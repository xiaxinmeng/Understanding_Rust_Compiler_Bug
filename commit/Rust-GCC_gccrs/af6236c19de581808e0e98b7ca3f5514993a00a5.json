{"sha": "af6236c19de581808e0e98b7ca3f5514993a00a5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWY2MjM2YzE5ZGU1ODE4MDhlMGU5OGI3Y2EzZjU1MTQ5OTNhMDBhNQ==", "commit": {"author": {"name": "Alexandre Oliva", "email": "aoliva@redhat.com", "date": "2013-01-18T10:58:15Z"}, "committer": {"name": "Alexandre Oliva", "email": "aoliva@gcc.gnu.org", "date": "2013-01-18T10:58:15Z"}, "message": "re PR debug/54114 (VTA compile-time performance could be improved)\n\nPR debug/54114\nPR debug/54402\nPR debug/49888\n* var-tracking.c (negative_power_of_two_p): New.\n(global_get_addr_cache, local_get_addr_cache): New.\n(get_addr_from_global_cache, get_addr_from_local_cache): New.\n(vt_canonicalize_addr): Rewrite using the above.  Adjust the\nheading comment.\n(vt_stack_offset_p): Remove.\n(vt_canon_true_dep): Always canonicalize loc's address.\n(clobber_overlapping_mems): Make sure we have a MEM.\n(local_get_addr_clear_given_value): New.\n(val_reset): Clear local cached entries.\n(compute_bb_dataflow): Create and release the local cache.\nDisable duplicate MEMs clobbering.\n(emit_notes_in_bb): Clobber MEMs likewise.\n(vt_emit_notes): Create and release the local cache.\n(vt_initialize, vt_finalize): Create and release the global\ncache, respectively.\n* alias.c (rtx_equal_for_memref_p): Compare operands of\nENTRY_VALUEs.\n\nFrom-SVN: r195291", "tree": {"sha": "99bb20202acf93837191e504d606842487027e5c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/99bb20202acf93837191e504d606842487027e5c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/af6236c19de581808e0e98b7ca3f5514993a00a5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/af6236c19de581808e0e98b7ca3f5514993a00a5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/af6236c19de581808e0e98b7ca3f5514993a00a5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/af6236c19de581808e0e98b7ca3f5514993a00a5/comments", "author": null, "committer": null, "parents": [{"sha": "7ff37ffa0865c4c7c5610009916d66927d14c258", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7ff37ffa0865c4c7c5610009916d66927d14c258", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7ff37ffa0865c4c7c5610009916d66927d14c258"}], "stats": {"total": 321, "additions": 255, "deletions": 66}, "files": [{"sha": "26e7c7249737b89852bfefa48e16f0a3cf4c4cf2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af6236c19de581808e0e98b7ca3f5514993a00a5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af6236c19de581808e0e98b7ca3f5514993a00a5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=af6236c19de581808e0e98b7ca3f5514993a00a5", "patch": "@@ -1,3 +1,27 @@\n+2013-01-18  Alexandre Oliva <aoliva@redhat.com>\n+\n+\tPR debug/54114\n+\tPR debug/54402\n+\tPR debug/49888\n+\t* var-tracking.c (negative_power_of_two_p): New.\n+\t(global_get_addr_cache, local_get_addr_cache): New.\n+\t(get_addr_from_global_cache, get_addr_from_local_cache): New.\n+\t(vt_canonicalize_addr): Rewrite using the above.  Adjust the\n+\theading comment.\n+\t(vt_stack_offset_p): Remove.\n+\t(vt_canon_true_dep): Always canonicalize loc's address.\n+\t(clobber_overlapping_mems): Make sure we have a MEM.\n+\t(local_get_addr_clear_given_value): New.\n+\t(val_reset): Clear local cached entries.\n+\t(compute_bb_dataflow): Create and release the local cache.\n+\tDisable duplicate MEMs clobbering.\n+\t(emit_notes_in_bb): Clobber MEMs likewise.\n+\t(vt_emit_notes): Create and release the local cache.\n+\t(vt_initialize, vt_finalize): Create and release the global\n+\tcache, respectively.\n+\t* alias.c (rtx_equal_for_memref_p): Compare operands of\n+\tENTRY_VALUEs.\n+\n 2013-01-18  Alexandre Oliva <aoliva@redhat.com>\n \n \tPR libmudflap/53359"}, {"sha": "e18dd342f6d573d123376cf7b1ccb51cef3a75ef", "filename": "gcc/alias.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af6236c19de581808e0e98b7ca3f5514993a00a5/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af6236c19de581808e0e98b7ca3f5514993a00a5/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=af6236c19de581808e0e98b7ca3f5514993a00a5", "patch": "@@ -1465,6 +1465,10 @@ rtx_equal_for_memref_p (const_rtx x, const_rtx y)\n     case SYMBOL_REF:\n       return XSTR (x, 0) == XSTR (y, 0);\n \n+    case ENTRY_VALUE:\n+      /* This is magic, don't go through canonicalization et al.  */\n+      return rtx_equal_p (ENTRY_VALUE_EXP (x), ENTRY_VALUE_EXP (y));\n+\n     case VALUE:\n     CASE_CONST_UNIQUE:\n       /* There's no need to compare the contents of CONST_DOUBLEs or"}, {"sha": "714acb69692f8e9d53f627c928d16186d0104222", "filename": "gcc/var-tracking.c", "status": "modified", "additions": 227, "deletions": 66, "changes": 293, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af6236c19de581808e0e98b7ca3f5514993a00a5/gcc%2Fvar-tracking.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af6236c19de581808e0e98b7ca3f5514993a00a5/gcc%2Fvar-tracking.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvar-tracking.c?ref=af6236c19de581808e0e98b7ca3f5514993a00a5", "patch": "@@ -1948,6 +1948,14 @@ var_regno_delete (dataflow_set *set, int regno)\n   *reg = NULL;\n }\n \n+/* Return true if I is the negated value of a power of two.  */\n+static bool\n+negative_power_of_two_p (HOST_WIDE_INT i)\n+{\n+  unsigned HOST_WIDE_INT x = -(unsigned HOST_WIDE_INT)i;\n+  return x == (x & -x);\n+}\n+\n /* Strip constant offsets and alignments off of LOC.  Return the base\n    expression.  */\n \n@@ -1958,83 +1966,191 @@ vt_get_canonicalize_base (rtx loc)\n \t  || GET_CODE (loc) == AND)\n \t && GET_CODE (XEXP (loc, 1)) == CONST_INT\n \t && (GET_CODE (loc) != AND\n-\t     || INTVAL (XEXP (loc, 1)) < 0))\n+\t     || negative_power_of_two_p (INTVAL (XEXP (loc, 1)))))\n     loc = XEXP (loc, 0);\n \n   return loc;\n }\n \n+/* This caches canonicalized addresses for VALUEs, computed using\n+   information in the global cselib table.  */\n+static struct pointer_map_t *global_get_addr_cache;\n+\n+/* This caches canonicalized addresses for VALUEs, computed using\n+   information from the global cache and information pertaining to a\n+   basic block being analyzed.  */\n+static struct pointer_map_t *local_get_addr_cache;\n+\n+static rtx vt_canonicalize_addr (dataflow_set *, rtx);\n+\n+/* Return the canonical address for LOC, that must be a VALUE, using a\n+   cached global equivalence or computing it and storing it in the\n+   global cache.  */\n+\n+static rtx\n+get_addr_from_global_cache (rtx const loc)\n+{\n+  rtx x;\n+  void **slot;\n+\n+  gcc_checking_assert (GET_CODE (loc) == VALUE);\n+  \n+  slot = pointer_map_insert (global_get_addr_cache, loc);\n+  if (*slot)\n+    return (rtx)*slot;\n+\n+  x = canon_rtx (get_addr (loc));\n+\n+  /* Tentative, avoiding infinite recursion.  */\n+  *slot = x;\n+\n+  if (x != loc)\n+    {\n+      rtx nx = vt_canonicalize_addr (NULL, x);\n+      if (nx != x)\n+\t{\n+\t  /* The table may have moved during recursion, recompute\n+\t     SLOT.  */\n+\t  slot = pointer_map_contains (global_get_addr_cache, loc);\n+\t  *slot = x = nx;\n+\t}\n+    }\n+\n+  return x;\n+}\n+\n+/* Return the canonical address for LOC, that must be a VALUE, using a\n+   cached local equivalence or computing it and storing it in the\n+   local cache.  */\n+\n+static rtx\n+get_addr_from_local_cache (dataflow_set *set, rtx const loc)\n+{\n+  rtx x;\n+  void **slot;\n+  decl_or_value dv;\n+  variable var;\n+  location_chain l;\n+\n+  gcc_checking_assert (GET_CODE (loc) == VALUE);\n+  \n+  slot = pointer_map_insert (local_get_addr_cache, loc);\n+  if (*slot)\n+    return (rtx)*slot;\n+\n+  x = get_addr_from_global_cache (loc);\n+  \n+  /* Tentative, avoiding infinite recursion.  */\n+  *slot = x;\n+\n+  /* Recurse to cache local expansion of X, or if we need to search\n+     for a VALUE in the expansion.  */\n+  if (x != loc)\n+    {\n+      rtx nx = vt_canonicalize_addr (set, x);\n+      if (nx != x)\n+\t{\n+\t  slot = pointer_map_contains (local_get_addr_cache, loc);\n+\t  *slot = x = nx;\n+\t}\n+      return x;\n+    }\n+\n+  dv = dv_from_rtx (x);\n+  var = (variable) htab_find_with_hash (shared_hash_htab (set->vars),\n+\t\t\t\t\tdv, dv_htab_hash (dv));\n+  if (!var)\n+    return x;\n+\n+  /* Look for an improved equivalent expression.  */\n+  for (l = var->var_part[0].loc_chain; l; l = l->next)\n+    {\n+      rtx base = vt_get_canonicalize_base (l->loc);\n+      if (GET_CODE (base) == VALUE\n+\t  && canon_value_cmp (base, loc))\n+\t{\n+\t  rtx nx = vt_canonicalize_addr (set, l->loc);\n+\t  if (x != nx)\n+\t    {\n+\t      slot = pointer_map_contains (local_get_addr_cache, loc);\n+\t      *slot = x = nx;\n+\t    }\n+\t  break;\n+\t}\n+    }\n+\n+  return x;\n+}\n+\n /* Canonicalize LOC using equivalences from SET in addition to those\n-   in the cselib static table.  */\n+   in the cselib static table.  It expects a VALUE-based expression,\n+   and it will only substitute VALUEs with other VALUEs or\n+   function-global equivalences, so that, if two addresses have base\n+   VALUEs that are locally or globally related in ways that\n+   memrefs_conflict_p cares about, they will both canonicalize to\n+   expressions that have the same base VALUE.\n+\n+   The use of VALUEs as canonical base addresses enables the canonical\n+   RTXs to remain unchanged globally, if they resolve to a constant,\n+   or throughout a basic block otherwise, so that they can be cached\n+   and the cache needs not be invalidated when REGs, MEMs or such\n+   change.  */\n \n static rtx\n vt_canonicalize_addr (dataflow_set *set, rtx oloc)\n {\n   HOST_WIDE_INT ofst = 0;\n   enum machine_mode mode = GET_MODE (oloc);\n-  rtx loc = canon_rtx (get_addr (oloc));\n+  rtx loc = oloc;\n+  rtx x;\n+  bool retry = true;\n \n-  /* Try to substitute a base VALUE for equivalent expressions as much\n-     as possible.  The goal here is to expand stack-related addresses\n-     to one of the stack base registers, so that we can compare\n-     addresses for overlaps.  */\n-  while (GET_CODE (vt_get_canonicalize_base (loc)) == VALUE)\n+  while (retry)\n     {\n-      rtx x;\n-      decl_or_value dv;\n-      variable var;\n-      location_chain l;\n-\n-      while (GET_CODE (loc) == PLUS)\n+      while (GET_CODE (loc) == PLUS\n+\t     && GET_CODE (XEXP (loc, 1)) == CONST_INT)\n \t{\n \t  ofst += INTVAL (XEXP (loc, 1));\n \t  loc = XEXP (loc, 0);\n-\t  continue;\n \t}\n \n       /* Alignment operations can't normally be combined, so just\n \t canonicalize the base and we're done.  We'll normally have\n \t only one stack alignment anyway.  */\n-      if (GET_CODE (loc) == AND)\n+      if (GET_CODE (loc) == AND\n+\t  && GET_CODE (XEXP (loc, 1)) == CONST_INT\n+\t  && negative_power_of_two_p (INTVAL (XEXP (loc, 1))))\n \t{\n \t  x = vt_canonicalize_addr (set, XEXP (loc, 0));\n \t  if (x != XEXP (loc, 0))\n \t    loc = gen_rtx_AND (mode, x, XEXP (loc, 1));\n-\t  loc = canon_rtx (get_addr (loc));\n-\t  break;\n+\t  retry = false;\n \t}\n \n-      x = canon_rtx (get_addr (loc));\n-\n-      /* We've made progress!  Start over.  */\n-      if (x != loc || GET_CODE (x) != VALUE)\n+      if (GET_CODE (loc) == VALUE)\n \t{\n-\t  loc = x;\n-\t  continue;\n-\t}\n-\n-      dv = dv_from_rtx (x);\n-      var = (variable) htab_find_with_hash (shared_hash_htab (set->vars),\n-\t\t\t\t\t    dv, dv_htab_hash (dv));\n-      if (!var)\n-\tbreak;\n+\t  if (set)\n+\t    loc = get_addr_from_local_cache (set, loc);\n+\t  else\n+\t    loc = get_addr_from_global_cache (loc);\n \n-      /* Look for an improved equivalent expression.  */\n-      for (l = var->var_part[0].loc_chain; l; l = l->next)\n-\t{\n-\t  rtx base = vt_get_canonicalize_base (l->loc);\n-\t  if (GET_CODE (base) == REG\n-\t      || (GET_CODE (base) == VALUE\n-\t\t  && canon_value_cmp (base, loc)))\n+\t  /* Consolidate plus_constants.  */\n+\t  while (ofst && GET_CODE (loc) == PLUS\n+\t\t && GET_CODE (XEXP (loc, 1)) == CONST_INT)\n \t    {\n-\t      loc = l->loc;\n-\t      break;\n+\t      ofst += INTVAL (XEXP (loc, 1));\n+\t      loc = XEXP (loc, 0);\n \t    }\n-\t}\n \n-      /* No luck with the dataflow set, so we're done.  */\n-      if (!l)\n-\tbreak;\n+\t  retry = false;\n+\t}\n+      else\n+\t{\n+\t  x = canon_rtx (loc);\n+\t  if (retry)\n+\t    retry = (x != loc);\n+\t  loc = x;\n+\t}\n     }\n \n   /* Add OFST back in.  */\n@@ -2052,19 +2168,6 @@ vt_canonicalize_addr (dataflow_set *set, rtx oloc)\n   return loc;\n }\n \n-/* Return true iff ADDR has a stack register as the base address.  */\n-\n-static inline bool\n-vt_stack_offset_p (rtx addr)\n-{\n-  rtx base = vt_get_canonicalize_base (addr);\n-\n-  if (GET_CODE (base) != REG)\n-    return false;\n-\n-  return REGNO_PTR_FRAME_P (REGNO (base));\n-}\n-\n /* Return true iff there's a true dependence between MLOC and LOC.\n    MADDR must be a canonicalized version of MLOC's address.  */\n \n@@ -2074,15 +2177,10 @@ vt_canon_true_dep (dataflow_set *set, rtx mloc, rtx maddr, rtx loc)\n   if (GET_CODE (loc) != MEM)\n     return false;\n \n-  if (!canon_true_dependence (mloc, GET_MODE (mloc), maddr, loc, NULL))\n+  rtx addr = vt_canonicalize_addr (set, XEXP (loc, 0));\n+  if (!canon_true_dependence (mloc, GET_MODE (mloc), maddr, loc, addr))\n     return false;\n \n-  if (!MEM_EXPR (loc) && vt_stack_offset_p (maddr))\n-    {\n-      rtx addr = vt_canonicalize_addr (set, XEXP (loc, 0));\n-      return canon_true_dependence (mloc, GET_MODE (mloc), maddr, loc, addr);\n-    }\n-\n   return true;\n }\n \n@@ -2177,6 +2275,8 @@ clobber_overlapping_mems (dataflow_set *set, rtx loc)\n {\n   struct overlapping_mems coms;\n \n+  gcc_checking_assert (GET_CODE (loc) == MEM);\n+\n   coms.set = set;\n   coms.loc = canon_rtx (loc);\n   coms.addr = vt_canonicalize_addr (set, XEXP (loc, 0));\n@@ -2358,6 +2458,17 @@ val_store (dataflow_set *set, rtx val, rtx loc, rtx insn, bool modified)\n   val_bind (set, val, loc, modified);\n }\n \n+/* Clear (canonical address) slots that reference X.  */\n+\n+static bool\n+local_get_addr_clear_given_value (const void *v ATTRIBUTE_UNUSED,\n+\t\t\t\t  void **slot, void *x)\n+{\n+  if (vt_get_canonicalize_base ((rtx)*slot) == x)\n+    *slot = NULL;\n+  return true;\n+}\n+\n /* Reset this node, detaching all its equivalences.  Return the slot\n    in the variable hash table that holds dv, if there is one.  */\n \n@@ -2373,6 +2484,28 @@ val_reset (dataflow_set *set, decl_or_value dv)\n \n   gcc_assert (var->n_var_parts == 1);\n \n+  if (var->onepart == ONEPART_VALUE)\n+    {\n+      rtx x = dv_as_value (dv);\n+      void **slot;\n+      \n+      /* Relationships in the global cache don't change, so reset the\n+\t local cache entry only.  */\n+      slot = pointer_map_contains (local_get_addr_cache, x);\n+      if (slot)\n+\t{\n+\t  /* If the value resolved back to itself, odds are that other\n+\t     values may have cached it too.  These entries now refer\n+\t     to the old X, so detach them too.  Entries that used the\n+\t     old X but resolved to something else remain ok as long as\n+\t     that something else isn't also reset.  */\n+\t  if (*slot == x)\n+\t    pointer_map_traverse (local_get_addr_cache,\n+\t\t\t\t  local_get_addr_clear_given_value, x);\n+\t  *slot = NULL;\n+\t}\n+    }\n+\n   cval = NULL;\n   for (node = var->var_part[0].loc_chain; node; node = node->next)\n     if (GET_CODE (node->loc) == VALUE\n@@ -6424,6 +6557,9 @@ compute_bb_dataflow (basic_block bb)\n   dataflow_set_copy (&old_out, out);\n   dataflow_set_copy (out, in);\n \n+  if (MAY_HAVE_DEBUG_INSNS)\n+    local_get_addr_cache = pointer_map_create ();\n+\n   FOR_EACH_VEC_ELT (VTI (bb)->mos, i, mo)\n     {\n       rtx insn = mo->insn;\n@@ -6613,7 +6749,12 @@ compute_bb_dataflow (basic_block bb)\n \t      else if (REG_P (uloc))\n \t\tvar_regno_delete (out, REGNO (uloc));\n \t      else if (MEM_P (uloc))\n-\t\tclobber_overlapping_mems (out, uloc);\n+\t\t{\n+\t\t  gcc_checking_assert (GET_CODE (vloc) == MEM);\n+\t\t  gcc_checking_assert (dstv == vloc);\n+\t\t  if (dstv != vloc)\n+\t\t    clobber_overlapping_mems (out, vloc);\n+\t\t}\n \n \t      val_store (out, val, dstv, insn, true);\n \t    }\n@@ -6700,6 +6841,9 @@ compute_bb_dataflow (basic_block bb)\n \n   if (MAY_HAVE_DEBUG_INSNS)\n     {\n+      pointer_map_destroy (local_get_addr_cache);\n+      local_get_addr_cache = NULL;\n+\n       dataflow_set_equiv_regs (out);\n       htab_traverse (shared_hash_htab (out->vars), canonicalize_values_mark,\n \t\t     out);\n@@ -9113,7 +9257,12 @@ emit_notes_in_bb (basic_block bb, dataflow_set *set)\n \t      else if (REG_P (uloc))\n \t\tvar_regno_delete (set, REGNO (uloc));\n \t      else if (MEM_P (uloc))\n-\t\tclobber_overlapping_mems (set, uloc);\n+\t\t{\n+\t\t  gcc_checking_assert (GET_CODE (vloc) == MEM);\n+\t\t  gcc_checking_assert (vloc == dstv);\n+\t\t  if (vloc != dstv)\n+\t\t    clobber_overlapping_mems (set, vloc);\n+\t\t}\n \n \t      val_store (set, val, dstv, insn, true);\n \n@@ -9240,9 +9389,16 @@ vt_emit_notes (void)\n \t subsequent basic blocks.  */\n       emit_notes_for_differences (BB_HEAD (bb), &cur, &VTI (bb)->in);\n \n+      if (MAY_HAVE_DEBUG_INSNS)\n+\tlocal_get_addr_cache = pointer_map_create ();\n+\n       /* Emit the notes for the changes in the basic block itself.  */\n       emit_notes_in_bb (bb, &cur);\n \n+      if (MAY_HAVE_DEBUG_INSNS)\n+\tpointer_map_destroy (local_get_addr_cache);\n+      local_get_addr_cache = NULL;\n+\n       /* Free memory occupied by the in hash table, we won't need it\n \t again.  */\n       dataflow_set_clear (&VTI (bb)->in);\n@@ -9611,11 +9767,13 @@ vt_initialize (void)\n       valvar_pool = create_alloc_pool (\"small variable_def pool\",\n \t\t\t\t       sizeof (struct variable_def), 256);\n       preserved_values.create (256);\n+      global_get_addr_cache = pointer_map_create ();\n     }\n   else\n     {\n       scratch_regs = NULL;\n       valvar_pool = NULL;\n+      global_get_addr_cache = NULL;\n     }\n \n   if (MAY_HAVE_DEBUG_INSNS)\n@@ -9952,6 +10110,9 @@ vt_finalize (void)\n \n   if (MAY_HAVE_DEBUG_INSNS)\n     {\n+      if (global_get_addr_cache)\n+\tpointer_map_destroy (global_get_addr_cache);\n+      global_get_addr_cache = NULL;\n       if (loc_exp_dep_pool)\n \tfree_alloc_pool (loc_exp_dep_pool);\n       loc_exp_dep_pool = NULL;"}]}