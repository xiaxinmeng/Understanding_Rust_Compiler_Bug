{"sha": "561642fa67798158762265f5100e3052275fe970", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTYxNjQyZmE2Nzc5ODE1ODc2MjI2NWY1MTAwZTMwNTIyNzVmZTk3MA==", "commit": {"author": {"name": "Anil Paranjape", "email": "anil.paranjape@kpitcummins.com", "date": "2008-03-25T13:32:13Z"}, "committer": {"name": "Kaz Kojima", "email": "kkojima@gcc.gnu.org", "date": "2008-03-25T13:32:13Z"}, "message": "sh.c (SH_ATTRIBUTES): Define.\n\n\t* config/sh/sh.c (SH_ATTRIBUTES): Define.\n\t(SYMBOL_FLAG_FUNCVEC_FUNCTION): Define.\n\t(print_operand): Handle resbank in %@ operand code.\n\t(sh_encode_section_info): New.\n\t(push_regs): Add conditions for resbank.\n\t(sh_expand_epilogue): Likewise.\n\t(sh_insert_attributes): Likewise.\n\t(sh_attribute_table): Likewise.\n\t(sh_handle_resbank_handler_attribute): New.\n\t(sh2a_handle_function_vector_handler_attribute): New.\n\t(sh2a_is_function_vector_call): New.\n\t(sh2a_get_function_vector_number): New.\n\t(sh2a_function_vector_p): New.\n\t(sh_cfun_resbank_handler_p): New.\n\t* config/sh/sh.md (calli): Emit jsr/n if possible.\n\t(calli_tbr_rel): New.\n\t(calli_pcrel): Emit jsr/n if possible.\n\t(return_i): Emit rts/n if possible.\n\t(call_valuei_tbr_rel): New.\n\t(call_valuei_pcrel): Add condition for SH2A target.\n\t(call_value): Likewise.\n\t* config/sh/sh-protos.h (sh_cfun_resbank_handler_p): Declare.\n\t(sh2a_get_function_vector_number): Likewise.\n\t(sh2a_is_function_vector_call): Likewise.\n\t* doc/extend.texi: Document TBR relative addressing of SH2A.\n\t(resbank): Add description for SH2A.\n\n\t* gcc.target/sh/sh2a-resbank.c: New test.\n\t* gcc.target/sh/sh2a-tbr-jump.c: New test.\n\t* gcc.target/sh/sh2a-jsrn.c: New test.\n\t* gcc.target/sh/sh2a-rtsn.c: New test.\n\n\nCo-Authored-By: Jayant R Sonar <jayant.sonar@kpitcummins.com>\nCo-Authored-By: Naveen.H.S <naveen.hs@kpitcummins.com>\n\nFrom-SVN: r133513", "tree": {"sha": "9d545fbf7312945f348908340895704e9ccd4110", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9d545fbf7312945f348908340895704e9ccd4110"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/561642fa67798158762265f5100e3052275fe970", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/561642fa67798158762265f5100e3052275fe970", "html_url": "https://github.com/Rust-GCC/gccrs/commit/561642fa67798158762265f5100e3052275fe970", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/561642fa67798158762265f5100e3052275fe970/comments", "author": null, "committer": null, "parents": [{"sha": "53b308f61e96c47b54abf5c7db2e9831cbc43e66", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/53b308f61e96c47b54abf5c7db2e9831cbc43e66", "html_url": "https://github.com/Rust-GCC/gccrs/commit/53b308f61e96c47b54abf5c7db2e9831cbc43e66"}], "stats": {"total": 471, "additions": 454, "deletions": 17}, "files": [{"sha": "071d094d4db635962c3a82b5323e5e84db245558", "filename": "gcc/ChangeLog", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/561642fa67798158762265f5100e3052275fe970/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/561642fa67798158762265f5100e3052275fe970/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=561642fa67798158762265f5100e3052275fe970", "patch": "@@ -1,3 +1,34 @@\n+2008-03-25  Anil Paranjape  <anil.paranjape@kpitcummins.com>\n+\t    Jayant Sonar  <Jayant.sonar@kpitcummins.com>\n+\t    Naveen.H.S  <naveen.hs@kpitcummins.com>\n+\n+\t* config/sh/sh.c (SH_ATTRIBUTES): Define.\n+\t(SYMBOL_FLAG_FUNCVEC_FUNCTION): Define.\n+\t(print_operand): Handle resbank in %@ operand code.\n+\t(sh_encode_section_info): New.\n+\t(push_regs): Add conditions for resbank.\n+\t(sh_expand_epilogue): Likewise.\n+\t(sh_insert_attributes): Likewise.\n+\t(sh_attribute_table): Likewise.\n+\t(sh_handle_resbank_handler_attribute): New.\n+\t(sh2a_handle_function_vector_handler_attribute): New.\n+\t(sh2a_is_function_vector_call): New.\n+\t(sh2a_get_function_vector_number): New.\n+\t(sh2a_function_vector_p): New.\n+\t(sh_cfun_resbank_handler_p): New.\n+\t* config/sh/sh.md (calli): Emit jsr/n if possible.\n+\t(calli_tbr_rel): New.\n+\t(calli_pcrel): Emit jsr/n if possible.\n+\t(return_i): Emit rts/n if possible.\n+\t(call_valuei_tbr_rel): New.\n+\t(call_valuei_pcrel): Add condition for SH2A target.\n+\t(call_value): Likewise.\n+\t* config/sh/sh-protos.h (sh_cfun_resbank_handler_p): Declare.\n+\t(sh2a_get_function_vector_number): Likewise.\n+\t(sh2a_is_function_vector_call): Likewise.\n+\t* doc/extend.texi: Document TBR relative addressing of SH2A.\n+\t(resbank): Add description for SH2A.\n+\n 2008-03-24  Richard Guenther  <rguenther@suse.de>\n \n \tPR c/22371"}, {"sha": "9e1a48823543e1e110e21d9798231729b8b35c47", "filename": "gcc/config/sh/sh-protos.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/561642fa67798158762265f5100e3052275fe970/gcc%2Fconfig%2Fsh%2Fsh-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/561642fa67798158762265f5100e3052275fe970/gcc%2Fconfig%2Fsh%2Fsh-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh-protos.h?ref=561642fa67798158762265f5100e3052275fe970", "patch": "@@ -134,6 +134,7 @@ extern int initial_elimination_offset (int, int);\n extern int fldi_ok (void);\n extern int sh_hard_regno_rename_ok (unsigned int, unsigned int);\n extern int sh_cfun_interrupt_handler_p (void);\n+extern int sh_cfun_resbank_handler_p (void);\n extern int sh_attr_renesas_p (const_tree);\n extern int sh_cfun_attr_renesas_p (void);\n extern void sh_initialize_trampoline (rtx, rtx, rtx);\n@@ -170,6 +171,8 @@ struct secondary_reload_info;\n extern enum reg_class sh_secondary_reload (bool, rtx, enum reg_class,\n \t\t\t\t\t   enum machine_mode,\n \t\t\t\t\t   struct secondary_reload_info *);\n+extern int sh2a_get_function_vector_number (rtx);\n+extern int sh2a_is_function_vector_call (rtx);\n \n #endif /* ! GCC_SH_PROTOS_H */\n "}, {"sha": "57049ea738f070f8a53aa54ab03afd40f3e2ef07", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 224, "deletions": 13, "changes": 237, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/561642fa67798158762265f5100e3052275fe970/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/561642fa67798158762265f5100e3052275fe970/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=561642fa67798158762265f5100e3052275fe970", "patch": "@@ -69,6 +69,14 @@ int code_for_indirect_jump_scratch = CODE_FOR_indirect_jump_scratch;\n #define GEN_ADD3 (*(TARGET_SHMEDIA64 ? gen_adddi3 : gen_addsi3))\n #define GEN_SUB3 (*(TARGET_SHMEDIA64 ? gen_subdi3 : gen_subsi3))\n \n+/* Used to simplify the logic below.  Find the attributes wherever\n+   they may be.  */\n+#define SH_ATTRIBUTES(decl) \\\n+  (TYPE_P (decl)) ? TYPE_ATTRIBUTES (decl) \\\n+\t\t  : DECL_ATTRIBUTES (decl) \\\n+\t\t  ? (DECL_ATTRIBUTES (decl)) \\\n+\t\t  : TYPE_ATTRIBUTES (TREE_TYPE (decl))\n+\n /* Set to 1 by expand_prologue() when the function is an interrupt handler.  */\n int current_function_interrupt;\n \n@@ -185,6 +193,10 @@ static HOST_WIDE_INT rounded_frame_size (int);\n static rtx mark_constant_pool_use (rtx);\n const struct attribute_spec sh_attribute_table[];\n static tree sh_handle_interrupt_handler_attribute (tree *, tree, tree, int, bool *);\n+static tree sh_handle_resbank_handler_attribute (tree *, tree,\n+\t\t\t\t\t\t tree, int, bool *);\n+static tree sh2a_handle_function_vector_handler_attribute (tree *, tree,\n+\t\t\t\t\t\t\t   tree, int, bool *);\n static tree sh_handle_sp_switch_attribute (tree *, tree, tree, int, bool *);\n static tree sh_handle_trap_exit_attribute (tree *, tree, tree, int, bool *);\n static tree sh_handle_renesas_attribute (tree *, tree, tree, int, bool *);\n@@ -258,6 +270,8 @@ static int sh_arg_partial_bytes (CUMULATIVE_ARGS *, enum machine_mode,\n \t\t\t         tree, bool);\n static bool sh_scalar_mode_supported_p (enum machine_mode);\n static int sh_dwarf_calling_convention (const_tree);\n+static void sh_encode_section_info (tree, rtx, int);\n+static int sh2a_function_vector_p (tree);\n \n \f\n /* Initialize the GCC target structure.  */\n@@ -449,6 +463,9 @@ static int sh_dwarf_calling_convention (const_tree);\n /* Return current register pressure for regmode.  */\n #define CURR_REGMODE_PRESSURE(MODE) \tcurr_regmode_pressure[((MODE) == SImode) ? 0 : 1]\n \n+#undef  TARGET_ENCODE_SECTION_INFO\n+#define TARGET_ENCODE_SECTION_INFO\tsh_encode_section_info\n+\n #ifdef SYMBIAN\n \n #undef  TARGET_ENCODE_SECTION_INFO\n@@ -463,6 +480,9 @@ static int sh_dwarf_calling_convention (const_tree);\n #undef TARGET_SECONDARY_RELOAD\n #define TARGET_SECONDARY_RELOAD sh_secondary_reload\n \n+/* Machine-specific symbol_ref flags.  */\n+#define SYMBOL_FLAG_FUNCVEC_FUNCTION    (SYMBOL_FLAG_MACH_DEP << 0)\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n /* Implement TARGET_HANDLE_OPTION.  */\n@@ -690,7 +710,11 @@ print_operand (FILE *stream, rtx x, int code)\n \tfprintf (stream, \"trapa #%ld\",\n \t\t (long) TREE_INT_CST_LOW (TREE_VALUE (TREE_VALUE (trapa_attr))));\n       else if (sh_cfun_interrupt_handler_p ())\n-\tfprintf (stream, \"rte\");\n+\t{\n+\t  if (sh_cfun_resbank_handler_p ())\n+\t    fprintf (stream, \"resbank\\n\");\n+\t  fprintf (stream, \"rte\");\n+\t}\n       else\n \tfprintf (stream, \"rts\");\n       break;\n@@ -1022,6 +1046,19 @@ print_operand (FILE *stream, rtx x, int code)\n     }\n }\n \f\n+\n+/* Encode symbol attributes of a SYMBOL_REF into its\n+   SYMBOL_REF_FLAGS.  */\n+static void\n+sh_encode_section_info (tree decl, rtx rtl, int first)\n+{\n+  default_encode_section_info (decl, rtl, first);\n+\n+  if (TREE_CODE (decl) == FUNCTION_DECL\n+      && sh2a_function_vector_p (decl) && TARGET_SH2A)\n+    SYMBOL_REF_FLAGS (XEXP (rtl, 0)) |= SYMBOL_FLAG_FUNCVEC_FUNCTION;\n+}\n+\n /* Like force_operand, but guarantees that VALUE ends up in TARGET.  */\n static void\n force_into (rtx value, rtx target)\n@@ -5767,7 +5804,16 @@ push_regs (HARD_REG_SET *mask, int interrupt_handler)\n       if (i != PR_REG\n \t  && (i != FPSCR_REG || ! skip_fpscr)\n \t  && TEST_HARD_REG_BIT (*mask, i))\n-\tpush (i);\n+           {\n+  \t/* If the ISR has RESBANK attribute assigned, don't push any of\n+   \t   the following registers - R0-R14, MACH, MACL and GBR.  */\n+      if (! (sh_cfun_resbank_handler_p ()\n+\t     && ((i >= FIRST_GENERAL_REG && i < LAST_GENERAL_REG)\n+\t\t || i == MACH_REG\n+\t\t || i == MACL_REG\n+\t\t || i == GBR_REG)))\n+\t  push (i);\n+  \t}\n     }\n \n   /* Push banked registers last to improve delay slot opportunities.  */\n@@ -5776,7 +5822,8 @@ push_regs (HARD_REG_SET *mask, int interrupt_handler)\n       if (TEST_HARD_REG_BIT (*mask, i))\n \tpush (i);\n \n-  if (TEST_HARD_REG_BIT (*mask, PR_REG))\n+  /* Don't push PR register for an ISR with RESBANK attribute assigned.  */\n+  if (TEST_HARD_REG_BIT (*mask, PR_REG) && !sh_cfun_resbank_handler_p ())\n     push (PR_REG);\n }\n \n@@ -6705,7 +6752,10 @@ sh_expand_epilogue (bool sibcall_p)\n       int last_reg;\n \n       save_size = 0;\n-      if (TEST_HARD_REG_BIT (live_regs_mask, PR_REG))\n+\t/* For an ISR with RESBANK attribute assigned, don't pop PR\n+\t   register.  */\n+      if (TEST_HARD_REG_BIT (live_regs_mask, PR_REG)\n+\t  && !sh_cfun_resbank_handler_p ())\t\n \t{\n \t  if (!frame_pointer_needed)\n \t    emit_insn (gen_blockage ());\n@@ -6733,7 +6783,15 @@ sh_expand_epilogue (bool sibcall_p)\n \t      && hard_reg_set_intersect_p (live_regs_mask,\n \t\t\t\t\t  reg_class_contents[DF_REGS]))\n \t    fpscr_deferred = 1;\n-\t  else if (j != PR_REG && TEST_HARD_REG_BIT (live_regs_mask, j))\n+\t  /* For an ISR with RESBANK attribute assigned, don't pop\n+\t     following registers, R0-R14, MACH, MACL and GBR.  */\n+\t  else if (j != PR_REG && TEST_HARD_REG_BIT (live_regs_mask, j) \n+\t\t   && ! (sh_cfun_resbank_handler_p ()\n+\t\t\t && ((j >= FIRST_GENERAL_REG\n+\t\t\t      && j < LAST_GENERAL_REG)\n+\t\t\t      || j == MACH_REG\n+\t\t\t      || j == MACL_REG\n+\t\t\t      || j == GBR_REG)))\n \t    pop (j);\n \n \t  if (j == FIRST_FP_REG && fpscr_deferred)\n@@ -7904,19 +7962,22 @@ sh_insert_attributes (tree node, tree *attributes)\n \t   java frontend.  */\n \tattrs\n \t  = tree_cons (get_identifier(\"interrupt_handler\"), NULL_TREE, attrs);\n-      /* However, for sp_switch, trap_exit and nosave_low_regs, if the\n-\t interrupt attribute is missing, we ignore the attribute and warn.  */\n+      /* However, for sp_switch, trap_exit, nosave_low_regs and resbank,\n+\t if the interrupt attribute is missing, we ignore the attribute\n+\t and warn.  */\n       else if (lookup_attribute (\"sp_switch\", attrs)\n \t       || lookup_attribute (\"trap_exit\", attrs)\n-\t       || lookup_attribute (\"nosave_low_regs\", attrs))\n+\t       || lookup_attribute (\"nosave_low_regs\", attrs)\n+\t       || lookup_attribute (\"resbank\", attrs))\n \t{\n \t  tree *tail;\n \n \t  for (tail = attributes; attrs; attrs = TREE_CHAIN (attrs))\n \t    {\n \t      if (is_attribute_p (\"sp_switch\", TREE_PURPOSE (attrs))\n \t\t  || is_attribute_p (\"trap_exit\", TREE_PURPOSE (attrs))\n-\t\t  || is_attribute_p (\"nosave_low_regs\", TREE_PURPOSE (attrs)))\n+\t\t  || is_attribute_p (\"nosave_low_regs\", TREE_PURPOSE (attrs))\n+\t\t  || is_attribute_p (\"resbank\", TREE_PURPOSE (attrs)))\n \t\twarning (OPT_Wattributes,\n \t\t\t \"%qs attribute only applies to interrupt functions\",\n \t\t\t IDENTIFIER_POINTER (TREE_PURPOSE (attrs)));\n@@ -7963,6 +8024,8 @@ sh_insert_attributes (tree node, tree *attributes)\n    renesas -- use Renesas calling/layout conventions (functions and\n    structures).\n \n+   resbank -- In case of an ISR, use a register bank to save registers\n+   R0-R14, MACH, MACL, GBR and PR.  This is useful only on SH2A targets.\n */\n \n const struct attribute_spec sh_attribute_table[] =\n@@ -7974,6 +8037,8 @@ const struct attribute_spec sh_attribute_table[] =\n   { \"renesas\",           0, 0, false, true, false, sh_handle_renesas_attribute },\n   { \"trapa_handler\",     0, 0, true,  false, false, sh_handle_interrupt_handler_attribute },\n   { \"nosave_low_regs\",   0, 0, true,  false, false, sh_handle_interrupt_handler_attribute },\n+  { \"resbank\",           0, 0, true,  false, false, sh_handle_resbank_handler_attribute },\n+  { \"function_vector\",   1, 1, true,  false, false, sh2a_handle_function_vector_handler_attribute },\n #ifdef SYMBIAN\n   /* Symbian support adds three new attributes:\n      dllexport - for exporting a function/variable that will live in a dll\n@@ -7988,18 +8053,41 @@ const struct attribute_spec sh_attribute_table[] =\n   { NULL,                0, 0, false, false, false, NULL }\n };\n \n+/* Handle a 'resbank' attribute.  */\n+static tree\n+sh_handle_resbank_handler_attribute (tree * node, tree name,\n+                                     tree args ATTRIBUTE_UNUSED,\n+                                     int flags ATTRIBUTE_UNUSED,\n+                                     bool * no_add_attrs)\n+{\n+  if (!TARGET_SH2A)\n+    {\n+      warning (OPT_Wattributes, \"%qs attribute is supported only for SH2A\",\n+               IDENTIFIER_POINTER (name));\n+      *no_add_attrs = true;\n+    }\n+  if (TREE_CODE (*node) != FUNCTION_DECL)\n+    {\n+      warning (OPT_Wattributes, \"%qs attribute only applies to functions\",\n+               IDENTIFIER_POINTER (name));\n+      *no_add_attrs = true;\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n /* Handle an \"interrupt_handler\" attribute; arguments as in\n    struct attribute_spec.handler.  */\n static tree\n sh_handle_interrupt_handler_attribute (tree *node, tree name,\n-\t\t\t\t       tree args ATTRIBUTE_UNUSED,\n-\t\t\t\t       int flags ATTRIBUTE_UNUSED,\n-\t\t\t\t       bool *no_add_attrs)\n+                                       tree args ATTRIBUTE_UNUSED,\n+                                       int flags ATTRIBUTE_UNUSED,\n+                                       bool *no_add_attrs)\n {\n   if (TREE_CODE (*node) != FUNCTION_DECL)\n     {\n       warning (OPT_Wattributes, \"%qs attribute only applies to functions\",\n-\t       IDENTIFIER_POINTER (name));\n+               IDENTIFIER_POINTER (name));\n       *no_add_attrs = true;\n     }\n   else if (TARGET_SHCOMPACT)\n@@ -8011,6 +8099,96 @@ sh_handle_interrupt_handler_attribute (tree *node, tree name,\n   return NULL_TREE;\n }\n \n+/* Handle an 'function_vector' attribute; arguments as in\n+   struct attribute_spec.handler.  */\n+static tree\n+sh2a_handle_function_vector_handler_attribute (tree * node, tree name,\n+                                               tree args ATTRIBUTE_UNUSED,\n+                                               int flags ATTRIBUTE_UNUSED,\n+                                               bool * no_add_attrs)\n+{\n+  if (!TARGET_SH2A)\n+    {\n+      warning (OPT_Wattributes, \"%qs attribute only applies to SH2A\",\n+               IDENTIFIER_POINTER (name));\n+      *no_add_attrs = true;\n+    }\n+  else if (TREE_CODE (*node) != FUNCTION_DECL)\n+    {\n+      warning (OPT_Wattributes, \"%qs attribute only applies to functions\",\n+               IDENTIFIER_POINTER (name));\n+      *no_add_attrs = true;\n+    }\n+  else if (TREE_CODE (TREE_VALUE (args)) != INTEGER_CST)\n+    {\n+      /* The argument must be a constant integer.  */\n+      warning (OPT_Wattributes,\n+               \"`%s' attribute argument not an integer constant\",\n+               IDENTIFIER_POINTER (name));\n+      *no_add_attrs = true;\n+    }\n+  else if (TREE_INT_CST_LOW (TREE_VALUE (args)) > 255)\n+    {\n+      /* The argument value must be between 0 to 255.  */\n+      warning (OPT_Wattributes,\n+               \"`%s' attribute argument should be between 0 to 255\",\n+               IDENTIFIER_POINTER (name));\n+      *no_add_attrs = true;\n+    }\n+  return NULL_TREE;\n+}\n+\n+/* Returns 1 if current function has been assigned the attribute\n+   'function_vector'.  */\n+int\n+sh2a_is_function_vector_call (rtx x)\n+{\n+  if (GET_CODE (x) == SYMBOL_REF\n+      && (SYMBOL_REF_FLAGS (x) & SYMBOL_FLAG_FUNCVEC_FUNCTION))\n+    {\n+      tree tr = SYMBOL_REF_DECL (x);\n+\n+      if (sh2a_function_vector_p (tr))\n+        return 1;\n+    }\n+\n+  return 0;\n+}\n+\n+/* Returns the function vector number, if the the attribute\n+   'function_vector' is assigned, otherwise returns zero.  */\n+int\n+sh2a_get_function_vector_number (rtx x)\n+{\n+  int num;\n+  tree list, t;\n+\n+  if ((GET_CODE (x) == SYMBOL_REF)\n+      && (SYMBOL_REF_FLAGS (x) & SYMBOL_FLAG_FUNCVEC_FUNCTION))\n+    {\n+      t = SYMBOL_REF_DECL (x);\n+\n+      if (TREE_CODE (t) != FUNCTION_DECL)\n+        return 0;\n+\n+      list = SH_ATTRIBUTES (t);\n+      while (list)\n+        {\n+          if (is_attribute_p (\"function_vector\", TREE_PURPOSE (list)))\n+            {\n+              num = TREE_INT_CST_LOW (TREE_VALUE (TREE_VALUE (list)));\n+              return num;\n+            }\n+\n+          list = TREE_CHAIN (list);\n+        }\n+\n+      return 0;\n+    }\n+  else\n+    return 0;\n+}\n+\n /* Handle an \"sp_switch\" attribute; arguments as in\n    struct attribute_spec.handler.  */\n static tree\n@@ -8101,6 +8279,39 @@ sh_cfun_interrupt_handler_p (void)\n \t  != NULL_TREE);\n }\n \n+/* Returns 1 if FUNC has been assigned the attribute\n+   \"function_vector\".  */\n+int\n+sh2a_function_vector_p (tree func)\n+{\n+  tree list;\n+  if (TREE_CODE (func) != FUNCTION_DECL)\n+    return 0;\n+\n+  list = SH_ATTRIBUTES (func);\n+  while (list)\n+    {\n+      if (is_attribute_p (\"function_vector\", TREE_PURPOSE (list)))\n+        return 1;\n+\n+      list = TREE_CHAIN (list);\n+    }\n+  return 0;\n+}\n+\n+/* Returns TRUE if given tree has the \"resbank\" attribute.  */\n+\n+int\n+sh_cfun_resbank_handler_p (void)\n+{\n+  return ((lookup_attribute (\"resbank\",\n+                             DECL_ATTRIBUTES (current_function_decl))\n+           != NULL_TREE)\n+          && (lookup_attribute (\"interrupt_handler\",\n+                                DECL_ATTRIBUTES (current_function_decl))\n+              != NULL_TREE) && TARGET_SH2A);\n+}\n+\n /* Implement TARGET_CHECK_PCH_TARGET_FLAGS.  */\n \n static const char *"}, {"sha": "6dae438f9f9c6e8d34337b20b0267dd3a75bf97a", "filename": "gcc/config/sh/sh.md", "status": "modified", "additions": 96, "deletions": 3, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/561642fa67798158762265f5100e3052275fe970/gcc%2Fconfig%2Fsh%2Fsh.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/561642fa67798158762265f5100e3052275fe970/gcc%2Fconfig%2Fsh%2Fsh.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.md?ref=561642fa67798158762265f5100e3052275fe970", "patch": "@@ -7443,14 +7443,46 @@ label:\n    (use (reg:PSI FPSCR_REG))\n    (clobber (reg:SI PR_REG))]\n   \"TARGET_SH1\"\n-  \"jsr\t@%0%#\"\n+  \"*\n+   {\n+     if (TARGET_SH2A && (dbr_sequence_length () == 0))\n+\treturn \\\"jsr/n\\\\t@%0\\\";\n+     else\n+\treturn \\\"jsr\\\\t@%0%#\\\";\n+   }\"\n+\n   [(set_attr \"type\" \"call\")\n    (set (attr \"fp_mode\")\n \t(if_then_else (eq_attr \"fpu_single\" \"yes\")\n \t\t      (const_string \"single\") (const_string \"double\")))\n    (set_attr \"needs_delay_slot\" \"yes\")\n    (set_attr \"fp_set\" \"unknown\")])\n \n+;; This is TBR relative jump instruction for SH2A architecture.\n+;; Its use is enabled assigning an attribute \"function_vector\"\n+;; and the vector number to a function during its declaration.\n+\n+(define_insn \"calli_tbr_rel\"\n+  [(call (mem (match_operand:SI 0 \"symbol_ref_operand\" \"\"))\n+\t (match_operand 1 \"\" \"\"))\n+   (use (reg:PSI FPSCR_REG))\n+   (clobber (reg:SI PR_REG))]\n+  \"TARGET_SH2A && sh2a_is_function_vector_call (operands[0])\"\n+  \"*\n+{\n+  unsigned HOST_WIDE_INT vect_num;\n+  vect_num = sh2a_get_function_vector_number (operands[0]);\n+  operands[2] = GEN_INT (vect_num * 4);\n+\n+  return \\\"jsr/n\\\\t@@(%O2,tbr)\\\";\n+}\"\n+  [(set_attr \"type\" \"call\")\n+   (set (attr \"fp_mode\")\n+\t(if_then_else (eq_attr \"fpu_single\" \"yes\")\n+\t\t      (const_string \"single\") (const_string \"double\")))\n+   (set_attr \"needs_delay_slot\" \"no\")\n+   (set_attr \"fp_set\" \"unknown\")])\n+\n ;; This is a pc-rel call, using bsrf, for use with PIC.\n \n (define_insn \"calli_pcrel\"\n@@ -7546,14 +7578,46 @@ label:\n    (use (reg:PSI FPSCR_REG))\n    (clobber (reg:SI PR_REG))]\n   \"TARGET_SH1\"\n-  \"jsr\t@%1%#\"\n+  \"*\n+   {\n+     if (TARGET_SH2A && (dbr_sequence_length () == 0))\n+\treturn \\\"jsr/n\\\\t@%1\\\";\n+     else\n+\treturn \\\"jsr\\\\t@%1%#\\\";\n+   }\"\n   [(set_attr \"type\" \"call\")\n    (set (attr \"fp_mode\")\n \t(if_then_else (eq_attr \"fpu_single\" \"yes\")\n \t\t      (const_string \"single\") (const_string \"double\")))\n    (set_attr \"needs_delay_slot\" \"yes\")\n    (set_attr \"fp_set\" \"unknown\")])\n \n+;; This is TBR relative jump instruction for SH2A architecture.\n+;; Its use is enabled assigning an attribute \"function_vector\"\n+;; and the vector number to a function during its declaration.\n+\n+(define_insn \"call_valuei_tbr_rel\"\n+  [(set (match_operand 0 \"\" \"=rf\")\n+\t(call (mem:SI (match_operand:SI 1 \"symbol_ref_operand\" \"\"))\n+\t      (match_operand 2 \"\" \"\")))\n+   (use (reg:PSI FPSCR_REG))\n+   (clobber (reg:SI PR_REG))]\n+  \"TARGET_SH2A && sh2a_is_function_vector_call (operands[1])\"\n+  \"*\n+{\n+  unsigned HOST_WIDE_INT vect_num;\n+  vect_num = sh2a_get_function_vector_number (operands[1]);\n+  operands[3] = GEN_INT (vect_num * 4);\n+\n+  return \\\"jsr/n\\\\t@@(%O3,tbr)\\\";\n+}\"\n+  [(set_attr \"type\" \"call\")\n+   (set (attr \"fp_mode\")\n+\t(if_then_else (eq_attr \"fpu_single\" \"yes\")\n+\t\t      (const_string \"single\") (const_string \"double\")))\n+   (set_attr \"needs_delay_slot\" \"no\")\n+   (set_attr \"fp_set\" \"unknown\")])\n+\n (define_insn \"call_valuei_pcrel\"\n   [(set (match_operand 0 \"\" \"=rf\")\n \t(call (mem:SI (match_operand:SI 1 \"arith_reg_operand\" \"r\"))\n@@ -7715,6 +7779,17 @@ label:\n       emit_insn (gen_symGOTPLT2reg (reg, XEXP (operands[0], 0)));\n       XEXP (operands[0], 0) = reg;\n     }\n+  if (!flag_pic && TARGET_SH2A\n+      && GET_CODE (operands[0]) == MEM\n+      && GET_CODE (XEXP (operands[0], 0)) == SYMBOL_REF)\n+    {\n+      if (sh2a_is_function_vector_call (XEXP (operands[0], 0)))\n+\t{\n+\t  emit_call_insn (gen_calli_tbr_rel (XEXP (operands[0], 0),\n+\t\t\t\t\t     operands[1]));\n+\t  DONE;\n+\t}\n+    }\n   if (flag_pic && TARGET_SH2\n       && GET_CODE (operands[0]) == MEM\n       && GET_CODE (XEXP (operands[0], 0)) == SYMBOL_REF)\n@@ -7898,6 +7973,17 @@ label:\n       emit_insn (gen_symGOTPLT2reg (reg, XEXP (operands[1], 0)));\n       XEXP (operands[1], 0) = reg;\n     }\n+  if (!flag_pic && TARGET_SH2A\n+      && GET_CODE (operands[1]) == MEM\n+      && GET_CODE (XEXP (operands[1], 0)) == SYMBOL_REF)\n+    {\n+      if (sh2a_is_function_vector_call (XEXP (operands[1], 0)))\n+\t{\n+\t  emit_call_insn (gen_call_valuei_tbr_rel (operands[0],\n+\t\t\t\t XEXP (operands[1], 0), operands[2]));\n+\t  DONE;\n+\t}\n+    }\n   if (flag_pic && TARGET_SH2\n       && GET_CODE (operands[1]) == MEM\n       && GET_CODE (XEXP (operands[1], 0)) == SYMBOL_REF)\n@@ -9262,7 +9348,14 @@ mov.l\\\\t1f,r0\\\\n\\\\\n    && reload_completed\n    && lookup_attribute (\\\"trap_exit\\\",\n \t\t\tDECL_ATTRIBUTES (current_function_decl)) == NULL_TREE\"\n-  \"%@\t%#\"\n+  \"*\n+  {\n+    if (TARGET_SH2A && (dbr_sequence_length () == 0)\n+\t\t\t&& !current_function_interrupt)\n+       return \\\"rts/n\\\";\n+    else\n+       return \\\"%@\t%#\\\";\n+  }\"\n   [(set_attr \"type\" \"return\")\n    (set_attr \"needs_delay_slot\" \"yes\")])\n "}, {"sha": "1fa7fc2bcf7b247c9bcbb8a1a0534278225d889e", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 31, "deletions": 1, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/561642fa67798158762265f5100e3052275fe970/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/561642fa67798158762265f5100e3052275fe970/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=561642fa67798158762265f5100e3052275fe970", "patch": "@@ -2299,16 +2299,33 @@ is used.  @xref{C Dialect Options,,Options\n Controlling C Dialect}.\n \n @item function_vector\n-@cindex calling functions through the function vector on H8/300, M16C, and M32C processors\n+@cindex calling functions through the function vector on H8/300, M16C, M32C and SH2A processors\n Use this attribute on the H8/300, H8/300H, and H8S to indicate that the specified\n function should be called through the function vector.  Calling a\n function through the function vector will reduce code size, however;\n the function vector has a limited size (maximum 128 entries on the H8/300\n and 64 entries on the H8/300H and H8S) and shares space with the interrupt vector.\n \n+In SH2A target, this attribute declares a function to be called using the\n+TBR relative addressing mode.  The argument to this attribute is the entry\n+number of the same function in a vector table containing all the TBR\n+relative addressable functions.  For the successful jump, register TBR\n+should contain the start address of this TBR relative vector table.\n+In the startup routine of the user application, user needs to care of this\n+TBR register initialization.  The TBR relative vector table can have at\n+max 256 function entries.  The jumps to these functions will be generated\n+using a SH2A specific, non delayed branch instruction JSR/N @@(disp8,TBR).\n You must use GAS and GLD from GNU binutils version 2.7 or later for\n this attribute to work correctly.\n \n+Please refer the example of M16C target, to see the use of this\n+attribute while declaring a function,\n+\n+In an application, for a function being called once, this attribute will\n+save at least 8 bytes of code; and if other successive calls are being\n+made to the same function, it will save 2 bytes of code per each of these\n+calls.\n+\n On M16C/M32C targets, the @code{function_vector} attribute declares a\n special page subroutine call function. Use of this attribute reduces\n the code size by 2 bytes for each call generated to the\n@@ -2722,6 +2739,19 @@ number of registers available if used in conjunction with the\n attribute is incompatible with nested functions; this is considered a\n hard error.\n \n+@item resbank\n+@cindex @code{resbank} attribute\n+On the SH2A target, this attribute enables the high-speed register\n+saving and restoration using a register bank for @code{interrupt_handler}\n+routines.  Saving to the bank is performed automatcially after the CPU\n+accepts an interrupt that uses a register bank.\n+\n+The nineteen 32-bit registers comprising general register R0 to R14,\n+control register GBR, and system registers MACH, MACL, and PR and the\n+vector table address offset are saved into a register bank.  Register\n+banks are stacked in first-in last-out (FILO) sequence.  Restoration\n+from the bank is executed by issuing a RESBANK instruction.\n+\n @item returns_twice\n @cindex @code{returns_twice} attribute\n The @code{returns_twice} attribute tells the compiler that a function may"}, {"sha": "103aaf20414c078513b6993d99d09ce9d2a3efe0", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/561642fa67798158762265f5100e3052275fe970/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/561642fa67798158762265f5100e3052275fe970/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=561642fa67798158762265f5100e3052275fe970", "patch": "@@ -1,3 +1,12 @@\n+2008-03-25  Anil Paranjape  <anil.paranjape@kpitcummins.com>\n+\t    Jayant Sonar  <Jayant.sonar@kpitcummins.com>\n+\t    Naveen.H.S  <naveen.hs@kpitcummins.com>\n+\n+\t* gcc.target/sh/sh2a-resbank.c: New test.\n+\t* gcc.target/sh/sh2a-tbr-jump.c: New test.\n+\t* gcc.target/sh/sh2a-jsrn.c: New test.\n+\t* gcc.target/sh/sh2a-rtsn.c: New test.\n+\n 2008-03-25  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* gcc.target/i386/sse-17.c: Include sse2-check.h."}, {"sha": "9b9b92cb92074d6669d5ef5ddd06b543271160b4", "filename": "gcc/testsuite/gcc.target/sh/sh2a-jsrn.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/561642fa67798158762265f5100e3052275fe970/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fsh2a-jsrn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/561642fa67798158762265f5100e3052275fe970/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fsh2a-jsrn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fsh2a-jsrn.c?ref=561642fa67798158762265f5100e3052275fe970", "patch": "@@ -0,0 +1,15 @@\n+/* Testcase to check generation of a SH2A specific instruction for\n+   'JSR/N @Rm'.  */\n+/* { dg-do assemble {target sh*-*-*}}  */\n+/* { dg-options \"-O0\" }  */\n+/* { dg-skip-if \"\" { \"sh*-*-*\" } \"*\" \"-m2a -m2a-nofpu -m2a-single -m2a-single-only\" }  */\n+/* { dg-final { scan-assembler \"jsr/n\"} }  */\n+\n+void foo(void)\n+{\n+}\n+\n+void bar()\n+{\n+  foo();\n+}"}, {"sha": "aab6852f336431fa69a17d0bc3bb6a428bff48c1", "filename": "gcc/testsuite/gcc.target/sh/sh2a-resbank.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/561642fa67798158762265f5100e3052275fe970/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fsh2a-resbank.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/561642fa67798158762265f5100e3052275fe970/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fsh2a-resbank.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fsh2a-resbank.c?ref=561642fa67798158762265f5100e3052275fe970", "patch": "@@ -0,0 +1,12 @@\n+/* Test for resbank attribute.  */\n+/* { dg-do assemble {target sh*-*-*}} */\n+/* { dg-skip-if \"\" { \"sh*-*-*\" } \"*\" \"-m2a -m2a-nofpu -m2a-single -m2a-single-only\" } */\n+/* { dg-final { scan-assembler \"resbank\" } } */\n+ \n+extern void bar(void);\n+ \n+void foo(void) __attribute__((interrupt_handler, resbank));\n+void foo(void)\n+{\n+  bar();\n+}"}, {"sha": "2601ced5cff3aa631d3659e60c57b12c931910f2", "filename": "gcc/testsuite/gcc.target/sh/sh2a-rtsn.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/561642fa67798158762265f5100e3052275fe970/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fsh2a-rtsn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/561642fa67798158762265f5100e3052275fe970/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fsh2a-rtsn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fsh2a-rtsn.c?ref=561642fa67798158762265f5100e3052275fe970", "patch": "@@ -0,0 +1,11 @@\n+/* Testcase to check generation of a SH2A specific instruction for\n+   'RTS/N'.  */\n+/* { dg-do assemble {target sh*-*-*}}  */\n+/* { dg-options \"-O0\" }  */\n+/* { dg-skip-if \"\" { \"sh*-*-*\" } \"*\" \"-m2a -m2a-nofpu -m2a-single -m2a-single-only\" }  */\n+/* { dg-final { scan-assembler \"rts/n\"} }  */\n+\n+void\n+bar (void)\n+{\n+}"}, {"sha": "8029b03dd4ae81f605e131589ea24de0399db82d", "filename": "gcc/testsuite/gcc.target/sh/sh2a-tbr-jump.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/561642fa67798158762265f5100e3052275fe970/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fsh2a-tbr-jump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/561642fa67798158762265f5100e3052275fe970/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fsh2a-tbr-jump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fsh2a-tbr-jump.c?ref=561642fa67798158762265f5100e3052275fe970", "patch": "@@ -0,0 +1,22 @@\n+/* Testcase to check generation of a SH2A specific,\n+   TBR relative jump instruction - 'JSR @@(disp8,TBR)'.  */\n+/* { dg-do assemble {target sh*-*-*}} */\n+/* { dg-options \"\" } */\n+/* { dg-skip-if \"\" { \"sh*-*-*\" } \"*\" \"-m2a -m2a-nofpu -m2a-single -m2a-single-only\" } */\n+/* { dg-final { scan-assembler-times \"jsr/n\\\\t@@\\\\(40,tbr\\\\)\" 1} } */\n+/* { dg-final { scan-assembler-times \"jsr/n\\\\t@@\\\\(72,tbr\\\\)\" 1} } */\n+ \n+extern void foo1 (void) __attribute__ ((function_vector(10)));\n+extern void foo2 (void);\n+extern int bar1 (void) __attribute__ ((function_vector(18)));\n+extern int bar2 (void);\n+\n+int\n+bar()\n+{\n+  foo1();\n+  foo2();\n+\n+  bar1();\n+  bar2();\n+}"}]}