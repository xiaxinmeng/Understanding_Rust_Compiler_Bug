{"sha": "db6bb1ec036f180584d221cdc66dff7bb7180d7a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGI2YmIxZWMwMzZmMTgwNTg0ZDIyMWNkYzY2ZGZmN2JiNzE4MGQ3YQ==", "commit": {"author": {"name": "Andreas Krebbel", "email": "krebbel@linux.vnet.ibm.com", "date": "2017-09-01T15:58:05Z"}, "committer": {"name": "Andreas Krebbel", "email": "krebbel@gcc.gnu.org", "date": "2017-09-01T15:58:05Z"}, "message": "S/390: PR82012: Implement CAN_INLINE_P target hook.\n\nTARGET_CAN_INLINE_P must be implemented when supporting target\nattributes.\n\ngcc/ChangeLog:\n\n2017-09-01  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>\n\n\tPR target/82012\n\t* config/s390/s390.c (s390_can_inline_p): New function.\n\ngcc/testsuite/ChangeLog:\n\n2017-09-01  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>\n\n\tPR target/82012\n\t* gcc.target/s390/target-attribute/pr82012.c: New test.\n\nFrom-SVN: r251601", "tree": {"sha": "120d17aca1c004b77c81225c4d7db63eb76c2f29", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/120d17aca1c004b77c81225c4d7db63eb76c2f29"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/db6bb1ec036f180584d221cdc66dff7bb7180d7a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/db6bb1ec036f180584d221cdc66dff7bb7180d7a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/db6bb1ec036f180584d221cdc66dff7bb7180d7a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/db6bb1ec036f180584d221cdc66dff7bb7180d7a/comments", "author": null, "committer": null, "parents": [{"sha": "0e34f6d842f2cd7f9aecdc32bfdc14dcf6c811e5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e34f6d842f2cd7f9aecdc32bfdc14dcf6c811e5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0e34f6d842f2cd7f9aecdc32bfdc14dcf6c811e5"}], "stats": {"total": 109, "additions": 109, "deletions": 0}, "files": [{"sha": "e71380e5c9dd3a54afe64c44e405412c1c012255", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db6bb1ec036f180584d221cdc66dff7bb7180d7a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db6bb1ec036f180584d221cdc66dff7bb7180d7a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=db6bb1ec036f180584d221cdc66dff7bb7180d7a", "patch": "@@ -1,3 +1,8 @@\n+2017-09-01  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>\n+\n+\tPR target/82012\n+\t* config/s390/s390.c (s390_can_inline_p): New function.\n+\n 2017-09-01  Jeff Law  <law@redhat.com>\n \n \tPR tree-optimization/82052"}, {"sha": "8b6991adef9fa24a8babe66024e5e3ff35a8ebf5", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db6bb1ec036f180584d221cdc66dff7bb7180d7a/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db6bb1ec036f180584d221cdc66dff7bb7180d7a/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=db6bb1ec036f180584d221cdc66dff7bb7180d7a", "patch": "@@ -79,6 +79,10 @@ along with GCC; see the file COPYING3.  If not see\n #include \"rtl-iter.h\"\n #include \"intl.h\"\n #include \"tm-constrs.h\"\n+#include \"tree-vrp.h\"\n+#include \"symbol-summary.h\"\n+#include \"ipa-prop.h\"\n+#include \"ipa-fnsummary.h\"\n \n /* This file should be included last.  */\n #include \"target-def.h\"\n@@ -15354,6 +15358,52 @@ s390_valid_target_attribute_p (tree fndecl,\n   return ret;\n }\n \n+/* Hook to determine if one function can safely inline another.  */\n+\n+static bool\n+s390_can_inline_p (tree caller, tree callee)\n+{\n+  tree caller_tree = DECL_FUNCTION_SPECIFIC_TARGET (caller);\n+  tree callee_tree = DECL_FUNCTION_SPECIFIC_TARGET (callee);\n+\n+  if (!callee_tree)\n+    callee_tree = target_option_default_node;\n+  if (!caller_tree)\n+    caller_tree = target_option_default_node;\n+  if (callee_tree == caller_tree)\n+    return true;\n+\n+  struct cl_target_option *caller_opts = TREE_TARGET_OPTION (caller_tree);\n+  struct cl_target_option *callee_opts = TREE_TARGET_OPTION (callee_tree);\n+  bool ret = true;\n+\n+  if ((caller_opts->x_target_flags & ~(MASK_SOFT_FLOAT | MASK_HARD_DFP))\n+      != (callee_opts->x_target_flags & ~(MASK_SOFT_FLOAT | MASK_HARD_DFP)))\n+    ret = false;\n+\n+  /* Don't inline functions to be compiled for a more recent arch into a\n+     function for an older arch.  */\n+  else if (caller_opts->x_s390_arch < callee_opts->x_s390_arch)\n+    ret = false;\n+\n+  /* Inlining a hard float function into a soft float function is only\n+     allowed if the hard float function doesn't actually make use of\n+     floating point.\n+\n+     We are called from FEs for multi-versioning call optimization, so\n+     beware of ipa_fn_summaries not available.  */\n+  else if (((TARGET_SOFT_FLOAT_P (caller_opts->x_target_flags)\n+\t     && !TARGET_SOFT_FLOAT_P (callee_opts->x_target_flags))\n+\t    || (!TARGET_HARD_DFP_P (caller_opts->x_target_flags)\n+\t\t&& TARGET_HARD_DFP_P (callee_opts->x_target_flags)))\n+\t   && (! ipa_fn_summaries\n+\t       || ipa_fn_summaries->get\n+\t       (cgraph_node::get (callee))->fp_expressions))\n+    ret = false;\n+\n+  return ret;\n+}\n+\n /* Restore targets globals from NEW_TREE and invalidate s390_previous_fndecl\n    cache.  */\n \n@@ -15936,6 +15986,9 @@ s390_asan_shadow_offset (void)\n \n #undef TARGET_OPTION_VALID_ATTRIBUTE_P\n #define TARGET_OPTION_VALID_ATTRIBUTE_P s390_valid_target_attribute_p\n+\n+#undef TARGET_CAN_INLINE_P\n+#define TARGET_CAN_INLINE_P s390_can_inline_p\n #endif\n \n #undef TARGET_OPTION_RESTORE"}, {"sha": "fe6e4301bff99bff080f92def994e52cefd18bc5", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db6bb1ec036f180584d221cdc66dff7bb7180d7a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db6bb1ec036f180584d221cdc66dff7bb7180d7a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=db6bb1ec036f180584d221cdc66dff7bb7180d7a", "patch": "@@ -1,3 +1,8 @@\n+2017-09-01  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>\n+\n+\tPR target/82012\n+\t* gcc.target/s390/target-attribute/pr82012.c: New test.\n+\n 2017-09-01  Jeff Law  <law@redhat.com>\n \n \tPR tree-optimization/82052"}, {"sha": "2e1f7ae57beeca8bced8af5ac73a1cf71c1ce19b", "filename": "gcc/testsuite/gcc.target/s390/target-attribute/pr82012.c", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db6bb1ec036f180584d221cdc66dff7bb7180d7a/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Ftarget-attribute%2Fpr82012.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db6bb1ec036f180584d221cdc66dff7bb7180d7a/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Ftarget-attribute%2Fpr82012.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Ftarget-attribute%2Fpr82012.c?ref=db6bb1ec036f180584d221cdc66dff7bb7180d7a", "patch": "@@ -0,0 +1,46 @@\n+/* Different target attributes in general prevent inlining.  However,\n+   we make an exception for soft-float callers if the callee doesn't\n+   actually use HW floating point.  This is currently required for\n+   compiling libitm.  */\n+\n+/* { dg-options \"-Wno-attributes\" } */\n+\n+double g = 1.0;\n+\n+/* Inlining ok here.  foo1 doesn't use FP.  */\n+\n+int __attribute__ ((always_inline)) foo1 (int a)\n+{\n+  return 0;\n+}\n+\n+int __attribute__ ((target (\"soft-float\"))) test1 (int a)\n+{\n+  return foo1 (a);\n+}\n+\n+/* Inlining ok here.  FP store doesn't need HW FP.  */\n+\n+int __attribute__ ((always_inline)) foo2 (int a)\n+{\n+  g = 2.0;\n+  return 0;\n+}\n+\n+int __attribute__ ((target (\"soft-float\"))) test2 (int a)\n+{\n+  return foo2 (a);\n+}\n+\n+/* Inlining needs to be rejected.  foo3 performs HW FP operation.  */\n+\n+int __attribute__ ((always_inline)) foo3 (int a) /* { dg-error \"inlining failed in call to always_inline\" } */\n+{\n+  g = (double) a / 2.0;\n+  return 0;\n+}\n+\n+int __attribute__ ((target (\"soft-float\"))) test3 (int a)\n+{\n+  return foo3 (a);\n+}"}]}