{"sha": "c5a047348d810987513ce54c6533c1314ad19593", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzVhMDQ3MzQ4ZDgxMDk4NzUxM2NlNTRjNjUzM2MxMzE0YWQxOTU5Mw==", "commit": {"author": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2000-04-25T19:32:36Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2000-04-25T19:32:36Z"}, "message": "[multiple changes]\n\n2000-04-25  Zack Weinberg  <zack@wolery.cumb.org>\n\n\t* cpplib.h (struct cpp_buffer): Add 'mapped' flag; fix\n\tcommentary.\n\n2000-04-25  Neil Booth  <NeilB@earthling.net>\n\n\tRestore previous patch, plus the following fixes:\n\n\t* cpphash.c (_cpp_create_definition): Test PREV_WHITESPACE in\n\tflags, not CPP_OPEN_PAREN.\n\t* cpplex.c (expand_token_space, init_token_list,\n\tcpp_free_token_list): Put the dummy token at list->tokens[-1].\n\t(_cpp_lex_line, _cpp_lex_file): token list is 0-based.\n\nFrom-SVN: r33419", "tree": {"sha": "5a047961b22821bc1f9f0aa156612fd5c002d95c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5a047961b22821bc1f9f0aa156612fd5c002d95c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c5a047348d810987513ce54c6533c1314ad19593", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c5a047348d810987513ce54c6533c1314ad19593", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c5a047348d810987513ce54c6533c1314ad19593", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c5a047348d810987513ce54c6533c1314ad19593/comments", "author": null, "committer": null, "parents": [{"sha": "e0075d846d4a4bbcb3a5114bdc8f4f130bf819b1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e0075d846d4a4bbcb3a5114bdc8f4f130bf819b1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e0075d846d4a4bbcb3a5114bdc8f4f130bf819b1"}], "stats": {"total": 1566, "additions": 1492, "deletions": 74}, "files": [{"sha": "4547607ffcfaf63c55e0f1dc4d0f3d6b31952d2a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5a047348d810987513ce54c6533c1314ad19593/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5a047348d810987513ce54c6533c1314ad19593/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c5a047348d810987513ce54c6533c1314ad19593", "patch": "@@ -1,3 +1,18 @@\n+2000-04-25  Zack Weinberg  <zack@wolery.cumb.org>\n+\n+\t* cpplib.h (struct cpp_buffer): Add 'mapped' flag; fix\n+\tcommentary. \n+\n+2000-04-25  Neil Booth  <NeilB@earthling.net>\n+\n+\tRestore previous patch, plus the following fixes:\n+\n+\t* cpphash.c (_cpp_create_definition): Test PREV_WHITESPACE in\n+\tflags, not CPP_OPEN_PAREN.\n+\t* cpplex.c (expand_token_space, init_token_list,\n+\tcpp_free_token_list): Put the dummy token at list->tokens[-1].\n+\t(_cpp_lex_line, _cpp_lex_file): token list is 0-based.\n+\n Tue Apr 25 14:06:40 2000  Alexandre Oliva  <oliva@lsd.ic.unicamp.br>\n \n \t* config/i386/freebsd.h (INT_ASM_OP): Define."}, {"sha": "fe594a2dadc3c8f1d67a41a229e4d0aec8eec19a", "filename": "gcc/cpphash.c", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5a047348d810987513ce54c6533c1314ad19593/gcc%2Fcpphash.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5a047348d810987513ce54c6533c1314ad19593/gcc%2Fcpphash.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.c?ref=c5a047348d810987513ce54c6533c1314ad19593", "patch": "@@ -459,7 +459,8 @@ collect_objlike_expansion (pfile, list)\n \tdefault:;\n \t}\n \n-      if (i > 1 && !last_was_paste && (list->tokens[i].flags & HSPACE_BEFORE))\n+      if (i > 1 && !last_was_paste\n+\t  && (list->tokens[i].flags & PREV_WHITESPACE))\n \tCPP_PUTC (pfile, ' ');\n \n       CPP_PUTS (pfile,\n@@ -571,10 +572,10 @@ collect_funlike_expansion (pfile, list, arglist, replacement)\n \t}\n \n       if (last_token != PASTE && last_token != START\n-\t  && (list->tokens[i].flags & HSPACE_BEFORE))\n+\t  && (list->tokens[i].flags & PREV_WHITESPACE))\n \tCPP_PUTC (pfile, ' ');\n       if (last_token == ARG && CPP_TRADITIONAL (pfile)\n-\t  && !(list->tokens[i].flags & HSPACE_BEFORE))\n+\t  && !(list->tokens[i].flags & PREV_WHITESPACE))\n \tendpat->raw_after = 1;\n \n       switch (token)\n@@ -616,7 +617,7 @@ collect_funlike_expansion (pfile, list, arglist, replacement)\n       {\n \tint raw_before = (last_token == PASTE\n \t\t\t  || (CPP_TRADITIONAL (pfile)\n-\t\t\t      && !(list->tokens[i].flags & HSPACE_BEFORE)));\n+\t\t\t      && !(list->tokens[i].flags & PREV_WHITESPACE)));\n       \n \tadd_pat (&pat, &endpat,\n \t\t CPP_WRITTEN (pfile) - last /* nchars */, j /* argno */,\n@@ -865,7 +866,7 @@ _cpp_create_definition (pfile, list, hp)\n   /* The macro is function-like only if the next character,\n      with no intervening whitespace, is '('.  */\n   else if (list->tokens[1].type == CPP_OPEN_PAREN\n-\t   && ! (list->tokens[1].flags & HSPACE_BEFORE))\n+\t   && ! (list->tokens[1].flags & PREV_WHITESPACE))\n     {\n       struct arglist args;\n       int replacement;\n@@ -884,7 +885,7 @@ _cpp_create_definition (pfile, list, hp)\n      whitespace after the name (6.10.3 para 3).  */\n   else\n     {\n-      if (! (list->tokens[1].flags & CPP_OPEN_PAREN))\n+      if (! (list->tokens[1].flags & PREV_WHITESPACE))\n \tcpp_pedwarn (pfile,\n \t\t     \"The C standard requires whitespace after #define %s\",\n \t\t     hp->name);"}, {"sha": "2d2ea8d5c3612eff3f9b4cad247e7314134731df", "filename": "gcc/cpphash.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5a047348d810987513ce54c6533c1314ad19593/gcc%2Fcpphash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5a047348d810987513ce54c6533c1314ad19593/gcc%2Fcpphash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.h?ref=c5a047348d810987513ce54c6533c1314ad19593", "patch": "@@ -317,5 +317,6 @@ extern void _cpp_scan_line\t\tPARAMS ((cpp_reader *, cpp_toklist *));\n /* In cpplib.c */\n extern int _cpp_handle_directive\tPARAMS ((cpp_reader *));\n extern void _cpp_handle_eof\t\tPARAMS ((cpp_reader *));\n+extern void _cpp_check_directive        PARAMS((cpp_toklist *, cpp_token *));\n \n #endif"}, {"sha": "30614372809e0a744e93b195361be906e14f2aa2", "filename": "gcc/cpplex.c", "status": "modified", "additions": 1362, "deletions": 23, "changes": 1385, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5a047348d810987513ce54c6533c1314ad19593/gcc%2Fcpplex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5a047348d810987513ce54c6533c1314ad19593/gcc%2Fcpplex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplex.c?ref=c5a047348d810987513ce54c6533c1314ad19593", "patch": "@@ -4,6 +4,7 @@\n    Based on CCCP program by Paul Rubin, June 1986\n    Adapted to ANSI C, Richard Stallman, Jan 1987\n    Broken out to separate file, Zack Weinberg, Mar 2000\n+   Single-pass line tokenization by Neil Booth, April 2000\n \n This program is free software; you can redistribute it and/or modify it\n under the terms of the GNU General Public License as published by the\n@@ -54,12 +55,15 @@ static void output_line_command\tPARAMS ((cpp_reader *, cpp_printer *,\n \t\t\t\t\t unsigned int));\n static void bump_column\t\tPARAMS ((cpp_printer *, unsigned int,\n \t\t\t\t\t unsigned int));\n-static void expand_name_space\tPARAMS ((cpp_toklist *));\n+static void expand_name_space   PARAMS ((cpp_toklist *, unsigned int));\n static void expand_token_space\tPARAMS ((cpp_toklist *));\n static void init_token_list\tPARAMS ((cpp_reader *, cpp_toklist *, int));\n static void pedantic_whitespace\tPARAMS ((cpp_reader *, U_CHAR *,\n \t\t\t\t\t unsigned int));\n \n+#define auto_expand_name_space(list) \\\n+    expand_name_space ((list), (list)->name_cap / 2)\n+\n /* Re-allocates PFILE->token_buffer so it will hold at least N more chars.  */\n \n void\n@@ -431,12 +435,12 @@ cpp_file_buffer (pfile)\n \n /* Expand a token list's string space.  */\n static void\n-expand_name_space (list)\n+expand_name_space (list, len)\n      cpp_toklist *list;\n-{  \n-  list->name_cap *= 2;\n-  list->namebuf = (unsigned char *) xrealloc (list->namebuf,\n-\t\t\t\t\t      list->name_cap);\n+     unsigned int len;\n+{\n+  list->name_cap += len;\n+  list->namebuf = (unsigned char *) xrealloc (list->namebuf, list->name_cap);\n }\n \n /* Expand the number of tokens in a list.  */\n@@ -446,36 +450,42 @@ expand_token_space (list)\n {\n   list->tokens_cap *= 2;\n   list->tokens = (cpp_token *)\n-    xrealloc (list->tokens, list->tokens_cap * sizeof (cpp_token));\n+    xrealloc (list->tokens - 1, (list->tokens_cap + 1) * sizeof (cpp_token));\n+  list->tokens++;\t\t/* Skip the dummy.  */\n }\n \n-/* Initialise a token list.  */\n+/* Initialize a token list.  We allocate an extra token in front of\n+   the token list, as this allows us to always peek at the previous\n+   token without worrying about underflowing the list.  */\n static void\n init_token_list (pfile, list, recycle)\n      cpp_reader *pfile;\n      cpp_toklist *list;\n      int recycle;\n {\n-  /* Recycling a used list saves 2 free-malloc pairs.  */\n-  if (recycle)\n+  /* Recycling a used list saves 3 free-malloc pairs.  */\n+  if (!recycle)\n     {\n-      list->tokens_used = 0;\n-      list->name_used = 0;\n-    }\n-  else\n-    {\n-      /* Initialise token space.  */\n-      list->tokens_cap = 256;\t/* 4K on Intel.\t */\n-      list->tokens_used = 0;\n+      /* Initialize token space.  Put a dummy token before the start\n+         that will fail matches.  */\n+      list->tokens_cap = 256;\t/* 4K's worth.  */\n       list->tokens = (cpp_token *)\n-\txmalloc (list->tokens_cap * sizeof (cpp_token));\n+\txmalloc ((list->tokens_cap + 1) * sizeof (cpp_token));\n+      list->tokens[0].type = CPP_EOF;\n+      list->tokens++;\n \n-      /* Initialise name space.\t */\n+      /* Initialize name space.  */\n       list->name_cap = 1024;\n-      list->name_used = 0;\n       list->namebuf = (unsigned char *) xmalloc (list->name_cap);\n+\n+      /* Only create a comment space on demand.  */\n+      list->comments_cap = 0;\n+      list->comments = 0;\n     }\n \n+  list->tokens_used = 0;\n+  list->name_used = 0;\n+  list->comments_used = 0;\n   if (pfile->buffer)\n     list->line = pfile->buffer->lineno;\n   list->dir_handler = 0;\n@@ -522,15 +532,15 @@ _cpp_scan_line (pfile, list)\n       if (list->tokens_used >= list->tokens_cap)\n \texpand_token_space (list);\n       if (list->name_used + len >= list->name_cap)\n-\texpand_name_space (list);\n+\tauto_expand_name_space (list);\n \n       if (type == CPP_MACRO)\n \ttype = CPP_NAME;\n \n       list->tokens_used++;\n       list->tokens[i].type = type;\n       list->tokens[i].col = col;\n-      list->tokens[i].flags = space_before ? HSPACE_BEFORE : 0;\n+      list->tokens[i].flags = space_before ? PREV_WHITESPACE : 0;\n       \n       if (type == CPP_VSPACE)\n \tbreak;\n@@ -2037,3 +2047,1332 @@ _cpp_init_input_buffer (pfile)\n   pfile->input_buffer = tmp;\n   pfile->input_buffer_len = 8192;\n }\n+\n+#if 0\n+\n+static void expand_comment_space PARAMS ((cpp_toklist *));\n+void init_trigraph_map PARAMS ((void));\n+static unsigned char* trigraph_replace PARAMS ((cpp_reader *, unsigned char *,\n+\t\t\t\t\t\tunsigned char *));\n+static const unsigned char *backslash_start PARAMS ((cpp_reader *,\n+\t\t\t\t\t\t     const unsigned char *));\n+static int skip_block_comment PARAMS ((cpp_reader *));\n+static int skip_line_comment PARAMS ((cpp_reader *));\n+static void skip_whitespace PARAMS ((cpp_reader *, int));\n+static void parse_name PARAMS ((cpp_reader *, cpp_toklist *, cpp_name *));\n+static void parse_number PARAMS ((cpp_reader *, cpp_toklist *, cpp_name *));\n+static void parse_string PARAMS ((cpp_reader *, cpp_toklist *, cpp_name *,\n+\t\t\t\t  unsigned int));\n+static int trigraph_ok PARAMS ((cpp_reader *, const unsigned char *));\n+static void copy_comment PARAMS ((cpp_toklist *, const unsigned char *,\n+\t\t\t\t  unsigned int, unsigned int, unsigned int));\n+void _cpp_lex_line PARAMS ((cpp_reader *, cpp_toklist *));\n+\n+static void _cpp_output_list PARAMS ((cpp_reader *, cpp_toklist *));\n+\n+unsigned int spell_char PARAMS ((unsigned char *, cpp_toklist *,\n+\t\t\t\t cpp_token *token));\n+unsigned int spell_string PARAMS ((unsigned char *, cpp_toklist *,\n+\t\t\t\t   cpp_token *token));\n+unsigned int spell_comment PARAMS ((unsigned char *, cpp_toklist *,\n+\t\t\t\t    cpp_token *token));\n+unsigned int spell_name PARAMS ((unsigned char *, cpp_toklist *,\n+\t\t\t\t cpp_token *token));\n+unsigned int spell_other PARAMS ((unsigned char *, cpp_toklist *,\n+\t\t\t\t  cpp_token *token));\n+\n+typedef unsigned int (* speller) PARAMS ((unsigned char *, cpp_toklist *,\n+\t\t\t\t\t  cpp_token *));\n+\n+/* Macros on a cpp_name.  */\n+#define INIT_NAME(list, name) \\\n+  do {(name).len = 0; (name).offset = (list)->name_used;} while (0)\n+\n+#define IS_DIRECTIVE(list) (list->tokens[0].type == CPP_HASH)\n+#define COLUMN(cur) ((cur) - buffer->line_base)\n+\n+/* Maybe put these in the ISTABLE eventually.  */\n+#define IS_HSPACE(c) ((c) == ' ' || (c) == '\\t')\n+#define IS_NEWLINE(c) ((c) == '\\n' || (c) == '\\r')\n+\n+/* Handle LF, CR, CR-LF and LF-CR style newlines.  Assumes next\n+   character, if any, is in buffer.  */\n+#define handle_newline(cur, limit, c) \\\n+  do {\\\n+  if ((cur) < (limit) && *(cur) == '\\r' + '\\n' - c) \\\n+    (cur)++; \\\n+  CPP_BUMP_LINE_CUR (pfile, (cur)); \\\n+  } while (0)\n+\n+#define IMMED_TOKEN() (!(cur_token->flags & PREV_WHITESPACE))\n+#define PREV_TOKEN_TYPE (cur_token[-1].type)\n+\n+#define SPELL_TEXT     0\n+#define SPELL_HANDLER  1\n+#define SPELL_NONE     2\n+#define SPELL_EOL      3\n+\n+#define T(e, s) {SPELL_TEXT, s},\n+#define H(e, s) {SPELL_HANDLER, s},\n+#define N(e, s) {SPELL_NONE, s},\n+#define E(e, s) {SPELL_EOL, s},\n+\n+static const struct token_spelling\n+{\n+  char type;\n+  PTR  speller;\n+} token_spellings [N_TTYPES + 1] = {TTYPE_TABLE {0, 0} };\n+\n+#undef T\n+#undef H\n+#undef N\n+#undef E\n+\n+static const unsigned char *digraph_spellings [] = {\"%:\", \"%:%:\", \"<:\",\n+\t\t\t\t\t\t    \":>\", \"<%\", \"%>\"};\n+\n+static void\n+expand_comment_space (list)\n+     cpp_toklist *list;\n+{\n+  if (list->comments_cap == 0)\n+    {\n+      list->comments_cap = 10;\n+      list->comments = (cpp_token *)\n+\txmalloc (list->comments_cap * sizeof (cpp_token));\n+    }\n+  else\n+    {\n+      list->comments_cap *= 2;\n+      list->comments = (cpp_token *)\n+\txrealloc (list->comments, list->comments_cap);\n+    }\n+}\n+\n+void\n+cpp_free_token_list (list)\n+     cpp_toklist *list;\n+{\n+  if (list->comments)\n+    free (list->comments);\n+  free (list->tokens - 1);\n+  free (list->namebuf);\n+  free (list);\n+}\n+\n+static char trigraph_map[256];\n+\n+void\n+init_trigraph_map ()\n+{\n+  trigraph_map['='] = '#';\n+  trigraph_map['('] = '[';\n+  trigraph_map[')'] = ']';\n+  trigraph_map['/'] = '\\\\';\n+  trigraph_map['\\''] = '^';\n+  trigraph_map['<'] = '{';\n+  trigraph_map['>'] = '}';\n+  trigraph_map['!'] = '|';\n+  trigraph_map['-'] = '~';\n+}\n+\n+/* Call when a trigraph is encountered.  It warns if necessary, and\n+   returns true if the trigraph should be honoured.  END is the third\n+   character of a trigraph in the input stream.  */\n+static int\n+trigraph_ok (pfile, end)\n+     cpp_reader *pfile;\n+     const unsigned char *end;\n+{\n+  int accept = CPP_OPTION (pfile, trigraphs);\n+  \n+  if (CPP_OPTION (pfile, warn_trigraphs))\n+    {\n+      unsigned int col = end - 1 - pfile->buffer->line_base;\n+      if (accept)\n+\tcpp_warning_with_line (pfile, pfile->buffer->lineno, col, \n+\t\t\t       \"trigraph ??%c converted to %c\",\n+\t\t\t       (int) *end, (int) trigraph_map[*end]);\n+      else\n+\tcpp_warning_with_line (pfile, pfile->buffer->lineno, col,\n+\t\t\t       \"trigraph ??%c ignored\", (int) *end);\n+    }\n+  return accept;\n+}\n+\n+/* Scan a string for trigraphs, warning or replacing them inline as\n+   appropriate.  When parsing a string, we must call this routine\n+   before processing a newline character (if trigraphs are enabled),\n+   since the newline might be escaped by a preceding backslash\n+   trigraph sequence.  Returns a pointer to the end of the name after\n+   replacement.  */\n+\n+static unsigned char*\n+trigraph_replace (pfile, src, limit)\n+     cpp_reader *pfile;\n+     unsigned char *src;\n+     unsigned char* limit;\n+{\n+  unsigned char *dest;\n+\n+  /* Starting with src[1], find two consecutive '?'.  The case of no\n+     trigraphs is streamlined.  */\n+  \n+  for (; src + 1 < limit; src += 2)\n+    {\n+      if (src[0] != '?')\n+\tcontinue;\n+\n+      /* Make src point to the 1st (NOT 2nd) of two consecutive '?'s.  */\n+      if (src[-1] == '?')\n+\tsrc--;\n+      else if (src + 2 == limit || src[1] != '?')\n+\tcontinue;\n+\n+      /* Check if it really is a trigraph.  */\n+      if (trigraph_map[src[2]] == 0)\n+\tcontinue;\n+\n+      dest = src;\n+      goto trigraph_found;\n+    }\n+  return limit;\n+\n+  /* Now we have a trigraph, we need to scan the remaining buffer, and\n+     copy-shifting its contents left if replacement is enabled.  */\n+  for (; src + 2 < limit; dest++, src++)\n+    if ((*dest = *src) == '?' && src[1] == '?' && trigraph_map[src[2]])\n+      {\n+      trigraph_found:\n+\tsrc += 2;\n+\tif (trigraph_ok (pfile, pfile->buffer->cur - (limit - src)))\n+\t  *dest = trigraph_map[*src];\n+      }\n+  \n+  /* Copy remaining (at most 2) characters.  */\n+  while (src < limit)\n+    *dest++ = *src++;\n+  return dest;\n+}\n+\n+/* If CUR is a backslash or the end of a trigraphed backslash, return\n+   a pointer to its beginning, otherwise NULL.  We don't read beyond\n+   the buffer start, because there is the start of the comment in the\n+   buffer.  */\n+static const unsigned char *\n+backslash_start (pfile, cur)\n+     cpp_reader *pfile;\n+     const unsigned char *cur;\n+{\n+  if (cur[0] == '\\\\')\n+    return cur;\n+  if (cur[0] == '/' && cur[-1] == '?' && cur[-2] == '?'\n+      && trigraph_ok (pfile, cur))\n+    return cur - 2;\n+  return 0;\n+}\n+\n+/* Skip a C-style block comment.  This is probably the trickiest\n+   handler.  We find the end of the comment by seeing if an asterisk\n+   is before every '/' we encounter.  The nasty complication is that a\n+   previous asterisk may be separated by one or more escaped newlines.\n+   Returns non-zero if comment terminated by EOF, zero otherwise.  */\n+static int\n+skip_block_comment (pfile)\n+     cpp_reader *pfile;\n+{\n+  cpp_buffer *buffer = pfile->buffer;\n+  const unsigned char *char_after_star = 0;\n+  register const unsigned char *cur = buffer->cur;\n+  int seen_eof = 0;\n+  \n+  /* Inner loop would think the comment has ended if the first comment\n+     character is a '/'.  Avoid this and keep the inner loop clean by\n+     skipping such a character.  */\n+  if (cur < buffer->rlimit && cur[0] == '/')\n+    cur++;\n+\n+  for (; cur < buffer->rlimit; )\n+    {\n+      unsigned char c = *cur++;\n+\n+      /* People like decorating comments with '*', so check for\n+\t '/' instead for efficiency.  */\n+      if (c == '/')\n+\t{\n+\t  if (cur[-2] == '*' || cur - 1 == char_after_star)\n+\t    goto out;\n+\n+\t  /* Warn about potential nested comments, but not when\n+\t     the final character inside the comment is a '/'.\n+\t     Don't bother to get it right across escaped newlines.  */\n+\t  if (CPP_OPTION (pfile, warn_comments) && cur + 1 < buffer->rlimit\n+\t      && cur[0] == '*' && cur[1] != '/') \n+\t    {\n+\t      buffer->cur = cur;\n+\t      cpp_warning (pfile, \"'/*' within comment\");\n+\t    }\n+\t}\n+      else if (IS_NEWLINE(c))\n+\t{\n+\t  const unsigned char* bslash = backslash_start (pfile, cur - 2);\n+\n+\t  handle_newline (cur, buffer->rlimit, c);\n+\t  /* Work correctly if there is an asterisk before an\n+\t     arbirtrarily long sequence of escaped newlines.  */\n+\t  if (bslash && (bslash[-1] == '*' || bslash == char_after_star))\n+\t    char_after_star = cur;\n+\t  else\n+\t    char_after_star = 0;\n+\t}\n+    }\n+  seen_eof = 1;\n+\n+ out:\n+  buffer->cur = cur;\n+  return seen_eof;\n+}\n+\n+/* Skip a C++ or Chill line comment.  Handles escaped newlines.\n+   Returns non-zero if a multiline comment.  */\n+static int\n+skip_line_comment (pfile)\n+     cpp_reader *pfile;\n+{\n+  cpp_buffer *buffer = pfile->buffer;\n+  register const unsigned char *cur = buffer->cur;\n+  int multiline = 0;\n+\n+  for (; cur < buffer->rlimit; )\n+    {\n+      unsigned char c = *cur++;\n+\n+      if (IS_NEWLINE (c))\n+\t{\n+\t  /* Check for a (trigaph?) backslash escaping the newline.  */\n+\t  if (!backslash_start (pfile, cur - 2))\n+\t    goto out;\n+\t  multiline = 1;\n+\t  handle_newline (cur, buffer->rlimit, c);\n+\t}\n+    }\n+  cur++;\n+\n+ out:\n+  buffer->cur = cur - 1;\t/* Leave newline for caller.  */\n+  return multiline;\n+}\n+\n+/* Skips whitespace, stopping at next non-whitespace character.  */\n+static void\n+skip_whitespace (pfile, in_directive)\n+     cpp_reader *pfile;\n+     int in_directive;\n+{\n+  cpp_buffer *buffer = pfile->buffer;\n+  register const unsigned char *cur = buffer->cur;\n+  unsigned short null_count = 0;\n+\n+  for (; cur < buffer->rlimit; )\n+    {\n+      unsigned char c = *cur++;\n+\n+      if (IS_HSPACE(c))\t\t/* FIXME: Fix ISTABLE.  */\n+\tcontinue;\n+      if (!is_space(c) || IS_NEWLINE (c)) /* Main loop handles newlines.  */\n+\tgoto out;\n+      if (c == '\\0')\n+\tnull_count++;\n+      /* Mut be '\\f' or '\\v' */\n+      else if (in_directive && CPP_PEDANTIC (pfile))\n+\tcpp_pedwarn (pfile, \"%s in preprocessing directive\",\n+\t\t     c == '\\f' ? \"formfeed\" : \"vertical tab\");\n+    }\n+  cur++;\n+\n+ out:\n+  buffer->cur = cur - 1;\n+  if (null_count)\n+    cpp_warning (pfile, null_count > 1 ? \"embedded null characters ignored\"\n+\t\t : \"embedded null character ignored\");\n+}\n+\n+/* Parse (append) an identifier.  */\n+static void\n+parse_name (pfile, list, name)\n+     cpp_reader *pfile;\n+     cpp_toklist *list;\n+     cpp_name *name;\n+{\n+  const unsigned char *name_limit;\n+  unsigned char *namebuf;\n+  cpp_buffer *buffer = pfile->buffer;\n+  register const unsigned char *cur = buffer->cur;\n+\n+ expanded:\n+  name_limit = list->namebuf + list->name_cap;\n+  namebuf = list->namebuf + list->name_used;\n+\n+  for (; cur < buffer->rlimit && namebuf < name_limit; )\n+    {\n+      unsigned char c = *namebuf = *cur; /* Copy a single char.  */\n+\n+      if (! is_idchar(c))\n+\tgoto out;\n+      namebuf++;\n+      cur++;\n+      if (c == '$' && CPP_PEDANTIC (pfile))\n+\t{\n+\t  buffer->cur = cur;\n+\t  cpp_pedwarn (pfile, \"'$' character in identifier\");\n+\t}\n+    }\n+\n+  /* Run out of name space?  */\n+  if (cur < buffer->rlimit)\n+    {\n+      list->name_used = namebuf - list->namebuf;\n+      auto_expand_name_space (list);\n+      goto expanded;\n+    }\n+\n+ out:\n+  buffer->cur = cur;\n+  name->len = namebuf - (list->namebuf + name->offset);\n+  list->name_used = namebuf - list->namebuf;\n+}\n+\n+/* Parse (append) a number.  */\n+\n+#define VALID_SIGN(c, prevc) \\\n+  (((c) == '+' || (c) == '-') && \\\n+   ((prevc) == 'e' || (prevc) == 'E' \\\n+    || (((prevc) == 'p' || (prevc) == 'P') && !CPP_OPTION (pfile, c89))))\n+\n+static void\n+parse_number (pfile, list, name)\n+     cpp_reader *pfile;\n+     cpp_toklist *list;\n+     cpp_name *name;\n+{\n+  const unsigned char *name_limit;\n+  unsigned char *namebuf;\n+  cpp_buffer *buffer = pfile->buffer;\n+  register const unsigned char *cur = buffer->cur;\n+\n+ expanded:\n+  name_limit = list->namebuf + list->name_cap;\n+  namebuf = list->namebuf + list->name_used;\n+\n+  for (; cur < buffer->rlimit && namebuf < name_limit; )\n+    {\n+      unsigned char c = *namebuf = *cur; /* Copy a single char.  */\n+\n+      /* Perhaps we should accept '$' here if we accept it for\n+         identifiers.  We know namebuf[-1] is safe, because for c to\n+         be a sign we must have pushed at least one character.  */\n+      if (!is_numchar (c) && c != '.' && ! VALID_SIGN (c, namebuf[-1]))\n+\tgoto out;\n+\n+      namebuf++;\n+      cur++;\n+    }\n+\n+  /* Run out of name space?  */\n+  if (cur < buffer->rlimit)\n+    {\n+      list->name_used = namebuf - list->namebuf;\n+      auto_expand_name_space (list);\n+      goto expanded;\n+    }\n+  \n+ out:\n+  buffer->cur = cur;\n+  name->len = namebuf - (list->namebuf + name->offset);\n+  list->name_used = namebuf - list->namebuf;\n+}\n+\n+/* Places a string terminated by an unescaped TERMINATOR into a\n+   cpp_name, which should be expandable and thus at the top of the\n+   list's stack.  Handles embedded trigraphs, if necessary, and\n+   escaped newlines.\n+\n+   Can be used for character constants (terminator = '\\''), string\n+   constants ('\"'), angled headers ('>') and assertions (')').  */\n+\n+static void\n+parse_string (pfile, list, name, terminator)\n+     cpp_reader *pfile;\n+     cpp_toklist *list;\n+     cpp_name *name;\n+     unsigned int terminator;\n+{\n+  cpp_buffer *buffer = pfile->buffer;\n+  register const unsigned char *cur = buffer->cur;\n+  const unsigned char *name_limit;\n+  unsigned char *namebuf;\n+  unsigned int null_count = 0;\n+  int trigraphed_len = 0;\n+\n+ expanded:\n+  name_limit = list->namebuf + list->name_cap;\n+  namebuf = list->namebuf + list->name_used;\n+\n+  for (; cur < buffer->rlimit && namebuf < name_limit; )\n+    {\n+      unsigned int c = *namebuf++ = *cur++; /* Copy a single char.  */\n+\n+      if (c == '\\0')\n+\tnull_count++;\n+      else if (c == terminator || IS_NEWLINE (c))\n+\t{\n+\t  unsigned char* name_start = list->namebuf + name->offset;\n+\n+\t  /* Needed for trigraph_replace and multiline string warning.  */\n+\t  buffer->cur = cur;\n+\n+\t  /* Scan for trigraphs before checking if backslash-escaped.  */\n+\t  if (CPP_OPTION (pfile, trigraphs)\n+\t      || CPP_OPTION (pfile, warn_trigraphs))\n+\t    {\n+\t      namebuf = trigraph_replace (pfile, name_start + trigraphed_len,\n+\t\t\t\t\t    namebuf);\n+\t      trigraphed_len = namebuf - 2 - (name_start + trigraphed_len);\n+\t      if (trigraphed_len < 0)\n+\t\ttrigraphed_len = 0;\n+\t    }\n+\n+\t  namebuf--;     /* Drop the newline / terminator from the name.  */\n+\t  if (IS_NEWLINE (c))\n+\t    {\n+\t      /* Drop a backslash newline, and continue. */\n+\t      if (namebuf[-1] == '\\\\')\n+\t\t{\n+\t\t  handle_newline (cur, buffer->rlimit, c);\n+\t\t  namebuf--;\n+\t\t  continue;\n+\t\t}\n+\n+\t      cur--;\n+\n+\t      /* In Fortran and assembly language, silently terminate\n+\t\t strings of either variety at end of line.  This is a\n+\t\t kludge around not knowing where comments are in these\n+\t\t languages.  */\n+\t      if (CPP_OPTION (pfile, lang_fortran)\n+\t\t  || CPP_OPTION (pfile, lang_asm))\n+\t\tgoto out;\n+\n+\t      /* Character constants, headers and asserts may not\n+\t\t extend over multiple lines.  In Standard C, neither\n+\t\t may strings.  We accept multiline strings as an\n+\t\t extension, but not in directives.  */\n+\t      if (terminator != '\"' || IS_DIRECTIVE (list))\n+\t\tgoto unterminated;\n+\t\t\n+\t      cur++;  /* Move forwards again.  */\n+\n+\t      if (pfile->multiline_string_line == 0)\n+\t\t{\n+\t\t  pfile->multiline_string_line = list->line;\n+\t\t  if (CPP_PEDANTIC (pfile))\n+\t\t    cpp_pedwarn (pfile, \"multi-line string constant\");\n+\t\t}\n+\n+\t      *namebuf++ = '\\n';\n+\t      handle_newline (cur, buffer->rlimit, c);\n+\t    }\n+\t  else\n+\t    {\n+\t      unsigned char *temp;\n+\n+\t      /* An odd number of consecutive backslashes represents\n+\t\t an escaped terminator.  */\n+\t      temp = namebuf - 1;\n+\t      while (temp >= name_start && *temp == '\\\\')\n+\t\ttemp--;\n+\n+\t      if ((namebuf - temp) & 1)\n+\t\tgoto out;\n+\t      namebuf++;\n+\t    }\n+\t}\n+    }\n+\n+  /* Run out of name space?  */\n+  if (cur < buffer->rlimit)\n+    {\n+      list->name_used = namebuf - list->namebuf;\n+      auto_expand_name_space (list);\n+      goto expanded;\n+    }\n+\n+  /* We may not have trigraph-replaced the input for this code path,\n+     but as the input is in error by being unterminated we don't\n+     bother.  Prevent warnings about no newlines at EOF.  */\n+  if (IS_NEWLINE(cur[-1]))\n+    cur--;\n+\n+ unterminated:\n+  cpp_error (pfile, \"missing terminating %c character\", (int) terminator);\n+\n+  if (terminator == '\\\"' && pfile->multiline_string_line != list->line\n+      && pfile->multiline_string_line != 0)\n+    {\n+      cpp_error_with_line (pfile, pfile->multiline_string_line, -1,\n+\t\t\t   \"possible start of unterminated string literal\");\n+      pfile->multiline_string_line = 0;\n+    }\n+  \n+ out:\n+  buffer->cur = cur;\n+  name->len = namebuf - (list->namebuf + name->offset);\n+  list->name_used = namebuf - list->namebuf;\n+\n+  if (null_count > 0)\n+    cpp_warning (pfile, (null_count > 1 ? \"null characters preserved\"\n+\t\t\t : \"null character preserved\"));\n+}\n+\n+/* The character C helps us distinguish comment types: '*' = C style,\n+   '-' = Chill-style and '/' = C++ style.  For code simplicity, the\n+   stored comment includes any C-style comment terminator.  */\n+static void\n+copy_comment (list, from, len, tok_no, type)\n+     cpp_toklist *list;\n+     const unsigned char *from;\n+     unsigned int len;\n+     unsigned int tok_no;\n+     unsigned int type;\n+{\n+  cpp_token *comment;\n+\n+  if (list->comments_used == list->comments_cap)\n+    expand_comment_space (list);\n+\n+  if (list->name_used + len > list->name_cap)\n+    expand_name_space (list, len);\n+\n+  comment = &list->comments[list->comments_used++];\n+  comment->type = type;\n+  comment->aux = tok_no;\n+  comment->val.name.len = len;\n+  comment->val.name.offset = list->name_used;\n+\n+  memcpy (list->namebuf + list->name_used, from, len);\n+  list->name_used += len;\n+}\n+\n+/*\n+ *  The tokenizer's main loop.  Returns a token list, representing a\n+ *  logical line in the input file, terminated with a CPP_VSPACE\n+ *  token.  On EOF, a token list containing the single CPP_EOF token\n+ *  is returned.\n+ *\n+ *  Implementation relies almost entirely on lookback, rather than\n+ *  looking forwards.  This means that tokenization requires just\n+ *  a single pass of the file, even in the presence of trigraphs and\n+ *  escaped newlines, providing significant performance benefits.\n+ *  Trigraph overhead is negligible if they are disabled, and low\n+ *  even when enabled.\n+ */\n+\n+#define PUSH_TOKEN(ttype) cur_token++->type = ttype\n+#define REVISE_TOKEN(ttype) cur_token[-1].type = ttype\n+#define BACKUP_TOKEN(ttype) (--cur_token)->type = ttype\n+#define BACKUP_DIGRAPH(ttype) do { \\\n+  BACKUP_TOKEN(ttype); cur_token->flags |= DIGRAPH;} while (0)\n+\n+void\n+_cpp_lex_line (pfile, list)\n+     cpp_reader *pfile;\n+     cpp_toklist *list;\n+{\n+  cpp_token *cur_token, *token_limit;\n+  cpp_buffer *buffer = pfile->buffer;\n+  register const unsigned char *cur = buffer->cur;\n+  unsigned char flags = 0;\n+\n+ expanded:\n+  token_limit = list->tokens + list->tokens_cap;\n+  cur_token = list->tokens + list->tokens_used;\n+\n+  for (; cur < buffer->rlimit && cur_token < token_limit;)\n+    {\n+      unsigned char c = *cur++;\n+\n+      /* Optimize whitespace skipping, in particular the case of a\n+\t single whitespace character, as every other token is probably\n+\t whitespace. (' ' '\\t' '\\v' '\\f' '\\0').  */\n+      if (is_hspace ((unsigned int) c))\n+\t{\n+\t  if (c == '\\0' || (cur < buffer->rlimit && is_hspace (*cur)))\n+\t    {\n+\t      buffer->cur = cur - (c == '\\0');\t/* Get the null warning.  */\n+\t      skip_whitespace (pfile, IS_DIRECTIVE (list));\n+\t      cur = buffer->cur;\n+\t    }\n+\t  flags = PREV_WHITESPACE;\n+\t  if (cur == buffer->rlimit)\n+\t    break;\n+\t  c = *cur++;\n+\t}\n+\n+      /* Initialize current token.  Its type is set in the switch.  */\n+      cur_token->col = COLUMN (cur);\n+      cur_token->flags = flags;\n+      flags = 0;\n+\n+      switch (c)\n+\t{\n+\tcase '0': case '1': case '2': case '3': case '4':\n+\tcase '5': case '6': case '7': case '8': case '9':\n+\t  /* Prepend an immediately previous CPP_DOT token.  */\n+\t  if (PREV_TOKEN_TYPE == CPP_DOT && IMMED_TOKEN ())\n+\t    {\n+\t      cur_token--;\n+\t      if (list->name_cap == list->name_used)\n+\t\tauto_expand_name_space (list);\n+\n+\t      cur_token->val.name.len = 1;\n+\t      cur_token->val.name.offset = list->name_used;\n+\t      list->namebuf[list->name_used++] = '.';\n+\t    }\n+\t  else\n+\t    INIT_NAME (list, cur_token->val.name);\n+\t  cur--;\t\t/* Backup character.  */\n+\n+\tcontinue_number:\n+\t  buffer->cur = cur;\n+\t  parse_number (pfile, list, &cur_token->val.name);\n+\t  cur = buffer->cur;\n+\n+\t  PUSH_TOKEN (CPP_NUMBER); /* Number not yet interpreted.  */\n+\t  break;\n+\n+\tletter:\n+\tcase '_':\n+\tcase 'a': case 'b': case 'c': case 'd': case 'e': case 'f':\n+\tcase 'g': case 'h': case 'i': case 'j': case 'k': case 'l':\n+\tcase 'm': case 'n': case 'o': case 'p': case 'q': case 'r':\n+\tcase 's': case 't': case 'u': case 'v': case 'w': case 'x':\n+\tcase 'y': case 'z':\n+\tcase 'A': case 'B': case 'C': case 'D': case 'E': case 'F':\n+\tcase 'G': case 'H': case 'I': case 'J': case 'K': case 'L':\n+\tcase 'M': case 'N': case 'O': case 'P': case 'Q': case 'R':\n+\tcase 'S': case 'T': case 'U': case 'V': case 'W': case 'X':\n+\tcase 'Y': case 'Z':\n+\t  INIT_NAME (list, cur_token->val.name);\n+\t  cur--;\t\t     /* Backup character.  */\n+\t  cur_token->type = CPP_NAME; /* Identifier, macro etc.  */\n+\n+\tcontinue_name:\n+\t  buffer->cur = cur;\n+\t  parse_name (pfile, list, &cur_token->val.name);\n+\t  cur = buffer->cur;\n+\n+\t  /* Find handler for newly created / extended directive.  */\n+\t  if (IS_DIRECTIVE (list) && cur_token == &list->tokens[1])\n+\t    _cpp_check_directive (list, cur_token);\n+\t  cur_token++;\n+\t  break;\n+\n+\tcase '\\'':\n+\t  /* Fall through.  */\n+\tcase '\\\"':\n+\t  cur_token->type = c == '\\'' ? CPP_CHAR : CPP_STRING;\n+\t  /* Do we have a wide string?  */\n+\t  if (cur_token[-1].type == CPP_NAME && IMMED_TOKEN ()\n+\t      && cur_token[-1].val.name.len == 1\n+\t      && TOK_NAME (list, cur_token - 1)[0] == 'L'\n+\t      && !CPP_TRADITIONAL (pfile))\n+\t    {\n+\t      /* No need for 'L' any more.  */\n+\t      list->name_used--;\n+\t      (--cur_token)->type = (c == '\\'' ? CPP_WCHAR : CPP_WSTRING);\n+\t    }\n+\n+\tdo_parse_string:\n+\t  /* Here c is one of ' \" > or ).  */\n+\t  INIT_NAME (list, cur_token->val.name);\n+\t  buffer->cur = cur;\n+\t  parse_string (pfile, list, &cur_token->val.name, c);\n+\t  cur = buffer->cur;\n+\t  cur_token++;\n+\t  break;\n+\n+\tcase '/':\n+\t  cur_token->type = CPP_DIV;\n+\t  if (IMMED_TOKEN ())\n+\t    {\n+\t      if (PREV_TOKEN_TYPE == CPP_DIV)\n+\t\t{\n+\t\t  /* We silently allow C++ comments in system headers,\n+\t\t     irrespective of conformance mode, because lots of\n+\t\t     broken systems do that and trying to clean it up\n+\t\t     in fixincludes is a nightmare.  */\n+\t\t  if (buffer->system_header_p)\n+\t\t    goto do_line_comment;\n+\t\t  else if (CPP_OPTION (pfile, cplusplus_comments))\n+\t\t    {\n+\t\t      if (CPP_OPTION (pfile, c89) && CPP_PEDANTIC (pfile)\n+\t\t\t  && ! buffer->warned_cplusplus_comments)\n+\t\t\t{\n+\t\t\t  buffer->cur = cur;\n+\t\t\t  cpp_pedwarn (pfile,\n+\t\t\t     \"C++ style comments are not allowed in ISO C89\");\n+\t\t\t  cpp_pedwarn (pfile,\n+\t\t\t  \"(this will be reported only once per input file)\");\n+\t\t\t  buffer->warned_cplusplus_comments = 1;\n+\t\t\t}\n+\t\t    do_line_comment:\n+\t\t      buffer->cur = cur;\n+\t\t      if (cur[-2] != c)\n+\t\t\tcpp_warning (pfile,\n+\t\t\t\t     \"comment start split across lines\");\n+\t\t      if (skip_line_comment (pfile))\n+\t\t\tcpp_error_with_line (pfile, list->line,\n+\t\t\t\t\t     cur_token[-1].col,\n+\t\t\t\t\t     \"multi-line comment\");\n+\t\t      if (!CPP_OPTION (pfile, discard_comments))\n+\t\t\tcopy_comment (list, cur, buffer->cur - cur,\n+\t\t\t\t      cur_token - 1 - list->tokens, c == '/'\n+\t\t\t\t      ? CPP_CPP_COMMENT: CPP_CHILL_COMMENT);\n+\t\t      cur = buffer->cur;\n+\n+\t\t      /* Back-up to first '-' or '/'.  */\n+\t\t      cur_token -= 2;\n+\t\t      if (!CPP_OPTION (pfile, traditional))\n+\t\t\tflags = PREV_WHITESPACE;\n+\t\t    }\n+\t\t}\n+\t    }\n+\t  cur_token++;\n+\t  break;\n+\t\t      \n+\tcase '*':\n+\t  cur_token->type = CPP_MULT;\n+\t  if (IMMED_TOKEN ())\n+\t    {\n+\t      if (PREV_TOKEN_TYPE == CPP_DIV)\n+\t\t{\n+\t\t  buffer->cur = cur;\n+\t\t  if (cur[-2] != '/')\n+\t\t    cpp_warning (pfile,\n+\t\t\t\t \"comment start '/*' split across lines\");\n+\t\t  if (skip_block_comment (pfile))\n+\t\t    cpp_error_with_line (pfile, list->line, cur_token[-1].col,\n+\t\t\t\t\t \"unterminated comment\");\n+\t\t  else if (buffer->cur[-2] != '*')\n+\t\t    cpp_warning (pfile,\n+\t\t\t\t \"comment end '*/' split across lines\");\n+\t\t  if (!CPP_OPTION (pfile, discard_comments))\n+\t\t    copy_comment (list, cur, buffer->cur - cur,\n+\t\t\t\t cur_token - 1 - list->tokens, CPP_C_COMMENT);\n+\t\t  cur = buffer->cur;\n+\n+\t\t  cur_token -= 2;\n+\t\t  if (!CPP_OPTION (pfile, traditional))\n+\t\t    flags = PREV_WHITESPACE;\n+\t\t}\n+\t      else if (CPP_OPTION (pfile, cplusplus))\n+\t\t{\n+\t\t  /* In C++, there are .* and ->* operators.  */\n+\t\t  if (PREV_TOKEN_TYPE == CPP_DEREF)\n+\t\t    BACKUP_TOKEN (CPP_DEREF_STAR);\n+\t\t  else if (PREV_TOKEN_TYPE == CPP_DOT)\n+\t\t    BACKUP_TOKEN (CPP_DOT_STAR);\n+\t\t}\n+\t    }\n+\t  cur_token++;\n+\t  break;\n+\n+\tcase '\\n':\n+\tcase '\\r':\n+\t  handle_newline (cur, buffer->rlimit, c);\n+\t  if (PREV_TOKEN_TYPE != CPP_BACKSLASH || !IMMED_TOKEN ())\n+\t    {\n+\t      if (PREV_TOKEN_TYPE == CPP_BACKSLASH)\n+\t\t{\n+\t\t  buffer->cur = cur;\n+\t\t  cpp_warning (pfile,\n+\t\t\t       \"backslash and newline separated by space\");\n+\t\t}\n+\t      PUSH_TOKEN (CPP_VSPACE);\n+\t      goto out;\n+\t    }\n+\t  /* Remove the escaped newline.  Then continue to process\n+\t     any interrupted name or number.  */\n+\t  cur_token--;\n+\t  if (IMMED_TOKEN ())\n+\t    {\n+\t      cur_token--;\n+\t      if (cur_token->type == CPP_NAME)\n+\t\tgoto continue_name;\n+\t      else if (cur_token->type == CPP_NUMBER)\n+\t\tgoto continue_number;\n+\t      cur_token++;\n+\t    }\n+\t  break;\n+\n+\tcase '-':\n+\t  if (IMMED_TOKEN () && PREV_TOKEN_TYPE == CPP_MINUS)\n+\t    {\n+\t      if (CPP_OPTION (pfile, chill))\n+\t\tgoto do_line_comment;\n+\t      REVISE_TOKEN (CPP_MINUS_MINUS);\n+\t    }\n+\t  else\n+\t    PUSH_TOKEN (CPP_MINUS);\n+\t  break;\n+\n+\t  /* The digraph flag checking ensures that ## and %:%:\n+\t     are interpreted as CPP_PASTE, but #%: and %:# are not.  */\n+\tmake_hash:\n+\tcase '#':\n+\t  if (PREV_TOKEN_TYPE == CPP_HASH && IMMED_TOKEN ()\n+\t      && ((cur_token->flags ^ cur_token[-1].flags) & DIGRAPH) == 0)\n+\t    REVISE_TOKEN (CPP_PASTE);\n+\t  else\n+\t    PUSH_TOKEN (CPP_HASH);\n+\t  break;\n+\n+\tcase ':':\n+\t  cur_token->type = CPP_COLON;\n+\t  if (IMMED_TOKEN ())\n+\t    {\n+\t      if (PREV_TOKEN_TYPE == CPP_COLON\n+\t\t  && CPP_OPTION (pfile, cplusplus))\n+\t\tBACKUP_TOKEN (CPP_SCOPE);\n+\t      /* Digraph: \"<:\" is a '['  */\n+\t      else if (PREV_TOKEN_TYPE == CPP_LESS)\n+\t\tBACKUP_DIGRAPH (CPP_OPEN_SQUARE);\n+\t      /* Digraph: \"%:\" is a '#'  */\n+\t      else if (PREV_TOKEN_TYPE == CPP_MOD)\n+\t\t{\n+\t\t  (--cur_token)->flags |= DIGRAPH;\n+\t\t  goto make_hash;\n+\t\t}\n+\t    }\n+\t  cur_token++;\n+\t  break;\n+\n+\tcase '&':\n+\t  if (IMMED_TOKEN () && PREV_TOKEN_TYPE == CPP_AND)\n+\t    REVISE_TOKEN (CPP_AND_AND);\n+\t  else\n+\t    PUSH_TOKEN (CPP_AND);\n+\t  break;\n+\n+\tmake_or:\n+\tcase '|':\n+\t  if (IMMED_TOKEN () && PREV_TOKEN_TYPE == CPP_OR)\n+\t    REVISE_TOKEN (CPP_OR_OR);\n+\t  else\n+\t    PUSH_TOKEN (CPP_OR);\n+\t  break;\n+\n+\tcase '+':\n+\t  if (IMMED_TOKEN () && PREV_TOKEN_TYPE == CPP_PLUS)\n+\t    REVISE_TOKEN (CPP_PLUS_PLUS);\n+\t  else\n+\t    PUSH_TOKEN (CPP_PLUS);\n+\t  break;\n+\n+\tcase '=':\n+\t    /* This relies on equidistance of \"?=\" and \"?\" tokens.  */\n+\t  if (IMMED_TOKEN () && PREV_TOKEN_TYPE <= CPP_LAST_EQ)\n+\t    REVISE_TOKEN (PREV_TOKEN_TYPE + (CPP_EQ_EQ - CPP_EQ));\n+\t  else\n+\t    PUSH_TOKEN (CPP_EQ);\n+\t  break;\n+\n+\tcase '>':\n+\t  cur_token->type = CPP_GREATER;\n+\t  if (IMMED_TOKEN ())\n+\t    {\n+\t      if (PREV_TOKEN_TYPE == CPP_GREATER)\n+\t\tBACKUP_TOKEN (CPP_RSHIFT);\n+\t      else if (PREV_TOKEN_TYPE == CPP_MINUS)\n+\t\tBACKUP_TOKEN (CPP_DEREF);\n+\t      /* Digraph: \":>\" is a ']'  */\n+\t      else if (PREV_TOKEN_TYPE == CPP_COLON)\n+\t\tBACKUP_DIGRAPH (CPP_CLOSE_SQUARE);\n+\t      /* Digraph: \"%>\" is a '}'  */\n+\t      else if (PREV_TOKEN_TYPE == CPP_MOD)\n+\t\tBACKUP_DIGRAPH (CPP_CLOSE_BRACE);\n+\t    }\n+\t  cur_token++;\n+\t  break;\n+\t  \n+\tcase '<':\n+\t  if (IMMED_TOKEN () && PREV_TOKEN_TYPE == CPP_LESS)\n+\t    {\n+\t      REVISE_TOKEN (CPP_LSHIFT);\n+\t      break;\n+\t    }\n+\t  /* Is this the beginning of a header name?  */\n+\t  if (list->dir_flags & SYNTAX_INCLUDE)\n+\t    {\n+\t      c = '>';\t/* Terminator.  */\n+\t      cur_token->type = CPP_HEADER_NAME;\n+\t      goto do_parse_string;\n+\t    }\n+\t  PUSH_TOKEN (CPP_LESS);\n+\t  break;\n+\n+\tcase '%':\n+\t  /* Digraph: \"<%\" is a '{'  */\n+\t  cur_token->type = CPP_MOD;\n+\t  if (IMMED_TOKEN () && PREV_TOKEN_TYPE == CPP_LESS)\n+\t    BACKUP_DIGRAPH (CPP_OPEN_BRACE);\n+\t  cur_token++;\n+\t  break;\n+\n+\tcase ')':\n+\t  PUSH_TOKEN (CPP_CLOSE_PAREN);\n+\t  break;\n+\n+\tcase '(':\n+\t  /* Is this the beginning of an assertion string?  */\n+\t  if (list->dir_flags & SYNTAX_ASSERT)\n+\t    {\n+\t      c = ')';\t/* Terminator.  */\n+\t      cur_token->type = CPP_ASSERTION;\n+\t      goto do_parse_string;\n+\t    }\n+\t  PUSH_TOKEN (CPP_OPEN_PAREN);\n+\t  break;\n+\n+\tmake_complement:\n+\tcase '~':\n+\t  PUSH_TOKEN (CPP_COMPL);\n+\t  break;\n+\n+\tcase '?':\n+\t  if (cur + 1 < buffer->rlimit && *cur == '?'\n+\t      && trigraph_map[cur[1]] && trigraph_ok (pfile, cur + 1))\n+\t    {\n+\t      /* Handle trigraph.  */\n+\t      cur++;\n+\t      switch (*cur++)\n+\t\t{\n+\t\tcase '(': goto make_open_square;\n+\t\tcase ')': goto make_close_square;\n+\t\tcase '<': goto make_open_brace;\n+\t\tcase '>': goto make_close_brace;\n+\t\tcase '=': goto make_hash;\n+\t\tcase '!': goto make_or;\n+\t\tcase '-': goto make_complement;\n+\t\tcase '/': goto make_backslash;\n+\t\tcase '\\'': goto make_xor;\n+\t\t}\n+\t    }\n+\t  if (IMMED_TOKEN () && CPP_OPTION (pfile, cplusplus))\n+\t    {\n+\t      /* GNU C++ defines <? and >? operators.  */\n+\t      if (PREV_TOKEN_TYPE == CPP_LESS)\n+\t\t{\n+\t\t  REVISE_TOKEN (CPP_MIN);\n+\t\t  break;\n+\t\t}\n+\t      else if (PREV_TOKEN_TYPE == CPP_GREATER)\n+\t\t{\n+\t\t  REVISE_TOKEN (CPP_MAX);\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t  PUSH_TOKEN (CPP_QUERY);\n+\t  break;\n+\n+\tcase '.':\n+\t  if (PREV_TOKEN_TYPE == CPP_DOT && cur_token[-2].type == CPP_DOT\n+\t      && IMMED_TOKEN ()\n+\t      && !(cur_token[-1].flags & PREV_WHITESPACE))\n+\t    {\n+\t      cur_token -= 2;\n+\t      PUSH_TOKEN (CPP_ELLIPSIS);\n+\t    }\n+\t  else\n+\t    PUSH_TOKEN (CPP_DOT);\n+\t  break;\n+\n+\tmake_xor:\n+\tcase '^': PUSH_TOKEN (CPP_XOR); break;\n+\tmake_open_brace:\n+\tcase '{': PUSH_TOKEN (CPP_OPEN_BRACE); break;\n+\tmake_close_brace:\n+\tcase '}': PUSH_TOKEN (CPP_CLOSE_BRACE); break;\n+\tmake_open_square:\n+\tcase '[': PUSH_TOKEN (CPP_OPEN_SQUARE); break;\n+\tmake_close_square:\n+\tcase ']': PUSH_TOKEN (CPP_CLOSE_SQUARE); break;\n+\tmake_backslash:\n+\tcase '\\\\': PUSH_TOKEN (CPP_BACKSLASH); break;\n+\tcase '!': PUSH_TOKEN (CPP_NOT); break;\n+\tcase ',': PUSH_TOKEN (CPP_COMMA); break;\n+\tcase ';': PUSH_TOKEN (CPP_SEMICOLON); break;\n+\n+\tcase '$':\n+\t  if (CPP_OPTION (pfile, dollars_in_ident))\n+\t    goto letter;\n+\t  /* Fall through */\n+\tdefault:\n+\t  cur_token->aux = c;\n+\t  PUSH_TOKEN (CPP_OTHER);\n+\t  break;\n+\t}\n+    }\n+\n+  /* Run out of token space?  */\n+  if (cur_token == token_limit)\n+    {\n+      list->tokens_used = cur_token - list->tokens;\n+      expand_token_space (list);\n+      goto expanded;\n+    }\n+\n+  cur_token->type = CPP_EOF;\n+  cur_token->flags = flags;\n+\n+  if (cur_token != &list->tokens[0])\n+    {\n+      /* Next call back will get just a CPP_EOF.  */\n+      buffer->cur = cur;\n+      cpp_warning (pfile, \"no newline at end of file\");\n+      PUSH_TOKEN (CPP_VSPACE);\n+    }\n+\n+ out:\n+  buffer->cur = cur;\n+\n+  list->tokens_used = cur_token - list->tokens;\n+\n+  /* FIXME:  take this check out and put it in the caller.\n+     list->directive == 0 indicates an unknown directive (but null\n+     directive is OK).  This is the first time we can be sure the\n+     directive is invalid, and thus warn about it, because it might\n+     have been split by escaped newlines.  Also, don't complain about\n+     invalid directives in assembly source, we don't know where the\n+     comments are, and # may introduce assembler pseudo-ops.  */\n+\n+  if (IS_DIRECTIVE (list) && list->dir_handler == 0\n+      && list->tokens[1].type != CPP_VSPACE\n+      && !CPP_OPTION (pfile, lang_asm))\n+    cpp_error_with_line (pfile, list->line, list->tokens[1].col,\n+\t\t\t \"invalid preprocessing directive\");\n+}\n+\n+/* Token spelling functions.  Used for output of a preprocessed file,\n+   stringizing and token pasting.  They all assume sufficient buffer\n+   is allocated, and return exactly how much they used.  */\n+\n+/* Needs buffer of 3 + len.  */\n+unsigned int\n+spell_char (buffer, list, token)\n+     unsigned char *buffer;\n+     cpp_toklist *list;\n+     cpp_token *token;\n+{\n+  unsigned char* orig_buff = buffer;\n+  size_t len;\n+\n+  if (token->type == CPP_WCHAR)\n+    *buffer++ = 'L';\n+  *buffer++ = '\\'';\n+\n+  len = token->val.name.len;\n+  memcpy (buffer, TOK_NAME (list, token), len);\n+  buffer += len;\n+  *buffer++ = '\\'';\n+  return buffer - orig_buff;\n+}\n+\n+/* Needs buffer of 3 + len.  */\n+unsigned int\n+spell_string (buffer, list, token)\n+     unsigned char *buffer;\n+     cpp_toklist *list;\n+     cpp_token *token;\n+{\n+  unsigned char* orig_buff = buffer;\n+  size_t len;\n+\n+  if (token->type == CPP_WSTRING)\n+    *buffer++ = 'L';\n+  *buffer++ = '\"';\n+\n+  len = token->val.name.len;\n+  memcpy (buffer, TOK_NAME (list, token), len);\n+  buffer += len;\n+  *buffer++ = '\"';\n+  return buffer - orig_buff;\n+}\n+\n+/* Needs buffer of len + 2.  */\n+unsigned int\n+spell_comment (buffer, list, token)\n+     unsigned char *buffer;\n+     cpp_toklist *list;\n+     cpp_token *token;\n+{\n+  size_t len;\n+\n+  if (token->type == CPP_C_COMMENT)\n+    {\n+      *buffer++ = '/';\n+      *buffer++ = '*';\n+    }\n+  else if (token->type == CPP_CPP_COMMENT)\n+    {\n+      *buffer++ = '/';\n+      *buffer++ = '/';\n+    }\n+  else \n+    {\n+      *buffer++ = '-';\n+      *buffer++ = '-';\n+    }\n+\n+  len = token->val.name.len;\n+  memcpy (buffer, TOK_NAME (list, token), len);\n+\n+  return len + 2;\n+}\n+\n+/* Needs buffer of len.  */\n+unsigned int\n+spell_name (buffer, list, token)\n+     unsigned char *buffer;\n+     cpp_toklist *list;\n+     cpp_token *token;\n+{\n+  size_t len;\n+\n+  len = token->val.name.len;\n+  memcpy (buffer, TOK_NAME (list, token), len);\n+  buffer += len;\n+\n+  return len;\n+}\n+\n+/* Needs buffer of 1.  */\n+unsigned int\n+spell_other (buffer, list, token)\n+     unsigned char *buffer;\n+     cpp_toklist *list ATTRIBUTE_UNUSED;\n+     cpp_token *token;\n+{\n+  *buffer++ = token->aux;\n+  return 1;\n+}\n+\n+void\n+_cpp_lex_file (pfile)\n+     cpp_reader* pfile;\n+{\n+  int recycle;\n+  cpp_toklist* list;\n+\n+  init_trigraph_map ();\n+  list = (cpp_toklist *) xmalloc (sizeof (cpp_toklist));\n+\n+  for (recycle = 0; ;)\n+    {\n+      init_token_list (pfile, list, recycle);\n+      recycle = 1;\n+\n+      _cpp_lex_line (pfile, list);\n+      if (list->tokens[0].type == CPP_EOF)\n+\tbreak;\n+\n+      if (list->dir_handler)\n+\t{\n+\t  if (list->dir_handler (pfile))\n+\t    {\n+\t      list = (cpp_toklist *) xmalloc (sizeof (cpp_toklist));\n+\t      recycle = 0;\n+\t    }\n+\t}\n+      else\n+\t_cpp_output_list (pfile, list);\n+    }\n+}\n+\n+static void\n+_cpp_output_list (pfile, list)\n+     cpp_reader *pfile;\n+     cpp_toklist *list;\n+{\n+  unsigned int comment_no = 0;\n+  cpp_token *token, *comment_token = 0;\n+\n+  if (list->comments_used > 0)\n+    comment_token = list->tokens + list->comments[0].aux;\n+\n+  CPP_RESERVE (pfile, 2);\t/* Always have room for \" \\n\".  */\n+  for (token = &list->tokens[0];; token++)\n+    {\n+      if (token->flags & PREV_WHITESPACE)\n+\t{\n+\t  /* Output comments if -C.  Otherwise a space will do.  */\n+\t  if (token == comment_token)\n+\t    {\n+\t      cpp_token *comment = &list->comments[comment_no];\n+\t      do\n+\t\t{\n+\t\t  /* Longest wrapper is 4.  */\n+\t\t  CPP_RESERVE (pfile, 4 + 2 + comment->val.name.len);\n+\t\t  pfile->limit += spell_comment (pfile->limit, list, comment);\n+\t\t  comment_no++, comment++;\n+\t\t  if (comment_no == list->comments_used)\n+\t\t    break;\n+\t\t  comment_token = comment->aux + list->tokens;\n+\t\t}\n+\t      while (comment_token == token);\n+\t    }\n+\t  else\n+\t    CPP_PUTC_Q (pfile, ' ');\n+\t}\n+\n+      switch (token_spellings[token->type].type)\n+\t{\n+\tcase SPELL_TEXT:\n+\t  {\n+\t    const unsigned char *spelling;\n+\t    unsigned char c;\n+\n+\t    CPP_RESERVE (pfile, 4 + 2); /* Longest is 4.  */\n+\t    if (token->flags & DIGRAPH)\n+\t      spelling = digraph_spellings [token->type - CPP_FIRST_DIGRAPH];\n+\t    else\n+\t      spelling = token_spellings[token->type].speller;\n+\n+\t    while ((c = *spelling++) != '\\0')\n+\t      CPP_PUTC_Q (pfile, c);\n+\t  }\n+\t  break;\n+\n+\tcase SPELL_HANDLER:\n+\t  {\n+\t    speller s;\n+\n+\t    s = (speller) token_spellings[token->type].speller;\n+\t    /* Longest wrapper is 4.  */\n+\t    CPP_RESERVE (pfile, 4 + 2 + token->val.name.len);\n+\t    pfile->limit += s (pfile->limit, list, token);\n+\t  }\n+\t  break;\n+\n+\tcase SPELL_EOL:\n+\t  CPP_PUTC_Q (pfile, '\\n');\n+\t  return;\n+\n+\tcase SPELL_NONE:\n+\t  cpp_error (pfile, \"Unwriteable token\");\n+\t  break;\n+\t}\n+    }\n+}\n+\n+#endif"}, {"sha": "2d466ff1d55e4a1687d5a9031484d76bc05cf946", "filename": "gcc/cpplib.c", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5a047348d810987513ce54c6533c1314ad19593/gcc%2Fcpplib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5a047348d810987513ce54c6533c1314ad19593/gcc%2Fcpplib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.c?ref=c5a047348d810987513ce54c6533c1314ad19593", "patch": "@@ -150,6 +150,29 @@ DIRECTIVE_TABLE\n #undef D\n #undef DIRECTIVE_TABLE\n \n+/* Check if a token's name matches that of a known directive.  Put in\n+   this file to save exporting dtable and other unneeded information.  */\n+void\n+_cpp_check_directive (list, token)\n+     cpp_toklist *list;\n+     cpp_token *token;\n+{\n+  const char *name = list->namebuf + token->val.name.offset;\n+  size_t len = token->val.name.len;\n+  unsigned int i;\n+\n+  list->dir_handler = 0;\n+  list->dir_flags = 0;\n+\n+  for (i = 0; i < N_DIRECTIVES; i++)\n+    if (dtable[i].length == len && !strncmp (dtable[i].name, name, len)) \n+      {\n+\tlist->dir_handler = dtable[i].func;\n+\tlist->dir_flags = dtable[i].flags;\n+\tbreak;\n+      }\n+}\n+\n /* Handle a possible # directive.\n    '#' has already been read.  */\n "}, {"sha": "aca02a9efce68c3034b86d89464f1b4acd6d27ab", "filename": "gcc/cpplib.h", "status": "modified", "additions": 84, "deletions": 45, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5a047348d810987513ce54c6533c1314ad19593/gcc%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5a047348d810987513ce54c6533c1314ad19593/gcc%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.h?ref=c5a047348d810987513ce54c6533c1314ad19593", "patch": "@@ -34,13 +34,26 @@ typedef struct cpp_options cpp_options;\n typedef struct cpp_printer cpp_printer;\n typedef struct cpp_token cpp_token;\n typedef struct cpp_toklist cpp_toklist;\n+typedef struct cpp_name cpp_name;\n+\n+/* The first two groups, apart from '=', can appear in preprocessor\n+   expressions.  This allows a lookup table to be implemented in\n+   _cpp_parse_expr.\n+\n+   The first group, to CPP_LAST_EQ, can be immediately followed by an\n+   '='.  The lexer needs operators ending in '=', like \">>=\", to be in\n+   the same order as their counterparts without the '=', like \">>\".  */\n+\n+/* Positions in the table.  */\n+#define CPP_LAST_EQ CPP_LSHIFT\n+#define CPP_FIRST_DIGRAPH CPP_HASH\n \n-  /* Put operators that can appear in a preprocessor expression first.\n-     This allows a lookup table to be implemented in _cpp_parse_expr.\n-     Ordering within this group is currently not significant, apart\n-     from those ending in '=' being at the end.  */\n #define TTYPE_TABLE\t\t\t\t\\\n-  T(CPP_PLUS = 0,\t\"+\")\t/* math */\t\\\n+  T(CPP_EQ = 0,\t\t\"=\")\t\t\t\\\n+  T(CPP_NOT,\t\t\"!\")\t\t\t\\\n+  T(CPP_GREATER,\t\">\")\t/* compare */\t\\\n+  T(CPP_LESS,\t\t\"<\")\t\t\t\\\n+  T(CPP_PLUS,\t\t\"+\")\t/* math */\t\\\n   T(CPP_MINUS,\t\t\"-\")\t\t\t\\\n   T(CPP_MULT,\t\t\"*\")\t\t\t\\\n   T(CPP_DIV,\t\t\"/\")\t\t\t\\\n@@ -51,22 +64,19 @@ typedef struct cpp_toklist cpp_toklist;\n   T(CPP_COMPL,\t\t\"~\")\t\t\t\\\n   T(CPP_RSHIFT,\t\t\">>\")\t\t\t\\\n   T(CPP_LSHIFT,\t\t\"<<\")\t\t\t\\\n-  T(CPP_NOT,\t\t\"!\")\t/* logicals */\t\\\n-  T(CPP_AND_AND,\t\"&&\")\t\t\t\\\n+\\\n+  T(CPP_AND_AND,\t\"&&\")\t/* logical */\t\\\n   T(CPP_OR_OR,\t\t\"||\")\t\t\t\\\n   T(CPP_QUERY,\t\t\"?\")\t\t\t\\\n   T(CPP_COLON,\t\t\":\")\t\t\t\\\n   T(CPP_COMMA,\t\t\",\")\t/* grouping */\t\\\n   T(CPP_OPEN_PAREN,\t\"(\")\t\t\t\\\n   T(CPP_CLOSE_PAREN,\t\")\")\t\t\t\\\n-  T(CPP_GREATER,\t\">\")\t/* compare */\t\\\n-  T(CPP_LESS,\t\t\"<\")\t\t\t\\\n-  T(CPP_EQ_EQ,\t\t\"==\")\t\t\t\\\n+  T(CPP_EQ_EQ,\t\t\"==\")\t/* compare */\t\\\n   T(CPP_NOT_EQ,\t\t\"!=\")\t\t\t\\\n   T(CPP_GREATER_EQ,\t\">=\")\t\t\t\\\n   T(CPP_LESS_EQ,\t\"<=\")\t\t\t\\\n \\\n-  /* The remainder of the punctuation.  Order is not significant. */\t\\\n   T(CPP_PLUS_EQ,\t\"+=\")\t/* math */\t\\\n   T(CPP_MINUS_EQ,\t\"-=\")\t\t\t\\\n   T(CPP_MULT_EQ,\t\"*=\")\t\t\t\\\n@@ -78,55 +88,67 @@ typedef struct cpp_toklist cpp_toklist;\n   T(CPP_COMPL_EQ,\t\"~=\")\t\t\t\\\n   T(CPP_RSHIFT_EQ,\t\">>=\")\t\t\t\\\n   T(CPP_LSHIFT_EQ,\t\"<<=\")\t\t\t\\\n-  T(CPP_EQ,\t\t\"=\")\t/* assign */\t\\\n+  /* Digraphs together, beginning with CPP_FIRST_DIGRAPH.  */\t\\\n+  T(CPP_HASH,\t\t\"#\")\t/* digraphs */\t\\\n+  T(CPP_PASTE,\t\t\"##\")\t\t\t\\\n+  T(CPP_OPEN_SQUARE,\t\"[\")\t\t\t\\\n+  T(CPP_CLOSE_SQUARE,\t\"]\")\t\t\t\\\n+  T(CPP_OPEN_BRACE,\t\"{\")\t\t\t\\\n+  T(CPP_CLOSE_BRACE,\t\"}\")\t\t\t\\\n+  /* The remainder of the punctuation.  Order is not significant. */\t\\\n+  T(CPP_SEMICOLON,\t\";\")\t/* structure */\t\\\n+  T(CPP_ELLIPSIS,\t\"...\")\t\t\t\\\n+  T(CPP_BACKSLASH,\t\"\\\\\")\t\t\t\\\n   T(CPP_PLUS_PLUS,\t\"++\")\t/* increment */\t\\\n   T(CPP_MINUS_MINUS,\t\"--\")\t\t\t\\\n   T(CPP_DEREF,\t\t\"->\")\t/* accessors */\t\\\n   T(CPP_DOT,\t\t\".\")\t\t\t\\\n-  T(CPP_OPEN_SQUARE,\t\"[\")\t\t\t\\\n-  T(CPP_CLOSE_SQUARE,\t\"]\")\t\t\t\\\n   T(CPP_SCOPE,\t\t\"::\")\t\t\t\\\n   T(CPP_DEREF_STAR,\t\"->*\")\t\t\t\\\n   T(CPP_DOT_STAR,\t\".*\")\t\t\t\\\n-  T(CPP_OPEN_BRACE,\t\"{\")\t/* structure */\t\\\n-  T(CPP_CLOSE_BRACE,\t\"}\")\t\t\t\\\n-  T(CPP_SEMICOLON,\t\";\")\t\t\t\\\n-  T(CPP_ELLIPSIS,\t\"...\")\t\t\t\\\n-  T(CPP_HASH,\t\t\"#\")\t\t\t\\\n-  T(CPP_PASTE,\t\t\"##\")\t\t\t\\\n-  T(CPP_BACKSLASH,\t\"\\\\\")\t\t\t\\\n   T(CPP_MIN,\t\t\"<?\")\t/* extension */\t\\\n   T(CPP_MAX,\t\t\">?\")\t\t\t\\\n-  T(CPP_OTHER,\t\tspell_other) /* stray punctuation */ \\\n+  H(CPP_OTHER,\t\tspell_other) /* stray punctuation */ \\\n \\\n-  T(CPP_NAME,\t\tspell_name)\t/* word */\t\\\n-  T(CPP_INT,\t\t0)\t\t/* 23 */\t\\\n-  T(CPP_FLOAT,\t\t0)\t\t/* 3.14159 */\t\\\n-  T(CPP_NUMBER,\t\tspell_name)\t/* 34_be+ta  */\t\\\n-  T(CPP_CHAR,\t\tspell_char)\t/* 'char' */\t\\\n-  T(CPP_WCHAR,\t\tspell_char)\t/* L'char' */\t\\\n-  T(CPP_STRING,\t\tspell_string)\t/* \"string\" */\t\\\n-  T(CPP_WSTRING,\tspell_string)\t/* L\"string\" */\t\\\n+  H(CPP_NAME,\t\tspell_name)\t/* word */\t\\\n+  N(CPP_INT,\t\t0)\t\t/* 23 */\t\\\n+  N(CPP_FLOAT,\t\t0)\t\t/* 3.14159 */\t\\\n+  H(CPP_NUMBER,\t\tspell_name)\t/* 34_be+ta  */\t\\\n+  H(CPP_CHAR,\t\tspell_char)\t/* 'char' */\t\\\n+  H(CPP_WCHAR,\t\tspell_char)\t/* L'char' */\t\\\n+  H(CPP_STRING,\t\tspell_string)\t/* \"string\" */\t\\\n+  H(CPP_WSTRING,\tspell_string)\t/* L\"string\" */\t\\\n \\\n-  T(CPP_COMMENT,\tspell_comment)\t/* Only if output comments.  */ \\\n-  T(CPP_VSPACE,\t\t\"\\n\")\t\t/* End of line.  */\t\t\\\n-  T(CPP_EOF,\t\t0)\t\t/* End of file.  */\t\t\\\n-  T(CPP_HEADER_NAME,\t0)\t\t/* <stdio.h> in #include */\t\\\n-  T(CPP_ASSERTION,\t0)\t\t/* (...) in #assert */\t\t\\\n+  H(CPP_C_COMMENT,\tspell_comment)\t/* Only if output comments.  */ \\\n+  H(CPP_CPP_COMMENT,\tspell_comment)\t/* Only if output comments.  */ \\\n+  H(CPP_CHILL_COMMENT,\tspell_comment)\t/* Only if output comments.  */ \\\n+  N(CPP_MACRO_ARG,      0)              /* Macro argument.  */          \\\n+  N(CPP_SUBLIST,        0)\t        /* Sublist.  */                 \\\n+  E(CPP_VSPACE,\t\t\"\\n\")\t\t/* End of line.  */\t\t\\\n+  N(CPP_EOF,\t\t0)\t\t/* End of file.  */\t\t\\\n+  N(CPP_HEADER_NAME,\t0)\t\t/* <stdio.h> in #include */\t\\\n+  N(CPP_ASSERTION,\t0)\t\t/* (...) in #assert */\t\t\\\n \\\n   /* Obsolete - will be removed when no code uses them still.  */\t\\\n-  T(CPP_HSPACE,\t\t0)\t\t/* Horizontal white space.  */\t\\\n-  T(CPP_POP,\t\t0)\t\t/* End of buffer.  */\t\t\\\n-  T(CPP_DIRECTIVE,\t0)\t\t/* #define and the like */\t\\\n-  T(CPP_MACRO,\t\t0)\t\t/* Like a NAME, but expanded.  */\n+  H(CPP_COMMENT,\t0)\t\t/* Only if output comments.  */ \\\n+  N(CPP_HSPACE,\t\t0)\t\t/* Horizontal white space.  */\t\\\n+  N(CPP_POP,\t\t0)\t\t/* End of buffer.  */\t\t\\\n+  N(CPP_DIRECTIVE,\t0)\t\t/* #define and the like */\t\\\n+  N(CPP_MACRO,\t\t0)\t\t/* Like a NAME, but expanded.  */\n \n #define T(e, s) e,\n+#define H(e, s) e,\n+#define N(e, s) e,\n+#define E(e, s) e,\n enum cpp_ttype\n {\n   TTYPE_TABLE\n   N_TTYPES\n };\n #undef T\n+#undef H\n+#undef N\n+#undef E\n \n /* Payload of a NAME, NUMBER, FLOAT, STRING, or COMMENT token.  */\n struct cpp_name\n@@ -135,8 +157,12 @@ struct cpp_name\n   unsigned int offset;\t\t/* from list->namebuf */\n };\n \n-/* Per token flags.  */\n-#define HSPACE_BEFORE\t(1 << 0)\t/* token preceded by hspace */\n+#define TOK_NAME(list, token) ((list)->namebuf + (token)->val.name.offset)\n+\n+/* Flags for the cpp_token structure.  */\n+#define PREV_WHITESPACE     1\t/* If whitespace before this token.  */\n+#define DIGRAPH             2\t/* If it was a digraph.  */\n+#define UNSIGNED_INT        4   /* If int preprocessing token unsigned.  */\n \n /* A preprocessing token.\n    This has been carefully packed and should occupy 16 bytes on\n@@ -150,8 +176,9 @@ struct cpp_token\n   unsigned char type;\n #endif\n   unsigned char flags;\t\t\t/* flags - see above */\n-  unsigned int aux;\t\t\t/* hash of a NAME, or something -\n-\t\t\t\t\t   see uses in the code */\n+  unsigned int aux;\t\t\t/* CPP_OTHER character.  Hash of a\n+\t\t\t\t\t   NAME, or something - see uses\n+\t\t\t\t\t   in the code */\n   union\n   {\n     struct cpp_name name;\t\t/* a string */\n@@ -168,7 +195,7 @@ typedef int (*parse_cleanup_t) PARAMS ((cpp_buffer *, cpp_reader *));\n \n struct cpp_toklist\n {\n-  struct cpp_token *tokens;\t/* actual tokens as an array */\n+  cpp_token *tokens;\t\t/* actual tokens as an array */\n   unsigned int tokens_used;\t/* tokens used */\n   unsigned int tokens_cap;\t/* tokens allocated */\n \n@@ -178,6 +205,11 @@ struct cpp_toklist\n \n   unsigned int line;\t\t/* starting line number */\n \n+  /* Comment copying.  */\n+  cpp_token *comments;\t\t/* comment tokens.  */\n+  unsigned int comments_used;\t/* comment tokens used.  */\n+  unsigned int comments_cap;\t/* comment token capacity.  */\n+\n   /* Only used if tokens[0].type == CPP_DIRECTIVE.  This is the\n      handler to call after lexing the rest of this line.  The flags\n      indicate whether the rest of the line gets special treatment\n@@ -244,8 +276,12 @@ struct cpp_buffer\n \n   /* True if we have already warned about C++ comments in this file.\n      The warning happens only for C89 extended mode with -pedantic on,\n-     and only once per file (otherwise it would be far too noisy).  */\n+     or for -Wtraditional, and only once per file (otherwise it would\n+     be far too noisy).  */\n   char warned_cplusplus_comments;\n+\n+  /* True if this buffer's data is mmapped.  */\n+  char mapped;\n };\n \n struct file_name_map_list;\n@@ -561,6 +597,7 @@ struct cpp_printer\n /* Name under which this program was invoked.  */\n extern const char *progname;\n \n+extern void _cpp_lex_file PARAMS((cpp_reader *));\n extern int cpp_handle_options PARAMS ((cpp_reader *, int, char **));\n extern enum cpp_ttype cpp_get_token PARAMS ((cpp_reader *));\n extern enum cpp_ttype cpp_get_non_space_token PARAMS ((cpp_reader *));\n@@ -580,6 +617,8 @@ extern void cpp_assert PARAMS ((cpp_reader *, const char *));\n extern void cpp_undef  PARAMS ((cpp_reader *, const char *));\n extern void cpp_unassert PARAMS ((cpp_reader *, const char *));\n \n+extern void cpp_free_token_list PARAMS ((cpp_toklist *));\n+\n /* N.B. The error-message-printer prototypes have not been nicely\n    formatted because exgettext needs to see 'msgid' on the same line\n    as the name of the function in order to work properly.  Only the"}]}