{"sha": "ddd5a7c1808995545ad5befaa7320135e60b5d38", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGRkNWE3YzE4MDg5OTU1NDVhZDViZWZhYTczMjAxMzVlNjBiNWQzOA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-05-16T12:14:26Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-05-16T12:14:26Z"}, "message": "Fix typos in comments.\n\nFrom-SVN: r9711", "tree": {"sha": "bf405c4941b111c08c0642d3410b2970aca3b162", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bf405c4941b111c08c0642d3410b2970aca3b162"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ddd5a7c1808995545ad5befaa7320135e60b5d38", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ddd5a7c1808995545ad5befaa7320135e60b5d38", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ddd5a7c1808995545ad5befaa7320135e60b5d38", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ddd5a7c1808995545ad5befaa7320135e60b5d38/comments", "author": null, "committer": null, "parents": [{"sha": "6de129de79f7646825d5b004d9fdbca5b893d106", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6de129de79f7646825d5b004d9fdbca5b893d106", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6de129de79f7646825d5b004d9fdbca5b893d106"}], "stats": {"total": 405, "additions": 202, "deletions": 203}, "files": [{"sha": "afadd04cfeb9f5af7758015196dbfccebf6cfa73", "filename": "gcc/bc-emit.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddd5a7c1808995545ad5befaa7320135e60b5d38/gcc%2Fbc-emit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddd5a7c1808995545ad5befaa7320135e60b5d38/gcc%2Fbc-emit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbc-emit.c?ref=ddd5a7c1808995545ad5befaa7320135e60b5d38", "patch": "@@ -441,7 +441,7 @@ bc_initialize ()\n /* External addresses referenced in a function.  Rather than trying to\n    work relocatable address directly into bytecoded functions (which would\n    require us to provide hairy location info and possibly obey alignment\n-   rules imposed by the architecture) we build an auxilary table of\n+   rules imposed by the architecture) we build an auxiliary table of\n    pointer constants, and encode just offsets into this table into the\n    actual bytecode. */\n static struct bc_seg *ptrconsts;"}, {"sha": "3391ca6ee56e07cd13e568c5725b4c6c1dba071f", "filename": "gcc/bi-lexer.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddd5a7c1808995545ad5befaa7320135e60b5d38/gcc%2Fbi-lexer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddd5a7c1808995545ad5befaa7320135e60b5d38/gcc%2Fbi-lexer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbi-lexer.c?ref=ddd5a7c1808995545ad5befaa7320135e60b5d38", "patch": "@@ -26,7 +26,7 @@ static char *buffer = NULL;\n static char *inpoint = NULL;\n \n \n-/* Safely allocate NBYTES bytes of memory. Reuturns pointer to block of\n+/* Safely allocate NBYTES bytes of memory.  Returns pointer to block of\n    memory. */\n \n static char *"}, {"sha": "9b80ea9ddc0f82cb9ec7572f1c3565b8572d9276", "filename": "gcc/bi-run.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddd5a7c1808995545ad5befaa7320135e60b5d38/gcc%2Fbi-run.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddd5a7c1808995545ad5befaa7320135e60b5d38/gcc%2Fbi-run.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbi-run.h?ref=ddd5a7c1808995545ad5befaa7320135e60b5d38", "patch": "@@ -101,7 +101,7 @@ struct bytecode\n    The above applies to BYTE_LOW_ENDIAN machines. In BYTE_BIG_ENDIAN machines, the\n    bit numbering is reversed (i.e. bit 0 is the sign bit).\n \n-   (Alright, so I drew this to keep my tongue in cheek while writing the code below,\n+   (All right, so I drew this to keep my tongue in cheek while writing the code below,\n     not because I'm into ASCII art.) */\n \n "}, {"sha": "2c959f6a601533df646125a879c6c79a74951d9a", "filename": "gcc/c-decl.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddd5a7c1808995545ad5befaa7320135e60b5d38/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddd5a7c1808995545ad5befaa7320135e60b5d38/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=ddd5a7c1808995545ad5befaa7320135e60b5d38", "patch": "@@ -3553,7 +3553,7 @@ start_decl (declarator, declspecs, initialized, attributes, prefix_attributes)\n      TEM may equal DECL or it may be a previous decl of the same name.  */\n   tem = pushdecl (decl);\n \n-  /* For C and Obective-C, we by default put things in .common when\n+  /* For C and Objective-C, we by default put things in .common when\n      possible.  */\n   DECL_COMMON (tem) = 1;\n \n@@ -3809,7 +3809,7 @@ finish_decl (decl, init, asmspec_tree)\n \t    {\n \t      preserve_initializer ();\n \t      /* Hack?  Set the permanent bit for something that is permanent,\n-\t\t but not on the permenent obstack, so as to convince\n+\t\t but not on the permanent obstack, so as to convince\n \t\t output_constant_def to make its rtl on the permanent\n \t\t obstack.  */\n \t      TREE_PERMANENT (DECL_INITIAL (decl)) = 1;"}, {"sha": "23b1107cfd69a8dccc54552a6728356cb210917a", "filename": "gcc/c-iterate.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddd5a7c1808995545ad5befaa7320135e60b5d38/gcc%2Fc-iterate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddd5a7c1808995545ad5befaa7320135e60b5d38/gcc%2Fc-iterate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-iterate.c?ref=ddd5a7c1808995545ad5befaa7320135e60b5d38", "patch": "@@ -341,7 +341,7 @@ iterator_loop_epilogue (idecl, start_note, end_note)\n \n   ITERATOR_BOUND_P (idecl) = 0;\n   /* we can reset rtl since there is not chance that this expansion */\n-  /* would be superceded by a higher level one */\n+  /* would be superseded by a higher level one */\n   if (top_level_ixpansion_p ())\n     DECL_RTL (idecl) = 0;\n   if (end_note)\n@@ -433,7 +433,7 @@ pop_iterator_stack ()\n \f\n \n /* Record an iterator expansion (\"ixpansion\") for IDECL.\n-   The remaining paramters are the notes in the loop entry\n+   The remaining parameters are the notes in the loop entry\n    and exit rtl.  */\n \n static void"}, {"sha": "a7a2687e00637a3473f4777e955f9fdfd93092db", "filename": "gcc/c-lex.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddd5a7c1808995545ad5befaa7320135e60b5d38/gcc%2Fc-lex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddd5a7c1808995545ad5befaa7320135e60b5d38/gcc%2Fc-lex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-lex.c?ref=ddd5a7c1808995545ad5befaa7320135e60b5d38", "patch": "@@ -994,7 +994,7 @@ yylex ()\n \t      goto string_constant;\n \t    }\n \t  ungetc(c, finput);\n-\t  /* Fall through to treat '@' as the start of an indentifier.  */\n+\t  /* Fall through to treat '@' as the start of an identifier.  */\n \t}\n \n     case 'A':  case 'B':  case 'C':  case 'D':  case 'E':"}, {"sha": "76c9670fdb0a4e802d4209994555e1353f11bd1f", "filename": "gcc/c-parse.in", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddd5a7c1808995545ad5befaa7320135e60b5d38/gcc%2Fc-parse.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddd5a7c1808995545ad5befaa7320135e60b5d38/gcc%2Fc-parse.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parse.in?ref=ddd5a7c1808995545ad5befaa7320135e60b5d38", "patch": "@@ -814,7 +814,7 @@ string:\n \t;\n \n ifobjc\n-/* Produces an OBJC_STRING_CST with prehaps more OBJC_STRING_CSTs chained\n+/* Produces an OBJC_STRING_CST with perhaps more OBJC_STRING_CSTs chained\n    onto it.  */\n objc_string:\n \t  OBJC_STRING\n@@ -1164,7 +1164,7 @@ initelt:\n \t| error\n \t/* These are for labeled elements.  The syntax for an array element\n \t   initializer conflicts with the syntax for an Objective-C message,\n-\t   so don't include these productions in the Objective-C grammer.  */\n+\t   so don't include these productions in the Objective-C grammar.  */\n ifc\n \t| '[' expr_no_commas ELLIPSIS expr_no_commas ']' '='\n \t\t{ set_init_index ($2, $4); }"}, {"sha": "93a345edc5658a12b85dc04bcc03089960ce8ae0", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddd5a7c1808995545ad5befaa7320135e60b5d38/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddd5a7c1808995545ad5befaa7320135e60b5d38/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=ddd5a7c1808995545ad5befaa7320135e60b5d38", "patch": "@@ -4921,7 +4921,7 @@ static tree constructor_fields;\n static tree constructor_index;\n \n /* For an ARRAY_TYPE, this is the end index of the range\n-   to intitialize with the next element, or NULL in the ordinary case\n+   to initialize with the next element, or NULL in the ordinary case\n    where the element is used just once.  */\n static tree constructor_range_end;\n "}, {"sha": "4d4859275cdd31cd5e9e9d202f1480ab05f5424e", "filename": "gcc/calls.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddd5a7c1808995545ad5befaa7320135e60b5d38/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddd5a7c1808995545ad5befaa7320135e60b5d38/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=ddd5a7c1808995545ad5befaa7320135e60b5d38", "patch": "@@ -161,7 +161,7 @@ calls_function_1 (exp, which)\n   int type = TREE_CODE_CLASS (code);\n   int length = tree_code_length[(int) code];\n \n-  /* If this code is langauge-specific, we don't know what it will do.  */\n+  /* If this code is language-specific, we don't know what it will do.  */\n   if ((int) code >= NUM_TREE_CODES)\n     return 1;\n \n@@ -1757,7 +1757,7 @@ expand_call (exp, target, ignore)\n \targs[i].aligned_regs = (rtx *) alloca (sizeof (rtx)\n \t\t\t\t\t       * args[i].n_aligned_regs);\n \n-\t/* Structures smaller than a word are aligned to the least signifcant\n+\t/* Structures smaller than a word are aligned to the least significant\n \t   byte (to the right).  On a BYTES_BIG_ENDIAN machine, this means we\n \t   must skip the empty high order bytes when calculating the bit\n \t   offset.  */"}, {"sha": "e6870cd4a795537a8231dfa030f8c3471a71c86d", "filename": "gcc/cccp.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddd5a7c1808995545ad5befaa7320135e60b5d38/gcc%2Fcccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddd5a7c1808995545ad5befaa7320135e60b5d38/gcc%2Fcccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcccp.c?ref=ddd5a7c1808995545ad5befaa7320135e60b5d38", "patch": "@@ -320,7 +320,7 @@ extern const char *const sys_errlist[];\n #else\n extern char *sys_errlist[];\n #endif\n-#else\t/* HAVE_STERRROR */\n+#else\t/* HAVE_STRERROR */\n char *strerror ();\n #endif\n #else\t/* VMS */\n@@ -10308,7 +10308,7 @@ fopen (fname, type)\n #undef fopen\t/* Get back the REAL fopen routine */\n   /* The gcc-vms-1.42 distribution's header files prototype fopen with two\n      fixed arguments, which matches ANSI's specification but not VAXCRTL's\n-     pre-ANSI implmentation.  This hack circumvents the mismatch problem.  */\n+     pre-ANSI implementation.  This hack circumvents the mismatch problem.  */\n   FILE *(*vmslib_fopen)() = (FILE *(*)()) fopen;\n \n   if (*type == 'w')"}, {"sha": "c2a073e6ef7efa1ab501aa4ec1035928e019c5b0", "filename": "gcc/collect2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddd5a7c1808995545ad5befaa7320135e60b5d38/gcc%2Fcollect2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddd5a7c1808995545ad5befaa7320135e60b5d38/gcc%2Fcollect2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcollect2.c?ref=ddd5a7c1808995545ad5befaa7320135e60b5d38", "patch": "@@ -190,7 +190,7 @@ char *strerror();\n /* Some systems use __main in a way incompatible with its use in gcc, in these\n    cases use the macros NAME__MAIN to give a quoted symbol and SYMBOL__MAIN to\n    give the same symbol without quotes for an alternative entry point.  You\n-   must define both, or niether. */\n+   must define both, or neither.  */\n #ifndef NAME__MAIN\n #define NAME__MAIN \"__main\"\n #define SYMBOL__MAIN __main"}, {"sha": "c84549d4193fa2c998f05b5f18a010a41251fcd4", "filename": "gcc/combine.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddd5a7c1808995545ad5befaa7320135e60b5d38/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddd5a7c1808995545ad5befaa7320135e60b5d38/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=ddd5a7c1808995545ad5befaa7320135e60b5d38", "patch": "@@ -120,7 +120,7 @@ static int combine_successes;\n \n static int total_attempts, total_merges, total_extras, total_successes;\n \n-/* Define a defulat value for REVERSIBLE_CC_MODE.\n+/* Define a default value for REVERSIBLE_CC_MODE.\n    We can never assume that a condition code mode is safe to reverse unless\n    the md tells us so.  */\n #ifndef REVERSIBLE_CC_MODE\n@@ -2426,7 +2426,7 @@ find_split_point (loc, insn)\n       /* If we have a PLUS whose second operand is a constant and the\n \t address is not valid, perhaps will can split it up using\n \t the machine-specific way to split large constants.  We use\n-\t the first psuedo-reg (one of the virtual regs) as a placeholder;\n+\t the first pseudo-reg (one of the virtual regs) as a placeholder;\n \t it will not remain in the result.  */\n       if (GET_CODE (XEXP (x, 0)) == PLUS\n \t  && GET_CODE (XEXP (XEXP (x, 0), 1)) == CONST_INT\n@@ -6163,7 +6163,7 @@ if_then_else_cond (x, ptrue, pfalse)\n     }\n \n   /* If this is a COMPARE, do nothing, since the IF_THEN_ELSE we would\n-     make can't possibly match and would supress other optimizations.  */\n+     make can't possibly match and would suppress other optimizations.  */\n   else if (code == COMPARE)\n     ;\n \n@@ -10013,7 +10013,7 @@ get_last_value (x)\n \t  value = SET_SRC (set);\n \n \t  /* Make sure that VALUE doesn't reference X.  Replace any\n-\t     expliit references with a CLOBBER.  If there are any remaining\n+\t     explicit references with a CLOBBER.  If there are any remaining\n \t     references (rare), don't use the value.  */\n \n \t  if (reg_mentioned_p (x, value))\n@@ -10101,7 +10101,7 @@ static int reg_dead_flag;\n \n /* Function called via note_stores from reg_dead_at_p.\n \n-   If DEST is within [reg_dead_rengno, reg_dead_endregno), set \n+   If DEST is within [reg_dead_regno, reg_dead_endregno), set \n    reg_dead_flag to 1 if X is a CLOBBER and to -1 it is a SET.  */\n \n static void"}, {"sha": "2ab053d238294eb8444424c6385c2fda1382f7a1", "filename": "gcc/config/1750a/1750a.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddd5a7c1808995545ad5befaa7320135e60b5d38/gcc%2Fconfig%2F1750a%2F1750a.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddd5a7c1808995545ad5befaa7320135e60b5d38/gcc%2Fconfig%2F1750a%2F1750a.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2F1750a%2F1750a.md?ref=ddd5a7c1808995545ad5befaa7320135e60b5d38", "patch": "@@ -949,7 +949,7 @@\n ;********************\n \n ;; Bit field instructions, general cases.\n-;; \"o,d\" constraint causes a nonoffsetable memref to match the \"o\"\n+;; \"o,d\" constraint causes a nonoffsettable memref to match the \"o\"\n ;; so that its address is reloaded.\n \n ;; (define_insn \"extv\" ..."}, {"sha": "5c94cdd7c466af9143a1d44d372af96d5d143049", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddd5a7c1808995545ad5befaa7320135e60b5d38/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddd5a7c1808995545ad5befaa7320135e60b5d38/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=ddd5a7c1808995545ad5befaa7320135e60b5d38", "patch": "@@ -1318,7 +1318,7 @@ output_prolog (file, size)\n      linked to procedure descriptors.\n      Outputting the lineno helps debugging of one line functions as they\n      would otherwise get no line number at all. Please note that we would\n-     like to put out last_linenum from final.c, but it is not accesible.  */\n+     like to put out last_linenum from final.c, but it is not accessible.  */\n \n   if (write_symbols == SDB_DEBUG)\n     {"}, {"sha": "d0f8daf45db40236876eed0bf1bc37293bdb45de", "filename": "gcc/config/alpha/alpha.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddd5a7c1808995545ad5befaa7320135e60b5d38/gcc%2Fconfig%2Falpha%2Falpha.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddd5a7c1808995545ad5befaa7320135e60b5d38/gcc%2Fconfig%2Falpha%2Falpha.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.h?ref=ddd5a7c1808995545ad5befaa7320135e60b5d38", "patch": "@@ -552,7 +552,7 @@ enum reg_class { NO_REGS, GENERAL_REGS, FLOAT_REGS, ALL_REGS,\n /* Loading and storing HImode or QImode values to and from memory\n    usually requires a scratch register.  The exceptions are loading\n    QImode and HImode from an aligned address to a general register. \n-   We also cannot load an unaligned address or a paradodixal SUBREG into an\n+   We also cannot load an unaligned address or a paradoxical SUBREG into an\n    FP register.   */\n \n #define SECONDARY_INPUT_RELOAD_CLASS(CLASS,MODE,IN)\t\t\t\\\n@@ -942,7 +942,7 @@ extern char *alpha_function_name;\n \n /* Output assembler code to FILE to increment profiler label # LABELNO\n    for profiling a function entry.  Under OSF/1, profiling is enabled\n-   by simply passing -pg to the assember and linker.  */\n+   by simply passing -pg to the assembler and linker.  */\n \n #define FUNCTION_PROFILER(FILE, LABELNO)\n "}, {"sha": "5ec06c8c69a5fdba9ddd31261e6419b92443744d", "filename": "gcc/config/alpha/alpha.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddd5a7c1808995545ad5befaa7320135e60b5d38/gcc%2Fconfig%2Falpha%2Falpha.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddd5a7c1808995545ad5befaa7320135e60b5d38/gcc%2Fconfig%2Falpha%2Falpha.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.md?ref=ddd5a7c1808995545ad5befaa7320135e60b5d38", "patch": "@@ -3558,7 +3558,7 @@\n { extern rtx get_unaligned_address ();\n   rtx addr = get_unaligned_address (operands[1]);\n   /* It is possible that one of the registers we got for operands[2]\n-     might co-incide with that of operands[0] (which is why we made\n+     might coincide with that of operands[0] (which is why we made\n      it TImode).  Pick the other one to use as our scratch.  */\n   rtx scratch = gen_rtx (REG, DImode,\n \t\t\t REGNO (operands[0]) == REGNO (operands[2]) "}, {"sha": "0121d0ec38c3855aa4acd4c94909e8f200acdb93", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddd5a7c1808995545ad5befaa7320135e60b5d38/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddd5a7c1808995545ad5befaa7320135e60b5d38/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=ddd5a7c1808995545ad5befaa7320135e60b5d38", "patch": "@@ -59,7 +59,7 @@ int arm_compare_fp;\n /* What type of cpu are we compiling for? */\n enum processor_type arm_cpu;\n \n-/* Waht type of floating point are we compiling for? */\n+/* What type of floating point are we compiling for? */\n enum floating_point_type arm_fpu;\n \n /* In case of a PRE_INC, POST_INC, PRE_DEC, POST_DEC memory reference, we\n@@ -2425,7 +2425,7 @@ shift_op (op, amountp)\n \t multiplication by a power of 2 with the recognizer for a\n \t shift.  >=32 is not a valid shift for \"asl\", so we must try and\n \t output a shift that produces the correct arithmetical result.\n-\t Using lsr #32 is idendical except for the fact that the carry bit\n+\t Using lsr #32 is identical except for the fact that the carry bit\n \t is not set correctly if we set the flags; but we never use the \n \t carry bit from such an operation, so we can ignore that.  */\n       if (code == ROTATERT)\n@@ -3038,7 +3038,7 @@ arm_expand_prologue ()\n   if (live_regs_mask)\n     {\n       /* If we have to push any regs, then we must push lr as well, or\n-\t we won't get a propper return.  */\n+\t we won't get a proper return.  */\n       live_regs_mask |= 0x4000;\n       emit_multi_reg_push (live_regs_mask);\n     }\n@@ -3075,13 +3075,13 @@ arm_expand_prologue ()\n \f\n /* If CODE is 'd', then the X is a condition operand and the instruction\n    should only be executed if the condition is true.\n-   if CODE is 'D', then the X is a condition operand and the instruciton\n+   if CODE is 'D', then the X is a condition operand and the instruction\n    should only be executed if the condition is false: however, if the mode\n    of the comparison is CCFPEmode, then always execute the instruction -- we\n    do this because in these circumstances !GE does not necessarily imply LT;\n    in these cases the instruction pattern will take care to make sure that\n    an instruction containing %d will follow, thereby undoing the effects of\n-   doing this instrucion unconditionally.\n+   doing this instruction unconditionally.\n    If CODE is 'N' then X is a floating point operand that must be negated\n    before output.\n    If CODE is 'B' then output a bitwise inverted value of X (a const int).\n@@ -3320,7 +3320,7 @@ output_load_symbol (insn, operands)\n     abort ();\n \n   /* When generating the instructions, we never mask out the bits that we\n-     think will be always zero, then if a mistake has occured somewhere, the\n+     think will be always zero, then if a mistake has occurred somewhere, the\n      assembler will spot it and generate an error.  */\n \n   /* If the symbol is word aligned then we might be able to reduce the\n@@ -3522,7 +3522,7 @@ final_prescan_insn (insn, opvec, noperands)\n   if (GET_CODE (insn) != JUMP_INSN)\n     return;\n \n-  /* This jump might be paralled with a clobber of the condition codes \n+  /* This jump might be paralleled with a clobber of the condition codes \n      the jump should always come first */\n   if (GET_CODE (body) == PARALLEL && XVECLEN (body, 0) > 0)\n     body = XVECEXP (body, 0, 0);\n@@ -3740,7 +3740,7 @@ final_prescan_insn (insn, opvec, noperands)\n \t}\n       /* restore recog_operand (getting the attributes of other insns can\n \t destroy this array, but final.c assumes that it remains intact\n-\t accross this call; since the insn has been recognized already we\n+\t across this call; since the insn has been recognized already we\n \t call recog direct). */\n       recog (PATTERN (insn), insn, NULL_PTR);\n     }"}, {"sha": "6241a20115db007ac4cc7954c7252760af38d288", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddd5a7c1808995545ad5befaa7320135e60b5d38/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddd5a7c1808995545ad5befaa7320135e60b5d38/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=ddd5a7c1808995545ad5befaa7320135e60b5d38", "patch": "@@ -1278,7 +1278,7 @@ do\t\t\t\t\t\t\t\t\t\\\n #define MEMORY_MOVE_COST(MODE)  10\n \n /* All address computations that can be done are free, but rtx cost returns\n-   the same for practically all of them.  So we weight the differnt types\n+   the same for practically all of them.  So we weight the different types\n    of address here in the order (most pref first):\n    PRE/POST_INC/DEC, SHIFT or NON-INT sum, INT sum, REG, MEM or LABEL. */\n #define ADDRESS_COST(X)\t\t\t\t\t\t\t     \\\n@@ -1306,9 +1306,9 @@ do\t\t\t\t\t\t\t\t\t\\\n /* Condition code information. */\n /* Given a comparison code (EQ, NE, etc.) and the first operand of a COMPARE,\n    return the mode to be used for the comparison. \n-   CCFPEmode should be used with floating inequalites,\n+   CCFPEmode should be used with floating inequalities,\n    CCFPmode should be used with floating equalities.\n-   CC_NOOVmode should be used with SImode integer equalites\n+   CC_NOOVmode should be used with SImode integer equalities.\n    CCmode should be used otherwise. */\n \n #define EXTRA_CC_MODES CC_NOOVmode, CCFPmode, CCFPEmode"}, {"sha": "36d5f0697f655ff1c7e5a314fe98c30fbe4ca825", "filename": "gcc/config/arm/arm.md", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddd5a7c1808995545ad5befaa7320135e60b5d38/gcc%2Fconfig%2Farm%2Farm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddd5a7c1808995545ad5befaa7320135e60b5d38/gcc%2Fconfig%2Farm%2Farm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.md?ref=ddd5a7c1808995545ad5befaa7320135e60b5d38", "patch": "@@ -54,7 +54,7 @@\n ; but are if the branch wasn't taken; the effect is to limit the branch\n ; elimination scanning.\n \n-; NOCOND means that the condition codes are niether altered nor affect the\n+; NOCOND means that the condition codes are neither altered nor affect the\n ; output of this insn\n \n (define_attr \"conds\" \"use,set,clob,jump_clob,nocond\"\n@@ -2104,7 +2104,7 @@\n ;; Operand 1 is the destination address in a register (SImode)\n \n ;; In both this routine and the next, we must be careful not to spill\n-;; a memory address of reg+large_const into a seperate PLUS insn, since this\n+;; a memory address of reg+large_const into a separate PLUS insn, since this\n ;; can generate unrecognizable rtl.\n \n (define_expand \"storehi\"\n@@ -3990,7 +3990,7 @@\n \")\n \n ;; Don't match these patterns if we can use a conditional compare, since they\n-;; tell the final prescan branch elimator code that full branch inlining\n+;; tell the final prescan branch eliminator code that full branch inlining\n ;; can't be done.\n \n (define_insn \"\"\n@@ -4227,7 +4227,7 @@\n \")\n \n ;; Don't match these patterns if we can use a conditional compare, since they\n-;; tell the final prescan branch elimator code that full branch inlining\n+;; tell the final prescan branch eliminator code that full branch inlining\n ;; can't be done.\n \n (define_insn \"\"\n@@ -4390,7 +4390,7 @@\n   \"\"\n   \"*\n   /* If we have an operation where (op x 0) is the identity operation and\n-     the condtional operator is LT or GE and we are comparing against zero and\n+     the conditional operator is LT or GE and we are comparing against zero and\n      everything is in registers then we can do this in two instructions */\n   if (operands[3] == const0_rtx\n       && GET_CODE (operands[7]) != AND\n@@ -4435,7 +4435,7 @@\n   \"\"\n   \"*\n   /* If we have an operation where (op x 0) is the identity operation and\n-     the condtional operator is LT or GE and we are comparing against zero and\n+     the conditional operator is LT or GE and we are comparing against zero and\n      everything is in registers then we can do this in two instructions */\n   if (operands[5] == const0_rtx\n       && GET_CODE (operands[7]) != AND\n@@ -5306,7 +5306,7 @@\n ;; any of our local variables.  If we call alloca then this is unsafe\n ;; since restoring the frame frees the memory, which is not what we want.\n ;; Sometimes the return might have been targeted by the final prescan:\n-;; if so then emit a propper return insn as well.\n+;; if so then emit a proper return insn as well.\n ;; Unfortunately, if the frame pointer is required, we don't know if the\n ;; current function has any implicit stack pointer adjustments that will \n ;; be restored by the return: we can't therefore do a tail call.\n@@ -5416,7 +5416,7 @@\n ;; and jump direct to the subroutine.  On return from the subroutine\n ;; execution continues at the branch; this avoids a prefetch stall.\n ;; We use the length attribute (via short_branch ()) to establish whether or\n-;; not this is possible, this is the same asthe sparc does.\n+;; not this is possible, this is the same as the sparc does.\n \n (define_peephole\n   [(parallel[(call (mem:SI (match_operand:SI 0 \"\" \"i\"))"}, {"sha": "8e60cfdd0b892cf37fb9478974271ce371fb88f8", "filename": "gcc/config/arm/riscix.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddd5a7c1808995545ad5befaa7320135e60b5d38/gcc%2Fconfig%2Farm%2Friscix.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddd5a7c1808995545ad5befaa7320135e60b5d38/gcc%2Fconfig%2Farm%2Friscix.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Friscix.h?ref=ddd5a7c1808995545ad5befaa7320135e60b5d38", "patch": "@@ -58,7 +58,7 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n \t%{!mbsd:%{!mxopen:%{!ansi: -D_BSD_C}}}\"\n #endif\n \n-/* RISCiX has some wierd symbol name munging, that is done to the object module\n+/* RISCiX has some weird symbol name munging, that is done to the object module\n    after assembly, which enables multiple libraries to be supported within\n    one (possibly shared) library.  It basically changes the symbol name of\n    certain symbols (for example _bcopy is converted to _$bcopy if using BSD)"}, {"sha": "826ec2f93f2c882bd440041ff069e84f82aa0315", "filename": "gcc/config/arm/riscix1-1.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddd5a7c1808995545ad5befaa7320135e60b5d38/gcc%2Fconfig%2Farm%2Friscix1-1.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddd5a7c1808995545ad5befaa7320135e60b5d38/gcc%2Fconfig%2Farm%2Friscix1-1.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Friscix1-1.h?ref=ddd5a7c1808995545ad5befaa7320135e60b5d38", "patch": "@@ -74,7 +74,7 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n /* Some systems use __main in a way incompatible with its use in gcc, in these\n    cases use the macros NAME__MAIN to give a quoted symbol and SYMBOL__MAIN to\n    give the same symbol without quotes for an alternative entry point.  You\n-   must define both, or niether. */\n+   must define both, or neither. */\n #ifndef NAME__MAIN\n #define NAME__MAIN \"__gccmain\"\n #define SYMBOL__MAIN __gccmain"}, {"sha": "831fec90af5670e2323e1f44a8ff3234997c0d0a", "filename": "gcc/config/clipper/clipper.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddd5a7c1808995545ad5befaa7320135e60b5d38/gcc%2Fconfig%2Fclipper%2Fclipper.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddd5a7c1808995545ad5befaa7320135e60b5d38/gcc%2Fconfig%2Fclipper%2Fclipper.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fclipper%2Fclipper.h?ref=ddd5a7c1808995545ad5befaa7320135e60b5d38", "patch": "@@ -127,7 +127,7 @@ extern int target_flags;\n /* Let's keep the stack somewhat aligned.  */\n #define STACK_BOUNDARY 64\n \n-/* Define this macro if it is advisible to hold scalars in registers\n+/* Define this macro if it is advisable to hold scalars in registers\n    in a wider mode than that declared by the program.  In such cases, \n    the value is constrained to be within the bounds of the declared\n    type, but kept valid in the wider mode.  The signedness of the"}, {"sha": "3ccc8d7fef8a054e1e3530d8b5b90d36c7f30f8e", "filename": "gcc/config/clipper/clipper.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddd5a7c1808995545ad5befaa7320135e60b5d38/gcc%2Fconfig%2Fclipper%2Fclipper.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddd5a7c1808995545ad5befaa7320135e60b5d38/gcc%2Fconfig%2Fclipper%2Fclipper.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fclipper%2Fclipper.md?ref=ddd5a7c1808995545ad5befaa7320135e60b5d38", "patch": "@@ -59,7 +59,7 @@\n   (const_string \"clobber\")))\n \n ;;\n-;; clipper seems to be a tradional risc processor\n+;; clipper seems to be a traditional risc processor\n ;; we define a functional unit 'memory'\n ;;\n (define_function_unit \"memory\" 1 1 (eq_attr \"type\" \"load\") 4 0)     \n@@ -305,7 +305,7 @@\n     operands[1] = force_reg (DImode, operands[1]);\n }\")\n \n-;; If an operand is a MEM but not offsetable, we can't load it into\n+;; If an operand is a MEM but not offsettable, we can't load it into\n ;; a register, so we must force the third alternative to be the one\n ;; reloaded.  Hence we show the first as more expensive.\n (define_insn \"\""}, {"sha": "484a6e44d81f97e384aa875298d755cdaedd91c1", "filename": "gcc/config/dsp16xx/dsp16xx.h", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddd5a7c1808995545ad5befaa7320135e60b5d38/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddd5a7c1808995545ad5befaa7320135e60b5d38/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx.h?ref=ddd5a7c1808995545ad5befaa7320135e60b5d38", "patch": "@@ -200,7 +200,7 @@ extern int target_flags;\n    Unit. */\n #define TARGET_BMU (target_flags & MASK_BMU)\n \n-/* Optimize to conseverve memory */\n+/* Optimize to conserve memory */\n #define TARGET_OPTIMIZE_MEMORY (target_flags & MASK_OPTIMIZE_MEMORY)\n \n /* Optimize for maximum speed */\n@@ -330,7 +330,7 @@ extern int target_flags;\n    For the 1600 we can decide arbitrarily since there are no machine instructions for them. */\n #define WORDS_BIG_ENDIAN 1\n \n-/* number of bits in an addressible storage unit */\n+/* number of bits in an addressable storage unit */\n #define BITS_PER_UNIT 16\n \n /* Width in bits of a \"word\", which is the contents of a machine register.\n@@ -598,7 +598,7 @@ extern int target_flags;\n    controlled by target switches, then GCC will automatically avoid\n    using these registers when the target switches are opposed to\n    them.)  If the user tells us there is no BMU, we can't use\n-   ar0-ar3 for regsiter allocation */\n+   ar0-ar3 for register allocation */\n \n #define CONDITIONAL_REGISTER_USAGE\t\t\t\t\t\\\n do\t\t\t\t\t\t\t\t\t\\\n@@ -1159,8 +1159,8 @@ extern struct dsp16xx_frame_info current_frame_info;\n /* Define the first register to be used for argument passing */\n #define FIRST_REG_FOR_FUNCTION_ARG REG_Y\n \n-/* Define the profitablity of saving registers around calls.\n-   NOTE: For now we turin this off because of a bug in the\n+/* Define the profitability of saving registers around calls.\n+   NOTE: For now we turn this off because of a bug in the\n    caller-saves code and also because i'm not sure it is helpful\n    on the 1610. */\n \n@@ -1470,7 +1470,7 @@ extern struct dsp16xx_frame_info current_frame_info;\n   case CONST_DOUBLE:\t\t\t\t\t\t        \\\n     return COSTS_N_INSNS (2);\n \n-/* Like CONST_COSTS but applies to nonsonstant RTL expressions.\n+/* Like CONST_COSTS but applies to nonconstant RTL expressions.\n    This can be used, for example to indicate how costly a multiply\n    instruction is. */\n #define RTX_COSTS(X,CODE,OUTER_CODE)                            \\\n@@ -1896,7 +1896,7 @@ bss_section ()\t\t\t\t\t\t\t   \\\n \n /* This is how to output an assembler line that says to advance \n    the location counter to a multiple of 2**LOG bytes. We should\n-   not have to do any alignemnt since the 1610 is a word machine. */\n+   not have to do any alignment since the 1610 is a word machine. */\n #define ASM_OUTPUT_ALIGN(FILE,LOG)\n \n /* Define this macro if ASM_OUTPUT_SKIP should not be used in the text section\n@@ -1944,8 +1944,8 @@ bss_section ()\t\t\t\t\t\t\t   \\\n /* Defining this macro causes the compiler to omit a sign-extend, zero-extend,\n    or bitwise 'and' instruction that truncates the count of a shift operation\n    to a width equal to the number of bits needed to represent the size of the\n-   object being shifted. Do not define this macro unless the trucation applies\n-   to both shoft operations and bit-field operations (if any). */\n+   object being shifted. Do not define this macro unless the truncation applies\n+   to both shift operations and bit-field operations (if any). */\n /* #define SHIFT_COUNT_TRUNCATED */\n \n /* Value is 1 if truncating an integer of INPREC bits to OUTPREC bits"}, {"sha": "386ad596ea8319d21145eaf5cca995df0baeb934", "filename": "gcc/config/dsp16xx/dsp16xx.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddd5a7c1808995545ad5befaa7320135e60b5d38/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddd5a7c1808995545ad5befaa7320135e60b5d38/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdsp16xx%2Fdsp16xx.md?ref=ddd5a7c1808995545ad5befaa7320135e60b5d38", "patch": "@@ -962,8 +962,8 @@\n \tswitch (which_alternative)\n \t{\n \t\tcase 0:\n-\t\t   /* We have to use the move mneumonic otherwise the 1610 will\n-\t\t      attempt to transfer all 32-bits of 'y', 'p' or an accumualtor\n+\t\t   /* We have to use the move mnemonic otherwise the 1610 will\n+\t\t      attempt to transfer all 32-bits of 'y', 'p' or an accumulator\n \t\t      , which we don't want */\n \t\t   if (REGNO(operands[1]) == REG_Y || REGNO(operands[1]) == REG_PROD\n \t\t\t|| IS_ACCUM_REG(REGNO(operands[1])))\n@@ -1008,8 +1008,8 @@\n \tswitch (which_alternative)\n \t{\n \t\tcase 0:\n-\t\t   /* We have to use the move mneumonic otherwise the 1610 will\n-\t\t      attempt to transfer all 32-bits of 'y', 'p' or an accumualtor\n+\t\t   /* We have to use the move mnemonic otherwise the 1610 will\n+\t\t      attempt to transfer all 32-bits of 'y', 'p' or an accumulator\n \t\t      , which we don't want */\n \t\t   if (REGNO(operands[1]) == REG_Y || REGNO(operands[1]) == REG_PROD\n \t\t\t|| IS_ACCUM_REG(REGNO(operands[1])))"}, {"sha": "8007aeb7a690073fca77ddc63d51ab47d9e0249f", "filename": "gcc/config/elxsi/elxsi.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddd5a7c1808995545ad5befaa7320135e60b5d38/gcc%2Fconfig%2Felxsi%2Felxsi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddd5a7c1808995545ad5befaa7320135e60b5d38/gcc%2Fconfig%2Felxsi%2Felxsi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Felxsi%2Felxsi.h?ref=ddd5a7c1808995545ad5befaa7320135e60b5d38", "patch": "@@ -442,7 +442,7 @@ enum reg_class { NO_REGS, GENERAL_REGS, ALL_REGS, LIM_REG_CLASSES };\n   extern int current_function_calls_alloca;\t\t\t\t\t\t\\\n   /* this conditional is ONLY here because there is a BUG;\t\t\\\n \t     EXIT_IGNORE_STACK is ignored itself when the first part of\t\t\\\n-\t     the condition is true! (atleast in version 1.35) */\t\t\\\n+\t     the condition is true! (at least in version 1.35) */\t\t\\\n   /* the 8*10 is for 64 bits of .r5 - .r14 */\t\t\t\t\\\n   if (current_function_calls_alloca || (SIZE)>=(256-8*10)) {\t\t\\\n     /* use .r4 as a temporary! Ok for now.... */\t\t\t\\"}, {"sha": "56984e85f86d0a020e38a69d59ecc043d2f1c321", "filename": "gcc/config/fp-bit.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddd5a7c1808995545ad5befaa7320135e60b5d38/gcc%2Fconfig%2Ffp-bit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddd5a7c1808995545ad5befaa7320135e60b5d38/gcc%2Fconfig%2Ffp-bit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffp-bit.c?ref=ddd5a7c1808995545ad5befaa7320135e60b5d38", "patch": "@@ -435,7 +435,7 @@ unpack_d (FLO_union_type * src, fp_number_type * dst)\n       /* Huge exponent*/\n       if (fraction == 0)\n \t{\n-\t  /* Attatched to a zero fraction - means infinity */\n+\t  /* Attached to a zero fraction - means infinity */\n \t  dst->class = CLASS_INFINITY;\n \t}\n       else\n@@ -569,7 +569,7 @@ _fpadd_parts (fp_number_type * a,\n \t  tmp->normal_exp = a_normal_exp;\n \t  tmp->fraction.ll = -tfraction;\n \t}\n-      /* and renomalize it */\n+      /* and renormalize it */\n \n       while (tmp->fraction.ll < IMPLICIT_1 && tmp->fraction.ll)\n \t{"}, {"sha": "a14155a03c546a610c971d5d3ad3814c3b75a85c", "filename": "gcc/config/h8300/h8300.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddd5a7c1808995545ad5befaa7320135e60b5d38/gcc%2Fconfig%2Fh8300%2Fh8300.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddd5a7c1808995545ad5befaa7320135e60b5d38/gcc%2Fconfig%2Fh8300%2Fh8300.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.c?ref=ddd5a7c1808995545ad5befaa7320135e60b5d38", "patch": "@@ -869,7 +869,7 @@ print_operand (file, x, code)\n       break;\n     case 'L':\n       /* 'L' must always be used twice in a single pattern.  It generates\n-\t the same lable twice, and then will generate a unique label the\n+\t the same label twice, and then will generate a unique label the\n \t next time it is used.  */\n       asm_fprintf (file, \"tl%d\", (lab++) / 2);\n       break;"}, {"sha": "c84d4345e14c7da886e4da42ea01da9ec3fc1356", "filename": "gcc/config/h8300/h8300.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddd5a7c1808995545ad5befaa7320135e60b5d38/gcc%2Fconfig%2Fh8300%2Fh8300.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddd5a7c1808995545ad5befaa7320135e60b5d38/gcc%2Fconfig%2Fh8300%2Fh8300.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.md?ref=ddd5a7c1808995545ad5befaa7320135e60b5d38", "patch": "@@ -1629,7 +1629,7 @@\n ;; BIT FIELDS\n ;; -----------------------------------------------------------------\n ;; The H8/300 has given 1/8th of its opcode space to bitfield\n-;; instuctions so let's use them as well as we can\n+;; instructions so let's use them as well as we can\n \n ;; BCC and BCS patterns.\n "}, {"sha": "06c5b8835e16373395d62637446cc316b9cd265c", "filename": "gcc/config/i370/i370.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddd5a7c1808995545ad5befaa7320135e60b5d38/gcc%2Fconfig%2Fi370%2Fi370.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddd5a7c1808995545ad5befaa7320135e60b5d38/gcc%2Fconfig%2Fi370%2Fi370.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi370%2Fi370.h?ref=ddd5a7c1808995545ad5befaa7320135e60b5d38", "patch": "@@ -59,7 +59,7 @@ extern int mvs_function_name_length;\n \n extern int current_function_outgoing_args_size;\n \n-/* Compile using char instructins (mvc, nc, oc, xc).  On 4341 use this since\n+/* Compile using char instructions (mvc, nc, oc, xc).  On 4341 use this since\n    these are more than twice as fast as load-op-store.\n    On 3090 don't use this since load-op-store is much faster.  */\n \n@@ -94,7 +94,7 @@ extern int current_function_outgoing_args_size;\n \n #define WORDS_BIG_ENDIAN 1\n \n-/* Number of bits in an addressible storage unit.  */\n+/* Number of bits in an addressable storage unit.  */\n \n #define BITS_PER_UNIT 8\n "}, {"sha": "a26c4b4cdcaf3a71db92e3a4696034b44b9cf3b2", "filename": "gcc/config/i370/i370.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddd5a7c1808995545ad5befaa7320135e60b5d38/gcc%2Fconfig%2Fi370%2Fi370.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddd5a7c1808995545ad5befaa7320135e60b5d38/gcc%2Fconfig%2Fi370%2Fi370.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi370%2Fi370.md?ref=ddd5a7c1808995545ad5befaa7320135e60b5d38", "patch": "@@ -1,7 +1,7 @@\n ;;- Machine description for GNU compiler -- System/370 version.\n ;;  Copyright (C) 1989, 1993, 1994 Free Software Foundation, Inc.\n ;;  Contributed by Jan Stein (jan@cd.chalmers.se).\n-;;  Modifed for MVS C/370 by Dave Pitts (pitts@mcdata.com)\n+;;  Modified for MVS C/370 by Dave Pitts (pitts@mcdata.com)\n \n ;; This file is part of GNU CC.\n \n@@ -42,7 +42,7 @@\n ;;   %R -- Print the register of a memory reference (PLUS (REG) (CONST_INT)).\n ;;   %X -- Print a constant byte integer in hex.\n ;;\n-;; We have a special contraint for pattern matching.\n+;; We have a special constraint for pattern matching.\n ;;\n ;;   s_operand -- Matches a valid S operand in a RS, SI or SS type instruction.\n ;;"}, {"sha": "6c3b5d5ccc3209e8866b926b764d8b68bb9f5f5c", "filename": "gcc/config/i370/xm-i370.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddd5a7c1808995545ad5befaa7320135e60b5d38/gcc%2Fconfig%2Fi370%2Fxm-i370.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddd5a7c1808995545ad5befaa7320135e60b5d38/gcc%2Fconfig%2Fi370%2Fxm-i370.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi370%2Fxm-i370.h?ref=ddd5a7c1808995545ad5befaa7320135e60b5d38", "patch": "@@ -1,7 +1,7 @@\n /* Configuration for GNU C-compiler for System/370.\n    Copyright (C) 1989, 1993 Free Software Foundation, Inc.\n    Contributed by Jan Stein (jan@cd.chalmers.se).\n-   Modifed for MVS C/370 by Dave Pitts (pitts@mcdata.com)\n+   Modified for MVS C/370 by Dave Pitts (pitts@mcdata.com)\n \n This file is part of GNU CC.\n "}, {"sha": "c5f2aa56b722cd3ce2b66749b347c1d7c56e319a", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddd5a7c1808995545ad5befaa7320135e60b5d38/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddd5a7c1808995545ad5befaa7320135e60b5d38/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=ddd5a7c1808995545ad5befaa7320135e60b5d38", "patch": "@@ -58,7 +58,7 @@ extern int target_flags;\n \n /* Macros used in the machine description to test the flags.  */\n \n-/* configure can arrage to make this 2, to force a 486.  */\n+/* configure can arrange to make this 2, to force a 486.  */\n #ifndef TARGET_CPU_DEFAULT\n #define TARGET_CPU_DEFAULT 0\n #endif\n@@ -717,7 +717,7 @@ enum reg_class\n    register and zero otherwise.  On most machines, this default\n    should be used.  Only define this macro to some other expression\n    if pseudo allocated by `local-alloc.c' end up in memory because\n-   their hard registers were needed for spill regisers.  If this\n+   their hard registers were needed for spill registers.  If this\n    macro returns nonzero for those classes, those pseudos will only\n    be allocated by `global.c', which knows how to reallocate the\n    pseudo to another register.  If there would not be another"}, {"sha": "1433c2896eed9731ebb0115d3baa100b7b9a3d48", "filename": "gcc/config/i386/linux.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddd5a7c1808995545ad5befaa7320135e60b5d38/gcc%2Fconfig%2Fi386%2Flinux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddd5a7c1808995545ad5befaa7320135e60b5d38/gcc%2Fconfig%2Fi386%2Flinux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Flinux.h?ref=ddd5a7c1808995545ad5befaa7320135e60b5d38", "patch": "@@ -72,7 +72,7 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n    for x86 FP registers, but the SDB on x86/svr4 is so completely\n    broken with respect to FP registers that it is hardly worth thinking\n    of it as something to strive for compatibility with.\n-   The verison of x86/svr4 SDB I have at the moment does (partially)\n+   The version of x86/svr4 SDB I have at the moment does (partially)\n    seem to believe that DWARF register number 11 is associated with\n    the x86 register %st(0), but that's about all.  Higher DWARF\n    register numbers don't seem to be associated with anything in"}, {"sha": "f6e8ae27e7b6044e2d8134e17b0d0c47ce040701", "filename": "gcc/config/i386/os2.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddd5a7c1808995545ad5befaa7320135e60b5d38/gcc%2Fconfig%2Fi386%2Fos2.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddd5a7c1808995545ad5befaa7320135e60b5d38/gcc%2Fconfig%2Fi386%2Fos2.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fos2.h?ref=ddd5a7c1808995545ad5befaa7320135e60b5d38", "patch": "@@ -54,7 +54,7 @@ extern int maximum_field_alignment;\n #undef PCC_BITFIELD_TYPE_MATTERS\n #define PCC_BITFIELD_TYPE_MATTERS (maximum_field_alignment == 0)\n \n-/* Define this macro if it is advisible to hold scalars in registers\n+/* Define this macro if it is advisable to hold scalars in registers\n    in a wider mode than that declared by the program.  In such cases,\n    the value is constrained to be within the bounds of the declared\n    type, but kept valid in the wider mode.  The signedness of the"}, {"sha": "97af2a9fc38f7dbcd364c05fd349a89f51a3ad4a", "filename": "gcc/config/i386/sysv4.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddd5a7c1808995545ad5befaa7320135e60b5d38/gcc%2Fconfig%2Fi386%2Fsysv4.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddd5a7c1808995545ad5befaa7320135e60b5d38/gcc%2Fconfig%2Fi386%2Fsysv4.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fsysv4.h?ref=ddd5a7c1808995545ad5befaa7320135e60b5d38", "patch": "@@ -133,7 +133,7 @@ do { long value[3];\t\t\t\t\t\t\t\\\n    broken with respect to FP registers that it is hardly worth thinking\n    of it as something to strive for compatibility with.\n \n-   The verison of x86/svr4 SDB I have at the moment does (partially)\n+   The version of x86/svr4 SDB I have at the moment does (partially)\n    seem to believe that DWARF register number 11 is associated with\n    the x86 register %st(0), but that's about all.  Higher DWARF\n    register numbers don't seem to be associated with anything in"}, {"sha": "9544b4cfa22f697f8c4e1ebeb9e77caee8857b2c", "filename": "gcc/config/i860/i860.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddd5a7c1808995545ad5befaa7320135e60b5d38/gcc%2Fconfig%2Fi860%2Fi860.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddd5a7c1808995545ad5befaa7320135e60b5d38/gcc%2Fconfig%2Fi860%2Fi860.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi860%2Fi860.md?ref=ddd5a7c1808995545ad5befaa7320135e60b5d38", "patch": "@@ -1441,7 +1441,7 @@\n ;; Signed bitfield extractions come out looking like\n ;;\t(shiftrt (sign_extend (shift <Y> <C1>)) <C2>)\n ;; which we expand poorly as four shift insns.\n-;; These patters yeild two shifts:\n+;; These patterns yield two shifts:\n ;;\t(shiftrt (shift <Y> <C3>) <C4>)\n (define_insn \"\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")"}, {"sha": "e73aa9921dec9546ba1bbe9b36cf32324a7b8cca", "filename": "gcc/config/i860/paragon.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddd5a7c1808995545ad5befaa7320135e60b5d38/gcc%2Fconfig%2Fi860%2Fparagon.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddd5a7c1808995545ad5befaa7320135e60b5d38/gcc%2Fconfig%2Fi860%2Fparagon.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi860%2Fparagon.h?ref=ddd5a7c1808995545ad5befaa7320135e60b5d38", "patch": "@@ -55,7 +55,7 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n /* autoinit.o autolaunches NX applications */\n #define STARTFILE_SPEC \"-ycrt0.o%s %{mnx:-yoptions/autoinit.o%s}\"\n \n-/* libic.a is the PGI intrisic library */\n+/* libic.a is the PGI intrinsic library */\n /* libpm.o and guard.o are for the performance monitoring modules (ignored) */\n /* /usr/lib/noieee contains non-IEEE compliant (but faster) math routines */\n #if\tHAVE_DASH_G"}, {"sha": "f9ddfec7051036a24f8fd92c17cb2e30cd36de62", "filename": "gcc/config/i960/i960.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddd5a7c1808995545ad5befaa7320135e60b5d38/gcc%2Fconfig%2Fi960%2Fi960.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddd5a7c1808995545ad5befaa7320135e60b5d38/gcc%2Fconfig%2Fi960%2Fi960.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi960%2Fi960.c?ref=ddd5a7c1808995545ad5befaa7320135e60b5d38", "patch": "@@ -827,7 +827,7 @@ i960_function_name_declare (file, name, fndecl)\n   else\n     leaf_proc_ok = 0;\n \n-  /* Even if nobody uses extra parms, can't have leafroc or tail calls if\n+  /* Even if nobody uses extra parms, can't have leafproc or tail calls if\n      argblock, because argblock uses g14 implicitly.  */\n \n   if (current_function_args_size != 0 || VARARGS_STDARG_FUNCTION (fndecl))"}, {"sha": "6df7e210eab78398dbce6ec65fee806577deb5e9", "filename": "gcc/config/i960/i960.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddd5a7c1808995545ad5befaa7320135e60b5d38/gcc%2Fconfig%2Fi960%2Fi960.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddd5a7c1808995545ad5befaa7320135e60b5d38/gcc%2Fconfig%2Fi960%2Fi960.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi960%2Fi960.h?ref=ddd5a7c1808995545ad5befaa7320135e60b5d38", "patch": "@@ -307,7 +307,7 @@ extern int target_flags;\n /* Target machine storage layout.  */\n \n /* Define for cross-compilation from a host with a different float format\n-   or endianess (e.g. VAX, x86).  */\n+   or endianness (e.g. VAX, x86).  */\n #define REAL_ARITHMETIC\n \n /* Define this if most significant bit is lowest numbered"}, {"sha": "b23001a9238afb0e421524bd53c9695fb62117d2", "filename": "gcc/config/m68k/ccur-GAS.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddd5a7c1808995545ad5befaa7320135e60b5d38/gcc%2Fconfig%2Fm68k%2Fccur-GAS.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddd5a7c1808995545ad5befaa7320135e60b5d38/gcc%2Fconfig%2Fm68k%2Fccur-GAS.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fccur-GAS.h?ref=ddd5a7c1808995545ad5befaa7320135e60b5d38", "patch": "@@ -75,7 +75,7 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n #undef EMPTY_FIELD_BOUNDARY\n #define EMPTY_FIELD_BOUNDARY 32\n \n-/* Allocation boundry in bits for the code of a function */\n+/* Allocation boundary in bits for the code of a function */\n #undef  FUNCTION_BOUNDARY\n #define FUNCTION_BOUNDARY 32\n "}, {"sha": "0b47f8ccc9aff8fb64b768e8c1759f381dd6fd2a", "filename": "gcc/config/m68k/hp320.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddd5a7c1808995545ad5befaa7320135e60b5d38/gcc%2Fconfig%2Fm68k%2Fhp320.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddd5a7c1808995545ad5befaa7320135e60b5d38/gcc%2Fconfig%2Fm68k%2Fhp320.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fhp320.h?ref=ddd5a7c1808995545ad5befaa7320135e60b5d38", "patch": "@@ -601,6 +601,6 @@ do { register int i;\t\t\t\\\n   (! symbolic_operand (X, VOIDmode) \\\n    || ((GET_CODE(X) == SYMBOL_REF) && SYMBOL_REF_FLAG(X)))\n \n-/* hpux8 and later have C++ compatable include files, so do not\n+/* hpux8 and later have C++ compatible include files, so do not\n    pretend they are `extern \"C\"'.  */\n #define NO_IMPLICIT_EXTERN_C"}, {"sha": "7833e5388d21b9d676a3d446e6b707701090f192", "filename": "gcc/config/m68k/lb1sf68.asm", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddd5a7c1808995545ad5befaa7320135e60b5d38/gcc%2Fconfig%2Fm68k%2Flb1sf68.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddd5a7c1808995545ad5befaa7320135e60b5d38/gcc%2Fconfig%2Fm68k%2Flb1sf68.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Flb1sf68.asm?ref=ddd5a7c1808995545ad5befaa7320135e60b5d38", "patch": "@@ -315,7 +315,7 @@ L4:\tlsrl\tIMM (1), d1\t/* shift divisor */\n \tdivu\td1, d0\t\t/* now we have 16 bit divisor */\n \tandl\tIMM (0xffff), d0 /* mask out divisor, ignore remainder */\n \n-/* Muliply the 16 bit tentative quotient with the 32 bit divisor.  Because of\n+/* Multiply the 16 bit tentative quotient with the 32 bit divisor.  Because of\n    the operand ranges, this might give a 33 bit product.  If this product is\n    greater than the dividend, the tentative quotient was too large. */\n \tmovel\td2, d1\n@@ -628,7 +628,7 @@ Ladddf$2:\n | Here we have a's exponent larger than b's, so we have to shift b. We do \n | this by using as counter d2:\n 1:\tmovew\td4,d2\t\t| move largest exponent to d2\n-\tsubw\td5,d2\t\t| and substract second exponent\n+\tsubw\td5,d2\t\t| and subtract second exponent\n \texg\td4,a2\t\t| get back the longs we saved\n \texg\td5,a3\t\t|\n | if difference is too large we don't shift (actually, we can just exit) '\n@@ -714,7 +714,7 @@ Ladddf$4:\n | Now we have the numbers in d0--d3 and d4--d7, the exponent in a2, and\n | the signs in a4.\n \n-| Here we have to decide whether to add or substract the numbers:\n+| Here we have to decide whether to add or subtract the numbers:\n \texg\td7,a0\t\t| get the signs \n \texg\td6,a3\t\t| a3 is free to be used\n \tmovel\td7,d6\t\t|\n@@ -723,7 +723,7 @@ Ladddf$4:\n \tmovew\tIMM (0),d6\t| and b's sign in d6 '\n \teorl\td7,d6\t\t| compare the signs\n \tbmi\tLsubdf$0\t| if the signs are different we have \n-\t\t\t\t| to substract\n+\t\t\t\t| to subtract\n \texg\td7,a0\t\t| else we add the numbers\n \texg\td6,a3\t\t|\n \taddl\td7,d3\t\t|\n@@ -739,7 +739,7 @@ Ladddf$4:\n \n | Before rounding normalize so bit #DBL_MANT_DIG is set (we will consider\n | the case of denormalized numbers in the rounding routine itself).\n-| As in the addition (not in the substraction!) we could have set \n+| As in the addition (not in the subtraction!) we could have set \n | one more bit we check this:\n \tbtst\tIMM (DBL_MANT_DIG+1),d0\t\n \tbeq\t1f\n@@ -772,7 +772,7 @@ Ladddf$5:\n \tbra\tLd$overflow\n \n Lsubdf$0:\n-| Here we do the substraction.\n+| Here we do the subtraction.\n \texg\td7,a0\t\t| put sign back in a0\n \texg\td6,a3\t\t|\n \tsubl\td7,d3\t\t|\n@@ -796,7 +796,7 @@ Lsubdf$0:\n \n | Before rounding normalize so bit #DBL_MANT_DIG is set (we will consider\n | the case of denormalized numbers in the rounding routine itself).\n-| As in the addition (not in the substraction!) we could have set \n+| As in the addition (not in the subtraction!) we could have set \n | one more bit we check this:\n \tbtst\tIMM (DBL_MANT_DIG+1),d0\t\n \tbeq\t1f\n@@ -927,7 +927,7 @@ Ladddf$nf:\n 3:\n | Now comes the check for +/-INFINITY. We know that both are (maybe not\n | finite) numbers, but we have to check if both are infinite whether we\n-| are adding or substracting them.\n+| are adding or subtracting them.\n \teorl\td7,d6\t\t| to check sign bits\n \tbmi\t1f\n \tandl\tIMM (0x80000000),d7 | get (common) sign bit\n@@ -999,7 +999,7 @@ Lmuldf$1:\n \tlsrw\tIMM (4),d5\t\t|\n Lmuldf$2:\t\t\t\t|\n \taddw\td5,d4\t\t\t| add exponents\n-\tsubw\tIMM (D_BIAS+1),d4\t| and substract bias (plus one)\n+\tsubw\tIMM (D_BIAS+1),d4\t| and subtract bias (plus one)\n \n | We are now ready to do the multiplication. The situation is as follows:\n | both a and b have bit 52 ( bit 20 of d0 and d2) set (even if they were \n@@ -1210,7 +1210,7 @@ Ldivdf$1:\t\t\t|\n \tswap\td5\t\t|\n \tlsrw\tIMM (4),d5\t|\n Ldivdf$2:\t\t\t|\n-\tsubw\td5,d4\t\t| substract exponents\n+\tsubw\td5,d4\t\t| subtract exponents\n \taddw\tIMM (D_BIAS),d4\t| and add bias\n \n | We are now ready to do the division. We have prepared things in such a way\n@@ -1245,7 +1245,7 @@ Ldivdf$2:\t\t\t|\n \tdbra\td5,1b\t\t| and branch back\n \tbra\t5f\t\t\t\n 4:\tcmpl\td1,d3\t\t| here d0==d2, so check d1 and d3\n-\tbhi\t3b\t\t| if d1 > d2 skip the substraction\n+\tbhi\t3b\t\t| if d1 > d2 skip the subtraction\n \tbra\t2b\t\t| else go do it\n 5:\n | Here we have to start setting the bits in the second long.\n@@ -1262,7 +1262,7 @@ Ldivdf$2:\t\t\t|\n \tdbra\td5,1b\t\t| and branch back\n \tbra\t5f\t\t\t\n 4:\tcmpl\td1,d3\t\t| here d0==d2, so check d1 and d3\n-\tbhi\t3b\t\t| if d1 > d2 skip the substraction\n+\tbhi\t3b\t\t| if d1 > d2 skip the subtraction\n \tbra\t2b\t\t| else go do it\n 5:\n | Now go ahead checking until we hit a one, which we store in d2.\n@@ -1902,12 +1902,12 @@ Laddsf$2:\n | signs are stored in a0 and a1).\n \n Laddsf$3:\n-| Here we have to decide whether to add or substract the numbers\n+| Here we have to decide whether to add or subtract the numbers\n \texg\td6,a0\t\t| get signs back\n \texg\td7,a1\t\t| and save the exponents\n \teorl\td6,d7\t\t| combine sign bits\n \tbmi\tLsubsf$0\t| if negative a and b have opposite \n-\t\t\t\t| sign so we actually substract the\n+\t\t\t\t| sign so we actually subtract the\n \t\t\t\t| numbers\n \n | Here we have both positive or both negative\n@@ -1926,7 +1926,7 @@ Laddsf$3:\n \n | Before rounding normalize so bit #FLT_MANT_DIG is set (we will consider\n | the case of denormalized numbers in the rounding routine itself).\n-| As in the addition (not in the substraction!) we could have set \n+| As in the addition (not in the subtraction!) we could have set \n | one more bit we check this:\n \tbtst\tIMM (FLT_MANT_DIG+1),d0\t\n \tbeq\t1f\n@@ -1957,7 +1957,7 @@ Laddsf$4:\n \n Lsubsf$0:\n | We are here if a > 0 and b < 0 (sign bits cleared).\n-| Here we do the substraction.\n+| Here we do the subtraction.\n \tmovel\td6,d7\t\t| put sign in d7\n \tandl\tIMM (0x80000000),d7\n \n@@ -1974,7 +1974,7 @@ Lsubsf$0:\n \n | Now d0-d1 is positive and the sign bit is in d7.\n \n-| Note that we do not have to normalize, since in the substraction bit\n+| Note that we do not have to normalize, since in the subtraction bit\n | #FLT_MANT_DIG+1 is never set, and denormalized numbers are handled by\n | the rounding routines themselves.\n \tlea\tLsubsf$1,a0\t| to return from rounding routine\n@@ -2071,7 +2071,7 @@ Laddsf$ret$den:\n \n | Note: when adding two floats of the same sign if either one is \n | NaN we return NaN without regard to whether the other is finite or \n-| not. When substracting them (i.e., when adding two numbers of \n+| not. When subtracting them (i.e., when adding two numbers of \n | opposite signs) things are more complicated: if both are INFINITY \n | we return NaN, if only one is INFINITY and the other is NaN we return\n | NaN, but if it is finite we return INFINITY with the corresponding sign.\n@@ -2095,7 +2095,7 @@ Laddsf$nf:\n \tbhi\tLf$inop\t\t\n | Now comes the check for +/-INFINITY. We know that both are (maybe not\n | finite) numbers, but we have to check if both are infinite whether we\n-| are adding or substracting them.\n+| are adding or subtracting them.\n \teorl\td3,d2\t\t| to check sign bits\n \tbmi\t1f\n \tmovel\td0,d7\n@@ -2161,7 +2161,7 @@ Lmulsf$1:\t\t\t| number\n \tlsrw\tIMM (7),d3\t|\n Lmulsf$2:\t\t\t|\n \taddw\td3,d2\t\t| add exponents\n-\tsubw\tIMM (F_BIAS+1),d2 | and substract bias (plus one)\n+\tsubw\tIMM (F_BIAS+1),d2 | and subtract bias (plus one)\n \n | We are now ready to do the multiplication. The situation is as follows:\n | both a and b have bit FLT_MANT_DIG-1 set (even if they were \n@@ -2292,7 +2292,7 @@ SYM (__divsf3):\n \tbeq\tLdivsf$b$0\t\t| branch if b is zero\n \tcmpl\td6,d0\t\t\t| is a big?\n \tbhi\tLdivsf$inop\t\t| if a is NaN return NaN\n-\tbeq\tLdivsf$inf\t\t| if a is INIFINITY we have to check b\n+\tbeq\tLdivsf$inf\t\t| if a is INFINITY we have to check b\n \tcmpl\td6,d1\t\t\t| now compare b with INFINITY \n \tbhi\tLdivsf$inop\t\t| if b is NaN return NaN\n \tbeq\tLdivsf$underflow\n@@ -2314,7 +2314,7 @@ Ldivsf$1:\t\t\t|\n \tswap\td3\t\t|\n \tlsrw\tIMM (7),d3\t|\n Ldivsf$2:\t\t\t|\n-\tsubw\td3,d2\t\t| substract exponents\n+\tsubw\td3,d2\t\t| subtract exponents\n  \taddw\tIMM (F_BIAS),d2\t| and add bias\n  \n | We are now ready to do the division. We have prepared things in such a way"}, {"sha": "95354c3473377ac5dff2a9927e5c6ce146f832f3", "filename": "gcc/config/m68k/m68k.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddd5a7c1808995545ad5befaa7320135e60b5d38/gcc%2Fconfig%2Fm68k%2Fm68k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddd5a7c1808995545ad5befaa7320135e60b5d38/gcc%2Fconfig%2Fm68k%2Fm68k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.c?ref=ddd5a7c1808995545ad5befaa7320135e60b5d38", "patch": "@@ -1040,7 +1040,7 @@ const_method (constant)\n   /* Likewise, try with not.w */\n   if (use_movq (i ^ 0xffff))\n     return NOTW;\n-  /* This is the only value where neg.w is usefull */\n+  /* This is the only value where neg.w is useful */\n   if (i == -65408)\n     return NEGW;\n   /* Try also with swap */"}, {"sha": "0bdb05a913fb2918bda0a136d69e381919d560d4", "filename": "gcc/config/m68k/plexus.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddd5a7c1808995545ad5befaa7320135e60b5d38/gcc%2Fconfig%2Fm68k%2Fplexus.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddd5a7c1808995545ad5befaa7320135e60b5d38/gcc%2Fconfig%2Fm68k%2Fplexus.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fplexus.h?ref=ddd5a7c1808995545ad5befaa7320135e60b5d38", "patch": "@@ -15,7 +15,7 @@\n    The Plexus port of gcc requires you to use gas ( either 1.3X with COFF \n    patches or 2.X ),  If you use gas 2.X you have to use binutils-2.X.\n       \n-   With using gas-2.X the Plexus gcc port is now capabable of generating\n+   With using gas-2.X the Plexus gcc port is now capable of generating\n    output suitable for use by gdb-4.X ( send mail to above address for\n    info on getting gdb patches or other GNU items for the Plexus )\n "}, {"sha": "4c809f958f9175a26dc2904b52e5b521fe23b9fc", "filename": "gcc/config/m68k/x-apollo68", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddd5a7c1808995545ad5befaa7320135e60b5d38/gcc%2Fconfig%2Fm68k%2Fx-apollo68", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddd5a7c1808995545ad5befaa7320135e60b5d38/gcc%2Fconfig%2Fm68k%2Fx-apollo68", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fx-apollo68?ref=ddd5a7c1808995545ad5befaa7320135e60b5d38", "patch": "@@ -6,7 +6,7 @@ CC=cc -g -A nansi -A cpu,3000 -A runtype,bsd4.3 -A systype,any -DSHORT_ENUM_BUG\n OLDCC=cc -g -A nansi -A cpu,3000 -A runtype,bsd4.3 -A systype,any -DSHORT_ENUM_BUG\n \n # This used to redefine CFLAGS and LIBGCC2_CFLAGS to eliminate the unsupported\n-# -g flag from both macros.  This gives an undebugable stage1 compiler which\n+# -g flag from both macros.  This gives an undebuggable stage1 compiler which\n # is bad, and it also does the wrong thing if we are cross compiling to a\n # target which does support debugging.  There is currently no way to avoid\n # the -g option that doesn't break something else."}, {"sha": "b61b8826e04bd612c269df4693e05060406d3577", "filename": "gcc/config/m88k/m88k.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddd5a7c1808995545ad5befaa7320135e60b5d38/gcc%2Fconfig%2Fm88k%2Fm88k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddd5a7c1808995545ad5befaa7320135e60b5d38/gcc%2Fconfig%2Fm88k%2Fm88k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm88k%2Fm88k.c?ref=ddd5a7c1808995545ad5befaa7320135e60b5d38", "patch": "@@ -1349,7 +1349,7 @@ real_or_0_operand (op, mode)\n \t      && op == CONST0_RTX (mode)));\n }\n \n-/* Return true if OP is valid to use in the context of logic aritmethic\n+/* Return true if OP is valid to use in the context of logic arithmetic\n    on condition codes. */\n \n int\n@@ -2029,7 +2029,7 @@ m88k_end_epilogue (stream, size)\n     PUT_OCS_FUNCTION_END (stream);\n \n   /* If the last insn isn't a BARRIER, we must write a return insn.  This\n-     should only happen if the function has no prologe and no body.  */\n+     should only happen if the function has no prologue and no body.  */\n   if (GET_CODE (insn) == NOTE)\n     insn = prev_nonnote_insn (insn);\n   if (insn == 0 || GET_CODE (insn) != BARRIER)"}, {"sha": "8cdf561e72439dcf3c9623e1e6016a8122dd04af", "filename": "gcc/config/m88k/tekXD88.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddd5a7c1808995545ad5befaa7320135e60b5d38/gcc%2Fconfig%2Fm88k%2FtekXD88.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddd5a7c1808995545ad5befaa7320135e60b5d38/gcc%2Fconfig%2Fm88k%2FtekXD88.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm88k%2FtekXD88.h?ref=ddd5a7c1808995545ad5befaa7320135e60b5d38", "patch": "@@ -41,7 +41,7 @@\n \n /* The bundled ld program needs link editor directives which normally\n    reside in /lib/default.ld.  We'll pass our own copy during the link\n-   phase because additioal information about extra sections must be added\n+   phase because additional information about extra sections must be added\n    so that gcc generated files will link properly.\n    --KRG.\n    */"}, {"sha": "94a2210285f592455a061b46ee64aad560d01f79", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddd5a7c1808995545ad5befaa7320135e60b5d38/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddd5a7c1808995545ad5befaa7320135e60b5d38/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=ddd5a7c1808995545ad5befaa7320135e60b5d38", "patch": "@@ -117,7 +117,7 @@ int num_source_filenames = 0;\n    start and end boundaries).  */\n int sdb_label_count = 0;\n \n-/* Next label # for each statment for Silicon Graphics IRIS systems. */\n+/* Next label # for each statement for Silicon Graphics IRIS systems. */\n int sym_lineno = 0;\n \n /* Non-zero if inside of a function, because the stupid MIPS asm can't\n@@ -4716,7 +4716,7 @@ save_restore_insns (store_p, large_reg, large_offset, file)\n     }\n   else\n     {\n-      base_reg_rtx = (rtx)0;\t\t/* Make sure these are initialzed */\n+      base_reg_rtx = (rtx)0;\t\t/* Make sure these are initialized */\n       base_offset  = 0;\n     }\n "}, {"sha": "39f6cf39d3316d5bd92eb558412da4d33fab8fd2", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddd5a7c1808995545ad5befaa7320135e60b5d38/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddd5a7c1808995545ad5befaa7320135e60b5d38/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=ddd5a7c1808995545ad5befaa7320135e60b5d38", "patch": "@@ -3314,7 +3314,7 @@ while (0)\n #define ASM_OUTPUT_SOURCE_FILENAME(STREAM, NAME)\t\t\t\\\n   mips_output_filename (STREAM, NAME)\n \n-/* This is defined so that it can be overriden in iris6.h.  */\n+/* This is defined so that it can be overridden in iris6.h.  */\n #define ASM_OUTPUT_FILENAME(STREAM, NUM_SOURCE_FILENAMES, NAME) \\\n do\t\t\t\t\t\t\t\t\\\n   {\t\t\t\t\t\t\t\t\\"}, {"sha": "5c572868999842fe15d8817adea4c0def8568c32", "filename": "gcc/config/nextstep21.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddd5a7c1808995545ad5befaa7320135e60b5d38/gcc%2Fconfig%2Fnextstep21.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddd5a7c1808995545ad5befaa7320135e60b5d38/gcc%2Fconfig%2Fnextstep21.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnextstep21.h?ref=ddd5a7c1808995545ad5befaa7320135e60b5d38", "patch": "@@ -26,7 +26,7 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n #undef USE_COLLECT2\n #define USE_COLLECT2\n \n-/* use this until a newer gdb for NeXTStep21 is availible */\n+/* use this until a newer gdb for NeXTStep21 is available */\n #define DEFAULT_GDB_EXTENSIONS 0\n \n /* we need the call to __main to start all global destructors and constructors"}, {"sha": "43017c74ae2249ee64267262ff31e9b153b5c1b5", "filename": "gcc/config/pa/pa-hpux.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddd5a7c1808995545ad5befaa7320135e60b5d38/gcc%2Fconfig%2Fpa%2Fpa-hpux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddd5a7c1808995545ad5befaa7320135e60b5d38/gcc%2Fconfig%2Fpa%2Fpa-hpux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa-hpux.h?ref=ddd5a7c1808995545ad5befaa7320135e60b5d38", "patch": "@@ -45,6 +45,6 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n #define LINK_SPEC \\\n   \"%{!shared:-u main} %{static:-a archive} %{g*:-a archive} %{shared:-b}\"\n \n-/* hpux8 and later have C++ compatable include files, so do not\n+/* hpux8 and later have C++ compatible include files, so do not\n    pretend they are `extern \"C\"'.  */\n #define NO_IMPLICIT_EXTERN_C"}, {"sha": "be95729684a3c4bf2f225b4c81fadffd6b814619", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddd5a7c1808995545ad5befaa7320135e60b5d38/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddd5a7c1808995545ad5befaa7320135e60b5d38/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=ddd5a7c1808995545ad5befaa7320135e60b5d38", "patch": "@@ -64,7 +64,7 @@ static rtx find_addr_reg ();\n unsigned int total_code_bytes;\n \n /* Variables to handle plabels that we discover are necessary at assembly\n-   output time.  They are output after the currrent function.  */\n+   output time.  They are output after the current function.  */\n \n struct defer_plab\n {\n@@ -416,7 +416,7 @@ zdepi_cint_p (x)\n   unsigned HOST_WIDE_INT lsb_mask, t;\n \n   /* This might not be obvious, but it's at least fast.\n-     This function is critcal; we don't have the time loops would take.  */\n+     This function is critical; we don't have the time loops would take.  */\n   lsb_mask = x & -x;\n   t = ((x >> 4) + lsb_mask) & ~(lsb_mask - 1);\n   /* Return true iff t is a power of two.  */\n@@ -619,7 +619,7 @@ legitimize_pic_address (orig, mode, reg)\n \n    It is also beneficial to handle (plus (mult (X) (Y)) (Z)) in a special\n    manner if Y is 2, 4, or 8.  (allows more shadd insns and shifted indexed\n-   adressing modes to be used).\n+   addressing modes to be used).\n \n    Put X and Z into registers.  Then put the entire expression into\n    a register.  */\n@@ -1421,7 +1421,7 @@ output_fp_move_double (operands)\n \t  output_asm_insn (\"copy %%r0,%0\\n\\tcopy %%r0,%1\", xoperands);\n \t}\n       /* This is a pain.  You have to be prepared to deal with an\n-\t arbritary address here including pre/post increment/decrement.\n+\t arbitrary address here including pre/post increment/decrement.\n \n \t so avoid this in the MD.  */\n       else\n@@ -2225,7 +2225,7 @@ hppa_expand_prologue()\n      mcounts do, _mcount appears to behave differently on the HPPA.  It\n      takes the return address of the caller, the address of this routine,\n      and the address of the label.  Also, it isn't magic, so\n-     argument registre hsave to be preserved.  */\n+     argument registers have to be preserved.  */\n   if (profile_flag)\n     {\n       int pc_offset, i, arg_offset, basereg, offsetadj;\n@@ -2657,7 +2657,7 @@ pa_adjust_cost (insn, link, dep_insn, cost)\n \t\tcase TYPE_FPSQRTSGL:\n \t\tcase TYPE_FPSQRTDBL:\n \t\t  /* A fpload can't be issued until one cycle before a\n-\t\t     preceeding arithmetic operation has finished if\n+\t\t     preceding arithmetic operation has finished if\n \t\t     the target of the fpload is any of the sources\n \t\t     (or destination) of the arithmetic operation.  */\n \t\t  return cost - (pa_cpu_attr == PROCESSOR_700) ? 1 : 2;\n@@ -2692,7 +2692,7 @@ pa_adjust_cost (insn, link, dep_insn, cost)\n \t\tcase TYPE_FPSQRTSGL:\n \t\tcase TYPE_FPSQRTDBL:\n \t\t  /* An ALU flop can't be issued until two cycles before a\n-\t\t     preceeding divide or sqrt operation has finished if\n+\t\t     preceding divide or sqrt operation has finished if\n \t\t     the target of the ALU flop is any of the sources\n \t\t     (or destination) of the divide or sqrt operation.  */\n \t\t  return cost - (pa_cpu_attr == PROCESSOR_700) ? 2 : 4;\n@@ -2738,7 +2738,7 @@ pa_adjust_cost (insn, link, dep_insn, cost)\n \t\tcase TYPE_FPSQRTSGL:\n \t\tcase TYPE_FPSQRTDBL:\n \t\t  /* A fpload can't be issued until one cycle before a\n-\t\t     preceeding arithmetic operation has finished if\n+\t\t     preceding arithmetic operation has finished if\n \t\t     the target of the fpload is the destination of the\n \t\t     arithmetic operation.  */\n \t\t  return cost - (pa_cpu_attr == PROCESSOR_700) ? 1 : 2;\n@@ -2773,7 +2773,7 @@ pa_adjust_cost (insn, link, dep_insn, cost)\n \t\tcase TYPE_FPSQRTSGL:\n \t\tcase TYPE_FPSQRTDBL:\n \t\t  /* An ALU flop can't be issued until two cycles before a\n-\t\t     preceeding divide or sqrt operation has finished if\n+\t\t     preceding divide or sqrt operation has finished if\n \t\t     the target of the ALU flop is also the target of\n \t\t     of the divide or sqrt operation.  */\n \t\t  return cost - (pa_cpu_attr == PROCESSOR_700) ? 2 : 4;\n@@ -4482,7 +4482,7 @@ jump_in_call_delay (insn)\n    instructions!\n \n    Because we actually jump into the table, the addresses of each entry\n-   must stay contant in relation to the beginning of the table (which\n+   must stay constant in relation to the beginning of the table (which\n    itself must stay constant relative to the instruction to jump into\n    it).  I don't believe we can guarantee earlier passes of the compiler\n    will adhere to those rules."}, {"sha": "8ab2021c7adb81f93283cab7b63468143e8a8869", "filename": "gcc/config/pa/pa.h", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddd5a7c1808995545ad5befaa7320135e60b5d38/gcc%2Fconfig%2Fpa%2Fpa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddd5a7c1808995545ad5befaa7320135e60b5d38/gcc%2Fconfig%2Fpa%2Fpa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.h?ref=ddd5a7c1808995545ad5befaa7320135e60b5d38", "patch": "@@ -155,7 +155,7 @@ extern int target_flags;\n #define DEFAULT_GDB_EXTENSIONS 1\n \n /* This is the way other stabs-in-XXX tools do things.  We will be\n-   compatable.  */\n+   compatible.  */\n #define DBX_BLOCKS_FUNCTION_RELATIVE 1\n \n /* Likewise for linenos.\n@@ -180,7 +180,7 @@ extern int target_flags;\n    name *first*...  */\n #define DBX_FUNCTION_FIRST\n \n-/* Only lables should ever begin in colunm zero.  */\n+/* Only labels should ever begin in column zero.  */\n #define ASM_STABS_OP \"\\t.stabs\"\n #define ASM_STABN_OP \"\\t.stabn\"\n \n@@ -265,7 +265,7 @@ do {\t\t\t\t\t\t\t\t\\\n /* target machine storage layout */\n \n /* Define for cross-compilation from a host with a different float format\n-   or endianess (e.g. VAX, x86).  */\n+   or endianness (e.g. VAX, x86).  */\n #define REAL_ARITHMETIC\n \n /* Define this macro if it is advisable to hold scalars in registers\n@@ -1526,7 +1526,7 @@ while (0)\n \n /* Arghh.  This is used for stuff in the constant pool; this may include\n    function addresses on the PA, which during PIC code generation must\n-   reside in the data space.  Unfortuantely, there's no way to determine\n+   reside in the data space.  Unfortunately, there's no way to determine\n    if a particular label in the constant pool refers to a function address.\n    So just force everything into the data space during PIC generation.  */\n #define SELECT_RTX_SECTION(RTX,MODE)\t\\\n@@ -1995,7 +1995,7 @@ readonly_data ()\t\t\t\t\t\t\t\\\n /* This is how to output an element of a case-vector that is relative.\n    This must be defined correctly as it is used when generating PIC code.\n \n-   I belive it safe to use the same definition as ASM_OUTPUT_ADDR_VEC_ELT\n+   I believe it safe to use the same definition as ASM_OUTPUT_ADDR_VEC_ELT\n    on the PA since ASM_OUTPUT_ADDR_VEC_ELT uses pc-relative jump instructions\n    rather than a table of absolute addresses.  */\n "}, {"sha": "16ef6637f0a10a0659348dbd50fbbf45d92c7b45", "filename": "gcc/config/pa/x-pa", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddd5a7c1808995545ad5befaa7320135e60b5d38/gcc%2Fconfig%2Fpa%2Fx-pa", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddd5a7c1808995545ad5befaa7320135e60b5d38/gcc%2Fconfig%2Fpa%2Fx-pa", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fx-pa?ref=ddd5a7c1808995545ad5befaa7320135e60b5d38", "patch": "@@ -1,4 +1,4 @@\n CC=gcc -DUSE_C_ALLOCA -D__inline= -Dbsd4_4\n-# BSD on the PA already has ANSI include files which are c++ compatable.\n+# BSD on the PA already has ANSI include files which are c++ compatible.\n INSTALL_HEADERS=\n STMP_FIXPROTO="}, {"sha": "2d9a2f4e25504d30897a52b461cb38a4bc5ab65d", "filename": "gcc/config/pdp11/pdp11.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddd5a7c1808995545ad5befaa7320135e60b5d38/gcc%2Fconfig%2Fpdp11%2Fpdp11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddd5a7c1808995545ad5befaa7320135e60b5d38/gcc%2Fconfig%2Fpdp11%2Fpdp11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpdp11%2Fpdp11.c?ref=ddd5a7c1808995545ad5befaa7320135e60b5d38", "patch": "@@ -1030,7 +1030,7 @@ notice_update_cc_on_set(exp, insn)\n     }\n     else /* if (GET_CODE (SET_DEST (exp)) == MEM)\t*/\t\n     {  \n-\t/* the last else is a bit paranoic, but since nearly all instructions \n+\t/* the last else is a bit paranoiac, but since nearly all instructions \n \t   play with condition codes, it's reasonable! */\n \n \tCC_STATUS_INIT; /* paranoia*/ "}, {"sha": "cd2b6da3c8ab2ab58166a73e739d17138539aa53", "filename": "gcc/config/pdp11/pdp11.h", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddd5a7c1808995545ad5befaa7320135e60b5d38/gcc%2Fconfig%2Fpdp11%2Fpdp11.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddd5a7c1808995545ad5befaa7320135e60b5d38/gcc%2Fconfig%2Fpdp11%2Fpdp11.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpdp11%2Fpdp11.h?ref=ddd5a7c1808995545ad5befaa7320135e60b5d38", "patch": "@@ -25,7 +25,7 @@ char *output_move_double();\n char *output_move_quad();\n char *output_block_move();\n \n-/* check whther load_fpu_reg or not */\n+/* check whether load_fpu_reg or not */\n #define LOAD_FPU_REG_P(x) ((x)>=8 && (x)<=11)\n #define NO_LOAD_FPU_REG_P(x) ((x)==12 || (x)==13)\n #define FPU_REG_P(x)\t(LOAD_FPU_REG_P(x) || NO_LOAD_FPU_REG_P(x))\n@@ -85,7 +85,7 @@ extern int target_flags;\n     { \"abshi\", 128},\t\t\\\n     { \"no-abshi\", -128},\t\\\n /* is branching expensive - on a PDP, it's actually really cheap */ \\\n-/* this is just to play aroound and check what code gcc generates */ \\\n+/* this is just to play around and check what code gcc generates */ \\\n     { \"branch-expensive\", 256}, \\\n     { \"branch-cheap\", -256},\t\\\n /* optimize for space instead of time - just in a couple of places */ \\\n@@ -170,7 +170,7 @@ extern int target_flags;\n /* Define this if most significant word of a multiword number is numbered.  */\n #define WORDS_BIG_ENDIAN 1\n \n-/* number of bits in an addressible storage unit */\n+/* number of bits in an addressable storage unit */\n #define BITS_PER_UNIT 8\n \n /* Width in bits of a \"word\", which is the contents of a machine register.\n@@ -453,8 +453,8 @@ enum reg_class { NO_REGS, MUL_REGS, GENERAL_REGS, LOAD_FPU_REGS, NO_LOAD_FPU_REG\n    operand as its first argument and the constraint letter as its\n    second operand.\n \n-   `Q'\tis for memory refereces using take more than 1 instruction.\n-   `R'\tis for memory refereces which take 1 word for the instruction.  */\n+   `Q'\tis for memory references using take more than 1 instruction.\n+   `R'\tis for memory references which take 1 word for the instruction.  */\n \n #define EXTRA_CONSTRAINT(OP,CODE)\t\t\t\t\t\\\n   ((GET_CODE (OP) != MEM) ? 0\t\t\t\t\t\t\\"}, {"sha": "615581015d454616cbae8234ed66ed1b523e2dcc", "filename": "gcc/config/pdp11/pdp11.md", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddd5a7c1808995545ad5befaa7320135e60b5d38/gcc%2Fconfig%2Fpdp11%2Fpdp11.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddd5a7c1808995545ad5befaa7320135e60b5d38/gcc%2Fconfig%2Fpdp11%2Fpdp11.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpdp11%2Fpdp11.md?ref=ddd5a7c1808995545ad5befaa7320135e60b5d38", "patch": "@@ -63,7 +63,7 @@\n ;; length default is 1 word each\n (define_attr \"length\" \"\" (const_int 1))\n \n-;; a users asm staement \n+;; a user's asm statement\n (define_asm_attributes\n   [(set_attr \"type\" \"unknown\")\n ; all bets are off how long it is - make it 256, forces long jumps \n@@ -679,7 +679,7 @@\n   [(set_attr \"length\" \"8,8,8\")])\n \n ;; maybe fiddle a bit with move_ratio, then \n-;; let contraints only accept a register ...\n+;; let constraints only accept a register ...\n \n (define_expand \"movstrhi\"\n   [(parallel [(set (mem:BLK (match_operand:BLK 0 \"general_operand\" \"=g,g\"))\n@@ -881,7 +881,7 @@\n   [(set_attr \"length\" \"6\")])\n \n ;; make float to int and vice versa \n-;; using the cc_status.flag field we coulf probably cut down\n+;; using the cc_status.flag field we could probably cut down\n ;; on seti and setl\n ;; assume that we are normally in double and integer mode -\n ;; what do pdp library routines do to fpu mode ?\n@@ -1015,7 +1015,7 @@\n \f\n ;;- subtract instructions\n ;; we don't have to care for constant second \n-;; args, since they are cononical plus:xx now!\n+;; args, since they are canonical plus:xx now!\n ;; also for minus:DF ??\n \n (define_insn \"subdf3\"\n@@ -1058,7 +1058,7 @@\n   output_asm_insn (\\\"sub %2, %0\\\", lateoperands);\n   return \\\"\\\";\n }\"\n-;; offsetable memory addresses always are expensive!!!\n+;; offsettable memory addresses always are expensive!!!\n   [(set_attr \"length\" \"3,5,6,8\")])\n \n (define_insn \"subhi3\""}, {"sha": "a26c730a1a16fb53fa9c6b31d627121c625d8e37", "filename": "gcc/config/rs6000/eabi.asm", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddd5a7c1808995545ad5befaa7320135e60b5d38/gcc%2Fconfig%2Frs6000%2Feabi.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddd5a7c1808995545ad5befaa7320135e60b5d38/gcc%2Fconfig%2Frs6000%2Feabi.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Feabi.asm?ref=ddd5a7c1808995545ad5befaa7320135e60b5d38", "patch": "@@ -53,7 +53,7 @@ __eabi:\tmflr\t0\n # Normal program, load up register 2\n \n \tlwz\t2,.Lgot(11)\t\t\t# normal GOT address\n-\tb\t__do_global_ctors\t\t# do any C++ global contstructors (which returns to caller)\n+\tb\t__do_global_ctors\t\t# do any C++ global constructors (which returns to caller)\n \n # We need to relocate the .got2 pointers.  Don't load register 2\n \n@@ -77,7 +77,7 @@ __eabi:\tmflr\t0\n # Done adjusting pointers, return\n \n .Ldone:\n-\tb\t__do_global_ctors\t\t# do any C++ global contstructors (which returns to caller)\n+\tb\t__do_global_ctors\t\t# do any C++ global constructors (which returns to caller)\n \n # Routines for saving floating point registers, called by the compiler.\n # Called with r11 pointing to the stack header word of the caller of the"}, {"sha": "bbefc031f6ba1510de32ec90416356756492835e", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddd5a7c1808995545ad5befaa7320135e60b5d38/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddd5a7c1808995545ad5befaa7320135e60b5d38/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=ddd5a7c1808995545ad5befaa7320135e60b5d38", "patch": "@@ -1577,7 +1577,7 @@ svr4_traceback (file, name, decl)\n   long alloca_reg;\t\t\t\t/* stack/frame register */\n   long fpr_max\t\t= 64 - first_fp_reg;\t/* # of floating point registers saved */\n   long gpr_max\t\t= 32 - first_reg;\t/* # of general purpose registers saved */\n-  long sp_max;\t\t\t\t\t/* 1 if the function aquires a stack frame */\n+  long sp_max;\t\t\t\t\t/* 1 if the function acquires a stack frame */\n   long lr_max;\t\t\t\t\t/* 1 if the function stores the link register */\n   long cr_max;\t\t\t\t\t/* 1 if the function has a CR save word */\n   long fpscr_max\t= 0;\t\t\t/* 1 if the function has a FPSCR save word */"}, {"sha": "7e701dbd90298748783287a34d92bda7af6c06d2", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddd5a7c1808995545ad5befaa7320135e60b5d38/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddd5a7c1808995545ad5befaa7320135e60b5d38/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=ddd5a7c1808995545ad5befaa7320135e60b5d38", "patch": "@@ -1453,7 +1453,7 @@\n \n ;; AIX architecture-independent common-mode multiply (DImode),\n ;; divide/modulus, and quotient subroutine calls.  Input operands in R3 and\n-;; R4; results in R3 and somtimes R4; link register always clobbered by bla\n+;; R4; results in R3 and sometimes R4; link register always clobbered by bla\n ;; instruction; R0 sometimes clobbered; also, MQ sometimes clobbered but\n ;; assumed unused if generating common-mode, so ignore.\n (define_insn \"mulh_call\""}, {"sha": "e31e16ed694012d42f637510c99f3ab0c4e67dc8", "filename": "gcc/config/sh/sh.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddd5a7c1808995545ad5befaa7320135e60b5d38/gcc%2Fconfig%2Fsh%2Fsh.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddd5a7c1808995545ad5befaa7320135e60b5d38/gcc%2Fconfig%2Fsh%2Fsh.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.h?ref=ddd5a7c1808995545ad5befaa7320135e60b5d38", "patch": "@@ -417,7 +417,7 @@ do {\t\t\t\t\t\t\t\t\\\n /* The SH has two sorts of general registers, R0 and the rest.  R0 can\n    be used as the destination of some of the arithmetic ops. There are\n    also some special purpose registers; the T bit register, the\n-   Procedure Return Register and the Multipy Accumulate Registers.  */\n+   Procedure Return Register and the Multiply Accumulate Registers.  */\n \n enum reg_class\n {\n@@ -705,7 +705,7 @@ extern int current_function_anonymous_args;\n /* Output assembler code for a block containing the constant parts\n    of a trampoline, leaving space for the variable parts.\n \n-   On the SH, the trapoline looks like\n+   On the SH, the trampoline looks like\n    1 0000 D301     \t\tmov.l\tl1,r3\n    2 0002 DD02     \t   \tmov.l\tl2,r13\n    3 0004 4D2B     \t\tjmp\t@r13"}, {"sha": "86cdd6b772eef84f3032f33a8266e7ab7cc53aa5", "filename": "gcc/config/sh/sh.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddd5a7c1808995545ad5befaa7320135e60b5d38/gcc%2Fconfig%2Fsh%2Fsh.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddd5a7c1808995545ad5befaa7320135e60b5d38/gcc%2Fconfig%2Fsh%2Fsh.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.md?ref=ddd5a7c1808995545ad5befaa7320135e60b5d38", "patch": "@@ -297,7 +297,7 @@\n ;; we take advantage of the library routines which don't clobber as many\n ;; registers as a normal function call would.\n \n-;; We must use a psuedo-reg forced to reg 0 in the SET_DEST rather than\n+;; We must use a pseudo-reg forced to reg 0 in the SET_DEST rather than\n ;; hard register 0.  If we used hard register 0, then the next instruction\n ;; would be a move from hard register 0 to a pseudo-reg.  If the pseudo-reg\n ;; gets allocated to a stack slot that needs its address reloaded, then"}, {"sha": "7a27742028c0e6a6bcdc3387e2f826f824bb6f93", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddd5a7c1808995545ad5befaa7320135e60b5d38/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddd5a7c1808995545ad5befaa7320135e60b5d38/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=ddd5a7c1808995545ad5befaa7320135e60b5d38", "patch": "@@ -780,7 +780,7 @@ gen_compare_reg (code, x, y)\n      we need the movcc patterns).  It is possible to provide the movcc\n      patterns by using the ldxfsr/stxfsr v9 insns.  I tried it: you need two\n      registers (say %g1,%g5) and it takes about 6 insns.  A better fix would be\n-     to tell cse that CCFPE mode registers (even pseudoes) are call\n+     to tell cse that CCFPE mode registers (even pseudos) are call\n      clobbered.  */\n \n   /* ??? This is an experiment.  Rather than making changes to cse which may\n@@ -1952,7 +1952,7 @@ output_move_quad (operands)\n       abort ();\n     }\n \n-  /* Normal case: move the four words in lowest to higest address order.  */\n+  /* Normal case: move the four words in lowest to highest address order.  */\n \n   output_asm_insn (singlemove_string (wordpart[0]), wordpart[0]);\n \n@@ -4079,7 +4079,7 @@ sparc_type_code (type)\n    (to store insns).  This is a bit excessive.  Perhaps a different\n    mechanism would be better here.\n \n-   Emit 3 FLUSH instructions to synchonize the data and instruction caches.\n+   Emit 3 FLUSH instructions to synchronize the data and instruction caches.\n \n    ??? v9: We assume the top 32 bits of function addresses are 0.  */\n \n@@ -4513,7 +4513,7 @@ sparc_flat_output_function_prologue (file, size)\n \t Don't change the order of insns emitted here without checking with\n \t the gdb folk first.  */\n \n-      /* Is the entire register save area offsetable from %sp?  */\n+      /* Is the entire register save area offsettable from %sp?  */\n       if (reg_offset < 4096 - 64 * UNITS_PER_WORD)\n \t{\n \t  if (size <= 4096)\n@@ -4663,7 +4663,7 @@ sparc_flat_output_function_epilogue (file, size)\n \t\t     fp_str, size, sp_str);\n \t}\n \n-      /* Is the entire register save area offsetable from %sp?  */\n+      /* Is the entire register save area offsettable from %sp?  */\n       if (reg_offset < 4096 - 64 * UNITS_PER_WORD)\n \t{\n \t  size1 = 0;"}, {"sha": "5594f1606f55a98e53c9d51129512f560ffa12df", "filename": "gcc/config/sparc/sparc.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddd5a7c1808995545ad5befaa7320135e60b5d38/gcc%2Fconfig%2Fsparc%2Fsparc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddd5a7c1808995545ad5befaa7320135e60b5d38/gcc%2Fconfig%2Fsparc%2Fsparc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.md?ref=ddd5a7c1808995545ad5befaa7320135e60b5d38", "patch": "@@ -5243,7 +5243,7 @@\n ;; The scan instruction searches from the most significant bit while ffs\n ;; searches from the least significant bit.  The bit index and treatment of\n ;; zero also differ.  It takes at least 7 instructions to get the proper\n-;; result.  Here is an obvious 8 instruction seequence.\n+;; result.  Here is an obvious 8 instruction sequence.\n \n (define_insn \"ffssi2\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=&r\")"}, {"sha": "47697319d69cc6304ebbdcfcf0531772d498164f", "filename": "gcc/config/vax/vax.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddd5a7c1808995545ad5befaa7320135e60b5d38/gcc%2Fconfig%2Fvax%2Fvax.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddd5a7c1808995545ad5befaa7320135e60b5d38/gcc%2Fconfig%2Fvax%2Fvax.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvax%2Fvax.md?ref=ddd5a7c1808995545ad5befaa7320135e60b5d38", "patch": "@@ -1419,7 +1419,7 @@\n \n ;; When the field position and size are constant and the destination\n ;; is a register, extv and extzv are much slower than a rotate followed\n-;; by a bicl or sign extension.  Becase we might end up choosing ext[z]v\n+;; by a bicl or sign extension.  Because we might end up choosing ext[z]v\n ;; anyway, we can't allow immediate values for the primary source operand.\n \n (define_insn \"\""}, {"sha": "08c2b5369c30d6424dd73383750fdf8a00586a3d", "filename": "gcc/cp/class.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddd5a7c1808995545ad5befaa7320135e60b5d38/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddd5a7c1808995545ad5befaa7320135e60b5d38/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=ddd5a7c1808995545ad5befaa7320135e60b5d38", "patch": "@@ -190,7 +190,7 @@ build_vbase_path (code, type, expr, path, alias_this)\n      (the static type of the complete object), and then convert back\n      to the type we want.  Until that is done, or until we can\n      recognize when that is, we cannot do the short cut logic. (mrs) */\n-  /* Do this, until we can undo any previous convertions.  See net35.C\n+  /* Do this, until we can undo any previous conversions.  See net35.C\n      for a testcase. */\n   fixed_type_p = complete_type_p (expr);\n \n@@ -2276,7 +2276,7 @@ modify_one_vtable (binfo, t, fndecl, pfn)\n \t     consideration the virtual base class pointers that we\n \t     stick in before the virtual function table pointer.\n \n-\t     Also, we want just the delta bewteen the most base class\n+\t     Also, we want just the delta between the most base class\n \t     that we derived this vfield from and us.  */\n \t  base_offset = size_binop (PLUS_EXPR,\n \t\t\t\t    get_derived_offset (binfo, DECL_CONTEXT (current_fndecl)),\n@@ -2374,7 +2374,7 @@ fixup_vtable_deltas1 (binfo, t)\n \t     consideration the virtual base class pointers that we\n \t     stick in before the virtual function table pointer.\n \n-\t     Also, we want just the delta bewteen the most base class\n+\t     Also, we want just the delta between the most base class\n \t     that we derived this vfield from and us.  */\n \t  base_offset = size_binop (PLUS_EXPR,\n \t\t\t\t    get_derived_offset (binfo, DECL_CONTEXT (fndecl)),\n@@ -2583,7 +2583,7 @@ override_one_vtable (binfo, old, t)\n \t      return;\n \t    }\n \t  {\n-\t    /* This MUST be overriden, or the class is ill-formed.  */\n+\t    /* This MUST be overridden, or the class is ill-formed.  */\n \t    /* For now, we just make it abstract.  */\n \t    tree fndecl = TREE_OPERAND (FNADDR_FROM_VTABLE_ENTRY (TREE_VALUE (virtuals)), 0);\n \t    tree vfn;\n@@ -3722,7 +3722,7 @@ finish_struct (t, list_of_fieldlists, warn_anon)\n       vbases = CLASSTYPE_VBASECLASSES (t);\n       while (vbases)\n \t{\n-\t  /* We might be able to shorten the ammount of work we do by\n+\t  /* We might be able to shorten the amount of work we do by\n \t     only doing this for vtables that come from virtual bases\n \t     that have differing offsets, but don't want to miss any\n \t     entries.  */\n@@ -4340,7 +4340,7 @@ pushclass (type, modify)\n \t{\n \t  tree item;\n \n-\t  /* Hooray, our cacheing was successful, let's just install the\n+\t  /* Hooray, we successfully cached; let's just install the\n \t     cached class_shadowed list, and walk through it to get the\n \t     IDENTIFIER_TYPE_VALUEs correct.  */\n \t  set_class_shadows (previous_class_values);"}, {"sha": "f2e3c48e64a2895a7ce4e5a7665cbacfaf8300fb", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddd5a7c1808995545ad5befaa7320135e60b5d38/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddd5a7c1808995545ad5befaa7320135e60b5d38/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=ddd5a7c1808995545ad5befaa7320135e60b5d38", "patch": "@@ -1464,7 +1464,7 @@ extern tree unknown_type_node;\n extern tree opaque_type_node, signature_type_node;\n \n /* Node for \"pointer to (virtual) function\".\n-   This may be distinct from ptr_type_node so gdb can distinuish them. */\n+   This may be distinct from ptr_type_node so gdb can distinguish them. */\n #define vfunc_ptr_type_node \\\n   (flag_vtable_thunks ? vtable_entry_type : ptr_type_node)\n \n@@ -1783,7 +1783,7 @@ extern int flag_external_templates;\n \n extern int flag_alt_external_templates;\n \n-/* Nonzero means implicit template instantatiations are emitted.  */\n+/* Nonzero means implicit template instantiations are emitted.  */\n \n extern int flag_implicit_templates;\n "}, {"sha": "e695ce23f853eacb477b919ed396da8b8a133ea0", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddd5a7c1808995545ad5befaa7320135e60b5d38/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddd5a7c1808995545ad5befaa7320135e60b5d38/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=ddd5a7c1808995545ad5befaa7320135e60b5d38", "patch": "@@ -430,7 +430,7 @@ extern int flag_huge_objects;\n \n /* Nonzero if we want to conserve space in the .o files.  We do this\n    by putting uninitialized data and runtime initialized data into\n-   .common instead of .data at the expense of not flaging multiple\n+   .common instead of .data at the expense of not flagging multiple\n    definitions.  */\n extern int flag_conserve_space;\n \n@@ -1223,9 +1223,9 @@ poplevel_class (force)\n   for (shadowed = level->shadowed; shadowed; shadowed = TREE_CHAIN (shadowed))\n     IDENTIFIER_LOCAL_VALUE (TREE_PURPOSE (shadowed)) = TREE_VALUE (shadowed);\n   /* If we're leaving a toplevel class, don't bother to do the setting\n-     of IDENTIFER_CLASS_VALUE to NULL_TREE, since first of all this slot\n+     of IDENTIFIER_CLASS_VALUE to NULL_TREE, since first of all this slot\n      shouldn't even be used when current_class_type isn't set, and second,\n-     if we don't touch it here, we're able to use the caching effect if the\n+     if we don't touch it here, we're able to use the cache effect if the\n      next time we're entering a class scope, it is the same class.  */\n   if (current_class_depth != 1 || force)\n     for (shadowed = level->class_shadowed;\n@@ -1729,7 +1729,7 @@ make_type_decl (name, type)\n #endif\n \n /* Push a tag name NAME for struct/class/union/enum type TYPE.\n-   Normally put into into the inner-most non-tag-tranparent scope,\n+   Normally put into into the inner-most non-tag-transparent scope,\n    but if GLOBALIZE is true, put it in the inner-most non-class scope.\n    The latter is needed for implicit declarations. */\n \n@@ -5160,7 +5160,7 @@ init_decl_processing ()\n     {\n       flag_inline_functions = 0;\n #if 0\n-      /* This causes uneccessary emission of inline functions.  */\n+      /* This causes unnecessary emission of inline functions.  */\n       flag_default_inline = 0;\n #endif\n     }\n@@ -11197,7 +11197,7 @@ store_parm_decls ()\n \texpand_expr (build_function_call (lookup_name (get_identifier (\"__gc_main\"), 0), NULL_TREE),\n \t\t     0, VOIDmode, 0);\n #if 0\n-      /* done at a differnet time */\n+      /* done at a different time */\n       if (flag_rtti)\n \toutput_builtin_tdesc_entries ();\n #endif"}, {"sha": "3d878a60950e29bc8c1292bbcda53330ad322967", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddd5a7c1808995545ad5befaa7320135e60b5d38/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddd5a7c1808995545ad5befaa7320135e60b5d38/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=ddd5a7c1808995545ad5befaa7320135e60b5d38", "patch": "@@ -227,7 +227,7 @@ int warn_extern_inline;\n /* Non-zero means warn when the compiler will reorder code.  */\n int warn_reorder;\n \n-/* Non-zero means warn when sysnthesis behavior differs from Cfront's.  */\n+/* Non-zero means warn when synthesis behavior differs from Cfront's.  */\n int warn_synth;\n \n /* Nonzero means `$' can be in an identifier.\n@@ -341,7 +341,7 @@ int flag_huge_objects;\n \n /* Nonzero if we want to conserve space in the .o files.  We do this\n    by putting uninitialized data and runtime initialized data into\n-   .common instead of .data at the expense of not flaging multiple\n+   .common instead of .data at the expense of not flagging multiple\n    definitions.  */\n \n int flag_conserve_space;\n@@ -985,7 +985,7 @@ grokclassfn (ctype, cname, function, flags, quals)\n \n #if 0\n       /* This code is going into the compiler, but currently, it makes\n-\t libg++/src/Interger.cc not compile.  The problem is that the nice name\n+\t libg++/src/Integer.cc not compile.  The problem is that the nice name\n \t winds up going into the symbol table, and conversion operations look\n \t for the manged name.  */\n       substitute_nice_name (function);\n@@ -1958,7 +1958,7 @@ build_push_scope (cname, name)\n     return rval;\n \n   /* We do need to push the scope in this case, since CTYPE helps\n-     determine subsequent intializers (i.e., Foo::Bar x = foo_enum_1;).  */\n+     determine subsequent initializers (i.e., Foo::Bar x = foo_enum_1;).  */\n \n   push_nested_class (ctype, 3);\n   TREE_COMPLEXITY (rval) = current_class_depth;\n@@ -3001,7 +3001,7 @@ finish_file ()\n \t      emit_note (input_filename, lineno);\n \n \t      /* 9.5p5: The initializer of a static member of a class has\n-\t\t the same acess rights as a member function.  */\n+\t\t the same access rights as a member function.  */\n \t      DECL_CLASS_CONTEXT (current_function_decl) = DECL_CONTEXT (decl);\n \t      DECL_STATIC_FUNCTION_P (current_function_decl) = 1;\n "}, {"sha": "26905e2878cb42dd2c158675c29d0d8b51f75943", "filename": "gcc/cp/error.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddd5a7c1808995545ad5befaa7320135e60b5d38/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddd5a7c1808995545ad5befaa7320135e60b5d38/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=ddd5a7c1808995545ad5befaa7320135e60b5d38", "patch": "@@ -275,7 +275,7 @@ dump_aggr_type (t, v)\n       OB_PUTC2 (':', ':');\n     }\n \n-  /* kludge around wierd behavior on g++.brendan/line1.C */\n+  /* kludge around weird behavior on g++.brendan/line1.C */\n   if (TREE_CODE (name) != IDENTIFIER_NODE)\n     name = DECL_NAME (name);\n "}, {"sha": "78127a1a08757c2c7febfbf0fefc23469e07229b", "filename": "gcc/cp/except.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddd5a7c1808995545ad5befaa7320135e60b5d38/gcc%2Fcp%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddd5a7c1808995545ad5befaa7320135e60b5d38/gcc%2Fcp%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.c?ref=ddd5a7c1808995545ad5befaa7320135e60b5d38", "patch": "@@ -175,7 +175,7 @@ It is a complete rewrite of all the EH stuff that was here before\n \tShortcomings:\n \t\t1. The type of the throw and catch must still match\n \t\t   exactly (no support yet for matching base classes)\n-\t\t2. Throw specifications of functions still doesnt't work.\n+\t\t2. Throw specifications of functions still don't work.\n \tCool Things:\n \t\t1. Destructors are called properly :-)\n \t\t2. No overhead for the non-exception thrown case.\n@@ -1282,7 +1282,7 @@ void expand_end_catch_block ()\n       /* label for the start of the protection region.  */\n       start_protect_label_rtx = pop_label_entry (&false_label_stack);\n \n-      /* Cleanup the EH paramater.  */\n+      /* Cleanup the EH parameter.  */\n       decls = getdecls ();\n       expand_end_bindings (decls, decls != NULL_TREE, 0);\n       \n@@ -1331,7 +1331,7 @@ do_unwind (throw_label)\n   params=tree_cons (NULL_TREE, integer_zero_node, NULL_TREE);\n   fcall = build_function_call (BuiltinReturnAddress, params);\n   return_val_rtx = expand_expr (fcall, NULL_RTX, SImode, 0);\n-  /* In the return, the new pc is pc+8, as the value comming in is\n+  /* In the return, the new pc is pc+8, as the value coming in is\n      really the address of the call insn, not the next insn.  */\n   emit_move_insn (return_val_rtx, plus_constant(gen_rtx (LABEL_REF,\n \t\t\t\t\t\t\t Pmode,\n@@ -1404,9 +1404,9 @@ do_unwind (throw_label)\n }\n \n /* is called from expand_exception_blocks () to generate the code in a function\n-   to \"throw\" if anything in the function needs to preform a throw.\n+   to \"throw\" if anything in the function needs to perform a throw.\n \n-   expands \"throw\" as the following psuedo code:\n+   expands \"throw\" as the following pseudo code:\n \n \tthrow:\n \t\teh = find_first_exception_match (saved_pc);"}, {"sha": "6b193a36f5259f1b87a9bd207dd8755d2982556f", "filename": "gcc/cp/init.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddd5a7c1808995545ad5befaa7320135e60b5d38/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddd5a7c1808995545ad5befaa7320135e60b5d38/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=ddd5a7c1808995545ad5befaa7320135e60b5d38", "patch": "@@ -109,7 +109,7 @@ void init_init_processing ()\n    pointer to the type of the real derived type that we want to\n    initialize for.  This is the case when addr is a pointer to a sub\n    object of a complete object, and we only want to do part of the\n-   complete object's initiailzation of vtable pointers.  This is done\n+   complete object's initialization of vtable pointers.  This is done\n    for all virtual table pointers in virtual base classes.  REAL_BINFO\n    is used to find the BINFO_VTABLE that we initialize with.  BINFO is\n    used for conversions of addr to subobjects.\n@@ -3157,7 +3157,7 @@ build_new (placement, decl, init, use_global_new)\n \t  /* If we want to check the value of the allocation expression,\n              and the number of elements in the array is not a constant, we\n              *must* expand the SAVE_EXPR for nelts in alloc_expr before we\n-             expand it in the actual initalization.  So we need to build up\n+             expand it in the actual initialization.  So we need to build up\n              an RTL_EXPR for alloc_expr.  Sigh.  */\n \t  if (alloc_expr && ! TREE_CONSTANT (nelts))\n \t    {"}, {"sha": "a80b900c18a93a4333e3b3be29fb8fc41bfe2580", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddd5a7c1808995545ad5befaa7320135e60b5d38/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddd5a7c1808995545ad5befaa7320135e60b5d38/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=ddd5a7c1808995545ad5befaa7320135e60b5d38", "patch": "@@ -2544,7 +2544,7 @@ check_newline ()\n \t\t}\n \t    }\n \n-\t  /* Do the actions implied by the preceeding numbers.  */\n+\t  /* Do the actions implied by the preceding numbers.  */\n \n \t  if (action == act_push)\n \t    {"}, {"sha": "e14f6ff89501e2b76201323d57a36f163b8df24c", "filename": "gcc/cp/search.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddd5a7c1808995545ad5befaa7320135e60b5d38/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddd5a7c1808995545ad5befaa7320135e60b5d38/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=ddd5a7c1808995545ad5befaa7320135e60b5d38", "patch": "@@ -566,7 +566,7 @@ get_base_distance_recursive (binfo, depth, is_private, basetype_path, rval,\n    Return -3 if PARENT is private to TYPE, and PROTECT is non-zero.\n \n    If PATH_PTR is non-NULL, then also build the list of types\n-   from PARENT to TYPE, with TREE_VIA_VIRUAL and TREE_VIA_PUBLIC\n+   from PARENT to TYPE, with TREE_VIA_VIRTUAL and TREE_VIA_PUBLIC\n    set.\n \n    PARENT can also be a binfo, in which case that exact parent is found\n@@ -2743,7 +2743,7 @@ fixup_virtual_upcast_offsets (real_binfo, binfo, init_self, can_elide, addr, ori\n    are initializing.\n \n    When USE_COMPUTED_OFFSETS is non-zero, we can assume that the\n-   object was laidout by a top-level contructor and the computed\n+   object was laid out by a top-level constructor and the computed\n    offsets are valid to store vtables.  When zero, we must store new\n    vtables through virtual baseclass pointers.\n "}, {"sha": "8378888f7fa47c40437629d6daffe9d324f738b2", "filename": "gcc/cp/sig.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddd5a7c1808995545ad5befaa7320135e60b5d38/gcc%2Fcp%2Fsig.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddd5a7c1808995545ad5befaa7320135e60b5d38/gcc%2Fcp%2Fsig.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsig.c?ref=ddd5a7c1808995545ad5befaa7320135e60b5d38", "patch": "@@ -239,7 +239,7 @@ build_signature_pointer_or_reference_type (to_type, constp, volatilep, refp)\n   current_obstack = ambient_obstack;\n   saveable_obstack = ambient_saveable_obstack;\n \n-  /* Ouput debug information for this type.  */\n+  /* Output debug information for this type.  */\n   rest_of_type_compilation (t, 1);\n \n   return t;"}, {"sha": "280e9dedcc744eae0f6ac07f3c128d709ea6d860", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddd5a7c1808995545ad5befaa7320135e60b5d38/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddd5a7c1808995545ad5befaa7320135e60b5d38/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=ddd5a7c1808995545ad5befaa7320135e60b5d38", "patch": "@@ -2990,7 +2990,7 @@ build_binary_op_nodefault (code, orig_op0, orig_op1, error_code)\n \t    resultcode = RDIV_EXPR;\n \t  else\n \t    /* When dividing two signed integers, we have to promote to int.\n-\t       unless we divide by a conatant != -1.  Note that default\n+\t       unless we divide by a constant != -1.  Note that default\n \t       conversion will have been performed on the operands at this\n \t       point, so we have to dig out the original type to find out if\n \t       it was unsigned.  */\n@@ -6171,7 +6171,7 @@ language_lvalue_valid (exp)\n   return 1;\n }\n \f\n-/* Get differnce in deltas for different pointer to member function\n+/* Get difference in deltas for different pointer to member function\n    types.  Return inetger_zero_node, if FROM cannot be converted to a\n    TO type.  If FORCE is true, then allow reverse conversions as well.  */\n static tree\n@@ -6253,7 +6253,7 @@ build_ptrmemfunc (type, pfn, force)\n   tree npfn;\n   tree u;\n \n-  /* Handle multiple conversions of pointer to member fucntions. */\n+  /* Handle multiple conversions of pointer to member functions. */\n   if (TYPE_PTRMEMFUNC_P (TREE_TYPE (pfn)))\n     {\n       tree ndelta, ndelta2, nindex;"}, {"sha": "f1d8ae117090680d6b6f96c7f8ca168f751ad6b0", "filename": "gcc/cp/xref.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddd5a7c1808995545ad5befaa7320135e60b5d38/gcc%2Fcp%2Fxref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddd5a7c1808995545ad5befaa7320135e60b5d38/gcc%2Fcp%2Fxref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fxref.c?ref=ddd5a7c1808995545ad5befaa7320135e60b5d38", "patch": "@@ -803,7 +803,7 @@ fixname(nam, buf)\n   return buf;\n }\n \n-/* Open file for xrefing.  */\n+/* Open file for xreffing.  */\n \n static void\n open_xref_file(file)"}, {"sha": "30c5eab7dfbef574c9e73d219fecbcbd621544d8", "filename": "gcc/cplus-dem.c", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddd5a7c1808995545ad5befaa7320135e60b5d38/gcc%2Fcplus-dem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddd5a7c1808995545ad5befaa7320135e60b5d38/gcc%2Fcplus-dem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcplus-dem.c?ref=ddd5a7c1808995545ad5befaa7320135e60b5d38", "patch": "@@ -163,11 +163,11 @@ static const struct optable\n   {\"compound\",\t  \", \",\t\t0},\t\t/* old */\n   {\"cm\",\t  \", \",\t\tDMGL_ANSI},\t/* ansi */\n   {\"cond\",\t  \"?:\",\t\t0},\t\t/* old */\n-  {\"cn\",\t  \"?:\",\t\tDMGL_ANSI},\t/* psuedo-ansi */\n+  {\"cn\",\t  \"?:\",\t\tDMGL_ANSI},\t/* pseudo-ansi */\n   {\"max\",\t  \">?\",\t\t0},\t\t/* old */\n-  {\"mx\",\t  \">?\",\t\tDMGL_ANSI},\t/* psuedo-ansi */\n+  {\"mx\",\t  \">?\",\t\tDMGL_ANSI},\t/* pseudo-ansi */\n   {\"min\",\t  \"<?\",\t\t0},\t\t/* old */\n-  {\"mn\",\t  \"<?\",\t\tDMGL_ANSI},\t/* psuedo-ansi */\n+  {\"mn\",\t  \"<?\",\t\tDMGL_ANSI},\t/* pseudo-ansi */\n   {\"nop\",\t  \"\",\t\t0},\t\t/* old (for operator=) */\n   {\"rm\",\t  \"->*\",\tDMGL_ANSI}\t/* ansi */\n };\n@@ -955,7 +955,7 @@ demangle_template (work, mangled, tname, trawname)\n \t\t    break;\n \t\t  default:\n \t\t    /* it's probably user defined type, let's assume\n-\t\t       it's integeral, it seems hard to figure out\n+\t\t       it's integral, it seems hard to figure out\n \t\t       what it really is */\n \t\t    done = is_integral = 1;\n \t\t}\n@@ -2397,10 +2397,9 @@ demangle_args (work, mangled, declp)\n             {\n               /* If we have 10 or more types we might have more than a 1 digit\n                  index so we'll have to consume the whole count here. This\n-                 will loose if the next thing is a type name preceeded by a\n+                 will lose if the next thing is a type name preceded by a\n                  count but it's impossible to demangle that case properly\n                  anyway. Eg if we already have 12 types is T12Pc \"(..., type1,\n-                 anyway. Eg if we already have 12 types is T12Pc \"(..., type1,\n                  Pc, ...)\"  or \"(..., type12, char *, ...)\" */\n               if ((t = consume_count(mangled)) == 0)\n                 {"}, {"sha": "3f3e2126cbabd1e8005a15d20f18df8230eac413", "filename": "gcc/cpplib.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddd5a7c1808995545ad5befaa7320135e60b5d38/gcc%2Fcpplib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddd5a7c1808995545ad5befaa7320135e60b5d38/gcc%2Fcpplib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.c?ref=ddd5a7c1808995545ad5befaa7320135e60b5d38", "patch": "@@ -3111,7 +3111,7 @@ get_directive_token (pfile)\n    This function expects to see \"fname\" or <fname> on the input.\n \n    The input is normally in part of the output_buffer following\n-   CPP_WRITTEN, and will get overwriiten by output_line_command.\n+   CPP_WRITTEN, and will get overwritten by output_line_command.\n    I.e. in input file specification has been popped by handle_directive.\n    This is safe. */\n \n@@ -4623,7 +4623,7 @@ cpp_get_token (pfile)\n \t  if (CPP_BUFFER (pfile)->nominal_fname && next_buf != 0)\n \t    {\n \t      /* We're about to return from an #include file.\n-\t\t Emit #line information now (as part of the CPP_POP) restult.\n+\t\t Emit #line information now (as part of the CPP_POP) result.\n \t\t But the #line refers to the file we will pop to. */\n \t      cpp_buffer *cur_buffer = CPP_BUFFER (pfile);\n \t      CPP_BUFFER (pfile) = next_buf;\n@@ -7441,7 +7441,7 @@ extern const char *const sys_errlist[];\n #else\n extern char *sys_errlist[];\n #endif\n-#else\t/* HAVE_STERRROR */\n+#else\t/* HAVE_STRERROR */\n char *strerror ();\n #endif\n #else\t/* VMS */"}, {"sha": "3036760925a283b3aa9beb88c1ee2bdb7ded7f13", "filename": "gcc/cpplib.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddd5a7c1808995545ad5befaa7320135e60b5d38/gcc%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddd5a7c1808995545ad5befaa7320135e60b5d38/gcc%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.h?ref=ddd5a7c1808995545ad5befaa7320135e60b5d38", "patch": "@@ -344,7 +344,7 @@ struct cpp_options {\n   char for_lint;\n \n   /* Nonzero means handle CHILL comment syntax\n-     and output CHILL string delimeter for __DATE___ etc. */\n+     and output CHILL string delimiter for __DATE___ etc. */\n \n   char chill;\n "}]}