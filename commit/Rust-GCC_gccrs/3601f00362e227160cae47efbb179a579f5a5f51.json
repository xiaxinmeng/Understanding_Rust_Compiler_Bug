{"sha": "3601f00362e227160cae47efbb179a579f5a5f51", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzYwMWYwMDM2MmUyMjcxNjBjYWU0N2VmYmIxNzlhNTc5ZjVhNWY1MQ==", "commit": {"author": {"name": "Kriang Lerdsuwanakij", "email": "lerdsuwa@users.sourceforge.net", "date": "2004-07-18T12:37:57Z"}, "committer": {"name": "Kriang Lerdsuwanakij", "email": "lerdsuwa@gcc.gnu.org", "date": "2004-07-18T12:37:57Z"}, "message": "re PR c++/13092 (Accepts invalid pointer-to-member conversion)\n\n\tPR c++/13092\n\t* init.c (build_offset_ref): Build SCOPE_REF with non-null\n\tTREE_TYPE for non-dependent names.\n\t* typeck.c (build_x_unary_op): Handle non-dependent SCOPE_REF.\n\t* pt.c (type_dependent_expression_p): Handle SCOPE_REF with\n\tunknown_type_node as its TREE_TYPE.\n\t* cxx-pretty_print.c (pp_cxx_unqualified_id): Handle BASELINK.\n\t* error.c (dump_decl) <SCOPE_REF case>: Use pp_expression.\n\t(dump_expr) <SCOPE_REF case>: Likewise.\n\n\t* g++.dg/template/non-dependent7.C: New test.\n\t* g++.dg/template/non-dependent8.C: Likewise.\n\t* g++.dg/template/non-dependent9.C: Likewise.\n\t* g++.dg/template/non-dependent10.C: Likewise.\n\nFrom-SVN: r84889", "tree": {"sha": "d79f98c004fe4bbd1222c18f019ba3f4157791c8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d79f98c004fe4bbd1222c18f019ba3f4157791c8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3601f00362e227160cae47efbb179a579f5a5f51", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3601f00362e227160cae47efbb179a579f5a5f51", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3601f00362e227160cae47efbb179a579f5a5f51", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3601f00362e227160cae47efbb179a579f5a5f51/comments", "author": null, "committer": null, "parents": [{"sha": "605570470c75d5ff7ef2285ef6dfe61948607379", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/605570470c75d5ff7ef2285ef6dfe61948607379", "html_url": "https://github.com/Rust-GCC/gccrs/commit/605570470c75d5ff7ef2285ef6dfe61948607379"}], "stats": {"total": 151, "additions": 144, "deletions": 7}, "files": [{"sha": "29ef50d6fdef7a9ab9b8ebca306b026cea43a289", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3601f00362e227160cae47efbb179a579f5a5f51/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3601f00362e227160cae47efbb179a579f5a5f51/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=3601f00362e227160cae47efbb179a579f5a5f51", "patch": "@@ -1,3 +1,15 @@\n+2004-07-18  Kriang Lerdsuwanakij  <lerdsuwa@users.sourceforge.net>\n+\n+\tPR c++/13092\n+\t* init.c (build_offset_ref): Build SCOPE_REF with non-null\n+\tTREE_TYPE for non-dependent names.\n+\t* typeck.c (build_x_unary_op): Handle non-dependent SCOPE_REF.\n+\t* pt.c (type_dependent_expression_p): Handle SCOPE_REF with\n+\tunknown_type_node as its TREE_TYPE.\n+\t* cxx-pretty_print.c (pp_cxx_unqualified_id): Handle BASELINK.\n+\t* error.c (dump_decl) <SCOPE_REF case>: Use pp_expression.\n+\t(dump_expr) <SCOPE_REF case>: Likewise.\n+\n 2004-07-17  Jason Merrill  <jason@redhat.com>\n \n \tPR c++/16115"}, {"sha": "1c84e161f5dd48ec9678f53086b760c88e29422b", "filename": "gcc/cp/cxx-pretty-print.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3601f00362e227160cae47efbb179a579f5a5f51/gcc%2Fcp%2Fcxx-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3601f00362e227160cae47efbb179a579f5a5f51/gcc%2Fcp%2Fcxx-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcxx-pretty-print.c?ref=3601f00362e227160cae47efbb179a579f5a5f51", "patch": "@@ -180,6 +180,10 @@ pp_cxx_unqualified_id (cxx_pretty_printer *pp, tree t)\n       pp_cxx_template_id (pp, t);\n       break;\n \n+    case BASELINK:\n+      pp_cxx_unqualified_id (pp, BASELINK_FUNCTIONS (t));\n+      break;\n+\n     case RECORD_TYPE:\n     case UNION_TYPE:\n     case ENUMERAL_TYPE:"}, {"sha": "6fa99a7a80145e583df590d2e5274f64eafd5973", "filename": "gcc/cp/error.c", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3601f00362e227160cae47efbb179a579f5a5f51/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3601f00362e227160cae47efbb179a579f5a5f51/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=3601f00362e227160cae47efbb179a579f5a5f51", "patch": "@@ -764,9 +764,7 @@ dump_decl (tree t, int flags)\n       break;\n \n     case SCOPE_REF:\n-      dump_decl (TREE_OPERAND (t, 0), flags & ~TFF_DECL_SPECIFIERS);\n-      pp_colon_colon (cxx_pp); \n-      dump_decl (TREE_OPERAND (t, 1), flags);\n+      pp_expression (cxx_pp, t);\n       break;\n \n     case ARRAY_REF:\n@@ -1708,9 +1706,7 @@ dump_expr (tree t, int flags)\n       break;\n \n     case SCOPE_REF:\n-      dump_type (TREE_OPERAND (t, 0), flags);\n-      pp_cxx_colon_colon (cxx_pp);\n-      dump_expr (TREE_OPERAND (t, 1), flags | TFF_EXPR_IN_PARENS);\n+      pp_expression (cxx_pp, t);\n       break;\n \n     case CAST_EXPR:"}, {"sha": "926dfcd9c890ea8e1ac8777458fa796a97f8f2c1", "filename": "gcc/cp/init.c", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3601f00362e227160cae47efbb179a579f5a5f51/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3601f00362e227160cae47efbb179a579f5a5f51/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=3601f00362e227160cae47efbb179a579f5a5f51", "patch": "@@ -1334,7 +1334,7 @@ build_offset_ref (tree type, tree name, bool address_p)\n   if (TREE_CODE (name) == TEMPLATE_DECL)\n     return name;\n \n-  if (processing_template_decl || uses_template_parms (type))\n+  if (dependent_type_p (type) || type_dependent_expression_p (name))\n     return build_min_nt (SCOPE_REF, type, name);\n \n   if (TREE_CODE (name) == TEMPLATE_ID_EXPR)\n@@ -1398,6 +1398,7 @@ build_offset_ref (tree type, tree name, bool address_p)\n       return error_mark_node;\n     }\n \n+  /* Set up BASEBINFO for member lookup.  */\n   decl = maybe_dummy_object (type, &basebinfo);\n \n   if (BASELINK_P (name) || DECL_P (name))\n@@ -1416,6 +1417,14 @@ build_offset_ref (tree type, tree name, bool address_p)\n       return error_mark_node;\n     }\n \n+  if (processing_template_decl)\n+    {\n+      if (TREE_CODE (orig_name) == TEMPLATE_ID_EXPR)\n+\treturn build_min (SCOPE_REF, TREE_TYPE (member), type, orig_name);\n+      else\n+\treturn build_min (SCOPE_REF, TREE_TYPE (member), type, name);\n+    }\n+\n   if (TREE_CODE (member) == TYPE_DECL)\n     {\n       TREE_USED (member) = 1;"}, {"sha": "59eb9c742d400369d85bb51b9345c0d179e28e4e", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3601f00362e227160cae47efbb179a579f5a5f51/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3601f00362e227160cae47efbb179a579f5a5f51/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=3601f00362e227160cae47efbb179a579f5a5f51", "patch": "@@ -11866,6 +11866,9 @@ type_dependent_expression_p (tree expression)\n \t  if (TREE_CODE (expression) == IDENTIFIER_NODE)\n \t    return false;\n \t}\n+      /* SCOPE_REF with non-null TREE_TYPE is always non-dependent.  */\n+      if (TREE_CODE (expression) == SCOPE_REF)\n+\treturn false;\n       \n       if (TREE_CODE (expression) == BASELINK)\n \texpression = BASELINK_FUNCTIONS (expression);"}, {"sha": "21e7fe4a4ee49980fc5d0808d4d1245adb62d4de", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3601f00362e227160cae47efbb179a579f5a5f51/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3601f00362e227160cae47efbb179a579f5a5f51/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=3601f00362e227160cae47efbb179a579f5a5f51", "patch": "@@ -3530,6 +3530,24 @@ build_x_unary_op (enum tree_code code, tree xarg)\n     {\n       if (type_dependent_expression_p (xarg))\n \treturn build_min_nt (code, xarg, NULL_TREE);\n+\n+      /* For non-dependent pointer-to-member, the SCOPE_REF will be\n+\t processed during template substitution.  Just compute the\n+\t right type here and build an ADDR_EXPR around it for\n+\t diagnostics.  */\n+      if (code == ADDR_EXPR && TREE_CODE (xarg) == SCOPE_REF)\n+\t{\n+\t  tree type;\n+\t  if (TREE_TYPE (xarg) == unknown_type_node)\n+\t    type = unknown_type_node;\n+\t  else if (TREE_CODE (TREE_TYPE (xarg)) == FUNCTION_TYPE)\n+\t    type = build_pointer_type (TREE_TYPE (xarg));\n+\t  else\n+\t    type = build_ptrmem_type (TREE_OPERAND (xarg, 0),\n+\t\t\t\t      TREE_TYPE (xarg));\n+\t  return build_min (code, type, xarg, NULL_TREE);\n+\t}\n+\n       xarg = build_non_dependent_expr (xarg);\n     }\n "}, {"sha": "d9d4e545e85c162b4e3a039ce07d6c692b40cb9d", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3601f00362e227160cae47efbb179a579f5a5f51/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3601f00362e227160cae47efbb179a579f5a5f51/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=3601f00362e227160cae47efbb179a579f5a5f51", "patch": "@@ -1,3 +1,11 @@\n+2004-07-18  Kriang Lerdsuwanakij  <lerdsuwa@users.sourceforge.net>\n+\n+\tPR c++/13092\n+\t* g++.dg/template/non-dependent7.C: New test.\n+\t* g++.dg/template/non-dependent8.C: Likewise.\n+\t* g++.dg/template/non-dependent9.C: Likewise.\n+\t* g++.dg/template/non-dependent10.C: Likewise.\n+\n 2004-07-17  Mark Mitchell  <mark@codesourcery.com>\n \n \tPR c++/16337"}, {"sha": "0adac25f08da97de9348c0a00b8fa8fb467acf51", "filename": "gcc/testsuite/g++.dg/template/non-dependent10.C", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3601f00362e227160cae47efbb179a579f5a5f51/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fnon-dependent10.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3601f00362e227160cae47efbb179a579f5a5f51/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fnon-dependent10.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fnon-dependent10.C?ref=3601f00362e227160cae47efbb179a579f5a5f51", "patch": "@@ -0,0 +1,22 @@\n+// { dg-do compile }\n+\n+// Origin: Giovanni Bajo <giovannibajo@libero.it>\n+\n+// Two-phase name lookup for address of member:\n+// Detecting overloading function error during parsing\n+\n+struct S\n+{\n+  int f(char);\n+  int f(int);\n+};\n+\n+template<int (S::*p)()>\n+struct X\n+{};\n+\n+template <class T>\n+struct Foo\n+{\n+  X<&S::f> x;\t// { dg-error \"convert|no type\" }\n+};"}, {"sha": "ee34327ad63b171b2f7ea0a36229956ffadf9ca9", "filename": "gcc/testsuite/g++.dg/template/non-dependent7.C", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3601f00362e227160cae47efbb179a579f5a5f51/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fnon-dependent7.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3601f00362e227160cae47efbb179a579f5a5f51/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fnon-dependent7.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fnon-dependent7.C?ref=3601f00362e227160cae47efbb179a579f5a5f51", "patch": "@@ -0,0 +1,22 @@\n+// { dg-do compile }\n+\n+// Origin: Giovanni Bajo <giovannibajo@libero.it>\n+\n+// PR c++/13092: ICE taking address of member which is non-dependent\n+\n+struct S\n+{\n+  int i;\n+};\n+\n+template<int S::*p>\n+struct X\n+{};\n+\n+template <class T>\n+struct Foo\n+{\n+  X<&S::i> x;\n+};\n+\n+template struct Foo<void>;"}, {"sha": "369e137317c7dc1b8d4dced6d2b1da223455bbb2", "filename": "gcc/testsuite/g++.dg/template/non-dependent8.C", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3601f00362e227160cae47efbb179a579f5a5f51/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fnon-dependent8.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3601f00362e227160cae47efbb179a579f5a5f51/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fnon-dependent8.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fnon-dependent8.C?ref=3601f00362e227160cae47efbb179a579f5a5f51", "patch": "@@ -0,0 +1,21 @@\n+// { dg-do compile }\n+\n+// Origin: Giovanni Bajo <giovannibajo@libero.it>\n+\n+// Two-phase name lookup for address of member:\n+// Detecting error during parsing\n+\n+struct S\n+{\n+  char i;\n+};\n+\n+template<int S::*p>\n+struct X\n+{};\n+\n+template <class T>\n+struct Foo\n+{\n+  X<&S::i> x;\t// { dg-error \"convert|no type\" }\n+};"}, {"sha": "c046312d558c36b89c37e291736b533d56c0a6bc", "filename": "gcc/testsuite/g++.dg/template/non-dependent9.C", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3601f00362e227160cae47efbb179a579f5a5f51/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fnon-dependent9.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3601f00362e227160cae47efbb179a579f5a5f51/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fnon-dependent9.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fnon-dependent9.C?ref=3601f00362e227160cae47efbb179a579f5a5f51", "patch": "@@ -0,0 +1,22 @@\n+// { dg-do compile }\n+\n+// Origin: Giovanni Bajo <giovannibajo@libero.it>\n+\n+// Two-phase name lookup for address of member:\n+// Overloading function\n+\n+struct S\n+{\n+  int f();\n+  int f(int);\n+};\n+\n+template<int (S::*p)()>\n+struct X\n+{};\n+\n+template <class T>\n+struct Foo\n+{\n+  X<&S::f> x;\n+};"}]}