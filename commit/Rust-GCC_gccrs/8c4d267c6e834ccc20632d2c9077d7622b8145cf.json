{"sha": "8c4d267c6e834ccc20632d2c9077d7622b8145cf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGM0ZDI2N2M2ZTgzNGNjYzIwNjMyZDJjOTA3N2Q3NjIyYjgxNDVjZg==", "commit": {"author": {"name": "Kostya Serebryany", "email": "kcc@google.com", "date": "2012-12-04T07:00:35Z"}, "committer": {"name": "Kostya Serebryany", "email": "kcc@gcc.gnu.org", "date": "2012-12-04T07:00:35Z"}, "message": "[libsanitizer] Fix PR55521 by switching libsanitizer from mach_override to mac interpose functions on darwin\n\nFrom-SVN: r194120", "tree": {"sha": "ffc5f7302fa16d7a7c53d7de59d3edaae370fbd3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ffc5f7302fa16d7a7c53d7de59d3edaae370fbd3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8c4d267c6e834ccc20632d2c9077d7622b8145cf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c4d267c6e834ccc20632d2c9077d7622b8145cf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8c4d267c6e834ccc20632d2c9077d7622b8145cf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c4d267c6e834ccc20632d2c9077d7622b8145cf/comments", "author": {"login": "kcc", "id": 1789297, "node_id": "MDQ6VXNlcjE3ODkyOTc=", "avatar_url": "https://avatars.githubusercontent.com/u/1789297?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kcc", "html_url": "https://github.com/kcc", "followers_url": "https://api.github.com/users/kcc/followers", "following_url": "https://api.github.com/users/kcc/following{/other_user}", "gists_url": "https://api.github.com/users/kcc/gists{/gist_id}", "starred_url": "https://api.github.com/users/kcc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kcc/subscriptions", "organizations_url": "https://api.github.com/users/kcc/orgs", "repos_url": "https://api.github.com/users/kcc/repos", "events_url": "https://api.github.com/users/kcc/events{/privacy}", "received_events_url": "https://api.github.com/users/kcc/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "3fa057a43770dbb23a0fb21a94cab1789df3277c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3fa057a43770dbb23a0fb21a94cab1789df3277c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3fa057a43770dbb23a0fb21a94cab1789df3277c"}], "stats": {"total": 1398, "additions": 206, "deletions": 1192}, "files": [{"sha": "d1f8c815dddba91baf560cf16b8104b227c67e34", "filename": "libsanitizer/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c4d267c6e834ccc20632d2c9077d7622b8145cf/libsanitizer%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c4d267c6e834ccc20632d2c9077d7622b8145cf/libsanitizer%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2FChangeLog?ref=8c4d267c6e834ccc20632d2c9077d7622b8145cf", "patch": "@@ -1,3 +1,29 @@\n+2012-12-04  Kostya Serebryany kcc@google.com\n+            Jack Howarth <howarth@bromo.med.uc.edu>\n+\n+\tPR 55521/sanitizer\n+\t* configure.ac: Define USING_MAC_INTERPOSE when on darwin.\n+\t* Makefile.am: Don't build interception subdir when\n+\tUSING_MAC_INTERPOSE defined.\n+\t* asan/Makefile.am: Pass -DMAC_INTERPOSE_FUNCTIONS and\n+\t-DMISSING_BLOCKS_SUPPORT when USING_MAC_INTERPOSE defined.\n+\tCompile asan_interceptors_dynamic.cc but not libinterception\n+\twhen USING_MAC_INTERPOSE defined.\n+\t* interception/Makefile.am: Remove usage of USING_MACH_OVERRIDE.\n+\t* configure: Regenerated.\n+\t* Makefile.in: Likewise.\n+\t* asan/Makefile.in: Likewise.\n+\t* interception/Makefile.in: Likewise.\n+\t* asan/asan_intercepted_functions.h: Use MISSING_BLOCKS_SUPPORT.\n+\t* asan/asan_mac.cc: Likewise.\n+\t* asan/dynamic/asan_interceptors_dynamic.cc: Migrate from llvm\n+\tand use MISSING_BLOCKS_SUPPORT.\n+\t* merge.sh: Merge lib/asan/dynamic into asan/dynamic.\n+\t* interception/mach_override/LICENSE.txt: Remove unused file.\n+\t* interception/mach_override/mach_override.c: Likewise.\n+\t* interception/mach_override/mach_override.h: Likewise.\n+\t* interception/mach_override: Remove unused directory.\n+\n 2012-11-28  H.J. Lu  <hongjiu.lu@intel.com>\n \n \t* Makefile.am (AM_MAKEFLAGS): Restore CC and CXX."}, {"sha": "9a0683920178a18b4a282a1d05735069d0fe76cc", "filename": "libsanitizer/Makefile.am", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c4d267c6e834ccc20632d2c9077d7622b8145cf/libsanitizer%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c4d267c6e834ccc20632d2c9077d7622b8145cf/libsanitizer%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2FMakefile.am?ref=8c4d267c6e834ccc20632d2c9077d7622b8145cf", "patch": "@@ -6,6 +6,10 @@ else\n SUBDIRS = interception sanitizer_common asan \n endif\n \n+if USING_MAC_INTERPOSE\n+SUBDIRS = sanitizer_common asan\n+endif\n+\n # Work around what appears to be a GNU make bug handling MAKEFLAGS\n # values defined in terms of make variables, as is the case for CC and\n # friends when we are called from the top level Makefile."}, {"sha": "4606490762ada9c0c5e6afc5945e3b70a30cc48f", "filename": "libsanitizer/Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c4d267c6e834ccc20632d2c9077d7622b8145cf/libsanitizer%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c4d267c6e834ccc20632d2c9077d7622b8145cf/libsanitizer%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2FMakefile.in?ref=8c4d267c6e834ccc20632d2c9077d7622b8145cf", "patch": "@@ -246,6 +246,7 @@ top_srcdir = @top_srcdir@\n ACLOCAL_AMFLAGS = -I .. -I ../config\n @TSAN_SUPPORTED_FALSE@SUBDIRS = interception sanitizer_common asan \n @TSAN_SUPPORTED_TRUE@SUBDIRS = interception sanitizer_common asan tsan \n+@USING_MAC_INTERPOSE_TRUE@SUBDIRS = sanitizer_common asan\n \n # Work around what appears to be a GNU make bug handling MAKEFLAGS\n # values defined in terms of make variables, as is the case for CC and"}, {"sha": "7656f9f2140d2e47eada41f07097b27cea402a56", "filename": "libsanitizer/asan/Makefile.am", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c4d267c6e834ccc20632d2c9077d7622b8145cf/libsanitizer%2Fasan%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c4d267c6e834ccc20632d2c9077d7622b8145cf/libsanitizer%2Fasan%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2FMakefile.am?ref=8c4d267c6e834ccc20632d2c9077d7622b8145cf", "patch": "@@ -4,6 +4,9 @@ AM_CPPFLAGS = -I $(top_srcdir)/include -I $(top_srcdir)\n gcc_version := $(shell cat $(top_srcdir)/../gcc/BASE-VER)\n \n DEFS = -D_GNU_SOURCE -D_DEBUG -D__STDC_CONSTANT_MACROS -D__STDC_FORMAT_MACROS -D__STDC_LIMIT_MACROS -DASAN_HAS_EXCEPTIONS=1 -DASAN_FLEXIBLE_MAPPING_AND_OFFSET=0 -DASAN_NEEDS_SEGV=1\n+if USING_MAC_INTERPOSE\n+DEFS += -DMAC_INTERPOSE_FUNCTIONS -DMISSING_BLOCKS_SUPPORT\n+endif\n AM_CXXFLAGS = -Wall -W -Wno-unused-parameter -Wwrite-strings -pedantic -Wno-long-long  -fPIC -fno-builtin -fno-exceptions -fomit-frame-pointer -funwind-tables -fvisibility=hidden -Wno-variadic-macros -Wno-c99-extensions \n ACLOCAL_AMFLAGS = -I $(top_srcdir) -I $(top_srcdir)/config\n \n@@ -29,8 +32,14 @@ asan_files = \\\n \tasan_thread.cc \\\n \tasan_win.cc\n \n-libasan_la_SOURCES = $(asan_files) \n+libasan_la_SOURCES = $(asan_files)\n+if USING_MAC_INTERPOSE\n+libasan_la_SOURCES += dynamic/asan_interceptors_dynamic.cc\n+libasan_la_LIBADD = $(top_builddir)/sanitizer_common/libsanitizer_common.la $(top_builddir)/../libstdc++-v3/src/libstdc++.la\n+else\n libasan_la_LIBADD = $(top_builddir)/sanitizer_common/libsanitizer_common.la $(top_builddir)/interception/libinterception.la $(top_builddir)/../libstdc++-v3/src/libstdc++.la\n+endif\n+\n libasan_la_LDFLAGS = -version-info `grep -v '^\\#' $(srcdir)/libtool-version` -lpthread -ldl\n \n # Work around what appears to be a GNU make bug handling MAKEFLAGS"}, {"sha": "4bd7179c9cfaaa8fb8fe49a9552b31732e5f7fef", "filename": "libsanitizer/asan/Makefile.in", "status": "modified", "additions": 33, "deletions": 9, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c4d267c6e834ccc20632d2c9077d7622b8145cf/libsanitizer%2Fasan%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c4d267c6e834ccc20632d2c9077d7622b8145cf/libsanitizer%2Fasan%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2FMakefile.in?ref=8c4d267c6e834ccc20632d2c9077d7622b8145cf", "patch": "@@ -35,6 +35,8 @@ POST_UNINSTALL = :\n build_triplet = @build@\n host_triplet = @host@\n target_triplet = @target@\n+@USING_MAC_INTERPOSE_TRUE@am__append_1 = -DMAC_INTERPOSE_FUNCTIONS -DMISSING_BLOCKS_SUPPORT\n+@USING_MAC_INTERPOSE_TRUE@am__append_2 = dynamic/asan_interceptors_dynamic.cc\n subdir = asan\n DIST_COMMON = $(srcdir)/Makefile.am $(srcdir)/Makefile.in\n ACLOCAL_M4 = $(top_srcdir)/aclocal.m4\n@@ -74,17 +76,27 @@ am__base_list = \\\n   sed '$$!N;$$!N;$$!N;$$!N;s/\\n/ /g'\n am__installdirs = \"$(DESTDIR)$(toolexeclibdir)\"\n LTLIBRARIES = $(toolexeclib_LTLIBRARIES)\n-libasan_la_DEPENDENCIES =  \\\n-\t$(top_builddir)/sanitizer_common/libsanitizer_common.la \\\n-\t$(top_builddir)/interception/libinterception.la \\\n-\t$(top_builddir)/../libstdc++-v3/src/libstdc++.la\n+@USING_MAC_INTERPOSE_FALSE@libasan_la_DEPENDENCIES = $(top_builddir)/sanitizer_common/libsanitizer_common.la \\\n+@USING_MAC_INTERPOSE_FALSE@\t$(top_builddir)/interception/libinterception.la \\\n+@USING_MAC_INTERPOSE_FALSE@\t$(top_builddir)/../libstdc++-v3/src/libstdc++.la\n+@USING_MAC_INTERPOSE_TRUE@libasan_la_DEPENDENCIES = $(top_builddir)/sanitizer_common/libsanitizer_common.la \\\n+@USING_MAC_INTERPOSE_TRUE@\t$(top_builddir)/../libstdc++-v3/src/libstdc++.la\n+am__libasan_la_SOURCES_DIST = asan_allocator.cc asan_interceptors.cc \\\n+\tasan_mac.cc asan_malloc_mac.cc asan_new_delete.cc \\\n+\tasan_posix.cc asan_rtl.cc asan_stats.cc \\\n+\tasan_thread_registry.cc asan_globals.cc asan_linux.cc \\\n+\tasan_malloc_linux.cc asan_malloc_win.cc asan_poisoning.cc \\\n+\tasan_report.cc asan_stack.cc asan_thread.cc asan_win.cc \\\n+\tdynamic/asan_interceptors_dynamic.cc\n am__objects_1 = asan_allocator.lo asan_interceptors.lo asan_mac.lo \\\n \tasan_malloc_mac.lo asan_new_delete.lo asan_posix.lo \\\n \tasan_rtl.lo asan_stats.lo asan_thread_registry.lo \\\n \tasan_globals.lo asan_linux.lo asan_malloc_linux.lo \\\n \tasan_malloc_win.lo asan_poisoning.lo asan_report.lo \\\n \tasan_stack.lo asan_thread.lo asan_win.lo\n-am_libasan_la_OBJECTS = $(am__objects_1)\n+@USING_MAC_INTERPOSE_TRUE@am__objects_2 =  \\\n+@USING_MAC_INTERPOSE_TRUE@\tasan_interceptors_dynamic.lo\n+am_libasan_la_OBJECTS = $(am__objects_1) $(am__objects_2)\n libasan_la_OBJECTS = $(am_libasan_la_OBJECTS)\n libasan_la_LINK = $(LIBTOOL) --tag=CXX $(AM_LIBTOOLFLAGS) \\\n \t$(LIBTOOLFLAGS) --mode=link $(CXXLD) $(AM_CXXFLAGS) \\\n@@ -103,7 +115,7 @@ CXXLINK = $(LIBTOOL) --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \\\n \t--mode=link $(CXXLD) $(AM_CXXFLAGS) $(CXXFLAGS) $(AM_LDFLAGS) \\\n \t$(LDFLAGS) -o $@\n SOURCES = $(libasan_la_SOURCES)\n-DIST_SOURCES = $(libasan_la_SOURCES)\n+DIST_SOURCES = $(am__libasan_la_SOURCES_DIST)\n ETAGS = etags\n CTAGS = ctags\n DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)\n@@ -127,7 +139,10 @@ CXXCPP = @CXXCPP@\n CXXDEPMODE = @CXXDEPMODE@\n CXXFLAGS = @CXXFLAGS@\n CYGPATH_W = @CYGPATH_W@\n-DEFS = -D_GNU_SOURCE -D_DEBUG -D__STDC_CONSTANT_MACROS -D__STDC_FORMAT_MACROS -D__STDC_LIMIT_MACROS -DASAN_HAS_EXCEPTIONS=1 -DASAN_FLEXIBLE_MAPPING_AND_OFFSET=0 -DASAN_NEEDS_SEGV=1\n+DEFS = -D_GNU_SOURCE -D_DEBUG -D__STDC_CONSTANT_MACROS \\\n+\t-D__STDC_FORMAT_MACROS -D__STDC_LIMIT_MACROS \\\n+\t-DASAN_HAS_EXCEPTIONS=1 -DASAN_FLEXIBLE_MAPPING_AND_OFFSET=0 \\\n+\t-DASAN_NEEDS_SEGV=1 $(am__append_1)\n DEPDIR = @DEPDIR@\n DSYMUTIL = @DSYMUTIL@\n DUMPBIN = @DUMPBIN@\n@@ -262,8 +277,9 @@ asan_files = \\\n \tasan_thread.cc \\\n \tasan_win.cc\n \n-libasan_la_SOURCES = $(asan_files) \n-libasan_la_LIBADD = $(top_builddir)/sanitizer_common/libsanitizer_common.la $(top_builddir)/interception/libinterception.la $(top_builddir)/../libstdc++-v3/src/libstdc++.la\n+libasan_la_SOURCES = $(asan_files) $(am__append_2)\n+@USING_MAC_INTERPOSE_FALSE@libasan_la_LIBADD = $(top_builddir)/sanitizer_common/libsanitizer_common.la $(top_builddir)/interception/libinterception.la $(top_builddir)/../libstdc++-v3/src/libstdc++.la\n+@USING_MAC_INTERPOSE_TRUE@libasan_la_LIBADD = $(top_builddir)/sanitizer_common/libsanitizer_common.la $(top_builddir)/../libstdc++-v3/src/libstdc++.la\n libasan_la_LDFLAGS = -version-info `grep -v '^\\#' $(srcdir)/libtool-version` -lpthread -ldl\n \n # Work around what appears to be a GNU make bug handling MAKEFLAGS\n@@ -384,6 +400,7 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_allocator.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_globals.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_interceptors.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_interceptors_dynamic.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_linux.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_mac.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_malloc_linux.Plo@am__quote@\n@@ -421,6 +438,13 @@ distclean-compile:\n @AMDEP_TRUE@@am__fastdepCXX_FALSE@\tDEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n @am__fastdepCXX_FALSE@\t$(LTCXXCOMPILE) -c -o $@ $<\n \n+asan_interceptors_dynamic.lo: dynamic/asan_interceptors_dynamic.cc\n+@am__fastdepCXX_TRUE@\t$(LIBTOOL)  --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -MT asan_interceptors_dynamic.lo -MD -MP -MF $(DEPDIR)/asan_interceptors_dynamic.Tpo -c -o asan_interceptors_dynamic.lo `test -f 'dynamic/asan_interceptors_dynamic.cc' || echo '$(srcdir)/'`dynamic/asan_interceptors_dynamic.cc\n+@am__fastdepCXX_TRUE@\t$(am__mv) $(DEPDIR)/asan_interceptors_dynamic.Tpo $(DEPDIR)/asan_interceptors_dynamic.Plo\n+@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tsource='dynamic/asan_interceptors_dynamic.cc' object='asan_interceptors_dynamic.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tDEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCXX_FALSE@\t$(LIBTOOL)  --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -c -o asan_interceptors_dynamic.lo `test -f 'dynamic/asan_interceptors_dynamic.cc' || echo '$(srcdir)/'`dynamic/asan_interceptors_dynamic.cc\n+\n mostlyclean-libtool:\n \t-rm -f *.lo\n "}, {"sha": "89f91ad6a31f8b436b9dbbe318c5c9aefbd67c0d", "filename": "libsanitizer/asan/asan_intercepted_functions.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c4d267c6e834ccc20632d2c9077d7622b8145cf/libsanitizer%2Fasan%2Fasan_intercepted_functions.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c4d267c6e834ccc20632d2c9077d7622b8145cf/libsanitizer%2Fasan%2Fasan_intercepted_functions.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_intercepted_functions.h?ref=8c4d267c6e834ccc20632d2c9077d7622b8145cf", "patch": "@@ -203,7 +203,7 @@ DECLARE_FUNCTION_AND_WRAPPER(void, __CFInitialize, void);\n DECLARE_FUNCTION_AND_WRAPPER(CFStringRef, CFStringCreateCopy,\n                              CFAllocatorRef alloc, CFStringRef str);\n DECLARE_FUNCTION_AND_WRAPPER(void, free, void* ptr);\n-#if MAC_INTERPOSE_FUNCTIONS\n+#if MAC_INTERPOSE_FUNCTIONS && !defined(MISSING_BLOCKS_SUPPORT)\n DECLARE_FUNCTION_AND_WRAPPER(void, dispatch_group_async,\n                              dispatch_group_t dg,\n                              dispatch_queue_t dq, void (^work)(void));"}, {"sha": "db0b6d30a8be9907ad41296a27f1c13a12ef7e06", "filename": "libsanitizer/asan/asan_mac.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c4d267c6e834ccc20632d2c9077d7622b8145cf/libsanitizer%2Fasan%2Fasan_mac.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c4d267c6e834ccc20632d2c9077d7622b8145cf/libsanitizer%2Fasan%2Fasan_mac.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_mac.cc?ref=8c4d267c6e834ccc20632d2c9077d7622b8145cf", "patch": "@@ -383,7 +383,7 @@ INTERCEPTOR(void, dispatch_group_async_f, dispatch_group_t group,\n                                asan_dispatch_call_block_and_release);\n }\n \n-#if MAC_INTERPOSE_FUNCTIONS\n+#if MAC_INTERPOSE_FUNCTIONS && !defined(MISSING_BLOCKS_SUPPORT)\n // dispatch_async, dispatch_group_async and others tailcall the corresponding\n // dispatch_*_f functions. When wrapping functions with mach_override, those\n // dispatch_*_f are intercepted automatically. But with dylib interposition"}, {"sha": "4f0f7bd2d5f89be400c23790b90d98ed3933d806", "filename": "libsanitizer/asan/dynamic/asan_interceptors_dynamic.cc", "status": "added", "additions": 111, "deletions": 0, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c4d267c6e834ccc20632d2c9077d7622b8145cf/libsanitizer%2Fasan%2Fdynamic%2Fasan_interceptors_dynamic.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c4d267c6e834ccc20632d2c9077d7622b8145cf/libsanitizer%2Fasan%2Fdynamic%2Fasan_interceptors_dynamic.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fdynamic%2Fasan_interceptors_dynamic.cc?ref=8c4d267c6e834ccc20632d2c9077d7622b8145cf", "patch": "@@ -0,0 +1,111 @@\n+//===-- asan_interceptors_dynamic.cc --------------------------------------===//\n+//\n+//                     The LLVM Compiler Infrastructure\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of AddressSanitizer, an address sanity checker.\n+//\n+// __DATA,__interpose section of the dynamic runtime library for Mac OS.\n+//===----------------------------------------------------------------------===//\n+\n+#if defined(__APPLE__)\n+\n+#include \"../asan_interceptors.h\"\n+#include \"../asan_intercepted_functions.h\"\n+\n+namespace __asan {\n+\n+#if !MAC_INTERPOSE_FUNCTIONS\n+# error \\\n+  Dynamic interposing library should be built with -DMAC_INTERPOSE_FUNCTIONS\n+#endif\n+\n+#define INTERPOSE_FUNCTION(function) \\\n+    { reinterpret_cast<const uptr>(WRAP(function)), \\\n+      reinterpret_cast<const uptr>(function) }\n+\n+#define INTERPOSE_FUNCTION_2(function, wrapper) \\\n+    { reinterpret_cast<const uptr>(wrapper), \\\n+      reinterpret_cast<const uptr>(function) }\n+\n+struct interpose_substitution {\n+  const uptr replacement;\n+  const uptr original;\n+};\n+\n+__attribute__((used))\n+const interpose_substitution substitutions[]\n+    __attribute__((section(\"__DATA, __interpose\"))) = {\n+  INTERPOSE_FUNCTION(strlen),\n+  INTERPOSE_FUNCTION(memcmp),\n+  INTERPOSE_FUNCTION(memcpy),\n+  INTERPOSE_FUNCTION(memmove),\n+  INTERPOSE_FUNCTION(memset),\n+  INTERPOSE_FUNCTION(strchr),\n+  INTERPOSE_FUNCTION(strcat),\n+  INTERPOSE_FUNCTION(strncat),\n+  INTERPOSE_FUNCTION(strcpy),\n+  INTERPOSE_FUNCTION(strncpy),\n+  INTERPOSE_FUNCTION(pthread_create),\n+  INTERPOSE_FUNCTION(longjmp),\n+#if ASAN_INTERCEPT__LONGJMP\n+  INTERPOSE_FUNCTION(_longjmp),\n+#endif\n+#if ASAN_INTERCEPT_SIGLONGJMP\n+  INTERPOSE_FUNCTION(siglongjmp),\n+#endif\n+#if ASAN_INTERCEPT_STRDUP\n+  INTERPOSE_FUNCTION(strdup),\n+#endif\n+#if ASAN_INTERCEPT_STRNLEN\n+  INTERPOSE_FUNCTION(strnlen),\n+#endif\n+#if ASAN_INTERCEPT_INDEX\n+  INTERPOSE_FUNCTION_2(index, WRAP(strchr)),\n+#endif\n+  INTERPOSE_FUNCTION(strcmp),\n+  INTERPOSE_FUNCTION(strncmp),\n+#if ASAN_INTERCEPT_STRCASECMP_AND_STRNCASECMP\n+  INTERPOSE_FUNCTION(strcasecmp),\n+  INTERPOSE_FUNCTION(strncasecmp),\n+#endif\n+  INTERPOSE_FUNCTION(atoi),\n+  INTERPOSE_FUNCTION(atol),\n+  INTERPOSE_FUNCTION(strtol),\n+#if ASAN_INTERCEPT_ATOLL_AND_STRTOLL\n+  INTERPOSE_FUNCTION(atoll),\n+  INTERPOSE_FUNCTION(strtoll),\n+#endif\n+#if ASAN_INTERCEPT_MLOCKX\n+  INTERPOSE_FUNCTION(mlock),\n+  INTERPOSE_FUNCTION(munlock),\n+  INTERPOSE_FUNCTION(mlockall),\n+  INTERPOSE_FUNCTION(munlockall),\n+#endif\n+  INTERPOSE_FUNCTION(dispatch_async_f),\n+  INTERPOSE_FUNCTION(dispatch_sync_f),\n+  INTERPOSE_FUNCTION(dispatch_after_f),\n+  INTERPOSE_FUNCTION(dispatch_barrier_async_f),\n+  INTERPOSE_FUNCTION(dispatch_group_async_f),\n+#ifndef MISSING_BLOCKS_SUPPORT\n+  INTERPOSE_FUNCTION(dispatch_group_async),\n+  INTERPOSE_FUNCTION(dispatch_async),\n+  INTERPOSE_FUNCTION(dispatch_after),\n+  INTERPOSE_FUNCTION(dispatch_source_set_event_handler),\n+  INTERPOSE_FUNCTION(dispatch_source_set_cancel_handler),\n+#endif\n+  INTERPOSE_FUNCTION(signal),\n+  INTERPOSE_FUNCTION(sigaction),\n+\n+  INTERPOSE_FUNCTION(__CFInitialize),\n+  INTERPOSE_FUNCTION(CFStringCreateCopy),\n+  INTERPOSE_FUNCTION(free),\n+};\n+\n+}  // namespace __asan\n+\n+#endif  // __APPLE__"}, {"sha": "1d64feff57b3191443b73715c87b6262534f0135", "filename": "libsanitizer/configure", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c4d267c6e834ccc20632d2c9077d7622b8145cf/libsanitizer%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c4d267c6e834ccc20632d2c9077d7622b8145cf/libsanitizer%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fconfigure?ref=8c4d267c6e834ccc20632d2c9077d7622b8145cf", "patch": "@@ -604,8 +604,8 @@ ac_subst_vars='am__EXEEXT_FALSE\n am__EXEEXT_TRUE\n LTLIBOBJS\n LIBOBJS\n-USING_MACH_OVERRIDE_FALSE\n-USING_MACH_OVERRIDE_TRUE\n+USING_MAC_INTERPOSE_FALSE\n+USING_MAC_INTERPOSE_TRUE\n TSAN_SUPPORTED_FALSE\n TSAN_SUPPORTED_TRUE\n enable_static\n@@ -14497,15 +14497,15 @@ fi\n \n \n case \"$host\" in\n-  *-*-darwin*) MACH_OVERRIDE=true ;;\n-  *) MACH_OVERRIDE=false ;;\n+  *-*-darwin*) MAC_INTERPOSE=true ;;\n+  *) MAC_INTERPOSE=false ;;\n esac\n- if $MACH_OVERRIDE; then\n-  USING_MACH_OVERRIDE_TRUE=\n-  USING_MACH_OVERRIDE_FALSE='#'\n+ if $MAC_INTERPOSE; then\n+  USING_MAC_INTERPOSE_TRUE=\n+  USING_MAC_INTERPOSE_FALSE='#'\n else\n-  USING_MACH_OVERRIDE_TRUE='#'\n-  USING_MACH_OVERRIDE_FALSE=\n+  USING_MAC_INTERPOSE_TRUE='#'\n+  USING_MAC_INTERPOSE_FALSE=\n fi\n \n \n@@ -14685,8 +14685,8 @@ if test -z \"${TSAN_SUPPORTED_TRUE}\" && test -z \"${TSAN_SUPPORTED_FALSE}\"; then\n   as_fn_error \"conditional \\\"TSAN_SUPPORTED\\\" was never defined.\n Usually this means the macro was only invoked conditionally.\" \"$LINENO\" 5\n fi\n-if test -z \"${USING_MACH_OVERRIDE_TRUE}\" && test -z \"${USING_MACH_OVERRIDE_FALSE}\"; then\n-  as_fn_error \"conditional \\\"USING_MACH_OVERRIDE\\\" was never defined.\n+if test -z \"${USING_MAC_INTERPOSE_TRUE}\" && test -z \"${USING_MAC_INTERPOSE_FALSE}\"; then\n+  as_fn_error \"conditional \\\"USING_MAC_INTERPOSE\\\" was never defined.\n Usually this means the macro was only invoked conditionally.\" \"$LINENO\" 5\n fi\n "}, {"sha": "49f9cd730c3f9e9296a5d7274f01b7707bfe2f18", "filename": "libsanitizer/configure.ac", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c4d267c6e834ccc20632d2c9077d7622b8145cf/libsanitizer%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c4d267c6e834ccc20632d2c9077d7622b8145cf/libsanitizer%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fconfigure.ac?ref=8c4d267c6e834ccc20632d2c9077d7622b8145cf", "patch": "@@ -81,10 +81,10 @@ unset TSAN_SUPPORTED\n AM_CONDITIONAL(TSAN_SUPPORTED, [test \"x$TSAN_SUPPORTED\" = \"xyes\"])\n \n case \"$host\" in\n-  *-*-darwin*) MACH_OVERRIDE=true ;;\n-  *) MACH_OVERRIDE=false ;;\n+  *-*-darwin*) MAC_INTERPOSE=true ;;\n+  *) MAC_INTERPOSE=false ;;\n esac\n-AM_CONDITIONAL(USING_MACH_OVERRIDE, $MACH_OVERRIDE)\n+AM_CONDITIONAL(USING_MAC_INTERPOSE, $MAC_INTERPOSE)\n \n AC_CONFIG_FILES([Makefile])\n "}, {"sha": "a815dcf67bdeccc9993cfa5d8af21d0bd2248006", "filename": "libsanitizer/interception/Makefile.am", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c4d267c6e834ccc20632d2c9077d7622b8145cf/libsanitizer%2Finterception%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c4d267c6e834ccc20632d2c9077d7622b8145cf/libsanitizer%2Finterception%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finterception%2FMakefile.am?ref=8c4d267c6e834ccc20632d2c9077d7622b8145cf", "patch": "@@ -14,11 +14,7 @@ interception_files = \\\n         interception_mac.cc \\\n         interception_win.cc\n \n-if USING_MACH_OVERRIDE\n-libinterception_la_SOURCES = $(interception_files) mach_override/mach_override.c\n-else\n libinterception_la_SOURCES = $(interception_files)\n-endif\n \n # Work around what appears to be a GNU make bug handling MAKEFLAGS\n # values defined in terms of make variables, as is the case for CC and"}, {"sha": "f86b41f5c4cdef829bd99cafc5d584a35033900d", "filename": "libsanitizer/interception/Makefile.in", "status": "modified", "additions": 4, "deletions": 49, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c4d267c6e834ccc20632d2c9077d7622b8145cf/libsanitizer%2Finterception%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c4d267c6e834ccc20632d2c9077d7622b8145cf/libsanitizer%2Finterception%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finterception%2FMakefile.in?ref=8c4d267c6e834ccc20632d2c9077d7622b8145cf", "patch": "@@ -53,29 +53,14 @@ CONFIG_CLEAN_FILES =\n CONFIG_CLEAN_VPATH_FILES =\n LTLIBRARIES = $(noinst_LTLIBRARIES)\n libinterception_la_LIBADD =\n-am__libinterception_la_SOURCES_DIST = interception_linux.cc \\\n-\tinterception_mac.cc interception_win.cc \\\n-\tmach_override/mach_override.c\n am__objects_1 = interception_linux.lo interception_mac.lo \\\n \tinterception_win.lo\n-@USING_MACH_OVERRIDE_FALSE@am_libinterception_la_OBJECTS =  \\\n-@USING_MACH_OVERRIDE_FALSE@\t$(am__objects_1)\n-@USING_MACH_OVERRIDE_TRUE@am_libinterception_la_OBJECTS =  \\\n-@USING_MACH_OVERRIDE_TRUE@\t$(am__objects_1) mach_override.lo\n+am_libinterception_la_OBJECTS = $(am__objects_1)\n libinterception_la_OBJECTS = $(am_libinterception_la_OBJECTS)\n DEFAULT_INCLUDES = -I.@am__isrc@\n depcomp = $(SHELL) $(top_srcdir)/../depcomp\n am__depfiles_maybe = depfiles\n am__mv = mv -f\n-COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \\\n-\t$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)\n-LTCOMPILE = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \\\n-\t--mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \\\n-\t$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)\n-CCLD = $(CC)\n-LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \\\n-\t--mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) \\\n-\t$(LDFLAGS) -o $@\n CXXCOMPILE = $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \\\n \t$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS)\n LTCXXCOMPILE = $(LIBTOOL) --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \\\n@@ -86,7 +71,7 @@ CXXLINK = $(LIBTOOL) --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \\\n \t--mode=link $(CXXLD) $(AM_CXXFLAGS) $(CXXFLAGS) $(AM_LDFLAGS) \\\n \t$(LDFLAGS) -o $@\n SOURCES = $(libinterception_la_SOURCES)\n-DIST_SOURCES = $(am__libinterception_la_SOURCES_DIST)\n+DIST_SOURCES = $(libinterception_la_SOURCES)\n ETAGS = etags\n CTAGS = ctags\n DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)\n@@ -230,8 +215,7 @@ interception_files = \\\n         interception_mac.cc \\\n         interception_win.cc\n \n-@USING_MACH_OVERRIDE_FALSE@libinterception_la_SOURCES = $(interception_files)\n-@USING_MACH_OVERRIDE_TRUE@libinterception_la_SOURCES = $(interception_files) mach_override/mach_override.c\n+libinterception_la_SOURCES = $(interception_files)\n \n # Work around what appears to be a GNU make bug handling MAKEFLAGS\n # values defined in terms of make variables, as is the case for CC and\n@@ -277,7 +261,7 @@ MAKEOVERRIDES =\n all: all-am\n \n .SUFFIXES:\n-.SUFFIXES: .c .cc .lo .o .obj\n+.SUFFIXES: .cc .lo .o .obj\n $(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)\n \t@for dep in $?; do \\\n \t  case '$(am__configure_deps)' in \\\n@@ -329,35 +313,6 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/interception_linux.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/interception_mac.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/interception_win.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/mach_override.Plo@am__quote@\n-\n-.c.o:\n-@am__fastdepCC_TRUE@\t$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<\n-@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$<' object='$@' libtool=no @AMDEPBACKSLASH@\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n-@am__fastdepCC_FALSE@\t$(COMPILE) -c $<\n-\n-.c.obj:\n-@am__fastdepCC_TRUE@\t$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `$(CYGPATH_W) '$<'`\n-@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$<' object='$@' libtool=no @AMDEPBACKSLASH@\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n-@am__fastdepCC_FALSE@\t$(COMPILE) -c `$(CYGPATH_W) '$<'`\n-\n-.c.lo:\n-@am__fastdepCC_TRUE@\t$(LTCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<\n-@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Plo\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$<' object='$@' libtool=yes @AMDEPBACKSLASH@\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n-@am__fastdepCC_FALSE@\t$(LTCOMPILE) -c -o $@ $<\n-\n-mach_override.lo: mach_override/mach_override.c\n-@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT mach_override.lo -MD -MP -MF $(DEPDIR)/mach_override.Tpo -c -o mach_override.lo `test -f 'mach_override/mach_override.c' || echo '$(srcdir)/'`mach_override/mach_override.c\n-@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/mach_override.Tpo $(DEPDIR)/mach_override.Plo\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='mach_override/mach_override.c' object='mach_override.lo' libtool=yes @AMDEPBACKSLASH@\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n-@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o mach_override.lo `test -f 'mach_override/mach_override.c' || echo '$(srcdir)/'`mach_override/mach_override.c\n \n .cc.o:\n @am__fastdepCXX_TRUE@\t$(CXXCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<"}, {"sha": "9446965176cedef047f0930dfe550db4ba2389fb", "filename": "libsanitizer/interception/mach_override/LICENSE.txt", "status": "removed", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fa057a43770dbb23a0fb21a94cab1789df3277c/libsanitizer%2Finterception%2Fmach_override%2FLICENSE.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fa057a43770dbb23a0fb21a94cab1789df3277c/libsanitizer%2Finterception%2Fmach_override%2FLICENSE.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finterception%2Fmach_override%2FLICENSE.txt?ref=3fa057a43770dbb23a0fb21a94cab1789df3277c", "patch": "@@ -1,3 +0,0 @@\n-Copyright (c) 2003-2009 Jonathan 'Wolf' Rentzsch: <http://rentzsch.com>\n-Some rights reserved: <http://opensource.org/licenses/mit-license.php>\n-"}, {"sha": "7511a7bebb82075a17c360cee7591b0727fdf4d7", "filename": "libsanitizer/interception/mach_override/mach_override.c", "status": "removed", "additions": 0, "deletions": 970, "changes": 970, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fa057a43770dbb23a0fb21a94cab1789df3277c/libsanitizer%2Finterception%2Fmach_override%2Fmach_override.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fa057a43770dbb23a0fb21a94cab1789df3277c/libsanitizer%2Finterception%2Fmach_override%2Fmach_override.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finterception%2Fmach_override%2Fmach_override.c?ref=3fa057a43770dbb23a0fb21a94cab1789df3277c", "patch": "@@ -1,970 +0,0 @@\n-/*******************************************************************************\n-\tmach_override.c\n-\t\tCopyright (c) 2003-2009 Jonathan 'Wolf' Rentzsch: <http://rentzsch.com>\n-\t\tSome rights reserved: <http://opensource.org/licenses/mit-license.php>\n-\n-\t***************************************************************************/\n-#ifdef __APPLE__\n-\n-#include \"mach_override.h\"\n-\n-#include <mach-o/dyld.h>\n-#include <mach/mach_host.h>\n-#include <mach/mach_init.h>\n-#include <mach/vm_map.h>\n-#include <sys/mman.h>\n-\n-#include <CoreServices/CoreServices.h>\n-\n-//#define DEBUG_DISASM 1\n-#undef DEBUG_DISASM\n-\n-/**************************\n-*\t\n-*\tConstants\n-*\t\n-**************************/\n-#pragma mark\t-\n-#pragma mark\t(Constants)\n-\n-#if defined(__ppc__) || defined(__POWERPC__)\n-\n-static\n-long kIslandTemplate[] = {\n-\t0x9001FFFC,\t//\tstw\t\tr0,-4(SP)\n-\t0x3C00DEAD,\t//\tlis\t\tr0,0xDEAD\n-\t0x6000BEEF,\t//\tori\t\tr0,r0,0xBEEF\n-\t0x7C0903A6,\t//\tmtctr\tr0\n-\t0x8001FFFC,\t//\tlwz\t\tr0,-4(SP)\n-\t0x60000000,\t//\tnop\t\t; optionally replaced\n-\t0x4E800420 \t//\tbctr\n-};\n-\n-#define kAddressHi\t\t\t3\n-#define kAddressLo\t\t\t5\n-#define kInstructionHi\t\t10\n-#define kInstructionLo\t\t11\n-\n-#elif defined(__i386__) \n-\n-#define kOriginalInstructionsSize 16\n-\n-static\n-unsigned char kIslandTemplate[] = {\n-\t// kOriginalInstructionsSize nop instructions so that we \n-\t// should have enough space to host original instructions \n-\t0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, \n-\t0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90,\n-\t// Now the real jump instruction\n-\t0xE9, 0xEF, 0xBE, 0xAD, 0xDE\n-};\n-\n-#define kInstructions\t0\n-#define kJumpAddress    kInstructions + kOriginalInstructionsSize + 1\n-#elif defined(__x86_64__)\n-\n-#define kOriginalInstructionsSize 32\n-\n-#define kJumpAddress    kOriginalInstructionsSize + 6\n-\n-static\n-unsigned char kIslandTemplate[] = {\n-\t// kOriginalInstructionsSize nop instructions so that we \n-\t// should have enough space to host original instructions \n-\t0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, \n-\t0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90,\n-\t0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, \n-\t0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90,\n-\t// Now the real jump instruction\n-\t0xFF, 0x25, 0x00, 0x00, 0x00, 0x00,\n-        0x00, 0x00, 0x00, 0x00,\n-        0x00, 0x00, 0x00, 0x00\n-};\n-\n-#endif\n-\n-#define\tkAllocateHigh\t\t1\n-#define\tkAllocateNormal\t\t0\n-\n-/**************************\n-*\t\n-*\tData Types\n-*\t\n-**************************/\n-#pragma mark\t-\n-#pragma mark\t(Data Types)\n-\n-typedef\tstruct\t{\n-\tchar\tinstructions[sizeof(kIslandTemplate)];\n-\tint\t\tallocatedHigh;\n-}\tBranchIsland;\n-\n-/**************************\n-*\t\n-*\tFunky Protos\n-*\t\n-**************************/\n-#pragma mark\t-\n-#pragma mark\t(Funky Protos)\n-\n-\n-\tstatic mach_error_t\n-allocateBranchIsland(\n-\t\tBranchIsland\t**island,\n-\t\tint\t\t\t\tallocateHigh,\n-\t\tvoid *originalFunctionAddress);\n-\n-\tstatic mach_error_t\n-freeBranchIsland(\n-\t\tBranchIsland\t*island );\n-\n-\tstatic mach_error_t\n-defaultIslandMalloc(\n-\t  void **ptr, size_t unused_size, void *hint);\n-\n-\tstatic mach_error_t\n-defaultIslandFree(\n-   \tvoid *ptr);\n-\n-#if defined(__ppc__) || defined(__POWERPC__)\n-\tstatic mach_error_t\n-setBranchIslandTarget(\n-\t\tBranchIsland\t*island,\n-\t\tconst void\t\t*branchTo,\n-\t\tlong\t\t\tinstruction );\n-#endif \n-\n-#if defined(__i386__) || defined(__x86_64__)\n-static mach_error_t\n-setBranchIslandTarget_i386(\n-\t\t\t\t\t\t   BranchIsland\t*island,\n-\t\t\t\t\t\t   const void\t\t*branchTo,\n-\t\t\t\t\t\t   char*\t\t\tinstructions );\n-// Can't be made static because there's no C implementation for atomic_mov64\n-// on i386.\n-void \n-atomic_mov64(\n-\t\tuint64_t *targetAddress,\n-\t\tuint64_t value ) __attribute__((visibility(\"hidden\")));\n-\n-\tstatic Boolean \n-eatKnownInstructions( \n-\tunsigned char\t*code, \n-\tuint64_t\t\t*newInstruction,\n-\tint\t\t\t\t*howManyEaten, \n-\tchar\t\t\t*originalInstructions,\n-\tint\t\t\t\t*originalInstructionCount, \n-\tuint8_t\t\t\t*originalInstructionSizes );\n-\n-\tstatic void\n-fixupInstructions(\n-    void\t\t*originalFunction,\n-    void\t\t*escapeIsland,\n-    void\t\t*instructionsToFix,\n-\tint\t\t\tinstructionCount,\n-\tuint8_t\t\t*instructionSizes );\n-\n-#ifdef DEBUG_DISASM\n-\tstatic void\n-dump16Bytes(\n-\tvoid\t*ptr);\n-#endif  // DEBUG_DISASM\n-#endif\n-\n-/*******************************************************************************\n-*\t\n-*\tInterface\n-*\t\n-*******************************************************************************/\n-#pragma mark\t-\n-#pragma mark\t(Interface)\n-\n-#if defined(__i386__) || defined(__x86_64__)\n-static mach_error_t makeIslandExecutable(void *address) {\n-\tmach_error_t err = err_none;\n-    vm_size_t pageSize;\n-    host_page_size( mach_host_self(), &pageSize );\n-    uintptr_t page = (uintptr_t)address & ~(uintptr_t)(pageSize-1);\n-    int e = err_none;\n-    e |= mprotect((void *)page, pageSize, PROT_EXEC | PROT_READ | PROT_WRITE);\n-    e |= msync((void *)page, pageSize, MS_INVALIDATE );\n-    if (e) {\n-        err = err_cannot_override;\n-    }\n-    return err;\n-}\n-#endif\n-\n-\t\tstatic mach_error_t\n-defaultIslandMalloc(\n-\tvoid **ptr, size_t unused_size, void *hint) {\n-  return allocateBranchIsland( (BranchIsland**)ptr, kAllocateHigh, hint );\n-}\n-\t\tstatic mach_error_t\n-defaultIslandFree(\n-\tvoid *ptr) {\n-\treturn freeBranchIsland(ptr);\n-}\n-\n-    mach_error_t\n-__asan_mach_override_ptr(\n-\tvoid *originalFunctionAddress,\n-    const void *overrideFunctionAddress,\n-    void **originalFunctionReentryIsland )\n-{\n-  return __asan_mach_override_ptr_custom(originalFunctionAddress,\n-\t\toverrideFunctionAddress,\n-\t\toriginalFunctionReentryIsland,\n-\t\tdefaultIslandMalloc,\n-\t\tdefaultIslandFree);\n-}\n-\n-    mach_error_t\n-__asan_mach_override_ptr_custom(\n-\tvoid *originalFunctionAddress,\n-    const void *overrideFunctionAddress,\n-    void **originalFunctionReentryIsland,\n-\t\tisland_malloc *alloc,\n-\t\tisland_free *dealloc)\n-{\n-\tassert( originalFunctionAddress );\n-\tassert( overrideFunctionAddress );\n-\t\n-\t// this addresses overriding such functions as AudioOutputUnitStart()\n-\t// test with modified DefaultOutputUnit project\n-#if defined(__x86_64__)\n-    for(;;){\n-        if(*(uint16_t*)originalFunctionAddress==0x25FF)    // jmp qword near [rip+0x????????]\n-            originalFunctionAddress=*(void**)((char*)originalFunctionAddress+6+*(int32_t *)((uint16_t*)originalFunctionAddress+1));\n-        else break;\n-    }\n-#elif defined(__i386__)\n-    for(;;){\n-        if(*(uint16_t*)originalFunctionAddress==0x25FF)    // jmp *0x????????\n-            originalFunctionAddress=**(void***)((uint16_t*)originalFunctionAddress+1);\n-        else break;\n-    }\n-#endif\n-#ifdef DEBUG_DISASM\n-  {\n-    fprintf(stderr, \"Replacing function at %p\\n\", originalFunctionAddress);\n-    fprintf(stderr, \"First 16 bytes of the function: \");\n-    unsigned char *orig = (unsigned char *)originalFunctionAddress;\n-    int i;\n-    for (i = 0; i < 16; i++) {\n-       fprintf(stderr, \"%x \", (unsigned int) orig[i]);\n-    }\n-    fprintf(stderr, \"\\n\");\n-    fprintf(stderr, \n-            \"To disassemble, save the following function as disas.c\"\n-            \" and run:\\n  gcc -c disas.c && gobjdump -d disas.o\\n\"\n-            \"The first 16 bytes of the original function will start\"\n-            \" after four nop instructions.\\n\");\n-    fprintf(stderr, \"\\nvoid foo() {\\n  asm volatile(\\\"nop;nop;nop;nop;\\\");\\n\");\n-    int j = 0;\n-    for (j = 0; j < 2; j++) {\n-      fprintf(stderr, \"  asm volatile(\\\".byte \");\n-      for (i = 8 * j; i < 8 * (j+1) - 1; i++) {\n-        fprintf(stderr, \"0x%x, \", (unsigned int) orig[i]);\n-      }\n-      fprintf(stderr, \"0x%x;\\\");\\n\", (unsigned int) orig[8 * (j+1) - 1]);\n-    }\n-    fprintf(stderr, \"}\\n\\n\");\n-  }\n-#endif\n-\n-\tlong\t*originalFunctionPtr = (long*) originalFunctionAddress;\n-\tmach_error_t\terr = err_none;\n-\t\n-#if defined(__ppc__) || defined(__POWERPC__)\n-\t//\tEnsure first instruction isn't 'mfctr'.\n-\t#define\tkMFCTRMask\t\t\t0xfc1fffff\n-\t#define\tkMFCTRInstruction\t0x7c0903a6\n-\t\n-\tlong\toriginalInstruction = *originalFunctionPtr;\n-\tif( !err && ((originalInstruction & kMFCTRMask) == kMFCTRInstruction) )\n-\t\terr = err_cannot_override;\n-#elif defined(__i386__) || defined(__x86_64__)\n-\tint eatenCount = 0;\n-\tint originalInstructionCount = 0;\n-\tchar originalInstructions[kOriginalInstructionsSize];\n-\tuint8_t originalInstructionSizes[kOriginalInstructionsSize];\n-\tuint64_t jumpRelativeInstruction = 0; // JMP\n-\n-\tBoolean overridePossible = eatKnownInstructions ((unsigned char *)originalFunctionPtr, \n-\t\t\t\t\t\t\t\t\t\t&jumpRelativeInstruction, &eatenCount, \n-\t\t\t\t\t\t\t\t\t\toriginalInstructions, &originalInstructionCount, \n-\t\t\t\t\t\t\t\t\t\toriginalInstructionSizes );\n-#ifdef DEBUG_DISASM\n-  if (!overridePossible) fprintf(stderr, \"overridePossible = false @%d\\n\", __LINE__);\n-#endif\n-\tif (eatenCount > kOriginalInstructionsSize) {\n-#ifdef DEBUG_DISASM\n-\t\tfprintf(stderr, \"Too many instructions eaten\\n\");\n-#endif    \n-\t\toverridePossible = false;\n-\t}\n-\tif (!overridePossible) err = err_cannot_override;\n-\tif (err) fprintf(stderr, \"err = %x %s:%d\\n\", err, __FILE__, __LINE__);\n-#endif\n-\t\n-\t//\tMake the original function implementation writable.\n-\tif( !err ) {\n-\t\terr = vm_protect( mach_task_self(),\n-\t\t\t\t(vm_address_t) originalFunctionPtr, 8, false,\n-\t\t\t\t(VM_PROT_ALL | VM_PROT_COPY) );\n-\t\tif( err )\n-\t\t\terr = vm_protect( mach_task_self(),\n-\t\t\t\t\t(vm_address_t) originalFunctionPtr, 8, false,\n-\t\t\t\t\t(VM_PROT_DEFAULT | VM_PROT_COPY) );\n-\t}\n-\tif (err) fprintf(stderr, \"err = %x %s:%d\\n\", err, __FILE__, __LINE__);\n-\t\n-\t//\tAllocate and target the escape island to the overriding function.\n-\tBranchIsland\t*escapeIsland = NULL;\n-\tif( !err )\n-\t\terr = alloc( (void**)&escapeIsland, sizeof(BranchIsland), originalFunctionAddress );\n-\tif ( err ) fprintf(stderr, \"err = %x %s:%d\\n\", err, __FILE__, __LINE__);\n-\t\n-#if defined(__ppc__) || defined(__POWERPC__)\n-\tif( !err )\n-\t\terr = setBranchIslandTarget( escapeIsland, overrideFunctionAddress, 0 );\n-\t\n-\t//\tBuild the branch absolute instruction to the escape island.\n-\tlong\tbranchAbsoluteInstruction = 0; // Set to 0 just to silence warning.\n-\tif( !err ) {\n-\t\tlong escapeIslandAddress = ((long) escapeIsland) & 0x3FFFFFF;\n-\t\tbranchAbsoluteInstruction = 0x48000002 | escapeIslandAddress;\n-\t}\n-#elif defined(__i386__) || defined(__x86_64__)\n-        if (err) fprintf(stderr, \"err = %x %s:%d\\n\", err, __FILE__, __LINE__);\n-\n-\tif( !err )\n-\t\terr = setBranchIslandTarget_i386( escapeIsland, overrideFunctionAddress, 0 );\n- \n-\tif (err) fprintf(stderr, \"err = %x %s:%d\\n\", err, __FILE__, __LINE__);\n-\t// Build the jump relative instruction to the escape island\n-#endif\n-\n-\n-#if defined(__i386__) || defined(__x86_64__)\n-\tif (!err) {\n-\t\tuint32_t addressOffset = ((char*)escapeIsland - (char*)originalFunctionPtr - 5);\n-\t\taddressOffset = OSSwapInt32(addressOffset);\n-\t\t\n-\t\tjumpRelativeInstruction |= 0xE900000000000000LL; \n-\t\tjumpRelativeInstruction |= ((uint64_t)addressOffset & 0xffffffff) << 24;\n-\t\tjumpRelativeInstruction = OSSwapInt64(jumpRelativeInstruction);\t\t\n-\t}\n-#endif\n-\t\n-\t//\tOptionally allocate & return the reentry island. This may contain relocated\n-\t//  jmp instructions and so has all the same addressing reachability requirements\n-\t//  the escape island has to the original function, except the escape island is\n-\t//  technically our original function.\n-\tBranchIsland\t*reentryIsland = NULL;\n-\tif( !err && originalFunctionReentryIsland ) {\n-\t\terr = alloc( (void**)&reentryIsland, sizeof(BranchIsland), escapeIsland);\n-\t\tif( !err )\n-\t\t\t*originalFunctionReentryIsland = reentryIsland;\n-\t}\n-\t\n-#if defined(__ppc__) || defined(__POWERPC__)\t\n-\t//\tAtomically:\n-\t//\to If the reentry island was allocated:\n-\t//\t\to Insert the original instruction into the reentry island.\n-\t//\t\to Target the reentry island at the 2nd instruction of the\n-\t//\t\t  original function.\n-\t//\to Replace the original instruction with the branch absolute.\n-\tif( !err ) {\n-\t\tint escapeIslandEngaged = false;\n-\t\tdo {\n-\t\t\tif( reentryIsland )\n-\t\t\t\terr = setBranchIslandTarget( reentryIsland,\n-\t\t\t\t\t\t(void*) (originalFunctionPtr+1), originalInstruction );\n-\t\t\tif( !err ) {\n-\t\t\t\tescapeIslandEngaged = CompareAndSwap( originalInstruction,\n-\t\t\t\t\t\t\t\t\t\tbranchAbsoluteInstruction,\n-\t\t\t\t\t\t\t\t\t\t(UInt32*)originalFunctionPtr );\n-\t\t\t\tif( !escapeIslandEngaged ) {\n-\t\t\t\t\t//\tSomeone replaced the instruction out from under us,\n-\t\t\t\t\t//\tre-read the instruction, make sure it's still not\n-\t\t\t\t\t//\t'mfctr' and try again.\n-\t\t\t\t\toriginalInstruction = *originalFunctionPtr;\n-\t\t\t\t\tif( (originalInstruction & kMFCTRMask) == kMFCTRInstruction)\n-\t\t\t\t\t\terr = err_cannot_override;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t} while( !err && !escapeIslandEngaged );\n-\t}\n-#elif defined(__i386__) || defined(__x86_64__)\n-\t// Atomically:\n-\t//\to If the reentry island was allocated:\n-\t//\t\to Insert the original instructions into the reentry island.\n-\t//\t\to Target the reentry island at the first non-replaced \n-\t//        instruction of the original function.\n-\t//\to Replace the original first instructions with the jump relative.\n-\t//\n-\t// Note that on i386, we do not support someone else changing the code under our feet\n-\tif ( !err ) {\n-\t\tfixupInstructions(originalFunctionPtr, reentryIsland, originalInstructions,\n-\t\t\t\t\toriginalInstructionCount, originalInstructionSizes );\n-\t\n-\t\tif( reentryIsland )\n-\t\t\terr = setBranchIslandTarget_i386( reentryIsland,\n-\t\t\t\t\t\t\t\t\t\t (void*) ((char *)originalFunctionPtr+eatenCount), originalInstructions );\n-\t\t// try making islands executable before planting the jmp\n-#if defined(__x86_64__) || defined(__i386__)\n-        if( !err )\n-            err = makeIslandExecutable(escapeIsland);\n-        if( !err && reentryIsland )\n-            err = makeIslandExecutable(reentryIsland);\n-#endif\n-\t\tif ( !err )\n-\t\t\tatomic_mov64((uint64_t *)originalFunctionPtr, jumpRelativeInstruction);\n-\t}\n-#endif\n-\t\n-\t//\tClean up on error.\n-\tif( err ) {\n-\t\tif( reentryIsland )\n-\t\t\tdealloc( reentryIsland );\n-\t\tif( escapeIsland )\n-\t\t\tdealloc( escapeIsland );\n-\t}\n-\n-#ifdef DEBUG_DISASM\n-  {\n-    fprintf(stderr, \"First 16 bytes of the function after slicing: \");\n-    unsigned char *orig = (unsigned char *)originalFunctionAddress;\n-    int i;\n-    for (i = 0; i < 16; i++) {\n-       fprintf(stderr, \"%x \", (unsigned int) orig[i]);\n-    }\n-    fprintf(stderr, \"\\n\");\n-  }\n-#endif\n-\treturn err;\n-}\n-\n-/*******************************************************************************\n-*\t\n-*\tImplementation\n-*\t\n-*******************************************************************************/\n-#pragma mark\t-\n-#pragma mark\t(Implementation)\n-\n-/***************************************************************************//**\n-\tImplementation: Allocates memory for a branch island.\n-\t\n-\t@param\tisland\t\t\t<-\tThe allocated island.\n-\t@param\tallocateHigh\t->\tWhether to allocate the island at the end of the\n-\t\t\t\t\t\t\t\taddress space (for use with the branch absolute\n-\t\t\t\t\t\t\t\tinstruction).\n-\t@result\t\t\t\t\t<-\tmach_error_t\n-\n-\t***************************************************************************/\n-\n-\tstatic mach_error_t\n-allocateBranchIsland(\n-\t\tBranchIsland\t**island,\n-\t\tint\t\t\t\tallocateHigh,\n-\t\tvoid *originalFunctionAddress)\n-{\n-\tassert( island );\n-\t\n-\tmach_error_t\terr = err_none;\n-\t\n-\tif( allocateHigh ) {\n-\t\tvm_size_t pageSize;\n-\t\terr = host_page_size( mach_host_self(), &pageSize );\n-\t\tif( !err ) {\n-\t\t\tassert( sizeof( BranchIsland ) <= pageSize );\n-#if defined(__ppc__) || defined(__POWERPC__)\n-\t\t\tvm_address_t first = 0xfeffffff;\n-\t\t\tvm_address_t last = 0xfe000000 + pageSize;\n-#elif defined(__x86_64__)\n-\t\t\tvm_address_t first = ((uint64_t)originalFunctionAddress & ~(uint64_t)(((uint64_t)1 << 31) - 1)) | ((uint64_t)1 << 31); // start in the middle of the page?\n-\t\t\tvm_address_t last = 0x0;\n-#else\n-\t\t\tvm_address_t first = 0xffc00000;\n-\t\t\tvm_address_t last = 0xfffe0000;\n-#endif\n-\n-\t\t\tvm_address_t page = first;\n-\t\t\tint allocated = 0;\n-\t\t\tvm_map_t task_self = mach_task_self();\n-\t\t\t\n-\t\t\twhile( !err && !allocated && page != last ) {\n-\n-\t\t\t\terr = vm_allocate( task_self, &page, pageSize, 0 );\n-\t\t\t\tif( err == err_none )\n-\t\t\t\t\tallocated = 1;\n-\t\t\t\telse if( err == KERN_NO_SPACE ) {\n-#if defined(__x86_64__)\n-\t\t\t\t\tpage -= pageSize;\n-#else\n-\t\t\t\t\tpage += pageSize;\n-#endif\n-\t\t\t\t\terr = err_none;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tif( allocated )\n-\t\t\t\t*island = (BranchIsland*) page;\n-\t\t\telse if( !allocated && !err )\n-\t\t\t\terr = KERN_NO_SPACE;\n-\t\t}\n-\t} else {\n-\t\tvoid *block = malloc( sizeof( BranchIsland ) );\n-\t\tif( block )\n-\t\t\t*island = block;\n-\t\telse\n-\t\t\terr = KERN_NO_SPACE;\n-\t}\n-\tif( !err )\n-\t\t(**island).allocatedHigh = allocateHigh;\n-\t\n-\treturn err;\n-}\n-\n-/***************************************************************************//**\n-\tImplementation: Deallocates memory for a branch island.\n-\t\n-\t@param\tisland\t->\tThe island to deallocate.\n-\t@result\t\t\t<-\tmach_error_t\n-\n-\t***************************************************************************/\n-\n-\tstatic mach_error_t\n-freeBranchIsland(\n-\t\tBranchIsland\t*island )\n-{\n-\tassert( island );\n-\tassert( (*(long*)&island->instructions[0]) == kIslandTemplate[0] );\n-\tassert( island->allocatedHigh );\n-\t\n-\tmach_error_t\terr = err_none;\n-\t\n-\tif( island->allocatedHigh ) {\n-\t\tvm_size_t pageSize;\n-\t\terr = host_page_size( mach_host_self(), &pageSize );\n-\t\tif( !err ) {\n-\t\t\tassert( sizeof( BranchIsland ) <= pageSize );\n-\t\t\terr = vm_deallocate(\n-\t\t\t\t\tmach_task_self(),\n-\t\t\t\t\t(vm_address_t) island, pageSize );\n-\t\t}\n-\t} else {\n-\t\tfree( island );\n-\t}\n-\t\n-\treturn err;\n-}\n-\n-/***************************************************************************//**\n-\tImplementation: Sets the branch island's target, with an optional\n-\tinstruction.\n-\t\n-\t@param\tisland\t\t->\tThe branch island to insert target into.\n-\t@param\tbranchTo\t->\tThe address of the target.\n-\t@param\tinstruction\t->\tOptional instruction to execute prior to branch. Set\n-\t\t\t\t\t\t\tto zero for nop.\n-\t@result\t\t\t\t<-\tmach_error_t\n-\n-\t***************************************************************************/\n-#if defined(__ppc__) || defined(__POWERPC__)\n-\tstatic mach_error_t\n-setBranchIslandTarget(\n-\t\tBranchIsland\t*island,\n-\t\tconst void\t\t*branchTo,\n-\t\tlong\t\t\tinstruction )\n-{\n-\t//\tCopy over the template code.\n-    bcopy( kIslandTemplate, island->instructions, sizeof( kIslandTemplate ) );\n-    \n-    //\tFill in the address.\n-    ((short*)island->instructions)[kAddressLo] = ((long) branchTo) & 0x0000FFFF;\n-    ((short*)island->instructions)[kAddressHi]\n-    \t= (((long) branchTo) >> 16) & 0x0000FFFF;\n-    \n-    //\tFill in the (optional) instuction.\n-    if( instruction != 0 ) {\n-        ((short*)island->instructions)[kInstructionLo]\n-        \t= instruction & 0x0000FFFF;\n-        ((short*)island->instructions)[kInstructionHi]\n-        \t= (instruction >> 16) & 0x0000FFFF;\n-    }\n-    \n-    //MakeDataExecutable( island->instructions, sizeof( kIslandTemplate ) );\n-\tmsync( island->instructions, sizeof( kIslandTemplate ), MS_INVALIDATE );\n-    \n-    return err_none;\n-}\n-#endif \n-\n-#if defined(__i386__)\n-\tstatic mach_error_t\n-setBranchIslandTarget_i386(\n-\tBranchIsland\t*island,\n-\tconst void\t\t*branchTo,\n-\tchar*\t\t\tinstructions )\n-{\n-\n-\t//\tCopy over the template code.\n-    bcopy( kIslandTemplate, island->instructions, sizeof( kIslandTemplate ) );\n-\n-\t// copy original instructions\n-\tif (instructions) {\n-\t\tbcopy (instructions, island->instructions + kInstructions, kOriginalInstructionsSize);\n-\t}\n-\t\n-    // Fill in the address.\n-    int32_t addressOffset = (char *)branchTo - (island->instructions + kJumpAddress + 4);\n-    *((int32_t *)(island->instructions + kJumpAddress)) = addressOffset; \n-\n-    msync( island->instructions, sizeof( kIslandTemplate ), MS_INVALIDATE );\n-    return err_none;\n-}\n-\n-#elif defined(__x86_64__)\n-static mach_error_t\n-setBranchIslandTarget_i386(\n-        BranchIsland\t*island,\n-        const void\t\t*branchTo,\n-        char*\t\t\tinstructions )\n-{\n-    // Copy over the template code.\n-    bcopy( kIslandTemplate, island->instructions, sizeof( kIslandTemplate ) );\n-\n-    // Copy original instructions.\n-    if (instructions) {\n-        bcopy (instructions, island->instructions, kOriginalInstructionsSize);\n-    }\n-\n-    //\tFill in the address.\n-    *((uint64_t *)(island->instructions + kJumpAddress)) = (uint64_t)branchTo; \n-    msync( island->instructions, sizeof( kIslandTemplate ), MS_INVALIDATE );\n-\n-    return err_none;\n-}\n-#endif\n-\n-\n-#if defined(__i386__) || defined(__x86_64__)\n-// simplistic instruction matching\n-typedef struct {\n-\tunsigned int length; // max 15\n-\tunsigned char mask[15]; // sequence of bytes in memory order\n-\tunsigned char constraint[15]; // sequence of bytes in memory order\n-}\tAsmInstructionMatch;\n-\n-#if defined(__i386__)\n-static AsmInstructionMatch possibleInstructions[] = {\n-\t{ 0x5, {0xFF, 0x00, 0x00, 0x00, 0x00}, {0xE9, 0x00, 0x00, 0x00, 0x00} },\t// jmp 0x????????\n-\t{ 0x5, {0xFF, 0xFF, 0xFF, 0xFF, 0xFF}, {0x55, 0x89, 0xe5, 0xc9, 0xc3} },\t// push %esp; mov %esp,%ebp; leave; ret\n-\t{ 0x1, {0xFF}, {0x90} },\t\t\t\t\t\t\t// nop\n-\t{ 0x1, {0xF8}, {0x50} },\t\t\t\t\t\t\t// push %reg\n-\t{ 0x2, {0xFF, 0xFF}, {0x89, 0xE5} },\t\t\t\t                // mov %esp,%ebp\n-\t{ 0x3, {0xFF, 0xFF, 0xFF}, {0x89, 0x1C, 0x24} },\t\t\t\t                // mov %ebx,(%esp)\n-\t{ 0x3, {0xFF, 0xFF, 0x00}, {0x83, 0xEC, 0x00} },\t                        // sub 0x??, %esp\n-\t{ 0x6, {0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00}, {0x81, 0xEC, 0x00, 0x00, 0x00, 0x00} },\t// sub 0x??, %esp with 32bit immediate\n-\t{ 0x2, {0xFF, 0xFF}, {0x31, 0xC0} },\t\t\t\t\t\t// xor %eax, %eax\n-\t{ 0x3, {0xFF, 0x4F, 0x00}, {0x8B, 0x45, 0x00} },  // mov $imm(%ebp), %reg\n-\t{ 0x3, {0xFF, 0x4C, 0x00}, {0x8B, 0x40, 0x00} },  // mov $imm(%eax-%edx), %reg\n-\t{ 0x3, {0xFF, 0xCF, 0x00}, {0x8B, 0x4D, 0x00} },  // mov $imm(%rpb), %reg\n-\t{ 0x3, {0xFF, 0x4F, 0x00}, {0x8A, 0x4D, 0x00} },  // mov $imm(%ebp), %cl\n-\t{ 0x4, {0xFF, 0xFF, 0xFF, 0x00}, {0x8B, 0x4C, 0x24, 0x00} },  \t\t\t// mov $imm(%esp), %ecx\n-\t{ 0x4, {0xFF, 0x00, 0x00, 0x00}, {0x8B, 0x00, 0x00, 0x00} },  \t\t\t// mov r16,r/m16 or r32,r/m32\n-\t{ 0x5, {0xFF, 0x00, 0x00, 0x00, 0x00}, {0xB9, 0x00, 0x00, 0x00, 0x00} }, \t// mov $imm, %ecx\n-\t{ 0x5, {0xFF, 0x00, 0x00, 0x00, 0x00}, {0xB8, 0x00, 0x00, 0x00, 0x00} }, \t// mov $imm, %eax\n-\t{ 0x4, {0xFF, 0xFF, 0xFF, 0x00}, {0x66, 0x0F, 0xEF, 0x00} },             \t// pxor xmm2/128, xmm1\n-\t{ 0x2, {0xFF, 0xFF}, {0xDB, 0xE3} }, \t\t\t\t\t\t// fninit\n-\t{ 0x5, {0xFF, 0x00, 0x00, 0x00, 0x00}, {0xE8, 0x00, 0x00, 0x00, 0x00} },\t// call $imm\n-\t{ 0x4, {0xFF, 0xFF, 0xFF, 0x00}, {0x0F, 0xBE, 0x55, 0x00} },                    // movsbl $imm(%ebp), %edx\n-\t{ 0x0, {0x00}, {0x00} }\n-};\n-#elif defined(__x86_64__)\n-// TODO(glider): disassembling the \"0x48, 0x89\" sequences is trickier than it's done below.\n-// If it stops working, refer to http://ref.x86asm.net/geek.html#modrm_byte_32_64 to do it\n-// more accurately.\n-// Note: 0x48 is in fact the REX.W prefix, but it might be wrong to treat it as a separate\n-// instruction.\n-static AsmInstructionMatch possibleInstructions[] = {\n-\t{ 0x5, {0xFF, 0x00, 0x00, 0x00, 0x00}, {0xE9, 0x00, 0x00, 0x00, 0x00} },\t// jmp 0x????????\n-\t{ 0x1, {0xFF}, {0x90} },\t\t\t\t\t\t\t// nop\n-\t{ 0x1, {0xF8}, {0x50} },\t\t\t\t\t\t\t// push %rX\n-\t{ 0x1, {0xFF}, {0x65} },\t\t\t\t\t\t\t// GS prefix\n-\t{ 0x3, {0xFF, 0xFF, 0xFF}, {0x48, 0x89, 0xE5} },\t\t\t\t// mov %rsp,%rbp\n-\t{ 0x4, {0xFF, 0xFF, 0xFF, 0x00}, {0x48, 0x83, 0xEC, 0x00} },\t                // sub 0x??, %rsp\n-\t{ 0x4, {0xFB, 0xFF, 0x07, 0x00}, {0x48, 0x89, 0x05, 0x00} },\t                // move onto rbp\n-\t{ 0x3, {0xFB, 0xFF, 0x00}, {0x48, 0x89, 0x00} },\t                            // mov %reg, %reg\n-\t{ 0x3, {0xFB, 0xFF, 0x00}, {0x49, 0x89, 0x00} },\t                            // mov %reg, %reg (REX.WB)\n-\t{ 0x2, {0xFF, 0x00}, {0x41, 0x00} },\t\t\t\t\t\t// push %rXX\n-\t{ 0x2, {0xFF, 0x00}, {0x84, 0x00} },\t\t\t\t\t\t// test %rX8,%rX8\n-\t{ 0x2, {0xFF, 0x00}, {0x85, 0x00} },\t\t\t\t\t\t// test %rX,%rX\n-\t{ 0x2, {0xFF, 0x00}, {0x77, 0x00} },\t\t\t\t\t\t// ja $i8\n-\t{ 0x2, {0xFF, 0x00}, {0x74, 0x00} },\t\t\t\t\t\t// je $i8\n-\t{ 0x5, {0xF8, 0x00, 0x00, 0x00, 0x00}, {0xB8, 0x00, 0x00, 0x00, 0x00} },\t// mov $imm, %reg\n-\t{ 0x3, {0xFF, 0xFF, 0x00}, {0xFF, 0x77, 0x00} },\t\t\t\t// pushq $imm(%rdi)\n-\t{ 0x2, {0xFF, 0xFF}, {0x31, 0xC0} },\t\t\t\t\t\t// xor %eax, %eax\n-\t{ 0x5, {0xFF, 0x00, 0x00, 0x00, 0x00}, {0x25, 0x00, 0x00, 0x00, 0x00} },\t// and $imm, %eax\n-\t{ 0x3, {0xFF, 0xFF, 0xFF}, {0x80, 0x3F, 0x00} },\t\t\t\t// cmpb $imm, (%rdi)\n-\n-  { 0x8, {0xFF, 0xFF, 0xCF, 0xFF, 0x00, 0x00, 0x00, 0x00},\n-         {0x48, 0x8B, 0x04, 0x25, 0x00, 0x00, 0x00, 0x00}, },                     // mov $imm, %{rax,rdx,rsp,rsi}\n-  { 0x4, {0xFF, 0xFF, 0xFF, 0x00}, {0x48, 0x83, 0xFA, 0x00}, },   // cmp $i8, %rdx\n-\t{ 0x4, {0xFF, 0xFF, 0x00, 0x00}, {0x83, 0x7f, 0x00, 0x00}, },\t\t\t// cmpl $imm, $imm(%rdi)\n-\t{ 0xa, {0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},\n-               {0x48, 0xB8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00} },    // mov $imm, %rax\n-        { 0x6, {0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00},\n-               {0x81, 0xE6, 0x00, 0x00, 0x00, 0x00} },                            // and $imm, %esi\n-        { 0x6, {0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00},\n-               {0xFF, 0x25, 0x00, 0x00, 0x00, 0x00} },                            // jmpq *(%rip)\n-        { 0x4, {0xFF, 0xFF, 0xFF, 0x00}, {0x66, 0x0F, 0xEF, 0x00} },              // pxor xmm2/128, xmm1\n-        { 0x2, {0xFF, 0x00}, {0x89, 0x00} },                               // mov r/m32,r32 or r/m16,r16\n-        { 0x3, {0xFF, 0xFF, 0xFF}, {0x49, 0x89, 0xF8} },                   // mov %rdi,%r8\n-        { 0x4, {0xFF, 0xFF, 0xFF, 0xFF}, {0x40, 0x0F, 0xBE, 0xCE} },       // movsbl %sil,%ecx\n-        { 0x7, {0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00},\n-               {0x48, 0x8D, 0x05, 0x00, 0x00, 0x00, 0x00} },  // lea $imm(%rip),%rax\n-        { 0x3, {0xFF, 0xFF, 0xFF}, {0x0F, 0xBE, 0xCE} },  // movsbl, %dh, %ecx\n-        { 0x3, {0xFF, 0xFF, 0x00}, {0xFF, 0x77, 0x00} },  // pushq $imm(%rdi)\n-        { 0x2, {0xFF, 0xFF}, {0xDB, 0xE3} }, // fninit\n-        { 0x3, {0xFF, 0xFF, 0xFF}, {0x48, 0x85, 0xD2} },  // test %rdx,%rdx\n-\t{ 0x0, {0x00}, {0x00} }\n-};\n-#endif\n-\n-static Boolean codeMatchesInstruction(unsigned char *code, AsmInstructionMatch* instruction) \n-{\n-\tBoolean match = true;\n-\t\n-\tsize_t i;\n-  assert(instruction);\n-#ifdef DEBUG_DISASM\n-\tfprintf(stderr, \"Matching: \");\n-#endif  \n-\tfor (i=0; i<instruction->length; i++) {\n-\t\tunsigned char mask = instruction->mask[i];\n-\t\tunsigned char constraint = instruction->constraint[i];\n-\t\tunsigned char codeValue = code[i];\n-#ifdef DEBUG_DISASM\n-\t\tfprintf(stderr, \"%x \", (unsigned)codeValue);\n-#endif    \n-\t\tmatch = ((codeValue & mask) == constraint);\n-\t\tif (!match) break;\n-\t}\n-#ifdef DEBUG_DISASM\n-\tif (match) {\n-\t\tfprintf(stderr, \" OK\\n\");\n-\t} else {\n-\t\tfprintf(stderr, \" FAIL\\n\");\n-\t}\n-#endif  \n-\treturn match;\n-}\n-\n-#if defined(__i386__) || defined(__x86_64__)\n-\tstatic Boolean \n-eatKnownInstructions( \n-\tunsigned char\t*code, \n-\tuint64_t\t\t*newInstruction,\n-\tint\t\t\t\t*howManyEaten, \n-\tchar\t\t\t*originalInstructions,\n-\tint\t\t\t\t*originalInstructionCount, \n-\tuint8_t\t\t\t*originalInstructionSizes )\n-{\n-\tBoolean allInstructionsKnown = true;\n-\tint totalEaten = 0;\n-\tunsigned char* ptr = code;\n-\tint remainsToEat = 5; // a JMP instruction takes 5 bytes\n-\tint instructionIndex = 0;\n-\t\n-\tif (howManyEaten) *howManyEaten = 0;\n-\tif (originalInstructionCount) *originalInstructionCount = 0;\n-\twhile (remainsToEat > 0) {\n-\t\tBoolean curInstructionKnown = false;\n-\t\t\n-\t\t// See if instruction matches one  we know\n-\t\tAsmInstructionMatch* curInstr = possibleInstructions;\n-\t\tdo { \n-\t\t\tif ((curInstructionKnown = codeMatchesInstruction(ptr, curInstr))) break;\n-\t\t\tcurInstr++;\n-\t\t} while (curInstr->length > 0);\n-\t\t\n-\t\t// if all instruction matches failed, we don't know current instruction then, stop here\n-\t\tif (!curInstructionKnown) { \n-\t\t\tallInstructionsKnown = false;\n-\t\t\tfprintf(stderr, \"mach_override: some instructions unknown! Need to update mach_override.c\\n\");\n-\t\t\tbreak;\n-\t\t}\n-\t\t\n-\t\t// At this point, we've matched curInstr\n-\t\tint eaten = curInstr->length;\n-\t\tptr += eaten;\n-\t\tremainsToEat -= eaten;\n-\t\ttotalEaten += eaten;\n-\t\t\n-\t\tif (originalInstructionSizes) originalInstructionSizes[instructionIndex] = eaten;\n-\t\tinstructionIndex += 1;\n-\t\tif (originalInstructionCount) *originalInstructionCount = instructionIndex;\n-\t}\n-\n-\n-\tif (howManyEaten) *howManyEaten = totalEaten;\n-\n-\tif (originalInstructions) {\n-\t\tBoolean enoughSpaceForOriginalInstructions = (totalEaten < kOriginalInstructionsSize);\n-\t\t\n-\t\tif (enoughSpaceForOriginalInstructions) {\n-\t\t\tmemset(originalInstructions, 0x90 /* NOP */, kOriginalInstructionsSize); // fill instructions with NOP\n-\t\t\tbcopy(code, originalInstructions, totalEaten);\n-\t\t} else {\n-#ifdef DEBUG_DISASM\n-\t\t\tfprintf(stderr, \"Not enough space in island to store original instructions. Adapt the island definition and kOriginalInstructionsSize\\n\");\n-#endif      \n-\t\t\treturn false;\n-\t\t}\n-\t}\n-\t\n-\tif (allInstructionsKnown) {\n-\t\t// save last 3 bytes of first 64bits of codre we'll replace\n-\t\tuint64_t currentFirst64BitsOfCode = *((uint64_t *)code);\n-\t\tcurrentFirst64BitsOfCode = OSSwapInt64(currentFirst64BitsOfCode); // back to memory representation\n-\t\tcurrentFirst64BitsOfCode &= 0x0000000000FFFFFFLL; \n-\t\t\n-\t\t// keep only last 3 instructions bytes, first 5 will be replaced by JMP instr\n-\t\t*newInstruction &= 0xFFFFFFFFFF000000LL; // clear last 3 bytes\n-\t\t*newInstruction |= (currentFirst64BitsOfCode & 0x0000000000FFFFFFLL); // set last 3 bytes\n-\t}\n-\n-\treturn allInstructionsKnown;\n-}\n-\n-\tstatic void\n-fixupInstructions(\n-    void\t\t*originalFunction,\n-    void\t\t*escapeIsland,\n-    void\t\t*instructionsToFix,\n-\tint\t\t\tinstructionCount,\n-\tuint8_t\t\t*instructionSizes )\n-{\n-\tvoid *initialOriginalFunction = originalFunction;\n-\tint\tindex, fixed_size, code_size = 0;\n-\tfor (index = 0;index < instructionCount;index += 1)\n-\t\tcode_size += instructionSizes[index];\n-\n-#ifdef DEBUG_DISASM\n-\tvoid *initialInstructionsToFix = instructionsToFix;\n-\tfprintf(stderr, \"BEFORE FIXING:\\n\");\n-\tdump16Bytes(initialOriginalFunction);\n-\tdump16Bytes(initialInstructionsToFix);\n-#endif  // DEBUG_DISASM\n-\n-\tfor (index = 0;index < instructionCount;index += 1)\n-\t{\n-                fixed_size = instructionSizes[index];\n-\t\tif ((*(uint8_t*)instructionsToFix == 0xE9) || // 32-bit jump relative\n-\t\t    (*(uint8_t*)instructionsToFix == 0xE8))   // 32-bit call relative\n-\t\t{\n-\t\t\tuint32_t offset = (uintptr_t)originalFunction - (uintptr_t)escapeIsland;\n-\t\t\tuint32_t *jumpOffsetPtr = (uint32_t*)((uintptr_t)instructionsToFix + 1);\n-\t\t\t*jumpOffsetPtr += offset;\n-\t\t}\n-\t\tif ((*(uint8_t*)instructionsToFix == 0x74) ||  // Near jump if equal (je), 2 bytes.\n-\t\t    (*(uint8_t*)instructionsToFix == 0x77))    // Near jump if above (ja), 2 bytes.\n-\t\t{\n-\t\t\t// We replace a near je/ja instruction, \"7P JJ\", with a 32-bit je/ja, \"0F 8P WW XX YY ZZ\".\n-\t\t\t// This is critical, otherwise a near jump will likely fall outside the original function.\n-\t\t\tuint32_t offset = (uintptr_t)initialOriginalFunction - (uintptr_t)escapeIsland;\n-\t\t\tuint32_t jumpOffset = *(uint8_t*)((uintptr_t)instructionsToFix + 1);\n-\t\t\t*((uint8_t*)instructionsToFix + 1) = *(uint8_t*)instructionsToFix + 0x10;\n-\t\t\t*(uint8_t*)instructionsToFix = 0x0F;\n-\t\t\tuint32_t *jumpOffsetPtr = (uint32_t*)((uintptr_t)instructionsToFix + 2 );\n-\t\t\t*jumpOffsetPtr = offset + jumpOffset;\n-\t\t\tfixed_size = 6;\n-                }\n-\t\t\n-\t\toriginalFunction = (void*)((uintptr_t)originalFunction + instructionSizes[index]);\n-\t\tescapeIsland = (void*)((uintptr_t)escapeIsland + instructionSizes[index]);\n-\t\tinstructionsToFix = (void*)((uintptr_t)instructionsToFix + fixed_size);\n-\n-\t\t// Expanding short instructions into longer ones may overwrite the next instructions,\n-\t\t// so we must restore them.\n-\t\tcode_size -= fixed_size;\n-\t\tif ((code_size > 0) && (fixed_size != instructionSizes[index])) {\n-\t\t\tbcopy(originalFunction, instructionsToFix, code_size);\n-\t\t}\n-\t}\n-#ifdef DEBUG_DISASM\n-\tfprintf(stderr, \"AFTER_FIXING:\\n\");\n-\tdump16Bytes(initialOriginalFunction);\n-\tdump16Bytes(initialInstructionsToFix);\n-#endif  // DEBUG_DISASM\n-}\n-\n-#ifdef DEBUG_DISASM\n-#define HEX_DIGIT(x) ((((x) % 16) < 10) ? ('0' + ((x) % 16)) : ('A' + ((x) % 16 - 10)))\n-\n-\tstatic void\n-dump16Bytes(\n-\tvoid \t*ptr) {\n-\tint i;\n-\tchar buf[3];\n-\tuint8_t *bytes = (uint8_t*)ptr;\n-\tfor (i = 0; i < 16; i++) {\n-\t\tbuf[0] = HEX_DIGIT(bytes[i] / 16);\n-\t\tbuf[1] = HEX_DIGIT(bytes[i] % 16);\n-\t\tbuf[2] = ' ';\n-\t\twrite(2, buf, 3);\n-\t}\n-\twrite(2, \"\\n\", 1);\n-}\n-#endif  // DEBUG_DISASM\n-#endif\n-\n-#if defined(__i386__)\n-__asm(\n-\t\t\t\".text;\"\n-\t\t\t\".align 2, 0x90;\"\n-\t\t\t\"_atomic_mov64:;\"\n-\t\t\t\"\tpushl %ebp;\"\n-\t\t\t\"\tmovl %esp, %ebp;\"\n-\t\t\t\"\tpushl %esi;\"\n-\t\t\t\"\tpushl %ebx;\"\n-\t\t\t\"\tpushl %ecx;\"\n-\t\t\t\"\tpushl %eax;\"\n-\t\t\t\"\tpushl %edx;\"\n-\t\n-\t\t\t// atomic push of value to an address\n-\t\t\t// we use cmpxchg8b, which compares content of an address with \n-\t\t\t// edx:eax. If they are equal, it atomically puts 64bit value \n-\t\t\t// ecx:ebx in address. \n-\t\t\t// We thus put contents of address in edx:eax to force ecx:ebx\n-\t\t\t// in address\n-\t\t\t\"\tmov\t\t8(%ebp), %esi;\"  // esi contains target address\n-\t\t\t\"\tmov\t\t12(%ebp), %ebx;\"\n-\t\t\t\"\tmov\t\t16(%ebp), %ecx;\" // ecx:ebx now contains value to put in target address\n-\t\t\t\"\tmov\t\t(%esi), %eax;\"\n-\t\t\t\"\tmov\t\t4(%esi), %edx;\"  // edx:eax now contains value currently contained in target address\n-\t\t\t\"\tlock; cmpxchg8b\t(%esi);\" // atomic move.\n-\t\t\t\n-\t\t\t// restore registers\n-\t\t\t\"\tpopl %edx;\"\n-\t\t\t\"\tpopl %eax;\"\n-\t\t\t\"\tpopl %ecx;\"\n-\t\t\t\"\tpopl %ebx;\"\n-\t\t\t\"\tpopl %esi;\"\n-\t\t\t\"\tpopl %ebp;\"\n-\t\t\t\"\tret\"\n-);\n-#elif defined(__x86_64__)\n-void atomic_mov64(\n-\t\tuint64_t *targetAddress,\n-\t\tuint64_t value )\n-{\n-    *targetAddress = value;\n-}\n-#endif\n-#endif\n-#endif  // __APPLE__"}, {"sha": "7e60cdcd619c66f5964bd9943d9faa534e291479", "filename": "libsanitizer/interception/mach_override/mach_override.h", "status": "removed", "additions": 0, "deletions": 140, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fa057a43770dbb23a0fb21a94cab1789df3277c/libsanitizer%2Finterception%2Fmach_override%2Fmach_override.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fa057a43770dbb23a0fb21a94cab1789df3277c/libsanitizer%2Finterception%2Fmach_override%2Fmach_override.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finterception%2Fmach_override%2Fmach_override.h?ref=3fa057a43770dbb23a0fb21a94cab1789df3277c", "patch": "@@ -1,140 +0,0 @@\n-/*******************************************************************************\n-\tmach_override.h\n-\t\tCopyright (c) 2003-2009 Jonathan 'Wolf' Rentzsch: <http://rentzsch.com>\n-\t\tSome rights reserved: <http://opensource.org/licenses/mit-license.php>\n-\n-\t***************************************************************************/\n-\n-/***************************************************************************//**\n-\t@mainpage\tmach_override\n-\t@author\t\tJonathan 'Wolf' Rentzsch: <http://rentzsch.com>\n-\t\n-\tThis package, coded in C to the Mach API, allows you to override (\"patch\")\n-\tprogram- and system-supplied functions at runtime. You can fully replace\n-\tfunctions with your implementations, or merely head- or tail-patch the\n-\toriginal implementations.\n-\t\n-\tUse it by #include'ing mach_override.h from your .c, .m or .mm file(s).\n-\t\n-\t@todo\tDiscontinue use of Carbon's MakeDataExecutable() and\n-\t\t\tCompareAndSwap() calls and start using the Mach equivalents, if they\n-\t\t\texist. If they don't, write them and roll them in. That way, this\n-\t\t\tcode will be pure Mach, which will make it easier to use everywhere.\n-\t\t\tUpdate: MakeDataExecutable() has been replaced by\n-\t\t\tmsync(MS_INVALIDATE). There is an OSCompareAndSwap in libkern, but\n-\t\t\tI'm currently unsure if I can link against it. May have to roll in\n-\t\t\tmy own version...\n-\t@todo\tStop using an entire 4K high-allocated VM page per 28-byte escape\n-\t\t\tbranch island. Done right, this will dramatically speed up escape\n-\t\t\tisland allocations when they number over 250. Then again, if you're\n-\t\t\toverriding more than 250 functions, maybe speed isn't your main\n-\t\t\tconcern...\n-\t@todo\tAdd detection of: b, bl, bla, bc, bcl, bcla, bcctrl, bclrl\n-\t\t\tfirst-instructions. Initially, we should refuse to override\n-\t\t\tfunctions beginning with these instructions. Eventually, we should\n-\t\t\tdynamically rewrite them to make them position-independent.\n-\t@todo\tWrite mach_unoverride(), which would remove an override placed on a\n-\t\t\tfunction. Must be multiple-override aware, which means an almost\n-\t\t\tcomplete rewrite under the covers, because the target address can't\n-\t\t\tbe spread across two load instructions like it is now since it will\n-\t\t\tneed to be atomically updatable.\n-\t@todo\tAdd non-rentry variants of overrides to test_mach_override.\n-\n-\t***************************************************************************/\n-\n-#ifdef __APPLE__\n-\n-#ifndef\t\t_mach_override_\n-#define\t\t_mach_override_\n-\n-#include <sys/types.h>\n-#include <mach/error.h>\n-\n-#ifdef\t__cplusplus\n-\textern\t\"C\"\t{\n-#endif\n-\n-/**\n-\tReturned if the function to be overrided begins with a 'mfctr' instruction.\n-*/\n-#define\terr_cannot_override\t(err_local|1)\n-\n-/************************************************************************************//**\n-\tDynamically overrides the function implementation referenced by\n-\toriginalFunctionAddress with the implentation pointed to by overrideFunctionAddress.\n-\tOptionally returns a pointer to a \"reentry island\" which, if jumped to, will resume\n-\tthe original implementation.\n-\t\n-\t@param\toriginalFunctionAddress\t\t\t->\tRequired address of the function to\n-\t\t\t\t\t\t\t\t\t\t\t\toverride (with overrideFunctionAddress).\n-\t@param\toverrideFunctionAddress\t\t\t->\tRequired address to the overriding\n-\t\t\t\t\t\t\t\t\t\t\t\tfunction.\n-\t@param\toriginalFunctionReentryIsland\t<-\tOptional pointer to pointer to the\n-\t\t\t\t\t\t\t\t\t\t\t\treentry island. Can be NULL.\n-\t@result\t\t\t\t\t\t\t\t\t<-\terr_cannot_override if the original\n-\t\t\t\t\t\t\t\t\t\t\t\tfunction's implementation begins with\n-\t\t\t\t\t\t\t\t\t\t\t\tthe 'mfctr' instruction.\n-\n-\t************************************************************************************/\n-\n-// We're prefixing mach_override_ptr() with \"__asan_\" to avoid name conflicts with other\n-// mach_override_ptr() implementations that may appear in the client program.\n-    mach_error_t\n-__asan_mach_override_ptr(\n-\tvoid *originalFunctionAddress,\n-    const void *overrideFunctionAddress,\n-    void **originalFunctionReentryIsland );\n-\n-// Allow to use custom allocation and deallocation routines with mach_override_ptr().\n-// This should help to speed up the things on x86_64.\n-typedef mach_error_t island_malloc( void **ptr, size_t size, void *hint );\n-typedef mach_error_t island_free( void *ptr );\n-\n-    mach_error_t\n-__asan_mach_override_ptr_custom(\n-\tvoid *originalFunctionAddress,\n-    const void *overrideFunctionAddress,\n-    void **originalFunctionReentryIsland,\n-    island_malloc *alloc,\n-    island_free *dealloc );\n-\n-/************************************************************************************//**\n-\t\n-\n-\t************************************************************************************/\n- \n-#ifdef\t__cplusplus\n-\n-#define MACH_OVERRIDE( ORIGINAL_FUNCTION_RETURN_TYPE, ORIGINAL_FUNCTION_NAME, ORIGINAL_FUNCTION_ARGS, ERR )\t\t\t\\\n-\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n-\t\tstatic ORIGINAL_FUNCTION_RETURN_TYPE (*ORIGINAL_FUNCTION_NAME##_reenter)ORIGINAL_FUNCTION_ARGS;\t\t\t\t\\\n-\t\tstatic bool ORIGINAL_FUNCTION_NAME##_overriden = false;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n-\t\tclass mach_override_class__##ORIGINAL_FUNCTION_NAME {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n-\t\tpublic:\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n-\t\t\tstatic kern_return_t override(void *originalFunctionPtr) {\t\t\t\t\t\t\t\t\t\t\t\t\\\n-\t\t\t\tkern_return_t result = err_none;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n-\t\t\t\tif (!ORIGINAL_FUNCTION_NAME##_overriden) {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\tORIGINAL_FUNCTION_NAME##_overriden = true;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\tresult = mach_override_ptr( (void*)originalFunctionPtr,\t\t\t\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\t\t\t(void*)mach_override_class__##ORIGINAL_FUNCTION_NAME::replacement,\t\\\n-\t\t\t\t\t\t\t\t\t\t\t\t(void**)&ORIGINAL_FUNCTION_NAME##_reenter );\t\t\t\t\t\t\\\n-\t\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n-\t\t\t\treturn result;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n-\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n-\t\t\tstatic ORIGINAL_FUNCTION_RETURN_TYPE replacement ORIGINAL_FUNCTION_ARGS {\n-\n-#define END_MACH_OVERRIDE( ORIGINAL_FUNCTION_NAME )\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n-\t\t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n-\t\t};\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n-\t\terr = mach_override_class__##ORIGINAL_FUNCTION_NAME::override((void*)ORIGINAL_FUNCTION_NAME);\t\t\t\t\\\n-\t}\n- \n-#endif\n-\n-#ifdef\t__cplusplus\n-\t}\n-#endif\n-#endif\t//\t_mach_override_\n-\n-#endif  // __APPLE__"}, {"sha": "0f75431cf6853113204f6b18390b826d76724aa2", "filename": "libsanitizer/merge.sh", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c4d267c6e834ccc20632d2c9077d7622b8145cf/libsanitizer%2Fmerge.sh", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c4d267c6e834ccc20632d2c9077d7622b8145cf/libsanitizer%2Fmerge.sh", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fmerge.sh?ref=8c4d267c6e834ccc20632d2c9077d7622b8145cf", "patch": "@@ -66,6 +66,7 @@ CUR_REV=$(get_current_rev)\n echo Current upstream revision: $CUR_REV\n merge include/sanitizer include/sanitizer\n merge lib/asan asan\n+merge lib/asan/dynamic asan/dynamic\n merge lib/tsan/rtl tsan\n merge lib/sanitizer_common sanitizer_common\n merge lib/interception interception"}]}