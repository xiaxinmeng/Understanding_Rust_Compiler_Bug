{"sha": "9db7c9316e484499286d39d4c15e77310bedd3e9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWRiN2M5MzE2ZTQ4NDQ5OTI4NmQzOWQ0YzE1ZTc3MzEwYmVkZDNlOQ==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2014-12-02T01:51:25Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2014-12-02T01:51:25Z"}, "message": "Define *_at_thread_exit() functions.\n\n\t* config/abi/pre/gnu.ver: Add new exports.\n\t* include/std/condition_variable (notify_all_at_thread_exit): Declare.\n\t(__at_thread_exit_elt): New base class.\n\t* include/std/future: Add comments documenting the implementation.\n\t(__future_base::_State_baseV2::_State_baseV2()): Use brace-or-equal\n\tinitializers and define constructor as defaulted.\n\t(__future_base::_State_baseV2::_M_ready): Replace member function\n\twith member variable.\n\t(__future_base::_State_baseV2::_M_set_result): Set _M_ready.\n\t(__future_base::_State_baseV2::_M_set_delayed_result): Define.\n\t(__future_base::_State_baseV2::_M_break_promise): Set _M_ready.\n\t(__future_base::_State_baseV2::_Make_ready): New helper class.\n\t(__future_base::_Deferred_state::_M_has_deferred): Remove requirement\n\tfor caller to own mutex.\n\t(__future_base::_Async_state_impl::~_Async_state_impl): Call join\n\tdirectly.\n\t(__future_base::_Task_state_base::_M_run): Take arguments by\n\treference.\n\t(__future_base::_Task_state_base::_M_run_delayed): Declare new pure\n\tvirtual function.\n\t(__future_base::_Task_state::_M_run_delayed): Define override.\n\t(promise::set_value_at_thread_exit): Define.\n\t(promise::set_exception_at_thread_exit): Define.\n\t(packaged_task::make_ready_at_thread_exit): Define.\n\t* src/c++11/condition_variable.cc (notify_all_at_thread_exit): Define.\n\t* src/c++11/future.cc\n\t(__future_base::_State_baseV2::_Make_ready::_M_set): Define.\n\t* testsuite/30_threads/condition_variable/members/3.cc: New.\n\t* testsuite/30_threads/packaged_task/members/at_thread_exit.cc: New.\n\t* testsuite/30_threads/promise/members/at_thread_exit.cc: New.\n\nFrom-SVN: r218255", "tree": {"sha": "5388ff127d2315eb52f9a0b33c34a6dc49719774", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5388ff127d2315eb52f9a0b33c34a6dc49719774"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9db7c9316e484499286d39d4c15e77310bedd3e9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9db7c9316e484499286d39d4c15e77310bedd3e9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9db7c9316e484499286d39d4c15e77310bedd3e9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9db7c9316e484499286d39d4c15e77310bedd3e9/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8581fd64994f5cdadb5f7d9f346dc5c1c369631a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8581fd64994f5cdadb5f7d9f346dc5c1c369631a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8581fd64994f5cdadb5f7d9f346dc5c1c369631a"}], "stats": {"total": 557, "additions": 527, "deletions": 30}, "files": [{"sha": "19499dc390f632ceaac1023f3fe56a7b76109970", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9db7c9316e484499286d39d4c15e77310bedd3e9/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9db7c9316e484499286d39d4c15e77310bedd3e9/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=9db7c9316e484499286d39d4c15e77310bedd3e9", "patch": "@@ -1,3 +1,36 @@\n+2014-12-02  Jonathan Wakely  <jwakely@redhat.com>\n+\n+\t* config/abi/pre/gnu.ver: Add new exports.\n+\t* include/std/condition_variable (notify_all_at_thread_exit): Declare.\n+\t(__at_thread_exit_elt): New base class.\n+\t* include/std/future: Add comments documenting the implementation.\n+\t(__future_base::_State_baseV2::_State_baseV2()): Use brace-or-equal\n+\tinitializers and define constructor as defaulted.\n+\t(__future_base::_State_baseV2::_M_ready): Replace member function\n+\twith member variable.\n+\t(__future_base::_State_baseV2::_M_set_result): Set _M_ready.\n+\t(__future_base::_State_baseV2::_M_set_delayed_result): Define.\n+\t(__future_base::_State_baseV2::_M_break_promise): Set _M_ready.\n+\t(__future_base::_State_baseV2::_Make_ready): New helper class.\n+\t(__future_base::_Deferred_state::_M_has_deferred): Remove requirement\n+\tfor caller to own mutex.\n+\t(__future_base::_Async_state_impl::~_Async_state_impl): Call join\n+\tdirectly.\n+\t(__future_base::_Task_state_base::_M_run): Take arguments by\n+\treference.\n+\t(__future_base::_Task_state_base::_M_run_delayed): Declare new pure\n+\tvirtual function.\n+\t(__future_base::_Task_state::_M_run_delayed): Define override.\n+\t(promise::set_value_at_thread_exit): Define.\n+\t(promise::set_exception_at_thread_exit): Define.\n+\t(packaged_task::make_ready_at_thread_exit): Define.\n+\t* src/c++11/condition_variable.cc (notify_all_at_thread_exit): Define.\n+\t* src/c++11/future.cc\n+\t(__future_base::_State_baseV2::_Make_ready::_M_set): Define.\n+\t* testsuite/30_threads/condition_variable/members/3.cc: New.\n+\t* testsuite/30_threads/packaged_task/members/at_thread_exit.cc: New.\n+\t* testsuite/30_threads/promise/members/at_thread_exit.cc: New.\n+\n 2014-12-01  Jonathan Wakely  <jwakely@redhat.com>\n \n \tPR libstdc++/63840"}, {"sha": "c73ebe7a65552d49cb92c3e4aa1a9988a400d535", "filename": "libstdc++-v3/config/abi/pre/gnu.ver", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9db7c9316e484499286d39d4c15e77310bedd3e9/libstdc%2B%2B-v3%2Fconfig%2Fabi%2Fpre%2Fgnu.ver", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9db7c9316e484499286d39d4c15e77310bedd3e9/libstdc%2B%2B-v3%2Fconfig%2Fabi%2Fpre%2Fgnu.ver", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Fabi%2Fpre%2Fgnu.ver?ref=9db7c9316e484499286d39d4c15e77310bedd3e9", "patch": "@@ -128,7 +128,8 @@ GLIBCXX_3.4 {\n       std::messages*;\n       std::money*;\n #     std::n[^u]*;\n-      std::n[^aue]*;\n+      std::n[^aueo]*;\n+      std::nothrow;\n       std::nu[^m]*;\n       std::num[^e]*;\n       std::ostrstream*;\n@@ -1500,6 +1501,11 @@ GLIBCXX_3.4.21 {\n     # std::_Sp_locker::*\n     _ZNSt10_Sp_locker[CD]*;\n \n+    # std::notify_all_at_thread_exit\n+    _ZSt25notify_all_at_thread_exitRSt18condition_variableSt11unique_lockISt5mutexE;\n+    # std::__future_base::_State_baseV2::_Make_ready::_M_set()\n+    _ZNSt13__future_base13_State_baseV211_Make_ready6_M_setEv;\n+\n } GLIBCXX_3.4.20;\n \n "}, {"sha": "a3682c0bc79dc531710d120542e500bf4e9a5831", "filename": "libstdc++-v3/include/std/condition_variable", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9db7c9316e484499286d39d4c15e77310bedd3e9/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fcondition_variable", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9db7c9316e484499286d39d4c15e77310bedd3e9/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fcondition_variable", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fcondition_variable?ref=9db7c9316e484499286d39d4c15e77310bedd3e9", "patch": "@@ -170,6 +170,15 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       }\n   };\n \n+  void\n+  notify_all_at_thread_exit(condition_variable&, unique_lock<mutex>);\n+\n+  struct __at_thread_exit_elt\n+  {\n+    __at_thread_exit_elt* _M_next;\n+    void (*_M_cb)(void*);\n+  };\n+\n   inline namespace _V2 {\n \n   /// condition_variable_any"}, {"sha": "60c2e4eb6d937f1d97361726910d009b7fd1f559", "filename": "libstdc++-v3/include/std/future", "status": "modified", "additions": 197, "deletions": 29, "changes": 226, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9db7c9316e484499286d39d4c15e77310bedd3e9/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffuture", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9db7c9316e484499286d39d4c15e77310bedd3e9/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffuture", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffuture?ref=9db7c9316e484499286d39d4c15e77310bedd3e9", "patch": "@@ -202,7 +202,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       virtual ~_Result_base();\n     };\n \n-    /// Result.\n+    /// A unique_ptr for result objects.\n+    template<typename _Res>\n+      using _Ptr = unique_ptr<_Res, _Result_base::_Deleter>;\n+\n+    /// A result object that has storage for an object of type _Res.\n     template<typename _Res>\n       struct _Result : _Result_base\n       {\n@@ -243,11 +247,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \tvoid _M_destroy() { delete this; }\n     };\n \n-    /// A unique_ptr based on the instantiating type.\n-    template<typename _Res>\n-      using _Ptr = unique_ptr<_Res, _Result_base::_Deleter>;\n-\n-    /// Result_alloc.\n+    /// A result object that uses an allocator.\n     template<typename _Res, typename _Alloc>\n       struct _Result_alloc final : _Result<_Res>, _Alloc\n       {\n@@ -266,6 +266,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t}\n       };\n \n+    // Create a result object that uses an allocator.\n     template<typename _Res, typename _Allocator>\n       static _Ptr<_Result_alloc<_Res, _Allocator>>\n       _S_allocate_result(const _Allocator& __a)\n@@ -278,38 +279,42 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \treturn _Ptr<__result_type>(__p);\n       }\n \n+    // Keep it simple for std::allocator.\n     template<typename _Res, typename _Tp>\n       static _Ptr<_Result<_Res>>\n       _S_allocate_result(const std::allocator<_Tp>& __a)\n       {\n \treturn _Ptr<_Result<_Res>>(new _Result<_Res>);\n       }\n \n-    /// Base class for state between a promise and one or more\n-    /// associated futures.\n+    // Base class for various types of shared state created by an\n+    // asynchronous provider (such as a std::promise) and shared with one\n+    // or more associated futures.\n     class _State_baseV2\n     {\n       typedef _Ptr<_Result_base> _Ptr_type;\n \n       _Ptr_type\t\t\t_M_result;\n       mutex               \t_M_mutex;\n       condition_variable  \t_M_cond;\n-      atomic_flag         \t_M_retrieved;\n+      atomic_flag\t\t_M_retrieved = ATOMIC_FLAG_INIT;\n+      bool\t\t\t_M_ready = false;\n       once_flag\t\t\t_M_once;\n \n     public:\n-      _State_baseV2() noexcept : _M_result(), _M_retrieved(ATOMIC_FLAG_INIT)\n-\t{ }\n+      _State_baseV2() noexcept = default;\n       _State_baseV2(const _State_baseV2&) = delete;\n       _State_baseV2& operator=(const _State_baseV2&) = delete;\n       virtual ~_State_baseV2() = default;\n \n       _Result_base&\n       wait()\n       {\n+\t// Run any deferred function or join any asynchronous thread:\n \t_M_complete_async();\n+\n \tunique_lock<mutex> __lock(_M_mutex);\n-\t_M_cond.wait(__lock, [&] { return _M_ready(); });\n+\t_M_cond.wait(__lock, [&] { return _M_ready; });\n \treturn *_M_result;\n       }\n \n@@ -318,15 +323,23 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n         wait_for(const chrono::duration<_Rep, _Period>& __rel)\n         {\n \t  unique_lock<mutex> __lock(_M_mutex);\n-\t  if (_M_ready())\n+\t  if (_M_ready)\n \t    return future_status::ready;\n \t  if (_M_has_deferred())\n \t    return future_status::deferred;\n-\t  if (_M_cond.wait_for(__lock, __rel, [&] { return _M_ready(); }))\n+\t  if (_M_cond.wait_for(__lock, __rel, [&] { return _M_ready; }))\n \t    {\n \t      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n \t      // 2100.  timed waiting functions must also join\n+\t      // This call is a no-op by default except on an async future,\n+\t      // in which case the async thread is joined.  It's also not a\n+\t      // no-op for a deferred future, but such a future will never\n+\t      // reach this point because it returns future_status::deferred\n+\t      // instead of waiting for the future to become ready (see\n+\t      // above).  Async futures synchronize in this call, so we need\n+\t      // no further synchronization here.\n \t      _M_complete_async();\n+\n \t      return future_status::ready;\n \t    }\n \t  return future_status::timeout;\n@@ -337,20 +350,28 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n         wait_until(const chrono::time_point<_Clock, _Duration>& __abs)\n         {\n \t  unique_lock<mutex> __lock(_M_mutex);\n-\t  if (_M_ready())\n+\t  if (_M_ready)\n \t    return future_status::ready;\n \t  if (_M_has_deferred())\n \t    return future_status::deferred;\n-\t  if (_M_cond.wait_until(__lock, __abs, [&] { return _M_ready(); }))\n+\t  if (_M_cond.wait_until(__lock, __abs, [&] { return _M_ready; }))\n \t    {\n \t      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n \t      // 2100.  timed waiting functions must also join\n+\t      // See wait_for(...) above.\n \t      _M_complete_async();\n+\n \t      return future_status::ready;\n \t    }\n \t  return future_status::timeout;\n \t}\n \n+      // Provide a result to the shared state and make it ready.\n+      // Atomically performs:\n+      //   if (!_M_ready) {\n+      //     _M_result = __res();\n+      //     _M_ready = true;\n+      //   }\n       void\n       _M_set_result(function<_Ptr_type()> __res, bool __ignore_failure = false)\n       {\n@@ -360,27 +381,59 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \tcall_once(_M_once, &_State_baseV2::_M_do_set, this,\n \t\t  std::__addressof(__res), std::__addressof(__lock));\n \tif (__lock.owns_lock())\n-\t  _M_cond.notify_all();\n+\t  {\n+\t    _M_ready = true;\n+\t    _M_cond.notify_all();\n+\t  }\n \telse if (!__ignore_failure)\n           __throw_future_error(int(future_errc::promise_already_satisfied));\n       }\n \n+      // Provide a result to the shared state but delay making it ready\n+      // until the calling thread exits.\n+      // Atomically performs:\n+      //   if (!_M_ready) {\n+      //     _M_result = __res();\n+      //   }\n+      void\n+      _M_set_delayed_result(function<_Ptr_type()> __res,\n+\t\t\t    weak_ptr<_State_baseV2> __self)\n+      {\n+\tunique_ptr<_Make_ready> __mr{new _Make_ready};\n+\tunique_lock<mutex> __lock(_M_mutex, defer_lock);\n+        // all calls to this function are serialized,\n+        // side-effects of invoking __res only happen once\n+\tcall_once(_M_once, &_State_baseV2::_M_do_set, this,\n+\t\t  std::__addressof(__res), std::__addressof(__lock));\n+\tif (!__lock.owns_lock())\n+          __throw_future_error(int(future_errc::promise_already_satisfied));\n+\t__mr->_M_shared_state = std::move(__self);\n+\t__mr->_M_set();\n+\t__mr.release();\n+      }\n+\n+      // Abandon this shared state.\n       void\n       _M_break_promise(_Ptr_type __res)\n       {\n \tif (static_cast<bool>(__res))\n \t  {\n \t    error_code __ec(make_error_code(future_errc::broken_promise));\n \t    __res->_M_error = make_exception_ptr(future_error(__ec));\n+\t    // This function is only called when the last asynchronous result\n+\t    // provider is abandoning this shared state, so noone can be\n+\t    // trying to make the shared state ready at the same time, and\n+\t    // we can access _M_result directly instead of through call_once.\n \t    {\n \t      lock_guard<mutex> __lock(_M_mutex);\n \t      _M_result.swap(__res);\n+\t      _M_ready = true;\n \t    }\n \t    _M_cond.notify_all();\n \t  }\n       }\n \n-      // Called when this object is passed to a future.\n+      // Called when this object is first passed to a future.\n       void\n       _M_set_retrieved_flag()\n       {\n@@ -401,6 +454,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n               || is_same<const _Res, _Arg>::value,   // promise<R>\n               \"Invalid specialisation\");\n \n+\t  // Used by std::promise to copy construct the result.\n           typename promise<_Res>::_Ptr_type operator()()\n           {\n             _State_baseV2::_S_check(_M_promise->_M_future);\n@@ -415,6 +469,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       template<typename _Res>\n         struct _Setter<_Res, _Res&&>\n         {\n+\t  // Used by std::promise to move construct the result.\n           typename promise<_Res>::_Ptr_type operator()()\n           {\n             _State_baseV2::_S_check(_M_promise->_M_future);\n@@ -431,6 +486,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       template<typename _Res>\n         struct _Setter<_Res, __exception_ptr_tag>\n         {\n+\t  // Used by std::promise to store an exception as the result.\n           typename promise<_Res>::_Ptr_type operator()()\n           {\n             _State_baseV2::_S_check(_M_promise->_M_future);\n@@ -465,6 +521,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n         }\n \n     private:\n+      // The function invoked with std::call_once(_M_once, ...).\n       void\n       _M_do_set(function<_Ptr_type()>* __f, unique_lock<mutex>* __lock)\n       {\n@@ -473,14 +530,18 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n         _M_result.swap(__res);\n       }\n \n-      bool _M_ready() const noexcept { return static_cast<bool>(_M_result); }\n-\n       // Wait for completion of async function.\n       virtual void _M_complete_async() { }\n \n-      // Return true if state contains a deferred function.\n-      // Caller must own _M_mutex.\n+      // Return true if state corresponds to a deferred function.\n       virtual bool _M_has_deferred() const { return false; }\n+\n+      struct _Make_ready final : __at_thread_exit_elt\n+      {\n+\tweak_ptr<_State_baseV2> _M_shared_state;\n+\tstatic void _S_run(void*);\n+\tvoid _M_set();\n+      };\n     };\n \n #ifdef _GLIBCXX_ASYNC_ABI_COMPAT\n@@ -531,7 +592,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n       _Result() noexcept : _M_value_ptr() { }\n \n-      void _M_set(_Res& __res) noexcept { _M_value_ptr = &__res; }\n+      void\n+      _M_set(_Res& __res) noexcept\n+      { _M_value_ptr = std::addressof(__res); }\n \n       _Res& _M_get() noexcept { return *_M_value_ptr; }\n \n@@ -1012,6 +1075,27 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       void\n       set_exception(exception_ptr __p)\n       { _M_future->_M_set_result(_State::__setter(__p, this)); }\n+\n+      void\n+      set_value_at_thread_exit(const _Res& __r)\n+      {\n+\t_M_future->_M_set_delayed_result(_State::__setter(this, __r),\n+\t\t\t\t\t _M_future);\n+      }\n+\n+      void\n+      set_value_at_thread_exit(_Res&& __r)\n+      {\n+\t_M_future->_M_set_delayed_result(\n+\t    _State::__setter(this, std::move(__r)), _M_future);\n+      }\n+\n+      void\n+      set_exception_at_thread_exit(exception_ptr __p)\n+      {\n+\t_M_future->_M_set_delayed_result(_State::__setter(__p, this),\n+\t\t\t\t\t _M_future);\n+      }\n     };\n \n   template<typename _Res>\n@@ -1097,6 +1181,20 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       void\n       set_exception(exception_ptr __p)\n       { _M_future->_M_set_result(_State::__setter(__p, this)); }\n+\n+      void\n+      set_value_at_thread_exit(_Res& __r)\n+      {\n+\t_M_future->_M_set_delayed_result(_State::__setter(this, __r),\n+\t\t\t\t\t _M_future);\n+      }\n+\n+      void\n+      set_exception_at_thread_exit(exception_ptr __p)\n+      {\n+\t_M_future->_M_set_delayed_result(_State::__setter(__p, this),\n+\t\t\t\t\t _M_future);\n+      }\n     };\n \n   /// Explicit specialization for promise<void>\n@@ -1172,6 +1270,16 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       void\n       set_exception(exception_ptr __p)\n       { _M_future->_M_set_result(_State::__setter(__p, this)); }\n+\n+      void\n+      set_value_at_thread_exit();\n+\n+      void\n+      set_exception_at_thread_exit(exception_ptr __p)\n+      {\n+\t_M_future->_M_set_delayed_result(_State::__setter(__p, this),\n+\t\t\t\t\t _M_future);\n+      }\n     };\n \n   // set void\n@@ -1191,9 +1299,17 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   promise<void>::set_value()\n   { _M_future->_M_set_result(_State::_Setter<void, void>{ this }); }\n \n+  inline void\n+  promise<void>::set_value_at_thread_exit()\n+  {\n+    _M_future->_M_set_delayed_result(_State::_Setter<void, void>{this},\n+\t\t\t\t     _M_future);\n+  }\n+\n   template<typename _Ptr_type, typename _Fn, typename _Res>\n     struct __future_base::_Task_setter\n     {\n+      // Invoke the function and provide the result to the caller.\n       _Ptr_type operator()()\n       {\n \t__try\n@@ -1237,6 +1353,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       _Fn*\t\t_M_fn;\n     };\n \n+  // Holds storage for a packaged_task's result.\n   template<typename _Res, typename... _Args>\n     struct __future_base::_Task_state_base<_Res(_Args...)>\n     : __future_base::_State_base\n@@ -1248,8 +1365,13 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t: _M_result(_S_allocate_result<_Res>(__a))\n \t{ }\n \n+      // Invoke the stored task and make the state ready.\n       virtual void\n-      _M_run(_Args... __args) = 0;\n+      _M_run(_Args&&... __args) = 0;\n+\n+      // Invoke the stored task and make the state ready at thread exit.\n+      virtual void\n+      _M_run_delayed(_Args&&... __args, weak_ptr<_State_base>) = 0;\n \n       virtual shared_ptr<_Task_state_base>\n       _M_reset() = 0;\n@@ -1258,6 +1380,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       _Ptr_type _M_result;\n     };\n \n+  // Holds a packaged_task's stored task.\n   template<typename _Fn, typename _Alloc, typename _Res, typename... _Args>\n     struct __future_base::_Task_state<_Fn, _Alloc, _Res(_Args...)> final\n     : __future_base::_Task_state_base<_Res(_Args...)>\n@@ -1270,14 +1393,24 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n     private:\n       virtual void\n-      _M_run(_Args... __args)\n+      _M_run(_Args&&... __args)\n       {\n \t// bound arguments decay so wrap lvalue references\n \tauto __boundfn = std::__bind_simple(std::ref(_M_impl._M_fn),\n \t    _S_maybe_wrap_ref(std::forward<_Args>(__args))...);\n \tthis->_M_set_result(_S_task_setter(this->_M_result, __boundfn));\n       }\n \n+      virtual void\n+      _M_run_delayed(_Args&&... __args, weak_ptr<_State_base> __self)\n+      {\n+\t// bound arguments decay so wrap lvalue references\n+\tauto __boundfn = std::__bind_simple(std::ref(_M_impl._M_fn),\n+\t    _S_maybe_wrap_ref(std::forward<_Args>(__args))...);\n+\tthis->_M_set_delayed_result(_S_task_setter(this->_M_result, __boundfn),\n+\t\t\t\t    std::move(__self));\n+      }\n+\n       virtual shared_ptr<_Task_state_base<_Res(_Args...)>>\n       _M_reset();\n \n@@ -1412,6 +1545,13 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t_M_state->_M_run(std::forward<_ArgTypes>(__args)...);\n       }\n \n+      void\n+      make_ready_at_thread_exit(_ArgTypes... __args)\n+      {\n+\t__future_base::_State_base::_S_check(_M_state);\n+\t_M_state->_M_run_delayed(std::forward<_ArgTypes>(__args)..., _M_state);\n+      }\n+\n       void\n       reset()\n       {\n@@ -1434,6 +1574,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     : public true_type { };\n \n \n+  // Shared state created by std::async().\n+  // Holds a deferred function and storage for its result.\n   template<typename _BoundFn, typename _Res>\n     class __future_base::_Deferred_state final\n     : public __future_base::_State_base\n@@ -1453,21 +1595,42 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       virtual void\n       _M_complete_async()\n       {\n-        // safe to call multiple times so ignore failure\n+\t// Multiple threads can call a waiting function on the future and\n+\t// reach this point at the same time. The call_once in _M_set_result\n+\t// ensures only the first one run the deferred function, stores the\n+\t// result in _M_result, swaps that with the base _M_result and makes\n+\t// the state ready. Tell _M_set_result to ignore failure so all later\n+\t// calls do nothing.\n         _M_set_result(_S_task_setter(_M_result, _M_fn), true);\n       }\n \n-      virtual bool\n-      _M_has_deferred() const { return static_cast<bool>(_M_result); }\n+      // Caller should check whether the state is ready first, because this\n+      // function will return true even after the deferred function has run.\n+      virtual bool _M_has_deferred() const { true; }\n     };\n \n+  // Common functionality hoisted out of the _Async_state_impl template.\n   class __future_base::_Async_state_commonV2\n     : public __future_base::_State_base\n   {\n   protected:\n     ~_Async_state_commonV2() = default;\n \n     // Make waiting functions block until the thread completes, as if joined.\n+    //\n+    // This function is used by wait() to satisfy the first requirement below\n+    // and by wait_for() / wait_until() to satisfy the second.\n+    //\n+    // [futures.async]:\n+    //\n+    // \u2014 a call to a waiting function on an asynchronous return object that\n+    // shares the shared state created by this async call shall block until\n+    // the associated thread has completed, as if joined, or else time out.\n+    //\n+    // \u2014 the associated thread completion synchronizes with the return from\n+    // the first function that successfully detects the ready status of the\n+    // shared state or with the return from the last function that releases\n+    // the shared state, whichever happens first.\n     virtual void _M_complete_async() { _M_join(); }\n \n     void _M_join() { std::call_once(_M_once, &thread::join, ref(_M_thread)); }\n@@ -1476,6 +1639,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     once_flag _M_once;\n   };\n \n+  // Shared state created by std::async().\n+  // Starts a new thread that runs a function and makes the shared state ready.\n   template<typename _BoundFn, typename _Res>\n     class __future_base::_Async_state_impl final\n     : public __future_base::_Async_state_commonV2\n@@ -1500,7 +1665,10 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n         } };\n       }\n \n-      ~_Async_state_impl() { _M_join(); }\n+      // Must not destroy _M_result and _M_fn until the thread finishes.\n+      // Call join() directly rather than through _M_join() because no other\n+      // thread can be referring to this state if it is being destroyed.\n+      ~_Async_state_impl() { if (_M_thread.joinable()) _M_thread.join(); }\n \n     private:\n       typedef __future_base::_Ptr<_Result<_Res>> _Ptr_type;"}, {"sha": "c2768eb86e4c72ab33e435808432a866875327e2", "filename": "libstdc++-v3/src/c++11/condition_variable.cc", "status": "modified", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9db7c9316e484499286d39d4c15e77310bedd3e9/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B11%2Fcondition_variable.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9db7c9316e484499286d39d4c15e77310bedd3e9/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B11%2Fcondition_variable.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B11%2Fcondition_variable.cc?ref=9db7c9316e484499286d39d4c15e77310bedd3e9", "patch": "@@ -77,6 +77,80 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       __throw_system_error(__e);\n   }\n \n+  extern void\n+  __at_thread_exit(__at_thread_exit_elt*);\n+\n+  namespace\n+  {\n+    __gthread_key_t key;\n+\n+    void run(void* p)\n+    {\n+      auto elt = (__at_thread_exit_elt*)p;\n+      while (elt)\n+\t{\n+\t  auto next = elt->_M_next;\n+\t  elt->_M_cb(elt);\n+\t  elt = next;\n+\t}\n+    }\n+\n+    void run()\n+    {\n+      auto elt = (__at_thread_exit_elt*)__gthread_getspecific(key);\n+      __gthread_setspecific(key, nullptr);\n+      run(elt);\n+    }\n+\n+    struct notifier final : __at_thread_exit_elt\n+    {\n+      notifier(condition_variable& cv, unique_lock<mutex>& l)\n+      : cv(&cv), mx(l.release())\n+      {\n+\t_M_cb = &notifier::run;\n+\t__at_thread_exit(this);\n+      }\n+\n+      ~notifier()\n+      {\n+\tmx->unlock();\n+\tcv->notify_all();\n+      }\n+\n+      condition_variable* cv;\n+      mutex* mx;\n+\n+      static void run(void* p) { delete static_cast<notifier*>(p); }\n+    };\n+\n+\n+    void key_init() {\n+      struct key_s {\n+\tkey_s() { __gthread_key_create (&key, run); }\n+\t~key_s() { __gthread_key_delete (key); }\n+      };\n+      static key_s ks;\n+      // Also make sure the callbacks are run by std::exit.\n+      std::atexit (run);\n+    }\n+  }\n+\n+  void\n+  __at_thread_exit(__at_thread_exit_elt* elt)\n+  {\n+    static __gthread_once_t once = __GTHREAD_ONCE_INIT;\n+    __gthread_once (&once, key_init);\n+\n+    elt->_M_next = (__at_thread_exit_elt*)__gthread_getspecific(key);\n+    __gthread_setspecific(key, elt);\n+  }\n+\n+  void\n+  notify_all_at_thread_exit(condition_variable& cv, unique_lock<mutex> l)\n+  {\n+    (void) new notifier{cv, l};\n+  }\n+\n _GLIBCXX_END_NAMESPACE_VERSION\n } // namespace\n "}, {"sha": "ca42dc19b8b570182615972410c03fcd2bbad9ac", "filename": "libstdc++-v3/src/c++11/future.cc", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9db7c9316e484499286d39d4c15e77310bedd3e9/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B11%2Ffuture.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9db7c9316e484499286d39d4c15e77310bedd3e9/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B11%2Ffuture.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B11%2Ffuture.cc?ref=9db7c9316e484499286d39d4c15e77310bedd3e9", "patch": "@@ -82,6 +82,31 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   __future_base::_Result_base::_Result_base() = default;\n \n   __future_base::_Result_base::~_Result_base() = default;\n+\n+  void\n+  __future_base::_State_baseV2::_Make_ready::_S_run(void* p)\n+  {\n+    unique_ptr<_Make_ready> mr{static_cast<_Make_ready*>(p)};\n+    if (auto state = mr->_M_shared_state.lock())\n+      {\n+\t{\n+\t  lock_guard<mutex> __lock{state->_M_mutex};\n+\t  state->_M_ready = true;\n+\t}\n+\tstate->_M_cond.notify_all();\n+      }\n+  }\n+\n+  // defined in src/c++11/condition_variable.cc\n+  extern void\n+  __at_thread_exit(__at_thread_exit_elt* elt);\n+\n+  void\n+  __future_base::_State_baseV2::_Make_ready::_M_set()\n+  {\n+    _M_cb = &_Make_ready::_S_run;\n+    __at_thread_exit(this);\n+  }\n #endif\n \n _GLIBCXX_END_NAMESPACE_VERSION"}, {"sha": "0da545d1439c47af75c567303adf85e9f4f454ca", "filename": "libstdc++-v3/testsuite/30_threads/condition_variable/members/3.cc", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9db7c9316e484499286d39d4c15e77310bedd3e9/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fcondition_variable%2Fmembers%2F3.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9db7c9316e484499286d39d4c15e77310bedd3e9/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fcondition_variable%2Fmembers%2F3.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fcondition_variable%2Fmembers%2F3.cc?ref=9db7c9316e484499286d39d4c15e77310bedd3e9", "patch": "@@ -0,0 +1,55 @@\n+// { dg-do run { target *-*-freebsd* *-*-dragonfly* *-*-netbsd* *-*-linux* *-*-gnu* *-*-solaris* *-*-cygwin *-*-darwin* powerpc-ibm-aix* } }\n+// { dg-options \" -std=gnu++11 -pthread\" { target *-*-freebsd* *-*-dragonfly* *-*-netbsd* *-*-linux* *-*-gnu* powerpc-ibm-aix* } }\n+// { dg-options \" -std=gnu++11 -pthreads\" { target *-*-solaris* } }\n+// { dg-options \" -std=gnu++11 \" { target *-*-cygwin *-*-darwin* } }\n+// { dg-require-cstdint \"\" }\n+// { dg-require-gthreads \"\" }\n+\n+// Copyright (C) 2014 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <condition_variable>\n+#include <thread>\n+#include <mutex>\n+\n+std::mutex mx;\n+std::condition_variable cv;\n+int counter = 0;\n+\n+struct Inc\n+{\n+  Inc() { ++counter; }\n+  ~Inc() { ++counter; }\n+};\n+\n+\n+void func()\n+{\n+  std::unique_lock<std::mutex> lock{mx};\n+  std::notify_all_at_thread_exit(cv, std::move(lock));\n+  static thread_local Inc inc;\n+}\n+\n+int main()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  std::unique_lock<std::mutex> lock{mx};\n+  std::thread t{func};\n+  cv.wait(lock, [&]{ return counter == 2; });\n+  t.join();\n+}"}, {"sha": "5bbdd3da670802b25585558849f1589a91b87457", "filename": "libstdc++-v3/testsuite/30_threads/packaged_task/members/at_thread_exit.cc", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9db7c9316e484499286d39d4c15e77310bedd3e9/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fpackaged_task%2Fmembers%2Fat_thread_exit.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9db7c9316e484499286d39d4c15e77310bedd3e9/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fpackaged_task%2Fmembers%2Fat_thread_exit.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fpackaged_task%2Fmembers%2Fat_thread_exit.cc?ref=9db7c9316e484499286d39d4c15e77310bedd3e9", "patch": "@@ -0,0 +1,61 @@\n+// { dg-do run { target *-*-freebsd* *-*-dragonfly* *-*-netbsd* *-*-linux* *-*-gnu* *-*-solaris* *-*-cygwin *-*-darwin* powerpc-ibm-aix* } }\n+// { dg-options \" -std=gnu++11 -pthread\" { target *-*-freebsd* *-*-dragonfly* *-*-netbsd* *-*-linux* *-*-gnu* powerpc-ibm-aix* } }\n+// { dg-options \" -std=gnu++11 -pthreads\" { target *-*-solaris* } }\n+// { dg-options \" -std=gnu++11 \" { target *-*-cygwin *-*-darwin* } }\n+// { dg-require-cstdint \"\" }\n+// { dg-require-gthreads \"\" }\n+// { dg-require-atomic-builtins \"\" }\n+\n+// Copyright (C) 2014 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+\n+#include <future>\n+#include <testsuite_hooks.h>\n+\n+bool executed = false;\n+\n+int execute(int i) { executed = true; return i + 1; }\n+\n+std::future<int> f1;\n+\n+bool ready(std::future<int>& f)\n+{\n+  return f.wait_for(std::chrono::milliseconds(1)) == std::future_status::ready;\n+}\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  std::packaged_task<int(int)> p1(execute);\n+  f1 = p1.get_future();\n+\n+  p1.make_ready_at_thread_exit(1);\n+\n+  VERIFY( executed );\n+  VERIFY( p1.valid() );\n+  VERIFY( !ready(f1) );\n+}\n+\n+int main()\n+{\n+  std::thread t{test01};\n+  t.join();\n+  VERIFY( ready(f1) );\n+  VERIFY( f1.get() == 2 );\n+}"}, {"sha": "3842a131688b928bdbae12783a2992dc63e5c742", "filename": "libstdc++-v3/testsuite/30_threads/promise/members/at_thread_exit.cc", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9db7c9316e484499286d39d4c15e77310bedd3e9/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fpromise%2Fmembers%2Fat_thread_exit.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9db7c9316e484499286d39d4c15e77310bedd3e9/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fpromise%2Fmembers%2Fat_thread_exit.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fpromise%2Fmembers%2Fat_thread_exit.cc?ref=9db7c9316e484499286d39d4c15e77310bedd3e9", "patch": "@@ -0,0 +1,66 @@\n+// { dg-do run { target *-*-freebsd* *-*-dragonfly* *-*-netbsd* *-*-linux* *-*-gnu* *-*-solaris* *-*-cygwin *-*-darwin* powerpc-ibm-aix* } }\n+// { dg-options \" -std=gnu++11 -pthread\" { target *-*-freebsd* *-*-dragonfly* *-*-netbsd* *-*-linux* *-*-gnu* powerpc-ibm-aix* } }\n+// { dg-options \" -std=gnu++11 -pthreads\" { target *-*-solaris* } }\n+// { dg-options \" -std=gnu++11 \" { target *-*-cygwin *-*-darwin* } }\n+// { dg-require-cstdint \"\" }\n+// { dg-require-gthreads \"\" }\n+// { dg-require-atomic-builtins \"\" }\n+\n+// Copyright (C) 2014 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+\n+#include <future>\n+#include <testsuite_hooks.h>\n+\n+int copies;\n+int copies_cmp;\n+\n+struct Obj\n+{\n+  Obj() = default;\n+  Obj(const Obj&) { ++copies; }\n+};\n+\n+std::future<Obj> f1;\n+\n+bool ready(std::future<Obj>& f)\n+{\n+  return f.wait_for(std::chrono::milliseconds(1)) == std::future_status::ready;\n+}\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  std::promise<Obj> p1;\n+  f1 = p1.get_future();\n+\n+  p1.set_value_at_thread_exit( {} );\n+\n+  copies_cmp = copies;\n+\n+  VERIFY( !ready(f1) );\n+}\n+\n+int main()\n+{\n+  std::thread t{test01};\n+  t.join();\n+  VERIFY( ready(f1) );\n+  VERIFY( copies == copies_cmp );\n+}"}]}