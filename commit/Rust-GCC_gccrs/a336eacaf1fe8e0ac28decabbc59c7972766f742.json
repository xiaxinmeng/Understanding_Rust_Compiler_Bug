{"sha": "a336eacaf1fe8e0ac28decabbc59c7972766f742", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTMzNmVhY2FmMWZlOGUwYWMyOGRlY2FiYmM1OWM3OTcyNzY2Zjc0Mg==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2004-03-18T15:18:36Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2004-03-18T15:18:36Z"}, "message": "[multiple changes]\n\n2004-03-18  Arnaud Charlet  <charlet@act-europe.fr>\n\n\t* 5atpopsp.adb: Remove RTEMS from list of platforms using this file.\n\n\tCode clean up:\n\t* 5ataprop.adb, 5ftaprop.adb, 5htaprop.adb, 5itaprop.adb, 5staprop.adb,\n\t5vtaprop.adb, 5wtaprop.adb, 7staprop.adb (Finalize_TCB): Use\n\tSpecific.Set instead of direct call to e.g pthread_setspecific.\n\n2004-03-18  Thomas Quinot  <quinot@act-europe.fr>\n\n\t* adaint.c: Update comments.\n\n\t* Makefile.in: set PREFIX_OBJS, SYMLIB, THREADSLIB, and\n\tGNATLIB_SHARED for FreeBSD.\n\n2004-03-18  Jose Ruiz  <ruiz@act-europe.fr>\n\n\t* init.c [VxWorks]: Do not fix the stack size for the environment task.\n\tWhen needed (stack checking) the stack size is retrieved\n\tfrom the VxWorks kernel.\n\n\t* Makefile.in: Flag -nostdinc is required when building the run time\n\tfor avoiding looking for files in the base compiler.\n\tAdd the VxWorks specific version of the package body for\n\tSystem.Stack_checking.Operations (5zstchop.adb).\n\n\t* Make-lang.in: Add the object file for\n\tSystem.Stack_Checking.Operations.\n\n\t* Makefile.rtl: Add object file for the package\n\tSystem.Stack_Checking.Operations.\n\n\t* s-stchop.ads, s-stchop.adb, 5zstchop.adb: New files.\n\n\t* s-stache.ads, s-stache.adb: Move the operations related to stack\n\tchecking from this package to package System.Stack_Checking.Operations.\n\tThis way, stack checking operations are only linked in the final\n\texecutable when using the -fstack-check flag.\n\n2004-03-18  Doug Rupp  <rupp@gnat.com>\n\n\t* Makefile.in [VMS]: Handle 64 bit specs (5qsystem.ads, 5xcrtl.ads).\n\tReorganize ifeq's.\n\n\t* 5qsystem.ads, 5xcrtl.ads: New files.\n\n2004-03-18  Vincent Celier  <celier@gnat.com>\n\n\t* prj.adb (Reset): Reset hash table Files_Htable\n\n\t* prj-env.adb (Source_Paths, Object_Paths): New tables.\n\t(Add_To_Source_Path, Add_To_Object_Path): New procedures, to replace\n\tthe procedures Add_To_Path_File.\n\t(Set_Ada_Paths): Accumulate source and object dirs in the tables,\n\tmaking sure that each directory is present only once and, for object\n\tdirs, when a directory already present is added, the duplicate is\n\tremoved and the directory is always put as the last in the table.\n\tWrite the path files at the end of these accumulations.\n\n\t* prj-nmsc.adb (Record_Source): Add source file name in hash table\n\tFiles_Htable for all sources.\n\n\t* prj-proc.adb (Process): Remove restrictions between not directly\n\trelated extending projects.\n\n2004-03-18  Emmanuel Briot  <briot@act-europe.fr>\n\n\t* prj-nmsc.ads, prj-nmsc.adb (Ada_Check): New parameter Trusted_Mode.\n\t(Find_Sources): Minor speed optimization.\n\n\t* prj-proc.ads, prj-proc.adb (Check, Recursive_Check, Process): New\n\tparameter Trusted_Mode.\n\n2004-03-18  Sergey Rybin  <rybin@act-europe.fr>\n\n\t* scn.adb (Determine_License): Take into account a degenerated case\n\twhen the source contains only comments.\n\n2004-03-18  Ed Schonberg  <schonberg@gnat.com>\n\n\t* sem_warn.adb (Check_References): For a warning on a selected\n\tcomponent that does not come from source, locate an uninitialized\n\tcomponent of the record type to produce a more precise error message.\n\nFrom-SVN: r79623", "tree": {"sha": "c005e46c28cc0d31445b8654f494f202ecaac7fd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c005e46c28cc0d31445b8654f494f202ecaac7fd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a336eacaf1fe8e0ac28decabbc59c7972766f742", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a336eacaf1fe8e0ac28decabbc59c7972766f742", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a336eacaf1fe8e0ac28decabbc59c7972766f742", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a336eacaf1fe8e0ac28decabbc59c7972766f742/comments", "author": null, "committer": null, "parents": [{"sha": "214ee4a2c634d178c3725178a36c341bb08c4397", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/214ee4a2c634d178c3725178a36c341bb08c4397", "html_url": "https://github.com/Rust-GCC/gccrs/commit/214ee4a2c634d178c3725178a36c341bb08c4397"}], "stats": {"total": 1973, "additions": 1425, "deletions": 548}, "files": [{"sha": "1fa1c22fa4b1c8ba486beb3c08a3b70bf3b54bde", "filename": "gcc/ada/5ataprop.adb", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a336eacaf1fe8e0ac28decabbc59c7972766f742/gcc%2Fada%2F5ataprop.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a336eacaf1fe8e0ac28decabbc59c7972766f742/gcc%2Fada%2F5ataprop.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5ataprop.adb?ref=a336eacaf1fe8e0ac28decabbc59c7972766f742", "patch": "@@ -921,8 +921,8 @@ package body System.Task_Primitives.Operations is\n    ------------------\n \n    procedure Finalize_TCB (T : Task_ID) is\n-      Result : Interfaces.C.int;\n-      Tmp    : Task_ID := T;\n+      Result  : Interfaces.C.int;\n+      Tmp     : Task_ID := T;\n       Is_Self : constant Boolean := T = Self;\n \n       procedure Free is new\n@@ -944,10 +944,8 @@ package body System.Task_Primitives.Operations is\n       Free (Tmp);\n \n       if Is_Self then\n-         Result := pthread_setspecific (ATCB_Key, System.Null_Address);\n-         pragma Assert (Result = 0);\n+         Specific.Set (null);\n       end if;\n-\n    end Finalize_TCB;\n \n    ---------------"}, {"sha": "c1c0815c79014c3e6b502b8a109708648e31174e", "filename": "gcc/ada/5atpopsp.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a336eacaf1fe8e0ac28decabbc59c7972766f742/gcc%2Fada%2F5atpopsp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a336eacaf1fe8e0ac28decabbc59c7972766f742/gcc%2Fada%2F5atpopsp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5atpopsp.adb?ref=a336eacaf1fe8e0ac28decabbc59c7972766f742", "patch": "@@ -34,8 +34,8 @@\n --  This is a POSIX version of this package where foreign threads are\n --  recognized.\n \n---  Currently, DEC Unix, SCO UnixWare, Solaris pthread, HPUX pthread,\n---  GNU/Linux threads, and RTEMS use this version.\n+--  Currently, DEC Unix, SCO UnixWare, Solaris pthread, HPUX pthread and\n+--  GNU/Linux threads use this version.\n \n separate (System.Task_Primitives.Operations)\n package body Specific is"}, {"sha": "6eb6e2ad52a1847c558c3a32464b3840e2a79c04", "filename": "gcc/ada/5ftaprop.adb", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a336eacaf1fe8e0ac28decabbc59c7972766f742/gcc%2Fada%2F5ftaprop.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a336eacaf1fe8e0ac28decabbc59c7972766f742/gcc%2Fada%2F5ftaprop.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5ftaprop.adb?ref=a336eacaf1fe8e0ac28decabbc59c7972766f742", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                  B o d y                                 --\n --                                                                          --\n---         Copyright (C) 1992-2003, Free Software Foundation, Inc.          --\n+--         Copyright (C) 1992-2004, Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -916,8 +916,8 @@ package body System.Task_Primitives.Operations is\n    ------------------\n \n    procedure Finalize_TCB (T : Task_ID) is\n-      Result : Interfaces.C.int;\n-      Tmp    : Task_ID := T;\n+      Result  : Interfaces.C.int;\n+      Tmp     : Task_ID := T;\n       Is_Self : constant Boolean := T = Self;\n \n       procedure Free is new\n@@ -939,10 +939,8 @@ package body System.Task_Primitives.Operations is\n       Free (Tmp);\n \n       if Is_Self then\n-         Result := pthread_setspecific (ATCB_Key, System.Null_Address);\n-         pragma Assert (Result = 0);\n+         Specific.Set (null);\n       end if;\n-\n    end Finalize_TCB;\n \n    ---------------"}, {"sha": "1aaf3c26c56f7f9c8401f0f282de47bf1044f58c", "filename": "gcc/ada/5htaprop.adb", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a336eacaf1fe8e0ac28decabbc59c7972766f742/gcc%2Fada%2F5htaprop.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a336eacaf1fe8e0ac28decabbc59c7972766f742/gcc%2Fada%2F5htaprop.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5htaprop.adb?ref=a336eacaf1fe8e0ac28decabbc59c7972766f742", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                  B o d y                                 --\n --                                                                          --\n---         Copyright (C) 1992-2003, Free Software Foundation, Inc.          --\n+--         Copyright (C) 1992-2004, Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -862,8 +862,8 @@ package body System.Task_Primitives.Operations is\n    ------------------\n \n    procedure Finalize_TCB (T : Task_ID) is\n-      Result : Interfaces.C.int;\n-      Tmp    : Task_ID := T;\n+      Result  : Interfaces.C.int;\n+      Tmp     : Task_ID := T;\n       Is_Self : constant Boolean := T = Self;\n \n       procedure Free is new\n@@ -885,10 +885,8 @@ package body System.Task_Primitives.Operations is\n       Free (Tmp);\n \n       if Is_Self then\n-         Result := pthread_setspecific (ATCB_Key, System.Null_Address);\n-         pragma Assert (Result = 0);\n+         Specific.Set (null);\n       end if;\n-\n    end Finalize_TCB;\n \n    ---------------"}, {"sha": "6ab670f97224ad47e55f1148fc734eb963dbbd5b", "filename": "gcc/ada/5itaprop.adb", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a336eacaf1fe8e0ac28decabbc59c7972766f742/gcc%2Fada%2F5itaprop.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a336eacaf1fe8e0ac28decabbc59c7972766f742/gcc%2Fada%2F5itaprop.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5itaprop.adb?ref=a336eacaf1fe8e0ac28decabbc59c7972766f742", "patch": "@@ -891,8 +891,8 @@ package body System.Task_Primitives.Operations is\n    ------------------\n \n    procedure Finalize_TCB (T : Task_ID) is\n-      Result : Interfaces.C.int;\n-      Tmp    : Task_ID := T;\n+      Result  : Interfaces.C.int;\n+      Tmp     : Task_ID := T;\n       Is_Self : constant Boolean := T = Self;\n \n       procedure Free is new\n@@ -914,10 +914,8 @@ package body System.Task_Primitives.Operations is\n       Free (Tmp);\n \n       if Is_Self then\n-         Result := pthread_setspecific (ATCB_Key, System.Null_Address);\n-         pragma Assert (Result = 0);\n+         Specific.Set (null);\n       end if;\n-\n    end Finalize_TCB;\n \n    ---------------"}, {"sha": "4d17cdacde56e595f104cbc37a2085c6c2762997", "filename": "gcc/ada/5qsystem.ads", "status": "added", "additions": 236, "deletions": 0, "changes": 236, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a336eacaf1fe8e0ac28decabbc59c7972766f742/gcc%2Fada%2F5qsystem.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a336eacaf1fe8e0ac28decabbc59c7972766f742/gcc%2Fada%2F5qsystem.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5qsystem.ads?ref=a336eacaf1fe8e0ac28decabbc59c7972766f742", "patch": "@@ -0,0 +1,236 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                        GNAT RUN-TIME COMPONENTS                          --\n+--                                                                          --\n+--                               S Y S T E M                                --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                (OpenVMS 64bit GCC_ZCX DEC Threads Version)               --\n+--                                                                          --\n+--             Copyright (C) 2004 Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- This specification is derived from the Ada Reference Manual for use with --\n+-- GNAT. The copyright notice above, and the license provisions that follow --\n+-- apply solely to the  contents of the part following the private keyword. --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+package System is\n+pragma Pure (System);\n+--  Note that we take advantage of the implementation permission to\n+--  make this unit Pure instead of Preelaborable, see RM 13.7(36)\n+\n+   type Name is (SYSTEM_NAME_GNAT);\n+   System_Name : constant Name := SYSTEM_NAME_GNAT;\n+\n+   --  System-Dependent Named Numbers\n+\n+   Min_Int               : constant := Long_Long_Integer'First;\n+   Max_Int               : constant := Long_Long_Integer'Last;\n+\n+   Max_Binary_Modulus    : constant := 2 ** Long_Long_Integer'Size;\n+   Max_Nonbinary_Modulus : constant := Integer'Last;\n+\n+   Max_Base_Digits       : constant := Long_Long_Float'Digits;\n+   Max_Digits            : constant := Long_Long_Float'Digits;\n+\n+   Max_Mantissa          : constant := 63;\n+   Fine_Delta            : constant := 2.0 ** (-Max_Mantissa);\n+\n+   Tick                  : constant := 0.01;\n+\n+   --  Storage-related Declarations\n+\n+   type Address is private;\n+   Null_Address : constant Address;\n+\n+   Storage_Unit : constant := 8;\n+   Word_Size    : constant := 64;\n+   Memory_Size  : constant := 2 ** 64;\n+\n+   --  Address comparison\n+\n+   function \"<\"  (Left, Right : Address) return Boolean;\n+   function \"<=\" (Left, Right : Address) return Boolean;\n+   function \">\"  (Left, Right : Address) return Boolean;\n+   function \">=\" (Left, Right : Address) return Boolean;\n+   function \"=\"  (Left, Right : Address) return Boolean;\n+\n+   pragma Import (Intrinsic, \"<\");\n+   pragma Import (Intrinsic, \"<=\");\n+   pragma Import (Intrinsic, \">\");\n+   pragma Import (Intrinsic, \">=\");\n+   pragma Import (Intrinsic, \"=\");\n+\n+   --  Other System-Dependent Declarations\n+\n+   type Bit_Order is (High_Order_First, Low_Order_First);\n+   Default_Bit_Order : constant Bit_Order := Low_Order_First;\n+\n+   --  Priority-related Declarations (RM D.1)\n+\n+   Max_Priority           : constant Positive := 30;\n+   Max_Interrupt_Priority : constant Positive := 31;\n+\n+   subtype Any_Priority       is Integer      range  0 .. 31;\n+   subtype Priority           is Any_Priority range  0 .. 30;\n+   subtype Interrupt_Priority is Any_Priority range 31 .. 31;\n+\n+   Default_Priority : constant Priority := 15;\n+\n+private\n+\n+   type Address is mod Memory_Size;\n+   Null_Address : constant Address := 0;\n+\n+   --------------------------------------\n+   -- System Implementation Parameters --\n+   --------------------------------------\n+\n+   --  These parameters provide information about the target that is used\n+   --  by the compiler. They are in the private part of System, where they\n+   --  can be accessed using the special circuitry in the Targparm unit\n+   --  whose source should be consulted for more detailed descriptions\n+   --  of the individual switch values.\n+\n+   AAMP                      : constant Boolean := False;\n+   Backend_Divide_Checks     : constant Boolean := False;\n+   Backend_Overflow_Checks   : constant Boolean := False;\n+   Command_Line_Args         : constant Boolean := True;\n+   Configurable_Run_Time     : constant Boolean := False;\n+   Denorm                    : constant Boolean := False;\n+   Duration_32_Bits          : constant Boolean := False;\n+   Exit_Status_Supported     : constant Boolean := True;\n+   Fractional_Fixed_Ops      : constant Boolean := False;\n+   Frontend_Layout           : constant Boolean := False;\n+   Functions_Return_By_DSP   : constant Boolean := False;\n+   Machine_Overflows         : constant Boolean := False;\n+   Machine_Rounds            : constant Boolean := True;\n+   OpenVMS                   : constant Boolean := True;\n+   Signed_Zeros              : constant Boolean := True;\n+   Stack_Check_Default       : constant Boolean := True;\n+   Stack_Check_Probes        : constant Boolean := True;\n+   Support_64_Bit_Divides    : constant Boolean := True;\n+   Support_Aggregates        : constant Boolean := True;\n+   Support_Composite_Assign  : constant Boolean := True;\n+   Support_Composite_Compare : constant Boolean := True;\n+   Support_Long_Shifts       : constant Boolean := True;\n+   Suppress_Standard_Library : constant Boolean := False;\n+   Use_Ada_Main_Program_Name : constant Boolean := False;\n+   ZCX_By_Default            : constant Boolean := True;\n+   GCC_ZCX_Support           : constant Boolean := True;\n+   Front_End_ZCX_Support     : constant Boolean := False;\n+\n+   --  Obsolete entries, to be removed eventually (bootstrap issues!)\n+\n+   High_Integrity_Mode       : constant Boolean := False;\n+   Long_Shifts_Inlined       : constant Boolean := False;\n+\n+   --------------------------\n+   -- Underlying Priorities --\n+   ---------------------------\n+\n+   --  Important note: this section of the file must come AFTER the\n+   --  definition of the system implementation parameters to ensure\n+   --  that the value of these parameters is available for analysis\n+   --  of the declarations here (using Rtsfind at compile time).\n+\n+   --  The underlying priorities table provides a generalized mechanism\n+   --  for mapping from Ada priorities to system priorities. In some\n+   --  cases a 1-1 mapping is not the convenient or optimal choice.\n+\n+   --  For DEC Threads OpenVMS, we use the full range of 31 priorities\n+   --  in the Ada model, but map them by compression onto the more limited\n+   --  range of priorities available in OpenVMS.\n+\n+   --  To replace the default values of the Underlying_Priorities mapping,\n+   --  copy this source file into your build directory, edit the file to\n+   --  reflect your desired behavior, and recompile with the command:\n+\n+   --     $ gcc -c -O3 -gnatpgn system.ads\n+\n+   --  then recompile the run-time parts that depend on this package:\n+\n+   --     $ gnatmake -a -gnatn -O3 <your application>\n+\n+   --  then force rebuilding your application if you need different options:\n+\n+   --     $ gnatmake -f <your options> <your application>\n+\n+   type Priorities_Mapping is array (Any_Priority) of Integer;\n+   pragma Suppress_Initialization (Priorities_Mapping);\n+   --  Suppress initialization in case gnat.adc specifies Normalize_Scalars\n+\n+   Underlying_Priorities : constant Priorities_Mapping :=\n+\n+     (Priority'First => 16,\n+\n+      1  => 17,\n+      2  => 18,\n+      3  => 18,\n+      4  => 18,\n+      5  => 18,\n+      6  => 19,\n+      7  => 19,\n+      8  => 19,\n+      9  => 20,\n+      10 => 20,\n+      11 => 21,\n+      12 => 21,\n+      13 => 22,\n+      14 => 23,\n+\n+      Default_Priority   => 24,\n+\n+      16 => 25,\n+      17 => 25,\n+      18 => 25,\n+      19 => 26,\n+      20 => 26,\n+      21 => 26,\n+      22 => 27,\n+      23 => 27,\n+      24 => 27,\n+      25 => 28,\n+      26 => 28,\n+      27 => 29,\n+      28 => 29,\n+      29 => 30,\n+\n+      Priority'Last      => 30,\n+\n+      Interrupt_Priority => 31);\n+\n+   ----------------------------\n+   -- Special VMS Interfaces --\n+   ----------------------------\n+\n+   procedure Lib_Stop (I : in Integer);\n+   pragma Interface (C, Lib_Stop);\n+   pragma Import_Procedure (Lib_Stop, \"LIB$STOP\", Mechanism => (Value));\n+   --  Interface to VMS condition handling. Used by RTSfind and pragma\n+   --  {Import,Export}_Exception. Put here because this is the only\n+   --  VMS specific package that doesn't drag in tasking.\n+\n+end System;"}, {"sha": "0242b0aefa8765c4b667452141ef2462e6a9f2df", "filename": "gcc/ada/5staprop.adb", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a336eacaf1fe8e0ac28decabbc59c7972766f742/gcc%2Fada%2F5staprop.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a336eacaf1fe8e0ac28decabbc59c7972766f742/gcc%2Fada%2F5staprop.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5staprop.adb?ref=a336eacaf1fe8e0ac28decabbc59c7972766f742", "patch": "@@ -882,7 +882,6 @@ package body System.Task_Primitives.Operations is\n    -----------------------------\n \n    function Register_Foreign_Thread return Task_ID is\n-\n    begin\n       if Is_Valid_Task then\n          return Self;\n@@ -1037,7 +1036,6 @@ package body System.Task_Primitives.Operations is\n       if Is_Self then\n          Specific.Set (null);\n       end if;\n-\n    end Finalize_TCB;\n \n    ---------------"}, {"sha": "fd6c98baefa83893f8469d3dd847da43b70463c2", "filename": "gcc/ada/5vtaprop.adb", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a336eacaf1fe8e0ac28decabbc59c7972766f742/gcc%2Fada%2F5vtaprop.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a336eacaf1fe8e0ac28decabbc59c7972766f742/gcc%2Fada%2F5vtaprop.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5vtaprop.adb?ref=a336eacaf1fe8e0ac28decabbc59c7972766f742", "patch": "@@ -879,8 +879,7 @@ package body System.Task_Primitives.Operations is\n       Free (Tmp);\n \n       if Is_Self then\n-         Result := pthread_setspecific (ATCB_Key, System.Null_Address);\n-         pragma Assert (Result = 0);\n+         Specific.Set (null);\n       end if;\n    end Finalize_TCB;\n "}, {"sha": "1e24de0c6ecdb6649c820635f95617ca850ce1fc", "filename": "gcc/ada/5wtaprop.adb", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a336eacaf1fe8e0ac28decabbc59c7972766f742/gcc%2Fada%2F5wtaprop.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a336eacaf1fe8e0ac28decabbc59c7972766f742/gcc%2Fada%2F5wtaprop.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5wtaprop.adb?ref=a336eacaf1fe8e0ac28decabbc59c7972766f742", "patch": "@@ -913,7 +913,7 @@ package body System.Task_Primitives.Operations is\n       Self_ID   : Task_ID := T;\n       Result    : DWORD;\n       Succeeded : BOOL;\n-      Is_Self : constant Boolean := T = Self;\n+      Is_Self   : constant Boolean := T = Self;\n \n       procedure Free is new\n         Unchecked_Deallocation (Ada_Task_Control_Block, Task_ID);\n@@ -943,8 +943,7 @@ package body System.Task_Primitives.Operations is\n       Free (Self_ID);\n \n       if Is_Self then\n-         Succeeded := TlsSetValue (TlsIndex, System.Null_Address);\n-         pragma Assert (Succeeded = True);\n+         Specific.Set (null);\n       end if;\n    end Finalize_TCB;\n "}, {"sha": "dd3292e384a97171c6b99db3bc3121a91095b9e8", "filename": "gcc/ada/5xcrtl.ads", "status": "added", "additions": 159, "deletions": 0, "changes": 159, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a336eacaf1fe8e0ac28decabbc59c7972766f742/gcc%2Fada%2F5xcrtl.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a336eacaf1fe8e0ac28decabbc59c7972766f742/gcc%2Fada%2F5xcrtl.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5xcrtl.ads?ref=a336eacaf1fe8e0ac28decabbc59c7972766f742", "patch": "@@ -0,0 +1,159 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                        GNAT RUN-TIME COMPONENTS                          --\n+--                                                                          --\n+--                         S Y S T E M . C R T L                            --\n+--                                                                          --\n+--                                S p e c                                   --\n+--                                                                          --\n+--           Copyright (C) 2004 Free Software Foundation, Inc.              --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This package provides the low level interface to the C Run Time Library\n+--  on 64 bit VMS\n+\n+with System.Parameters;\n+package System.CRTL is\n+pragma Preelaborate (CRTL);\n+\n+   subtype chars is System.Address;\n+   --  Pointer to null-terminated array of characters\n+\n+   subtype FILEs is System.Address;\n+   --  Corresponds to the C type FILE*\n+\n+   subtype int is Integer;\n+\n+   type long is range -(2 ** (System.Parameters.long_bits - 1))\n+      .. +(2 ** (System.Parameters.long_bits - 1)) - 1;\n+\n+   subtype off_t is Integer;\n+\n+   type size_t is mod 2 ** Standard'Address_Size;\n+\n+   function atoi (A : System.Address) return Integer;\n+   pragma Import (C, atoi, \"decc$atoi\");\n+\n+   procedure clearerr (stream : FILEs);\n+   pragma Import (C, clearerr, \"decc$clearerr\");\n+\n+   function fclose (stream : FILEs) return int;\n+   pragma Import (C, fclose, \"decc$fclose\");\n+\n+   function fdopen (handle : int; mode : chars) return FILEs;\n+   pragma Import (C, fdopen, \"decc$fdopen\");\n+\n+   function fflush (stream : FILEs) return int;\n+   pragma Import (C, fflush, \"decc$fflush\");\n+\n+   function fgetc (stream : FILEs) return int;\n+   pragma Import (C, fgetc, \"decc$fgetc\");\n+\n+   function fgets (strng : chars; n : int; stream : FILEs) return chars;\n+   pragma Import (C, fgets, \"decc$fgets\");\n+\n+   function fopen (filename : chars; Mode : chars) return FILEs;\n+   pragma Import (C, fopen, \"decc$fopen\");\n+\n+   function fputc (C : int; stream : FILEs) return int;\n+   pragma Import (C, fputc, \"decc$fputc\");\n+\n+   function fputs (Strng : chars; Stream : FILEs) return int;\n+   pragma Import (C, fputs, \"decc$fputs\");\n+\n+   procedure free (Ptr : System.Address);\n+   pragma Import (C, free, \"decc$free\");\n+\n+   function freopen\n+     (filename : chars;\n+      mode     : chars;\n+      stream   : FILEs)\n+      return     FILEs;\n+   pragma Import (C, freopen, \"decc$freopen\");\n+\n+   function fseek\n+     (stream : FILEs;\n+      offset : long;\n+      origin : int)\n+      return   int;\n+   pragma Import (C, fseek, \"decc$fseek\");\n+\n+   function ftell (stream : FILEs) return long;\n+   pragma Import (C, ftell, \"decc$ftell\");\n+\n+   function getenv (S : String) return System.Address;\n+   pragma Import (C, getenv, \"decc$getenv\");\n+\n+   function isatty (handle : int) return int;\n+   pragma Import (C, isatty, \"decc$isatty\");\n+\n+   function lseek (fd : int; offset : off_t; direction : int) return off_t;\n+   pragma Import (C, lseek, \"decc$lseek\");\n+\n+   function malloc (Size : size_t) return System.Address;\n+   pragma Import (C, malloc, \"decc$_malloc64\");\n+\n+   procedure memcpy (S1 : System.Address; S2 : System.Address; N : size_t);\n+   pragma Import (C, memcpy, \"decc$_memcpy64\");\n+\n+   procedure memmove (S1 : System.Address; S2 : System.Address; N : size_t);\n+   pragma Import (C, memmove, \"decc$_memmove64\");\n+\n+   procedure mktemp (template : chars);\n+   pragma Import (C, mktemp, \"decc$_mktemp64\");\n+\n+   function read (fd : int; buffer : chars; nbytes : int) return int;\n+   pragma Import (C, read, \"decc$read\");\n+\n+   function realloc\n+     (Ptr : System.Address; Size : size_t) return System.Address;\n+   pragma Import (C, realloc, \"decc$_realloc64\");\n+\n+   procedure rewind (stream : FILEs);\n+   pragma Import (C, rewind, \"decc$rewind\");\n+\n+   function setvbuf\n+     (stream : FILEs;\n+      buffer : chars;\n+      mode   : int;\n+      size   : size_t)\n+      return   int;\n+   pragma Import (C, setvbuf, \"decc$setvbuf\");\n+\n+   procedure tmpnam (string : chars);\n+   pragma Import (C, tmpnam, \"decc$_tmpnam64\");\n+\n+   function tmpfile return FILEs;\n+   pragma Import (C, tmpfile, \"decc$tmpfile\");\n+\n+   function ungetc (c : int; stream : FILEs) return int;\n+   pragma Import (C, ungetc, \"decc$ungetc\");\n+\n+   function unlink (filename : chars) return int;\n+   pragma Import (C, unlink, \"decc$unlink\");\n+\n+   function write (fd : int; buffer : chars; nbytes : int) return int;\n+   pragma Import (C, write, \"decc$write\");\n+end System.CRTL;"}, {"sha": "b19bb56f27499d6f26e2ffa22c689e7d1866dc4b", "filename": "gcc/ada/5zstchop.adb", "status": "added", "additions": 255, "deletions": 0, "changes": 255, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a336eacaf1fe8e0ac28decabbc59c7972766f742/gcc%2Fada%2F5zstchop.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a336eacaf1fe8e0ac28decabbc59c7972766f742/gcc%2Fada%2F5zstchop.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5zstchop.adb?ref=a336eacaf1fe8e0ac28decabbc59c7972766f742", "patch": "@@ -0,0 +1,255 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                GNU ADA RUN-TIME LIBRARY (GNARL) COMPONENTS               --\n+--                                                                          --\n+--     S Y S T E M . S T A C K _ C H E C K I N G . O P E R A T I O N S      --\n+--                                                                          --\n+--                                  B o d y                                 --\n+--                                                                          --\n+--          Copyright (C) 1999-2004 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNARL is free software; you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion. GNARL is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNARL; see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNARL was developed by the GNARL team at Florida State University.       --\n+-- Extensive contributions were provided by Ada Core Technologies, Inc.     --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This is the VxWorks version of this package.\n+--  This file should be kept synchronized with the general implementation\n+--  provided by s-stchop.adb.\n+\n+pragma Restrictions (No_Elaboration_Code);\n+--  We want to guarantee the absence of elaboration code because the\n+--  binder does not handle references to this package.\n+\n+with Ada.Exceptions;\n+\n+with System.Storage_Elements; use System.Storage_Elements;\n+with System.Parameters; use System.Parameters;\n+with System.Soft_Links;\n+with Interfaces.C;\n+with System.OS_Interface;\n+\n+package body System.Stack_Checking.Operations is\n+\n+   --  In order to have stack checking working appropriately on\n+   --  VxWorks we need to extract the stack size information from the\n+   --  VxWorks kernel itself. It means that the library for showing\n+   --  task-related information needs to be linked into the VxWorks\n+   --  system, when using stack checking. The TaskShow library can be\n+   --  linked into the VxWorks system by either:\n+   --    * defining INCLUDE_SHOW_ROUTINES in config.h when using\n+   --      configuration header files, or\n+   --    * selecting INCLUDE_TASK_SHOW when using the Tornado project\n+   --      facility.\n+\n+   function Set_Stack_Info (Stack : access Stack_Access) return Stack_Access;\n+\n+   --  The function Set_Stack_Info is the actual function that updates\n+   --  the cache containing a pointer to the Stack_Info. It may also\n+   --  be used for detecting asynchronous abort in combination with\n+   --  Invalidate_Self_Cache.\n+\n+   --  Set_Stack_Info should do the following things in order:\n+   --     1) Get the Stack_Access value for the current task\n+   --     2) Set Stack.all to the value obtained in 1)\n+   --     3) Optionally Poll to check for asynchronous abort\n+\n+   --  This order is important because if at any time a write to\n+   --  the stack cache is pending, that write should be followed\n+   --  by a Poll to prevent loosing signals.\n+\n+   --  Note: This function must be compiled with Polling turned off\n+\n+   --  Note: on systems like VxWorks and OS/2 with real thread-local storage,\n+   --        Set_Stack_Info should return an access value for such local\n+   --        storage. In those cases the cache will always be up-to-date.\n+\n+   --  The following constants should be imported from some system-specific\n+   --  constants package. The constants must be static for performance reasons.\n+\n+   ----------------------------\n+   -- Invalidate_Stack_Cache --\n+   ----------------------------\n+\n+   procedure Invalidate_Stack_Cache (Any_Stack : Stack_Access) is\n+      pragma Warnings (Off, Any_Stack);\n+   begin\n+      Cache := Null_Stack;\n+   end Invalidate_Stack_Cache;\n+\n+   --------------------\n+   -- Set_Stack_Info --\n+   --------------------\n+\n+   function Set_Stack_Info\n+     (Stack : access Stack_Access) return Stack_Access\n+   is\n+\n+      --  Task descriptor that is handled internally by the VxWorks kernel\n+      type Task_Descriptor is record\n+         T_Id            : Interfaces.C.int; -- task identifier\n+         Td_Name         : System.Address; -- task name\n+         Td_Priority     : Interfaces.C.int; -- task priority\n+         Td_Status       : Interfaces.C.int; -- task status\n+         Td_Options      : Interfaces.C.int; -- task option bits (see below)\n+         Td_Entry        : System.Address; -- original entry point of task\n+         Td_Sp           : System.Address; -- saved stack pointer\n+         Td_PStackBase   : System.Address; -- the bottom of the stack\n+         Td_PStackLimit  : System.Address; -- the effective end of the stack\n+         Td_PStackEnd    : System.Address; -- the actual end of the stack\n+         Td_StackSize    : Interfaces.C.int; -- size of stack in bytes\n+         Td_StackCurrent : Interfaces.C.int; -- current stack usage in bytes\n+         Td_StackHigh    : Interfaces.C.int; -- maximum stack usage in bytes\n+         Td_StackMargin  : Interfaces.C.int; -- current stack margin in bytes\n+         Td_ErrorStatus  : Interfaces.C.int; -- most recent task error status\n+         Td_Delay        : Interfaces.C.int; -- delay/timeout ticks\n+      end record;\n+\n+      --  This VxWorks procedure fills in a specified task descriptor\n+      --  for a specified task.\n+      procedure TaskInfoGet (T_Id : System.OS_Interface.t_id;\n+                             Task_Desc : access Task_Descriptor);\n+      pragma Import (C, TaskInfoGet, \"taskInfoGet\");\n+\n+      My_Stack  : Stack_Access;\n+      Task_Desc : aliased Task_Descriptor;\n+\n+   begin\n+      --  The order of steps 1 .. 3 is important, see specification.\n+\n+      --  1) Get the Stack_Access value for the current task\n+\n+      My_Stack := Soft_Links.Get_Stack_Info.all;\n+\n+      if My_Stack.Base = Null_Address then\n+\n+         --  First invocation. Ask the VxWorks kernel about stack\n+         --  values.\n+         TaskInfoGet (System.OS_Interface.taskIdSelf, Task_Desc'Access);\n+\n+         My_Stack.Size := System.Storage_Elements.Storage_Offset\n+           (Task_Desc.Td_StackSize);\n+         My_Stack.Base := Task_Desc.Td_PStackBase;\n+         My_Stack.Limit := Task_Desc.Td_PStackLimit;\n+\n+      end if;\n+\n+      --  2) Set Stack.all to the value obtained in 1)\n+\n+      Stack.all := My_Stack;\n+\n+      --  3) Optionally Poll to check for asynchronous abort\n+\n+      if Soft_Links.Check_Abort_Status.all /= 0 then\n+         raise Standard'Abort_Signal;\n+      end if;\n+\n+      return My_Stack; -- Never trust the cached value, but return local copy!\n+   end Set_Stack_Info;\n+\n+   --------------------\n+   -- Set_Stack_Size --\n+   --------------------\n+\n+   --  Specify the stack size for the current frame.\n+\n+   procedure Set_Stack_Size\n+     (Stack_Size : System.Storage_Elements.Storage_Offset)\n+   is\n+      My_Stack      : Stack_Access;\n+      Frame_Address : constant System.Address := My_Stack'Address;\n+\n+   begin\n+      My_Stack := Stack_Check (Frame_Address);\n+\n+      if Stack_Grows_Down then\n+         My_Stack.Limit := My_Stack.Base - Stack_Size;\n+      else\n+         My_Stack.Limit := My_Stack.Base + Stack_Size;\n+      end if;\n+   end Set_Stack_Size;\n+\n+   -----------------\n+   -- Stack_Check --\n+   -----------------\n+\n+   function Stack_Check\n+     (Stack_Address : System.Address) return Stack_Access\n+   is\n+      type Frame_Marker is null record;\n+      Marker        : Frame_Marker;\n+      Cached_Stack  : constant Stack_Access := Cache;\n+      Frame_Address : constant System.Address := Marker'Address;\n+\n+   begin\n+      --  This function first does a \"cheap\" check which is correct\n+      --  if it succeeds. In case of failure, the full check is done.\n+      --  Ideally the cheap check should be done in an optimized manner,\n+      --  or be inlined.\n+\n+      if (Stack_Grows_Down and then\n+            (Frame_Address <= Cached_Stack.Base\n+               and\n+             Stack_Address > Cached_Stack.Limit))\n+        or else\n+         (not Stack_Grows_Down and then\n+            (Frame_Address >= Cached_Stack.Base\n+               and\n+             Stack_Address < Cached_Stack.Limit))\n+      then\n+         --  Cached_Stack is valid as it passed the stack check\n+         return Cached_Stack;\n+      end if;\n+\n+      Full_Check :\n+      declare\n+         My_Stack : constant Stack_Access := Set_Stack_Info (Cache'Access);\n+         --  At this point Stack.all might already be invalid, so\n+         --  it is essential to use our local copy of Stack!\n+\n+      begin\n+         if (Stack_Grows_Down and then\n+                  Stack_Address < My_Stack.Limit)\n+           or else\n+            (not Stack_Grows_Down and then\n+                  Stack_Address > My_Stack.Limit)\n+         then\n+            Ada.Exceptions.Raise_Exception\n+              (E       => Storage_Error'Identity,\n+               Message => \"stack overflow detected\");\n+         end if;\n+\n+         return My_Stack;\n+      end Full_Check;\n+   end Stack_Check;\n+\n+   ------------------------\n+   -- Update_Stack_Cache --\n+   ------------------------\n+\n+   procedure Update_Stack_Cache (Stack : Stack_Access) is\n+   begin\n+      if not Multi_Processor then\n+         Cache := Stack;\n+      end if;\n+   end Update_Stack_Cache;\n+\n+end System.Stack_Checking.Operations;"}, {"sha": "f5bc6174ccb241db2d1a13e916914b4357e2b7cb", "filename": "gcc/ada/7staprop.adb", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a336eacaf1fe8e0ac28decabbc59c7972766f742/gcc%2Fada%2F7staprop.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a336eacaf1fe8e0ac28decabbc59c7972766f742/gcc%2Fada%2F7staprop.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F7staprop.adb?ref=a336eacaf1fe8e0ac28decabbc59c7972766f742", "patch": "@@ -995,8 +995,8 @@ package body System.Task_Primitives.Operations is\n    ------------------\n \n    procedure Finalize_TCB (T : Task_ID) is\n-      Result : Interfaces.C.int;\n-      Tmp    : Task_ID := T;\n+      Result  : Interfaces.C.int;\n+      Tmp     : Task_ID := T;\n       Is_Self : constant Boolean := T = Self;\n \n       procedure Free is new\n@@ -1018,10 +1018,8 @@ package body System.Task_Primitives.Operations is\n       Free (Tmp);\n \n       if Is_Self then\n-         Result := pthread_setspecific (ATCB_Key, System.Null_Address);\n-         pragma Assert (Result = 0);\n+         Specific.Set (null);\n       end if;\n-\n    end Finalize_TCB;\n \n    ---------------"}, {"sha": "5e2af3e25334787006f7b173f8d9f1f844f8e5b2", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a336eacaf1fe8e0ac28decabbc59c7972766f742/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a336eacaf1fe8e0ac28decabbc59c7972766f742/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=a336eacaf1fe8e0ac28decabbc59c7972766f742", "patch": "@@ -1,3 +1,88 @@\n+2004-03-18  Arnaud Charlet  <charlet@act-europe.fr>\n+\n+\t* 5atpopsp.adb: Remove RTEMS from list of platforms using this file.\n+\n+\tCode clean up:\n+\t* 5ataprop.adb, 5ftaprop.adb, 5htaprop.adb, 5itaprop.adb, 5staprop.adb,\n+\t5vtaprop.adb, 5wtaprop.adb, 7staprop.adb (Finalize_TCB): Use\n+\tSpecific.Set instead of direct call to e.g pthread_setspecific.\n+\n+2004-03-18  Thomas Quinot  <quinot@act-europe.fr>\n+\n+\t* adaint.c: Update comments.\n+\n+\t* Makefile.in: set PREFIX_OBJS, SYMLIB, THREADSLIB, and\n+\tGNATLIB_SHARED for FreeBSD.\n+\n+2004-03-18  Jose Ruiz  <ruiz@act-europe.fr>\n+\n+\t* init.c [VxWorks]: Do not fix the stack size for the environment task.\n+\tWhen needed (stack checking) the stack size is retrieved\n+\tfrom the VxWorks kernel.\n+\n+\t* Makefile.in: Flag -nostdinc is required when building the run time\n+\tfor avoiding looking for files in the base compiler.\n+\tAdd the VxWorks specific version of the package body for\n+\tSystem.Stack_checking.Operations (5zstchop.adb).\n+\n+\t* Make-lang.in: Add the object file for\n+\tSystem.Stack_Checking.Operations.\n+\n+\t* Makefile.rtl: Add object file for the package\n+\tSystem.Stack_Checking.Operations.\n+\n+\t* s-stchop.ads, s-stchop.adb, 5zstchop.adb: New files.\n+\n+\t* s-stache.ads, s-stache.adb: Move the operations related to stack\n+\tchecking from this package to package System.Stack_Checking.Operations.\n+\tThis way, stack checking operations are only linked in the final\n+\texecutable when using the -fstack-check flag.\n+\n+2004-03-18  Doug Rupp  <rupp@gnat.com>\n+\n+\t* Makefile.in [VMS]: Handle 64 bit specs (5qsystem.ads, 5xcrtl.ads).\n+\tReorganize ifeq's.\n+\n+\t* 5qsystem.ads, 5xcrtl.ads: New files.\n+\n+2004-03-18  Vincent Celier  <celier@gnat.com>\n+\n+\t* prj.adb (Reset): Reset hash table Files_Htable\n+\n+\t* prj-env.adb (Source_Paths, Object_Paths): New tables.\n+\t(Add_To_Source_Path, Add_To_Object_Path): New procedures, to replace\n+\tthe procedures Add_To_Path_File.\n+\t(Set_Ada_Paths): Accumulate source and object dirs in the tables,\n+\tmaking sure that each directory is present only once and, for object\n+\tdirs, when a directory already present is added, the duplicate is\n+\tremoved and the directory is always put as the last in the table.\n+\tWrite the path files at the end of these accumulations.\n+\n+\t* prj-nmsc.adb (Record_Source): Add source file name in hash table\n+\tFiles_Htable for all sources.\n+\n+\t* prj-proc.adb (Process): Remove restrictions between not directly\n+\trelated extending projects.\n+\n+2004-03-18  Emmanuel Briot  <briot@act-europe.fr>\n+\n+\t* prj-nmsc.ads, prj-nmsc.adb (Ada_Check): New parameter Trusted_Mode.\n+\t(Find_Sources): Minor speed optimization.\n+\n+\t* prj-proc.ads, prj-proc.adb (Check, Recursive_Check, Process): New\n+\tparameter Trusted_Mode.\n+\n+2004-03-18  Sergey Rybin  <rybin@act-europe.fr>\n+\n+\t* scn.adb (Determine_License): Take into account a degenerated case\n+\twhen the source contains only comments.\n+\n+2004-03-18  Ed Schonberg  <schonberg@gnat.com>\n+\n+\t* sem_warn.adb (Check_References): For a warning on a selected\n+\tcomponent that does not come from source, locate an uninitialized\n+\tcomponent of the record type to produce a more precise error message.\n+\n 2004-03-15  Jerome Guitton  <guitton@act-europe.fr>\n \n \t* 3zsoccon.ads: Fix multicast options."}, {"sha": "3c0f95bef7bddcf0a81c05f6ec4301987700341d", "filename": "gcc/ada/Make-lang.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a336eacaf1fe8e0ac28decabbc59c7972766f742/gcc%2Fada%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a336eacaf1fe8e0ac28decabbc59c7972766f742/gcc%2Fada%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FMake-lang.in?ref=a336eacaf1fe8e0ac28decabbc59c7972766f742", "patch": "@@ -2795,7 +2795,7 @@ ada/s-sopco5.o : ada/system.ads ada/s-secsta.ads ada/s-stoele.ads \\\n \n ada/s-stache.o : ada/ada.ads ada/a-except.ads ada/system.ads \\\n    ada/s-crtl.ads ada/s-parame.ads ada/s-soflin.ads ada/s-stache.ads \\\n-   ada/s-stache.adb ada/s-stalib.ads ada/s-stoele.ads ada/s-stoele.adb \\\n+   ada/s-stalib.ads ada/s-stoele.ads ada/s-stoele.adb \\\n    ada/s-traent.ads ada/unchconv.ads \n \n ada/s-stalib.o : ada/ada.ads ada/a-except.ads ada/system.ads \\"}, {"sha": "910411058e71f7a7ea5ffa726b55c7f5fc42f5e9", "filename": "gcc/ada/Makefile.in", "status": "modified", "additions": 32, "deletions": 22, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a336eacaf1fe8e0ac28decabbc59c7972766f742/gcc%2Fada%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a336eacaf1fe8e0ac28decabbc59c7972766f742/gcc%2Fada%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FMakefile.in?ref=a336eacaf1fe8e0ac28decabbc59c7972766f742", "patch": "@@ -122,7 +122,7 @@ ADA_CFLAGS =\n ADAFLAGS = -W -Wall -gnatpg -gnata\n SOME_ADAFLAGS =-gnata\n FORCE_DEBUG_ADAFLAGS = -g\n-GNATLIBFLAGS = -gnatpg\n+GNATLIBFLAGS = -gnatpg -nostdinc\n GNATLIBCFLAGS = -g -O2\n GNATLIBCFLAGS_FOR_C = $(GNATLIBCFLAGS) $(TARGET_LIBGCC2_CFLAGS) -fexceptions \\\n \t-DIN_RTS\n@@ -471,6 +471,7 @@ ifeq ($(strip $(filter-out alpha% dec vx%,$(targ))),)\n   s-osinte.ads<5zosinte.ads \\\n   s-osprim.adb<5zosprim.adb \\\n   s-parame.ads<5zparame.ads \\\n+  s-stchop.adb<5zstchop.adb \\\n   s-taprop.adb<5ztaprop.adb \\\n   s-tpopsp.adb<5ztpopsp.adb \\\n   s-taspri.ads<5ztaspri.ads \\\n@@ -498,6 +499,7 @@ ifeq ($(strip $(filter-out m68k% wrs vx%,$(targ))),)\n   s-osinte.ads<5zosinte.ads \\\n   s-osprim.adb<5zosprim.adb \\\n   s-parame.ads<5zparame.ads \\\n+  s-stchop.adb<5zstchop.adb \\\n   s-taprop.adb<5ztaprop.adb \\\n   s-taspri.ads<5ztaspri.ads \\\n   s-tpopsp.adb<5ztpopsp.adb \\\n@@ -536,6 +538,7 @@ ifeq ($(strip $(filter-out powerpc% wrs vxworks,$(targ))),)\n   s-osinte.ads<5zosinte.ads \\\n   s-osprim.adb<5zosprim.adb \\\n   s-parame.ads<5zparame.ads \\\n+  s-stchop.adb<5zstchop.adb \\\n   s-taprop.adb<5ztaprop.adb \\\n   s-taspri.ads<5ztaspri.ads \\\n   s-tpopsp.adb<5ztpopsp.adb \\\n@@ -621,6 +624,7 @@ ifeq ($(strip $(filter-out sparc% wrs vx%,$(targ))),)\n   s-osinte.ads<5zosinte.ads \\\n   s-osprim.adb<5zosprim.adb \\\n   s-parame.ads<5zparame.ads \\\n+  s-stchop.adb<5zstchop.adb \\\n   s-taprop.adb<5ztaprop.adb \\\n   s-taspri.ads<5ztaspri.ads \\\n   s-tpopsp.adb<5ztpopsp.adb \\\n@@ -650,6 +654,7 @@ ifeq ($(strip $(filter-out xscale% coff wrs vx%,$(targ))),)\n   s-osinte.ads<5zosinte.ads \\\n   s-osprim.adb<5zosprim.adb \\\n   s-parame.ads<5zparame.ads \\\n+  s-stchop.adb<5zstchop.adb \\\n   s-taprop.adb<5ztaprop.adb \\\n   s-taspri.ads<5ztaspri.ads \\\n   s-tpopsp.adb<5ztpopsp.adb \\\n@@ -679,6 +684,7 @@ ifeq ($(strip $(filter-out mips% wrs vx%,$(targ))),)\n   s-osinte.ads<5zosinte.ads \\\n   s-osprim.adb<5zosprim.adb \\\n   s-parame.ads<5zparame.ads \\\n+  s-stchop.adb<5zstchop.adb \\\n   s-taprop.adb<5ztaprop.adb \\\n   s-taspri.ads<5ztaspri.ads \\\n   s-tpopsp.adb<5ztpopsp.adb \\\n@@ -870,7 +876,14 @@ ifeq ($(strip $(filter-out %86 freebsd%,$(arch) $(osys))),)\n   s-tpopsp.adb<7stpopsp.adb \\\n   system.ads<56system.ads\n \n-  THREADSLIB=\n+  TOOLS_TARGET_PAIRS = \\\n+  mlib-tgt.adb<5lml-tgt.adb\n+  GNATLIB_SHARED = gnatlib-shared-dual\n+\n+  SYMLIB = $(ADDR2LINE_SYMLIB)\n+  THREADSLIB= -lc_r\n+  GMEM_LIB = gmemlib\n+  PREFIX_OBJS = $(PREFIX_REAL_OBJS)\n   LIBRARY_VERSION := $(LIB_VERSION)\n endif\n \n@@ -1125,7 +1138,7 @@ ifeq ($(strip $(filter-out alpha% dec osf%,$(targ))),)\n   LIBRARY_VERSION := $(LIB_VERSION)\n endif\n \n-ifeq ($(strip $(filter-out alpha% ia64 dec vms% openvms% alphavms%,$(host))),)\n+ifeq ($(strip $(filter-out alpha% ia64 dec hp vms% openvms% alphavms%,$(host))),)\n \n soext  = .exe\n hyphen = _\n@@ -1137,31 +1150,27 @@ hyphen = _\n endif\n \n ifeq ($(strip $(filter-out alpha% ia64 dec hp vms% openvms% alphavms%,$(targ))),)\n-\n-ifeq ($(strip $(filter-out ia64% hp vms% openvms%,$(targ))),)\n-  LIBGNAT_TARGET_PAIRS_AUX = \\\n+ifeq ($(strip $(filter-out ia64 hp vms% openvms%,$(targ))),)\n+  LIBGNAT_TARGET_PAIRS_AUX1 = \\\n+  s-crtl.ads<5xcrtl.ads \\\n   s-osinte.adb<5xosinte.adb \\\n   s-osinte.ads<5xosinte.ads \\\n-  s-parame.ads<5vparame.ads\n+  system.ads<5qsystem.ads\n else\n-ifeq ($(strip $(filter-out alpha64% dec hp vms% openvms% alphavms%,$(targ))),)\n-  LIBGNAT_TARGET_PAIRS_AUX = \\\n+ifeq ($(strip $(filter-out alpha% dec vms% openvms% alphavms%,$(targ))),)\n+  LIBGNAT_TARGET_PAIRS_AUX1 = \\\n+  s-crtl.ads<5vcrtl.ads \\\n   s-osinte.adb<5vosinte.adb \\\n   s-osinte.ads<5vosinte.ads \\\n-  s-parame.ads<5vparame.ads\n-else\n+  system.ads<5xsystem.ads\n+endif\n+endif\n ifeq ($(strip $(filter-out express EXPRESS,$(THREAD_KIND))),)\n-  LIBGNAT_TARGET_PAIRS_AUX = \\\n-  s-osinte.adb<5vosinte.adb \\\n-  s-osinte.ads<5vosinte.ads \\\n+  LIBGNAT_TARGET_PAIRS_AUX2 = \\\n   s-parame.ads<5xparame.ads\n else\n-  LIBGNAT_TARGET_PAIRS_AUX = \\\n-  s-osinte.adb<5vosinte.adb \\\n-  s-osinte.ads<5vosinte.ads \\\n+  LIBGNAT_TARGET_PAIRS_AUX2 = \\\n   s-parame.ads<5vparame.ads\n-endif\n-endif\n endif\n \n   LIBGNAT_TARGET_PAIRS = \\\n@@ -1180,7 +1189,6 @@ endif\n   i-cpp.adb<6vcpp.adb \\\n   interfac.ads<6vinterf.ads \\\n   s-asthan.adb<5vasthan.adb \\\n-  s-crtl.ads<5vcrtl.ads \\\n   s-inmaop.adb<5vinmaop.adb \\\n   s-interr.adb<5vinterr.adb \\\n   s-intman.adb<5vintman.adb \\\n@@ -1195,14 +1203,16 @@ endif\n   s-traent.adb<5vtraent.adb \\\n   s-traent.ads<5vtraent.ads \\\n   s-vaflop.adb<5vvaflop.adb \\\n-  system.ads<5xsystem.ads   \\\n-  $(LIBGNAT_TARGET_PAIRS_AUX)\n+  $(LIBGNAT_TARGET_PAIRS_AUX1) \\\n+  $(LIBGNAT_TARGET_PAIRS_AUX2)\n \n   TOOLS_TARGET_PAIRS=mlib-tgt.adb<5vml-tgt.adb\n \n   GNATLIB_SHARED=gnatlib-shared-vms\n+ifeq ($(strip $(filter-out alpha% dec vms% openvms% alphavms%,$(targ))),)\n   EXTRA_LIBGNAT_SRCS=vmshandler.asm\n   EXTRA_LIBGNAT_OBJS=vmshandler.o\n+endif\n   EXTRA_GNATRTL_TASKING_OBJS=s-tpopde.o\n   EXTRA_GNATTOOLS = \\\n      ../../gnatlbr$(exeext) \\"}, {"sha": "f24998144214ac7047ac2a79b2ed0670da1f3491", "filename": "gcc/ada/Makefile.rtl", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a336eacaf1fe8e0ac28decabbc59c7972766f742/gcc%2Fada%2FMakefile.rtl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a336eacaf1fe8e0ac28decabbc59c7972766f742/gcc%2Fada%2FMakefile.rtl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FMakefile.rtl?ref=a336eacaf1fe8e0ac28decabbc59c7972766f742", "patch": "@@ -406,6 +406,7 @@ GNATRTL_NONTASKING_OBJS= \\\n   s-sopco4$(objext) \\\n   s-sopco5$(objext) \\\n   s-stache$(objext) \\\n+  s-stchop$(objext) \\\n   s-stalib$(objext) \\\n   s-stoele$(objext) \\\n   s-stopoo$(objext) \\"}, {"sha": "0b27ada7ef4a692e1999a1226c640ddb7e9d34fe", "filename": "gcc/ada/adaint.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a336eacaf1fe8e0ac28decabbc59c7972766f742/gcc%2Fada%2Fadaint.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a336eacaf1fe8e0ac28decabbc59c7972766f742/gcc%2Fada%2Fadaint.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fadaint.c?ref=a336eacaf1fe8e0ac28decabbc59c7972766f742", "patch": "@@ -2390,6 +2390,7 @@ _flush_cache()\n #if defined (CROSS_COMPILE)  \\\n   || (! (defined (sparc) && defined (sun) && defined (__SVR4)) \\\n       && ! (defined (linux) && defined (i386)) \\\n+      && ! defined (__FreeBSD__) \\\n       && ! defined (hpux) \\\n       && ! defined (_AIX) \\\n       && ! (defined (__alpha__)  && defined (__osf__)) \\"}, {"sha": "61981725eaaf397b2cb443ce646c847d583230a6", "filename": "gcc/ada/init.c", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a336eacaf1fe8e0ac28decabbc59c7972766f742/gcc%2Fada%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a336eacaf1fe8e0ac28decabbc59c7972766f742/gcc%2Fada%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Finit.c?ref=a336eacaf1fe8e0ac28decabbc59c7972766f742", "patch": "@@ -1777,20 +1777,6 @@ __gnat_initialize (void)\n {\n   __gnat_init_float ();\n \n-  /* Assume an environment task stack size of 20kB.\n-\n-     Using a constant is necessary because we do not want each Ada application\n-     to depend on the optional taskShow library,\n-     which is required to get the actual stack information.\n-\n-     The consequence of this is that with -fstack-check\n-     the environment task must have an actual stack size\n-     of at least 20kB and the usable size will be about 14kB.\n-  */\n-\n-  __gnat_set_stack_size (14336);\n-  /* Allow some head room for the stack checking code, and for\n-     stack space consumed during initialization */\n }\n \n /********************************/"}, {"sha": "f974e0f3c124b0eb73475e4b4abce1f5a66e35a4", "filename": "gcc/ada/prj-env.adb", "status": "modified", "additions": 171, "deletions": 95, "changes": 266, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a336eacaf1fe8e0ac28decabbc59c7972766f742/gcc%2Fada%2Fprj-env.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a336eacaf1fe8e0ac28decabbc59c7972766f742/gcc%2Fada%2Fprj-env.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-env.adb?ref=a336eacaf1fe8e0ac28decabbc59c7972766f742", "patch": "@@ -87,6 +87,24 @@ package body Prj.Env is\n    --  A Boolean array type used in Create_Mapping_File to select the projects\n    --  in the closure of a specific project.\n \n+   package Source_Paths is new Table.Table\n+     (Table_Component_Type => Name_Id,\n+      Table_Index_Type     => Natural,\n+      Table_Low_Bound      => 1,\n+      Table_Initial        => 50,\n+      Table_Increment      => 50,\n+      Table_Name           => \"Prj.Env.Source_Paths\");\n+   --  A table to store the source dirs before creating the source path file\n+\n+   package Object_Paths is new Table.Table\n+     (Table_Component_Type => Name_Id,\n+      Table_Index_Type     => Natural,\n+      Table_Low_Bound      => 1,\n+      Table_Initial        => 50,\n+      Table_Increment      => 50,\n+      Table_Name           => \"Prj.Env.Source_Paths\");\n+   --  A table to store the object dirs, before creating the object path file\n+\n    -----------------------\n    -- Local Subprograms --\n    -----------------------\n@@ -109,16 +127,13 @@ package body Prj.Env is\n    --  If Ada_Path_Length /= 0, prepend a Path_Separator character to\n    --  Path.\n \n-   procedure Add_To_Path_File\n-     (Source_Dirs : String_List_Id;\n-      Path_File   : File_Descriptor);\n-   --  Add to Ada_Path_Buffer all the source directories in string list\n+   procedure Add_To_Source_Path (Source_Dirs : String_List_Id);\n+   --  Add to Ada_Path_B all the source directories in string list\n    --  Source_Dirs, if any. Increment Ada_Path_Length.\n \n-   procedure Add_To_Path_File\n-     (Path      : String;\n-      Path_File : File_Descriptor);\n-   --  Add Path to path file\n+   procedure Add_To_Object_Path (Object_Dir : Name_Id);\n+   --  Add Object_Dir to object path table. Make sure it is not duplicate\n+   --  and it is the last one in the current table.\n \n    procedure Create_New_Path_File\n      (Path_FD   : out File_Descriptor;\n@@ -311,6 +326,34 @@ package body Prj.Env is\n       return Projects.Table (Project).Ada_Objects_Path;\n    end Ada_Objects_Path;\n \n+   ------------------------\n+   -- Add_To_Object_Path --\n+   ------------------------\n+\n+   procedure Add_To_Object_Path (Object_Dir : Name_Id) is\n+   begin\n+      --  Check if the directory is already in the table\n+\n+      for Index in 1 .. Object_Paths.Last loop\n+         --  If it is, remove it, and add it as the last one\n+\n+         if Object_Paths.Table (Index) = Object_Dir then\n+            for Index2 in Index + 1 .. Object_Paths.Last loop\n+               Object_Paths.Table (Index2 - 1) :=\n+                 Object_Paths.Table (Index2);\n+            end loop;\n+\n+            Object_Paths.Table (Object_Paths.Last) := Object_Dir;\n+            return;\n+         end if;\n+      end loop;\n+\n+      --  The directory is not already in the table, add it\n+\n+      Object_Paths.Increment_Last;\n+      Object_Paths.Table (Object_Paths.Last) := Object_Dir;\n+   end Add_To_Object_Path;\n+\n    -----------------\n    -- Add_To_Path --\n    -----------------\n@@ -402,41 +445,43 @@ package body Prj.Env is\n       Ada_Path_Length := Ada_Path_Length + Dir'Length;\n    end Add_To_Path;\n \n-   ----------------------\n-   -- Add_To_Path_File --\n-   ----------------------\n+   ------------------------\n+   -- Add_To_Source_Path --\n+   ------------------------\n \n-   procedure Add_To_Path_File\n-     (Source_Dirs : String_List_Id;\n-      Path_File   : File_Descriptor)\n-   is\n+   procedure Add_To_Source_Path (Source_Dirs : String_List_Id) is\n       Current    : String_List_Id := Source_Dirs;\n       Source_Dir : String_Element;\n+      Add_It     : Boolean;\n \n    begin\n+      --  Add each source directory\n+\n       while Current /= Nil_String loop\n          Source_Dir := String_Elements.Table (Current);\n-         Add_To_Path_File (Get_Name_String (Source_Dir.Value), Path_File);\n-         Current := Source_Dir.Next;\n-      end loop;\n-   end Add_To_Path_File;\n+         Add_It := True;\n \n-   procedure Add_To_Path_File\n-     (Path      : String;\n-      Path_File : File_Descriptor)\n-   is\n-      Line : String (1 .. Path'Length + 1);\n-      Len  : Natural;\n+         --  Check if the source directory is already in the table\n \n-   begin\n-      Line (1 .. Path'Length) := Path;\n-      Line (Line'Last) := ASCII.LF;\n-      Len := Write (Path_File, Line (1)'Address, Line'Length);\n+         for Index in 1 .. Source_Paths.Last loop\n+            --  If it is already, no need to add it\n \n-      if Len /= Line'Length then\n-         Prj.Com.Fail (\"disk full\");\n-      end if;\n-   end Add_To_Path_File;\n+            if Source_Paths.Table (Index) = Source_Dir.Value then\n+               Add_It := False;\n+               exit;\n+            end if;\n+         end loop;\n+\n+         if Add_It then\n+            Source_Paths.Increment_Last;\n+            Source_Paths.Table (Source_Paths.Last) := Source_Dir.Value;\n+         end if;\n+\n+         --  Next source directory\n+\n+         Current := Source_Dir.Next;\n+      end loop;\n+   end Add_To_Source_Path;\n \n    -----------------------\n    -- Body_Path_Name_Of --\n@@ -1845,87 +1890,100 @@ package body Prj.Env is\n       Status : Boolean;\n       --  For calls to Close\n \n-      procedure Add (Project : Project_Id);\n+      Len : Natural;\n+\n+      procedure Add (Proj : Project_Id);\n       --  Add all the source/object directories of a project to the path only\n-      --  if this project has not been visited. Calls itself recursively for\n-      --  projects being extended, and imported projects.\n+      --  if this project has not been visited. Calls an internal procedure\n+      --  recursively for projects being extended, and imported projects.\n \n       ---------\n       -- Add --\n       ---------\n \n-      procedure Add (Project : Project_Id) is\n-      begin\n-         --  If Seen is False, then the project has not yet been visited\n+      procedure Add (Proj : Project_Id) is\n \n-         if not Projects.Table (Project).Seen then\n-            Projects.Table (Project).Seen := True;\n+         procedure Recursive_Add (Project : Project_Id);\n+         --  Recursive procedure to add the source/object paths of extended/\n+         --  imported projects.\n \n-            declare\n-               Data : constant Project_Data := Projects.Table (Project);\n-               List : Project_List := Data.Imported_Projects;\n+         -------------------\n+         -- Recursive_Add --\n+         -------------------\n \n-            begin\n-               if Process_Source_Dirs then\n+         procedure Recursive_Add (Project : Project_Id) is\n+         begin\n+            --  If Seen is False, then the project has not yet been visited\n \n-                  --  Add to path all source directories of this project\n-                  --  if there are Ada sources.\n+            if not Projects.Table (Project).Seen then\n+               Projects.Table (Project).Seen := True;\n \n-                  if Projects.Table (Project).Sources_Present then\n-                     Add_To_Path_File (Data.Source_Dirs, Source_FD);\n+               declare\n+                  Data : constant Project_Data := Projects.Table (Project);\n+                  List : Project_List := Data.Imported_Projects;\n+\n+               begin\n+                  if Process_Source_Dirs then\n+\n+                     --  Add to path all source directories of this project\n+                     --  if there are Ada sources.\n+\n+                     if Projects.Table (Project).Sources_Present then\n+                        Add_To_Source_Path (Data.Source_Dirs);\n+                     end if;\n                   end if;\n-               end if;\n \n-               if Process_Object_Dirs then\n+                  if Process_Object_Dirs then\n \n-                  --  Add to path the object directory of this project\n-                  --  except if we don't include library project and\n-                  --  this is a library project.\n+                     --  Add to path the object directory of this project\n+                     --  except if we don't include library project and\n+                     --  this is a library project.\n \n-                  if (Data.Library and then Including_Libraries)\n-                    or else\n-                     (Data.Object_Directory /= No_Name\n-                        and then\n-                         (not Including_Libraries or else not Data.Library))\n-                  then\n-                     --  For a library project, add the library directory\n+                     if (Data.Library and then Including_Libraries)\n+                       or else\n+                         (Data.Object_Directory /= No_Name\n+                          and then\n+                            (not Including_Libraries or else not Data.Library))\n+                     then\n+                        --  For a library project, add the library directory\n \n-                     if Data.Library then\n-                        declare\n-                           New_Path : constant String :=\n-                                        Get_Name_String (Data.Library_Dir);\n+                        if Data.Library then\n+                           Add_To_Object_Path (Data.Library_Dir);\n \n-                        begin\n-                           Add_To_Path_File (New_Path, Object_FD);\n-                        end;\n+                        else\n+                           --  For a non library project, add the object\n+                           --  directory.\n \n-                     else\n-                        --  For a non library project, add the object directory\n-\n-                        declare\n-                           New_Path : constant String :=\n-                             Get_Name_String (Data.Object_Directory);\n-                        begin\n-                           Add_To_Path_File (New_Path, Object_FD);\n-                        end;\n+                           Add_To_Object_Path (Data.Object_Directory);\n+                        end if;\n                      end if;\n                   end if;\n-               end if;\n \n-               --  Call Add to the project being extended, if any\n+                  --  Call Add to the project being extended, if any\n \n-               if Data.Extends /= No_Project then\n-                  Add (Data.Extends);\n-               end if;\n+                  if Data.Extends /= No_Project then\n+                     Recursive_Add (Data.Extends);\n+                  end if;\n \n-               --  Call Add for each imported project, if any\n+                  --  Call Add for each imported project, if any\n \n-               while List /= Empty_Project_List loop\n-                  Add (Project_Lists.Table (List).Project);\n-                  List := Project_Lists.Table (List).Next;\n-               end loop;\n-            end;\n-         end if;\n+                  while List /= Empty_Project_List loop\n+                     Recursive_Add (Project_Lists.Table (List).Project);\n+                     List := Project_Lists.Table (List).Next;\n+                  end loop;\n+               end;\n+            end if;\n+         end Recursive_Add;\n+\n+      begin\n+         Source_Paths.Set_Last (0);\n+         Object_Paths.Set_Last (0);\n+\n+         for Index in 1 .. Projects.Last loop\n+            Projects.Table (Index).Seen := False;\n+         end loop;\n+\n+         Recursive_Add (Proj);\n       end Add;\n \n    --  Start of processing for Set_Ada_Paths\n@@ -1966,16 +2024,23 @@ package body Prj.Env is\n       --  then call the recursive procedure Add for Project.\n \n       if Process_Source_Dirs or Process_Object_Dirs then\n-         for Index in 1 .. Projects.Last loop\n-            Projects.Table (Index).Seen := False;\n-         end loop;\n-\n          Add (Project);\n       end if;\n \n-      --  Close any file that has been created.\n+      --  Write and close any file that has been created.\n \n       if Source_FD /= Invalid_FD then\n+         for Index in 1 .. Source_Paths.Last loop\n+            Get_Name_String (Source_Paths.Table (Index));\n+            Name_Len := Name_Len + 1;\n+            Name_Buffer (Name_Len) := ASCII.LF;\n+            Len := Write (Source_FD, Name_Buffer (1)'Address, Name_Len);\n+\n+            if Len /= Name_Len then\n+               Prj.Com.Fail (\"disk full\");\n+            end if;\n+         end loop;\n+\n          Close (Source_FD, Status);\n \n          if not Status then\n@@ -1984,6 +2049,17 @@ package body Prj.Env is\n       end if;\n \n       if Object_FD /= Invalid_FD then\n+         for Index in 1 .. Object_Paths.Last loop\n+            Get_Name_String (Object_Paths.Table (Index));\n+            Name_Len := Name_Len + 1;\n+            Name_Buffer (Name_Len) := ASCII.LF;\n+            Len := Write (Object_FD, Name_Buffer (1)'Address, Name_Len);\n+\n+            if Len /= Name_Len then\n+               Prj.Com.Fail (\"disk full\");\n+            end if;\n+         end loop;\n+\n          Close (Object_FD, Status);\n \n          if not Status then"}, {"sha": "51d5e0e8253f7b81066395929e19d028b6a111f7", "filename": "gcc/ada/prj-nmsc.adb", "status": "modified", "additions": 17, "deletions": 11, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a336eacaf1fe8e0ac28decabbc59c7972766f742/gcc%2Fada%2Fprj-nmsc.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a336eacaf1fe8e0ac28decabbc59c7972766f742/gcc%2Fada%2Fprj-nmsc.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-nmsc.adb?ref=a336eacaf1fe8e0ac28decabbc59c7972766f742", "patch": "@@ -587,7 +587,8 @@ package body Prj.Nmsc is\n \n    procedure Ada_Check\n      (Project      : Project_Id;\n-      Report_Error : Put_Line_Access)\n+      Report_Error : Put_Line_Access;\n+      Trusted_Mode : Boolean)\n    is\n       Data         : Project_Data;\n       Languages    : Variable_Value := Nil_Variable_Value;\n@@ -665,9 +666,12 @@ package body Prj.Nmsc is\n                Source_Recorded := False;\n                Element := String_Elements.Table (Source_Dir);\n                if Element.Value /= No_Name then\n+                  Get_Name_String (Element.Display_Value);\n                   declare\n                      Source_Directory : constant String :=\n-                       Get_Name_String (Element.Display_Value);\n+                        Name_Buffer (1 .. Name_Len) & Directory_Separator;\n+                     Dir_Last  : constant Natural :=\n+                        Compute_Directory_Last (Source_Directory);\n \n                   begin\n                      if Current_Verbosity = High then\n@@ -677,7 +681,8 @@ package body Prj.Nmsc is\n \n                      --  We look to every entry in the source directory\n \n-                     Open (Dir, Source_Directory);\n+                     Open (Dir, Source_Directory\n+                             (Source_Directory'First .. Dir_Last));\n \n                      --  Canonical_Case_File_Name (Source_Directory);\n \n@@ -693,20 +698,16 @@ package body Prj.Nmsc is\n \n                         declare\n                            File_Name : constant Name_Id := Name_Find;\n-                           Dir       : constant String :=\n-                                         Source_Directory &\n-                                         Directory_Separator;\n-                           Dir_Last  : constant Natural :=\n-                                         Compute_Directory_Last (Dir);\n                            Path      : constant String :=\n                                   Normalize_Pathname\n                                     (Name      => Name_Buffer (1 .. Name_Len),\n-                                     Directory => Dir (Dir'First .. Dir_Last));\n+                                     Directory => Source_Directory\n+                                       (Source_Directory'First .. Dir_Last),\n+                                     Resolve_Links => not Trusted_Mode);\n                            Path_Name : Name_Id;\n \n                         begin\n-                           if Is_Regular_File (Path) then\n-\n+                           if Trusted_Mode or else Is_Regular_File (Path) then\n                               Name_Len := Path'Length;\n                               Name_Buffer (1 .. Name_Len) := Path;\n                               Path_Name := Name_Find;\n@@ -3750,6 +3751,11 @@ package body Prj.Nmsc is\n                        (The_Unit_Data.File_Names (Unit_Kind).Name);\n                   end if;\n \n+                  --  Record the file name in the hash table Files_Htable\n+\n+                  Unit_Prj := (Unit => The_Unit, Project => Project);\n+                  Files_Htable.Set (Canonical_File_Name, Unit_Prj);\n+\n                   The_Unit_Data.File_Names (Unit_Kind) :=\n                     (Name         => Canonical_File_Name,\n                      Display_Name => File_Name,"}, {"sha": "56ee59fa61fce5e10ae72a2bb6227de4df6db18d", "filename": "gcc/ada/prj-nmsc.ads", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a336eacaf1fe8e0ac28decabbc59c7972766f742/gcc%2Fada%2Fprj-nmsc.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a336eacaf1fe8e0ac28decabbc59c7972766f742/gcc%2Fada%2Fprj-nmsc.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-nmsc.ads?ref=a336eacaf1fe8e0ac28decabbc59c7972766f742", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---             Copyright (C) 2000-2003 Free Software Foundation, Inc.       --\n+--             Copyright (C) 2000-2004 Free Software Foundation, Inc.       --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -31,12 +31,17 @@ private package Prj.Nmsc is\n \n    procedure Ada_Check\n      (Project      : Project_Id;\n-      Report_Error : Put_Line_Access);\n+      Report_Error : Put_Line_Access;\n+      Trusted_Mode : Boolean);\n    --  Call Language_Independent_Check.\n    --  Check the naming scheme for Ada.\n    --  Find the Ada source files if any.\n    --  If Report_Error is null , use the standard error reporting mechanism\n    --  (Errout). Otherwise, report errors using Report_Error.\n+   --  If Trusted_Mode is True, it is assumed that the project doesn't contain\n+   --  any file duplicated through symbolic links (although the latter are\n+   --  still valid if they point to a file which is outside of the project),\n+   --  and that no directory has a name which is a valid source name.\n \n    procedure Language_Independent_Check\n      (Project      : Project_Id;"}, {"sha": "1258e244ee41c23aada54c3f376ace4cea2a20d8", "filename": "gcc/ada/prj-proc.adb", "status": "modified", "additions": 22, "deletions": 83, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a336eacaf1fe8e0ac28decabbc59c7972766f742/gcc%2Fada%2Fprj-proc.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a336eacaf1fe8e0ac28decabbc59c7972766f742/gcc%2Fada%2Fprj-proc.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-proc.adb?ref=a336eacaf1fe8e0ac28decabbc59c7972766f742", "patch": "@@ -101,14 +101,16 @@ package body Prj.Proc is\n    --  recursively for all imported projects and a extended project, if any.\n    --  Then process the declarative items of the project.\n \n-   procedure Check (Project : in out Project_Id);\n+   procedure Check (Project : in out Project_Id; Trusted_Mode : Boolean);\n    --  Set all projects to not checked, then call Recursive_Check for the\n    --  main project Project. Project is set to No_Project if errors occurred.\n+   --  See Prj.Nmsc.Ada_Check for information on Trusted_Mode.\n \n-   procedure Recursive_Check (Project : Project_Id);\n+   procedure Recursive_Check (Project : Project_Id; Trusted_Mode : Boolean);\n    --  If Project is not marked as checked, mark it as checked, call\n    --  Check_Naming_Scheme for the project, then call itself for a\n    --  possible extended project and all the imported projects of Project.\n+   --  See Prj.Nmsc.Ada_Check for information on Trusted_Mode\n \n    ---------\n    -- Add --\n@@ -205,16 +207,15 @@ package body Prj.Proc is\n    -- Check --\n    -----------\n \n-   procedure Check (Project : in out Project_Id) is\n+   procedure Check (Project : in out Project_Id; Trusted_Mode : Boolean) is\n    begin\n       --  Make sure that all projects are marked as not checked\n \n       for Index in 1 .. Projects.Last loop\n          Projects.Table (Index).Checked := False;\n       end loop;\n \n-      Recursive_Check (Project);\n-\n+      Recursive_Check (Project, Trusted_Mode);\n    end Check;\n \n    ----------------\n@@ -815,7 +816,8 @@ package body Prj.Proc is\n      (Project           : out Project_Id;\n       Success           : out Boolean;\n       From_Project_Node : Project_Node_Id;\n-      Report_Error      : Put_Line_Access)\n+      Report_Error      : Put_Line_Access;\n+      Trusted_Mode      : Boolean := False)\n    is\n       Obj_Dir    : Name_Id;\n       Extending  : Project_Id;\n@@ -839,7 +841,7 @@ package body Prj.Proc is\n          Extended_By       => No_Project);\n \n       if Project /= No_Project then\n-         Check (Project);\n+         Check (Project, Trusted_Mode);\n       end if;\n \n       --  If main project is an extending all project, set the object\n@@ -861,15 +863,15 @@ package body Prj.Proc is\n          end;\n       end if;\n \n-      --  Check that no extended project shares its object directory with\n-      --  another extended project or with its extending project(s).\n+      --  Check that no extending project shares its object directory with\n+      --  the project(s) it extends.\n \n       if Project /= No_Project then\n-         for Extended in 1 .. Projects.Last loop\n-            Extending := Projects.Table (Extended).Extended_By;\n+         for Proj in 1 .. Projects.Last loop\n+            Extending := Projects.Table (Proj).Extended_By;\n \n             if Extending /= No_Project then\n-               Obj_Dir := Projects.Table (Extended).Object_Directory;\n+               Obj_Dir := Projects.Table (Proj).Object_Directory;\n \n                --  Check that a project being extended does not share its\n                --  object directory with any project that extends it, directly\n@@ -885,13 +887,13 @@ package body Prj.Proc is\n                       Projects.Table (Extending2).Object_Directory = Obj_Dir\n                   then\n                      if Projects.Table (Extending2).Virtual then\n-                        Error_Msg_Name_1 := Projects.Table (Extended).Name;\n+                        Error_Msg_Name_1 := Projects.Table (Proj).Name;\n \n                         if Error_Report = null then\n                            Error_Msg\n                              (\"project % cannot be extended by a virtual \" &\n                               \"project with the same object directory\",\n-                              Projects.Table (Extended).Location);\n+                              Projects.Table (Proj).Location);\n \n                         else\n                            Error_Report\n@@ -905,7 +907,7 @@ package body Prj.Proc is\n                      else\n                         Error_Msg_Name_1 :=\n                           Projects.Table (Extending2).Name;\n-                        Error_Msg_Name_2 := Projects.Table (Extended).Name;\n+                        Error_Msg_Name_2 := Projects.Table (Proj).Name;\n \n                         if Error_Report = null then\n                            Error_Msg\n@@ -933,70 +935,6 @@ package body Prj.Proc is\n \n                   Extending2 := Projects.Table (Extending2).Extended_By;\n                end loop;\n-\n-               --  Check that two projects being extended do not share their\n-               --  project directories.\n-\n-               for Prj in Extended + 1 .. Projects.Last loop\n-                  Extending2 := Projects.Table (Prj).Extended_By;\n-\n-                  if Extending2 /= No_Project\n-                    and then Projects.Table (Prj).Sources_Present\n-                    and then Projects.Table (Prj).Object_Directory = Obj_Dir\n-                    and then not Projects.Table (Extending).Virtual\n-                  then\n-                     Error_Msg_Name_1 := Projects.Table (Extending).Name;\n-                     Error_Msg_Name_2 := Projects.Table (Extended).Name;\n-\n-                     if Error_Report = null then\n-                        Error_Msg (\"project % cannot extend project %\",\n-                                   Projects.Table (Extending).Location);\n-\n-                     else\n-                        Error_Report\n-                          (\"project \"\"\" &\n-                           Get_Name_String (Error_Msg_Name_1) &\n-                           \"\"\" cannot extend project \"\"\" &\n-                           Get_Name_String (Error_Msg_Name_2) & '\"',\n-                           Project);\n-                     end if;\n-\n-                     Error_Msg_Name_1 := Projects.Table (Extended).Name;\n-                     Error_Msg_Name_2 := Projects.Table (Prj).Name;\n-\n-                     if Error_Report = null then\n-                        Error_Msg\n-                          (\"\\project % has the same object directory \" &\n-                           \"as project %\",\n-                           Projects.Table (Extending).Location);\n-\n-                     else\n-                        Error_Report\n-                          (\"project \"\"\" &\n-                             Get_Name_String (Error_Msg_Name_1) &\n-                             \"\"\" has the same object directory as project \"\"\" &\n-                             Get_Name_String (Error_Msg_Name_2) & \"\"\",\",\n-                           Project);\n-                     end if;\n-\n-                     Error_Msg_Name_1 := Projects.Table (Extending2).Name;\n-\n-                     if Error_Report = null then\n-                        Error_Msg\n-                          (\"\\which is extended by project %\",\n-                           Projects.Table (Extending).Location);\n-\n-                     else\n-                        Error_Report\n-                          (\"which is extended by project \"\"\" &\n-                           Get_Name_String (Error_Msg_Name_1) & '\"',\n-                           Project);\n-                     end if;\n-\n-                     Project := No_Project;\n-                     exit;\n-                  end if;\n-               end loop;\n             end if;\n          end loop;\n       end if;\n@@ -1817,7 +1755,7 @@ package body Prj.Proc is\n    -- Recursive_Check --\n    ---------------------\n \n-   procedure Recursive_Check (Project : Project_Id) is\n+   procedure Recursive_Check (Project : Project_Id; Trusted_Mode : Boolean) is\n       Data                  : Project_Data;\n       Imported_Project_List : Project_List := Empty_Project_List;\n \n@@ -1838,14 +1776,15 @@ package body Prj.Proc is\n          --  Call itself for a possible extended project.\n          --  (if there is no extended project, then nothing happens).\n \n-         Recursive_Check (Data.Extends);\n+         Recursive_Check (Data.Extends, Trusted_Mode);\n \n          --  Call itself for all imported projects\n \n          Imported_Project_List := Data.Imported_Projects;\n          while Imported_Project_List /= Empty_Project_List loop\n             Recursive_Check\n-              (Project_Lists.Table (Imported_Project_List).Project);\n+              (Project_Lists.Table (Imported_Project_List).Project,\n+               Trusted_Mode);\n             Imported_Project_List :=\n               Project_Lists.Table (Imported_Project_List).Next;\n          end loop;\n@@ -1856,7 +1795,7 @@ package body Prj.Proc is\n             Write_Line (\"\"\"\");\n          end if;\n \n-         Prj.Nmsc.Ada_Check (Project, Error_Report);\n+         Prj.Nmsc.Ada_Check (Project, Error_Report, Trusted_Mode);\n       end if;\n    end Recursive_Check;\n "}, {"sha": "99a329f5dffbb24b7ff974a28cd072f98059944b", "filename": "gcc/ada/prj-proc.ads", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a336eacaf1fe8e0ac28decabbc59c7972766f742/gcc%2Fada%2Fprj-proc.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a336eacaf1fe8e0ac28decabbc59c7972766f742/gcc%2Fada%2Fprj-proc.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-proc.ads?ref=a336eacaf1fe8e0ac28decabbc59c7972766f742", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---             Copyright (C) 2001-2003 Free Software Foundation, Inc.       --\n+--             Copyright (C) 2001-2004 Free Software Foundation, Inc.       --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -36,9 +36,14 @@ package Prj.Proc is\n      (Project           : out Project_Id;\n       Success           : out Boolean;\n       From_Project_Node : Project_Node_Id;\n-      Report_Error      : Put_Line_Access);\n+      Report_Error      : Put_Line_Access;\n+      Trusted_Mode      : Boolean := False);\n    --  Process a project file tree into project file data structures.\n    --  If Report_Error is null, use the error reporting mechanism.\n    --  Otherwise, report errors using Report_Error.\n+   --  If Trusted_Mode is True, it is assumed that the project doesn't contain\n+   --  any file duplicated through symbolic links (although the latter are\n+   --  still valid if they point to a file which is outside of the project),\n+   --  and that no directory has a name which is a valid source name.\n \n end Prj.Proc;"}, {"sha": "0f09236fd8fb173255a9ef0de7b3077e063326d3", "filename": "gcc/ada/prj.adb", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a336eacaf1fe8e0ac28decabbc59c7972766f742/gcc%2Fada%2Fprj.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a336eacaf1fe8e0ac28decabbc59c7972766f742/gcc%2Fada%2Fprj.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj.adb?ref=a336eacaf1fe8e0ac28decabbc59c7972766f742", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---             Copyright (C) 2001-2003 Free Software Foundation, Inc.       --\n+--             Copyright (C) 2001-2004 Free Software Foundation, Inc.       --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -370,6 +370,7 @@ package body Prj is\n       String_Elements.Init;\n       Prj.Com.Units.Init;\n       Prj.Com.Units_Htable.Reset;\n+      Prj.Com.Files_Htable.Reset;\n    end Reset;\n \n    ------------------------"}, {"sha": "738e3eeb67b731b9f51e577cb5215b2273e85598", "filename": "gcc/ada/s-stache.adb", "status": "modified", "additions": 1, "deletions": 231, "changes": 232, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a336eacaf1fe8e0ac28decabbc59c7972766f742/gcc%2Fada%2Fs-stache.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a336eacaf1fe8e0ac28decabbc59c7972766f742/gcc%2Fada%2Fs-stache.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-stache.adb?ref=a336eacaf1fe8e0ac28decabbc59c7972766f742", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                  B o d y                                 --\n --                                                                          --\n---          Copyright (C) 1999-2003 Free Software Foundation, Inc.          --\n+--           Copyright (C) 1999-2004 Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -31,235 +31,5 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-with Ada.Exceptions;\n-\n-with System.Storage_Elements; use System.Storage_Elements;\n-with System.Parameters; use System.Parameters;\n-with System.Soft_Links;\n-with System.CRTL;\n-\n package body System.Stack_Checking is\n-\n-   Kilobyte : constant := 1024;\n-\n-   function Set_Stack_Info (Stack : access Stack_Access) return Stack_Access;\n-\n-   --  The function Set_Stack_Info is the actual function that updates\n-   --  the cache containing a pointer to the Stack_Info. It may also\n-   --  be used for detecting asynchronous abort in combination with\n-   --  Invalidate_Self_Cache.\n-\n-   --  Set_Stack_Info should do the following things in order:\n-   --     1) Get the Stack_Access value for the current task\n-   --     2) Set Stack.all to the value obtained in 1)\n-   --     3) Optionally Poll to check for asynchronous abort\n-\n-   --  This order is important because if at any time a write to\n-   --  the stack cache is pending, that write should be followed\n-   --  by a Poll to prevent loosing signals.\n-\n-   --  Note: This function must be compiled with Polling turned off\n-\n-   --  Note: on systems like VxWorks and OS/2 with real thread-local storage,\n-   --        Set_Stack_Info should return an access value for such local\n-   --        storage. In those cases the cache will always be up-to-date.\n-\n-   --  The following constants should be imported from some system-specific\n-   --  constants package. The constants must be static for performance reasons.\n-\n-   ----------------------------\n-   -- Invalidate_Stack_Cache --\n-   ----------------------------\n-\n-   procedure Invalidate_Stack_Cache (Any_Stack : Stack_Access) is\n-      pragma Warnings (Off, Any_Stack);\n-   begin\n-      Cache := Null_Stack;\n-   end Invalidate_Stack_Cache;\n-\n-   --------------------\n-   -- Set_Stack_Info --\n-   --------------------\n-\n-   function Set_Stack_Info\n-     (Stack : access Stack_Access) return Stack_Access\n-   is\n-      type Frame_Mark is null record;\n-      Frame_Location : Frame_Mark;\n-      Frame_Address  : constant Address := Frame_Location'Address;\n-\n-      My_Stack    : Stack_Access;\n-      Limit_Chars : System.Address;\n-      Limit       : Integer;\n-\n-   begin\n-      --  The order of steps 1 .. 3 is important, see specification.\n-\n-      --  1) Get the Stack_Access value for the current task\n-\n-      My_Stack := Soft_Links.Get_Stack_Info.all;\n-\n-      if My_Stack.Base = Null_Address then\n-\n-         --  First invocation, initialize based on the assumption that\n-         --  there are Environment_Stack_Size bytes available beyond\n-         --  the current frame address.\n-\n-         if My_Stack.Size = 0 then\n-            My_Stack.Size := Storage_Offset (Default_Env_Stack_Size);\n-\n-            --  When the environment variable GNAT_STACK_LIMIT is set,\n-            --  set Environment_Stack_Size to that number of kB.\n-\n-            Limit_Chars := System.CRTL.getenv (\"GNAT_STACK_LIMIT\" & ASCII.NUL);\n-\n-            if Limit_Chars /= Null_Address then\n-               Limit := System.CRTL.atoi (Limit_Chars);\n-\n-               if Limit >= 0 then\n-                  My_Stack.Size := Storage_Offset (Limit) * Kilobyte;\n-               end if;\n-            end if;\n-         end if;\n-\n-         My_Stack.Base := Frame_Address;\n-\n-         if Stack_Grows_Down then\n-\n-            --  Prevent wrap-around on too big stack sizes\n-\n-            My_Stack.Limit := My_Stack.Base - My_Stack.Size;\n-\n-            if My_Stack.Limit > My_Stack.Base then\n-               My_Stack.Limit := Address'First;\n-            end if;\n-\n-         else\n-            My_Stack.Limit := My_Stack.Base + My_Stack.Size;\n-\n-            --  Prevent wrap-around on too big stack sizes\n-\n-            if My_Stack.Limit < My_Stack.Base then\n-               My_Stack.Limit := Address'Last;\n-            end if;\n-         end if;\n-      end if;\n-\n-      --  2) Set Stack.all to the value obtained in 1)\n-\n-      Stack.all := My_Stack;\n-\n-      --  3) Optionally Poll to check for asynchronous abort\n-\n-      if Soft_Links.Check_Abort_Status.all /= 0 then\n-         raise Standard'Abort_Signal;\n-      end if;\n-\n-      return My_Stack; -- Never trust the cached value, but return local copy!\n-   end Set_Stack_Info;\n-\n-   --------------------\n-   -- Set_Stack_Size --\n-   --------------------\n-\n-   --  Specify the stack size for the current frame.\n-\n-   procedure Set_Stack_Size\n-     (Stack_Size : System.Storage_Elements.Storage_Offset)\n-   is\n-      My_Stack      : Stack_Access;\n-      Frame_Address : constant System.Address := My_Stack'Address;\n-\n-   begin\n-      My_Stack := Stack_Check (Frame_Address);\n-\n-      if Stack_Grows_Down then\n-         My_Stack.Limit := My_Stack.Base - Stack_Size;\n-      else\n-         My_Stack.Limit := My_Stack.Base + Stack_Size;\n-      end if;\n-   end Set_Stack_Size;\n-\n-   -----------------\n-   -- Stack_Check --\n-   -----------------\n-\n-   function Stack_Check\n-     (Stack_Address : System.Address) return Stack_Access\n-   is\n-      type Frame_Marker is null record;\n-      Marker        : Frame_Marker;\n-      Cached_Stack  : constant Stack_Access := Cache;\n-      Frame_Address : constant System.Address := Marker'Address;\n-\n-   begin\n-      --  This function first does a \"cheap\" check which is correct\n-      --  if it succeeds. In case of failure, the full check is done.\n-      --  Ideally the cheap check should be done in an optimized manner,\n-      --  or be inlined.\n-\n-      if (Stack_Grows_Down and then\n-            (Frame_Address <= Cached_Stack.Base\n-               and\n-             Stack_Address > Cached_Stack.Limit))\n-        or else\n-         (not Stack_Grows_Down and then\n-            (Frame_Address >= Cached_Stack.Base\n-               and\n-             Stack_Address < Cached_Stack.Limit))\n-      then\n-         --  Cached_Stack is valid as it passed the stack check\n-         return Cached_Stack;\n-      end if;\n-\n-      Full_Check :\n-      declare\n-         My_Stack : constant Stack_Access := Set_Stack_Info (Cache'Access);\n-         --  At this point Stack.all might already be invalid, so\n-         --  it is essential to use our local copy of Stack!\n-\n-      begin\n-         if (Stack_Grows_Down and then\n-               (not (Frame_Address <= My_Stack.Base)))\n-           or else\n-            (not Stack_Grows_Down and then\n-               (not (Frame_Address >= My_Stack.Base)))\n-         then\n-            --  The returned Base is lower than the stored one,\n-            --  so assume that the original one wasn't right and use the\n-            --  current Frame_Address as new one. This allows initializing\n-            --  Base with the Frame_Address as approximation.\n-            --  During initialization the Frame_Address will be close to\n-            --  the stack base anyway: the difference should be compensated\n-            --  for in the stack reserve.\n-\n-            My_Stack.Base := Frame_Address;\n-         end if;\n-\n-         if (Stack_Grows_Down and then\n-                  Stack_Address < My_Stack.Limit)\n-           or else\n-            (not Stack_Grows_Down and then\n-                  Stack_Address > My_Stack.Limit)\n-         then\n-            Ada.Exceptions.Raise_Exception\n-              (E       => Storage_Error'Identity,\n-               Message => \"stack overflow detected\");\n-         end if;\n-\n-         return My_Stack;\n-      end Full_Check;\n-   end Stack_Check;\n-\n-   ------------------------\n-   -- Update_Stack_Cache --\n-   ------------------------\n-\n-   procedure Update_Stack_Cache (Stack : Stack_Access) is\n-   begin\n-      if not Multi_Processor then\n-         Cache := Stack;\n-      end if;\n-   end Update_Stack_Cache;\n-\n end System.Stack_Checking;"}, {"sha": "932ecf1b3a9ae083be26fcb0aec281ba43fd95a8", "filename": "gcc/ada/s-stache.ads", "status": "modified", "additions": 9, "deletions": 36, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a336eacaf1fe8e0ac28decabbc59c7972766f742/gcc%2Fada%2Fs-stache.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a336eacaf1fe8e0ac28decabbc59c7972766f742/gcc%2Fada%2Fs-stache.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-stache.ads?ref=a336eacaf1fe8e0ac28decabbc59c7972766f742", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                  S p e c                                 --\n --                                                                          --\n---           Copyright (C) 1999-2003 Free Software Foundation, Inc.         --\n+--           Copyright (C) 1999-2004 Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -33,14 +33,16 @@\n \n --  This package provides a system-independent implementation of stack\n --  checking using comparison with stack base and limit.\n+--  This package defines basic types and objects. Operations related\n+--  to stack checking can be found in package\n+--  System.Stack_Checking.Operations.\n \n with System.Storage_Elements;\n \n-pragma Polling (Off);\n---  Turn off polling, we do not want polling to take place during stack\n---  checking operations. It causes infinite loops and other problems.\n-\n package System.Stack_Checking is\n+\n+   pragma Elaborate_Body;\n+\n    type Stack_Info is record\n       Limit : System.Address := System.Null_Address;\n       Base  : System.Address := System.Null_Address;\n@@ -59,30 +61,7 @@ package System.Stack_Checking is\n    --  upgrowing stack) may contain any address that is part of another stack.\n    --  The Stack_Access may be part of a larger data structure.\n \n-   Multi_Processor        : constant Boolean := False; --  Not supported yet\n-\n-   ----------------------\n-   -- Client Interface --\n-   ----------------------\n-\n-   procedure Set_Stack_Size\n-     (Stack_Size : System.Storage_Elements.Storage_Offset);\n-   --  Specify the stack size for the current task.\n-\n-   procedure Update_Stack_Cache (Stack : Stack_Access);\n-   --  Set the stack cache for the current task. Note that this is only\n-   --  for optimization purposes, nothing can be assumed about the\n-   --  contents of the cache at any time, see Set_Stack_Info.\n-\n-   procedure Invalidate_Stack_Cache (Any_Stack : Stack_Access);\n-   --  Invalidate cache entries for the task T that owns Any_Stack.\n-   --  This causes the Set_Stack_Info function to be called during\n-   --  the next stack check done by T. This can be used to interrupt\n-   --  task T asynchronously.\n-   --  Stack_Check should be called in loops for this to work reliably.\n-\n-   function Stack_Check (Stack_Address : System.Address) return Stack_Access;\n-   --  This version of Stack_Check should not be inlined.\n+   Multi_Processor : constant Boolean := False; --  Not supported yet\n \n private\n \n@@ -92,14 +71,8 @@ private\n       Size  => 0);\n    --  Use explicit assignment to avoid elaboration code (call to init proc).\n \n-   Null_Stack       : constant Stack_Access := Null_Stack_Info'Access;\n+   Null_Stack : constant Stack_Access := Null_Stack_Info'Access;\n    --  Stack_Access value that will return a Stack_Base and Stack_Limit\n    --  that fail any stack check.\n \n-   Cache            : aliased Stack_Access := Null_Stack;\n-\n-   pragma Export (C, Cache, \"_gnat_stack_cache\");\n-   pragma Export (C, Stack_Check, \"_gnat_stack_check\");\n-   pragma Export (C, Set_Stack_Size, \"__gnat_set_stack_size\");\n-\n end System.Stack_Checking;"}, {"sha": "3a1b1e91a079db0e76d8e20e09aa93829f399b40", "filename": "gcc/ada/s-stchop.adb", "status": "added", "additions": 273, "deletions": 0, "changes": 273, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a336eacaf1fe8e0ac28decabbc59c7972766f742/gcc%2Fada%2Fs-stchop.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a336eacaf1fe8e0ac28decabbc59c7972766f742/gcc%2Fada%2Fs-stchop.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-stchop.adb?ref=a336eacaf1fe8e0ac28decabbc59c7972766f742", "patch": "@@ -0,0 +1,273 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                GNU ADA RUN-TIME LIBRARY (GNARL) COMPONENTS               --\n+--                                                                          --\n+--     S Y S T E M . S T A C K _ C H E C K I N G . O P E R A T I O N S      --\n+--                                                                          --\n+--                                  B o d y                                 --\n+--                                                                          --\n+--          Copyright (C) 1999-2004 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNARL is free software; you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion. GNARL is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNARL; see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNARL was developed by the GNARL team at Florida State University.       --\n+-- Extensive contributions were provided by Ada Core Technologies, Inc.     --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This is the general implementation of this package. There is a VxWorks\n+--  specific version of this package (5zstchop.adb). This file should\n+--  be kept synchronized with it.\n+\n+pragma Restrictions (No_Elaboration_Code);\n+--  We want to guarantee the absence of elaboration code because the\n+--  binder does not handle references to this package.\n+\n+with Ada.Exceptions;\n+\n+with System.Storage_Elements; use System.Storage_Elements;\n+with System.Parameters; use System.Parameters;\n+with System.Soft_Links;\n+with System.CRTL;\n+\n+package body System.Stack_Checking.Operations is\n+\n+   Kilobyte : constant := 1024;\n+\n+   function Set_Stack_Info (Stack : access Stack_Access) return Stack_Access;\n+\n+   --  The function Set_Stack_Info is the actual function that updates\n+   --  the cache containing a pointer to the Stack_Info. It may also\n+   --  be used for detecting asynchronous abort in combination with\n+   --  Invalidate_Self_Cache.\n+\n+   --  Set_Stack_Info should do the following things in order:\n+   --     1) Get the Stack_Access value for the current task\n+   --     2) Set Stack.all to the value obtained in 1)\n+   --     3) Optionally Poll to check for asynchronous abort\n+\n+   --  This order is important because if at any time a write to\n+   --  the stack cache is pending, that write should be followed\n+   --  by a Poll to prevent loosing signals.\n+\n+   --  Note: This function must be compiled with Polling turned off\n+\n+   --  Note: on systems like VxWorks and OS/2 with real thread-local storage,\n+   --        Set_Stack_Info should return an access value for such local\n+   --        storage. In those cases the cache will always be up-to-date.\n+\n+   --  The following constants should be imported from some system-specific\n+   --  constants package. The constants must be static for performance reasons.\n+\n+   ----------------------------\n+   -- Invalidate_Stack_Cache --\n+   ----------------------------\n+\n+   procedure Invalidate_Stack_Cache (Any_Stack : Stack_Access) is\n+      pragma Warnings (Off, Any_Stack);\n+   begin\n+      Cache := Null_Stack;\n+   end Invalidate_Stack_Cache;\n+\n+   --------------------\n+   -- Set_Stack_Info --\n+   --------------------\n+\n+   function Set_Stack_Info\n+     (Stack : access Stack_Access) return Stack_Access\n+   is\n+      type Frame_Mark is null record;\n+      Frame_Location : Frame_Mark;\n+      Frame_Address  : constant Address := Frame_Location'Address;\n+\n+      My_Stack    : Stack_Access;\n+      Limit_Chars : System.Address;\n+      Limit       : Integer;\n+\n+   begin\n+      --  The order of steps 1 .. 3 is important, see specification.\n+\n+      --  1) Get the Stack_Access value for the current task\n+\n+      My_Stack := Soft_Links.Get_Stack_Info.all;\n+\n+      if My_Stack.Base = Null_Address then\n+\n+         --  First invocation, initialize based on the assumption that\n+         --  there are Environment_Stack_Size bytes available beyond\n+         --  the current frame address.\n+\n+         if My_Stack.Size = 0 then\n+            My_Stack.Size := Storage_Offset (Default_Env_Stack_Size);\n+\n+            --  When the environment variable GNAT_STACK_LIMIT is set,\n+            --  set Environment_Stack_Size to that number of kB.\n+\n+            Limit_Chars := System.CRTL.getenv (\"GNAT_STACK_LIMIT\" & ASCII.NUL);\n+\n+            if Limit_Chars /= Null_Address then\n+               Limit := System.CRTL.atoi (Limit_Chars);\n+\n+               if Limit >= 0 then\n+                  My_Stack.Size := Storage_Offset (Limit) * Kilobyte;\n+               end if;\n+            end if;\n+         end if;\n+\n+         My_Stack.Base := Frame_Address;\n+\n+         if Stack_Grows_Down then\n+\n+            --  Prevent wrap-around on too big stack sizes\n+\n+            My_Stack.Limit := My_Stack.Base - My_Stack.Size;\n+\n+            if My_Stack.Limit > My_Stack.Base then\n+               My_Stack.Limit := Address'First;\n+            end if;\n+\n+         else\n+            My_Stack.Limit := My_Stack.Base + My_Stack.Size;\n+\n+            --  Prevent wrap-around on too big stack sizes\n+\n+            if My_Stack.Limit < My_Stack.Base then\n+               My_Stack.Limit := Address'Last;\n+            end if;\n+         end if;\n+      end if;\n+\n+      --  2) Set Stack.all to the value obtained in 1)\n+\n+      Stack.all := My_Stack;\n+\n+      --  3) Optionally Poll to check for asynchronous abort\n+\n+      if Soft_Links.Check_Abort_Status.all /= 0 then\n+         raise Standard'Abort_Signal;\n+      end if;\n+\n+      return My_Stack; -- Never trust the cached value, but return local copy!\n+   end Set_Stack_Info;\n+\n+   --------------------\n+   -- Set_Stack_Size --\n+   --------------------\n+\n+   --  Specify the stack size for the current frame.\n+\n+   procedure Set_Stack_Size\n+     (Stack_Size : System.Storage_Elements.Storage_Offset)\n+   is\n+      My_Stack      : Stack_Access;\n+      Frame_Address : constant System.Address := My_Stack'Address;\n+\n+   begin\n+      My_Stack := Stack_Check (Frame_Address);\n+\n+      if Stack_Grows_Down then\n+         My_Stack.Limit := My_Stack.Base - Stack_Size;\n+      else\n+         My_Stack.Limit := My_Stack.Base + Stack_Size;\n+      end if;\n+   end Set_Stack_Size;\n+\n+   -----------------\n+   -- Stack_Check --\n+   -----------------\n+\n+   function Stack_Check\n+     (Stack_Address : System.Address) return Stack_Access\n+   is\n+      type Frame_Marker is null record;\n+      Marker        : Frame_Marker;\n+      Cached_Stack  : constant Stack_Access := Cache;\n+      Frame_Address : constant System.Address := Marker'Address;\n+\n+   begin\n+      --  This function first does a \"cheap\" check which is correct\n+      --  if it succeeds. In case of failure, the full check is done.\n+      --  Ideally the cheap check should be done in an optimized manner,\n+      --  or be inlined.\n+\n+      if (Stack_Grows_Down and then\n+            (Frame_Address <= Cached_Stack.Base\n+               and\n+             Stack_Address > Cached_Stack.Limit))\n+        or else\n+         (not Stack_Grows_Down and then\n+            (Frame_Address >= Cached_Stack.Base\n+               and\n+             Stack_Address < Cached_Stack.Limit))\n+      then\n+         --  Cached_Stack is valid as it passed the stack check\n+         return Cached_Stack;\n+      end if;\n+\n+      Full_Check :\n+      declare\n+         My_Stack : constant Stack_Access := Set_Stack_Info (Cache'Access);\n+         --  At this point Stack.all might already be invalid, so\n+         --  it is essential to use our local copy of Stack!\n+\n+      begin\n+         if (Stack_Grows_Down and then\n+               (not (Frame_Address <= My_Stack.Base)))\n+           or else\n+            (not Stack_Grows_Down and then\n+               (not (Frame_Address >= My_Stack.Base)))\n+         then\n+            --  The returned Base is lower than the stored one,\n+            --  so assume that the original one wasn't right and use the\n+            --  current Frame_Address as new one. This allows initializing\n+            --  Base with the Frame_Address as approximation.\n+            --  During initialization the Frame_Address will be close to\n+            --  the stack base anyway: the difference should be compensated\n+            --  for in the stack reserve.\n+\n+            My_Stack.Base := Frame_Address;\n+         end if;\n+\n+         if (Stack_Grows_Down and then\n+                  Stack_Address < My_Stack.Limit)\n+           or else\n+            (not Stack_Grows_Down and then\n+                  Stack_Address > My_Stack.Limit)\n+         then\n+            Ada.Exceptions.Raise_Exception\n+              (E       => Storage_Error'Identity,\n+               Message => \"stack overflow detected\");\n+         end if;\n+\n+         return My_Stack;\n+      end Full_Check;\n+   end Stack_Check;\n+\n+   ------------------------\n+   -- Update_Stack_Cache --\n+   ------------------------\n+\n+   procedure Update_Stack_Cache (Stack : Stack_Access) is\n+   begin\n+      if not Multi_Processor then\n+         Cache := Stack;\n+      end if;\n+   end Update_Stack_Cache;\n+\n+end System.Stack_Checking.Operations;"}, {"sha": "10217204d6f36cbc4432612ac8e277b4efd9d301", "filename": "gcc/ada/s-stchop.ads", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a336eacaf1fe8e0ac28decabbc59c7972766f742/gcc%2Fada%2Fs-stchop.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a336eacaf1fe8e0ac28decabbc59c7972766f742/gcc%2Fada%2Fs-stchop.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-stchop.ads?ref=a336eacaf1fe8e0ac28decabbc59c7972766f742", "patch": "@@ -0,0 +1,74 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                GNU ADA RUN-TIME LIBRARY (GNARL) COMPONENTS               --\n+--                                                                          --\n+--     S Y S T E M . S T A C K _ C H E C K I N G . O P E R A T I O N S      --\n+--                                                                          --\n+--                                  S p e c                                 --\n+--                                                                          --\n+--            Copyright (C) 1999-2004 Free Software Foundation, Inc.        --\n+--                                                                          --\n+-- GNARL is free software; you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion. GNARL is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNARL; see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNARL was developed by the GNARL team at Florida State University.       --\n+-- Extensive contributions were provided by Ada Core Technologies, Inc.     --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This package provides a implementation of stack checking operations\n+--  using comparison with stack base and limit.\n+\n+pragma Restrictions (No_Elaboration_Code);\n+--  We want to guarantee the absence of elaboration code because the\n+--  binder does not handle references to this package.\n+\n+with System.Storage_Elements;\n+\n+pragma Polling (Off);\n+--  Turn off polling, we do not want polling to take place during stack\n+--  checking operations. It causes infinite loops and other problems.\n+\n+package System.Stack_Checking.Operations is\n+   procedure Set_Stack_Size\n+     (Stack_Size : System.Storage_Elements.Storage_Offset);\n+   --  Specify the stack size for the current task.\n+\n+   procedure Update_Stack_Cache (Stack : Stack_Access);\n+   --  Set the stack cache for the current task. Note that this is only\n+   --  for optimization purposes, nothing can be assumed about the\n+   --  contents of the cache at any time, see Set_Stack_Info.\n+\n+   procedure Invalidate_Stack_Cache (Any_Stack : Stack_Access);\n+   --  Invalidate cache entries for the task T that owns Any_Stack.\n+   --  This causes the Set_Stack_Info function to be called during\n+   --  the next stack check done by T. This can be used to interrupt\n+   --  task T asynchronously.\n+   --  Stack_Check should be called in loops for this to work reliably.\n+\n+   function Stack_Check (Stack_Address : System.Address) return Stack_Access;\n+   --  This version of Stack_Check should not be inlined.\n+\n+private\n+\n+   Cache : aliased Stack_Access := Null_Stack;\n+\n+   pragma Export (C, Cache, \"_gnat_stack_cache\");\n+   pragma Export (C, Stack_Check, \"_gnat_stack_check\");\n+\n+end System.Stack_Checking.Operations;"}, {"sha": "b1e57079bbfb664ab01b5b9427a6c52dadf2bdef", "filename": "gcc/ada/scn.adb", "status": "modified", "additions": 20, "deletions": 13, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a336eacaf1fe8e0ac28decabbc59c7972766f742/gcc%2Fada%2Fscn.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a336eacaf1fe8e0ac28decabbc59c7972766f742/gcc%2Fada%2Fscn.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fscn.adb?ref=a336eacaf1fe8e0ac28decabbc59c7972766f742", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2003 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2004 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -170,6 +170,7 @@ package body Scn is\n       begin\n          while Source (Scan_Ptr) /= CR\n            and then Source (Scan_Ptr) /= LF\n+           and then Source (Scan_Ptr) /= EOF\n          loop\n             Scan_Ptr := Scan_Ptr + 1;\n          end loop;\n@@ -210,21 +211,27 @@ package body Scn is\n \n          Check_End_Of_Line;\n \n-         declare\n-            Physical : Boolean;\n+         if Source (Scan_Ptr) /= EOF then\n \n-         begin\n-            Skip_Line_Terminators (Scan_Ptr, Physical);\n+            --  We have to take into account a degenerate case when the source\n+            --  file contains only comments and no Ada code.\n \n-            --  If we are at start of physical line, update scan pointers\n-            --  to reflect the start of the new line.\n+            declare\n+               Physical : Boolean;\n \n-            if Physical then\n-               Current_Line_Start       := Scan_Ptr;\n-               Start_Column             := Scanner.Set_Start_Column;\n-               First_Non_Blank_Location := Scan_Ptr;\n-            end if;\n-         end;\n+            begin\n+               Skip_Line_Terminators (Scan_Ptr, Physical);\n+\n+               --  If we are at start of physical line, update scan pointers\n+               --  to reflect the start of the new line.\n+\n+               if Physical then\n+                  Current_Line_Start       := Scan_Ptr;\n+                  Start_Column             := Scanner.Set_Start_Column;\n+                  First_Non_Blank_Location := Scan_Ptr;\n+               end if;\n+            end;\n+         end if;\n       end loop;\n    end Determine_License;\n "}, {"sha": "c6aa3599d5df36674a9824a3ea36b21ee242fcc3", "filename": "gcc/ada/sem_warn.adb", "status": "modified", "additions": 30, "deletions": 1, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a336eacaf1fe8e0ac28decabbc59c7972766f742/gcc%2Fada%2Fsem_warn.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a336eacaf1fe8e0ac28decabbc59c7972766f742/gcc%2Fada%2Fsem_warn.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_warn.adb?ref=a336eacaf1fe8e0ac28decabbc59c7972766f742", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1999-2003 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1999-2004 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -472,9 +472,38 @@ package body Sem_Warn is\n                      end loop;\n \n                      --  Here we issue the warning, all checks completed\n+                     --  If the unset reference is prefix of a selected\n+                     --  component that comes from source, mention the\n+                     --  component as well. If the selected component comes\n+                     --  from expansion, all we know is that the entity is\n+                     --  not fully initialized at the point of the reference.\n+                     --  Locate an unintialized component to get a better\n+                     --  error message.\n \n                      if Nkind (Parent (UR)) = N_Selected_Component then\n                         Error_Msg_Node_2 := Selector_Name (Parent (UR));\n+\n+                        if not Comes_From_Source (Parent (UR)) then\n+                           declare\n+                              Comp : Entity_Id;\n+\n+                           begin\n+                              Comp := First_Entity (Etype (E1));\n+                              while Present (Comp) loop\n+                                 if Ekind (Comp) = E_Component\n+                                   and then Nkind (Parent (Comp)) =\n+                                     N_Component_Declaration\n+                                   and then No (Expression (Parent (Comp)))\n+                                 then\n+                                    Error_Msg_Node_2 := Comp;\n+                                    exit;\n+                                 end if;\n+\n+                                 Next_Entity (Comp);\n+                              end loop;\n+                           end;\n+                        end if;\n+\n                         Error_Msg_N\n                           (\"`&.&` may be referenced before it has a value?\",\n                            UR);"}]}