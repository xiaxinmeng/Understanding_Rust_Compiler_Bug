{"sha": "95ad46b905b6e49c6888f2923347d0b85c466b96", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTVhZDQ2YjkwNWI2ZTQ5YzY4ODhmMjkyMzM0N2QwYjg1YzQ2NmI5Ng==", "commit": {"author": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2021-08-20T13:52:37Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2021-08-22T13:56:26Z"}, "message": "Extract header Path type-check code into cc file\n\nPart of the ongoing effort to extract code into cc files to help\ncompilation times.", "tree": {"sha": "f2313e0f7f5aea2288b09dc1237a27e070e51e7a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f2313e0f7f5aea2288b09dc1237a27e070e51e7a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/95ad46b905b6e49c6888f2923347d0b85c466b96", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/95ad46b905b6e49c6888f2923347d0b85c466b96", "html_url": "https://github.com/Rust-GCC/gccrs/commit/95ad46b905b6e49c6888f2923347d0b85c466b96", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/95ad46b905b6e49c6888f2923347d0b85c466b96/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e9746f445cf57c12f70d0016722835ec504cc655", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e9746f445cf57c12f70d0016722835ec504cc655", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e9746f445cf57c12f70d0016722835ec504cc655"}], "stats": {"total": 896, "additions": 467, "deletions": 429}, "files": [{"sha": "9c69b44e49037932636f7c03c72a432c4d36739d", "filename": "gcc/rust/Make-lang.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95ad46b905b6e49c6888f2923347d0b85c466b96/gcc%2Frust%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95ad46b905b6e49c6888f2923347d0b85c466b96/gcc%2Frust%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2FMake-lang.in?ref=95ad46b905b6e49c6888f2923347d0b85c466b96", "patch": "@@ -84,6 +84,7 @@ GRS_OBJS = \\\n     rust/rust-hir-trait-resolve.o \\\n     rust/rust-hir-const-fold.o \\\n     rust/rust-lint-marklive.o \\\n+    rust/rust-hir-type-check-path.o \\\n     $(END)\n # removed object files from here\n "}, {"sha": "a95a4e91c787767033bfd3250677332c4726837c", "filename": "gcc/rust/typecheck/rust-hir-type-check-expr.h", "status": "modified", "additions": 5, "deletions": 429, "changes": 434, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95ad46b905b6e49c6888f2923347d0b85c466b96/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95ad46b905b6e49c6888f2923347d0b85c466b96/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h?ref=95ad46b905b6e49c6888f2923347d0b85c466b96", "patch": "@@ -925,169 +925,9 @@ class TypeCheckExpr : public TypeCheckBase\n     infered = resolved->get_field_type ();\n   }\n \n-  void visit (HIR::QualifiedPathInExpression &expr) override\n-  {\n-    HIR::QualifiedPathType qual_path_type = expr.get_path_type ();\n-    TyTy::BaseType *root\n-      = TypeCheckType::Resolve (qual_path_type.get_type ().get ());\n-    if (root->get_kind () == TyTy::TypeKind::ERROR)\n-      return;\n-\n-    if (!qual_path_type.has_as_clause ())\n-      {\n-\t// then this is just a normal path-in-expression\n-\tNodeId root_resolved_node_id = UNKNOWN_NODEID;\n-\tbool ok = resolver->lookup_resolved_type (\n-\t  qual_path_type.get_type ()->get_mappings ().get_nodeid (),\n-\t  &root_resolved_node_id);\n-\trust_assert (ok);\n-\n-\tresolve_segments (root_resolved_node_id, expr.get_segments (), 0, root,\n-\t\t\t  expr.get_mappings (), expr.get_locus ());\n-      }\n-\n-    // Resolve the trait now\n-    TraitReference *trait_ref\n-      = TraitResolver::Resolve (*qual_path_type.get_trait ().get ());\n-    if (trait_ref->is_error ())\n-      return;\n-\n-    // does this type actually implement this type-bound?\n-    if (!TypeBoundsProbe::is_bound_satisfied_for_type (root, trait_ref))\n-      return;\n-\n-    // then we need to look at the next segment to create perform the correct\n-    // projection type\n-    if (expr.get_segments ().empty ())\n-      return;\n-\n-    // we need resolve to the impl block\n-    NodeId impl_resolved_id = UNKNOWN_NODEID;\n-    bool ok = resolver->lookup_resolved_name (\n-      qual_path_type.get_mappings ().get_nodeid (), &impl_resolved_id);\n-    rust_assert (ok);\n-\n-    HirId impl_block_id;\n-    ok = mappings->lookup_node_to_hir (expr.get_mappings ().get_crate_num (),\n-\t\t\t\t       impl_resolved_id, &impl_block_id);\n-    rust_assert (ok);\n-\n-    AssociatedImplTrait *lookup_associated = nullptr;\n-    bool found_impl_trait\n-      = context->lookup_associated_trait_impl (impl_block_id,\n-\t\t\t\t\t       &lookup_associated);\n-    rust_assert (found_impl_trait);\n-\n-    DefId resolved_item_id = UNKNOWN_DEFID;\n-    HIR::PathExprSegment &item_seg = expr.get_segments ().at (0);\n-\n-    const TraitItemReference *trait_item_ref = nullptr;\n-    ok = trait_ref->lookup_trait_item (item_seg.get_segment ().as_string (),\n-\t\t\t\t       &trait_item_ref);\n-    if (!ok)\n-      {\n-\trust_error_at (item_seg.get_locus (), \"unknown associated item\");\n-\treturn;\n-      }\n-    resolved_item_id = trait_item_ref->get_mappings ().get_defid ();\n-\n-    infered = lookup_associated->get_projected_type (\n-      trait_item_ref, root, item_seg.get_mappings ().get_hirid (),\n-      item_seg.get_locus ());\n-\n-    // turbo-fish segment path::<ty>\n-    if (item_seg.has_generic_args ())\n-      {\n-\tif (!infered->can_substitute ())\n-\t  {\n-\t    rust_error_at (item_seg.get_locus (),\n-\t\t\t   \"substitutions not supported for %s\",\n-\t\t\t   infered->as_string ().c_str ());\n-\t    infered = new TyTy::ErrorType (expr.get_mappings ().get_hirid ());\n-\t    return;\n-\t  }\n-\tinfered = SubstMapper::Resolve (infered, expr.get_locus (),\n-\t\t\t\t\t&item_seg.get_generic_args ());\n-      }\n-\n-    TyTy::ProjectionType *projection\n-      = new TyTy::ProjectionType (qual_path_type.get_mappings ().get_hirid (),\n-\t\t\t\t  TyTy::TyVar (root->get_ref ()), trait_ref,\n-\t\t\t\t  resolved_item_id, lookup_associated);\n-    context->insert_type (qual_path_type.get_mappings (), projection);\n-\n-    // continue on as a path-in-expression\n-    NodeId root_resolved_node_id\n-      = trait_item_ref->get_mappings ().get_nodeid ();\n-    bool fully_resolved = expr.get_segments ().size () <= 1;\n-\n-    if (fully_resolved)\n-      {\n-\t// lookup if the name resolver was able to canonically resolve this or\n-\t// not\n-\tNodeId path_resolved_id = UNKNOWN_NODEID;\n-\tif (resolver->lookup_resolved_name (expr.get_mappings ().get_nodeid (),\n-\t\t\t\t\t    &path_resolved_id))\n-\t  {\n-\t    rust_assert (path_resolved_id == root_resolved_node_id);\n-\t  }\n-\t// check the type scope\n-\telse if (resolver->lookup_resolved_type (\n-\t\t   expr.get_mappings ().get_nodeid (), &path_resolved_id))\n-\t  {\n-\t    rust_assert (path_resolved_id == root_resolved_node_id);\n-\t  }\n-\telse\n-\t  {\n-\t    resolver->insert_resolved_name (expr.get_mappings ().get_nodeid (),\n-\t\t\t\t\t    root_resolved_node_id);\n-\t  }\n-\n-\tcontext->insert_receiver (expr.get_mappings ().get_hirid (), root);\n-\treturn;\n-      }\n-\n-    resolve_segments (root_resolved_node_id, expr.get_segments (), 1, infered,\n-\t\t      expr.get_mappings (), expr.get_locus ());\n-  }\n-\n-  void visit (HIR::PathInExpression &expr) override\n-  {\n-    NodeId resolved_node_id = UNKNOWN_NODEID;\n-\n-    size_t offset = -1;\n-    TyTy::BaseType *tyseg\n-      = resolve_root_path (expr, &offset, &resolved_node_id);\n-\n-    if (tyseg == nullptr)\n-      {\n-\trust_debug_loc (expr.get_locus (), \"failed to resolve root_seg\");\n-      }\n-    rust_assert (tyseg != nullptr);\n+  void visit (HIR::QualifiedPathInExpression &expr) override;\n \n-    if (tyseg->get_kind () == TyTy::TypeKind::ERROR)\n-      return;\n-\n-    if (expr.get_num_segments () == 1)\n-      {\n-\tLocation locus = expr.get_segments ().back ().get_locus ();\n-\n-\tbool is_big_self\n-\t  = expr.get_segments ().front ().get_segment ().as_string ().compare (\n-\t      \"Self\")\n-\t    == 0;\n-\tif (!is_big_self && tyseg->needs_generic_substitutions ())\n-\t  {\n-\t    tyseg = SubstMapper::InferSubst (tyseg, locus);\n-\t  }\n-\n-\tinfered = tyseg;\n-\treturn;\n-      }\n-\n-    resolve_segments (resolved_node_id, expr.get_segments (), offset, tyseg,\n-\t\t      expr.get_mappings (), expr.get_locus ());\n-  }\n+  void visit (HIR::PathInExpression &expr) override;\n \n   void visit (HIR::LoopExpr &expr) override\n   {\n@@ -1235,277 +1075,13 @@ class TypeCheckExpr : public TypeCheckBase\n   // Beware: currently returns Tyty::ErrorType or nullptr in case of error.\n   TyTy::BaseType *resolve_root_path (HIR::PathInExpression &expr,\n \t\t\t\t     size_t *offset,\n-\t\t\t\t     NodeId *root_resolved_node_id)\n-  {\n-    TyTy::BaseType *root_tyty = nullptr;\n-    *offset = 0;\n-    for (size_t i = 0; i < expr.get_num_segments (); i++)\n-      {\n-\tHIR::PathExprSegment &seg = expr.get_segments ().at (i);\n-\n-\tbool have_more_segments = (expr.get_num_segments () - 1 != i);\n-\tbool is_root = *offset == 0;\n-\tNodeId ast_node_id = seg.get_mappings ().get_nodeid ();\n-\n-\t// then lookup the reference_node_id\n-\tNodeId ref_node_id = UNKNOWN_NODEID;\n-\tif (resolver->lookup_resolved_name (ast_node_id, &ref_node_id))\n-\t  {\n-\t    // these ref_node_ids will resolve to a pattern declaration but we\n-\t    // are interested in the definition that this refers to get the\n-\t    // parent id\n-\t    Definition def;\n-\t    if (!resolver->lookup_definition (ref_node_id, &def))\n-\t      {\n-\t\trust_error_at (expr.get_locus (),\n-\t\t\t       \"unknown reference for resolved name\");\n-\t\treturn new TyTy::ErrorType (expr.get_mappings ().get_hirid ());\n-\t      }\n-\t    ref_node_id = def.parent;\n-\t  }\n-\telse\n-\t  {\n-\t    resolver->lookup_resolved_type (ast_node_id, &ref_node_id);\n-\t  }\n-\n-\t// ref_node_id is the NodeId that the segments refers to.\n-\tif (ref_node_id == UNKNOWN_NODEID)\n-\t  {\n-\t    if (is_root)\n-\t      {\n-\t\trust_error_at (seg.get_locus (),\n-\t\t\t       \"failed to type resolve root segment\");\n-\t\treturn new TyTy::ErrorType (expr.get_mappings ().get_hirid ());\n-\t      }\n-\t    return root_tyty;\n-\t  }\n-\n-\t// node back to HIR\n-\tHirId ref;\n-\tif (!mappings->lookup_node_to_hir (\n-\t      expr.get_mappings ().get_crate_num (), ref_node_id, &ref))\n-\t  {\n-\t    if (is_root)\n-\t      {\n-\t\trust_error_at (seg.get_locus (), \"456 reverse lookup failure\");\n-\t\trust_debug_loc (\n-\t\t  seg.get_locus (),\n-\t\t  \"failure with [%s] mappings [%s] ref_node_id [%u]\",\n-\t\t  seg.as_string ().c_str (),\n-\t\t  seg.get_mappings ().as_string ().c_str (), ref_node_id);\n-\n-\t\treturn new TyTy::ErrorType (expr.get_mappings ().get_hirid ());\n-\t      }\n-\n-\t    return root_tyty;\n-\t  }\n-\n-\tauto seg_is_module\n-\t  = (nullptr\n-\t     != mappings->lookup_module (expr.get_mappings ().get_crate_num (),\n-\t\t\t\t\t ref));\n-\n-\tif (seg_is_module)\n-\t  {\n-\t    // A::B::C::this_is_a_module::D::E::F\n-\t    //          ^^^^^^^^^^^^^^^^\n-\t    //          Currently handling this.\n-\t    if (have_more_segments)\n-\t      {\n-\t\t(*offset)++;\n-\t\tcontinue;\n-\t      }\n-\n-\t    // In the case of :\n-\t    // A::B::C::this_is_a_module\n-\t    //          ^^^^^^^^^^^^^^^^\n-\t    // This is an error, we are not expecting a module.\n-\t    rust_error_at (seg.get_locus (), \"expected value\");\n-\t    return new TyTy::ErrorType (expr.get_mappings ().get_hirid ());\n-\t  }\n-\n-\tTyTy::BaseType *lookup = nullptr;\n-\tif (!context->lookup_type (ref, &lookup))\n-\t  {\n-\t    if (is_root)\n-\t      {\n-\t\trust_error_at (seg.get_locus (),\n-\t\t\t       \"failed to resolve root segment\");\n-\t\treturn new TyTy::ErrorType (expr.get_mappings ().get_hirid ());\n-\t      }\n-\t    return root_tyty;\n-\t  }\n-\n-\t// if we have a previous segment type\n-\tif (root_tyty != nullptr)\n-\t  {\n-\t    // if this next segment needs substitution we must apply the\n-\t    // previous type arguments\n-\t    //\n-\t    // such as: GenericStruct::<_>::new(123, 456)\n-\t    if (lookup->needs_generic_substitutions ())\n-\t      {\n-\t\tif (!root_tyty->needs_generic_substitutions ())\n-\t\t  {\n-\t\t    auto used_args_in_prev_segment\n-\t\t      = GetUsedSubstArgs::From (root_tyty);\n-\t\t    lookup = SubstMapperInternal::Resolve (\n-\t\t      lookup, used_args_in_prev_segment);\n-\t\t  }\n-\t      }\n-\t  }\n-\n-\t// turbo-fish segment path::<ty>\n-\tif (seg.has_generic_args ())\n-\t  {\n-\t    if (!lookup->can_substitute ())\n-\t      {\n-\t\trust_error_at (seg.get_locus (),\n-\t\t\t       \"substitutions not supported for %s\",\n-\t\t\t       lookup->as_string ().c_str ());\n-\t\treturn new TyTy::ErrorType (lookup->get_ref ());\n-\t      }\n-\t    lookup = SubstMapper::Resolve (lookup, expr.get_locus (),\n-\t\t\t\t\t   &seg.get_generic_args ());\n-\t  }\n-\n-\t*root_resolved_node_id = ref_node_id;\n-\t*offset = *offset + 1;\n-\troot_tyty = lookup;\n-      }\n-\n-    return root_tyty;\n-  }\n+\t\t\t\t     NodeId *root_resolved_node_id);\n \n   void resolve_segments (NodeId root_resolved_node_id,\n \t\t\t std::vector<HIR::PathExprSegment> &segments,\n \t\t\t size_t offset, TyTy::BaseType *tyseg,\n \t\t\t const Analysis::NodeMapping &expr_mappings,\n-\t\t\t Location expr_locus)\n-  {\n-    NodeId resolved_node_id = root_resolved_node_id;\n-    TyTy::BaseType *prev_segment = tyseg;\n-    for (size_t i = offset; i < segments.size (); i++)\n-      {\n-\tHIR::PathExprSegment &seg = segments.at (i);\n-\n-\tbool reciever_is_generic\n-\t  = prev_segment->get_kind () == TyTy::TypeKind::PARAM;\n-\tbool probe_bounds = true;\n-\tbool probe_impls = !reciever_is_generic;\n-\tbool ignore_mandatory_trait_items = !reciever_is_generic;\n-\n-\t// probe the path\n-\tauto candidates\n-\t  = PathProbeType::Probe (prev_segment, seg.get_segment (), probe_impls,\n-\t\t\t\t  probe_bounds, ignore_mandatory_trait_items);\n-\tif (candidates.size () == 0)\n-\t  {\n-\t    rust_error_at (\n-\t      seg.get_locus (),\n-\t      \"failed to resolve path segment using an impl Probe\");\n-\t    return;\n-\t  }\n-\telse if (candidates.size () > 1)\n-\t  {\n-\t    ReportMultipleCandidateError::Report (candidates,\n-\t\t\t\t\t\t  seg.get_segment (),\n-\t\t\t\t\t\t  seg.get_locus ());\n-\t    return;\n-\t  }\n-\n-\tauto &candidate = candidates.at (0);\n-\tprev_segment = tyseg;\n-\ttyseg = candidate.ty;\n-\n-\tif (candidate.is_impl_candidate ())\n-\t  {\n-\t    resolved_node_id\n-\t      = candidate.item.impl.impl_item->get_impl_mappings ()\n-\t\t  .get_nodeid ();\n-\t  }\n-\telse\n-\t  {\n-\t    resolved_node_id\n-\t      = candidate.item.trait.item_ref->get_mappings ().get_nodeid ();\n-\n-\t    // lookup the associated-impl-trait\n-\t    HIR::ImplBlock *impl = candidate.item.trait.impl;\n-\t    if (impl != nullptr)\n-\t      {\n-\t\tAssociatedImplTrait *lookup_associated = nullptr;\n-\t\tbool found_impl_trait = context->lookup_associated_trait_impl (\n-\t\t  impl->get_mappings ().get_hirid (), &lookup_associated);\n-\t\trust_assert (found_impl_trait);\n-\n-\t\tlookup_associated->setup_associated_types ();\n-\n-\t\t// we need a new ty_ref_id for this trait item\n-\t\ttyseg = tyseg->clone ();\n-\t\ttyseg->set_ty_ref (mappings->get_next_hir_id ());\n-\t      }\n-\t  }\n-\n-\tif (seg.has_generic_args ())\n-\t  {\n-\t    if (!tyseg->can_substitute ())\n-\t      {\n-\t\trust_error_at (expr_locus, \"substitutions not supported for %s\",\n-\t\t\t       tyseg->as_string ().c_str ());\n-\t\treturn;\n-\t      }\n-\n-\t    tyseg = SubstMapper::Resolve (tyseg, expr_locus,\n-\t\t\t\t\t  &seg.get_generic_args ());\n-\t    if (tyseg->get_kind () == TyTy::TypeKind::ERROR)\n-\t      return;\n-\t  }\n-      }\n-\n-    context->insert_receiver (expr_mappings.get_hirid (), prev_segment);\n-    if (tyseg->needs_generic_substitutions ())\n-      {\n-\tLocation locus = segments.back ().get_locus ();\n-\tif (!prev_segment->needs_generic_substitutions ())\n-\t  {\n-\t    auto used_args_in_prev_segment\n-\t      = GetUsedSubstArgs::From (prev_segment);\n-\t    if (!used_args_in_prev_segment.is_error ())\n-\t      tyseg = SubstMapperInternal::Resolve (tyseg,\n-\t\t\t\t\t\t    used_args_in_prev_segment);\n-\t  }\n-\telse\n-\t  {\n-\t    tyseg = SubstMapper::InferSubst (tyseg, locus);\n-\t  }\n-\n-\tif (tyseg->get_kind () == TyTy::TypeKind::ERROR)\n-\t  return;\n-      }\n-\n-    rust_assert (resolved_node_id != UNKNOWN_NODEID);\n-\n-    // lookup if the name resolver was able to canonically resolve this or not\n-    NodeId path_resolved_id = UNKNOWN_NODEID;\n-    if (resolver->lookup_resolved_name (expr_mappings.get_nodeid (),\n-\t\t\t\t\t&path_resolved_id))\n-      {\n-\trust_assert (path_resolved_id == resolved_node_id);\n-      }\n-    // check the type scope\n-    else if (resolver->lookup_resolved_type (expr_mappings.get_nodeid (),\n-\t\t\t\t\t     &path_resolved_id))\n-      {\n-\trust_assert (path_resolved_id == resolved_node_id);\n-      }\n-    else\n-      {\n-\tresolver->insert_resolved_name (expr_mappings.get_nodeid (),\n-\t\t\t\t\tresolved_node_id);\n-      }\n-\n-    infered = tyseg;\n-  }\n+\t\t\t Location expr_locus);\n \n   bool\n   validate_arithmetic_type (TyTy::BaseType *type,\n@@ -1569,7 +1145,7 @@ class TypeCheckExpr : public TypeCheckBase\n   Location root_array_expr_locus;\n \n   bool inside_loop;\n-}; // namespace Resolver\n+};\n \n } // namespace Resolver\n } // namespace Rust"}, {"sha": "657c45c0ffebd12240e316bb740b998d6a87e5c2", "filename": "gcc/rust/typecheck/rust-hir-type-check-path.cc", "status": "added", "additions": 461, "deletions": 0, "changes": 461, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95ad46b905b6e49c6888f2923347d0b85c466b96/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-path.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95ad46b905b6e49c6888f2923347d0b85c466b96/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-path.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-path.cc?ref=95ad46b905b6e49c6888f2923347d0b85c466b96", "patch": "@@ -0,0 +1,461 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-hir-type-check-expr.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+void\n+TypeCheckExpr::visit (HIR::QualifiedPathInExpression &expr)\n+{\n+  HIR::QualifiedPathType qual_path_type = expr.get_path_type ();\n+  TyTy::BaseType *root\n+    = TypeCheckType::Resolve (qual_path_type.get_type ().get ());\n+  if (root->get_kind () == TyTy::TypeKind::ERROR)\n+    return;\n+\n+  if (!qual_path_type.has_as_clause ())\n+    {\n+      // then this is just a normal path-in-expression\n+      NodeId root_resolved_node_id = UNKNOWN_NODEID;\n+      bool ok = resolver->lookup_resolved_type (\n+\tqual_path_type.get_type ()->get_mappings ().get_nodeid (),\n+\t&root_resolved_node_id);\n+      rust_assert (ok);\n+\n+      resolve_segments (root_resolved_node_id, expr.get_segments (), 0, root,\n+\t\t\texpr.get_mappings (), expr.get_locus ());\n+    }\n+\n+  // Resolve the trait now\n+  TraitReference *trait_ref\n+    = TraitResolver::Resolve (*qual_path_type.get_trait ().get ());\n+  if (trait_ref->is_error ())\n+    return;\n+\n+  // does this type actually implement this type-bound?\n+  if (!TypeBoundsProbe::is_bound_satisfied_for_type (root, trait_ref))\n+    return;\n+\n+  // then we need to look at the next segment to create perform the correct\n+  // projection type\n+  if (expr.get_segments ().empty ())\n+    return;\n+\n+  // we need resolve to the impl block\n+  NodeId impl_resolved_id = UNKNOWN_NODEID;\n+  bool ok = resolver->lookup_resolved_name (\n+    qual_path_type.get_mappings ().get_nodeid (), &impl_resolved_id);\n+  rust_assert (ok);\n+\n+  HirId impl_block_id;\n+  ok = mappings->lookup_node_to_hir (expr.get_mappings ().get_crate_num (),\n+\t\t\t\t     impl_resolved_id, &impl_block_id);\n+  rust_assert (ok);\n+\n+  AssociatedImplTrait *lookup_associated = nullptr;\n+  bool found_impl_trait\n+    = context->lookup_associated_trait_impl (impl_block_id, &lookup_associated);\n+  rust_assert (found_impl_trait);\n+\n+  DefId resolved_item_id = UNKNOWN_DEFID;\n+  HIR::PathExprSegment &item_seg = expr.get_segments ().at (0);\n+\n+  const TraitItemReference *trait_item_ref = nullptr;\n+  ok = trait_ref->lookup_trait_item (item_seg.get_segment ().as_string (),\n+\t\t\t\t     &trait_item_ref);\n+  if (!ok)\n+    {\n+      rust_error_at (item_seg.get_locus (), \"unknown associated item\");\n+      return;\n+    }\n+  resolved_item_id = trait_item_ref->get_mappings ().get_defid ();\n+\n+  infered = lookup_associated->get_projected_type (\n+    trait_item_ref, root, item_seg.get_mappings ().get_hirid (),\n+    item_seg.get_locus ());\n+\n+  // turbo-fish segment path::<ty>\n+  if (item_seg.has_generic_args ())\n+    {\n+      if (!infered->can_substitute ())\n+\t{\n+\t  rust_error_at (item_seg.get_locus (),\n+\t\t\t \"substitutions not supported for %s\",\n+\t\t\t infered->as_string ().c_str ());\n+\t  infered = new TyTy::ErrorType (expr.get_mappings ().get_hirid ());\n+\t  return;\n+\t}\n+      infered = SubstMapper::Resolve (infered, expr.get_locus (),\n+\t\t\t\t      &item_seg.get_generic_args ());\n+    }\n+\n+  TyTy::ProjectionType *projection\n+    = new TyTy::ProjectionType (qual_path_type.get_mappings ().get_hirid (),\n+\t\t\t\tTyTy::TyVar (root->get_ref ()), trait_ref,\n+\t\t\t\tresolved_item_id, lookup_associated);\n+  context->insert_type (qual_path_type.get_mappings (), projection);\n+\n+  // continue on as a path-in-expression\n+  NodeId root_resolved_node_id = trait_item_ref->get_mappings ().get_nodeid ();\n+  bool fully_resolved = expr.get_segments ().size () <= 1;\n+\n+  if (fully_resolved)\n+    {\n+      // lookup if the name resolver was able to canonically resolve this or\n+      // not\n+      NodeId path_resolved_id = UNKNOWN_NODEID;\n+      if (resolver->lookup_resolved_name (expr.get_mappings ().get_nodeid (),\n+\t\t\t\t\t  &path_resolved_id))\n+\t{\n+\t  rust_assert (path_resolved_id == root_resolved_node_id);\n+\t}\n+      // check the type scope\n+      else if (resolver->lookup_resolved_type (\n+\t\t expr.get_mappings ().get_nodeid (), &path_resolved_id))\n+\t{\n+\t  rust_assert (path_resolved_id == root_resolved_node_id);\n+\t}\n+      else\n+\t{\n+\t  resolver->insert_resolved_name (expr.get_mappings ().get_nodeid (),\n+\t\t\t\t\t  root_resolved_node_id);\n+\t}\n+\n+      context->insert_receiver (expr.get_mappings ().get_hirid (), root);\n+      return;\n+    }\n+\n+  resolve_segments (root_resolved_node_id, expr.get_segments (), 1, infered,\n+\t\t    expr.get_mappings (), expr.get_locus ());\n+}\n+\n+void\n+TypeCheckExpr::visit (HIR::PathInExpression &expr)\n+{\n+  NodeId resolved_node_id = UNKNOWN_NODEID;\n+\n+  size_t offset = -1;\n+  TyTy::BaseType *tyseg = resolve_root_path (expr, &offset, &resolved_node_id);\n+\n+  if (tyseg == nullptr)\n+    {\n+      rust_debug_loc (expr.get_locus (), \"failed to resolve root_seg\");\n+    }\n+  rust_assert (tyseg != nullptr);\n+\n+  if (tyseg->get_kind () == TyTy::TypeKind::ERROR)\n+    return;\n+\n+  if (expr.get_num_segments () == 1)\n+    {\n+      Location locus = expr.get_segments ().back ().get_locus ();\n+\n+      bool is_big_self\n+\t= expr.get_segments ().front ().get_segment ().as_string ().compare (\n+\t    \"Self\")\n+\t  == 0;\n+      if (!is_big_self && tyseg->needs_generic_substitutions ())\n+\t{\n+\t  tyseg = SubstMapper::InferSubst (tyseg, locus);\n+\t}\n+\n+      infered = tyseg;\n+      return;\n+    }\n+\n+  resolve_segments (resolved_node_id, expr.get_segments (), offset, tyseg,\n+\t\t    expr.get_mappings (), expr.get_locus ());\n+}\n+\n+TyTy::BaseType *\n+TypeCheckExpr::resolve_root_path (HIR::PathInExpression &expr, size_t *offset,\n+\t\t\t\t  NodeId *root_resolved_node_id)\n+{\n+  TyTy::BaseType *root_tyty = nullptr;\n+  *offset = 0;\n+  for (size_t i = 0; i < expr.get_num_segments (); i++)\n+    {\n+      HIR::PathExprSegment &seg = expr.get_segments ().at (i);\n+\n+      bool have_more_segments = (expr.get_num_segments () - 1 != i);\n+      bool is_root = *offset == 0;\n+      NodeId ast_node_id = seg.get_mappings ().get_nodeid ();\n+\n+      // then lookup the reference_node_id\n+      NodeId ref_node_id = UNKNOWN_NODEID;\n+      if (resolver->lookup_resolved_name (ast_node_id, &ref_node_id))\n+\t{\n+\t  // these ref_node_ids will resolve to a pattern declaration but we\n+\t  // are interested in the definition that this refers to get the\n+\t  // parent id\n+\t  Definition def;\n+\t  if (!resolver->lookup_definition (ref_node_id, &def))\n+\t    {\n+\t      rust_error_at (expr.get_locus (),\n+\t\t\t     \"unknown reference for resolved name\");\n+\t      return new TyTy::ErrorType (expr.get_mappings ().get_hirid ());\n+\t    }\n+\t  ref_node_id = def.parent;\n+\t}\n+      else\n+\t{\n+\t  resolver->lookup_resolved_type (ast_node_id, &ref_node_id);\n+\t}\n+\n+      // ref_node_id is the NodeId that the segments refers to.\n+      if (ref_node_id == UNKNOWN_NODEID)\n+\t{\n+\t  if (is_root)\n+\t    {\n+\t      rust_error_at (seg.get_locus (),\n+\t\t\t     \"failed to type resolve root segment\");\n+\t      return new TyTy::ErrorType (expr.get_mappings ().get_hirid ());\n+\t    }\n+\t  return root_tyty;\n+\t}\n+\n+      // node back to HIR\n+      HirId ref;\n+      if (!mappings->lookup_node_to_hir (expr.get_mappings ().get_crate_num (),\n+\t\t\t\t\t ref_node_id, &ref))\n+\t{\n+\t  if (is_root)\n+\t    {\n+\t      rust_error_at (seg.get_locus (), \"456 reverse lookup failure\");\n+\t      rust_debug_loc (\n+\t\tseg.get_locus (),\n+\t\t\"failure with [%s] mappings [%s] ref_node_id [%u]\",\n+\t\tseg.as_string ().c_str (),\n+\t\tseg.get_mappings ().as_string ().c_str (), ref_node_id);\n+\n+\t      return new TyTy::ErrorType (expr.get_mappings ().get_hirid ());\n+\t    }\n+\n+\t  return root_tyty;\n+\t}\n+\n+      auto seg_is_module\n+\t= (nullptr\n+\t   != mappings->lookup_module (expr.get_mappings ().get_crate_num (),\n+\t\t\t\t       ref));\n+\n+      if (seg_is_module)\n+\t{\n+\t  // A::B::C::this_is_a_module::D::E::F\n+\t  //          ^^^^^^^^^^^^^^^^\n+\t  //          Currently handling this.\n+\t  if (have_more_segments)\n+\t    {\n+\t      (*offset)++;\n+\t      continue;\n+\t    }\n+\n+\t  // In the case of :\n+\t  // A::B::C::this_is_a_module\n+\t  //          ^^^^^^^^^^^^^^^^\n+\t  // This is an error, we are not expecting a module.\n+\t  rust_error_at (seg.get_locus (), \"expected value\");\n+\t  return new TyTy::ErrorType (expr.get_mappings ().get_hirid ());\n+\t}\n+\n+      TyTy::BaseType *lookup = nullptr;\n+      if (!context->lookup_type (ref, &lookup))\n+\t{\n+\t  if (is_root)\n+\t    {\n+\t      rust_error_at (seg.get_locus (),\n+\t\t\t     \"failed to resolve root segment\");\n+\t      return new TyTy::ErrorType (expr.get_mappings ().get_hirid ());\n+\t    }\n+\t  return root_tyty;\n+\t}\n+\n+      // if we have a previous segment type\n+      if (root_tyty != nullptr)\n+\t{\n+\t  // if this next segment needs substitution we must apply the\n+\t  // previous type arguments\n+\t  //\n+\t  // such as: GenericStruct::<_>::new(123, 456)\n+\t  if (lookup->needs_generic_substitutions ())\n+\t    {\n+\t      if (!root_tyty->needs_generic_substitutions ())\n+\t\t{\n+\t\t  auto used_args_in_prev_segment\n+\t\t    = GetUsedSubstArgs::From (root_tyty);\n+\t\t  lookup\n+\t\t    = SubstMapperInternal::Resolve (lookup,\n+\t\t\t\t\t\t    used_args_in_prev_segment);\n+\t\t}\n+\t    }\n+\t}\n+\n+      // turbo-fish segment path::<ty>\n+      if (seg.has_generic_args ())\n+\t{\n+\t  if (!lookup->can_substitute ())\n+\t    {\n+\t      rust_error_at (seg.get_locus (),\n+\t\t\t     \"substitutions not supported for %s\",\n+\t\t\t     lookup->as_string ().c_str ());\n+\t      return new TyTy::ErrorType (lookup->get_ref ());\n+\t    }\n+\t  lookup = SubstMapper::Resolve (lookup, expr.get_locus (),\n+\t\t\t\t\t &seg.get_generic_args ());\n+\t}\n+\n+      *root_resolved_node_id = ref_node_id;\n+      *offset = *offset + 1;\n+      root_tyty = lookup;\n+    }\n+\n+  return root_tyty;\n+}\n+\n+void\n+TypeCheckExpr::resolve_segments (NodeId root_resolved_node_id,\n+\t\t\t\t std::vector<HIR::PathExprSegment> &segments,\n+\t\t\t\t size_t offset, TyTy::BaseType *tyseg,\n+\t\t\t\t const Analysis::NodeMapping &expr_mappings,\n+\t\t\t\t Location expr_locus)\n+{\n+  NodeId resolved_node_id = root_resolved_node_id;\n+  TyTy::BaseType *prev_segment = tyseg;\n+  for (size_t i = offset; i < segments.size (); i++)\n+    {\n+      HIR::PathExprSegment &seg = segments.at (i);\n+\n+      bool reciever_is_generic\n+\t= prev_segment->get_kind () == TyTy::TypeKind::PARAM;\n+      bool probe_bounds = true;\n+      bool probe_impls = !reciever_is_generic;\n+      bool ignore_mandatory_trait_items = !reciever_is_generic;\n+\n+      // probe the path\n+      auto candidates\n+\t= PathProbeType::Probe (prev_segment, seg.get_segment (), probe_impls,\n+\t\t\t\tprobe_bounds, ignore_mandatory_trait_items);\n+      if (candidates.size () == 0)\n+\t{\n+\t  rust_error_at (seg.get_locus (),\n+\t\t\t \"failed to resolve path segment using an impl Probe\");\n+\t  return;\n+\t}\n+      else if (candidates.size () > 1)\n+\t{\n+\t  ReportMultipleCandidateError::Report (candidates, seg.get_segment (),\n+\t\t\t\t\t\tseg.get_locus ());\n+\t  return;\n+\t}\n+\n+      auto &candidate = candidates.at (0);\n+      prev_segment = tyseg;\n+      tyseg = candidate.ty;\n+\n+      if (candidate.is_impl_candidate ())\n+\t{\n+\t  resolved_node_id\n+\t    = candidate.item.impl.impl_item->get_impl_mappings ().get_nodeid ();\n+\t}\n+      else\n+\t{\n+\t  resolved_node_id\n+\t    = candidate.item.trait.item_ref->get_mappings ().get_nodeid ();\n+\n+\t  // lookup the associated-impl-trait\n+\t  HIR::ImplBlock *impl = candidate.item.trait.impl;\n+\t  if (impl != nullptr)\n+\t    {\n+\t      AssociatedImplTrait *lookup_associated = nullptr;\n+\t      bool found_impl_trait = context->lookup_associated_trait_impl (\n+\t\timpl->get_mappings ().get_hirid (), &lookup_associated);\n+\t      rust_assert (found_impl_trait);\n+\n+\t      lookup_associated->setup_associated_types ();\n+\n+\t      // we need a new ty_ref_id for this trait item\n+\t      tyseg = tyseg->clone ();\n+\t      tyseg->set_ty_ref (mappings->get_next_hir_id ());\n+\t    }\n+\t}\n+\n+      if (seg.has_generic_args ())\n+\t{\n+\t  if (!tyseg->can_substitute ())\n+\t    {\n+\t      rust_error_at (expr_locus, \"substitutions not supported for %s\",\n+\t\t\t     tyseg->as_string ().c_str ());\n+\t      return;\n+\t    }\n+\n+\t  tyseg = SubstMapper::Resolve (tyseg, expr_locus,\n+\t\t\t\t\t&seg.get_generic_args ());\n+\t  if (tyseg->get_kind () == TyTy::TypeKind::ERROR)\n+\t    return;\n+\t}\n+    }\n+\n+  context->insert_receiver (expr_mappings.get_hirid (), prev_segment);\n+  if (tyseg->needs_generic_substitutions ())\n+    {\n+      Location locus = segments.back ().get_locus ();\n+      if (!prev_segment->needs_generic_substitutions ())\n+\t{\n+\t  auto used_args_in_prev_segment\n+\t    = GetUsedSubstArgs::From (prev_segment);\n+\t  if (!used_args_in_prev_segment.is_error ())\n+\t    tyseg\n+\t      = SubstMapperInternal::Resolve (tyseg, used_args_in_prev_segment);\n+\t}\n+      else\n+\t{\n+\t  tyseg = SubstMapper::InferSubst (tyseg, locus);\n+\t}\n+\n+      if (tyseg->get_kind () == TyTy::TypeKind::ERROR)\n+\treturn;\n+    }\n+\n+  rust_assert (resolved_node_id != UNKNOWN_NODEID);\n+\n+  // lookup if the name resolver was able to canonically resolve this or not\n+  NodeId path_resolved_id = UNKNOWN_NODEID;\n+  if (resolver->lookup_resolved_name (expr_mappings.get_nodeid (),\n+\t\t\t\t      &path_resolved_id))\n+    {\n+      rust_assert (path_resolved_id == resolved_node_id);\n+    }\n+  // check the type scope\n+  else if (resolver->lookup_resolved_type (expr_mappings.get_nodeid (),\n+\t\t\t\t\t   &path_resolved_id))\n+    {\n+      rust_assert (path_resolved_id == resolved_node_id);\n+    }\n+  else\n+    {\n+      resolver->insert_resolved_name (expr_mappings.get_nodeid (),\n+\t\t\t\t      resolved_node_id);\n+    }\n+\n+  infered = tyseg;\n+}\n+\n+} // namespace Resolver\n+} // namespace Rust"}]}