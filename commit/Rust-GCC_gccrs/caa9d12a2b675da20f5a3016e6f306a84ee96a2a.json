{"sha": "caa9d12a2b675da20f5a3016e6f306a84ee96a2a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2FhOWQxMmEyYjY3NWRhMjBmNWEzMDE2ZTZmMzA2YTg0ZWU5NmEyYQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2009-04-24T08:04:38Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2009-04-24T08:04:38Z"}, "message": "ttypes.ads (Target_Double_Float_Alignment): New variable.\n\n\t* ttypes.ads (Target_Double_Float_Alignment): New variable.\n\t(Target_Double_Scalar_Alignment): Likewise.\n\t* get_targ.ads (Get_Strict_Alignment): Adjust external name.\n\t(Get_Double_Float_Alignment): New imported function.\n\t(Get_Double_Scalar_Alignment): Likewise.\n\t* layout.adb (Set_Elem_Alignment): Take into account specific caps for\n\tthe alignment of \"double\" floating-point types and \"double\" or larger\n\tscalar types, as parameterized by Target_Double_Float_Alignment and\n\tTarget_Double_Scalar_Alignment respectively.\n\t* gcc-interface/gigi.h (double_float_alignment): Declare.\n\t(double_scalar_alignment): Likewise.\n\t(is_double_float_or_array): Likewise.\n\t(is_double_scalar_or_array): Likewise.\n\t(get_target_double_float_alignment): Likewise.\n\t(get_target_double_scalar_alignment): Likewise.\n\t* gcc-interface/targtyps.c (get_strict_alignment): Rename into...\n\t(get_target_strict_alignment): ...this.\n\t(get_target_double_float_alignment): New function.\n\t(get_target_double_scalar_alignment): Likewise.\n\t* gcc-interface/decl.c (gnat_to_gnu_entity) <E_Signed_Integer_Subtype>:\n\tTest the presence of an alignment clause for under-aligned integer\n\ttypes.  Take into account specific caps for the alignment of \"double\"\n\tfloating-point types and \"double\" or larger scalar types, as\n\tparameterized by Target_Double_Float_Alignment and\n\tTarget_Double_Scalar_Alignment respectively.\n\t(validate_alignment): Likewise.\n\t* gcc-interface/trans.c (Attribute_to_gnu) <Attr_Alignment>: Likewise.\n\t(gigi): Initialize double_float_alignment and double_scalar_alignment.\n\t* gcc-interface/utils.c (double_float_alignment): New global variable.\n\t(double_scalar_alignment): Likewise.\n\t(is_double_float_or_array): New predicate.\n\t(is_double_scalar_or_array): Likewise.\n\nFrom-SVN: r146675", "tree": {"sha": "4ef92f0ee83700140ec99de85778563e3dbe29e6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4ef92f0ee83700140ec99de85778563e3dbe29e6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/caa9d12a2b675da20f5a3016e6f306a84ee96a2a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/caa9d12a2b675da20f5a3016e6f306a84ee96a2a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/caa9d12a2b675da20f5a3016e6f306a84ee96a2a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/caa9d12a2b675da20f5a3016e6f306a84ee96a2a/comments", "author": null, "committer": null, "parents": [{"sha": "1275de7d6eb0240c3dc56206aa68bac7a6c2318b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1275de7d6eb0240c3dc56206aa68bac7a6c2318b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1275de7d6eb0240c3dc56206aa68bac7a6c2318b"}], "stats": {"total": 413, "additions": 374, "deletions": 39}, "files": [{"sha": "298c554a329f2d16c620a3626b2b96bb8ebdd7f6", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/caa9d12a2b675da20f5a3016e6f306a84ee96a2a/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/caa9d12a2b675da20f5a3016e6f306a84ee96a2a/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=caa9d12a2b675da20f5a3016e6f306a84ee96a2a", "patch": "@@ -1,3 +1,38 @@\n+2009-04-24  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* ttypes.ads (Target_Double_Float_Alignment): New variable.\n+\t(Target_Double_Scalar_Alignment): Likewise.\n+\t* get_targ.ads (Get_Strict_Alignment): Adjust external name.\n+\t(Get_Double_Float_Alignment): New imported function.\n+\t(Get_Double_Scalar_Alignment): Likewise.\n+\t* layout.adb (Set_Elem_Alignment): Take into account specific caps for\n+\tthe alignment of \"double\" floating-point types and \"double\" or larger\n+\tscalar types, as parameterized by Target_Double_Float_Alignment and\n+\tTarget_Double_Scalar_Alignment respectively.\n+\t* gcc-interface/gigi.h (double_float_alignment): Declare.\n+\t(double_scalar_alignment): Likewise.\n+\t(is_double_float_or_array): Likewise.\n+\t(is_double_scalar_or_array): Likewise.\n+\t(get_target_double_float_alignment): Likewise.\n+\t(get_target_double_scalar_alignment): Likewise.\n+\t* gcc-interface/targtyps.c (get_strict_alignment): Rename into...\n+\t(get_target_strict_alignment): ...this.\n+\t(get_target_double_float_alignment): New function.\n+\t(get_target_double_scalar_alignment): Likewise.\n+\t* gcc-interface/decl.c (gnat_to_gnu_entity) <E_Signed_Integer_Subtype>:\n+\tTest the presence of an alignment clause for under-aligned integer\n+\ttypes.  Take into account specific caps for the alignment of \"double\"\n+\tfloating-point types and \"double\" or larger scalar types, as\n+\tparameterized by Target_Double_Float_Alignment and\n+\tTarget_Double_Scalar_Alignment respectively.\n+\t(validate_alignment): Likewise.\n+\t* gcc-interface/trans.c (Attribute_to_gnu) <Attr_Alignment>: Likewise.\n+\t(gigi): Initialize double_float_alignment and double_scalar_alignment.\n+\t* gcc-interface/utils.c (double_float_alignment): New global variable.\n+\t(double_scalar_alignment): Likewise.\n+\t(is_double_float_or_array): New predicate.\n+\t(is_double_scalar_or_array): Likewise.\n+\n 2009-04-24  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc-interface/utils2.c (build_cond_expr): Move SAVE_EXPR ahead of"}, {"sha": "3575aa55b9dcfb52413c691ec0db3948fb0477fd", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 65, "deletions": 6, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/caa9d12a2b675da20f5a3016e6f306a84ee96a2a/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/caa9d12a2b675da20f5a3016e6f306a84ee96a2a/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=caa9d12a2b675da20f5a3016e6f306a84ee96a2a", "patch": "@@ -1662,7 +1662,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n       /* If the type we are dealing with has got a smaller alignment than the\n \t natural one, we need to wrap it up in a record type and under-align\n \t the latter.  We reuse the padding machinery for this purpose.  */\n-      else if (Known_Alignment (gnat_entity)\n+      else if (Present (Alignment_Clause (gnat_entity))\n \t       && UI_Is_In_Int_Range (Alignment (gnat_entity))\n \t       && (align = UI_To_Int (Alignment (gnat_entity)) * BITS_PER_UNIT)\n \t       && align < TYPE_ALIGN (gnu_type))\n@@ -4661,8 +4661,29 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n       /* Back-annotate the Alignment of the type if not already in the\n \t tree.  Likewise for sizes.  */\n       if (Unknown_Alignment (gnat_entity))\n-\tSet_Alignment (gnat_entity,\n-\t\t       UI_From_Int (TYPE_ALIGN (gnu_type) / BITS_PER_UNIT));\n+\t{\n+\t  unsigned int double_align, align;\n+\t  bool is_capped_double, align_clause;\n+\n+\t  /* If the default alignment of \"double\" or larger scalar types is\n+\t     specifically capped and this is not an array with an alignment\n+\t     clause on the component type, return the cap.  */\n+\t  if ((double_align = double_float_alignment) > 0)\n+\t    is_capped_double\n+\t      = is_double_float_or_array (gnat_entity, &align_clause);\n+\t  else if ((double_align = double_scalar_alignment) > 0)\n+\t    is_capped_double\n+\t      = is_double_scalar_or_array (gnat_entity, &align_clause);\n+\t  else\n+\t    is_capped_double = align_clause = false;\n+\n+\t  if (is_capped_double && !align_clause)\n+\t    align = double_align;\n+\t  else\n+\t    align = TYPE_ALIGN (gnu_type) / BITS_PER_UNIT;\n+\n+\t  Set_Alignment (gnat_entity, UI_From_Int (align));\n+\t}\n \n       if (Unknown_Esize (gnat_entity) && TYPE_SIZE (gnu_type))\n \t{\n@@ -7507,9 +7528,47 @@ validate_alignment (Uint alignment, Entity_Id gnat_entity, unsigned int align)\n   else if (!(Present (Alignment_Clause (gnat_entity))\n \t     && From_At_Mod (Alignment_Clause (gnat_entity)))\n \t   && new_align * BITS_PER_UNIT < align)\n-    post_error_ne_num (\"alignment for& must be at least ^\",\n-\t\t       gnat_error_node, gnat_entity,\n-\t\t       align / BITS_PER_UNIT);\n+    {\n+      unsigned int double_align;\n+      bool is_capped_double, align_clause;\n+\n+      /* If the default alignment of \"double\" or larger scalar types is\n+\t specifically capped and the new alignment is above the cap, do\n+\t not post an error and change the alignment only if there is an\n+\t alignment clause; this makes it possible to have the associated\n+\t GCC type overaligned by default for performance reasons.  */\n+      if ((double_align = double_float_alignment) > 0)\n+\t{\n+\t  Entity_Id gnat_type\n+\t    = Is_Type (gnat_entity) ? gnat_entity : Etype (gnat_entity);\n+\t  is_capped_double\n+\t    = is_double_float_or_array (gnat_type, &align_clause);\n+\t}\n+      else if ((double_align = double_scalar_alignment) > 0)\n+\t{\n+\t  Entity_Id gnat_type\n+\t    = Is_Type (gnat_entity) ? gnat_entity : Etype (gnat_entity);\n+\t  is_capped_double\n+\t    = is_double_scalar_or_array (gnat_type, &align_clause);\n+\t}\n+      else\n+\tis_capped_double = align_clause = false;\n+\n+      if (is_capped_double && new_align >= double_align)\n+\t{\n+\t  if (align_clause)\n+\t    align = new_align * BITS_PER_UNIT;\n+\t}\n+      else\n+\t{\n+\t  if (is_capped_double)\n+\t    align = double_align * BITS_PER_UNIT;\n+\n+\t  post_error_ne_num (\"alignment for& must be at least ^\",\n+\t\t\t     gnat_error_node, gnat_entity,\n+\t\t\t     align / BITS_PER_UNIT);\n+\t}\n+    }\n   else\n     {\n       new_align = (new_align > 0 ? new_align * BITS_PER_UNIT : 1);"}, {"sha": "8ccb39c4b0aba06a0fd6e0ea1a55b73ce8177fd4", "filename": "gcc/ada/gcc-interface/gigi.h", "status": "modified", "additions": 29, "deletions": 4, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/caa9d12a2b675da20f5a3016e6f306a84ee96a2a/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/caa9d12a2b675da20f5a3016e6f306a84ee96a2a/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fgigi.h?ref=caa9d12a2b675da20f5a3016e6f306a84ee96a2a", "patch": "@@ -268,6 +268,16 @@ extern int max_gnat_nodes;\n /* If nonzero, pretend we are allocating at global level.  */\n extern int force_global;\n \n+/* The default alignment of \"double\" floating-point types, i.e. floating\n+   point types whose size is equal to 64 bits, or 0 if this alignment is\n+   not specifically capped.  */\n+extern int double_float_alignment;\n+\n+/* The default alignment of \"double\" or larger scalar types, i.e. scalar\n+   types whose size is greater or equal to 64 bits, or 0 if this alignment\n+   is not specifically capped.  */\n+extern int double_scalar_alignment;\n+\n /* Standard data type sizes.  Most of these are not used.  */\n \n #ifndef CHAR_TYPE_SIZE\n@@ -730,6 +740,20 @@ extern tree unchecked_convert (tree type, tree expr, bool notrunc_p);\n    the latter being a record type as predicated by Is_Record_Type.  */\n extern enum tree_code tree_code_for_record_type (Entity_Id gnat_type);\n \n+/* Return true if GNAT_TYPE is a \"double\" floating-point type, i.e. whose\n+   size is equal to 64 bits, or an array of such a type.  Set ALIGN_CLAUSE\n+   according to the presence of an alignment clause on the type or, if it\n+   is an array, on the component type.  */\n+extern bool is_double_float_or_array (Entity_Id gnat_type,\n+\t\t\t\t      bool *align_clause);\n+\n+/* Return true if GNAT_TYPE is a \"double\" or larger scalar type, i.e. whose\n+   size is greater or equal to 64 bits, or an array of such a type.  Set\n+   ALIGN_CLAUSE according to the presence of an alignment clause on the\n+   type or, if it is an array, on the component type.  */\n+extern bool is_double_scalar_or_array (Entity_Id gnat_type,\n+\t\t\t\t       bool *align_clause);\n+\n /* Return true if GNU_TYPE is suitable as the type of a non-aliased\n    component of an aggregate type.  */\n extern bool type_for_nonaliased_component_p (tree gnu_type);\n@@ -899,15 +923,17 @@ extern Pos get_target_float_size (void);\n extern Pos get_target_double_size (void);\n extern Pos get_target_long_double_size (void);\n extern Pos get_target_pointer_size (void);\n-extern Pos get_target_maximum_alignment (void);\n-extern Pos get_target_default_allocator_alignment (void);\n extern Pos get_target_maximum_default_alignment (void);\n+extern Pos get_target_default_allocator_alignment (void);\n extern Pos get_target_maximum_allowed_alignment (void);\n+extern Pos get_target_maximum_alignment (void);\n extern Nat get_float_words_be (void);\n extern Nat get_words_be (void);\n extern Nat get_bytes_be (void);\n extern Nat get_bits_be (void);\n-extern Nat get_strict_alignment (void);\n+extern Nat get_target_strict_alignment (void);\n+extern Nat get_target_double_float_alignment (void);\n+extern Nat get_target_double_scalar_alignment (void);\n \n /* Let code know whether we are targetting VMS without need of\n    intrusive preprocessor directives.  */\n@@ -921,4 +947,3 @@ extern Nat get_strict_alignment (void);\n #ifndef TARGET_MALLOC64\n #define TARGET_MALLOC64 0\n #endif\n-"}, {"sha": "3b8aa5cc9f51fdcbbc3f6c11eddac7ae40170b81", "filename": "gcc/ada/gcc-interface/targtyps.c", "status": "modified", "additions": 24, "deletions": 2, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/caa9d12a2b675da20f5a3016e6f306a84ee96a2a/gcc%2Fada%2Fgcc-interface%2Ftargtyps.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/caa9d12a2b675da20f5a3016e6f306a84ee96a2a/gcc%2Fada%2Fgcc-interface%2Ftargtyps.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftargtyps.c?ref=caa9d12a2b675da20f5a3016e6f306a84ee96a2a", "patch": "@@ -127,7 +127,6 @@ get_target_long_double_size (void)\n   return fp_prec_to_size (WIDEST_HARDWARE_FP_SIZE);\n }\n \n-\n Pos\n get_target_pointer_size (void)\n {\n@@ -217,7 +216,30 @@ get_bits_be (void)\n }\n \n Nat\n-get_strict_alignment (void)\n+get_target_strict_alignment (void)\n {\n   return STRICT_ALIGNMENT;\n }\n+\n+Nat\n+get_target_double_float_alignment (void)\n+{\n+#ifdef TARGET_ALIGN_NATURAL\n+  /* This macro is only defined by the rs6000 port.  */\n+  if (!TARGET_ALIGN_NATURAL\n+      && (DEFAULT_ABI == ABI_AIX || DEFAULT_ABI == ABI_DARWIN))\n+    return 32 / BITS_PER_UNIT;\n+#endif\n+  return 0;\n+}\n+\n+Nat\n+get_target_double_scalar_alignment (void)\n+{\n+#ifdef TARGET_ALIGN_DOUBLE\n+  /* This macro is only defined by the i386 port.  */\n+  if (!TARGET_ALIGN_DOUBLE && !TARGET_64BIT)\n+    return 32 / BITS_PER_UNIT;\n+#endif\n+  return 0;\n+}"}, {"sha": "d6aa7dfa1233bf629ba02654aa30e0b91c024cc7", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 51, "deletions": 15, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/caa9d12a2b675da20f5a3016e6f306a84ee96a2a/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/caa9d12a2b675da20f5a3016e6f306a84ee96a2a/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=caa9d12a2b675da20f5a3016e6f306a84ee96a2a", "patch": "@@ -317,6 +317,10 @@ gigi (Node_Id gnat_root, int max_gnat_node, int number_name,\n   if (!Stack_Check_Probes_On_Target)\n     set_stack_check_libfunc (gen_rtx_SYMBOL_REF (Pmode, \"_gnat_stack_check\"));\n \n+  /* Retrieve alignment settings.  */\n+  double_float_alignment = get_target_double_float_alignment ();\n+  double_scalar_alignment = get_target_double_scalar_alignment ();\n+\n   /* Record the builtin types.  Define `integer' and `unsigned char' first so\n      that dbx will output them first.  */\n   record_builtin_type (\"integer\", integer_type_node);\n@@ -1066,12 +1070,10 @@ Pragma_to_gnu (Node_Id gnat_node)\n static tree\n Attribute_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, int attribute)\n {\n-  tree gnu_result = error_mark_node;\n-  tree gnu_result_type;\n-  tree gnu_expr;\n-  bool prefix_unused = false;\n   tree gnu_prefix = gnat_to_gnu (Prefix (gnat_node));\n   tree gnu_type = TREE_TYPE (gnu_prefix);\n+  tree gnu_expr, gnu_result_type, gnu_result = error_mark_node;\n+  bool prefix_unused = false;\n \n   /* If the input is a NULL_EXPR, make a new one.  */\n   if (TREE_CODE (gnu_prefix) == NULL_EXPR)\n@@ -1375,19 +1377,53 @@ Attribute_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, int attribute)\n       break;\n \n     case Attr_Alignment:\n-      if (TREE_CODE (gnu_prefix) == COMPONENT_REF\n-\t  && (TREE_CODE (TREE_TYPE (TREE_OPERAND (gnu_prefix, 0)))\n-\t      == RECORD_TYPE)\n-\t  && (TYPE_IS_PADDING_P (TREE_TYPE (TREE_OPERAND (gnu_prefix, 0)))))\n-\tgnu_prefix = TREE_OPERAND (gnu_prefix, 0);\n+      {\n+\tunsigned int align;\n \n-      gnu_type = TREE_TYPE (gnu_prefix);\n-      gnu_result_type = get_unpadded_type (Etype (gnat_node));\n-      prefix_unused = true;\n+\tif (TREE_CODE (gnu_prefix) == COMPONENT_REF\n+\t    && (TREE_CODE (TREE_TYPE (TREE_OPERAND (gnu_prefix, 0)))\n+\t\t== RECORD_TYPE)\n+\t    && (TYPE_IS_PADDING_P (TREE_TYPE (TREE_OPERAND (gnu_prefix, 0)))))\n+\t  gnu_prefix = TREE_OPERAND (gnu_prefix, 0);\n \n-      gnu_result = size_int ((TREE_CODE (gnu_prefix) == COMPONENT_REF\n-\t\t\t      ? DECL_ALIGN (TREE_OPERAND (gnu_prefix, 1))\n-\t\t\t      : TYPE_ALIGN (gnu_type)) / BITS_PER_UNIT);\n+\tgnu_type = TREE_TYPE (gnu_prefix);\n+\tgnu_result_type = get_unpadded_type (Etype (gnat_node));\n+\tprefix_unused = true;\n+\n+\tif (TREE_CODE (gnu_prefix) == COMPONENT_REF)\n+\t  align = DECL_ALIGN (TREE_OPERAND (gnu_prefix, 1)) / BITS_PER_UNIT;\n+\telse\n+\t  {\n+\t    Node_Id gnat_prefix = Prefix (gnat_node);\n+\t    Entity_Id gnat_type = Etype (gnat_prefix);\n+\t    unsigned int double_align;\n+\t    bool is_capped_double, align_clause;\n+\n+\t    /* If the default alignment of \"double\" or larger scalar types is\n+\t       specifically capped and there is an alignment clause neither\n+\t       on the type nor on the prefix itself, return the cap.  */\n+\t    if ((double_align = double_float_alignment) > 0)\n+\t      is_capped_double\n+\t\t= is_double_float_or_array (gnat_type, &align_clause);\n+\t    else if ((double_align = double_scalar_alignment) > 0)\n+\t      is_capped_double\n+\t\t= is_double_scalar_or_array (gnat_type, &align_clause);\n+\t    else\n+\t      is_capped_double = align_clause = false;\n+\n+\t    if (is_capped_double\n+\t\t&& Nkind (gnat_prefix) == N_Identifier\n+\t\t&& Present (Alignment_Clause (Entity (gnat_prefix))))\n+\t      align_clause = true;\n+\n+\t    if (is_capped_double && !align_clause)\n+\t      align = double_align;\n+\t    else\n+\t      align = TYPE_ALIGN (gnu_type) / BITS_PER_UNIT;\n+\t  }\n+\n+\tgnu_result = size_int (align);\n+      }\n       break;\n \n     case Attr_First:"}, {"sha": "e3cf9756ea30fd476f3104e9050fd61c9b3bf362", "filename": "gcc/ada/gcc-interface/utils.c", "status": "modified", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/caa9d12a2b675da20f5a3016e6f306a84ee96a2a/gcc%2Fada%2Fgcc-interface%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/caa9d12a2b675da20f5a3016e6f306a84ee96a2a/gcc%2Fada%2Fgcc-interface%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.c?ref=caa9d12a2b675da20f5a3016e6f306a84ee96a2a", "patch": "@@ -74,6 +74,16 @@\n /* If nonzero, pretend we are allocating at global level.  */\n int force_global;\n \n+/* The default alignment of \"double\" floating-point types, i.e. floating\n+   point types whose size is equal to 64 bits, or 0 if this alignment is\n+   not specifically capped.  */\n+int double_float_alignment;\n+\n+/* The default alignment of \"double\" or larger scalar types, i.e. scalar\n+   types whose size is greater or equal to 64 bits, or 0 if this alignment\n+   is not specifically capped.  */\n+int double_scalar_alignment;\n+\n /* Tree nodes for the various types and decls we create.  */\n tree gnat_std_decls[(int) ADT_LAST];\n \n@@ -4564,6 +4574,62 @@ tree_code_for_record_type (Entity_Id gnat_type)\n   return UNION_TYPE;\n }\n \n+/* Return true if GNAT_TYPE is a \"double\" floating-point type, i.e. whose\n+   size is equal to 64 bits, or an array of such a type.  Set ALIGN_CLAUSE\n+   according to the presence of an alignment clause on the type or, if it\n+   is an array, on the component type.  */\n+\n+bool\n+is_double_float_or_array (Entity_Id gnat_type, bool *align_clause)\n+{\n+  gnat_type = Underlying_Type (gnat_type);\n+\n+  *align_clause = Present (Alignment_Clause (gnat_type));\n+\n+  if (Is_Array_Type (gnat_type))\n+    {\n+      gnat_type = Underlying_Type (Component_Type (gnat_type));\n+      if (Present (Alignment_Clause (gnat_type)))\n+\t*align_clause = true;\n+    }\n+\n+  if (!Is_Floating_Point_Type (gnat_type))\n+    return false;\n+\n+  if (UI_To_Int (Esize (gnat_type)) != 64)\n+    return false;\n+\n+  return true;\n+}\n+\n+/* Return true if GNAT_TYPE is a \"double\" or larger scalar type, i.e. whose\n+   size is greater or equal to 64 bits, or an array of such a type.  Set\n+   ALIGN_CLAUSE according to the presence of an alignment clause on the\n+   type or, if it is an array, on the component type.  */\n+\n+bool\n+is_double_scalar_or_array (Entity_Id gnat_type, bool *align_clause)\n+{\n+  gnat_type = Underlying_Type (gnat_type);\n+\n+  *align_clause = Present (Alignment_Clause (gnat_type));\n+\n+  if (Is_Array_Type (gnat_type))\n+    {\n+      gnat_type = Underlying_Type (Component_Type (gnat_type));\n+      if (Present (Alignment_Clause (gnat_type)))\n+\t*align_clause = true;\n+    }\n+\n+  if (!Is_Scalar_Type (gnat_type))\n+    return false;\n+\n+  if (UI_To_Int (Esize (gnat_type)) < 64)\n+    return false;\n+\n+  return true;\n+}\n+\n /* Return true if GNU_TYPE is suitable as the type of a non-aliased\n    component of an aggregate type.  */\n "}, {"sha": "07a9ab2db6f9ffee0a7b5f34ba110204ec936227", "filename": "gcc/ada/get_targ.ads", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/caa9d12a2b675da20f5a3016e6f306a84ee96a2a/gcc%2Fada%2Fget_targ.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/caa9d12a2b675da20f5a3016e6f306a84ee96a2a/gcc%2Fada%2Fget_targ.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fget_targ.ads?ref=caa9d12a2b675da20f5a3016e6f306a84ee96a2a", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -93,7 +93,15 @@ package Get_Targ is\n    pragma Import (C, Get_Bits_BE, \"get_bits_be\");\n \n    function Get_Strict_Alignment return Nat;\n-   pragma Import (C, Get_Strict_Alignment, \"get_strict_alignment\");\n+   pragma Import (C, Get_Strict_Alignment, \"get_target_strict_alignment\");\n+\n+   function Get_Double_Float_Alignment return Nat;\n+   pragma Import (C, Get_Double_Float_Alignment,\n+                  \"get_target_double_float_alignment\");\n+\n+   function Get_Double_Scalar_Alignment return Nat;\n+   pragma Import (C, Get_Double_Scalar_Alignment,\n+                  \"get_target_double_scalar_alignment\");\n \n    function Get_Max_Unaligned_Field return Pos;\n    --  Returns the maximum supported size in bits for a field that is"}, {"sha": "4e721539d87d2dbb0407951abb02bedb45f1e042", "filename": "gcc/ada/layout.adb", "status": "modified", "additions": 28, "deletions": 7, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/caa9d12a2b675da20f5a3016e6f306a84ee96a2a/gcc%2Fada%2Flayout.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/caa9d12a2b675da20f5a3016e6f306a84ee96a2a/gcc%2Fada%2Flayout.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flayout.adb?ref=caa9d12a2b675da20f5a3016e6f306a84ee96a2a", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2001-2008, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2001-2009, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -3033,15 +3033,36 @@ package body Layout is\n       --  the type, or the maximum allowed alignment.\n \n       declare\n-         S : constant Int :=\n-               UI_To_Int (Esize (E)) / SSU;\n-         A : Nat;\n+         S : constant Int := UI_To_Int (Esize (E)) / SSU;\n+         Max_Alignment, A : Nat;\n \n       begin\n+         --  If the default alignment of \"double\" floating-point types is\n+         --  specifically capped, enforce the cap.\n+\n+         if Ttypes.Target_Double_Float_Alignment > 0\n+           and then S = 8\n+           and then Is_Floating_Point_Type (E)\n+         then\n+            Max_Alignment := Ttypes.Target_Double_Float_Alignment;\n+\n+         --  If the default alignment of \"double\" or larger scalar types is\n+         --  specifically capped, enforce the cap.\n+\n+         elsif Ttypes.Target_Double_Scalar_Alignment > 0\n+           and then S >= 8\n+           and then Is_Scalar_Type (E)\n+         then\n+            Max_Alignment := Ttypes.Target_Double_Scalar_Alignment;\n+\n+         --  Otherwise enforce the overall alignment cap\n+\n+         else\n+            Max_Alignment := Ttypes.Maximum_Alignment;\n+         end if;\n+\n          A := 1;\n-         while 2 * A <= Ttypes.Maximum_Alignment\n-            and then 2 * A <= S\n-         loop\n+         while 2 * A <= Max_Alignment and then 2 * A <= S loop\n             A := 2 * A;\n          end loop;\n "}, {"sha": "01b86e336a676924d56188beecd967f080f7202f", "filename": "gcc/ada/ttypes.ads", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/caa9d12a2b675da20f5a3016e6f306a84ee96a2a/gcc%2Fada%2Fttypes.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/caa9d12a2b675da20f5a3016e6f306a84ee96a2a/gcc%2Fada%2Fttypes.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fttypes.ads?ref=caa9d12a2b675da20f5a3016e6f306a84ee96a2a", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -81,10 +81,10 @@ package Ttypes is\n    --  for all targets.\n \n    --  Note that during compilation there are two versions of package System\n-   --  around. The version that is directly WITH'ed by compiler packages\n+   --  around. The version that is directly with'ed by compiler packages\n    --  contains host-dependent definitions, which is what is needed in that\n    --  case (for example, System.Storage_Unit referenced in the source of the\n-   --  compiler refers to the storage unit of the host, not the target. This\n+   --  compiler refers to the storage unit of the host, not the target). This\n    --  means that, like attribute references, any references to constants in\n    --  package System in the compiler code are suspicious, since it is strange\n    --  for the compiler to have such host dependencies. If the compiler needs\n@@ -205,4 +205,14 @@ package Ttypes is\n    Target_Strict_Alignment : Boolean := Get_Strict_Alignment /= 0;\n    --  True if instructions will fail if data is misaligned\n \n+   Target_Double_Float_Alignment : Nat := Get_Double_Float_Alignment;\n+   --  The default alignment of \"double\" floating-point types, i.e. floating-\n+   --  point types whose size is equal to 64 bits, or 0 if this alignment is\n+   --  not specifically capped.\n+\n+   Target_Double_Scalar_Alignment : Nat := Get_Double_Scalar_Alignment;\n+   --  The default alignment of \"double\" or larger scalar types, i.e. scalar\n+   --  types whose size is greater or equal to 64 bits, or 0 if this alignment\n+   --  is not specifically capped.\n+\n end Ttypes;"}, {"sha": "3af0f6f3dde6e22c5f04c5409279e7a326b728dd", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/caa9d12a2b675da20f5a3016e6f306a84ee96a2a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/caa9d12a2b675da20f5a3016e6f306a84ee96a2a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=caa9d12a2b675da20f5a3016e6f306a84ee96a2a", "patch": "@@ -1,3 +1,8 @@\n+2009-04-24  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gnat.dg/alignment7.adb: New test.\n+\t* gnat.dg/alignment8.adb: Likewise.\n+\n 2009-04-24  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gnat.dg/specs/pr34799.ads: Rename to rep_clause1.ads."}, {"sha": "5a3b8eb43c81f05433dc33b263a6f056e5ee84f6", "filename": "gcc/testsuite/gnat.dg/alignment7.adb", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/caa9d12a2b675da20f5a3016e6f306a84ee96a2a/gcc%2Ftestsuite%2Fgnat.dg%2Falignment7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/caa9d12a2b675da20f5a3016e6f306a84ee96a2a/gcc%2Ftestsuite%2Fgnat.dg%2Falignment7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Falignment7.adb?ref=caa9d12a2b675da20f5a3016e6f306a84ee96a2a", "patch": "@@ -0,0 +1,24 @@\n+-- { dg-do run }\n+\n+with System;\n+\n+procedure Alignment7 is\n+\n+  type R is record\n+    I : Integer;\n+    F : Long_Float;\n+  end record;\n+  for R'Alignment use 8;\n+\n+  procedure Q (A : System.Address) is\n+    F : Long_Float;\n+    for F'Address use A;\n+  begin\n+    F := 0.0;\n+  end;\n+\n+  V : R;\n+\n+begin\n+  Q (V.F'Address);\n+end;"}, {"sha": "06136c36e0e5484cf4c5d642c1b3cdacc2ee2447", "filename": "gcc/testsuite/gnat.dg/alignment8.adb", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/caa9d12a2b675da20f5a3016e6f306a84ee96a2a/gcc%2Ftestsuite%2Fgnat.dg%2Falignment8.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/caa9d12a2b675da20f5a3016e6f306a84ee96a2a/gcc%2Ftestsuite%2Fgnat.dg%2Falignment8.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Falignment8.adb?ref=caa9d12a2b675da20f5a3016e6f306a84ee96a2a", "patch": "@@ -0,0 +1,24 @@\n+-- { dg-do run }\n+\n+with System;\n+\n+procedure Alignment8 is\n+\n+  type R is record\n+    I : Integer;\n+    F : Long_Long_Integer;\n+  end record;\n+  for R'Alignment use 8;\n+\n+  procedure Q (A : System.Address) is\n+    F : Long_Long_Integer;\n+    for F'Address use A;\n+  begin\n+    F := 0;\n+  end;\n+\n+  V : R;\n+\n+begin\n+  Q (V.F'Address);\n+end;"}]}