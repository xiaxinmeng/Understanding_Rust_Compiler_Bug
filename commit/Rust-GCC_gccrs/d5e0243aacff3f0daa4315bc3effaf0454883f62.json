{"sha": "d5e0243aacff3f0daa4315bc3effaf0454883f62", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDVlMDI0M2FhY2ZmM2YwZGFhNDMxNWJjM2VmZmFmMDQ1NDg4M2Y2Mg==", "commit": {"author": {"name": "David Edelsohn", "email": "edelsohn@gnu.org", "date": "2001-12-23T02:16:02Z"}, "committer": {"name": "David Edelsohn", "email": "dje@gcc.gnu.org", "date": "2001-12-23T02:16:02Z"}, "message": "loop.c (scan_loop, [...]): Do not overlook hard registers when computing statistics.\n\n        * loop.c (scan_loop, move_movables, count_one_set): Do not\n        overlook hard registers when computing statistics.\n\nFrom-SVN: r48280", "tree": {"sha": "4698c9c32a8dc36e5705443957e6db33abd8f190", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4698c9c32a8dc36e5705443957e6db33abd8f190"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d5e0243aacff3f0daa4315bc3effaf0454883f62", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d5e0243aacff3f0daa4315bc3effaf0454883f62", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d5e0243aacff3f0daa4315bc3effaf0454883f62", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d5e0243aacff3f0daa4315bc3effaf0454883f62/comments", "author": null, "committer": null, "parents": [{"sha": "53d4257f7fd9c8446aae11c3c84de7133773a73c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/53d4257f7fd9c8446aae11c3c84de7133773a73c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/53d4257f7fd9c8446aae11c3c84de7133773a73c"}], "stats": {"total": 68, "additions": 47, "deletions": 21}, "files": [{"sha": "654025098ec444265c536b42f8d9d1823c7e2b9e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5e0243aacff3f0daa4315bc3effaf0454883f62/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5e0243aacff3f0daa4315bc3effaf0454883f62/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d5e0243aacff3f0daa4315bc3effaf0454883f62", "patch": "@@ -1,3 +1,8 @@\n+2001-12-22  David Edelsohn  <edelsohn@gnu.org>\n+\n+\t* loop.c (scan_loop, move_movables, count_one_set): Do not\n+\toverlook hard registers when computing statistics.\n+\n Sun Dec 23 00:49:37 CET 2001  Jan Hubicka  <jh@suse.cz>\n \n \t* calls.c (ECF_LIBCALL_BLOCK): New constant."}, {"sha": "5678354d4785ef6cac650443da9ca04720ffb46b", "filename": "gcc/loop.c", "status": "modified", "additions": 42, "deletions": 21, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5e0243aacff3f0daa4315bc3effaf0454883f62/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5e0243aacff3f0daa4315bc3effaf0454883f62/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=d5e0243aacff3f0daa4315bc3effaf0454883f62", "patch": "@@ -145,6 +145,10 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n ((REGNO_LAST_LUID (REGNO) > INSN_LUID ((LOOP)->end) \\\n  || REGNO_FIRST_LUID (REGNO) < INSN_LUID ((LOOP)->start)))\n \n+#define LOOP_REGNO_NREGS(REGNO, SET_DEST) \\\n+((REGNO) < FIRST_PSEUDO_REGISTER \\\n+ ? HARD_REGNO_NREGS ((REGNO), GET_MODE (SET_DEST)) : 1)\n+\n \n /* Vector mapping INSN_UIDs to luids.\n    The luids are like uids but increase monotonically always.\n@@ -893,7 +897,8 @@ scan_loop (loop, flags)\n \t\t\t\t   SET_DEST (set), copy_rtx (SET_SRC (set)));\n \n \t\t  delete_insn (p);\n-\t\t  regs->array[regno].set_in_loop = 0;\n+\t\t  for (i = 0; i < LOOP_REGNO_NREGS (regno, SET_DEST (set)); i++)\n+\t\t    regs->array[regno+i].set_in_loop = 0;\n \t\t  continue;\n \t\t}\n \n@@ -923,7 +928,8 @@ scan_loop (loop, flags)\n \t      m->savings = regs->array[regno].n_times_set;\n \t      if (find_reg_note (p, REG_RETVAL, NULL_RTX))\n \t\tm->savings += libcall_benefit (p);\n-\t      regs->array[regno].set_in_loop = move_insn ? -2 : -1;\n+\t      for (i = 0; i < LOOP_REGNO_NREGS (regno, SET_DEST (set)); i++)\n+\t\tregs->array[regno+i].set_in_loop = move_insn ? -2 : -1;\n \t      /* Add M to the end of the chain MOVABLES.  */\n \t      loop_movables_add (movables, m);\n \n@@ -1024,7 +1030,8 @@ scan_loop (loop, flags)\n \t\t  m->match = 0;\n \t\t  m->lifetime = LOOP_REG_LIFETIME (loop, regno);\n \t\t  m->savings = 1;\n-\t\t  regs->array[regno].set_in_loop = -1;\n+\t\t  for (i = 0; i < LOOP_REGNO_NREGS (regno, SET_DEST (set)); i++)\n+\t\t    regs->array[regno+i].set_in_loop = -1;\n \t\t  /* Add M to the end of the chain MOVABLES.  */\n \t\t  loop_movables_add (movables, m);\n \t\t}\n@@ -2145,7 +2152,11 @@ move_movables (loop, movables, threshold, insn_count)\n \n \t      /* The reg set here is now invariant.  */\n \t      if (! m->partial)\n-\t\tregs->array[regno].set_in_loop = 0;\n+\t\t{\n+\t\t  int i;\n+\t\t  for (i = 0; i < LOOP_REGNO_NREGS (regno, m->set_dest); i++)\n+\t\t    regs->array[regno+i].set_in_loop = 0;\n+\t\t}\n \n \t      m->done = 1;\n \n@@ -2205,7 +2216,13 @@ move_movables (loop, movables, threshold, insn_count)\n \t\t      /* The reg merged here is now invariant,\n \t\t\t if the reg it matches is invariant.  */\n \t\t      if (! m->partial)\n-\t\t\tregs->array[m1->regno].set_in_loop = 0;\n+\t\t\t{\n+\t\t\t  int i;\n+\t\t\t  for (i = 0;\n+\t\t\t       i < LOOP_REGNO_NREGS (regno, m1->set_dest);\n+\t\t\t       i++)\n+\t\t\t    regs->array[m1->regno+i].set_in_loop = 0;\n+\t\t\t}\n \t\t    }\n \t    }\n \t  else if (loop_dump_stream)\n@@ -3445,23 +3462,27 @@ count_one_set (regs, insn, x, last_set)\n \tdest = XEXP (dest, 0);\n       if (GET_CODE (dest) == REG)\n \t{\n+\t  int i;\n \t  int regno = REGNO (dest);\n-\t  /* If this is the first setting of this reg\n-\t     in current basic block, and it was set before,\n-\t     it must be set in two basic blocks, so it cannot\n-\t     be moved out of the loop.  */\n-\t  if (regs->array[regno].set_in_loop > 0\n-\t      && last_set == 0)\n-\t    regs->array[regno].may_not_optimize = 1;\n-\t  /* If this is not first setting in current basic block,\n-\t     see if reg was used in between previous one and this.\n-\t     If so, neither one can be moved.  */\n-\t  if (last_set[regno] != 0\n-\t      && reg_used_between_p (dest, last_set[regno], insn))\n-\t    regs->array[regno].may_not_optimize = 1;\n-\t  if (regs->array[regno].set_in_loop < 127)\n-\t    ++regs->array[regno].set_in_loop;\n-\t  last_set[regno] = insn;\n+\t  for (i = 0; i < LOOP_REGNO_NREGS (regno, dest); i++)\n+\t    {\n+\t      /* If this is the first setting of this reg\n+\t\t in current basic block, and it was set before,\n+\t\t it must be set in two basic blocks, so it cannot\n+\t\t be moved out of the loop.  */\n+\t      if (regs->array[regno].set_in_loop > 0\n+\t\t  && last_set == 0)\n+\t\tregs->array[regno+i].may_not_optimize = 1;\n+\t      /* If this is not first setting in current basic block,\n+\t\t see if reg was used in between previous one and this.\n+\t\t If so, neither one can be moved.  */\n+\t      if (last_set[regno] != 0\n+\t\t  && reg_used_between_p (dest, last_set[regno], insn))\n+\t\tregs->array[regno+i].may_not_optimize = 1;\n+\t      if (regs->array[regno+i].set_in_loop < 127)\n+\t\t++regs->array[regno+i].set_in_loop;\n+\t      last_set[regno+i] = insn;\n+\t    }\n \t}\n     }\n }"}]}