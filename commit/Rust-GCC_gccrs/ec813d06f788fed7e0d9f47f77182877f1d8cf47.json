{"sha": "ec813d06f788fed7e0d9f47f77182877f1d8cf47", "node_id": "C_kwDOANBUbNoAKGVjODEzZDA2Zjc4OGZlZDdlMGQ5ZjQ3Zjc3MTgyODc3ZjFkOGNmNDc", "commit": {"author": {"name": "Steve Baird", "email": "baird@adacore.com", "date": "2021-07-09T19:04:09Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2021-09-22T15:01:42Z"}, "message": "[Ada] Add -gnatX support for casing on array values\n\ngcc/ada/\n\n\t* exp_ch5.adb (Expand_General_Case_Statement.Pattern_Match): Add\n\tnew function Indexed_Element to handle array element\n\tcomparisons. Handle case choices that are array aggregates,\n\tstring literals, or names denoting constants.\n\t* sem_case.adb (Composite_Case_Ops.Array_Case_Ops): New package\n\tproviding utilities needed for casing on arrays.\n\t(Composite_Case_Ops.Choice_Analysis): If necessary, include\n\tarray length as a \"component\" (like a discriminant) when\n\ttraversing components. We do not (yet) partition choice analysis\n\tto deal with unequal length choices separately. Instead, we\n\tembed everything in the minimum-dimensionality Cartesian product\n\tspace needed to handle all choices properly; this is determined\n\tby the length of the longest choice pattern.\n\t(Composite_Case_Ops.Choice_Analysis.Traverse_Discrete_Parts):\n\tInclude length as a \"component\" in the traversal if necessary.\n\t(Composite_Case_Ops.Choice_Analysis.Parse_Choice.Traverse_Choice):\n\tAdd support for case choices that are string literals or names\n\tdenoting constants.\n\t(Composite_Case_Ops.Choice_Analysis): Include length as a\n\t\"component\" in the analysis if necessary.\n\t(Check_Choices.Check_Case_Pattern_Choices.Ops.Value_Sets.Value_Index_Count):\n\tImprove error message when capacity exceeded.\n\t* doc/gnat_rm/implementation_defined_pragmas.rst: Update\n\tdocumentation to reflect current implementation status.\n\t* gnat_rm.texi: Regenerate.", "tree": {"sha": "e0124781b876c9e0dc0935870ea4bf972dc610cd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e0124781b876c9e0dc0935870ea4bf972dc610cd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ec813d06f788fed7e0d9f47f77182877f1d8cf47", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec813d06f788fed7e0d9f47f77182877f1d8cf47", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ec813d06f788fed7e0d9f47f77182877f1d8cf47", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec813d06f788fed7e0d9f47f77182877f1d8cf47/comments", "author": {"login": "swbaird", "id": 50751052, "node_id": "MDQ6VXNlcjUwNzUxMDUy", "avatar_url": "https://avatars.githubusercontent.com/u/50751052?v=4", "gravatar_id": "", "url": "https://api.github.com/users/swbaird", "html_url": "https://github.com/swbaird", "followers_url": "https://api.github.com/users/swbaird/followers", "following_url": "https://api.github.com/users/swbaird/following{/other_user}", "gists_url": "https://api.github.com/users/swbaird/gists{/gist_id}", "starred_url": "https://api.github.com/users/swbaird/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/swbaird/subscriptions", "organizations_url": "https://api.github.com/users/swbaird/orgs", "repos_url": "https://api.github.com/users/swbaird/repos", "events_url": "https://api.github.com/users/swbaird/events{/privacy}", "received_events_url": "https://api.github.com/users/swbaird/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c5ff859dc01958f39ba77de6421d774171e3ea09", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c5ff859dc01958f39ba77de6421d774171e3ea09", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c5ff859dc01958f39ba77de6421d774171e3ea09"}], "stats": {"total": 513, "additions": 459, "deletions": 54}, "files": [{"sha": "9d2f11305e897ea6821ab52455eed42fd614bcae", "filename": "gcc/ada/doc/gnat_rm/implementation_defined_pragmas.rst", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec813d06f788fed7e0d9f47f77182877f1d8cf47/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fimplementation_defined_pragmas.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec813d06f788fed7e0d9f47f77182877f1d8cf47/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fimplementation_defined_pragmas.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fimplementation_defined_pragmas.rst?ref=ec813d06f788fed7e0d9f47f77182877f1d8cf47", "patch": "@@ -2270,8 +2270,15 @@ of GNAT specific extensions are recognized as follows:\n   values of the composite type shall be covered. The composite type of the\n   selector shall be a nonlimited untagged (but possibly discriminated)\n   record type, all of whose subcomponent subtypes are either static discrete\n-  subtypes or record types that meet the same restrictions. Support for arrays\n-  is planned, but not yet implemented.\n+  subtypes or record types that meet the same restrictions.\n+\n+  Support for casing on arrays (and on records that contain arrays) is\n+  currently subject to some restrictions. Non-positional\n+  array aggregates are not supported as (or within) case choices. Likewise\n+  for array type and subtype names. The current implementation exceeds\n+  compile-time capacity limits in some annoyingly common scenarios; the\n+  message generated in such cases is usually \"Capacity exceeded in compiling\n+  case statement with composite selector type\".\n \n   In addition, pattern bindings are supported. This is a mechanism\n   for binding a name to a component of a matching value for use within\n@@ -2280,7 +2287,8 @@ of GNAT specific extensions are recognized as follows:\n   \"is <identifier>\". In the special case of a \"box\" component association,\n   the identifier may instead be provided within the box. Either of these\n   indicates that the given identifer denotes (a constant view of) the matching\n-  subcomponent of the case selector.\n+  subcomponent of the case selector. Binding is not yet supported for arrays\n+  or subcomponents thereof.\n \n   Consider this example (which uses type Rec from the previous example):\n "}, {"sha": "21ac2a2b747ca1ad601d8096522a1ee752f0f1e8", "filename": "gcc/ada/exp_ch5.adb", "status": "modified", "additions": 131, "deletions": 16, "changes": 147, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec813d06f788fed7e0d9f47f77182877f1d8cf47/gcc%2Fada%2Fexp_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec813d06f788fed7e0d9f47f77182877f1d8cf47/gcc%2Fada%2Fexp_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch5.adb?ref=ec813d06f788fed7e0d9f47f77182877f1d8cf47", "patch": "@@ -31,7 +31,6 @@ with Einfo;          use Einfo;\n with Einfo.Entities; use Einfo.Entities;\n with Einfo.Utils;    use Einfo.Utils;\n with Elists;         use Elists;\n-with Errout;         use Errout;\n with Exp_Aggr;       use Exp_Aggr;\n with Exp_Ch6;        use Exp_Ch6;\n with Exp_Ch7;        use Exp_Ch7;\n@@ -3365,6 +3364,30 @@ package body Exp_Ch5 is\n               renames Pattern_Match;\n             --  convenient rename for recursive calls\n \n+            function Indexed_Element (Idx : Pos) return Node_Id;\n+            --  Returns the Nth (well, ok, the Idxth) element of Object\n+\n+            ---------------------\n+            -- Indexed_Element --\n+            ---------------------\n+\n+            function Indexed_Element (Idx : Pos) return Node_Id is\n+               Obj_Index : constant Node_Id :=\n+                 Make_Op_Add (Loc,\n+                   Left_Opnd =>\n+                     Make_Attribute_Reference (Loc,\n+                       Attribute_Name => Name_First,\n+                       Prefix => New_Copy_Tree (Object)),\n+                   Right_Opnd =>\n+                     Make_Integer_Literal (Loc, Idx - 1));\n+            begin\n+               return Make_Indexed_Component (Loc,\n+                        Prefix => New_Copy_Tree (Object),\n+                        Expressions => New_List (Obj_Index));\n+            end Indexed_Element;\n+\n+         --  Start of processing for Pattern_Match\n+\n          begin\n             if Choice_Index /= 0 and not Suppress_Choice_Index_Update then\n                pragma Assert (Present (Choice_Index_Decl));\n@@ -3399,16 +3422,51 @@ package body Exp_Ch5 is\n \n             case Nkind (Pattern) is\n                when N_Aggregate =>\n-                  return Result : Node_Id :=\n-                    New_Occurrence_Of (Standard_True, Loc)\n-                  do\n+                  declare\n+                     Result : Node_Id;\n+                  begin\n                      if Is_Array_Type (Etype (Pattern)) then\n-                        --  Calling Error_Msg_N during expansion is usually a\n-                        --  mistake but is ok for an \"unimplemented\" message.\n-                        Error_Msg_N\n-                          (\"array-valued case choices unimplemented\",\n-                          Pattern);\n-                        return;\n+\n+                        --  Nonpositional aggregates currently unimplemented.\n+                        --  We flag that case during analysis, so an assertion\n+                        --  is ok here.\n+                        --\n+                        pragma Assert\n+                          (not Is_Non_Empty_List\n+                                 (Component_Associations (Pattern)));\n+\n+                        declare\n+                           Agg_Length : constant Node_Id :=\n+                             Make_Integer_Literal (Loc,\n+                               List_Length (Expressions (Pattern)));\n+\n+                           Obj_Length : constant Node_Id :=\n+                             Make_Attribute_Reference (Loc,\n+                               Attribute_Name => Name_Length,\n+                               Prefix => New_Copy_Tree (Object));\n+                        begin\n+                           Result := Make_Op_Eq (Loc,\n+                                       Left_Opnd  => Obj_Length,\n+                                       Right_Opnd => Agg_Length);\n+                        end;\n+\n+                        declare\n+                           Expr : Node_Id := First (Expressions (Pattern));\n+                           Idx  : Pos := 1;\n+                        begin\n+                           while Present (Expr) loop\n+                              Result :=\n+                                Make_And_Then (Loc,\n+                                  Left_Opnd  => Result,\n+                                  Right_Opnd =>\n+                                    PM (Pattern => Expr,\n+                                        Object => Indexed_Element (Idx)));\n+                              Next (Expr);\n+                              Idx := Idx + 1;\n+                           end loop;\n+                        end;\n+\n+                        return Result;\n                      end if;\n \n                      --  positional notation should have been normalized\n@@ -3425,6 +3483,8 @@ package body Exp_Ch5 is\n                              Selector_Name => New_Occurrence_Of\n                                                 (Entity (Choice), Loc)));\n                      begin\n+                        Result := New_Occurrence_Of (Standard_True, Loc);\n+\n                         while Present (Component_Assoc) loop\n                            Choice := First (Choices (Component_Assoc));\n                            while Present (Choice) loop\n@@ -3530,27 +3590,82 @@ package body Exp_Ch5 is\n                            Next (Component_Assoc);\n                         end loop;\n                      end;\n+                     return Result;\n+                  end;\n+\n+               when N_String_Literal =>\n+                  return Result : Node_Id do\n+                     declare\n+                        Char_Type : constant Entity_Id :=\n+                          Root_Type (Component_Type (Etype (Pattern)));\n+\n+                        --  If the component type is not a standard character\n+                        --  type then this string lit should have already been\n+                        --  transformed into an aggregate in\n+                        --  Resolve_String_Literal.\n+                        --\n+                        pragma Assert (Is_Standard_Character_Type (Char_Type));\n+\n+                        Str    : constant String_Id  := Strval (Pattern);\n+                        Strlen : constant Nat        := String_Length (Str);\n+\n+                        Lit_Length : constant Node_Id :=\n+                          Make_Integer_Literal (Loc, Strlen);\n+\n+                        Obj_Length : constant Node_Id :=\n+                          Make_Attribute_Reference (Loc,\n+                            Attribute_Name => Name_Length,\n+                            Prefix => New_Copy_Tree (Object));\n+                     begin\n+                        Result := Make_Op_Eq (Loc,\n+                                    Left_Opnd  => Obj_Length,\n+                                    Right_Opnd => Lit_Length);\n+\n+                        for Idx in 1 .. Strlen loop\n+                           declare\n+                              C           : constant Char_Code :=\n+                                Get_String_Char (Str, Idx);\n+                              Obj_Element : constant Node_Id :=\n+                                Indexed_Element (Idx);\n+                              Char_Lit    : Node_Id;\n+                           begin\n+                              Set_Character_Literal_Name (C);\n+                              Char_Lit :=\n+                                Make_Character_Literal (Loc,\n+                                  Chars              => Name_Find,\n+                                  Char_Literal_Value => UI_From_CC (C));\n+\n+                              Result :=\n+                                Make_And_Then (Loc,\n+                                  Left_Opnd  => Result,\n+                                  Right_Opnd =>\n+                                    Make_Op_Eq (Loc,\n+                                      Left_Opnd  => Obj_Element,\n+                                      Right_Opnd => Char_Lit));\n+                           end;\n+                        end loop;\n+                     end;\n                   end return;\n \n                when N_Qualified_Expression =>\n-                  --  Make a copy for one of the two uses of Object; the choice\n-                  --  of where to use the original and where to use the copy\n-                  --  is arbitrary.\n-\n                   return Make_And_Then (Loc,\n                     Left_Opnd  => Make_In (Loc,\n                       Left_Opnd  => New_Copy_Tree (Object),\n                       Right_Opnd => New_Copy_Tree (Subtype_Mark (Pattern))),\n                     Right_Opnd =>\n                       PM (Pattern => Expression (Pattern),\n-                          Object  => Object));\n+                          Object  => New_Copy_Tree (Object)));\n \n                when N_Identifier | N_Expanded_Name =>\n                   if Is_Type (Entity (Pattern)) then\n                      return Make_In (Loc,\n-                       Left_Opnd  => Object,\n+                       Left_Opnd  => New_Copy_Tree (Object),\n                        Right_Opnd => New_Occurrence_Of\n                                        (Entity (Pattern), Loc));\n+                  elsif Ekind (Entity (Pattern)) = E_Constant then\n+                     return PM (Pattern =>\n+                                  Expression (Parent (Entity (Pattern))),\n+                                Object => Object);\n                   end if;\n \n                when N_Others_Choice =>"}, {"sha": "08cef9fce3f4a927dd2d79ad66158293f6ae5e77", "filename": "gcc/ada/gnat_rm.texi", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec813d06f788fed7e0d9f47f77182877f1d8cf47/gcc%2Fada%2Fgnat_rm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec813d06f788fed7e0d9f47f77182877f1d8cf47/gcc%2Fada%2Fgnat_rm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_rm.texi?ref=ec813d06f788fed7e0d9f47f77182877f1d8cf47", "patch": "@@ -21,7 +21,7 @@\n \n @copying\n @quotation\n-GNAT Reference Manual , Jun 23, 2021\n+GNAT Reference Manual , Aug 03, 2021\n \n AdaCore\n \n@@ -3698,8 +3698,15 @@ will not be executed if the earlier alternative \u201cmatches\u201d). All possible\n values of the composite type shall be covered. The composite type of the\n selector shall be a nonlimited untagged (but possibly discriminated)\n record type, all of whose subcomponent subtypes are either static discrete\n-subtypes or record types that meet the same restrictions. Support for arrays\n-is planned, but not yet implemented.\n+subtypes or record types that meet the same restrictions.\n+\n+Support for casing on arrays (and on records that contain arrays) is\n+currently subject to some restrictions. Non-positional\n+array aggregates are not supported as (or within) case choices. Likewise\n+for array type and subtype names. The current implementation exceeds\n+compile-time capacity limits in some annoyingly common scenarios; the\n+message generated in such cases is usually \u201cCapacity exceeded in compiling\n+case statement with composite selector type\u201d.\n \n In addition, pattern bindings are supported. This is a mechanism\n for binding a name to a component of a matching value for use within\n@@ -3708,7 +3715,8 @@ that occurs within a case choice, the expression may be followed by\n \u201cis <identifier>\u201d. In the special case of a \u201cbox\u201d component association,\n the identifier may instead be provided within the box. Either of these\n indicates that the given identifer denotes (a constant view of) the matching\n-subcomponent of the case selector.\n+subcomponent of the case selector. Binding is not yet supported for arrays\n+or subcomponents thereof.\n \n Consider this example (which uses type Rec from the previous example):\n "}, {"sha": "cc7e988226d0b86d2e8c09b7dea7a23c81010aed", "filename": "gcc/ada/sem_case.adb", "status": "modified", "additions": 305, "deletions": 31, "changes": 336, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec813d06f788fed7e0d9f47f77182877f1d8cf47/gcc%2Fada%2Fsem_case.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec813d06f788fed7e0d9f47f77182877f1d8cf47/gcc%2Fada%2Fsem_case.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_case.adb?ref=ec813d06f788fed7e0d9f47f77182877f1d8cf47", "patch": "@@ -44,6 +44,7 @@ with Stand;          use Stand;\n with Sinfo;          use Sinfo;\n with Sinfo.Nodes;    use Sinfo.Nodes;\n with Sinfo.Utils;    use Sinfo.Utils;\n+with Stringt;        use Stringt;\n with Table;\n with Tbuild;         use Tbuild;\n with Uintp;          use Uintp;\n@@ -105,25 +106,70 @@ package body Sem_Case is\n \n    package Composite_Case_Ops is\n \n+      function Choice_Count (Alternatives : List_Id) return Nat;\n+      --  The sum of the number of choices for each alternative in the given\n+      --  list.\n+\n       function Scalar_Part_Count (Subtyp : Entity_Id) return Nat;\n       --  Given the composite type Subtyp of a case selector, returns the\n       --  number of scalar parts in an object of this type. This is the\n       --  dimensionality of the associated Cartesian product space.\n \n-      function Choice_Count (Alternatives : List_Id) return Nat;\n-      --  The sum of the number of choices for each alternative in the given\n-      --  list.\n+      package Array_Case_Ops is\n+         function Array_Choice_Length (Choice : Node_Id) return Nat;\n+         --  Given a choice expression of an array type, returns its length.\n+\n+         function Normalized_Case_Expr_Type\n+           (Case_Statement : Node_Id) return Entity_Id;\n+         --  Usually returns the Etype of the selector expression of the\n+         --  case statement. However, in the case of a constrained array\n+         --  subtype with a nonstatic constraint, returns the unconstrained\n+         --  array base type.\n+\n+         function Unconstrained_Array_Effective_Length\n+           (Array_Type : Entity_Id; Case_Statement : Node_Id) return Nat;\n+         --  If the nominal subtype of the case selector is unconstrained,\n+         --  then use the length of the longest choice of the case statement.\n+         --  Components beyond that index value will not influence the case\n+         --  selection decision.\n+\n+         function Unconstrained_Array_Scalar_Part_Count\n+           (Array_Type : Entity_Id; Case_Statement : Node_Id) return Nat;\n+         --  Same as Scalar_Part_Count except that the value used for the\n+         --  \"length\" of the array subtype being cased on is determined by\n+         --  calling Unconstrained_Array_Effective_Length.\n+      end Array_Case_Ops;\n \n       generic\n          Case_Statement : Node_Id;\n       package Choice_Analysis is\n \n+         use Array_Case_Ops;\n+\n          type Alternative_Id is\n            new Int range 1 .. List_Length (Alternatives (Case_Statement));\n          type Choice_Id is\n            new Int range 1 .. Choice_Count (Alternatives (Case_Statement));\n+\n+         Case_Expr_Type : constant Entity_Id :=\n+           Normalized_Case_Expr_Type (Case_Statement);\n+\n+         Unconstrained_Array_Case : constant Boolean :=\n+           Is_Array_Type (Case_Expr_Type)\n+             and then not Is_Constrained (Case_Expr_Type);\n+\n+         --  If Unconstrained_Array_Case is True, choice lengths may differ:\n+         --    when \"Aaa\" | \"Bb\" | \"C\" | \"\" =>\n+         --\n+         --  Strictly speaking, the name \"Unconstrained_Array_Case\" is\n+         --  slightly imprecise; a subtype with a nonstatic constraint is\n+         --  also treated as unconstrained (see Normalize_Case_Expr_Type).\n+\n          type Part_Id is new Int range\n-           1 .. Scalar_Part_Count (Etype (Expression (Case_Statement)));\n+           1 .. (if Unconstrained_Array_Case\n+                 then Unconstrained_Array_Scalar_Part_Count\n+                        (Case_Expr_Type, Case_Statement)\n+                 else Scalar_Part_Count (Case_Expr_Type));\n \n          type Discrete_Range_Info is\n            record\n@@ -1118,6 +1164,21 @@ package body Sem_Case is\n          return UI_To_Int (Len);\n       end Static_Array_Length;\n \n+      ------------------\n+      -- Choice_Count --\n+      ------------------\n+\n+      function Choice_Count (Alternatives : List_Id) return Nat is\n+         Result : Nat := 0;\n+         Alt : Node_Id := First (Alternatives);\n+      begin\n+         while Present (Alt) loop\n+            Result := Result + List_Length (Discrete_Choices (Alt));\n+            Next (Alt);\n+         end loop;\n+         return Result;\n+      end Choice_Count;\n+\n       -----------------------\n       -- Scalar_Part_Count --\n       -----------------------\n@@ -1147,20 +1208,118 @@ package body Sem_Case is\n          end if;\n       end Scalar_Part_Count;\n \n-      ------------------\n-      -- Choice_Count --\n-      ------------------\n+      package body Array_Case_Ops is\n \n-      function Choice_Count (Alternatives : List_Id) return Nat is\n-         Result : Nat := 0;\n-         Alt : Node_Id := First (Alternatives);\n-      begin\n-         while Present (Alt) loop\n-            Result := Result + List_Length (Discrete_Choices (Alt));\n-            Next (Alt);\n-         end loop;\n-         return Result;\n-      end Choice_Count;\n+         -------------------------\n+         -- Array_Choice_Length --\n+         -------------------------\n+\n+         function Array_Choice_Length (Choice : Node_Id) return Nat is\n+         begin\n+            case Nkind (Choice) is\n+               when N_String_Literal =>\n+                  return String_Length (Strval (Choice));\n+               when N_Aggregate =>\n+                  declare\n+                     Bounds : constant Node_Id :=\n+                       Aggregate_Bounds (Choice);\n+                     pragma Assert (Is_OK_Static_Range (Bounds));\n+                     Lo     : constant Uint :=\n+                       Expr_Value (Low_Bound (Bounds));\n+                     Hi     : constant Uint :=\n+                       Expr_Value (High_Bound (Bounds));\n+                     Len : constant Uint := (Hi - Lo) + 1;\n+                  begin\n+                     return UI_To_Int (Len);\n+                  end;\n+               when N_Has_Entity =>\n+                  if Present (Entity (Choice))\n+                    and then Ekind (Entity (Choice)) = E_Constant\n+                  then\n+                     return Array_Choice_Length\n+                              (Expression (Parent (Entity (Choice))));\n+                  end if;\n+               when N_Others_Choice =>\n+                  return 0;\n+               when others =>\n+                  null;\n+            end case;\n+\n+            if Nkind (Original_Node (Choice))\n+                 in N_String_Literal | N_Aggregate\n+            then\n+               return Array_Choice_Length (Original_Node (Choice));\n+            end if;\n+\n+            Error_Msg_N (\"Unsupported case choice\", Choice);\n+            return 0;\n+         end Array_Choice_Length;\n+\n+         -------------------------------\n+         -- Normalized_Case_Expr_Type --\n+         -------------------------------\n+\n+         function Normalized_Case_Expr_Type\n+           (Case_Statement : Node_Id) return Entity_Id\n+         is\n+            Unnormalized : constant Entity_Id :=\n+              Etype (Expression (Case_Statement));\n+         begin\n+            if Is_Array_Type (Unnormalized)\n+              and then Is_Constrained (Unnormalized)\n+              and then not Has_Static_Array_Bounds (Unnormalized)\n+            then\n+               return Base_Type (Unnormalized);\n+            else\n+               return Unnormalized;\n+            end if;\n+         end Normalized_Case_Expr_Type;\n+\n+      ------------------------------------------\n+         -- Unconstrained_Array_Effective_Length --\n+      ------------------------------------------\n+\n+         function Unconstrained_Array_Effective_Length\n+           (Array_Type : Entity_Id; Case_Statement : Node_Id) return Nat\n+         is\n+            pragma Assert (Is_Array_Type (Array_Type));\n+            --  Array_Type is otherwise unreferenced for now.\n+\n+            Result : Nat := 0;\n+            Alt : Node_Id := First (Alternatives (Case_Statement));\n+         begin\n+            while Present (Alt) loop\n+               declare\n+                  Choice : Node_Id := First (Discrete_Choices (Alt));\n+               begin\n+                  while Present (Choice) loop\n+                     Result := Nat'Max (Result, Array_Choice_Length (Choice));\n+                     Next (Choice);\n+                  end loop;\n+               end;\n+               Next (Alt);\n+            end loop;\n+\n+            return Result;\n+         end Unconstrained_Array_Effective_Length;\n+\n+         -------------------------------------------\n+         -- Unconstrained_Array_Scalar_Part_Count --\n+         -------------------------------------------\n+\n+         function Unconstrained_Array_Scalar_Part_Count\n+           (Array_Type : Entity_Id; Case_Statement : Node_Id) return Nat\n+         is\n+         begin\n+            --  Add one for the length, which is treated like a discriminant\n+\n+            return 1 + (Unconstrained_Array_Effective_Length\n+                          (Array_Type     => Array_Type,\n+                           Case_Statement => Case_Statement)\n+                        * Scalar_Part_Count (Component_Type (Array_Type)));\n+         end Unconstrained_Array_Scalar_Part_Count;\n+\n+      end Array_Case_Ops;\n \n       package body Choice_Analysis is\n \n@@ -1220,9 +1379,32 @@ package body Sem_Case is\n                     ((Low  => Expr_Value (Type_Low_Bound (Subtyp)),\n                       High => Expr_Value (Type_High_Bound (Subtyp))));\n                elsif Is_Array_Type (Subtyp) then\n-                  for I in 1 .. Static_Array_Length (Subtyp) loop\n-                     Traverse_Discrete_Parts (Component_Type (Subtyp));\n-                  end loop;\n+                  declare\n+                     Len : Nat;\n+                  begin\n+                     if Is_Constrained (Subtyp) then\n+                        Len := Static_Array_Length (Subtyp);\n+                     else\n+                        --  Length will be treated like a discriminant;\n+                        --  We could compute High more precisely as\n+                        --    1 + Index_Subtype'Last - Index_Subtype'First\n+                        --  (we currently require that those bounds be\n+                        --  static, so this is an option), but only downside of\n+                        --  overshooting is if somebody wants to omit a\n+                        --  \"when others\" choice and exhaustively cover all\n+                        --  possibilities explicitly.\n+                        Update_Result\n+                          ((Low  => Uint_0,\n+                            High => Uint_2 ** Uint_32));\n+\n+                        Len := Unconstrained_Array_Effective_Length\n+                                 (Array_Type     => Subtyp,\n+                                  Case_Statement => Case_Statement);\n+                     end if;\n+                     for I in 1 .. Len loop\n+                        Traverse_Discrete_Parts (Component_Type (Subtyp));\n+                     end loop;\n+                  end;\n                elsif Is_Record_Type (Subtyp) then\n                   if Has_Static_Discriminant_Constraint (Subtyp) then\n \n@@ -1274,7 +1456,7 @@ package body Sem_Case is\n             end Traverse_Discrete_Parts;\n \n          begin\n-            Traverse_Discrete_Parts (Etype (Expression (Case_Statement)));\n+            Traverse_Discrete_Parts (Case_Expr_Type);\n             pragma Assert (Done or else Serious_Errors_Detected > 0);\n             return Result;\n          end Component_Bounds_Info;\n@@ -1531,6 +1713,19 @@ package body Sem_Case is\n                            & \"choice not implemented\", Expr);\n                      end if;\n \n+                     if not Unconstrained_Array_Case\n+                        and then List_Length (Expressions (Expr))\n+                           /= Nat (Part_Id'Last)\n+                     then\n+                        Error_Msg_N\n+                          (\"Array aggregate length\"\n+                            & List_Length (Expressions (Expr))'Image\n+                            & \" does not match length of\"\n+                            & \" statically constrained case selector\"\n+                            & Part_Id'Last'Image, Expr);\n+                        return;\n+                     end if;\n+\n                      declare\n                         Subexpr : Node_Id := First (Expressions (Expr));\n                      begin\n@@ -1542,9 +1737,50 @@ package body Sem_Case is\n                   else\n                      raise Program_Error;\n                   end if;\n+               elsif Nkind (Expr) = N_String_Literal then\n+                  if not Is_Array_Type (Etype (Expr)) then\n+                     Error_Msg_N\n+                       (\"User-defined string literal not allowed as/within\"\n+                        & \"case choice\", Expr);\n+                  else\n+                     declare\n+                        Char_Type : constant Entity_Id :=\n+                          Root_Type (Component_Type (Etype (Expr)));\n+\n+                        --  If the component type is not a standard character\n+                        --  type then this string lit should have already been\n+                        --  transformed into an aggregate in\n+                        --  Resolve_String_Literal.\n+                        --\n+                        pragma Assert (Is_Standard_Character_Type (Char_Type));\n+\n+                        Str      : constant String_Id := Strval (Expr);\n+                        Strlen   : constant Nat       := String_Length (Str);\n+                        Char_Val : Uint;\n+                     begin\n+                        if not Unconstrained_Array_Case\n+                           and then Strlen /= Nat (Part_Id'Last)\n+                        then\n+                           Error_Msg_N\n+                             (\"String literal length\"\n+                              & Strlen'Image\n+                              & \" does not match length of\"\n+                              & \" statically constrained case selector\"\n+                              & Part_Id'Last'Image, Expr);\n+                           return;\n+                        end if;\n+\n+                        for Idx in 1 .. Strlen loop\n+                           Char_Val :=\n+                             UI_From_CC (Get_String_Char (Str, Idx));\n+                           Update_Result ((Low | High => Char_Val));\n+                        end loop;\n+                     end;\n+                  end if;\n                elsif Is_Discrete_Type (Etype (Expr)) then\n-                  if Nkind (Expr) in N_Has_Entity and then\n-                    Is_Type (Entity (Expr))\n+                  if Nkind (Expr) in N_Has_Entity\n+                    and then Present (Entity (Expr))\n+                    and then Is_Type (Entity (Expr))\n                   then\n                      declare\n                         Low  : constant Node_Id :=\n@@ -1559,10 +1795,20 @@ package body Sem_Case is\n                      pragma Assert (Compile_Time_Known_Value (Expr));\n                      Update_Result ((Low | High => Expr_Value (Expr)));\n                   end if;\n+               elsif Nkind (Expr) in N_Has_Entity\n+                 and then Present (Entity (Expr))\n+                 and then Ekind (Entity (Expr)) = E_Constant\n+               then\n+                  Traverse_Choice (Expression (Parent (Entity (Expr))));\n+               elsif Nkind (Original_Node (Expr))\n+                       in N_Aggregate | N_String_Literal\n+               then\n+                  Traverse_Choice (Original_Node (Expr));\n                else\n                   Error_Msg_N\n-                    (\"non-aggregate case choice subexpression which is not\"\n-                     & \" of a discrete type not implemented\", Expr);\n+                    (\"non-aggregate case choice (or subexpression thereof)\"\n+                     & \" that is not of a discrete type not implemented\",\n+                     Expr);\n                end if;\n             end Traverse_Choice;\n \n@@ -1572,8 +1818,26 @@ package body Sem_Case is\n             if Nkind (Choice) = N_Others_Choice then\n                return (Is_Others => True);\n             end if;\n+\n+            if Unconstrained_Array_Case then\n+               --  Treat length like a discriminant\n+               Update_Result ((Low | High =>\n+                                 UI_From_Int (Array_Choice_Length (Choice))));\n+            end if;\n+\n             Traverse_Choice (Choice);\n \n+            if Unconstrained_Array_Case then\n+               --  This is somewhat tricky. Suppose we are casing on String,\n+               --  the longest choice in the case statement is length 10, and\n+               --  the choice we are looking at now is of length 6. We fill\n+               --  in the trailing 4 slots here.\n+               while Next_Part <= Part_Id'Last loop\n+                  Update_Result_For_Full_Coverage\n+                    (Comp_Type => Component_Type (Case_Expr_Type));\n+               end loop;\n+            end if;\n+\n             --  Avoid returning uninitialized garbage in error case\n             if Next_Part /= Part_Id'Last + 1 then\n                pragma Assert (Serious_Errors_Detected > 0);\n@@ -2098,6 +2362,12 @@ package body Sem_Case is\n                   Result := Result * Value_Index_Base (Uint_Sets.Size (Set));\n                end loop;\n                return Result;\n+            exception\n+               when Constraint_Error =>\n+                  Error_Msg_N\n+                    (\"Capacity exceeded in compiling case statement with\"\n+                      & \" composite selector type\", Case_Statement);\n+                  raise;\n             end Value_Index_Count;\n \n             Max_Value_Index : constant Value_Index_Base := Value_Index_Count;\n@@ -3014,12 +3284,20 @@ package body Sem_Case is\n                         \"an enumeration representation clause\", N);\n                   end if;\n                elsif Is_Array_Type (Subtyp) then\n-                  pragma Assert (Is_Constrained (Subtyp));\n-\n                   if Number_Dimensions (Subtyp) /= 1 then\n                      Error_Msg_N\n                        (\"dimensionality of array type of case selector (or \" &\n                         \"subcomponent thereof) is greater than 1\", N);\n+\n+                  elsif not Is_Constrained (Subtyp) then\n+                     if not Is_Static_Subtype\n+                              (Etype (First_Index (Subtyp)))\n+                     then\n+                        Error_Msg_N\n+                          (\"Unconstrained array subtype of case selector\" &\n+                           \" has nonstatic index subtype\", N);\n+                     end if;\n+\n                   elsif not Is_OK_Static_Range (First_Index (Subtyp)) then\n                      Error_Msg_N\n                        (\"array subtype of case selector (or \" &\n@@ -3077,10 +3355,6 @@ package body Sem_Case is\n             elsif Needs_Finalization (Subtyp) then\n                Error_Msg_N (\"case selector type requires finalization\", N);\n \n-            elsif Is_Array_Type (Subtyp) and not Is_Constrained (Subtyp) then\n-               Error_Msg_N\n-                 (\"case selector subtype is unconstrained array subtype\", N);\n-\n             else\n                Check_Component_Subtype (Subtyp);\n             end if;"}]}