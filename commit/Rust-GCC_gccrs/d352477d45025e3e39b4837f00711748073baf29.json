{"sha": "d352477d45025e3e39b4837f00711748073baf29", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDM1MjQ3N2Q0NTAyNWUzZTM5YjQ4MzdmMDA3MTE3NDgwNzNiYWYyOQ==", "commit": {"author": {"name": "Mark Wielaard", "email": "mark@klomp.org", "date": "2001-10-02T22:49:59Z"}, "committer": {"name": "Mark Wielaard", "email": "mark@gcc.gnu.org", "date": "2001-10-02T22:49:59Z"}, "message": "Makefile.am (core_java_source_files): add InheritableThreadLocal\n\n\t* Makefile.am (core_java_source_files): add InheritableThreadLocal\n\t* Makefile.in: regenerate\n\t* gcj/javaprims.h: ditto\n\t* java/lang/InheritableThreadLocal.java: new class from Classpath\n\t* java/lang/Thread.java Thread (Thread, ThreadGroup, Runnable, String):\n\tcall InheritableThreadLocal.newChildThread()\n\nFrom-SVN: r45979", "tree": {"sha": "aeaeb369f3dc7b1214392be4abcc073d0adb6358", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/aeaeb369f3dc7b1214392be4abcc073d0adb6358"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d352477d45025e3e39b4837f00711748073baf29", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d352477d45025e3e39b4837f00711748073baf29", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d352477d45025e3e39b4837f00711748073baf29", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d352477d45025e3e39b4837f00711748073baf29/comments", "author": null, "committer": null, "parents": [{"sha": "a2566f60d2a35cf237a62d77d521d3108ad36b2d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a2566f60d2a35cf237a62d77d521d3108ad36b2d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a2566f60d2a35cf237a62d77d521d3108ad36b2d"}], "stats": {"total": 181, "additions": 181, "deletions": 0}, "files": [{"sha": "84a61c2dca92915dbd29896aba9b6d162870e8c3", "filename": "libjava/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d352477d45025e3e39b4837f00711748073baf29/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d352477d45025e3e39b4837f00711748073baf29/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=d352477d45025e3e39b4837f00711748073baf29", "patch": "@@ -1,3 +1,12 @@\n+2001-10-02  Mark Wielaard  <mark@klomp.org>\n+\n+\t* Makefile.am (core_java_source_files): add InheritableThreadLocal\n+\t* Makefile.in: regenerate\n+\t* gcj/javaprims.h: ditto\n+\t* java/lang/InheritableThreadLocal.java: new class from Classpath\n+\t* java/lang/Thread.java Thread (Thread, ThreadGroup, Runnable, String):\n+\tcall InheritableThreadLocal.newChildThread()\n+\n 2001-10-01  Mark Wielaard  <mark@klomp.org>\n \n \t* Makefile.am: Add new classes"}, {"sha": "91d437fed9db4df71e3ead6cfabf9db42c883083", "filename": "libjava/Makefile.am", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d352477d45025e3e39b4837f00711748073baf29/libjava%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d352477d45025e3e39b4837f00711748073baf29/libjava%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.am?ref=d352477d45025e3e39b4837f00711748073baf29", "patch": "@@ -937,6 +937,7 @@ java/lang/IllegalStateException.java \\\n java/lang/IllegalThreadStateException.java \\\n java/lang/IncompatibleClassChangeError.java \\\n java/lang/IndexOutOfBoundsException.java \\\n+java/lang/InheritableThreadLocal.java \\\n java/lang/InstantiationError.java \\\n java/lang/InstantiationException.java \\\n java/lang/Integer.java \\"}, {"sha": "1c605a20e49a1b9667c111fa2d14db27842199d9", "filename": "libjava/Makefile.in", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d352477d45025e3e39b4837f00711748073baf29/libjava%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d352477d45025e3e39b4837f00711748073baf29/libjava%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.in?ref=d352477d45025e3e39b4837f00711748073baf29", "patch": "@@ -668,6 +668,7 @@ java/lang/IllegalStateException.java \\\n java/lang/IllegalThreadStateException.java \\\n java/lang/IncompatibleClassChangeError.java \\\n java/lang/IndexOutOfBoundsException.java \\\n+java/lang/InheritableThreadLocal.java \\\n java/lang/InstantiationError.java \\\n java/lang/InstantiationException.java \\\n java/lang/Integer.java \\\n@@ -1793,6 +1794,7 @@ DEP_FILES =  .deps/$(srcdir)/$(CONVERT_DIR)/gen-from-JIS.P \\\n .deps/java/lang/IllegalThreadStateException.P \\\n .deps/java/lang/IncompatibleClassChangeError.P \\\n .deps/java/lang/IndexOutOfBoundsException.P \\\n+.deps/java/lang/InheritableThreadLocal.P \\\n .deps/java/lang/InstantiationError.P \\\n .deps/java/lang/InstantiationException.P .deps/java/lang/Integer.P \\\n .deps/java/lang/InternalError.P .deps/java/lang/InterruptedException.P \\"}, {"sha": "f9cac09f5f25948e613b3e7e59558d0ae5d50ff5", "filename": "libjava/gcj/javaprims.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d352477d45025e3e39b4837f00711748073baf29/libjava%2Fgcj%2Fjavaprims.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d352477d45025e3e39b4837f00711748073baf29/libjava%2Fgcj%2Fjavaprims.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgcj%2Fjavaprims.h?ref=d352477d45025e3e39b4837f00711748073baf29", "patch": "@@ -162,6 +162,7 @@ extern \"Java\"\n       class IllegalThreadStateException;\n       class IncompatibleClassChangeError;\n       class IndexOutOfBoundsException;\n+      class InheritableThreadLocal;\n       class InstantiationError;\n       class InstantiationException;\n       class Integer;"}, {"sha": "32102a66bafddb0747f1bcd024e114622572753f", "filename": "libjava/java/lang/InheritableThreadLocal.java", "status": "added", "additions": 167, "deletions": 0, "changes": 167, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d352477d45025e3e39b4837f00711748073baf29/libjava%2Fjava%2Flang%2FInheritableThreadLocal.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d352477d45025e3e39b4837f00711748073baf29/libjava%2Fjava%2Flang%2FInheritableThreadLocal.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FInheritableThreadLocal.java?ref=d352477d45025e3e39b4837f00711748073baf29", "patch": "@@ -0,0 +1,167 @@\n+/* java.lang.InheritableThreadLocal\n+   Copyright (C) 2000, 2001 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+package java.lang;\n+\n+import java.util.Iterator;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.WeakHashMap;\n+\n+/**\n+ * ThreadLocal whose value is inherited by child Threads.\n+ * The value of the InheritableThreadLocal associated with the (parent) Thread\n+ * on the moment that it creates a new (child) Thread is set as the value that\n+ * is associated with the new (child) Thread.\n+ * <p>\n+ * It is possible to make the value associated with the child Thread a function\n+ * of the value that is associated with the parent Thread by overriding the\n+ * <code>childValue()</code> method.\n+ *\n+ * @since 1.2\n+ * @author Mark Wielaard (mark@klomp.org)\n+ */\n+public class InheritableThreadLocal extends ThreadLocal {\n+\t\n+\t/**\n+\t * Maps Threads to a Set of InheritableThreadLocals\n+\t * (the heritage of that Thread).\n+\t * Uses a WeakHashMap so if the Thread is garbage collected the reference\n+\t * to that Set disappears.\n+\t * Both <code>AddToHeritage</code> access and modify it so they have to\n+\t * synchronize on the threadMap when they do.\n+\t */\n+\tprivate static Map threadMap = new WeakHashMap();\n+\t\n+\t/**\n+\t * Creates a new InheritableThreadLocal that has no values associated\n+\t * with it yet.\n+\t */\n+\tpublic InheritableThreadLocal() {\n+\t\tsuper();\n+\t}\n+\t\n+\t/**\n+\t * Determines the value associated with a newly created child Thread\n+\t * as a function of the value associated with the currently executing\n+\t * (parent) Thread.\n+\t * <p>\n+\t * The default implementation just returns the parentValue.\n+\t */\n+\tprotected Object childValue(Object parentValue) {\n+\t\treturn parentValue;\n+\t}\n+\t\n+\t/**\n+\t * Adds this <code>InheritableThreadLocal</code> to the heritage of the\n+\t * current Thread and returns the value of the <code>ThreadLocal</code>\n+\t * for the Thread. The value will be either the last value that the\n+\t * current Thread has set, or the childValue of the last value that the\n+\t * parent Thread set before the current Thread was created, or the\n+\t * initialValue of the <code>ThreadLocal</code>.\n+\t *\n+\t * @see ThreadLocal#get()\n+\t */\n+\tpublic Object get() {\n+\t\taddToHeritage(); \n+\t\treturn super.get();\n+\t}\n+\t\n+\t/**\n+\t * Adds this <code>InheritableThreadLocal</code> to the heritage of the\n+\t * current Thread and sets the value of the <code>ThreadLocal</code>\n+\t * for the Thread.\n+\t *\n+\t * @see ThreadLocal#set(Object)\n+\t */\n+\tpublic void set(Object value) {\n+\t\taddToHeritage();\n+\t\tsuper.set(value);\n+\t}\n+\t\n+\t/**\n+\t * Adds this <code>InheritableThreadLocal</code> to the heritage\n+\t * of the current Thread.\n+\t */\n+\tprivate void addToHeritage() {\n+\t\tThread currentThread = Thread.currentThread();\n+\t\tSet heritage;\n+\t\tsynchronized(threadMap) {\n+\t\t\theritage = (Set)threadMap.get(currentThread);\n+\t\t}\n+\t\t// Note that we don't have to synchronize on the heritage Set\n+\t\t// since only this Thread (or the parent Thread when creating\n+\t\t// the heritage) ever modifies it.\n+\t\tif (heritage == null) {\n+\t\t\theritage = new HashSet();\n+\t\t\tsynchronized(threadMap) {\n+\t\t\t\tthreadMap.put(currentThread, heritage);\n+\t\t\t}\n+\t\t}\n+\t\tif (!heritage.contains(this)) {\n+\t\t\theritage.add(this);\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Generates the childValues of all <code>InheritableThreadLocal</code>s\n+\t * that are in the heritage of the current Thread for the newly created\n+\t * childThread.\n+\t * Should be called from the contructor of java.lang.Thread.\n+\t */\n+\tstatic void newChildThread(Thread childThread) {\n+\t\t// The currentThread is the parent of the new thread\n+\t\tThread parentThread = Thread.currentThread();\n+\t\t\n+\t\t// Inherit all the InheritableThreadLocals of the parent thread\n+\t\tSet heritage;\n+\t\tsynchronized(threadMap) {\n+\t\t\theritage = (Set)threadMap.get(parentThread);\n+\t\t}\n+\t\t// Note that we don't have to synchronize on the heritage Set\n+\t\t// since only this Thread (or the parent Thread when creating\n+\t\t// the heritage) ever modifies it.\n+\t\tif (heritage != null) {\n+\t\t\tsynchronized(threadMap) {\n+\t\t\t\tthreadMap.put(childThread, new HashSet(heritage));\n+\t\t\t}\n+\t\t\t// And constructs all the new child values\n+\t\t\t// (has to be done now that we are executing in the parentThread)\n+\t\t\tIterator it = heritage.iterator();\n+\t\t\twhile (it.hasNext()) {\n+\t\t\t\tInheritableThreadLocal local =\n+\t\t\t\t\t(InheritableThreadLocal) it.next();\n+\t\t\t\t// Note that the parentValue cannot be null\n+\t\t\t\t// If it was it would not be in the heritage\n+\t\t\t\tObject parentValue = local.get(parentThread).getValue();\n+\t\t\t\tObject childValue = local.childValue(parentValue);\n+\t\t\t\tThreadLocal.Value v = new ThreadLocal.Value(childValue);\n+\t\t\t\tlocal.set(childThread, v);\n+\t\t\t}\n+\t\t}\n+\t}\n+}"}, {"sha": "542f47192fda4c3e95e383f364795056c7091fa1", "filename": "libjava/java/lang/Thread.java", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d352477d45025e3e39b4837f00711748073baf29/libjava%2Fjava%2Flang%2FThread.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d352477d45025e3e39b4837f00711748073baf29/libjava%2Fjava%2Flang%2FThread.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FThread.java?ref=d352477d45025e3e39b4837f00711748073baf29", "patch": "@@ -247,6 +247,7 @@ private Thread (Thread current, ThreadGroup g, Runnable r, String n)\n \tint pri = current.getPriority();\n \tpriority = (gmax < pri ? gmax : pri);\n \tcontext_class_loader = current.context_class_loader;\n+\tInheritableThreadLocal.newChildThread(this);\n       }\n     else\n       {"}]}