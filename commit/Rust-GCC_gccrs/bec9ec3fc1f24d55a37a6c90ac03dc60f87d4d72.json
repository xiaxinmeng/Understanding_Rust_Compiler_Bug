{"sha": "bec9ec3fc1f24d55a37a6c90ac03dc60f87d4d72", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmVjOWVjM2ZjMWYyNGQ1NWEzN2E2YzkwYWMwM2RjNjBmODdkNGQ3Mg==", "commit": {"author": {"name": "Torvald Riegel", "email": "triegel@redhat.com", "date": "2013-08-30T10:33:41Z"}, "committer": {"name": "Torvald Riegel", "email": "torvald@gcc.gnu.org", "date": "2013-08-30T10:33:41Z"}, "message": "Add custom HTM fast path for RTM on x86_64.\n\n\t* libitm_i.h (gtm_thread): Assign an asm name to serial_lock.\n\t(htm_fastpath): Assign an asm name.\n\t* libitm.h (_ITM_codeProperties): Add non-ABI flags used by custom\n\tHTM fast paths.\n\t(_ITM_actions): Likewise.\n\t* config/x86/target.h (HTM_CUSTOM_FASTPATH): Enable custom fastpath on\n\tx86_64.\n\t* config/x86/sjlj.S (_ITM_beginTransaction): Add custom HTM fast path.\n\t* config/posix/rwlock.h (gtm_rwlock): Update comments.  Move summary\n\tfield to the start of the structure.\n\t* config/linux/rwlock.h (gtm_rwlock): Update comments.\n\t* beginend.cc (gtm_thread::begin_transaction): Add retry policy\n\thandling for custom HTM fast paths.\n\nFrom-SVN: r202101", "tree": {"sha": "c0b7c9260feea5365646627e5ddc4df6b74877de", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c0b7c9260feea5365646627e5ddc4df6b74877de"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bec9ec3fc1f24d55a37a6c90ac03dc60f87d4d72", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bec9ec3fc1f24d55a37a6c90ac03dc60f87d4d72", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bec9ec3fc1f24d55a37a6c90ac03dc60f87d4d72", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bec9ec3fc1f24d55a37a6c90ac03dc60f87d4d72/comments", "author": {"login": "triegelrh", "id": 62400967, "node_id": "MDQ6VXNlcjYyNDAwOTY3", "avatar_url": "https://avatars.githubusercontent.com/u/62400967?v=4", "gravatar_id": "", "url": "https://api.github.com/users/triegelrh", "html_url": "https://github.com/triegelrh", "followers_url": "https://api.github.com/users/triegelrh/followers", "following_url": "https://api.github.com/users/triegelrh/following{/other_user}", "gists_url": "https://api.github.com/users/triegelrh/gists{/gist_id}", "starred_url": "https://api.github.com/users/triegelrh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/triegelrh/subscriptions", "organizations_url": "https://api.github.com/users/triegelrh/orgs", "repos_url": "https://api.github.com/users/triegelrh/repos", "events_url": "https://api.github.com/users/triegelrh/events{/privacy}", "received_events_url": "https://api.github.com/users/triegelrh/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8595a07d8d161b4c612101171f3ad423689ec020", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8595a07d8d161b4c612101171f3ad423689ec020", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8595a07d8d161b4c612101171f3ad423689ec020"}], "stats": {"total": 229, "additions": 198, "deletions": 31}, "files": [{"sha": "351b779e23fc1dad23d73e8b64999598047be566", "filename": "libitm/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bec9ec3fc1f24d55a37a6c90ac03dc60f87d4d72/libitm%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bec9ec3fc1f24d55a37a6c90ac03dc60f87d4d72/libitm%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2FChangeLog?ref=bec9ec3fc1f24d55a37a6c90ac03dc60f87d4d72", "patch": "@@ -1,3 +1,19 @@\n+2013-08-30  Torvald Riegel  <triegel@redhat.com>\n+\n+\t* libitm_i.h (gtm_thread): Assign an asm name to serial_lock.\n+\t(htm_fastpath): Assign an asm name.\n+\t* libitm.h (_ITM_codeProperties): Add non-ABI flags used by custom\n+\tHTM fast paths.\n+\t(_ITM_actions): Likewise.\n+\t* config/x86/target.h (HTM_CUSTOM_FASTPATH): Enable custom fastpath on\n+\tx86_64.\n+\t* config/x86/sjlj.S (_ITM_beginTransaction): Add custom HTM fast path.\n+\t* config/posix/rwlock.h (gtm_rwlock): Update comments.  Move summary\n+\tfield to the start of the structure.\n+\t* config/linux/rwlock.h (gtm_rwlock): Update comments.\n+\t* beginend.cc (gtm_thread::begin_transaction): Add retry policy\n+\thandling for custom HTM fast paths.\n+\n 2013-08-14  Andreas Krebbel  <Andreas.Krebbel@de.ibm.com>\n \tRevert:\n \t2013-08-02  Andreas Krebbel  <Andreas.Krebbel@de.ibm.com>"}, {"sha": "bd7b19ec844f3a30720c5eaac367aa5acd9b819c", "filename": "libitm/beginend.cc", "status": "modified", "additions": 45, "deletions": 1, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bec9ec3fc1f24d55a37a6c90ac03dc60f87d4d72/libitm%2Fbeginend.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bec9ec3fc1f24d55a37a6c90ac03dc60f87d4d72/libitm%2Fbeginend.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Fbeginend.cc?ref=bec9ec3fc1f24d55a37a6c90ac03dc60f87d4d72", "patch": "@@ -165,7 +165,7 @@ GTM::gtm_thread::begin_transaction (uint32_t prop, const gtm_jmpbuf *jb)\n   if (unlikely(prop & pr_undoLogCode))\n     GTM_fatal(\"pr_undoLogCode not supported\");\n \n-#if defined(USE_HTM_FASTPATH) && !defined(HTM_CUSTOM_FASTPATH)\n+#ifdef USE_HTM_FASTPATH\n   // HTM fastpath.  Only chosen in the absence of transaction_cancel to allow\n   // using an uninstrumented code path.\n   // The fastpath is enabled only by dispatch_htm's method group, which uses\n@@ -187,6 +187,7 @@ GTM::gtm_thread::begin_transaction (uint32_t prop, const gtm_jmpbuf *jb)\n   // indeed in serial mode, and HW transactions should never need serial mode\n   // for any internal changes (e.g., they never abort visibly to the STM code\n   // and thus do not trigger the standard retry handling).\n+#ifndef HTM_CUSTOM_FASTPATH\n   if (likely(htm_fastpath && (prop & pr_hasNoAbort)))\n     {\n       for (uint32_t t = htm_fastpath; t; t--)\n@@ -237,6 +238,49 @@ GTM::gtm_thread::begin_transaction (uint32_t prop, const gtm_jmpbuf *jb)\n \t    }\n \t}\n     }\n+#else\n+  // If we have a custom HTM fastpath in ITM_beginTransaction, we implement\n+  // just the retry policy here.  We communicate with the custom fastpath\n+  // through additional property bits and return codes, and either transfer\n+  // control back to the custom fastpath or run the fallback mechanism.  The\n+  // fastpath synchronization algorithm itself is the same.\n+  // pr_HTMRetryableAbort states that a HW transaction started by the custom\n+  // HTM fastpath aborted, and that we thus have to decide whether to retry\n+  // the fastpath (returning a_tryHTMFastPath) or just proceed with the\n+  // fallback method.\n+  if (likely(htm_fastpath && (prop & pr_HTMRetryableAbort)))\n+    {\n+      tx = gtm_thr();\n+      if (unlikely(tx == NULL))\n+        {\n+          // See below.\n+          tx = new gtm_thread();\n+          set_gtm_thr(tx);\n+        }\n+      // If this is the first abort, reset the retry count.  We abuse\n+      // restart_total for the retry count, which is fine because our only\n+      // other fallback will use serial transactions, which don't use\n+      // restart_total but will reset it when committing.\n+      if (!(prop & pr_HTMRetriedAfterAbort))\n+\ttx->restart_total = htm_fastpath;\n+\n+      if (--tx->restart_total > 0)\n+\t{\n+\t  // Wait until any concurrent serial-mode transactions have finished.\n+\t  // Essentially the same code as above.\n+\t  if (serial_lock.is_write_locked())\n+\t    {\n+\t      if (tx->nesting > 0)\n+\t\tgoto stop_custom_htm_fastpath;\n+\t      serial_lock.read_lock(tx);\n+\t      serial_lock.read_unlock(tx);\n+\t    }\n+\t  // Let ITM_beginTransaction retry the custom HTM fastpath.\n+\t  return a_tryHTMFastPath;\n+\t}\n+    }\n+ stop_custom_htm_fastpath:\n+#endif\n #endif\n \n   tx = gtm_thr();"}, {"sha": "c761edf0c9c58c86a8d620deb9aa9d3054c36c7b", "filename": "libitm/config/linux/rwlock.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bec9ec3fc1f24d55a37a6c90ac03dc60f87d4d72/libitm%2Fconfig%2Flinux%2Frwlock.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bec9ec3fc1f24d55a37a6c90ac03dc60f87d4d72/libitm%2Fconfig%2Flinux%2Frwlock.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Fconfig%2Flinux%2Frwlock.h?ref=bec9ec3fc1f24d55a37a6c90ac03dc60f87d4d72", "patch": "@@ -39,6 +39,11 @@ struct gtm_thread;\n //\n // In this implementation, writers are given highest priority access but\n // read-to-write upgrades do not have a higher priority than writers.\n+//\n+// Do not change the layout of this class; it must remain a POD type with\n+// standard layout, and the WRITERS field must be first (i.e., so the\n+// assembler code can assume that its address is equal to the address of the\n+// respective instance of the class).\n \n class gtm_rwlock\n {"}, {"sha": "b2fd517b642fe849eacc53e1696e235030e51888", "filename": "libitm/config/posix/rwlock.h", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bec9ec3fc1f24d55a37a6c90ac03dc60f87d4d72/libitm%2Fconfig%2Fposix%2Frwlock.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bec9ec3fc1f24d55a37a6c90ac03dc60f87d4d72/libitm%2Fconfig%2Fposix%2Frwlock.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Fconfig%2Fposix%2Frwlock.h?ref=bec9ec3fc1f24d55a37a6c90ac03dc60f87d4d72", "patch": "@@ -44,19 +44,25 @@ struct gtm_thread;\n //\n // In this implementation, writers are given highest priority access but\n // read-to-write upgrades do not have a higher priority than writers.\n+//\n+// Do not change the layout of this class; it must remain a POD type with\n+// standard layout, and the SUMMARY field must be first (i.e., so the\n+// assembler code can assume that its address is equal to the address of the\n+// respective instance of the class).\n \n class gtm_rwlock\n {\n-  pthread_mutex_t mutex;\t        // Held if manipulating any field.\n-  pthread_cond_t c_readers;\t        // Readers wait here\n-  pthread_cond_t c_writers;\t        // Writers wait here for writers\n-  pthread_cond_t c_confirmed_writers;\t// Writers wait here for readers\n-\n   static const unsigned a_writer  = 1;\t// An active writer.\n   static const unsigned w_writer  = 2;\t// The w_writers field != 0\n   static const unsigned w_reader  = 4;  // The w_readers field != 0\n \n   std::atomic<unsigned int> summary;\t// Bitmask of the above.\n+\n+  pthread_mutex_t mutex;\t        // Held if manipulating any field.\n+  pthread_cond_t c_readers;\t        // Readers wait here\n+  pthread_cond_t c_writers;\t        // Writers wait here for writers\n+  pthread_cond_t c_confirmed_writers;\t// Writers wait here for readers\n+\n   unsigned int a_readers;\t// Nr active readers as observed by a writer\n   unsigned int w_readers;\t// Nr waiting readers\n   unsigned int w_writers;\t// Nr waiting writers"}, {"sha": "437551bcd69679aca9b93a6c25de1b9aa9f6f357", "filename": "libitm/config/x86/sjlj.S", "status": "modified", "additions": 89, "deletions": 12, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bec9ec3fc1f24d55a37a6c90ac03dc60f87d4d72/libitm%2Fconfig%2Fx86%2Fsjlj.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bec9ec3fc1f24d55a37a6c90ac03dc60f87d4d72/libitm%2Fconfig%2Fx86%2Fsjlj.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Fconfig%2Fx86%2Fsjlj.S?ref=bec9ec3fc1f24d55a37a6c90ac03dc60f87d4d72", "patch": "@@ -24,6 +24,7 @@\n \n \n #include \"asmcfi.h\"\n+#include \"config.h\"\n \n #define CONCAT1(a, b) CONCAT2(a, b)\n #define CONCAT2(a, b) a ## b\n@@ -52,6 +53,19 @@\n #  endif\n #endif\n \n+/* These are duplicates of the canonical definitions in libitm.h.  Note that\n+   the code relies on pr_uninstrumentedCode == a_runUninstrumentedCode.  */\n+#define pr_uninstrumentedCode\t0x02\n+#define pr_hasNoAbort\t\t0x08\n+#define pr_HTMRetryableAbort\t0x800000\n+#define pr_HTMRetriedAfterAbort\t0x1000000\n+#define a_runInstrumentedCode\t0x01\n+#define a_runUninstrumentedCode\t0x02\n+#define a_tryHTMFastPath\t0x20\n+\n+#define _XABORT_EXPLICIT\t(1 << 0)\n+#define _XABORT_RETRY\t\t(1 << 1)\n+\n \t.text\n \n \t.align 4\n@@ -60,20 +74,83 @@\n SYM(_ITM_beginTransaction):\n \tcfi_startproc\n #ifdef __x86_64__\n+#ifdef HAVE_AS_RTM\n+\t/* Custom HTM fast path.  We start the HW transaction here and let\n+\t   gtm_thread::begin_transaction (aka GTM_begin_transaction) decide\n+\t   how to proceed on aborts: We either retry the fast path, or fall\n+\t   back to another execution method.  RTM restores all registers after\n+\t   a HW transaction abort, so we can do the SW setjmp after aborts,\n+\t   and we have to because we might choose a SW fall back.  However,\n+\t   we have to explicitly save/restore the first argument (edi).  */\n+\tcmpl\t$0, SYM(gtm_htm_fastpath)(%rip)\n+\tjz\t.Lno_htm\n+\ttestl\t$pr_hasNoAbort, %edi\n+\tjz\t.Lno_htm\n+.Lhtm_fastpath:\n+\txbegin\t.Ltxn_abort\n+\t/* Monitor the serial lock (specifically, the 32b writer/summary field\n+\t   at its start), and only continue if there is no serial-mode\n+\t   transaction.  Note that we might be just a nested transaction and\n+\t   our outermost transaction might be in serial mode; we check for\n+\t   this case in the retry policy implementation.  */\n+\tcmpl\t$0, SYM(gtm_serial_lock)(%rip)\n+\tjnz\t1f\n+\t/* Everything is good.  Run the transaction, preferably using the\n+\t   uninstrumented code path.  Note that the following works because\n+\t   pr_uninstrumentedCode == a_runUninstrumentedCode.  */\n+\tandl\t$pr_uninstrumentedCode, %edi\n+\tmov\t$a_runInstrumentedCode, %eax\n+\tcmovnz\t%edi, %eax\n+\tret\n+\t/* There is a serial-mode transaction, so abort (see htm_abort()\n+\t   regarding the abort code).  */\n+1:\txabort\t$0xff\n+.Ltxn_abort:\n+\t/* If it might make sense to retry the HTM fast path, let the C++\n+\t   code decide.  */\n+\ttestl\t$(_XABORT_RETRY|_XABORT_EXPLICIT), %eax\n+\tjz\t.Lno_htm\n+\torl\t$pr_HTMRetryableAbort, %edi\n+\t/* Let the C++ code handle the retry policy.  */\n+.Lno_htm:\n+#endif\n \tleaq\t8(%rsp), %rax\n-\tsubq\t$56, %rsp\n-\tcfi_def_cfa_offset(64)\n-\tmovq\t%rax, (%rsp)\n-\tmovq\t%rbx, 8(%rsp)\n-\tmovq\t%rbp, 16(%rsp)\n-\tmovq\t%r12, 24(%rsp)\n-\tmovq\t%r13, 32(%rsp)\n-\tmovq\t%r14, 40(%rsp)\n-\tmovq\t%r15, 48(%rsp)\n-\tmovq\t%rsp, %rsi\n+\tsubq\t$72, %rsp\n+\tcfi_adjust_cfa_offset(72)\n+\t/* Store edi for future HTM fast path retries.  We use a stack slot\n+\t   lower than the jmpbuf so that the jmpbuf's rip field will overlap\n+\t   with the proper return address on the stack.  */\n+\tmovl\t%edi, 8(%rsp)\n+\t/* Save the jmpbuf for any non-HTM-fastpath execution method.\n+\t   Because rsp-based addressing is 1 byte larger and we've got rax\n+\t   handy, use it.  */\n+\tmovq\t%rax, -64(%rax)\n+\tmovq\t%rbx, -56(%rax)\n+\tmovq\t%rbp, -48(%rax)\n+\tmovq\t%r12, -40(%rax)\n+\tmovq\t%r13, -32(%rax)\n+\tmovq\t%r14, -24(%rax)\n+\tmovq\t%r15, -16(%rax)\n+\tleaq\t-64(%rax), %rsi\n \tcall\tSYM(GTM_begin_transaction)\n-\taddq\t$56, %rsp\n-\tcfi_def_cfa_offset(8)\n+\tmovl\t8(%rsp), %edi\n+\taddq\t$72, %rsp\n+\tcfi_adjust_cfa_offset(-72)\n+#ifdef HAVE_AS_RTM\n+\t/* If a_tryHTMFastPath was returned, then we need to retry the\n+\t   fast path.  We also restore edi and set pr_HTMRetriedAfterAbort\n+\t   to state that we have retried the fast path already (it's harmless\n+\t   if this bit is set even if we don't retry the fast path because it\n+\t   is checked iff pr_HTMRetryableAbort is set).  We clear\n+\t   pr_HTMRetryableAbort because it applies to a previous HW\n+\t   transaction attempt.  */\n+\tcmpl\t$a_tryHTMFastPath, %eax\n+\tjnz\t2f\n+\tandl\t$(0xffffffff-pr_HTMRetryableAbort), %edi\n+\torl\t$pr_HTMRetriedAfterAbort, %edi\n+\tjmp\t.Lhtm_fastpath\n+2:\n+#endif\n #else\n \tleal\t4(%esp), %ecx\n \tmovl\t4(%esp), %eax"}, {"sha": "65efb31324ecb2a7d56ac8eb8e145a80622e3e55", "filename": "libitm/config/x86/target.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bec9ec3fc1f24d55a37a6c90ac03dc60f87d4d72/libitm%2Fconfig%2Fx86%2Ftarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bec9ec3fc1f24d55a37a6c90ac03dc60f87d4d72/libitm%2Fconfig%2Fx86%2Ftarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Fconfig%2Fx86%2Ftarget.h?ref=bec9ec3fc1f24d55a37a6c90ac03dc60f87d4d72", "patch": "@@ -70,6 +70,10 @@ cpu_relax (void)\n // See gtm_thread::begin_transaction for how these functions are used.\n #ifdef HAVE_AS_RTM\n #define USE_HTM_FASTPATH\n+#ifdef __x86_64__\n+// Use the custom fastpath in ITM_beginTransaction.\n+#define HTM_CUSTOM_FASTPATH\n+#endif\n \n static inline bool\n htm_available ()"}, {"sha": "4bee0a2577e2afe9b14d0449764ef47b26f96c9d", "filename": "libitm/libitm.h", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bec9ec3fc1f24d55a37a6c90ac03dc60f87d4d72/libitm%2Flibitm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bec9ec3fc1f24d55a37a6c90ac03dc60f87d4d72/libitm%2Flibitm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Flibitm.h?ref=bec9ec3fc1f24d55a37a6c90ac03dc60f87d4d72", "patch": "@@ -72,7 +72,9 @@ typedef enum\n     inIrrevocableTransaction\n } _ITM_howExecuting;\n \n-/* Values to describe properties of code, passed in to beginTransaction */\n+/* Values to describe properties of code, passed in to beginTransaction.\n+   Some of these constants are duplicated in some of the ITM_beginTransaction\n+   implementations, so update those too when applying any changes.  */\n typedef enum\n {\n    pr_instrumentedCode\t\t= 0x0001,\n@@ -95,17 +97,24 @@ typedef enum\n    pr_exceptionBlock\t\t= 0x1000,\n    pr_hasElse\t\t\t= 0x2000,\n    pr_readOnly\t\t\t= 0x4000,\n-   pr_hasNoSimpleReads\t\t= 0x400000\n+   pr_hasNoSimpleReads\t\t= 0x400000,\n+   /* These are not part of the ABI but used for custom HTM fast paths.  See\n+      ITM_beginTransaction and gtm_thread::begin_transaction.  */\n+   pr_HTMRetryableAbort\t\t= 0x800000,\n+   pr_HTMRetriedAfterAbort\t= 0x1000000\n } _ITM_codeProperties;\n \n-/* Result from startTransaction that describes what actions to take.  */\n+/* Result from startTransaction that describes what actions to take.\n+   Some of these constants are duplicated in some of the ITM_beginTransaction\n+   implementations, so update those too when applying any changes.  */\n typedef enum\n {\n    a_runInstrumentedCode       = 0x01,\n    a_runUninstrumentedCode     = 0x02,\n    a_saveLiveVariables         = 0x04,\n    a_restoreLiveVariables      = 0x08,\n    a_abortTransaction          = 0x10,\n+   a_tryHTMFastPath            = 0x20\n } _ITM_actions;\n \n typedef struct"}, {"sha": "e965caf839c6822431854a43837bf36cdb517f6c", "filename": "libitm/libitm_i.h", "status": "modified", "additions": 16, "deletions": 10, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bec9ec3fc1f24d55a37a6c90ac03dc60f87d4d72/libitm%2Flibitm_i.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bec9ec3fc1f24d55a37a6c90ac03dc60f87d4d72/libitm%2Flibitm_i.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Flibitm_i.h?ref=bec9ec3fc1f24d55a37a6c90ac03dc60f87d4d72", "patch": "@@ -87,6 +87,14 @@ enum gtm_restart_reason\n #include \"dispatch.h\"\n #include \"containers.h\"\n \n+#ifdef __USER_LABEL_PREFIX__\n+# define UPFX UPFX1(__USER_LABEL_PREFIX__)\n+# define UPFX1(t) UPFX2(t)\n+# define UPFX2(t) #t\n+#else\n+# define UPFX\n+#endif\n+\n namespace GTM HIDDEN {\n \n // This type is private to alloc.c, but needs to be defined so that\n@@ -230,6 +238,7 @@ struct gtm_thread\n   // be used for the next iteration of the transaction.\n   // Only restart_total is reset to zero when the transaction commits, the\n   // other counters are total values for all previously executed transactions.\n+  // restart_total is also used by the HTM fastpath in a different way.\n   uint32_t restart_reason[NUM_RESTARTS];\n   uint32_t restart_total;\n \n@@ -247,7 +256,9 @@ struct gtm_thread\n   // The lock that provides access to serial mode.  Non-serialized\n   // transactions acquire read locks; a serialized transaction aquires\n   // a write lock.\n-  static gtm_rwlock serial_lock;\n+  // Accessed from assembly language, thus the \"asm\" specifier on\n+  // the name, avoiding complex name mangling.\n+  static gtm_rwlock serial_lock __asm__(UPFX \"gtm_serial_lock\");\n \n   // The head of the list of all threads' transactions.\n   static gtm_thread *list_of_threads;\n@@ -277,15 +288,8 @@ struct gtm_thread\n \n   // Invoked from assembly language, thus the \"asm\" specifier on\n   // the name, avoiding complex name mangling.\n-#ifdef __USER_LABEL_PREFIX__\n-#define UPFX1(t) UPFX(t)\n-#define UPFX(t) #t\n-  static uint32_t begin_transaction(uint32_t, const gtm_jmpbuf *)\n-\t__asm__(UPFX1(__USER_LABEL_PREFIX__) \"GTM_begin_transaction\") ITM_REGPARM;\n-#else\n   static uint32_t begin_transaction(uint32_t, const gtm_jmpbuf *)\n-\t__asm__(\"GTM_begin_transaction\") ITM_REGPARM;\n-#endif\n+\t__asm__(UPFX \"GTM_begin_transaction\") ITM_REGPARM;\n   // In eh_cpp.cc\n   void revert_cpp_exceptions (gtm_transaction_cp *cp = 0);\n \n@@ -338,7 +342,9 @@ extern gtm_cacheline_mask gtm_mask_stack(gtm_cacheline *, gtm_cacheline_mask);\n \n // Control variable for the HTM fastpath that uses serial mode as fallback.\n // Non-zero if the HTM fastpath is enabled. See gtm_thread::begin_transaction.\n-extern uint32_t htm_fastpath;\n+// Accessed from assembly language, thus the \"asm\" specifier on\n+// the name, avoiding complex name mangling.\n+extern uint32_t htm_fastpath __asm__(UPFX \"gtm_htm_fastpath\");\n \n } // namespace GTM\n "}]}