{"sha": "d4b71b95fe4842753bc3b695862d2dc160ff2313", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDRiNzFiOTVmZTQ4NDI3NTNiYzNiNjk1ODYyZDJkYzE2MGZmMjMxMw==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2015-08-03T13:28:46Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2015-08-03T13:28:46Z"}, "message": "genmatch.c (simplify::for_subst_vec): New member.\n\n2015-08-03  Richard Biener  <rguenther@suse.de>\n\n\t* genmatch.c (simplify::for_subst_vec): New member.\n\t(binary_ok): New helper for for lowering.\n\t(lower_for): Delay substituting operators into result expressions\n\tif we can merge the results eventually again.\n\t(capture_info::walk_result): Adjust for user_id appearing as\n\tresult expression operator.\n\t(expr::gen_transform): Likewise.\n\t(dt_simplify::gen_1): Likewise.\n\t(dt_simplify::gen): Pass not substituted operators to tail\n\tfunctions or initialize local variable with it.\n\t(decision_tree::gen): Adjust function signature.\n\t* match.pd: Fix tests against global code and add default\n\tcases to switch stmts.\n\nFrom-SVN: r226504", "tree": {"sha": "b0cc92d24bb9bd7cc191e1350e787968d64b9921", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b0cc92d24bb9bd7cc191e1350e787968d64b9921"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d4b71b95fe4842753bc3b695862d2dc160ff2313", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d4b71b95fe4842753bc3b695862d2dc160ff2313", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d4b71b95fe4842753bc3b695862d2dc160ff2313", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d4b71b95fe4842753bc3b695862d2dc160ff2313/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1d2fdec6bc1fe203e9df6f5e5edf69f50af0b35d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1d2fdec6bc1fe203e9df6f5e5edf69f50af0b35d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1d2fdec6bc1fe203e9df6f5e5edf69f50af0b35d"}], "stats": {"total": 229, "additions": 190, "deletions": 39}, "files": [{"sha": "ba7d89d2ca8c8cde8267da2cf0ae8e4d1a609aa4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4b71b95fe4842753bc3b695862d2dc160ff2313/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4b71b95fe4842753bc3b695862d2dc160ff2313/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d4b71b95fe4842753bc3b695862d2dc160ff2313", "patch": "@@ -1,3 +1,19 @@\n+2015-08-03  Richard Biener  <rguenther@suse.de>\n+\n+\t* genmatch.c (simplify::for_subst_vec): New member.\n+\t(binary_ok): New helper for for lowering.\n+\t(lower_for): Delay substituting operators into result expressions\n+\tif we can merge the results eventually again.\n+\t(capture_info::walk_result): Adjust for user_id appearing as\n+\tresult expression operator.\n+\t(expr::gen_transform): Likewise.\n+\t(dt_simplify::gen_1): Likewise.\n+\t(dt_simplify::gen): Pass not substituted operators to tail\n+\tfunctions or initialize local variable with it.\n+\t(decision_tree::gen): Adjust function signature.\n+\t* match.pd: Fix tests against global code and add default\n+\tcases to switch stmts.\n+\n 2015-08-03  Richard Biener  <rguenther@suse.de>\n \n \t* genmatch.c (dt_simplify::gen): Create captures array"}, {"sha": "15d257b9653ae533c687dee0ca8521fbea360d1c", "filename": "gcc/genmatch.c", "status": "modified", "additions": 174, "deletions": 39, "changes": 213, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4b71b95fe4842753bc3b695862d2dc160ff2313/gcc%2Fgenmatch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4b71b95fe4842753bc3b695862d2dc160ff2313/gcc%2Fgenmatch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenmatch.c?ref=d4b71b95fe4842753bc3b695862d2dc160ff2313", "patch": "@@ -683,7 +683,7 @@ struct simplify\n   simplify (simplify_kind kind_, operand *match_, operand *result_,\n \t    vec<vec<user_id *> > for_vec_, cid_map_t *capture_ids_)\n       : kind (kind_), match (match_), result (result_),\n-      for_vec (for_vec_),\n+      for_vec (for_vec_), for_subst_vec (vNULL),\n       capture_ids (capture_ids_), capture_max (capture_ids_->elements () - 1) {}\n \n   simplify_kind kind;\n@@ -697,6 +697,7 @@ struct simplify\n   /* Collected 'for' expression operators that have to be replaced\n      in the lowering phase.  */\n   vec<vec<user_id *> > for_vec;\n+  vec<std::pair<user_id *, id_base *> > for_subst_vec;\n   /* A map of capture identifiers to indexes.  */\n   cid_map_t *capture_ids;\n   int capture_max;\n@@ -1135,6 +1136,38 @@ replace_id (operand *o, user_id *id, id_base *with)\n   return o;\n }\n \n+/* Return true if the binary operator OP is ok for delayed substitution\n+   during for lowering.  */\n+\n+static bool\n+binary_ok (operator_id *op)\n+{\n+  switch (op->code)\n+    {\n+    case PLUS_EXPR:\n+    case MINUS_EXPR:\n+    case MULT_EXPR:\n+    case TRUNC_DIV_EXPR:\n+    case CEIL_DIV_EXPR:\n+    case FLOOR_DIV_EXPR:\n+    case ROUND_DIV_EXPR:\n+    case TRUNC_MOD_EXPR:\n+    case CEIL_MOD_EXPR:\n+    case FLOOR_MOD_EXPR:\n+    case ROUND_MOD_EXPR:\n+    case RDIV_EXPR:\n+    case EXACT_DIV_EXPR:\n+    case MIN_EXPR:\n+    case MAX_EXPR:\n+    case BIT_IOR_EXPR:\n+    case BIT_XOR_EXPR:\n+    case BIT_AND_EXPR:\n+      return true;\n+    default:\n+      return false;\n+    }\n+}\n+\n /* Lower recorded fors for SIN and output to SIMPLIFIERS.  */\n \n static void\n@@ -1154,9 +1187,46 @@ lower_for (simplify *sin, vec<simplify *>& simplifiers)\n       vec<user_id *>& ids = for_vec[fi];\n       unsigned n_ids = ids.length ();\n       unsigned max_n_opers = 0;\n+      bool can_delay_subst = (sin->kind == simplify::SIMPLIFY);\n       for (unsigned i = 0; i < n_ids; ++i)\n-\tif (ids[i]->substitutes.length () > max_n_opers)\n-\t  max_n_opers = ids[i]->substitutes.length ();\n+\t{\n+\t  if (ids[i]->substitutes.length () > max_n_opers)\n+\t    max_n_opers = ids[i]->substitutes.length ();\n+\t  /* Require that all substitutes are of the same kind so that\n+\t     if we delay substitution to the result op code generation\n+\t     can look at the first substitute for deciding things like\n+\t     types of operands.  */\n+\t  enum id_base::id_kind kind = ids[i]->substitutes[0]->kind;\n+\t  for (unsigned j = 0; j < ids[i]->substitutes.length (); ++j)\n+\t    if (ids[i]->substitutes[j]->kind != kind)\n+\t      can_delay_subst = false;\n+\t    else if (operator_id *op\n+\t\t       = dyn_cast <operator_id *> (ids[i]->substitutes[j]))\n+\t      {\n+\t\toperator_id *op0\n+\t\t  = as_a <operator_id *> (ids[i]->substitutes[0]);\n+\t\tif (strcmp (op->tcc, \"tcc_comparison\") == 0\n+\t\t    && strcmp (op0->tcc, \"tcc_comparison\") == 0)\n+\t\t  ;\n+\t\t/* Unfortunately we can't just allow all tcc_binary.  */\n+\t\telse if (strcmp (op->tcc, \"tcc_binary\") == 0\n+\t\t\t && strcmp (op0->tcc, \"tcc_binary\") == 0\n+\t\t\t && binary_ok (op)\n+\t\t\t && binary_ok (op0))\n+\t\t  ;\n+\t\telse if ((strcmp (op->id + 1, \"SHIFT_EXPR\") == 0\n+\t\t\t  || strcmp (op->id + 1, \"ROTATE_EXPR\") == 0)\n+\t\t\t && (strcmp (op0->id + 1, \"SHIFT_EXPR\") == 0\n+\t\t\t     || strcmp (op0->id + 1, \"ROTATE_EXPR\") == 0))\n+\t\t  ;\n+\t\telse\n+\t\t  can_delay_subst = false;\n+\t      }\n+\t    else if (is_a <fn_id *> (ids[i]->substitutes[j]))\n+\t      ;\n+\t    else\n+\t      can_delay_subst = false;\n+\t}\n \n       unsigned worklist_end = worklist.length ();\n       for (unsigned si = worklist_start; si < worklist_end; ++si)\n@@ -1166,16 +1236,26 @@ lower_for (simplify *sin, vec<simplify *>& simplifiers)\n \t    {\n \t      operand *match_op = s->match;\n \t      operand *result_op = s->result;\n+\t      vec<std::pair<user_id *, id_base *> > subst;\n+\t      subst.create (n_ids);\n \t      for (unsigned i = 0; i < n_ids; ++i)\n \t\t{\n \t\t  user_id *id = ids[i];\n \t\t  id_base *oper = id->substitutes[j % id->substitutes.length ()];\n+\t\t  subst.quick_push (std::make_pair (id, oper));\n \t\t  match_op = replace_id (match_op, id, oper);\n-\t\t  if (result_op)\n+\t\t  if (result_op\n+\t\t      && !can_delay_subst)\n \t\t    result_op = replace_id (result_op, id, oper);\n \t\t}\n \t      simplify *ns = new simplify (s->kind, match_op, result_op,\n \t\t\t\t\t   vNULL, s->capture_ids);\n+\t      ns->for_subst_vec.safe_splice (s->for_subst_vec);\n+\t      if (result_op\n+\t\t  && can_delay_subst)\n+\t\tns->for_subst_vec.safe_splice (subst);\n+\t      else\n+\t\tsubst.release ();\n \t      worklist.safe_push (ns);\n \t    }\n \t}\n@@ -1818,6 +1898,9 @@ capture_info::walk_result (operand *o, bool conditional_p, operand *result)\n     }\n   else if (expr *e = dyn_cast <expr *> (o))\n     {\n+      id_base *opr = e->operation;\n+      if (user_id *uid = dyn_cast <user_id *> (opr))\n+\topr = uid->substitutes[0];\n       for (unsigned i = 0; i < e->ops.length (); ++i)\n \t{\n \t  bool cond_p = conditional_p;\n@@ -1972,7 +2055,14 @@ expr::gen_transform (FILE *f, int indent, const char *dest, bool gimple,\n \t\t     int depth, const char *in_type, capture_info *cinfo,\n \t\t     dt_operand **indexes, bool)\n {\n-  bool conversion_p = is_conversion (operation);\n+  id_base *opr = operation;\n+  /* When we delay operator substituting during lowering of fors we\n+     make sure that for code-gen purposes the effects of each substitute\n+     are the same.  Thus just look at that.  */\n+  if (user_id *uid = dyn_cast <user_id *> (opr))\n+    opr = uid->substitutes[0];\n+\n+  bool conversion_p = is_conversion (opr);\n   const char *type = expr_type;\n   char optype[64];\n   if (type)\n@@ -1982,23 +2072,23 @@ expr::gen_transform (FILE *f, int indent, const char *dest, bool gimple,\n     /* For conversions we need to build the expression using the\n        outer type passed in.  */\n     type = in_type;\n-  else if (*operation == REALPART_EXPR\n-\t   || *operation == IMAGPART_EXPR)\n+  else if (*opr == REALPART_EXPR\n+\t   || *opr == IMAGPART_EXPR)\n     {\n       /* __real and __imag use the component type of its operand.  */\n       sprintf (optype, \"TREE_TYPE (TREE_TYPE (ops%d[0]))\", depth);\n       type = optype;\n     }\n-  else if (is_a <operator_id *> (operation)\n-\t   && !strcmp (as_a <operator_id *> (operation)->tcc, \"tcc_comparison\"))\n+  else if (is_a <operator_id *> (opr)\n+\t   && !strcmp (as_a <operator_id *> (opr)->tcc, \"tcc_comparison\"))\n     {\n       /* comparisons use boolean_type_node (or what gets in), but\n          their operands need to figure out the types themselves.  */\n       sprintf (optype, \"boolean_type_node\");\n       type = optype;\n     }\n-  else if (*operation == COND_EXPR\n-\t   || *operation == VEC_COND_EXPR)\n+  else if (*opr == COND_EXPR\n+\t   || *opr == VEC_COND_EXPR)\n     {\n       /* Conditions are of the same type as their first alternative.  */\n       sprintf (optype, \"TREE_TYPE (ops%d[1])\", depth);\n@@ -2023,24 +2113,24 @@ expr::gen_transform (FILE *f, int indent, const char *dest, bool gimple,\n       char dest[32];\n       snprintf (dest, 32, \"ops%d[%u]\", depth, i);\n       const char *optype\n-\t= get_operand_type (operation, in_type, expr_type,\n+\t= get_operand_type (opr, in_type, expr_type,\n \t\t\t    i == 0 ? NULL : op0type);\n       ops[i]->gen_transform (f, indent, dest, gimple, depth + 1, optype,\n \t\t\t     cinfo, indexes,\n-\t\t\t     ((!(*operation == COND_EXPR)\n-\t\t\t       && !(*operation == VEC_COND_EXPR))\n+\t\t\t     ((!(*opr == COND_EXPR)\n+\t\t\t       && !(*opr == VEC_COND_EXPR))\n \t\t\t      || i != 0));\n     }\n \n-  const char *opr;\n+  const char *opr_name;\n   if (*operation == CONVERT_EXPR)\n-    opr = \"NOP_EXPR\";\n+    opr_name = \"NOP_EXPR\";\n   else\n-    opr = operation->id;\n+    opr_name = operation->id;\n \n   if (gimple)\n     {\n-      if (*operation == CONVERT_EXPR)\n+      if (*opr == CONVERT_EXPR)\n \t{\n \t  fprintf_indent (f, indent,\n \t\t\t  \"if (%s != TREE_TYPE (ops%d[0])\\n\",\n@@ -2054,7 +2144,7 @@ expr::gen_transform (FILE *f, int indent, const char *dest, bool gimple,\n       /* ???  Building a stmt can fail for various reasons here, seq being\n          NULL or the stmt referencing SSA names occuring in abnormal PHIs.\n \t So if we fail here we should continue matching other patterns.  */\n-      fprintf_indent (f, indent, \"code_helper tem_code = %s;\\n\", opr);\n+      fprintf_indent (f, indent, \"code_helper tem_code = %s;\\n\", opr_name);\n       fprintf_indent (f, indent, \"tree tem_ops[3] = { \");\n       for (unsigned i = 0; i < ops.length (); ++i)\n \tfprintf (f, \"ops%d[%u]%s\", depth, i,\n@@ -2067,7 +2157,7 @@ expr::gen_transform (FILE *f, int indent, const char *dest, bool gimple,\n \t\t      type);\n       fprintf_indent (f, indent,\n \t\t      \"if (!res) return false;\\n\");\n-      if (*operation == CONVERT_EXPR)\n+      if (*opr == CONVERT_EXPR)\n \t{\n \t  indent -= 4;\n \t  fprintf_indent (f, indent, \"  }\\n\");\n@@ -2077,22 +2167,22 @@ expr::gen_transform (FILE *f, int indent, const char *dest, bool gimple,\n     }\n   else\n     {\n-      if (*operation == CONVERT_EXPR)\n+      if (*opr == CONVERT_EXPR)\n \t{\n \t  fprintf_indent (f, indent, \"if (TREE_TYPE (ops%d[0]) != %s)\\n\",\n \t\t\t  depth, type);\n \t  indent += 2;\n \t}\n-      if (operation->kind == id_base::CODE)\n+      if (opr->kind == id_base::CODE)\n \tfprintf_indent (f, indent, \"res = fold_build%d_loc (loc, %s, %s\",\n-\t\t\tops.length(), opr, type);\n+\t\t\tops.length(), opr_name, type);\n       else\n \tfprintf_indent (f, indent, \"res = build_call_expr_loc (loc, \"\n-\t\t\t\"builtin_decl_implicit (%s), %d\", opr, ops.length());\n+\t\t\t\"builtin_decl_implicit (%s), %d\", opr_name, ops.length());\n       for (unsigned i = 0; i < ops.length (); ++i)\n \tfprintf (f, \", ops%d[%u]\", depth, i);\n       fprintf (f, \");\\n\");\n-      if (*operation == CONVERT_EXPR)\n+      if (*opr == CONVERT_EXPR)\n \t{\n \t  indent -= 2;\n \t  fprintf_indent (f, indent, \"else\\n\");\n@@ -2838,7 +2928,15 @@ dt_simplify::gen_1 (FILE *f, int indent, bool gimple, operand *result)\n       if (result->type == operand::OP_EXPR)\n \t{\n \t  expr *e = as_a <expr *> (result);\n-\t  bool is_predicate = is_a <predicate_id *> (e->operation);\n+\t  id_base *opr = e->operation;\n+\t  bool is_predicate = false;\n+\t  /* When we delay operator substituting during lowering of fors we\n+\t     make sure that for code-gen purposes the effects of each substitute\n+\t     are the same.  Thus just look at that.  */\n+\t  if (user_id *uid = dyn_cast <user_id *> (opr))\n+\t    opr = uid->substitutes[0];\n+\t  else if (is_a <predicate_id *> (opr))\n+\t    is_predicate = true;\n \t  if (!is_predicate)\n \t    fprintf_indent (f, indent, \"*res_code = %s;\\n\",\n \t\t\t    *e->operation == CONVERT_EXPR\n@@ -2848,7 +2946,7 @@ dt_simplify::gen_1 (FILE *f, int indent, bool gimple, operand *result)\n \t      char dest[32];\n \t      snprintf (dest, 32, \"res_ops[%d]\", j);\n \t      const char *optype\n-\t\t= get_operand_type (e->operation,\n+\t\t= get_operand_type (opr,\n \t\t\t\t    \"type\", e->expr_type,\n \t\t\t\t    j == 0 ? NULL : \"TREE_TYPE (res_ops[0])\");\n \t      /* We need to expand GENERIC conditions we captured from\n@@ -2858,8 +2956,8 @@ dt_simplify::gen_1 (FILE *f, int indent, bool gimple, operand *result)\n \t\t   /* But avoid doing that if the GENERIC condition is\n \t\t      valid - which it is in the first operand of COND_EXPRs\n \t\t      and VEC_COND_EXRPs.  */\n-\t\t   && ((!(*e->operation == COND_EXPR)\n-\t\t\t&& !(*e->operation == VEC_COND_EXPR))\n+\t\t   && ((!(*opr == COND_EXPR)\n+\t\t\t&& !(*opr == VEC_COND_EXPR))\n \t\t       || j != 0));\n \t      e->ops[j]->gen_transform (f, indent, dest, true, 1, optype,\n \t\t\t\t\t&cinfo,\n@@ -2908,7 +3006,14 @@ dt_simplify::gen_1 (FILE *f, int indent, bool gimple, operand *result)\n       if (result->type == operand::OP_EXPR)\n \t{\n \t  expr *e = as_a <expr *> (result);\n-\t  is_predicate = is_a <predicate_id *> (e->operation);\n+\t  id_base *opr = e->operation;\n+\t  /* When we delay operator substituting during lowering of fors we\n+\t     make sure that for code-gen purposes the effects of each substitute\n+\t     are the same.  Thus just look at that.  */\n+\t  if (user_id *uid = dyn_cast <user_id *> (opr))\n+\t    opr = uid->substitutes[0];\n+\t  else if (is_a <predicate_id *> (opr))\n+\t    is_predicate = true;\n \t  /* Search for captures used multiple times in the result expression\n \t     and dependent on TREE_SIDE_EFFECTS emit a SAVE_EXPR.  */\n \t  if (!is_predicate)\n@@ -2938,7 +3043,7 @@ dt_simplify::gen_1 (FILE *f, int indent, bool gimple, operand *result)\n \t\t  snprintf (dest, 32, \"res_op%d\", j);\n \t\t}\n \t      const char *optype\n-\t        = get_operand_type (e->operation,\n+\t        = get_operand_type (opr,\n \t\t\t\t    \"type\", e->expr_type,\n \t\t\t\t    j == 0\n \t\t\t\t    ? NULL : \"TREE_TYPE (res_op0)\");\n@@ -2953,12 +3058,12 @@ dt_simplify::gen_1 (FILE *f, int indent, bool gimple, operand *result)\n \t      /* Re-fold the toplevel result.  Use non_lvalue to\n \t         build NON_LVALUE_EXPRs so they get properly\n \t\t ignored when in GIMPLE form.  */\n-\t      if (*e->operation == NON_LVALUE_EXPR)\n+\t      if (*opr == NON_LVALUE_EXPR)\n \t\tfprintf_indent (f, indent,\n \t\t\t\t\"res = non_lvalue_loc (loc, res_op0);\\n\");\n \t      else\n \t\t{\n-\t\t  if (e->operation->kind == id_base::CODE)\n+\t\t  if (is_a <operator_id *> (opr))\n \t\t    fprintf_indent (f, indent,\n \t\t\t\t    \"res = fold_build%d_loc (loc, %s, type\",\n \t\t\t\t    e->ops.length (),\n@@ -3039,7 +3144,10 @@ dt_simplify::gen (FILE *f, int indent, bool gimple)\n       if (gimple)\n \t{\n \t  fprintf_indent (f, indent, \"if (%s (res_code, res_ops, seq, \"\n-\t\t\t  \"valueize, type, captures))\\n\", info->fname);\n+\t\t\t  \"valueize, type, captures\", info->fname);\n+\t  for (unsigned i = 0; i < s->for_subst_vec.length (); ++i)\n+\t    fprintf (f, \", %s\", s->for_subst_vec[i].second->id);\n+\t  fprintf (f, \"))\\n\");\n \t  fprintf_indent (f, indent, \"  return true;\\n\");\n \t}\n       else\n@@ -3048,12 +3156,30 @@ dt_simplify::gen (FILE *f, int indent, bool gimple)\n \t\t\t  info->fname);\n \t  for (unsigned i = 0; i < as_a <expr *> (s->match)->ops.length (); ++i)\n \t    fprintf (f, \", op%d\", i);\n-\t  fprintf (f, \", captures);\\n\");\n+\t  fprintf (f, \", captures\");\n+\t  for (unsigned i = 0; i < s->for_subst_vec.length (); ++i)\n+\t    fprintf (f, \", %s\", s->for_subst_vec[i].second->id);\n+\t  fprintf (f, \");\\n\");\n \t  fprintf_indent (f, indent, \"if (res) return res;\\n\");\n \t}\n     }\n   else\n-    gen_1 (f, indent, gimple, s->result);\n+    {\n+      for (unsigned i = 0; i < s->for_subst_vec.length (); ++i)\n+\t{\n+\t  if (is_a <operator_id *> (s->for_subst_vec[i].second))\n+\t    fprintf_indent (f, indent, \"enum tree_code %s = %s;\\n\",\n+\t\t\t    s->for_subst_vec[i].first->id,\n+\t\t\t    s->for_subst_vec[i].second->id);\n+\t  else if (is_a <fn_id *> (s->for_subst_vec[i].second))\n+\t    fprintf_indent (f, indent, \"enum built_in_function %s = %s;\\n\",\n+\t\t\t    s->for_subst_vec[i].first->id,\n+\t\t\t    s->for_subst_vec[i].second->id);\n+\t  else\n+\t    gcc_unreachable ();\n+\t}\n+      gen_1 (f, indent, gimple, s->result);\n+    }\n \n   indent -= 2;\n   fprintf_indent (f, indent, \"}\\n\");\n@@ -3183,7 +3309,7 @@ decision_tree::gen (FILE *f, bool gimple)\n \t\t \"                 gimple_seq *seq, tree (*valueize)(tree) \"\n \t\t \"ATTRIBUTE_UNUSED,\\n\"\n \t\t \"                 tree ARG_UNUSED (type), tree *ARG_UNUSED \"\n-\t\t \"(captures))\\n\",\n+\t\t \"(captures)\\n\",\n \t\t s->fname);\n       else\n \t{\n@@ -3193,10 +3319,19 @@ decision_tree::gen (FILE *f, bool gimple)\n \t  for (unsigned i = 0;\n \t       i < as_a <expr *>(s->s->s->match)->ops.length (); ++i)\n \t    fprintf (f, \" tree ARG_UNUSED (op%d),\", i);\n-\t  fprintf (f, \" tree *captures)\\n\");\n+\t  fprintf (f, \" tree *captures\\n\");\n+\t}\n+      for (unsigned i = 0; i < s->s->s->for_subst_vec.length (); ++i)\n+\t{\n+\t  if (is_a <operator_id *> (s->s->s->for_subst_vec[i].second))\n+\t    fprintf (f, \", enum tree_code ARG_UNUSED (%s)\",\n+\t\t     s->s->s->for_subst_vec[i].first->id);\n+\t  else if (is_a <fn_id *> (s->s->s->for_subst_vec[i].second))\n+\t    fprintf (f, \", enum built_in_function ARG_UNUSED (%s)\",\n+\t\t     s->s->s->for_subst_vec[i].first->id);\n \t}\n \n-      fprintf (f, \"{\\n\");\n+      fprintf (f, \")\\n{\\n\");\n       s->s->gen_1 (f, 2, gimple, s->s->s->result);\n       if (gimple)\n \tfprintf (f, \"  return false;\\n\");"}]}