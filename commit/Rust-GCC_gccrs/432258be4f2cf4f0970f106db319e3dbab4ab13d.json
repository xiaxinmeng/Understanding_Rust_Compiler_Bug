{"sha": "432258be4f2cf4f0970f106db319e3dbab4ab13d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDMyMjU4YmU0ZjJjZjRmMDk3MGYxMDZkYjMxOWUzZGJhYjRhYjEzZA==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2020-11-05T12:16:13Z"}, "committer": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2020-11-05T13:31:32Z"}, "message": "libstdc++: Fix new <sstream> constructors\n\n- Add a missing 'explicit' to a basic_stringbuf constructor.\n- Set up the get/put area pointers in the constructor from strings using\n  different allocator types.\n- Remove public basic_stringbuf::__sv_type alias.\n- Do not construct temporary basic_string objects with a\n  default-constructed allocator.\n\nAlso, change which basic_string constructor is used, as a minor\ncompile-time optimization. Constructing from a basic_string_view\nrequires more work from the compiler, so just use a pointer and length.\n\nlibstdc++-v3/ChangeLog:\n\n\t* include/std/sstream (basic_stringbuf(const allocator_type&):\n\tAdd explicit.\n\t(basic_stringbuf(const basic_string<C,T,SA>&, openmode, const A&)):\n\tCall _M_stringbuf_init. Construct _M_string from pointer and length\n\tto avoid constraint checks for string view.\n\t(basic_stringbuf::view()): Make __sv_type alias local to the\n\tfunction.\n\t(basic_istringstream(const basic_string<C,T,SA>&, openmode, const A&)):\n\tPass string to _M_streambuf instead of constructing a temporary\n\twith the wrong allocator.\n\t(basic_ostringstream(const basic_string<C,T,SA>&, openmode, const A&)):\n\tLikewise.\n\t(basic_stringstream(const basic_string<C,T,SA>&, openmode, const A&)):\n\tLikewise.\n\t* src/c++20/sstream-inst.cc: Use string_view and wstring_view\n\ttypedefs in explicit instantiations.\n\t* testsuite/27_io/basic_istringstream/cons/char/1.cc: Add more\n\ttests for constructors.\n\t* testsuite/27_io/basic_ostringstream/cons/char/1.cc: Likewise.\n\t* testsuite/27_io/basic_stringbuf/cons/char/1.cc: Likewise.\n\t* testsuite/27_io/basic_stringbuf/cons/char/2.cc: Likewise.\n\t* testsuite/27_io/basic_stringbuf/cons/wchar_t/1.cc: Likewise.\n\t* testsuite/27_io/basic_stringbuf/cons/wchar_t/2.cc: Likewise.\n\t* testsuite/27_io/basic_stringstream/cons/char/1.cc: Likewise.", "tree": {"sha": "1c1c9d60c27e86527efb1ebce7cea15358519af1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1c1c9d60c27e86527efb1ebce7cea15358519af1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/432258be4f2cf4f0970f106db319e3dbab4ab13d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/432258be4f2cf4f0970f106db319e3dbab4ab13d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/432258be4f2cf4f0970f106db319e3dbab4ab13d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/432258be4f2cf4f0970f106db319e3dbab4ab13d/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cbc3f0bcc0e6dba4be2873f7ed7b63de6f8fc524", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cbc3f0bcc0e6dba4be2873f7ed7b63de6f8fc524", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cbc3f0bcc0e6dba4be2873f7ed7b63de6f8fc524"}], "stats": {"total": 506, "additions": 451, "deletions": 55}, "files": [{"sha": "437e2ba2a5f8f593aad3b7141ae168d2f33673f4", "filename": "libstdc++-v3/include/std/sstream", "status": "modified", "additions": 17, "deletions": 21, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/432258be4f2cf4f0970f106db319e3dbab4ab13d/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fsstream", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/432258be4f2cf4f0970f106db319e3dbab4ab13d/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fsstream", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fsstream?ref=432258be4f2cf4f0970f106db319e3dbab4ab13d", "patch": "@@ -166,8 +166,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11\n #endif\n \n #if __cplusplus > 201703L && _GLIBCXX_USE_CXX11_ABI\n-      using __sv_type = basic_string_view<char_type, traits_type>;\n-\n+      explicit\n       basic_stringbuf(const allocator_type& __a)\n       : basic_stringbuf(ios_base::in | std::ios_base::out, __a)\n       { }\n@@ -185,18 +184,18 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11\n       { _M_stringbuf_init(__mode); }\n \n       template<typename _SAlloc>\n-      basic_stringbuf(const basic_string<_CharT, _Traits, _SAlloc>& __s,\n-\t\t      const allocator_type& __a)\n-      : basic_stringbuf(__s, ios_base::in | std::ios_base::out, __a)\n-      { }\n+\tbasic_stringbuf(const basic_string<_CharT, _Traits, _SAlloc>& __s,\n+\t\t\tconst allocator_type& __a)\n+\t: basic_stringbuf(__s, ios_base::in | std::ios_base::out, __a)\n+\t{ }\n \n       template<typename _SAlloc>\n-      basic_stringbuf(const basic_string<_CharT, _Traits, _SAlloc>& __s,\n-\t\t      ios_base::openmode __mode,\n-\t\t      const allocator_type& __a)\n-      : __streambuf_type(), _M_mode(__mode),\n-      _M_string(static_cast<__sv_type>(__s), __a)\n-      { }\n+\tbasic_stringbuf(const basic_string<_CharT, _Traits, _SAlloc>& __s,\n+\t\t\tios_base::openmode __mode,\n+\t\t\tconst allocator_type& __a)\n+\t: __streambuf_type(), _M_mode(__mode),\n+\t  _M_string(__s.data(), __s.size(), __a)\n+\t{ _M_stringbuf_init(__mode); }\n \n       template<typename _SAlloc>\n \texplicit\n@@ -258,9 +257,11 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11\n       }\n \n #if __cplusplus > 201703L && _GLIBCXX_USE_CXX11_ABI\n-      __sv_type\n+      basic_string_view<char_type, traits_type>\n       view() const noexcept\n       {\n+\tusing __sv_type = basic_string_view<char_type, traits_type>;\n+\n \tif (this->pptr())\n \t  {\n \t    // The current egptr() may not be the actual string end.\n@@ -598,9 +599,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11\n \tbasic_istringstream(const basic_string<_CharT, _Traits, _SAlloc>& __str,\n \t\t\t    ios_base::openmode __mode,\n \t\t\t    const allocator_type& __a)\n-\t: __istream_type(),\n-\t_M_stringbuf(__string_type(__str.data(), __str.size()),\n-\t\t     __mode | ios_base::in, __a)\n+\t: __istream_type(), _M_stringbuf(__str, __mode | ios_base::in, __a)\n \t{ this->init(std::__addressof(_M_stringbuf)); }\n \n       template<typename _SAlloc>\n@@ -796,9 +795,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11\n \tbasic_ostringstream(const basic_string<_CharT, _Traits, _SAlloc>& __str,\n \t\t\t    ios_base::openmode __mode,\n \t\t\t    const allocator_type& __a)\n-\t: __ostream_type(),\n-\t_M_stringbuf(__string_type(__str.data(), __str.size()),\n-\t\t     __mode | ios_base::out, __a)\n+\t: __ostream_type(), _M_stringbuf(__str, __mode | ios_base::out, __a)\n \t{ this->init(std::__addressof(_M_stringbuf)); }\n \n       template<typename _SAlloc>\n@@ -991,8 +988,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11\n \tbasic_stringstream(const basic_string<_CharT, _Traits, _SAlloc>& __str,\n \t\t\t   ios_base::openmode __mode,\n \t\t\t   const allocator_type& __a)\n-\t: __iostream_type(),\n-\t_M_stringbuf(__string_type(__str.data(), __str.size()), __mode, __a)\n+\t: __iostream_type(), _M_stringbuf(__str, __mode, __a)\n \t{ this->init(std::__addressof(_M_stringbuf)); }\n \n       template<typename _SAlloc>"}, {"sha": "ada3eabac1f552b50f06a6be0ecaac1f6ebc0c1f", "filename": "libstdc++-v3/src/c++20/sstream-inst.cc", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/432258be4f2cf4f0970f106db319e3dbab4ab13d/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B20%2Fsstream-inst.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/432258be4f2cf4f0970f106db319e3dbab4ab13d/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B20%2Fsstream-inst.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B20%2Fsstream-inst.cc?ref=432258be4f2cf4f0970f106db319e3dbab4ab13d", "patch": "@@ -43,7 +43,7 @@ template basic_stringbuf<char>::basic_stringbuf(basic_stringbuf&&,\n \t\t\t\t\t\tconst allocator_type&);\n template basic_stringbuf<char>::allocator_type\n basic_stringbuf<char>::get_allocator() const noexcept;\n-template basic_stringbuf<char>::__sv_type\n+template string_view\n basic_stringbuf<char>::view() const noexcept;\n \n template basic_istringstream<char>::basic_istringstream(ios_base::openmode,\n@@ -68,8 +68,6 @@ template string_view\n basic_stringstream<char>::view() const noexcept;\n \n #ifdef _GLIBCXX_USE_WCHAR_T\n-using wsv_type = basic_string_view<wchar_t>;\n-\n template basic_stringbuf<wchar_t>::basic_stringbuf(const allocator_type&);\n template basic_stringbuf<wchar_t>::basic_stringbuf(ios_base::openmode,\n \t\t\t\t\t\t   const allocator_type&);\n@@ -80,7 +78,7 @@ template basic_stringbuf<wchar_t>::basic_stringbuf(basic_stringbuf&&,\n template basic_stringbuf<wchar_t>::allocator_type\n basic_stringbuf<wchar_t>::get_allocator() const noexcept;\n \n-template basic_istringstream<wchar_t>::__stringbuf_type::__sv_type\n+template wstring_view\n basic_stringbuf<wchar_t>::view() const noexcept;\n \n template basic_istringstream<wchar_t>::basic_istringstream(ios_base::openmode,"}, {"sha": "6584b88193d3a7dbb3616506efc5f05658109e15", "filename": "libstdc++-v3/testsuite/27_io/basic_istringstream/cons/char/1.cc", "status": "modified", "additions": 35, "deletions": 2, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/432258be4f2cf4f0970f106db319e3dbab4ab13d/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_istringstream%2Fcons%2Fchar%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/432258be4f2cf4f0970f106db319e3dbab4ab13d/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_istringstream%2Fcons%2Fchar%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_istringstream%2Fcons%2Fchar%2F1.cc?ref=432258be4f2cf4f0970f106db319e3dbab4ab13d", "patch": "@@ -33,7 +33,7 @@ test01()\n   std::istringstream stm(std::ios_base::in, a);\n }\n \n-auto const cstr = \"This is a test\";\n+auto const cstr = \"This is a test string\";\n \n void\n test02()\n@@ -75,11 +75,44 @@ test03()\n   }\n }\n \n+// A minimal allocator with no default constructor\n+template<typename T>\n+  struct NoDefaultCons : __gnu_test::SimpleAllocator<T>\n+  {\n+    using __gnu_test::SimpleAllocator<T>::SimpleAllocator;\n+\n+    NoDefaultCons() = delete;\n+\n+    NoDefaultCons(int) { }\n+  };\n+\n+void\n+test04()\n+{\n+  using sstream = std::basic_istringstream<char, std::char_traits<char>,\n+\t\t\t\t\t   NoDefaultCons<char>>;\n+\n+  NoDefaultCons<char> a(1);\n+  const std::string str(cstr);\n+\n+  sstream ss1(str, a);\n+  VERIFY( ss1.str() == cstr );\n+  VERIFY( ss1.get() == cstr[0] );\n+\n+  sstream ss2(str, std::ios::out, a);\n+  VERIFY( ss2.str() == cstr );\n+  VERIFY( ss2.get() == cstr[0] );\n+\n+  sstream ss3(std::string(str), std::ios::out, a);\n+  VERIFY( ss3.str() == cstr );\n+  VERIFY( ss3.get() == cstr[0] );\n+}\n+\n int\n main()\n {\n   test01();\n   test02();\n   test03();\n-  return 0;\n+  test04();\n }"}, {"sha": "885949caf002324ed246860460f6c31a4682de4f", "filename": "libstdc++-v3/testsuite/27_io/basic_ostringstream/cons/char/1.cc", "status": "modified", "additions": 36, "deletions": 2, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/432258be4f2cf4f0970f106db319e3dbab4ab13d/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_ostringstream%2Fcons%2Fchar%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/432258be4f2cf4f0970f106db319e3dbab4ab13d/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_ostringstream%2Fcons%2Fchar%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_ostringstream%2Fcons%2Fchar%2F1.cc?ref=432258be4f2cf4f0970f106db319e3dbab4ab13d", "patch": "@@ -33,7 +33,7 @@ test01()\n   std::ostringstream stm(std::ios_base::in, a);\n }\n \n-auto const cstr = \"This is a test\";\n+auto const cstr = \"This is a test string\";\n \n void\n test02()\n@@ -75,11 +75,45 @@ test03()\n   }\n }\n \n+// A minimal allocator with no default constructor\n+template<typename T>\n+  struct NoDefaultCons : __gnu_test::SimpleAllocator<T>\n+  {\n+    using __gnu_test::SimpleAllocator<T>::SimpleAllocator;\n+\n+    NoDefaultCons() = delete;\n+\n+    NoDefaultCons(int) { }\n+  };\n+\n+void\n+test04()\n+{\n+  using sstream = std::basic_ostringstream<char, std::char_traits<char>,\n+\t\t\t\t\t   NoDefaultCons<char>>;\n+\n+  NoDefaultCons<char> a(1);\n+  const std::string str(cstr);\n+\n+  sstream ss1(str, a);\n+  VERIFY( ss1.str() == cstr );\n+\n+  sstream ss2(str, std::ios::in, a);\n+  VERIFY( ss2.str() == cstr );\n+  VERIFY( bool(ss2 << \"That\") );\n+  VERIFY( ss2.str() == \"That is a test string\" );\n+\n+  sstream ss3(std::string(str), std::ios::ate, a);\n+  VERIFY( ss3.str() == cstr );\n+  VERIFY( bool(ss3 << \"y thing\") );\n+  VERIFY( ss3.str() == \"This is a test stringy thing\" );\n+}\n+\n int\n main()\n {\n   test01();\n   test02();\n   test03();\n-  return 0;\n+  test04();\n }"}, {"sha": "bd17e6ddc9e3619e3ce7cb1339c8094d544c7d43", "filename": "libstdc++-v3/testsuite/27_io/basic_stringbuf/cons/char/1.cc", "status": "modified", "additions": 35, "deletions": 2, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/432258be4f2cf4f0970f106db319e3dbab4ab13d/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_stringbuf%2Fcons%2Fchar%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/432258be4f2cf4f0970f106db319e3dbab4ab13d/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_stringbuf%2Fcons%2Fchar%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_stringbuf%2Fcons%2Fchar%2F1.cc?ref=432258be4f2cf4f0970f106db319e3dbab4ab13d", "patch": "@@ -17,7 +17,7 @@\n // with this library; see the file COPYING3.  If not see\n // <http://www.gnu.org/licenses/>.\n \n-// 27.7.1.1  basic_stringbuf constructors  [lib.stringbuf.cons]\n+// C++03 27.7.1.1  basic_stringbuf constructors  [lib.stringbuf.cons]\n \n #include <sstream>\n #include <testsuite_hooks.h>\n@@ -30,8 +30,41 @@ void test01()\n   VERIFY( sbuf.check_pointers() );\n }\n \n-int main() \n+void test02()\n+{\n+  std::stringbuf sbuf;\n+  VERIFY( sbuf.str().empty() );\n+\n+  std::stringbuf sbuf1(std::ios::in);\n+  VERIFY( sbuf1.str().empty() );\n+\n+  const std::string str = \"This is my boomstick!\";\n+\n+  std::stringbuf sbuf2(str);\n+  VERIFY( sbuf2.str() == str );\n+\n+  std::stringbuf sbuf3(str, std::ios::in);\n+  VERIFY( sbuf3.str() == str );\n+  VERIFY( sbuf3.sgetc() == str[0] );\n+  VERIFY( sbuf3.sputc('X') == std::stringbuf::traits_type::eof() );\n+\n+  std::stringbuf sbuf4(str, std::ios::out);\n+  VERIFY( sbuf4.str() == str );\n+  VERIFY( sbuf4.sputc('Y') == 'Y' );\n+  VERIFY( sbuf4.sgetc() == std::stringbuf::traits_type::eof() );\n+\n+#if __cplusplus >= 201103L\n+  static_assert( ! std::is_convertible<std::ios::openmode, std::stringbuf>(),\n+\t\t  \"stringbuf(ios::openmode) is explicit\");\n+\n+  static_assert( ! std::is_convertible<const std::string&, std::stringbuf>(),\n+\t\t  \"stringbuf(string, ios::openmode) is explicit\");\n+#endif\n+}\n+\n+int main()\n {\n   test01();\n+  test02();\n   return 0;\n }"}, {"sha": "c72ca5c7c84df43fba77031dbee4216f4357d03e", "filename": "libstdc++-v3/testsuite/27_io/basic_stringbuf/cons/char/2.cc", "status": "modified", "additions": 117, "deletions": 8, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/432258be4f2cf4f0970f106db319e3dbab4ab13d/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_stringbuf%2Fcons%2Fchar%2F2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/432258be4f2cf4f0970f106db319e3dbab4ab13d/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_stringbuf%2Fcons%2Fchar%2F2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_stringbuf%2Fcons%2Fchar%2F2.cc?ref=432258be4f2cf4f0970f106db319e3dbab4ab13d", "patch": "@@ -15,7 +15,7 @@\n // with this library; see the file COPYING3.  If not see\n // <http://www.gnu.org/licenses/>.\n \n-// 27.7.1.1  basic_stringbuf constructors  [lib.stringbuf.cons]\n+// C++20 29.8.2.2  basic_stringbuf constructors  [stringbuf.cons]\n \n // { dg-options \"-std=gnu++2a\" }\n // { dg-do run { target c++2a } }\n@@ -26,13 +26,24 @@\n #include <testsuite_allocator.h>\n #include <testsuite_hooks.h>\n \n+template<typename Alloc, typename C = typename Alloc::value_type>\n+  using stringbuf_with_alloc\n+    = std::basic_stringbuf<C, std::char_traits<C>, Alloc>;\n+\n void\n test01()\n {\n+  // Test C++20 constructors taking an allocator but no string.\n+\n+  static_assert(!std::is_convertible_v<std::allocator<char>, std::stringbuf>,\n+      \"stringbuf(const allocator<char>&) is explicit\");\n+\n   {\n     using alloc_type = __gnu_test::uneq_allocator<char>;\n-    using sbuf_t = std::basic_stringbuf<char, std::char_traits<char>,\n-\t\t\t\t\t\talloc_type>;\n+    using sbuf_t = stringbuf_with_alloc<alloc_type>;\n+\n+    static_assert(!std::is_convertible_v<const alloc_type&, sbuf_t>,\n+\t\"basic_stringbuf(const basic_stringbuf::allocator_type&) is explicit\");\n \n     alloc_type aa;\n     sbuf_t sbuf1(aa);\n@@ -48,58 +59,157 @@ test01()\n   std::stringbuf::allocator_type a;\n   {\n     std::stringbuf sbuf(std::ios_base::in, a);\n+    VERIFY( sbuf.str().empty() );\n+\n+    std::stringbuf sbuf2 = {std::ios_base::in, a}; // non-explicit ctor\n   }\n \n   {\n     std::stringbuf sbuf(a);\n+    VERIFY( sbuf.str().empty() );\n   }\n }\n \n-auto const cstr = \"This is a test\";\n+auto const cstr = \"This is a test string\";\n \n void\n test02()\n {\n+  // Test C++20 constructor taking an rvalue string\n+\n+  static_assert(!std::is_convertible_v<std::string, std::stringbuf>,\n+      \"stringbuf(string&&, ios::openmode) is explicit\");\n+\n   std::string s1(cstr);\n-  std::stringbuf sbuf(std::move(s1));\n+  std::stringbuf sbuf1(std::move(s1));\n   VERIFY( s1.empty() );\n+  VERIFY( sbuf1.str() == cstr );\n+  VERIFY( sbuf1.sgetc() == cstr[0] );\n \n   std::string s2(cstr);\n-  VERIFY( sbuf.str() == s2 );\n+  std::stringbuf sbuf2(std::move(s2), std::ios_base::in);\n+  VERIFY( s2.empty() );\n+  VERIFY( sbuf2.str() == cstr );\n+  VERIFY( sbuf2.sgetc() == cstr[0] );\n+  VERIFY( sbuf2.sputc('X') == std::stringbuf::traits_type::eof() );\n+\n+  std::string s3(cstr);\n+  std::stringbuf sbuf3(std::move(s3), std::ios_base::out);\n+  VERIFY( s3.empty() );\n+  VERIFY( sbuf3.str() == cstr );\n+  VERIFY( sbuf3.sputc('Y') == 'Y' );\n+  VERIFY( sbuf3.sgetc() == std::stringbuf::traits_type::eof() );\n }\n \n+// A minimal allocator with no default constructor\n+template<typename T>\n+  struct NoDefaultCons : __gnu_test::SimpleAllocator<T>\n+  {\n+    using __gnu_test::SimpleAllocator<T>::SimpleAllocator;\n+\n+    NoDefaultCons() = delete;\n+\n+    NoDefaultCons(int) { }\n+  };\n+\n void\n test03()\n {\n+  // Test C++20 constructors taking strings using different allocators\n+\n   using alloc_type = __gnu_test::tracker_allocator<char>;\n   using str_type = std::basic_string<char, std::char_traits<char>, alloc_type>;\n \n   auto const mode = std::ios_base::in | std::ios_base::out;\n   str_type s1(cstr);\n \n   {\n+    // basic_stringbuf(const basic_string<char, traits_type, SAlloc>&,\n+    //                 ios_base::openmode,\n+    //                 const allocator_type&)\n+\n     std::stringbuf::allocator_type a;\n-    std::stringbuf sbuf(s1, mode, a);\n+    std::stringbuf sbuf = {s1, mode, a}; // ={} checks for non-explicit ctor\n     std::string s2(cstr);\n     VERIFY( sbuf.str() == s2 );\n+\n+    std::stringbuf sbuf2 = {std::move(s1), std::ios::in, a};\n+    VERIFY( sbuf2.str() == s2 );\n+    VERIFY( s1 == cstr ); // did not move from std::move(s1)\n+    VERIFY( sbuf2.sgetc() == s1[0] );\n+    VERIFY( sbuf2.sputc('X') == std::stringbuf::traits_type::eof() );\n+\n+    std::stringbuf sbuf3 = {std::move(s1), std::ios::out, a};\n+    VERIFY( sbuf3.str() == s2 );\n+    VERIFY( s1 == cstr ); // did not move from std::move(s1)\n+    VERIFY( sbuf3.sputc('X') == 'X' );\n+    VERIFY( sbuf3.sgetc() == std::stringbuf::traits_type::eof() );\n   }\n \n   {\n+    // explicit\n+    // basic_stringbuf(const basic_string<char, traits_type, SAlloc>&,\n+    //                 ios_base::openmode)\n+\n     std::stringbuf sbuf(s1, mode);\n     std::string s2(cstr);\n     VERIFY( sbuf.str() == s2 );\n+\n+    std::stringbuf sbuf2(std::move(s1), std::ios::in);\n+    VERIFY( sbuf2.str() == s2 );\n+    VERIFY( s1 == cstr ); // did not move from std::move(s1)\n+    VERIFY( sbuf2.sgetc() == s1[0] );\n+    VERIFY( sbuf2.sputc('X') == std::stringbuf::traits_type::eof() );\n+\n+    std::stringbuf sbuf3(std::move(s1), std::ios::out);\n+    VERIFY( sbuf3.str() == s2 );\n+    VERIFY( s1 == cstr ); // did not move from std::move(s1)\n+    VERIFY( sbuf3.sputc('X') == 'X' );\n+    VERIFY( sbuf3.sgetc() == std::stringbuf::traits_type::eof() );\n   }\n \n   {\n+    // explicit\n+    // basic_stringbuf(const basic_string<char, traits_type, SAlloc>&,\n+    //                 ios_base::openmode = ios_base::in|ios_base::out)\n+\n+    static_assert( ! std::is_convertible_v<str_type, std::stringbuf>,\n+\t\"stringbuf(const basic_string<char, traits_type, SAlloc>&, openmode)\"\n+\t\" is explicit\");\n+\n     std::stringbuf sbuf(s1);\n     std::string s2(cstr);\n     VERIFY( sbuf.str() == s2 );\n+\n+    std::stringbuf sbuf2(std::move(s1));\n+    VERIFY( sbuf2.str() == s2 );\n+    VERIFY( s1 == cstr ); // did not move from std::move(s1)\n+    VERIFY( sbuf2.sgetc() == s1[0] );\n+  }\n+\n+  {\n+    NoDefaultCons<char> a(1);\n+    stringbuf_with_alloc<NoDefaultCons<char>> sbuf1(s1, a);\n+    VERIFY( sbuf1.str() == cstr );\n+    VERIFY( sbuf1.sgetc() == s1[0] );\n+\n+    stringbuf_with_alloc<NoDefaultCons<char>> sbuf2(s1, std::ios::in, a);\n+    VERIFY( sbuf2.str() == cstr );\n+    VERIFY( sbuf2.sgetc() == s1[0] );\n+    VERIFY( sbuf2.sputc('X') == std::stringbuf::traits_type::eof() );\n+\n+    stringbuf_with_alloc<NoDefaultCons<char>> sbuf3(s1, std::ios::out, a);\n+    VERIFY( sbuf3.str() == cstr );\n+    VERIFY( sbuf3.sputc('X') == 'X' );\n+    VERIFY( sbuf3.sgetc() == std::stringbuf::traits_type::eof() );\n   }\n }\n \n void\n test04()\n {\n+  // Test C++20 allocator-extended move constructor\n+\n   std::stringbuf sbuf1(cstr);\n \n   std::stringbuf::allocator_type a;\n@@ -117,5 +227,4 @@ main()\n   test02();\n   test03();\n   test04();\n-  return 0;\n }"}, {"sha": "4e3a2a9631d8f28e935b0258d7569f52cbeebb35", "filename": "libstdc++-v3/testsuite/27_io/basic_stringbuf/cons/wchar_t/1.cc", "status": "modified", "additions": 35, "deletions": 2, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/432258be4f2cf4f0970f106db319e3dbab4ab13d/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_stringbuf%2Fcons%2Fwchar_t%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/432258be4f2cf4f0970f106db319e3dbab4ab13d/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_stringbuf%2Fcons%2Fwchar_t%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_stringbuf%2Fcons%2Fwchar_t%2F1.cc?ref=432258be4f2cf4f0970f106db319e3dbab4ab13d", "patch": "@@ -17,7 +17,7 @@\n // with this library; see the file COPYING3.  If not see\n // <http://www.gnu.org/licenses/>.\n \n-// 27.7.1.1  basic_stringbuf constructors  [lib.stringbuf.cons]\n+// C++03 27.7.1.1  basic_stringbuf constructors  [lib.stringbuf.cons]\n \n #include <sstream>\n #include <testsuite_hooks.h>\n@@ -30,8 +30,41 @@ void test01()\n   VERIFY( sbuf.check_pointers() );\n }\n \n-int main() \n+void test02()\n+{\n+  std::wstringbuf sbuf;\n+  VERIFY( sbuf.str().empty() );\n+\n+  std::wstringbuf sbuf1(std::wios::in);\n+  VERIFY( sbuf1.str().empty() );\n+\n+  const std::wstring str = L\"This is my boomstick!\";\n+\n+  std::wstringbuf sbuf2(str);\n+  VERIFY( sbuf2.str() == str );\n+\n+  std::wstringbuf sbuf3(str, std::wios::in);\n+  VERIFY( sbuf3.str() == str );\n+  VERIFY( sbuf3.sgetc() == str[0] );\n+  VERIFY( sbuf3.sputc(L'X') == std::wstringbuf::traits_type::eof() );\n+\n+  std::wstringbuf sbuf4(str, std::wios::out);\n+  VERIFY( sbuf4.str() == str );\n+  VERIFY( sbuf4.sputc(L'Y') == L'Y' );\n+  VERIFY( sbuf4.sgetc() == std::wstringbuf::traits_type::eof() );\n+\n+#if __cplusplus >= 201103L\n+  static_assert( ! std::is_convertible<std::wios::openmode, std::wstringbuf>(),\n+\t\t  \"wstringbuf(wios::openmode) is explicit\");\n+\n+  static_assert( ! std::is_convertible<const std::wstring&, std::wstringbuf>(),\n+\t\t  \"wstringbuf(wstring, wios::openmode) is explicit\");\n+#endif\n+}\n+\n+int main()\n {\n   test01();\n+  test02();\n   return 0;\n }"}, {"sha": "4fbbbf39ad393daaab0fd5cd51d9ae8237380f0e", "filename": "libstdc++-v3/testsuite/27_io/basic_stringbuf/cons/wchar_t/2.cc", "status": "modified", "additions": 131, "deletions": 6, "changes": 137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/432258be4f2cf4f0970f106db319e3dbab4ab13d/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_stringbuf%2Fcons%2Fwchar_t%2F2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/432258be4f2cf4f0970f106db319e3dbab4ab13d/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_stringbuf%2Fcons%2Fwchar_t%2F2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_stringbuf%2Fcons%2Fwchar_t%2F2.cc?ref=432258be4f2cf4f0970f106db319e3dbab4ab13d", "patch": "@@ -15,7 +15,7 @@\n // with this library; see the file COPYING3.  If not see\n // <http://www.gnu.org/licenses/>.\n \n-// 27.7.1.1  basic_stringbuf constructors  [lib.stringbuf.cons]\n+// C++20 29.8.2.2  basic_stringbuf constructors  [stringbuf.cons]\n \n // { dg-options \"-std=gnu++2a\" }\n // { dg-do run { target c++2a } }\n@@ -26,64 +26,190 @@\n #include <testsuite_allocator.h>\n #include <testsuite_hooks.h>\n \n+template<typename Alloc, typename C = typename Alloc::value_type>\n+  using stringbuf_with_alloc\n+    = std::basic_stringbuf<C, std::char_traits<C>, Alloc>;\n+\n void\n test01()\n {\n+  // Test C++20 constructors taking an allocator but no string.\n+\n+  static_assert(!std::is_convertible_v<std::allocator<wchar_t>, std::wstringbuf>,\n+      \"wstringbuf(const allocator<wchar_t>&) is explicit\");\n+\n+  {\n+    using alloc_type = __gnu_test::uneq_allocator<wchar_t>;\n+    using sbuf_t = stringbuf_with_alloc<alloc_type>;\n+\n+    static_assert(!std::is_convertible_v<const alloc_type&, sbuf_t>,\n+\t\"basic_stringbuf(const basic_stringbuf::allocator_type&) is explicit\");\n+\n+    alloc_type aa;\n+    sbuf_t sbuf1(aa);\n+    VERIFY( aa == sbuf1.get_allocator() );\n+\n+    alloc_type aaa(42);\n+    sbuf_t sbuf2(aaa);\n+    VERIFY( aaa == sbuf2.get_allocator() );\n+\n+    VERIFY( sbuf1.get_allocator() != sbuf2.get_allocator() );\n+  }\n+\n   std::wstringbuf::allocator_type a;\n   {\n     std::wstringbuf sbuf(std::ios_base::in, a);\n+    VERIFY( sbuf.str().empty() );\n+\n+    std::wstringbuf sbuf2 = {std::ios_base::in, a}; // non-explicit ctor\n   }\n \n   {\n     std::wstringbuf sbuf(a);\n+    VERIFY( sbuf.str().empty() );\n   }\n }\n \n-auto const cstr = L\"This is a test\";\n+auto const cstr = L\"This is a test string\";\n \n void\n test02()\n {\n+  // Test C++20 constructor taking an rvalue string\n+\n+  static_assert(!std::is_convertible_v<std::wstring, std::wstringbuf>,\n+      \"wstringbuf(wstring&&, ios::openmode) is explicit\");\n+\n   std::wstring s1(cstr);\n-  std::wstringbuf sbuf(std::move(s1));\n+  std::wstringbuf sbuf1(std::move(s1));\n   VERIFY( s1.empty() );\n+  VERIFY( sbuf1.str() == cstr );\n+  VERIFY( sbuf1.sgetc() == cstr[0] );\n \n   std::wstring s2(cstr);\n-  VERIFY( sbuf.str() == s2 );\n+  std::wstringbuf sbuf2(std::move(s2), std::ios_base::in);\n+  VERIFY( s2.empty() );\n+  VERIFY( sbuf2.str() == cstr );\n+  VERIFY( sbuf2.sgetc() == cstr[0] );\n+  VERIFY( sbuf2.sputc(L'X') == std::wstringbuf::traits_type::eof() );\n+\n+  std::wstring s3(cstr);\n+  std::wstringbuf sbuf3(std::move(s3), std::ios_base::out);\n+  VERIFY( s3.empty() );\n+  VERIFY( sbuf3.str() == cstr );\n+  VERIFY( sbuf3.sputc(L'Y') == L'Y' );\n+  VERIFY( sbuf3.sgetc() == std::wstringbuf::traits_type::eof() );\n }\n \n+// A minimal allocator with no default constructor\n+template<typename T>\n+  struct NoDefaultCons : __gnu_test::SimpleAllocator<T>\n+  {\n+    using __gnu_test::SimpleAllocator<T>::SimpleAllocator;\n+\n+    NoDefaultCons() = delete;\n+\n+    NoDefaultCons(int) { }\n+  };\n+\n void\n test03()\n {\n+  // Test C++20 constructors taking strings using different allocators\n+\n   using alloc_type = __gnu_test::tracker_allocator<wchar_t>;\n   using str_type = std::basic_string<wchar_t, std::char_traits<wchar_t>, alloc_type>;\n \n   auto const mode = std::ios_base::in | std::ios_base::out;\n   str_type s1(cstr);\n \n   {\n+    // basic_stringbuf(const basic_string<wchar_t, traits_type, SAlloc>&,\n+    //                 ios_base::openmode,\n+    //                 const allocator_type&)\n+\n     std::wstringbuf::allocator_type a;\n-    std::wstringbuf sbuf(s1, mode, a);\n+    std::wstringbuf sbuf = {s1, mode, a}; // ={} checks for non-explicit ctor\n     std::wstring s2(cstr);\n     VERIFY( sbuf.str() == s2 );\n+\n+    std::wstringbuf sbuf2 = {std::move(s1), std::ios::in, a};\n+    VERIFY( sbuf2.str() == s2 );\n+    VERIFY( s1 == cstr ); // did not move from std::move(s1)\n+    VERIFY( sbuf2.sgetc() == s1[0] );\n+    VERIFY( sbuf2.sputc(L'X') == std::wstringbuf::traits_type::eof() );\n+\n+    std::wstringbuf sbuf3 = {std::move(s1), std::ios::out, a};\n+    VERIFY( sbuf3.str() == s2 );\n+    VERIFY( s1 == cstr ); // did not move from std::move(s1)\n+    VERIFY( sbuf3.sputc(L'X') == L'X' );\n+    VERIFY( sbuf3.sgetc() == std::wstringbuf::traits_type::eof() );\n   }\n \n   {\n+    // explicit\n+    // basic_stringbuf(const basic_string<wchar_t, traits_type, SAlloc>&,\n+    //                 ios_base::openmode)\n+\n     std::wstringbuf sbuf(s1, mode);\n     std::wstring s2(cstr);\n     VERIFY( sbuf.str() == s2 );\n+\n+    std::wstringbuf sbuf2(std::move(s1), std::ios::in);\n+    VERIFY( sbuf2.str() == s2 );\n+    VERIFY( s1 == cstr ); // did not move from std::move(s1)\n+    VERIFY( sbuf2.sgetc() == s1[0] );\n+    VERIFY( sbuf2.sputc(L'X') == std::wstringbuf::traits_type::eof() );\n+\n+    std::wstringbuf sbuf3(std::move(s1), std::ios::out);\n+    VERIFY( sbuf3.str() == s2 );\n+    VERIFY( s1 == cstr ); // did not move from std::move(s1)\n+    VERIFY( sbuf3.sputc(L'X') == L'X' );\n+    VERIFY( sbuf3.sgetc() == std::wstringbuf::traits_type::eof() );\n   }\n \n   {\n+    // explicit\n+    // basic_stringbuf(const basic_string<wchar_t, traits_type, SAlloc>&,\n+    //                 ios_base::openmode = ios_base::in|ios_base::out)\n+\n+    static_assert( ! std::is_convertible_v<str_type, std::wstringbuf>,\n+\t\"wstringbuf(const basic_string<wchar_t, traits_type, SAlloc>&,\"\n+\t\t  \" openmode) is explicit\");\n+\n     std::wstringbuf sbuf(s1);\n     std::wstring s2(cstr);\n     VERIFY( sbuf.str() == s2 );\n+\n+    std::wstringbuf sbuf2(std::move(s1));\n+    VERIFY( sbuf2.str() == s2 );\n+    VERIFY( s1 == cstr ); // did not move from std::move(s1)\n+    VERIFY( sbuf2.sgetc() == s1[0] );\n+  }\n+\n+  {\n+    NoDefaultCons<wchar_t> a(1);\n+    stringbuf_with_alloc<NoDefaultCons<wchar_t>> sbuf1(s1, a);\n+    VERIFY( sbuf1.str() == cstr );\n+    VERIFY( sbuf1.sgetc() == s1[0] );\n+\n+    stringbuf_with_alloc<NoDefaultCons<wchar_t>> sbuf2(s1, std::ios::in, a);\n+    VERIFY( sbuf2.str() == cstr );\n+    VERIFY( sbuf2.sgetc() == s1[0] );\n+    VERIFY( sbuf2.sputc(L'X') == std::wstringbuf::traits_type::eof() );\n+\n+    stringbuf_with_alloc<NoDefaultCons<wchar_t>> sbuf3(s1, std::ios::out, a);\n+    VERIFY( sbuf3.str() == cstr );\n+    VERIFY( sbuf3.sputc(L'X') == L'X' );\n+    VERIFY( sbuf3.sgetc() == std::wstringbuf::traits_type::eof() );\n   }\n }\n \n void\n test04()\n {\n+  // Test C++20 allocator-extended move constructor\n+\n   std::wstringbuf sbuf1(cstr);\n \n   std::wstringbuf::allocator_type a;\n@@ -101,5 +227,4 @@ main()\n   test02();\n   test03();\n   test04();\n-  return 0;\n }"}, {"sha": "33f2953a6513aab0192ae55dc53c5ea84498e57e", "filename": "libstdc++-v3/testsuite/27_io/basic_stringstream/cons/char/1.cc", "status": "modified", "additions": 43, "deletions": 8, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/432258be4f2cf4f0970f106db319e3dbab4ab13d/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_stringstream%2Fcons%2Fchar%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/432258be4f2cf4f0970f106db319e3dbab4ab13d/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_stringstream%2Fcons%2Fchar%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_stringstream%2Fcons%2Fchar%2F1.cc?ref=432258be4f2cf4f0970f106db319e3dbab4ab13d", "patch": "@@ -33,7 +33,7 @@ test01()\n   std::stringstream stm(std::ios_base::in, a);\n }\n \n-auto const cstr = \"This is a test\";\n+auto const cstr = \"This is a test string\";\n \n void\n test02()\n@@ -57,29 +57,64 @@ test03()\n \n   {\n     std::stringstream::allocator_type a;\n-    std::stringstream sbuf(s1, mode, a);\n+    std::stringstream ss(s1, mode, a);\n     std::string s2(cstr);\n-    VERIFY( sbuf.str() == s2 );\n+    VERIFY( ss.str() == s2 );\n   }\n \n   {\n-    std::stringstream sbuf(s1, mode);\n+    std::stringstream ss(s1, mode);\n     std::string s2(cstr);\n-    VERIFY( sbuf.str() == s2 );\n+    VERIFY( ss.str() == s2 );\n   }\n \n   {\n-    std::stringstream sbuf(s1);\n+    std::stringstream ss(s1);\n     std::string s2(cstr);\n-    VERIFY( sbuf.str() == s2 );\n+    VERIFY( ss.str() == s2 );\n   }\n }\n \n+// A minimal allocator with no default constructor\n+template<typename T>\n+  struct NoDefaultCons : __gnu_test::SimpleAllocator<T>\n+  {\n+    using __gnu_test::SimpleAllocator<T>::SimpleAllocator;\n+\n+    NoDefaultCons() = delete;\n+\n+    NoDefaultCons(int) { }\n+  };\n+\n+void\n+test04()\n+{\n+  using sstream = std::basic_stringstream<char, std::char_traits<char>,\n+\t\t\t\t\t  NoDefaultCons<char>>;\n+\n+  NoDefaultCons<char> a(1);\n+  const std::string str(cstr);\n+\n+  sstream ss1(str, a);\n+  VERIFY( ss1.str() == cstr );\n+  VERIFY( ss1.get() == cstr[0] );\n+\n+  sstream ss2(str, std::ios::in, a);\n+  VERIFY( ss2.str() == cstr );\n+  VERIFY( ss2.get() == cstr[0] );\n+  VERIFY( !bool(ss2 << 1) );\n+\n+  sstream ss3(std::string(str), std::ios::out, a);\n+  VERIFY( ss3.str() == cstr );\n+  VERIFY( bool(ss3 << 1) );\n+  VERIFY( ss3.get() == std::wstringbuf::traits_type::eof() );\n+}\n+\n int\n main()\n {\n   test01();\n   test02();\n   test03();\n-  return 0;\n+  test04();\n }"}]}