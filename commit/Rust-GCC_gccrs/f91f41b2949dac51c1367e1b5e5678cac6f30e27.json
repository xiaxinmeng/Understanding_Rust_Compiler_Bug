{"sha": "f91f41b2949dac51c1367e1b5e5678cac6f30e27", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjkxZjQxYjI5NDlkYWM1MWMxMzY3ZTFiNWU1Njc4Y2FjNmYzMGUyNw==", "commit": {"author": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2003-08-01T18:41:40Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2003-08-01T18:41:40Z"}, "message": "c-decl.c (gettags, [...]): Delete.\n\n\t* c-decl.c (gettags, pushdecl_function_level): Delete.\n\t(last_function_parm_vars): Rename last_function_parm_others.\n\t(current_function_parm_vars): Rename current_function_parm_others.\n\t(struct c_scope): Rewrite comment explaining this data structure.\n\tAdd names_last, blocks_last, parms_last fields.  Rename\n\tincomplete_list to incomplete.\n\t(SCOPE_LIST_APPEND, SCOPE_LIST_CONCAT): New macros.\n\t(poplevel): Ignore second argument.  No need to nreverse\n\tanything.  Restructure such that each list is processed\n\texactly once.  Use 'const location_t *locus' syntactic sugar\n\tvariable where useful.  Issue unused variable warnings\n\tourselves, do not rely on function.c.\n\t(insert_block, pushdecl, bind_label): Use SCOPE_LIST_APPEND.\n\t(pushdecl_top_level): Likewise.  Don't call duplicate_decls.\n\t(implicitly_declare): decl cannot be error_mark_node.\n\t(undeclared_variable): Manipulate scope structure directly.\n\t(c_make_fname_decl): Likewise.\n\t(getdecls, c_init_decl_processing): Fix comment.\n\t(mark_forward_parm_decls): Use SCOPE_LIST_CONCAT.  No need\n\tfor 'last' variable.\n\t(grokparms): No need to nreverse parms list.\n\t(store_parm_decls_newstyle): Set up the parms_last and\n\tnames_last fields of the new scope too.\n\t(store_parm_decls_oldstyle): Can assume DECL_WEAK is not set\n\ton parms to begin with; check this under ENABLE_CHECKING.  Set\n\tup parms_last.\n\t(check_for_loop_decls): Refer directly to current_scope->tags.\n\tUse consistent quote style in diagnostics.\n\t(c_write_global_declarations): The names list is not backward.\n\n\t* c-common.h: Don't prototype gettags.\n\t* c-parse.in: Call poplevel with second argument 0 always.\n\nFrom-SVN: r70061", "tree": {"sha": "b78379f5b65e3815b2718d14618e418deacbbc47", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b78379f5b65e3815b2718d14618e418deacbbc47"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f91f41b2949dac51c1367e1b5e5678cac6f30e27", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f91f41b2949dac51c1367e1b5e5678cac6f30e27", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f91f41b2949dac51c1367e1b5e5678cac6f30e27", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f91f41b2949dac51c1367e1b5e5678cac6f30e27/comments", "author": null, "committer": null, "parents": [{"sha": "a8eb1db5500def99dd77a07692d38468649a90da", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a8eb1db5500def99dd77a07692d38468649a90da", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a8eb1db5500def99dd77a07692d38468649a90da"}], "stats": {"total": 574, "additions": 286, "deletions": 288}, "files": [{"sha": "1e697f24ffdb4a72660d622d8d974c696ee78ff7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 38, "deletions": 3, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f91f41b2949dac51c1367e1b5e5678cac6f30e27/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f91f41b2949dac51c1367e1b5e5678cac6f30e27/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f91f41b2949dac51c1367e1b5e5678cac6f30e27", "patch": "@@ -1,3 +1,38 @@\n+2003-08-01  Zack Weinberg  <zack@codesourcery.com>\n+\n+\t* c-decl.c (gettags, pushdecl_function_level): Delete.\n+\t(last_function_parm_vars): Rename last_function_parm_others.\n+\t(current_function_parm_vars): Rename current_function_parm_others.\n+\t(struct c_scope): Rewrite comment explaining this data structure.\n+\tAdd names_last, blocks_last, parms_last fields.  Rename\n+\tincomplete_list to incomplete.\n+\t(SCOPE_LIST_APPEND, SCOPE_LIST_CONCAT): New macros.\n+\t(poplevel): Ignore second argument.  No need to nreverse\n+\tanything.  Restructure such that each list is processed\n+\texactly once.  Use 'const location_t *locus' syntactic sugar\n+\tvariable where useful.  Issue unused variable warnings\n+\tourselves, do not rely on function.c.\n+\t(insert_block, pushdecl, bind_label): Use SCOPE_LIST_APPEND.\n+\t(pushdecl_top_level): Likewise.  Don't call duplicate_decls.\n+\t(implicitly_declare): decl cannot be error_mark_node.\n+\t(undeclared_variable): Manipulate scope structure directly.\n+\t(c_make_fname_decl): Likewise.\n+\t(getdecls, c_init_decl_processing): Fix comment.\n+\t(mark_forward_parm_decls): Use SCOPE_LIST_CONCAT.  No need\n+\tfor 'last' variable.\n+\t(grokparms): No need to nreverse parms list.\n+\t(store_parm_decls_newstyle): Set up the parms_last and\n+\tnames_last fields of the new scope too.\n+\t(store_parm_decls_oldstyle): Can assume DECL_WEAK is not set\n+\ton parms to begin with; check this under ENABLE_CHECKING.  Set\n+\tup parms_last.\n+\t(check_for_loop_decls): Refer directly to current_scope->tags.\n+\tUse consistent quote style in diagnostics.\n+\t(c_write_global_declarations): The names list is not backward.\n+\n+\t* c-common.h: Don't prototype gettags.\n+\t* c-parse.in: Call poplevel with second argument 0 always.\n+\n 2003-08-01  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* builtins.def: Resort builtins.\n@@ -194,8 +229,8 @@ Thu Jul 31 19:49:53 CEST 2003  Jan Hubicka  <jh@suse.cz>\n \n 2003-07-31  Vladimir Makarov  <vmakarov@redhat.com>\n \n-        * sched-deps.c (sched_analyze_2): Prevent interblock move of CC0\n-        setter.\n+\t* sched-deps.c (sched_analyze_2): Prevent interblock move of CC0\n+\tsetter.\n \n 2003-07-30  Roger Sayle  <roger@eyesopen.com>\n \n@@ -223,7 +258,7 @@ Thu Jul 31 19:49:53 CEST 2003  Jan Hubicka  <jh@suse.cz>\n \n 2003-07-31  Ulrich Weigand  <uweigand@de.ibm.com>\n \n-\t* config/s390/s390.md (UNSPEC_ROUND, UNSPEC_SETHIGH, \n+\t* config/s390/s390.md (UNSPEC_ROUND, UNSPEC_SETHIGH,\n \tUNSPECV_BLOCKAGE): New constants.\n \t(\"*sethighqisi\", \"*sethighhisi\", \"*sethiqidi_64\", \"*sethiqidi_31\",\n \t\"*extractqi\", \"*extracthi\", \"*extendqidi2\" splitter, \"*extendqisi2\""}, {"sha": "da673f62da1d2a7b45c779a5daec1f828eee8872", "filename": "gcc/c-common.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f91f41b2949dac51c1367e1b5e5678cac6f30e27/gcc%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f91f41b2949dac51c1367e1b5e5678cac6f30e27/gcc%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.h?ref=f91f41b2949dac51c1367e1b5e5678cac6f30e27", "patch": "@@ -318,7 +318,6 @@ struct c_language_function GTY(()) {\n extern void (*lang_expand_stmt) (tree);\n extern void (*lang_expand_decl_stmt) (tree);\n extern void (*lang_expand_function_end) (void);\n-extern tree gettags (void);\n \n /* Callback that determines if it's ok for a function to have no\n    noreturn attribute.  */"}, {"sha": "cfe1a8e8db59d2500736161158bc84dce9d05b77", "filename": "gcc/c-decl.c", "status": "modified", "additions": 247, "deletions": 283, "changes": 530, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f91f41b2949dac51c1367e1b5e5678cac6f30e27/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f91f41b2949dac51c1367e1b5e5678cac6f30e27/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=f91f41b2949dac51c1367e1b5e5678cac6f30e27", "patch": "@@ -97,7 +97,7 @@ static tree last_function_parm_tags;\n /* ... and a chain of all non-parameter declarations (such as\n    CONST_DECLs from enumerations) here.  */\n \n-static tree last_function_parm_vars;\n+static tree last_function_parm_others;\n \n /* After parsing the declarator that starts a function definition,\n    `start_function' puts the list of parameter names or chain of decls here\n@@ -109,9 +109,9 @@ static tree current_function_parms;\n \n static tree current_function_parm_tags;\n \n-/* And for last_function_parm_vars.  */\n+/* And for last_function_parm_others.  */\n \n-static tree current_function_parm_vars;\n+static tree current_function_parm_others;\n \n /* Similar, for the file and line that the prototype came from if this is\n    an old-style definition.  */\n@@ -162,18 +162,30 @@ static int warn_about_return_type;\n \n static int current_extern_inline;\n \f\n-/* For each binding contour we allocate a c_scope structure\n- * which records the names defined in that contour.\n- * Contours include:\n- *  0) the global one\n- *  1) one for each function definition,\n- *     where internal declarations of the parameters appear.\n- *  2) one for each compound statement,\n- *     to record its declarations.\n- *\n- * The current meaning of a name can be found by searching the nested\n- * scopes from the current one out to the global one.\n- */\n+/* Each c_scope structure describes the complete contents of one scope.\n+   Three scopes are distinguished specially: the innermost or current\n+   scope, the innermost function scope, and the outermost or file scope.\n+\n+   Most declarations are recorded in the current scope.\n+\n+   All normal label declarations are recorded in the innermost\n+   function scope, as are bindings of undeclared identifiers to\n+   error_mark_node.  (GCC permits nested functions as an extension,\n+   hence the 'innermost' qualifier.)  Explicitly declared labels\n+   (using the __label__ extension) appear in the current scope.\n+\n+   Being in the global scope (current_scope == global_scope) causes\n+   special behavior in several places below.  Also, under some\n+   conditions the Objective-C front end records declarations in the\n+   global scope even though that isn't the current scope.\n+\n+   The order of the names, parms, and blocks lists matters, and they\n+   are frequently appended to.  To avoid having to walk all the way to\n+   the end of the list on each insertion, or reverse the lists later,\n+   we maintain a pointer to the last list entry for each of the lists.\n+\n+   The order of the tags, shadowed, shadowed_tags, and incomplete\n+   lists does not matter, so we just prepend to these lists.  */\n \n struct c_scope GTY(())\n {\n@@ -183,13 +195,14 @@ struct c_scope GTY(())\n   /* The next outermost function scope.  */\n   struct c_scope *outer_function;\n \n-  /* All variables, constants, functions, labels, and typedef names.\n-     They are in the reverse of the order supplied.  */\n+  /* All variables, constants, functions, labels, and typedef names.  */\n   tree names;\n+  tree names_last;\n \n   /* All parameter declarations.  Used only in the outermost scope of\n-     a function.  Again, in the reverse of the order supplied.  */\n+     a function.  */\n   tree parms;\n+  tree parms_last;\n \n   /* All structure, union, and enum type tags.  */\n   tree tags;\n@@ -209,9 +222,10 @@ struct c_scope GTY(())\n   /* For each scope (except the global one), a chain of BLOCK nodes\n      for all the scopes that were entered and exited one level down.  */\n   tree blocks;\n+  tree blocks_last;\n \n   /* Variable declarations with incomplete type in this scope.  */\n-  tree incomplete_list;\n+  tree incomplete;\n \n   /* True if we are currently filling this scope with parameter\n      declarations.  */\n@@ -251,6 +265,28 @@ static GTY(()) struct c_scope *current_function_scope;\n \n static GTY(()) struct c_scope *global_scope;\n \n+/* Append VAR to LIST in scope SCOPE.  */\t\t\\\n+#define SCOPE_LIST_APPEND(scope, list, decl) do {\t\\\n+  struct c_scope *s_ = (scope);\t\t\t\t\\\n+  tree d_ = (decl);\t\t\t\t\t\\\n+  if (s_->list##_last)\t\t\t\t\t\\\n+    TREE_CHAIN (s_->list##_last) = d_;\t\t\t\\\n+  else\t\t\t\t\t\t\t\\\n+    s_->list = d_;\t\t\t\t\t\\\n+  s_->list##_last = d_;\t\t\t\t\t\\\n+} while (0)\n+\n+/* Concatenate FROM in scope FSCOPE onto TO in scope TSCOPE.  */\n+#define SCOPE_LIST_CONCAT(tscope, to, fscope, from) do {\t\\\n+  struct c_scope *t_ = (tscope);\t\t\t\t\\\n+  struct c_scope *f_ = (fscope);\t\t\t\t\\\n+  if (t_->to##_last)\t\t\t\t\t\t\\\n+    TREE_CHAIN (t_->to##_last) = f_->from;\t\t\t\\\n+  else\t\t\t\t\t\t\t\t\\\n+    t_->to = f_->from;\t\t\t\t\t\t\\\n+  t_->to##_last = f_->from##_last;\t\t\t\t\\\n+} while (0)\n+\n /* True means unconditionally make a BLOCK for the next scope pushed.  */\n \n static bool keep_next_level_flag;\n@@ -288,7 +324,6 @@ static tree any_external_decl (tree);\n static void record_external_decl (tree);\n static void warn_if_shadowing (tree, tree);\n static void clone_underlying_type (tree);\n-static void pushdecl_function_level (tree, tree);\n static bool flexible_array_type_p (tree);\n static hashval_t link_hash_hash\t(const void *);\n static int link_hash_eq (const void *, const void *);\n@@ -454,8 +489,8 @@ pushlevel (int dummy ATTRIBUTE_UNUSED)\n    debugging output.  If KEEP is KEEP_MAYBE, do so only if the names\n    or tags lists are nonempty.\n \n-   If REVERSE is nonzero, reverse the order of decls before putting\n-   them into the BLOCK.\n+   The second parameter is ignored; it is present only for\n+   signature compatibility with lang_hooks.decls.poplevel.\n \n    If FUNCTIONBODY is nonzero, this level is the body of a function,\n    even if current_scope->function_body is not set.  This is used\n@@ -465,186 +500,165 @@ pushlevel (int dummy ATTRIBUTE_UNUSED)\n    FIXME: Eliminate the need for all arguments.  */\n \n tree\n-poplevel (int keep, int reverse, int functionbody)\n+poplevel (int keep, int dummy ATTRIBUTE_UNUSED, int functionbody)\n {\n-  tree link;\n+  struct c_scope *scope = current_scope;\n   tree block;\n   tree decl;\n-  tree decls = current_scope->names;\n-  tree tags = current_scope->tags;\n-  tree subblocks = current_scope->blocks;\n+  tree p;\n \n-  functionbody |= current_scope->function_body;\n+  scope->function_body |= functionbody;\n \n   if (keep == KEEP_MAYBE)\n-    keep = (current_scope->names || current_scope->tags);\n-\n-  keep |= current_scope->keep;\n-  keep |= functionbody;\n-\n-  /* We used to warn about unused variables in expand_end_bindings,\n-     i.e. while generating RTL.  But in function-at-a-time mode we may\n-     choose to never expand a function at all (e.g. auto inlining), so\n-     we do this explicitly now.\n-     No warnings when the global scope is popped because the global\n-     scope isn't popped for the last translation unit, so the warnings\n-     are done in c_write_global_declaration.  */\n-  if (current_scope != global_scope)\n-    warn_about_unused_variables (decls);\n+    keep = (scope->names || scope->tags);\n+\n+  keep |= scope->keep;\n+  keep |= scope->function_body;\n+\n+  /* If appropriate, create a BLOCK to record the decls for the life\n+     of this function.  */\n+  block = 0;\n+  if (keep)\n+    {\n+      block = make_node (BLOCK);\n+      BLOCK_VARS (block) = scope->names;\n+      BLOCK_SUBBLOCKS (block) = scope->blocks;\n+      TREE_USED (block) = 1;\n+    }\n+\n+  /* In each subblock, record that this is its superior.  */\n+  for (p = scope->blocks; p; p = TREE_CHAIN (p))\n+    BLOCK_SUPERCONTEXT (p) = block;\n+\n+  /* Clear out the variable bindings in this scope.\n \n-  /* Clear out the name-meanings declared in this scope.\n      Propagate TREE_ADDRESSABLE from nested functions to their\n-     containing functions.  */\n-  for (link = decls; link; link = TREE_CHAIN (link))\n+     containing functions.\n+\n+     Issue warnings for unused variables and labels, and errors for\n+     undefined labels, if there are any.  */\n+\n+  for (p = scope->names; p; p = TREE_CHAIN (p))\n     {\n-      if (TREE_CODE (link) == LABEL_DECL)\n+      const location_t *locus = &DECL_SOURCE_LOCATION (p);\n+\n+      switch (TREE_CODE (p))\n \t{\n-\t  if (TREE_USED (link) && DECL_INITIAL (link) == 0)\n+\tcase LABEL_DECL:\n+\t  if (TREE_USED (p) && !DECL_INITIAL (p))\n \t    {\n-\t      error (\"%Hlabel `%D' used but not defined\",\n-\t\t     &DECL_SOURCE_LOCATION (link), link);\n-\t      /* Avoid crashing later.  */\n-\t      DECL_INITIAL (link) = error_mark_node;\n+\t      error (\"%Hlabel `%D' used but not defined\", locus, p);\n+\t      DECL_INITIAL (p) = error_mark_node;\n \t    }\n-\t  else if (!TREE_USED (link) && warn_unused_label)\n+\t  else if (!TREE_USED (p) && warn_unused_label)\n \t    {\n-\t      if (DECL_INITIAL (link) != 0)\n-\t\twarning (\"%Hlabel `%D' defined but not used\",\n-\t\t\t &DECL_SOURCE_LOCATION (link), link);\n+\t      if (DECL_INITIAL (p))\n+\t\twarning (\"%Hlabel `%D' defined but not used\", locus, p);\n \t      else\n-\t\twarning (\"%Hlabel `%D' declared but not defined\",\n-\t\t\t &DECL_SOURCE_LOCATION (link), link);\n+\t\twarning (\"%Hlabel `%D' declared but not defined\", locus, p);\n \t    }\n-\t  IDENTIFIER_LABEL_VALUE (DECL_NAME (link)) = 0;\n-\t}\n-      else if (DECL_NAME (link) != 0)\n-\t{\n-\t  if (DECL_EXTERNAL (link) \n-\t      && current_scope != global_scope)\n-\t    /* External decls stay in the symbol-value slot but are\n-\t       inaccessible.  */\n-\t    C_DECL_INVISIBLE (link) = 1;\n-\t  else\n-\t    IDENTIFIER_SYMBOL_VALUE (DECL_NAME (link)) = 0;\n-\t}\n \n-      if (TREE_CODE (link) == FUNCTION_DECL\n-\t  && ! TREE_ASM_WRITTEN (link)\n-\t  && DECL_INITIAL (link) != 0\n-\t  && TREE_ADDRESSABLE (link)\n-\t  && DECL_ABSTRACT_ORIGIN (link) != 0\n-\t  && DECL_ABSTRACT_ORIGIN (link) != link)\n-\tTREE_ADDRESSABLE (DECL_ABSTRACT_ORIGIN (link)) = 1;\n-    }\n+\t  IDENTIFIER_LABEL_VALUE (DECL_NAME (p)) = 0;\n+\t  break;\n \n-  /* Clear out the parameter bindings declared in this scope.\n-     Unused-parameter warnings are handled by function.c.  */\n-  for (link = current_scope->parms; link; link = TREE_CHAIN (link))\n-    if (DECL_NAME (link))\n-      IDENTIFIER_SYMBOL_VALUE (DECL_NAME (link)) = 0;\n+\tcase FUNCTION_DECL:\n+\t  if (! TREE_ASM_WRITTEN (p)\n+\t      && DECL_INITIAL (p) != 0\n+\t      && TREE_ADDRESSABLE (p)\n+\t      && DECL_ABSTRACT_ORIGIN (p) != 0\n+\t      && DECL_ABSTRACT_ORIGIN (p) != p)\n+\t    TREE_ADDRESSABLE (DECL_ABSTRACT_ORIGIN (p)) = 1;\n+\t  goto normal;\n+\n+\tcase VAR_DECL:\n+\t  /* keep this in sync with stmt.c:warn_about_unused_variables.\n+\t     No warnings when the global scope is popped because the\n+\t     global scope isn't popped for the last translation unit,\n+\t     so the warnings are done in c_write_global_declaration.  */\n+\t  if (warn_unused_variable && scope != global_scope\n+\t      && !TREE_USED (p)\n+\t      && !DECL_IN_SYSTEM_HEADER (p)\n+\t      && DECL_NAME (p)\n+\t      && !DECL_ARTIFICIAL (p))\n+\t    warning (\"%Hunused variable `%D'\", locus, p);\n+\t  /* fall through */\n \n-  /* Clear out the tag-meanings declared in this scope.  */\n-  for (link = tags; link; link = TREE_CHAIN (link))\n-    if (TREE_PURPOSE (link))\n-      IDENTIFIER_TAG_VALUE (TREE_PURPOSE (link)) = 0;\n+\tdefault:\n+\tnormal:\n+\t  if (DECL_NAME (p))\n+\t    {\n+\t      if (DECL_EXTERNAL (p) && scope != global_scope)\n+\t\t/* External decls stay in the symbol-value slot but are\n+\t\t   inaccessible.  */\n+\t\tC_DECL_INVISIBLE (p) = 1;\n+\t      else\n+\t\tIDENTIFIER_SYMBOL_VALUE (DECL_NAME (p)) = 0;\n+\t    }\n+\t  break;\n+\t}\n+    }\n \n-  /* Restore all name- and label-meanings from outer scopes that were\n-     shadowed by this scope.  */\n+  /* Clear out the parameter bindings in this scope, if any.\n+     Unused-parameter warnings are handled by function.c.  */\n+  for (p = scope->parms; p; p = TREE_CHAIN (p))\n+    if (DECL_NAME (p))\n+      IDENTIFIER_SYMBOL_VALUE (DECL_NAME (p)) = 0;\n \n-  for (link = current_scope->shadowed; link; link = TREE_CHAIN (link))\n-    if (TREE_VALUE (link) && TREE_CODE (TREE_VALUE (link)) == LABEL_DECL)\n-      IDENTIFIER_LABEL_VALUE (TREE_PURPOSE (link)) = TREE_VALUE (link);\n-    else\n-      IDENTIFIER_SYMBOL_VALUE (TREE_PURPOSE (link)) = TREE_VALUE (link);\n+  /* Clear out the tag-meanings declared in this scope.\n \n-  /* Restore all tag-meanings from outer scopes that were shadowed by\n-     this scope.  */\n+     Set the TYPE_CONTEXTs for all of the tagged types belonging to\n+     this scope so that they point to the appropriate construct, i.e.\n+     either to the current FUNCTION_DECL node, or else to the BLOCK\n+     node we just constructed.\n \n-  for (link = current_scope->shadowed_tags; link;\n-       link = TREE_CHAIN (link))\n-    IDENTIFIER_TAG_VALUE (TREE_PURPOSE (link)) = TREE_VALUE (link);\n+     Note that for tagged types whose scope is just the formal\n+     parameter list for some function type specification, we can't\n+     properly set their TYPE_CONTEXTs here, because we don't have a\n+     pointer to the appropriate FUNCTION_TYPE node readily available\n+     to us.  For those cases, the TYPE_CONTEXTs of the relevant tagged\n+     type nodes get set in `grokdeclarator' as soon as we have created\n+     the FUNCTION_TYPE node which will represent the \"scope\" for these\n+     \"parameter list local\" tagged types.  */\n \n-  /* If this is the outermost block of a function, remove all\n-     PARM_DECLs from current_scope->names; they are already\n-     stored in DECL_ARGUMENTS of cfun->decl in proper order, should\n-     not be put in BLOCK_VARS, and furthermore reversing them will\n-     cause trouble later.  They are all together at the end of the\n-     list.  */\n-  if (functionbody && decls)\n+  decl = scope->function_body ? current_function_decl : block;\n+  for (p = scope->tags; p; p = TREE_CHAIN (p))\n     {\n-      if (TREE_CODE (decls) == PARM_DECL)\n-\tdecls = 0;\n-      else\n-\t{\n-\t  link = decls;\n-\t  while (TREE_CHAIN (link)\n-\t\t && TREE_CODE (TREE_CHAIN (link)) != PARM_DECL)\n-\t    link = TREE_CHAIN (link);\n-\n-\t  TREE_CHAIN (link) = 0;\n-\t}\n+      if (TREE_PURPOSE (p))\n+\tIDENTIFIER_TAG_VALUE (TREE_PURPOSE (p)) = 0;\n+      if (decl)\n+\tTYPE_CONTEXT (TREE_VALUE (p)) = decl;\n     }\n \n-  /* Get the decls in the order they were written.\n-     Usually current_scope->names is in reverse order.\n-     But parameter decls were previously put in forward order.  */\n-\n-  if (reverse)\n-    decls = nreverse (decls);\n+  /* Restore all name- and label-meanings from outer scopes that were\n+     shadowed by this scope.  */\n+  for (p = scope->shadowed; p; p = TREE_CHAIN (p))\n+    if (TREE_VALUE (p) && TREE_CODE (TREE_VALUE (p)) == LABEL_DECL)\n+      IDENTIFIER_LABEL_VALUE (TREE_PURPOSE (p)) = TREE_VALUE (p);\n+    else\n+      IDENTIFIER_SYMBOL_VALUE (TREE_PURPOSE (p)) = TREE_VALUE (p);\n \n-  /* If appropriate, create a BLOCK to record the decls for the life\n-     of this function.  */\n+  /* Restore all tag-meanings from outer scopes that were shadowed by\n+     this scope.  */\n+  for (p = scope->shadowed_tags; p; p = TREE_CHAIN (p))\n+    IDENTIFIER_TAG_VALUE (TREE_PURPOSE (p)) = TREE_VALUE (p);\n \n-  block = 0;\n-  if (keep)\n+  /* Dispose of the block that we just made inside some higher level.  */\n+  if (scope->function_body)\n+    DECL_INITIAL (current_function_decl) = block;\n+  else if (scope->outer)\n     {\n-      block = make_node (BLOCK);\n-      BLOCK_VARS (block) = decls;\n-      BLOCK_SUBBLOCKS (block) = subblocks;\n-      TREE_USED (block) = 1;\n+      if (block)\n+\tSCOPE_LIST_APPEND (scope->outer, blocks, block);\n+      /* If we did not make a block for the scope just exited, any\n+\t blocks made for inner scopes must be carried forward so they\n+\t will later become subblocks of something else.  */\n+      else if (scope->blocks)\n+\tSCOPE_LIST_CONCAT (scope->outer, blocks, scope, blocks);\n     }\n \n-  /* In each subblock, record that this is its superior.  */\n-\n-  for (link = subblocks; link; link = TREE_CHAIN (link))\n-    BLOCK_SUPERCONTEXT (link) = block;\n-\n-  /* Set the TYPE_CONTEXTs for all of the tagged types belonging to this\n-     binding contour so that they point to the appropriate construct, i.e.\n-     either to the current FUNCTION_DECL node, or else to the BLOCK node\n-     we just constructed.\n-\n-     Note that for tagged types whose scope is just the formal parameter\n-     list for some function type specification, we can't properly set\n-     their TYPE_CONTEXTs here, because we don't have a pointer to the\n-     appropriate FUNCTION_TYPE node readily available to us.  For those\n-     cases, the TYPE_CONTEXTs of the relevant tagged type nodes get set\n-     in `grokdeclarator' as soon as we have created the FUNCTION_TYPE\n-     node which will represent the \"scope\" for these \"parameter list local\"\n-     tagged types.  */\n-\n-  decl = functionbody ? current_function_decl : block;\n-  if (decl)\n-    for (link = tags; link; link = TREE_CHAIN (link))\n-      TYPE_CONTEXT (TREE_VALUE (link)) = decl;\n-\n   /* Pop the current scope, and free the structure for reuse.  */\n   pop_scope ();\n \n-  /* Dispose of the block that we just made inside some higher level.  */\n-  if (functionbody)\n-    DECL_INITIAL (current_function_decl) = block;\n-  else if (block && current_scope)\n-    current_scope->blocks\n-      = chainon (current_scope->blocks, block);\n-  /* If we did not make a block for the scope just exited, any blocks\n-     made for inner scopes (since they cannot be recorded as subblocks\n-     here) must be carried forward so they will later become subblocks\n-     of something else.  */\n-  else if (! block && subblocks)\n-    current_scope->blocks\n-      = chainon (current_scope->blocks, subblocks);\n-\n   return block;\n }\n \n@@ -656,8 +670,7 @@ void\n insert_block (tree block)\n {\n   TREE_USED (block) = 1;\n-  current_scope->blocks\n-    = chainon (current_scope->blocks, block);\n+  SCOPE_LIST_APPEND (current_scope, blocks, block);\n }\n \n /* Set the BLOCK node for the innermost scope (the one we are\n@@ -1687,8 +1700,8 @@ pushdecl (tree x)\n \t\tif (*p == old)\n \t\t  {\n \t\t    *p = TREE_CHAIN (old);\n-\t\t    TREE_CHAIN (old) = scope->parms;\n-\t\t    scope->parms = old;\n+\t\t    SCOPE_LIST_APPEND (scope, parms, old);\n+\t\t    break;\n \t\t  }\n \t    }\n \t  return old;\n@@ -1748,88 +1761,41 @@ pushdecl (tree x)\n \t    element = TREE_TYPE (element);\n \t  if (TREE_CODE (element) == RECORD_TYPE\n \t      || TREE_CODE (element) == UNION_TYPE)\n-\t    scope->incomplete_list = tree_cons (NULL_TREE, x,\n-\t\t\t\t\t\tscope->incomplete_list);\n+\t    scope->incomplete = tree_cons (NULL_TREE, x, scope->incomplete);\n \t}\n     }\n \n-  /* Put decls on list in reverse order.\n-     We will reverse them later if necessary.  */\n   if (TREE_CODE (x) == PARM_DECL)\n-    {\n-      TREE_CHAIN (x) = scope->parms;\n-      scope->parms = x;\n-    }\n+    SCOPE_LIST_APPEND (scope, parms, x);\n   else\n-    {\n-      TREE_CHAIN (x) = scope->names;\n-      scope->names = x;\n-    }\n+    SCOPE_LIST_APPEND (scope, names, x);\n \n   return x;\n }\n \n /* Record X as belonging to the global scope (C99 \"file scope\").\n    This is used only internally by the Objective-C front end,\n-   and is limited to its needs.  It will hork if there is _any_\n-   visible binding for X (not just a global one).  */\n+   and is limited to its needs.  duplicate_decls is not called;\n+   if there is any preexisting decl for this identifier, it is an ICE.  */\n+\n tree\n pushdecl_top_level (tree x)\n {\n-  tree name, old;\n+  tree name;\n \n   if (TREE_CODE (x) != VAR_DECL)\n     abort ();\n \n   name = DECL_NAME (x);\n-  old = IDENTIFIER_SYMBOL_VALUE (name);\n-\n-  if (old)\n-    {\n-      if (DECL_CONTEXT (old))\n-\tabort ();\n \n-      if (!duplicate_decls (x, old, 0, false))\n-\tabort ();\n-\n-      return old;\n-    }\n+  if (IDENTIFIER_SYMBOL_VALUE (name))\n+    abort ();\n \n   DECL_CONTEXT (x) = current_file_decl;\n   IDENTIFIER_SYMBOL_VALUE (name) = x;\n-  TREE_CHAIN (x) = global_scope->names;\n-  global_scope->names = x;\n-  return x;\n-}\n-\n-/* Record X as belonging to the outermost scope of the current\n-   function.  This is used only internally, by c_make_fname_decl and\n-   undeclared_variable, and is limited to their needs.  The NAME is\n-   provided as a separate argument because undeclared_variable wants to\n-   use error_mark_node for X.  For VAR_DECLs, duplicate_decls is not\n-   called; if there is any preexisting decl for this identifier, it is\n-   an ICE.  */\n-static void\n-pushdecl_function_level (tree x, tree name)\n-{\n-  struct c_scope *scope = current_function_scope;\n-\n-  if (x == error_mark_node)\n-    scope->shadowed = tree_cons (name, IDENTIFIER_SYMBOL_VALUE (name),\n-\t\t\t\t scope->shadowed);\n-  else if (TREE_CODE (x) == VAR_DECL)\n-    {\n-      if (name != DECL_NAME (x))\n-\tabort ();\n-      if (IDENTIFIER_SYMBOL_VALUE (name))\n-\tabort ();\n \n-      DECL_CONTEXT (x) = current_function_decl;\n-      TREE_CHAIN (x) = scope->names;\n-      scope->names = x;\n-    }\n-\n-  IDENTIFIER_SYMBOL_VALUE (name) = x;\n+  SCOPE_LIST_APPEND (global_scope, names, x);\n+  return x;\n }\n \f\n /* Generate an implicit declaration for identifier FUNCTIONID as a\n@@ -1840,7 +1806,7 @@ implicitly_declare (tree functionid)\n {\n   tree decl = any_external_decl (functionid);\n \n-  if (decl && decl != error_mark_node)\n+  if (decl)\n     {\n       /* Implicit declaration of a function already declared\n \t (somehow) in a different scope, or as a built-in.\n@@ -1969,12 +1935,13 @@ void\n undeclared_variable (tree id)\n {\n   static bool already = false;\n+  struct c_scope *scope;\n \n   if (current_function_decl == 0)\n     {\n       error (\"`%s' undeclared here (not in a function)\",\n \t     IDENTIFIER_POINTER (id));\n-      IDENTIFIER_SYMBOL_VALUE (id) = error_mark_node;\n+      scope = current_scope;\n     }\n   else\n     {\n@@ -1988,8 +1955,12 @@ undeclared_variable (tree id)\n \t  already = true;\n \t}\n \n-      pushdecl_function_level (error_mark_node, id);\n+      scope = current_function_scope;\n     }\n+\n+  scope->shadowed = tree_cons (id, IDENTIFIER_SYMBOL_VALUE (id),\n+\t\t\t       scope->shadowed);\n+  IDENTIFIER_SYMBOL_VALUE (id) = error_mark_node;\n }\n \f\n /* Subroutine of lookup_label, declare_label, define_label: construct a\n@@ -2018,8 +1989,7 @@ bind_label (tree name, tree label, struct c_scope *scope)\n \t\t\t\t scope->shadowed);\n   IDENTIFIER_LABEL_VALUE (name) = label;\n \n-  TREE_CHAIN (label) = scope->names;\n-  scope->names = label;\n+  SCOPE_LIST_APPEND (scope, names, label);\n }\n \n /* Get the LABEL_DECL corresponding to identifier NAME as a label.\n@@ -2152,22 +2122,14 @@ define_label (location_t location, tree name)\n   return label;\n }\n \f\n-/* Return the list of declarations of the current scope.\n-   Note that this list is in reverse order.  */\n+/* Return the list of declarations of the current scope.  */\n \n tree\n getdecls (void)\n {\n   return current_scope->names;\n }\n \n-/* Return the list of type-tags (for structs, etc) of the current scope.  */\n-\n-tree\n-gettags (void)\n-{\n-  return current_scope->tags;\n-}\n \f\n /* Given NAME, an IDENTIFIER_NODE,\n    return the structure (or union or enum) definition for that name.\n@@ -2334,8 +2296,7 @@ c_init_decl_processing (void)\n    NAME depended on the type of the function.  As we don't yet implement\n    delayed emission of static data, we mark the decl as emitted\n    so it is not placed in the output.  Anything using it must therefore pull\n-   out the STRING_CST initializer directly.  This does mean that these names\n-   are string merging candidates, which is wrong for C99's __func__.  FIXME.  */\n+   out the STRING_CST initializer directly.  FIXME.  */\n \n static tree\n c_make_fname_decl (tree id, int type_dep)\n@@ -2361,7 +2322,11 @@ c_make_fname_decl (tree id, int type_dep)\n   TREE_USED (decl) = 1;\n \n   if (current_function_decl)\n-    pushdecl_function_level (decl, DECL_NAME (decl));\n+    {\n+      DECL_CONTEXT (decl) = current_function_decl;\n+      IDENTIFIER_SYMBOL_VALUE (id) = decl;\n+      SCOPE_LIST_APPEND (current_function_scope, names, decl);\n+    }\n \n   finish_decl (decl, init, NULL_TREE);\n \n@@ -3041,29 +3006,27 @@ push_parm_decl (tree parm)\n   immediate_size_expand = save_immediate_size_expand;\n }\n \n-/* Shift all the existing parameter decls to the variables list,\n-   and reset the parameters list.  Used when a ; terminating\n-   forward parameter decls is encountered.  */\n+/* Mark all the parameter declarations to date as forward decls,\n+   shift them to the variables list, and reset the parameters list.\n+   Also diagnose use of this extension.  */\n \n void\n mark_forward_parm_decls (void)\n {\n-  tree parm, last;\n+  tree parm;\n \n   if (pedantic && !current_scope->warned_forward_parm_decls)\n     {\n       pedwarn (\"ISO C forbids forward parameter declarations\");\n       current_scope->warned_forward_parm_decls = true;\n     }\n \n-  for (last = 0, parm = current_scope->parms;\n-       parm;\n-       last = parm, parm = TREE_CHAIN (parm))\n+  for (parm = current_scope->parms; parm; parm = TREE_CHAIN (parm))\n     TREE_ASM_WRITTEN (parm) = 1;\n \n-  TREE_CHAIN (last)    = current_scope->names;\n-  current_scope->names = current_scope->parms;\n+  SCOPE_LIST_CONCAT (current_scope, names, current_scope, parms);\n   current_scope->parms = 0;\n+  current_scope->parms_last = 0;\n }\n \f\n static GTY(()) int compound_literal_number;\n@@ -4516,7 +4479,7 @@ grokparms (tree parms_info, int funcdef_flag)\n \n   last_function_parms = TREE_PURPOSE (parms_info);\n   last_function_parm_tags = TREE_VALUE (parms_info);\n-  last_function_parm_vars = TREE_TYPE (parms_info);\n+  last_function_parm_others = TREE_TYPE (parms_info);\n \n   if (warn_strict_prototypes && first_parm == 0 && !funcdef_flag\n       && !in_system_header)\n@@ -4611,9 +4574,6 @@ get_parm_info (int void_at_end)\n       return tree_cons (0, 0, tree_cons (0, void_type_node, 0));\n     }\n \n-  if (parms)\n-    current_scope->parms = parms = nreverse (parms);\n-\n   /* Sanity check all of the parameter declarations.  */\n   for (decl = parms; decl; decl = TREE_CHAIN (decl))\n     {\n@@ -5196,11 +5156,11 @@ finish_struct (tree t, tree fieldlist, tree attributes)\n   /* If this structure or union completes the type of any previous\n      variable declaration, lay it out and output its rtl.  */\n \n-  if (current_scope->incomplete_list != NULL_TREE)\n+  if (current_scope->incomplete != NULL_TREE)\n     {\n       tree prev = NULL_TREE;\n \n-      for (x = current_scope->incomplete_list; x; x = TREE_CHAIN (x))\n+      for (x = current_scope->incomplete; x; x = TREE_CHAIN (x))\n         {\n \t  tree decl = TREE_VALUE (x);\n \n@@ -5218,7 +5178,7 @@ finish_struct (tree t, tree fieldlist, tree attributes)\n \t      if (prev)\n \t\tTREE_CHAIN (prev) = TREE_CHAIN (x);\n \t      else\n-\t        current_scope->incomplete_list = TREE_CHAIN (x);\n+\t        current_scope->incomplete = TREE_CHAIN (x);\n \t    }\n \t  else if (!COMPLETE_TYPE_P (TREE_TYPE (decl))\n \t\t   && TREE_CODE (TREE_TYPE (decl)) == ARRAY_TYPE)\n@@ -5242,7 +5202,7 @@ finish_struct (tree t, tree fieldlist, tree attributes)\n \t\t  if (prev)\n \t\t    TREE_CHAIN (prev) = TREE_CHAIN (x);\n \t\t  else\n-\t\t    current_scope->incomplete_list = TREE_CHAIN (x);\n+\t\t    current_scope->incomplete = TREE_CHAIN (x);\n \t\t}\n \t    }\n \t}\n@@ -5567,7 +5527,7 @@ start_function (tree declspecs, tree declarator, tree attributes)\n      where store_parm_decls will find them.  */\n   current_function_parms = last_function_parms;\n   current_function_parm_tags = last_function_parm_tags;\n-  current_function_parm_vars = last_function_parm_vars;\n+  current_function_parm_others = last_function_parm_others;\n \n   /* Make the init_value nonzero so pushdecl knows this is not tentative.\n      error_mark_node is replaced below (in poplevel) with the BLOCK.  */\n@@ -5749,11 +5709,11 @@ start_function (tree declspecs, tree declarator, tree attributes)\n static void\n store_parm_decls_newstyle (void)\n {\n-  tree decl;\n+  tree decl, last;\n   tree fndecl = current_function_decl;\n   tree parms = current_function_parms;\n   tree tags = current_function_parm_tags;\n-  tree vars = current_function_parm_vars;\n+  tree others = current_function_parm_others;\n \n   if (current_scope->parms || current_scope->names || current_scope->tags)\n     {\n@@ -5767,10 +5727,9 @@ store_parm_decls_newstyle (void)\n \n   /* Now make all the parameter declarations visible in the function body.\n      We can bypass most of the grunt work of pushdecl.  */\n-  for (decl = parms; decl; decl = TREE_CHAIN (decl))\n+  for (last = 0, decl = parms; decl; last = decl, decl = TREE_CHAIN (decl))\n     {\n       DECL_CONTEXT (decl) = current_function_decl;\n-\n       if (DECL_NAME (decl) == 0)\n \terror (\"%Hparameter name omitted\", &DECL_SOURCE_LOCATION (decl));\n       else\n@@ -5784,12 +5743,13 @@ store_parm_decls_newstyle (void)\n \t}\n     }\n   current_scope->parms = parms;\n+  current_scope->parms_last = last;\n \n   /* Record the parameter list in the function declaration.  */\n   DECL_ARGUMENTS (fndecl) = parms;\n \n   /* Now make all the ancillary declarations visible, likewise.  */\n-  for (decl = vars; decl; decl = TREE_CHAIN (decl))\n+  for (last = 0, decl = others; decl; last = decl, decl = TREE_CHAIN (decl))\n     {\n       DECL_CONTEXT (decl) = current_function_decl;\n       if (DECL_NAME (decl)\n@@ -5803,7 +5763,8 @@ store_parm_decls_newstyle (void)\n \t  IDENTIFIER_SYMBOL_VALUE (DECL_NAME (decl)) = decl;\n \t}\n     }\n-  current_scope->names = vars;\n+  current_scope->names = others;\n+  current_scope->names_last = last;\n \n   /* And all the tag declarations.  */\n   for (decl = tags; decl; decl = TREE_CHAIN (decl))\n@@ -5832,9 +5793,12 @@ store_parm_decls_oldstyle (void)\n   tree parmids = current_function_parms;\n \n   /* We use DECL_WEAK as a flag to show which parameters have been\n-     seen already, since it is not used on PARM_DECL or CONST_DECL.  */\n+     seen already, since it is not used on PARM_DECL.  */\n+#ifdef ENABLE_CHECKING\n   for (parm = current_scope->parms; parm; parm = TREE_CHAIN (parm))\n-    DECL_WEAK (parm) = 0;\n+    if (DECL_WEAK (parm))\n+      abort ();\n+#endif\n \n   /* Match each formal parameter name with its declaration.  Save each\n      decl in the appropriate TREE_PURPOSE slot of the parmids chain.  */\n@@ -5939,6 +5903,7 @@ store_parm_decls_oldstyle (void)\n \t    last = TREE_PURPOSE (parm);\n \t    DECL_WEAK (last) = 0;\n \t  }\n+      current_scope->parms_last = last;\n       TREE_CHAIN (last) = 0;\n     }\n \n@@ -6472,7 +6437,7 @@ check_for_loop_decls (void)\n       /* If we get here, declarations have been used in a for loop without\n \t the C99 for loop scope.  This doesn't make much sense, so don't\n \t allow it.  */\n-      error (\"`for' loop initial declaration used outside C99 mode\");\n+      error (\"'for' loop initial declaration used outside C99 mode\");\n       return;\n     }\n   /* C99 subclause 6.8.5 paragraph 3:\n@@ -6489,20 +6454,20 @@ check_for_loop_decls (void)\n      interpretation, to avoid creating an extension which later causes\n      problems.  */\n \n-  for (t = gettags (); t; t = TREE_CHAIN (t))\n+  for (t = current_scope->tags; t; t = TREE_CHAIN (t))\n     {\n       if (TREE_PURPOSE (t) != 0)\n         {\n           enum tree_code code = TREE_CODE (TREE_VALUE (t));\n \n           if (code == RECORD_TYPE)\n-            error (\"`struct %s' declared in `for' loop initial declaration\",\n+            error (\"'struct %s' declared in 'for' loop initial declaration\",\n                    IDENTIFIER_POINTER (TREE_PURPOSE (t)));\n           else if (code == UNION_TYPE)\n-            error (\"`union %s' declared in `for' loop initial declaration\",\n+            error (\"'union %s' declared in 'for' loop initial declaration\",\n                    IDENTIFIER_POINTER (TREE_PURPOSE (t)));\n           else\n-            error (\"`enum %s' declared in `for' loop initial declaration\",\n+            error (\"'enum %s' declared in 'for' loop initial declaration\",\n                    IDENTIFIER_POINTER (TREE_PURPOSE (t)));\n         }\n     }\n@@ -6515,7 +6480,7 @@ check_for_loop_decls (void)\n                \"initial declaration\", locus, t);\n       else if (TREE_STATIC (t))\n \terror (\"%Hdeclaration of static variable '%D' in 'for' loop \"\n-               \"initial declaration\", locus, t);\n+\t       \"initial declaration\", locus, t);\n       else if (DECL_EXTERNAL (t))\n \terror (\"%Hdeclaration of 'extern' variable '%D' in 'for' loop \"\n                \"initial declaration\", locus, t);\n@@ -6885,11 +6850,10 @@ c_write_global_declarations(void)\n       int i;\n       tree decl;\n       \n-      /* Process the decls in reverse order--earliest first.\n-\t Put them into VEC from back to front, then take out from front.  */\n-      \n+      /* Process the decls in the order they were written.  */\n+\n       for (i = 0, decl = globals; i < len; i++, decl = TREE_CHAIN (decl))\n-\tvec[len - i - 1] = decl;\n+\tvec[i] = decl;\n       \n       wrapup_global_declarations (vec, len);\n       "}, {"sha": "2ae875e70ade551c3cd0b8502d2e3e49410d727a", "filename": "gcc/c-parse.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f91f41b2949dac51c1367e1b5e5678cac6f30e27/gcc%2Fc-parse.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f91f41b2949dac51c1367e1b5e5678cac6f30e27/gcc%2Fc-parse.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parse.in?ref=f91f41b2949dac51c1367e1b5e5678cac6f30e27", "patch": "@@ -2135,7 +2135,7 @@ compstmt_start: '{' { compstmt_count++;\n compstmt_nostart: '}'\n \t\t{ $$ = convert (void_type_node, integer_zero_node); }\n \t| pushlevel maybe_label_decls compstmt_contents_nonempty '}' poplevel\n-\t\t{ $$ = poplevel (KEEP_MAYBE, 1, 0);\n+\t\t{ $$ = poplevel (KEEP_MAYBE, 0, 0);\n \t\t  SCOPE_STMT_BLOCK (TREE_PURPOSE ($5))\n \t\t    = SCOPE_STMT_BLOCK (TREE_VALUE ($5))\n \t\t    = $$; }"}]}