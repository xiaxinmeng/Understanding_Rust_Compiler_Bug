{"sha": "f1bd2543dbb95d13b56ff8fc27c6a88842abe422", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjFiZDI1NDNkYmI5NWQxM2I1NmZmOGZjMjdjNmE4ODg0MmFiZTQyMg==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2007-02-04T14:28:00Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2007-02-04T14:28:00Z"}, "message": "* passes.c (init_optimization_passes): Reindent.\n\nFrom-SVN: r121573", "tree": {"sha": "38f8a57fe18988b9859e10bd8fbbbe06fc8561cf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/38f8a57fe18988b9859e10bd8fbbbe06fc8561cf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f1bd2543dbb95d13b56ff8fc27c6a88842abe422", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f1bd2543dbb95d13b56ff8fc27c6a88842abe422", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f1bd2543dbb95d13b56ff8fc27c6a88842abe422", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f1bd2543dbb95d13b56ff8fc27c6a88842abe422/comments", "author": null, "committer": null, "parents": [{"sha": "1084e689538f05f1ccf59403f6358e41fd56c5d6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1084e689538f05f1ccf59403f6358e41fd56c5d6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1084e689538f05f1ccf59403f6358e41fd56c5d6"}], "stats": {"total": 524, "additions": 266, "deletions": 258}, "files": [{"sha": "e757d1e8f74c3cfe47d36a5128774562f3ba33ec", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1bd2543dbb95d13b56ff8fc27c6a88842abe422/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1bd2543dbb95d13b56ff8fc27c6a88842abe422/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f1bd2543dbb95d13b56ff8fc27c6a88842abe422", "patch": "@@ -1,3 +1,7 @@\n+2007-02-04  Jan Hubicka  <jh@suse.cz>\n+\n+\t* passes.c (init_optimization_passes): Reindent.\n+\n 2007-02-04  Jan Hubicka  <jh@suse.cz>\n \t    Eric Botcazou  <ebotcazou@libertysurf.fr>\n "}, {"sha": "104e2934d28c7c269a7057ac675c526f57b02564", "filename": "gcc/passes.c", "status": "modified", "additions": 262, "deletions": 258, "changes": 520, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1bd2543dbb95d13b56ff8fc27c6a88842abe422/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1bd2543dbb95d13b56ff8fc27c6a88842abe422/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=f1bd2543dbb95d13b56ff8fc27c6a88842abe422", "patch": "@@ -427,7 +427,6 @@ next_pass_1 (struct tree_opt_pass **list, struct tree_opt_pass *pass)\n        cgraph_expand_all_functions ()\n            for each node N in the cgraph\n \t       cgraph_expand_function (N)\n-\t           cgraph_lower_function (N)\t-> Now a NOP.\n \t\t   lang_hooks.callgraph.expand_function (DECL (N))\n \t\t   \ttree_rest_of_compilation (DECL (N))  -> all_passes\n */\n@@ -439,28 +438,10 @@ init_optimization_passes (void)\n \n #define NEXT_PASS(PASS)  (p = next_pass_1 (p, &PASS))\n \n-  /* Interprocedural optimization passes.  */\n-  p = &all_ipa_passes;\n-  NEXT_PASS (pass_ipa_function_and_variable_visibility);\n-  NEXT_PASS (pass_ipa_early_inline);\n-  NEXT_PASS (pass_early_local_passes);\n-  NEXT_PASS (pass_ipa_increase_alignment);\n-  NEXT_PASS (pass_ipa_cp);\n-  NEXT_PASS (pass_ipa_inline);\n-  NEXT_PASS (pass_ipa_reference);\n-  NEXT_PASS (pass_ipa_pure_const); \n-  NEXT_PASS (pass_ipa_type_escape);\n-  NEXT_PASS (pass_ipa_pta);\n-  *p = NULL;\n-\n-  p = &pass_ipa_early_inline.sub;\n-  NEXT_PASS (pass_early_inline);\n-  NEXT_PASS (pass_inline_parameters);\n-  NEXT_PASS (pass_rebuild_cgraph_edges);\n-  *p = NULL;\n-\n-  /* All passes needed to lower the function into shape optimizers can\n-     operate on.  */\n+ /* All passes needed to lower the function into shape optimizers can\n+    operate on.  These passes are always run first on the function, but\n+    backend might produce already lowered functions that are not processed\n+    by these passes.  */\n   p = &all_lowering_passes;\n   NEXT_PASS (pass_remove_useless_stmts);\n   NEXT_PASS (pass_mudflap_1);\n@@ -475,255 +456,278 @@ init_optimization_passes (void)\n   NEXT_PASS (pass_inline_parameters);\n   *p = NULL;\n \n-  p = &pass_early_local_passes.sub;\n-  NEXT_PASS (pass_tree_profile);\n-  NEXT_PASS (pass_cleanup_cfg);\n-  NEXT_PASS (pass_init_datastructures);\n-  NEXT_PASS (pass_expand_omp);\n-  NEXT_PASS (pass_all_early_optimizations);\n-  NEXT_PASS (pass_rebuild_cgraph_edges);\n-  NEXT_PASS (pass_inline_parameters);\n-  *p = NULL;\n-\n-  p = &pass_all_early_optimizations.sub;\n-  NEXT_PASS (pass_referenced_vars);\n-  NEXT_PASS (pass_reset_cc_flags);\n-  NEXT_PASS (pass_build_ssa);\n-  NEXT_PASS (pass_early_warn_uninitialized);\n-  NEXT_PASS (pass_rebuild_cgraph_edges);\n-  NEXT_PASS (pass_early_inline);\n-  NEXT_PASS (pass_cleanup_cfg);\n-  NEXT_PASS (pass_rename_ssa_copies);\n-  NEXT_PASS (pass_ccp);\n-  \n-  NEXT_PASS (pass_forwprop);\n-  NEXT_PASS (pass_sra);\n-  NEXT_PASS (pass_copy_prop);\n-  NEXT_PASS (pass_merge_phi);\n-  NEXT_PASS (pass_dce);\n-  NEXT_PASS (pass_tail_recursion);\n-  NEXT_PASS (pass_release_ssa_names);\n-\n+  /* Interprocedural optimization passes. \n+     All these passes are ignored in -fno-unit-at-a-time\n+     except for subpases of early_local_pases.  */\n+  p = &all_ipa_passes;\n+  NEXT_PASS (pass_ipa_function_and_variable_visibility);\n+  NEXT_PASS (pass_ipa_early_inline);\n+    {\n+      struct tree_opt_pass **p = &pass_ipa_early_inline.sub;\n+      NEXT_PASS (pass_early_inline);\n+      NEXT_PASS (pass_inline_parameters);\n+      NEXT_PASS (pass_rebuild_cgraph_edges);\n+    }\n+  NEXT_PASS (pass_early_local_passes);\n+    {\n+      struct tree_opt_pass **p = &pass_early_local_passes.sub;\n+      NEXT_PASS (pass_tree_profile);\n+      NEXT_PASS (pass_cleanup_cfg);\n+      NEXT_PASS (pass_init_datastructures);\n+      NEXT_PASS (pass_expand_omp);\n+      NEXT_PASS (pass_all_early_optimizations);\n+\t{\n+\t  struct tree_opt_pass **p = &pass_all_early_optimizations.sub;\n+\t  NEXT_PASS (pass_referenced_vars);\n+\t  NEXT_PASS (pass_reset_cc_flags);\n+\t  NEXT_PASS (pass_build_ssa);\n+\t  NEXT_PASS (pass_early_warn_uninitialized);\n+\t  NEXT_PASS (pass_rebuild_cgraph_edges);\n+\t  NEXT_PASS (pass_early_inline);\n+\t  NEXT_PASS (pass_cleanup_cfg);\n+\t  NEXT_PASS (pass_rename_ssa_copies);\n+\t  NEXT_PASS (pass_ccp);\n+\t  NEXT_PASS (pass_forwprop);\n+\t  NEXT_PASS (pass_sra);\n+\t  NEXT_PASS (pass_copy_prop);\n+\t  NEXT_PASS (pass_merge_phi);\n+\t  NEXT_PASS (pass_dce);\n+\t  NEXT_PASS (pass_tail_recursion);\n+\t  NEXT_PASS (pass_release_ssa_names);\n+\t}\n+      NEXT_PASS (pass_rebuild_cgraph_edges);\n+      NEXT_PASS (pass_inline_parameters);\n+    }\n+  NEXT_PASS (pass_ipa_increase_alignment);\n+  NEXT_PASS (pass_ipa_cp);\n+  NEXT_PASS (pass_ipa_inline);\n+  NEXT_PASS (pass_ipa_reference);\n+  NEXT_PASS (pass_ipa_pure_const); \n+  NEXT_PASS (pass_ipa_type_escape);\n+  NEXT_PASS (pass_ipa_pta);\n   *p = NULL;\n \n+  /* These passes are run after IPA passes on every function that is being output\n+     to the assemlber file.  */\n   p = &all_passes;\n   NEXT_PASS (pass_apply_inline);\n   NEXT_PASS (pass_all_optimizations);\n+    {\n+      struct tree_opt_pass **p = &pass_all_optimizations.sub;\n+      NEXT_PASS (pass_create_structure_vars);\n+      NEXT_PASS (pass_may_alias);\n+      NEXT_PASS (pass_return_slot);\n+      NEXT_PASS (pass_rename_ssa_copies);\n+\n+      /* Initial scalar cleanups.  */\n+      NEXT_PASS (pass_ccp);\n+      NEXT_PASS (pass_fre);\n+      NEXT_PASS (pass_dce);\n+      NEXT_PASS (pass_forwprop);\n+      NEXT_PASS (pass_copy_prop);\n+      NEXT_PASS (pass_merge_phi);\n+      NEXT_PASS (pass_vrp);\n+      NEXT_PASS (pass_dce);\n+      NEXT_PASS (pass_dominator);\n+\n+      /* The only const/copy propagation opportunities left after\n+\t DOM should be due to degenerate PHI nodes.  So rather than\n+\t run the full propagators, run a specialized pass which\n+\t only examines PHIs to discover const/copy propagation\n+\t opportunities.  */\n+      NEXT_PASS (pass_phi_only_cprop);\n+\n+      NEXT_PASS (pass_phiopt);\n+      NEXT_PASS (pass_may_alias);\n+      NEXT_PASS (pass_tail_recursion);\n+      NEXT_PASS (pass_profile);\n+      NEXT_PASS (pass_ch);\n+      NEXT_PASS (pass_stdarg);\n+      NEXT_PASS (pass_lower_complex);\n+      NEXT_PASS (pass_sra);\n+      /* FIXME: SRA may generate arbitrary gimple code, exposing new\n+\t aliased and call-clobbered variables.  As mentioned below,\n+\t pass_may_alias should be a TODO item.  */\n+      NEXT_PASS (pass_may_alias);\n+      NEXT_PASS (pass_rename_ssa_copies);\n+      NEXT_PASS (pass_dominator);\n+\n+      /* The only const/copy propagation opportunities left after\n+\t DOM should be due to degenerate PHI nodes.  So rather than\n+\t run the full propagators, run a specialized pass which\n+\t only examines PHIs to discover const/copy propagation\n+\t opportunities.  */\n+      NEXT_PASS (pass_phi_only_cprop);\n+\n+      NEXT_PASS (pass_reassoc);\n+      NEXT_PASS (pass_dce);\n+      NEXT_PASS (pass_dse);\n+      NEXT_PASS (pass_may_alias);\n+      NEXT_PASS (pass_forwprop);\n+      NEXT_PASS (pass_phiopt);\n+      NEXT_PASS (pass_object_sizes);\n+      NEXT_PASS (pass_store_ccp);\n+      NEXT_PASS (pass_store_copy_prop);\n+      NEXT_PASS (pass_fold_builtins);\n+      NEXT_PASS (pass_cse_sincos);\n+      /* FIXME: May alias should a TODO but for 4.0.0,\n+\t we add may_alias right after fold builtins\n+\t which can create arbitrary GIMPLE.  */\n+      NEXT_PASS (pass_may_alias);\n+      NEXT_PASS (pass_split_crit_edges);\n+      NEXT_PASS (pass_pre);\n+      NEXT_PASS (pass_may_alias);\n+      NEXT_PASS (pass_sink_code);\n+      NEXT_PASS (pass_tree_loop);\n+\t{\n+\t  struct tree_opt_pass **p = &pass_tree_loop.sub;\n+\t  NEXT_PASS (pass_tree_loop_init);\n+\t  NEXT_PASS (pass_copy_prop);\n+\t  NEXT_PASS (pass_lim);\n+\t  NEXT_PASS (pass_tree_unswitch);\n+\t  NEXT_PASS (pass_scev_cprop);\n+\t  NEXT_PASS (pass_empty_loop);\n+\t  NEXT_PASS (pass_record_bounds);\n+\t  NEXT_PASS (pass_linear_transform);\n+\t  NEXT_PASS (pass_iv_canon);\n+\t  NEXT_PASS (pass_if_conversion);\n+\t  NEXT_PASS (pass_vectorize);\n+\t    {\n+\t      struct tree_opt_pass **p = &pass_vectorize.sub;\n+\t      NEXT_PASS (pass_lower_vector_ssa);\n+\t      NEXT_PASS (pass_dce_loop);\n+\t    }\n+\t  /* NEXT_PASS (pass_may_alias) cannot be done again because the\n+\t     vectorizer creates alias relations that are not supported by\n+\t     pass_may_alias.  */\n+\t  NEXT_PASS (pass_complete_unroll);\n+\t  NEXT_PASS (pass_loop_prefetch);\n+\t  NEXT_PASS (pass_iv_optimize);\n+\t  NEXT_PASS (pass_tree_loop_done);\n+\t}\n+      NEXT_PASS (pass_cse_reciprocals);\n+      NEXT_PASS (pass_reassoc);\n+      NEXT_PASS (pass_vrp);\n+      NEXT_PASS (pass_dominator);\n+\n+      /* The only const/copy propagation opportunities left after\n+\t DOM should be due to degenerate PHI nodes.  So rather than\n+\t run the full propagators, run a specialized pass which\n+\t only examines PHIs to discover const/copy propagation\n+\t opportunities.  */\n+      NEXT_PASS (pass_phi_only_cprop);\n+\n+      NEXT_PASS (pass_cd_dce);\n+\n+      /* FIXME: If DCE is not run before checking for uninitialized uses,\n+\t we may get false warnings (e.g., testsuite/gcc.dg/uninit-5.c).\n+\t However, this also causes us to misdiagnose cases that should be\n+\t real warnings (e.g., testsuite/gcc.dg/pr18501.c).\n+\t \n+\t To fix the false positives in uninit-5.c, we would have to\n+\t account for the predicates protecting the set and the use of each\n+\t variable.  Using a representation like Gated Single Assignment\n+\t may help.  */\n+      NEXT_PASS (pass_late_warn_uninitialized);\n+      NEXT_PASS (pass_dse);\n+      NEXT_PASS (pass_forwprop);\n+      NEXT_PASS (pass_phiopt);\n+      NEXT_PASS (pass_tail_calls);\n+      NEXT_PASS (pass_rename_ssa_copies);\n+      NEXT_PASS (pass_uncprop);\n+      NEXT_PASS (pass_del_ssa);\n+      NEXT_PASS (pass_nrv);\n+      NEXT_PASS (pass_mark_used_blocks);\n+      NEXT_PASS (pass_cleanup_cfg_post_optimizing);\n+    }\n   NEXT_PASS (pass_warn_function_noreturn);\n   NEXT_PASS (pass_free_datastructures);\n   NEXT_PASS (pass_mudflap_2);\n   NEXT_PASS (pass_free_cfg_annotations);\n   NEXT_PASS (pass_expand);\n   NEXT_PASS (pass_rest_of_compilation);\n+    {\n+      struct tree_opt_pass **p = &pass_rest_of_compilation.sub;\n+      NEXT_PASS (pass_init_function);\n+      NEXT_PASS (pass_jump);\n+      NEXT_PASS (pass_insn_locators_initialize);\n+      NEXT_PASS (pass_rtl_eh);\n+      NEXT_PASS (pass_initial_value_sets);\n+      NEXT_PASS (pass_unshare_all_rtl);\n+      NEXT_PASS (pass_instantiate_virtual_regs);\n+      NEXT_PASS (pass_jump2);\n+      NEXT_PASS (pass_lower_subreg);\n+      NEXT_PASS (pass_cse);\n+      NEXT_PASS (pass_rtl_fwprop);\n+      NEXT_PASS (pass_gcse);\n+      NEXT_PASS (pass_jump_bypass);\n+      NEXT_PASS (pass_rtl_ifcvt);\n+      NEXT_PASS (pass_tracer);\n+      /* Perform loop optimizations.  It might be better to do them a bit\n+\t sooner, but we want the profile feedback to work more\n+\t efficiently.  */\n+      NEXT_PASS (pass_loop2);\n+\t{\n+\t  struct tree_opt_pass **p = &pass_loop2.sub;\n+\t  NEXT_PASS (pass_rtl_loop_init);\n+\t  NEXT_PASS (pass_rtl_move_loop_invariants);\n+\t  NEXT_PASS (pass_rtl_unswitch);\n+\t  NEXT_PASS (pass_rtl_unroll_and_peel_loops);\n+\t  NEXT_PASS (pass_rtl_doloop);\n+\t  NEXT_PASS (pass_rtl_loop_done);\n+\t  *p = NULL;\n+\t}\n+      NEXT_PASS (pass_web);\n+      NEXT_PASS (pass_cse2);\n+      NEXT_PASS (pass_rtl_fwprop_addr);\n+      NEXT_PASS (pass_life);\n+      NEXT_PASS (pass_combine);\n+      NEXT_PASS (pass_if_after_combine);\n+      NEXT_PASS (pass_partition_blocks);\n+      NEXT_PASS (pass_regmove);\n+      NEXT_PASS (pass_split_all_insns);\n+      NEXT_PASS (pass_lower_subreg2);\n+      NEXT_PASS (pass_mode_switching);\n+      NEXT_PASS (pass_see);\n+      NEXT_PASS (pass_recompute_reg_usage);\n+      NEXT_PASS (pass_sms);\n+      NEXT_PASS (pass_sched);\n+      NEXT_PASS (pass_local_alloc);\n+      NEXT_PASS (pass_global_alloc);\n+      NEXT_PASS (pass_postreload);\n+\t{\n+\t  struct tree_opt_pass **p = &pass_postreload.sub;\n+\t  NEXT_PASS (pass_postreload_cse);\n+\t  NEXT_PASS (pass_gcse2);\n+\t  NEXT_PASS (pass_flow2);\n+\t  NEXT_PASS (pass_rtl_seqabstr);\n+\t  NEXT_PASS (pass_stack_adjustments);\n+\t  NEXT_PASS (pass_peephole2);\n+\t  NEXT_PASS (pass_if_after_reload);\n+\t  NEXT_PASS (pass_regrename);\n+\t  NEXT_PASS (pass_reorder_blocks);\n+\t  NEXT_PASS (pass_branch_target_load_optimize);\n+\t  NEXT_PASS (pass_leaf_regs);\n+\t  NEXT_PASS (pass_sched2);\n+\t  NEXT_PASS (pass_split_before_regstack);\n+\t  NEXT_PASS (pass_stack_regs);\n+\t  NEXT_PASS (pass_compute_alignments);\n+\t  NEXT_PASS (pass_duplicate_computed_gotos);\n+\t  NEXT_PASS (pass_variable_tracking);\n+\t  NEXT_PASS (pass_free_cfg);\n+\t  NEXT_PASS (pass_machine_reorg);\n+\t  NEXT_PASS (pass_cleanup_barriers);\n+\t  NEXT_PASS (pass_delay_slots);\n+\t  NEXT_PASS (pass_split_for_shorten_branches);\n+\t  NEXT_PASS (pass_convert_to_eh_region_ranges);\n+\t  NEXT_PASS (pass_shorten_branches);\n+\t  NEXT_PASS (pass_set_nothrow_function_flags);\n+\t  NEXT_PASS (pass_final);\n+\t}\n+    }\n   NEXT_PASS (pass_clean_state);\n   *p = NULL;\n \n-  p = &pass_all_optimizations.sub;\n-  NEXT_PASS (pass_create_structure_vars);\n-  NEXT_PASS (pass_may_alias);\n-  NEXT_PASS (pass_return_slot);\n-  NEXT_PASS (pass_rename_ssa_copies);\n-\n-  /* Initial scalar cleanups.  */\n-  NEXT_PASS (pass_ccp);\n-  NEXT_PASS (pass_fre);\n-  NEXT_PASS (pass_dce);\n-  NEXT_PASS (pass_forwprop);\n-  NEXT_PASS (pass_copy_prop);\n-  NEXT_PASS (pass_merge_phi);\n-  NEXT_PASS (pass_vrp);\n-  NEXT_PASS (pass_dce);\n-  NEXT_PASS (pass_dominator);\n-\n-  /* The only const/copy propagation opportunities left after\n-     DOM should be due to degenerate PHI nodes.  So rather than\n-     run the full propagators, run a specialized pass which\n-     only examines PHIs to discover const/copy propagation\n-     opportunities.  */\n-  NEXT_PASS (pass_phi_only_cprop);\n-\n-  NEXT_PASS (pass_phiopt);\n-  NEXT_PASS (pass_may_alias);\n-  NEXT_PASS (pass_tail_recursion);\n-  NEXT_PASS (pass_profile);\n-  NEXT_PASS (pass_ch);\n-  NEXT_PASS (pass_stdarg);\n-  NEXT_PASS (pass_lower_complex);\n-  NEXT_PASS (pass_sra);\n-  /* FIXME: SRA may generate arbitrary gimple code, exposing new\n-     aliased and call-clobbered variables.  As mentioned below,\n-     pass_may_alias should be a TODO item.  */\n-  NEXT_PASS (pass_may_alias);\n-  NEXT_PASS (pass_rename_ssa_copies);\n-  NEXT_PASS (pass_dominator);\n-\n-  /* The only const/copy propagation opportunities left after\n-     DOM should be due to degenerate PHI nodes.  So rather than\n-     run the full propagators, run a specialized pass which\n-     only examines PHIs to discover const/copy propagation\n-     opportunities.  */\n-  NEXT_PASS (pass_phi_only_cprop);\n-\n-  NEXT_PASS (pass_reassoc);\n-  NEXT_PASS (pass_dce);\n-  NEXT_PASS (pass_dse);\n-  NEXT_PASS (pass_may_alias);\n-  NEXT_PASS (pass_forwprop);\n-  NEXT_PASS (pass_phiopt);\n-  NEXT_PASS (pass_object_sizes);\n-  NEXT_PASS (pass_store_ccp);\n-  NEXT_PASS (pass_store_copy_prop);\n-  NEXT_PASS (pass_fold_builtins);\n-  NEXT_PASS (pass_cse_sincos);\n-  /* FIXME: May alias should a TODO but for 4.0.0,\n-     we add may_alias right after fold builtins\n-     which can create arbitrary GIMPLE.  */\n-  NEXT_PASS (pass_may_alias);\n-  NEXT_PASS (pass_split_crit_edges);\n-  NEXT_PASS (pass_pre);\n-  NEXT_PASS (pass_may_alias);\n-  NEXT_PASS (pass_sink_code);\n-  NEXT_PASS (pass_tree_loop);\n-  NEXT_PASS (pass_cse_reciprocals);\n-  NEXT_PASS (pass_reassoc);\n-  NEXT_PASS (pass_vrp);\n-  NEXT_PASS (pass_dominator);\n-\n-  /* The only const/copy propagation opportunities left after\n-     DOM should be due to degenerate PHI nodes.  So rather than\n-     run the full propagators, run a specialized pass which\n-     only examines PHIs to discover const/copy propagation\n-     opportunities.  */\n-  NEXT_PASS (pass_phi_only_cprop);\n-\n-  NEXT_PASS (pass_cd_dce);\n-\n-  /* FIXME: If DCE is not run before checking for uninitialized uses,\n-     we may get false warnings (e.g., testsuite/gcc.dg/uninit-5.c).\n-     However, this also causes us to misdiagnose cases that should be\n-     real warnings (e.g., testsuite/gcc.dg/pr18501.c).\n-     \n-     To fix the false positives in uninit-5.c, we would have to\n-     account for the predicates protecting the set and the use of each\n-     variable.  Using a representation like Gated Single Assignment\n-     may help.  */\n-  NEXT_PASS (pass_late_warn_uninitialized);\n-  NEXT_PASS (pass_dse);\n-  NEXT_PASS (pass_forwprop);\n-  NEXT_PASS (pass_phiopt);\n-  NEXT_PASS (pass_tail_calls);\n-  NEXT_PASS (pass_rename_ssa_copies);\n-  NEXT_PASS (pass_uncprop);\n-  NEXT_PASS (pass_del_ssa);\n-  NEXT_PASS (pass_nrv);\n-  NEXT_PASS (pass_mark_used_blocks);\n-  NEXT_PASS (pass_cleanup_cfg_post_optimizing);\n-  *p = NULL;\n-\n-  p = &pass_tree_loop.sub;\n-  NEXT_PASS (pass_tree_loop_init);\n-  NEXT_PASS (pass_copy_prop);\n-  NEXT_PASS (pass_lim);\n-  NEXT_PASS (pass_tree_unswitch);\n-  NEXT_PASS (pass_scev_cprop);\n-  NEXT_PASS (pass_empty_loop);\n-  NEXT_PASS (pass_record_bounds);\n-  NEXT_PASS (pass_linear_transform);\n-  NEXT_PASS (pass_iv_canon);\n-  NEXT_PASS (pass_if_conversion);\n-  NEXT_PASS (pass_vectorize);\n-  /* NEXT_PASS (pass_may_alias) cannot be done again because the\n-     vectorizer creates alias relations that are not supported by\n-     pass_may_alias.  */\n-  NEXT_PASS (pass_complete_unroll);\n-  NEXT_PASS (pass_loop_prefetch);\n-  NEXT_PASS (pass_iv_optimize);\n-  NEXT_PASS (pass_tree_loop_done);\n-  *p = NULL;\n-\n-  p = &pass_vectorize.sub;\n-  NEXT_PASS (pass_lower_vector_ssa);\n-  NEXT_PASS (pass_dce_loop);\n-  *p = NULL;\n-\n-  p = &pass_loop2.sub;\n-  NEXT_PASS (pass_rtl_loop_init);\n-  NEXT_PASS (pass_rtl_move_loop_invariants);\n-  NEXT_PASS (pass_rtl_unswitch);\n-  NEXT_PASS (pass_rtl_unroll_and_peel_loops);\n-  NEXT_PASS (pass_rtl_doloop);\n-  NEXT_PASS (pass_rtl_loop_done);\n-  *p = NULL;\n-  \n-  p = &pass_rest_of_compilation.sub;\n-  NEXT_PASS (pass_init_function);\n-  NEXT_PASS (pass_jump);\n-  NEXT_PASS (pass_insn_locators_initialize);\n-  NEXT_PASS (pass_rtl_eh);\n-  NEXT_PASS (pass_initial_value_sets);\n-  NEXT_PASS (pass_unshare_all_rtl);\n-  NEXT_PASS (pass_instantiate_virtual_regs);\n-  NEXT_PASS (pass_jump2);\n-  NEXT_PASS (pass_lower_subreg);\n-  NEXT_PASS (pass_cse);\n-  NEXT_PASS (pass_rtl_fwprop);\n-  NEXT_PASS (pass_gcse);\n-  NEXT_PASS (pass_jump_bypass);\n-  NEXT_PASS (pass_rtl_ifcvt);\n-  NEXT_PASS (pass_tracer);\n-  /* Perform loop optimizations.  It might be better to do them a bit\n-     sooner, but we want the profile feedback to work more\n-     efficiently.  */\n-  NEXT_PASS (pass_loop2);\n-  NEXT_PASS (pass_web);\n-  NEXT_PASS (pass_cse2);\n-  NEXT_PASS (pass_rtl_fwprop_addr);\n-  NEXT_PASS (pass_life);\n-  NEXT_PASS (pass_combine);\n-  NEXT_PASS (pass_if_after_combine);\n-  NEXT_PASS (pass_partition_blocks);\n-  NEXT_PASS (pass_regmove);\n-  NEXT_PASS (pass_split_all_insns);\n-  NEXT_PASS (pass_lower_subreg2);\n-  NEXT_PASS (pass_mode_switching);\n-  NEXT_PASS (pass_see);\n-  NEXT_PASS (pass_recompute_reg_usage);\n-  NEXT_PASS (pass_sms);\n-  NEXT_PASS (pass_sched);\n-  NEXT_PASS (pass_local_alloc);\n-  NEXT_PASS (pass_global_alloc);\n-  NEXT_PASS (pass_postreload);\n-  *p = NULL;\n-\n-  p = &pass_postreload.sub;\n-  NEXT_PASS (pass_postreload_cse);\n-  NEXT_PASS (pass_gcse2);\n-  NEXT_PASS (pass_flow2);\n-  NEXT_PASS (pass_rtl_seqabstr);\n-  NEXT_PASS (pass_stack_adjustments);\n-  NEXT_PASS (pass_peephole2);\n-  NEXT_PASS (pass_if_after_reload);\n-  NEXT_PASS (pass_regrename);\n-  NEXT_PASS (pass_reorder_blocks);\n-  NEXT_PASS (pass_branch_target_load_optimize);\n-  NEXT_PASS (pass_leaf_regs);\n-  NEXT_PASS (pass_sched2);\n-  NEXT_PASS (pass_split_before_regstack);\n-  NEXT_PASS (pass_stack_regs);\n-  NEXT_PASS (pass_compute_alignments);\n-  NEXT_PASS (pass_duplicate_computed_gotos);\n-  NEXT_PASS (pass_variable_tracking);\n-  NEXT_PASS (pass_free_cfg);\n-  NEXT_PASS (pass_machine_reorg);\n-  NEXT_PASS (pass_cleanup_barriers);\n-  NEXT_PASS (pass_delay_slots);\n-  NEXT_PASS (pass_split_for_shorten_branches);\n-  NEXT_PASS (pass_convert_to_eh_region_ranges);\n-  NEXT_PASS (pass_shorten_branches);\n-  NEXT_PASS (pass_set_nothrow_function_flags);\n-  NEXT_PASS (pass_final);\n-  *p = NULL;\n-\n #undef NEXT_PASS\n \n   /* Register the passes with the tree dump code.  */"}]}