{"sha": "292689c213a6cbf75983bf9274b2a336ae0ae910", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjkyNjg5YzIxM2E2Y2JmNzU5ODNiZjkyNzRiMmEzMzZhZTBhZTkxMA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-10-24T09:28:21Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-10-24T09:28:21Z"}, "message": "[multiple changes]\n\n2011-10-24  Emmanuel Briot  <briot@adacore.com>\n\n\t* prj-proc.adb (Process_Expression_Variable_Decl): No special\n\thandling for Project_Path unless it is an attribute.\n\n2011-10-24  Javier Miranda  <miranda@adacore.com>\n\n\t* sem_ch12.adb (Check_Hidden_Primitives): New subprogram.\n\t(Install_Hidden_Primitives): New subprogram.\n\t(Restore_Hidden_Primitives): New subprogram.\n\t(Analyze_Formal_Package_Declaration,\n\tAnalyze_Package_Instantiation, Analyze_Subprogram_Instantiation):\n\tInvoke Check_Hidden_Primitives after every call to\n\tAnalyze_Associations, and invoke Restore_Hidden_Primitives to\n\trestore their visibility after processing the instantiation.\n\t(Instantiate_Package_Body): Install visible primitives before\n\tanalyzing the instantiation and uninstall them to restore their\n\tvisibility when the instantiation has been analyzed.\n\t* sem_util.ads, sem_util.adb (Add_Suffix): New subprogram\n\t(Remove_Suffix): New subprogram\n\t* sem_ch3.adb (Derive_Subprogram): When handling\n\ta derived subprogram for the instantiation of a formal derived\n\ttagged type, inherit the dispatching attributes from the actual\n\tsubprogram (not from the parent type).\n\nFrom-SVN: r180370", "tree": {"sha": "dc5131aaa30f31746ad74e3a7ccd0d6891584186", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dc5131aaa30f31746ad74e3a7ccd0d6891584186"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/292689c213a6cbf75983bf9274b2a336ae0ae910", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/292689c213a6cbf75983bf9274b2a336ae0ae910", "html_url": "https://github.com/Rust-GCC/gccrs/commit/292689c213a6cbf75983bf9274b2a336ae0ae910", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/292689c213a6cbf75983bf9274b2a336ae0ae910/comments", "author": null, "committer": null, "parents": [{"sha": "db4b3c499d935e5764d9aaf8b3239f8968029376", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/db4b3c499d935e5764d9aaf8b3239f8968029376", "html_url": "https://github.com/Rust-GCC/gccrs/commit/db4b3c499d935e5764d9aaf8b3239f8968029376"}], "stats": {"total": 335, "additions": 319, "deletions": 16}, "files": [{"sha": "3a21df4383efbe78c3c5e93a6d467560c87ffcab", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/292689c213a6cbf75983bf9274b2a336ae0ae910/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/292689c213a6cbf75983bf9274b2a336ae0ae910/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=292689c213a6cbf75983bf9274b2a336ae0ae910", "patch": "@@ -1,3 +1,28 @@\n+2011-10-24  Emmanuel Briot  <briot@adacore.com>\n+\n+\t* prj-proc.adb (Process_Expression_Variable_Decl): No special\n+\thandling for Project_Path unless it is an attribute.\n+\n+2011-10-24  Javier Miranda  <miranda@adacore.com>\n+\n+\t* sem_ch12.adb (Check_Hidden_Primitives): New subprogram.\n+\t(Install_Hidden_Primitives): New subprogram.\n+\t(Restore_Hidden_Primitives): New subprogram.\n+\t(Analyze_Formal_Package_Declaration,\n+\tAnalyze_Package_Instantiation, Analyze_Subprogram_Instantiation):\n+\tInvoke Check_Hidden_Primitives after every call to\n+\tAnalyze_Associations, and invoke Restore_Hidden_Primitives to\n+\trestore their visibility after processing the instantiation.\n+\t(Instantiate_Package_Body): Install visible primitives before\n+\tanalyzing the instantiation and uninstall them to restore their\n+\tvisibility when the instantiation has been analyzed.\n+\t* sem_util.ads, sem_util.adb (Add_Suffix): New subprogram\n+\t(Remove_Suffix): New subprogram\n+\t* sem_ch3.adb (Derive_Subprogram): When handling\n+\ta derived subprogram for the instantiation of a formal derived\n+\ttagged type, inherit the dispatching attributes from the actual\n+\tsubprogram (not from the parent type).\n+\n 2011-10-24  Vasiliy Fofanov  <fofanov@adacore.com>\n \n \t* gnat_ugn.texi: Document explicit use of XDECGNAT library."}, {"sha": "8e5060be243d3002bf3c341d2d8e98455e4e2bde", "filename": "gcc/ada/prj-proc.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/292689c213a6cbf75983bf9274b2a336ae0ae910/gcc%2Fada%2Fprj-proc.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/292689c213a6cbf75983bf9274b2a336ae0ae910/gcc%2Fada%2Fprj-proc.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-proc.adb?ref=292689c213a6cbf75983bf9274b2a336ae0ae910", "patch": "@@ -2053,7 +2053,7 @@ package body Prj.Proc is\n             Shared.Variable_Elements.Table (Var).Value := New_Value;\n          end if;\n \n-         if Name = Snames.Name_Project_Path then\n+         if Is_Attribute and then Name = Snames.Name_Project_Path then\n             if In_Tree.Is_Root_Tree then\n                declare\n                   Val : String_List_Id := New_Value.Values;"}, {"sha": "befd210ccb20fd2f35dfec89bb2c2fb9564d3fff", "filename": "gcc/ada/sem_ch12.adb", "status": "modified", "additions": 259, "deletions": 10, "changes": 269, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/292689c213a6cbf75983bf9274b2a336ae0ae910/gcc%2Fada%2Fsem_ch12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/292689c213a6cbf75983bf9274b2a336ae0ae910/gcc%2Fada%2Fsem_ch12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch12.adb?ref=292689c213a6cbf75983bf9274b2a336ae0ae910", "patch": "@@ -29,6 +29,7 @@ with Einfo;    use Einfo;\n with Elists;   use Elists;\n with Errout;   use Errout;\n with Expander; use Expander;\n+with Exp_Disp; use Exp_Disp;\n with Fname;    use Fname;\n with Fname.UF; use Fname.UF;\n with Freeze;   use Freeze;\n@@ -399,6 +400,13 @@ package body Sem_Ch12 is\n    --  package cannot be inlined by the front-end because front-end inlining\n    --  requires a strict linear order of elaboration.\n \n+   function Check_Hidden_Primitives (Assoc_List : List_Id) return Elist_Id;\n+   --  Check if some association between formals and actuals requires to make\n+   --  visible primitives of a tagged type, and make those primitives visible.\n+   --  Return the list of primitives whose visibility is modified (to restore\n+   --  their visibility later through Restore_Hidden_Primitives). If no\n+   --  candidate is found then return No_Elist.\n+\n    procedure Check_Hidden_Child_Unit\n      (N           : Node_Id;\n       Gen_Unit    : Entity_Id;\n@@ -556,6 +564,18 @@ package body Sem_Ch12 is\n    procedure Remove_Parent (In_Body : Boolean := False);\n    --  Reverse effect after instantiation of child is complete\n \n+   procedure Install_Hidden_Primitives\n+     (Prims_List : in out Elist_Id;\n+      Gen_T      : Entity_Id;\n+      Act_T      : Entity_Id);\n+   --  Remove suffix 'P' from hidden primitives of Act_T to match the\n+   --  visibility of primitives of Gen_T. The list of primitives to which\n+   --  the suffix is removed is added to Prims_List to restore them later.\n+\n+   procedure Restore_Hidden_Primitives (Prims_List : in out Elist_Id);\n+   --  Restore suffix 'P' to primitives of Prims_List and leave Prims_List\n+   --  set to No_Elist.\n+\n    procedure Inline_Instance_Body\n      (N        : Node_Id;\n       Gen_Unit : Entity_Id;\n@@ -884,7 +904,6 @@ package body Sem_Ch12 is\n       Formals : List_Id;\n       F_Copy  : List_Id) return List_Id\n    is\n-\n       Actual_Types    : constant Elist_Id  := New_Elmt_List;\n       Assoc           : constant List_Id   := New_List;\n       Default_Actuals : constant Elist_Id  := New_Elmt_List;\n@@ -2039,6 +2058,10 @@ package body Sem_Ch12 is\n       Renaming_In_Par  : Entity_Id;\n       Associations     : Boolean := True;\n \n+      Vis_Prims_List : Elist_Id := No_Elist;\n+      --  List of primitives made temporarily visible in the instantiation\n+      --  to match the visibility of the formal type\n+\n       function Build_Local_Package return Node_Id;\n       --  The formal package is rewritten so that its parameters are replaced\n       --  with corresponding declarations. For parameters with bona fide\n@@ -2124,9 +2147,11 @@ package body Sem_Ch12 is\n \n                Decls :=\n                  Analyze_Associations\n-                   (Original_Node (N),\n-                      Generic_Formal_Declarations (Act_Tree),\n-                      Generic_Formal_Declarations (Gen_Decl));\n+                   (I_Node  => Original_Node (N),\n+                    Formals => Generic_Formal_Declarations (Act_Tree),\n+                    F_Copy  => Generic_Formal_Declarations (Gen_Decl));\n+\n+               Vis_Prims_List := Check_Hidden_Primitives (Decls);\n             end;\n          end if;\n \n@@ -2263,6 +2288,7 @@ package body Sem_Ch12 is\n             Enter_Name (Formal);\n             Set_Ekind  (Formal, E_Variable);\n             Set_Etype  (Formal, Any_Type);\n+            Restore_Hidden_Primitives (Vis_Prims_List);\n \n             if Parent_Installed then\n                Remove_Parent;\n@@ -2336,6 +2362,7 @@ package body Sem_Ch12 is\n       end;\n \n       End_Package_Scope (Formal);\n+      Restore_Hidden_Primitives (Vis_Prims_List);\n \n       if Parent_Installed then\n          Remove_Parent;\n@@ -3131,6 +3158,12 @@ package body Sem_Ch12 is\n          return False;\n       end Might_Inline_Subp;\n \n+      --  Local declarations\n+\n+      Vis_Prims_List : Elist_Id := No_Elist;\n+      --  List of primitives made temporarily visible in the instantiation\n+      --  to match the visibility of the formal type\n+\n    --  Start of processing for Analyze_Package_Instantiation\n \n    begin\n@@ -3308,9 +3341,11 @@ package body Sem_Ch12 is\n \n          Renaming_List :=\n            Analyze_Associations\n-             (N,\n-              Generic_Formal_Declarations (Act_Tree),\n-              Generic_Formal_Declarations (Gen_Decl));\n+             (I_Node  => N,\n+              Formals => Generic_Formal_Declarations (Act_Tree),\n+              F_Copy  => Generic_Formal_Declarations (Gen_Decl));\n+\n+         Vis_Prims_List := Check_Hidden_Primitives (Renaming_List);\n \n          Set_Instance_Env (Gen_Unit, Act_Decl_Id);\n          Set_Defining_Unit_Name (Act_Spec, Act_Decl_Name);\n@@ -3696,6 +3731,7 @@ package body Sem_Ch12 is\n \n          Check_Formal_Packages (Act_Decl_Id);\n \n+         Restore_Hidden_Primitives (Vis_Prims_List);\n          Restore_Private_Views (Act_Decl_Id);\n \n          Inherit_Context (Gen_Decl, N);\n@@ -4277,6 +4313,12 @@ package body Sem_Ch12 is\n          end if;\n       end Analyze_Instance_And_Renamings;\n \n+      --  Local variables\n+\n+      Vis_Prims_List : Elist_Id := No_Elist;\n+      --  List of primitives made temporarily visible in the instantiation\n+      --  to match the visibility of the formal type\n+\n    --  Start of processing for Analyze_Subprogram_Instantiation\n \n    begin\n@@ -4376,6 +4418,7 @@ package body Sem_Ch12 is\n             Error_Msg_NE\n               (\"circular Instantiation: & instantiated in &!\", N, Gen_Unit);\n             Circularity_Detected := True;\n+            Restore_Hidden_Primitives (Vis_Prims_List);\n             goto Leave;\n          end if;\n \n@@ -4402,9 +4445,11 @@ package body Sem_Ch12 is\n \n          Renaming_List :=\n            Analyze_Associations\n-             (N,\n-              Generic_Formal_Declarations (Act_Tree),\n-              Generic_Formal_Declarations (Gen_Decl));\n+             (I_Node  => N,\n+              Formals => Generic_Formal_Declarations (Act_Tree),\n+              F_Copy  => Generic_Formal_Declarations (Gen_Decl));\n+\n+         Vis_Prims_List := Check_Hidden_Primitives (Renaming_List);\n \n          --  The subprogram itself cannot contain a nested instance, so the\n          --  current parent is left empty.\n@@ -4554,6 +4599,7 @@ package body Sem_Ch12 is\n             Remove_Parent;\n          end if;\n \n+         Restore_Hidden_Primitives (Vis_Prims_List);\n          Restore_Env;\n          Env_Installed := False;\n          Generic_Renamings.Set_Last (0);\n@@ -5856,6 +5902,49 @@ package body Sem_Ch12 is\n       end if;\n    end Check_Private_View;\n \n+   -----------------------------\n+   -- Check_Hidden_Primitives --\n+   -----------------------------\n+\n+   function Check_Hidden_Primitives (Assoc_List : List_Id) return Elist_Id is\n+      Actual : Node_Id;\n+      Gen_T  : Entity_Id;\n+      Result : Elist_Id := No_Elist;\n+\n+   begin\n+      if No (Assoc_List) then\n+         return No_Elist;\n+      end if;\n+\n+      --  Traverse the list of associations between formals and actuals\n+      --  searching for renamings of tagged types\n+\n+      Actual := First (Assoc_List);\n+      while Present (Actual) loop\n+         if Nkind (Actual) = N_Subtype_Declaration then\n+            Gen_T := Generic_Parent_Type (Actual);\n+\n+            if Present (Gen_T)\n+              and then Is_Tagged_Type (Gen_T)\n+            then\n+               --  Traverse the list of primitives of the actual types\n+               --  searching for hidden primitives that are visible in the\n+               --  corresponding generic formal; leave them visible and\n+               --  append them to Result to restore their decoration later.\n+\n+               Install_Hidden_Primitives\n+                 (Prims_List => Result,\n+                  Gen_T      => Gen_T,\n+                  Act_T      => Entity (Subtype_Indication (Actual)));\n+            end if;\n+         end if;\n+\n+         Next (Actual);\n+      end loop;\n+\n+      return Result;\n+   end Check_Hidden_Primitives;\n+\n    --------------------------\n    -- Contains_Instance_Of --\n    --------------------------\n@@ -7893,6 +7982,138 @@ package body Sem_Ch12 is\n       end if;\n    end Install_Parent;\n \n+   -------------------------------\n+   -- Install_Hidden_Primitives --\n+   -------------------------------\n+\n+   procedure Install_Hidden_Primitives\n+     (Prims_List : in out Elist_Id;\n+      Gen_T      : Entity_Id;\n+      Act_T      : Entity_Id)\n+   is\n+      Elmt        : Elmt_Id;\n+      List        : Elist_Id := No_Elist;\n+      Prim_G_Elmt : Elmt_Id;\n+      Prim_A_Elmt : Elmt_Id;\n+      Prim_G      : Node_Id;\n+      Prim_A      : Node_Id;\n+\n+   begin\n+      --  No action needed in case of serious errors because we cannot trust\n+      --  in the order of primitives\n+\n+      if Serious_Errors_Detected > 0 then\n+         return;\n+\n+      --  No action possible if we don't have available the list of primitive\n+      --  operations\n+\n+      elsif No (Gen_T)\n+        or else not Is_Record_Type (Gen_T)\n+        or else not Is_Tagged_Type (Gen_T)\n+        or else not Is_Record_Type (Act_T)\n+        or else not Is_Tagged_Type (Act_T)\n+      then\n+         return;\n+\n+      --  There is no need to handle interface types since their primitives\n+      --  cannot be hidden\n+\n+      elsif Is_Interface (Gen_T) then\n+         return;\n+      end if;\n+\n+      Prim_G_Elmt := First_Elmt (Primitive_Operations (Gen_T));\n+\n+      if not Is_Class_Wide_Type (Act_T) then\n+         Prim_A_Elmt := First_Elmt (Primitive_Operations (Act_T));\n+      else\n+         Prim_A_Elmt := First_Elmt (Primitive_Operations (Root_Type (Act_T)));\n+      end if;\n+\n+      loop\n+         --  Skip predefined primitives in the generic formal\n+\n+         while Present (Prim_G_Elmt)\n+           and then Is_Predefined_Dispatching_Operation (Node (Prim_G_Elmt))\n+         loop\n+            Next_Elmt (Prim_G_Elmt);\n+         end loop;\n+\n+         --  Skip predefined primitives in the generic actual\n+\n+         while Present (Prim_A_Elmt)\n+           and then Is_Predefined_Dispatching_Operation (Node (Prim_A_Elmt))\n+         loop\n+            Next_Elmt (Prim_A_Elmt);\n+         end loop;\n+\n+         exit when No (Prim_G_Elmt) or else No (Prim_A_Elmt);\n+\n+         Prim_G := Node (Prim_G_Elmt);\n+         Prim_A := Node (Prim_A_Elmt);\n+\n+         --  There is no need to handle interface primitives because their\n+         --  primitives are not hidden\n+\n+         exit when Present (Interface_Alias (Prim_G));\n+\n+         if Chars (Prim_G) /= Chars (Prim_A)\n+           and then Has_Suffix (Prim_A, 'P')\n+           and then Remove_Suffix (Prim_A, 'P') = Chars (Prim_G)\n+         then\n+            Set_Chars (Prim_A, Chars (Prim_G));\n+\n+            if List = No_Elist then\n+               List := New_Elmt_List;\n+            end if;\n+\n+            Append_Elmt (Prim_A, List);\n+         end if;\n+\n+         Next_Elmt (Prim_A_Elmt);\n+         Next_Elmt (Prim_G_Elmt);\n+      end loop;\n+\n+      --  Append the elements to the list of temporarily visible primitives\n+      --  avoiding duplicates\n+\n+      if Present (List) then\n+         if No (Prims_List) then\n+            Prims_List := New_Elmt_List;\n+         end if;\n+\n+         Elmt := First_Elmt (List);\n+         while Present (Elmt) loop\n+            Append_Unique_Elmt (Node (Elmt), Prims_List);\n+            Next_Elmt (Elmt);\n+         end loop;\n+      end if;\n+   end Install_Hidden_Primitives;\n+\n+   -------------------------------\n+   -- Restore_Hidden_Primitives --\n+   -------------------------------\n+\n+   procedure Restore_Hidden_Primitives (Prims_List : in out Elist_Id) is\n+      Prim_Elmt : Elmt_Id;\n+      Prim      : Node_Id;\n+\n+   begin\n+      if Prims_List /= No_Elist then\n+         Prim_Elmt := First_Elmt (Prims_List);\n+\n+         while Present (Prim_Elmt) loop\n+            Prim := Node (Prim_Elmt);\n+            Set_Chars (Prim, Add_Suffix (Prim, 'P'));\n+\n+            Next_Elmt (Prim_Elmt);\n+         end loop;\n+\n+         Prims_List := No_Elist;\n+      end if;\n+   end Restore_Hidden_Primitives;\n+\n    --------------------------------\n    -- Instantiate_Formal_Package --\n    --------------------------------\n@@ -9065,6 +9286,10 @@ package body Sem_Ch12 is\n       Par_Ent : Entity_Id := Empty;\n       Par_Vis : Boolean   := False;\n \n+      Vis_Prims_List : Elist_Id := No_Elist;\n+      --  List of primitives made temporarily visible in the instantiation\n+      --  to match the visibility of the formal type\n+\n    begin\n       Gen_Body_Id := Corresponding_Body (Gen_Decl);\n \n@@ -9134,6 +9359,29 @@ package body Sem_Ch12 is\n          Set_Corresponding_Spec (Act_Body, Act_Decl_Id);\n          Check_Generic_Actuals (Act_Decl_Id, False);\n \n+         --  Install primitives hidden at the point of the instantiation but\n+         --  visible when processing the generic formals\n+\n+         declare\n+            E : Entity_Id;\n+\n+         begin\n+            E := First_Entity (Act_Decl_Id);\n+            while Present (E) loop\n+               if Is_Type (E)\n+                 and then Is_Generic_Actual_Type (E)\n+                 and then Is_Tagged_Type (E)\n+               then\n+                  Install_Hidden_Primitives\n+                    (Prims_List => Vis_Prims_List,\n+                     Gen_T      => Generic_Parent_Type (Parent (E)),\n+                     Act_T      => E);\n+               end if;\n+\n+               Next_Entity (E);\n+            end loop;\n+         end;\n+\n          --  If it is a child unit, make the parent instance (which is an\n          --  instance of the parent of the generic) visible. The parent\n          --  instance is the prefix of the name of the generic unit.\n@@ -9226,6 +9474,7 @@ package body Sem_Ch12 is\n             Set_Is_Immediately_Visible (Par_Ent, Par_Vis);\n          end if;\n \n+         Restore_Hidden_Primitives (Vis_Prims_List);\n          Restore_Private_Views (Act_Decl_Id);\n \n          --  Remove the current unit from visibility if this is an instance"}, {"sha": "488e6dc98cc10cebf69812110b521c6131fccb1c", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/292689c213a6cbf75983bf9274b2a336ae0ae910/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/292689c213a6cbf75983bf9274b2a336ae0ae910/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=292689c213a6cbf75983bf9274b2a336ae0ae910", "patch": "@@ -13318,18 +13318,18 @@ package body Sem_Ch3 is\n \n       --  Check for case of a derived subprogram for the instantiation of a\n       --  formal derived tagged type, if so mark the subprogram as dispatching\n-      --  and inherit the dispatching attributes of the parent subprogram. The\n+      --  and inherit the dispatching attributes of the actual subprogram. The\n       --  derived subprogram is effectively renaming of the actual subprogram,\n       --  so it needs to have the same attributes as the actual.\n \n       if Present (Actual_Subp)\n-        and then Is_Dispatching_Operation (Parent_Subp)\n+        and then Is_Dispatching_Operation (Actual_Subp)\n       then\n          Set_Is_Dispatching_Operation (New_Subp);\n \n-         if Present (DTC_Entity (Parent_Subp)) then\n-            Set_DTC_Entity (New_Subp, DTC_Entity (Parent_Subp));\n-            Set_DT_Position (New_Subp, DT_Position (Parent_Subp));\n+         if Present (DTC_Entity (Actual_Subp)) then\n+            Set_DTC_Entity (New_Subp, DTC_Entity (Actual_Subp));\n+            Set_DT_Position (New_Subp, DT_Position (Actual_Subp));\n          end if;\n       end if;\n "}, {"sha": "9dfecd3d956f8674e43954812ac2eaac7e86ece3", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/292689c213a6cbf75983bf9274b2a336ae0ae910/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/292689c213a6cbf75983bf9274b2a336ae0ae910/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=292689c213a6cbf75983bf9274b2a336ae0ae910", "patch": "@@ -5965,6 +5965,29 @@ package body Sem_Util is\n       return Name_Buffer (Name_Len) = Suffix;\n    end Has_Suffix;\n \n+   ----------------\n+   -- Add_Suffix --\n+   ----------------\n+\n+   function Add_Suffix (E : Entity_Id; Suffix : Character) return Name_Id is\n+   begin\n+      Get_Name_String (Chars (E));\n+      Add_Char_To_Name_Buffer (Suffix);\n+      return Name_Find;\n+   end Add_Suffix;\n+\n+   -------------------\n+   -- Remove_Suffix --\n+   -------------------\n+\n+   function Remove_Suffix (E : Entity_Id; Suffix : Character) return Name_Id is\n+   begin\n+      pragma Assert (Has_Suffix (E, Suffix));\n+      Get_Name_String (Chars (E));\n+      Name_Len := Name_Len - 1;\n+      return Name_Find;\n+   end Remove_Suffix;\n+\n    --------------------------\n    -- Has_Tagged_Component --\n    --------------------------"}, {"sha": "c7f610d52f04a3d0c735087bd1db73450b112102", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/292689c213a6cbf75983bf9274b2a336ae0ae910/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/292689c213a6cbf75983bf9274b2a336ae0ae910/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=292689c213a6cbf75983bf9274b2a336ae0ae910", "patch": "@@ -691,6 +691,12 @@ package Sem_Util is\n    function Has_Suffix (E : Entity_Id; Suffix : Character) return Boolean;\n    --  Returns true if the last character of E is Suffix. Used in Assertions.\n \n+   function Add_Suffix (E : Entity_Id; Suffix : Character) return Name_Id;\n+   --  Returns the name of E adding Suffix\n+\n+   function Remove_Suffix (E : Entity_Id; Suffix : Character) return Name_Id;\n+   --  Returns the name of E without Suffix\n+\n    function Has_Tagged_Component (Typ : Entity_Id) return Boolean;\n    --  Returns True if Typ is a composite type (array or record) which is\n    --  either itself a tagged type, or has a component (recursively) which is"}]}