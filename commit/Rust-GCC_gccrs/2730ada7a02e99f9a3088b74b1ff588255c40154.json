{"sha": "2730ada7a02e99f9a3088b74b1ff588255c40154", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjczMGFkYTdhMDJlOTlmOWEzMDg4Yjc0YjFmZjU4ODI1NWM0MDE1NA==", "commit": {"author": {"name": "Teresa Johnson", "email": "tejohnson@google.com", "date": "2012-11-30T16:47:04Z"}, "committer": {"name": "Teresa Johnson", "email": "tejohnson@gcc.gnu.org", "date": "2012-11-30T16:47:04Z"}, "message": "Revised patch to ensure that histograms from the profile summary are streamed...\n\nRevised patch to ensure that histograms from the profile summary are streamed\nthrough the LTO files so that the working set can be computed for use in\ndownstream optimizations.\n\n2012-11-30  Teresa Johnson  <tejohnson@google.com>\n\n\t* lto-cgraph.c (output_profile_summary): Stream out sum_all\n\tand histogram.\n\t(input_profile_summary): Stream in sum_all and histogram.\n\t(merge_profile_summaries): Merge sum_all and histogram, and\n\tchange to use RDIV.\n\t(input_symtab): Call compute_working_sets after merging\n\tsummaries.\n\t* gcov-io.c (gcov_histo_index): Make extern for compiler.\n\t* gcov-io.h (gcov_histo_index): Ditto.\n\t* profile.c (compute_working_sets): Remove static keyword.\n\t* profile.h (compute_working_sets): Ditto.\n\t* Makefile.in (lto-cgraph.o): Depend on profile.h.\n\nFrom-SVN: r193999", "tree": {"sha": "2f91f256a35f639f54c8da185d2974983b74c68a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2f91f256a35f639f54c8da185d2974983b74c68a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2730ada7a02e99f9a3088b74b1ff588255c40154", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2730ada7a02e99f9a3088b74b1ff588255c40154", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2730ada7a02e99f9a3088b74b1ff588255c40154", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2730ada7a02e99f9a3088b74b1ff588255c40154/comments", "author": {"login": "teresajohnson", "id": 20446403, "node_id": "MDQ6VXNlcjIwNDQ2NDAz", "avatar_url": "https://avatars.githubusercontent.com/u/20446403?v=4", "gravatar_id": "", "url": "https://api.github.com/users/teresajohnson", "html_url": "https://github.com/teresajohnson", "followers_url": "https://api.github.com/users/teresajohnson/followers", "following_url": "https://api.github.com/users/teresajohnson/following{/other_user}", "gists_url": "https://api.github.com/users/teresajohnson/gists{/gist_id}", "starred_url": "https://api.github.com/users/teresajohnson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/teresajohnson/subscriptions", "organizations_url": "https://api.github.com/users/teresajohnson/orgs", "repos_url": "https://api.github.com/users/teresajohnson/repos", "events_url": "https://api.github.com/users/teresajohnson/events{/privacy}", "received_events_url": "https://api.github.com/users/teresajohnson/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c1ed6a0172fa629c31f23f99d76b3fa0109bb66b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c1ed6a0172fa629c31f23f99d76b3fa0109bb66b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c1ed6a0172fa629c31f23f99d76b3fa0109bb66b"}], "stats": {"total": 162, "additions": 136, "deletions": 26}, "files": [{"sha": "6d1822398b855a37a036ddd2bac1a6e30e4e409c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2730ada7a02e99f9a3088b74b1ff588255c40154/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2730ada7a02e99f9a3088b74b1ff588255c40154/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2730ada7a02e99f9a3088b74b1ff588255c40154", "patch": "@@ -1,3 +1,18 @@\n+2012-11-30  Teresa Johnson  <tejohnson@google.com>\n+\n+\t* lto-cgraph.c (output_profile_summary): Stream out sum_all\n+\tand histogram.\n+\t(input_profile_summary): Stream in sum_all and histogram.\n+\t(merge_profile_summaries): Merge sum_all and histogram, and\n+\tchange to use RDIV.\n+\t(input_symtab): Call compute_working_sets after merging\n+\tsummaries.\n+\t* gcov-io.c (gcov_histo_index): Make extern for compiler.\n+\t* gcov-io.h (gcov_histo_index): Ditto.\n+\t* profile.c (compute_working_sets): Remove static keyword.\n+\t* profile.h (compute_working_sets): Ditto.\n+\t* Makefile.in (lto-cgraph.o): Depend on profile.h.\n+\n 2012-11-30  Martin Jambor  <mjambor@suse.cz>\n \n \tPR middle-end/52890"}, {"sha": "42fb5cf7e107d7f3c3c74aca333913e1fa0a1665", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2730ada7a02e99f9a3088b74b1ff588255c40154/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2730ada7a02e99f9a3088b74b1ff588255c40154/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=2730ada7a02e99f9a3088b74b1ff588255c40154", "patch": "@@ -2162,7 +2162,7 @@ lto-cgraph.o: lto-cgraph.c $(CONFIG_H) $(SYSTEM_H) coretypes.h   \\\n    $(HASHTAB_H) langhooks.h $(BASIC_BLOCK_H) \\\n    $(TREE_FLOW_H) $(CGRAPH_H) $(FUNCTION_H) $(GGC_H) $(DIAGNOSTIC_CORE_H) \\\n    $(EXCEPT_H) $(TIMEVAR_H) pointer-set.h $(LTO_STREAMER_H) \\\n-   $(GCOV_IO_H) $(DATA_STREAMER_H) $(TREE_STREAMER_H) $(TREE_PASS_H)\n+   $(GCOV_IO_H) $(DATA_STREAMER_H) $(TREE_STREAMER_H) $(TREE_PASS_H) profile.h\n lto-streamer-in.o: lto-streamer-in.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n    $(TM_H) toplev.h $(DIAGNOSTIC_CORE_H) $(EXPR_H) $(FLAGS_H) $(PARAMS_H) \\\n    input.h $(HASHTAB_H) $(BASIC_BLOCK_H) $(TREE_FLOW_H) $(TREE_PASS_H) \\"}, {"sha": "f45c32cc1e5526ac6e5e2d14e8df8e3cb60d28e8", "filename": "gcc/gcov-io.c", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2730ada7a02e99f9a3088b74b1ff588255c40154/gcc%2Fgcov-io.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2730ada7a02e99f9a3088b74b1ff588255c40154/gcc%2Fgcov-io.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcov-io.c?ref=2730ada7a02e99f9a3088b74b1ff588255c40154", "patch": "@@ -622,11 +622,15 @@ gcov_time (void)\n }\n #endif /* IN_GCOV */\n \n-#if IN_LIBGCOV || !IN_GCOV\n+#if !IN_GCOV\n /* Determine the index into histogram for VALUE. */\n \n+#if IN_LIBGCOV\n static unsigned\n-gcov_histo_index(gcov_type value)\n+#else\n+GCOV_LINKAGE unsigned\n+#endif\n+gcov_histo_index (gcov_type value)\n {\n   gcov_type_unsigned v = (gcov_type_unsigned)value;\n   unsigned r = 0;\n@@ -664,8 +668,8 @@ gcov_histo_index(gcov_type value)\n    its entry's original cumulative counter value when computing the\n    new merged cum_value.  */\n \n-static void gcov_histogram_merge(gcov_bucket_type *tgt_histo,\n-                                 gcov_bucket_type *src_histo)\n+static void gcov_histogram_merge (gcov_bucket_type *tgt_histo,\n+                                  gcov_bucket_type *src_histo)\n {\n   int src_i, tgt_i, tmp_i = 0;\n   unsigned src_num, tgt_num, merge_num;\n@@ -801,4 +805,4 @@ static void gcov_histogram_merge(gcov_bucket_type *tgt_histo,\n   /* Finally, copy the merged histogram into tgt_histo.  */\n   memcpy(tgt_histo, tmp_histo, sizeof (gcov_bucket_type) * GCOV_HISTOGRAM_SIZE);\n }\n-#endif /* IN_LIBGCOV || !IN_GCOV */\n+#endif /* !IN_GCOV */"}, {"sha": "1f01aacd3e93564fb21b7eefdbc195925b627b67", "filename": "gcc/gcov-io.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2730ada7a02e99f9a3088b74b1ff588255c40154/gcc%2Fgcov-io.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2730ada7a02e99f9a3088b74b1ff588255c40154/gcc%2Fgcov-io.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcov-io.h?ref=2730ada7a02e99f9a3088b74b1ff588255c40154", "patch": "@@ -612,6 +612,7 @@ GCOV_LINKAGE void gcov_write_unsigned (gcov_unsigned_t) ATTRIBUTE_HIDDEN;\n \n #if !IN_GCOV && !IN_LIBGCOV\n /* Available only in compiler */\n+GCOV_LINKAGE unsigned gcov_histo_index (gcov_type value);\n GCOV_LINKAGE void gcov_write_string (const char *);\n GCOV_LINKAGE gcov_position_t gcov_write_tag (gcov_unsigned_t);\n GCOV_LINKAGE void gcov_write_length (gcov_position_t /*position*/);"}, {"sha": "5feaf1abc7ab8601737390c9cf4a9c87c5a9d467", "filename": "gcc/lto-cgraph.c", "status": "modified", "additions": 107, "deletions": 19, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2730ada7a02e99f9a3088b74b1ff588255c40154/gcc%2Flto-cgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2730ada7a02e99f9a3088b74b1ff588255c40154/gcc%2Flto-cgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-cgraph.c?ref=2730ada7a02e99f9a3088b74b1ff588255c40154", "patch": "@@ -46,6 +46,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-streamer.h\"\n #include \"gcov-io.h\"\n #include \"tree-pass.h\"\n+#include \"profile.h\"\n \n static void output_cgraph_opt_summary (void);\n static void input_cgraph_opt_summary (vec<symtab_node>  nodes);\n@@ -593,14 +594,39 @@ lto_output_ref (struct lto_simple_output_block *ob, struct ipa_ref *ref,\n static void\n output_profile_summary (struct lto_simple_output_block *ob)\n {\n+  unsigned h_ix;\n+  struct bitpack_d bp;\n+\n   if (profile_info)\n     {\n-      /* We do not output num, sum_all and run_max, they are not used by\n-\t GCC profile feedback and they are difficult to merge from multiple\n-\t units.  */\n+      /* We do not output num and run_max, they are not used by\n+         GCC profile feedback and they are difficult to merge from multiple\n+         units.  */\n       gcc_assert (profile_info->runs);\n       streamer_write_uhwi_stream (ob->main_stream, profile_info->runs);\n       streamer_write_uhwi_stream (ob->main_stream, profile_info->sum_max);\n+\n+      /* sum_all is needed for computing the working set with the\n+         histogram.  */\n+      streamer_write_uhwi_stream (ob->main_stream, profile_info->sum_all);\n+\n+      /* Create and output a bitpack of non-zero histogram entries indices.  */\n+      bp = bitpack_create (ob->main_stream);\n+      for (h_ix = 0; h_ix < GCOV_HISTOGRAM_SIZE; h_ix++)\n+        bp_pack_value (&bp, profile_info->histogram[h_ix].num_counters > 0, 1);\n+      streamer_write_bitpack (&bp);\n+      /* Now stream out only those non-zero entries.  */\n+      for (h_ix = 0; h_ix < GCOV_HISTOGRAM_SIZE; h_ix++)\n+        {\n+          if (!profile_info->histogram[h_ix].num_counters)\n+            continue;\n+          streamer_write_uhwi_stream (ob->main_stream,\n+                                      profile_info->histogram[h_ix].num_counters);\n+          streamer_write_uhwi_stream (ob->main_stream,\n+                                      profile_info->histogram[h_ix].min_value);\n+          streamer_write_uhwi_stream (ob->main_stream,\n+                                      profile_info->histogram[h_ix].cum_value);\n+        }\n     }\n   else\n     streamer_write_uhwi_stream (ob->main_stream, 0);\n@@ -1227,11 +1253,38 @@ static void\n input_profile_summary (struct lto_input_block *ib,\n \t\t       struct lto_file_decl_data *file_data)\n {\n+  unsigned h_ix;\n+  struct bitpack_d bp;\n   unsigned int runs = streamer_read_uhwi (ib);\n   if (runs)\n     {\n       file_data->profile_info.runs = runs;\n       file_data->profile_info.sum_max = streamer_read_uhwi (ib);\n+      file_data->profile_info.sum_all = streamer_read_uhwi (ib);\n+\n+      memset (file_data->profile_info.histogram, 0,\n+              sizeof (gcov_bucket_type) * GCOV_HISTOGRAM_SIZE);\n+      /* Input the bitpack of non-zero histogram indices.  */\n+      bp = streamer_read_bitpack (ib);\n+      /* Read in and unpack the full bitpack, flagging non-zero\n+         histogram entries by setting the num_counters non-zero.  */\n+      for (h_ix = 0; h_ix < GCOV_HISTOGRAM_SIZE; h_ix++)\n+        {\n+          file_data->profile_info.histogram[h_ix].num_counters\n+              = bp_unpack_value (&bp, 1);\n+        }\n+      for (h_ix = 0; h_ix < GCOV_HISTOGRAM_SIZE; h_ix++)\n+        {\n+          if (!file_data->profile_info.histogram[h_ix].num_counters)\n+            continue;\n+\n+          file_data->profile_info.histogram[h_ix].num_counters\n+              = streamer_read_uhwi (ib);\n+          file_data->profile_info.histogram[h_ix].min_value\n+              = streamer_read_uhwi (ib);\n+          file_data->profile_info.histogram[h_ix].cum_value\n+              = streamer_read_uhwi (ib);\n+        }\n     }\n \n }\n@@ -1242,10 +1295,13 @@ static void\n merge_profile_summaries (struct lto_file_decl_data **file_data_vec)\n {\n   struct lto_file_decl_data *file_data;\n-  unsigned int j;\n+  unsigned int j, h_ix;\n   gcov_unsigned_t max_runs = 0;\n   struct cgraph_node *node;\n   struct cgraph_edge *edge;\n+  gcov_type saved_sum_all = 0;\n+  gcov_ctr_summary *saved_profile_info = 0;\n+  int saved_scale = 0;\n \n   /* Find unit with maximal number of runs.  If we ever get serious about\n      roundoff errors, we might also consider computing smallest common\n@@ -1269,23 +1325,57 @@ merge_profile_summaries (struct lto_file_decl_data **file_data_vec)\n   profile_info = &lto_gcov_summary;\n   lto_gcov_summary.runs = max_runs;\n   lto_gcov_summary.sum_max = 0;\n+  memset (lto_gcov_summary.histogram, 0,\n+          sizeof (gcov_bucket_type) * GCOV_HISTOGRAM_SIZE);\n \n   /* Rescale all units to the maximal number of runs.\n      sum_max can not be easily merged, as we have no idea what files come from\n      the same run.  We do not use the info anyway, so leave it 0.  */\n   for (j = 0; (file_data = file_data_vec[j]) != NULL; j++)\n     if (file_data->profile_info.runs)\n       {\n-\tint scale = ((REG_BR_PROB_BASE * max_runs\n-\t\t      + file_data->profile_info.runs / 2)\n-\t\t     / file_data->profile_info.runs);\n+\tint scale = RDIV (REG_BR_PROB_BASE * max_runs,\n+                          file_data->profile_info.runs);\n \tlto_gcov_summary.sum_max = MAX (lto_gcov_summary.sum_max,\n-\t\t\t\t\t(file_data->profile_info.sum_max\n-\t\t\t\t\t * scale\n-\t\t\t\t\t + REG_BR_PROB_BASE / 2)\n-\t\t\t\t\t/ REG_BR_PROB_BASE);\n+\t\t\t\t\tRDIV (file_data->profile_info.sum_max\n+                                              * scale, REG_BR_PROB_BASE));\n+\tlto_gcov_summary.sum_all = MAX (lto_gcov_summary.sum_all,\n+\t\t\t\t\tRDIV (file_data->profile_info.sum_all\n+                                              * scale, REG_BR_PROB_BASE));\n+        /* Save a pointer to the profile_info with the largest\n+           scaled sum_all and the scale for use in merging the\n+           histogram.  */\n+        if (lto_gcov_summary.sum_all > saved_sum_all)\n+          {\n+            saved_profile_info = &file_data->profile_info;\n+            saved_sum_all = lto_gcov_summary.sum_all;\n+            saved_scale = scale;\n+          }\n       }\n \n+  gcc_assert (saved_profile_info);\n+\n+  /* Scale up the histogram from the profile that had the largest\n+     scaled sum_all above.  */\n+  for (h_ix = 0; h_ix < GCOV_HISTOGRAM_SIZE; h_ix++)\n+    {\n+      /* Scale up the min value as we did the corresponding sum_all\n+         above. Use that to find the new histogram index.  */\n+      int scaled_min = RDIV (saved_profile_info->histogram[h_ix].min_value\n+                             * saved_scale, REG_BR_PROB_BASE);\n+      unsigned new_ix = gcov_histo_index (scaled_min);\n+      lto_gcov_summary.histogram[new_ix].min_value = scaled_min;\n+      /* Some of the scaled counter values would ostensibly need to be placed\n+         into different (larger) histogram buckets, but we keep things simple\n+         here and place the scaled cumulative counter value in the bucket\n+         corresponding to the scaled minimum counter value.  */\n+      lto_gcov_summary.histogram[new_ix].cum_value\n+          = RDIV (saved_profile_info->histogram[h_ix].cum_value\n+                  * saved_scale, REG_BR_PROB_BASE);\n+      lto_gcov_summary.histogram[new_ix].num_counters\n+          = saved_profile_info->histogram[h_ix].num_counters;\n+    }\n+\n   /* Watch roundoff errors.  */\n   if (lto_gcov_summary.sum_max < max_runs)\n     lto_gcov_summary.sum_max = max_runs;\n@@ -1303,10 +1393,8 @@ merge_profile_summaries (struct lto_file_decl_data **file_data_vec)\n       {\n \tint scale;\n \n-\tscale =\n-\t   ((node->count_materialization_scale * max_runs\n-\t     + node->symbol.lto_file_data->profile_info.runs / 2)\n-\t    / node->symbol.lto_file_data->profile_info.runs);\n+\tscale = RDIV (node->count_materialization_scale * max_runs,\n+                      node->symbol.lto_file_data->profile_info.runs);\n \tnode->count_materialization_scale = scale;\n \tif (scale < 0)\n \t  fatal_error (\"Profile information in %s corrupted\",\n@@ -1315,10 +1403,8 @@ merge_profile_summaries (struct lto_file_decl_data **file_data_vec)\n \tif (scale == REG_BR_PROB_BASE)\n \t  continue;\n \tfor (edge = node->callees; edge; edge = edge->next_callee)\n-\t  edge->count = ((edge->count * scale + REG_BR_PROB_BASE / 2)\n-\t\t\t / REG_BR_PROB_BASE);\n-\tnode->count = ((node->count * scale + REG_BR_PROB_BASE / 2)\n-\t\t       / REG_BR_PROB_BASE);\n+\t  edge->count = RDIV (edge->count * scale, REG_BR_PROB_BASE);\n+\tnode->count = RDIV (node->count * scale, REG_BR_PROB_BASE);\n       }\n }\n \n@@ -1365,6 +1451,8 @@ input_symtab (void)\n     }\n \n   merge_profile_summaries (file_data_vec);\n+  compute_working_sets ();\n+\n \n   /* Clear out the aux field that was used to store enough state to\n      tell which nodes should be overwritten.  */"}, {"sha": "b50150d6c1e3f6d94d19482f1e30c5c5988154fa", "filename": "gcc/profile.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2730ada7a02e99f9a3088b74b1ff588255c40154/gcc%2Fprofile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2730ada7a02e99f9a3088b74b1ff588255c40154/gcc%2Fprofile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile.c?ref=2730ada7a02e99f9a3088b74b1ff588255c40154", "patch": "@@ -207,7 +207,7 @@ instrument_values (histogram_values values)\n    the number of counters required to cover that working set percentage and\n    the minimum counter value in that working set.  */\n \n-static void\n+void\n compute_working_sets (void)\n {\n   gcov_type working_set_cum_values[NUM_GCOV_WORKING_SETS];"}, {"sha": "ed8c88667d80f8d2fe7bf3f603b6d85a161b22dd", "filename": "gcc/profile.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2730ada7a02e99f9a3088b74b1ff588255c40154/gcc%2Fprofile.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2730ada7a02e99f9a3088b74b1ff588255c40154/gcc%2Fprofile.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile.h?ref=2730ada7a02e99f9a3088b74b1ff588255c40154", "patch": "@@ -47,4 +47,6 @@ extern gcov_type sum_edge_counts (vec<edge, va_gc> *edges);\n extern void init_node_map (void);\n extern void del_node_map (void);\n \n+extern void compute_working_sets (void);\n+\n #endif /* PROFILE_H */"}]}