{"sha": "0fe854a7e085766e646a8347362add815ad9c489", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGZlODU0YTdlMDg1NzY2ZTY0NmE4MzQ3MzYyYWRkODE1YWQ5YzQ4OQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2002-04-22T18:17:06Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2002-04-22T18:17:06Z"}, "message": "alias.c (canon_true_dependence): Special case (mem:blk (scratch)).\n\n        * alias.c (canon_true_dependence): Special case (mem:blk (scratch)).\n\n        * gcse.c (free_insn_expr_list_list): New.\n        (clear_modify_mem_tables): Use it.  Fix bit set usage.\n        (canon_list_insert): Use EXPR_LISTs for expressions.\n        (record_last_mem_set_info): Factor BLOCK_NUM (insn).\n\nFrom-SVN: r52624", "tree": {"sha": "44312bb45a57f13062f0c55c4052ae1c95e01c6b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/44312bb45a57f13062f0c55c4052ae1c95e01c6b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0fe854a7e085766e646a8347362add815ad9c489", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0fe854a7e085766e646a8347362add815ad9c489", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0fe854a7e085766e646a8347362add815ad9c489", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0fe854a7e085766e646a8347362add815ad9c489/comments", "author": null, "committer": null, "parents": [{"sha": "af0d16cdec59d270a017f82ac209c44dfa748ea3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/af0d16cdec59d270a017f82ac209c44dfa748ea3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/af0d16cdec59d270a017f82ac209c44dfa748ea3"}], "stats": {"total": 87, "additions": 64, "deletions": 23}, "files": [{"sha": "0ab697d06c082713a786309ba6b775469bdc92f5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fe854a7e085766e646a8347362add815ad9c489/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fe854a7e085766e646a8347362add815ad9c489/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0fe854a7e085766e646a8347362add815ad9c489", "patch": "@@ -1,3 +1,13 @@\n+2002-04-22  Richard Henderson  <rth@redhat.com>\n+\n+\tPR c/6344\n+\t* alias.c (canon_true_dependence): Special case (mem:blk (scratch)).\n+\n+\t* gcse.c (free_insn_expr_list_list): New.\n+\t(clear_modify_mem_tables): Use it.  Fix bit set usage.\n+\t(canon_list_insert): Use EXPR_LISTs for expressions.\n+\t(record_last_mem_set_info): Factor BLOCK_NUM (insn).\n+\n 2002-04-22  Neil Booth  <neil@daikokuya.demon.co.uk>\n \n \t* cppfiles.c (_cpp_pop_file_buffer): Return void.  Move\n@@ -15,12 +25,12 @@\n \n 2002-04-22  Aldy Hernandez  <aldyh@redhat.com>\n \n-        * config/rs6000/altivec.h (vec_xor): Add variant for both args\n-        being vector signed int.\n-        (vec_andc): Same.\n-        (vec_xor): Add variant for both args being vector signed char.\n-        Remove redundant variant.\n-        (vec_andc): Same.\n+\t* config/rs6000/altivec.h (vec_xor): Add variant for both args\n+\tbeing vector signed int.\n+\t(vec_andc): Same.\n+\t(vec_xor): Add variant for both args being vector signed char.\n+\tRemove redundant variant.\n+\t(vec_andc): Same.\n \n 2002-04-21  David S. Miller  <davem@redhat.com>\n "}, {"sha": "24874f4f63da46e4c238566b343255d2cfbed094", "filename": "gcc/alias.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fe854a7e085766e646a8347362add815ad9c489/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fe854a7e085766e646a8347362add815ad9c489/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=0fe854a7e085766e646a8347362add815ad9c489", "patch": "@@ -2121,6 +2121,13 @@ canon_true_dependence (mem, mem_mode, mem_addr, x, varies)\n   if (MEM_VOLATILE_P (x) && MEM_VOLATILE_P (mem))\n     return 1;\n \n+  /* (mem:BLK (scratch)) is a special mechanism to conflict with everything.\n+     This is used in epilogue deallocation functions.  */\n+  if (GET_MODE (x) == BLKmode && GET_CODE (XEXP (x, 0)) == SCRATCH)\n+    return 1;\n+  if (GET_MODE (mem) == BLKmode && GET_CODE (XEXP (mem, 0)) == SCRATCH)\n+    return 1;\n+\n   if (DIFFERENT_ALIAS_SETS_P (x, mem))\n     return 0;\n "}, {"sha": "56c26a4be9f578e281a0e3cd007cf24930b0e77d", "filename": "gcc/gcse.c", "status": "modified", "additions": 41, "deletions": 17, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fe854a7e085766e646a8347362add815ad9c489/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fe854a7e085766e646a8347362add815ad9c489/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=0fe854a7e085766e646a8347362add815ad9c489", "patch": "@@ -697,6 +697,7 @@ static void delete_store\t\tPARAMS ((struct ls_expr *,\n \t\t\t\t\t\t basic_block));\n static void free_store_memory\t\tPARAMS ((void));\n static void store_motion\t\tPARAMS ((void));\n+static void free_insn_expr_list_list\tPARAMS ((rtx *));\n static void clear_modify_mem_tables\tPARAMS ((void));\n static void free_modify_mem_tables\tPARAMS ((void));\n \f\n@@ -2387,6 +2388,7 @@ canon_list_insert (dest, unused1, v_insn)\n      void * v_insn;\n {\n   rtx dest_addr, insn;\n+  int bb;\n \n   while (GET_CODE (dest) == SUBREG\n       || GET_CODE (dest) == ZERO_EXTRACT\n@@ -2404,12 +2406,13 @@ canon_list_insert (dest, unused1, v_insn)\n   dest_addr = get_addr (XEXP (dest, 0));\n   dest_addr = canon_rtx (dest_addr);\n   insn = (rtx) v_insn;  \n+  bb = BLOCK_NUM (insn);\n \n-  canon_modify_mem_list[BLOCK_NUM (insn)] = \n-    alloc_INSN_LIST (dest_addr, canon_modify_mem_list[BLOCK_NUM (insn)]);\n-  canon_modify_mem_list[BLOCK_NUM (insn)] = \n-    alloc_INSN_LIST (dest, canon_modify_mem_list[BLOCK_NUM (insn)]);\n-  bitmap_set_bit (canon_modify_mem_list_set, BLOCK_NUM (insn));\n+  canon_modify_mem_list[bb] = \n+    alloc_EXPR_LIST (VOIDmode, dest_addr, canon_modify_mem_list[bb]);\n+  canon_modify_mem_list[bb] = \n+    alloc_EXPR_LIST (VOIDmode, dest, canon_modify_mem_list[bb]);\n+  bitmap_set_bit (canon_modify_mem_list_set, bb);\n }\n \n /* Record memory modification information for INSN.  We do not actually care\n@@ -2420,23 +2423,24 @@ static void\n record_last_mem_set_info (insn)\n      rtx insn;\n {\n+  int bb = BLOCK_NUM (insn);\n+\n   /* load_killed_in_block_p will handle the case of calls clobbering\n      everything.  */\n-  modify_mem_list[BLOCK_NUM (insn)] = \n-    alloc_INSN_LIST (insn, modify_mem_list[BLOCK_NUM (insn)]);\n-  bitmap_set_bit (modify_mem_list_set, BLOCK_NUM (insn));\n+  modify_mem_list[bb] = alloc_INSN_LIST (insn, modify_mem_list[bb]);\n+  bitmap_set_bit (modify_mem_list_set, bb);\n \n   if (GET_CODE (insn) == CALL_INSN)\n     {\n       /* Note that traversals of this loop (other than for free-ing)\n \t will break after encountering a CALL_INSN.  So, there's no\n \t need to insert a pair of items, as canon_list_insert does.  */\n-      canon_modify_mem_list[BLOCK_NUM (insn)] = \n-        alloc_INSN_LIST (insn, canon_modify_mem_list[BLOCK_NUM (insn)]);\n-      bitmap_set_bit (canon_modify_mem_list_set, BLOCK_NUM (insn));\n+      canon_modify_mem_list[bb] = \n+        alloc_INSN_LIST (insn, canon_modify_mem_list[bb]);\n+      bitmap_set_bit (canon_modify_mem_list_set, bb);\n     }\n   else\n-    note_stores (PATTERN (insn), canon_list_insert, (void*) insn );\n+    note_stores (PATTERN (insn), canon_list_insert, (void*) insn);\n }\n \n /* Called from compute_hash_table via note_stores to handle one\n@@ -2712,21 +2716,41 @@ next_set (regno, expr)\n   return expr;\n }\n \n+/* Like free_INSN_LIST_list or free_EXPR_LIST_list, except that the node\n+   types may be mixed.  */\n+\n+static void\n+free_insn_expr_list_list (listp)\n+     rtx *listp;\n+{\n+  rtx list, next;\n+\n+  for (list = *listp; list ; list = next)\n+    {\n+      next = XEXP (list, 1);\n+      if (GET_CODE (list) == EXPR_LIST)\n+\tfree_EXPR_LIST_node (list);\n+      else\n+\tfree_INSN_LIST_node (list);\n+    }\n+\n+  *listp = NULL;\n+}\n+\n /* Clear canon_modify_mem_list and modify_mem_list tables.  */\n static void\n clear_modify_mem_tables ()\n {\n   int i;\n \n   EXECUTE_IF_SET_IN_BITMAP\n-    (canon_modify_mem_list_set, 0, i,\n-     free_INSN_LIST_list (modify_mem_list + i));\n-  bitmap_clear (canon_modify_mem_list_set);\n+    (modify_mem_list_set, 0, i, free_INSN_LIST_list (modify_mem_list + i));\n+  bitmap_clear (modify_mem_list_set);\n \n   EXECUTE_IF_SET_IN_BITMAP\n     (canon_modify_mem_list_set, 0, i,\n-     free_INSN_LIST_list (canon_modify_mem_list + i));\n-  bitmap_clear (modify_mem_list_set);\n+     free_insn_expr_list_list (canon_modify_mem_list + i));\n+  bitmap_clear (canon_modify_mem_list_set);\n }\n \n /* Release memory used by modify_mem_list_set and canon_modify_mem_list_set.  */"}]}