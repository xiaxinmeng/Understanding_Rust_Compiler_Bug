{"sha": "b7561b5d2443f1d5f54f5177f0fb1a13c4205856", "node_id": "C_kwDOANBUbNoAKGI3NTYxYjVkMjQ0M2YxZDVmNTRmNTE3N2YwZmIxYTEzYzQyMDU4NTY", "commit": {"author": {"name": "Raphael Moreira Zinsly", "email": "rzinsly@linux.ibm.com", "date": "2021-10-05T18:32:52Z"}, "committer": {"name": "Segher Boessenkool", "email": "segher@kernel.crashing.org", "date": "2021-10-14T20:00:44Z"}, "message": "libgcc: Add a backchain fallback to _Unwind_Backtrace() on PowerPC\n\nWithout dwarf2 unwind tables available _Unwind_Backtrace() is not\nable to return the full backtrace.\nThis patch adds a fallback function on powerpc to get the backtrace\nby doing a backchain, this code was originally at glibc.\n\nlibgcc/ChangeLog:\n\n\t* config/rs6000/linux-unwind.h (struct rt_sigframe): Move it to\n\toutside of get_regs() in order to use it in another function, this\n\tis done twice: for __powerpc64__ and for !__powerpc64__.\n\t(struct trace_arg): New struct.\n\t(struct layout): New struct.\n\t(ppc_backchain_fallback): New function.\n\t* unwind.inc (_Unwind_Backtrace): Look for _URC_NORMAL_STOP code\n\tstate and call MD_BACKCHAIN_FALLBACK.\n\ngcc/testsuite/ChangeLog:\n\n\t* gcc.target/powerpc/unwind-backchain.c: New test.", "tree": {"sha": "b146d395c0cf2844e5f122eae30920805ea723ea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b146d395c0cf2844e5f122eae30920805ea723ea"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b7561b5d2443f1d5f54f5177f0fb1a13c4205856", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b7561b5d2443f1d5f54f5177f0fb1a13c4205856", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b7561b5d2443f1d5f54f5177f0fb1a13c4205856", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b7561b5d2443f1d5f54f5177f0fb1a13c4205856/comments", "author": {"login": "rzinsly", "id": 6718397, "node_id": "MDQ6VXNlcjY3MTgzOTc=", "avatar_url": "https://avatars.githubusercontent.com/u/6718397?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rzinsly", "html_url": "https://github.com/rzinsly", "followers_url": "https://api.github.com/users/rzinsly/followers", "following_url": "https://api.github.com/users/rzinsly/following{/other_user}", "gists_url": "https://api.github.com/users/rzinsly/gists{/gist_id}", "starred_url": "https://api.github.com/users/rzinsly/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rzinsly/subscriptions", "organizations_url": "https://api.github.com/users/rzinsly/orgs", "repos_url": "https://api.github.com/users/rzinsly/repos", "events_url": "https://api.github.com/users/rzinsly/events{/privacy}", "received_events_url": "https://api.github.com/users/rzinsly/received_events", "type": "User", "site_admin": false}, "committer": {"login": "segher", "id": 417629, "node_id": "MDQ6VXNlcjQxNzYyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/417629?v=4", "gravatar_id": "", "url": "https://api.github.com/users/segher", "html_url": "https://github.com/segher", "followers_url": "https://api.github.com/users/segher/followers", "following_url": "https://api.github.com/users/segher/following{/other_user}", "gists_url": "https://api.github.com/users/segher/gists{/gist_id}", "starred_url": "https://api.github.com/users/segher/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/segher/subscriptions", "organizations_url": "https://api.github.com/users/segher/orgs", "repos_url": "https://api.github.com/users/segher/repos", "events_url": "https://api.github.com/users/segher/events{/privacy}", "received_events_url": "https://api.github.com/users/segher/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b47490c572c5938f887b54240af6096a7c90f640", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b47490c572c5938f887b54240af6096a7c90f640", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b47490c572c5938f887b54240af6096a7c90f640"}], "stats": {"total": 140, "additions": 124, "deletions": 16}, "files": [{"sha": "affa9b2efecc2235e344d41a1b824463edf18e0b", "filename": "gcc/testsuite/gcc.target/powerpc/unwind-backchain.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7561b5d2443f1d5f54f5177f0fb1a13c4205856/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Funwind-backchain.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7561b5d2443f1d5f54f5177f0fb1a13c4205856/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Funwind-backchain.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Funwind-backchain.c?ref=b7561b5d2443f1d5f54f5177f0fb1a13c4205856", "patch": "@@ -0,0 +1,24 @@\n+/* -linux* targets have a fallback for the absence of unwind tables, thus are\n+   the only ones we can guarantee backtrace returns all addresses.  */\n+/* { dg-do run { target { *-*-linux* } } } */\n+/* { dg-options \"-fno-asynchronous-unwind-tables\" } */\n+\n+#include <execinfo.h>\n+\n+void\n+test_backtrace()\n+{\n+  int addresses;\n+  void *buffer[10];\n+\n+  addresses = backtrace(buffer, 10);\n+  if(addresses != 4)\n+    __builtin_abort();\n+}\n+\n+int\n+main()\n+{\n+  test_backtrace();\n+  return 0;\n+}"}, {"sha": "8deccc1d6506ee155860913e0ef3434659e03a3e", "filename": "libgcc/config/rs6000/linux-unwind.h", "status": "modified", "additions": 88, "deletions": 14, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7561b5d2443f1d5f54f5177f0fb1a13c4205856/libgcc%2Fconfig%2Frs6000%2Flinux-unwind.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7561b5d2443f1d5f54f5177f0fb1a13c4205856/libgcc%2Fconfig%2Frs6000%2Flinux-unwind.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Frs6000%2Flinux-unwind.h?ref=b7561b5d2443f1d5f54f5177f0fb1a13c4205856", "patch": "@@ -94,6 +94,15 @@ struct gcc_ucontext\n \n enum { SIGNAL_FRAMESIZE = 128 };\n \n+struct rt_sigframe {\n+  char gap[SIGNAL_FRAMESIZE];\n+  struct gcc_ucontext uc;\n+  unsigned long pad[2];\n+  int tramp[6];\n+  void *pinfo;\n+  struct gcc_ucontext *puc;\n+};\n+\n /* If PC is at a sigreturn trampoline, return a pointer to the\n    regs.  Otherwise return NULL.  */\n \n@@ -136,14 +145,7 @@ get_regs (struct _Unwind_Context *context)\n #endif\n \t{\n \t  /* This works for 2.4.21 and later kernels.  */\n-\t  struct rt_sigframe {\n-\t    char gap[SIGNAL_FRAMESIZE];\n-\t    struct gcc_ucontext uc;\n-\t    unsigned long pad[2];\n-\t    int tramp[6];\n-\t    void *pinfo;\n-\t    struct gcc_ucontext *puc;\n-\t  } *frame = (struct rt_sigframe *) context->cfa;\n+\t  struct rt_sigframe *frame = (struct rt_sigframe *) context->cfa;\n \t  return frame->uc.regs;\n \t}\n     }\n@@ -154,6 +156,12 @@ get_regs (struct _Unwind_Context *context)\n \n enum { SIGNAL_FRAMESIZE = 64 };\n \n+struct rt_sigframe {\n+  char gap[SIGNAL_FRAMESIZE + 16];\n+  char siginfo[128];\n+  struct gcc_ucontext uc;\n+};\n+\n static struct gcc_regs *\n get_regs (struct _Unwind_Context *context)\n {\n@@ -176,11 +184,7 @@ get_regs (struct _Unwind_Context *context)\n     }\n   else if (pc[0] == 0x38006666 || pc[0] == 0x380000AC)\n     {\n-      struct rt_sigframe {\n-\tchar gap[SIGNAL_FRAMESIZE + 16];\n-\tchar siginfo[128];\n-\tstruct gcc_ucontext uc;\n-      } *frame = (struct rt_sigframe *) context->cfa;\n+      struct rt_sigframe *frame = (struct rt_sigframe *) context->cfa;\n       return frame->uc.regs;\n     }\n   return NULL;\n@@ -203,7 +207,7 @@ ppc_fallback_frame_state (struct _Unwind_Context *context,\n   int i;\n \n   if (regs == NULL)\n-    return _URC_END_OF_STACK;\n+    return _URC_NORMAL_STOP;\n \n   new_cfa = regs->gpr[__LIBGCC_STACK_POINTER_REGNUM__];\n   fs->regs.cfa_how = CFA_REG_OFFSET;\n@@ -352,3 +356,73 @@ frob_update_context (struct _Unwind_Context *context, _Unwind_FrameState *fs ATT\n     }\n #endif\n }\n+\n+#define MD_BACKCHAIN_FALLBACK ppc_backchain_fallback\n+\n+struct trace_arg\n+{\n+  /* Stores the list of addresses.  */\n+  void **array;\n+  struct unwind_link *unwind_link;\n+  _Unwind_Word cfa;\n+  /* Number of addresses currently stored.  */\n+  int count;\n+  /* Maximum number of addresses.  */\n+  int size;\n+};\n+\n+/* This is the stack layout we see with every stack frame.\n+   Note that every routine is required by the ABI to lay out the stack\n+   like this.\n+\n+\t    +----------------+        +-----------------+\n+    %r1  -> | previous frame--------> | previous frame--->...  --> NULL\n+\t    |                |        |                 |\n+\t    | cr save        |        | cr save\t        |\n+\t    |                |        |                 |\n+\t    | (unused)       |        | lr save         |\n+\t    +----------------+        +-----------------+\n+\n+  The CR save is only present on 64-bit ABIs.\n+*/\n+struct frame_layout\n+{\n+  struct frame_layout *backchain;\n+#ifdef __powerpc64__\n+  long int cr_save;\n+#endif\n+  void *lr_save;\n+};\n+\n+\n+void ppc_backchain_fallback (struct _Unwind_Context *context, void *a)\n+{\n+  struct frame_layout *current;\n+  struct trace_arg *arg = a;\n+  int count;\n+\n+  /* Get the last address computed and start with the next.  */\n+  current = context->cfa;\n+  current = current->backchain;\n+\n+  for (count = arg->count; current != NULL; current = current->backchain)\n+    {\n+      arg->array[count] = current->lr_save;\n+\n+      /* Check if the symbol is the signal trampoline and get the interrupted\n+\t symbol address from the trampoline saved area.  */\n+      context->ra = current->lr_save;\n+      if (current->lr_save && get_regs (context))\n+\t{\n+\t  struct rt_sigframe *sigframe = (struct rt_sigframe *) current;\n+\t  if (count + 1 == arg->size)\n+\t    break;\n+\t  arg->array[++count] = (void *) sigframe->uc.rsave.nip;\n+\t  current = (void *) sigframe->uc.rsave.gpr[1];\n+\t}\n+      if (count++ >= arg->size)\n+\tbreak;\n+    }\n+\n+  arg->count = count-1;\n+}"}, {"sha": "456a5ee682f4faff74321e3b0aface59e10c8616", "filename": "libgcc/unwind.inc", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7561b5d2443f1d5f54f5177f0fb1a13c4205856/libgcc%2Funwind.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7561b5d2443f1d5f54f5177f0fb1a13c4205856/libgcc%2Funwind.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Funwind.inc?ref=b7561b5d2443f1d5f54f5177f0fb1a13c4205856", "patch": "@@ -300,14 +300,24 @@ _Unwind_Backtrace(_Unwind_Trace_Fn trace, void * trace_argument)\n \n       /* Set up fs to describe the FDE for the caller of context.  */\n       code = uw_frame_state_for (&context, &fs);\n-      if (code != _URC_NO_REASON && code != _URC_END_OF_STACK)\n+      if (code != _URC_NO_REASON && code != _URC_END_OF_STACK\n+          && code != _URC_NORMAL_STOP)\n \treturn _URC_FATAL_PHASE1_ERROR;\n \n       /* Call trace function.  */\n       if ((*trace) (&context, trace_argument) != _URC_NO_REASON)\n \treturn _URC_FATAL_PHASE1_ERROR;\n \n-      /* We're done at end of stack.  */\t\n+#ifdef MD_BACKCHAIN_FALLBACK\n+      /* Do a backchain if there is no DWARF data.  */\n+      if (code == _URC_NORMAL_STOP)\n+\t{\n+\t  MD_BACKCHAIN_FALLBACK(&context, trace_argument);\n+\t  break;\n+\t}\n+#endif\n+\n+      /* We're done at end of stack.  */\n       if (code == _URC_END_OF_STACK)\n \tbreak;\n "}]}