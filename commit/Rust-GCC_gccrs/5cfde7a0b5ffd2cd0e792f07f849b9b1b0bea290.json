{"sha": "5cfde7a0b5ffd2cd0e792f07f849b9b1b0bea290", "node_id": "C_kwDOANBUbNoAKDVjZmRlN2EwYjVmZmQyY2QwZTc5MmYwN2Y4NDliOWIxYjBiZWEyOTA", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2022-05-09T08:17:09Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2022-06-01T08:43:19Z"}, "message": "[Ada] Rename Returns_On_Secondary_Stack into Needs_Secondary_Stack\n\nThe Returns_On_Secondary_Stack predicate is a misnomer because it must be\ninvoked on a type and types do not return; as a matter of fact, the other\nReturns_XXX predicates apply to functions.\n\ngcc/ada/\n\n\t* exp_ch6.adb (Caller_Known_Size): Invoke Needs_Secondary_Stack in\n\tlieu of Returns_On_Secondary_Stack.\n\t(Expand_Call_Helper): Likewise.\n\t(Expand_Simple_Function_Return): Likewise.\n\t(Needs_BIP_Alloc_Form): Likewise.\n\t* exp_ch7.adb (Wrap_Transient_Declaration): Likewise.\n\t* sem_res.adb (Resolve_Call): Likewise.\n\t(Resolve_Entry_Call): Likewise.\n\t* sem_util.ads (Returns_On_Secondary_Stack): Rename into...\n\t(Needs_Secondary_Stack): ...this.\n\t* sem_util.adb (Returns_On_Secondary_Stack): Rename into...\n\t(Needs_Secondary_Stack): ...this.\n\t* fe.h (Returns_On_Secondary_Stack): Delete.\n\t(Needs_Secondary_Stack): New function.\n\t* gcc-interface/decl.cc (gnat_to_gnu_subprog_type): Replace call\n\tto Returns_On_Secondary_Stack with Needs_Secondary_Stack.", "tree": {"sha": "b01faa4a536d97167663111382617ddb16dc3935", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b01faa4a536d97167663111382617ddb16dc3935"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5cfde7a0b5ffd2cd0e792f07f849b9b1b0bea290", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5cfde7a0b5ffd2cd0e792f07f849b9b1b0bea290", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5cfde7a0b5ffd2cd0e792f07f849b9b1b0bea290", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5cfde7a0b5ffd2cd0e792f07f849b9b1b0bea290/comments", "author": null, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4e8310b33c37d1eaaa4ffd08aca404a787252cf5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4e8310b33c37d1eaaa4ffd08aca404a787252cf5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4e8310b33c37d1eaaa4ffd08aca404a787252cf5"}], "stats": {"total": 569, "additions": 283, "deletions": 286}, "files": [{"sha": "8bbc5154e047b45964e394b0f9c4e66da0b67f84", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5cfde7a0b5ffd2cd0e792f07f849b9b1b0bea290/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5cfde7a0b5ffd2cd0e792f07f849b9b1b0bea290/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=5cfde7a0b5ffd2cd0e792f07f849b9b1b0bea290", "patch": "@@ -1060,7 +1060,7 @@ package body Exp_Ch6 is\n \n    begin\n       return (No (Ctrl) and then Is_Definite_Subtype (Utyp))\n-        or else not Returns_On_Secondary_Stack (Utyp);\n+        or else not Needs_Secondary_Stack (Utyp);\n    end Caller_Known_Size;\n \n    -----------------------\n@@ -4946,7 +4946,7 @@ package body Exp_Ch6 is\n                  Is_Build_In_Place_Function_Call (Parent (Call_Node)))\n          then\n             Establish_Transient_Scope\n-              (Call_Node, Returns_On_Secondary_Stack (Etype (Subp)));\n+              (Call_Node, Needs_Secondary_Stack (Etype (Subp)));\n          end if;\n       end if;\n    end Expand_Call_Helper;\n@@ -7341,7 +7341,7 @@ package body Exp_Ch6 is\n       --  A return statement from an ignored Ghost function does not use the\n       --  secondary stack (or any other one).\n \n-      elsif not Returns_On_Secondary_Stack (R_Type)\n+      elsif not Needs_Secondary_Stack (R_Type)\n         or else Is_Ignored_Ghost_Entity (Scope_Id)\n       then\n          --  Mutable records with variable-length components are not returned\n@@ -7455,7 +7455,7 @@ package body Exp_Ch6 is\n          --  how to do a copy.)\n \n          if Exp_Is_Function_Call\n-           and then Returns_On_Secondary_Stack (Exp_Typ)\n+           and then Needs_Secondary_Stack (Exp_Typ)\n          then\n             Set_By_Ref (N);\n \n@@ -10219,7 +10219,7 @@ package body Exp_Ch6 is\n       pragma Assert (Is_Build_In_Place_Function (Func_Id));\n       Func_Typ : constant Entity_Id := Underlying_Type (Etype (Func_Id));\n    begin\n-      return Returns_On_Secondary_Stack (Func_Typ);\n+      return Needs_Secondary_Stack (Func_Typ);\n    end Needs_BIP_Alloc_Form;\n \n    -------------------------------------"}, {"sha": "206f46aa8e1d29b6856a7d8c8f897863c1808836", "filename": "gcc/ada/exp_ch7.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5cfde7a0b5ffd2cd0e792f07f849b9b1b0bea290/gcc%2Fada%2Fexp_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5cfde7a0b5ffd2cd0e792f07f849b9b1b0bea290/gcc%2Fada%2Fexp_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch7.adb?ref=5cfde7a0b5ffd2cd0e792f07f849b9b1b0bea290", "patch": "@@ -10312,7 +10312,7 @@ package body Exp_Ch7 is\n          --  reclamation is done by the caller.\n \n          if Ekind (Curr_S) = E_Function\n-           and then Returns_On_Secondary_Stack (Etype (Curr_S))\n+           and then Needs_Secondary_Stack (Etype (Curr_S))\n          then\n             null;\n "}, {"sha": "a4ab35ea1f69952cb592c5d2ada6dd0f95d3f04d", "filename": "gcc/ada/fe.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5cfde7a0b5ffd2cd0e792f07f849b9b1b0bea290/gcc%2Fada%2Ffe.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5cfde7a0b5ffd2cd0e792f07f849b9b1b0bea290/gcc%2Fada%2Ffe.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffe.h?ref=5cfde7a0b5ffd2cd0e792f07f849b9b1b0bea290", "patch": "@@ -297,15 +297,15 @@ extern Boolean Compile_Time_Known_Value\t(Node_Id);\n #define First_Actual\t\t\tsem_util__first_actual\n #define Is_Expression_Function\t\tsem_util__is_expression_function\n #define Is_Variable_Size_Record \tsem_util__is_variable_size_record\n+#define Needs_Secondary_Stack\t\tsem_util__needs_secondary_stack\n #define Next_Actual\t\t\tsem_util__next_actual\n-#define Returns_On_Secondary_Stack\tsem_util__returns_on_secondary_stack\n \n extern Entity_Id Defining_Entity\t\t(Node_Id);\n extern Node_Id First_Actual\t\t\t(Node_Id);\n extern Boolean Is_Expression_Function\t\t(Entity_Id);\n extern Boolean Is_Variable_Size_Record \t\t(Entity_Id);\n+extern Boolean Needs_Secondary_Stack\t\t(Entity_Id);\n extern Node_Id Next_Actual\t\t\t(Node_Id);\n-extern Boolean Returns_On_Secondary_Stack\t(Entity_Id);\n \n /* sinfo: */\n "}, {"sha": "318c3bedf4ee7bdb41ab0204c2e61262ae6f90dd", "filename": "gcc/ada/gcc-interface/decl.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5cfde7a0b5ffd2cd0e792f07f849b9b1b0bea290/gcc%2Fada%2Fgcc-interface%2Fdecl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5cfde7a0b5ffd2cd0e792f07f849b9b1b0bea290/gcc%2Fada%2Fgcc-interface%2Fdecl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.cc?ref=5cfde7a0b5ffd2cd0e792f07f849b9b1b0bea290", "patch": "@@ -5864,7 +5864,7 @@ gnat_to_gnu_subprog_type (Entity_Id gnat_subprog, bool definition,\n \t}\n \n       /* This is for the other types returned on the secondary stack.  */\n-      else if (Returns_On_Secondary_Stack (gnat_return_type))\n+      else if (Needs_Secondary_Stack (gnat_return_type))\n \t{\n \t  gnu_return_type = build_reference_type (gnu_return_type);\n \t  return_unconstrained_p = true;"}, {"sha": "7d595eb23e88996bf591f881e89e4bda2f1b3213", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5cfde7a0b5ffd2cd0e792f07f849b9b1b0bea290/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5cfde7a0b5ffd2cd0e792f07f849b9b1b0bea290/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=5cfde7a0b5ffd2cd0e792f07f849b9b1b0bea290", "patch": "@@ -6959,8 +6959,7 @@ package body Sem_Res is\n         and then Requires_Transient_Scope (Etype (Nam))\n         and then not Is_Ignored_Ghost_Entity (Nam)\n       then\n-         Establish_Transient_Scope\n-           (N, Returns_On_Secondary_Stack (Etype (Nam)));\n+         Establish_Transient_Scope (N, Needs_Secondary_Stack (Etype (Nam)));\n \n          --  If the call appears within the bounds of a loop, it will be\n          --  rewritten and reanalyzed, nothing left to do here.\n@@ -8540,8 +8539,7 @@ package body Sem_Res is\n       elsif Expander_Active\n         and then Requires_Transient_Scope (Etype (Nam))\n       then\n-         Establish_Transient_Scope\n-           (N, Returns_On_Secondary_Stack (Etype (Nam)));\n+         Establish_Transient_Scope (N, Needs_Secondary_Stack (Etype (Nam)));\n       end if;\n \n       --  Now we know that this is not a call to a function that returns an"}, {"sha": "c231fbb1a72150ecb6ffc20ea1c66079918d8d03", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 266, "deletions": 267, "changes": 533, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5cfde7a0b5ffd2cd0e792f07f849b9b1b0bea290/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5cfde7a0b5ffd2cd0e792f07f849b9b1b0bea290/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=5cfde7a0b5ffd2cd0e792f07f849b9b1b0bea290", "patch": "@@ -6891,7 +6891,7 @@ package body Sem_Util is\n       --  returned on the secondary stack, the secondary stack allocation is\n       --  done by the front end, see Expand_Simple_Function_Return.\n \n-      elsif Returns_On_Secondary_Stack (Typ)\n+      elsif Needs_Secondary_Stack (Typ)\n         and then CW_Or_Needs_Finalization (Underlying_Type (Typ))\n       then\n          Set_Returns_By_Ref (Func);\n@@ -23265,6 +23265,267 @@ package body Sem_Util is\n       end if;\n    end Needs_Result_Accessibility_Level;\n \n+   ----------------------------\n+   --  Needs_Secondary_Stack --\n+   ----------------------------\n+\n+   function Needs_Secondary_Stack (Id : Entity_Id) return Boolean is\n+      pragma Assert (if Present (Id) then Ekind (Id) in E_Void | Type_Kind);\n+\n+      function Caller_Known_Size_Record (Typ : Entity_Id) return Boolean;\n+      --  Called for untagged record and protected types. Return True if the\n+      --  size of function results is known in the caller for Typ.\n+\n+      function Large_Max_Size_Mutable (Typ : Entity_Id) return Boolean;\n+      --  Returns True if Typ is a nonlimited record with defaulted\n+      --  discriminants whose max size makes it unsuitable for allocating on\n+      --  the primary stack.\n+\n+      ------------------------------\n+      -- Caller_Known_Size_Record --\n+      ------------------------------\n+\n+      function Caller_Known_Size_Record (Typ : Entity_Id) return Boolean is\n+         pragma Assert (Typ = Underlying_Type (Typ));\n+\n+         function Depends_On_Discriminant (Typ : Entity_Id) return Boolean;\n+         --  Called for untagged record and protected types. Return True if Typ\n+         --  depends on discriminants, either directly when it is unconstrained\n+         --  or indirectly when it is constrained by uplevel discriminants.\n+\n+         -----------------------------\n+         -- Depends_On_Discriminant --\n+         -----------------------------\n+\n+         function Depends_On_Discriminant (Typ : Entity_Id) return Boolean is\n+            Cons : Elmt_Id;\n+\n+         begin\n+            if Has_Discriminants (Typ) then\n+               if not Is_Constrained (Typ) then\n+                  return True;\n+\n+               else\n+                  Cons := First_Elmt (Discriminant_Constraint (Typ));\n+                  while Present (Cons) loop\n+                     if Nkind (Node (Cons)) = N_Identifier\n+                       and then Ekind (Entity (Node (Cons))) = E_Discriminant\n+                     then\n+                        return True;\n+                     end if;\n+\n+                     Next_Elmt (Cons);\n+                  end loop;\n+               end if;\n+            end if;\n+\n+            return False;\n+         end Depends_On_Discriminant;\n+\n+      begin\n+         --  First see if we have a variant part and return False if it depends\n+         --  on discriminants.\n+\n+         if Has_Variant_Part (Typ) and then Depends_On_Discriminant (Typ) then\n+            return False;\n+         end if;\n+\n+         --  Then loop over components and return False if their subtype has a\n+         --  caller-unknown size, possibly recursively.\n+\n+         --  ??? This is overly conservative, an array could be nested inside\n+         --  some other record that is constrained by nondiscriminants. That\n+         --  is, the recursive calls are too conservative.\n+\n+         declare\n+            Comp : Entity_Id;\n+\n+         begin\n+            Comp := First_Component (Typ);\n+            while Present (Comp) loop\n+               declare\n+                  Comp_Type : constant Entity_Id :=\n+                                Underlying_Type (Etype (Comp));\n+\n+               begin\n+                  if Is_Record_Type (Comp_Type)\n+                        or else\n+                     Is_Protected_Type (Comp_Type)\n+                  then\n+                     if not Caller_Known_Size_Record (Comp_Type) then\n+                        return False;\n+                     end if;\n+\n+                  elsif Is_Array_Type (Comp_Type) then\n+                     if Size_Depends_On_Discriminant (Comp_Type) then\n+                        return False;\n+                     end if;\n+                  end if;\n+               end;\n+\n+               Next_Component (Comp);\n+            end loop;\n+         end;\n+\n+         return True;\n+      end Caller_Known_Size_Record;\n+\n+      ------------------------------\n+      -- Large_Max_Size_Mutable --\n+      ------------------------------\n+\n+      function Large_Max_Size_Mutable (Typ : Entity_Id) return Boolean is\n+         pragma Assert (Typ = Underlying_Type (Typ));\n+\n+         function Is_Large_Discrete_Type (T : Entity_Id) return Boolean;\n+         --  Returns true if the discrete type T has a large range\n+\n+         ----------------------------\n+         -- Is_Large_Discrete_Type --\n+         ----------------------------\n+\n+         function Is_Large_Discrete_Type (T : Entity_Id) return Boolean is\n+            Threshold : constant Int := 16;\n+            --  Arbitrary threshold above which we consider it \"large\". We want\n+            --  a fairly large threshold, because these large types really\n+            --  shouldn't have default discriminants in the first place, in\n+            --  most cases.\n+\n+         begin\n+            return UI_To_Int (RM_Size (T)) > Threshold;\n+         end Is_Large_Discrete_Type;\n+\n+      --  Start of processing for Large_Max_Size_Mutable\n+\n+      begin\n+         if Is_Record_Type (Typ)\n+           and then not Is_Limited_View (Typ)\n+           and then Has_Defaulted_Discriminants (Typ)\n+         then\n+            --  Loop through the components, looking for an array whose upper\n+            --  bound(s) depends on discriminants, where both the subtype of\n+            --  the discriminant and the index subtype are too large.\n+\n+            declare\n+               Comp : Entity_Id;\n+\n+            begin\n+               Comp := First_Component (Typ);\n+               while Present (Comp) loop\n+                  declare\n+                     Comp_Type : constant Entity_Id :=\n+                                   Underlying_Type (Etype (Comp));\n+\n+                     Hi   : Node_Id;\n+                     Indx : Node_Id;\n+                     Ityp : Entity_Id;\n+\n+                  begin\n+                     if Is_Array_Type (Comp_Type) then\n+                        Indx := First_Index (Comp_Type);\n+\n+                        while Present (Indx) loop\n+                           Ityp := Etype (Indx);\n+                           Hi := Type_High_Bound (Ityp);\n+\n+                           if Nkind (Hi) = N_Identifier\n+                             and then Ekind (Entity (Hi)) = E_Discriminant\n+                             and then Is_Large_Discrete_Type (Ityp)\n+                             and then Is_Large_Discrete_Type\n+                                        (Etype (Entity (Hi)))\n+                           then\n+                              return True;\n+                           end if;\n+\n+                           Next_Index (Indx);\n+                        end loop;\n+                     end if;\n+                  end;\n+\n+                  Next_Component (Comp);\n+               end loop;\n+            end;\n+         end if;\n+\n+         return False;\n+      end Large_Max_Size_Mutable;\n+\n+      --  Local declarations\n+\n+      Typ : constant Entity_Id := Underlying_Type (Id);\n+\n+   --  Start of processing for Needs_Secondary_Stack\n+\n+   begin\n+      --  This is a private type which is not completed yet. This can only\n+      --  happen in a default expression (of a formal parameter or of a\n+      --  record component). Do not expand transient scope in this case.\n+\n+      if No (Typ) then\n+         return False;\n+      end if;\n+\n+      --  Do not expand transient scope for non-existent procedure return or\n+      --  string literal types.\n+\n+      if Typ = Standard_Void_Type\n+        or else Ekind (Typ) = E_String_Literal_Subtype\n+      then\n+         return False;\n+\n+      --  If Typ is a generic formal incomplete type, then we want to look at\n+      --  the actual type.\n+\n+      elsif Ekind (Typ) = E_Record_Subtype\n+        and then Present (Cloned_Subtype (Typ))\n+      then\n+         return Needs_Secondary_Stack (Cloned_Subtype (Typ));\n+\n+      --  Functions returning specific tagged types may dispatch on result, so\n+      --  their returned value is allocated on the secondary stack, even in the\n+      --  definite case. We must treat nondispatching functions the same way,\n+      --  because access-to-function types can point at both, so the calling\n+      --  conventions must be compatible.\n+\n+      elsif Is_Tagged_Type (Typ) then\n+         return True;\n+\n+      --  If the return slot of the back end cannot be accessed, then there\n+      --  is no way to call Adjust at the right time for the return object if\n+      --  the type needs finalization, so the return object must be allocated\n+      --  on the secondary stack.\n+\n+      elsif not Back_End_Return_Slot and then Needs_Finalization (Typ) then\n+         return True;\n+\n+      --  Untagged definite subtypes are known size. This includes all\n+      --  elementary [sub]types. Tasks are known size even if they have\n+      --  discriminants. So we return False here, with one exception:\n+      --  For a type like:\n+      --    type T (Last : Natural := 0) is\n+      --       X : String (1 .. Last);\n+      --    end record;\n+      --  we return True. That's because for \"P(F(...));\", where F returns T,\n+      --  we don't know the size of the result at the call site, so if we\n+      --  allocated it on the primary stack, we would have to allocate the\n+      --  maximum size, which is way too big.\n+\n+      elsif Is_Definite_Subtype (Typ) or else Is_Task_Type (Typ) then\n+         return Large_Max_Size_Mutable (Typ);\n+\n+      --  Indefinite (discriminated) untagged record or protected type\n+\n+      elsif Is_Record_Type (Typ) or else Is_Protected_Type (Typ) then\n+         return not Caller_Known_Size_Record (Typ);\n+\n+      --  Unconstrained array\n+\n+      else\n+         pragma Assert (Is_Array_Type (Typ) and not Is_Definite_Subtype (Typ));\n+         return True;\n+      end if;\n+   end Needs_Secondary_Stack;\n+\n    ---------------------------------\n    -- Needs_Simple_Initialization --\n    ---------------------------------\n@@ -27406,7 +27667,7 @@ package body Sem_Util is\n \n    function Requires_Transient_Scope (Typ : Entity_Id) return Boolean is\n    begin\n-      return Returns_On_Secondary_Stack (Typ) or else Needs_Finalization (Typ);\n+      return Needs_Secondary_Stack (Typ) or else Needs_Finalization (Typ);\n    end Requires_Transient_Scope;\n \n    --------------------------\n@@ -27454,267 +27715,6 @@ package body Sem_Util is\n       SPARK_Mode_Pragma := Prag;\n    end Restore_SPARK_Mode;\n \n-   ---------------------------------\n-   --  Returns_On_Secondary_Stack --\n-   ---------------------------------\n-\n-   function Returns_On_Secondary_Stack (Id : Entity_Id) return Boolean is\n-      pragma Assert (if Present (Id) then Ekind (Id) in E_Void | Type_Kind);\n-\n-      function Caller_Known_Size_Record (Typ : Entity_Id) return Boolean;\n-      --  Called for untagged record and protected types. Return True if the\n-      --  size of function results is known in the caller for Typ.\n-\n-      function Large_Max_Size_Mutable (Typ : Entity_Id) return Boolean;\n-      --  Returns True if Typ is a nonlimited record with defaulted\n-      --  discriminants whose max size makes it unsuitable for allocating on\n-      --  the primary stack.\n-\n-      ------------------------------\n-      -- Caller_Known_Size_Record --\n-      ------------------------------\n-\n-      function Caller_Known_Size_Record (Typ : Entity_Id) return Boolean is\n-         pragma Assert (Typ = Underlying_Type (Typ));\n-\n-         function Depends_On_Discriminant (Typ : Entity_Id) return Boolean;\n-         --  Called for untagged record and protected types. Return True if Typ\n-         --  depends on discriminants, either directly when it is unconstrained\n-         --  or indirectly when it is constrained by uplevel discriminants.\n-\n-         -----------------------------\n-         -- Depends_On_Discriminant --\n-         -----------------------------\n-\n-         function Depends_On_Discriminant (Typ : Entity_Id) return Boolean is\n-            Cons : Elmt_Id;\n-\n-         begin\n-            if Has_Discriminants (Typ) then\n-               if not Is_Constrained (Typ) then\n-                  return True;\n-\n-               else\n-                  Cons := First_Elmt (Discriminant_Constraint (Typ));\n-                  while Present (Cons) loop\n-                     if Nkind (Node (Cons)) = N_Identifier\n-                       and then Ekind (Entity (Node (Cons))) = E_Discriminant\n-                     then\n-                        return True;\n-                     end if;\n-\n-                     Next_Elmt (Cons);\n-                  end loop;\n-               end if;\n-            end if;\n-\n-            return False;\n-         end Depends_On_Discriminant;\n-\n-      begin\n-         --  First see if we have a variant part and return False if it depends\n-         --  on discriminants.\n-\n-         if Has_Variant_Part (Typ) and then Depends_On_Discriminant (Typ) then\n-            return False;\n-         end if;\n-\n-         --  Then loop over components and return False if their subtype has a\n-         --  caller-unknown size, possibly recursively.\n-\n-         --  ??? This is overly conservative, an array could be nested inside\n-         --  some other record that is constrained by nondiscriminants. That\n-         --  is, the recursive calls are too conservative.\n-\n-         declare\n-            Comp : Entity_Id;\n-\n-         begin\n-            Comp := First_Component (Typ);\n-            while Present (Comp) loop\n-               declare\n-                  Comp_Type : constant Entity_Id :=\n-                                Underlying_Type (Etype (Comp));\n-\n-               begin\n-                  if Is_Record_Type (Comp_Type)\n-                        or else\n-                     Is_Protected_Type (Comp_Type)\n-                  then\n-                     if not Caller_Known_Size_Record (Comp_Type) then\n-                        return False;\n-                     end if;\n-\n-                  elsif Is_Array_Type (Comp_Type) then\n-                     if Size_Depends_On_Discriminant (Comp_Type) then\n-                        return False;\n-                     end if;\n-                  end if;\n-               end;\n-\n-               Next_Component (Comp);\n-            end loop;\n-         end;\n-\n-         return True;\n-      end Caller_Known_Size_Record;\n-\n-      ------------------------------\n-      -- Large_Max_Size_Mutable --\n-      ------------------------------\n-\n-      function Large_Max_Size_Mutable (Typ : Entity_Id) return Boolean is\n-         pragma Assert (Typ = Underlying_Type (Typ));\n-\n-         function Is_Large_Discrete_Type (T : Entity_Id) return Boolean;\n-         --  Returns true if the discrete type T has a large range\n-\n-         ----------------------------\n-         -- Is_Large_Discrete_Type --\n-         ----------------------------\n-\n-         function Is_Large_Discrete_Type (T : Entity_Id) return Boolean is\n-            Threshold : constant Int := 16;\n-            --  Arbitrary threshold above which we consider it \"large\". We want\n-            --  a fairly large threshold, because these large types really\n-            --  shouldn't have default discriminants in the first place, in\n-            --  most cases.\n-\n-         begin\n-            return UI_To_Int (RM_Size (T)) > Threshold;\n-         end Is_Large_Discrete_Type;\n-\n-      --  Start of processing for Large_Max_Size_Mutable\n-\n-      begin\n-         if Is_Record_Type (Typ)\n-           and then not Is_Limited_View (Typ)\n-           and then Has_Defaulted_Discriminants (Typ)\n-         then\n-            --  Loop through the components, looking for an array whose upper\n-            --  bound(s) depends on discriminants, where both the subtype of\n-            --  the discriminant and the index subtype are too large.\n-\n-            declare\n-               Comp : Entity_Id;\n-\n-            begin\n-               Comp := First_Component (Typ);\n-               while Present (Comp) loop\n-                  declare\n-                     Comp_Type : constant Entity_Id :=\n-                                   Underlying_Type (Etype (Comp));\n-\n-                     Hi   : Node_Id;\n-                     Indx : Node_Id;\n-                     Ityp : Entity_Id;\n-\n-                  begin\n-                     if Is_Array_Type (Comp_Type) then\n-                        Indx := First_Index (Comp_Type);\n-\n-                        while Present (Indx) loop\n-                           Ityp := Etype (Indx);\n-                           Hi := Type_High_Bound (Ityp);\n-\n-                           if Nkind (Hi) = N_Identifier\n-                             and then Ekind (Entity (Hi)) = E_Discriminant\n-                             and then Is_Large_Discrete_Type (Ityp)\n-                             and then Is_Large_Discrete_Type\n-                                        (Etype (Entity (Hi)))\n-                           then\n-                              return True;\n-                           end if;\n-\n-                           Next_Index (Indx);\n-                        end loop;\n-                     end if;\n-                  end;\n-\n-                  Next_Component (Comp);\n-               end loop;\n-            end;\n-         end if;\n-\n-         return False;\n-      end Large_Max_Size_Mutable;\n-\n-      --  Local declarations\n-\n-      Typ : constant Entity_Id := Underlying_Type (Id);\n-\n-   --  Start of processing for Returns_On_Secondary_Stack\n-\n-   begin\n-      --  This is a private type which is not completed yet. This can only\n-      --  happen in a default expression (of a formal parameter or of a\n-      --  record component). Do not expand transient scope in this case.\n-\n-      if No (Typ) then\n-         return False;\n-      end if;\n-\n-      --  Do not expand transient scope for non-existent procedure return or\n-      --  string literal types.\n-\n-      if Typ = Standard_Void_Type\n-        or else Ekind (Typ) = E_String_Literal_Subtype\n-      then\n-         return False;\n-\n-      --  If Typ is a generic formal incomplete type, then we want to look at\n-      --  the actual type.\n-\n-      elsif Ekind (Typ) = E_Record_Subtype\n-        and then Present (Cloned_Subtype (Typ))\n-      then\n-         return Returns_On_Secondary_Stack (Cloned_Subtype (Typ));\n-\n-      --  Functions returning specific tagged types may dispatch on result, so\n-      --  their returned value is allocated on the secondary stack, even in the\n-      --  definite case. We must treat nondispatching functions the same way,\n-      --  because access-to-function types can point at both, so the calling\n-      --  conventions must be compatible.\n-\n-      elsif Is_Tagged_Type (Typ) then\n-         return True;\n-\n-      --  If the return slot of the back end cannot be accessed, then there\n-      --  is no way to call Adjust at the right time for the return object if\n-      --  the type needs finalization, so the return object must be allocated\n-      --  on the secondary stack.\n-\n-      elsif not Back_End_Return_Slot and then Needs_Finalization (Typ) then\n-         return True;\n-\n-      --  Untagged definite subtypes are known size. This includes all\n-      --  elementary [sub]types. Tasks are known size even if they have\n-      --  discriminants. So we return False here, with one exception:\n-      --  For a type like:\n-      --    type T (Last : Natural := 0) is\n-      --       X : String (1 .. Last);\n-      --    end record;\n-      --  we return True. That's because for \"P(F(...));\", where F returns T,\n-      --  we don't know the size of the result at the call site, so if we\n-      --  allocated it on the primary stack, we would have to allocate the\n-      --  maximum size, which is way too big.\n-\n-      elsif Is_Definite_Subtype (Typ) or else Is_Task_Type (Typ) then\n-         return Large_Max_Size_Mutable (Typ);\n-\n-      --  Indefinite (discriminated) untagged record or protected type\n-\n-      elsif Is_Record_Type (Typ) or else Is_Protected_Type (Typ) then\n-         return not Caller_Known_Size_Record (Typ);\n-\n-      --  Unconstrained array\n-\n-      else\n-         pragma Assert (Is_Array_Type (Typ) and not Is_Definite_Subtype (Typ));\n-         return True;\n-      end if;\n-   end Returns_On_Secondary_Stack;\n-\n    --------------------------------\n    -- Returns_Unconstrained_Type --\n    --------------------------------\n@@ -32201,10 +32201,9 @@ package body Sem_Util is\n             --    type Typ (Len : Natural := 0) is\n             --      record F : String (1 .. Len); end record;\n             --\n-            --  See Large_Max_Size_Mutable function elsewhere in this\n-            --  file (currently declared inside of\n-            --  Returns_On_Secondary_Stack, so it would have to be\n-            --  moved if we want it to be callable from here).\n+            --  See Large_Max_Size_Mutable function elsewhere in this file,\n+            --  currently declared inside of Needs_Secondary_Stack, so it\n+            --  would have to be moved if we want it to be callable from here.\n \n          end Indirect_Temp_Needed;\n "}, {"sha": "4121cf0457a737d1e4f261ce542dcf180af5dc58", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5cfde7a0b5ffd2cd0e792f07f849b9b1b0bea290/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5cfde7a0b5ffd2cd0e792f07f849b9b1b0bea290/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=5cfde7a0b5ffd2cd0e792f07f849b9b1b0bea290", "patch": "@@ -2677,6 +2677,12 @@ package Sem_Util is\n    --  parameter to identify the accessibility level of the function result\n    --  \"determined by the point of call\".\n \n+   function Needs_Secondary_Stack (Id : Entity_Id) return Boolean;\n+   --  Return true if functions whose result type is Id must return on the\n+   --  secondary stack, i.e. allocate the return object on this stack.\n+\n+   --  WARNING: There is a matching C declaration of this subprogram in fe.h\n+\n    function Needs_Simple_Initialization\n      (Typ         : Entity_Id;\n       Consider_IS : Boolean := True) return Boolean;\n@@ -3092,12 +3098,6 @@ package Sem_Util is\n    --  Set the current SPARK_Mode to Mode and SPARK_Mode_Pragma to Prag. This\n    --  routine must be used in tandem with Set_SPARK_Mode.\n \n-   function Returns_On_Secondary_Stack (Id : Entity_Id) return Boolean;\n-   --  Return true if functions whose result type is Id must return on the\n-   --  secondary stack, i.e. allocate the return object on this stack.\n-\n-   --  WARNING: There is a matching C declaration of this subprogram in fe.h\n-\n    function Returns_Unconstrained_Type (Subp : Entity_Id) return Boolean;\n    --  Return true if Subp is a function that returns an unconstrained type\n "}]}