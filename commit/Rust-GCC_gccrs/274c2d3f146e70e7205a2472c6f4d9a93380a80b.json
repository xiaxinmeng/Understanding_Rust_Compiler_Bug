{"sha": "274c2d3f146e70e7205a2472c6f4d9a93380a80b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mjc0YzJkM2YxNDZlNzBlNzIwNWEyNDcyYzZmNGQ5YTkzMzgwYTgwYg==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2017-11-17T17:53:49Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2017-11-17T17:53:49Z"}, "message": "i386.c (ix86_multiplication_cost, [...]): Break out from ...\n\n\n\t* i386.c (ix86_multiplication_cost, ix86_division_cost,\n\tix86_shift_rotate_cost): Break out from ...\n\t(ix86_rtx_costs): ... here.\n\t(ix86_add_stmt_cost): Use rtx cost machinery to compute cost of\n\tvector operations.\n\n\t* gcc.target/i386/xop-imul64-vector.c: Disable vectorizer costmodel.\n\nFrom-SVN: r254889", "tree": {"sha": "f8ed3b7bb47a28a02c067a893caf7a57f28877bd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f8ed3b7bb47a28a02c067a893caf7a57f28877bd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/274c2d3f146e70e7205a2472c6f4d9a93380a80b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/274c2d3f146e70e7205a2472c6f4d9a93380a80b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/274c2d3f146e70e7205a2472c6f4d9a93380a80b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/274c2d3f146e70e7205a2472c6f4d9a93380a80b/comments", "author": null, "committer": null, "parents": [{"sha": "650fe7323c11e5e116e34d88028909b1221e2cc8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/650fe7323c11e5e116e34d88028909b1221e2cc8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/650fe7323c11e5e116e34d88028909b1221e2cc8"}], "stats": {"total": 436, "additions": 306, "deletions": 130}, "files": [{"sha": "9d96f9564ef621c7def3e44e4617871763f6e7f1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/274c2d3f146e70e7205a2472c6f4d9a93380a80b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/274c2d3f146e70e7205a2472c6f4d9a93380a80b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=274c2d3f146e70e7205a2472c6f4d9a93380a80b", "patch": "@@ -1,3 +1,11 @@\n+2017-11-17  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* i386.c (ix86_multiplication_cost, ix86_division_cost,\n+\tix86_shift_rotate_cost): Break out from ...\n+\t(ix86_rtx_costs): ... here.\n+\t(ix86_add_stmt_cost): Use rtx cost machinery to compute cost of\n+\tvector operations.\n+\n 2017-11-17  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* predict.c (determine_unlikely_bbs): Set cgraph node count to 0"}, {"sha": "835c73db9d23c6b23c991c4a5c6a5d7ba6e8c396", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 293, "deletions": 129, "changes": 422, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/274c2d3f146e70e7205a2472c6f4d9a93380a80b/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/274c2d3f146e70e7205a2472c6f4d9a93380a80b/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=274c2d3f146e70e7205a2472c6f4d9a93380a80b", "patch": "@@ -39285,6 +39285,168 @@ ix86_vec_cost (machine_mode mode, int cost, bool parallel)\n   return cost;\n }\n \n+/* Return cost of multiplication in MODE.  */\n+\n+static int\n+ix86_multiplication_cost (const struct processor_costs *cost,\n+\t\t\t  enum machine_mode mode)\n+{\n+  machine_mode inner_mode = mode;\n+  if (VECTOR_MODE_P (mode))\n+    inner_mode = GET_MODE_INNER (mode);\n+\n+  if (SSE_FLOAT_MODE_P (mode) && TARGET_SSE_MATH)\n+    return inner_mode == DFmode ? cost->mulsd : cost->mulss;\n+  else if (X87_FLOAT_MODE_P (mode))\n+    return cost->fmul;\n+  else if (FLOAT_MODE_P (mode))\n+    return  ix86_vec_cost (mode,\n+\t\t\t   inner_mode == DFmode\n+\t\t\t   ? cost->mulsd : cost->mulss, true);\n+  else if (GET_MODE_CLASS (mode) == MODE_VECTOR_INT)\n+    {\n+      /* V*QImode is emulated with 7-13 insns.  */\n+      if (mode == V16QImode || mode == V32QImode)\n+\t{\n+\t  int extra = 11;\n+\t  if (TARGET_XOP && mode == V16QImode)\n+\t    extra = 5;\n+\t  else if (TARGET_SSSE3)\n+\t    extra = 6;\n+\t  return ix86_vec_cost (mode,\n+\t\t\t\tcost->mulss * 2 + cost->sse_op * extra,\n+\t\t\t\ttrue);\n+\t}\n+      /* V*DImode is emulated with 5-8 insns.  */\n+      else if (mode == V2DImode || mode == V4DImode)\n+\t{\n+\t  if (TARGET_XOP && mode == V2DImode)\n+\t    return ix86_vec_cost (mode,\n+\t\t\t\t  cost->mulss * 2 + cost->sse_op * 3,\n+\t\t\t\t  true);\n+\t  else\n+\t    return ix86_vec_cost (mode,\n+\t\t\t\t  cost->mulss * 3 + cost->sse_op * 5,\n+\t\t\t\t  true);\n+\t}\n+      /* Without sse4.1, we don't have PMULLD; it's emulated with 7\n+\t insns, including two PMULUDQ.  */\n+      else if (mode == V4SImode && !(TARGET_SSE4_1 || TARGET_AVX))\n+\treturn ix86_vec_cost (mode, cost->mulss * 2 + cost->sse_op * 5,\n+\t\t\t\ttrue);\n+      else\n+\treturn ix86_vec_cost (mode, cost->mulss, true);\n+    }\n+  else\n+    return (cost->mult_init[MODE_INDEX (mode)] + cost->mult_bit * 7);\n+}\n+\n+/* Return cost of multiplication in MODE.  */\n+\n+static int\n+ix86_division_cost (const struct processor_costs *cost,\n+\t\t\t  enum machine_mode mode)\n+{\n+  machine_mode inner_mode = mode;\n+  if (VECTOR_MODE_P (mode))\n+    inner_mode = GET_MODE_INNER (mode);\n+\n+  if (SSE_FLOAT_MODE_P (mode) && TARGET_SSE_MATH)\n+    return inner_mode == DFmode ? cost->divsd : cost->divss;\n+  else if (X87_FLOAT_MODE_P (mode))\n+    return cost->fdiv;\n+  else if (FLOAT_MODE_P (mode))\n+    return ix86_vec_cost (mode,\n+\t\t\t    inner_mode == DFmode ? cost->divsd : cost->divss,\n+\t\t\t    true);\n+  else\n+    return cost->divide[MODE_INDEX (mode)];\n+}\n+\n+/* Return cost of shift in MODE.\n+   If CONSTANT_OP1 is true, the op1 value is known and set in OP1_VAL.\n+   AND_IN_OP1 specify in op1 is result of and and SHIFT_AND_TRUNCATE\n+   if op1 is a result of subreg.\n+\n+   SKIP_OP0/1 is set to true if cost of OP0/1 should be ignored.  */\n+\n+static int\n+ix86_shift_rotate_cost (const struct processor_costs *cost,\n+\t\t\tenum machine_mode mode, bool constant_op1,\n+\t\t\tHOST_WIDE_INT op1_val,\n+\t\t\tbool speed,\n+\t\t\tbool and_in_op1,\n+\t\t\tbool shift_and_truncate,\n+\t\t\tbool *skip_op0, bool *skip_op1)\n+{\n+  if (skip_op0)\n+    *skip_op0 = *skip_op1 = false;\n+  if (GET_MODE_CLASS (mode) == MODE_VECTOR_INT)\n+    {\n+      /* V*QImode is emulated with 1-11 insns.  */\n+      if (mode == V16QImode || mode == V32QImode)\n+\t{\n+\t  int count = 11;\n+\t  if (TARGET_XOP && mode == V16QImode)\n+\t    {\n+\t      /* For XOP we use vpshab, which requires a broadcast of the\n+\t\t value to the variable shift insn.  For constants this\n+\t\t means a V16Q const in mem; even when we can perform the\n+\t\t shift with one insn set the cost to prefer paddb.  */\n+\t      if (constant_op1)\n+\t\t{\n+\t\t  if (skip_op1)\n+\t\t    *skip_op1 = true;\n+\t\t  return ix86_vec_cost (mode,\n+\t\t\t    cost->sse_op\n+\t\t\t    + (speed\n+\t\t\t       ? 2\n+\t\t\t       : COSTS_N_BYTES\n+\t\t\t\t (GET_MODE_UNIT_SIZE (mode))), true);\n+\t\t}\n+\t      count = 3;\n+\t    }\n+\t  else if (TARGET_SSSE3)\n+\t    count = 7;\n+\t  return ix86_vec_cost (mode, cost->sse_op * count, true);\n+\t}\n+      else\n+\treturn ix86_vec_cost (mode, cost->sse_op, true);\n+    }\n+  if (GET_MODE_SIZE (mode) > UNITS_PER_WORD)\n+    {\n+      if (constant_op1)\n+\t{\n+\t  if (op1_val > 32)\n+\t    return cost->shift_const + COSTS_N_INSNS (2);\n+\t  else\n+\t    return cost->shift_const * 2;\n+\t}\n+      else\n+\t{\n+\t  if (and_in_op1)\n+\t    return cost->shift_var * 2;\n+\t  else\n+\t    return cost->shift_var * 6 + COSTS_N_INSNS (2);\n+\t}\n+    }\n+  else\n+    {\n+      if (constant_op1)\n+\treturn cost->shift_const;\n+      else if (shift_and_truncate)\n+\t{\n+\t  if (skip_op0)\n+\t    *skip_op0 = *skip_op1 = true;\n+\t  /* Return the cost after shift-and truncation.  */\n+\t  return cost->shift_var;\n+\t}\n+      else\n+\treturn cost->shift_var;\n+    }\n+  return cost->shift_const;\n+}\n+\n /* Compute a (partial) cost for rtx X.  Return true if the complete\n    cost has been computed, and false if subexpressions should be\n    scanned.  In either case, *TOTAL contains the cost result.  */\n@@ -39298,9 +39460,6 @@ ix86_rtx_costs (rtx x, machine_mode mode, int outer_code_i, int opno,\n   enum rtx_code outer_code = (enum rtx_code) outer_code_i;\n   const struct processor_costs *cost = speed ? ix86_cost : &ix86_size_cost;\n   int src_cost;\n-  machine_mode inner_mode = mode;\n-  if (VECTOR_MODE_P (mode))\n-    inner_mode = GET_MODE_INNER (mode);\n \n   switch (code)\n     {\n@@ -39428,68 +39587,22 @@ ix86_rtx_costs (rtx x, machine_mode mode, int outer_code_i, int opno,\n     case ASHIFTRT:\n     case LSHIFTRT:\n     case ROTATERT:\n-      if (GET_MODE_CLASS (mode) == MODE_VECTOR_INT)\n-\t{\n-\t  /* ??? Should be SSE vector operation cost.  */\n-\t  /* At least for published AMD latencies, this really is the same\n-\t     as the latency for a simple fpu operation like fabs.  */\n-\t  /* V*QImode is emulated with 1-11 insns.  */\n-\t  if (mode == V16QImode || mode == V32QImode)\n-\t    {\n-\t      int count = 11;\n-\t      if (TARGET_XOP && mode == V16QImode)\n-\t\t{\n-\t\t  /* For XOP we use vpshab, which requires a broadcast of the\n-\t\t     value to the variable shift insn.  For constants this\n-\t\t     means a V16Q const in mem; even when we can perform the\n-\t\t     shift with one insn set the cost to prefer paddb.  */\n-\t\t  if (CONSTANT_P (XEXP (x, 1)))\n-\t\t    {\n-\t\t      *total = ix86_vec_cost (mode,\n-\t\t\t\tcost->sse_op\n-\t\t\t\t+ rtx_cost (XEXP (x, 0), mode, code, 0, speed)\n-\t\t\t\t+ (speed ? 2 : COSTS_N_BYTES (16)), true);\n-\t\t      return true;\n-\t\t    }\n-\t\t  count = 3;\n-\t\t}\n-\t      else if (TARGET_SSSE3)\n-\t\tcount = 7;\n-\t      *total = ix86_vec_cost (mode, cost->sse_op * count, true);\n-\t    }\n-\t  else\n-\t    *total = ix86_vec_cost (mode, cost->sse_op, true);\n-\t}\n-      else if (GET_MODE_SIZE (mode) > UNITS_PER_WORD)\n-\t{\n-\t  if (CONST_INT_P (XEXP (x, 1)))\n-\t    {\n-\t      if (INTVAL (XEXP (x, 1)) > 32)\n-\t\t*total = cost->shift_const + COSTS_N_INSNS (2);\n-\t      else\n-\t\t*total = cost->shift_const * 2;\n-\t    }\n-\t  else\n-\t    {\n-\t      if (GET_CODE (XEXP (x, 1)) == AND)\n-\t\t*total = cost->shift_var * 2;\n-\t      else\n-\t\t*total = cost->shift_var * 6 + COSTS_N_INSNS (2);\n-\t    }\n-\t}\n-      else\n-\t{\n-\t  if (CONST_INT_P (XEXP (x, 1)))\n-\t    *total = cost->shift_const;\n-\t  else if (SUBREG_P (XEXP (x, 1))\n-\t\t   && GET_CODE (XEXP (XEXP (x, 1), 0)) == AND)\n-\t    {\n-\t      /* Return the cost after shift-and truncation.  */\n-\t      *total = cost->shift_var;\n-\t      return true;\n-\t    }\n-\t  else\n-\t    *total = cost->shift_var;\n+      bool skip_op0, skip_op1;\n+      *total = ix86_shift_rotate_cost (cost, mode, CONSTANT_P (XEXP (x, 1)),\n+\t\t\t\t       CONST_INT_P (XEXP (x, 1))\n+\t\t\t\t\t ? INTVAL (XEXP (x, 1)) : -1,\n+\t\t\t\t       speed,\n+\t\t\t\t       GET_CODE (XEXP (x, 1)) == AND,\n+\t\t\t\t       SUBREG_P (XEXP (x, 1))\n+\t\t\t\t       && GET_CODE (XEXP (XEXP (x, 1), 0)) == AND,\n+\t\t\t\t       &skip_op0, &skip_op1);\n+      if (skip_op0 || skip_op1)\n+\t{\n+\t  if (!skip_op0)\n+\t    *total += rtx_cost (XEXP (x, 0), mode, code, 0, speed);\n+\t  if (!skip_op1)\n+\t    *total += rtx_cost (XEXP (x, 1), mode, code, 0, speed);\n+\t  return true;\n \t}\n       return false;\n \n@@ -39519,59 +39632,7 @@ ix86_rtx_costs (rtx x, machine_mode mode, int outer_code_i, int opno,\n       }\n \n     case MULT:\n-      if (SSE_FLOAT_MODE_P (mode) && TARGET_SSE_MATH)\n-\t{\n-\t  *total = inner_mode == DFmode ? cost->mulsd : cost->mulss;\n-\t  return false;\n-\t}\n-      else if (X87_FLOAT_MODE_P (mode))\n-\t{\n-\t  *total = cost->fmul;\n-\t  return false;\n-\t}\n-      else if (FLOAT_MODE_P (mode))\n-\t{\n-\t  *total = ix86_vec_cost (mode,\n-\t\t\t\t  inner_mode == DFmode\n-\t\t\t\t  ? cost->mulsd : cost->mulss, true);\n-\t  return false;\n-\t}\n-      else if (GET_MODE_CLASS (mode) == MODE_VECTOR_INT)\n-\t{\n-\t  /* V*QImode is emulated with 7-13 insns.  */\n-\t  if (mode == V16QImode || mode == V32QImode)\n-\t    {\n-\t      int extra = 11;\n-\t      if (TARGET_XOP && mode == V16QImode)\n-\t\textra = 5;\n-\t      else if (TARGET_SSSE3)\n-\t\textra = 6;\n-\t      *total = ix86_vec_cost (mode,\n-\t\t\t\t      cost->mulss * 2 + cost->sse_op * extra,\n-\t\t\t\t      true);\n-\t    }\n-\t  /* V*DImode is emulated with 5-8 insns.  */\n-\t  else if (mode == V2DImode || mode == V4DImode)\n-\t    {\n-\t      if (TARGET_XOP && mode == V2DImode)\n-\t\t*total = ix86_vec_cost (mode,\n-\t\t\t\t\tcost->mulss * 2 + cost->sse_op * 3,\n-\t\t\t\t\ttrue);\n-\t      else\n-\t\t*total = ix86_vec_cost (mode,\n-\t\t\t\t\tcost->mulss * 3 + cost->sse_op * 5,\n-\t\t\t\t\ttrue);\n-\t    }\n-\t  /* Without sse4.1, we don't have PMULLD; it's emulated with 7\n-\t     insns, including two PMULUDQ.  */\n-\t  else if (mode == V4SImode && !(TARGET_SSE4_1 || TARGET_AVX))\n-\t    *total = ix86_vec_cost (mode, cost->mulss * 2 + cost->sse_op * 5,\n-\t\t\t\t    true);\n-\t  else\n-\t    *total = ix86_vec_cost (mode, cost->mulss, true);\n-\t  return false;\n-\t}\n-      else\n+      if (!FLOAT_MODE_P (mode) && !VECTOR_MODE_P (mode))\n \t{\n \t  rtx op0 = XEXP (x, 0);\n \t  rtx op1 = XEXP (x, 1);\n@@ -39616,21 +39677,14 @@ ix86_rtx_costs (rtx x, machine_mode mode, int outer_code_i, int opno,\n \n           return true;\n \t}\n+      *total = ix86_multiplication_cost (cost, mode);\n+      return false;\n \n     case DIV:\n     case UDIV:\n     case MOD:\n     case UMOD:\n-      if (SSE_FLOAT_MODE_P (mode) && TARGET_SSE_MATH)\n-\t*total = inner_mode == DFmode ? cost->divsd : cost->divss;\n-      else if (X87_FLOAT_MODE_P (mode))\n-\t*total = cost->fdiv;\n-      else if (FLOAT_MODE_P (mode))\n-\t*total = ix86_vec_cost (mode,\n-\t\t\t        inner_mode == DFmode ? cost->divsd : cost->divss,\n-\t\t\t\ttrue);\n-      else\n-\t*total = cost->divide[MODE_INDEX (mode)];\n+      *total = ix86_division_cost (cost, mode);\n       return false;\n \n     case PLUS:\n@@ -48827,7 +48881,117 @@ ix86_add_stmt_cost (void *data, int count, enum vect_cost_for_stmt kind,\n   unsigned retval = 0;\n \n   tree vectype = stmt_info ? stmt_vectype (stmt_info) : NULL_TREE;\n-  int stmt_cost = ix86_builtin_vectorization_cost (kind, vectype, misalign);\n+  int stmt_cost = - 1;\n+\n+  if ((kind == vector_stmt || kind == scalar_stmt)\n+      && stmt_info\n+      && stmt_info->stmt && gimple_code (stmt_info->stmt) == GIMPLE_ASSIGN)\n+    {\n+      tree_code subcode = gimple_assign_rhs_code (stmt_info->stmt);\n+      bool fp = false;\n+      machine_mode mode = TImode;\n+\n+      if (vectype != NULL)\n+\t{\n+\t  fp = FLOAT_TYPE_P (vectype);\n+\t  mode = TYPE_MODE (vectype);\n+\t}\n+      /*machine_mode inner_mode = mode;\n+      if (VECTOR_MODE_P (mode))\n+\tinner_mode = GET_MODE_INNER (mode);*/\n+\n+      switch (subcode)\n+\t{\n+\tcase PLUS_EXPR:\n+\tcase POINTER_PLUS_EXPR:\n+\tcase MINUS_EXPR:\n+\t  if (kind == scalar_stmt)\n+\t    {\n+\t      if (SSE_FLOAT_MODE_P (mode) && TARGET_SSE_MATH)\n+\t\tstmt_cost = ix86_cost->addss;\n+\t      else if (X87_FLOAT_MODE_P (mode))\n+\t\tstmt_cost = ix86_cost->fadd;\n+\t      else\n+\t        stmt_cost = ix86_cost->add;\n+\t    }\n+\t  else\n+\t    stmt_cost = ix86_vec_cost (mode,\n+\t\t\t\t       fp ? ix86_cost->addss\n+\t\t\t\t       : ix86_cost->sse_op,\n+\t\t\t\t       true);\n+\t  break;\n+\n+\tcase MULT_EXPR:\n+\tcase WIDEN_MULT_EXPR:\n+\tcase MULT_HIGHPART_EXPR:\n+\t  stmt_cost = ix86_multiplication_cost (ix86_cost, mode);\n+\t  break;\n+\tcase FMA_EXPR:\n+          stmt_cost = ix86_vec_cost (mode,\n+\t\t\t\t     mode == SFmode ? ix86_cost->fmass\n+\t\t\t\t     : ix86_cost->fmasd,\n+\t\t\t\t     true);\n+\t  break;\n+\tcase NEGATE_EXPR:\n+\t  if (SSE_FLOAT_MODE_P (mode) && TARGET_SSE_MATH)\n+\t    stmt_cost = ix86_cost->sse_op;\n+\t  else if (X87_FLOAT_MODE_P (mode))\n+\t    stmt_cost = ix86_cost->fchs;\n+\t  else if (VECTOR_MODE_P (mode))\n+\t    stmt_cost = ix86_vec_cost (mode, ix86_cost->sse_op, true);\n+\t  else\n+\t    stmt_cost = ix86_cost->add;\n+\t  break;\n+\tcase TRUNC_DIV_EXPR:\n+\tcase CEIL_DIV_EXPR:\n+\tcase FLOOR_DIV_EXPR:\n+\tcase ROUND_DIV_EXPR:\n+\tcase TRUNC_MOD_EXPR:\n+\tcase CEIL_MOD_EXPR:\n+\tcase FLOOR_MOD_EXPR:\n+\tcase RDIV_EXPR:\n+\tcase ROUND_MOD_EXPR:\n+\tcase EXACT_DIV_EXPR:\n+\t  stmt_cost = ix86_division_cost (ix86_cost, mode);\n+\t  break;\n+\n+\tcase RSHIFT_EXPR:\n+\tcase LSHIFT_EXPR:\n+\tcase LROTATE_EXPR:\n+\tcase RROTATE_EXPR:\n+\t  {\n+\t    tree op2 = gimple_assign_rhs2 (stmt_info->stmt);\n+\t    stmt_cost = ix86_shift_rotate_cost\n+\t\t\t   (ix86_cost, mode,\n+\t\t            TREE_CODE (op2) == INTEGER_CST,\n+\t\t\t    cst_and_fits_in_hwi (op2) ? int_cst_value (op2) : -1,\n+\t\t            true, false, false, NULL, NULL);\n+\t  }\n+\t  break;\n+\tcase NOP_EXPR:\n+\t  stmt_cost = 0;\n+\t  break;\n+\n+\tcase BIT_IOR_EXPR:\n+\tcase ABS_EXPR:\n+\tcase MIN_EXPR:\n+\tcase MAX_EXPR:\n+\tcase BIT_XOR_EXPR:\n+\tcase BIT_AND_EXPR:\n+\tcase BIT_NOT_EXPR:\n+\t  if (SSE_FLOAT_MODE_P (mode) && TARGET_SSE_MATH)\n+\t    stmt_cost = ix86_cost->sse_op;\n+\t  else if (VECTOR_MODE_P (mode))\n+\t    stmt_cost = ix86_vec_cost (mode, ix86_cost->sse_op, true);\n+\t  else\n+\t    stmt_cost = ix86_cost->add;\n+\t  break;\n+\tdefault:\n+\t  break;\n+\t}\n+    }\n+  if (stmt_cost == -1)\n+    stmt_cost = ix86_builtin_vectorization_cost (kind, vectype, misalign);\n \n   /* Penalize DFmode vector operations for Bonnell.  */\n   if (TARGET_BONNELL && kind == vector_stmt"}, {"sha": "c75df82e97dc8f070ff7437acdcc61e7375e09c8", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/274c2d3f146e70e7205a2472c6f4d9a93380a80b/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/274c2d3f146e70e7205a2472c6f4d9a93380a80b/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=274c2d3f146e70e7205a2472c6f4d9a93380a80b", "patch": "@@ -1,3 +1,7 @@\n+2017-11-17  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* gcc.target/i386/xop-imul64-vector.c: Disable vectorizer costmodel.\n+\n 2017-11-17  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* gcc.dg/tree-ssa/dump-2.c: Fixup template for profile precision"}, {"sha": "43a27a5cb24a0d84bf640c80fa0d39b2d89f2511", "filename": "gcc/testsuite/gcc.target/i386/xop-imul64-vector.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/274c2d3f146e70e7205a2472c6f4d9a93380a80b/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fxop-imul64-vector.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/274c2d3f146e70e7205a2472c6f4d9a93380a80b/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fxop-imul64-vector.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fxop-imul64-vector.c?ref=274c2d3f146e70e7205a2472c6f4d9a93380a80b", "patch": "@@ -3,7 +3,7 @@\n \n /* { dg-do compile } */\n /* { dg-require-effective-target lp64 } */\n-/* { dg-options \"-O2 -mxop -mno-avx2 -ftree-vectorize\" } */\n+/* { dg-options \"-O2 -mxop -mno-avx2 -ftree-vectorize -fno-vect-cost-model\" } */\n \n extern void exit (int);\n "}]}