{"sha": "68126bad7bac641c40f6796f451093d07a1798b6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjgxMjZiYWQ3YmFjNjQxYzQwZjY3OTZmNDUxMDkzZDA3YTE3OThiNg==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2011-11-09T16:41:22Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2011-11-09T16:41:22Z"}, "message": "sparc.c (output_v8plus_shift): Take INSN parameter first and adjust head comment.\n\n\t* config/sparc/sparc.c (output_v8plus_shift): Take INSN parameter first\n\tand adjust head comment.\n\t(output_v8plus_mult): Change NAME into OPCODE and adjust throughout.\n\t(vector_init_bshuffle): Add head comment.\n\t(vector_init_move_words): Likewise.\n\t(vector_init_prepare_elts): Likewise.  Take LOCS parameter first.\n\t(sparc_expand_vector_init): Likewise.  Adjust call to above function.\n\t(sparc_expand_vector_init_vis2): Likewise.\n\t(sparc_expand_vector_init_vis1): Likewise.\n\t(sparc_expand_conditional_move): Likewise.\n\t(sparc_expand_vcond): Likewise.\n\t* config/sparc/sparc-protos.h (output_v8plus_shift): Adjust.\n\t* config/sparc/sparc.md (ashldi3_v8plus): Adjust call to\n\toutput_v8plus_shift.\n\t(ashrdi3_v8plus): Likewise.\n\t(lshrdi3_v8plus): Likewise.\n\nFrom-SVN: r181211", "tree": {"sha": "06361d7d73b29d682ce8d4f3020633d461c84407", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/06361d7d73b29d682ce8d4f3020633d461c84407"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/68126bad7bac641c40f6796f451093d07a1798b6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/68126bad7bac641c40f6796f451093d07a1798b6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/68126bad7bac641c40f6796f451093d07a1798b6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/68126bad7bac641c40f6796f451093d07a1798b6/comments", "author": null, "committer": null, "parents": [{"sha": "f5024b4a87d4cd042e70468f3158e7e3ca6b0b4b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f5024b4a87d4cd042e70468f3158e7e3ca6b0b4b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f5024b4a87d4cd042e70468f3158e7e3ca6b0b4b"}], "stats": {"total": 94, "additions": 68, "deletions": 26}, "files": [{"sha": "ccf20b1bcaa27c2a798b37229ec264779bc56f92", "filename": "gcc/config/sparc/sparc-protos.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68126bad7bac641c40f6796f451093d07a1798b6/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68126bad7bac641c40f6796f451093d07a1798b6/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h?ref=68126bad7bac641c40f6796f451093d07a1798b6", "patch": "@@ -74,7 +74,8 @@ extern const char *output_ubranch (rtx, int, rtx);\n extern const char *output_cbranch (rtx, rtx, int, int, int, rtx);\n extern const char *output_return (rtx);\n extern const char *output_sibcall (rtx, rtx);\n-extern const char *output_v8plus_shift (rtx *, rtx, const char *);\n+extern const char *output_v8plus_shift (rtx, rtx *, const char *);\n+extern const char *output_v8plus_mult (rtx, rtx *, const char *);\n extern const char *output_v9branch (rtx, rtx, int, int, int, int, rtx);\n extern const char *output_probe_stack_range (rtx, rtx);\n extern bool emit_scc_insn (rtx []);\n@@ -104,7 +105,6 @@ extern int v9_regcmp_p (enum rtx_code);\n extern int sparc_check_64 (rtx, rtx);\n extern rtx gen_df_reg (rtx, int);\n extern void sparc_expand_compare_and_swap_12 (rtx, rtx, rtx, rtx);\n-extern const char *output_v8plus_mult (rtx, rtx *, const char *);\n extern void sparc_expand_vector_init (rtx, rtx);\n extern void sparc_expand_vec_perm_bmask(enum machine_mode, rtx);\n extern bool sparc_expand_conditional_move (enum machine_mode, rtx *);"}, {"sha": "1f2a27ab1cebe424e2c96e80eb15abe2e4af0fd8", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 63, "deletions": 21, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68126bad7bac641c40f6796f451093d07a1798b6/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68126bad7bac641c40f6796f451093d07a1798b6/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=68126bad7bac641c40f6796f451093d07a1798b6", "patch": "@@ -576,7 +576,8 @@ static bool sparc_print_operand_punct_valid_p (unsigned char);\n static void sparc_print_operand (FILE *, rtx, int);\n static void sparc_print_operand_address (FILE *, rtx);\n static reg_class_t sparc_secondary_reload (bool, rtx, reg_class_t,\n-\t\t\t\t\t   enum machine_mode, secondary_reload_info *);\n+\t\t\t\t\t   enum machine_mode,\n+\t\t\t\t\t   secondary_reload_info *);\n \f\n #ifdef SUBTARGET_ATTRIBUTE_TABLE\n /* Table of valid machine attributes.  */\n@@ -9120,10 +9121,11 @@ sparc_check_64 (rtx x, rtx insn)\n   return 0;\n }\n \n-/* Returns assembly code to perform a DImode shift using\n-   a 64-bit global or out register on SPARC-V8+.  */\n+/* Output a wide shift instruction in V8+ mode.  INSN is the instruction,\n+   OPERANDS are its operands and OPCODE is the mnemonic to be used.  */\n+\n const char *\n-output_v8plus_shift (rtx *operands, rtx insn, const char *opcode)\n+output_v8plus_shift (rtx insn, rtx *operands, const char *opcode)\n {\n   static char asm_code[60];\n \n@@ -9148,12 +9150,13 @@ output_v8plus_shift (rtx *operands, rtx insn, const char *opcode)\n       output_asm_insn (\"or\\t%L1, %3, %3\", operands);\n     }\n \n-  strcpy(asm_code, opcode);\n+  strcpy (asm_code, opcode);\n \n   if (which_alternative != 2)\n     return strcat (asm_code, \"\\t%0, %2, %L0\\n\\tsrlx\\t%L0, 32, %H0\");\n   else\n-    return strcat (asm_code, \"\\t%3, %2, %3\\n\\tsrlx\\t%3, 32, %H0\\n\\tmov\\t%3, %L0\");\n+    return\n+      strcat (asm_code, \"\\t%3, %2, %3\\n\\tsrlx\\t%3, 32, %H0\\n\\tmov\\t%3, %L0\");\n }\n \f\n /* Output rtl to increment the profiler label LABELNO\n@@ -11156,7 +11159,7 @@ sparc_conditional_register_usage (void)\n     global_regs[SPARC_GSR_REG] = 1;\n }\n \n-/* Implement TARGET_PREFERRED_RELOAD_CLASS\n+/* Implement TARGET_PREFERRED_RELOAD_CLASS:\n \n    - We can't load constants into FP registers.\n    - We can't load FP constants into integer registers when soft-float,\n@@ -11206,8 +11209,11 @@ sparc_preferred_reload_class (rtx x, reg_class_t rclass)\n   return rclass;\n }\n \n+/* Output a wide multiply instruction in V8+ mode.  INSN is the instruction,\n+   OPERANDS are its operands and OPCODE is the mnemonic to be used.  */\n+\n const char *\n-output_v8plus_mult (rtx insn, rtx *operands, const char *name)\n+output_v8plus_mult (rtx insn, rtx *operands, const char *opcode)\n {\n   char mulstr[32];\n \n@@ -11222,15 +11228,15 @@ output_v8plus_mult (rtx insn, rtx *operands, const char *name)\n       if (which_alternative == 1)\n \t{\n \t  output_asm_insn (\"or\\t%L1, %H1, %H1\", operands);\n-\t  sprintf (mulstr, \"%s\\t%%H1, %%2, %%L0\", name);\n+\t  sprintf (mulstr, \"%s\\t%%H1, %%2, %%L0\", opcode);\n \t  output_asm_insn (mulstr, operands);\n \t  return \"srlx\\t%L0, 32, %H0\";\n \t}\n       else\n \t{\n \t  output_asm_insn (\"sllx\\t%H1, 32, %3\", operands);\n           output_asm_insn (\"or\\t%L1, %3, %3\", operands);\n-          sprintf (mulstr, \"%s\\t%%3, %%2, %%3\", name);\n+          sprintf (mulstr, \"%s\\t%%3, %%2, %%3\", opcode);\n \t  output_asm_insn (mulstr, operands);\n \t  output_asm_insn (\"srlx\\t%3, 32, %H0\", operands);\n           return \"mov\\t%3, %L0\";\n@@ -11241,15 +11247,15 @@ output_v8plus_mult (rtx insn, rtx *operands, const char *name)\n       if (which_alternative == 1)\n \t{\n \t  output_asm_insn (\"or\\t%L1, %H1, %H1\", operands);\n-          sprintf (mulstr, \"%s\\t%%H1, %%H1, %%L0\", name);\n+          sprintf (mulstr, \"%s\\t%%H1, %%H1, %%L0\", opcode);\n \t  output_asm_insn (mulstr, operands);\n \t  return \"srlx\\t%L0, 32, %H0\";\n \t}\n       else\n \t{\n \t  output_asm_insn (\"sllx\\t%H1, 32, %3\", operands);\n           output_asm_insn (\"or\\t%L1, %3, %3\", operands);\n-\t  sprintf (mulstr, \"%s\\t%%3, %%3, %%3\", name);\n+\t  sprintf (mulstr, \"%s\\t%%3, %%3, %%3\", opcode);\n \t  output_asm_insn (mulstr, operands);\n \t  output_asm_insn (\"srlx\\t%3, 32, %H0\", operands);\n           return \"mov\\t%3, %L0\";\n@@ -11262,7 +11268,7 @@ output_v8plus_mult (rtx insn, rtx *operands, const char *name)\n       output_asm_insn (\"or\\t%L1, %H1, %H1\", operands);\n       output_asm_insn (\"sllx\\t%H2, 32, %L1\", operands);\n       output_asm_insn (\"or\\t%L2, %L1, %L1\", operands);\n-      sprintf (mulstr, \"%s\\t%%H1, %%L1, %%L0\", name);\n+      sprintf (mulstr, \"%s\\t%%H1, %%L1, %%L0\", opcode);\n       output_asm_insn (mulstr, operands);\n       return \"srlx\\t%L0, 32, %H0\";\n     }\n@@ -11272,15 +11278,20 @@ output_v8plus_mult (rtx insn, rtx *operands, const char *name)\n       output_asm_insn (\"sllx\\t%H2, 32, %4\", operands);\n       output_asm_insn (\"or\\t%L1, %3, %3\", operands);\n       output_asm_insn (\"or\\t%L2, %4, %4\", operands);\n-      sprintf (mulstr, \"%s\\t%%3, %%4, %%3\", name);\n+      sprintf (mulstr, \"%s\\t%%3, %%4, %%3\", opcode);\n       output_asm_insn (mulstr, operands);\n       output_asm_insn (\"srlx\\t%3, 32, %H0\", operands);\n       return \"mov\\t%3, %L0\";\n     }\n }\n \n+/* Subroutine of sparc_expand_vector_init.  Emit code to initialize TARGET to\n+   the N_ELTS values for individual fields contained in LOCS by means of VIS2\n+   BSHUFFLE insn.  MODE and INNER_MODE are the modes describing TARGET.  */\n+\n static void\n-vector_init_bshuffle (rtx target, rtx *locs, int n_elts, enum machine_mode mode,\n+vector_init_bshuffle (rtx target, rtx *locs, int n_elts,\n+\t\t      enum machine_mode mode,\n \t\t      enum machine_mode inner_mode)\n {\n   rtx mid_target, r0_high, r0_low, r1_high, r1_low;\n@@ -11394,6 +11405,11 @@ vector_init_bshuffle (rtx target, rtx *locs, int n_elts, enum machine_mode mode,\n     emit_move_insn (target, gen_lowpart (partial_mode, mid_target));\n }\n \n+/* Subroutine of sparc_expand_vector_init.  Emit code to initialize TARGET to\n+   values for individual fields VALS by means of simple word moves if this is\n+   possible.  MODE and INNER_MODE are the modes describing TARGET.  Return true\n+   on success.  */\n+\n static bool\n vector_init_move_words (rtx target, rtx vals, enum machine_mode mode,\n \t\t\tenum machine_mode inner_mode)\n@@ -11417,11 +11433,13 @@ vector_init_move_words (rtx target, rtx vals, enum machine_mode mode,\n   return false;\n }\n \n-/* Move the elements in rtvec VALS into registers compatible with MODE.\n-   Store the rtx for these regs into the corresponding array entry of\n-   LOCS.  */\n+/* Subroutine of sparc_expand_vector_init.  Move the N_ELTS elements in VALS\n+   into registers compatible with MODE and INNER_MODE.  Store the RTX for\n+   these regs into the corresponding array entry of LOCS.  */\n+\n static void\n-vector_init_prepare_elts (rtx vals, int n_elts, rtx *locs, enum machine_mode mode,\n+vector_init_prepare_elts (rtx *locs, rtx vals, int n_elts,\n+\t\t\t  enum machine_mode mode,\n \t\t\t  enum machine_mode inner_mode)\n {\n   enum machine_mode loc_mode;\n@@ -11494,7 +11512,9 @@ vector_init_prepare_elts (rtx vals, int n_elts, rtx *locs, enum machine_mode mod\n \t\t}\n \t      else if (code != MEM)\n \t\t{\n-\t\t  rtx stk = assign_stack_temp (inner_mode, GET_MODE_SIZE(inner_mode), 0);\n+\t\t  rtx stk\n+\t\t    = assign_stack_temp (inner_mode, GET_MODE_SIZE(inner_mode),\n+\t\t\t\t\t 0);\n \t\t  emit_move_insn (stk, elt);\n \t\t  m = stk;\n \t\t}\n@@ -11516,6 +11536,11 @@ vector_init_prepare_elts (rtx vals, int n_elts, rtx *locs, enum machine_mode mod\n     }\n }\n \n+/* Subroutine of sparc_expand_vector_init.  Emit code to initialize TARGET to\n+   the N_ELTS values for individual fields contained in LOCS by means of VIS2\n+   instructions, among which N_UNIQUE are unique.  MODE and INNER_MODE are the\n+   modes describing TARGET.  */\n+\n static void\n sparc_expand_vector_init_vis2 (rtx target, rtx *locs, int n_elts, int n_unique,\n \t\t\t       enum machine_mode mode,\n@@ -11541,6 +11566,10 @@ sparc_expand_vector_init_vis2 (rtx target, rtx *locs, int n_elts, int n_unique,\n     }\n }\n \n+/* Subroutine of sparc_expand_vector_init.  Emit code to initialize TARGET to\n+   the N_ELTS values for individual fields contained in LOCS by means of VIS1\n+   instructions, among which N_UNIQUE are unique.  MODE is TARGET's mode.  */\n+\n static void\n sparc_expand_vector_init_vis1 (rtx target, rtx *locs, int n_elts, int n_unique,\n \t\t\t       enum machine_mode mode)\n@@ -11609,6 +11638,8 @@ sparc_expand_vector_init_vis1 (rtx target, rtx *locs, int n_elts, int n_unique,\n     emit_move_insn (target, gen_highpart (mode, tmp));\n }\n \n+/* Emit code to initialize TARGET to values for individual fields VALS.  */\n+\n void\n sparc_expand_vector_init (rtx target, rtx vals)\n {\n@@ -11650,7 +11681,7 @@ sparc_expand_vector_init (rtx target, rtx vals)\n   if (vector_init_move_words (target, vals, mode, inner_mode))\n     return;\n \n-  vector_init_prepare_elts (vals, n_elts, locs, mode, inner_mode);\n+  vector_init_prepare_elts (locs, vals, n_elts, mode, inner_mode);\n \n   if (TARGET_VIS2)\n     sparc_expand_vector_init_vis2 (target, locs, n_elts, n_unique,\n@@ -11659,6 +11690,8 @@ sparc_expand_vector_init (rtx target, rtx vals)\n     sparc_expand_vector_init_vis1 (target, locs, n_elts, n_unique, mode);\n }\n \n+/* Implement TARGET_SECONDARY_RELOAD.  */\n+\n static reg_class_t\n sparc_secondary_reload (bool in_p, rtx x, reg_class_t rclass_i,\n \t\t\tenum machine_mode mode, secondary_reload_info *sri)\n@@ -11722,6 +11755,9 @@ sparc_secondary_reload (bool in_p, rtx x, reg_class_t rclass_i,\n   return NO_REGS;\n }\n \n+/* Emit code to conditionally move either OPERANDS[2] or OPERANDS[3] into\n+   OPERANDS[0] in MODE.  OPERANDS[1] is the operator of the condition.  */\n+\n bool\n sparc_expand_conditional_move (enum machine_mode mode, rtx *operands)\n {\n@@ -11777,6 +11813,12 @@ sparc_expand_conditional_move (enum machine_mode mode, rtx *operands)\n   return true;\n }\n \n+/* Emit code to conditionally move a combination of OPERANDS[1] and OPERANDS[2]\n+   into OPERANDS[0] in MODE, depending on the outcome of the comparison of\n+   OPERANDS[4] and OPERANDS[5].  OPERANDS[3] is the operator of the condition.\n+   FCODE is the machine code to be used for OPERANDS[3] and CCODE the machine\n+   code to be used for the condition mask.  */\n+\n void\n sparc_expand_vcond (enum machine_mode mode, rtx *operands, int ccode, int fcode)\n {"}, {"sha": "bf750b29e421ed403ae916d664b7d4f266ead21e", "filename": "gcc/config/sparc/sparc.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68126bad7bac641c40f6796f451093d07a1798b6/gcc%2Fconfig%2Fsparc%2Fsparc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68126bad7bac641c40f6796f451093d07a1798b6/gcc%2Fconfig%2Fsparc%2Fsparc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.md?ref=68126bad7bac641c40f6796f451093d07a1798b6", "patch": "@@ -5649,7 +5649,7 @@\n \t\t   (match_operand:SI 2 \"arith_operand\" \"rI,rI,rI\")))\n    (clobber (match_scratch:SI 3 \"=X,X,&h\"))]\n   \"TARGET_V8PLUS\"\n-  \"* return output_v8plus_shift (operands, insn, \\\"sllx\\\");\"\n+  \"* return output_v8plus_shift (insn ,operands, \\\"sllx\\\");\"\n   [(set_attr \"type\" \"multi\")\n    (set_attr \"length\" \"5,5,6\")])\n \n@@ -5759,7 +5759,7 @@\n \t\t     (match_operand:SI 2 \"arith_operand\" \"rI,rI,rI\")))\n    (clobber (match_scratch:SI 3 \"=X,X,&h\"))]\n   \"TARGET_V8PLUS\"\n-  \"* return output_v8plus_shift (operands, insn, \\\"srax\\\");\"\n+  \"* return output_v8plus_shift (insn, operands, \\\"srax\\\");\"\n   [(set_attr \"type\" \"multi\")\n    (set_attr \"length\" \"5,5,6\")])\n \n@@ -5849,7 +5849,7 @@\n \t\t     (match_operand:SI 2 \"arith_operand\" \"rI,rI,rI\")))\n    (clobber (match_scratch:SI 3 \"=X,X,&h\"))]\n   \"TARGET_V8PLUS\"\n-  \"* return output_v8plus_shift (operands, insn, \\\"srlx\\\");\"\n+  \"* return output_v8plus_shift (insn, operands, \\\"srlx\\\");\"\n   [(set_attr \"type\" \"multi\")\n    (set_attr \"length\" \"5,5,6\")])\n "}]}