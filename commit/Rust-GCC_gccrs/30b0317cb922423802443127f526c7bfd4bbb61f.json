{"sha": "30b0317cb922423802443127f526c7bfd4bbb61f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzBiMDMxN2NiOTIyNDIzODAyNDQzMTI3ZjUyNmM3YmZkNGJiYjYxZg==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2013-03-26T09:14:59Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2013-03-26T09:14:59Z"}, "message": "emit-rtl.c (set_mem_attributes_minus_bitpos): Remove alignment computations and rely on get_object_alignment_1 for the...\n\n2013-03-26  Richard Biener  <rguenther@suse.de>\n\n\t* emit-rtl.c (set_mem_attributes_minus_bitpos): Remove\n\talignment computations and rely on get_object_alignment_1\n\tfor the !TYPE_P case.\n\tCommonize DECL/COMPONENT_REF handling in the ARRAY_REF path.\n\nFrom-SVN: r197095", "tree": {"sha": "6e163de4f8776d1d4ec960e026bfa6b63c52a023", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6e163de4f8776d1d4ec960e026bfa6b63c52a023"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/30b0317cb922423802443127f526c7bfd4bbb61f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/30b0317cb922423802443127f526c7bfd4bbb61f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/30b0317cb922423802443127f526c7bfd4bbb61f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/30b0317cb922423802443127f526c7bfd4bbb61f/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "cbcdb1406c417b53e8a8845ce431ad9492cae644", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cbcdb1406c417b53e8a8845ce431ad9492cae644", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cbcdb1406c417b53e8a8845ce431ad9492cae644"}], "stats": {"total": 105, "additions": 24, "deletions": 81}, "files": [{"sha": "dd61f1545229d192433aeb762adf979f298e5edb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30b0317cb922423802443127f526c7bfd4bbb61f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30b0317cb922423802443127f526c7bfd4bbb61f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=30b0317cb922423802443127f526c7bfd4bbb61f", "patch": "@@ -1,3 +1,10 @@\n+2013-03-26  Richard Biener  <rguenther@suse.de>\n+\n+\t* emit-rtl.c (set_mem_attributes_minus_bitpos): Remove\n+\talignment computations and rely on get_object_alignment_1\n+\tfor the !TYPE_P case.\n+\tCommonize DECL/COMPONENT_REF handling in the ARRAY_REF path.\n+\n 2013-03-26  Walter Lee  <walt@tilera.com>\n \n \t* config/tilegx/tilegx.h (PROFILE_BEFORE_PROLOGUE): Define."}, {"sha": "e412bef9570285399aac1b9c590a1214d924187c", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 17, "deletions": 81, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30b0317cb922423802443127f526c7bfd4bbb61f/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30b0317cb922423802443127f526c7bfd4bbb61f/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=30b0317cb922423802443127f526c7bfd4bbb61f", "patch": "@@ -1653,51 +1653,17 @@ set_mem_attributes_minus_bitpos (rtx ref, tree t, int objectp,\n   if (objectp || TREE_CODE (t) == INDIRECT_REF || TYPE_ALIGN_OK (type))\n     attrs.align = MAX (attrs.align, TYPE_ALIGN (type));\n \n-  else if (TREE_CODE (t) == MEM_REF)\n-    {\n-      tree op0 = TREE_OPERAND (t, 0);\n-      if (TREE_CODE (op0) == ADDR_EXPR\n-\t  && (DECL_P (TREE_OPERAND (op0, 0))\n-\t      || CONSTANT_CLASS_P (TREE_OPERAND (op0, 0))))\n-\t{\n-\t  if (DECL_P (TREE_OPERAND (op0, 0)))\n-\t    attrs.align = DECL_ALIGN (TREE_OPERAND (op0, 0));\n-\t  else if (CONSTANT_CLASS_P (TREE_OPERAND (op0, 0)))\n-\t    {\n-\t      attrs.align = TYPE_ALIGN (TREE_TYPE (TREE_OPERAND (op0, 0)));\n-#ifdef CONSTANT_ALIGNMENT\n-\t      attrs.align = CONSTANT_ALIGNMENT (TREE_OPERAND (op0, 0),\n-\t\t\t\t\t\tattrs.align);\n-#endif\n-\t    }\n-\t  if (TREE_INT_CST_LOW (TREE_OPERAND (t, 1)) != 0)\n-\t    {\n-\t      unsigned HOST_WIDE_INT ioff\n-\t\t= TREE_INT_CST_LOW (TREE_OPERAND (t, 1));\n-\t      unsigned HOST_WIDE_INT aoff = (ioff & -ioff) * BITS_PER_UNIT;\n-\t      attrs.align = MIN (aoff, attrs.align);\n-\t    }\n-\t}\n-      else\n-\t/* ??? This isn't fully correct, we can't set the alignment from the\n-\t   type in all cases.  */\n-\tattrs.align = MAX (attrs.align, TYPE_ALIGN (type));\n-    }\n-\n-  else if (TREE_CODE (t) == TARGET_MEM_REF)\n-    /* ??? This isn't fully correct, we can't set the alignment from the\n-       type in all cases.  */\n-    attrs.align = MAX (attrs.align, TYPE_ALIGN (type));\n-\n   /* If the size is known, we can set that.  */\n   tree new_size = TYPE_SIZE_UNIT (type);\n \n+  /* The address-space is that of the type.  */\n+  as = TYPE_ADDR_SPACE (type);\n+\n   /* If T is not a type, we may be able to deduce some more information about\n      the expression.  */\n   if (! TYPE_P (t))\n     {\n       tree base;\n-      bool align_computed = false;\n \n       if (TREE_THIS_VOLATILE (t))\n \tMEM_VOLATILE_P (ref) = 1;\n@@ -1727,15 +1693,14 @@ set_mem_attributes_minus_bitpos (rtx ref, tree t, int objectp,\n \t      && TREE_STATIC (base))\n \t    MEM_READONLY_P (ref) = 1;\n \n+\t  /* Address-space information is on the base object.  */\n \t  if (TREE_CODE (base) == MEM_REF\n \t      || TREE_CODE (base) == TARGET_MEM_REF)\n \t    as = TYPE_ADDR_SPACE (TREE_TYPE (TREE_TYPE (TREE_OPERAND (base,\n \t\t\t\t\t\t\t\t      0))));\n \t  else\n \t    as = TYPE_ADDR_SPACE (TREE_TYPE (base));\n \t}\n-      else\n-\tas = TYPE_ADDR_SPACE (type);\n \n       /* If this expression uses it's parent's alias set, mark it such\n \t that we won't change it.  */\n@@ -1750,19 +1715,11 @@ set_mem_attributes_minus_bitpos (rtx ref, tree t, int objectp,\n \t  attrs.offset = 0;\n \t  apply_bitpos = bitpos;\n \t  new_size = DECL_SIZE_UNIT (t);\n-\t  attrs.align = DECL_ALIGN (t);\n-\t  align_computed = true;\n \t}\n \n-      /* If this is a constant, we know the alignment.  */\n+      /* ???  If we end up with a constant here do record a MEM_EXPR.  */\n       else if (CONSTANT_CLASS_P (t))\n-\t{\n-\t  attrs.align = TYPE_ALIGN (type);\n-#ifdef CONSTANT_ALIGNMENT\n-\t  attrs.align = CONSTANT_ALIGNMENT (t, attrs.align);\n-#endif\n-\t  align_computed = true;\n-\t}\n+\t;\n \n       /* If this is a field reference, record it.  */\n       else if (TREE_CODE (t) == COMPONENT_REF)\n@@ -1807,24 +1764,8 @@ set_mem_attributes_minus_bitpos (rtx ref, tree t, int objectp,\n \t    }\n \t  while (TREE_CODE (t2) == ARRAY_REF);\n \n-\t  if (DECL_P (t2))\n-\t    {\n-\t      attrs.expr = t2;\n-\t      attrs.offset_known_p = false;\n-\t      if (host_integerp (off_tree, 1))\n-\t\t{\n-\t\t  HOST_WIDE_INT ioff = tree_low_cst (off_tree, 1);\n-\t\t  HOST_WIDE_INT aoff = (ioff & -ioff) * BITS_PER_UNIT;\n-\t\t  attrs.align = DECL_ALIGN (t2);\n-\t\t  if (aoff && (unsigned HOST_WIDE_INT) aoff < attrs.align)\n-\t            attrs.align = aoff;\n-\t\t  align_computed = true;\n-\t\t  attrs.offset_known_p = true;\n-\t\t  attrs.offset = ioff;\n-\t\t  apply_bitpos = bitpos;\n-\t\t}\n-\t    }\n-\t  else if (TREE_CODE (t2) == COMPONENT_REF)\n+\t  if (DECL_P (t2)\n+\t      || TREE_CODE (t2) == COMPONENT_REF)\n \t    {\n \t      attrs.expr = t2;\n \t      attrs.offset_known_p = false;\n@@ -1834,9 +1775,8 @@ set_mem_attributes_minus_bitpos (rtx ref, tree t, int objectp,\n \t\t  attrs.offset = tree_low_cst (off_tree, 1);\n \t\t  apply_bitpos = bitpos;\n \t\t}\n-\t      /* ??? Any reason the field size would be different than\n-\t\t the size we got from the type?  */\n \t    }\n+\t  /* Else do not record a MEM_EXPR.  */\n \t}\n \n       /* If this is an indirect reference, record it.  */\n@@ -1849,19 +1789,15 @@ set_mem_attributes_minus_bitpos (rtx ref, tree t, int objectp,\n \t  apply_bitpos = bitpos;\n \t}\n \n-      if (!align_computed)\n-\t{\n-\t  unsigned int obj_align;\n-\t  unsigned HOST_WIDE_INT obj_bitpos;\n-\t  get_object_alignment_1 (t, &obj_align, &obj_bitpos);\n-\t  obj_bitpos = (obj_bitpos - bitpos) & (obj_align - 1);\n-\t  if (obj_bitpos != 0)\n-\t    obj_align = (obj_bitpos & -obj_bitpos);\n-\t  attrs.align = MAX (attrs.align, obj_align);\n-\t}\n+      /* Compute the alignment.  */\n+      unsigned int obj_align;\n+      unsigned HOST_WIDE_INT obj_bitpos;\n+      get_object_alignment_1 (t, &obj_align, &obj_bitpos);\n+      obj_bitpos = (obj_bitpos - bitpos) & (obj_align - 1);\n+      if (obj_bitpos != 0)\n+\tobj_align = (obj_bitpos & -obj_bitpos);\n+      attrs.align = MAX (attrs.align, obj_align);\n     }\n-  else\n-    as = TYPE_ADDR_SPACE (type);\n \n   if (host_integerp (new_size, 1))\n     {"}]}