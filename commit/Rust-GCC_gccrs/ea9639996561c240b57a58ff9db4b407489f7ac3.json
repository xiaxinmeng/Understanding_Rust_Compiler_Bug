{"sha": "ea9639996561c240b57a58ff9db4b407489f7ac3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWE5NjM5OTk2NTYxYzI0MGI1N2E1OGZmOWRiNGI0MDc0ODlmN2FjMw==", "commit": {"author": {"name": "Olivier Hainque", "email": "hainque@adacore.com", "date": "2011-06-14T12:20:08Z"}, "committer": {"name": "Rainer Orth", "email": "ro@gcc.gnu.org", "date": "2011-06-14T12:20:08Z"}, "message": "irix6-unwind.h: New file.\n\n2011-06-14  Olivier Hainque  <hainque@adacore.com>\n\t    Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n\n\t* config/mips/irix6-unwind.h: New file.\n\t* config.host (mips-sgi-irix6.5*): Set md_unwind_header.\n\nCo-Authored-By: Rainer Orth <ro@CeBiTec.Uni-Bielefeld.DE>\n\nFrom-SVN: r175013", "tree": {"sha": "0c4b65cf7456f0c5d2cdcfc35ad20a3bf9561cb3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0c4b65cf7456f0c5d2cdcfc35ad20a3bf9561cb3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ea9639996561c240b57a58ff9db4b407489f7ac3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ea9639996561c240b57a58ff9db4b407489f7ac3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ea9639996561c240b57a58ff9db4b407489f7ac3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ea9639996561c240b57a58ff9db4b407489f7ac3/comments", "author": {"login": "hainque", "id": 18735142, "node_id": "MDQ6VXNlcjE4NzM1MTQy", "avatar_url": "https://avatars.githubusercontent.com/u/18735142?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hainque", "html_url": "https://github.com/hainque", "followers_url": "https://api.github.com/users/hainque/followers", "following_url": "https://api.github.com/users/hainque/following{/other_user}", "gists_url": "https://api.github.com/users/hainque/gists{/gist_id}", "starred_url": "https://api.github.com/users/hainque/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hainque/subscriptions", "organizations_url": "https://api.github.com/users/hainque/orgs", "repos_url": "https://api.github.com/users/hainque/repos", "events_url": "https://api.github.com/users/hainque/events{/privacy}", "received_events_url": "https://api.github.com/users/hainque/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "37e1a18f04e97714fa63d486bbce76e28e22baa3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/37e1a18f04e97714fa63d486bbce76e28e22baa3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/37e1a18f04e97714fa63d486bbce76e28e22baa3"}], "stats": {"total": 187, "additions": 187, "deletions": 0}, "files": [{"sha": "1ce7387107f2db640785bfa2ba367be4d07ba5bd", "filename": "libgcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea9639996561c240b57a58ff9db4b407489f7ac3/libgcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea9639996561c240b57a58ff9db4b407489f7ac3/libgcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2FChangeLog?ref=ea9639996561c240b57a58ff9db4b407489f7ac3", "patch": "@@ -1,3 +1,9 @@\n+2011-06-14  Olivier Hainque  <hainque@adacore.com>\n+\t    Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n+\n+\t* config/mips/irix6-unwind.h: New file.\n+\t* config.host (mips-sgi-irix6.5*): Set md_unwind_header.\n+\n 2011-06-10  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* config/sparc/linux-unwind.h (STACK_BIAS): Define."}, {"sha": "6ea74900c86b2b617f1f9252d4fa83f791da350d", "filename": "libgcc/config.host", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea9639996561c240b57a58ff9db4b407489f7ac3/libgcc%2Fconfig.host", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea9639996561c240b57a58ff9db4b407489f7ac3/libgcc%2Fconfig.host", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig.host?ref=ea9639996561c240b57a58ff9db4b407489f7ac3", "patch": "@@ -456,6 +456,7 @@ microblaze*-*-*)\n mips-sgi-irix6.5*)\n \ttmake_file=\"mips/t-irix6 t-crtfm t-slibgcc mips/t-slibgcc-irix\"\n \textra_parts=\"crtbegin.o crtend.o crtfastmath.o irix-crti.o irix-crtn.o\"\n+\tmd_unwind_header=mips/irix6-unwind.h\n \t;;\n mips*-*-netbsd*)\t\t\t# NetBSD/mips, either endian.\n \t;;"}, {"sha": "e862560fe341a9fbacfcb0718bf6e9506999c8ee", "filename": "libgcc/config/mips/irix6-unwind.h", "status": "added", "additions": 180, "deletions": 0, "changes": 180, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea9639996561c240b57a58ff9db4b407489f7ac3/libgcc%2Fconfig%2Fmips%2Firix6-unwind.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea9639996561c240b57a58ff9db4b407489f7ac3/libgcc%2Fconfig%2Fmips%2Firix6-unwind.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fmips%2Firix6-unwind.h?ref=ea9639996561c240b57a58ff9db4b407489f7ac3", "patch": "@@ -0,0 +1,180 @@\n+/* DWARF2 EH unwinding support for MIPS IRIX 6.\n+   Copyright (C) 2011 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+/* Do code reading to identify a signal frame, and set the frame\n+   state data appropriately.  See unwind-dw2.c for the structs.  */\n+\n+/* This code was developed-for and only tested-in limited ABI\n+   configurations.  Characterize that.  */\n+\n+#if defined (_ABIN32) || defined (_ABI64)\n+#define SUPPORTED_ABI 1\n+#else\n+#define SUPPORTED_ABI 0\n+#endif\n+\n+#include <signal.h>\n+\n+#define MD_FALLBACK_FRAME_STATE_FOR mips_fallback_frame_state\n+\n+/* Look at the code around RA to see if it matches a sighandler caller with a\n+   sigcontext_t * argument (SA_SIGINFO cleared).  Return that pointer argument\n+   if it does match, or 0 otherwise.  */\n+\n+static sigcontext_t *\n+sigcontext_for (unsigned int *ra, void *cfa)\n+{\n+  /* IRIX 6.5, mono-threaded application.  We're lucky enough to be able\n+     to expect a short very sighandler specific sequence around.\n+\n+     <_sigtramp+124>:\tli\tv0,1088 (SYS_sigreturn)\n+     <_sigtramp+128>:\tsyscall  */\n+\n+  if (   ra[6] == 0x24020440\n+      && ra[7] == 0x0000000c)\n+    return (sigcontext_t *)(cfa + 0x30);\n+\n+  /* IRIX 6.5 variants, multi-threaded application, pthreads.  Nothing really\n+     sighandler specific handy, so match a fairly long constant sequence.  */\n+\n+#if _MIPS_SIM == _ABIN32\n+  /* \n+     <sig_fixup_mask+40>:\tsd\ts0,0(sp)\n+     <sig_fixup_mask+44>:\tsll\tra,a0,0x2\n+     <sig_fixup_mask+48>:\taddiu\tt9,t9,-28584/-28456/-28448\n+     <sig_fixup_mask+52>:\tlw\ts0,3804(at)\n+     <sig_fixup_mask+56>:\taddu\tt9,t9,ra\n+     <sig_fixup_mask+60>:\tlw\tt9,0(t9)\n+     <sig_fixup_mask+64>:\tld\tat,3696(at)\n+     <sig_fixup_mask+68>:\tld\ts2,88(s0)\n+     <sig_fixup_mask+72>:\tjalr\tt9\n+     <sig_fixup_mask+76>:\tsd\tat,88(s0)  */\n+   if (   ra[-10] == 0xffb00000\n+      && ra[ -9] == 0x0004f880\n+      && (ra[-8] == 0x27399058\n+\t  || ra[-8] == 0x273990d8\n+\t  || ra[-8] == 0x273990e0)\n+      && ra[ -7] == 0x8c300edc\n+      && ra[ -6] == 0x033fc821\n+      && ra[ -5] == 0x8f390000\n+      && ra[ -4] == 0xdc210e70\n+      && ra[ -3] == 0xde120058\n+      && ra[ -2] == 0x0320f809\n+      && ra[ -1] == 0xfe010058)\n+\n+#elif _MIPS_SIM == _ABI64\n+  /* \n+     <sig_fixup_mask+44>:\tsd\ts0,0(sp)\n+     <sig_fixup_mask+48>:\tdaddu\tt9,t9,ra\n+     <sig_fixup_mask+52>:\tdsll\tra,a0,0x3\n+     <sig_fixup_mask+56>:\tld\ts0,3880(at)\n+     <sig_fixup_mask+60>:\tdaddu\tt9,t9,ra\n+     <sig_fixup_mask+64>:\tld\tt9,0(t9)\n+     <sig_fixup_mask+68>:\tld\tat,3696(at)\n+     <sig_fixup_mask+72>:\tld\ts2,152(s0)\n+     <sig_fixup_mask+76>:\tjalr\tt9\n+     <sig_fixup_mask+80>:\tsd\tat,152(s0)  */\n+  if (   ra[-10] == 0xffb00000\n+      && ra[ -9] == 0x033fc82d\n+      && ra[ -8] == 0x0004f8f8\n+      && ra[ -7] == 0xdc300f28\n+      && ra[ -6] == 0x033fc82d\n+      && ra[ -5] == 0xdf390000\n+      && ra[ -4] == 0xdc210e70\n+      && ra[ -3] == 0xde120098\n+      && ra[ -2] == 0x0320f809\n+      && ra[ -1] == 0xfe010098)\n+#endif\n+    return (sigcontext_t *)(cfa + 0x60);\n+\n+  return 0;\n+}\n+\n+#define SIGCTX_GREG_ADDR(REGNO,SIGCTX) \\\n+  ((void *) &(SIGCTX)->sc_regs[REGNO])\n+\n+#define SIGCTX_FPREG_ADDR(REGNO,SIGCTX) \\\n+  ((void *) &(SIGCTX)->sc_fpregs[REGNO])\n+\n+static _Unwind_Reason_Code\n+mips_fallback_frame_state (struct _Unwind_Context *context,\n+\t\t\t   _Unwind_FrameState *fs)\n+{\n+  /* Return address and CFA of the frame we're attempting to unwind through,\n+     possibly a signal handler.  */\n+  void *ctx_ra  = (void *)context->ra;\n+  void *ctx_cfa = (void *)context->cfa;\n+\n+  /* CFA of the intermediate abstract kernel frame between the interrupted\n+     code and the signal handler, if we're indeed unwinding through a signal\n+     handler.  */\n+  void *k_cfa;\n+\n+  /* Pointer to the sigcontext_t structure pushed by the kernel when we're\n+     unwinding through a signal handler setup with SA_SIGINFO cleared.  */\n+  sigcontext_t *sigctx;\n+  int i;\n+\n+  if (! SUPPORTED_ABI)\n+    return _URC_END_OF_STACK;\n+    \n+  sigctx = sigcontext_for (ctx_ra, ctx_cfa);\n+\n+  if (sigctx == 0)\n+    return _URC_END_OF_STACK;\n+\n+  /* The abstract kernel frame's CFA is extactly the stack pointer\n+     value at the interruption point.  */\n+  k_cfa = *(void **)SIGCTX_GREG_ADDR (CTX_SP, sigctx);\n+\n+  /* State the rules to compute the CFA we have the value of: use the\n+     previous CFA and offset by the difference between the two.  See\n+     uw_update_context_1 for the supporting details.  */\n+  fs->regs.cfa_how = CFA_REG_OFFSET;\n+  fs->regs.cfa_reg = __builtin_dwarf_sp_column ();\n+  fs->regs.cfa_offset = k_cfa - ctx_cfa;\n+\n+  /* Fill the internal frame_state structure with information stating where\n+     each register of interest can be found from the CFA.  */\n+  for (i = 0; i <= 31; i ++)\n+    {\n+      fs->regs.reg[i].how = REG_SAVED_OFFSET;\n+      fs->regs.reg[i].loc.offset = SIGCTX_GREG_ADDR (i, sigctx) - k_cfa;\n+    }\n+\n+  for (i = 0; i <= 31; i ++)\n+    {\n+      fs->regs.reg[32+i].how = REG_SAVED_OFFSET;\n+      fs->regs.reg[32+i].loc.offset = SIGCTX_FPREG_ADDR (i, sigctx) - k_cfa;\n+    }\n+\n+  /* State the rules to find the kernel's code \"return address\", which is the\n+     address of the active instruction when the signal was caught.  */\n+  fs->retaddr_column = DWARF_FRAME_RETURN_COLUMN;\n+  fs->regs.reg[fs->retaddr_column].how = REG_SAVED_OFFSET;\n+  fs->regs.reg[fs->retaddr_column].loc.offset = (void *)&sigctx->sc_pc - k_cfa;\n+  fs->signal_frame = 1;\n+\n+  return _URC_NO_REASON;\n+}"}]}