{"sha": "e6455a099ec74071ba9c011cc314a48cadbe2bfe", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTY0NTVhMDk5ZWM3NDA3MWJhOWMwMTFjYzMxNGE0OGNhZGJlMmJmZQ==", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2021-04-26T17:24:09Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2021-04-26T20:28:04Z"}, "message": "Handle anti-ranges of MIN,MAX uniformly.\n\nThe -fstrict-enums comment in the VR_ANTI_RANGE handling code is out\nof date, as out-of-range ranges have already been handled by this\ntime.  I've removed it.\n\nFurthermore, optimizing ~[MIN,MAX] as VARYING instead of UNDEFINED is\nan old idiom.  I've been wanting to change it for a while, but have\nonly remembered late in the release cycle when it was too risky.\n\nWhat I've chosen to do in this case is fall through to the code that\nnormalizes the range.  This will correctly turn ~[MIN,MAX] into\nUNDEFINED, yet leaving things alone in the case of -fstrict-enums\nwhere [MIN,MAX] may not necessarily include the entire range of the\nunderlying precision.  For example, if the domain of a strict enum is\n[3,5] setting a VR_ANTI_RANGE of ~[3,5] should not cause neither\nVR_UNDEFINED nor VR_VARYING, but just plain ~[3,5].\n\nThis is similar to what we do for -fstrict-enums when we set a range\nof [3,5].  We leave it as a VR_RANGE, instead of upgrading it to\nVR_VARYING.\n\ngcc/ChangeLog:\n\n\t* value-range.cc (irange::irange_set_1bit_anti_range): Add assert.\n\t(irange::set): Call irange_set_1bit_anti_range for handling all\n\t1-bit ranges.  Fall through on ~[MIN,MAX].", "tree": {"sha": "00f54135bd65305be20f774b7d0a0f5714e1a8c4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/00f54135bd65305be20f774b7d0a0f5714e1a8c4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e6455a099ec74071ba9c011cc314a48cadbe2bfe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e6455a099ec74071ba9c011cc314a48cadbe2bfe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e6455a099ec74071ba9c011cc314a48cadbe2bfe", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e6455a099ec74071ba9c011cc314a48cadbe2bfe/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2e0b1c6ce3afe0670b96444c6b955ce184ed0046", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e0b1c6ce3afe0670b96444c6b955ce184ed0046", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2e0b1c6ce3afe0670b96444c6b955ce184ed0046"}], "stats": {"total": 26, "additions": 10, "deletions": 16}, "files": [{"sha": "2decd08d155551ec91084929a4424a6922f25af6", "filename": "gcc/value-range.cc", "status": "modified", "additions": 10, "deletions": 16, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6455a099ec74071ba9c011cc314a48cadbe2bfe/gcc%2Fvalue-range.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6455a099ec74071ba9c011cc314a48cadbe2bfe/gcc%2Fvalue-range.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-range.cc?ref=e6455a099ec74071ba9c011cc314a48cadbe2bfe", "patch": "@@ -203,6 +203,8 @@ irange::irange_set_1bit_anti_range (tree min, tree max)\n   else\n     {\n       // The only alternative is [MIN,MAX], which is the empty range.\n+      gcc_checking_assert (vrp_val_is_min (min));\n+      gcc_checking_assert (vrp_val_is_max (max));\n       set_undefined ();\n     }\n   if (flag_checking)\n@@ -313,29 +315,21 @@ irange::set (tree min, tree max, value_range_kind kind)\n   // Anti-ranges that can be represented as ranges should be so.\n   if (kind == VR_ANTI_RANGE)\n     {\n-      /* For -fstrict-enums we may receive out-of-range ranges so consider\n-         values < -INF and values > INF as -INF/INF as well.  */\n       bool is_min = vrp_val_is_min (min);\n       bool is_max = vrp_val_is_max (max);\n-      tree type = TREE_TYPE (min);\n \n       if (is_min && is_max)\n \t{\n-\t  /* We cannot deal with empty ranges, drop to varying.\n-\t     ???  This could be VR_UNDEFINED instead.  */\n-\t  set_varying (type);\n-\t  return;\n+\t  // Fall through.  This will either be normalized as\n+\t  // VR_UNDEFINED if the anti-range spans the entire\n+\t  // precision, or it will remain an VR_ANTI_RANGE in the case\n+\t  // of an -fstrict-enum where [MIN,MAX] is less than the span\n+\t  // of underlying precision.\n \t}\n-      else if (TYPE_PRECISION (TREE_TYPE (min)) == 1\n-\t       && (is_min || is_max))\n+      else if (TYPE_PRECISION (TREE_TYPE (min)) == 1)\n \t{\n-\t  /* Non-empty boolean ranges can always be represented\n-\t     as a singleton range.  */\n-\t  if (is_min)\n-\t    min = max = vrp_val_max (TREE_TYPE (min));\n-\t  else\n-\t    min = max = vrp_val_min (TREE_TYPE (min));\n-\t  kind = VR_RANGE;\n+\t  irange_set_1bit_anti_range (min, max);\n+\t  return;\n \t}\n       else if (is_min)\n         {"}]}