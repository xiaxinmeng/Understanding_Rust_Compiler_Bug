{"sha": "573aa7d4b7c1249c16c12c8483ab8b9830848b82", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTczYWE3ZDRiN2MxMjQ5YzE2YzEyYzg0ODNhYjhiOTgzMDg0OGI4Mg==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2016-12-12T21:56:22Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@gcc.gnu.org", "date": "2016-12-12T21:56:22Z"}, "message": "PR middle-end/78622 - -Wformat-length/-fprintf-return-value incorrect with overflow/wrapping\n\ngcc/ChangeLog:\n\n\tPR middle-end/78622\n\tPR middle-end78606\n\t* gimple-ssa-sprintf.c (min_bytes_remaining): Use res.knownrange\n\trather than res.bounded.\n\t(get_width_and_precision): Set precision to -1 when negative.\n\t(adjust_range_for_overflow): New function.\n\t(format_integer): Correct the handling of the space, plus, and pound\n\tflags, and the special case of zero precision.\n\tAlways set res.bounded to true unless either precision or width\n\tis specified and unknown.\n\tCall adjust_range_for_overflow.\n\tAvoid use zero as the shortest value when precision is specified\n\tbut unknown.\n\t(format_directive): Remove vestigial quoting.  Always inform of\n\targument value or range when it's available.\n\t(add_bytes): Correct the computation of boundrange used to\n\tdecide whether a warning is of a \"maybe\" or \"defnitely\" kind.\n\ngcc/testsuite/ChangeLog:\n\n\tPR middle-end/78622\n\tPR middle-end78606\n\t* gcc.c-torture/execute/pr78622.c: New test.\n\t* gcc.dg/tree-ssa/builtin-sprintf-2.c: Remove \"benign\" undefined\n\tbehavior inadvertently introduced in a previous commit.  Tighten\n\tup final checking.\n\t* gcc.dg/tree-ssa/builtin-sprintf-5.c: Rename macros for clarity.\n\tAdd test cases.\n\t* gcc.dg/tree-ssa/builtin-sprintf-6.c: Add test cases.\n\t* gcc.dg/tree-ssa/builtin-sprintf-warn-1.c: Same.\n\t* gcc.dg/tree-ssa/builtin-sprintf-warn-2.c: Same.\n\t* gcc.dg/tree-ssa/builtin-sprintf-warn-3.c: Same.\n\t* gcc.dg/tree-ssa/builtin-sprintf-warn-5.c: Same.\n\t* gcc.dg/tree-ssa/builtin-sprintf-warn-6.c: Remove xfails and\n\tadd a final optimization check.\n\t* gcc.dg/tree-ssa/builtin-sprintf.c: Add test cases.\n\t* gcc.dg/tree-ssa/pr78622.c: New test.\n\nFrom-SVN: r243582", "tree": {"sha": "0db314e59f7a48d91b36bc70196945369abde7e7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0db314e59f7a48d91b36bc70196945369abde7e7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/573aa7d4b7c1249c16c12c8483ab8b9830848b82", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/573aa7d4b7c1249c16c12c8483ab8b9830848b82", "html_url": "https://github.com/Rust-GCC/gccrs/commit/573aa7d4b7c1249c16c12c8483ab8b9830848b82", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/573aa7d4b7c1249c16c12c8483ab8b9830848b82/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "068b961b6a5ad37898cee76ce0e80ef46001eb03", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/068b961b6a5ad37898cee76ce0e80ef46001eb03", "html_url": "https://github.com/Rust-GCC/gccrs/commit/068b961b6a5ad37898cee76ce0e80ef46001eb03"}], "stats": {"total": 1034, "additions": 756, "deletions": 278}, "files": [{"sha": "efc8bdd5b850bf564656649044354b99dd8e21ca", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/573aa7d4b7c1249c16c12c8483ab8b9830848b82/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/573aa7d4b7c1249c16c12c8483ab8b9830848b82/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=573aa7d4b7c1249c16c12c8483ab8b9830848b82", "patch": "@@ -1,3 +1,23 @@\n+2016-12-12  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR middle-end/78622\n+\tPR middle-end78606\n+\t* gimple-ssa-sprintf.c (min_bytes_remaining): Use res.knownrange\n+\trather than res.bounded.\n+\t(get_width_and_precision): Set precision to -1 when negative.\n+\t(adjust_range_for_overflow): New function.\n+\t(format_integer): Correct the handling of the space, plus, and pound\n+\tflags, and the special case of zero precision.\n+\tAlways set res.bounded to true unless either precision or width\n+\tis specified and unknown.\n+\tCall adjust_range_for_overflow.\n+\tAvoid use zero as the shortest value when precision is specified\n+\tbut unknown.\n+\t(format_directive): Remove vestigial quoting.  Always inform of\n+\targument value or range when it's available.\n+\t(add_bytes): Correct the computation of boundrange used to\n+\tdecide whether a warning is of a \"maybe\" or \"defnitely\" kind.\n+\n 2016-12-12  Dominik Vogt  <vogt@linux.vnet.ibm.com>\n \n \t* combine.c (change_zero_ext): Handle mode expanding zero_extracts."}, {"sha": "fa0935754a12e07e17b53208d65c63ad482f3302", "filename": "gcc/gimple-ssa-sprintf.c", "status": "modified", "additions": 175, "deletions": 95, "changes": 270, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/573aa7d4b7c1249c16c12c8483ab8b9830848b82/gcc%2Fgimple-ssa-sprintf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/573aa7d4b7c1249c16c12c8483ab8b9830848b82/gcc%2Fgimple-ssa-sprintf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-sprintf.c?ref=573aa7d4b7c1249c16c12c8483ab8b9830848b82", "patch": "@@ -637,7 +637,7 @@ min_bytes_remaining (unsigned HOST_WIDE_INT navail, const format_result &res)\n   if (HOST_WIDE_INT_MAX <= navail)\n     return navail;\n \n-  if (1 < warn_format_length || res.bounded)\n+  if (1 < warn_format_length || res.knownrange)\n     {\n       /* At level 2, or when all directives output an exact number\n \t of bytes or when their arguments were bounded by known\n@@ -801,7 +801,7 @@ get_width_and_precision (const conversion_spec &spec,\n \t{\n \t  prec = tree_to_shwi (spec.star_precision);\n \t  if (prec < 0)\n-\t    prec = 0;\n+\t    prec = -1;\n \t}\n       else\n \tprec = HOST_WIDE_INT_MIN;\n@@ -811,6 +811,69 @@ get_width_and_precision (const conversion_spec &spec,\n   *pprec = prec;\n }\n \n+/* With the range [*ARGMIN, *ARGMAX] of an integer directive's actual\n+   argument, due to the conversion from either *ARGMIN or *ARGMAX to\n+   the type of the directive's formal argument it's possible for both\n+   to result in the same number of bytes or a range of bytes that's\n+   less than the number of bytes that would result from formatting\n+   some other value in the range [*ARGMIN, *ARGMAX].  This can be\n+   determined by checking for the actual argument being in the range\n+   of the type of the directive.  If it isn't it must be assumed to\n+   take on the full range of the directive's type.\n+   Return true when the range has been adjusted to the full unsigned\n+   range of DIRTYPE, or [0, DIRTYPE_MAX], and false otherwise.  */\n+\n+static bool\n+adjust_range_for_overflow (tree dirtype, tree *argmin, tree *argmax)\n+{\n+  tree argtype = TREE_TYPE (*argmin);\n+  unsigned argprec = TYPE_PRECISION (argtype);\n+  unsigned dirprec = TYPE_PRECISION (dirtype);\n+\n+  /* If the actual argument and the directive's argument have the same\n+     precision and sign there can be no overflow and so there is nothing\n+     to adjust.  */\n+  if (argprec == dirprec && TYPE_SIGN (argtype) == TYPE_SIGN (dirtype))\n+    return false;\n+\n+  /* The logic below was inspired/lifted from the CONVERT_EXPR_CODE_P\n+     branch in the extract_range_from_unary_expr function in tree-vrp.c.  */\n+\n+  if (TREE_CODE (*argmin) == INTEGER_CST\n+      && TREE_CODE (*argmax) == INTEGER_CST\n+      && (dirprec >= argprec\n+\t  || integer_zerop (int_const_binop (RSHIFT_EXPR,\n+\t\t\t\t\t     int_const_binop (MINUS_EXPR,\n+\t\t\t\t\t\t\t      *argmax,\n+\t\t\t\t\t\t\t      *argmin),\n+\t\t\t\t\t     size_int (dirprec)))))\n+    {\n+      *argmin = force_fit_type (dirtype, wi::to_widest (*argmin), 0, false);\n+      *argmax = force_fit_type (dirtype, wi::to_widest (*argmax), 0, false);\n+\n+      /* If *ARGMIN is still less than *ARGMAX the conversion above\n+\t is safe.  Otherwise, it has overflowed and would be unsafe.  */\n+      if (tree_int_cst_le (*argmin, *argmax))\n+\treturn false;\n+    }\n+\n+  tree dirmin = TYPE_MIN_VALUE (dirtype);\n+  tree dirmax = TYPE_MAX_VALUE (dirtype);\n+\n+  if (TYPE_UNSIGNED (dirtype))\n+    {\n+      *argmin = dirmin;\n+      *argmax = dirmax;\n+    }\n+  else\n+    {\n+      *argmin = integer_zero_node;\n+      *argmax = dirmin;\n+    }\n+\n+  return true;\n+}\n+\n /* Return a range representing the minimum and maximum number of bytes\n    that the conversion specification SPEC will write on output for the\n    integer argument ARG when non-null.  ARG may be null (for vararg\n@@ -902,27 +965,24 @@ format_integer (const conversion_spec &spec, tree arg)\n       int base;\n \n       /* True when a signed conversion is preceded by a sign or space.  */\n-      bool maybesign;\n+      bool maybesign = false;\n \n       switch (spec.specifier)\n \t{\n \tcase 'd':\n \tcase 'i':\n-\t  /* Space is only effective for signed conversions.  */\n-\t  maybesign = spec.get_flag (' ');\n+\t  /* Space and '+' are  only meaningful for signed conversions.  */\n+\t  maybesign = spec.get_flag (' ') | spec.get_flag ('+');\n \t  base = 10;\n \t  break;\n \tcase 'u':\n-\t  maybesign = spec.force_flags ? spec.get_flag (' ') : false;\n \t  base = 10;\n \t  break;\n \tcase 'o':\n-\t  maybesign = spec.force_flags ? spec.get_flag (' ') : false;\n \t  base = 8;\n \t  break;\n \tcase 'X':\n \tcase 'x':\n-\t  maybesign = spec.force_flags ? spec.get_flag (' ') : false;\n \t  base = 16;\n \t  break;\n \tdefault:\n@@ -933,20 +993,20 @@ format_integer (const conversion_spec &spec, tree arg)\n \n       if ((prec == HOST_WIDE_INT_MIN || prec == 0) && integer_zerop (arg))\n \t{\n-\t  /* As a special case, a precision of zero with an argument\n-\t     of zero results in zero bytes regardless of flags (with\n-\t     width having the normal effect).  This must extend to\n-\t     the case of a specified precision with an unknown value\n-\t     because it can be zero.  */\n-\t  len = 0;\n+\t  /* As a special case, a precision of zero with a zero argument\n+\t     results in zero bytes except in base 8 when the '#' flag is\n+\t     specified, and for signed conversions in base 8 and 10 when\n+\t     flags when either the space or '+' flag has been specified\n+\t     when it results in just one byte (with width having the normal\n+\t     effect).  This must extend to the case of a specified precision\n+\t     with an unknown value because it can be zero.  */\n+\t  len = ((base == 8 && spec.get_flag ('#')) || maybesign);\n \t}\n       else\n \t{\n \t  /* Convert the argument to the type of the directive.  */\n \t  arg = fold_convert (dirtype, arg);\n \n-\t  maybesign |= spec.get_flag ('+');\n-\n \t  /* True when a conversion is preceded by a prefix indicating the base\n \t     of the argument (octal or hexadecimal).  */\n \t  bool maybebase = spec.get_flag ('#');\n@@ -994,6 +1054,10 @@ format_integer (const conversion_spec &spec, tree arg)\n \n   fmtresult res;\n \n+  /* The result is bounded unless width or precision has been specified\n+     whose value is unknown.  */\n+  res.bounded = width != HOST_WIDE_INT_MIN && prec != HOST_WIDE_INT_MIN;\n+\n   /* Using either the range the non-constant argument is in, or its\n      type (either \"formal\" or actual), create a range of values that\n      constrain the length of output given the warning level.  */\n@@ -1010,38 +1074,19 @@ format_integer (const conversion_spec &spec, tree arg)\n       enum value_range_type range_type = get_range_info (arg, &min, &max);\n       if (range_type == VR_RANGE)\n \t{\n-\t  res.argmin = build_int_cst (argtype, wi::fits_uhwi_p (min)\n-\t\t\t\t      ? min.to_uhwi () : min.to_shwi ());\n-\t  res.argmax = build_int_cst (argtype, wi::fits_uhwi_p (max)\n-\t\t\t\t      ? max.to_uhwi () : max.to_shwi ());\n-\n-\t  /* For a range with a negative lower bound and a non-negative\n-\t     upper bound, use one to determine the minimum number of bytes\n-\t     on output and whichever of the two bounds that results in\n-\t     the greater number of bytes on output for the upper bound.\n-\t     For example, for ARG in the range of [-3, 123], use 123 as\n-\t     the upper bound for %i but -3 for %u.  */\n-\t  if (wi::neg_p (min) && !wi::neg_p (max))\n-\t    {\n-\t      argmin = res.argmin;\n-\t      argmax = res.argmax;\n-\t      int minbytes = format_integer (spec, res.argmin).range.min;\n-\t      int maxbytes = format_integer (spec, res.argmax).range.max;\n-\t      if (maxbytes < minbytes)\n-\t\targmax = res.argmin;\n-\n-\t      argmin = integer_zero_node;\n-\t    }\n-\t  else\n-\t    {\n-\t      argmin = res.argmin;\n-\t      argmax = res.argmax;\n-\t    }\n-\n-\t  /* The argument is bounded by the known range of values\n-\t     determined by Value Range Propagation.  */\n-\t  res.bounded = true;\n-\t  res.knownrange = true;\n+\t  argmin = build_int_cst (argtype, wi::fits_uhwi_p (min)\n+\t\t\t\t  ? min.to_uhwi () : min.to_shwi ());\n+\t  argmax = build_int_cst (argtype, wi::fits_uhwi_p (max)\n+\t\t\t\t  ? max.to_uhwi () : max.to_shwi ());\n+\n+\t  /* Set KNOWNRANGE if the argument is in a known subrange\n+\t     of the directive's type (KNOWNRANGE may be reset below).  */\n+\t  res.knownrange\n+\t    = (!tree_int_cst_equal (TYPE_MIN_VALUE (dirtype), argmin)\n+\t       || !tree_int_cst_equal (TYPE_MAX_VALUE (dirtype), argmax));\n+\n+\t  res.argmin = argmin;\n+\t  res.argmax = argmax;\n \t}\n       else if (range_type == VR_ANTI_RANGE)\n \t{\n@@ -1083,7 +1128,7 @@ format_integer (const conversion_spec &spec, tree arg)\n \t can output.  When precision is specified but unknown, use zero\n \t as the minimum since it results in no bytes on output (unless\n \t width is specified to be greater than 0).  */\n-      argmin = build_int_cst (argtype, prec != HOST_WIDE_INT_MIN);\n+      argmin = build_int_cst (argtype, prec && prec != HOST_WIDE_INT_MIN);\n \n       int typeprec = TYPE_PRECISION (dirtype);\n       int argprec = TYPE_PRECISION (argtype);\n@@ -1111,11 +1156,46 @@ format_integer (const conversion_spec &spec, tree arg)\n       res.argmax = argmax;\n     }\n \n+  if (tree_int_cst_lt (argmax, argmin))\n+    {\n+      tree tmp = argmax;\n+      argmax = argmin;\n+      argmin = tmp;\n+    }\n+\n+  /* Clear KNOWNRANGE if the range has been adjusted to the maximum\n+     of the directive.  If it has been cleared then since ARGMIN and/or\n+     ARGMAX have been adjusted also adjust the corresponding ARGMIN and\n+     ARGMAX in the result to include in diagnostics.  */\n+  if (adjust_range_for_overflow (dirtype, &argmin, &argmax))\n+    {\n+      res.knownrange = false;\n+      res.argmin = argmin;\n+      res.argmax = argmax;\n+    }\n+\n   /* Recursively compute the minimum and maximum from the known range,\n      taking care to swap them if the lower bound results in longer\n      output than the upper bound (e.g., in the range [-1, 0].  */\n-  res.range.min = format_integer (spec, argmin).range.min;\n-  res.range.max = format_integer (spec, argmax).range.max;\n+\n+  if (TYPE_UNSIGNED (dirtype))\n+    {\n+      /* For unsigned conversions/directives, use the minimum (i.e., 0\n+\t or 1) and maximum to compute the shortest and longest output,\n+\t respectively.  */\n+      res.range.min = format_integer (spec, argmin).range.min;\n+      res.range.max = format_integer (spec, argmax).range.max;\n+    }\n+  else\n+    {\n+      /* For signed conversions/directives, use the maximum (i.e., 0)\n+\t to compute the shortest output and the minimum (i.e., TYPE_MIN)\n+\t to compute the longest output.  This is important when precision\n+\t is specified but unknown because otherwise both output lengths\n+\t would reflect the largest possible precision (i.e., INT_MAX).  */\n+      res.range.min = format_integer (spec, argmax).range.min;\n+      res.range.max = format_integer (spec, argmin).range.max;\n+    }\n \n   /* The result is bounded either when the argument is determined to be\n      (e.g., when it's within some range) or when the minimum and maximum\n@@ -1786,13 +1866,13 @@ format_directive (const pass_sprintf_length::call_info &info,\n      NUL that's appended after the format string has been processed.  */\n   unsigned HOST_WIDE_INT navail = min_bytes_remaining (info.objsize, *res);\n \n+  bool warned = res->warned;\n+\n   if (fmtres.range.min < fmtres.range.max)\n     {\n       /* The result is a range (i.e., it's inexact).  */\n-      if (!res->warned)\n+      if (!warned)\n \t{\n-\t  bool warned = false;\n-\n \t  if (navail < fmtres.range.min)\n \t    {\n \t      /* The minimum directive output is longer than there is\n@@ -1877,21 +1957,6 @@ format_directive (const pass_sprintf_length::call_info &info,\n \t\t\t\t    navail);\n \t\t}\n \t    }\n-\n-\t  res->warned |= warned;\n-\n-\t  if (warned && fmtres.argmin)\n-\t    {\n-\t      if (fmtres.argmin == fmtres.argmax)\n-\t\tinform (info.fmtloc, \"directive argument %qE\", fmtres.argmin);\n-\t      else if (fmtres.bounded)\n-\t\tinform (info.fmtloc, \"directive argument in the range [%E, %E]\",\n-\t\t\tfmtres.argmin, fmtres.argmax);\n-\t      else\n-\t\tinform (info.fmtloc,\n-\t\t\t\"using the range [%qE, %qE] for directive argument\",\n-\t\t\tfmtres.argmin, fmtres.argmax);\n-\t    }\n \t}\n \n       /* Disable exact length checking but adjust the minimum and maximum.  */\n@@ -1904,7 +1969,7 @@ format_directive (const pass_sprintf_length::call_info &info,\n     }\n   else\n     {\n-      if (!res->warned && fmtres.range.min > 0 && navail < fmtres.range.min)\n+      if (!warned && fmtres.range.min > 0 && navail < fmtres.range.min)\n \t{\n \t  const char* fmtstr\n \t    = (info.bounded\n@@ -1919,10 +1984,10 @@ format_directive (const pass_sprintf_length::call_info &info,\n \t\t  : G_(\"%<%.*s%> directive writing %wu byte \"\n \t\t       \"into a region of size %wu\")));\n \n-\t  res->warned = fmtwarn (dirloc, pargrange, NULL,\n-\t\t\t\t OPT_Wformat_length_, fmtstr,\n-\t\t\t\t (int)cvtlen, cvtbeg, fmtres.range.min,\n-\t\t\t\t navail);\n+\t  warned = fmtwarn (dirloc, pargrange, NULL,\n+\t\t\t    OPT_Wformat_length_, fmtstr,\n+\t\t\t    (int)cvtlen, cvtbeg, fmtres.range.min,\n+\t\t\t    navail);\n \t}\n       *res += fmtres.range.min;\n     }\n@@ -1933,7 +1998,7 @@ format_directive (const pass_sprintf_length::call_info &info,\n   if (!minunder4k || fmtres.range.max > 4095)\n     res->under4k = false;\n \n-  if (!res->warned && 1 < warn_format_length\n+  if (!warned && 1 < warn_format_length\n       && (!minunder4k || fmtres.range.max > 4095))\n     {\n       /* The directive output may be longer than the maximum required\n@@ -1944,11 +2009,11 @@ format_directive (const pass_sprintf_length::call_info &info,\n \t (like Glibc does under some conditions).  */\n \n       if (fmtres.range.min == fmtres.range.max)\n-\tres->warned = fmtwarn (dirloc, pargrange, NULL,\n-\t\t\t       OPT_Wformat_length_,\n-\t\t\t       \"%<%.*s%> directive output of %wu bytes exceeds \"\n-\t\t\t       \"minimum required size of 4095\",\n-\t\t\t       (int)cvtlen, cvtbeg, fmtres.range.min);\n+\twarned = fmtwarn (dirloc, pargrange, NULL,\n+\t\t\t  OPT_Wformat_length_,\n+\t\t\t  \"%<%.*s%> directive output of %wu bytes exceeds \"\n+\t\t\t  \"minimum required size of 4095\",\n+\t\t\t  (int)cvtlen, cvtbeg, fmtres.range.min);\n       else\n \t{\n \t  const char *fmtstr\n@@ -1958,17 +2023,17 @@ format_directive (const pass_sprintf_length::call_info &info,\n \t       : G_(\"%<%.*s%> directive output between %qu and %wu \"\n \t\t    \"bytes exceeds minimum required size of 4095\"));\n \n-\t  res->warned = fmtwarn (dirloc, pargrange, NULL,\n-\t\t\t\t OPT_Wformat_length_, fmtstr,\n-\t\t\t\t (int)cvtlen, cvtbeg,\n-\t\t\t\t fmtres.range.min, fmtres.range.max);\n+\t  warned = fmtwarn (dirloc, pargrange, NULL,\n+\t\t\t    OPT_Wformat_length_, fmtstr,\n+\t\t\t    (int)cvtlen, cvtbeg,\n+\t\t\t    fmtres.range.min, fmtres.range.max);\n \t}\n     }\n \n   /* Has the minimum directive output length exceeded INT_MAX?  */\n   bool exceedmin = res->number_chars_min > target_int_max ();\n \n-  if (!res->warned\n+  if (!warned\n       && (exceedmin\n \t  || (1 < warn_format_length\n \t      && res->number_chars_max > target_int_max ())))\n@@ -1977,11 +2042,11 @@ format_directive (const pass_sprintf_length::call_info &info,\n \t to exceed INT_MAX bytes.  */\n \n       if (fmtres.range.min == fmtres.range.max)\n-\tres->warned = fmtwarn (dirloc, pargrange, NULL,\n-\t\t\t       OPT_Wformat_length_,\n-\t\t\t       \"%<%.*s%> directive output of %wu bytes causes \"\n-\t\t\t       \"result to exceed %<INT_MAX%>\",\n-\t\t\t       (int)cvtlen, cvtbeg, fmtres.range.min);\n+\twarned = fmtwarn (dirloc, pargrange, NULL,\n+\t\t\t  OPT_Wformat_length_,\n+\t\t\t  \"%<%.*s%> directive output of %wu bytes causes \"\n+\t\t\t  \"result to exceed %<INT_MAX%>\",\n+\t\t\t  (int)cvtlen, cvtbeg, fmtres.range.min);\n       else\n \t{\n \t  const char *fmtstr\n@@ -1990,12 +2055,27 @@ format_directive (const pass_sprintf_length::call_info &info,\n \t\t     \"bytes causes result to exceed %<INT_MAX%>\")\n \t       : G_ (\"%<%.*s%> directive output between %wu and %wu \"\n \t\t     \"bytes may cause result to exceed %<INT_MAX%>\"));\n-\t  res->warned = fmtwarn (dirloc, pargrange, NULL,\n-\t\t\t\t OPT_Wformat_length_, fmtstr,\n-\t\t\t\t (int)cvtlen, cvtbeg,\n-\t\t\t\t fmtres.range.min, fmtres.range.max);\n+\t  warned = fmtwarn (dirloc, pargrange, NULL,\n+\t\t\t    OPT_Wformat_length_, fmtstr,\n+\t\t\t    (int)cvtlen, cvtbeg,\n+\t\t\t    fmtres.range.min, fmtres.range.max);\n \t}\n     }\n+\n+  if (warned && fmtres.argmin)\n+    {\n+      if (fmtres.argmin == fmtres.argmax)\n+\tinform (info.fmtloc, \"directive argument %qE\", fmtres.argmin);\n+      else if (fmtres.knownrange)\n+\tinform (info.fmtloc, \"directive argument in the range [%E, %E]\",\n+\t\tfmtres.argmin, fmtres.argmax);\n+      else\n+\tinform (info.fmtloc,\n+\t\t\"using the range [%E, %E] for directive argument\",\n+\t\tfmtres.argmin, fmtres.argmax);\n+    }\n+\n+  res->warned |= warned;\n }\n \n /* Account for the number of bytes between BEG and END (or between\n@@ -2067,7 +2147,7 @@ add_bytes (const pass_sprintf_length::call_info &info,\n \t indicate that the overflow/truncation may (but need not) happen.  */\n       bool boundrange\n \t= (res->number_chars_min < res->number_chars_max\n-\t   && res->number_chars_min < info.objsize);\n+\t   && res->number_chars_min + nbytes <= info.objsize);\n \n       if (!end && ((nbytes - navail) == 1 || boundrange))\n \t{"}, {"sha": "71a6e2a53dda7d0fafdec2c78a553f81fa21bbe7", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/573aa7d4b7c1249c16c12c8483ab8b9830848b82/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/573aa7d4b7c1249c16c12c8483ab8b9830848b82/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=573aa7d4b7c1249c16c12c8483ab8b9830848b82", "patch": "@@ -1,3 +1,23 @@\n+2016-12-12  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR middle-end/78622\n+\tPR middle-end78606\n+\t* gcc.c-torture/execute/pr78622.c: New test.\n+\t* gcc.dg/tree-ssa/builtin-sprintf-2.c: Remove \"benign\" undefined\n+\tbehavior inadvertently introduced in a previous commit.  Tighten\n+\tup final checking.\n+\t* gcc.dg/tree-ssa/builtin-sprintf-5.c: Rename macros for clarity.\n+\tAdd test cases.\n+\t* gcc.dg/tree-ssa/builtin-sprintf-6.c: Add test cases.\n+\t* gcc.dg/tree-ssa/builtin-sprintf-warn-1.c: Same.\n+\t* gcc.dg/tree-ssa/builtin-sprintf-warn-2.c: Same.\n+\t* gcc.dg/tree-ssa/builtin-sprintf-warn-3.c: Same.\n+\t* gcc.dg/tree-ssa/builtin-sprintf-warn-5.c: Same.\n+\t* gcc.dg/tree-ssa/builtin-sprintf-warn-6.c: Remove xfails and\n+\tadd a final optimization check.\n+\t* gcc.dg/tree-ssa/builtin-sprintf.c: Add test cases.\n+\t* gcc.dg/tree-ssa/pr78622.c: New test.\n+\n 2016-12-12  Janus Weil  <janus@gcc.gnu.org>\n \n \tPR fortran/78392"}, {"sha": "d835c74c40db7b82dc9c7681849d2d2dd20df2ec", "filename": "gcc/testsuite/gcc.c-torture/execute/pr78622.c", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/573aa7d4b7c1249c16c12c8483ab8b9830848b82/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr78622.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/573aa7d4b7c1249c16c12c8483ab8b9830848b82/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr78622.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr78622.c?ref=573aa7d4b7c1249c16c12c8483ab8b9830848b82", "patch": "@@ -0,0 +1,34 @@\n+/* PR middle-end/78622 - [7 Regression] -Wformat-length/-fprintf-return-value\n+   incorrect with overflow/wrapping\n+   { dg-additional-options \"-Wformat-length=2\" } */\n+\n+__attribute__((noinline, noclone)) int\n+foo (int x)\n+{\n+  if (x < 4096 + 8 || x >= 4096 + 256 + 8)\n+    return -1;\n+\n+  char buf[5];\n+  int n = __builtin_snprintf (buf, sizeof buf, \"%hhd\", x + 1);\n+  __builtin_printf (\"\\\"%hhd\\\" => %i\\n\", x + 1, n);\n+  return n;\n+}\n+\n+int\n+main (void)\n+{\n+  if (__SCHAR_MAX__ != 127 || __CHAR_BIT__ != 8 || __SIZEOF_INT__ != 4)\n+    return 0;\n+\n+  if (foo (4095 + 9) != 1\n+      || foo (4095 + 32) != 2\n+      || foo (4095 + 127) != 3\n+      || foo (4095 + 128) != 4\n+      || foo (4095 + 240) != 3\n+      || foo (4095 + 248) != 2\n+      || foo (4095 + 255) != 2\n+      || foo (4095 + 256) != 1)\n+    __builtin_abort ();\n+\n+  return 0;\n+}"}, {"sha": "260f4fc2046159446d39ab7ae5e7622f705638ef", "filename": "gcc/testsuite/gcc.dg/tree-ssa/builtin-sprintf-2.c", "status": "modified", "additions": 18, "deletions": 10, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/573aa7d4b7c1249c16c12c8483ab8b9830848b82/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/573aa7d4b7c1249c16c12c8483ab8b9830848b82/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-2.c?ref=573aa7d4b7c1249c16c12c8483ab8b9830848b82", "patch": "@@ -25,6 +25,9 @@ char buf8k [8192];\n #define concat(a, b)   a ## b\n #define CAT(a, b)      concat (a, b)\n \n+/* Calls to this function must not be eliminated.  */\n+void must_not_eliminate (void);\n+\n #define EQL(expect, size, fmt, ...)\t\t\t\t\t\\\n   void __attribute__ ((noinline, noclone))\t\t\t\t\\\n   CAT (test_on_line_, __LINE__)(void)\t\t\t\t\t\\\n@@ -34,7 +37,7 @@ char buf8k [8192];\n \tchar *dst = size < 0 ? buf : buf8k + sizeof buf8k - size;\t\\\n \tint result = __builtin_sprintf (dst, fmt, __VA_ARGS__);\t\t\\\n \tif (result != expect)\t\t\t\t\t\t\\\n-\t  __builtin_abort ();\t\t\t\t\t\t\\\n+\t  must_not_eliminate ();\t\t\t\t\t\\\n       }\t\t\t\t\t\t\t\t\t\\\n   }\n \n@@ -50,7 +53,7 @@ char buf8k [8192];\n \tchar *dst = size < 0 ? buf : buf8k + sizeof buf8k - size;\t\\\n \tint result = __builtin_sprintf (dst, fmt, __VA_ARGS__);\t\t\\\n \tif (result < min || max < result)\t\t\t\t\\\n-\t  __builtin_abort ();\t\t\t\t\t\t\\\n+\t  must_not_eliminate ();\t\t\t\t\t\\\n       }\t\t\t\t\t\t\t\t\t\\\n   }\n \n@@ -75,6 +78,8 @@ EQL (0, 0, \"%-s\", \"\");\n EQL (1, 1, \"%c\",  'x');\n EQL (1, 1, \"%-s\", \"x\");\n \n+EQL (1, 2, \"%c\",  'x');\n+\n EQL (4, 4, \"%4c\", 'x');\n \n /* Verify that exceeding the environmental limit of 4095 bytes for\n@@ -179,7 +184,7 @@ RNG (4,  4, 32, \"%zu\", sz)\n \n /* Exercise bug 78586.  */\n RNG (4,  4, 32, \"%lu\", (unsigned long)i)\n-RNG (4,  4, 32, \"%lu\", (unsigned)u)\n+RNG (4,  4, 32, \"%lu\", (unsigned long)u)\n RNG (4,  4, 32, \"%lu\", (unsigned long)li)\n RNG (4,  4, 32, \"%lu\", (unsigned long)lu)\n RNG (4,  4, 32, \"%lu\", (unsigned long)sz)\n@@ -259,21 +264,24 @@ RNG (0,  6,   8, \"%s%ls\", \"1\", L\"2\");\n /* Verify that no call to abort has been eliminated and that each call\n    is at the beginning of a basic block (and thus the result of a branch).\n    This latter test tries to verify that the test preceding the call to\n-   abort has not been eliminated either.\n+   the must_not_eliminate() function has not been eliminated either.\n \n    The expected output looks something like this:\n \n    <bb 2>:\n    result_3 = __builtin_sprintf (&MEM[(void *)&buf8k + 8192B], \"%c\", 32);\n    if (result_3 != 0)\n-     goto <bb 3>;\n+     goto <bb 3>; [50.0%]\n    else\n-     goto <bb 4>;\n+     goto <bb 4>; [50.0%]\n \n-   <bb 3>:\n-   __builtin_abort ();\n+   <bb 3>[50.0%]:\n+   must_not_eliminate ();\n \n */\n \n-/* { dg-final { scan-tree-dump-times \"> \\\\\\[\\[0-9.\\]+%\\\\\\]:\\n *__builtin_abort\" 124 \"optimized\" { target { ilp32 || lp64 } } } } */\n-/* { dg-final { scan-tree-dump-times \"> \\\\\\[\\[0-9.\\]+%\\\\\\]:\\n *__builtin_abort\" 93 \"optimized\" { target { { ! ilp32 } && { ! lp64 } } } } } */\n+/*  Only conditional calls to abort should be made (with any probability):\n+    { dg-final { scan-tree-dump-times \"> \\\\\\[\\[0-9.\\]+%\\\\\\]:\\n *must_not_eliminate\" 124 \"optimized\" { target { ilp32 || lp64 } } } }\n+    { dg-final { scan-tree-dump-times \"> \\\\\\[\\[0-9.\\]+%\\\\\\]:\\n *must_not_eliminate\" 93 \"optimized\" { target { { ! ilp32 } && { ! lp64 } } } } }\n+    No unconditional calls to abort should be made:\n+    { dg-final { scan-tree-dump-not \";\\n *must_not_eliminate\" \"optimized\" } } */"}, {"sha": "c4489acb360d7e184f19921365a7f6e336a34ad2", "filename": "gcc/testsuite/gcc.dg/tree-ssa/builtin-sprintf-5.c", "status": "modified", "additions": 103, "deletions": 71, "changes": 174, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/573aa7d4b7c1249c16c12c8483ab8b9830848b82/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/573aa7d4b7c1249c16c12c8483ab8b9830848b82/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-5.c?ref=573aa7d4b7c1249c16c12c8483ab8b9830848b82", "patch": "@@ -8,129 +8,161 @@\n #define FAIL(line)  CAT (failure_on_line_, line)\n #define PASS(line)  CAT (success_on_line_, line)\n \n-/* Emit a call to a function named failure_on_line_NNN when EXPR is false.  */\n-#define ASSERT(value, expect)\t\t\t\\\n+/* Emit a call to a function named failure_on_line_NNN when VALUE\n+   is not equal to the constant EXPECTED, otherwise emit a call to\n+   function success_on_line_NNN.  */\n+#define ASSERT(value, expected)\t\t\t\\\n   do {\t\t\t\t\t\t\\\n     extern void FAIL (__LINE__)(int);\t\t\\\n     extern void PASS (__LINE__)(int);\t\t\\\n-    if (value == expect)\t\t\t\\\n+    if (value == expected)\t\t\t\\\n       PASS (__LINE__)(value);\t\t\t\\\n     else\t\t\t\t\t\\\n       FAIL (__LINE__)(value);\t\t\t\\\n   } while (0)\n \n-#define T(expect, ...)\t\t\t\t\t\\\n+#define EQL(expect, ...)\t\t\t\t\\\n   do {\t\t\t\t\t\t\t\\\n     int n = __builtin_snprintf (0, 0, __VA_ARGS__);\t\\\n     ASSERT (n, expect);\t\t\t\t\t\\\n   } while (0)\n \n int ival (int i) { return i; }\n \n+/* Generate a signed int value in the specified range.  */\n+\n+static int\n+int_range (int min, int max)\n+{\n+  extern int int_value (void);\n+  int val = int_value ();\n+  if (val < min || max < val)\n+    val = min;\n+  return val;\n+}\n+\n+#define R(min, max) int_range (min, max)\n+\n void test_arg_int (int i, int n)\n {\n-  T (1, \"%i\", ival (0));\n-  T (1, \"%i\", ival (1));\n-  T (2, \"%i%i\", ival (0), ival (1));\n-  T (3, \"%i%i%i\", ival (0), ival (1), ival (9));\n-  T (5, \"%i %i %i\", ival (0), ival (1), ival (9));\n+  EQL (1, \"%i\", ival (0));\n+  EQL (1, \"%i\", ival (1));\n+  EQL (2, \"%i%i\", ival (0), ival (1));\n+  EQL (3, \"%i%i%i\", ival (0), ival (1), ival (9));\n+  EQL (5, \"%i %i %i\", ival (0), ival (1), ival (9));\n \n-  T (5, \"%i %i %i\", ival (0), ival (1), ival (9));\n+  EQL (5, \"%i %i %i\", ival (0), ival (1), ival (9));\n \n-  T (13, \"%hhu.%hhu.%hhu.%hhu\", ival (23), ival (78), ival (216), ival (135));\n+  EQL (13, \"%hhu.%hhu.%hhu.%hhu\", ival (23), ival (78), ival (216), ival (135));\n \n   for (i = 0; i != 9; ++i)\n-    T (1, \"%i\", i);\n+    EQL (1, \"%i\", i);\n \n   for (i = -n; i != n; ++i)\n-    T (8, \"%08x\", i);\n+    EQL (8, \"%08x\", i);\n \n   /*  As a special case, a precision of zero with an argument of zero\n       results in zero bytes (unless modified by width).  */\n-  T (0, \"%.0d\", ival (0));\n-  T (0, \"%.0i\", ival (0));\n-  T (0, \"%.0o\", ival (0));\n-  T (0, \"%.0u\", ival (0));\n-  T (0, \"%.0x\", ival (0));\n-\n-  T (0, \"%.*d\", 0, ival (0));\n-  T (0, \"%.*i\", 0, ival (0));\n-  T (0, \"%.*o\", 0, ival (0));\n-  T (0, \"%.*u\", 0, ival (0));\n-  T (0, \"%.*x\", 0, ival (0));\n-\n-  T (1, \"%1.0d\", ival (0));\n-  T (1, \"%1.0i\", ival (0));\n-  T (1, \"%1.0o\", ival (0));\n-  T (1, \"%1.0u\", ival (0));\n-  T (1, \"%1.0x\", ival (0));\n+  EQL (0, \"%.0d\", ival (0));\n+  EQL (0, \"%.0i\", ival (0));\n+  EQL (0, \"%.0o\", ival (0));\n+  EQL (0, \"%.0u\", ival (0));\n+  EQL (0, \"%.0x\", ival (0));\n+\n+  EQL (0, \"%.*d\", 0, ival (0));\n+  EQL (0, \"%.*i\", 0, ival (0));\n+  EQL (0, \"%.*o\", 0, ival (0));\n+  EQL (0, \"%.*u\", 0, ival (0));\n+  EQL (0, \"%.*x\", 0, ival (0));\n+\n+  EQL (1, \"%1.0d\", ival (0));\n+  EQL (1, \"%1.0i\", ival (0));\n+  EQL (1, \"%1.0o\", ival (0));\n+  EQL (1, \"%1.0u\", ival (0));\n+  EQL (1, \"%1.0x\", ival (0));\n+\n+  EQL (4, \"%hhi\", R (-128, -127));\n+  EQL (3, \"%hhi\", R ( -99,  -10));\n+  EQL (2, \"%hhi\", R (  -9,   -1));\n+  EQL (1, \"%hhi\", R (   0,    9));\n+  EQL (1, \"%hhi\", R (   0,    9));\n+\n+  EQL (1, \"%1.0hhi\", R (   0,    1));\n+  EQL (1, \"%1.1hhi\", R (   0,    9));\n+  EQL (2, \"%1.2hhi\", R (   0,    9));\n+  EQL (3, \"%1.3hhi\", R (   0,    9));\n+\n+  EQL (1, \"%hhi\", R (1024, 1033));\n+  EQL (2, \"%hhi\", R (1034, 1123));\n+  EQL (1, \"%hhu\", R (1024, 1033));\n+  EQL (2, \"%hhu\", R (1034, 1123));\n }\n \n void test_arg_string (const char *s)\n {\n-  T ( 0, \"%-s\", \"\");\n-  T ( 1, \"%%\");\n-  T ( 1, \"%-s\", \"1\");\n-  T ( 2, \"%-s\", \"12\");\n-  T ( 3, \"%-s\", \"123\");\n-  T ( 5, \"s=%s\", \"123\");\n-  T (10, \"%%s=\\\"%s\\\"\", \"12345\");\n-\n-  T ( 1, \"%.*s\", 1, \"123\");\n-  T ( 2, \"%.*s\", 2, \"123\");\n-  T ( 3, \"%.*s\", 3, \"123\");\n-  T ( 3, \"%.*s\", 4, \"123\");\n-\n-  T ( 1, \"%1.*s\", 1, \"123\");\n-  T ( 2, \"%1.*s\", 2, \"123\");\n-  T ( 3, \"%1.*s\", 3, \"123\");\n-  T ( 3, \"%1.*s\", 4, \"123\");\n-  T ( 4, \"%4.*s\", 1, \"123\");\n-  T ( 4, \"%4.*s\", 2, \"123\");\n-  T ( 4, \"%4.*s\", 3, \"123\");\n-  T ( 4, \"%4.*s\", 4, \"123\");\n-  T ( 4, \"%4.*s\", 5, \"123\");\n+  EQL ( 0, \"%-s\", \"\");\n+  EQL ( 1, \"%%\");\n+  EQL ( 1, \"%-s\", \"1\");\n+  EQL ( 2, \"%-s\", \"12\");\n+  EQL ( 3, \"%-s\", \"123\");\n+  EQL ( 5, \"s=%s\", \"123\");\n+  EQL (10, \"%%s=\\\"%s\\\"\", \"12345\");\n+\n+  EQL ( 1, \"%.*s\", 1, \"123\");\n+  EQL ( 2, \"%.*s\", 2, \"123\");\n+  EQL ( 3, \"%.*s\", 3, \"123\");\n+  EQL ( 3, \"%.*s\", 4, \"123\");\n+\n+  EQL ( 1, \"%1.*s\", 1, \"123\");\n+  EQL ( 2, \"%1.*s\", 2, \"123\");\n+  EQL ( 3, \"%1.*s\", 3, \"123\");\n+  EQL ( 3, \"%1.*s\", 4, \"123\");\n+  EQL ( 4, \"%4.*s\", 1, \"123\");\n+  EQL ( 4, \"%4.*s\", 2, \"123\");\n+  EQL ( 4, \"%4.*s\", 3, \"123\");\n+  EQL ( 4, \"%4.*s\", 4, \"123\");\n+  EQL ( 4, \"%4.*s\", 5, \"123\");\n \n   const char *a = \"123\";\n   const char *b = \"456\";\n \n-  T ( 3, \"%-s\", s ? a : b);\n-  T ( 0, \"%.0s\", s);\n-  T ( 1, \"%1.1s\", s);\n-  T ( 2, \"%2.2s\", s);\n-  T ( 2, \"%2.1s\", s);\n+  EQL ( 3, \"%-s\", s ? a : b);\n+  EQL ( 0, \"%.0s\", s);\n+  EQL ( 1, \"%1.1s\", s);\n+  EQL ( 2, \"%2.2s\", s);\n+  EQL ( 2, \"%2.1s\", s);\n }\n \n void test_arg_multiarg (int i, double d)\n {\n-  T (16, \"%i %f %s\", 123, 3.14, \"abc\");\n-  T (16, \"%12i %s\", i, \"abc\");\n-  T (16, \"%*i %s\", 12, i, \"abc\");\n+  EQL (16, \"%i %f %s\", 123, 3.14, \"abc\");\n+  EQL (16, \"%12i %s\", i, \"abc\");\n+  EQL (16, \"%*i %s\", 12, i, \"abc\");\n }\n \n-#define TV(expect, fmt, va)\t\t\t\t\\\n+#define EQLv(expect, fmt, va)\t\t\t\t\\\n   do {\t\t\t\t\t\t\t\\\n     int n = __builtin_vsnprintf (0, 0, fmt, va);\t\\\n     ASSERT (n, expect);\t\t\t\t\t\\\n   } while (0)\n \n void test_va_int (__builtin_va_list va)\n {\n-  TV ( 2, \"%02hhx\", va);\n-  TV ( 2, \"%02.*hhx\", va);\n-  TV ( 4, \"%04hx\", va);\n-  TV ( 4, \"%04.*hx\", va);\n+  EQLv ( 2, \"%02hhx\", va);\n+  EQLv ( 2, \"%02.*hhx\", va);\n+  EQLv ( 4, \"%04hx\", va);\n+  EQLv ( 4, \"%04.*hx\", va);\n }\n \n void test_va_multiarg (__builtin_va_list va)\n {\n-  TV ( 8, \"%8x\", va);\n-  TV ( 8, \"% 8x\", va);\n-  TV ( 9, \"%9x\", va);\n-  TV (11, \"%11o\", va);\n-  TV (12, \"%12o\", va);\n+  EQLv ( 8, \"%8x\", va);\n+  EQLv ( 8, \"% 8x\", va);\n+  EQLv ( 9, \"%9x\", va);\n+  EQLv (11, \"%11o\", va);\n+  EQLv (12, \"%12o\", va);\n \n-  TV (16, \"%12i %3.2s\", va);\n+  EQLv (16, \"%12i %3.2s\", va);\n }\n \n "}, {"sha": "abd49dfcc0339ba4993fa1c253a8dc84b18c2b63", "filename": "gcc/testsuite/gcc.dg/tree-ssa/builtin-sprintf-6.c", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/573aa7d4b7c1249c16c12c8483ab8b9830848b82/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/573aa7d4b7c1249c16c12c8483ab8b9830848b82/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-6.c?ref=573aa7d4b7c1249c16c12c8483ab8b9830848b82", "patch": "@@ -8,6 +8,8 @@\n    { dg-options \"-O2 -Wformat -fdump-tree-optimized\" }\n    { dg-require-effective-target int32plus } */\n \n+typedef __SIZE_TYPE__ size_t;\n+\n #define CONCAT(a, b) a ## b\n #define CAT(a, b)    CONCAT (a, b)\n \n@@ -50,6 +52,19 @@ void test_arg_int (int width, int prec, int i, int n)\n \n   T (\"%i\", R (1, 10));\n \n+  /* Each of the bounds of the ranges below results in just one byte\n+     on output because they convert to the value 9 in type char, yet\n+     other values in those ranges can result in up to four bytes.\n+     For example, 4240 converts to -112.  Verify that the output\n+     isn't folded into a constant.  This assumes __CHAR_BIT__ of 8.  */\n+  T (\"%hhi\", R (4104, 4360) + 1);\n+  T (\"%hhu\", R (4104, 4360) + 1);\n+\n+  /* Here, the range includes all possible lengths of output for\n+     a 16-bit short and 32-bit int.  */\n+  T (\"%hi\", R (65536, 65536 * 2));\n+  T (\"%hu\", R (65536, 65536 * 2));\n+\n   T (\"%'i\", 1234567);\n \n   for (i = -n; i != n; ++i)\n@@ -104,6 +119,7 @@ void test_invalid_directive (void)\n   T (\"abc%Q\");    /* { dg-warning \"unknown conversion type character .Q.\" } */\n }\n \n+\n /* Use 'grep \"^ *T (\" builtin-sprintf-6.c  | wc -l' to determine\n    the count for the directive below.\n-   { dg-final { scan-tree-dump-times \"snprintf\" 42 \"optimized\"} } */\n+   { dg-final { scan-tree-dump-times \"snprintf\" 46 \"optimized\"} } */"}, {"sha": "4d08bcd68422b71d5cf71abaadc3364ace4f552a", "filename": "gcc/testsuite/gcc.dg/tree-ssa/builtin-sprintf-warn-1.c", "status": "modified", "additions": 29, "deletions": 18, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/573aa7d4b7c1249c16c12c8483ab8b9830848b82/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-warn-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/573aa7d4b7c1249c16c12c8483ab8b9830848b82/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-warn-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-warn-1.c?ref=573aa7d4b7c1249c16c12c8483ab8b9830848b82", "patch": "@@ -429,19 +429,20 @@ void test_sprintf_chk_hh_const (void)\n   T (4, \"%hhi %hhi\", 11, 12);   /* { dg-warning \"into a region\" } */\n \n   /*  As a special case, a precision of zero with an argument of zero\n-      results in zero bytes (unless modified by width).  */\n+      results in zero bytes (unless modified by flags and/or width).  */\n   T (1, \"%.0hhd\",   0);\n-  T (1, \"%+.0hhd\",  0);\n+  T (1, \"%+.0hhd\",  0);         /* { dg-warning \"nul past the end\" } */\n   T (1, \"%-.0hhd\",  0);\n-  T (1, \"% .0hhd\",  0);\n+  T (1, \"% .0hhd\",  0);         /* { dg-warning \"nul past the end\" } */\n   T (1, \"%0.0hhd\",  0);         /* { dg-warning \".0. flag ignored with precision\" } */\n   T (1, \"%00.0hhd\", 0);         /* { dg-warning \"repeated .0. flag in format\" } */\n   /* { dg-warning \".0. flag ignored with precision\" \"\" { target *-*-* } .-1 } */\n   T (1, \"%-0.0hhd\", 0);         /* { dg-warning \".0. flag ignored with .-. flag\" } */\n   /* { dg-warning \".0. flag ignored with precision\" \"\" { target *-*-* } .-1 } */\n   T (1, \"%.0hhi\",   0);\n   T (1, \"%.0hho\",   0);\n-  T (1, \"%#.0hho\",  0);\n+  /* As a special case, '#' in base 8 results in 1 byte (the zero).  */\n+  T (1, \"%#.0hho\",  0);         /* { dg-warning \"nul past the end\" } */\n   T (1, \"%.0hhx\",   0);\n   T (1, \"%.0hhX\",   0);\n   T (1, \"%#.0hhX\",  0);\n@@ -545,17 +546,17 @@ void test_sprintf_chk_h_const (void)\n   /*  As a special case, a precision of zero with an argument of zero\n       results in zero bytes (unless modified by width).  */\n   T (1, \"%.0hd\",        0);\n-  T (1, \"%+.0hd\",       0);\n+  T (1, \"%+.0hd\",       0);         /* { dg-warning \"nul past the end\" } */\n   T (1, \"%-.0hd\",       0);\n-  T (1, \"% .0hd\",       0);\n+  T (1, \"% .0hd\",       0);         /* { dg-warning \"nul past the end\" } */\n   T (1, \"%0.0hd\",       0);         /* { dg-warning \".0. flag ignored with precision\" } */\n   T (1, \"%00.0hd\",      0);         /* { dg-warning \"repeated .0. flag in format\" } */\n   /* { dg-warning \".0. flag ignored with precision\" \"\" { target *-*-* } .-1 } */\n   T (1, \"%-0.0hd\",      0);         /* { dg-warning \".0. flag ignored with .-. flag\" } */\n   /* { dg-warning \".0. flag ignored with precision\" \"\" { target *-*-* } .-1 } */\n   T (1, \"%.0hi\",        0);\n   T (1, \"%.0ho\",        0);\n-  T (1, \"%#.0ho\",       0);\n+  T (1, \"%#.0ho\",       0);         /* { dg-warning \"nul past the end\" } */\n   T (1, \"%.0hx\",        0);\n   T (1, \"%.0hX\",        0);\n   T (1, \"%#.0hX\",       0);\n@@ -628,17 +629,17 @@ void test_sprintf_chk_integer_const (void)\n   /*  As a special case, a precision of zero with an argument of zero\n       results in zero bytes (unless modified by width).  */\n   T (1, \"%.0d\",         0);\n-  T (1, \"%+.0d\",        0);\n+  T (1, \"%+.0d\",        0);         /* { dg-warning \"nul past the end\" } */\n   T (1, \"%-.0d\",        0);\n-  T (1, \"% .0d\",        0);\n+  T (1, \"% .0d\",        0);         /* { dg-warning \"nul past the end\" } */\n   T (1, \"%0.0d\",        0);         /* { dg-warning \".0. flag ignored with precision\" } */\n   T (1, \"%00.0d\",       0);         /* { dg-warning \"repeated .0. flag in format\" } */\n   /* { dg-warning \".0. flag ignored with precision\" \"\" { target *-*-* } .-1 } */\n   T (1, \"%-0.0d\",       0);         /* { dg-warning \".0. flag ignored with .-. flag\" } */\n   /* { dg-warning \".0. flag ignored with precision\" \"\" { target *-*-* } .-1 } */\n   T (1, \"%.0i\",         0);\n   T (1, \"%.0o\",         0);\n-  T (1, \"%#.0o\",        0);\n+  T (1, \"%#.0o\",        0);         /* { dg-warning \"nul past the end\" } */\n   T (1, \"%.0x\",         0);\n   T (1, \"%.0X\",         0);\n   T (1, \"%#.0X\",        0);\n@@ -727,17 +728,19 @@ void test_sprintf_chk_j_const (void)\n   /*  As a special case, a precision of zero with an argument of zero\n       results in zero bytes (unless modified by width).  */\n   T (1, \"%.0jd\",     I (0));\n-  T (1, \"%+.0jd\",    I (0));\n+  T (1, \"%+.0jd\",    I (0));         /* { dg-warning \"nul past the end\" } */\n+  T (1, \"%+.0ju\",    I (0));         /* { dg-warning \".\\\\+. flag used\" } */\n   T (1, \"%-.0jd\",    I (0));\n-  T (1, \"% .0jd\",    I (0));\n+  T (1, \"% .0jd\",    I (0));         /* { dg-warning \"nul past the end\" } */\n+  T (1, \"% .0ju\",    I (0));         /* { dg-warning \". . flag used\" } */\n   T (1, \"%0.0jd\",    I (0));         /* { dg-warning \".0. flag ignored with precision\" } */\n   T (1, \"%00.0jd\",   I (0));         /* { dg-warning \"repeated .0. flag in format\" } */\n   /* { dg-warning \".0. flag ignored with precision\" \"\" { target *-*-* } .-1 } */\n   T (1, \"%-0.0jd\",   I (0));         /* { dg-warning \".0. flag ignored with .-. flag\" } */\n   /* { dg-warning \".0. flag ignored with precision\" \"\" { target *-*-* } .-1 } */\n   T (1, \"%.0ji\",     I (0));\n   T (1, \"%.0jo\",     I (0));\n-  T (1, \"%#.0jo\",    I (0));\n+  T (1, \"%#.0jo\",    I (0));         /* { dg-warning \"nul past the end\" } */\n   T (1, \"%.0jx\",     I (0));\n   T (1, \"%.0jX\",     I (0));\n   T (1, \"%#.0jX\",    I (0));\n@@ -801,17 +804,19 @@ void test_sprintf_chk_l_const (void)\n   /*  As a special case, a precision of zero with an argument of zero\n       results in zero bytes (unless modified by width).  */\n   T (1, \"%.0ld\",     0L);\n-  T (1, \"%+.0ld\",    0L);\n+  T (1, \"%+.0ld\",    0L);         /* { dg-warning \"nul past the end\" } */\n+  T (1, \"%+.0lu\",    0L);         /* { dg-warning \".\\\\+. flag used\" } */\n   T (1, \"%-.0ld\",    0L);\n-  T (1, \"% .0ld\",    0L);\n+  T (1, \"% .0ld\",    0L);         /* { dg-warning \"nul past the end\" } */\n+  T (1, \"% .0lu\",    0L);         /* { dg-warning \". . flag used\" } */\n   T (1, \"%0.0ld\",    0L);         /* { dg-warning \".0. flag ignored with precision\" } */\n   T (1, \"%00.0ld\",   0L);         /* { dg-warning \"repeated .0. flag in format\" } */\n   /* { dg-warning \".0. flag ignored with precision\" \"\" { target *-*-* } .-1 } */\n   T (1, \"%-0.0ld\",   0L);         /* { dg-warning \".0. flag ignored with .-. flag\" } */\n   /* { dg-warning \".0. flag ignored with precision\" \"\" { target *-*-* } .-1 } */\n   T (1, \"%.0li\",     0L);\n   T (1, \"%.0lo\",     0L);\n-  T (1, \"%#.0lo\",    0L);\n+  T (1, \"%#.0lo\",    0L);         /* { dg-warning \"nul past the end\" } */\n   T (1, \"%.0lx\",     0L);\n   T (1, \"%.0lX\",     0L);\n   T (1, \"%#.0lX\",    0L);\n@@ -1039,8 +1044,8 @@ void test_sprintf_chk_s_nonconst (int w, int p, const char *s)\n      is not.  */\n   T ( 1, \"%*s\",  w, \"\");\n   T ( 1, \"%*s\",  w, \"1\");       /* { dg-warning \"nul past the end\" } */\n-  T ( 1, \"%.*s\", w, \"\");\n-  T ( 1, \"%.*s\", w, \"1\");       /* { dg-warning \"may write a terminating nul\" } */\n+  T ( 1, \"%.*s\", p, \"\");\n+  T ( 1, \"%.*s\", p, \"1\");       /* { dg-warning \"may write a terminating nul\" } */\n   T ( 1, \"%.*s\", w, \"123\");     /* { dg-warning \"writing between 0 and 3 bytes into a region of size 1\" } */\n \n   T ( 1, \"%*s\", w, \"123\");      /* { dg-warning \"writing 3 or more bytes into a region of size 1\" } */\n@@ -1294,6 +1299,12 @@ void test_sprintf_chk_int_nonconst (int w, int p, int a)\n   T (3, \"%2x\",          a);\n \n   T (1, \"%.*d\",      p, a);\n+\n+  T (4, \"%i %i\",        a, a);\n+  /* The following will definitely be \"writing a terminating nul past the end\"\n+     (i.e., not \"may write\".)  */\n+  T (4, \"%i %i \",       a, a);      /* { dg-warning \"writing a terminating nul past the end\" } */\n+  T (4, \"%i %i %i\",     a, a, a);   /* { dg-warning \"into a region\" }*/\n }\n \n void test_sprintf_chk_e_nonconst (int w, int p, double d)"}, {"sha": "7acb83d85b7a88439aaf0b05f8ba73f835e30154", "filename": "gcc/testsuite/gcc.dg/tree-ssa/builtin-sprintf-warn-2.c", "status": "modified", "additions": 50, "deletions": 1, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/573aa7d4b7c1249c16c12c8483ab8b9830848b82/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-warn-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/573aa7d4b7c1249c16c12c8483ab8b9830848b82/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-warn-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-warn-2.c?ref=573aa7d4b7c1249c16c12c8483ab8b9830848b82", "patch": "@@ -125,12 +125,61 @@ void test_s_nonconst (const char *s, const wchar_t *ws, struct Arrays *a)\n \n   /* Exercise buffer overflow detection with non-const integer arguments.  */\n \n-void test_hh_nonconst (int x)\n+void test_hh_nonconst (int w, int p, int x, unsigned y)\n {\n   T (1, \"%hhi\",         x);     /* { dg-warning \"into a region\" } */\n   T (2, \"%hhi\",         x);     /* { dg-warning \"into a region\" } */\n   T (3, \"%hhi\",         x);     /* { dg-warning \"into a region\" } */\n   T (4, \"%hhi\",         x);     /* { dg-warning \"may write a terminating nul past the end of the destination\" } */\n+\n+  T (1, \"%hhi\",         y);     /* { dg-warning \"between 1 and 4 bytes\" } */\n+  T (2, \"%hhi\",         y);     /* { dg-warning \"into a region\" } */\n+  T (3, \"%hhi\",         y);     /* { dg-warning \"into a region\" } */\n+  T (4, \"%hhi\",         y);     /* { dg-warning \"may write a terminating nul past the end of the destination\" } */\n+\n+  /* Negative precision is treated as if none were specified.  */\n+  T (1, \"%.*hhi\",   -1, x);     /* { dg-warning \"between 1 and 4 bytes\" } */\n+  T (2, \"%.*hhi\",   -1, x);     /* { dg-warning \"into a region\" } */\n+  T (3, \"%.*hhi\",   -1, x);     /* { dg-warning \"into a region\" } */\n+  T (4, \"%.*hhi\",   -1, x);     /* { dg-warning \"may write a terminating nul past the end of the destination\" } */\n+\n+  /* Zero precision means that zero argument formats as no bytes unless\n+     length or flags make it otherwise.  */\n+  T (1, \"%.*hhi\",    0, x);     /* { dg-warning \"between 0 and 4 bytes\" } */\n+  T (2, \"%.*hhi\",    0, x);     /* { dg-warning \"between 0 and 4 bytes\" } */\n+  T (3, \"%.*hhi\",    0, x);     /* { dg-warning \"between 0 and 4 bytes\" } */\n+  T (4, \"%.*hhi\",    0, x);     /* { dg-warning \"may write a terminating nul past the end of the destination\" } */\n+\n+  T (1, \"%.*hhi\",    0, y);     /* { dg-warning \"between 0 and 4 bytes\" } */\n+  T (2, \"%.*hhi\",    0, y);     /* { dg-warning \"between 0 and 4 bytes\" } */\n+  T (3, \"%.*hhi\",    0, y);     /* { dg-warning \"between 0 and 4 bytes\" } */\n+  T (4, \"%.*hhi\",    0, y);     /* { dg-warning \"may write a terminating nul past the end of the destination\" } */\n+\n+  T (1, \"%#.*hhi\",    0, y);    /* { dg-warning \"between 0 and 4 bytes\" } */\n+  /* { dg-warning \".#. flag used\" \"-Wformat\" { target *-*-* } .-1 } */\n+  T (1, \"%+.*hhi\",    0, y);    /* { dg-warning \"between 1 and 4 bytes\" } */\n+  T (1, \"%-.*hhi\",    0, y);    /* { dg-warning \"between 0 and 4 bytes\" } */\n+  T (1, \"% .*hhi\",    0, y);    /* { dg-warning \"between 1 and 4 bytes\" } */\n+\n+  T (1, \"%#.*hhi\",    1, y);    /* { dg-warning \"between 1 and 4 bytes\" } */\n+  /* { dg-warning \".#. flag used\" \"-Wformat\" { target *-*-* } .-1 } */\n+  T (1, \"%+.*hhi\",    1, y);    /* { dg-warning \"between 2 and 4 bytes\" } */\n+  T (1, \"%-.*hhi\",    1, y);    /* { dg-warning \"between 1 and 4 bytes\" } */\n+  T (1, \"% .*hhi\",    1, y);    /* { dg-warning \"between 2 and 4 bytes\" } */\n+\n+  T (1, \"%#.*hhi\",    p, y);    /* { dg-warning \"writing 0 or more bytes\" } */\n+  /* { dg-warning \".#. flag used\" \"-Wformat\" { target *-*-* } .-1 } */\n+  T (1, \"%+.*hhi\",    p, y);    /* { dg-warning \"writing 1 or more bytes\" } */\n+  T (1, \"%-.*hhi\",    p, y);    /* { dg-warning \"writing 0 or more bytes\" } */\n+  T (1, \"% .*hhi\",    p, y);    /* { dg-warning \"writing 1 or more bytes\" } */\n+\n+  T (1, \"%#.*hhu\",    0, y);    /* { dg-warning \"between 0 and 3 bytes\" } */\n+  /* { dg-warning \".#. flag used\" \"-Wformat\" { target *-*-* } .-1 } */\n+  T (1, \"%+.*hhu\",    0, y);    /* { dg-warning \"between 0 and 3 bytes\" } */\n+  /* { dg-warning \".\\\\+. flag used\" \"-Wformat\" { target *-*-* } .-1 } */\n+  T (1, \"%-.*hhu\",    0, y);    /* { dg-warning \"between 0 and 3 bytes\" } */\n+  T (1, \"% .*hhu\",    0, y);    /* { dg-warning \"between 0 and 3 bytes\" } */\n+  /* { dg-warning \". . flag used\" \"-Wformat\" { target *-*-* } .-1 } */\n }\n \n void test_h_nonconst (int x)"}, {"sha": "1ca0a66388e43e22708e8a1934ab45927451a567", "filename": "gcc/testsuite/gcc.dg/tree-ssa/builtin-sprintf-warn-3.c", "status": "modified", "additions": 144, "deletions": 61, "changes": 205, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/573aa7d4b7c1249c16c12c8483ab8b9830848b82/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-warn-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/573aa7d4b7c1249c16c12c8483ab8b9830848b82/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-warn-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-warn-3.c?ref=573aa7d4b7c1249c16c12c8483ab8b9830848b82", "patch": "@@ -116,54 +116,76 @@ void test_sprintf_chk_integer_value (void)\n   T ( 9, \"%8u\", i (    1));\n }\n \n+extern int rand (void);\n+\n /* Functions to require optimization to figure out the range of the operand.\n    Used to verify that the checker makes use of the range information to\n    avoid diagnosing the output of sufficiently constrained arguments to\n    integer directives.  */\n \n-signed char*\n-range_schar (signed char *val, signed char min, signed char max)\n+signed char\n+range_schar (signed char min, signed char max)\n {\n-  if (*val < min || max < *val) __builtin_abort ();\n-  return val;\n+  signed char val = rand ();\n+  return val < min || max < val ? min : val;\n }\n \n-unsigned char*\n-range_uchar (unsigned char *val, unsigned char min, unsigned char max)\n+unsigned char\n+range_uchar (unsigned char min, unsigned char max)\n {\n-  if (*val < min || max < *val) __builtin_abort ();\n-  return val;\n+  unsigned char val = rand ();\n+  return val < min || max < val ? min : val;\n }\n \n-signed short*\n-range_sshort (signed short *val, signed short min, signed short max)\n+signed short\n+range_sshrt (signed short min, signed short max)\n {\n-  if (*val < min || max < *val) __builtin_abort ();\n-  return val;\n+  signed short val = rand ();\n+  return val < min || max < val ? min : val;\n }\n \n-unsigned short*\n-range_ushort (unsigned short *val, unsigned short min, unsigned short max)\n+unsigned short\n+range_ushrt (unsigned short min, unsigned short max)\n {\n-  if (*val < min || max < *val) __builtin_abort ();\n-  return val;\n+  unsigned short val = rand ();\n+  return val < min || max < val ? min : val;\n }\n \n-/* Helper to prevent GCC from figuring out the return value.  */\n-extern int idx (void);\n+signed int\n+range_sint (signed int min, signed int max)\n+{\n+  signed int val = rand ();\n+  return val < min || max < val ? min : val;\n+}\n \n-/* Exercise ranges only in types signed and unsigned char and short.\n-   No other types work due to bug 71690.  */\n+unsigned int\n+range_uint (unsigned int min, unsigned int max)\n+{\n+  unsigned int val = rand ();\n+  return val < min || max < val ? min : val;\n+}\n \n-void test_sprintf_chk_range_schar (signed char *a)\n+void test_sprintf_chk_range_schar (void)\n {\n-  (void)&a;\n+#define R(min, max) range_sint (min, max)\n+\n+  T ( 0, \"%hhi\", R (0, 1));     /* { dg-warning \".%hhi. directive writing 1 byte into a region of size 0\" } */\n+  /* { dg-message \"directive argument in the range \\\\\\[0, 1\\\\\\]\" \"note\" { target *-*-* } .-1 } */\n \n-  /* Ra creates a range of signed char for A [idx].  A different\n-     value is used each time to prevent the ranges from intesecting\n-     one another, possibly even eliminating some tests as a result\n-     of the range being empty.  */\n-#define R(min, max) *range_schar (a + idx (), min, max)\n+  T ( 0, \"%hhi\", R (0, 127));   /* { dg-warning \".%hhi. directive writing between 1 and 3 bytes into a region of size 0\" } */\n+  /* { dg-message \"directive argument in the range \\\\\\[0, 127\\\\\\]\" \"note\" { target *-*-* } .-1 } */\n+\n+  T ( 0, \"%hhi\", R (1024, 1033));   /* { dg-warning \".%hhi. directive writing 1 byte into a region of size 0\" } */\n+  /* { dg-message \"directive argument in the range \\\\\\[1024, 1033\\\\\\]\" \"note\" { target *-*-* } .-1 } */\n+\n+  T ( 0, \"%hhi\", R (1024, 1034));   /* { dg-warning \".%hhi. directive writing between 1 and 2 bytes into a region of size 0\" } */\n+  /* { dg-message \"directive argument in the range \\\\\\[1024, 1034\\\\\\]\" \"note\" { target *-*-* } .-1 } */\n+\n+  T ( 0, \"%hhi\", R (1024, 2035));   /* { dg-warning \".%hhi. directive writing between 1 and 4 bytes into a region of size 0\" } */\n+  /* { dg-message \"using the range \\\\\\[0, -128\\\\\\] for directive argument\" \"note\" { target *-*-* } .-1 } */\n+\n+#undef R\n+#define R(min, max) range_schar (min, max)\n \n   T ( 0, \"%i\",  R (0, 9));      /* { dg-warning \".%i. directive writing 1 byte into a region of size 0\" } */\n   T ( 1, \"%i\",  R (0, 9));      /* { dg-warning \"nul past the end\" } */\n@@ -192,47 +214,108 @@ void test_sprintf_chk_range_schar (signed char *a)\n   T ( 6, \"%i_%i_%i\", R (0, 9), R (0, 10), R (0, 10)); /* { dg-warning \"may write a terminating nul past the end|.%i. directive writing between 1 and 2 bytes into a region of size 1\" } */\n }\n \n-void test_sprintf_chk_range_uchar (unsigned char *a, unsigned char *b)\n+void test_sprintf_chk_range_uchar (void)\n+{\n+#undef R\n+#define R(min, max) range_uchar (min, max)\n+\n+  T ( 0, \"%i\",  R (0,  9));   /* { dg-warning \".%i. directive writing 1 byte into a region of size 0\" } */\n+  T ( 1, \"%i\",  R (0,  9));   /* { dg-warning \"nul past the end\" } */\n+  T ( 2, \"%i\",  R (0,  9));\n+  T ( 2, \"%i\",  R (9, 10));   /* { dg-warning \"may write a terminating nul past the end of the destination\" } */\n+\n+  T ( 3, \"%i\",  R (0,  99));\n+  T ( 3, \"%i\",  R (0, 100));  /* { dg-warning \"may write a terminating nul past the end of the destination\" } */\n+}\n+\n+void test_sprintf_chk_range_sshrt (void)\n+{\n+#undef R\n+#define R(min, max) range_sshrt (min, max)\n+\n+  T ( 0, \"%i\",  R ( 0, 9));     /* { dg-warning \".%i. directive writing 1 byte into a region of size 0\" } */\n+  T ( 1, \"%i\",  R ( 0, 1));     /* { dg-warning \"nul past the end\" } */\n+  T ( 1, \"%i\",  R ( 0, 9));     /* { dg-warning \"nul past the end\" } */\n+  T ( 2, \"%i\",  R ( 0, 1));\n+  T ( 2, \"%i\",  R ( 8, 9));\n+  T ( 2, \"%i\",  R ( 0, 9));\n+  T ( 2, \"%i\",  R (-1, 0));     /* { dg-warning \"may write a terminating nul past the end of the destination\" } */\n+  T ( 2, \"%i\",  R ( 9, 10));    /* { dg-warning \"may write a terminating nul past the end of the destination\" } */\n+\n+  T ( 3, \"%i\",  R ( 0, 99));\n+  T ( 3, \"%i\",  R (99, 999));   /* { dg-warning \"may write a terminating nul past the end of the destination\" } */\n+\n+  T ( 4, \"%i\",  R (  0,  999));\n+  T ( 4, \"%i\",  R ( 99,  999));\n+  T ( 4, \"%i\",  R (998,  999));\n+  T ( 4, \"%i\",  R (999, 1000)); /* { dg-warning \"may write a terminating nul past the end of the destination\" } */\n+}\n+\n+void test_sprintf_chk_range_ushrt (void)\n {\n-  (void)&a;\n-  (void)&b;\n+#undef R\n+#define R(min, max) range_ushrt (min, max)\n+\n+  T ( 0, \"%i\",  R ( 0, 9));     /* { dg-warning \".%i. directive writing 1 byte into a region of size 0\" } */\n+  T ( 1, \"%i\",  R ( 0, 1));     /* { dg-warning \"nul past the end\" } */\n+  T ( 1, \"%i\",  R ( 0, 9));     /* { dg-warning \"nul past the end\" } */\n+  T ( 2, \"%i\",  R ( 0, 1));\n+  T ( 2, \"%i\",  R ( 8, 9));\n+  T ( 2, \"%i\",  R ( 0, 9));\n+  T ( 2, \"%i\",  R ( 9, 10));    /* { dg-warning \"may write a terminating nul past the end of the destination\" } */\n+\n+  T ( 3, \"%i\",  R ( 0, 99));\n+  T ( 3, \"%i\",  R (99, 999));   /* { dg-warning \"may write a terminating nul past the end of the destination\" } */\n+\n+  T ( 4, \"%i\",  R (  0,  999));\n+  T ( 4, \"%i\",  R ( 99,  999));\n+  T ( 4, \"%i\",  R (998,  999));\n+  T ( 4, \"%i\",  R (999, 1000)); /* { dg-warning \"may write a terminating nul past the end of the destination\" } */\n+}\n \n-#undef Ra\n-#define Ra(min, max) *range_uchar (a + idx (), min, max)\n+void test_sprintf_chk_range_sint (void)\n+{\n+#undef R\n+#define R(min, max) range_sint (min, max)\n+\n+  T ( 0, \"%i\",  R ( 0, 9));     /* { dg-warning \".%i. directive writing 1 byte into a region of size 0\" } */\n+  T ( 1, \"%i\",  R ( 0, 1));     /* { dg-warning \"nul past the end\" } */\n+  T ( 1, \"%i\",  R ( 0, 9));     /* { dg-warning \"nul past the end\" } */\n+  T ( 2, \"%i\",  R ( 0, 1));\n+  T ( 2, \"%i\",  R ( 8, 9));\n+  T ( 2, \"%i\",  R ( 0, 9));\n+  T ( 2, \"%i\",  R (-1, 0));     /* { dg-warning \"may write a terminating nul past the end of the destination\" } */\n+  T ( 2, \"%i\",  R ( 9, 10));    /* { dg-warning \"may write a terminating nul past the end of the destination\" } */\n \n-  T ( 0, \"%i\",  Ra (0,  9));   /* { dg-warning \".%i. directive writing 1 byte into a region of size 0\" } */\n-  T ( 1, \"%i\",  Ra (0,  9));   /* { dg-warning \"nul past the end\" } */\n-  T ( 2, \"%i\",  Ra (0,  9));\n-  T ( 2, \"%i\",  Ra (9, 10));   /* { dg-warning \"may write a terminating nul past the end of the destination\" } */\n+  T ( 3, \"%i\",  R ( 0, 99));\n+  T ( 3, \"%i\",  R (99, 999));   /* { dg-warning \"may write a terminating nul past the end of the destination\" } */\n \n-  T ( 3, \"%i\",  Ra (0,  99));\n-  T ( 3, \"%i\",  Ra (0, 100));  /* { dg-warning \"may write a terminating nul past the end of the destination\" } */\n+  T ( 4, \"%i\",  R (  0,  999));\n+  T ( 4, \"%i\",  R ( 99,  999));\n+  T ( 4, \"%i\",  R (998,  999));\n+  T ( 4, \"%i\",  R (999, 1000)); /* { dg-warning \"may write a terminating nul past the end of the destination\" } */\n }\n \n-void test_sprintf_chk_range_sshort (signed short *a, signed short *b)\n+void test_sprintf_chk_range_uint (void)\n {\n-  (void)&a;\n-  (void)&b;\n-\n-#undef Ra\n-#define Ra(min, max) *range_sshort (a + idx (), min, max)\n-\n-  T ( 0, \"%i\",  Ra ( 0, 9));     /* { dg-warning \".%i. directive writing 1 byte into a region of size 0\" } */\n-  T ( 1, \"%i\",  Ra ( 0, 1));     /* { dg-warning \"nul past the end\" } */\n-  T ( 1, \"%i\",  Ra ( 0, 9));     /* { dg-warning \"nul past the end\" } */\n-  T ( 2, \"%i\",  Ra ( 0, 1));\n-  T ( 2, \"%i\",  Ra ( 8, 9));\n-  T ( 2, \"%i\",  Ra ( 0, 9));\n-  T ( 2, \"%i\",  Ra (-1, 0));     /* { dg-warning \"may write a terminating nul past the end of the destination\" } */\n-  T ( 2, \"%i\",  Ra ( 9, 10));    /* { dg-warning \"may write a terminating nul past the end of the destination\" } */\n-\n-  T ( 3, \"%i\",  Ra ( 0, 99));\n-  T ( 3, \"%i\",  Ra (99, 999));   /* { dg-warning \"may write a terminating nul past the end of the destination\" } */\n-\n-  T ( 4, \"%i\",  Ra (  0,  999));\n-  T ( 4, \"%i\",  Ra ( 99,  999));\n-  T ( 4, \"%i\",  Ra (998,  999));\n-  T ( 4, \"%i\",  Ra (999, 1000)); /* { dg-warning \"may write a terminating nul past the end of the destination\" } */\n+#undef R\n+#define R(min, max) range_uint (min, max)\n+\n+  T ( 0, \"%i\",  R ( 0, 9));     /* { dg-warning \".%i. directive writing 1 byte into a region of size 0\" } */\n+  T ( 1, \"%i\",  R ( 0, 1));     /* { dg-warning \"nul past the end\" } */\n+  T ( 1, \"%i\",  R ( 0, 9));     /* { dg-warning \"nul past the end\" } */\n+  T ( 2, \"%i\",  R ( 0, 1));\n+  T ( 2, \"%i\",  R ( 8, 9));\n+  T ( 2, \"%i\",  R ( 0, 9));\n+  T ( 2, \"%i\",  R ( 9, 10));    /* { dg-warning \"may write a terminating nul past the end of the destination\" } */\n+\n+  T ( 3, \"%i\",  R ( 0, 99));\n+  T ( 3, \"%i\",  R (99, 999));   /* { dg-warning \"may write a terminating nul past the end of the destination\" } */\n+\n+  T ( 4, \"%i\",  R (  0,  999));\n+  T ( 4, \"%i\",  R ( 99,  999));\n+  T ( 4, \"%i\",  R (998,  999));\n+  T ( 4, \"%i\",  R (999, 1000)); /* { dg-warning \"may write a terminating nul past the end of the destination\" } */\n }\n \n /* Verify that destination size in excess of INT_MAX (and, separately,"}, {"sha": "121ed4ea3c822ec76187fc155f87308507e21c23", "filename": "gcc/testsuite/gcc.dg/tree-ssa/builtin-sprintf-warn-6.c", "status": "modified", "additions": 23, "deletions": 8, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/573aa7d4b7c1249c16c12c8483ab8b9830848b82/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-warn-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/573aa7d4b7c1249c16c12c8483ab8b9830848b82/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-warn-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-warn-6.c?ref=573aa7d4b7c1249c16c12c8483ab8b9830848b82", "patch": "@@ -2,15 +2,18 @@\n    Test to verify that the correct range information is made available to the\n    -Wformat-lenght check to prevent warnings.  */\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -Wformat -Wformat-length\" } */\n+/* { dg-options \"-O2 -Wformat -Wformat-length -fdump-tree-optimized\" } */\n \n+void abort (void);\n int snprintf (char*, __SIZE_TYPE__, const char*, ...);\n \n void fuchar (unsigned char j, char *p)\n {\n   if (j > 99)\n     return;\n-  snprintf (p, 4, \"%3hu\", j);\n+\n+  if (3 != snprintf (p, 4, \"%3hu\", j))\n+    abort ();\n }\n \n void fschar (signed char j, char *p)\n@@ -20,14 +23,17 @@ void fschar (signed char j, char *p)\n   if (k > 99)\n     return;\n \n-  snprintf (p, 3, \"%3hhu\", k);   /* { dg-bogus \"\" \"unsigned char\" { xfail *-*-* } } */\n+  if (3 != snprintf (p, 4, \"%3hhu\", k))\n+    abort ();\n }\n \n void fushrt (unsigned short j, char *p)\n {\n   if (j > 999)\n     return;\n-  snprintf (p, 4, \"%3hu\", j);\n+\n+  if (3 != snprintf (p, 4, \"%3hu\", j))\n+    abort ();\n }\n \n void fshrt (short j, char *p)\n@@ -37,7 +43,8 @@ void fshrt (short j, char *p)\n   if (k > 999)\n     return;\n \n-  snprintf (p, 4, \"%3hu\", k);\n+  if (3 != snprintf (p, 4, \"%3hu\", k))\n+    abort ();\n }\n \n void fuint (unsigned j, char *p)\n@@ -54,13 +61,16 @@ void fint (int j, char *p)\n   if (k > 999)\n     return;\n \n-  snprintf (p, 4, \"%3u\", k);   /* { dg-bogus \"\" \"unsigned int\" { xfail *-*-* } } */\n+  /* Range info isn't available here.  */\n+  snprintf (p, 4, \"%3u\", k);\n }\n \n void fulong (unsigned long j, char *p)\n {\n   if (j > 999)\n     return;\n+\n+  /* Range info isn't available here.  */\n   snprintf (p, 4, \"%3lu\", j);\n }\n \n@@ -71,13 +81,16 @@ void flong (long j, char *p)\n   if (k > 999)\n     return;\n \n-  snprintf (p, 4, \"%3lu\", k);   /* { dg-bogus \"\" \"unsigned long\" { xfail *-*-* } } */\n+  /* Range info isn't available here.  */\n+  snprintf (p, 4, \"%3lu\", k);\n }\n \n void fullong (unsigned long long j, char *p)\n {\n   if (j > 999)\n     return;\n+\n+  /* Range info isn't available here.  */\n   snprintf (p, 4, \"%3llu\", j);\n }\n \n@@ -88,5 +101,7 @@ void fllong (long j, char *p)\n   if (k > 999)\n     return;\n \n-  snprintf (p, 4, \"%3llu\", k);   /* { dg-bogus \"\" \"unsigned long long\" { xfail lp64 } } */\n+  snprintf (p, 4, \"%3llu\", k);\n }\n+\n+/* { dg-final { scan-tree-dump-not \"abort\" \"optimized\" } } */"}, {"sha": "35a5bd0f0602aa1697c6ba959158322a896891d9", "filename": "gcc/testsuite/gcc.dg/tree-ssa/builtin-sprintf.c", "status": "modified", "additions": 60, "deletions": 13, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/573aa7d4b7c1249c16c12c8483ab8b9830848b82/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/573aa7d4b7c1249c16c12c8483ab8b9830848b82/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf.c?ref=573aa7d4b7c1249c16c12c8483ab8b9830848b82", "patch": "@@ -166,27 +166,48 @@ test_c (char c)\n   EQL (5,  6, \"%c %c %c\",  c,   c,   c);\n }\n \n-/* Generate a pseudo-random value in the specified range.  The return\n-   value must be unsigned char to work around limitations in the GCC\n-   range information.  Similarly for the declaration of rand() whose\n-   correct return value should be int, but that also prevents the range\n-   information from making it to the printf pass.  */\n+/* Generate a pseudo-random unsigned value.  */\n \n-unsigned char uchar_range (unsigned min, unsigned max)\n+unsigned __attribute__ ((noclone, noinline))\n+unsigned_value (void)\n {\n-  extern unsigned rand (void);\n+  extern int rand ();\n+  return rand ();\n+}\n \n-  unsigned x;\n-  x = rand ();\n+/* Generate a pseudo-random signed value.  */\n \n-  if (x < min)\n-    x = min;\n-  else if (max < x)\n-    x = max;\n+int __attribute__ ((noclone, noinline))\n+int_value (void)\n+{\n+  extern int rand ();\n+  return rand ();\n+}\n+\n+/* Generate an unsigned char value in the specified range.  */\n \n+static unsigned char\n+uchar_range (unsigned min, unsigned max)\n+{\n+  unsigned x = unsigned_value ();\n+  if (x < min || max < x)\n+    x = min;\n   return x;\n }\n \n+/* Generate a signed int value in the specified range.  */\n+\n+static int\n+int_range (int min, int max)\n+{\n+  int val = int_value ();\n+  if (val < min || max < val)\n+    val = min;\n+  return val;\n+}\n+\n+#define IR(min, max) int_range (min, max)\n+\n static void __attribute__ ((noinline, noclone))\n test_d_i (int i, long li)\n {\n@@ -266,9 +287,35 @@ test_d_i (int i, long li)\n   RNG ( 1,  4,  5, \"%hhi\",     i);\n   RNG ( 1,  3,  4, \"%hhu\",     i);\n \n+  RNG ( 3,  4,  5, \"%hhi\",     IR (-128,  -10));\n+  RNG ( 2,  4,  5, \"%hhi\",     IR (-128,   -1));\n+  RNG ( 1,  4,  5, \"%hhi\",     IR (-128,    0));\n+\n+  RNG ( 1,  4,  5, \"%1hhi\",    IR (-128,    0));\n+  RNG ( 1,  4,  5, \"%2hhi\",    IR (-128,    0));\n+  RNG ( 1,  4,  5, \"%3hhi\",    IR (-128,    0));\n+  RNG ( 1,  4,  5, \"%4hhi\",    IR (-128,    0));\n+  RNG ( 1,  5,  6, \"%5hhi\",    IR (-128,    0));\n+  RNG ( 1,  6,  7, \"%6hhi\",    IR (-128,    0));\n+  RNG ( 2,  6,  7, \"%6hhi\",    IR (-128,   10));\n+\n+  RNG ( 0,  1,  2, \"%.hhi\",    IR (   0,    1));\n+  RNG ( 0,  1,  2, \"%.0hhi\",   IR (   0,    1));\n+  RNG ( 0,  1,  2, \"%0.0hhi\",  IR (   0,    1));   /* { dg-warning \".0. flag ignored with precision\" } */\n+  RNG ( 0,  1,  2, \"%*.0hhi\",  0, IR (   0,    1));\n+\n+  RNG ( 1,  2,  3, \"%hhi\",     IR (1024, 1034));\n+  RNG ( 1,  4,  5, \"%hhi\",     IR (1024, 2048));\n+  RNG ( 2,  3,  4, \"%hhi\",     IR (1034, 1151));\n+\n+  RNG ( 1,  2,  3, \"%hhu\",     IR (1024, 1034));\n+  RNG ( 1,  3,  4, \"%hhu\",     IR (1024, 2048));\n+  RNG ( 2,  3,  4, \"%hhu\",     IR (1034, 1151));\n+\n #if __SIZEOF_SHORT__ == 2\n   RNG ( 1,  6,  7, \"%hi\",      i);\n   RNG ( 1,  5,  6, \"%hu\",      i);\n+\n #elif __SIZEOF_SHORT__ == 4\n   RNG ( 1, 11, 12, \"%hi\",      i);\n   RNG ( 1, 10, 11, \"%hu\",      i);"}, {"sha": "7a73ebeed40d5ad2ec0aaa96364e1f7553afa021", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr78622.c", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/573aa7d4b7c1249c16c12c8483ab8b9830848b82/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr78622.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/573aa7d4b7c1249c16c12c8483ab8b9830848b82/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr78622.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr78622.c?ref=573aa7d4b7c1249c16c12c8483ab8b9830848b82", "patch": "@@ -0,0 +1,63 @@\n+/* PR middle-end/78622 - [7 Regression] -Wformat-length/-fprintf-return-value\n+   incorrect with overflow/wrapping\n+   { dg-do compile }\n+   { dg-options \"-Wformat-length=2\" } */\n+\n+char buf[1];\n+\n+int test_uchar_hhd (unsigned char x)\n+{\n+  if (x < 64 || x > 2U * __SCHAR_MAX__ - 10)\n+    return -1;\n+\n+  return __builtin_sprintf (buf, \"%hhd\", x + 1);   /* { dg-warning \"directive writing between 1 and 4 bytes into a region of size 1\" \"int32plus\" { target { int32plus } } } */\n+}\n+\n+int test_uint_hhd (unsigned x)\n+{\n+  if (x < 64 || x > 2U * __INT_MAX__ - 10)\n+    return -1;\n+\n+  return __builtin_sprintf (buf, \"%hhd\", x + 1);   /* { dg-warning \"directive writing between 1 and 4 bytes into a region of size 1\" \"int32plus\" { target { int32plus } } } */\n+}\n+\n+int test_schar_hhu (signed char x)\n+{\n+  if (x < -9 || x > 9)\n+    return -1;\n+\n+  return __builtin_sprintf (buf, \"%hhu\", x + 1);   /* { dg-warning \"directive writing between 1 and 3 bytes into a region of size 1\" \"int32plus\" { target { int32plus } } } */\n+}\n+\n+int test_ushort_hd (unsigned short x)\n+{\n+  if (x < 64 || x > 2U * __SHRT_MAX__ - 10)\n+    return -1;\n+\n+  return __builtin_sprintf (buf, \"%hd\", x + 1);   /* { dg-warning \"directive writing between 1 and 6 bytes into a region of size 1\" \"int32plus\" { target { int32plus } } } */\n+}\n+\n+int test_uint_d (unsigned x)\n+{\n+  if (x < 64 || x > 2U * __INT_MAX__ - 10)\n+    return -1;\n+\n+  return __builtin_sprintf (buf, \"%d\", x + 1);   /* { dg-warning \"directive writing between 1 and 11 bytes into a region of size 1\" \"int32plus\" { target { int32plus } } } */\n+}\n+\n+int test_ulong_ld (unsigned long x)\n+{\n+  if (x < 64 || x > 2LU * __LONG_MAX__ - 10)\n+    return -1;\n+\n+  return __builtin_sprintf (buf, \"%ld\", x + 1);   /* { dg-warning \"directive writing between 1 and 11 bytes into a region of size 1\" \"ilp32\" { target { ilp32 } } } */\n+  /* { dg-warning \"directive writing between 1 and 20 bytes into a region of size 1\" \"lp64\" { target { lp64 } } .-1 } */\n+}\n+\n+int test_ullong_lld (unsigned long long x)\n+{\n+  if (x < 64 || x > 2LLU * __LONG_LONG_MAX__ - 10)\n+    return -1;\n+\n+  return __builtin_sprintf (buf, \"%lld\", x + 1);   /* { dg-warning \"directive writing between 1 and 20 bytes into a region of size 1\" \"int32plus\" { target { int32plus } } } */\n+}"}]}