{"sha": "b680881871eeab3095ffc35c73b34662803ea4fb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjY4MDg4MTg3MWVlYWIzMDk1ZmZjMzVjNzNiMzQ2NjI4MDNlYTRmYg==", "commit": {"author": {"name": "John David Anglin", "email": "danglin@gcc.gnu.org", "date": "2014-04-04T22:25:51Z"}, "committer": {"name": "John David Anglin", "email": "danglin@gcc.gnu.org", "date": "2014-04-04T22:25:51Z"}, "message": "re PR rtl-optimization/60155 (ICE: in get_pressure_class_and_nregs at gcse.c:3438)\n\n\tPR rtl-optimization/60155\n\t* gcse.c (record_set_data): New function.\n\t(single_set_gcse): New function.\n\t(gcse_emit_move_after): Use single_set_gcse instead of single_set.\n\t(hoist_code): Likewise.\n\t(get_pressure_class_and_nregs): Likewise.\n\nFrom-SVN: r209134", "tree": {"sha": "6943553dd4373405684e3bec66c0ad48f3934029", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6943553dd4373405684e3bec66c0ad48f3934029"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b680881871eeab3095ffc35c73b34662803ea4fb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b680881871eeab3095ffc35c73b34662803ea4fb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b680881871eeab3095ffc35c73b34662803ea4fb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b680881871eeab3095ffc35c73b34662803ea4fb/comments", "author": null, "committer": null, "parents": [{"sha": "3e0da29a996ff9457f973781dd233835bb793b3a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3e0da29a996ff9457f973781dd233835bb793b3a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3e0da29a996ff9457f973781dd233835bb793b3a"}], "stats": {"total": 80, "additions": 73, "deletions": 7}, "files": [{"sha": "c6d836576dadc47a46564c47c3b4e7114da23a4c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b680881871eeab3095ffc35c73b34662803ea4fb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b680881871eeab3095ffc35c73b34662803ea4fb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b680881871eeab3095ffc35c73b34662803ea4fb", "patch": "@@ -1,3 +1,12 @@\n+2014-04-04  John David Anglin  <danglin@gcc.gnu.org>\n+\n+\tPR rtl-optimization/60155\n+\t* gcse.c (record_set_data): New function.\n+\t(single_set_gcse): New function.\n+\t(gcse_emit_move_after): Use single_set_gcse instead of single_set.\n+\t(hoist_code): Likewise.\n+\t(get_pressure_class_and_nregs): Likewise.\n+\n 2014-04-04  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* explow.c (probe_stack_range): Emit a final optimization blockage."}, {"sha": "b852aa1bf22fd0d11a1080f0c913993efe7618c3", "filename": "gcc/gcse.c", "status": "modified", "additions": 64, "deletions": 7, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b680881871eeab3095ffc35c73b34662803ea4fb/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b680881871eeab3095ffc35c73b34662803ea4fb/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=b680881871eeab3095ffc35c73b34662803ea4fb", "patch": "@@ -2502,14 +2502,74 @@ pre_insert_copies (void)\n       }\n }\n \n+struct set_data\n+{\n+  rtx insn;\n+  const_rtx set;\n+  int nsets;\n+};\n+\n+/* Increment number of sets and record set in DATA.  */\n+\n+static void\n+record_set_data (rtx dest, const_rtx set, void *data)\n+{\n+  struct set_data *s = (struct set_data *)data;\n+\n+  if (GET_CODE (set) == SET)\n+    {\n+      /* We allow insns having multiple sets, where all but one are\n+\t dead as single set insns.  In the common case only a single\n+\t set is present, so we want to avoid checking for REG_UNUSED\n+\t notes unless necessary.  */\n+      if (s->nsets == 1\n+\t  && find_reg_note (s->insn, REG_UNUSED, SET_DEST (s->set))\n+\t  && !side_effects_p (s->set))\n+\ts->nsets = 0;\n+\n+      if (!s->nsets)\n+\t{\n+\t  /* Record this set.  */\n+\t  s->nsets += 1;\n+\t  s->set = set;\n+\t}\n+      else if (!find_reg_note (s->insn, REG_UNUSED, dest)\n+\t       || side_effects_p (set))\n+\ts->nsets += 1;\n+    }\n+}\n+\n+static const_rtx\n+single_set_gcse (rtx insn)\n+{\n+  struct set_data s;\n+  rtx pattern;\n+  \n+  gcc_assert (INSN_P (insn));\n+\n+  /* Optimize common case.  */\n+  pattern = PATTERN (insn);\n+  if (GET_CODE (pattern) == SET)\n+    return pattern;\n+\n+  s.insn = insn;\n+  s.nsets = 0;\n+  note_stores (pattern, record_set_data, &s);\n+\n+  /* Considered invariant insns have exactly one set.  */\n+  gcc_assert (s.nsets == 1);\n+  return s.set;\n+}\n+\n /* Emit move from SRC to DEST noting the equivalence with expression computed\n    in INSN.  */\n \n static rtx\n gcse_emit_move_after (rtx dest, rtx src, rtx insn)\n {\n   rtx new_rtx;\n-  rtx set = single_set (insn), set2;\n+  const_rtx set = single_set_gcse (insn);\n+  rtx set2;\n   rtx note;\n   rtx eqv = NULL_RTX;\n \n@@ -3369,13 +3429,12 @@ hoist_code (void)\n \t      FOR_EACH_VEC_ELT (occrs_to_hoist, j, occr)\n \t\t{\n \t\t  rtx insn;\n-\t\t  rtx set;\n+\t\t  const_rtx set;\n \n \t\t  gcc_assert (!occr->deleted_p);\n \n \t\t  insn = occr->insn;\n-\t\t  set = single_set (insn);\n-\t\t  gcc_assert (set);\n+\t\t  set = single_set_gcse (insn);\n \n \t\t  /* Create a pseudo-reg to store the result of reaching\n \t\t     expressions into.  Get the mode for the new pseudo\n@@ -3456,10 +3515,8 @@ get_pressure_class_and_nregs (rtx insn, int *nregs)\n {\n   rtx reg;\n   enum reg_class pressure_class;\n-  rtx set = single_set (insn);\n+  const_rtx set = single_set_gcse (insn);\n \n-  /* Considered invariant insns have only one set.  */\n-  gcc_assert (set != NULL_RTX);\n   reg = SET_DEST (set);\n   if (GET_CODE (reg) == SUBREG)\n     reg = SUBREG_REG (reg);"}]}