{"sha": "6615c446157600e6dbe0b716f48e80a64e49807f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjYxNWM0NDYxNTc2MDBlNmRiZTBiNzE2ZjQ4ZTgwYTY0ZTQ5ODA3Zg==", "commit": {"author": {"name": "Jeffrey D. Oldham", "email": "oldham@codesourcery.com", "date": "2004-09-17T21:55:02Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2004-09-17T21:55:02Z"}, "message": "alias.c (find_base_decl): Remove unreachable case '3' block.\n\n2004-09-17  Jeffrey D. Oldham  <oldham@codesourcery.com>\n\t    Zack Weinberg  <zack@codesourcery.com>\n\n\t* alias.c (find_base_decl): Remove unreachable case '3' block.\n\t* expr.c (safe_from_p): Abort if passed a type.\n\t* tree-gimple.c (recalculate_side_effects): Abort if passed\n\tanything other than an expression.\n\t* tree-ssa-pre.c (phi_translate): Return expr immediately if\n\tis_gimple_min_invariant is true for it.  Reorder cases for clarity.\n\tAbort on un-handled tree classes.\n\t(valid_in_set): Likewise.\n\t* tree.c (tree_code_class_strings): New static data.\n\n\t* tree.h (enum tree_code_class): New.\n\t(tree_code_class_strings): Declare.\n\t(TREE_CODE_CLASS_STRING, EXCEPTIONAL_CLASS_P, CONSTANT_CLASS_P)\n\t(REFERENCE_CLASS_P, COMPARISON_CLASS_P, UNARY_CLASS_P, BINARY_CLASS_P)\n\t(STATEMENT_CLASS_P, EXPRESSION_CLASS_P, IS_TYPE_OR_DECL_P): New macros.\n\t(TYPE_P, DECL_P, IS_NON_TYPE_CODE_CLASS, IS_EXPR_CODE_CLASS)\n\t(checking macros, EXPR_LOCATION, SET_EXPR_LOCATION, EXPR_LOCUS): Update.\n\n\t* tree.def, c-common.def, objc/objc-tree.def: Use\n\ttree_code_class enumeration constants instead of code letters.\n\n\t* alias.c, builtins.c, c-common.c, c-format.c, c-lang.c, c-pragma.c\n\t* c-typeck.c, cgraphunit.c, convert.c, dbxout.c, dwarf2out.c\n\t* emit-rtl.c expr.c, fold-const.c, gimplify.c, lambda-code.c\n\t* langhooks.c, langhooks.h, predict.c, print-tree.c, reload1.c, stmt.c\n\t* tree-browser.c, tree-cfg.c, tree-chrec.c, tree-complex.c, tree-dfa.c\n\t* tree-dump.c, tree-eh.c, tree-gimple.c, tree-inline.c, tree-nested.c\n\t* tree-outof-ssa.c, tree-pretty-print.c, tree-sra.c, tree-ssa-ccp.c\n\t* tree-ssa-dce.c, tree-ssa-dom.c, tree-ssa-forwprop.c, tree-ssa-live.c\n\t* tree-ssa-loop-im.c, tree-ssa-loop-ivopts.c, tree-ssa-operands.c\n\t* tree-ssa-phiopt.c, tree-ssa-pre.c, tree-ssa-propagate.c\n\t* tree-ssa.c, tree-ssanames.c, tree-tailcall.c, tree.c, varasm.c\n\t* config/sol2-c.c, config/arm/arm.c, config/i386/winnt.c\n\t* config/pa/pa.c, config/pa/pa.h, config/sh/sh.c, objc/objc-lang.c\n\tUpdate to match.\n\n\t* LANGUAGES: Add note about change.\n\nada:\n\t* ada-tree.def: Use tree_code_class enumeration constants\n\tinstead of code letters.\n\t* ada-tree.h, decl.c, misc.c, trans.c, utils.c, utils2.c:\n\tUpdate for new tree-class enumeration constants.\n\ncp:\n\t* cp-tree.def: Use tree_code_class enumeration constants\n\tinstead of code letters.\n\t* call.c, class.c, cp-gimplify.c, cp-lang.c, cxx-pretty-print.c\n\t* mangle.c, pt.c, semantics.c, tree.c, typeck.c:\n\tUpdate for new tree-class enumeration constants.\n\nfortran:\n\t* f95-lang.c, trans-expr.c, trans.c: Update for new tree-class\n\tenumeration constants.\n\njava:\n\t* java-tree.def: Use tree_code_class enumeration constants\n\tinstead of code letters.\n\t* java-gimplify.c, jcf-write.c, lang.c, parse.y: Update for\n\tnew tree-class enumeration constants.\n\ntreelang:\n\t* treetree.c: Update for new tree-class enumeration constants.\n\nFrom-SVN: r87675", "tree": {"sha": "b888315cd5fd9c69beb9093c01225e1f84fa5bf1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b888315cd5fd9c69beb9093c01225e1f84fa5bf1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6615c446157600e6dbe0b716f48e80a64e49807f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6615c446157600e6dbe0b716f48e80a64e49807f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6615c446157600e6dbe0b716f48e80a64e49807f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6615c446157600e6dbe0b716f48e80a64e49807f/comments", "author": null, "committer": null, "parents": [{"sha": "ade229823345594457019992b95c57221087554e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ade229823345594457019992b95c57221087554e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ade229823345594457019992b95c57221087554e"}], "stats": {"total": 2250, "additions": 1212, "deletions": 1038}, "files": [{"sha": "f61c75b08de9379880c312f0d9cc92cecb8109bc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 52, "deletions": 11, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6615c446157600e6dbe0b716f48e80a64e49807f", "patch": "@@ -1,3 +1,44 @@\n+2004-09-17  Jeffrey D. Oldham  <oldham@codesourcery.com>\n+\t    Zack Weinberg  <zack@codesourcery.com>\n+\n+\t* alias.c (find_base_decl): Remove unreachable case '3' block.\n+\t* expr.c (safe_from_p): Abort if passed a type.\n+\t* tree-gimple.c (recalculate_side_effects): Abort if passed\n+\tanything other than an expression.\n+\t* tree-ssa-pre.c (phi_translate): Return expr immediately if\n+\tis_gimple_min_invariant is true for it.  Reorder cases for clarity.\n+\tAbort on un-handled tree classes.\n+\t(valid_in_set): Likewise.\n+\t* tree.c (tree_code_class_strings): New static data.\n+\n+\t* tree.h (enum tree_code_class): New.\n+\t(tree_code_class_strings): Declare.\n+\t(TREE_CODE_CLASS_STRING, EXCEPTIONAL_CLASS_P, CONSTANT_CLASS_P)\n+\t(REFERENCE_CLASS_P, COMPARISON_CLASS_P, UNARY_CLASS_P, BINARY_CLASS_P)\n+\t(STATEMENT_CLASS_P, EXPRESSION_CLASS_P, IS_TYPE_OR_DECL_P): New macros.\n+\t(TYPE_P, DECL_P, IS_NON_TYPE_CODE_CLASS, IS_EXPR_CODE_CLASS)\n+\t(checking macros, EXPR_LOCATION, SET_EXPR_LOCATION, EXPR_LOCUS): Update.\n+\n+\t* tree.def, c-common.def, objc/objc-tree.def: Use\n+\ttree_code_class enumeration constants instead of code letters.\n+\n+\t* alias.c, builtins.c, c-common.c, c-format.c, c-lang.c, c-pragma.c\n+\t* c-typeck.c, cgraphunit.c, convert.c, dbxout.c, dwarf2out.c\n+\t* emit-rtl.c expr.c, fold-const.c, gimplify.c, lambda-code.c\n+\t* langhooks.c, langhooks.h, predict.c, print-tree.c, reload1.c, stmt.c\n+\t* tree-browser.c, tree-cfg.c, tree-chrec.c, tree-complex.c, tree-dfa.c\n+\t* tree-dump.c, tree-eh.c, tree-gimple.c, tree-inline.c, tree-nested.c\n+\t* tree-outof-ssa.c, tree-pretty-print.c, tree-sra.c, tree-ssa-ccp.c\n+\t* tree-ssa-dce.c, tree-ssa-dom.c, tree-ssa-forwprop.c, tree-ssa-live.c\n+\t* tree-ssa-loop-im.c, tree-ssa-loop-ivopts.c, tree-ssa-operands.c\n+\t* tree-ssa-phiopt.c, tree-ssa-pre.c, tree-ssa-propagate.c\n+\t* tree-ssa.c, tree-ssanames.c, tree-tailcall.c, tree.c, varasm.c\n+\t* config/sol2-c.c, config/arm/arm.c, config/i386/winnt.c\n+\t* config/pa/pa.c, config/pa/pa.h, config/sh/sh.c, objc/objc-lang.c\n+\tUpdate to match.\n+\n+\t* LANGUAGES: Add note about change.\n+\n 2004-09-17  Diego Novillo  <dnovillo@redhat.com>\n \n \tPR tree-optimization/17319\n@@ -33,7 +74,7 @@\n \t(dbxout_init): Include lang number in N_SO  stab.\n \t* dbxout.h (N_SO_AS, N_SO_C, N_SO_ANSI_C, N_SO_CC, N_SO_FORTRAN,\n \tN_SO_PASCAL, N_SO_FORTRAN90, N_SO_OBJC, N_SO_OBJCPLUS): New #define.\n-\t\n+\n 2004-09-17  Diego Novillo  <dnovillo@redhat.com>\n \n \tPR tree-optimization/17273\n@@ -63,7 +104,7 @@\n \n 2004-09-17  Sylvain Pion  <Sylvain.Pion@sophia.inria.fr>\n \n-        * doc/extend.texi: Fix duplicated word.\n+\t* doc/extend.texi: Fix duplicated word.\n \n 2004-09-17  Toon Moene  <toon@moene.indiv.nluug.nl>\n \n@@ -115,7 +156,7 @@\n \n 2004-09-17  Steven Bosscher  <stevenb@suse.de>\n \n-        PR tree-optimization/17513\n+\tPR tree-optimization/17513\n \t* cfgexpand.c (construct_init_block): Clear EDGE_EXECUTABLE\n \tfor successors of the entry block.\n \n@@ -208,11 +249,11 @@\n 2004-09-16  Andrew MacLeod  <amacleod@redhat.com>\n \n \tPR tree-optimization/17517\n-\t* tree-ssa-copyrename.c (copy_rename_partition_coalesce): Don't \n+\t* tree-ssa-copyrename.c (copy_rename_partition_coalesce): Don't\n \tcoalesce same-root variables without checking for abnormal PHI usage.\n \n 2004-09-16  Daniel Berlin  <dberlin@dberlin.org>\n-\t\n+\n \t* cfgloop.h (duplicate_loop):  Add prototype.\n \t* cfgloopmanip.c (duplicate_loop): Make non-static.\n \t* lambda-code.c (perfect_nestify): Factor out test whether\n@@ -229,7 +270,7 @@\n \tloop invariant as well.\n \t(perfect_nestify): new function.\n \t(gcc_loop_to_lambda_loop): New parameters to track lower bounds,\n-\tupper bounds, and steps. \n+\tupper bounds, and steps.\n \tSet outerinductionvar properly.\n \t(gcc_loopnest_to_lambda_loopnest): Add loops and need_perfect\n \tparameters.\n@@ -254,9 +295,9 @@\n 2004-09-16  Sebastian Pop  <pop@cri.ensmp.fr>\n \n \t* tree-loop-linear.c (gather_interchange_stats): Add more comments.\n-\tGather also strides of accessed data.  Pass in the data references \n+\tGather also strides of accessed data.  Pass in the data references\n \tarray.\n-\t(try_interchange_loops): Add a new heuristic for handling the temporal \n+\t(try_interchange_loops): Add a new heuristic for handling the temporal\n \tlocality.  Pass in the data references array.\n \t(linear_transform_loops): Pass the data references array to\n \ttry_interchange_loops.\n@@ -369,7 +410,7 @@\n \n \t* Makefile.in (tree-ssa-dom.o): Depend on tree-ssa-propagate.h.\n \t* tree-ssa-dom.c (cprop_into_stmt): Recompute TREE_INVARIANT\n-        after propagating into an ADDR_EXPR.\n+\tafter propagating into an ADDR_EXPR.\n \n 2004-09-15  Andrew Pinski  <apinski@apple.com>\n \n@@ -587,7 +628,7 @@\n 2004-09-14  Jeff Law  <law@redhat.com>\n \n \t* tree-ssa-dom.c (stmts_to_rescan): Move from a block-local\n-\tto a global varray.  \n+\tto a global varray.\n \t(tree_ssa_dominator_optimize): Allocate stmts_to_rescan.\n \t(dom_opt_initialize_block_local_data): No longer test state\n \tof stmts_to_rescan.\n@@ -824,7 +865,7 @@\n \tPR tree-optimization/17400\n \t* tree-ssa-copyrename.c (copy_rename_partition_coalesce): Don't\n \tcoalesce partitions when one occurs in an abnormal PHI.\n-\t\t\t\t\t\t\t      \n+\n 2004-09-13  Andrew Pinski  <apinski@apple.com>\n \n \t* config/rs6000/darwin.h (ASM_OUTPUT_COMMON): Change variable size's"}, {"sha": "5f20d9c24e9fa9681fb0c016759577e40afbfd29", "filename": "gcc/LANGUAGES", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2FLANGUAGES", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2FLANGUAGES", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FLANGUAGES?ref=6615c446157600e6dbe0b716f48e80a64e49807f", "patch": "@@ -6,6 +6,18 @@ time as we can formally start documenting the interface this file will\n serve as a repository for information on these interface and any incompatable\n changes we've made.\n \n+2004-09-09:\n+  In an effort to decrease execution time, single char tree code\n+  classes were changed to enumerated values.\n+\n+  Old way:\n+\n+    DEFTREECODE (CLASS_METHOD_DECL, \"class_method_decl\", 'd', 0)\n+\n+  New way:\n+\n+    DEFTREECODE (CLASS_METHOD_DECL, \"class_method_decl\", tcc_declaration, 0)\n+\n 2001-02-26:\n   A DECL_INITIAL of NULL_TREE or error_mark_node in a VAR_DECL is no longer\n   taken to signify a tentative definition which should not be emitted until"}, {"sha": "92560a9641c2c4a8cecc8b49e967bd25fb4747d6", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 19, "deletions": 11, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=6615c446157600e6dbe0b716f48e80a64e49807f", "patch": "@@ -1,3 +1,11 @@\n+2004-09-17  Jeffrey D. Oldham  <oldham@codesourcery.com>\n+\t    Zack Weinberg  <zack@codesourcery.com>\n+\n+\t* ada-tree.def: Use tree_code_class enumeration constants\n+\tinstead of code letters.\n+\t* ada-tree.h, decl.c, misc.c, trans.c, utils.c, utils2.c:\n+\tUpdate for new tree-class enumeration constants.\n+\n 2004-09-17  Vincent Celier  <celier@gnat.com>\n \n \t* prj-attr-pm.ads, prj-attr-pm.adb: New files, to split some private\n@@ -456,7 +464,7 @@\n \n 2004-08-25  Nathan Sidwell  <nathan@codesourcery.com>\n \t    Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n-\t\n+\n \t* ada-tree.h (TYPE_RM_SIZE_INT): Use TYPE_LANG_SLOT_1.\n \n 2004-08-25  Nathan Sidwell  <nathan@codesourcery.com>\n@@ -465,7 +473,7 @@\n \t* trans.c (Exception_Handler_to_gnu_sjlj, gnat_to_gnu): Likewise.\n \t* utils.c (init_gigi_decls): Likewise.\n \t* utils2.c (build_call_raise, build_allocator): Likewise.\n-\t\n+\n 2004-08-24  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* utils.c (gnat_init_decl_processing): Adjust\n@@ -589,7 +597,7 @@\n \tGNAT.Sockets.Thin.Is_Socket_In_Set to account for new specification\n \tand test explicitly for non-zero return value.\n \n-\t* g-socthi-vms.ads, g-socthi-mingw.ads, g-socthi-vxworks.ads: \n+\t* g-socthi-vms.ads, g-socthi-mingw.ads, g-socthi-vxworks.ads:\n \t(Is_Socket_In_Set): Declare imported function as returning C.int, to\n \tavoid using a derived boolean type.\n \n@@ -1264,7 +1272,7 @@\n \t(gnat_to_gnu, case N_Compilation_Unit): Just handle nested case here.\n \t(add_stmt): Force walking of sizes and DECL_INITIAL for DECL_EXPR.\n \t(mark_visited): Don't mark dummy type.\n-\t(tree_transform <N_Procedure_Call_Statement>): Unless this is an In\t\n+\t(tree_transform <N_Procedure_Call_Statement>): Unless this is an In\n \tparameter, we must remove any LJM building from GNU_NAME.\n \t(gnat_to_gnu, case N_String_Literal): Fill in indices in CONSTRUCTOR.\n \t(pos_to_constructor): Use int_const_binop.\n@@ -1471,7 +1479,7 @@\n \t(gnat_to_gnu): If statement and not in procedure, go into elab proc.\n \tDelete calls to add_decl_expr; add arg to create_*_decl.\n \t(gnat_to_gnu, case N_Loop): Recalculate side effects on COND_EXPR.\n-\t(gnat_to_gnu, case N_Subprogram_Body): Move some code to \n+\t(gnat_to_gnu, case N_Subprogram_Body): Move some code to\n \tbegin_subprog_body and call it.\n \tDon't push and pop ggc context.\n \t(gnat_to_gnu, case N_Compilation_Unit): Rework to support elab proc.\n@@ -1497,7 +1505,7 @@\n \t(function_nesting_depth): Deleted.\n \t(begin_subprog_body): Delete obsolete code.\n \t* utils2.c (build_call_alloc_dealloc): Add new arg to create_var_decl.\n-\t\n+\n 2004-06-28  Robert Dewar  <dewar@gnat.com>\n \n \t* mlib-tgt-tru64.adb, mlib-tgt-aix.adb, mlib-tgt-irix.adb,\n@@ -1629,8 +1637,8 @@\n \tLib_Address and Relocatable.\n \t(Default_DLL_Address): Removed.\n \n-\t* mlib-tgt-tru64.adb, mlib-tgt-aix.adb, mlib-tgt-irix.adb, \n-\tmlib-tgt-hpux.adb, mlib-tgt-linux.adb, mlib-tgt-solaris.adb, \n+\t* mlib-tgt-tru64.adb, mlib-tgt-aix.adb, mlib-tgt-irix.adb,\n+\tmlib-tgt-hpux.adb, mlib-tgt-linux.adb, mlib-tgt-solaris.adb,\n \tmlib-tgt-vms-alpha.adb, mlib-tgt-vms-ia64.adb, mlib-tgt-vxworks.adb:\n \t(Build_Dynamic_Library): Remove parameter Lib_Address and Relocatable.\n \t(Default_DLL_Address): Removed.\n@@ -1827,7 +1835,7 @@\n \t(Compile_Sources.Compile): Add switch -gnatez as the last option\n \t(Display): Never display -gnatez\n \n-\t* Makefile.generic: \n+\t* Makefile.generic:\n \tWhen using $(MAIN_OBJECT), always use $(OBJ_DIR)/$(MAIN_OBJECT)\n \n \t* gnatcmd.adb (Check_Project): New function\n@@ -2402,7 +2410,7 @@\n \topt.adb, par.adb, opt.ads, par-ch11.adb, par-ch3.adb, par-ch4.adb,\n \tpar-ch5.adb, par-ch6.adb, par-ch8.adb, par-ch9.adb, par-prag.adb,\n \tpar-util.adb, scng.adb, sem_aggr.adb, sem_attr.adb, sem_cat.adb,\n-        sem_ch10.adb, sem_ch10.adb, sem_ch11.adb, sem_ch12.adb, sem_ch2.adb,\n+\tsem_ch10.adb, sem_ch10.adb, sem_ch11.adb, sem_ch12.adb, sem_ch2.adb,\n \tsem_ch3.adb, sem_ch3.ads, sem_ch4.adb, sem_ch5.adb, sem_ch6.adb,\n \tsem_ch7.adb, sem_ch8.adb, sem_ch9.adb, sem_eval.adb, sem_prag.adb,\n \tsem_res.adb, sem_type.adb, sem_util.adb, sinfo.ads, snames.adb,\n@@ -3027,7 +3035,7 @@\n \n \tRenaming of target specific files for clarity\n \n-        * Makefile.in: Rename GNAT target specific files.\n+\t* Makefile.in: Rename GNAT target specific files.\n \n \t* 31soccon.ads, 31soliop.ads 35soccon.ads, 3asoccon.ads,\n \t3bsoccon.ads, 3gsoccon.ads, 3hsoccon.ads, 3psoccon.ads,"}, {"sha": "25ea95ef6ce5176f02e82a995608aff93d2a0ee6", "filename": "gcc/ada/ada-tree.def", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Fada%2Fada-tree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Fada%2Fada-tree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fada-tree.def?ref=6615c446157600e6dbe0b716f48e80a64e49807f", "patch": "@@ -6,7 +6,7 @@\n  *                                                                          *\n  *                              Specification                               *\n  *                                                                          *\n- *          Copyright (C) 1992-2003 Free Software Foundation, Inc.          *\n+ *          Copyright (C) 1992-2004 Free Software Foundation, Inc.          *\n  *                                                                          *\n  * GNAT is free software;  you can  redistribute it  and/or modify it under *\n  * terms of the  GNU General Public License as published  by the Free Soft- *\n@@ -28,23 +28,24 @@\n    to GCC. TREE_TYPE is the type of the fat pointer and TYPE_OBJECT_RECORD_TYPE\n    is the type of a record containing the template and data.  */\n \n-DEFTREECODE (UNCONSTRAINED_ARRAY_TYPE, \"unconstrained_array_type\", 't', 0)\n+DEFTREECODE (UNCONSTRAINED_ARRAY_TYPE, \"unconstrained_array_type\", tcc_type, 0)\n \n /* A reference to an unconstrained array.  This node only exists as an\n    intermediate node during the translation of a GNAT tree to a GCC tree;\n    it is never passed to GCC.  The only field used is operand 0, which\n    is the fat pointer object.  */\n \n-DEFTREECODE (UNCONSTRAINED_ARRAY_REF, \"unconstrained_array_ref\", 'r', 1)\n+DEFTREECODE (UNCONSTRAINED_ARRAY_REF, \"unconstrained_array_ref\",\n+\t    tcc_reference, 1)\n \n /* An expression that returns an RTL suitable for its type.  Operand 0\n    is an expression to be evaluated for side effects only.  */\n-DEFTREECODE (NULL_EXPR, \"null_expr\", 'e', 1)\n+DEFTREECODE (NULL_EXPR, \"null_expr\", tcc_expression, 1)\n \n /* Same as ADDR_EXPR, except that if the operand represents a bit field,\n    return the address of the byte containing the bit.  This is used\n    for the 'Address attribute and never shows up in the tree.  */\n-DEFTREECODE (ATTR_ADDR_EXPR, \"attr_addr_expr\", 'r', 1)\n+DEFTREECODE (ATTR_ADDR_EXPR, \"attr_addr_expr\", tcc_reference, 1)\n \n /* Here are the tree codes for the statement types known to Ada.  These\n    must be at the end of this file to allow IS_ADA_STMT to work.  */\n@@ -53,32 +54,32 @@ DEFTREECODE (ATTR_ADDR_EXPR, \"attr_addr_expr\", 'r', 1)\n    makes this tree node, whose operand is a statement.  The latter inserts\n    the actual statements into this node.  Gimplification consists of\n    just returning the inner statement.  */\n-DEFTREECODE (STMT_STMT, \"stmt_stmt\", 's', 1)\n+DEFTREECODE (STMT_STMT, \"stmt_stmt\", tcc_statement, 1)\n \n /* A loop.  LOOP_STMT_TOP_COND and LOOP_STMT_BOT_COND are the tests to exit a\n    loop at the top and bottom, respectively.  LOOP_STMT_UPDATE is the statement\n    to update the loop iterator at the continue point.  LOOP_STMT_BODY are the\n    statements in the body of the loop.  LOOP_STMT_LABEL points to the LABEL_DECL\n    of the end label of the loop.  */\n-DEFTREECODE (LOOP_STMT, \"loop_stmt\", 's', 5)\n+DEFTREECODE (LOOP_STMT, \"loop_stmt\", tcc_statement, 5)\n \n /* Conditionally exit a loop.  EXIT_STMT_COND is the condition, which, if\n    true, will cause the loop to be exited.  If no condition is specified,\n    the loop is unconditionally exited.  EXIT_STMT_LABEL is the end label\n    corresponding to the loop to exit.  */\n-DEFTREECODE (EXIT_STMT, \"exit_stmt\", 's', 2)\n+DEFTREECODE (EXIT_STMT, \"exit_stmt\", tcc_statement, 2)\n \n /* A exception region.  REGION_STMT_BODY is the statement to be executed\n    inside the region.  REGION_STMT_HANDLE is a statement that represents\n    the exception handlers (usually a BLOCK_STMT of HANDLE_STMTs).\n    REGION_STMT_BLOCK is the BLOCK node for the declarative region, if any.  */\n-DEFTREECODE (REGION_STMT, \"region_stmt\", 's', 3)\n+DEFTREECODE (REGION_STMT, \"region_stmt\", tcc_statement, 3)\n \n /* An exception handler.  HANDLER_STMT_ARG is the value to pass to \n    expand_start_catch, HANDLER_STMT_LIST is the list of statements for the\n    handler itself, and HANDLER_STMT_BLOCK is the BLOCK node for this\n    binding. */\n-DEFTREECODE (HANDLER_STMT, \"handler_stmt\", 's', 3)\n+DEFTREECODE (HANDLER_STMT, \"handler_stmt\", tcc_statement, 3)\n \n /* A statement that emits a USE for its single operand.  */\n-DEFTREECODE (USE_STMT, \"use_expr\", 's', 1)\n+DEFTREECODE (USE_STMT, \"use_expr\", tcc_statement, 1)"}, {"sha": "7d4a756a725655a3f75e992bd888b83ebb2352e8", "filename": "gcc/ada/ada-tree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Fada%2Fada-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Fada%2Fada-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fada-tree.h?ref=6615c446157600e6dbe0b716f48e80a64e49807f", "patch": "@@ -273,7 +273,7 @@ struct lang_type GTY(()) {tree t; };\n /* Define fields and macros for statements.\n \n    Start by defining which tree codes are used for statements.  */\n-#define IS_STMT(NODE)\t\t(TREE_CODE_CLASS (TREE_CODE (NODE)) == 's')\n+#define IS_STMT(NODE)\t\t(STATEMENT_CLASS_P (NODE))\n #define IS_ADA_STMT(NODE)\t(IS_STMT (NODE)\t\t\t\t\\\n \t\t\t\t && TREE_CODE (NODE) >= STMT_STMT)\n "}, {"sha": "08b5176afde134c750ec4bdaa92d11f319659339", "filename": "gcc/ada/decl.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Fada%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Fada%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdecl.c?ref=6615c446157600e6dbe0b716f48e80a64e49807f", "patch": "@@ -761,7 +761,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t       just use that declaration or reference as this entity unless\n \t       the latter has to be materialized.  */\n \t    else if ((DECL_P (gnu_expr)\n-\t\t      || TREE_CODE_CLASS (TREE_CODE (gnu_expr)) == 'r')\n+\t\t      || (REFERENCE_CLASS_P (gnu_expr) == tcc_reference))\n \t\t     && !Materialize_Entity (gnat_entity)\n \t\t     && (!global_bindings_p ()\n \t\t\t || (staticp (gnu_expr)\n@@ -4553,7 +4553,7 @@ elaborate_expression_1 (Node_Id gnat_expr, Entity_Id gnat_entity,\n      rely here on the fact that an expression cannot contain both the\n      discriminant and some other variable.  */\n \n-  expr_variable = (TREE_CODE_CLASS (TREE_CODE (gnu_expr)) != 'c'\n+  expr_variable = (!CONSTANT_CLASS_P (gnu_expr)\n \t\t   && !(TREE_CODE (gnu_inner_expr) == VAR_DECL\n \t\t\t&& TREE_READONLY (gnu_inner_expr))\n \t\t   && !CONTAINS_PLACEHOLDER_P (gnu_expr));\n@@ -5565,8 +5565,7 @@ annotate_value (tree gnu_size)\n     return No_Uint;\n \n   /* See if we've already saved the value for this node.  */\n-  if (IS_EXPR_CODE_CLASS (TREE_CODE_CLASS (TREE_CODE (gnu_size)))\n-      && TREE_COMPLEXITY (gnu_size))\n+  if (EXPR_P (gnu_size) && TREE_COMPLEXITY (gnu_size))\n     return (Node_Ref_Or_Val) TREE_COMPLEXITY (gnu_size);\n \n   /* If we do not return inside this switch, TCODE will be set to the"}, {"sha": "d1631cdb4632247e7b50fa44f3f3be6ae82b9048", "filename": "gcc/ada/misc.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Fada%2Fmisc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Fada%2Fmisc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmisc.c?ref=6615c446157600e6dbe0b716f48e80a64e49807f", "patch": "@@ -173,9 +173,9 @@ const struct lang_hooks lang_hooks = LANG_HOOKS_INITIALIZER;\n \n #define DEFTREECODE(SYM, NAME, TYPE, LENGTH) TYPE,\n \n-const char tree_code_type[] = {\n+const enum tree_code_class tree_code_type[] = {\n #include \"tree.def\"\n-  'x',\n+  tcc_exceptional,\n #include \"ada-tree.def\"\n };\n #undef DEFTREECODE"}, {"sha": "4defe553e628f50b28509662d7b27cecddcd7104", "filename": "gcc/ada/trans.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Fada%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Fada%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftrans.c?ref=6615c446157600e6dbe0b716f48e80a64e49807f", "patch": "@@ -3219,7 +3219,7 @@ gnat_to_gnu (Node_Id gnat_node)\n \t/* If this is a comparison operator, convert any references to\n \t   an unconstrained array value into a reference to the\n \t   actual array.  */\n-\tif (TREE_CODE_CLASS (code) == '<')\n+\tif (TREE_CODE_CLASS (code) == tcc_comparison)\n \t  {\n \t    gnu_lhs = maybe_unconstrained_array (gnu_lhs);\n \t    gnu_rhs = maybe_unconstrained_array (gnu_rhs);\n@@ -4035,7 +4035,7 @@ gnat_to_gnu (Node_Id gnat_node)\n   /* Set the location information into the result.  If we're supposed to\n      return something of void_type, it means we have something we're\n      elaborating for effect, so just return.  */\n-  if (IS_EXPR_CODE_CLASS (TREE_CODE_CLASS (TREE_CODE (gnu_result))))\n+  if (EXPR_P (gnu_result))\n     annotate_with_node (gnu_result, gnat_node);\n \n   if (TREE_CODE (gnu_result_type) == VOID_TYPE)\n@@ -5712,13 +5712,13 @@ gnat_stabilize_reference_1 (tree e, bool force)\n \n   switch (TREE_CODE_CLASS (code))\n     {\n-    case 'x':\n-    case 't':\n-    case 'd':\n-    case '<':\n-    case 's':\n-    case 'e':\n-    case 'r':\n+    case tcc_exceptional:\n+    case tcc_type:\n+    case tcc_declaration:\n+    case tcc_comparison:\n+    case tcc_statement:\n+    case tcc_expression:\n+    case tcc_reference:\n       /* If this is a COMPONENT_REF of a fat pointer, save the entire\n \t fat pointer.  This may be more efficient, but will also allow\n \t us to more easily find the match for the PLACEHOLDER_EXPR.  */\n@@ -5734,20 +5734,20 @@ gnat_stabilize_reference_1 (tree e, bool force)\n \treturn e;\n       break;\n \n-    case 'c':\n+    case tcc_constant:\n       /* Constants need no processing.  In fact, we should never reach\n \t here.  */\n       return e;\n \n-    case '2':\n+    case tcc_binary:\n       /* Recursively stabilize each operand.  */\n       result = build2 (code, type,\n \t\t       gnat_stabilize_reference_1 (TREE_OPERAND (e, 0), force),\n \t\t       gnat_stabilize_reference_1 (TREE_OPERAND (e, 1),\n \t\t\t\t\t\t   force));\n       break;\n \n-    case '1':\n+    case tcc_unary:\n       /* Recursively stabilize each operand.  */\n       result = build1 (code, type,\n \t\t       gnat_stabilize_reference_1 (TREE_OPERAND (e, 0),"}, {"sha": "1a5afb3d9b1150d687103261cd2bf24cd61cbd79", "filename": "gcc/ada/utils.c", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Fada%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Fada%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Futils.c?ref=6615c446157600e6dbe0b716f48e80a64e49807f", "patch": "@@ -2009,19 +2009,19 @@ max_size (tree exp, bool max_p)\n \n   switch (TREE_CODE_CLASS (code))\n     {\n-    case 'd':\n-    case 'c':\n+    case tcc_declaration:\n+    case tcc_constant:\n       return exp;\n \n-    case 'x':\n+    case tcc_exceptional:\n       if (code == TREE_LIST)\n \treturn tree_cons (TREE_PURPOSE (exp),\n \t\t\t  max_size (TREE_VALUE (exp), max_p),\n \t\t\t  TREE_CHAIN (exp)\n \t\t\t  ? max_size (TREE_CHAIN (exp), max_p) : NULL_TREE);\n       break;\n \n-    case 'r':\n+    case tcc_reference:\n       /* If this contains a PLACEHOLDER_EXPR, it is the thing we want to\n \t modify.  Otherwise, we treat it like a variable.  */\n       if (!CONTAINS_PLACEHOLDER_P (exp))\n@@ -2031,12 +2031,12 @@ max_size (tree exp, bool max_p)\n       return\n \tmax_size (max_p ? TYPE_MAX_VALUE (type) : TYPE_MIN_VALUE (type), true);\n \n-    case '<':\n+    case tcc_comparison:\n       return max_p ? size_one_node : size_zero_node;\n \n-    case '1':\n-    case '2':\n-    case 'e':\n+    case tcc_unary:\n+    case tcc_binary:\n+    case tcc_expression:\n       switch (TREE_CODE_LENGTH (code))\n \t{\n \tcase 1:\n@@ -2087,6 +2087,10 @@ max_size (tree exp, bool max_p)\n \t    return build3 (CALL_EXPR, type, TREE_OPERAND (exp, 0),\n \t\t\t   max_size (TREE_OPERAND (exp, 1), max_p), NULL);\n \t}\n+\n+      /* Other tree classes cannot happen.  */\n+    default:\n+      break;\n     }\n \n   abort ();"}, {"sha": "4611fc8e904b8cba2992421f4e0bd6490e8a8013", "filename": "gcc/ada/utils2.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Fada%2Futils2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Fada%2Futils2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Futils2.c?ref=6615c446157600e6dbe0b716f48e80a64e49807f", "patch": "@@ -290,17 +290,18 @@ contains_null_expr (tree exp)\n \n   switch (TREE_CODE_CLASS (TREE_CODE (exp)))\n     {\n-    case '1':\n+    case tcc_unary:\n       return contains_null_expr (TREE_OPERAND (exp, 0));\n \n-    case '<':  case '2':\n+    case tcc_comparison:\n+    case tcc_binary:\n       tem = contains_null_expr (TREE_OPERAND (exp, 0));\n       if (tem)\n \treturn tem;\n \n       return contains_null_expr (TREE_OPERAND (exp, 1));\n \n-    case 'e':\n+    case tcc_expression:\n       switch (TREE_CODE (exp))\n \t{\n \tcase SAVE_EXPR:"}, {"sha": "cc74ee8a18703ae21a37dcc8205d577bd3809f97", "filename": "gcc/alias.c", "status": "modified", "additions": 4, "deletions": 19, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=6615c446157600e6dbe0b716f48e80a64e49807f", "patch": "@@ -342,24 +342,24 @@ objects_must_conflict_p (tree t1, tree t2)\n static tree\n find_base_decl (tree t)\n {\n-  tree d0, d1, d2;\n+  tree d0, d1;\n \n   if (t == 0 || t == error_mark_node || ! POINTER_TYPE_P (TREE_TYPE (t)))\n     return 0;\n \n   /* If this is a declaration, return it.  */\n-  if (TREE_CODE_CLASS (TREE_CODE (t)) == 'd')\n+  if (DECL_P (t))\n     return t;\n \n   /* Handle general expressions.  It would be nice to deal with\n      COMPONENT_REFs here.  If we could tell that `a' and `b' were the\n      same, then `a->f' and `b->f' are also the same.  */\n   switch (TREE_CODE_CLASS (TREE_CODE (t)))\n     {\n-    case '1':\n+    case tcc_unary:\n       return find_base_decl (TREE_OPERAND (t, 0));\n \n-    case '2':\n+    case tcc_binary:\n       /* Return 0 if found in neither or both are the same.  */\n       d0 = find_base_decl (TREE_OPERAND (t, 0));\n       d1 = find_base_decl (TREE_OPERAND (t, 1));\n@@ -372,21 +372,6 @@ find_base_decl (tree t)\n       else\n \treturn 0;\n \n-    case '3':\n-      d0 = find_base_decl (TREE_OPERAND (t, 0));\n-      d1 = find_base_decl (TREE_OPERAND (t, 1));\n-      d2 = find_base_decl (TREE_OPERAND (t, 2));\n-\n-      /* Set any nonzero values from the last, then from the first.  */\n-      if (d1 == 0) d1 = d2;\n-      if (d0 == 0) d0 = d1;\n-      if (d1 == 0) d1 = d0;\n-      if (d2 == 0) d2 = d1;\n-\n-      /* At this point all are nonzero or all are zero.  If all three are the\n-\t same, return it.  Otherwise, return zero.  */\n-      return (d0 == d1 && d1 == d2) ? d0 : 0;\n-\n     default:\n       return 0;\n     }"}, {"sha": "8502087cc77e3658e8661403da854cad93b3fbcb", "filename": "gcc/builtins.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=6615c446157600e6dbe0b716f48e80a64e49807f", "patch": "@@ -248,7 +248,7 @@ get_pointer_alignment (tree exp, unsigned int max_align)\n \t  else if (DECL_P (exp))\n \t    align = DECL_ALIGN (exp);\n #ifdef CONSTANT_ALIGNMENT\n-\t  else if (TREE_CODE_CLASS (TREE_CODE (exp)) == 'c')\n+\t  else if (CONSTANT_CLASS_P (exp))\n \t    align = CONSTANT_ALIGNMENT (exp, align);\n #endif\n \t  return MIN (align, max_align);\n@@ -6205,7 +6205,7 @@ fold_builtin_constant_p (tree arglist)\n   STRIP_NOPS (arglist);\n \n   /* If we know this is a constant, emit the constant of one.  */\n-  if (TREE_CODE_CLASS (TREE_CODE (arglist)) == 'c'\n+  if (CONSTANT_CLASS_P (arglist)\n       || (TREE_CODE (arglist) == CONSTRUCTOR\n \t  && TREE_CONSTANT (arglist))\n       || (TREE_CODE (arglist) == ADDR_EXPR\n@@ -8513,7 +8513,7 @@ fold_builtin (tree exp, bool ignore)\n   if (exp)\n     {\n       /* ??? Don't clobber shared nodes such as integer_zero_node.  */\n-      if (TREE_CODE_CLASS (TREE_CODE (exp)) == 'c')\n+      if (CONSTANT_CLASS_P (exp))\n \texp = build1 (NOP_EXPR, TREE_TYPE (exp), exp);\n       TREE_NO_WARNING (exp) = 1;\n     }"}, {"sha": "2b8ad801e9a788cd254b9b99bd8eed51f7baf372", "filename": "gcc/c-common.c", "status": "modified", "additions": 26, "deletions": 33, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=6615c446157600e6dbe0b716f48e80a64e49807f", "patch": "@@ -1196,7 +1196,7 @@ verify_tree (tree x, struct tlist **pbefore_sp, struct tlist **pno_sp,\n {\n   struct tlist *tmp_before, *tmp_nosp, *tmp_list2, *tmp_list3;\n   enum tree_code code;\n-  char cl;\n+  enum tree_code_class cl;\n \n   /* X may be NULL if it is the operand of an empty statement expression\n      ({ }).  */\n@@ -1345,39 +1345,32 @@ verify_tree (tree x, struct tlist **pbefore_sp, struct tlist **pno_sp,\n \tadd_tlist (pno_sp, t->cache_after_sp, NULL_TREE, 1);\n \treturn;\n       }\n-    default:\n-      break;\n-    }\n \n-  if (cl == '1')\n-    {\n-      if (first_rtl_op (code) == 0)\n-\treturn;\n-      x = TREE_OPERAND (x, 0);\n-      writer = 0;\n-      goto restart;\n-    }\n-\n-  switch (cl)\n-    {\n-    case 'r':\n-    case '<':\n-    case '2':\n-    case 'e':\n-    case 's':\n-    case 'x':\n-      {\n-\tint lp;\n-\tint max = first_rtl_op (TREE_CODE (x));\n-\tfor (lp = 0; lp < max; lp++)\n-\t  {\n-\t    tmp_before = tmp_nosp = 0;\n-\t    verify_tree (TREE_OPERAND (x, lp), &tmp_before, &tmp_nosp, NULL_TREE);\n-\t    merge_tlist (&tmp_nosp, tmp_before, 0);\n-\t    add_tlist (pno_sp, tmp_nosp, NULL_TREE, 0);\n-\t  }\n-\tbreak;\n-      }\n+    default:\n+      /* For other expressions, simply recurse on their operands.\n+         Manual tail recursion for unary expressions.\n+\t Other non-expressions need not be processed.  */\n+      if (cl == tcc_unary)\n+\t{\n+\t  if (first_rtl_op (code) == 0)\n+\t    return;\n+\t  x = TREE_OPERAND (x, 0);\n+\t  writer = 0;\n+\t  goto restart;\n+\t}\n+      else if (IS_EXPR_CODE_CLASS (cl))\n+\t{\n+\t  int lp;\n+\t  int max = first_rtl_op (TREE_CODE (x));\n+\t  for (lp = 0; lp < max; lp++)\n+\t    {\n+\t      tmp_before = tmp_nosp = 0;\n+\t      verify_tree (TREE_OPERAND (x, lp), &tmp_before, &tmp_nosp, 0);\n+\t      merge_tlist (&tmp_nosp, tmp_before, 0);\n+\t      add_tlist (pno_sp, tmp_nosp, NULL_TREE, 0);\n+\t    }\n+\t}\n+      return;\n     }\n }\n "}, {"sha": "adca88f4700535358030c3ffb8bab637029e0f50", "filename": "gcc/c-common.def", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Fc-common.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Fc-common.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.def?ref=6615c446157600e6dbe0b716f48e80a64e49807f", "patch": "@@ -25,46 +25,46 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n /* Tree nodes relevant to both C and C++. These were originally in\n cp-tree.def in the cp subdir.  */\n \n-DEFTREECODE (SIZEOF_EXPR, \"sizeof_expr\", '1', 1)\n-DEFTREECODE (ARROW_EXPR, \"arrow_expr\", 'e', 1)\n-DEFTREECODE (ALIGNOF_EXPR, \"alignof_expr\", '1', 1)\n+DEFTREECODE (SIZEOF_EXPR, \"sizeof_expr\", tcc_unary, 1)\n+DEFTREECODE (ARROW_EXPR, \"arrow_expr\", tcc_expression, 1)\n+DEFTREECODE (ALIGNOF_EXPR, \"alignof_expr\", tcc_unary, 1)\n \n /* Used to represent an expression statement.  Use `EXPR_STMT_EXPR' to\n    obtain the expression.  */\n-DEFTREECODE (EXPR_STMT, \"expr_stmt\", 'e', 1)\n+DEFTREECODE (EXPR_STMT, \"expr_stmt\", tcc_expression, 1)\n \n /* Used to represent a `for' statement. The operands are\n    FOR_INIT_STMT, FOR_COND, FOR_EXPR, and FOR_BODY, respectively.  */\n-DEFTREECODE (FOR_STMT, \"for_stmt\", 'e', 4)\n+DEFTREECODE (FOR_STMT, \"for_stmt\", tcc_expression, 4)\n \n /* Used to represent a 'while' statement. The operands are WHILE_COND\n    and WHILE_BODY, respectively.  */\n-DEFTREECODE (WHILE_STMT, \"while_stmt\", 'e', 2)\n+DEFTREECODE (WHILE_STMT, \"while_stmt\", tcc_expression, 2)\n \n /* Used to represent a 'do' statement. The operands are DO_BODY and\n    DO_COND, respectively.  */\n-DEFTREECODE (DO_STMT, \"do_stmt\", 'e', 2)\n+DEFTREECODE (DO_STMT, \"do_stmt\", tcc_expression, 2)\n \n /* Used to represent a 'break' statement.  */\n-DEFTREECODE (BREAK_STMT, \"break_stmt\", 'e', 0)\n+DEFTREECODE (BREAK_STMT, \"break_stmt\", tcc_expression, 0)\n \n /* Used to represent a 'continue' statement.  */\n-DEFTREECODE (CONTINUE_STMT, \"continue_stmt\", 'e', 0)\n+DEFTREECODE (CONTINUE_STMT, \"continue_stmt\", tcc_expression, 0)\n \n /* Used to represent a 'switch' statement. The operands are\n    SWITCH_COND, SWITCH_BODY and SWITCH_TYPE, respectively.  */\n-DEFTREECODE (SWITCH_STMT, \"switch_stmt\", 'e', 3)\n+DEFTREECODE (SWITCH_STMT, \"switch_stmt\", tcc_expression, 3)\n \n /* A STMT_EXPR represents a statement-expression.  The\n    STMT_EXPR_STMT is the statement given by the expression.  */\n-DEFTREECODE (STMT_EXPR, \"stmt_expr\", 'e', 1)\n+DEFTREECODE (STMT_EXPR, \"stmt_expr\", tcc_expression, 1)\n \n /* A COMPOUND_LITERAL_EXPR represents a C99 compound literal.  The\n    COMPOUND_LITERAL_EXPR_DECL_STMT is the a DECL_STMT containing the decl\n    for the anonymous object represented by the COMPOUND_LITERAL;\n    the DECL_INITIAL of that decl is the CONSTRUCTOR that initializes\n    the compound literal.  */\n-DEFTREECODE (COMPOUND_LITERAL_EXPR, \"compound_literal_expr\", 'e', 1)\n+DEFTREECODE (COMPOUND_LITERAL_EXPR, \"compound_literal_expr\", tcc_expression, 1)\n \n /*\n Local variables:"}, {"sha": "341eb59c7c2fa1981e75c8111b660f6c005a1e78", "filename": "gcc/c-format.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Fc-format.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Fc-format.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-format.c?ref=6615c446157600e6dbe0b716f48e80a64e49807f", "patch": "@@ -2094,7 +2094,7 @@ check_format_types (format_wanted_type *types, const char *format_start,\n \t\t  && i == 0\n \t\t  && (TYPE_READONLY (cur_type)\n \t\t      || (cur_param != 0\n-\t\t\t  && (TREE_CODE_CLASS (TREE_CODE (cur_param)) == 'c'\n+\t\t\t  && (CONSTANT_CLASS_P (cur_param)\n \t\t\t      || (DECL_P (cur_param)\n \t\t\t\t  && TREE_READONLY (cur_param))))))\n \t\twarning (\"writing into constant object (arg %d)\", arg_num);"}, {"sha": "ca0173e333aac3cb2e0abf34c58c2160d2cbf64f", "filename": "gcc/c-lang.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Fc-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Fc-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-lang.c?ref=6615c446157600e6dbe0b716f48e80a64e49807f", "patch": "@@ -54,9 +54,9 @@ const struct lang_hooks lang_hooks = LANG_HOOKS_INITIALIZER;\n \n #define DEFTREECODE(SYM, NAME, TYPE, LENGTH) TYPE,\n \n-const char tree_code_type[] = {\n+const enum tree_code_class tree_code_type[] = {\n #include \"tree.def\"\n-  'x',\n+  tcc_exceptional,\n #include \"c-common.def\"\n };\n #undef DEFTREECODE"}, {"sha": "fd2f7f714ad7afebbd787b46b033dced8e3dabd1", "filename": "gcc/c-pragma.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Fc-pragma.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Fc-pragma.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-pragma.c?ref=6615c446157600e6dbe0b716f48e80a64e49807f", "patch": "@@ -316,7 +316,7 @@ handle_pragma_weak (cpp_reader * ARG_UNUSED (dummy))\n     warning (\"junk at end of #pragma weak\");\n \n   decl = identifier_global_value (name);\n-  if (decl && TREE_CODE_CLASS (TREE_CODE (decl)) == 'd')\n+  if (decl && DECL_P (decl))\n     {\n       apply_pragma_weak (decl, value);\n       if (value)"}, {"sha": "5ec00aa4250eca08c386afd619d0ec6d3fb87b1c", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 26, "deletions": 17, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=6615c446157600e6dbe0b716f48e80a64e49807f", "patch": "@@ -744,18 +744,24 @@ same_translation_unit_p (tree t1, tree t2)\n   while (t1 && TREE_CODE (t1) != TRANSLATION_UNIT_DECL)\n     switch (TREE_CODE_CLASS (TREE_CODE (t1)))\n       {\n-      case 'd': t1 = DECL_CONTEXT (t1); break;\n-      case 't': t1 = TYPE_CONTEXT (t1); break;\n-      case 'x': t1 = BLOCK_SUPERCONTEXT (t1); break;  /* assume block */\n+      case tcc_declaration:\n+\tt1 = DECL_CONTEXT (t1); break;\n+      case tcc_type:\n+\tt1 = TYPE_CONTEXT (t1); break;\n+      case tcc_exceptional:\n+\tt1 = BLOCK_SUPERCONTEXT (t1); break;  /* assume block */\n       default: gcc_unreachable ();\n       }\n \n   while (t2 && TREE_CODE (t2) != TRANSLATION_UNIT_DECL)\n     switch (TREE_CODE_CLASS (TREE_CODE (t2)))\n       {\n-      case 'd': t2 = DECL_CONTEXT (t2); break;\n-      case 't': t2 = TYPE_CONTEXT (t2); break;\n-      case 'x': t2 = BLOCK_SUPERCONTEXT (t2); break;  /* assume block */\n+      case tcc_declaration:\n+\tt2 = DECL_CONTEXT (t2); break;\n+      case tcc_type:\n+\tt2 = TYPE_CONTEXT (t2); break;\n+      case tcc_exceptional:\n+\tt2 = BLOCK_SUPERCONTEXT (t2); break;  /* assume block */\n       default: gcc_unreachable ();\n       }\n \n@@ -1200,7 +1206,7 @@ default_function_array_conversion (tree exp)\n       int volatilep = 0;\n       int lvalue_array_p;\n \n-      if (TREE_CODE_CLASS (TREE_CODE (exp)) == 'r' || DECL_P (exp))\n+      if (REFERENCE_CLASS_P (exp) || DECL_P (exp))\n \t{\n \t  constp = TREE_READONLY (exp);\n \t  volatilep = TREE_THIS_VOLATILE (exp);\n@@ -2232,7 +2238,8 @@ parser_build_binary_op (enum tree_code code, struct c_expr arg1,\n \t      || code2 == PLUS_EXPR || code2 == MINUS_EXPR)\n \t    warning (\"suggest parentheses around arithmetic in operand of |\");\n \t  /* Check cases like x|y==z */\n-\t  if (TREE_CODE_CLASS (code1) == '<' || TREE_CODE_CLASS (code2) == '<')\n+\t  if (TREE_CODE_CLASS (code1) == tcc_comparison\n+\t      || TREE_CODE_CLASS (code2) == tcc_comparison)\n \t    warning (\"suggest parentheses around comparison in operand of |\");\n \t}\n \n@@ -2244,7 +2251,8 @@ parser_build_binary_op (enum tree_code code, struct c_expr arg1,\n \t      || code2 == PLUS_EXPR || code2 == MINUS_EXPR)\n \t    warning (\"suggest parentheses around arithmetic in operand of ^\");\n \t  /* Check cases like x^y==z */\n-\t  if (TREE_CODE_CLASS (code1) == '<' || TREE_CODE_CLASS (code2) == '<')\n+\t  if (TREE_CODE_CLASS (code1) == tcc_comparison\n+\t      || TREE_CODE_CLASS (code2) == tcc_comparison)\n \t    warning (\"suggest parentheses around comparison in operand of ^\");\n \t}\n \n@@ -2254,13 +2262,14 @@ parser_build_binary_op (enum tree_code code, struct c_expr arg1,\n \t      || code2 == PLUS_EXPR || code2 == MINUS_EXPR)\n \t    warning (\"suggest parentheses around + or - in operand of &\");\n \t  /* Check cases like x&y==z */\n-\t  if (TREE_CODE_CLASS (code1) == '<' || TREE_CODE_CLASS (code2) == '<')\n+\t  if (TREE_CODE_CLASS (code1) == tcc_comparison\n+\t      || TREE_CODE_CLASS (code2) == tcc_comparison)\n \t    warning (\"suggest parentheses around comparison in operand of &\");\n \t}\n       /* Similarly, check for cases like 1<=i<=10 that are probably errors.  */\n-      if (TREE_CODE_CLASS (code) == '<'\n-\t  && (TREE_CODE_CLASS (code1) == '<'\n-\t      || TREE_CODE_CLASS (code2) == '<'))\n+      if (TREE_CODE_CLASS (code) == tcc_comparison\n+\t  && (TREE_CODE_CLASS (code1) == tcc_comparison\n+\t      || TREE_CODE_CLASS (code2) == tcc_comparison))\n \twarning (\"comparisons like X<=Y<=Z do not have their mathematical meaning\");\n \n     }\n@@ -2604,7 +2613,7 @@ build_unary_op (enum tree_code code, tree xarg, int flag)\n          to which the address will point.  Note that you can't get a\n \t restricted pointer by taking the address of something, so we\n \t only have to deal with `const' and `volatile' here.  */\n-      if ((DECL_P (arg) || TREE_CODE_CLASS (TREE_CODE (arg)) == 'r')\n+      if ((DECL_P (arg) || REFERENCE_CLASS_P (arg))\n \t  && (TREE_READONLY (arg) || TREE_THIS_VOLATILE (arg)))\n \t  argtype = c_build_type_variant (argtype,\n \t\t\t\t\t  TREE_READONLY (arg),\n@@ -3208,7 +3217,7 @@ build_c_cast (tree type, tree expr)\n \t  else\n \t    TREE_OVERFLOW (value) = 0;\n \t  \n-\t  if (TREE_CODE_CLASS (TREE_CODE (ovalue)) == 'c')\n+\t  if (CONSTANT_CLASS_P (ovalue))\n \t    /* Similarly, constant_overflow cannot have become\n \t       cleared.  */\n \t    TREE_CONSTANT_OVERFLOW (value) = TREE_CONSTANT_OVERFLOW (ovalue);\n@@ -6396,7 +6405,7 @@ c_finish_return (tree retval)\n \t    case ADDR_EXPR:\n \t      inner = TREE_OPERAND (inner, 0);\n \n-\t      while (TREE_CODE_CLASS (TREE_CODE (inner)) == 'r'\n+\t      while (REFERENCE_CLASS_P (inner)\n \t             && TREE_CODE (inner) != INDIRECT_REF)\n \t\tinner = TREE_OPERAND (inner, 0);\n \n@@ -6744,7 +6753,7 @@ c_process_expr_stmt (tree expr)\n \n   /* If the expression is not of a type to which we cannot assign a line\n      number, wrap the thing in a no-op NOP_EXPR.  */\n-  if (DECL_P (expr) || TREE_CODE_CLASS (TREE_CODE (expr)) == 'c')\n+  if (DECL_P (expr) || CONSTANT_CLASS_P (expr))\n     expr = build1 (NOP_EXPR, TREE_TYPE (expr), expr);\n \n   if (EXPR_P (expr))"}, {"sha": "e4348ca8b83134792a8d5c350c3125a3a184f75f", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=6615c446157600e6dbe0b716f48e80a64e49807f", "patch": "@@ -671,7 +671,7 @@ record_call_1 (tree *tp, int *walk_subtrees, void *data)\n     default:\n       /* Save some cycles by not walking types and declaration as we\n \t won't find anything useful there anyway.  */\n-      if (DECL_P (*tp) || TYPE_P (*tp))\n+      if (IS_TYPE_OR_DECL_P (*tp))\n \t{\n \t  *walk_subtrees = 0;\n \t  break;\n@@ -740,7 +740,7 @@ verify_cgraph_node_1 (tree *tp, int *walk_subtrees, void *data)\n \n   /* Save some cycles by not walking types and declaration as we\n      won't find anything useful there anyway.  */\n-  if (DECL_P (*tp) || TYPE_P (*tp))\n+  if (IS_TYPE_OR_DECL_P (*tp))\n     *walk_subtrees = 0;\n \n   return NULL_TREE;\n@@ -2225,18 +2225,18 @@ scan_for_static_refs (tree *tp,\n \tcheck_lhs_var (fn, TREE_OPERAND (t, 0));\n \t/* Next check the operands on the rhs to see if they are ok. */\n \tswitch (TREE_CODE_CLASS (TREE_CODE (rhs))) {\n-\tcase '2':\n+\tcase tcc_binary:\n \t  check_rhs_var (fn, TREE_OPERAND (rhs, 0));\n \t  check_rhs_var (fn, TREE_OPERAND (rhs, 1));\n \t  break;\n-\tcase '1':\n-\tcase 'r':\n+\tcase tcc_unary:\n+\tcase tcc_reference:\n \t  check_rhs_var (fn, TREE_OPERAND (rhs, 0));\n \t  break;\n-\tcase 'd':\n+\tcase tcc_declaration:\n \t  check_rhs_var (fn, rhs);\n \t  break;\n-\tcase 'e':\n+\tcase tcc_expression:\n \t  switch (TREE_CODE (rhs)) {\n \t  case ADDR_EXPR:\n \t    check_rhs_var (fn, rhs);"}, {"sha": "a838372b4860b982cff0072729ac336dd87a13da", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=6615c446157600e6dbe0b716f48e80a64e49807f", "patch": "@@ -13788,7 +13788,7 @@ arm_encode_section_info (tree decl, rtx rtl, int first)\n   /* If we are referencing a function that is weak then encode a long call\n      flag in the function name, otherwise if the function is static or\n      or known to be defined in this file then encode a short call flag.  */\n-  if (first && TREE_CODE_CLASS (TREE_CODE (decl)) == 'd')\n+  if (first && DECL_P (decl))\n     {\n       if (TREE_CODE (decl) == FUNCTION_DECL && DECL_WEAK (decl))\n         arm_encode_call_attribute (decl, LONG_CALL_FLAG_CHAR);"}, {"sha": "a2a7a3076c6dc287345028639d272a4a3a9396b7", "filename": "gcc/config/i386/winnt.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Fconfig%2Fi386%2Fwinnt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Fconfig%2Fi386%2Fwinnt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fwinnt.c?ref=6615c446157600e6dbe0b716f48e80a64e49807f", "patch": "@@ -99,8 +99,7 @@ associated_type (tree decl)\n \tt = TYPE_MAIN_VARIANT\n \t  (TREE_TYPE (TREE_VALUE (TYPE_ARG_TYPES (TREE_TYPE (decl)))));\n     }\n-  else if (DECL_CONTEXT (decl)\n-\t   && TREE_CODE_CLASS (TREE_CODE (DECL_CONTEXT (decl))) == 't')\n+  else if (DECL_CONTEXT (decl) && TYPE_P (DECL_CONTEXT (decl)))\n     t = DECL_CONTEXT (decl);\n \n   return t;"}, {"sha": "4cefce56b3b5d9142fde009c7b16273344899cfb", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=6615c446157600e6dbe0b716f48e80a64e49807f", "patch": "@@ -9342,8 +9342,7 @@ pa_select_section (tree exp, int reloc,\n       else\n \treadonly_data_section ();\n     }\n-  else if (TREE_CODE_CLASS (TREE_CODE (exp)) == 'c'\n-\t   && !reloc)\n+  else if (CONSTANT_CLASS_P (exp) && !reloc)\n     readonly_data_section ();\n   else if (TARGET_SOM\n \t   && TREE_CODE (exp) == VAR_DECL"}, {"sha": "5c5d8bf39f078b078911b9726df8d815ef28d298", "filename": "gcc/config/pa/pa.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Fconfig%2Fpa%2Fpa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Fconfig%2Fpa%2Fpa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.h?ref=6615c446157600e6dbe0b716f48e80a64e49807f", "patch": "@@ -1770,7 +1770,7 @@ forget_section (void)\t\t\t\t\t\t\t\\\n        && TREE_READONLY (DECL) && ! TREE_SIDE_EFFECTS (DECL)\t\t\\\n        && (! DECL_INITIAL (DECL) || ! reloc_needed (DECL_INITIAL (DECL))) \\\n        && !flag_pic)\t\t\t\t\t\t\t\\\n-   || (TREE_CODE_CLASS (TREE_CODE (DECL)) == 'c'))\n+   || CONSTANT_CLASS_P (DECL))\n \n #define FUNCTION_NAME_P(NAME)  (*(NAME) == '@')\n "}, {"sha": "ce4ee857a89a2f49d298a45c337926be94cebc6b", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=6615c446157600e6dbe0b716f48e80a64e49807f", "patch": "@@ -7065,7 +7065,7 @@ sh_insert_attributes (tree node, tree *attributes)\n     return;\n \n   /* We are only interested in fields.  */\n-  if (TREE_CODE_CLASS (TREE_CODE (node)) != 'd')\n+  if (!DECL_P (node))\n     return;\n \n   /* Add a 'handle_interrupt' attribute.  */"}, {"sha": "17628a03ffab33cd6418ba898a3e88c164ae9eb3", "filename": "gcc/config/sol2-c.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Fconfig%2Fsol2-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Fconfig%2Fsol2-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsol2-c.c?ref=6615c446157600e6dbe0b716f48e80a64e49807f", "patch": "@@ -113,7 +113,7 @@ solaris_pragma_align (cpp_reader *pfile ATTRIBUTE_UNUSED)\n   while (1)\n     {\n       tree decl = identifier_global_value (t);\n-      if (decl && TREE_CODE_CLASS (TREE_CODE (decl)) == 'd')\n+      if (decl && DECL_P (decl))\n \twarning (\"%<#pragma align%> must appear before the declaration of \"\n \t\t \"%D, ignoring\", decl);\n       else\n@@ -168,7 +168,7 @@ solaris_pragma_init (cpp_reader *pfile ATTRIBUTE_UNUSED)\n   while (1)\n     {\n       tree decl = identifier_global_value (t);\n-      if (decl && TREE_CODE_CLASS (TREE_CODE (decl)) == 'd')\n+      if (decl && DECL_P (decl))\n \t{\n \t  tree init_list = build_tree_list (get_identifier (\"init\"),\n \t\t\t\t\t    NULL);\n@@ -226,7 +226,7 @@ solaris_pragma_fini (cpp_reader *pfile ATTRIBUTE_UNUSED)\n   while (1)\n     {\n       tree decl = identifier_global_value (t);\n-      if (decl && TREE_CODE_CLASS (TREE_CODE (decl)) == 'd')\n+      if (decl && DECL_P (decl))\n \t{\n \t  tree fini_list = build_tree_list (get_identifier (\"fini\"),\n \t\t\t\t\t    NULL);"}, {"sha": "d9c0c129d7cf59af5da36effb264ea138dcc1fd6", "filename": "gcc/convert.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Fconvert.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Fconvert.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconvert.c?ref=6615c446157600e6dbe0b716f48e80a64e49807f", "patch": "@@ -401,7 +401,7 @@ convert_to_integer (tree type, tree expr)\n \t we must also change the types of the operands to maintain type\n \t correctness.  */\n \n-      if (TREE_CODE_CLASS (ex_form) == '<')\n+      if (TREE_CODE_CLASS (ex_form) == tcc_comparison)\n \t{\n \t  expr = copy_node (expr);\n \t  TREE_TYPE (expr) = type;"}, {"sha": "be9b0d33688bad90eb89058ea9d0d534362b76f1", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=6615c446157600e6dbe0b716f48e80a64e49807f", "patch": "@@ -1,3 +1,12 @@\n+2004-09-17  Jeffrey D. Oldham  <oldham@codesourcery.com>\n+\t    Zack Weinberg  <zack@codesourcery.com>\n+\n+\t* cp-tree.def: Use tree_code_class enumeration constants\n+\tinstead of code letters.\n+\t* call.c, class.c, cp-gimplify.c, cp-lang.c, cxx-pretty-print.c\n+\t* mangle.c, pt.c, semantics.c, tree.c, typeck.c:\n+\tUpdate for new tree-class enumeration constants.\n+\n 2004-09-16  Mark Mitchell  <mark@codesourcery.com>\n \n \tPR c++/16002\n@@ -16,7 +25,7 @@\n \n 2004-09-16  Andrew MacLeod  <amacleod@redhat.com>\n \n-\t* error.c (dump_decl): Make sure there is lang_specific info before \n+\t* error.c (dump_decl): Make sure there is lang_specific info before\n \tchecking for DTOR and CTOR decls.\n \n 2004-09-16  Nathan Sidwell  <nathan@codesourcery.com>\n@@ -106,9 +115,9 @@\n 2004-09-11  Richard Henderson  <rth@redhat.com>\n \n \tPR c++/17404\n-        * pt.c (cur_stmt_expr): Move from tsubst_expr.\n-        (tsubst_expr) <case STMT_EXPR>: Move ...\n-        (tsubst_copy_and_build): ... here.\n+\t* pt.c (cur_stmt_expr): Move from tsubst_expr.\n+\t(tsubst_expr) <case STMT_EXPR>: Move ...\n+\t(tsubst_copy_and_build): ... here.\n \n 2004-09-10  Zack Weinberg  <zack@codesourcery.com>\n "}, {"sha": "4f2a80c2922004dc7d84c4adc3a4a3080fbc27ce", "filename": "gcc/cp/call.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=6615c446157600e6dbe0b716f48e80a64e49807f", "patch": "@@ -5867,7 +5867,7 @@ joust (struct z_candidate *cand1, struct z_candidate *cand2, bool warn)\n   /* If we have two pseudo-candidates for conversions to the same type,\n      or two candidates for the same function, arbitrarily pick one.  */\n   if (cand1->fn == cand2->fn\n-      && (TYPE_P (cand1->fn) || DECL_P (cand1->fn)))\n+      && (IS_TYPE_OR_DECL_P (cand1->fn)))\n     return 1;\n \n   /* a viable function F1"}, {"sha": "5a065209849cfed1b2a71a17259cba60c07964b3", "filename": "gcc/cp/class.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=6615c446157600e6dbe0b716f48e80a64e49807f", "patch": "@@ -6272,11 +6272,11 @@ get_enclosing_class (tree type)\n     {\n       switch (TREE_CODE_CLASS (TREE_CODE (node)))\n \t{\n-\tcase 'd':\n+\tcase tcc_declaration:\n \t  node = DECL_CONTEXT (node);\n \t  break;\n \n-\tcase 't':\n+\tcase tcc_type:\n \t  if (node != type)\n \t    return node;\n \t  node = TYPE_CONTEXT (node);"}, {"sha": "d6a2f18ff05364ab864afe37a590f63ed147532c", "filename": "gcc/cp/cp-gimplify.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Fcp%2Fcp-gimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Fcp%2Fcp-gimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-gimplify.c?ref=6615c446157600e6dbe0b716f48e80a64e49807f", "patch": "@@ -303,7 +303,7 @@ cp_genericize_r (tree *stmt_p, int *walk_subtrees, void *data)\n \t   && is_invisiref_parm (TREE_OPERAND (stmt, 0)))\n     /* Don't dereference an invisiref RESULT_DECL inside a RETURN_EXPR.  */\n     *walk_subtrees = 0;\n-  else if (DECL_P (stmt) || TYPE_P (stmt))\n+  else if (IS_TYPE_OR_DECL_P (stmt))\n     *walk_subtrees = 0;\n \n   /* Due to the way voidify_wrapper_expr is written, we don't get a chance"}, {"sha": "3b2590cd498207ba48b5fc640b9164427e88f02c", "filename": "gcc/cp/cp-lang.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Fcp%2Fcp-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Fcp%2Fcp-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-lang.c?ref=6615c446157600e6dbe0b716f48e80a64e49807f", "patch": "@@ -57,11 +57,11 @@ const struct lang_hooks lang_hooks = LANG_HOOKS_INITIALIZER;\n \n #define DEFTREECODE(SYM, NAME, TYPE, LENGTH) TYPE,\n \n-const char tree_code_type[] = {\n+const enum tree_code_class tree_code_type[] = {\n #include \"tree.def\"\n-  'x',\n+  tcc_exceptional,\n #include \"c-common.def\"\n-  'x',\n+  tcc_exceptional,\n #include \"cp-tree.def\"\n };\n #undef DEFTREECODE"}, {"sha": "2335e2f70435d369dbf113a876c4066d09088b14", "filename": "gcc/cp/cp-tree.def", "status": "modified", "additions": 48, "deletions": 47, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Fcp%2Fcp-tree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Fcp%2Fcp-tree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.def?ref=6615c446157600e6dbe0b716f48e80a64e49807f", "patch": "@@ -42,56 +42,56 @@ Boston, MA 02111-1307, USA.  */\n    2. An expression of the form `x.*p'.  In this case, operand 0 will\n       be an expression corresponding to `x' and operand 1 will be an\n       expression with pointer-to-member type.  */\n-DEFTREECODE (OFFSET_REF, \"offset_ref\", 'r', 2)\n+DEFTREECODE (OFFSET_REF, \"offset_ref\", tcc_reference, 2)\n \n /* A pointer-to-member constant.  For a pointer-to-member constant\n    `X::Y' The PTRMEM_CST_CLASS is the RECORD_TYPE for `X' and the\n    PTRMEM_CST_MEMBER is the _DECL for `Y'.  */\n-DEFTREECODE (PTRMEM_CST, \"ptrmem_cst\", 'c', 0)\n+DEFTREECODE (PTRMEM_CST, \"ptrmem_cst\", tcc_constant, 0)\n \n /* For NEW_EXPR, operand 0 is the placement list.\n    Operand 1 is the new-declarator.\n    Operand 2 is the number of elements in the array.\n    Operand 3 is the initializer.  */\n-DEFTREECODE (NEW_EXPR, \"nw_expr\", 'e', 4)\n-DEFTREECODE (VEC_NEW_EXPR, \"vec_nw_expr\", 'e', 3)\n+DEFTREECODE (NEW_EXPR, \"nw_expr\", tcc_expression, 4)\n+DEFTREECODE (VEC_NEW_EXPR, \"vec_nw_expr\", tcc_expression, 3)\n \n /* For DELETE_EXPR, operand 0 is the store to be destroyed.\n    Operand 1 is the value to pass to the destroying function\n    saying whether the store should be deallocated as well.  */\n-DEFTREECODE (DELETE_EXPR, \"dl_expr\", 'e', 2)\n-DEFTREECODE (VEC_DELETE_EXPR, \"vec_dl_expr\", 'e', 2)\n+DEFTREECODE (DELETE_EXPR, \"dl_expr\", tcc_expression, 2)\n+DEFTREECODE (VEC_DELETE_EXPR, \"vec_dl_expr\", tcc_expression, 2)\n \n /* Value is reference to particular overloaded class method.\n    Operand 0 is the class, operand 1 is the field\n    The COMPLEXITY field holds the class level (usually 0).  */\n-DEFTREECODE (SCOPE_REF, \"scope_ref\", 'r', 2)\n+DEFTREECODE (SCOPE_REF, \"scope_ref\", tcc_reference, 2)\n \n /* When composing an object with a member, this is the result.\n    Operand 0 is the object.  Operand 1 is the member (usually\n    a dereferenced pointer to member).  */\n-DEFTREECODE (MEMBER_REF, \"member_ref\", 'r', 2)\n+DEFTREECODE (MEMBER_REF, \"member_ref\", tcc_reference, 2)\n \n /* Type conversion operator in C++.  TREE_TYPE is type that this\n    operator converts to.  Operand is expression to be converted.  */\n-DEFTREECODE (TYPE_EXPR, \"type_expr\", 'e', 1)\n+DEFTREECODE (TYPE_EXPR, \"type_expr\", tcc_expression, 1)\n \n /* For AGGR_INIT_EXPR, operand 0 is function which performs initialization,\n    operand 1 is argument list to initialization function,\n    and operand 2 is the slot which was allocated for this expression.  */\n-DEFTREECODE (AGGR_INIT_EXPR, \"aggr_init_expr\", 'e', 3)\n+DEFTREECODE (AGGR_INIT_EXPR, \"aggr_init_expr\", tcc_expression, 3)\n \n /* A throw expression.  operand 0 is the expression, if there was one,\n    else it is NULL_TREE.  */\n-DEFTREECODE (THROW_EXPR, \"throw_expr\", 'e', 1)\n+DEFTREECODE (THROW_EXPR, \"throw_expr\", tcc_expression, 1)\n \n /* An empty class object.  The TREE_TYPE gives the class type.  We use\n    these to avoid actually creating instances of the empty classes.  */\n-DEFTREECODE (EMPTY_CLASS_EXPR, \"empty_class_expr\", 'e', 0)\n+DEFTREECODE (EMPTY_CLASS_EXPR, \"empty_class_expr\", tcc_expression, 0)\n \n /* A DECL which is really just a placeholder for an expression.  Used to\n    implement non-class scope anonymous unions.  */\n-DEFTREECODE (ALIAS_DECL, \"alias_decl\", 'd', 0)\n+DEFTREECODE (ALIAS_DECL, \"alias_decl\", tcc_declaration, 0)\n \n /* A reference to a member function or member functions from a base\n    class.  BASELINK_FUNCTIONS gives the FUNCTION_DECL,\n@@ -105,7 +105,7 @@ DEFTREECODE (ALIAS_DECL, \"alias_decl\", 'd', 0)\n    the type of the expression.  This type is either a FUNCTION_TYPE,\n    METHOD_TYPE, or `unknown_type_node' indicating that the function is\n    overloaded.  */\n-DEFTREECODE (BASELINK, \"baselink\", 'x', 0)\n+DEFTREECODE (BASELINK, \"baselink\", tcc_exceptional, 0)\n \n /* Template definition.  The following fields have the specified uses,\n    although there are other macros in cp-tree.h that should be used for\n@@ -122,7 +122,7 @@ DEFTREECODE (BASELINK, \"baselink\", 'x', 0)\n         DECL_TEMPLATE_RESULT    decl for object to be created\n                                 (e.g., FUNCTION_DECL with tmpl parms used)\n  */\n-DEFTREECODE (TEMPLATE_DECL, \"template_decl\", 'd', 0)\n+DEFTREECODE (TEMPLATE_DECL, \"template_decl\", tcc_declaration, 0)\n \n /* Index into a template parameter list.  The TEMPLATE_PARM_IDX gives\n    the index (from 0) of the parameter, while the TEMPLATE_PARM_LEVEL\n@@ -157,11 +157,11 @@ DEFTREECODE (TEMPLATE_DECL, \"template_decl\", 'd', 0)\n    The LEVEL is the level of the parameter when we are worrying about\n    the types of things; the ORIG_LEVEL is the level when we are\n    worrying about instantiating things.  */\n-DEFTREECODE (TEMPLATE_PARM_INDEX, \"template_parm_index\", 'x', 0)\n+DEFTREECODE (TEMPLATE_PARM_INDEX, \"template_parm_index\", tcc_exceptional, 0)\n \n /* Index into a template parameter list.  This parameter must be a type.\n    The type.value field will be a TEMPLATE_PARM_INDEX.  */\n-DEFTREECODE (TEMPLATE_TYPE_PARM, \"template_type_parm\", 't', 0)\n+DEFTREECODE (TEMPLATE_TYPE_PARM, \"template_type_parm\", tcc_type, 0)\n \n /* Index into a template parameter list for template template parameters.\n    This parameter must be a type.  The TYPE_FIELDS value will be a \n@@ -170,65 +170,66 @@ DEFTREECODE (TEMPLATE_TYPE_PARM, \"template_type_parm\", 't', 0)\n    It is used without template arguments like TT in C<TT>, \n    TEMPLATE_TEMPLATE_PARM_TEMPLATE_INFO is NULL_TREE\n    and TYPE_NAME is a TEMPLATE_DECL.  */\n-DEFTREECODE (TEMPLATE_TEMPLATE_PARM, \"template_template_parm\", 't', 0)\n+DEFTREECODE (TEMPLATE_TEMPLATE_PARM, \"template_template_parm\", tcc_type, 0)\n \n /* Like TEMPLATE_TEMPLATE_PARM it is used with bound template arguments \n    like TT<int>.\n    In this case, TEMPLATE_TEMPLATE_PARM_TEMPLATE_INFO contains the\n    template name and its bound arguments.  TYPE_NAME is a TYPE_DECL.  */\n-DEFTREECODE (BOUND_TEMPLATE_TEMPLATE_PARM, \"bound_template_template_parm\", 't', 0)\n+DEFTREECODE (BOUND_TEMPLATE_TEMPLATE_PARM, \"bound_template_template_parm\",\n+\t     tcc_type, 0)\n \n /* A type designated by `typename T::t'.  TYPE_CONTEXT is `T',\n    TYPE_NAME is an IDENTIFIER_NODE for `t'.  If the type was named via\n    template-id, TYPENAME_TYPE_FULLNAME will hold the TEMPLATE_ID_EXPR.\n    If TREE_TYPE is present, this type was generated by the implicit\n    typename extension, and the TREE_TYPE is a _TYPE from a baseclass\n    of `T'.  */\n-DEFTREECODE (TYPENAME_TYPE, \"typename_type\", 't', 0)\n+DEFTREECODE (TYPENAME_TYPE, \"typename_type\", tcc_type, 0)\n \n /* For template template argument of the form `T::template C'.\n    TYPE_CONTEXT is `T', the template parameter dependent object.\n    TYPE_NAME is an IDENTIFIER_NODE for `C', the member class template.  */\n-DEFTREECODE (UNBOUND_CLASS_TEMPLATE, \"unbound_class_template\", 't', 0)\n+DEFTREECODE (UNBOUND_CLASS_TEMPLATE, \"unbound_class_template\", tcc_type, 0)\n \n /* A type designated by `__typeof (expr)'.  TYPEOF_TYPE_EXPR is the\n    expression in question.  */\n-DEFTREECODE (TYPEOF_TYPE, \"typeof_type\", 't', 0)\n+DEFTREECODE (TYPEOF_TYPE, \"typeof_type\", tcc_type, 0)\n \n /* A using declaration.  DECL_INITIAL contains the specified scope.  \n    This is not an alias, but is later expanded into multiple aliases.\n    The decl will have a NULL_TYPE iff the scope is a dependent scope,\n    otherwise it will have a void type.  */\n-DEFTREECODE (USING_DECL, \"using_decl\", 'd', 0)\n+DEFTREECODE (USING_DECL, \"using_decl\", tcc_declaration, 0)\n \n /* A using directive. The operand is USING_STMT_NAMESPACE.  */     \n-DEFTREECODE (USING_STMT, \"using_directive\", 'e', 1)\n+DEFTREECODE (USING_STMT, \"using_directive\", tcc_expression, 1)\n \n /* An un-parsed default argument.  Looks like an IDENTIFIER_NODE.  */\n-DEFTREECODE (DEFAULT_ARG, \"default_arg\", 'x', 0)\n+DEFTREECODE (DEFAULT_ARG, \"default_arg\", tcc_exceptional, 0)\n \n /* A template-id, like foo<int>.  The first operand is the template.\n    The second is NULL if there are no explicit arguments, or a\n    TREE_VEC of arguments.  The template will be a FUNCTION_DECL,\n    TEMPLATE_DECL, or an OVERLOAD.  If the template-id refers to a\n    member template, the template may be an IDENTIFIER_NODE.  */\n-DEFTREECODE (TEMPLATE_ID_EXPR, \"template_id_expr\", 'e', 2)\n+DEFTREECODE (TEMPLATE_ID_EXPR, \"template_id_expr\", tcc_expression, 2)\n \n /* A list-like node for chaining overloading candidates. TREE_TYPE is \n    the original name, and the parameter is the FUNCTION_DECL.  */\n-DEFTREECODE (OVERLOAD, \"overload\", 'x', 0)\n+DEFTREECODE (OVERLOAD, \"overload\", tcc_exceptional, 0)\n \n /* A whole bunch of tree codes for the initial, superficial parsing of\n    templates.  */\n-DEFTREECODE (MODOP_EXPR, \"modop_expr\", 'e', 3)\n-DEFTREECODE (CAST_EXPR, \"cast_expr\", '1', 1)\n-DEFTREECODE (REINTERPRET_CAST_EXPR, \"reinterpret_cast_expr\", '1', 1)\n-DEFTREECODE (CONST_CAST_EXPR, \"const_cast_expr\", '1', 1)\n-DEFTREECODE (STATIC_CAST_EXPR, \"static_cast_expr\", '1', 1)\n-DEFTREECODE (DYNAMIC_CAST_EXPR, \"dynamic_cast_expr\", '1', 1)\n-DEFTREECODE (DOTSTAR_EXPR, \"dotstar_expr\", 'e', 2)\n-DEFTREECODE (TYPEID_EXPR, \"typeid_expr\", 'e', 1)\n-DEFTREECODE (PSEUDO_DTOR_EXPR, \"pseudo_dtor_expr\", 'e', 3)\n+DEFTREECODE (MODOP_EXPR, \"modop_expr\", tcc_expression, 3)\n+DEFTREECODE (CAST_EXPR, \"cast_expr\", tcc_unary, 1)\n+DEFTREECODE (REINTERPRET_CAST_EXPR, \"reinterpret_cast_expr\", tcc_unary, 1)\n+DEFTREECODE (CONST_CAST_EXPR, \"const_cast_expr\", tcc_unary, 1)\n+DEFTREECODE (STATIC_CAST_EXPR, \"static_cast_expr\", tcc_unary, 1)\n+DEFTREECODE (DYNAMIC_CAST_EXPR, \"dynamic_cast_expr\", tcc_unary, 1)\n+DEFTREECODE (DOTSTAR_EXPR, \"dotstar_expr\", tcc_expression, 2)\n+DEFTREECODE (TYPEID_EXPR, \"typeid_expr\", tcc_expression, 1)\n+DEFTREECODE (PSEUDO_DTOR_EXPR, \"pseudo_dtor_expr\", tcc_expression, 3)\n \n /* A placeholder for an expression that is not type-dependent, but\n    does occur in a template.  When an expression that is not\n@@ -239,38 +240,38 @@ DEFTREECODE (PSEUDO_DTOR_EXPR, \"pseudo_dtor_expr\", 'e', 3)\n    that situation, we create a NON_DEPENDENT_EXPR to take the place of\n    the original expression.  The expression is the only operand -- it\n    is only needed for diagnostics.  */\n-DEFTREECODE (NON_DEPENDENT_EXPR, \"non_dependent_expr\", 'e', 1)\n+DEFTREECODE (NON_DEPENDENT_EXPR, \"non_dependent_expr\", tcc_expression, 1)\n \n /* CTOR_INITIALIZER is a placeholder in template code for a call to\n    setup_vtbl_pointer (and appears in all functions, not just ctors).  */\n-DEFTREECODE (CTOR_INITIALIZER, \"ctor_initializer\", 'e', 1)\n+DEFTREECODE (CTOR_INITIALIZER, \"ctor_initializer\", tcc_expression, 1)\n \n-DEFTREECODE (TRY_BLOCK, \"try_block\", 'e', 2)\n+DEFTREECODE (TRY_BLOCK, \"try_block\", tcc_expression, 2)\n \n-DEFTREECODE (EH_SPEC_BLOCK, \"eh_spec_block\", 'e', 2)\n+DEFTREECODE (EH_SPEC_BLOCK, \"eh_spec_block\", tcc_expression, 2)\n \n /* A HANDLER wraps a catch handler for the HANDLER_TYPE.  If this is\n    CATCH_ALL_TYPE, then the handler catches all types.  The declaration of\n    the catch variable is in HANDLER_PARMS, and the body block in\n    HANDLER_BODY.  */\n-DEFTREECODE (HANDLER, \"handler\", 'e', 2)\n+DEFTREECODE (HANDLER, \"handler\", tcc_expression, 2)\n \n /* A MUST_NOT_THROW_EXPR wraps an expression that may not\n    throw, and must call terminate if it does.  */\n-DEFTREECODE (MUST_NOT_THROW_EXPR, \"must_not_throw_expr\", 'e', 1)\n+DEFTREECODE (MUST_NOT_THROW_EXPR, \"must_not_throw_expr\", tcc_expression, 1)\n \n /* A CLEANUP_STMT marks the point at which a declaration is fully\n    constructed.  The CLEANUP_EXPR is run on behalf of CLEANUP_DECL\n    when CLEANUP_BODY completes.  */\n-DEFTREECODE (CLEANUP_STMT, \"cleanup_stmt\", 'e', 3)\n+DEFTREECODE (CLEANUP_STMT, \"cleanup_stmt\", tcc_expression, 3)\n \n /* Represents an 'if' statement. The operands are IF_COND,\n    THEN_CLAUSE, and ELSE_CLAUSE, respectively.  */\n /* ??? It is currently still necessary to distinguish between IF_STMT \n    and COND_EXPR for the benefit of templates.  */\n-DEFTREECODE (IF_STMT, \"if_stmt\", 'e', 3)\n+DEFTREECODE (IF_STMT, \"if_stmt\", tcc_expression, 3)\n \n-DEFTREECODE (TAG_DEFN, \"tag_defn\", 'e', 0)\n+DEFTREECODE (TAG_DEFN, \"tag_defn\", tcc_expression, 0)\n \n /* Template instantiation level node.\n \n@@ -280,10 +281,10 @@ DEFTREECODE (TAG_DEFN, \"tag_defn\", 'e', 0)\n    A stack of template instantiation nodes is kept through the TREE_CHAIN\n    fields of these nodes.  */\n \n-DEFTREECODE (TINST_LEVEL, \"TINST_LEVEL\", 'x', 0)\n+DEFTREECODE (TINST_LEVEL, \"TINST_LEVEL\", tcc_exceptional, 0)\n \n /* Represents an 'offsetof' expression during template expansion.  */\n-DEFTREECODE (OFFSETOF_EXPR, \"offsetof_expr\", 'e', 1)\n+DEFTREECODE (OFFSETOF_EXPR, \"offsetof_expr\", tcc_expression, 1)\n \n /*\n Local variables:"}, {"sha": "ca2a29f08b1c54ede61567782c56324215058ab5", "filename": "gcc/cp/cxx-pretty-print.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Fcp%2Fcxx-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Fcp%2Fcxx-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcxx-pretty-print.c?ref=6615c446157600e6dbe0b716f48e80a64e49807f", "patch": "@@ -1154,7 +1154,8 @@ static void\n pp_cxx_parameter_declaration_clause (cxx_pretty_printer *pp, tree t)\n {\n   tree args = TYPE_P (t) ? NULL : FUNCTION_FIRST_USER_PARM (t);\n-  tree types = TYPE_P (t) ? TYPE_ARG_TYPES (t) : FUNCTION_FIRST_USER_PARMTYPE (t);\n+  tree types = \n+    TYPE_P (t) ? TYPE_ARG_TYPES (t) : FUNCTION_FIRST_USER_PARMTYPE (t);\n   const bool abstract = args == NULL\n     || pp_c_base (pp)->flags & pp_c_flag_abstract;\n   bool first = true;\n@@ -1441,7 +1442,7 @@ pp_cxx_template_argument_list (cxx_pretty_printer *pp, tree t)\n       if (i != 0)\n         pp_cxx_separate_with (pp, ',');\n       if (TYPE_P (arg) || (TREE_CODE (arg) == TEMPLATE_DECL\n-                           && TYPE_P (DECL_TEMPLATE_RESULT (arg))))\n+\t\t\t   && TYPE_P (DECL_TEMPLATE_RESULT (arg))))\n         pp_cxx_type_id (pp, arg);\n       else\n         pp_cxx_expression (pp, arg);"}, {"sha": "5d9995faa32948b449a5f871dd4c7a2419bf800a", "filename": "gcc/cp/mangle.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Fcp%2Fmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Fcp%2Fmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmangle.c?ref=6615c446157600e6dbe0b716f48e80a64e49807f", "patch": "@@ -1997,7 +1997,7 @@ write_expression (tree expr)\n       || code == TEMPLATE_PARM_INDEX)\n     write_template_param (expr);\n   /* Handle literals.  */\n-  else if (TREE_CODE_CLASS (code) == 'c' \n+  else if (TREE_CODE_CLASS (code) == tcc_constant\n \t   || (abi_version_at_least (2) && code == CONST_DECL))\n     write_template_arg_literal (expr);\n   else if (DECL_P (expr))\n@@ -2260,7 +2260,7 @@ write_template_arg (tree node)\n   else if (code == TEMPLATE_DECL)\n     /* A template appearing as a template arg is a template template arg.  */\n     write_template_template_arg (node);\n-  else if ((TREE_CODE_CLASS (code) == 'c' && code != PTRMEM_CST)\n+  else if ((TREE_CODE_CLASS (code) == tcc_constant && code != PTRMEM_CST)\n \t   || (abi_version_at_least (2) && code == CONST_DECL))\n     write_template_arg_literal (node);\n   else if (DECL_P (node))"}, {"sha": "d7e59039ce4aeb03fdad32effd151d9e99d2f4e9", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 17, "deletions": 10, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=6615c446157600e6dbe0b716f48e80a64e49807f", "patch": "@@ -4891,7 +4891,7 @@ uses_template_parms (tree t)\n \t   || TREE_CODE (t) == TEMPLATE_PARM_INDEX\n \t   || TREE_CODE (t) == OVERLOAD\n \t   || TREE_CODE (t) == BASELINK\n-\t   || TREE_CODE_CLASS (TREE_CODE (t)) == 'c')\n+\t   || CONSTANT_CLASS_P (t))\n     dependent_p = (type_dependent_expression_p (t)\n \t\t   || value_dependent_expression_p (t));\n   else\n@@ -10109,7 +10109,7 @@ unify (tree tparms, tree targs, tree parm, tree arg, int strict)\n       return 1;\n \n     default:\n-      gcc_assert (IS_EXPR_CODE_CLASS (TREE_CODE_CLASS (TREE_CODE (parm))));\n+      gcc_assert (EXPR_P (parm));\n       \n       /* We must be looking at an expression.  This can happen with\n \t something like: \n@@ -11586,9 +11586,9 @@ dependent_type_p_r (tree type)\n \n      A type is dependent if it is:\n \n-     -- a template parameter. Template template parameters are\n-\ttypes for us (since TYPE_P holds true for them) so we\n-\thandle them here.  */\n+     -- a template parameter. Template template parameters are types\n+\tfor us (since TYPE_P holds true for them) so we handle\n+\tthem here.  */\n   if (TREE_CODE (type) == TEMPLATE_TYPE_PARM \n       || TREE_CODE (type) == TEMPLATE_TEMPLATE_PARM)\n     return true;\n@@ -11819,20 +11819,20 @@ value_dependent_expression_p (tree expression)\n \t    || value_dependent_expression_p (TREE_OPERAND (expression, 1)));\n   /* A constant expression is value-dependent if any subexpression is\n      value-dependent.  */\n-  if (IS_EXPR_CODE_CLASS (TREE_CODE_CLASS (TREE_CODE (expression))))\n+  if (EXPR_P (expression))\n     {\n       switch (TREE_CODE_CLASS (TREE_CODE (expression)))\n \t{\n-\tcase '1':\n+\tcase tcc_unary:\n \t  return (value_dependent_expression_p \n \t\t  (TREE_OPERAND (expression, 0)));\n-\tcase '<':\n-\tcase '2':\n+\tcase tcc_comparison:\n+\tcase tcc_binary:\n \t  return ((value_dependent_expression_p \n \t\t   (TREE_OPERAND (expression, 0)))\n \t\t  || (value_dependent_expression_p \n \t\t      (TREE_OPERAND (expression, 1))));\n-\tcase 'e':\n+\tcase tcc_expression:\n \t  {\n \t    int i;\n \t    for (i = 0; i < first_rtl_op (TREE_CODE (expression)); ++i)\n@@ -11846,6 +11846,13 @@ value_dependent_expression_p (tree expression)\n \t\treturn true;\n \t    return false;\n \t  }\n+\tcase tcc_reference:\n+\tcase tcc_statement:\n+\t  /* These cannot be value dependent.  */\n+\t  return false;\n+\n+\tdefault:\n+\t  gcc_unreachable ();\n \t}\n     }\n "}, {"sha": "2f1d0e8f3da9a182e41b6d01b6f829e0af77f897", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=6615c446157600e6dbe0b716f48e80a64e49807f", "patch": "@@ -1239,7 +1239,7 @@ finish_mem_initializers (tree mem_inits)\n tree\n finish_parenthesized_expr (tree expr)\n {\n-  if (IS_EXPR_CODE_CLASS (TREE_CODE_CLASS (TREE_CODE (expr))))\n+  if (EXPR_P (expr))\n     /* This inhibits warnings in c_common_truthvalue_conversion.  */\n     TREE_NO_WARNING (expr) = 1;\n "}, {"sha": "28bb512da75319ab52eec6b8503066ea0995d7e4", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=6615c446157600e6dbe0b716f48e80a64e49807f", "patch": "@@ -1,6 +1,6 @@\n /* Language-dependent node constructors for parse phase of GNU compiler.\n    Copyright (C) 1987, 1988, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n-   1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.\n+   1999, 2000, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.\n    Hacked by Michael Tiemann (tiemann@cygnus.com)\n \n This file is part of GCC.\n@@ -1554,12 +1554,12 @@ cp_tree_equal (tree t1, tree t2)\n \n   switch (TREE_CODE_CLASS (code1))\n     {\n-    case '1':\n-    case '2':\n-    case '<':\n-    case 'e':\n-    case 'r':\n-    case 's':\n+    case tcc_unary:\n+    case tcc_binary:\n+    case tcc_comparison:\n+    case tcc_expression:\n+    case tcc_reference:\n+    case tcc_statement:\n       {\n \tint i;\n \n@@ -1570,11 +1570,12 @@ cp_tree_equal (tree t1, tree t2)\n \treturn true;\n       }\n \n-    case 't':\n+    case tcc_type:\n       return same_type_p (t1, t2);\n+    default:\n+      gcc_unreachable ();\n     }\n-\n-  gcc_unreachable ();\n+  /* We can get here with --disable-checking.  */\n   return false;\n }\n "}, {"sha": "990352d492d56e0dcf9e7f94505b1971cec59ab2", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=6615c446157600e6dbe0b716f48e80a64e49807f", "patch": "@@ -4956,7 +4956,7 @@ build_c_cast (tree type, tree expr)\n \t{\n \t  TREE_OVERFLOW (value) = TREE_OVERFLOW (ovalue);\n \n-\t  if (TREE_CODE_CLASS (TREE_CODE (ovalue)) == 'c')\n+\t  if (CONSTANT_CLASS_P (ovalue))\n \t    TREE_CONSTANT_OVERFLOW (value) = TREE_CONSTANT_OVERFLOW (ovalue);\n \t}\n     }"}, {"sha": "62f3102fd1d4c844c9f9af44f0535018275b01ae", "filename": "gcc/dbxout.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Fdbxout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Fdbxout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdbxout.c?ref=6615c446157600e6dbe0b716f48e80a64e49807f", "patch": "@@ -1318,7 +1318,7 @@ dbxout_type (tree type, int full)\n \t   || TREE_CODE (type) == QUAL_UNION_TYPE\n \t   || TREE_CODE (type) == ENUMERAL_TYPE)\n \t  && TYPE_STUB_DECL (type)\n-\t  && TREE_CODE_CLASS (TREE_CODE (TYPE_STUB_DECL (type))) == 'd'\n+\t  && DECL_P (TYPE_STUB_DECL (type))\n \t  && ! DECL_IGNORED_P (TYPE_STUB_DECL (type)))\n \tdebug_queue_symbol (TYPE_STUB_DECL (type));\n       else if (TYPE_NAME (type)\n@@ -2179,19 +2179,19 @@ dbxout_symbol (tree decl, int local ATTRIBUTE_UNUSED)\n            || TREE_CODE (t) == ENUMERAL_TYPE)\n           && TYPE_STUB_DECL (t)\n           && TYPE_STUB_DECL (t) != decl\n-          && TREE_CODE_CLASS (TREE_CODE (TYPE_STUB_DECL (t))) == 'd'\n+          && DECL_P (TYPE_STUB_DECL (t))\n           && ! DECL_IGNORED_P (TYPE_STUB_DECL (t)))\n         {\n           debug_queue_symbol (TYPE_STUB_DECL (t));\n           if (TYPE_NAME (t)\n               && TYPE_NAME (t) != TYPE_STUB_DECL (t)\n               && TYPE_NAME (t) != decl\n-              && TREE_CODE_CLASS (TREE_CODE (TYPE_NAME (t))) == 'd')\n+              && DECL_P (TYPE_NAME (t)))\n             debug_queue_symbol (TYPE_NAME (t));\n         }\n       else if (TYPE_NAME (t)\n \t       && TYPE_NAME (t) != decl\n-\t       && TREE_CODE_CLASS (TREE_CODE (TYPE_NAME (t))) == 'd')\n+\t       && DECL_P (TYPE_NAME (t)))\n         debug_queue_symbol (TYPE_NAME (t));\n     }\n "}, {"sha": "51b3681a0bf4b1aed312757c5b2547aff137c2f3", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=6615c446157600e6dbe0b716f48e80a64e49807f", "patch": "@@ -10918,7 +10918,7 @@ gen_formal_parameter_die (tree node, dw_die_ref context_die)\n \n   switch (TREE_CODE_CLASS (TREE_CODE (node)))\n     {\n-    case 'd':\n+    case tcc_declaration:\n       origin = decl_ultimate_origin (node);\n       if (origin != NULL)\n \tadd_abstract_origin_attribute (parm_die, origin);\n@@ -10939,7 +10939,7 @@ gen_formal_parameter_die (tree node, dw_die_ref context_die)\n \n       break;\n \n-    case 't':\n+    case tcc_type:\n       /* We were called with some kind of a ..._TYPE node.  */\n       add_type_attribute (parm_die, node, 0, 0, context_die);\n       break;\n@@ -12417,7 +12417,8 @@ force_type_die (tree type)\n static dw_die_ref\n setup_namespace_context (tree thing, dw_die_ref context_die)\n {\n-  tree context = DECL_P (thing) ? DECL_CONTEXT (thing) : TYPE_CONTEXT (thing);\n+  tree context = (DECL_P (thing)\n+\t\t  ? DECL_CONTEXT (thing) : TYPE_CONTEXT (thing));\n   if (context && TREE_CODE (context) == NAMESPACE_DECL)\n     /* Force out the namespace.  */\n     context_die = force_decl_die (context);"}, {"sha": "ce597b086e62fcd02c17d607376a4caf32d0f41c", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=6615c446157600e6dbe0b716f48e80a64e49807f", "patch": "@@ -1592,7 +1592,7 @@ set_mem_attributes_minus_bitpos (rtx ref, tree t, int objectp,\n \t}\n \n       /* If this is a constant, we know the alignment.  */\n-      else if (TREE_CODE_CLASS (TREE_CODE (t)) == 'c')\n+      else if (CONSTANT_CLASS_P (t))\n \t{\n \t  align = TYPE_ALIGN (type);\n #ifdef CONSTANT_ALIGNMENT"}, {"sha": "da8304a970867c1438d239be15d25fe4d3dfae61", "filename": "gcc/expr.c", "status": "modified", "additions": 20, "deletions": 14, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=6615c446157600e6dbe0b716f48e80a64e49807f", "patch": "@@ -3527,7 +3527,7 @@ expand_assignment (tree to, tree from, int want_value)\n \t  src = from;\n \t  STRIP_NOPS (src);\n \t  if (TREE_CODE (TREE_TYPE (src)) != INTEGER_TYPE\n-\t      || TREE_CODE_CLASS (TREE_CODE (src)) != '2')\n+\t      || !BINARY_CLASS_P (src))\n \t    break;\n \n \t  op0 = TREE_OPERAND (src, 0);\n@@ -5755,14 +5755,14 @@ safe_from_p (rtx x, tree exp, int top_p)\n   /* Now look at our tree code and possibly recurse.  */\n   switch (TREE_CODE_CLASS (TREE_CODE (exp)))\n     {\n-    case 'd':\n+    case tcc_declaration:\n       exp_rtl = DECL_RTL_IF_SET (exp);\n       break;\n \n-    case 'c':\n+    case tcc_constant:\n       return 1;\n \n-    case 'x':\n+    case tcc_exceptional:\n       if (TREE_CODE (exp) == TREE_LIST)\n \t{\n \t  while (1)\n@@ -5781,25 +5781,25 @@ safe_from_p (rtx x, tree exp, int top_p)\n       else\n \treturn 0;\n \n-    case 's':\n+    case tcc_statement:\n       /* The only case we look at here is the DECL_INITIAL inside a\n \t DECL_EXPR.  */\n       return (TREE_CODE (exp) != DECL_EXPR\n \t      || TREE_CODE (DECL_EXPR_DECL (exp)) != VAR_DECL\n \t      || !DECL_INITIAL (DECL_EXPR_DECL (exp))\n \t      || safe_from_p (x, DECL_INITIAL (DECL_EXPR_DECL (exp)), 0));\n \n-    case '2':\n-    case '<':\n+    case tcc_binary:\n+    case tcc_comparison:\n       if (!safe_from_p (x, TREE_OPERAND (exp, 1), 0))\n \treturn 0;\n       /* Fall through.  */\n \n-    case '1':\n+    case tcc_unary:\n       return safe_from_p (x, TREE_OPERAND (exp, 0), 0);\n \n-    case 'e':\n-    case 'r':\n+    case tcc_expression:\n+    case tcc_reference:\n       /* Now do code-specific tests.  EXP_RTL is set to any rtx we find in\n \t the expression.  If it is set, we conflict iff we are that rtx or\n \t both are in memory.  Otherwise, we check all operands of the\n@@ -5872,6 +5872,11 @@ safe_from_p (rtx x, tree exp, int top_p)\n \t  >= (unsigned int) LAST_AND_UNUSED_TREE_CODE\n \t  && !lang_hooks.safe_from_p (x, exp))\n \treturn 0;\n+      break;\n+\n+    case tcc_type:\n+      /* Should never get a type here.  */\n+      gcc_unreachable ();\n     }\n \n   /* If we have an rtl, find any enclosed object.  Then see if we conflict\n@@ -6068,7 +6073,7 @@ expand_expr_addr_expr_1 (tree exp, rtx target, enum machine_mode tmode,\n      generating ADDR_EXPR of something that isn't an LVALUE.  The only\n      exception here is STRING_CST.  */\n   if (TREE_CODE (exp) == CONSTRUCTOR\n-      || TREE_CODE_CLASS (TREE_CODE (exp)) == 'c')\n+      || CONSTANT_CLASS_P (exp))\n     return XEXP (output_constant_def (exp, 0), 0);\n \n   /* Everything must be something allowed by is_gimple_addressable.  */\n@@ -6400,12 +6405,13 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t  return const0_rtx;\n \t}\n \n-      if (TREE_CODE_CLASS (code) == '1' || code == COMPONENT_REF\n-\t  || code == INDIRECT_REF)\n+      if (TREE_CODE_CLASS (code) == tcc_unary\n+\t  || code == COMPONENT_REF || code == INDIRECT_REF)\n \treturn expand_expr (TREE_OPERAND (exp, 0), const0_rtx, VOIDmode,\n \t\t\t    modifier);\n \n-      else if (TREE_CODE_CLASS (code) == '2' || TREE_CODE_CLASS (code) == '<'\n+      else if (TREE_CODE_CLASS (code) == tcc_binary\n+\t       || TREE_CODE_CLASS (code) == tcc_comparison\n \t       || code == ARRAY_REF || code == ARRAY_RANGE_REF)\n \t{\n \t  expand_expr (TREE_OPERAND (exp, 0), const0_rtx, VOIDmode, modifier);"}, {"sha": "25c84a459149aa0aa73ffb8b267f9aaf07a79fa2", "filename": "gcc/fold-const.c", "status": "modified", "additions": 84, "deletions": 83, "changes": 167, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=6615c446157600e6dbe0b716f48e80a64e49807f", "patch": "@@ -2281,7 +2281,7 @@ combine_comparisons (enum tree_code code, enum tree_code lcode,\n static int\n truth_value_p (enum tree_code code)\n {\n-  return (TREE_CODE_CLASS (code) == '<'\n+  return (TREE_CODE_CLASS (code) == tcc_comparison\n \t  || code == TRUTH_AND_EXPR || code == TRUTH_ANDIF_EXPR\n \t  || code == TRUTH_OR_EXPR || code == TRUTH_ORIF_EXPR\n \t  || code == TRUTH_XOR_EXPR || code == TRUTH_NOT_EXPR);\n@@ -2420,7 +2420,7 @@ operand_equal_p (tree arg0, tree arg1, unsigned int flags)\n \n   switch (TREE_CODE_CLASS (TREE_CODE (arg0)))\n     {\n-    case '1':\n+    case tcc_unary:\n       /* Two conversions are equal only if signedness and modes match.  */\n       switch (TREE_CODE (arg0))\n         {\n@@ -2441,8 +2441,8 @@ operand_equal_p (tree arg0, tree arg1, unsigned int flags)\n       return operand_equal_p (TREE_OPERAND (arg0, 0),\n \t\t\t      TREE_OPERAND (arg1, 0), flags);\n \n-    case '<':\n-    case '2':\n+    case tcc_comparison:\n+    case tcc_binary:\n       if (operand_equal_p (TREE_OPERAND (arg0, 0),\n \t\t\t   TREE_OPERAND (arg1, 0), flags)\n \t  && operand_equal_p (TREE_OPERAND (arg0, 1),\n@@ -2456,7 +2456,7 @@ operand_equal_p (tree arg0, tree arg1, unsigned int flags)\n \t      && operand_equal_p (TREE_OPERAND (arg0, 1),\n \t\t\t\t  TREE_OPERAND (arg1, 0), flags));\n \n-    case 'r':\n+    case tcc_reference:\n       /* If either of the pointer (or reference) expressions we are\n \t dereferencing contain a side effect, these cannot be equal.  */\n       if (TREE_SIDE_EFFECTS (arg0)\n@@ -2503,7 +2503,7 @@ operand_equal_p (tree arg0, tree arg1, unsigned int flags)\n \t  return 0;\n \t}\n \n-    case 'e':\n+    case tcc_expression:\n       switch (TREE_CODE (arg0))\n \t{\n \tcase ADDR_EXPR:\n@@ -2570,7 +2570,7 @@ operand_equal_p (tree arg0, tree arg1, unsigned int flags)\n \t  return 0;\n \t}\n \n-    case 'd':\n+    case tcc_declaration:\n       /* Consider __builtin_sqrt equal to sqrt.  */\n       return (TREE_CODE (arg0) == FUNCTION_DECL\n \t      && DECL_BUILT_IN (arg0) && DECL_BUILT_IN (arg1)\n@@ -2652,42 +2652,42 @@ static int\n twoval_comparison_p (tree arg, tree *cval1, tree *cval2, int *save_p)\n {\n   enum tree_code code = TREE_CODE (arg);\n-  char class = TREE_CODE_CLASS (code);\n+  enum tree_code_class class = TREE_CODE_CLASS (code);\n \n-  /* We can handle some of the 'e' cases here.  */\n-  if (class == 'e' && code == TRUTH_NOT_EXPR)\n-    class = '1';\n-  else if (class == 'e'\n+  /* We can handle some of the tcc_expression cases here.  */\n+  if (class == tcc_expression && code == TRUTH_NOT_EXPR)\n+    class = tcc_unary;\n+  else if (class == tcc_expression\n \t   && (code == TRUTH_ANDIF_EXPR || code == TRUTH_ORIF_EXPR\n \t       || code == COMPOUND_EXPR))\n-    class = '2';\n+    class = tcc_binary;\n \n-  else if (class == 'e' && code == SAVE_EXPR\n+  else if (class == tcc_expression && code == SAVE_EXPR\n \t   && ! TREE_SIDE_EFFECTS (TREE_OPERAND (arg, 0)))\n     {\n       /* If we've already found a CVAL1 or CVAL2, this expression is\n \t two complex to handle.  */\n       if (*cval1 || *cval2)\n \treturn 0;\n \n-      class = '1';\n+      class = tcc_unary;\n       *save_p = 1;\n     }\n \n   switch (class)\n     {\n-    case '1':\n+    case tcc_unary:\n       return twoval_comparison_p (TREE_OPERAND (arg, 0), cval1, cval2, save_p);\n \n-    case '2':\n+    case tcc_binary:\n       return (twoval_comparison_p (TREE_OPERAND (arg, 0), cval1, cval2, save_p)\n \t      && twoval_comparison_p (TREE_OPERAND (arg, 1),\n \t\t\t\t      cval1, cval2, save_p));\n \n-    case 'c':\n+    case tcc_constant:\n       return 1;\n \n-    case 'e':\n+    case tcc_expression:\n       if (code == COND_EXPR)\n \treturn (twoval_comparison_p (TREE_OPERAND (arg, 0),\n \t\t\t\t     cval1, cval2, save_p)\n@@ -2697,7 +2697,7 @@ twoval_comparison_p (tree arg, tree *cval1, tree *cval2, int *save_p)\n \t\t\t\t\tcval1, cval2, save_p));\n       return 0;\n \n-    case '<':\n+    case tcc_comparison:\n       /* First see if we can handle the first operand, then the second.  For\n \t the second operand, we know *CVAL1 can't be zero.  It must be that\n \t one side of the comparison is each of the values; test for the\n@@ -2745,30 +2745,30 @@ eval_subst (tree arg, tree old0, tree new0, tree old1, tree new1)\n {\n   tree type = TREE_TYPE (arg);\n   enum tree_code code = TREE_CODE (arg);\n-  char class = TREE_CODE_CLASS (code);\n+  enum tree_code_class class = TREE_CODE_CLASS (code);\n \n-  /* We can handle some of the 'e' cases here.  */\n-  if (class == 'e' && code == TRUTH_NOT_EXPR)\n-    class = '1';\n-  else if (class == 'e'\n+  /* We can handle some of the tcc_expression cases here.  */\n+  if (class == tcc_expression && code == TRUTH_NOT_EXPR)\n+    class = tcc_unary;\n+  else if (class == tcc_expression\n \t   && (code == TRUTH_ANDIF_EXPR || code == TRUTH_ORIF_EXPR))\n-    class = '2';\n+    class = tcc_binary;\n \n   switch (class)\n     {\n-    case '1':\n+    case tcc_unary:\n       return fold (build1 (code, type,\n \t\t\t   eval_subst (TREE_OPERAND (arg, 0),\n \t\t\t\t       old0, new0, old1, new1)));\n \n-    case '2':\n+    case tcc_binary:\n       return fold (build2 (code, type,\n \t\t\t   eval_subst (TREE_OPERAND (arg, 0),\n \t\t\t\t       old0, new0, old1, new1),\n \t\t\t   eval_subst (TREE_OPERAND (arg, 1),\n \t\t\t\t       old0, new0, old1, new1)));\n \n-    case 'e':\n+    case tcc_expression:\n       switch (code)\n \t{\n \tcase SAVE_EXPR:\n@@ -2790,7 +2790,7 @@ eval_subst (tree arg, tree old0, tree new0, tree old1, tree new1)\n \t}\n       /* Fall through - ???  */\n \n-    case '<':\n+    case tcc_comparison:\n       {\n \ttree arg0 = TREE_OPERAND (arg, 0);\n \ttree arg1 = TREE_OPERAND (arg, 1);\n@@ -2890,7 +2890,7 @@ invert_truthvalue (tree arg)\n      floating-point non-equality comparisons, in which case we just\n      enclose a TRUTH_NOT_EXPR around what we have.  */\n \n-  if (TREE_CODE_CLASS (code) == '<')\n+  if (TREE_CODE_CLASS (code) == tcc_comparison)\n     {\n       tree op_type = TREE_TYPE (TREE_OPERAND (arg, 0));\n       if (FLOAT_TYPE_P (op_type)\n@@ -3413,7 +3413,7 @@ simple_operand_p (tree exp)\n \t     == TYPE_MODE (TREE_TYPE (TREE_OPERAND (exp, 0)))))\n     exp = TREE_OPERAND (exp, 0);\n \n-  return (TREE_CODE_CLASS (TREE_CODE (exp)) == 'c'\n+  return (CONSTANT_CLASS_P (exp)\n \t  || (DECL_P (exp)\n \t      && ! TREE_ADDRESSABLE (exp)\n \t      && ! TREE_THIS_VOLATILE (exp)\n@@ -3484,7 +3484,7 @@ range_binop (enum tree_code code, tree type, tree arg0, int upper0_p,\n       return TREE_CODE (tem) == INTEGER_CST ? tem : 0;\n     }\n \n-  if (TREE_CODE_CLASS (code) != '<')\n+  if (TREE_CODE_CLASS (code) != tcc_comparison)\n     return 0;\n \n   /* Set SGN[01] to -1 if ARG[01] is a lower bound, 1 for upper, and 0\n@@ -3555,13 +3555,13 @@ make_range (tree exp, int *pin_p, tree *plow, tree *phigh)\n \t{\n \t  if (first_rtl_op (code) > 0)\n \t    arg0 = TREE_OPERAND (exp, 0);\n-\t  if (TREE_CODE_CLASS (code) == '<'\n-\t      || TREE_CODE_CLASS (code) == '1'\n-\t      || TREE_CODE_CLASS (code) == '2')\n+\t  if (TREE_CODE_CLASS (code) == tcc_comparison\n+\t      || TREE_CODE_CLASS (code) == tcc_unary\n+\t      || TREE_CODE_CLASS (code) == tcc_binary)\n \t    arg0_type = TREE_TYPE (arg0);\n-\t  if (TREE_CODE_CLASS (code) == '2'\n-\t      || TREE_CODE_CLASS (code) == '<'\n-\t      || (TREE_CODE_CLASS (code) == 'e'\n+\t  if (TREE_CODE_CLASS (code) == tcc_binary\n+\t      || TREE_CODE_CLASS (code) == tcc_comparison\n+\t      || (TREE_CODE_CLASS (code) == tcc_expression\n \t\t  && TREE_CODE_LENGTH (code) > 1))\n \t    arg1 = TREE_OPERAND (exp, 1);\n \t}\n@@ -4192,7 +4192,7 @@ fold_cond_expr_with_comparison (tree type, tree arg0, tree arg1, tree arg2)\n \ttem = fold (build1 (ABS_EXPR, TREE_TYPE (arg1), arg1));\n \treturn negate_expr (fold_convert (type, tem));\n       default:\n-\tgcc_assert (TREE_CODE_CLASS (comp_code) == '<');\n+\tgcc_assert (TREE_CODE_CLASS (comp_code) == tcc_comparison);\n \tbreak;\n       }\n \n@@ -4296,7 +4296,7 @@ fold_cond_expr_with_comparison (tree type, tree arg0, tree arg1, tree arg2)\n \t    return pedantic_non_lvalue (fold_convert (type, arg1));\n \t  break;\n \tdefault:\n-\t  gcc_assert (TREE_CODE_CLASS (comp_code) == '<');\n+\t  gcc_assert (TREE_CODE_CLASS (comp_code) == tcc_comparison);\n \t  break;\n \t}\n     }\n@@ -4569,7 +4569,8 @@ fold_truthop (enum tree_code code, tree truth_type, tree lhs, tree rhs)\n       rcode = NE_EXPR;\n     }\n \n-  if (TREE_CODE_CLASS (lcode) != '<' || TREE_CODE_CLASS (rcode) != '<')\n+  if (TREE_CODE_CLASS (lcode) != tcc_comparison\n+      || TREE_CODE_CLASS (rcode) != tcc_comparison)\n     return 0;\n \n   ll_arg = TREE_OPERAND (lhs, 0);\n@@ -5073,10 +5074,10 @@ extract_muldiv_1 (tree t, tree c, enum tree_code code, tree wide_type)\n   if (integer_zerop (c))\n     return NULL_TREE;\n \n-  if (TREE_CODE_CLASS (tcode) == '1')\n+  if (TREE_CODE_CLASS (tcode) == tcc_unary)\n     op0 = TREE_OPERAND (t, 0);\n \n-  if (TREE_CODE_CLASS (tcode) == '2')\n+  if (TREE_CODE_CLASS (tcode) == tcc_binary)\n     op0 = TREE_OPERAND (t, 0), op1 = TREE_OPERAND (t, 1);\n \n   /* Note that we need not handle conditional operations here since fold\n@@ -5094,10 +5095,10 @@ extract_muldiv_1 (tree t, tree c, enum tree_code code, tree wide_type)\n \n     case CONVERT_EXPR:  case NON_LVALUE_EXPR:  case NOP_EXPR:\n       /* If op0 is an expression ...  */\n-      if ((TREE_CODE_CLASS (TREE_CODE (op0)) == '<'\n-\t   || TREE_CODE_CLASS (TREE_CODE (op0)) == '1'\n-\t   || TREE_CODE_CLASS (TREE_CODE (op0)) == '2'\n-\t   || TREE_CODE_CLASS (TREE_CODE (op0)) == 'e')\n+      if ((COMPARISON_CLASS_P (op0)\n+\t   || UNARY_CLASS_P (op0)\n+\t   || BINARY_CLASS_P (op0)\n+\t   || EXPRESSION_CLASS_P (op0))\n \t  /* ... and is unsigned, and its type is smaller than ctype,\n \t     then we cannot pass through as widening.  */\n \t  && ((TYPE_UNSIGNED (TREE_TYPE (op0))\n@@ -5990,14 +5991,14 @@ fold (tree expr)\n   tree tem;\n   tree arg0 = NULL_TREE, arg1 = NULL_TREE;\n   enum tree_code code = TREE_CODE (t);\n-  int kind = TREE_CODE_CLASS (code);\n+  enum tree_code_class kind = TREE_CODE_CLASS (code);\n \n   /* WINS will be nonzero when the switch is done\n      if all operands are constant.  */\n   int wins = 1;\n \n   /* Return right away if a constant.  */\n-  if (kind == 'c')\n+  if (kind == tcc_constant)\n     return t;\n \n   if (code == NOP_EXPR || code == FLOAT_EXPR || code == CONVERT_EXPR)\n@@ -6046,7 +6047,7 @@ fold (tree expr)\n \t     of the arguments so that their form can be studied.  In any\n \t     cases, the appropriate type conversions should be put back in\n \t     the tree that will get out of the constant folder.  */\n-\t  if (kind == '<')\n+\t  if (kind == tcc_comparison)\n \t    STRIP_SIGN_NOPS (op);\n \t  else\n \t    STRIP_NOPS (op);\n@@ -6118,7 +6119,7 @@ fold (tree expr)\n       return tem;\n     }\n \n-  if (TREE_CODE_CLASS (code) == '1')\n+  if (TREE_CODE_CLASS (code) == tcc_unary)\n     {\n       if (TREE_CODE (arg0) == COMPOUND_EXPR)\n \treturn build2 (COMPOUND_EXPR, type, TREE_OPERAND (arg0, 0),\n@@ -6165,7 +6166,7 @@ fold (tree expr)\n \t\t\t\t  TREE_OPERAND (TREE_OPERAND (tem, 2), 0)));\n \t  return tem;\n \t}\n-      else if (TREE_CODE_CLASS (TREE_CODE (arg0)) == '<')\n+      else if (COMPARISON_CLASS_P (arg0))\n \t{\n \t  if (TREE_CODE (type) == BOOLEAN_TYPE)\n \t    {\n@@ -6181,16 +6182,16 @@ fold (tree expr)\n \t\t\t\t\t       integer_zero_node))));\n \t}\n    }\n-  else if (TREE_CODE_CLASS (code) == '<'\n+  else if (TREE_CODE_CLASS (code) == tcc_comparison\n \t   && TREE_CODE (arg0) == COMPOUND_EXPR)\n     return build2 (COMPOUND_EXPR, type, TREE_OPERAND (arg0, 0),\n \t\t   fold (build2 (code, type, TREE_OPERAND (arg0, 1), arg1)));\n-  else if (TREE_CODE_CLASS (code) == '<'\n+  else if (TREE_CODE_CLASS (code) == tcc_comparison\n \t   && TREE_CODE (arg1) == COMPOUND_EXPR)\n     return build2 (COMPOUND_EXPR, type, TREE_OPERAND (arg1, 0),\n \t\t   fold (build2 (code, type, arg0, TREE_OPERAND (arg1, 1))));\n-  else if (TREE_CODE_CLASS (code) == '2'\n-\t   || TREE_CODE_CLASS (code) == '<')\n+  else if (TREE_CODE_CLASS (code) == tcc_binary\n+\t   || TREE_CODE_CLASS (code) == tcc_comparison)\n     {\n       if (TREE_CODE (arg0) == COMPOUND_EXPR)\n \treturn build2 (COMPOUND_EXPR, type, TREE_OPERAND (arg0, 0),\n@@ -6202,17 +6203,15 @@ fold (tree expr)\n \t\t       fold (build2 (code, type,\n \t\t\t\t     arg0, TREE_OPERAND (arg1, 1))));\n \n-      if (TREE_CODE (arg0) == COND_EXPR\n-\t  || TREE_CODE_CLASS (TREE_CODE (arg0)) == '<')\n+      if (TREE_CODE (arg0) == COND_EXPR || COMPARISON_CLASS_P (arg0))\n \t{\n \t  tem = fold_binary_op_with_conditional_arg (code, type, arg0, arg1,\n \t\t\t\t\t\t     /*cond_first_p=*/1);\n \t  if (tem != NULL_TREE)\n \t    return tem;\n \t}\n \n-      if (TREE_CODE (arg1) == COND_EXPR\n-\t  || TREE_CODE_CLASS (TREE_CODE (arg1)) == '<')\n+      if (TREE_CODE (arg1) == COND_EXPR || COMPARISON_CLASS_P (arg1))\n \t{\n \t  tem = fold_binary_op_with_conditional_arg (code, type, arg1, arg0,\n \t\t\t\t\t\t     /*cond_first_p=*/0);\n@@ -6382,7 +6381,7 @@ fold (tree expr)\n       /* Convert (T1)((T2)X op Y) into (T1)X op Y, for pointer types T1 and\n \t T2 being pointers to types of the same size.  */\n       if (POINTER_TYPE_P (TREE_TYPE (t))\n-\t  && TREE_CODE_CLASS (TREE_CODE (arg0)) == '2'\n+\t  && BINARY_CLASS_P (arg0)\n \t  && TREE_CODE (TREE_OPERAND (arg0, 0)) == NOP_EXPR\n \t  && POINTER_TYPE_P (TREE_TYPE (TREE_OPERAND (arg0, 0))))\n \t{\n@@ -8772,7 +8771,7 @@ fold (tree expr)\n \t for reasons given above each one.\n \n          Also try swapping the arguments and inverting the conditional.  */\n-      if (TREE_CODE_CLASS (TREE_CODE (arg0)) == '<'\n+      if (COMPARISON_CLASS_P (arg0)\n \t  && operand_equal_for_comparison_p (TREE_OPERAND (arg0, 0),\n \t\t\t\t\t     arg1, TREE_OPERAND (arg0, 1))\n \t  && !HONOR_SIGNED_ZEROS (TYPE_MODE (TREE_TYPE (arg1))))\n@@ -8784,14 +8783,14 @@ fold (tree expr)\n \t    return tem;\n \t}\n \n-      if (TREE_CODE_CLASS (TREE_CODE (arg0)) == '<'\n+      if (COMPARISON_CLASS_P (arg0)\n \t  && operand_equal_for_comparison_p (TREE_OPERAND (arg0, 0),\n \t\t\t\t\t     TREE_OPERAND (t, 2),\n \t\t\t\t\t     TREE_OPERAND (arg0, 1))\n \t  && !HONOR_SIGNED_ZEROS (TYPE_MODE (TREE_TYPE (TREE_OPERAND (t, 2)))))\n \t{\n \t  tem = invert_truthvalue (arg0);\n-\t  if (TREE_CODE_CLASS (TREE_CODE (tem)) == '<')\n+\t  if (COMPARISON_CLASS_P (tem))\n \t    {\n \t      tem = fold_cond_expr_with_comparison (type, tem,\n \t\t\t\t\t\t    TREE_OPERAND (t, 2),\n@@ -9055,14 +9054,15 @@ fold_checksum_tree (tree expr, struct md5_ctx *ctx, htab_t ht)\n     return;\n   *slot = expr;\n   code = TREE_CODE (expr);\n-  if (TREE_CODE_CLASS (code) == 'd' && DECL_ASSEMBLER_NAME_SET_P (expr))\n+  if (TREE_CODE_CLASS (code) == tcc_declaration\n+      && DECL_ASSEMBLER_NAME_SET_P (expr))\n     {\n       /* Allow DECL_ASSEMBLER_NAME to be modified.  */\n       memcpy (buf, expr, tree_size (expr));\n       expr = (tree) buf;\n       SET_DECL_ASSEMBLER_NAME (expr, NULL);\n     }\n-  else if (TREE_CODE_CLASS (code) == 't'\n+  else if (TREE_CODE_CLASS (code) == tcc_type\n \t   && (TYPE_POINTER_TO (expr) || TYPE_REFERENCE_TO (expr)\n \t       || TYPE_CACHED_VALUES_P (expr)))\n     {\n@@ -9076,11 +9076,12 @@ fold_checksum_tree (tree expr, struct md5_ctx *ctx, htab_t ht)\n     }\n   md5_process_bytes (expr, tree_size (expr), ctx);\n   fold_checksum_tree (TREE_TYPE (expr), ctx, ht);\n-  if (TREE_CODE_CLASS (code) != 't' && TREE_CODE_CLASS (code) != 'd')\n+  if (TREE_CODE_CLASS (code) != tcc_type\n+      && TREE_CODE_CLASS (code) != tcc_declaration)\n     fold_checksum_tree (TREE_CHAIN (expr), ctx, ht);\n   switch (TREE_CODE_CLASS (code))\n     {\n-    case 'c':\n+    case tcc_constant:\n       switch (code)\n \t{\n \tcase STRING_CST:\n@@ -9098,7 +9099,7 @@ fold_checksum_tree (tree expr, struct md5_ctx *ctx, htab_t ht)\n \t  break;\n \t}\n       break;\n-    case 'x':\n+    case tcc_exceptional:\n       switch (code)\n \t{\n \tcase TREE_LIST:\n@@ -9113,17 +9114,17 @@ fold_checksum_tree (tree expr, struct md5_ctx *ctx, htab_t ht)\n \t  break;\n \t}\n       break;\n-    case 'e':\n-    case 'r':\n-    case '<':\n-    case '1':\n-    case '2':\n-    case 's':\n+    case tcc_expression:\n+    case tcc_reference:\n+    case tcc_comparison:\n+    case tcc_unary:\n+    case tcc_binary:\n+    case tcc_statement:\n       len = first_rtl_op (code);\n       for (i = 0; i < len; ++i)\n \tfold_checksum_tree (TREE_OPERAND (expr, i), ctx, ht);\n       break;\n-    case 'd':\n+    case tcc_declaration:\n       fold_checksum_tree (DECL_SIZE (expr), ctx, ht);\n       fold_checksum_tree (DECL_SIZE_UNIT (expr), ctx, ht);\n       fold_checksum_tree (DECL_NAME (expr), ctx, ht);\n@@ -9136,7 +9137,7 @@ fold_checksum_tree (tree expr, struct md5_ctx *ctx, htab_t ht)\n       fold_checksum_tree (DECL_ATTRIBUTES (expr), ctx, ht);\n       fold_checksum_tree (DECL_VINDEX (expr), ctx, ht);\n       break;\n-    case 't':\n+    case tcc_type:\n       if (TREE_CODE (expr) == ENUMERAL_TYPE)\n         fold_checksum_tree (TYPE_VALUES (expr), ctx, ht);\n       fold_checksum_tree (TYPE_SIZE (expr), ctx, ht);\n@@ -9630,7 +9631,7 @@ tree_expr_nonzero_p (tree t)\n \t  return !DECL_WEAK (base);\n \n \t/* Constants are never weak.  */\n-\tif (TREE_CODE_CLASS (TREE_CODE (base)) == 'c')\n+\tif (CONSTANT_CLASS_P (base))\n \t  return true;\n \n \treturn false;\n@@ -10554,12 +10555,12 @@ fold_ignored_result (tree t)\n   for (;;)\n     switch (TREE_CODE_CLASS (TREE_CODE (t)))\n       {\n-      case '1':\n+      case tcc_unary:\n \tt = TREE_OPERAND (t, 0);\n \tbreak;\n \n-      case '2':\n-      case '<':\n+      case tcc_binary:\n+      case tcc_comparison:\n \tif (!TREE_SIDE_EFFECTS (TREE_OPERAND (t, 1)))\n \t  t = TREE_OPERAND (t, 0);\n \telse if (!TREE_SIDE_EFFECTS (TREE_OPERAND (t, 0)))\n@@ -10568,7 +10569,7 @@ fold_ignored_result (tree t)\n \t  return t;\n \tbreak;\n \n-      case 'e':\n+      case tcc_expression:\n \tswitch (TREE_CODE (t))\n \t  {\n \t  case COMPOUND_EXPR:"}, {"sha": "9053f3652d18c7d5bc83b80873e49024be94a72d", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 71, "deletions": 65, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=6615c446157600e6dbe0b716f48e80a64e49807f", "patch": "@@ -1,3 +1,9 @@\n+2004-09-17  Jeffrey D. Oldham  <oldham@codesourcery.com>\n+\t    Zack Weinberg  <zack@codesourcery.com>\n+\n+\t* f95-lang.c, trans-expr.c, trans.c: Update for new tree-class\n+\tenumeration constants.\n+\n 2004-09-17  Paul Brook  <paul@codesourcery.com>\n \n \t* gfortran.h (struct gfc_linebuf): Don't use C99 empty arrays.\n@@ -312,30 +318,30 @@\n \n 2004-08-26  Richard Henderson  <rth@redhat.com>\n \n-        * arith.c: Include system.h, not real system headers.\n-        (MPZ_NULL, MPF_NULL, DEF_GFC_INTEGER_KIND, DEF_GFC_LOGICAL_KIND,\n-        DEF_GFC_REAL_KIND, GFC_SP_KIND, GFC_SP_PREC, GFC_SP_EMIN, GFC_SP_EMAX,\n-        GFC_DP_KIND, GFC_DP_PREC, GFC_DP_EMIN, GFC_DP_EMAX, GFC_QP_KIND,\n-        GFC_QP_PREC, GFC_QP_EMIN, GFC_QP_EMAX): Remove.\n-        (gfc_integer_kinds, gfc_logical_kinds, gfc_real_kinds,\n-        gfc_index_integer_kind, gfc_default_integer_kind,\n-        gfc_default_real_kind,gfc_default_double_kind,\n-        gfc_default_character_kind, gfc_default_logical_kind,\n-        gfc_default_complex_kind, validate_integer, validate_real,\n-        validate_logical, validate_character,\n-        gfc_validate_kind): Move to trans-types.c.\n-        (gfc_set_model_kind): Use gfc_validate_kind.\n-        (gfc_set_model): Just copy the current precision to default.\n-        (gfc_arith_init_1): Use mpfr precision 128 for integer setup.\n-        * f95-lang.c (gfc_init_decl_processing): Invoke gfc_init_kinds.\n-        * gfortran.h: Update file commentary.\n-        * trans-types.c (MAX_INT_KINDS, MAX_REAL_KINDS): New.\n-        (gfc_default_integer_kind_1, gfc_default_real_kind_1,\n-        gfc_default_double_kind_1, gfc_default_character_kind_1,\n-        gfc_default_logical_kind_1, gfc_default_complex_kind_1): New.\n-        (gfc_init_kinds): New.\n-        (gfc_init_types): Don't set gfc_index_integer_kind here.\n-        * trans-types.h (gfc_init_kinds): Declare.\n+\t* arith.c: Include system.h, not real system headers.\n+\t(MPZ_NULL, MPF_NULL, DEF_GFC_INTEGER_KIND, DEF_GFC_LOGICAL_KIND,\n+\tDEF_GFC_REAL_KIND, GFC_SP_KIND, GFC_SP_PREC, GFC_SP_EMIN, GFC_SP_EMAX,\n+\tGFC_DP_KIND, GFC_DP_PREC, GFC_DP_EMIN, GFC_DP_EMAX, GFC_QP_KIND,\n+\tGFC_QP_PREC, GFC_QP_EMIN, GFC_QP_EMAX): Remove.\n+\t(gfc_integer_kinds, gfc_logical_kinds, gfc_real_kinds,\n+\tgfc_index_integer_kind, gfc_default_integer_kind,\n+\tgfc_default_real_kind,gfc_default_double_kind,\n+\tgfc_default_character_kind, gfc_default_logical_kind,\n+\tgfc_default_complex_kind, validate_integer, validate_real,\n+\tvalidate_logical, validate_character,\n+\tgfc_validate_kind): Move to trans-types.c.\n+\t(gfc_set_model_kind): Use gfc_validate_kind.\n+\t(gfc_set_model): Just copy the current precision to default.\n+\t(gfc_arith_init_1): Use mpfr precision 128 for integer setup.\n+\t* f95-lang.c (gfc_init_decl_processing): Invoke gfc_init_kinds.\n+\t* gfortran.h: Update file commentary.\n+\t* trans-types.c (MAX_INT_KINDS, MAX_REAL_KINDS): New.\n+\t(gfc_default_integer_kind_1, gfc_default_real_kind_1,\n+\tgfc_default_double_kind_1, gfc_default_character_kind_1,\n+\tgfc_default_logical_kind_1, gfc_default_complex_kind_1): New.\n+\t(gfc_init_kinds): New.\n+\t(gfc_init_types): Don't set gfc_index_integer_kind here.\n+\t* trans-types.h (gfc_init_kinds): Declare.\n \t* doc/invoke.texi: Clarify DOUBLE PRECISION behaviour wrt -r8.\n \n 2004-08-26  Tobias Schlueter  <tobias.schlueter@physik.uni-muenchen.de>\n@@ -422,7 +428,7 @@\n \tbuild.\n \t* trans-array.c (gfc_conv_descriptor_data,\n \tgfc_conv_descriptor_offset, gfc_conv_descriptor_dimension,\n-\tgfc_conv_descriptor_stride, gfc_conv_descriptor_lbound, \n+\tgfc_conv_descriptor_stride, gfc_conv_descriptor_lbound,\n \tgfc_conv_descriptor_ubound, gfc_trans_allocate_array_storage,\n \tgfc_trans_allocate_temp_array,\n \tgfc_trans_array_constructor_subarray,\n@@ -480,7 +486,7 @@\n \n 2004-08-25  Tobias Schlueter  <tobias.schlueter@physik.uni-muenchen.de>\n \n-\t* trans-const.c (gfc_conv_mpz_to_tree): Change call to \n+\t* trans-const.c (gfc_conv_mpz_to_tree): Change call to\n \tbuild_int_cst to build_int_cst_wide in accordance to Nathan's\n \tprevious patch.\n \n@@ -503,7 +509,7 @@\n \n 2004-08-24  Tobias Schlueter  <tobias.schlueter@physik.uni-muenchen.de>\n \n-\t* trans-decl.c, trans-types.c: Add and remove blank lines as \n+\t* trans-decl.c, trans-types.c: Add and remove blank lines as\n \trequired.\n \n 2004-08-24  Richard Henderson  <rth@redhat.com>\n@@ -512,9 +518,9 @@\n \n 2004-08-24  Tobias Schlueter  <tobias.schlueter@physik.uni-muenchen.de>\n \n-\t* resolve.c (merge_argument_lists): Revert unintentionally \n+\t* resolve.c (merge_argument_lists): Revert unintentionally\n \tcommitted change.\n-\t\n+\n 2004-08-24  Tobias Schlueter  <tobias.schlueter@physik.uni-muenchen.de>\n \n \t* trans-decl.c (build_function_decl): Fix spelling in comment.\n@@ -545,15 +551,15 @@\n 2004-08-22  Richard Henderson  <rth@redhat.com>\n \n \tPR 13465\n-        * data.c (find_con_by_offset): Search ordered list; handle\n-        elements with repeat counts.\n-        (gfc_assign_data_value_range): New.\n-        * gfortran.h (struct gfc_data_value): Make repeat unsigned.\n-        (gfc_assign_data_value_range): Declare.\n-        * match.c (top_val_list): Extract repeat count into a temporary.\n-        * resolve.c (values): Make left unsigned.\n-        (next_data_value): Don't decrement left.\n-        (check_data_variable): Use gfc_assign_data_value_range.\n+\t* data.c (find_con_by_offset): Search ordered list; handle\n+\telements with repeat counts.\n+\t(gfc_assign_data_value_range): New.\n+\t* gfortran.h (struct gfc_data_value): Make repeat unsigned.\n+\t(gfc_assign_data_value_range): Declare.\n+\t* match.c (top_val_list): Extract repeat count into a temporary.\n+\t* resolve.c (values): Make left unsigned.\n+\t(next_data_value): Don't decrement left.\n+\t(check_data_variable): Use gfc_assign_data_value_range.\n \n 2004-08-22  Tobias Schlueter  <tobias.schlueter@physik.uni-muenchen.de>\n \n@@ -1416,7 +1422,7 @@\n \tunused variables if they're use associated.\n \n 2004-06-14  Tobias Schlueter  <tobias.schlueter@physik.uni-muenchen.de>\n-        Andrew Vaught <andyv@firstinter.net>\n+\tAndrew Vaught <andyv@firstinter.net>\n \n \tPR fortran/14928\n \t* gfortran.h (gfc_check_f): Add new field f3ml.\n@@ -1769,7 +1775,7 @@\n 2004-05-17  Steve Kargl  <kargls@comcast.net>\n \n \t* arith.c (gfc_real2complex): Range checking wrong part of complex\n-        number.\n+\tnumber.\n \n 2004-05-16  Paul Brook  <paul@codesourcery.com>\n \n@@ -1911,15 +1917,15 @@\n \n 2004-05-14  Tobias Schlueter  <tobias.schlueter@physik.uni-muenchen.de>\n \n-        PR fortran/14066\n+\tPR fortran/14066\n \t* match.c (gfc_match_do): Allow infinite loops with\n \tlabel-do-stmt. Do not enforce space after comma.\n \n 2004-05-14  Tobias Schlueter  <tobias.schlueter@physik.uni-muenchen.de>\n \n-        PR fortran/15051\n+\tPR fortran/15051\n \t* parse.c (parse_interface): Allow empty INTERFACE, remove\n-        seen_body.\n+\tseen_body.\n \n 2004-05-14  Tobias Schlueter  <tobias.schlueter@physik.uni-muenchen.de>\n \n@@ -1941,7 +1947,7 @@\n \n \tPR fortran/14568\n \t* trans-decl.c (generate_local_decl): Don't warn for unused\n-        variables which are in common blocks.\n+\tvariables which are in common blocks.\n \n 2004-05-13  Diego Novillo  <dnovillo@redhat.com>\n \n@@ -2166,9 +2172,9 @@\n \n 2004-03-24  Bud Davis  <bdavis9659@comcast.net>\n \n-        PR 14055\n+\tPR 14055\n \t* arith.c (gfc_convert_integer,gfc_convert_real):  Removed leading '+'\n-        before conversion by gmp library call.\n+\tbefore conversion by gmp library call.\n \n 2004-03-24  Bud Davis  <bdavis9659@comcast.net>\n \n@@ -3103,8 +3109,8 @@\n \t* lang-options.h: Remove.\n \n 2003-07-23  Arnaud Desitter  <arnaud.desitter@geography.oxford.ac.uk>\n-        * iresolve.c (g95_resolve_transpose): Proper variable in switch.\n-        * simplify.c (g95_simplify_nearest): Fix typo and use a correct test\n+\t* iresolve.c (g95_resolve_transpose): Proper variable in switch.\n+\t* simplify.c (g95_simplify_nearest): Fix typo and use a correct test\n \ton kind.\n \n 2003-07-22  Steven Bosscher  <steven@gcc.gnu.org>\n@@ -3749,21 +3755,21 @@\n \n 2003-04-10  Canqun Yang  <canqun@yahoo.com.cn>\n \n-        * trans-stmt.c (g95_trans_forall): Implement WHERE inside FORALL.\n-        (g95_trans_forall_body): New function.\n+\t* trans-stmt.c (g95_trans_forall): Implement WHERE inside FORALL.\n+\t(g95_trans_forall_body): New function.\n \n 2003-04-10  Canqun Yang  <canqun@yahoo.com.cn>\n \n-        * resolve.c (resove_where): New function.\n-        (resolve_where_shape): New function.\n-        (resolve_code): Add call to 'resolve_where'\n-        * trans-stmt.c (g95_trans_where): Modified.\n-        (g95_trans_where_2): New function.\n-        (g95_trans_where_assign): New function.\n-        (g95_evaluate_where_mask): New function.\n-        (g95_add_to_stmt_list): New function.\n-        (g95_get_temp_expr): New function.\n-        * trans.h (where_stmt_list): New structure.\n+\t* resolve.c (resove_where): New function.\n+\t(resolve_where_shape): New function.\n+\t(resolve_code): Add call to 'resolve_where'\n+\t* trans-stmt.c (g95_trans_where): Modified.\n+\t(g95_trans_where_2): New function.\n+\t(g95_trans_where_assign): New function.\n+\t(g95_evaluate_where_mask): New function.\n+\t(g95_add_to_stmt_list): New function.\n+\t(g95_get_temp_expr): New function.\n+\t* trans.h (where_stmt_list): New structure.\n \n 2003-04-10  Paul Brook  <paul@nowt.org>\n \n@@ -3851,7 +3857,7 @@\n \n \t* arith.c (validate_logical), g95.h, options.c (g95_init_options):\n \tRemove option l1.\n-        * g95.h, intrinsic.c(g95_get_intrinsic_sub_symbol): Add const.\n+\t* g95.h, intrinsic.c(g95_get_intrinsic_sub_symbol): Add const.\n \t* iresolve.c(g95_resolve_cpu_time, g95_resolve_random_number): Add\n \tconst.\n \t* lang-options.h: Remove -finline-repack-arrays. Add -fg77-calls.\n@@ -4092,7 +4098,7 @@\n 2003-02-05  Toon Moene  <toon@moene.indiv.nluug.nl>\n \n \t* lang-options.h: Fix warning involving C90 concatenated\n-        strings.\n+\tstrings.\n \n 2003-02-06  Steven Bosscher  <s.bosscher@student.tudelft.nl>\n \t    Arnaud Desitter  <arnaud.desitter@geography.oxford.ac.uk>\n@@ -4178,7 +4184,7 @@\n \n 2003-01-28  Steven Bosscher  <s.bosscher@student.tudelft.n>\n \n-        * Make-lang.in: Don't build with broken tree-ssa-pre.\n+\t* Make-lang.in: Don't build with broken tree-ssa-pre.\n \n 2003-01-28  Steven Bosscher  <s.bosscher@student.tudelft.nl>\n \n@@ -4515,7 +4521,7 @@\n \n 2003-01-10  Steven Bosscher  <s.bosscher@student.tudelft.nl>\n \n-        * dump-parse-tree.c (g95_show_namespace): Fixed another\n+\t* dump-parse-tree.c (g95_show_namespace): Fixed another\n \ttypo.  Sorry, it's Friday...\n \n 2003-01-10  Steven Bosscher  <s.bosscher@student.tudelft.nl>\n@@ -5018,7 +5024,7 @@\n 2002-09-01  Toon Moene  <toon@moene.indiv.nluug.nl>\n \n \t* g95_conv_mpz_to_tree: Free storage pointed to by q,\n-        not by buff.\n+\tnot by buff.\n \n 2002-08-30  Paul Brook  <paul@nowt.org>\n "}, {"sha": "8edf5692bb03d1f8864d8c70f1fbdcf693d9667e", "filename": "gcc/fortran/f95-lang.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Ffortran%2Ff95-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Ffortran%2Ff95-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ff95-lang.c?ref=6615c446157600e6dbe0b716f48e80a64e49807f", "patch": "@@ -153,7 +153,7 @@ const struct lang_hooks lang_hooks = LANG_HOOKS_INITIALIZER;\n \n #define DEFTREECODE(SYM, NAME, TYPE, LENGTH) TYPE,\n \n-const char tree_code_type[] = {\n+const enum tree_code_class tree_code_type[] = {\n #include \"tree.def\"\n };\n #undef DEFTREECODE\n@@ -221,7 +221,7 @@ gfc_truthvalue_conversion (tree expr)\n     case BOOLEAN_TYPE:\n       if (TREE_TYPE (expr) == boolean_type_node)\n \treturn expr;\n-      else if (TREE_CODE_CLASS (TREE_CODE (expr)) == '<')\n+      else if (COMPARISON_CLASS_P (expr))\n \t{\n \t  TREE_TYPE (expr) = boolean_type_node;\n \t  return expr;"}, {"sha": "29550b715e6af55744168ade2a9307d5dda054a9", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=6615c446157600e6dbe0b716f48e80a64e49807f", "patch": "@@ -107,7 +107,7 @@ gfc_make_safe_expr (gfc_se * se)\n {\n   tree var;\n \n-  if (TREE_CODE_CLASS (TREE_CODE (se->expr)) == 'c')\n+  if (CONSTANT_CLASS_P (se->expr))\n     return;\n \n   /* We need a temporary for this result.  */"}, {"sha": "8005b32924bf0820fe443c69ad8cfc4dc037db3f", "filename": "gcc/fortran/trans.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Ffortran%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Ffortran%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.c?ref=6615c446157600e6dbe0b716f48e80a64e49807f", "patch": "@@ -127,7 +127,7 @@ gfc_evaluate_now (tree expr, stmtblock_t * pblock)\n {\n   tree var;\n \n-  if (TREE_CODE_CLASS (TREE_CODE (expr)) == 'c')\n+  if (CONSTANT_CLASS_P (expr))\n     return expr;\n \n   var = gfc_create_var (TREE_TYPE (expr), NULL);"}, {"sha": "f648985e4574c03324b77cd4033da897ac020a0a", "filename": "gcc/gimplify.c", "status": "modified", "additions": 13, "deletions": 15, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=6615c446157600e6dbe0b716f48e80a64e49807f", "patch": "@@ -562,9 +562,7 @@ should_carry_locus_p (tree stmt)\n static void\n annotate_one_with_locus (tree t, location_t locus)\n {\n-  if (IS_EXPR_CODE_CLASS (TREE_CODE_CLASS (TREE_CODE (t)))\n-      && ! EXPR_HAS_LOCATION (t)\n-      && should_carry_locus_p (t))\n+  if (EXPR_P (t) && ! EXPR_HAS_LOCATION (t) && should_carry_locus_p (t))\n     SET_EXPR_LOCATION (t, locus);\n }\n \n@@ -599,9 +597,9 @@ mostly_copy_tree_r (tree *tp, int *walk_subtrees, void *data)\n {\n   enum tree_code code = TREE_CODE (*tp);\n   /* Don't unshare types, decls, constants and SAVE_EXPR nodes.  */\n-  if (TREE_CODE_CLASS (code) == 't'\n-      || TREE_CODE_CLASS (code) == 'd'\n-      || TREE_CODE_CLASS (code) == 'c'\n+  if (TREE_CODE_CLASS (code) == tcc_type\n+      || TREE_CODE_CLASS (code) == tcc_declaration\n+      || TREE_CODE_CLASS (code) == tcc_constant\n       || code == SAVE_EXPR || code == TARGET_EXPR\n       /* We can't do anything sensible with a BLOCK used as an expression,\n \t but we also can't abort when we see it because of non-expression\n@@ -637,9 +635,9 @@ copy_if_shared_r (tree *tp, int *walk_subtrees ATTRIBUTE_UNUSED,\n      types and the bounds of types.  Mark them as visited so we properly\n      unmark their subtrees on the unmark pass.  If we've already seen them,\n      don't look down further.  */\n-  if (TREE_CODE_CLASS (code) == 't'\n-      || TREE_CODE_CLASS (code) == 'd'\n-      || TREE_CODE_CLASS (code) == 'c')\n+  if (TREE_CODE_CLASS (code) == tcc_type\n+      || TREE_CODE_CLASS (code) == tcc_declaration\n+      || TREE_CODE_CLASS (code) == tcc_constant)\n     {\n       if (TREE_VISITED (t))\n \t*walk_subtrees = 0;\n@@ -2319,7 +2317,7 @@ gimplify_init_ctor_preeval_1 (tree *tp, int *walk_subtrees, void *xdata)\n       && alias_sets_conflict_p (data->lhs_alias_set, get_alias_set (t)))\n     return t;\n \n-  if (DECL_P (t) || TYPE_P (t))\n+  if (IS_TYPE_OR_DECL_P (t))\n     *walk_subtrees = 0;\n   return NULL;\n }\n@@ -3872,7 +3870,7 @@ gimplify_expr (tree *expr_p, tree *pre_p, tree *post_p,\n \tdefault:\n \t  switch (TREE_CODE_CLASS (TREE_CODE (*expr_p)))\n \t    {\n-\t    case '<':\n+\t    case tcc_comparison:\n \t      /* If this is a comparison of objects of aggregate type,\n \t     \t handle it specially (by converting to a call to\n \t     \t memcmp).  It would be nice to only have to do this\n@@ -3886,12 +3884,12 @@ gimplify_expr (tree *expr_p, tree *pre_p, tree *post_p,\n \t      \n \t    /* If *EXPR_P does not need to be special-cased, handle it\n \t       according to its class.  */\n-\t    case '1':\n+\t    case tcc_unary:\n \t      ret = gimplify_expr (&TREE_OPERAND (*expr_p, 0), pre_p,\n \t\t\t\t   post_p, is_gimple_val, fb_rvalue);\n \t      break;\n \n-\t    case '2':\n+\t    case tcc_binary:\n \t    expr_2:\n \t      {\n \t\tenum gimplify_status r0, r1;\n@@ -3905,8 +3903,8 @@ gimplify_expr (tree *expr_p, tree *pre_p, tree *post_p,\n \t\tbreak;\n \t      }\n \t      \n-\t    case 'd':\n-\t    case 'c':\n+\t    case tcc_declaration:\n+\t    case tcc_constant:\n \t      ret = GS_ALL_DONE;\n \t      goto dont_recalculate;\n \t      "}, {"sha": "f0311cc50498f3e4ce02872cc10e8f58293929a0", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=6615c446157600e6dbe0b716f48e80a64e49807f", "patch": "@@ -1,3 +1,11 @@\n+2004-09-17  Jeffrey D. Oldham  <oldham@codesourcery.com>\n+\t    Zack Weinberg  <zack@codesourcery.com>\n+\n+\t* java-tree.def: Use tree_code_class enumeration constants\n+\tinstead of code letters.\n+\t* java-gimplify.c, jcf-write.c, lang.c, parse.y: Update for\n+\tnew tree-class enumeration constants.\n+\n 2004-09-13  Tom Tromey  <tromey@redhat.com>\n \n \tPR java/17216:\n@@ -131,7 +139,7 @@\n \t* class.c (build_utf8_ref, build_static_field_ref,\n \tmake_field_value, make_method_value, get_dispatch_table,\n \tmake_class_data, emit_symbol_table, emit_catch_table): Likewise.\n-\t* constants.c (get_tag_node,  build_ref_from_constant_pool, \n+\t* constants.c (get_tag_node,  build_ref_from_constant_pool,\n \tbuild_constants_constructor): Likewise.\n \t* decl.c (java_init_decl_processing): Likewise.\n \t* expr.c (build_java_array_length_access, build_newarray,\n@@ -627,7 +635,7 @@\n \tset_nested_class_simple_name_value.\n \n 2004-06-22  Andrew Haley  <aph@redhat.com>\n-            Ranjit Mathew  <rmathew@hotmail.com>\n+\t    Ranjit Mathew  <rmathew@hotmail.com>\n \n \tFixes PR java/16113.\n \t* decl.c (force_poplevels): Remove call to expand_end_bindings.\n@@ -699,7 +707,7 @@\n \tof unordered conditionals. Add comment.\n \n 2004-05-29  Ranjit Mathew  <rmathew@hotmail.com>\n-            Per Bothner  <per@bothner.com>\n+\t    Per Bothner  <per@bothner.com>\n \n \t* java-tree.h (DECL_LOCAL_FINAL_IUD): New macro to test if a\n \tlocal variable was initialised upon declaration."}, {"sha": "54d5c75447203a358148da0c0f065d446d577a0f", "filename": "gcc/java/java-gimplify.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Fjava%2Fjava-gimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Fjava%2Fjava-gimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjava-gimplify.c?ref=6615c446157600e6dbe0b716f48e80a64e49807f", "patch": "@@ -141,7 +141,8 @@ java_gimplify_expr (tree *expr_p, tree *pre_p ATTRIBUTE_UNUSED,\n \t Parameter lists, maybe?  Or perhaps that's unnecessary because\n \t the front end already generates SAVE_EXPRs.  */\n \n-      if (TREE_CODE_CLASS (code) == '2' || TREE_CODE_CLASS (code) == '<')\n+      if (TREE_CODE_CLASS (code) == tcc_binary\n+\t  || TREE_CODE_CLASS (code) == tcc_comparison)\n \t{\n \t  enum gimplify_status stat \n \t    = gimplify_expr (&TREE_OPERAND (*expr_p, 0), pre_p, post_p,"}, {"sha": "2f2b9f467eb697917056b2c0c625c06f84067fb2", "filename": "gcc/java/java-tree.def", "status": "modified", "additions": 23, "deletions": 21, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Fjava%2Fjava-tree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Fjava%2Fjava-tree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjava-tree.def?ref=6615c446157600e6dbe0b716f48e80a64e49807f", "patch": "@@ -1,102 +1,104 @@\n /* Shift right, logical. */\n \n-DEFTREECODE (URSHIFT_EXPR, \"urshift_expr\", '2', 2)\n+DEFTREECODE (URSHIFT_EXPR, \"urshift_expr\", tcc_binary, 2)\n \n /* Return -1, 0, 1 depending on whether the first argument is\n    less, equal, or greater to the second argument. */\n-DEFTREECODE (COMPARE_EXPR, \"compare_expr\", '2', 2)\n+DEFTREECODE (COMPARE_EXPR, \"compare_expr\", tcc_binary, 2)\n \n /* Same as COMPARE_EXPR, but if either value is NaN, the result is -1. */\n-DEFTREECODE (COMPARE_L_EXPR, \"compare_l_expr\", '2', 2)\n+DEFTREECODE (COMPARE_L_EXPR, \"compare_l_expr\", tcc_binary, 2)\n /* Same as COMPARE_EXPR, but if either value is NaN, the result is 1. */\n-DEFTREECODE (COMPARE_G_EXPR, \"compare_g_expr\", '2', 2)\n+DEFTREECODE (COMPARE_G_EXPR, \"compare_g_expr\", tcc_binary, 2)\n \n /* Unary plus. Operand 0 is the expression the unary plus is applied\n    to */\n-DEFTREECODE (UNARY_PLUS_EXPR, \"unary_plus_expr\", '1', 1)\n+DEFTREECODE (UNARY_PLUS_EXPR, \"unary_plus_expr\", tcc_unary, 1)\n \n /* New array creation expression.\n    Operand 0 is the array base type.\n    Operand 1 is the list of dimension expressions. \n    Operand 2 is the number of other dimensions of unspecified range.\n    Once patched, the node will bear the type of the created array.  */\n-DEFTREECODE (NEW_ARRAY_EXPR, \"new_array_expr\", 'e', 3)\n+DEFTREECODE (NEW_ARRAY_EXPR, \"new_array_expr\", tcc_expression, 3)\n \n /* New anonymous array creation expression.\n    Operand 0 is the base type of the anonymous array.\n    Operand 1 is the signature of the dimensions this array contains.\n    Operand 2 is the anonymous array initializer.\n    Once patched, the node will bear the type of the created array.  */\n-DEFTREECODE (NEW_ANONYMOUS_ARRAY_EXPR, \"new_anonymous_array\", 'e', 3)\n+DEFTREECODE (NEW_ANONYMOUS_ARRAY_EXPR, \"new_anonymous_array\",\n+\t     tcc_expression, 3)\n \n /* New class creation expression.\n    Operand 0 is the name of the class to be created\n    Operand 1 is the argument list used to select a constructor.\n    There is no operand 2.  That slot is used for the\n    CALL_EXPR_RTL macro (see preexpand_calls).\n    The type should be the one of the created class.  */\n-DEFTREECODE (NEW_CLASS_EXPR, \"new_class_expr\", 'e', 3)\n+DEFTREECODE (NEW_CLASS_EXPR, \"new_class_expr\", tcc_expression, 3)\n \n /* Defines `this' as an expression.  */\n-DEFTREECODE (THIS_EXPR, \"this\", '1', 0)\n+DEFTREECODE (THIS_EXPR, \"this\", tcc_unary, 0)\n \n /* Case statement expression.\n    Operand 1 is the case value.  */\n-DEFTREECODE (CASE_EXPR, \"case\", 'e', 1)\n+DEFTREECODE (CASE_EXPR, \"case\", tcc_expression, 1)\n \n /* Default statement expression. */\n-DEFTREECODE (DEFAULT_EXPR, \"default\", 'e', 0)\n+DEFTREECODE (DEFAULT_EXPR, \"default\", tcc_expression, 0)\n \n /* Try expression\n    Operand 0 is the tried block,\n    Operand 1 contains chained catch nodes. */\n-DEFTREECODE (TRY_EXPR, \"try-catch\", 'e', 2)\n+DEFTREECODE (TRY_EXPR, \"try-catch\", tcc_expression, 2)\n \n /* Catch clause.\n    Operand 0 is the catch clause block, which contains the declaration of\n    the catch clause parameter.  */\n-DEFTREECODE (JAVA_CATCH_EXPR, \"catch\", '1', 1)\n+DEFTREECODE (JAVA_CATCH_EXPR, \"catch\", tcc_unary, 1)\n \n /* Synchronized statement.\n    Operand 0 is the expression on which we wish to synchronize,\n    Operand 1 is the synchronized expression block.  */\n-DEFTREECODE (SYNCHRONIZED_EXPR, \"synchronized\", 'e', 2)\n+DEFTREECODE (SYNCHRONIZED_EXPR, \"synchronized\", tcc_expression, 2)\n \n /* Throw statement.\n    Operand 0 is the throw expression.  */\n-DEFTREECODE (THROW_EXPR, \"throw\", '1', 1)\n+DEFTREECODE (THROW_EXPR, \"throw\", tcc_unary, 1)\n \n /* Conditional operator.\n    Operand 0 is the condition expression\n    Operand 1 is the then-value\n    Operand 2 is the else-value.  */\n-DEFTREECODE (CONDITIONAL_EXPR, \"?:\", 'e', 3)\n+DEFTREECODE (CONDITIONAL_EXPR, \"?:\", tcc_expression, 3)\n \n /* instanceof operator.\n    Operand 0 is the expression that is getting tested\n    Operand 1 is the class used for the test.  */\n-DEFTREECODE (INSTANCEOF_EXPR, \"instanceof\", 'e', 2)\n+DEFTREECODE (INSTANCEOF_EXPR, \"instanceof\", tcc_expression, 2)\n \n /* Array initializers.\n    Operand 0 is the (sub) array target to initialize, left to NULL_TREE\n    when the node is created.\n    Operand 1 is a CONSTRUCTOR node.  */\n-DEFTREECODE (NEW_ARRAY_INIT, \"new_array_init\", '1', 1)\n+DEFTREECODE (NEW_ARRAY_INIT, \"new_array_init\", tcc_unary, 1)\n \n /* Class literal.\n    Operand 0 is the name of the class we're trying to build a\n    reference from.  */\n-DEFTREECODE (CLASS_LITERAL, \"class_literal\", '1', 1)\n+DEFTREECODE (CLASS_LITERAL, \"class_literal\", tcc_unary, 1)\n \n /* The Java object within the exception object from the runtime.  */\n-DEFTREECODE (JAVA_EXC_OBJ_EXPR, \"java_exc_obj_expr\", 'e', 0)\n+DEFTREECODE (JAVA_EXC_OBJ_EXPR, \"java_exc_obj_expr\", tcc_expression, 0)\n \n /* Annotates a tree node (usually an expression) with source location\n    information: a file name (EXPR_WFL_FILENAME);  a line number\n    (EXPR_WFL_LINENO); and column number (EXPR_WFL_COLNO).  It is\n    expanded as the contained node (EXPR_WFL_NODE);  a line note should\n    be emitted first if EXPR_WFL_EMIT_LINE_NOTE.  */\n-DEFTREECODE (EXPR_WITH_FILE_LOCATION, \"expr_with_file_location\", 'e', 3)\n+DEFTREECODE (EXPR_WITH_FILE_LOCATION, \"expr_with_file_location\",\n+\t     tcc_expression, 3)\n \n /*\n Local variables:"}, {"sha": "5137eecf2922600bd6dd3a8b1252dd8dc5f3f071", "filename": "gcc/java/jcf-write.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Fjava%2Fjcf-write.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Fjava%2Fjcf-write.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-write.c?ref=6615c446157600e6dbe0b716f48e80a64e49807f", "patch": "@@ -2036,8 +2036,7 @@ generate_bytecode_insns (tree exp, int target, struct jcf_partial *state)\n \t/* If the rhs is a binary expression and the left operand is\n \t   `==' to the lhs then we have an OP= expression.  In this\n \t   case we must do some special processing.  */\n-\tif (TREE_CODE_CLASS (TREE_CODE (rhs)) == '2'\n-\t    && lhs == TREE_OPERAND (rhs, 0))\n+\tif (BINARY_CLASS_P (rhs) && lhs == TREE_OPERAND (rhs, 0))\n \t  {\n \t    if (TREE_CODE (lhs) == COMPONENT_REF)\n \t      {"}, {"sha": "d1c69770787bf6910d17b2be211650faf777e20a", "filename": "gcc/java/lang.c", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Fjava%2Flang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Fjava%2Flang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Flang.c?ref=6615c446157600e6dbe0b716f48e80a64e49807f", "patch": "@@ -78,9 +78,9 @@ static void java_clear_binding_stack (void);\n \n #define DEFTREECODE(SYM, NAME, TYPE, LENGTH) TYPE,\n \n-const char tree_code_type[] = {\n+const enum tree_code_class tree_code_type[] = {\n #include \"tree.def\"\n-  'x',\n+  tcc_exceptional,\n #include \"java-tree.def\"\n };\n #undef DEFTREECODE\n@@ -430,8 +430,7 @@ put_decl_node (tree node)\n       node = TREE_TYPE (node);\n       was_pointer = 1;\n     }\n-  if (TREE_CODE_CLASS (TREE_CODE (node)) == 'd'\n-      && DECL_NAME (node) != NULL_TREE)\n+  if (DECL_P (node) && DECL_NAME (node) != NULL_TREE)\n     {\n       if (TREE_CODE (node) == FUNCTION_DECL)\n \t{\n@@ -464,8 +463,7 @@ put_decl_node (tree node)\n       else\n \tput_decl_node (DECL_NAME (node));\n     }\n-  else if (TREE_CODE_CLASS (TREE_CODE (node)) == 't'\n-      && TYPE_NAME (node) != NULL_TREE)\n+  else if (TYPE_P (node) && TYPE_NAME (node) != NULL_TREE)\n     {\n       if (TREE_CODE (node) == RECORD_TYPE && TYPE_ARRAY_P (node))\n \t{"}, {"sha": "377c195323b14d2a1cf0c698be624863987a5591", "filename": "gcc/java/parse.y", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Fjava%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Fjava%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.y?ref=6615c446157600e6dbe0b716f48e80a64e49807f", "patch": "@@ -1687,7 +1687,7 @@ do_statement:\n for_statement:\n \tfor_begin SC_TK expression SC_TK for_update CP_TK statement\n \t\t{\n-\t\t  if (TREE_CODE_CLASS (TREE_CODE ($3)) == 'c')\n+\t\t  if (CONSTANT_CLASS_P ($3))\n \t\t    $3 = build_wfl_node ($3);\n \t\t  $$ = finish_for_loop (EXPR_WFL_LINECOL ($3), $3, $5, $7);\n \t\t}\n@@ -3126,7 +3126,7 @@ find_expr_with_wfl (tree node)\n {\n   while (node)\n     {\n-      char code;\n+      enum tree_code_class code;\n       tree to_return;\n \n       switch (TREE_CODE (node))\n@@ -3152,7 +3152,8 @@ find_expr_with_wfl (tree node)\n \n \tdefault:\n \t  code = TREE_CODE_CLASS (TREE_CODE (node));\n-\t  if (((code == '1') || (code == '2') || (code == 'e'))\n+\t  if (((code == tcc_unary) || (code == tcc_binary)\n+\t       || (code == tcc_expression))\n \t      && EXPR_WFL_LINECOL (node))\n \t    return node;\n \t  return NULL_TREE;\n@@ -14895,8 +14896,7 @@ finish_for_loop (int location, tree condition, tree update, tree body)\n \t{\n \t  /* Try to detect constraint violations.  These would be\n \t     programming errors somewhere.  */\n-\t  if (! IS_EXPR_CODE_CLASS (TREE_CODE_CLASS (TREE_CODE (up2)))\n-\t      || TREE_CODE (up2) == LOOP_EXPR)\n+\t  if (! EXPR_P (up2) || TREE_CODE (up2) == LOOP_EXPR)\n \t    abort ();\n \t  SUPPRESS_UNREACHABLE_ERROR (up2) = 1;\n \t}"}, {"sha": "c520a6bf501b57d7bdd214a02af20a79452a0c8b", "filename": "gcc/lambda-code.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Flambda-code.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Flambda-code.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flambda-code.c?ref=6615c446157600e6dbe0b716f48e80a64e49807f", "patch": "@@ -1420,7 +1420,7 @@ find_induction_var_from_exit_cond (struct loop *loop)\n   if (TREE_CODE (expr) != COND_EXPR)\n     return NULL_TREE;\n   test = TREE_OPERAND (expr, 0);\n-  if (TREE_CODE_CLASS (TREE_CODE (test)) != '<')\n+  if (!COMPARISON_CLASS_P (test))\n     return NULL_TREE;\n   /* This is a guess.  We say that for a <,!=,<= b, a is the induction\n      variable."}, {"sha": "199c93e9b504f0e696de06f6db0c8ffa6beb7df8", "filename": "gcc/langhooks.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Flanghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Flanghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks.c?ref=6615c446157600e6dbe0b716f48e80a64e49807f", "patch": "@@ -422,7 +422,7 @@ lhd_tree_dump_type_quals (tree t)\n tree\n lhd_expr_size (tree exp)\n {\n-  if (TREE_CODE_CLASS (TREE_CODE (exp)) == 'd'\n+  if (DECL_P (exp)\n       && DECL_SIZE_UNIT (exp) != 0)\n     return DECL_SIZE_UNIT (exp);\n   else\n@@ -439,8 +439,8 @@ lhd_gimplify_expr (tree *expr_p ATTRIBUTE_UNUSED, tree *pre_p ATTRIBUTE_UNUSED,\n }\n \n /* lang_hooks.tree_size: Determine the size of a tree with code C,\n-   which is a language-specific tree code in category 'x'.  The\n-   default expects never to be called.  */\n+   which is a language-specific tree code in category tcc_constant or\n+   tcc_exceptional.  The default expects never to be called.  */\n size_t\n lhd_tree_size (enum tree_code c ATTRIBUTE_UNUSED)\n {"}, {"sha": "43749a24e88b7592641001ce2a5deeafe40938bd", "filename": "gcc/langhooks.h", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Flanghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Flanghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks.h?ref=6615c446157600e6dbe0b716f48e80a64e49807f", "patch": "@@ -205,9 +205,10 @@ struct lang_hooks\n      identifier nodes long enough for the language-specific slots.  */\n   size_t identifier_size;\n \n-  /* Determines the size of any language-specific 'x' or 'c' nodes.\n-     Since it is called from make_node, the only information available\n-     is the tree code.  Expected to abort on unrecognized codes.  */\n+  /* Determines the size of any language-specific tcc_constant or\n+     tcc_exceptional nodes.  Since it is called from make_node, the\n+     only information available is the tree code.  Expected to abort\n+     on unrecognized codes.  */\n   size_t (*tree_size) (enum tree_code);\n \n   /* The first callback made to the front end, for simple\n@@ -338,12 +339,12 @@ struct lang_hooks\n      this hook.  It should output to stderr.  */\n   void (*print_statistics) (void);\n \n-  /* Called by print_tree when there is a tree of class 'x' that it\n-     doesn't know how to display.  */\n+  /* Called by print_tree when there is a tree of class tcc_exceptional\n+     that it doesn't know how to display.  */\n   lang_print_tree_hook print_xnode;\n \n-  /* Called to print language-dependent parts of a class 'd', class\n-     't', and IDENTIFIER_NODE nodes.  */\n+  /* Called to print language-dependent parts of tcc_decl, tcc_type,\n+     and IDENTIFIER_NODE nodes.  */\n   lang_print_tree_hook print_decl;\n   lang_print_tree_hook print_type;\n   lang_print_tree_hook print_identifier;"}, {"sha": "2d8319d2417a77af7a5f3f895646b7a653ec5f11", "filename": "gcc/objc/objc-lang.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Fobjc%2Fobjc-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Fobjc%2Fobjc-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-lang.c?ref=6615c446157600e6dbe0b716f48e80a64e49807f", "patch": "@@ -54,11 +54,11 @@ const struct lang_hooks lang_hooks = LANG_HOOKS_INITIALIZER;\n \n #define DEFTREECODE(SYM, NAME, TYPE, LENGTH) TYPE,\n \n-const char tree_code_type[] = {\n+const enum tree_code_class tree_code_type[] = {\n #include \"tree.def\"\n-  'x',\n+  tcc_exceptional,\n #include \"c-common.def\"\n-  'x',\n+  tcc_exceptional,\n #include \"objc-tree.def\"\n };\n #undef DEFTREECODE"}, {"sha": "8702e968426f764dbaa58bd23de288546ed7234c", "filename": "gcc/objc/objc-tree.def", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Fobjc%2Fobjc-tree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Fobjc%2Fobjc-tree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-tree.def?ref=6615c446157600e6dbe0b716f48e80a64e49807f", "patch": "@@ -1,7 +1,7 @@\n /* This file contains the definitions and documentation for the\n    additional tree codes used in the Objective C front end (see tree.def\n    for the standard codes).\n-   Copyright (C) 1990, 1997, 1998, 1999, 2000, 2001, 2003 \n+   Copyright (C) 1990, 1997, 1998, 1999, 2000, 2001, 2003, 2004 \n    Free Software Foundation, Inc.\n \n This file is part of GCC.\n@@ -23,20 +23,22 @@ Boston, MA 02111-1307, USA.  */\n \n \n /* Objective-C types.  */\n-DEFTREECODE (CLASS_INTERFACE_TYPE, \"class_interface_type\", 't', 0)\n-DEFTREECODE (CLASS_IMPLEMENTATION_TYPE, \"class_implementation_type\", 't', 0)\n-DEFTREECODE (CATEGORY_INTERFACE_TYPE, \"category_interface_type\", 't', 0)\n-DEFTREECODE (CATEGORY_IMPLEMENTATION_TYPE,\"category_implementation_type\", 't', 0)\n-DEFTREECODE (PROTOCOL_INTERFACE_TYPE, \"protocol_interface_type\", 't', 0)\n+DEFTREECODE (CLASS_INTERFACE_TYPE, \"class_interface_type\", tcc_type, 0)\n+DEFTREECODE (CLASS_IMPLEMENTATION_TYPE, \"class_implementation_type\",\n+\t     tcc_type, 0)\n+DEFTREECODE (CATEGORY_INTERFACE_TYPE, \"category_interface_type\", tcc_type, 0)\n+DEFTREECODE (CATEGORY_IMPLEMENTATION_TYPE,\"category_implementation_type\",\n+\t     tcc_type, 0)\n+DEFTREECODE (PROTOCOL_INTERFACE_TYPE, \"protocol_interface_type\", tcc_type, 0)\n \n /* Objective-C decls.  */\n-DEFTREECODE (KEYWORD_DECL, \"keyword_decl\", 'd', 0)\n-DEFTREECODE (INSTANCE_METHOD_DECL, \"instance_method_decl\", 'd', 0)\n-DEFTREECODE (CLASS_METHOD_DECL, \"class_method_decl\", 'd', 0)\n+DEFTREECODE (KEYWORD_DECL, \"keyword_decl\", tcc_declaration, 0)\n+DEFTREECODE (INSTANCE_METHOD_DECL, \"instance_method_decl\", tcc_declaration, 0)\n+DEFTREECODE (CLASS_METHOD_DECL, \"class_method_decl\", tcc_declaration, 0)\n \n /* Objective-C expressions.  */\n-DEFTREECODE (MESSAGE_SEND_EXPR, \"message_send_expr\", 'e', 3)\n-DEFTREECODE (CLASS_REFERENCE_EXPR, \"class_reference_expr\", 'e', 1)\n+DEFTREECODE (MESSAGE_SEND_EXPR, \"message_send_expr\", tcc_expression, 3)\n+DEFTREECODE (CLASS_REFERENCE_EXPR, \"class_reference_expr\", tcc_expression, 1)\n \n /*\n Local variables:"}, {"sha": "c6d5ce7cb9453860e50f20bd9b27680a6897b958", "filename": "gcc/predict.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=6615c446157600e6dbe0b716f48e80a64e49807f", "patch": "@@ -1048,7 +1048,7 @@ tree_predict_by_opcode (basic_block bb)\n     if (then_edge->flags & EDGE_TRUE_VALUE)\n        break;\n   cond = TREE_OPERAND (stmt, 0);\n-  if (TREE_CODE_CLASS (TREE_CODE (cond)) != '<')\n+  if (!COMPARISON_CLASS_P (cond))\n     return;\n   op0 = TREE_OPERAND (cond, 0);\n   type = TREE_TYPE (op0);"}, {"sha": "20822af24b1bf388349d17500f5d3fbc91f28a77", "filename": "gcc/print-tree.c", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Fprint-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Fprint-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-tree.c?ref=6615c446157600e6dbe0b716f48e80a64e49807f", "patch": "@@ -61,7 +61,7 @@ debug_tree (tree node)\n void\n print_node_brief (FILE *file, const char *prefix, tree node, int indent)\n {\n-  char class;\n+  enum tree_code_class class;\n \n   if (node == 0)\n     return;\n@@ -75,12 +75,12 @@ print_node_brief (FILE *file, const char *prefix, tree node, int indent)\n   fprintf (file, \"%s <%s \" HOST_PTR_PRINTF,\n \t   prefix, tree_code_name[(int) TREE_CODE (node)], (char *) node);\n \n-  if (class == 'd')\n+  if (class == tcc_declaration)\n     {\n       if (DECL_NAME (node))\n \tfprintf (file, \" %s\", IDENTIFIER_POINTER (DECL_NAME (node)));\n     }\n-  else if (class == 't')\n+  else if (class == tcc_type)\n     {\n       if (TYPE_NAME (node))\n \t{\n@@ -156,7 +156,7 @@ print_node (FILE *file, const char *prefix, tree node, int indent)\n   int hash;\n   struct bucket *b;\n   enum machine_mode mode;\n-  char class;\n+  enum tree_code_class class;\n   int len;\n   int first_rtl;\n   int i;\n@@ -177,7 +177,7 @@ print_node (FILE *file, const char *prefix, tree node, int indent)\n       return;\n     }\n \n-  if (indent > 8 && (class == 't' || class == 'd'))\n+  if (indent > 8 && (class == tcc_type || class == tcc_declaration))\n     {\n       print_node_brief (file, prefix, node, indent);\n       return;\n@@ -214,12 +214,12 @@ print_node (FILE *file, const char *prefix, tree node, int indent)\n \t   prefix, tree_code_name[(int) TREE_CODE (node)], (void *) node);\n \n   /* Print the name, if any.  */\n-  if (class == 'd')\n+  if (class == tcc_declaration)\n     {\n       if (DECL_NAME (node))\n \tfprintf (file, \" %s\", IDENTIFIER_POINTER (DECL_NAME (node)));\n     }\n-  else if (class == 't')\n+  else if (class == tcc_type)\n     {\n       if (TYPE_NAME (node))\n \t{\n@@ -296,7 +296,7 @@ print_node (FILE *file, const char *prefix, tree node, int indent)\n \n   switch (TREE_CODE_CLASS (TREE_CODE (node)))\n     {\n-    case 'd':\n+    case tcc_declaration:\n       mode = DECL_MODE (node);\n \n       if (DECL_UNSIGNED (node))\n@@ -461,7 +461,7 @@ print_node (FILE *file, const char *prefix, tree node, int indent)\n \tprint_node_brief (file, \"chain\", TREE_CHAIN (node), indent + 4);\n       break;\n \n-    case 't':\n+    case tcc_type:\n       if (TYPE_UNSIGNED (node))\n \tfputs (\" unsigned\", file);\n \n@@ -573,12 +573,12 @@ print_node (FILE *file, const char *prefix, tree node, int indent)\n       print_node_brief (file, \"chain\", TREE_CHAIN (node), indent + 4);\n       break;\n \n-    case 'e':\n-    case '<':\n-    case '1':\n-    case '2':\n-    case 'r':\n-    case 's':\n+    case tcc_expression:\n+    case tcc_comparison:\n+    case tcc_unary:\n+    case tcc_binary:\n+    case tcc_reference:\n+    case tcc_statement:\n       if (TREE_CODE (node) == BIT_FIELD_REF && BIT_FIELD_REF_UNSIGNED (node))\n \tfputs (\" unsigned\", file);\n       if (TREE_CODE (node) == BIND_EXPR)\n@@ -619,8 +619,8 @@ print_node (FILE *file, const char *prefix, tree node, int indent)\n       print_node (file, \"chain\", TREE_CHAIN (node), indent + 4);\n       break;\n \n-    case 'c':\n-    case 'x':\n+    case tcc_constant:\n+    case tcc_exceptional:\n       switch (TREE_CODE (node))\n \t{\n \tcase INTEGER_CST:\n@@ -765,7 +765,7 @@ print_node (FILE *file, const char *prefix, tree node, int indent)\n \t  break;\n \n \tdefault:\n-\t  if (TREE_CODE_CLASS (TREE_CODE (node)) == 'x')\n+\t  if (EXCEPTIONAL_CLASS_P (node))\n \t    lang_hooks.print_xnode (file, node, indent);\n \t  break;\n \t}"}, {"sha": "c63d418b39cad20ea49581b79c3c7a14fd76afda", "filename": "gcc/reload1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=6615c446157600e6dbe0b716f48e80a64e49807f", "patch": "@@ -2032,7 +2032,7 @@ alter_reg (int i, int from_reg)\n       /* If we have a decl for the original register, set it for the\n \t memory.  If this is a shared MEM, make a copy.  */\n       if (REG_EXPR (regno_reg_rtx[i])\n-\t  && TREE_CODE_CLASS (TREE_CODE (REG_EXPR (regno_reg_rtx[i]))) == 'd')\n+\t  && DECL_P (REG_EXPR (regno_reg_rtx[i])))\n \t{\n \t  rtx decl = DECL_RTL_IF_SET (REG_EXPR (regno_reg_rtx[i]));\n "}, {"sha": "e5d094d5ae968014a48fa029717bd05cfbd9cf38", "filename": "gcc/stmt.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=6615c446157600e6dbe0b716f48e80a64e49807f", "patch": "@@ -1471,16 +1471,14 @@ warn_if_unused_value (tree exp, location_t locus)\n \n     default:\n       /* Referencing a volatile value is a side effect, so don't warn.  */\n-      if ((DECL_P (exp)\n-\t   || TREE_CODE_CLASS (TREE_CODE (exp)) == 'r')\n+      if ((DECL_P (exp) || REFERENCE_CLASS_P (exp))\n \t  && TREE_THIS_VOLATILE (exp))\n \treturn 0;\n \n       /* If this is an expression which has no operands, there is no value\n \t to be unused.  There are no such language-independent codes,\n \t but front ends may define such.  */\n-      if (TREE_CODE_CLASS (TREE_CODE (exp)) == 'e'\n-\t  && TREE_CODE_LENGTH (TREE_CODE (exp)) == 0)\n+      if (EXPRESSION_CLASS_P (exp) && TREE_CODE_LENGTH (TREE_CODE (exp)) == 0)\n \treturn 0;\n \n     maybe_warn:"}, {"sha": "1ac5dda331dd317505cdc36adbaba5f86da8ad0c", "filename": "gcc/tree-browser.c", "status": "modified", "additions": 21, "deletions": 25, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Ftree-browser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Ftree-browser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-browser.c?ref=6615c446157600e6dbe0b716f48e80a64e49807f", "patch": "@@ -1,5 +1,5 @@\n /* Tree browser.\n-   Copyright (C) 2002, 2003 Free Software Foundation, Inc.\n+   Copyright (C) 2002, 2003, 2004 Free Software Foundation, Inc.\n    Contributed by Sebastian Pop <s.pop@laposte.net>\n \n This file is part of GCC.\n@@ -262,14 +262,14 @@ browse_tree (tree begin)\n \t  break;\n \n \tcase TB_REFERENCE_TO_THIS:\n-\t  if (head && TREE_CODE_CLASS (TREE_CODE (head)) == 't')\n+\t  if (head && TYPE_P (head))\n \t    TB_SET_HEAD (TYPE_REFERENCE_TO (head));\n \t  else\n \t    TB_WF;\n \t  break;\n \n \tcase TB_POINTER_TO_THIS:\n-\t  if (head && TREE_CODE_CLASS (TREE_CODE (head)) == 't')\n+\t  if (head && TYPE_P (head))\n \t    TB_SET_HEAD (TYPE_POINTER_TO (head));\n \t  else\n \t    TB_WF;\n@@ -338,28 +338,28 @@ browse_tree (tree begin)\n \t  break;\n \n \tcase TB_INITIAL:\n-\t  if (head && TREE_CODE_CLASS (TREE_CODE (head)) == 'd')\n+\t  if (head && DECL_P (head))\n \t    TB_SET_HEAD (DECL_INITIAL (head));\n \t  else\n \t    TB_WF;\n \t  break;\n \n \tcase TB_RESULT:\n-\t  if (head && TREE_CODE_CLASS (TREE_CODE (head)) == 'd')\n+\t  if (head && DECL_P (head))\n \t    TB_SET_HEAD (DECL_RESULT_FLD (head));\n \t  else\n \t    TB_WF;\n \t  break;\n \n \tcase TB_ARGUMENTS:\n-\t  if (head && TREE_CODE_CLASS (TREE_CODE (head)) == 'd')\n+\t  if (head && DECL_P (head))\n \t    TB_SET_HEAD (DECL_ARGUMENTS (head));\n \t  else\n \t    TB_WF;\n \t  break;\n \n \tcase TB_ABSTRACT_ORIGIN:\n-\t  if (head && TREE_CODE_CLASS (TREE_CODE (head)) == 'd')\n+\t  if (head && DECL_P (head))\n \t    TB_SET_HEAD (DECL_ABSTRACT_ORIGIN (head));\n \t  else if (head && TREE_CODE (head) == BLOCK)\n \t    TB_SET_HEAD (BLOCK_ABSTRACT_ORIGIN (head));\n@@ -368,18 +368,18 @@ browse_tree (tree begin)\n \t  break;\n \n \tcase TB_ATTRIBUTES:\n-\t  if (head && TREE_CODE_CLASS (TREE_CODE (head)) == 'd')\n+\t  if (head && DECL_P (head))\n \t    TB_SET_HEAD (DECL_ATTRIBUTES (head));\n-\t  else if (head && TREE_CODE_CLASS (TREE_CODE (head)) == 't')\n+\t  else if (head && TYPE_P (head))\n \t    TB_SET_HEAD (TYPE_ATTRIBUTES (head));\n \t  else\n \t    TB_WF;\n \t  break;\n \n \tcase TB_CONTEXT:\n-\t  if (head && TREE_CODE_CLASS (TREE_CODE (head)) == 'd')\n+\t  if (head && DECL_P (head))\n \t    TB_SET_HEAD (DECL_CONTEXT (head));\n-\t  else if (head && TREE_CODE_CLASS (TREE_CODE (head)) == 't'\n+\t  else if (head && TYPE_P (head)\n \t\t   && TYPE_CONTEXT (head))\n \t    TB_SET_HEAD (TYPE_CONTEXT (head));\n \t  else\n@@ -401,18 +401,18 @@ browse_tree (tree begin)\n           break;\n \n \tcase TB_UNIT_SIZE:\n-\t  if (head && TREE_CODE_CLASS (TREE_CODE (head)) == 'd')\n+\t  if (head && DECL_P (head))\n \t    TB_SET_HEAD (DECL_SIZE_UNIT (head));\n-\t  else if (head && TREE_CODE_CLASS (TREE_CODE (head)) == 't')\n+\t  else if (head && TYPE_P (head))\n \t    TB_SET_HEAD (TYPE_SIZE_UNIT (head));\n \t  else\n \t    TB_WF;\n \t  break;\n \n \tcase TB_SIZE:\n-\t  if (head && TREE_CODE_CLASS (TREE_CODE (head)) == 'd')\n+\t  if (head && DECL_P (head))\n \t    TB_SET_HEAD (DECL_SIZE (head));\n-\t  else if (head && TREE_CODE_CLASS (TREE_CODE (head)) == 't')\n+\t  else if (head && TYPE_P (head))\n \t    TB_SET_HEAD (TYPE_SIZE (head));\n \t  else\n \t    TB_WF;\n@@ -441,32 +441,28 @@ browse_tree (tree begin)\n \t  break;\n \n \tcase TB_CHILD_0:\n-\t  if (head && IS_EXPR_CODE_CLASS (TREE_CODE_CLASS (TREE_CODE (head)))\n-\t      && TREE_OPERAND (head, 0))\n+\t  if (head && EXPR_P (head) && TREE_OPERAND (head, 0))\n \t    TB_SET_HEAD (TREE_OPERAND (head, 0));\n \t  else\n \t    TB_WF;\n \t  break;\n \n \tcase TB_CHILD_1:\n-          if (head && IS_EXPR_CODE_CLASS (TREE_CODE_CLASS (TREE_CODE (head)))\n-\t      && TREE_OPERAND (head, 1))\n+          if (head && EXPR_P (head) && TREE_OPERAND (head, 1))\n \t    TB_SET_HEAD (TREE_OPERAND (head, 1));\n \t  else\n \t    TB_WF;\n           break;\n \n \tcase TB_CHILD_2:\n-          if (head && IS_EXPR_CODE_CLASS (TREE_CODE_CLASS (TREE_CODE (head)))\n-\t      && TREE_OPERAND (head, 2))\n+          if (head && EXPR_P (head) && TREE_OPERAND (head, 2))\n \t    TB_SET_HEAD (TREE_OPERAND (head, 2));\n \t  else\n \t    TB_WF;\n \t  break;\n \n \tcase TB_CHILD_3:\n-\t  if (head && IS_EXPR_CODE_CLASS (TREE_CODE_CLASS (TREE_CODE (head)))\n-\t      && TREE_OPERAND (head, 3))\n+\t  if (head && EXPR_P (head) && TREE_OPERAND (head, 3))\n \t    TB_SET_HEAD (TREE_OPERAND (head, 3));\n \t  else\n \t    TB_WF;\n@@ -751,7 +747,7 @@ store_child_info (tree *tp, int *walk_subtrees ATTRIBUTE_UNUSED,\n   node = *tp;\n \n   /* 'node' is the parent of 'TREE_OPERAND (node, *)'.  */\n-  if (TREE_CODE_CLASS (TREE_CODE (node)) == 'e')\n+  if (EXPRESSION_CLASS_P (node))\n     {\n \n #define STORE_CHILD(N) do {                                                \\\n@@ -808,7 +804,7 @@ TB_parent_eq (const void *p1, const void *p2)\n   if (p1 == NULL || p2 == NULL)\n     return 0;\n \n-  if (TREE_CODE_CLASS(TREE_CODE(parent)) == 'e')\n+  if (EXPRESSION_CLASS_P (parent))\n     {\n \n #define TEST_CHILD(N) do {               \\"}, {"sha": "69c8b2587f766ab1729fe9427331247c57a15bd4", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=6615c446157600e6dbe0b716f48e80a64e49807f", "patch": "@@ -2004,7 +2004,7 @@ find_taken_edge (basic_block bb, tree val)\n      SSA_NAME, we can always determine its truth value (except when\n      doing floating point comparisons that may involve NaNs).  */\n   if (val\n-      && TREE_CODE_CLASS (TREE_CODE (val)) == '<'\n+      && COMPARISON_CLASS_P (val)\n       && TREE_OPERAND (val, 0) == TREE_OPERAND (val, 1)\n       && TREE_CODE (TREE_OPERAND (val, 0)) == SSA_NAME\n       && (TREE_CODE (TREE_TYPE (TREE_OPERAND (val, 0))) != REAL_TYPE\n@@ -3085,8 +3085,8 @@ verify_expr (tree *tp, int *walk_subtrees, void *data ATTRIBUTE_UNUSED)\n      We check for constants explicitly since they are not considered\n      gimple invariants if they overflowed.  */\n #define CHECK_OP(N, MSG) \\\n-  do { if (TREE_CODE_CLASS (TREE_CODE (TREE_OPERAND (t, N))) != 'c'\t\\\n-         && !is_gimple_val (TREE_OPERAND (t, N)))\t\t\t\\\n+  do { if (!CONSTANT_CLASS_P (TREE_OPERAND (t, N))\t\t\\\n+         && !is_gimple_val (TREE_OPERAND (t, N)))\t\t\\\n        { error (MSG); return TREE_OPERAND (t, N); }} while (0)\n \n   switch (TREE_CODE (t))\n@@ -3187,8 +3187,7 @@ verify_expr (tree *tp, int *walk_subtrees, void *data ATTRIBUTE_UNUSED)\n \t  t = TREE_OPERAND (t, 0);\n \t}\n \n-      if (TREE_CODE_CLASS (TREE_CODE (t)) != 'c'\n-\t  && !is_gimple_lvalue (t))\n+      if (!CONSTANT_CLASS_P (t) && !is_gimple_lvalue (t))\n \t{\n \t  error (\"Invalid reference prefix.\");\n \t  return t;\n@@ -3298,18 +3297,18 @@ verify_stmt (tree stmt, bool last_in_block)\n static bool\n tree_node_can_be_shared (tree t)\n {\n-  if (TYPE_P (t) || DECL_P (t)\n+  if (IS_TYPE_OR_DECL_P (t)\n       /* We check for constants explicitly since they are not considered\n \t gimple invariants if they overflowed.  */\n-      || TREE_CODE_CLASS (TREE_CODE (t)) == 'c'\n+      || CONSTANT_CLASS_P (t)\n       || is_gimple_min_invariant (t)\n       || TREE_CODE (t) == SSA_NAME)\n     return true;\n \n   while (((TREE_CODE (t) == ARRAY_REF || TREE_CODE (t) == ARRAY_RANGE_REF)\n \t  /* We check for constants explicitly since they are not considered\n \t     gimple invariants if they overflowed.  */\n-\t  && (TREE_CODE_CLASS (TREE_CODE (TREE_OPERAND (t, 1))) == 'c'\n+\t  && (CONSTANT_CLASS_P (TREE_OPERAND (t, 1))\n \t      || is_gimple_min_invariant (TREE_OPERAND (t, 1))))\n \t || (TREE_CODE (t) == COMPONENT_REF\n \t     || TREE_CODE (t) == REALPART_EXPR"}, {"sha": "47419c2c3d743eaeec18b8a002ad438b22b8bd72", "filename": "gcc/tree-chrec.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Ftree-chrec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Ftree-chrec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-chrec.c?ref=6615c446157600e6dbe0b716f48e80a64e49807f", "patch": "@@ -932,7 +932,7 @@ chrec_convert (tree type,\n \n \t/* Don't propagate overflows.  */\n \tTREE_OVERFLOW (res) = 0;\n-\tif (TREE_CODE_CLASS (TREE_CODE (res)) == 'c')\n+\tif (CONSTANT_CLASS_P (res))\n \t  TREE_CONSTANT_OVERFLOW (res) = 0;\n \treturn res;\n       }"}, {"sha": "5a4fdf5a66896c0fd9f8b8a8146b569b02abd6f0", "filename": "gcc/tree-complex.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Ftree-complex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Ftree-complex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-complex.c?ref=6615c446157600e6dbe0b716f48e80a64e49807f", "patch": "@@ -425,7 +425,7 @@ expand_complex_operations_1 (block_stmt_iterator *bsi)\n   ar = extract_component (bsi, ac, 0);\n   ai = extract_component (bsi, ac, 1);\n \n-  if (TREE_CODE_CLASS (code) == '1')\n+  if (TREE_CODE_CLASS (code) == tcc_unary)\n     bc = br = bi = NULL;\n   else\n     {\n@@ -776,8 +776,8 @@ expand_vector_operations_1 (block_stmt_iterator *bsi)\n     return;\n \n   code = TREE_CODE (rhs);\n-  if (TREE_CODE_CLASS (code) != '1'\n-      && TREE_CODE_CLASS (code) != '2')\n+  if (TREE_CODE_CLASS (code) != tcc_unary\n+      && TREE_CODE_CLASS (code) != tcc_binary)\n     return;\n \n   if (code == NOP_EXPR || code == VIEW_CONVERT_EXPR)\n@@ -872,7 +872,7 @@ expand_vector_operations_1 (block_stmt_iterator *bsi)\n \tbreak;\n       }\n \n-  if (TREE_CODE_CLASS (code) == '1')\n+  if (TREE_CODE_CLASS (code) == tcc_unary)\n     *p_rhs = expand_vector_piecewise (bsi, do_unop, type, compute_type,\n \t\t\t\t      TREE_OPERAND (rhs, 0),\n \t\t\t\t      NULL_TREE, code);"}, {"sha": "4e65c5dffc8914698e20e83a9167b9aef4842015", "filename": "gcc/tree-dfa.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Ftree-dfa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Ftree-dfa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-dfa.c?ref=6615c446157600e6dbe0b716f48e80a64e49807f", "patch": "@@ -847,9 +847,7 @@ find_vars_r (tree *tp, int *walk_subtrees, void *data)\n \n   /* Type, _DECL and constant nodes have no interesting children.\n      Ignore them.  */\n-  else if (DECL_P (*tp)\n-\t   || TYPE_P (*tp)\n-\t   || TREE_CODE_CLASS (TREE_CODE (*tp)) == 'c')\n+  else if (IS_TYPE_OR_DECL_P (*tp) || CONSTANT_CLASS_P (*tp))\n     *walk_subtrees = 0;\n \n   return NULL_TREE;"}, {"sha": "d8d370fc3040ab7087cf2ff301f0e6e9412a748f", "filename": "gcc/tree-dump.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Ftree-dump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Ftree-dump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-dump.c?ref=6615c446157600e6dbe0b716f48e80a64e49807f", "patch": "@@ -216,7 +216,7 @@ dequeue_and_dump (dump_info_p di)\n   tree t;\n   unsigned int index;\n   enum tree_code code;\n-  char code_class;\n+  enum tree_code_class code_class;\n   const char* code_name;\n \n   /* Get the next node from the queue.  */\n@@ -292,19 +292,19 @@ dequeue_and_dump (dump_info_p di)\n \n       switch (code_class)\n \t{\n-\tcase '1':\n+\tcase tcc_unary:\n \t  dump_child (\"op 0\", TREE_OPERAND (t, 0));\n \t  break;\n \n-\tcase '2':\n-\tcase '<':\n+\tcase tcc_binary:\n+\tcase tcc_comparison:\n \t  dump_child (\"op 0\", TREE_OPERAND (t, 0));\n \t  dump_child (\"op 1\", TREE_OPERAND (t, 1));\n \t  break;\n \n-\tcase 'e':\n-\tcase 'r':\n-\tcase 's':\n+\tcase tcc_expression:\n+\tcase tcc_reference:\n+\tcase tcc_statement:\n \t  /* These nodes are handled explicitly below.  */\n \t  break;\n \n@@ -346,7 +346,7 @@ dequeue_and_dump (dump_info_p di)\n       if (TREE_CHAIN (t) && !dump_flag (di, TDF_SLIM, NULL))\n \tdump_child (\"chan\", TREE_CHAIN (t));\n     }\n-  else if (code_class == 't')\n+  else if (code_class == tcc_type)\n     {\n       /* All types have qualifiers.  */\n       int quals = lang_hooks.tree_dump.type_quals (t);\n@@ -373,7 +373,7 @@ dequeue_and_dump (dump_info_p di)\n       /* All types have alignments.  */\n       dump_int (di, \"algn\", TYPE_ALIGN (t));\n     }\n-  else if (code_class == 'c')\n+  else if (code_class == tcc_constant)\n     /* All constants can have types.  */\n     queue_and_dump_type (di, t);\n "}, {"sha": "b7bc7c3221bc451db248a43a6b14d441d9bcffd2", "filename": "gcc/tree-eh.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Ftree-eh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Ftree-eh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-eh.c?ref=6615c446157600e6dbe0b716f48e80a64e49807f", "patch": "@@ -1,5 +1,5 @@\n /* Exception handling semantics and decomposition for trees.\n-   Copyright (C) 2003 Free Software Foundation, Inc.\n+   Copyright (C) 2003, 2004 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -1719,9 +1719,9 @@ tree_could_trap_p (tree expr)\n   bool honor_trapv = false;\n   tree t, base, idx;\n \n-  if (TREE_CODE_CLASS (code) == '<'\n-      || TREE_CODE_CLASS (code) == '1'\n-      || TREE_CODE_CLASS (code) == '2')\n+  if (TREE_CODE_CLASS (code) == tcc_comparison\n+      || TREE_CODE_CLASS (code) == tcc_unary\n+      || TREE_CODE_CLASS (code) == tcc_binary)\n     {\n       t = TREE_TYPE (expr);\n       fp_operation = FLOAT_TYPE_P (t);"}, {"sha": "d9fe0205b3ca022a06f7c461cb1de8aa23e6f21f", "filename": "gcc/tree-gimple.c", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Ftree-gimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Ftree-gimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-gimple.c?ref=6615c446157600e6dbe0b716f48e80a64e49807f", "patch": "@@ -201,9 +201,9 @@ is_gimple_formal_tmp_rhs (tree t)\n \n   switch (TREE_CODE_CLASS (code))\n     {\n-    case '1':\n-    case '2':\n-    case '<':\n+    case tcc_unary:\n+    case tcc_binary:\n+    case tcc_comparison:\n       return true;\n \n     default:\n@@ -312,8 +312,7 @@ is_gimple_lvalue (tree t)\n bool\n is_gimple_condexpr (tree t)\n {\n-  return (is_gimple_val (t)\n-\t  || TREE_CODE_CLASS (TREE_CODE (t)) == '<');\n+  return (is_gimple_val (t) || COMPARISON_CLASS_P (t));\n }\n \n /*  Return true if T is something whose address can be taken.  */\n@@ -579,7 +578,7 @@ recalculate_side_effects (tree t)\n \n   switch (TREE_CODE_CLASS (code))\n     {\n-    case 'e':\n+    case tcc_expression:\n       switch (code)\n \t{\n \tcase INIT_EXPR:\n@@ -598,10 +597,10 @@ recalculate_side_effects (tree t)\n \t}\n       /* Fall through.  */\n \n-    case '<':  /* a comparison expression */\n-    case '1':  /* a unary arithmetic expression */\n-    case '2':  /* a binary arithmetic expression */\n-    case 'r':  /* a reference */\n+    case tcc_comparison:  /* a comparison expression */\n+    case tcc_unary:       /* a unary arithmetic expression */\n+    case tcc_binary:      /* a binary arithmetic expression */\n+    case tcc_reference:   /* a reference */\n       TREE_SIDE_EFFECTS (t) = TREE_THIS_VOLATILE (t);\n       for (i = 0; i < fro; ++i)\n \t{\n@@ -610,5 +609,9 @@ recalculate_side_effects (tree t)\n \t    TREE_SIDE_EFFECTS (t) = 1;\n \t}\n       break;\n+\n+    default:\n+      /* Can never be used with non-expressions.  */\n+      gcc_unreachable ();\n    }\n }"}, {"sha": "707faaf75a3720ea491ba5d6e5120f8418160ff7", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=6615c446157600e6dbe0b716f48e80a64e49807f", "patch": "@@ -1159,16 +1159,15 @@ estimate_num_insns_1 (tree *tp, int *walk_subtrees, void *data)\n   int *count = data;\n   tree x = *tp;\n \n-  if (TYPE_P (x) || DECL_P (x))\n+  if (IS_TYPE_OR_DECL_P (x))\n     {\n       *walk_subtrees = 0;\n       return NULL;\n     }\n   /* Assume that constants and references counts nothing.  These should\n      be majorized by amount of operations among them we count later\n      and are common target of CSE and similar optimizations.  */\n-  else if (TREE_CODE_CLASS (TREE_CODE (x)) == 'c'\n-\t   || TREE_CODE_CLASS (TREE_CODE (x)) == 'r')\n+  else if (CONSTANT_CLASS_P (x) || REFERENCE_CLASS_P (x))\n     return NULL;\n \n   switch (TREE_CODE (x))\n@@ -2258,7 +2257,7 @@ copy_tree_r (tree *tp, int *walk_subtrees, void *data ATTRIBUTE_UNUSED)\n \n   /* We make copies of most nodes.  */\n   if (IS_EXPR_CODE_CLASS (TREE_CODE_CLASS (code))\n-      || TREE_CODE_CLASS (code) == 'c'\n+      || TREE_CODE_CLASS (code) == tcc_constant\n       || code == TREE_LIST\n       || code == TREE_VEC\n       || code == TYPE_DECL)\n@@ -2288,9 +2287,9 @@ copy_tree_r (tree *tp, int *walk_subtrees, void *data ATTRIBUTE_UNUSED)\n \tBIND_EXPR_BLOCK (*tp) = NULL_TREE;\n     }\n \n-  else if (TREE_CODE_CLASS (code) == 't')\n+  else if (TREE_CODE_CLASS (code) == tcc_type)\n     *walk_subtrees = 0;\n-  else if (TREE_CODE_CLASS (code) == 'd')\n+  else if (TREE_CODE_CLASS (code) == tcc_declaration)\n     *walk_subtrees = 0;\n   else\n     gcc_assert (code != STATEMENT_LIST);"}, {"sha": "135ac0486a8a8976d4a4fb751823e9ed2387a2a5", "filename": "gcc/tree-nested.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Ftree-nested.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Ftree-nested.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-nested.c?ref=6615c446157600e6dbe0b716f48e80a64e49807f", "patch": "@@ -831,7 +831,7 @@ convert_nonlocal_reference (tree *tp, int *walk_subtrees, void *data)\n       break;\n \n     default:\n-      if (!DECL_P (t) && !TYPE_P (t))\n+      if (!IS_TYPE_OR_DECL_P (t))\n \t{\n \t  *walk_subtrees = 1;\n           wi->val_only = true;\n@@ -945,7 +945,7 @@ convert_local_reference (tree *tp, int *walk_subtrees, void *data)\n       break;\n \n     default:\n-      if (!DECL_P (t) && !TYPE_P (t))\n+      if (!IS_TYPE_OR_DECL_P (t))\n \t{\n \t  *walk_subtrees = 1;\n \t  wi->val_only = true;\n@@ -1124,7 +1124,7 @@ convert_tramp_reference (tree *tp, int *walk_subtrees, void *data)\n       break;\n \n     default:\n-      if (!DECL_P (t) && !TYPE_P (t))\n+      if (!IS_TYPE_OR_DECL_P (t))\n \t*walk_subtrees = 1;\n       break;\n     }"}, {"sha": "185e39bc59870a0dfa7a57c01f7f6292130683cd", "filename": "gcc/tree-outof-ssa.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Ftree-outof-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Ftree-outof-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-outof-ssa.c?ref=6615c446157600e6dbe0b716f48e80a64e49807f", "patch": "@@ -1750,7 +1750,7 @@ discover_nonconstant_array_refs_r (tree * tp, int *walk_subtrees,\n {\n   tree t = *tp;\n \n-  if (TYPE_P (t) || DECL_P (t))\n+  if (IS_TYPE_OR_DECL_P (t))\n     *walk_subtrees = 0;\n   else if (TREE_CODE (t) == ARRAY_REF || TREE_CODE (t) == ARRAY_RANGE_REF)\n     {"}, {"sha": "71196fbe78345fd6a6ad8740d68abc6afaf0fea7", "filename": "gcc/tree-pretty-print.c", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Ftree-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Ftree-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pretty-print.c?ref=6615c446157600e6dbe0b716f48e80a64e49807f", "patch": "@@ -1,5 +1,5 @@\n /* Pretty formatting of GENERIC trees in C syntax.\n-   Copyright (C) 2001, 2002, 2003 Free Software Foundation, Inc.\n+   Copyright (C) 2001, 2002, 2003, 2004 Free Software Foundation, Inc.\n    Adapted from c-pretty-print.c by Diego Novillo <dnovillo@redhat.com>\n \n This file is part of GCC.\n@@ -70,7 +70,7 @@ do_niy (pretty_printer *buffer, tree node)\n   pp_string (buffer, \"<<< Unknown tree: \");\n   pp_string (buffer, tree_code_name[(int) TREE_CODE (node)]);\n \n-  if (IS_EXPR_CODE_CLASS (TREE_CODE_CLASS (TREE_CODE (node))))\n+  if (EXPR_P (node))\n     {\n       len = first_rtl_op (TREE_CODE (node));\n       for (i = 0; i < len; ++i)\n@@ -303,7 +303,7 @@ dump_generic_node (pretty_printer *buffer, tree node, int spc, int flags,\n     case CHAR_TYPE:\n       {\n \tunsigned int quals = TYPE_QUALS (node);\n-\tchar class;\n+\tenum tree_code_class class;\n \n \tif (quals & TYPE_QUAL_CONST)\n \t  pp_string (buffer, \"const \");\n@@ -314,14 +314,14 @@ dump_generic_node (pretty_printer *buffer, tree node, int spc, int flags,\n \n \tclass = TREE_CODE_CLASS (TREE_CODE (node));\n \n-\tif (class == 'd')\n+\tif (class == tcc_declaration)\n \t  {\n \t    if (DECL_NAME (node))\n \t      dump_decl_name (buffer, node, flags);\n \t    else\n               pp_string (buffer, \"<unnamed type decl>\");\n \t  }\n-\telse if (class == 't')\n+\telse if (class == tcc_type)\n \t  {\n \t    if (TYPE_NAME (node))\n \t      {\n@@ -1330,9 +1330,7 @@ dump_generic_node (pretty_printer *buffer, tree node, int spc, int flags,\n \n     case GOTO_EXPR:\n       op0 = GOTO_DESTINATION (node);\n-      if (TREE_CODE (op0) != SSA_NAME\n-\t  && DECL_P (op0)\n-\t  && DECL_NAME (op0))\n+      if (TREE_CODE (op0) != SSA_NAME && DECL_P (op0) && DECL_NAME (op0))\n \t{\n \t  const char *name = IDENTIFIER_POINTER (DECL_NAME (op0));\n \t  if (strcmp (name, \"break\") == 0"}, {"sha": "01a609acda2a8e6dbcfca43cd54207011c5309b2", "filename": "gcc/tree-sra.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Ftree-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Ftree-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-sra.c?ref=6615c446157600e6dbe0b716f48e80a64e49807f", "patch": "@@ -1553,7 +1553,7 @@ find_new_referenced_vars_1 (tree *tp, int *walk_subtrees,\n   if (TREE_CODE (t) == VAR_DECL && !var_ann (t))\n     add_referenced_tmp_var (t);\n \n-  if (DECL_P (t) || TYPE_P (t))\n+  if (IS_TYPE_OR_DECL_P (t))\n     *walk_subtrees = 0;\n \n   return NULL;\n@@ -1903,7 +1903,7 @@ mark_notrap (tree *tp, int *walk_subtrees, void *data ATTRIBUTE_UNUSED)\n       TREE_THIS_NOTRAP (t) = 1;\n       *walk_subtrees = 0;\n     }\n-  else if (DECL_P (t) || TYPE_P (t))\n+  else if (IS_TYPE_OR_DECL_P (t))\n     *walk_subtrees = 0;\n \n   return NULL;"}, {"sha": "ae06ea0680bcbd48bef7fdf9c10789b14288f2af", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=6615c446157600e6dbe0b716f48e80a64e49807f", "patch": "@@ -1790,7 +1790,7 @@ add_pointed_to_var (struct alias_info *ai, tree ptr, tree value)\n   gcc_assert (TREE_CODE (value) == ADDR_EXPR);\n \n   pt_var = TREE_OPERAND (value, 0);\n-  if (TREE_CODE_CLASS (TREE_CODE (pt_var)) == 'r')\n+  if (REFERENCE_CLASS_P (pt_var))\n     pt_var = get_base_address (pt_var);\n \n   if (pt_var && SSA_VAR_P (pt_var))"}, {"sha": "81ce67321c578e778467b49a83e7066196f98c78", "filename": "gcc/tree-ssa-ccp.c", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Ftree-ssa-ccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Ftree-ssa-ccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ccp.c?ref=6615c446157600e6dbe0b716f48e80a64e49807f", "patch": "@@ -787,7 +787,7 @@ ccp_fold (tree stmt)\n {\n   tree rhs = get_rhs (stmt);\n   enum tree_code code = TREE_CODE (rhs);\n-  int kind = TREE_CODE_CLASS (code);\n+  enum tree_code_class kind = TREE_CODE_CLASS (code);\n   tree retval = NULL_TREE;\n   vuse_optype vuses;\n   \n@@ -805,7 +805,7 @@ ccp_fold (tree stmt)\n   /* Unary operators.  Note that we know the single operand must\n      be a constant.  So this should almost always return a\n      simplified RHS.  */\n-  if (kind == '1')\n+  if (kind == tcc_unary)\n     {\n       /* Handle unary operators which can appear in GIMPLE form.  */\n       tree op0 = TREE_OPERAND (rhs, 0);\n@@ -845,8 +845,8 @@ ccp_fold (tree stmt)\n \n   /* Binary and comparison operators.  We know one or both of the\n      operands are constants.  */\n-  else if (kind == '2'\n-           || kind == '<'\n+  else if (kind == tcc_binary\n+           || kind == tcc_comparison\n            || code == TRUTH_AND_EXPR\n            || code == TRUTH_OR_EXPR\n            || code == TRUTH_XOR_EXPR)\n@@ -2035,7 +2035,8 @@ fold_stmt (tree *stmt_p)\n \t  if (TREE_CODE (callee) == OBJ_TYPE_REF\n \t      && lang_hooks.fold_obj_type_ref\n \t      && TREE_CODE (OBJ_TYPE_REF_OBJECT (callee)) == ADDR_EXPR\n-\t      && DECL_P (TREE_OPERAND (OBJ_TYPE_REF_OBJECT (callee), 0)))\n+\t      && DECL_P (TREE_OPERAND\n+\t\t\t (OBJ_TYPE_REF_OBJECT (callee), 0)))\n \t    {\n \t      tree t;\n "}, {"sha": "80357dcfc277bed1bad58cc6fefcf31f0d4e7149", "filename": "gcc/tree-ssa-dce.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Ftree-ssa-dce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Ftree-ssa-dce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dce.c?ref=6615c446157600e6dbe0b716f48e80a64e49807f", "patch": "@@ -402,7 +402,7 @@ mark_stmt_if_obviously_necessary (tree stmt, bool aggressive)\n \t a global variable.  Otherwise, we check if the base variable\n \t is a global.  */\n       lhs = TREE_OPERAND (stmt, 0);\n-      if (TREE_CODE_CLASS (TREE_CODE (lhs)) == 'r')\n+      if (REFERENCE_CLASS_P (lhs))\n \tlhs = get_base_address (lhs);\n \n       if (lhs == NULL_TREE)"}, {"sha": "1953dfbde66ccd5d8618e677f3623b419938be86", "filename": "gcc/tree-ssa-dom.c", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Ftree-ssa-dom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Ftree-ssa-dom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.c?ref=6615c446157600e6dbe0b716f48e80a64e49807f", "patch": "@@ -616,7 +616,7 @@ thread_across_edge (struct dom_walk_data *walk_data, edge e)\n       else\n \tcond = SWITCH_COND (stmt);\n \n-      if (TREE_CODE_CLASS (TREE_CODE (cond)) == '<')\n+      if (COMPARISON_CLASS_P (cond))\n \t{\n \t  tree dummy_cond, op0, op1;\n \t  enum tree_code cond_code;\n@@ -776,8 +776,7 @@ initialize_hash_element (tree expr, tree lhs, struct expr_hash_elt *element)\n      For the former case, we have no annotation and we want to hash the\n      conditional expression.  In the latter case we have an annotation and\n      we want to record the expression the statement evaluates.  */\n-  if (TREE_CODE_CLASS (TREE_CODE (expr)) == '<'\n-      || TREE_CODE (expr) == TRUTH_NOT_EXPR)\n+  if (COMPARISON_CLASS_P (expr) || TREE_CODE (expr) == TRUTH_NOT_EXPR)\n     {\n       element->ann = NULL;\n       element->rhs = expr;\n@@ -932,7 +931,7 @@ dom_opt_finalize_block (struct dom_walk_data *walk_data, basic_block bb)\n     }\n   else if ((last = last_stmt (bb))\n \t   && TREE_CODE (last) == COND_EXPR\n-\t   && (TREE_CODE_CLASS (TREE_CODE (COND_EXPR_COND (last))) == '<'\n+\t   && (COMPARISON_CLASS_P (COND_EXPR_COND (last))\n \t       || TREE_CODE (COND_EXPR_COND (last)) == SSA_NAME)\n \t   && bb->succ\n \t   && (bb->succ->flags & EDGE_ABNORMAL) == 0\n@@ -949,7 +948,7 @@ dom_opt_finalize_block (struct dom_walk_data *walk_data, basic_block bb)\n       cond = COND_EXPR_COND (last);\n       cond_code = TREE_CODE (cond);\n \n-      if (TREE_CODE_CLASS (cond_code) == '<')\n+      if (TREE_CODE_CLASS (cond_code) == tcc_comparison)\n \tinverted = invert_truthvalue (cond);\n \n       /* If the THEN arm is the end of a dominator tree or has PHI nodes,\n@@ -965,7 +964,7 @@ dom_opt_finalize_block (struct dom_walk_data *walk_data, basic_block bb)\n \t  VARRAY_PUSH_TREE (const_and_copies_stack, NULL_TREE);\n \n \t  /* Record any equivalences created by following this edge.  */\n-\t  if (TREE_CODE_CLASS (cond_code) == '<')\n+\t  if (TREE_CODE_CLASS (cond_code) == tcc_comparison)\n \t    {\n \t      record_cond (cond, boolean_true_node);\n \t      record_dominating_conditions (cond);\n@@ -989,7 +988,7 @@ dom_opt_finalize_block (struct dom_walk_data *walk_data, basic_block bb)\n \t  || phi_nodes (false_edge->dest))\n \t{\n \t  /* Record any equivalences created by following this edge.  */\n-\t  if (TREE_CODE_CLASS (cond_code) == '<')\n+\t  if (TREE_CODE_CLASS (cond_code) == tcc_comparison)\n \t    {\n \t      record_cond (cond, boolean_false_node);\n \t      record_cond (inverted, boolean_true_node);\n@@ -1699,10 +1698,9 @@ simplify_rhs_and_lookup_avail_expr (struct dom_walk_data *walk_data,\n \t\t  /* If the result is a suitable looking gimple expression,\n \t\t     then use it instead of the original for STMT.  */\n \t\t  if (TREE_CODE (t) == SSA_NAME\n-\t\t      || (TREE_CODE_CLASS (TREE_CODE (t)) == '1'\n+\t\t      || (UNARY_CLASS_P (t)\n \t\t\t  && TREE_CODE (TREE_OPERAND (t, 0)) == SSA_NAME)\n-\t\t      || ((TREE_CODE_CLASS (TREE_CODE (t)) == '2'\n-\t\t\t   || TREE_CODE_CLASS (TREE_CODE (t)) == '<')\n+\t\t      || ((BINARY_CLASS_P (t) || COMPARISON_CLASS_P (t))\n \t\t\t  && TREE_CODE (TREE_OPERAND (t, 0)) == SSA_NAME\n \t\t\t  && is_gimple_val (TREE_OPERAND (t, 1))))\n \t\t    result = update_rhs_and_lookup_avail_expr (stmt, t, insert);\n@@ -1920,7 +1918,7 @@ simplify_cond_and_lookup_avail_expr (tree stmt,\n {\n   tree cond = COND_EXPR_COND (stmt);\n \n-  if (TREE_CODE_CLASS (TREE_CODE (cond)) == '<')\n+  if (COMPARISON_CLASS_P (cond))\n     {\n       tree op0 = TREE_OPERAND (cond, 0);\n       tree op1 = TREE_OPERAND (cond, 1);\n@@ -3023,7 +3021,7 @@ record_range (tree cond, basic_block bb, varray_type *vrp_variables_p)\n {\n   /* We explicitly ignore NE_EXPRs.  They rarely allow for meaningful\n      range optimizations and significantly complicate the implementation.  */\n-  if (TREE_CODE_CLASS (TREE_CODE (cond)) == '<'\n+  if (COMPARISON_CLASS_P (cond)\n       && TREE_CODE (cond) != NE_EXPR\n       && TREE_CODE (TREE_TYPE (TREE_OPERAND (cond, 1))) == INTEGER_TYPE)\n     {\n@@ -3091,7 +3089,7 @@ get_eq_expr_value (tree if_stmt,\n \n   /* If we have a comparison expression, then record its result into\n      the available expression table.  */\n-  if (TREE_CODE_CLASS (TREE_CODE (cond)) == '<')\n+  if (COMPARISON_CLASS_P (cond))\n     {\n       tree op0 = TREE_OPERAND (cond, 0);\n       tree op1 = TREE_OPERAND (cond, 1);"}, {"sha": "52c386001c9b850dfcb845bb64f2be531ca0a656", "filename": "gcc/tree-ssa-forwprop.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Ftree-ssa-forwprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Ftree-ssa-forwprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-forwprop.c?ref=6615c446157600e6dbe0b716f48e80a64e49807f", "patch": "@@ -172,7 +172,7 @@ record_single_argument_cond_exprs (varray_type cond_worklist,\n \t  if (cond_code == SSA_NAME\n \t      || ((cond_code == EQ_EXPR || cond_code == NE_EXPR)\n \t\t  && TREE_CODE (TREE_OPERAND (cond, 0)) == SSA_NAME\n-\t\t  && TREE_CODE_CLASS (TREE_CODE (TREE_OPERAND (cond, 1))) == 'c'\n+\t\t  && CONSTANT_CLASS_P (TREE_OPERAND (cond, 1))\n \t\t  && INTEGRAL_TYPE_P (TREE_TYPE (TREE_OPERAND (cond, 1)))))\n \t    {\n \t      tree def;\n@@ -209,7 +209,7 @@ record_single_argument_cond_exprs (varray_type cond_worklist,\n \t\t      /* The first operand must be an SSA_NAME and the second\n \t\t\t operand must be a constant.  */\n \t\t      if (TREE_CODE (op0) != SSA_NAME\n-\t\t\t  || TREE_CODE_CLASS (TREE_CODE (op1)) != 'c'\n+\t\t\t  || !CONSTANT_CLASS_P (op1)\n \t\t\t  || !INTEGRAL_TYPE_P (TREE_TYPE (op1)))\n \t\t\tcontinue;\n \t\t    }\n@@ -223,7 +223,7 @@ record_single_argument_cond_exprs (varray_type cond_worklist,\n \t\t      /* If TEST_VAR is set from a relational operation\n \t\t\t between two SSA_NAMEs or a combination of an SSA_NAME\n \t\t\t and a constant, then it is interesting.  */\n-\t\t      if (TREE_CODE_CLASS (TREE_CODE (def_rhs)) == '<')\n+\t\t      if (COMPARISON_CLASS_P (def_rhs))\n \t\t\t{\n \t\t\t  tree op0 = TREE_OPERAND (def_rhs, 0);\n \t\t\t  tree op1 = TREE_OPERAND (def_rhs, 1);\n@@ -364,7 +364,7 @@ substitute_single_use_vars (varray_type *cond_worklist,\n \t      new_cond = build (cond_code, boolean_type_node, op0, t);\n \t    }\n \t  /* If the variable is defined by a conditional expression... */\n-\t  else if (TREE_CODE_CLASS (def_rhs_code) == '<')\n+\t  else if (TREE_CODE_CLASS (def_rhs_code) == tcc_comparison)\n \t    {\n \t      /* TEST_VAR was set from a relational operator.  */\n \t      tree op0 = TREE_OPERAND (def_rhs, 0);\n@@ -382,7 +382,7 @@ substitute_single_use_vars (varray_type *cond_worklist,\n \n \t\t  /* If we did not get a simple relational expression or\n \t\t     bare SSA_NAME, then we can not optimize this case.  */\n-\t\t  if (TREE_CODE_CLASS (TREE_CODE (new_cond)) != '<'\n+\t\t  if (!COMPARISON_CLASS_P (new_cond)\n \t\t      && TREE_CODE (new_cond) != SSA_NAME)\n \t\t    continue;\n \t\t}"}, {"sha": "507f3782abb0dea0954ea1c891dca1bd06d7ef18", "filename": "gcc/tree-ssa-live.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Ftree-ssa-live.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Ftree-ssa-live.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-live.c?ref=6615c446157600e6dbe0b716f48e80a64e49807f", "patch": "@@ -1,5 +1,5 @@\n /* Liveness for SSA trees.\n-   Copyright (C) 2003 Free Software Foundation, Inc.\n+   Copyright (C) 2003, 2004 Free Software Foundation, Inc.\n    Contributed by Andrew MacLeod <amacleod@redhat.com>\n \n This file is part of GCC.\n@@ -297,7 +297,7 @@ mark_all_vars_used_1 (tree *tp, int *walk_subtrees,\n   if (TREE_CODE (t) == VAR_DECL)\n     set_is_used (t);\n \n-  if (DECL_P (t) || TYPE_P (t))\n+  if (IS_TYPE_OR_DECL_P (t))\n     *walk_subtrees = 0;\n \n   return NULL;"}, {"sha": "de8649173d00111d4abc38efb6c0e5b7aab8b93a", "filename": "gcc/tree-ssa-loop-im.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Ftree-ssa-loop-im.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Ftree-ssa-loop-im.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-im.c?ref=6615c446157600e6dbe0b716f48e80a64e49807f", "patch": "@@ -1,5 +1,5 @@\n /* Loop invariant motion.\n-   Copyright (C) 2003 Free Software Foundation, Inc.\n+   Copyright (C) 2003, 2004 Free Software Foundation, Inc.\n    \n This file is part of GCC.\n    \n@@ -256,7 +256,7 @@ outermost_invariant_loop (tree def, struct loop *loop)\n static struct loop *\n outermost_invariant_loop_expr (tree expr, struct loop *loop)\n {\n-  char class = TREE_CODE_CLASS (TREE_CODE (expr));\n+  enum tree_code_class class = TREE_CODE_CLASS (TREE_CODE (expr));\n   unsigned i, nops;\n   struct loop *max_loop = superloop_at_depth (loop, 1), *aloop;\n \n@@ -265,10 +265,10 @@ outermost_invariant_loop_expr (tree expr, struct loop *loop)\n       || is_gimple_min_invariant (expr))\n     return outermost_invariant_loop (expr, loop);\n \n-  if (class != '1'\n-      && class != '2'\n-      && class != 'e'\n-      && class != '<')\n+  if (class != tcc_unary\n+      && class != tcc_binary\n+      && class != tcc_expression\n+      && class != tcc_comparison)\n     return NULL;\n \n   nops = first_rtl_op (TREE_CODE (expr));\n@@ -714,7 +714,7 @@ may_move_till (tree ref, tree *index, void *data)\n static void\n force_move_till_expr (tree expr, struct loop *orig_loop, struct loop *loop)\n {\n-  char class = TREE_CODE_CLASS (TREE_CODE (expr));\n+  enum tree_code_class class = TREE_CODE_CLASS (TREE_CODE (expr));\n   unsigned i, nops;\n \n   if (TREE_CODE (expr) == SSA_NAME)\n@@ -727,10 +727,10 @@ force_move_till_expr (tree expr, struct loop *orig_loop, struct loop *loop)\n       return;\n     }\n \n-  if (class != '1'\n-      && class != '2'\n-      && class != 'e'\n-      && class != '<')\n+  if (class != tcc_unary\n+      && class != tcc_binary\n+      && class != tcc_expression\n+      && class != tcc_comparison)\n     return;\n \n   nops = first_rtl_op (TREE_CODE (expr));"}, {"sha": "078e8a36cf9f7f9286d5da1c6d077c0ad2dc08b9", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=6615c446157600e6dbe0b716f48e80a64e49807f", "patch": "@@ -1,5 +1,5 @@\n /* Induction variable optimizations.\n-   Copyright (C) 2003 Free Software Foundation, Inc.\n+   Copyright (C) 2003, 2004 Free Software Foundation, Inc.\n    \n This file is part of GCC.\n    \n@@ -721,7 +721,7 @@ static bool\n contains_abnormal_ssa_name_p (tree expr)\n {\n   enum tree_code code = TREE_CODE (expr);\n-  char class = TREE_CODE_CLASS (code);\n+  enum tree_code_class class = TREE_CODE_CLASS (code);\n     \n   if (code == SSA_NAME)\n     return SSA_NAME_OCCURS_IN_ABNORMAL_PHI (expr) != 0;\n@@ -737,13 +737,13 @@ contains_abnormal_ssa_name_p (tree expr)\n \n   switch (class)\n     {\n-    case '2':\n-    case '<':\n+    case tcc_binary:\n+    case tcc_comparison:\n       if (contains_abnormal_ssa_name_p (TREE_OPERAND (expr, 1)))\n \treturn true;\n \n       /* Fallthru.  */\n-    case '1':\n+    case tcc_unary:\n       if (contains_abnormal_ssa_name_p (TREE_OPERAND (expr, 0)))\n \treturn true;\n \n@@ -1347,21 +1347,20 @@ find_interesting_uses_stmt (struct ivopts_data *data, tree stmt)\n \n       switch (TREE_CODE_CLASS (TREE_CODE (rhs)))\n \t{\n-\tcase '<':\n+\tcase tcc_comparison:\n \t  find_interesting_uses_cond (data, stmt, &TREE_OPERAND (stmt, 1));\n \t  return;\n \n-\tcase 'r':\n+\tcase tcc_reference:\n \t  find_interesting_uses_address (data, stmt, &TREE_OPERAND (stmt, 1));\n-\t  if (TREE_CODE_CLASS (TREE_CODE (lhs)) == 'r')\n+\t  if (REFERENCE_CLASS_P (lhs))\n \t    find_interesting_uses_address (data, stmt, &TREE_OPERAND (stmt, 0));\n \t  return;\n \n \tdefault: ;\n \t}\n \n-      /* Handle memory = gimple_val.  */\n-      if (TREE_CODE_CLASS (TREE_CODE (lhs)) == 'r'\n+      if (REFERENCE_CLASS_P (lhs)\n \t  && is_gimple_val (rhs))\n \t{\n \t  find_interesting_uses_address (data, stmt, &TREE_OPERAND (stmt, 0));"}, {"sha": "8aae4ca1c6d846c923980dfb6309f4066f407fe9", "filename": "gcc/tree-ssa-operands.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Ftree-ssa-operands.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Ftree-ssa-operands.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-operands.c?ref=6615c446157600e6dbe0b716f48e80a64e49807f", "patch": "@@ -1,5 +1,5 @@\n /* SSA operands management for trees.\n-   Copyright (C) 2003 Free Software Foundation, Inc.\n+   Copyright (C) 2003, 2004 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -967,7 +967,7 @@ static void\n get_expr_operands (tree stmt, tree *expr_p, int flags)\n {\n   enum tree_code code;\n-  char class;\n+  enum tree_code_class class;\n   tree expr = *expr_p;\n \n   if (expr == NULL || expr == error_mark_node)\n@@ -1170,11 +1170,11 @@ get_expr_operands (tree stmt, tree *expr_p, int flags)\n       return;\n \n     default:\n-      if (class == '1')\n+      if (class == tcc_unary)\n \tgoto do_unary;\n-      if (class == '2' || class == '<')\n+      if (class == tcc_binary || class == tcc_comparison)\n \tgoto do_binary;\n-      if (class == 'c' || class == 't')\n+      if (class == tcc_constant || class == tcc_type)\n \treturn;\n     }\n "}, {"sha": "5d7f0e4e03cd910248b30f73a7aecbac29b88d50", "filename": "gcc/tree-ssa-phiopt.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Ftree-ssa-phiopt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Ftree-ssa-phiopt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-phiopt.c?ref=6615c446157600e6dbe0b716f48e80a64e49807f", "patch": "@@ -341,7 +341,7 @@ conditional_replacement (basic_block bb, tree phi, tree arg0, tree arg1)\n   if (old_result)\n     {\n       tree new1;\n-      if (TREE_CODE_CLASS (TREE_CODE (old_result)) != '<')\n+      if (!COMPARISON_CLASS_P (old_result))\n \treturn false;\n       \n       new1 = build (TREE_CODE (old_result), TREE_TYPE (result),"}, {"sha": "cbaba2c2117914f29230212b143e6cab41c51277", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 49, "deletions": 50, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=6615c446157600e6dbe0b716f48e80a64e49807f", "patch": "@@ -848,15 +848,21 @@ phi_translate (tree expr, value_set_t set, basic_block pred,\n   if (expr == NULL)\n     return NULL;\n \n+  if (is_gimple_min_invariant (expr))\n+    return expr;\n+\n   /* Phi translations of a given expression don't change,  */\n   phitrans = phi_trans_lookup (expr, pred);\n   if (phitrans)\n     return phitrans;\n   \n-  \n   switch (TREE_CODE_CLASS (TREE_CODE (expr)))\n     {\n-    case '2':\n+    case tcc_reference:\n+      /* XXX: Until we have PRE of loads working, none will be ANTIC. */\n+      return NULL;\n+\n+    case tcc_binary:\n       {\n \ttree oldop1 = TREE_OPERAND (expr, 0);\n \ttree oldop2 = TREE_OPERAND (expr, 1);\n@@ -884,13 +890,9 @@ phi_translate (tree expr, value_set_t set, basic_block pred,\n \t    phi_trans_add (oldexpr, newexpr, pred);\t    \n \t  }\n       }\n-      break;\n-      /* XXX: Until we have PRE of loads working, none will be ANTIC.\n-       */\n-    case 'r':\n-      return NULL;\n-      break;\n-    case '1':\n+      return expr;\n+\n+    case tcc_unary:\n       {\n \ttree oldop1 = TREE_OPERAND (expr, 0);\n \ttree newop1;\n@@ -911,10 +913,9 @@ phi_translate (tree expr, value_set_t set, basic_block pred,\n \t    phi_trans_add (oldexpr, newexpr, pred);\n \t  }\n       }\n-      break;\n-    case 'd':\n-      gcc_unreachable ();\n-    case 'x':\n+      return expr;\n+\n+    case tcc_exceptional:\n       {\n \ttree phi = NULL;\n \tint i;\n@@ -934,9 +935,11 @@ phi_translate (tree expr, value_set_t set, basic_block pred,\n \t      return PHI_ARG_DEF (phi, i);\n \t    }\n       }\n-      break;\n+      return expr;\n+\n+    default:\n+      gcc_unreachable ();\n     }\n-  return expr;\n }\n \n static void\n@@ -1046,34 +1049,31 @@ valid_in_set (value_set_t set, tree expr)\n {\n   switch (TREE_CODE_CLASS (TREE_CODE (expr)))\n     {\n-    case '2':\n+    case tcc_binary:\n       {\n \ttree op1 = TREE_OPERAND (expr, 0);\n \ttree op2 = TREE_OPERAND (expr, 1);\n \treturn set_contains_value (set, op1) && set_contains_value (set, op2);\n       }\n-      break;\n-    case '1':\n+\n+    case tcc_unary:\n       {\n \ttree op1 = TREE_OPERAND (expr, 0);\n \treturn set_contains_value (set, op1);\n       }\n-      break;\n-      /* XXX: Until PRE of loads works, no reference nodes are ANTIC.\n-       */\n-    case 'r':\n-      {\n-\treturn false;\n-      }\n-    case 'x':\n-      {\n-\tgcc_assert (TREE_CODE (expr) == SSA_NAME);\n-\treturn true;\n-      }\n-    case 'c':\n-      gcc_unreachable ();\n-    }\n-  return false;\n+\n+    case tcc_reference:\n+      /* XXX: Until PRE of loads works, no reference nodes are ANTIC.  */\n+      return false;\n+\n+    case tcc_exceptional:\n+      gcc_assert (TREE_CODE (expr) == SSA_NAME);\n+      return true;\n+\n+    default:\n+      /* No other cases should be encountered.  */\n+      gcc_unreachable (); \n+   }\n }\n \n /* Clean the set of expressions that are no longer valid in SET.  This\n@@ -1291,9 +1291,9 @@ find_or_generate_expression (basic_block block, tree expr, tree stmts)\n   if (genop == NULL)\n     {\n       genop = VALUE_HANDLE_EXPR_SET (expr)->head->expr;\n-      gcc_assert (TREE_CODE_CLASS (TREE_CODE (genop)) == '1'\n-\t\t  || TREE_CODE_CLASS (TREE_CODE (genop)) == '2'\n-\t\t  || TREE_CODE_CLASS (TREE_CODE (genop)) == 'r');\n+      gcc_assert (UNARY_CLASS_P (genop)\n+\t\t  || BINARY_CLASS_P (genop)\n+\t\t  || REFERENCE_CLASS_P (genop));\n       genop = create_expression_by_pieces (block, genop, stmts);\n     }\n   return genop;\n@@ -1323,7 +1323,7 @@ create_expression_by_pieces (basic_block block, tree expr, tree stmts)\n   \n   switch (TREE_CODE_CLASS (TREE_CODE (expr)))\n     {\n-    case '2':\n+    case tcc_binary:\n       {\n \ttree_stmt_iterator tsi;\n \ttree genop1, genop2;\n@@ -1345,7 +1345,7 @@ create_expression_by_pieces (basic_block block, tree expr, tree stmts)\n \tpre_stats.insertions++;\n \tbreak;\n       }\n-    case '1':\n+    case tcc_unary:\n       {\n \ttree_stmt_iterator tsi;\n \ttree genop1;\n@@ -1423,8 +1423,8 @@ insert_aux (basic_block block)\n \t\t   node;\n \t\t   node = node->next)\n \t\t{\n-\t\t  if (TREE_CODE_CLASS (TREE_CODE (node->expr)) == '2'\n-\t\t      || TREE_CODE_CLASS (TREE_CODE (node->expr)) == '1')\n+\t\t  if (BINARY_CLASS_P (node->expr)\n+\t\t      || UNARY_CLASS_P (node->expr))\n \t\t    {\n \t\t      tree *avail;\n \t\t      tree val;\n@@ -1528,8 +1528,8 @@ insert_aux (basic_block block)\n \t\t\t      tree builtexpr;\n \t\t\t      bprime = pred->src;\n \t\t\t      eprime = avail[bprime->index];\n-\t\t\t      if (TREE_CODE_CLASS (TREE_CODE (eprime)) == '2'\n-\t\t\t\t  || TREE_CODE_CLASS (TREE_CODE (eprime)) == '1')\n+\t\t\t      if (BINARY_CLASS_P (eprime)\n+\t\t\t\t  || UNARY_CLASS_P (eprime))\n \t\t\t\t{\n \t\t\t\t  builtexpr = create_expression_by_pieces (bprime,\n \t\t\t\t\t\t\t\t\t   eprime,\n@@ -1668,13 +1668,13 @@ create_value_expr_from (tree expr, basic_block block, vuse_optype vuses)\n   enum tree_code code = TREE_CODE (expr);\n   tree vexpr;\n \n-  gcc_assert (TREE_CODE_CLASS (code) == '1'\n-\t      || TREE_CODE_CLASS (code) == '2'\n-\t      || TREE_CODE_CLASS (code) == 'r');\n+  gcc_assert (TREE_CODE_CLASS (code) == tcc_unary\n+\t      || TREE_CODE_CLASS (code) == tcc_binary\n+\t      || TREE_CODE_CLASS (code) == tcc_reference);\n \n-  if (TREE_CODE_CLASS (code) == '1')\n+  if (TREE_CODE_CLASS (code) == tcc_unary)\n     vexpr = pool_alloc (unary_node_pool);\n-  else if (TREE_CODE_CLASS (code) == 'r')\n+  else if (TREE_CODE_CLASS (code) == tcc_reference)\n     vexpr = pool_alloc (reference_node_pool);\n   else\n     vexpr = pool_alloc (binary_node_pool);\n@@ -1791,8 +1791,7 @@ compute_avail (basic_block block)\n \t\t    value_insert_into_set (EXP_GEN (block), rhs);\n \t\t  continue;\n \t\t}\t   \n-\t      else if (TREE_CODE_CLASS (TREE_CODE (rhs)) == '1'\n-\t\t       || TREE_CODE_CLASS (TREE_CODE (rhs)) == '2'\n+\t      else if (UNARY_CLASS_P (rhs) || BINARY_CLASS_P (rhs)\n \t\t       || TREE_CODE (rhs) == INDIRECT_REF)\n \t\t{\n \t\t  /* For binary, unary, and reference expressions,"}, {"sha": "ffb7c9c00b01b5fde787820c4994d35773f62b07", "filename": "gcc/tree-ssa-propagate.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Ftree-ssa-propagate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Ftree-ssa-propagate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-propagate.c?ref=6615c446157600e6dbe0b716f48e80a64e49807f", "patch": "@@ -564,13 +564,13 @@ set_rhs (tree *stmt_p, tree expr)\n   ssa_op_iter iter;\n \n   /* Verify the constant folded result is valid gimple.  */\n-  if (TREE_CODE_CLASS (code) == '2')\n+  if (TREE_CODE_CLASS (code) == tcc_binary)\n     {\n       if (!is_gimple_val (TREE_OPERAND (expr, 0))\n \t  || !is_gimple_val (TREE_OPERAND (expr, 1)))\n \treturn false;\n     }\n-  else if (TREE_CODE_CLASS (code) == '1')\n+  else if (TREE_CODE_CLASS (code) == tcc_unary)\n     {\n       if (!is_gimple_val (TREE_OPERAND (expr, 0)))\n \treturn false;"}, {"sha": "21dc59aac0210fffdde8fa116dabf140257d411d", "filename": "gcc/tree-ssa.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Ftree-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Ftree-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa.c?ref=6615c446157600e6dbe0b716f48e80a64e49807f", "patch": "@@ -1296,7 +1296,7 @@ warn_uninitialized_var (tree *tp, int *walk_subtrees, void *data)\n       warn_uninit (t, \"%H'%D' is used uninitialized in this function\", locus);\n       *walk_subtrees = 0;\n     }\n-  else if (DECL_P (t) || TYPE_P (t))\n+  else if (IS_TYPE_OR_DECL_P (t))\n     *walk_subtrees = 0;\n \n   return NULL_TREE;"}, {"sha": "55ba145c35ae659cae7bfcf256d0ee2b104cf27a", "filename": "gcc/tree-ssanames.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Ftree-ssanames.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Ftree-ssanames.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssanames.c?ref=6615c446157600e6dbe0b716f48e80a64e49807f", "patch": "@@ -1,5 +1,5 @@\n /* Generic routines for manipulating SSA_NAME expressions\n-   Copyright (C) 2003 Free Software Foundation, Inc.\n+   Copyright (C) 2003, 2004 Free Software Foundation, Inc.\n                                                                                 \n This file is part of GCC.\n                                                                                 \n@@ -184,9 +184,7 @@ make_ssa_name (tree var, tree stmt)\n   gcc_assert (DECL_P (var)\n \t      || TREE_CODE (var) == INDIRECT_REF);\n \n-  gcc_assert (!stmt\n-\t      || IS_EXPR_CODE_CLASS (TREE_CODE_CLASS (TREE_CODE (stmt)))\n-\t      || TREE_CODE (stmt) == PHI_NODE);\n+  gcc_assert (!stmt || EXPR_P (stmt) || TREE_CODE (stmt) == PHI_NODE);\n \n   /* If our free list has an element, then use it.  Also reuse the\n      SSA version number of the element on the free list which helps"}, {"sha": "6f3fdcaaf93f1dd5833e11b592b6bd40041847a7", "filename": "gcc/tree-tailcall.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Ftree-tailcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Ftree-tailcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-tailcall.c?ref=6615c446157600e6dbe0b716f48e80a64e49807f", "patch": "@@ -1,5 +1,5 @@\n /* Tail call optimization on trees.\n-   Copyright (C) 2003 Free Software Foundation, Inc.\n+   Copyright (C) 2003, 2004 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -279,7 +279,7 @@ process_assignment (tree ass, tree stmt, block_stmt_iterator call, tree *m,\n       return true;\n     }\n \n-  if (TREE_CODE_CLASS (code) != '2')\n+  if (TREE_CODE_CLASS (code) != tcc_binary)\n     return false;\n \n   /* Accumulator optimizations will reverse the order of operations."}, {"sha": "f0c55e0acd3b5b1c722cf5f9ee5da7c61984ba98", "filename": "gcc/tree.c", "status": "modified", "additions": 138, "deletions": 104, "changes": 242, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=6615c446157600e6dbe0b716f48e80a64e49807f", "patch": "@@ -50,6 +50,23 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"tree-flow.h\"\n #include \"params.h\"\n \n+/* Each tree code class has an associated string representation.\n+   These must correspond to the tree_code_class entries.  */\n+\n+const char* tree_code_class_strings[] =\n+  {\n+    \"exceptional\",\n+    \"constant\",\n+    \"type\",\n+    \"declaration\",\n+    \"reference\",\n+    \"comparison\",\n+    \"unary\",\n+    \"binary\",\n+    \"statement\",\n+    \"expression\",\n+  };\n+\n /* obstack.[ch] explicitly declined to prototype this.  */\n extern int _obstack_allocated_p (struct obstack *h, void *obj);\n \n@@ -155,22 +172,22 @@ tree_code_size (enum tree_code code)\n \n   switch (TREE_CODE_CLASS (code))\n     {\n-    case 'd':  /* A decl node */\n+    case tcc_declaration:  /* A decl node */\n       return sizeof (struct tree_decl);\n \n-    case 't':  /* a type node */\n+    case tcc_type:  /* a type node */\n       return sizeof (struct tree_type);\n \n-    case 'r':  /* a reference */\n-    case 'e':  /* an expression */\n-    case 's':  /* an expression with side effects */\n-    case '<':  /* a comparison expression */\n-    case '1':  /* a unary arithmetic expression */\n-    case '2':  /* a binary arithmetic expression */\n+    case tcc_reference:   /* a reference */\n+    case tcc_expression:  /* an expression */\n+    case tcc_statement:   /* an expression with side effects */\n+    case tcc_comparison:  /* a comparison expression */\n+    case tcc_unary:       /* a unary arithmetic expression */\n+    case tcc_binary:      /* a binary arithmetic expression */\n       return (sizeof (struct tree_exp)\n \t      + (TREE_CODE_LENGTH (code) - 1) * sizeof (char *));\n \n-    case 'c':  /* a constant */\n+    case tcc_constant:  /* a constant */\n       switch (code)\n \t{\n \tcase INTEGER_CST:\treturn sizeof (struct tree_int_cst);\n@@ -182,7 +199,7 @@ tree_code_size (enum tree_code code)\n \t  return lang_hooks.tree_size (code);\n \t}\n \n-    case 'x':  /* something random, like an identifier.  */\n+    case tcc_exceptional:  /* something random, like an identifier.  */\n       switch (code)\n \t{\n \tcase IDENTIFIER_NODE:\treturn lang_hooks.identifier_size;\n@@ -240,41 +257,41 @@ tree\n make_node_stat (enum tree_code code MEM_STAT_DECL)\n {\n   tree t;\n-  int type = TREE_CODE_CLASS (code);\n+  enum tree_code_class type = TREE_CODE_CLASS (code);\n   size_t length = tree_code_size (code);\n #ifdef GATHER_STATISTICS\n   tree_node_kind kind;\n \n   switch (type)\n     {\n-    case 'd':  /* A decl node */\n+    case tcc_declaration:  /* A decl node */\n       kind = d_kind;\n       break;\n \n-    case 't':  /* a type node */\n+    case tcc_type:  /* a type node */\n       kind = t_kind;\n       break;\n \n-    case 's':  /* an expression with side effects */\n+    case tcc_statement:  /* an expression with side effects */\n       kind = s_kind;\n       break;\n \n-    case 'r':  /* a reference */\n+    case tcc_reference:  /* a reference */\n       kind = r_kind;\n       break;\n \n-    case 'e':  /* an expression */\n-    case '<':  /* a comparison expression */\n-    case '1':  /* a unary arithmetic expression */\n-    case '2':  /* a binary arithmetic expression */\n+    case tcc_expression:  /* an expression */\n+    case tcc_comparison:  /* a comparison expression */\n+    case tcc_unary:  /* a unary arithmetic expression */\n+    case tcc_binary:  /* a binary arithmetic expression */\n       kind = e_kind;\n       break;\n \n-    case 'c':  /* a constant */\n+    case tcc_constant:  /* a constant */\n       kind = c_kind;\n       break;\n \n-    case 'x':  /* something random, like an identifier.  */\n+    case tcc_exceptional:  /* something random, like an identifier.  */\n       if (code == IDENTIFIER_NODE)\n \tkind = id_kind;\n       else if (code == TREE_VEC)\n@@ -290,9 +307,6 @@ make_node_stat (enum tree_code code MEM_STAT_DECL)\n       else\n \tkind = x_kind;\n       break;\n-\n-    default:\n-      gcc_unreachable ();\n     }\n \n   tree_node_counts[(int) kind]++;\n@@ -307,11 +321,11 @@ make_node_stat (enum tree_code code MEM_STAT_DECL)\n \n   switch (type)\n     {\n-    case 's':\n+    case tcc_statement:\n       TREE_SIDE_EFFECTS (t) = 1;\n       break;\n \n-    case 'd':\n+    case tcc_declaration:\n       if (code != FUNCTION_DECL)\n \tDECL_ALIGN (t) = 1;\n       DECL_USER_ALIGN (t) = 0;\n@@ -323,7 +337,7 @@ make_node_stat (enum tree_code code MEM_STAT_DECL)\n       DECL_POINTER_ALIAS_SET (t) = -1;\n       break;\n \n-    case 't':\n+    case tcc_type:\n       TYPE_UID (t) = next_type_uid++;\n       TYPE_ALIGN (t) = char_type_node ? TYPE_ALIGN (char_type_node) : 0;\n       TYPE_USER_ALIGN (t) = 0;\n@@ -337,12 +351,12 @@ make_node_stat (enum tree_code code MEM_STAT_DECL)\n       TYPE_ALIAS_SET (t) = -1;\n       break;\n \n-    case 'c':\n+    case tcc_constant:\n       TREE_CONSTANT (t) = 1;\n       TREE_INVARIANT (t) = 1;\n       break;\n \n-    case 'e':\n+    case tcc_expression:\n       switch (code)\n \t{\n \tcase INIT_EXPR:\n@@ -361,6 +375,10 @@ make_node_stat (enum tree_code code MEM_STAT_DECL)\n \t  break;\n \t}\n       break;\n+\n+    default:\n+      /* Other classes need no special treatment.  */\n+      break;\n     }\n \n   return t;\n@@ -387,9 +405,9 @@ copy_node_stat (tree node MEM_STAT_DECL)\n   TREE_VISITED (t) = 0;\n   t->common.ann = 0;\n \n-  if (TREE_CODE_CLASS (code) == 'd')\n+  if (TREE_CODE_CLASS (code) == tcc_declaration)\n     DECL_UID (t) = next_decl_uid++;\n-  else if (TREE_CODE_CLASS (code) == 't')\n+  else if (TREE_CODE_CLASS (code) == tcc_type)\n     {\n       TYPE_UID (t) = next_type_uid++;\n       /* The following is so that the debug code for\n@@ -1566,9 +1584,9 @@ skip_simple_arithmetic (tree expr)\n   inner = expr;\n   while (1)\n     {\n-      if (TREE_CODE_CLASS (TREE_CODE (inner)) == '1')\n+      if (UNARY_CLASS_P (inner))\n \tinner = TREE_OPERAND (inner, 0);\n-      else if (TREE_CODE_CLASS (TREE_CODE (inner)) == '2')\n+      else if (BINARY_CLASS_P (inner))\n \t{\n \t  if (TREE_INVARIANT (TREE_OPERAND (inner, 1)))\n \t    inner = TREE_OPERAND (inner, 0);\n@@ -1606,22 +1624,29 @@ tree_node_structure (tree t)\n \n   switch (TREE_CODE_CLASS (code))\n     {\n-    case 'd':\treturn TS_DECL;\n-    case 't':\treturn TS_TYPE;\n-    case 'r': case '<': case '1': case '2': case 'e': case 's':\n+    case tcc_declaration:\n+      return TS_DECL;\n+    case tcc_type:\n+      return TS_TYPE;\n+    case tcc_reference:\n+    case tcc_comparison:\n+    case tcc_unary:\n+    case tcc_binary:\n+    case tcc_expression:\n+    case tcc_statement:\n       return TS_EXP;\n-    default:  /* 'c' and 'x' */\n+    default:  /* tcc_constant and tcc_exceptional */\n       break;\n     }\n   switch (code)\n     {\n-      /* 'c' cases.  */\n+      /* tcc_constant cases.  */\n     case INTEGER_CST:\t\treturn TS_INT_CST;\n     case REAL_CST:\t\treturn TS_REAL_CST;\n     case COMPLEX_CST:\t\treturn TS_COMPLEX;\n     case VECTOR_CST:\t\treturn TS_VECTOR;\n     case STRING_CST:\t\treturn TS_STRING;\n-      /* 'x' cases.  */\n+      /* tcc_exceptional cases.  */\n     case ERROR_MARK:\t\treturn TS_COMMON;\n     case IDENTIFIER_NODE:\treturn TS_IDENTIFIER;\n     case TREE_LIST:\t\treturn TS_LIST;\n@@ -1656,22 +1681,23 @@ contains_placeholder_p (tree exp)\n \n   switch (TREE_CODE_CLASS (code))\n     {\n-    case 'r':\n+    case tcc_reference:\n       /* Don't look at any PLACEHOLDER_EXPRs that might be in index or bit\n \t position computations since they will be converted into a\n \t WITH_RECORD_EXPR involving the reference, which will assume\n \t here will be valid.  */\n       return CONTAINS_PLACEHOLDER_P (TREE_OPERAND (exp, 0));\n \n-    case 'x':\n+    case tcc_exceptional:\n       if (code == TREE_LIST)\n \treturn (CONTAINS_PLACEHOLDER_P (TREE_VALUE (exp))\n \t\t|| CONTAINS_PLACEHOLDER_P (TREE_CHAIN (exp)));\n       break;\n \n-    case '1':\n-    case '2':  case '<':\n-    case 'e':\n+    case tcc_unary:\n+    case tcc_binary:\n+    case tcc_comparison:\n+    case tcc_expression:\n       switch (code)\n \t{\n \tcase COMPOUND_EXPR:\n@@ -1823,7 +1849,7 @@ substitute_in_expr (tree exp, tree f, tree r)\n      /* If this expression is getting a value from a PLACEHOLDER_EXPR\n \tand it is the right field, replace it with R.  */\n      for (inner = TREE_OPERAND (exp, 0);\n-\t  TREE_CODE_CLASS (TREE_CODE (inner)) == 'r';\n+\t  REFERENCE_CLASS_P (inner);\n \t  inner = TREE_OPERAND (inner, 0))\n        ;\n      if (TREE_CODE (inner) == PLACEHOLDER_EXPR\n@@ -1844,16 +1870,16 @@ substitute_in_expr (tree exp, tree f, tree r)\n   else\n     switch (TREE_CODE_CLASS (code))\n       {\n-      case 'c':\n-      case 'd':\n+      case tcc_constant:\n+      case tcc_declaration:\n \treturn exp;\n \n-      case 'x':\n-      case '1':\n-      case '2':\n-      case '<':\n-      case 'e':\n-      case 'r':\n+      case tcc_exceptional:\n+      case tcc_unary:\n+      case tcc_binary:\n+      case tcc_comparison:\n+      case tcc_expression:\n+      case tcc_reference:\n \tswitch (first_rtl_op (code))\n \t  {\n \t  case 0:\n@@ -1922,10 +1948,10 @@ substitute_placeholder_in_expr (tree exp, tree obj)\n \t   elt = ((TREE_CODE (elt) == COMPOUND_EXPR\n \t\t   || TREE_CODE (elt) == COND_EXPR)\n \t\t  ? TREE_OPERAND (elt, 1)\n-\t\t  : (TREE_CODE_CLASS (TREE_CODE (elt)) == 'r'\n-\t\t     || TREE_CODE_CLASS (TREE_CODE (elt)) == '1'\n-\t\t     || TREE_CODE_CLASS (TREE_CODE (elt)) == '2'\n-\t\t     || TREE_CODE_CLASS (TREE_CODE (elt)) == 'e')\n+\t\t  : (REFERENCE_CLASS_P (elt)\n+\t\t     || UNARY_CLASS_P (elt)\n+\t\t     || BINARY_CLASS_P (elt)\n+\t\t     || EXPRESSION_CLASS_P (elt))\n \t\t  ? TREE_OPERAND (elt, 0) : 0))\n \tif (TYPE_MAIN_VARIANT (TREE_TYPE (elt)) == need_type)\n \t  return elt;\n@@ -1934,10 +1960,10 @@ substitute_placeholder_in_expr (tree exp, tree obj)\n \t   elt = ((TREE_CODE (elt) == COMPOUND_EXPR\n \t\t   || TREE_CODE (elt) == COND_EXPR)\n \t\t  ? TREE_OPERAND (elt, 1)\n-\t\t  : (TREE_CODE_CLASS (TREE_CODE (elt)) == 'r'\n-\t\t     || TREE_CODE_CLASS (TREE_CODE (elt)) == '1'\n-\t\t     || TREE_CODE_CLASS (TREE_CODE (elt)) == '2'\n-\t\t     || TREE_CODE_CLASS (TREE_CODE (elt)) == 'e')\n+\t\t  : (REFERENCE_CLASS_P (elt)\n+\t\t     || UNARY_CLASS_P (elt)\n+\t\t     || BINARY_CLASS_P (elt)\n+\t\t     || EXPRESSION_CLASS_P (elt))\n \t\t  ? TREE_OPERAND (elt, 0) : 0))\n \tif (POINTER_TYPE_P (TREE_TYPE (elt))\n \t    && (TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (elt)))\n@@ -1963,17 +1989,17 @@ substitute_placeholder_in_expr (tree exp, tree obj)\n   else\n     switch (TREE_CODE_CLASS (code))\n       {\n-      case 'c':\n-      case 'd':\n+      case tcc_constant:\n+      case tcc_declaration:\n \treturn exp;\n \n-      case 'x':\n-      case '1':\n-      case '2':\n-      case '<':\n-      case 'e':\n-      case 'r':\n-      case 's':\n+      case tcc_exceptional:\n+      case tcc_unary:\n+      case tcc_binary:\n+      case tcc_comparison:\n+      case tcc_expression:\n+      case tcc_reference:\n+      case tcc_statement:\n \tswitch (first_rtl_op (code))\n \t  {\n \t  case 0:\n@@ -2145,13 +2171,13 @@ stabilize_reference_1 (tree e)\n \n   switch (TREE_CODE_CLASS (code))\n     {\n-    case 'x':\n-    case 't':\n-    case 'd':\n-    case '<':\n-    case 's':\n-    case 'e':\n-    case 'r':\n+    case tcc_exceptional:\n+    case tcc_type:\n+    case tcc_declaration:\n+    case tcc_comparison:\n+    case tcc_statement:\n+    case tcc_expression:\n+    case tcc_reference:\n       /* If the expression has side-effects, then encase it in a SAVE_EXPR\n \t so that it will only be evaluated once.  */\n       /* The reference (r) and comparison (<) classes could be handled as\n@@ -2160,12 +2186,12 @@ stabilize_reference_1 (tree e)\n \treturn save_expr (e);\n       return e;\n \n-    case 'c':\n+    case tcc_constant:\n       /* Constants need no processing.  In fact, we should never reach\n \t here.  */\n       return e;\n \n-    case '2':\n+    case tcc_binary:\n       /* Division is slow and tends to be compiled with jumps,\n \t especially the division by powers of 2 that is often\n \t found inside of an array reference.  So do it just once.  */\n@@ -2179,7 +2205,7 @@ stabilize_reference_1 (tree e)\n \t\t\t stabilize_reference_1 (TREE_OPERAND (e, 1)));\n       break;\n \n-    case '1':\n+    case tcc_unary:\n       /* Recursively stabilize each operand.  */\n       result = build_nt (code, stabilize_reference_1 (TREE_OPERAND (e, 0)));\n       break;\n@@ -2271,7 +2297,7 @@ do { tree _node = (NODE); \\\n       else\n \tti = tc = false;\n     }\n-  else if (TREE_CODE_CLASS (TREE_CODE (node)) == 'c')\n+  else if (CONSTANT_CLASS_P (node))\n     ;\n   else\n     {\n@@ -2319,10 +2345,10 @@ build1_stat (enum tree_code code, tree type, tree node MEM_STAT_DECL)\n #ifdef GATHER_STATISTICS\n   switch (TREE_CODE_CLASS (code))\n     {\n-    case 's':  /* an expression with side effects */\n+    case tcc_statement:  /* an expression with side effects */\n       kind = s_kind;\n       break;\n-    case 'r':  /* a reference */\n+    case tcc_reference:  /* a reference */\n       kind = r_kind;\n       break;\n     default:\n@@ -2357,7 +2383,7 @@ build1_stat (enum tree_code code, tree type, tree node MEM_STAT_DECL)\n       TREE_READONLY (t) = TREE_READONLY (node);\n     }\n \n-  if (TREE_CODE_CLASS (code) == 's')\n+  if (TREE_CODE_CLASS (code) == tcc_statement)\n     TREE_SIDE_EFFECTS (t) = 1;\n   else switch (code)\n     {\n@@ -2386,12 +2412,15 @@ build1_stat (enum tree_code code, tree type, tree node MEM_STAT_DECL)\n       break;\n \n     default:\n-      if (TREE_CODE_CLASS (code) == '1' && node && !TYPE_P (node)\n+      if (TREE_CODE_CLASS (code) == tcc_unary\n+\t  && node && !TYPE_P (node)\n \t  && TREE_CONSTANT (node))\n \tTREE_CONSTANT (t) = 1;\n-      if (TREE_CODE_CLASS (code) == '1' && node && TREE_INVARIANT (node))\n+      if (TREE_CODE_CLASS (code) == tcc_unary\n+\t  && node && TREE_INVARIANT (node))\n \tTREE_INVARIANT (t) = 1;\n-      if (TREE_CODE_CLASS (code) == 'r' && node && TREE_THIS_VOLATILE (node))\n+      if (TREE_CODE_CLASS (code) == tcc_reference\n+\t  && node && TREE_THIS_VOLATILE (node))\n \tTREE_THIS_VOLATILE (t) = 1;\n       break;\n     }\n@@ -2435,8 +2464,8 @@ build2_stat (enum tree_code code, tree tt, tree arg0, tree arg1 MEM_STAT_DECL)\n \n   /* Expressions without side effects may be constant if their\n      arguments are as well.  */\n-  constant = (TREE_CODE_CLASS (code) == '<'\n-\t      || TREE_CODE_CLASS (code) == '2');\n+  constant = (TREE_CODE_CLASS (code) == tcc_comparison\n+\t      || TREE_CODE_CLASS (code) == tcc_binary);\n   read_only = 1;\n   side_effects = TREE_SIDE_EFFECTS (t);\n   invariant = constant;\n@@ -2449,7 +2478,8 @@ build2_stat (enum tree_code code, tree tt, tree arg0, tree arg1 MEM_STAT_DECL)\n   TREE_INVARIANT (t) = invariant;\n   TREE_SIDE_EFFECTS (t) = side_effects;\n   TREE_THIS_VOLATILE (t)\n-    = TREE_CODE_CLASS (code) == 'r' && arg0 && TREE_THIS_VOLATILE (arg0);\n+    = (TREE_CODE_CLASS (code) == tcc_reference\n+       && arg0 && TREE_THIS_VOLATILE (arg0));\n \n   return t;\n }\n@@ -2497,7 +2527,8 @@ build3_stat (enum tree_code code, tree tt, tree arg0, tree arg1,\n \n   TREE_SIDE_EFFECTS (t) = side_effects;\n   TREE_THIS_VOLATILE (t)\n-    = TREE_CODE_CLASS (code) == 'r' && arg0 && TREE_THIS_VOLATILE (arg0);\n+    = (TREE_CODE_CLASS (code) == tcc_reference\n+       && arg0 && TREE_THIS_VOLATILE (arg0));\n \n   return t;\n }\n@@ -2526,7 +2557,8 @@ build4_stat (enum tree_code code, tree tt, tree arg0, tree arg1,\n \n   TREE_SIDE_EFFECTS (t) = side_effects;\n   TREE_THIS_VOLATILE (t)\n-    = TREE_CODE_CLASS (code) == 'r' && arg0 && TREE_THIS_VOLATILE (arg0);\n+    = (TREE_CODE_CLASS (code) == tcc_reference\n+       && arg0 && TREE_THIS_VOLATILE (arg0));\n \n   return t;\n }\n@@ -3829,12 +3861,12 @@ simple_cst_equal (tree t1, tree t2)\n \n   switch (TREE_CODE_CLASS (code1))\n     {\n-    case '1':\n-    case '2':\n-    case '<':\n-    case 'e':\n-    case 'r':\n-    case 's':\n+    case tcc_unary:\n+    case tcc_binary:\n+    case tcc_comparison:\n+    case tcc_expression:\n+    case tcc_reference:\n+    case tcc_statement:\n       cmp = 1;\n       for (i = 0; i < TREE_CODE_LENGTH (code1); i++)\n \t{\n@@ -3976,7 +4008,7 @@ iterative_hash_expr (tree t, hashval_t val)\n     default:\n       class = TREE_CODE_CLASS (code);\n \n-      if (class == 'd')\n+      if (class == tcc_declaration)\n \t{\n \t  /* Decls we can just compare by pointer.  */\n \t  val = iterative_hash_pointer (t, val);\n@@ -4774,7 +4806,8 @@ find_var_from_fn (tree *tp, int *walk_subtrees, void *data)\n   if (TYPE_P (*tp))\n     *walk_subtrees = 0;\n \n-  else if (DECL_P (*tp) && lang_hooks.tree_inlining.auto_var_in_fn_p (*tp, fn))\n+  else if (DECL_P (*tp)\n+\t   && lang_hooks.tree_inlining.auto_var_in_fn_p (*tp, fn))\n     return *tp;\n \n   return NULL_TREE;\n@@ -5312,12 +5345,13 @@ tree_not_check_failed (const tree node, const char *file,\n    code, given in CL.  */\n \n void\n-tree_class_check_failed (const tree node, int cl, const char *file,\n-\t\t\t int line, const char *function)\n+tree_class_check_failed (const tree node, const enum tree_code_class cl,\n+\t\t\t const char *file, int line, const char *function)\n {\n   internal_error\n-    (\"tree check: expected class %qc, have %qc (%s) in %s, at %s:%d\",\n-     cl, TREE_CODE_CLASS (TREE_CODE (node)),\n+    (\"tree check: expected class %qs, have %qs (%s) in %s, at %s:%d\",\n+     TREE_CODE_CLASS_STRING (cl),\n+     TREE_CODE_CLASS_STRING (TREE_CODE_CLASS (TREE_CODE (node))),\n      tree_code_name[TREE_CODE (node)], function, trim_filename (file), line);\n }\n "}, {"sha": "c0507423671ad5fd0e8ea0f16e8285073f3dfe7d", "filename": "gcc/tree.def", "status": "modified", "additions": 161, "deletions": 171, "changes": 332, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Ftree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Ftree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.def?ref=6615c446157600e6dbe0b716f48e80a64e49807f", "patch": "@@ -21,49 +21,37 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n 02111-1307, USA.  */\n \n \n-/* The third argument can be:\n-   'x' for an exceptional code (fits no category).\n-   't' for a type object code.\n-   'c' for codes for constants.\n-   'd' for codes for declarations (also serving as variable refs).\n-   'r' for codes for references to storage.\n-   '<' for codes for comparison expressions.\n-   '1' for codes for unary arithmetic expressions.\n-   '2' for codes for binary arithmetic expressions.\n-   's' for codes for \"statement\" expressions, which have side-effects,\n-       but usually no interesting value.\n-   'e' for codes for other kinds of expressions.  */\n-\n-/* For `r', `e', `<', `1', `2', and `s' nodes, which use struct\n-   tree_exp, the 4th element is the number of argument slots to\n-   allocate.  This determines the size of the tree node object.\n-   Other nodes use different structures, and the size is determined\n-   by the tree_union member structure; the 4th element should be\n-   zero.  Languages that define language-specific 'x' or 'c' codes\n-   must define the tree_size langhook to say how big they are.  */\n+/* For tcc_references, tcc_expression, tcc_comparison, tcc_unary,\n+   tcc_binary, and tcc_statement nodes, which use struct tree_exp, the\n+   4th element is the number of argument slots to allocate.  This\n+   determines the size of the tree node object.  Other nodes use\n+   different structures, and the size is determined by the tree_union\n+   member structure; the 4th element should be zero.  Languages that\n+   define language-specific tcc_exceptional or tcc_constant codes must\n+   define the tree_size langhook to say how big they are.  */\n \n /* Any erroneous construct is parsed into a node of this type.\n    This type of node is accepted without complaint in all contexts\n    by later parsing activities, to avoid multiple error messages\n    for one error.\n    No fields in these nodes are used except the TREE_CODE.  */\n-DEFTREECODE (ERROR_MARK, \"error_mark\", 'x', 0)\n+DEFTREECODE (ERROR_MARK, \"error_mark\", tcc_exceptional, 0)\n \n /* Used to represent a name (such as, in the DECL_NAME of a decl node).\n    Internally it looks like a STRING_CST node.\n    There is only one IDENTIFIER_NODE ever made for any particular name.\n    Use `get_identifier' to get it (or create it, the first time).  */\n-DEFTREECODE (IDENTIFIER_NODE, \"identifier_node\", 'x', 0)\n+DEFTREECODE (IDENTIFIER_NODE, \"identifier_node\", tcc_exceptional, 0)\n \n /* Has the TREE_VALUE and TREE_PURPOSE fields.  */\n /* These nodes are made into lists by chaining through the\n    TREE_CHAIN field.  The elements of the list live in the\n    TREE_VALUE fields, while TREE_PURPOSE fields are occasionally\n    used as well to get the effect of Lisp association lists.  */\n-DEFTREECODE (TREE_LIST, \"tree_list\", 'x', 0)\n+DEFTREECODE (TREE_LIST, \"tree_list\", tcc_exceptional, 0)\n \n /* These nodes contain an array of tree nodes.  */\n-DEFTREECODE (TREE_VEC, \"tree_vec\", 'x', 0)\n+DEFTREECODE (TREE_VEC, \"tree_vec\", tcc_exceptional, 0)\n \n /* A symbol binding block.  These are arranged in a tree,\n    where the BLOCK_SUBBLOCKS field contains a chain of subblocks\n@@ -85,7 +73,7 @@ DEFTREECODE (TREE_VEC, \"tree_vec\", 'x', 0)\n    instance of an inline function).\n    TREE_ASM_WRITTEN is nonzero if the block was actually referenced\n    in the generated assembly.  */\n-DEFTREECODE (BLOCK, \"block\", 'x', 0)\n+DEFTREECODE (BLOCK, \"block\", tcc_exceptional, 0)\n \f\n /* Each data type is represented by a tree node whose code is one of\n    the following:  */\n@@ -130,7 +118,8 @@ DEFTREECODE (BLOCK, \"block\", 'x', 0)\n     ENUMERAL_TYPE, RECORD_TYPE, UNION_TYPE, and QUAL_UNION_TYPE nodes;\n     see below.  */\n \n-DEFTREECODE (VOID_TYPE, \"void_type\", 't', 0)\t/* The void type in C */\n+DEFTREECODE (VOID_TYPE, \"void_type\", tcc_type, 0)\n+\t/* The void type in C */\n \n /* Integer types in all languages, including char in C.\n    Also used for sub-ranges of other discrete types.\n@@ -140,20 +129,20 @@ DEFTREECODE (VOID_TYPE, \"void_type\", 't', 0)\t/* The void type in C */\n    of this will point at the supertype (another INTEGER_TYPE,\n    or an ENUMERAL_TYPE, CHAR_TYPE, or BOOLEAN_TYPE).\n    Otherwise, the TREE_TYPE is zero.  */\n-DEFTREECODE (INTEGER_TYPE, \"integer_type\", 't', 0)\n+DEFTREECODE (INTEGER_TYPE, \"integer_type\", tcc_type, 0)\n \n /* C's float and double.  Different floating types are distinguished\n    by machine mode and by the TYPE_SIZE and the TYPE_PRECISION.  */\n-DEFTREECODE (REAL_TYPE, \"real_type\", 't', 0)\n+DEFTREECODE (REAL_TYPE, \"real_type\", tcc_type, 0)\n \n /* Complex number types.  The TREE_TYPE field is the data type\n    of the real and imaginary parts.  */\n-DEFTREECODE (COMPLEX_TYPE, \"complex_type\", 't', 0)\n+DEFTREECODE (COMPLEX_TYPE, \"complex_type\", tcc_type, 0)\n \n /* Vector types.  The TREE_TYPE field is the data type of the vector\n    elements.  The TYPE_PRECISION field is the number of subparts of\n    the vector.  */\n-DEFTREECODE (VECTOR_TYPE, \"vector_type\", 't', 0)\n+DEFTREECODE (VECTOR_TYPE, \"vector_type\", tcc_type, 0)\n \n /* C enums.  The type node looks just like an INTEGER_TYPE node.\n    The symbols for the values of the enum type are defined by\n@@ -166,39 +155,39 @@ DEFTREECODE (VECTOR_TYPE, \"vector_type\", 't', 0)\n    fields are filled in.\n    RECORD_TYPE, UNION_TYPE, and QUAL_UNION_TYPE forward refs are\n    treated similarly.  */\n-DEFTREECODE (ENUMERAL_TYPE, \"enumeral_type\", 't', 0)\n+DEFTREECODE (ENUMERAL_TYPE, \"enumeral_type\", tcc_type, 0)\n \n /* Pascal's boolean type (true or false are the only values);\n    no special fields needed.  */\n-DEFTREECODE (BOOLEAN_TYPE, \"boolean_type\", 't', 0)\n+DEFTREECODE (BOOLEAN_TYPE, \"boolean_type\", tcc_type, 0)\n \n /* CHAR in Pascal; not used in C.\n    No special fields needed.  */\n-DEFTREECODE (CHAR_TYPE, \"char_type\", 't', 0)\n+DEFTREECODE (CHAR_TYPE, \"char_type\", tcc_type, 0)\n \n /* All pointer-to-x types have code POINTER_TYPE.\n    The TREE_TYPE points to the node for the type pointed to.  */\n-DEFTREECODE (POINTER_TYPE, \"pointer_type\", 't', 0)\n+DEFTREECODE (POINTER_TYPE, \"pointer_type\", tcc_type, 0)\n \n /* An offset is a pointer relative to an object.\n    The TREE_TYPE field is the type of the object at the offset.\n    The TYPE_OFFSET_BASETYPE points to the node for the type of object\n    that the offset is relative to.  */\n-DEFTREECODE (OFFSET_TYPE, \"offset_type\", 't', 0)\n+DEFTREECODE (OFFSET_TYPE, \"offset_type\", tcc_type, 0)\n \n /* A reference is like a pointer except that it is coerced\n    automatically to the value it points to.  Used in C++.  */\n-DEFTREECODE (REFERENCE_TYPE, \"reference_type\", 't', 0)\n+DEFTREECODE (REFERENCE_TYPE, \"reference_type\", tcc_type, 0)\n \n /* METHOD_TYPE is the type of a function which takes an extra first\n    argument for \"self\", which is not present in the declared argument list.\n    The TREE_TYPE is the return type of the method.  The TYPE_METHOD_BASETYPE\n    is the type of \"self\".  TYPE_ARG_TYPES is the real argument list, which\n    includes the hidden argument for \"self\".  */\n-DEFTREECODE (METHOD_TYPE, \"method_type\", 't', 0)\n+DEFTREECODE (METHOD_TYPE, \"method_type\", tcc_type, 0)\n \n /* Used for Pascal; details not determined right now.  */\n-DEFTREECODE (FILE_TYPE, \"file_type\", 't', 0)\n+DEFTREECODE (FILE_TYPE, \"file_type\", tcc_type, 0)\n \n /* Types of arrays.  Special fields:\n    TREE_TYPE\t\t  Type of an array element.\n@@ -209,13 +198,13 @@ DEFTREECODE (FILE_TYPE, \"file_type\", 't', 0)\n  TYPE_STRING_FLAG indicates a string (in contrast to an array of chars)\n  in languages (such as Chill) that make a distinction.  */\n /* Array types in C or Pascal */\n-DEFTREECODE (ARRAY_TYPE, \"array_type\", 't', 0)\n+DEFTREECODE (ARRAY_TYPE, \"array_type\", tcc_type, 0)\n \n /* Types of sets for Pascal.  Special fields are the same as\n    in an array type.  The target type is always a boolean type.\n    Used for both bitstrings and powersets in Chill;\n    TYPE_STRING_FLAG indicates a bitstring.  */\n-DEFTREECODE (SET_TYPE, \"set_type\", 't', 0)\n+DEFTREECODE (SET_TYPE, \"set_type\", tcc_type, 0)\n \n /* Struct in C, or record in Pascal.  */\n /* Special fields:\n@@ -225,33 +214,33 @@ DEFTREECODE (SET_TYPE, \"set_type\", 't', 0)\n    A few may need to be added for Pascal.  */\n /* See the comment above, before ENUMERAL_TYPE, for how\n    forward references to struct tags are handled in C.  */\n-DEFTREECODE (RECORD_TYPE, \"record_type\", 't', 0)\n+DEFTREECODE (RECORD_TYPE, \"record_type\", tcc_type, 0)\n \n /* Union in C.  Like a struct, except that the offsets of the fields\n    will all be zero.  */\n /* See the comment above, before ENUMERAL_TYPE, for how\n    forward references to union tags are handled in C.  */\n-DEFTREECODE (UNION_TYPE, \"union_type\", 't', 0)\t/* C union type */\n+DEFTREECODE (UNION_TYPE, \"union_type\", tcc_type, 0)\t/* C union type */\n \n /* Similar to UNION_TYPE, except that the expressions in DECL_QUALIFIER\n    in each FIELD_DECL determine what the union contains.  The first\n    field whose DECL_QUALIFIER expression is true is deemed to occupy\n    the union.  */\n-DEFTREECODE (QUAL_UNION_TYPE, \"qual_union_type\", 't', 0)\n+DEFTREECODE (QUAL_UNION_TYPE, \"qual_union_type\", tcc_type, 0)\n \n /* Type of functions.  Special fields:\n    TREE_TYPE\t\t    type of value returned.\n    TYPE_ARG_TYPES      list of types of arguments expected.\n \tthis list is made of TREE_LIST nodes.\n    Types of \"Procedures\" in languages where they are different from functions\n    have code FUNCTION_TYPE also, but then TREE_TYPE is zero or void type.  */\n-DEFTREECODE (FUNCTION_TYPE, \"function_type\", 't', 0)\n+DEFTREECODE (FUNCTION_TYPE, \"function_type\", tcc_type, 0)\n \n /* This is a language-specific kind of type.\n    Its meaning is defined by the language front end.\n    layout_type does not know how to lay this out,\n    so the front-end must do so manually.  */\n-DEFTREECODE (LANG_TYPE, \"lang_type\", 't', 0)\n+DEFTREECODE (LANG_TYPE, \"lang_type\", tcc_type, 0)\n \f\n /* Expressions */\n \n@@ -265,20 +254,20 @@ DEFTREECODE (LANG_TYPE, \"lang_type\", 't', 0)\n    TREE_CONSTANT_OVERFLOW already set, it is known to be unique.\n    INTEGER_CST nodes are created for the integral types, for pointer\n    types and for vector and float types in some circumstances.  */\n-DEFTREECODE (INTEGER_CST, \"integer_cst\", 'c', 0)\n+DEFTREECODE (INTEGER_CST, \"integer_cst\", tcc_constant, 0)\n \n /* Contents are in TREE_REAL_CST field.  */\n-DEFTREECODE (REAL_CST, \"real_cst\", 'c', 0)\n+DEFTREECODE (REAL_CST, \"real_cst\", tcc_constant, 0)\n \n /* Contents are in TREE_REALPART and TREE_IMAGPART fields,\n    whose contents are other constant nodes.  */\n-DEFTREECODE (COMPLEX_CST, \"complex_cst\", 'c', 0)\n+DEFTREECODE (COMPLEX_CST, \"complex_cst\", tcc_constant, 0)\n \n /* Contents are in TREE_VECTOR_CST_ELTS field.  */\n-DEFTREECODE (VECTOR_CST, \"vector_cst\", 'c', 0)\n+DEFTREECODE (VECTOR_CST, \"vector_cst\", tcc_constant, 0)\n \n /* Contents are TREE_STRING_LENGTH and TREE_STRING_POINTER fields.  */\n-DEFTREECODE (STRING_CST, \"string_cst\", 'c', 0)\n+DEFTREECODE (STRING_CST, \"string_cst\", tcc_constant, 0)\n \n /* Declarations.  All references to names are represented as ..._DECL\n    nodes.  The decls in one binding context are chained through the\n@@ -338,22 +327,23 @@ DEFTREECODE (STRING_CST, \"string_cst\", 'c', 0)\n    of a decl (i.e. one which is nested within an abstract instance of a\n    inline function.  */\n \n-DEFTREECODE (FUNCTION_DECL, \"function_decl\", 'd', 0)\n-DEFTREECODE (LABEL_DECL, \"label_decl\", 'd', 0)\n-DEFTREECODE (CONST_DECL, \"const_decl\", 'd', 0)\n-DEFTREECODE (TYPE_DECL, \"type_decl\", 'd', 0)\n-DEFTREECODE (VAR_DECL, \"var_decl\", 'd', 0)\n-DEFTREECODE (PARM_DECL, \"parm_decl\", 'd', 0)\n-DEFTREECODE (RESULT_DECL, \"result_decl\", 'd', 0)\n-DEFTREECODE (FIELD_DECL, \"field_decl\", 'd', 0)\n+DEFTREECODE (FUNCTION_DECL, \"function_decl\", tcc_declaration, 0)\n+DEFTREECODE (LABEL_DECL, \"label_decl\", tcc_declaration, 0)\n+DEFTREECODE (CONST_DECL, \"const_decl\", tcc_declaration, 0)\n+DEFTREECODE (TYPE_DECL, \"type_decl\", tcc_declaration, 0)\n+DEFTREECODE (VAR_DECL, \"var_decl\", tcc_declaration, 0)\n+DEFTREECODE (PARM_DECL, \"parm_decl\", tcc_declaration, 0)\n+DEFTREECODE (RESULT_DECL, \"result_decl\", tcc_declaration, 0)\n+DEFTREECODE (FIELD_DECL, \"field_decl\", tcc_declaration, 0)\n \n /* A namespace declaration.  Namespaces appear in DECL_CONTEXT of other\n    _DECLs, providing a hierarchy of names.  */\n-DEFTREECODE (NAMESPACE_DECL, \"namespace_decl\", 'd', 0)\n+DEFTREECODE (NAMESPACE_DECL, \"namespace_decl\", tcc_declaration, 0)\n \n /* A translation unit.  This is not technically a declaration, since it\n    can't be looked up, but it's close enough.  */\n-DEFTREECODE (TRANSLATION_UNIT_DECL, \"translation_unit_decl\", 'd', 0)\n+DEFTREECODE (TRANSLATION_UNIT_DECL, \"translation_unit_decl\",\\\n+\t     tcc_declaration, 0)\n \f\n /* References to storage.  */\n \n@@ -362,7 +352,7 @@ DEFTREECODE (TRANSLATION_UNIT_DECL, \"translation_unit_decl\", 'd', 0)\n    Operand 1 is the field (a node of type FIELD_DECL).\n    Operand 2, if present, is the value of DECL_FIELD_OFFSET, measured\n    in units of DECL_OFFSET_ALIGN / BITS_PER_UNIT.  */\n-DEFTREECODE (COMPONENT_REF, \"component_ref\", 'r', 3)\n+DEFTREECODE (COMPONENT_REF, \"component_ref\", tcc_reference, 3)\n \n /* Reference to a group of bits within an object.  Similar to COMPONENT_REF\n    except the position is given explicitly rather than via a FIELD_DECL.\n@@ -371,22 +361,22 @@ DEFTREECODE (COMPONENT_REF, \"component_ref\", 'r', 3)\n    operand 2 is a tree giving the position of the first referenced bit.\n    The field can be either a signed or unsigned field;\n    BIT_FIELD_REF_UNSIGNED says which.  */\n-DEFTREECODE (BIT_FIELD_REF, \"bit_field_ref\", 'r', 3)\n+DEFTREECODE (BIT_FIELD_REF, \"bit_field_ref\", tcc_reference, 3)\n \n /* C unary `*' or Pascal `^'.  One operand, an expression for a pointer.  */\n-DEFTREECODE (INDIRECT_REF, \"indirect_ref\", 'r', 1)\n+DEFTREECODE (INDIRECT_REF, \"indirect_ref\", tcc_reference, 1)\n \n /* Array indexing.\n    Operand 0 is the array; operand 1 is a (single) array index.\n    Operand 2, if present, is a copy of TYPE_MIN_VALUE of the index.\n    Operand 3, if present, is the element size, measured in units of\n    the alignment of the element type.  */\n-DEFTREECODE (ARRAY_REF, \"array_ref\", 'r', 4)\n+DEFTREECODE (ARRAY_REF, \"array_ref\", tcc_reference, 4)\n \n /* Likewise, except that the result is a range (\"slice\") of the array.  The\n    starting index of the resulting array is taken from operand 1 and the size\n    of the range is taken from the type of the expression.  */\n-DEFTREECODE (ARRAY_RANGE_REF, \"array_range_ref\", 'r', 4)\n+DEFTREECODE (ARRAY_RANGE_REF, \"array_range_ref\", tcc_reference, 4)\n \n /* Used to represent lookup of runtime type dependent data.  Often this is\n    a reference to a vtable, but it needn't be.  Operands are:\n@@ -398,13 +388,13 @@ DEFTREECODE (ARRAY_RANGE_REF, \"array_range_ref\", 'r', 4)\n    reference to something simpler, usually to the address of a DECL.\n    Never touched by the middle-end.  Good choices would be either an\n    identifier or a vtable index.  */\n-DEFTREECODE (OBJ_TYPE_REF, \"obj_type_ref\", 'e', 3)\n+DEFTREECODE (OBJ_TYPE_REF, \"obj_type_ref\", tcc_expression, 3)\n \n /* The exception object from the runtime.  */\n-DEFTREECODE (EXC_PTR_EXPR, \"exc_ptr_expr\", 'e', 0)\n+DEFTREECODE (EXC_PTR_EXPR, \"exc_ptr_expr\", tcc_expression, 0)\n \n /* The filter object from the runtime.  */\n-DEFTREECODE (FILTER_EXPR, \"filter_expr\", 'e', 0)\n+DEFTREECODE (FILTER_EXPR, \"filter_expr\", tcc_expression, 0)\n \n /* Constructor: return an aggregate value made from specified components.\n    In C, this is used only for structure and array initializers.\n@@ -426,7 +416,7 @@ DEFTREECODE (FILTER_EXPR, \"filter_expr\", 'e', 0)\n    The TREE_VALUE specifies a value (index) in the set that is true.\n    If TREE_PURPOSE is non-NULL, it specifies the lower limit of a\n    range of true values.  Elements not listed are false (not in the set).  */\n-DEFTREECODE (CONSTRUCTOR, \"constructor\", 'e', 1)\n+DEFTREECODE (CONSTRUCTOR, \"constructor\", tcc_expression, 1)\n \n /* The expression types are mostly straightforward, with the fourth argument\n    of DEFTREECODE saying how many operands there are.\n@@ -436,22 +426,22 @@ DEFTREECODE (CONSTRUCTOR, \"constructor\", 'e', 1)\n /* Contains two expressions to compute, one followed by the other.\n    the first value is ignored.  The second one's value is used.  The\n    type of the first expression need not agree with the other types.  */\n-DEFTREECODE (COMPOUND_EXPR, \"compound_expr\", 'e', 2)\n+DEFTREECODE (COMPOUND_EXPR, \"compound_expr\", tcc_expression, 2)\n \n /* Assignment expression.  Operand 0 is the what to set; 1, the new value.  */\n-DEFTREECODE (MODIFY_EXPR, \"modify_expr\", 'e', 2)\n+DEFTREECODE (MODIFY_EXPR, \"modify_expr\", tcc_expression, 2)\n \n /* Initialization expression.  Operand 0 is the variable to initialize;\n    Operand 1 is the initializer.  */\n-DEFTREECODE (INIT_EXPR, \"init_expr\", 'e', 2)\n+DEFTREECODE (INIT_EXPR, \"init_expr\", tcc_expression, 2)\n \n /* For TARGET_EXPR, operand 0 is the target of an initialization,\n    operand 1 is the initializer for the target, which may be void\n      if simply expanding it initializes the target.\n    operand 2 is the cleanup for this node, if any.\n    operand 3 is the saved initializer after this node has been\n    expanded once; this is so we can re-expand the tree later.  */\n-DEFTREECODE (TARGET_EXPR, \"target_expr\", 'e', 4)\n+DEFTREECODE (TARGET_EXPR, \"target_expr\", tcc_expression, 4)\n \n /* Conditional expression ( ... ? ... : ...  in C).\n    Operand 0 is the condition.\n@@ -461,7 +451,7 @@ DEFTREECODE (TARGET_EXPR, \"target_expr\", 'e', 4)\n    Operand 1 must have the same type as the entire expression, unless\n    it unconditionally throws an exception, in which case it should\n    have VOID_TYPE.  The same constraints apply to operand 2.  */\n-DEFTREECODE (COND_EXPR, \"cond_expr\", 'e', 3)\n+DEFTREECODE (COND_EXPR, \"cond_expr\", tcc_expression, 3)\n \n /* Declare local variables, including making RTL and allocating space.\n    BIND_EXPR_VARS is a chain of VAR_DECL nodes for the variables.\n@@ -484,25 +474,25 @@ DEFTREECODE (COND_EXPR, \"cond_expr\", 'e', 3)\n    In order for the BIND_EXPR to be known at all, the code that creates it\n    must also install it as a subblock in the tree of BLOCK\n    nodes for the function.  */\n-DEFTREECODE (BIND_EXPR, \"bind_expr\", 'e', 3)\n+DEFTREECODE (BIND_EXPR, \"bind_expr\", tcc_expression, 3)\n \n /* A labeled block. Operand 0 is the label that will be generated to\n    mark the end of the block.\n    Operand 1 is the labeled block body.  */\n-DEFTREECODE (LABELED_BLOCK_EXPR, \"labeled_block_expr\", 'e', 2)\n+DEFTREECODE (LABELED_BLOCK_EXPR, \"labeled_block_expr\", tcc_expression, 2)\n \n /* Function call.  Operand 0 is the function.\n    Operand 1 is the argument list, a list of expressions\n    made out of a chain of TREE_LIST nodes.\n    Operand 2 is the static chain argument, or NULL.  */\n-DEFTREECODE (CALL_EXPR, \"call_expr\", 'e', 3)\n+DEFTREECODE (CALL_EXPR, \"call_expr\", tcc_expression, 3)\n \n /* Specify a value to compute along with its corresponding cleanup.\n    Operand 0 is the cleanup expression.\n    The cleanup is executed by the first enclosing CLEANUP_POINT_EXPR,\n    which must exist.  This differs from TRY_CATCH_EXPR in that operand 1\n    is always evaluated when cleanups are run.  */\n-DEFTREECODE (WITH_CLEANUP_EXPR, \"with_cleanup_expr\", 'e', 1)\n+DEFTREECODE (WITH_CLEANUP_EXPR, \"with_cleanup_expr\", tcc_expression, 1)\n \n /* Specify a cleanup point.\n    Operand 0 is an expression that may have cleanups.  If it does, those\n@@ -519,7 +509,7 @@ DEFTREECODE (WITH_CLEANUP_EXPR, \"with_cleanup_expr\", 'e', 1)\n \n    As a consequence, the operand of a CLEANUP_POINT_EXPR must not have\n    BLKmode, because it will not be forced out of memory.  */\n-DEFTREECODE (CLEANUP_POINT_EXPR, \"cleanup_point_expr\", 'e', 1)\n+DEFTREECODE (CLEANUP_POINT_EXPR, \"cleanup_point_expr\", tcc_expression, 1)\n \n /* The following two codes are used in languages that have types where\n    some field in an object of the type contains a value that is used in\n@@ -571,62 +561,62 @@ DEFTREECODE (CLEANUP_POINT_EXPR, \"cleanup_point_expr\", 'e', 1)\n \n /* Denotes a record to later be substituted before evaluating this expression.\n    The type of this expression is used to find the record to replace it.  */\n-DEFTREECODE (PLACEHOLDER_EXPR, \"placeholder_expr\", 'x', 0)\n+DEFTREECODE (PLACEHOLDER_EXPR, \"placeholder_expr\", tcc_exceptional, 0)\n \n /* Simple arithmetic.  */\n-DEFTREECODE (PLUS_EXPR, \"plus_expr\", '2', 2)\n-DEFTREECODE (MINUS_EXPR, \"minus_expr\", '2', 2)\n-DEFTREECODE (MULT_EXPR, \"mult_expr\", '2', 2)\n+DEFTREECODE (PLUS_EXPR, \"plus_expr\", tcc_binary, 2)\n+DEFTREECODE (MINUS_EXPR, \"minus_expr\", tcc_binary, 2)\n+DEFTREECODE (MULT_EXPR, \"mult_expr\", tcc_binary, 2)\n \n /* Division for integer result that rounds the quotient toward zero.  */\n-DEFTREECODE (TRUNC_DIV_EXPR, \"trunc_div_expr\", '2', 2)\n+DEFTREECODE (TRUNC_DIV_EXPR, \"trunc_div_expr\", tcc_binary, 2)\n \n /* Division for integer result that rounds the quotient toward infinity.  */\n-DEFTREECODE (CEIL_DIV_EXPR, \"ceil_div_expr\", '2', 2)\n+DEFTREECODE (CEIL_DIV_EXPR, \"ceil_div_expr\", tcc_binary, 2)\n \n /* Division for integer result that rounds toward minus infinity.  */\n-DEFTREECODE (FLOOR_DIV_EXPR, \"floor_div_expr\", '2', 2)\n+DEFTREECODE (FLOOR_DIV_EXPR, \"floor_div_expr\", tcc_binary, 2)\n \n /* Division for integer result that rounds toward nearest integer.  */\n-DEFTREECODE (ROUND_DIV_EXPR, \"round_div_expr\", '2', 2)\n+DEFTREECODE (ROUND_DIV_EXPR, \"round_div_expr\", tcc_binary, 2)\n \n /* Four kinds of remainder that go with the four kinds of division.  */\n-DEFTREECODE (TRUNC_MOD_EXPR, \"trunc_mod_expr\", '2', 2)\n-DEFTREECODE (CEIL_MOD_EXPR, \"ceil_mod_expr\", '2', 2)\n-DEFTREECODE (FLOOR_MOD_EXPR, \"floor_mod_expr\", '2', 2)\n-DEFTREECODE (ROUND_MOD_EXPR, \"round_mod_expr\", '2', 2)\n+DEFTREECODE (TRUNC_MOD_EXPR, \"trunc_mod_expr\", tcc_binary, 2)\n+DEFTREECODE (CEIL_MOD_EXPR, \"ceil_mod_expr\", tcc_binary, 2)\n+DEFTREECODE (FLOOR_MOD_EXPR, \"floor_mod_expr\", tcc_binary, 2)\n+DEFTREECODE (ROUND_MOD_EXPR, \"round_mod_expr\", tcc_binary, 2)\n \n /* Division for real result.  */\n-DEFTREECODE (RDIV_EXPR, \"rdiv_expr\", '2', 2)\n+DEFTREECODE (RDIV_EXPR, \"rdiv_expr\", tcc_binary, 2)\n \n /* Division which is not supposed to need rounding.\n    Used for pointer subtraction in C.  */\n-DEFTREECODE (EXACT_DIV_EXPR, \"exact_div_expr\", '2', 2)\n+DEFTREECODE (EXACT_DIV_EXPR, \"exact_div_expr\", tcc_binary, 2)\n \n /* Conversion of real to fixed point: four ways to round,\n    like the four ways to divide.\n    CONVERT_EXPR can also be used to convert a real to an integer,\n    and that is what is used in languages that do not have ways of\n    specifying which of these is wanted.  Maybe these are not needed.  */\n-DEFTREECODE (FIX_TRUNC_EXPR, \"fix_trunc_expr\", '1', 1)\n-DEFTREECODE (FIX_CEIL_EXPR, \"fix_ceil_expr\", '1', 1)\n-DEFTREECODE (FIX_FLOOR_EXPR, \"fix_floor_expr\", '1', 1)\n-DEFTREECODE (FIX_ROUND_EXPR, \"fix_round_expr\", '1', 1)\n+DEFTREECODE (FIX_TRUNC_EXPR, \"fix_trunc_expr\", tcc_unary, 1)\n+DEFTREECODE (FIX_CEIL_EXPR, \"fix_ceil_expr\", tcc_unary, 1)\n+DEFTREECODE (FIX_FLOOR_EXPR, \"fix_floor_expr\", tcc_unary, 1)\n+DEFTREECODE (FIX_ROUND_EXPR, \"fix_round_expr\", tcc_unary, 1)\n \n /* Conversion of an integer to a real.  */\n-DEFTREECODE (FLOAT_EXPR, \"float_expr\", '1', 1)\n+DEFTREECODE (FLOAT_EXPR, \"float_expr\", tcc_unary, 1)\n \n /* Unary negation.  */\n-DEFTREECODE (NEGATE_EXPR, \"negate_expr\", '1', 1)\n+DEFTREECODE (NEGATE_EXPR, \"negate_expr\", tcc_unary, 1)\n \n-DEFTREECODE (MIN_EXPR, \"min_expr\", '2', 2)\n-DEFTREECODE (MAX_EXPR, \"max_expr\", '2', 2)\n+DEFTREECODE (MIN_EXPR, \"min_expr\", tcc_binary, 2)\n+DEFTREECODE (MAX_EXPR, \"max_expr\", tcc_binary, 2)\n \n /* Represents the absolute value of the operand.\n \n    An ABS_EXPR must have either an INTEGER_TYPE or a REAL_TYPE.  The\n    operand of the ABS_EXPR must have the same type.  */\n-DEFTREECODE (ABS_EXPR, \"abs_expr\", '1', 1)\n+DEFTREECODE (ABS_EXPR, \"abs_expr\", tcc_unary, 1)\n \n /* Shift operations for shift and rotate.\n    Shift means logical shift if done on an\n@@ -635,16 +625,16 @@ DEFTREECODE (ABS_EXPR, \"abs_expr\", '1', 1)\n    shift by; it need not be the same type as the first operand and result.\n    Note that the result is undefined if the second operand is larger\n    than the first operand's type size.  */\n-DEFTREECODE (LSHIFT_EXPR, \"lshift_expr\", '2', 2)\n-DEFTREECODE (RSHIFT_EXPR, \"rshift_expr\", '2', 2)\n-DEFTREECODE (LROTATE_EXPR, \"lrotate_expr\", '2', 2)\n-DEFTREECODE (RROTATE_EXPR, \"rrotate_expr\", '2', 2)\n+DEFTREECODE (LSHIFT_EXPR, \"lshift_expr\", tcc_binary, 2)\n+DEFTREECODE (RSHIFT_EXPR, \"rshift_expr\", tcc_binary, 2)\n+DEFTREECODE (LROTATE_EXPR, \"lrotate_expr\", tcc_binary, 2)\n+DEFTREECODE (RROTATE_EXPR, \"rrotate_expr\", tcc_binary, 2)\n \n /* Bitwise operations.  Operands have same mode as result.  */\n-DEFTREECODE (BIT_IOR_EXPR, \"bit_ior_expr\", '2', 2)\n-DEFTREECODE (BIT_XOR_EXPR, \"bit_xor_expr\", '2', 2)\n-DEFTREECODE (BIT_AND_EXPR, \"bit_and_expr\", '2', 2)\n-DEFTREECODE (BIT_NOT_EXPR, \"bit_not_expr\", '1', 1)\n+DEFTREECODE (BIT_IOR_EXPR, \"bit_ior_expr\", tcc_binary, 2)\n+DEFTREECODE (BIT_XOR_EXPR, \"bit_xor_expr\", tcc_binary, 2)\n+DEFTREECODE (BIT_AND_EXPR, \"bit_and_expr\", tcc_binary, 2)\n+DEFTREECODE (BIT_NOT_EXPR, \"bit_not_expr\", tcc_unary, 1)\n \n /* ANDIF and ORIF allow the second operand not to be computed if the\n    value of the expression is determined from the first operand.  AND,\n@@ -655,52 +645,52 @@ DEFTREECODE (BIT_NOT_EXPR, \"bit_not_expr\", '1', 1)\n    an INTEGER_TYPE VAR_DECL as its argument; instead, a NE_EXPR will be\n    used to compare the VAR_DECL to zero, thereby obtaining a node with\n    value zero or one.  */\n-DEFTREECODE (TRUTH_ANDIF_EXPR, \"truth_andif_expr\", 'e', 2)\n-DEFTREECODE (TRUTH_ORIF_EXPR, \"truth_orif_expr\", 'e', 2)\n-DEFTREECODE (TRUTH_AND_EXPR, \"truth_and_expr\", 'e', 2)\n-DEFTREECODE (TRUTH_OR_EXPR, \"truth_or_expr\", 'e', 2)\n-DEFTREECODE (TRUTH_XOR_EXPR, \"truth_xor_expr\", 'e', 2)\n-DEFTREECODE (TRUTH_NOT_EXPR, \"truth_not_expr\", 'e', 1)\n+DEFTREECODE (TRUTH_ANDIF_EXPR, \"truth_andif_expr\", tcc_expression, 2)\n+DEFTREECODE (TRUTH_ORIF_EXPR, \"truth_orif_expr\", tcc_expression, 2)\n+DEFTREECODE (TRUTH_AND_EXPR, \"truth_and_expr\", tcc_expression, 2)\n+DEFTREECODE (TRUTH_OR_EXPR, \"truth_or_expr\", tcc_expression, 2)\n+DEFTREECODE (TRUTH_XOR_EXPR, \"truth_xor_expr\", tcc_expression, 2)\n+DEFTREECODE (TRUTH_NOT_EXPR, \"truth_not_expr\", tcc_expression, 1)\n \n /* Relational operators.\n    `EQ_EXPR' and `NE_EXPR' are allowed for any types.\n    The others are allowed only for integer (or pointer or enumeral)\n    or real types.\n    In all cases the operands will have the same type,\n    and the value is always the type used by the language for booleans.  */\n-DEFTREECODE (LT_EXPR, \"lt_expr\", '<', 2)\n-DEFTREECODE (LE_EXPR, \"le_expr\", '<', 2)\n-DEFTREECODE (GT_EXPR, \"gt_expr\", '<', 2)\n-DEFTREECODE (GE_EXPR, \"ge_expr\", '<', 2)\n-DEFTREECODE (EQ_EXPR, \"eq_expr\", '<', 2)\n-DEFTREECODE (NE_EXPR, \"ne_expr\", '<', 2)\n+DEFTREECODE (LT_EXPR, \"lt_expr\", tcc_comparison, 2)\n+DEFTREECODE (LE_EXPR, \"le_expr\", tcc_comparison, 2)\n+DEFTREECODE (GT_EXPR, \"gt_expr\", tcc_comparison, 2)\n+DEFTREECODE (GE_EXPR, \"ge_expr\", tcc_comparison, 2)\n+DEFTREECODE (EQ_EXPR, \"eq_expr\", tcc_comparison, 2)\n+DEFTREECODE (NE_EXPR, \"ne_expr\", tcc_comparison, 2)\n \n /* Additional relational operators for floating point unordered.  */\n-DEFTREECODE (UNORDERED_EXPR, \"unordered_expr\", '<', 2)\n-DEFTREECODE (ORDERED_EXPR, \"ordered_expr\", '<', 2)\n+DEFTREECODE (UNORDERED_EXPR, \"unordered_expr\", tcc_comparison, 2)\n+DEFTREECODE (ORDERED_EXPR, \"ordered_expr\", tcc_comparison, 2)\n \n /* These are equivalent to unordered or ...  */\n-DEFTREECODE (UNLT_EXPR, \"unlt_expr\", '<', 2)\n-DEFTREECODE (UNLE_EXPR, \"unle_expr\", '<', 2)\n-DEFTREECODE (UNGT_EXPR, \"ungt_expr\", '<', 2)\n-DEFTREECODE (UNGE_EXPR, \"unge_expr\", '<', 2)\n-DEFTREECODE (UNEQ_EXPR, \"uneq_expr\", '<', 2)\n+DEFTREECODE (UNLT_EXPR, \"unlt_expr\", tcc_comparison, 2)\n+DEFTREECODE (UNLE_EXPR, \"unle_expr\", tcc_comparison, 2)\n+DEFTREECODE (UNGT_EXPR, \"ungt_expr\", tcc_comparison, 2)\n+DEFTREECODE (UNGE_EXPR, \"unge_expr\", tcc_comparison, 2)\n+DEFTREECODE (UNEQ_EXPR, \"uneq_expr\", tcc_comparison, 2)\n \n /* This is the reverse of uneq_expr.  */\n-DEFTREECODE (LTGT_EXPR, \"ltgt_expr\", '<', 2)\n+DEFTREECODE (LTGT_EXPR, \"ltgt_expr\", tcc_comparison, 2)\n \n-DEFTREECODE (RANGE_EXPR, \"range_expr\", '2', 2)\n+DEFTREECODE (RANGE_EXPR, \"range_expr\", tcc_binary, 2)\n \n /* Represents a conversion of type of a value.\n    All conversions, including implicit ones, must be\n    represented by CONVERT_EXPR or NOP_EXPR nodes.  */\n-DEFTREECODE (CONVERT_EXPR, \"convert_expr\", '1', 1)\n+DEFTREECODE (CONVERT_EXPR, \"convert_expr\", tcc_unary, 1)\n \n /* Represents a conversion expected to require no code to be generated.  */\n-DEFTREECODE (NOP_EXPR, \"nop_expr\", '1', 1)\n+DEFTREECODE (NOP_EXPR, \"nop_expr\", tcc_unary, 1)\n \n /* Value is same as argument, but guaranteed not an lvalue.  */\n-DEFTREECODE (NON_LVALUE_EXPR, \"non_lvalue_expr\", '1', 1)\n+DEFTREECODE (NON_LVALUE_EXPR, \"non_lvalue_expr\", tcc_unary, 1)\n \n /* Represents viewing something of one type as being of a second type.\n    This corresponds to an \"Unchecked Conversion\" in Ada and roughly to\n@@ -712,91 +702,91 @@ DEFTREECODE (NON_LVALUE_EXPR, \"non_lvalue_expr\", '1', 1)\n    case no actual data motion may occur.  TREE_ADDRESSABLE will be set in\n    this case and GCC must abort if it could not do the operation without\n    generating insns.  */\n-DEFTREECODE (VIEW_CONVERT_EXPR, \"view_convert_expr\", 'r', 1)\n+DEFTREECODE (VIEW_CONVERT_EXPR, \"view_convert_expr\", tcc_reference, 1)\n \n /* Represents something we computed once and will use multiple times.\n    First operand is that expression.  After it is evaluated once, it\n    will be replaced by the temporary variable that holds the value.  */\n-DEFTREECODE (SAVE_EXPR, \"save_expr\", 'e', 1)\n+DEFTREECODE (SAVE_EXPR, \"save_expr\", tcc_expression, 1)\n \n /* & in C.  Value is the address at which the operand's value resides.\n    Operand may have any mode.  Result mode is Pmode.  */\n-DEFTREECODE (ADDR_EXPR, \"addr_expr\", 'e', 1)\n+DEFTREECODE (ADDR_EXPR, \"addr_expr\", tcc_expression, 1)\n \n /* Operand0 is a function constant; result is part N of a function\n    descriptor of type ptr_mode.  */\n-DEFTREECODE (FDESC_EXPR, \"fdesc_expr\", 'e', 2)\n+DEFTREECODE (FDESC_EXPR, \"fdesc_expr\", tcc_expression, 2)\n \n /* Given two real or integer operands of the same type,\n    returns a complex value of the corresponding complex type.  */\n-DEFTREECODE (COMPLEX_EXPR, \"complex_expr\", '2', 2)\n+DEFTREECODE (COMPLEX_EXPR, \"complex_expr\", tcc_binary, 2)\n \n /* Complex conjugate of operand.  Used only on complex types.  */\n-DEFTREECODE (CONJ_EXPR, \"conj_expr\", '1', 1)\n+DEFTREECODE (CONJ_EXPR, \"conj_expr\", tcc_unary, 1)\n \n /* Used only on an operand of complex type, these return\n    a value of the corresponding component type.  */\n-DEFTREECODE (REALPART_EXPR, \"realpart_expr\", 'r', 1)\n-DEFTREECODE (IMAGPART_EXPR, \"imagpart_expr\", 'r', 1)\n+DEFTREECODE (REALPART_EXPR, \"realpart_expr\", tcc_reference, 1)\n+DEFTREECODE (IMAGPART_EXPR, \"imagpart_expr\", tcc_reference, 1)\n \n /* Nodes for ++ and -- in C.\n    The second arg is how much to increment or decrement by.\n    For a pointer, it would be the size of the object pointed to.  */\n-DEFTREECODE (PREDECREMENT_EXPR, \"predecrement_expr\", 'e', 2)\n-DEFTREECODE (PREINCREMENT_EXPR, \"preincrement_expr\", 'e', 2)\n-DEFTREECODE (POSTDECREMENT_EXPR, \"postdecrement_expr\", 'e', 2)\n-DEFTREECODE (POSTINCREMENT_EXPR, \"postincrement_expr\", 'e', 2)\n+DEFTREECODE (PREDECREMENT_EXPR, \"predecrement_expr\", tcc_expression, 2)\n+DEFTREECODE (PREINCREMENT_EXPR, \"preincrement_expr\", tcc_expression, 2)\n+DEFTREECODE (POSTDECREMENT_EXPR, \"postdecrement_expr\", tcc_expression, 2)\n+DEFTREECODE (POSTINCREMENT_EXPR, \"postincrement_expr\", tcc_expression, 2)\n \n /* Used to implement `va_arg'.  */\n-DEFTREECODE (VA_ARG_EXPR, \"va_arg_expr\", 'e', 1)\n+DEFTREECODE (VA_ARG_EXPR, \"va_arg_expr\", tcc_expression, 1)\n \n /* Evaluate operand 1.  If and only if an exception is thrown during\n    the evaluation of operand 1, evaluate operand 2.\n \n    This differs from TRY_FINALLY_EXPR in that operand 2 is not evaluated\n    on a normal or jump exit, only on an exception.  */\n-DEFTREECODE (TRY_CATCH_EXPR, \"try_catch_expr\", 's', 2)\n+DEFTREECODE (TRY_CATCH_EXPR, \"try_catch_expr\", tcc_statement, 2)\n \n /* Evaluate the first operand.\n    The second operand is a cleanup expression which is evaluated\n    on any exit (normal, exception, or jump out) from this expression.  */\n-DEFTREECODE (TRY_FINALLY_EXPR, \"try_finally\", 's', 2)\n+DEFTREECODE (TRY_FINALLY_EXPR, \"try_finally\", tcc_statement, 2)\n \f\n /* These types of expressions have no useful value,\n    and always have side effects.  */\n \n /* Used to represent a local declaration. The operand is DECL_EXPR_DECL.  */\n-DEFTREECODE (DECL_EXPR, \"decl_expr\", 's', 1)\n+DEFTREECODE (DECL_EXPR, \"decl_expr\", tcc_statement, 1)\n \n /* A label definition, encapsulated as a statement.\n    Operand 0 is the LABEL_DECL node for the label that appears here.\n    The type should be void and the value should be ignored.  */\n-DEFTREECODE (LABEL_EXPR, \"label_expr\", 's', 1)\n+DEFTREECODE (LABEL_EXPR, \"label_expr\", tcc_statement, 1)\n \n /* GOTO.  Operand 0 is a LABEL_DECL node or an expression.\n    The type should be void and the value should be ignored.  */\n-DEFTREECODE (GOTO_EXPR, \"goto_expr\", 's', 1)\n+DEFTREECODE (GOTO_EXPR, \"goto_expr\", tcc_statement, 1)\n \n /* RETURN.  Evaluates operand 0, then returns from the current function.\n    Presumably that operand is an assignment that stores into the\n    RESULT_DECL that hold the value to be returned.\n    The operand may be null.\n    The type should be void and the value should be ignored.  */\n-DEFTREECODE (RETURN_EXPR, \"return_expr\", 's', 1)\n+DEFTREECODE (RETURN_EXPR, \"return_expr\", tcc_statement, 1)\n \n /* Exit the inner most loop conditionally.  Operand 0 is the condition.\n    The type should be void and the value should be ignored.  */\n-DEFTREECODE (EXIT_EXPR, \"exit_expr\", 's', 1)\n+DEFTREECODE (EXIT_EXPR, \"exit_expr\", tcc_statement, 1)\n \n /* A loop.  Operand 0 is the body of the loop.\n    It must contain an EXIT_EXPR or is an infinite loop.\n    The type should be void and the value should be ignored.  */\n-DEFTREECODE (LOOP_EXPR, \"loop_expr\", 's', 1)\n+DEFTREECODE (LOOP_EXPR, \"loop_expr\", tcc_statement, 1)\n \n /* Exit a labeled block, possibly returning a value.  Operand 0 is a\n    LABELED_BLOCK_EXPR to exit.  Operand 1 is the value to return. It\n    may be left null.  */\n-DEFTREECODE (EXIT_BLOCK_EXPR, \"exit_block_expr\", 's', 2)\n+DEFTREECODE (EXIT_BLOCK_EXPR, \"exit_block_expr\", tcc_statement, 2)\n \n /* Switch expression.\n \n@@ -810,79 +800,79 @@ DEFTREECODE (EXIT_BLOCK_EXPR, \"exit_block_expr\", 's', 2)\n      must not be NULL.\n    Operand 2 is either NULL_TREE or a TREE_VEC of the CASE_LABEL_EXPRs\n      of all the cases.  */\n-DEFTREECODE (SWITCH_EXPR, \"switch_expr\", 's', 3)\n+DEFTREECODE (SWITCH_EXPR, \"switch_expr\", tcc_statement, 3)\n \n /* Used to represent a case label. The operands are CASE_LOW and\n    CASE_HIGH, respectively. If CASE_LOW is NULL_TREE, the label is a\n    'default' label. If CASE_HIGH is NULL_TREE, the label is a normal case\n    label.  CASE_LABEL is the corresponding LABEL_DECL.  */\n-DEFTREECODE (CASE_LABEL_EXPR, \"case_label_expr\", 's', 3)\n+DEFTREECODE (CASE_LABEL_EXPR, \"case_label_expr\", tcc_statement, 3)\n \n /* RESX.  Resume execution after an exception.  Operand 0 is a\n    number indicating the exception region that is being left.  */\n-DEFTREECODE (RESX_EXPR, \"resx_expr\", 's', 1)\n+DEFTREECODE (RESX_EXPR, \"resx_expr\", tcc_statement, 1)\n \n /* Used to represent an inline assembly statement.  ASM_STRING returns a\n    STRING_CST for the instruction (e.g., \"mov x, y\"). ASM_OUTPUTS,\n    ASM_INPUTS, and ASM_CLOBBERS represent the outputs, inputs, and clobbers\n    for the statement.  */\n-DEFTREECODE (ASM_EXPR, \"asm_expr\", 's', 4)\n+DEFTREECODE (ASM_EXPR, \"asm_expr\", tcc_statement, 4)\n \n /* Variable references for SSA analysis.  New SSA names are created every\n    time a variable is assigned a new value.  The SSA builder uses SSA_NAME\n    nodes to implement SSA versioning.  */\n-DEFTREECODE (SSA_NAME, \"ssa_name\", 'x', 0)\n+DEFTREECODE (SSA_NAME, \"ssa_name\", tcc_exceptional, 0)\n \n /* SSA PHI operator.  PHI_RESULT is the new SSA_NAME node created by\n    the PHI node.  PHI_ARG_LENGTH is the number of arguments.\n    PHI_ARG_ELT returns the Ith tuple <ssa_name, edge> from the\n    argument list.  Each tuple contains the incoming reaching\n    definition (SSA_NAME node) and the edge via which that definition\n    is coming through.   */\n-DEFTREECODE (PHI_NODE, \"phi_node\", 'x', 0)\n+DEFTREECODE (PHI_NODE, \"phi_node\", tcc_exceptional, 0)\n \n /* Used to represent a typed exception handler.  CATCH_TYPES is the type (or\n    list of types) handled, and CATCH_BODY is the code for the handler.  */\n-DEFTREECODE (CATCH_EXPR, \"catch_expr\", 's', 2)\n+DEFTREECODE (CATCH_EXPR, \"catch_expr\", tcc_statement, 2)\n \n /* Used to represent an exception specification.  EH_FILTER_TYPES is a list\n    of allowed types, and EH_FILTER_FAILURE is an expression to evaluate on\n    failure.  EH_FILTER_MUST_NOT_THROW controls which range type to use when\n    expanding.  */\n-DEFTREECODE (EH_FILTER_EXPR, \"eh_filter_expr\", 's', 2)\n+DEFTREECODE (EH_FILTER_EXPR, \"eh_filter_expr\", tcc_statement, 2)\n \n /* Node used for describing a property that is known at compile\n    time.  */\n-DEFTREECODE (SCEV_KNOWN, \"scev_known\", 'e', 0)\n+DEFTREECODE (SCEV_KNOWN, \"scev_known\", tcc_expression, 0)\n \n /* Node used for describing a property that is not known at compile\n    time.  */\n-DEFTREECODE (SCEV_NOT_KNOWN, \"scev_not_known\", 'e', 0)\n+DEFTREECODE (SCEV_NOT_KNOWN, \"scev_not_known\", tcc_expression, 0)\n \n /* Polynomial chains of recurrences.\n    Under the form: cr = {CHREC_LEFT (cr), +, CHREC_RIGHT (cr)}.  */\n-DEFTREECODE (POLYNOMIAL_CHREC, \"polynomial_chrec\", 'e', 3)\n+DEFTREECODE (POLYNOMIAL_CHREC, \"polynomial_chrec\", tcc_expression, 3)\n \n /* Used to chain children of container statements together.\n    Use the interface in tree-iterator.h to access this node.  */\n-DEFTREECODE (STATEMENT_LIST, \"statement_list\", 'x', 0)\n+DEFTREECODE (STATEMENT_LIST, \"statement_list\", tcc_exceptional, 0)\n \n /* Value handles.  Artificial nodes to represent expressions in\n    partial redundancy elimination (tree-ssa-pre.c).  These nodes are\n    used for expression canonicalization.  If two expressions compute\n    the same value, they will be assigned the same value handle.  */\n-DEFTREECODE (VALUE_HANDLE, \"value_handle\", 'x', 0)\n+DEFTREECODE (VALUE_HANDLE, \"value_handle\", tcc_exceptional, 0)\n \n /* Base class information. Holds information about a class as a\n    baseclass of itself or another class.  */\n-DEFTREECODE (TREE_BINFO, \"tree_binfo\", 'x', 0)\n+DEFTREECODE (TREE_BINFO, \"tree_binfo\", tcc_exceptional, 0)\n \n /* Records the size for an expression of variable size type.  This is\n    for use in contexts in which we are accessing the entire object,\n    such as for a function call, or block copy.\n    Operand 0 is the real expression.\n    Operand 1 is the size of the type in the expression.  */\n-DEFTREECODE (WITH_SIZE_EXPR, \"with_size_expr\", 'e', 2)\n+DEFTREECODE (WITH_SIZE_EXPR, \"with_size_expr\", tcc_expression, 2)\n \n /*\n Local variables:"}, {"sha": "83f90b7773a50f65307749717d49c83de7cc941c", "filename": "gcc/tree.h", "status": "modified", "additions": 99, "deletions": 32, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=6615c446157600e6dbe0b716f48e80a64e49807f", "patch": "@@ -43,25 +43,103 @@ enum tree_code {\n /* Number of language-independent tree codes.  */\n #define NUM_TREE_CODES ((int) LAST_AND_UNUSED_TREE_CODE)\n \n-/* Indexed by enum tree_code, contains a character which is\n-   `<' for a comparison expression, `1', for a unary arithmetic\n-   expression, `2' for a binary arithmetic expression, `e' for\n-   other types of expressions, `r' for a reference, `c' for a\n-   constant, `d' for a decl, `t' for a type, `s' for a statement,\n-   and `x' for anything else (TREE_LIST, IDENTIFIER, etc).  */\n+/* Tree code classes.  */\n+\n+/* Each tree_code has an associated code class represented by a\n+   TREE_CODE_CLASS.  */\n+\n+enum tree_code_class {\n+  tcc_exceptional, /* An exceptional code (fits no category).  */\n+  tcc_constant,    /* A constant.  */\n+  tcc_type,        /* A type object code.  */\n+  tcc_declaration, /* A declaration (also serving as variable refs).  */\n+  tcc_reference,   /* A reference to storage.  */\n+  tcc_comparison,  /* A comparison expression.  */\n+  tcc_unary,       /* A unary arithmetic expression.  */\n+  tcc_binary,      /* A binary arithmetic expression.  */\n+  tcc_statement,   /* A statement expression, which have side effects\n+\t\t      but usually no interesting value.  */\n+  tcc_expression   /* Any other expression.  */\n+};\n+\n+/* Each tree code class has an associated string representation.\n+   These must correspond to the tree_code_class entries.  */\n+\n+extern const char* tree_code_class_strings[];\n+\n+/* Returns the string representing CLASS.  */\n+\n+#define TREE_CODE_CLASS_STRING(CLASS)\\\n+        tree_code_class_strings[(int) (CLASS)]\n \n #define MAX_TREE_CODES 256\n-extern const char tree_code_type[];\n+extern const enum tree_code_class tree_code_type[];\n #define TREE_CODE_CLASS(CODE)\ttree_code_type[(int) (CODE)]\n \n+/* Nonzero if CODE represents an exceptional code.  */\n+\n+#define EXCEPTIONAL_CLASS_P(CODE)\\\n+\t(TREE_CODE_CLASS (TREE_CODE (CODE)) == tcc_exceptional)\n+\n+/* Nonzero if CODE represents a constant.  */\n+\n+#define CONSTANT_CLASS_P(CODE)\\\n+\t(TREE_CODE_CLASS (TREE_CODE (CODE)) == tcc_constant)\n+\n+/* Nonzero if CODE represents a type.  */\n+\n+#define TYPE_P(CODE)\\\n+\t(TREE_CODE_CLASS (TREE_CODE (CODE)) == tcc_type)\n+\n+/* Nonzero if CODE represents a declaration.  */\n+\n+#define DECL_P(CODE)\\\n+        (TREE_CODE_CLASS (TREE_CODE (CODE)) == tcc_declaration)\n+\n+/* Nonzero if CODE represents a reference.  */\n+\n+#define REFERENCE_CLASS_P(CODE)\\\n+\t(TREE_CODE_CLASS (TREE_CODE (CODE)) == tcc_reference)\n+\n+/* Nonzero if CODE represents a comparison.  */\n+\n+#define COMPARISON_CLASS_P(CODE)\\\n+\t(TREE_CODE_CLASS (TREE_CODE (CODE)) == tcc_comparison)\n+\n+/* Nonzero if CODE represents a unary arithmetic expression.  */\n+\n+#define UNARY_CLASS_P(CODE)\\\n+\t(TREE_CODE_CLASS (TREE_CODE (CODE)) == tcc_unary)\n+\n+/* Nonzero if CODE represents a binary arithmetic expression.  */\n+\n+#define BINARY_CLASS_P(CODE)\\\n+\t(TREE_CODE_CLASS (TREE_CODE (CODE)) == tcc_binary)\n+\n+/* Nonzero if CODE represents a statement expression.  */\n+\n+#define STATEMENT_CLASS_P(CODE)\\\n+\t(TREE_CODE_CLASS (TREE_CODE (CODE)) == tcc_statement)\n+\n+/* Nonzero if CODE represents any other expression.  */\n+\n+#define EXPRESSION_CLASS_P(CODE)\\\n+\t(TREE_CODE_CLASS (TREE_CODE (CODE)) == tcc_expression)\n+\n /* Returns nonzero iff CLASS is not the tree code of a type.  */\n \n-#define IS_NON_TYPE_CODE_CLASS(CLASS) ((CLASS) != 't')\n+#define IS_NON_TYPE_CODE_CLASS(CLASS) ((CLASS) != tcc_type)\n+\n+/* Returns nonzero iff CODE represents a type or declaration.  */\n+\n+#define IS_TYPE_OR_DECL_P(CODE)\\\n+\t(TYPE_P (CODE) || DECL_P (CODE))\n \n /* Returns nonzero iff CLASS is the tree-code class of an\n    expression.  */\n \n-#define IS_EXPR_CODE_CLASS(CLASS) (strchr (\"<12ers\", (CLASS)) != 0)\n+#define IS_EXPR_CODE_CLASS(CLASS)\\\n+\t(((CLASS) >= tcc_reference) && ((CLASS) <= tcc_expression))\n \n /* Returns nonzero iff NODE is an expression of some kind.  */\n \n@@ -448,7 +526,7 @@ struct tree_common GTY(())\n ({  const tree __t = (T);\t\t\t\t\t\t\\\n     char const __c = TREE_CODE_CLASS (TREE_CODE (__t));\t\t\t\\\n     if (!IS_EXPR_CODE_CLASS (__c))\t\t\t\t\t\\\n-      tree_class_check_failed (__t, 'E', __FILE__, __LINE__,\t\t\\\n+      tree_class_check_failed (__t, tcc_expression, __FILE__, __LINE__,\t\\\n \t\t\t       __FUNCTION__);\t\t\t\t\\\n     __t; })\n \n@@ -457,7 +535,7 @@ struct tree_common GTY(())\n ({  const tree __t = (T);\t\t\t\t\t\t\\\n     char const __c = TREE_CODE_CLASS (TREE_CODE (__t));\t\t\t\\\n     if (!IS_NON_TYPE_CODE_CLASS (__c))\t\t\t\t\t\\\n-      tree_class_check_failed (__t, 'T', __FILE__, __LINE__,\t\t\\\n+      tree_class_check_failed (__t, tcc_type, __FILE__, __LINE__,\t\\\n \t\t\t       __FUNCTION__);\t\t\t\t\\\n     __t; })\n \n@@ -517,7 +595,7 @@ extern void tree_check_failed (const tree, const char *, int, const char *,\n \t\t\t       ...) ATTRIBUTE_NORETURN;\n extern void tree_not_check_failed (const tree, const char *, int, const char *,\n \t\t\t\t   ...) ATTRIBUTE_NORETURN;\n-extern void tree_class_check_failed (const tree, int,\n+extern void tree_class_check_failed (const tree, const enum tree_code_class,\n \t\t\t\t     const char *, int, const char *)\n     ATTRIBUTE_NORETURN;\n extern void tree_vec_elt_check_failed (int, int, const char *,\n@@ -557,10 +635,10 @@ extern void tree_operand_check_failed (int, enum tree_code,\n \n #include \"tree-check.h\"\n \n-#define TYPE_CHECK(T)\t\tTREE_CLASS_CHECK (T, 't')\n-#define DECL_CHECK(T)\t\tTREE_CLASS_CHECK (T, 'd')\n-#define CST_CHECK(T)\t\tTREE_CLASS_CHECK (T, 'c')\n-#define STMT_CHECK(T)\t\tTREE_CLASS_CHECK (T, 's')\n+#define TYPE_CHECK(T)\t\tTREE_CLASS_CHECK (T, tcc_type)\n+#define DECL_CHECK(T)\t\tTREE_CLASS_CHECK (T, tcc_declaration)\n+#define CST_CHECK(T)\t\tTREE_CLASS_CHECK (T, tcc_constant)\n+#define STMT_CHECK(T)\t\tTREE_CLASS_CHECK (T, tcc_statement)\n #define FUNC_OR_METHOD_CHECK(T)\tTREE_CHECK2 (T, FUNCTION_TYPE, METHOD_TYPE)\n #define PTR_OR_REF_CHECK(T)\tTREE_CHECK2 (T, POINTER_TYPE, REFERENCE_TYPE)\n \n@@ -712,9 +790,6 @@ extern void tree_operand_check_failed (int, enum tree_code,\n #define COMPLETE_OR_UNBOUND_ARRAY_TYPE_P(NODE) \\\n   (COMPLETE_TYPE_P (TREE_CODE (NODE) == ARRAY_TYPE ? TREE_TYPE (NODE) : (NODE)))\n \n-/* Nonzero if TYPE represents a type.  */\n-\n-#define TYPE_P(TYPE)\t(TREE_CODE_CLASS (TREE_CODE (TYPE)) == 't')\n \f\n /* Define many boolean fields that all tree nodes have.  */\n \n@@ -839,7 +914,8 @@ extern void tree_operand_check_failed (int, enum tree_code,\n #define TREE_READONLY(NODE) (NON_TYPE_CHECK (NODE)->common.readonly_flag)\n \n /* Nonzero if NODE is a _DECL with TREE_READONLY set.  */\n-#define TREE_READONLY_DECL_P(NODE) (DECL_P (NODE) && TREE_READONLY (NODE))\n+#define TREE_READONLY_DECL_P(NODE)\\\n+\t(DECL_P (NODE) && TREE_READONLY (NODE))\n \n /* Value of expression is constant.  Always on in all ..._CST nodes.  May\n    also appear in an expression or decl where the value is constant.  */\n@@ -1091,17 +1167,13 @@ struct tree_vec GTY(())\n    decls and constants can be shared among multiple locations, so\n    return nothing.  */\n #define EXPR_LOCATION(NODE)\t\t\t\t\t\\\n-  (IS_EXPR_CODE_CLASS (TREE_CODE_CLASS (TREE_CODE (NODE)))\t\\\n-   ? (NODE)->exp.locus\t\t\t\t\t\t\\\n-   : UNKNOWN_LOCATION)\n+  (EXPR_P (NODE) ? (NODE)->exp.locus : UNKNOWN_LOCATION)\n #define SET_EXPR_LOCATION(NODE, FROM) \\\n   (EXPR_CHECK (NODE)->exp.locus = (FROM))\n #define EXPR_HAS_LOCATION(NODE) (EXPR_LOCATION (NODE) != UNKNOWN_LOCATION)\n /* EXPR_LOCUS and SET_EXPR_LOCUS are deprecated.  */\n #define EXPR_LOCUS(NODE)\t\t\t\t\t\\\n-  (IS_EXPR_CODE_CLASS (TREE_CODE_CLASS (TREE_CODE (NODE)))\t\\\n-   ? &(NODE)->exp.locus\t\t\t\t\t\t\\\n-   : (location_t *)NULL)\n+  (EXPR_P (NODE) ? &(NODE)->exp.locus : (location_t *)NULL)\n #define SET_EXPR_LOCUS(NODE, FROM) \\\n   do { source_location *loc_tmp = FROM; \\\n        EXPR_CHECK (NODE)->exp.locus \\\n@@ -1115,9 +1187,7 @@ struct tree_vec GTY(())\n    decls and constants can be shared among multiple locations, so\n    return nothing.  */\n #define EXPR_LOCUS(NODE)\t\t\t\t\t\\\n-  (IS_EXPR_CODE_CLASS (TREE_CODE_CLASS (TREE_CODE (NODE)))\t\\\n-   ? (NODE)->exp.locus\t\t\t\t\t\t\\\n-   : (location_t *)NULL)\n+  (EXPR_P (NODE) ? (NODE)->exp.locus : (location_t *)NULL)\n #define SET_EXPR_LOCUS(NODE, FROM) \\\n   (EXPR_CHECK (NODE)->exp.locus = (FROM))\n #define SET_EXPR_LOCATION(NODE, FROM) annotate_with_locus (NODE, FROM)\n@@ -1753,9 +1823,6 @@ struct tree_binfo GTY (())\n \f\n /* Define fields and accessors for nodes representing declared names.  */\n \n-/* Nonzero if DECL represents a decl.  */\n-#define DECL_P(DECL)\t(TREE_CODE_CLASS (TREE_CODE (DECL)) == 'd')\n-\n /* Nonzero if DECL represents a variable for the SSA passes.  */\n #define SSA_VAR_P(DECL) \\\n \t(TREE_CODE (DECL) == VAR_DECL\t\\"}, {"sha": "773a50a5e465853e7bc508de2c43cf49475bd613", "filename": "gcc/treelang/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Ftreelang%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Ftreelang%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftreelang%2FChangeLog?ref=6615c446157600e6dbe0b716f48e80a64e49807f", "patch": "@@ -1,3 +1,8 @@\n+2004-09-17  Jeffrey D. Oldham  <oldham@codesourcery.com>\n+\t    Zack Weinberg  <zack@codesourcery.com>\n+\n+\t* treetree.c: Update for new tree-class enumeration constants.\n+\n 2004-09-15  Zack Weinberg  <zack@codesourcery.com>\n \n \t* Make-lang.in (treelang-warn): Set to $(STRICT_WARN)."}, {"sha": "e0a220fe65da0a9603e6dfd2e41f7bb552b4e26a", "filename": "gcc/treelang/treetree.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Ftreelang%2Ftreetree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Ftreelang%2Ftreetree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftreelang%2Ftreetree.c?ref=6615c446157600e6dbe0b716f48e80a64e49807f", "patch": "@@ -199,9 +199,9 @@ const struct lang_hooks lang_hooks = LANG_HOOKS_INITIALIZER;\n \n #define DEFTREECODE(SYM, NAME, TYPE, LENGTH) TYPE,\n \n-const char tree_code_type[] = {\n+const enum tree_code_class tree_code_type[] = {\n #include \"tree.def\"\n-  'x'\n+  tcc_exceptional\n };\n #undef DEFTREECODE\n "}, {"sha": "5bb96c648cfb53616e746284e359a7b0fc8a8004", "filename": "gcc/varasm.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6615c446157600e6dbe0b716f48e80a64e49807f/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=6615c446157600e6dbe0b716f48e80a64e49807f", "patch": "@@ -2466,7 +2466,7 @@ copy_constant (tree exp)\n     case ADDR_EXPR:\n       /* For ADDR_EXPR, we do not want to copy the decl whose address\n \t is requested.  We do want to copy constants though.  */\n-      if (TREE_CODE_CLASS (TREE_CODE (TREE_OPERAND (exp, 0))) == 'c')\n+      if (CONSTANT_CLASS_P (TREE_OPERAND (exp, 0)))\n \treturn build1 (TREE_CODE (exp), TREE_TYPE (exp),\n \t\t       copy_constant (TREE_OPERAND (exp, 0)));\n       else\n@@ -3378,8 +3378,7 @@ output_addressed_constants (tree exp)\n \t   tem = TREE_OPERAND (tem, 0))\n \t;\n \n-      if (TREE_CODE_CLASS (TREE_CODE (tem)) == 'c'\n-\t  || TREE_CODE (tem) == CONSTRUCTOR)\n+      if (CONSTANT_CLASS_P (tem) || TREE_CODE (tem) == CONSTRUCTOR)\n \toutput_constant_def (tem, 0);\n       break;\n "}]}