{"sha": "93bad80ebc1ab5f6ee336002c26244b8eff5202e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTNiYWQ4MGViYzFhYjVmNmVlMzM2MDAyYzI2MjQ0YjhlZmY1MjAyZQ==", "commit": {"author": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2003-09-14T13:42:33Z"}, "committer": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2003-09-14T13:42:33Z"}, "message": "ra.c: Convert to ISO C90 prototypes.\n\n2003-09-14  Steven Bosscher  <steven@gcc.gnu.org>\n\n\t* ra.c: Convert to ISO C90 prototypes.\n\t* ra-build.c: Likewise.\n\t* ra-colorize.c: Likewise.\n\t* ra-debug.c: Likewise.\n\t* ra-rewrite.c: Likewise.\n\nFrom-SVN: r71379", "tree": {"sha": "ea31a83d868ad9e736e2c3651d1a3006b5fa5c98", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ea31a83d868ad9e736e2c3651d1a3006b5fa5c98"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/93bad80ebc1ab5f6ee336002c26244b8eff5202e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/93bad80ebc1ab5f6ee336002c26244b8eff5202e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/93bad80ebc1ab5f6ee336002c26244b8eff5202e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/93bad80ebc1ab5f6ee336002c26244b8eff5202e/comments", "author": null, "committer": null, "parents": [{"sha": "3983d33ea8d7bbee76bc53db3a5eb1d2139f5bbf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3983d33ea8d7bbee76bc53db3a5eb1d2139f5bbf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3983d33ea8d7bbee76bc53db3a5eb1d2139f5bbf"}], "stats": {"total": 869, "additions": 335, "deletions": 534}, "files": [{"sha": "903db9b2f3fd16695609393b73a8e3e7d8c38360", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93bad80ebc1ab5f6ee336002c26244b8eff5202e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93bad80ebc1ab5f6ee336002c26244b8eff5202e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=93bad80ebc1ab5f6ee336002c26244b8eff5202e", "patch": "@@ -1,3 +1,11 @@\n+2003-09-14  Steven Bosscher  <steven@gcc.gnu.org>\n+\n+\t* ra.c: Convert to ISO C90 prototypes.\n+\t* ra-build.c: Likewise.\n+\t* ra-colorize.c: Likewise.\n+\t* ra-debug.c: Likewise.\n+\t* ra-rewrite.c: Likewise.\n+\n 2003-09-14  Richard Sandiford  <rsandifo@redhat.com>\n \n \t* Makefile.in (%.dvi): Remove excess $(docdir)."}, {"sha": "896570ebf91179877f6ce1d9bfbd62e4206f5417", "filename": "gcc/ra-build.c", "status": "modified", "additions": 106, "deletions": 175, "changes": 281, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93bad80ebc1ab5f6ee336002c26244b8eff5202e/gcc%2Fra-build.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93bad80ebc1ab5f6ee336002c26244b8eff5202e/gcc%2Fra-build.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fra-build.c?ref=93bad80ebc1ab5f6ee336002c26244b8eff5202e", "patch": "@@ -68,60 +68,59 @@\n \n struct curr_use;\n \n-static unsigned HOST_WIDE_INT rtx_to_undefined PARAMS ((rtx));\n-static bitmap find_sub_conflicts PARAMS ((struct web_part *, unsigned int));\n-static bitmap get_sub_conflicts PARAMS ((struct web_part *, unsigned int));\n-static unsigned int undef_to_size_word PARAMS ((rtx, unsigned HOST_WIDE_INT *));\n-static bitmap undef_to_bitmap PARAMS ((struct web_part *,\n-\t\t\t\t       unsigned HOST_WIDE_INT *));\n-static struct web_part * find_web_part_1 PARAMS ((struct web_part *));\n+static unsigned HOST_WIDE_INT rtx_to_undefined (rtx);\n+static bitmap find_sub_conflicts (struct web_part *, unsigned int);\n+static bitmap get_sub_conflicts (struct web_part *, unsigned int);\n+static unsigned int undef_to_size_word (rtx, unsigned HOST_WIDE_INT *);\n+static bitmap undef_to_bitmap (struct web_part *,\n+\t\t\t       unsigned HOST_WIDE_INT *);\n+static struct web_part * find_web_part_1 (struct web_part *);\n static struct web_part * union_web_part_roots\n-\t\t\t\tPARAMS ((struct web_part *, struct web_part *));\n-static int defuse_overlap_p_1 PARAMS ((rtx, struct curr_use *));\n-static int live_out_1 PARAMS ((struct df *, struct curr_use *, rtx));\n-static int live_out PARAMS ((struct df *, struct curr_use *, rtx));\n-static rtx live_in_edge PARAMS (( struct df *, struct curr_use *, edge));\n-static void live_in PARAMS ((struct df *, struct curr_use *, rtx));\n-static int copy_insn_p PARAMS ((rtx, rtx *, rtx *));\n-static void remember_move PARAMS ((rtx));\n-static void handle_asm_insn PARAMS ((struct df *, rtx));\n-static void prune_hardregs_for_mode PARAMS ((HARD_REG_SET *,\n-\t\t\t\t\t     enum machine_mode));\n-static void init_one_web_common PARAMS ((struct web *, rtx));\n-static void init_one_web PARAMS ((struct web *, rtx));\n-static void reinit_one_web PARAMS ((struct web *, rtx));\n-static struct web * add_subweb PARAMS ((struct web *, rtx));\n-static struct web * add_subweb_2 PARAMS ((struct web *, unsigned int));\n-static void init_web_parts PARAMS ((struct df *));\n-static void copy_conflict_list PARAMS ((struct web *));\n-static void add_conflict_edge PARAMS ((struct web *, struct web *));\n-static void build_inverse_webs PARAMS ((struct web *));\n-static void copy_web PARAMS ((struct web *, struct web_link **));\n-static void compare_and_free_webs PARAMS ((struct web_link **));\n-static void init_webs_defs_uses PARAMS ((void));\n-static unsigned int parts_to_webs_1 PARAMS ((struct df *, struct web_link **,\n-\t\t\t\t\t     struct df_link *));\n-static void parts_to_webs PARAMS ((struct df *));\n-static void reset_conflicts PARAMS ((void));\n+\t\t\t\t(struct web_part *, struct web_part *);\n+static int defuse_overlap_p_1 (rtx, struct curr_use *);\n+static int live_out_1 (struct df *, struct curr_use *, rtx);\n+static int live_out (struct df *, struct curr_use *, rtx);\n+static rtx live_in_edge ( struct df *, struct curr_use *, edge);\n+static void live_in (struct df *, struct curr_use *, rtx);\n+static int copy_insn_p (rtx, rtx *, rtx *);\n+static void remember_move (rtx);\n+static void handle_asm_insn (struct df *, rtx);\n+static void prune_hardregs_for_mode (HARD_REG_SET *, enum machine_mode);\n+static void init_one_web_common (struct web *, rtx);\n+static void init_one_web (struct web *, rtx);\n+static void reinit_one_web (struct web *, rtx);\n+static struct web * add_subweb (struct web *, rtx);\n+static struct web * add_subweb_2 (struct web *, unsigned int);\n+static void init_web_parts (struct df *);\n+static void copy_conflict_list (struct web *);\n+static void add_conflict_edge (struct web *, struct web *);\n+static void build_inverse_webs (struct web *);\n+static void copy_web (struct web *, struct web_link **);\n+static void compare_and_free_webs (struct web_link **);\n+static void init_webs_defs_uses (void);\n+static unsigned int parts_to_webs_1 (struct df *, struct web_link **,\n+\t\t\t\t     struct df_link *);\n+static void parts_to_webs (struct df *);\n+static void reset_conflicts (void);\n #if 0\n-static void check_conflict_numbers PARAMS ((void));\n+static void check_conflict_numbers (void)\n #endif\n-static void conflicts_between_webs PARAMS ((struct df *));\n-static void remember_web_was_spilled PARAMS ((struct web *));\n-static void detect_spill_temps PARAMS ((void));\n-static int contains_pseudo PARAMS ((rtx));\n-static int want_to_remat PARAMS ((rtx x));\n-static void detect_remat_webs PARAMS ((void));\n-static void determine_web_costs PARAMS ((void));\n-static void detect_webs_set_in_cond_jump PARAMS ((void));\n-static void make_webs PARAMS ((struct df *));\n-static void moves_to_webs PARAMS ((struct df *));\n-static void connect_rmw_web_parts PARAMS ((struct df *));\n-static void update_regnos_mentioned PARAMS ((void));\n-static void livethrough_conflicts_bb PARAMS ((basic_block));\n-static void init_bb_info PARAMS ((void));\n-static void free_bb_info PARAMS ((void));\n-static void build_web_parts_and_conflicts PARAMS ((struct df *));\n+static void conflicts_between_webs (struct df *);\n+static void remember_web_was_spilled (struct web *);\n+static void detect_spill_temps (void);\n+static int contains_pseudo (rtx);\n+static int want_to_remat (rtx x);\n+static void detect_remat_webs (void);\n+static void determine_web_costs (void);\n+static void detect_webs_set_in_cond_jump (void);\n+static void make_webs (struct df *);\n+static void moves_to_webs (struct df *);\n+static void connect_rmw_web_parts (struct df *);\n+static void update_regnos_mentioned (void);\n+static void livethrough_conflicts_bb (basic_block);\n+static void init_bb_info (void);\n+static void free_bb_info (void);\n+static void build_web_parts_and_conflicts (struct df *);\n \n \n /* A sbitmap of DF_REF_IDs of uses, which are live over an abnormal\n@@ -181,8 +180,7 @@ struct ra_bb_info\n    as an integer.  */\n \n unsigned int\n-rtx_to_bits (x)\n-     rtx x;\n+rtx_to_bits (rtx x)\n {\n   unsigned int len, beg;\n   len = GET_MODE_SIZE (GET_MODE (x));\n@@ -193,8 +191,7 @@ rtx_to_bits (x)\n /* X is a REG or SUBREG rtx.  Return the bytes it touches as a bitmask.  */\n \n static unsigned HOST_WIDE_INT\n-rtx_to_undefined (x)\n-     rtx x;\n+rtx_to_undefined (rtx x)\n {\n   unsigned int len, beg;\n   unsigned HOST_WIDE_INT ret;\n@@ -225,10 +222,7 @@ int *number_seen;\n    not NULL.  */\n \n static int\n-copy_insn_p (insn, source, target)\n-     rtx insn;\n-     rtx *source;\n-     rtx *target;\n+copy_insn_p (rtx insn, rtx *source, rtx *target)\n {\n   rtx d, s;\n   unsigned int d_regno, s_regno;\n@@ -308,9 +302,7 @@ copy_insn_p (insn, source, target)\n    exist yet in WP.  */\n \n static bitmap\n-find_sub_conflicts (wp, size_word)\n-     struct web_part *wp;\n-     unsigned int size_word;\n+find_sub_conflicts (struct web_part *wp, unsigned int size_word)\n {\n   struct tagged_conflict *cl;\n   cl = wp->sub_conflicts;\n@@ -324,9 +316,7 @@ find_sub_conflicts (wp, size_word)\n    doesn't exist.  I.e. this never returns NULL.  */\n \n static bitmap\n-get_sub_conflicts (wp, size_word)\n-     struct web_part *wp;\n-     unsigned int size_word;\n+get_sub_conflicts (struct web_part *wp, unsigned int size_word)\n {\n   bitmap b = find_sub_conflicts (wp, size_word);\n   if (!b)\n@@ -382,9 +372,7 @@ static struct undef_table_s {\n    */\n \n static unsigned int\n-undef_to_size_word (reg, undefined)\n-     rtx reg;\n-     unsigned HOST_WIDE_INT *undefined;\n+undef_to_size_word (rtx reg, unsigned HOST_WIDE_INT *undefined)\n {\n   /* When only the lower four bits are possibly set, we use\n      a fast lookup table.  */\n@@ -440,9 +428,7 @@ undef_to_size_word (reg, undefined)\n    covered by the part for that bitmap.  */\n \n static bitmap\n-undef_to_bitmap (wp, undefined)\n-     struct web_part *wp;\n-     unsigned HOST_WIDE_INT *undefined;\n+undef_to_bitmap (struct web_part *wp, unsigned HOST_WIDE_INT *undefined)\n {\n   unsigned int size_word = undef_to_size_word (DF_REF_REAL_REG (wp->ref),\n \t\t\t\t\t       undefined);\n@@ -453,8 +439,7 @@ undef_to_bitmap (wp, undefined)\n    it compresses the path.  P may not be NULL.  */\n \n static struct web_part *\n-find_web_part_1 (p)\n-     struct web_part *p;\n+find_web_part_1 (struct web_part *p)\n {\n   struct web_part *r = p;\n   struct web_part *p_next;\n@@ -480,8 +465,7 @@ find_web_part_1 (p)\n    The root of the resulting (possibly larger) web part is returned.  */\n \n static struct web_part *\n-union_web_part_roots (r1, r2)\n-     struct web_part *r1, *r2;\n+union_web_part_roots (struct web_part *r1, struct web_part *r2)\n {\n   if (r1 != r2)\n     {\n@@ -552,8 +536,7 @@ union_web_part_roots (r1, r2)\n /* Remember that we've handled a given move, so we don't reprocess it.  */\n \n static void\n-remember_move (insn)\n-     rtx insn;\n+remember_move (rtx insn)\n {\n   if (!TEST_BIT (move_handled, INSN_UID (insn)))\n     {\n@@ -629,9 +612,7 @@ struct curr_use {\n    otherwise a test is needed to track the already defined bytes.  */\n \n static int\n-defuse_overlap_p_1 (def, use)\n-     rtx def;\n-     struct curr_use *use;\n+defuse_overlap_p_1 (rtx def, struct curr_use *use)\n {\n   int mode = 0;\n   if (def == use->x)\n@@ -708,10 +689,7 @@ defuse_overlap_p_1 (def, use)\n    this insn.  */\n \n static int\n-live_out_1 (df, use, insn)\n-     struct df *df ATTRIBUTE_UNUSED;\n-     struct curr_use *use;\n-     rtx insn;\n+live_out_1 (struct df *df ATTRIBUTE_UNUSED, struct curr_use *use, rtx insn)\n {\n   int defined = 0;\n   int uid = INSN_UID (insn);\n@@ -863,10 +841,7 @@ live_out_1 (df, use, insn)\n    this insn).  */\n \n static inline int\n-live_out (df, use, insn)\n-     struct df *df;\n-     struct curr_use *use;\n-     rtx insn;\n+live_out (struct df *df, struct curr_use *use, rtx insn)\n {\n   unsigned int uid = INSN_UID (insn);\n   if (visit_trace[uid].wp\n@@ -894,10 +869,7 @@ live_out (df, use, insn)\n    which uses are live at the end of that basic block.  */\n \n static rtx\n-live_in_edge (df, use, e)\n-     struct df *df;\n-     struct curr_use *use;\n-     edge e;\n+live_in_edge (struct df *df, struct curr_use *use, edge e)\n {\n   struct ra_bb_info *info_pred;\n   rtx next_insn;\n@@ -943,10 +915,7 @@ live_in_edge (df, use, e)\n    def-use chains, and all defs during that chain are noted.  */\n \n static void\n-live_in (df, use, insn)\n-     struct df *df;\n-     struct curr_use *use;\n-     rtx insn;\n+live_in (struct df *df, struct curr_use *use, rtx insn)\n {\n   unsigned int loc_vpass = visited_pass;\n \n@@ -1006,7 +975,7 @@ live_in (df, use, insn)\n    pass.  */\n \n static void\n-update_regnos_mentioned ()\n+update_regnos_mentioned (void)\n {\n   int last_uid = last_max_uid;\n   rtx insn;\n@@ -1048,8 +1017,7 @@ update_regnos_mentioned ()\n    spanned_deaths members.  */\n \n static void\n-livethrough_conflicts_bb (bb)\n-     basic_block bb;\n+livethrough_conflicts_bb (basic_block bb)\n {\n   struct ra_bb_info *info = (struct ra_bb_info *) bb->aux;\n   rtx insn;\n@@ -1106,7 +1074,7 @@ livethrough_conflicts_bb (bb)\n    building live ranges.  */\n \n static void\n-init_bb_info ()\n+init_bb_info (void)\n {\n   basic_block bb;\n   FOR_ALL_BB (bb)\n@@ -1122,7 +1090,7 @@ init_bb_info ()\n /* Free that per basic block info.  */\n \n static void\n-free_bb_info ()\n+free_bb_info (void)\n {\n   basic_block bb;\n   FOR_ALL_BB (bb)\n@@ -1140,8 +1108,7 @@ free_bb_info ()\n    their conflicts.  */\n \n static void\n-build_web_parts_and_conflicts (df)\n-     struct df *df;\n+build_web_parts_and_conflicts (struct df *df)\n {\n   struct df_link *link;\n   struct curr_use use;\n@@ -1198,8 +1165,7 @@ build_web_parts_and_conflicts (df)\n    read-mod-write instruction), so we must reconnect such webs.  */\n \n static void\n-connect_rmw_web_parts (df)\n-     struct df *df;\n+connect_rmw_web_parts (struct df *df)\n {\n   unsigned int i;\n \n@@ -1228,19 +1194,15 @@ connect_rmw_web_parts (df)\n /* Deletes all hardregs from *S which are not allowed for MODE.  */\n \n static void\n-prune_hardregs_for_mode (s, mode)\n-     HARD_REG_SET *s;\n-     enum machine_mode mode;\n+prune_hardregs_for_mode (HARD_REG_SET *s, enum machine_mode mode)\n {\n   AND_HARD_REG_SET (*s, hardregs_for_mode[(int) mode]);\n }\n \n /* Initialize the members of a web, which are deducible from REG.  */\n \n static void\n-init_one_web_common (web, reg)\n-     struct web *web;\n-     rtx reg;\n+init_one_web_common (struct web *web, rtx reg)\n {\n   if (GET_CODE (reg) != REG)\n     abort ();\n@@ -1317,9 +1279,7 @@ init_one_web_common (web, reg)\n /* Initializes WEBs members from REG or zero them.  */\n \n static void\n-init_one_web (web, reg)\n-     struct web *web;\n-     rtx reg;\n+init_one_web (struct web *web, rtx reg)\n {\n   memset (web, 0, sizeof (struct web));\n   init_one_web_common (web, reg);\n@@ -1331,9 +1291,7 @@ init_one_web (web, reg)\n    members.  */\n \n static void\n-reinit_one_web (web, reg)\n-     struct web *web;\n-     rtx reg;\n+reinit_one_web (struct web *web, rtx reg)\n {\n   web->old_color = web->color + 1;\n   init_one_web_common (web, reg);\n@@ -1374,9 +1332,7 @@ reinit_one_web (web, reg)\n    becomes its super web).  It must not exist already.  */\n \n static struct web *\n-add_subweb (web, reg)\n-     struct web *web;\n-     rtx reg;\n+add_subweb (struct web *web, rtx reg)\n {\n   struct web *w;\n   if (GET_CODE (reg) != SUBREG)\n@@ -1402,9 +1358,7 @@ add_subweb (web, reg)\n    In difference to add_subweb() this marks the new subweb as artificial.  */\n \n static struct web *\n-add_subweb_2 (web, size_word)\n-     struct web *web;\n-     unsigned int size_word;\n+add_subweb_2 (struct web *web, unsigned int  size_word)\n {\n   /* To get a correct mode for the to be produced subreg, we don't want to\n      simply do a mode_for_size() for the mode_class of the whole web.\n@@ -1431,8 +1385,7 @@ add_subweb_2 (web, size_word)\n /* Initialize all the web parts we are going to need.  */\n \n static void\n-init_web_parts (df)\n-     struct df *df;\n+init_web_parts (struct df *df)\n {\n   int regno;\n   unsigned int no;\n@@ -1506,8 +1459,7 @@ init_web_parts (df)\n    new conflicts, we copy it here to orig_conflict_list.  */\n \n static void\n-copy_conflict_list (web)\n-     struct web *web;\n+copy_conflict_list (struct web *web)\n {\n   struct conflict_link *cl;\n   if (web->orig_conflict_list || web->have_orig_conflicts)\n@@ -1546,8 +1498,7 @@ copy_conflict_list (web)\n    happen, if SUBREG webs are involved.  */\n \n static void\n-add_conflict_edge (from, to)\n-     struct web *from, *to;\n+add_conflict_edge (struct web *from, struct web *to)\n {\n   if (from->type != PRECOLORED)\n     {\n@@ -1612,8 +1563,7 @@ add_conflict_edge (from, to)\n    already.  */\n \n void\n-record_conflict (web1, web2)\n-     struct web *web1, *web2;\n+record_conflict (struct web *web1, struct web *web2)\n {\n   unsigned int id1 = web1->id, id2 = web2->id;\n   unsigned int index = igraph_index (id1, id2);\n@@ -1665,8 +1615,7 @@ record_conflict (web1, web2)\n    possible to exactly specify (W-Wy) for all already existing subwebs Wy.  */\n \n static void\n-build_inverse_webs (web)\n-     struct web *web;\n+build_inverse_webs (struct web *web)\n {\n   struct web *sweb = web->subreg_next;\n   unsigned HOST_WIDE_INT undef;\n@@ -1691,9 +1640,7 @@ build_inverse_webs (web)\n    Used for consistency checking.  */\n \n static void\n-copy_web (web, wl)\n-     struct web *web;\n-     struct web_link **wl;\n+copy_web (struct web *web, struct web_link **wl)\n {\n   struct web *cweb = xmalloc (sizeof *cweb);\n   struct web_link *link = ra_alloc (sizeof *link);\n@@ -1707,8 +1654,7 @@ copy_web (web, wl)\n    with the global webs of the same ID.  For consistency checking.  */\n \n static void\n-compare_and_free_webs (link)\n-     struct web_link **link;\n+compare_and_free_webs (struct web_link **link)\n {\n   struct web_link *wl;\n   for (wl = *link; wl; wl = wl->next)\n@@ -1757,7 +1703,7 @@ compare_and_free_webs (link)\n /* Setup and fill uses[] and defs[] arrays of the webs.  */\n \n static void\n-init_webs_defs_uses ()\n+init_webs_defs_uses (void)\n {\n   struct dlist *d;\n   for (d = WEBS(INITIAL); d; d = d->next)\n@@ -1795,10 +1741,8 @@ init_webs_defs_uses ()\n    up use2web and def2web arrays.  */\n \n static unsigned int\n-parts_to_webs_1 (df, copy_webs, all_refs)\n-     struct df *df;\n-     struct web_link **copy_webs;\n-     struct df_link *all_refs;\n+parts_to_webs_1 (struct df *df, struct web_link **copy_webs,\n+\t\t struct df_link *all_refs)\n {\n   unsigned int i;\n   unsigned int webnum;\n@@ -2016,8 +1960,7 @@ parts_to_webs_1 (df, copy_webs, all_refs)\n    other (i.e. without creating the conflict edges).  */\n \n static void\n-parts_to_webs (df)\n-     struct df *df;\n+parts_to_webs (struct df *df)\n {\n   unsigned int i;\n   unsigned int webnum;\n@@ -2115,7 +2058,7 @@ parts_to_webs (df)\n    conflicts.  */\n \n static void\n-reset_conflicts ()\n+reset_conflicts (void)\n {\n   unsigned int i;\n   bitmap newwebs = BITMAP_XMALLOC ();\n@@ -2197,7 +2140,7 @@ reset_conflicts ()\n \n #if 0\n static void\n-check_conflict_numbers ()\n+check_conflict_numbers (void)\n {\n   unsigned int i;\n   for (i = 0; i < num_webs; i++)\n@@ -2228,8 +2171,7 @@ check_conflict_numbers ()\n    in reality conflict get the same color.  */\n \n static void\n-conflicts_between_webs (df)\n-     struct df *df;\n+conflicts_between_webs (struct df *df)\n {\n   unsigned int i;\n #ifdef STACK_REGS\n@@ -2327,8 +2269,7 @@ conflicts_between_webs (df)\n    accordingly.  */\n \n static void\n-remember_web_was_spilled (web)\n-     struct web *web;\n+remember_web_was_spilled (struct web *web)\n {\n   int i;\n   unsigned int found_size = 0;\n@@ -2408,7 +2349,7 @@ remember_web_was_spilled (web)\n    if it will be spillable in this pass.  */\n \n static void\n-detect_spill_temps ()\n+detect_spill_temps (void)\n {\n   struct dlist *d;\n   bitmap already = BITMAP_XMALLOC ();\n@@ -2512,8 +2453,7 @@ detect_spill_temps ()\n /* Returns nonzero if the rtx MEM refers somehow to a stack location.  */\n \n int\n-memref_is_stack_slot (mem)\n-     rtx mem;\n+memref_is_stack_slot (rtx mem)\n {\n   rtx ad = XEXP (mem, 0);\n   rtx x;\n@@ -2530,8 +2470,7 @@ memref_is_stack_slot (mem)\n /* Returns nonzero, if rtx X somewhere contains any pseudo register.  */\n \n static int\n-contains_pseudo (x)\n-     rtx x;\n+contains_pseudo (rtx x)\n {\n   const char *fmt;\n   int i;\n@@ -2569,8 +2508,7 @@ contains_pseudo (x)\n \n static GTY(()) rtx remat_test_insn;\n static int\n-want_to_remat (x)\n-     rtx x;\n+want_to_remat (rtx x)\n {\n   int num_clobbers = 0;\n   int icode;\n@@ -2608,7 +2546,7 @@ want_to_remat (x)\n    and that value is simple enough, and want_to_remat() holds for it.  */\n \n static void\n-detect_remat_webs ()\n+detect_remat_webs (void)\n {\n   struct dlist *d;\n   for (d = WEBS(INITIAL); d; d = d->next)\n@@ -2675,7 +2613,7 @@ detect_remat_webs ()\n /* Determine the spill costs of all webs.  */\n \n static void\n-determine_web_costs ()\n+determine_web_costs (void)\n {\n   struct dlist *d;\n   for (d = WEBS(INITIAL); d; d = d->next)\n@@ -2732,7 +2670,7 @@ determine_web_costs ()\n    which destroys the CFG.  (Somewhen we want to deal with that XXX)  */\n \n static void\n-detect_webs_set_in_cond_jump ()\n+detect_webs_set_in_cond_jump (void)\n {\n   basic_block bb;\n   FOR_EACH_BB (bb)\n@@ -2755,8 +2693,7 @@ detect_webs_set_in_cond_jump ()\n    though.  */\n \n static void\n-make_webs (df)\n-     struct df *df;\n+make_webs (struct df *df)\n {\n   /* First build all the webs itself.  They are not related with\n      others yet.  */\n@@ -2774,8 +2711,7 @@ make_webs (df)\n /* Distribute moves to the corresponding webs.  */\n \n static void\n-moves_to_webs (df)\n-     struct df *df;\n+moves_to_webs (struct df *df)\n {\n   struct df_link *link;\n   struct move_list *ml;\n@@ -2853,9 +2789,7 @@ moves_to_webs (df)\n    and constrain the allocator too much.  */\n \n static void\n-handle_asm_insn (df, insn)\n-     struct df *df;\n-     rtx insn;\n+handle_asm_insn (struct df *df, rtx insn)\n {\n   const char *constraints[MAX_RECOG_OPERANDS];\n   enum machine_mode operand_mode[MAX_RECOG_OPERANDS];\n@@ -3027,8 +2961,7 @@ handle_asm_insn (df, insn)\n    and conflicts.  */\n \n void\n-build_i_graph (df)\n-     struct df *df;\n+build_i_graph (struct df *df)\n {\n   rtx insn;\n \n@@ -3061,8 +2994,7 @@ build_i_graph (df)\n    defs and uses.  */\n \n void\n-ra_build_realloc (df)\n-     struct df *df;\n+ra_build_realloc (struct df *df)\n {\n   struct web_part *last_web_parts = web_parts;\n   struct web **last_def2web = def2web;\n@@ -3176,7 +3108,7 @@ ra_build_realloc (df)\n /* Free up/clear some memory, only needed for one pass.  */\n \n void\n-ra_build_free ()\n+ra_build_free (void)\n {\n   struct dlist *d;\n   unsigned int i;\n@@ -3236,8 +3168,7 @@ ra_build_free ()\n /* Free all memory for the interference graph structures.  */\n \n void\n-ra_build_free_all (df)\n-     struct df *df;\n+ra_build_free_all (struct df *df)\n {\n   unsigned int i;\n "}, {"sha": "f0d028118d7114ecc5fb7af48b14116e4a171bbb", "filename": "gcc/ra-colorize.c", "status": "modified", "additions": 111, "deletions": 164, "changes": 275, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93bad80ebc1ab5f6ee336002c26244b8eff5202e/gcc%2Fra-colorize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93bad80ebc1ab5f6ee336002c26244b8eff5202e/gcc%2Fra-colorize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fra-colorize.c?ref=93bad80ebc1ab5f6ee336002c26244b8eff5202e", "patch": "@@ -47,64 +47,62 @@\n    Additionally there is a custom step to locally improve the overall\n    spill cost of the colored graph (recolor_spills).  */\n \n-static void push_list PARAMS ((struct dlist *, struct dlist **));\n-static void push_list_end PARAMS ((struct dlist *, struct dlist **));\n-static void free_dlist PARAMS ((struct dlist **));\n-static void put_web_at_end PARAMS ((struct web *, enum node_type));\n-static void put_move PARAMS ((struct move *, enum move_type));\n-static void build_worklists PARAMS ((struct df *));\n-static void enable_move PARAMS ((struct web *));\n-static void decrement_degree PARAMS ((struct web *, int));\n-static void simplify PARAMS ((void));\n-static void remove_move_1 PARAMS ((struct web *, struct move *));\n-static void remove_move PARAMS ((struct web *, struct move *));\n-static void add_worklist PARAMS ((struct web *));\n-static int ok PARAMS ((struct web *, struct web *));\n-static int conservative PARAMS ((struct web *, struct web *));\n-static inline unsigned int simplify_p PARAMS ((enum node_type));\n-static void combine PARAMS ((struct web *, struct web *));\n-static void coalesce PARAMS ((void));\n-static void freeze_moves PARAMS ((struct web *));\n-static void freeze PARAMS ((void));\n-static void select_spill PARAMS ((void));\n-static int color_usable_p PARAMS ((int, HARD_REG_SET, HARD_REG_SET,\n-\t\t\t\t   enum machine_mode));\n-int get_free_reg PARAMS ((HARD_REG_SET, HARD_REG_SET, enum machine_mode));\n-static int get_biased_reg PARAMS ((HARD_REG_SET, HARD_REG_SET, HARD_REG_SET,\n-\t\t\t\t   HARD_REG_SET, enum machine_mode));\n-static int count_long_blocks PARAMS ((HARD_REG_SET, int));\n-static char * hardregset_to_string PARAMS ((HARD_REG_SET));\n-static void calculate_dont_begin PARAMS ((struct web *, HARD_REG_SET *));\n-static void colorize_one_web PARAMS ((struct web *, int));\n-static void assign_colors PARAMS ((void));\n-static void try_recolor_web PARAMS ((struct web *));\n-static void insert_coalesced_conflicts PARAMS ((void));\n-static int comp_webs_maxcost PARAMS ((const void *, const void *));\n-static void recolor_spills PARAMS ((void));\n-static void check_colors PARAMS ((void));\n-static void restore_conflicts_from_coalesce PARAMS ((struct web *));\n-static void break_coalesced_spills PARAMS ((void));\n-static void unalias_web PARAMS ((struct web *));\n-static void break_aliases_to_web PARAMS ((struct web *));\n-static void break_precolored_alias PARAMS ((struct web *));\n-static void init_web_pairs PARAMS ((void));\n-static void add_web_pair_cost PARAMS ((struct web *, struct web *,\n-\t\t\t               unsigned HOST_WIDE_INT, unsigned int));\n-static int comp_web_pairs PARAMS ((const void *, const void *));\n-static void sort_and_combine_web_pairs PARAMS ((int));\n-static void aggressive_coalesce PARAMS ((void));\n-static void extended_coalesce_2 PARAMS ((void));\n-static void check_uncoalesced_moves PARAMS ((void));\n+static void push_list (struct dlist *, struct dlist **);\n+static void push_list_end (struct dlist *, struct dlist **);\n+static void free_dlist (struct dlist **);\n+static void put_web_at_end (struct web *, enum node_type);\n+static void put_move (struct move *, enum move_type);\n+static void build_worklists (struct df *);\n+static void enable_move (struct web *);\n+static void decrement_degree (struct web *, int);\n+static void simplify (void);\n+static void remove_move_1 (struct web *, struct move *);\n+static void remove_move (struct web *, struct move *);\n+static void add_worklist (struct web *);\n+static int ok (struct web *, struct web *);\n+static int conservative (struct web *, struct web *);\n+static inline unsigned int simplify_p (enum node_type);\n+static void combine (struct web *, struct web *);\n+static void coalesce (void);\n+static void freeze_moves (struct web *);\n+static void freeze (void);\n+static void select_spill (void);\n+static int color_usable_p (int, HARD_REG_SET, HARD_REG_SET,\n+\t\t\t   enum machine_mode);\n+int get_free_reg (HARD_REG_SET, HARD_REG_SET, enum machine_mode);\n+static int get_biased_reg (HARD_REG_SET, HARD_REG_SET, HARD_REG_SET,\n+\t\t\t   HARD_REG_SET, enum machine_mode);\n+static int count_long_blocks (HARD_REG_SET, int);\n+static char * hardregset_to_string (HARD_REG_SET);\n+static void calculate_dont_begin (struct web *, HARD_REG_SET *);\n+static void colorize_one_web (struct web *, int);\n+static void assign_colors (void);\n+static void try_recolor_web (struct web *);\n+static void insert_coalesced_conflicts (void);\n+static int comp_webs_maxcost (const void *, const void *);\n+static void recolor_spills (void);\n+static void check_colors (void);\n+static void restore_conflicts_from_coalesce (struct web *);\n+static void break_coalesced_spills (void);\n+static void unalias_web (struct web *);\n+static void break_aliases_to_web (struct web *);\n+static void break_precolored_alias (struct web *);\n+static void init_web_pairs (void);\n+static void add_web_pair_cost (struct web *, struct web *,\n+\t\t               unsigned HOST_WIDE_INT, unsigned int);\n+static int comp_web_pairs (const void *, const void *);\n+static void sort_and_combine_web_pairs (int);\n+static void aggressive_coalesce (void);\n+static void extended_coalesce_2 (void);\n+static void check_uncoalesced_moves (void);\n \n static struct dlist *mv_worklist, *mv_coalesced, *mv_constrained;\n static struct dlist *mv_frozen, *mv_active;\n \n /* Push a node onto the front of the list.  */\n \n static void\n-push_list (x, list)\n-     struct dlist *x;\n-     struct dlist **list;\n+push_list (struct dlist *x, struct dlist **list)\n {\n   if (x->next || x->prev)\n     abort ();\n@@ -115,9 +113,7 @@ push_list (x, list)\n }\n \n static void\n-push_list_end (x, list)\n-     struct dlist *x;\n-     struct dlist **list;\n+push_list_end (struct dlist *x, struct dlist **list)\n {\n   if (x->prev || x->next)\n     abort ();\n@@ -135,9 +131,7 @@ push_list_end (x, list)\n /* Remove a node from the list.  */\n \n void\n-remove_list (x, list)\n-     struct dlist *x;\n-     struct dlist **list;\n+remove_list (struct dlist *x, struct dlist **list)\n {\n   struct dlist *y = x->prev;\n   if (y)\n@@ -153,8 +147,7 @@ remove_list (x, list)\n /* Pop the front of the list.  */\n \n struct dlist *\n-pop_list (list)\n-     struct dlist **list;\n+pop_list (struct dlist **list)\n {\n   struct dlist *r = *list;\n   if (r)\n@@ -165,8 +158,7 @@ pop_list (list)\n /* Free the given double linked list.  */\n \n static void\n-free_dlist (list)\n-     struct dlist **list;\n+free_dlist (struct dlist **list)\n {\n   *list = NULL;\n }\n@@ -176,9 +168,7 @@ free_dlist (list)\n    Inline, because it's called with constant TYPE every time.  */\n \n inline void\n-put_web (web, type)\n-     struct web *web;\n-     enum node_type type;\n+put_web (struct web *web, enum node_type type)\n {\n   switch (type)\n     {\n@@ -216,7 +206,7 @@ put_web (web, type)\n    they are coalesced to.  */\n \n void\n-reset_lists ()\n+reset_lists (void)\n {\n   struct dlist *d;\n   unsigned int i;\n@@ -270,9 +260,7 @@ reset_lists ()\n    list.  Additionally TYPE may not be SIMPLIFY.  */\n \n static void\n-put_web_at_end (web, type)\n-     struct web *web;\n-     enum node_type type;\n+put_web_at_end (struct web *web, enum node_type type)\n {\n   if (type == PRECOLORED)\n     type = INITIAL;\n@@ -286,8 +274,7 @@ put_web_at_end (web, type)\n    its current type).  */\n \n void\n-remove_web_from_list (web)\n-     struct web *web;\n+remove_web_from_list (struct web *web)\n {\n   if (web->type == PRECOLORED)\n     remove_list (web->dlink, &WEBS(INITIAL));\n@@ -298,9 +285,7 @@ remove_web_from_list (web)\n /* Give MOVE the TYPE, and link it into the correct list.  */\n \n static inline void\n-put_move (move, type)\n-     struct move *move;\n-     enum move_type type;\n+put_move (struct move *move, enum move_type type)\n {\n   switch (type)\n     {\n@@ -328,8 +313,7 @@ put_move (move, type)\n /* Build the worklists we are going to process.  */\n \n static void\n-build_worklists (df)\n-     struct df *df ATTRIBUTE_UNUSED;\n+build_worklists (struct df *df ATTRIBUTE_UNUSED)\n {\n   struct dlist *d, *d_next;\n   struct move_list *ml;\n@@ -407,8 +391,7 @@ build_worklists (df)\n /* Enable the active moves, in which WEB takes part, to be processed.  */\n \n static void\n-enable_move (web)\n-     struct web *web;\n+enable_move (struct web *web)\n {\n   struct move_list *ml;\n   for (ml = web->moves; ml; ml = ml->next)\n@@ -424,9 +407,7 @@ enable_move (web)\n    now smaller than its freedom.  */\n \n static void\n-decrement_degree (web, dec)\n-     struct web *web;\n-     int dec;\n+decrement_degree (struct web *web, int dec)\n {\n   int before = web->num_conflicts;\n   web->num_conflicts -= dec;\n@@ -454,7 +435,7 @@ decrement_degree (web, dec)\n /* Repeatedly simplify the nodes on the simplify worklists.  */\n \n static void\n-simplify ()\n+simplify (void)\n {\n   struct dlist *d;\n   struct web *web;\n@@ -493,9 +474,7 @@ simplify ()\n /* Helper function to remove a move from the movelist of the web.  */\n \n static void\n-remove_move_1 (web, move)\n-     struct web *web;\n-     struct move *move;\n+remove_move_1 (struct web *web, struct move *move)\n {\n   struct move_list *ml = web->moves;\n   if (!ml)\n@@ -516,9 +495,7 @@ remove_move_1 (web, move)\n    not in the list anymore.  */\n \n static void\n-remove_move (web, move)\n-     struct web *web;\n-     struct move *move;\n+remove_move (struct web *web, struct move *move)\n {\n   struct move_list *ml;\n   remove_move_1 (web, move);\n@@ -530,8 +507,7 @@ remove_move (web, move)\n /* Merge the moves for the two webs into the first web's movelist.  */\n \n void\n-merge_moves (u, v)\n-     struct web *u, *v;\n+merge_moves (struct web *u, struct web *v)\n {\n   regset seen;\n   struct move_list *ml, *ml_next;\n@@ -555,8 +531,7 @@ merge_moves (u, v)\n /* Add a web to the simplify worklist, from the freeze worklist.  */\n \n static void\n-add_worklist (web)\n-     struct web *web;\n+add_worklist (struct web *web)\n {\n   if (web->type != PRECOLORED && !web->moves\n       && web->num_conflicts < NUM_REGS (web))\n@@ -569,8 +544,7 @@ add_worklist (web)\n /* Precolored node coalescing heuristic.  */\n \n static int\n-ok (target, source)\n-     struct web *target, *source;\n+ok (struct web *target, struct web *source)\n {\n   struct conflict_link *wl;\n   int i;\n@@ -661,8 +635,7 @@ ok (target, source)\n /* Non-precolored node coalescing heuristic.  */\n \n static int\n-conservative (target, source)\n-     struct web *target, *source;\n+conservative (struct web *target, struct web *source)\n {\n   unsigned int k;\n   unsigned int loop;\n@@ -699,8 +672,7 @@ conservative (target, source)\n    was passed in.  */\n \n struct web *\n-alias (web)\n-     struct web *web;\n+alias (struct web *web)\n {\n   while (web->type == COALESCED)\n     web = web->alias;\n@@ -711,17 +683,15 @@ alias (web)\n    SIMPLIFY types.  */\n \n static inline unsigned int\n-simplify_p (type)\n-     enum node_type type;\n+simplify_p (enum node_type type)\n {\n   return type == SIMPLIFY || type == SIMPLIFY_SPILL || type == SIMPLIFY_FAT;\n }\n \n /* Actually combine two webs, that can be coalesced.  */\n \n static void\n-combine (u, v)\n-     struct web *u, *v;\n+combine (struct web *u, struct web *v)\n {\n   int i;\n   struct conflict_link *wl;\n@@ -850,7 +820,7 @@ combine (u, v)\n    This is used only for iterated coalescing.  */\n \n static void\n-coalesce ()\n+coalesce (void)\n {\n   struct dlist *d = pop_list (&mv_worklist);\n   struct move *m = DLIST_MOVE (d);\n@@ -896,8 +866,7 @@ coalesce ()\n /* Freeze the moves associated with the web.  Used for iterated coalescing.  */\n \n static void\n-freeze_moves (web)\n-     struct web *web;\n+freeze_moves (struct web *web)\n {\n   struct move_list *ml, *ml_next;\n   for (ml = web->moves; ml; ml = ml_next)\n@@ -928,7 +897,7 @@ freeze_moves (web)\n    coalescing).  */\n \n static void\n-freeze ()\n+freeze (void)\n {\n   struct dlist *d = pop_list (&WEBS(FREEZE));\n   put_web (DLIST_WEB (d), SIMPLIFY);\n@@ -938,17 +907,16 @@ freeze ()\n /* The current spill heuristic.  Returns a number for a WEB.\n    Webs with higher numbers are selected later.  */\n \n-static unsigned HOST_WIDE_INT (*spill_heuristic) PARAMS ((struct web *));\n+static unsigned HOST_WIDE_INT (*spill_heuristic) (struct web *);\n \n-static unsigned HOST_WIDE_INT default_spill_heuristic PARAMS ((struct web *));\n+static unsigned HOST_WIDE_INT default_spill_heuristic (struct web *);\n \n /* Our default heuristic is similar to spill_cost / num_conflicts.\n    Just scaled for integer arithmetic, and it favors coalesced webs,\n    and webs which span more insns with deaths.  */\n \n static unsigned HOST_WIDE_INT\n-default_spill_heuristic (web)\n-     struct web *web;\n+default_spill_heuristic (struct web *web)\n {\n   unsigned HOST_WIDE_INT ret;\n   unsigned int divisor = 1;\n@@ -970,7 +938,7 @@ default_spill_heuristic (web)\n    *actually* spill until we need to).  */\n \n static void\n-select_spill ()\n+select_spill (void)\n {\n   unsigned HOST_WIDE_INT best = (unsigned HOST_WIDE_INT) -1;\n   struct dlist *bestd = NULL;\n@@ -1016,10 +984,8 @@ select_spill ()\n    free colors, and MODE, returns nonzero of color C is still usable.  */\n \n static int\n-color_usable_p (c, dont_begin_colors, free_colors, mode)\n-     int c;\n-     HARD_REG_SET dont_begin_colors, free_colors;\n-     enum machine_mode mode;\n+color_usable_p (int c, HARD_REG_SET dont_begin_colors,\n+\t\tHARD_REG_SET free_colors, enum machine_mode  mode)\n {\n   if (!TEST_HARD_REG_BIT (dont_begin_colors, c)\n       && TEST_HARD_REG_BIT (free_colors, c)\n@@ -1048,9 +1014,8 @@ color_usable_p (c, dont_begin_colors, free_colors, mode)\n    block could be found.  */\n \n int\n-get_free_reg (dont_begin_colors, free_colors, mode)\n-     HARD_REG_SET dont_begin_colors, free_colors;\n-     enum machine_mode mode;\n+get_free_reg (HARD_REG_SET dont_begin_colors, HARD_REG_SET free_colors,\n+\t      enum machine_mode mode)\n {\n   int c;\n   int last_resort_reg = -1;\n@@ -1099,9 +1064,9 @@ get_free_reg (dont_begin_colors, free_colors, mode)\n    only do the last two steps.  */\n \n static int\n-get_biased_reg (dont_begin_colors, bias, prefer_colors, free_colors, mode)\n-     HARD_REG_SET dont_begin_colors, bias, prefer_colors, free_colors;\n-     enum machine_mode mode;\n+get_biased_reg (HARD_REG_SET dont_begin_colors, HARD_REG_SET bias,\n+\t\tHARD_REG_SET prefer_colors, HARD_REG_SET free_colors,\n+\t\tenum machine_mode mode)\n {\n   int c = -1;\n   HARD_REG_SET s;\n@@ -1132,9 +1097,7 @@ get_biased_reg (dont_begin_colors, bias, prefer_colors, free_colors, mode)\n    in FREE_COLORS.  */\n \n static int\n-count_long_blocks (free_colors, len)\n-     HARD_REG_SET free_colors;\n-     int len;\n+count_long_blocks (HARD_REG_SET free_colors, int len)\n {\n   int i, j;\n   int count = 0;\n@@ -1158,8 +1121,7 @@ count_long_blocks (free_colors, len)\n    of hardreg sets.  Note that this string is statically allocated.  */\n \n static char *\n-hardregset_to_string (s)\n-     HARD_REG_SET s;\n+hardregset_to_string (HARD_REG_SET s)\n {\n   static char string[/*FIRST_PSEUDO_REGISTER + 30*/1024];\n #if FIRST_PSEUDO_REGISTER <= HOST_BITS_PER_WIDE_INT\n@@ -1190,9 +1152,7 @@ hardregset_to_string (s)\n    3 can't be used as begin color.  */\n \n static void\n-calculate_dont_begin (web, result)\n-     struct web *web;\n-     HARD_REG_SET *result;\n+calculate_dont_begin (struct web *web, HARD_REG_SET *result)\n {\n   struct conflict_link *wl;\n   HARD_REG_SET dont_begin;\n@@ -1279,9 +1239,7 @@ calculate_dont_begin (web, result)\n    register starved machines, so we try to avoid this.  */\n \n static void\n-colorize_one_web (web, hard)\n-     struct web *web;\n-     int hard;\n+colorize_one_web (struct web *web, int hard)\n {\n   struct conflict_link *wl;\n   HARD_REG_SET colors, dont_begin;\n@@ -1664,7 +1622,7 @@ colorize_one_web (web, hard)\n    colors of coalesced webs.  */\n \n static void\n-assign_colors ()\n+assign_colors (void)\n {\n   struct dlist *d;\n \n@@ -1693,8 +1651,7 @@ assign_colors ()\n    be aware, that currently this pass is quite slow.  */\n \n static void\n-try_recolor_web (web)\n-     struct web *web;\n+try_recolor_web (struct web *web)\n {\n   struct conflict_link *wl;\n   unsigned HOST_WIDE_INT *cost_neighbors;\n@@ -1895,7 +1852,7 @@ try_recolor_web (web)\n    isn't used anymore, e.g. on a completely colored graph.  */\n \n static void\n-insert_coalesced_conflicts ()\n+insert_coalesced_conflicts (void)\n {\n   struct dlist *d;\n   for (d = WEBS(COALESCED); 0 && d; d = d->next)\n@@ -1949,8 +1906,7 @@ insert_coalesced_conflicts ()\n    largest cost first.  */\n \n static int\n-comp_webs_maxcost (w1, w2)\n-     const void *w1, *w2;\n+comp_webs_maxcost (const void *w1, const void *w2)\n {\n   struct web *web1 = *(struct web **)w1;\n   struct web *web2 = *(struct web **)w2;\n@@ -1966,7 +1922,7 @@ comp_webs_maxcost (w1, w2)\n    how this is done.  This just calls it for each spilled web.  */\n \n static void\n-recolor_spills ()\n+recolor_spills (void)\n {\n   unsigned int i, num;\n   struct web **order2web;\n@@ -2003,7 +1959,7 @@ recolor_spills ()\n    not being in usable regs.  */\n \n static void\n-check_colors ()\n+check_colors (void)\n {\n   unsigned int i;\n   for (i = 0; i < num_webs - num_subwebs; i++)\n@@ -2081,8 +2037,7 @@ check_colors ()\n    back onto SELECT stack.  */\n \n static void\n-unalias_web (web)\n-     struct web *web;\n+unalias_web (struct web *web)\n {\n   web->alias = NULL;\n   web->is_coalesced = 0;\n@@ -2110,8 +2065,7 @@ unalias_web (web)\n    Somewhen we'll change this to be more sane.  */\n \n static void\n-break_aliases_to_web (web)\n-     struct web *web;\n+break_aliases_to_web (struct web *web)\n {\n   struct dlist *d, *d_next;\n   if (web->type != SPILLED)\n@@ -2153,8 +2107,7 @@ break_aliases_to_web (web)\n    from initially coalescing both.  */\n \n static void\n-break_precolored_alias (web)\n-     struct web *web;\n+break_precolored_alias (struct web *web)\n {\n   struct web *pre = web->alias;\n   struct conflict_link *wl;\n@@ -2222,8 +2175,7 @@ break_precolored_alias (web)\n    and break up the coalescing.  */\n \n static void\n-restore_conflicts_from_coalesce (web)\n-     struct web *web;\n+restore_conflicts_from_coalesce (struct web *web)\n {\n   struct conflict_link **pcl;\n   struct conflict_link *wl;\n@@ -2329,7 +2281,7 @@ restore_conflicts_from_coalesce (web)\n    there are any spilled coalesce targets.  */\n \n static void\n-break_coalesced_spills ()\n+break_coalesced_spills (void)\n {\n   int changed = 0;\n   while (1)\n@@ -2397,7 +2349,7 @@ static unsigned int num_web_pairs;\n /* Clear the hash table of web pairs.  */\n \n static void\n-init_web_pairs ()\n+init_web_pairs (void)\n {\n   memset (web_pair_hash, 0, sizeof web_pair_hash);\n   num_web_pairs = 0;\n@@ -2409,10 +2361,8 @@ init_web_pairs ()\n    already in, cumulate the costs and conflict number.  */\n \n static void\n-add_web_pair_cost (web1, web2, cost, conflicts)\n-     struct web *web1, *web2;\n-     unsigned HOST_WIDE_INT cost;\n-     unsigned int conflicts;\n+add_web_pair_cost (struct web *web1, struct web *web2,\n+\t\t   unsigned HOST_WIDE_INT cost, unsigned int conflicts)\n {\n   unsigned int hash;\n   struct web_pair *p;\n@@ -2447,8 +2397,7 @@ add_web_pair_cost (web1, web2, cost, conflicts)\n    when the moves are removed) come first.  */\n \n static int\n-comp_web_pairs (w1, w2)\n-     const void *w1, *w2;\n+comp_web_pairs (const void *w1, const void *w2)\n {\n   struct web_pair *p1 = *(struct web_pair **)w1;\n   struct web_pair *p2 = *(struct web_pair **)w2;\n@@ -2468,8 +2417,7 @@ comp_web_pairs (w1, w2)\n    with the most savings.  */\n \n static void\n-sort_and_combine_web_pairs (for_move)\n-     int for_move;\n+sort_and_combine_web_pairs (int for_move)\n {\n   unsigned int i;\n   struct web_pair **sorted;\n@@ -2520,7 +2468,7 @@ sort_and_combine_web_pairs (for_move)\n    giving the most saving if coalesced.  */\n \n static void\n-aggressive_coalesce ()\n+aggressive_coalesce (void)\n {\n   struct dlist *d;\n   struct move *m;\n@@ -2579,7 +2527,7 @@ aggressive_coalesce ()\n    all insns, and for each insn, through all defs and uses.  */\n \n static void\n-extended_coalesce_2 ()\n+extended_coalesce_2 (void)\n {\n   rtx insn;\n   struct ra_insn_info info;\n@@ -2624,7 +2572,7 @@ extended_coalesce_2 ()\n /* Check if we forgot to coalesce some moves.  */\n \n static void\n-check_uncoalesced_moves ()\n+check_uncoalesced_moves (void)\n {\n   struct move_list *ml;\n   struct move *m;\n@@ -2658,8 +2606,7 @@ check_uncoalesced_moves ()\n    produces a list of spilled, colored and coalesced nodes.  */\n \n void\n-ra_colorize_graph (df)\n-     struct df *df;\n+ra_colorize_graph (struct df *df)\n {\n   if (rtl_dump_file)\n     dump_igraph (df);\n@@ -2704,7 +2651,7 @@ ra_colorize_graph (df)\n \n /* Initialize this module.  */\n \n-void ra_colorize_init ()\n+void ra_colorize_init (void)\n {\n   /* FIXME: Choose spill heuristic for platform if we have one */\n   spill_heuristic = default_spill_heuristic;\n@@ -2714,7 +2661,7 @@ void ra_colorize_init ()\n    memory).  */\n \n void\n-ra_colorize_free_all ()\n+ra_colorize_free_all (void)\n {\n   struct dlist *d;\n   while ((d = pop_list (&WEBS(FREE))) != NULL)"}, {"sha": "acddbe128cd71b87319cf24b4b9472007ea9644e", "filename": "gcc/ra-debug.c", "status": "modified", "additions": 25, "deletions": 57, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93bad80ebc1ab5f6ee336002c26244b8eff5202e/gcc%2Fra-debug.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93bad80ebc1ab5f6ee336002c26244b8eff5202e/gcc%2Fra-debug.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fra-debug.c?ref=93bad80ebc1ab5f6ee336002c26244b8eff5202e", "patch": "@@ -36,10 +36,10 @@\n /* This file contains various dumping and debug functions for\n    the graph coloring register allocator.  */\n \n-static void ra_print_rtx_1op PARAMS ((FILE *, rtx));\n-static void ra_print_rtx_2op PARAMS ((FILE *, rtx));\n-static void ra_print_rtx_3op PARAMS ((FILE *, rtx));\n-static void ra_print_rtx_object PARAMS ((FILE *, rtx));\n+static void ra_print_rtx_1op (FILE *, rtx);\n+static void ra_print_rtx_2op (FILE *, rtx);\n+static void ra_print_rtx_3op (FILE *, rtx);\n+static void ra_print_rtx_object (FILE *, rtx);\n \n /* The hardregs as names, for debugging.  */\n static const char *const reg_class_names[] = REG_CLASS_NAMES;\n@@ -70,9 +70,7 @@ ra_debug_msg (unsigned int level, const char *format, ...)\n    \"op(Y)\" to FILE.  */\n \n static void\n-ra_print_rtx_1op (file, x)\n-     FILE *file;\n-     rtx x;\n+ra_print_rtx_1op (FILE *file, rtx x)\n {\n   enum rtx_code code = GET_CODE (x);\n   rtx op0 = XEXP (x, 0);\n@@ -106,9 +104,7 @@ ra_print_rtx_1op (file, x)\n    to FILE.  */\n \n static void\n-ra_print_rtx_2op (file, x)\n-     FILE *file;\n-     rtx x;\n+ra_print_rtx_2op (FILE *file, rtx x)\n {\n   int infix = 1;\n   const char *opname = \"shitop\";\n@@ -171,9 +167,7 @@ ra_print_rtx_2op (file, x)\n    I.e. X is either an IF_THEN_ELSE, or a bitmap operation.  */\n \n static void\n-ra_print_rtx_3op (file, x)\n-     FILE *file;\n-     rtx x;\n+ra_print_rtx_3op (FILE *file, rtx x)\n {\n   enum rtx_code code = GET_CODE (x);\n   rtx op0 = XEXP (x, 0);\n@@ -208,9 +202,7 @@ ra_print_rtx_3op (file, x)\n    is a hardreg, whose name is NULL, or empty.  */\n \n static void\n-ra_print_rtx_object (file, x)\n-     FILE *file;\n-     rtx x;\n+ra_print_rtx_object (FILE *file, rtx x)\n {\n   enum rtx_code code = GET_CODE (x);\n   enum machine_mode mode = GET_MODE (x);\n@@ -344,10 +336,7 @@ ra_print_rtx_object (file, x)\n    the preceding and following insn.  */\n \n void\n-ra_print_rtx (file, x, with_pn)\n-     FILE *file;\n-     rtx x;\n-     int with_pn;\n+ra_print_rtx (FILE *file, rtx x, int with_pn)\n {\n   enum rtx_code code;\n   char class;\n@@ -517,10 +506,7 @@ ra_print_rtx (file, x, with_pn)\n /* This only calls ra_print_rtx(), but emits a final newline.  */\n \n void\n-ra_print_rtx_top (file, x, with_pn)\n-     FILE *file;\n-     rtx x;\n-     int with_pn;\n+ra_print_rtx_top (FILE *file, rtx x, int with_pn)\n {\n   ra_print_rtx (file, x, with_pn);\n   fprintf (file, \"\\n\");\n@@ -529,8 +515,7 @@ ra_print_rtx_top (file, x, with_pn)\n /* Callable from gdb.  This prints rtx X onto stderr.  */\n \n void\n-ra_debug_rtx (x)\n-     rtx x;\n+ra_debug_rtx (rtx x)\n {\n   ra_print_rtx_top (stderr, x, 1);\n }\n@@ -539,8 +524,7 @@ ra_debug_rtx (x)\n    The first and last insn are emitted with UIDs of prev and next insns.  */\n \n void\n-ra_debug_bbi (bbi)\n-     int bbi;\n+ra_debug_bbi (int bbi)\n {\n   basic_block bb = BASIC_BLOCK (bbi);\n   rtx insn;\n@@ -557,9 +541,7 @@ ra_debug_bbi (bbi)\n    or emit a window of NUM insns around INSN, to stderr.  */\n \n void\n-ra_debug_insns (insn, num)\n-     rtx insn;\n-     int num;\n+ra_debug_insns (rtx insn, int num)\n {\n   int i, count = (num == 0 ? 1 : num < 0 ? -num : num);\n   if (num < 0)\n@@ -578,9 +560,7 @@ ra_debug_insns (insn, num)\n    some notes, if flag_ra_dump_notes is zero.  */\n \n void\n-ra_print_rtl_with_bb (file, insn)\n-     FILE *file;\n-     rtx insn;\n+ra_print_rtl_with_bb (FILE *file, rtx insn)\n {\n   basic_block last_bb, bb;\n   unsigned int num = 0;\n@@ -628,7 +608,7 @@ ra_print_rtl_with_bb (file, insn)\n    graph, and prints the findings.  */\n \n void\n-dump_number_seen ()\n+dump_number_seen (void)\n {\n #define N 17\n   int num[N];\n@@ -654,8 +634,7 @@ dump_number_seen ()\n /* Dump the interference graph, the move list and the webs.  */\n \n void\n-dump_igraph (df)\n-     struct df *df ATTRIBUTE_UNUSED;\n+dump_igraph (struct df *df ATTRIBUTE_UNUSED)\n {\n   struct move_list *ml;\n   unsigned int def1, def2;\n@@ -741,7 +720,7 @@ dump_igraph (df)\n    to my custom graph colorizer.  */\n \n void\n-dump_igraph_machine ()\n+dump_igraph_machine (void)\n {\n   unsigned int i;\n \n@@ -801,7 +780,7 @@ dump_igraph_machine ()\n    and emits information, if the resulting insns are strictly valid.  */\n \n void\n-dump_constraints ()\n+dump_constraints (void)\n {\n   rtx insn;\n   int i;\n@@ -854,9 +833,7 @@ dump_constraints ()\n    preceded by a custom message MSG, with debug level LEVEL.  */\n \n void\n-dump_graph_cost (level, msg)\n-     unsigned int level;\n-     const char *msg;\n+dump_graph_cost (unsigned int level, const char *msg)\n {\n   unsigned int i;\n   unsigned HOST_WIDE_INT cost;\n@@ -878,8 +855,7 @@ dump_graph_cost (level, msg)\n /* Dump the color assignment per web, the coalesced and spilled webs.  */\n \n void\n-dump_ra (df)\n-     struct df *df ATTRIBUTE_UNUSED;\n+dump_ra (struct df *df ATTRIBUTE_UNUSED)\n {\n   struct web *web;\n   struct dlist *d;\n@@ -913,10 +889,7 @@ dump_ra (df)\n    (loads, stores and copies).  */\n \n void\n-dump_static_insn_cost (file, message, prefix)\n-     FILE *file;\n-     const char *message;\n-     const char *prefix;\n+dump_static_insn_cost (FILE *file, const char *message, const char *prefix)\n {\n   struct cost\n     {\n@@ -1001,9 +974,7 @@ dump_static_insn_cost (file, message, prefix)\n    hardregs in common.  */\n \n int\n-web_conflicts_p (web1, web2)\n-     struct web *web1;\n-     struct web *web2;\n+web_conflicts_p (struct web *web1, struct web *web2)\n {\n   if (web1->type == PRECOLORED && web2->type == PRECOLORED)\n     return 0;\n@@ -1020,8 +991,7 @@ web_conflicts_p (web1, web2)\n /* Dump all uids of insns in which WEB is mentioned.  */\n \n void\n-dump_web_insns (web)\n-     struct web *web;\n+dump_web_insns (struct web *web)\n {\n   unsigned int i;\n \n@@ -1047,8 +1017,7 @@ dump_web_insns (web)\n /* Dump conflicts for web WEB.  */\n \n void\n-dump_web_conflicts (web)\n-     struct web *web;\n+dump_web_conflicts (struct web *web)\n {\n   int num = 0;\n   unsigned int def2;\n@@ -1099,8 +1068,7 @@ dump_web_conflicts (web)\n /* Output HARD_REG_SET to stderr.  */\n \n void\n-debug_hard_reg_set (set)\n-     HARD_REG_SET set;\n+debug_hard_reg_set (HARD_REG_SET set)\n {\n   int i;\n   for (i = 0; i < FIRST_PSEUDO_REGISTER; ++i)"}, {"sha": "14360d894a08d49685d00143ca03d2cea773db56", "filename": "gcc/ra-rewrite.c", "status": "modified", "additions": 58, "deletions": 94, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93bad80ebc1ab5f6ee336002c26244b8eff5202e/gcc%2Fra-rewrite.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93bad80ebc1ab5f6ee336002c26244b8eff5202e/gcc%2Fra-rewrite.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fra-rewrite.c?ref=93bad80ebc1ab5f6ee336002c26244b8eff5202e", "patch": "@@ -44,33 +44,32 @@\n struct rewrite_info;\n struct rtx_list;\n \n-static void spill_coalescing PARAMS ((sbitmap, sbitmap));\n-static unsigned HOST_WIDE_INT spill_prop_savings PARAMS ((struct web *,\n-\t\t\t\t\t\t\t  sbitmap));\n-static void spill_prop_insert PARAMS ((struct web *, sbitmap, sbitmap));\n-static int spill_propagation PARAMS ((sbitmap, sbitmap, sbitmap));\n-static void spill_coalprop PARAMS ((void));\n-static void allocate_spill_web PARAMS ((struct web *));\n-static void choose_spill_colors PARAMS ((void));\n-static void rewrite_program PARAMS ((bitmap));\n-static void remember_slot PARAMS ((struct rtx_list **, rtx));\n-static int slots_overlap_p PARAMS ((rtx, rtx));\n-static void delete_overlapping_slots PARAMS ((struct rtx_list **, rtx));\n-static int slot_member_p PARAMS ((struct rtx_list *, rtx));\n-static void insert_stores PARAMS ((bitmap));\n-static int spill_same_color_p PARAMS ((struct web *, struct web *));\n-static bool is_partly_live_1 PARAMS ((sbitmap, struct web *));\n-static void update_spill_colors PARAMS ((HARD_REG_SET *, struct web *, int));\n-static int spill_is_free PARAMS ((HARD_REG_SET *, struct web *));\n-static void emit_loads PARAMS ((struct rewrite_info *, int, rtx));\n-static void reloads_to_loads PARAMS ((struct rewrite_info *, struct ref **,\n-\t\t\t\t      unsigned int, struct web **));\n-static void rewrite_program2 PARAMS ((bitmap));\n-static void mark_refs_for_checking PARAMS ((struct web *, bitmap));\n-static void detect_web_parts_to_rebuild PARAMS ((void));\n-static void delete_useless_defs PARAMS ((void));\n-static void detect_non_changed_webs PARAMS ((void));\n-static void reset_changed_flag PARAMS ((void));\n+static void spill_coalescing (sbitmap, sbitmap);\n+static unsigned HOST_WIDE_INT spill_prop_savings (struct web *, sbitmap);\n+static void spill_prop_insert (struct web *, sbitmap, sbitmap);\n+static int spill_propagation (sbitmap, sbitmap, sbitmap);\n+static void spill_coalprop (void);\n+static void allocate_spill_web (struct web *);\n+static void choose_spill_colors (void);\n+static void rewrite_program (bitmap);\n+static void remember_slot (struct rtx_list **, rtx);\n+static int slots_overlap_p (rtx, rtx);\n+static void delete_overlapping_slots (struct rtx_list **, rtx);\n+static int slot_member_p (struct rtx_list *, rtx);\n+static void insert_stores (bitmap);\n+static int spill_same_color_p (struct web *, struct web *);\n+static bool is_partly_live_1 (sbitmap, struct web *);\n+static void update_spill_colors (HARD_REG_SET *, struct web *, int);\n+static int spill_is_free (HARD_REG_SET *, struct web *);\n+static void emit_loads (struct rewrite_info *, int, rtx);\n+static void reloads_to_loads (struct rewrite_info *, struct ref **,\n+\t\t\t      unsigned int, struct web **);\n+static void rewrite_program2 (bitmap);\n+static void mark_refs_for_checking (struct web *, bitmap);\n+static void detect_web_parts_to_rebuild (void);\n+static void delete_useless_defs (void);\n+static void detect_non_changed_webs (void);\n+static void reset_changed_flag (void);\n \n /* For tracking some statistics, we count the number (and cost)\n    of deleted move insns.  */\n@@ -84,8 +83,7 @@ static unsigned HOST_WIDE_INT deleted_move_cost;\n    reduces memory shuffling.  */\n \n static void\n-spill_coalescing (coalesce, spilled)\n-     sbitmap coalesce, spilled;\n+spill_coalescing (sbitmap coalesce, sbitmap spilled)\n {\n   struct move_list *ml;\n   struct move *m;\n@@ -160,9 +158,7 @@ spill_coalescing (coalesce, spilled)\n    SPILLED, in terms of removed move insn cost.  */\n \n static unsigned HOST_WIDE_INT\n-spill_prop_savings (web, spilled)\n-     struct web *web;\n-     sbitmap spilled;\n+spill_prop_savings (struct web *web, sbitmap spilled)\n {\n   unsigned HOST_WIDE_INT savings = 0;\n   struct move_list *ml;\n@@ -196,9 +192,7 @@ spill_prop_savings (web, spilled)\n    to LIST and PROCESSED.  */\n \n static void\n-spill_prop_insert (web, list, processed)\n-     struct web *web;\n-     sbitmap list, processed;\n+spill_prop_insert (struct web *web, sbitmap list, sbitmap processed)\n {\n   struct move_list *ml;\n   struct move *m;\n@@ -232,8 +226,7 @@ spill_prop_insert (web, list, processed)\n    of all webs processed so far, so we don't do work twice.  */\n \n static int\n-spill_propagation (to_prop, spilled, processed)\n-     sbitmap to_prop, spilled, processed;\n+spill_propagation (sbitmap to_prop, sbitmap spilled, sbitmap processed)\n {\n   int id;\n   int again = 0;\n@@ -275,7 +268,7 @@ spill_propagation (to_prop, spilled, processed)\n    spill coalescing and spill propagation, until nothing changes.  */\n \n static void\n-spill_coalprop ()\n+spill_coalprop (void)\n {\n   sbitmap spilled, processed, to_prop;\n   struct dlist *d;\n@@ -311,8 +304,7 @@ spill_coalprop ()\n    MEM references.  */\n \n static void\n-allocate_spill_web (web)\n-     struct web *web;\n+allocate_spill_web (struct web *web)\n {\n   int regno = web->regno;\n   rtx slot;\n@@ -326,7 +318,7 @@ allocate_spill_web (web)\n    spilling.  The heuristic isn't good in any way.  */\n \n static void\n-choose_spill_colors ()\n+choose_spill_colors (void)\n {\n   struct dlist *d;\n   unsigned HOST_WIDE_INT *costs = xmalloc (FIRST_PSEUDO_REGISTER * sizeof (costs[0]));\n@@ -397,8 +389,7 @@ static bitmap useless_defs;\n    deaths.  */\n \n static void\n-rewrite_program (new_deaths)\n-     bitmap new_deaths;\n+rewrite_program (bitmap new_deaths)\n {\n   unsigned int i;\n   struct dlist *d;\n@@ -538,9 +529,7 @@ struct rtx_list\n /* Adds X to *LIST.  */\n \n static void\n-remember_slot (list, x)\n-     struct rtx_list **list;\n-     rtx x;\n+remember_slot (struct rtx_list **list, rtx x)\n {\n   struct rtx_list *l;\n   /* PRE: X is not already in LIST.  */\n@@ -556,8 +545,7 @@ remember_slot (list, x)\n    (plus (basereg) (const_inst x)), otherwise they overlap.  */\n \n static int\n-slots_overlap_p (s1, s2)\n-     rtx s1, s2;\n+slots_overlap_p (rtx s1, rtx s2)\n {\n   rtx base1, base2;\n   HOST_WIDE_INT ofs1 = 0, ofs2 = 0;\n@@ -607,9 +595,7 @@ slots_overlap_p (s1, s2)\n    of slots_overlap_p().  */\n \n static void\n-delete_overlapping_slots (list, x)\n-     struct rtx_list **list;\n-     rtx x;\n+delete_overlapping_slots (struct rtx_list **list, rtx x)\n {\n   while (*list)\n     {\n@@ -623,9 +609,7 @@ delete_overlapping_slots (list, x)\n /* Returns nonzero, of X is member of LIST.  */\n \n static int\n-slot_member_p (list, x)\n-     struct rtx_list *list;\n-     rtx x;\n+slot_member_p (struct rtx_list *list, rtx x)\n {\n   for (;list; list = list->next)\n     if (rtx_equal_p (list->x, x))\n@@ -640,8 +624,7 @@ slot_member_p (list, x)\n    containing deaths.  */\n \n static void\n-insert_stores (new_deaths)\n-     bitmap new_deaths;\n+insert_stores (bitmap new_deaths)\n {\n   rtx insn;\n   rtx last_slot = NULL_RTX;\n@@ -750,8 +733,7 @@ insert_stores (new_deaths)\n    they are not the same width.  */\n \n static int\n-spill_same_color_p (web1, web2)\n-     struct web *web1, *web2;\n+spill_same_color_p (struct web *web1, struct web *web2)\n {\n   int c1, size1, c2, size2;\n   if ((c1 = alias (web1)->color) < 0 || c1 == an_unusable_color)\n@@ -772,9 +754,7 @@ spill_same_color_p (web1, web2)\n    subwebs (or WEB itself) is live.  */\n \n static bool\n-is_partly_live_1 (live, web)\n-     sbitmap live;\n-     struct web *web;\n+is_partly_live_1 (sbitmap live, struct web *web)\n {\n   do\n     if (TEST_BIT (live, web->id))\n@@ -793,10 +773,7 @@ is_partly_live_1 (live, web)\n    is nonzero), or remove them.  */\n \n static void\n-update_spill_colors (in_use, web, add)\n-     HARD_REG_SET *in_use;\n-     struct web *web;\n-     int add;\n+update_spill_colors (HARD_REG_SET *in_use, struct web *web, int add)\n {\n   int c, size;\n   if ((c = alias (find_web_for_subweb (web))->color) < 0\n@@ -825,9 +802,7 @@ update_spill_colors (in_use, web, add)\n    Generally, if WEB can't be left colorized return 1.  */\n \n static int\n-spill_is_free (in_use, web)\n-     HARD_REG_SET *in_use;\n-     struct web *web;\n+spill_is_free (HARD_REG_SET *in_use, struct web *web)\n {\n   int c, size;\n   if ((c = alias (web)->color) < 0)\n@@ -881,10 +856,7 @@ struct rewrite_info\n    loads.  LAST_BLOCK_INSN is the last insn of the current basic block.  */\n \n static void\n-emit_loads (ri, nl_first_reload, last_block_insn)\n-     struct rewrite_info *ri;\n-     int nl_first_reload;\n-     rtx last_block_insn;\n+emit_loads (struct rewrite_info *ri, int nl_first_reload, rtx last_block_insn)\n {\n   int j;\n   for (j = ri->nl_size; j;)\n@@ -1018,11 +990,8 @@ emit_loads (ri, nl_first_reload, last_block_insn)\n    and whose colors isn't free anymore, on the needed_loads list.  */\n \n static void\n-reloads_to_loads (ri, refs, num_refs, ref2web)\n-     struct rewrite_info *ri;\n-     struct ref **refs;\n-     unsigned int num_refs;\n-     struct web **ref2web;\n+reloads_to_loads (struct rewrite_info *ri, struct ref **refs,\n+\t\t  unsigned int num_refs, struct web **ref2web)\n {\n   unsigned int n;\n   int num_reloads = ri->num_reloads;\n@@ -1081,8 +1050,7 @@ reloads_to_loads (ri, refs, num_refs, ref2web)\n    containing deaths).  */\n \n static void\n-rewrite_program2 (new_deaths)\n-     bitmap new_deaths;\n+rewrite_program2 (bitmap new_deaths)\n {\n   basic_block bb = NULL;\n   int nl_first_reload;\n@@ -1445,9 +1413,7 @@ rewrite_program2 (new_deaths)\n    Also remember all IDs of its uses in USES_AS_BITMAP.  */\n \n static void\n-mark_refs_for_checking (web, uses_as_bitmap)\n-     struct web *web;\n-     bitmap uses_as_bitmap;\n+mark_refs_for_checking (struct web *web, bitmap uses_as_bitmap)\n {\n   unsigned int i;\n   for (i = 0; i < web->num_uses; i++)\n@@ -1473,7 +1439,7 @@ mark_refs_for_checking (web, uses_as_bitmap)\n    information, we will rebuild.  */\n \n static void\n-detect_web_parts_to_rebuild ()\n+detect_web_parts_to_rebuild (void)\n {\n   bitmap uses_as_bitmap;\n   unsigned int i, pass;\n@@ -1585,7 +1551,7 @@ static unsigned HOST_WIDE_INT deleted_def_cost;\n    which wasn't live.  Try to delete all those insns.  */\n \n static void\n-delete_useless_defs ()\n+delete_useless_defs (void)\n {\n   unsigned int i;\n   /* If the insn only sets the def without any sideeffect (besides\n@@ -1613,7 +1579,7 @@ delete_useless_defs ()\n    in this pass).  */\n \n static void\n-detect_non_changed_webs ()\n+detect_non_changed_webs (void)\n {\n   struct dlist *d, *d_next;\n   for (d = WEBS(SPILLED); d; d = d_next)\n@@ -1639,7 +1605,7 @@ detect_non_changed_webs ()\n /* Before spilling we clear the changed flags for all spilled webs.  */\n \n static void\n-reset_changed_flag ()\n+reset_changed_flag (void)\n {\n   struct dlist *d;\n   for (d = WEBS(SPILLED); d; d = d->next)\n@@ -1652,7 +1618,7 @@ reset_changed_flag ()\n    building the interference graph in the next pass.  */\n \n void\n-actual_spill ()\n+actual_spill (void)\n {\n   int i;\n   bitmap new_deaths = BITMAP_XMALLOC ();\n@@ -1840,7 +1806,7 @@ emit_colors (df)\n /* Delete some coalesced moves from the insn stream.  */\n \n void\n-delete_moves ()\n+delete_moves (void)\n {\n   struct move_list *ml;\n   struct web *s, *t;\n@@ -1898,7 +1864,7 @@ delete_moves ()\n    that comes later) Bah.  */\n \n void\n-remove_suspicious_death_notes ()\n+remove_suspicious_death_notes (void)\n {\n   rtx insn;\n   for (insn = get_insns(); insn; insn = NEXT_INSN (insn))\n@@ -1927,8 +1893,7 @@ remove_suspicious_death_notes ()\n    is nonzero, also free ra_reg_renumber and reset ra_max_regno.  */\n \n void\n-setup_renumber (free_it)\n-     int free_it;\n+setup_renumber (int free_it)\n {\n   int i;\n   max_regno = max_reg_num ();\n@@ -1949,8 +1914,7 @@ setup_renumber (free_it)\n    and removed moves or useless defs.  */\n \n void\n-dump_cost (level)\n-     unsigned int level;\n+dump_cost (unsigned int level)\n {\n   ra_debug_msg (level, \"Instructions for spilling\\n added:\\n\");\n   ra_debug_msg (level, \"  loads =%d cost=\" HOST_WIDE_INT_PRINT_UNSIGNED \"\\n\",\n@@ -1969,7 +1933,7 @@ dump_cost (level)\n /* Initialization of the rewrite phase.  */\n \n void\n-ra_rewrite_init ()\n+ra_rewrite_init (void)\n {\n   emitted_spill_loads = 0;\n   emitted_spill_stores = 0;"}, {"sha": "01ce6dc067fc560d43bc49a6e7f3bba9f9e42d0e", "filename": "gcc/ra.c", "status": "modified", "additions": 27, "deletions": 44, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93bad80ebc1ab5f6ee336002c26244b8eff5202e/gcc%2Fra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93bad80ebc1ab5f6ee336002c26244b8eff5202e/gcc%2Fra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fra.c?ref=93bad80ebc1ab5f6ee336002c26244b8eff5202e", "patch": "@@ -1,5 +1,5 @@\n /* Graph coloring register allocator\n-   Copyright (C) 2001, 2002 Free Software Foundation, Inc.\n+   Copyright (C) 2001, 2002, 2003 Free Software Foundation, Inc.\n    Contributed by Michael Matz <matz@suse.de>\n    and Daniel Berlin <dan@cgsoftware.com>.\n \n@@ -85,16 +85,16 @@\n   */\n \n static struct obstack ra_obstack;\n-static void create_insn_info PARAMS ((struct df *));\n-static void free_insn_info PARAMS ((void));\n-static void alloc_mem PARAMS ((struct df *));\n-static void free_mem PARAMS ((struct df *));\n-static void free_all_mem PARAMS ((struct df *df));\n-static int one_pass PARAMS ((struct df *, int));\n-static void check_df PARAMS ((struct df *));\n-static void init_ra PARAMS ((void));\n+static void create_insn_info (struct df *);\n+static void free_insn_info (void);\n+static void alloc_mem (struct df *);\n+static void free_mem (struct df *);\n+static void free_all_mem (struct df *df);\n+static int one_pass (struct df *, int);\n+static void check_df (struct df *);\n+static void init_ra (void);\n \n-void reg_alloc PARAMS ((void));\n+void reg_alloc (void);\n \n /* These global variables are \"internal\" to the register allocator.\n    They are all documented at their declarations in ra.h.  */\n@@ -165,17 +165,15 @@ int flag_ra_dump_notes = 0;\n    is done.  Allocate an object of SIZE bytes.  */\n \n void *\n-ra_alloc (size)\n-     size_t size;\n+ra_alloc (size_t size)\n {\n   return obstack_alloc (&ra_obstack, size);\n }\n \n /* Like ra_alloc(), but clear the returned memory.  */\n \n void *\n-ra_calloc (size)\n-     size_t size;\n+ra_calloc (size_t size)\n {\n   void *p = obstack_alloc (&ra_obstack, size);\n   memset (p, 0, size);\n@@ -185,8 +183,7 @@ ra_calloc (size)\n /* Returns the number of hardregs in HARD_REG_SET RS.  */\n \n int\n-hard_regs_count (rs)\n-     HARD_REG_SET rs;\n+hard_regs_count (HARD_REG_SET rs)\n {\n   int count = 0;\n #ifdef HARD_REG_SET\n@@ -220,8 +217,7 @@ hard_regs_count (rs)\n    be basically valid.  */\n \n rtx\n-ra_emit_move_insn (x, y)\n-     rtx x, y;\n+ra_emit_move_insn (rtx x, rtx y)\n {\n   enum machine_mode mode = GET_MODE (x);\n   if (GET_MODE_CLASS (mode) == MODE_CC)\n@@ -238,8 +234,7 @@ static struct ref **refs_for_insn_df;\n    all valid defs and uses in an insn.  */\n \n static void\n-create_insn_info (df)\n-     struct df *df;\n+create_insn_info (struct df *df)\n {\n   rtx insn;\n   struct ref **act_refs;\n@@ -288,7 +283,7 @@ create_insn_info (df)\n /* Free the insn_df structures.  */\n \n static void\n-free_insn_info ()\n+free_insn_info (void)\n {\n   free (refs_for_insn_df);\n   refs_for_insn_df = NULL;\n@@ -302,9 +297,7 @@ free_insn_info ()\n    represented by WEB.  Returns the matching subweb or NULL.  */\n \n struct web *\n-find_subweb (web, reg)\n-     struct web *web;\n-     rtx reg;\n+find_subweb (struct web *web, rtx reg)\n {\n   struct web *w;\n   if (GET_CODE (reg) != SUBREG)\n@@ -320,9 +313,7 @@ find_subweb (web, reg)\n    a collection of the needed size and offset (in bytes).  */\n \n struct web *\n-find_subweb_2 (web, size_word)\n-     struct web *web;\n-     unsigned int size_word;\n+find_subweb_2 (struct web *web, unsigned int size_word)\n {\n   struct web *w = web;\n   if (size_word == GET_MODE_SIZE (GET_MODE (web->orig_x)))\n@@ -340,8 +331,7 @@ find_subweb_2 (web, size_word)\n /* Returns the superweb for SUBWEB.  */\n \n struct web *\n-find_web_for_subweb_1 (subweb)\n-     struct web *subweb;\n+find_web_for_subweb_1 (struct web *subweb)\n {\n   while (subweb->parent_web)\n     subweb = subweb->parent_web;\n@@ -352,8 +342,7 @@ find_web_for_subweb_1 (subweb)\n    Return 1 if they do.  */\n \n int\n-hard_regs_intersect_p (a, b)\n-     HARD_REG_SET *a, *b;\n+hard_regs_intersect_p (HARD_REG_SET *a, HARD_REG_SET *b)\n {\n   HARD_REG_SET c;\n   COPY_HARD_REG_SET (c, *a);\n@@ -368,8 +357,7 @@ hard_regs_intersect_p (a, b)\n    register allocator.  */\n \n static void\n-alloc_mem (df)\n-     struct df *df;\n+alloc_mem (struct df *df)\n {\n   int i;\n   ra_build_realloc (df);\n@@ -386,8 +374,7 @@ alloc_mem (df)\n /* Free the memory which isn't necessary for the next pass.  */\n \n static void\n-free_mem (df)\n-     struct df *df ATTRIBUTE_UNUSED;\n+free_mem (struct df *df ATTRIBUTE_UNUSED)\n {\n   free_insn_info ();\n   ra_build_free ();\n@@ -397,8 +384,7 @@ free_mem (df)\n    it's done.  */\n \n static void\n-free_all_mem (df)\n-     struct df *df;\n+free_all_mem (struct df *df)\n {\n   unsigned int i;\n   live_at_end -= 2;\n@@ -418,9 +404,7 @@ static long ticks_rebuild;\n    was added, i.e. if the allocator needs to rerun.  */\n \n static int\n-one_pass (df, rebuild)\n-     struct df *df;\n-     int rebuild;\n+one_pass (struct df *df, int rebuild)\n {\n   long ticks = clock ();\n   int something_spilled;\n@@ -461,7 +445,7 @@ one_pass (df, rebuild)\n /* Initialize various arrays for the register allocator.  */\n \n static void\n-init_ra ()\n+init_ra (void)\n {\n   int i;\n   HARD_REG_SET rs;\n@@ -592,8 +576,7 @@ init_ra ()\n    invariances we expect.  */\n \n static void\n-check_df (df)\n-     struct df *df;\n+check_df (struct df *df)\n {\n   struct df_link *link;\n   rtx insn;\n@@ -663,7 +646,7 @@ check_df (df)\n /* Main register allocator entry point.  */\n \n void\n-reg_alloc ()\n+reg_alloc (void)\n {\n   int changed;\n   FILE *ra_dump_file = rtl_dump_file;"}]}