{"sha": "a81ffd93b83c4be250514ff385b5b88fa5c3835b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTgxZmZkOTNiODNjNGJlMjUwNTE0ZmYzODViNWI4OGZhNWMzODM1Yg==", "commit": {"author": {"name": "Jim Wilson", "email": "jimw@sifive.com", "date": "2019-11-05T22:34:40Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "2019-11-05T22:34:40Z"}, "message": "Allow libcalls for complex memcpy when optimizing for size.\n\nThe RISC-V backend wants to use a libcall when optimizing for size if\nmore than 6 instructions are needed.  Emit_move_complex asks for no\nlibcalls.  This case requires 8 insns for rv64 and 16 insns for rv32,\nso we get fallback code that emits a loop.  Commit_one_edge_insertion\ndoesn't allow code inserted for a phi node on an edge to end with a\nbranch, and so this triggers an assertion.  This problem goes away if\nwe allow libcalls when optimizing for size, which gives the code the\nRISC-V backend wants, and avoids triggering the assert.\n\n\tgcc/\n\tPR middle-end/92263\n\t* expr.c (emit_move_complex): Only use BLOCK_OP_NO_LIBCALL when\n\toptimize_insn_for_speed_p is true.\n\n\tgcc/testsuite/\n\tPR middle-end/92263\n\t* gcc.dg/pr92263.c: New.\n\nFrom-SVN: r277861", "tree": {"sha": "9106ef9f8689bb7b61d0d78c63a1ad65f8dffe08", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9106ef9f8689bb7b61d0d78c63a1ad65f8dffe08"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a81ffd93b83c4be250514ff385b5b88fa5c3835b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a81ffd93b83c4be250514ff385b5b88fa5c3835b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a81ffd93b83c4be250514ff385b5b88fa5c3835b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a81ffd93b83c4be250514ff385b5b88fa5c3835b/comments", "author": null, "committer": null, "parents": [{"sha": "8aa76bb74696d0987e04a82ebcbc44f745ce788d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8aa76bb74696d0987e04a82ebcbc44f745ce788d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8aa76bb74696d0987e04a82ebcbc44f745ce788d"}], "stats": {"total": 45, "additions": 43, "deletions": 2}, "files": [{"sha": "4312d12506149a7d64d2ede5003c408115a82727", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a81ffd93b83c4be250514ff385b5b88fa5c3835b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a81ffd93b83c4be250514ff385b5b88fa5c3835b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a81ffd93b83c4be250514ff385b5b88fa5c3835b", "patch": "@@ -1,3 +1,9 @@\n+2019-11-05  Jim Wilson  <jimw@sifive.com>\n+\n+\tPR middle-end/92263\n+\t* expr.c (emit_move_complex): Only use BLOCK_OP_NO_LIBCALL when\n+\toptimize_insn_for_speed_p is true.\n+\n 2019-11-05  Martin Sebor  <msebor@redhat.com>\n \n \tPR middle-end/92333"}, {"sha": "0fd5890f8b4484b74c7f690fb748ef414c812945", "filename": "gcc/expr.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a81ffd93b83c4be250514ff385b5b88fa5c3835b/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a81ffd93b83c4be250514ff385b5b88fa5c3835b/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=a81ffd93b83c4be250514ff385b5b88fa5c3835b", "patch": "@@ -3571,11 +3571,13 @@ emit_move_complex (machine_mode mode, rtx x, rtx y)\n       rtx_insn *ret;\n \n       /* For memory to memory moves, optimal behavior can be had with the\n-\t existing block move logic.  */\n+\t existing block move logic.  But use normal expansion if optimizing\n+\t for size.  */\n       if (MEM_P (x) && MEM_P (y))\n \t{\n \t  emit_block_move (x, y, gen_int_mode (GET_MODE_SIZE (mode), Pmode),\n-\t\t\t   BLOCK_OP_NO_LIBCALL);\n+\t\t\t   (optimize_insn_for_speed_p()\n+\t\t\t    ? BLOCK_OP_NO_LIBCALL : BLOCK_OP_NORMAL));\n \t  return get_last_insn ();\n \t}\n "}, {"sha": "f34ed0873f8f9caf31d1b192de78db9f6ac9306d", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a81ffd93b83c4be250514ff385b5b88fa5c3835b/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a81ffd93b83c4be250514ff385b5b88fa5c3835b/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=a81ffd93b83c4be250514ff385b5b88fa5c3835b", "patch": "@@ -1,3 +1,8 @@\n+2019-11-05  Jim Wilson  <jimw@sifive.com>\n+\n+\tPR middle-end/92263\n+\t* gcc.dg/pr92263.c: New.\n+\n 2019-11-05  Martin Sebor  <msebor@redhat.com>\n \n \tPR middle-end/92333"}, {"sha": "a79dfd1e351012f6cc6c614d2e916ed03ff2791b", "filename": "gcc/testsuite/gcc.dg/pr92263.c", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a81ffd93b83c4be250514ff385b5b88fa5c3835b/gcc%2Ftestsuite%2Fgcc.dg%2Fpr92263.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a81ffd93b83c4be250514ff385b5b88fa5c3835b/gcc%2Ftestsuite%2Fgcc.dg%2Fpr92263.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr92263.c?ref=a81ffd93b83c4be250514ff385b5b88fa5c3835b", "patch": "@@ -0,0 +1,28 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fno-tree-dce -fno-tree-forwprop -Os -ffloat-store\" } */\n+\n+extern long double cabsl (_Complex long double);\n+\n+typedef struct {\n+  int nsant, nvqd;\n+  _Complex long double *vqd;\n+} vsorc_t;\n+vsorc_t vsorc;\n+\n+void foo(int next_job, int ain_num, int iped, long t) {\n+  long double zpnorm;\n+\n+  while (!next_job)\n+    if (ain_num)\n+    {\n+      if (iped == 1)\n+        zpnorm = 0.0;\n+      int indx = vsorc.nvqd-1;\n+      vsorc.vqd[indx] = t*1.0fj;\n+      if (cabsl(vsorc.vqd[indx]) < 1.e-20)\n+        vsorc.vqd[indx] = 0.0fj;\n+      zpnorm = t;\n+      if (zpnorm > 0.0)\n+        iped = vsorc.nsant;\n+    }\n+}"}]}