{"sha": "cdf2dd41b5a6892a26164be9dc17924ddb529586", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2RmMmRkNDFiNWE2ODkyYTI2MTY0YmU5ZGMxNzkyNGRkYjUyOTU4Ng==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2017-06-12T10:47:36Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2017-06-12T10:47:36Z"}, "message": "re PR ada/81070 (build failure for s-intrr.adb)\n\n\tPR ada/81070\n\t* s-interr-hwint.adb: Reinstate.\n\t* gcc-interface/Makefile.in (RTEMS): Use it again.\n\nFrom-SVN: r249115", "tree": {"sha": "1dae092d88848d186c60954dacca1a2af9001b87", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1dae092d88848d186c60954dacca1a2af9001b87"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cdf2dd41b5a6892a26164be9dc17924ddb529586", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cdf2dd41b5a6892a26164be9dc17924ddb529586", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cdf2dd41b5a6892a26164be9dc17924ddb529586", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cdf2dd41b5a6892a26164be9dc17924ddb529586/comments", "author": null, "committer": null, "parents": [{"sha": "aebce39694e2ce735fa12cdcdcd32d9e1984f102", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aebce39694e2ce735fa12cdcdcd32d9e1984f102", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aebce39694e2ce735fa12cdcdcd32d9e1984f102"}], "stats": {"total": 1118, "additions": 1117, "deletions": 1}, "files": [{"sha": "07ddbe830deb50ae91f50d21c4a5b8b76ba1d079", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cdf2dd41b5a6892a26164be9dc17924ddb529586/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cdf2dd41b5a6892a26164be9dc17924ddb529586/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=cdf2dd41b5a6892a26164be9dc17924ddb529586", "patch": "@@ -1,3 +1,9 @@\n+2017-06-12  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\tPR ada/81070\n+\t* s-interr-hwint.adb: Reinstate.\n+\t* gcc-interface/Makefile.in (RTEMS): Use it again.\n+\n 2017-06-08  Olivier Hainque  <hainque@adacore.com>\n \n \t* vx_crtbegin_auto.c: Update year in copyright notice."}, {"sha": "1030a67f9ea1f65bc7fad656c6beda7d978a1034", "filename": "gcc/ada/gcc-interface/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cdf2dd41b5a6892a26164be9dc17924ddb529586/gcc%2Fada%2Fgcc-interface%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cdf2dd41b5a6892a26164be9dc17924ddb529586/gcc%2Fada%2Fgcc-interface%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2FMakefile.in?ref=cdf2dd41b5a6892a26164be9dc17924ddb529586", "patch": "@@ -1747,7 +1747,7 @@ ifeq ($(strip $(filter-out rtems%,$(target_os))),)\n   s-taspri.ads<s-taspri-posix.ads \\\n   s-tpopsp.adb<s-tpopsp-tls.adb \\\n   s-stchop.adb<s-stchop-rtems.adb \\\n-  s-interr.adb<s-interr-vxworks.adb\n+  s-interr.adb<s-interr-hwint.adb\n endif\n \n # PikeOS"}, {"sha": "8e2950f30fbb88aa2ed7ada18ffb05883d13abd2", "filename": "gcc/ada/s-interr-hwint.adb", "status": "added", "additions": 1110, "deletions": 0, "changes": 1110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cdf2dd41b5a6892a26164be9dc17924ddb529586/gcc%2Fada%2Fs-interr-hwint.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cdf2dd41b5a6892a26164be9dc17924ddb529586/gcc%2Fada%2Fs-interr-hwint.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-interr-hwint.adb?ref=cdf2dd41b5a6892a26164be9dc17924ddb529586", "patch": "@@ -0,0 +1,1110 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                 GNAT RUN-TIME LIBRARY (GNARL) COMPONENTS                 --\n+--                                                                          --\n+--                     S Y S T E M . I N T E R R U P T S                    --\n+--                                                                          --\n+--                                  B o d y                                 --\n+--                                                                          --\n+--         Copyright (C) 1992-2014, Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNARL is free software; you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNARL was developed by the GNARL team at Florida State University.       --\n+-- Extensive contributions were provided by Ada Core Technologies, Inc.     --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Invariants:\n+\n+--  All user-handlable signals are masked at all times in all tasks/threads\n+--  except possibly for the Interrupt_Manager task.\n+\n+--  When a user task wants to have the effect of masking/unmasking an signal,\n+--  it must call Block_Interrupt/Unblock_Interrupt, which will have the effect\n+--  of unmasking/masking the signal in the Interrupt_Manager task. These\n+--  comments do not apply to vectored hardware interrupts, which may be masked\n+--  or unmasked using routined interfaced to the relevant embedded RTOS system\n+--  calls.\n+\n+--  Once we associate a Signal_Server_Task with an signal, the task never goes\n+--  away, and we never remove the association. On the other hand, it is more\n+--  convenient to terminate an associated Interrupt_Server_Task for a vectored\n+--  hardware interrupt (since we use a binary semaphore for synchronization\n+--  with the umbrella handler).\n+\n+--  There is no more than one signal per Signal_Server_Task and no more than\n+--  one Signal_Server_Task per signal. The same relation holds for hardware\n+--  interrupts and Interrupt_Server_Task's at any given time. That is, only\n+--  one non-terminated Interrupt_Server_Task exists for a give interrupt at\n+--  any time.\n+\n+--  Within this package, the lock L is used to protect the various status\n+--  tables. If there is a Server_Task associated with a signal or interrupt,\n+--  we use the per-task lock of the Server_Task instead so that we protect the\n+--  status between Interrupt_Manager and Server_Task. Protection among service\n+--  requests are ensured via user calls to the Interrupt_Manager entries.\n+\n+--  This is reasonably generic version of this package, supporting vectored\n+--  hardware interrupts using non-RTOS specific adapter routines which should\n+--  easily implemented on any RTOS capable of supporting GNAT.\n+\n+with Ada.Unchecked_Conversion;\n+with Ada.Task_Identification;\n+\n+with Interfaces.C; use Interfaces.C;\n+with System.OS_Interface; use System.OS_Interface;\n+with System.Interrupt_Management;\n+with System.Task_Primitives.Operations;\n+with System.Storage_Elements;\n+with System.Tasking.Utilities;\n+\n+with System.Tasking.Rendezvous;\n+pragma Elaborate_All (System.Tasking.Rendezvous);\n+\n+package body System.Interrupts is\n+\n+   use Tasking;\n+\n+   package POP renames System.Task_Primitives.Operations;\n+\n+   function To_Ada is new Ada.Unchecked_Conversion\n+     (System.Tasking.Task_Id, Ada.Task_Identification.Task_Id);\n+\n+   function To_System is new Ada.Unchecked_Conversion\n+     (Ada.Task_Identification.Task_Id, Task_Id);\n+\n+   -----------------\n+   -- Local Tasks --\n+   -----------------\n+\n+   --  WARNING: System.Tasking.Stages performs calls to this task with low-\n+   --  level constructs. Do not change this spec without synchronizing it.\n+\n+   task Interrupt_Manager is\n+      entry Detach_Interrupt_Entries (T : Task_Id);\n+\n+      entry Attach_Handler\n+        (New_Handler : Parameterless_Handler;\n+         Interrupt   : Interrupt_ID;\n+         Static      : Boolean;\n+         Restoration : Boolean := False);\n+\n+      entry Exchange_Handler\n+        (Old_Handler : out Parameterless_Handler;\n+         New_Handler : Parameterless_Handler;\n+         Interrupt   : Interrupt_ID;\n+         Static      : Boolean);\n+\n+      entry Detach_Handler\n+        (Interrupt : Interrupt_ID;\n+         Static    : Boolean);\n+\n+      entry Bind_Interrupt_To_Entry\n+        (T         : Task_Id;\n+         E         : Task_Entry_Index;\n+         Interrupt : Interrupt_ID);\n+\n+      pragma Interrupt_Priority (System.Interrupt_Priority'First);\n+   end Interrupt_Manager;\n+\n+   task type Interrupt_Server_Task\n+     (Interrupt : Interrupt_ID;\n+      Int_Sema  : Binary_Semaphore_Id)\n+   is\n+      --  Server task for vectored hardware interrupt handling\n+\n+      pragma Interrupt_Priority (System.Interrupt_Priority'First + 2);\n+   end Interrupt_Server_Task;\n+\n+   type Interrupt_Task_Access is access Interrupt_Server_Task;\n+\n+   -------------------------------\n+   -- Local Types and Variables --\n+   -------------------------------\n+\n+   type Entry_Assoc is record\n+      T : Task_Id;\n+      E : Task_Entry_Index;\n+   end record;\n+\n+   type Handler_Assoc is record\n+      H      : Parameterless_Handler;\n+      Static : Boolean;   --  Indicates static binding;\n+   end record;\n+\n+   User_Handler : array (Interrupt_ID) of Handler_Assoc :=\n+     (others => (null, Static => False));\n+   pragma Volatile_Components (User_Handler);\n+   --  Holds the protected procedure handler (if any) and its Static\n+   --  information for each interrupt or signal. A handler is static iff it\n+   --  is specified through the pragma Attach_Handler.\n+\n+   User_Entry : array (Interrupt_ID) of Entry_Assoc :=\n+                  (others => (T => Null_Task, E => Null_Task_Entry));\n+   pragma Volatile_Components (User_Entry);\n+   --  Holds the task and entry index (if any) for each interrupt / signal\n+\n+   --  Type and Head, Tail of the list containing Registered Interrupt\n+   --  Handlers. These definitions are used to register the handlers\n+   --  specified by the pragma Interrupt_Handler.\n+\n+   type Registered_Handler;\n+   type R_Link is access all Registered_Handler;\n+\n+   type Registered_Handler is record\n+      H    : System.Address := System.Null_Address;\n+      Next : R_Link := null;\n+   end record;\n+\n+   Registered_Handler_Head : R_Link := null;\n+   Registered_Handler_Tail : R_Link := null;\n+\n+   Server_ID : array (Interrupt_ID) of System.Tasking.Task_Id :=\n+                 (others => System.Tasking.Null_Task);\n+   pragma Atomic_Components (Server_ID);\n+   --  Holds the Task_Id of the Server_Task for each interrupt / signal.\n+   --  Task_Id is needed to accomplish locking per interrupt base. Also\n+   --  is needed to determine whether to create a new Server_Task.\n+\n+   Semaphore_ID_Map : array\n+     (Interrupt_ID range 0 .. System.OS_Interface.Max_HW_Interrupt) of\n+        Binary_Semaphore_Id := (others => 0);\n+   --  Array of binary semaphores associated with vectored interrupts. Note\n+   --  that the last bound should be Max_HW_Interrupt, but this will raise\n+   --  Storage_Error if Num_HW_Interrupts is null so use extra 4 bytes instead.\n+\n+   Interrupt_Access_Hold : Interrupt_Task_Access;\n+   --  Variable for allocating an Interrupt_Server_Task\n+\n+   Handler_Installed : array (HW_Interrupt) of Boolean := (others => False);\n+   --  True if Notify_Interrupt was connected to the interrupt. Handlers can\n+   --  be connected but disconnection is not possible on VxWorks. Therefore\n+   --  we ensure Notify_Installed is connected at most once.\n+\n+   -----------------------\n+   -- Local Subprograms --\n+   -----------------------\n+\n+   procedure Check_Reserved_Interrupt (Interrupt : Interrupt_ID);\n+   --  Check if Id is a reserved interrupt, and if so raise Program_Error\n+   --  with an appropriate message, otherwise return.\n+\n+   procedure Finalize_Interrupt_Servers;\n+   --  Unbind the handlers for hardware interrupt server tasks at program\n+   --  termination.\n+\n+   function Is_Registered (Handler : Parameterless_Handler) return Boolean;\n+   --  See if Handler has been \"pragma\"ed using Interrupt_Handler.\n+   --  Always consider a null handler as registered.\n+\n+   procedure Notify_Interrupt (Param : System.Address);\n+   pragma Convention (C, Notify_Interrupt);\n+   --  Umbrella handler for vectored interrupts (not signals)\n+\n+   procedure Install_Umbrella_Handler\n+     (Interrupt : HW_Interrupt;\n+      Handler   : System.OS_Interface.Interrupt_Handler);\n+   --  Install the runtime umbrella handler for a vectored hardware\n+   --  interrupt\n+\n+   procedure Unimplemented (Feature : String);\n+   pragma No_Return (Unimplemented);\n+   --  Used to mark a call to an unimplemented function. Raises Program_Error\n+   --  with an appropriate message noting that Feature is unimplemented.\n+\n+   --------------------\n+   -- Attach_Handler --\n+   --------------------\n+\n+   --  Calling this procedure with New_Handler = null and Static = True\n+   --  means we want to detach the current handler regardless of the previous\n+   --  handler's binding status (i.e. do not care if it is a dynamic or static\n+   --  handler).\n+\n+   --  This option is needed so that during the finalization of a PO, we can\n+   --  detach handlers attached through pragma Attach_Handler.\n+\n+   procedure Attach_Handler\n+     (New_Handler : Parameterless_Handler;\n+      Interrupt   : Interrupt_ID;\n+      Static      : Boolean := False) is\n+   begin\n+      Check_Reserved_Interrupt (Interrupt);\n+      Interrupt_Manager.Attach_Handler (New_Handler, Interrupt, Static);\n+   end Attach_Handler;\n+\n+   -----------------------------\n+   -- Bind_Interrupt_To_Entry --\n+   -----------------------------\n+\n+   --  This procedure raises a Program_Error if it tries to\n+   --  bind an interrupt to which an Entry or a Procedure is\n+   --  already bound.\n+\n+   procedure Bind_Interrupt_To_Entry\n+     (T       : Task_Id;\n+      E       : Task_Entry_Index;\n+      Int_Ref : System.Address)\n+   is\n+      Interrupt : constant Interrupt_ID :=\n+                    Interrupt_ID (Storage_Elements.To_Integer (Int_Ref));\n+   begin\n+      Check_Reserved_Interrupt (Interrupt);\n+      Interrupt_Manager.Bind_Interrupt_To_Entry (T, E, Interrupt);\n+   end Bind_Interrupt_To_Entry;\n+\n+   ---------------------\n+   -- Block_Interrupt --\n+   ---------------------\n+\n+   procedure Block_Interrupt (Interrupt : Interrupt_ID) is\n+   begin\n+      Unimplemented (\"Block_Interrupt\");\n+   end Block_Interrupt;\n+\n+   ------------------------------\n+   -- Check_Reserved_Interrupt --\n+   ------------------------------\n+\n+   procedure Check_Reserved_Interrupt (Interrupt : Interrupt_ID) is\n+   begin\n+      if Is_Reserved (Interrupt) then\n+         raise Program_Error with\n+           \"interrupt\" & Interrupt_ID'Image (Interrupt) & \" is reserved\";\n+      else\n+         return;\n+      end if;\n+   end Check_Reserved_Interrupt;\n+\n+   ---------------------\n+   -- Current_Handler --\n+   ---------------------\n+\n+   function Current_Handler\n+     (Interrupt : Interrupt_ID) return Parameterless_Handler\n+   is\n+   begin\n+      Check_Reserved_Interrupt (Interrupt);\n+\n+      --  ??? Since Parameterless_Handler is not Atomic, the current\n+      --  implementation is wrong. We need a new service in Interrupt_Manager\n+      --  to ensure atomicity.\n+\n+      return User_Handler (Interrupt).H;\n+   end Current_Handler;\n+\n+   --------------------\n+   -- Detach_Handler --\n+   --------------------\n+\n+   --  Calling this procedure with Static = True means we want to Detach the\n+   --  current handler regardless of the previous handler's binding status\n+   --  (i.e. do not care if it is a dynamic or static handler).\n+\n+   --  This option is needed so that during the finalization of a PO, we can\n+   --  detach handlers attached through pragma Attach_Handler.\n+\n+   procedure Detach_Handler\n+     (Interrupt : Interrupt_ID;\n+      Static    : Boolean := False)\n+   is\n+   begin\n+      Check_Reserved_Interrupt (Interrupt);\n+      Interrupt_Manager.Detach_Handler (Interrupt, Static);\n+   end Detach_Handler;\n+\n+   ------------------------------\n+   -- Detach_Interrupt_Entries --\n+   ------------------------------\n+\n+   procedure Detach_Interrupt_Entries (T : Task_Id) is\n+   begin\n+      Interrupt_Manager.Detach_Interrupt_Entries (T);\n+   end Detach_Interrupt_Entries;\n+\n+   ----------------------\n+   -- Exchange_Handler --\n+   ----------------------\n+\n+   --  Calling this procedure with New_Handler = null and Static = True\n+   --  means we want to detach the current handler regardless of the previous\n+   --  handler's binding status (i.e. we do not care if it is a dynamic or\n+   --  static handler).\n+\n+   --  This option is needed so that during the finalization of a PO, we can\n+   --  detach handlers attached through pragma Attach_Handler.\n+\n+   procedure Exchange_Handler\n+     (Old_Handler : out Parameterless_Handler;\n+      New_Handler : Parameterless_Handler;\n+      Interrupt   : Interrupt_ID;\n+      Static      : Boolean := False)\n+   is\n+   begin\n+      Check_Reserved_Interrupt (Interrupt);\n+      Interrupt_Manager.Exchange_Handler\n+        (Old_Handler, New_Handler, Interrupt, Static);\n+   end Exchange_Handler;\n+\n+   --------------\n+   -- Finalize --\n+   --------------\n+\n+   procedure Finalize (Object : in out Static_Interrupt_Protection) is\n+   begin\n+      --  ??? loop to be executed only when we're not doing library level\n+      --  finalization, since in this case all interrupt / signal tasks are\n+      --  gone.\n+\n+      if not Interrupt_Manager'Terminated then\n+         for N in reverse Object.Previous_Handlers'Range loop\n+            Interrupt_Manager.Attach_Handler\n+              (New_Handler => Object.Previous_Handlers (N).Handler,\n+               Interrupt   => Object.Previous_Handlers (N).Interrupt,\n+               Static      => Object.Previous_Handlers (N).Static,\n+               Restoration => True);\n+         end loop;\n+      end if;\n+\n+      Tasking.Protected_Objects.Entries.Finalize\n+        (Tasking.Protected_Objects.Entries.Protection_Entries (Object));\n+   end Finalize;\n+\n+   --------------------------------\n+   -- Finalize_Interrupt_Servers --\n+   --------------------------------\n+\n+   --  Restore default handlers for interrupt servers\n+\n+   --  This is called by the Interrupt_Manager task when it receives the abort\n+   --  signal during program finalization.\n+\n+   procedure Finalize_Interrupt_Servers is\n+      HW_Interrupts : constant Boolean := HW_Interrupt'Last >= 0;\n+   begin\n+      if HW_Interrupts then\n+         for Int in HW_Interrupt loop\n+            if Server_ID (Interrupt_ID (Int)) /= null\n+              and then\n+                not Ada.Task_Identification.Is_Terminated\n+                 (To_Ada (Server_ID (Interrupt_ID (Int))))\n+            then\n+               Interrupt_Manager.Attach_Handler\n+                 (New_Handler => null,\n+                  Interrupt   => Interrupt_ID (Int),\n+                  Static      => True,\n+                  Restoration => True);\n+            end if;\n+         end loop;\n+      end if;\n+   end Finalize_Interrupt_Servers;\n+\n+   -------------------------------------\n+   -- Has_Interrupt_Or_Attach_Handler --\n+   -------------------------------------\n+\n+   function Has_Interrupt_Or_Attach_Handler\n+     (Object : access Dynamic_Interrupt_Protection)\n+      return   Boolean\n+   is\n+      pragma Unreferenced (Object);\n+   begin\n+      return True;\n+   end Has_Interrupt_Or_Attach_Handler;\n+\n+   function Has_Interrupt_Or_Attach_Handler\n+     (Object : access Static_Interrupt_Protection)\n+      return   Boolean\n+   is\n+      pragma Unreferenced (Object);\n+   begin\n+      return True;\n+   end Has_Interrupt_Or_Attach_Handler;\n+\n+   ----------------------\n+   -- Ignore_Interrupt --\n+   ----------------------\n+\n+   procedure Ignore_Interrupt (Interrupt : Interrupt_ID) is\n+   begin\n+      Unimplemented (\"Ignore_Interrupt\");\n+   end Ignore_Interrupt;\n+\n+   ----------------------\n+   -- Install_Handlers --\n+   ----------------------\n+\n+   procedure Install_Handlers\n+     (Object       : access Static_Interrupt_Protection;\n+      New_Handlers : New_Handler_Array)\n+   is\n+   begin\n+      for N in New_Handlers'Range loop\n+\n+         --  We need a lock around this ???\n+\n+         Object.Previous_Handlers (N).Interrupt := New_Handlers (N).Interrupt;\n+         Object.Previous_Handlers (N).Static    := User_Handler\n+           (New_Handlers (N).Interrupt).Static;\n+\n+         --  We call Exchange_Handler and not directly Interrupt_Manager.\n+         --  Exchange_Handler so we get the Is_Reserved check.\n+\n+         Exchange_Handler\n+           (Old_Handler => Object.Previous_Handlers (N).Handler,\n+            New_Handler => New_Handlers (N).Handler,\n+            Interrupt   => New_Handlers (N).Interrupt,\n+            Static      => True);\n+      end loop;\n+   end Install_Handlers;\n+\n+   ---------------------------------\n+   -- Install_Restricted_Handlers --\n+   ---------------------------------\n+\n+   procedure Install_Restricted_Handlers\n+      (Prio     : Any_Priority;\n+       Handlers : New_Handler_Array)\n+   is\n+      pragma Unreferenced (Prio);\n+   begin\n+      for N in Handlers'Range loop\n+         Attach_Handler (Handlers (N).Handler, Handlers (N).Interrupt, True);\n+      end loop;\n+   end Install_Restricted_Handlers;\n+\n+   ------------------------------\n+   -- Install_Umbrella_Handler --\n+   ------------------------------\n+\n+   procedure Install_Umbrella_Handler\n+     (Interrupt : HW_Interrupt;\n+      Handler   : System.OS_Interface.Interrupt_Handler)\n+   is\n+      Vec : constant Interrupt_Vector :=\n+              Interrupt_Number_To_Vector (int (Interrupt));\n+\n+      Status : int;\n+\n+   begin\n+      --  Only install umbrella handler when no Ada handler has already been\n+      --  installed. Note that the interrupt number is passed as a parameter\n+      --  when an interrupt occurs, so the umbrella handler has a different\n+      --  wrapper generated by intConnect for each interrupt number.\n+\n+      if not Handler_Installed (Interrupt) then\n+         Status :=\n+            Interrupt_Connect (Vec, Handler, System.Address (Interrupt));\n+         pragma Assert (Status = 0);\n+\n+         Handler_Installed (Interrupt) := True;\n+      end if;\n+   end Install_Umbrella_Handler;\n+\n+   ----------------\n+   -- Is_Blocked --\n+   ----------------\n+\n+   function Is_Blocked (Interrupt : Interrupt_ID) return Boolean is\n+   begin\n+      Unimplemented (\"Is_Blocked\");\n+      return False;\n+   end Is_Blocked;\n+\n+   -----------------------\n+   -- Is_Entry_Attached --\n+   -----------------------\n+\n+   function Is_Entry_Attached (Interrupt : Interrupt_ID) return Boolean is\n+   begin\n+      Check_Reserved_Interrupt (Interrupt);\n+      return User_Entry (Interrupt).T /= Null_Task;\n+   end Is_Entry_Attached;\n+\n+   -------------------------\n+   -- Is_Handler_Attached --\n+   -------------------------\n+\n+   function Is_Handler_Attached (Interrupt : Interrupt_ID) return Boolean is\n+   begin\n+      Check_Reserved_Interrupt (Interrupt);\n+      return User_Handler (Interrupt).H /= null;\n+   end Is_Handler_Attached;\n+\n+   ----------------\n+   -- Is_Ignored --\n+   ----------------\n+\n+   function Is_Ignored (Interrupt : Interrupt_ID) return Boolean is\n+   begin\n+      Unimplemented (\"Is_Ignored\");\n+      return False;\n+   end Is_Ignored;\n+\n+   -------------------\n+   -- Is_Registered --\n+   -------------------\n+\n+   function Is_Registered (Handler : Parameterless_Handler) return Boolean is\n+      type Fat_Ptr is record\n+         Object_Addr  : System.Address;\n+         Handler_Addr : System.Address;\n+      end record;\n+\n+      function To_Fat_Ptr is new Ada.Unchecked_Conversion\n+        (Parameterless_Handler, Fat_Ptr);\n+\n+      Ptr : R_Link;\n+      Fat : Fat_Ptr;\n+\n+   begin\n+      if Handler = null then\n+         return True;\n+      end if;\n+\n+      Fat := To_Fat_Ptr (Handler);\n+\n+      Ptr := Registered_Handler_Head;\n+      while Ptr /= null loop\n+         if Ptr.H = Fat.Handler_Addr then\n+            return True;\n+         end if;\n+\n+         Ptr := Ptr.Next;\n+      end loop;\n+\n+      return False;\n+   end Is_Registered;\n+\n+   -----------------\n+   -- Is_Reserved --\n+   -----------------\n+\n+   function Is_Reserved (Interrupt : Interrupt_ID) return Boolean is\n+      use System.Interrupt_Management;\n+   begin\n+      return Reserve (System.Interrupt_Management.Interrupt_ID (Interrupt));\n+   end Is_Reserved;\n+\n+   ----------------------\n+   -- Notify_Interrupt --\n+   ----------------------\n+\n+   --  Umbrella handler for vectored hardware interrupts (as opposed to signals\n+   --  and exceptions). As opposed to the signal implementation, this handler\n+   --  is installed in the vector table when the first Ada handler is attached\n+   --  to the interrupt. However because VxWorks don't support disconnecting\n+   --  handlers, this subprogram always test whether or not an Ada handler is\n+   --  effectively attached.\n+\n+   --  Otherwise, the handler that existed prior to program startup is in the\n+   --  vector table. This ensures that handlers installed by the BSP are active\n+   --  unless explicitly replaced in the program text.\n+\n+   --  Each Interrupt_Server_Task has an associated binary semaphore on which\n+   --  it pends once it's been started. This routine determines The appropriate\n+   --  semaphore and issues a semGive call, waking the server task. When\n+   --  a handler is unbound, System.Interrupts.Unbind_Handler issues a\n+   --  Binary_Semaphore_Flush, and the server task deletes its semaphore\n+   --  and terminates.\n+\n+   procedure Notify_Interrupt (Param : System.Address) is\n+      Interrupt : constant Interrupt_ID := Interrupt_ID (Param);\n+      Id        : constant Binary_Semaphore_Id := Semaphore_ID_Map (Interrupt);\n+      Status    : int;\n+   begin\n+      if Id /= 0 then\n+         Status := Binary_Semaphore_Release (Id);\n+         pragma Assert (Status = 0);\n+      end if;\n+   end Notify_Interrupt;\n+\n+   ---------------\n+   -- Reference --\n+   ---------------\n+\n+   function Reference (Interrupt : Interrupt_ID) return System.Address is\n+   begin\n+      Check_Reserved_Interrupt (Interrupt);\n+      return Storage_Elements.To_Address\n+               (Storage_Elements.Integer_Address (Interrupt));\n+   end Reference;\n+\n+   --------------------------------\n+   -- Register_Interrupt_Handler --\n+   --------------------------------\n+\n+   procedure Register_Interrupt_Handler (Handler_Addr : System.Address) is\n+      New_Node_Ptr : R_Link;\n+\n+   begin\n+      --  This routine registers a handler as usable for dynamic interrupt\n+      --  handler association. Routines attaching and detaching handlers\n+      --  dynamically should determine whether the handler is registered.\n+      --  Program_Error should be raised if it is not registered.\n+\n+      --  Pragma Interrupt_Handler can only appear in a library level PO\n+      --  definition and instantiation. Therefore, we do not need to implement\n+      --  an unregister operation. Nor do we need to protect the queue\n+      --  structure with a lock.\n+\n+      pragma Assert (Handler_Addr /= System.Null_Address);\n+\n+      New_Node_Ptr := new Registered_Handler;\n+      New_Node_Ptr.H := Handler_Addr;\n+\n+      if Registered_Handler_Head = null then\n+         Registered_Handler_Head := New_Node_Ptr;\n+         Registered_Handler_Tail := New_Node_Ptr;\n+      else\n+         Registered_Handler_Tail.Next := New_Node_Ptr;\n+         Registered_Handler_Tail := New_Node_Ptr;\n+      end if;\n+   end Register_Interrupt_Handler;\n+\n+   -----------------------\n+   -- Unblock_Interrupt --\n+   -----------------------\n+\n+   procedure Unblock_Interrupt (Interrupt : Interrupt_ID) is\n+   begin\n+      Unimplemented (\"Unblock_Interrupt\");\n+   end Unblock_Interrupt;\n+\n+   ------------------\n+   -- Unblocked_By --\n+   ------------------\n+\n+   function Unblocked_By\n+     (Interrupt : Interrupt_ID) return System.Tasking.Task_Id\n+   is\n+   begin\n+      Unimplemented (\"Unblocked_By\");\n+      return Null_Task;\n+   end Unblocked_By;\n+\n+   ------------------------\n+   -- Unignore_Interrupt --\n+   ------------------------\n+\n+   procedure Unignore_Interrupt (Interrupt : Interrupt_ID) is\n+   begin\n+      Unimplemented (\"Unignore_Interrupt\");\n+   end Unignore_Interrupt;\n+\n+   -------------------\n+   -- Unimplemented --\n+   -------------------\n+\n+   procedure Unimplemented (Feature : String) is\n+   begin\n+      raise Program_Error with Feature & \" not implemented on VxWorks\";\n+   end Unimplemented;\n+\n+   -----------------------\n+   -- Interrupt_Manager --\n+   -----------------------\n+\n+   task body Interrupt_Manager is\n+      --  By making this task independent of any master, when the process goes\n+      --  away, the Interrupt_Manager will terminate gracefully.\n+\n+      Ignore : constant Boolean := System.Tasking.Utilities.Make_Independent;\n+      pragma Unreferenced (Ignore);\n+\n+      --------------------\n+      -- Local Routines --\n+      --------------------\n+\n+      procedure Bind_Handler (Interrupt : Interrupt_ID);\n+      --  This procedure does not do anything if a signal is blocked.\n+      --  Otherwise, we have to interrupt Server_Task for status change\n+      --  through a wakeup signal.\n+\n+      procedure Unbind_Handler (Interrupt : Interrupt_ID);\n+      --  This procedure does not do anything if a signal is blocked.\n+      --  Otherwise, we have to interrupt Server_Task for status change\n+      --  through an abort signal.\n+\n+      procedure Unprotected_Exchange_Handler\n+        (Old_Handler : out Parameterless_Handler;\n+         New_Handler : Parameterless_Handler;\n+         Interrupt   : Interrupt_ID;\n+         Static      : Boolean;\n+         Restoration : Boolean := False);\n+\n+      procedure Unprotected_Detach_Handler\n+        (Interrupt : Interrupt_ID;\n+         Static    : Boolean);\n+\n+      ------------------\n+      -- Bind_Handler --\n+      ------------------\n+\n+      procedure Bind_Handler (Interrupt : Interrupt_ID) is\n+      begin\n+         Install_Umbrella_Handler\n+           (HW_Interrupt (Interrupt), Notify_Interrupt'Access);\n+      end Bind_Handler;\n+\n+      --------------------\n+      -- Unbind_Handler --\n+      --------------------\n+\n+      procedure Unbind_Handler (Interrupt : Interrupt_ID) is\n+         Status : int;\n+\n+      begin\n+         --  Flush server task off semaphore, allowing it to terminate\n+\n+         Status := Binary_Semaphore_Flush (Semaphore_ID_Map (Interrupt));\n+         pragma Assert (Status = 0);\n+      end Unbind_Handler;\n+\n+      --------------------------------\n+      -- Unprotected_Detach_Handler --\n+      --------------------------------\n+\n+      procedure Unprotected_Detach_Handler\n+        (Interrupt : Interrupt_ID;\n+         Static    : Boolean)\n+      is\n+         Old_Handler : Parameterless_Handler;\n+      begin\n+         if User_Entry (Interrupt).T /= Null_Task then\n+\n+            --  If an interrupt entry is installed raise Program_Error\n+            --  (propagate it to the caller).\n+\n+            raise Program_Error with\n+              \"an interrupt entry is already installed\";\n+         end if;\n+\n+         --  Note : Static = True will pass the following check. This is the\n+         --  case when we want to detach a handler regardless of the static\n+         --  status of the Current_Handler.\n+\n+         if not Static and then User_Handler (Interrupt).Static then\n+\n+            --  Trying to detach a static Interrupt Handler, raise\n+            --  Program_Error.\n+\n+            raise Program_Error with\n+              \"trying to detach a static Interrupt Handler\";\n+         end if;\n+\n+         Old_Handler := User_Handler (Interrupt).H;\n+\n+         --  The new handler\n+\n+         User_Handler (Interrupt).H := null;\n+         User_Handler (Interrupt).Static := False;\n+\n+         if Old_Handler /= null then\n+            Unbind_Handler (Interrupt);\n+         end if;\n+      end Unprotected_Detach_Handler;\n+\n+      ----------------------------------\n+      -- Unprotected_Exchange_Handler --\n+      ----------------------------------\n+\n+      procedure Unprotected_Exchange_Handler\n+        (Old_Handler : out Parameterless_Handler;\n+         New_Handler : Parameterless_Handler;\n+         Interrupt   : Interrupt_ID;\n+         Static      : Boolean;\n+         Restoration : Boolean := False)\n+      is\n+      begin\n+         if User_Entry (Interrupt).T /= Null_Task then\n+\n+            --  If an interrupt entry is already installed, raise\n+            --  Program_Error (propagate it to the caller).\n+\n+            raise Program_Error with \"an interrupt is already installed\";\n+         end if;\n+\n+         --  Note : A null handler with Static = True will pass the following\n+         --  check. This is the case when we want to detach a handler\n+         --  regardless of the Static status of Current_Handler.\n+\n+         --  We don't check anything if Restoration is True, since we may be\n+         --  detaching a static handler to restore a dynamic one.\n+\n+         if not Restoration and then not Static\n+           and then (User_Handler (Interrupt).Static\n+\n+            --  Trying to overwrite a static Interrupt Handler with a dynamic\n+            --  Handler\n+\n+            --  The new handler is not specified as an Interrupt Handler by a\n+            --  pragma.\n+\n+           or else not Is_Registered (New_Handler))\n+         then\n+            raise Program_Error with\n+               \"trying to overwrite a static interrupt handler with a \"\n+               & \"dynamic handler\";\n+         end if;\n+\n+         --  Save the old handler\n+\n+         Old_Handler := User_Handler (Interrupt).H;\n+\n+         --  The new handler\n+\n+         User_Handler (Interrupt).H := New_Handler;\n+\n+         if New_Handler = null then\n+\n+            --  The null handler means we are detaching the handler\n+\n+            User_Handler (Interrupt).Static := False;\n+\n+         else\n+            User_Handler (Interrupt).Static := Static;\n+         end if;\n+\n+         --  Invoke a corresponding Server_Task if not yet created. Place\n+         --  Task_Id info in Server_ID array.\n+\n+         if New_Handler /= null\n+           and then\n+            (Server_ID (Interrupt) = Null_Task\n+              or else\n+                Ada.Task_Identification.Is_Terminated\n+                  (To_Ada (Server_ID (Interrupt))))\n+         then\n+            Interrupt_Access_Hold :=\n+              new Interrupt_Server_Task (Interrupt, Binary_Semaphore_Create);\n+            Server_ID (Interrupt) :=\n+              To_System (Interrupt_Access_Hold.all'Identity);\n+         end if;\n+\n+         if (New_Handler = null) and then Old_Handler /= null then\n+\n+            --  Restore default handler\n+\n+            Unbind_Handler (Interrupt);\n+\n+         elsif Old_Handler = null then\n+\n+            --  Save default handler\n+\n+            Bind_Handler (Interrupt);\n+         end if;\n+      end Unprotected_Exchange_Handler;\n+\n+   --  Start of processing for Interrupt_Manager\n+\n+   begin\n+      loop\n+         --  A block is needed to absorb Program_Error exception\n+\n+         declare\n+            Old_Handler : Parameterless_Handler;\n+\n+         begin\n+            select\n+               accept Attach_Handler\n+                 (New_Handler : Parameterless_Handler;\n+                  Interrupt   : Interrupt_ID;\n+                  Static      : Boolean;\n+                  Restoration : Boolean := False)\n+               do\n+                  Unprotected_Exchange_Handler\n+                    (Old_Handler, New_Handler, Interrupt, Static, Restoration);\n+               end Attach_Handler;\n+\n+            or\n+               accept Exchange_Handler\n+                 (Old_Handler : out Parameterless_Handler;\n+                  New_Handler : Parameterless_Handler;\n+                  Interrupt   : Interrupt_ID;\n+                  Static      : Boolean)\n+               do\n+                  Unprotected_Exchange_Handler\n+                    (Old_Handler, New_Handler, Interrupt, Static);\n+               end Exchange_Handler;\n+\n+            or\n+               accept Detach_Handler\n+                  (Interrupt : Interrupt_ID;\n+                   Static    : Boolean)\n+               do\n+                  Unprotected_Detach_Handler (Interrupt, Static);\n+               end Detach_Handler;\n+\n+            or\n+               accept Bind_Interrupt_To_Entry\n+                 (T         : Task_Id;\n+                  E         : Task_Entry_Index;\n+                  Interrupt : Interrupt_ID)\n+               do\n+                  --  If there is a binding already (either a procedure or an\n+                  --  entry), raise Program_Error (propagate it to the caller).\n+\n+                  if User_Handler (Interrupt).H /= null\n+                    or else User_Entry (Interrupt).T /= Null_Task\n+                  then\n+                     raise Program_Error with\n+                       \"a binding for this interrupt is already present\";\n+                  end if;\n+\n+                  User_Entry (Interrupt) := Entry_Assoc'(T => T, E => E);\n+\n+                  --  Indicate the attachment of interrupt entry in the ATCB.\n+                  --  This is needed so when an interrupt entry task terminates\n+                  --  the binding can be cleaned. The call to unbinding must be\n+                  --  make by the task before it terminates.\n+\n+                  T.Interrupt_Entry := True;\n+\n+                  --  Invoke a corresponding Server_Task if not yet created.\n+                  --  Place Task_Id info in Server_ID array.\n+\n+                  if Server_ID (Interrupt) = Null_Task\n+                    or else\n+                      Ada.Task_Identification.Is_Terminated\n+                        (To_Ada (Server_ID (Interrupt)))\n+                  then\n+                     Interrupt_Access_Hold := new Interrupt_Server_Task\n+                       (Interrupt, Binary_Semaphore_Create);\n+                     Server_ID (Interrupt) :=\n+                       To_System (Interrupt_Access_Hold.all'Identity);\n+                  end if;\n+\n+                  Bind_Handler (Interrupt);\n+               end Bind_Interrupt_To_Entry;\n+\n+            or\n+               accept Detach_Interrupt_Entries (T : Task_Id) do\n+                  for Int in Interrupt_ID'Range loop\n+                     if not Is_Reserved (Int) then\n+                        if User_Entry (Int).T = T then\n+                           User_Entry (Int) :=\n+                             Entry_Assoc'\n+                               (T => Null_Task, E => Null_Task_Entry);\n+                           Unbind_Handler (Int);\n+                        end if;\n+                     end if;\n+                  end loop;\n+\n+                  --  Indicate in ATCB that no interrupt entries are attached\n+\n+                  T.Interrupt_Entry := False;\n+               end Detach_Interrupt_Entries;\n+            end select;\n+\n+         exception\n+            --  If there is a Program_Error we just want to propagate it to\n+            --  the caller and do not want to stop this task.\n+\n+            when Program_Error =>\n+               null;\n+\n+            when others =>\n+               pragma Assert (False);\n+               null;\n+         end;\n+      end loop;\n+\n+   exception\n+      when Standard'Abort_Signal =>\n+\n+         --  Flush interrupt server semaphores, so they can terminate\n+\n+         Finalize_Interrupt_Servers;\n+         raise;\n+   end Interrupt_Manager;\n+\n+   ---------------------------\n+   -- Interrupt_Server_Task --\n+   ---------------------------\n+\n+   --  Server task for vectored hardware interrupt handling\n+\n+   task body Interrupt_Server_Task is\n+      Ignore : constant Boolean := System.Tasking.Utilities.Make_Independent;\n+\n+      Self_Id         : constant Task_Id := Self;\n+      Tmp_Handler     : Parameterless_Handler;\n+      Tmp_ID          : Task_Id;\n+      Tmp_Entry_Index : Task_Entry_Index;\n+      Status          : int;\n+\n+   begin\n+      Semaphore_ID_Map (Interrupt) := Int_Sema;\n+\n+      loop\n+         --  Pend on semaphore that will be triggered by the umbrella handler\n+         --  when the associated interrupt comes in.\n+\n+         Status := Binary_Semaphore_Obtain (Int_Sema);\n+         pragma Assert (Status = 0);\n+\n+         if User_Handler (Interrupt).H /= null then\n+\n+            --  Protected procedure handler\n+\n+            Tmp_Handler := User_Handler (Interrupt).H;\n+            Tmp_Handler.all;\n+\n+         elsif User_Entry (Interrupt).T /= Null_Task then\n+\n+            --  Interrupt entry handler\n+\n+            Tmp_ID := User_Entry (Interrupt).T;\n+            Tmp_Entry_Index := User_Entry (Interrupt).E;\n+            System.Tasking.Rendezvous.Call_Simple\n+              (Tmp_ID, Tmp_Entry_Index, System.Null_Address);\n+\n+         else\n+            --  Semaphore has been flushed by an unbind operation in the\n+            --  Interrupt_Manager. Terminate the server task.\n+\n+            --  Wait for the Interrupt_Manager to complete its work\n+\n+            POP.Write_Lock (Self_Id);\n+\n+            --  Unassociate the interrupt handler\n+\n+            Semaphore_ID_Map (Interrupt) := 0;\n+\n+            --  Delete the associated semaphore\n+\n+            Status := Binary_Semaphore_Delete (Int_Sema);\n+\n+            pragma Assert (Status = 0);\n+\n+            --  Set status for the Interrupt_Manager\n+\n+            Server_ID (Interrupt) := Null_Task;\n+            POP.Unlock (Self_Id);\n+\n+            exit;\n+         end if;\n+      end loop;\n+   end Interrupt_Server_Task;\n+\n+begin\n+   --  Get Interrupt_Manager's ID so that Abort_Interrupt can be sent\n+\n+   Interrupt_Manager_ID := To_System (Interrupt_Manager'Identity);\n+end System.Interrupts;"}]}