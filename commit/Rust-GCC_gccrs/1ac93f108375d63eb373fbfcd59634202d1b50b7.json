{"sha": "1ac93f108375d63eb373fbfcd59634202d1b50b7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWFjOTNmMTA4Mzc1ZDYzZWIzNzNmYmZjZDU5NjM0MjAyZDFiNTBiNw==", "commit": {"author": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2011-06-30T21:54:29Z"}, "committer": {"name": "Martin Jambor", "email": "jamborm@gcc.gnu.org", "date": "2011-06-30T21:54:29Z"}, "message": "tree-sra.c (struct access): Rename total_scalarization to grp_total_scalarization\n\n2011-06-30  Martin Jambor  <mjambor@suse.cz>\n\n\t* tree-sra.c (struct access): Rename total_scalarization to\n\tgrp_total_scalarization\n\t(completely_scalarize_var): New function.\n\t(sort_and_splice_var_accesses): Set total_scalarization in the\n\trepresentative access.\n\t(analyze_access_subtree): Propagate total scalarization accross the\n\ttree, no holes in totally scalarized trees, simplify coverage\n\tcomputation.\n\t(analyze_all_variable_accesses): Call completely_scalarize_var instead\n\tof completely_scalarize_record.\n\n\t* testsuite/gcc.dg/tree-ssa/sra-12.c: New test.\n\nFrom-SVN: r175733", "tree": {"sha": "e45709faaffddb5adbaa67c4980f88fdc69b3932", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e45709faaffddb5adbaa67c4980f88fdc69b3932"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1ac93f108375d63eb373fbfcd59634202d1b50b7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ac93f108375d63eb373fbfcd59634202d1b50b7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1ac93f108375d63eb373fbfcd59634202d1b50b7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ac93f108375d63eb373fbfcd59634202d1b50b7/comments", "author": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ca1085f03cc717057e7831e1ca0b98fc44c78eb8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca1085f03cc717057e7831e1ca0b98fc44c78eb8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ca1085f03cc717057e7831e1ca0b98fc44c78eb8"}], "stats": {"total": 118, "additions": 93, "deletions": 25}, "files": [{"sha": "8fc1cd55b8e5e5d8c31210edbbd048c4491f7e9f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ac93f108375d63eb373fbfcd59634202d1b50b7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ac93f108375d63eb373fbfcd59634202d1b50b7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1ac93f108375d63eb373fbfcd59634202d1b50b7", "patch": "@@ -1,3 +1,16 @@\n+2011-06-30  Martin Jambor  <mjambor@suse.cz>\n+\n+\t* tree-sra.c (struct access): Rename total_scalarization to\n+\tgrp_total_scalarization\n+\t(completely_scalarize_var): New function.\n+\t(sort_and_splice_var_accesses): Set total_scalarization in the\n+\trepresentative access.\n+\t(analyze_access_subtree): Propagate total scalarization accross the\n+\ttree, no holes in totally scalarized trees, simplify coverage\n+\tcomputation.\n+\t(analyze_all_variable_accesses): Call completely_scalarize_var instead\n+\tof completely_scalarize_record.\n+\n 2011-06-30  Richard Henderson  <rth@redhat.com>\n \n \t* config/i386/i386.h (X86_TUNE_DEEP_BRANCH_PREDICTION): Remove."}, {"sha": "66e980ac7e469a748311807b6f5e0b18c4d3e726", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ac93f108375d63eb373fbfcd59634202d1b50b7/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ac93f108375d63eb373fbfcd59634202d1b50b7/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=1ac93f108375d63eb373fbfcd59634202d1b50b7", "patch": "@@ -1,3 +1,7 @@\n+2011-06-30  Martin Jambor  <mjambor@suse.cz>\n+\n+\t* gcc.dg/tree-ssa/sra-12.c: New test.\n+\n 2011-06-29  Jason Merrill  <jason@redhat.com>\n \n \t* g++.dg/cpp0x/named.C: Test subobject of xvalue."}, {"sha": "988caecd4ae40d2e32aeebef4d5c66f6a5e0484e", "filename": "gcc/testsuite/gcc.dg/tree-ssa/sra-12.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ac93f108375d63eb373fbfcd59634202d1b50b7/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fsra-12.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ac93f108375d63eb373fbfcd59634202d1b50b7/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fsra-12.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fsra-12.c?ref=1ac93f108375d63eb373fbfcd59634202d1b50b7", "patch": "@@ -0,0 +1,25 @@\n+/* Verify that SRA total scalarization will not be confused by padding.  */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-O1 -fdump-tree-release_ssa\" } */\n+\n+struct S\n+{\n+  int i;\n+  unsigned short f1;\n+  char f2;\n+  unsigned short f3, f4;\n+};\n+\n+\n+int foo (struct S *p)\n+{\n+  struct S l;\n+\n+  l = *p;\n+  l.i++;\n+  *p = l;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"l;\" 0 \"release_ssa\"} } */\n+/* { dg-final { cleanup-tree-dump \"release_ssa\" } } */"}, {"sha": "d244766b0e2d742663206eb771081f3e903e3735", "filename": "gcc/tree-sra.c", "status": "modified", "additions": 51, "deletions": 25, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ac93f108375d63eb373fbfcd59634202d1b50b7/gcc%2Ftree-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ac93f108375d63eb373fbfcd59634202d1b50b7/gcc%2Ftree-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-sra.c?ref=1ac93f108375d63eb373fbfcd59634202d1b50b7", "patch": "@@ -170,10 +170,6 @@ struct access\n   /* Is this particular access write access? */\n   unsigned write : 1;\n \n-  /* Is this access an artificial one created to scalarize some record\n-     entirely? */\n-  unsigned total_scalarization : 1;\n-\n   /* Is this access an access to a non-addressable field? */\n   unsigned non_addressable : 1;\n \n@@ -204,6 +200,10 @@ struct access\n      is not propagated in the access tree in any direction.  */\n   unsigned grp_scalar_write : 1;\n \n+  /* Is this access an artificial one created to scalarize some record\n+     entirely? */\n+  unsigned grp_total_scalarization : 1;\n+\n   /* Other passes of the analysis use this bit to make function\n      analyze_access_subtree create scalar replacements for this group if\n      possible.  */\n@@ -377,26 +377,26 @@ dump_access (FILE *f, struct access *access, bool grp)\n   fprintf (f, \", type = \");\n   print_generic_expr (f, access->type, 0);\n   if (grp)\n-    fprintf (f, \", total_scalarization = %d, grp_read = %d, grp_write = %d, \"\n-\t     \"grp_assignment_read = %d, grp_assignment_write = %d, \"\n-\t     \"grp_scalar_read = %d, grp_scalar_write = %d, \"\n+    fprintf (f, \", grp_read = %d, grp_write = %d, grp_assignment_read = %d, \"\n+\t     \"grp_assignment_write = %d, grp_scalar_read = %d, \"\n+\t     \"grp_scalar_write = %d, grp_total_scalarization = %d, \"\n \t     \"grp_hint = %d, grp_covered = %d, \"\n \t     \"grp_unscalarizable_region = %d, grp_unscalarized_data = %d, \"\n \t     \"grp_partial_lhs = %d, grp_to_be_replaced = %d, \"\n \t     \"grp_maybe_modified = %d, \"\n \t     \"grp_not_necessarilly_dereferenced = %d\\n\",\n-\t     access->total_scalarization, access->grp_read, access->grp_write,\n-\t     access->grp_assignment_read, access->grp_assignment_write,\n-\t     access->grp_scalar_read, access->grp_scalar_write,\n+\t     access->grp_read, access->grp_write, access->grp_assignment_read,\n+\t     access->grp_assignment_write, access->grp_scalar_read,\n+\t     access->grp_scalar_write, access->grp_total_scalarization,\n \t     access->grp_hint, access->grp_covered,\n \t     access->grp_unscalarizable_region, access->grp_unscalarized_data,\n \t     access->grp_partial_lhs, access->grp_to_be_replaced,\n \t     access->grp_maybe_modified,\n \t     access->grp_not_necessarilly_dereferenced);\n   else\n-    fprintf (f, \", write = %d, total_scalarization = %d, \"\n+    fprintf (f, \", write = %d, grp_total_scalarization = %d, \"\n \t     \"grp_partial_lhs = %d\\n\",\n-\t     access->write, access->total_scalarization,\n+\t     access->write, access->grp_total_scalarization,\n \t     access->grp_partial_lhs);\n }\n \n@@ -924,14 +924,31 @@ completely_scalarize_record (tree base, tree decl, HOST_WIDE_INT offset,\n \t    access = create_access_1 (base, pos, size);\n \t    access->expr = nref;\n \t    access->type = ft;\n-\t    access->total_scalarization = 1;\n+\t    access->grp_total_scalarization = 1;\n \t    /* Accesses for intraprocedural SRA can have their stmt NULL.  */\n \t  }\n \telse\n \t  completely_scalarize_record (base, fld, pos, nref);\n       }\n }\n \n+/* Create total_scalarization accesses for all scalar type fields in VAR and\n+   for VAR a a whole.  VAR must be of a RECORD_TYPE conforming to\n+   type_consists_of_records_p.   */\n+\n+static void\n+completely_scalarize_var (tree var)\n+{\n+  HOST_WIDE_INT size = tree_low_cst (DECL_SIZE (var), 1);\n+  struct access *access;\n+\n+  access = create_access_1 (var, 0, size);\n+  access->expr = var;\n+  access->type = TREE_TYPE (var);\n+  access->grp_total_scalarization = 1;\n+\n+  completely_scalarize_record (var, var, 0, var);\n+}\n \n /* Search the given tree for a declaration by skipping handled components and\n    exclude it from the candidates.  */\n@@ -1714,7 +1731,7 @@ sort_and_splice_var_accesses (tree var)\n       bool grp_assignment_read = access->grp_assignment_read;\n       bool grp_assignment_write = access->grp_assignment_write;\n       bool multiple_scalar_reads = false;\n-      bool total_scalarization = access->total_scalarization;\n+      bool total_scalarization = access->grp_total_scalarization;\n       bool grp_partial_lhs = access->grp_partial_lhs;\n       bool first_scalar = is_gimple_reg_type (access->type);\n       bool unscalarizable_region = access->grp_unscalarizable_region;\n@@ -1758,7 +1775,7 @@ sort_and_splice_var_accesses (tree var)\n \t  grp_assignment_write |= ac2->grp_assignment_write;\n \t  grp_partial_lhs |= ac2->grp_partial_lhs;\n \t  unscalarizable_region |= ac2->grp_unscalarizable_region;\n-\t  total_scalarization |= ac2->total_scalarization;\n+\t  total_scalarization |= ac2->grp_total_scalarization;\n \t  relink_to_new_repr (access, ac2);\n \n \t  /* If there are both aggregate-type and scalar-type accesses with\n@@ -1779,6 +1796,7 @@ sort_and_splice_var_accesses (tree var)\n       access->grp_assignment_read = grp_assignment_read;\n       access->grp_assignment_write = grp_assignment_write;\n       access->grp_hint = multiple_scalar_reads || total_scalarization;\n+      access->grp_total_scalarization = total_scalarization;\n       access->grp_partial_lhs = grp_partial_lhs;\n       access->grp_unscalarizable_region = unscalarizable_region;\n       if (access->first_link)\n@@ -2024,6 +2042,8 @@ analyze_access_subtree (struct access *root, struct access *parent,\n \troot->grp_write = 1;\n       if (parent->grp_assignment_write)\n \troot->grp_assignment_write = 1;\n+      if (parent->grp_total_scalarization)\n+\troot->grp_total_scalarization = 1;\n     }\n \n   if (root->grp_unscalarizable_region)\n@@ -2034,16 +2054,16 @@ analyze_access_subtree (struct access *root, struct access *parent,\n \n   for (child = root->first_child; child; child = child->next_sibling)\n     {\n-      if (!hole && child->offset < covered_to)\n-\thole = true;\n-      else\n-\tcovered_to += child->size;\n-\n+      hole |= covered_to < child->offset;\n       sth_created |= analyze_access_subtree (child, root,\n \t\t\t\t\t     allow_replacements && !scalar);\n \n       root->grp_unscalarized_data |= child->grp_unscalarized_data;\n-      hole |= !child->grp_covered;\n+      root->grp_total_scalarization &= child->grp_total_scalarization;\n+      if (child->grp_covered)\n+\tcovered_to += child->size;\n+      else\n+\thole = true;\n     }\n \n   if (allow_replacements && scalar && !root->first_child\n@@ -2064,10 +2084,16 @@ analyze_access_subtree (struct access *root, struct access *parent,\n       sth_created = true;\n       hole = false;\n     }\n-  else if (covered_to < limit)\n-    hole = true;\n+  else\n+    {\n+      if (covered_to < limit)\n+\thole = true;\n+      if (scalar)\n+\troot->grp_total_scalarization = 0;\n+    }\n \n-  if (sth_created && !hole)\n+  if (sth_created\n+      && (!hole || root->grp_total_scalarization))\n     {\n       root->grp_covered = 1;\n       return true;\n@@ -2289,7 +2315,7 @@ analyze_all_variable_accesses (void)\n \t\t<= max_total_scalarization_size)\n \t    && type_consists_of_records_p (TREE_TYPE (var)))\n \t  {\n-\t    completely_scalarize_record (var, var, 0, var);\n+\t    completely_scalarize_var (var);\n \t    if (dump_file && (dump_flags & TDF_DETAILS))\n \t      {\n \t\tfprintf (dump_file, \"Will attempt to totally scalarize \");"}]}