{"sha": "20df0482b5ef474e00bdae865e6daf33b6fc6266", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjBkZjA0ODJiNWVmNDc0ZTAwYmRhZTg2NWU2ZGFmMzNiNmZjNjI2Ng==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "1997-03-25T22:03:18Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "1997-03-25T22:03:18Z"}, "message": "Add %include, %include_noerr, %rename support to specs\n\nFrom-SVN: r13803", "tree": {"sha": "409f91918e72c5bc1386f20febe92012e2bb6aae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/409f91918e72c5bc1386f20febe92012e2bb6aae"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/20df0482b5ef474e00bdae865e6daf33b6fc6266", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/20df0482b5ef474e00bdae865e6daf33b6fc6266", "html_url": "https://github.com/Rust-GCC/gccrs/commit/20df0482b5ef474e00bdae865e6daf33b6fc6266", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/20df0482b5ef474e00bdae865e6daf33b6fc6266/comments", "author": null, "committer": null, "parents": [{"sha": "ae998c9a69a3cfa88fe8157eb72db36036a7a7b2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ae998c9a69a3cfa88fe8157eb72db36036a7a7b2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ae998c9a69a3cfa88fe8157eb72db36036a7a7b2"}], "stats": {"total": 390, "additions": 266, "deletions": 124}, "files": [{"sha": "8e50517f1233853e99a37a7b110da0a52bbbaa14", "filename": "gcc/gcc.c", "status": "modified", "additions": 266, "deletions": 124, "changes": 390, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20df0482b5ef474e00bdae865e6daf33b6fc6266/gcc%2Fgcc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20df0482b5ef474e00bdae865e6daf33b6fc6266/gcc%2Fgcc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcc.c?ref=20df0482b5ef474e00bdae865e6daf33b6fc6266", "patch": "@@ -231,7 +231,8 @@ extern char *version_string;\n /* Forward declaration for prototypes.  */\n struct path_prefix;\n \n-static void init_spec\t\tPROTO(());\n+static void init_spec\t\tPROTO((void));\n+static void read_specs\t\tPROTO((char *, int));\n static void set_spec\t\tPROTO((char *, char *));\n static struct compiler *lookup_compiler PROTO((char *, int, char *));\n static char *build_search_list\tPROTO((struct path_prefix *, char *, int));\n@@ -1026,126 +1027,6 @@ my_strerror(e)\n #endif\n }\n \f\n-/* Read compilation specs from a file named FILENAME,\n-   replacing the default ones.\n-\n-   A suffix which starts with `*' is a definition for\n-   one of the machine-specific sub-specs.  The \"suffix\" should be\n-   *asm, *cc1, *cpp, *link, *startfile, *signed_char, etc.\n-   The corresponding spec is stored in asm_spec, etc.,\n-   rather than in the `compilers' vector.\n-\n-   Anything invalid in the file is a fatal error.  */\n-\n-static void\n-read_specs (filename)\n-     char *filename;\n-{\n-  int desc;\n-  int readlen;\n-  struct stat statbuf;\n-  char *buffer;\n-  register char *p;\n-\n-  if (verbose_flag)\n-    fprintf (stderr, \"Reading specs from %s\\n\", filename);\n-\n-  /* Open and stat the file.  */\n-  desc = open (filename, O_RDONLY, 0);\n-  if (desc < 0)\n-    pfatal_with_name (filename);\n-  if (stat (filename, &statbuf) < 0)\n-    pfatal_with_name (filename);\n-\n-  /* Read contents of file into BUFFER.  */\n-  buffer = xmalloc ((unsigned) statbuf.st_size + 1);\n-  readlen = read (desc, buffer, (unsigned) statbuf.st_size);\n-  if (readlen < 0)\n-    pfatal_with_name (filename);\n-  buffer[readlen] = 0;\n-  close (desc);\n-\n-  /* Scan BUFFER for specs, putting them in the vector.  */\n-  p = buffer;\n-  while (1)\n-    {\n-      char *suffix;\n-      char *spec;\n-      char *in, *out, *p1, *p2;\n-\n-      /* Advance P in BUFFER to the next nonblank nocomment line.  */\n-      p = skip_whitespace (p);\n-      if (*p == 0)\n-\tbreak;\n-\n-      /* Find the colon that should end the suffix.  */\n-      p1 = p;\n-      while (*p1 && *p1 != ':' && *p1 != '\\n') p1++;\n-      /* The colon shouldn't be missing.  */\n-      if (*p1 != ':')\n-\tfatal (\"specs file malformed after %d characters\", p1 - buffer);\n-      /* Skip back over trailing whitespace.  */\n-      p2 = p1;\n-      while (p2 > buffer && (p2[-1] == ' ' || p2[-1] == '\\t')) p2--;\n-      /* Copy the suffix to a string.  */\n-      suffix = save_string (p, p2 - p);\n-      /* Find the next line.  */\n-      p = skip_whitespace (p1 + 1);\n-      if (p[1] == 0)\n-\tfatal (\"specs file malformed after %d characters\", p - buffer);\n-      p1 = p;\n-      /* Find next blank line.  */\n-      while (*p1 && !(*p1 == '\\n' && p1[1] == '\\n')) p1++;\n-      /* Specs end at the blank line and do not include the newline.  */\n-      spec = save_string (p, p1 - p);\n-      p = p1;\n-\n-      /* Delete backslash-newline sequences from the spec.  */\n-      in = spec;\n-      out = spec;\n-      while (*in != 0)\n-\t{\n-\t  if (in[0] == '\\\\' && in[1] == '\\n')\n-\t    in += 2;\n-\t  else if (in[0] == '#')\n-\t    {\n-\t      while (*in && *in != '\\n') in++;\n-\t    }\n-\t  else\n-\t    *out++ = *in++;\n-\t}\n-      *out = 0;\n-\n-      if (suffix[0] == '*')\n-\t{\n-\t  if (! strcmp (suffix, \"*link_command\"))\n-\t    link_command_spec = spec;\n-\t  else\n-\t    set_spec (suffix + 1, spec);\n-\t}\n-      else\n-\t{\n-\t  /* Add this pair to the vector.  */\n-\t  compilers\n-\t    = ((struct compiler *)\n-\t       xrealloc (compilers, (n_compilers + 2) * sizeof (struct compiler)));\n-\t  compilers[n_compilers].suffix = suffix;\n-\t  bzero ((char *) compilers[n_compilers].spec,\n-\t\t sizeof compilers[n_compilers].spec);\n-\t  compilers[n_compilers].spec[0] = spec;\n-\t  n_compilers++;\n-\t  bzero ((char *) &compilers[n_compilers],\n-\t\t sizeof compilers[n_compilers]);\n-\t}\n-\n-      if (*suffix == 0)\n-\tlink_command_spec = spec;\n-    }\n-\n-  if (link_command_spec == 0)\n-    fatal (\"spec file has no spec for linking\");\n-}\n-\n static char *\n skip_whitespace (p)\n      char *p;\n@@ -1236,6 +1117,9 @@ init_spec ()\n   if (specs)\n     return;\t\t\t/* already initialized */\n \n+  if (verbose_flag)\n+    fprintf (stderr, \"Using builtin specs.\\n\");\n+\n #ifdef EXTRA_SPECS\n   for (i = (sizeof (extra_specs) / sizeof (extra_specs[0])) - 1; i >= 0; i--)\n     {\n@@ -1272,6 +1156,19 @@ set_spec (name, spec)\n   int name_len = strlen (name);\n   int i;\n \n+  /* If this is the first call, initialize the statically allocated specs */\n+  if (!specs)\n+    {\n+      struct spec_list *next = (struct spec_list *)0;\n+      for (i = (sizeof (static_specs) / sizeof (static_specs[0])) - 1; i >= 0; i--)\n+\t{\n+\t  sl = &static_specs[i];\n+\t  sl->next = next;\n+\t  next = sl;\n+\t}\n+      specs = sl;\n+    }\n+\n   /* See if the spec already exists */\n   for (sl = specs; sl; sl = sl->next)\n     if (name_len == sl->name_len && !strcmp (sl->name, name))\n@@ -1295,6 +1192,11 @@ set_spec (name, spec)\n \t\t     ? concat (old_spec, spec + 1, NULL_PTR)\n \t\t     : save_string (spec, strlen (spec)));\n \n+#ifdef DEBUG_SPECS\n+  if (verbose_flag)\n+    fprintf (stderr, \"Setting spec %s to '%s'\\n\\n\", name, *(sl->ptr_spec));\n+#endif\n+\n   /* Free the old spec */\n   if (old_spec && sl->alloc_p)\n     free (old_spec);\n@@ -1459,6 +1361,241 @@ store_arg (arg, delete_always, delete_failure)\n     record_temp_file (arg, delete_always, delete_failure);\n }\n \f\n+/* Read compilation specs from a file named FILENAME,\n+   replacing the default ones.\n+\n+   A suffix which starts with `*' is a definition for\n+   one of the machine-specific sub-specs.  The \"suffix\" should be\n+   *asm, *cc1, *cpp, *link, *startfile, *signed_char, etc.\n+   The corresponding spec is stored in asm_spec, etc.,\n+   rather than in the `compilers' vector.\n+\n+   Anything invalid in the file is a fatal error.  */\n+\n+static void\n+read_specs (filename, main_p)\n+     char *filename;\n+     int main_p;\n+{\n+  int desc;\n+  int readlen;\n+  struct stat statbuf;\n+  char *buffer;\n+  register char *p;\n+\n+  if (verbose_flag)\n+    fprintf (stderr, \"Reading specs from %s\\n\", filename);\n+\n+  /* Open and stat the file.  */\n+  desc = open (filename, O_RDONLY, 0);\n+  if (desc < 0)\n+    pfatal_with_name (filename);\n+  if (stat (filename, &statbuf) < 0)\n+    pfatal_with_name (filename);\n+\n+  /* Read contents of file into BUFFER.  */\n+  buffer = xmalloc ((unsigned) statbuf.st_size + 1);\n+  readlen = read (desc, buffer, (unsigned) statbuf.st_size);\n+  if (readlen < 0)\n+    pfatal_with_name (filename);\n+  buffer[readlen] = 0;\n+  close (desc);\n+\n+  /* Scan BUFFER for specs, putting them in the vector.  */\n+  p = buffer;\n+  while (1)\n+    {\n+      char *suffix;\n+      char *spec;\n+      char *in, *out, *p1, *p2, *p3;\n+\n+      /* Advance P in BUFFER to the next nonblank nocomment line.  */\n+      p = skip_whitespace (p);\n+      if (*p == 0)\n+\tbreak;\n+\n+      /* Is this a special command that starts with '%'? */\n+      /* Don't allow this for the main specs file, since it would\n+\t encourage people to overwrite it.  */\n+      if (*p == '%' && !main_p)\n+\t{\n+\t  p1 = p;\n+\t  while (*p && *p != '\\n') p++;\n+\t  p++;\t\t\t/* skip \\n */\n+\n+\t  if (!strncmp (p1, \"%include\", sizeof (\"%include\")-1)\n+\t      && (p1[ sizeof (\"%include\")-1 ] == ' '\n+\t\t  || p1[ sizeof (\"%include\")-1 ] == '\\t'))\n+\t    {\n+\t      char *new_filename;\n+\n+\t      p1 += sizeof (\"%include\");\n+\t      while (*p1 == ' ' || *p1 == '\\t') p1++;\n+\n+\t      if (*p1++ != '<' || p[-2] != '>')\n+\t\tfatal (\"specs %%include syntax malformed after %d characters\",\n+\t\t       p1 - buffer + 1);\n+\n+\t      p[-2] = '\\0';\n+\t      new_filename = find_a_file (&startfile_prefixes, p1, R_OK);\n+\t      read_specs (new_filename ? new_filename : p1, FALSE);\n+\t      continue;\n+\t    }\n+\t  else if (!strncmp (p1, \"%include_noerr\", sizeof (\"%include_noerr\")-1)\n+\t      && (p1[ sizeof (\"%include_noerr\")-1 ] == ' '\n+\t\t  || p1[ sizeof (\"%include_noerr\")-1 ] == '\\t'))\n+\t    {\n+\t      char *new_filename;\n+\n+\t      p1 += sizeof (\"%include_noerr\");\n+\t      while (*p1 == ' ' || *p1 == '\\t') p1++;\n+\n+\t      if (*p1++ != '<' || p[-2] != '>')\n+\t\tfatal (\"specs %%include syntax malformed after %d characters\",\n+\t\t       p1 - buffer + 1);\n+\n+\t      p[-2] = '\\0';\n+\t      new_filename = find_a_file (&startfile_prefixes, p1, R_OK);\n+\t      if (new_filename)\n+\t\tread_specs (new_filename, FALSE);\n+\t      else if (verbose_flag)\n+\t\tfprintf (stderr, \"Could not find specs file %s\\n\", p1);\n+\t      continue;\n+\t    }\n+\t  else if (!strncmp (p1, \"%rename\", sizeof (\"%rename\")-1)\n+\t\t   && (p1[ sizeof (\"%rename\")-1 ] == ' '\n+\t\t       || p1[ sizeof (\"%rename\")-1 ] == '\\t'))\n+\t    {\n+\t      int name_len;\n+\t      struct spec_list *sl;\n+\n+\t      /* Get original name */\n+\t      p1 += sizeof (\"%rename\");\n+\t      while (*p1 == ' ' || *p1 == '\\t') p1++;\n+\t      if (!isalpha (*p1))\n+\t\tfatal (\"specs %%rename syntax malformed after %d characters\",\n+\t\t       p1 - buffer);\n+\n+\t      p2 = p1;\n+\t      while (*p2 && !isspace (*p2)) p2++;\n+\t      if (*p2 != ' ' && *p2 != '\\t')\n+\t\tfatal (\"specs %%rename syntax malformed after %d characters\",\n+\t\t       p2 - buffer);\n+\n+\t      name_len = p2 - p1;\n+\t      *p2++ = '\\0';\n+\t      while (*p2 == ' ' || *p2 == '\\t') p2++;\n+\t      if (!isalpha (*p2))\n+\t\tfatal (\"specs %%rename syntax malformed after %d characters\",\n+\t\t       p2 - buffer);\n+\n+\t      /* Get new spec name */\n+\t      p3 = p2;\n+\t      while (*p3 && !isspace (*p3)) p3++;\n+\t      if (p3 != p-1)\n+\t\tfatal (\"specs %%rename syntax malformed after %d characters\",\n+\t\t       p3 - buffer);\n+\t      *p3 = '\\0';\n+\n+\t      for (sl = specs; sl; sl = sl->next)\n+\t\tif (name_len == sl->name_len && !strcmp (sl->name, p1))\n+\t\t  break;\n+\n+\t      if (!sl)\n+\t\tfatal (\"specs %s spec was not found to be renamed\", p1);\n+\n+\t      if (!strcmp (p1, p2))\n+\t\tcontinue;\n+\n+\t      if (verbose_flag)\n+\t\t{\n+\t\t  fprintf (stderr, \"rename spec %s to %s\\n\", p1, p2);\n+#ifdef DEBUG_SPECS\n+\t\t  fprintf (stderr, \"spec is '%s'\\n\\n\", *(sl->ptr_spec));\n+#endif\n+\t\t}\n+\n+\t      set_spec (p2, *(sl->ptr_spec));\n+\t      if (sl->alloc_p)\n+\t\tfree (*(sl->ptr_spec));\n+\n+\t      *(sl->ptr_spec) = \"\";\n+\t      sl->alloc_p = 0;\n+\t      continue;\n+\t    }\n+\t  else\n+\t    fatal (\"specs unknown %% command after %d characters\",\n+\t\t   p1 - buffer);\n+\t}\n+\n+      /* Find the colon that should end the suffix.  */\n+      p1 = p;\n+      while (*p1 && *p1 != ':' && *p1 != '\\n') p1++;\n+      /* The colon shouldn't be missing.  */\n+      if (*p1 != ':')\n+\tfatal (\"specs file malformed after %d characters\", p1 - buffer);\n+      /* Skip back over trailing whitespace.  */\n+      p2 = p1;\n+      while (p2 > buffer && (p2[-1] == ' ' || p2[-1] == '\\t')) p2--;\n+      /* Copy the suffix to a string.  */\n+      suffix = save_string (p, p2 - p);\n+      /* Find the next line.  */\n+      p = skip_whitespace (p1 + 1);\n+      if (p[1] == 0)\n+\tfatal (\"specs file malformed after %d characters\", p - buffer);\n+      p1 = p;\n+      /* Find next blank line.  */\n+      while (*p1 && !(*p1 == '\\n' && p1[1] == '\\n')) p1++;\n+      /* Specs end at the blank line and do not include the newline.  */\n+      spec = save_string (p, p1 - p);\n+      p = p1;\n+\n+      /* Delete backslash-newline sequences from the spec.  */\n+      in = spec;\n+      out = spec;\n+      while (*in != 0)\n+\t{\n+\t  if (in[0] == '\\\\' && in[1] == '\\n')\n+\t    in += 2;\n+\t  else if (in[0] == '#')\n+\t    {\n+\t      while (*in && *in != '\\n') in++;\n+\t    }\n+\t  else\n+\t    *out++ = *in++;\n+\t}\n+      *out = 0;\n+\n+      if (suffix[0] == '*')\n+\t{\n+\t  if (! strcmp (suffix, \"*link_command\"))\n+\t    link_command_spec = spec;\n+\t  else\n+\t    set_spec (suffix + 1, spec);\n+\t}\n+      else\n+\t{\n+\t  /* Add this pair to the vector.  */\n+\t  compilers\n+\t    = ((struct compiler *)\n+\t       xrealloc (compilers, (n_compilers + 2) * sizeof (struct compiler)));\n+\t  compilers[n_compilers].suffix = suffix;\n+\t  bzero ((char *) compilers[n_compilers].spec,\n+\t\t sizeof compilers[n_compilers].spec);\n+\t  compilers[n_compilers].spec[0] = spec;\n+\t  n_compilers++;\n+\t  bzero ((char *) &compilers[n_compilers],\n+\t\t sizeof compilers[n_compilers]);\n+\t}\n+\n+      if (*suffix == 0)\n+\tlink_command_spec = spec;\n+    }\n+\n+  if (link_command_spec == 0)\n+    fatal (\"spec file has no spec for linking\");\n+}\n+\f\n /* Record the names of temporary files we tell compilers to write,\n    and delete them at the end of the run.  */\n \n@@ -3615,6 +3752,10 @@ do_spec_1 (spec, inswitch, soft_matched_part)\n \t\tif (sl->name_len == len && !strncmp (sl->name, name, len))\n \t\t  {\n \t\t    name = *(sl->ptr_spec);\n+#ifdef DEBUG_SPECS\n+\t\t    fprintf (stderr, \"Processing spec %c%s%c, which is '%s'\\n\",\n+\t\t\t     c, sl->name, (c == '(') ? ')' : ']', name);\n+#endif\n \t\t    break;\n \t\t  }\n \n@@ -4238,18 +4379,19 @@ main (argc, argv)\n \t\t\t   spec_version, dir_separator_str, NULL_PTR);\n   just_machine_suffix = concat (spec_machine, dir_separator_str, NULL_PTR);\n \n-  init_spec ();\n   specs_file = find_a_file (&startfile_prefixes, \"specs\", R_OK);\n   /* Read the specs file unless it is a default one.  */\n   if (specs_file != 0 && strcmp (specs_file, \"specs\"))\n-    read_specs (specs_file);\n+    read_specs (specs_file, TRUE);\n+  else\n+    init_spec ();\n \n   /* Process any user specified specs in the order given on the command\n      line.  */\n   for (uptr = user_specs_head; uptr; uptr = uptr->next)\n     {\n       char *filename = find_a_file (&startfile_prefixes, uptr->filename, R_OK);\n-      read_specs (filename ? filename : uptr->filename);\n+      read_specs (filename ? filename : uptr->filename, FALSE);\n     }\n \n   /* If not cross-compiling, look for startfiles in the standard places.  */"}]}