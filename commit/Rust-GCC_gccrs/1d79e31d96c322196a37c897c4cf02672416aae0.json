{"sha": "1d79e31d96c322196a37c897c4cf02672416aae0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWQ3OWUzMWQ5NmMzMjIxOTZhMzdjODk3YzRjZjAyNjcyNDE2YWFlMA==", "commit": {"author": {"name": "Kai Tietz", "email": "ktietz@gcc.gnu.org", "date": "2008-07-04T12:38:46Z"}, "committer": {"name": "Kai Tietz", "email": "ktietz@gcc.gnu.org", "date": "2008-07-04T12:38:46Z"}, "message": "Revert 137452.\n\nFrom-SVN: r137457", "tree": {"sha": "0e9e7ec0b2245baf28771eddb44c22187087a92f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0e9e7ec0b2245baf28771eddb44c22187087a92f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1d79e31d96c322196a37c897c4cf02672416aae0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1d79e31d96c322196a37c897c4cf02672416aae0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1d79e31d96c322196a37c897c4cf02672416aae0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1d79e31d96c322196a37c897c4cf02672416aae0/comments", "author": null, "committer": null, "parents": [{"sha": "48325d73d3745ac658a623db37f661adab495d0e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/48325d73d3745ac658a623db37f661adab495d0e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/48325d73d3745ac658a623db37f661adab495d0e"}], "stats": {"total": 476, "additions": 65, "deletions": 411}, "files": [{"sha": "731955b5699f38e9e1dd87a6c5671dd3eebfee5f", "filename": "gcc/builtins.c", "status": "modified", "additions": 34, "deletions": 58, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d79e31d96c322196a37c897c4cf02672416aae0/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d79e31d96c322196a37c897c4cf02672416aae0/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=1d79e31d96c322196a37c897c4cf02672416aae0", "patch": "@@ -4623,19 +4623,18 @@ expand_builtin_next_arg (void)\n static tree\n stabilize_va_list (tree valist, int needs_lvalue)\n {\n-  tree vatype = targetm.canonical_va_list_type (TREE_TYPE (valist));\n-  if (vatype !=NULL && TREE_CODE (vatype) == ARRAY_TYPE)\n+  if (TREE_CODE (va_list_type_node) == ARRAY_TYPE)\n     {\n       if (TREE_SIDE_EFFECTS (valist))\n \tvalist = save_expr (valist);\n \n       /* For this case, the backends will be expecting a pointer to\n-\t vatype, but it's possible we've actually been given an array\n-\t (an actual TARGET_CANONICAL_VA_LIST_TYPE (valist)).\n+\t TREE_TYPE (va_list_type_node), but it's possible we've\n+\t actually been given an array (an actual va_list_type_node).\n \t So fix it.  */\n       if (TREE_CODE (TREE_TYPE (valist)) == ARRAY_TYPE)\n \t{\n-\t  tree p1 = build_pointer_type (TREE_TYPE (vatype));\n+\t  tree p1 = build_pointer_type (TREE_TYPE (va_list_type_node));\n \t  valist = build_fold_addr_expr_with_type (valist, p1);\n \t}\n     }\n@@ -4648,7 +4647,7 @@ stabilize_va_list (tree valist, int needs_lvalue)\n \t  if (! TREE_SIDE_EFFECTS (valist))\n \t    return valist;\n \n-\t  pt = build_pointer_type (vatype);\n+\t  pt = build_pointer_type (va_list_type_node);\n \t  valist = fold_build1 (ADDR_EXPR, pt, valist);\n \t  TREE_SIDE_EFFECTS (valist) = 1;\n \t}\n@@ -4669,42 +4668,6 @@ std_build_builtin_va_list (void)\n   return ptr_type_node;\n }\n \n-/* The \"standard\" abi va_list is va_list_type_node.  */\n-\n-tree\n-std_fn_abi_va_list (tree fndecl ATTRIBUTE_UNUSED)\n-{\n-  return va_list_type_node;\n-}\n-\n-/* The \"standard\" type of va_list is va_list_type_node.  */\n-\n-tree\n-std_canonical_va_list_type (tree type)\n-{\n-  tree wtype, htype;\n-\n-  wtype = va_list_type_node;\n-  htype = type;\n-  if (TREE_CODE (wtype) == ARRAY_TYPE)\n-    {\n-      /* If va_list is an array type, the argument may have decayed\n-\t to a pointer type, e.g. by being passed to another function.\n-\t In that case, unwrap both types so that we can compare the\n-\t underlying records.  */\n-      if (TREE_CODE (htype) == ARRAY_TYPE\n-\t  || POINTER_TYPE_P (htype))\n-\t{\n-\t  wtype = TREE_TYPE (wtype);\n-\t  htype = TREE_TYPE (htype);\n-\t}\n-    }\n-  if (TYPE_MAIN_VARIANT (wtype) == TYPE_MAIN_VARIANT (htype))\n-    return va_list_type_node;\n-\n-  return NULL_TREE;\n-}\n-\n /* The \"standard\" implementation of va_start: just assign `nextarg' to\n    the variable.  */\n \n@@ -4860,26 +4823,41 @@ dummy_object (tree type)\n enum gimplify_status\n gimplify_va_arg_expr (tree *expr_p, tree *pre_p, tree *post_p)\n {\n-  tree promoted_type, have_va_type;\n+  tree promoted_type, want_va_type, have_va_type;\n   tree valist = TREE_OPERAND (*expr_p, 0);\n   tree type = TREE_TYPE (*expr_p);\n   tree t;\n \n   /* Verify that valist is of the proper type.  */\n+  want_va_type = va_list_type_node;\n   have_va_type = TREE_TYPE (valist);\n+\n   if (have_va_type == error_mark_node)\n     return GS_ERROR;\n-  have_va_type = targetm.canonical_va_list_type (have_va_type);\n \n-  if (have_va_type == NULL_TREE)\n+  if (TREE_CODE (want_va_type) == ARRAY_TYPE)\n+    {\n+      /* If va_list is an array type, the argument may have decayed\n+\t to a pointer type, e.g. by being passed to another function.\n+\t In that case, unwrap both types so that we can compare the\n+\t underlying records.  */\n+      if (TREE_CODE (have_va_type) == ARRAY_TYPE\n+\t  || POINTER_TYPE_P (have_va_type))\n+\t{\n+\t  want_va_type = TREE_TYPE (want_va_type);\n+\t  have_va_type = TREE_TYPE (have_va_type);\n+\t}\n+    }\n+\n+  if (TYPE_MAIN_VARIANT (want_va_type) != TYPE_MAIN_VARIANT (have_va_type))\n     {\n       error (\"first argument to %<va_arg%> not of type %<va_list%>\");\n       return GS_ERROR;\n     }\n \n   /* Generate a diagnostic for requesting data of a type that cannot\n      be passed through `...' due to type promotion at the call site.  */\n-  if ((promoted_type = lang_hooks.types.type_promotes_to (type))\n+  else if ((promoted_type = lang_hooks.types.type_promotes_to (type))\n \t   != type)\n     {\n       static bool gave_help;\n@@ -4911,15 +4889,15 @@ gimplify_va_arg_expr (tree *expr_p, tree *pre_p, tree *post_p)\n     {\n       /* Make it easier for the backends by protecting the valist argument\n \t from multiple evaluations.  */\n-      if (TREE_CODE (have_va_type) == ARRAY_TYPE)\n+      if (TREE_CODE (va_list_type_node) == ARRAY_TYPE)\n \t{\n \t  /* For this case, the backends will be expecting a pointer to\n-\t     TREE_TYPE (abi), but it's possible we've\n-\t     actually been given an array (an actual TARGET_FN_ABI_VA_LIST).\n+\t     TREE_TYPE (va_list_type_node), but it's possible we've\n+\t     actually been given an array (an actual va_list_type_node).\n \t     So fix it.  */\n \t  if (TREE_CODE (TREE_TYPE (valist)) == ARRAY_TYPE)\n \t    {\n-\t      tree p1 = build_pointer_type (TREE_TYPE (have_va_type));\n+\t      tree p1 = build_pointer_type (TREE_TYPE (va_list_type_node));\n \t      valist = build_fold_addr_expr_with_type (valist, p1);\n \t    }\n \t  gimplify_expr (&valist, pre_p, post_p, is_gimple_val, fb_rvalue);\n@@ -4967,11 +4945,9 @@ expand_builtin_va_copy (tree exp)\n   dst = stabilize_va_list (dst, 1);\n   src = stabilize_va_list (src, 0);\n \n-  gcc_assert (cfun != NULL && cfun->decl != NULL_TREE);\n-\n-  if (TREE_CODE (targetm.fn_abi_va_list (cfun->decl)) != ARRAY_TYPE)\n+  if (TREE_CODE (va_list_type_node) != ARRAY_TYPE)\n     {\n-      t = build2 (MODIFY_EXPR, targetm.fn_abi_va_list (cfun->decl), dst, src);\n+      t = build2 (MODIFY_EXPR, va_list_type_node, dst, src);\n       TREE_SIDE_EFFECTS (t) = 1;\n       expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n     }\n@@ -4982,19 +4958,19 @@ expand_builtin_va_copy (tree exp)\n       /* Evaluate to pointers.  */\n       dstb = expand_expr (dst, NULL_RTX, Pmode, EXPAND_NORMAL);\n       srcb = expand_expr (src, NULL_RTX, Pmode, EXPAND_NORMAL);\n-      size = expand_expr (TYPE_SIZE_UNIT (targetm.fn_abi_va_list (cfun->decl)),\n-      \t\t  NULL_RTX, VOIDmode, EXPAND_NORMAL);\n+      size = expand_expr (TYPE_SIZE_UNIT (va_list_type_node), NULL_RTX,\n+\t\t\t  VOIDmode, EXPAND_NORMAL);\n \n       dstb = convert_memory_address (Pmode, dstb);\n       srcb = convert_memory_address (Pmode, srcb);\n \n       /* \"Dereference\" to BLKmode memories.  */\n       dstb = gen_rtx_MEM (BLKmode, dstb);\n       set_mem_alias_set (dstb, get_alias_set (TREE_TYPE (TREE_TYPE (dst))));\n-      set_mem_align (dstb, TYPE_ALIGN (targetm.fn_abi_va_list (cfun->decl)));\n+      set_mem_align (dstb, TYPE_ALIGN (va_list_type_node));\n       srcb = gen_rtx_MEM (BLKmode, srcb);\n       set_mem_alias_set (srcb, get_alias_set (TREE_TYPE (TREE_TYPE (src))));\n-      set_mem_align (srcb, TYPE_ALIGN (targetm.fn_abi_va_list (cfun->decl)));\n+      set_mem_align (srcb, TYPE_ALIGN (va_list_type_node));\n \n       /* Copy.  */\n       emit_block_move (dstb, srcb, size, BLOCK_OP_NORMAL);"}, {"sha": "3a633843f73ae6e0de76a7e43c48c07c9005d38d", "filename": "gcc/c-common.c", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d79e31d96c322196a37c897c4cf02672416aae0/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d79e31d96c322196a37c897c4cf02672416aae0/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=1d79e31d96c322196a37c897c4cf02672416aae0", "patch": "@@ -4002,20 +4002,6 @@ c_common_nodes_and_builtins (void)\n   lang_hooks.decls.pushdecl\n     (build_decl (TYPE_DECL, get_identifier (\"__builtin_va_list\"),\n \t\t va_list_type_node));\n-#ifdef TARGET_ENUM_VA_LIST\n-  {\n-    int l;\n-    const char *pname;\n-    tree ptype;\n-    for (l = 0; TARGET_ENUM_VA_LIST (l, &pname, &ptype); ++l)\n-      {\n-\tlang_hooks.decls.pushdecl\n-\t  (build_decl (TYPE_DECL, get_identifier (pname),\n-\t  \t       ptype));\n-\n-      }\n-  }\n-#endif\n \n   if (TREE_CODE (va_list_type_node) == ARRAY_TYPE)\n     {"}, {"sha": "b29a762895c10ace22dc2cd6c188cf76e9bfcd5d", "filename": "gcc/config.gcc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d79e31d96c322196a37c897c4cf02672416aae0/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d79e31d96c322196a37c897c4cf02672416aae0/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=1d79e31d96c322196a37c897c4cf02672416aae0", "patch": "@@ -281,14 +281,14 @@ i[34567]86-*-*)\n \textra_headers=\"cpuid.h mmintrin.h mm3dnow.h xmmintrin.h emmintrin.h\n \t\t       pmmintrin.h tmmintrin.h ammintrin.h smmintrin.h\n \t\t       nmmintrin.h bmmintrin.h mmintrin-common.h\n-\t\t       wmmintrin.h cross-stdarg.h\"\n+\t\t       wmmintrin.h\"\n \t;;\n x86_64-*-*)\n \tcpu_type=i386\n \textra_headers=\"cpuid.h mmintrin.h mm3dnow.h xmmintrin.h emmintrin.h\n \t\t       pmmintrin.h tmmintrin.h ammintrin.h smmintrin.h\n \t\t       nmmintrin.h bmmintrin.h mmintrin-common.h\n-\t\t       wmmintrin.h cross-stdarg.h\"\n+\t\t       wmmintrin.h\"\n \tneed_64bit_hwint=yes\n \t;;\n ia64-*-*)"}, {"sha": "8d0772dbe8b61c944c1cadd27c4dd30116be6aac", "filename": "gcc/config/i386/i386-protos.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d79e31d96c322196a37c897c4cf02672416aae0/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d79e31d96c322196a37c897c4cf02672416aae0/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-protos.h?ref=1d79e31d96c322196a37c897c4cf02672416aae0", "patch": "@@ -141,9 +141,6 @@ extern int ix86_cfun_abi (void);\n extern int ix86_function_abi (const_tree);\n extern int ix86_function_type_abi (const_tree);\n extern void ix86_call_abi_override (const_tree);\n-extern tree ix86_fn_abi_va_list (tree);\n-extern tree ix86_canonical_va_list_type (tree);\n-extern int ix86_enum_va_list (int, const char **, tree *);\n extern int ix86_reg_parm_stack_space (const_tree);\n \n extern void ix86_split_fp_branch (enum rtx_code code, rtx, rtx,"}, {"sha": "a0edacaaaba212594e1bbd288f65f798f0f040a0", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 12, "deletions": 251, "changes": 263, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d79e31d96c322196a37c897c4cf02672416aae0/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d79e31d96c322196a37c897c4cf02672416aae0/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=1d79e31d96c322196a37c897c4cf02672416aae0", "patch": "@@ -1716,10 +1716,6 @@ unsigned int ix86_preferred_stack_boundary;\n /* Values 1-5: see jump.c */\n int ix86_branch_cost;\n \n-/* Calling abi specific va_list type nodes.  */\n-static GTY(()) tree sysv_va_list_type_node;\n-static GTY(()) tree ms_va_list_type_node;\n-\n /* Variables which are this size or smaller are put in the data/bss\n    or ldata/lbss sections.  */\n \n@@ -2778,8 +2774,9 @@ override_options (void)\n     set_param_value (\"l2-cache-size\", ix86_cost->l2_cache_size);\n \n   /* If using typedef char *va_list, signal that __builtin_va_start (&ap, 0)\n-     can be optimized to ap = __builtin_next_arg (0).  */\n-  if (!TARGET_64BIT)\n+     can be optimized to ap = __builtin_next_arg (0).\n+     For abi switching it should be corrected.  */\n+  if (!TARGET_64BIT || DEFAULT_ABI == MS_ABI)\n     targetm.expand_builtin_va_start = NULL;\n \n   if (TARGET_64BIT)\n@@ -3607,6 +3604,9 @@ ix86_function_type_abi (const_tree fntype)\n       else\n         abi = lookup_attribute (\"sysv_abi\", TYPE_ATTRIBUTES (fntype)) ? SYSV_ABI : MS_ABI;\n \n+      if (DEFAULT_ABI == MS_ABI && abi == SYSV_ABI)\n+        sorry (\"using sysv calling convention on target w64 is not supported\");\n+\n       return abi;\n     }\n   return DEFAULT_ABI;\n@@ -5174,16 +5174,13 @@ ix86_struct_value_rtx (tree type, int incoming ATTRIBUTE_UNUSED)\n \f\n /* Create the va_list data type.  */\n \n-/* Returns the calling convention specific va_list date type.\n-   The argument ABI can be DEFAULT_ABI, MS_ABI, or SYSV_ABI.  */\n-\n static tree\n-ix86_build_builtin_va_list_abi (enum calling_abi abi)\n+ix86_build_builtin_va_list (void)\n {\n   tree f_gpr, f_fpr, f_ovf, f_sav, record, type_decl;\n \n   /* For i386 we use plain pointer to argument area.  */\n-  if (!TARGET_64BIT || abi == MS_ABI)\n+  if (!TARGET_64BIT || ix86_cfun_abi () == MS_ABI)\n     return build_pointer_type (char_type_node);\n \n   record = (*lang_hooks.types.make_type) (RECORD_TYPE);\n@@ -5219,33 +5216,6 @@ ix86_build_builtin_va_list_abi (enum calling_abi abi)\n   return build_array_type (record, build_index_type (size_zero_node));\n }\n \n-/* Setup the builtin va_list data type and for 64-bit the additional\n-   calling convention specific va_list data types.  */\n-\n-static tree\n-ix86_build_builtin_va_list (void)\n-{\n-  tree ret = ix86_build_builtin_va_list_abi (DEFAULT_ABI);\n-\n-  /* Initialize abi specific va_list builtin types.  */\n-  if (TARGET_64BIT)\n-    {\n-      tree t;\n-\n-      t = ix86_build_builtin_va_list_abi (SYSV_ABI);\n-      if (TREE_CODE (t) != RECORD_TYPE)\n-        t = build_variant_type_copy (t);\n-      sysv_va_list_type_node = t;\n-\n-      t = ix86_build_builtin_va_list_abi (MS_ABI);\n-      if (TREE_CODE (t) != RECORD_TYPE)\n-        t = build_variant_type_copy (t);\n-      ms_va_list_type_node = t;\n-    }\n-\n-  return ret;\n-}\n-\n /* Worker function for TARGET_SETUP_INCOMING_VARARGS.  */\n \n static void\n@@ -5401,14 +5371,13 @@ ix86_va_start (tree valist, rtx nextarg)\n   tree type;\n \n   /* Only 64bit target needs something special.  */\n-  if (!TARGET_64BIT ||\n-      ix86_canonical_va_list_type (TREE_TYPE (valist)) == ms_va_list_type_node)\n+  if (!TARGET_64BIT || cfun->machine->call_abi == MS_ABI)\n     {\n       std_expand_builtin_va_start (valist, nextarg);\n       return;\n     }\n \n-  f_gpr = TYPE_FIELDS (TREE_TYPE (sysv_va_list_type_node));\n+  f_gpr = TYPE_FIELDS (TREE_TYPE (va_list_type_node));\n   f_fpr = TREE_CHAIN (f_gpr);\n   f_ovf = TREE_CHAIN (f_fpr);\n   f_sav = TREE_CHAIN (f_ovf);\n@@ -5481,11 +5450,10 @@ ix86_gimplify_va_arg (tree valist, tree type, tree *pre_p, tree *post_p)\n   enum machine_mode nat_mode;\n \n   /* Only 64bit target needs something special.  */\n-  if (!TARGET_64BIT ||\n-      ix86_canonical_va_list_type (TREE_TYPE (valist)) == ms_va_list_type_node)\n+  if (!TARGET_64BIT || cfun->machine->call_abi == MS_ABI)\n     return std_gimplify_va_arg_expr (valist, type, pre_p, post_p);\n \n-  f_gpr = TYPE_FIELDS (TREE_TYPE (sysv_va_list_type_node));\n+  f_gpr = TYPE_FIELDS (TREE_TYPE (va_list_type_node));\n   f_fpr = TREE_CHAIN (f_gpr);\n   f_ovf = TREE_CHAIN (f_fpr);\n   f_sav = TREE_CHAIN (f_ovf);\n@@ -20248,55 +20216,6 @@ ix86_init_mmx_sse_builtins (void)\n     }\n }\n \n-/* Internal method for ix86_init_builtins.  */\n-\n-static void\n-ix86_init_builtins_va_builtins_abi (void)\n-{\n-  tree ms_va_ref, sysv_va_ref;\n-  tree fnvoid_va_end_ms, fnvoid_va_end_sysv;\n-  tree fnvoid_va_start_ms, fnvoid_va_start_sysv;\n-  tree fnvoid_va_copy_ms, fnvoid_va_copy_sysv;\n-  tree fnattr_ms = NULL_TREE, fnattr_sysv = NULL_TREE;\n-\n-  if (!TARGET_64BIT)\n-    return;\n-  fnattr_ms = build_tree_list (get_identifier (\"ms_abi\"), NULL_TREE);\n-  fnattr_sysv = build_tree_list (get_identifier (\"sysv_abi\"), NULL_TREE);\n-  ms_va_ref = build_reference_type (ms_va_list_type_node);\n-  sysv_va_ref =\n-    build_pointer_type (TREE_TYPE (sysv_va_list_type_node));\n-\n-  fnvoid_va_end_ms =\n-    build_function_type_list (void_type_node, ms_va_ref, NULL_TREE);\n-  fnvoid_va_start_ms =\n-    build_varargs_function_type_list (void_type_node, ms_va_ref, NULL_TREE);\n-  fnvoid_va_end_sysv =\n-    build_function_type_list (void_type_node, sysv_va_ref, NULL_TREE);\n-  fnvoid_va_start_sysv =\n-    build_varargs_function_type_list (void_type_node, sysv_va_ref,\n-    \t\t\t\t       NULL_TREE);\n-  fnvoid_va_copy_ms =\n-    build_function_type_list (void_type_node, ms_va_list_type_node, ms_va_ref,\n-    \t\t\t      NULL_TREE);\n-  fnvoid_va_copy_sysv =\n-    build_function_type_list (void_type_node, sysv_va_list_type_node,\n-    \t\t\t      sysv_va_ref, NULL_TREE);\n-\n-  add_builtin_function (\"__builtin_ms_va_start\", fnvoid_va_start_ms,\n-  \t\t\tBUILT_IN_VA_START, BUILT_IN_NORMAL, NULL, fnattr_ms);\n-  add_builtin_function (\"__builtin_ms_va_end\", fnvoid_va_end_ms,\n-  \t\t\tBUILT_IN_VA_END, BUILT_IN_NORMAL, NULL, fnattr_ms);\n-  add_builtin_function (\"__builtin_ms_va_copy\", fnvoid_va_copy_ms,\n-\t\t\tBUILT_IN_VA_COPY, BUILT_IN_NORMAL, NULL, fnattr_ms);\n-  add_builtin_function (\"__builtin_sysv_va_start\", fnvoid_va_start_sysv,\n-  \t\t\tBUILT_IN_VA_START, BUILT_IN_NORMAL, NULL, fnattr_sysv);\n-  add_builtin_function (\"__builtin_sysv_va_end\", fnvoid_va_end_sysv,\n-  \t\t\tBUILT_IN_VA_END, BUILT_IN_NORMAL, NULL, fnattr_sysv);\n-  add_builtin_function (\"__builtin_sysv_va_copy\", fnvoid_va_copy_sysv,\n-\t\t\tBUILT_IN_VA_COPY, BUILT_IN_NORMAL, NULL, fnattr_sysv);\n-}\n-\n static void\n ix86_init_builtins (void)\n {\n@@ -20354,8 +20273,6 @@ ix86_init_builtins (void)\n \n   if (TARGET_MMX)\n     ix86_init_mmx_sse_builtins ();\n-  if (TARGET_64BIT)\n-    ix86_init_builtins_va_builtins_abi ();\n }\n \n /* Errors in the source file can cause expand_expr to return const0_rtx\n@@ -23180,54 +23097,6 @@ x86_order_regs_for_local_alloc (void)\n      reg_alloc_order [pos++] = 0;\n }\n \n-/* Handle a \"ms_abi\" or \"sysv\" attribute; arguments as in\n-   struct attribute_spec.handler.  */\n-static tree\n-ix86_handle_abi_attribute (tree *node, tree name,\n-\t\t\t      tree args ATTRIBUTE_UNUSED,\n-\t\t\t      int flags ATTRIBUTE_UNUSED, bool *no_add_attrs)\n-{\n-  if (TREE_CODE (*node) != FUNCTION_TYPE\n-      && TREE_CODE (*node) != METHOD_TYPE\n-      && TREE_CODE (*node) != FIELD_DECL\n-      && TREE_CODE (*node) != TYPE_DECL)\n-    {\n-      warning (OPT_Wattributes, \"%qs attribute only applies to functions\",\n-\t       IDENTIFIER_POINTER (name));\n-      *no_add_attrs = true;\n-      return NULL_TREE;\n-    }\n-  if (!TARGET_64BIT)\n-    {\n-      warning (OPT_Wattributes, \"%qs attribute only available for 64-bit\",\n-\t       IDENTIFIER_POINTER (name));\n-      *no_add_attrs = true;\n-      return NULL_TREE;\n-    }\n-\n-  /* Can combine regparm with all attributes but fastcall.  */\n-  if (is_attribute_p (\"ms_abi\", name))\n-    {\n-      if (lookup_attribute (\"sysv_abi\", TYPE_ATTRIBUTES (*node)))\n-        {\n-\t  error (\"ms_abi and sysv_abi attributes are not compatible\");\n-\t}\n-\n-      return NULL_TREE;\n-    }\n-  else if (is_attribute_p (\"sysv_abi\", name))\n-    {\n-      if (lookup_attribute (\"ms_abi\", TYPE_ATTRIBUTES (*node)))\n-        {\n-\t  error (\"ms_abi and sysv_abi attributes are not compatible\");\n-\t}\n-\n-      return NULL_TREE;\n-    }\n-\n-  return NULL_TREE;\n-}\n-\n /* Handle a \"ms_struct\" or \"gcc_struct\" attribute; arguments as in\n    struct attribute_spec.handler.  */\n static tree\n@@ -26037,10 +25906,6 @@ static const struct attribute_spec ix86_attribute_table[] =\n #ifdef SUBTARGET_ATTRIBUTE_TABLE\n   SUBTARGET_ATTRIBUTE_TABLE,\n #endif\n-  /* ms_abi and sysv_abi calling convention function attributes.  */\n-  { \"ms_abi\", 0, 0, false, true, true, ix86_handle_abi_attribute },\n-  { \"sysv_abi\", 0, 0, false, true, true, ix86_handle_abi_attribute },\n-  /* End element.  */\n   { NULL,        0, 0, false, false, false, NULL }\n };\n \n@@ -26068,104 +25933,6 @@ x86_builtin_vectorization_cost (bool runtime_test)\n     return 0;\n }\n \n-/* This function returns the calling abi specific va_list type node.\n-   It returns  the FNDECL specific va_list type.  */\n-\n-tree\n-ix86_fn_abi_va_list (tree fndecl)\n-{\n-  int abi;\n-\n-  if (!TARGET_64BIT)\n-    return va_list_type_node;\n-  gcc_assert (fndecl != NULL_TREE);\n-  abi = ix86_function_abi ((const_tree) fndecl);\n-\n-  if (abi == DEFAULT_ABI)\n-    return va_list_type_node;\n-  else if (abi == MS_ABI)\n-    return ms_va_list_type_node;\n-  else\n-    return sysv_va_list_type_node;\n-}\n-\n-/* Returns the canonical va_list type specified by TYPE. If there\n-   is no valid TYPE provided, it return NULL_TREE.  */\n-\n-tree\n-ix86_canonical_va_list_type (tree type)\n-{\n-  tree wtype, htype;\n-  if (TARGET_64BIT)\n-    {\n-      wtype = sysv_va_list_type_node;\n-      htype = type;\n-      if (TREE_CODE (wtype) == ARRAY_TYPE)\n-\t{\n-\t  /* If va_list is an array type, the argument may have decayed\n-\t     to a pointer type, e.g. by being passed to another function.\n-\t     In that case, unwrap both types so that we can compare the\n-\t     underlying records.  */\n-\t  if (TREE_CODE (htype) == ARRAY_TYPE\n-\t      || POINTER_TYPE_P (htype))\n-\t    {\n-\t      wtype = TREE_TYPE (wtype);\n-\t      htype = TREE_TYPE (htype);\n-\t    }\n-\t}\n-      if (TYPE_MAIN_VARIANT (wtype) == TYPE_MAIN_VARIANT (htype))\n-\treturn sysv_va_list_type_node;\n-      wtype = ms_va_list_type_node;\n-      htype = type;\n-      if (TREE_CODE (wtype) == ARRAY_TYPE)\n-\t{\n-\t  /* If va_list is an array type, the argument may have decayed\n-\t     to a pointer type, e.g. by being passed to another function.\n-\t     In that case, unwrap both types so that we can compare the\n-\t     underlying records.  */\n-\t  if (TREE_CODE (htype) == ARRAY_TYPE\n-\t      || POINTER_TYPE_P (htype))\n-\t    {\n-\t      wtype = TREE_TYPE (wtype);\n-\t      htype = TREE_TYPE (htype);\n-\t    }\n-\t}\n-      if (TYPE_MAIN_VARIANT (wtype) == TYPE_MAIN_VARIANT (htype))\n-\treturn ms_va_list_type_node;\n-\n-      return NULL_TREE;\n-    }\n-  return std_canonical_va_list_type (type);\n-}\n-\n-/* Iterate through the target-specific builtin types for va_list.\n-    IDX denotes the iterator, *PTREE is set to the result type of\n-    the va_list builtin, and *PNAME to its internal type.\n-    Returns zero if there is no element for this index, otherwise\n-    IDX should be increased upon the next call.\n-    Note, do not iterate a base builtin's name like __builtin_va_list.\n-    Used from c_common_nodes_and_builtins.  */\n-\n-int\n-ix86_enum_va_list (int idx, const char **pname, tree *ptree)\n-{\n-  if (!TARGET_64BIT)\n-    return 0;\n-  switch (idx) {\n-  case 0:\n-    *ptree = ms_va_list_type_node;\n-    *pname = \"__builtin_ms_va_list\";\n-    break;\n-  case 1:\n-    *ptree = sysv_va_list_type_node;\n-    *pname = \"__builtin_sysv_va_list\";\n-    break;\n-  default:\n-    return 0;\n-  }\n-  return 1;\n-}\n-\n /* Initialize the GCC target structure.  */\n #undef TARGET_RETURN_IN_MEMORY\n #define TARGET_RETURN_IN_MEMORY ix86_return_in_memory\n@@ -26294,12 +26061,6 @@ ix86_enum_va_list (int idx, const char **pname, tree *ptree)\n #undef TARGET_BUILD_BUILTIN_VA_LIST\n #define TARGET_BUILD_BUILTIN_VA_LIST ix86_build_builtin_va_list\n \n-#undef TARGET_FN_ABI_VA_LIST\n-#define TARGET_FN_ABI_VA_LIST ix86_fn_abi_va_list\n-\n-#undef TARGET_CANONICAL_VA_LIST_TYPE\n-#define TARGET_CANONICAL_VA_LIST_TYPE ix86_canonical_va_list_type\n-\n #undef TARGET_EXPAND_BUILTIN_VA_START\n #define TARGET_EXPAND_BUILTIN_VA_START ix86_va_start\n "}, {"sha": "b011885424a8699288499f2344625340ed070cb4", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d79e31d96c322196a37c897c4cf02672416aae0/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d79e31d96c322196a37c897c4cf02672416aae0/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=1d79e31d96c322196a37c897c4cf02672416aae0", "patch": "@@ -453,7 +453,7 @@ extern tree x86_mfence;\n #define TARGET_64BIT_MS_ABI (TARGET_64BIT && ix86_cfun_abi () == MS_ABI)\n \n /* Available call abi.  */\n-enum calling_abi\n+enum\n {\n   SYSV_ABI = 0,\n   MS_ABI = 1\n@@ -2556,11 +2556,6 @@ struct machine_function GTY(())\n #undef TARG_COND_BRANCH_COST\n #define TARG_COND_BRANCH_COST           ix86_cost->branch_cost\n \n-/* Enum through the target specific extra va_list types. Please, do not\n-   iterate the base va_list type name.  */\n-#define TARGET_ENUM_VA_LIST(IDX, PNAME, PTYPE) \\\n-  (!TARGET_64BIT ? 0 : ix86_enum_va_list (IDX, PNAME, PTYPE))\n-\n /* Cost of any scalar operation, excluding load and store.  */\n #undef TARG_SCALAR_STMT_COST\n #define TARG_SCALAR_STMT_COST           ix86_cost->scalar_stmt_cost"}, {"sha": "d4ba0e20814bb7789cdc485a83d7a966685048e6", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d79e31d96c322196a37c897c4cf02672416aae0/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d79e31d96c322196a37c897c4cf02672416aae0/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=1d79e31d96c322196a37c897c4cf02672416aae0", "patch": "@@ -4187,18 +4187,6 @@ This hook returns a type node for @code{va_list} for the target.\n The default version of the hook returns @code{void*}.\n @end deftypefn\n \n-@deftypefn {Target Hook} tree TARGET_FN_ABI_VA_LIST (tree @var{fndecl})\n-This hook returns the va_list type of the calling convention specified by\n-@var{fndecl}.\n-The default version of this hook returns @code{va_list_type_node}.\n-@end deftypefn\n-\n-@deftypefn {Target Hook} tree TARGET_CANONICAL_VA_LIST_TYPE (tree @var{type})\n-This hook returns the va_list type of the calling convention specified by the\n-type of @var{type}. If @var{type} is not a valid va_list type, it returns\n-@code{NULL_TREE}.\n-@end deftypefn\n-\n @deftypefn {Target Hook} tree TARGET_GIMPLIFY_VA_ARG_EXPR (tree @var{valist}, tree @var{type}, tree *@var{pre_p}, tree *@var{post_p})\n This hook performs target-specific gimplification of\n @code{VA_ARG_EXPR}.  The first two parameters correspond to the\n@@ -4329,20 +4317,6 @@ function use different registers for the return value, this macro\n should recognize only the caller's register numbers.\n @end defmac\n \n-@defmac TARGET_ENUM_VA_LIST (@var{idx}, @var{pname}, @var{ptype})\n-This target macro is used in function @code{c_common_nodes_and_builtins}\n-to iterate through the target specific builtin types for va_list. The\n-variable @var{idx} is used as iterator. @var{pname} has to be a pointer\n-to a @code{const char *} and @var{ptype} a pointer to a @code{tree} typed\n-variable.\n-The arguments @var{pname} and @var{ptype} are used to store the result of\n-this macro and are set to the name of the va_list builtin type and its\n-internal type.\n-If the return value of this macro is zero, then there is no more element.\n-Otherwise the @var{IDX} should be increased for the next call of this\n-macro to iterate through all types.\n-@end defmac\n-\n @defmac APPLY_RESULT_SIZE\n Define this macro if @samp{untyped_call} and @samp{untyped_return}\n need more space than is implied by @code{FUNCTION_VALUE_REGNO_P} for"}, {"sha": "beb44bd80b7d051887770e2221f9a98e06a25ee4", "filename": "gcc/expr.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d79e31d96c322196a37c897c4cf02672416aae0/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d79e31d96c322196a37c897c4cf02672416aae0/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=1d79e31d96c322196a37c897c4cf02672416aae0", "patch": "@@ -342,9 +342,6 @@ extern rtx emit_store_flag_force (rtx, enum rtx_code, rtx, rtx,\n /* Functions from builtins.c:  */\n extern rtx expand_builtin (tree, rtx, rtx, enum machine_mode, int);\n extern tree std_build_builtin_va_list (void);\n-extern tree std_fn_abi_va_list (tree);\n-extern tree std_canonical_va_list_type (tree);\n-\n extern void std_expand_builtin_va_start (tree, rtx);\n extern rtx default_expand_builtin (tree, rtx, rtx, enum machine_mode, int);\n extern void expand_builtin_setjmp_setup (rtx, rtx);"}, {"sha": "2692e94aabc970afab2979435874a76806151542", "filename": "gcc/target-def.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d79e31d96c322196a37c897c4cf02672416aae0/gcc%2Ftarget-def.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d79e31d96c322196a37c897c4cf02672416aae0/gcc%2Ftarget-def.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget-def.h?ref=1d79e31d96c322196a37c897c4cf02672416aae0", "patch": "@@ -520,8 +520,6 @@\n #define TARGET_MACHINE_DEPENDENT_REORG 0\n \n #define TARGET_BUILD_BUILTIN_VA_LIST std_build_builtin_va_list\n-#define TARGET_FN_ABI_VA_LIST std_fn_abi_va_list\n-#define TARGET_CANONICAL_VA_LIST_TYPE std_canonical_va_list_type\n #define TARGET_EXPAND_BUILTIN_VA_START 0\n \n #define TARGET_GET_PCH_VALIDITY default_get_pch_validity\n@@ -822,8 +820,6 @@\n   TARGET_CC_MODES_COMPATIBLE,\t\t\t\\\n   TARGET_MACHINE_DEPENDENT_REORG,\t\t\\\n   TARGET_BUILD_BUILTIN_VA_LIST,\t\t\t\\\n-  TARGET_FN_ABI_VA_LIST,\t\t\t\\\n-  TARGET_CANONICAL_VA_LIST_TYPE,\t\t\t\\\n   TARGET_EXPAND_BUILTIN_VA_START,\t\t\\\n   TARGET_GIMPLIFY_VA_ARG_EXPR,\t\t\t\\\n   TARGET_GET_PCH_VALIDITY,\t\t\t\\"}, {"sha": "012d1c0099ba87948af63978fc0ce1f8c98d59b6", "filename": "gcc/target.h", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d79e31d96c322196a37c897c4cf02672416aae0/gcc%2Ftarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d79e31d96c322196a37c897c4cf02672416aae0/gcc%2Ftarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.h?ref=1d79e31d96c322196a37c897c4cf02672416aae0", "patch": "@@ -697,12 +697,6 @@ struct gcc_target\n   /* Create the __builtin_va_list type.  */\n   tree (* build_builtin_va_list) (void);\n \n-  /* Get the cfun/fndecl calling abi __builtin_va_list type.  */\n-  tree (* fn_abi_va_list) (tree);\n-\n-  /* Get the __builtin_va_list type dependent on input type.  */\n-  tree (* canonical_va_list_type) (tree);\n-\n   /* Expand the __builtin_va_start builtin.  */\n   void (* expand_builtin_va_start) (tree valist, rtx nextarg);\n "}, {"sha": "391511f56a7d3c15455489cb183beecc2107bccb", "filename": "gcc/tree-sra.c", "status": "modified", "additions": 3, "deletions": 21, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d79e31d96c322196a37c897c4cf02672416aae0/gcc%2Ftree-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d79e31d96c322196a37c897c4cf02672416aae0/gcc%2Ftree-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-sra.c?ref=1d79e31d96c322196a37c897c4cf02672416aae0", "patch": "@@ -308,26 +308,6 @@ sra_type_can_be_decomposed_p (tree type)\n   return false;\n }\n \n-/* Returns true if the TYPE is one of the available va_list types.\n-   Otherwise it returns false.\n-   Note, that for multiple calling conventions there can be more\n-   than just one va_list type present.  */\n-\n-static bool\n-is_va_list_type (tree type)\n-{\n-  tree h;\n-\n-  if (type == NULL_TREE)\n-    return false;\n-  h = targetm.canonical_va_list_type (type);\n-  if (h == NULL_TREE)\n-    return false;\n-  if (TYPE_MAIN_VARIANT (type) == TYPE_MAIN_VARIANT (h))\n-\t return true;\n-  return false;\n-}\n-\n /* Return true if DECL can be decomposed into a set of independent\n    (though not necessarily scalar) variables.  */\n \n@@ -380,7 +360,9 @@ decl_can_be_decomposed_p (tree var)\n      tree-stdarg.c, as the decomposition is truly a win.  This could also\n      be fixed if the stdarg pass ran early, but this can't be done until\n      we've aliasing information early too.  See PR 30791.  */\n-  if (early_sra && is_va_list_type (TREE_TYPE (var)))\n+  if (early_sra\n+      && TYPE_MAIN_VARIANT (TREE_TYPE (var))\n+\t == TYPE_MAIN_VARIANT (va_list_type_node))\n     return false;\n \n   return true;"}, {"sha": "d4dfadbced041342836a5c48ca7f0e540a408d42", "filename": "gcc/tree-ssa-ccp.c", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d79e31d96c322196a37c897c4cf02672416aae0/gcc%2Ftree-ssa-ccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d79e31d96c322196a37c897c4cf02672416aae0/gcc%2Ftree-ssa-ccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ccp.c?ref=1d79e31d96c322196a37c897c4cf02672416aae0", "patch": "@@ -2748,19 +2748,17 @@ optimize_stack_restore (basic_block bb, tree call, block_stmt_iterator i)\n static tree\n optimize_stdarg_builtin (tree call)\n {\n-  tree callee, lhs, rhs, cfun_va_list;\n+  tree callee, lhs, rhs;\n   bool va_list_simple_ptr;\n \n   if (TREE_CODE (call) != CALL_EXPR)\n     return NULL_TREE;\n \n-  callee = get_callee_fndecl (call);\n-\n-  cfun_va_list = targetm.fn_abi_va_list (callee);\n-  va_list_simple_ptr = POINTER_TYPE_P (cfun_va_list)\n-\t\t       && (TREE_TYPE (cfun_va_list) == void_type_node\n-\t\t\t   || TREE_TYPE (cfun_va_list) == char_type_node);\n+  va_list_simple_ptr = POINTER_TYPE_P (va_list_type_node)\n+\t\t       && (TREE_TYPE (va_list_type_node) == void_type_node\n+\t\t\t   || TREE_TYPE (va_list_type_node) == char_type_node);\n \n+  callee = get_callee_fndecl (call);\n   switch (DECL_FUNCTION_CODE (callee))\n     {\n     case BUILT_IN_VA_START:\n@@ -2775,7 +2773,7 @@ optimize_stdarg_builtin (tree call)\n       lhs = CALL_EXPR_ARG (call, 0);\n       if (!POINTER_TYPE_P (TREE_TYPE (lhs))\n \t  || TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (lhs)))\n-\t     != TYPE_MAIN_VARIANT (cfun_va_list))\n+\t     != TYPE_MAIN_VARIANT (va_list_type_node))\n \treturn NULL_TREE;\n \n       lhs = build_fold_indirect_ref (lhs);\n@@ -2794,13 +2792,13 @@ optimize_stdarg_builtin (tree call)\n       lhs = CALL_EXPR_ARG (call, 0);\n       if (!POINTER_TYPE_P (TREE_TYPE (lhs))\n \t  || TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (lhs)))\n-\t     != TYPE_MAIN_VARIANT (cfun_va_list))\n+\t     != TYPE_MAIN_VARIANT (va_list_type_node))\n \treturn NULL_TREE;\n \n       lhs = build_fold_indirect_ref (lhs);\n       rhs = CALL_EXPR_ARG (call, 1);\n       if (TYPE_MAIN_VARIANT (TREE_TYPE (rhs))\n-\t  != TYPE_MAIN_VARIANT (cfun_va_list))\n+\t  != TYPE_MAIN_VARIANT (va_list_type_node))\n \treturn NULL_TREE;\n \n       rhs = fold_convert (TREE_TYPE (lhs), rhs);"}, {"sha": "728c37d4d6de1aaba1533ad7a8d335b96f4ec30a", "filename": "gcc/tree-stdarg.c", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d79e31d96c322196a37c897c4cf02672416aae0/gcc%2Ftree-stdarg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d79e31d96c322196a37c897c4cf02672416aae0/gcc%2Ftree-stdarg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-stdarg.c?ref=1d79e31d96c322196a37c897c4cf02672416aae0", "patch": "@@ -605,7 +605,6 @@ execute_optimize_stdarg (void)\n   bool va_list_simple_ptr;\n   struct stdarg_info si;\n   const char *funcname = NULL;\n-  tree cfun_va_list;\n \n   cfun->va_list_gpr_size = 0;\n   cfun->va_list_fpr_size = 0;\n@@ -616,11 +615,10 @@ execute_optimize_stdarg (void)\n   if (dump_file)\n     funcname = lang_hooks.decl_printable_name (current_function_decl, 2);\n \n-  cfun_va_list = targetm.fn_abi_va_list (cfun->decl);\n-  va_list_simple_ptr = POINTER_TYPE_P (cfun_va_list)\n-\t\t       && (TREE_TYPE (cfun_va_list) == void_type_node\n-\t\t\t   || TREE_TYPE (cfun_va_list) == char_type_node);\n-  gcc_assert (is_gimple_reg_type (cfun_va_list) == va_list_simple_ptr);\n+  va_list_simple_ptr = POINTER_TYPE_P (va_list_type_node)\n+\t\t       && (TREE_TYPE (va_list_type_node) == void_type_node\n+\t\t\t   || TREE_TYPE (va_list_type_node) == char_type_node);\n+  gcc_assert (is_gimple_reg_type (va_list_type_node) == va_list_simple_ptr);\n \n   FOR_EACH_BB (bb)\n     {\n@@ -673,7 +671,7 @@ execute_optimize_stdarg (void)\n \t      ap = TREE_OPERAND (ap, 0);\n \t    }\n \t  if (TYPE_MAIN_VARIANT (TREE_TYPE (ap))\n-\t      != TYPE_MAIN_VARIANT (targetm.fn_abi_va_list (cfun->decl))\n+\t      != TYPE_MAIN_VARIANT (va_list_type_node)\n \t      || TREE_CODE (ap) != VAR_DECL)\n \t    {\n \t      va_list_escapes = true;"}]}