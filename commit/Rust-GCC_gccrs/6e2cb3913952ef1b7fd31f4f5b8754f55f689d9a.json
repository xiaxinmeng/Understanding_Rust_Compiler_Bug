{"sha": "6e2cb3913952ef1b7fd31f4f5b8754f55f689d9a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmUyY2IzOTEzOTUyZWYxYjdmZDMxZjRmNWI4NzU0ZjU1ZjY4OWQ5YQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2011-09-16T19:14:36Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2011-09-16T19:14:36Z"}, "message": "sse.md (vec_extract_hi_<mode>, [...]): Use vextracti128 instead of vextractf128 for -mavx2 and integer vectors.\n\n\t* config/i386/sse.md (vec_extract_hi_<mode>,\n\tvec_extract_hi_v16hi, vec_extract_hi_v32qi): Use\n\tvextracti128 instead of vextractf128 for -mavx2 and\n\tinteger vectors.  For V4DFmode fix up mode attribute.\n\t(VEC_EXTRACT_MODE): For TARGET_AVX add 32-byte vectors.\n\t(vec_set_lo_<mode>, vec_set_hi_<mode>): For VI8F_256 modes use V4DF\n\tinstead of V8SF mode attribute.\n\t(avx2_extracti128): Change into define_expand.\n\t* config/i386/i386.c (ix86_expand_vector_extract): Handle\n\t32-byte vector modes if TARGET_AVX.\n\n\t* gcc.target/i386/sse2-extract-1.c: New test.\n\t* gcc.target/i386/avx-extract-1.c: New test.\n\nFrom-SVN: r178915", "tree": {"sha": "63520943d260db2da79353c5616960e263cdd8ba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/63520943d260db2da79353c5616960e263cdd8ba"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6e2cb3913952ef1b7fd31f4f5b8754f55f689d9a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e2cb3913952ef1b7fd31f4f5b8754f55f689d9a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6e2cb3913952ef1b7fd31f4f5b8754f55f689d9a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e2cb3913952ef1b7fd31f4f5b8754f55f689d9a/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "6deb519753e07d167eda75bced5a7987a57f0a03", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6deb519753e07d167eda75bced5a7987a57f0a03", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6deb519753e07d167eda75bced5a7987a57f0a03"}], "stats": {"total": 296, "additions": 275, "deletions": 21}, "files": [{"sha": "834ae64cf069f5aad8dc2e8f0802ff719795b12b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e2cb3913952ef1b7fd31f4f5b8754f55f689d9a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e2cb3913952ef1b7fd31f4f5b8754f55f689d9a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6e2cb3913952ef1b7fd31f4f5b8754f55f689d9a", "patch": "@@ -1,3 +1,16 @@\n+2011-09-16  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* config/i386/sse.md (vec_extract_hi_<mode>,\n+\tvec_extract_hi_v16hi, vec_extract_hi_v32qi): Use\n+\tvextracti128 instead of vextractf128 for -mavx2 and\n+\tinteger vectors.  For V4DFmode fix up mode attribute.\n+\t(VEC_EXTRACT_MODE): For TARGET_AVX add 32-byte vectors.\n+\t(vec_set_lo_<mode>, vec_set_hi_<mode>): For VI8F_256 modes use V4DF\n+\tinstead of V8SF mode attribute.\n+\t(avx2_extracti128): Change into define_expand.\n+\t* config/i386/i386.c (ix86_expand_vector_extract): Handle\n+\t32-byte vector modes if TARGET_AVX.\n+\n 2011-09-16  Georg-Johann Lay  <avr@gjlay.de>\n \t\n \t* config/avr/avr.md: (umulqihi3, mulqihi3): Write as one pattern."}, {"sha": "6e7bcd938ecf8814c811a67fb6fc4c0d5fae6108", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e2cb3913952ef1b7fd31f4f5b8754f55f689d9a/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e2cb3913952ef1b7fd31f4f5b8754f55f689d9a/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=6e2cb3913952ef1b7fd31f4f5b8754f55f689d9a", "patch": "@@ -32587,6 +32587,84 @@ ix86_expand_vector_extract (bool mmx_ok, rtx target, rtx vec, int elt)\n       use_vec_extr = TARGET_SSE4_1;\n       break;\n \n+    case V8SFmode:\n+      if (TARGET_AVX)\n+\t{\n+\t  tmp = gen_reg_rtx (V4SFmode);\n+\t  if (elt < 4)\n+\t    emit_insn (gen_vec_extract_lo_v8sf (tmp, vec));\n+\t  else\n+\t    emit_insn (gen_vec_extract_hi_v8sf (tmp, vec));\n+\t  ix86_expand_vector_extract (false, target, tmp, elt & 3);\n+\t  return;\n+\t}\n+      break;\n+\n+    case V4DFmode:\n+      if (TARGET_AVX)\n+\t{\n+\t  tmp = gen_reg_rtx (V2DFmode);\n+\t  if (elt < 2)\n+\t    emit_insn (gen_vec_extract_lo_v4df (tmp, vec));\n+\t  else\n+\t    emit_insn (gen_vec_extract_hi_v4df (tmp, vec));\n+\t  ix86_expand_vector_extract (false, target, tmp, elt & 1);\n+\t  return;\n+\t}\n+      break;\n+\n+    case V32QImode:\n+      if (TARGET_AVX)\n+\t{\n+\t  tmp = gen_reg_rtx (V16QImode);\n+\t  if (elt < 16)\n+\t    emit_insn (gen_vec_extract_lo_v32qi (tmp, vec));\n+\t  else\n+\t    emit_insn (gen_vec_extract_hi_v32qi (tmp, vec));\n+\t  ix86_expand_vector_extract (false, target, tmp, elt & 15);\n+\t  return;\n+\t}\n+      break;\n+\n+    case V16HImode:\n+      if (TARGET_AVX)\n+\t{\n+\t  tmp = gen_reg_rtx (V8HImode);\n+\t  if (elt < 8)\n+\t    emit_insn (gen_vec_extract_lo_v16hi (tmp, vec));\n+\t  else\n+\t    emit_insn (gen_vec_extract_hi_v16hi (tmp, vec));\n+\t  ix86_expand_vector_extract (false, target, tmp, elt & 7);\n+\t  return;\n+\t}\n+      break;\n+\n+    case V8SImode:\n+      if (TARGET_AVX)\n+\t{\n+\t  tmp = gen_reg_rtx (V4SImode);\n+\t  if (elt < 4)\n+\t    emit_insn (gen_vec_extract_lo_v8si (tmp, vec));\n+\t  else\n+\t    emit_insn (gen_vec_extract_hi_v8si (tmp, vec));\n+\t  ix86_expand_vector_extract (false, target, tmp, elt & 3);\n+\t  return;\n+\t}\n+      break;\n+\n+    case V4DImode:\n+      if (TARGET_AVX)\n+\t{\n+\t  tmp = gen_reg_rtx (V2DImode);\n+\t  if (elt < 2)\n+\t    emit_insn (gen_vec_extract_lo_v4di (tmp, vec));\n+\t  else\n+\t    emit_insn (gen_vec_extract_hi_v4di (tmp, vec));\n+\t  ix86_expand_vector_extract (false, target, tmp, elt & 1);\n+\t  return;\n+\t}\n+      break;\n+\n     case V8QImode:\n       /* ??? Could extract the appropriate HImode element and shift.  */\n     default:"}, {"sha": "01edc4e85e934c15d235fc157d0b4cf146dede87", "filename": "gcc/config/i386/sse.md", "status": "modified", "additions": 72, "deletions": 21, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e2cb3913952ef1b7fd31f4f5b8754f55f689d9a/gcc%2Fconfig%2Fi386%2Fsse.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e2cb3913952ef1b7fd31f4f5b8754f55f689d9a/gcc%2Fconfig%2Fi386%2Fsse.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fsse.md?ref=6e2cb3913952ef1b7fd31f4f5b8754f55f689d9a", "patch": "@@ -3827,13 +3827,23 @@\n \t  (match_operand:VI8F_256 1 \"register_operand\" \"x,x\")\n \t  (parallel [(const_int 2) (const_int 3)])))]\n   \"TARGET_AVX\"\n-  \"vextractf128\\t{$0x1, %1, %0|%0, %1, 0x1}\"\n+{\n+  if (get_attr_mode (insn) == MODE_OI)\n+    return \"vextracti128\\t{$0x1, %1, %0|%0, %1, 0x1}\";\n+  else\n+    return \"vextractf128\\t{$0x1, %1, %0|%0, %1, 0x1}\";\n+}\n   [(set_attr \"type\" \"sselog\")\n    (set_attr \"prefix_extra\" \"1\")\n    (set_attr \"length_immediate\" \"1\")\n    (set_attr \"memory\" \"none,store\")\n    (set_attr \"prefix\" \"vex\")\n-   (set_attr \"mode\" \"V8SF\")])\n+   (set (attr \"mode\")\n+     (if_then_else\n+       (and (match_test \"TARGET_AVX2\")\n+\t    (eq (const_string \"<MODE>mode\") (const_string \"V4DImode\")))\n+     (const_string \"OI\")\n+     (const_string \"V4DF\")))])\n \n (define_insn_and_split \"vec_extract_lo_<mode>\"\n   [(set (match_operand:<ssehalfvecmode> 0 \"nonimmediate_operand\" \"=x,m\")\n@@ -3862,13 +3872,23 @@\n \t  (parallel [(const_int 4) (const_int 5)\n \t\t     (const_int 6) (const_int 7)])))]\n   \"TARGET_AVX\"\n-  \"vextractf128\\t{$0x1, %1, %0|%0, %1, 0x1}\"\n+{\n+  if (get_attr_mode (insn) == MODE_OI)\n+    return \"vextracti128\\t{$0x1, %1, %0|%0, %1, 0x1}\";\n+  else\n+    return \"vextractf128\\t{$0x1, %1, %0|%0, %1, 0x1}\";\n+}\n   [(set_attr \"type\" \"sselog\")\n    (set_attr \"prefix_extra\" \"1\")\n    (set_attr \"length_immediate\" \"1\")\n    (set_attr \"memory\" \"none,store\")\n    (set_attr \"prefix\" \"vex\")\n-   (set_attr \"mode\" \"V8SF\")])\n+   (set (attr \"mode\")\n+     (if_then_else\n+       (and (match_test \"TARGET_AVX2\")\n+\t    (eq (const_string \"<MODE>mode\") (const_string \"V8SImode\")))\n+     (const_string \"OI\")\n+     (const_string \"V8SF\")))])\n \n (define_insn_and_split \"vec_extract_lo_v16hi\"\n   [(set (match_operand:V8HI 0 \"nonimmediate_operand\" \"=x,m\")\n@@ -3901,13 +3921,21 @@\n \t\t     (const_int 12) (const_int 13)\n \t\t     (const_int 14) (const_int 15)])))]\n   \"TARGET_AVX\"\n-  \"vextractf128\\t{$0x1, %1, %0|%0, %1, 0x1}\"\n+{\n+  if (get_attr_mode (insn) == MODE_OI)\n+    return \"vextracti128\\t{$0x1, %1, %0|%0, %1, 0x1}\";\n+  else\n+    return \"vextractf128\\t{$0x1, %1, %0|%0, %1, 0x1}\";\n+}\n   [(set_attr \"type\" \"sselog\")\n    (set_attr \"prefix_extra\" \"1\")\n    (set_attr \"length_immediate\" \"1\")\n    (set_attr \"memory\" \"none,store\")\n    (set_attr \"prefix\" \"vex\")\n-   (set_attr \"mode\" \"V8SF\")])\n+   (set (attr \"mode\")\n+     (if_then_else (match_test \"TARGET_AVX2\")\n+   (const_string \"OI\")\n+   (const_string \"V8SF\")))])\n \n (define_insn_and_split \"vec_extract_lo_v32qi\"\n   [(set (match_operand:V16QI 0 \"nonimmediate_operand\" \"=x,m\")\n@@ -3948,13 +3976,21 @@\n \t\t     (const_int 28) (const_int 29)\n \t\t     (const_int 30) (const_int 31)])))]\n   \"TARGET_AVX\"\n-  \"vextractf128\\t{$0x1, %1, %0|%0, %1, 0x1}\"\n+{\n+  if (get_attr_mode (insn) == MODE_OI)\n+    return \"vextracti128\\t{$0x1, %1, %0|%0, %1, 0x1}\";\n+  else\n+    return \"vextractf128\\t{$0x1, %1, %0|%0, %1, 0x1}\";\n+}\n   [(set_attr \"type\" \"sselog\")\n    (set_attr \"prefix_extra\" \"1\")\n    (set_attr \"length_immediate\" \"1\")\n    (set_attr \"memory\" \"none,store\")\n    (set_attr \"prefix\" \"vex\")\n-   (set_attr \"mode\" \"V8SF\")])\n+   (set (attr \"mode\")\n+     (if_then_else (match_test \"TARGET_AVX2\")\n+   (const_string \"OI\")\n+   (const_string \"V8SF\")))])\n \n (define_insn \"*sse4_1_extractps\"\n   [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=rm\")\n@@ -3988,7 +4024,10 @@\n \n ;; Modes handled by vec_extract patterns.\n (define_mode_iterator VEC_EXTRACT_MODE\n-  [V16QI V8HI V4SI V2DI\n+  [(V32QI \"TARGET_AVX\") V16QI\n+   (V16HI \"TARGET_AVX\") V8HI\n+   (V8SI \"TARGET_AVX\") V4SI\n+   (V4DI \"TARGET_AVX\") V2DI\n    (V8SF \"TARGET_AVX\") V4SF\n    (V4DF \"TARGET_AVX\") V2DF])\n \n@@ -11916,7 +11955,7 @@\n    (set_attr \"prefix_extra\" \"1\")\n    (set_attr \"length_immediate\" \"1\")\n    (set_attr \"prefix\" \"vex\")\n-   (set_attr \"mode\" \"V8SF\")])\n+   (set_attr \"mode\" \"V4DF\")])\n \n (define_insn \"vec_set_hi_<mode>\"\n   [(set (match_operand:VI8F_256 0 \"register_operand\" \"=x\")\n@@ -11931,7 +11970,7 @@\n    (set_attr \"prefix_extra\" \"1\")\n    (set_attr \"length_immediate\" \"1\")\n    (set_attr \"prefix\" \"vex\")\n-   (set_attr \"mode\" \"V8SF\")])\n+   (set_attr \"mode\" \"V4DF\")])\n \n (define_insn \"vec_set_lo_<mode>\"\n   [(set (match_operand:VI4F_256 0 \"register_operand\" \"=x\")\n@@ -12122,17 +12161,29 @@\n   DONE;\n })\n \n-(define_insn \"avx2_extracti128\"\n-  [(set (match_operand:V2DI 0 \"register_operand\" \"=x\")\n-\t(vec_select:V2DI\n-\t  (match_operand:V4DI 1 \"nonimmediate_operand\" \"xm\")\n-\t  (parallel [(match_operand:SI 2 \"const_0_to_1_operand\" \"n\")])))]\n+(define_expand \"avx2_extracti128\"\n+  [(match_operand:V2DI 0 \"nonimmediate_operand\" \"\")\n+   (match_operand:V4DI 1 \"register_operand\" \"\")\n+   (match_operand:SI 2 \"const_0_to_1_operand\" \"\")]\n   \"TARGET_AVX2\"\n-  \"vextracti128\\t{%2, %1, %0|%0, %1, %2}\"\n-  [(set_attr \"type\" \"ssemov\")\n-   (set_attr \"prefix_extra\" \"1\")\n-   (set_attr \"prefix\" \"vex\")\n-   (set_attr \"mode\" \"OI\")])\n+{\n+  rtx (*insn)(rtx, rtx);\n+\n+  switch (INTVAL (operands[2]))\n+    {\n+    case 0:\n+      insn = gen_vec_extract_lo_v4di;\n+      break;\n+    case 1:\n+      insn = gen_vec_extract_hi_v4di;\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  emit_insn (insn (operands[0], operands[1]));\n+  DONE;\n+})\n \n (define_expand \"avx2_inserti128\"\n   [(match_operand:V4DI 0 \"register_operand\" \"\")"}, {"sha": "b9d52b47d709edd94b087485819ae442e93c754c", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e2cb3913952ef1b7fd31f4f5b8754f55f689d9a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e2cb3913952ef1b7fd31f4f5b8754f55f689d9a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=6e2cb3913952ef1b7fd31f4f5b8754f55f689d9a", "patch": "@@ -1,3 +1,8 @@\n+2011-09-16  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* gcc.target/i386/sse2-extract-1.c: New test.\n+\t* gcc.target/i386/avx-extract-1.c: New test.\n+\n 2011-09-16  Terry Guo  <terry.guo@arm.com>\n \n \t* gcc.dg/tree-ssa/foldconst-3.c: Don't use short enums."}, {"sha": "2684125f52ae57b27c0008d5c2cbef116e198b4a", "filename": "gcc/testsuite/gcc.target/i386/avx-extract-1.c", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e2cb3913952ef1b7fd31f4f5b8754f55f689d9a/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx-extract-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e2cb3913952ef1b7fd31f4f5b8754f55f689d9a/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx-extract-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx-extract-1.c?ref=6e2cb3913952ef1b7fd31f4f5b8754f55f689d9a", "patch": "@@ -0,0 +1,5 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -mavx\" } */\n+/* { dg-require-effective-target avx_runtime } */\n+\n+#include \"sse2-extract-1.c\""}, {"sha": "f701cee8c02f7973fc8d40e323cc3b52e891302b", "filename": "gcc/testsuite/gcc.target/i386/sse2-extract-1.c", "status": "added", "additions": 102, "deletions": 0, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e2cb3913952ef1b7fd31f4f5b8754f55f689d9a/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse2-extract-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e2cb3913952ef1b7fd31f4f5b8754f55f689d9a/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse2-extract-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse2-extract-1.c?ref=6e2cb3913952ef1b7fd31f4f5b8754f55f689d9a", "patch": "@@ -0,0 +1,102 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -msse2\" } */\n+/* { dg-require-effective-target sse2_runtime } */\n+\n+extern void abort (void);\n+typedef unsigned long long uint64_t;\n+\n+#define vector(elcount, type)  \\\n+__attribute__((vector_size((elcount)*sizeof(type)))) type\n+\n+#define FN(elcount, type, idx) \\\n+__attribute__((noinline, noclone)) \\\n+type f##type##elcount##_##idx (vector (elcount, type) x) { return x[idx] + 1; }\n+#define T2(elcount, type) \\\n+  H (elcount, type) \\\n+  F (elcount, type, 0) \\\n+  F (elcount, type, 1)\n+#define T4(elcount, type) \\\n+  T2 (elcount, type) \\\n+  F (elcount, type, 2) \\\n+  F (elcount, type, 3)\n+#define T8(elcount, type) \\\n+  T4 (elcount, type) \\\n+  F (elcount, type, 4) \\\n+  F (elcount, type, 5) \\\n+  F (elcount, type, 6) \\\n+  F (elcount, type, 7)\n+#define T16(elcount, type) \\\n+  T8 (elcount, type) \\\n+  F (elcount, type, 8) \\\n+  F (elcount, type, 9) \\\n+  F (elcount, type, 10) \\\n+  F (elcount, type, 11) \\\n+  F (elcount, type, 12) \\\n+  F (elcount, type, 13) \\\n+  F (elcount, type, 14) \\\n+  F (elcount, type, 15)\n+#define T32(elcount, type) \\\n+  T16 (elcount, type) \\\n+  F (elcount, type, 16) \\\n+  F (elcount, type, 17) \\\n+  F (elcount, type, 18) \\\n+  F (elcount, type, 19) \\\n+  F (elcount, type, 20) \\\n+  F (elcount, type, 21) \\\n+  F (elcount, type, 22) \\\n+  F (elcount, type, 23) \\\n+  F (elcount, type, 24) \\\n+  F (elcount, type, 25) \\\n+  F (elcount, type, 26) \\\n+  F (elcount, type, 27) \\\n+  F (elcount, type, 28) \\\n+  F (elcount, type, 29) \\\n+  F (elcount, type, 30) \\\n+  F (elcount, type, 31)\n+#define TESTS_SSE2 \\\n+T2 (2, double) E \\\n+T2 (2, uint64_t) E \\\n+T4 (4, float) E \\\n+T4 (4, int) E \\\n+T8 (8, short) E \\\n+T16 (16, char) E\n+#define TESTS_AVX \\\n+T4 (4, double) E \\\n+T4 (4, uint64_t) E \\\n+T8 (8, float) E \\\n+T8 (8, int) E \\\n+T16 (16, short) E \\\n+T32 (32, char) E\n+#ifdef __AVX__\n+#define TESTS TESTS_SSE2 TESTS_AVX\n+#else\n+#define TESTS TESTS_SSE2\n+#endif\n+\n+#define F FN\n+#define H(elcount, type)\n+#define E\n+TESTS\n+\n+int\n+main ()\n+{\n+#undef F\n+#undef H\n+#undef E\n+#define H(elcount, type) \\\n+  vector (elcount, type) v##type##elcount = {\n+#define E };\n+#define F(elcount, type, idx) idx + 1,\n+  TESTS\n+#undef F\n+#undef H\n+#undef E\n+#define H(elcount, type)\n+#define E\n+#define F(elcount, type, idx) \\\n+  if (f##type##elcount##_##idx (v##type##elcount) != idx + 2) \\\n+    abort ();\n+  TESTS\n+  return 0;\n+}"}]}