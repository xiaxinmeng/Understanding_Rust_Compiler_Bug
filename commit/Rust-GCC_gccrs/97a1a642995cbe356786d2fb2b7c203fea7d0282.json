{"sha": "97a1a642995cbe356786d2fb2b7c203fea7d0282", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTdhMWE2NDI5OTVjYmUzNTY3ODZkMmZiMmI3YzIwM2ZlYTdkMDI4Mg==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2015-12-03T11:26:56Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2015-12-03T11:26:56Z"}, "message": "re PR tree-optimization/66051 (can't vectorize reductions inside an SLP group)\n\n2015-12-03  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/66051\n\t* tree-vect-slp.c (vect_build_slp_tree_1): Remove restriction\n\ton load group size.  Do not pass in vectorization_factor.\n\t(vect_transform_slp_perm_load): Do not require any permute support.\n\t(vect_build_slp_tree): Do not pass in vectorization factor.\n\t(vect_analyze_slp_instance): Do not compute vectorization\n\tfactor estimate.  Use vector size instead of vectorization factor\n\testimate to split store groups for BB vectorization.\n\n\t* gcc.dg/vect/slp-42.c: New testcase.\n\nFrom-SVN: r231225", "tree": {"sha": "afefa2b1a929269bdd0a2d3120eef4d111960e5f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/afefa2b1a929269bdd0a2d3120eef4d111960e5f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/97a1a642995cbe356786d2fb2b7c203fea7d0282", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/97a1a642995cbe356786d2fb2b7c203fea7d0282", "html_url": "https://github.com/Rust-GCC/gccrs/commit/97a1a642995cbe356786d2fb2b7c203fea7d0282", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/97a1a642995cbe356786d2fb2b7c203fea7d0282/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b5be36b1dba767987999e7fac5af85022e97c113", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b5be36b1dba767987999e7fac5af85022e97c113", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b5be36b1dba767987999e7fac5af85022e97c113"}], "stats": {"total": 110, "additions": 46, "deletions": 64}, "files": [{"sha": "65b1b2b62843a1595617ef1f03908a52ecda0b03", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97a1a642995cbe356786d2fb2b7c203fea7d0282/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97a1a642995cbe356786d2fb2b7c203fea7d0282/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=97a1a642995cbe356786d2fb2b7c203fea7d0282", "patch": "@@ -1,3 +1,14 @@\n+2015-12-03  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/66051\n+\t* tree-vect-slp.c (vect_build_slp_tree_1): Remove restriction\n+\ton load group size.  Do not pass in vectorization_factor.\n+\t(vect_transform_slp_perm_load): Do not require any permute support.\n+\t(vect_build_slp_tree): Do not pass in vectorization factor.\n+\t(vect_analyze_slp_instance): Do not compute vectorization\n+\tfactor estimate.  Use vector size instead of vectorization factor\n+\testimate to split store groups for BB vectorization.\n+\n 2015-12-03  Ilya Enkovich  <enkovich.gnu@gmail.com>\n \n \t* cfgexpand.c (expand_gimple_stmt_1): Return statement with"}, {"sha": "55529e05720fd2855cb50117f32904eb0205c374", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97a1a642995cbe356786d2fb2b7c203fea7d0282/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97a1a642995cbe356786d2fb2b7c203fea7d0282/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=97a1a642995cbe356786d2fb2b7c203fea7d0282", "patch": "@@ -1,3 +1,8 @@\n+2015-12-03  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/66051\n+\t* gcc.dg/vect/slp-42.c: New testcase.\n+\n 2015-12-02  Kirill Yukhin  <kirill.yukhin@intel.com>\n \n \t* gcc.target/i386/avx512vl-vextractf32x4-1.c: Fix scan pattern."}, {"sha": "ea5fe167cdbabde60ecec3c3f1bf0eb771863ffd", "filename": "gcc/testsuite/gcc.dg/vect/slp-42.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97a1a642995cbe356786d2fb2b7c203fea7d0282/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-42.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97a1a642995cbe356786d2fb2b7c203fea7d0282/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-42.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-42.c?ref=97a1a642995cbe356786d2fb2b7c203fea7d0282", "patch": "@@ -0,0 +1,19 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target vect_int } */\n+\n+int p[4096], q[4096];\n+\n+void foo (int n)\n+{\n+  int i;\n+  for (i = 0; i < n; ++i)\n+    {\n+      p[i*4+0] = q[i*8+0] + q[i*8+4];\n+      p[i*4+1] = q[i*8+1] + q[i*8+5];\n+      p[i*4+2] = q[i*8+2] + q[i*8+6];\n+      p[i*4+3] = q[i*8+3] + q[i*8+7];\n+    }\n+}\n+\n+/* { dg-final { scan-tree-dump \"vectorizing stmts using SLP\" \"vect\" } } */\n+/* { dg-final { scan-tree-dump \"vectorized 1 loops\" \"vect\" } } */"}, {"sha": "b893682306762411adbc87f24e0245b6824fa161", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 11, "deletions": 64, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97a1a642995cbe356786d2fb2b7c203fea7d0282/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97a1a642995cbe356786d2fb2b7c203fea7d0282/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=97a1a642995cbe356786d2fb2b7c203fea7d0282", "patch": "@@ -430,8 +430,7 @@ static bool\n vect_build_slp_tree_1 (vec_info *vinfo,\n \t\t       vec<gimple *> stmts, unsigned int group_size,\n \t\t       unsigned nops, unsigned int *max_nunits,\n-\t\t       unsigned int vectorization_factor, bool *matches,\n-\t\t       bool *two_operators)\n+\t\t       bool *matches, bool *two_operators)\n {\n   unsigned int i;\n   gimple *first_stmt = stmts[0], *stmt = stmts[0];\n@@ -523,11 +522,7 @@ vect_build_slp_tree_1 (vec_info *vinfo,\n \n       /* In case of multiple types we need to detect the smallest type.  */\n       if (*max_nunits < TYPE_VECTOR_SUBPARTS (vectype))\n-        {\n-          *max_nunits = TYPE_VECTOR_SUBPARTS (vectype);\n-          if (is_a <bb_vec_info> (vinfo))\n-            vectorization_factor = *max_nunits;\n-        }\n+\t*max_nunits = TYPE_VECTOR_SUBPARTS (vectype);\n \n       if (gcall *call_stmt = dyn_cast <gcall *> (stmt))\n \t{\n@@ -700,31 +695,6 @@ vect_build_slp_tree_1 (vec_info *vinfo,\n \t  else\n \t    {\n \t      /* Load.  */\n-              /* Check that the size of interleaved loads group is not\n-                 greater than the SLP group size.  */\n-\t      unsigned ncopies\n-\t\t= vectorization_factor / TYPE_VECTOR_SUBPARTS (vectype);\n-              if (is_a <loop_vec_info> (vinfo)\n-\t\t  && GROUP_FIRST_ELEMENT (vinfo_for_stmt (stmt)) == stmt\n-                  && ((GROUP_SIZE (vinfo_for_stmt (stmt))\n-\t\t       - GROUP_GAP (vinfo_for_stmt (stmt)))\n-\t\t      > ncopies * group_size))\n-                {\n-                  if (dump_enabled_p ())\n-                    {\n-                      dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t\t       \"Build SLP failed: the number \"\n-\t\t\t\t       \"of interleaved loads is greater than \"\n-\t\t\t\t       \"the SLP group size \");\n-                      dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM,\n-\t\t\t\t\tstmt, 0);\n-                      dump_printf (MSG_MISSED_OPTIMIZATION, \"\\n\");\n-                    }\n-\t\t  /* Fatal mismatch.  */\n-\t\t  matches[0] = false;\n-                  return false;\n-                }\n-\n               first_load = GROUP_FIRST_ELEMENT (vinfo_for_stmt (stmt));\n               if (prev_first_load)\n                 {\n@@ -871,7 +841,6 @@ vect_build_slp_tree (vec_info *vinfo,\n                      slp_tree *node, unsigned int group_size,\n                      unsigned int *max_nunits,\n                      vec<slp_tree> *loads,\n-                     unsigned int vectorization_factor,\n \t\t     bool *matches, unsigned *npermutes, unsigned *tree_size,\n \t\t     unsigned max_tree_size)\n {\n@@ -895,8 +864,7 @@ vect_build_slp_tree (vec_info *vinfo,\n   bool two_operators = false;\n   if (!vect_build_slp_tree_1 (vinfo,\n \t\t\t      SLP_TREE_SCALAR_STMTS (*node), group_size, nops,\n-\t\t\t      max_nunits, vectorization_factor, matches,\n-\t\t\t      &two_operators))\n+\t\t\t      max_nunits, matches, &two_operators))\n     return false;\n   SLP_TREE_TWO_OPERATORS (*node) = two_operators;\n \n@@ -959,8 +927,7 @@ vect_build_slp_tree (vec_info *vinfo,\n \t}\n \n       if (vect_build_slp_tree (vinfo, &child,\n-\t\t\t       group_size, max_nunits, loads,\n-\t\t\t       vectorization_factor, matches,\n+\t\t\t       group_size, max_nunits, loads, matches,\n \t\t\t       npermutes, &this_tree_size, max_tree_size))\n \t{\n \t  /* If we have all children of child built up from scalars then just\n@@ -1074,7 +1041,6 @@ vect_build_slp_tree (vec_info *vinfo,\n \t  bool *tem = XALLOCAVEC (bool, group_size);\n \t  if (vect_build_slp_tree (vinfo, &child,\n \t\t\t\t   group_size, max_nunits, loads,\n-\t\t\t\t   vectorization_factor,\n \t\t\t\t   tem, npermutes, &this_tree_size,\n \t\t\t\t   max_tree_size))\n \t    {\n@@ -1656,7 +1622,6 @@ vect_analyze_slp_instance (vec_info *vinfo,\n   unsigned int unrolling_factor = 1, nunits;\n   tree vectype, scalar_type = NULL_TREE;\n   gimple *next;\n-  unsigned int vectorization_factor = 0;\n   unsigned int i;\n   unsigned int max_nunits = 0;\n   vec<slp_tree> loads;\n@@ -1697,12 +1662,7 @@ vect_analyze_slp_instance (vec_info *vinfo,\n \n       return false;\n     }\n-\n   nunits = TYPE_VECTOR_SUBPARTS (vectype);\n-  if (is_a <loop_vec_info> (vinfo))\n-    vectorization_factor = as_a <loop_vec_info> (vinfo)->vectorization_factor;\n-  else\n-    vectorization_factor = nunits;\n \n   /* Calculate the unrolling factor.  */\n   unrolling_factor = least_common_multiple (nunits, group_size) / group_size;\n@@ -1755,8 +1715,7 @@ vect_analyze_slp_instance (vec_info *vinfo,\n   unsigned npermutes = 0;\n   if (vect_build_slp_tree (vinfo, &node, group_size,\n \t\t\t   &max_nunits, &loads,\n-\t\t\t   vectorization_factor, matches, &npermutes, NULL,\n-\t\t\t   max_tree_size))\n+\t\t\t   matches, &npermutes, NULL, max_tree_size))\n     {\n       /* Calculate the unrolling factor based on the smallest type.  */\n       if (max_nunits > nunits)\n@@ -1852,7 +1811,7 @@ vect_analyze_slp_instance (vec_info *vinfo,\n   loads.release ();\n \n   /* For basic block SLP, try to break the group up into multiples of the\n-     vectorization factor.  */\n+     vector size.  */\n   if (is_a <bb_vec_info> (vinfo)\n       && GROUP_FIRST_ELEMENT (vinfo_for_stmt (stmt))\n       && STMT_VINFO_GROUPED_ACCESS (vinfo_for_stmt (stmt)))\n@@ -1862,21 +1821,21 @@ vect_analyze_slp_instance (vec_info *vinfo,\n       for (i = 0; i < group_size; i++)\n \tif (!matches[i]) break;\n \n-      if (i >= vectorization_factor && i < group_size)\n+      if (i >= nunits && i < group_size)\n \t{\n \t  /* Split into two groups at the first vector boundary before i.  */\n-\t  gcc_assert ((vectorization_factor & (vectorization_factor - 1)) == 0);\n-\t  unsigned group1_size = i & ~(vectorization_factor - 1);\n+\t  gcc_assert ((nunits & (nunits - 1)) == 0);\n+\t  unsigned group1_size = i & ~(nunits - 1);\n \n \t  gimple *rest = vect_split_slp_store_group (stmt, group1_size);\n \t  bool res = vect_analyze_slp_instance (vinfo, stmt, max_tree_size);\n \t  /* If the first non-match was in the middle of a vector,\n \t     skip the rest of that vector.  */\n \t  if (group1_size < i)\n \t    {\n-\t      i = group1_size + vectorization_factor;\n+\t      i = group1_size + nunits;\n \t      if (i < group_size)\n-\t\trest = vect_split_slp_store_group (rest, vectorization_factor);\n+\t\trest = vect_split_slp_store_group (rest, nunits);\n \t    }\n \t  if (i < group_size)\n \t    res |= vect_analyze_slp_instance (vinfo, rest, max_tree_size);\n@@ -3274,18 +3233,6 @@ vect_transform_slp_perm_load (slp_tree node, vec<tree> dr_chain,\n \n   mode = TYPE_MODE (vectype);\n \n-  if (!can_vec_perm_p (mode, false, NULL))\n-    {\n-      if (dump_enabled_p ())\n-        {\n-          dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t   \"no vect permute for \");\n-          dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM, stmt, 0);\n-          dump_printf (MSG_MISSED_OPTIMIZATION, \"\\n\");\n-        }\n-      return false;\n-    }\n-\n   /* The generic VEC_PERM_EXPR code always uses an integral type of the\n      same size as the vector element being permuted.  */\n   mask_element_type = lang_hooks.types.type_for_mode"}]}