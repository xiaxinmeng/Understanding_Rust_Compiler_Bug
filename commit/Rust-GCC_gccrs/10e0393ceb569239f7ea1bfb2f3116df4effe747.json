{"sha": "10e0393ceb569239f7ea1bfb2f3116df4effe747", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTBlMDM5M2NlYjU2OTIzOWY3ZWExYmZiMmYzMTE2ZGY0ZWZmZTc0Nw==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2015-09-15T17:03:49Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2015-09-15T17:03:49Z"}, "message": "[PATCH] More class-ification of DOM\n\n        PR tree-optimization/47679\n\t* tree-ssa-dom.c (expr_hash_elt): Now a class with ctors/dtors,\n\tmethods and private members.\n\t(avail_exprs_stack): Similarly.  Change type of global\n\tfrom a pair of expr_hash_elt_t to the new class.\n\t(expr_elt_hasher::hash): Corresponding changes.\n\t(expr_elt_hasher::equal): Similarly.\n\t(avail_expr_hash): Similarly.\n\t(pass_dominator::execute): Similarly.\n\t(dom_opt_dom_walker::thread_across_edge): Similarly.\n\t(record_cond): Similarly.\n\t(dom_opt_dom_walker::before_dom_children): Similarly.\n\t(dom_opt_dom_walker::after_dom_children): Similarly.\n\t(lookup_avail_expr): Likewise.\n\t(initialize_hash_element): Now a expr_hash_elt constructor.\n\t(initialize_hash_element_from_expr): Similarly.\n\t(free_expr_hash_elt_contents): Now a dtor for class expr_hash_elt.\n\t(free_expr_hash_elt): Call dtor for the element.\n\t(remove_local_expressions_from_table): Now the \"pop_to_marker\"\n\tmethod in the available_exprs_stack class.\n\t(avail_expr_stack::record_expr): Method factored out.\n\t(print_expr_hash_elt): Now a method in the expr_hash_elt class.\n\tFix formatting.\n\t(hashable_expr_equal_p): Fix formatting.\n\nFrom-SVN: r227801", "tree": {"sha": "d8e95b2c7a7b82c1bea521015e256af7c35ea08c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d8e95b2c7a7b82c1bea521015e256af7c35ea08c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/10e0393ceb569239f7ea1bfb2f3116df4effe747", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10e0393ceb569239f7ea1bfb2f3116df4effe747", "html_url": "https://github.com/Rust-GCC/gccrs/commit/10e0393ceb569239f7ea1bfb2f3116df4effe747", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10e0393ceb569239f7ea1bfb2f3116df4effe747/comments", "author": null, "committer": null, "parents": [{"sha": "31bdd08a9d21a2fd7019bbd7b178c8911a7d2e41", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/31bdd08a9d21a2fd7019bbd7b178c8911a7d2e41", "html_url": "https://github.com/Rust-GCC/gccrs/commit/31bdd08a9d21a2fd7019bbd7b178c8911a7d2e41"}], "stats": {"total": 358, "additions": 218, "deletions": 140}, "files": [{"sha": "70cd06358b558668cdce63bb649d190c4cc8b8e2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10e0393ceb569239f7ea1bfb2f3116df4effe747/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10e0393ceb569239f7ea1bfb2f3116df4effe747/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=10e0393ceb569239f7ea1bfb2f3116df4effe747", "patch": "@@ -1,3 +1,30 @@\n+2015-09-15  Jeff Law  <law@redhat.com>\n+\n+        PR tree-optimization/47679\n+\t* tree-ssa-dom.c (expr_hash_elt): Now a class with ctors/dtors,\n+\tmethods and private members.\n+\t(avail_exprs_stack): Similarly.  Change type of global\n+\tfrom a pair of expr_hash_elt_t to the new class.\n+\t(expr_elt_hasher::hash): Corresponding changes.\n+\t(expr_elt_hasher::equal): Similarly.\n+\t(avail_expr_hash): Similarly.\n+\t(pass_dominator::execute): Similarly.\n+\t(dom_opt_dom_walker::thread_across_edge): Similarly.\n+\t(record_cond): Similarly.\n+\t(dom_opt_dom_walker::before_dom_children): Similarly.\n+\t(dom_opt_dom_walker::after_dom_children): Similarly.\n+\t(lookup_avail_expr): Likewise.\n+\t(initialize_hash_element): Now a expr_hash_elt constructor.\n+\t(initialize_hash_element_from_expr): Similarly.\n+\t(free_expr_hash_elt_contents): Now a dtor for class expr_hash_elt.\n+\t(free_expr_hash_elt): Call dtor for the element.\n+\t(remove_local_expressions_from_table): Now the \"pop_to_marker\"\n+\tmethod in the available_exprs_stack class.\n+\t(avail_expr_stack::record_expr): Method factored out.\n+\t(print_expr_hash_elt): Now a method in the expr_hash_elt class.\n+\tFix formatting.\n+\t(hashable_expr_equal_p): Fix formatting.\n+\n 2015-09-15  David Malcolm  <dmalcolm@redhat.com>\n \n \t* input.h (location_get_source_line): Drop \"expanded_location\""}, {"sha": "9e38541ab037184511691e565340b7f493fb2ef2", "filename": "gcc/tree-ssa-dom.c", "status": "modified", "additions": 191, "deletions": 140, "changes": 331, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10e0393ceb569239f7ea1bfb2f3116df4effe747/gcc%2Ftree-ssa-dom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10e0393ceb569239f7ea1bfb2f3116df4effe747/gcc%2Ftree-ssa-dom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.c?ref=10e0393ceb569239f7ea1bfb2f3116df4effe747", "patch": "@@ -121,28 +121,46 @@ struct edge_info\n    marker.  */\n typedef struct expr_hash_elt * expr_hash_elt_t;\n \n-static vec<std::pair<expr_hash_elt_t, expr_hash_elt_t> > avail_exprs_stack;\n \n /* Structure for entries in the expression hash table.  */\n \n-struct expr_hash_elt\n-{\n-  /* The value (lhs) of this expression.  */\n-  tree lhs;\n-\n+class expr_hash_elt\n+{\n+ public:\n+  expr_hash_elt (gimple, tree);\n+  expr_hash_elt (tree);\n+  expr_hash_elt (struct hashable_expr *, tree);\n+  expr_hash_elt (class expr_hash_elt &);\n+  ~expr_hash_elt ();\n+  void print (FILE *);\n+  tree vop (void) { return m_vop; }\n+  tree lhs (void) { return m_lhs; }\n+  struct hashable_expr *expr (void) { return &m_expr; }\n+  expr_hash_elt *stamp (void) { return m_stamp; }\n+  hashval_t hash (void) { return m_hash; }\n+\n+ private:\n   /* The expression (rhs) we want to record.  */\n-  struct hashable_expr expr;\n+  struct hashable_expr m_expr;\n+\n+  /* The value (lhs) of this expression.  */\n+  tree m_lhs;\n \n   /* The virtual operand associated with the nearest dominating stmt\n      loading from or storing to expr.  */\n-  tree vop;\n+  tree m_vop;\n \n   /* The hash value for RHS.  */\n-  hashval_t hash;\n+  hashval_t m_hash;\n \n   /* A unique stamp, typically the address of the hash\n      element itself, used in removing entries from the table.  */\n-  struct expr_hash_elt *stamp;\n+  struct expr_hash_elt *m_stamp;\n+\n+  /* We should never be making assignments between objects in this class.\n+     Though it might allow us to exploit C++11 move semantics if we\n+     defined the move constructor and move assignment operator.  */\n+  expr_hash_elt& operator=(const expr_hash_elt&);\n };\n \n /* Hashtable helpers.  */\n@@ -158,25 +176,56 @@ struct expr_elt_hasher : pointer_hash <expr_hash_elt>\n   static inline void remove (value_type &);\n };\n \n+/* This class defines a unwindable AVAIL_EXPRs, built on top of the\n+   available expression hash table.\n+\n+   Essentially it's just a stack of available expression value pairs with\n+   a special marker (NULL, NULL) to indicate unwind points.   */\n+\n+class avail_exprs_stack\n+{\n+ public:\n+  /* We need access to the AVAIL_EXPR hash table so that we can\n+     remove entries from the hash table when unwinding the stack.  */\n+  avail_exprs_stack (hash_table<expr_elt_hasher> *table)\n+    { m_stack.create (20); m_avail_exprs = table; }\n+  ~avail_exprs_stack (void) { m_stack.release (); }\n+\n+  /* Push the unwinding marker onto the stack.  */\n+  void push_marker (void) { record_expr (NULL, NULL, 'M'); }\n+\n+  /* Restore the AVAIL_EXPRs table to its state when the last marker\n+     was pushed.  */\n+  void pop_to_marker ();\n+\n+  /* Record a single available expression that can be unwound.  */\n+  void record_expr (expr_hash_elt_t, expr_hash_elt_t, char);\n+\n+ private:\n+  vec<std::pair<expr_hash_elt_t, expr_hash_elt_t> > m_stack;\n+  hash_table<expr_elt_hasher> *m_avail_exprs;\n+};\n+\n+\n inline hashval_t\n expr_elt_hasher::hash (const value_type &p)\n {\n-  return p->hash;\n+  return p->hash ();\n }\n \n inline bool\n expr_elt_hasher::equal (const value_type &p1, const compare_type &p2)\n {\n-  const struct hashable_expr *expr1 = &p1->expr;\n-  const struct expr_hash_elt *stamp1 = p1->stamp;\n-  const struct hashable_expr *expr2 = &p2->expr;\n-  const struct expr_hash_elt *stamp2 = p2->stamp;\n+  const struct hashable_expr *expr1 = p1->expr ();\n+  const struct expr_hash_elt *stamp1 = p1->stamp ();\n+  const struct hashable_expr *expr2 = p2->expr ();\n+  const struct expr_hash_elt *stamp2 = p2->stamp ();\n \n   /* This case should apply only when removing entries from the table.  */\n   if (stamp1 == stamp2)\n     return true;\n \n-  if (p1->hash != p2->hash)\n+  if (p1->hash () != p2->hash ())\n     return false;\n \n   /* In case of a collision, both RHS have to be identical and have the\n@@ -207,6 +256,7 @@ static hash_table<expr_elt_hasher> *avail_exprs;\n \n /* Unwindable const/copy equivalences.  */\n static const_and_copies *const_and_copies;\n+static avail_exprs_stack *avail_exprs_stack;\n \n /* Track whether or not we have changed the control flow graph.  */\n static bool cfg_altered;\n@@ -231,7 +281,7 @@ static struct opt_stats_d opt_stats;\n /* Local functions.  */\n static void optimize_stmt (basic_block, gimple_stmt_iterator);\n static tree lookup_avail_expr (gimple, bool);\n-static hashval_t avail_expr_hash (struct expr_hash_elt *);\n+static hashval_t avail_expr_hash (class expr_hash_elt *);\n static void htab_statistics (FILE *,\n \t\t\t     const hash_table<expr_elt_hasher> &);\n static void record_cond (cond_equivalence *);\n@@ -240,19 +290,16 @@ static void record_equivalences_from_phis (basic_block);\n static void record_equivalences_from_incoming_edge (basic_block);\n static void eliminate_redundant_computations (gimple_stmt_iterator *);\n static void record_equivalences_from_stmt (gimple, int);\n-static void remove_local_expressions_from_table (void);\n static edge single_incoming_edge_ignoring_loop_edges (basic_block);\n \n \n /* Given a statement STMT, initialize the hash table element pointed to\n    by ELEMENT.  */\n \n-static void\n-initialize_hash_element (gimple stmt, tree lhs,\n-                         struct expr_hash_elt *element)\n+expr_hash_elt::expr_hash_elt (gimple stmt, tree orig_lhs)\n {\n   enum gimple_code code = gimple_code (stmt);\n-  struct hashable_expr *expr = &element->expr;\n+  struct hashable_expr *expr = this->expr ();\n \n   if (code == GIMPLE_ASSIGN)\n     {\n@@ -342,17 +389,17 @@ initialize_hash_element (gimple stmt, tree lhs,\n       expr->kind = EXPR_PHI;\n       expr->ops.phi.nargs = nargs;\n       expr->ops.phi.args = XCNEWVEC (tree, nargs);\n-\n       for (i = 0; i < nargs; i++)\n         expr->ops.phi.args[i] = gimple_phi_arg_def (stmt, i);\n+\n     }\n   else\n     gcc_unreachable ();\n \n-  element->lhs = lhs;\n-  element->vop = gimple_vuse (stmt);\n-  element->hash = avail_expr_hash (element);\n-  element->stamp = element;\n+  m_lhs = orig_lhs;\n+  m_vop = gimple_vuse (stmt);\n+  m_hash = avail_expr_hash (this);\n+  m_stamp = this;\n }\n \n /* Given a conditional expression COND as a tree, initialize\n@@ -385,16 +432,50 @@ initialize_expr_from_cond (tree cond, struct hashable_expr *expr)\n /* Given a hashable_expr expression EXPR and an LHS,\n    initialize the hash table element pointed to by ELEMENT.  */\n \n-static void\n-initialize_hash_element_from_expr (struct hashable_expr *expr,\n-                                   tree lhs,\n-                                   struct expr_hash_elt *element)\n-{\n-  element->expr = *expr;\n-  element->lhs = lhs;\n-  element->vop = NULL_TREE;\n-  element->hash = avail_expr_hash (element);\n-  element->stamp = element;\n+expr_hash_elt::expr_hash_elt (struct hashable_expr *orig, tree orig_lhs)\n+{\n+  m_expr = *orig;\n+  m_lhs = orig_lhs;\n+  m_vop = NULL_TREE;\n+  m_hash = avail_expr_hash (this);\n+  m_stamp = this;\n+}\n+\n+expr_hash_elt::expr_hash_elt (class expr_hash_elt &old_elt)\n+{\n+  m_expr = old_elt.m_expr;\n+  m_lhs = old_elt.m_lhs;\n+  m_vop = old_elt.m_vop;\n+  m_hash = old_elt.m_hash;\n+  m_stamp = this;\n+\n+  /* Now deep copy the malloc'd space for CALL and PHI args.  */\n+  if (old_elt.m_expr.kind == EXPR_CALL)\n+    {\n+      size_t nargs = old_elt.m_expr.ops.call.nargs;\n+      size_t i;\n+\n+      m_expr.ops.call.args = XCNEWVEC (tree, nargs);\n+      for (i = 0; i < nargs; i++)\n+        m_expr.ops.call.args[i] = old_elt.m_expr.ops.call.args[i];\n+    }\n+  else if (old_elt.m_expr.kind == EXPR_PHI)\n+    {\n+      size_t nargs = old_elt.m_expr.ops.phi.nargs;\n+      size_t i;\n+\n+      m_expr.ops.phi.args = XCNEWVEC (tree, nargs);\n+      for (i = 0; i < nargs; i++)\n+        m_expr.ops.phi.args[i] = old_elt.m_expr.ops.phi.args[i];\n+    }\n+}\n+\n+expr_hash_elt::~expr_hash_elt ()\n+{\n+  if (m_expr.kind == EXPR_CALL)\n+    free (m_expr.ops.call.args);\n+  else if (m_expr.kind == EXPR_PHI)\n+    free (m_expr.ops.phi.args);\n }\n \n /* Compare two hashable_expr structures for equivalence.  They are\n@@ -404,7 +485,7 @@ initialize_hash_element_from_expr (struct hashable_expr *expr,\n \n static bool\n hashable_expr_equal_p (const struct hashable_expr *expr0,\n-                        const struct hashable_expr *expr1)\n+\t\t       const struct hashable_expr *expr1)\n {\n   tree type0 = expr0->type;\n   tree type1 = expr1->type;\n@@ -641,51 +722,51 @@ add_hashable_expr (const struct hashable_expr *expr, hash &hstate)\n \n /* Print a diagnostic dump of an expression hash table entry.  */\n \n-static void\n-print_expr_hash_elt (FILE * stream, const struct expr_hash_elt *element)\n+void\n+expr_hash_elt::print (FILE *stream)\n {\n   fprintf (stream, \"STMT \");\n \n-  if (element->lhs)\n+  if (m_lhs)\n     {\n-      print_generic_expr (stream, element->lhs, 0);\n+      print_generic_expr (stream, m_lhs, 0);\n       fprintf (stream, \" = \");\n     }\n \n-  switch (element->expr.kind)\n+  switch (m_expr.kind)\n     {\n       case EXPR_SINGLE:\n-        print_generic_expr (stream, element->expr.ops.single.rhs, 0);\n+        print_generic_expr (stream, m_expr.ops.single.rhs, 0);\n         break;\n \n       case EXPR_UNARY:\n-\tfprintf (stream, \"%s \", get_tree_code_name (element->expr.ops.unary.op));\n-        print_generic_expr (stream, element->expr.ops.unary.opnd, 0);\n+\tfprintf (stream, \"%s \", get_tree_code_name (m_expr.ops.unary.op));\n+        print_generic_expr (stream, m_expr.ops.unary.opnd, 0);\n         break;\n \n       case EXPR_BINARY:\n-        print_generic_expr (stream, element->expr.ops.binary.opnd0, 0);\n-\tfprintf (stream, \" %s \", get_tree_code_name (element->expr.ops.binary.op));\n-        print_generic_expr (stream, element->expr.ops.binary.opnd1, 0);\n+        print_generic_expr (stream, m_expr.ops.binary.opnd0, 0);\n+\tfprintf (stream, \" %s \", get_tree_code_name (m_expr.ops.binary.op));\n+        print_generic_expr (stream, m_expr.ops.binary.opnd1, 0);\n         break;\n \n       case EXPR_TERNARY:\n-\tfprintf (stream, \" %s <\", get_tree_code_name (element->expr.ops.ternary.op));\n-        print_generic_expr (stream, element->expr.ops.ternary.opnd0, 0);\n+\tfprintf (stream, \" %s <\", get_tree_code_name (m_expr.ops.ternary.op));\n+        print_generic_expr (stream, m_expr.ops.ternary.opnd0, 0);\n \tfputs (\", \", stream);\n-        print_generic_expr (stream, element->expr.ops.ternary.opnd1, 0);\n+        print_generic_expr (stream, m_expr.ops.ternary.opnd1, 0);\n \tfputs (\", \", stream);\n-        print_generic_expr (stream, element->expr.ops.ternary.opnd2, 0);\n+        print_generic_expr (stream, m_expr.ops.ternary.opnd2, 0);\n \tfputs (\">\", stream);\n         break;\n \n       case EXPR_CALL:\n         {\n           size_t i;\n-          size_t nargs = element->expr.ops.call.nargs;\n+          size_t nargs = m_expr.ops.call.nargs;\n           gcall *fn_from;\n \n-          fn_from = element->expr.ops.call.fn_from;\n+          fn_from = m_expr.ops.call.fn_from;\n           if (gimple_call_internal_p (fn_from))\n             fputs (internal_fn_name (gimple_call_internal_fn (fn_from)),\n                    stream);\n@@ -694,7 +775,7 @@ print_expr_hash_elt (FILE * stream, const struct expr_hash_elt *element)\n           fprintf (stream, \" (\");\n           for (i = 0; i < nargs; i++)\n             {\n-              print_generic_expr (stream, element->expr.ops.call.args[i], 0);\n+              print_generic_expr (stream, m_expr.ops.call.args[i], 0);\n               if (i + 1 < nargs)\n                 fprintf (stream, \", \");\n             }\n@@ -705,12 +786,12 @@ print_expr_hash_elt (FILE * stream, const struct expr_hash_elt *element)\n       case EXPR_PHI:\n         {\n           size_t i;\n-          size_t nargs = element->expr.ops.phi.nargs;\n+          size_t nargs = m_expr.ops.phi.nargs;\n \n           fprintf (stream, \"PHI <\");\n           for (i = 0; i < nargs; i++)\n             {\n-              print_generic_expr (stream, element->expr.ops.phi.args[i], 0);\n+              print_generic_expr (stream, m_expr.ops.phi.args[i], 0);\n               if (i + 1 < nargs)\n                 fprintf (stream, \", \");\n             }\n@@ -719,34 +800,22 @@ print_expr_hash_elt (FILE * stream, const struct expr_hash_elt *element)\n         break;\n     }\n \n-  if (element->vop)\n+  if (m_vop)\n     {\n       fprintf (stream, \" with \");\n-      print_generic_expr (stream, element->vop, 0);\n+      print_generic_expr (stream, m_vop, 0);\n     }\n \n   fprintf (stream, \"\\n\");\n }\n \n-/* Delete variable sized pieces of the expr_hash_elt ELEMENT.  */\n-\n-static void\n-free_expr_hash_elt_contents (struct expr_hash_elt *element)\n-{\n-  if (element->expr.kind == EXPR_CALL)\n-    free (element->expr.ops.call.args);\n-  else if (element->expr.kind == EXPR_PHI)\n-    free (element->expr.ops.phi.args);\n-}\n-\n /* Delete an expr_hash_elt and reclaim its storage.  */\n \n static void\n free_expr_hash_elt (void *elt)\n {\n-  struct expr_hash_elt *element = ((struct expr_hash_elt *)elt);\n-  free_expr_hash_elt_contents (element);\n-  free (element);\n+  class expr_hash_elt *element = ((class expr_hash_elt *)elt);\n+  delete element;\n }\n \n /* Allocate an EDGE_INFO for edge E and attach it to E.\n@@ -1163,7 +1232,7 @@ pass_dominator::execute (function *fun)\n \n   /* Create our hash tables.  */\n   avail_exprs = new hash_table<expr_elt_hasher> (1024);\n-  avail_exprs_stack.create (20);\n+  avail_exprs_stack = new class avail_exprs_stack (avail_exprs);\n   const_and_copies = new class const_and_copies ();\n   need_eh_cleanup = BITMAP_ALLOC (NULL);\n   need_noreturn_fixup.create (0);\n@@ -1286,7 +1355,7 @@ pass_dominator::execute (function *fun)\n   /* Free asserted bitmaps and stacks.  */\n   BITMAP_FREE (need_eh_cleanup);\n   need_noreturn_fixup.release ();\n-  avail_exprs_stack.release ();\n+  delete avail_exprs_stack;\n   delete const_and_copies;\n \n   /* Free the value-handle array.  */\n@@ -1354,14 +1423,13 @@ canonicalize_comparison (gcond *condstmt)\n /* Remove all the expressions in LOCALS from TABLE, stopping when there are\n    LIMIT entries left in LOCALs.  */\n \n-static void\n-remove_local_expressions_from_table (void)\n+void\n+avail_exprs_stack::pop_to_marker ()\n {\n   /* Remove all the expressions made available in this block.  */\n-  while (avail_exprs_stack.length () > 0)\n+  while (m_stack.length () > 0)\n     {\n-      std::pair<expr_hash_elt_t, expr_hash_elt_t> victim\n-\t= avail_exprs_stack.pop ();\n+      std::pair<expr_hash_elt_t, expr_hash_elt_t> victim = m_stack.pop ();\n       expr_hash_elt **slot;\n \n       if (victim.first == NULL)\n@@ -1373,21 +1441,36 @@ remove_local_expressions_from_table (void)\n       if (dump_file && (dump_flags & TDF_DETAILS))\n         {\n           fprintf (dump_file, \"<<<< \");\n-          print_expr_hash_elt (dump_file, victim.first);\n+\t  victim.first->print (dump_file);\n         }\n \n-      slot = avail_exprs->find_slot (victim.first, NO_INSERT);\n+      slot = m_avail_exprs->find_slot (victim.first, NO_INSERT);\n       gcc_assert (slot && *slot == victim.first);\n       if (victim.second != NULL)\n \t{\n \t  free_expr_hash_elt (*slot);\n \t  *slot = victim.second;\n \t}\n       else\n-\tavail_exprs->clear_slot (slot);\n+\tm_avail_exprs->clear_slot (slot);\n+    }\n+}\n+\n+void\n+avail_exprs_stack::record_expr (class expr_hash_elt *elt1,\n+\t\t\t\tclass expr_hash_elt *elt2,\n+\t\t\t\tchar type)\n+{\n+  if (elt1 && dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      fprintf (dump_file, \"%c>>> \", type);\n+      elt1->print (dump_file);\n     }\n+\n+  m_stack.safe_push (std::pair<expr_hash_elt_t, expr_hash_elt_t> (elt1, elt2));\n }\n \n+\n /* A trivial wrapper so that we can present the generic jump\n    threading code with a simple API for simplifying statements.  */\n static tree\n@@ -1522,8 +1605,7 @@ dom_opt_dom_walker::thread_across_edge (edge e)\n \n   /* Push a marker on both stacks so we can unwind the tables back to their\n      current state.  */\n-  avail_exprs_stack.safe_push\n-    (std::pair<expr_hash_elt_t, expr_hash_elt_t> (NULL, NULL));\n+  avail_exprs_stack->push_marker ();\n   const_and_copies->push_marker ();\n \n   /* Traversing E may result in equivalences we can utilize.  */\n@@ -1536,12 +1618,12 @@ dom_opt_dom_walker::thread_across_edge (edge e)\n \t\t        simplify_stmt_for_jump_threading);\n \n   /* And restore the various tables to their state before\n-     we threaded this edge. \n+     we threaded this edge.\n \n      XXX The code in tree-ssa-threadedge.c will restore the state of\n      the const_and_copies table.  We we just have to restore the expression\n      table.  */\n-  remove_local_expressions_from_table ();\n+  avail_exprs_stack->pop_to_marker ();\n }\n \n /* PHI nodes can create equivalences too.\n@@ -1699,24 +1781,15 @@ htab_statistics (FILE *file, const hash_table<expr_elt_hasher> &htab)\n static void\n record_cond (cond_equivalence *p)\n {\n-  struct expr_hash_elt *element = XCNEW (struct expr_hash_elt);\n+  class expr_hash_elt *element = new expr_hash_elt (&p->cond, p->value);\n   expr_hash_elt **slot;\n \n-  initialize_hash_element_from_expr (&p->cond, p->value, element);\n-\n-  slot = avail_exprs->find_slot_with_hash (element, element->hash, INSERT);\n+  slot = avail_exprs->find_slot_with_hash (element, element->hash (), INSERT);\n   if (*slot == NULL)\n     {\n       *slot = element;\n \n-      if (dump_file && (dump_flags & TDF_DETAILS))\n-        {\n-          fprintf (dump_file, \"1>>> \");\n-          print_expr_hash_elt (dump_file, element);\n-        }\n-\n-      avail_exprs_stack.safe_push\n-\t(std::pair<expr_hash_elt_t, expr_hash_elt_t> (element, NULL));\n+      avail_exprs_stack->record_expr (element, NULL, '1');\n     }\n   else\n     free_expr_hash_elt (element);\n@@ -1941,8 +2014,7 @@ dom_opt_dom_walker::before_dom_children (basic_block bb)\n \n   /* Push a marker on the stacks of local information so that we know how\n      far to unwind when we finalize this block.  */\n-  avail_exprs_stack.safe_push\n-    (std::pair<expr_hash_elt_t, expr_hash_elt_t> (NULL, NULL));\n+  avail_exprs_stack->push_marker ();\n   const_and_copies->push_marker ();\n \n   record_equivalences_from_incoming_edge (bb);\n@@ -1953,11 +2025,10 @@ dom_opt_dom_walker::before_dom_children (basic_block bb)\n   /* Create equivalences from redundant PHIs.  PHIs are only truly\n      redundant when they exist in the same block, so push another\n      marker and unwind right afterwards.  */\n-  avail_exprs_stack.safe_push\n-    (std::pair<expr_hash_elt_t, expr_hash_elt_t> (NULL, NULL));\n+  avail_exprs_stack->push_marker ();\n   for (gsi = gsi_start_phis (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n     eliminate_redundant_computations (&gsi);\n-  remove_local_expressions_from_table ();\n+  avail_exprs_stack->pop_to_marker ();\n \n   for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n     optimize_stmt (bb, gsi);\n@@ -2008,7 +2079,7 @@ dom_opt_dom_walker::after_dom_children (basic_block bb)\n     }\n \n   /* These remove expressions local to BB from the tables.  */\n-  remove_local_expressions_from_table ();\n+  avail_exprs_stack->pop_to_marker ();\n   const_and_copies->pop_to_marker ();\n }\n \n@@ -2550,60 +2621,49 @@ lookup_avail_expr (gimple stmt, bool insert)\n {\n   expr_hash_elt **slot;\n   tree lhs;\n-  struct expr_hash_elt element;\n \n   /* Get LHS of phi, assignment, or call; else NULL_TREE.  */\n   if (gimple_code (stmt) == GIMPLE_PHI)\n     lhs = gimple_phi_result (stmt);\n   else\n     lhs = gimple_get_lhs (stmt);\n \n-  initialize_hash_element (stmt, lhs, &element);\n+  class expr_hash_elt element (stmt, lhs);\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n       fprintf (dump_file, \"LKUP \");\n-      print_expr_hash_elt (dump_file, &element);\n+      element.print (dump_file);\n     }\n \n   /* Don't bother remembering constant assignments and copy operations.\n      Constants and copy operations are handled by the constant/copy propagator\n      in optimize_stmt.  */\n-  if (element.expr.kind == EXPR_SINGLE\n-      && (TREE_CODE (element.expr.ops.single.rhs) == SSA_NAME\n-          || is_gimple_min_invariant (element.expr.ops.single.rhs)))\n+  if (element.expr()->kind == EXPR_SINGLE\n+      && (TREE_CODE (element.expr()->ops.single.rhs) == SSA_NAME\n+          || is_gimple_min_invariant (element.expr()->ops.single.rhs)))\n     return NULL_TREE;\n \n   /* Finally try to find the expression in the main expression hash table.  */\n   slot = avail_exprs->find_slot (&element, (insert ? INSERT : NO_INSERT));\n   if (slot == NULL)\n     {\n-      free_expr_hash_elt_contents (&element);\n       return NULL_TREE;\n     }\n   else if (*slot == NULL)\n     {\n-      struct expr_hash_elt *element2 = XNEW (struct expr_hash_elt);\n-      *element2 = element;\n-      element2->stamp = element2;\n+      class expr_hash_elt *element2 = new expr_hash_elt (element);\n       *slot = element2;\n \n-      if (dump_file && (dump_flags & TDF_DETAILS))\n-        {\n-          fprintf (dump_file, \"2>>> \");\n-          print_expr_hash_elt (dump_file, element2);\n-        }\n-\n-      avail_exprs_stack.safe_push\n-\t(std::pair<expr_hash_elt_t, expr_hash_elt_t> (element2, NULL));\n+      avail_exprs_stack->record_expr (element2, NULL, '2');\n       return NULL_TREE;\n     }\n \n   /* If we found a redundant memory operation do an alias walk to\n      check if we can re-use it.  */\n-  if (gimple_vuse (stmt) != (*slot)->vop)\n+  if (gimple_vuse (stmt) != (*slot)->vop ())\n     {\n-      tree vuse1 = (*slot)->vop;\n+      tree vuse1 = (*slot)->vop ();\n       tree vuse2 = gimple_vuse (stmt);\n       /* If we have a load of a register and a candidate in the\n \t hash with vuse1 then try to reach its stmt by walking\n@@ -2619,30 +2679,21 @@ lookup_avail_expr (gimple stmt, bool insert)\n \t{\n \t  if (insert)\n \t    {\n-\t      struct expr_hash_elt *element2 = XNEW (struct expr_hash_elt);\n-\t      *element2 = element;\n-\t      element2->stamp = element2;\n+\t      class expr_hash_elt *element2 = new expr_hash_elt (element);\n \n \t      /* Insert the expr into the hash by replacing the current\n \t\t entry and recording the value to restore in the\n \t\t avail_exprs_stack.  */\n-\t      avail_exprs_stack.safe_push (std::make_pair (element2, *slot));\n+\t      avail_exprs_stack->record_expr (element2, *slot, '2');\n \t      *slot = element2;\n-\t      if (dump_file && (dump_flags & TDF_DETAILS))\n-\t\t{\n-\t\t  fprintf (dump_file, \"2>>> \");\n-\t\t  print_expr_hash_elt (dump_file, *slot);\n-\t\t}\n \t    }\n \t  return NULL_TREE;\n \t}\n     }\n \n-  free_expr_hash_elt_contents (&element);\n-\n   /* Extract the LHS of the assignment so that it can be used as the current\n      definition of another variable.  */\n-  lhs = (*slot)->lhs;\n+  lhs = (*slot)->lhs ();\n \n   lhs = dom_valueize (lhs);\n \n@@ -2661,9 +2712,9 @@ lookup_avail_expr (gimple stmt, bool insert)\n    its operands.  */\n \n static hashval_t\n-avail_expr_hash (struct expr_hash_elt *p)\n+avail_expr_hash (class expr_hash_elt *p)\n {\n-  const struct hashable_expr *expr = &p->expr;\n+  const struct hashable_expr *expr = p->expr ();\n   inchash::hash hstate;\n \n   inchash::add_hashable_expr (expr, hstate);"}]}