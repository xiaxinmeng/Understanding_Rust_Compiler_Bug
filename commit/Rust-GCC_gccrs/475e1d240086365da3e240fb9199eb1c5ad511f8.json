{"sha": "475e1d240086365da3e240fb9199eb1c5ad511f8", "node_id": "C_kwDOANBUbNoAKDQ3NWUxZDI0MDA4NjM2NWRhM2UyNDBmYjkxOTllYjFjNWFkNTExZjg", "commit": {"author": {"name": "Javier Miranda", "email": "miranda@adacore.com", "date": "2021-08-02T13:16:47Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2021-10-01T06:13:37Z"}, "message": "[Ada] Ada2022: AI12-0195 overriding class-wide pre/postconditions\n\ngcc/ada/\n\n\t* contracts.ads (Make_Class_Precondition_Subps): New subprogram.\n\t(Merge_Class_Conditions): New subprogram.\n\t(Process_Class_Conditions_At_Freeze_Point): New subprogram.\n\n\t* contracts.adb (Check_Class_Condition): New subprogram.\n\t(Set_Class_Condition): New subprogram.\n\t(Analyze_Contracts): Remove code analyzing class-wide-clone\n\tsubprogram since it is no longer built.\n\t(Process_Spec_Postconditions): Avoid processing twice seen\n\tsubprograms.\n\t(Process_Preconditions): Simplify its functionality to\n\tnon-class-wide preconditions.\n\t(Process_Preconditions_For): No action needed for wrappers and\n\thelpers.\n\t(Make_Class_Precondition_Subps): New subprogram.\n\t(Process_Class_Conditions_At_Freeze_Point): New subprogram.\n\t(Merge_Class_Conditions): New subprogram.\n\t* exp_ch6.ads (Install_Class_Preconditions_Check): New\n\tsubprogram.\n\t* exp_ch6.adb (Expand_Call_Helper): Install class-wide\n\tpreconditions check on dispatching primitives that have or\n\tinherit class-wide preconditions.\n\t(Freeze_Subprogram): Remove code for null procedures with\n\tpreconditions.\n\t(Install_Class_Preconditions_Check): New subprogram.\n\t* exp_util.ads (Build_Class_Wide_Expression): Lower the\n\tcomplexity of this subprogram; out-mode formal Needs_Wrapper\n\tsince this functionality is now provided by a new subprogram.\n\t(Get_Mapped_Entity): New subprogram.\n\t(Map_Formals): New subprogram.\n\t* exp_util.adb (Build_Class_Wide_Expression): Lower the\n\tcomplexity of this subprogram. Its previous functionality is now\n\tprovided by subprograms Needs_Wrapper and Check_Class_Condition.\n\t(Add_Parent_DICs): Map the overridden primitive to the\n\toverriding one.\n\t(Get_Mapped_Entity): New subprogram.\n\t(Map_Formals): New subprogram.\n\t(Update_Primitives_Mapping): Adding assertion.\n\t* freeze.ads (Check_Inherited_Conditions): Subprogram made\n\tpublic with added formal to support late overriding.\n\t* freeze.adb (Check_Inherited_Conditions): New implementation;\n\tbuilds the dispatch table wrapper required for class-wide\n\tpre/postconditions; added support for late overriding.\n\t(Needs_Wrapper): New subprogram.\n\t* sem.ads (Inside_Class_Condition_Preanalysis): New global\n\tvariable.\n\t* sem_disp.ads (Covered_Interface_Primitives): New subprogram.\n\t* sem_disp.adb (Covered_Interface_Primitives): New subprogram.\n\t(Check_Dispatching_Context): Skip checking context of\n\tdispatching calls during preanalysis of class-wide conditions\n\tsince at that stage the expression is not installed yet on its\n\tdefinite context.\n\t(Check_Dispatching_Call): Skip checking 6.1.1(18.2/5) by\n\tAI12-0412 on helpers and wrappers internally built for\n\tsupporting class-wide conditions; for late-overriding\n\tsubprograms call Check_Inherited_Conditions to build the\n\tdispatch-table wrapper (if required).\n\t(Propagate_Tag): Adding call to\n\tInstall_Class_Preconditions_Check.\n\t* sem_util.ads (Build_Class_Wide_Clone_Body): Removed.\n\t(Build_Class_Wide_Clone_Call): Removed.\n\t(Build_Class_Wide_Clone_Decl): Removed.\n\t(Class_Condition): New subprogram.\n\t(Nearest_Class_Condition_Subprogram): New subprogram.\n\t* sem_util.adb (Build_Class_Wide_Clone_Body): Removed.\n\t(Build_Class_Wide_Clone_Call): Removed.\n\t(Build_Class_Wide_Clone_Decl): Removed.\n\t(Class_Condition): New subprogram.\n\t(Nearest_Class_Condition_Subprogram): New subprogram.\n\t(Eligible_For_Conditional_Evaluation): No need to evaluate\n\tclass-wide conditions during preanalysis since the expression is\n\tnot installed on its definite context.\n\t* einfo.ads (Class_Wide_Clone): Removed.\n\t(Class_Postconditions): New attribute.\n\t(Class_Preconditions): New attribute.\n\t(Class_Preconditions_Subprogram): New attribute.\n\t(Dynamic_Call_Helper): New attribute.\n\t(Ignored_Class_Postconditions): New attribute.\n\t(Ignored_Class_Preconditions): New attribute.\n\t(Indirect_Call_Wrapper): New attribute.\n\t(Is_Dispatch_Table_Wrapper): New attribute.\n\t(Static_Call_Helper): New attribute.\n\t* exp_attr.adb (Expand_N_Attribute_Reference): When the prefix\n\tis of an access-to-subprogram type that has class-wide\n\tpreconditions and an indirect-call wrapper of such subprogram is\n\tavailable, replace the prefix by the wrapper.\n\t* exp_ch3.adb (Build_Class_Condition_Subprograms): New\n\tsubprogram.\n\t(Register_Dispatch_Table_Wrappers): New subprogram.\n\t* exp_disp.adb (Build_Class_Wide_Check): Removed; class-wide\n\tprecondition checks now rely on internally built helpers.\n\t* sem_ch13.adb (Analyze_Aspect_Specifications): Set initial\n\tvalue of attributes Class_Preconditions, Class_Postconditions,\n\tIgnored_Class_Preconditions and Ignored_Class_Postconditions.\n\tThese values are later updated with the full pre/postcondition\n\tby Merge_Class_Conditions.\n\t(Freeze_Entity_Checks): Call\n\tProcess_Class_Conditions_At_Freeze_Point.\n\t* sem_ch6.adb (Analyze_Subprogram_Body_Helper): Remove code\n\tbuilding the body of the class-wide clone subprogram since it is\n\tno longer required.\n\t(Install_Entity): Adding assertion.\n\t* sem_prag.adb (Analyze_Pre_Post_Condition_In_Decl_Part): Remove\n\tcode building and analyzing the class-wide clone subprogram; no\n\tlonger required.\n\t(Build_Pragma_Check_Equivalent): Adjust call to\n\tBuild_Class_Wide_Expression since the formal named Needs_Wrapper\n\thas been removed.\n\t* sem_attr.adb (Analyze_Attribute_Old_Result): Skip processing\n\tthese attributes during preanalysis of class-wide conditions\n\tsince at that stage the expression is not installed yet on its\n\tdefinite context.\n\t* sem_res.adb (Resolve_Actuals): Skip applying RM 3.9.2(9/1) and\n\tSPARK RM 6.1.7(3) on actuals of internal helpers and wrappers\n\tbuilt to support class-wide preconditions.\n\t* sem_ch5.adb (Process_Bounds): Do not generate a constant\n\tdeclaration for the bounds when we are preanalyzing a class-wide\n\tcondition.\n\t(Analyze_Loop_Parameter_Specification): Handle preanalysis of\n\tquantified expression placed in the outermost expression of a\n\tclass-wide condition.\n\t* ghost.adb (Check_Ghost_Context): No check required during\n\tpreanalysis of class-wide conditions.\n\t* gen_il-fields.ads (Opt_Field_Enum): Adding\n\tClass_Postconditions, Class_Preconditions,\n\tClass_Preconditions_Subprogram, Dynamic_Call_Helper,\n\tIgnored_Class_Postconditions, Ignored_Class_Preconditions,\n\tIndirect_Call_Wrapper, Is_Dispatch_Table_Wrapper,\n\tStatic_Call_Helper.\n\t* gen_il-gen-gen_entities.adb (Is_Dispatch_Table_Wrapper):\n\tAdding semantic flag Is_Dispatch_Table_Wrapper; removing\n\tsemantic field Class_Wide_Clone; adding semantic fields for\n\tClass_Postconditions, Class_Preconditions,\n\tClass_Preconditions_Subprogram, Dynamic_Call_Helper,\n\tIgnored_Class_Postconditions, Indirect_Call_Wrapper,\n\tIgnored_Class_Preconditions, and Static_Call_Helper.", "tree": {"sha": "af9747924c8d2abae7816f3e825da9f7e9b8e26a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/af9747924c8d2abae7816f3e825da9f7e9b8e26a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/475e1d240086365da3e240fb9199eb1c5ad511f8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/475e1d240086365da3e240fb9199eb1c5ad511f8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/475e1d240086365da3e240fb9199eb1c5ad511f8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/475e1d240086365da3e240fb9199eb1c5ad511f8/comments", "author": {"login": "miranda-adacore", "id": 54413934, "node_id": "MDQ6VXNlcjU0NDEzOTM0", "avatar_url": "https://avatars.githubusercontent.com/u/54413934?v=4", "gravatar_id": "", "url": "https://api.github.com/users/miranda-adacore", "html_url": "https://github.com/miranda-adacore", "followers_url": "https://api.github.com/users/miranda-adacore/followers", "following_url": "https://api.github.com/users/miranda-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/miranda-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/miranda-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/miranda-adacore/subscriptions", "organizations_url": "https://api.github.com/users/miranda-adacore/orgs", "repos_url": "https://api.github.com/users/miranda-adacore/repos", "events_url": "https://api.github.com/users/miranda-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/miranda-adacore/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fa465c1b609c0d9c5ad426cea803204c74dc277a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa465c1b609c0d9c5ad426cea803204c74dc277a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fa465c1b609c0d9c5ad426cea803204c74dc277a"}], "stats": {"total": 3856, "additions": 2843, "deletions": 1013}, "files": [{"sha": "2726486d2002b1c9148f9c8d2a1b98b560922c49", "filename": "gcc/ada/contracts.adb", "status": "modified", "additions": 1387, "deletions": 254, "changes": 1641, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/475e1d240086365da3e240fb9199eb1c5ad511f8/gcc%2Fada%2Fcontracts.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/475e1d240086365da3e240fb9199eb1c5ad511f8/gcc%2Fada%2Fcontracts.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fcontracts.adb?ref=475e1d240086365da3e240fb9199eb1c5ad511f8", "patch": "@@ -47,6 +47,8 @@ with Sem_Ch12;       use Sem_Ch12;\n with Sem_Ch13;       use Sem_Ch13;\n with Sem_Disp;       use Sem_Disp;\n with Sem_Prag;       use Sem_Prag;\n+with Sem_Res;        use Sem_Res;\n+with Sem_Type;       use Sem_Type;\n with Sem_Util;       use Sem_Util;\n with Sinfo;          use Sinfo;\n with Sinfo.Nodes;    use Sinfo.Nodes;\n@@ -66,6 +68,16 @@ package body Contracts is\n    --\n    --    Part_Of\n \n+   procedure Check_Class_Condition\n+     (Cond            : Node_Id;\n+      Subp            : Entity_Id;\n+      Par_Subp        : Entity_Id;\n+      Is_Precondition : Boolean);\n+   --  Perform checking of class-wide pre/postcondition Cond inherited by Subp\n+   --  from Par_Subp. Is_Precondition enables check specific for preconditions.\n+   --  In SPARK_Mode, an inherited operation that is not overridden but has\n+   --  inherited modified conditions pre/postconditions is illegal.\n+\n    procedure Check_Type_Or_Object_External_Properties\n      (Type_Or_Obj_Id : Entity_Id);\n    --  Perform checking of external properties pragmas that is common to both\n@@ -77,6 +89,12 @@ package body Contracts is\n    --  well as Contract_Cases, Subprogram_Variant, invariants and predicates.\n    --  Body_Id denotes the entity of the subprogram body.\n \n+   procedure Set_Class_Condition\n+     (Kind : Condition_Kind;\n+      Subp : Entity_Id;\n+      Cond : Node_Id);\n+   --  Set the class-wide Kind condition of Subp\n+\n    -----------------------\n    -- Add_Contract_Item --\n    -----------------------\n@@ -386,23 +404,7 @@ package body Contracts is\n                           | N_Generic_Subprogram_Declaration\n                           | N_Subprogram_Declaration\n          then\n-            declare\n-               Subp_Id : constant Entity_Id := Defining_Entity (Decl);\n-\n-            begin\n-               Analyze_Entry_Or_Subprogram_Contract (Subp_Id);\n-\n-               --  If analysis of a class-wide pre/postcondition indicates\n-               --  that a class-wide clone is needed, analyze its declaration\n-               --  now. Its body is created when the body of the original\n-               --  operation is analyzed (and rewritten).\n-\n-               if Is_Subprogram (Subp_Id)\n-                 and then Present (Class_Wide_Clone (Subp_Id))\n-               then\n-                  Analyze (Unit_Declaration_Node (Class_Wide_Clone (Subp_Id)));\n-               end if;\n-            end;\n+            Analyze_Entry_Or_Subprogram_Contract (Defining_Entity (Decl));\n \n          --  Entry or subprogram bodies\n \n@@ -1491,6 +1493,141 @@ package body Contracts is\n         (Type_Or_Obj_Id => Type_Id);\n    end Analyze_Type_Contract;\n \n+   ---------------------------\n+   -- Check_Class_Condition --\n+   ---------------------------\n+\n+   procedure Check_Class_Condition\n+     (Cond            : Node_Id;\n+      Subp            : Entity_Id;\n+      Par_Subp        : Entity_Id;\n+      Is_Precondition : Boolean)\n+   is\n+      function Check_Entity (N : Node_Id) return Traverse_Result;\n+      --  Check reference to formal of inherited operation or to primitive\n+      --  operation of root type.\n+\n+      ------------------\n+      -- Check_Entity --\n+      ------------------\n+\n+      function Check_Entity (N : Node_Id) return Traverse_Result is\n+         New_E  : Entity_Id;\n+         Orig_E : Entity_Id;\n+\n+      begin\n+         if Nkind (N) = N_Identifier\n+           and then Present (Entity (N))\n+           and then\n+             (Is_Formal (Entity (N)) or else Is_Subprogram (Entity (N)))\n+           and then\n+             (Nkind (Parent (N)) /= N_Attribute_Reference\n+               or else Attribute_Name (Parent (N)) /= Name_Class)\n+         then\n+            --  These checks do not apply to dispatching calls within the\n+            --  condition, but only to calls whose static tag is that of\n+            --  the parent type.\n+\n+            if Is_Subprogram (Entity (N))\n+              and then Nkind (Parent (N)) = N_Function_Call\n+              and then Present (Controlling_Argument (Parent (N)))\n+            then\n+               return OK;\n+            end if;\n+\n+            --  Determine whether entity has a renaming\n+\n+            Orig_E := Entity (N);\n+            New_E  := Get_Mapped_Entity (Orig_E);\n+\n+            if Present (New_E) then\n+\n+               --  AI12-0166: A precondition for a protected operation\n+               --  cannot include an internal call to a protected function\n+               --  of the type. In the case of an inherited condition for an\n+               --  overriding operation, both the operation and the function\n+               --  are given by primitive wrappers.\n+\n+               if Is_Precondition\n+                 and then Ekind (New_E) = E_Function\n+                 and then Is_Primitive_Wrapper (New_E)\n+                 and then Is_Primitive_Wrapper (Subp)\n+                 and then Scope (Subp) = Scope (New_E)\n+               then\n+                  Error_Msg_Node_2 := Wrapped_Entity (Subp);\n+                  Error_Msg_NE\n+                    (\"internal call to& cannot appear in inherited \"\n+                     & \"precondition of protected operation&\",\n+                     Subp, Wrapped_Entity (New_E));\n+               end if;\n+            end if;\n+\n+            --  Check that there are no calls left to abstract operations if\n+            --  the current subprogram is not abstract.\n+\n+            if Present (New_E)\n+              and then Nkind (Parent (N)) = N_Function_Call\n+              and then N = Name (Parent (N))\n+            then\n+               if not Is_Abstract_Subprogram (Subp)\n+                 and then Is_Abstract_Subprogram (New_E)\n+               then\n+                  Error_Msg_Sloc   := Sloc (Current_Scope);\n+                  Error_Msg_Node_2 := Subp;\n+\n+                  if Comes_From_Source (Subp) then\n+                     Error_Msg_NE\n+                       (\"cannot call abstract subprogram & in inherited \"\n+                        & \"condition for&#\", Subp, New_E);\n+                  else\n+                     Error_Msg_NE\n+                       (\"cannot call abstract subprogram & in inherited \"\n+                        & \"condition for inherited&#\", Subp, New_E);\n+                  end if;\n+\n+               --  In SPARK mode, report error on inherited condition for an\n+               --  inherited operation if it contains a call to an overriding\n+               --  operation, because this implies that the pre/postconditions\n+               --  of the inherited operation have changed silently.\n+\n+               elsif SPARK_Mode = On\n+                 and then Warn_On_Suspicious_Contract\n+                 and then Present (Alias (Subp))\n+                 and then Present (New_E)\n+                 and then Comes_From_Source (New_E)\n+               then\n+                  Error_Msg_N\n+                    (\"cannot modify inherited condition (SPARK RM 6.1.1(1))\",\n+                     Parent (Subp));\n+                  Error_Msg_Sloc   := Sloc (New_E);\n+                  Error_Msg_Node_2 := Subp;\n+                  Error_Msg_NE\n+                    (\"\\overriding of&# forces overriding of&\",\n+                     Parent (Subp), New_E);\n+               end if;\n+            end if;\n+         end if;\n+\n+         return OK;\n+      end Check_Entity;\n+\n+      procedure Check_Condition_Entities is\n+        new Traverse_Proc (Check_Entity);\n+\n+   --  Start of processing for Check_Class_Condition\n+\n+   begin\n+      --  No check required if the subprograms match\n+\n+      if Par_Subp = Subp then\n+         return;\n+      end if;\n+\n+      Update_Primitives_Mapping (Par_Subp, Subp);\n+      Map_Formals (Par_Subp, Subp);\n+      Check_Condition_Entities (Cond);\n+   end Check_Class_Condition;\n+\n    -----------------------------\n    -- Create_Generic_Contract --\n    -----------------------------\n@@ -1900,7 +2037,7 @@ package body Contracts is\n       procedure Add_Stable_Property_Contracts\n         (Subp_Id : Entity_Id; Class_Present : Boolean)\n       is\n-         Loc         : constant Source_Ptr := Sloc (Subp_Id);\n+         Loc : constant Source_Ptr := Sloc (Subp_Id);\n \n          procedure Insert_Stable_Property_Check\n            (Formal : Entity_Id; Property_Function : Entity_Id);\n@@ -2552,13 +2689,38 @@ package body Contracts is\n          ---------------------------------\n \n          procedure Process_Spec_Postconditions is\n-            Subps   : constant Subprogram_List :=\n-                        Inherited_Subprograms (Spec_Id);\n+            Subps : constant Subprogram_List :=\n+                      Inherited_Subprograms (Spec_Id);\n+            Seen  : Subprogram_List (Subps'Range) := (others => Empty);\n+\n+            function Seen_Subp (Subp_Id : Entity_Id) return Boolean;\n+            --  Return True if the contract of subprogram Subp_Id has been\n+            --  processed.\n+\n+            ---------------\n+            -- Seen_Subp --\n+            ---------------\n+\n+            function Seen_Subp (Subp_Id : Entity_Id) return Boolean is\n+            begin\n+               for Index in Seen'Range loop\n+                  if Seen (Index) = Subp_Id then\n+                     return True;\n+                  end if;\n+               end loop;\n+\n+               return False;\n+            end Seen_Subp;\n+\n+            --  Local variables\n+\n             Item    : Node_Id;\n             Items   : Node_Id;\n             Prag    : Node_Id;\n             Subp_Id : Entity_Id;\n \n+         --  Start of processing for Process_Spec_Postconditions\n+\n          begin\n             --  Process the contract\n \n@@ -2589,7 +2751,7 @@ package body Contracts is\n                   Subp_Id := Ultimate_Alias (Subp_Id);\n                end if;\n \n-               --  Wrappers of class-wide pre/post conditions reference the\n+               --  Wrappers of class-wide pre/postconditions reference the\n                --  parent primitive that has the inherited contract.\n \n                if Is_Wrapper (Subp_Id)\n@@ -2600,7 +2762,9 @@ package body Contracts is\n \n                Items := Contract (Subp_Id);\n \n-               if Present (Items) then\n+               if not Seen_Subp (Subp_Id) and then Present (Items) then\n+                  Seen (Index) := Subp_Id;\n+\n                   Prag := Pre_Post_Conditions (Items);\n                   while Present (Prag) loop\n                      if Pragma_Name (Prag) = Name_Postcondition\n@@ -2657,10 +2821,6 @@ package body Contracts is\n       ---------------------------\n \n       procedure Process_Preconditions is\n-         Class_Pre : Node_Id := Empty;\n-         --  The sole [inherited] class-wide precondition pragma that applies\n-         --  to the subprogram.\n-\n          Insert_Node : Node_Id := Empty;\n          --  The insertion node after which all pragma Check equivalents are\n          --  inserted.\n@@ -2669,21 +2829,12 @@ package body Contracts is\n          --  Determine whether arbitrary declaration Decl denotes a renaming of\n          --  a discriminant or protection field _object.\n \n-         procedure Merge_Preconditions (From : Node_Id; Into : Node_Id);\n-         --  Merge two class-wide preconditions by \"or else\"-ing them. The\n-         --  changes are accumulated in parameter Into. Update the error\n-         --  message of Into.\n-\n          procedure Prepend_To_Decls (Item : Node_Id);\n          --  Prepend a single item to the declarations of the subprogram body\n \n-         procedure Prepend_To_Decls_Or_Save (Prag : Node_Id);\n-         --  Save a class-wide precondition into Class_Pre, or prepend a normal\n-         --  precondition to the declarations of the body and analyze it.\n-\n-         procedure Process_Inherited_Preconditions;\n-         --  Collect all inherited class-wide preconditions and merge them into\n-         --  one big precondition to be evaluated as pragma Check.\n+         procedure Prepend_Pragma_To_Decls (Prag : Node_Id);\n+         --  Prepend a normal precondition to the declarations of the body and\n+         --  analyze it.\n \n          procedure Process_Preconditions_For (Subp_Id : Entity_Id);\n          --  Collect all preconditions of subprogram Subp_Id and prepend their\n@@ -2737,78 +2888,6 @@ package body Contracts is\n             return False;\n          end Is_Prologue_Renaming;\n \n-         -------------------------\n-         -- Merge_Preconditions --\n-         -------------------------\n-\n-         procedure Merge_Preconditions (From : Node_Id; Into : Node_Id) is\n-            function Expression_Arg (Prag : Node_Id) return Node_Id;\n-            --  Return the boolean expression argument of a precondition while\n-            --  updating its parentheses count for the subsequent merge.\n-\n-            function Message_Arg (Prag : Node_Id) return Node_Id;\n-            --  Return the message argument of a precondition\n-\n-            --------------------\n-            -- Expression_Arg --\n-            --------------------\n-\n-            function Expression_Arg (Prag : Node_Id) return Node_Id is\n-               Args : constant List_Id := Pragma_Argument_Associations (Prag);\n-               Arg  : constant Node_Id := Get_Pragma_Arg (Next (First (Args)));\n-\n-            begin\n-               if Paren_Count (Arg) = 0 then\n-                  Set_Paren_Count (Arg, 1);\n-               end if;\n-\n-               return Arg;\n-            end Expression_Arg;\n-\n-            -----------------\n-            -- Message_Arg --\n-            -----------------\n-\n-            function Message_Arg (Prag : Node_Id) return Node_Id is\n-               Args : constant List_Id := Pragma_Argument_Associations (Prag);\n-            begin\n-               return Get_Pragma_Arg (Last (Args));\n-            end Message_Arg;\n-\n-            --  Local variables\n-\n-            From_Expr : constant Node_Id := Expression_Arg (From);\n-            From_Msg  : constant Node_Id := Message_Arg    (From);\n-            Into_Expr : constant Node_Id := Expression_Arg (Into);\n-            Into_Msg  : constant Node_Id := Message_Arg    (Into);\n-            Loc       : constant Source_Ptr := Sloc (Into);\n-\n-         --  Start of processing for Merge_Preconditions\n-\n-         begin\n-            --  Merge the two preconditions by \"or else\"-ing them\n-\n-            Rewrite (Into_Expr,\n-              Make_Or_Else (Loc,\n-                Right_Opnd => Relocate_Node (Into_Expr),\n-                Left_Opnd  => From_Expr));\n-\n-            --  Merge the two error messages to produce a single message of the\n-            --  form:\n-\n-            --    failed precondition from ...\n-            --      also failed inherited precondition from ...\n-\n-            if not Exception_Locations_Suppressed then\n-               Start_String (Strval (Into_Msg));\n-               Store_String_Char (ASCII.LF);\n-               Store_String_Chars (\"  also \");\n-               Store_String_Chars (Strval (From_Msg));\n-\n-               Set_Strval (Into_Msg, End_String);\n-            end if;\n-         end Merge_Preconditions;\n-\n          ----------------------\n          -- Prepend_To_Decls --\n          ----------------------\n@@ -2829,28 +2908,27 @@ package body Contracts is\n             Prepend_To (Decls, Item);\n          end Prepend_To_Decls;\n \n-         ------------------------------\n-         -- Prepend_To_Decls_Or_Save --\n-         ------------------------------\n+         -----------------------------\n+         -- Prepend_Pragma_To_Decls --\n+         -----------------------------\n \n-         procedure Prepend_To_Decls_Or_Save (Prag : Node_Id) is\n+         procedure Prepend_Pragma_To_Decls (Prag : Node_Id) is\n             Check_Prag : Node_Id;\n \n          begin\n-            Check_Prag := Build_Pragma_Check_Equivalent (Prag);\n-\n-            --  Save the sole class-wide precondition (if any) for the next\n-            --  step, where it will be merged with inherited preconditions.\n+            --  Skip the sole class-wide precondition (if any) since it is\n+            --  processed by Merge_Class_Conditions.\n \n             if Class_Present (Prag) then\n-               pragma Assert (No (Class_Pre));\n-               Class_Pre := Check_Prag;\n+               null;\n \n             --  Accumulate the corresponding Check pragmas at the top of the\n             --  declarations. Prepending the items ensures that they will be\n             --  evaluated in their original order.\n \n             else\n+               Check_Prag := Build_Pragma_Check_Equivalent (Prag);\n+\n                if Present (Insert_Node) then\n                   Insert_After (Insert_Node, Check_Prag);\n                else\n@@ -2859,87 +2937,7 @@ package body Contracts is\n \n                Analyze (Check_Prag);\n             end if;\n-         end Prepend_To_Decls_Or_Save;\n-\n-         -------------------------------------\n-         -- Process_Inherited_Preconditions --\n-         -------------------------------------\n-\n-         procedure Process_Inherited_Preconditions is\n-            Subps : constant Subprogram_List :=\n-                      Inherited_Subprograms (Spec_Id);\n-\n-            Item    : Node_Id;\n-            Items   : Node_Id;\n-            Prag    : Node_Id;\n-            Subp_Id : Entity_Id;\n-\n-         begin\n-            --  Process the contracts of all inherited subprograms, looking for\n-            --  class-wide preconditions.\n-\n-            for Index in Subps'Range loop\n-               Subp_Id := Subps (Index);\n-\n-               if Present (Alias (Subp_Id)) then\n-                  Subp_Id := Ultimate_Alias (Subp_Id);\n-               end if;\n-\n-               --  Wrappers of class-wide pre/post conditions reference the\n-               --  parent primitive that has the inherited contract.\n-\n-               if Is_Wrapper (Subp_Id)\n-                 and then Present (LSP_Subprogram (Subp_Id))\n-               then\n-                  Subp_Id := LSP_Subprogram (Subp_Id);\n-               end if;\n-\n-               Items := Contract (Subp_Id);\n-\n-               if Present (Items) then\n-                  Prag := Pre_Post_Conditions (Items);\n-                  while Present (Prag) loop\n-                     if Pragma_Name (Prag) = Name_Precondition\n-                       and then Class_Present (Prag)\n-                     then\n-                        Item :=\n-                          Build_Pragma_Check_Equivalent\n-                            (Prag     => Prag,\n-                             Subp_Id  => Spec_Id,\n-                             Inher_Id => Subp_Id);\n-\n-                        --  The pragma Check equivalent of the class-wide\n-                        --  precondition is still created even though the\n-                        --  pragma may be ignored because the equivalent\n-                        --  performs semantic checks.\n-\n-                        if Is_Checked (Prag) then\n-\n-                           --  The spec of an inherited subprogram already\n-                           --  yielded a class-wide precondition. Merge the\n-                           --  existing precondition with the current one\n-                           --  using \"or else\".\n-\n-                           if Present (Class_Pre) then\n-                              Merge_Preconditions (Item, Class_Pre);\n-                           else\n-                              Class_Pre := Item;\n-                           end if;\n-                        end if;\n-                     end if;\n-\n-                     Prag := Next_Pragma (Prag);\n-                  end loop;\n-               end if;\n-            end loop;\n-\n-            --  Add the merged class-wide preconditions\n-\n-            if Present (Class_Pre) then\n-               Prepend_To_Decls (Class_Pre);\n-               Analyze (Class_Pre);\n-            end if;\n-         end Process_Inherited_Preconditions;\n+         end Prepend_Pragma_To_Decls;\n \n          -------------------------------\n          -- Process_Preconditions_For --\n@@ -2983,7 +2981,7 @@ package body Contracts is\n                            N      => Body_Decl);\n                      end if;\n \n-                     Prepend_To_Decls_Or_Save (Prag);\n+                     Prepend_Pragma_To_Decls (Prag);\n                   end if;\n \n                   Prag := Next_Pragma (Prag);\n@@ -3008,7 +3006,7 @@ package body Contracts is\n                      if Pragma_Name (Decl) = Name_Precondition\n                        and then Is_Checked (Decl)\n                      then\n-                        Prepend_To_Decls_Or_Save (Decl);\n+                        Prepend_Pragma_To_Decls (Decl);\n                      end if;\n \n                   --  Skip internally generated code\n@@ -3073,22 +3071,21 @@ package body Contracts is\n \n                Next (Decl);\n             end loop;\n-         end if;\n \n-         --  The processing of preconditions is done in reverse order (body\n-         --  first), because each pragma Check equivalent is inserted at the\n-         --  top of the declarations. This ensures that the final order is\n-         --  consistent with following diagram:\n+            --  The processing of preconditions is done in reverse order (body\n+            --  first), because each pragma Check equivalent is inserted at the\n+            --  top of the declarations. This ensures that the final order is\n+            --  consistent with following diagram:\n \n-         --    <inherited preconditions>\n-         --    <preconditions from spec>\n-         --    <preconditions from body>\n+            --    <inherited preconditions>\n+            --    <preconditions from spec>\n+            --    <preconditions from body>\n \n-         Process_Preconditions_For (Body_Id);\n+            Process_Preconditions_For (Body_Id);\n+         end if;\n \n          if Present (Spec_Id) then\n             Process_Preconditions_For (Spec_Id);\n-            Process_Inherited_Preconditions;\n          end if;\n       end Process_Preconditions;\n \n@@ -3139,6 +3136,12 @@ package body Contracts is\n       elsif Is_Ignored_Ghost_Entity (Subp_Id) then\n          return;\n \n+      --  No action needed for helpers and indirect-call wrapper built to\n+      --  support class-wide preconditions.\n+\n+      elsif Present (Class_Preconditions_Subprogram (Subp_Id)) then\n+         return;\n+\n       --  Do not re-expand the same contract. This scenario occurs when a\n       --  construct is rewritten into something else during its analysis\n       --  (expression functions for instance).\n@@ -3605,61 +3608,1191 @@ package body Contracts is\n       end if;\n    end Instantiate_Subprogram_Contract;\n \n-   ----------------------------------------\n-   -- Save_Global_References_In_Contract --\n-   ----------------------------------------\n+   -----------------------------------\n+   -- Make_Class_Precondition_Subps --\n+   -----------------------------------\n \n-   procedure Save_Global_References_In_Contract\n-     (Templ  : Node_Id;\n-      Gen_Id : Entity_Id)\n+   procedure Make_Class_Precondition_Subps\n+     (Subp_Id         : Entity_Id;\n+      Late_Overriding : Boolean := False)\n    is\n-      procedure Save_Global_References_In_List (First_Prag : Node_Id);\n-      --  Save all global references in contract-related source pragmas found\n-      --  in the list, starting with pragma First_Prag.\n+      Loc         : constant Source_Ptr := Sloc (Subp_Id);\n+      Tagged_Type : constant Entity_Id := Find_Dispatching_Type (Subp_Id);\n \n-      ------------------------------------\n-      -- Save_Global_References_In_List --\n-      ------------------------------------\n+      procedure Add_Indirect_Call_Wrapper;\n+      --  Build the indirect-call wrapper and append it to the freezing actions\n+      --  of Tagged_Type.\n \n-      procedure Save_Global_References_In_List (First_Prag : Node_Id) is\n-         Prag : Node_Id;\n+      procedure Add_Call_Helper\n+        (Helper_Id  : Entity_Id;\n+         Is_Dynamic : Boolean);\n+      --  Factorizes code for building a call helper with the given identifier\n+      --  and append it to the freezing actions of Tagged_Type. Is_Dynamic\n+      --  controls building the static or dynamic version of the helper.\n \n-      begin\n-         Prag := First_Prag;\n-         while Present (Prag) loop\n-            if Is_Generic_Contract_Pragma (Prag) then\n-               Save_Global_References (Prag);\n+      -------------------------------\n+      -- Add_Indirect_Call_Wrapper --\n+      -------------------------------\n+\n+      procedure Add_Indirect_Call_Wrapper is\n+\n+         function Build_ICW_Body return Node_Id;\n+         --  Build the body of the indirect call wrapper\n+\n+         function Build_ICW_Decl return Node_Id;\n+         --  Build the declaration of the indirect call wrapper\n+\n+         --------------------\n+         -- Build_ICW_Body --\n+         --------------------\n+\n+         function Build_ICW_Body return Node_Id is\n+            ICW_Id    : constant Entity_Id := Indirect_Call_Wrapper (Subp_Id);\n+            Spec      : constant Node_Id   := Parent (ICW_Id);\n+            Body_Spec : Node_Id;\n+            Call      : Node_Id;\n+            ICW_Body  : Node_Id;\n+\n+         begin\n+            Body_Spec := Copy_Subprogram_Spec (Spec);\n+\n+            --  Build call to wrapped subprogram\n+\n+            declare\n+               Actuals     : constant List_Id := Empty_List;\n+               Formal_Spec : Entity_Id :=\n+                               First (Parameter_Specifications (Spec));\n+            begin\n+               --  Build parameter association & call\n+\n+               while Present (Formal_Spec) loop\n+                  Append_To (Actuals,\n+                    New_Occurrence_Of\n+                      (Defining_Identifier (Formal_Spec), Loc));\n+                  Next (Formal_Spec);\n+               end loop;\n+\n+               if Ekind (ICW_Id) = E_Procedure then\n+                  Call :=\n+                    Make_Procedure_Call_Statement (Loc,\n+                      Name => New_Occurrence_Of (Subp_Id, Loc),\n+                      Parameter_Associations => Actuals);\n+               else\n+                  Call :=\n+                    Make_Simple_Return_Statement (Loc,\n+                      Expression =>\n+                        Make_Function_Call (Loc,\n+                          Name => New_Occurrence_Of (Subp_Id, Loc),\n+                          Parameter_Associations => Actuals));\n+               end if;\n+            end;\n+\n+            ICW_Body :=\n+              Make_Subprogram_Body (Loc,\n+                Specification              => Body_Spec,\n+                Declarations               => New_List,\n+                Handled_Statement_Sequence =>\n+                  Make_Handled_Sequence_Of_Statements (Loc,\n+                    Statements => New_List (Call)));\n+\n+            --  The new operation is internal and overriding indicators do not\n+            --  apply.\n+\n+            Set_Must_Override (Body_Spec, False);\n+\n+            return ICW_Body;\n+         end Build_ICW_Body;\n+\n+         --------------------\n+         -- Build_ICW_Decl --\n+         --------------------\n+\n+         function Build_ICW_Decl return Node_Id is\n+            ICW_Id : constant Entity_Id  :=\n+                       Make_Defining_Identifier (Loc,\n+                         New_External_Name (Chars (Subp_Id),\n+                           Suffix       => \"ICW\",\n+                           Suffix_Index => Source_Offset (Loc)));\n+            Decl   : Node_Id;\n+            Spec   : Node_Id;\n+\n+         begin\n+            Spec := Copy_Subprogram_Spec (Parent (Subp_Id));\n+            Set_Must_Override      (Spec, False);\n+            Set_Must_Not_Override  (Spec, False);\n+            Set_Defining_Unit_Name (Spec, ICW_Id);\n+            Mutate_Ekind  (ICW_Id, Ekind (Subp_Id));\n+            Set_Is_Public (ICW_Id);\n+\n+            --  The indirect call wrapper is commonly used for indirect calls\n+            --  but inlined for direct calls performed from the DTW.\n+\n+            Set_Is_Inlined (ICW_Id);\n+\n+            if Nkind (Spec) = N_Procedure_Specification then\n+               Set_Null_Present (Spec, False);\n             end if;\n \n-            Prag := Next_Pragma (Prag);\n-         end loop;\n-      end Save_Global_References_In_List;\n+            Decl := Make_Subprogram_Declaration (Loc, Spec);\n \n-      --  Local variables\n+            --  Link original subprogram to indirect wrapper and vice versa\n \n-      Items : constant Node_Id := Contract (Defining_Entity (Templ));\n+            Set_Indirect_Call_Wrapper (Subp_Id, ICW_Id);\n+            Set_Class_Preconditions_Subprogram (ICW_Id, Subp_Id);\n \n-   --  Start of processing for Save_Global_References_In_Contract\n+            --  Inherit debug info flag to allow debugging the wrapper\n \n-   begin\n-      --  The entity of the analyzed generic copy must be on the scope stack\n-      --  to ensure proper detection of global references.\n+            if Needs_Debug_Info (Subp_Id) then\n+               Set_Debug_Info_Needed (ICW_Id);\n+            end if;\n \n-      Push_Scope (Gen_Id);\n+            return Decl;\n+         end Build_ICW_Decl;\n \n-      if Permits_Aspect_Specifications (Templ)\n-        and then Has_Aspects (Templ)\n-      then\n-         Save_Global_References_In_Aspects (Templ);\n-      end if;\n+         --  Local Variables\n \n-      if Present (Items) then\n-         Save_Global_References_In_List (Pre_Post_Conditions (Items));\n-         Save_Global_References_In_List (Contract_Test_Cases (Items));\n-         Save_Global_References_In_List (Classifications     (Items));\n-      end if;\n+         ICW_Body : Node_Id;\n+         ICW_Decl : Node_Id;\n \n-      Pop_Scope;\n-   end Save_Global_References_In_Contract;\n+      --  Start of processing for Add_Indirect_Call_Wrapper\n+\n+      begin\n+         pragma Assert (No (Indirect_Call_Wrapper (Subp_Id)));\n+\n+         ICW_Decl := Build_ICW_Decl;\n+\n+         Ensure_Freeze_Node (Tagged_Type);\n+         Append_Freeze_Action (Tagged_Type, ICW_Decl);\n+         Analyze (ICW_Decl);\n+\n+         ICW_Body := Build_ICW_Body;\n+         Append_Freeze_Action (Tagged_Type, ICW_Body);\n+\n+         --  We cannot defer the analysis of this ICW wrapper when it is\n+         --  built as a consequence of building its partner DTW wrapper\n+         --  at the freezing point of the tagged type.\n+\n+         if Is_Dispatch_Table_Wrapper (Subp_Id) then\n+            Analyze (ICW_Body);\n+         end if;\n+      end Add_Indirect_Call_Wrapper;\n+\n+      ---------------------\n+      -- Add_Call_Helper --\n+      ---------------------\n+\n+      procedure Add_Call_Helper\n+        (Helper_Id  : Entity_Id;\n+         Is_Dynamic : Boolean)\n+      is\n+         function Build_Call_Helper_Body return Node_Id;\n+         --  Build the body of a call helper\n+\n+         function Build_Call_Helper_Decl return Node_Id;\n+         --  Build the declaration of a call helper\n+\n+         function Build_Call_Helper_Spec (Spec_Id : Entity_Id) return Node_Id;\n+         --  Build the specification of the helper\n+\n+         ----------------------------\n+         -- Build_Call_Helper_Body --\n+         ----------------------------\n+\n+         function Build_Call_Helper_Body return Node_Id is\n+\n+            function Copy_And_Update_References\n+              (Expr : Node_Id) return Node_Id;\n+            --  Copy Expr updating references to formals of Helper_Id; update\n+            --  also references to loop identifiers of quantified expressions.\n+\n+            --------------------------------\n+            -- Copy_And_Update_References --\n+            --------------------------------\n+\n+            function Copy_And_Update_References\n+              (Expr : Node_Id) return Node_Id\n+            is\n+               Assoc_List : constant Elist_Id := New_Elmt_List;\n+\n+               procedure Map_Quantified_Expression_Loop_Identifiers;\n+               --  Traverse Expr and append to Assoc_List the mapping of loop\n+               --  identifers of quantified expressions with its new copy.\n+\n+               ------------------------------------------------\n+               -- Map_Quantified_Expression_Loop_Identifiers --\n+               ------------------------------------------------\n+\n+               procedure Map_Quantified_Expression_Loop_Identifiers is\n+                  function Map_Loop_Param (N : Node_Id) return Traverse_Result;\n+                  --  Append to Assoc_List the mapping of loop identifers of\n+                  --  quantified expressions with its new copy.\n+\n+                  --------------------\n+                  -- Map_Loop_Param --\n+                  --------------------\n+\n+                  function Map_Loop_Param (N : Node_Id) return Traverse_Result\n+                  is\n+                  begin\n+                     if Nkind (N) = N_Loop_Parameter_Specification\n+                       and then Nkind (Parent (N)) = N_Quantified_Expression\n+                     then\n+                        declare\n+                           Def_Id : constant Entity_Id :=\n+                                      Defining_Identifier (N);\n+                        begin\n+                           Append_Elmt (Def_Id, Assoc_List);\n+                           Append_Elmt (New_Copy (Def_Id), Assoc_List);\n+                        end;\n+                     end if;\n+\n+                     return OK;\n+                  end Map_Loop_Param;\n+\n+                  procedure Map_Quantified_Expressions is\n+                     new Traverse_Proc (Map_Loop_Param);\n+\n+               begin\n+                  Map_Quantified_Expressions (Expr);\n+               end Map_Quantified_Expression_Loop_Identifiers;\n+\n+               --  Local variables\n+\n+               Subp_Formal_Id   : Entity_Id := First_Formal (Subp_Id);\n+               Helper_Formal_Id : Entity_Id := First_Formal (Helper_Id);\n+\n+            --  Start of processing for Copy_And_Update_References\n+\n+            begin\n+               while Present (Subp_Formal_Id) loop\n+                  Append_Elmt (Subp_Formal_Id,   Assoc_List);\n+                  Append_Elmt (Helper_Formal_Id, Assoc_List);\n+\n+                  Next_Formal (Subp_Formal_Id);\n+                  Next_Formal (Helper_Formal_Id);\n+               end loop;\n+\n+               Map_Quantified_Expression_Loop_Identifiers;\n+\n+               return New_Copy_Tree (Expr, Map => Assoc_List);\n+            end Copy_And_Update_References;\n+\n+            --  Local variables\n+\n+            Helper_Decl : constant Node_Id := Parent (Parent (Helper_Id));\n+            Body_Id     : Entity_Id;\n+            Body_Spec   : Node_Id;\n+            Body_Stmts  : Node_Id;\n+            Helper_Body : Node_Id;\n+            Return_Expr : Node_Id;\n+\n+         --  Start of processing for Build_Call_Helper_Body\n+\n+         begin\n+            pragma Assert (Analyzed (Unit_Declaration_Node (Helper_Id)));\n+            pragma Assert (No (Corresponding_Body (Helper_Decl)));\n+\n+            Body_Id   := Make_Defining_Identifier (Loc, Chars (Helper_Id));\n+            Body_Spec := Build_Call_Helper_Spec (Body_Id);\n+\n+            Set_Corresponding_Body (Helper_Decl, Body_Id);\n+            Set_Must_Override (Body_Spec, False);\n+\n+            if Present (Class_Preconditions (Subp_Id)) then\n+               Return_Expr :=\n+                 Copy_And_Update_References (Class_Preconditions (Subp_Id));\n+\n+            --  When the subprogram is compiled with assertions disabled the\n+            --  helper just returns True; done to avoid reporting errors at\n+            --  link time since a unit may be compiled with assertions disabled\n+            --  and another (which depends on it) compiled with assertions\n+            --  enabled.\n+\n+            else\n+               pragma Assert (Present (Ignored_Class_Preconditions (Subp_Id)));\n+               Return_Expr := New_Occurrence_Of (Standard_True, Loc);\n+            end if;\n+\n+            Body_Stmts :=\n+              Make_Handled_Sequence_Of_Statements (Loc,\n+                Statements => New_List (\n+                  Make_Simple_Return_Statement (Loc, Return_Expr)));\n+\n+            Helper_Body :=\n+              Make_Subprogram_Body (Loc,\n+                Specification              => Body_Spec,\n+                Declarations               => New_List,\n+                Handled_Statement_Sequence => Body_Stmts);\n+\n+            return Helper_Body;\n+         end Build_Call_Helper_Body;\n+\n+         ----------------------------\n+         -- Build_Call_Helper_Decl --\n+         ----------------------------\n+\n+         function Build_Call_Helper_Decl return Node_Id is\n+            Decl : Node_Id;\n+            Spec : Node_Id;\n+\n+         begin\n+            Spec := Build_Call_Helper_Spec (Helper_Id);\n+            Set_Must_Override      (Spec, False);\n+            Set_Must_Not_Override  (Spec, False);\n+            Set_Is_Inlined (Helper_Id);\n+            Set_Is_Public  (Helper_Id);\n+\n+            Decl := Make_Subprogram_Declaration (Loc, Spec);\n+\n+            --  Inherit debug info flag from Subp_Id to Helper_Id to allow\n+            --  debugging of the helper subprogram.\n+\n+            if Needs_Debug_Info (Subp_Id) then\n+               Set_Debug_Info_Needed (Helper_Id);\n+            end if;\n+\n+            return Decl;\n+         end Build_Call_Helper_Decl;\n+\n+         ----------------------------\n+         -- Build_Call_Helper_Spec --\n+         ----------------------------\n+\n+         function Build_Call_Helper_Spec (Spec_Id : Entity_Id) return Node_Id\n+         is\n+            Spec         : constant Node_Id := Parent (Subp_Id);\n+            Def_Id       : constant Node_Id := Defining_Unit_Name (Spec);\n+            Formal       : Entity_Id;\n+            Func_Formals : constant List_Id := New_List;\n+            P_Spec       : constant List_Id := Parameter_Specifications (Spec);\n+            Par_Formal   : Node_Id;\n+            Param        : Node_Id;\n+            Param_Type   : Node_Id;\n+\n+         begin\n+            --  Create a list of formal parameters with the same types as the\n+            --  original subprogram but changing the controlling formal.\n+\n+            Param  := First (P_Spec);\n+            Formal := First_Formal (Def_Id);\n+            while Present (Formal) loop\n+               Par_Formal := Parent (Formal);\n+\n+               if Is_Dynamic and then Is_Controlling_Formal (Formal) then\n+                  if Nkind (Parameter_Type (Par_Formal))\n+                    = N_Access_Definition\n+                  then\n+                     Param_Type :=\n+                       Copy_Separate_Tree (Parameter_Type (Par_Formal));\n+                     Rewrite (Subtype_Mark (Param_Type),\n+                       Make_Attribute_Reference (Loc,\n+                         Prefix => Relocate_Node (Subtype_Mark (Param_Type)),\n+                         Attribute_Name => Name_Class));\n+\n+                  else\n+                     Param_Type :=\n+                       Make_Attribute_Reference (Loc,\n+                         Prefix => New_Occurrence_Of (Etype (Formal), Loc),\n+                         Attribute_Name => Name_Class);\n+                  end if;\n+               else\n+                  Param_Type := New_Occurrence_Of (Etype (Formal), Loc);\n+               end if;\n+\n+               Append_To (Func_Formals,\n+                 Make_Parameter_Specification (Loc,\n+                   Defining_Identifier    =>\n+                     Make_Defining_Identifier (Loc, Chars (Formal)),\n+                   In_Present             => In_Present (Par_Formal),\n+                   Out_Present            => Out_Present (Par_Formal),\n+                   Null_Exclusion_Present => Null_Exclusion_Present\n+                                               (Par_Formal),\n+                   Parameter_Type         => Param_Type));\n+\n+               Next (Param);\n+               Next_Formal (Formal);\n+            end loop;\n+\n+            return\n+              Make_Function_Specification (Loc,\n+                Defining_Unit_Name       => Spec_Id,\n+                Parameter_Specifications => Func_Formals,\n+                Result_Definition        =>\n+                  New_Occurrence_Of (Standard_Boolean, Loc));\n+         end Build_Call_Helper_Spec;\n+\n+         --  Local variables\n+\n+         Helper_Body : Node_Id;\n+         Helper_Decl : Node_Id;\n+\n+      --  Start of processing for Add_Call_Helper\n+\n+      begin\n+         Helper_Decl := Build_Call_Helper_Decl;\n+         Mutate_Ekind (Helper_Id, Ekind (Subp_Id));\n+\n+         --  Add the helper to the freezing actions of the tagged type\n+\n+         Ensure_Freeze_Node   (Tagged_Type);\n+         Append_Freeze_Action (Tagged_Type, Helper_Decl);\n+         Analyze (Helper_Decl);\n+\n+         Helper_Body := Build_Call_Helper_Body;\n+         Append_Freeze_Action (Tagged_Type, Helper_Body);\n+\n+         --  If this helper is built as part of building the DTW at the\n+         --  freezing point of its tagged type then we cannot defer\n+         --  its analysis.\n+\n+         if Late_Overriding then\n+            pragma Assert (Is_Dispatch_Table_Wrapper (Subp_Id));\n+            Analyze (Helper_Body);\n+         end if;\n+      end Add_Call_Helper;\n+\n+      --  Local variables\n+\n+      Helper_Id : Entity_Id;\n+\n+   --  Start of processing for Make_Class_Precondition_Subps\n+\n+   begin\n+      if Present (Class_Preconditions (Subp_Id))\n+        or Present (Ignored_Class_Preconditions (Subp_Id))\n+      then\n+         pragma Assert\n+           (Comes_From_Source (Subp_Id)\n+              or else Is_Dispatch_Table_Wrapper (Subp_Id));\n+\n+         if No (Dynamic_Call_Helper (Subp_Id)) then\n+\n+            --  Build and add to the freezing actions of Tagged_Type its\n+            --  dynamic-call helper.\n+\n+            Helper_Id :=\n+              Make_Defining_Identifier (Loc,\n+                New_External_Name (Chars (Subp_Id),\n+                Suffix       => \"DP\",\n+                Suffix_Index => Source_Offset (Loc)));\n+            Add_Call_Helper (Helper_Id, Is_Dynamic => True);\n+\n+            --  Link original subprogram to helper and vice versa\n+\n+            Set_Dynamic_Call_Helper (Subp_Id, Helper_Id);\n+            Set_Class_Preconditions_Subprogram (Helper_Id, Subp_Id);\n+         end if;\n+\n+         if not Is_Abstract_Subprogram (Subp_Id)\n+           and then No (Static_Call_Helper (Subp_Id))\n+         then\n+            --  Build and add to the freezing actions of Tagged_Type its\n+            --  static-call helper.\n+\n+            Helper_Id :=\n+              Make_Defining_Identifier (Loc,\n+                New_External_Name (Chars (Subp_Id),\n+                Suffix       => \"SP\",\n+                Suffix_Index => Source_Offset (Loc)));\n+\n+            Add_Call_Helper (Helper_Id, Is_Dynamic => False);\n+\n+            --  Link original subprogram to helper and vice versa\n+\n+            Set_Static_Call_Helper (Subp_Id, Helper_Id);\n+            Set_Class_Preconditions_Subprogram (Helper_Id, Subp_Id);\n+\n+            --  Build and add to the freezing actions of Tagged_Type the\n+            --  indirect-call wrapper.\n+\n+            Add_Indirect_Call_Wrapper;\n+         end if;\n+      end if;\n+   end Make_Class_Precondition_Subps;\n+\n+   ----------------------------------------------\n+   -- Process_Class_Conditions_At_Freeze_Point --\n+   ----------------------------------------------\n+\n+   procedure Process_Class_Conditions_At_Freeze_Point (Typ : Entity_Id) is\n+\n+      procedure Check_Class_Conditions (Spec_Id : Entity_Id);\n+      --  Check class-wide pre/postconditions of Spec_Id\n+\n+      function Has_Class_Postconditions_Subprogram\n+        (Spec_Id : Entity_Id) return Boolean;\n+      --  Return True if Spec_Id has (or inherits) a postconditions subprogram.\n+\n+      function Has_Class_Preconditions_Subprogram\n+        (Spec_Id : Entity_Id) return Boolean;\n+      --  Return True if Spec_Id has (or inherits) a preconditions subprogram.\n+\n+      ----------------------------\n+      -- Check_Class_Conditions --\n+      ----------------------------\n+\n+      procedure Check_Class_Conditions (Spec_Id : Entity_Id) is\n+         Par_Subp : Entity_Id;\n+\n+      begin\n+         for Kind in Condition_Kind loop\n+            Par_Subp := Nearest_Class_Condition_Subprogram (Kind, Spec_Id);\n+\n+            if Present (Par_Subp) then\n+               Check_Class_Condition\n+                 (Cond            => Class_Condition (Kind, Par_Subp),\n+                  Subp            => Spec_Id,\n+                  Par_Subp        => Par_Subp,\n+                  Is_Precondition => Kind in Ignored_Class_Precondition\n+                                           | Class_Precondition);\n+            end if;\n+         end loop;\n+      end Check_Class_Conditions;\n+\n+      -----------------------------------------\n+      -- Has_Class_Postconditions_Subprogram --\n+      -----------------------------------------\n+\n+      function Has_Class_Postconditions_Subprogram\n+        (Spec_Id : Entity_Id) return Boolean is\n+      begin\n+         return\n+           Present (Nearest_Class_Condition_Subprogram\n+                     (Spec_Id => Spec_Id,\n+                      Kind    => Class_Postcondition))\n+             or else\n+           Present (Nearest_Class_Condition_Subprogram\n+                     (Spec_Id => Spec_Id,\n+                      Kind    => Ignored_Class_Postcondition));\n+      end Has_Class_Postconditions_Subprogram;\n+\n+      ----------------------------------------\n+      -- Has_Class_Preconditions_Subprogram --\n+      ----------------------------------------\n+\n+      function Has_Class_Preconditions_Subprogram\n+        (Spec_Id : Entity_Id) return Boolean is\n+      begin\n+         return\n+           Present (Nearest_Class_Condition_Subprogram\n+                     (Spec_Id => Spec_Id,\n+                      Kind    => Class_Precondition))\n+             or else\n+           Present (Nearest_Class_Condition_Subprogram\n+                     (Spec_Id => Spec_Id,\n+                      Kind    => Ignored_Class_Precondition));\n+      end Has_Class_Preconditions_Subprogram;\n+\n+      --  Local variables\n+\n+      Prim_Elmt : Elmt_Id := First_Elmt (Primitive_Operations (Typ));\n+      Prim      : Entity_Id;\n+\n+   --  Start of processing for Process_Class_Conditions_At_Freeze_Point\n+\n+   begin\n+      while Present (Prim_Elmt) loop\n+         Prim := Node (Prim_Elmt);\n+\n+         if Has_Class_Preconditions_Subprogram (Prim)\n+           or else Has_Class_Postconditions_Subprogram (Prim)\n+         then\n+            if Comes_From_Source (Prim) then\n+               if Has_Significant_Contract (Prim) then\n+                  Merge_Class_Conditions (Prim);\n+               end if;\n+\n+            --  Handle wrapper of protected operation\n+\n+            elsif Is_Primitive_Wrapper (Prim) then\n+               Merge_Class_Conditions (Prim);\n+\n+            --  Check inherited class-wide conditions, excluding internal\n+            --  entities built for mapping of interface primitives.\n+\n+            elsif Is_Derived_Type (Typ)\n+              and then Present (Alias (Prim))\n+              and then No (Interface_Alias (Prim))\n+            then\n+               Check_Class_Conditions (Prim);\n+            end if;\n+         end if;\n+\n+         Next_Elmt (Prim_Elmt);\n+      end loop;\n+   end Process_Class_Conditions_At_Freeze_Point;\n+\n+   ----------------------------\n+   -- Merge_Class_Conditions --\n+   ----------------------------\n+\n+   procedure Merge_Class_Conditions (Spec_Id : Entity_Id) is\n+\n+      procedure Preanalyze_Condition\n+        (Subp : Entity_Id;\n+         Expr : Node_Id);\n+      --  Preanalyze the class-wide condition Expr of Subp\n+\n+      procedure Process_Inherited_Conditions (Kind : Condition_Kind);\n+      --  Collect all inherited class-wide conditions of Spec_Id and merge\n+      --  them into one big condition.\n+\n+      --------------------------\n+      -- Preanalyze_Condition --\n+      --------------------------\n+\n+      procedure Preanalyze_Condition\n+        (Subp : Entity_Id;\n+         Expr : Node_Id)\n+      is\n+         procedure Clear_Unset_References;\n+         --  Clear unset references on formals of Subp since preanalysis\n+         --  occurs in a place unrelated to the actual code.\n+\n+         procedure Remove_Controlling_Arguments;\n+         --  Traverse Expr and clear the Controlling_Argument of calls to\n+         --  nonabstract functions.\n+\n+         procedure Remove_Formals (Id : Entity_Id);\n+         --  Remove formals from homonym chains and make them not visible\n+\n+         ----------------------------\n+         -- Clear_Unset_References --\n+         ----------------------------\n+\n+         procedure Clear_Unset_References is\n+            F : Entity_Id := First_Formal (Subp);\n+\n+         begin\n+            while Present (F) loop\n+               Set_Unset_Reference (F, Empty);\n+               Next_Formal (F);\n+            end loop;\n+         end Clear_Unset_References;\n+\n+         ----------------------------------\n+         -- Remove_Controlling_Arguments --\n+         ----------------------------------\n+\n+         procedure Remove_Controlling_Arguments is\n+            function Remove_Ctrl_Arg (N : Node_Id) return Traverse_Result;\n+            --  Reset the Controlling_Argument of calls to nonabstract\n+            --  function calls.\n+\n+            ---------------------\n+            -- Remove_Ctrl_Arg --\n+            ---------------------\n+\n+            function Remove_Ctrl_Arg (N : Node_Id) return Traverse_Result is\n+            begin\n+               if Nkind (N) = N_Function_Call\n+                 and then Present (Controlling_Argument (N))\n+                 and then not Is_Abstract_Subprogram (Entity (Name (N)))\n+               then\n+                  Set_Controlling_Argument (N, Empty);\n+               end if;\n+\n+               return OK;\n+            end Remove_Ctrl_Arg;\n+\n+            procedure Remove_Ctrl_Args is new Traverse_Proc (Remove_Ctrl_Arg);\n+         begin\n+            Remove_Ctrl_Args (Expr);\n+         end Remove_Controlling_Arguments;\n+\n+         --------------------\n+         -- Remove_Formals --\n+         --------------------\n+\n+         procedure Remove_Formals (Id : Entity_Id) is\n+            F : Entity_Id := First_Formal (Id);\n+\n+         begin\n+            while Present (F) loop\n+               Set_Is_Immediately_Visible (F, False);\n+               Remove_Homonym (F);\n+               Next_Formal (F);\n+            end loop;\n+         end Remove_Formals;\n+\n+      --  Start of processing for Preanalyze_Condition\n+\n+      begin\n+         pragma Assert (Present (Expr));\n+         pragma Assert (Inside_Class_Condition_Preanalysis = False);\n+\n+         Push_Scope (Subp);\n+         Install_Formals (Subp);\n+         Inside_Class_Condition_Preanalysis := True;\n+\n+         Preanalyze_And_Resolve (Expr, Standard_Boolean);\n+\n+         Inside_Class_Condition_Preanalysis := False;\n+         Remove_Formals (Subp);\n+         Pop_Scope;\n+\n+         --  Traverse Expr and clear the Controlling_Argument of calls to\n+         --  nonabstract functions. Required since the preanalyzed condition\n+         --  is not yet installed on its definite context and will be cloned\n+         --  and extended in derivations with additional conditions.\n+\n+         Remove_Controlling_Arguments;\n+\n+         --  Clear also attribute Unset_Reference; again because preanalysis\n+         --  occurs in a place unrelated to the actual code.\n+\n+         Clear_Unset_References;\n+      end Preanalyze_Condition;\n+\n+      ----------------------------------\n+      -- Process_Inherited_Conditions --\n+      ----------------------------------\n+\n+      procedure Process_Inherited_Conditions (Kind : Condition_Kind) is\n+         Tag_Typ : constant Entity_Id       := Find_Dispatching_Type (Spec_Id);\n+         Subps   : constant Subprogram_List := Inherited_Subprograms (Spec_Id);\n+         Seen    : Subprogram_List (Subps'Range) := (others => Empty);\n+\n+         function Inherit_Condition\n+           (Par_Subp : Entity_Id;\n+            Subp     : Entity_Id) return Node_Id;\n+         --  Inherit the class-wide condition from Par_Subp to Subp and adjust\n+         --  all the references to formals in the inherited condition.\n+\n+         procedure Merge_Conditions (From : Node_Id; Into : Node_Id);\n+         --  Merge two class-wide preconditions or postconditions (the former\n+         --  are merged using \"or else\", and the latter are merged using \"and-\n+         --  then\"). The changes are accumulated in parameter Into.\n+\n+         function Seen_Subp (Id : Entity_Id) return Boolean;\n+         --  Return True if the contract of subprogram Id has been processed\n+\n+         -----------------------\n+         -- Inherit_Condition --\n+         -----------------------\n+\n+         function Inherit_Condition\n+           (Par_Subp : Entity_Id;\n+            Subp     : Entity_Id) return Node_Id\n+         is\n+            Installed_Calls : constant Elist_Id := New_Elmt_List;\n+\n+            procedure Install_Original_Selected_Component (Expr : Node_Id);\n+            --  Traverse the given expression searching for dispatching calls\n+            --  to functions whose original nodes was a selected component,\n+            --  and replacing them temporarily by a copy of their original\n+            --  node. Modified calls are stored in the list Installed_Calls\n+            --  (to undo this work later).\n+\n+            procedure Restore_Dispatching_Calls (Expr : Node_Id);\n+            --  Undo the work done by Install_Original_Selected_Component.\n+\n+            -----------------------------------------\n+            -- Install_Original_Selected_Component --\n+            -----------------------------------------\n+\n+            procedure Install_Original_Selected_Component (Expr : Node_Id) is\n+               function Install_Node (N : Node_Id) return Traverse_Result;\n+               --  Process a single node\n+\n+               ------------------\n+               -- Install_Node --\n+               ------------------\n+\n+               function Install_Node (N : Node_Id) return Traverse_Result is\n+                  New_N    : Node_Id;\n+                  Orig_Nod : Node_Id;\n+\n+               begin\n+                  if Nkind (N) = N_Function_Call\n+                    and then Nkind (Original_Node (N)) = N_Selected_Component\n+                    and then Is_Dispatching_Operation (Entity (Name (N)))\n+                  then\n+                     Orig_Nod := Original_Node (N);\n+\n+                     --  Temporarily use the original node field to keep the\n+                     --  reference to this node (to undo this work later!).\n+\n+                     New_N := New_Copy (N);\n+                     Set_Original_Node (New_N, Orig_Nod);\n+                     Append_Elmt (New_N, Installed_Calls);\n+\n+                     Rewrite (N, Orig_Nod);\n+                     Set_Original_Node (N, New_N);\n+                  end if;\n+\n+                  return OK;\n+               end Install_Node;\n+\n+               procedure Install_Nodes is new Traverse_Proc (Install_Node);\n+\n+            begin\n+               Install_Nodes (Expr);\n+            end Install_Original_Selected_Component;\n+\n+            -------------------------------\n+            -- Restore_Dispatching_Calls --\n+            -------------------------------\n+\n+            procedure Restore_Dispatching_Calls (Expr : Node_Id) is\n+               function Restore_Node (N : Node_Id) return Traverse_Result;\n+               --  Process a single node\n+\n+               ------------------\n+               -- Restore_Node --\n+               ------------------\n+\n+               function Restore_Node (N : Node_Id) return Traverse_Result is\n+                  Orig_Sel_N : Node_Id;\n+\n+               begin\n+                  if Nkind (N) = N_Selected_Component\n+                    and then Nkind (Original_Node (N)) = N_Function_Call\n+                    and then Contains (Installed_Calls, Original_Node (N))\n+                  then\n+                     Orig_Sel_N := Original_Node (Original_Node (N));\n+                     pragma Assert (Nkind (Orig_Sel_N) = N_Selected_Component);\n+                     Rewrite (N, Original_Node (N));\n+                     Set_Original_Node (N, Orig_Sel_N);\n+                  end if;\n+\n+                  return OK;\n+               end Restore_Node;\n+\n+               procedure Restore_Nodes is new Traverse_Proc (Restore_Node);\n+\n+            begin\n+               Restore_Nodes (Expr);\n+            end Restore_Dispatching_Calls;\n+\n+            --  Local variables\n+\n+            Assoc_List     : constant Elist_Id := New_Elmt_List;\n+            Par_Formal_Id  : Entity_Id := First_Formal (Par_Subp);\n+            Subp_Formal_Id : Entity_Id := First_Formal (Subp);\n+            New_Expr       : Node_Id;\n+            Class_Cond     : Node_Id;\n+\n+         --  Start of processing for Inherit_Condition\n+\n+         begin\n+            while Present (Par_Formal_Id) loop\n+               Append_Elmt (Par_Formal_Id,  Assoc_List);\n+               Append_Elmt (Subp_Formal_Id, Assoc_List);\n+\n+               Next_Formal (Par_Formal_Id);\n+               Next_Formal (Subp_Formal_Id);\n+            end loop;\n+\n+            --  In order to properly preanalyze an inherited preanalyzed\n+            --  condition that has occurrences of the Object.Operation\n+            --  notation we must restore the original node; otherwise we\n+            --  would report spurious errors.\n+\n+            Class_Cond := Class_Condition (Kind, Par_Subp);\n+\n+            Install_Original_Selected_Component (Class_Cond);\n+            New_Expr := New_Copy_Tree (Class_Cond);\n+            Restore_Dispatching_Calls (Class_Cond);\n+\n+            return New_Copy_Tree (New_Expr, Map => Assoc_List);\n+         end Inherit_Condition;\n+\n+         ----------------------\n+         -- Merge_Conditions --\n+         ----------------------\n+\n+         procedure Merge_Conditions (From : Node_Id; Into : Node_Id) is\n+            function Expression_Arg (Expr : Node_Id) return Node_Id;\n+            --  Return the boolean expression argument of a condition while\n+            --  updating its parentheses count for the subsequent merge.\n+\n+            --------------------\n+            -- Expression_Arg --\n+            --------------------\n+\n+            function Expression_Arg (Expr : Node_Id) return Node_Id is\n+            begin\n+               if Paren_Count (Expr) = 0 then\n+                  Set_Paren_Count (Expr, 1);\n+               end if;\n+\n+               return Expr;\n+            end Expression_Arg;\n+\n+            --  Local variables\n+\n+            From_Expr : constant Node_Id := Expression_Arg (From);\n+            Into_Expr : constant Node_Id := Expression_Arg (Into);\n+            Loc       : constant Source_Ptr := Sloc (Into);\n+\n+         --  Start of processing for Merge_Conditions\n+\n+         begin\n+            case Kind is\n+\n+               --  Merge the two preconditions by \"or else\"-ing them\n+\n+               when Ignored_Class_Precondition\n+                  | Class_Precondition\n+               =>\n+                  Rewrite (Into_Expr,\n+                    Make_Or_Else (Loc,\n+                      Right_Opnd => Relocate_Node (Into_Expr),\n+                      Left_Opnd  => From_Expr));\n+\n+               --  Merge the two postconditions by \"and then\"-ing them\n+\n+               when Ignored_Class_Postcondition\n+                  | Class_Postcondition\n+               =>\n+                  Rewrite (Into_Expr,\n+                    Make_And_Then (Loc,\n+                      Right_Opnd => Relocate_Node (Into_Expr),\n+                      Left_Opnd  => From_Expr));\n+            end case;\n+         end Merge_Conditions;\n+\n+         ---------------\n+         -- Seen_Subp --\n+         ---------------\n+\n+         function Seen_Subp (Id : Entity_Id) return Boolean is\n+         begin\n+            for Index in Seen'Range loop\n+               if Seen (Index) = Id then\n+                  return True;\n+               end if;\n+            end loop;\n+\n+            return False;\n+         end Seen_Subp;\n+\n+         --  Local variables\n+\n+         Class_Cond      : Node_Id;\n+         Cond            : Node_Id;\n+         Subp_Id         : Entity_Id;\n+         Par_Prim        : Entity_Id := Empty;\n+         Par_Iface_Prims : Elist_Id  := No_Elist;\n+\n+      --  Start of processing for Process_Inherited_Conditions\n+\n+      begin\n+         Class_Cond := Class_Condition (Kind, Spec_Id);\n+\n+         --  Process parent primitives looking for nearest ancestor with\n+         --  class-wide conditions.\n+\n+         for Index in Subps'Range loop\n+            Subp_Id := Subps (Index);\n+\n+            if No (Par_Prim)\n+              and then Is_Ancestor (Find_Dispatching_Type (Subp_Id), Tag_Typ)\n+            then\n+               if Present (Alias (Subp_Id)) then\n+                  Subp_Id := Ultimate_Alias (Subp_Id);\n+               end if;\n+\n+               --  Wrappers of class-wide pre/postconditions reference the\n+               --  parent primitive that has the inherited contract and help\n+               --  us to climb fast.\n+\n+               if Is_Wrapper (Subp_Id)\n+                 and then Present (LSP_Subprogram (Subp_Id))\n+               then\n+                  Subp_Id := LSP_Subprogram (Subp_Id);\n+               end if;\n+\n+               if not Seen_Subp (Subp_Id)\n+                 and then Present (Class_Condition (Kind, Subp_Id))\n+               then\n+                  Seen (Index)    := Subp_Id;\n+                  Par_Prim        := Subp_Id;\n+                  Par_Iface_Prims := Covered_Interface_Primitives (Par_Prim);\n+\n+                  Cond := Inherit_Condition\n+                            (Subp     => Spec_Id,\n+                             Par_Subp => Subp_Id);\n+\n+                  if Present (Class_Cond) then\n+                     Merge_Conditions (Cond, Class_Cond);\n+                  else\n+                     Class_Cond := Cond;\n+                  end if;\n+\n+                  Check_Class_Condition\n+                    (Cond            => Class_Cond,\n+                     Subp            => Spec_Id,\n+                     Par_Subp        => Subp_Id,\n+                     Is_Precondition => Kind in Ignored_Class_Precondition\n+                                              | Class_Precondition);\n+                  Build_Class_Wide_Expression\n+                    (Pragma_Or_Expr  => Class_Cond,\n+                     Subp            => Spec_Id,\n+                     Par_Subp        => Subp_Id,\n+                     Adjust_Sloc     => False);\n+\n+                  --  We are done as soon as we process the nearest ancestor\n+\n+                  exit;\n+               end if;\n+            end if;\n+         end loop;\n+\n+         --  Process the contract of interface primitives not covered by\n+         --  the nearest ancestor.\n+\n+         for Index in Subps'Range loop\n+            Subp_Id := Subps (Index);\n+\n+            if Is_Interface (Find_Dispatching_Type (Subp_Id)) then\n+               if Present (Alias (Subp_Id)) then\n+                  Subp_Id := Ultimate_Alias (Subp_Id);\n+               end if;\n+\n+               if not Seen_Subp (Subp_Id)\n+                 and then Present (Class_Condition (Kind, Subp_Id))\n+                 and then not Contains (Par_Iface_Prims, Subp_Id)\n+               then\n+                  Seen (Index) := Subp_Id;\n+\n+                  Cond := Inherit_Condition\n+                            (Subp     => Spec_Id,\n+                             Par_Subp => Subp_Id);\n+\n+                  Check_Class_Condition\n+                    (Cond            => Cond,\n+                     Subp            => Spec_Id,\n+                     Par_Subp        => Subp_Id,\n+                     Is_Precondition => Kind in Ignored_Class_Precondition\n+                                              | Class_Precondition);\n+                  Build_Class_Wide_Expression\n+                    (Pragma_Or_Expr  => Cond,\n+                     Subp            => Spec_Id,\n+                     Par_Subp        => Subp_Id,\n+                     Adjust_Sloc     => False);\n+\n+                  if Present (Class_Cond) then\n+                     Merge_Conditions (Cond, Class_Cond);\n+                  else\n+                     Class_Cond := Cond;\n+                  end if;\n+               end if;\n+            end if;\n+         end loop;\n+\n+         Set_Class_Condition (Kind, Spec_Id, Class_Cond);\n+      end Process_Inherited_Conditions;\n+\n+      --  Local variables\n+\n+      Cond : Node_Id;\n+\n+   --  Start of processing for Merge_Class_Conditions\n+\n+   begin\n+      for Kind in Condition_Kind loop\n+         Cond := Class_Condition (Kind, Spec_Id);\n+\n+         --  If this subprogram has class-wide conditions then preanalyze\n+         --  them before processing inherited conditions since conditions\n+         --  are checked and merged from right to left.\n+\n+         if Present (Cond) then\n+            Preanalyze_Condition (Spec_Id, Cond);\n+         end if;\n+\n+         Process_Inherited_Conditions (Kind);\n+\n+         --  Preanalyze merged inherited conditions\n+\n+         if Cond /= Class_Condition (Kind, Spec_Id) then\n+            Preanalyze_Condition (Spec_Id,\n+              Class_Condition (Kind, Spec_Id));\n+         end if;\n+      end loop;\n+   end Merge_Class_Conditions;\n+\n+   ----------------------------------------\n+   -- Save_Global_References_In_Contract --\n+   ----------------------------------------\n+\n+   procedure Save_Global_References_In_Contract\n+     (Templ  : Node_Id;\n+      Gen_Id : Entity_Id)\n+   is\n+      procedure Save_Global_References_In_List (First_Prag : Node_Id);\n+      --  Save all global references in contract-related source pragmas found\n+      --  in the list, starting with pragma First_Prag.\n+\n+      ------------------------------------\n+      -- Save_Global_References_In_List --\n+      ------------------------------------\n+\n+      procedure Save_Global_References_In_List (First_Prag : Node_Id) is\n+         Prag : Node_Id := First_Prag;\n+\n+      begin\n+         while Present (Prag) loop\n+            if Is_Generic_Contract_Pragma (Prag) then\n+               Save_Global_References (Prag);\n+            end if;\n+\n+            Prag := Next_Pragma (Prag);\n+         end loop;\n+      end Save_Global_References_In_List;\n+\n+      --  Local variables\n+\n+      Items : constant Node_Id := Contract (Defining_Entity (Templ));\n+\n+   --  Start of processing for Save_Global_References_In_Contract\n+\n+   begin\n+      --  The entity of the analyzed generic copy must be on the scope stack\n+      --  to ensure proper detection of global references.\n+\n+      Push_Scope (Gen_Id);\n+\n+      if Permits_Aspect_Specifications (Templ)\n+        and then Has_Aspects (Templ)\n+      then\n+         Save_Global_References_In_Aspects (Templ);\n+      end if;\n+\n+      if Present (Items) then\n+         Save_Global_References_In_List (Pre_Post_Conditions (Items));\n+         Save_Global_References_In_List (Contract_Test_Cases (Items));\n+         Save_Global_References_In_List (Classifications     (Items));\n+      end if;\n+\n+      Pop_Scope;\n+   end Save_Global_References_In_Contract;\n+\n+   -------------------------\n+   -- Set_Class_Condition --\n+   -------------------------\n+\n+   procedure Set_Class_Condition\n+     (Kind : Condition_Kind;\n+      Subp : Entity_Id;\n+      Cond : Node_Id)\n+   is\n+   begin\n+      case Kind is\n+         when Class_Postcondition =>\n+            Set_Class_Postconditions (Subp, Cond);\n+\n+         when Class_Precondition =>\n+            Set_Class_Preconditions (Subp, Cond);\n+\n+         when Ignored_Class_Postcondition =>\n+            Set_Ignored_Class_Postconditions (Subp, Cond);\n+\n+         when Ignored_Class_Precondition =>\n+            Set_Ignored_Class_Preconditions (Subp, Cond);\n+      end case;\n+   end Set_Class_Condition;\n \n end Contracts;"}, {"sha": "eb26ebf1332d94505115158281346d0a79d0d408", "filename": "gcc/ada/contracts.ads", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/475e1d240086365da3e240fb9199eb1c5ad511f8/gcc%2Fada%2Fcontracts.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/475e1d240086365da3e240fb9199eb1c5ad511f8/gcc%2Fada%2Fcontracts.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fcontracts.ads?ref=475e1d240086365da3e240fb9199eb1c5ad511f8", "patch": "@@ -216,6 +216,31 @@ package Contracts is\n    --  subprogram declaration template denoted by Templ. The instantiated\n    --  pragmas are added to list L.\n \n+   procedure Make_Class_Precondition_Subps\n+     (Subp_Id         : Entity_Id;\n+      Late_Overriding : Boolean := False);\n+   --  Build helpers that at run time evaluate statically and dynamically the\n+   --  class-wide preconditions of Subp_Id; build also the indirect-call\n+   --  wrapper (ICW) required to check class-wide preconditions when the\n+   --  subprogram is invoked through an access-to-subprogram, or when it\n+   --  overrides an inherited class-wide precondition (see AI12-0195-1).\n+   --  Late_Overriding enables special handling required for late-overriding\n+   --  subprograms.\n+\n+   procedure Merge_Class_Conditions (Spec_Id : Entity_Id);\n+   --  Merge and preanalyze all class-wide conditions of Spec_Id (class-wide\n+   --  preconditions merged with operator or-else; class-wide postconditions\n+   --  merged with operator and-then). Ignored pre/postconditions are also\n+   --  merged since, although they are not required to generate code, their\n+   --  preanalysis is required to perform semantic checks. Resulting merged\n+   --  expressions are later installed by the expander in helper subprograms\n+   --  which are invoked from the caller side; they are also used to build\n+   --  the dispatch-table wrapper (DTW), if required.\n+\n+   procedure Process_Class_Conditions_At_Freeze_Point (Typ : Entity_Id);\n+   --  Merge, preanalyze, and check class-wide pre/postconditions of Typ\n+   --  primitives.\n+\n    procedure Save_Global_References_In_Contract\n      (Templ  : Node_Id;\n       Gen_Id : Entity_Id);"}, {"sha": "f890fe54230dbbe9e4d11116904111e5ffe03343", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 67, "deletions": 8, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/475e1d240086365da3e240fb9199eb1c5ad511f8/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/475e1d240086365da3e240fb9199eb1c5ad511f8/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=475e1d240086365da3e240fb9199eb1c5ad511f8", "patch": "@@ -610,12 +610,23 @@ package Einfo is\n --       tables must be consulted to determine if there actually is an active\n --       Suppress or Unsuppress pragma that applies to the entity.\n \n---    Class_Wide_Clone\n---       Defined on subprogram entities. Set if the subprogram has a class-wide\n---       pre- or postcondition, and the expression contains calls to other\n---       primitive funtions of the type. Used to implement properly the\n---       semantics of inherited operations whose class-wide condition may\n---       be different from that of the ancestor (See AI012-0195).\n+--    Class_Postconditions\n+--       Defined on subprogram entities. Set if the subprogram has class-wide\n+--       postconditions. Denotes the (and-then) expression built by merging\n+--       inherited class-wide postconditions with its own class-wide\n+--       postconditions.\n+\n+--    Class_Preconditions\n+--       Defined on subprogram entities. Set if the subprogram has class-wide\n+--       preconditions. Denotes the (or-else) expression built by merging\n+--       inherited class-wide preconditions with its own class-wide\n+--       preconditions.\n+\n+--    Class_Preconditions_Subprogram\n+--       Defined on subprogram entities. Set on subprogram helpers and also on\n+--       the indirect-call wrapper internally built for subprograms that have\n+--       class-wide preconditions. References the subprogram that has the\n+--       class-wide preconditions.\n \n --    Class_Wide_Type\n --       Defined in all type entities. For a tagged type or subtype, returns\n@@ -1029,6 +1040,11 @@ package Einfo is\n --       associated with the tagged type. For an untagged record, contains\n --       No_Elist.\n \n+--    Dynamic_Call_Helper\n+--       Defined on subprogram entities. Set if the subprogram has class-wide\n+--       preconditions. Denotes the helper that evaluates at run time the\n+--       class-wide preconditions performing dispatching calls.\n+\n --    DTC_Entity\n --       Defined in function and procedure entities. Set to Empty unless\n --       the subprogram is dispatching in which case it references the\n@@ -2182,6 +2198,18 @@ package Einfo is\n --       \"off\" and indicates that all SPARK_Mode pragmas found within must\n --       be ignored.\n \n+--    Ignored_Class_Postconditions\n+--       Defined on subprogram entities. Set if the subprogram has class-wide\n+--       postconditions. Denotes the (and-then) expression built by merging\n+--       inherited ignored class-wide postconditions with its own ignored\n+--       class-wide postconditions.\n+\n+--    Ignored_Class_Preconditions\n+--       Defined on subprogram entities. Set if the subprogram has class-wide\n+--       preconditions. Denotes the (or-else) expression built by merging\n+--       inherited ignored class-wide preconditions with its own ignored\n+--       class-wide preconditions.\n+\n --    Implementation_Base_Type (synthesized)\n --       Applies to all entities. For types, similar to Base_Type, but never\n --       returns a private type when applied to a non-private type. Instead in\n@@ -2216,6 +2244,12 @@ package Einfo is\n --       is relocated to the corresponding package body, which must have a\n --       corresponding nonlimited with_clause.\n \n+--    Indirect_Call_Wrapper\n+--       Defined on subprogram entities. Set if the subprogram has class-wide\n+--       preconditions. Denotes the internal wrapper that checks preconditions\n+--       and invokes the subprogram body. Subp'Access points to the indirect\n+--       call wrapper if available.\n+\n --    Initialization_Statements\n --       Defined in constants and variables. For a composite object initialized\n --       with an aggregate that has been converted to a sequence of\n@@ -2507,6 +2541,11 @@ package Einfo is\n --       Applies to all entities. Set to indicate to the backend that this\n --       entity is associated with a dispatch table.\n \n+--    Is_Dispatch_Table_Wrapper\n+--       Applies to all entities. Set on wrappers built when the subprogram has\n+--       class-wide preconditions or class-wide postconditions affected by\n+--       overriding (AI12-0195).\n+\n --    Is_Dispatching_Operation\n --       Defined in all entities. Set for procedures, functions, generic\n --       procedures, and generic functions if the corresponding operation\n@@ -4401,6 +4440,11 @@ package Einfo is\n --       Default_Scalar_Storage_Order (High_Order_First) was active at the time\n --       the record or array was declared and therefore applies to it.\n \n+--    Static_Call_Helper\n+--       Defined on subprogram entities. Set if the subprogram has class-wide\n+--       preconditions. Denotes the helper that evaluates at runtime the\n+--       class-wide preconditions performing static calls.\n+\n --    Static_Discrete_Predicate\n --       Defined in discrete types/subtypes with static predicates (with the\n --       two flags Has_Predicates and Has_Static_Predicate set). Set if the\n@@ -4878,6 +4922,7 @@ package Einfo is\n    --    Is_Discrim_SO_Function\n    --    Is_Discriminant_Check_Function\n    --    Is_Dispatch_Table_Entity\n+   --    Is_Dispatch_Table_Wrapper\n    --    Is_Dispatching_Operation\n    --    Is_Entry_Formal\n    --    Is_Exported\n@@ -5484,7 +5529,14 @@ package Einfo is\n    --    Linker_Section_Pragma\n    --    Contract\n    --    Import_Pragma                        (non-generic case only)\n-   --    Class_Wide_Clone\n+   --    Class_Postconditions\n+   --    Class_Preconditions\n+   --    Class_Preconditions_Subprogram\n+   --    Dynamic_Call_Helper\n+   --    Ignored_Class_Preconditions\n+   --    Ignored_Class_Postconditions\n+   --    Indirect_Call_Wrapper\n+   --    Static_Call_Helper\n    --    Protected_Subprogram                 (non-generic case only)\n    --    SPARK_Pragma\n    --    Original_Protected_Subprogram\n@@ -5840,7 +5892,14 @@ package Einfo is\n    --    Linker_Section_Pragma\n    --    Contract\n    --    Import_Pragma                        (non-generic case only)\n-   --    Class_Wide_Clone\n+   --    Class_Postconditions\n+   --    Class_Preconditions\n+   --    Class_Preconditions_Subprogram\n+   --    Dynamic_Call_Helper\n+   --    Ignored_Class_Preconditions\n+   --    Ignored_Class_Postconditions\n+   --    Indirect_Call_Wrapper\n+   --    Static_Call_Helper\n    --    Protected_Subprogram                 (non-generic case only)\n    --    SPARK_Pragma\n    --    Original_Protected_Subprogram"}, {"sha": "3e7bb838118c12062ca97e0985c5683f3de345e2", "filename": "gcc/ada/exp_attr.adb", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/475e1d240086365da3e240fb9199eb1c5ad511f8/gcc%2Fada%2Fexp_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/475e1d240086365da3e240fb9199eb1c5ad511f8/gcc%2Fada%2Fexp_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_attr.adb?ref=475e1d240086365da3e240fb9199eb1c5ad511f8", "patch": "@@ -2216,6 +2216,20 @@ package body Exp_Attr is\n             if Is_Access_Protected_Subprogram_Type (Btyp) then\n                Expand_Access_To_Protected_Op (N, Pref, Typ);\n \n+            --  If prefix is a subprogram that has class-wide preconditions and\n+            --  an indirect-call wrapper (ICW) of such subprogram is available\n+            --  then replace the prefix by the ICW.\n+\n+            elsif Is_Access_Subprogram_Type (Btyp)\n+              and then Is_Entity_Name (Pref)\n+              and then Present (Class_Preconditions (Entity (Pref)))\n+              and then Present (Indirect_Call_Wrapper (Entity (Pref)))\n+            then\n+               Rewrite (Pref,\n+                 New_Occurrence_Of\n+                   (Indirect_Call_Wrapper (Entity (Pref)), Loc));\n+               Analyze_And_Resolve (N, Typ);\n+\n             --  If prefix is a type name, this is a reference to the current\n             --  instance of the type, within its initialization procedure.\n "}, {"sha": "418306f304074b6872a91037a642c5d051850fa7", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/475e1d240086365da3e240fb9199eb1c5ad511f8/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/475e1d240086365da3e240fb9199eb1c5ad511f8/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=475e1d240086365da3e240fb9199eb1c5ad511f8", "patch": "@@ -26,6 +26,7 @@\n with Aspects;        use Aspects;\n with Atree;          use Atree;\n with Checks;         use Checks;\n+with Contracts;      use Contracts;\n with Einfo;          use Einfo;\n with Einfo.Entities; use Einfo.Entities;\n with Einfo.Utils;    use Einfo.Utils;\n@@ -5352,10 +5353,66 @@ package body Exp_Ch3 is\n    -------------------------------\n \n    procedure Expand_Freeze_Record_Type (N : Node_Id) is\n+\n+      procedure Build_Class_Condition_Subprograms (Typ : Entity_Id);\n+      --  Create internal subprograms of Typ primitives that have class-wide\n+      --  preconditions or postconditions; they are invoked by the caller to\n+      --  evaluate the conditions.\n+\n       procedure Build_Variant_Record_Equality (Typ  : Entity_Id);\n       --  Create An Equality function for the untagged variant record Typ and\n       --  attach it to the TSS list.\n \n+      procedure Register_Dispatch_Table_Wrappers (Typ : Entity_Id);\n+      --  Register dispatch-table wrappers in the dispatch table of Typ\n+\n+      ---------------------------------------\n+      -- Build_Class_Condition_Subprograms --\n+      ---------------------------------------\n+\n+      procedure Build_Class_Condition_Subprograms (Typ : Entity_Id) is\n+         Prim_List : constant Elist_Id := Primitive_Operations (Typ);\n+         Prim_Elmt : Elmt_Id           := First_Elmt (Prim_List);\n+         Prim      : Entity_Id;\n+\n+      begin\n+         while Present (Prim_Elmt) loop\n+            Prim := Node (Prim_Elmt);\n+\n+            --  Primitive with class-wide preconditions\n+\n+            if Comes_From_Source (Prim)\n+              and then Has_Significant_Contract (Prim)\n+              and then\n+                (Present (Class_Preconditions (Prim))\n+                   or else Present (Ignored_Class_Preconditions (Prim)))\n+            then\n+               if Expander_Active then\n+                  Make_Class_Precondition_Subps (Prim);\n+               end if;\n+\n+            --  Wrapper of a primitive that has or inherits class-wide\n+            --  preconditions.\n+\n+            elsif Is_Primitive_Wrapper (Prim)\n+              and then\n+                (Present (Nearest_Class_Condition_Subprogram\n+                           (Spec_Id => Prim,\n+                            Kind    => Class_Precondition))\n+                   or else\n+                 Present (Nearest_Class_Condition_Subprogram\n+                           (Spec_Id => Prim,\n+                            Kind    => Ignored_Class_Precondition)))\n+            then\n+               if Expander_Active then\n+                  Make_Class_Precondition_Subps (Prim);\n+               end if;\n+            end if;\n+\n+            Next_Elmt (Prim_Elmt);\n+         end loop;\n+      end Build_Class_Condition_Subprograms;\n+\n       -----------------------------------\n       -- Build_Variant_Record_Equality --\n       -----------------------------------\n@@ -5417,6 +5474,27 @@ package body Exp_Ch3 is\n          end if;\n       end Build_Variant_Record_Equality;\n \n+      --------------------------------------\n+      -- Register_Dispatch_Table_Wrappers --\n+      --------------------------------------\n+\n+      procedure Register_Dispatch_Table_Wrappers (Typ : Entity_Id) is\n+         Elmt : Elmt_Id := First_Elmt (Primitive_Operations (Typ));\n+         Subp : Entity_Id;\n+\n+      begin\n+         while Present (Elmt) loop\n+            Subp := Node (Elmt);\n+\n+            if Is_Dispatch_Table_Wrapper (Subp) then\n+               Append_Freeze_Actions (Typ,\n+                 Register_Primitive (Sloc (Subp), Subp));\n+            end if;\n+\n+            Next_Elmt (Elmt);\n+         end loop;\n+      end Register_Dispatch_Table_Wrappers;\n+\n       --  Local variables\n \n       Typ      : constant Node_Id := Entity (N);\n@@ -5666,6 +5744,13 @@ package body Exp_Ch3 is\n \n                if not Building_Static_DT (Typ) then\n                   Append_Freeze_Actions (Typ, Make_DT (Typ));\n+\n+                  --  Register dispatch table wrappers in the dispatch table.\n+                  --  It could not be done when these wrappers were built\n+                  --  because, at that stage, the dispatch table was not\n+                  --  available.\n+\n+                  Register_Dispatch_Table_Wrappers (Typ);\n                end if;\n             end if;\n \n@@ -5857,6 +5942,13 @@ package body Exp_Ch3 is\n             end loop;\n          end;\n       end if;\n+\n+      --  Build internal subprograms of primitives with class-wide\n+      --  pre/postconditions.\n+\n+      if Is_Tagged_Type (Typ) then\n+         Build_Class_Condition_Subprograms (Typ);\n+      end if;\n    end Expand_Freeze_Record_Type;\n \n    ------------------------------------"}, {"sha": "ffd14759a7f15b323d69b274063ee302247ecb1b", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 374, "deletions": 13, "changes": 387, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/475e1d240086365da3e240fb9199eb1c5ad511f8/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/475e1d240086365da3e240fb9199eb1c5ad511f8/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=475e1d240086365da3e240fb9199eb1c5ad511f8", "patch": "@@ -73,8 +73,10 @@ with Sem_Util;       use Sem_Util;\n with Sinfo;          use Sinfo;\n with Sinfo.Nodes;    use Sinfo.Nodes;\n with Sinfo.Utils;    use Sinfo.Utils;\n+with Sinput;         use Sinput;\n with Snames;         use Snames;\n with Stand;          use Stand;\n+with Stringt;        use Stringt;\n with Tbuild;         use Tbuild;\n with Uintp;          use Uintp;\n with Validsw;        use Validsw;\n@@ -4065,7 +4067,7 @@ package body Exp_Ch6 is\n             end;\n          end if;\n \n-         --  If the formal is class wide and the actual is an aggregate, force\n+         --  If the formal is class-wide and the actual is an aggregate, force\n          --  evaluation so that the back end who does not know about class-wide\n          --  type, does not generate a temporary of the wrong size.\n \n@@ -4250,6 +4252,16 @@ package body Exp_Ch6 is\n          Expand_Interface_Actuals (Call_Node);\n       end if;\n \n+      --  Install class-wide preconditions runtime check when this is a\n+      --  dispatching primitive that has or inherits class-wide preconditions;\n+      --  otherwise no runtime check is installed.\n+\n+      if Nkind (Call_Node) in N_Subprogram_Call\n+        and then Is_Dispatching_Operation (Subp)\n+      then\n+         Install_Class_Preconditions_Check (Call_Node);\n+      end if;\n+\n       --  Deals with Dispatch_Call if we still have a call, before expanding\n       --  extra actuals since this will be done on the re-analysis of the\n       --  dispatching call. Note that we do not try to shorten the actual list\n@@ -7855,18 +7867,6 @@ package body Exp_Ch6 is\n       --  returned type may not be known yet (for private types).\n \n       Compute_Returns_By_Ref (Subp);\n-\n-      --  When freezing a null procedure, analyze its delayed aspects now\n-      --  because we may not have reached the end of the declarative list when\n-      --  delayed aspects are normally analyzed. This ensures that dispatching\n-      --  calls are properly rewritten when the generated _Postcondition\n-      --  procedure is analyzed in the null procedure body.\n-\n-      if Nkind (Parent (Subp)) = N_Procedure_Specification\n-        and then Null_Present (Parent (Subp))\n-      then\n-         Analyze_Entry_Or_Subprogram_Contract (Subp);\n-      end if;\n    end Freeze_Subprogram;\n \n    --------------------------\n@@ -8101,6 +8101,367 @@ package body Exp_Ch6 is\n       end if;\n    end Insert_Post_Call_Actions;\n \n+   ---------------------------------------\n+   -- Install_Class_Preconditions_Check --\n+   ---------------------------------------\n+\n+   procedure Install_Class_Preconditions_Check (Call_Node : Node_Id) is\n+      Loc : constant Source_Ptr := Sloc (Call_Node);\n+\n+      function Build_Dynamic_Check_Helper_Call return Node_Id;\n+      --  Build call to the helper runtime function of the nearest ancestor\n+      --  of the target subprogram that dynamically evaluates the merged\n+      --  or-else preconditions.\n+\n+      function Build_Error_Message (Subp_Id : Entity_Id) return Node_Id;\n+      --  Build message associated with the class-wide precondition of Subp_Id\n+      --  indicating the call that caused it.\n+\n+      function Build_Static_Check_Helper_Call return Node_Id;\n+      --  Build call to the helper runtime function of the nearest ancestor\n+      --  of the target subprogram that dynamically evaluates the merged\n+      --  or-else preconditions.\n+\n+      function Class_Preconditions_Subprogram\n+        (Spec_Id : Entity_Id;\n+         Dynamic : Boolean) return Node_Id;\n+      --  Return the nearest ancestor of Spec_Id defining a helper function\n+      --  that evaluates a combined or-else expression containing all the\n+      --  inherited class-wide preconditions; Dynamic enables searching for\n+      --  the helper that dynamically evaluates preconditions using dispatching\n+      --  calls; if False it searches for the helper that statically evaluates\n+      --  preconditions; return Empty when not available (which means that no\n+      --  preconditions check is required).\n+\n+      -------------------------------------\n+      -- Build_Dynamic_Check_Helper_Call --\n+      -------------------------------------\n+\n+      function Build_Dynamic_Check_Helper_Call return Node_Id is\n+         Spec_Id   : constant Entity_Id := Entity (Name (Call_Node));\n+         CW_Subp   : constant Entity_Id :=\n+                       Class_Preconditions_Subprogram (Spec_Id,\n+                         Dynamic => True);\n+         Helper_Id : constant Entity_Id :=\n+                       Dynamic_Call_Helper (CW_Subp);\n+         Actuals   : constant List_Id := New_List;\n+         A         : Node_Id   := First_Actual (Call_Node);\n+         F         : Entity_Id := First_Formal (Helper_Id);\n+\n+      begin\n+         while Present (A) loop\n+\n+            --  Ensure that the evaluation of the actuals will not produce\n+            --  side effects.\n+\n+            Remove_Side_Effects (A);\n+\n+            Append_To (Actuals, New_Copy_Tree (A));\n+            Next_Formal (F);\n+            Next_Actual (A);\n+         end loop;\n+\n+         return\n+           Make_Function_Call (Loc,\n+             Name => New_Occurrence_Of (Helper_Id, Loc),\n+             Parameter_Associations => Actuals);\n+      end Build_Dynamic_Check_Helper_Call;\n+\n+      -------------------------\n+      -- Build_Error_Message --\n+      -------------------------\n+\n+      function Build_Error_Message (Subp_Id : Entity_Id) return Node_Id is\n+\n+         procedure Append_Message\n+           (Id       : Entity_Id;\n+            Is_First : in out Boolean);\n+         --  Build the fragment of the message associated with subprogram Id;\n+         --  Is_First facilitates identifying continuation messages.\n+\n+         --------------------\n+         -- Append_Message --\n+         --------------------\n+\n+         procedure Append_Message\n+           (Id       : Entity_Id;\n+            Is_First : in out Boolean)\n+         is\n+            Prag   : constant Node_Id := Get_Class_Wide_Pragma (Id,\n+                                         Pragma_Precondition);\n+            Msg    : Node_Id;\n+            Str_Id : String_Id;\n+\n+         begin\n+            if No (Prag) or else Is_Ignored (Prag) then\n+               return;\n+            end if;\n+\n+            Msg    := Expression (Last (Pragma_Argument_Associations (Prag)));\n+            Str_Id := Strval (Msg);\n+\n+            if Is_First then\n+               Is_First := False;\n+\n+               Append (Global_Name_Buffer, Strval (Msg));\n+\n+               if Id /= Subp_Id\n+                 and then Name_Buffer (1 .. 19) = \"failed precondition\"\n+               then\n+                  Insert_Str_In_Name_Buffer (\"inherited \", 8);\n+               end if;\n+\n+            else\n+               declare\n+                  Str      : constant String := To_String (Str_Id);\n+                  From_Idx : Integer;\n+\n+               begin\n+                  Append (Global_Name_Buffer, ASCII.LF);\n+                  Append (Global_Name_Buffer, \"  or \");\n+\n+                  From_Idx := Name_Len;\n+                  Append (Global_Name_Buffer, Str_Id);\n+\n+                  if Str (1 .. 19) = \"failed precondition\" then\n+                     Insert_Str_In_Name_Buffer (\"inherited \", From_Idx + 8);\n+                  end if;\n+               end;\n+            end if;\n+         end Append_Message;\n+\n+         --  Local variables\n+\n+         Str_Loc  : constant String := Build_Location_String (Loc);\n+         Subps    : constant Subprogram_List :=\n+                      Inherited_Subprograms (Subp_Id);\n+         Is_First : Boolean := True;\n+\n+      --  Start of processing for Build_Error_Message\n+\n+      begin\n+         Name_Len := 0;\n+         Append_Message (Subp_Id, Is_First);\n+\n+         for Index in Subps'Range loop\n+            Append_Message (Subps (Index), Is_First);\n+         end loop;\n+\n+         if Present (Controlling_Argument (Call_Node)) then\n+            Append (Global_Name_Buffer, \" in dispatching call at \");\n+         else\n+            Append (Global_Name_Buffer, \" in call at \");\n+         end if;\n+\n+         Append (Global_Name_Buffer, Str_Loc);\n+\n+         return Make_String_Literal (Loc, Name_Buffer (1 .. Name_Len));\n+      end Build_Error_Message;\n+\n+      ------------------------------------\n+      -- Build_Static_Check_Helper_Call --\n+      ------------------------------------\n+\n+      function Build_Static_Check_Helper_Call return Node_Id is\n+         Actuals   : constant List_Id := New_List;\n+         A         : Node_Id;\n+         Helper_Id : Entity_Id;\n+         F         : Entity_Id;\n+         CW_Subp   : Entity_Id;\n+         Spec_Id   : constant Entity_Id := Entity (Name (Call_Node));\n+\n+      begin\n+         --  The target is the wrapper built to support inheriting body but\n+         --  overriding pre/postconditions (AI12-0195).\n+\n+         if Is_Dispatch_Table_Wrapper (Spec_Id) then\n+            CW_Subp := Spec_Id;\n+\n+         --  Common case\n+\n+         else\n+            CW_Subp := Class_Preconditions_Subprogram (Spec_Id,\n+                         Dynamic => False);\n+         end if;\n+\n+         Helper_Id := Static_Call_Helper (CW_Subp);\n+\n+         F := First_Formal (Helper_Id);\n+         A := First_Actual (Call_Node);\n+         while Present (A) loop\n+\n+            --  Ensure that the evaluation of the actuals will not produce\n+            --  side effects.\n+\n+            Remove_Side_Effects (A);\n+\n+            if Is_Controlling_Actual (A)\n+              and then Etype (F) /= Etype (A)\n+            then\n+               Append_To (Actuals,\n+                 Make_Unchecked_Type_Conversion (Loc,\n+                   New_Occurrence_Of (Etype (F), Loc),\n+                   New_Copy_Tree (A)));\n+            else\n+               Append_To (Actuals, New_Copy_Tree (A));\n+            end if;\n+\n+            Next_Formal (F);\n+            Next_Actual (A);\n+         end loop;\n+\n+         return\n+           Make_Function_Call (Loc,\n+             Name => New_Occurrence_Of (Helper_Id, Loc),\n+             Parameter_Associations => Actuals);\n+      end Build_Static_Check_Helper_Call;\n+\n+      ------------------------------------\n+      -- Class_Preconditions_Subprogram --\n+      ------------------------------------\n+\n+      function Class_Preconditions_Subprogram\n+        (Spec_Id : Entity_Id;\n+         Dynamic : Boolean) return Node_Id\n+      is\n+         Subp_Id : constant Entity_Id := Ultimate_Alias (Spec_Id);\n+\n+      begin\n+         --  Prevent cascaded errors\n+\n+         if not Is_Dispatching_Operation (Subp_Id) then\n+            return Empty;\n+\n+         --  No need to search if this subprogram has the helper we are\n+         --  searching\n+\n+         elsif Dynamic then\n+            if Present (Dynamic_Call_Helper (Subp_Id)) then\n+               return Subp_Id;\n+            end if;\n+         else\n+            if Present (Static_Call_Helper (Subp_Id)) then\n+               return Subp_Id;\n+            end if;\n+         end if;\n+\n+         --  Process inherited subprograms looking for class-wide\n+         --  preconditions.\n+\n+         declare\n+            Subps   : constant Subprogram_List :=\n+                        Inherited_Subprograms (Subp_Id);\n+            Subp_Id : Entity_Id;\n+\n+         begin\n+            for Index in Subps'Range loop\n+               Subp_Id := Subps (Index);\n+\n+               if Present (Alias (Subp_Id)) then\n+                  Subp_Id := Ultimate_Alias (Subp_Id);\n+               end if;\n+\n+               --  Wrappers of class-wide pre/postconditions reference the\n+               --  parent primitive that has the inherited contract.\n+\n+               if Is_Wrapper (Subp_Id)\n+                 and then Present (LSP_Subprogram (Subp_Id))\n+               then\n+                  Subp_Id := LSP_Subprogram (Subp_Id);\n+               end if;\n+\n+               if Dynamic then\n+                  if Present (Dynamic_Call_Helper (Subp_Id)) then\n+                     return Subp_Id;\n+                  end if;\n+               else\n+                  if Present (Static_Call_Helper (Subp_Id)) then\n+                     return Subp_Id;\n+                  end if;\n+               end if;\n+            end loop;\n+         end;\n+\n+         return Empty;\n+      end Class_Preconditions_Subprogram;\n+\n+      --  Local variables\n+\n+      Dynamic_Check : constant Boolean :=\n+                        Present (Controlling_Argument (Call_Node));\n+      Class_Subp    : Entity_Id;\n+      Cond          : Node_Id;\n+      Subp          : Entity_Id;\n+\n+   --  Start of processing for Install_Class_Preconditions_Check\n+\n+   begin\n+      --  Do not expand the check if we are compiling under restriction\n+      --  No_Dispatching_Calls; the semantic analyzer has previously\n+      --  notified the violation of this restriction.\n+\n+      if Dynamic_Check\n+        and then Restriction_Active (No_Dispatching_Calls)\n+      then\n+         return;\n+\n+      --  Class-wide precondition check not needed in interface thunks since\n+      --  they are installed in the dispatching call that caused invoking the\n+      --  thunk.\n+\n+      elsif Is_Thunk (Current_Scope) then\n+         return;\n+      end if;\n+\n+      Subp := Entity (Name (Call_Node));\n+\n+      --  No check needed for this subprogram call if no class-wide\n+      --  preconditions apply (or if the unique available preconditions\n+      --  are ignored preconditions).\n+\n+      Class_Subp := Class_Preconditions_Subprogram (Subp, Dynamic_Check);\n+\n+      if No (Class_Subp)\n+        or else No (Class_Preconditions (Class_Subp))\n+      then\n+         return;\n+      end if;\n+\n+      --  Build and install the check\n+\n+      if Dynamic_Check then\n+         Cond := Build_Dynamic_Check_Helper_Call;\n+      else\n+         Cond := Build_Static_Check_Helper_Call;\n+      end if;\n+\n+      if Exception_Locations_Suppressed then\n+         Insert_Action (Call_Node,\n+           Make_If_Statement (Loc,\n+             Condition       => Make_Op_Not (Loc, Cond),\n+             Then_Statements => New_List (\n+               Make_Raise_Statement (Loc,\n+                 Name =>\n+                   New_Occurrence_Of\n+                     (RTE (RE_Assert_Failure), Loc)))));\n+\n+      --  Failed check with message indicating the failed precondition and the\n+      --  call that caused it.\n+\n+      else\n+         Insert_Action (Call_Node,\n+           Make_If_Statement (Loc,\n+             Condition       => Make_Op_Not (Loc, Cond),\n+             Then_Statements => New_List (\n+               Make_Procedure_Call_Statement (Loc,\n+                 Name                   =>\n+                   New_Occurrence_Of\n+                     (RTE (RE_Raise_Assert_Failure), Loc),\n+                 Parameter_Associations =>\n+                   New_List (Build_Error_Message (Subp))))));\n+      end if;\n+   end Install_Class_Preconditions_Check;\n+\n    -----------------------------------\n    -- Is_Build_In_Place_Result_Type --\n    -----------------------------------"}, {"sha": "196f7e6d9414c711d258153c479b9fa8ec78ee5e", "filename": "gcc/ada/exp_ch6.ads", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/475e1d240086365da3e240fb9199eb1c5ad511f8/gcc%2Fada%2Fexp_ch6.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/475e1d240086365da3e240fb9199eb1c5ad511f8/gcc%2Fada%2Fexp_ch6.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.ads?ref=475e1d240086365da3e240fb9199eb1c5ad511f8", "patch": "@@ -121,6 +121,9 @@ package Exp_Ch6 is\n    --  The returned node is the root of the procedure body which will replace\n    --  the original function body, which is not needed for the C program.\n \n+   procedure Install_Class_Preconditions_Check (Call_Node : Node_Id);\n+   --  Install check of class-wide preconditions on the caller.\n+\n    function Is_Build_In_Place_Entity (E : Entity_Id) return Boolean;\n    --  Ada 2005 (AI-318-02): Returns True if E is a BIP entity.\n "}, {"sha": "72f4e7c90b72fa1080a6de20a31fbc29674ebf3f", "filename": "gcc/ada/exp_disp.adb", "status": "modified", "additions": 0, "deletions": 225, "changes": 225, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/475e1d240086365da3e240fb9199eb1c5ad511f8/gcc%2Fada%2Fexp_disp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/475e1d240086365da3e240fb9199eb1c5ad511f8/gcc%2Fada%2Fexp_disp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_disp.adb?ref=475e1d240086365da3e240fb9199eb1c5ad511f8", "patch": "@@ -63,7 +63,6 @@ with Sem_Util;       use Sem_Util;\n with Sinfo;          use Sinfo;\n with Sinfo.Nodes;    use Sinfo.Nodes;\n with Sinfo.Utils;    use Sinfo.Utils;\n-with Sinput;         use Sinput;\n with Snames;         use Snames;\n with Stand;          use Stand;\n with Stringt;        use Stringt;\n@@ -697,233 +696,11 @@ package body Exp_Disp is\n       Eq_Prim_Op      : Entity_Id := Empty;\n       Controlling_Tag : Node_Id;\n \n-      procedure Build_Class_Wide_Check (E : Entity_Id);\n-      --  If the denoted subprogram has a class-wide precondition, generate a\n-      --  check using that precondition before the dispatching call, because\n-      --  this is the only class-wide precondition that applies to the call;\n-      --  otherwise climb to the ancestors searching for the enclosing\n-      --  overridden primitive of E that has a class-wide precondition (and\n-      --  use it to generate the check).\n-\n       function New_Value (From : Node_Id) return Node_Id;\n       --  From is the original Expression. New_Value is equivalent to a call\n       --  to Duplicate_Subexpr with an explicit dereference when From is an\n       --  access parameter.\n \n-      ----------------------------\n-      -- Build_Class_Wide_Check --\n-      ----------------------------\n-\n-      procedure Build_Class_Wide_Check (E : Entity_Id) is\n-         Subp : Entity_Id := E;\n-\n-         function Has_Class_Wide_Precondition\n-           (Subp : Entity_Id) return Boolean;\n-         --  Evaluates if the dispatching subprogram Subp has a class-wide\n-         --  precondition.\n-\n-         function Replace_Formals (N : Node_Id) return Traverse_Result;\n-         --  Replace occurrences of the formals of the subprogram by the\n-         --  corresponding actuals in the call, given that this check is\n-         --  performed outside of the body of the subprogram.\n-\n-         --  If the dispatching call appears in the same scope as the\n-         --  declaration of the dispatching subprogram (for example in\n-         --  the expression of a local expression function), the spec\n-         --  has not been analyzed yet, in which case we use the Chars\n-         --  field to recognize intended occurrences of the formals.\n-\n-         ---------------------------------\n-         -- Has_Class_Wide_Precondition --\n-         ---------------------------------\n-\n-         function Has_Class_Wide_Precondition\n-           (Subp : Entity_Id) return Boolean\n-         is\n-            Prec : Node_Id := Empty;\n-\n-         begin\n-            if Present (Contract (Subp))\n-              and then Present (Pre_Post_Conditions (Contract (Subp)))\n-            then\n-               Prec := Pre_Post_Conditions (Contract (Subp));\n-\n-               while Present (Prec) loop\n-                  exit when Pragma_Name (Prec) = Name_Precondition\n-                    and then Class_Present (Prec);\n-                  Prec := Next_Pragma (Prec);\n-               end loop;\n-            end if;\n-\n-            return Present (Prec)\n-              and then not Is_Ignored (Prec);\n-         end Has_Class_Wide_Precondition;\n-\n-         ---------------------\n-         -- Replace_Formals --\n-         ---------------------\n-\n-         function Replace_Formals (N : Node_Id) return Traverse_Result is\n-            A : Node_Id;\n-            F : Entity_Id;\n-         begin\n-            if Is_Entity_Name (N) then\n-               F := First_Formal (Subp);\n-               A := First_Actual (Call_Node);\n-\n-               if Present (Entity (N)) and then Is_Formal (Entity (N)) then\n-                  while Present (F) loop\n-                     if F = Entity (N) then\n-                        if not Is_Controlling_Actual (N) then\n-                           Rewrite (N, New_Copy_Tree (A));\n-\n-                           --  If the formal is class-wide, and thus not a\n-                           --  controlling argument, preserve its type because\n-                           --  it may appear in a nested call with a class-wide\n-                           --  parameter.\n-\n-                           if Is_Class_Wide_Type (Etype (F)) then\n-                              Set_Etype (N, Etype (F));\n-\n-                           --  Conversely, if this is a controlling argument\n-                           --  (in a dispatching call in the condition) that\n-                           --  is a dereference, the source is an access-to-\n-                           --  -class-wide type, so preserve the dispatching\n-                           --  nature of the call in the rewritten condition.\n-\n-                           elsif Nkind (Parent (N)) = N_Explicit_Dereference\n-                             and then Is_Controlling_Actual (Parent (N))\n-                           then\n-                              Set_Controlling_Argument (Parent (Parent (N)),\n-                                 Parent (N));\n-                           end if;\n-\n-                        --  Ensure that the type of the controlling actual\n-                        --  matches the type of the controlling formal of the\n-                        --  parent primitive Subp defining the class-wide\n-                        --  precondition.\n-\n-                        elsif Is_Class_Wide_Type (Etype (A)) then\n-                           Rewrite (N,\n-                             Convert_To\n-                               (Class_Wide_Type (Etype (F)),\n-                                New_Copy_Tree (A)));\n-\n-                        else\n-                           Rewrite (N,\n-                             Convert_To\n-                               (Etype (F),\n-                                New_Copy_Tree (A)));\n-                        end if;\n-\n-                        exit;\n-                     end if;\n-\n-                     Next_Formal (F);\n-                     Next_Actual (A);\n-                  end loop;\n-\n-               --  If the node is not analyzed, recognize occurrences of a\n-               --  formal by name, as would be done when resolving the aspect\n-               --  expression in the context of the subprogram.\n-\n-               elsif not Analyzed (N)\n-                 and then Nkind (N) = N_Identifier\n-                 and then No (Entity (N))\n-               then\n-                  while Present (F) loop\n-                     if Chars (N) = Chars (F) then\n-                        Rewrite (N, New_Copy_Tree (A));\n-                        return Skip;\n-                     end if;\n-\n-                     Next_Formal (F);\n-                     Next_Actual (A);\n-                  end loop;\n-               end if;\n-            end if;\n-\n-            return OK;\n-         end Replace_Formals;\n-\n-         procedure Update is new Traverse_Proc (Replace_Formals);\n-\n-         --  Local variables\n-\n-         Str_Loc : constant String := Build_Location_String (Loc);\n-\n-         A    : Node_Id;\n-         Cond : Node_Id;\n-         Msg  : Node_Id;\n-         Prec : Node_Id;\n-\n-      --  Start of processing for Build_Class_Wide_Check\n-\n-      begin\n-         --  Climb searching for the enclosing class-wide precondition\n-\n-         while not Has_Class_Wide_Precondition (Subp)\n-           and then Present (Overridden_Operation (Subp))\n-         loop\n-            Subp := Overridden_Operation (Subp);\n-         end loop;\n-\n-         --  Locate class-wide precondition, if any\n-\n-         if Present (Contract (Subp))\n-           and then Present (Pre_Post_Conditions (Contract (Subp)))\n-         then\n-            Prec := Pre_Post_Conditions (Contract (Subp));\n-\n-            while Present (Prec) loop\n-               exit when Pragma_Name (Prec) = Name_Precondition\n-                 and then Class_Present (Prec);\n-               Prec := Next_Pragma (Prec);\n-            end loop;\n-\n-            if No (Prec) or else Is_Ignored (Prec) then\n-               return;\n-            end if;\n-\n-            --  Ensure that the evaluation of the actuals will not produce side\n-            --  effects (since the check will use a copy of the actuals).\n-\n-            A := First_Actual (Call_Node);\n-            while Present (A) loop\n-               Remove_Side_Effects (A);\n-               Next_Actual (A);\n-            end loop;\n-\n-            --  The expression for the precondition is analyzed within the\n-            --  generated pragma. The message text is the last parameter of\n-            --  the generated pragma, indicating source of precondition.\n-\n-            Cond :=\n-              New_Copy_Tree\n-                (Expression (First (Pragma_Argument_Associations (Prec))));\n-            Update (Cond);\n-\n-            --  Build message indicating the failed precondition and the\n-            --  dispatching call that caused it.\n-\n-            Msg := Expression (Last (Pragma_Argument_Associations (Prec)));\n-            Name_Len := 0;\n-            Append (Global_Name_Buffer, Strval (Msg));\n-            Append (Global_Name_Buffer, \" in dispatching call at \");\n-            Append (Global_Name_Buffer, Str_Loc);\n-            Msg := Make_String_Literal (Loc, Name_Buffer (1 .. Name_Len));\n-\n-            Insert_Action (Call_Node,\n-              Make_If_Statement (Loc,\n-                Condition       => Make_Op_Not (Loc, Cond),\n-                Then_Statements => New_List (\n-                  Make_Procedure_Call_Statement (Loc,\n-                    Name                   =>\n-                      New_Occurrence_Of (RTE (RE_Raise_Assert_Failure), Loc),\n-                    Parameter_Associations => New_List (Msg)))));\n-         end if;\n-      end Build_Class_Wide_Check;\n-\n       ---------------\n       -- New_Value --\n       ---------------\n@@ -984,8 +761,6 @@ package body Exp_Disp is\n          Subp := Alias (Subp);\n       end if;\n \n-      Build_Class_Wide_Check (Subp);\n-\n       --  Definition of the class-wide type and the tagged type\n \n       --  If the controlling argument is itself a tag rather than a tagged"}, {"sha": "7c366663dcbc941bf3ba6e0019f182f913649716", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 81, "deletions": 102, "changes": 183, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/475e1d240086365da3e240fb9199eb1c5ad511f8/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/475e1d240086365da3e240fb9199eb1c5ad511f8/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=475e1d240086365da3e240fb9199eb1c5ad511f8", "patch": "@@ -1270,11 +1270,10 @@ package body Exp_Util is\n    ---------------------------------\n \n    procedure Build_Class_Wide_Expression\n-     (Prag          : Node_Id;\n-      Subp          : Entity_Id;\n-      Par_Subp      : Entity_Id;\n-      Adjust_Sloc   : Boolean;\n-      Needs_Wrapper : out Boolean)\n+     (Pragma_Or_Expr : Node_Id;\n+      Subp           : Entity_Id;\n+      Par_Subp       : Entity_Id;\n+      Adjust_Sloc    : Boolean)\n    is\n       function Replace_Entity (N : Node_Id) return Traverse_Result;\n       --  Replace reference to formal of inherited operation or to primitive\n@@ -1319,84 +1318,6 @@ package body Exp_Util is\n \n             if Present (New_E) then\n                Rewrite (N, New_Occurrence_Of (New_E, Sloc (N)));\n-\n-               --  AI12-0166: a precondition for a protected operation\n-               --  cannot include an internal call to a protected function\n-               --  of the type. In the case of an inherited condition for an\n-               --  overriding operation, both the operation and the function\n-               --  are given by primitive wrappers.\n-               --  Move this check to sem???\n-\n-               if Ekind (New_E) = E_Function\n-                 and then Is_Primitive_Wrapper (New_E)\n-                 and then Is_Primitive_Wrapper (Subp)\n-                 and then Scope (Subp) = Scope (New_E)\n-                 and then Chars (Pragma_Identifier (Prag)) = Name_Precondition\n-               then\n-                  Error_Msg_Node_2 := Wrapped_Entity (Subp);\n-                  Error_Msg_NE\n-                    (\"internal call to& cannot appear in inherited \"\n-                     & \"precondition of protected operation&\",\n-                     N, Wrapped_Entity (New_E));\n-               end if;\n-\n-               --  If the entity is an overridden primitive and we are not\n-               --  in GNATprove mode, we must build a wrapper for the current\n-               --  inherited operation. If the reference is the prefix of an\n-               --  attribute such as 'Result (or others ???) there is no need\n-               --  for a wrapper: the condition is just rewritten in terms of\n-               --  the inherited subprogram.\n-\n-               if Is_Subprogram (New_E)\n-                  and then Nkind (Parent (N)) /= N_Attribute_Reference\n-                  and then not GNATprove_Mode\n-               then\n-                  Needs_Wrapper := True;\n-               end if;\n-            end if;\n-\n-            --  Check that there are no calls left to abstract operations if\n-            --  the current subprogram is not abstract.\n-            --  Move this check to sem???\n-\n-            if Nkind (Parent (N)) = N_Function_Call\n-              and then N = Name (Parent (N))\n-            then\n-               if not Is_Abstract_Subprogram (Subp)\n-                 and then Is_Abstract_Subprogram (Entity (N))\n-               then\n-                  Error_Msg_Sloc   := Sloc (Current_Scope);\n-                  Error_Msg_Node_2 := Subp;\n-                  if Comes_From_Source (Subp) then\n-                     Error_Msg_NE\n-                       (\"cannot call abstract subprogram & in inherited \"\n-                        & \"condition for&#\", Subp, Entity (N));\n-                  else\n-                     Error_Msg_NE\n-                       (\"cannot call abstract subprogram & in inherited \"\n-                        & \"condition for inherited&#\", Subp, Entity (N));\n-                  end if;\n-\n-               --  In SPARK mode, reject an inherited condition for an\n-               --  inherited operation if it contains a call to an overriding\n-               --  operation, because this implies that the pre/postconditions\n-               --  of the inherited operation have changed silently.\n-\n-               elsif SPARK_Mode = On\n-                 and then Warn_On_Suspicious_Contract\n-                 and then Present (Alias (Subp))\n-                 and then Present (New_E)\n-                 and then Comes_From_Source (New_E)\n-               then\n-                  Error_Msg_N\n-                    (\"cannot modify inherited condition (SPARK RM 6.1.1(1))\",\n-                     Parent (Subp));\n-                  Error_Msg_Sloc   := Sloc (New_E);\n-                  Error_Msg_Node_2 := Subp;\n-                  Error_Msg_NE\n-                    (\"\\overriding of&# forces overriding of&\",\n-                     Parent (Subp), New_E);\n-               end if;\n             end if;\n \n             --  Update type of function call node, which should be the same as\n@@ -1422,26 +1343,17 @@ package body Exp_Util is\n \n       --  Local variables\n \n-      Par_Formal  : Entity_Id;\n-      Subp_Formal : Entity_Id;\n+      Par_Typ  : constant Entity_Id := Find_Dispatching_Type (Par_Subp);\n+      Subp_Typ : constant Entity_Id := Find_Dispatching_Type (Subp);\n \n    --  Start of processing for Build_Class_Wide_Expression\n \n    begin\n-      Needs_Wrapper := False;\n-\n-      --  Add mapping from old formals to new formals\n+      pragma Assert (Par_Typ /= Subp_Typ);\n \n-      Par_Formal  := First_Formal (Par_Subp);\n-      Subp_Formal := First_Formal (Subp);\n-\n-      while Present (Par_Formal) and then Present (Subp_Formal) loop\n-         Type_Map.Set (Par_Formal, Subp_Formal);\n-         Next_Formal (Par_Formal);\n-         Next_Formal (Subp_Formal);\n-      end loop;\n-\n-      Replace_Condition_Entities (Prag);\n+      Update_Primitives_Mapping (Par_Subp, Subp);\n+      Map_Formals (Par_Subp, Subp);\n+      Replace_Condition_Entities (Pragma_Or_Expr);\n    end Build_Class_Wide_Expression;\n \n    --------------------\n@@ -1895,7 +1807,33 @@ package body Exp_Util is\n          Priv_Typ : Entity_Id;\n          --  The partial view of Par_Typ\n \n+         Op_Node  : Elmt_Id;\n+         Par_Prim : Entity_Id;\n+         Prim     : Entity_Id;\n+\n       begin\n+         --  Map the overridden primitive to the overriding one; required by\n+         --  Replace_References (called by Add_Inherited_DICs) to handle calls\n+         --  to parent primitives.\n+\n+         Op_Node := First_Elmt (Primitive_Operations (T));\n+         while Present (Op_Node) loop\n+            Prim := Node (Op_Node);\n+\n+            if Present (Overridden_Operation (Prim))\n+              and then Comes_From_Source (Prim)\n+            then\n+               Par_Prim := Overridden_Operation (Prim);\n+\n+               --  Create a mapping of the form:\n+               --    parent type primitive -> derived type primitive\n+\n+               Type_Map.Set (Par_Prim, Prim);\n+            end if;\n+\n+            Next_Elmt (Op_Node);\n+         end loop;\n+\n          --  Climb the parent type chain\n \n          Curr_Typ := T;\n@@ -7073,6 +7011,15 @@ package body Exp_Util is\n       return Etype (Indx);\n    end Get_Index_Subtype;\n \n+   -----------------------\n+   -- Get_Mapped_Entity --\n+   -----------------------\n+\n+   function Get_Mapped_Entity (E : Entity_Id) return Entity_Id is\n+   begin\n+      return Type_Map.Get (E);\n+   end Get_Mapped_Entity;\n+\n    ---------------------\n    -- Get_Stream_Size --\n    ---------------------\n@@ -10350,6 +10297,36 @@ package body Exp_Util is\n       end if;\n    end Make_Variant_Comparison;\n \n+   -----------------\n+   -- Map_Formals --\n+   -----------------\n+\n+   procedure Map_Formals\n+     (Parent_Subp  : Entity_Id;\n+      Derived_Subp : Entity_Id;\n+      Force_Update : Boolean := False)\n+   is\n+      Par_Formal  : Entity_Id := First_Formal (Parent_Subp);\n+      Subp_Formal : Entity_Id := First_Formal (Derived_Subp);\n+\n+   begin\n+      if Force_Update then\n+         Type_Map.Set (Parent_Subp, Derived_Subp);\n+      end if;\n+\n+      --  At this stage either we are under regular processing and the caller\n+      --  has previously ensured that these primitives are already mapped (by\n+      --  means of calling previously to Update_Primitives_Mapping), or we are\n+      --  processing a late-overriding primitive and Force_Update updated above\n+      --  the mapping of these primitives.\n+\n+      while Present (Par_Formal) and then Present (Subp_Formal) loop\n+         Type_Map.Set (Par_Formal, Subp_Formal);\n+         Next_Formal (Par_Formal);\n+         Next_Formal (Subp_Formal);\n+      end loop;\n+   end Map_Formals;\n+\n    ---------------\n    -- Map_Types --\n    ---------------\n@@ -10861,7 +10838,7 @@ package body Exp_Util is\n          --  they relate to the primitives of the parent type. If there is a\n          --  meaningful relation, create a mapping of the form:\n \n-         --    parent type primitive -> perived type primitive\n+         --    parent type primitive -> derived type primitive\n \n          if Present (Direct_Primitive_Operations (Deriv_Typ)) then\n             Prim_Elmt := First_Elmt (Direct_Primitive_Operations (Deriv_Typ));\n@@ -14123,10 +14100,12 @@ package body Exp_Util is\n      (Inher_Id : Entity_Id;\n       Subp_Id  : Entity_Id)\n    is\n+      Parent_Type  : constant Entity_Id := Find_Dispatching_Type (Inher_Id);\n+      Derived_Type : constant Entity_Id := Find_Dispatching_Type (Subp_Id);\n+\n    begin\n-      Map_Types\n-        (Parent_Type  => Find_Dispatching_Type (Inher_Id),\n-         Derived_Type => Find_Dispatching_Type (Subp_Id));\n+      pragma Assert (Parent_Type /= Derived_Type);\n+      Map_Types (Parent_Type, Derived_Type);\n    end Update_Primitives_Mapping;\n \n    ----------------------------------"}, {"sha": "eddf314c9321750bad04b0a01d9231eea7a4ebc3", "filename": "gcc/ada/exp_util.ads", "status": "modified", "additions": 25, "deletions": 23, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/475e1d240086365da3e240fb9199eb1c5ad511f8/gcc%2Fada%2Fexp_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/475e1d240086365da3e240fb9199eb1c5ad511f8/gcc%2Fada%2Fexp_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.ads?ref=475e1d240086365da3e240fb9199eb1c5ad511f8", "patch": "@@ -270,28 +270,16 @@ package Exp_Util is\n    --  not install a call to Abort_Defer.\n \n    procedure Build_Class_Wide_Expression\n-     (Prag          : Node_Id;\n-      Subp          : Entity_Id;\n-      Par_Subp      : Entity_Id;\n-      Adjust_Sloc   : Boolean;\n-      Needs_Wrapper : out Boolean);\n-   --  Build the expression for an inherited class-wide condition. Prag is\n-   --  the pragma constructed from the corresponding aspect of the parent\n-   --  subprogram, and Subp is the overriding operation, and Par_Subp is\n-   --  the overridden operation that has the condition. Adjust_Sloc is True\n-   --  when the sloc of nodes traversed should be adjusted for the inherited\n-   --  pragma. The routine is also called to check whether an inherited\n-   --  operation that is not overridden but has inherited conditions needs\n-   --  a wrapper, because the inherited condition includes calls to other\n-   --  primitives that have been overridden. In that case the first argument\n-   --  is the expression of the original class-wide aspect. In SPARK_Mode, such\n-   --  operation which are just inherited but have modified pre/postconditions\n-   --  are illegal.\n-   --  If there are calls to overridden operations in the condition, and the\n-   --  pragma applies to an inherited operation, a wrapper must be built for\n-   --  it to capture the new inherited condition. The flag Needs_Wrapper is\n-   --  set in that case so that the wrapper can be built, when the controlling\n-   --  type is frozen.\n+     (Pragma_Or_Expr : Node_Id;\n+      Subp           : Entity_Id;\n+      Par_Subp       : Entity_Id;\n+      Adjust_Sloc    : Boolean);\n+   --  Build the expression for an inherited class-wide condition. Pragma_Or_\n+   --  _Expr is either the pragma constructed from the corresponding aspect of\n+   --  the parent subprogram or the class-wide pre/postcondition built from the\n+   --  parent, Subp is the overriding operation, and Par_Subp is the overridden\n+   --  operation that has the condition. Adjust_Sloc is True when the sloc of\n+   --  nodes traversed should be adjusted for the inherited pragma.\n \n    function Build_DIC_Call\n      (Loc      : Source_Ptr;\n@@ -612,7 +600,7 @@ package Exp_Util is\n    function Find_Prim_Op (T : Entity_Id; Name : Name_Id) return Entity_Id;\n    --  Find the first primitive operation of a tagged type T with name Name.\n    --  This function allows the use of a primitive operation which is not\n-   --  directly visible. If T is a class wide type, then the reference is to an\n+   --  directly visible. If T is a class-wide type, then the reference is to an\n    --  operation of the corresponding root type. It is an error if no primitive\n    --  operation with the given name is found.\n \n@@ -739,6 +727,10 @@ package Exp_Util is\n    --  Used for First, Last, and Length, when the prefix is an array type.\n    --  Obtains the corresponding index subtype.\n \n+   function Get_Mapped_Entity (E : Entity_Id) return Entity_Id;\n+   --  Return the mapped entity of E; used to check inherited class-wide\n+   --  pre/postconditions.\n+\n    function Get_Stream_Size (E : Entity_Id) return Uint;\n    --  Return the stream size value of the subtype E\n \n@@ -918,6 +910,15 @@ package Exp_Util is\n    --  Subprogram_Variant. Generate a comparison between Curr_Val and Old_Val\n    --  depending on the variant mode (Increases / Decreases).\n \n+   procedure Map_Formals\n+     (Parent_Subp  : Entity_Id;\n+      Derived_Subp : Entity_Id;\n+      Force_Update : Boolean := False);\n+   --  Establish the mapping from the formals of Parent_Subp to the formals\n+   --  of Derived_Subp; if Force_Update is True then mapping of Parent_Subp to\n+   --  Derived_Subp is also updated; used to update mapping of late-overriding\n+   --  primitives of a tagged type.\n+\n    procedure Map_Types (Parent_Type : Entity_Id; Derived_Type : Entity_Id);\n    --  Establish the following mapping between the attributes of tagged parent\n    --  type Parent_Type and tagged derived type Derived_Type.\n@@ -1205,5 +1206,6 @@ package Exp_Util is\n private\n    pragma Inline (Duplicate_Subexpr);\n    pragma Inline (Force_Evaluation);\n+   pragma Inline (Get_Mapped_Entity);\n    pragma Inline (Is_Library_Level_Tagged_Type);\n end Exp_Util;"}, {"sha": "5f81d9efbdaa39e9a94318bb0d5664da98344084", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 442, "deletions": 131, "changes": 573, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/475e1d240086365da3e240fb9199eb1c5ad511f8/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/475e1d240086365da3e240fb9199eb1c5ad511f8/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=475e1d240086365da3e240fb9199eb1c5ad511f8", "patch": "@@ -35,6 +35,7 @@ with Elists;         use Elists;\n with Errout;         use Errout;\n with Exp_Ch3;        use Exp_Ch3;\n with Exp_Ch7;        use Exp_Ch7;\n+with Exp_Disp;       use Exp_Disp;\n with Exp_Pakd;       use Exp_Pakd;\n with Exp_Util;       use Exp_Util;\n with Exp_Tss;        use Exp_Tss;\n@@ -56,6 +57,7 @@ with Sem_Ch6;        use Sem_Ch6;\n with Sem_Ch7;        use Sem_Ch7;\n with Sem_Ch8;        use Sem_Ch8;\n with Sem_Ch13;       use Sem_Ch13;\n+with Sem_Disp;       use Sem_Disp;\n with Sem_Eval;       use Sem_Eval;\n with Sem_Mech;       use Sem_Mech;\n with Sem_Prag;       use Sem_Prag;\n@@ -132,11 +134,6 @@ package body Freeze is\n    --  Attribute references to outer types are freeze points for those types;\n    --  this routine generates the required freeze nodes for them.\n \n-   procedure Check_Inherited_Conditions (R : Entity_Id);\n-   --  For a tagged derived type, create wrappers for inherited operations\n-   --  that have a class-wide condition, so it can be properly rewritten if\n-   --  it involves calls to other overriding primitives.\n-\n    procedure Check_Strict_Alignment (E : Entity_Id);\n    --  E is a base type. If E is tagged or has a component that is aliased\n    --  or tagged or contains something this is aliased or tagged, set\n@@ -160,7 +157,7 @@ package body Freeze is\n    procedure Freeze_Enumeration_Type (Typ : Entity_Id);\n    --  Freeze enumeration type. The Esize field is set as processing\n    --  proceeds (i.e. set by default when the type is declared and then\n-   --  adjusted by rep clauses. What this procedure does is to make sure\n+   --  adjusted by rep clauses). What this procedure does is to make sure\n    --  that if a foreign convention is specified, and no specific size\n    --  is given, then the size must be at least Integer'Size.\n \n@@ -1483,90 +1480,322 @@ package body Freeze is\n    -- Check_Inherited_Conditions --\n    --------------------------------\n \n-   procedure Check_Inherited_Conditions (R : Entity_Id) is\n-      Prim_Ops      : constant Elist_Id := Primitive_Operations (R);\n-      Decls         : List_Id;\n-      Needs_Wrapper : Boolean;\n-      Op_Node       : Elmt_Id;\n-      Par_Prim      : Entity_Id;\n-      Prim          : Entity_Id;\n-\n-      procedure Build_Inherited_Condition_Pragmas (Subp : Entity_Id);\n+   procedure Check_Inherited_Conditions\n+     (R               : Entity_Id;\n+      Late_Overriding : Boolean := False)\n+   is\n+      Prim_Ops       : constant Elist_Id := Primitive_Operations (R);\n+      Decls          : List_Id;\n+      Op_Node        : Elmt_Id;\n+      Par_Prim       : Entity_Id;\n+      Prim           : Entity_Id;\n+      Wrapper_Needed : Boolean;\n+\n+      function Build_DTW_Body\n+        (Loc          : Source_Ptr;\n+         DTW_Spec     : Node_Id;\n+         DTW_Decls    : List_Id;\n+         Par_Prim     : Entity_Id;\n+         Wrapped_Subp : Entity_Id) return Node_Id;\n+      --  Build the body of the dispatch table wrapper containing the given\n+      --  spec and declarations; the call to the wrapped subprogram includes\n+      --  the proper type conversion.\n+\n+      function Build_DTW_Spec (Par_Prim : Entity_Id) return Node_Id;\n+      --  Build the spec of the dispatch table wrapper\n+\n+      procedure Build_Inherited_Condition_Pragmas\n+        (Subp           : Entity_Id;\n+         Wrapper_Needed : out Boolean);\n       --  Build corresponding pragmas for an operation whose ancestor has\n-      --  class-wide pre/postconditions. If the operation is inherited, the\n-      --  pragmas force the creation of a wrapper for the inherited operation.\n-      --  If the ancestor is being overridden, the pragmas are constructed only\n-      --  to verify their legality, in case they contain calls to other\n-      --  primitives that may have been overridden.\n+      --  class-wide pre/postconditions. If the operation is inherited then\n+      --  Wrapper_Needed is returned True to force the creation of a wrapper\n+      --  for the inherited operation. If the ancestor is being overridden,\n+      --  the pragmas are constructed only to verify their legality, in case\n+      --  they contain calls to other primitives that may have been overridden.\n+\n+      function Needs_Wrapper\n+        (Class_Cond : Node_Id;\n+         Subp       : Entity_Id;\n+         Par_Subp   : Entity_Id) return Boolean;\n+      --  Checks whether the dispatch-table wrapper (DTW) for Subp must be\n+      --  built to evaluate the given class-wide condition.\n+\n+      --------------------\n+      -- Build_DTW_Body --\n+      --------------------\n+\n+      function Build_DTW_Body\n+        (Loc          : Source_Ptr;\n+         DTW_Spec     : Node_Id;\n+         DTW_Decls    : List_Id;\n+         Par_Prim     : Entity_Id;\n+         Wrapped_Subp : Entity_Id) return Node_Id\n+      is\n+         Par_Typ    : constant Entity_Id := Find_Dispatching_Type (Par_Prim);\n+         Actuals    : constant List_Id   := Empty_List;\n+         Call       : Node_Id;\n+         Formal     : Entity_Id := First_Formal (Par_Prim);\n+         New_F_Spec : Entity_Id := First (Parameter_Specifications (DTW_Spec));\n+         New_Formal : Entity_Id;\n+\n+      begin\n+         --  Build parameter association for call to wrapped subprogram\n+\n+         while Present (Formal) loop\n+            New_Formal := Defining_Identifier (New_F_Spec);\n+\n+            --  If the controlling argument is inherited, add conversion to\n+            --  parent type for the call.\n+\n+            if Etype (Formal) = Par_Typ\n+              and then Is_Controlling_Formal (Formal)\n+            then\n+               Append_To (Actuals,\n+                 Make_Type_Conversion (Loc,\n+                   New_Occurrence_Of (Par_Typ, Loc),\n+                   New_Occurrence_Of (New_Formal, Loc)));\n+            else\n+               Append_To (Actuals, New_Occurrence_Of (New_Formal, Loc));\n+            end if;\n+\n+            Next_Formal (Formal);\n+            Next (New_F_Spec);\n+         end loop;\n+\n+         if Ekind (Wrapped_Subp) = E_Procedure then\n+            Call :=\n+              Make_Procedure_Call_Statement (Loc,\n+                Name => New_Occurrence_Of (Wrapped_Subp, Loc),\n+                Parameter_Associations => Actuals);\n+         else\n+            Call :=\n+              Make_Simple_Return_Statement (Loc,\n+                Expression =>\n+                  Make_Function_Call (Loc,\n+                    Name => New_Occurrence_Of (Wrapped_Subp, Loc),\n+                    Parameter_Associations => Actuals));\n+         end if;\n+\n+         return\n+           Make_Subprogram_Body (Loc,\n+             Specification              => Copy_Subprogram_Spec (DTW_Spec),\n+             Declarations               => DTW_Decls,\n+             Handled_Statement_Sequence =>\n+               Make_Handled_Sequence_Of_Statements (Loc,\n+                 Statements => New_List (Call),\n+                 End_Label  => Make_Identifier (Loc,\n+                                 Chars (Defining_Entity (DTW_Spec)))));\n+      end Build_DTW_Body;\n+\n+      --------------------\n+      -- Build_DTW_Spec --\n+      --------------------\n+\n+      function Build_DTW_Spec (Par_Prim : Entity_Id) return Node_Id is\n+         DTW_Id   : Entity_Id;\n+         DTW_Spec : Node_Id;\n+\n+      begin\n+         DTW_Spec := Build_Overriding_Spec (Par_Prim, R);\n+         DTW_Id   := Defining_Entity (DTW_Spec);\n+\n+         --  Add minimal decoration of fields\n+\n+         Mutate_Ekind (DTW_Id, Ekind (Par_Prim));\n+         Set_LSP_Subprogram (DTW_Id, Par_Prim);\n+         Set_Is_Dispatch_Table_Wrapper (DTW_Id);\n+         Set_Is_Wrapper (DTW_Id);\n+\n+         --  The DTW wrapper is never a null procedure\n+\n+         if Nkind (DTW_Spec) = N_Procedure_Specification then\n+            Set_Null_Present (DTW_Spec, False);\n+         end if;\n+\n+         return DTW_Spec;\n+      end Build_DTW_Spec;\n \n       ---------------------------------------\n       -- Build_Inherited_Condition_Pragmas --\n       ---------------------------------------\n \n-      procedure Build_Inherited_Condition_Pragmas (Subp : Entity_Id) is\n-         A_Post   : Node_Id;\n-         A_Pre    : Node_Id;\n-         New_Prag : Node_Id;\n+      procedure Build_Inherited_Condition_Pragmas\n+        (Subp           : Entity_Id;\n+         Wrapper_Needed : out Boolean)\n+      is\n+         Class_Pre  : constant Node_Id :=\n+                        Class_Preconditions (Ultimate_Alias (Subp));\n+         Class_Post : Node_Id := Class_Postconditions (Par_Prim);\n+         A_Post     : Node_Id;\n+         New_Prag   : Node_Id;\n \n       begin\n-         A_Pre := Get_Class_Wide_Pragma (Par_Prim, Pragma_Precondition);\n+         Wrapper_Needed := False;\n \n-         if Present (A_Pre) then\n-            New_Prag := New_Copy_Tree (A_Pre);\n-            Build_Class_Wide_Expression\n-              (Prag          => New_Prag,\n-               Subp          => Prim,\n-               Par_Subp      => Par_Prim,\n-               Adjust_Sloc   => False,\n-               Needs_Wrapper => Needs_Wrapper);\n-\n-            if Needs_Wrapper\n-              and then not Comes_From_Source (Subp)\n-              and then Expander_Active\n-            then\n-               Append (New_Prag, Decls);\n-            end if;\n+         if No (Class_Pre) and then No (Class_Post) then\n+            return;\n          end if;\n \n-         A_Post := Get_Class_Wide_Pragma (Par_Prim, Pragma_Postcondition);\n+         --  For class-wide preconditions we just evaluate whether the wrapper\n+         --  is needed; there is no need to build the pragma since the check\n+         --  is performed on the caller side.\n \n-         if Present (A_Post) then\n-            New_Prag := New_Copy_Tree (A_Post);\n+         if Present (Class_Pre)\n+           and then Needs_Wrapper (Class_Pre, Subp, Par_Prim)\n+         then\n+            Wrapper_Needed := True;\n+         end if;\n+\n+         --  For class-wide postconditions we evaluate whether the wrapper is\n+         --  needed and we build the class-wide postcondition pragma to install\n+         --  it in the wrapper.\n+\n+         if Present (Class_Post)\n+           and then Needs_Wrapper (Class_Post, Subp, Par_Prim)\n+         then\n+            Wrapper_Needed := True;\n+\n+            --  Update the class-wide postcondition\n+\n+            Class_Post := New_Copy_Tree (Class_Post);\n             Build_Class_Wide_Expression\n-              (Prag           => New_Prag,\n-               Subp           => Prim,\n+              (Pragma_Or_Expr => Class_Post,\n+               Subp           => Subp,\n                Par_Subp       => Par_Prim,\n-               Adjust_Sloc    => False,\n-               Needs_Wrapper  => Needs_Wrapper);\n+               Adjust_Sloc    => False);\n \n-            if Needs_Wrapper\n-              and then not Comes_From_Source (Subp)\n-              and then Expander_Active\n-            then\n-               Append (New_Prag, Decls);\n+            --  Install the updated class-wide postcondition in a copy of the\n+            --  pragma postcondition defined for the nearest ancestor.\n+\n+            A_Post := Get_Class_Wide_Pragma (Par_Prim,\n+                        Pragma_Postcondition);\n+\n+            if No (A_Post) then\n+               declare\n+                  Subps : constant Subprogram_List :=\n+                            Inherited_Subprograms (Subp);\n+               begin\n+                  for Index in Subps'Range loop\n+                     A_Post := Get_Class_Wide_Pragma (Subps (Index),\n+                                 Pragma_Postcondition);\n+                     exit when Present (A_Post);\n+                  end loop;\n+               end;\n             end if;\n+\n+            New_Prag := New_Copy_Tree (A_Post);\n+            Rewrite\n+              (Expression (First (Pragma_Argument_Associations (New_Prag))),\n+               Class_Post);\n+            Append (New_Prag, Decls);\n          end if;\n       end Build_Inherited_Condition_Pragmas;\n \n+      -------------------\n+      -- Needs_Wrapper --\n+      -------------------\n+\n+      function Needs_Wrapper\n+        (Class_Cond : Node_Id;\n+         Subp       : Entity_Id;\n+         Par_Subp   : Entity_Id) return Boolean\n+      is\n+         Result : Boolean := False;\n+\n+         function Check_Entity (N : Node_Id) return Traverse_Result;\n+         --  Check calls to overridden primitives\n+\n+         --------------------\n+         -- Replace_Entity --\n+         --------------------\n+\n+         function Check_Entity (N : Node_Id) return Traverse_Result is\n+            New_E : Entity_Id;\n+\n+         begin\n+            if Nkind (N) = N_Identifier\n+              and then Present (Entity (N))\n+              and then\n+                (Is_Formal (Entity (N)) or else Is_Subprogram (Entity (N)))\n+              and then\n+                (Nkind (Parent (N)) /= N_Attribute_Reference\n+                  or else Attribute_Name (Parent (N)) /= Name_Class)\n+            then\n+               --  The check does not apply to dispatching calls within the\n+               --  condition, but only to calls whose static tag is that of\n+               --  the parent type.\n+\n+               if Is_Subprogram (Entity (N))\n+                 and then Nkind (Parent (N)) = N_Function_Call\n+                 and then Present (Controlling_Argument (Parent (N)))\n+               then\n+                  return OK;\n+               end if;\n+\n+               --  Determine whether entity has a renaming\n+\n+               New_E := Get_Mapped_Entity (Entity (N));\n+\n+               --  If the entity is an overridden primitive and we are not\n+               --  in GNATprove mode, we must build a wrapper for the current\n+               --  inherited operation. If the reference is the prefix of an\n+               --  attribute such as 'Result (or others ???) there is no need\n+               --  for a wrapper: the condition is just rewritten in terms of\n+               --  the inherited subprogram.\n+\n+               if Present (New_E)\n+                 and then Comes_From_Source (New_E)\n+                 and then Is_Subprogram (New_E)\n+                 and then Nkind (Parent (N)) /= N_Attribute_Reference\n+                 and then not GNATprove_Mode\n+               then\n+                  Result := True;\n+                  return Abandon;\n+               end if;\n+            end if;\n+\n+            return OK;\n+         end Check_Entity;\n+\n+         procedure Check_Condition_Entities is\n+           new Traverse_Proc (Check_Entity);\n+\n+      --  Start of processing for Needs_Wrapper\n+\n+      begin\n+         Update_Primitives_Mapping (Par_Subp, Subp);\n+\n+         Map_Formals (Par_Subp, Subp);\n+         Check_Condition_Entities (Class_Cond);\n+\n+         return Result;\n+      end Needs_Wrapper;\n+\n    --  Start of processing for Check_Inherited_Conditions\n \n    begin\n-      Op_Node := First_Elmt (Prim_Ops);\n-      while Present (Op_Node) loop\n-         Prim := Node (Op_Node);\n+      if Late_Overriding then\n+         Op_Node := First_Elmt (Prim_Ops);\n+         while Present (Op_Node) loop\n+            Prim := Node (Op_Node);\n \n-         --  Map the overridden primitive to the overriding one. This takes\n-         --  care of all overridings and is done only once.\n+            --  Map the overridden primitive to the overriding one\n \n-         if Present (Overridden_Operation (Prim))\n-           and then Comes_From_Source (Prim)\n-         then\n-            Par_Prim := Overridden_Operation (Prim);\n-            Update_Primitives_Mapping (Par_Prim, Prim);\n-         end if;\n+            if Present (Overridden_Operation (Prim))\n+              and then Comes_From_Source (Prim)\n+            then\n+               Par_Prim := Overridden_Operation (Prim);\n+               Update_Primitives_Mapping (Par_Prim, Prim);\n \n-         Next_Elmt (Op_Node);\n-      end loop;\n+               --  Force discarding previous mappings of its formals\n+\n+               Map_Formals (Par_Prim, Prim, Force_Update => True);\n+            end if;\n+\n+            Next_Elmt (Op_Node);\n+         end loop;\n+      end if;\n \n       --  Perform validity checks on the inherited conditions of overriding\n       --  operations, for conformance with LSP, and apply SPARK-specific\n@@ -1602,12 +1831,6 @@ package body Freeze is\n \n             if GNATprove_Mode then\n                Collect_Inherited_Class_Wide_Conditions (Prim);\n-\n-            --  Otherwise build the corresponding pragmas to check for legality\n-            --  of the inherited condition.\n-\n-            else\n-               Build_Inherited_Condition_Pragmas (Prim);\n             end if;\n          end if;\n \n@@ -1621,12 +1844,17 @@ package body Freeze is\n       Op_Node := First_Elmt (Prim_Ops);\n \n       while Present (Op_Node) loop\n-         Decls         := Empty_List;\n-         Prim          := Node (Op_Node);\n-         Needs_Wrapper := False;\n+         Decls          := Empty_List;\n+         Prim           := Node (Op_Node);\n+         Wrapper_Needed := False;\n+\n+         --  Skip internal entities built for mapping interface primitives\n \n-         if not Comes_From_Source (Prim) and then Present (Alias (Prim)) then\n-            Par_Prim := Alias (Prim);\n+         if not Comes_From_Source (Prim)\n+           and then Present (Alias (Prim))\n+           and then No (Interface_Alias (Prim))\n+         then\n+            Par_Prim := Ultimate_Alias (Prim);\n \n             --  When the primitive is an LSP wrapper we climb to the parent\n             --  primitive that has the inherited contract.\n@@ -1644,87 +1872,170 @@ package body Freeze is\n             --  in the loop above.\n \n             Analyze_Entry_Or_Subprogram_Contract (Par_Prim);\n-            Build_Inherited_Condition_Pragmas (Prim);\n+            Build_Inherited_Condition_Pragmas (Prim, Wrapper_Needed);\n          end if;\n \n-         if Needs_Wrapper\n+         if Wrapper_Needed\n            and then not Is_Abstract_Subprogram (Par_Prim)\n            and then Expander_Active\n          then\n-            --  We need to build a new primitive that overrides the inherited\n-            --  one, and whose inherited expression has been updated above.\n-            --  These expressions are the arguments of pragmas that are part\n-            --  of the declarations of the wrapper. The wrapper holds a single\n-            --  statement that is a call to the class-wide clone, where the\n-            --  controlling actuals are conversions to the corresponding type\n-            --  in the parent primitive:\n-\n-            --    procedure New_Prim (F1 : T1; ...);\n-            --    procedure New_Prim (F1 : T1; ...) is\n-            --       pragma Check (Precondition, Expr);\n-            --    begin\n-            --       Par_Prim_Clone (Par_Type (F1), ...);\n-            --    end;\n-\n-            --  If the primitive is a function the statement is a return\n-            --  statement with a call.\n+            --  Build the dispatch-table wrapper (DTW). The support for\n+            --  AI12-0195 relies on two kind of wrappers: one for indirect\n+            --  calls (also used for AI12-0220), and one for putting in the\n+            --  dispatch table:\n+            --\n+            --    1) \"indirect-call wrapper\" (ICW) is needed anytime there are\n+            --       class-wide preconditions. Prim'Access will point directly\n+            --       at the ICW if any, or at the \"pristine\" body if Prim has\n+            --       no class-wide preconditions.\n+            --\n+            --    2) \"dispatch-table wrapper\" (DTW) is needed anytime the class\n+            --       wide preconditions *or* the class-wide postconditions are\n+            --       affected by overriding.\n+            --\n+            --  The DTW holds a single statement that is a single call where\n+            --  the controlling actuals are conversions to the corresponding\n+            --  type in the parent primitive. If the primitive is a function\n+            --  the statement is a return statement with a call.\n \n             declare\n                Alias_Id : constant Entity_Id  := Ultimate_Alias (Prim);\n                Loc      : constant Source_Ptr := Sloc (R);\n-               Par_R    : constant Node_Id    := Parent (R);\n-               New_Body : Node_Id;\n-               New_Decl : Node_Id;\n-               New_Id   : Entity_Id;\n-               New_Spec : Node_Id;\n+               DTW_Body : Node_Id;\n+               DTW_Decl : Node_Id;\n+               DTW_Id   : Entity_Id;\n+               DTW_Spec : Node_Id;\n \n             begin\n                --  The wrapper must be analyzed in the scope of its wrapped\n                --  primitive (to ensure its correct decoration).\n \n                Push_Scope (Scope (Prim));\n \n-               New_Spec := Build_Overriding_Spec (Par_Prim, R);\n-               New_Id   := Defining_Entity (New_Spec);\n-               New_Decl :=\n-                 Make_Subprogram_Declaration (Loc,\n-                   Specification => New_Spec);\n+               DTW_Spec := Build_DTW_Spec (Par_Prim);\n+               DTW_Id   := Defining_Entity (DTW_Spec);\n+               DTW_Decl := Make_Subprogram_Declaration (Loc,\n+                             Specification => DTW_Spec);\n+\n+               --  For inherited class-wide preconditions the DTW wrapper\n+               --  reuses the ICW of the parent (which checks the parent\n+               --  interpretation of the class-wide preconditions); the\n+               --  interpretation of the class-wide preconditions for the\n+               --  inherited subprogram is checked at the caller side.\n+\n+               --  When the subprogram inherits class-wide postconditions\n+               --  the DTW also checks the interpretation of the class-wide\n+               --  postconditions for the inherited subprogram, and the body\n+               --  of the parent checks its interpretation of the parent for\n+               --  the class-wide postconditions.\n+\n+               --      procedure Prim (F1 : T1; ...) is\n+               --         [ pragma Check (Postcondition, Expr); ]\n+               --      begin\n+               --         Par_Prim_ICW (Par_Type (F1), ...);\n+               --      end;\n+\n+               if Present (Indirect_Call_Wrapper (Par_Prim)) then\n+                  DTW_Body :=\n+                    Build_DTW_Body (Loc,\n+                      DTW_Spec     => DTW_Spec,\n+                      DTW_Decls    => Decls,\n+                      Par_Prim     => Par_Prim,\n+                      Wrapped_Subp => Indirect_Call_Wrapper (Par_Prim));\n+\n+               --  For subprograms that only inherit class-wide postconditions\n+               --  the DTW wrapper calls the parent primitive (which on its\n+               --  body checks the interpretation of the class-wide post-\n+               --  conditions for the parent subprogram), and the DTW checks\n+               --  the interpretation of the class-wide postconditions for the\n+               --  inherited subprogram.\n+\n+               --      procedure Prim (F1 : T1; ...) is\n+               --         pragma Check (Postcondition, Expr);\n+               --      begin\n+               --         Par_Prim (Par_Type (F1), ...);\n+               --      end;\n \n-               --  Insert the declaration and the body of the wrapper after\n-               --  type declaration that generates inherited operation. For\n-               --  a null procedure, the declaration implies a null body.\n-\n-               --  Before insertion, do some minimal decoration of fields\n+               else\n+                  DTW_Body :=\n+                    Build_DTW_Body (Loc,\n+                      DTW_Spec     => DTW_Spec,\n+                      DTW_Decls    => Decls,\n+                      Par_Prim     => Par_Prim,\n+                      Wrapped_Subp => Par_Prim);\n+               end if;\n \n-               Mutate_Ekind (New_Id, Ekind (Par_Prim));\n-               Set_LSP_Subprogram (New_Id, Par_Prim);\n-               Set_Is_Wrapper (New_Id);\n+               --  Insert the declaration of the wrapper before the freezing\n+               --  node of the record type declaration to ensure that it will\n+               --  override the internal primitive built by Derive_Subprogram.\n \n-               if Nkind (New_Spec) = N_Procedure_Specification\n-                 and then Null_Present (New_Spec)\n-               then\n-                  Insert_After_And_Analyze (Par_R, New_Decl);\n+               Ensure_Freeze_Node (R);\n \n+               if Late_Overriding then\n+                  Insert_Before_And_Analyze (Freeze_Node (R), DTW_Decl);\n                else\n-                  --  Build body as wrapper to a call to the already built\n-                  --  class-wide clone.\n+                  Append_Freeze_Action (R, DTW_Decl);\n+               end if;\n+\n+               Analyze (DTW_Decl);\n+\n+               --  Insert the body of the wrapper in the freeze actions of\n+               --  its record type declaration to ensure that it is placed\n+               --  in the scope of its declaration but not too early to cause\n+               --  premature freezing of other entities.\n+\n+               Append_Freeze_Action (R, DTW_Body);\n+               Analyze (DTW_Body);\n+\n+               --  Ensure correct decoration\n+\n+               pragma Assert (Is_Dispatching_Operation (DTW_Id));\n+               pragma Assert (Present (Overridden_Operation (DTW_Id)));\n+               pragma Assert (Overridden_Operation (DTW_Id) = Alias_Id);\n \n-                  New_Body :=\n-                    Build_Class_Wide_Clone_Call\n-                      (Loc, Decls, Par_Prim, New_Spec);\n+               --  Inherit dispatch table slot\n \n-                  Insert_List_After_And_Analyze\n-                    (Par_R, New_List (New_Decl, New_Body));\n+               Set_DTC_Entity_Value (R, DTW_Id);\n+               Set_DT_Position (DTW_Id, DT_Position (Alias_Id));\n \n-                  --  Ensure correct decoration\n+               --  Register the wrapper in the dispatch table\n \n-                  pragma Assert (Present (Alias (Prim)));\n-                  pragma Assert (Present (Overridden_Operation (New_Id)));\n-                  pragma Assert (Overridden_Operation (New_Id) = Alias_Id);\n+               if Late_Overriding\n+                 and then not Building_Static_DT (R)\n+               then\n+                  Insert_List_After_And_Analyze (Freeze_Node (R),\n+                    Register_Primitive (Loc, DTW_Id));\n                end if;\n \n-               pragma Assert (Is_Dispatching_Operation (Prim));\n-               pragma Assert (Is_Dispatching_Operation (New_Id));\n+               --  Build the helper and ICW for the DTW\n+\n+               if Present (Indirect_Call_Wrapper (Par_Prim)) then\n+                  declare\n+                     CW_Subp : Entity_Id;\n+                     Decl_N  : Node_Id;\n+                     Body_N  : Node_Id;\n+\n+                  begin\n+                     Merge_Class_Conditions (DTW_Id);\n+                     Make_Class_Precondition_Subps (DTW_Id,\n+                       Late_Overriding => Late_Overriding);\n+\n+                     CW_Subp := Static_Call_Helper (DTW_Id);\n+                     Decl_N  := Unit_Declaration_Node (CW_Subp);\n+                     Analyze (Decl_N);\n+\n+                     --  If the DTW was built for a late-overriding primitive\n+                     --  its body must be analyzed now (since the tagged type\n+                     --  is already frozen).\n+\n+                     if Late_Overriding then\n+                        Body_N :=\n+                          Unit_Declaration_Node\n+                            (Corresponding_Body (Decl_N));\n+                        Analyze (Body_N);\n+                     end if;\n+                  end;\n+               end if;\n \n                Pop_Scope;\n             end;\n@@ -7417,7 +7728,7 @@ package body Freeze is\n       if Is_Type (E) then\n          Freeze_And_Append (First_Subtype (E), N, Result);\n \n-         --  If we just froze a tagged non-class wide record, then freeze the\n+         --  If we just froze a tagged non-class-wide record, then freeze the\n          --  corresponding class-wide type. This must be done after the tagged\n          --  type itself is frozen, because the class-wide type refers to the\n          --  tagged type which generates the class."}, {"sha": "01747562b20853f38d697dc4346154e2eaeeaae8", "filename": "gcc/ada/freeze.ads", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/475e1d240086365da3e240fb9199eb1c5ad511f8/gcc%2Fada%2Ffreeze.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/475e1d240086365da3e240fb9199eb1c5ad511f8/gcc%2Fada%2Ffreeze.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.ads?ref=475e1d240086365da3e240fb9199eb1c5ad511f8", "patch": "@@ -174,6 +174,15 @@ package Freeze is\n    --  do not allow a size clause if the size would not otherwise be known at\n    --  compile time in any case.\n \n+   procedure Check_Inherited_Conditions\n+    (R               : Entity_Id;\n+     Late_Overriding : Boolean := False);\n+   --  For a tagged derived type R, create wrappers for inherited operations\n+   --  that have class-wide conditions, so it can be properly rewritten if\n+   --  it involves calls to other overriding primitives. Late_Overriding is\n+   --  True when we are processing the body of a primitive with no previous\n+   --  spec defined after R is frozen (see Check_Dispatching_Operation).\n+\n    function Is_Full_Access_Aggregate (N : Node_Id) return Boolean;\n    --  If a full access object is initialized with an aggregate or is assigned\n    --  an aggregate, we have to prevent a piecemeal access or assignment to the"}, {"sha": "24f57b4b2417d3f778ae9db17db0be3170370758", "filename": "gcc/ada/gen_il-fields.ads", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/475e1d240086365da3e240fb9199eb1c5ad511f8/gcc%2Fada%2Fgen_il-fields.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/475e1d240086365da3e240fb9199eb1c5ad511f8/gcc%2Fada%2Fgen_il-fields.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgen_il-fields.ads?ref=475e1d240086365da3e240fb9199eb1c5ad511f8", "patch": "@@ -461,7 +461,9 @@ package Gen_IL.Fields is\n       Can_Never_Be_Null,\n       Can_Use_Internal_Rep,\n       Checks_May_Be_Suppressed,\n-      Class_Wide_Clone,\n+      Class_Postconditions,\n+      Class_Preconditions,\n+      Class_Preconditions_Subprogram,\n       Class_Wide_Type,\n       Cloned_Subtype,\n       Component_Alignment,\n@@ -509,6 +511,7 @@ package Gen_IL.Fields is\n       Discriminant_Default_Value,\n       Discriminant_Number,\n       Dispatch_Table_Wrappers,\n+      Dynamic_Call_Helper,\n       DT_Entry_Count,\n       DT_Offset_To_Top_Func,\n       DT_Position,\n@@ -649,9 +652,12 @@ package Gen_IL.Fields is\n       Hiding_Loop_Variable,\n       Hidden_In_Formal_Instance,\n       Homonym,\n+      Ignored_Class_Postconditions,\n+      Ignored_Class_Preconditions,\n       Ignore_SPARK_Mode_Pragmas,\n       Import_Pragma,\n       Incomplete_Actuals,\n+      Indirect_Call_Wrapper,\n       In_Package_Body,\n       In_Private_Part,\n       In_Use,\n@@ -693,6 +699,7 @@ package Gen_IL.Fields is\n       Is_Discrim_SO_Function,\n       Is_Discriminant_Check_Function,\n       Is_Dispatch_Table_Entity,\n+      Is_Dispatch_Table_Wrapper,\n       Is_Dispatching_Operation,\n       Is_Elaboration_Checks_OK_Id,\n       Is_Elaboration_Warnings_OK_Id,\n@@ -892,6 +899,7 @@ package Gen_IL.Fields is\n       Spec_Entity,\n       SSO_Set_High_By_Default,\n       SSO_Set_Low_By_Default,\n+      Static_Call_Helper,\n       Static_Discrete_Predicate,\n       Static_Elaboration_Desired,\n       Static_Initialization,"}, {"sha": "bf0997e795d64f24019ee5b6097b3187bd9d9b57", "filename": "gcc/ada/gen_il-gen-gen_entities.adb", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/475e1d240086365da3e240fb9199eb1c5ad511f8/gcc%2Fada%2Fgen_il-gen-gen_entities.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/475e1d240086365da3e240fb9199eb1c5ad511f8/gcc%2Fada%2Fgen_il-gen-gen_entities.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgen_il-gen-gen_entities.adb?ref=475e1d240086365da3e240fb9199eb1c5ad511f8", "patch": "@@ -139,6 +139,7 @@ begin -- Gen_IL.Gen.Gen_Entities\n         Sm (Is_Discrim_SO_Function, Flag),\n         Sm (Is_Discriminant_Check_Function, Flag),\n         Sm (Is_Dispatch_Table_Entity, Flag),\n+        Sm (Is_Dispatch_Table_Wrapper, Flag),\n         Sm (Is_Dispatching_Operation, Flag),\n         Sm (Is_Eliminated, Flag),\n         Sm (Is_Entry_Formal, Flag),\n@@ -977,17 +978,23 @@ begin -- Gen_IL.Gen.Gen_Entities\n \n    Ab (Subprogram_Kind, Overloadable_Kind,\n        (Sm (Body_Needed_For_SAL, Flag),\n-        Sm (Class_Wide_Clone, Node_Id),\n+        Sm (Class_Postconditions, Node_Id),\n+        Sm (Class_Preconditions, Node_Id),\n+        Sm (Class_Preconditions_Subprogram, Node_Id),\n         Sm (Contract, Node_Id),\n+        Sm (Dynamic_Call_Helper, Node_Id),\n         Sm (Elaboration_Entity, Node_Id),\n         Sm (Elaboration_Entity_Required, Flag),\n         Sm (First_Entity, Node_Id),\n         Sm (Has_Expanded_Contract, Flag),\n         Sm (Has_Nested_Subprogram, Flag),\n         Sm (Has_Out_Or_In_Out_Parameter, Flag),\n         Sm (Has_Recursive_Call, Flag),\n+        Sm (Ignored_Class_Postconditions, Node_Id),\n+        Sm (Ignored_Class_Preconditions, Node_Id),\n         Sm (Ignore_SPARK_Mode_Pragmas, Flag),\n         Sm (Import_Pragma, Node_Id),\n+        Sm (Indirect_Call_Wrapper, Node_Id),\n         Sm (Interface_Alias, Node_Id),\n         Sm (Interface_Name, Node_Id),\n         Sm (Is_Elaboration_Checks_OK_Id, Flag),\n@@ -998,6 +1005,7 @@ begin -- Gen_IL.Gen.Gen_Entities\n         Sm (Overridden_Operation, Node_Id),\n         Sm (Protected_Body_Subprogram, Node_Id),\n         Sm (Scope_Depth_Value, Uint),\n+        Sm (Static_Call_Helper, Node_Id),\n         Sm (SPARK_Pragma, Node_Id),\n         Sm (SPARK_Pragma_Inherited, Flag),\n         Sm (Subps_Index, Uint)));"}, {"sha": "1720fe01cb83709ed3d1aff11f17e2ca5d76977d", "filename": "gcc/ada/ghost.adb", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/475e1d240086365da3e240fb9199eb1c5ad511f8/gcc%2Fada%2Fghost.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/475e1d240086365da3e240fb9199eb1c5ad511f8/gcc%2Fada%2Fghost.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fghost.adb?ref=475e1d240086365da3e240fb9199eb1c5ad511f8", "patch": "@@ -584,6 +584,15 @@ package body Ghost is\n    --  Start of processing for Check_Ghost_Context\n \n    begin\n+      --  Class-wide pre/postconditions of ignored pragmas are preanalyzed\n+      --  to report errors on wrong conditions; however, ignored pragmas may\n+      --  also have references to ghost entities and we must disable checking\n+      --  their context to avoid reporting spurious errors.\n+\n+      if Inside_Class_Condition_Preanalysis then\n+         return;\n+      end if;\n+\n       --  Once it has been established that the reference to the Ghost entity\n       --  is within a suitable context, ensure that the policy at the point of\n       --  declaration and at the point of use match."}, {"sha": "699f68520bad4c8832aea120d0d4a2bb9de2187b", "filename": "gcc/ada/sem.ads", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/475e1d240086365da3e240fb9199eb1c5ad511f8/gcc%2Fada%2Fsem.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/475e1d240086365da3e240fb9199eb1c5ad511f8/gcc%2Fada%2Fsem.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem.ads?ref=475e1d240086365da3e240fb9199eb1c5ad511f8", "patch": "@@ -291,6 +291,10 @@ package Sem is\n    --  freezing nodes can modify the status of this flag, any other client\n    --  should regard it as read-only.\n \n+   Inside_Class_Condition_Preanalysis : Boolean := False;\n+   --  Flag indicating whether we are preanalyzing a class-wide precondition\n+   --  or postcondition.\n+\n    Inside_Preanalysis_Without_Freezing : Nat := 0;\n    --  Flag indicating whether we are preanalyzing an expression performing no\n    --  freezing. Non-zero means we are inside (it is actually a level counter"}, {"sha": "7b6dc21b6f0beab35a06044dbc785c68e80b7233", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/475e1d240086365da3e240fb9199eb1c5ad511f8/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/475e1d240086365da3e240fb9199eb1c5ad511f8/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=475e1d240086365da3e240fb9199eb1c5ad511f8", "patch": "@@ -1339,6 +1339,16 @@ package body Sem_Attr is\n          Legal   := False;\n          Spec_Id := Empty;\n \n+         --  Skip processing during preanalysis of class-wide preconditions and\n+         --  postconditions since at this stage the expression is not installed\n+         --  yet on its definite context.\n+\n+         if Inside_Class_Condition_Preanalysis then\n+            Legal   := True;\n+            Spec_Id := Current_Scope;\n+            return;\n+         end if;\n+\n          --  Traverse the parent chain to find the aspect or pragma where the\n          --  attribute resides.\n "}, {"sha": "15b3c444125601640a1050fc6cdd8b90f365a34c", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/475e1d240086365da3e240fb9199eb1c5ad511f8/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/475e1d240086365da3e240fb9199eb1c5ad511f8/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=475e1d240086365da3e240fb9199eb1c5ad511f8", "patch": "@@ -26,6 +26,7 @@\n with Aspects;        use Aspects;\n with Atree;          use Atree;\n with Checks;         use Checks;\n+with Contracts;      use Contracts;\n with Debug;          use Debug;\n with Einfo;          use Einfo;\n with Einfo.Entities; use Einfo.Entities;\n@@ -4446,6 +4447,38 @@ package body Sem_Ch13 is\n                      goto Continue;\n                   end if;\n \n+                  --  Remember class-wide conditions; they will be merged\n+                  --  with inherited conditions.\n+\n+                  if Class_Present (Aspect)\n+                    and then A_Id in Aspect_Pre | Aspect_Post\n+                    and then Is_Subprogram (E)\n+                    and then not Is_Ignored_Ghost_Entity (E)\n+                  then\n+                     if A_Id = Aspect_Pre then\n+                        if Is_Ignored (Aspect) then\n+                           Set_Ignored_Class_Preconditions (E,\n+                             New_Copy_Tree (Expr));\n+                        else\n+                           Set_Class_Preconditions (E, New_Copy_Tree (Expr));\n+                        end if;\n+\n+                     --  Postconditions may split into separate aspects, and we\n+                     --  remember the expression before such split (i.e. when\n+                     --  the first postcondition is processed).\n+\n+                     elsif No (Class_Postconditions (E))\n+                       and then No (Ignored_Class_Postconditions (E))\n+                     then\n+                        if Is_Ignored (Aspect) then\n+                           Set_Ignored_Class_Postconditions (E,\n+                             New_Copy_Tree (Expr));\n+                        else\n+                           Set_Class_Postconditions (E, New_Copy_Tree (Expr));\n+                        end if;\n+                     end if;\n+                  end if;\n+\n                   --  If the expressions is of the form A and then B, then\n                   --  we generate separate Pre/Post aspects for the separate\n                   --  clauses. Since we allow multiple pragmas, there is no\n@@ -13169,6 +13202,13 @@ package body Sem_Ch13 is\n             end if;\n          end Check_Variant_Part;\n       end if;\n+\n+      if not In_Generic_Scope (E)\n+        and then Ekind (E) = E_Record_Type\n+        and then Is_Tagged_Type (E)\n+      then\n+         Process_Class_Conditions_At_Freeze_Point (E);\n+      end if;\n    end Freeze_Entity_Checks;\n \n    -------------------------"}, {"sha": "63bb80c129143a47c9348851f8ef00f62e6b8c3c", "filename": "gcc/ada/sem_ch5.adb", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/475e1d240086365da3e240fb9199eb1c5ad511f8/gcc%2Fada%2Fsem_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/475e1d240086365da3e240fb9199eb1c5ad511f8/gcc%2Fada%2Fsem_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch5.adb?ref=475e1d240086365da3e240fb9199eb1c5ad511f8", "patch": "@@ -3028,6 +3028,10 @@ package body Sem_Ch5 is\n             then\n                Analyze_And_Resolve (Original_Bound, Typ);\n                return Original_Bound;\n+\n+            elsif Inside_Class_Condition_Preanalysis then\n+               Analyze_And_Resolve (Original_Bound, Typ);\n+               return Original_Bound;\n             end if;\n \n             --  Normally, the best approach is simply to generate a constant\n@@ -3333,11 +3337,17 @@ package body Sem_Ch5 is\n       --  or post-condition has been expanded. Update the type of the loop\n       --  variable to reflect the proper itype at each stage of analysis.\n \n+      --  Loop_Nod might not be present when we are preanalyzing a class-wide\n+      --  pre/postcondition since preanalysis occurs in a place unrelated to\n+      --  the actual code and the quantified expression may be the outermost\n+      --  expression of the class-wide condition.\n+\n       if No (Etype (Id))\n         or else Etype (Id) = Any_Type\n         or else\n           (Present (Etype (Id))\n             and then Is_Itype (Etype (Id))\n+            and then Present (Loop_Nod)\n             and then Nkind (Parent (Loop_Nod)) = N_Expression_With_Actions\n             and then Nkind (Original_Node (Parent (Loop_Nod))) =\n                                                    N_Quantified_Expression)"}, {"sha": "1fcbdfbf918b769b1cbb6400fa7857fbfeb05eb1", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 1, "deletions": 23, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/475e1d240086365da3e240fb9199eb1c5ad511f8/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/475e1d240086365da3e240fb9199eb1c5ad511f8/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=475e1d240086365da3e240fb9199eb1c5ad511f8", "patch": "@@ -4498,29 +4498,6 @@ package body Sem_Ch6 is\n          end if;\n       end if;\n \n-      --  If the subprogram has a class-wide clone, build its body as a copy\n-      --  of the original body, and rewrite body of original subprogram as a\n-      --  wrapper that calls the clone. If N is a stub, this construction will\n-      --  take place when the proper body is analyzed. No action needed if this\n-      --  subprogram has been eliminated.\n-\n-      if Present (Spec_Id)\n-        and then Present (Class_Wide_Clone (Spec_Id))\n-        and then (Comes_From_Source (N) or else Was_Expression_Function (N))\n-        and then Nkind (N) /= N_Subprogram_Body_Stub\n-        and then not (Expander_Active and then Is_Eliminated (Spec_Id))\n-      then\n-         Build_Class_Wide_Clone_Body (Spec_Id, N);\n-\n-         --  This is the new body for the existing primitive operation\n-\n-         Rewrite (N, Build_Class_Wide_Clone_Call\n-           (Sloc (N), New_List, Spec_Id, Parent (Spec_Id)));\n-         Set_Has_Completion (Spec_Id, False);\n-         Analyze (N);\n-         return;\n-      end if;\n-\n       --  Place subprogram on scope stack, and make formals visible. If there\n       --  is a spec, the visible entity remains that of the spec.\n \n@@ -10413,6 +10390,7 @@ package body Sem_Ch6 is\n    begin\n       Set_Is_Immediately_Visible (E);\n       Set_Current_Entity (E);\n+      pragma Assert (Prev /= E);\n       Set_Homonym (E, Prev);\n    end Install_Entity;\n "}, {"sha": "cba3c9dbb0d234f83354df72fd0c9b83ab9ea289", "filename": "gcc/ada/sem_disp.adb", "status": "modified", "additions": 110, "deletions": 0, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/475e1d240086365da3e240fb9199eb1c5ad511f8/gcc%2Fada%2Fsem_disp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/475e1d240086365da3e240fb9199eb1c5ad511f8/gcc%2Fada%2Fsem_disp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_disp.adb?ref=475e1d240086365da3e240fb9199eb1c5ad511f8", "patch": "@@ -32,9 +32,11 @@ with Einfo.Entities; use Einfo.Entities;\n with Einfo.Utils;    use Einfo.Utils;\n with Exp_Disp;       use Exp_Disp;\n with Exp_Util;       use Exp_Util;\n+with Exp_Ch6;        use Exp_Ch6;\n with Exp_Ch7;        use Exp_Ch7;\n with Exp_Tss;        use Exp_Tss;\n with Errout;         use Errout;\n+with Freeze;         use Freeze;\n with Lib.Xref;       use Lib.Xref;\n with Namet;          use Namet;\n with Nlists;         use Nlists;\n@@ -197,6 +199,91 @@ package body Sem_Disp is\n       return Empty;\n    end Covered_Interface_Op;\n \n+   ----------------------------------\n+   -- Covered_Interface_Primitives --\n+   ----------------------------------\n+\n+   function Covered_Interface_Primitives (Prim : Entity_Id) return Elist_Id is\n+      Tagged_Type : constant Entity_Id := Find_Dispatching_Type (Prim);\n+      Elmt        : Elmt_Id;\n+      E           : Entity_Id;\n+      Result      : Elist_Id := No_Elist;\n+\n+   begin\n+      pragma Assert (Is_Dispatching_Operation (Prim));\n+\n+      --  Although this is a dispatching primitive we must check if its\n+      --  dispatching type is available because it may be the primitive\n+      --  of a private type not defined as tagged in its partial view.\n+\n+      if Present (Tagged_Type) and then Has_Interfaces (Tagged_Type) then\n+\n+         --  If the tagged type is frozen then the internal entities associated\n+         --  with interfaces are available in the list of primitives of the\n+         --  tagged type and can be used to speed up this search.\n+\n+         if Is_Frozen (Tagged_Type) then\n+            Elmt := First_Elmt (Primitive_Operations (Tagged_Type));\n+            while Present (Elmt) loop\n+               E := Node (Elmt);\n+\n+               if Present (Interface_Alias (E))\n+                 and then Alias (E) = Prim\n+               then\n+                  if No (Result) then\n+                     Result := New_Elmt_List;\n+                  end if;\n+\n+                  Append_Elmt (Interface_Alias (E), Result);\n+               end if;\n+\n+               Next_Elmt (Elmt);\n+            end loop;\n+\n+         --  Otherwise we must collect all the interface primitives and check\n+         --  whether the Prim overrides (implements) some interface primitive.\n+\n+         else\n+            declare\n+               Ifaces_List : Elist_Id;\n+               Iface_Elmt  : Elmt_Id;\n+               Iface       : Entity_Id;\n+               Iface_Prim  : Entity_Id;\n+\n+            begin\n+               Collect_Interfaces (Tagged_Type, Ifaces_List);\n+\n+               Iface_Elmt := First_Elmt (Ifaces_List);\n+               while Present (Iface_Elmt) loop\n+                  Iface := Node (Iface_Elmt);\n+\n+                  Elmt := First_Elmt (Primitive_Operations (Iface));\n+                  while Present (Elmt) loop\n+                     Iface_Prim := Node (Elmt);\n+\n+                     if Chars (Iface_Prim) = Chars (Prim)\n+                       and then Is_Interface_Conformant\n+                                  (Tagged_Type, Iface_Prim, Prim)\n+                     then\n+                        if No (Result) then\n+                           Result := New_Elmt_List;\n+                        end if;\n+\n+                        Append_Elmt (Iface_Prim, Result);\n+                     end if;\n+\n+                     Next_Elmt (Elmt);\n+                  end loop;\n+\n+                  Next_Elmt (Iface_Elmt);\n+               end loop;\n+            end;\n+         end if;\n+      end if;\n+\n+      return Result;\n+   end Covered_Interface_Primitives;\n+\n    -------------------------------\n    -- Check_Controlling_Formals --\n    -------------------------------\n@@ -592,6 +679,14 @@ package body Sem_Disp is\n       --  Start of processing for Check_Dispatching_Context\n \n       begin\n+         --  Skip checking context of dispatching calls during preanalysis of\n+         --  class-wide conditions since at that stage the expression is not\n+         --  installed yet on its definite context.\n+\n+         if Inside_Class_Condition_Preanalysis then\n+            return;\n+         end if;\n+\n          --  If the called subprogram is a private overriding, replace it\n          --  with its alias, which has the correct body. Verify that the\n          --  two subprograms have the same controlling type (this is not the\n@@ -992,10 +1087,17 @@ package body Sem_Disp is\n          --  nonstatic values, then report an error. This is specified by\n          --  RM 6.1.1(18.2/5) (by AI12-0412).\n \n+         --  Skip reporting this error on helpers and indirect-call wrappers\n+         --  built to support class-wide preconditions.\n+\n          if No (Control)\n            and then not Is_Abstract_Subprogram (Subp_Entity)\n            and then\n              Is_Prim_Of_Abst_Type_With_Nonstatic_CW_Pre_Post (Subp_Entity)\n+           and then not\n+             (Is_Subprogram (Current_Scope)\n+                and then\n+              Present (Class_Preconditions_Subprogram (Current_Scope)))\n          then\n             Error_Msg_N\n               (\"nondispatching call to nonabstract subprogram of \"\n@@ -1463,6 +1565,9 @@ package body Sem_Disp is\n                               end;\n                            end if;\n                         end if;\n+\n+                        Check_Inherited_Conditions (Tagged_Type,\n+                          Late_Overriding => True);\n                      end if;\n                   end if;\n                end;\n@@ -2925,6 +3030,11 @@ package body Sem_Disp is\n          Next_Actual (Arg);\n       end loop;\n \n+      --  Add class-wide precondition check if the target of this dispatching\n+      --  call has or inherits class-wide preconditions.\n+\n+      Install_Class_Preconditions_Check (Call_Node);\n+\n       --  Expansion of dispatching calls is suppressed on VM targets, because\n       --  the VM back-ends directly handle the generation of dispatching calls\n       --  and would have to undo any expansion to an indirect call."}, {"sha": "f37391b63070a07b26ca50b4331a92f45b48256b", "filename": "gcc/ada/sem_disp.ads", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/475e1d240086365da3e240fb9199eb1c5ad511f8/gcc%2Fada%2Fsem_disp.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/475e1d240086365da3e240fb9199eb1c5ad511f8/gcc%2Fada%2Fsem_disp.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_disp.ads?ref=475e1d240086365da3e240fb9199eb1c5ad511f8", "patch": "@@ -74,6 +74,10 @@ package Sem_Disp is\n    --  The Alias of Old_Subp is adjusted to point to the inherited procedure\n    --  of the full view because it is always this one which has to be called.\n \n+   function Covered_Interface_Primitives (Prim : Entity_Id) return Elist_Id;\n+   --  Returns all the interface primitives covered by Prim, when its\n+   --  controlling type has progenitors.\n+\n    function Covered_Interface_Op (Prim : Entity_Id) return Entity_Id;\n    --  Returns the interface primitive that Prim covers, when its controlling\n    --  type has progenitors."}, {"sha": "7386ecc1b938d184f3d86d832f4e64c00a99513b", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 4, "deletions": 34, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/475e1d240086365da3e240fb9199eb1c5ad511f8/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/475e1d240086365da3e240fb9199eb1c5ad511f8/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=475e1d240086365da3e240fb9199eb1c5ad511f8", "patch": "@@ -25896,23 +25896,6 @@ package body Sem_Prag is\n                        (\"operation in class-wide condition must be primitive \"\n                         & \"of &\", Nod, Disp_Typ);\n                   end if;\n-\n-               --  Otherwise we have a call to an overridden primitive, and we\n-               --  will create a common class-wide clone for the body of\n-               --  original operation and its eventual inherited versions. If\n-               --  the original operation dispatches on result it is never\n-               --  inherited and there is no need for a clone. There is not\n-               --  need for a clone either in GNATprove mode, as cases that\n-               --  would require it are rejected (when an inherited primitive\n-               --  calls an overridden operation in a class-wide contract), and\n-               --  the clone would make proof impossible in some cases.\n-\n-               elsif not Is_Abstract_Subprogram (Spec_Id)\n-                 and then No (Class_Wide_Clone (Spec_Id))\n-                 and then not Has_Controlling_Result (Spec_Id)\n-                 and then not GNATprove_Mode\n-               then\n-                  Build_Class_Wide_Clone_Decl (Spec_Id);\n                end if;\n             end;\n \n@@ -26033,15 +26016,6 @@ package body Sem_Prag is\n          End_Scope;\n       end if;\n \n-      --  If analysis of the condition indicates that a class-wide clone\n-      --  has been created, build and analyze its declaration.\n-\n-      if Is_Subprogram (Spec_Id)\n-        and then Present (Class_Wide_Clone (Spec_Id))\n-      then\n-         Analyze (Unit_Declaration_Node (Class_Wide_Clone (Spec_Id)));\n-      end if;\n-\n       --  Currently it is not possible to inline pre/postconditions on a\n       --  subprogram subject to pragma Inline_Always.\n \n@@ -29528,9 +29502,6 @@ package body Sem_Prag is\n       Msg_Arg    : Node_Id;\n       Nam        : Name_Id;\n \n-      Needs_Wrapper : Boolean;\n-      pragma Unreferenced (Needs_Wrapper);\n-\n    --  Start of processing for Build_Pragma_Check_Equivalent\n \n    begin\n@@ -29557,11 +29528,10 @@ package body Sem_Prag is\n          --  Build the inherited class-wide condition\n \n          Build_Class_Wide_Expression\n-           (Prag          => Check_Prag,\n-            Subp          => Subp_Id,\n-            Par_Subp      => Inher_Id,\n-            Adjust_Sloc   => True,\n-            Needs_Wrapper => Needs_Wrapper);\n+           (Pragma_Or_Expr => Check_Prag,\n+            Subp           => Subp_Id,\n+            Par_Subp       => Inher_Id,\n+            Adjust_Sloc    => True);\n \n       --  If not an inherited condition simply copy the original pragma\n "}, {"sha": "0d013ba7ec14f51c6450adfb66a59dedd671f8a3", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/475e1d240086365da3e240fb9199eb1c5ad511f8/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/475e1d240086365da3e240fb9199eb1c5ad511f8/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=475e1d240086365da3e240fb9199eb1c5ad511f8", "patch": "@@ -4891,10 +4891,15 @@ package body Sem_Res is\n \n             --  Apply legality rule 3.9.2  (9/1)\n \n+            --  Skip this check on helpers and indirect-call wrappers built to\n+            --  support class-wide preconditions.\n+\n             if (Is_Class_Wide_Type (A_Typ) or else Is_Dynamically_Tagged (A))\n               and then not Is_Class_Wide_Type (F_Typ)\n               and then not Is_Controlling_Formal (F)\n               and then not In_Instance\n+              and then (not Is_Subprogram (Nam)\n+                         or else No (Class_Preconditions_Subprogram (Nam)))\n             then\n                Error_Msg_N (\"class-wide argument not allowed here!\", A);\n \n@@ -4992,9 +4997,13 @@ package body Sem_Res is\n             --  \"False\" cannot act as an actual in a subprogram with value\n             --  \"True\" (SPARK RM 6.1.7(3)).\n \n+            --  No check needed for helpers and indirect-call wrappers built to\n+            --  support class-wide preconditions.\n+\n             if Is_EVF_Expression (A)\n               and then Extensions_Visible_Status (Nam) =\n                        Extensions_Visible_True\n+              and then No (Class_Preconditions_Subprogram (Current_Scope))\n             then\n                Error_Msg_N\n                  (\"formal parameter cannot act as actual parameter when \""}, {"sha": "98e687791071bc8c9cbc1ea7f024e0a697419cd0", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 87, "deletions": 174, "changes": 261, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/475e1d240086365da3e240fb9199eb1c5ad511f8/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/475e1d240086365da3e240fb9199eb1c5ad511f8/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=475e1d240086365da3e240fb9199eb1c5ad511f8", "patch": "@@ -2212,180 +2212,6 @@ package body Sem_Util is\n       return Empty;\n    end Build_Actual_Subtype_Of_Component;\n \n-   ---------------------------------\n-   -- Build_Class_Wide_Clone_Body --\n-   ---------------------------------\n-\n-   procedure Build_Class_Wide_Clone_Body\n-     (Spec_Id : Entity_Id;\n-      Bod     : Node_Id)\n-   is\n-      Loc        : constant Source_Ptr := Sloc (Bod);\n-      Clone_Id   : constant Entity_Id  := Class_Wide_Clone (Spec_Id);\n-      Clone_Body : Node_Id;\n-      Assoc_List : constant Elist_Id := New_Elmt_List;\n-\n-   begin\n-      --  The declaration of the class-wide clone was created when the\n-      --  corresponding class-wide condition was analyzed.\n-\n-      --  The body of the original condition may contain references to\n-      --  the formals of Spec_Id. In the body of the class-wide clone,\n-      --  these must be replaced with the corresponding formals of\n-      --  the clone.\n-\n-      declare\n-         Spec_Formal_Id  : Entity_Id := First_Formal (Spec_Id);\n-         Clone_Formal_Id : Entity_Id := First_Formal (Clone_Id);\n-      begin\n-         while Present (Spec_Formal_Id) loop\n-            Append_Elmt (Spec_Formal_Id,  Assoc_List);\n-            Append_Elmt (Clone_Formal_Id, Assoc_List);\n-\n-            Next_Formal (Spec_Formal_Id);\n-            Next_Formal (Clone_Formal_Id);\n-         end loop;\n-      end;\n-\n-      Clone_Body :=\n-        Make_Subprogram_Body (Loc,\n-          Specification              =>\n-            Copy_Subprogram_Spec (Parent (Clone_Id)),\n-          Declarations               => Declarations (Bod),\n-          Handled_Statement_Sequence =>\n-            New_Copy_Tree (Handled_Statement_Sequence (Bod),\n-              Map => Assoc_List));\n-\n-      --  The new operation is internal and overriding indicators do not apply\n-      --  (the original primitive may have carried one).\n-\n-      Set_Must_Override (Specification (Clone_Body), False);\n-\n-      --  If the subprogram body is the proper body of a stub, insert the\n-      --  subprogram after the stub, i.e. the same declarative region as\n-      --  the original sugprogram.\n-\n-      if Nkind (Parent (Bod)) = N_Subunit then\n-         Insert_After (Corresponding_Stub (Parent (Bod)), Clone_Body);\n-\n-      else\n-         Insert_Before (Bod, Clone_Body);\n-      end if;\n-\n-      Analyze (Clone_Body);\n-   end Build_Class_Wide_Clone_Body;\n-\n-   ---------------------------------\n-   -- Build_Class_Wide_Clone_Call --\n-   ---------------------------------\n-\n-   function Build_Class_Wide_Clone_Call\n-     (Loc     : Source_Ptr;\n-      Decls   : List_Id;\n-      Spec_Id : Entity_Id;\n-      Spec    : Node_Id) return Node_Id\n-   is\n-      Clone_Id : constant Entity_Id := Class_Wide_Clone (Spec_Id);\n-      Par_Type : constant Entity_Id := Find_Dispatching_Type (Spec_Id);\n-\n-      Actuals    : List_Id;\n-      Call       : Node_Id;\n-      Formal     : Entity_Id;\n-      New_Body   : Node_Id;\n-      New_F_Spec : Entity_Id;\n-      New_Formal : Entity_Id;\n-\n-   begin\n-      Actuals    := Empty_List;\n-      Formal     := First_Formal (Spec_Id);\n-      New_F_Spec := First (Parameter_Specifications (Spec));\n-\n-      --  Build parameter association for call to class-wide clone.\n-\n-      while Present (Formal) loop\n-         New_Formal := Defining_Identifier (New_F_Spec);\n-\n-         --  If controlling argument and operation is inherited, add conversion\n-         --  to parent type for the call.\n-\n-         if Etype (Formal) = Par_Type\n-           and then not Is_Empty_List (Decls)\n-         then\n-            Append_To (Actuals,\n-              Make_Type_Conversion (Loc,\n-                New_Occurrence_Of (Par_Type, Loc),\n-                New_Occurrence_Of (New_Formal, Loc)));\n-\n-         else\n-            Append_To (Actuals, New_Occurrence_Of (New_Formal, Loc));\n-         end if;\n-\n-         Next_Formal (Formal);\n-         Next (New_F_Spec);\n-      end loop;\n-\n-      if Ekind (Spec_Id) = E_Procedure then\n-         Call :=\n-           Make_Procedure_Call_Statement (Loc,\n-             Name                   => New_Occurrence_Of (Clone_Id, Loc),\n-             Parameter_Associations => Actuals);\n-      else\n-         Call :=\n-           Make_Simple_Return_Statement (Loc,\n-            Expression =>\n-              Make_Function_Call (Loc,\n-                Name                   => New_Occurrence_Of (Clone_Id, Loc),\n-                Parameter_Associations => Actuals));\n-      end if;\n-\n-      New_Body :=\n-        Make_Subprogram_Body (Loc,\n-          Specification              =>\n-            Copy_Subprogram_Spec (Spec),\n-          Declarations               => Decls,\n-          Handled_Statement_Sequence =>\n-            Make_Handled_Sequence_Of_Statements (Loc,\n-              Statements => New_List (Call),\n-              End_Label  => Make_Identifier (Loc, Chars (Spec_Id))));\n-\n-      return New_Body;\n-   end Build_Class_Wide_Clone_Call;\n-\n-   ---------------------------------\n-   -- Build_Class_Wide_Clone_Decl --\n-   ---------------------------------\n-\n-   procedure Build_Class_Wide_Clone_Decl (Spec_Id : Entity_Id) is\n-      Loc      : constant Source_Ptr := Sloc (Spec_Id);\n-      Clone_Id : constant Entity_Id  :=\n-                   Make_Defining_Identifier (Loc,\n-                     New_External_Name (Chars (Spec_Id), Suffix => \"CL\"));\n-\n-      Decl : Node_Id;\n-      Spec : Node_Id;\n-\n-   begin\n-      Spec := Copy_Subprogram_Spec (Parent (Spec_Id));\n-      Set_Must_Override      (Spec, False);\n-      Set_Must_Not_Override  (Spec, False);\n-      Set_Defining_Unit_Name (Spec, Clone_Id);\n-\n-      Decl := Make_Subprogram_Declaration (Loc, Spec);\n-      Append (Decl, List_Containing (Unit_Declaration_Node (Spec_Id)));\n-\n-      --  Link clone to original subprogram, for use when building body and\n-      --  wrapper call to inherited operation.\n-\n-      Set_Class_Wide_Clone (Spec_Id, Clone_Id);\n-\n-      --  Inherit debug info flag from Spec_Id to Clone_Id to allow debugging\n-      --  of the class-wide clone subprogram.\n-\n-      if Needs_Debug_Info (Spec_Id) then\n-         Set_Debug_Info_Needed (Clone_Id);\n-      end if;\n-   end Build_Class_Wide_Clone_Decl;\n-\n    -----------------------------\n    -- Build_Component_Subtype --\n    -----------------------------\n@@ -5878,6 +5704,30 @@ package body Sem_Util is\n       end if;\n    end Choice_List;\n \n+   ---------------------\n+   -- Class_Condition --\n+   ---------------------\n+\n+   function Class_Condition\n+     (Kind : Condition_Kind;\n+      Subp : Entity_Id) return Node_Id is\n+\n+   begin\n+      case Kind is\n+         when Class_Postcondition =>\n+            return Class_Postconditions (Subp);\n+\n+         when Class_Precondition =>\n+            return Class_Preconditions (Subp);\n+\n+         when Ignored_Class_Postcondition =>\n+            return Ignored_Class_Postconditions (Subp);\n+\n+         when Ignored_Class_Precondition =>\n+            return Ignored_Class_Preconditions (Subp);\n+      end case;\n+   end Class_Condition;\n+\n    -------------------------\n    -- Collect_Body_States --\n    -------------------------\n@@ -22789,6 +22639,61 @@ package body Sem_Util is\n       return Result;\n    end Might_Raise;\n \n+   ----------------------------------------\n+   -- Nearest_Class_Condition_Subprogram --\n+   ----------------------------------------\n+\n+   function Nearest_Class_Condition_Subprogram\n+     (Kind    : Condition_Kind;\n+      Spec_Id : Entity_Id) return Entity_Id\n+   is\n+      Subp_Id : constant Entity_Id := Ultimate_Alias (Spec_Id);\n+\n+   begin\n+      --  Prevent cascaded errors\n+\n+      if not Is_Dispatching_Operation (Subp_Id) then\n+         return Empty;\n+\n+      --  No need to search if this subprogram has class-wide postconditions\n+\n+      elsif Present (Class_Condition (Kind, Subp_Id)) then\n+         return Subp_Id;\n+      end if;\n+\n+      --  Process the contracts of inherited subprograms, looking for\n+      --  class-wide pre/postconditions.\n+\n+      declare\n+         Subps   : constant Subprogram_List := Inherited_Subprograms (Subp_Id);\n+         Subp_Id : Entity_Id;\n+\n+      begin\n+         for Index in Subps'Range loop\n+            Subp_Id := Subps (Index);\n+\n+            if Present (Alias (Subp_Id)) then\n+               Subp_Id := Ultimate_Alias (Subp_Id);\n+            end if;\n+\n+            --  Wrappers of class-wide pre/postconditions reference the\n+            --  parent primitive that has the inherited contract.\n+\n+            if Is_Wrapper (Subp_Id)\n+              and then Present (LSP_Subprogram (Subp_Id))\n+            then\n+               Subp_Id := LSP_Subprogram (Subp_Id);\n+            end if;\n+\n+            if Present (Class_Condition (Kind, Subp_Id)) then\n+               return Subp_Id;\n+            end if;\n+         end loop;\n+      end;\n+\n+      return Empty;\n+   end Nearest_Class_Condition_Subprogram;\n+\n    --------------------------------\n    -- Nearest_Enclosing_Instance --\n    --------------------------------\n@@ -31535,8 +31440,16 @@ package body Sem_Util is\n                --  type case correctly, so we avoid that problem by\n                --  returning True here.\n                return True;\n+\n             elsif Ada_Version < Ada_2022 then\n                return False;\n+\n+            elsif Inside_Class_Condition_Preanalysis then\n+               --  No need to evaluate it during preanalysis of a class-wide\n+               --  pre/postcondition since the expression is not installed yet\n+               --  on its definite context.\n+               return False;\n+\n             elsif not Is_Conditionally_Evaluated (Expr) then\n                return False;\n             else"}, {"sha": "7a7771562c6127d1c0c98016e6eb5e24c929c67f", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 18, "deletions": 24, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/475e1d240086365da3e240fb9199eb1c5ad511f8/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/475e1d240086365da3e240fb9199eb1c5ad511f8/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=475e1d240086365da3e240fb9199eb1c5ad511f8", "patch": "@@ -283,30 +283,6 @@ package Sem_Util is\n    --  take care of constructing declaration and body of the clone, and\n    --  building the calls to it within the appropriate wrappers.\n \n-   procedure Build_Class_Wide_Clone_Body\n-     (Spec_Id  : Entity_Id;\n-      Bod      : Node_Id);\n-   --  Build body of subprogram that has a class-wide condition that contains\n-   --  calls to other primitives. Spec_Id is the Id of the subprogram, and B\n-   --  is its source body, which becomes the body of the clone.\n-\n-   function Build_Class_Wide_Clone_Call\n-    (Loc      : Source_Ptr;\n-     Decls    : List_Id;\n-     Spec_Id  : Entity_Id;\n-     Spec     : Node_Id) return Node_Id;\n-   --  Build a call to the common class-wide clone of a subprogram with\n-   --  class-wide conditions. The body of the subprogram becomes a wrapper\n-   --  for a call to the clone. The inherited operation becomes a similar\n-   --  wrapper to which modified conditions apply, and the call to the\n-   --  clone includes the proper conversion in a call the parent operation.\n-\n-   procedure Build_Class_Wide_Clone_Decl (Spec_Id : Entity_Id);\n-   --  For a subprogram that has a class-wide condition that contains calls\n-   --  to other primitives, build an internal subprogram that is invoked\n-   --  through a type-specific wrapper for all inherited subprograms that\n-   --  may have a modified condition.\n-\n    procedure Build_Constrained_Itype\n      (N              : Node_Id;\n       Typ            : Entity_Id;\n@@ -527,6 +503,18 @@ package Sem_Util is\n    --  reasons these nodes have a different structure even though they play\n    --  similar roles in array aggregates.\n \n+   type Condition_Kind is\n+     (Ignored_Class_Precondition,\n+      Ignored_Class_Postcondition,\n+      Class_Precondition,\n+      Class_Postcondition);\n+   --  Kind of class-wide conditions\n+\n+   function Class_Condition\n+     (Kind : Condition_Kind;\n+      Subp : Entity_Id) return Node_Id;\n+   --  Class-wide Kind condition of Subp\n+\n    function Collect_Body_States (Body_Id : Entity_Id) return Elist_Id;\n    --  Gather the entities of all abstract states and objects declared in the\n    --  body state space of package body Body_Id.\n@@ -2621,6 +2609,12 @@ package Sem_Util is\n    --  if we're not sure, we return True. If N is a subprogram body, this is\n    --  about whether execution of that body can raise.\n \n+   function Nearest_Class_Condition_Subprogram\n+     (Kind    : Condition_Kind;\n+      Spec_Id : Entity_Id) return Entity_Id;\n+   --  Return the nearest ancestor containing the merged class-wide conditions\n+   --  that statically apply to Spec_Id; return Empty otherwise.\n+\n    function Nearest_Enclosing_Instance (E : Entity_Id) return Entity_Id;\n    --  Return the entity of the nearest enclosing instance which encapsulates\n    --  entity E. If no such instance exits, return Empty."}]}