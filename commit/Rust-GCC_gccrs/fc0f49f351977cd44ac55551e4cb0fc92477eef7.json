{"sha": "fc0f49f351977cd44ac55551e4cb0fc92477eef7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmMwZjQ5ZjM1MTk3N2NkNDRhYzU1NTUxZTRjYjBmYzkyNDc3ZWVmNw==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2008-03-06T12:08:23Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2008-03-06T12:08:23Z"}, "message": "tree.def (BIT_FIELD_REF): Constrain result type and its precision.\n\n2008-03-06  Richard Guenther  <rguenther@suse.de>\n\n\t* tree.def (BIT_FIELD_REF): Constrain result type and its precision.\n\t* tree-cfg.c (verify_expr): Verify BIT_FIELD_REF constraints on\n\tresult type and precision.\n\t* expr.c (get_inner_reference): Set unsignedp based on the result\n\ttype of BIT_FIELD_REF.\n\t* tree.h (BIT_FIELD_REF_UNSIGNED): Remove.\n\t* tree-sra.c (instantiate_element): Do not set BIT_FIELD_REF_UNSIGNED.\n\t(try_instantiate_multiple_fields): Likewise.  Use the correct type\n\tfor BIT_FIELD_REF.\n\t(sra_build_assignment): Likewise.\n\t(sra_build_elt_assignment): Likewise.\n\t(sra_explode_bitfield_assignment): Likewise.\n\t* print-tree.c (print_node): Do not check BIT_FIELD_REF_UNSIGNED.\n\t* tree-vect-transform.c (vect_create_epilog_for_reduction): Do not\n\tset BIT_FIELD_REF_UNSIGNED.\n\t(vectorizable_load): Likewise.\n\nFrom-SVN: r132969", "tree": {"sha": "bebeb96faecfdcf797f71dee5229fe073b7e2e3e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bebeb96faecfdcf797f71dee5229fe073b7e2e3e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fc0f49f351977cd44ac55551e4cb0fc92477eef7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc0f49f351977cd44ac55551e4cb0fc92477eef7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fc0f49f351977cd44ac55551e4cb0fc92477eef7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc0f49f351977cd44ac55551e4cb0fc92477eef7/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e186ff694e3233b58c8b7d04e90f223f84b9d691", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e186ff694e3233b58c8b7d04e90f223f84b9d691", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e186ff694e3233b58c8b7d04e90f223f84b9d691"}], "stats": {"total": 81, "additions": 53, "deletions": 28}, "files": [{"sha": "62d7822121499795cee198f21cd032265049f423", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc0f49f351977cd44ac55551e4cb0fc92477eef7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc0f49f351977cd44ac55551e4cb0fc92477eef7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fc0f49f351977cd44ac55551e4cb0fc92477eef7", "patch": "@@ -1,3 +1,22 @@\n+2008-03-06  Richard Guenther  <rguenther@suse.de>\n+\n+\t* tree.def (BIT_FIELD_REF): Constrain result type and its precision.\n+\t* tree-cfg.c (verify_expr): Verify BIT_FIELD_REF constraints on\n+\tresult type and precision.\n+\t* expr.c (get_inner_reference): Set unsignedp based on the result\n+\ttype of BIT_FIELD_REF.\n+\t* tree.h (BIT_FIELD_REF_UNSIGNED): Remove.\n+\t* tree-sra.c (instantiate_element): Do not set BIT_FIELD_REF_UNSIGNED.\n+\t(try_instantiate_multiple_fields): Likewise.  Use the correct type\n+\tfor BIT_FIELD_REF.\n+\t(sra_build_assignment): Likewise.\n+\t(sra_build_elt_assignment): Likewise.\n+\t(sra_explode_bitfield_assignment): Likewise.\n+\t* print-tree.c (print_node): Do not check BIT_FIELD_REF_UNSIGNED.\n+\t* tree-vect-transform.c (vect_create_epilog_for_reduction): Do not\n+\tset BIT_FIELD_REF_UNSIGNED.\n+\t(vectorizable_load): Likewise.\n+\n 2008-03-06  Andreas Krebbel  <krebbel1@de.ibm.com>\n \n \t* cse.c (cse_extended_basic_block): Invalidate artificial defs"}, {"sha": "2cd6e627843e983e9f0f0afe768e5db28a17d284", "filename": "gcc/expr.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc0f49f351977cd44ac55551e4cb0fc92477eef7/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc0f49f351977cd44ac55551e4cb0fc92477eef7/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=fc0f49f351977cd44ac55551e4cb0fc92477eef7", "patch": "@@ -5893,7 +5893,8 @@ get_inner_reference (tree exp, HOST_WIDE_INT *pbitsize,\n   else if (TREE_CODE (exp) == BIT_FIELD_REF)\n     {\n       size_tree = TREE_OPERAND (exp, 1);\n-      *punsignedp = BIT_FIELD_REF_UNSIGNED (exp);\n+      *punsignedp = (! INTEGRAL_TYPE_P (TREE_TYPE (exp))\n+\t\t     || TYPE_UNSIGNED (TREE_TYPE (exp)));\n \n       /* For vector types, with the correct size of access, use the mode of\n \t inner type.  */"}, {"sha": "889f1c5f511fd2e83c88404c3d3dee39bbcd576e", "filename": "gcc/print-tree.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc0f49f351977cd44ac55551e4cb0fc92477eef7/gcc%2Fprint-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc0f49f351977cd44ac55551e4cb0fc92477eef7/gcc%2Fprint-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-tree.c?ref=fc0f49f351977cd44ac55551e4cb0fc92477eef7", "patch": "@@ -676,8 +676,6 @@ print_node (FILE *file, const char *prefix, tree node, int indent)\n     case tcc_reference:\n     case tcc_statement:\n     case tcc_vl_exp:\n-      if (TREE_CODE (node) == BIT_FIELD_REF && BIT_FIELD_REF_UNSIGNED (node))\n-\tfputs (\" unsigned\", file);\n       if (TREE_CODE (node) == BIND_EXPR)\n \t{\n \t  print_node (file, \"vars\", TREE_OPERAND (node, 0), indent + 4);"}, {"sha": "f98c684471e7d1b7c08a68519bd04142bad9c0fd", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc0f49f351977cd44ac55551e4cb0fc92477eef7/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc0f49f351977cd44ac55551e4cb0fc92477eef7/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=fc0f49f351977cd44ac55551e4cb0fc92477eef7", "patch": "@@ -3277,6 +3277,22 @@ verify_expr (tree *tp, int *walk_subtrees, void *data ATTRIBUTE_UNUSED)\n \t\t  error (\"invalid position or size operand to BIT_FIELD_REF\");\n \t\t  return t;\n \t\t}\n+\t      else if (INTEGRAL_TYPE_P (TREE_TYPE (t))\n+\t\t       && (TYPE_PRECISION (TREE_TYPE (t))\n+\t\t\t   != TREE_INT_CST_LOW (TREE_OPERAND (t, 1))))\n+\t\t{\n+\t\t  error (\"integral result type precision does not match \"\n+\t\t\t \"field size of BIT_FIELD_REF\");\n+\t\t  return t;\n+\t\t}\n+\t      if (!INTEGRAL_TYPE_P (TREE_TYPE (t))\n+\t\t  && (GET_MODE_PRECISION (TYPE_MODE (TREE_TYPE (t)))\n+\t\t      != TREE_INT_CST_LOW (TREE_OPERAND (t, 1))))\n+\t\t{\n+\t\t  error (\"mode precision of non-integral result does not \"\n+\t\t\t \"match field size of BIT_FIELD_REF\");\n+\t\t  return t;\n+\t\t}\n \t    }\n \n \t  t = TREE_OPERAND (t, 0);"}, {"sha": "45142e8e14cd07bef93c94b6b23f9231c9282183", "filename": "gcc/tree-sra.c", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc0f49f351977cd44ac55551e4cb0fc92477eef7/gcc%2Ftree-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc0f49f351977cd44ac55551e4cb0fc92477eef7/gcc%2Ftree-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-sra.c?ref=fc0f49f351977cd44ac55551e4cb0fc92477eef7", "patch": "@@ -1280,9 +1280,6 @@ instantiate_element (struct sra_elt *elt)\n \t\t\t\t\t       TYPE_SIZE (elt->type),\n \t\t\t\t\t       DECL_SIZE (var))\n \t\t\t\t : bitsize_int (0));\n-      if (!INTEGRAL_TYPE_P (elt->type)\n-\t  || TYPE_UNSIGNED (elt->type))\n-\tBIT_FIELD_REF_UNSIGNED (elt->replacement) = 1;\n     }\n \n   /* For vectors, if used on the left hand side with BIT_FIELD_REF,\n@@ -1677,12 +1674,17 @@ try_instantiate_multiple_fields (struct sra_elt *elt, tree f)\n \n   /* Create the field group as a single variable.  */\n \n-  type = lang_hooks.types.type_for_mode (mode, 1);\n+  /* We used to create a type for the mode above, but size turns\n+     to be out not of mode-size.  As we need a matching type\n+     to build a BIT_FIELD_REF, use a nonstandard integer type as\n+     fallback.  */\n+  type = lang_hooks.types.type_for_size (size, 1);\n+  if (!type || TYPE_PRECISION (type) != size)\n+    type = build_nonstandard_integer_type (size, 1);\n   gcc_assert (type);\n   var = build3 (BIT_FIELD_REF, type, NULL_TREE,\n \t\tbitsize_int (size),\n \t\tbitsize_int (bit));\n-  BIT_FIELD_REF_UNSIGNED (var) = 1;\n \n   block = instantiate_missing_elements_1 (elt, var, type);\n   gcc_assert (block && block->is_scalar);\n@@ -1696,7 +1698,6 @@ try_instantiate_multiple_fields (struct sra_elt *elt, tree f)\n \t\t\t\t   TREE_TYPE (block->element), var,\n \t\t\t\t   bitsize_int (size),\n \t\t\t\t   bitsize_int (bit & ~alchk));\n-      BIT_FIELD_REF_UNSIGNED (block->replacement) = 1;\n     }\n \n   block->in_bitfld_block = 2;\n@@ -1719,7 +1720,6 @@ try_instantiate_multiple_fields (struct sra_elt *elt, tree f)\n \t\t\t\t   + (TREE_INT_CST_LOW\n \t\t\t\t      (DECL_FIELD_BIT_OFFSET (f))))\n \t\t\t\t  & ~alchk));\n-      BIT_FIELD_REF_UNSIGNED (fld->replacement) = TYPE_UNSIGNED (field_type);\n       fld->in_bitfld_block = 1;\n     }\n \n@@ -2141,7 +2141,8 @@ sra_build_assignment (tree dst, tree src)\n       tree var, shift, width;\n       tree utype, stype, stmp, utmp, dtmp;\n       tree list, stmt;\n-      bool unsignedp = BIT_FIELD_REF_UNSIGNED (src);\n+      bool unsignedp = (INTEGRAL_TYPE_P (TREE_TYPE (src))\n+\t\t        ? TYPE_UNSIGNED (TREE_TYPE (src)) : true);\n \n       var = TREE_OPERAND (src, 0);\n       width = TREE_OPERAND (src, 1);\n@@ -2491,6 +2492,7 @@ sra_build_elt_assignment (struct sra_elt *elt, tree src)\n   if (elt->in_bitfld_block == 2\n       && TREE_CODE (src) == BIT_FIELD_REF)\n     {\n+      tmp = src;\n       cst = TYPE_SIZE (TREE_TYPE (var));\n       cst2 = size_binop (MINUS_EXPR, TREE_OPERAND (src, 2),\n \t\t\t TREE_OPERAND (dst, 2));\n@@ -2536,8 +2538,7 @@ sra_build_elt_assignment (struct sra_elt *elt, tree src)\n \t}\n       else\n \t{\n-\t  src = fold_build3 (BIT_FIELD_REF, TREE_TYPE (var), src, cst, cst2);\n-\t  BIT_FIELD_REF_UNSIGNED (src) = 1;\n+\t  src = fold_convert (TREE_TYPE (var), tmp);\n \t}\n \n       return sra_build_assignment (var, src);\n@@ -3014,6 +3015,8 @@ sra_explode_bitfield_assignment (tree var, tree vpos, bool to_var,\n \t  type = TREE_TYPE (infld);\n \t  if (TYPE_PRECISION (type) != TREE_INT_CST_LOW (flen))\n \t    type = lang_hooks.types.type_for_size (TREE_INT_CST_LOW (flen), 1);\n+\t  else\n+\t    type = unsigned_type_for (type);\n \n \t  if (TREE_CODE (infld) == BIT_FIELD_REF)\n \t    {\n@@ -3031,15 +3034,13 @@ sra_explode_bitfield_assignment (tree var, tree vpos, bool to_var,\n \t    }\n \n \t  infld = fold_build3 (BIT_FIELD_REF, type, infld, flen, fpos);\n-\t  BIT_FIELD_REF_UNSIGNED (infld) = 1;\n \n \t  invar = size_binop (MINUS_EXPR, flp.field_pos, bpos);\n \t  if (flp.overlap_pos)\n \t    invar = size_binop (PLUS_EXPR, invar, flp.overlap_pos);\n \t  invar = size_binop (PLUS_EXPR, invar, vpos);\n \n \t  invar = fold_build3 (BIT_FIELD_REF, type, var, flen, invar);\n-\t  BIT_FIELD_REF_UNSIGNED (invar) = 1;\n \n \t  if (to_var)\n \t    st = sra_build_bf_assignment (invar, infld);"}, {"sha": "a35e963b48f2caa30f4bbd61eb242f4d747ef0c7", "filename": "gcc/tree-vect-transform.c", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc0f49f351977cd44ac55551e4cb0fc92477eef7/gcc%2Ftree-vect-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc0f49f351977cd44ac55551e4cb0fc92477eef7/gcc%2Ftree-vect-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-transform.c?ref=fc0f49f351977cd44ac55551e4cb0fc92477eef7", "patch": "@@ -2517,7 +2517,6 @@ vect_create_epilog_for_reduction (tree vect_def, tree stmt,\n \t  vec_size_in_bits = tree_low_cst (TYPE_SIZE (vectype), 1);\n \t  rhs = build3 (BIT_FIELD_REF, scalar_type, vec_temp, bitsize,\n \t\t\t bitsize_zero_node);\n-\t  BIT_FIELD_REF_UNSIGNED (rhs) = TYPE_UNSIGNED (scalar_type);\n \t  epilog_stmt = build_gimple_modify_stmt (new_scalar_dest, rhs);\n \t  new_temp = make_ssa_name (new_scalar_dest, epilog_stmt);\n \t  GIMPLE_STMT_OPERAND (epilog_stmt, 0) = new_temp;\n@@ -2532,7 +2531,6 @@ vect_create_epilog_for_reduction (tree vect_def, tree stmt,\n \t      tree rhs = build3 (BIT_FIELD_REF, scalar_type, vec_temp, bitsize,\n \t\t\t\t bitpos);\n \t\t\n-\t      BIT_FIELD_REF_UNSIGNED (rhs) = TYPE_UNSIGNED (scalar_type);\n \t      epilog_stmt = build_gimple_modify_stmt (new_scalar_dest, rhs);\n \t      new_name = make_ssa_name (new_scalar_dest, epilog_stmt);\n \t      GIMPLE_STMT_OPERAND (epilog_stmt, 0) = new_name;\n@@ -2568,7 +2566,6 @@ vect_create_epilog_for_reduction (tree vect_def, tree stmt,\n \tbitpos = bitsize_zero_node;\n \n       rhs = build3 (BIT_FIELD_REF, scalar_type, new_temp, bitsize, bitpos);\n-      BIT_FIELD_REF_UNSIGNED (rhs) = TYPE_UNSIGNED (scalar_type);\n       epilog_stmt = build_gimple_modify_stmt (new_scalar_dest, rhs);\n       new_temp = make_ssa_name (new_scalar_dest, epilog_stmt);\n       GIMPLE_STMT_OPERAND (epilog_stmt, 0) = new_temp; \n@@ -5877,8 +5874,6 @@ vectorizable_load (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt,\n \t\t  bitpos = bitsize_zero_node;\n \t\t  vec_inv = build3 (BIT_FIELD_REF, scalar_type, new_temp, \n \t\t\t\t\t\t\t    bitsize, bitpos);\n-\t\t  BIT_FIELD_REF_UNSIGNED (vec_inv) = \n-\t\t\t\t\t\t TYPE_UNSIGNED (scalar_type);\n \t\t  vec_dest = \n \t\t\tvect_create_destination_var (scalar_dest, NULL_TREE);\n \t\t  new_stmt = build_gimple_modify_stmt (vec_dest, vec_inv);"}, {"sha": "4a55ee0aaf9c0409bbcd8e9b0d3bf6ecd7bd1ca9", "filename": "gcc/tree.def", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc0f49f351977cd44ac55551e4cb0fc92477eef7/gcc%2Ftree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc0f49f351977cd44ac55551e4cb0fc92477eef7/gcc%2Ftree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.def?ref=fc0f49f351977cd44ac55551e4cb0fc92477eef7", "patch": "@@ -391,8 +391,9 @@ DEFTREECODE (COMPONENT_REF, \"component_ref\", tcc_reference, 3)\n    Operand 0 is the structure or union expression;\n    operand 1 is a tree giving the constant number of bits being referenced;\n    operand 2 is a tree giving the constant position of the first referenced bit.\n-   The field can be either a signed or unsigned field;\n-   BIT_FIELD_REF_UNSIGNED says which.  */\n+   The result type width has to match the number of bits referenced.\n+   If the result type is integral, its signedness specifies how it is extended\n+   to its mode width.  */\n DEFTREECODE (BIT_FIELD_REF, \"bit_field_ref\", tcc_reference, 3)\n \n /* The ordering of the following codes is optimized for the checking"}, {"sha": "de6654de80f722c0c6eca3ae373536e3115263a4", "filename": "gcc/tree.h", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc0f49f351977cd44ac55551e4cb0fc92477eef7/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc0f49f351977cd44ac55551e4cb0fc92477eef7/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=fc0f49f351977cd44ac55551e4cb0fc92477eef7", "patch": "@@ -542,8 +542,6 @@ struct gimple_stmt GTY(())\n            all types\n        DECL_UNSIGNED in\n            all decls\n-       BIT_FIELD_REF_UNSIGNED in\n-           BIT_FIELD_REF\n \n    asm_written_flag:\n \n@@ -1301,10 +1299,6 @@ extern void omp_clause_range_check_failed (const_tree, const char *, int,\n #define DECL_UNSIGNED(NODE) \\\n   (DECL_COMMON_CHECK (NODE)->base.unsigned_flag)\n \n-/* In a BIT_FIELD_REF, means the bitfield is to be interpreted as unsigned.  */\n-#define BIT_FIELD_REF_UNSIGNED(NODE) \\\n-  (BIT_FIELD_REF_CHECK (NODE)->base.unsigned_flag)\n-\n /* In integral and pointer types, means an unsigned type.  */\n #define TYPE_UNSIGNED(NODE) (TYPE_CHECK (NODE)->base.unsigned_flag)\n "}]}