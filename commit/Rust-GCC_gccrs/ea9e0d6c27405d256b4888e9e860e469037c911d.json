{"sha": "ea9e0d6c27405d256b4888e9e860e469037c911d", "node_id": "C_kwDOANBUbNoAKGVhOWUwZDZjMjc0MDVkMjU2YjQ4ODhlOWU4NjBlNDY5MDM3YzkxMWQ", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2021-11-17T22:09:23Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2021-11-17T22:09:23Z"}, "message": "Avoid pathological function redeclarations when checking access sizes [PR102759].\n\nResolves:\nPR tree-optimization/102759 - ICE: Segmentation fault in maybe_check_access_sizes since r12-2976-gb48d4e6818674898\n\ngcc/ChangeLog:\n\n\tPR tree-optimization/102759\n\t* gimple-array-bounds.cc (build_printable_array_type): Move...\n\t* gimple-ssa-warn-access.cc (build_printable_array_type): Avoid\n\tpathological function redeclarations that remove a previously\n\tdeclared prototype.\n\tImprove formatting of function arguments in informational notes.\n\t* pointer-query.cc (build_printable_array_type): ...to here.\n\t* pointer-query.h (build_printable_array_type): Declared.\n\ngcc/testsuite/ChangeLog:\n\n\tPR tree-optimization/102759\n\t* gcc.dg/Warray-parameter-10.c: New test.\n\t* gcc.dg/Wstringop-overflow-82.c: New test.", "tree": {"sha": "acc04c95beb0bfed36eed47bb3a5131d09815bde", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/acc04c95beb0bfed36eed47bb3a5131d09815bde"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ea9e0d6c27405d256b4888e9e860e469037c911d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ea9e0d6c27405d256b4888e9e860e469037c911d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ea9e0d6c27405d256b4888e9e860e469037c911d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ea9e0d6c27405d256b4888e9e860e469037c911d/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "53a643f8568067d7700a9f2facc8ba39974973d3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/53a643f8568067d7700a9f2facc8ba39974973d3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/53a643f8568067d7700a9f2facc8ba39974973d3"}], "stats": {"total": 140, "additions": 105, "deletions": 35}, "files": [{"sha": "ddb99d263d18d9a21f6d4319f8b4947a67e1610d", "filename": "gcc/gimple-array-bounds.cc", "status": "modified", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea9e0d6c27405d256b4888e9e860e469037c911d/gcc%2Fgimple-array-bounds.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea9e0d6c27405d256b4888e9e860e469037c911d/gcc%2Fgimple-array-bounds.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-array-bounds.cc?ref=ea9e0d6c27405d256b4888e9e860e469037c911d", "patch": "@@ -372,31 +372,6 @@ array_bounds_checker::check_array_ref (location_t location, tree ref,\n   return warned;\n }\n \n-/* Wrapper around build_array_type_nelts that makes sure the array\n-   can be created at all and handles zero sized arrays specially.  */\n-\n-static tree\n-build_printable_array_type (tree eltype, unsigned HOST_WIDE_INT nelts)\n-{\n-  if (TYPE_SIZE_UNIT (eltype)\n-      && TREE_CODE (TYPE_SIZE_UNIT (eltype)) == INTEGER_CST\n-      && !integer_zerop (TYPE_SIZE_UNIT (eltype))\n-      && TYPE_ALIGN_UNIT (eltype) > 1\n-      && wi::zext (wi::to_wide (TYPE_SIZE_UNIT (eltype)),\n-\t\t   ffs_hwi (TYPE_ALIGN_UNIT (eltype)) - 1) != 0)\n-    eltype = TYPE_MAIN_VARIANT (eltype);\n-\n-  if (nelts)\n-    return build_array_type_nelts (eltype, nelts);\n-\n-  tree idxtype = build_range_type (sizetype, size_zero_node, NULL_TREE);\n-  tree arrtype = build_array_type (eltype, idxtype);\n-  arrtype = build_distinct_type_copy (TYPE_MAIN_VARIANT (arrtype));\n-  TYPE_SIZE (arrtype) = bitsize_zero_node;\n-  TYPE_SIZE_UNIT (arrtype) = size_zero_node;\n-  return arrtype;\n-}\n-\n /* Checks one MEM_REF in REF, located at LOCATION, for out-of-bounds\n    references to string constants.  If VRP can determine that the array\n    subscript is a constant, check if it is outside valid range."}, {"sha": "48bf8aaff50af5523034786107cd15c083f18c3b", "filename": "gcc/gimple-ssa-warn-access.cc", "status": "modified", "additions": 23, "deletions": 10, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea9e0d6c27405d256b4888e9e860e469037c911d/gcc%2Fgimple-ssa-warn-access.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea9e0d6c27405d256b4888e9e860e469037c911d/gcc%2Fgimple-ssa-warn-access.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-warn-access.cc?ref=ea9e0d6c27405d256b4888e9e860e469037c911d", "patch": "@@ -2978,10 +2978,16 @@ pass_waccess::maybe_check_access_sizes (rdwr_map *rwm, tree fndecl, tree fntype,\n \tcontinue;\n \n       tree ptrtype = fntype_argno_type (fntype, ptridx);\n+      if (!ptrtype)\n+\t/* A function with a prototype was redeclared without one and\n+\t   the protype has been lost.  See pr102759.  Avoid dealing\n+\t   with this pathological case.  */\n+\treturn;\n+\n       tree argtype = TREE_TYPE (ptrtype);\n \n-      /* The size of the access by the call.  */\n-      tree access_size;\n+      /* The size of the access by the call in elements.  */\n+      tree access_nelts;\n       if (sizidx == -1)\n \t{\n \t  /* If only the pointer attribute operand was specified and\n@@ -2991,17 +2997,17 @@ pass_waccess::maybe_check_access_sizes (rdwr_map *rwm, tree fndecl, tree fntype,\n \t     if the pointer is also declared with attribute nonnull.  */\n \t  if (access.second.minsize\n \t      && access.second.minsize != HOST_WIDE_INT_M1U)\n-\t    access_size = build_int_cstu (sizetype, access.second.minsize);\n+\t    access_nelts = build_int_cstu (sizetype, access.second.minsize);\n \t  else\n-\t    access_size = size_one_node;\n+\t    access_nelts = size_one_node;\n \t}\n       else\n-\taccess_size = rwm->get (sizidx)->size;\n+\taccess_nelts = rwm->get (sizidx)->size;\n \n       /* Format the value or range to avoid an explosion of messages.  */\n       char sizstr[80];\n       tree sizrng[2] = { size_zero_node, build_all_ones_cst (sizetype) };\n-      if (get_size_range (m_ptr_qry.rvals, access_size, stmt, sizrng, 1))\n+      if (get_size_range (m_ptr_qry.rvals, access_nelts, stmt, sizrng, 1))\n \t{\n \t  char *s0 = print_generic_expr_to_str (sizrng[0]);\n \t  if (tree_int_cst_equal (sizrng[0], sizrng[1]))\n@@ -3059,6 +3065,8 @@ pass_waccess::maybe_check_access_sizes (rdwr_map *rwm, tree fndecl, tree fntype,\n \t    }\n \t}\n \n+      /* The size of the access by the call in bytes.  */\n+      tree access_size = NULL_TREE;\n       if (tree_int_cst_sgn (sizrng[0]) >= 0)\n \t{\n \t  if (COMPLETE_TYPE_P (argtype))\n@@ -3075,9 +3083,9 @@ pass_waccess::maybe_check_access_sizes (rdwr_map *rwm, tree fndecl, tree fntype,\n \t\t    access_size = wide_int_to_tree (sizetype, minsize);\n \t\t  }\n \t    }\n+\t  else\n+\t    access_size = access_nelts;\n \t}\n-      else\n-\taccess_size = NULL_TREE;\n \n       if (integer_zerop (ptr))\n \t{\n@@ -3172,8 +3180,13 @@ pass_waccess::maybe_check_access_sizes (rdwr_map *rwm, tree fndecl, tree fntype,\n       if (opt_warned != no_warning)\n \t{\n \t  if (access.second.internal_p)\n-\t    inform (loc, \"referencing argument %u of type %qT\",\n-\t\t    ptridx + 1, ptrtype);\n+\t    {\n+\t      unsigned HOST_WIDE_INT nelts =\n+\t\taccess_nelts ? access.second.minsize : HOST_WIDE_INT_M1U;\n+\t      tree arrtype = build_printable_array_type (argtype, nelts);\n+\t      inform (loc, \"referencing argument %u of type %qT\",\n+\t\t      ptridx + 1, arrtype);\n+\t    }\n \t  else\n \t    /* If check_access issued a warning above, append the relevant\n \t       attribute to the string.  */"}, {"sha": "2ead027161753ec32f20a50f5a2fb7c678e669f4", "filename": "gcc/pointer-query.cc", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea9e0d6c27405d256b4888e9e860e469037c911d/gcc%2Fpointer-query.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea9e0d6c27405d256b4888e9e860e469037c911d/gcc%2Fpointer-query.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpointer-query.cc?ref=ea9e0d6c27405d256b4888e9e860e469037c911d", "patch": "@@ -2358,3 +2358,33 @@ array_elt_at_offset (tree artype, HOST_WIDE_INT off,\n \n   return NULL_TREE;\n }\n+\n+/* Wrapper around build_array_type_nelts that makes sure the array\n+   can be created at all and handles zero sized arrays specially.  */\n+\n+tree\n+build_printable_array_type (tree eltype, unsigned HOST_WIDE_INT nelts)\n+{\n+  if (TYPE_SIZE_UNIT (eltype)\n+      && TREE_CODE (TYPE_SIZE_UNIT (eltype)) == INTEGER_CST\n+      && !integer_zerop (TYPE_SIZE_UNIT (eltype))\n+      && TYPE_ALIGN_UNIT (eltype) > 1\n+      && wi::zext (wi::to_wide (TYPE_SIZE_UNIT (eltype)),\n+\t\t   ffs_hwi (TYPE_ALIGN_UNIT (eltype)) - 1) != 0)\n+    eltype = TYPE_MAIN_VARIANT (eltype);\n+\n+  /* Consider excessive NELTS an array of unknown bound.  */\n+  tree idxtype = NULL_TREE;\n+  if (nelts < HOST_WIDE_INT_MAX)\n+    {\n+      if (nelts)\n+\treturn build_array_type_nelts (eltype, nelts);\n+      idxtype = build_range_type (sizetype, size_zero_node, NULL_TREE);\n+    }\n+\n+  tree arrtype = build_array_type (eltype, idxtype);\n+  arrtype = build_distinct_type_copy (TYPE_MAIN_VARIANT (arrtype));\n+  TYPE_SIZE (arrtype) = bitsize_zero_node;\n+  TYPE_SIZE_UNIT (arrtype) = size_zero_node;\n+  return arrtype;\n+}"}, {"sha": "fbea3316f14d3bd8ed28e2b8863832327dc89334", "filename": "gcc/pointer-query.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea9e0d6c27405d256b4888e9e860e469037c911d/gcc%2Fpointer-query.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea9e0d6c27405d256b4888e9e860e469037c911d/gcc%2Fpointer-query.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpointer-query.h?ref=ea9e0d6c27405d256b4888e9e860e469037c911d", "patch": "@@ -275,4 +275,7 @@ extern tree array_elt_at_offset (tree, HOST_WIDE_INT,\n \t\t\t\t HOST_WIDE_INT * = nullptr,\n \t\t\t\t HOST_WIDE_INT * = nullptr);\n \n+/* Helper to build an array type that can be printed.  */\n+extern tree build_printable_array_type (tree, unsigned HOST_WIDE_INT);\n+\n #endif   // GCC_POINTER_QUERY_H"}, {"sha": "378f8afbd34087c404c0006d7c9b26a5f3389aed", "filename": "gcc/testsuite/gcc.dg/Warray-parameter-10.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea9e0d6c27405d256b4888e9e860e469037c911d/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-parameter-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea9e0d6c27405d256b4888e9e860e469037c911d/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-parameter-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-parameter-10.c?ref=ea9e0d6c27405d256b4888e9e860e469037c911d", "patch": "@@ -0,0 +1,20 @@\n+/* PR c/102759 - ICE calling a function taking an argument redeclared\n+   without a prototype.\n+   { dg-do compile }\n+   { dg-options \"-Wall\" } */\n+\n+void f (void)\n+{\n+  void gia (int[2]);\n+  void g ();\n+}\n+\n+/* Redeclaring the g(int[]) above without a prototype loses it.  */\n+void gia ();\n+void g (int[2]);\n+\n+void h (void )\n+{\n+  gia (gia);\n+  gia (g);\n+}"}, {"sha": "ee2693dcea97a8faa4699c7c039357d46866777b", "filename": "gcc/testsuite/gcc.dg/Wstringop-overflow-82.c", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea9e0d6c27405d256b4888e9e860e469037c911d/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-82.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea9e0d6c27405d256b4888e9e860e469037c911d/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-82.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-82.c?ref=ea9e0d6c27405d256b4888e9e860e469037c911d", "patch": "@@ -0,0 +1,29 @@\n+/* Verify that notes after warnings for array and VLA parameters show\n+   the array form.\n+   { dg-do compile }\n+   { dg-options \"-Wall\" } */\n+\n+void fia5 (int[5]);\n+\n+void gia3_fia5 (void)\n+{\n+  int a[3];\n+  fia5 (a);             // { dg-warning \"-Wstringop-overflow\" }\n+                        // { dg-message \"argument 1 of type 'int\\\\\\[5]'\" \"note\" { target *-*-* } .-1 }\n+}\n+\n+\n+/* The type of the argument would ideall be 'int[n]' but the variable\n+   bound is lost/cleared by free-lang-data and never makes it into\n+   the middle end.  An (inferior) alternative would be 'int[*]' but\n+   the pretty printer doesn't know how to format the star.  A better\n+   solution might be to introduce a new notation, like 'int[$1]',\n+   where the $1 refers to the VLA argument bound.  */\n+void fvla (int n, int[n]);\n+\n+void gia3_fvla (void)\n+{\n+  int a[3];\n+  fvla (sizeof a, a);   // { dg-warning \"-Wstringop-overflow\" }\n+                        // { dg-message \"argument 2 of type 'int\\\\\\[]'\" \"note\" { target *-*-* } .-1 }\n+}"}]}