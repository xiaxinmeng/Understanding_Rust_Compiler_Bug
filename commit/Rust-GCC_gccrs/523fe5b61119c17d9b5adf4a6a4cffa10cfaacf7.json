{"sha": "523fe5b61119c17d9b5adf4a6a4cffa10cfaacf7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTIzZmU1YjYxMTE5YzE3ZDliNWFkZjRhNmE0Y2ZmYTEwY2ZhYWNmNw==", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2019-10-07T11:43:13Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@gcc.gnu.org", "date": "2019-10-07T11:43:13Z"}, "message": "Disentangle range_fold_*ary_expr() into various independent pieces.\n\nFrom-SVN: r276654", "tree": {"sha": "4617fdf345a30e048b11728ab4f252205401b94e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4617fdf345a30e048b11728ab4f252205401b94e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/523fe5b61119c17d9b5adf4a6a4cffa10cfaacf7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/523fe5b61119c17d9b5adf4a6a4cffa10cfaacf7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/523fe5b61119c17d9b5adf4a6a4cffa10cfaacf7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/523fe5b61119c17d9b5adf4a6a4cffa10cfaacf7/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "3faf75d458529592007436a0972f44e14ebf46f6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3faf75d458529592007436a0972f44e14ebf46f6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3faf75d458529592007436a0972f44e14ebf46f6"}], "stats": {"total": 302, "additions": 187, "deletions": 115}, "files": [{"sha": "83ad0017b5aefd3ea0e5f7792ebf2e9ce6d28c86", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/523fe5b61119c17d9b5adf4a6a4cffa10cfaacf7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/523fe5b61119c17d9b5adf4a6a4cffa10cfaacf7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=523fe5b61119c17d9b5adf4a6a4cffa10cfaacf7", "patch": "@@ -1,3 +1,23 @@\n+2019-10-07  Aldy Hernandez  <aldyh@redhat.com>\n+\n+\t* ipa-prop.c (ipa_vr::nonzero_p): New.\n+\t(ipcp_update_vr): Use nonzero_p instead of open-coding check for\n+\tnon-zero range.\n+\t* ipa-prop.h (class ipa_vr): Add nonzero_p.\n+\t* tree-vrp.c (range_has_numeric_bounds_p): New.\n+\t(range_int_cst_p): Use range_has_numeric_bounds_p.\n+\t(get_range_op_handler): New.\n+\t(supported_types_p): New.\n+\t(defined_ranges_p): New.\n+\t(drop_undefines_to_varying): New.\n+\t(range_fold_binary_symbolics_p): New.\n+\t(range_fold_unary_symbolics_p): New.\n+\t(range_fold_unary_expr): Extract out into above functions.\n+\t(range_fold_binary_expr): Same.\n+\t(value_range_base::normalize_addresses): New.\n+\t(value_range_base::normalize_symbolics): Normalize addresses.\n+\t* tree-vrp.h (class value_range_base): Add normalize_addresses.\n+\n 2019-10-07  Aldy Hernandez  <aldyh@redhat.com>\n \n \t* tree-vrp.c (value_range_base::singleton_p): Use"}, {"sha": "20a0bddcbab9c21d562cb51f2fb1f8afd99869e3", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/523fe5b61119c17d9b5adf4a6a4cffa10cfaacf7/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/523fe5b61119c17d9b5adf4a6a4cffa10cfaacf7/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=523fe5b61119c17d9b5adf4a6a4cffa10cfaacf7", "patch": "@@ -5109,6 +5109,18 @@ ipcp_update_bits (struct cgraph_node *node)\n     }\n }\n \n+bool\n+ipa_vr::nonzero_p (tree expr_type) const\n+{\n+  if (type == VR_ANTI_RANGE && wi::eq_p (min, 0) && wi::eq_p (max, 0))\n+    return true;\n+\n+  unsigned prec = TYPE_PRECISION (expr_type);\n+  return (type == VR_RANGE\n+\t  && wi::eq_p (min, wi::one (prec))\n+\t  && wi::eq_p (max, wi::max_value (prec, TYPE_SIGN (expr_type))));\n+}\n+\n /* Update value range of formal parameters as described in\n    ipcp_transformation.  */\n \n@@ -5181,9 +5193,7 @@ ipcp_update_vr (struct cgraph_node *node)\n \t\t\t\t\t\t      TYPE_SIGN (type)));\n \t    }\n \t  else if (POINTER_TYPE_P (TREE_TYPE (ddef))\n-\t\t   && vr[i].type == VR_ANTI_RANGE\n-\t\t   && wi::eq_p (vr[i].min, 0)\n-\t\t   && wi::eq_p (vr[i].max, 0))\n+\t\t   && vr[i].nonzero_p (TREE_TYPE (ddef)))\n \t    {\n \t      if (dump_file)\n \t\tfprintf (dump_file, \"Setting nonnull for %u\\n\", i);"}, {"sha": "eb3397a6d81a37c4ff51ca95e484f74562364414", "filename": "gcc/ipa-prop.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/523fe5b61119c17d9b5adf4a6a4cffa10cfaacf7/gcc%2Fipa-prop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/523fe5b61119c17d9b5adf4a6a4cffa10cfaacf7/gcc%2Fipa-prop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.h?ref=523fe5b61119c17d9b5adf4a6a4cffa10cfaacf7", "patch": "@@ -165,6 +165,7 @@ class GTY(()) ipa_vr\n   enum value_range_kind type;\n   wide_int min;\n   wide_int max;\n+  bool nonzero_p (tree) const;\n };\n \n /* A jump function for a callsite represents the values passed as actual"}, {"sha": "d69cfb107cbe79058a8f1d96385491a571053d11", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 152, "deletions": 112, "changes": 264, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/523fe5b61119c17d9b5adf4a6a4cffa10cfaacf7/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/523fe5b61119c17d9b5adf4a6a4cffa10cfaacf7/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=523fe5b61119c17d9b5adf4a6a4cffa10cfaacf7", "patch": "@@ -910,15 +910,21 @@ vrp_bitmap_equal_p (const_bitmap b1, const_bitmap b2)\n \t      && bitmap_equal_p (b1, b2)));\n }\n \n+static bool\n+range_has_numeric_bounds_p (const value_range_base *vr)\n+{\n+  return (vr->min ()\n+\t  && TREE_CODE (vr->min ()) == INTEGER_CST\n+\t  && TREE_CODE (vr->max ()) == INTEGER_CST);\n+}\n+\n /* Return true if max and min of VR are INTEGER_CST.  It's not necessary\n    a singleton.  */\n \n bool\n range_int_cst_p (const value_range_base *vr)\n {\n-  return (vr->kind () == VR_RANGE\n-\t  && TREE_CODE (vr->min ()) == INTEGER_CST\n-\t  && TREE_CODE (vr->max ()) == INTEGER_CST);\n+  return (vr->kind () == VR_RANGE && range_has_numeric_bounds_p (vr));\n }\n \n /* Return true if VR is a INTEGER_CST singleton.  */\n@@ -1760,119 +1766,102 @@ extract_range_from_plus_minus_expr (value_range_base *vr,\n     vr->set (kind, min, max);\n }\n \n-/* Normalize a value_range for use in range_ops and return it.  */\n+/* Return the range-ops handler for CODE and EXPR_TYPE.  If no\n+   suitable operator is found, return NULL and set VR to VARYING.  */\n \n-static value_range_base\n-normalize_for_range_ops (const value_range_base &vr)\n+static const range_operator *\n+get_range_op_handler (value_range_base *vr,\n+\t\t      enum tree_code code,\n+\t\t      tree expr_type)\n {\n-  tree type = vr.type ();\n+  const range_operator *op = range_op_handler (code, expr_type);\n+  if (!op)\n+    vr->set_varying (expr_type);\n+  return op;\n+}\n+\n+/* If the types passed are supported, return TRUE, otherwise set VR to\n+   VARYING and return FALSE.  */\n \n-  /* This will return ~[0,0] for [&var, &var].  */\n-  if (POINTER_TYPE_P (type) && !range_includes_zero_p (&vr))\n+static bool\n+supported_types_p (value_range_base *vr,\n+\t\t   tree type0,\n+\t\t   tree type1 = NULL)\n+{\n+  if (!value_range_base::supports_type_p (type0)\n+      || (type1 && !value_range_base::supports_type_p (type1)))\n     {\n-      value_range_base temp;\n-      temp.set_nonzero (type);\n-      return temp;\n+      vr->set_varying (type0);\n+      return false;\n     }\n-  if (vr.symbolic_p ())\n-    return normalize_for_range_ops (vr.normalize_symbolics ());\n-  if (TREE_CODE (vr.min ()) == INTEGER_CST\n-      && TREE_CODE (vr.max ()) == INTEGER_CST)\n-    return vr;\n-  /* Anything not strictly numeric at this point becomes varying.  */\n-  return value_range_base (vr.type ());\n+  return true;\n }\n \n-/* Fold a binary expression of two value_range's with range-ops.  */\n+/* If any of the ranges passed are defined, return TRUE, otherwise set\n+   VR to UNDEFINED and return FALSE.  */\n \n-void\n-range_fold_binary_expr (value_range_base *vr,\n-\t\t\tenum tree_code code,\n-\t\t\ttree expr_type,\n-\t\t\tconst value_range_base *vr0_,\n-\t\t\tconst value_range_base *vr1_)\n+static bool\n+defined_ranges_p (value_range_base *vr,\n+\t\t  const value_range_base *vr0,\n+\t\t  const value_range_base *vr1 = NULL)\n {\n-  if (!value_range_base::supports_type_p (expr_type)\n-      || (!vr0_->undefined_p ()\n-\t  && !value_range_base::supports_type_p (vr0_->type ()))\n-      || (!vr1_->undefined_p ()\n-\t  && !value_range_base::supports_type_p (vr1_->type ())))\n-    {\n-      vr->set_varying (expr_type);\n-      return;\n-    }\n-  if (vr0_->undefined_p () && vr1_->undefined_p ())\n+  if (vr0->undefined_p () && (!vr1 || vr1->undefined_p ()))\n     {\n       vr->set_undefined ();\n-      return;\n-    }\n-  range_operator *op = range_op_handler (code, expr_type);\n-  if (!op)\n-    {\n-      vr->set_varying (expr_type);\n-      return;\n+      return false;\n     }\n+  return true;\n+}\n \n-  /* Mimic any behavior users of extract_range_from_binary_expr may\n-     expect.  */\n-  value_range_base vr0 = *vr0_, vr1 = *vr1_;\n-  if (vr0.undefined_p ())\n-    vr0.set_varying (expr_type);\n-  else if (vr1.undefined_p ())\n-    vr1.set_varying (expr_type);\n+static value_range_base\n+drop_undefines_to_varying (const value_range_base *vr, tree expr_type)\n+{\n+  if (vr->undefined_p ())\n+    return value_range_base (expr_type);\n+  else\n+    return *vr;\n+}\n+\n+/* If any operand is symbolic, perform a binary operation on them and\n+   return TRUE, otherwise return FALSE.  */\n \n-  /* Handle symbolics.  */\n-  if (vr0.symbolic_p () || vr1.symbolic_p ())\n+static bool\n+range_fold_binary_symbolics_p (value_range_base *vr,\n+\t\t\t       tree_code code,\n+\t\t\t       tree expr_type,\n+\t\t\t       const value_range_base *vr0,\n+\t\t\t       const value_range_base *vr1)\n+{\n+  if (vr0->symbolic_p () || vr1->symbolic_p ())\n     {\n       if ((code == PLUS_EXPR || code == MINUS_EXPR))\n \t{\n-\t  extract_range_from_plus_minus_expr (vr, code, expr_type,\n-\t\t\t\t\t      &vr0, &vr1);\n-\t  return;\n+\t  extract_range_from_plus_minus_expr (vr, code, expr_type, vr0, vr1);\n+\t  return true;\n \t}\n       if (POINTER_TYPE_P (expr_type) && code == POINTER_PLUS_EXPR)\n \t{\n-\t  extract_range_from_pointer_plus_expr (vr, code, expr_type,\n-\t\t\t\t\t\t&vr0, &vr1);\n-\t  return;\n+\t  extract_range_from_pointer_plus_expr (vr, code, expr_type, vr0, vr1);\n+\t  return true;\n \t}\n+      const range_operator *op = get_range_op_handler (vr, code, expr_type);\n+      *vr = op->fold_range (expr_type,\n+\t\t\t    vr0->normalize_symbolics (),\n+\t\t\t    vr1->normalize_symbolics ());\n+      return true;\n     }\n-\n-  /* Do the range-ops dance.  */\n-  value_range_base n0 = normalize_for_range_ops (vr0);\n-  value_range_base n1 = normalize_for_range_ops (vr1);\n-  *vr = op->fold_range (expr_type, n0, n1);\n+  return false;\n }\n \n-/* Fold a unary expression of a value_range with range-ops.  */\n+/* If operand is symbolic, perform a unary operation on it and return\n+   TRUE, otherwise return FALSE.  */\n \n-void\n-range_fold_unary_expr (value_range_base *vr,\n-\t\t       enum tree_code code, tree expr_type,\n-\t\t       const value_range_base *vr0,\n-\t\t       tree vr0_type)\n+static bool\n+range_fold_unary_symbolics_p (value_range_base *vr,\n+\t\t\t      tree_code code,\n+\t\t\t      tree expr_type,\n+\t\t\t      const value_range_base *vr0)\n {\n-  /* Mimic any behavior users of extract_range_from_unary_expr may\n-     expect.  */\n-  if (!value_range_base::supports_type_p (expr_type)\n-      || !value_range_base::supports_type_p (vr0_type))\n-    {\n-      vr->set_varying (expr_type);\n-      return;\n-    }\n-  if (vr0->undefined_p ())\n-    {\n-      vr->set_undefined ();\n-      return;\n-    }\n-  range_operator *op = range_op_handler (code, expr_type);\n-  if (!op)\n-    {\n-      vr->set_varying (expr_type);\n-      return;\n-    }\n-\n-  /* Handle symbolics.  */\n   if (vr0->symbolic_p ())\n     {\n       if (code == NEGATE_EXPR)\n@@ -1881,38 +1870,72 @@ range_fold_unary_expr (value_range_base *vr,\n \t  value_range_base zero;\n \t  zero.set_zero (vr0->type ());\n \t  range_fold_binary_expr (vr, MINUS_EXPR, expr_type, &zero, vr0);\n-\t  return;\n+\t  return true;\n \t}\n       if (code == BIT_NOT_EXPR)\n \t{\n \t  /* ~X is simply -1 - X.  */\n \t  value_range_base minusone;\n \t  minusone.set (build_int_cst (vr0->type (), -1));\n \t  range_fold_binary_expr (vr, MINUS_EXPR, expr_type, &minusone, vr0);\n-\t  return;\n+\t  return true;\n \t}\n+      const range_operator *op = get_range_op_handler (vr, code, expr_type);\n       *vr = op->fold_range (expr_type,\n-\t\t\t    normalize_for_range_ops (*vr0),\n+\t\t\t    vr0->normalize_symbolics (),\n \t\t\t    value_range_base (expr_type));\n-      return;\n-    }\n-  if (CONVERT_EXPR_CODE_P (code) && (POINTER_TYPE_P (expr_type)\n-\t\t\t\t     || POINTER_TYPE_P (vr0->type ())))\n-    {\n-      /* This handles symbolic conversions such such as [25, x_4].  */\n-      if (!range_includes_zero_p (vr0))\n-\tvr->set_nonzero (expr_type);\n-      else if (vr0->zero_p ())\n-\tvr->set_zero (expr_type);\n-      else\n-\tvr->set_varying (expr_type);\n-      return;\n+      return true;\n     }\n+  return false;\n+}\n \n-  /* Do the range-ops dance.  */\n-  value_range_base n0 = normalize_for_range_ops (*vr0);\n-  value_range_base n1 (expr_type);\n-  *vr = op->fold_range (expr_type, n0, n1);\n+/* Perform a binary operation on a pair of ranges.  */\n+\n+void\n+range_fold_binary_expr (value_range_base *vr,\n+\t\t\tenum tree_code code,\n+\t\t\ttree expr_type,\n+\t\t\tconst value_range_base *vr0_,\n+\t\t\tconst value_range_base *vr1_)\n+{\n+  if (!supported_types_p (vr, expr_type)\n+      || !defined_ranges_p (vr, vr0_, vr1_))\n+    return;\n+  const range_operator *op = get_range_op_handler (vr, code, expr_type);\n+  if (!op)\n+    return;\n+\n+  value_range_base vr0 = drop_undefines_to_varying (vr0_, expr_type);\n+  value_range_base vr1 = drop_undefines_to_varying (vr1_, expr_type);\n+  if (range_fold_binary_symbolics_p (vr, code, expr_type, &vr0, &vr1))\n+    return;\n+\n+  *vr = op->fold_range (expr_type,\n+\t\t\tvr0.normalize_addresses (),\n+\t\t\tvr1.normalize_addresses ());\n+}\n+\n+/* Perform a unary operation on a range.  */\n+\n+void\n+range_fold_unary_expr (value_range_base *vr,\n+\t\t       enum tree_code code, tree expr_type,\n+\t\t       const value_range_base *vr0,\n+\t\t       tree vr0_type)\n+{\n+  if (!supported_types_p (vr, expr_type, vr0_type)\n+      || !defined_ranges_p (vr, vr0))\n+    return;\n+  const range_operator *op = get_range_op_handler (vr, code, expr_type);\n+  if (!op)\n+    return;\n+\n+  if (range_fold_unary_symbolics_p (vr, code, expr_type, vr0))\n+    return;\n+\n+  *vr = op->fold_range (expr_type,\n+\t\t\tvr0->normalize_addresses (),\n+\t\t\tvalue_range_base (expr_type));\n }\n \n /* Given a COND_EXPR COND of the form 'V OP W', and an SSA name V,\n@@ -5997,7 +6020,24 @@ value_range::union_ (const value_range *other)\n     }\n }\n \n-/* Normalize symbolics into constants.  */\n+/* Normalize addresses into constants.  */\n+\n+value_range_base\n+value_range_base::normalize_addresses () const\n+{\n+  if (!POINTER_TYPE_P (type ()) || range_has_numeric_bounds_p (this))\n+    return *this;\n+\n+  if (!range_includes_zero_p (this))\n+    {\n+      gcc_checking_assert (TREE_CODE (m_min) == ADDR_EXPR\n+\t\t\t   || TREE_CODE (m_max) == ADDR_EXPR);\n+      return range_nonzero (type ());\n+    }\n+  return value_range_base (type ());\n+}\n+\n+/* Normalize symbolics and addresses into constants.  */\n \n value_range_base\n value_range_base::normalize_symbolics () const\n@@ -6008,7 +6048,7 @@ value_range_base::normalize_symbolics () const\n   bool min_symbolic = !is_gimple_min_invariant (min ());\n   bool max_symbolic = !is_gimple_min_invariant (max ());\n   if (!min_symbolic && !max_symbolic)\n-    return *this;\n+    return normalize_addresses ();\n \n   // [SYM, SYM] -> VARYING\n   if (min_symbolic && max_symbolic)"}, {"sha": "a3f9e90699d3d49fe080be1713c5b52fdf71904b", "filename": "gcc/tree-vrp.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/523fe5b61119c17d9b5adf4a6a4cffa10cfaacf7/gcc%2Ftree-vrp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/523fe5b61119c17d9b5adf4a6a4cffa10cfaacf7/gcc%2Ftree-vrp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.h?ref=523fe5b61119c17d9b5adf4a6a4cffa10cfaacf7", "patch": "@@ -86,6 +86,7 @@ class GTY((for_user)) value_range_base\n \n   static bool supports_type_p (tree);\n   value_range_base normalize_symbolics () const;\n+  value_range_base normalize_addresses () const;\n \n   static const unsigned int m_max_pairs = 2;\n   bool contains_p (tree) const;"}]}