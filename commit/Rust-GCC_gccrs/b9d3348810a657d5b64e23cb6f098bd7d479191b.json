{"sha": "b9d3348810a657d5b64e23cb6f098bd7d479191b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjlkMzM0ODgxMGE2NTdkNWI2NGUyM2NiNmYwOThiZDdkNDc5MTkxYg==", "commit": {"author": {"name": "Daniel Berlin", "email": "dberlin@dberlin.org", "date": "2005-07-19T03:36:15Z"}, "committer": {"name": "Daniel Berlin", "email": "dberlin@gcc.gnu.org", "date": "2005-07-19T03:36:15Z"}, "message": "re PR tree-optimization/22483 (ICE : tree check: expected ssa_name, have var_decl in is_old_name, at tree-into-ssa.c:466)\n\n2005-07-18  Daniel Berlin  <dberlin@dberlin.org>\n\n\tFix PR tree-optimization/22483\n\n\t* tree-complex.c (create_components): Use\n\tsafe_referenced_var_iterator and FOR_EACH_REFERENCED_VAR_SAFE.\n\t* tree-flow-inline.h (fill_referenced_var_vec): New function.\n\t* tree-flow.h (safe_referenced_var_iterator): New structure.\n\t(FOR_EACH_REFERENCED_VAR_SAFE): New macro.\n\t* tree-ssa-alias.c (setup_pointers_and_addressables): Use\n\tsafe_referenced_var iterator.\n\t(add_type_alias): Ditto.\n\nFrom-SVN: r102150", "tree": {"sha": "880e6bcccb700c5d4ffc320ff94104a03e895fc9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/880e6bcccb700c5d4ffc320ff94104a03e895fc9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b9d3348810a657d5b64e23cb6f098bd7d479191b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b9d3348810a657d5b64e23cb6f098bd7d479191b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b9d3348810a657d5b64e23cb6f098bd7d479191b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b9d3348810a657d5b64e23cb6f098bd7d479191b/comments", "author": {"login": "dberlin", "id": 324715, "node_id": "MDQ6VXNlcjMyNDcxNQ==", "avatar_url": "https://avatars.githubusercontent.com/u/324715?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dberlin", "html_url": "https://github.com/dberlin", "followers_url": "https://api.github.com/users/dberlin/followers", "following_url": "https://api.github.com/users/dberlin/following{/other_user}", "gists_url": "https://api.github.com/users/dberlin/gists{/gist_id}", "starred_url": "https://api.github.com/users/dberlin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dberlin/subscriptions", "organizations_url": "https://api.github.com/users/dberlin/orgs", "repos_url": "https://api.github.com/users/dberlin/repos", "events_url": "https://api.github.com/users/dberlin/events{/privacy}", "received_events_url": "https://api.github.com/users/dberlin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "9fa264571da0247ed1b0d0d0e64897f7b3731c50", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9fa264571da0247ed1b0d0d0e64897f7b3731c50", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9fa264571da0247ed1b0d0d0e64897f7b3731c50"}], "stats": {"total": 75, "additions": 66, "deletions": 9}, "files": [{"sha": "7828291c81c0fc66fbdce50dc417fad049f3e2ff", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9d3348810a657d5b64e23cb6f098bd7d479191b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9d3348810a657d5b64e23cb6f098bd7d479191b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b9d3348810a657d5b64e23cb6f098bd7d479191b", "patch": "@@ -1,3 +1,16 @@\n+2005-07-18  Daniel Berlin  <dberlin@dberlin.org>\n+\n+\tFix PR tree-optimization/22483\n+\t\n+\t* tree-complex.c (create_components): Use\n+\tsafe_referenced_var_iterator and FOR_EACH_REFERENCED_VAR_SAFE.\n+\t* tree-flow-inline.h (fill_referenced_var_vec): New function.\n+\t* tree-flow.h (safe_referenced_var_iterator): New structure.\n+\t(FOR_EACH_REFERENCED_VAR_SAFE): New macro.\n+\t* tree-ssa-alias.c (setup_pointers_and_addressables): Use\n+\tsafe_referenced_var iterator.\n+\t(add_type_alias): Ditto.\n+\n 2005-07-19  Steven Bosscher  <stevenb@suse.de>\n \n \t* loop-init.c (rest_of_handle_loop2): Remove."}, {"sha": "54f3ace791ddf7ef19c2d8de278589b00147cf40", "filename": "gcc/tree-complex.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9d3348810a657d5b64e23cb6f098bd7d479191b/gcc%2Ftree-complex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9d3348810a657d5b64e23cb6f098bd7d479191b/gcc%2Ftree-complex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-complex.c?ref=b9d3348810a657d5b64e23cb6f098bd7d479191b", "patch": "@@ -386,7 +386,8 @@ create_components (void)\n {\n   size_t n;\n   tree var;\n-  referenced_var_iterator rvi;\n+  safe_referenced_var_iterator rvi;\n+  VEC (tree, heap) *refvars;\n \n   n = num_referenced_vars;\n   if (n == 0)\n@@ -395,7 +396,7 @@ create_components (void)\n   complex_variable_components = htab_create (10,  int_tree_map_hash,\n \t\t\t\t\t     int_tree_map_eq, free);\n \n-  FOR_EACH_REFERENCED_VAR (var, rvi)\n+  FOR_EACH_REFERENCED_VAR_SAFE (var, refvars, rvi)\n     {\n       tree r = NULL, i = NULL;\n \n@@ -442,6 +443,7 @@ create_components (void)\n       cvc_insert (2 * DECL_UID (var), r);\n       cvc_insert (2 * DECL_UID (var) + 1, i);\n     }\n+  VEC_free (tree, heap, refvars);\n }\n \n /* Extract the real or imaginary part of a complex variable or constant."}, {"sha": "30d13ab4ae40c1b0ab4e9375f050df873fd346b2", "filename": "gcc/tree-flow-inline.h", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9d3348810a657d5b64e23cb6f098bd7d479191b/gcc%2Ftree-flow-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9d3348810a657d5b64e23cb6f098bd7d479191b/gcc%2Ftree-flow-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow-inline.h?ref=b9d3348810a657d5b64e23cb6f098bd7d479191b", "patch": "@@ -105,7 +105,19 @@ next_referenced_var (referenced_var_iterator *iter)\n     return NULL;\n   return itm->to;\n } \n- \n+\n+/* Fill up VEC with the variables in the referenced vars hashtable.  */\n+\n+static inline void\n+fill_referenced_var_vec (VEC (tree, heap) **vec)\n+{\n+  referenced_var_iterator rvi;\n+  tree var;\n+  *vec = NULL;\n+  FOR_EACH_REFERENCED_VAR (var, rvi)\n+    VEC_safe_push (tree, heap, *vec, var);\n+}\n+\n /* Return the variable annotation for T, which must be a _DECL node.\n    Return NULL if the variable annotation doesn't already exist.  */\n static inline var_ann_t"}, {"sha": "da49ed199e9d77dd2715ee50c055b37f5da7a4f4", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9d3348810a657d5b64e23cb6f098bd7d479191b/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9d3348810a657d5b64e23cb6f098bd7d479191b/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=b9d3348810a657d5b64e23cb6f098bd7d479191b", "patch": "@@ -389,11 +389,35 @@ typedef struct\n } referenced_var_iterator;\n \n \n+/* This macro loops over all the referenced vars, one at a time, putting the\n+   current var in VAR.  Note:  You are not allowed to add referenced variables\n+   to the hashtable while using this macro.  Doing so may cause it to behave\n+   erratically.  */\n+\n #define FOR_EACH_REFERENCED_VAR(VAR, ITER) \\\n   for ((VAR) = first_referenced_var (&(ITER)); \\\n        !end_referenced_vars_p (&(ITER)); \\\n        (VAR) = next_referenced_var (&(ITER))) \n \n+\n+typedef struct\n+{\n+  int i;\n+} safe_referenced_var_iterator;\n+\n+/* This macro loops over all the referenced vars, one at a time, putting the\n+   current var in VAR.  You are allowed to add referenced variables during the\n+   execution of this macro, however, the macro will not iterate over them.  It\n+   requires a temporary vector of trees, VEC, whose lifetime is controlled by\n+   the caller.  The purpose of the vector is to temporarily store the\n+   referenced_variables hashtable so that adding referenced variables does not\n+   affect the hashtable.  */\n+\n+#define FOR_EACH_REFERENCED_VAR_SAFE(VAR, VEC, ITER) \\\n+  for ((ITER).i = 0, fill_referenced_var_vec (&(VEC)); \\\n+       VEC_iterate (tree, (VEC), (ITER).i, (VAR)); \\\n+       (ITER).i++)\n+\n /* Array of all variables referenced in the function.  */\n extern GTY((param_is (struct int_tree_map))) htab_t referenced_vars;\n "}, {"sha": "c65fe8d043ffdc9875000c92ac580726fa11424f", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9d3348810a657d5b64e23cb6f098bd7d479191b/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9d3348810a657d5b64e23cb6f098bd7d479191b/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=b9d3348810a657d5b64e23cb6f098bd7d479191b", "patch": "@@ -1168,6 +1168,8 @@ setup_pointers_and_addressables (struct alias_info *ai)\n   size_t n_vars, num_addressable_vars, num_pointers;\n   referenced_var_iterator rvi;\n   tree var;\n+  VEC (tree, heap) *varvec = NULL;\n+  safe_referenced_var_iterator srvi;\n \n   /* Size up the arrays ADDRESSABLE_VARS and POINTERS.  */\n   num_addressable_vars = num_pointers = 0;\n@@ -1204,7 +1206,7 @@ setup_pointers_and_addressables (struct alias_info *ai)\n      unnecessarily.  */\n   n_vars = num_referenced_vars;\n \n-  FOR_EACH_REFERENCED_VAR (var, rvi)\n+  FOR_EACH_REFERENCED_VAR_SAFE (var, varvec, srvi)\n     {\n       var_ann_t v_ann = var_ann (var);\n       subvar_t svars;\n@@ -1336,6 +1338,7 @@ setup_pointers_and_addressables (struct alias_info *ai)\n \t    }\n \t}\n     }\n+  VEC_free (tree, heap, varvec);\n }\n \n \n@@ -2218,14 +2221,14 @@ add_type_alias (tree ptr, tree var)\n   tree tag;\n   var_ann_t ann = var_ann (ptr);\n   subvar_t svars;\n-  \n+  VEC (tree, heap) *varvec = NULL;  \n \n   if (ann->type_mem_tag == NULL_TREE)\n     {\n       tree q = NULL_TREE;\n       tree tag_type = TREE_TYPE (TREE_TYPE (ptr));\n       HOST_WIDE_INT tag_set = get_alias_set (tag_type);\n-      referenced_var_iterator rvi;\n+      safe_referenced_var_iterator rvi;\n \n       /* PTR doesn't have a type tag, create a new one and add VAR to\n \t the new tag's alias set.\n@@ -2234,7 +2237,7 @@ add_type_alias (tree ptr, tree var)\n \t whether there is another pointer Q with the same alias set as\n \t PTR.  This could be sped up by having type tags associated\n \t with types.  */\n-      FOR_EACH_REFERENCED_VAR (q, rvi)\n+      FOR_EACH_REFERENCED_VAR_SAFE (q, varvec, rvi)\n \t{\n \t  if (POINTER_TYPE_P (TREE_TYPE (q))\n \t      && tag_set == get_alias_set (TREE_TYPE (TREE_TYPE (q))))\n@@ -2292,6 +2295,7 @@ add_type_alias (tree ptr, tree var)\n       for (i = 0; i < VARRAY_ACTIVE_SIZE (aliases); i++)\n \tmark_sym_for_renaming (VARRAY_TREE (aliases, i));\n     }\n+  VEC_free (tree, heap, varvec);\n }\n \n \n@@ -2766,7 +2770,8 @@ static void\n create_structure_vars (void)\n {\n   basic_block bb;\n-  referenced_var_iterator rvi;\n+  safe_referenced_var_iterator rvi;\n+  VEC (tree, heap) *varvec = NULL;\n   tree var;\n \n   used_portions = htab_create (10, used_part_map_hash, used_part_map_eq, \n@@ -2782,7 +2787,7 @@ create_structure_vars (void)\n \t\t\t\t\tNULL);\n \t}\n     }\n-  FOR_EACH_REFERENCED_VAR (var, rvi)\n+  FOR_EACH_REFERENCED_VAR_SAFE (var, varvec, rvi)\n     {\n       /* The C++ FE creates vars without DECL_SIZE set, for some reason.  */\n       if (var \t  \n@@ -2793,6 +2798,7 @@ create_structure_vars (void)\n \tcreate_overlap_variables_for (var);\n     }\n   htab_delete (used_portions);\n+  VEC_free (tree, heap, varvec);\n \n }\n "}]}