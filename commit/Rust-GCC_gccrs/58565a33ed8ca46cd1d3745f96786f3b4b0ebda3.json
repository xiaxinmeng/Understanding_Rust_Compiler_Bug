{"sha": "58565a33ed8ca46cd1d3745f96786f3b4b0ebda3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTg1NjVhMzNlZDhjYTQ2Y2QxZDM3NDVmOTY3ODZmM2I0YjBlYmRhMw==", "commit": {"author": {"name": "Sanjiv Kumar Gupta", "email": "sanjivg@noida.hcltech.com", "date": "2004-02-24T17:28:33Z"}, "committer": {"name": "Vladimir Makarov", "email": "vmakarov@gcc.gnu.org", "date": "2004-02-24T17:28:33Z"}, "message": "target-def.h (TARGET_SCHED_INIT_GLOBAL, [...]): New macros.\n\n2003-02-24  Sanjiv Kumar Gupta  <sanjivg@noida.hcltech.com>\n\n\t* target-def.h (TARGET_SCHED_INIT_GLOBAL,\n\tTARGET_SCHED_FINISH_GLOBAL): New macros.\n\n\t* target.h (md_init_global, md_finish_global): Function\n\tdeclarations corresponding to new target macros.\n\n\t* haifa-sched.c (sched_init, sched_finish): Allow target to\n\tcall the new schedular hooks.\n\n\t* flow.c (recompute_reg_usage): Add PROP_DEATH_NOTES flag in\n\tcall to update_life_info.\n\n\t* config/sh/sh.h (OVERRIDE_OPTIONS): Re-enable\n\tflag_schedule_insns for SH4.\n\n\t* config/sh/sh.c (sh_md_init_global, sh_md_finish_global,\n\tfind_set_regmode_weight, find_insn_regmode_weight,\n\tfind_regmode_weight), sh_md_init, sh_dfa_new_cycle,\n\tsh_variable_issue, high_pressure, ready_reorder,\n\trank_for_reorder, swap_reorder, sh_reorder, sh_reorder2): New\n\tfunctions used to throttle the insn movement in first\n\tscheduling pass for SH.\n\n\t* gcc/doc/tm.texi: Document TARGET_SCHED_INIT_GLOBAL and\n\tTARGET_SCHED_FINISH_GLOBAL.\n\nFrom-SVN: r78374", "tree": {"sha": "3aa01967e3cab5b61a2460c360bbe2508accd84f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3aa01967e3cab5b61a2460c360bbe2508accd84f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/58565a33ed8ca46cd1d3745f96786f3b4b0ebda3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/58565a33ed8ca46cd1d3745f96786f3b4b0ebda3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/58565a33ed8ca46cd1d3745f96786f3b4b0ebda3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/58565a33ed8ca46cd1d3745f96786f3b4b0ebda3/comments", "author": null, "committer": null, "parents": [{"sha": "34208acf14fa026ae391a819525d20b48af5c2bf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/34208acf14fa026ae391a819525d20b48af5c2bf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/34208acf14fa026ae391a819525d20b48af5c2bf"}], "stats": {"total": 478, "additions": 476, "deletions": 2}, "files": [{"sha": "99cbcb3f71c7c16c8aa5219a042ddd0712a6d5c3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58565a33ed8ca46cd1d3745f96786f3b4b0ebda3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58565a33ed8ca46cd1d3745f96786f3b4b0ebda3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=58565a33ed8ca46cd1d3745f96786f3b4b0ebda3", "patch": "@@ -1,3 +1,31 @@\n+2003-02-24  Sanjiv Kumar Gupta  <sanjivg@noida.hcltech.com>\n+\n+\t* target-def.h (TARGET_SCHED_INIT_GLOBAL,\n+\tTARGET_SCHED_FINISH_GLOBAL): New macros.\n+\n+\t* target.h (md_init_global, md_finish_global): Function\n+\tdeclarations corresponding to new target macros.\n+\n+\t* haifa-sched.c (sched_init, sched_finish): Allow target to\n+\tcall the new schedular hooks.\n+\n+\t* flow.c (recompute_reg_usage): Add PROP_DEATH_NOTES flag in\n+\tcall to update_life_info.\n+\n+\t* config/sh/sh.h (OVERRIDE_OPTIONS): Re-enable\n+\tflag_schedule_insns for SH4.\n+\n+\t* config/sh/sh.c (sh_md_init_global, sh_md_finish_global,\n+\tfind_set_regmode_weight, find_insn_regmode_weight,\n+\tfind_regmode_weight), sh_md_init, sh_dfa_new_cycle,\n+\tsh_variable_issue, high_pressure, ready_reorder,\n+\trank_for_reorder, swap_reorder, sh_reorder, sh_reorder2): New\n+\tfunctions used to throttle the insn movement in first\n+\tscheduling pass for SH.\n+\n+\t* gcc/doc/tm.texi: Document TARGET_SCHED_INIT_GLOBAL and\n+\tTARGET_SCHED_FINISH_GLOBAL.\n+\n 2004-02-24  Alexandre Oliva  <aoliva@redhat.com>\n \n \tImplement FR-V FDPIC ABI support for frv-uclinux and frv-linux."}, {"sha": "dbb463d9915a5eea8d1d3d8162fb6acb6b15ae91", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 410, "deletions": 0, "changes": 410, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58565a33ed8ca46cd1d3745f96786f3b4b0ebda3/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58565a33ed8ca46cd1d3745f96786f3b4b0ebda3/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=58565a33ed8ca46cd1d3745f96786f3b4b0ebda3", "patch": "@@ -49,6 +49,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"ra.h\"\n #include \"cfglayout.h\"\n #include \"intl.h\"\n+#include \"sched-int.h\"\n #include \"ggc.h\"\n \n int code_for_indirect_jump_scratch = CODE_FOR_indirect_jump_scratch;\n@@ -101,6 +102,21 @@ int current_function_anonymous_args;\n /* Which cpu are we scheduling for.  */\n enum processor_type sh_cpu;\n \n+/* Definitions used in ready queue reordering for first scheduling pass.  */\n+\n+/* Reg weights arrays for modes SFmode and SImode, indexed by insn LUID.  */\n+static short *regmode_weight[2];\n+\n+/* Total SFmode and SImode weights of scheduled insns.  */\n+static int curr_regmode_pressure[2];\n+\n+/* If true, skip cycles for Q -> R movement.  */\n+static int skip_cycles = 0;\n+\n+/* Cached value of can_issue_more. This is cached in sh_variable_issue hook\n+   and returned from sh_reorder2.  */\n+static short cached_can_issue_more;\n+\n /* Saved operands from the last compare to use when we generate an scc\n    or bcc insn.  */\n \n@@ -211,6 +227,21 @@ static void sh_insert_attributes (tree, tree *);\n static int sh_adjust_cost (rtx, rtx, rtx, int);\n static int sh_use_dfa_interface (void);\n static int sh_issue_rate (void);\n+static int sh_dfa_new_cycle (FILE *, int, rtx, int, int, int *sort_p);\n+static short find_set_regmode_weight (rtx, enum machine_mode);\n+static short find_insn_regmode_weight (rtx, enum machine_mode);\n+static void find_regmode_weight (int, enum machine_mode);\n+static void  sh_md_init_global (FILE *, int, int);\n+static void  sh_md_finish_global (FILE *, int);\n+static int rank_for_reorder (const void *, const void *);\n+static void swap_reorder (rtx *, int);\n+static void ready_reorder (rtx *, int);\n+static short high_pressure (enum machine_mode);\n+static int sh_reorder (FILE *, int, rtx *, int *, int);\n+static int sh_reorder2 (FILE *, int, rtx *, int *, int);\n+static void sh_md_init (FILE *, int, int);\n+static int sh_variable_issue (FILE *, int, rtx, int);\n+  \n static bool sh_function_ok_for_sibcall (tree, tree);\n \n static bool sh_cannot_modify_jumps_p (void);\n@@ -293,6 +324,62 @@ static tree sh_build_builtin_va_list (void);\n #undef TARGET_SCHED_ISSUE_RATE\n #define TARGET_SCHED_ISSUE_RATE sh_issue_rate\n \n+/* The next 5 hooks have been implemented for reenabling sched1.  With the\n+   help of these macros we are limiting the movement of insns in sched1 to\n+   reduce the register pressure.  The overall idea is to keep count of SImode \n+   and SFmode regs required by already scheduled insns. When these counts\n+   cross some threshold values; give priority to insns that free registers.\n+   The insn that frees registers is most likely to be the insn with lowest\n+   LUID (original insn order); but such an insn might be there in the stalled \n+   queue (Q) instead of the ready queue (R).  To solve this, we skip cycles\n+   upto a max of 8 cycles so that such insns may move from Q -> R.\n+\n+   The description of the hooks are as below:\n+\n+   TARGET_SCHED_INIT_GLOBAL: Added a new target hook in the generic\n+   scheduler; it is called inside the sched_init function just after\n+   find_insn_reg_weights function call. It is used to calculate the SImode\n+   and SFmode weights of insns of basic blocks; much similiar to what\n+   find_insn_reg_weights does. \n+   TARGET_SCHED_FINISH_GLOBAL: Corresponding cleanup hook.\n+\n+   TARGET_SCHED_DFA_NEW_CYCLE: Skip cycles if high register pressure is\n+   indicated by TARGET_SCHED_REORDER2; doing this may move insns from\n+   (Q)->(R).\n+\n+   TARGET_SCHED_REORDER: If the register pressure for SImode or SFmode is\n+   high; reorder the ready queue so that the insn with lowest LUID will be\n+   issued next.\n+\n+   TARGET_SCHED_REORDER2: If the register pressure is high, indicate to\n+   TARGET_SCHED_DFA_NEW_CYCLE to skip cycles.\n+\n+   TARGET_SCHED_VARIABLE_ISSUE: Cache the value of can_issue_more so that it\n+   can be returned from TARGET_SCHED_REORDER2.\n+\n+   TARGET_SCHED_INIT: Reset the register pressure counting variables.  */\n+\n+#undef TARGET_SCHED_DFA_NEW_CYCLE\n+#define TARGET_SCHED_DFA_NEW_CYCLE sh_dfa_new_cycle\n+\n+#undef TARGET_SCHED_INIT_GLOBAL\n+#define TARGET_SCHED_INIT_GLOBAL sh_md_init_global\n+\n+#undef TARGET_SCHED_FINISH_GLOBAL\n+#define TARGET_SCHED_FINISH_GLOBAL sh_md_finish_global\n+\n+#undef TARGET_SCHED_VARIABLE_ISSUE\n+#define TARGET_SCHED_VARIABLE_ISSUE sh_variable_issue\n+\n+#undef TARGET_SCHED_REORDER\n+#define TARGET_SCHED_REORDER sh_reorder\n+\n+#undef TARGET_SCHED_REORDER2\n+#define TARGET_SCHED_REORDER2 sh_reorder2\n+\n+#undef TARGET_SCHED_INIT\n+#define TARGET_SCHED_INIT sh_md_init\n+\n #undef TARGET_CANNOT_MODIFY_JUMPS_P\n #define TARGET_CANNOT_MODIFY_JUMPS_P sh_cannot_modify_jumps_p\n #undef TARGET_BRANCH_TARGET_REGISTER_CLASS\n@@ -354,6 +441,12 @@ static tree sh_build_builtin_va_list (void);\n #undef TARGET_PCH_VALID_P\n #define TARGET_PCH_VALID_P sh_pch_valid_p\n \n+/* Return regmode weight for insn.  */\n+#define INSN_REGMODE_WEIGHT(INSN, MODE)  regmode_weight[((MODE) == SImode) ? 0 : 1][INSN_UID (INSN)]\n+\n+/* Return current register pressure for regmode.  */\n+#define CURR_REGMODE_PRESSURE(MODE) \tcurr_regmode_pressure[((MODE) == SImode) ? 0 : 1]\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n /* Print the operand address in x to the stream.  */\n@@ -8264,6 +8357,323 @@ sh_issue_rate(void)\n     return 1;\n }\n \n+/* Functions for ready queue reordering for sched1.  */\n+\n+/* Get weight for mode for a set x.  */\n+static short\n+find_set_regmode_weight (x, mode)\n+     rtx x;\n+     enum machine_mode mode;\n+{\n+  if (GET_CODE (x) == CLOBBER && register_operand (SET_DEST (x), mode))\n+    return 1;\n+  if (GET_CODE (x) == SET && register_operand (SET_DEST (x), mode))\n+    {\n+      if (GET_CODE (SET_DEST (x)) == REG)\n+\t{\n+\t  if (!reg_mentioned_p (SET_DEST (x), SET_SRC (x)))\n+\t    return 1;\n+\t  else\n+\t    return 0;\n+\t}\n+      return 1;\n+    }\n+  return 0;\n+}\n+\n+/* Get regmode weight for insn.  */\n+static short\n+find_insn_regmode_weight (insn, mode)\n+     rtx insn;\n+     enum machine_mode mode;\n+{\n+  short reg_weight = 0;\n+  rtx x;\n+\n+  /* Increment weight for each register born here.  */\n+  x = PATTERN (insn);\n+  reg_weight += find_set_regmode_weight (x, mode);\n+  if (GET_CODE (x) == PARALLEL)\n+    {\n+      int j;\n+      for (j = XVECLEN (x, 0) - 1; j >= 0; j--)\n+\t{\n+\t  x = XVECEXP (PATTERN (insn), 0, j);\n+\t  reg_weight += find_set_regmode_weight (x, mode);\n+\t}\n+    }\n+  /* Decrement weight for each register that dies here.  */\n+  for (x = REG_NOTES (insn); x; x = XEXP (x, 1))\n+    {\n+      if (REG_NOTE_KIND (x) == REG_DEAD || REG_NOTE_KIND (x) == REG_UNUSED)\n+\t{\n+\t  rtx note = XEXP (x, 0);\n+\t  if (GET_CODE (note) == REG && GET_MODE (note) == mode)\n+\t    reg_weight--;\n+\t}\n+    }\n+  return reg_weight;\n+}\n+\n+/* Calculate regmode weights for all insns of a basic block.  */\n+static void\n+find_regmode_weight (b, mode)\n+     int b;\n+     enum machine_mode mode;\n+{\n+  rtx insn, next_tail, head, tail;\n+\n+  get_block_head_tail (b, &head, &tail);\n+  next_tail = NEXT_INSN (tail);\n+\n+  for (insn = head; insn != next_tail; insn = NEXT_INSN (insn))\n+    {\n+      /* Handle register life information.  */\n+      if (!INSN_P (insn))\n+\tcontinue;\n+\n+      if (mode == SFmode)\n+\tINSN_REGMODE_WEIGHT (insn, mode) =\n+\t  find_insn_regmode_weight (insn, mode) + 2 * find_insn_regmode_weight (insn, DFmode);\n+      else if (mode == SImode)\n+\tINSN_REGMODE_WEIGHT (insn, mode) =\n+\t  find_insn_regmode_weight (insn, mode) + 2 * find_insn_regmode_weight (insn, DImode);\n+    }\n+}\n+\n+/* Comparison function for ready queue sorting.  */\n+static int\n+rank_for_reorder (x, y)\n+     const void *x;\n+     const void *y;\n+{\n+  rtx tmp = *(const rtx *) y;\n+  rtx tmp2 = *(const rtx *) x;\n+\n+  /* The insn in a schedule group should be issued the first.  */\n+  if (SCHED_GROUP_P (tmp) != SCHED_GROUP_P (tmp2))\n+    return SCHED_GROUP_P (tmp2) ? 1 : -1;\n+\n+  /* If insns are equally good, sort by INSN_LUID (original insn order), This \n+     minimizes instruction movement, thus minimizing sched's effect on\n+     register pressure.  */\n+  return INSN_LUID (tmp) - INSN_LUID (tmp2);\n+}\n+\n+/* Resort the array A in which only element at index N may be out of order.  */\n+static void\n+swap_reorder (a, n)\n+     rtx *a;\n+     int n;\n+{\n+  rtx insn = a[n - 1];\n+  int i = n - 2;\n+\n+  while (i >= 0 && rank_for_reorder (a + i, &insn) >= 0)\n+    {\n+      a[i + 1] = a[i];\n+      i -= 1;\n+    }\n+  a[i + 1] = insn;\n+}\n+\n+#define SCHED_REORDER(READY, N_READY)                                \\\n+do { if ((N_READY) == 2)                                             \\\n+       swap_reorder (READY, N_READY);                                \\\n+     else if ((N_READY) > 2)                                         \\\n+       qsort (READY, N_READY, sizeof (rtx), rank_for_reorder); }     \\\n+while (0)\n+\n+/* Sort the ready list READY by ascending priority, using the SCHED_REORDER\n+   macro.  */\n+static void\n+ready_reorder (ready, nready)\n+     rtx *ready;\n+     int nready;\n+{\n+  SCHED_REORDER (ready, nready);\n+}\n+\n+/* Calculate regmode weights for all insns of all basic block.  */\n+static void\n+sh_md_init_global (dump, verbose, old_max_uid)\n+     FILE *dump ATTRIBUTE_UNUSED;\n+     int verbose ATTRIBUTE_UNUSED;\n+     int old_max_uid;\n+{\n+  basic_block b;\n+\n+  regmode_weight[0] = (short *) xcalloc (old_max_uid, sizeof (short));\n+  regmode_weight[1] = (short *) xcalloc (old_max_uid, sizeof (short));\n+\n+  FOR_EACH_BB_REVERSE (b)\n+  {\n+    find_regmode_weight (b->index, SImode);\n+    find_regmode_weight (b->index, SFmode);\n+  }\n+\n+  CURR_REGMODE_PRESSURE (SImode) = 0;\n+  CURR_REGMODE_PRESSURE (SFmode) = 0;\n+\n+}\n+\n+/* Cleanup.  */\n+static void\n+sh_md_finish_global (dump, verbose)\n+     FILE *dump ATTRIBUTE_UNUSED;\n+     int verbose ATTRIBUTE_UNUSED;\n+{\n+  if (regmode_weight[0])\n+    {\n+      free (regmode_weight[0]);\n+      regmode_weight[0] = NULL;\n+    }\n+  if (regmode_weight[1])\n+    {\n+      free (regmode_weight[1]);\n+      regmode_weight[1] = NULL;\n+    }\n+}\n+\n+/* Cache the can_issue_more so that we can return it from reorder2. Also,\n+   keep count of register pressures on SImode and SFmode. */\n+static int\n+sh_variable_issue (dump, sched_verbose, insn, can_issue_more)\n+     FILE *dump ATTRIBUTE_UNUSED;\n+     int sched_verbose ATTRIBUTE_UNUSED;\n+     rtx insn;\n+     int can_issue_more;\n+{\n+  if (GET_CODE (PATTERN (insn)) != USE\n+      && GET_CODE (PATTERN (insn)) != CLOBBER)\n+    cached_can_issue_more = can_issue_more - 1;\n+  else\n+    cached_can_issue_more = can_issue_more;\n+\n+  if (reload_completed)\n+    return cached_can_issue_more;\n+\n+  CURR_REGMODE_PRESSURE (SImode) += INSN_REGMODE_WEIGHT (insn, SImode);\n+  CURR_REGMODE_PRESSURE (SFmode) += INSN_REGMODE_WEIGHT (insn, SFmode);\n+\n+  return cached_can_issue_more;\n+}\n+\n+static void\n+sh_md_init (dump, verbose, veclen)\n+     FILE *dump ATTRIBUTE_UNUSED;\n+     int verbose ATTRIBUTE_UNUSED;\n+     int veclen ATTRIBUTE_UNUSED;\n+{\n+  CURR_REGMODE_PRESSURE (SImode) = 0;\n+  CURR_REGMODE_PRESSURE (SFmode) = 0;\n+}\n+\n+/* Some magic numbers.  */\n+/* Pressure on register r0 can lead to spill failures. so avoid sched1 for\n+   functions that already have high pressure on r0. */\n+#define R0_MAX_LIFE_REGIONS 2\n+#define R0_MAX_LIVE_LENGTH 12\n+/* Register Pressure threshols for SImode and SFmode registers.  */\n+#define SIMODE_MAX_WEIGHT 5\n+#define SFMODE_MAX_WEIGHT 10\n+\n+/* Return true if the pressure is high for MODE.  */\n+static short\n+high_pressure (mode)\n+     enum machine_mode mode;\n+{\n+  /* Pressure on register r0 can lead to spill failures. so avoid sched1 for\n+     functions that already have high pressure on r0. */\n+  if ((REG_N_SETS (0) - REG_N_DEATHS (0)) >= R0_MAX_LIFE_REGIONS\n+      && REG_LIVE_LENGTH (0) >= R0_MAX_LIVE_LENGTH)\n+    return 1;\n+\n+  if (mode == SFmode)\n+    return (CURR_REGMODE_PRESSURE (SFmode) > SFMODE_MAX_WEIGHT);\n+  else\n+    return (CURR_REGMODE_PRESSURE (SImode) > SIMODE_MAX_WEIGHT);\n+}\n+\n+/* Reorder ready queue if register pressure is high.  */\n+static int\n+sh_reorder (dump, sched_verbose, ready, n_readyp, clock_var)\n+     FILE *dump ATTRIBUTE_UNUSED;\n+     int sched_verbose ATTRIBUTE_UNUSED;\n+     rtx *ready;\n+     int *n_readyp;\n+     int clock_var ATTRIBUTE_UNUSED;\n+{\n+  if (reload_completed)\n+    return sh_issue_rate ();\n+\n+  if (high_pressure (SFmode) || high_pressure (SImode))\n+    {\n+      ready_reorder (ready, *n_readyp);\n+    }\n+\n+  return sh_issue_rate ();\n+}\n+\n+/* Skip cycles if the current register pressure is high.  */\n+static int \n+sh_reorder2 (dump, sched_verbose, ready, n_readyp, clock_var)\n+     FILE *dump ATTRIBUTE_UNUSED;\n+     int sched_verbose ATTRIBUTE_UNUSED;\n+     rtx *ready ATTRIBUTE_UNUSED;\n+     int *n_readyp ATTRIBUTE_UNUSED;\n+     int clock_var ATTRIBUTE_UNUSED;\n+{\n+  if (reload_completed)\n+    return cached_can_issue_more;\n+\n+  if (high_pressure(SFmode) || high_pressure (SImode)) \n+    skip_cycles = 1;\n+\n+  return cached_can_issue_more;\n+}\n+\n+/* Skip cycles without sorting the ready queue. This will move insn from\n+   Q->R. If this is the last cycle we are skipping; allow sorting of ready\n+   queue by sh_reorder.  */ \n+\n+/* Generally, skipping these many cycles are sufficient for all insns to move \n+   from Q -> R.  */ \n+#define MAX_SKIPS 8 \n+\n+static int\n+sh_dfa_new_cycle (sched_dump, sched_verbose, insn, last_clock_var, \n+\t\tclock_var, sort_p)\n+     FILE *sched_dump ATTRIBUTE_UNUSED;\n+     int sched_verbose ATTRIBUTE_UNUSED;\n+     rtx insn ATTRIBUTE_UNUSED;\n+     int last_clock_var;\n+     int clock_var;\n+     int *sort_p;\n+{\n+  if (reload_completed)\n+\t  return 0;\n+\n+  if (skip_cycles) \n+  {\n+    if ((clock_var - last_clock_var) < MAX_SKIPS)\n+    {\n+      *sort_p = 0;\n+      return 1;\n+    }\n+    /* If this is the last cycle we are skipping, allow reordering of R.  */\n+    if ((clock_var - last_clock_var) == MAX_SKIPS)\n+    {\n+      *sort_p = 1;\n+      return 1;\n+    }\n+  }\n+\n+  skip_cycles = 0;\n+\n+  return 0;\n+}\n+\n /* SHmedia requires registers for branches, so we can't generate new\n    branches past reload.  */\n static bool"}, {"sha": "6bdfefe7932954635a80fd7b8fc109feb7352944", "filename": "gcc/config/sh/sh.h", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58565a33ed8ca46cd1d3745f96786f3b4b0ebda3/gcc%2Fconfig%2Fsh%2Fsh.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58565a33ed8ca46cd1d3745f96786f3b4b0ebda3/gcc%2Fconfig%2Fsh%2Fsh.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.h?ref=58565a33ed8ca46cd1d3745f96786f3b4b0ebda3", "patch": "@@ -516,7 +516,11 @@ do {\t\t\t\t\t\t\t\t\t\\\n       /* Never run scheduling before reload, since that can\t\t\\\n \t break global alloc, and generates slower code anyway due\t\\\n \t to the pressure on R0.  */\t\t\t\t\t\\\n-      flag_schedule_insns = 0;\t\t\t\t\t\t\\\n+      /* Enable sched1 for SH4; ready queue will be reordered by\t\\\n+\t the target hooks when pressure is high. We can not do this for \\\n+\t SH3 and lower as they give spill failures for R0.  */\t\t\\\n+      if (!TARGET_HARD_SH4) \t\t\t\t\t\t\\\n+        flag_schedule_insns = 0;\t\t \t\t\t\\\n     }\t\t\t\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n   if (align_loops == 0)\t\t\t\t\t\t\t\\"}, {"sha": "1ffa5ee413b8cbff1b07d570f8439134aa9d9bb6", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58565a33ed8ca46cd1d3745f96786f3b4b0ebda3/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58565a33ed8ca46cd1d3745f96786f3b4b0ebda3/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=58565a33ed8ca46cd1d3745f96786f3b4b0ebda3", "patch": "@@ -5571,6 +5571,19 @@ to.  @var{verbose} is the verbose level provided by\n @option{-fsched-verbose-@var{n}}.\n @end deftypefn\n \n+@deftypefn {Target Hook} void TARGET_SCHED_INIT_GLOBAL (FILE *@var{file}, int @var{verbose}, int @var{old_max_uid})\n+This hook is executed by the scheduler after function level initializations.\n+@var{file} is either a null pointer, or a stdio stream to write any debug output to.\n+@var{verbose} is the verbose level provided by @option{-fsched-verbose-@var{n}}.\n+@var{old_max_uid} is the maximum insn uid when scheduling begins.\n+@end deftypefn\n+\n+@deftypefn {Target Hook} void TARGET_SCHED_FINISH_GLOBAL (FILE *@var{file}, int @var{verbose})\n+This is the cleanup hook corresponding to TARGET_SCHED_INIT_GLOBAL.\n+@var{file} is either a null pointer, or a stdio stream to write any debug output to.\n+@var{verbose} is the verbose level provided by @option{-fsched-verbose-@var{n}}.\n+@end deftypefn\n+\n @deftypefn {Target Hook} int TARGET_SCHED_USE_DFA_PIPELINE_INTERFACE (void)\n This hook is called many times during insn scheduling.  If the hook\n returns nonzero, the automaton based pipeline description is used for"}, {"sha": "736e5e61bcb175fd03520be4873001aaf83c112e", "filename": "gcc/flow.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58565a33ed8ca46cd1d3745f96786f3b4b0ebda3/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58565a33ed8ca46cd1d3745f96786f3b4b0ebda3/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=58565a33ed8ca46cd1d3745f96786f3b4b0ebda3", "patch": "@@ -4260,7 +4260,10 @@ void\n recompute_reg_usage (rtx f ATTRIBUTE_UNUSED, int loop_step ATTRIBUTE_UNUSED)\n {\n   allocate_reg_life_data ();\n-  update_life_info (NULL, UPDATE_LIFE_LOCAL, PROP_REG_INFO);\n+  /* distribute_notes in combiner fails to convert some of the REG_UNUSED notes\n+   to REG_DEAD notes.  This causes CHECK_DEAD_NOTES in sched1 to abort.  To \n+   solve this update the DEATH_NOTES here.  */\n+  update_life_info (NULL, UPDATE_LIFE_LOCAL, PROP_REG_INFO | PROP_DEATH_NOTES);\n }\n \n /* Optionally removes all the REG_DEAD and REG_UNUSED notes from a set of"}, {"sha": "496ea2caa2a89c6ed424b31dba7be899f0db8a83", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58565a33ed8ca46cd1d3745f96786f3b4b0ebda3/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58565a33ed8ca46cd1d3745f96786f3b4b0ebda3/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=58565a33ed8ca46cd1d3745f96786f3b4b0ebda3", "patch": "@@ -2856,6 +2856,9 @@ sched_init (FILE *dump_file)\n      removing death notes.  */\n   FOR_EACH_BB_REVERSE (b)\n     find_insn_reg_weight (b->index);\n+\n+  if (targetm.sched.md_init_global)\n+      (*targetm.sched.md_init_global) (sched_dump, sched_verbose, old_max_uid);\n }\n \n /* Free global data used during insn scheduling.  */\n@@ -2875,5 +2878,8 @@ sched_finish (void)\n   end_alias_analysis ();\n   if (write_symbols != NO_DEBUG)\n     free (line_note_head);\n+\n+  if (targetm.sched.md_finish_global)\n+      (*targetm.sched.md_finish_global) (sched_dump, sched_verbose);\n }\n #endif /* INSN_SCHEDULING */"}, {"sha": "0b35bc1855a2485a4c911ef14ab921d9c8f5e3c4", "filename": "gcc/target-def.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58565a33ed8ca46cd1d3745f96786f3b4b0ebda3/gcc%2Ftarget-def.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58565a33ed8ca46cd1d3745f96786f3b4b0ebda3/gcc%2Ftarget-def.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget-def.h?ref=58565a33ed8ca46cd1d3745f96786f3b4b0ebda3", "patch": "@@ -217,6 +217,8 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n #define TARGET_SCHED_VARIABLE_ISSUE 0\n #define TARGET_SCHED_INIT 0\n #define TARGET_SCHED_FINISH 0\n+#define TARGET_SCHED_INIT_GLOBAL 0\n+#define TARGET_SCHED_FINISH_GLOBAL 0\n #define TARGET_SCHED_REORDER 0\n #define TARGET_SCHED_REORDER2 0\n #define TARGET_SCHED_DEPENDENCIES_EVALUATION_HOOK 0\n@@ -239,6 +241,8 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n    TARGET_SCHED_VARIABLE_ISSUE,\t\t\t\t\t\\\n    TARGET_SCHED_INIT,\t\t\t\t\t\t\\\n    TARGET_SCHED_FINISH,\t\t\t\t\t\t\\\n+   TARGET_SCHED_INIT_GLOBAL,\t\t\t\t\t\\\n+   TARGET_SCHED_FINISH_GLOBAL,\t\t\t\t\t\\\n    TARGET_SCHED_REORDER,\t\t\t\t\t\\\n    TARGET_SCHED_REORDER2,\t\t\t\t\t\\\n    TARGET_SCHED_DEPENDENCIES_EVALUATION_HOOK,\t\t\t\\"}, {"sha": "67cf25da0f6e616ff38cd5b0d4141d0201912e82", "filename": "gcc/target.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58565a33ed8ca46cd1d3745f96786f3b4b0ebda3/gcc%2Ftarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58565a33ed8ca46cd1d3745f96786f3b4b0ebda3/gcc%2Ftarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.h?ref=58565a33ed8ca46cd1d3745f96786f3b4b0ebda3", "patch": "@@ -183,6 +183,12 @@ struct gcc_target\n     /* Finalize machine-dependent scheduling code.  */\n     void (* md_finish) (FILE *, int);\n \n+    /* Initialize machine-dependent function while scheduling code.  */\n+    void (* md_init_global) (FILE *, int, int);\n+\n+    /* Finalize machine-dependent function wide scheduling code.  */\n+    void (* md_finish_global) (FILE *, int);\n+\n     /* Reorder insns in a machine-dependent fashion, in two different\n        places.  Default does nothing.  */\n     int (* reorder) (FILE *, int, rtx *, int *, int);"}]}