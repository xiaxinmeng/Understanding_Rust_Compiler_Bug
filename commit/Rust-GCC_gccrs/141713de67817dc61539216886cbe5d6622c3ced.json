{"sha": "141713de67817dc61539216886cbe5d6622c3ced", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTQxNzEzZGU2NzgxN2RjNjE1MzkyMTY4ODZjYmU1ZDY2MjJjM2NlZA==", "commit": {"author": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1996-04-17T18:54:58Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1996-04-17T18:54:58Z"}, "message": "(check_newline): Rewrite to use tokens.\n\n(handle_sysv_pragma): Take a token instead of a character.\n\nFrom-SVN: r11838", "tree": {"sha": "1d7341e5872a659964541f1671e43d48a587b230", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1d7341e5872a659964541f1671e43d48a587b230"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/141713de67817dc61539216886cbe5d6622c3ced", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/141713de67817dc61539216886cbe5d6622c3ced", "html_url": "https://github.com/Rust-GCC/gccrs/commit/141713de67817dc61539216886cbe5d6622c3ced", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/141713de67817dc61539216886cbe5d6622c3ced/comments", "author": null, "committer": null, "parents": [{"sha": "402e1fd13fdb9a82b12b323dfe2a0b9a524565b0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/402e1fd13fdb9a82b12b323dfe2a0b9a524565b0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/402e1fd13fdb9a82b12b323dfe2a0b9a524565b0"}], "stats": {"total": 55, "additions": 39, "deletions": 16}, "files": [{"sha": "1ce34cecfedee2d05c909cf7feacda43cf0f5d1a", "filename": "gcc/c-lex.c", "status": "modified", "additions": 39, "deletions": 16, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/141713de67817dc61539216886cbe5d6622c3ced/gcc%2Fc-lex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/141713de67817dc61539216886cbe5d6622c3ced/gcc%2Fc-lex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-lex.c?ref=141713de67817dc61539216886cbe5d6622c3ced", "patch": "@@ -398,15 +398,33 @@ check_newline ()\n \t      && getc (finput) == 'a'\n \t      && ((c = getc (finput)) == ' ' || c == '\\t' || c == '\\n'))\n \t    {\n+\t      while (c == ' ' || c == '\\t')\n+\t\tc = getc (finput);\n+\t      if (c == '\\n')\n+\t\treturn c;\n #ifdef HANDLE_SYSV_PRAGMA\n-\t      return handle_sysv_pragma (finput, c);\n+\t      token = yylex ();\n+\t      if (token != IDENTIFIER)\n+\t\tgoto skipline;\n+\t      if (handle_sysv_pragma (finput, token))\n+\t\t{\n+\t\t  c = getc (finput);\n+\t\t  return c;\n+\t\t}\n #else /* !HANDLE_SYSV_PRAGMA */\n #ifdef HANDLE_PRAGMA\n-\t      return HANDLE_PRAGMA (finput, c);\n+\t      token = yylex ();\n+\t      if (token != IDENTIFIER)\n+\t\tgoto skipline;\n+\t      if (HANDLE_PRAGMA (finput, yylval.ttype))\n+\t\t{\n+\t\t  c = getc (finput);\n+\t\t  return c;\n+\t\t}\n #endif /* HANDLE_PRAGMA */\n-\t      goto skipline;\n #endif /* !HANDLE_SYSV_PRAGMA */\n \t    }\n+\t  goto skipline;\n \t}\n \n       else if (c == 'd')\n@@ -684,28 +702,22 @@ check_newline ()\n #ifdef HANDLE_SYSV_PRAGMA\n \n /* Handle a #pragma directive.  INPUT is the current input stream,\n-   and C is a character to reread.  Processes the entire input line\n-   and returns a character for the caller to reread: either \\n or EOF.  */\n+   and TOKEN is the token we read after `#pragma'.  Processes the entire input\n+   line and returns a character for the caller to reread: either \\n or EOF.  */\n \n /* This function has to be in this file, in order to get at\n    the token types.  */\n \n int\n-handle_sysv_pragma (input, c)\n+handle_sysv_pragma (input, token)\n      FILE *input;\n-     int c;\n+     register int token;\n {\n+  register int c;\n+\n   for (;;)\n     {\n-      while (c == ' ' || c == '\\t')\n-\tc = getc (input);\n-      if (c == '\\n' || c == EOF)\n-\t{\n-\t  handle_pragma_token (0, 0);\n-\t  return c;\n-\t}\n-      ungetc (c, input);\n-      switch (yylex ())\n+      switch (token)\n \t{\n \tcase IDENTIFIER:\n \tcase TYPENAME:\n@@ -716,10 +728,21 @@ handle_sysv_pragma (input, c)\n \tdefault:\n \t  handle_pragma_token (token_buffer, 0);\n \t}\n+\n       if (nextchar >= 0)\n \tc = nextchar, nextchar = -1;\n       else\n \tc = getc (input);\n+\n+      while (c == ' ' || c == '\\t')\n+\tc = getc (input);\n+      if (c == '\\n' || c == EOF)\n+\t{\n+\t  handle_pragma_token (0, 0);\n+\t  return c;\n+\t}\n+      ungetc (c, input);\n+      token = yylex ();\n     }\n }\n "}]}