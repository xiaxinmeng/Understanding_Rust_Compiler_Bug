{"sha": "38a448ca5dfe60244ab3c1f0ea8e3604ec69370b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzhhNDQ4Y2E1ZGZlNjAyNDRhYjNjMWYwZWE4ZTM2MDRlYzY5MzcwYg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "1998-01-14T23:10:50Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "1998-01-14T23:10:50Z"}, "message": "alias.c: Change all uses of gen_rtx(FOO...) to gen_rtx_FOO...\n\n* alias.c: Change all uses of gen_rtx(FOO...) to gen_rtx_FOO;\nchange gen_rtx(expr...) to gen_rtx_fmt_foo(expr...).\n* caller-save.c, calls.c, combine.c, cse.c: Likewise.\n* dwarf2out.c, except.c, explow.c, expmed.c, expr.c: Likewise.\n* final.c, flow.c, function.c, genpeep.c, haifa-sched.c: Likewise.\n* halfpic.c, integrate.c, jump.c, local-alloc.c, loop.c: Likewise.\n* profile.c, recog.c, reg-stack.c, regclass.c, regmove.c: Likewise.\n* reload.c, reload1.c, reorg.c, sched.c, stmt.c, stupid.c: Likewise.\n* unroll.c, varasm.c: Likewise.\n* config/alpha/alpha.c, config/alpha/alpha.md: Likewise.\n\nFrom-SVN: r17357", "tree": {"sha": "5b5f754e444d69a16ff8c719a5776021720484fb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5b5f754e444d69a16ff8c719a5776021720484fb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/38a448ca5dfe60244ab3c1f0ea8e3604ec69370b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/38a448ca5dfe60244ab3c1f0ea8e3604ec69370b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/38a448ca5dfe60244ab3c1f0ea8e3604ec69370b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/38a448ca5dfe60244ab3c1f0ea8e3604ec69370b/comments", "author": null, "committer": null, "parents": [{"sha": "ace62b49726ea831f91ad378882af8c5f8e28176", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ace62b49726ea831f91ad378882af8c5f8e28176", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ace62b49726ea831f91ad378882af8c5f8e28176"}], "stats": {"total": 2885, "additions": 1487, "deletions": 1398}, "files": [{"sha": "af70b627e15c3a7278e2dea7733a11efd231a06c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38a448ca5dfe60244ab3c1f0ea8e3604ec69370b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38a448ca5dfe60244ab3c1f0ea8e3604ec69370b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=38a448ca5dfe60244ab3c1f0ea8e3604ec69370b", "patch": "@@ -1,4 +1,17 @@\n-Wed Jan 14 19:36:08 1998  Gavin Kock  (gavin@cygnus.com)\n+Wed Jan 14 22:49:17 1998  Richard Henderson  <rth@cygnus.com>\n+\n+\t* alias.c: Change all uses of gen_rtx(FOO...) to gen_rtx_FOO;\n+\tchange gen_rtx(expr...) to gen_rtx_fmt_foo(expr...).\n+\t* caller-save.c, calls.c, combine.c, cse.c: Likewise.\n+\t* dwarf2out.c, except.c, explow.c, expmed.c, expr.c: Likewise.\n+\t* final.c, flow.c, function.c, genpeep.c, haifa-sched.c: Likewise.\n+\t* halfpic.c, integrate.c, jump.c, local-alloc.c, loop.c: Likewise.\n+\t* profile.c, recog.c, reg-stack.c, regclass.c, regmove.c: Likewise.\n+\t* reload.c, reload1.c, reorg.c, sched.c, stmt.c, stupid.c: Likewise.\n+\t* unroll.c, varasm.c: Likewise.\n+\t* config/alpha/alpha.c, config/alpha/alpha.md: Likewise.\n+\n+Wed Jan 14 19:36:08 1998  Gavin Koch  (gavin@cygnus.com)\n \n \t* mips.h: Fix some type-o's from a previous change.\n "}, {"sha": "5080822764faa2b30a406e04d05017d3b51cb4f7", "filename": "gcc/alias.c", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38a448ca5dfe60244ab3c1f0ea8e3604ec69370b/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38a448ca5dfe60244ab3c1f0ea8e3604ec69370b/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=38a448ca5dfe60244ab3c1f0ea8e3604ec69370b", "patch": "@@ -128,7 +128,7 @@ find_base_value (src)\n \t  && (XEXP (src, 0) == arg_pointer_rtx\n \t      || (GET_CODE (XEXP (src, 0)) == PLUS\n \t\t  && XEXP (XEXP (src, 0), 0) == arg_pointer_rtx)))\n-\treturn gen_rtx (ADDRESS, VOIDmode, src);\n+\treturn gen_rtx_ADDRESS (VOIDmode, src);\n       return 0;\n \n     case CONST:\n@@ -251,8 +251,8 @@ record_set (dest, set)\n \t  return;\n \t}\n       reg_seen[regno] = 1;\n-      new_reg_base_value[regno] = gen_rtx (ADDRESS, Pmode,\n-\t\t\t\t       GEN_INT (unique_id++));\n+      new_reg_base_value[regno] = gen_rtx_ADDRESS (Pmode,\n+\t\t\t\t\t\t   GEN_INT (unique_id++));\n       return;\n     }\n \n@@ -326,7 +326,7 @@ canon_rtx (x)\n \t    return plus_constant_for_output (x1, INTVAL (x0));\n \t  else if (GET_CODE (x1) == CONST_INT)\n \t    return plus_constant_for_output (x0, INTVAL (x1));\n-\t  return gen_rtx (PLUS, GET_MODE (x), x0, x1);\n+\t  return gen_rtx_PLUS (GET_MODE (x), x0, x1);\n \t}\n     }\n   /* This gives us much better alias analysis when called from\n@@ -338,7 +338,7 @@ canon_rtx (x)\n       rtx addr = canon_rtx (XEXP (x, 0));\n       if (addr != XEXP (x, 0))\n \t{\n-\t  rtx new = gen_rtx (MEM, GET_MODE (x), addr);\n+\t  rtx new = gen_rtx_MEM (GET_MODE (x), addr);\n \t  MEM_VOLATILE_P (new) = MEM_VOLATILE_P (x);\n \t  RTX_UNCHANGING_P (new) = RTX_UNCHANGING_P (x);\n \t  MEM_IN_STRUCT_P (new) = MEM_IN_STRUCT_P (x);\n@@ -1049,28 +1049,28 @@ init_alias_analysis ()\n \n       for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n \tif (TEST_HARD_REG_BIT (argument_registers, i))\n-\t  new_reg_base_value[i] = gen_rtx (ADDRESS, VOIDmode,\n-\t\t\t\t\t   gen_rtx (REG, Pmode, i));\n+\t  new_reg_base_value[i] = gen_rtx_ADDRESS (VOIDmode,\n+\t\t\t\t\t\t   gen_rtx_REG (Pmode, i));\n \n       new_reg_base_value[STACK_POINTER_REGNUM]\n-\t= gen_rtx (ADDRESS, Pmode, stack_pointer_rtx);\n+\t= gen_rtx_ADDRESS (Pmode, stack_pointer_rtx);\n       new_reg_base_value[ARG_POINTER_REGNUM]\n-\t= gen_rtx (ADDRESS, Pmode, arg_pointer_rtx);\n+\t= gen_rtx_ADDRESS (Pmode, arg_pointer_rtx);\n       new_reg_base_value[FRAME_POINTER_REGNUM]\n-\t= gen_rtx (ADDRESS, Pmode, frame_pointer_rtx);\n+\t= gen_rtx_ADDRESS (Pmode, frame_pointer_rtx);\n #if HARD_FRAME_POINTER_REGNUM != FRAME_POINTER_REGNUM\n       new_reg_base_value[HARD_FRAME_POINTER_REGNUM]\n-\t= gen_rtx (ADDRESS, Pmode, hard_frame_pointer_rtx);\n+\t= gen_rtx_ADDRESS (Pmode, hard_frame_pointer_rtx);\n #endif\n       if (struct_value_incoming_rtx\n \t  && GET_CODE (struct_value_incoming_rtx) == REG)\n \tnew_reg_base_value[REGNO (struct_value_incoming_rtx)]\n-\t  = gen_rtx (ADDRESS, Pmode, struct_value_incoming_rtx);\n+\t  = gen_rtx_ADDRESS (Pmode, struct_value_incoming_rtx);\n \n       if (static_chain_rtx\n \t  && GET_CODE (static_chain_rtx) == REG)\n \tnew_reg_base_value[REGNO (static_chain_rtx)]\n-\t  = gen_rtx (ADDRESS, Pmode, static_chain_rtx);\n+\t  = gen_rtx_ADDRESS (Pmode, static_chain_rtx);\n \n       /* Walk the insns adding values to the new_reg_base_value array.  */\n       for (insn = get_insns (); insn; insn = NEXT_INSN (insn))"}, {"sha": "d1c541e54227e00859ba2172fd6887d557bee125", "filename": "gcc/caller-save.c", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38a448ca5dfe60244ab3c1f0ea8e3604ec69370b/gcc%2Fcaller-save.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38a448ca5dfe60244ab3c1f0ea8e3604ec69370b/gcc%2Fcaller-save.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcaller-save.c?ref=38a448ca5dfe60244ab3c1f0ea8e3604ec69370b", "patch": "@@ -144,11 +144,11 @@ init_caller_save ()\n   if (i == FIRST_PSEUDO_REGISTER)\n     abort ();\n \n-  addr_reg = gen_rtx (REG, Pmode, i);\n+  addr_reg = gen_rtx_REG (Pmode, i);\n \n   for (offset = 1 << (HOST_BITS_PER_INT / 2); offset; offset >>= 1)\n     {\n-      address = gen_rtx (PLUS, Pmode, addr_reg, GEN_INT (offset));\n+      address = gen_rtx_PLUS (Pmode, addr_reg, GEN_INT (offset));\n \n       for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n \tif (regno_save_mode[i][1] != VOIDmode\n@@ -172,10 +172,10 @@ init_caller_save ()\n     for (j = 1; j <= MOVE_MAX / UNITS_PER_WORD; j++)\n       if (regno_save_mode[i][j] != VOIDmode)\n         {\n-\t  rtx mem = gen_rtx (MEM, regno_save_mode[i][j], address);\n-\t  rtx reg = gen_rtx (REG, regno_save_mode[i][j], i);\n-\t  rtx savepat = gen_rtx (SET, VOIDmode, mem, reg);\n-\t  rtx restpat = gen_rtx (SET, VOIDmode, reg, mem);\n+\t  rtx mem = gen_rtx_MEM (regno_save_mode[i][j], address);\n+\t  rtx reg = gen_rtx_REG (regno_save_mode[i][j], i);\n+\t  rtx savepat = gen_rtx_SET (VOIDmode, mem, reg);\n+\t  rtx restpat = gen_rtx_SET (VOIDmode, reg, mem);\n \t  rtx saveinsn = emit_insn (savepat);\n \t  rtx restinsn = emit_insn (restpat);\n \t  int ok;\n@@ -322,8 +322,8 @@ setup_save_areas (pchanged)\n \t      {\n \t\t/* This should not depend on WORDS_BIG_ENDIAN.\n \t\t   The order of words in regs is the same as in memory.  */\n-\t\trtx temp = gen_rtx (MEM, regno_save_mode[i+k][1], \n-\t\t\t\t    XEXP (regno_save_mem[i][j], 0));\n+\t\trtx temp = gen_rtx_MEM (regno_save_mode[i+k][1], \n+\t\t\t\t\tXEXP (regno_save_mem[i][j], 0));\n \n \t\tregno_save_mem[i+k][1] \n \t\t  = adj_offsettable_operand (temp, k * UNITS_PER_WORD);\n@@ -692,8 +692,9 @@ insert_save_restore (insn, save_p, regno, insn_mode, maxrestore)\n \t  if (! ok)\n \t    continue;\n \n-          pat = gen_rtx (SET, VOIDmode, regno_save_mem[regno][i],\n-\t\t     gen_rtx (REG, GET_MODE (regno_save_mem[regno][i]), regno));\n+          pat = gen_rtx_SET (VOIDmode, regno_save_mem[regno][i],\n+\t\t\t     gen_rtx_REG (GET_MODE (regno_save_mem[regno][i]),\n+\t\t\t\t\t  regno));\n           code = reg_save_code[regno][i];\n \n \t  /* Set hard_regs_saved for all the registers we saved.  */\n@@ -731,9 +732,9 @@ insert_save_restore (insn, save_p, regno, insn_mode, maxrestore)\n \t  if (! ok)\n \t    continue;\n \t    \n-          pat = gen_rtx (SET, VOIDmode,\n-\t\t         gen_rtx (REG, GET_MODE (regno_save_mem[regno][i]), \n-\t\t\t\t  regno), \n+          pat = gen_rtx_SET (VOIDmode,\n+\t\t\t     gen_rtx_REG (GET_MODE (regno_save_mem[regno][i]), \n+\t\t\t\t\t  regno), \n \t\t\t regno_save_mem[regno][i]);\n           code = reg_restore_code[regno][i];\n "}, {"sha": "358c637c504d40283e574b5602d0a1944d486b45", "filename": "gcc/calls.c", "status": "modified", "additions": 84, "deletions": 81, "changes": 165, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38a448ca5dfe60244ab3c1f0ea8e3604ec69370b/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38a448ca5dfe60244ab3c1f0ea8e3604ec69370b/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=38a448ca5dfe60244ab3c1f0ea8e3604ec69370b", "patch": "@@ -380,10 +380,10 @@ emit_call_1 (funexp, fndecl, funtype, stack_size, struct_value_size,\n \n       if (valreg)\n \tpat = gen_call_value_pop (valreg,\n-\t\t\t\t  gen_rtx (MEM, FUNCTION_MODE, funexp),\n+\t\t\t\t  gen_rtx_MEM (FUNCTION_MODE, funexp),\n \t\t\t\t  stack_size_rtx, next_arg_reg, n_pop);\n       else\n-\tpat = gen_call_pop (gen_rtx (MEM, FUNCTION_MODE, funexp),\n+\tpat = gen_call_pop (gen_rtx_MEM (FUNCTION_MODE, funexp),\n \t\t\t    stack_size_rtx, next_arg_reg, n_pop);\n \n       emit_call_insn (pat);\n@@ -398,11 +398,11 @@ emit_call_1 (funexp, fndecl, funtype, stack_size, struct_value_size,\n     {\n       if (valreg)\n \temit_call_insn (gen_call_value (valreg,\n-\t\t\t\t\tgen_rtx (MEM, FUNCTION_MODE, funexp),\n+\t\t\t\t\tgen_rtx_MEM (FUNCTION_MODE, funexp),\n \t\t\t\t\tstack_size_rtx, next_arg_reg,\n \t\t\t\t\tNULL_RTX));\n       else\n-\temit_call_insn (gen_call (gen_rtx (MEM, FUNCTION_MODE, funexp),\n+\temit_call_insn (gen_call (gen_rtx_MEM (FUNCTION_MODE, funexp),\n \t\t\t\t  stack_size_rtx, next_arg_reg,\n \t\t\t\t  struct_value_size_rtx));\n     }\n@@ -454,9 +454,9 @@ emit_call_1 (funexp, fndecl, funtype, stack_size, struct_value_size,\n     {\n       if (!already_popped)\n \tCALL_INSN_FUNCTION_USAGE (call_insn)\n-\t  = gen_rtx (EXPR_LIST, VOIDmode,\n-\t\t     gen_rtx (CLOBBER, VOIDmode, stack_pointer_rtx),\n-\t\t     CALL_INSN_FUNCTION_USAGE (call_insn));\n+\t  = gen_rtx_EXPR_LIST (VOIDmode,\n+\t\t\t       gen_rtx_CLOBBER (VOIDmode, stack_pointer_rtx),\n+\t\t\t       CALL_INSN_FUNCTION_USAGE (call_insn));\n       stack_size -= RETURN_POPS_ARGS (fndecl, funtype, stack_size);\n       stack_size_rtx = GEN_INT (stack_size);\n     }\n@@ -1092,10 +1092,10 @@ expand_call (exp, target, ignore)\n \t\t      pending_stack_adjust = 0;\n \t\t    }\n \n-\t\t  copy = gen_rtx (MEM, BLKmode,\n-\t\t\t\t  allocate_dynamic_stack_space (size_rtx,\n-\t\t\t\t\t\t\t\tNULL_RTX,\n-\t\t\t\t\t\t\t\tTYPE_ALIGN (type)));\n+\t\t  copy = gen_rtx_MEM (BLKmode,\n+\t\t\t\t      allocate_dynamic_stack_space (size_rtx,\n+\t\t\t\t\t\t\t\t    NULL_RTX,\n+\t\t\t\t\t\t\t\t    TYPE_ALIGN (type)));\n \t\t}\n \t      else\n \t\t{\n@@ -1567,20 +1567,20 @@ expand_call (exp, target, ignore)\n \t  if (GET_CODE (offset) == CONST_INT)\n \t    addr = plus_constant (arg_reg, INTVAL (offset));\n \t  else\n-\t    addr = gen_rtx (PLUS, Pmode, arg_reg, offset);\n+\t    addr = gen_rtx_PLUS (Pmode, arg_reg, offset);\n \n \t  addr = plus_constant (addr, arg_offset);\n-\t  args[i].stack = gen_rtx (MEM, args[i].mode, addr);\n+\t  args[i].stack = gen_rtx_MEM (args[i].mode, addr);\n \t  MEM_IN_STRUCT_P (args[i].stack)\n \t    = AGGREGATE_TYPE_P (TREE_TYPE (args[i].tree_value));\n \n \t  if (GET_CODE (slot_offset) == CONST_INT)\n \t    addr = plus_constant (arg_reg, INTVAL (slot_offset));\n \t  else\n-\t    addr = gen_rtx (PLUS, Pmode, arg_reg, slot_offset);\n+\t    addr = gen_rtx_PLUS (Pmode, arg_reg, slot_offset);\n \n \t  addr = plus_constant (addr, arg_offset);\n-\t  args[i].stack_slot = gen_rtx (MEM, args[i].mode, addr);\n+\t  args[i].stack_slot = gen_rtx_MEM (args[i].mode, addr);\n \t}\n     }\n \t\t\t\t\t       \n@@ -1723,17 +1723,17 @@ expand_call (exp, target, ignore)\n \t\t\t       BIGGEST_ALIGNMENT / UNITS_PER_WORD) - 1)))\n \tsave_mode = BLKmode;\n \n-      stack_area = gen_rtx (MEM, save_mode,\n-\t\t\t    memory_address (save_mode,\n+      stack_area = gen_rtx_MEM (save_mode,\n+\t\t\t\tmemory_address (save_mode,\n \t\t\t\t\t    \n #ifdef ARGS_GROW_DOWNWARD\n-\t\t\t\t\t    plus_constant (argblock,\n-\t\t\t\t\t\t\t   - high_to_save)\n+\t\t\t\t\t\tplus_constant (argblock,\n+\t\t\t\t\t\t\t       - high_to_save)\n #else\n-\t\t\t\t\t    plus_constant (argblock,\n-\t\t\t\t\t\t\t   low_to_save)\n+\t\t\t\t\t\tplus_constant (argblock,\n+\t\t\t\t\t\t\t       low_to_save)\n #endif\n-\t\t\t\t\t    ));\n+\t\t\t\t\t\t));\n       if (save_mode == BLKmode)\n \t{\n \t  save_area = assign_stack_temp (BLKmode, num_to_save, 0);\n@@ -1926,7 +1926,7 @@ expand_call (exp, target, ignore)\n \n \t  else if (args[i].n_aligned_regs != 0)\n \t    for (j = 0; j < args[i].n_aligned_regs; j++)\n-\t      emit_move_insn (gen_rtx (REG, word_mode, REGNO (reg) + j),\n+\t      emit_move_insn (gen_rtx_REG (word_mode, REGNO (reg) + j),\n \t\t\t      args[i].aligned_regs[j]);\n \n \t  else if (partial == 0 || args[i].pass_on_stack)\n@@ -1976,12 +1976,12 @@ expand_call (exp, target, ignore)\n \t arguments in order as well as the function name.  */\n #ifdef PUSH_ARGS_REVERSED\n       for (i = 0; i < num_actuals; i++)\n-\tnote = gen_rtx (EXPR_LIST, VOIDmode, args[i].initial_value, note);\n+\tnote = gen_rtx_EXPR_LIST (VOIDmode, args[i].initial_value, note);\n #else\n       for (i = num_actuals - 1; i >= 0; i--)\n-\tnote = gen_rtx (EXPR_LIST, VOIDmode, args[i].initial_value, note);\n+\tnote = gen_rtx_EXPR_LIST (VOIDmode, args[i].initial_value, note);\n #endif\n-      note = gen_rtx (EXPR_LIST, VOIDmode, funexp, note);\n+      note = gen_rtx_EXPR_LIST (VOIDmode, funexp, note);\n \n       insns = get_insns ();\n       end_sequence ();\n@@ -2013,7 +2013,7 @@ expand_call (exp, target, ignore)\n \t anything else.  */\n       last = get_last_insn ();\n       REG_NOTES (last) = \n-\tgen_rtx (EXPR_LIST, REG_NOALIAS, temp, REG_NOTES (last));\n+\tgen_rtx_EXPR_LIST (REG_NOALIAS, temp, REG_NOTES (last));\n \n       /* Write out the sequence.  */\n       insns = get_insns ();\n@@ -2060,9 +2060,9 @@ expand_call (exp, target, ignore)\n     {\n       if (target == 0 || GET_CODE (target) != MEM)\n \t{\n-\t  target = gen_rtx (MEM, TYPE_MODE (TREE_TYPE (exp)),\n-\t\t\t    memory_address (TYPE_MODE (TREE_TYPE (exp)),\n-\t\t\t\t\t    structure_value_addr));\n+\t  target = gen_rtx_MEM (TYPE_MODE (TREE_TYPE (exp)),\n+\t\t\t\tmemory_address (TYPE_MODE (TREE_TYPE (exp)),\n+\t\t\t\t\t\tstructure_value_addr));\n \t  MEM_IN_STRUCT_P (target) = AGGREGATE_TYPE_P (TREE_TYPE (exp));\n \t}\n     }\n@@ -2071,8 +2071,8 @@ expand_call (exp, target, ignore)\n       /* This is the special C++ case where we need to\n \t know what the true target was.  We take care to\n \t never use this value more than once in one expression.  */\n-      target = gen_rtx (MEM, TYPE_MODE (TREE_TYPE (exp)),\n-\t\t\tcopy_to_reg (valreg));\n+      target = gen_rtx_MEM (TYPE_MODE (TREE_TYPE (exp)),\n+\t\t\t    copy_to_reg (valreg));\n       MEM_IN_STRUCT_P (target) = AGGREGATE_TYPE_P (TREE_TYPE (exp));\n     }\n   /* Handle calls that return values in multiple non-contiguous locations.\n@@ -2189,7 +2189,7 @@ expand_call (exp, target, ignore)\n \t  != promote_mode (type, TYPE_MODE (type), &unsignedp, 1))\n \tabort ();\n \n-      target = gen_rtx (SUBREG, TYPE_MODE (type), target, 0);\n+      target = gen_rtx_SUBREG (TYPE_MODE (type), target, 0);\n       SUBREG_PROMOTED_VAR_P (target) = 1;\n       SUBREG_PROMOTED_UNSIGNED_P (target) = unsignedp;\n     }\n@@ -2216,14 +2216,16 @@ expand_call (exp, target, ignore)\n \t{\n \t  enum machine_mode save_mode = GET_MODE (save_area);\n \t  rtx stack_area\n-\t    = gen_rtx (MEM, save_mode,\n-\t\t       memory_address (save_mode,\n+\t    = gen_rtx_MEM (save_mode,\n+\t\t\t   memory_address (save_mode,\n #ifdef ARGS_GROW_DOWNWARD\n-\t\t\t\t       plus_constant (argblock, - high_to_save)\n+\t\t\t\t\t   plus_constant (argblock,\n+\t\t\t\t\t\t\t  - high_to_save)\n #else\n-\t\t\t\t       plus_constant (argblock, low_to_save)\n+\t\t\t\t\t   plus_constant (argblock,\n+\t\t\t\t\t\t\t  low_to_save)\n #endif\n-\t\t\t\t       ));\n+\t\t\t\t\t   ));\n \n \t  if (save_mode != BLKmode)\n \t    emit_move_insn (stack_area, save_area);\n@@ -2240,9 +2242,9 @@ expand_call (exp, target, ignore)\n \t  {\n \t    enum machine_mode save_mode = GET_MODE (args[i].save_area);\n \t    rtx stack_area\n-\t      = gen_rtx (MEM, save_mode,\n-\t\t\t memory_address (save_mode,\n-\t\t\t\t\t XEXP (args[i].stack_slot, 0)));\n+\t      = gen_rtx_MEM (save_mode,\n+\t\t\t     memory_address (save_mode,\n+\t\t\t\t\t     XEXP (args[i].stack_slot, 0)));\n \n \t    if (save_mode != BLKmode)\n \t      emit_move_insn (stack_area, args[i].save_area);\n@@ -2572,17 +2574,17 @@ emit_library_call VPROTO((rtx orgfun, int no_queue, enum machine_mode outmode,\n \t\t\t       BIGGEST_ALIGNMENT / UNITS_PER_WORD) - 1)))\n \tsave_mode = BLKmode;\n \n-      stack_area = gen_rtx (MEM, save_mode,\n-\t\t\t    memory_address (save_mode,\n+      stack_area = gen_rtx_MEM (save_mode,\n+\t\t\t\tmemory_address (save_mode,\n \t\t\t\t\t    \n #ifdef ARGS_GROW_DOWNWARD\n-\t\t\t\t\t    plus_constant (argblock,\n-\t\t\t\t\t\t\t   - high_to_save)\n+\t\t\t\t\t\tplus_constant (argblock,\n+\t\t\t\t\t\t\t       - high_to_save)\n #else\n-\t\t\t\t\t    plus_constant (argblock,\n-\t\t\t\t\t\t\t   low_to_save)\n+\t\t\t\t\t\tplus_constant (argblock,\n+\t\t\t\t\t\t\t       low_to_save)\n #endif\n-\t\t\t\t\t    ));\n+\t\t\t\t\t\t));\n       if (save_mode == BLKmode)\n \t{\n \t  save_area = assign_stack_temp (BLKmode, num_to_save, 0);\n@@ -2644,9 +2646,9 @@ emit_library_call VPROTO((rtx orgfun, int no_queue, enum machine_mode outmode,\n \t\t= mode_for_size (argvec[argnum].size.constant * BITS_PER_UNIT,\n \t\t\t\t MODE_INT, 1);\n \t      rtx stack_area\n-\t\t= gen_rtx (MEM, save_mode,\n-\t\t\t   memory_address (save_mode, plus_constant (argblock,\n-\t\t\t\t\t   argvec[argnum].offset.constant)));\n+\t\t= gen_rtx_MEM (save_mode,\n+\t\t\t       memory_address (save_mode,\n+\t\t\t\t\t       plus_constant (argblock, argvec[argnum].offset.constant)));\n \t      argvec[argnum].save_area = gen_reg_rtx (save_mode);\n \t      emit_move_insn (argvec[argnum].save_area, stack_area);\n \t    }\n@@ -2739,14 +2741,14 @@ emit_library_call VPROTO((rtx orgfun, int no_queue, enum machine_mode outmode,\n     {\n       enum machine_mode save_mode = GET_MODE (save_area);\n       rtx stack_area\n-\t= gen_rtx (MEM, save_mode,\n-\t\t   memory_address (save_mode,\n+\t= gen_rtx_MEM (save_mode,\n+\t\t       memory_address (save_mode,\n #ifdef ARGS_GROW_DOWNWARD\n-\t\t\t\t   plus_constant (argblock, - high_to_save)\n+\t\t\t\t       plus_constant (argblock, - high_to_save)\n #else\n-\t\t\t\t   plus_constant (argblock, low_to_save)\n+\t\t\t\t       plus_constant (argblock, low_to_save)\n #endif\n-\t\t\t\t   ));\n+\t\t\t\t       ));\n \n       if (save_mode != BLKmode)\n \temit_move_insn (stack_area, save_area);\n@@ -2763,9 +2765,9 @@ emit_library_call VPROTO((rtx orgfun, int no_queue, enum machine_mode outmode,\n       {\n \tenum machine_mode save_mode = GET_MODE (argvec[count].save_area);\n \trtx stack_area\n-\t  = gen_rtx (MEM, save_mode,\n-\t\t     memory_address (save_mode, plus_constant (argblock,\n-\t\t\t\t     argvec[count].offset.constant)));\n+\t  = gen_rtx_MEM (save_mode,\n+\t\t\t memory_address (save_mode,\n+\t\t\t\t\t plus_constant (argblock, argvec[count].offset.constant)));\n \n \temit_move_insn (stack_area, argvec[count].save_area);\n       }\n@@ -2859,7 +2861,7 @@ emit_library_call_value VPROTO((rtx orgfun, rtx value, int no_queue,\n       rtx pointer_reg\n \t= hard_function_value (build_pointer_type (type_for_mode (outmode, 0)),\n \t\t\t       0);\n-      mem_value = gen_rtx (MEM, outmode, pointer_reg);\n+      mem_value = gen_rtx_MEM (outmode, pointer_reg);\n       pcc_struct_value = 1;\n       if (value == 0)\n \tvalue = gen_reg_rtx (outmode);\n@@ -3140,17 +3142,17 @@ emit_library_call_value VPROTO((rtx orgfun, rtx value, int no_queue,\n \t\t\t       BIGGEST_ALIGNMENT / UNITS_PER_WORD) - 1)))\n \tsave_mode = BLKmode;\n \n-      stack_area = gen_rtx (MEM, save_mode,\n-\t\t\t    memory_address (save_mode,\n+      stack_area = gen_rtx_MEM (save_mode,\n+\t\t\t\tmemory_address (save_mode,\n \t\t\t\t\t    \n #ifdef ARGS_GROW_DOWNWARD\n-\t\t\t\t\t    plus_constant (argblock,\n-\t\t\t\t\t\t\t   - high_to_save)\n+\t\t\t\t\t\tplus_constant (argblock,\n+\t\t\t\t\t\t\t       - high_to_save)\n #else\n-\t\t\t\t\t    plus_constant (argblock,\n-\t\t\t\t\t\t\t   low_to_save)\n+\t\t\t\t\t\tplus_constant (argblock,\n+\t\t\t\t\t\t\t       low_to_save)\n #endif\n-\t\t\t\t\t    ));\n+\t\t\t\t\t\t));\n       if (save_mode == BLKmode)\n \t{\n \t  save_area = assign_stack_temp (BLKmode, num_to_save, 0);\n@@ -3212,9 +3214,10 @@ emit_library_call_value VPROTO((rtx orgfun, rtx value, int no_queue,\n \t\t= mode_for_size (argvec[argnum].size.constant * BITS_PER_UNIT,\n \t\t\t\t MODE_INT, 1);\n \t      rtx stack_area\n-\t\t= gen_rtx (MEM, save_mode,\n-\t\t\t   memory_address (save_mode, plus_constant (argblock,\n-\t\t\t\t\t   argvec[argnum].offset.constant)));\n+\t\t= gen_rtx_MEM (save_mode,\n+\t\t\t       memory_address (save_mode,\n+\t\t\t\t\t       plus_constant (argblock,\n+\t\t\t\t\t\t\t      argvec[argnum].offset.constant)));\n \t      argvec[argnum].save_area = gen_reg_rtx (save_mode);\n \t      emit_move_insn (argvec[argnum].save_area, stack_area);\n \t    }\n@@ -3332,15 +3335,14 @@ emit_library_call_value VPROTO((rtx orgfun, rtx value, int no_queue,\n     {\n       enum machine_mode save_mode = GET_MODE (save_area);\n       rtx stack_area\n-\t= gen_rtx (MEM, save_mode,\n-\t\t   memory_address (save_mode,\n+\t= gen_rtx_MEM (save_mode,\n+\t\t       memory_address (save_mode,\n #ifdef ARGS_GROW_DOWNWARD\n-\t\t\t\t   plus_constant (argblock, - high_to_save)\n+\t\t\t\t       plus_constant (argblock, - high_to_save)\n #else\n-\t\t\t\t   plus_constant (argblock, low_to_save)\n+\t\t\t\t       plus_constant (argblock, low_to_save)\n #endif\n-\t\t\t\t   ));\n-\n+\t\t\t\t       ));\n       if (save_mode != BLKmode)\n \temit_move_insn (stack_area, save_area);\n       else\n@@ -3356,7 +3358,7 @@ emit_library_call_value VPROTO((rtx orgfun, rtx value, int no_queue,\n       {\n \tenum machine_mode save_mode = GET_MODE (argvec[count].save_area);\n \trtx stack_area\n-\t  = gen_rtx (MEM, save_mode,\n+\t  = gen_rtx_MEM (save_mode,\n \t\t     memory_address (save_mode, plus_constant (argblock,\n \t\t\t\t     argvec[count].offset.constant)));\n \n@@ -3400,11 +3402,11 @@ target_for_arg (type, size, args_addr, offset)\n     {\n       /* I have no idea how to guarantee that this\n \t will work in the presence of register parameters.  */\n-      target = gen_rtx (PLUS, Pmode, args_addr, offset_rtx);\n+      target = gen_rtx_PLUS (Pmode, args_addr, offset_rtx);\n       target = memory_address (QImode, target);\n     }\n \n-  return gen_rtx (MEM, BLKmode, target);\n+  return gen_rtx_MEM (BLKmode, target);\n }\n #endif\n \f\n@@ -3486,8 +3488,9 @@ store_one_arg (arg, argblock, may_be_alloca, variable_size, fndecl,\n \t  enum machine_mode save_mode\n \t    = mode_for_size (arg->size.constant * BITS_PER_UNIT, MODE_INT, 1);\n \t  rtx stack_area\n-\t    = gen_rtx (MEM, save_mode,\n-\t\t       memory_address (save_mode, XEXP (arg->stack_slot, 0)));\n+\t    = gen_rtx_MEM (save_mode,\n+\t\t\t   memory_address (save_mode,\n+\t\t\t\t\t   XEXP (arg->stack_slot, 0)));\n \n \t  if (save_mode == BLKmode)\n \t    {"}, {"sha": "fc3d688b5f3a8b86b339eded099a535dd68b94b4", "filename": "gcc/combine.c", "status": "modified", "additions": 136, "deletions": 128, "changes": 264, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38a448ca5dfe60244ab3c1f0ea8e3604ec69370b/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38a448ca5dfe60244ab3c1f0ea8e3604ec69370b/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=38a448ca5dfe60244ab3c1f0ea8e3604ec69370b", "patch": "@@ -711,10 +711,13 @@ setup_incoming_promotions ()\n   for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n     if (FUNCTION_ARG_REGNO_P (regno)\n \t&& (reg = promoted_input_arg (regno, &mode, &unsignedp)) != 0)\n-      record_value_for_reg (reg, first,\n-\t\t\t    gen_rtx (unsignedp ? ZERO_EXTEND : SIGN_EXTEND,\n-\t\t\t\t     GET_MODE (reg),\n-\t\t\t\t     gen_rtx (CLOBBER, mode, const0_rtx)));\n+      {\n+\trecord_value_for_reg\n+\t  (reg, first, gen_rtx_fmt_e ((unsignedp ? ZERO_EXTEND\n+\t\t\t\t       : SIGN_EXTEND),\n+\t\t\t\t      GET_MODE (reg),\n+\t\t\t\t      gen_rtx_CLOBBER (mode, const0_rtx)));\n+      }\n #endif\n }\n \f\n@@ -1449,8 +1452,9 @@ try_combine (i3, i2, i1)\n \t     as I2 will not cause a problem.  */\n \n \t  subst_prev_insn = i1\n-\t    = gen_rtx (INSN, VOIDmode, INSN_UID (i2), NULL_RTX, i2,\n-\t\t       XVECEXP (PATTERN (i2), 0, 1), -1, NULL_RTX, NULL_RTX);\n+\t    = gen_rtx_INSN (VOIDmode, INSN_UID (i2), NULL_RTX, i2,\n+\t\t\t    XVECEXP (PATTERN (i2), 0, 1), -1, NULL_RTX,\n+\t\t\t    NULL_RTX);\n \n \t  SUBST (PATTERN (i2), XVECEXP (PATTERN (i2), 0, 0));\n \t  SUBST (XEXP (SET_SRC (PATTERN (i2)), 0),\n@@ -1547,7 +1551,7 @@ try_combine (i3, i2, i1)\n      I2DEST.  */\n \n   i2pat = (GET_CODE (PATTERN (i2)) == PARALLEL\n-\t   ? gen_rtx (SET, VOIDmode, i2dest, i2src)\n+\t   ? gen_rtx_SET (VOIDmode, i2dest, i2src)\n \t   : PATTERN (i2));\n \n   if (added_sets_2)\n@@ -1633,7 +1637,7 @@ try_combine (i3, i2, i1)\n \t      != GET_MODE (SET_DEST (newpat))))\n \t{\n \t  int regno = REGNO (SET_DEST (newpat));\n-\t  rtx new_dest = gen_rtx (REG, compare_mode, regno);\n+\t  rtx new_dest = gen_rtx_REG (compare_mode, regno);\n \n \t  if (regno < FIRST_PSEUDO_REGISTER\n \t      || (REG_N_SETS (regno) == 1 && ! added_sets_2\n@@ -1727,22 +1731,22 @@ try_combine (i3, i2, i1)\n \t{\n \t  rtvec old = XVEC (newpat, 0);\n \t  total_sets = XVECLEN (newpat, 0) + added_sets_1 + added_sets_2;\n-\t  newpat = gen_rtx (PARALLEL, VOIDmode, rtvec_alloc (total_sets));\n+\t  newpat = gen_rtx_PARALLEL (VOIDmode, rtvec_alloc (total_sets));\n \t  bcopy ((char *) &old->elem[0], (char *) XVEC (newpat, 0)->elem,\n \t\t sizeof (old->elem[0]) * old->num_elem);\n \t}\n       else\n \t{\n \t  rtx old = newpat;\n \t  total_sets = 1 + added_sets_1 + added_sets_2;\n-\t  newpat = gen_rtx (PARALLEL, VOIDmode, rtvec_alloc (total_sets));\n+\t  newpat = gen_rtx_PARALLEL (VOIDmode, rtvec_alloc (total_sets));\n \t  XVECEXP (newpat, 0, 0) = old;\n \t}\n \n      if (added_sets_1)\n        XVECEXP (newpat, 0, --total_sets)\n \t = (GET_CODE (PATTERN (i1)) == PARALLEL\n-\t    ? gen_rtx (SET, VOIDmode, i1dest, i1src) : PATTERN (i1));\n+\t    ? gen_rtx_SET (VOIDmode, i1dest, i1src) : PATTERN (i1));\n \n      if (added_sets_2)\n \t{\n@@ -1841,15 +1845,15 @@ try_combine (i3, i2, i1)\n \t      && (REGNO (i2dest) < FIRST_PSEUDO_REGISTER\n \t\t  || (REG_N_SETS (REGNO (i2dest)) == 1 && ! added_sets_2\n \t\t      && ! REG_USERVAR_P (i2dest))))\n-\t    ni2dest = gen_rtx (REG, GET_MODE (SET_DEST (newpat)),\n+\t    ni2dest = gen_rtx_REG (GET_MODE (SET_DEST (newpat)),\n \t\t\t       REGNO (i2dest));\n \n-\t  m_split = split_insns (gen_rtx (PARALLEL, VOIDmode,\n-\t\t\t\t\t  gen_rtvec (2, newpat,\n-\t\t\t\t\t\t     gen_rtx (CLOBBER,\n-\t\t\t\t\t\t\t      VOIDmode,\n-\t\t\t\t\t\t\t      ni2dest))),\n-\t\t\t\t i3);\n+\t  m_split = split_insns\n+\t    (gen_rtx_PARALLEL (VOIDmode,\n+\t\t\t       gen_rtvec (2, newpat,\n+\t\t\t\t\t  gen_rtx_CLOBBER (VOIDmode,\n+\t\t\t\t\t\t\t   ni2dest))),\n+\t     i3);\n \t}\n \n       if (m_split && GET_CODE (m_split) == SEQUENCE\n@@ -1940,7 +1944,7 @@ try_combine (i3, i2, i1)\n \t     validated that we can do this.  */\n \t  if (GET_MODE (i2dest) != split_mode && split_mode != VOIDmode)\n \t    {\n-\t      newdest = gen_rtx (REG, split_mode, REGNO (i2dest));\n+\t      newdest = gen_rtx_REG (split_mode, REGNO (i2dest));\n \n \t      if (REGNO (i2dest) >= FIRST_PSEUDO_REGISTER)\n \t\tSUBST (regno_reg_rtx[REGNO (i2dest)], newdest);\n@@ -2053,7 +2057,7 @@ try_combine (i3, i2, i1)\n \t     that destination.  */\n \n \t  PATTERN (i3) = newpat;\n-\t  distribute_links (gen_rtx (INSN_LIST, VOIDmode, i3, NULL_RTX));\n+\t  distribute_links (gen_rtx_INSN_LIST (VOIDmode, i3, NULL_RTX));\n \n \t  /* I3 now uses what used to be its destination and which is\n \t     now I2's destination.  That means we need a LOG_LINK from\n@@ -2364,12 +2368,12 @@ try_combine (i3, i2, i1)\n \t  REG_N_DEATHS (REGNO (i3dest_killed))++;\n \n \tif (newi2pat && reg_set_p (i3dest_killed, newi2pat))\n-\t  distribute_notes (gen_rtx (EXPR_LIST, REG_DEAD, i3dest_killed,\n-\t\t\t\t     NULL_RTX),\n+\t  distribute_notes (gen_rtx_EXPR_LIST (REG_DEAD, i3dest_killed,\n+\t\t\t\t\t       NULL_RTX),\n \t\t\t    NULL_RTX, i2, NULL_RTX, elim_i2, elim_i1);\n \telse\n-\t  distribute_notes (gen_rtx (EXPR_LIST, REG_DEAD, i3dest_killed,\n-\t\t\t\t     NULL_RTX),\n+\t  distribute_notes (gen_rtx_EXPR_LIST (REG_DEAD, i3dest_killed,\n+\t\t\t\t\t       NULL_RTX),\n \t\t\t    NULL_RTX, i3, newi2pat ? i2 : NULL_RTX,\n \t\t\t    elim_i2, elim_i1);\n       }\n@@ -2380,10 +2384,10 @@ try_combine (i3, i2, i1)\n \t  REG_N_DEATHS (REGNO (i2dest))++;\n \n \tif (newi2pat && reg_set_p (i2dest, newi2pat))\n-\t  distribute_notes (gen_rtx (EXPR_LIST, REG_DEAD, i2dest, NULL_RTX),\n+\t  distribute_notes (gen_rtx_EXPR_LIST (REG_DEAD, i2dest, NULL_RTX),\n \t\t\t    NULL_RTX, i2, NULL_RTX, NULL_RTX, NULL_RTX);\n \telse\n-\t  distribute_notes (gen_rtx (EXPR_LIST, REG_DEAD, i2dest, NULL_RTX),\n+\t  distribute_notes (gen_rtx_EXPR_LIST (REG_DEAD, i2dest, NULL_RTX),\n \t\t\t    NULL_RTX, i3, newi2pat ? i2 : NULL_RTX,\n \t\t\t    NULL_RTX, NULL_RTX);\n       }\n@@ -2394,10 +2398,10 @@ try_combine (i3, i2, i1)\n \t  REG_N_DEATHS (REGNO (i1dest))++;\n \n \tif (newi2pat && reg_set_p (i1dest, newi2pat))\n-\t  distribute_notes (gen_rtx (EXPR_LIST, REG_DEAD, i1dest, NULL_RTX),\n+\t  distribute_notes (gen_rtx_EXPR_LIST (REG_DEAD, i1dest, NULL_RTX),\n \t\t\t    NULL_RTX, i2, NULL_RTX, NULL_RTX, NULL_RTX);\n \telse\n-\t  distribute_notes (gen_rtx (EXPR_LIST, REG_DEAD, i1dest, NULL_RTX),\n+\t  distribute_notes (gen_rtx_EXPR_LIST (REG_DEAD, i1dest, NULL_RTX),\n \t\t\t    NULL_RTX, i3, newi2pat ? i2 : NULL_RTX,\n \t\t\t    NULL_RTX, NULL_RTX);\n       }\n@@ -2581,7 +2585,7 @@ find_split_point (loc, insn)\n \t  && ! memory_address_p (GET_MODE (x), XEXP (x, 0)))\n \t{\n \t  rtx reg = regno_reg_rtx[FIRST_PSEUDO_REGISTER];\n-\t  rtx seq = split_insns (gen_rtx (SET, VOIDmode, reg, XEXP (x, 0)),\n+\t  rtx seq = split_insns (gen_rtx_SET (VOIDmode, reg, XEXP (x, 0)),\n \t\t\t\t subst_insn);\n \n \t  /* This should have produced two insns, each of which sets our\n@@ -2983,7 +2987,7 @@ subst (x, from, to, in_dest, unique_copy)\n      So force this insn not to match in this (rare) case.  */\n   if (! in_dest && code == REG && GET_CODE (from) == REG\n       && REGNO (x) == REGNO (from))\n-    return gen_rtx (CLOBBER, GET_MODE (x), const0_rtx);\n+    return gen_rtx_CLOBBER (GET_MODE (x), const0_rtx);\n \n   /* If this is an object, we are done unless it is a MEM or LO_SUM, both\n      of which may contain things that can be combined.  */\n@@ -3065,7 +3069,7 @@ subst (x, from, to, in_dest, unique_copy)\n \t\t  && ! (code == SET && i == 1 && XEXP (x, 0) == cc0_rtx)\n #endif\n \t\t  )\n-\t\treturn gen_rtx (CLOBBER, VOIDmode, const0_rtx);\n+\t\treturn gen_rtx_CLOBBER (VOIDmode, const0_rtx);\n \n \t      new = (unique_copy && n_occurrences ? copy_rtx (to) : to);\n \t      n_occurrences++;\n@@ -3267,9 +3271,10 @@ simplify_rtx (x, op0_mode, last, in_dest)\n \t\t\t   gen_binary (reverse_condition (cond_code), \n \t\t\t\t       mode, cond, cop1));\n \t  else\n-\t    return gen_rtx (IF_THEN_ELSE, mode,\n-\t\t\t    gen_binary (cond_code, VOIDmode, cond, cop1),\n-\t\t\t    true, false);\n+\t    return gen_rtx_IF_THEN_ELSE (mode,\n+\t\t\t\t\t gen_binary (cond_code, VOIDmode,\n+\t\t\t\t\t\t     cond, cop1),\n+\t\t\t\t\t true, false);\n \n \t  code = GET_CODE (x);\n \t  op0_mode = VOIDmode;\n@@ -3385,7 +3390,7 @@ simplify_rtx (x, op0_mode, last, in_dest)\n \t     if that would change the meaning of the address.  */\n \t  if (MEM_VOLATILE_P (SUBREG_REG (x))\n \t      || mode_dependent_address_p (XEXP (inner, 0)))\n-\t    return gen_rtx (CLOBBER, mode, const0_rtx);\n+\t    return gen_rtx_CLOBBER (mode, const0_rtx);\n \n \t  if (BYTES_BIG_ENDIAN)\n \t    {\n@@ -3397,10 +3402,10 @@ simplify_rtx (x, op0_mode, last, in_dest)\n \t    }\n \t  /* Note if the plus_constant doesn't make a valid address\n \t     then this combination won't be accepted.  */\n-\t  x = gen_rtx (MEM, mode,\n-\t\t       plus_constant (XEXP (inner, 0),\n-\t\t\t\t      (SUBREG_WORD (x) * UNITS_PER_WORD\n-\t\t\t\t       + endian_offset)));\n+\t  x = gen_rtx_MEM (mode,\n+\t\t\t   plus_constant (XEXP (inner, 0),\n+\t\t\t\t\t  (SUBREG_WORD (x) * UNITS_PER_WORD\n+\t\t\t\t\t   + endian_offset)));\n \t  MEM_VOLATILE_P (x) = MEM_VOLATILE_P (inner);\n \t  RTX_UNCHANGING_P (x) = RTX_UNCHANGING_P (inner);\n \t  MEM_IN_STRUCT_P (x) = MEM_IN_STRUCT_P (inner);\n@@ -3442,10 +3447,10 @@ simplify_rtx (x, op0_mode, last, in_dest)\n \t{\n \t  if (HARD_REGNO_MODE_OK (REGNO (SUBREG_REG (x)) + SUBREG_WORD (x),\n \t\t\t\t  mode))\n-\t    return gen_rtx (REG, mode,\n-\t\t\t    REGNO (SUBREG_REG (x)) + SUBREG_WORD (x));\n+\t    return gen_rtx_REG (mode,\n+\t\t\t\tREGNO (SUBREG_REG (x)) + SUBREG_WORD (x));\n \t  else\n-\t    return gen_rtx (CLOBBER, mode, const0_rtx);\n+\t    return gen_rtx_CLOBBER (mode, const0_rtx);\n \t}\n \n       /* For a constant, try to pick up the part we want.  Handle a full\n@@ -3519,8 +3524,8 @@ simplify_rtx (x, op0_mode, last, in_dest)\n \t but this doesn't seem common enough to bother with.  */\n       if (GET_CODE (XEXP (x, 0)) == ASHIFT\n \t  && XEXP (XEXP (x, 0), 0) == const1_rtx)\n-\treturn gen_rtx (ROTATE, mode, gen_unary (NOT, mode, mode, const1_rtx),\n-\t\t\tXEXP (XEXP (x, 0), 1));\n+\treturn gen_rtx_ROTATE (mode, gen_unary (NOT, mode, mode, const1_rtx),\n+\t\t\t       XEXP (XEXP (x, 0), 1));\n \t\t\t\t\t    \n       if (GET_CODE (XEXP (x, 0)) == SUBREG\n \t  && subreg_lowpart_p (XEXP (x, 0))\n@@ -3531,9 +3536,10 @@ simplify_rtx (x, op0_mode, last, in_dest)\n \t{\n \t  enum machine_mode inner_mode = GET_MODE (SUBREG_REG (XEXP (x, 0)));\n \n-\t  x = gen_rtx (ROTATE, inner_mode,\n-\t\t       gen_unary (NOT, inner_mode, inner_mode, const1_rtx),\n-\t\t       XEXP (SUBREG_REG (XEXP (x, 0)), 1));\n+\t  x = gen_rtx_ROTATE (inner_mode,\n+\t\t\t      gen_unary (NOT, inner_mode, inner_mode,\n+\t\t\t\t\t const1_rtx),\n+\t\t\t      XEXP (SUBREG_REG (XEXP (x, 0)), 1));\n \t  return gen_lowpart_for_combine (mode, x);\n \t}\n \t\t\t\t\t    \n@@ -4538,7 +4544,7 @@ simplify_set (x)\n       if (compare_mode != GET_MODE (dest))\n \t{\n \t  int regno = REGNO (dest);\n-\t  rtx new_dest = gen_rtx (REG, compare_mode, regno);\n+\t  rtx new_dest = gen_rtx_REG (compare_mode, regno);\n \n \t  if (regno < FIRST_PSEUDO_REGISTER\n \t      || (REG_N_SETS (regno) == 1 && ! REG_USERVAR_P (dest)))\n@@ -4925,9 +4931,9 @@ simplify_logical (x, last)\n \t  && GET_CODE (XEXP (op1, 1)) == CONST_INT\n \t  && (INTVAL (XEXP (op0, 1)) + INTVAL (XEXP (op1, 1))\n \t      == GET_MODE_BITSIZE (mode)))\n-\treturn gen_rtx (ROTATE, mode, XEXP (op0, 0),\n-\t\t\t(GET_CODE (op0) == ASHIFT\n-\t\t\t ? XEXP (op0, 1) : XEXP (op1, 1)));\n+\treturn gen_rtx_ROTATE (mode, XEXP (op0, 0),\n+\t\t\t       (GET_CODE (op0) == ASHIFT\n+\t\t\t\t? XEXP (op0, 1) : XEXP (op1, 1)));\n \n       /* If OP0 is (ashiftrt (plus ...) C), it might actually be\n \t a (sign_extend (plus ...)).  If so, OP1 is a CONST_INT, and the PLUS\n@@ -5109,7 +5115,7 @@ expand_compound_operation (x)\n \t with a (use (mem ...)) construct that only combine understands\n \t and is used only for this purpose.  */\n       if (len + pos > GET_MODE_BITSIZE (GET_MODE (XEXP (x, 0))))\n-\tSUBST (XEXP (x, 0), gen_rtx (USE, GET_MODE (x), XEXP (x, 0)));\n+\tSUBST (XEXP (x, 0), gen_rtx_USE (GET_MODE (x), XEXP (x, 0)));\n \n       if (BITS_BIG_ENDIAN)\n \tpos = GET_MODE_BITSIZE (GET_MODE (XEXP (x, 0))) - len - pos;\n@@ -5185,7 +5191,7 @@ expand_compound_operation (x)\n \t\t\t    >> 1))\n \t\t      == 0))))\n \t{\n-\t  rtx temp = gen_rtx (SIGN_EXTEND, GET_MODE (x), XEXP (x, 0));\n+\t  rtx temp = gen_rtx_SIGN_EXTEND (GET_MODE (x), XEXP (x, 0));\n \n \t  if (rtx_cost (temp, SET) < rtx_cost (x, SET))\n \t    return expand_compound_operation (temp);\n@@ -5275,7 +5281,7 @@ expand_field_assignment (x)\n \t     surround INNER  with a USE to indicate this.  */\n \t  if (GET_CODE (pos) == CONST_INT\n \t      && INTVAL (pos) + len > GET_MODE_BITSIZE (GET_MODE (inner)))\n-\t    inner = gen_rtx (USE, GET_MODE (SET_DEST (x)), inner);\n+\t    inner = gen_rtx_USE (GET_MODE (SET_DEST (x)), inner);\n \n \t  if (BITS_BIG_ENDIAN)\n \t    {\n@@ -5304,9 +5310,9 @@ expand_field_assignment (x)\n \t\t   == ((GET_MODE_SIZE (GET_MODE (SUBREG_REG (SET_DEST (x))))\n \t\t\t+ (UNITS_PER_WORD - 1)) / UNITS_PER_WORD)))\n \t{\n-\t  x = gen_rtx (SET, VOIDmode, SUBREG_REG (SET_DEST (x)),\n-\t\t       gen_lowpart_for_combine (GET_MODE (SUBREG_REG (SET_DEST (x))),\n-\t\t\t\t\t\tSET_SRC (x)));\n+\t  x = gen_rtx_SET (VOIDmode, SUBREG_REG (SET_DEST (x)),\n+\t\t\t   gen_lowpart_for_combine (GET_MODE (SUBREG_REG (SET_DEST (x))),\n+\t\t\t\t\t\t    SET_SRC (x)));\n \t  continue;\n \t}\n       else\n@@ -5326,22 +5332,22 @@ expand_field_assignment (x)\n       /* Now compute the equivalent expression.  Make a copy of INNER\n \t for the SET_DEST in case it is a MEM into which we will substitute;\n \t we don't want shared RTL in that case.  */\n-      x = gen_rtx (SET, VOIDmode, copy_rtx (inner),\n-\t\t   gen_binary (IOR, compute_mode,\n-\t\t\t       gen_binary (AND, compute_mode,\n-\t\t\t\t\t   gen_unary (NOT, compute_mode,\n-\t\t\t\t\t\t      compute_mode,\n-\t\t\t\t\t\t      gen_binary (ASHIFT,\n-\t\t\t\t\t\t\t\t  compute_mode,\n-\t\t\t\t\t\t\t\t  mask, pos)),\n-\t\t\t\t\t   inner),\n-\t\t\t       gen_binary (ASHIFT, compute_mode,\n-\t\t\t\t\t   gen_binary (AND, compute_mode,\n-\t\t\t\t\t\t       gen_lowpart_for_combine\n-\t\t\t\t\t\t       (compute_mode,\n-\t\t\t\t\t\t\tSET_SRC (x)),\n-\t\t\t\t\t\t       mask),\n-\t\t\t\t\t   pos)));\n+      x = gen_rtx_SET (VOIDmode, copy_rtx (inner),\n+\t\t       gen_binary (IOR, compute_mode,\n+\t\t\t\t   gen_binary (AND, compute_mode,\n+\t\t\t\t\t       gen_unary (NOT, compute_mode,\n+\t\t\t\t\t\t\t  compute_mode,\n+\t\t\t\t\t\t\t  gen_binary (ASHIFT,\n+\t\t\t\t\t\t\t\t      compute_mode,\n+\t\t\t\t\t\t\t\t      mask, pos)),\n+\t\t\t\t\t       inner),\n+\t\t\t\t   gen_binary (ASHIFT, compute_mode,\n+\t\t\t\t\t       gen_binary (AND, compute_mode,\n+\t\t\t\t\t\t\t   gen_lowpart_for_combine\n+\t\t\t\t\t\t\t   (compute_mode,\n+\t\t\t\t\t\t\t    SET_SRC (x)),\n+\t\t\t\t\t\t\t   mask),\n+\t\t\t\t\t       pos)));\n     }\n \n   return x;\n@@ -5471,7 +5477,7 @@ make_extraction (mode, inner, pos, pos_rtx, len,\n \t  else\n \t    offset = pos / BITS_PER_UNIT;\n \n-\t  new = gen_rtx (MEM, tmode, plus_constant (XEXP (inner, 0), offset));\n+\t  new = gen_rtx_MEM (tmode, plus_constant (XEXP (inner, 0), offset));\n \t  RTX_UNCHANGING_P (new) = RTX_UNCHANGING_P (inner);\n \t  MEM_VOLATILE_P (new) = MEM_VOLATILE_P (inner);\n \t  MEM_IN_STRUCT_P (new) = MEM_IN_STRUCT_P (inner);\n@@ -5481,14 +5487,14 @@ make_extraction (mode, inner, pos, pos_rtx, len,\n \t  /* We can't call gen_lowpart_for_combine here since we always want\n \t     a SUBREG and it would sometimes return a new hard register.  */\n \t  if (tmode != inner_mode)\n-\t    new = gen_rtx (SUBREG, tmode, inner,\n-\t\t\t   (WORDS_BIG_ENDIAN\n-\t\t\t    && GET_MODE_SIZE (inner_mode) > UNITS_PER_WORD\n-\t\t\t    ? (((GET_MODE_SIZE (inner_mode)\n-\t\t\t\t - GET_MODE_SIZE (tmode))\n-\t\t\t\t/ UNITS_PER_WORD)\n-\t\t\t       - pos / BITS_PER_WORD)\n-\t\t\t    : pos / BITS_PER_WORD));\n+\t    new = gen_rtx_SUBREG (tmode, inner,\n+\t\t\t\t  (WORDS_BIG_ENDIAN\n+\t\t\t\t   && GET_MODE_SIZE (inner_mode) > UNITS_PER_WORD\n+\t\t\t\t   ? (((GET_MODE_SIZE (inner_mode)\n+\t\t\t\t\t- GET_MODE_SIZE (tmode))\n+\t\t\t\t       / UNITS_PER_WORD)\n+\t\t\t\t      - pos / BITS_PER_WORD)\n+\t\t\t\t   : pos / BITS_PER_WORD));\n \t  else\n \t    new = inner;\n \t}\n@@ -5505,7 +5511,7 @@ make_extraction (mode, inner, pos, pos_rtx, len,\n       if (in_dest)\n \treturn (GET_CODE (new) == MEM ? new\n \t\t: (GET_CODE (new) != SUBREG\n-\t\t   ? gen_rtx (CLOBBER, tmode, const0_rtx)\n+\t\t   ? gen_rtx_CLOBBER (tmode, const0_rtx)\n \t\t   : gen_rtx_combine (STRICT_LOW_PART, VOIDmode, new)));\n \n       /* Otherwise, sign- or zero-extend unless we already are in the\n@@ -5645,8 +5651,8 @@ make_extraction (mode, inner, pos, pos_rtx, len,\n \n       if (offset != 0 || inner_mode != wanted_inner_mode)\n \t{\n-\t  rtx newmem = gen_rtx (MEM, wanted_inner_mode,\n-\t\t\t\tplus_constant (XEXP (inner, 0), offset));\n+\t  rtx newmem = gen_rtx_MEM (wanted_inner_mode,\n+\t\t\t\t    plus_constant (XEXP (inner, 0), offset));\n \t  RTX_UNCHANGING_P (newmem) = RTX_UNCHANGING_P (inner);\n \t  MEM_VOLATILE_P (newmem) = MEM_VOLATILE_P (inner);\n \t  MEM_IN_STRUCT_P (newmem) = MEM_IN_STRUCT_P (inner);\n@@ -5845,10 +5851,10 @@ make_compound_operation (x, in_code)\n \t{\n \t  /* Apply the distributive law, and then try to make extractions.  */\n \t  new = gen_rtx_combine (GET_CODE (XEXP (x, 0)), mode,\n-\t\t\t\t gen_rtx (AND, mode, XEXP (XEXP (x, 0), 0),\n-\t\t\t\t\t  XEXP (x, 1)),\n-\t\t\t\t gen_rtx (AND, mode, XEXP (XEXP (x, 0), 1),\n-\t\t\t\t\t  XEXP (x, 1)));\n+\t\t\t\t gen_rtx_AND (mode, XEXP (XEXP (x, 0), 0),\n+\t\t\t\t\t      XEXP (x, 1)),\n+\t\t\t\t gen_rtx_AND (mode, XEXP (XEXP (x, 0), 1),\n+\t\t\t\t\t      XEXP (x, 1)));\n \t  new = make_compound_operation (new, in_code);\n \t}\n \n@@ -6920,7 +6926,7 @@ make_field_assignment (x)\n       assign = make_extraction (VOIDmode, dest, 0, XEXP (XEXP (src, 0), 1),\n \t\t\t\t1, 1, 1, 0);\n       if (assign != 0)\n-\treturn gen_rtx (SET, VOIDmode, assign, const0_rtx);\n+\treturn gen_rtx_SET (VOIDmode, assign, const0_rtx);\n       return x;\n     }\n \n@@ -6936,7 +6942,7 @@ make_field_assignment (x)\n \t\t\t\tXEXP (SUBREG_REG (XEXP (src, 0)), 1),\n \t\t\t\t1, 1, 1, 0);\n       if (assign != 0)\n-\treturn gen_rtx (SET, VOIDmode, assign, const0_rtx);\n+\treturn gen_rtx_SET (VOIDmode, assign, const0_rtx);\n       return x;\n     }\n \n@@ -6949,7 +6955,7 @@ make_field_assignment (x)\n       assign = make_extraction (VOIDmode, dest, 0, XEXP (XEXP (src, 0), 1),\n \t\t\t\t1, 1, 1, 0);\n       if (assign != 0)\n-\treturn gen_rtx (SET, VOIDmode, assign, const1_rtx);\n+\treturn gen_rtx_SET (VOIDmode, assign, const1_rtx);\n       return x;\n     }\n \n@@ -8169,7 +8175,7 @@ simplify_shift_const (x, code, result_mode, varop, count)\n       if (x)\n \treturn x;\n \n-      return gen_rtx (code, mode, varop, GEN_INT (count));\n+      return gen_rtx_fmt_ee (code, mode, varop, GEN_INT (count));\n     }\n \n   /* Unless one of the branches of the `if' in this loop does a `continue',\n@@ -8287,11 +8293,11 @@ simplify_shift_const (x, code, result_mode, varop, count)\n \t\t\t\t\t MODE_INT, 1)) != BLKmode)\n \t    {\n \t      if (BYTES_BIG_ENDIAN)\n-\t\tnew = gen_rtx (MEM, tmode, XEXP (varop, 0));\n+\t\tnew = gen_rtx_MEM (tmode, XEXP (varop, 0));\n \t      else\n-\t\tnew = gen_rtx (MEM, tmode,\n-\t\t\t       plus_constant (XEXP (varop, 0),\n-\t\t\t\t\t      count / BITS_PER_UNIT));\n+\t\tnew = gen_rtx_MEM (tmode,\n+\t\t\t\t   plus_constant (XEXP (varop, 0),\n+\t\t\t\t\t\t  count / BITS_PER_UNIT));\n \t      RTX_UNCHANGING_P (new) = RTX_UNCHANGING_P (varop);\n \t      MEM_VOLATILE_P (new) = MEM_VOLATILE_P (varop);\n \t      MEM_IN_STRUCT_P (new) = MEM_IN_STRUCT_P (varop);\n@@ -8924,10 +8930,10 @@ recog_for_combine (pnewpat, insn, pnotes, padded_scratches)\n      them.  Then check to make sure that all of them are dead.  */\n   if (num_clobbers_to_add)\n     {\n-      rtx newpat = gen_rtx (PARALLEL, VOIDmode,\n-\t\t\t    gen_rtvec (GET_CODE (pat) == PARALLEL\n-\t\t\t\t       ? XVECLEN (pat, 0) + num_clobbers_to_add\n-\t\t\t\t       : num_clobbers_to_add + 1));\n+      rtx newpat = gen_rtx_PARALLEL (VOIDmode,\n+\t\t\t\t     gen_rtvec (GET_CODE (pat) == PARALLEL\n+\t\t\t\t\t\t? XVECLEN (pat, 0) + num_clobbers_to_add\n+\t\t\t\t\t\t: num_clobbers_to_add + 1));\n \n       if (GET_CODE (pat) == PARALLEL)\n \tfor (i = 0; i < XVECLEN (pat, 0); i++)\n@@ -8945,8 +8951,8 @@ recog_for_combine (pnewpat, insn, pnotes, padded_scratches)\n \t    return -1;\n \t  else if (GET_CODE (XEXP (XVECEXP (newpat, 0, i), 0)) == SCRATCH)\n \t    (*padded_scratches)++;\n-\t  notes = gen_rtx (EXPR_LIST, REG_UNUSED,\n-\t\t\t   XEXP (XVECEXP (newpat, 0, i), 0), notes);\n+\t  notes = gen_rtx_EXPR_LIST (REG_UNUSED,\n+\t\t\t\t     XEXP (XVECEXP (newpat, 0, i), 0), notes);\n \t}\n       pat = newpat;\n     }\n@@ -8986,7 +8992,7 @@ gen_lowpart_for_combine (mode, x)\n \t     && (GET_CODE (x) == CONST_INT\n \t\t || GET_CODE (x) == CONST_DOUBLE))\n \t    || GET_MODE_SIZE (GET_MODE (x)) == GET_MODE_SIZE (mode)))\n-    return gen_rtx (CLOBBER, GET_MODE (x), const0_rtx);\n+    return gen_rtx_CLOBBER (GET_MODE (x), const0_rtx);\n \n   /* X might be a paradoxical (subreg (mem)).  In that case, gen_lowpart\n      won't know what to do.  So we will strip off the SUBREG here and\n@@ -9018,13 +9024,13 @@ gen_lowpart_for_combine (mode, x)\n       /* Refuse to work on a volatile memory ref or one with a mode-dependent\n \t address.  */\n       if (MEM_VOLATILE_P (x) || mode_dependent_address_p (XEXP (x, 0)))\n-\treturn gen_rtx (CLOBBER, GET_MODE (x), const0_rtx);\n+\treturn gen_rtx_CLOBBER (GET_MODE (x), const0_rtx);\n \n       /* If we want to refer to something bigger than the original memref,\n \t generate a perverse subreg instead.  That will force a reload\n \t of the original memref X.  */\n       if (GET_MODE_SIZE (GET_MODE (x)) < GET_MODE_SIZE (mode))\n-\treturn gen_rtx (SUBREG, mode, x, 0);\n+\treturn gen_rtx_SUBREG (mode, x, 0);\n \n       if (WORDS_BIG_ENDIAN)\n \toffset = (MAX (GET_MODE_SIZE (GET_MODE (x)), UNITS_PER_WORD)\n@@ -9036,7 +9042,7 @@ gen_lowpart_for_combine (mode, x)\n \t  offset -= (MIN (UNITS_PER_WORD, GET_MODE_SIZE (mode))\n \t\t     - MIN (UNITS_PER_WORD, GET_MODE_SIZE (GET_MODE (x))));\n \t}\n-      new = gen_rtx (MEM, mode, plus_constant (XEXP (x, 0), offset));\n+      new = gen_rtx_MEM (mode, plus_constant (XEXP (x, 0), offset));\n       RTX_UNCHANGING_P (new) = RTX_UNCHANGING_P (x);\n       MEM_VOLATILE_P (new) = MEM_VOLATILE_P (x);\n       MEM_IN_STRUCT_P (new) = MEM_IN_STRUCT_P (x);\n@@ -9059,7 +9065,7 @@ gen_lowpart_for_combine (mode, x)\n \tword = ((GET_MODE_SIZE (GET_MODE (x))\n \t\t - MAX (GET_MODE_SIZE (mode), UNITS_PER_WORD))\n \t\t/ UNITS_PER_WORD);\n-      return gen_rtx (SUBREG, mode, x, word);\n+      return gen_rtx_SUBREG (mode, x, word);\n     }\n }\n \f\n@@ -10495,7 +10501,7 @@ get_last_value_validate (loc, insn, tick, replace)\n \t\t&& reg_last_set_label[j] > tick))\n \t  {\n \t    if (replace)\n-\t      *loc = gen_rtx (CLOBBER, GET_MODE (x), const0_rtx);\n+\t      *loc = gen_rtx_CLOBBER (GET_MODE (x), const0_rtx);\n \t    return replace;\n \t  }\n \n@@ -10508,7 +10514,7 @@ get_last_value_validate (loc, insn, tick, replace)\n \t   && INSN_CUID (insn) <= mem_last_set)\n     {\n       if (replace)\n-\t*loc = gen_rtx (CLOBBER, GET_MODE (x), const0_rtx);\n+\t*loc = gen_rtx_CLOBBER (GET_MODE (x), const0_rtx);\n       return replace;\n     }\n \n@@ -10601,7 +10607,7 @@ get_last_value (x)\n \n \t  if (reg_mentioned_p (x, value))\n \t    value = replace_rtx (copy_rtx (value), x,\n-\t\t\t\t gen_rtx (CLOBBER, GET_MODE (x), const0_rtx));\n+\t\t\t\t gen_rtx_CLOBBER (GET_MODE (x), const0_rtx));\n \n \t  if (reg_overlap_mentioned_p (x, value))\n \t    return 0;\n@@ -10968,9 +10974,9 @@ move_deaths (x, maybe_kill_insn, from_cuid, to_insn, pnotes)\n \t      for (i = deadregno; i < deadend; i++)\n \t\tif (i < regno || i >= ourend)\n \t\t  REG_NOTES (where_dead)\n-\t\t    = gen_rtx (EXPR_LIST, REG_DEAD,\n-\t\t\t       gen_rtx (REG, reg_raw_mode[i], i),\n-\t\t\t       REG_NOTES (where_dead));\n+\t\t    = gen_rtx_EXPR_LIST (REG_DEAD,\n+\t\t\t\t\t gen_rtx_REG (reg_raw_mode[i], i),\n+\t\t\t\t\t REG_NOTES (where_dead));\n \t    }\n \t  /* If we didn't find any note, or if we found a REG_DEAD note that\n \t     covers only part of the given reg, and we have a multi-reg hard\n@@ -10994,7 +11000,7 @@ move_deaths (x, maybe_kill_insn, from_cuid, to_insn, pnotes)\n \t\toffset = 1;\n \n \t      for (i = regno + offset; i < ourend; i++)\n-\t\tmove_deaths (gen_rtx (REG, reg_raw_mode[i], i),\n+\t\tmove_deaths (gen_rtx_REG (reg_raw_mode[i], i),\n \t\t\t     maybe_kill_insn, from_cuid, to_insn, &oldnotes);\n \t    }\n \n@@ -11004,7 +11010,7 @@ move_deaths (x, maybe_kill_insn, from_cuid, to_insn, pnotes)\n \t      *pnotes = note;\n \t    }\n \t  else\n-\t    *pnotes = gen_rtx (EXPR_LIST, REG_DEAD, x, *pnotes);\n+\t    *pnotes = gen_rtx_EXPR_LIST (REG_DEAD, x, *pnotes);\n \n \t  REG_N_DEATHS (regno)++;\n \t}\n@@ -11393,7 +11399,7 @@ distribute_notes (notes, from_insn, i3, i2, elim_i2, elim_i1)\n \t      if (REG_NOTE_KIND (note) == REG_DEAD && place == 0 && tem != 0)\n \t\t{\n \t\t  place\n-\t\t    = emit_insn_after (gen_rtx (USE, VOIDmode, XEXP (note, 0)),\n+\t\t    = emit_insn_after (gen_rtx_USE (VOIDmode, XEXP (note, 0)),\n \t\t\t\t       tem);\n \n \t\t  /* If this insn was emitted between blocks, then update\n@@ -11452,7 +11458,7 @@ distribute_notes (notes, from_insn, i3, i2, elim_i2, elim_i1)\n \t\t    if (! refers_to_regno_p (i, i + 1, PATTERN (place), 0)\n \t\t\t&& ! find_regno_fusage (place, USE, i))\n \t\t      {\n-\t\t\trtx piece = gen_rtx (REG, reg_raw_mode[i], i);\n+\t\t\trtx piece = gen_rtx_REG (reg_raw_mode[i], i);\n \t\t\trtx p;\n \n \t\t\t/* See if we already placed a USE note for this\n@@ -11471,12 +11477,12 @@ distribute_notes (notes, from_insn, i3, i2, elim_i2, elim_i1)\n \t\t\tif (p)\n \t\t\t  {\n \t\t\t    rtx use_insn\n-\t\t\t      = emit_insn_before (gen_rtx (USE, VOIDmode,\n-\t\t\t\t\t\t\t   piece),\n+\t\t\t      = emit_insn_before (gen_rtx_USE (VOIDmode,\n+\t\t\t\t\t\t\t       piece),\n \t\t\t\t\t\t  p);\n \t\t\t    REG_NOTES (use_insn)\n-\t\t\t      = gen_rtx (EXPR_LIST, REG_DEAD, piece,\n-\t\t\t\t\t REG_NOTES (use_insn));\n+\t\t\t      = gen_rtx_EXPR_LIST (REG_DEAD, piece,\n+\t\t\t\t\t\t   REG_NOTES (use_insn));\n \t\t\t  }\n \n \t\t\tall_used = 0;\n@@ -11499,17 +11505,17 @@ distribute_notes (notes, from_insn, i3, i2, elim_i2, elim_i1)\n \n \t\t      for (i = regno; i < endregno; i++)\n \t\t\t{\n-\t\t\t  rtx piece = gen_rtx (REG, reg_raw_mode[i], i);\n+\t\t\t  rtx piece = gen_rtx_REG (reg_raw_mode[i], i);\n \n \t\t\t  if ((reg_referenced_p (piece, PATTERN (place))\n \t\t\t       || (GET_CODE (place) == CALL_INSN\n \t\t\t\t   && find_reg_fusage (place, USE, piece)))\n \t\t\t      && ! dead_or_set_p (place, piece)\n \t\t\t      && ! reg_bitfield_target_p (piece,\n \t\t\t\t\t\t\t  PATTERN (place)))\n-\t\t\t    REG_NOTES (place) = gen_rtx (EXPR_LIST, REG_DEAD,\n-\t\t\t\t\t\t\t piece,\n-\t\t\t\t\t\t\t REG_NOTES (place));\n+\t\t\t    REG_NOTES (place)\n+\t\t\t      = gen_rtx_EXPR_LIST (REG_DEAD,\n+\t\t\t\t\t\t   piece, REG_NOTES (place));\n \t\t\t}\n \n \t\t      place = 0;\n@@ -11541,8 +11547,10 @@ distribute_notes (notes, from_insn, i3, i2, elim_i2, elim_i1)\n \t      && GET_CODE (XEXP (note, 0)) == REG)\n \t    REG_N_DEATHS (REGNO (XEXP (note, 0)))++;\n \n-\t  REG_NOTES (place2) = gen_rtx (GET_CODE (note), REG_NOTE_KIND (note),\n-\t\t\t\t\tXEXP (note, 0), REG_NOTES (place2));\n+\t  REG_NOTES (place2) = gen_rtx_fmt_ee (GET_CODE (note),\n+\t\t\t\t\t       REG_NOTE_KIND (note),\n+\t\t\t\t\t       XEXP (note, 0),\n+\t\t\t\t\t       REG_NOTES (place2));\n \t}\n     }\n }"}, {"sha": "f418ea111360838e2dbca24b628256596484ab51", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 45, "deletions": 41, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38a448ca5dfe60244ab3c1f0ea8e3604ec69370b/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38a448ca5dfe60244ab3c1f0ea8e3604ec69370b/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=38a448ca5dfe60244ab3c1f0ea8e3604ec69370b", "patch": "@@ -832,7 +832,7 @@ get_aligned_mem (ref, paligned_mem, pbitnum)\n   if (GET_CODE (base) == PLUS)\n     offset += INTVAL (XEXP (base, 1)), base = XEXP (base, 0);\n \n-  *paligned_mem = gen_rtx (MEM, SImode,\n+  *paligned_mem = gen_rtx_MEM (SImode,\n \t\t\t   plus_constant (base, offset & ~3));\n   MEM_IN_STRUCT_P (*paligned_mem) = MEM_IN_STRUCT_P (ref);\n   MEM_VOLATILE_P (*paligned_mem) = MEM_VOLATILE_P (ref);\n@@ -1025,7 +1025,7 @@ alpha_emit_set_const_1 (target, mode, c, n)\n \n \t  if (target == NULL)\n \t    target = gen_reg_rtx (mode);\n-\t  emit_insn (gen_rtx (SET, VOIDmode, target, GEN_INT (c)));\n+\t  emit_insn (gen_rtx_SET (VOIDmode, target, GEN_INT (c)));\n \t  return target;\n \t}\n       else if (n >= 2 + (extra != 0))\n@@ -1234,7 +1234,7 @@ alpha_emit_conditional_move (cmp, mode)\n      This avoids emitting spurious compares. */\n   if (signed_comparison_operator (cmp, cmp_op_mode)\n       && (op0 == CONST0_RTX (cmp_mode) || op1 == CONST0_RTX (cmp_mode)))\n-    return gen_rtx (code, VOIDmode, op0, op1);\n+    return gen_rtx_fmt_ee (code, VOIDmode, op0, op1);\n \n   /* We can't put the comparison insides a conditional move;\n      emit a compare instruction and put that inside the\n@@ -1266,8 +1266,8 @@ alpha_emit_conditional_move (cmp, mode)\n     }\n \n   tem = gen_reg_rtx (cmp_op_mode);\n-  emit_move_insn (tem, gen_rtx (code, cmp_op_mode, op0, op1));\n-  return gen_rtx (cmov_code, VOIDmode, tem, CONST0_RTX (cmp_op_mode));\n+  emit_move_insn (tem, gen_rtx_fmt_ee (code, cmp_op_mode, op0, op1));\n+  return gen_rtx_fmt_ee (cmov_code, VOIDmode, tem, CONST0_RTX (cmp_op_mode));\n }\n \f\n /* Use ext[wlq][lh] as the Architecture Handbook describes for extracting\n@@ -1313,16 +1313,17 @@ alpha_expand_unaligned_load (tgt, mem, size, ofs, sign)\n \n   emit_move_insn (meml,\n \t\t  change_address (mem, DImode,\n-\t\t\t\t  gen_rtx (AND, DImode, \n-\t\t\t\t\t   plus_constant (XEXP (mem, 0), ofs),\n-\t\t\t\t\t   GEN_INT (-8))));\n+\t\t\t\t  gen_rtx_AND (DImode, \n+\t\t\t\t\t       plus_constant (XEXP (mem, 0),\n+\t\t\t\t\t\t\t      ofs),\n+\t\t\t\t\t       GEN_INT (-8))));\n \n   emit_move_insn (memh,\n \t\t  change_address (mem, DImode,\n-\t\t\t\t  gen_rtx (AND, DImode, \n-\t\t\t\t\t   plus_constant (XEXP (mem, 0),\n-\t\t\t\t\t\t\t  ofs + size - 1),\n-\t\t\t\t\t   GEN_INT (-8))));\n+\t\t\t\t  gen_rtx_AND (DImode, \n+\t\t\t\t\t       plus_constant (XEXP (mem, 0),\n+\t\t\t\t\t\t\t      ofs + size - 1),\n+\t\t\t\t\t       GEN_INT (-8))));\n \n   if (sign && size == 2)\n     {\n@@ -1373,13 +1374,14 @@ alpha_expand_unaligned_store (dst, src, size, ofs)\n   insh = gen_reg_rtx (DImode);\n \n   meml = change_address (dst, DImode,\n-\t\t\t gen_rtx (AND, DImode, \n-\t\t\t\t  plus_constant (XEXP (dst, 0), ofs),\n-\t\t\t\t  GEN_INT (-8)));\n+\t\t\t gen_rtx_AND (DImode, \n+\t\t\t\t      plus_constant (XEXP (dst, 0), ofs),\n+\t\t\t\t      GEN_INT (-8)));\n   memh = change_address (dst, DImode,\n-\t\t\t gen_rtx (AND, DImode, \n-\t\t\t\t  plus_constant (XEXP (dst, 0), ofs+size-1),\n-\t\t\t\t  GEN_INT (-8)));\n+\t\t\t gen_rtx_AND (DImode, \n+\t\t\t\t      plus_constant (XEXP (dst, 0),\n+\t\t\t\t\t\t     ofs+size-1),\n+\t\t\t\t      GEN_INT (-8)));\n \n   emit_move_insn (dsth, memh);\n   emit_move_insn (dstl, meml);\n@@ -1461,17 +1463,17 @@ alpha_expand_unaligned_load_words (data_regs, src_addr, words)\n     {\n       emit_move_insn (data_regs[i],\n \t\t      change_address (src_addr, DImode,\n-\t\t\t\t      gen_rtx (AND, DImode,\n-\t\t\t\t\t       plus_constant (XEXP(src_addr,0),\n-\t\t\t\t\t\t\t      8*i),\n-\t\t\t\t\t       im8)));\n+\t\t\t\t      gen_rtx_AND (DImode,\n+\t\t\t\t\t\t   plus_constant (XEXP(src_addr,0),\n+\t\t\t\t\t\t\t\t  8*i),\n+\t\t\t\t\t\t   im8)));\n     }\n   emit_move_insn (data_regs[words],\n \t\t  change_address (src_addr, DImode,\n-\t\t\t\t  gen_rtx (AND, DImode,\n-\t\t\t\t\t   plus_constant (XEXP(src_addr,0),\n-\t\t\t\t\t\t\t  8*words - 1),\n-\t\t\t\t\t   im8)));\n+\t\t\t\t  gen_rtx_AND (DImode,\n+\t\t\t\t\t       plus_constant (XEXP(src_addr,0),\n+\t\t\t\t\t\t\t      8*words - 1),\n+\t\t\t\t\t       im8)));\n \n   /* Extract the half-word fragments.  Unfortunately DEC decided to make\n      extxh with offset zero a noop instead of zeroing the register, so \n@@ -1485,10 +1487,10 @@ alpha_expand_unaligned_load_words (data_regs, src_addr, words)\n       emit_insn (gen_extxl (data_regs[i], data_regs[i], i64, src_reg));\n \n       emit_insn (gen_extqh (ext_tmps[i], data_regs[i+1], src_reg));\n-      emit_insn (gen_rtx (SET, VOIDmode, ext_tmps[i],\n-\t\t\t  gen_rtx (IF_THEN_ELSE, DImode,\n-\t\t\t\t   gen_rtx (EQ, DImode, and_reg, const0_rtx),\n-\t\t\t\t   const0_rtx, ext_tmps[i])));\n+      emit_insn (gen_rtx_SET (VOIDmode, ext_tmps[i],\n+\t\t\t      gen_rtx_IF_THEN_ELSE (DImode,\n+\t\t\t\t\t\t    gen_rtx_EQ (DImode, and_reg, const0_rtx),\n+\t\t\t\t\t\t    const0_rtx, ext_tmps[i])));\n     }\n \n   /* Merge the half-words into whole words.  */\n@@ -1528,14 +1530,14 @@ alpha_expand_unaligned_store_words (data_regs, dst_addr, words)\n   st_tmp_2 = gen_reg_rtx(DImode);\n   \n   st_addr_2 = change_address (dst_addr, DImode,\n-\t\t\t      gen_rtx (AND, DImode,\n-\t\t\t\t       plus_constant (XEXP(dst_addr,0),\n-\t\t\t\t\t\t      words*8 - 1),\n+\t\t\t      gen_rtx_AND (DImode,\n+\t\t\t\t\t   plus_constant (XEXP(dst_addr,0),\n+\t\t\t\t\t\t\t  words*8 - 1),\n \t\t\t\t       im8));\n   st_addr_1 = change_address (dst_addr, DImode,\n-\t\t\t      gen_rtx (AND, DImode, \n-\t\t\t\t       XEXP (dst_addr, 0),\n-\t\t\t\t       im8));\n+\t\t\t      gen_rtx_AND (DImode, \n+\t\t\t\t\t   XEXP (dst_addr, 0),\n+\t\t\t\t\t   im8));\n \n   /* Load up the destination end bits.  */\n   emit_move_insn (st_tmp_2, st_addr_2);\n@@ -1576,9 +1578,9 @@ alpha_expand_unaligned_store_words (data_regs, dst_addr, words)\n   for (i = words-1; i > 0; --i)\n     {\n       emit_move_insn (change_address (dst_addr, DImode,\n-\t\t\t\t      gen_rtx (AND, DImode,\n-\t\t\t\t\t       plus_constant(XEXP (dst_addr,0),\n-\t\t\t\t\t\t\t     i*8),\n+\t\t\t\t      gen_rtx_AND (DImode,\n+\t\t\t\t\t\t   plus_constant(XEXP (dst_addr,0),\n+\t\t\t\t\t\t\t\t i*8),\n \t\t\t\t\t       im8)),\n \t\t      data_regs ? ins_tmps[i-1] : const0_rtx);\n     }\n@@ -2058,7 +2060,8 @@ alpha_return_addr (count, frame)\n \n   /* No rtx yet.  Invent one, and initialize it from $26 in the prologue.  */\n   alpha_return_addr_rtx = gen_reg_rtx (Pmode);\n-  init = gen_rtx (SET, Pmode, alpha_return_addr_rtx, gen_rtx (REG, Pmode, 26));\n+  init = gen_rtx_SET (Pmode, alpha_return_addr_rtx,\n+\t\t      gen_rtx_REG (Pmode, REG_RA));\n \n   /* Emit the insn to the prologue with the other argument copies.  */\n   push_topmost_sequence ();\n@@ -2076,7 +2079,8 @@ alpha_ra_ever_killed ()\n   if (!alpha_return_addr_rtx)\n     return regs_ever_live[REG_RA];\n \n-  return reg_set_between_p (gen_rtx (REG, REG_RA), get_insns(), NULL_RTX);\n+  return reg_set_between_p (gen_rtx_REG (Pmode, REG_RA),\n+\t\t\t    get_insns(), NULL_RTX);\n }\n \n \f"}, {"sha": "2e36e058e4fee954aece8ec13a3cd13012539d25", "filename": "gcc/config/alpha/alpha.md", "status": "modified", "additions": 133, "deletions": 134, "changes": 267, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38a448ca5dfe60244ab3c1f0ea8e3604ec69370b/gcc%2Fconfig%2Falpha%2Falpha.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38a448ca5dfe60244ab3c1f0ea8e3604ec69370b/gcc%2Fconfig%2Falpha%2Falpha.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.md?ref=38a448ca5dfe60244ab3c1f0ea8e3604ec69370b", "patch": "@@ -374,10 +374,10 @@\n \t\t (match_operand:SI 2 \"add_operand\" \"\")))]\n   \"\"\n   \"\n-{ emit_insn (gen_rtx (SET, VOIDmode, gen_lowpart (DImode, operands[0]),\n-\t\t      gen_rtx (PLUS, DImode,\n-\t\t\t       gen_lowpart (DImode, operands[1]),\n-\t\t\t       gen_lowpart (DImode, operands[2]))));\n+{ emit_insn (gen_rtx_SET (VOIDmode, gen_lowpart (DImode, operands[0]),\n+\t\t\t  gen_rtx_PLUS (DImode,\n+\t\t\t\t\tgen_lowpart (DImode, operands[1]),\n+\t\t\t\t\tgen_lowpart (DImode, operands[2]))));\n   DONE;\n } \")\n \n@@ -456,8 +456,8 @@\n    (set (match_dup 0) (sign_extend:DI (plus:SI (match_dup 7) (match_dup 4))))]\n   \"\n {\n-  operands[6] = gen_rtx (GET_CODE (operands[1]), DImode,\n-\t\t\t operands[2], operands[3]);\n+  operands[6] = gen_rtx_fmt_ee (GET_CODE (operands[1]), DImode,\n+\t\t\t\toperands[2], operands[3]);\n   operands[7] = gen_lowpart (SImode, operands[5]);\n }\")\n \n@@ -529,8 +529,8 @@\n \t\t\t\t (match_dup 5))))]\n   \"\n {\n-  operands[7] = gen_rtx (GET_CODE (operands[1]), DImode,\n-\t\t\t operands[2], operands[3]);\n+  operands[7] = gen_rtx_fmt_ee (GET_CODE (operands[1]), DImode,\n+\t\t\t\toperands[2], operands[3]);\n   operands[8] = gen_lowpart (SImode, operands[6]);\n }\")\n \n@@ -660,12 +660,11 @@\n \t\t  (match_operand:SI 2 \"reg_or_8bit_operand\" \"\")))]\n   \"\"\n   \"\n-{ emit_insn (gen_rtx (SET, VOIDmode, gen_lowpart (DImode, operands[0]),\n-\t\t      gen_rtx (MINUS, DImode,\n-\t\t\t       gen_lowpart (DImode, operands[1]),\n-\t\t\t       gen_lowpart (DImode, operands[2]))));\n+{ emit_insn (gen_rtx_SET (VOIDmode, gen_lowpart (DImode, operands[0]),\n+\t\t\t  gen_rtx_MINUS (DImode,\n+\t\t\t\t\t gen_lowpart (DImode, operands[1]),\n+\t\t\t\t\t gen_lowpart (DImode, operands[2]))));\n   DONE;\n-\n } \")\n \n (define_insn \"\"\n@@ -2801,10 +2800,10 @@\n     }\n \n   operands[1] = gen_reg_rtx (mode);\n-  operands[2] = gen_rtx (compare_code, mode,\n-\t\t\t alpha_compare_op0, alpha_compare_op1);\n-  operands[3] = gen_rtx (branch_code, VOIDmode,\n-\t\t\t operands[1], CONST0_RTX (mode));\n+  operands[2] = gen_rtx_fmt_ee (compare_code, mode,\n+\t\t\t\talpha_compare_op0, alpha_compare_op1);\n+  operands[3] = gen_rtx_fmt_ee (branch_code, VOIDmode,\n+\t\t\t\toperands[1], CONST0_RTX (mode));\n }\")\n \n (define_expand \"bne\"\n@@ -2839,10 +2838,10 @@\n     }\n \n   operands[1] = gen_reg_rtx (mode);\n-  operands[2] = gen_rtx (compare_code, mode,\n-\t\t\t alpha_compare_op0, alpha_compare_op1);\n-  operands[3] = gen_rtx (branch_code, VOIDmode,\n-\t\t\t operands[1], CONST0_RTX (mode));\n+  operands[2] = gen_rtx_fmt_ee (compare_code, mode,\n+\t\t\t\talpha_compare_op0, alpha_compare_op1);\n+  operands[3] = gen_rtx_fmt_ee (branch_code, VOIDmode,\n+\t\t\t\toperands[1], CONST0_RTX (mode));\n }\")\n \n (define_expand \"blt\"\n@@ -2856,8 +2855,8 @@\n {\n   enum machine_mode mode = alpha_compare_fp_p ? DFmode : DImode;\n   operands[1] = gen_reg_rtx (mode);\n-  operands[2] = gen_rtx (LT, mode, alpha_compare_op0, alpha_compare_op1);\n-  operands[3] = gen_rtx (NE, VOIDmode, operands[1], CONST0_RTX (mode));\n+  operands[2] = gen_rtx_LT (mode, alpha_compare_op0, alpha_compare_op1);\n+  operands[3] = gen_rtx_NE (VOIDmode, operands[1], CONST0_RTX (mode));\n }\")\n \n (define_expand \"ble\"\n@@ -2871,8 +2870,8 @@\n {\n   enum machine_mode mode = alpha_compare_fp_p ? DFmode : DImode;\n   operands[1] = gen_reg_rtx (mode);\n-  operands[2] = gen_rtx (LE, mode, alpha_compare_op0, alpha_compare_op1);\n-  operands[3] = gen_rtx (NE, VOIDmode, operands[1], CONST0_RTX (mode));\n+  operands[2] = gen_rtx_LE (mode, alpha_compare_op0, alpha_compare_op1);\n+  operands[3] = gen_rtx_NE (VOIDmode, operands[1], CONST0_RTX (mode));\n }\")\n \n (define_expand \"bgt\"\n@@ -2887,14 +2886,14 @@\n   if (alpha_compare_fp_p)\n     {\n       operands[1] = gen_reg_rtx (DFmode);\n-      operands[2] = gen_rtx (LT, DFmode, alpha_compare_op1, alpha_compare_op0);\n-      operands[3] = gen_rtx (NE, VOIDmode, operands[1], CONST0_RTX (DFmode));\n+      operands[2] = gen_rtx_LT (DFmode, alpha_compare_op1, alpha_compare_op0);\n+      operands[3] = gen_rtx_NE (VOIDmode, operands[1], CONST0_RTX (DFmode));\n     }\n   else\n     {\n       operands[1] = gen_reg_rtx (DImode);\n-      operands[2] = gen_rtx (LE, DImode, alpha_compare_op0, alpha_compare_op1);\n-      operands[3] = gen_rtx (EQ, VOIDmode, operands[1], const0_rtx);\n+      operands[2] = gen_rtx_LE (DImode, alpha_compare_op0, alpha_compare_op1);\n+      operands[3] = gen_rtx_EQ (VOIDmode, operands[1], const0_rtx);\n     }\n }\")\n \n@@ -2910,14 +2909,14 @@\n   if (alpha_compare_fp_p)\n     {\n       operands[1] = gen_reg_rtx (DFmode);\n-      operands[2] = gen_rtx (LE, DFmode, alpha_compare_op1, alpha_compare_op0);\n-      operands[3] = gen_rtx (NE, VOIDmode, operands[1], CONST0_RTX (DFmode));\n+      operands[2] = gen_rtx_LE (DFmode, alpha_compare_op1, alpha_compare_op0);\n+      operands[3] = gen_rtx_NE (VOIDmode, operands[1], CONST0_RTX (DFmode));\n     }\n   else\n     {\n       operands[1] = gen_reg_rtx (DImode);\n-      operands[2] = gen_rtx (LT, DImode, alpha_compare_op0, alpha_compare_op1);\n-      operands[3] = gen_rtx (EQ, VOIDmode, operands[1], const0_rtx);\n+      operands[2] = gen_rtx_LT (DImode, alpha_compare_op0, alpha_compare_op1);\n+      operands[3] = gen_rtx_EQ (VOIDmode, operands[1], const0_rtx);\n     }\n }\")\n \n@@ -2931,8 +2930,8 @@\n   \"\n {\n   operands[1] = gen_reg_rtx (DImode);\n-  operands[2] = gen_rtx (LTU, DImode, alpha_compare_op0, alpha_compare_op1);\n-  operands[3] = gen_rtx (NE, VOIDmode, operands[1], const0_rtx);\n+  operands[2] = gen_rtx_LTU (DImode, alpha_compare_op0, alpha_compare_op1);\n+  operands[3] = gen_rtx_NE (VOIDmode, operands[1], const0_rtx);\n }\")\n \n (define_expand \"bleu\"\n@@ -2945,8 +2944,8 @@\n   \"\n {\n   operands[1] = gen_reg_rtx (DImode);\n-  operands[2] = gen_rtx (LEU, DImode, alpha_compare_op0, alpha_compare_op1);\n-  operands[3] = gen_rtx (NE, VOIDmode, operands[1], const0_rtx);\n+  operands[2] = gen_rtx_LEU (DImode, alpha_compare_op0, alpha_compare_op1);\n+  operands[3] = gen_rtx_NE (VOIDmode, operands[1], const0_rtx);\n }\")\n \n (define_expand \"bgtu\"\n@@ -2959,8 +2958,8 @@\n   \"\n {\n   operands[1] = gen_reg_rtx (DImode);\n-  operands[2] = gen_rtx (LEU, DImode, alpha_compare_op0, alpha_compare_op1);\n-  operands[3] = gen_rtx (EQ, VOIDmode, operands[1], const0_rtx);\n+  operands[2] = gen_rtx_LEU (DImode, alpha_compare_op0, alpha_compare_op1);\n+  operands[3] = gen_rtx_EQ (VOIDmode, operands[1], const0_rtx);\n }\")\n \n (define_expand \"bgeu\"\n@@ -2973,8 +2972,8 @@\n   \"\n {\n   operands[1] = gen_reg_rtx (DImode);\n-  operands[2] = gen_rtx (LTU, DImode, alpha_compare_op0, alpha_compare_op1);\n-  operands[3] = gen_rtx (EQ, VOIDmode, operands[1], const0_rtx);\n+  operands[2] = gen_rtx_LTU (DImode, alpha_compare_op0, alpha_compare_op1);\n+  operands[3] = gen_rtx_EQ (VOIDmode, operands[1], const0_rtx);\n }\")\n \n (define_expand \"seq\"\n@@ -2986,7 +2985,7 @@\n   if (alpha_compare_fp_p)\n     FAIL;\n \n-  operands[1] = gen_rtx (EQ, DImode, alpha_compare_op0, alpha_compare_op1);\n+  operands[1] = gen_rtx_EQ (DImode, alpha_compare_op0, alpha_compare_op1);\n }\")\n \n (define_expand \"sne\"\n@@ -2999,7 +2998,7 @@\n   if (alpha_compare_fp_p)\n     FAIL;\n \n-  operands[1] = gen_rtx (EQ, DImode, alpha_compare_op0, alpha_compare_op1);\n+  operands[1] = gen_rtx_EQ (DImode, alpha_compare_op0, alpha_compare_op1);\n }\")\n \n (define_expand \"slt\"\n@@ -3011,7 +3010,7 @@\n   if (alpha_compare_fp_p)\n     FAIL;\n \n-  operands[1] = gen_rtx (LT, DImode, alpha_compare_op0, alpha_compare_op1);\n+  operands[1] = gen_rtx_LT (DImode, alpha_compare_op0, alpha_compare_op1);\n }\")\n \n (define_expand \"sle\"\n@@ -3023,7 +3022,7 @@\n   if (alpha_compare_fp_p)\n     FAIL;\n \n-  operands[1] = gen_rtx (LE, DImode, alpha_compare_op0, alpha_compare_op1);\n+  operands[1] = gen_rtx_LE (DImode, alpha_compare_op0, alpha_compare_op1);\n }\")\n \n (define_expand \"sgt\"\n@@ -3035,8 +3034,8 @@\n   if (alpha_compare_fp_p)\n     FAIL;\n \n-  operands[1] = gen_rtx (LT, DImode, force_reg (DImode, alpha_compare_op1),\n-\t\t\t alpha_compare_op0);\n+  operands[1] = gen_rtx_LT (DImode, force_reg (DImode, alpha_compare_op1),\n+\t\t\t    alpha_compare_op0);\n }\")\n \n (define_expand \"sge\"\n@@ -3048,8 +3047,8 @@\n   if (alpha_compare_fp_p)\n     FAIL;\n \n-  operands[1] = gen_rtx (LE, DImode, force_reg (DImode, alpha_compare_op1),\n-\t\t\t alpha_compare_op0);\n+  operands[1] = gen_rtx_LE (DImode, force_reg (DImode, alpha_compare_op1),\n+\t\t\t    alpha_compare_op0);\n }\")\n \n (define_expand \"sltu\"\n@@ -3061,7 +3060,7 @@\n   if (alpha_compare_fp_p)\n     FAIL;\n \n-  operands[1] = gen_rtx (LTU, DImode, alpha_compare_op0, alpha_compare_op1);\n+  operands[1] = gen_rtx_LTU (DImode, alpha_compare_op0, alpha_compare_op1);\n }\")\n \n (define_expand \"sleu\"\n@@ -3073,7 +3072,7 @@\n   if (alpha_compare_fp_p)\n     FAIL;\n \n-  operands[1] = gen_rtx (LEU, DImode, alpha_compare_op0, alpha_compare_op1);\n+  operands[1] = gen_rtx_LEU (DImode, alpha_compare_op0, alpha_compare_op1);\n }\")\n \n (define_expand \"sgtu\"\n@@ -3085,8 +3084,8 @@\n   if (alpha_compare_fp_p)\n     FAIL;\n \n-  operands[1] = gen_rtx (LTU, DImode, force_reg (DImode, alpha_compare_op1),\n-\t\t\t alpha_compare_op0);\n+  operands[1] = gen_rtx_LTU (DImode, force_reg (DImode, alpha_compare_op1),\n+\t\t\t     alpha_compare_op0);\n }\")\n \n (define_expand \"sgeu\"\n@@ -3098,8 +3097,8 @@\n   if (alpha_compare_fp_p)\n     FAIL;\n \n-  operands[1] = gen_rtx (LEU, DImode, force_reg (DImode, alpha_compare_op1),\n-\t\t\t alpha_compare_op0);\n+  operands[1] = gen_rtx_LEU (DImode, force_reg (DImode, alpha_compare_op1),\n+\t\t\t     alpha_compare_op0);\n }\")\n \f\n ;; These are the main define_expand's used to make conditional moves.\n@@ -3204,25 +3203,25 @@\n \t  && extended_count (operands[3], DImode, unsignedp) >= 1))\n     {\n       if (GET_CODE (operands[3]) == CONST_INT)\n-\toperands[7] = gen_rtx (PLUS, DImode, operands[2],\n-\t\t\t       GEN_INT (- INTVAL (operands[3])));\n+\toperands[7] = gen_rtx_PLUS (DImode, operands[2],\n+\t\t\t\t    GEN_INT (- INTVAL (operands[3])));\n       else\n-\toperands[7] = gen_rtx (MINUS, DImode, operands[2], operands[3]);\n+\toperands[7] = gen_rtx_MINUS (DImode, operands[2], operands[3]);\n \n-      operands[8] = gen_rtx (code, VOIDmode, operands[6], const0_rtx);\n+      operands[8] = gen_rtx_fmt_ee (code, VOIDmode, operands[6], const0_rtx);\n     }\n \n   else if (code == EQ || code == LE || code == LT\n \t   || code == LEU || code == LTU)\n     {\n-      operands[7] = gen_rtx (code, DImode, operands[2], operands[3]);\n-      operands[8] = gen_rtx (NE, VOIDmode, operands[6], const0_rtx);\n+      operands[7] = gen_rtx_fmt_ee (code, DImode, operands[2], operands[3]);\n+      operands[8] = gen_rtx_NE (VOIDmode, operands[6], const0_rtx);\n     }\n   else\n     {\n-      operands[7] = gen_rtx (reverse_condition (code), DImode, operands[2],\n-\t\t\t     operands[3]);\n-      operands[8] = gen_rtx (EQ, VOIDmode, operands[6], const0_rtx);\n+      operands[7] = gen_rtx_fmt_ee (reverse_condition (code), DImode,\n+\t\t\t\t    operands[2], operands[3]);\n+      operands[8] = gen_rtx_EQ (VOIDmode, operands[6], const0_rtx);\n     }\n }\")\n \n@@ -3251,14 +3250,14 @@\n     FAIL;\n  \n   if (GET_CODE (operands[3]) == CONST_INT)\n-    tem = gen_rtx (PLUS, SImode, operands[2],\n-\t\t   GEN_INT (- INTVAL (operands[3])));\n+    tem = gen_rtx_PLUS (SImode, operands[2],\n+\t\t\tGEN_INT (- INTVAL (operands[3])));\n   else\n-    tem = gen_rtx (MINUS, SImode, operands[2], operands[3]);\n+    tem = gen_rtx_MINUS (SImode, operands[2], operands[3]);\n \n-  operands[7] = gen_rtx (SIGN_EXTEND, DImode, tem);\n-  operands[8] = gen_rtx (GET_CODE (operands[1]), VOIDmode, operands[6],\n-\t\t\t const0_rtx);\n+  operands[7] = gen_rtx_SIGN_EXTEND (DImode, tem);\n+  operands[8] = gen_rtx_fmt_ee (GET_CODE (operands[1]), VOIDmode,\n+\t\t\t\toperands[6], const0_rtx);\n }\")\n \n (define_split\n@@ -3282,25 +3281,25 @@\n \t  && extended_count (operands[3], DImode, unsignedp) >= 1))\n     {\n       if (GET_CODE (operands[3]) == CONST_INT)\n-\toperands[5] = gen_rtx (PLUS, DImode, operands[2],\n-\t\t\t       GEN_INT (- INTVAL (operands[3])));\n+\toperands[5] = gen_rtx_PLUS (DImode, operands[2],\n+\t\t\t\t    GEN_INT (- INTVAL (operands[3])));\n       else\n-\toperands[5] = gen_rtx (MINUS, DImode, operands[2], operands[3]);\n+\toperands[5] = gen_rtx_MINUS (DImode, operands[2], operands[3]);\n \n-      operands[6] = gen_rtx (code, VOIDmode, operands[4], const0_rtx);\n+      operands[6] = gen_rtx_fmt_ee (code, VOIDmode, operands[4], const0_rtx);\n     }\n \n   else if (code == EQ || code == LE || code == LT\n \t   || code == LEU || code == LTU)\n     {\n-      operands[5] = gen_rtx (code, DImode, operands[2], operands[3]);\n-      operands[6] = gen_rtx (NE, VOIDmode, operands[4], const0_rtx);\n+      operands[5] = gen_rtx_fmt_ee (code, DImode, operands[2], operands[3]);\n+      operands[6] = gen_rtx_NE (VOIDmode, operands[4], const0_rtx);\n     }\n   else\n     {\n-      operands[5] = gen_rtx (reverse_condition (code), DImode, operands[2],\n-\t\t\t     operands[3]);\n-      operands[6] = gen_rtx (EQ, VOIDmode, operands[4], const0_rtx);\n+      operands[5] = gen_rtx_fmt_ee (reverse_condition (code), DImode,\n+\t\t\t\t    operands[2], operands[3]);\n+      operands[6] = gen_rtx_EQ (VOIDmode, operands[4], const0_rtx);\n     }\n }\")\n \n@@ -3321,14 +3320,14 @@\n { rtx tem;\n \n   if (GET_CODE (operands[3]) == CONST_INT)\n-    tem = gen_rtx (PLUS, SImode, operands[2],\n-\t\t   GEN_INT (- INTVAL (operands[3])));\n+    tem = gen_rtx_PLUS (SImode, operands[2],\n+\t\t\tGEN_INT (- INTVAL (operands[3])));\n   else\n-    tem = gen_rtx (MINUS, SImode, operands[2], operands[3]);\n+    tem = gen_rtx_MINUS (SImode, operands[2], operands[3]);\n   \n-  operands[5] = gen_rtx (SIGN_EXTEND, DImode, tem);\n-  operands[6] = gen_rtx (GET_CODE (operands[1]), VOIDmode,\n-\t\t\t operands[4], const0_rtx);\n+  operands[5] = gen_rtx_SIGN_EXTEND (DImode, tem);\n+  operands[6] = gen_rtx_fmt_ee (GET_CODE (operands[1]), VOIDmode,\n+\t\t\t\toperands[4], const0_rtx);\n }\")\n \n ;; We can convert such things as \"a > 0xffff\" to \"t = a & ~ 0xffff; t != 0\".\n@@ -3350,10 +3349,10 @@\n   \"\n {\n   operands[5] = GEN_INT (~ INTVAL (operands[3]));\n-  operands[6] = gen_rtx (((GET_CODE (operands[1]) == GTU\n-\t\t\t   || GET_CODE (operands[1]) == GT)\n-\t\t\t  ? NE : EQ),\n-\t\t\t DImode, operands[4], const0_rtx);\n+  operands[6] = gen_rtx_fmt_ee (((GET_CODE (operands[1]) == GTU\n+\t\t\t\t  || GET_CODE (operands[1]) == GT)\n+\t\t\t\t ? NE : EQ),\n+\t\t\t\tDImode, operands[4], const0_rtx);\n }\")\n \f\n ;; Here are the CALL and unconditional branch insns.  Calls on NT and OSF\n@@ -3391,7 +3390,7 @@\n   if (GET_CODE (operands[0]) != SYMBOL_REF\n       && ! (GET_CODE (operands[0]) == REG && REGNO (operands[0]) == 27))\n     {\n-      rtx tem = gen_rtx (REG, DImode, 27);\n+      rtx tem = gen_rtx_REG (DImode, 27);\n       emit_move_insn (tem, operands[0]);\n       operands[0] = tem;\n     }\n@@ -3434,7 +3433,7 @@\n      indirect call differently.  Load RA and set operands[2] to PV in\n      both cases.  */\n \n-  emit_move_insn (gen_rtx (REG, DImode, 25), operands[1]);\n+  emit_move_insn (gen_rtx_REG (DImode, 25), operands[1]);\n   if (GET_CODE (operands[0]) == SYMBOL_REF)\n     {\n       extern char *savealloc ();\n@@ -3447,17 +3446,17 @@\n       linksym[0] = '$';\n       strcpy (linksym+1, symbol);\n       strcat (linksym, \\\"..lk\\\");\n-      linkage = gen_rtx (SYMBOL_REF, Pmode, linksym);\n+      linkage = gen_rtx_SYMBOL_REF (Pmode, linksym);\n \n-      emit_move_insn (gen_rtx (REG, Pmode, 26), gen_rtx (MEM, Pmode, linkage));\n+      emit_move_insn (gen_rtx_REG (Pmode, 26), gen_rtx_MEM (Pmode, linkage));\n \n       operands[2]\n-\t= validize_mem (gen_rtx (MEM, Pmode, plus_constant (linkage, 8)));\n+\t= validize_mem (gen_rtx_MEM (Pmode, plus_constant (linkage, 8)));\n     }\n   else\n     {\n-      emit_move_insn (gen_rtx (REG, Pmode, 26),\n-\t\t      gen_rtx (MEM, Pmode, plus_constant (operands[0], 8)));\n+      emit_move_insn (gen_rtx_REG (Pmode, 26),\n+\t\t      gen_rtx_MEM (Pmode, plus_constant (operands[0], 8)));\n \n       operands[2] = operands[0];\n     }\n@@ -3499,7 +3498,7 @@\n   if (GET_CODE (operands[1]) != SYMBOL_REF\n       && ! (GET_CODE (operands[1]) == REG && REGNO (operands[1]) == 27))\n     {\n-      rtx tem = gen_rtx (REG, DImode, 27);\n+      rtx tem = gen_rtx_REG (DImode, 27);\n       emit_move_insn (tem, operands[1]);\n       operands[1] = tem;\n     }\n@@ -3539,7 +3538,7 @@\n      indirect call differently.  Load RA and set operands[3] to PV in\n      both cases.  */\n \n-  emit_move_insn (gen_rtx (REG, DImode, 25), operands[2]);\n+  emit_move_insn (gen_rtx_REG (DImode, 25), operands[2]);\n   if (GET_CODE (operands[1]) == SYMBOL_REF)\n     {\n       extern char *savealloc ();\n@@ -3551,17 +3550,17 @@\n       linksym[0] = '$';\n       strcpy (linksym+1, symbol);\n       strcat (linksym, \\\"..lk\\\");\n-      linkage = gen_rtx (SYMBOL_REF, Pmode, linksym);\n+      linkage = gen_rtx_SYMBOL_REF (Pmode, linksym);\n \n-      emit_move_insn (gen_rtx (REG, Pmode, 26), gen_rtx (MEM, Pmode, linkage));\n+      emit_move_insn (gen_rtx_REG (Pmode, 26), gen_rtx_MEM (Pmode, linkage));\n \n       operands[3]\n-\t= validize_mem (gen_rtx (MEM, Pmode, plus_constant (linkage, 8)));\n+\t= validize_mem (gen_rtx_MEM (Pmode, plus_constant (linkage, 8)));\n     }\n   else\n     {\n-      emit_move_insn (gen_rtx (REG, Pmode, 26),\n-\t\t      gen_rtx (MEM, Pmode, plus_constant (operands[1], 8)));\n+      emit_move_insn (gen_rtx_REG (Pmode, 26),\n+\t\t      gen_rtx_MEM (Pmode, plus_constant (operands[1], 8)));\n \n       operands[3] = operands[1];\n     }\n@@ -4442,7 +4441,7 @@\n \t{\n \t  rtx aligned_mem, bitnum;\n \t  rtx scratch = (reload_in_progress\n-\t\t\t ? gen_rtx (REG, SImode, REGNO (operands[0]))\n+\t\t\t ? gen_rtx_REG (SImode, REGNO (operands[0]))\n \t\t\t : gen_reg_rtx (SImode));\n \n \t  /* ??? This code creates a new MEM rtx.  If we were called during\n@@ -4452,7 +4451,7 @@\n \t      && GET_CODE (operands[1]) == MEM\n \t      && ! strict_memory_address_p (SImode, XEXP (operands[1], 0)))\n \t    {\n-\t      rtx tmp = gen_rtx (REG, Pmode, REGNO (operands[0]));\n+\t      rtx tmp = gen_rtx_REG (Pmode, REGNO (operands[0]));\n \t      emit_insn (gen_move_insn (tmp, XEXP (operands[1], 0)));\n \t      XEXP (operands[1], 0) = tmp;\n \t    }\n@@ -4566,7 +4565,7 @@\n \t{\n \t  rtx aligned_mem, bitnum;\n \t  rtx scratch = (reload_in_progress\n-\t\t\t ? gen_rtx (REG, SImode, REGNO (operands[0]))\n+\t\t\t ? gen_rtx_REG (SImode, REGNO (operands[0]))\n \t\t\t : gen_reg_rtx (SImode));\n \n \t  /* ??? This code creates a new MEM rtx.  If we were called during\n@@ -4576,7 +4575,7 @@\n \t      && GET_CODE (operands[1]) == MEM\n \t      && ! strict_memory_address_p (SImode, XEXP (operands[1], 0)))\n \t    {\n-\t      rtx tmp = gen_rtx (REG, Pmode, REGNO (operands[0]));\n+\t      rtx tmp = gen_rtx_REG (Pmode, REGNO (operands[0]));\n \t      emit_insn (gen_move_insn (tmp, XEXP (operands[1], 0)));\n \t      XEXP (operands[1], 0) = tmp;\n \t    }\n@@ -4660,22 +4659,22 @@\n   /* It is possible that one of the registers we got for operands[2]\n      might coincide with that of operands[0] (which is why we made\n      it TImode).  Pick the other one to use as our scratch.  */\n-  scratch = gen_rtx (REG, DImode,\n-\t\t     REGNO (operands[0]) == REGNO (operands[2]) \n-\t\t     ? REGNO (operands[2]) + 1 : REGNO (operands[2]));\n+  scratch = gen_rtx_REG (DImode,\n+\t\t\t REGNO (operands[0]) == REGNO (operands[2]) \n+\t\t\t ? REGNO (operands[2]) + 1 : REGNO (operands[2]));\n \n   /* We must be careful to make sure that the new rtx won't need reloading.  */\n   if (GET_CODE (operands[1]) == MEM &&\n       ! strict_memory_address_p (DImode, XEXP (operands[1], 0)))\n     {\n-      tmp = gen_rtx (REG, Pmode, REGNO (operands[0]));\n+      tmp = gen_rtx_REG (Pmode, REGNO (operands[0]));\n       emit_insn (gen_move_insn (tmp, XEXP (operands[1], 0)));\n       XEXP (operands[1], 0) = tmp;\n     }\n   addr = get_unaligned_address (operands[1], 0);\n \n   seq = gen_unaligned_loadqi (operands[0], addr, scratch,\n-\t\t\t      gen_rtx (REG, DImode, REGNO (operands[0])));\n+\t\t\t      gen_rtx_REG (DImode, REGNO (operands[0])));\n \n   alpha_set_memflags (seq, operands[1]);\n   emit_insn (seq);\n@@ -4694,22 +4693,22 @@\n   /* It is possible that one of the registers we got for operands[2]\n      might coincide with that of operands[0] (which is why we made\n      it TImode).  Pick the other one to use as our scratch.  */\n-  scratch = gen_rtx (REG, DImode,\n-\t\t     REGNO (operands[0]) == REGNO (operands[2]) \n-\t\t     ? REGNO (operands[2]) + 1 : REGNO (operands[2]));\n+  scratch = gen_rtx_REG (DImode,\n+\t\t\t REGNO (operands[0]) == REGNO (operands[2]) \n+\t\t\t ? REGNO (operands[2]) + 1 : REGNO (operands[2]));\n \n   /* We must be careful to make sure that the new rtx won't need reloading.  */\n   if (GET_CODE (operands[1]) == MEM &&\n       ! strict_memory_address_p (DImode, XEXP (operands[1], 0)))\n     {\n-      tmp = gen_rtx (REG, Pmode, REGNO (operands[0]));\n+      tmp = gen_rtx_REG (Pmode, REGNO (operands[0]));\n       emit_insn (gen_move_insn (tmp, XEXP (operands[1], 0)));\n       XEXP (operands[1], 0) = tmp;\n     }\n   addr = get_unaligned_address (operands[1], 0);\n \n   seq = gen_unaligned_loadhi (operands[0], addr, scratch,\n-\t\t\t      gen_rtx (REG, DImode, REGNO (operands[0])));\n+\t\t\t      gen_rtx_REG (DImode, REGNO (operands[0])));\n \n   alpha_set_memflags (seq, operands[1]);\n   emit_insn (seq);\n@@ -4728,7 +4727,7 @@\n   if (GET_CODE (operands[0]) == MEM &&\n       ! strict_memory_address_p (DImode, XEXP (operands[0], 0)))\n     {\n-      rtx scratch1 = gen_rtx (REG, DImode, REGNO (operands[2]));\n+      rtx scratch1 = gen_rtx_REG (DImode, REGNO (operands[2]));\n       emit_insn (gen_move_insn (scratch1, XEXP (operands[0], 0)));\n       XEXP (operands[0], 0) = scratch1;\n     }\n@@ -4740,15 +4739,15 @@\n       get_aligned_mem (operands[0], &aligned_mem, &bitnum);\n \n       emit_insn (gen_aligned_store (aligned_mem, operands[1], bitnum,\n-\t\t\t\t    gen_rtx (REG, SImode, REGNO (operands[2])),\n-\t\t\t\t    gen_rtx (REG, SImode,\n-\t\t\t\t\t     REGNO (operands[2]) + 1)));\n+\t\t\t\t    gen_rtx_REG (SImode, REGNO (operands[2])),\n+\t\t\t\t    gen_rtx_REG (SImode,\n+\t\t\t\t\t\t REGNO (operands[2]) + 1)));\n     }\n   else\n     {\n       rtx addr = get_unaligned_address (operands[0], 0);\n-      rtx scratch1 = gen_rtx (REG, DImode, REGNO (operands[2]));\n-      rtx scratch2 = gen_rtx (REG, DImode, REGNO (operands[2]) + 1);\n+      rtx scratch1 = gen_rtx_REG (DImode, REGNO (operands[2]));\n+      rtx scratch2 = gen_rtx_REG (DImode, REGNO (operands[2]) + 1);\n       rtx scratch3 = scratch1;\n       rtx seq;\n \n@@ -4776,7 +4775,7 @@\n   if (GET_CODE (operands[0]) == MEM &&\n       ! strict_memory_address_p (DImode, XEXP (operands[0], 0)))\n     {\n-      rtx scratch1 = gen_rtx (REG, DImode, REGNO (operands[2]));\n+      rtx scratch1 = gen_rtx_REG (DImode, REGNO (operands[2]));\n       emit_insn (gen_move_insn (scratch1, XEXP (operands[0], 0)));\n       XEXP (operands[0], 0) = scratch1;\n     }\n@@ -4788,15 +4787,15 @@\n       get_aligned_mem (operands[0], &aligned_mem, &bitnum);\n \n       emit_insn (gen_aligned_store (aligned_mem, operands[1], bitnum,\n-\t\t\t\t    gen_rtx (REG, SImode, REGNO (operands[2])),\n-\t\t\t\t    gen_rtx (REG, SImode,\n-\t\t\t\t\t     REGNO (operands[2]) + 1)));\n+\t\t\t\t    gen_rtx_REG (SImode, REGNO (operands[2])),\n+\t\t\t\t    gen_rtx_REG (SImode,\n+\t\t\t\t\t\t REGNO (operands[2]) + 1)));\n     }\n   else\n     {\n       rtx addr = get_unaligned_address (operands[0], 0);\n-      rtx scratch1 = gen_rtx (REG, DImode, REGNO (operands[2]));\n-      rtx scratch2 = gen_rtx (REG, DImode, REGNO (operands[2]) + 1);\n+      rtx scratch1 = gen_rtx_REG (DImode, REGNO (operands[2]));\n+      rtx scratch2 = gen_rtx_REG (DImode, REGNO (operands[2]) + 1);\n       rtx scratch3 = scratch1;\n       rtx seq;\n \n@@ -4934,8 +4933,8 @@\n   \"\"\n   \"\n {\n-  operands[1] = gen_rtx (MEM, DImode, plus_constant (stack_pointer_rtx,\n-\t\t\t\t\t\t     INTVAL (operands[0])));\n+  operands[1] = gen_rtx_MEM (DImode, plus_constant (stack_pointer_rtx,\n+\t\t\t\t\t\t    INTVAL (operands[0])));\n   MEM_VOLATILE_P (operands[1]) = 1;\n \n   operands[0] = const0_rtx;\n@@ -4997,16 +4996,16 @@\n \t}\n \n       emit_label (loop_label);\n-      memref = gen_rtx (MEM, DImode, tmp);\n+      memref = gen_rtx_MEM (DImode, tmp);\n       MEM_VOLATILE_P (memref) = 1;\n       emit_move_insn (memref, const0_rtx);\n       emit_insn (gen_adddi3 (tmp, tmp, GEN_INT(-8192)));\n       emit_insn (gen_cmpdi (tmp, want));\n       emit_jump_insn (gen_bgtu (loop_label));\n       if (obey_regdecls)\n-\tgen_rtx (USE, VOIDmode, tmp);\n+\tgen_rtx_USE (VOIDmode, tmp);\n \n-      memref = gen_rtx (MEM, DImode, want);\n+      memref = gen_rtx_MEM (DImode, want);\n       MEM_VOLATILE_P (memref) = 1;\n       emit_move_insn (memref, const0_rtx);\n "}, {"sha": "ae1a5c909fb335d7169fd5300a4875e7753fea60", "filename": "gcc/cse.c", "status": "modified", "additions": 41, "deletions": 40, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38a448ca5dfe60244ab3c1f0ea8e3604ec69370b/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38a448ca5dfe60244ab3c1f0ea8e3604ec69370b/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=38a448ca5dfe60244ab3c1f0ea8e3604ec69370b", "patch": "@@ -2494,7 +2494,7 @@ canon_reg (x, insn)\n \tfirst = qty_first_reg[reg_qty[REGNO (x)]];\n \treturn (first >= FIRST_PSEUDO_REGISTER ? regno_reg_rtx[first]\n \t\t: REGNO_REG_CLASS (first) == NO_REGS ? x\n-\t\t: gen_rtx (REG, qty_mode[reg_qty[REGNO (x)]], first));\n+\t\t: gen_rtx_REG (qty_mode[reg_qty[REGNO (x)]], first));\n       }\n       \n     default:\n@@ -3696,11 +3696,11 @@ simplify_binary_operation (code, mode, op0, op1)\n \n \t  /* Change subtraction from zero into negation.  */\n \t  if (op0 == CONST0_RTX (mode))\n-\t    return gen_rtx (NEG, mode, op1);\n+\t    return gen_rtx_NEG (mode, op1);\n \n \t  /* (-1 - a) is ~a.  */\n \t  if (op0 == constm1_rtx)\n-\t    return gen_rtx (NOT, mode, op1);\n+\t    return gen_rtx_NOT (mode, op1);\n \n \t  /* Subtracting 0 has no effect.  */\n \t  if (op1 == CONST0_RTX (mode))\n@@ -3784,9 +3784,9 @@ simplify_binary_operation (code, mode, op0, op1)\n \t  if (GET_CODE (op1) == AND)\n \t    {\n \t     if (rtx_equal_p (op0, XEXP (op1, 0)))\n-\t       return cse_gen_binary (AND, mode, op0, gen_rtx (NOT, mode, XEXP (op1, 1)));\n+\t       return cse_gen_binary (AND, mode, op0, gen_rtx_NOT (mode, XEXP (op1, 1)));\n \t     if (rtx_equal_p (op0, XEXP (op1, 1)))\n-\t       return cse_gen_binary (AND, mode, op0, gen_rtx (NOT, mode, XEXP (op1, 0)));\n+\t       return cse_gen_binary (AND, mode, op0, gen_rtx_NOT (mode, XEXP (op1, 0)));\n \t   }\n \t  break;\n \n@@ -3795,7 +3795,7 @@ simplify_binary_operation (code, mode, op0, op1)\n \t    {\n \t      tem = simplify_unary_operation (NEG, mode, op0, mode);\n \n-\t      return tem ? tem : gen_rtx (NEG, mode, op0);\n+\t      return tem ? tem : gen_rtx_NEG (mode, op0);\n \t    }\n \n \t  /* In IEEE floating point, x*0 is not always 0.  */\n@@ -3821,7 +3821,7 @@ simplify_binary_operation (code, mode, op0, op1)\n \t      && (width <= HOST_BITS_PER_WIDE_INT\n \t\t  || val != HOST_BITS_PER_WIDE_INT - 1)\n \t      && ! rtx_equal_function_value_matters)\n-\t    return gen_rtx (ASHIFT, mode, op0, GEN_INT (val));\n+\t    return gen_rtx_ASHIFT (mode, op0, GEN_INT (val));\n \n \t  if (GET_CODE (op1) == CONST_DOUBLE\n \t      && GET_MODE_CLASS (GET_MODE (op1)) == MODE_FLOAT)\n@@ -3841,10 +3841,10 @@ simplify_binary_operation (code, mode, op0, op1)\n \n \t      /* x*2 is x+x and x*(-1) is -x */\n \t      if (op1is2 && GET_MODE (op0) == mode)\n-\t\treturn gen_rtx (PLUS, mode, op0, copy_rtx (op0));\n+\t\treturn gen_rtx_PLUS (mode, op0, copy_rtx (op0));\n \n \t      else if (op1ism1 && GET_MODE (op0) == mode)\n-\t\treturn gen_rtx (NEG, mode, op0);\n+\t\treturn gen_rtx_NEG (mode, op0);\n \t    }\n \t  break;\n \n@@ -3869,7 +3869,7 @@ simplify_binary_operation (code, mode, op0, op1)\n \t    return op0;\n \t  if (GET_CODE (op1) == CONST_INT\n \t      && (INTVAL (op1) & GET_MODE_MASK (mode)) == GET_MODE_MASK (mode))\n-\t    return gen_rtx (NOT, mode, op0);\n+\t    return gen_rtx_NOT (mode, op0);\n \t  if (op0 == op1 && ! side_effects_p (op0)\n \t      && GET_MODE_CLASS (mode) != MODE_CC)\n \t    return const0_rtx;\n@@ -3897,7 +3897,7 @@ simplify_binary_operation (code, mode, op0, op1)\n \t     below).  */\n \t  if (GET_CODE (op1) == CONST_INT\n \t      && (arg1 = exact_log2 (INTVAL (op1))) > 0)\n-\t    return gen_rtx (LSHIFTRT, mode, op0, GEN_INT (arg1));\n+\t    return gen_rtx_LSHIFTRT (mode, op0, GEN_INT (arg1));\n \n \t  /* ... fall through ...  */\n \n@@ -3928,11 +3928,11 @@ simplify_binary_operation (code, mode, op0, op1)\n \t\t{\n #if defined (REAL_ARITHMETIC)\n \t\t  REAL_ARITHMETIC (d, rtx_to_tree_code (DIV), dconst1, d);\n-\t\t  return gen_rtx (MULT, mode, op0, \n-\t\t\t\t  CONST_DOUBLE_FROM_REAL_VALUE (d, mode));\n+\t\t  return gen_rtx_MULT (mode, op0, \n+\t\t\t\t       CONST_DOUBLE_FROM_REAL_VALUE (d, mode));\n #else\n-\t\t  return gen_rtx (MULT, mode, op0, \n-\t\t\t\t  CONST_DOUBLE_FROM_REAL_VALUE (1./d, mode));\n+\t\t  return gen_rtx_MULT (mode, op0, \n+\t\t\t\t       CONST_DOUBLE_FROM_REAL_VALUE (1./d, mode));\n #endif\n \t\t}\n \t    }\n@@ -3943,7 +3943,7 @@ simplify_binary_operation (code, mode, op0, op1)\n \t  /* Handle modulus by power of two (mod with 1 handled below).  */\n \t  if (GET_CODE (op1) == CONST_INT\n \t      && exact_log2 (INTVAL (op1)) > 0)\n-\t    return gen_rtx (AND, mode, op0, GEN_INT (INTVAL (op1) - 1));\n+\t    return gen_rtx_AND (mode, op0, GEN_INT (INTVAL (op1) - 1));\n \n \t  /* ... fall through ...  */\n \n@@ -4375,7 +4375,7 @@ simplify_plus_minus (code, mode, op0, op1)\n   for (i = 1; i < n_ops; i++)\n     result = cse_gen_binary (negs[i] ? MINUS : PLUS, mode, result, ops[i]);\n \n-  return negate ? gen_rtx (NEG, mode, result) : result;\n+  return negate ? gen_rtx_NEG (mode, result) : result;\n }\n \f\n /* Make a binary operation by properly ordering the operands and \n@@ -4415,7 +4415,7 @@ cse_gen_binary (code, mode, op0, op1)\n \t   && GET_MODE (op0) != VOIDmode)\n     return plus_constant (op0, - INTVAL (op1));\n   else\n-    return gen_rtx (code, mode, op0, op1);\n+    return gen_rtx_fmt_ee (code, mode, op0, op1);\n }\n \f\n /* Like simplify_binary_operation except used for relational operators.\n@@ -4803,7 +4803,7 @@ fold_rtx (x, insn)\n \t      && GET_CODE (NEXT_INSN (next)) == JUMP_INSN\n \t      && (GET_CODE (PATTERN (NEXT_INSN (next))) == ADDR_VEC\n \t\t  || GET_CODE (PATTERN (NEXT_INSN (next))) == ADDR_DIFF_VEC))\n-\t    return gen_rtx (LABEL_REF, Pmode, next);\n+\t    return gen_rtx_LABEL_REF (Pmode, next);\n \t}\n       break;\n \n@@ -5102,17 +5102,17 @@ fold_rtx (x, insn)\n \t\t\t< XVECLEN (table, 1)))\n \t\t  {\n \t\t    offset /= GET_MODE_SIZE (GET_MODE (table));\n-\t\t    new = gen_rtx (MINUS, Pmode, XVECEXP (table, 1, offset),\n-\t\t\t\t   XEXP (table, 0));\n+\t\t    new = gen_rtx_MINUS (Pmode, XVECEXP (table, 1, offset),\n+\t\t\t\t\t XEXP (table, 0));\n \n \t\t    if (GET_MODE (table) != Pmode)\n-\t\t      new = gen_rtx (TRUNCATE, GET_MODE (table), new);\n+\t\t      new = gen_rtx_TRUNCATE (GET_MODE (table), new);\n \n \t\t    /* Indicate this is a constant.  This isn't a \n \t\t       valid form of CONST, but it will only be used\n \t\t       to fold the next insns and then discarded, so\n \t\t       it should be safe.  */\n-\t\t    return gen_rtx (CONST, GET_MODE (new), new);\n+\t\t    return gen_rtx_CONST (GET_MODE (new), new);\n \t\t  }\n \t      }\n \t  }\n@@ -5312,7 +5312,7 @@ fold_rtx (x, insn)\n \t\t\t\t\tconst_arg0 ? const_arg0 : folded_arg0,\n \t\t\t\t\tmode_arg0);\n \tif (new != 0 && is_const)\n-\t  new = gen_rtx (CONST, mode, new);\n+\t  new = gen_rtx_CONST (mode, new);\n       }\n       break;\n       \n@@ -5763,7 +5763,7 @@ gen_lowpart_if_possible (mode, x)\n \t   unchanged.  */\n \toffset -= (MIN (UNITS_PER_WORD, GET_MODE_SIZE (mode))\n \t\t   - MIN (UNITS_PER_WORD, GET_MODE_SIZE (GET_MODE (x))));\n-      new = gen_rtx (MEM, mode, plus_constant (XEXP (x, 0), offset));\n+      new = gen_rtx_MEM (mode, plus_constant (XEXP (x, 0), offset));\n       if (! memory_address_p (mode, XEXP (new, 0)))\n \treturn 0;\n       MEM_VOLATILE_P (new) = MEM_VOLATILE_P (x);\n@@ -5859,7 +5859,7 @@ record_jump_cond (code, mode, op0, op1, reversed_nonequality)\n       rtx tem = gen_lowpart_if_possible (inner_mode, op1);\n \n       record_jump_cond (code, mode, SUBREG_REG (op0),\n-\t\t\ttem ? tem : gen_rtx (SUBREG, inner_mode, op1, 0),\n+\t\t\ttem ? tem : gen_rtx_SUBREG (inner_mode, op1, 0),\n \t\t\treversed_nonequality);\n     }\n \n@@ -5871,7 +5871,7 @@ record_jump_cond (code, mode, op0, op1, reversed_nonequality)\n       rtx tem = gen_lowpart_if_possible (inner_mode, op0);\n \n       record_jump_cond (code, mode, SUBREG_REG (op1),\n-\t\t\ttem ? tem : gen_rtx (SUBREG, inner_mode, op0, 0),\n+\t\t\ttem ? tem : gen_rtx_SUBREG (inner_mode, op0, 0),\n \t\t\treversed_nonequality);\n     }\n \n@@ -5891,7 +5891,7 @@ record_jump_cond (code, mode, op0, op1, reversed_nonequality)\n       rtx tem = gen_lowpart_if_possible (inner_mode, op1);\n \n       record_jump_cond (code, mode, SUBREG_REG (op0),\n-\t\t\ttem ? tem : gen_rtx (SUBREG, inner_mode, op1, 0),\n+\t\t\ttem ? tem : gen_rtx_SUBREG (inner_mode, op1, 0),\n \t\t\treversed_nonequality);\n     }\n \n@@ -5904,7 +5904,7 @@ record_jump_cond (code, mode, op0, op1, reversed_nonequality)\n       rtx tem = gen_lowpart_if_possible (inner_mode, op0);\n \n       record_jump_cond (code, mode, SUBREG_REG (op1),\n-\t\t\ttem ? tem : gen_rtx (SUBREG, inner_mode, op0, 0),\n+\t\t\ttem ? tem : gen_rtx_SUBREG (inner_mode, op0, 0),\n \t\t\treversed_nonequality);\n     }\n \n@@ -6602,7 +6602,7 @@ cse_insn (insn, in_libcall_block)\n \t  && GET_MODE_SIZE (mode) < UNITS_PER_WORD)\n \t{\n \t  enum machine_mode tmode;\n-\t  rtx new_and = gen_rtx (AND, VOIDmode, NULL_RTX, XEXP (src, 1));\n+\t  rtx new_and = gen_rtx_AND (VOIDmode, NULL_RTX, XEXP (src, 1));\n \n \t  for (tmode = GET_MODE_WIDER_MODE (mode);\n \t       GET_MODE_SIZE (tmode) <= UNITS_PER_WORD;\n@@ -6864,7 +6864,7 @@ cse_insn (insn, in_libcall_block)\n \t\t  && (GET_CODE (PATTERN (NEXT_INSN (trial))) == ADDR_DIFF_VEC\n \t\t      || GET_CODE (PATTERN (NEXT_INSN (trial))) == ADDR_VEC))\n \n-\t\ttrial = gen_rtx (LABEL_REF, Pmode, get_label_after (trial));\n+\t\ttrial = gen_rtx_LABEL_REF (Pmode, get_label_after (trial));\n \n \t      SET_SRC (sets[i].rtl) = trial;\n  \t      cse_jumps_altered = 1;\n@@ -6929,7 +6929,7 @@ cse_insn (insn, in_libcall_block)\n \n \t  src = SET_SRC (sets[i].rtl)\n \t    = first >= FIRST_PSEUDO_REGISTER ? regno_reg_rtx[first]\n-\t      : gen_rtx (REG, GET_MODE (src), first);\n+\t      : gen_rtx_REG (GET_MODE (src), first);\n \n \t  /* If we had a constant that is cheaper than what we are now\n \t     setting SRC to, use that constant.  We ignored it when we\n@@ -6968,8 +6968,8 @@ cse_insn (insn, in_libcall_block)\n \t  if (tem)\n \t    XEXP (tem, 0) = src_const;\n \t  else\n-\t    REG_NOTES (insn) = gen_rtx (EXPR_LIST, REG_EQUAL,\n-\t\t\t\t        src_const, REG_NOTES (insn));\n+\t    REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_EQUAL,\n+\t\t\t\t\t\t  src_const, REG_NOTES (insn));\n \n           /* If storing a constant value in a register that\n \t     previously held the constant value 0,\n@@ -6995,8 +6995,9 @@ cse_insn (insn, in_libcall_block)\n \t\t  if (note)\n \t\t    XEXP (note, 0) = const_insn;\n \t\t  else\n-\t\t    REG_NOTES (insn) = gen_rtx (INSN_LIST, REG_WAS_0,\n-\t\t\t\t\t\tconst_insn, REG_NOTES (insn));\n+\t\t    REG_NOTES (insn) = gen_rtx_INSN_LIST (REG_WAS_0,\n+\t\t\t\t\t\t\t  const_insn,\n+\t\t\t\t\t\t\t  REG_NOTES (insn));\n \t\t}\n \t    }\n \t}\n@@ -7174,8 +7175,8 @@ cse_insn (insn, in_libcall_block)\n \t  this_insn_cc0 = src_const && mode != VOIDmode ? src_const : src;\n \t  this_insn_cc0_mode = mode;\n \t  if (FLOAT_MODE_P (mode))\n-\t    this_insn_cc0 = gen_rtx (COMPARE, VOIDmode, this_insn_cc0,\n-\t\t\t\t     CONST0_RTX (mode));\n+\t    this_insn_cc0 = gen_rtx_COMPARE (VOIDmode, this_insn_cc0,\n+\t\t\t\t\t     CONST0_RTX (mode));\n \t}\n #endif\n     }\n@@ -7453,7 +7454,7 @@ cse_insn (insn, in_libcall_block)\n \n \t\tnew_src = gen_lowpart_if_possible (new_mode, elt->exp);\n \t\tif (new_src == 0)\n-\t\t  new_src = gen_rtx (SUBREG, new_mode, elt->exp, 0);\n+\t\t  new_src = gen_rtx_SUBREG (new_mode, elt->exp, 0);\n \n \t\tsrc_hash = HASH (new_src, new_mode);\n \t\tsrc_elt = lookup (new_src, src_hash, new_mode);\n@@ -8277,7 +8278,7 @@ cse_main (f, nregs, after_loop, file)\n \n   /* Allocate scratch rtl here.  cse_insn will fill in the memory reference\n      and change the code and mode as appropriate.  */\n-  memory_extend_rtx = gen_rtx (ZERO_EXTEND, VOIDmode, NULL_RTX);\n+  memory_extend_rtx = gen_rtx_ZERO_EXTEND (VOIDmode, NULL_RTX);\n #endif\n \n   /* Discard all the free elements of the previous function"}, {"sha": "6b23d6e81ed64f5c8641e717e1dbac5e9396ca42", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38a448ca5dfe60244ab3c1f0ea8e3604ec69370b/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38a448ca5dfe60244ab3c1f0ea8e3604ec69370b/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=38a448ca5dfe60244ab3c1f0ea8e3604ec69370b", "patch": "@@ -402,30 +402,30 @@ static unsigned reg_number\t\tPROTO((rtx));\n    .debug_frame.  */\n \n #define ASM_OUTPUT_DWARF_ADDR(FILE,LABEL) \\\n-  assemble_integer (gen_rtx (SYMBOL_REF, Pmode, LABEL), PTR_SIZE, 1)\n+  assemble_integer (gen_rtx_SYMBOL_REF (Pmode, LABEL), PTR_SIZE, 1)\n \n #define ASM_OUTPUT_DWARF_OFFSET4(FILE,LABEL) \\\n-  assemble_integer (gen_rtx (SYMBOL_REF, SImode, LABEL), 4, 1)\n+  assemble_integer (gen_rtx_SYMBOL_REF (SImode, LABEL), 4, 1)\n \n #define ASM_OUTPUT_DWARF_OFFSET(FILE,LABEL) \\\n-  assemble_integer (gen_rtx (SYMBOL_REF, SImode, LABEL), 4, 1)\n+  assemble_integer (gen_rtx_SYMBOL_REF (SImode, LABEL), 4, 1)\n \n #define ASM_OUTPUT_DWARF_DELTA2(FILE,LABEL1,LABEL2)\t\t\t\\\n-  assemble_integer (gen_rtx (MINUS, HImode,\t\t\t      \t\\\n-\t\t\t     gen_rtx (SYMBOL_REF, Pmode, LABEL1),   \t\\\n-\t\t\t     gen_rtx (SYMBOL_REF, Pmode, LABEL2)),\t\\\n+  assemble_integer (gen_rtx_MINUS (HImode,\t\t\t      \t\\\n+\t\t\t     gen_rtx_SYMBOL_REF (Pmode, LABEL1),   \t\\\n+\t\t\t     gen_rtx_SYMBOL_REF (Pmode, LABEL2)),\t\\\n \t\t    2, 1)\n   \n #define ASM_OUTPUT_DWARF_DELTA4(FILE,LABEL1,LABEL2)\t\t\t\\\n-  assemble_integer (gen_rtx (MINUS, SImode,\t\t\t      \t\\\n-\t\t\t     gen_rtx (SYMBOL_REF, Pmode, LABEL1),   \t\\\n-\t\t\t     gen_rtx (SYMBOL_REF, Pmode, LABEL2)),\t\\\n+  assemble_integer (gen_rtx_MINUS (SImode,\t\t\t      \t\\\n+\t\t\t     gen_rtx_SYMBOL_REF (Pmode, LABEL1),   \t\\\n+\t\t\t     gen_rtx_SYMBOL_REF (Pmode, LABEL2)),\t\\\n \t\t    4, 1)\n \n #define ASM_OUTPUT_DWARF_ADDR_DELTA(FILE,LABEL1,LABEL2)\t\t\t\\\n-  assemble_integer (gen_rtx (MINUS, Pmode,\t\t\t\t\\\n-\t\t\t     gen_rtx (SYMBOL_REF, Pmode, LABEL1),\t\\\n-\t\t\t     gen_rtx (SYMBOL_REF, Pmode, LABEL2)),\t\\\n+  assemble_integer (gen_rtx_MINUS (Pmode,\t\t\t\t\\\n+\t\t\t     gen_rtx_SYMBOL_REF (Pmode, LABEL1),\t\\\n+\t\t\t     gen_rtx_SYMBOL_REF (Pmode, LABEL2)),\t\\\n \t\t    PTR_SIZE, 1)\n \n #define ASM_OUTPUT_DWARF_DELTA(FILE,LABEL1,LABEL2) \\"}, {"sha": "216ab70f68257b19cddb8fe5f1e596f6ccd5cc7f", "filename": "gcc/except.c", "status": "modified", "additions": 21, "deletions": 23, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38a448ca5dfe60244ab3c1f0ea8e3604ec69370b/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38a448ca5dfe60244ab3c1f0ea8e3604ec69370b/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=38a448ca5dfe60244ab3c1f0ea8e3604ec69370b", "patch": "@@ -758,15 +758,13 @@ get_eh_context ()\n \n       current_function_ehc = gen_reg_rtx (Pmode);\n       \n-      insn = gen_rtx (USE,\n-\t\t      GET_MODE (current_function_ehc),\n-\t\t      current_function_ehc);\n+      insn = gen_rtx_USE (GET_MODE (current_function_ehc),\n+\t\t\t  current_function_ehc);\n       insn = emit_insn_before (insn, get_first_nonparm_insn ());\n \n       REG_NOTES (insn)\n-\t= gen_rtx (EXPR_LIST, \n-\t\t   REG_EH_CONTEXT, current_function_ehc,\n-\t\t   REG_NOTES (insn));\n+\t= gen_rtx_EXPR_LIST (REG_EH_CONTEXT, current_function_ehc,\n+\t\t\t     REG_NOTES (insn));\n     }\n   return current_function_ehc;\n }\n@@ -791,7 +789,7 @@ get_dynamic_handler_chain ()\n   result = copy_to_reg (dhc);\n \n   /* We don't want a copy of the dcc, but rather, the single dcc.  */\n-  return gen_rtx (MEM, Pmode, result);\n+  return gen_rtx_MEM (Pmode, result);\n }\n \n /* Get a reference to the dynamic cleanup chain.  It points to the\n@@ -811,7 +809,7 @@ get_dynamic_cleanup_chain ()\n   result = copy_to_reg (dcc);\n \n   /* We don't want a copy of the dcc, but rather, the single dcc.  */\n-  return gen_rtx (MEM, Pmode, result);\n+  return gen_rtx_MEM (Pmode, result);\n }\n \n /* Generate code to evaluate X and jump to LABEL if the value is nonzero.\n@@ -878,10 +876,10 @@ start_dynamic_cleanup (func, arg)\n \n   /* Store func and arg into the cleanup list element.  */\n \n-  new_func = gen_rtx (MEM, Pmode, plus_constant (XEXP (buf, 0),\n-\t\t\t\t\t\t GET_MODE_SIZE (Pmode)));\n-  new_arg = gen_rtx (MEM, Pmode, plus_constant (XEXP (buf, 0),\n-\t\t\t\t\t\tGET_MODE_SIZE (Pmode)*2));\n+  new_func = gen_rtx_MEM (Pmode, plus_constant (XEXP (buf, 0),\n+\t\t\t\t\t\tGET_MODE_SIZE (Pmode)));\n+  new_arg = gen_rtx_MEM (Pmode, plus_constant (XEXP (buf, 0),\n+\t\t\t\t\t       GET_MODE_SIZE (Pmode)*2));\n   x = expand_expr (func, new_func, Pmode, 0);\n   if (x != new_func)\n     emit_move_insn (new_func, x);\n@@ -934,8 +932,8 @@ start_dynamic_handler ()\n   /* Store dhc into the first word of the newly allocated buffer.  */\n \n   dhc = get_dynamic_handler_chain ();\n-  dcc = gen_rtx (MEM, Pmode, plus_constant (XEXP (arg, 0),\n-\t\t\t\t\t    GET_MODE_SIZE (Pmode)));\n+  dcc = gen_rtx_MEM (Pmode, plus_constant (XEXP (arg, 0),\n+\t\t\t\t\t   GET_MODE_SIZE (Pmode)));\n   emit_move_insn (arg, dhc);\n \n   /* Zero out the start of the cleanup chain.  */\n@@ -1574,15 +1572,15 @@ output_exception_table_entry (file, n)\n   rtx sym;\n \n   ASM_GENERATE_INTERNAL_LABEL (buf, \"LEHB\", n);\n-  sym = gen_rtx (SYMBOL_REF, Pmode, buf);\n+  sym = gen_rtx_SYMBOL_REF (Pmode, buf);\n   assemble_integer (sym, POINTER_SIZE / BITS_PER_UNIT, 1);\n \n   ASM_GENERATE_INTERNAL_LABEL (buf, \"LEHE\", n);\n-  sym = gen_rtx (SYMBOL_REF, Pmode, buf);\n+  sym = gen_rtx_SYMBOL_REF (Pmode, buf);\n   assemble_integer (sym, POINTER_SIZE / BITS_PER_UNIT, 1);\n \n   ASM_GENERATE_INTERNAL_LABEL (buf, \"L\", n);\n-  sym = gen_rtx (SYMBOL_REF, Pmode, buf);\n+  sym = gen_rtx_SYMBOL_REF (Pmode, buf);\n   assemble_integer (sym, POINTER_SIZE / BITS_PER_UNIT, 1);\n \n   putc ('\\n', file);\t\t/* blank line */\n@@ -1717,8 +1715,8 @@ find_exception_handler_labels ()\n \n \t      if (label)\n \t\texception_handler_labels\n-\t\t  = gen_rtx (EXPR_LIST, VOIDmode,\n-\t\t\t     label, exception_handler_labels);\n+\t\t  = gen_rtx_EXPR_LIST (VOIDmode,\n+\t\t\t\t       label, exception_handler_labels);\n \t      else\n \t\twarning (\"didn't find handler for EH region %d\",\n \t\t\t NOTE_BLOCK_NUMBER (insn));\n@@ -2134,7 +2132,7 @@ eh_regs (r1, r2, outgoing)\n       for (i = 0; i < FIRST_PSEUDO_REGISTER; ++i)\n \tif (call_used_regs[i] && ! fixed_regs[i] && i != REGNO (reg1))\n \t  {\n-\t    reg2 = gen_rtx (REG, Pmode, i);\n+\t    reg2 = gen_rtx_REG (Pmode, i);\n \t    break;\n \t  }\n \n@@ -2166,7 +2164,7 @@ expand_builtin_eh_stub ()\n   emit_indirect_jump (handler);\n \n   emit_label (after_stub);\n-  return gen_rtx (LABEL_REF, Pmode, stub_start);\n+  return gen_rtx_LABEL_REF (Pmode, stub_start);\n }\n \n /* Set up the registers for passing the handler address and stack offset\n@@ -2184,6 +2182,6 @@ expand_builtin_set_eh_regs (handler, offset)\n   store_expr (handler, reg1, 0);\n \n   /* These will be used by the stub.  */\n-  emit_insn (gen_rtx (USE, VOIDmode, reg1));\n-  emit_insn (gen_rtx (USE, VOIDmode, reg2));\n+  emit_insn (gen_rtx_USE (VOIDmode, reg1));\n+  emit_insn (gen_rtx_USE (VOIDmode, reg2));\n }"}, {"sha": "e38c1e43f8b064cd986ec00cb2d7c2ccf34bb5da", "filename": "gcc/explow.c", "status": "modified", "additions": 84, "deletions": 49, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38a448ca5dfe60244ab3c1f0ea8e3604ec69370b/gcc%2Fexplow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38a448ca5dfe60244ab3c1f0ea8e3604ec69370b/gcc%2Fexplow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexplow.c?ref=38a448ca5dfe60244ab3c1f0ea8e3604ec69370b", "patch": "@@ -20,6 +20,7 @@ Boston, MA 02111-1307, USA.  */\n \n \n #include \"config.h\"\n+#include <stdio.h>\n #include \"rtl.h\"\n #include \"tree.h\"\n #include \"flags.h\"\n@@ -78,10 +79,15 @@ plus_constant_wide (x, c)\n       if (GET_CODE (XEXP (x, 0)) == SYMBOL_REF\n \t  && CONSTANT_POOL_ADDRESS_P (XEXP (x, 0)))\n \t{\n+\t  /* Any rtl we create here must go in a saveable obstack, since\n+\t     we might have been called from within combine.  */\n+\t  push_obstacks_nochange ();\n+\t  rtl_in_saveable_obstack ();\n \t  tem\n \t    = force_const_mem (GET_MODE (x),\n \t\t\t       plus_constant (get_pool_constant (XEXP (x, 0)),\n \t\t\t\t\t      c));\n+\t  pop_obstacks ();\n \t  if (memory_address_p (GET_MODE (tem), XEXP (tem, 0)))\n \t    return tem;\n \t}\n@@ -112,22 +118,26 @@ plus_constant_wide (x, c)\n       if (GET_CODE (XEXP (x, 1)) == CONST_INT)\n \treturn plus_constant (XEXP (x, 0), c + INTVAL (XEXP (x, 1)));\n       else if (CONSTANT_P (XEXP (x, 0)))\n-\treturn gen_rtx (PLUS, mode,\n-\t\t\tplus_constant (XEXP (x, 0), c),\n-\t\t\tXEXP (x, 1));\n+\treturn gen_rtx_PLUS (mode,\n+\t\t\t     plus_constant (XEXP (x, 0), c),\n+\t\t\t     XEXP (x, 1));\n       else if (CONSTANT_P (XEXP (x, 1)))\n-\treturn gen_rtx (PLUS, mode,\n-\t\t\tXEXP (x, 0),\n-\t\t\tplus_constant (XEXP (x, 1), c));\n+\treturn gen_rtx_PLUS (mode,\n+\t\t\t     XEXP (x, 0),\n+\t\t\t     plus_constant (XEXP (x, 1), c));\n+      break;\n+      \n+    default:\n+      break;\n     }\n \n   if (c != 0)\n-    x = gen_rtx (PLUS, mode, x, GEN_INT (c));\n+    x = gen_rtx_PLUS (mode, x, GEN_INT (c));\n \n   if (GET_CODE (x) == SYMBOL_REF || GET_CODE (x) == LABEL_REF)\n     return x;\n   else if (all_constant)\n-    return gen_rtx (CONST, mode, x);\n+    return gen_rtx_CONST (mode, x);\n   else\n     return x;\n }\n@@ -146,7 +156,7 @@ plus_constant_for_output_wide (x, c)\n   int all_constant = 0;\n \n   if (GET_CODE (x) == LO_SUM)\n-    return gen_rtx (LO_SUM, mode, XEXP (x, 0),\n+    return gen_rtx_LO_SUM (mode, XEXP (x, 0),\n \t\t    plus_constant_for_output (XEXP (x, 1), c));\n \n   else\n@@ -188,7 +198,7 @@ eliminate_constant_term (x, constptr)\n       && GET_CODE (tem) == CONST_INT)\n     {\n       *constptr = tem;\n-      return gen_rtx (PLUS, GET_MODE (x), x0, x1);\n+      return gen_rtx_PLUS (GET_MODE (x), x0, x1);\n     }\n \n   return x;\n@@ -286,7 +296,7 @@ break_out_memory_refs (x)\n       register rtx op1 = break_out_memory_refs (XEXP (x, 1));\n \n       if (op0 != XEXP (x, 0) || op1 != XEXP (x, 1))\n-\tx = gen_rtx (GET_CODE (x), Pmode, op0, op1);\n+\tx = gen_rtx_fmt_ee (GET_CODE (x), Pmode, op0, op1);\n     }\n \n   return x;\n@@ -317,31 +327,37 @@ convert_memory_address (to_mode, x)\n       return x;\n \n     case LABEL_REF:\n-      return gen_rtx (LABEL_REF, to_mode, XEXP (x, 0));\n+      temp = gen_rtx_LABEL_REF (to_mode, XEXP (x, 0));\n+      LABEL_REF_NONLOCAL_P (temp) = LABEL_REF_NONLOCAL_P (x);\n+      return temp;\n \n     case SYMBOL_REF:\n-      temp = gen_rtx (SYMBOL_REF, to_mode, XSTR (x, 0));\n+      temp = gen_rtx_SYMBOL_REF (to_mode, XSTR (x, 0));\n       SYMBOL_REF_FLAG (temp) = SYMBOL_REF_FLAG (x);\n       CONSTANT_POOL_ADDRESS_P (temp) = CONSTANT_POOL_ADDRESS_P (x);\n       return temp;\n \n     case CONST:\n-      return gen_rtx (CONST, to_mode, \n-\t\t      convert_memory_address (to_mode, XEXP (x, 0)));\n+      return gen_rtx_CONST (to_mode, \n+\t\t\t    convert_memory_address (to_mode, XEXP (x, 0)));\n \n     case PLUS:\n     case MULT:\n       /* For addition the second operand is a small constant, we can safely\n-\t permute the converstion and addition operation.  We can always safely\n+\t permute the conversion and addition operation.  We can always safely\n \t permute them if we are making the address narrower.  In addition,\n \t always permute the operations if this is a constant.  */\n       if (GET_MODE_SIZE (to_mode) < GET_MODE_SIZE (from_mode)\n \t  || (GET_CODE (x) == PLUS && GET_CODE (XEXP (x, 1)) == CONST_INT\n \t      && (INTVAL (XEXP (x, 1)) + 20000 < 40000\n \t\t  || CONSTANT_P (XEXP (x, 0)))))\n-\treturn gen_rtx (GET_CODE (x), to_mode, \n-\t\t\tconvert_memory_address (to_mode, XEXP (x, 0)),\n-\t\t\tconvert_memory_address (to_mode, XEXP (x, 1)));\n+\treturn gen_rtx_fmt_ee (GET_CODE (x), to_mode, \n+\t\t\t       convert_memory_address (to_mode, XEXP (x, 0)),\n+\t\t\t       convert_memory_address (to_mode, XEXP (x, 1)));\n+      break;\n+      \n+    default:\n+      break;\n     }\n \n   return convert_modes (to_mode, from_mode,\n@@ -383,7 +399,7 @@ copy_all_regs (x)\n       register rtx op0 = copy_all_regs (XEXP (x, 0));\n       register rtx op1 = copy_all_regs (XEXP (x, 1));\n       if (op0 != XEXP (x, 0) || op1 != XEXP (x, 1))\n-\tx = gen_rtx (GET_CODE (x), Pmode, op0, op1);\n+\tx = gen_rtx_fmt_ee (GET_CODE (x), Pmode, op0, op1);\n     }\n   return x;\n }\n@@ -399,6 +415,9 @@ memory_address (mode, x)\n {\n   register rtx oldx = x;\n \n+  if (GET_CODE (x) == ADDRESSOF)\n+    return x;\n+\n #ifdef POINTERS_EXTEND_UNSIGNED\n   if (GET_MODE (x) == ptr_mode)\n     x = convert_memory_address (Pmode, x);\n@@ -458,7 +477,7 @@ memory_address (mode, x)\n \t    x = force_operand (x, NULL_RTX);\n \t  else\n \t    {\n-\t      y = gen_rtx (PLUS, GET_MODE (x), copy_to_reg (y), constant_term);\n+\t      y = gen_rtx_PLUS (GET_MODE (x), copy_to_reg (y), constant_term);\n \t      if (! memory_address_p (mode, y))\n \t\tx = force_operand (x, NULL_RTX);\n \t      else\n@@ -567,7 +586,7 @@ stabilize (x)\n       rtx mem;\n       if (GET_CODE (temp) != REG)\n \ttemp = copy_to_reg (temp);\n-      mem = gen_rtx (MEM, GET_MODE (x), temp);\n+      mem = gen_rtx_MEM (GET_MODE (x), temp);\n \n       /* Mark returned memref with in_struct if it's in an array or\n \t structure.  Copy const and volatile from original memref.  */\n@@ -663,7 +682,7 @@ force_reg (mode, x)\n       if (note)\n \tXEXP (note, 0) = x;\n       else\n-\tREG_NOTES (insn) = gen_rtx (EXPR_LIST, REG_EQUAL, x, REG_NOTES (insn));\n+\tREG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_EQUAL, x, REG_NOTES (insn));\n     }\n   return temp;\n }\n@@ -740,6 +759,9 @@ promote_mode (type, mode, punsignedp, for_call)\n       unsignedp = POINTERS_EXTEND_UNSIGNED;\n       break;\n #endif\n+      \n+    default:\n+      break;\n     }\n \n   *punsignedp = unsignedp;\n@@ -879,6 +901,8 @@ emit_stack_save (save_level, psave, after)\n \t}\n       break;\n #endif\n+    default:\n+      break;\n     }\n \n   /* If there is no save area and we have to allocate one, do so.  Otherwise\n@@ -959,6 +983,8 @@ emit_stack_restore (save_level, sa, after)\n \tfcn = gen_restore_stack_nonlocal;\n       break;\n #endif\n+    default:\n+      break;\n     }\n \n   if (sa != 0)\n@@ -1090,38 +1116,39 @@ allocate_dynamic_stack_space (size, target, known_align)\n \n   mark_reg_pointer (target, known_align / BITS_PER_UNIT);\n \n-#ifndef STACK_GROWS_DOWNWARD\n-  emit_move_insn (target, virtual_stack_dynamic_rtx);\n-#endif\n-\n   /* Perform the required allocation from the stack.  Some systems do\n      this differently than simply incrementing/decrementing from the\n-     stack pointer.  */\n+     stack pointer, such as acquiring the space by calling malloc().  */\n #ifdef HAVE_allocate_stack\n   if (HAVE_allocate_stack)\n     {\n-      enum machine_mode mode\n-\t= insn_operand_mode[(int) CODE_FOR_allocate_stack][0];\n-\n-      size = convert_modes (mode, ptr_mode, size, 1);\n+      enum machine_mode mode;\n \n       if (insn_operand_predicate[(int) CODE_FOR_allocate_stack][0]\n \t  && ! ((*insn_operand_predicate[(int) CODE_FOR_allocate_stack][0])\n+\t\t(target, Pmode)))\n+\ttarget = copy_to_mode_reg (Pmode, target);\n+      mode = insn_operand_mode[(int) CODE_FOR_allocate_stack][1];\n+      size = convert_modes (mode, ptr_mode, size, 1);\n+      if (insn_operand_predicate[(int) CODE_FOR_allocate_stack][1]\n+\t  && ! ((*insn_operand_predicate[(int) CODE_FOR_allocate_stack][1])\n \t\t(size, mode)))\n \tsize = copy_to_mode_reg (mode, size);\n \n-      emit_insn (gen_allocate_stack (size));\n+      emit_insn (gen_allocate_stack (target, size));\n     }\n   else\n #endif\n     {\n+#ifndef STACK_GROWS_DOWNWARD\n+      emit_move_insn (target, virtual_stack_dynamic_rtx);\n+#endif\n       size = convert_modes (Pmode, ptr_mode, size, 1);\n       anti_adjust_stack (size);\n-    }\n-\n #ifdef STACK_GROWS_DOWNWARD\n   emit_move_insn (target, virtual_stack_dynamic_rtx);\n #endif\n+    }\n \n   if (MUST_ALIGN)\n     {\n@@ -1159,7 +1186,7 @@ static void\n emit_stack_probe (address)\n      rtx address;\n {\n-  rtx memref = gen_rtx (MEM, word_mode, address);\n+  rtx memref = gen_rtx_MEM (word_mode, address);\n \n   MEM_VOLATILE_P (memref) = 1;\n \n@@ -1190,10 +1217,11 @@ probe_stack_range (first, size)\n #ifdef HAVE_check_stack\n   if (HAVE_check_stack)\n     {\n-      rtx last_addr = force_operand (gen_rtx (STACK_GROW_OP, Pmode,\n-\t\t\t\t\t      stack_pointer_rtx,\n-\t\t\t\t\t      plus_constant (size, first)),\n-\t\t\t\t     NULL_RTX);\n+      rtx last_addr\n+\t= force_operand (gen_rtx_STACK_GROW_OP (Pmode,\n+\t\t\t\t\t\tstack_pointer_rtx,\n+\t\t\t\t\t\tplus_constant (size, first)),\n+\t\t\t NULL_RTX);\n \n       if (insn_operand_predicate[(int) CODE_FOR_check_stack][0]\n \t  && ! ((*insn_operand_predicate[(int) CODE_FOR_check_stack][0])\n@@ -1218,25 +1246,28 @@ probe_stack_range (first, size)\n       for (offset = first + STACK_CHECK_PROBE_INTERVAL;\n \t   offset < INTVAL (size);\n \t   offset = offset + STACK_CHECK_PROBE_INTERVAL)\n-\temit_stack_probe (gen_rtx (STACK_GROW_OP, Pmode,\n-\t\t\t\t   stack_pointer_rtx, GEN_INT (offset)));\n+\temit_stack_probe (gen_rtx_fmt_ee (STACK_GROW_OP, Pmode,\n+\t\t\t\t\t  stack_pointer_rtx,\n+\t\t\t\t\t  GEN_INT (offset)));\n \n-      emit_stack_probe (gen_rtx (STACK_GROW_OP, Pmode, stack_pointer_rtx,\n-\t\t\t\t plus_constant (size, first)));\n+      emit_stack_probe (gen_rtx_fmt_ee (STACK_GROW_OP, Pmode,\n+\t\t\t\t\tstack_pointer_rtx,\n+\t\t\t\t\tplus_constant (size, first)));\n     }\n \n   /* In the variable case, do the same as above, but in a loop.  We emit loop\n      notes so that loop optimization can be done.  */\n   else\n     {\n       rtx test_addr\n-\t= force_operand (gen_rtx (STACK_GROW_OP, Pmode, stack_pointer_rtx,\n-\t\t\t\t  GEN_INT (first\n-\t\t\t\t\t   + STACK_CHECK_PROBE_INTERVAL)),\n+\t= force_operand (gen_rtx_fmt_ee (STACK_GROW_OP, Pmode,\n+\t\t\t\t\t stack_pointer_rtx,\n+\t\t\t\t\t GEN_INT (first + STACK_CHECK_PROBE_INTERVAL)),\n \t\t\t NULL_RTX);\n       rtx last_addr\n-\t= force_operand (gen_rtx (STACK_GROW_OP, Pmode, stack_pointer_rtx,\n-\t\t\t\t  plus_constant (size, first)),\n+\t= force_operand (gen_rtx_fmt_ee (STACK_GROW_OP, Pmode,\n+\t\t\t\t\t stack_pointer_rtx,\n+\t\t\t\t\t plus_constant (size, first)),\n \t\t\t NULL_RTX);\n       rtx incr = GEN_INT (STACK_CHECK_PROBE_INTERVAL);\n       rtx loop_lab = gen_label_rtx ();\n@@ -1276,6 +1307,10 @@ probe_stack_range (first, size)\n       emit_note (NULL_PTR, NOTE_INSN_LOOP_END);\n       emit_label (end_lab);\n \n+      /* If will be doing stupid optimization, show test_addr is still live. */\n+      if (obey_regdecls)\n+\temit_insn (gen_rtx_USE (VOIDmode, test_addr));\n+\n       emit_stack_probe (last_addr);\n     }\n }"}, {"sha": "f6da8acd48ad5ecfd49216d0efcf476308d5f2a5", "filename": "gcc/expmed.c", "status": "modified", "additions": 101, "deletions": 93, "changes": 194, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38a448ca5dfe60244ab3c1f0ea8e3604ec69370b/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38a448ca5dfe60244ab3c1f0ea8e3604ec69370b/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=38a448ca5dfe60244ab3c1f0ea8e3604ec69370b", "patch": "@@ -80,7 +80,7 @@ init_expmed ()\n   char *free_point;\n   /* This is \"some random pseudo register\" for purposes of calling recog\n      to see what insns exist.  */\n-  rtx reg = gen_rtx (REG, word_mode, 10000);\n+  rtx reg = gen_rtx_REG (word_mode, 10000);\n   rtx shift_insn, shiftadd_insn, shiftsub_insn;\n   int dummy;\n   int m;\n@@ -95,23 +95,25 @@ init_expmed ()\n   free_point = (char *) oballoc (0);\n \n   zero_cost = rtx_cost (const0_rtx, 0);\n-  add_cost = rtx_cost (gen_rtx (PLUS, word_mode, reg, reg), SET);\n-\n-  shift_insn = emit_insn (gen_rtx (SET, VOIDmode, reg,\n-\t\t\t\t   gen_rtx (ASHIFT, word_mode, reg,\n-\t\t\t\t\t    const0_rtx)));\n-\n-  shiftadd_insn = emit_insn (gen_rtx (SET, VOIDmode, reg,\n-\t\t\t\t      gen_rtx (PLUS, word_mode,\n-\t\t\t\t\t       gen_rtx (MULT, word_mode,\n-\t\t\t\t\t\t\treg, const0_rtx),\n-\t\t\t\t\t       reg)));\n-\n-  shiftsub_insn = emit_insn (gen_rtx (SET, VOIDmode, reg,\n-\t\t\t\t      gen_rtx (MINUS, word_mode,\n-\t\t\t\t\t       gen_rtx (MULT, word_mode,\n-\t\t\t\t\t\t\t reg, const0_rtx),\n-\t\t\t\t\t\treg)));\n+  add_cost = rtx_cost (gen_rtx_PLUS (word_mode, reg, reg), SET);\n+\n+  shift_insn = emit_insn (gen_rtx_SET (VOIDmode, reg,\n+\t\t\t\t       gen_rtx_ASHIFT (word_mode, reg,\n+\t\t\t\t\t\t       const0_rtx)));\n+\n+  shiftadd_insn\n+    = emit_insn (gen_rtx_SET (VOIDmode, reg,\n+\t\t\t      gen_rtx_PLUS (word_mode,\n+\t\t\t\t\t    gen_rtx_MULT (word_mode,\n+\t\t\t\t\t\t\t  reg, const0_rtx),\n+\t\t\t\t\t    reg)));\n+\n+  shiftsub_insn\n+    = emit_insn (gen_rtx_SET (VOIDmode, reg,\n+\t\t\t      gen_rtx_MINUS (word_mode,\n+\t\t\t\t\t     gen_rtx_MULT (word_mode,\n+\t\t\t\t\t\t\t   reg, const0_rtx),\n+\t\t\t\t\t     reg)));\n \n   init_recog ();\n \n@@ -137,37 +139,39 @@ init_expmed ()\n \tshiftsub_cost[m] = rtx_cost (SET_SRC (PATTERN (shiftsub_insn)), SET);\n     }\n \n-  negate_cost = rtx_cost (gen_rtx (NEG, word_mode, reg), SET);\n+  negate_cost = rtx_cost (gen_rtx_NEG (word_mode, reg), SET);\n \n   sdiv_pow2_cheap\n-    = (rtx_cost (gen_rtx (DIV, word_mode, reg, GEN_INT (32)), SET)\n+    = (rtx_cost (gen_rtx_DIV (word_mode, reg, GEN_INT (32)), SET)\n        <= 2 * add_cost);\n   smod_pow2_cheap\n-    = (rtx_cost (gen_rtx (MOD, word_mode, reg, GEN_INT (32)), SET)\n+    = (rtx_cost (gen_rtx_MOD (word_mode, reg, GEN_INT (32)), SET)\n        <= 2 * add_cost);\n \n   for (mode = GET_CLASS_NARROWEST_MODE (MODE_INT);\n        mode != VOIDmode;\n        mode = GET_MODE_WIDER_MODE (mode))\n     {\n-      reg = gen_rtx (REG, mode, 10000);\n-      div_cost[(int) mode] = rtx_cost (gen_rtx (UDIV, mode, reg, reg), SET);\n-      mul_cost[(int) mode] = rtx_cost (gen_rtx (MULT, mode, reg, reg), SET);\n+      reg = gen_rtx_REG (mode, 10000);\n+      div_cost[(int) mode] = rtx_cost (gen_rtx_UDIV (mode, reg, reg), SET);\n+      mul_cost[(int) mode] = rtx_cost (gen_rtx_MULT (mode, reg, reg), SET);\n       wider_mode = GET_MODE_WIDER_MODE (mode);\n       if (wider_mode != VOIDmode)\n \t{\n \t  mul_widen_cost[(int) wider_mode]\n-\t    = rtx_cost (gen_rtx (MULT, wider_mode,\n-\t\t\t\t gen_rtx (ZERO_EXTEND, wider_mode, reg),\n-\t\t\t\t gen_rtx (ZERO_EXTEND, wider_mode, reg)),\n+\t    = rtx_cost (gen_rtx_MULT (wider_mode,\n+\t\t\t\t      gen_rtx_ZERO_EXTEND (wider_mode, reg),\n+\t\t\t\t      gen_rtx_ZERO_EXTEND (wider_mode, reg)),\n \t\t\tSET);\n \t  mul_highpart_cost[(int) mode]\n-\t    = rtx_cost (gen_rtx (TRUNCATE, mode,\n-\t\t\t\t gen_rtx (LSHIFTRT, wider_mode,\n-\t\t\t\t\t  gen_rtx (MULT, wider_mode,\n-\t\t\t\t\t\t   gen_rtx (ZERO_EXTEND, wider_mode, reg),\n-\t\t\t\t\t\t   gen_rtx (ZERO_EXTEND, wider_mode, reg)),\n-\t\t\t\t\t  GEN_INT (GET_MODE_BITSIZE (mode)))),\n+\t    = rtx_cost (gen_rtx_TRUNCATE\n+\t\t\t(mode,\n+\t\t\t gen_rtx_LSHIFTRT\n+\t\t\t (wider_mode,\n+\t\t\t  gen_rtx_MULT (wider_mode,\n+\t\t\t\t\tgen_rtx_ZERO_EXTEND (wider_mode, reg),\n+\t\t\t\t\tgen_rtx_ZERO_EXTEND (wider_mode, reg)),\n+\t\t\t  GEN_INT (GET_MODE_BITSIZE (mode)))),\n \t\t\tSET);\n \t}\n     }\n@@ -273,7 +277,7 @@ store_bit_field (str_rtx, bitsize, bitnum, fieldmode, value, align, total_size)\n       if (GET_MODE (op0) != fieldmode)\n \t{\n \t  if (GET_CODE (op0) == REG)\n-\t    op0 = gen_rtx (SUBREG, fieldmode, op0, offset);\n+\t    op0 = gen_rtx_SUBREG (fieldmode, op0, offset);\n \t  else\n \t    op0 = change_address (op0, fieldmode,\n \t\t\t\t  plus_constant (XEXP (op0, 0), offset));\n@@ -308,7 +312,7 @@ store_bit_field (str_rtx, bitsize, bitnum, fieldmode, value, align, total_size)\n \t  if(! (*insn_operand_predicate[icode][1]) (value, fieldmode))\n \t    value = copy_to_mode_reg (fieldmode, value);\n \t  emit_insn (GEN_FCN (icode)\n-\t\t   (gen_rtx (SUBREG, fieldmode, op0, offset), value));\n+\t\t   (gen_rtx_SUBREG (fieldmode, op0, offset), value));\n \t}\n       return value;\n     }\n@@ -365,7 +369,7 @@ store_bit_field (str_rtx, bitsize, bitnum, fieldmode, value, align, total_size)\n     {\n       if (offset != 0\n \t  || GET_MODE_SIZE (GET_MODE (op0)) > UNITS_PER_WORD)\n-\top0 = gen_rtx (SUBREG, TYPE_MODE (type_for_size (BITS_PER_WORD, 0)),\n+\top0 = gen_rtx_SUBREG (TYPE_MODE (type_for_size (BITS_PER_WORD, 0)),\n \t\t       op0, offset);\n       offset = 0;\n     }\n@@ -382,7 +386,7 @@ store_bit_field (str_rtx, bitsize, bitnum, fieldmode, value, align, total_size)\n     {\n       if (GET_CODE (value) != REG)\n \tvalue = copy_to_reg (value);\n-      value = gen_rtx (SUBREG, word_mode, value, 0);\n+      value = gen_rtx_SUBREG (word_mode, value, 0);\n     }\n \n   /* Now OFFSET is nonzero only if OP0 is memory\n@@ -465,9 +469,9 @@ store_bit_field (str_rtx, bitsize, bitnum, fieldmode, value, align, total_size)\n       if (GET_CODE (xop0) == SUBREG)\n \t/* We can't just change the mode, because this might clobber op0,\n \t   and we will need the original value of op0 if insv fails.  */\n-\txop0 = gen_rtx (SUBREG, maxmode, SUBREG_REG (xop0), SUBREG_WORD (xop0));\n+\txop0 = gen_rtx_SUBREG (maxmode, SUBREG_REG (xop0), SUBREG_WORD (xop0));\n       if (GET_CODE (xop0) == REG && GET_MODE (xop0) != maxmode)\n-\txop0 = gen_rtx (SUBREG, maxmode, xop0, 0);\n+\txop0 = gen_rtx_SUBREG (maxmode, xop0, 0);\n \n       /* On big-endian machines, we count bits from the most significant.\n \t If the bit field insn does not, we must invert.  */\n@@ -497,7 +501,7 @@ store_bit_field (str_rtx, bitsize, bitnum, fieldmode, value, align, total_size)\n \t\t  /* Avoid making subreg of a subreg, or of a mem.  */\n \t\t  if (GET_CODE (value1) != REG)\n \t\tvalue1 = copy_to_reg (value1);\n-\t\t  value1 = gen_rtx (SUBREG, maxmode, value1, 0);\n+\t\t  value1 = gen_rtx_SUBREG (maxmode, value1, 0);\n \t\t}\n \t      else\n \t\tvalue1 = gen_lowpart (maxmode, value1);\n@@ -954,7 +958,7 @@ extract_bit_field (str_rtx, bitsize, bitnum, unsignedp,\n       if (mode1 != GET_MODE (op0))\n \t{\n \t  if (GET_CODE (op0) == REG)\n-\t    op0 = gen_rtx (SUBREG, mode1, op0, offset);\n+\t    op0 = gen_rtx_SUBREG (mode1, op0, offset);\n \t  else\n \t    op0 = change_address (op0, mode1,\n \t\t\t\t  plus_constant (XEXP (op0, 0), offset));\n@@ -980,7 +984,7 @@ extract_bit_field (str_rtx, bitsize, bitnum, unsignedp,\n \ttarget = gen_reg_rtx (mode);\n \n       /* Indicate for flow that the entire target reg is being set.  */\n-      emit_insn (gen_rtx (CLOBBER, VOIDmode, target));\n+      emit_insn (gen_rtx_CLOBBER (VOIDmode, target));\n \n       for (i = 0; i < nwords; i++)\n \t{\n@@ -1049,7 +1053,7 @@ extract_bit_field (str_rtx, bitsize, bitnum, unsignedp,\n     {\n       if (offset != 0\n \t  || GET_MODE_SIZE (GET_MODE (op0)) > UNITS_PER_WORD)\n-\top0 = gen_rtx (SUBREG, TYPE_MODE (type_for_size (BITS_PER_WORD, 0)),\n+\top0 = gen_rtx_SUBREG (TYPE_MODE (type_for_size (BITS_PER_WORD, 0)),\n \t\t       op0, offset);\n       offset = 0;\n     }\n@@ -1138,7 +1142,7 @@ extract_bit_field (str_rtx, bitsize, bitnum, unsignedp,\n \t  if (GET_CODE (xop0) == SUBREG && GET_MODE (xop0) != maxmode)\n \t    abort ();\n \t  if (GET_CODE (xop0) == REG && GET_MODE (xop0) != maxmode)\n-\t    xop0 = gen_rtx (SUBREG, maxmode, xop0, 0);\n+\t    xop0 = gen_rtx_SUBREG (maxmode, xop0, 0);\n \n \t  /* On big-endian machines, we count bits from the most significant.\n \t     If the bit field insn does not, we must invert.  */\n@@ -1272,7 +1276,7 @@ extract_bit_field (str_rtx, bitsize, bitnum, unsignedp,\n \t  if (GET_CODE (xop0) == SUBREG && GET_MODE (xop0) != maxmode)\n \t    abort ();\n \t  if (GET_CODE (xop0) == REG && GET_MODE (xop0) != maxmode)\n-\t    xop0 = gen_rtx (SUBREG, maxmode, xop0, 0);\n+\t    xop0 = gen_rtx_SUBREG (maxmode, xop0, 0);\n \n \t  /* On big-endian machines, we count bits from the most significant.\n \t     If the bit field insn does not, we must invert.  */\n@@ -1351,7 +1355,7 @@ extract_bit_field (str_rtx, bitsize, bitnum, unsignedp,\n \t\t\t\t    target, unsignedp);\n \t  if (GET_CODE (target) != REG)\n \t    target = copy_to_reg (target);\n-\t  return gen_rtx (SUBREG, tmode, target, 0);\n+\t  return gen_rtx_SUBREG (tmode, target, 0);\n \t}\n       else\n \treturn convert_to_mode (tmode, target, unsignedp);\n@@ -2197,7 +2201,7 @@ expand_mult (mode, op0, op1, target, unsignedp)\n \t and then negate, do the multiplication directly, or do multiplication\n \t by OP1 - 1.  */\n \n-      mult_cost = rtx_cost (gen_rtx (MULT, mode, op0, op1), SET);\n+      mult_cost = rtx_cost (gen_rtx_MULT (mode, op0, op1), SET);\n       mult_cost = MIN (12 * add_cost, mult_cost);\n \n       synth_mult (&alg, val, mult_cost);\n@@ -2268,15 +2272,15 @@ expand_mult (mode, op0, op1, target, unsignedp)\n \t\tcase alg_add_t_m2:\n \t\t  tem = expand_shift (LSHIFT_EXPR, mode, op0,\n \t\t\t\t      build_int_2 (log, 0), NULL_RTX, 0);\n-\t\t  accum = force_operand (gen_rtx (PLUS, mode, accum, tem),\n+\t\t  accum = force_operand (gen_rtx_PLUS (mode, accum, tem),\n \t\t\t\t\t add_target ? add_target : accum_target);\n \t\t  val_so_far += (HOST_WIDE_INT) 1 << log;\n \t\t  break;\n \n \t\tcase alg_sub_t_m2:\n \t\t  tem = expand_shift (LSHIFT_EXPR, mode, op0,\n \t\t\t\t      build_int_2 (log, 0), NULL_RTX, 0);\n-\t\t  accum = force_operand (gen_rtx (MINUS, mode, accum, tem),\n+\t\t  accum = force_operand (gen_rtx_MINUS (mode, accum, tem),\n \t\t\t\t\t add_target ? add_target : accum_target);\n \t\t  val_so_far -= (HOST_WIDE_INT) 1 << log;\n \t\t  break;\n@@ -2285,7 +2289,7 @@ expand_mult (mode, op0, op1, target, unsignedp)\n \t\t  accum = expand_shift (LSHIFT_EXPR, mode, accum,\n \t\t\t\t\tbuild_int_2 (log, 0), shift_subtarget,\n \t\t\t\t\t0);\n-\t\t  accum = force_operand (gen_rtx (PLUS, mode, accum, op0),\n+\t\t  accum = force_operand (gen_rtx_PLUS (mode, accum, op0),\n \t\t\t\t\t add_target ? add_target : accum_target);\n \t\t  val_so_far = (val_so_far << log) + 1;\n \t\t  break;\n@@ -2294,23 +2298,23 @@ expand_mult (mode, op0, op1, target, unsignedp)\n \t\t  accum = expand_shift (LSHIFT_EXPR, mode, accum,\n \t\t\t\t\tbuild_int_2 (log, 0), shift_subtarget,\n \t\t\t\t\t0);\n-\t\t  accum = force_operand (gen_rtx (MINUS, mode, accum, op0),\n+\t\t  accum = force_operand (gen_rtx_MINUS (mode, accum, op0),\n \t\t\t\t\t add_target ? add_target : accum_target);\n \t\t  val_so_far = (val_so_far << log) - 1;\n \t\t  break;\n \n \t\tcase alg_add_factor:\n \t\t  tem = expand_shift (LSHIFT_EXPR, mode, accum,\n \t\t\t\t      build_int_2 (log, 0), NULL_RTX, 0);\n-\t\t  accum = force_operand (gen_rtx (PLUS, mode, accum, tem),\n+\t\t  accum = force_operand (gen_rtx_PLUS (mode, accum, tem),\n \t\t\t\t\t add_target ? add_target : accum_target);\n \t\t  val_so_far += val_so_far << log;\n \t\t  break;\n \n \t\tcase alg_sub_factor:\n \t\t  tem = expand_shift (LSHIFT_EXPR, mode, accum,\n \t\t\t\t      build_int_2 (log, 0), NULL_RTX, 0);\n-\t\t  accum = force_operand (gen_rtx (MINUS, mode, tem, accum),\n+\t\t  accum = force_operand (gen_rtx_MINUS (mode, tem, accum),\n \t\t\t\t\t (add_target ? add_target\n \t\t\t\t\t  : preserve ? 0 : tem));\n \t\t  val_so_far = (val_so_far << log) - val_so_far;\n@@ -2325,9 +2329,9 @@ expand_mult (mode, op0, op1, target, unsignedp)\n \n \t      insn = get_last_insn ();\n \t      REG_NOTES (insn)\n-\t\t= gen_rtx (EXPR_LIST, REG_EQUAL,\n-\t\t\t   gen_rtx (MULT, mode, op0, GEN_INT (val_so_far)),\n-\t\t\t   REG_NOTES (insn));\n+\t\t= gen_rtx_EXPR_LIST (REG_EQUAL,\n+\t\t\t\t     gen_rtx_MULT (mode, op0, GEN_INT (val_so_far)),\n+\t\t\t\t     REG_NOTES (insn));\n \t    }\n \n \t  if (variant == negate_variant)\n@@ -2338,7 +2342,7 @@ expand_mult (mode, op0, op1, target, unsignedp)\n \t  else if (variant == add_variant)\n \t    {\n \t      val_so_far = val_so_far + 1;\n-\t      accum = force_operand (gen_rtx (PLUS, mode, accum, op0), target);\n+\t      accum = force_operand (gen_rtx_PLUS (mode, accum, op0), target);\n \t    }\n \n \t  if (val != val_so_far)\n@@ -2529,14 +2533,16 @@ expand_mult_highpart_adjust (mode, adj_operand, op0, op1, target, unsignedp)\n \t\t      build_int_2 (GET_MODE_BITSIZE (mode) - 1, 0),\n \t\t      NULL_RTX, 0);\n   tem = expand_and (tem, op1, NULL_RTX);\n-  adj_operand = force_operand (gen_rtx (adj_code, mode, adj_operand, tem),\n-\t\t\t       adj_operand);\n+  adj_operand\n+    = force_operand (gen_rtx_fmt_ee (adj_code, mode, adj_operand, tem),\n+\t\t     adj_operand);\n \n   tem = expand_shift (RSHIFT_EXPR, mode, op1,\n \t\t      build_int_2 (GET_MODE_BITSIZE (mode) - 1, 0),\n \t\t      NULL_RTX, 0);\n   tem = expand_and (tem, op0, NULL_RTX);\n-  target = force_operand (gen_rtx (adj_code, mode, adj_operand, tem), target);\n+  target = force_operand (gen_rtx_fmt_ee (adj_code, mode, adj_operand, tem),\n+\t\t\t  target);\n \n   return target;\n }\n@@ -2949,13 +2955,13 @@ expand_divmod (rem_flag, code, mode, op0, op1, target, unsignedp)\n \t\t\t\t\t\t       max_cost - extra_cost);\n \t\t\t    if (t1 == 0)\n \t\t\t      goto fail1;\n-\t\t\t    t2 = force_operand (gen_rtx (MINUS, compute_mode,\n-\t\t\t\t\t\t\t op0, t1),\n+\t\t\t    t2 = force_operand (gen_rtx_MINUS (compute_mode,\n+\t\t\t\t\t\t\t       op0, t1),\n \t\t\t\t\t\tNULL_RTX);\n \t\t\t    t3 = expand_shift (RSHIFT_EXPR, compute_mode, t2,\n \t\t\t\t\t       build_int_2 (1, 0), NULL_RTX,1);\n-\t\t\t    t4 = force_operand (gen_rtx (PLUS, compute_mode,\n-\t\t\t\t\t\t\t t1, t3),\n+\t\t\t    t4 = force_operand (gen_rtx_PLUS (compute_mode,\n+\t\t\t\t\t\t\t      t1, t3),\n \t\t\t\t\t\tNULL_RTX);\n \t\t\t    quotient\n \t\t\t      = expand_shift (RSHIFT_EXPR, compute_mode, t4,\n@@ -2991,9 +2997,9 @@ expand_divmod (rem_flag, code, mode, op0, op1, target, unsignedp)\n \t\t    && (set = single_set (insn)) != 0\n \t\t    && SET_DEST (set) == quotient)\n \t\t  REG_NOTES (insn)\n-\t\t    = gen_rtx (EXPR_LIST, REG_EQUAL,\n-\t\t\t       gen_rtx (UDIV, compute_mode, op0, op1),\n-\t\t\t       REG_NOTES (insn));\n+\t\t    = gen_rtx_EXPR_LIST (REG_EQUAL,\n+\t\t\t\t\t gen_rtx_UDIV (compute_mode, op0, op1),\n+\t\t\t\t\t REG_NOTES (insn));\n \t      }\n \t    else\t\t/* TRUNC_DIV, signed */\n \t      {\n@@ -3052,8 +3058,8 @@ expand_divmod (rem_flag, code, mode, op0, op1, target, unsignedp)\n \t\t\tt2 = expand_shift (RSHIFT_EXPR, compute_mode, t1,\n \t\t\t\t\t   build_int_2 (size - lgup, 0),\n \t\t\t\t\t   NULL_RTX, 1);\n-\t\t\tt3 = force_operand (gen_rtx (PLUS, compute_mode,\n-\t\t\t\t\t\t     op0, t2),\n+\t\t\tt3 = force_operand (gen_rtx_PLUS (compute_mode,\n+\t\t\t\t\t\t\t  op0, t2),\n \t\t\t\t\t    NULL_RTX);\n \t\t\tquotient = expand_shift (RSHIFT_EXPR, compute_mode, t3,\n \t\t\t\t\t\t build_int_2 (lgup, 0),\n@@ -3069,9 +3075,10 @@ expand_divmod (rem_flag, code, mode, op0, op1, target, unsignedp)\n \t\t\t    && (set = single_set (insn)) != 0\n \t\t\t    && SET_DEST (set) == quotient)\n \t\t\t  REG_NOTES (insn)\n-\t\t\t    = gen_rtx (EXPR_LIST, REG_EQUAL,\n-\t\t\t\t       gen_rtx (DIV, compute_mode, op0,\n-\t\t\t\t\t\tGEN_INT (abs_d)),\n+\t\t\t    = gen_rtx_EXPR_LIST (REG_EQUAL,\n+\t\t\t\t\t\t gen_rtx_DIV (compute_mode,\n+\t\t\t\t\t\t\t      op0,\n+\t\t\t\t\t\t\t      GEN_INT (abs_d)),\n \t\t\t\t       REG_NOTES (insn));\n \n \t\t\tquotient = expand_unop (compute_mode, neg_optab,\n@@ -3098,10 +3105,10 @@ expand_divmod (rem_flag, code, mode, op0, op1, target, unsignedp)\n \t\t\tt3 = expand_shift (RSHIFT_EXPR, compute_mode, op0,\n \t\t\t\t\t   build_int_2 (size - 1, 0), NULL_RTX, 0);\n \t\t\tif (d < 0)\n-\t\t\t  quotient = force_operand (gen_rtx (MINUS, compute_mode, t3, t2),\n+\t\t\t  quotient = force_operand (gen_rtx_MINUS (compute_mode, t3, t2),\n \t\t\t\t\t\t    tquotient);\n \t\t\telse\n-\t\t\t  quotient = force_operand (gen_rtx (MINUS, compute_mode, t2, t3),\n+\t\t\t  quotient = force_operand (gen_rtx_MINUS (compute_mode, t2, t3),\n \t\t\t\t\t\t    tquotient);\n \t\t      }\n \t\t    else\n@@ -3116,17 +3123,17 @@ expand_divmod (rem_flag, code, mode, op0, op1, target, unsignedp)\n \t\t\t\t\t\t   max_cost - extra_cost);\n \t\t\tif (t1 == 0)\n \t\t\t  goto fail1;\n-\t\t\tt2 = force_operand (gen_rtx (PLUS, compute_mode, t1, op0),\n+\t\t\tt2 = force_operand (gen_rtx_PLUS (compute_mode, t1, op0),\n \t\t\t\t\t    NULL_RTX);\n \t\t\tt3 = expand_shift (RSHIFT_EXPR, compute_mode, t2,\n \t\t\t\t\t   build_int_2 (post_shift, 0), NULL_RTX, 0);\n \t\t\tt4 = expand_shift (RSHIFT_EXPR, compute_mode, op0,\n \t\t\t\t\t   build_int_2 (size - 1, 0), NULL_RTX, 0);\n \t\t\tif (d < 0)\n-\t\t\t  quotient = force_operand (gen_rtx (MINUS, compute_mode, t4, t3),\n+\t\t\t  quotient = force_operand (gen_rtx_MINUS (compute_mode, t4, t3),\n \t\t\t\t\t\t    tquotient);\n \t\t\telse\n-\t\t\t  quotient = force_operand (gen_rtx (MINUS, compute_mode, t3, t4),\n+\t\t\t  quotient = force_operand (gen_rtx_MINUS (compute_mode, t3, t4),\n \t\t\t\t\t\t    tquotient);\n \t\t      }\n \t\t  }\n@@ -3138,9 +3145,9 @@ expand_divmod (rem_flag, code, mode, op0, op1, target, unsignedp)\n \t\t    && (set = single_set (insn)) != 0\n \t\t    && SET_DEST (set) == quotient)\n \t\t  REG_NOTES (insn)\n-\t\t    = gen_rtx (EXPR_LIST, REG_EQUAL,\n-\t\t\t       gen_rtx (DIV, compute_mode, op0, op1),\n-\t\t\t       REG_NOTES (insn));\n+\t\t    = gen_rtx_EXPR_LIST (REG_EQUAL,\n+\t\t\t\t\t gen_rtx_DIV (compute_mode, op0, op1),\n+\t\t\t\t\t REG_NOTES (insn));\n \t      }\n \t    break;\n \t  }\n@@ -3208,13 +3215,13 @@ expand_divmod (rem_flag, code, mode, op0, op1, target, unsignedp)\n \t    else\n \t      {\n \t\trtx nsign, t1, t2, t3, t4;\n-\t\tt1 = force_operand (gen_rtx (PLUS, compute_mode,\n-\t\t\t\t\t     op0, constm1_rtx), NULL_RTX);\n+\t\tt1 = force_operand (gen_rtx_PLUS (compute_mode,\n+\t\t\t\t\t\t  op0, constm1_rtx), NULL_RTX);\n \t\tt2 = expand_binop (compute_mode, ior_optab, op0, t1, NULL_RTX,\n \t\t\t\t   0, OPTAB_WIDEN);\n \t\tnsign = expand_shift (RSHIFT_EXPR, compute_mode, t2,\n \t\t\t\t      build_int_2 (size - 1, 0), NULL_RTX, 0);\n-\t\tt3 = force_operand (gen_rtx (MINUS, compute_mode, t1, nsign),\n+\t\tt3 = force_operand (gen_rtx_MINUS (compute_mode, t1, nsign),\n \t\t\t\t    NULL_RTX);\n \t\tt4 = expand_divmod (0, TRUNC_DIV_EXPR, compute_mode, t3, op1,\n \t\t\t\t    NULL_RTX, 0);\n@@ -3223,8 +3230,8 @@ expand_divmod (rem_flag, code, mode, op0, op1, target, unsignedp)\n \t\t    rtx t5;\n \t\t    t5 = expand_unop (compute_mode, one_cmpl_optab, nsign,\n \t\t\t\t      NULL_RTX, 0);\n-\t\t    quotient = force_operand (gen_rtx (PLUS, compute_mode,\n-\t\t\t\t\t\t       t4, t5),\n+\t\t    quotient = force_operand (gen_rtx_PLUS (compute_mode,\n+\t\t\t\t\t\t\t    t4, t5),\n \t\t\t\t\t      tquotient);\n \t\t  }\n \t      }\n@@ -3355,8 +3362,8 @@ expand_divmod (rem_flag, code, mode, op0, op1, target, unsignedp)\n \t\t    quotient = t1;\n \t\t  }\n \t\telse\n-\t\t  quotient = force_operand (gen_rtx (PLUS, compute_mode,\n-\t\t\t\t\t\t     t1, t3),\n+\t\t  quotient = force_operand (gen_rtx_PLUS (compute_mode,\n+\t\t\t\t\t\t\t  t1, t3),\n \t\t\t\t\t    tquotient);\n \t\tbreak;\n \t      }\n@@ -3457,8 +3464,8 @@ expand_divmod (rem_flag, code, mode, op0, op1, target, unsignedp)\n \t\t    quotient = t1;\n \t\t  }\n \t\telse\n-\t\t  quotient = force_operand (gen_rtx (PLUS, compute_mode,\n-\t\t\t\t\t\t     t1, t3),\n+\t\t  quotient = force_operand (gen_rtx_PLUS (compute_mode,\n+\t\t\t\t\t\t\t  t1, t3),\n \t\t\t\t\t    tquotient);\n \t\tbreak;\n \t      }\n@@ -3575,10 +3582,11 @@ expand_divmod (rem_flag, code, mode, op0, op1, target, unsignedp)\n \n \t    insn = get_last_insn ();\n \t    REG_NOTES (insn)\n-\t      = gen_rtx (EXPR_LIST, REG_EQUAL,\n-\t\t\t gen_rtx (unsignedp ? UDIV : DIV, compute_mode,\n-\t\t\t\t  op0, op1),\n-\t\t\t REG_NOTES (insn));\n+\t      = gen_rtx_EXPR_LIST (REG_EQUAL,\n+\t\t\t\t   gen_rtx_fmt_ee (unsignedp ? UDIV : DIV,\n+\t\t\t\t\t\t   compute_mode,\n+\t\t\t\t\t\t   op0, op1),\n+\t\t\t\t   REG_NOTES (insn));\n \t  }\n \tbreak;\n "}, {"sha": "05af3dac72429a8fefcc2ebb5edfd8c375d386f6", "filename": "gcc/expr.c", "status": "modified", "additions": 151, "deletions": 147, "changes": 298, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38a448ca5dfe60244ab3c1f0ea8e3604ec69370b/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38a448ca5dfe60244ab3c1f0ea8e3604ec69370b/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=38a448ca5dfe60244ab3c1f0ea8e3604ec69370b", "patch": "@@ -298,11 +298,11 @@ init_expr_once ()\n   /* Try indexing by frame ptr and try by stack ptr.\n      It is known that on the Convex the stack ptr isn't a valid index.\n      With luck, one or the other is valid on any machine.  */\n-  rtx mem = gen_rtx (MEM, VOIDmode, stack_pointer_rtx);\n-  rtx mem1 = gen_rtx (MEM, VOIDmode, frame_pointer_rtx);\n+  rtx mem = gen_rtx_MEM (VOIDmode, stack_pointer_rtx);\n+  rtx mem1 = gen_rtx_MEM (VOIDmode, frame_pointer_rtx);\n \n   start_sequence ();\n-  insn = emit_insn (gen_rtx (SET, 0, NULL_RTX, NULL_RTX));\n+  insn = emit_insn (gen_rtx_SET (0, NULL_RTX, NULL_RTX));\n   pat = PATTERN (insn);\n \n   for (mode = VOIDmode; (int) mode < NUM_MACHINE_MODES;\n@@ -327,7 +327,7 @@ init_expr_once ()\n \t    if (! HARD_REGNO_MODE_OK (regno, mode))\n \t      continue;\n \n-\t    reg = gen_rtx (REG, mode, regno);\n+\t    reg = gen_rtx_REG (mode, regno);\n \n \t    SET_SRC (pat) = mem;\n \t    SET_DEST (pat) = reg;\n@@ -421,8 +421,9 @@ static rtx\n enqueue_insn (var, body)\n      rtx var, body;\n {\n-  pending_chain = gen_rtx (QUEUED, GET_MODE (var),\n-\t\t\t   var, NULL_RTX, NULL_RTX, body, pending_chain);\n+  pending_chain = gen_rtx_QUEUED (GET_MODE (var),\n+\t\t\t\t  var, NULL_RTX, NULL_RTX, body,\n+\t\t\t\t  pending_chain);\n   return pending_chain;\n }\n \n@@ -465,7 +466,7 @@ protect_from_queue (x, modify)\n \t  && GET_CODE (XEXP (x, 0)) == QUEUED && !modify)\n \t{\n \t  register rtx y = XEXP (x, 0);\n-\t  register rtx new = gen_rtx (MEM, GET_MODE (x), QUEUED_VAR (y));\n+\t  register rtx new = gen_rtx_MEM (GET_MODE (x), QUEUED_VAR (y));\n \n \t  MEM_IN_STRUCT_P (new) = MEM_IN_STRUCT_P (x);\n \t  RTX_UNCHANGING_P (new) = RTX_UNCHANGING_P (x);\n@@ -892,7 +893,7 @@ convert_move (to, from, unsignedp)\n \t\t   != CODE_FOR_nothing))\n \t{\n \t  if (GET_CODE (to) == REG)\n-\t    emit_insn (gen_rtx (CLOBBER, VOIDmode, to));\n+\t    emit_insn (gen_rtx_CLOBBER (VOIDmode, to));\n \t  convert_move (gen_lowpart (word_mode, to), from, unsignedp);\n \t  emit_unop_insn (code, to,\n \t\t\t  gen_lowpart (word_mode, to), equiv_code);\n@@ -962,7 +963,7 @@ convert_move (to, from, unsignedp)\n       end_sequence ();\n \n       emit_no_conflict_block (insns, to, from, NULL_RTX,\n-\t\t\t      gen_rtx (equiv_code, to_mode, copy_rtx (from)));\n+\t\t\t      gen_rtx_fmt_e (equiv_code, to_mode, copy_rtx (from)));\n       return;\n     }\n \n@@ -1550,15 +1551,15 @@ move_by_pieces_1 (genfun, mode, data)\n       if (data->reverse) data->offset -= size;\n \n       to1 = (data->autinc_to\n-\t     ? gen_rtx (MEM, mode, data->to_addr)\n+\t     ? gen_rtx_MEM (mode, data->to_addr)\n \t     : copy_rtx (change_address (data->to, mode,\n \t\t\t\t\t plus_constant (data->to_addr,\n \t\t\t\t\t\t\tdata->offset))));\n       MEM_IN_STRUCT_P (to1) = data->to_struct;\n \n       from1\n \t= (data->autinc_from\n-\t   ? gen_rtx (MEM, mode, data->from_addr)\n+\t   ? gen_rtx_MEM (mode, data->from_addr)\n \t   : copy_rtx (change_address (data->from, mode,\n \t\t\t\t       plus_constant (data->from_addr,\n \t\t\t\t\t\t      data->offset))));\n@@ -1722,7 +1723,7 @@ move_block_to_reg (regno, x, nregs, mode)\n   if (HAVE_load_multiple)\n     {\n       last = get_last_insn ();\n-      pat = gen_load_multiple (gen_rtx (REG, word_mode, regno), x,\n+      pat = gen_load_multiple (gen_rtx_REG (word_mode, regno), x,\n \t\t\t       GEN_INT (nregs));\n       if (pat)\n \t{\n@@ -1735,7 +1736,7 @@ move_block_to_reg (regno, x, nregs, mode)\n #endif\n \n   for (i = 0; i < nregs; i++)\n-    emit_move_insn (gen_rtx (REG, word_mode, regno + i),\n+    emit_move_insn (gen_rtx_REG (word_mode, regno + i),\n \t\t    operand_subword_force (x, i, mode));\n }\n \n@@ -1761,7 +1762,7 @@ move_block_from_reg (regno, x, nregs, size)\n       && (mode = mode_for_size (size * BITS_PER_UNIT, MODE_INT, 0)) != BLKmode)\n     {\n       emit_move_insn (change_address (x, mode, NULL),\n-\t\t      gen_rtx (REG, mode, regno));\n+\t\t      gen_rtx_REG (mode, regno));\n       return;\n     }\n     \n@@ -1777,7 +1778,7 @@ move_block_from_reg (regno, x, nregs, size)\n \tabort ();\n \n       shift = expand_shift (LSHIFT_EXPR, word_mode,\n-\t\t\t    gen_rtx (REG, word_mode, regno),\n+\t\t\t    gen_rtx_REG (word_mode, regno),\n \t\t\t    build_int_2 ((UNITS_PER_WORD - size)\n \t\t\t\t\t * BITS_PER_UNIT, 0), NULL_RTX, 0);\n       emit_move_insn (tem, shift);\n@@ -1789,7 +1790,7 @@ move_block_from_reg (regno, x, nregs, size)\n   if (HAVE_store_multiple)\n     {\n       last = get_last_insn ();\n-      pat = gen_store_multiple (x, gen_rtx (REG, word_mode, regno),\n+      pat = gen_store_multiple (x, gen_rtx_REG (word_mode, regno),\n \t\t\t\tGEN_INT (nregs));\n       if (pat)\n \t{\n@@ -1808,7 +1809,7 @@ move_block_from_reg (regno, x, nregs, size)\n       if (tem == 0)\n \tabort ();\n \n-      emit_move_insn (tem, gen_rtx (REG, word_mode, regno + i));\n+      emit_move_insn (tem, gen_rtx_REG (word_mode, regno + i));\n     }\n }\n \n@@ -1923,8 +1924,8 @@ use_reg (call_fusage, reg)\n     abort();\n \n   *call_fusage\n-    = gen_rtx (EXPR_LIST, VOIDmode,\n-\t       gen_rtx (USE, VOIDmode, reg), *call_fusage);\n+    = gen_rtx_EXPR_LIST (VOIDmode,\n+\t\t\t gen_rtx_USE (VOIDmode, reg), *call_fusage);\n }\n \n /* Add USE expressions to *CALL_FUSAGE for each of NREGS consecutive regs,\n@@ -1942,7 +1943,7 @@ use_regs (call_fusage, regno, nregs)\n     abort ();\n \n   for (i = 0; i < nregs; i++)\n-    use_reg (call_fusage, gen_rtx (REG, reg_raw_mode[regno + i], regno + i));\n+    use_reg (call_fusage, gen_rtx_REG (reg_raw_mode[regno + i], regno + i));\n }\n \n /* Add USE expressions to *CALL_FUSAGE for each REG contained in the\n@@ -2075,7 +2076,7 @@ clear_by_pieces_1 (genfun, mode, data)\n       if (data->reverse) data->offset -= size;\n \n       to1 = (data->autinc_to\n-\t     ? gen_rtx (MEM, mode, data->to_addr)\n+\t     ? gen_rtx_MEM (mode, data->to_addr)\n \t     : copy_rtx (change_address (data->to, mode,\n \t\t\t\t\t plus_constant (data->to_addr,\n \t\t\t\t\t\t\tdata->offset))));\n@@ -2286,17 +2287,17 @@ emit_move_insn_1 (x, y)\n \t     regardless of machine's endianness.  */\n #ifdef STACK_GROWS_DOWNWARD\n \t  emit_insn (GEN_FCN (mov_optab->handlers[(int) submode].insn_code)\n-\t\t     (gen_rtx (MEM, submode, (XEXP (x, 0))),\n+\t\t     (gen_rtx_MEM (submode, (XEXP (x, 0))),\n \t\t      gen_imagpart (submode, y)));\n \t  emit_insn (GEN_FCN (mov_optab->handlers[(int) submode].insn_code)\n-\t\t     (gen_rtx (MEM, submode, (XEXP (x, 0))),\n+\t\t     (gen_rtx_MEM (submode, (XEXP (x, 0))),\n \t\t      gen_realpart (submode, y)));\n #else\n \t  emit_insn (GEN_FCN (mov_optab->handlers[(int) submode].insn_code)\n-\t\t     (gen_rtx (MEM, submode, (XEXP (x, 0))),\n+\t\t     (gen_rtx_MEM (submode, (XEXP (x, 0))),\n \t\t      gen_realpart (submode, y)));\n \t  emit_insn (GEN_FCN (mov_optab->handlers[(int) submode].insn_code)\n-\t\t     (gen_rtx (MEM, submode, (XEXP (x, 0))),\n+\t\t     (gen_rtx_MEM (submode, (XEXP (x, 0))),\n \t\t      gen_imagpart (submode, y)));\n #endif\n \t}\n@@ -2332,7 +2333,7 @@ emit_move_insn_1 (x, y)\n \t\t\t     \n       /* Show the output dies here.  */\n       if (x != y)\n-        emit_insn (gen_rtx (CLOBBER, VOIDmode, x));\n+        emit_insn (gen_rtx_CLOBBER (VOIDmode, x));\n \n       for (i = 0;\n \t   i < (GET_MODE_SIZE (mode)  + (UNITS_PER_WORD - 1)) / UNITS_PER_WORD;\n@@ -2405,10 +2406,10 @@ push_block (size, extra, below)\n     temp = plus_constant (virtual_outgoing_args_rtx,\n \t\t\t  - INTVAL (size) - (below ? 0 : extra));\n   else if (extra != 0 && !below)\n-    temp = gen_rtx (PLUS, Pmode, virtual_outgoing_args_rtx,\n+    temp = gen_rtx_PLUS (Pmode, virtual_outgoing_args_rtx,\n \t\t    negate_rtx (Pmode, plus_constant (size, extra)));\n   else\n-    temp = gen_rtx (PLUS, Pmode, virtual_outgoing_args_rtx,\n+    temp = gen_rtx_PLUS (Pmode, virtual_outgoing_args_rtx,\n \t\t    negate_rtx (Pmode, size));\n #endif\n \n@@ -2418,7 +2419,7 @@ push_block (size, extra, below)\n rtx\n gen_push_operand ()\n {\n-  return gen_rtx (STACK_PUSH_CODE, Pmode, stack_pointer_rtx);\n+  return gen_rtx_fmt_e (STACK_PUSH_CODE, Pmode, stack_pointer_rtx);\n }\n \n /* Return an rtx for the address of the beginning of a as-if-it-was-pushed\n@@ -2431,9 +2432,9 @@ get_push_address (size)\n   register rtx temp;\n \n   if (STACK_PUSH_CODE == POST_DEC)\n-    temp = gen_rtx (PLUS, Pmode, stack_pointer_rtx, GEN_INT (size));\n+    temp = gen_rtx_PLUS (Pmode, stack_pointer_rtx, GEN_INT (size));\n   else if (STACK_PUSH_CODE == POST_INC)\n-    temp = gen_rtx (MINUS, Pmode, stack_pointer_rtx, GEN_INT (size));\n+    temp = gen_rtx_MINUS (Pmode, stack_pointer_rtx, GEN_INT (size));\n   else\n     temp = stack_pointer_rtx;\n \n@@ -2557,7 +2558,7 @@ emit_push_insn (x, mode, type, size, align, partial, reg, extra,\n \t      && where_pad != none && where_pad != stack_direction)\n \t    anti_adjust_stack (GEN_INT (extra));\n \n-\t  move_by_pieces (gen_rtx (MEM, BLKmode, gen_push_operand ()), xinner,\n+\t  move_by_pieces (gen_rtx_MEM (BLKmode, gen_push_operand ()), xinner,\n \t\t\t  INTVAL (size) - used, align);\n \n \t  if (flag_check_memory_usage && ! in_check_memory_usage)\n@@ -2613,8 +2614,9 @@ emit_push_insn (x, mode, type, size, align, partial, reg, extra,\n \t\t\t\t\t\t  skip + INTVAL (args_so_far)));\n \t  else\n \t    temp = memory_address (BLKmode,\n-\t\t\t\t   plus_constant (gen_rtx (PLUS, Pmode,\n-\t\t\t\t\t\t\t   args_addr, args_so_far),\n+\t\t\t\t   plus_constant (gen_rtx_PLUS (Pmode,\n+\t\t\t\t\t\t\t\targs_addr,\n+\t\t\t\t\t\t\t\targs_so_far),\n \t\t\t\t\t\t  skip));\n \t  if (flag_check_memory_usage && ! in_check_memory_usage)\n \t    {\n@@ -2641,7 +2643,7 @@ emit_push_insn (x, mode, type, size, align, partial, reg, extra,\n \t      && (move_by_pieces_ninsns ((unsigned) INTVAL (size), align)\n \t\t  < MOVE_RATIO))\n \t    {\n-\t      move_by_pieces (gen_rtx (MEM, BLKmode, temp), xinner,\n+\t      move_by_pieces (gen_rtx_MEM (BLKmode, temp), xinner,\n \t\t\t      INTVAL (size), align);\n \t      goto ret;\n \t    }\n@@ -2654,7 +2656,7 @@ emit_push_insn (x, mode, type, size, align, partial, reg, extra,\n \t      && ((unsigned) INTVAL (size)\n \t\t  < (1 << (GET_MODE_BITSIZE (QImode) - 1))))\n \t    {\n-\t      rtx pat = gen_movstrqi (gen_rtx (MEM, BLKmode, temp),\n+\t      rtx pat = gen_movstrqi (gen_rtx_MEM (BLKmode, temp),\n \t\t\t\t      xinner, size, GEN_INT (align));\n \t      if (pat != 0)\n \t\t{\n@@ -2669,7 +2671,7 @@ emit_push_insn (x, mode, type, size, align, partial, reg, extra,\n \t      && ((unsigned) INTVAL (size)\n \t\t  < (1 << (GET_MODE_BITSIZE (HImode) - 1))))\n \t    {\n-\t      rtx pat = gen_movstrhi (gen_rtx (MEM, BLKmode, temp),\n+\t      rtx pat = gen_movstrhi (gen_rtx_MEM (BLKmode, temp),\n \t\t\t\t      xinner, size, GEN_INT (align));\n \t      if (pat != 0)\n \t\t{\n@@ -2681,7 +2683,7 @@ emit_push_insn (x, mode, type, size, align, partial, reg, extra,\n #ifdef HAVE_movstrsi\n \t  if (HAVE_movstrsi)\n \t    {\n-\t      rtx pat = gen_movstrsi (gen_rtx (MEM, BLKmode, temp),\n+\t      rtx pat = gen_movstrsi (gen_rtx_MEM (BLKmode, temp),\n \t\t\t\t      xinner, size, GEN_INT (align));\n \t      if (pat != 0)\n \t\t{\n@@ -2693,7 +2695,7 @@ emit_push_insn (x, mode, type, size, align, partial, reg, extra,\n #ifdef HAVE_movstrdi\n \t  if (HAVE_movstrdi)\n \t    {\n-\t      rtx pat = gen_movstrdi (gen_rtx (MEM, BLKmode, temp),\n+\t      rtx pat = gen_movstrdi (gen_rtx_MEM (BLKmode, temp),\n \t\t\t\t      xinner, size, GEN_INT (align));\n \t      if (pat != 0)\n \t\t{\n@@ -2821,12 +2823,12 @@ emit_push_insn (x, mode, type, size, align, partial, reg, extra,\n \t\t\t\tplus_constant (args_addr, \n \t\t\t\t\t       INTVAL (args_so_far)));\n           else\n-\t    addr = memory_address (mode, gen_rtx (PLUS, Pmode, args_addr,\n-\t\t\t\t\t\t  args_so_far));\n+\t    addr = memory_address (mode, gen_rtx_PLUS (Pmode, args_addr,\n+\t\t\t\t\t\t       args_so_far));\n \t  target = addr;\n \t}\n \n-      emit_move_insn (gen_rtx (MEM, mode, addr), x);\n+      emit_move_insn (gen_rtx_MEM (mode, addr), x);\n \n       if (flag_check_memory_usage && ! in_check_memory_usage)\n \t{\n@@ -2949,8 +2951,8 @@ expand_assignment (to, from, want_value, suggest_reg)\n \t  if (GET_CODE (to_rtx) != MEM)\n \t    abort ();\n \t  to_rtx = change_address (to_rtx, VOIDmode,\n-\t\t\t\t   gen_rtx (PLUS, ptr_mode, XEXP (to_rtx, 0),\n-\t\t\t\t\t    force_reg (ptr_mode, offset_rtx)));\n+\t\t\t\t   gen_rtx_PLUS (ptr_mode, XEXP (to_rtx, 0),\n+\t\t\t\t\t\t force_reg (ptr_mode, offset_rtx)));\n \t}\n       if (volatilep)\n \t{\n@@ -3627,7 +3629,7 @@ store_constructor (exp, target, cleared)\n       /* Inform later passes that the whole union value is dead.  */\n       if (TREE_CODE (type) == UNION_TYPE\n \t  || TREE_CODE (type) == QUAL_UNION_TYPE)\n-\temit_insn (gen_rtx (CLOBBER, VOIDmode, target));\n+\temit_insn (gen_rtx_CLOBBER (VOIDmode, target));\n \n       /* If we are building a static constructor into a register,\n \t set the initial value as zero so we can fold the value into\n@@ -3657,7 +3659,7 @@ store_constructor (exp, target, cleared)\n \t}\n       else\n \t/* Inform later passes that the old value is dead.  */\n-\temit_insn (gen_rtx (CLOBBER, VOIDmode, target));\n+\temit_insn (gen_rtx_CLOBBER (VOIDmode, target));\n \n       /* Store each element of the constructor into\n \t the corresponding field of TARGET.  */\n@@ -3716,7 +3718,7 @@ store_constructor (exp, target, cleared)\n \n \t      to_rtx\n \t\t= change_address (to_rtx, VOIDmode,\n-\t\t\t\t  gen_rtx (PLUS, ptr_mode, XEXP (to_rtx, 0),\n+\t\t\t\t  gen_rtx_PLUS (ptr_mode, XEXP (to_rtx, 0),\n \t\t\t\t\t   force_reg (ptr_mode, offset_rtx)));\n \t    }\n \t  if (TREE_READONLY (field))\n@@ -3793,7 +3795,7 @@ store_constructor (exp, target, cleared)\n \t}\n       else\n \t/* Inform later passes that the old value is dead.  */\n-\temit_insn (gen_rtx (CLOBBER, VOIDmode, target));\n+\temit_insn (gen_rtx_CLOBBER (VOIDmode, target));\n \n       /* Store each element of the constructor into\n \t the corresponding element of TARGET, determined\n@@ -3879,7 +3881,7 @@ store_constructor (exp, target, cleared)\n \t\t\t\t\t\t     TYPE_MIN_VALUE (domain)),\n \t\t\t\t\t position);\n \t\t  pos_rtx = expand_expr (position, 0, VOIDmode, 0);\n-\t\t  addr = gen_rtx (PLUS, Pmode, XEXP (target, 0), pos_rtx);\n+\t\t  addr = gen_rtx_PLUS (Pmode, XEXP (target, 0), pos_rtx);\n \t\t  xtarget = change_address (target, mode, addr);\n \t\t  if (TREE_CODE (value) == CONSTRUCTOR)\n \t\t    store_constructor (value, xtarget, cleared);\n@@ -3899,7 +3901,7 @@ store_constructor (exp, target, cleared)\n \t\t  /* Needed by stupid register allocation. to extend the\n \t\t     lifetime of pseudo-regs used by target past the end\n \t\t     of the loop.  */\n-\t\t  emit_insn (gen_rtx (USE, GET_MODE (target), target));\n+\t\t  emit_insn (gen_rtx_USE (GET_MODE (target), target));\n \t\t}\n \t    }\n \t  else if ((index != 0 && TREE_CODE (index) != INTEGER_CST)\n@@ -3918,7 +3920,7 @@ store_constructor (exp, target, cleared)\n \t\t\t\t     size_int (BITS_PER_UNIT));\n \t      position = size_binop (MULT_EXPR, index, position);\n \t      pos_rtx = expand_expr (position, 0, VOIDmode, 0);\n-\t      addr = gen_rtx (PLUS, Pmode, XEXP (target, 0), pos_rtx);\n+\t      addr = gen_rtx_PLUS (Pmode, XEXP (target, 0), pos_rtx);\n \t      xtarget = change_address (target, mode, addr);\n \t      store_expr (value, xtarget, 0);\n \t    }\n@@ -4103,7 +4105,7 @@ store_constructor (exp, target, cleared)\n \t  else\n #endif\n \t    {\n-\t      emit_library_call (gen_rtx (SYMBOL_REF, Pmode, \"__setbits\"),\n+\t      emit_library_call (gen_rtx_SYMBOL_REF (Pmode, \"__setbits\"),\n \t\t\t\t 0, VOIDmode, 4, XEXP (targetx, 0), Pmode,\n \t\t\t\t bitlength_rtx, TYPE_MODE (sizetype),\n \t\t\t\t startbit_rtx, TYPE_MODE (sizetype),\n@@ -4997,15 +4999,16 @@ expand_expr (exp, target, tmode, modifier)\n \t    push_obstacks (p->function_obstack,\n \t\t\t   p->function_maybepermanent_obstack);\n \n-\t    p->forced_labels = gen_rtx (EXPR_LIST, VOIDmode,\n-\t\t\t\t\tlabel_rtx (exp), p->forced_labels);\n+\t    p->forced_labels = gen_rtx_EXPR_LIST (VOIDmode,\n+\t\t\t\t\t\t  label_rtx (exp),\n+\t\t\t\t\t\t  p->forced_labels);\n \t    pop_obstacks ();\n \t  }\n \telse if (modifier == EXPAND_INITIALIZER)\n-\t  forced_labels = gen_rtx (EXPR_LIST, VOIDmode,\n-\t\t\t\t   label_rtx (exp), forced_labels);\n-\ttemp = gen_rtx (MEM, FUNCTION_MODE,\n-\t\t\tgen_rtx (LABEL_REF, Pmode, label_rtx (exp)));\n+\t  forced_labels = gen_rtx_EXPR_LIST (VOIDmode,\n+\t\t\t\t\t     label_rtx (exp), forced_labels);\n+\ttemp = gen_rtx_MEM (FUNCTION_MODE,\n+\t\t\t    gen_rtx_LABEL_REF (Pmode, label_rtx (exp)));\n \tif (function != current_function_decl\n \t    && function != inline_function_decl && function != 0)\n \t  LABEL_REF_NONLOCAL_P (XEXP (temp, 0)) = 1;\n@@ -5099,8 +5102,8 @@ expand_expr (exp, target, tmode, modifier)\n \t    abort ();\n \t  addr = XEXP (DECL_RTL (exp), 0);\n \t  if (GET_CODE (addr) == MEM)\n-\t    addr = gen_rtx (MEM, Pmode,\n-\t\t\t    fix_lexical_addr (XEXP (addr, 0), exp));\n+\t    addr = gen_rtx_MEM (Pmode,\n+\t\t\t\tfix_lexical_addr (XEXP (addr, 0), exp));\n \t  else\n \t    addr = fix_lexical_addr (addr, exp);\n \t  temp = change_address (DECL_RTL (exp), mode, addr);\n@@ -5154,7 +5157,7 @@ expand_expr (exp, target, tmode, modifier)\n \t      != promote_mode (type, DECL_MODE (exp), &unsignedp, 0))\n \t    abort ();\n \n-\t  temp = gen_rtx (SUBREG, mode, DECL_RTL (exp), 0);\n+\t  temp = gen_rtx_SUBREG (mode, DECL_RTL (exp), 0);\n \t  SUBREG_PROMOTED_VAR_P (temp) = 1;\n \t  SUBREG_PROMOTED_UNSIGNED_P (temp) = unsignedp;\n \t  return temp;\n@@ -5245,8 +5248,8 @@ expand_expr (exp, target, tmode, modifier)\n \n \t  SAVE_EXPR_RTL (exp) = temp;\n \t  if (!optimize && GET_CODE (temp) == REG)\n-\t    save_expr_regs = gen_rtx (EXPR_LIST, VOIDmode, temp,\n-\t\t\t\t      save_expr_regs);\n+\t    save_expr_regs = gen_rtx_EXPR_LIST (VOIDmode, temp,\n+\t\t\t\t\t\tsave_expr_regs);\n \n \t  /* If the mode of TEMP does not match that of the expression, it\n \t     must be a promoted value.  We pass store_expr a SUBREG of the\n@@ -5256,7 +5259,7 @@ expand_expr (exp, target, tmode, modifier)\n \n \t  if (GET_CODE (temp) == REG && GET_MODE (temp) != mode)\n \t    {\n-\t      temp = gen_rtx (SUBREG, mode, SAVE_EXPR_RTL (exp), 0);\n+\t      temp = gen_rtx_SUBREG (mode, SAVE_EXPR_RTL (exp), 0);\n \t      SUBREG_PROMOTED_VAR_P (temp) = 1;\n \t      SUBREG_PROMOTED_UNSIGNED_P (temp) = unsignedp;\n \t    }\n@@ -5277,7 +5280,7 @@ expand_expr (exp, target, tmode, modifier)\n \t{\n \t  /* Compute the signedness and make the proper SUBREG.  */\n \t  promote_mode (type, mode, &unsignedp, 0);\n-\t  temp = gen_rtx (SUBREG, mode, SAVE_EXPR_RTL (exp), 0);\n+\t  temp = gen_rtx_SUBREG (mode, SAVE_EXPR_RTL (exp), 0);\n \t  SUBREG_PROMOTED_VAR_P (temp) = 1;\n \t  SUBREG_PROMOTED_UNSIGNED_P (temp) = unsignedp;\n \t  return temp;\n@@ -5524,7 +5527,7 @@ expand_expr (exp, target, tmode, modifier)\n \t      }\n \t  }\n \n-\ttemp = gen_rtx (MEM, mode, op0);\n+\ttemp = gen_rtx_MEM (mode, op0);\n \t/* If address was computed by addition,\n \t   mark this as an element of an aggregate.  */\n \tif (TREE_CODE (TREE_OPERAND (exp, 0)) == PLUS_EXPR\n@@ -5752,8 +5755,8 @@ expand_expr (exp, target, tmode, modifier)\n #endif\n \n \t    op0 = change_address (op0, VOIDmode,\n-\t\t\t\t  gen_rtx (PLUS, ptr_mode, XEXP (op0, 0),\n-\t\t\t\t\t   force_reg (ptr_mode, offset_rtx)));\n+\t\t\t\t  gen_rtx_PLUS (ptr_mode, XEXP (op0, 0),\n+\t\t\t\t\t\tforce_reg (ptr_mode, offset_rtx)));\n \t  }\n \n \t/* Don't forget about volatility even if this is a bitfield.  */\n@@ -5880,8 +5883,8 @@ expand_expr (exp, target, tmode, modifier)\n \t/* Get a reference to just this component.  */\n \tif (modifier == EXPAND_CONST_ADDRESS\n \t    || modifier == EXPAND_SUM || modifier == EXPAND_INITIALIZER)\n-\t  op0 = gen_rtx (MEM, mode1, plus_constant (XEXP (op0, 0),\n-\t\t\t\t\t\t    (bitpos / BITS_PER_UNIT)));\n+\t  op0 = gen_rtx_MEM (mode1, plus_constant (XEXP (op0, 0),\n+\t\t\t\t\t\t   (bitpos / BITS_PER_UNIT)));\n \telse\n \t  op0 = change_address (op0, mode1,\n \t\t\t\tplus_constant (XEXP (op0, 0),\n@@ -5999,7 +6002,7 @@ expand_expr (exp, target, tmode, modifier)\n \n \t/* Extract the bit we want to examine */\n \tbit = expand_shift (RSHIFT_EXPR, byte_mode,\n-\t\t\t    gen_rtx (MEM, byte_mode, addr),\n+\t\t\t    gen_rtx_MEM (byte_mode, addr),\n \t\t\t    make_tree (TREE_TYPE (index), rem),\n \t\t\t    NULL_RTX, 1);\n \tresult = expand_binop (byte_mode, and_optab, bit, const1_rtx,\n@@ -6121,7 +6124,7 @@ expand_expr (exp, target, tmode, modifier)\n \t\t\t op0, TREE_UNSIGNED (TREE_TYPE (TREE_OPERAND (exp, 0))));\n \n       if (modifier == EXPAND_INITIALIZER)\n-\treturn gen_rtx (unsignedp ? ZERO_EXTEND : SIGN_EXTEND, mode, op0);\n+\treturn gen_rtx_fmt_e (unsignedp ? ZERO_EXTEND : SIGN_EXTEND, mode, op0);\n \n       if (target == 0)\n \treturn\n@@ -6244,9 +6247,9 @@ expand_expr (exp, target, tmode, modifier)\n \t    op0 = temp;\n \t  /* Ensure that MULT comes first if there is one.  */\n \t  else if (GET_CODE (op0) == MULT)\n-\t    op0 = gen_rtx (PLUS, mode, op0, XEXP (op1, 0));\n+\t    op0 = gen_rtx_PLUS (mode, op0, XEXP (op1, 0));\n \t  else\n-\t    op0 = gen_rtx (PLUS, mode, XEXP (op1, 0), op0);\n+\t    op0 = gen_rtx_PLUS (mode, XEXP (op1, 0), op0);\n \n \t  /* Let's also eliminate constants from op0 if possible.  */\n \t  op0 = eliminate_constant_term (op0, &constant_term);\n@@ -6260,15 +6263,15 @@ expand_expr (exp, target, tmode, modifier)\n \t  if (temp != 0)\n \t    op1 = temp;\n \t  else\n-\t    op1 = gen_rtx (PLUS, mode, constant_term, XEXP (op1, 1));\n+\t    op1 = gen_rtx_PLUS (mode, constant_term, XEXP (op1, 1));\n \t}\n \n       /* Put a constant term last and put a multiplication first.  */\n       if (CONSTANT_P (op0) || GET_CODE (op1) == MULT)\n \ttemp = op1, op1 = op0, op0 = temp;\n \n       temp = simplify_binary_operation (PLUS, mode, op0, op1);\n-      return temp ? temp : gen_rtx (PLUS, mode, op0, op1);\n+      return temp ? temp : gen_rtx_PLUS (mode, op0, op1);\n \n     case MINUS_EXPR:\n       /* For initializers, we are allowed to return a MINUS of two\n@@ -6290,7 +6293,7 @@ expand_expr (exp, target, tmode, modifier)\n \t  if (GET_CODE (op1) == CONST_INT)\n \t    return plus_constant (op0, - INTVAL (op1));\n \t  else\n-\t    return gen_rtx (MINUS, mode, op0, op1);\n+\t    return gen_rtx_MINUS (mode, op0, op1);\n \t}\n       /* Convert A - const to A + (-const).  */\n       if (TREE_CODE (TREE_OPERAND (exp, 1)) == INTEGER_CST)\n@@ -6347,9 +6350,9 @@ expand_expr (exp, target, tmode, modifier)\n \t  /* Apply distributive law if OP0 is x+c.  */\n \t  if (GET_CODE (op0) == PLUS\n \t      && GET_CODE (XEXP (op0, 1)) == CONST_INT)\n-\t    return gen_rtx (PLUS, mode,\n-\t\t\t    gen_rtx (MULT, mode, XEXP (op0, 0),\n-\t\t\t\t     GEN_INT (TREE_INT_CST_LOW (TREE_OPERAND (exp, 1)))),\n+\t    return gen_rtx_PLUS (mode,\n+\t\t\t\t gen_rtx_MULT (mode, XEXP (op0, 0),\n+\t\t\t\t\t       GEN_INT (TREE_INT_CST_LOW (TREE_OPERAND (exp, 1)))),\n \t\t\t    GEN_INT (TREE_INT_CST_LOW (TREE_OPERAND (exp, 1))\n \t\t\t\t     * INTVAL (XEXP (op0, 1))));\n \n@@ -6358,8 +6361,8 @@ expand_expr (exp, target, tmode, modifier)\n \t  if (GET_CODE (op0) != REG)\n \t    op0 = copy_to_mode_reg (mode, op0);\n \n-\t  return gen_rtx (MULT, mode, op0,\n-\t\t\t  GEN_INT (TREE_INT_CST_LOW (TREE_OPERAND (exp, 1))));\n+\t  return gen_rtx_MULT (mode, op0,\n+\t\t\t       GEN_INT (TREE_INT_CST_LOW (TREE_OPERAND (exp, 1))));\n \t}\n \n       if (! safe_from_p (subtarget, TREE_OPERAND (exp, 1)))\n@@ -7389,14 +7392,14 @@ expand_expr (exp, target, tmode, modifier)\n     case POPDCC_EXPR:\n       {\n \trtx dcc = get_dynamic_cleanup_chain ();\n-\temit_move_insn (dcc, validize_mem (gen_rtx (MEM, Pmode, dcc)));\n+\temit_move_insn (dcc, validize_mem (gen_rtx_MEM (Pmode, dcc)));\n \treturn const0_rtx;\n       }\n \n     case POPDHC_EXPR:\n       {\n \trtx dhc = get_dynamic_handler_chain ();\n-\temit_move_insn (dhc, validize_mem (gen_rtx (MEM, Pmode, dhc)));\n+\temit_move_insn (dhc, validize_mem (gen_rtx_MEM (Pmode, dhc)));\n \treturn const0_rtx;\n       }\n \n@@ -8151,7 +8154,7 @@ expand_builtin_return_addr (fndecl_code, count, tem)\n       tem = DYNAMIC_CHAIN_ADDRESS (tem);\n #endif\n       tem = memory_address (Pmode, tem);\n-      tem = copy_to_reg (gen_rtx (MEM, Pmode, tem));\n+      tem = copy_to_reg (gen_rtx_MEM (Pmode, tem));\n     }\n \n   /* For __builtin_frame_address, return what we've got.  */\n@@ -8165,7 +8168,7 @@ expand_builtin_return_addr (fndecl_code, count, tem)\n #else\n   tem = memory_address (Pmode,\n \t\t\tplus_constant (tem, GET_MODE_SIZE (Pmode)));\n-  tem = gen_rtx (MEM, Pmode, tem);\n+  tem = gen_rtx_MEM (Pmode, tem);\n #endif\n   return tem;\n }\n@@ -8215,22 +8218,22 @@ expand_builtin_setjmp (buf_addr, target)\n   /* We store the frame pointer and the address of lab1 in the buffer\n      and use the rest of it for the stack save area, which is\n      machine-dependent.  */\n-  emit_move_insn (gen_rtx (MEM, Pmode, buf_addr),\n+  emit_move_insn (gen_rtx_MEM (Pmode, buf_addr),\n \t\t  virtual_stack_vars_rtx);\n   emit_move_insn\n-    (validize_mem (gen_rtx (MEM, Pmode,\n-\t\t\t    plus_constant (buf_addr,\n-\t\t\t\t\t   GET_MODE_SIZE (Pmode)))),\n-     gen_rtx (LABEL_REF, Pmode, lab1));\n+    (validize_mem (gen_rtx_MEM (Pmode,\n+\t\t\t\tplus_constant (buf_addr,\n+\t\t\t\t\t       GET_MODE_SIZE (Pmode)))),\n+     gen_rtx_LABEL_REF (Pmode, lab1));\n \n #ifdef HAVE_save_stack_nonlocal\n   if (HAVE_save_stack_nonlocal)\n     sa_mode = insn_operand_mode[(int) CODE_FOR_save_stack_nonlocal][0];\n #endif\n \n-  stack_save = gen_rtx (MEM, sa_mode,\n-\t\t\tplus_constant (buf_addr,\n-\t\t\t\t       2 * GET_MODE_SIZE (Pmode)));\n+  stack_save = gen_rtx_MEM (sa_mode,\n+\t\t\t    plus_constant (buf_addr,\n+\t\t\t\t\t   2 * GET_MODE_SIZE (Pmode)));\n   emit_stack_save (SAVE_NONLOCAL, &stack_save, NULL_RTX);\n \n #ifdef HAVE_setjmp\n@@ -8246,11 +8249,11 @@ expand_builtin_setjmp (buf_addr, target)\n \n   /* Note that setjmp clobbers FP when we get here, so we have to make\n      sure it's marked as used by this function.  */\n-  emit_insn (gen_rtx (USE, VOIDmode, hard_frame_pointer_rtx));\n+  emit_insn (gen_rtx_USE (VOIDmode, hard_frame_pointer_rtx));\n \n   /* Mark the static chain as clobbered here so life information\n      doesn't get messed up for it.  */\n-  emit_insn (gen_rtx (CLOBBER, VOIDmode, static_chain_rtx));\n+  emit_insn (gen_rtx_CLOBBER (VOIDmode, static_chain_rtx));\n \n   /* Now put in the code to restore the frame pointer, and argument\n      pointer, if needed.  The code below is from expand_end_bindings\n@@ -8303,13 +8306,13 @@ expand_builtin_setjmp (buf_addr, target)\n   op0 = memory_address (FUNCTION_MODE, op0);\n \n   INIT_CUMULATIVE_ARGS (args_so_far, NULL_TREE,\n-\t\t\tgen_rtx (SYMBOL_REF, Pmode, \"__dummy\"), 1);\n+\t\t\tgen_rtx_SYMBOL_REF (Pmode, \"__dummy\"), 1);\n   next_arg_reg = FUNCTION_ARG (args_so_far, VOIDmode, void_type_node, 1);\n \n #ifndef ACCUMULATE_OUTGOING_ARGS\n #ifdef HAVE_call_pop\n   if (HAVE_call_pop)\n-    emit_call_insn (gen_call_pop (gen_rtx (MEM, FUNCTION_MODE, op0),\n+    emit_call_insn (gen_call_pop (gen_rtx_MEM (FUNCTION_MODE, op0),\n \t\t\t\t  const0_rtx, next_arg_reg,\n \t\t\t\t  GEN_INT (return_pops)));\n   else\n@@ -8318,7 +8321,7 @@ expand_builtin_setjmp (buf_addr, target)\n \n #ifdef HAVE_call\n     if (HAVE_call)\n-      emit_call_insn (gen_call (gen_rtx (MEM, FUNCTION_MODE, op0),\n+      emit_call_insn (gen_call (gen_rtx_MEM (FUNCTION_MODE, op0),\n \t\t\t\tconst0_rtx, next_arg_reg, const0_rtx));\n     else\n #endif\n@@ -8448,7 +8451,7 @@ expand_builtin (exp, target, subtarget, mode, ignore)\n \t    rtx errno_rtx = GEN_ERRNO_RTX;\n #else\n \t    rtx errno_rtx\n-\t      = gen_rtx (MEM, word_mode, gen_rtx (SYMBOL_REF, Pmode, \"errno\"));\n+\t      = gen_rtx_MEM (word_mode, gen_rtx_SYMBOL_REF (Pmode, \"errno\"));\n #endif\n \n \t    emit_move_insn (errno_rtx, GEN_INT (TARGET_EDOM));\n@@ -8919,7 +8922,7 @@ expand_builtin (exp, target, subtarget, mode, ignore)\n \t    char_rtx = copy_to_mode_reg (char_mode, char_rtx);\n \n \t  emit_insn (GEN_FCN (icode) (result,\n-\t\t\t\t      gen_rtx (MEM, BLKmode, src_rtx),\n+\t\t\t\t      gen_rtx_MEM (BLKmode, src_rtx),\n \t\t\t\t      char_rtx, GEN_INT (align)));\n \n \t  /* Return the value in the proper mode for this function.  */\n@@ -8997,16 +9000,16 @@ expand_builtin (exp, target, subtarget, mode, ignore)\n \t    }\n \n \t  dest_rtx = expand_expr (dest, NULL_RTX, ptr_mode, EXPAND_SUM);\n-\t  dest_mem = gen_rtx (MEM, BLKmode,\n-\t\t\t      memory_address (BLKmode, dest_rtx));\n+\t  dest_mem = gen_rtx_MEM (BLKmode,\n+\t\t\t\t  memory_address (BLKmode, dest_rtx));\n \t  /* There could be a void* cast on top of the object.  */\n \t  while (TREE_CODE (dest) == NOP_EXPR)\n \t    dest = TREE_OPERAND (dest, 0);\n \t  type = TREE_TYPE (TREE_TYPE (dest));\n \t  MEM_IN_STRUCT_P (dest_mem) = AGGREGATE_TYPE_P (type);\n \t  src_rtx = expand_expr (src, NULL_RTX, ptr_mode, EXPAND_SUM);\n-\t  src_mem = gen_rtx (MEM, BLKmode,\n-\t\t\t     memory_address (BLKmode, src_rtx));\n+\t  src_mem = gen_rtx_MEM (BLKmode,\n+\t\t\t\t memory_address (BLKmode, src_rtx));\n \t  len_rtx = expand_expr (len, NULL_RTX, VOIDmode, 0);\n \n \t  /* Just copy the rights of SRC to the rights of DEST.  */\n@@ -9077,8 +9080,8 @@ expand_builtin (exp, target, subtarget, mode, ignore)\n \t    break;\n \n \t  dest_rtx = expand_expr (dest, NULL_RTX, ptr_mode, EXPAND_SUM);\n-\t  dest_mem = gen_rtx (MEM, BLKmode,\n-\t\t\t      memory_address (BLKmode, dest_rtx));\n+\t  dest_mem = gen_rtx_MEM (BLKmode,\n+\t\t\t\t  memory_address (BLKmode, dest_rtx));\n \t   \n \t  /* Just check DST is writable and mark it as readable.  */\n \t  if (flag_check_memory_usage)\n@@ -9211,14 +9214,14 @@ expand_builtin (exp, target, subtarget, mode, ignore)\n \t  result = gen_reg_rtx (insn_mode);\n \n \temit_insn (gen_cmpstrsi (result,\n-\t\t\t\t gen_rtx (MEM, BLKmode,\n-\t\t\t\t\t  expand_expr (arg1, NULL_RTX,\n-\t\t\t\t\t\t       ptr_mode,\n-\t\t\t\t\t\t       EXPAND_NORMAL)),\n-\t\t\t\t gen_rtx (MEM, BLKmode,\n-\t\t\t\t\t  expand_expr (arg2, NULL_RTX,\n-\t\t\t\t\t\t       ptr_mode,\n-\t\t\t\t\t\t       EXPAND_NORMAL)),\n+\t\t\t\t gen_rtx_MEM (BLKmode,\n+\t\t\t\t\t      expand_expr (arg1, NULL_RTX,\n+\t\t\t\t\t\t\t   ptr_mode,\n+\t\t\t\t\t\t\t   EXPAND_NORMAL)),\n+\t\t\t\t gen_rtx_MEM (BLKmode,\n+\t\t\t\t\t      expand_expr (arg2, NULL_RTX,\n+\t\t\t\t\t\t\t   ptr_mode,\n+\t\t\t\t\t\t\t   EXPAND_NORMAL)),\n \t\t\t\t expand_expr (len, NULL_RTX, VOIDmode, 0),\n \t\t\t\t GEN_INT (MIN (arg1_align, arg2_align))));\n \n@@ -9276,9 +9279,10 @@ expand_builtin (exp, target, subtarget, mode, ignore)\n \t\t\t\t\t   NULL_RTX,\n \t\t\t\t\t   VOIDmode, 0));\n #endif\n-\trtx fp = gen_rtx (MEM, Pmode, buf_addr);\n-\trtx lab = gen_rtx (MEM, Pmode,\n-\t\t\t   plus_constant (buf_addr, GET_MODE_SIZE (Pmode)));\n+\trtx fp = gen_rtx_MEM (Pmode, buf_addr);\n+\trtx lab = gen_rtx_MEM (Pmode,\n+\t\t\t       plus_constant (buf_addr,\n+\t\t\t\t\t      GET_MODE_SIZE (Pmode)));\n \tenum machine_mode sa_mode\n #ifdef HAVE_save_stack_nonlocal\n \t  = (HAVE_save_stack_nonlocal\n@@ -9287,9 +9291,9 @@ expand_builtin (exp, target, subtarget, mode, ignore)\n #else\n \t= Pmode;\n #endif\n-\trtx stack = gen_rtx (MEM, sa_mode,\n-\t\t\t     plus_constant (buf_addr,\n-\t\t\t\t\t    2 * GET_MODE_SIZE (Pmode)));\n+\trtx stack = gen_rtx_MEM (sa_mode,\n+\t\t\t\t plus_constant (buf_addr,\n+\t\t\t\t\t\t2 * GET_MODE_SIZE (Pmode)));\n \n \tDECL_EXTERNAL (dummy_decl) = 1;\n \tTREE_PUBLIC (dummy_decl) = 1;\n@@ -9317,9 +9321,9 @@ expand_builtin (exp, target, subtarget, mode, ignore)\n \t  /* Put in the static chain register the address of the dummy\n \t     function.  */\n \t  emit_move_insn (static_chain_rtx, XEXP (DECL_RTL (dummy_decl), 0));\n-\t  emit_insn (gen_rtx (USE, VOIDmode, hard_frame_pointer_rtx));\n-\t  emit_insn (gen_rtx (USE, VOIDmode, stack_pointer_rtx));\n-\t  emit_insn (gen_rtx (USE, VOIDmode, static_chain_rtx));\n+\t  emit_insn (gen_rtx_USE (VOIDmode, hard_frame_pointer_rtx));\n+\t  emit_insn (gen_rtx_USE (VOIDmode, stack_pointer_rtx));\n+\t  emit_insn (gen_rtx_USE (VOIDmode, static_chain_rtx));\n \t  emit_indirect_jump (lab);\n \t}\n \n@@ -9550,15 +9554,15 @@ result_vector (savep, result)\n \talign = GET_MODE_ALIGNMENT (mode) / BITS_PER_UNIT;\n \tif (size % align != 0)\n \t  size = CEIL (size, align) * align;\n-\treg = gen_rtx (REG, mode, savep ? regno : INCOMING_REGNO (regno));\n+\treg = gen_rtx_REG (mode, savep ? regno : INCOMING_REGNO (regno));\n \tmem = change_address (result, mode,\n \t\t\t      plus_constant (XEXP (result, 0), size));\n \tsavevec[nelts++] = (savep\n-\t\t\t    ? gen_rtx (SET, VOIDmode, mem, reg)\n-\t\t\t    : gen_rtx (SET, VOIDmode, reg, mem));\n+\t\t\t    ? gen_rtx_SET (VOIDmode, mem, reg)\n+\t\t\t    : gen_rtx_SET (VOIDmode, reg, mem));\n \tsize += GET_MODE_SIZE (mode);\n       }\n-  return gen_rtx (PARALLEL, VOIDmode, gen_rtvec_v (nelts, savevec));\n+  return gen_rtx_PARALLEL (VOIDmode, gen_rtvec_v (nelts, savevec));\n }\n #endif /* HAVE_untyped_call or HAVE_untyped_return */\n \n@@ -9591,13 +9595,13 @@ expand_builtin_apply_args ()\n \tif (size % align != 0)\n \t  size = CEIL (size, align) * align;\n \n-\ttem = gen_rtx (REG, mode, INCOMING_REGNO (regno));\n+\ttem = gen_rtx_REG (mode, INCOMING_REGNO (regno));\n \n #ifdef STACK_REGS\n         /* For reg-stack.c's stack register household.\n \t   Compare with a similar piece of code in function.c.  */\n \n-        emit_insn (gen_rtx (USE, mode, tem));\n+        emit_insn (gen_rtx_USE (mode, tem));\n #endif\n \n \temit_move_insn (change_address (registers, mode,\n@@ -9648,7 +9652,7 @@ expand_builtin_apply (function, arguments, argsize)\n   /* Fetch the arg pointer from the ARGUMENTS block.  */\n   incoming_args = gen_reg_rtx (Pmode);\n   emit_move_insn (incoming_args,\n-\t\t  gen_rtx (MEM, Pmode, arguments));\n+\t\t  gen_rtx_MEM (Pmode, arguments));\n #ifndef STACK_GROWS_DOWNWARD\n   incoming_args = expand_binop (Pmode, sub_optab, incoming_args, argsize,\n \t\t\t\tincoming_args, 0, OPTAB_LIB_WIDEN);\n@@ -9674,14 +9678,14 @@ expand_builtin_apply (function, arguments, argsize)\n      but it's likely that the source and/or destination addresses in\n      the block copy will need updating in machine specific ways.  */\n   dest = allocate_dynamic_stack_space (argsize, 0, 0);\n-  emit_block_move (gen_rtx (MEM, BLKmode, dest),\n-\t\t   gen_rtx (MEM, BLKmode, incoming_args),\n+  emit_block_move (gen_rtx_MEM (BLKmode, dest),\n+\t\t   gen_rtx_MEM (BLKmode, incoming_args),\n \t\t   argsize,\n \t\t   PARM_BOUNDARY / BITS_PER_UNIT);\n \n   /* Refer to the argument block.  */\n   apply_args_size ();\n-  arguments = gen_rtx (MEM, BLKmode, arguments);\n+  arguments = gen_rtx_MEM (BLKmode, arguments);\n \n   /* Walk past the arg-pointer and structure value address.  */\n   size = GET_MODE_SIZE (Pmode);\n@@ -9696,7 +9700,7 @@ expand_builtin_apply (function, arguments, argsize)\n \talign = GET_MODE_ALIGNMENT (mode) / BITS_PER_UNIT;\n \tif (size % align != 0)\n \t  size = CEIL (size, align) * align;\n-\treg = gen_rtx (REG, mode, regno);\n+\treg = gen_rtx_REG (mode, regno);\n \temit_move_insn (reg,\n \t\t\tchange_address (arguments, mode,\n \t\t\t\t\tplus_constant (XEXP (arguments, 0),\n@@ -9734,7 +9738,7 @@ expand_builtin_apply (function, arguments, argsize)\n   /* Generate the actual call instruction and save the return value.  */\n #ifdef HAVE_untyped_call\n   if (HAVE_untyped_call)\n-    emit_call_insn (gen_untyped_call (gen_rtx (MEM, FUNCTION_MODE, function),\n+    emit_call_insn (gen_untyped_call (gen_rtx_MEM (FUNCTION_MODE, function),\n \t\t\t\t      result, result_vector (1, result)));\n   else\n #endif\n@@ -9752,11 +9756,11 @@ expand_builtin_apply (function, arguments, argsize)\n \t  {\n \t    if (valreg)\n \t      abort (); /* HAVE_untyped_call required.  */\n-\t    valreg = gen_rtx (REG, mode, regno);\n+\t    valreg = gen_rtx_REG (mode, regno);\n \t  }\n \n       emit_call_insn (gen_call_value (valreg,\n-\t\t\t\t      gen_rtx (MEM, FUNCTION_MODE, function),\n+\t\t\t\t      gen_rtx_MEM (FUNCTION_MODE, function),\n \t\t\t\t      const0_rtx, NULL_RTX, const0_rtx));\n \n       emit_move_insn (change_address (result, GET_MODE (valreg),\n@@ -9815,7 +9819,7 @@ expand_builtin_return (result)\n   rtx call_fusage = 0;\n \n   apply_result_size ();\n-  result = gen_rtx (MEM, BLKmode, result);\n+  result = gen_rtx_MEM (BLKmode, result);\n \n #ifdef HAVE_untyped_return\n   if (HAVE_untyped_return)\n@@ -9834,14 +9838,14 @@ expand_builtin_return (result)\n \talign = GET_MODE_ALIGNMENT (mode) / BITS_PER_UNIT;\n \tif (size % align != 0)\n \t  size = CEIL (size, align) * align;\n-\treg = gen_rtx (REG, mode, INCOMING_REGNO (regno));\n+\treg = gen_rtx_REG (mode, INCOMING_REGNO (regno));\n \temit_move_insn (reg,\n \t\t\tchange_address (result, mode,\n \t\t\t\t\tplus_constant (XEXP (result, 0),\n \t\t\t\t\t\t       size)));\n \n \tpush_to_sequence (call_fusage);\n-\temit_insn (gen_rtx (USE, VOIDmode, reg));\n+\temit_insn (gen_rtx_USE (VOIDmode, reg));\n \tcall_fusage = get_insns ();\n \tend_sequence ();\n \tsize += GET_MODE_SIZE (mode);\n@@ -10994,7 +10998,7 @@ compare_from_rtx (op0, op1, code, unsignedp, mode, size, align)\n \t\n   emit_cmp_insn (op0, op1, code, size, mode, unsignedp, align);\n \n-  return gen_rtx (code, VOIDmode, cc0_rtx, const0_rtx);\n+  return gen_rtx_fmt_ee (code, VOIDmode, cc0_rtx, const0_rtx);\n }\n \f\n /* Generate code to calculate EXP using a store-flag instruction\n@@ -11312,18 +11316,18 @@ do_tablejump (index, mode, range, table_label, default_label)\n      GET_MODE_SIZE, because this indicates how large insns are.  The other\n      uses should all be Pmode, because they are addresses.  This code\n      could fail if addresses and insns are not the same size.  */\n-  index = gen_rtx (PLUS, Pmode,\n-\t\t   gen_rtx (MULT, Pmode, index,\n-\t\t\t    GEN_INT (GET_MODE_SIZE (CASE_VECTOR_MODE))),\n-\t\t   gen_rtx (LABEL_REF, Pmode, table_label));\n+  index = gen_rtx_PLUS (Pmode,\n+\t\t\tgen_rtx_MULT (Pmode, index,\n+\t\t\t\t      GEN_INT (GET_MODE_SIZE (CASE_VECTOR_MODE))),\n+\t\t\tgen_rtx_LABEL_REF (Pmode, table_label));\n #ifdef PIC_CASE_VECTOR_ADDRESS\n   if (flag_pic)\n     index = PIC_CASE_VECTOR_ADDRESS (index);\n   else\n #endif\n     index = memory_address_noforce (CASE_VECTOR_MODE, index);\n   temp = gen_reg_rtx (CASE_VECTOR_MODE);\n-  vector = gen_rtx (MEM, CASE_VECTOR_MODE, index);\n+  vector = gen_rtx_MEM (CASE_VECTOR_MODE, index);\n   RTX_UNCHANGING_P (vector) = 1;\n   convert_move (temp, vector, 0);\n "}, {"sha": "10beae297f0c5b51905480ed21e4d89ccb808328", "filename": "gcc/final.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38a448ca5dfe60244ab3c1f0ea8e3604ec69370b/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38a448ca5dfe60244ab3c1f0ea8e3604ec69370b/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=38a448ca5dfe60244ab3c1f0ea8e3604ec69370b", "patch": "@@ -369,11 +369,11 @@ end_final (filename)\n \n       /* address of filename */\n       ASM_GENERATE_INTERNAL_LABEL (name, \"LPBX\", 1);\n-      assemble_integer (gen_rtx (SYMBOL_REF, Pmode, name), pointer_bytes, 1);\n+      assemble_integer (gen_rtx_SYMBOL_REF (Pmode, name), pointer_bytes, 1);\n \n       /* address of count table */\n       ASM_GENERATE_INTERNAL_LABEL (name, \"LPBX\", 2);\n-      assemble_integer (gen_rtx (SYMBOL_REF, Pmode, name), pointer_bytes, 1);\n+      assemble_integer (gen_rtx_SYMBOL_REF (Pmode, name), pointer_bytes, 1);\n \n       /* count of the # of basic blocks or # of instrumented arcs */\n       if (profile_block_flag)\n@@ -389,7 +389,7 @@ end_final (filename)\n       if (profile_block_flag)\n \t{\n \t  ASM_GENERATE_INTERNAL_LABEL (name, \"LPBX\", 3);\n-\t  assemble_integer (gen_rtx (SYMBOL_REF, Pmode, name), pointer_bytes,\n+\t  assemble_integer (gen_rtx_SYMBOL_REF (Pmode, name), pointer_bytes,\n \t\t\t    1);\n \t}\n       else\n@@ -402,7 +402,7 @@ end_final (filename)\n       if (profile_block_flag)\n \t{\n \t  ASM_GENERATE_INTERNAL_LABEL (name, \"LPBX\", 4);\n-\t  assemble_integer (gen_rtx (SYMBOL_REF, Pmode, name), pointer_bytes,\n+\t  assemble_integer (gen_rtx_SYMBOL_REF (Pmode, name), pointer_bytes,\n \t\t\t    1);\n \t}\n       else\n@@ -412,9 +412,9 @@ end_final (filename)\n       if (write_symbols != NO_DEBUG && profile_block_flag)\n \t{\n \t  ASM_GENERATE_INTERNAL_LABEL (name, \"LPBX\", 5);\n-\t  assemble_integer (gen_rtx (SYMBOL_REF, Pmode, name), pointer_bytes, 1);\n+\t  assemble_integer (gen_rtx_SYMBOL_REF (Pmode, name), pointer_bytes, 1);\n \t  ASM_GENERATE_INTERNAL_LABEL (name, \"LPBX\", 6);\n-\t  assemble_integer (gen_rtx (SYMBOL_REF, Pmode, name), pointer_bytes, 1);\n+\t  assemble_integer (gen_rtx_SYMBOL_REF (Pmode, name), pointer_bytes, 1);\n \t}\n       else\n \t{\n@@ -499,7 +499,7 @@ end_final (filename)\n \t  for (i = 0; i < count_basic_blocks; i++)\n \t    {\n \t      ASM_GENERATE_INTERNAL_LABEL (name, \"LPB\", i);\n-\t      assemble_integer (gen_rtx (SYMBOL_REF, Pmode, name),\n+\t      assemble_integer (gen_rtx_SYMBOL_REF (Pmode, name),\n \t\t\t\tpointer_bytes, 1);\n \t    }\n \t}\n@@ -514,7 +514,7 @@ end_final (filename)\n \t\t{\n \t\t  ASM_GENERATE_INTERNAL_LABEL (name, \"LPBC\",\n \t\t\t\t\t       ptr->func_label_num);\n-\t\t  assemble_integer (gen_rtx (SYMBOL_REF, Pmode, name),\n+\t\t  assemble_integer (gen_rtx_SYMBOL_REF (Pmode, name),\n \t\t\t\t    pointer_bytes, 1);\n \t\t}\n \t      else\n@@ -543,7 +543,7 @@ end_final (filename)\n \t\t{\n \t\t  ASM_GENERATE_INTERNAL_LABEL (name, \"LPBC\",\n \t\t\t\t\t       ptr->file_label_num);\n-\t\t  assemble_integer (gen_rtx (SYMBOL_REF, Pmode, name),\n+\t\t  assemble_integer (gen_rtx_SYMBOL_REF (Pmode, name),\n \t\t\t\t    pointer_bytes, 1);\n \t\t}\n \t      else\n@@ -559,7 +559,7 @@ end_final (filename)\n       if (profile_block_flag)\n \t{\n \t  ASM_GENERATE_INTERNAL_LABEL (name, \"LPBX\", 3);\n-\t  assemble_integer (gen_rtx (SYMBOL_REF, Pmode, name), pointer_bytes,\n+\t  assemble_integer (gen_rtx_SYMBOL_REF (Pmode, name), pointer_bytes,\n \t\t\t    1);\n \t}\n     }"}, {"sha": "4769feb5f005d679669155063cba18700cf77425", "filename": "gcc/flow.c", "status": "modified", "additions": 35, "deletions": 36, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38a448ca5dfe60244ab3c1f0ea8e3604ec69370b/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38a448ca5dfe60244ab3c1f0ea8e3604ec69370b/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=38a448ca5dfe60244ab3c1f0ea8e3604ec69370b", "patch": "@@ -473,8 +473,8 @@ find_basic_blocks (f, nonlocal_label_list)\n \t  /* Make a list of all labels referred to other than by jumps.  */\n \t  for (note = REG_NOTES (insn); note; note = XEXP (note, 1))\n \t    if (REG_NOTE_KIND (note) == REG_LABEL)\n-\t      label_value_list = gen_rtx (EXPR_LIST, VOIDmode, XEXP (note, 0),\n-\t\t\t\t\t  label_value_list);\n+\t      label_value_list = gen_rtx_EXPR_LIST (VOIDmode, XEXP (note, 0),\n+\t\t\t\t\t\t    label_value_list);\n \t}\n \n       /* Keep a lifo list of the currently active exception handlers.  */\n@@ -485,8 +485,8 @@ find_basic_blocks (f, nonlocal_label_list)\n \t      for (x = exception_handler_labels; x; x = XEXP (x, 1))\n \t\tif (CODE_LABEL_NUMBER (XEXP (x, 0)) == NOTE_BLOCK_NUMBER (insn))\n \t\t  {\n-\t\t    eh_note = gen_rtx (EXPR_LIST, VOIDmode,\n-\t\t\t\t       XEXP (x, 0), eh_note);\n+\t\t    eh_note = gen_rtx_EXPR_LIST (VOIDmode,\n+\t\t\t\t\t\t XEXP (x, 0), eh_note);\n \t\t    break;\n \t\t  }\n \t      if (x == NULL_RTX)\n@@ -567,7 +567,7 @@ find_basic_blocks (f, nonlocal_label_list)\n \t\t   reachable from this block.  */\n \t\tfor (x = forced_labels; x; x = XEXP (x, 1))\n \t\t  if (! LABEL_REF_NONLOCAL_P (x))\n-\t\t    mark_label_ref (gen_rtx (LABEL_REF, VOIDmode, XEXP (x, 0)),\n+\t\t    mark_label_ref (gen_rtx_LABEL_REF (VOIDmode, XEXP (x, 0)),\n \t\t\t\t    insn, 0);\n \n \t\t/* Now scan the insns for this block, we may need to make\n@@ -608,8 +608,7 @@ find_basic_blocks (f, nonlocal_label_list)\n \t\t\t      {\n \t\t\t\tx = XEXP (note, 0);\n \t\t\t\tblock_live[BLOCK_NUM (x)] = 1;\n-\t\t\t\tmark_label_ref (gen_rtx (LABEL_REF,\n-\t\t\t\t\t\t\t VOIDmode, x),\n+\t\t\t\tmark_label_ref (gen_rtx_LABEL_REF (VOIDmode, x),\n \t\t\t\t\t\tinsn, 0);\n \t\t\t      }\n \t\t\t  }\n@@ -620,13 +619,13 @@ find_basic_blocks (f, nonlocal_label_list)\n \t\t\tif (computed_jump_p (insn))\n \t\t\t  {\n \t\t\t    for (x = label_value_list; x; x = XEXP (x, 1))\n-\t\t\t      mark_label_ref (gen_rtx (LABEL_REF, VOIDmode,\n-\t\t\t\t\t\t       XEXP (x, 0)),\n+\t\t\t      mark_label_ref (gen_rtx_LABEL_REF (VOIDmode,\n+\t\t\t\t\t\t\t\t XEXP (x, 0)),\n \t\t\t\t\t      insn, 0);\n \n \t\t\t    for (x = forced_labels; x; x = XEXP (x, 1))\n-\t\t\t      mark_label_ref (gen_rtx (LABEL_REF, VOIDmode,\n-\t\t\t\t\t\t       XEXP (x, 0)),\n+\t\t\t      mark_label_ref (gen_rtx_LABEL_REF (VOIDmode,\n+\t\t\t\t\t\t\t\t XEXP (x, 0)),\n \t\t\t\t\t      insn, 0);\n \t\t\t    }\n \n@@ -643,17 +642,17 @@ find_basic_blocks (f, nonlocal_label_list)\n \t\t\t\t\t\t\t NULL_RTX)))\n \t\t\t  {\n \t\t\t    if (active_eh_handler[INSN_UID (insn)])\n-\t\t\t      mark_label_ref (gen_rtx (LABEL_REF, VOIDmode,\n-\t\t\t\t\t\t       active_eh_handler[INSN_UID (insn)]),\n+\t\t\t      mark_label_ref (gen_rtx_LABEL_REF (VOIDmode,\n+\t\t\t\t\t\t\t\t active_eh_handler[INSN_UID (insn)]),\n \t\t\t\t\t      insn, 0);\n \n \t\t\t    if (!asynchronous_exceptions)\n \t\t\t      {\n \t\t\t\tfor (x = nonlocal_label_list;\n \t\t\t\t     x;\n \t\t\t\t     x = XEXP (x, 1))\n-\t\t\t\t  mark_label_ref (gen_rtx (LABEL_REF, VOIDmode,\n-\t\t\t\t\t\t\t   XEXP (x, 0)),\n+\t\t\t\t  mark_label_ref (gen_rtx_LABEL_REF (VOIDmode,\n+\t\t\t\t\t\t\t\t     XEXP (x, 0)),\n \t\t\t\t\t\t  insn, 0);\n \t\t\t      }\n \t\t\t    /* ??? This could be made smarter:\n@@ -1666,7 +1665,7 @@ propagate_block (old, first, last, final, significant, bnum)\n \t\t  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n \t\t    if (global_regs[i])\n \t\t      mark_used_regs (old, live,\n-\t\t\t\t      gen_rtx (REG, reg_raw_mode[i], i),\n+\t\t\t\t      gen_rtx_REG (reg_raw_mode[i], i),\n \t\t\t\t      final, insn);\n \n \t\t  /* Calls also clobber memory.  */\n@@ -2111,7 +2110,7 @@ mark_set_1 (needed, dead, x, insn, significant)\n \t\t  && (regno >= FIRST_PSEUDO_REGISTER\n \t\t      || asm_noperands (PATTERN (y)) < 0))\n \t\tLOG_LINKS (y)\n-\t\t  = gen_rtx (INSN_LIST, VOIDmode, insn, LOG_LINKS (y));\n+\t\t  = gen_rtx_INSN_LIST (VOIDmode, insn, LOG_LINKS (y));\n \t    }\n \t  else if (! some_needed)\n \t    {\n@@ -2120,7 +2119,7 @@ mark_set_1 (needed, dead, x, insn, significant)\n \t\t be eliminated (because the same insn does something useful).\n \t\t Indicate this by marking the reg being set as dying here.  */\n \t      REG_NOTES (insn)\n-\t\t= gen_rtx (EXPR_LIST, REG_UNUSED, reg, REG_NOTES (insn));\n+\t\t= gen_rtx_EXPR_LIST (REG_UNUSED, reg, REG_NOTES (insn));\n \t      REG_N_DEATHS (REGNO (reg))++;\n \t    }\n \t  else\n@@ -2137,10 +2136,10 @@ mark_set_1 (needed, dead, x, insn, significant)\n \t\t   i >= 0; i--)\n \t\tif (!REGNO_REG_SET_P (needed, regno + i))\n \t\t  REG_NOTES (insn)\n-\t\t    = gen_rtx (EXPR_LIST, REG_UNUSED,\n-\t\t\t       gen_rtx (REG, reg_raw_mode[regno + i],\n-\t\t\t\t\tregno + i),\n-\t\t\t       REG_NOTES (insn));\n+\t\t    = gen_rtx_EXPR_LIST (REG_UNUSED,\n+\t\t\t\t\t gen_rtx_REG (reg_raw_mode[regno + i],\n+\t\t\t\t\t\t      regno + i),\n+\t\t\t\t\t REG_NOTES (insn));\n \t    }\n \t}\n     }\n@@ -2152,7 +2151,7 @@ mark_set_1 (needed, dead, x, insn, significant)\n   else if (GET_CODE (reg) == SCRATCH && insn != 0)\n     {\n       REG_NOTES (insn)\n-\t= gen_rtx (EXPR_LIST, REG_UNUSED, reg, REG_NOTES (insn));\n+\t= gen_rtx_EXPR_LIST (REG_UNUSED, reg, REG_NOTES (insn));\n       num_scratch++;\n     }\n }\n@@ -2226,7 +2225,7 @@ find_auto_inc (needed, x, insn)\n \t\t we can't, we are done.  Otherwise, we will do any\n \t\t needed updates below.  */\n \t      if (! validate_change (insn, &XEXP (x, 0),\n-\t\t\t\t     gen_rtx (inc_code, Pmode, addr),\n+\t\t\t\t     gen_rtx_fmt_e (inc_code, Pmode, addr),\n \t\t\t\t     0))\n \t\treturn;\n \t    }\n@@ -2267,7 +2266,7 @@ find_auto_inc (needed, x, insn)\n \t\t so is not correct in the pre-inc case.  */\n \n \t      validate_change (insn, &XEXP (x, 0),\n-\t\t\t       gen_rtx (inc_code, Pmode, q),\n+\t\t\t       gen_rtx_fmt_e (inc_code, Pmode, q),\n \t\t\t       1);\n \t      validate_change (incr, &XEXP (y, 0), q, 1);\n \t      if (! apply_change_group ())\n@@ -2314,7 +2313,7 @@ find_auto_inc (needed, x, insn)\n \t     has an implicit side effect.  */\n \n \t  REG_NOTES (insn)\n-\t    = gen_rtx (EXPR_LIST, REG_INC, addr, REG_NOTES (insn));\n+\t    = gen_rtx_EXPR_LIST (REG_INC, addr, REG_NOTES (insn));\n \n \t  /* Modify the old increment-insn to simply copy\n \t     the already-incremented value of our register.  */\n@@ -2553,7 +2552,7 @@ mark_used_regs (needed, live, x, final, insn)\n \t\tif (! some_needed)\n \t\t  {\n \t\t    REG_NOTES (insn)\n-\t\t      = gen_rtx (EXPR_LIST, REG_DEAD, x, REG_NOTES (insn));\n+\t\t      = gen_rtx_EXPR_LIST (REG_DEAD, x, REG_NOTES (insn));\n \t\t    REG_N_DEATHS (regno)++;\n \t\t  }\n \t\telse\n@@ -2568,10 +2567,10 @@ mark_used_regs (needed, live, x, final, insn)\n \t\t      if (!REGNO_REG_SET_P (needed, regno + i)\n \t\t\t  && ! dead_or_set_regno_p (insn, regno + i))\n \t\t\tREG_NOTES (insn)\n-\t\t\t  = gen_rtx (EXPR_LIST, REG_DEAD,\n-\t\t\t\t     gen_rtx (REG, reg_raw_mode[regno + i],\n-\t\t\t\t\t      regno + i),\n-\t\t\t\t     REG_NOTES (insn));\n+\t\t\t  = gen_rtx_EXPR_LIST (REG_DEAD,\n+\t\t\t\t\t       gen_rtx_REG (reg_raw_mode[regno + i],\n+\t\t\t\t\t\t\t    regno + i),\n+\t\t\t\t\t       REG_NOTES (insn));\n \t\t  }\n \t      }\n \t  }\n@@ -2814,14 +2813,14 @@ try_pre_increment (insn, reg, amount)\n \n   /* See if this combination of instruction and addressing mode exists.  */\n   if (! validate_change (insn, &XEXP (use, 0),\n-\t\t\t gen_rtx (amount > 0\n-\t\t\t\t  ? (do_post ? POST_INC : PRE_INC)\n-\t\t\t\t  : (do_post ? POST_DEC : PRE_DEC),\n-\t\t\t\t  Pmode, reg), 0))\n+\t\t\t gen_rtx_fmt_e (amount > 0\n+\t\t\t\t\t? (do_post ? POST_INC : PRE_INC)\n+\t\t\t\t\t: (do_post ? POST_DEC : PRE_DEC),\n+\t\t\t\t\tPmode, reg), 0))\n     return 0;\n \n   /* Record that this insn now has an implicit side effect on X.  */\n-  REG_NOTES (insn) = gen_rtx (EXPR_LIST, REG_INC, reg, REG_NOTES (insn));\n+  REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_INC, reg, REG_NOTES (insn));\n   return 1;\n }\n "}, {"sha": "e77e0ba44e17e1791ca7b96a71d3dcffc2b26bdf", "filename": "gcc/function.c", "status": "modified", "additions": 61, "deletions": 73, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38a448ca5dfe60244ab3c1f0ea8e3604ec69370b/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38a448ca5dfe60244ab3c1f0ea8e3604ec69370b/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=38a448ca5dfe60244ab3c1f0ea8e3604ec69370b", "patch": "@@ -727,9 +727,9 @@ assign_stack_local (mode, size, align)\n   frame_offset += size;\n #endif\n \n-  x = gen_rtx (MEM, mode, addr);\n+  x = gen_rtx_MEM (mode, addr);\n \n-  stack_slot_list = gen_rtx (EXPR_LIST, VOIDmode, x, stack_slot_list);\n+  stack_slot_list = gen_rtx_EXPR_LIST (VOIDmode, x, stack_slot_list);\n \n   return x;\n }\n@@ -789,10 +789,10 @@ assign_outer_stack_local (mode, size, align, function)\n   function->frame_offset += size;\n #endif\n \n-  x = gen_rtx (MEM, mode, addr);\n+  x = gen_rtx_MEM (mode, addr);\n \n   function->stack_slot_list\n-    = gen_rtx (EXPR_LIST, VOIDmode, x, function->stack_slot_list);\n+    = gen_rtx_EXPR_LIST (VOIDmode, x, function->stack_slot_list);\n \n   pop_obstacks ();\n \n@@ -857,16 +857,16 @@ assign_stack_temp (mode, size, keep)\n \t      p->size = best_p->size - rounded_size;\n \t      p->base_offset = best_p->base_offset + rounded_size;\n \t      p->full_size = best_p->full_size - rounded_size;\n-\t      p->slot = gen_rtx (MEM, BLKmode,\n-\t\t\t\t plus_constant (XEXP (best_p->slot, 0),\n-\t\t\t\t\t\trounded_size));\n+\t      p->slot = gen_rtx_MEM (BLKmode,\n+\t\t\t\t     plus_constant (XEXP (best_p->slot, 0),\n+\t\t\t\t\t\t    rounded_size));\n \t      p->address = 0;\n \t      p->rtl_expr = 0;\n \t      p->next = temp_slots;\n \t      temp_slots = p;\n \n-\t      stack_slot_list = gen_rtx (EXPR_LIST, VOIDmode, p->slot,\n-\t\t\t\t\t stack_slot_list);\n+\t      stack_slot_list = gen_rtx_EXPR_LIST (VOIDmode, p->slot,\n+\t\t\t\t\t\t   stack_slot_list);\n \n \t      best_p->size = rounded_size;\n \t      best_p->full_size = rounded_size;\n@@ -1084,9 +1084,9 @@ update_temp_slot_address (old, new)\n   else\n     {\n       if (GET_CODE (p->address) != EXPR_LIST)\n-\tp->address = gen_rtx (EXPR_LIST, VOIDmode, p->address, NULL_RTX);\n+\tp->address = gen_rtx_EXPR_LIST (VOIDmode, p->address, NULL_RTX);\n \n-      p->address = gen_rtx (EXPR_LIST, VOIDmode, new, p->address);\n+      p->address = gen_rtx_EXPR_LIST (VOIDmode, new, p->address);\n     }\n }\n \n@@ -1906,8 +1906,8 @@ fixup_var_refs_1 (var, promoted_mode, loc, insn, replacements)\n \n \t\t  pos %= GET_MODE_BITSIZE (wanted_mode);\n \n-\t\t  newmem = gen_rtx (MEM, wanted_mode,\n-\t\t\t\t    plus_constant (XEXP (tem, 0), offset));\n+\t\t  newmem = gen_rtx_MEM (wanted_mode,\n+\t\t\t\t\tplus_constant (XEXP (tem, 0), offset));\n \t\t  RTX_UNCHANGING_P (newmem) = RTX_UNCHANGING_P (tem);\n \t\t  MEM_VOLATILE_P (newmem) = MEM_VOLATILE_P (tem);\n \t\t  MEM_IN_STRUCT_P (newmem) = MEM_IN_STRUCT_P (tem);\n@@ -2094,8 +2094,8 @@ fixup_var_refs_1 (var, promoted_mode, loc, insn, replacements)\n \n \t\t    pos %= GET_MODE_BITSIZE (wanted_mode);\n \n-\t\t    newmem = gen_rtx (MEM, wanted_mode,\n-\t\t\t\t      plus_constant (XEXP (tem, 0), offset));\n+\t\t    newmem = gen_rtx_MEM (wanted_mode,\n+\t\t\t\t\t  plus_constant (XEXP (tem, 0), offset));\n \t\t    RTX_UNCHANGING_P (newmem) = RTX_UNCHANGING_P (tem);\n \t\t    MEM_VOLATILE_P (newmem) = MEM_VOLATILE_P (tem);\n \t\t    MEM_IN_STRUCT_P (newmem) = MEM_IN_STRUCT_P (tem);\n@@ -2646,8 +2646,7 @@ gen_mem_addressof (reg, decl)\n {\n   tree type = TREE_TYPE (decl);\n \n-  rtx r = gen_rtx (ADDRESSOF, Pmode, gen_reg_rtx (GET_MODE (reg)));\n-  ADDRESSOF_REGNO (r) = REGNO (reg);\n+  rtx r = gen_rtx_ADDRESSOF (Pmode, gen_reg_rtx (GET_MODE (reg)), REGNO (reg));\n   SET_ADDRESSOF_DECL (r, decl);\n \n   XEXP (reg, 0) = r;\n@@ -2740,12 +2739,12 @@ purge_addressof_1 (loc, insn, force)\n     {\n       rtx sub = XEXP (XEXP (x, 0), 0);\n       if (GET_CODE (sub) == MEM)\n-\tsub = gen_rtx (MEM, GET_MODE (x), copy_rtx (XEXP (sub, 0)));\n+\tsub = gen_rtx_MEM (GET_MODE (x), copy_rtx (XEXP (sub, 0)));\n       if (GET_CODE (sub) == REG && GET_MODE (x) != GET_MODE (sub))\n \t{\n \t  if (! BYTES_BIG_ENDIAN && ! WORDS_BIG_ENDIAN)\n \t    {\n-\t      rtx sub2 = gen_rtx (SUBREG, GET_MODE (x), sub, 0);\n+\t      rtx sub2 = gen_rtx_SUBREG (GET_MODE (x), sub, 0);\n \t      if (validate_change (insn, loc, sub2, 0))\n \t\tgoto restart;\n \t    }\n@@ -3098,7 +3097,7 @@ instantiate_virtual_regs_1 (loc, object, extra_insns)\n \n \t      instantiate_virtual_regs_1 (&XEXP (XEXP (x, 0), 1), object,\n \t\t\t\t\t  extra_insns);\n-\t      new = gen_rtx (PLUS, Pmode, new, XEXP (XEXP (x, 0), 1));\n+\t      new = gen_rtx_PLUS (Pmode, new, XEXP (XEXP (x, 0), 1));\n \t    }\n \n \t  else if (XEXP (x, 0) == virtual_incoming_args_rtx)\n@@ -3161,7 +3160,7 @@ instantiate_virtual_regs_1 (loc, object, extra_insns)\n \t\t     register containing the sum.  */\n \n \t\t  XEXP (x, 0) = old;\n-\t\t  new = gen_rtx (PLUS, Pmode, new, new_offset);\n+\t\t  new = gen_rtx_PLUS (Pmode, new, new_offset);\n \n \t\t  start_sequence ();\n \t\t  temp = force_operand (new, NULL_RTX);\n@@ -3428,7 +3427,7 @@ nonlocal_label_rtx_list ()\n   rtx x = 0;\n \n   for (t = nonlocal_labels; t; t = TREE_CHAIN (t))\n-    x = gen_rtx (EXPR_LIST, VOIDmode, label_rtx (TREE_VALUE (t)), x);\n+    x = gen_rtx_EXPR_LIST (VOIDmode, label_rtx (TREE_VALUE (t)), x);\n \n   return x;\n }\n@@ -3443,14 +3442,14 @@ use_variable (rtl)\n {\n   if (GET_CODE (rtl) == REG)\n     /* This is a register variable.  */\n-    emit_insn (gen_rtx (USE, VOIDmode, rtl));\n+    emit_insn (gen_rtx_USE (VOIDmode, rtl));\n   else if (GET_CODE (rtl) == MEM\n \t   && GET_CODE (XEXP (rtl, 0)) == REG\n \t   && (REGNO (XEXP (rtl, 0)) < FIRST_VIRTUAL_REGISTER\n \t       || REGNO (XEXP (rtl, 0)) > LAST_VIRTUAL_REGISTER)\n \t   && XEXP (rtl, 0) != current_function_internal_arg_pointer)\n     /* This is a variable-sized structure.  */\n-    emit_insn (gen_rtx (USE, VOIDmode, XEXP (rtl, 0)));\n+    emit_insn (gen_rtx_USE (VOIDmode, XEXP (rtl, 0)));\n }\n \n /* Like use_variable except that it outputs the USEs after INSN\n@@ -3462,14 +3461,14 @@ use_variable_after (rtl, insn)\n {\n   if (GET_CODE (rtl) == REG)\n     /* This is a register variable.  */\n-    emit_insn_after (gen_rtx (USE, VOIDmode, rtl), insn);\n+    emit_insn_after (gen_rtx_USE (VOIDmode, rtl), insn);\n   else if (GET_CODE (rtl) == MEM\n \t   && GET_CODE (XEXP (rtl, 0)) == REG\n \t   && (REGNO (XEXP (rtl, 0)) < FIRST_VIRTUAL_REGISTER\n \t       || REGNO (XEXP (rtl, 0)) > LAST_VIRTUAL_REGISTER)\n \t   && XEXP (rtl, 0) != current_function_internal_arg_pointer)\n     /* This is a variable-sized structure.  */\n-    emit_insn_after (gen_rtx (USE, VOIDmode, XEXP (rtl, 0)), insn);\n+    emit_insn_after (gen_rtx_USE (VOIDmode, XEXP (rtl, 0)), insn);\n }\n \f\n int\n@@ -3674,8 +3673,8 @@ assign_parms (fndecl, second_time)\n \t  || TREE_CODE (parm) != PARM_DECL\n \t  || passed_type == NULL)\n \t{\n-\t  DECL_INCOMING_RTL (parm) = DECL_RTL (parm) = gen_rtx (MEM, BLKmode,\n-\t\t\t\t\t\t\t\tconst0_rtx);\n+\t  DECL_INCOMING_RTL (parm) = DECL_RTL (parm)\n+\t    = gen_rtx_MEM (BLKmode, const0_rtx);\n \t  TREE_USED (parm) = 1;\n \t  continue;\n \t}\n@@ -3799,11 +3798,12 @@ assign_parms (fndecl, second_time)\n \t  rtx offset_rtx = ARGS_SIZE_RTX (stack_offset);\n \n \t  if (offset_rtx == const0_rtx)\n-\t    stack_parm = gen_rtx (MEM, promoted_mode, internal_arg_pointer);\n+\t    stack_parm = gen_rtx_MEM (promoted_mode, internal_arg_pointer);\n \t  else\n-\t    stack_parm = gen_rtx (MEM, promoted_mode,\n-\t\t\t\t  gen_rtx (PLUS, Pmode,\n-\t\t\t\t\t   internal_arg_pointer, offset_rtx));\n+\t    stack_parm = gen_rtx_MEM (promoted_mode,\n+\t\t\t\t      gen_rtx_PLUS (Pmode,\n+\t\t\t\t\t\t    internal_arg_pointer,\n+\t\t\t\t\t\t    offset_rtx));\n \n \t  /* If this is a memory ref that contains aggregate components,\n \t     mark it as such for cse and loop optimize.  Likewise if it\n@@ -3936,24 +3936,12 @@ assign_parms (fndecl, second_time)\n \n \t  offset_rtx = ARGS_SIZE_RTX (stack_offset);\n \t  if (offset_rtx == const0_rtx)\n-\t    stack_parm = gen_rtx (MEM, nominal_mode, internal_arg_pointer);\n+\t    stack_parm = gen_rtx_MEM (nominal_mode, internal_arg_pointer);\n \t  else\n-\t    stack_parm = gen_rtx (MEM, nominal_mode,\n-\t\t\t\t  gen_rtx (PLUS, Pmode,\n-\t      if (flag_check_memory_usage)\n-\t\t{\n-\t\t  push_to_sequence (conversion_insns);\n-\t\t  emit_library_call (chkr_set_right_libfunc, 1, VOIDmode, 3,\n-\t\t\t\t     XEXP (stack_parm, 0), ptr_mode,\n-\t\t\t\t     GEN_INT (int_size_in_bytes \n-\t\t\t\t\t      (TREE_TYPE (parm))),\n-\t\t\t\t     TYPE_MODE (sizetype),\n-\t\t\t\t     GEN_INT (MEMORY_USE_RW),\n-\t\t\t\t     TYPE_MODE (integer_type_node));\n-\t\t  conversion_insns = get_insns ();\n-\t\t  end_sequence ();\n-\t\t}\n-\t\t\t\t\t   internal_arg_pointer, offset_rtx));\n+\t    stack_parm = gen_rtx_MEM (nominal_mode,\n+\t\t\t\t      gen_rtx_PLUS (Pmode,\n+\t\t\t\t\t\t    internal_arg_pointer,\n+\t\t\t\t\t\t    offset_rtx));\n \n \t  /* If this is a memory ref that contains aggregate components,\n \t     mark it as such for cse and loop optimize.  */\n@@ -3969,7 +3957,7 @@ assign_parms (fndecl, second_time)\n \t have been optimised away.  */\n \n       if (GET_CODE (entry_parm) == REG && !(hide_last_arg && last_named))\n-\t  emit_insn (gen_rtx (USE, GET_MODE (entry_parm), entry_parm));\n+\t  emit_insn (gen_rtx_USE (GET_MODE (entry_parm), entry_parm));\n #endif\n \n       /* ENTRY_PARM is an RTX for the parameter as it arrives,\n@@ -4067,7 +4055,7 @@ assign_parms (fndecl, second_time)\n \t  if (passed_pointer)\n \t    {\n \t      DECL_RTL (parm)\n-\t\t= gen_rtx (MEM, TYPE_MODE (TREE_TYPE (passed_type)), parmreg);\n+\t\t= gen_rtx_MEM (TYPE_MODE (TREE_TYPE (passed_type)), parmreg);\n \t      MEM_IN_STRUCT_P (DECL_RTL (parm)) = aggregate;\n \t    }\n \t  else\n@@ -4162,10 +4150,10 @@ assign_parms (fndecl, second_time)\n \t      if (TYPE_SIZE (type) == 0\n \t\t  || TREE_CODE (TYPE_SIZE (type)) != INTEGER_CST)\n \t\t/* This is a variable sized object.  */\n-\t\tcopy = gen_rtx (MEM, BLKmode,\n-\t\t\t\tallocate_dynamic_stack_space\n-\t\t\t\t(expr_size (parm), NULL_RTX,\n-\t\t\t\t TYPE_ALIGN (type)));\n+\t\tcopy = gen_rtx_MEM (BLKmode,\n+\t\t\t\t    allocate_dynamic_stack_space\n+\t\t\t\t    (expr_size (parm), NULL_RTX,\n+\t\t\t\t     TYPE_ALIGN (type)));\n \t      else\n \t\tcopy = assign_stack_temp (TYPE_MODE (type),\n \t\t\t\t\t  int_size_in_bytes (type), 1);\n@@ -4266,21 +4254,21 @@ assign_parms (fndecl, second_time)\n \t\t    if (set != 0\n \t\t\t&& SET_DEST (set) == regno_reg_rtx [regnoi])\n \t\t      REG_NOTES (sinsn)\n-\t\t\t= gen_rtx (EXPR_LIST, REG_EQUIV,\n-\t\t\t\t   parm_reg_stack_loc[regnoi],\n-\t\t\t\t   REG_NOTES (sinsn));\n+\t\t\t= gen_rtx_EXPR_LIST (REG_EQUIV,\n+\t\t\t\t\t     parm_reg_stack_loc[regnoi],\n+\t\t\t\t\t     REG_NOTES (sinsn));\n \t\t    else if (set != 0\n \t\t\t     && SET_DEST (set) == regno_reg_rtx [regnor])\n \t\t      REG_NOTES (sinsn)\n-\t\t\t= gen_rtx (EXPR_LIST, REG_EQUIV,\n-\t\t\t\t   parm_reg_stack_loc[regnor],\n-\t\t\t\t   REG_NOTES (sinsn));\n+\t\t\t= gen_rtx_EXPR_LIST (REG_EQUIV,\n+\t\t\t\t\t     parm_reg_stack_loc[regnor],\n+\t\t\t\t\t     REG_NOTES (sinsn));\n \t\t  }\n \t      else if ((set = single_set (linsn)) != 0\n \t\t       && SET_DEST (set) == parmreg)\n \t        REG_NOTES (linsn)\n-\t\t  = gen_rtx (EXPR_LIST, REG_EQUIV,\n-\t\t\t     stack_parm, REG_NOTES (linsn));\n+\t\t  = gen_rtx_EXPR_LIST (REG_EQUIV,\n+\t\t\t\t       stack_parm, REG_NOTES (linsn));\n \t    }\n \n \t  /* For pointer data type, suggest pointer register.  */\n@@ -4366,7 +4354,7 @@ assign_parms (fndecl, second_time)\n \t  tree restype = TREE_TYPE (result);\n \n \t  DECL_RTL (result)\n-\t    = gen_rtx (MEM, DECL_MODE (result), DECL_RTL (parm));\n+\t    = gen_rtx_MEM (DECL_MODE (result), DECL_RTL (parm));\n \n \t  MEM_IN_STRUCT_P (DECL_RTL (result)) = AGGREGATE_TYPE_P (restype);\n \t}\n@@ -4874,7 +4862,7 @@ fix_lexical_addr (addr, var)\n       addr = fix_lexical_addr (XEXP (fp->arg_pointer_save_area, 0), var);\n       addr = memory_address (Pmode, addr);\n \n-      base = copy_to_reg (gen_rtx (MEM, Pmode, addr));\n+      base = copy_to_reg (gen_rtx_MEM (Pmode, addr));\n #else\n       displacement += (FIRST_PARM_OFFSET (context) - STARTING_FRAME_OFFSET);\n       base = lookup_static_chain (var);\n@@ -5388,7 +5376,7 @@ expand_main_function ()\n       /* The zero below avoids a possible parse error */\n       0;\n #if !defined (HAS_INIT_SECTION)\n-      emit_library_call (gen_rtx (SYMBOL_REF, Pmode, NAME__MAIN), 0,\n+      emit_library_call (gen_rtx_SYMBOL_REF (Pmode, NAME__MAIN), 0,\n \t\t\t VOIDmode, 0);\n #endif /* not HAS_INIT_SECTION */\n     }\n@@ -5567,7 +5555,7 @@ expand_function_start (subr, parms_have_cleanups)\n       if (value_address)\n \t{\n \t  DECL_RTL (DECL_RESULT (subr))\n-\t    = gen_rtx (MEM, DECL_MODE (DECL_RESULT (subr)), value_address);\n+\t    = gen_rtx_MEM (DECL_MODE (DECL_RESULT (subr)), value_address);\n \t  MEM_IN_STRUCT_P (DECL_RTL (DECL_RESULT (subr)))\n \t    = AGGREGATE_TYPE_P (TREE_TYPE (DECL_RESULT (subr)));\n \t}\n@@ -5682,14 +5670,14 @@ expand_function_start (subr, parms_have_cleanups)\n #ifdef FRAME_GROWS_DOWNWARD\n \t  last_ptr = plus_constant (last_ptr, - GET_MODE_SIZE (Pmode));\n #endif\n-\t  last_ptr = copy_to_reg (gen_rtx (MEM, Pmode,\n-\t\t\t\t\t   memory_address (Pmode, last_ptr)));\n+\t  last_ptr = copy_to_reg (gen_rtx_MEM (Pmode,\n+\t\t\t\t\t       memory_address (Pmode, last_ptr)));\n \n \t  /* If we are not optimizing, ensure that we know that this\n \t     piece of context is live over the entire function.  */\n \t  if (! optimize)\n-\t    save_expr_regs = gen_rtx (EXPR_LIST, VOIDmode, last_ptr,\n-\t\t\t\t      save_expr_regs);\n+\t    save_expr_regs = gen_rtx_EXPR_LIST (VOIDmode, last_ptr,\n+\t\t\t\t\t\tsave_expr_regs);\n \t}\n     }\n \n@@ -5772,7 +5760,7 @@ expand_function_end (filename, line, end_bindings)\n \t{\n \t  end_temporary_allocation ();\n \t  initial_trampoline\n-\t    = gen_rtx (MEM, BLKmode, assemble_trampoline_template ());\n+\t    = gen_rtx_MEM (BLKmode, assemble_trampoline_template ());\n \t  resume_temporary_allocation ();\n \t}\n #endif\n@@ -5950,7 +5938,7 @@ expand_function_end (filename, line, end_bindings)\n \t\t  GET_MODE (DECL_RTL (DECL_RESULT (current_function_decl))));\n       emit_move_insn (real_decl_result,\n \t\t      DECL_RTL (DECL_RESULT (current_function_decl)));\n-      emit_insn (gen_rtx (USE, VOIDmode, real_decl_result));\n+      emit_insn (gen_rtx_USE (VOIDmode, real_decl_result));\n \n       /* The delay slot scheduler assumes that current_function_return_rtx\n \t holds the hard register containing the return value, not a temporary"}, {"sha": "c82c32a1d1b664f40211f7c72830abc0d2d53961", "filename": "gcc/genpeep.c", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38a448ca5dfe60244ab3c1f0ea8e3604ec69370b/gcc%2Fgenpeep.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38a448ca5dfe60244ab3c1f0ea8e3604ec69370b/gcc%2Fgenpeep.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenpeep.c?ref=38a448ca5dfe60244ab3c1f0ea8e3604ec69370b", "patch": "@@ -1,5 +1,5 @@\n /* Generate code from machine description to perform peephole optimizations.\n-   Copyright (C) 1987, 1989, 1992 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 1989, 1992, 1997 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -48,7 +48,6 @@ struct link\n \n char *xmalloc ();\n static void match_rtx ();\n-static void gen_exp ();\n static void fatal ();\n void fancy_abort ();\n \n@@ -123,7 +122,7 @@ gen_peephole (peep)\n      So use a simple regular form: a PARALLEL containing a vector\n      of all the operands.  */\n \n-  printf (\"  PATTERN (ins1) = gen_rtx (PARALLEL, VOIDmode, gen_rtvec_v (%d, operands));\\n\", n_operands);\n+  printf (\"  PATTERN (ins1) = gen_rtx_PARALLEL (VOIDmode, gen_rtvec_v (%d, operands));\\n\", n_operands);\n \n #if 0\n   printf (\"  if (want_jump && GET_CODE (ins1) != JUMP_INSN)\\n\");\n@@ -264,6 +263,9 @@ match_rtx (x, path, fail_label)\n     case ADDRESS:\n       match_rtx (XEXP (x, 0), path, fail_label);\n       return;\n+      \n+    default:\n+      break;\n     }\n \n   printf (\"  x = \");\n@@ -455,6 +457,7 @@ main (argc, argv)\n from the machine description file `md'.  */\\n\\n\");\n \n   printf (\"#include \\\"config.h\\\"\\n\");\n+  printf (\"#include <stdio.h>\\n\");\n   printf (\"#include \\\"rtl.h\\\"\\n\");\n   printf (\"#include \\\"regs.h\\\"\\n\");\n   printf (\"#include \\\"output.h\\\"\\n\");"}, {"sha": "b301240dedb06ace09eb380c55ecafa195f51edd", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 38, "deletions": 36, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38a448ca5dfe60244ab3c1f0ea8e3604ec69370b/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38a448ca5dfe60244ab3c1f0ea8e3604ec69370b/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=38a448ca5dfe60244ab3c1f0ea8e3604ec69370b", "patch": "@@ -3367,7 +3367,7 @@ flush_pending_lists (insn, only_write)\n     add_dependence (insn, XEXP (u, 0), REG_DEP_ANTI);\n \n   last_pending_memory_flush =\n-    gen_rtx (INSN_LIST, VOIDmode, insn, NULL_RTX);\n+    gen_rtx_INSN_LIST (VOIDmode, insn, NULL_RTX);\n }\n \n /* Analyze a single SET or CLOBBER rtx, X, creating all dependencies generated\n@@ -3583,8 +3583,8 @@ sched_analyze_2 (x, insn)\n \t    while (--i >= 0)\n \t      {\n \t\treg_last_uses[regno + i]\n-\t\t  = gen_rtx (INSN_LIST, VOIDmode,\n-\t\t\t     insn, reg_last_uses[regno + i]);\n+\t\t  = gen_rtx_INSN_LIST (VOIDmode,\n+\t\t\t\t       insn, reg_last_uses[regno + i]);\n \n \t\tfor (u = reg_last_sets[regno + i]; u; u = XEXP (u, 1))\n \t\t  add_dependence (insn, XEXP (u, 0), 0);\n@@ -3598,7 +3598,7 @@ sched_analyze_2 (x, insn)\n \telse\n \t  {\n \t    reg_last_uses[regno]\n-\t      = gen_rtx (INSN_LIST, VOIDmode, insn, reg_last_uses[regno]);\n+\t      = gen_rtx_INSN_LIST (VOIDmode, insn, reg_last_uses[regno]);\n \n \t    for (u = reg_last_sets[regno]; u; u = XEXP (u, 1))\n \t      add_dependence (insn, XEXP (u, 0), 0);\n@@ -3835,7 +3835,7 @@ sched_analyze_insn (x, insn, loop_notes)\n \t\t\t     {\n \t\t\t       /* reg_last_sets[r] is now a list of insns */\n \t\t\t       reg_last_sets[i]\n-\t\t\t\t = gen_rtx (INSN_LIST, VOIDmode, insn, NULL_RTX);\n+\t\t\t\t = gen_rtx_INSN_LIST (VOIDmode, insn, NULL_RTX);\n \t\t\t     });\n   CLEAR_REG_SET (reg_pending_sets);\n \n@@ -3845,7 +3845,7 @@ sched_analyze_insn (x, insn, loop_notes)\n \n \t/* reg_last_sets[r] is now a list of insns */\n \treg_last_sets[i]\n-\t  = gen_rtx (INSN_LIST, VOIDmode, insn, NULL_RTX);\n+\t  = gen_rtx_INSN_LIST (VOIDmode, insn, NULL_RTX);\n \n       reg_pending_sets_all = 0;\n     }\n@@ -3945,12 +3945,12 @@ sched_analyze (head, tail)\n \t      /* Add a pair of fake REG_NOTE which we will later\n \t\t convert back into a NOTE_INSN_SETJMP note.  See\n \t\t reemit_notes for why we use a pair of NOTEs.  */\n-\t      REG_NOTES (insn) = gen_rtx (EXPR_LIST, REG_DEAD,\n-\t\t\t\t\t  GEN_INT (0),\n-\t\t\t\t\t  REG_NOTES (insn));\n-\t      REG_NOTES (insn) = gen_rtx (EXPR_LIST, REG_DEAD,\n-\t\t\t\t\t  GEN_INT (NOTE_INSN_SETJMP),\n-\t\t\t\t\t  REG_NOTES (insn));\n+\t      REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_DEAD,\n+\t\t\t\t\t\t    GEN_INT (0),\n+\t\t\t\t\t\t    REG_NOTES (insn));\n+\t      REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_DEAD,\n+\t\t\t\t\t\t    GEN_INT (NOTE_INSN_SETJMP),\n+\t\t\t\t\t\t    REG_NOTES (insn));\n \t    }\n \t  else\n \t    {\n@@ -3993,7 +3993,7 @@ sched_analyze (head, tail)\n \n \t  /* last_function_call is now a list of insns */\n \t  last_function_call\n-\t    = gen_rtx (INSN_LIST, VOIDmode, insn, NULL_RTX);\n+\t    = gen_rtx_INSN_LIST (VOIDmode, insn, NULL_RTX);\n \t}\n \n       /* See comments on reemit_notes as to why we do this.  */\n@@ -4005,10 +4005,12 @@ sched_analyze (head, tail)\n \t\t   || (NOTE_LINE_NUMBER (insn) == NOTE_INSN_SETJMP\n \t\t       && GET_CODE (PREV_INSN (insn)) != CALL_INSN)))\n \t{\n-\t  loop_notes = gen_rtx (EXPR_LIST, REG_DEAD,\n-\t\t\t\tGEN_INT (NOTE_BLOCK_NUMBER (insn)), loop_notes);\n-\t  loop_notes = gen_rtx (EXPR_LIST, REG_DEAD,\n-\t\t\t\tGEN_INT (NOTE_LINE_NUMBER (insn)), loop_notes);\n+\t  loop_notes = gen_rtx_EXPR_LIST (REG_DEAD,\n+\t\t\t\t\t  GEN_INT (NOTE_BLOCK_NUMBER (insn)),\n+\t\t\t\t\t  loop_notes);\n+\t  loop_notes = gen_rtx_EXPR_LIST (REG_DEAD,\n+\t\t\t\t\t  GEN_INT (NOTE_LINE_NUMBER (insn)),\n+\t\t\t\t\t  loop_notes);\n \t  CONST_CALL_P (loop_notes) = CONST_CALL_P (insn);\n \t}\n \n@@ -4480,7 +4482,7 @@ create_reg_dead_note (reg, insn)\n \t    {\n \t      link = rtx_alloc (EXPR_LIST);\n \t      PUT_REG_NOTE_KIND (link, REG_DEAD);\n-\t      XEXP (link, 0) = gen_rtx (REG, word_mode, 0);\n+\t      XEXP (link, 0) = gen_rtx_REG (word_mode, 0);\n \t      XEXP (link, 1) = NULL_RTX;\n \t    }\n \t     \n@@ -4495,7 +4497,7 @@ create_reg_dead_note (reg, insn)\n \t{\n \t  rtx temp_reg, temp_link;\n \n-\t  temp_reg = gen_rtx (REG, word_mode, 0);\n+\t  temp_reg = gen_rtx_REG (word_mode, 0);\n \t  temp_link = rtx_alloc (EXPR_LIST);\n \t  PUT_REG_NOTE_KIND (temp_link, REG_DEAD);\n \t  XEXP (temp_link, 0) = temp_reg;\n@@ -4631,9 +4633,8 @@ attach_deaths (x, insn, set_p)\n \t\t\t     i >= 0; i--)\n \t\t\t  if (! REGNO_REG_SET_P (old_live_regs, regno+i)\n \t\t\t      && ! dead_or_set_regno_p (insn, regno + i))\n-\t\t\t    create_reg_dead_note (gen_rtx (REG,\n-\t\t\t\t\t\t\t   reg_raw_mode[regno + i],\n-\t\t\t\t\t\t\t   regno + i),\n+\t\t\t    create_reg_dead_note (gen_rtx_REG (reg_raw_mode[regno + i],\n+\t\t\t\t\t\t\t       regno + i),\n \t\t\t\t\t\t  insn);\n \t\t      }\n \t\t  }\n@@ -7097,8 +7098,8 @@ init_rgn_data_dependences (n_bbs)\n   for (bb = 0; bb < n_bbs; bb++)\n     {\n       bb_sched_before_next_call[bb] =\n-\tgen_rtx (INSN, VOIDmode, 0, NULL_RTX, NULL_RTX,\n-\t\t NULL_RTX, 0, NULL_RTX, NULL_RTX);\n+\tgen_rtx_INSN (VOIDmode, 0, NULL_RTX, NULL_RTX,\n+\t\t      NULL_RTX, 0, NULL_RTX, NULL_RTX);\n       LOG_LINKS (bb_sched_before_next_call[bb]) = 0;\n     }\n }\n@@ -7228,8 +7229,8 @@ compute_block_backward_dependences (bb)\n       last_function_call = 0;\n       last_pending_memory_flush = 0;\n       sched_before_next_call\n-\t= gen_rtx (INSN, VOIDmode, 0, NULL_RTX, NULL_RTX,\n-\t\t   NULL_RTX, 0, NULL_RTX, NULL_RTX);\n+\t= gen_rtx_INSN (VOIDmode, 0, NULL_RTX, NULL_RTX,\n+\t\t\tNULL_RTX, 0, NULL_RTX, NULL_RTX);\n       LOG_LINKS (sched_before_next_call) = 0;\n     }\n   else\n@@ -7293,8 +7294,8 @@ compute_block_backward_dependences (bb)\n \t\t      continue;\n \n \t\t    (bb_reg_last_uses[bb_succ])[reg]\n-\t\t      = gen_rtx (INSN_LIST, VOIDmode, XEXP (u, 0),\n-\t\t\t\t (bb_reg_last_uses[bb_succ])[reg]);\n+\t\t      = gen_rtx_INSN_LIST (VOIDmode, XEXP (u, 0),\n+\t\t\t\t\t   (bb_reg_last_uses[bb_succ])[reg]);\n \t\t  }\n \n \t\t/* reg-last-defs lists are inherited by bb_succ */\n@@ -7304,8 +7305,8 @@ compute_block_backward_dependences (bb)\n \t\t      continue;\n \n \t\t    (bb_reg_last_sets[bb_succ])[reg]\n-\t\t      = gen_rtx (INSN_LIST, VOIDmode, XEXP (u, 0),\n-\t\t\t\t (bb_reg_last_sets[bb_succ])[reg]);\n+\t\t      = gen_rtx_INSN_LIST (VOIDmode, XEXP (u, 0),\n+\t\t\t\t\t   (bb_reg_last_sets[bb_succ])[reg]);\n \t\t  }\n \t      }\n \n@@ -7346,8 +7347,8 @@ compute_block_backward_dependences (bb)\n \t\t  continue;\n \n \t\tbb_last_function_call[bb_succ]\n-\t\t  = gen_rtx (INSN_LIST, VOIDmode, XEXP (u, 0),\n-\t\t\t     bb_last_function_call[bb_succ]);\n+\t\t  = gen_rtx_INSN_LIST (VOIDmode, XEXP (u, 0),\n+\t\t\t\t       bb_last_function_call[bb_succ]);\n \t      }\n \n \t    /* last_pending_memory_flush is inherited by bb_succ */\n@@ -7357,8 +7358,8 @@ compute_block_backward_dependences (bb)\n \t\t  continue;\n \n \t\tbb_last_pending_memory_flush[bb_succ]\n-\t\t  = gen_rtx (INSN_LIST, VOIDmode, XEXP (u, 0),\n-\t\t\t     bb_last_pending_memory_flush[bb_succ]);\n+\t\t  = gen_rtx_INSN_LIST (VOIDmode, XEXP (u, 0),\n+\t\t\t\t       bb_last_pending_memory_flush[bb_succ]);\n \t      }\n \n \t    /* sched_before_next_call is inherited by bb_succ */\n@@ -8122,8 +8123,9 @@ update_flow_info (notes, first, last, orig_insn)\n \t  for (insn = first; insn != NEXT_INSN (last); insn = NEXT_INSN (insn))\n \t    if (GET_RTX_CLASS (GET_CODE (insn)) == 'i'\n \t\t&& reg_mentioned_p (XEXP (note, 0), PATTERN (insn)))\n-\t      REG_NOTES (insn) = gen_rtx (EXPR_LIST, REG_LABEL,\n-\t\t\t\t\t  XEXP (note, 0), REG_NOTES (insn));\n+\t      REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_LABEL,\n+\t\t\t\t\t\t    XEXP (note, 0),\n+\t\t\t\t\t\t    REG_NOTES (insn));\n \t  break;\n \n \tcase REG_CC_SETTER:"}, {"sha": "810eedaf5b85b5f91921b42d14379178188718fe", "filename": "gcc/halfpic.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38a448ca5dfe60244ab3c1f0ea8e3604ec69370b/gcc%2Fhalfpic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38a448ca5dfe60244ab3c1f0ea8e3604ec69370b/gcc%2Fhalfpic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhalfpic.c?ref=38a448ca5dfe60244ab3c1f0ea8e3604ec69370b", "patch": "@@ -1,5 +1,5 @@\n /* OSF/rose half-pic support functions.\n-   Copyright (C) 1992 Free Software Foundation, Inc.\n+   Copyright (C) 1992, 1997 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -32,9 +32,9 @@ Boston, MA 02111-1307, USA.  */\n \n #ifdef HALF_PIC_INIT\n \n+#include <stdio.h>\n #include \"tree.h\"\n #include \"rtl.h\"\n-#include <stdio.h>\n #include \"obstack.h\"\n \n #define obstack_chunk_alloc xmalloc\n@@ -188,7 +188,7 @@ half_pic_finish (stream)\n       if (p->pointer_p)\n \t{\n \t  ASM_OUTPUT_LABEL (stream, p->ref_name);\n-\t  ASM_OUTPUT_INT (stream, gen_rtx (SYMBOL_REF, Pmode, p->real_name));\n+\t  ASM_OUTPUT_INT (stream, gen_rtx_SYMBOL_REF (Pmode, p->real_name));\n \t}\n     }\n }\n@@ -394,7 +394,7 @@ half_pic_ptr (operand)\n     }\n \n   half_pic_number_refs++;\n-  return gen_rtx (SYMBOL_REF, Pmode, p->ref_name);\n+  return gen_rtx_SYMBOL_REF (Pmode, p->ref_name);\n }\n \n #endif /* HALF_PIC_INIT */"}, {"sha": "256a665f07bc676d5145f1f84d93c134e8187eee", "filename": "gcc/integrate.c", "status": "modified", "additions": 32, "deletions": 31, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38a448ca5dfe60244ab3c1f0ea8e3604ec69370b/gcc%2Fintegrate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38a448ca5dfe60244ab3c1f0ea8e3604ec69370b/gcc%2Fintegrate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintegrate.c?ref=38a448ca5dfe60244ab3c1f0ea8e3604ec69370b", "patch": "@@ -913,7 +913,7 @@ save_constants (px)\n \t   && CONSTANT_POOL_ADDRESS_P (XEXP (x,0)))\n     {\n       enum machine_mode const_mode = get_pool_mode (XEXP (x, 0));\n-      rtx new = gen_rtx (CONST, const_mode, get_pool_constant (XEXP (x, 0)));\n+      rtx new = gen_rtx_CONST (const_mode, get_pool_constant (XEXP (x, 0)));\n       RTX_INTEGRATED_P (new) = 1;\n \n       /* If the MEM was in a different mode than the constant (perhaps we\n@@ -922,7 +922,7 @@ save_constants (px)\n \n       if (GET_MODE (x) != const_mode)\n \t{\n-\t  new = gen_rtx (SUBREG, GET_MODE (x), new, 0);\n+\t  new = gen_rtx_SUBREG (GET_MODE (x), new, 0);\n \t  RTX_INTEGRATED_P (new) = 1;\n \t}\n \n@@ -932,9 +932,9 @@ save_constants (px)\n   else if (GET_CODE (x) == SYMBOL_REF\n \t   && CONSTANT_POOL_ADDRESS_P (x))\n     {\n-      *px = gen_rtx (ADDRESS, GET_MODE (x),\n-\t\t     gen_rtx (CONST, get_pool_mode (x),\n-\t\t\t      get_pool_constant (x)));\n+      *px = gen_rtx_ADDRESS (GET_MODE (x),\n+\t\t\t     gen_rtx_CONST (get_pool_mode (x),\n+\t\t\t\t\t    get_pool_constant (x)));\n       save_constants (&XEXP (*px, 0));\n       RTX_INTEGRATED_P (*px) = 1;\n     }\n@@ -1128,9 +1128,9 @@ copy_for_inline (orig)\n     case LABEL_REF:\n       /* If this is a non-local label, just make a new LABEL_REF.\n \t Otherwise, use the new label as well.  */\n-      x = gen_rtx (LABEL_REF, GET_MODE (orig),\n-\t\t   LABEL_REF_NONLOCAL_P (orig) ? XEXP (orig, 0)\n-\t\t   : label_map[CODE_LABEL_NUMBER (XEXP (orig, 0))]);\n+      x = gen_rtx_LABEL_REF (GET_MODE (orig),\n+\t\t\t     LABEL_REF_NONLOCAL_P (orig) ? XEXP (orig, 0)\n+\t\t\t     : label_map[CODE_LABEL_NUMBER (XEXP (orig, 0))]);\n       LABEL_REF_NONLOCAL_P (x) = LABEL_REF_NONLOCAL_P (orig);\n       LABEL_OUTSIDE_LOOP_P (x) = LABEL_OUTSIDE_LOOP_P (orig);\n       return x;\n@@ -1764,7 +1764,7 @@ expand_inline_function (fndecl, parms, target, ignore, type,\n \t      target = gen_lowpart (departing_mode, reg_to_map);\n \t    }\n \t  else\n-\t    reg_to_map = gen_rtx (SUBREG, arriving_mode, target, 0);\n+\t    reg_to_map = gen_rtx_SUBREG (arriving_mode, target, 0);\n \t}\n       else\n \treg_to_map = target;\n@@ -2089,8 +2089,9 @@ expand_inline_function (fndecl, parms, target, ignore, type,\n \n   if (structure_value_addr)\n     {\n-      target = gen_rtx (MEM, TYPE_MODE (type),\n-\t\t\tmemory_address (TYPE_MODE (type), structure_value_addr));\n+      target = gen_rtx_MEM (TYPE_MODE (type),\n+\t\t\t    memory_address (TYPE_MODE (type),\n+\t\t\t\t\t    structure_value_addr));\n       MEM_IN_STRUCT_P (target) = 1;\n     }\n \n@@ -2382,17 +2383,17 @@ copy_rtx_and_substitute (orig, map)\n       copy = copy_rtx_and_substitute (SUBREG_REG (orig), map);\n       /* SUBREG is ordinary, but don't make nested SUBREGs.  */\n       if (GET_CODE (copy) == SUBREG)\n-\treturn gen_rtx (SUBREG, GET_MODE (orig), SUBREG_REG (copy),\n-\t\t\tSUBREG_WORD (orig) + SUBREG_WORD (copy));\n+\treturn gen_rtx_SUBREG (GET_MODE (orig), SUBREG_REG (copy),\n+\t\t\t       SUBREG_WORD (orig) + SUBREG_WORD (copy));\n       else if (GET_CODE (copy) == CONCAT)\n \treturn (subreg_realpart_p (orig) ? XEXP (copy, 0) : XEXP (copy, 1));\n       else\n-\treturn gen_rtx (SUBREG, GET_MODE (orig), copy,\n-\t\t\tSUBREG_WORD (orig));\n+\treturn gen_rtx_SUBREG (GET_MODE (orig), copy,\n+\t\t\t       SUBREG_WORD (orig));\n \n     case ADDRESSOF:\n-      copy = gen_rtx (ADDRESSOF, mode,\n-\t\t      copy_rtx_and_substitute (XEXP (orig, 0), map));\n+      copy = gen_rtx_ADDRESSOF (mode,\n+\t\t\tcopy_rtx_and_substitute (XEXP (orig, 0), map), 0);\n       SET_ADDRESSOF_DECL (copy, ADDRESSOF_DECL (orig));\n       regno = ADDRESSOF_REGNO (orig);\n       if (map->reg_map[regno])\n@@ -2423,18 +2424,18 @@ copy_rtx_and_substitute (orig, map)\n       copy = copy_rtx_and_substitute (XEXP (orig, 0), map);\n       if (GET_CODE (copy) == SUBREG && GET_CODE (XEXP (orig, 0)) != SUBREG)\n \tcopy = SUBREG_REG (copy);\n-      return gen_rtx (code, VOIDmode, copy);\n+      return gen_rtx_fmt_e (code, VOIDmode, copy);\n \n     case CODE_LABEL:\n       LABEL_PRESERVE_P (get_label_from_map (map, CODE_LABEL_NUMBER (orig)))\n \t= LABEL_PRESERVE_P (orig);\n       return get_label_from_map (map, CODE_LABEL_NUMBER (orig));\n \n     case LABEL_REF:\n-      copy = gen_rtx (LABEL_REF, mode,\n-\t\t      LABEL_REF_NONLOCAL_P (orig) ? XEXP (orig, 0)\n-\t\t      : get_label_from_map (map, \n-\t\t\t\t\t    CODE_LABEL_NUMBER (XEXP (orig, 0))));\n+      copy = gen_rtx_LABEL_REF (mode,\n+\t\t\t\tLABEL_REF_NONLOCAL_P (orig) ? XEXP (orig, 0)\n+\t\t\t\t: get_label_from_map (map, \n+\t\t\t\t\t\t      CODE_LABEL_NUMBER (XEXP (orig, 0))));\n       LABEL_OUTSIDE_LOOP_P (copy) = LABEL_OUTSIDE_LOOP_P (orig);\n \n       /* The fact that this label was previously nonlocal does not mean\n@@ -2578,9 +2579,9 @@ copy_rtx_and_substitute (orig, map)\n #ifndef NO_FUNCTION_CSE\n       if (! (optimize && ! flag_no_function_cse))\n #endif\n-\treturn gen_rtx (CALL, GET_MODE (orig),\n-\t\t\tgen_rtx (MEM, GET_MODE (XEXP (orig, 0)),\n-\t\t\t\t copy_rtx_and_substitute (XEXP (XEXP (orig, 0), 0), map)),\n+\treturn gen_rtx_CALL (GET_MODE (orig),\n+\t\t\t     gen_rtx_MEM (GET_MODE (XEXP (orig, 0)),\n+\t\t\t\t\t  copy_rtx_and_substitute (XEXP (XEXP (orig, 0), 0), map)),\n \t\t\tcopy_rtx_and_substitute (XEXP (orig, 1), map));\n       break;\n \n@@ -2605,12 +2606,12 @@ copy_rtx_and_substitute (orig, map)\n \t  HOST_WIDE_INT loc_offset\n \t    = GET_CODE (equiv_loc) == REG ? 0 : INTVAL (XEXP (equiv_loc, 1));\n \t      \n-\t  return gen_rtx (SET, VOIDmode, SET_DEST (orig),\n-\t\t\t  force_operand\n-\t\t\t  (plus_constant\n-\t\t\t   (copy_rtx_and_substitute (SET_SRC (orig), map),\n-\t\t\t    - loc_offset),\n-\t\t\t   NULL_RTX));\n+\t  return gen_rtx_SET (VOIDmode, SET_DEST (orig),\n+\t\t\t      force_operand\n+\t\t\t      (plus_constant\n+\t\t\t       (copy_rtx_and_substitute (SET_SRC (orig), map),\n+\t\t\t\t- loc_offset),\n+\t\t\t       NULL_RTX));\n \t}\n       break;\n "}, {"sha": "239af46993541b75d89c3846eb72e07d751416e9", "filename": "gcc/jump.c", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38a448ca5dfe60244ab3c1f0ea8e3604ec69370b/gcc%2Fjump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38a448ca5dfe60244ab3c1f0ea8e3604ec69370b/gcc%2Fjump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjump.c?ref=38a448ca5dfe60244ab3c1f0ea8e3604ec69370b", "patch": "@@ -478,7 +478,7 @@ jump_optimize (f, cross_jump, noop_moves, after_regscan)\n \t\t\t    /* Change this into a USE so that we won't emit\n \t\t\t       code for it, but still can keep the note.  */\n \t\t\t    PATTERN (insn)\n-\t\t\t      = gen_rtx (USE, VOIDmode, XEXP (trial, 0));\n+\t\t\t      = gen_rtx_USE (VOIDmode, XEXP (trial, 0));\n \t\t\t    INSN_CODE (insn) = -1;\n \t\t\t    /* Remove all reg notes but the REG_DEAD one.  */\n \t\t\t    REG_NOTES (insn) = trial;\n@@ -2106,7 +2106,7 @@ jump_optimize (f, cross_jump, noop_moves, after_regscan)\n \t\t      /* Make the old conditional jump\n \t\t\t into an unconditional one.  */\n \t\t      SET_SRC (PATTERN (insn))\n-\t\t\t= gen_rtx (LABEL_REF, VOIDmode, JUMP_LABEL (insn));\n+\t\t\t= gen_rtx_LABEL_REF (VOIDmode, JUMP_LABEL (insn));\n \t\t      INSN_CODE (insn) = -1;\n \t\t      emit_barrier_after (insn);\n \t\t      /* Add to jump_chain unless this is a new label\n@@ -2413,8 +2413,9 @@ duplicate_loop_exit_test (loop_start)\n \tfor (link = REG_NOTES (insn); link; link = XEXP (link, 1))\n \t  if (REG_NOTE_KIND (link) != REG_LABEL)\n \t    REG_NOTES (copy)\n-\t      = copy_rtx (gen_rtx (EXPR_LIST, REG_NOTE_KIND (link),\n-\t\t\t\t   XEXP (link, 0), REG_NOTES (copy)));\n+\t      = copy_rtx (gen_rtx_EXPR_LIST (REG_NOTE_KIND (link),\n+\t\t\t\t\t     XEXP (link, 0),\n+\t\t\t\t\t     REG_NOTES (copy)));\n \tif (reg_map && REG_NOTES (copy))\n \t  replace_regs (REG_NOTES (copy), reg_map, max_reg, 1);\n \tbreak;\n@@ -3402,8 +3403,8 @@ mark_jump_label (x, insn, cross_jump)\n \t\t    || ! (GET_CODE (next) == JUMP_INSN\n \t\t\t  && (GET_CODE (PATTERN (next)) == ADDR_VEC\n \t\t\t      || GET_CODE (PATTERN (next)) == ADDR_DIFF_VEC)))\n-\t\t  REG_NOTES (insn) = gen_rtx (EXPR_LIST, REG_LABEL, label,\n-\t\t\t\t\t      REG_NOTES (insn));\n+\t\t  REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_LABEL, label,\n+\t\t\t\t\t\t\tREG_NOTES (insn));\n \t      }\n \t  }\n \treturn;\n@@ -3490,8 +3491,8 @@ delete_computation (insn)\n \t    delete_computation (prev);\n \t  else\n \t    /* Otherwise, show that cc0 won't be used.  */\n-\t    REG_NOTES (prev) = gen_rtx (EXPR_LIST, REG_UNUSED,\n-\t\t\t\t\tcc0_rtx, REG_NOTES (prev));\n+\t    REG_NOTES (prev) = gen_rtx_EXPR_LIST (REG_UNUSED,\n+\t\t\t\t\t\t  cc0_rtx, REG_NOTES (prev));\n \t}\n     }\n #endif\n@@ -3840,9 +3841,9 @@ invert_exp (x, insn)\n \n       if (can_reverse_comparison_p (comp, insn)\n \t  && validate_change (insn, &XEXP (x, 0),\n-\t\t\t      gen_rtx (reverse_condition (GET_CODE (comp)),\n-\t\t\t\t       GET_MODE (comp), XEXP (comp, 0),\n-\t\t\t\t       XEXP (comp, 1)), 0))\n+\t\t\t      gen_rtx_fmt_ee (reverse_condition (GET_CODE (comp)),\n+\t\t\t\t\t      GET_MODE (comp), XEXP (comp, 0),\n+\t\t\t\t\t      XEXP (comp, 1)), 0))\n \treturn 1;\n \t\t\t\t       \n       tem = XEXP (x, 1);\n@@ -3983,22 +3984,22 @@ redirect_exp (loc, olabel, nlabel, insn)\n \t  if (nlabel)\n \t    XEXP (x, 0) = nlabel;\n \t  else\n-\t    return validate_change (insn, loc, gen_rtx (RETURN, VOIDmode), 0);\n+\t    return validate_change (insn, loc, gen_rtx_RETURN (VOIDmode), 0);\n \t  return 1;\n \t}\n     }\n   else if (code == RETURN && olabel == 0)\n     {\n-      x = gen_rtx (LABEL_REF, VOIDmode, nlabel);\n+      x = gen_rtx_LABEL_REF (VOIDmode, nlabel);\n       if (loc == &PATTERN (insn))\n-\tx = gen_rtx (SET, VOIDmode, pc_rtx, x);\n+\tx = gen_rtx_SET (VOIDmode, pc_rtx, x);\n       return validate_change (insn, loc, x, 0);\n     }\n \n   if (code == SET && nlabel == 0 && SET_DEST (x) == pc_rtx\n       && GET_CODE (SET_SRC (x)) == LABEL_REF\n       && XEXP (SET_SRC (x), 0) == olabel)\n-    return validate_change (insn, loc, gen_rtx (RETURN, VOIDmode), 0);\n+    return validate_change (insn, loc, gen_rtx_RETURN (VOIDmode), 0);\n \n   fmt = GET_RTX_FORMAT (code);\n   for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)"}, {"sha": "62f3e171895c857375e215dc52a37e4afbdee5ec", "filename": "gcc/local-alloc.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38a448ca5dfe60244ab3c1f0ea8e3604ec69370b/gcc%2Flocal-alloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38a448ca5dfe60244ab3c1f0ea8e3604ec69370b/gcc%2Flocal-alloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flocal-alloc.c?ref=38a448ca5dfe60244ab3c1f0ea8e3604ec69370b", "patch": "@@ -1082,8 +1082,8 @@ update_equiv_regs ()\n \t  && ! memref_used_between_p (SET_DEST (set),\n \t\t\t\t      reg_equiv_init_insn[regno], insn))\n \tREG_NOTES (reg_equiv_init_insn[regno])\n-\t  = gen_rtx (EXPR_LIST, REG_EQUIV, dest,\n-\t\t     REG_NOTES (reg_equiv_init_insn[regno]));\n+\t  = gen_rtx_EXPR_LIST (REG_EQUIV, dest,\n+\t\t\t       REG_NOTES (reg_equiv_init_insn[regno]));\n \n       /* If this is a register-register copy where SRC is not dead, see if we\n \t can optimize it.  */\n@@ -1158,8 +1158,8 @@ update_equiv_regs ()\n       if (note == 0 && REG_BASIC_BLOCK (regno) >= 0\n \t  && GET_CODE (SET_SRC (set)) == MEM\n \t  && validate_equiv_mem (insn, dest, SET_SRC (set)))\n-\tREG_NOTES (insn) = note = gen_rtx (EXPR_LIST, REG_EQUIV, SET_SRC (set),\n-\t\t\t\t\t   REG_NOTES (insn));\n+\tREG_NOTES (insn) = note = gen_rtx_EXPR_LIST (REG_EQUIV, SET_SRC (set),\n+\t\t\t\t\t\t     REG_NOTES (insn));\n \n       if (note)\n \t{\n@@ -1721,8 +1721,8 @@ block_alloc (b)\n \t  {\n \t    if (GET_CODE (qty_scratch_rtx[q]) == REG)\n \t      abort ();\n-\t    qty_scratch_rtx[q] = gen_rtx (REG, GET_MODE (qty_scratch_rtx[q]),\n-\t\t\t\t\t  qty_phys_reg[q]);\n+\t    qty_scratch_rtx[q] = gen_rtx_REG (GET_MODE (qty_scratch_rtx[q]),\n+\t\t\t\t\t      qty_phys_reg[q]);\n \t    scratch_block[scratch_index] = b;\n \t    scratch_list[scratch_index++] = qty_scratch_rtx[q];\n "}, {"sha": "222620171fb32f59844e567965a1c70b3073bc25", "filename": "gcc/loop.c", "status": "modified", "additions": 90, "deletions": 88, "changes": 178, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38a448ca5dfe60244ab3c1f0ea8e3604ec69370b/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38a448ca5dfe60244ab3c1f0ea8e3604ec69370b/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=38a448ca5dfe60244ab3c1f0ea8e3604ec69370b", "patch": "@@ -351,9 +351,9 @@ void\n init_loop ()\n {\n   char *free_point = (char *) oballoc (1);\n-  rtx reg = gen_rtx (REG, word_mode, LAST_VIRTUAL_REGISTER + 1);\n+  rtx reg = gen_rtx_REG (word_mode, LAST_VIRTUAL_REGISTER + 1);\n \n-  add_cost = rtx_cost (gen_rtx (PLUS, word_mode, reg, reg), SET);\n+  add_cost = rtx_cost (gen_rtx_PLUS (word_mode, reg, reg), SET);\n \n   /* We multiply by 2 to reconcile the difference in scale between\n      these two ways of computing costs.  Otherwise the cost of a copy\n@@ -1084,7 +1084,7 @@ record_excess_regs (in_this, not_in_this, output)\n     case REG:\n       if (REGNO (in_this) >= FIRST_PSEUDO_REGISTER\n \t  && ! reg_mentioned_p (in_this, not_in_this))\n-\t*output = gen_rtx (EXPR_LIST, VOIDmode, in_this, *output);\n+\t*output = gen_rtx_EXPR_LIST (VOIDmode, in_this, *output);\n       return;\n       \n     default:\n@@ -1591,8 +1591,8 @@ add_label_notes (x, insns)\n \t{\n \t  for (insn = insns; insn; insn = NEXT_INSN (insn))\n \t    if (reg_mentioned_p (XEXP (x, 0), insn))\n-\t      REG_NOTES (insn) = gen_rtx (EXPR_LIST, REG_LABEL, XEXP (x, 0),\n-\t\t\t\t\t  REG_NOTES (insn));\n+\t      REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_LABEL, XEXP (x, 0),\n+\t\t\t\t\t\t    REG_NOTES (insn));\n \t}\n       return;\n     }\n@@ -1744,9 +1744,10 @@ move_movables (movables, threshold, insn_count, loop_start, end, nregs)\n \t\t  REG_NOTES (i1) = REG_NOTES (m->insn);\n \t\t  r1 = SET_DEST (PATTERN (m->insn));\n \t\t  r2 = SET_DEST (PATTERN (m1->insn));\n-\t\t  regs_may_share = gen_rtx (EXPR_LIST, VOIDmode, r1,\n-\t\t\t\t\t    gen_rtx (EXPR_LIST, VOIDmode, r2,\n-\t\t\t\t\t\t     regs_may_share));\n+\t\t  regs_may_share\n+\t\t    = gen_rtx_EXPR_LIST (VOIDmode, r1,\n+\t\t\t\t\t gen_rtx_EXPR_LIST (VOIDmode, r2,\n+\t\t\t\t\t\t\t    regs_may_share));\n \t\t  delete_insn (m->insn);\n \n \t\t  if (new_start == 0)\n@@ -1796,9 +1797,8 @@ move_movables (movables, threshold, insn_count, loop_start, end, nregs)\n \t\t  i1 = emit_insns_before (temp, loop_start);\n \t\t  if (! find_reg_note (i1, REG_EQUAL, NULL_RTX))\n \t\t    REG_NOTES (i1)\n-\t\t      = gen_rtx (EXPR_LIST,\n-\t\t\t\t m->is_equiv ? REG_EQUIV : REG_EQUAL,\n-\t\t\t\t m->set_src, REG_NOTES (i1));\n+\t\t      = gen_rtx_EXPR_LIST (m->is_equiv ? REG_EQUIV : REG_EQUAL,\n+\t\t\t\t\t   m->set_src, REG_NOTES (i1));\n \n \t\t  if (loop_dump_stream)\n \t\t    fprintf (loop_dump_stream, \" moved to %d\", INSN_UID (i1));\n@@ -1969,8 +1969,9 @@ move_movables (movables, threshold, insn_count, loop_start, end, nregs)\n \t\t\t\t\t    (since it might get set outside).  */\n \t\t\t  && CONSTANT_P (SET_SRC (PATTERN (p))))\n \t\t\tREG_NOTES (i1)\n-\t\t\t  = gen_rtx (EXPR_LIST, REG_EQUAL,\n-\t\t\t\t     SET_SRC (PATTERN (p)), REG_NOTES (i1));\n+\t\t\t  = gen_rtx_EXPR_LIST (REG_EQUAL,\n+\t\t\t\t\t       SET_SRC (PATTERN (p)),\n+\t\t\t\t\t       REG_NOTES (i1));\n #endif\n \n \t\t      /* If library call, now fix the REG_NOTES that contain\n@@ -2219,9 +2220,9 @@ constant_high_bytes (p, loop_start)\n   /* Try to change (SET (REG ...) (ZERO_EXTEND (..:B ...)))\n      to (SET (STRICT_LOW_PART (SUBREG:B (REG...))) ...).  */\n \n-  new = gen_rtx (SET, VOIDmode,\n-\t\t gen_rtx (STRICT_LOW_PART, VOIDmode,\n-\t\t\t  gen_rtx (SUBREG, GET_MODE (XEXP (SET_SRC (PATTERN (p)), 0)),\n+  new = gen_rtx_SET (VOIDmode,\n+\t\t     gen_rtx_STRICT_LOW_PART (VOIDmode,\n+\t\t\t\t\t      gen_rtx_SUBREG (GET_MODE (XEXP (SET_SRC (PATTERN (p)), 0)),\n \t\t\t\t   SET_DEST (PATTERN (p)),\n \t\t\t\t   0)),\n \t\t XEXP (SET_SRC (PATTERN (p)), 0));\n@@ -2232,9 +2233,8 @@ constant_high_bytes (p, loop_start)\n       register int i;\n \n       /* Clear destination register before the loop.  */\n-      emit_insn_before (gen_rtx (SET, VOIDmode,\n-\t\t\t\t SET_DEST (PATTERN (p)),\n-\t\t\t\t const0_rtx),\n+      emit_insn_before (gen_rtx_SET (VOIDmode, SET_DEST (PATTERN (p)),\n+\t\t\t\t     const0_rtx),\n \t\t\tloop_start);\n \n       /* Inside the loop, just load the low part.  */\n@@ -3619,8 +3619,8 @@ strength_reduce (scan_start, end, loop_top, insn_count,\n \t  if (GET_CODE (test) == NE)\n \t    {\n \t      bl->init_insn = p;\n-\t      bl->init_set = gen_rtx (SET, VOIDmode,\n-\t\t\t\t      XEXP (test, 0), XEXP (test, 1));\n+\t      bl->init_set = gen_rtx_SET (VOIDmode,\n+\t\t\t\t\t  XEXP (test, 0), XEXP (test, 1));\n \t    }\n \t  else\n \t    bl->initial_test = test;\n@@ -5043,14 +5043,14 @@ update_giv_derive (p)\n \t\t  tem = 0;\n \n \t\t  if (biv->mult_val == const1_rtx)\n-\t\t    tem = simplify_giv_expr (gen_rtx (MULT, giv->mode,\n-\t\t\t\t\t\t      biv->add_val,\n-\t\t\t\t\t\t      giv->mult_val),\n+\t\t    tem = simplify_giv_expr (gen_rtx_MULT (giv->mode,\n+\t\t\t\t\t\t\t   biv->add_val,\n+\t\t\t\t\t\t\t   giv->mult_val),\n \t\t\t\t\t     &dummy);\n \n \t\t  if (tem && giv->derive_adjustment)\n-\t\t    tem = simplify_giv_expr (gen_rtx (PLUS, giv->mode, tem,\n-\t\t\t\t\t\t      giv->derive_adjustment),\n+\t\t    tem = simplify_giv_expr (gen_rtx_PLUS (giv->mode, tem,\n+\t\t\t\t\t\t\t   giv->derive_adjustment),\n \t\t\t\t\t     &dummy);\n \t\t  if (tem)\n \t\t    giv->derive_adjustment = tem;\n@@ -5392,29 +5392,29 @@ simplify_giv_expr (x, benefit)\n \t      {\n \t\ttem = plus_constant (arg0, INTVAL (arg1));\n \t\tif (GET_CODE (tem) != CONST_INT)\n-\t\t  tem = gen_rtx (USE, mode, tem);\n+\t\t  tem = gen_rtx_USE (mode, tem);\n \t      }\n \t    else\n \t      {\n \t\t/* Adding two invariants must result in an invariant,\n \t\t   so enclose addition operation inside a USE and\n \t\t   return it.  */\n-\t\ttem = gen_rtx (USE, mode, gen_rtx (PLUS, mode, arg0, arg1));\n+\t\ttem = gen_rtx_USE (mode, gen_rtx_PLUS (mode, arg0, arg1));\n \t      }\n \n \t    return tem;\n \n \t  case REG:\n \t  case MULT:\n \t    /* biv + invar or mult + invar.  Return sum.  */\n-\t    return gen_rtx (PLUS, mode, arg0, arg1);\n+\t    return gen_rtx_PLUS (mode, arg0, arg1);\n \n \t  case PLUS:\n \t    /* (a + invar_1) + invar_2.  Associate.  */\n-\t    return simplify_giv_expr (gen_rtx (PLUS, mode,\n-\t\t\t\t\t       XEXP (arg0, 0),\n-\t\t\t\t\t       gen_rtx (PLUS, mode,\n-\t\t\t\t\t\t\tXEXP (arg0, 1), arg1)),\n+\t    return simplify_giv_expr (gen_rtx_PLUS (mode,\n+\t\t\t\t\t\t    XEXP (arg0, 0),\n+\t\t\t\t\t\t    gen_rtx_PLUS (mode,\n+\t\t\t\t\t\t\t\t  XEXP (arg0, 1), arg1)),\n \t\t\t\t      benefit);\n \n \t  default:\n@@ -5424,9 +5424,9 @@ simplify_giv_expr (x, benefit)\n       /* Each argument must be either REG, PLUS, or MULT.  Convert REG to\n \t MULT to reduce cases.  */\n       if (GET_CODE (arg0) == REG)\n-\targ0 = gen_rtx (MULT, mode, arg0, const1_rtx);\n+\targ0 = gen_rtx_MULT (mode, arg0, const1_rtx);\n       if (GET_CODE (arg1) == REG)\n-\targ1 = gen_rtx (MULT, mode, arg1, const1_rtx);\n+\targ1 = gen_rtx_MULT (mode, arg1, const1_rtx);\n \n       /* Now have PLUS + PLUS, PLUS + MULT, MULT + PLUS, or MULT + MULT.\n \t Put a MULT first, leaving PLUS + PLUS, MULT + PLUS, or MULT + MULT.\n@@ -5435,10 +5435,10 @@ simplify_giv_expr (x, benefit)\n \ttem = arg0, arg0 = arg1, arg1 = tem;\n \n       if (GET_CODE (arg1) == PLUS)\n-\t  return simplify_giv_expr (gen_rtx (PLUS, mode,\n-\t\t\t\t\t     gen_rtx (PLUS, mode,\n-\t\t\t\t\t\t      arg0, XEXP (arg1, 0)),\n-\t\t\t\t\t     XEXP (arg1, 1)),\n+\t  return simplify_giv_expr (gen_rtx_PLUS (mode,\n+\t\t\t\t\t\t  gen_rtx_PLUS (mode, arg0,\n+\t\t\t\t\t\t\t\tXEXP (arg1, 0)),\n+\t\t\t\t\t\t  XEXP (arg1, 1)),\n \t\t\t\t    benefit);\n \n       /* Now must have MULT + MULT.  Distribute if same biv, else not giv.  */\n@@ -5448,19 +5448,19 @@ simplify_giv_expr (x, benefit)\n       if (XEXP (arg0, 0) != XEXP (arg1, 0))\n \treturn 0;\n \n-      return simplify_giv_expr (gen_rtx (MULT, mode,\n-\t\t\t\t\t XEXP (arg0, 0),\n-\t\t\t\t\t gen_rtx (PLUS, mode,\n-\t\t\t\t\t\t  XEXP (arg0, 1),\n-\t\t\t\t\t\t  XEXP (arg1, 1))),\n+      return simplify_giv_expr (gen_rtx_MULT (mode,\n+\t\t\t\t\t      XEXP (arg0, 0),\n+\t\t\t\t\t      gen_rtx_PLUS (mode,\n+\t\t\t\t\t\t\t    XEXP (arg0, 1),\n+\t\t\t\t\t\t\t    XEXP (arg1, 1))),\n \t\t\t\tbenefit);\n \n     case MINUS:\n       /* Handle \"a - b\" as \"a + b * (-1)\".  */\n-      return simplify_giv_expr (gen_rtx (PLUS, mode,\n-\t\t\t\t\t XEXP (x, 0),\n-\t\t\t\t\t gen_rtx (MULT, mode,\n-\t\t\t\t\t\t  XEXP (x, 1), constm1_rtx)),\n+      return simplify_giv_expr (gen_rtx_PLUS (mode,\n+\t\t\t\t\t      XEXP (x, 0),\n+\t\t\t\t\t      gen_rtx_MULT (mode, XEXP (x, 1),\n+\t\t\t\t\t\t\t    constm1_rtx)),\n \t\t\t\tbenefit);\n \n     case MULT:\n@@ -5489,7 +5489,7 @@ simplify_giv_expr (x, benefit)\n \t{\n \tcase REG:\n \t  /* biv * invar.  Done.  */\n-\t  return gen_rtx (MULT, mode, arg0, arg1);\n+\t  return gen_rtx_MULT (mode, arg0, arg1);\n \n \tcase CONST_INT:\n \t  /* Product of two constants.  */\n@@ -5501,19 +5501,21 @@ simplify_giv_expr (x, benefit)\n \n \tcase MULT:\n \t  /* (a * invar_1) * invar_2.  Associate.  */\n-\t  return simplify_giv_expr (gen_rtx (MULT, mode,\n-\t\t\t\t\t     XEXP (arg0, 0),\n-\t\t\t\t\t     gen_rtx (MULT, mode,\n-\t\t\t\t\t\t      XEXP (arg0, 1), arg1)),\n+\t  return simplify_giv_expr (gen_rtx_MULT (mode, XEXP (arg0, 0),\n+\t\t\t\t\t\t  gen_rtx_MULT (mode,\n+\t\t\t\t\t\t\t\tXEXP (arg0, 1),\n+\t\t\t\t\t\t\t\targ1)),\n \t\t\t\t    benefit);\n \n \tcase PLUS:\n \t  /* (a + invar_1) * invar_2.  Distribute.  */\n-\t  return simplify_giv_expr (gen_rtx (PLUS, mode,\n-\t\t\t\t\t     gen_rtx (MULT, mode,\n-\t\t\t\t\t\t      XEXP (arg0, 0), arg1),\n-\t\t\t\t\t     gen_rtx (MULT, mode,\n-\t\t\t\t\t\t      XEXP (arg0, 1), arg1)),\n+\t  return simplify_giv_expr (gen_rtx_PLUS (mode,\n+\t\t\t\t\t\t  gen_rtx_MULT (mode,\n+\t\t\t\t\t\t\t\tXEXP (arg0, 0),\n+\t\t\t\t\t\t\t\targ1),\n+\t\t\t\t\t\t  gen_rtx_MULT (mode,\n+\t\t\t\t\t\t\t\tXEXP (arg0, 1),\n+\t\t\t\t\t\t\t\targ1)),\n \t\t\t\t    benefit);\n \n \tdefault:\n@@ -5525,22 +5527,22 @@ simplify_giv_expr (x, benefit)\n       if (GET_CODE (XEXP (x, 1)) != CONST_INT)\n \treturn 0;\n \n-      return simplify_giv_expr (gen_rtx (MULT, mode,\n-\t\t\t\t\t XEXP (x, 0),\n-\t\t\t\t\t GEN_INT ((HOST_WIDE_INT) 1\n-\t\t\t\t\t\t  << INTVAL (XEXP (x, 1)))),\n+      return simplify_giv_expr (gen_rtx_MULT (mode,\n+\t\t\t\t\t      XEXP (x, 0),\n+\t\t\t\t\t      GEN_INT ((HOST_WIDE_INT) 1\n+\t\t\t\t\t\t       << INTVAL (XEXP (x, 1)))),\n \t\t\t\tbenefit);\n \n     case NEG:\n       /* \"-a\" is \"a * (-1)\" */\n-      return simplify_giv_expr (gen_rtx (MULT, mode, XEXP (x, 0), constm1_rtx),\n+      return simplify_giv_expr (gen_rtx_MULT (mode, XEXP (x, 0), constm1_rtx),\n \t\t\t\tbenefit);\n \n     case NOT:\n       /* \"~a\" is \"-a - 1\". Silly, but easy.  */\n-      return simplify_giv_expr (gen_rtx (MINUS, mode,\n-\t\t\t\t\t gen_rtx (NEG, mode, XEXP (x, 0)),\n-\t\t\t\t\t const1_rtx),\n+      return simplify_giv_expr (gen_rtx_MINUS (mode,\n+\t\t\t\t\t       gen_rtx_NEG (mode, XEXP (x, 0)),\n+\t\t\t\t\t       const1_rtx),\n \t\t\t\tbenefit);\n \n     case USE:\n@@ -5567,11 +5569,11 @@ simplify_giv_expr (x, benefit)\n \t    if (v->cant_derive)\n \t      return 0;\n \n-\t    tem = gen_rtx (PLUS, mode, gen_rtx (MULT, mode,\n-\t\t\t\t\t\tv->src_reg, v->mult_val),\n+\t    tem = gen_rtx_PLUS (mode, gen_rtx_MULT (mode, v->src_reg,\n+\t\t\t\t\t\t    v->mult_val),\n \t\t\t   v->add_val);\n \t    if (v->derive_adjustment)\n-\t      tem = gen_rtx (MINUS, mode, tem, v->derive_adjustment);\n+\t      tem = gen_rtx_MINUS (mode, tem, v->derive_adjustment);\n \t    return simplify_giv_expr (tem, benefit);\n \t  }\n \n@@ -5591,7 +5593,7 @@ simplify_giv_expr (x, benefit)\n \t  if (GET_CODE (x) == CONST_INT)\n \t    return x;\n \t  else\n-\t    return gen_rtx (USE, mode, x);\n+\t    return gen_rtx_USE (mode, x);\n \t}\n       else\n \treturn 0;\n@@ -5739,12 +5741,12 @@ express_from (g1, g2)\n   else if (mult == const1_rtx)\n     mult = g1->dest_reg;\n   else\n-    mult = gen_rtx (MULT, g2->mode, g1->dest_reg, mult);\n+    mult = gen_rtx_MULT (g2->mode, g1->dest_reg, mult);\n \n   if (add == const0_rtx)\n     return mult;\n   else\n-    return gen_rtx (PLUS, g2->mode, mult, add);\n+    return gen_rtx_PLUS (g2->mode, mult, add);\n }\n #endif\n \f\n@@ -6072,8 +6074,8 @@ check_dbra_loop (loop_end, insn_count, loop_start)\n \t{\n \t  /* register always nonnegative, add REG_NOTE to branch */\n \t  REG_NOTES (PREV_INSN (loop_end))\n-\t    = gen_rtx (EXPR_LIST, REG_NONNEG, NULL_RTX,\n-\t\t       REG_NOTES (PREV_INSN (loop_end)));\n+\t    = gen_rtx_EXPR_LIST (REG_NONNEG, NULL_RTX,\n+\t\t\t\t REG_NOTES (PREV_INSN (loop_end)));\n \t  bl->nonneg = 1;\n \n \t  return 1;\n@@ -6097,8 +6099,8 @@ check_dbra_loop (loop_end, insn_count, loop_start)\n \t      && INTVAL (bl->biv->add_val) == -1)\n \t    {\n \t      REG_NOTES (PREV_INSN (loop_end))\n-\t\t= gen_rtx (EXPR_LIST, REG_NONNEG, NULL_RTX,\n-\t\t\t   REG_NOTES (PREV_INSN (loop_end)));\n+\t\t= gen_rtx_EXPR_LIST (REG_NONNEG, NULL_RTX,\n+\t\t\t\t     REG_NOTES (PREV_INSN (loop_end)));\n \t      bl->nonneg = 1;\n \n \t      return 1;\n@@ -6302,8 +6304,8 @@ check_dbra_loop (loop_end, insn_count, loop_start)\n \t\t  /* Increment of LABEL_NUSES done above.  */\n \t\t  /* Register is now always nonnegative,\n \t\t     so add REG_NONNEG note to the branch.  */\n-\t\t  REG_NOTES (tem) = gen_rtx (EXPR_LIST, REG_NONNEG, NULL_RTX,\n-\t\t\t\t\t     REG_NOTES (tem));\n+\t\t  REG_NOTES (tem) = gen_rtx_EXPR_LIST (REG_NONNEG, NULL_RTX,\n+\t\t\t\t\t\t       REG_NOTES (tem));\n \t\t}\n \n \t      bl->nonneg = 1;\n@@ -6457,8 +6459,8 @@ maybe_eliminate_biv_1 (x, insn, bl, eliminate_p, where)\n \t\t/* If the giv has the opposite direction of change,\n \t\t   then reverse the comparison.  */\n \t\tif (INTVAL (v->mult_val) < 0)\n-\t\t  new = gen_rtx (COMPARE, GET_MODE (v->new_reg),\n-\t\t\t\t const0_rtx, v->new_reg);\n+\t\t  new = gen_rtx_COMPARE (GET_MODE (v->new_reg),\n+\t\t\t\t\t const0_rtx, v->new_reg);\n \t\telse\n \t\t  new = v->new_reg;\n \n@@ -6500,11 +6502,11 @@ maybe_eliminate_biv_1 (x, insn, bl, eliminate_p, where)\n \t\t/* If the giv has the opposite direction of change,\n \t\t   then reverse the comparison.  */\n \t\tif (INTVAL (v->mult_val) < 0)\n-\t\t  new = gen_rtx (COMPARE, VOIDmode, copy_rtx (v->add_val),\n-\t\t\t\t v->new_reg);\n+\t\t  new = gen_rtx_COMPARE (VOIDmode, copy_rtx (v->add_val),\n+\t\t\t\t\t v->new_reg);\n \t\telse\n-\t\t  new = gen_rtx (COMPARE, VOIDmode, v->new_reg,\n-\t\t\t\t copy_rtx (v->add_val));\n+\t\t  new = gen_rtx_COMPARE (VOIDmode, v->new_reg,\n+\t\t\t\t\t copy_rtx (v->add_val));\n \n \t\t/* Replace biv with the giv's reduced register.  */\n \t\tupdate_reg_last_use (v->add_val, insn);\n@@ -7088,7 +7090,7 @@ get_condition (jump, earliest)\n     return 0;\n #endif\n \n-  return gen_rtx (code, VOIDmode, op0, op1);\n+  return gen_rtx_fmt_ee (code, VOIDmode, op0, op1);\n }\n \n /* Similar to above routine, except that we also put an invariant last\n@@ -7105,8 +7107,8 @@ get_condition_for_loop (x)\n       || invariant_p (XEXP (comparison, 1)))\n     return comparison;\n \n-  return gen_rtx (swap_condition (GET_CODE (comparison)), VOIDmode,\n-\t\t  XEXP (comparison, 1), XEXP (comparison, 0));\n+  return gen_rtx_fmt_ee (swap_condition (GET_CODE (comparison)), VOIDmode,\n+\t\t\t XEXP (comparison, 1), XEXP (comparison, 0));\n }\n \n #ifdef HAIFA\n@@ -7620,7 +7622,7 @@ instrument_loop_bct (loop_start, loop_end, loop_num_iterations)\n       emit_insn (gen_move_insn (temp_reg1, loop_num_iterations));\n \n       /* this will be count register */\n-      temp_reg2 = gen_rtx (REG, loop_var_mode, COUNT_REGISTER_REGNUM);\n+      temp_reg2 = gen_rtx_REG (loop_var_mode, COUNT_REGISTER_REGNUM);\n       /* we have to move the value to the count register from an GPR\n \t because rtx pointed to by loop_num_iterations could contain\n \t expression which cannot be moved into count register */"}, {"sha": "80f4549b69efbb0f15ef00943742603b13e05874", "filename": "gcc/profile.c", "status": "modified", "additions": 15, "deletions": 16, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38a448ca5dfe60244ab3c1f0ea8e3604ec69370b/gcc%2Fprofile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38a448ca5dfe60244ab3c1f0ea8e3604ec69370b/gcc%2Fprofile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile.c?ref=38a448ca5dfe60244ab3c1f0ea8e3604ec69370b", "patch": "@@ -362,7 +362,7 @@ instrument_arcs (f, num_blocks, dump_file)\n \t\t  emit_barrier_after (arcptr->branch_insn);\n \t\t  \n \t\t  /* Fix up the table jump.  */\n-\t\t  new_lref = gen_rtx (LABEL_REF, Pmode, new_label);\n+\t\t  new_lref = gen_rtx_LABEL_REF (Pmode, new_label);\n \t\t  XVECEXP (PATTERN (arcptr->branch_insn),\n \t\t\t   (code == ADDR_DIFF_VEC), index) = new_lref;\n \t\t}\n@@ -821,7 +821,7 @@ branch_prob (f, dump_file)\n \t  {\n \t    /* Make a fake insn to tag our notes on.  */\n \t    bb_graph[i].first_insn = insn\n-\t      = emit_insn_after (gen_rtx (USE, VOIDmode, stack_pointer_rtx),\n+\t      = emit_insn_after (gen_rtx_USE (VOIDmode, stack_pointer_rtx),\n \t\t\t\t insn);\n \t    prev_code = CALL_INSN;\n \t  }\n@@ -1139,8 +1139,8 @@ branch_prob (f, dump_file)\n \t      num_branches++;\n \t      \n \t      REG_NOTES (arcptr->branch_insn)\n-\t\t= gen_rtx (EXPR_LIST, REG_BR_PROB, GEN_INT (prob),\n-\t\t\t   REG_NOTES (arcptr->branch_insn));\n+\t\t= gen_rtx_EXPR_LIST (REG_BR_PROB, GEN_INT (prob),\n+\t\t\t\t     REG_NOTES (arcptr->branch_insn));\n \t    }\n \t}\n \n@@ -1159,8 +1159,8 @@ branch_prob (f, dump_file)\n       else\n \t{\n \t  REG_NOTES (binfo->first_insn)\n-\t    = gen_rtx (EXPR_LIST, REG_EXEC_COUNT, GEN_INT (total),\n-\t\t       REG_NOTES (binfo->first_insn));\n+\t    = gen_rtx_EXPR_LIST (REG_EXEC_COUNT, GEN_INT (total),\n+\t\t\t\t REG_NOTES (binfo->first_insn));\n \t  if (i == num_blocks - 1)\n \t    return_label_execution_count = total;\n \t}\n@@ -1498,7 +1498,7 @@ init_arc_profiler ()\n   /* Generate and save a copy of this so it can be shared.  */\n   char *name = xmalloc (20);\n   ASM_GENERATE_INTERNAL_LABEL (name, \"LPBX\", 2);\n-  profiler_label = gen_rtx (SYMBOL_REF, Pmode, name);\n+  profiler_label = gen_rtx_SYMBOL_REF (Pmode, name);\n }\n \n /* Output instructions as RTL to increment the arc execution count.  */\n@@ -1510,10 +1510,9 @@ output_arc_profiler (arcno, insert_after)\n {\n   rtx profiler_target_addr\n     = (arcno\n-       ? gen_rtx (CONST, Pmode,\n-\t\t  gen_rtx (PLUS, Pmode, profiler_label,\n-\t\t\t   gen_rtx (CONST_INT, VOIDmode,\n-\t\t\t\t    LONG_TYPE_SIZE / BITS_PER_UNIT * arcno)))\n+       ? gen_rtx_CONST (Pmode,\n+\t\t\tgen_rtx_PLUS (Pmode, profiler_label,\n+\t\t\t\t      GEN_INT (LONG_TYPE_SIZE / BITS_PER_UNIT * arcno)))\n        : profiler_label);\n   enum machine_mode mode = mode_for_size (LONG_TYPE_SIZE, MODE_INT, 0);\n   rtx profiler_reg = gen_reg_rtx (mode);\n@@ -1569,14 +1568,14 @@ output_arc_profiler (arcno, insert_after)\n   start_sequence ();\n \n   emit_move_insn (address_reg, profiler_target_addr);\n-  mem_ref = gen_rtx (MEM, mode, address_reg);\n+  mem_ref = gen_rtx_MEM (mode, address_reg);\n   emit_move_insn (profiler_reg, mem_ref);\n \n-  add_ref = gen_rtx (PLUS, mode, profiler_reg, GEN_INT (1));\n+  add_ref = gen_rtx_PLUS (mode, profiler_reg, GEN_INT (1));\n   emit_move_insn (profiler_reg, add_ref);\n \n   /* This is the same rtx as above, but it is not legal to share this rtx.  */\n-  mem_ref = gen_rtx (MEM, mode, address_reg);\n+  mem_ref = gen_rtx_MEM (mode, address_reg);\n   emit_move_insn (mem_ref, profiler_reg);\n \n   sequence = gen_sequence ();\n@@ -1633,8 +1632,8 @@ output_func_start_profiler ()\n   /* Actually generate the code to call __bb_init_func. */\n   name = xmalloc (20);\n   ASM_GENERATE_INTERNAL_LABEL (name, \"LPBX\", 0);\n-  table_address = force_reg (Pmode, gen_rtx (SYMBOL_REF, Pmode, name));\n-  emit_library_call (gen_rtx (SYMBOL_REF, Pmode, \"__bb_init_func\"), 0,\n+  table_address = force_reg (Pmode, gen_rtx_SYMBOL_REF (Pmode, name));\n+  emit_library_call (gen_rtx_SYMBOL_REF (Pmode, \"__bb_init_func\"), 0,\n \t\t     mode, 1, table_address, Pmode);\n \n   expand_function_end (input_filename, lineno, 0);"}, {"sha": "a2d2489357a8b8d33a16a3c77a33a53dde568a55", "filename": "gcc/recog.c", "status": "modified", "additions": 34, "deletions": 17, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38a448ca5dfe60244ab3c1f0ea8e3604ec69370b/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38a448ca5dfe60244ab3c1f0ea8e3604ec69370b/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=38a448ca5dfe60244ab3c1f0ea8e3604ec69370b", "patch": "@@ -1,5 +1,5 @@\n /* Subroutines used by or related to instruction recognition.\n-   Copyright (C) 1987, 1988, 1991-6, 1997 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 1988, 91-6, 1997 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -20,8 +20,8 @@ Boston, MA 02111-1307, USA.  */\n \n \n #include \"config.h\"\n-#include \"rtl.h\"\n #include <stdio.h>\n+#include \"rtl.h\"\n #include \"insn-config.h\"\n #include \"insn-attr.h\"\n #include \"insn-flags.h\"\n@@ -43,8 +43,7 @@ Boston, MA 02111-1307, USA.  */\n /* Import from final.c: */\n extern rtx alter_subreg ();\n \n-int strict_memory_address_p ();\n-int memory_address_p ();\n+static rtx *find_single_use_1 PROTO((rtx, rtx *));\n \n /* Nonzero means allow operands to be volatile.\n    This should be 0 if you are generating rtl, such as if you are calling\n@@ -260,8 +259,8 @@ apply_change_group ()\n \t\t {\n \t\t   int j;\n \n-\t\t   newpat = gen_rtx (PARALLEL, VOIDmode, \n-\t\t\t\t     gen_rtvec (XVECLEN (pat, 0) - 1));\n+\t\t   newpat = gen_rtx_PARALLEL (VOIDmode, \n+\t\t\t\t\t      gen_rtvec (XVECLEN (pat, 0) - 1));\n \t\t   for (j = 0; j < XVECLEN (newpat, 0); j++)\n \t\t     XVECEXP (newpat, 0, j) = XVECEXP (pat, 0, j);\n \t\t }\n@@ -365,9 +364,10 @@ validate_replace_rtx_1 (loc, from, to, object)\n       if (prev_changes != num_changes && CONSTANT_P (XEXP (x, 0)))\n \t{\n \t  validate_change (object, loc,\n-\t\t\t   gen_rtx (GET_RTX_CLASS (code) == 'c' ? code\n-\t\t\t\t    : swap_condition (code),\n-\t\t\t\t    GET_MODE (x), XEXP (x, 1), XEXP (x, 0)),\n+\t\t\t   gen_rtx_fmt_ee (GET_RTX_CLASS (code) == 'c' ? code\n+\t\t\t\t\t   : swap_condition (code),\n+\t\t\t\t\t   GET_MODE (x), XEXP (x, 1),\n+\t\t\t\t\t   XEXP (x, 0)),\n \t\t\t   1);\n \t  x = *loc;\n \t  code = GET_CODE (x);\n@@ -413,7 +413,7 @@ validate_replace_rtx_1 (loc, from, to, object)\n \t  rtx new = simplify_unary_operation (code, GET_MODE (x), to,\n \t\t\t\t\t      GET_MODE (from));\n \t  if (new == 0)\n-\t    new = gen_rtx (CLOBBER, GET_MODE (x), const0_rtx);\n+\t    new = gen_rtx_CLOBBER (GET_MODE (x), const0_rtx);\n \n \t  validate_change (object, loc, new, 1);\n \t  return;\n@@ -442,7 +442,7 @@ validate_replace_rtx_1 (loc, from, to, object)\n \t\t\t    GET_MODE_SIZE (GET_MODE (SUBREG_REG (x))))\n \t\t       - MIN (UNITS_PER_WORD, GET_MODE_SIZE (mode)));\n \n-\t  new = gen_rtx (MEM, mode, plus_constant (XEXP (to, 0), offset));\n+\t  new = gen_rtx_MEM (mode, plus_constant (XEXP (to, 0), offset));\n \t  MEM_VOLATILE_P (new) = MEM_VOLATILE_P (to);\n \t  RTX_UNCHANGING_P (new) = RTX_UNCHANGING_P (to);\n \t  MEM_IN_STRUCT_P (new) = MEM_IN_STRUCT_P (to);\n@@ -493,8 +493,8 @@ validate_replace_rtx_1 (loc, from, to, object)\n \n \t      pos %= GET_MODE_BITSIZE (wanted_mode);\n \n-\t      newmem = gen_rtx (MEM, wanted_mode,\n-\t\t\t\tplus_constant (XEXP (to, 0), offset));\n+\t      newmem = gen_rtx_MEM (wanted_mode,\n+\t\t\t\t    plus_constant (XEXP (to, 0), offset));\n \t      RTX_UNCHANGING_P (newmem) = RTX_UNCHANGING_P (to);\n \t      MEM_VOLATILE_P (newmem) = MEM_VOLATILE_P (to);\n \t      MEM_IN_STRUCT_P (newmem) = MEM_IN_STRUCT_P (to);\n@@ -505,6 +505,9 @@ validate_replace_rtx_1 (loc, from, to, object)\n \t}\n \n       break;\n+      \n+    default:\n+      break;\n     }\n       \n   fmt = GET_RTX_FORMAT (code);\n@@ -627,6 +630,9 @@ find_single_use_1 (dest, loc)\n     case MEM:\n     case SUBREG:\n       return find_single_use_1 (dest, &XEXP (x, 0));\n+      \n+    default:\n+      break;\n     }\n \n   /* If it wasn't one of the common cases above, check each expression and\n@@ -819,10 +825,18 @@ general_operand (op, mode)\n       register rtx y = XEXP (op, 0);\n       if (! volatile_ok && MEM_VOLATILE_P (op))\n \treturn 0;\n+      if (GET_CODE (y) == ADDRESSOF)\n+\treturn 1;\n       /* Use the mem's mode, since it will be reloaded thus.  */\n       mode = GET_MODE (op);\n       GO_IF_LEGITIMATE_ADDRESS (mode, y, win);\n     }\n+\n+  /* Pretend this is an operand for now; we'll run force_operand\n+     on its replacement in fixup_var_refs_1.  */\n+  if (code == ADDRESSOF)\n+    return 1;\n+\n   return 0;\n \n  win:\n@@ -1058,6 +1072,9 @@ memory_address_p (mode, addr)\n      enum machine_mode mode;\n      register rtx addr;\n {\n+  if (GET_CODE (addr) == ADDRESSOF)\n+    return 1;\n+  \n   GO_IF_LEGITIMATE_ADDRESS (mode, addr, win);\n   return 0;\n \n@@ -1560,7 +1577,7 @@ adj_offsettable_operand (op, offset)\n \n       if (CONSTANT_ADDRESS_P (y))\n \t{\n-\t  new = gen_rtx (MEM, GET_MODE (op), plus_constant_for_output (y, offset));\n+\t  new = gen_rtx_MEM (GET_MODE (op), plus_constant_for_output (y, offset));\n \t  RTX_UNCHANGING_P (new) = RTX_UNCHANGING_P (op);\n \t  return new;\n \t}\n@@ -1580,7 +1597,7 @@ adj_offsettable_operand (op, offset)\n \t    }\n \t}\n \n-      new = gen_rtx (MEM, GET_MODE (op), plus_constant_for_output (y, offset));\n+      new = gen_rtx_MEM (GET_MODE (op), plus_constant_for_output (y, offset));\n       RTX_UNCHANGING_P (new) = RTX_UNCHANGING_P (op);\n       return new;\n     }\n@@ -1666,7 +1683,7 @@ constrain_operands (insn_code_num, strict)\n \t  earlyclobber[opno] = 0;\n \n \t  /* A unary operator may be accepted by the predicate, but it\n-\t     is irrelevant for matching contraints.  */\n+\t     is irrelevant for matching constraints.  */\n \t  if (GET_RTX_CLASS (GET_CODE (op)) == '1')\n \t    op = XEXP (op, 0);\n \n@@ -1975,7 +1992,7 @@ constrain_operands (insn_code_num, strict)\n }\n \n /* Return 1 iff OPERAND (assumed to be a REG rtx)\n-   is a hard reg in class CLASS when its regno is offsetted by OFFSET\n+   is a hard reg in class CLASS when its regno is offset by OFFSET\n    and changed to mode MODE.\n    If REG occupies multiple hard regs, all of them must be in CLASS.  */\n "}, {"sha": "243d74db128b759b074db71ea3892f5cbe20cd04", "filename": "gcc/reg-stack.c", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38a448ca5dfe60244ab3c1f0ea8e3604ec69370b/gcc%2Freg-stack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38a448ca5dfe60244ab3c1f0ea8e3604ec69370b/gcc%2Freg-stack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freg-stack.c?ref=38a448ca5dfe60244ab3c1f0ea8e3604ec69370b", "patch": "@@ -383,10 +383,10 @@ reg_to_stack (first, file)\n          {\n            for (mode = GET_CLASS_NARROWEST_MODE (MODE_FLOAT); mode != VOIDmode;\n                mode = GET_MODE_WIDER_MODE (mode))\n-              FP_MODE_REG (i, mode) = gen_rtx (REG, mode, i);\n+              FP_MODE_REG (i, mode) = gen_rtx_REG (mode, i);\n            for (mode = GET_CLASS_NARROWEST_MODE (MODE_COMPLEX_FLOAT); mode != VOIDmode;\n                mode = GET_MODE_WIDER_MODE (mode))\n-              FP_MODE_REG (i, mode) = gen_rtx (REG, mode, i);\n+              FP_MODE_REG (i, mode) = gen_rtx_REG (mode, i);\n          }\n       }\n    }\n@@ -1026,7 +1026,7 @@ record_asm_reg_life (insn, regstack, operands, constraints,\n   if (malformed_asm)\n     {\n       /* Avoid further trouble with this insn.  */\n-      PATTERN (insn) = gen_rtx (USE, VOIDmode, const0_rtx);\n+      PATTERN (insn) = gen_rtx_USE (VOIDmode, const0_rtx);\n       PUT_MODE (insn, VOIDmode);\n       return;\n     }\n@@ -1047,8 +1047,8 @@ record_asm_reg_life (insn, regstack, operands, constraints,\n \t REG_UNUSED.  */\n \n       if (! TEST_HARD_REG_BIT (regstack->reg_set, REGNO (op)))\n-\tREG_NOTES (insn) = gen_rtx (EXPR_LIST, REG_UNUSED, op,\n-\t\t\t\t    REG_NOTES (insn));\n+\tREG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_UNUSED, op,\n+\t\t\t\t\t      REG_NOTES (insn));\n \n       CLEAR_HARD_REG_BIT (regstack->reg_set, REGNO (op));\n     }\n@@ -1069,8 +1069,8 @@ record_asm_reg_life (insn, regstack, operands, constraints,\n       if (! TEST_HARD_REG_BIT (regstack->reg_set, REGNO (operands[i]))\n \t  && operand_matches[i] == -1\n \t  && find_regno_note (insn, REG_DEAD, REGNO (operands[i])) == NULL_RTX)\n-\tREG_NOTES (insn) = gen_rtx (EXPR_LIST, REG_DEAD, operands[i],\n-\t\t\t\t    REG_NOTES (insn));\n+\tREG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_DEAD, operands[i],\n+\t\t\t\t\t      REG_NOTES (insn));\n \n       SET_HARD_REG_BIT (regstack->reg_set, REGNO (operands[i]));\n     }\n@@ -1235,13 +1235,13 @@ record_reg_life (insn, block, regstack)\n \t  {\n \t    if (TEST_HARD_REG_BIT (src, regno)\n \t\t&& ! TEST_HARD_REG_BIT (dest, regno))\n-\t      REG_NOTES (insn) = gen_rtx (EXPR_LIST, REG_DEAD,\n-\t\t\t\t\t  FP_MODE_REG (regno, DFmode),\n-\t\t\t\t\t  REG_NOTES (insn));\n+\t      REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_DEAD,\n+\t\t\t\t\t\t    FP_MODE_REG (regno, DFmode),\n+\t\t\t\t\t\t    REG_NOTES (insn));\n \t    else if (TEST_HARD_REG_BIT (dest, regno))\n-\t      REG_NOTES (insn) = gen_rtx (EXPR_LIST, REG_UNUSED,\n-\t\t\t\t\t  FP_MODE_REG (regno, DFmode),\n-\t\t\t\t\t  REG_NOTES (insn));\n+\t      REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_UNUSED,\n+\t\t\t\t\t\t    FP_MODE_REG (regno, DFmode),\n+\t\t\t\t\t\t    REG_NOTES (insn));\n \t  }\n \n       if (GET_CODE (insn) == CALL_INSN)\n@@ -1263,8 +1263,8 @@ record_reg_life (insn, block, regstack)\n \t           cannot be used on these insns, because they do not appear in\n \t           block_number[].  */\n \n-\t        pat = gen_rtx (SET, VOIDmode, FP_MODE_REG (reg, DFmode),\n-\t\t\t       CONST0_RTX (DFmode));\n+\t        pat = gen_rtx_SET (VOIDmode, FP_MODE_REG (reg, DFmode),\n+\t\t\t\t   CONST0_RTX (DFmode));\n \t        init = emit_insn_after (pat, insn);\n \t        PUT_MODE (init, QImode);\n \n@@ -1331,8 +1331,8 @@ find_blocks (first)\n \t  /* Make a list of all labels referred to other than by jumps.  */\n \t  for (note = REG_NOTES (insn); note; note = XEXP (note, 1))\n \t    if (REG_NOTE_KIND (note) == REG_LABEL)\n-\t      label_value_list = gen_rtx (EXPR_LIST, VOIDmode, XEXP (note, 0),\n-\t\t\t\t\t  label_value_list);\n+\t      label_value_list = gen_rtx_EXPR_LIST (VOIDmode, XEXP (note, 0),\n+\t\t\t\t\t\t    label_value_list);\n \t}\n \n       block_number[INSN_UID (insn)] = block;\n@@ -1358,13 +1358,13 @@ find_blocks (first)\n \t    {\n \t      for (x = label_value_list; x; x = XEXP (x, 1))\n \t\trecord_label_references (insn,\n-\t\t\t\t\t gen_rtx (LABEL_REF, VOIDmode,\n-\t\t\t\t\t\t  XEXP (x, 0)));\n+\t\t\t\t\t gen_rtx_LABEL_REF (VOIDmode,\n+\t\t\t\t\t\t\t    XEXP (x, 0)));\n \n \t      for (x = forced_labels; x; x = XEXP (x, 1))\n \t\trecord_label_references (insn,\n-\t\t\t\t\t gen_rtx (LABEL_REF, VOIDmode,\n-\t\t\t\t\t\t  XEXP (x, 0)));\n+\t\t\t\t\t gen_rtx_LABEL_REF (VOIDmode,\n+\t\t\t\t\t\t\t    XEXP (x, 0)));\n \t    }\n \n \t  record_label_references (insn, pat);\n@@ -1590,8 +1590,8 @@ stack_reg_life_analysis (first, stackentry)\n       {\n \trtx init_rtx;\n \n-\tinit_rtx = gen_rtx (SET, VOIDmode, FP_MODE_REG(reg, DFmode),\n-\t\t\t    CONST0_RTX (DFmode));\n+\tinit_rtx = gen_rtx_SET (VOIDmode, FP_MODE_REG(reg, DFmode),\n+\t\t\t\tCONST0_RTX (DFmode));\n \tblock_begin[0] = emit_insn_after (init_rtx, first);\n \tPUT_MODE (block_begin[0], QImode);\n \n@@ -1707,16 +1707,16 @@ emit_pop_insn (insn, regstack, reg, when)\n   if (hard_regno < FIRST_STACK_REG)\n     abort ();\n \n-  pop_rtx = gen_rtx (SET, VOIDmode, FP_MODE_REG (hard_regno, DFmode),\n-\t\t     FP_MODE_REG (FIRST_STACK_REG, DFmode));\n+  pop_rtx = gen_rtx_SET (VOIDmode, FP_MODE_REG (hard_regno, DFmode),\n+\t\t\t FP_MODE_REG (FIRST_STACK_REG, DFmode));\n \n   pop_insn = (*when) (pop_rtx, insn);\n   /* ??? This used to be VOIDmode, but that seems wrong.  */\n   PUT_MODE (pop_insn, QImode);\n \n-  REG_NOTES (pop_insn) = gen_rtx (EXPR_LIST, REG_DEAD,\n-\t\t\t\t  FP_MODE_REG (FIRST_STACK_REG, DFmode),\n-\t\t\t\t  REG_NOTES (pop_insn));\n+  REG_NOTES (pop_insn) = gen_rtx_EXPR_LIST (REG_DEAD,\n+\t\t\t\t\t    FP_MODE_REG (FIRST_STACK_REG, DFmode),\n+\t\t\t\t\t    REG_NOTES (pop_insn));\n \n   regstack->reg[regstack->top - (hard_regno - FIRST_STACK_REG)]\n     = regstack->reg[regstack->top];\n@@ -1921,8 +1921,8 @@ move_for_stack_reg (insn, regstack, pat)\n \t  push_rtx = gen_movxf (top_stack_reg, top_stack_reg);\n \t  push_insn = emit_insn_before (push_rtx, insn);\n \t  PUT_MODE (push_insn, QImode);\n-\t  REG_NOTES (insn) = gen_rtx (EXPR_LIST, REG_DEAD, top_stack_reg,\n-\t\t\t\t      REG_NOTES (insn));\n+\t  REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_DEAD, top_stack_reg,\n+\t\t\t\t\t\tREG_NOTES (insn));\n \t}\n \n       replace_reg (psrc, FIRST_STACK_REG);"}, {"sha": "b2d2c03add65534dc8faa559144cfc071debae99", "filename": "gcc/regclass.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38a448ca5dfe60244ab3c1f0ea8e3604ec69370b/gcc%2Fregclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38a448ca5dfe60244ab3c1f0ea8e3604ec69370b/gcc%2Fregclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregclass.c?ref=38a448ca5dfe60244ab3c1f0ea8e3604ec69370b", "patch": "@@ -655,7 +655,7 @@ regclass (f, nregs)\n \n   for (i = 0; i < N_REG_CLASSES; i++)\n     {\n-      rtx r = gen_rtx (REG, VOIDmode, 0);\n+      rtx r = gen_rtx_REG (VOIDmode, 0);\n       enum machine_mode m;\n \n       for (j = 0; j < FIRST_PSEUDO_REGISTER; j++)\n@@ -1645,22 +1645,22 @@ auto_inc_dec_reg_p (reg, mode)\n      enum machine_mode mode;\n {\n #ifdef HAVE_POST_INCREMENT\n-  if (memory_address_p (mode, gen_rtx (POST_INC, Pmode, reg)))\n+  if (memory_address_p (mode, gen_rtx_POST_INC (Pmode, reg)))\n     return 1;\n #endif\n \n #ifdef HAVE_POST_DECREMENT\n-  if (memory_address_p (mode, gen_rtx (POST_DEC, Pmode, reg)))\n+  if (memory_address_p (mode, gen_rtx_POST_DEC (Pmode, reg)))\n     return 1;\n #endif\n \n #ifdef HAVE_PRE_INCREMENT\n-  if (memory_address_p (mode, gen_rtx (PRE_INC, Pmode, reg)))\n+  if (memory_address_p (mode, gen_rtx_PRE_INC (Pmode, reg)))\n     return 1;\n #endif\n \n #ifdef HAVE_PRE_DECREMENT\n-  if (memory_address_p (mode, gen_rtx (PRE_DEC, Pmode, reg)))\n+  if (memory_address_p (mode, gen_rtx_PRE_DEC (Pmode, reg)))\n     return 1;\n #endif\n "}, {"sha": "a6695df03c7735d60b369879f977bceb2ad59d3f", "filename": "gcc/regmove.c", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38a448ca5dfe60244ab3c1f0ea8e3604ec69370b/gcc%2Fregmove.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38a448ca5dfe60244ab3c1f0ea8e3604ec69370b/gcc%2Fregmove.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregmove.c?ref=38a448ca5dfe60244ab3c1f0ea8e3604ec69370b", "patch": "@@ -114,14 +114,12 @@ try_auto_increment (insn, inc_insn, inc_insn_set, reg, increment, pre)\n \t\t   &SET_SRC (inc_insn_set),\n \t\t   XEXP (SET_SRC (inc_insn_set), 0), 1);\n \t      validate_change (insn, &XEXP (use, 0),\n-\t\t\t       gen_rtx (inc_code,\n-\t\t\t\t\tPmode,\n-\t\t\t\t\treg), 1);\n+\t\t\t       gen_rtx_fmt_e (inc_code, Pmode, reg), 1);\n \t      if (apply_change_group ())\n \t\t{\n \t\t  REG_NOTES (insn)\n-\t\t    = gen_rtx (EXPR_LIST, REG_INC,\n-\t\t\t       reg, REG_NOTES (insn));\n+\t\t    = gen_rtx_EXPR_LIST (REG_INC,\n+\t\t\t\t\t reg, REG_NOTES (insn));\n \t\t  if (! inc_insn_set)\n \t\t    {\n \t\t      PUT_CODE (inc_insn, NOTE);\n@@ -218,7 +216,7 @@ optimize_reg_copy_3 (insn, dest, src)\n       XEXP (src, 0) = src_reg;\n       return;\n     }\n-  subreg = gen_rtx(SUBREG, old_mode, src_reg, 0);\n+  subreg = gen_rtx_SUBREG (old_mode, src_reg, 0);\n   while (p = NEXT_INSN (p), p != insn)\n     {\n       if (GET_RTX_CLASS (GET_CODE (p)) != 'i')\n@@ -530,8 +528,8 @@ regmove_optimize (f, nregs, regmove_dump_file)\n \t\t     >= GET_MODE_SIZE (GET_MODE (SUBREG_REG (dst))))\n \t\t{\n \t\t  src_subreg\n-\t\t    = gen_rtx(SUBREG,  GET_MODE (SUBREG_REG (dst)),\n-\t\t\t      src, SUBREG_WORD (dst));\n+\t\t    = gen_rtx_SUBREG (GET_MODE (SUBREG_REG (dst)),\n+\t\t\t\t      src, SUBREG_WORD (dst));\n \t\t  dst = SUBREG_REG (dst);\n \t\t}\n \t      if (GET_CODE (dst) != REG\n@@ -1381,9 +1379,9 @@ regmove_profitable_p ()\n \t      break;\n \t  if (i + 2 >= FIRST_PSEUDO_REGISTER)\n \t    break;\n-\t  reg0 = gen_rtx (REG, insn_operand_mode[icode][0], i);\n-\t  reg1 = gen_rtx (REG, insn_operand_mode[icode][1], i + 1);\n-\t  reg2 = gen_rtx (REG, insn_operand_mode[icode][2], i + 2);\n+\t  reg0 = gen_rtx_REG (insn_operand_mode[icode][0], i);\n+\t  reg1 = gen_rtx_REG (insn_operand_mode[icode][1], i + 1);\n+\t  reg2 = gen_rtx_REG (insn_operand_mode[icode][2], i + 2);\n \t  if (! (*insn_operand_predicate[icode][0]) (reg0, VOIDmode)\n \t      || ! (*insn_operand_predicate[icode][1]) (reg1, VOIDmode)\n \t      || ! (*insn_operand_predicate[icode][2]) (reg2, VOIDmode))"}, {"sha": "983060a865a9a5c3ff73a5e70a702d1ad79ee2a4", "filename": "gcc/reload.c", "status": "modified", "additions": 48, "deletions": 48, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38a448ca5dfe60244ab3c1f0ea8e3604ec69370b/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38a448ca5dfe60244ab3c1f0ea8e3604ec69370b/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=38a448ca5dfe60244ab3c1f0ea8e3604ec69370b", "patch": "@@ -830,10 +830,10 @@ push_reload (in, out, inloc, outloc, class,\n     {\n       if (GET_CODE (XEXP (in, 0)) == POST_INC\n \t  || GET_CODE (XEXP (in, 0)) == POST_DEC)\n-\tin = gen_rtx (MEM, GET_MODE (in), XEXP (XEXP (in, 0), 0));\n+\tin = gen_rtx_MEM (GET_MODE (in), XEXP (XEXP (in, 0), 0));\n       if (GET_CODE (XEXP (in, 0)) == PRE_INC\n \t  || GET_CODE (XEXP (in, 0)) == PRE_DEC)\n-\tout = gen_rtx (MEM, GET_MODE (out), XEXP (XEXP (out, 0), 0));\n+\tout = gen_rtx_MEM (GET_MODE (out), XEXP (XEXP (out, 0), 0));\n     }\n \n   /* If we are reloading a (SUBREG constant ...), really reload just the\n@@ -1078,16 +1078,16 @@ push_reload (in, out, inloc, outloc, class,\n   if (in != 0 && GET_CODE (in) == SUBREG && GET_CODE (SUBREG_REG (in)) == REG\n       && REGNO (SUBREG_REG (in)) < FIRST_PSEUDO_REGISTER\n       && ! dont_remove_subreg)\n-    in = gen_rtx (REG, GET_MODE (in),\n-\t\t  REGNO (SUBREG_REG (in)) + SUBREG_WORD (in));\n+    in = gen_rtx_REG (GET_MODE (in),\n+\t\t      REGNO (SUBREG_REG (in)) + SUBREG_WORD (in));\n \n   /* Similarly for OUT.  */\n   if (out != 0 && GET_CODE (out) == SUBREG\n       && GET_CODE (SUBREG_REG (out)) == REG\n       && REGNO (SUBREG_REG (out)) < FIRST_PSEUDO_REGISTER\n       && ! dont_remove_subreg)\n-    out = gen_rtx (REG, GET_MODE (out),\n-\t\t  REGNO (SUBREG_REG (out)) + SUBREG_WORD (out));\n+    out = gen_rtx_REG (GET_MODE (out),\n+\t\t       REGNO (SUBREG_REG (out)) + SUBREG_WORD (out));\n \n   /* Narrow down the class of register wanted if that is\n      desirable on this machine for efficiency.  */\n@@ -1442,7 +1442,7 @@ push_reload (in, out, inloc, outloc, class,\n \t    && TEST_HARD_REG_BIT (reg_class_contents[(int) class], regno)\n \t    && !fixed_regs[regno])\n \t  {\n-\t    reload_reg_rtx[i] = gen_rtx (REG, inmode, regno);\n+\t    reload_reg_rtx[i] = gen_rtx_REG (inmode, regno);\n \t    break;\n \t  }\n     }\n@@ -1658,9 +1658,9 @@ combine_reloads ()\n \t\t\t    REGNO (XEXP (note, 0)))))))\n \t&& ! fixed_regs[REGNO (XEXP (note, 0))])\n       {\n-\treload_reg_rtx[output_reload] = gen_rtx (REG,\n-\t\t\t\t\t\t reload_outmode[output_reload],\n-\t\t\t\t\t\t REGNO (XEXP (note, 0)));\n+\treload_reg_rtx[output_reload]\n+\t  = gen_rtx_REG (reload_outmode[output_reload],\n+\t\t\t REGNO (XEXP (note, 0)));\n \treturn;\n       }\n }\n@@ -1764,7 +1764,7 @@ find_dummy_reload (real_in, real_out, inloc, outloc,\n \t      if (GET_CODE (real_out) == REG)\n \t\tvalue = real_out;\n \t      else\n-\t\tvalue = gen_rtx (REG, outmode, regno);\n+\t\tvalue = gen_rtx_REG (outmode, regno);\n \t    }\n \t}\n \n@@ -1818,7 +1818,7 @@ find_dummy_reload (real_in, real_out, inloc, outloc,\n \t      if (GET_CODE (real_in) == REG)\n \t\tvalue = real_in;\n \t      else\n-\t\tvalue = gen_rtx (REG, inmode, regno);\n+\t\tvalue = gen_rtx_REG (inmode, regno);\n \t    }\n \t}\n     }\n@@ -2111,28 +2111,28 @@ decompose (x)\n \t{\n \t  if (GET_CODE (XEXP (offset, 0)) == CONST_INT)\n \t    {\n-\t      base = gen_rtx (PLUS, GET_MODE (base), base, XEXP (offset, 1));\n+\t      base = gen_rtx_PLUS (GET_MODE (base), base, XEXP (offset, 1));\n \t      offset = XEXP (offset, 0);\n \t    }\n \t  else if (GET_CODE (XEXP (offset, 1)) == CONST_INT)\n \t    {\n-\t      base = gen_rtx (PLUS, GET_MODE (base), base, XEXP (offset, 0));\n+\t      base = gen_rtx_PLUS (GET_MODE (base), base, XEXP (offset, 0));\n \t      offset = XEXP (offset, 1);\n \t    }\n \t  else\n \t    {\n-\t      base = gen_rtx (PLUS, GET_MODE (base), base, offset);\n+\t      base = gen_rtx_PLUS (GET_MODE (base), base, offset);\n \t      offset = const0_rtx;\n \t    }\n \t}\n       else if (GET_CODE (offset) != CONST_INT)\n \t{\n-\t  base = gen_rtx (PLUS, GET_MODE (base), base, offset);\n+\t  base = gen_rtx_PLUS (GET_MODE (base), base, offset);\n \t  offset = const0_rtx;\n \t}\n \n       if (all_const && GET_CODE (base) == PLUS)\n-\tbase = gen_rtx (CONST, GET_MODE (base), base);\n+\tbase = gen_rtx_CONST (GET_MODE (base), base);\n \n       if (GET_CODE (offset) != CONST_INT)\n \tabort ();\n@@ -2398,7 +2398,7 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t\t  {\n \t\t    error_for_asm (insn, \"operand constraints differ in number of alternatives\");\n \t\t    /* Avoid further trouble with this insn.  */\n-\t\t    PATTERN (insn) = gen_rtx (USE, VOIDmode, const0_rtx);\n+\t\t    PATTERN (insn) = gen_rtx_USE (VOIDmode, const0_rtx);\n \t\t    n_reloads = 0;\n \t\t    return;\n \t\t  }\n@@ -2617,13 +2617,13 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t\t after it.  */\n \n \t      if (modified[i] != RELOAD_READ)\n-\t\tPUT_MODE (emit_insn_after (gen_rtx (CLOBBER, VOIDmode,\n-\t\t\t\t\t\t    recog_operand[i]),\n+\t\tPUT_MODE (emit_insn_after (gen_rtx_CLOBBER (VOIDmode,\n+\t\t\t\t\t\t\t    recog_operand[i]),\n \t\t\t\t\t   insn),\n \t\t\t  DImode);\n \n \t      *recog_operand_loc[i] = recog_operand[i]\n-\t\t= gen_rtx (MEM, GET_MODE (recog_operand[i]), address);\n+\t\t= gen_rtx_MEM (GET_MODE (recog_operand[i]), address);\n \t      RTX_UNCHANGING_P (recog_operand[i])\n \t\t= RTX_UNCHANGING_P (regno_reg_rtx[regno]);\n \t      find_reloads_address (GET_MODE (recog_operand[i]),\n@@ -3428,7 +3428,7 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \tabort ();\n       error_for_asm (insn, \"inconsistent operand constraints in an `asm'\");\n       /* Avoid further trouble with this insn.  */\n-      PATTERN (insn) = gen_rtx (USE, VOIDmode, const0_rtx);\n+      PATTERN (insn) = gen_rtx_USE (VOIDmode, const0_rtx);\n       n_reloads = 0;\n       return;\n     }\n@@ -3631,7 +3631,7 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t  {\n \t    error_for_asm (insn, \"inconsistent operand constraints in an `asm'\");\n \t    /* Avoid further trouble with this insn.  */\n-\t    PATTERN (insn) = gen_rtx (USE, VOIDmode, const0_rtx);\n+\t    PATTERN (insn) = gen_rtx_USE (VOIDmode, const0_rtx);\n \t    n_reloads = 0;\n \t    return;\n \t  }\n@@ -4109,7 +4109,7 @@ find_reloads_toplev (x, opnum, type, ind_levels, is_set_dest)\n \t  if (rtx_varies_p (addr))\n \t    addr = copy_rtx (addr);\n \n-\t  x = gen_rtx (MEM, GET_MODE (x), addr);\n+\t  x = gen_rtx_MEM (GET_MODE (x), addr);\n \t  RTX_UNCHANGING_P (x) = RTX_UNCHANGING_P (regno_reg_rtx[regno]);\n \t  find_reloads_address (GET_MODE (x), NULL_PTR,\n \t\t\t\tXEXP (x, 0),\n@@ -4198,7 +4198,7 @@ find_reloads_toplev (x, opnum, type, ind_levels, is_set_dest)\n \t      offset -= MIN (size, UNITS_PER_WORD);\n \t    }\n \t  addr = plus_constant (addr, offset);\n-\t  x = gen_rtx (MEM, GET_MODE (x), addr);\n+\t  x = gen_rtx_MEM (GET_MODE (x), addr);\n \t  RTX_UNCHANGING_P (x) = RTX_UNCHANGING_P (regno_reg_rtx[regno]);\n \t  find_reloads_address (GET_MODE (x), NULL_PTR,\n \t\t\t\tXEXP (x, 0),\n@@ -4244,7 +4244,7 @@ make_memloc (ad, regno)\n   if (rtx_varies_p (tem))\n     tem = copy_rtx (tem);\n \n-  tem = gen_rtx (MEM, GET_MODE (ad), tem);\n+  tem = gen_rtx_MEM (GET_MODE (ad), tem);\n   RTX_UNCHANGING_P (tem) = RTX_UNCHANGING_P (regno_reg_rtx[regno]);\n   memlocs[n_memlocs++] = tem;\n   return tem;\n@@ -4497,9 +4497,9 @@ find_reloads_address (mode, memrefloc, ad, loc, opnum, type, ind_levels, insn)\n \t       || XEXP (XEXP (ad, 0), 0) == stack_pointer_rtx)\n \t   && ! memory_address_p (mode, ad))\n     {\n-      *loc = ad = gen_rtx (PLUS, GET_MODE (ad),\n-\t\t\t   plus_constant (XEXP (XEXP (ad, 0), 0),\n-\t\t\t\t\t  INTVAL (XEXP (ad, 1))),\n+      *loc = ad = gen_rtx_PLUS (GET_MODE (ad),\n+\t\t\t\tplus_constant (XEXP (XEXP (ad, 0), 0),\n+\t\t\t\t\t       INTVAL (XEXP (ad, 1))),\n \t\t\t   XEXP (XEXP (ad, 0), 1));\n       find_reloads_address_part (XEXP (ad, 0), &XEXP (ad, 0),\n \t\t\t\t reload_address_base_reg_class,\n@@ -4522,10 +4522,10 @@ find_reloads_address (mode, memrefloc, ad, loc, opnum, type, ind_levels, insn)\n \t       || XEXP (XEXP (ad, 0), 1) == stack_pointer_rtx)\n \t   && ! memory_address_p (mode, ad))\n     {\n-      *loc = ad = gen_rtx (PLUS, GET_MODE (ad),\n-\t\t\t   XEXP (XEXP (ad, 0), 0),\n-\t\t\t   plus_constant (XEXP (XEXP (ad, 0), 1),\n-\t\t\t\t\t  INTVAL (XEXP (ad, 1))));\n+      *loc = ad = gen_rtx_PLUS (GET_MODE (ad),\n+\t\t\t\tXEXP (XEXP (ad, 0), 0),\n+\t\t\t\tplus_constant (XEXP (XEXP (ad, 0), 1),\n+\t\t\t\t\t       INTVAL (XEXP (ad, 1))));\n       find_reloads_address_part (XEXP (ad, 1), &XEXP (ad, 1),\n \t\t\t\t reload_address_base_reg_class,\n \t\t\t\t GET_MODE (ad), opnum, type, ind_levels);\n@@ -4679,10 +4679,10 @@ form_sum (x, y)\n       if (GET_CODE (y) == CONST)\n \ty = XEXP (y, 0);\n \n-      return gen_rtx (CONST, VOIDmode, gen_rtx (PLUS, mode, x, y));\n+      return gen_rtx_CONST (VOIDmode, gen_rtx_PLUS (mode, x, y));\n     }\n \n-  return gen_rtx (PLUS, mode, x, y);\n+  return gen_rtx_PLUS (mode, x, y);\n }\n \f\n /* If ADDR is a sum containing a pseudo register that should be\n@@ -4798,17 +4798,17 @@ find_reloads_address_1 (mode, x, context, loc, opnum, type, ind_levels, insn)\n \t    op0 = SUBREG_REG (op0);\n \t    code0 = GET_CODE (op0);\n \t    if (code0 == REG && REGNO (op0) < FIRST_PSEUDO_REGISTER)\n-\t      op0 = gen_rtx (REG, word_mode,\n-\t\t\t     REGNO (op0) + SUBREG_WORD (orig_op0));\n+\t      op0 = gen_rtx_REG (word_mode,\n+\t\t\t\t REGNO (op0) + SUBREG_WORD (orig_op0));\n \t  }\n \n \tif (GET_CODE (op1) == SUBREG)\n \t  {\n \t    op1 = SUBREG_REG (op1);\n \t    code1 = GET_CODE (op1);\n \t    if (code1 == REG && REGNO (op1) < FIRST_PSEUDO_REGISTER)\n-\t      op1 = gen_rtx (REG, GET_MODE (op1),\n-\t\t\t     REGNO (op1) + SUBREG_WORD (orig_op1));\n+\t      op1 = gen_rtx_REG (GET_MODE (op1),\n+\t\t\t\t REGNO (op1) + SUBREG_WORD (orig_op1));\n \t  }\n \n \tif (code0 == MULT || code0 == SIGN_EXTEND || code0 == TRUNCATE \n@@ -4915,7 +4915,7 @@ find_reloads_address_1 (mode, x, context, loc, opnum, type, ind_levels, insn)\n \t\t\t\t    &XEXP (tem, 0), opnum, type,\n \t\t\t\t    ind_levels, insn);\n \t      /* Put this inside a new increment-expression.  */\n-\t      x = gen_rtx (GET_CODE (x), GET_MODE (x), tem);\n+\t      x = gen_rtx_fmt_e (GET_CODE (x), GET_MODE (x), tem);\n \t      /* Proceed to reload that, as if it contained a register.  */\n \t    }\n \n@@ -5219,7 +5219,7 @@ find_reloads_address_part (x, loc, class, mode, opnum, type, ind_levels)\n     {\n       rtx tem = force_const_mem (GET_MODE (x), XEXP (x, 1));\n \n-      x = gen_rtx (PLUS, GET_MODE (x), XEXP (x, 0), tem);\n+      x = gen_rtx_PLUS (GET_MODE (x), XEXP (x, 0), tem);\n       find_reloads_address (mode, &tem, XEXP (tem, 0), &XEXP (tem, 0),\n \t\t\t    opnum, type, ind_levels, 0);\n     }\n@@ -5251,7 +5251,7 @@ subst_reloads ()\n \t     do the wrong thing if RELOADREG is multi-word.  RELOADREG\n \t     will always be a REG here.  */\n \t  if (GET_MODE (reloadreg) != r->mode && r->mode != VOIDmode)\n-\t    reloadreg = gen_rtx (REG, r->mode, REGNO (reloadreg));\n+\t    reloadreg = gen_rtx_REG (r->mode, REGNO (reloadreg));\n \n \t  /* If we are putting this into a SUBREG and RELOADREG is a\n \t     SUBREG, we would be making nested SUBREGs, so we have to fix\n@@ -5335,7 +5335,7 @@ find_replacement (loc)\n       if (reloadreg && r->where == loc)\n \t{\n \t  if (r->mode != VOIDmode && GET_MODE (reloadreg) != r->mode)\n-\t    reloadreg = gen_rtx (REG, r->mode, REGNO (reloadreg));\n+\t    reloadreg = gen_rtx_REG (r->mode, REGNO (reloadreg));\n \n \t  return reloadreg;\n \t}\n@@ -5346,13 +5346,13 @@ find_replacement (loc)\n \t     ??? Is it actually still ever a SUBREG?  If so, why?  */\n \n \t  if (GET_CODE (reloadreg) == REG)\n-\t    return gen_rtx (REG, GET_MODE (*loc),\n-\t\t\t    REGNO (reloadreg) + SUBREG_WORD (*loc));\n+\t    return gen_rtx_REG (GET_MODE (*loc),\n+\t\t\t\tREGNO (reloadreg) + SUBREG_WORD (*loc));\n \t  else if (GET_MODE (reloadreg) == GET_MODE (*loc))\n \t    return reloadreg;\n \t  else\n-\t    return gen_rtx (SUBREG, GET_MODE (*loc), SUBREG_REG (reloadreg),\n-\t\t\t    SUBREG_WORD (reloadreg) + SUBREG_WORD (*loc));\n+\t    return gen_rtx_SUBREG (GET_MODE (*loc), SUBREG_REG (reloadreg),\n+\t\t\t\t   SUBREG_WORD (reloadreg) + SUBREG_WORD (*loc));\n \t}\n     }\n \n@@ -5365,7 +5365,7 @@ find_replacement (loc)\n       rtx y = find_replacement (&XEXP (*loc, 1));\n \n       if (x != XEXP (*loc, 0) || y != XEXP (*loc, 1))\n-\treturn gen_rtx (GET_CODE (*loc), GET_MODE (*loc), x, y);\n+\treturn gen_rtx_fmt_ee (GET_CODE (*loc), GET_MODE (*loc), x, y);\n     }\n \n   return *loc;"}, {"sha": "6de93b9b44b02693fd5e16661f3a9574e37f356e", "filename": "gcc/reload1.c", "status": "modified", "additions": 85, "deletions": 84, "changes": 169, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38a448ca5dfe60244ab3c1f0ea8e3604ec69370b/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38a448ca5dfe60244ab3c1f0ea8e3604ec69370b/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=38a448ca5dfe60244ab3c1f0ea8e3604ec69370b", "patch": "@@ -417,30 +417,30 @@ init_reload ()\n      permitted, zero if it is not permitted at all.  */\n \n   register rtx tem\n-    = gen_rtx (MEM, Pmode,\n-\t       gen_rtx (PLUS, Pmode,\n-\t\t\tgen_rtx (REG, Pmode, LAST_VIRTUAL_REGISTER + 1),\n-\t\t\tGEN_INT (4)));\n+    = gen_rtx_MEM (Pmode,\n+\t\t   gen_rtx_PLUS (Pmode,\n+\t\t\t\t gen_rtx_REG (Pmode, LAST_VIRTUAL_REGISTER + 1),\n+\t\t\t\t GEN_INT (4)));\n   spill_indirect_levels = 0;\n \n   while (memory_address_p (QImode, tem))\n     {\n       spill_indirect_levels++;\n-      tem = gen_rtx (MEM, Pmode, tem);\n+      tem = gen_rtx_MEM (Pmode, tem);\n     }\n \n   /* See if indirect addressing is valid for (MEM (SYMBOL_REF ...)).  */\n \n-  tem = gen_rtx (MEM, Pmode, gen_rtx (SYMBOL_REF, Pmode, \"foo\"));\n+  tem = gen_rtx_MEM (Pmode, gen_rtx_SYMBOL_REF (Pmode, \"foo\"));\n   indirect_symref_ok = memory_address_p (QImode, tem);\n \n   /* See if reg+reg is a valid (and offsettable) address.  */\n \n   for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n     {\n-      tem = gen_rtx (PLUS, Pmode,\n-\t\t     gen_rtx (REG, Pmode, HARD_FRAME_POINTER_REGNUM),\n-\t\t     gen_rtx (REG, Pmode, i));\n+      tem = gen_rtx_PLUS (Pmode,\n+\t\t\t  gen_rtx_REG (Pmode, HARD_FRAME_POINTER_REGNUM),\n+\t\t\t  gen_rtx_REG (Pmode, i));\n       /* This way, we make sure that reg+reg is an offsettable address.  */\n       tem = plus_constant (tem, 4);\n \n@@ -752,8 +752,8 @@ reload (first, global, dumpfile)\n   for (ep = reg_eliminate; ep < &reg_eliminate[NUM_ELIMINABLE_REGS]; ep++)\n     {\n       num_eliminable += ep->can_eliminate;\n-      ep->from_rtx = gen_rtx (REG, Pmode, ep->from);\n-      ep->to_rtx = gen_rtx (REG, Pmode, ep->to);\n+      ep->from_rtx = gen_rtx_REG (Pmode, ep->from);\n+      ep->to_rtx = gen_rtx_REG (Pmode, ep->to);\n     }\n \n   num_labels = max_label_num () - get_first_label_num ();\n@@ -2557,9 +2557,9 @@ alter_reg (i, from_reg)\n \t\t below.  */\n \t      adjust = GET_MODE_SIZE (mode) - total_size;\n \t      if (adjust)\n-\t\tstack_slot = gen_rtx (MEM, mode_for_size (total_size\n-\t\t\t\t\t\t\t  * BITS_PER_UNIT,\n-\t\t\t\t\t\t\t  MODE_INT, 1),\n+\t\tstack_slot = gen_rtx_MEM (mode_for_size (total_size\n+\t\t\t\t\t\t\t * BITS_PER_UNIT,\n+\t\t\t\t\t\t\t MODE_INT, 1),\n \t\t\t\t      plus_constant (XEXP (x, 0), adjust));\n \t    }\n \t  spill_stack_slot[from_reg] = stack_slot;\n@@ -2575,7 +2575,7 @@ alter_reg (i, from_reg)\n \t wrong mode, make a new stack slot.  */\n       if (adjust != 0 || GET_MODE (x) != GET_MODE (regno_reg_rtx[i]))\n \t{\n-\t  x = gen_rtx (MEM, GET_MODE (regno_reg_rtx[i]),\n+\t  x = gen_rtx_MEM (GET_MODE (regno_reg_rtx[i]),\n \t\t       plus_constant (XEXP (x, 0), adjust));\n \t  RTX_UNCHANGING_P (x) = RTX_UNCHANGING_P (regno_reg_rtx[i]);\n \t}\n@@ -2917,9 +2917,9 @@ eliminate_regs (x, mem_mode, insn)\n \t\t    && INTVAL (XEXP (x, 1)) == - ep->previous_offset)\n \t\t  return ep->to_rtx;\n \t\telse\n-\t\t  return gen_rtx (PLUS, Pmode, ep->to_rtx,\n-\t\t\t\t  plus_constant (XEXP (x, 1),\n-\t\t\t\t\t\t ep->previous_offset));\n+\t\t  return gen_rtx_PLUS (Pmode, ep->to_rtx,\n+\t\t\t\t       plus_constant (XEXP (x, 1),\n+\t\t\t\t\t\t      ep->previous_offset));\n \t      }\n \n \t  /* If the register is not eliminable, we are done since the other\n@@ -2968,7 +2968,7 @@ eliminate_regs (x, mem_mode, insn)\n \t       turn a PLUS into something else.  We might try to do so here\n \t       for an addition of 0 if we aren't optimizing.  */\n \t    if (! mem_mode && GET_CODE (new) != PLUS)\n-\t      return gen_rtx (PLUS, GET_MODE (x), new, const0_rtx);\n+\t      return gen_rtx_PLUS (GET_MODE (x), new, const0_rtx);\n \t    else\n \t      return new;\n \t  }\n@@ -2995,7 +2995,7 @@ eliminate_regs (x, mem_mode, insn)\n \t\tep->ref_outside_mem = 1;\n \n \t      return\n-\t\tplus_constant (gen_rtx (MULT, Pmode, ep->to_rtx, XEXP (x, 1)),\n+\t\tplus_constant (gen_rtx_MULT (Pmode, ep->to_rtx, XEXP (x, 1)),\n \t\t\t       ep->previous_offset * INTVAL (XEXP (x, 1)));\n \t    }\n \n@@ -3018,7 +3018,7 @@ eliminate_regs (x, mem_mode, insn)\n \t  = XEXP (x, 1) ? eliminate_regs (XEXP (x, 1), mem_mode, insn) : 0;\n \n \tif (new0 != XEXP (x, 0) || new1 != XEXP (x, 1))\n-\t  return gen_rtx (code, GET_MODE (x), new0, new1);\n+\t  return gen_rtx_fmt_ee (code, GET_MODE (x), new0, new1);\n       }\n       return x;\n \n@@ -3028,7 +3028,7 @@ eliminate_regs (x, mem_mode, insn)\n \t{\n \t  new = eliminate_regs (XEXP (x, 0), mem_mode, insn);\n \t  if (new != XEXP (x, 0))\n-\t    x = gen_rtx (EXPR_LIST, REG_NOTE_KIND (x), new, XEXP (x, 1));\n+\t    x = gen_rtx_EXPR_LIST (REG_NOTE_KIND (x), new, XEXP (x, 1));\n \t}\n \n       /* ... fall through ...  */\n@@ -3041,7 +3041,7 @@ eliminate_regs (x, mem_mode, insn)\n \t{\n \t  new = eliminate_regs (XEXP (x, 1), mem_mode, insn);\n \t  if (new != XEXP (x, 1))\n-\t    return gen_rtx (GET_CODE (x), GET_MODE (x), XEXP (x, 0), new);\n+\t    return gen_rtx_fmt_ee (GET_CODE (x), GET_MODE (x), XEXP (x, 0), new);\n \t}\n       return x;\n \n@@ -3077,7 +3077,7 @@ eliminate_regs (x, mem_mode, insn)\n     case FFS:\n       new = eliminate_regs (XEXP (x, 0), mem_mode, insn);\n       if (new != XEXP (x, 0))\n-\treturn gen_rtx (code, GET_MODE (x), new);\n+\treturn gen_rtx_fmt_e (code, GET_MODE (x), new);\n       return x;\n \n     case SUBREG:\n@@ -3109,7 +3109,7 @@ eliminate_regs (x, mem_mode, insn)\n \t\t insn so that delete_output_reload will do the right thing.  */\n \t      if (insn != 0 && GET_CODE (insn) != EXPR_LIST\n \t\t  && GET_CODE (insn) != INSN_LIST)\n-\t\temit_insn_before (gen_rtx (USE, VOIDmode, SUBREG_REG (x)),\n+\t\temit_insn_before (gen_rtx_USE (VOIDmode, SUBREG_REG (x)),\n \t\t\t\t  insn);\n \t    }\n \t}\n@@ -3160,7 +3160,7 @@ eliminate_regs (x, mem_mode, insn)\n \t      return new;\n \t    }\n \t  else\n-\t    return gen_rtx (SUBREG, GET_MODE (x), new, SUBREG_WORD (x));\n+\t    return gen_rtx_SUBREG (GET_MODE (x), new, SUBREG_WORD (x));\n \t}\n \n       return x;\n@@ -3175,7 +3175,7 @@ eliminate_regs (x, mem_mode, insn)\n \n       new = eliminate_regs (XEXP (x, 0), mem_mode, insn);\n       if (new != XEXP (x, 0))\n-\treturn gen_rtx (code, GET_MODE (x), new);\n+\treturn gen_rtx_fmt_e (code, GET_MODE (x), new);\n       return x;\n \n     case CLOBBER:\n@@ -3188,7 +3188,7 @@ eliminate_regs (x, mem_mode, insn)\n \n       new = eliminate_regs (XEXP (x, 0), mem_mode, insn);\n       if (new != XEXP (x, 0))\n-\treturn gen_rtx (code, GET_MODE (x), new);\n+\treturn gen_rtx_fmt_e (code, GET_MODE (x), new);\n       return x;\n \n     case ASM_OPERANDS:\n@@ -3221,12 +3221,13 @@ eliminate_regs (x, mem_mode, insn)\n \tif (new_asm_operands_vec == old_asm_operands_vec)\n \t  return x;\n \n-\tnew = gen_rtx (ASM_OPERANDS, VOIDmode, ASM_OPERANDS_TEMPLATE (x),\n-\t\t       ASM_OPERANDS_OUTPUT_CONSTRAINT (x),\n-\t\t       ASM_OPERANDS_OUTPUT_IDX (x), new_asm_operands_vec,\n-\t\t       ASM_OPERANDS_INPUT_CONSTRAINT_VEC (x),\n-\t\t       ASM_OPERANDS_SOURCE_FILE (x),\n-\t\t       ASM_OPERANDS_SOURCE_LINE (x));\n+\tnew = gen_rtx_ASM_OPERANDS (VOIDmode, ASM_OPERANDS_TEMPLATE (x),\n+\t\t\t\t    ASM_OPERANDS_OUTPUT_CONSTRAINT (x),\n+\t\t\t\t    ASM_OPERANDS_OUTPUT_IDX (x),\n+\t\t\t\t    new_asm_operands_vec,\n+\t\t\t\t    ASM_OPERANDS_INPUT_CONSTRAINT_VEC (x),\n+\t\t\t\t    ASM_OPERANDS_SOURCE_FILE (x),\n+\t\t\t\t    ASM_OPERANDS_SOURCE_LINE (x));\n \tnew->volatil = x->volatil;\n \treturn new;\n       }\n@@ -3283,10 +3284,10 @@ eliminate_regs (x, mem_mode, insn)\n \tif (GET_CODE (SET_DEST (x)) == REG && GET_CODE (new0) == MEM\n \t    && insn != 0 && GET_CODE (insn) != EXPR_LIST\n \t    && GET_CODE (insn) != INSN_LIST)\n-\t  emit_insn_after (gen_rtx (CLOBBER, VOIDmode, SET_DEST (x)), insn);\n+\t  emit_insn_after (gen_rtx_CLOBBER (VOIDmode, SET_DEST (x)), insn);\n \n \tif (new0 != SET_DEST (x) || new1 != SET_SRC (x))\n-\t  return gen_rtx (SET, VOIDmode, new0, new1);\n+\t  return gen_rtx_SET (VOIDmode, new0, new1);\n       }\n \n       return x;\n@@ -3304,7 +3305,7 @@ eliminate_regs (x, mem_mode, insn)\n       new = eliminate_regs (XEXP (x, 0), GET_MODE (x), insn);\n       if (new != XEXP (x, 0))\n \t{\n-\t  new = gen_rtx (MEM, GET_MODE (x), new);\n+\t  new = gen_rtx_MEM (GET_MODE (x), new);\n \t  new->volatil = x->volatil;\n \t  new->unchanging = x->unchanging;\n \t  new->in_struct = x->in_struct;\n@@ -3498,8 +3499,9 @@ eliminate_regs_in_insn (insn, replace)\n \t\t  /* We assume here that we don't need a PARALLEL of\n \t\t     any CLOBBERs for this assignment.  There's not\n \t\t     much we can do if we do need it.  */\n-\t\t  PATTERN (insn) = gen_rtx (SET, VOIDmode,\n-\t\t\t\t\t    SET_DEST (old_set), ep->to_rtx);\n+\t\t  PATTERN (insn) = gen_rtx_SET (VOIDmode,\n+\t\t\t\t\t\tSET_DEST (old_set),\n+\t\t\t\t\t\tep->to_rtx);\n \t\t  INSN_CODE (insn) = -1;\n \t\t  val = 1;\n \t\t  goto done;\n@@ -5160,7 +5162,7 @@ allocate_reload_reg (r, insn, last_reload, noerror)\n \n   if (new == 0 || GET_MODE (new) != reload_mode[r])\n     spill_reg_rtx[i] = new\n-      = gen_rtx (REG, reload_mode[r], spill_regs[i]);\n+      = gen_rtx_REG (reload_mode[r], spill_regs[i]);\n \t    \n   regno = true_regnum (new);\n \n@@ -5617,7 +5619,7 @@ choose_reload_regs (insn, avoid_return_reg)\n \t\t\t address and not all machines support SUBREGs\n \t\t\t there.  */\n \t\t      regno = REGNO (SUBREG_REG (equiv)) + SUBREG_WORD (equiv);\n-\t\t      equiv = gen_rtx (REG, reload_mode[r], regno);\n+\t\t      equiv = gen_rtx_REG (reload_mode[r], regno);\n \t\t    }\n \t\t  else\n \t\t    abort ();\n@@ -6176,12 +6178,12 @@ emit_reload_insns (insn)\n \t     must always be a REG here.  */\n \n \t  if (GET_MODE (reloadreg) != mode)\n-\t    reloadreg = gen_rtx (REG, mode, REGNO (reloadreg));\n+\t    reloadreg = gen_rtx_REG (mode, REGNO (reloadreg));\n \t  while (GET_CODE (oldequiv) == SUBREG && GET_MODE (oldequiv) != mode)\n \t    oldequiv = SUBREG_REG (oldequiv);\n \t  if (GET_MODE (oldequiv) != VOIDmode\n \t      && mode != GET_MODE (oldequiv))\n-\t    oldequiv = gen_rtx (SUBREG, mode, oldequiv, 0);\n+\t    oldequiv = gen_rtx_SUBREG (mode, oldequiv, 0);\n \n \t  /* Switch to the right place to emit the reload insns.  */\n \t  switch (reload_when_needed[j])\n@@ -6364,8 +6366,8 @@ emit_reload_insns (insn)\n \t\t\t\t    oldequiv = old, real_oldequiv = real_old;\n \t\t\t\t  else\n \t\t\t\t    second_reload_reg\n-\t\t\t\t      = gen_rtx (REG, new_mode,\n-\t\t\t\t\t\t REGNO (second_reload_reg));\n+\t\t\t\t      = gen_rtx_REG (new_mode,\n+\t\t\t\t\t\t     REGNO (second_reload_reg));\n \t\t\t\t}\n \t\t\t    }\n \t\t\t}\n@@ -6432,9 +6434,9 @@ emit_reload_insns (insn)\n \t\t\t&& reg_overlap_mentioned_for_reload_p (second_reload_reg,\n \t\t\t\t\t\t\t       PATTERN (prev)))\n \t\t      {\n-\t\t\tREG_NOTES (prev) = gen_rtx (EXPR_LIST, REG_DEAD,\n-\t\t\t\t\t\t    second_reload_reg,\n-\t\t\t\t\t\t    REG_NOTES (prev));\n+\t\t\tREG_NOTES (prev) = gen_rtx_EXPR_LIST (REG_DEAD,\n+\t\t\t\t\t\t\t      second_reload_reg,\n+\t\t\t\t\t\t\t      REG_NOTES (prev));\n \t\t\tbreak;\n \t\t      }\n \t\t}\n@@ -6475,8 +6477,8 @@ emit_reload_insns (insn)\n \t       || reload_when_needed[j] == RELOAD_FOR_INPUT)\n \t      && ! dead_or_set_p (insn, reloadreg))\n \t    REG_NOTES (insn)\n-\t      = gen_rtx (EXPR_LIST, REG_DEAD,\n-\t\t\t reloadreg, REG_NOTES (insn));\n+\t      = gen_rtx_EXPR_LIST (REG_DEAD,\n+\t\t\t\t   reloadreg, REG_NOTES (insn));\n \t}\n \n       /* When we inherit a reload, the last marked death of the reload reg\n@@ -6548,9 +6550,9 @@ emit_reload_insns (insn)\n \t\t\t&& reg_overlap_mentioned_for_reload_p (oldequiv_reg,\n \t\t\t\t\t\t\t       PATTERN (prev1)))\n \t\t      {\n-\t\t\tREG_NOTES (prev1) = gen_rtx (EXPR_LIST, REG_DEAD,\n-\t\t\t\t\t\t     oldequiv_reg,\n-\t\t\t\t\t\t     REG_NOTES (prev1));\n+\t\t\tREG_NOTES (prev1) = gen_rtx_EXPR_LIST (REG_DEAD,\n+\t\t\t\t\t\t\t       oldequiv_reg,\n+\t\t\t\t\t\t\t       REG_NOTES (prev1));\n \t\t\tbreak;\n \t\t      }\n \t\t    remove_death (REGNO (oldequiv_reg), prev);\n@@ -6657,11 +6659,11 @@ emit_reload_insns (insn)\n \t      error_for_asm (insn, \"output operand is constant in `asm'\");\n \t      /* Prevent crash--use something we know is valid.  */\n \t      mode = word_mode;\n-\t      old = gen_rtx (REG, mode, REGNO (reloadreg));\n+\t      old = gen_rtx_REG (mode, REGNO (reloadreg));\n \t    }\n \n \t  if (GET_MODE (reloadreg) != mode)\n-\t    reloadreg = gen_rtx (REG, mode, REGNO (reloadreg));\n+\t    reloadreg = gen_rtx_REG (mode, REGNO (reloadreg));\n \n #ifdef SECONDARY_OUTPUT_RELOAD_CLASS\n \n@@ -6702,7 +6704,7 @@ emit_reload_insns (insn)\n \t\t\t= reload_secondary_out_icode[secondary_reload];\n \n \t\t      if (GET_MODE (reloadreg) != mode)\n-\t\t\treloadreg = gen_rtx (REG, mode, REGNO (reloadreg));\n+\t\t\treloadreg = gen_rtx_REG (mode, REGNO (reloadreg));\n \n \t\t      if (tertiary_icode != CODE_FOR_nothing)\n \t\t\t{\n@@ -6757,8 +6759,8 @@ emit_reload_insns (insn)\n \t      if (GET_RTX_CLASS (GET_CODE (p)) == 'i'\n \t\t  && reg_overlap_mentioned_for_reload_p (reloadreg,\n \t\t\t\t\t\t\t PATTERN (p)))\n-\t\tREG_NOTES (p) = gen_rtx (EXPR_LIST, REG_DEAD,\n-\t\t\t\t\t reloadreg, REG_NOTES (p));\n+\t\tREG_NOTES (p) = gen_rtx_EXPR_LIST (REG_DEAD,\n+\t\t\t\t\t\t   reloadreg, REG_NOTES (p));\n \n #ifdef SECONDARY_OUTPUT_RELOAD_CLASS\n \t  if (! special && second_reloadreg\n@@ -6767,8 +6769,9 @@ emit_reload_insns (insn)\n \t      if (GET_RTX_CLASS (GET_CODE (p)) == 'i'\n \t\t  && reg_overlap_mentioned_for_reload_p (second_reloadreg,\n \t\t\t\t\t\t\t PATTERN (p)))\n-\t\tREG_NOTES (p) = gen_rtx (EXPR_LIST, REG_DEAD,\n-\t\t\t\t\t second_reloadreg, REG_NOTES (p));\n+\t\tREG_NOTES (p) = gen_rtx_EXPR_LIST (REG_DEAD,\n+\t\t\t\t\t\t   second_reloadreg,\n+\t\t\t\t\t\t   REG_NOTES (p));\n #endif\n #endif\n \t  /* Look at all insns we emitted, just to be safe.  */\n@@ -6956,9 +6959,8 @@ emit_reload_insns (insn)\n \t\t    for (k = 1; k < nnr; k++)\n \t\t      reg_last_reload_reg[nregno + k]\n \t\t\t= (nr == nnr\n-\t\t\t   ? gen_rtx (REG,\n-\t\t\t\t      reg_raw_mode[REGNO (reload_reg_rtx[r]) + k],\n-\t\t\t\t      REGNO (reload_reg_rtx[r]) + k)\n+\t\t\t   ? gen_rtx_REG (reg_raw_mode[REGNO (reload_reg_rtx[r]) + k],\n+\t\t\t\t\t  REGNO (reload_reg_rtx[r]) + k)\n \t\t\t   : 0);\n \n \t\t  /* Now do the inverse operation.  */\n@@ -7000,9 +7002,8 @@ emit_reload_insns (insn)\n \t\t    for (k = 1; k < nnr; k++)\n \t\t      reg_last_reload_reg[nregno + k]\n \t\t\t= (nr == nnr\n-\t\t\t   ? gen_rtx (REG,\n-\t\t\t\t      reg_raw_mode[REGNO (reload_reg_rtx[r]) + k],\n-\t\t\t\t      REGNO (reload_reg_rtx[r]) + k)\n+\t\t\t   ? gen_rtx_REG (reg_raw_mode[REGNO (reload_reg_rtx[r]) + k],\n+\t\t\t\t\t  REGNO (reload_reg_rtx[r]) + k)\n \t\t\t   : 0);\n \n \t\t  /* Unless we inherited this reload, show we haven't\n@@ -7156,9 +7157,9 @@ gen_reload (out, in, opnum, type)\n \ttem = op0, op0 = op1, op1 = tem;\n \n       if (op0 != XEXP (in, 0) || op1 != XEXP (in, 1))\n-\tin = gen_rtx (PLUS, GET_MODE (in), op0, op1);\n+\tin = gen_rtx_PLUS (GET_MODE (in), op0, op1);\n \n-      insn = emit_insn (gen_rtx (SET, VOIDmode, out, in));\n+      insn = emit_insn (gen_rtx_SET (VOIDmode, out, in));\n       code = recog_memoized (insn);\n \n       if (code >= 0)\n@@ -7231,10 +7232,10 @@ gen_reload (out, in, opnum, type)\n       rtx loc = get_secondary_mem (in, GET_MODE (out), opnum, type);\n \n       if (GET_MODE (loc) != GET_MODE (out))\n-\tout = gen_rtx (REG, GET_MODE (loc), REGNO (out));\n+\tout = gen_rtx_REG (GET_MODE (loc), REGNO (out));\n \n       if (GET_MODE (loc) != GET_MODE (in))\n-\tin = gen_rtx (REG, GET_MODE (loc), REGNO (in));\n+\tin = gen_rtx_REG (GET_MODE (loc), REGNO (in));\n \n       gen_reload (loc, in, opnum, type);\n       gen_reload (out, loc, opnum, type);\n@@ -7252,7 +7253,7 @@ gen_reload (out, in, opnum, type)\n \n   /* Otherwise, just write (set OUT IN) and hope for the best.  */\n   else\n-    emit_insn (gen_rtx (SET, VOIDmode, out, in));\n+    emit_insn (gen_rtx_SET (VOIDmode, out, in));\n \n   /* Return the first insn emitted.\n      We can not just return get_last_insn, because there may have\n@@ -7408,9 +7409,9 @@ inc_for_reload (reloadreg, value, inc_amount)\n      in gen_reload.  */\n \n   last = get_last_insn ();\n-  add_insn = emit_insn (gen_rtx (SET, VOIDmode, incloc,\n-\t\t\t\t gen_rtx (PLUS, GET_MODE (incloc),\n-\t\t\t\t\t  incloc, inc)));\n+  add_insn = emit_insn (gen_rtx_SET (VOIDmode, incloc,\n+\t\t\t\t     gen_rtx_PLUS (GET_MODE (incloc),\n+\t\t\t\t\t\t   incloc, inc)));\n \t\t\t\t\t\t\t  \n   code = recog_memoized (add_insn);\n   if (code >= 0)\n@@ -7888,11 +7889,11 @@ reload_cse_regs (first)\n \n   /* We pass this to reload_cse_invalidate_mem to invalidate all of\n      memory for a non-const call instruction.  */\n-  callmem = gen_rtx (MEM, BLKmode, const0_rtx);\n+  callmem = gen_rtx_MEM (BLKmode, const0_rtx);\n \n   /* This is used in reload_cse_invalidate_regno to avoid consing a\n      new REG in a loop in that function.  */\n-  invalidate_regno_rtx = gen_rtx (REG, VOIDmode, 0);\n+  invalidate_regno_rtx = gen_rtx_REG (VOIDmode, 0);\n \n   for (insn = first; insn; insn = NEXT_INSN (insn))\n     {\n@@ -8213,7 +8214,7 @@ reload_cse_simplify_set (set, insn)\n \t  pop_obstacks ();\n \n \t  validated = validate_change (insn, &SET_SRC (set),\n-\t\t\t\t       gen_rtx (REG, dest_mode, i), 1);\n+\t\t\t\t       gen_rtx_REG (dest_mode, i), 1);\n \n \t  /* Go back to the obstack we are using for temporary\n              storage.  */\n@@ -8368,7 +8369,7 @@ reload_cse_simplify_operands (insn)\n \t\t     replacement register if we don't have one for this\n \t\t     alternative yet.  */\n \t\t  if (op_alt_regno[i][j] == -1\n-\t\t      && reg_fits_class_p (gen_rtx (REG, mode, regno), class,\n+\t\t      && reg_fits_class_p (gen_rtx_REG (mode, regno), class,\n \t\t\t\t\t   0, mode))\n \t\t    {\n \t\t      alternative_nregs[j]++;\n@@ -8435,7 +8436,7 @@ reload_cse_simplify_operands (insn)\n \n       reload_cse_no_longer_dead (op_alt_regno[i][j], mode);\n       validate_change (insn, recog_operand_loc[i],\n-\t\t       gen_rtx (REG, mode, op_alt_regno[i][j]), 1);\n+\t\t       gen_rtx_REG (mode, op_alt_regno[i][j]), 1);\n     }\n \n   for (i = insn_n_dups[insn_code_number] - 1; i >= 0; i--)\n@@ -8448,7 +8449,7 @@ reload_cse_simplify_operands (insn)\n \n       reload_cse_no_longer_dead (op_alt_regno[op][j], mode);\n       validate_change (insn, recog_dup_loc[i],\n-\t\t       gen_rtx (REG, mode, op_alt_regno[op][j]), 1);\n+\t\t       gen_rtx_REG (mode, op_alt_regno[op][j]), 1);\n     }\n \n   /* Go back to the obstack we are using for temporary\n@@ -8592,12 +8593,12 @@ reload_cse_record_set (set, body)\n \t      else\n \t\ttmp = gen_lowpart_common (dest_mode, XEXP (x, 0));\n \t      if (tmp)\n-\t\treg_values[dreg] = gen_rtx (EXPR_LIST, dest_mode, tmp,\n-\t\t\t\t\t    reg_values[dreg]);\n+\t\treg_values[dreg] = gen_rtx_EXPR_LIST (dest_mode, tmp,\n+\t\t\t\t\t\t      reg_values[dreg]);\n \t    }\t      \n \t}\n       else\n-\treg_values[dreg] = gen_rtx (EXPR_LIST, dest_mode, src, NULL_RTX);\n+\treg_values[dreg] = gen_rtx_EXPR_LIST (dest_mode, src, NULL_RTX);\n \n       /* We've changed DREG, so invalidate any values held by other\n          registers that depend upon it.  */\n@@ -8616,7 +8617,7 @@ reload_cse_record_set (set, body)\n       /* If we're storing a register to memory, add DEST to the list\n          in REG_VALUES.  */\n       if (sreg >= 0 && ! side_effects_p (dest))\n-\treg_values[sreg] = gen_rtx (EXPR_LIST, dest_mode, dest,\n+\treg_values[sreg] = gen_rtx_EXPR_LIST (dest_mode, dest,\n \t\t\t\t    reg_values[sreg]);\n     }\n   else"}, {"sha": "631ef4beaf2fcddcd73db04814b68d074e5f953d", "filename": "gcc/reorg.c", "status": "modified", "additions": 21, "deletions": 20, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38a448ca5dfe60244ab3c1f0ea8e3604ec69370b/gcc%2Freorg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38a448ca5dfe60244ab3c1f0ea8e3604ec69370b/gcc%2Freorg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freorg.c?ref=38a448ca5dfe60244ab3c1f0ea8e3604ec69370b", "patch": "@@ -872,7 +872,7 @@ emit_delay_sequence (insn, list, length, avail)\n \n   /* Allocate the the rtvec to hold the insns and the SEQUENCE.  */\n   rtvec seqv = rtvec_alloc (length + 1);\n-  rtx seq = gen_rtx (SEQUENCE, VOIDmode, seqv);\n+  rtx seq = gen_rtx_SEQUENCE (VOIDmode, seqv);\n   rtx seq_insn = make_insn_raw (seq);\n   rtx first = get_insns ();\n   rtx last = get_last_insn ();\n@@ -985,7 +985,7 @@ add_to_delay_list (insn, delay_list)\n       if (tinfo)\n \ttinfo->block = -1;\n \n-      return gen_rtx (INSN_LIST, VOIDmode, insn, NULL_RTX);\n+      return gen_rtx_INSN_LIST (VOIDmode, insn, NULL_RTX);\n     }\n \n   /* Otherwise this must be an INSN_LIST.  Add INSN to the end of the\n@@ -1502,9 +1502,9 @@ get_branch_condition (insn, target)\n \t       || (GET_CODE (XEXP (src, 2)) == LABEL_REF\n \t\t   && XEXP (XEXP (src, 2), 0) == target))\n \t   && XEXP (src, 1) == pc_rtx)\n-    return gen_rtx (reverse_condition (GET_CODE (XEXP (src, 0))),\n-\t\t    GET_MODE (XEXP (src, 0)),\n-\t\t    XEXP (XEXP (src, 0), 0), XEXP (XEXP (src, 0), 1));\n+    return gen_rtx_fmt_ee (reverse_condition (GET_CODE (XEXP (src, 0))),\n+\t\t\t   GET_MODE (XEXP (src, 0)),\n+\t\t\t   XEXP (XEXP (src, 0), 0), XEXP (XEXP (src, 0), 1));\n \n   return 0;\n }\n@@ -1879,7 +1879,7 @@ try_merge_delay_insns (insn, thread)\n \t      INSN_FROM_TARGET_P (next_to_match) = 0;\n \t    }\n \t  else\n-\t    merged_insns = gen_rtx (INSN_LIST, VOIDmode, trial, merged_insns);\n+\t    merged_insns = gen_rtx_INSN_LIST (VOIDmode, trial, merged_insns);\n \n \t  if (++slot_number == num_slots)\n \t    break;\n@@ -1927,8 +1927,8 @@ try_merge_delay_insns (insn, thread)\n \t\t  INSN_FROM_TARGET_P (next_to_match) = 0;\n \t\t}\n \t      else\n-\t\tmerged_insns = gen_rtx (INSN_LIST, SImode, dtrial,\n-\t\t\t\t\tmerged_insns);\n+\t\tmerged_insns = gen_rtx_INSN_LIST (SImode, dtrial,\n+\t\t\t\t\t\t  merged_insns);\n \n \t      if (++slot_number == num_slots)\n \t\tbreak;\n@@ -2285,7 +2285,7 @@ update_block (insn, where)\n   if (INSN_FROM_TARGET_P (insn))\n     return;\n \n-  emit_insn_before (gen_rtx (USE, VOIDmode, insn), where);\n+  emit_insn_before (gen_rtx_USE (VOIDmode, insn), where);\n \n   /* INSN might be making a value live in a block where it didn't use to\n      be.  So recompute liveness information for this block.  */\n@@ -3113,8 +3113,8 @@ fill_simple_delay_slots (first, non_jumps_p)\n \t\t\t tail, of the list.  */\n \n \t\t      update_reg_dead_notes (trial, insn);\n-\t\t      delay_list = gen_rtx (INSN_LIST, VOIDmode,\n-\t\t\t\t\t    trial, delay_list);\n+\t\t      delay_list = gen_rtx_INSN_LIST (VOIDmode,\n+\t\t\t\t\t\t      trial, delay_list);\n \t\t      update_block (trial, trial);\n \t\t      delete_insn (trial);\n \t\t      if (slots_to_fill == ++slots_filled)\n@@ -3402,8 +3402,8 @@ fill_simple_delay_slots (first, non_jumps_p)\n \t\t insns we find on the head of the list.  */\n \n \t      current_function_epilogue_delay_list\n-\t\t= gen_rtx (INSN_LIST, VOIDmode, trial,\n-\t\t\t   current_function_epilogue_delay_list);\n+\t\t= gen_rtx_INSN_LIST (VOIDmode, trial,\n+\t\t\t\t     current_function_epilogue_delay_list);\n \t      mark_referenced_resources (trial, &end_of_function_needs, 1);\n \t      update_block (trial, trial);\n \t      delete_insn (trial);\n@@ -3756,13 +3756,13 @@ fill_slots_from_thread (insn, condition, thread, opposite_thread, likely,\n \t     the negated constant.  Otherwise, reverse the sense of the\n \t     arithmetic.  */\n \t  if (GET_CODE (other) == CONST_INT)\n-\t    new_arith = gen_rtx (GET_CODE (src), GET_MODE (src), dest,\n-\t\t\t\t negate_rtx (GET_MODE (src), other));\n+\t    new_arith = gen_rtx_fmt_ee (GET_CODE (src), GET_MODE (src), dest,\n+\t\t\t\t\tnegate_rtx (GET_MODE (src), other));\n \t  else\n-\t    new_arith = gen_rtx (GET_CODE (src) == PLUS ? MINUS : PLUS,\n-\t\t\t\t GET_MODE (src), dest, other);\n+\t    new_arith = gen_rtx_fmt_ee (GET_CODE (src) == PLUS ? MINUS : PLUS,\n+\t\t\t\t\tGET_MODE (src), dest, other);\n \n-\t  ninsn = emit_insn_after (gen_rtx (SET, VOIDmode, dest, new_arith),\n+\t  ninsn = emit_insn_after (gen_rtx_SET (VOIDmode, dest, new_arith),\n \t\t\t\t   insn);\n \n \t  if (recog_memoized (ninsn) < 0\n@@ -4631,8 +4631,9 @@ dbr_schedule (first, file)\n \tcontinue;\n \n       pred_flags = get_jump_flags (insn, JUMP_LABEL (insn));\n-      REG_NOTES (insn) = gen_rtx (EXPR_LIST, REG_BR_PRED,\n-\t\t\t\t  GEN_INT (pred_flags), REG_NOTES (insn));\n+      REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_BR_PRED,\n+\t\t\t\t\t    GEN_INT (pred_flags),\n+\t\t\t\t\t    REG_NOTES (insn));\n     }\n }\n #endif /* DELAY_SLOTS */"}, {"sha": "d52a55bef4bae3310c8684dbe029badc1ec16eba", "filename": "gcc/sched.c", "status": "modified", "additions": 23, "deletions": 21, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38a448ca5dfe60244ab3c1f0ea8e3604ec69370b/gcc%2Fsched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38a448ca5dfe60244ab3c1f0ea8e3604ec69370b/gcc%2Fsched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched.c?ref=38a448ca5dfe60244ab3c1f0ea8e3604ec69370b", "patch": "@@ -1333,8 +1333,8 @@ sched_analyze_2 (x, insn)\n \t    while (--i >= 0)\n \t      {\n \t\treg_last_uses[regno + i]\n-\t\t  = gen_rtx (INSN_LIST, VOIDmode,\n-\t\t\t     insn, reg_last_uses[regno + i]);\n+\t\t  = gen_rtx_INSN_LIST (VOIDmode,\n+\t\t\t\t       insn, reg_last_uses[regno + i]);\n \t\tif (reg_last_sets[regno + i])\n \t\t  add_dependence (insn, reg_last_sets[regno + i], 0);\n \t\tif ((call_used_regs[regno + i] || global_regs[regno + i])\n@@ -1346,7 +1346,7 @@ sched_analyze_2 (x, insn)\n \telse\n \t  {\n \t    reg_last_uses[regno]\n-\t      = gen_rtx (INSN_LIST, VOIDmode, insn, reg_last_uses[regno]);\n+\t      = gen_rtx_INSN_LIST (VOIDmode, insn, reg_last_uses[regno]);\n \t    if (reg_last_sets[regno])\n \t      add_dependence (insn, reg_last_sets[regno], 0);\n \n@@ -1685,12 +1685,12 @@ sched_analyze (head, tail)\n \t\t convert back into a NOTE_INSN_SETJMP note.  See\n \t\t reemit_notes for why we use a pair of of NOTEs.  */\n \n-\t      REG_NOTES (insn) = gen_rtx (EXPR_LIST, REG_DEAD,\n-\t\t\t\t\t  GEN_INT (0),\n-\t\t\t\t\t  REG_NOTES (insn));\n-\t      REG_NOTES (insn) = gen_rtx (EXPR_LIST, REG_DEAD,\n-\t\t\t\t\t  GEN_INT (NOTE_INSN_SETJMP),\n-\t\t\t\t\t  REG_NOTES (insn));\n+\t      REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_DEAD,\n+\t\t\t\t\t\t    GEN_INT (0),\n+\t\t\t\t\t\t    REG_NOTES (insn));\n+\t      REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_DEAD,\n+\t\t\t\t\t\t    GEN_INT (NOTE_INSN_SETJMP),\n+\t\t\t\t\t\t    REG_NOTES (insn));\n \t    }\n \t  else\n \t    {\n@@ -1740,10 +1740,12 @@ sched_analyze (head, tail)\n \t\t   || (NOTE_LINE_NUMBER (insn) == NOTE_INSN_SETJMP\n \t\t       && GET_CODE (PREV_INSN (insn)) != CALL_INSN)))\n \t{\n-\t  loop_notes = gen_rtx (EXPR_LIST, REG_DEAD,\n-\t\t\t\tGEN_INT (NOTE_BLOCK_NUMBER (insn)), loop_notes);\n-\t  loop_notes = gen_rtx (EXPR_LIST, REG_DEAD,\n-\t\t\t\tGEN_INT (NOTE_LINE_NUMBER (insn)), loop_notes);\n+\t  loop_notes = gen_rtx_EXPR_LIST (REG_DEAD,\n+\t\t\t\t\t  GEN_INT (NOTE_BLOCK_NUMBER (insn)),\n+\t\t\t\t\t  loop_notes);\n+\t  loop_notes = gen_rtx_EXPR_LIST (REG_DEAD,\n+\t\t\t\t\t  GEN_INT (NOTE_LINE_NUMBER (insn)),\n+\t\t\t\t\t  loop_notes);\n \t  CONST_CALL_P (loop_notes) = CONST_CALL_P (insn);\n \t}\n \n@@ -2236,7 +2238,7 @@ create_reg_dead_note (reg, insn)\n \t{\n \t  rtx temp_reg, temp_link;\n \n-\t  temp_reg = gen_rtx (REG, word_mode, 0);\n+\t  temp_reg = gen_rtx_REG (word_mode, 0);\n \t  temp_link = rtx_alloc (EXPR_LIST);\n \t  PUT_REG_NOTE_KIND (temp_link, REG_DEAD);\n \t  XEXP (temp_link, 0) = temp_reg;\n@@ -2372,9 +2374,8 @@ attach_deaths (x, insn, set_p)\n \t\t\t     i >= 0; i--)\n \t\t\t  if (! REGNO_REG_SET_P (old_live_regs, regno + i)\n \t\t\t      && ! dead_or_set_regno_p (insn, regno + i))\n-\t\t\t    create_reg_dead_note (gen_rtx (REG,\n-\t\t\t\t\t\t\t   reg_raw_mode[regno + i],\n-\t\t\t\t\t\t\t   regno + i),\n+\t\t\t    create_reg_dead_note (gen_rtx_REG (reg_raw_mode[regno + i],\n+\t\t\t\t\t\t\t       regno + i),\n \t\t\t\t\t\t  insn);\n \t\t      }\n \t\t  }\n@@ -3995,8 +3996,9 @@ update_flow_info (notes, first, last, orig_insn)\n \t  for (insn = first; insn != NEXT_INSN (last); insn = NEXT_INSN (insn))\n \t    if (GET_RTX_CLASS (GET_CODE (insn)) == 'i'\n \t\t&& reg_mentioned_p (XEXP (note, 0), PATTERN (insn)))\n-\t      REG_NOTES (insn) = gen_rtx (EXPR_LIST, REG_LABEL,\n-\t\t\t\t\t  XEXP (note, 0), REG_NOTES (insn));\n+\t      REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_LABEL,\n+\t\t\t\t\t\t    XEXP (note, 0),\n+\t\t\t\t\t\t    REG_NOTES (insn));\n \t  break;\n \n \tcase REG_CC_SETTER:\n@@ -4246,8 +4248,8 @@ schedule_insns (dump_file)\n \n   /* Create an insn here so that we can hang dependencies off of it later.  */\n   sched_before_next_call\n-    = gen_rtx (INSN, VOIDmode, 0, NULL_RTX, NULL_RTX,\n-\t       NULL_RTX, 0, NULL_RTX, NULL_RTX);\n+    = gen_rtx_INSN (VOIDmode, 0, NULL_RTX, NULL_RTX,\n+\t\t    NULL_RTX, 0, NULL_RTX, NULL_RTX);\n \n   /* Initialize the unused_*_lists.  We can't use the ones left over from\n      the previous function, because gcc has freed that memory.  We can use"}, {"sha": "48929aa559fbd066a2bea08375d8483fc813cf5c", "filename": "gcc/stmt.c", "status": "modified", "additions": 43, "deletions": 43, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38a448ca5dfe60244ab3c1f0ea8e3604ec69370b/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38a448ca5dfe60244ab3c1f0ea8e3604ec69370b/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=38a448ca5dfe60244ab3c1f0ea8e3604ec69370b", "patch": "@@ -736,7 +736,7 @@ expand_goto (label)\n   if (context != 0 && context != current_function_decl)\n     {\n       struct function *p = find_function_data (context);\n-      rtx label_ref = gen_rtx (LABEL_REF, Pmode, label_rtx (label));\n+      rtx label_ref = gen_rtx_LABEL_REF (Pmode, label_rtx (label));\n       rtx temp;\n \n       p->has_nonlocal_label = 1;\n@@ -789,9 +789,9 @@ expand_goto (label)\n \t  emit_move_insn (static_chain_rtx, label_ref);\n \t  /* USE of hard_frame_pointer_rtx added for consistency; not clear if\n \t     really needed.  */\n-\t  emit_insn (gen_rtx (USE, VOIDmode, hard_frame_pointer_rtx));\n-\t  emit_insn (gen_rtx (USE, VOIDmode, stack_pointer_rtx));\n-\t  emit_insn (gen_rtx (USE, VOIDmode, static_chain_rtx));\n+\t  emit_insn (gen_rtx_USE (VOIDmode, hard_frame_pointer_rtx));\n+\t  emit_insn (gen_rtx_USE (VOIDmode, stack_pointer_rtx));\n+\t  emit_insn (gen_rtx_USE (VOIDmode, static_chain_rtx));\n \t  emit_indirect_jump (temp);\n \t}\n      }\n@@ -1383,8 +1383,8 @@ expand_asm (body)\n   if (TREE_CODE (body) == ADDR_EXPR)\n     body = TREE_OPERAND (body, 0);\n \n-  emit_insn (gen_rtx (ASM_INPUT, VOIDmode,\n-\t\t      TREE_STRING_POINTER (body)));\n+  emit_insn (gen_rtx_ASM_INPUT (VOIDmode,\n+\t\t\t\tTREE_STRING_POINTER (body)));\n   last_expr_type = 0;\n }\n \n@@ -1571,9 +1571,9 @@ expand_asm_operands (string, outputs, inputs, clobbers, vol, filename, line)\n   argvec = rtvec_alloc (ninputs);\n   constraints = rtvec_alloc (ninputs);\n \n-  body = gen_rtx (ASM_OPERANDS, VOIDmode,\n-\t\t  TREE_STRING_POINTER (string), \"\", 0, argvec, constraints,\n-\t\t  filename, line);\n+  body = gen_rtx_ASM_OPERANDS (VOIDmode,\n+\t\t\t       TREE_STRING_POINTER (string), \"\", 0, argvec,\n+\t\t\t       constraints, filename, line);\n \n   /* The only use of BODY is if no outputs are specified, so set\n      it volatile, at least for now.  */\n@@ -1676,8 +1676,8 @@ expand_asm_operands (string, outputs, inputs, clobbers, vol, filename, line)\n \t}\n \t  \n       XVECEXP (body, 4, i)      /* constraints */\n-\t= gen_rtx (ASM_INPUT, TYPE_MODE (TREE_TYPE (TREE_VALUE (tail))),\n-\t\t   TREE_STRING_POINTER (TREE_PURPOSE (tail)));\n+\t= gen_rtx_ASM_INPUT (TYPE_MODE (TREE_TYPE (TREE_VALUE (tail))),\n+\t\t\t     TREE_STRING_POINTER (TREE_PURPOSE (tail)));\n       i++;\n     }\n \n@@ -1700,7 +1700,7 @@ expand_asm_operands (string, outputs, inputs, clobbers, vol, filename, line)\n       XVECEXP (body, 3, ninputs - ninout + i)      /* argvec */\n \t= output_rtx[j];\n       XVECEXP (body, 4, ninputs - ninout + i)      /* constraints */\n-\t= gen_rtx (ASM_INPUT, inout_mode[j], match[j]);\n+\t= gen_rtx_ASM_INPUT (inout_mode[j], match[j]);\n     }\n \n   /* Now, for each output, construct an rtx\n@@ -1711,7 +1711,7 @@ expand_asm_operands (string, outputs, inputs, clobbers, vol, filename, line)\n   if (noutputs == 1 && nclobbers == 0)\n     {\n       XSTR (body, 1) = TREE_STRING_POINTER (TREE_PURPOSE (outputs));\n-      insn = emit_insn (gen_rtx (SET, VOIDmode, output_rtx[0], body));\n+      insn = emit_insn (gen_rtx_SET (VOIDmode, output_rtx[0], body));\n     }\n   else if (noutputs == 0 && nclobbers == 0)\n     {\n@@ -1723,20 +1723,20 @@ expand_asm_operands (string, outputs, inputs, clobbers, vol, filename, line)\n       rtx obody = body;\n       int num = noutputs;\n       if (num == 0) num = 1;\n-      body = gen_rtx (PARALLEL, VOIDmode, rtvec_alloc (num + nclobbers));\n+      body = gen_rtx_PARALLEL (VOIDmode, rtvec_alloc (num + nclobbers));\n \n       /* For each output operand, store a SET.  */\n \n       for (i = 0, tail = outputs; tail; tail = TREE_CHAIN (tail), i++)\n \t{\n \t  XVECEXP (body, 0, i)\n-\t    = gen_rtx (SET, VOIDmode,\n-\t\t       output_rtx[i],\n-\t\t       gen_rtx (ASM_OPERANDS, VOIDmode,\n-\t\t\t\tTREE_STRING_POINTER (string),\n-\t\t\t\tTREE_STRING_POINTER (TREE_PURPOSE (tail)),\n-\t\t\t\ti, argvec, constraints,\n-\t\t\t\tfilename, line));\n+\t    = gen_rtx_SET (VOIDmode,\n+\t\t\t   output_rtx[i],\n+\t\t\t   gen_rtx_ASM_OPERANDS (VOIDmode,\n+\t\t\t\t\t\t TREE_STRING_POINTER (string),\n+\t\t\t\t\t\t TREE_STRING_POINTER (TREE_PURPOSE (tail)),\n+\t\t\t\t\t\t i, argvec, constraints,\n+\t\t\t\t\t\t filename, line));\n \t  MEM_VOLATILE_P (SET_SRC (XVECEXP (body, 0, i))) = vol;\n \t}\n \n@@ -1761,9 +1761,9 @@ expand_asm_operands (string, outputs, inputs, clobbers, vol, filename, line)\n \t      if (j == -4)\t/* `memory', don't cache memory across asm */\n \t\t{\n \t\t  XVECEXP (body, 0, i++)\n-\t\t    = gen_rtx (CLOBBER, VOIDmode,\n-\t\t\t       gen_rtx (MEM, BLKmode,\n-\t\t\t\t\tgen_rtx (SCRATCH, VOIDmode, 0)));\n+\t\t    = gen_rtx_CLOBBER (VOIDmode,\n+\t\t\t\t       gen_rtx_MEM (BLKmode,\n+\t\t\t\t\t\t    gen_rtx_SCRATCH (VOIDmode)));\n \t\t  continue;\n \t\t}\n \n@@ -1773,7 +1773,7 @@ expand_asm_operands (string, outputs, inputs, clobbers, vol, filename, line)\n \n \t  /* Use QImode since that's guaranteed to clobber just one reg.  */\n \t  XVECEXP (body, 0, i++)\n-\t    = gen_rtx (CLOBBER, VOIDmode, gen_rtx (REG, QImode, j));\n+\t    = gen_rtx_CLOBBER (VOIDmode, gen_rtx_REG (QImode, j));\n \t}\n \n       insn = emit_insn (body);\n@@ -2635,7 +2635,7 @@ expand_value_return (val)\n     }\n   if (GET_CODE (return_reg) == REG\n       && REGNO (return_reg) < FIRST_PSEUDO_REGISTER)\n-    emit_insn (gen_rtx (USE, VOIDmode, return_reg));\n+    emit_insn (gen_rtx_USE (VOIDmode, return_reg));\n   /* Handle calls that return values in multiple non-contiguous locations.\n      The Irix 6 ABI has examples of this.  */\n   else if (GET_CODE (return_reg) == PARALLEL)\n@@ -2648,7 +2648,7 @@ expand_value_return (val)\n \n \t  if (GET_CODE (x) == REG\n \t      && REGNO (x) < FIRST_PSEUDO_REGISTER)\n-\t    emit_insn (gen_rtx (USE, VOIDmode, x));\n+\t    emit_insn (gen_rtx_USE (VOIDmode, x));\n \t}\n     }\n \n@@ -2938,7 +2938,7 @@ expand_return (retval)\n \t      result_pseudos[xbitpos / BITS_PER_WORD] = dst;\n \n \t      /* Clobber the destination before we move anything into it.  */\n-\t      emit_insn (gen_rtx (CLOBBER, VOIDmode, dst));\n+\t      emit_insn (gen_rtx_CLOBBER (VOIDmode, dst));\n \t    }\n \n \t  /* We need a new source operand each time bitpos is on a word\n@@ -3339,7 +3339,7 @@ expand_end_bindings (vars, mark_ends, dont_jump_in)\n \n       start_sequence ();\n       emit_move_insn (nonlocal_goto_handler_slot,\n-\t\t      gen_rtx (LABEL_REF, Pmode, handler_label));\n+\t\t      gen_rtx_LABEL_REF (Pmode, handler_label));\n       insns = get_insns ();\n       end_sequence ();\n       emit_insns_before (insns, thisblock->data.block.first_insn);\n@@ -3414,15 +3414,15 @@ expand_end_bindings (vars, mark_ends, dont_jump_in)\n \t    rtx not_this = gen_label_rtx ();\n \t    rtx this = gen_label_rtx ();\n \t    do_jump_if_equal (static_chain_rtx,\n-\t\t\t      gen_rtx (LABEL_REF, Pmode, DECL_RTL (TREE_VALUE (link))),\n+\t\t\t      gen_rtx_LABEL_REF (Pmode, DECL_RTL (TREE_VALUE (link))),\n \t\t\t      this, 0);\n \t    emit_jump (not_this);\n \t    emit_label (this);\n \t    expand_goto (TREE_VALUE (link));\n \t    emit_label (not_this);\n \t  }\n       /* If label is not recognized, abort.  */\n-      emit_library_call (gen_rtx (SYMBOL_REF, Pmode, \"abort\"), 0,\n+      emit_library_call (gen_rtx_SYMBOL_REF (Pmode, \"abort\"), 0,\n \t\t\t VOIDmode, 0);\n       emit_barrier ();\n       emit_label (afterward);\n@@ -3589,7 +3589,7 @@ expand_decl (decl)\n   /* Create the RTL representation for the variable.  */\n \n   if (type == error_mark_node)\n-    DECL_RTL (decl) = gen_rtx (MEM, BLKmode, const0_rtx);\n+    DECL_RTL (decl) = gen_rtx_MEM (BLKmode, const0_rtx);\n   else if (DECL_SIZE (decl) == 0)\n     /* Variable with incomplete type.  */\n     {\n@@ -3599,7 +3599,7 @@ expand_decl (decl)\n       else\n \t/* An initializer is going to decide the size of this array.\n \t   Until we know the size, represent its address with a reg.  */\n-\tDECL_RTL (decl) = gen_rtx (MEM, BLKmode, gen_reg_rtx (Pmode));\n+\tDECL_RTL (decl) = gen_rtx_MEM (BLKmode, gen_reg_rtx (Pmode));\n       MEM_IN_STRUCT_P (DECL_RTL (decl)) = AGGREGATE_TYPE_P (type);\n     }\n   else if (DECL_MODE (decl) != BLKmode\n@@ -3708,7 +3708,7 @@ expand_decl (decl)\n \t\t\t\t\t      TYPE_ALIGN (TREE_TYPE (decl)));\n \n       /* Reference the variable indirect through that rtx.  */\n-      DECL_RTL (decl) = gen_rtx (MEM, DECL_MODE (decl), address);\n+      DECL_RTL (decl) = gen_rtx_MEM (DECL_MODE (decl), address);\n \n       /* If this is a memory ref that contains aggregate components,\n \t mark it as such for cse and loop optimize.  */\n@@ -4170,7 +4170,7 @@ expand_anon_union_decl (decl, cleanup, decl_elts)\n \t    DECL_RTL (decl_elt) = x;\n \t  else\n \t    {\n-\t      DECL_RTL (decl_elt) = gen_rtx (MEM, mode, copy_rtx (XEXP (x, 0)));\n+\t      DECL_RTL (decl_elt) = gen_rtx_MEM (mode, copy_rtx (XEXP (x, 0)));\n \t      MEM_IN_STRUCT_P (DECL_RTL (decl_elt)) = MEM_IN_STRUCT_P (x);\n \t      RTX_UNCHANGING_P (DECL_RTL (decl_elt)) = RTX_UNCHANGING_P (x);\n \t    }\n@@ -4180,7 +4180,7 @@ expand_anon_union_decl (decl, cleanup, decl_elts)\n \t  if (mode == GET_MODE (x))\n \t    DECL_RTL (decl_elt) = x;\n \t  else\n-\t    DECL_RTL (decl_elt) = gen_rtx (SUBREG, mode, x, 0);\n+\t    DECL_RTL (decl_elt) = gen_rtx_SUBREG (mode, x, 0);\n \t}\n       else\n \tabort ();\n@@ -5692,7 +5692,7 @@ expand_end_case (orig_index)\n \t      while (1)\n \t\t{\n \t\t  labelvec[i]\n-\t\t    = gen_rtx (LABEL_REF, Pmode, label_rtx (n->code_label));\n+\t\t    = gen_rtx_LABEL_REF (Pmode, label_rtx (n->code_label));\n \t\t  if (i + TREE_INT_CST_LOW (orig_minval)\n \t\t      == TREE_INT_CST_LOW (n->high))\n \t\t    break;\n@@ -5703,18 +5703,18 @@ expand_end_case (orig_index)\n \t  /* Fill in the gaps with the default.  */\n \t  for (i = 0; i < ncases; i++)\n \t    if (labelvec[i] == 0)\n-\t      labelvec[i] = gen_rtx (LABEL_REF, Pmode, default_label);\n+\t      labelvec[i] = gen_rtx_LABEL_REF (Pmode, default_label);\n \n \t  /* Output the table */\n \t  emit_label (table_label);\n \n \t  if (CASE_VECTOR_PC_RELATIVE || flag_pic)\n-\t    emit_jump_insn (gen_rtx (ADDR_DIFF_VEC, CASE_VECTOR_MODE,\n-\t\t\t\t     gen_rtx (LABEL_REF, Pmode, table_label),\n-\t\t\t\t     gen_rtvec_v (ncases, labelvec)));\n+\t    emit_jump_insn (gen_rtx_ADDR_DIFF_VEC (CASE_VECTOR_MODE,\n+\t\t\t\t\t\t   gen_rtx_LABEL_REF (Pmode, table_label),\n+\t\t\t\t\t\t   gen_rtvec_v (ncases, labelvec)));\n \t  else\n-\t    emit_jump_insn (gen_rtx (ADDR_VEC, CASE_VECTOR_MODE,\n-\t\t\t\t     gen_rtvec_v (ncases, labelvec)));\n+\t    emit_jump_insn (gen_rtx_ADDR_VEC (CASE_VECTOR_MODE,\n+\t\t\t\t\t      gen_rtvec_v (ncases, labelvec)));\n \n \t  /* If the case insn drops through the table,\n \t     after the table we must jump to the default-label."}, {"sha": "4800389a216e8abcc8d9fe52fb91e6d60a315d65", "filename": "gcc/stupid.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38a448ca5dfe60244ab3c1f0ea8e3604ec69370b/gcc%2Fstupid.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38a448ca5dfe60244ab3c1f0ea8e3604ec69370b/gcc%2Fstupid.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstupid.c?ref=38a448ca5dfe60244ab3c1f0ea8e3604ec69370b", "patch": "@@ -541,8 +541,9 @@ stupid_mark_refs (x, insn)\n \t\t  && REGNO_LAST_UID (regno) == INSN_UID (insn)\n \t\t  && (code == CLOBBER || ! reg_mentioned_p (SET_DEST (x),\n \t\t\t\t\t\t\t    SET_SRC (x))))\n-\t\tREG_NOTES (insn) = gen_rtx (EXPR_LIST, REG_UNUSED,\n-\t\t\t\t\t    SET_DEST (x), REG_NOTES (insn));\n+\t\tREG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_UNUSED,\n+\t\t\t\t\t\t      SET_DEST (x),\n+\t\t\t\t\t\t      REG_NOTES (insn));\n \t    }\n \t}\n "}, {"sha": "ea708f0f482d98c10da47e0f33787ffdaf49bc86", "filename": "gcc/unroll.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38a448ca5dfe60244ab3c1f0ea8e3604ec69370b/gcc%2Funroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38a448ca5dfe60244ab3c1f0ea8e3604ec69370b/gcc%2Funroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funroll.c?ref=38a448ca5dfe60244ab3c1f0ea8e3604ec69370b", "patch": "@@ -1228,7 +1228,7 @@ unroll_loop (loop_end, insn_count, loop_start, end_insert_before,\n \t  tem = get_label_from_map (map,\n \t\t\t\t    CODE_LABEL_NUMBER\n \t\t\t\t    (XEXP (SET_SRC (pattern), 0)));\n-\t  SET_SRC (pattern) = gen_rtx (LABEL_REF, VOIDmode, tem);\n+\t  SET_SRC (pattern) = gen_rtx_LABEL_REF (VOIDmode, tem);\n \n \t  /* Set the jump label so that it can be used by later loop unrolling\n \t     passes.  */\n@@ -2245,7 +2245,7 @@ fold_rtx_mult_add (mult1, mult2, add1, mode)\n \n   mult_res = simplify_binary_operation (MULT, mode, mult1, mult2);\n   if (! mult_res)\n-    mult_res = gen_rtx (MULT, mode, mult1, mult2);\n+    mult_res = gen_rtx_MULT (mode, mult1, mult2);\n \n   /* Again, put the constant second.  */\n   if (GET_CODE (add1) == CONST_INT)\n@@ -2257,7 +2257,7 @@ fold_rtx_mult_add (mult1, mult2, add1, mode)\n \n   result = simplify_binary_operation (PLUS, mode, add1, mult_res);\n   if (! result)\n-    result = gen_rtx (PLUS, mode, add1, mult_res);\n+    result = gen_rtx_PLUS (mode, add1, mult_res);\n \n   return result;\n }\n@@ -2948,8 +2948,8 @@ find_splittable_givs (bl, unroll_type, loop_start, loop_end, increment,\n \t\t     instruction on machines with complex addressing modes.\n \t\t     If we can't recognize it, then delete it and emit insns\n \t\t     to calculate the value from scratch.  */\n-\t\t  emit_insn_before (gen_rtx (SET, VOIDmode, tem,\n-\t\t\t\t\t     copy_rtx (v->new_reg)),\n+\t\t  emit_insn_before (gen_rtx_SET (VOIDmode, tem,\n+\t\t\t\t\t\t copy_rtx (v->new_reg)),\n \t\t\t\t    loop_start);\n \t\t  if (recog_memoized (PREV_INSN (loop_start)) < 0)\n \t\t    {\n@@ -3109,7 +3109,7 @@ reg_dead_after_loop (reg, loop_start, loop_end)\n   /* HACK: Must also search the loop fall through exit, create a label_ref\n      here which points to the loop_end, and append the loop_number_exit_labels\n      list to it.  */\n-  label = gen_rtx (LABEL_REF, VOIDmode, loop_end);\n+  label = gen_rtx_LABEL_REF (VOIDmode, loop_end);\n   LABEL_NEXTREF (label) = loop_number_exit_labels[this_loop_num];\n \n   for ( ; label; label = LABEL_NEXTREF (label))"}, {"sha": "81e53500475084d96a2cb2a473f12b22a77b6bf6", "filename": "gcc/varasm.c", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38a448ca5dfe60244ab3c1f0ea8e3604ec69370b/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38a448ca5dfe60244ab3c1f0ea8e3604ec69370b/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=38a448ca5dfe60244ab3c1f0ea8e3604ec69370b", "patch": "@@ -541,8 +541,8 @@ make_function_rtl (decl)\n   if (DECL_RTL (decl) == 0)\n     {\n       DECL_RTL (decl)\n-\t= gen_rtx (MEM, DECL_MODE (decl),\n-\t\t   gen_rtx (SYMBOL_REF, Pmode, name));\n+\t= gen_rtx_MEM (DECL_MODE (decl),\n+\t\t       gen_rtx_SYMBOL_REF (Pmode, name));\n \n       /* Optionally set flags or add text to the name to record information\n \t such as that it is a function name.  If the name is changed, the macro\n@@ -762,7 +762,7 @@ make_decl_rtl (decl, asmspec, top_level)\n \t     kludge to avoid setting DECL_RTL to frame_pointer_rtx.  */\n \n \t  DECL_RTL (decl)\n-\t    = gen_rtx (REG, DECL_MODE (decl), FIRST_PSEUDO_REGISTER);\n+\t    = gen_rtx_REG (DECL_MODE (decl), FIRST_PSEUDO_REGISTER);\n \t  REGNO (DECL_RTL (decl)) = reg_number;\n \t  REG_USERVAR_P (DECL_RTL (decl)) = 1;\n \n@@ -816,8 +816,8 @@ make_decl_rtl (decl, asmspec, top_level)\n \t      \t\t\t   new_name, strlen (new_name));\n \t    }\n \n-\t  DECL_RTL (decl) = gen_rtx (MEM, DECL_MODE (decl),\n-\t\t\t\t     gen_rtx (SYMBOL_REF, Pmode, name));\n+\t  DECL_RTL (decl) = gen_rtx_MEM (DECL_MODE (decl),\n+\t\t\t\t\t gen_rtx_SYMBOL_REF (Pmode, name));\n \n \t  /* If this variable is to be treated as volatile, show its\n \t     tree node has side effects.  If it has side effects, either\n@@ -1880,7 +1880,7 @@ assemble_static_space (size)\n   if (output_bytecode)\n     x = bc_gen_rtx (namestring, 0, (struct bc_label *) 0);\n   else\n-    x = gen_rtx (SYMBOL_REF, Pmode, namestring);\n+    x = gen_rtx_SYMBOL_REF (Pmode, namestring);\n \n   if (output_bytecode)\n     {\n@@ -1938,7 +1938,7 @@ assemble_trampoline_template ()\n   ASM_GENERATE_INTERNAL_LABEL (label, \"LTRAMP\", 0);\n   name\n     = (char *) obstack_copy0 (&permanent_obstack, label, strlen (label));\n-  return gen_rtx (SYMBOL_REF, Pmode, name);\n+  return gen_rtx_SYMBOL_REF (Pmode, name);\n }\n #endif\n \f\n@@ -2207,7 +2207,7 @@ immed_double_const (i0, i1, mode)\n \n   push_obstacks_nochange ();\n   rtl_in_saveable_obstack ();\n-  r = gen_rtx (CONST_DOUBLE, mode, NULL_RTX, i0, i1);\n+  r = gen_rtx_CONST_DOUBLE (mode, NULL_RTX, i0, i1);\n   pop_obstacks ();\n \n   /* Don't touch const_double_chain in nested function; see force_const_mem.\n@@ -2389,9 +2389,9 @@ decode_addr_const (exp, value)\n \t/* FIXME: this may not be correct, check it */\n \tx = bc_gen_rtx (TREE_STRING_POINTER (target), 0, (struct bc_label *) 0);\n       else\n-\tx = gen_rtx (MEM, FUNCTION_MODE,\n-\t\t     gen_rtx (LABEL_REF, VOIDmode,\n-\t\t\t      label_rtx (TREE_OPERAND (exp, 0))));\n+\tx = gen_rtx_MEM (FUNCTION_MODE,\n+\t\t\t gen_rtx_LABEL_REF (VOIDmode,\n+\t\t\t\t\t    label_rtx (TREE_OPERAND (exp, 0))));\n       break;\n \n     case REAL_CST:\n@@ -3087,10 +3087,10 @@ output_constant_def (exp)\n   if (TREE_PERMANENT (exp))\n     end_temporary_allocation ();\n \n-  def = gen_rtx (SYMBOL_REF, Pmode, desc->label);\n+  def = gen_rtx_SYMBOL_REF (Pmode, desc->label);\n       \n   TREE_CST_RTL (exp)\n-    = gen_rtx (MEM, TYPE_MODE (TREE_TYPE (exp)), def);\n+    = gen_rtx_MEM (TYPE_MODE (TREE_TYPE (exp)), def);\n   RTX_UNCHANGING_P (TREE_CST_RTL (exp)) = 1;\n   if (AGGREGATE_TYPE_P (TREE_TYPE (exp)))\n     MEM_IN_STRUCT_P (TREE_CST_RTL (exp)) = 1;\n@@ -3588,10 +3588,10 @@ force_const_mem (mode, x)\n \t  rtl_in_saveable_obstack ();\n \n \t  if (GET_CODE (x) == CONST)\n-\t    x = gen_rtx (CONST, GET_MODE (x), \n-\t\t\t gen_rtx (PLUS, GET_MODE (x), \n-\t\t\t\t  XEXP (XEXP (x, 0), 0),\n-\t\t\t\t  XEXP (XEXP (x, 0), 1)));\n+\t    x = gen_rtx_CONST (GET_MODE (x), \n+\t\t\t       gen_rtx_PLUS (GET_MODE (x), \n+\t\t\t\t\t     XEXP (XEXP (x, 0), 0),\n+\t\t\t\t\t     XEXP (XEXP (x, 0), 1)));\n \t  else\n \t    x = GEN_INT (INTVAL (x));\n \n@@ -3637,7 +3637,7 @@ force_const_mem (mode, x)\n \n   /* We have a symbol name; construct the SYMBOL_REF and the MEM.  */\n \n-  def = gen_rtx (MEM, mode, gen_rtx (SYMBOL_REF, Pmode, found));\n+  def = gen_rtx_MEM (mode, gen_rtx_SYMBOL_REF (Pmode, found));\n \n   RTX_UNCHANGING_P (def) = 1;\n   /* Mark the symbol_ref as belonging to this constants pool.  */"}]}