{"sha": "d1f876538e319f40cf1e0cf83ee0943e4e8eb543", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDFmODc2NTM4ZTMxOWY0MGNmMWUwY2Y4M2VlMDk0M2U0ZThlYjU0Mw==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2002-12-26T18:45:04Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2002-12-26T18:45:04Z"}, "message": "athlon.md: Fix comment typos.\n\n\t* config/i386/athlon.md: Fix comment typos.\n\t* config/i386/crtdll.h: Likewise.\n\t* config/i386/djgpp.h: Likewise.\n\t* config/i386/i386-interix.h: Likewise.\n\t* config/i386/i386.c: Likewise.\n\t* config/i386/i386.h: Likewise.\n\t* config/i386/i386.md: Likewise.\n\t* config/i386/k6.md: Likewise.\n\t* config/i386/mingw32.h: Likewise.\n\t* config/i386/pentium.md: Likewise.\n\t* config/i386/sco5.h: Likewise.\n\t* config/i386/winnt.c: Likewise.\n\t* config/i386/xmmintrin.h: Likewise.\n\nFrom-SVN: r60524", "tree": {"sha": "693c752cca293a18b8a5f441753970e2faa97ce8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/693c752cca293a18b8a5f441753970e2faa97ce8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d1f876538e319f40cf1e0cf83ee0943e4e8eb543", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d1f876538e319f40cf1e0cf83ee0943e4e8eb543", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d1f876538e319f40cf1e0cf83ee0943e4e8eb543", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d1f876538e319f40cf1e0cf83ee0943e4e8eb543/comments", "author": null, "committer": null, "parents": [{"sha": "eab5474f6d127da9625a398ba5c5e759ab73d130", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eab5474f6d127da9625a398ba5c5e759ab73d130", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eab5474f6d127da9625a398ba5c5e759ab73d130"}], "stats": {"total": 194, "additions": 105, "deletions": 89}, "files": [{"sha": "2732154e1e7d7032d7b9b04a3c78d7ba6b815e5e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1f876538e319f40cf1e0cf83ee0943e4e8eb543/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1f876538e319f40cf1e0cf83ee0943e4e8eb543/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d1f876538e319f40cf1e0cf83ee0943e4e8eb543", "patch": "@@ -1,3 +1,19 @@\n+2002-12-26  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* config/i386/athlon.md: Fix comment typos.\n+\t* config/i386/crtdll.h: Likewise.\n+\t* config/i386/djgpp.h: Likewise.\n+\t* config/i386/i386-interix.h: Likewise.\n+\t* config/i386/i386.c: Likewise.\n+\t* config/i386/i386.h: Likewise.\n+\t* config/i386/i386.md: Likewise.\n+\t* config/i386/k6.md: Likewise.\n+\t* config/i386/mingw32.h: Likewise.\n+\t* config/i386/pentium.md: Likewise.\n+\t* config/i386/sco5.h: Likewise.\n+\t* config/i386/winnt.c: Likewise.\n+\t* config/i386/xmmintrin.h: Likewise.\n+\n 2002-12-26  Jose Renau <renau@cs.uiuc.edu>\n \n \t* ssa-dce.c (EXECUTE_IF_UNNECESSARY): Verify INSN is an"}, {"sha": "6913fcd8bf449e069c9b0db4d8b6d7038a8cd53e", "filename": "gcc/config/i386/athlon.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1f876538e319f40cf1e0cf83ee0943e4e8eb543/gcc%2Fconfig%2Fi386%2Fathlon.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1f876538e319f40cf1e0cf83ee0943e4e8eb543/gcc%2Fconfig%2Fi386%2Fathlon.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fathlon.md?ref=d1f876538e319f40cf1e0cf83ee0943e4e8eb543", "patch": "@@ -53,7 +53,7 @@\n ;; is used (this is needed to allow troughput of 1.5 double decoded\n ;; instructions per cycle).\n ;;\n-;; In order to avoid dependnece between reservation of decoder\n+;; In order to avoid dependence between reservation of decoder\n ;; and other units, we model decoder as two stage fully pipelined unit\n ;; and only double decoded instruction may occupy unit in the first cycle.\n ;; With this scheme however two double instructions can be issued cycle0.\n@@ -74,7 +74,7 @@\n \t\t\t\t     | (nothing,(athlon-decode0 + athlon-decode1))\n \t\t\t\t     | (nothing,(athlon-decode1 + athlon-decode2)))\")\n \n-;; Agu and ieu unit results in extremly large automatons and\n+;; Agu and ieu unit results in extremely large automatons and\n ;; in our approximation they are hardly filled in.  Only ieu\n ;; unit can, as issue rate is 3 and agu unit is always used\n ;; first in the insn reservations.  Skip the models.\n@@ -107,7 +107,7 @@\n (define_reservation \"athlon-faddmul\" \"(athlon-fadd | athlon-fmul)\")\n \n \n-;; Jump instructions are executed in the branch unit compltetely transparent to us\n+;; Jump instructions are executed in the branch unit completely transparent to us\n (define_insn_reservation \"athlon_branch\" 0\n \t\t\t (and (eq_attr \"cpu\" \"athlon,k8\")\n \t\t\t      (eq_attr \"type\" \"ibr\"))\n@@ -474,7 +474,7 @@\n \t\t\t (and (eq_attr \"cpu\" \"athlon,k8\")\n \t\t\t      (eq_attr \"unit\" \"mmx\"))\n \t\t\t \"athlon-direct,athlon-faddmul\")\n-;; SSE operations are handled by the i387 unit as well.  The latnecy\n+;; SSE operations are handled by the i387 unit as well.  The latency\n ;; is same as for i387 operations for scalar operations\n (define_insn_reservation \"athlon_sselog_load\" 6\n \t\t\t (and (eq_attr \"cpu\" \"athlon\")"}, {"sha": "caddc99f761b5fbb4cc5efe42612647f825b203b", "filename": "gcc/config/i386/crtdll.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1f876538e319f40cf1e0cf83ee0943e4e8eb543/gcc%2Fconfig%2Fi386%2Fcrtdll.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1f876538e319f40cf1e0cf83ee0943e4e8eb543/gcc%2Fconfig%2Fi386%2Fcrtdll.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fcrtdll.h?ref=d1f876538e319f40cf1e0cf83ee0943e4e8eb543", "patch": "@@ -1,6 +1,6 @@\n /* Operating system specific defines to be used when targeting GCC for\n    hosting on Windows32, using GNU tools and the Windows32 API Library.\n-   This variant uses CRTDLL.DLL insted of MSVCRTDLL.DLL.\n+   This variant uses CRTDLL.DLL instead of MSVCRTDLL.DLL.\n    Copyright (C) 1998, 1999, 2000 Free Software Foundation, Inc.\n \n This file is part of GNU CC."}, {"sha": "67980344453d9fd08365e7f2f9a2c487ce4f9df4", "filename": "gcc/config/i386/djgpp.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1f876538e319f40cf1e0cf83ee0943e4e8eb543/gcc%2Fconfig%2Fi386%2Fdjgpp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1f876538e319f40cf1e0cf83ee0943e4e8eb543/gcc%2Fconfig%2Fi386%2Fdjgpp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fdjgpp.h?ref=d1f876538e319f40cf1e0cf83ee0943e4e8eb543", "patch": "@@ -63,7 +63,7 @@ Boston, MA 02111-1307, USA.  */\n \n /* Define standard DJGPP installation paths.                             */\n /* We override default /usr or /usr/local part with /dev/env/DJDIR which */\n-/* points to actual DJGPP instalation directory.                         */\n+/* points to actual DJGPP installation directory.                        */\n \n /* Standard include directory */\n #undef STANDARD_INCLUDE_DIR"}, {"sha": "4d3f8603b43f57088243ea0b309d852124ff9418", "filename": "gcc/config/i386/i386-interix.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1f876538e319f40cf1e0cf83ee0943e4e8eb543/gcc%2Fconfig%2Fi386%2Fi386-interix.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1f876538e319f40cf1e0cf83ee0943e4e8eb543/gcc%2Fconfig%2Fi386%2Fi386-interix.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-interix.h?ref=d1f876538e319f40cf1e0cf83ee0943e4e8eb543", "patch": "@@ -36,7 +36,7 @@ Boston, MA 02111-1307, USA.  */\n /* By default, target has a 80387, uses IEEE compatible arithmetic,\n    and returns float values in the 387 and needs stack probes\n    We also align doubles to 64-bits for MSVC default compatibility\n-   We do bitfields MSVC-compatably by default, too. */\n+   We do bitfields MSVC-compatibly by default, too. */\n #undef TARGET_SUBTARGET_DEFAULT\n #define TARGET_SUBTARGET_DEFAULT \\\n    (MASK_80387 | MASK_IEEE_FP | MASK_FLOAT_RETURNS | MASK_STACK_PROBE | \\"}, {"sha": "a714670a97b491c52a479486292634547e16eb02", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1f876538e319f40cf1e0cf83ee0943e4e8eb543/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1f876538e319f40cf1e0cf83ee0943e4e8eb543/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=d1f876538e319f40cf1e0cf83ee0943e4e8eb543", "patch": "@@ -503,7 +503,7 @@ const int x86_shift1 = ~m_486;\n const int x86_arch_always_fancy_math_387 = m_PENT | m_PPRO | m_ATHLON_K8 | m_PENT4;\n const int x86_sse_partial_reg_dependency = m_PENT4 | m_PPRO;\n /* Set for machines where the type and dependencies are resolved on SSE register\n-   parts insetad of whole registers, so we may maintain just lower part of\n+   parts instead of whole registers, so we may maintain just lower part of\n    scalar values in proper format leaving the upper part undefined.  */\n const int x86_sse_partial_regs = m_ATHLON_K8;\n /* Athlon optimizes partial-register FPS special case, thus avoiding the\n@@ -514,7 +514,7 @@ const int x86_sse_load0_by_pxor = m_PPRO | m_PENT4;\n const int x86_use_ffreep = m_ATHLON_K8;\n const int x86_rep_movl_optimal = m_386 | m_PENT | m_PPRO | m_K6;\n \n-/* In case the avreage insn count for single function invocation is\n+/* In case the average insn count for single function invocation is\n    lower than this constant, emit fast (but longer) prologue and\n    epilogue code.  */\n #define FAST_PROLOGUE_INSN_COUNT 20\n@@ -651,8 +651,8 @@ int const svr4_dbx_register_map[FIRST_PSEUDO_REGISTER] =\n   -1, 9, -1, -1, -1,\t\t\t/* arg, flags, fpsr, dir, frame */\n   21, 22, 23, 24, 25, 26, 27, 28,\t/* SSE registers */\n   29, 30, 31, 32, 33, 34, 35, 36,\t/* MMX registers */\n-  -1, -1, -1, -1, -1, -1, -1, -1,\t/* extemded integer registers */\n-  -1, -1, -1, -1, -1, -1, -1, -1,\t/* extemded SSE registers */\n+  -1, -1, -1, -1, -1, -1, -1, -1,\t/* extended integer registers */\n+  -1, -1, -1, -1, -1, -1, -1, -1,\t/* extended SSE registers */\n };\n \n /* Test and compare insns in i386.md store the information needed to\n@@ -879,9 +879,9 @@ static void ix86_svr3_asm_out_constructor PARAMS ((rtx, int));\n /* Register class used for passing given 64bit part of the argument.\n    These represent classes as documented by the PS ABI, with the exception\n    of SSESF, SSEDF classes, that are basically SSE class, just gcc will\n-   use SF or DFmode move instead of DImode to avoid reformating penalties.\n+   use SF or DFmode move instead of DImode to avoid reformatting penalties.\n \n-   Similary we play games with INTEGERSI_CLASS to use cheaper SImode moves\n+   Similarly we play games with INTEGERSI_CLASS to use cheaper SImode moves\n    whenever possible (upper half does contain padding).\n  */\n enum x86_64_reg_class\n@@ -1085,7 +1085,7 @@ override_options ()\n   real_format_for_mode[TFmode - QFmode] = &ieee_extended_intel_128_format;\n \n   /* Set the default values for switches whose default depends on TARGET_64BIT\n-     in case they weren't overwriten by command line options.  */\n+     in case they weren't overwritten by command line options.  */\n   if (TARGET_64BIT)\n     {\n       if (flag_omit_frame_pointer == 2)\n@@ -1394,7 +1394,7 @@ override_options ()\n   if (TARGET_3DNOW)\n     {\n       target_flags |= MASK_MMX;\n-      /* If we are targetting the Athlon architecture, enable the 3Dnow/MMX\n+      /* If we are targeting the Athlon architecture, enable the 3Dnow/MMX\n \t extensions it adds.  */\n       if (x86_3dnow_a & (1 << ix86_arch))\n \ttarget_flags |= MASK_3DNOW_A;\n@@ -1810,7 +1810,7 @@ init_cumulative_args (cum, fntype, libname)\n   return;\n }\n \n-/* x86-64 register passing impleemntation.  See x86-64 ABI for details.  Goal\n+/* x86-64 register passing implementation.  See x86-64 ABI for details.  Goal\n    of this code is to classify each 8bytes of incoming argument by the register\n    class and assign registers accordingly.  */\n \n@@ -2274,7 +2274,7 @@ construct_container (mode, type, in_return, nintregs, nsseregs, intreg, sse_regn\n \t    break;\n \t  case X86_64_INTEGER_CLASS:\n \t  case X86_64_INTEGERSI_CLASS:\n-\t    /* Merge TImodes on aligned occassions here too.  */\n+\t    /* Merge TImodes on aligned occasions here too.  */\n \t    if (i * 8 + 8 > bytes)\n \t      tmpmode = mode_for_size ((bytes - i * 8) * BITS_PER_UNIT, MODE_INT, 0);\n \t    else if (class[i] == X86_64_INTEGERSI_CLASS)\n@@ -2536,8 +2536,8 @@ ix86_function_value (valtype)\n       rtx ret = construct_container (TYPE_MODE (valtype), valtype, 1,\n \t\t\t\t     REGPARM_MAX, SSE_REGPARM_MAX,\n \t\t\t\t     x86_64_int_return_registers, 0);\n-      /* For zero sized structures, construct_continer return NULL, but we need\n-         to keep rest of compiler happy by returning meaningfull value.  */\n+      /* For zero sized structures, construct_container return NULL, but we need\n+         to keep rest of compiler happy by returning meaningful value.  */\n       if (!ret)\n \tret = gen_rtx_REG (TYPE_MODE (valtype), 0);\n       return ret;\n@@ -2719,7 +2719,7 @@ ix86_setup_incoming_varargs (cum, mode, type, pretend_size, no_rtl)\n   if (next_cum.sse_nregs)\n     {\n       /* Now emit code to save SSE registers.  The AX parameter contains number\n-\t of SSE parameter regsiters used to call this function.  We use\n+\t of SSE parameter registers used to call this function.  We use\n \t sse_prologue_save insn template that produces computed jump across\n \t SSE saves.  We need some preparation work to get this working.  */\n \n@@ -2885,11 +2885,11 @@ ix86_va_arg (valist, type)\n       need_temp = ((needed_intregs && TYPE_ALIGN (type) > 64)\n \t\t   || TYPE_ALIGN (type) > 128);\n \n-      /* In case we are passing structure, verify that it is consetuctive block\n+      /* In case we are passing structure, verify that it is consecutive block\n          on the register save area.  If not we need to do moves.  */\n       if (!need_temp && !REG_P (container))\n \t{\n-\t  /* Verify that all registers are strictly consetuctive  */\n+\t  /* Verify that all registers are strictly consecutive  */\n \t  if (SSE_REGNO_P (REGNO (XEXP (XVECEXP (container, 0, 0), 0))))\n \t    {\n \t      int i;\n@@ -3479,7 +3479,7 @@ const248_operand (op, mode)\n \t  && (INTVAL (op) == 2 || INTVAL (op) == 4 || INTVAL (op) == 8));\n }\n \n-/* True if this is a constant appropriate for an increment or decremenmt.  */\n+/* True if this is a constant appropriate for an increment or decrement.  */\n \n int\n incdec_operand (op, mode)\n@@ -3833,7 +3833,7 @@ ext_register_operand (op, mode)\n   if (!register_operand (op, VOIDmode))\n     return 0;\n \n-  /* Be curefull to accept only registers having upper parts.  */\n+  /* Be careful to accept only registers having upper parts.  */\n   regno = REG_P (op) ? REGNO (op) : REGNO (SUBREG_REG (op));\n   return (regno > LAST_VIRTUAL_REGISTER || regno < 4);\n }\n@@ -4731,7 +4731,7 @@ ix86_expand_prologue ()\n          is significantly longer, but also executes faster as modern hardware\n          can execute the moves in parallel, but can't do that for push/pop.\n \t \n-\t Be curefull about choosing what prologue to emit:  When function takes\n+\t Be careful about choosing what prologue to emit:  When function takes\n \t many instructions to execute we may use slow version as well as in\n \t case function is known to be outside hot spot (this is known with\n \t feedback only).  Weight the size of function by number of registers\n@@ -4834,7 +4834,7 @@ ix86_expand_prologue ()\n       /* Even with accurate pre-reload life analysis, we can wind up\n \t deleting all references to the pic register after reload.\n \t Consider if cross-jumping unifies two sides of a branch\n-\t controled by a comparison vs the only read from a global.\n+\t controlled by a comparison vs the only read from a global.\n \t In which case, allow the set_got to be deleted, though we're\n \t too late to do anything about the ebx save in the prologue.  */\n       REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_MAYBE_DEAD, const0_rtx, NULL);\n@@ -4896,7 +4896,7 @@ ix86_expand_epilogue (style)\n      while this code results in LEAVE instruction (or discrete equivalent),\n      so it is profitable in some other cases as well.  Especially when there\n      are no registers to restore.  We also use this code when TARGET_USE_LEAVE\n-     and there is exactly one register to pop. This heruistic may need some\n+     and there is exactly one register to pop. This heuristic may need some\n      tuning in future.  */\n   if ((!sp_valid && frame.nregs <= 1)\n       || (TARGET_EPILOGUE_USING_MOVE\n@@ -7080,7 +7080,7 @@ print_operand (file, x, code)\n \t\t    int cputaken = final_forward_branch_p (current_output_insn) == 0;\n \n \t\t    /* Emit hints only in the case default branch prediction\n-\t\t       heruistics would fail.  */\n+\t\t       heuristics would fail.  */\n \t\t    if (taken != cputaken)\n \t\t      {\n \t\t\t/* We use 3e (DS) prefix for taken branches and\n@@ -8448,7 +8448,7 @@ ix86_use_fcomi_compare (code)\n \n /* Swap, force into registers, or otherwise massage the two operands\n    to a fp comparison.  The operands are updated in place; the new\n-   comparsion code is returned.  */\n+   comparison code is returned.  */\n \n static enum rtx_code\n ix86_prepare_fp_compare_args (code, pop0, pop1)\n@@ -8663,7 +8663,7 @@ ix86_fp_comparison_fcomi_cost (code)\n      enum rtx_code code;\n {\n   enum rtx_code bypass_code, first_code, second_code;\n-  /* Return arbitarily high cost when instruction is not supported - this\n+  /* Return arbitrarily high cost when instruction is not supported - this\n      prevents gcc from using it.  */\n   if (!TARGET_CMOVE)\n     return 1024;\n@@ -8678,7 +8678,7 @@ ix86_fp_comparison_sahf_cost (code)\n      enum rtx_code code;\n {\n   enum rtx_code bypass_code, first_code, second_code;\n-  /* Return arbitarily high cost when instruction is not preferred - this\n+  /* Return arbitrarily high cost when instruction is not preferred - this\n      avoids gcc from using it.  */\n   if (!TARGET_USE_SAHF && !optimize_size)\n     return 1024;\n@@ -9244,7 +9244,7 @@ ix86_expand_setcc (code, dest)\n   return 1; /* DONE */\n }\n \n-/* Expand comparison setting or clearing carry flag.  Return true when sucesfull\n+/* Expand comparison setting or clearing carry flag.  Return true when successful\n    and set pop for the operation.  */\n bool\n ix86_expand_carry_flag_compare (code, op0, op1, pop)\n@@ -9901,7 +9901,7 @@ ix86_expand_fp_movcc (operands)\n \t\t\t\t\tVOIDmode, ix86_compare_op0,\n \t\t\t\t\tix86_compare_op1);\n \t}\n-      /* Similary try to manage result to be first operand of conditional\n+      /* Similarly try to manage result to be first operand of conditional\n \t move. We also don't support the NE comparison on SSE, so try to\n \t avoid it.  */\n       if ((rtx_equal_p (operands[0], operands[3])\n@@ -10645,7 +10645,7 @@ ix86_expand_movstr (dst, src, count_exp, align_exp)\n          able to predict the branches) and also it is friendlier to the\n          hardware branch prediction.\n \n-         Using loops is benefical for generic case, because we can\n+         Using loops is beneficial for generic case, because we can\n          handle small counts using the loops.  Many CPUs (such as Athlon)\n          have large REP prefix setup costs.\n \n@@ -11563,7 +11563,7 @@ ix86_adjust_cost (insn, link, dep_insn, cost)\n   rtx set, set2;\n   int dep_insn_code_number;\n \n-  /* Anti and output depenancies have zero cost on all CPUs.  */\n+  /* Anti and output dependencies have zero cost on all CPUs.  */\n   if (REG_NOTE_KIND (link) != 0)\n     return 0;\n \n@@ -11587,7 +11587,7 @@ ix86_adjust_cost (insn, link, dep_insn, cost)\n       if (ix86_flags_dependant (insn, dep_insn, insn_type))\n \tcost = 0;\n \n-      /* Floating point stores require value to be ready one cycle ealier.  */\n+      /* Floating point stores require value to be ready one cycle earlier.  */\n       if (insn_type == TYPE_FMOV\n \t  && get_attr_memory (insn) == MEMORY_STORE\n \t  && !ix86_agi_dependant (insn, dep_insn, insn_type))\n@@ -14180,7 +14180,7 @@ ix86_register_move_cost (mode, class1, class2)\n       \n       /* In case of copying from general_purpose_register we may emit multiple\n          stores followed by single load causing memory size mismatch stall.\n-         Count this as arbitarily high cost of 20.  */\n+         Count this as arbitrarily high cost of 20.  */\n       if (CLASS_MAX_NREGS (class1, mode) > CLASS_MAX_NREGS (class2, mode))\n \tcost += 20;\n \n@@ -14438,7 +14438,7 @@ x86_order_regs_for_local_alloc ()\n    for (i = FIRST_REX_SSE_REG; i <= LAST_REX_SSE_REG; i++)\n      reg_alloc_order [pos++] = i;\n \n-   /* x87 registerts.  */\n+   /* x87 registers.  */\n    if (TARGET_SSE_MATH)\n      for (i = FIRST_STACK_REG; i <= LAST_STACK_REG; i++)\n        reg_alloc_order [pos++] = i;\n@@ -14713,7 +14713,7 @@ x86_function_profiler (file, labelno)\n \n /* Implement machine specific optimizations.  \n    At the moment we implement single transformation: AMD Athlon works faster\n-   when RET is not destination of conditional jump or directly preceeded\n+   when RET is not destination of conditional jump or directly preceded\n    by other jump instruction.  We avoid the penalty by inserting NOP just\n    before the RET instructions in such cases.  */\n void"}, {"sha": "ac53a4f3f11a97747c429b5a5e12d1dbd84ba747", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1f876538e319f40cf1e0cf83ee0943e4e8eb543/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1f876538e319f40cf1e0cf83ee0943e4e8eb543/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=d1f876538e319f40cf1e0cf83ee0943e4e8eb543", "patch": "@@ -745,12 +745,12 @@ extern int x86_prefetch_sse;\n /* Boundary (in *bits*) on which stack pointer should be aligned.  */\n #define STACK_BOUNDARY BITS_PER_WORD\n \n-/* Boundary (in *bits*) on which the stack pointer preferrs to be\n+/* Boundary (in *bits*) on which the stack pointer prefers to be\n    aligned; the compiler cannot rely on having this alignment.  */\n #define PREFERRED_STACK_BOUNDARY ix86_preferred_stack_boundary\n \n /* As of July 2001, many runtimes to not align the stack properly when\n-   entering main.  This causes expand_main_function to forcably align\n+   entering main.  This causes expand_main_function to forcibly align\n    the stack, which results in aligned frames for functions called from\n    main, though it does nothing for the alignment of main itself.  */\n #define FORCE_PREFERRED_STACK_BOUNDARY_IN_MAIN \\\n@@ -771,7 +771,7 @@ extern int x86_prefetch_sse;\n    might need to be aligned. No data type wants to be aligned\n    rounder than this.\n \n-   Pentium+ preferrs DFmode values to be aligned to 64 bit boundary\n+   Pentium+ prefers DFmode values to be aligned to 64 bit boundary\n    and Pentium Pro XFmode values at 128 bit boundaries.  */\n \n #define BIGGEST_ALIGNMENT 128\n@@ -781,7 +781,7 @@ extern int x86_prefetch_sse;\n  ((MODE) == XFmode || (MODE) == TFmode || SSE_REG_MODE_P (MODE))\n \n /* The published ABIs say that doubles should be aligned on word\n-   boundaries, so lower the aligment for structure fields unless\n+   boundaries, so lower the alignment for structure fields unless\n    -malign-double is set.  */\n \n /* ??? Blah -- this macro is used directly by libobjc.  Since it\n@@ -952,7 +952,7 @@ extern int x86_prefetch_sse;\n \n /* ORDER_REGS_FOR_LOCAL_ALLOC is a macro which permits reg_alloc_order\n    to be rearranged based on a particular function.  When using sse math,\n-   we want to allocase SSE before x87 registers and vice vera.  */\n+   we want to allocate SSE before x87 registers and vice vera.  */\n \n #define ORDER_REGS_FOR_LOCAL_ALLOC x86_order_regs_for_local_alloc ()\n \n@@ -1441,7 +1441,7 @@ enum reg_class\n    K is for signed imm8 operands.\n    L is for andsi as zero-extending move.\n    M is for shifts that can be executed by the \"lea\" opcode.\n-   N is for immedaite operands for out/in instructions (0-255)\n+   N is for immediate operands for out/in instructions (0-255)\n    */\n \n #define CONST_OK_FOR_LETTER_P(VALUE, C)\t\t\t\t\\"}, {"sha": "0a05537b6c1b869300e8a2bce3dbe1b9362966c6", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1f876538e319f40cf1e0cf83ee0943e4e8eb543/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1f876538e319f40cf1e0cf83ee0943e4e8eb543/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=d1f876538e319f40cf1e0cf83ee0943e4e8eb543", "patch": "@@ -1205,7 +1205,7 @@\n    (set_attr \"modrm\" \"0,*,0,*,*,*,*,*,*,*\")\n    (set_attr \"mode\" \"SI,SI,SI,SI,SI,SI,DI,TI,SI,SI\")])\n \n-;; Stores and loads of ax to arbitary constant address.\n+;; Stores and loads of ax to arbitrary constant address.\n ;; We fake an second form of instruction to force reload to load address\n ;; into register when rax is not available\n (define_insn \"*movabssi_1_rex64\"\n@@ -1331,7 +1331,7 @@\n \t    (const_string \"HI\")))\n    (set_attr \"modrm\" \"0,*,*,0,*,*\")])\n \n-;; Stores and loads of ax to arbitary constant address.\n+;; Stores and loads of ax to arbitrary constant address.\n ;; We fake an second form of instruction to force reload to load address\n ;; into register when rax is not available\n (define_insn \"*movabshi_1_rex64\"\n@@ -1650,7 +1650,7 @@\n \t(const_string \"SI\")\n \t(const_string \"QI\")))])\n \n-;; Stores and loads of ax to arbitary constant address.\n+;; Stores and loads of ax to arbitrary constant address.\n ;; We fake an second form of instruction to force reload to load address\n ;; into register when rax is not available\n (define_insn \"*movabsqi_1_rex64\"\n@@ -1979,7 +1979,7 @@\n    (set_attr \"length_immediate\" \"*,4,8,*,*,*,*,*,*,*\")\n    (set_attr \"mode\" \"SI,DI,DI,DI,SI,DI,DI,DI,TI,DI\")])\n \n-;; Stores and loads of ax to arbitary constant address.\n+;; Stores and loads of ax to arbitrary constant address.\n ;; We fake an second form of instruction to force reload to load address\n ;; into register when rax is not available\n (define_insn \"*movabsdi_1_rex64\"\n@@ -2256,7 +2256,7 @@\n   \"ix86_expand_move (DFmode, operands); DONE;\")\n \n ;; Size of pushdf is 3 (for sub) + 2 (for fstp) + memory operand size.\n-;; Size of pushdf using integer insturctions is 2+2*memory operand size\n+;; Size of pushdf using integer instructions is 2+2*memory operand size\n ;; On the average, pushdf using integers can be still shorter.  Allow this\n ;; pattern for optimize_size too.\n \n@@ -2418,7 +2418,7 @@\n \t\t       (const_int 0))\n \t\t     (const_string \"V2DF\")]\n \t\t   (const_string \"DF\"))\n-\t       /* For achitectures resolving dependencies on register\n+\t       /* For architectures resolving dependencies on register\n \t\t  parts we may avoid extra work to zero out upper part\n \t\t  of register.  */\n \t       (eq_attr \"alternative\" \"7\")\n@@ -2538,7 +2538,7 @@\n \t\t       (const_int 0))\n \t\t     (const_string \"V2DF\")]\n \t\t   (const_string \"DF\"))\n-\t       /* For achitectures resolving dependencies on register\n+\t       /* For architectures resolving dependencies on register\n \t\t  parts we may avoid extra work to zero out upper part\n \t\t  of register.  */\n \t       (eq_attr \"alternative\" \"7\")\n@@ -2591,7 +2591,7 @@\n   \"ix86_expand_move (TFmode, operands); DONE;\")\n \n ;; Size of pushdf is 3 (for sub) + 2 (for fstp) + memory operand size.\n-;; Size of pushdf using integer insturctions is 3+3*memory operand size\n+;; Size of pushdf using integer instructions is 3+3*memory operand size\n ;; Pushing using integer instructions is longer except for constants\n ;; and direct memory references.\n ;; (assuming that any given constant is pushed only once, but this ought to be\n@@ -3930,7 +3930,7 @@\n   [(set (match_dup 0) (float_truncate:SF (match_dup 1)))]\n   \"\")\n \n-; Avoid possible reformating penalty on the destination by first\n+; Avoid possible reformatting penalty on the destination by first\n ; zeroing it out\n (define_split\n   [(set (match_operand:SF 0 \"register_operand\" \"\")\n@@ -4683,7 +4683,7 @@\n    (set_attr \"mode\" \"SF\")\n    (set_attr \"fp_int_src\" \"true\")])\n \n-; Avoid possible reformating penalty on the destination by first\n+; Avoid possible reformatting penalty on the destination by first\n ; zeroing it out\n (define_split\n   [(set (match_operand:SF 0 \"register_operand\" \"\")\n@@ -4737,7 +4737,7 @@\n    (set_attr \"mode\" \"SF\")\n    (set_attr \"fp_int_src\" \"true\")])\n \n-; Avoid possible reformating penalty on the destination by first\n+; Avoid possible reformatting penalty on the destination by first\n ; zeroing it out\n (define_split\n   [(set (match_operand:SF 0 \"register_operand\" \"\")\n@@ -7420,7 +7420,7 @@\n   \"\")\n \n ;; Allow to come the parameter in eax or edx to avoid extra moves.\n-;; Penalize eax case sligthly because it results in worse scheduling\n+;; Penalize eax case slightly because it results in worse scheduling\n ;; of code.\n (define_insn \"*divmoddi4_nocltd_rex64\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=&a,?a\")\n@@ -7505,7 +7505,7 @@\n   \"\")\n \n ;; Allow to come the parameter in eax or edx to avoid extra moves.\n-;; Penalize eax case sligthly because it results in worse scheduling\n+;; Penalize eax case slightly because it results in worse scheduling\n ;; of code.\n (define_insn \"*divmodsi4_nocltd\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=&a,?a\")\n@@ -7978,7 +7978,7 @@\n ;; Convert HImode/SImode test instructions with immediate to QImode ones.\n ;; i386 does not allow to encode test with 8bit sign extended immediate, so\n ;; this is relatively important trick.\n-;; Do the converison only post-reload to avoid limiting of the register class\n+;; Do the conversion only post-reload to avoid limiting of the register class\n ;; to QI regs.\n (define_split\n   [(set (reg 17)\n@@ -8442,7 +8442,7 @@\n \n ;; Convert wide AND instructions with immediate operand to shorter QImode\n ;; equivalents when possible.\n-;; Don't do the splitting with memory operands, since it intoduces risc\n+;; Don't do the splitting with memory operands, since it introduces risk\n ;; of memory mismatch stalls.  We may want to do the splitting for optimizing\n ;; for size, but that can (should?) be handled by generic code instead.\n (define_split\n@@ -9733,7 +9733,7 @@\n   operands[0] = simplify_gen_subreg (V2DFmode, operands[0], DFmode, 0);\n   operands[1] = simplify_gen_subreg (TImode, operands[1], DFmode, 0);\n   operands[2] = simplify_gen_subreg (TImode, operands[2], V2DFmode, 0);\n-  /* Avoid possible reformating on the operands.  */\n+  /* Avoid possible reformatting on the operands.  */\n   if (TARGET_SSE_PARTIAL_REGS && !optimize_size)\n     emit_insn (gen_sse2_unpcklpd (operands[0], operands[0], operands[0]));\n   if (operands_match_p (operands[0], operands[2]))\n@@ -9862,7 +9862,7 @@\n    operands[0] = gen_rtx_REG (SImode,\n \t\t\t      true_regnum (operands[0]) + (TARGET_64BIT ? 1 : 2));\")\n \n-;; Conditionize these after reload. If they matches before reload, we \n+;; Conditionalize these after reload. If they matches before reload, we \n ;; lose the clobber and ability to use integer instructions.\n \n (define_insn \"*negsf2_1\"\n@@ -10194,7 +10194,7 @@\n   operands[0] = simplify_gen_subreg (V2DFmode, operands[0], DFmode, 0);\n   operands[1] = simplify_gen_subreg (TImode, operands[1], DFmode, 0);\n   operands[2] = simplify_gen_subreg (TImode, operands[2], V2DFmode, 0);\n-  /* Avoid possible reformating on the operands.  */\n+  /* Avoid possible reformatting on the operands.  */\n   if (TARGET_SSE_PARTIAL_REGS && !optimize_size)\n     emit_insn (gen_sse2_unpcklpd (operands[0], operands[0], operands[0]));\n   if (operands_match_p (operands[0], operands[2]))\n@@ -12928,7 +12928,7 @@\n ;; The SSE store flag instructions saves 0 or 0xffffffff to the result.\n ;; subsequent logical operations are used to imitate conditional moves.\n ;; 0xffffffff is NaN, but not in normalized form, so we can't represent\n-;; it directly.  Futher holding this value in pseudo register might bring\n+;; it directly.  Further holding this value in pseudo register might bring\n ;; problem in implicit normalization in spill code.\n ;; So we don't define FLOAT_STORE_FLAG_VALUE and create these\n ;; instructions after reload by splitting the conditional move patterns.\n@@ -14002,7 +14002,7 @@\n       emit_move_insn (operands[0], out);\n     }\n \n-  /* Pentium bsf instruction is extremly slow.  The following code is\n+  /* Pentium bsf instruction is extremely slow.  The following code is\n      recommended by the Intel Optimizing Manual as a reasonable replacement:\n            TEST    EAX,EAX\n \t   JZ      SHORT BS2\n@@ -16941,7 +16941,7 @@\n    DONE;\n })\n \n-;; Split SSE based conditional move into seqence:\n+;; Split SSE based conditional move into sequence:\n ;; cmpCC op0, op4   -  set op0 to 0 or ffffffff depending on the comparison\n ;; and   op2, op0   -  zero op2 if comparison was false\n ;; nand  op0, op3   -  load op3 to op0 if comparison was false\n@@ -16983,7 +16983,7 @@\n     operands[6] = operands[2], operands[7] = operands[4];\n })\n \n-;; Special case of conditional move we can handle effectivly.\n+;; Special case of conditional move we can handle effectively.\n ;; Do not brother with the integer/floating point case, since these are\n ;; bot considerably slower, unlike in the generic case.\n (define_insn \"*sse_movsfcc_const0_1\"\n@@ -17432,7 +17432,7 @@\n \n ;; NOT is not pairable on Pentium, while XOR is, but one byte longer. \n ;; Don't split NOTs with a displacement operand, because resulting XOR\n-;; will not be pariable anyway.\n+;; will not be pairable anyway.\n ;;\n ;; On AMD K6, NOT is vector decoded with memory operand that can not be\n ;; represented using a modRM byte.  The XOR replacement is long decoded,\n@@ -19083,22 +19083,22 @@\n ;; on integral types.  We deal with this by representing the floating point\n ;; logical as logical on arguments casted to TImode as this is what hardware\n ;; really does.  Unfortunately hardware requires the type information to be\n-;; present and thus we must avoid subregs from being simplified and elliminated\n+;; present and thus we must avoid subregs from being simplified and eliminated\n ;; in later compilation phases.\n ;;\n ;; We have following variants from each instruction:\n ;; sse_andsf3 - the operation taking V4SF vector operands\n ;;              and doing TImode cast on them\n ;; *sse_andsf3_memory - the operation taking one memory operand casted to\n-;;                      TImode, since backend insist on elliminating casts\n+;;                      TImode, since backend insist on eliminating casts\n ;;                      on memory operands\n ;; sse_andti3_sf_1 - the operation taking SF scalar operands.\n ;;                   We can not accept memory operand here as instruction reads\n ;;\t\t     whole scalar.  This is generated only post reload by GCC\n ;;\t\t     scalar float operations that expands to logicals (fabs)\n ;; sse_andti3_sf_2 - the operation taking SF scalar input and TImode\n ;;\t\t     memory operand.  Eventually combine can be able\n-;;\t\t     to synthetize these using splitter.\n+;;\t\t     to synthesize these using splitter.\n ;; sse2_anddf3, *sse2_anddf3_memory\n ;;              \n ;; \n@@ -20691,7 +20691,7 @@\n   [(set_attr \"type\" \"mmxshft\")\n    (set_attr \"mode\" \"TI\")])\n \n-;; 3DNow reciprical and sqrt\n+;; 3DNow reciprocal and sqrt\n  \n (define_insn \"pfrcpv2sf2\"\n   [(set (match_operand:V2SF 0 \"register_operand\" \"=y\")"}, {"sha": "58ca6e447a1b1b519cae1da90d0f1d4a8c07fd21", "filename": "gcc/config/i386/k6.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1f876538e319f40cf1e0cf83ee0943e4e8eb543/gcc%2Fconfig%2Fi386%2Fk6.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1f876538e319f40cf1e0cf83ee0943e4e8eb543/gcc%2Fconfig%2Fi386%2Fk6.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fk6.md?ref=d1f876538e319f40cf1e0cf83ee0943e4e8eb543", "patch": "@@ -31,7 +31,7 @@\n ;; fpu    describes FPU unit\n ;; load   describes load unit.\n ;; branch describes branch unit.\n-;; store  decsribes store unit.  This unit is not modelled completely and only\n+;; store  describes store unit.  This unit is not modelled completely and only\n ;;        used to model lea operation.  Otherwise it lie outside of the critical\n ;;        path.\n ;;"}, {"sha": "3b8cf32bed9079436f1571068f78bad3530cd921", "filename": "gcc/config/i386/mingw32.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1f876538e319f40cf1e0cf83ee0943e4e8eb543/gcc%2Fconfig%2Fi386%2Fmingw32.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1f876538e319f40cf1e0cf83ee0943e4e8eb543/gcc%2Fconfig%2Fi386%2Fmingw32.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fmingw32.h?ref=d1f876538e319f40cf1e0cf83ee0943e4e8eb543", "patch": "@@ -32,7 +32,7 @@ Boston, MA 02111-1307, USA.  */\n \n #define TARGET_EXECUTABLE_SUFFIX \".exe\"\n \n-/* See i386/crtdll.h for an altervative definition.  */\n+/* See i386/crtdll.h for an alternative definition.  */\n #define EXTRA_OS_CPP_BUILTINS()\t\t\t\t\t\\\n   do\t\t\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\\\n@@ -102,7 +102,7 @@ Boston, MA 02111-1307, USA.  */\n #define MATH_LIBRARY \"\"\n \n /* Output STRING, a string representing a filename, to FILE.\n-   We canonicalize it to be in Unix format (backslashe are replaced\n+   We canonicalize it to be in Unix format (backslashes are replaced\n    forward slashes.  */\n #undef OUTPUT_QUOTED_STRING\n #define OUTPUT_QUOTED_STRING(FILE, STRING)               \\\n@@ -129,6 +129,6 @@ do {\t\t\t\t\t\t         \\\n   putc ('\\\"', asm_file);\t\t\t         \\\n } while (0)\n \n-/* Define as short unsigned for compatability with MS runtime.  */\n+/* Define as short unsigned for compatibility with MS runtime.  */\n #undef WINT_TYPE\n #define WINT_TYPE \"short unsigned int\""}, {"sha": "8bf224561afb5ccfc5daf5c35d405f62593d0a53", "filename": "gcc/config/i386/pentium.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1f876538e319f40cf1e0cf83ee0943e4e8eb543/gcc%2Fconfig%2Fi386%2Fpentium.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1f876538e319f40cf1e0cf83ee0943e4e8eb543/gcc%2Fconfig%2Fi386%2Fpentium.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fpentium.md?ref=d1f876538e319f40cf1e0cf83ee0943e4e8eb543", "patch": "@@ -34,7 +34,7 @@\n ;; while MMX Pentium can slot it on either U or V.  Model non-MMX Pentium\n ;; rules, because it results in noticeably better code on non-MMX Pentium\n ;; and doesn't hurt much on MMX.  (Prefixed instructions are not very\n-;; common, so the scheduler usualy has a non-prefixed insn to pair).\n+;; common, so the scheduler usually has a non-prefixed insn to pair).\n \n (define_attr \"pent_pair\" \"uv,pu,pv,np\"\n   (cond [(eq_attr \"imm_disp\" \"true\")\n@@ -71,7 +71,7 @@\n (define_automaton \"pentium,pentium_fpu\")\n \n ;; Pentium do have U and V pipes.  Instruction to both pipes\n-;; are alwyas issued together, much like on VLIW.\n+;; are always issued together, much like on VLIW.\n ;;\n ;;                    predecode\n ;;                   /         \\"}, {"sha": "aad56a193b2544806064544f9197e64286e40d21", "filename": "gcc/config/i386/sco5.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1f876538e319f40cf1e0cf83ee0943e4e8eb543/gcc%2Fconfig%2Fi386%2Fsco5.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1f876538e319f40cf1e0cf83ee0943e4e8eb543/gcc%2Fconfig%2Fi386%2Fsco5.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fsco5.h?ref=d1f876538e319f40cf1e0cf83ee0943e4e8eb543", "patch": "@@ -72,7 +72,7 @@ Boston, MA 02111-1307, USA.  */\n #define EH_FRAME_SECTION_NAME\t\\\n   ((TARGET_ELF) ? EH_FRAME_SECTION_NAME_ELF : EH_FRAME_SECTION_NAME_COFF)\n \n-/* Avoid problems (long sectino names, forward assembler refs) with DWARF\n+/* Avoid problems (long section names, forward assembler refs) with DWARF\n    exception unwinding when we're generating COFF */\n #define DWARF2_UNWIND_INFO\t\\\n   ((TARGET_ELF) ? 1 : 0 )  "}, {"sha": "846776139476ad1e5a9adada66ffff04481e76f8", "filename": "gcc/config/i386/winnt.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1f876538e319f40cf1e0cf83ee0943e4e8eb543/gcc%2Fconfig%2Fi386%2Fwinnt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1f876538e319f40cf1e0cf83ee0943e4e8eb543/gcc%2Fconfig%2Fi386%2Fwinnt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fwinnt.c?ref=d1f876538e319f40cf1e0cf83ee0943e4e8eb543", "patch": "@@ -579,7 +579,7 @@ i386_pe_unique_section (decl, reloc)\n    If the section has already been defined, to not allow it to have\n    different attributes, as (1) this is ambiguous since we're not seeing\n    all the declarations up front and (2) some assemblers (e.g. SVR4)\n-   do not recoginize section redefinitions.  */\n+   do not recognize section redefinitions.  */\n /* ??? This differs from the \"standard\" PE implementation in that we\n    handle the SHARED variable attribute.  Should this be done for all\n    PE targets?  */"}, {"sha": "be378253cc198ccef41f6d687721be77fbe9e961", "filename": "gcc/config/i386/xmmintrin.h", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1f876538e319f40cf1e0cf83ee0943e4e8eb543/gcc%2Fconfig%2Fi386%2Fxmmintrin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1f876538e319f40cf1e0cf83ee0943e4e8eb543/gcc%2Fconfig%2Fi386%2Fxmmintrin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fxmmintrin.h?ref=d1f876538e319f40cf1e0cf83ee0943e4e8eb543", "patch": "@@ -37,10 +37,10 @@\n /* We need type definitions from the MMX header file.  */\n #include <mmintrin.h>\n \n-/* The data type indended for user use.  */\n+/* The data type intended for user use.  */\n typedef int __m128 __attribute__ ((__mode__(__V4SF__)));\n \n-/* Internal data types for implementing the instrinsics.  */\n+/* Internal data types for implementing the intrinsics.  */\n typedef int __v4sf __attribute__ ((__mode__(__V4SF__)));\n typedef int __v4si __attribute__ ((__mode__(__V4SI__)));\n \n@@ -1047,7 +1047,7 @@ _mm_stream_ps (float *__P, __m128 __A)\n   __builtin_ia32_movntps (__P, (__v4sf)__A);\n }\n \n-/* Guarantees that every preceeding store is globally visible before\n+/* Guarantees that every preceding store is globally visible before\n    any subsequent store.  */\n static __inline void\n _mm_sfence (void)\n@@ -1114,21 +1114,21 @@ _mm_load_pd1 (double const *__P)\n   return _mm_load1_pd (__P);\n }\n \n-/* Load two DPFP values from P.  The addresd must be 16-byte aligned.  */\n+/* Load two DPFP values from P.  The address must be 16-byte aligned.  */\n static __inline __m128d\n _mm_load_pd (double const *__P)\n {\n   return (__m128d) __builtin_ia32_loadapd (__P);\n }\n \n-/* Load two DPFP values from P.  The addresd need not be 16-byte aligned.  */\n+/* Load two DPFP values from P.  The address need not be 16-byte aligned.  */\n static __inline __m128d\n _mm_loadu_pd (double const *__P)\n {\n   return (__m128d) __builtin_ia32_loadupd (__P);\n }\n \n-/* Load two DPFP values in reverse order.  The addresd must be aligned.  */\n+/* Load two DPFP values in reverse order.  The address must be aligned.  */\n static __inline __m128d\n _mm_loadr_pd (double const *__P)\n {\n@@ -1208,21 +1208,21 @@ _mm_store_pd1 (double *__P, __m128d __A)\n   _mm_store1_pd (__P, __A);\n }\n \n-/* Store two DPFP values.  The addresd must be 16-byte aligned.  */\n+/* Store two DPFP values.  The address must be 16-byte aligned.  */\n static __inline void\n _mm_store_pd (double *__P, __m128d __A)\n {\n   __builtin_ia32_storeapd (__P, (__v2df)__A);\n }\n \n-/* Store two DPFP values.  The addresd need not be 16-byte aligned.  */\n+/* Store two DPFP values.  The address need not be 16-byte aligned.  */\n static __inline void\n _mm_storeu_pd (double *__P, __m128d __A)\n {\n   __builtin_ia32_storeupd (__P, (__v2df)__A);\n }\n \n-/* Store two DPFP values in reverse order.  The addresd must be aligned.  */\n+/* Store two DPFP values in reverse order.  The address must be aligned.  */\n static __inline void\n _mm_storer_pd (double *__P, __m128d __A)\n {"}]}