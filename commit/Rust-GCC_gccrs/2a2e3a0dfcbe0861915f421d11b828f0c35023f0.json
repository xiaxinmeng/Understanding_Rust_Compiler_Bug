{"sha": "2a2e3a0dfcbe0861915f421d11b828f0c35023f0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmEyZTNhMGRmY2JlMDg2MTkxNWY0MjFkMTFiODI4ZjBjMzUwMjNmMA==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2019-09-30T16:19:52Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2019-09-30T16:19:52Z"}, "message": "[x86] Robustify vzeroupper handling across calls\n\nOne of the effects of the function_abi series is to make -fipa-ra\nwork for partially call-clobbered registers.  E.g. if a call preserves\nonly the low 32 bits of a register R, we handled the partial clobber\nseparately from -fipa-ra, and so treated the upper bits of R as\nclobbered even if we knew that the target function doesn't touch R.\n\n\"Fixing\" this caused problems for the vzeroupper handling on x86.\nThe pass that inserts the vzerouppers assumes that no 256-bit or 512-bit\nvalues are live across a call unless the call takes a 256-bit or 512-bit\nargument:\n\n      /* Needed mode is set to AVX_U128_CLEAN if there are\n\t no 256bit or 512bit modes used in function arguments. */\n\nThis implicitly relies on:\n\n/* Implement TARGET_HARD_REGNO_CALL_PART_CLOBBERED.  The only ABI that\n   saves SSE registers across calls is Win64 (thus no need to check the\n   current ABI here), and with AVX enabled Win64 only guarantees that\n   the low 16 bytes are saved.  */\n\nstatic bool\nix86_hard_regno_call_part_clobbered (rtx_insn *insn ATTRIBUTE_UNUSED,\n\t\t\t\t     unsigned int regno, machine_mode mode)\n{\n  return SSE_REGNO_P (regno) && GET_MODE_SIZE (mode) > 16;\n}\n\nThe comment suggests that this code is only needed for Win64 and that\nnot testing for Win64 is just a simplification.  But in practice it was\nneeded for correctness on GNU/Linux and other targets too, since without\nit the RA would be able to keep 256-bit and 512-bit values in SSE\nregisters across calls that are known not to clobber them.\n\nThis patch conservatively treats calls as AVX_U128_ANY if the RA can see\nthat some SSE registers are not touched by a call.  There are then no\nregressions if the ix86_hard_regno_call_part_clobbered check is disabled\nfor GNU/Linux (not something we should do, was just for testing).\n\nIf in fact we want -fipa-ra to pretend that all functions clobber\nSSE registers above 128 bits, it'd certainly be possible to arrange\nthat.  But IMO that would be an optimisation decision, whereas what\nthe patch is fixing is a correctness decision.  So I think we should\nhave this check even so.\n\n2019-09-30  Richard Sandiford  <richard.sandiford@arm.com>\n\ngcc/\n\t* config/i386/i386.c: Include function-abi.h.\n\t(ix86_avx_u128_mode_needed): Treat function calls as AVX_U128_ANY\n\tif they preserve some 256-bit or 512-bit SSE registers.\n\nFrom-SVN: r276310", "tree": {"sha": "e948b38afe63d8e0e48a9bf810f73526442646da", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e948b38afe63d8e0e48a9bf810f73526442646da"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2a2e3a0dfcbe0861915f421d11b828f0c35023f0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a2e3a0dfcbe0861915f421d11b828f0c35023f0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2a2e3a0dfcbe0861915f421d11b828f0c35023f0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a2e3a0dfcbe0861915f421d11b828f0c35023f0/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "5a5a3bc5fa14664be26748c11325021b6b6f8e74", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a5a3bc5fa14664be26748c11325021b6b6f8e74", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5a5a3bc5fa14664be26748c11325021b6b6f8e74"}], "stats": {"total": 16, "additions": 16, "deletions": 0}, "files": [{"sha": "acdcd914dc20a23ce7422b13fd8bcda9748066d8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a2e3a0dfcbe0861915f421d11b828f0c35023f0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a2e3a0dfcbe0861915f421d11b828f0c35023f0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2a2e3a0dfcbe0861915f421d11b828f0c35023f0", "patch": "@@ -1,3 +1,9 @@\n+2019-09-30  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* config/i386/i386.c: Include function-abi.h.\n+\t(ix86_avx_u128_mode_needed): Treat function calls as AVX_U128_ANY\n+\tif they preserve some 256-bit or 512-bit SSE registers.\n+\n 2019-09-30  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* target.def (insn_callee_abi): New hook."}, {"sha": "a13aef8077a7b52a80cc802a1021f73c111223dd", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a2e3a0dfcbe0861915f421d11b828f0c35023f0/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a2e3a0dfcbe0861915f421d11b828f0c35023f0/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=2a2e3a0dfcbe0861915f421d11b828f0c35023f0", "patch": "@@ -95,6 +95,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"i386-builtins.h\"\n #include \"i386-expand.h\"\n #include \"i386-features.h\"\n+#include \"function-abi.h\"\n \n /* This file should be included last.  */\n #include \"target-def.h\"\n@@ -13511,6 +13512,15 @@ ix86_avx_u128_mode_needed (rtx_insn *insn)\n \t    }\n \t}\n \n+      /* If the function is known to preserve some SSE registers,\n+\t RA and previous passes can legitimately rely on that for\n+\t modes wider than 256 bits.  It's only safe to issue a\n+\t vzeroupper if all SSE registers are clobbered.  */\n+      const function_abi &abi = insn_callee_abi (insn);\n+      if (!hard_reg_set_subset_p (reg_class_contents[ALL_SSE_REGS],\n+\t\t\t\t  abi.mode_clobbers (V4DImode)))\n+\treturn AVX_U128_ANY;\n+\n       return AVX_U128_CLEAN;\n     }\n "}]}