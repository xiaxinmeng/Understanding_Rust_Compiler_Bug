{"sha": "99c25a87c6bd63d6b03e3792630ae61c166dcac9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTljMjVhODdjNmJkNjNkNmIwM2UzNzkyNjMwYWU2MWMxNjZkY2FjOQ==", "commit": {"author": {"name": "Tobias Burnus", "email": "burnus@net-b.de", "date": "2012-09-23T06:48:48Z"}, "committer": {"name": "Tobias Burnus", "email": "burnus@gcc.gnu.org", "date": "2012-09-23T06:48:48Z"}, "message": "re PR fortran/54599 (Issues found in gfortran by the Coverity Scan)\n\n2012-09-23  Tobias Burnus  <burnus@net-b.de>\n\n        * parse.c (parse_derived): Don't set attr.alloc_comp\n        for pointer components with allocatable subcomps.\n\n        PR fortran/54599\n        * resolve.c (resolve_fl_namelist): Remove superfluous\n        NULL check.\n        * simplify.c (simplify_min_max): Remove unreachable code.\n        * trans-array.c (gfc_trans_create_temp_array): Change\n        a condition into an assert.\n\n        PR fortran/54618\n        * trans-expr.c (gfc_trans_class_init_assign): Guard\n        re-setting of the _data by gfc_conv_expr_present.\n        (gfc_conv_procedure_call): Fix INTENT(OUT) handling\n        for allocatable BT_CLASS.\n\n2012-09-23  Tobias Burnus  <burnus@net-b.de>\n\n        PR fortran/54618\n        * gfortran.dg/class_array_14.f90: New.\n\nFrom-SVN: r191649", "tree": {"sha": "6fb6edff03b3f9b88751aee4639a84d409c9b04f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6fb6edff03b3f9b88751aee4639a84d409c9b04f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/99c25a87c6bd63d6b03e3792630ae61c166dcac9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/99c25a87c6bd63d6b03e3792630ae61c166dcac9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/99c25a87c6bd63d6b03e3792630ae61c166dcac9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/99c25a87c6bd63d6b03e3792630ae61c166dcac9/comments", "author": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8856695d70f0c622d7154e95b52cd758f77c7e2c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8856695d70f0c622d7154e95b52cd758f77c7e2c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8856695d70f0c622d7154e95b52cd758f77c7e2c"}], "stats": {"total": 128, "additions": 116, "deletions": 12}, "files": [{"sha": "1be83d418b25207cf924d28ef225b671a4ce138a", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99c25a87c6bd63d6b03e3792630ae61c166dcac9/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99c25a87c6bd63d6b03e3792630ae61c166dcac9/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=99c25a87c6bd63d6b03e3792630ae61c166dcac9", "patch": "@@ -1,3 +1,21 @@\n+2012-09-23  Tobias Burnus  <burnus@net-b.de>\n+\n+\t* parse.c (parse_derived): Don't set attr.alloc_comp\n+\tfor pointer components with allocatable subcomps.\n+\n+\tPR fortran/54599\n+\t* resolve.c (resolve_fl_namelist): Remove superfluous\n+\tNULL check.\n+\t* simplify.c (simplify_min_max): Remove unreachable code.\n+\t* trans-array.c (gfc_trans_create_temp_array): Change\n+\ta condition into an assert.\n+\n+\tPR fortran/54618\n+\t* trans-expr.c (gfc_trans_class_init_assign): Guard\n+\tre-setting of the _data by gfc_conv_expr_present.\n+\t(gfc_conv_procedure_call): Fix INTENT(OUT) handling\n+\tfor allocatable BT_CLASS.\n+\n 2012-09-22  Thomas K\u00f6nig  <tkoenig@gcc.gnu.org>\n \n \tPR fortran/54599"}, {"sha": "f31e30940b8ee655b14f8d2327627a544a69e407", "filename": "gcc/fortran/parse.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99c25a87c6bd63d6b03e3792630ae61c166dcac9/gcc%2Ffortran%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99c25a87c6bd63d6b03e3792630ae61c166dcac9/gcc%2Ffortran%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fparse.c?ref=99c25a87c6bd63d6b03e3792630ae61c166dcac9", "patch": "@@ -2195,7 +2195,8 @@ parse_derived (void)\n       if (c->attr.allocatable\n \t  || (c->ts.type == BT_CLASS && c->attr.class_ok\n \t      && CLASS_DATA (c)->attr.allocatable)\n-\t  || (c->ts.type == BT_DERIVED && c->ts.u.derived->attr.alloc_comp))\n+\t  || (c->ts.type == BT_DERIVED && !c->attr.pointer\n+\t      && c->ts.u.derived->attr.alloc_comp))\n \t{\n \t  allocatable = true;\n \t  sym->attr.alloc_comp = 1;"}, {"sha": "0a20540b6da765098d6f7850c4082e076c81186f", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99c25a87c6bd63d6b03e3792630ae61c166dcac9/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99c25a87c6bd63d6b03e3792630ae61c166dcac9/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=99c25a87c6bd63d6b03e3792630ae61c166dcac9", "patch": "@@ -12478,7 +12478,7 @@ resolve_fl_namelist (gfc_symbol *sym)\n \t  continue;\n \n       nlsym = NULL;\n-      if (nl->sym && nl->sym->name)\n+      if (nl->sym->name)\n \tgfc_find_symbol (nl->sym->name, sym->ns, 1, &nlsym);\n       if (nlsym && nlsym->attr.flavor == FL_PROCEDURE)\n \t{"}, {"sha": "2f96e900bf1b20a385090573a526b48ba7b8e842", "filename": "gcc/fortran/simplify.c", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99c25a87c6bd63d6b03e3792630ae61c166dcac9/gcc%2Ffortran%2Fsimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99c25a87c6bd63d6b03e3792630ae61c166dcac9/gcc%2Ffortran%2Fsimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsimplify.c?ref=99c25a87c6bd63d6b03e3792630ae61c166dcac9", "patch": "@@ -4106,10 +4106,7 @@ simplify_min_max (gfc_expr *expr, int sign)\n       min_max_choose (arg->expr, extremum->expr, sign);\n \n       /* Delete the extra constant argument.  */\n-      if (last == NULL)\n-\texpr->value.function.actual = arg->next;\n-      else\n-\tlast->next = arg->next;\n+      last->next = arg->next;\n \n       arg->next = NULL;\n       gfc_free_actual_arglist (arg);"}, {"sha": "3e684ee66495145892f146cf7beeee0489fd5579", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99c25a87c6bd63d6b03e3792630ae61c166dcac9/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99c25a87c6bd63d6b03e3792630ae61c166dcac9/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=99c25a87c6bd63d6b03e3792630ae61c166dcac9", "patch": "@@ -1022,8 +1022,8 @@ gfc_trans_create_temp_array (stmtblock_t * pre, stmtblock_t * post, gfc_ss * ss,\n      dynamic type.  Generate an eltype and then the class expression.  */\n   if (eltype == NULL_TREE && initial)\n     {\n-      if (POINTER_TYPE_P (TREE_TYPE (initial)))\n-\tclass_expr = build_fold_indirect_ref_loc (input_location, initial);\n+      gcc_assert (POINTER_TYPE_P (TREE_TYPE (initial)));\n+      class_expr = build_fold_indirect_ref_loc (input_location, initial);\n       eltype = TREE_TYPE (class_expr);\n       eltype = gfc_get_element_type (eltype);\n       /* Obtain the structure (class) expression.  */"}, {"sha": "177d2865b81a70fdcd5a0084271e316bbdf5d0fa", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 34, "deletions": 4, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99c25a87c6bd63d6b03e3792630ae61c166dcac9/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99c25a87c6bd63d6b03e3792630ae61c166dcac9/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=99c25a87c6bd63d6b03e3792630ae61c166dcac9", "patch": "@@ -621,6 +621,16 @@ gfc_trans_class_init_assign (gfc_code *code)\n       gfc_add_block_to_block (&block, &src.pre);\n       tmp = gfc_build_memcpy_call (dst.expr, src.expr, memsz.expr);\n     }\n+\n+  if (code->expr1->symtree->n.sym->attr.optional\n+      || code->expr1->symtree->n.sym->ns->proc_name->attr.entry_master)\n+    {\n+      tree present = gfc_conv_expr_present (code->expr1->symtree->n.sym);\n+      tmp = build3_loc (input_location, COND_EXPR, TREE_TYPE (tmp),\n+\t\t\tpresent, tmp,\n+\t\t\tbuild_empty_stmt (input_location));\n+    }\n+\n   gfc_add_expr_to_block (&block, tmp);\n   \n   return gfc_finish_block (&block);\n@@ -3905,22 +3915,42 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \n \t\t  /* If an ALLOCATABLE dummy argument has INTENT(OUT) and is \n \t\t     allocated on entry, it must be deallocated.  */\n-\t\t  if (fsym && fsym->attr.allocatable\n-\t\t      && fsym->attr.intent == INTENT_OUT)\n+\t\t  if (fsym && fsym->attr.intent == INTENT_OUT\n+\t\t      && (fsym->attr.allocatable\n+\t\t\t  || (fsym->ts.type == BT_CLASS\n+\t\t\t      && CLASS_DATA (e)->attr.allocatable)))\n \t\t    {\n \t\t      stmtblock_t block;\n+\t\t      tree ptr;\n \n \t\t      gfc_init_block  (&block);\n-\t\t      tmp = gfc_deallocate_with_status (parmse.expr, NULL_TREE,\n+\t\t      ptr = parmse.expr;\n+\t\t      if (e->ts.type == BT_CLASS)\n+\t\t\tptr = gfc_class_data_get (ptr);\t\n+\n+\t\t      tmp = gfc_deallocate_with_status (ptr, NULL_TREE,\n \t\t\t\t\t\t\tNULL_TREE, NULL_TREE,\n \t\t\t\t\t\t\tNULL_TREE, true, NULL,\n \t\t\t\t\t\t\tfalse);\n \t\t      gfc_add_expr_to_block (&block, tmp);\n \t\t      tmp = fold_build2_loc (input_location, MODIFY_EXPR,\n-\t\t\t\t\t     void_type_node, parmse.expr,\n+\t\t\t\t\t     void_type_node, ptr,\n \t\t\t\t\t     null_pointer_node);\n \t\t      gfc_add_expr_to_block (&block, tmp);\n \n+\t\t      if (fsym->ts.type == BT_CLASS)\n+\t\t\t{\n+\t\t\t  gfc_symbol *vtab;\n+\t\t\t  gcc_assert (fsym->ts.u.derived == e->ts.u.derived);\n+\t\t\t  vtab = gfc_find_derived_vtab (fsym->ts.u.derived);\n+\t\t\t  tmp = gfc_get_symbol_decl (vtab);\n+\t\t\t  tmp = gfc_build_addr_expr (NULL_TREE, tmp);\n+\t\t\t  ptr = gfc_class_vptr_get (parmse.expr);\n+\t\t\t  gfc_add_modify (&block, ptr,\n+\t\t\t\t\t  fold_convert (TREE_TYPE (ptr), tmp));\n+\t\t\t  gfc_add_expr_to_block (&block, tmp);\n+\t\t\t}\n+\n \t\t      if (fsym->attr.optional\n \t\t\t  && e->expr_type == EXPR_VARIABLE\n \t\t\t  && e->symtree->n.sym->attr.optional)"}, {"sha": "7b18d9906308bec4242fb7e77e21c6cf7a28cffa", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99c25a87c6bd63d6b03e3792630ae61c166dcac9/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99c25a87c6bd63d6b03e3792630ae61c166dcac9/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=99c25a87c6bd63d6b03e3792630ae61c166dcac9", "patch": "@@ -1,3 +1,8 @@\n+2012-09-2323  Tobias Burnus  <burnus@net-b.de>\n+\n+\tPR fortran/54618\n+\t* gfortran.dg/class_array_14.f90: New.\n+\n 2012-09-22  Kai Tietz  <ktietz@redhat.com>\n \n \t* gcc.dg/tree-ssa/scev-3.c: Add llp64 to xfail."}, {"sha": "ad227a9074ceabeb6cbeca959321fb4d6763cdfa", "filename": "gcc/testsuite/gfortran.dg/class_array_14.f90", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99c25a87c6bd63d6b03e3792630ae61c166dcac9/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_array_14.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99c25a87c6bd63d6b03e3792630ae61c166dcac9/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_array_14.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_array_14.f90?ref=99c25a87c6bd63d6b03e3792630ae61c166dcac9", "patch": "@@ -0,0 +1,53 @@\n+! { dg-do run }\n+!\n+! PR fortran/54618\n+!\n+! Check whether default initialization works with INTENT(OUT)\n+! and ALLOCATABLE and no segfault occurs with OPTIONAL.\n+!\n+\n+subroutine test1()\n+  type typ1\n+    integer :: i = 6\n+  end type typ1\n+\n+  type(typ1) :: x\n+\n+  x%i = 77\n+  call f(x)\n+  if (x%i /= 6) call abort ()\n+  call f()\n+contains\n+  subroutine f(y1)\n+    class(typ1), intent(out), optional :: y1\n+  end subroutine f\n+end subroutine test1\n+\n+subroutine test2()\n+  type mytype\n+  end type mytype\n+  type, extends(mytype):: mytype2\n+  end type mytype2\n+\n+  class(mytype), allocatable :: x,y\n+  allocate (mytype2 :: x)\n+  call g(x)\n+  if (allocated (x) .or. .not. same_type_as (x,y)) call abort()\n+\n+  allocate (mytype2 :: x)\n+  call h(x)\n+  if (allocated (x) .or. .not. same_type_as (x,y)) call abort()\n+\n+  call h()\n+contains\n+  subroutine g(y2)\n+    class(mytype), intent(out), allocatable :: y2\n+  end subroutine g\n+  subroutine h(y3)\n+    class(mytype), optional, intent(out), allocatable :: y3\n+  end subroutine h\n+end subroutine test2\n+\n+call test1()\n+call test2()\n+end"}]}