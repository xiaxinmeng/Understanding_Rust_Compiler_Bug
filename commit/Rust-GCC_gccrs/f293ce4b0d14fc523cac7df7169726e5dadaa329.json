{"sha": "f293ce4b0d14fc523cac7df7169726e5dadaa329", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjI5M2NlNGIwZDE0ZmM1MjNjYWM3ZGY3MTY5NzI2ZTVkYWRhYTMyOQ==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2004-08-16T02:08:06Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2004-08-16T02:08:06Z"}, "message": "call.c (build_vfield_ref, [...]): Replace calls to build with calls to buildN.\n\n\n\t* call.c (build_vfield_ref, build_call, build_conditional_expr,\n\tconvert_arg_to_ellipsis, build_x_va_arg, build_over_call,\n\tbuild_java_interface_fn_ref, build_special_member_call,\n\tbuild_new_method_call, initialize_reference): Replace calls to\n\tbuild with calls to buildN.\n\t* class.c (build_base_path, convert_to_base_statically,\n\tbuild_vfn_ref, instantiate_type, dfs_accumulate_vtbl_inits,\n\tbuild_vtbl_initializer): Likewise.\n\t* cp-gimplify.c (genericize_try_block, genericize_catch_block,\n\tgimplify_if_stmt, cp_genericize_r): Likewise.\n\t* cvt.c (convert_to_void): Likewise.\n\t* decl.c (check_initializer, finish_constructor_body,\n\tfinish_destructor_body): Likewise.\n\t* error.c (dump_expr): Likewise.\n\t* except.c (build_exc_ptr, expand_start_catch_block, build_throw):\n\tLikewise.\n\t* init.c (perform_member_init, expand_virtual_init,\n\texpand_cleanup_for_base, build_init, expand_default_init,\n\tbuild_offset_ref, decl_constant_value, build_new, build_new_1,\n\tbuild_vec_delete_1, build_vec_init, build_delete,\n\tpush_base_cleanups, build_vec_delete): Likewise.\n\t* mangle.c (write_integer_cst): Likewise.\n\t* method.c (thunk_adjust, do_build_copy_constructor,\n\tdo_build_assign_ref): Likewise.\n\t* pt.c (lookup_template_function, tsubst, tsubst_copy_and_build,\n\tunify, build_non_dependent_expr): Likewise.\n\t* rtti.c (build_headof, build_typeid, ifnonnull,\n\tbuild_dyanmic_cast_1, tinfo_base_init): Likewise.\n\t* semantics.c (begin_compound_stmt, finish_call_expr,\n\tfinish_pseudo_destructor_expr, finish_id_expression,\n\tsimplify_aggr_init_expr, finalize_nrv_r): Likewise.\n\t* tree.c (build_target_expr, build_cplus_new, array_type_nelts_top,\n\tarray_type_nelts_total, stabilize_call): Likewise.\n\t* typeck.c (decay_conversion, build_class_member_access_expr,\n\tlookup_destructor, build_ptrmemfunc_access_expr, build_array_ref,\n\tget_member_function_from_ptrfunc, build_binary_op, pointer_diff,\n\tbuild_x_unary_op, build_unary_op, unary_complex_lvalue,\n\tbuild_compound_expr, build_modify_expr, expand_ptrmemfunc_cst,\n\tcheck_return_expr): Likewise.\n\t* typeck2.c (split_nonconstant_1, split_nonconstant_init_1,\n\tsplit_nonconstant_init, store_init_value, build_m_component_ref):\n\tLikewise.\n\nFrom-SVN: r86047", "tree": {"sha": "2cc9c5f5db376044b0b84f95ff1c9d2adfb3e6ed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2cc9c5f5db376044b0b84f95ff1c9d2adfb3e6ed"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f293ce4b0d14fc523cac7df7169726e5dadaa329", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f293ce4b0d14fc523cac7df7169726e5dadaa329", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f293ce4b0d14fc523cac7df7169726e5dadaa329", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f293ce4b0d14fc523cac7df7169726e5dadaa329/comments", "author": null, "committer": null, "parents": [{"sha": "ac41c41d4664b48d0b7f3dd6cd0ef25da17707b6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac41c41d4664b48d0b7f3dd6cd0ef25da17707b6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ac41c41d4664b48d0b7f3dd6cd0ef25da17707b6"}], "stats": {"total": 703, "additions": 378, "deletions": 325}, "files": [{"sha": "6e4ec4649498d60cf9b6fa7d5f7552d7310e1db4", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f293ce4b0d14fc523cac7df7169726e5dadaa329/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f293ce4b0d14fc523cac7df7169726e5dadaa329/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=f293ce4b0d14fc523cac7df7169726e5dadaa329", "patch": "@@ -1,3 +1,48 @@\n+2004-08-15  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* call.c (build_vfield_ref, build_call, build_conditional_expr,\n+\tconvert_arg_to_ellipsis, build_x_va_arg, build_over_call,\n+\tbuild_java_interface_fn_ref, build_special_member_call,\n+\tbuild_new_method_call, initialize_reference): Replace calls to\n+\tbuild with calls to buildN.\n+\t* class.c (build_base_path, convert_to_base_statically,\n+\tbuild_vfn_ref, instantiate_type, dfs_accumulate_vtbl_inits,\n+\tbuild_vtbl_initializer): Likewise.\n+\t* cp-gimplify.c (genericize_try_block, genericize_catch_block,\n+\tgimplify_if_stmt, cp_genericize_r): Likewise.\n+\t* cvt.c (convert_to_void): Likewise.\n+\t* decl.c (check_initializer, finish_constructor_body,\n+\tfinish_destructor_body): Likewise.\n+\t* error.c (dump_expr): Likewise.\n+\t* except.c (build_exc_ptr, expand_start_catch_block, build_throw):\n+\tLikewise.\n+\t* init.c (perform_member_init, expand_virtual_init,\n+\texpand_cleanup_for_base, build_init, expand_default_init,\n+\tbuild_offset_ref, decl_constant_value, build_new, build_new_1,\n+\tbuild_vec_delete_1, build_vec_init, build_delete,\n+\tpush_base_cleanups, build_vec_delete): Likewise.\n+\t* mangle.c (write_integer_cst): Likewise.\n+\t* method.c (thunk_adjust, do_build_copy_constructor,\n+\tdo_build_assign_ref): Likewise.\n+\t* pt.c (lookup_template_function, tsubst, tsubst_copy_and_build,\n+\tunify, build_non_dependent_expr): Likewise.\n+\t* rtti.c (build_headof, build_typeid, ifnonnull,\n+\tbuild_dyanmic_cast_1, tinfo_base_init): Likewise.\n+\t* semantics.c (begin_compound_stmt, finish_call_expr,\n+\tfinish_pseudo_destructor_expr, finish_id_expression,\n+\tsimplify_aggr_init_expr, finalize_nrv_r): Likewise.\n+\t* tree.c (build_target_expr, build_cplus_new, array_type_nelts_top,\n+\tarray_type_nelts_total, stabilize_call): Likewise.\n+\t* typeck.c (decay_conversion, build_class_member_access_expr,\n+\tlookup_destructor, build_ptrmemfunc_access_expr, build_array_ref,\n+\tget_member_function_from_ptrfunc, build_binary_op, pointer_diff,\n+\tbuild_x_unary_op, build_unary_op, unary_complex_lvalue,\n+\tbuild_compound_expr, build_modify_expr, expand_ptrmemfunc_cst,\n+\tcheck_return_expr): Likewise.\n+\t* typeck2.c (split_nonconstant_1, split_nonconstant_init_1,\n+\tsplit_nonconstant_init, store_init_value, build_m_component_ref):\n+\tLikewise.\n+\n 2004-08-15  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* call.c (convert_class_to_reference,"}, {"sha": "86f5e6ded364e893efc450ce314ae6967dc54685", "filename": "gcc/cp/call.c", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f293ce4b0d14fc523cac7df7169726e5dadaa329/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f293ce4b0d14fc523cac7df7169726e5dadaa329/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=f293ce4b0d14fc523cac7df7169726e5dadaa329", "patch": "@@ -204,8 +204,8 @@ build_vfield_ref (tree datum, tree type)\n       && !same_type_ignoring_top_level_qualifiers_p (TREE_TYPE (datum), type))\n     datum = convert_to_base (datum, type, /*check_access=*/false);\n \n-  return build (COMPONENT_REF, TREE_TYPE (TYPE_VFIELD (type)),\n-\t\tdatum, TYPE_VFIELD (type), NULL_TREE);\n+  return build3 (COMPONENT_REF, TREE_TYPE (TYPE_VFIELD (type)),\n+\t\t datum, TYPE_VFIELD (type), NULL_TREE);\n }\n \n /* Returns nonzero iff the destructor name specified in NAME\n@@ -343,12 +343,12 @@ build_call (tree function, tree parms)\n       if (is_empty_class (TREE_TYPE (TREE_VALUE (tmp)))\n \t  && ! TREE_ADDRESSABLE (TREE_TYPE (TREE_VALUE (tmp))))\n \t{\n-\t  tree t = build (EMPTY_CLASS_EXPR, TREE_TYPE (TREE_VALUE (tmp)));\n-\t  TREE_VALUE (tmp) = build (COMPOUND_EXPR, TREE_TYPE (t),\n-\t\t\t\t    TREE_VALUE (tmp), t);\n+\t  tree t = build0 (EMPTY_CLASS_EXPR, TREE_TYPE (TREE_VALUE (tmp)));\n+\t  TREE_VALUE (tmp) = build2 (COMPOUND_EXPR, TREE_TYPE (t),\n+\t\t\t\t     TREE_VALUE (tmp), t);\n \t}\n \n-  function = build (CALL_EXPR, result_type, function, parms, NULL_TREE);\n+  function = build3 (CALL_EXPR, result_type, function, parms, NULL_TREE);\n   TREE_HAS_CONSTRUCTOR (function) = is_constructor;\n   TREE_NOTHROW (function) = nothrow;\n   \n@@ -3463,7 +3463,7 @@ build_conditional_expr (tree arg1, tree arg2, tree arg3)\n     }\n \n  valid_operands:\n-  result = fold (build (COND_EXPR, result_type, arg1, arg2, arg3));\n+  result = fold (build3 (COND_EXPR, result_type, arg1, arg2, arg3));\n   /* We can't use result_type below, as fold might have returned a\n      throw_expr.  */\n \n@@ -4401,8 +4401,8 @@ convert_arg_to_ellipsis (tree arg)\n \twarning (\"cannot pass objects of non-POD type `%#T' through `...'; \"\n \t         \"call will abort at runtime\", TREE_TYPE (arg));\n       arg = call_builtin_trap ();\n-      arg = build (COMPOUND_EXPR, integer_type_node, arg,\n-\t\t   integer_zero_node);\n+      arg = build2 (COMPOUND_EXPR, integer_type_node, arg,\n+\t\t    integer_zero_node);\n     }\n \n   return arg;\n@@ -4428,8 +4428,8 @@ build_x_va_arg (tree expr, tree type)\n call will abort at runtime\",\n \t       type);\n       expr = convert (build_pointer_type (type), null_node);\n-      expr = build (COMPOUND_EXPR, TREE_TYPE (expr),\n-\t\t    call_builtin_trap (), expr);\n+      expr = build2 (COMPOUND_EXPR, TREE_TYPE (expr),\n+\t\t     call_builtin_trap (), expr);\n       expr = build_indirect_ref (expr, NULL);\n       return expr;\n     }\n@@ -4591,7 +4591,7 @@ build_over_call (struct z_candidate *cand, int flags)\n       tree expr;\n       tree return_type;\n       return_type = TREE_TYPE (TREE_TYPE (fn));\n-      expr = build (CALL_EXPR, return_type, fn, args, NULL_TREE);\n+      expr = build3 (CALL_EXPR, return_type, fn, args, NULL_TREE);\n       if (TREE_THIS_VOLATILE (fn) && cfun)\n \tcurrent_function_returns_abnormally = 1;\n       if (!VOID_TYPE_P (return_type))\n@@ -4803,7 +4803,7 @@ build_over_call (struct z_candidate *cand, int flags)\n \t  tree to = stabilize_reference\n \t    (build_indirect_ref (TREE_VALUE (args), 0));\n \n-\t  val = build (INIT_EXPR, DECL_CONTEXT (fn), to, arg);\n+\t  val = build2 (INIT_EXPR, DECL_CONTEXT (fn), to, arg);\n \t  return val;\n \t}\n     }\n@@ -4820,7 +4820,7 @@ build_over_call (struct z_candidate *cand, int flags)\n       if (tree_int_cst_equal (TYPE_SIZE (type), TYPE_SIZE (as_base)))\n \t{\n \t  arg = build_indirect_ref (arg, 0);\n-\t  val = build (MODIFY_EXPR, TREE_TYPE (to), to, arg);\n+\t  val = build2 (MODIFY_EXPR, TREE_TYPE (to), to, arg);\n \t}\n       else\n \t{\n@@ -4967,7 +4967,7 @@ build_java_interface_fn_ref (tree fn, tree instance)\n   lookup_fn = build1 (ADDR_EXPR, \n \t\t      build_pointer_type (TREE_TYPE (java_iface_lookup_fn)),\n \t\t      java_iface_lookup_fn);\n-  return build (CALL_EXPR, ptr_type_node, lookup_fn, lookup_args, NULL_TREE);\n+  return build3 (CALL_EXPR, ptr_type_node, lookup_fn, lookup_args, NULL_TREE);\n }\n \n /* Returns the value to use for the in-charge parameter when making a\n@@ -5083,14 +5083,14 @@ build_special_member_call (tree instance, tree name, tree args,\n \t Otherwise, we look it up using the VTT we were given.  */\n       vtt = TREE_CHAIN (CLASSTYPE_VTABLES (current_class_type));\n       vtt = decay_conversion (vtt);\n-      vtt = build (COND_EXPR, TREE_TYPE (vtt),\n-\t\t   build (EQ_EXPR, boolean_type_node,\n-\t\t\t  current_in_charge_parm, integer_zero_node),\n-\t\t   current_vtt_parm,\n-\t\t   vtt);\n+      vtt = build3 (COND_EXPR, TREE_TYPE (vtt),\n+\t\t    build2 (EQ_EXPR, boolean_type_node,\n+\t\t\t    current_in_charge_parm, integer_zero_node),\n+\t\t    current_vtt_parm,\n+\t\t    vtt);\n       my_friendly_assert (BINFO_SUBVTT_INDEX (binfo), 20010110);\n-      sub_vtt = build (PLUS_EXPR, TREE_TYPE (vtt), vtt,\n-\t\t       BINFO_SUBVTT_INDEX (binfo));\n+      sub_vtt = build2 (PLUS_EXPR, TREE_TYPE (vtt), vtt,\n+\t\t\tBINFO_SUBVTT_INDEX (binfo));\n \n       args = tree_cons (NULL_TREE, sub_vtt, args);\n     }\n@@ -5365,8 +5365,8 @@ build_new_method_call (tree instance, tree fns, tree args,\n \t      if (TREE_CODE (TREE_TYPE (cand->fn)) != METHOD_TYPE\n \t\t  && !is_dummy_object (instance_ptr) \n \t\t  && TREE_SIDE_EFFECTS (instance))\n-\t\tcall = build (COMPOUND_EXPR, TREE_TYPE (call), \n-\t\t\t      instance, call);\n+\t\tcall = build2 (COMPOUND_EXPR, TREE_TYPE (call), \n+\t\t\t       instance, call);\n \t    }\n \t}\n     }\n@@ -6488,7 +6488,7 @@ initialize_reference (tree type, tree expr, tree decl, tree *cleanup)\n \t    expr = get_target_expr (expr);\n \t  /* Create the INIT_EXPR that will initialize the temporary\n \t     variable.  */\n-\t  init = build (INIT_EXPR, type, var, expr);\n+\t  init = build2 (INIT_EXPR, type, var, expr);\n \t  if (at_function_scope_p ())\n \t    {\n \t      add_decl_expr (var);\n@@ -6522,7 +6522,7 @@ initialize_reference (tree type, tree expr, tree decl, tree *cleanup)\n \t    }\n \t  /* Use its address to initialize the reference variable.  */\n \t  expr = build_address (var);\n-\t  expr = build (COMPOUND_EXPR, TREE_TYPE (expr), init, expr);\n+\t  expr = build2 (COMPOUND_EXPR, TREE_TYPE (expr), init, expr);\n \t}\n       else\n \t/* Take the address of EXPR.  */"}, {"sha": "7c16791d25851bcc42b63ffaa0d1be097173ff8d", "filename": "gcc/cp/class.c", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f293ce4b0d14fc523cac7df7169726e5dadaa329/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f293ce4b0d14fc523cac7df7169726e5dadaa329/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=f293ce4b0d14fc523cac7df7169726e5dadaa329", "patch": "@@ -343,16 +343,16 @@ build_base_path (enum tree_code code,\n \t  t = TREE_TYPE (TYPE_VFIELD (BINFO_TYPE (derived)));\n \t  t = build_pointer_type (t);\n \t  v_offset = convert (t, current_vtt_parm);\n-\t  v_offset = build (PLUS_EXPR, t, v_offset,\n-\t\t\t    BINFO_VPTR_INDEX (derived));\n+\t  v_offset = build2 (PLUS_EXPR, t, v_offset,\n+\t\t\t     BINFO_VPTR_INDEX (derived));\n \t  v_offset = build_indirect_ref (v_offset, NULL);\n \t}\n       else\n \tv_offset = build_vfield_ref (build_indirect_ref (expr, NULL),\n \t\t\t\t     TREE_TYPE (TREE_TYPE (expr)));\n       \n-      v_offset = build (PLUS_EXPR, TREE_TYPE (v_offset),\n-\t\t\tv_offset,  BINFO_VPTR_FIELD (v_binfo));\n+      v_offset = build2 (PLUS_EXPR, TREE_TYPE (v_offset),\n+\t\t\t v_offset,  BINFO_VPTR_FIELD (v_binfo));\n       v_offset = build1 (NOP_EXPR, \n \t\t\t build_pointer_type (ptrdiff_type_node),\n \t\t\t v_offset);\n@@ -365,17 +365,17 @@ build_base_path (enum tree_code code,\n \t\t\t\t\t\tBINFO_OFFSET (v_binfo)));\n \n       if (!integer_zerop (offset))\n-\tv_offset = build (code, ptrdiff_type_node, v_offset, offset);\n+\tv_offset = build2 (code, ptrdiff_type_node, v_offset, offset);\n \n       if (fixed_type_p < 0)\n \t/* Negative fixed_type_p means this is a constructor or destructor;\n \t   virtual base layout is fixed in in-charge [cd]tors, but not in\n \t   base [cd]tors.  */\n-\toffset = build (COND_EXPR, ptrdiff_type_node,\n-\t\t\tbuild (EQ_EXPR, boolean_type_node,\n-\t\t\t       current_in_charge_parm, integer_zero_node),\n-\t\t\tv_offset,\n-\t\t\tBINFO_OFFSET (binfo));\n+\toffset = build3 (COND_EXPR, ptrdiff_type_node,\n+\t\t\t build2 (EQ_EXPR, boolean_type_node,\n+\t\t\t\t current_in_charge_parm, integer_zero_node),\n+\t\t\t v_offset,\n+\t\t\t BINFO_OFFSET (binfo));\n       else\n \toffset = v_offset;\n     }\n@@ -391,7 +391,7 @@ build_base_path (enum tree_code code,\n   expr = build1 (NOP_EXPR, ptr_target_type, expr);\n \n   if (!integer_zerop (offset))\n-    expr = build (code, ptr_target_type, expr, offset);\n+    expr = build2 (code, ptr_target_type, expr, offset);\n   else\n     null_test = NULL;\n   \n@@ -484,8 +484,8 @@ convert_to_base_statically (tree expr, tree base)\n       pointer_type = build_pointer_type (expr_type);\n       expr = build_unary_op (ADDR_EXPR, expr, /*noconvert=*/1);\n       if (!integer_zerop (BINFO_OFFSET (base)))\n-\t  expr = build (PLUS_EXPR, pointer_type, expr, \n-\t\t\tbuild_nop (pointer_type, BINFO_OFFSET (base)));\n+\t  expr = build2 (PLUS_EXPR, pointer_type, expr, \n+\t\t\t build_nop (pointer_type, BINFO_OFFSET (base)));\n       expr = build_nop (build_pointer_type (BINFO_TYPE (base)), expr);\n       expr = build1 (INDIRECT_REF, BINFO_TYPE (base), expr);\n     }\n@@ -558,7 +558,7 @@ build_vfn_ref (tree instance_ptr, tree idx)\n \t\t   build_unary_op (ADDR_EXPR, aref, /*noconvert=*/1));\n \n   /* Remember this as a method reference, for later devirtualization.  */\n-  aref = build (OBJ_TYPE_REF, TREE_TYPE (aref), aref, instance_ptr, idx);\n+  aref = build3 (OBJ_TYPE_REF, TREE_TYPE (aref), aref, instance_ptr, idx);\n \n   return aref;\n }\n@@ -6021,8 +6021,8 @@ instantiate_type (tree lhstype, tree rhs, tsubst_flags_t flags)\n \tif (addr != error_mark_node\n \t    && TREE_SIDE_EFFECTS (TREE_OPERAND (rhs, 0)))\n \t  /* Do not lose object's side effects.  */\n-\t  addr = build (COMPOUND_EXPR, TREE_TYPE (addr),\n-\t\t\tTREE_OPERAND (rhs, 0), addr);\n+\t  addr = build2 (COMPOUND_EXPR, TREE_TYPE (addr),\n+\t\t\t TREE_OPERAND (rhs, 0), addr);\n \treturn addr;\n       }\n \n@@ -7214,7 +7214,7 @@ dfs_accumulate_vtbl_inits (tree binfo,\n       index = size_binop (MULT_EXPR,\n \t\t\t  TYPE_SIZE_UNIT (vtable_entry_type),\n \t\t\t  index);\n-      vtbl = build (PLUS_EXPR, TREE_TYPE (vtbl), vtbl, index);\n+      vtbl = build2 (PLUS_EXPR, TREE_TYPE (vtbl), vtbl, index);\n     }\n \n   if (ctor_vtbl_p)\n@@ -7402,9 +7402,9 @@ build_vtbl_initializer (tree binfo,\n \t  else\n \t    for (i = 0; i < TARGET_VTABLE_USES_DESCRIPTORS; ++i)\n \t      {\n-\t\ttree fdesc = build (FDESC_EXPR, vfunc_ptr_type_node,\n-\t\t\t\t    TREE_OPERAND (init, 0),\n-\t\t\t\t    build_int_cst (NULL_TREE, i, 0));\n+\t\ttree fdesc = build2 (FDESC_EXPR, vfunc_ptr_type_node,\n+\t\t\t\t     TREE_OPERAND (init, 0),\n+\t\t\t\t     build_int_cst (NULL_TREE, i, 0));\n \t\tTREE_CONSTANT (fdesc) = 1;\n \t\tTREE_INVARIANT (fdesc) = 1;\n "}, {"sha": "e066f7b0f0b044f0784306a54e0299109f87ec2c", "filename": "gcc/cp/cp-gimplify.c", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f293ce4b0d14fc523cac7df7169726e5dadaa329/gcc%2Fcp%2Fcp-gimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f293ce4b0d14fc523cac7df7169726e5dadaa329/gcc%2Fcp%2Fcp-gimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-gimplify.c?ref=f293ce4b0d14fc523cac7df7169726e5dadaa329", "patch": "@@ -46,7 +46,7 @@ genericize_try_block (tree *stmt_p)\n   else\n     gimplify_stmt (&cleanup);\n \n-  *stmt_p = build (TRY_CATCH_EXPR, void_type_node, body, cleanup);\n+  *stmt_p = build2 (TRY_CATCH_EXPR, void_type_node, body, cleanup);\n }\n \n /* Genericize a HANDLER by converting to a CATCH_EXPR.  */\n@@ -60,7 +60,7 @@ genericize_catch_block (tree *stmt_p)\n   gimplify_stmt (&body);\n \n   /* FIXME should the caught type go in TREE_TYPE?  */\n-  *stmt_p = build (CATCH_EXPR, void_type_node, type, body);\n+  *stmt_p = build2 (CATCH_EXPR, void_type_node, type, body);\n }\n \n /* Genericize an EH_SPEC_BLOCK by converting it to a\n@@ -95,7 +95,7 @@ gimplify_if_stmt (tree *stmt_p)\n   if (!else_)\n     else_ = build_empty_stmt ();\n \n-  stmt = build (COND_EXPR, void_type_node, IF_COND (stmt), then_, else_);\n+  stmt = build3 (COND_EXPR, void_type_node, IF_COND (stmt), then_, else_);\n   *stmt_p = stmt;\n }\n \n@@ -310,8 +310,11 @@ cp_genericize_r (tree *stmt_p, int *walk_subtrees, void *data)\n      to lower this construct before scanning it, so we need to lower these\n      before doing anything else.  */\n   else if (TREE_CODE (stmt) == CLEANUP_STMT)\n-    *stmt_p = build (CLEANUP_EH_ONLY (stmt) ? TRY_CATCH_EXPR : TRY_FINALLY_EXPR,\n-\t\t     void_type_node, CLEANUP_BODY (stmt), CLEANUP_EXPR (stmt));\n+    *stmt_p = build2 (CLEANUP_EH_ONLY (stmt) ? TRY_CATCH_EXPR\n+\t\t\t\t\t     : TRY_FINALLY_EXPR,\n+\t\t      void_type_node,\n+\t\t      CLEANUP_BODY (stmt),\n+\t\t      CLEANUP_EXPR (stmt));\n \n   *slot = *stmt_p;\n   return NULL;"}, {"sha": "5a6584d1de9c43b849aa672e3880920431fea071", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f293ce4b0d14fc523cac7df7169726e5dadaa329/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f293ce4b0d14fc523cac7df7169726e5dadaa329/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=f293ce4b0d14fc523cac7df7169726e5dadaa329", "patch": "@@ -804,8 +804,8 @@ convert_to_void (tree expr, const char *implicit)\n \t  (op2, (implicit && !TREE_SIDE_EFFECTS (op1)\n \t\t ? \"third operand of conditional\" : NULL));\n         \n-\texpr = build (COND_EXPR, TREE_TYPE (new_op1),\n-\t\t      TREE_OPERAND (expr, 0), new_op1, new_op2);\n+\texpr = build3 (COND_EXPR, TREE_TYPE (new_op1),\n+\t\t       TREE_OPERAND (expr, 0), new_op1, new_op2);\n         break;\n       }\n     \n@@ -819,8 +819,8 @@ convert_to_void (tree expr, const char *implicit)\n         \n         if (new_op1 != op1)\n \t  {\n-\t    tree t = build (COMPOUND_EXPR, TREE_TYPE (new_op1),\n-\t\t\t    TREE_OPERAND (expr, 0), new_op1);\n+\t    tree t = build2 (COMPOUND_EXPR, TREE_TYPE (new_op1),\n+\t\t\t     TREE_OPERAND (expr, 0), new_op1);\n \t    expr = t;\n \t  }\n "}, {"sha": "a4856a9cfaff5cdf90a735b0b128c187b30c0a6c", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f293ce4b0d14fc523cac7df7169726e5dadaa329/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f293ce4b0d14fc523cac7df7169726e5dadaa329/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=f293ce4b0d14fc523cac7df7169726e5dadaa329", "patch": "@@ -4497,7 +4497,7 @@ check_initializer (tree decl, tree init, int flags, tree *cleanup)\n     check_for_uninitialized_const_var (decl);\n \n   if (init && init != error_mark_node)\n-    init_code = build (INIT_EXPR, type, decl, init);\n+    init_code = build2 (INIT_EXPR, type, decl, init);\n \n   return init_code;\n }\n@@ -10076,8 +10076,8 @@ finish_constructor_body (void)\n       add_stmt (build_stmt (LABEL_EXPR, cdtor_label));\n \n       val = DECL_ARGUMENTS (current_function_decl);\n-      val = build (MODIFY_EXPR, TREE_TYPE (val),\n-\t\t   DECL_RESULT (current_function_decl), val);\n+      val = build2 (MODIFY_EXPR, TREE_TYPE (val),\n+\t\t    DECL_RESULT (current_function_decl), val);\n       /* Return the address of the object.  */\n       exprstmt = build_stmt (RETURN_EXPR, val);\n       add_stmt (exprstmt);\n@@ -10160,9 +10160,9 @@ finish_destructor_body (void)\n \t /*global_p=*/false, NULL_TREE);\n \n       if_stmt = begin_if_stmt ();\n-      finish_if_stmt_cond (build (BIT_AND_EXPR, integer_type_node,\n-\t\t\t\t  current_in_charge_parm,\n-\t\t\t\t  integer_one_node),\n+      finish_if_stmt_cond (build2 (BIT_AND_EXPR, integer_type_node,\n+\t\t\t\t   current_in_charge_parm,\n+\t\t\t\t   integer_one_node),\n \t\t\t   if_stmt);\n       finish_expr_stmt (exprstmt);\n       finish_then_clause (if_stmt);\n@@ -10174,8 +10174,8 @@ finish_destructor_body (void)\n       tree val;\n \n       val = DECL_ARGUMENTS (current_function_decl);\n-      val = build (MODIFY_EXPR, TREE_TYPE (val),\n-\t\t   DECL_RESULT (current_function_decl), val);\n+      val = build2 (MODIFY_EXPR, TREE_TYPE (val),\n+\t\t    DECL_RESULT (current_function_decl), val);\n       /* Return the address of the object.  */\n       exprstmt = build_stmt (RETURN_EXPR, val);\n       add_stmt (exprstmt);"}, {"sha": "7814b6838819ff417894d23d3f77776059e63248", "filename": "gcc/cp/error.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f293ce4b0d14fc523cac7df7169726e5dadaa329/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f293ce4b0d14fc523cac7df7169726e5dadaa329/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=f293ce4b0d14fc523cac7df7169726e5dadaa329", "patch": "@@ -1402,9 +1402,9 @@ dump_expr (tree t, int flags)\n \tif (TREE_CODE (type) == ARRAY_REF)\n \t  type = build_cplus_array_type\n \t    (TREE_OPERAND (type, 0),\n-\t     build_index_type (fold (build (MINUS_EXPR, integer_type_node,\n-\t\t\t\t\t    TREE_OPERAND (type, 1),\n-\t\t\t\t\t    integer_one_node))));\n+\t     build_index_type (fold (build2 (MINUS_EXPR, integer_type_node,\n+\t\t\t\t\t     TREE_OPERAND (type, 1),\n+\t\t\t\t\t     integer_one_node))));\n \tdump_type (type, flags);\n \tif (init)\n \t  {"}, {"sha": "e572aa7128bde350170f14a693f809f4b12e92e4", "filename": "gcc/cp/except.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f293ce4b0d14fc523cac7df7169726e5dadaa329/gcc%2Fcp%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f293ce4b0d14fc523cac7df7169726e5dadaa329/gcc%2Fcp%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.c?ref=f293ce4b0d14fc523cac7df7169726e5dadaa329", "patch": "@@ -150,7 +150,7 @@ build_eh_type_type (tree type)\n tree\n build_exc_ptr (void)\n {\n-  return build (EXC_PTR_EXPR, ptr_type_node);\n+  return build0 (EXC_PTR_EXPR, ptr_type_node);\n }\n \n /* Build up a call to __cxa_begin_catch, to tell the runtime that the\n@@ -407,8 +407,8 @@ expand_start_catch_block (tree decl)\n \t     generic exception header.  */\n \t  init = build_exc_ptr ();\n \t  init = build1 (NOP_EXPR, build_pointer_type (type), init);\n-\t  init = build (MINUS_EXPR, TREE_TYPE (init), init,\n-\t\t\tTYPE_SIZE_UNIT (TREE_TYPE (init)));\n+\t  init = build2 (MINUS_EXPR, TREE_TYPE (init), init,\n+\t\t\t TYPE_SIZE_UNIT (TREE_TYPE (init)));\n \t  init = build_indirect_ref (init, NULL);\n \t  is_java = true;\n \t}\n@@ -689,13 +689,13 @@ build_throw (tree exp)\n       stabilize_init (exp, &temp_expr);\n \n       if (elided)\n-\texp = build (TRY_CATCH_EXPR, void_type_node, exp,\n-\t\t     do_free_exception (ptr));\n+\texp = build2 (TRY_CATCH_EXPR, void_type_node, exp,\n+\t\t      do_free_exception (ptr));\n       else\n \texp = build1 (MUST_NOT_THROW_EXPR, void_type_node, exp);\n \n       /* Prepend the allocation.  */\n-      exp = build (COMPOUND_EXPR, TREE_TYPE (exp), allocate_expr, exp);\n+      exp = build2 (COMPOUND_EXPR, TREE_TYPE (exp), allocate_expr, exp);\n       if (temp_expr)\n \t{\n \t  /* Prepend the calculation of the throw expression.  Also, force\n@@ -704,7 +704,7 @@ build_throw (tree exp)\n \t     them in MUST_NOT_THROW_EXPR, since they are run after the\n \t     exception object is initialized.  */\n \t  walk_tree_without_duplicates (&temp_expr, wrap_cleanups_r, 0);\n-\t  exp = build (COMPOUND_EXPR, TREE_TYPE (exp), temp_expr, exp);\n+\t  exp = build2 (COMPOUND_EXPR, TREE_TYPE (exp), temp_expr, exp);\n \t  exp = build1 (CLEANUP_POINT_EXPR, TREE_TYPE (exp), exp);\n \t}\n \n@@ -730,7 +730,7 @@ build_throw (tree exp)\n       tmp = build_function_call (fn, tmp);\n \n       /* Tack on the initialization stuff.  */\n-      exp = build (COMPOUND_EXPR, TREE_TYPE (tmp), exp, tmp);\n+      exp = build2 (COMPOUND_EXPR, TREE_TYPE (tmp), exp, tmp);\n     }\n   else\n     {"}, {"sha": "3263f6e9b752551747071117afffcaf53132fca0", "filename": "gcc/cp/init.c", "status": "modified", "additions": 87, "deletions": 86, "changes": 173, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f293ce4b0d14fc523cac7df7169726e5dadaa329/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f293ce4b0d14fc523cac7df7169726e5dadaa329/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=f293ce4b0d14fc523cac7df7169726e5dadaa329", "patch": "@@ -339,7 +339,7 @@ perform_member_init (tree member, tree init)\n     {\n       if (init)\n \t{\n-\t  init = build (INIT_EXPR, type, decl, TREE_VALUE (init));\n+\t  init = build2 (INIT_EXPR, type, decl, TREE_VALUE (init));\n \t  finish_expr_stmt (init);\n \t}\n     }\n@@ -766,22 +766,22 @@ expand_virtual_init (tree binfo, tree decl)\n \n       /* Compute the value to use, when there's a VTT.  */\n       vtt_parm = current_vtt_parm;\n-      vtbl2 = build (PLUS_EXPR, \n-\t\t     TREE_TYPE (vtt_parm), \n-\t\t     vtt_parm,\n-\t\t     vtt_index);\n+      vtbl2 = build2 (PLUS_EXPR, \n+\t\t      TREE_TYPE (vtt_parm), \n+\t\t      vtt_parm,\n+\t\t      vtt_index);\n       vtbl2 = build_indirect_ref (vtbl2, NULL);\n       vtbl2 = convert (TREE_TYPE (vtbl), vtbl2);\n \n       /* The actual initializer is the VTT value only in the subobject\n \t constructor.  In maybe_clone_body we'll substitute NULL for\n \t the vtt_parm in the case of the non-subobject constructor.  */\n-      vtbl = build (COND_EXPR, \n-\t\t    TREE_TYPE (vtbl), \n-\t\t    build (EQ_EXPR, boolean_type_node,\n-\t\t\t   current_in_charge_parm, integer_zero_node),\n-\t\t    vtbl2, \n-\t\t    vtbl);\n+      vtbl = build3 (COND_EXPR, \n+\t\t     TREE_TYPE (vtbl), \n+\t\t     build2 (EQ_EXPR, boolean_type_node,\n+\t\t\t     current_in_charge_parm, integer_zero_node),\n+\t\t     vtbl2, \n+\t\t     vtbl);\n     }\n \n   /* Compute the location of the vtpr.  */\n@@ -815,9 +815,9 @@ expand_cleanup_for_base (tree binfo, tree flag)\n \t\t\t\t    binfo,\n \t\t\t\t    LOOKUP_NORMAL | LOOKUP_NONVIRTUAL);\n   if (flag)\n-    expr = fold (build (COND_EXPR, void_type_node,\n-\t\t\tc_common_truthvalue_conversion (flag),\n-\t\t\texpr, integer_zero_node));\n+    expr = fold (build3 (COND_EXPR, void_type_node,\n+\t\t\t c_common_truthvalue_conversion (flag),\n+\t\t\t expr, integer_zero_node));\n \n   finish_eh_cleanup (expr);\n }\n@@ -1144,7 +1144,7 @@ build_init (tree decl, tree init, int flags)\n \t\t\t\t      TREE_TYPE (decl),\n \t\t\t\t      LOOKUP_NORMAL|flags);\n   else\n-    expr = build (INIT_EXPR, TREE_TYPE (decl), decl, init);\n+    expr = build2 (INIT_EXPR, TREE_TYPE (decl), decl, init);\n \n   return expr;\n }\n@@ -1192,12 +1192,12 @@ expand_default_init (tree binfo, tree true_exp, tree exp, tree init, int flags)\n \t   around the TARGET_EXPR for the copy constructor.  See\n \t   initialize_handler_parm.  */\n \t{\n-\t  TREE_OPERAND (init, 0) = build (INIT_EXPR, TREE_TYPE (exp), exp,\n-\t\t\t\t\t  TREE_OPERAND (init, 0));\n+\t  TREE_OPERAND (init, 0) = build2 (INIT_EXPR, TREE_TYPE (exp), exp,\n+\t\t\t\t\t   TREE_OPERAND (init, 0));\n \t  TREE_TYPE (init) = void_type_node;\n \t}\n       else\n-\tinit = build (INIT_EXPR, TREE_TYPE (exp), exp, init);\n+\tinit = build2 (INIT_EXPR, TREE_TYPE (exp), exp, init);\n       TREE_SIDE_EFFECTS (init) = 1;\n       finish_expr_stmt (init);\n       return;\n@@ -1365,8 +1365,8 @@ build_offset_ref (tree type, tree name, bool address_p)\n         return t;\n       if (TREE_CODE (orig_name) == TEMPLATE_ID_EXPR)\n         /* Reconstruct the TEMPLATE_ID_EXPR.  */\n-        t = build (TEMPLATE_ID_EXPR, TREE_TYPE (t),\n-                   t, TREE_OPERAND (orig_name, 1));\n+\tt = build2 (TEMPLATE_ID_EXPR, TREE_TYPE (t),\n+\t\t    t, TREE_OPERAND (orig_name, 1));\n       if (! type_unknown_p (t))\n \t{\n \t  mark_used (t);\n@@ -1461,9 +1461,9 @@ build_offset_ref (tree type, tree name, bool address_p)\n \t       expects to encounter OVERLOADs, not raw functions.  */\n \t    t = ovl_cons (t, NULL_TREE);\n \n-          t = build (TEMPLATE_ID_EXPR, TREE_TYPE (t), t,\n-\t             TREE_OPERAND (orig_name, 1));\n-\t  t = build (OFFSET_REF, unknown_type_node, decl, t);\n+          t = build2 (TEMPLATE_ID_EXPR, TREE_TYPE (t), t,\n+\t\t      TREE_OPERAND (orig_name, 1));\n+\t  t = build2 (OFFSET_REF, unknown_type_node, decl, t);\n           \n           PTRMEM_OK_P (t) = 1;\n           \t  \n@@ -1530,7 +1530,7 @@ build_offset_ref (tree type, tree name, bool address_p)\n \t  /* Build a representation of a the qualified name suitable\n \t     for use as the operand to \"&\" -- even though the \"&\" is\n \t     not actually present.  */\n-\t  member = build (OFFSET_REF, TREE_TYPE (member), decl, member);\n+\t  member = build2 (OFFSET_REF, TREE_TYPE (member), decl, member);\n \t  /* In Microsoft mode, treat a non-static member function as if\n \t     it were a pointer-to-member.  */\n \t  if (flag_ms_extensions)\n@@ -1553,7 +1553,7 @@ build_offset_ref (tree type, tree name, bool address_p)\n   /* In member functions, the form `type::name' is no longer\n      equivalent to `this->type::name', at least not until\n      resolve_offset_ref.  */\n-  member = build (OFFSET_REF, TREE_TYPE (member), decl, member);\n+  member = build2 (OFFSET_REF, TREE_TYPE (member), decl, member);\n   PTRMEM_OK_P (member) = 1;\n   return member;\n }\n@@ -1577,9 +1577,9 @@ decl_constant_value (tree decl)\n       d2 = decl_constant_value (TREE_OPERAND (decl, 2));\n \n       if (d1 != TREE_OPERAND (decl, 1) || d2 != TREE_OPERAND (decl, 2))\n-\treturn build (COND_EXPR,\n-\t\t      TREE_TYPE (decl),\n-\t\t      TREE_OPERAND (decl, 0), d1, d2);\n+\treturn build3 (COND_EXPR,\n+\t\t       TREE_TYPE (decl),\n+\t\t       TREE_OPERAND (decl, 0), d1, d2);\n     }\n \n   if (DECL_P (decl)\n@@ -1671,8 +1671,8 @@ build_new (tree placement, tree type, tree nelts, tree init,\n       return error_mark_node;\n     }\n \n-  rval = build (NEW_EXPR, build_pointer_type (type), placement, type,\n-\t\tnelts, init);\n+  rval = build4 (NEW_EXPR, build_pointer_type (type), placement, type,\n+\t\t nelts, init);\n   NEW_EXPR_USE_GLOBAL (rval) = use_global_new;\n   TREE_SIDE_EFFECTS (rval) = 1;\n   rval = build_new_1 (rval);\n@@ -1976,8 +1976,8 @@ build_new_1 (tree exp)\n       tree inits;\n       stabilize_call (alloc_call, &inits);\n       if (inits)\n-\talloc_expr = build (COMPOUND_EXPR, TREE_TYPE (alloc_expr), inits,\n-\t\t\t    alloc_expr);\n+\talloc_expr = build2 (COMPOUND_EXPR, TREE_TYPE (alloc_expr), inits,\n+\t\t\t     alloc_expr);\n     }\n \n   /*        unless an allocation function is declared with an empty  excep-\n@@ -1999,28 +1999,28 @@ build_new_1 (tree exp)\n       tree cookie_ptr;\n \n       /* Adjust so we're pointing to the start of the object.  */\n-      data_addr = get_target_expr (build (PLUS_EXPR, full_pointer_type,\n-\t\t\t\t\t  alloc_node, cookie_size));\n+      data_addr = get_target_expr (build2 (PLUS_EXPR, full_pointer_type,\n+\t\t\t\t\t   alloc_node, cookie_size));\n \n       /* Store the number of bytes allocated so that we can know how\n \t many elements to destroy later.  We use the last sizeof\n \t (size_t) bytes to store the number of elements.  */\n-      cookie_ptr = build (MINUS_EXPR, build_pointer_type (sizetype),\n-\t\t      data_addr, size_in_bytes (sizetype));\n+      cookie_ptr = build2 (MINUS_EXPR, build_pointer_type (sizetype),\n+\t\t\t   data_addr, size_in_bytes (sizetype));\n       cookie = build_indirect_ref (cookie_ptr, NULL);\n \n-      cookie_expr = build (MODIFY_EXPR, sizetype, cookie, nelts);\n+      cookie_expr = build2 (MODIFY_EXPR, sizetype, cookie, nelts);\n \n       if (targetm.cxx.cookie_has_size ())\n \t{\n \t  /* Also store the element size.  */\n-\t  cookie_ptr = build (MINUS_EXPR, build_pointer_type (sizetype),\n-\t\t\t      cookie_ptr, size_in_bytes (sizetype));\n+\t  cookie_ptr = build2 (MINUS_EXPR, build_pointer_type (sizetype),\n+\t\t\t       cookie_ptr, size_in_bytes (sizetype));\n \t  cookie = build_indirect_ref (cookie_ptr, NULL);\n-\t  cookie = build (MODIFY_EXPR, sizetype, cookie,\n-\t\t\t  size_in_bytes(true_type));\n-\t  cookie_expr = build (COMPOUND_EXPR, TREE_TYPE (cookie_expr),\n-\t\t\t       cookie, cookie_expr);\n+\t  cookie = build2 (MODIFY_EXPR, sizetype, cookie,\n+\t\t\t   size_in_bytes(true_type));\n+\t  cookie_expr = build2 (COMPOUND_EXPR, TREE_TYPE (cookie_expr),\n+\t\t\t\tcookie, cookie_expr);\n \t}\n       data_addr = TARGET_EXPR_SLOT (data_addr);\n     }\n@@ -2112,8 +2112,8 @@ build_new_1 (tree exp)\n \t  else if (stable)\n \t    /* This is much simpler if we were able to preevaluate all of\n \t       the arguments to the constructor call.  */\n-\t    init_expr = build (TRY_CATCH_EXPR, void_type_node,\n-\t\t\t       init_expr, cleanup);\n+\t    init_expr = build2 (TRY_CATCH_EXPR, void_type_node,\n+\t\t\t\tinit_expr, cleanup);\n \t  else\n \t    /* Ack!  First we allocate the memory.  Then we set our sentry\n \t       variable to true, and expand a cleanup that deletes the\n@@ -2134,16 +2134,16 @@ build_new_1 (tree exp)\n \t      sentry = TARGET_EXPR_SLOT (begin);\n \n \t      TARGET_EXPR_CLEANUP (begin)\n-\t\t= build (COND_EXPR, void_type_node, sentry,\n-\t\t\t cleanup, void_zero_node);\n+\t\t= build3 (COND_EXPR, void_type_node, sentry,\n+\t\t\t  cleanup, void_zero_node);\n \n-\t      end = build (MODIFY_EXPR, TREE_TYPE (sentry),\n-\t\t\t   sentry, boolean_false_node);\n+\t      end = build2 (MODIFY_EXPR, TREE_TYPE (sentry),\n+\t\t\t    sentry, boolean_false_node);\n \n \t      init_expr\n-\t\t= build (COMPOUND_EXPR, void_type_node, begin,\n-\t\t\t build (COMPOUND_EXPR, void_type_node, init_expr,\n-\t\t\t\tend));\n+\t\t= build2 (COMPOUND_EXPR, void_type_node, begin,\n+\t\t\t  build2 (COMPOUND_EXPR, void_type_node, init_expr,\n+\t\t\t\t  end));\n \t    }\n \t    \n \t}\n@@ -2156,9 +2156,9 @@ build_new_1 (tree exp)\n   rval = data_addr;\n \n   if (init_expr)\n-    rval = build (COMPOUND_EXPR, TREE_TYPE (rval), init_expr, rval);\n+    rval = build2 (COMPOUND_EXPR, TREE_TYPE (rval), init_expr, rval);\n   if (cookie_expr)\n-    rval = build (COMPOUND_EXPR, TREE_TYPE (rval), cookie_expr, rval);\n+    rval = build2 (COMPOUND_EXPR, TREE_TYPE (rval), cookie_expr, rval);\n \n   if (rval == alloc_node)\n     /* If we don't have an initializer or a cookie, strip the TARGET_EXPR\n@@ -2175,11 +2175,11 @@ build_new_1 (tree exp)\n \n       /* Perform the allocation before anything else, so that ALLOC_NODE\n \t has been initialized before we start using it.  */\n-      rval = build (COMPOUND_EXPR, TREE_TYPE (rval), alloc_expr, rval);\n+      rval = build2 (COMPOUND_EXPR, TREE_TYPE (rval), alloc_expr, rval);\n     }\n \n   if (init_preeval_expr)\n-    rval = build (COMPOUND_EXPR, TREE_TYPE (rval), init_preeval_expr, rval);\n+    rval = build2 (COMPOUND_EXPR, TREE_TYPE (rval), init_preeval_expr, rval);\n \n   /* Convert to the final type.  */\n   rval = build_nop (pointer_type, rval);\n@@ -2231,23 +2231,24 @@ build_vec_delete_1 (tree base, tree maxindex, tree type,\n \n   tbase = create_temporary_var (ptype);\n   tbase_init = build_modify_expr (tbase, NOP_EXPR,\n-\t\t\t\t  fold (build (PLUS_EXPR, ptype,\n-\t\t\t\t\t       base,\n-\t\t\t\t\t       virtual_size)));\n+\t\t\t\t  fold (build2 (PLUS_EXPR, ptype,\n+\t\t\t\t\t\tbase,\n+\t\t\t\t\t\tvirtual_size)));\n   DECL_REGISTER (tbase) = 1;\n-  controller = build (BIND_EXPR, void_type_node, tbase, NULL_TREE, NULL_TREE);\n+  controller = build3 (BIND_EXPR, void_type_node, tbase,\n+\t\t       NULL_TREE, NULL_TREE);\n   TREE_SIDE_EFFECTS (controller) = 1;\n \n-  body = build (EXIT_EXPR, void_type_node,\n-\t\tbuild (EQ_EXPR, boolean_type_node, base, tbase));\n+  body = build1 (EXIT_EXPR, void_type_node,\n+\t\t build2 (EQ_EXPR, boolean_type_node, base, tbase));\n   body = build_compound_expr\n     (body, build_modify_expr (tbase, NOP_EXPR,\n-\t\t\t      build (MINUS_EXPR, ptype, tbase, size_exp)));\n+\t\t\t      build2 (MINUS_EXPR, ptype, tbase, size_exp)));\n   body = build_compound_expr\n     (body, build_delete (ptype, tbase, sfk_complete_destructor,\n \t\t\t LOOKUP_NORMAL|LOOKUP_DESTRUCTOR, 1));\n \n-  loop = build (LOOP_EXPR, void_type_node, body);\n+  loop = build1 (LOOP_EXPR, void_type_node, body);\n   loop = build_compound_expr (tbase_init, loop);\n \n  no_destructor:\n@@ -2297,11 +2298,11 @@ build_vec_delete_1 (tree base, tree maxindex, tree type,\n     body = integer_zero_node;\n   \n   /* Outermost wrapper: If pointer is null, punt.  */\n-  body = fold (build (COND_EXPR, void_type_node,\n-\t\t      fold (build (NE_EXPR, boolean_type_node, base,\n-\t\t\t\t   convert (TREE_TYPE (base),\n-\t\t\t\t\t    integer_zero_node))),\n-\t\t      body, integer_zero_node));\n+  body = fold (build3 (COND_EXPR, void_type_node,\n+\t\t       fold (build2 (NE_EXPR, boolean_type_node, base,\n+\t\t\t\t     convert (TREE_TYPE (base),\n+\t\t\t\t\t      integer_zero_node))),\n+\t\t       body, integer_zero_node));\n   body = build1 (NOP_EXPR, void_type_node, body);\n \n   if (controller)\n@@ -2312,7 +2313,7 @@ build_vec_delete_1 (tree base, tree maxindex, tree type,\n \n   if (TREE_CODE (base) == SAVE_EXPR)\n     /* Pre-evaluate the SAVE_EXPR outside of the BIND_EXPR.  */\n-    body = build (COMPOUND_EXPR, void_type_node, base, body);\n+    body = build2 (COMPOUND_EXPR, void_type_node, base, body);\n \n   return convert_to_void (body, /*implicit=*/NULL);\n }\n@@ -2412,7 +2413,7 @@ build_vec_init (tree base, tree maxindex, tree init, int from_array)\n \t brace-enclosed initializers.  In this case, digest_init and\n \t store_constructor will handle the semantics for us.  */\n \n-      stmt_expr = build (INIT_EXPR, atype, base, init);\n+      stmt_expr = build2 (INIT_EXPR, atype, base, init);\n       return stmt_expr;\n     }\n \n@@ -2538,8 +2539,8 @@ build_vec_init (tree base, tree maxindex, tree init, int from_array)\n \n       for_stmt = begin_for_stmt ();\n       finish_for_init_stmt (for_stmt);\n-      finish_for_cond (build (NE_EXPR, boolean_type_node,\n-\t\t\t      iterator, integer_minus_one_node),\n+      finish_for_cond (build2 (NE_EXPR, boolean_type_node,\n+\t\t\t       iterator, integer_minus_one_node),\n \t\t       for_stmt);\n       finish_for_expr (build_unary_op (PREDECREMENT_EXPR, iterator, 0),\n \t\t       for_stmt);\n@@ -2828,7 +2829,7 @@ build_delete (tree type, tree addr, special_function_kind auto_delete,\n       expr = build_dtor_call (build_indirect_ref (addr, NULL),\n \t\t\t      auto_delete, flags);\n       if (do_delete)\n-\texpr = build (COMPOUND_EXPR, void_type_node, expr, do_delete);\n+\texpr = build2 (COMPOUND_EXPR, void_type_node, expr, do_delete);\n \n       if (flags & LOOKUP_DESTRUCTOR)\n \t/* Explicit destructor call; don't check for null pointer.  */\n@@ -2838,8 +2839,8 @@ build_delete (tree type, tree addr, special_function_kind auto_delete,\n \tifexp = fold (cp_build_binary_op (NE_EXPR, addr, integer_zero_node));\n \n       if (ifexp != integer_one_node)\n-\texpr = build (COND_EXPR, void_type_node,\n-\t\t      ifexp, expr, void_zero_node);\n+\texpr = build3 (COND_EXPR, void_type_node,\n+\t\t       ifexp, expr, void_zero_node);\n \n       return expr;\n     }\n@@ -2863,9 +2864,9 @@ push_base_cleanups (void)\n   if (TYPE_USES_VIRTUAL_BASECLASSES (current_class_type))\n     {\n       tree cond = (condition_conversion\n-\t\t   (build (BIT_AND_EXPR, integer_type_node,\n-\t\t\t   current_in_charge_parm,\n-\t\t\t   integer_two_node)));\n+\t\t   (build2 (BIT_AND_EXPR, integer_type_node,\n+\t\t\t    current_in_charge_parm,\n+\t\t\t    integer_two_node)));\n \n       /* The CLASSTYPE_VBASECLASSES vector is in initialization\n \t order, which is also the right order for pushing cleanups.  */\n@@ -2880,8 +2881,8 @@ push_base_cleanups (void)\n \t\t\t\t\t\tbase_binfo,\n \t\t\t\t\t\t(LOOKUP_NORMAL \n \t\t\t\t\t\t | LOOKUP_NONVIRTUAL));\n-\t      expr = build (COND_EXPR, void_type_node, cond,\n-\t\t\t    expr, void_zero_node);\n+\t      expr = build3 (COND_EXPR, void_type_node, cond,\n+\t\t\t     expr, void_zero_node);\n \t      finish_decl_cleanup (NULL_TREE, expr);\n \t    }\n \t}\n@@ -2988,10 +2989,10 @@ build_vec_delete (tree base, tree maxindex,\n \t  base = TARGET_EXPR_SLOT (base_init);\n \t}\n       type = strip_array_types (TREE_TYPE (type));\n-      cookie_addr = build (MINUS_EXPR,\n-\t\t\t   build_pointer_type (sizetype),\n-\t\t\t   base,\n-\t\t\t   TYPE_SIZE_UNIT (sizetype));\n+      cookie_addr = build2 (MINUS_EXPR,\n+\t\t\t    build_pointer_type (sizetype),\n+\t\t\t    base,\n+\t\t\t    TYPE_SIZE_UNIT (sizetype));\n       maxindex = build_indirect_ref (cookie_addr, NULL);\n     }\n   else if (TREE_CODE (type) == ARRAY_TYPE)\n@@ -3017,7 +3018,7 @@ build_vec_delete (tree base, tree maxindex,\n   rval = build_vec_delete_1 (base, maxindex, type, auto_delete_vec,\n \t\t\t     use_global_delete);\n   if (base_init)\n-    rval = build (COMPOUND_EXPR, TREE_TYPE (rval), base_init, rval);\n+    rval = build2 (COMPOUND_EXPR, TREE_TYPE (rval), base_init, rval);\n \n   return rval;\n }"}, {"sha": "b8feaffce13d66d918435fde1d82493592d9c48d", "filename": "gcc/cp/mangle.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f293ce4b0d14fc523cac7df7169726e5dadaa329/gcc%2Fcp%2Fmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f293ce4b0d14fc523cac7df7169726e5dadaa329/gcc%2Fcp%2Fmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmangle.c?ref=f293ce4b0d14fc523cac7df7169726e5dadaa329", "patch": "@@ -1194,14 +1194,14 @@ write_integer_cst (const tree cst)\n \t}\n       do\n \t{\n-\t  tree d = fold (build (FLOOR_DIV_EXPR, type, n, base));\n-\t  tree tmp = fold (build (MULT_EXPR, type, d, base));\n+\t  tree d = fold (build2 (FLOOR_DIV_EXPR, type, n, base));\n+\t  tree tmp = fold (build2 (MULT_EXPR, type, d, base));\n \t  unsigned c;\n \n \t  done = integer_zerop (d);\n-\t  tmp = fold (build (MINUS_EXPR, type, n, tmp));\n+\t  tmp = fold (build2 (MINUS_EXPR, type, n, tmp));\n \t  c = hwint_to_ascii (TREE_INT_CST_LOW (tmp), 10, ptr,\n-\t\t\t\tdone ? 1 : chunk_digits);\n+\t\t\t      done ? 1 : chunk_digits);\n \t  ptr -= c;\n \t  count += c;\n \t  n = d;"}, {"sha": "13fe0a492aa4bec2af32ac69d2c230fe35519d0f", "filename": "gcc/cp/method.c", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f293ce4b0d14fc523cac7df7169726e5dadaa329/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f293ce4b0d14fc523cac7df7169726e5dadaa329/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=f293ce4b0d14fc523cac7df7169726e5dadaa329", "patch": "@@ -224,8 +224,8 @@ thunk_adjust (tree ptr, bool this_adjusting,\n {\n   if (this_adjusting)\n     /* Adjust the pointer by the constant.  */\n-    ptr = fold (build (PLUS_EXPR, TREE_TYPE (ptr), ptr,\n-\t\t       ssize_int (fixed_offset)));\n+    ptr = fold (build2 (PLUS_EXPR, TREE_TYPE (ptr), ptr,\n+\t\t\tssize_int (fixed_offset)));\n \n   /* If there's a virtual offset, look up that value in the vtable and\n      adjust the pointer again.  */\n@@ -242,17 +242,17 @@ thunk_adjust (tree ptr, bool this_adjusting,\n       /* Form the vtable address.  */\n       vtable = build1 (INDIRECT_REF, TREE_TYPE (TREE_TYPE (vtable)), vtable);\n       /* Find the entry with the vcall offset.  */\n-      vtable = build (PLUS_EXPR, TREE_TYPE (vtable), vtable, virtual_offset);\n+      vtable = build2 (PLUS_EXPR, TREE_TYPE (vtable), vtable, virtual_offset);\n       /* Get the offset itself.  */\n       vtable = build1 (INDIRECT_REF, TREE_TYPE (TREE_TYPE (vtable)), vtable);\n       /* Adjust the `this' pointer.  */\n-      ptr = fold (build (PLUS_EXPR, TREE_TYPE (ptr), ptr, vtable));\n+      ptr = fold (build2 (PLUS_EXPR, TREE_TYPE (ptr), ptr, vtable));\n     }\n   \n   if (!this_adjusting)\n     /* Adjust the pointer by the constant.  */\n-    ptr = fold (build (PLUS_EXPR, TREE_TYPE (ptr), ptr,\n-\t\t       ssize_int (fixed_offset)));\n+    ptr = fold (build2 (PLUS_EXPR, TREE_TYPE (ptr), ptr,\n+\t\t\tssize_int (fixed_offset)));\n \n   return ptr;\n }\n@@ -511,7 +511,7 @@ do_build_copy_constructor (tree fndecl)\n        if *this is a base subobject.  */;\n   else if (TYPE_HAS_TRIVIAL_INIT_REF (current_class_type))\n     {\n-      t = build (INIT_EXPR, void_type_node, current_class_ref, parm);\n+      t = build2 (INIT_EXPR, void_type_node, current_class_ref, parm);\n       finish_expr_stmt (t);\n     }\n   else\n@@ -584,7 +584,7 @@ do_build_copy_constructor (tree fndecl)\n \t  expr_type = TREE_TYPE (field);\n \t  if (TREE_CODE (expr_type) != REFERENCE_TYPE)\n \t    expr_type = cp_build_qualified_type (expr_type, cvquals);\n-\t  init = build (COMPONENT_REF, expr_type, init, field, NULL_TREE);\n+\t  init = build3 (COMPONENT_REF, expr_type, init, field, NULL_TREE);\n \t  init = build_tree_list (NULL_TREE, init);\n \n \t  member_init_list\n@@ -609,7 +609,7 @@ do_build_assign_ref (tree fndecl)\n        if *this is a base subobject.  */;\n   else if (TYPE_HAS_TRIVIAL_ASSIGN_REF (current_class_type))\n     {\n-      tree t = build (MODIFY_EXPR, void_type_node, current_class_ref, parm);\n+      tree t = build2 (MODIFY_EXPR, void_type_node, current_class_ref, parm);\n       finish_expr_stmt (t);\n     }\n   else\n@@ -676,17 +676,17 @@ do_build_assign_ref (tree fndecl)\n \t  else\n \t    continue;\n \n-\t  comp = build (COMPONENT_REF, TREE_TYPE (field), comp, field,\n-\t\t\tNULL_TREE);\n-\t  init = build (COMPONENT_REF,\n-\t                cp_build_qualified_type (TREE_TYPE (field), cvquals),\n-\t                init, field, NULL_TREE);\n+\t  comp = build3 (COMPONENT_REF, TREE_TYPE (field), comp, field,\n+\t\t\t NULL_TREE);\n+\t  init = build3 (COMPONENT_REF,\n+\t\t\t cp_build_qualified_type (TREE_TYPE (field), cvquals),\n+\t\t\t init, field, NULL_TREE);\n \n \t  if (DECL_NAME (field))\n \t    finish_expr_stmt (build_modify_expr (comp, NOP_EXPR, init));\n \t  else\n-\t    finish_expr_stmt (build (MODIFY_EXPR, TREE_TYPE (comp), comp,\n-\t\t\t\t     init));\n+\t    finish_expr_stmt (build2 (MODIFY_EXPR, TREE_TYPE (comp), comp,\n+\t\t\t\t      init));\n \t}\n     }\n   finish_return_stmt (current_class_ref);"}, {"sha": "4590bd7dee2bfe97e5db62e1c5a105178fd764b7", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f293ce4b0d14fc523cac7df7169726e5dadaa329/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f293ce4b0d14fc523cac7df7169726e5dadaa329/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=f293ce4b0d14fc523cac7df7169726e5dadaa329", "patch": "@@ -4147,18 +4147,18 @@ lookup_template_function (tree fns, tree arglist)\n \n   if (BASELINK_P (fns))\n     {\n-      BASELINK_FUNCTIONS (fns) = build (TEMPLATE_ID_EXPR,\n-\t\t\t\t\tunknown_type_node,\n-\t\t\t\t\tBASELINK_FUNCTIONS (fns),\n-\t\t\t\t\targlist);\n+      BASELINK_FUNCTIONS (fns) = build2 (TEMPLATE_ID_EXPR,\n+\t\t\t\t\t unknown_type_node,\n+\t\t\t\t\t BASELINK_FUNCTIONS (fns),\n+\t\t\t\t\t arglist);\n       return fns;\n     }\n \n   type = TREE_TYPE (fns);\n   if (TREE_CODE (fns) == OVERLOAD || !type)\n     type = unknown_type_node;\n   \n-  return build (TEMPLATE_ID_EXPR, type, fns, arglist);\n+  return build2 (TEMPLATE_ID_EXPR, type, fns, arglist);\n }\n \n /* Within the scope of a template class S<T>, the name S gets bound\n@@ -7161,7 +7161,7 @@ tsubst (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \tif (e1 == error_mark_node || e2 == error_mark_node)\n \t  return error_mark_node;\n \n-\treturn fold (build (TREE_CODE (t), TREE_TYPE (t), e1, e2));\n+\treturn fold (build2 (TREE_CODE (t), TREE_TYPE (t), e1, e2));\n       }\n \n     case NEGATE_EXPR:\n@@ -7171,7 +7171,7 @@ tsubst (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \tif (e == error_mark_node)\n \t  return error_mark_node;\n \n-\treturn fold (build (TREE_CODE (t), TREE_TYPE (t), e));\n+\treturn fold (build1 (TREE_CODE (t), TREE_TYPE (t), e));\n       }\n \n     case TYPENAME_TYPE:\n@@ -8175,8 +8175,8 @@ tsubst_copy_and_build (tree t,\n \ttemplate = lookup_template_function (template, targs);\n \t\n \tif (object)\n-\t  return build (COMPONENT_REF, TREE_TYPE (template), \n-\t\t\tobject, template, NULL_TREE);\n+\t  return build3 (COMPONENT_REF, TREE_TYPE (template), \n+\t\t\t object, template, NULL_TREE);\n \telse\n \t  return template;\n       }\n@@ -10093,7 +10093,7 @@ unify (tree tparms, tree targs, tree parm, tree arg, int strict)\n \t  t1 = TREE_OPERAND (parm, 0);\n \t  t2 = TREE_OPERAND (parm, 1);\n \n-\t  t = fold (build (PLUS_EXPR, integer_type_node, arg, t2));\n+\t  t = fold (build2 (PLUS_EXPR, integer_type_node, arg, t2));\n \n \t  return unify (tparms, targs, t1, t, strict);\n \t}\n@@ -12173,19 +12173,19 @@ build_non_dependent_expr (tree expr)\n     return expr;\n \n   if (TREE_CODE (expr) == COND_EXPR)\n-    return build (COND_EXPR,\n-\t\t  TREE_TYPE (expr),\n-\t\t  TREE_OPERAND (expr, 0),\n-\t\t  (TREE_OPERAND (expr, 1) \n-\t\t   ? build_non_dependent_expr (TREE_OPERAND (expr, 1))\n-\t\t   : build_non_dependent_expr (TREE_OPERAND (expr, 0))),\n-\t\t  build_non_dependent_expr (TREE_OPERAND (expr, 2)));\n+    return build3 (COND_EXPR,\n+\t\t   TREE_TYPE (expr),\n+\t\t   TREE_OPERAND (expr, 0),\n+\t\t   (TREE_OPERAND (expr, 1) \n+\t\t    ? build_non_dependent_expr (TREE_OPERAND (expr, 1))\n+\t\t    : build_non_dependent_expr (TREE_OPERAND (expr, 0))),\n+\t\t   build_non_dependent_expr (TREE_OPERAND (expr, 2)));\n   if (TREE_CODE (expr) == COMPOUND_EXPR\n       && !COMPOUND_EXPR_OVERLOADED (expr))\n-    return build (COMPOUND_EXPR,\n-\t\t  TREE_TYPE (expr),\n-\t\t  TREE_OPERAND (expr, 0),\n-\t\t  build_non_dependent_expr (TREE_OPERAND (expr, 1)));\n+    return build2 (COMPOUND_EXPR,\n+\t\t   TREE_TYPE (expr),\n+\t\t   TREE_OPERAND (expr, 0),\n+\t\t   build_non_dependent_expr (TREE_OPERAND (expr, 1)));\n       \n   /* Otherwise, build a NON_DEPENDENT_EXPR.  \n "}, {"sha": "6e9a6ea64fa5e44efc11e1758f33436dd6a16fa9", "filename": "gcc/cp/rtti.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f293ce4b0d14fc523cac7df7169726e5dadaa329/gcc%2Fcp%2Frtti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f293ce4b0d14fc523cac7df7169726e5dadaa329/gcc%2Fcp%2Frtti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frtti.c?ref=f293ce4b0d14fc523cac7df7169726e5dadaa329", "patch": "@@ -157,8 +157,8 @@ build_headof (tree exp)\n \n   type = build_qualified_type (ptr_type_node, \n \t\t\t       cp_type_quals (TREE_TYPE (exp)));\n-  return build (PLUS_EXPR, type, exp, \n-\t\tconvert_to_integer (ptrdiff_type_node, offset));\n+  return build2 (PLUS_EXPR, type, exp, \n+\t\t convert_to_integer (ptrdiff_type_node, offset));\n }\n \n /* Get a bad_cast node for the program to throw...\n@@ -290,7 +290,7 @@ build_typeid (tree exp)\n     {\n       tree bad = throw_bad_typeid ();\n \n-      exp = build (COND_EXPR, TREE_TYPE (exp), cond, exp, bad);\n+      exp = build3 (COND_EXPR, TREE_TYPE (exp), cond, exp, bad);\n     }\n \n   return exp;\n@@ -419,10 +419,10 @@ get_typeid (tree type)\n static tree\n ifnonnull (tree test, tree result)\n {\n-  return build (COND_EXPR, TREE_TYPE (result),\n-\t\tbuild (EQ_EXPR, boolean_type_node, test, integer_zero_node),\n-\t\tcp_convert (TREE_TYPE (result), integer_zero_node),\n-\t\tresult);\n+  return build3 (COND_EXPR, TREE_TYPE (result),\n+\t\t build2 (EQ_EXPR, boolean_type_node, test, integer_zero_node),\n+\t\t cp_convert (TREE_TYPE (result), integer_zero_node),\n+\t\t result);\n }\n \n /* Execute a dynamic cast, as described in section 5.2.6 of the 9/93 working\n@@ -655,7 +655,7 @@ build_dynamic_cast_1 (tree type, tree expr)\n \t      tree bad = throw_bad_cast ();\n \t      \n \t      result = save_expr (result);\n-\t      return build (COND_EXPR, type, result, result, bad);\n+\t      return build3 (COND_EXPR, type, result, result, bad);\n \t    }\n \n \t  /* Now back to the type we want from a void*.  */\n@@ -827,7 +827,7 @@ tinfo_base_init (tree desc, tree target)\n       vtable_ptr = build_unary_op (ADDR_EXPR, vtable_ptr, 0);\n \n       /* We need to point into the middle of the vtable.  */\n-      vtable_ptr = build\n+      vtable_ptr = build2\n \t(PLUS_EXPR, TREE_TYPE (vtable_ptr), vtable_ptr,\n \t size_binop (MULT_EXPR,\n \t\t     size_int (2 * TARGET_VTABLE_DATA_ENTRY_DISTANCE),"}, {"sha": "393020f397045c593dbdc688b57e5302dd9d3377", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f293ce4b0d14fc523cac7df7169726e5dadaa329/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f293ce4b0d14fc523cac7df7169726e5dadaa329/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=f293ce4b0d14fc523cac7df7169726e5dadaa329", "patch": "@@ -1069,7 +1069,7 @@ begin_compound_stmt (unsigned int flags)\n      processing templates.  */\n   if (processing_template_decl)\n     {\n-      r = build (BIND_EXPR, NULL, NULL, r, NULL);\n+      r = build3 (BIND_EXPR, NULL, NULL, r, NULL);\n       BIND_EXPR_TRY_BLOCK (r) = (flags & BCS_TRY_BLOCK) != 0;\n       BIND_EXPR_BODY_BLOCK (r) = (flags & BCS_FN_BODY) != 0;\n       TREE_SIDE_EFFECTS (r) = 1;\n@@ -1799,8 +1799,8 @@ finish_call_expr (tree fn, tree args, bool disallow_virtual, bool koenig_p)\n \n   if (processing_template_decl)\n     {\n-      result = build (CALL_EXPR, TREE_TYPE (result), orig_fn,\n-\t\t      orig_args, NULL_TREE);\n+      result = build3 (CALL_EXPR, TREE_TYPE (result), orig_fn,\n+\t\t       orig_args, NULL_TREE);\n       KOENIG_LOOKUP_P (result) = koenig_p;\n     }\n   return result;\n@@ -1887,7 +1887,7 @@ finish_pseudo_destructor_expr (tree object, tree scope, tree destructor)\n \t}\n     }\n \n-  return build (PSEUDO_DTOR_EXPR, void_type_node, object, scope, destructor);\n+  return build3 (PSEUDO_DTOR_EXPR, void_type_node, object, scope, destructor);\n }\n \n /* Finish an expression of the form CODE EXPR.  */\n@@ -2540,8 +2540,8 @@ finish_id_expression (tree id_expression,\n \t      if (TYPE_P (scope) && dependent_type_p (scope))\n \t\treturn build_nt (SCOPE_REF, scope, id_expression);\n \t      else if (TYPE_P (scope) && DECL_P (decl))\n-\t\treturn build (SCOPE_REF, TREE_TYPE (decl), scope,\n-\t\t\t      id_expression);\n+\t\treturn build2 (SCOPE_REF, TREE_TYPE (decl), scope,\n+\t\t\t       id_expression);\n \t      else\n \t\treturn decl;\n \t    }\n@@ -2617,7 +2617,7 @@ finish_id_expression (tree id_expression,\n \t  else if (!processing_template_decl)\n \t    decl = convert_from_reference (decl);\n \t  else if (TYPE_P (scope))\n-\t    decl = build (SCOPE_REF, TREE_TYPE (decl), scope, decl);\n+\t    decl = build2 (SCOPE_REF, TREE_TYPE (decl), scope, decl);\n \t}\n       else if (TREE_CODE (decl) == FIELD_DECL)\n \tdecl = finish_non_static_data_member (decl, current_class_ref,\n@@ -2797,9 +2797,9 @@ simplify_aggr_init_expr (tree *tp)\n       args = tree_cons (NULL_TREE, addr, args);\n     }\n \n-  call_expr = build (CALL_EXPR, \n-\t\t     TREE_TYPE (TREE_TYPE (TREE_TYPE (fn))),\n-\t\t     fn, args, NULL_TREE);\n+  call_expr = build3 (CALL_EXPR, \n+\t\t      TREE_TYPE (TREE_TYPE (TREE_TYPE (fn))),\n+\t\t      fn, args, NULL_TREE);\n \n   if (style == arg)\n     /* Tell the backend that we've added our return slot to the argument\n@@ -3017,8 +3017,8 @@ finalize_nrv_r (tree* tp, int* walk_subtrees, void* data)\n       if (DECL_INITIAL (dp->var)\n \t  && DECL_INITIAL (dp->var) != error_mark_node)\n \t{\n-\t  init = build (INIT_EXPR, void_type_node, dp->result,\n-\t\t\tDECL_INITIAL (dp->var));\n+\t  init = build2 (INIT_EXPR, void_type_node, dp->result,\n+\t\t\t DECL_INITIAL (dp->var));\n \t  DECL_INITIAL (dp->var) = error_mark_node;\n \t}\n       else"}, {"sha": "aede4a6ccf73c8d04044a0f54ed32310a4b97f6e", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f293ce4b0d14fc523cac7df7169726e5dadaa329/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f293ce4b0d14fc523cac7df7169726e5dadaa329/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=f293ce4b0d14fc523cac7df7169726e5dadaa329", "patch": "@@ -234,8 +234,8 @@ build_target_expr (tree decl, tree value)\n {\n   tree t;\n \n-  t = build (TARGET_EXPR, TREE_TYPE (decl), decl, value,\n-\t     cxx_maybe_build_cleanup (decl), NULL_TREE);\n+  t = build4 (TARGET_EXPR, TREE_TYPE (decl), decl, value,\n+\t      cxx_maybe_build_cleanup (decl), NULL_TREE);\n   /* We always set TREE_SIDE_EFFECTS so that expand_expr does not\n      ignore the TARGET_EXPR.  If there really turn out to be no\n      side-effects, then the optimizer should be able to get rid of\n@@ -300,8 +300,8 @@ build_cplus_new (tree type, tree init)\n      type, don't mess with AGGR_INIT_EXPR.  */\n   if (is_ctor || TREE_ADDRESSABLE (type))\n     {\n-      rval = build (AGGR_INIT_EXPR, void_type_node, fn,\n-\t\t    TREE_OPERAND (init, 1), slot);\n+      rval = build3 (AGGR_INIT_EXPR, void_type_node, fn,\n+\t\t     TREE_OPERAND (init, 1), slot);\n       TREE_SIDE_EFFECTS (rval) = 1;\n       AGGR_INIT_VIA_CTOR_P (rval) = is_ctor;\n     }\n@@ -1154,9 +1154,9 @@ cxx_print_statistics (void)\n tree\n array_type_nelts_top (tree type)\n {\n-  return fold (build (PLUS_EXPR, sizetype,\n-\t\t      array_type_nelts (type),\n-\t\t      integer_one_node));\n+  return fold (build2 (PLUS_EXPR, sizetype,\n+\t\t       array_type_nelts (type),\n+\t\t       integer_one_node));\n }\n \n /* Return, as an INTEGER_CST node, the number of elements for TYPE\n@@ -1171,7 +1171,7 @@ array_type_nelts_total (tree type)\n   while (TREE_CODE (type) == ARRAY_TYPE)\n     {\n       tree n = array_type_nelts_top (type);\n-      sz = fold (build (MULT_EXPR, sizetype, sz, n));\n+      sz = fold (build2 (MULT_EXPR, sizetype, sz, n));\n       type = TREE_TYPE (type);\n     }\n   return sz;\n@@ -2403,7 +2403,7 @@ stabilize_call (tree call, tree *initp)\n \tif (!init)\n \t  /* Nothing.  */;\n \telse if (inits)\n-\t  inits = build (COMPOUND_EXPR, void_type_node, inits, init);\n+\t  inits = build2 (COMPOUND_EXPR, void_type_node, inits, init);\n \telse\n \t  inits = init;\n       }"}, {"sha": "01b969edb97e9f6e989bceb44bf4e09ae0919d51", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 83, "deletions": 79, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f293ce4b0d14fc523cac7df7169726e5dadaa329/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f293ce4b0d14fc523cac7df7169726e5dadaa329/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=f293ce4b0d14fc523cac7df7169726e5dadaa329", "patch": "@@ -1385,8 +1385,8 @@ decay_conversion (tree exp)\n       if (TREE_CODE (exp) == COMPOUND_EXPR)\n \t{\n \t  tree op1 = decay_conversion (TREE_OPERAND (exp, 1));\n-\t  return build (COMPOUND_EXPR, TREE_TYPE (op1),\n-\t\t\tTREE_OPERAND (exp, 0), op1);\n+\t  return build2 (COMPOUND_EXPR, TREE_TYPE (op1),\n+\t\t\t TREE_OPERAND (exp, 0), op1);\n \t}\n \n       if (!lvalue_p (exp)\n@@ -1658,7 +1658,7 @@ build_class_member_access_expr (tree object, tree member,\n       result = member;\n       /* If OBJECT has side-effects, they are supposed to occur.  */\n       if (TREE_SIDE_EFFECTS (object))\n-\tresult = build (COMPOUND_EXPR, TREE_TYPE (result), object, result);\n+\tresult = build2 (COMPOUND_EXPR, TREE_TYPE (result), object, result);\n     }\n   else if (TREE_CODE (member) == FIELD_DECL)\n     {\n@@ -1755,8 +1755,8 @@ build_class_member_access_expr (tree object, tree member,\n \t  member_type = cp_build_qualified_type (member_type, type_quals);\n \t}\n \n-      result = fold (build (COMPONENT_REF, member_type, object, member,\n-\t\t\t    NULL_TREE));\n+      result = fold (build3 (COMPONENT_REF, member_type, object, member,\n+\t\t\t     NULL_TREE));\n \n       /* Mark the expression const or volatile, as appropriate.  Even\n \t though we've dealt with the type above, we still have to mark the\n@@ -1783,16 +1783,16 @@ build_class_member_access_expr (tree object, tree member,\n \ttype = unknown_type_node;\n       /* Note that we do not convert OBJECT to the BASELINK_BINFO\n \t base.  That will happen when the function is called.  */\n-      result = build (COMPONENT_REF, type, object, member, NULL_TREE);\n+      result = build3 (COMPONENT_REF, type, object, member, NULL_TREE);\n     }\n   else if (TREE_CODE (member) == CONST_DECL)\n     {\n       /* The member is an enumerator.  */\n       result = member;\n       /* If OBJECT has side-effects, they are supposed to occur.  */\n       if (TREE_SIDE_EFFECTS (object))\n-\tresult = build (COMPOUND_EXPR, TREE_TYPE (result),\n-\t\t\tobject, result);\n+\tresult = build2 (COMPOUND_EXPR, TREE_TYPE (result),\n+\t\t\t object, result);\n     }\n   else\n     {\n@@ -1833,8 +1833,8 @@ lookup_destructor (tree object, tree scope, tree dtor_name)\n       return error_mark_node;\n     }\n   if (!TYPE_HAS_DESTRUCTOR (dtor_type))\n-    return build (PSEUDO_DTOR_EXPR, void_type_node, object, scope,\n-\t\t  dtor_type);\n+    return build3 (PSEUDO_DTOR_EXPR, void_type_node, object, scope,\n+\t\t   dtor_type);\n   expr = lookup_member (dtor_type, complete_dtor_identifier,\n \t\t\t/*protect=*/1, /*want_type=*/false);\n   expr = (adjust_result_of_qualified_name_lookup\n@@ -2037,7 +2037,8 @@ build_ptrmemfunc_access_expr (tree ptrmem, tree member_name)\n \t\t\t  /*want_type=*/false);\n   member_type = cp_build_qualified_type (TREE_TYPE (member),\n \t\t\t\t\t cp_type_quals (ptrmem_type));\n-  return fold (build (COMPONENT_REF, member_type, ptrmem, member, NULL_TREE));\n+  return fold (build3 (COMPONENT_REF, member_type,\n+\t\t       ptrmem, member, NULL_TREE));\n }\n \n /* Given an expression PTR for a pointer, return an expression\n@@ -2171,8 +2172,8 @@ build_array_ref (tree array, tree idx)\n     case COMPOUND_EXPR:\n       {\n \ttree value = build_array_ref (TREE_OPERAND (array, 1), idx);\n-\treturn build (COMPOUND_EXPR, TREE_TYPE (value),\n-\t\t      TREE_OPERAND (array, 0), value);\n+\treturn build2 (COMPOUND_EXPR, TREE_TYPE (value),\n+\t\t       TREE_OPERAND (array, 0), value);\n       }\n \n     case COND_EXPR:\n@@ -2253,7 +2254,7 @@ build_array_ref (tree array, tree idx)\n \t}\n \n       type = TREE_TYPE (TREE_TYPE (array));\n-      rval = build (ARRAY_REF, type, array, idx, NULL_TREE, NULL_TREE);\n+      rval = build4 (ARRAY_REF, type, array, idx, NULL_TREE, NULL_TREE);\n       /* Array ref is const/volatile if the array elements are\n \t or if the array is..  */\n       TREE_READONLY (rval)\n@@ -2372,8 +2373,8 @@ get_member_function_from_ptrfunc (tree *instance_ptrptr, tree function)\n       if (instance_ptr == error_mark_node)\n \treturn error_mark_node;\n       /* ...and then the delta in the PMF.  */\n-      instance_ptr = build (PLUS_EXPR, TREE_TYPE (instance_ptr),\n-\t\t\t    instance_ptr, delta);\n+      instance_ptr = build2 (PLUS_EXPR, TREE_TYPE (instance_ptr),\n+\t\t\t     instance_ptr, delta);\n \n       /* Hand back the adjusted 'this' argument to our caller.  */\n       *instance_ptrptr = instance_ptr;\n@@ -2384,7 +2385,7 @@ get_member_function_from_ptrfunc (tree *instance_ptrptr, tree function)\n       vtbl = build_indirect_ref (vtbl, NULL);\n \n       /* Finally, extract the function pointer from the vtable.  */\n-      e2 = fold (build (PLUS_EXPR, TREE_TYPE (vtbl), vtbl, idx));\n+      e2 = fold (build2 (PLUS_EXPR, TREE_TYPE (vtbl), vtbl, idx));\n       e2 = build_indirect_ref (e2, NULL);\n       TREE_CONSTANT (e2) = 1;\n       TREE_INVARIANT (e2) = 1;\n@@ -2401,8 +2402,8 @@ get_member_function_from_ptrfunc (tree *instance_ptrptr, tree function)\n       /* Make sure this doesn't get evaluated first inside one of the\n \t branches of the COND_EXPR.  */\n       if (instance_save_expr)\n-\te1 = build (COMPOUND_EXPR, TREE_TYPE (e1),\n-\t\t    instance_save_expr, e1);\n+\te1 = build2 (COMPOUND_EXPR, TREE_TYPE (e1),\n+\t\t     instance_save_expr, e1);\n \n       function = e1;\n     }\n@@ -3082,7 +3083,7 @@ build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n \t\t\t\t   cp_convert (TREE_TYPE (pfn0),\n \t\t\t\t\t       integer_zero_node));\n \t  e1 = cp_build_binary_op (TRUTH_ORIF_EXPR, e1, e2);\n-\t  e2 = build (EQ_EXPR, boolean_type_node, pfn0, pfn1);\n+\t  e2 = build2 (EQ_EXPR, boolean_type_node, pfn0, pfn1);\n \t  e = cp_build_binary_op (TRUTH_ANDIF_EXPR, e2, e1);\n \t  if (code == EQ_EXPR)\n \t    return e;\n@@ -3451,7 +3452,7 @@ build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n     build_type = result_type;\n \n   {\n-    tree result = fold (build (resultcode, build_type, op0, op1));\n+    tree result = fold (build2 (resultcode, build_type, op0, op1));\n     if (final_type != 0)\n       result = cp_convert (final_type, result);\n     return result;\n@@ -3516,7 +3517,7 @@ pointer_diff (tree op0, tree op1, tree ptrtype)\n \n   /* Do the division.  */\n \n-  result = build (EXACT_DIV_EXPR, restype, op0, cp_convert (restype, op1));\n+  result = build2 (EXACT_DIV_EXPR, restype, op0, cp_convert (restype, op1));\n   return fold (result);\n }\n \f\n@@ -3605,9 +3606,9 @@ build_x_unary_op (enum tree_code code, tree xarg)\n \t    {\n \t      /* A single non-static member, make sure we don't allow a\n                  pointer-to-member.  */\n-\t      xarg = build (OFFSET_REF, TREE_TYPE (xarg),\n-\t\t\t    TREE_OPERAND (xarg, 0),\n-\t\t\t    ovl_cons (TREE_OPERAND (xarg, 1), NULL_TREE));\n+\t      xarg = build2 (OFFSET_REF, TREE_TYPE (xarg),\n+\t\t\t     TREE_OPERAND (xarg, 0),\n+\t\t\t     ovl_cons (TREE_OPERAND (xarg, 1), NULL_TREE));\n \t      PTRMEM_OK_P (xarg) = ptrmem;\n \t    }\t      \n         }\n@@ -3799,8 +3800,8 @@ build_unary_op (enum tree_code code, tree xarg, int noconvert)\n \t  arg = stabilize_reference (arg);\n \t  real = build_unary_op (REALPART_EXPR, arg, 1);\n \t  imag = build_unary_op (IMAGPART_EXPR, arg, 1);\n-\t  return build (COMPLEX_EXPR, TREE_TYPE (arg),\n-\t\t\tbuild_unary_op (code, real, 1), imag);\n+\t  return build2 (COMPLEX_EXPR, TREE_TYPE (arg),\n+\t\t\t build_unary_op (code, real, 1), imag);\n \t}\n \n       /* Report invalid types.  */\n@@ -3885,13 +3886,14 @@ build_unary_op (enum tree_code code, tree xarg, int noconvert)\n \t\tvalue = arg;\n \t      else\n \t\tvalue = save_expr (arg);\n-\t      incremented = build (((code == PREINCREMENT_EXPR\n-\t\t\t\t     || code == POSTINCREMENT_EXPR)\n-\t\t\t\t    ? PLUS_EXPR : MINUS_EXPR),\n-\t\t\t\t   argtype, value, inc);\n+\t      incremented = build2 (((code == PREINCREMENT_EXPR\n+\t\t\t\t      || code == POSTINCREMENT_EXPR)\n+\t\t\t\t     ? PLUS_EXPR : MINUS_EXPR),\n+\t\t\t\t    argtype, value, inc);\n \n \t      modify = build_modify_expr (arg, NOP_EXPR, incremented);\n-\t      compound = build (COMPOUND_EXPR, TREE_TYPE (arg), modify, value);\n+\t      compound = build2 (COMPOUND_EXPR, TREE_TYPE (arg),\n+\t\t\t\t modify, value);\n \n \t      /* Eliminate warning about unused result of + or -.  */\n \t      TREE_NO_WARNING (compound) = 1;\n@@ -3919,7 +3921,7 @@ build_unary_op (enum tree_code code, tree xarg, int noconvert)\n \t    val = boolean_increment (code, arg);\n \t  }\n \telse\n-\t  val = build (code, TREE_TYPE (arg), arg, inc);\n+\t  val = build2 (code, TREE_TYPE (arg), arg, inc);\n \n \tTREE_SIDE_EFFECTS (val) = 1;\n \treturn cp_convert (result_type, val);\n@@ -4096,8 +4098,8 @@ build_unary_op (enum tree_code code, tree xarg, int noconvert)\n \t    addr = build_address (fn);\n \t    if (TREE_SIDE_EFFECTS (TREE_OPERAND (arg, 0)))\n \t      /* Do not lose object's side effects.  */\n-\t      addr = build (COMPOUND_EXPR, TREE_TYPE (addr),\n-\t\t\t    TREE_OPERAND (arg, 0), addr);\n+\t      addr = build2 (COMPOUND_EXPR, TREE_TYPE (addr),\n+\t\t\t     TREE_OPERAND (arg, 0), addr);\n \t  }\n \telse if (DECL_C_BIT_FIELD (TREE_OPERAND (arg, 1)))\n \t  {\n@@ -4118,8 +4120,9 @@ build_unary_op (enum tree_code code, tree xarg, int noconvert)\n \t    \n \t    rval = build_base_path (PLUS_EXPR, rval, binfo, 1);\n \t    rval = build_nop (argtype, rval);\n-\t    addr = fold (build (PLUS_EXPR, argtype, rval,\n-\t\t\t\tcp_convert (argtype, byte_position (field))));\n+\t    addr = fold (build2 (PLUS_EXPR, argtype, rval,\n+\t\t\t\t cp_convert (argtype,\n+\t\t\t\t\t     byte_position (field))));\n \t  }\n \n \tif (TREE_CODE (argtype) == POINTER_TYPE\n@@ -4160,8 +4163,8 @@ unary_complex_lvalue (enum tree_code code, tree arg)\n   if (TREE_CODE (arg) == COMPOUND_EXPR)\n     {\n       tree real_result = build_unary_op (code, TREE_OPERAND (arg, 1), 0);\n-      return build (COMPOUND_EXPR, TREE_TYPE (real_result),\n-\t\t    TREE_OPERAND (arg, 0), real_result);\n+      return build2 (COMPOUND_EXPR, TREE_TYPE (real_result),\n+\t\t     TREE_OPERAND (arg, 0), real_result);\n     }\n \n   /* Handle (a ? b : c) used as an \"lvalue\".  */\n@@ -4178,11 +4181,11 @@ unary_complex_lvalue (enum tree_code code, tree arg)\n       if (TREE_SIDE_EFFECTS (lvalue))\n \t{\n \t  lvalue = stabilize_reference (lvalue);\n-\t  arg = build (TREE_CODE (arg), TREE_TYPE (arg),\n-\t\t       lvalue, TREE_OPERAND (arg, 1));\n+\t  arg = build2 (TREE_CODE (arg), TREE_TYPE (arg),\n+\t\t\tlvalue, TREE_OPERAND (arg, 1));\n \t}\n       return unary_complex_lvalue\n-\t(code, build (COMPOUND_EXPR, TREE_TYPE (lvalue), arg, lvalue));\n+\t(code, build2 (COMPOUND_EXPR, TREE_TYPE (lvalue), arg, lvalue));\n     }\n \n   if (code != ADDR_EXPR)\n@@ -4193,7 +4196,8 @@ unary_complex_lvalue (enum tree_code code, tree arg)\n       || TREE_CODE (arg) == INIT_EXPR)\n     {\n       tree real_result = build_unary_op (code, TREE_OPERAND (arg, 0), 0);\n-      arg = build (COMPOUND_EXPR, TREE_TYPE (real_result), arg, real_result);\n+      arg = build2 (COMPOUND_EXPR, TREE_TYPE (real_result),\n+\t\t    arg, real_result);\n       TREE_NO_WARNING (arg) = 1;\n       return arg;\n     }\n@@ -4266,7 +4270,7 @@ unary_complex_lvalue (enum tree_code code, tree arg)\n       }\n \n     if (TREE_CODE (arg) == SAVE_EXPR && TREE_CODE (targ) == INDIRECT_REF)\n-      return build (SAVE_EXPR, build_pointer_type (TREE_TYPE (arg)),\n+      return build3 (SAVE_EXPR, build_pointer_type (TREE_TYPE (arg)),\n \t\t     TREE_OPERAND (targ, 0), current_function_decl, NULL);\n   }\n \n@@ -4440,13 +4444,13 @@ build_compound_expr (tree lhs, tree rhs)\n \t helps the compiler to eliminate unnecessary temporaries.  */\n       tree init = TREE_OPERAND (rhs, 1);\n       \n-      init = build (COMPOUND_EXPR, TREE_TYPE (init), lhs, init);\n+      init = build2 (COMPOUND_EXPR, TREE_TYPE (init), lhs, init);\n       TREE_OPERAND (rhs, 1) = init;\n       \n       return rhs;\n     }\n   \n-  return build (COMPOUND_EXPR, TREE_TYPE (rhs), lhs, rhs);\n+  return build2 (COMPOUND_EXPR, TREE_TYPE (rhs), lhs, rhs);\n }\n \n /* Issue an error message if casting from SRC_TYPE to DEST_TYPE casts\n@@ -5013,32 +5017,32 @@ build_modify_expr (tree lhs, enum tree_code modifycode, tree rhs)\n     case PREDECREMENT_EXPR:\n     case PREINCREMENT_EXPR:\n       if (TREE_SIDE_EFFECTS (TREE_OPERAND (lhs, 0)))\n-\tlhs = build (TREE_CODE (lhs), TREE_TYPE (lhs),\n-\t\t     stabilize_reference (TREE_OPERAND (lhs, 0)),\n-\t\t     TREE_OPERAND (lhs, 1));\n-      return build (COMPOUND_EXPR, lhstype,\n-\t\t    lhs,\n-\t\t    build_modify_expr (TREE_OPERAND (lhs, 0),\n-\t\t\t\t       modifycode, rhs));\n+\tlhs = build2 (TREE_CODE (lhs), TREE_TYPE (lhs),\n+\t\t      stabilize_reference (TREE_OPERAND (lhs, 0)),\n+\t\t      TREE_OPERAND (lhs, 1));\n+      return build2 (COMPOUND_EXPR, lhstype,\n+\t\t     lhs,\n+\t\t     build_modify_expr (TREE_OPERAND (lhs, 0),\n+\t\t\t\t\tmodifycode, rhs));\n \n       /* Handle (a, b) used as an \"lvalue\".  */\n     case COMPOUND_EXPR:\n       newrhs = build_modify_expr (TREE_OPERAND (lhs, 1),\n \t\t\t\t  modifycode, rhs);\n       if (newrhs == error_mark_node)\n \treturn error_mark_node;\n-      return build (COMPOUND_EXPR, lhstype,\n-\t\t    TREE_OPERAND (lhs, 0), newrhs);\n+      return build2 (COMPOUND_EXPR, lhstype,\n+\t\t     TREE_OPERAND (lhs, 0), newrhs);\n \n     case MODIFY_EXPR:\n       if (TREE_SIDE_EFFECTS (TREE_OPERAND (lhs, 0)))\n-\tlhs = build (TREE_CODE (lhs), TREE_TYPE (lhs),\n-\t\t     stabilize_reference (TREE_OPERAND (lhs, 0)),\n-\t\t     TREE_OPERAND (lhs, 1));\n+\tlhs = build2 (TREE_CODE (lhs), TREE_TYPE (lhs),\n+\t\t      stabilize_reference (TREE_OPERAND (lhs, 0)),\n+\t\t      TREE_OPERAND (lhs, 1));\n       newrhs = build_modify_expr (TREE_OPERAND (lhs, 0), modifycode, rhs);\n       if (newrhs == error_mark_node)\n \treturn error_mark_node;\n-      return build (COMPOUND_EXPR, lhstype, lhs, newrhs);\n+      return build2 (COMPOUND_EXPR, lhstype, lhs, newrhs);\n \n       /* Handle (a ? b : c) used as an \"lvalue\".  */\n     case COND_EXPR:\n@@ -5070,7 +5074,7 @@ build_modify_expr (tree lhs, enum tree_code modifycode, tree rhs)\n \t/* Make sure the code to compute the rhs comes out\n \t   before the split.  */\n \tif (preeval)\n-\t  cond = build (COMPOUND_EXPR, TREE_TYPE (lhs), preeval, cond);\n+\t  cond = build2 (COMPOUND_EXPR, TREE_TYPE (lhs), preeval, cond);\n \treturn cond;\n       }\n       \n@@ -5085,7 +5089,7 @@ build_modify_expr (tree lhs, enum tree_code modifycode, tree rhs)\n \t  if (! same_type_p (TREE_TYPE (rhs), lhstype))\n \t    /* Call convert to generate an error; see PR 11063.  */\n \t    rhs = convert (lhstype, rhs);\n-\t  result = build (INIT_EXPR, lhstype, lhs, rhs);\n+\t  result = build2 (INIT_EXPR, lhstype, lhs, rhs);\n \t  TREE_SIDE_EFFECTS (result) = 1;\n \t  return result;\n \t}\n@@ -5249,15 +5253,15 @@ build_modify_expr (tree lhs, enum tree_code modifycode, tree rhs)\n \t accidental self-initialization.  So we force the TARGET_EXPR to be\n \t expanded without a target.  */\n       if (TREE_CODE (newrhs) == TARGET_EXPR)\n-\tnewrhs = build (COMPOUND_EXPR, TREE_TYPE (newrhs), newrhs,\n-\t\t\tTREE_OPERAND (newrhs, 0));\n+\tnewrhs = build2 (COMPOUND_EXPR, TREE_TYPE (newrhs), newrhs,\n+\t\t\t TREE_OPERAND (newrhs, 0));\n     }\n \n   if (newrhs == error_mark_node)\n     return error_mark_node;\n \n-  result = build (modifycode == NOP_EXPR ? MODIFY_EXPR : INIT_EXPR,\n-\t\t  lhstype, lhs, newrhs);\n+  result = build2 (modifycode == NOP_EXPR ? MODIFY_EXPR : INIT_EXPR,\n+\t\t   lhstype, lhs, newrhs);\n \n   TREE_SIDE_EFFECTS (result) = 1;\n   if (!plain_assign)\n@@ -5272,7 +5276,7 @@ build_modify_expr (tree lhs, enum tree_code modifycode, tree rhs)\n     return result;\n   if (olhs)\n     {\n-      result = build (COMPOUND_EXPR, olhstype, result, olhs);\n+      result = build2 (COMPOUND_EXPR, olhstype, result, olhs);\n       TREE_NO_WARNING (result) = 1;\n       return result;\n     }\n@@ -5524,28 +5528,28 @@ expand_ptrmemfunc_cst (tree cst, tree *delta, tree *pfn)\n          fn; the call will do the opposite adjustment.  */\n       tree orig_class = DECL_CONTEXT (fn);\n       tree binfo = binfo_or_else (orig_class, fn_class);\n-      *delta = fold (build (PLUS_EXPR, TREE_TYPE (*delta),\n-\t\t\t    *delta, BINFO_OFFSET (binfo)));\n+      *delta = fold (build2 (PLUS_EXPR, TREE_TYPE (*delta),\n+\t\t\t     *delta, BINFO_OFFSET (binfo)));\n \n       /* We set PFN to the vtable offset at which the function can be\n \t found, plus one (unless ptrmemfunc_vbit_in_delta, in which\n \t case delta is shifted left, and then incremented).  */\n       *pfn = DECL_VINDEX (fn);\n-      *pfn = fold (build (MULT_EXPR, integer_type_node, *pfn,\n-\t\t\t  TYPE_SIZE_UNIT (vtable_entry_type)));\n+      *pfn = fold (build2 (MULT_EXPR, integer_type_node, *pfn,\n+\t\t\t   TYPE_SIZE_UNIT (vtable_entry_type)));\n \n       switch (TARGET_PTRMEMFUNC_VBIT_LOCATION)\n \t{\n \tcase ptrmemfunc_vbit_in_pfn:\n-\t  *pfn = fold (build (PLUS_EXPR, integer_type_node, *pfn,\n-\t\t\t      integer_one_node));\n+\t  *pfn = fold (build2 (PLUS_EXPR, integer_type_node, *pfn,\n+\t\t\t       integer_one_node));\n \t  break;\n \n \tcase ptrmemfunc_vbit_in_delta:\n-\t  *delta = fold (build (LSHIFT_EXPR, TREE_TYPE (*delta),\n-\t\t\t\t*delta, integer_one_node));\n-\t  *delta = fold (build (PLUS_EXPR, TREE_TYPE (*delta),\n-\t\t\t\t*delta, integer_one_node));\n+\t  *delta = fold (build2 (LSHIFT_EXPR, TREE_TYPE (*delta),\n+\t\t\t\t *delta, integer_one_node));\n+\t  *delta = fold (build2 (PLUS_EXPR, TREE_TYPE (*delta),\n+\t\t\t\t *delta, integer_one_node));\n \t  break;\n \n \tdefault:\n@@ -6055,15 +6059,15 @@ check_return_expr (tree retval)\n       else if (! current_function_returns_struct\n \t       && TREE_CODE (retval) == TARGET_EXPR\n \t       && TREE_CODE (TREE_OPERAND (retval, 1)) == AGGR_INIT_EXPR)\n-\tretval = build (COMPOUND_EXPR, TREE_TYPE (retval), retval,\n-\t\t\tTREE_OPERAND (retval, 0));\n+\tretval = build2 (COMPOUND_EXPR, TREE_TYPE (retval), retval,\n+\t\t\t TREE_OPERAND (retval, 0));\n       else\n \tmaybe_warn_about_returning_address_of_local (retval);\n     }\n   \n   /* Actually copy the value returned into the appropriate location.  */\n   if (retval && retval != result)\n-    retval = build (INIT_EXPR, TREE_TYPE (result), result, retval);\n+    retval = build2 (INIT_EXPR, TREE_TYPE (result), result, retval);\n \n   return retval;\n }"}, {"sha": "f44474db6ff94a90c279c3eea06c16fd82befb27", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f293ce4b0d14fc523cac7df7169726e5dadaa329/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f293ce4b0d14fc523cac7df7169726e5dadaa329/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=f293ce4b0d14fc523cac7df7169726e5dadaa329", "patch": "@@ -470,11 +470,11 @@ split_nonconstant_init_1 (tree dest, tree init)\n \t  if (TREE_CODE (value) == CONSTRUCTOR)\n \t    {\n \t      if (array_type_p)\n-\t        sub = build (ARRAY_REF, inner_type, dest, field_index,\n-\t\t\t     NULL_TREE, NULL_TREE);\n+\t        sub = build4 (ARRAY_REF, inner_type, dest, field_index,\n+\t\t\t      NULL_TREE, NULL_TREE);\n \t      else\n-\t        sub = build (COMPONENT_REF, inner_type, dest, field_index,\n-\t\t\t     NULL_TREE);\n+\t        sub = build3 (COMPONENT_REF, inner_type, dest, field_index,\n+\t\t\t      NULL_TREE);\n \n \t      split_nonconstant_init_1 (sub, value);\n \t    }\n@@ -483,13 +483,13 @@ split_nonconstant_init_1 (tree dest, tree init)\n \t      *pelt = TREE_CHAIN (elt);\n \n \t      if (array_type_p)\n-\t        sub = build (ARRAY_REF, inner_type, dest, field_index,\n-\t\t\t     NULL_TREE, NULL_TREE);\n+\t        sub = build4 (ARRAY_REF, inner_type, dest, field_index,\n+\t\t\t      NULL_TREE, NULL_TREE);\n \t      else\n-\t        sub = build (COMPONENT_REF, inner_type, dest, field_index,\n-\t\t\t     NULL_TREE);\n+\t        sub = build3 (COMPONENT_REF, inner_type, dest, field_index,\n+\t\t\t      NULL_TREE);\n \n-\t      code = build (MODIFY_EXPR, inner_type, sub, value);\n+\t      code = build2 (MODIFY_EXPR, inner_type, sub, value);\n \t      code = build_stmt (EXPR_STMT, code);\n \t      add_stmt (code);\n \t      continue;\n@@ -503,7 +503,7 @@ split_nonconstant_init_1 (tree dest, tree init)\n       if (!initializer_constant_valid_p (init, type))\n \t{\n \t  CONSTRUCTOR_ELTS (init) = NULL;\n-\t  code = build (MODIFY_EXPR, type, dest, init);\n+\t  code = build2 (MODIFY_EXPR, type, dest, init);\n \t  code = build_stmt (EXPR_STMT, code);\n \t  add_stmt (code);\n \t}\n@@ -533,7 +533,7 @@ split_nonconstant_init (tree dest, tree init)\n       TREE_READONLY (dest) = 0;\n     }\n   else\n-    code = build (INIT_EXPR, TREE_TYPE (dest), dest, init);\n+    code = build2 (INIT_EXPR, TREE_TYPE (dest), dest, init);\n \n   return code;\n }\n@@ -609,7 +609,7 @@ store_init_value (tree decl, tree init)\n      constructing never make it into DECL_INITIAL, and passes 'init' to\n      build_aggr_init without checking DECL_INITIAL.  So just return.  */\n   else if (TYPE_NEEDS_CONSTRUCTING (type))\n-    return build (INIT_EXPR, type, decl, value);\n+    return build2 (INIT_EXPR, type, decl, value);\n   else if (TREE_STATIC (decl)\n \t   && (! TREE_CONSTANT (value)\n \t       || ! initializer_constant_valid_p (value, TREE_TYPE (value))))\n@@ -1369,12 +1369,12 @@ build_m_component_ref (tree datum, tree component)\n       \n       /* Build an expression for \"object + offset\" where offset is the\n \t value stored in the pointer-to-data-member.  */\n-      datum = build (PLUS_EXPR, build_pointer_type (type),\n-\t\t     datum, build_nop (ptrdiff_type_node, component));\n+      datum = build2 (PLUS_EXPR, build_pointer_type (type),\n+\t\t      datum, build_nop (ptrdiff_type_node, component));\n       return build_indirect_ref (datum, 0);\n     }\n   else\n-    return build (OFFSET_REF, type, datum, component);\n+    return build2 (OFFSET_REF, type, datum, component);\n }\n \n /* Return a tree node for the expression TYPENAME '(' PARMS ')'.  */"}]}