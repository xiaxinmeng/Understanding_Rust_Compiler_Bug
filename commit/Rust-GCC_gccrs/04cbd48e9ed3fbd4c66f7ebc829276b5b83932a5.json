{"sha": "04cbd48e9ed3fbd4c66f7ebc829276b5b83932a5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDRjYmQ0OGU5ZWQzZmJkNGM2NmY3ZWJjODI5Mjc2YjViODM5MzJhNQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-10-21T10:25:12Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-10-21T10:25:12Z"}, "message": "[multiple changes]\n\n2010-10-21  Geert Bosch  <bosch@adacore.com>\n\n\t* urealp.adb (UR_Write): Write hexadecimal constants with exponent 1 as\n\tdecimal constants, and write any others using the exponent notation.\n\tMinor reformatting throughout\n\t(Store_Ureal_Normalized): New function (minor code reorganization)\n\n2010-10-21  Robert Dewar  <dewar@adacore.com>\n\n\t* einfo.ads, xeinfo.adb: Minor reformatting.\n\t* s-stalib.ads: Minor comment fixes.\n\nFrom-SVN: r165762", "tree": {"sha": "2a508d74f1374d42333372412e84101c8309980d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2a508d74f1374d42333372412e84101c8309980d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/04cbd48e9ed3fbd4c66f7ebc829276b5b83932a5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/04cbd48e9ed3fbd4c66f7ebc829276b5b83932a5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/04cbd48e9ed3fbd4c66f7ebc829276b5b83932a5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/04cbd48e9ed3fbd4c66f7ebc829276b5b83932a5/comments", "author": null, "committer": null, "parents": [{"sha": "7fc53871160b8543b60c86eabd3fdc7f52e4d686", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7fc53871160b8543b60c86eabd3fdc7f52e4d686", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7fc53871160b8543b60c86eabd3fdc7f52e4d686"}], "stats": {"total": 529, "additions": 260, "deletions": 269}, "files": [{"sha": "90fd375b6f1752699b711dc8cc554e7a65497162", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04cbd48e9ed3fbd4c66f7ebc829276b5b83932a5/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04cbd48e9ed3fbd4c66f7ebc829276b5b83932a5/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=04cbd48e9ed3fbd4c66f7ebc829276b5b83932a5", "patch": "@@ -1,3 +1,15 @@\n+2010-10-21  Geert Bosch  <bosch@adacore.com>\n+\n+\t* urealp.adb (UR_Write): Write hexadecimal constants with exponent 1 as\n+\tdecimal constants, and write any others using the exponent notation.\n+\tMinor reformatting throughout\n+\t(Store_Ureal_Normalized): New function (minor code reorganization)\n+\n+2010-10-21  Robert Dewar  <dewar@adacore.com>\n+\n+\t* einfo.ads, xeinfo.adb: Minor reformatting.\n+\t* s-stalib.ads: Minor comment fixes.\n+\n 2010-10-21  Ed Schonberg  <schonberg@adacore.com>\n \n \t* sem_ch6.adb (Enter_Overloaded_Entity): Refine warning message about"}, {"sha": "b79fa2935e30449222c010fe3ec0db0bc4b21c8d", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04cbd48e9ed3fbd4c66f7ebc829276b5b83932a5/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04cbd48e9ed3fbd4c66f7ebc829276b5b83932a5/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=04cbd48e9ed3fbd4c66f7ebc829276b5b83932a5", "patch": "@@ -850,10 +850,11 @@ package Einfo is\n --       index starting at 1 and ranging up to number of discriminants.\n \n --    Dispatch_Table_Wrappers (Elist26) [implementation base type only]\n---       Present in library level record type entities if we are generating\n---       statically allocated dispatch tables. For a tagged type, points to\n---       the list of dispatch table wrappers associated with the tagged type.\n---       For a non-tagged record, contains No_Elist.\n+--       Present in record type [with private] entities. Set in library level\n+--       record type entities if we are generating statically allocated\n+--       dispatch tables. For a tagged type, points to the list of dispatch\n+--       table wrappers associated with the tagged type. For a non-tagged\n+--       record, contains No_Elist.\n \n --    DTC_Entity (Node16)\n --       Present in function and procedure entities. Set to Empty unless\n@@ -5424,7 +5425,6 @@ package Einfo is\n    --  E_Record_Subtype\n    --    Direct_Primitive_Operations         (Elist10)\n    --    Access_Disp_Table                   (Elist16)  (base type only)\n-   --    Dispatch_Table_Wrappers             (Elist26)  (base type only)\n    --    Cloned_Subtype                      (Node16)   (subtype case only)\n    --    First_Entity                        (Node17)\n    --    Corresponding_Concurrent_Type       (Node18)\n@@ -5434,6 +5434,7 @@ package Einfo is\n    --    Corresponding_Remote_Type           (Node22)\n    --    Stored_Constraint                   (Elist23)\n    --    Interfaces                          (Elist25)\n+   --    Dispatch_Table_Wrappers             (Elist26)  (base type only)\n    --    Underlying_Record_View              (Node28)   (base type only)\n    --    Component_Alignment                 (special)  (base type only)\n    --    C_Pass_By_Copy                      (Flag125)  (base type only)\n@@ -5457,7 +5458,6 @@ package Einfo is\n    --  E_Record_Subtype_With_Private\n    --    Direct_Primitive_Operations         (Elist10)\n    --    Access_Disp_Table                   (Elist16)  (base type only)\n-   --    Dispatch_Table_Wrappers             (Elist26)  (base type only)\n    --    First_Entity                        (Node17)\n    --    Private_Dependents                  (Elist18)\n    --    Underlying_Full_View                (Node19)\n@@ -5466,6 +5466,7 @@ package Einfo is\n    --    Private_View                        (Node22)\n    --    Stored_Constraint                   (Elist23)\n    --    Interfaces                          (Elist25)\n+   --    Dispatch_Table_Wrappers             (Elist26)  (base type only)\n    --    Has_Completion                      (Flag26)\n    --    Has_Record_Rep_Clause               (Flag65)   (base type only)\n    --    Has_External_Tag_Rep_Clause         (Flag110)"}, {"sha": "6b3d8645c63be0a042eabd1d8c4df1487d262d2a", "filename": "gcc/ada/s-stalib.ads", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04cbd48e9ed3fbd4c66f7ebc829276b5b83932a5/gcc%2Fada%2Fs-stalib.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04cbd48e9ed3fbd4c66f7ebc829276b5b83932a5/gcc%2Fada%2Fs-stalib.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-stalib.ads?ref=04cbd48e9ed3fbd4c66f7ebc829276b5b83932a5", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2010, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -33,11 +33,11 @@\n --  are required to be part of every Ada program. A special mechanism is\n --  required to ensure that these are loaded, since it may be the case in\n --  some programs that the only references to these required packages are\n---  from C code or from code generated directly by Gigi, an in both cases\n+--  from C code or from code generated directly by Gigi, and in both cases\n --  the binder is not aware of such references.\n \n --  System.Standard_Library also includes data that must be present in every\n---  program, in particular the definitions of all the standard and also some\n+--  program, in particular data for all the standard exceptions, and also some\n --  subprograms that must be present in every program.\n \n --  The binder unconditionally includes s-stalib.ali, which ensures that this"}, {"sha": "e28ee59f106126767aa5f096ca6e726cd8862cf8", "filename": "gcc/ada/urealp.adb", "status": "modified", "additions": 235, "deletions": 259, "changes": 494, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04cbd48e9ed3fbd4c66f7ebc829276b5b83932a5/gcc%2Fada%2Furealp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04cbd48e9ed3fbd4c66f7ebc829276b5b83932a5/gcc%2Fada%2Furealp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Furealp.adb?ref=04cbd48e9ed3fbd4c66f7ebc829276b5b83932a5", "patch": "@@ -44,7 +44,7 @@ package body Urealp is\n       Num  : Uint;\n       --  Numerator (always non-negative)\n \n-      Den  : Uint;\n+      Den : Uint;\n       --  Denominator (always non-zero, always positive if base is zero)\n \n       Rbase : Nat;\n@@ -80,20 +80,20 @@ package body Urealp is\n    --  The following universal reals are the values returned by the constant\n    --  functions. They are initialized by the initialization procedure.\n \n-   UR_0          : Ureal;\n-   UR_M_0        : Ureal;\n-   UR_Tenth      : Ureal;\n-   UR_Half       : Ureal;\n-   UR_1          : Ureal;\n-   UR_2          : Ureal;\n-   UR_10         : Ureal;\n-   UR_10_36      : Ureal;\n-   UR_M_10_36    : Ureal;\n-   UR_100        : Ureal;\n-   UR_2_128      : Ureal;\n-   UR_2_80       : Ureal;\n-   UR_2_M_128    : Ureal;\n-   UR_2_M_80     : Ureal;\n+   UR_0       : Ureal;\n+   UR_M_0     : Ureal;\n+   UR_Tenth   : Ureal;\n+   UR_Half    : Ureal;\n+   UR_1       : Ureal;\n+   UR_2       : Ureal;\n+   UR_10      : Ureal;\n+   UR_10_36   : Ureal;\n+   UR_M_10_36 : Ureal;\n+   UR_100     : Ureal;\n+   UR_2_128   : Ureal;\n+   UR_2_80    : Ureal;\n+   UR_2_M_128 : Ureal;\n+   UR_2_M_80  : Ureal;\n \n    Num_Ureal_Constants : constant := 10;\n    --  This is used for an assertion check in Tree_Read and Tree_Write to\n@@ -134,18 +134,22 @@ package body Urealp is\n    --  Return true if the real quotient of Num / Den is an integer value\n \n    function Normalize (Val : Ureal_Entry) return Ureal_Entry;\n-   --  Normalizes the Ureal_Entry by reducing it to lowest terms (with a\n-   --  base value of 0).\n+   --  Normalizes the Ureal_Entry by reducing it to lowest terms (with a base\n+   --  value of 0).\n \n    function Same (U1, U2 : Ureal) return Boolean;\n    pragma Inline (Same);\n    --  Determines if U1 and U2 are the same Ureal. Note that we cannot use\n-   --  the equals operator for this test, since that tests for equality,\n-   --  not identity.\n+   --  the equals operator for this test, since that tests for equality, not\n+   --  identity.\n \n    function Store_Ureal (Val : Ureal_Entry) return Ureal;\n-   --  This store a new entry in the universal reals table and return\n-   --  its index in the table.\n+   --  This store a new entry in the universal reals table and return its index\n+   --  in the table.\n+\n+   function Store_Ureal_Normalized (Val : Ureal_Entry) return Ureal;\n+   pragma Inline (Store_Ureal_Normalized);\n+   --  Like Store_Ureal, but normalizes its operand first.\n \n    -------------------------\n    -- Decimal_Exponent_Hi --\n@@ -451,6 +455,15 @@ package body Urealp is\n       return Ureals.Last;\n    end Store_Ureal;\n \n+   ----------------------------\n+   -- Store_Ureal_Normalized --\n+   ----------------------------\n+\n+   function Store_Ureal_Normalized (Val : Ureal_Entry) return Ureal is\n+   begin\n+      return Store_Ureal (Normalize (Val));\n+   end Store_Ureal_Normalized;\n+\n    ---------------\n    -- Tree_Read --\n    ---------------\n@@ -505,11 +518,11 @@ package body Urealp is\n       Val : constant Ureal_Entry := Ureals.Table (Real);\n \n    begin\n-      return Store_Ureal (\n-               (Num      => Val.Num,\n-                Den      => Val.Den,\n-                Rbase    => Val.Rbase,\n-                Negative => False));\n+      return Store_Ureal\n+               ((Num      => Val.Num,\n+                 Den      => Val.Den,\n+                 Rbase    => Val.Rbase,\n+                 Negative => False));\n    end UR_Abs;\n \n    ------------\n@@ -529,7 +542,6 @@ package body Urealp is\n    function UR_Add (Left : Ureal; Right : Ureal) return Ureal is\n       Lval : Ureal_Entry := Ureals.Table (Left);\n       Rval : Ureal_Entry := Ureals.Table (Right);\n-\n       Num  : Uint;\n \n    begin\n@@ -538,7 +550,6 @@ package body Urealp is\n       --  be negative, even though in stored entries this can never be so)\n \n       if Lval.Rbase /= 0 and then Lval.Rbase = Rval.Rbase then\n-\n          declare\n             Opd_Min, Opd_Max   : Ureal_Entry;\n             Exp_Min, Exp_Max   : Uint;\n@@ -568,18 +579,18 @@ package body Urealp is\n               Opd_Min.Num * Lval.Rbase ** (Exp_Max - Exp_Min) + Opd_Max.Num;\n \n             if Num = 0 then\n-               return Store_Ureal (\n-                        (Num      => Uint_0,\n-                         Den      => Uint_1,\n-                         Rbase    => 0,\n-                         Negative => Lval.Negative));\n+               return Store_Ureal\n+                        ((Num      => Uint_0,\n+                          Den      => Uint_1,\n+                          Rbase    => 0,\n+                          Negative => Lval.Negative));\n \n             else\n-               return Store_Ureal (\n-                        (Num      => abs Num,\n-                         Den      => Exp_Max,\n-                         Rbase    => Lval.Rbase,\n-                         Negative => (Num < 0)));\n+               return Store_Ureal\n+                        ((Num      => abs Num,\n+                          Den      => Exp_Max,\n+                          Rbase    => Lval.Rbase,\n+                          Negative => (Num < 0)));\n             end if;\n          end;\n \n@@ -600,19 +611,18 @@ package body Urealp is\n             Num := (Ln.Num * Rn.Den) + (Rn.Num * Ln.Den);\n \n             if Num = 0 then\n-               return Store_Ureal (\n-                        (Num      => Uint_0,\n-                         Den      => Uint_1,\n-                         Rbase    => 0,\n-                         Negative => Lval.Negative));\n+               return Store_Ureal\n+                        ((Num      => Uint_0,\n+                          Den      => Uint_1,\n+                          Rbase    => 0,\n+                          Negative => Lval.Negative));\n \n             else\n-               return Store_Ureal (\n-                        Normalize (\n-                          (Num      => abs Num,\n-                           Den      => Ln.Den * Rn.Den,\n-                           Rbase    => 0,\n-                           Negative => (Num < 0))));\n+               return Store_Ureal_Normalized\n+                        ((Num      => abs Num,\n+                          Den      => Ln.Den * Rn.Den,\n+                          Rbase    => 0,\n+                          Negative => (Num < 0)));\n             end if;\n          end;\n       end if;\n@@ -624,7 +634,6 @@ package body Urealp is\n \n    function UR_Ceiling (Real : Ureal) return Uint is\n       Val : constant Ureal_Entry := Normalize (Ureals.Table (Real));\n-\n    begin\n       if Val.Negative then\n          return UI_Negate (Val.Num / Val.Den);\n@@ -656,56 +665,51 @@ package body Urealp is\n       pragma Assert (Rval.Num /= Uint_0);\n \n       if Lval.Rbase = 0 then\n-\n          if Rval.Rbase = 0 then\n-            return Store_Ureal (\n-                     Normalize (\n-                       (Num      => Lval.Num * Rval.Den,\n-                        Den      => Lval.Den * Rval.Num,\n-                        Rbase    => 0,\n-                        Negative => Rneg)));\n+            return Store_Ureal_Normalized\n+                     ((Num      => Lval.Num * Rval.Den,\n+                       Den      => Lval.Den * Rval.Num,\n+                       Rbase    => 0,\n+                       Negative => Rneg));\n \n          elsif Is_Integer (Lval.Num, Rval.Num * Lval.Den) then\n-            return Store_Ureal (\n-                     (Num      => Lval.Num / (Rval.Num * Lval.Den),\n-                      Den      => (-Rval.Den),\n-                      Rbase    => Rval.Rbase,\n-                      Negative => Rneg));\n+            return Store_Ureal\n+                     ((Num      => Lval.Num / (Rval.Num * Lval.Den),\n+                       Den      => (-Rval.Den),\n+                       Rbase    => Rval.Rbase,\n+                       Negative => Rneg));\n \n          elsif Rval.Den < 0 then\n-            return Store_Ureal (\n-                     Normalize (\n-                       (Num      => Lval.Num,\n-                        Den      => Rval.Rbase ** (-Rval.Den) *\n-                                    Rval.Num *\n-                                    Lval.Den,\n-                        Rbase    => 0,\n-                        Negative => Rneg)));\n+            return Store_Ureal_Normalized\n+                     ((Num      => Lval.Num,\n+                       Den      => Rval.Rbase ** (-Rval.Den) *\n+                                   Rval.Num *\n+                                   Lval.Den,\n+                       Rbase    => 0,\n+                       Negative => Rneg));\n \n          else\n-            return Store_Ureal (\n-                     Normalize (\n-                       (Num      => Lval.Num * Rval.Rbase ** Rval.Den,\n-                        Den      => Rval.Num * Lval.Den,\n-                        Rbase    => 0,\n-                        Negative => Rneg)));\n+            return Store_Ureal_Normalized\n+                     ((Num      => Lval.Num * Rval.Rbase ** Rval.Den,\n+                       Den      => Rval.Num * Lval.Den,\n+                       Rbase    => 0,\n+                       Negative => Rneg));\n          end if;\n \n       elsif Is_Integer (Lval.Num, Rval.Num) then\n-\n          if Rval.Rbase = Lval.Rbase then\n-            return Store_Ureal (\n-                     (Num      => Lval.Num / Rval.Num,\n-                      Den      => Lval.Den - Rval.Den,\n-                      Rbase    => Lval.Rbase,\n-                      Negative => Rneg));\n+            return Store_Ureal\n+                     ((Num      => Lval.Num / Rval.Num,\n+                       Den      => Lval.Den - Rval.Den,\n+                       Rbase    => Lval.Rbase,\n+                       Negative => Rneg));\n \n          elsif Rval.Rbase = 0 then\n-            return Store_Ureal (\n-                     (Num      => (Lval.Num / Rval.Num) * Rval.Den,\n-                      Den      => Lval.Den,\n-                      Rbase    => Lval.Rbase,\n-                      Negative => Rneg));\n+            return Store_Ureal\n+                     ((Num      => (Lval.Num / Rval.Num) * Rval.Den,\n+                       Den      => Lval.Den,\n+                       Rbase    => Lval.Rbase,\n+                       Negative => Rneg));\n \n          elsif Rval.Den < 0 then\n             declare\n@@ -721,20 +725,20 @@ package body Urealp is\n                          (Rval.Rbase ** (-Rval.Den));\n                end if;\n \n-               return Store_Ureal (\n-                        (Num      => Num,\n-                         Den      => Den,\n-                         Rbase    => 0,\n-                         Negative => Rneg));\n+               return Store_Ureal\n+                        ((Num      => Num,\n+                          Den      => Den,\n+                          Rbase    => 0,\n+                          Negative => Rneg));\n             end;\n \n          else\n-            return Store_Ureal (\n-                     (Num      => (Lval.Num / Rval.Num) *\n-                                  (Rval.Rbase ** Rval.Den),\n-                      Den      => Lval.Den,\n-                      Rbase    => Lval.Rbase,\n-                      Negative => Rneg));\n+            return Store_Ureal\n+                     ((Num      => (Lval.Num / Rval.Num) *\n+                                   (Rval.Rbase ** Rval.Den),\n+                       Den      => Lval.Den,\n+                       Rbase    => Lval.Rbase,\n+                       Negative => Rneg));\n          end if;\n \n       else\n@@ -745,7 +749,6 @@ package body Urealp is\n             if Lval.Den < 0 then\n                Num := Lval.Num * (Lval.Rbase ** (-Lval.Den));\n                Den := Rval.Num;\n-\n             else\n                Num := Lval.Num;\n                Den := Rval.Num * (Lval.Rbase ** Lval.Den);\n@@ -762,12 +765,11 @@ package body Urealp is\n                Num := Num * Rval.Den;\n             end if;\n \n-            return Store_Ureal (\n-                     Normalize (\n-                       (Num      => Num,\n-                        Den      => Den,\n-                        Rbase    => 0,\n-                        Negative => Rneg)));\n+            return Store_Ureal_Normalized\n+                     ((Num      => Num,\n+                       Den      => Den,\n+                       Rbase    => 0,\n+                       Negative => Rneg));\n          end;\n       end if;\n    end UR_Div;\n@@ -814,11 +816,11 @@ package body Urealp is\n       if IBas <= 16\n         and then UR_From_Uint (IBas) = Bas\n       then\n-         return Store_Ureal (\n-                 (Num      => Uint_1,\n-                  Den      => -N,\n-                  Rbase    => UI_To_Int (UR_Trunc (Bas)),\n-                  Negative => Neg));\n+         return Store_Ureal\n+                  ((Num      => Uint_1,\n+                    Den      => -N,\n+                    Rbase    => UI_To_Int (UR_Trunc (Bas)),\n+                    Negative => Neg));\n \n       --  If the exponent is negative then we raise the numerator and the\n       --  denominator (after normalization) to the absolute value of the\n@@ -829,11 +831,11 @@ package body Urealp is\n          pragma Assert (Val.Num /= 0);\n          Val := Normalize (Val);\n \n-         return Store_Ureal (\n-                 (Num      => Val.Den ** X,\n-                  Den      => Val.Num ** X,\n-                  Rbase    => 0,\n-                  Negative => Neg));\n+         return Store_Ureal\n+                  ((Num      => Val.Den ** X,\n+                    Den      => Val.Num ** X,\n+                    Rbase    => 0,\n+                    Negative => Neg));\n \n       --  If positive, we distinguish the case when the base is not zero, in\n       --  which case the new denominator is just the product of the old one\n@@ -842,21 +844,21 @@ package body Urealp is\n       else\n          if Val.Rbase /= 0 then\n \n-            return Store_Ureal (\n-                    (Num      => Val.Num ** X,\n-                     Den      => Val.Den * X,\n-                     Rbase    => Val.Rbase,\n-                     Negative => Neg));\n+            return Store_Ureal\n+                     ((Num      => Val.Num ** X,\n+                       Den      => Val.Den * X,\n+                       Rbase    => Val.Rbase,\n+                       Negative => Neg));\n \n          --  And when the base is zero, in which case we exponentiate\n          --  the old denominator.\n \n          else\n-            return Store_Ureal (\n-                    (Num      => Val.Num ** X,\n-                     Den      => Val.Den ** X,\n-                     Rbase    => 0,\n-                     Negative => Neg));\n+            return Store_Ureal\n+                     ((Num      => Val.Num ** X,\n+                       Den      => Val.Den ** X,\n+                       Rbase    => 0,\n+                       Negative => Neg));\n          end if;\n       end if;\n    end UR_Exponentiate;\n@@ -867,7 +869,6 @@ package body Urealp is\n \n    function UR_Floor (Real : Ureal) return Uint is\n       Val : constant Ureal_Entry := Normalize (Ureals.Table (Real));\n-\n    begin\n       if Val.Negative then\n          return UI_Negate ((Val.Num + Val.Den - 1) / Val.Den);\n@@ -888,11 +889,11 @@ package body Urealp is\n       return     Ureal\n    is\n    begin\n-      return Store_Ureal (\n-               (Num      => Num,\n-                Den      => Den,\n-                Rbase    => Rbase,\n-                Negative => Negative));\n+      return Store_Ureal\n+               ((Num      => Num,\n+                 Den      => Den,\n+                 Rbase    => Rbase,\n+                 Negative => Negative));\n    end UR_From_Components;\n \n    ------------------\n@@ -902,7 +903,7 @@ package body Urealp is\n    function UR_From_Uint (UI : Uint) return Ureal is\n    begin\n       return UR_From_Components\n-        (abs UI, Uint_1, Negative => (UI < 0));\n+               (abs UI, Uint_1, Negative => (UI < 0));\n    end UR_From_Uint;\n \n    -----------\n@@ -1095,67 +1096,62 @@ package body Urealp is\n    begin\n       if Lval.Rbase = 0 then\n          if Rval.Rbase = 0 then\n-            return Store_Ureal (\n-                     Normalize (\n-                        (Num      => Num,\n-                         Den      => Lval.Den * Rval.Den,\n-                         Rbase    => 0,\n-                         Negative => Rneg)));\n+            return Store_Ureal_Normalized\n+                     ((Num      => Num,\n+                       Den      => Lval.Den * Rval.Den,\n+                       Rbase    => 0,\n+                       Negative => Rneg));\n \n          elsif Is_Integer (Num, Lval.Den) then\n-            return Store_Ureal (\n-                     (Num      => Num / Lval.Den,\n-                      Den      => Rval.Den,\n-                      Rbase    => Rval.Rbase,\n-                      Negative => Rneg));\n+            return Store_Ureal\n+                     ((Num      => Num / Lval.Den,\n+                       Den      => Rval.Den,\n+                       Rbase    => Rval.Rbase,\n+                       Negative => Rneg));\n \n          elsif Rval.Den < 0 then\n-            return Store_Ureal (\n-                     Normalize (\n-                       (Num      => Num * (Rval.Rbase ** (-Rval.Den)),\n-                        Den      => Lval.Den,\n-                        Rbase    => 0,\n-                        Negative => Rneg)));\n+            return Store_Ureal_Normalized\n+                     ((Num      => Num * (Rval.Rbase ** (-Rval.Den)),\n+                       Den      => Lval.Den,\n+                       Rbase    => 0,\n+                       Negative => Rneg));\n \n          else\n-            return Store_Ureal (\n-                     Normalize (\n-                       (Num      => Num,\n-                        Den      => Lval.Den * (Rval.Rbase ** Rval.Den),\n-                        Rbase    => 0,\n-                        Negative => Rneg)));\n+            return Store_Ureal_Normalized\n+                     ((Num      => Num,\n+                       Den      => Lval.Den * (Rval.Rbase ** Rval.Den),\n+                       Rbase    => 0,\n+                       Negative => Rneg));\n          end if;\n \n       elsif Lval.Rbase = Rval.Rbase then\n-         return Store_Ureal (\n-                  (Num      => Num,\n-                   Den      => Lval.Den + Rval.Den,\n-                   Rbase    => Lval.Rbase,\n-                   Negative => Rneg));\n+         return Store_Ureal\n+                  ((Num      => Num,\n+                    Den      => Lval.Den + Rval.Den,\n+                    Rbase    => Lval.Rbase,\n+                    Negative => Rneg));\n \n       elsif Rval.Rbase = 0 then\n          if Is_Integer (Num, Rval.Den) then\n-            return Store_Ureal (\n-                     (Num      => Num / Rval.Den,\n-                      Den      => Lval.Den,\n-                      Rbase    => Lval.Rbase,\n-                      Negative => Rneg));\n+            return Store_Ureal\n+                     ((Num      => Num / Rval.Den,\n+                       Den      => Lval.Den,\n+                       Rbase    => Lval.Rbase,\n+                       Negative => Rneg));\n \n          elsif Lval.Den < 0 then\n-            return Store_Ureal (\n-                     Normalize (\n-                       (Num      => Num * (Lval.Rbase ** (-Lval.Den)),\n-                        Den      => Rval.Den,\n-                        Rbase    => 0,\n-                        Negative => Rneg)));\n+            return Store_Ureal_Normalized\n+                     ((Num      => Num * (Lval.Rbase ** (-Lval.Den)),\n+                       Den      => Rval.Den,\n+                       Rbase    => 0,\n+                       Negative => Rneg));\n \n          else\n-            return Store_Ureal (\n-                     Normalize (\n-                       (Num      => Num,\n-                        Den      => Rval.Den * (Lval.Rbase ** Lval.Den),\n-                        Rbase    => 0,\n-                        Negative => Rneg)));\n+            return Store_Ureal_Normalized\n+                     ((Num      => Num,\n+                       Den      => Rval.Den * (Lval.Rbase ** Lval.Den),\n+                       Rbase    => 0,\n+                       Negative => Rneg));\n          end if;\n \n       else\n@@ -1173,12 +1169,11 @@ package body Urealp is\n             Den := Den * (Rval.Rbase ** Rval.Den);\n          end if;\n \n-         return Store_Ureal (\n-                  Normalize (\n-                    (Num      => Num,\n-                     Den      => Den,\n-                     Rbase    => 0,\n-                     Negative => Rneg)));\n+         return Store_Ureal_Normalized\n+                  ((Num      => Num,\n+                    Den      => Den,\n+                    Rbase    => 0,\n+                    Negative => Rneg));\n       end if;\n    end UR_Mul;\n \n@@ -1228,8 +1223,8 @@ package body Urealp is\n             else\n                Result :=\n                   Rval.Negative /= Lval.Negative\n-                   or else Rval.Num /= Lval.Num\n-                   or else Rval.Den /= Lval.Den;\n+                    or else Rval.Num /= Lval.Num\n+                    or else Rval.Den /= Lval.Den;\n                Release (Imrk);\n                Release (Rmrk);\n                return Result;\n@@ -1244,11 +1239,11 @@ package body Urealp is\n \n    function UR_Negate (Real : Ureal) return Ureal is\n    begin\n-      return Store_Ureal (\n-               (Num      => Ureals.Table (Real).Num,\n-                Den      => Ureals.Table (Real).Den,\n-                Rbase    => Ureals.Table (Real).Rbase,\n-                Negative => not Ureals.Table (Real).Negative));\n+      return Store_Ureal\n+               ((Num      => Ureals.Table (Real).Num,\n+                 Den      => Ureals.Table (Real).Den,\n+                 Rbase    => Ureals.Table (Real).Rbase,\n+                 Negative => not Ureals.Table (Real).Negative));\n    end UR_Negate;\n \n    ------------\n@@ -1294,7 +1289,6 @@ package body Urealp is\n \n    function UR_Trunc (Real : Ureal) return Uint is\n       Val : constant Ureal_Entry := Normalize (Ureals.Table (Real));\n-\n    begin\n       if Val.Negative then\n          return -(Val.Num / Val.Den);\n@@ -1371,98 +1365,80 @@ package body Urealp is\n             Write_Str (\".0\");\n          end if;\n \n-      --  Constants in base 2, 10 or 16 can be written in normal Ada literal\n+      --  Constants in base 10 or 16 can be written in normal Ada literal\n       --  style, as long as they fit in the UI_Image_Buffer. Using hexadecimal\n       --  notation, 4 bytes are required for the 16# # part, and every fifth\n       --  character is an underscore. So, a buffer of size N has room for\n-\n-      --     ((N - 4) - (N - 4) / 5) * 4 bits\n-\n-      --   or at least\n-\n-      --     N * 16 / 5 - 12 bits\n+      --     ((N - 4) - (N - 4) / 5) * 4 bits,\n+      --  or at least\n+      --     N * 16 / 5 - 12 bits.\n \n       elsif (Val.Rbase = 10 or else Val.Rbase = 16)\n         and then Num_Bits (Val.Num) < UI_Image_Buffer'Length * 16 / 5 - 12\n       then\n-         declare\n-            Format : UI_Format := Decimal;\n-            Scale  : Uint;\n+         pragma Assert (Val.Den /= 0);\n \n-         begin\n-            if Val.Rbase = 16 then\n-               Write_Str (\"16#\");\n-               Format := Hex;\n-            end if;\n-\n-            --  Use fixed-point format for small scaling values\n+         --  Use fixed-point format for small scaling values\n \n-            if Val.Den = 1 then\n-               UI_Write (Val.Num / Val.Rbase, Format);\n-               Write_Char ('.');\n-               UI_Write (Val.Num mod Val.Rbase, Format);\n+         if (Val.Rbase = 10 and then Val.Den < 0 and then Val.Den > -3)\n+              or else (Val.Rbase = 16 and then Val.Den = -1)\n+         then\n+            UI_Write (Val.Num * Val.Rbase**(-Val.Den), Decimal);\n+            Write_Str (\".0\");\n \n-            elsif Val.Den = 2 then\n-               UI_Write (Val.Num / Val.Rbase**Uint_2, Format);\n-               Write_Char ('.');\n-               UI_Write (Val.Num mod Val.Rbase**Uint_2 / Val.Rbase, Format);\n-               UI_Write (Val.Num mod Val.Rbase, Format);\n+         --  Write hexadecimal constants in exponential notation with a zero\n+         --  unit digit. This matches the Ada canonical form for floating point\n+         --  numbers, and also ensures that the underscores end up in the\n+         --  correct place.\n \n-            elsif Val.Den = -1 then\n-               UI_Write (Val.Num, Format);\n-               Write_Str (\"0.0\");\n+         elsif Val.Rbase = 16 then\n+            UI_Image (Val.Num, Hex);\n+            pragma Assert (Val.Rbase = 16);\n \n-            elsif Val.Den = -2 then\n-               UI_Write (Val.Num, Format);\n-               Write_Str (\"00.0\");\n+            Write_Str (\"16#0.\");\n+            Write_Str (UI_Image_Buffer (4 .. UI_Image_Length));\n \n-            --  Else use exponential format\n+            --  For exponent, exclude 16# # and underscores from length\n \n-            else\n-               UI_Image (Val.Num, Format);\n-               Scale := UI_From_Int (Int (UI_Image_Length));\n+            UI_Image_Length := UI_Image_Length - 4;\n+            UI_Image_Length := UI_Image_Length - UI_Image_Length / 5;\n \n-               if Format = Decimal then\n+            Write_Char ('E');\n+            UI_Write (Int (UI_Image_Length) - Val.Den, Decimal);\n \n-                  --  Write decimal constants with a non-zero unit digit. This\n-                  --  matches usual scientific notation.\n+         elsif Val.Den = 1 then\n+            UI_Write (Val.Num / 10, Decimal);\n+            Write_Char ('.');\n+            UI_Write (Val.Num mod 10, Decimal);\n \n-                  Write_Char (UI_Image_Buffer (1));\n-                  Write_Char ('.');\n+         elsif Val.Den = 2 then\n+            UI_Write (Val.Num / 100, Decimal);\n+            Write_Char ('.');\n+            UI_Write (Val.Num / 10 mod 10, Decimal);\n+            UI_Write (Val.Num mod 10, Decimal);\n \n-                  if UI_Image_Length = 1 then\n-                     Write_Char ('0');\n-                  else\n-                     Write_Str (UI_Image_Buffer (2 .. UI_Image_Length));\n-                  end if;\n+         --  Else use decimal exponential format\n \n-                  Scale := Scale - 1; -- First digit is at unit position\n-               else\n-                  pragma Assert (Format = Hex);\n-\n-                  --  Write hexadecimal constants with a zero unit digit. This\n-                  --  matches the Ada canonical form for binary floating point\n-                  --  numbers, and also ensures that the underscores end up in\n-                  --  the correct place.\n+         else\n+            --  Write decimal constants with a non-zero unit digit. This\n+            --  matches usual scientific notation.\n \n-                  Write_Str (\"0.\");\n-                  Write_Str (UI_Image_Buffer (4 .. UI_Image_Length));\n-                  Scale := Scale - 4;         -- Subtract 16# #\n-                  Scale := Scale - Scale / 5; -- Subtract underscores;\n-               end if;\n+            UI_Image (Val.Num, Decimal);\n+            Write_Char (UI_Image_Buffer (1));\n+            Write_Char ('.');\n \n-               Write_Char ('E');\n-               Format := Decimal;\n-               UI_Write (Scale - Val.Den, Decimal);\n+            if UI_Image_Length = 1 then\n+               Write_Char ('0');\n+            else\n+               Write_Str (UI_Image_Buffer (2 .. UI_Image_Length));\n             end if;\n \n-            if Format = Hex then\n-               Write_Char ('#');\n-            end if;\n-         end;\n+            Write_Char ('E');\n+            UI_Write (Int (UI_Image_Length - 1) - Val.Den, Decimal);\n+         end if;\n \n-      --  Constants in a base other than 10 can still be easily written\n-      --  in normal Ada literal style if the numerator is one.\n+      --  Constants in a base other than 10 can still be easily written in\n+      --  normal Ada literal style if the numerator is one.\n \n       elsif Val.Rbase /= 0 and then Val.Num = 1 then\n          Write_Int (Val.Rbase);"}, {"sha": "1c76c316ed04cedc93a3efe2ac3721d0539bdbe0", "filename": "gcc/ada/xeinfo.adb", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04cbd48e9ed3fbd4c66f7ebc829276b5b83932a5/gcc%2Fada%2Fxeinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04cbd48e9ed3fbd4c66f7ebc829276b5b83932a5/gcc%2Fada%2Fxeinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fxeinfo.adb?ref=04cbd48e9ed3fbd4c66f7ebc829276b5b83932a5", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2008, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2010, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -348,6 +348,7 @@ begin\n       --  Case of type declaration\n \n       elsif Match (Line, F_Typ) then\n+\n          --  Process type declaration (must be enumeration type)\n \n          Ctr := 0;\n@@ -371,6 +372,7 @@ begin\n    end loop;\n \n    --  Process function declarations\n+\n    --  Note: Lastinlined used to control blank lines\n \n    Put_Line (Ofile, \"\");"}]}