{"sha": "137073d34a47fe14f97e35f69d3941b2ef0bb5c1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTM3MDczZDM0YTQ3ZmUxNGY5N2UzNWY2OWQzOTQxYjJlZjBiYjVjMQ==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2017-10-31T12:50:19Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2017-10-31T12:50:19Z"}, "message": "[C++ PATCH] overloaded operator fns [1/N]\n\nhttps://gcc.gnu.org/ml/gcc-patches/2017-10/msg02315.html\n\t* cp-tree.h (assign_op_identifier, call_op_identifier): Define.\n\t(LAMBDA_FUNCTION_P): Use DECL_OVERLOADED_OPERATOR_IS.\n\t(DECL_OVERLOADED_OPERATOR_P): Just retuurn true/false.\n\t(DECL_OVERLOADED_OPERATOR_CODE, DECL_OVERLOADED_OPERATOR_IS): Define.\n\t* call.c (add_function_candidate): Use\n\tDECL_OVERLOADED_OPERATOR_IS.\n\t(build_op_call_1): Use call_op_identifier &\n\tDECL_OVERLOADED_OPERATOR_IS.\n\t(build_over_call): Likewise.\n\t(has_trivial_copy_assign_p): Use assign_op_identifier.\n\t(build_special_member_call): Likewise.\n\t* class.c (dfs_declare_virt_assop_and_dtor): Likewise.\n\t(vbase_has_user_provided_move_assign,\n\tclasstype_has_move_assign_or_move_ctor_p): Likewise.\n\t* decl.c (duplicate_decls): Use DECL_OVERLOADED_OPERATOR_CODE.\n\t(grok_special_member_properties): Use assign_op_identifier.\n\t(start_preparsed_function): Use DECL_OVERLOADED_OPERATOR_IS.\n\t* decl2.c (mark_used): Use DECL_CONV_FN_P.\n\t* dump.c (dump_access): Delete prototype.\n\t(dump_op): Delete.\n\t(cp_dump_tree): Don't call it.\n\t* lambda.c (lambda_function): Use call_op_identifier.\n\t(maybe_add_lambda_conv_op): Not an overloaded operator.  Remove\n\tunneeded braces.\n\t* mangle.c (write_unqualified_name): Use DECL_OVERLOADED_OPERTOR_CODE.\n\t* method.c (do_build_copy_assign): Use assign_op_identifier.\n\t(synthesize_method): Use DECL_OVERLOADED_OPERATOR_IS.\n\t(get_copy_assign): Use assign_op_identifier.\n\t(synthesized_method_walk): Likewise.\n\t(defaultable_fn_check): Use DECL_OVERLOADED_OPERATOR_IS.\n\t* parser.c (cp_parser_lambda_declarator_opt): Use\n\tcall_op_identifier.\n\t* semanitics.c (classtype_has_nothrow_assign_or_copy_p): Use\n\tassign_op_identifier.\n\t* tree.c (special_function_p):  Use DECL_OVERLOADED_OPERATOR_IS.\n\t* typeck.c (check_return_expr): Use DECL_OVERLOADED_OPERATOR_CODE.\n\t(check_return_expr): Use assign_op_identifier.\n\nFrom-SVN: r254263", "tree": {"sha": "f744b2bf587a0a0316bd56618e284cc04aa509f4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f744b2bf587a0a0316bd56618e284cc04aa509f4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/137073d34a47fe14f97e35f69d3941b2ef0bb5c1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/137073d34a47fe14f97e35f69d3941b2ef0bb5c1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/137073d34a47fe14f97e35f69d3941b2ef0bb5c1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/137073d34a47fe14f97e35f69d3941b2ef0bb5c1/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8a3f457f148b7114dfa37927b73410eecc986a33", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a3f457f148b7114dfa37927b73410eecc986a33", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8a3f457f148b7114dfa37927b73410eecc986a33"}], "stats": {"total": 332, "additions": 110, "deletions": 222}, "files": [{"sha": "7ab9cf30065c136b49fe1049f1e7517a707cb8b0", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/137073d34a47fe14f97e35f69d3941b2ef0bb5c1/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/137073d34a47fe14f97e35f69d3941b2ef0bb5c1/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=137073d34a47fe14f97e35f69d3941b2ef0bb5c1", "patch": "@@ -1,3 +1,43 @@\n+2017-10-31  Nathan Sidwell  <nathan@acm.org>\n+\n+\t* cp-tree.h (assign_op_identifier, call_op_identifier): Define.\n+\t(LAMBDA_FUNCTION_P): Use DECL_OVERLOADED_OPERATOR_IS.\n+\t(DECL_OVERLOADED_OPERATOR_P): Just retuurn true/false.\n+\t(DECL_OVERLOADED_OPERATOR_CODE, DECL_OVERLOADED_OPERATOR_IS): Define.\n+\t* call.c (add_function_candidate): Use\n+\tDECL_OVERLOADED_OPERATOR_IS.\n+\t(build_op_call_1): Use call_op_identifier &\n+\tDECL_OVERLOADED_OPERATOR_IS.\n+\t(build_over_call): Likewise.\n+\t(has_trivial_copy_assign_p): Use assign_op_identifier.\n+\t(build_special_member_call): Likewise.\n+\t* class.c (dfs_declare_virt_assop_and_dtor): Likewise.\n+\t(vbase_has_user_provided_move_assign,\n+\tclasstype_has_move_assign_or_move_ctor_p): Likewise.\n+\t* decl.c (duplicate_decls): Use DECL_OVERLOADED_OPERATOR_CODE.\n+\t(grok_special_member_properties): Use assign_op_identifier.\n+\t(start_preparsed_function): Use DECL_OVERLOADED_OPERATOR_IS.\n+\t* decl2.c (mark_used): Use DECL_CONV_FN_P.\n+\t* dump.c (dump_access): Delete prototype.\n+\t(dump_op): Delete.\n+\t(cp_dump_tree): Don't call it.\n+\t* lambda.c (lambda_function): Use call_op_identifier.\n+\t(maybe_add_lambda_conv_op): Not an overloaded operator.  Remove\n+\tunneeded braces.\n+\t* mangle.c (write_unqualified_name): Use DECL_OVERLOADED_OPERTOR_CODE.\n+\t* method.c (do_build_copy_assign): Use assign_op_identifier.\n+\t(synthesize_method): Use DECL_OVERLOADED_OPERATOR_IS.\n+\t(get_copy_assign): Use assign_op_identifier.\n+\t(synthesized_method_walk): Likewise.\n+\t(defaultable_fn_check): Use DECL_OVERLOADED_OPERATOR_IS.\n+\t* parser.c (cp_parser_lambda_declarator_opt): Use\n+\tcall_op_identifier.\n+\t* semanitics.c (classtype_has_nothrow_assign_or_copy_p): Use\n+\tassign_op_identifier.\n+\t* tree.c (special_function_p):  Use DECL_OVERLOADED_OPERATOR_IS.\n+\t* typeck.c (check_return_expr): Use DECL_OVERLOADED_OPERATOR_CODE.\n+\t(check_return_expr): Use assign_op_identifier.\n+\n 2017-10-30  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR c++/82085"}, {"sha": "d899d45ec6dbc1c48a5dd1a9d28126efe9288c6b", "filename": "gcc/cp/call.c", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/137073d34a47fe14f97e35f69d3941b2ef0bb5c1/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/137073d34a47fe14f97e35f69d3941b2ef0bb5c1/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=137073d34a47fe14f97e35f69d3941b2ef0bb5c1", "patch": "@@ -2082,7 +2082,7 @@ add_function_candidate (struct z_candidate **candidates,\n       if (DECL_CONSTRUCTOR_P (fn))\n \ti = 1;\n       else if (DECL_ASSIGNMENT_OPERATOR_P (fn)\n-\t       && DECL_OVERLOADED_OPERATOR_P (fn) == NOP_EXPR)\n+\t       && DECL_OVERLOADED_OPERATOR_IS (fn, NOP_EXPR))\n \ti = 2;\n       else\n \ti = 0;\n@@ -4474,7 +4474,7 @@ build_op_call_1 (tree obj, vec<tree, va_gc> **args, tsubst_flags_t complain)\n \n   if (TYPE_BINFO (type))\n     {\n-      fns = lookup_fnfields (TYPE_BINFO (type), cp_operator_id (CALL_EXPR), 1);\n+      fns = lookup_fnfields (TYPE_BINFO (type), call_op_identifier, 1);\n       if (fns == error_mark_node)\n \treturn error_mark_node;\n     }\n@@ -4557,11 +4557,9 @@ build_op_call_1 (tree obj, vec<tree, va_gc> **args, tsubst_flags_t complain)\n             }\n \t  result = error_mark_node;\n \t}\n-      /* Since cand->fn will be a type, not a function, for a conversion\n-\t function, we must be careful not to unconditionally look at\n-\t DECL_NAME here.  */\n       else if (TREE_CODE (cand->fn) == FUNCTION_DECL\n-\t       && DECL_OVERLOADED_OPERATOR_P (cand->fn) == CALL_EXPR)\n+\t       && DECL_OVERLOADED_OPERATOR_P (cand->fn)\n+\t       && DECL_OVERLOADED_OPERATOR_IS (cand->fn, CALL_EXPR))\n \tresult = build_over_call (cand, LOOKUP_NORMAL, complain);\n       else\n \t{\n@@ -8116,7 +8114,8 @@ build_over_call (struct z_candidate *cand, int flags, tsubst_flags_t complain)\n \t  return val;\n \t}\n     }\n-  else if (DECL_OVERLOADED_OPERATOR_P (fn) == NOP_EXPR\n+  else if (DECL_ASSIGNMENT_OPERATOR_P (fn)\n+\t   && DECL_OVERLOADED_OPERATOR_IS (fn, NOP_EXPR)\n \t   && trivial_fn_p (fn)\n \t   && !DECL_DELETED_FN (fn))\n     {\n@@ -8284,7 +8283,7 @@ first_non_public_field (tree type)\n static bool\n has_trivial_copy_assign_p (tree type, bool access, bool *hasassign)\n {\n-  tree fns = get_class_binding (type, cp_assignment_operator_id (NOP_EXPR));\n+  tree fns = get_class_binding (type, assign_op_identifier);\n   bool all_trivial = true;\n \n   /* Iterate over overloads of the assignment operator, checking\n@@ -8784,8 +8783,7 @@ build_special_member_call (tree instance, tree name, vec<tree, va_gc> **args,\n   vec<tree, va_gc> *allocated = NULL;\n   tree ret;\n \n-  gcc_assert (IDENTIFIER_CDTOR_P (name)\n-\t      || name == cp_assignment_operator_id (NOP_EXPR));\n+  gcc_assert (IDENTIFIER_CDTOR_P (name) || name == assign_op_identifier);\n   if (TYPE_P (binfo))\n     {\n       /* Resolve the name.  */\n@@ -8811,18 +8809,21 @@ build_special_member_call (tree instance, tree name, vec<tree, va_gc> **args,\n       if (!same_type_ignoring_top_level_qualifiers_p\n \t  (TREE_TYPE (instance), BINFO_TYPE (binfo)))\n \t{\n-\t  if (name != cp_assignment_operator_id (NOP_EXPR))\n+\t  if (IDENTIFIER_CDTOR_P (name))\n \t    /* For constructors and destructors, either the base is\n \t       non-virtual, or it is virtual but we are doing the\n \t       conversion from a constructor or destructor for the\n \t       complete object.  In either case, we can convert\n \t       statically.  */\n \t    instance = convert_to_base_statically (instance, binfo);\n \t  else\n-\t    /* However, for assignment operators, we must convert\n-\t       dynamically if the base is virtual.  */\n-\t    instance = build_base_path (PLUS_EXPR, instance,\n-\t\t\t\t\tbinfo, /*nonnull=*/1, complain);\n+\t    {\n+\t      /* However, for assignment operators, we must convert\n+\t\t dynamically if the base is virtual.  */\n+\t      gcc_checking_assert (name == assign_op_identifier);\n+\t      instance = build_base_path (PLUS_EXPR, instance,\n+\t\t\t\t\t  binfo, /*nonnull=*/1, complain);\n+\t    }\n \t}\n     }\n "}, {"sha": "96009df8a468e49ffbf6c989dd1a2c48f218602b", "filename": "gcc/cp/class.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/137073d34a47fe14f97e35f69d3941b2ef0bb5c1/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/137073d34a47fe14f97e35f69d3941b2ef0bb5c1/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=137073d34a47fe14f97e35f69d3941b2ef0bb5c1", "patch": "@@ -3011,7 +3011,7 @@ static tree\n dfs_declare_virt_assop_and_dtor (tree binfo, void *data)\n {\n   tree bv, fn, t = (tree)data;\n-  tree opname = cp_assignment_operator_id (NOP_EXPR);\n+  tree opname = assign_op_identifier;\n \n   gcc_assert (t && CLASS_TYPE_P (t));\n   gcc_assert (binfo && TREE_CODE (binfo) == TREE_BINFO);\n@@ -5038,7 +5038,7 @@ vbase_has_user_provided_move_assign (tree type)\n   /* Does the type itself have a user-provided move assignment operator?  */\n   if (!CLASSTYPE_LAZY_MOVE_ASSIGN (type))\n     for (ovl_iterator iter (get_class_binding_direct\n-\t\t\t    (type, cp_assignment_operator_id (NOP_EXPR)));\n+\t\t\t    (type, assign_op_identifier));\n \t iter; ++iter)\n       if (!DECL_ARTIFICIAL (*iter) && move_fn_p (*iter))\n \treturn true;\n@@ -5186,7 +5186,7 @@ classtype_has_move_assign_or_move_ctor_p (tree t, bool user_p)\n \n   if (!CLASSTYPE_LAZY_MOVE_ASSIGN (t))\n     for (ovl_iterator iter (get_class_binding_direct\n-\t\t\t    (t, cp_assignment_operator_id (NOP_EXPR)));\n+\t\t\t    (t, assign_op_identifier));\n \t iter; ++iter)\n       if ((!user_p || !DECL_ARTIFICIAL (*iter)) && move_fn_p (*iter))\n \treturn true;"}, {"sha": "9c183a7e17305c42217ae4ad6475a1255654eb77", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 21, "deletions": 12, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/137073d34a47fe14f97e35f69d3941b2ef0bb5c1/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/137073d34a47fe14f97e35f69d3941b2ef0bb5c1/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=137073d34a47fe14f97e35f69d3941b2ef0bb5c1", "patch": "@@ -217,7 +217,7 @@ extern GTY(()) tree cp_global_trees[CPTI_MAX];\n    things) to iterate over their overloads defined by/for a type.  For\n    example:\n \n-     tree ovlid = cp_assignment_operator_id (NOP_EXPR);\n+     tree ovlid = assign_op_identifier;\n      tree overloads = get_class_binding (type, ovlid);\n      for (ovl_iterator it (overloads); it; ++it) { ... }\n \n@@ -244,6 +244,9 @@ extern GTY(()) tree cp_global_trees[CPTI_MAX];\n /* The name of a destructor that destroys virtual base classes, and\n    then deletes the entire object.  */\n #define deleting_dtor_identifier\tcp_global_trees[CPTI_DELETING_DTOR_IDENTIFIER]\n+\n+#define assign_op_identifier (cp_assignment_operator_id (NOP_EXPR))\n+#define call_op_identifier (cp_operator_id (CALL_EXPR))\n /* The name used for conversion operators -- but note that actual\n    conversion functions use special identifiers outside the identifier\n    table.  */\n@@ -1203,9 +1206,10 @@ struct GTY (()) tree_trait_expr {\n   (CLASS_TYPE_P (NODE) && CLASSTYPE_LAMBDA_EXPR (NODE))\n \n /* Test if FUNCTION_DECL is a lambda function.  */\n-#define LAMBDA_FUNCTION_P(FNDECL)\t\t\t\\\n-  (DECL_DECLARES_FUNCTION_P (FNDECL)\t\t\t\\\n-   && DECL_OVERLOADED_OPERATOR_P (FNDECL) == CALL_EXPR\t\\\n+#define LAMBDA_FUNCTION_P(FNDECL)\t\t\t\t\\\n+  (DECL_DECLARES_FUNCTION_P (FNDECL)\t\t\t\t\\\n+   && DECL_OVERLOADED_OPERATOR_P (FNDECL)\t\t\t\\\n+   && DECL_OVERLOADED_OPERATOR_IS (FNDECL, CALL_EXPR)\t\t\\\n    && LAMBDA_TYPE_P (CP_DECL_CONTEXT (FNDECL)))\n \n enum cp_lambda_default_capture_mode_type {\n@@ -2810,19 +2814,24 @@ struct GTY(()) lang_decl {\n #define SET_OVERLOADED_OPERATOR_CODE(NODE, CODE) \\\n   (LANG_DECL_FN_CHECK (NODE)->operator_code = (CODE))\n \n-/* If NODE is an overloaded operator, then this returns the TREE_CODE\n-   associated with the overloaded operator.  If NODE is not an\n-   overloaded operator, ERROR_MARK is returned.  Since the numerical\n-   value of ERROR_MARK is zero, this macro can be used as a predicate\n-   to test whether or not NODE is an overloaded operator.  */\n+/* True iff decl NODE is for an overloaded operator.  */\n #define DECL_OVERLOADED_OPERATOR_P(NODE)\t\t\\\n-  (IDENTIFIER_ANY_OP_P (DECL_NAME (NODE))\t\t\\\n-   ? LANG_DECL_FN_CHECK (NODE)->operator_code : ERROR_MARK)\n+  IDENTIFIER_ANY_OP_P (DECL_NAME (NODE))\n \n /* Nonzero if NODE is an assignment operator (including += and such).  */\n-#define DECL_ASSIGNMENT_OPERATOR_P(NODE) \\\n+#define DECL_ASSIGNMENT_OPERATOR_P(NODE)\t\t \\\n   IDENTIFIER_ASSIGN_OP_P (DECL_NAME (NODE))\n \n+/* NODE is a function_decl for an overloaded operator.  Return its\n+   operator code.   */\n+#define DECL_OVERLOADED_OPERATOR_CODE(NODE)\t\t\t\\\n+  (LANG_DECL_FN_CHECK (NODE)->operator_code)\n+\n+/* DECL is an overloaded operator.  Test whether it is for TREE_CODE\n+   (a literal constant).  */\n+#define DECL_OVERLOADED_OPERATOR_IS(DECL, CODE)\t\t\t\\\n+  (DECL_OVERLOADED_OPERATOR_CODE (DECL) == CODE)\n+\n /* For FUNCTION_DECLs: nonzero means that this function is a\n    constructor or a destructor with an extra in-charge parameter to\n    control whether or not virtual bases are constructed.  */"}, {"sha": "a983adfe0c46e341a6a35c679cae2822efe232b2", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/137073d34a47fe14f97e35f69d3941b2ef0bb5c1/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/137073d34a47fe14f97e35f69d3941b2ef0bb5c1/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=137073d34a47fe14f97e35f69d3941b2ef0bb5c1", "patch": "@@ -1921,9 +1921,9 @@ next_arg:;\n       DECL_FINAL_P (newdecl) |= DECL_FINAL_P (olddecl);\n       DECL_OVERRIDE_P (newdecl) |= DECL_OVERRIDE_P (olddecl);\n       DECL_THIS_STATIC (newdecl) |= DECL_THIS_STATIC (olddecl);\n-      if (DECL_OVERLOADED_OPERATOR_P (olddecl) != ERROR_MARK)\n+      if (DECL_OVERLOADED_OPERATOR_P (olddecl))\n \tSET_OVERLOADED_OPERATOR_CODE\n-\t  (newdecl, DECL_OVERLOADED_OPERATOR_P (olddecl));\n+\t  (newdecl, DECL_OVERLOADED_OPERATOR_CODE (olddecl));\n       new_defines_function = DECL_INITIAL (newdecl) != NULL_TREE;\n \n       /* Optionally warn about more than one declaration for the same\n@@ -12816,7 +12816,7 @@ grok_special_member_properties (tree decl)\n \t  && !ctor && !move_fn_p (decl))\n \tTYPE_HAS_CONSTEXPR_CTOR (class_type) = 1;\n     }\n-  else if (DECL_NAME (decl) == cp_assignment_operator_id (NOP_EXPR))\n+  else if (DECL_NAME (decl) == assign_op_identifier)\n     {\n       /* [class.copy]\n \n@@ -14769,9 +14769,11 @@ start_preparsed_function (tree decl1, tree attrs, int flags)\n \n   /* Effective C++ rule 15.  */\n   if (warn_ecpp\n-      && DECL_OVERLOADED_OPERATOR_P (decl1) == NOP_EXPR\n+      && DECL_ASSIGNMENT_OPERATOR_P (decl1)\n+      && DECL_OVERLOADED_OPERATOR_IS (decl1, NOP_EXPR)\n       && VOID_TYPE_P (TREE_TYPE (fntype)))\n-    warning (OPT_Weffc__, \"%<operator=%> should return a reference to %<*this%>\");\n+    warning (OPT_Weffc__,\n+\t     \"%<operator=%> should return a reference to %<*this%>\");\n \n   /* Make the init_value nonzero so pushdecl knows this is not tentative.\n      error_mark_node is replaced below (in poplevel) with the BLOCK.  */"}, {"sha": "80358651b03b7c9ef82be71579b9d2a6b01ab265", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/137073d34a47fe14f97e35f69d3941b2ef0bb5c1/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/137073d34a47fe14f97e35f69d3941b2ef0bb5c1/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=137073d34a47fe14f97e35f69d3941b2ef0bb5c1", "patch": "@@ -5101,11 +5101,11 @@ mark_used (tree decl, tsubst_flags_t complain)\n       && DECL_DELETED_FN (decl))\n     {\n       if (DECL_ARTIFICIAL (decl)\n-\t  && DECL_OVERLOADED_OPERATOR_P (decl) == TYPE_EXPR\n+\t  && DECL_CONV_FN_P (decl)\n \t  && LAMBDA_TYPE_P (DECL_CONTEXT (decl)))\n \t/* We mark a lambda conversion op as deleted if we can't\n \t   generate it properly; see maybe_add_lambda_conv_op.  */\n-\tsorry (\"converting lambda which uses %<...%> to function pointer\");\n+\tsorry (\"converting lambda that uses %<...%> to function pointer\");\n       else if (complain & tf_error)\n \t{\n \t  error (\"use of deleted function %qD\", decl);"}, {"sha": "2e4740f71eb690cd02df94e4136753cba56b2b50", "filename": "gcc/cp/dump.c", "status": "modified", "additions": 1, "deletions": 164, "changes": 165, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/137073d34a47fe14f97e35f69d3941b2ef0bb5c1/gcc%2Fcp%2Fdump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/137073d34a47fe14f97e35f69d3941b2ef0bb5c1/gcc%2Fcp%2Fdump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdump.c?ref=137073d34a47fe14f97e35f69d3941b2ef0bb5c1", "patch": "@@ -24,10 +24,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"cp-tree.h\"\n #include \"tree-dump.h\"\n \n-static void dump_access (dump_info_p, tree);\n-\n-static void dump_op (dump_info_p, tree);\n-\n /* Dump a representation of the accessibility information associated\n    with T.  */\n \n@@ -42,163 +38,6 @@ dump_access (dump_info_p di, tree t)\n     dump_string_field (di, \"accs\", \"pub\");\n }\n \n-/* Dump a representation of the specific operator for an overloaded\n-   operator associated with node t.  */\n-\n-static void\n-dump_op (dump_info_p di, tree t)\n-{\n-  switch (DECL_OVERLOADED_OPERATOR_P (t)) {\n-    case NEW_EXPR:\n-      dump_string (di, \"new\");\n-      break;\n-    case VEC_NEW_EXPR:\n-      dump_string (di, \"vecnew\");\n-      break;\n-    case DELETE_EXPR:\n-      dump_string (di, \"delete\");\n-      break;\n-    case VEC_DELETE_EXPR:\n-      dump_string (di, \"vecdelete\");\n-      break;\n-    case UNARY_PLUS_EXPR:\n-      dump_string (di, \"pos\");\n-      break;\n-    case NEGATE_EXPR:\n-      dump_string (di, \"neg\");\n-      break;\n-    case ADDR_EXPR:\n-      dump_string (di, \"addr\");\n-      break;\n-    case INDIRECT_REF:\n-      dump_string(di, \"deref\");\n-      break;\n-    case BIT_NOT_EXPR:\n-      dump_string(di, \"not\");\n-      break;\n-    case TRUTH_NOT_EXPR:\n-      dump_string(di, \"lnot\");\n-      break;\n-    case PREINCREMENT_EXPR:\n-      dump_string(di, \"preinc\");\n-      break;\n-    case PREDECREMENT_EXPR:\n-      dump_string(di, \"predec\");\n-      break;\n-    case PLUS_EXPR:\n-      if (DECL_ASSIGNMENT_OPERATOR_P (t))\n-\tdump_string (di, \"plusassign\");\n-      else\n-\tdump_string(di, \"plus\");\n-      break;\n-    case MINUS_EXPR:\n-      if (DECL_ASSIGNMENT_OPERATOR_P (t))\n-\tdump_string (di, \"minusassign\");\n-      else\n-\tdump_string(di, \"minus\");\n-      break;\n-    case MULT_EXPR:\n-      if (DECL_ASSIGNMENT_OPERATOR_P (t))\n-\tdump_string (di, \"multassign\");\n-      else\n-\tdump_string (di, \"mult\");\n-      break;\n-    case TRUNC_DIV_EXPR:\n-      if (DECL_ASSIGNMENT_OPERATOR_P (t))\n-\tdump_string (di, \"divassign\");\n-      else\n-\tdump_string (di, \"div\");\n-      break;\n-    case TRUNC_MOD_EXPR:\n-      if (DECL_ASSIGNMENT_OPERATOR_P (t))\n-\t dump_string (di, \"modassign\");\n-      else\n-\tdump_string (di, \"mod\");\n-      break;\n-    case BIT_AND_EXPR:\n-      if (DECL_ASSIGNMENT_OPERATOR_P (t))\n-\tdump_string (di, \"andassign\");\n-      else\n-\tdump_string (di, \"and\");\n-      break;\n-    case BIT_IOR_EXPR:\n-      if (DECL_ASSIGNMENT_OPERATOR_P (t))\n-\tdump_string (di, \"orassign\");\n-      else\n-\tdump_string (di, \"or\");\n-      break;\n-    case BIT_XOR_EXPR:\n-      if (DECL_ASSIGNMENT_OPERATOR_P (t))\n-\tdump_string (di, \"xorassign\");\n-      else\n-\tdump_string (di, \"xor\");\n-      break;\n-    case LSHIFT_EXPR:\n-      if (DECL_ASSIGNMENT_OPERATOR_P (t))\n-\tdump_string (di, \"lshiftassign\");\n-      else\n-\tdump_string (di, \"lshift\");\n-      break;\n-    case RSHIFT_EXPR:\n-      if (DECL_ASSIGNMENT_OPERATOR_P (t))\n-\tdump_string (di, \"rshiftassign\");\n-      else\n-\tdump_string (di, \"rshift\");\n-      break;\n-    case EQ_EXPR:\n-      dump_string (di, \"eq\");\n-      break;\n-    case NE_EXPR:\n-      dump_string (di, \"ne\");\n-      break;\n-    case LT_EXPR:\n-      dump_string (di, \"lt\");\n-      break;\n-    case GT_EXPR:\n-      dump_string (di, \"gt\");\n-      break;\n-    case LE_EXPR:\n-      dump_string (di, \"le\");\n-      break;\n-    case GE_EXPR:\n-      dump_string (di, \"ge\");\n-      break;\n-    case TRUTH_ANDIF_EXPR:\n-      dump_string (di, \"land\");\n-      break;\n-    case TRUTH_ORIF_EXPR:\n-      dump_string (di, \"lor\");\n-      break;\n-    case COMPOUND_EXPR:\n-      dump_string (di, \"compound\");\n-      break;\n-    case MEMBER_REF:\n-      dump_string (di, \"memref\");\n-      break;\n-    case COMPONENT_REF:\n-      dump_string (di, \"ref\");\n-      break;\n-    case ARRAY_REF:\n-      dump_string (di, \"subs\");\n-      break;\n-    case POSTINCREMENT_EXPR:\n-      dump_string (di, \"postinc\");\n-      break;\n-    case POSTDECREMENT_EXPR:\n-      dump_string (di, \"postdec\");\n-      break;\n-    case CALL_EXPR:\n-      dump_string (di, \"call\");\n-      break;\n-    case NOP_EXPR:\n-      if (DECL_ASSIGNMENT_OPERATOR_P (t))\n-\tdump_string (di, \"assign\");\n-      break;\n-    default:\n-      break;\n-  }\n-}\n-\n /* Dump information common to statements from STMT.  */\n \n static void\n@@ -303,10 +142,8 @@ cp_dump_tree (void* dump_info, tree t)\n     case FUNCTION_DECL:\n       if (!DECL_THUNK_P (t))\n \t{\n-\t  if (DECL_OVERLOADED_OPERATOR_P (t)) {\n+\t  if (DECL_OVERLOADED_OPERATOR_P (t))\n \t    dump_string_field (di, \"note\", \"operator\");\n-\t    dump_op (di, t);\n-\t  }\n \t  if (DECL_FUNCTION_MEMBER_P (t))\n \t    {\n \t      dump_string_field (di, \"note\", \"member\");"}, {"sha": "bb6c68a100a078c8715c0067860cc201d8adfccb", "filename": "gcc/cp/lambda.c", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/137073d34a47fe14f97e35f69d3941b2ef0bb5c1/gcc%2Fcp%2Flambda.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/137073d34a47fe14f97e35f69d3941b2ef0bb5c1/gcc%2Fcp%2Flambda.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flambda.c?ref=137073d34a47fe14f97e35f69d3941b2ef0bb5c1", "patch": "@@ -201,7 +201,7 @@ lambda_function (tree lambda)\n   if (CLASSTYPE_TEMPLATE_INSTANTIATION (type)\n       && !COMPLETE_OR_OPEN_TYPE_P (type))\n     return NULL_TREE;\n-  lambda = lookup_member (type, cp_operator_id (CALL_EXPR),\n+  lambda = lookup_member (type, call_op_identifier,\n \t\t\t  /*protect=*/0, /*want_type=*/false,\n \t\t\t  tf_warning_or_error);\n   if (lambda)\n@@ -1258,7 +1258,6 @@ maybe_add_lambda_conv_op (tree type)\n   tree fn = convfn;\n   DECL_SOURCE_LOCATION (fn) = DECL_SOURCE_LOCATION (callop);\n   SET_DECL_ALIGN (fn, MINIMUM_METHOD_BOUNDARY);\n-  SET_OVERLOADED_OPERATOR_CODE (fn, TYPE_EXPR);\n   grokclassfn (type, fn, NO_SPECIAL);\n   set_linkage_according_to_type (type, fn);\n   rest_of_decl_compilation (fn, namespace_bindings_p (), at_eof);\n@@ -1312,11 +1311,9 @@ maybe_add_lambda_conv_op (tree type)\n     fn = add_inherited_template_parms (fn, DECL_TI_TEMPLATE (callop));\n \n   if (flag_sanitize & SANITIZE_NULL)\n-    {\n-      /* Don't UBsan this function; we're deliberately calling op() with a null\n-\t object argument.  */\n-      add_no_sanitize_value (fn, SANITIZE_UNDEFINED);\n-    }\n+    /* Don't UBsan this function; we're deliberately calling op() with a null\n+       object argument.  */\n+    add_no_sanitize_value (fn, SANITIZE_UNDEFINED);\n \n   add_method (type, fn, false);\n "}, {"sha": "d01e652d4a075487aa441286a249271b6c357602", "filename": "gcc/cp/mangle.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/137073d34a47fe14f97e35f69d3941b2ef0bb5c1/gcc%2Fcp%2Fmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/137073d34a47fe14f97e35f69d3941b2ef0bb5c1/gcc%2Fcp%2Fmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmangle.c?ref=137073d34a47fe14f97e35f69d3941b2ef0bb5c1", "patch": "@@ -1351,7 +1351,7 @@ write_unqualified_name (tree decl)\n \t  else\n \t    oni = operator_name_info;\n \n-\t  write_string (oni[DECL_OVERLOADED_OPERATOR_P (decl)].mangled_name);\n+\t  write_string (oni[DECL_OVERLOADED_OPERATOR_CODE (decl)].mangled_name);\n \t}\n       else if (UDLIT_OPER_P (DECL_NAME (decl)))\n \twrite_literal_operator_name (DECL_NAME (decl));"}, {"sha": "e88e508892db12f494ce52d4b8e18bc654202c5c", "filename": "gcc/cp/method.c", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/137073d34a47fe14f97e35f69d3941b2ef0bb5c1/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/137073d34a47fe14f97e35f69d3941b2ef0bb5c1/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=137073d34a47fe14f97e35f69d3941b2ef0bb5c1", "patch": "@@ -815,7 +815,7 @@ do_build_copy_assign (tree fndecl)\n \t  parmvec = make_tree_vector_single (converted_parm);\n \t  finish_expr_stmt\n \t    (build_special_member_call (current_class_ref,\n-\t\t\t\t\tcp_assignment_operator_id (NOP_EXPR),\n+\t\t\t\t\tassign_op_identifier,\n \t\t\t\t\t&parmvec,\n \t\t\t\t\tbase_binfo,\n \t\t\t\t\tflags,\n@@ -929,7 +929,8 @@ synthesize_method (tree fndecl)\n   start_preparsed_function (fndecl, NULL_TREE, SF_DEFAULT | SF_PRE_PARSED);\n   stmt = begin_function_body ();\n \n-  if (DECL_OVERLOADED_OPERATOR_P (fndecl) == NOP_EXPR)\n+  if (DECL_ASSIGNMENT_OPERATOR_P (fndecl)\n+      && DECL_OVERLOADED_OPERATOR_IS (fndecl, NOP_EXPR))\n     {\n       do_build_copy_assign (fndecl);\n       need_body = false;\n@@ -1108,7 +1109,7 @@ get_copy_assign (tree type)\n   int quals = (TYPE_HAS_CONST_COPY_ASSIGN (type)\n \t       ? TYPE_QUAL_CONST : TYPE_UNQUALIFIED);\n   tree argtype = build_stub_type (type, quals, false);\n-  tree fn = locate_fn_flags (type, cp_assignment_operator_id (NOP_EXPR), argtype,\n+  tree fn = locate_fn_flags (type, assign_op_identifier, argtype,\n \t\t\t     LOOKUP_NORMAL, tf_warning_or_error);\n   if (fn == error_mark_node)\n     return NULL_TREE;\n@@ -1565,7 +1566,7 @@ synthesized_method_walk (tree ctype, special_function_kind sfk, bool const_p,\n     case sfk_move_assignment:\n     case sfk_copy_assignment:\n       assign_p = true;\n-      fnname = cp_assignment_operator_id (NOP_EXPR);\n+      fnname = assign_op_identifier;\n       break;\n \n     case sfk_destructor:\n@@ -2318,7 +2319,7 @@ defaultable_fn_check (tree fn)\n   else if (DECL_DESTRUCTOR_P (fn))\n     kind = sfk_destructor;\n   else if (DECL_ASSIGNMENT_OPERATOR_P (fn)\n-\t   && DECL_OVERLOADED_OPERATOR_P (fn) == NOP_EXPR)\n+\t   && DECL_OVERLOADED_OPERATOR_IS (fn, NOP_EXPR))\n     {\n       if (copy_fn_p (fn))\n \tkind = sfk_copy_assignment;"}, {"sha": "a536b808c3ca97a9c4168ff0406cc1c390dc129d", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/137073d34a47fe14f97e35f69d3941b2ef0bb5c1/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/137073d34a47fe14f97e35f69d3941b2ef0bb5c1/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=137073d34a47fe14f97e35f69d3941b2ef0bb5c1", "patch": "@@ -10614,8 +10614,7 @@ cp_parser_lambda_declarator_opt (cp_parser* parser, tree lambda_expr)\n \n     p = obstack_alloc (&declarator_obstack, 0);\n \n-    declarator = make_id_declarator (NULL_TREE, cp_operator_id (CALL_EXPR),\n-\t\t\t\t     sfk_none);\n+    declarator = make_id_declarator (NULL_TREE, call_op_identifier, sfk_none);\n \n     quals = (LAMBDA_EXPR_MUTABLE_P (lambda_expr)\n \t     ? TYPE_UNQUALIFIED : TYPE_QUAL_CONST);"}, {"sha": "89bea1e1f54b6c1b62fadfcfec2d96276a6be306", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/137073d34a47fe14f97e35f69d3941b2ef0bb5c1/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/137073d34a47fe14f97e35f69d3941b2ef0bb5c1/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=137073d34a47fe14f97e35f69d3941b2ef0bb5c1", "patch": "@@ -9020,8 +9020,7 @@ classtype_has_nothrow_assign_or_copy_p (tree type, bool assign_p)\n   tree fns = NULL_TREE;\n \n   if (assign_p || TYPE_HAS_COPY_CTOR (type))\n-    fns = get_class_binding (type,\n-\t\t\t     assign_p ? cp_assignment_operator_id (NOP_EXPR)\n+    fns = get_class_binding (type, assign_p ? assign_op_identifier\n \t\t\t     : ctor_identifier);\n \n   bool saw_copy = false;"}, {"sha": "b7d5f3dc3f516d369258981ab2dce833219c3aee", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/137073d34a47fe14f97e35f69d3941b2ef0bb5c1/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/137073d34a47fe14f97e35f69d3941b2ef0bb5c1/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=137073d34a47fe14f97e35f69d3941b2ef0bb5c1", "patch": "@@ -4847,7 +4847,8 @@ special_function_p (const_tree decl)\n     return sfk_move_constructor;\n   if (DECL_CONSTRUCTOR_P (decl))\n     return sfk_constructor;\n-  if (DECL_OVERLOADED_OPERATOR_P (decl) == NOP_EXPR)\n+  if (DECL_ASSIGNMENT_OPERATOR_P (decl)\n+      && DECL_OVERLOADED_OPERATOR_IS (decl, NOP_EXPR))\n     {\n       if (copy_fn_p (decl))\n \treturn sfk_copy_assignment;"}, {"sha": "3cc746a5ba478f861d3446fa8787de363172b7f1", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/137073d34a47fe14f97e35f69d3941b2ef0bb5c1/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/137073d34a47fe14f97e35f69d3941b2ef0bb5c1/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=137073d34a47fe14f97e35f69d3941b2ef0bb5c1", "patch": "@@ -9073,8 +9073,10 @@ check_return_expr (tree retval, bool *no_warning)\n     }\n \n   /* Only operator new(...) throw(), can return NULL [expr.new/13].  */\n-  if ((DECL_OVERLOADED_OPERATOR_P (current_function_decl) == NEW_EXPR\n-       || DECL_OVERLOADED_OPERATOR_P (current_function_decl) == VEC_NEW_EXPR)\n+  if (DECL_OVERLOADED_OPERATOR_P (current_function_decl)\n+      && (DECL_OVERLOADED_OPERATOR_CODE (current_function_decl) == NEW_EXPR\n+\t  || (DECL_OVERLOADED_OPERATOR_CODE (current_function_decl)\n+\t      == VEC_NEW_EXPR))\n       && !TYPE_NOTHROW_P (TREE_TYPE (current_function_decl))\n       && ! flag_check_new\n       && retval && null_ptr_cst_p (retval))\n@@ -9083,7 +9085,7 @@ check_return_expr (tree retval, bool *no_warning)\n \n   /* Effective C++ rule 15.  See also start_function.  */\n   if (warn_ecpp\n-      && DECL_NAME (current_function_decl) == cp_assignment_operator_id (NOP_EXPR))\n+      && DECL_NAME (current_function_decl) == assign_op_identifier)\n     {\n       bool warn = true;\n "}]}