{"sha": "dc5027f47440baef6b984b029fb5c3e5ee59e5ba", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGM1MDI3ZjQ3NDQwYmFlZjZiOTg0YjAyOWZiNWMzZTVlZTU5ZTViYQ==", "commit": {"author": {"name": "Joseph Myers", "email": "joseph@codesourcery.com", "date": "2010-05-23T20:47:16Z"}, "committer": {"name": "Joseph Myers", "email": "jsm28@gcc.gnu.org", "date": "2010-05-23T20:47:16Z"}, "message": "c-decl.c (diagnose_mismatched_decls): Give error for duplicate typedefs with different but compatible types.\n\n\t* c-decl.c (diagnose_mismatched_decls): Give error for duplicate\n\ttypedefs with different but compatible types.  Allow duplicate\n\ttypedefs with the same type except for pedantic non-C1X, but give\n\twarning for variably modified types.\n\t* c-typeck.c (tagged_types_tu_compatible_p,\n\tfunction_types_compatible_p, type_lists_compatible_p,\n\tcomptypes_internal): Add parameter different_types_p; set\n\t*different_types_p for different but compatible types.  All\n\tcallers changed.\n\t(comptypes_check_different_types): New.\n\t* c-tree.h (comptypes_check_different_types): Declare.\n\ntestsuite:\n\t* gcc.dg/c1x-typedef-1.c, gcc.dg/c1x-typedef-2.c,\n\tgcc.dg/c90-typedef-1.c, gcc.dg/c99-typedef-1.c: New tests.\n\t* gcc.dg/decl-8.c: Use -std=gnu89 -pedantic-errors.\n\nFrom-SVN: r159767", "tree": {"sha": "83fb32a9434ffd3ff6d6985dd79f64b42099c036", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/83fb32a9434ffd3ff6d6985dd79f64b42099c036"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dc5027f47440baef6b984b029fb5c3e5ee59e5ba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc5027f47440baef6b984b029fb5c3e5ee59e5ba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dc5027f47440baef6b984b029fb5c3e5ee59e5ba", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc5027f47440baef6b984b029fb5c3e5ee59e5ba/comments", "author": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8f9e812dacef3cc9eedb9fa17111affa93454287", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8f9e812dacef3cc9eedb9fa17111affa93454287", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8f9e812dacef3cc9eedb9fa17111affa93454287"}], "stats": {"total": 289, "additions": 249, "deletions": 40}, "files": [{"sha": "da66a2873a415b200a60ad25dc710594e0534362", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc5027f47440baef6b984b029fb5c3e5ee59e5ba/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc5027f47440baef6b984b029fb5c3e5ee59e5ba/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=dc5027f47440baef6b984b029fb5c3e5ee59e5ba", "patch": "@@ -1,3 +1,17 @@\n+2010-05-23  Joseph Myers  <joseph@codesourcery.com>\n+\n+\t* c-decl.c (diagnose_mismatched_decls): Give error for duplicate\n+\ttypedefs with different but compatible types.  Allow duplicate\n+\ttypedefs with the same type except for pedantic non-C1X, but give\n+\twarning for variably modified types.\n+\t* c-typeck.c (tagged_types_tu_compatible_p,\n+\tfunction_types_compatible_p, type_lists_compatible_p,\n+\tcomptypes_internal): Add parameter different_types_p; set\n+\t*different_types_p for different but compatible types.  All\n+\tcallers changed.\n+\t(comptypes_check_different_types): New.\n+\t* c-tree.h (comptypes_check_different_types): Declare.\n+\n 2010-05-23  Steven Bosscher  <steven@gcc.gnu.org>\n \n \t* regs.h: Do not include obstack.h, basic-block.h."}, {"sha": "68b0f8cd556dd4fa82a554a69b1b172279073236", "filename": "gcc/c-decl.c", "status": "modified", "additions": 34, "deletions": 4, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc5027f47440baef6b984b029fb5c3e5ee59e5ba/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc5027f47440baef6b984b029fb5c3e5ee59e5ba/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=dc5027f47440baef6b984b029fb5c3e5ee59e5ba", "patch": "@@ -1786,18 +1786,48 @@ diagnose_mismatched_decls (tree newdecl, tree olddecl,\n \n   /* Redeclaration of a type is a constraint violation (6.7.2.3p1),\n      but silently ignore the redeclaration if either is in a system\n-     header.  (Conflicting redeclarations were handled above.)  */\n+     header.  (Conflicting redeclarations were handled above.)  This\n+     is allowed for C1X if the types are the same, not just\n+     compatible.  */\n   if (TREE_CODE (newdecl) == TYPE_DECL)\n     {\n+      bool types_different = false;\n+      int comptypes_result;\n+\n+      comptypes_result\n+\t= comptypes_check_different_types (oldtype, newtype, &types_different);\n+\n+      if (comptypes_result != 1 || types_different)\n+\t{\n+\t  error (\"redefinition of typedef %q+D with different type\", newdecl);\n+\t  locate_old_decl (olddecl);\n+\t  return false;\n+\t}\n+\n       if (DECL_IN_SYSTEM_HEADER (newdecl)\n \t  || DECL_IN_SYSTEM_HEADER (olddecl)\n \t  || TREE_NO_WARNING (newdecl)\n \t  || TREE_NO_WARNING (olddecl))\n \treturn true;  /* Allow OLDDECL to continue in use.  */\n \n-      error (\"redefinition of typedef %q+D\", newdecl);\n-      locate_old_decl (olddecl);\n-      return false;\n+      if (pedantic && !flag_isoc1x)\n+\t{\n+\t  pedwarn (input_location, OPT_pedantic,\n+\t\t   \"redefinition of typedef %q+D\", newdecl);\n+\t  locate_old_decl (olddecl);\n+\t}\n+      else if (variably_modified_type_p (newtype, NULL))\n+\t{\n+\t  /* Whether there is a constraint violation for the types not\n+\t     being the same cannot be determined at compile time; a\n+\t     warning that there may be one at runtime is considered\n+\t     appropriate (WG14 reflector message 11743, 8 May 2009).  */\n+\t  warning (0, \"redefinition of typedef %q+D may be a constraint \"\n+\t\t   \"violation at runtime\", newdecl);\n+\t  locate_old_decl (olddecl);\n+\t}\n+\n+      return true;\n     }\n \n   /* Function declarations can either be 'static' or 'extern' (no"}, {"sha": "1806e2ccff767922438668e13632b1c3e7eafe87", "filename": "gcc/c-tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc5027f47440baef6b984b029fb5c3e5ee59e5ba/gcc%2Fc-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc5027f47440baef6b984b029fb5c3e5ee59e5ba/gcc%2Fc-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-tree.h?ref=dc5027f47440baef6b984b029fb5c3e5ee59e5ba", "patch": "@@ -506,6 +506,7 @@ extern tree c_objc_common_truthvalue_conversion (location_t, tree);\n extern tree require_complete_type (tree);\n extern int same_translation_unit_p (const_tree, const_tree);\n extern int comptypes (tree, tree);\n+extern int comptypes_check_different_types (tree, tree, bool *);\n extern bool c_vla_type_p (const_tree);\n extern bool c_mark_addressable (tree);\n extern void c_incomplete_type_error (const_tree, const_tree);"}, {"sha": "466586168f30caa2d069d68342874c873b7d9bc1", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 95, "deletions": 35, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc5027f47440baef6b984b029fb5c3e5ee59e5ba/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc5027f47440baef6b984b029fb5c3e5ee59e5ba/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=dc5027f47440baef6b984b029fb5c3e5ee59e5ba", "patch": "@@ -76,10 +76,12 @@ static int require_constant_elements;\n \n static bool null_pointer_constant_p (const_tree);\n static tree qualify_type (tree, tree);\n-static int tagged_types_tu_compatible_p (const_tree, const_tree, bool *);\n+static int tagged_types_tu_compatible_p (const_tree, const_tree, bool *,\n+\t\t\t\t\t bool *);\n static int comp_target_types (location_t, tree, tree);\n-static int function_types_compatible_p (const_tree, const_tree, bool *);\n-static int type_lists_compatible_p (const_tree, const_tree, bool *);\n+static int function_types_compatible_p (const_tree, const_tree, bool *,\n+\t\t\t\t\tbool *);\n+static int type_lists_compatible_p (const_tree, const_tree, bool *, bool *);\n static tree lookup_field (tree, tree);\n static int convert_arguments (tree, VEC(tree,gc) *, VEC(tree,gc) *, tree,\n \t\t\t      tree);\n@@ -106,7 +108,7 @@ static void readonly_error (tree, enum lvalue_use);\n static void readonly_warning (tree, enum lvalue_use);\n static int lvalue_or_else (const_tree, enum lvalue_use);\n static void record_maybe_used_decl (tree);\n-static int comptypes_internal (const_tree, const_tree, bool *);\n+static int comptypes_internal (const_tree, const_tree, bool *, bool *);\n \f\n /* Return true if EXP is a null pointer constant, false otherwise.  */\n \n@@ -972,7 +974,7 @@ comptypes (tree type1, tree type2)\n   const struct tagged_tu_seen_cache * tagged_tu_seen_base1 = tagged_tu_seen_base;\n   int val;\n \n-  val = comptypes_internal (type1, type2, NULL);\n+  val = comptypes_internal (type1, type2, NULL, NULL);\n   free_all_tagged_tu_seen_up_to (tagged_tu_seen_base1);\n \n   return val;\n@@ -987,7 +989,23 @@ comptypes_check_enum_int (tree type1, tree type2, bool *enum_and_int_p)\n   const struct tagged_tu_seen_cache * tagged_tu_seen_base1 = tagged_tu_seen_base;\n   int val;\n \n-  val = comptypes_internal (type1, type2, enum_and_int_p);\n+  val = comptypes_internal (type1, type2, enum_and_int_p, NULL);\n+  free_all_tagged_tu_seen_up_to (tagged_tu_seen_base1);\n+\n+  return val;\n+}\n+\n+/* Like comptypes, but if it returns nonzero for different types, it\n+   sets *DIFFERENT_TYPES_P to true.  */\n+\n+int\n+comptypes_check_different_types (tree type1, tree type2,\n+\t\t\t\t bool *different_types_p)\n+{\n+  const struct tagged_tu_seen_cache * tagged_tu_seen_base1 = tagged_tu_seen_base;\n+  int val;\n+\n+  val = comptypes_internal (type1, type2, NULL, different_types_p);\n   free_all_tagged_tu_seen_up_to (tagged_tu_seen_base1);\n \n   return val;\n@@ -998,11 +1016,17 @@ comptypes_check_enum_int (tree type1, tree type2, bool *enum_and_int_p)\n    but a warning may be needed if you use them together.  If\n    ENUM_AND_INT_P is not NULL, and one type is an enum and the other a\n    compatible integer type, then this sets *ENUM_AND_INT_P to true;\n-   *ENUM_AND_INT_P is never set to false.  This differs from\n-   comptypes, in that we don't free the seen types.  */\n+   *ENUM_AND_INT_P is never set to false.  If DIFFERENT_TYPES_P is not\n+   NULL, and the types are compatible but different enough not to be\n+   permitted in C1X typedef redeclarations, then this sets\n+   *DIFFERENT_TYPES_P to true; *DIFFERENT_TYPES_P is never set to\n+   false, but may or may not be set if the types are incompatible.\n+   This differs from comptypes, in that we don't free the seen\n+   types.  */\n \n static int\n-comptypes_internal (const_tree type1, const_tree type2, bool *enum_and_int_p)\n+comptypes_internal (const_tree type1, const_tree type2, bool *enum_and_int_p,\n+\t\t    bool *different_types_p)\n {\n   const_tree t1 = type1;\n   const_tree t2 = type2;\n@@ -1032,14 +1056,24 @@ comptypes_internal (const_tree type1, const_tree type2, bool *enum_and_int_p)\n   if (TREE_CODE (t1) == ENUMERAL_TYPE && TREE_CODE (t2) != ENUMERAL_TYPE)\n     {\n       t1 = c_common_type_for_size (TYPE_PRECISION (t1), TYPE_UNSIGNED (t1));\n-      if (enum_and_int_p != NULL && TREE_CODE (t2) != VOID_TYPE)\n-\t*enum_and_int_p = true;\n+      if (TREE_CODE (t2) != VOID_TYPE)\n+\t{\n+\t  if (enum_and_int_p != NULL)\n+\t    *enum_and_int_p = true;\n+\t  if (different_types_p != NULL)\n+\t    *different_types_p = true;\n+\t}\n     }\n   else if (TREE_CODE (t2) == ENUMERAL_TYPE && TREE_CODE (t1) != ENUMERAL_TYPE)\n     {\n       t2 = c_common_type_for_size (TYPE_PRECISION (t2), TYPE_UNSIGNED (t2));\n-      if (enum_and_int_p != NULL && TREE_CODE (t1) != VOID_TYPE)\n-\t*enum_and_int_p = true;\n+      if (TREE_CODE (t1) != VOID_TYPE)\n+\t{\n+\t  if (enum_and_int_p != NULL)\n+\t    *enum_and_int_p = true;\n+\t  if (different_types_p != NULL)\n+\t    *different_types_p = true;\n+\t}\n     }\n \n   if (t1 == t2)\n@@ -1079,11 +1113,12 @@ comptypes_internal (const_tree type1, const_tree type2, bool *enum_and_int_p)\n \tbreak;\n       val = (TREE_TYPE (t1) == TREE_TYPE (t2)\n \t     ? 1 : comptypes_internal (TREE_TYPE (t1), TREE_TYPE (t2),\n-\t\t\t\t       enum_and_int_p));\n+\t\t\t\t       enum_and_int_p, different_types_p));\n       break;\n \n     case FUNCTION_TYPE:\n-      val = function_types_compatible_p (t1, t2, enum_and_int_p);\n+      val = function_types_compatible_p (t1, t2, enum_and_int_p,\n+\t\t\t\t\t different_types_p);\n       break;\n \n     case ARRAY_TYPE:\n@@ -1097,9 +1132,13 @@ comptypes_internal (const_tree type1, const_tree type2, bool *enum_and_int_p)\n \t/* Target types must match incl. qualifiers.  */\n \tif (TREE_TYPE (t1) != TREE_TYPE (t2)\n \t    && 0 == (val = comptypes_internal (TREE_TYPE (t1), TREE_TYPE (t2),\n-\t\t\t\t\t       enum_and_int_p)))\n+\t\t\t\t\t       enum_and_int_p,\n+\t\t\t\t\t       different_types_p)))\n \t  return 0;\n \n+\tif (different_types_p != NULL\n+\t    && (d1 == 0) != (d2 == 0))\n+\t  *different_types_p = true;\n \t/* Sizes must match unless one is missing or variable.  */\n \tif (d1 == 0 || d2 == 0 || d1 == d2)\n \t  break;\n@@ -1116,6 +1155,9 @@ comptypes_internal (const_tree type1, const_tree type2, bool *enum_and_int_p)\n \td1_variable = d1_variable || (d1_zero && c_vla_type_p (t1));\n \td2_variable = d2_variable || (d2_zero && c_vla_type_p (t2));\n \n+\tif (different_types_p != NULL\n+\t    && d1_variable != d2_variable)\n+\t  *different_types_p = true;\n \tif (d1_variable || d2_variable)\n \t  break;\n \tif (d1_zero && d2_zero)\n@@ -1141,15 +1183,17 @@ comptypes_internal (const_tree type1, const_tree type2, bool *enum_and_int_p)\n \t    break;\n \n \t  if (attrval != 2)\n-\t    return tagged_types_tu_compatible_p (t1, t2, enum_and_int_p);\n-\t  val = tagged_types_tu_compatible_p (t1, t2, enum_and_int_p);\n+\t    return tagged_types_tu_compatible_p (t1, t2, enum_and_int_p,\n+\t\t\t\t\t\t different_types_p);\n+\t  val = tagged_types_tu_compatible_p (t1, t2, enum_and_int_p,\n+\t\t\t\t\t      different_types_p);\n \t}\n       break;\n \n     case VECTOR_TYPE:\n       val = (TYPE_VECTOR_SUBPARTS (t1) == TYPE_VECTOR_SUBPARTS (t2)\n \t     && comptypes_internal (TREE_TYPE (t1), TREE_TYPE (t2),\n-\t\t\t\t    enum_and_int_p));\n+\t\t\t\t    enum_and_int_p, different_types_p));\n       break;\n \n     default:\n@@ -1281,11 +1325,12 @@ free_all_tagged_tu_seen_up_to (const struct tagged_tu_seen_cache *tu_til)\n    compatible.  If the two types are not the same (which has been\n    checked earlier), this can only happen when multiple translation\n    units are being compiled.  See C99 6.2.7 paragraph 1 for the exact\n-   rules.  ENUM_AND_INT_P is as in comptypes_internal.  */\n+   rules.  ENUM_AND_INT_P and DIFFERENT_TYPES_P are as in\n+   comptypes_internal.  */\n \n static int\n tagged_types_tu_compatible_p (const_tree t1, const_tree t2,\n-\t\t\t      bool *enum_and_int_p)\n+\t\t\t      bool *enum_and_int_p, bool *different_types_p)\n {\n   tree s1, s2;\n   bool needs_warning = false;\n@@ -1396,7 +1441,7 @@ tagged_types_tu_compatible_p (const_tree t1, const_tree t2,\n \t    if (DECL_NAME (s1) != DECL_NAME (s2))\n \t      break;\n \t    result = comptypes_internal (TREE_TYPE (s1), TREE_TYPE (s2),\n-\t\t\t\t\t enum_and_int_p);\n+\t\t\t\t\t enum_and_int_p, different_types_p);\n \n \t    if (result != 1 && !DECL_NAME (s1))\n \t      break;\n@@ -1432,7 +1477,8 @@ tagged_types_tu_compatible_p (const_tree t1, const_tree t2,\n \t\t  int result;\n \n \t\t  result = comptypes_internal (TREE_TYPE (s1), TREE_TYPE (s2),\n-\t\t\t\t\t       enum_and_int_p);\n+\t\t\t\t\t       enum_and_int_p,\n+\t\t\t\t\t       different_types_p);\n \n \t\t  if (result != 1 && !DECL_NAME (s1))\n \t\t    continue;\n@@ -1475,7 +1521,7 @@ tagged_types_tu_compatible_p (const_tree t1, const_tree t2,\n \t\t|| DECL_NAME (s1) != DECL_NAME (s2))\n \t      break;\n \t    result = comptypes_internal (TREE_TYPE (s1), TREE_TYPE (s2),\n-\t\t\t\t\t enum_and_int_p);\n+\t\t\t\t\t enum_and_int_p, different_types_p);\n \t    if (result == 0)\n \t      break;\n \t    if (result == 2)\n@@ -1504,11 +1550,11 @@ tagged_types_tu_compatible_p (const_tree t1, const_tree t2,\n    Otherwise, if one type specifies only the number of arguments,\n    the other must specify that number of self-promoting arg types.\n    Otherwise, the argument types must match.\n-   ENUM_AND_INT_P is as in comptypes_internal.  */\n+   ENUM_AND_INT_P and DIFFERENT_TYPES_P are as in comptypes_internal.  */\n \n static int\n function_types_compatible_p (const_tree f1, const_tree f2,\n-\t\t\t     bool *enum_and_int_p)\n+\t\t\t     bool *enum_and_int_p, bool *different_types_p)\n {\n   tree args1, args2;\n   /* 1 if no need for warning yet, 2 if warning cause has been seen.  */\n@@ -1529,13 +1575,17 @@ function_types_compatible_p (const_tree f1, const_tree f2,\n   if (TYPE_VOLATILE (ret2))\n     ret2 = build_qualified_type (TYPE_MAIN_VARIANT (ret2),\n \t\t\t\t TYPE_QUALS (ret2) & ~TYPE_QUAL_VOLATILE);\n-  val = comptypes_internal (ret1, ret2, enum_and_int_p);\n+  val = comptypes_internal (ret1, ret2, enum_and_int_p, different_types_p);\n   if (val == 0)\n     return 0;\n \n   args1 = TYPE_ARG_TYPES (f1);\n   args2 = TYPE_ARG_TYPES (f2);\n \n+  if (different_types_p != NULL\n+      && (args1 == 0) != (args2 == 0))\n+    *different_types_p = true;\n+\n   /* An unspecified parmlist matches any specified parmlist\n      whose argument types don't need default promotions.  */\n \n@@ -1548,7 +1598,7 @@ function_types_compatible_p (const_tree f1, const_tree f2,\n \t If they don't match, ask for a warning (but no error).  */\n       if (TYPE_ACTUAL_ARG_TYPES (f1)\n \t  && 1 != type_lists_compatible_p (args2, TYPE_ACTUAL_ARG_TYPES (f1),\n-\t\t\t\t\t   enum_and_int_p))\n+\t\t\t\t\t   enum_and_int_p, different_types_p))\n \tval = 2;\n       return val;\n     }\n@@ -1558,23 +1608,25 @@ function_types_compatible_p (const_tree f1, const_tree f2,\n \treturn 0;\n       if (TYPE_ACTUAL_ARG_TYPES (f2)\n \t  && 1 != type_lists_compatible_p (args1, TYPE_ACTUAL_ARG_TYPES (f2),\n-\t\t\t\t\t   enum_and_int_p))\n+\t\t\t\t\t   enum_and_int_p, different_types_p))\n \tval = 2;\n       return val;\n     }\n \n   /* Both types have argument lists: compare them and propagate results.  */\n-  val1 = type_lists_compatible_p (args1, args2, enum_and_int_p);\n+  val1 = type_lists_compatible_p (args1, args2, enum_and_int_p,\n+\t\t\t\t  different_types_p);\n   return val1 != 1 ? val1 : val;\n }\n \n /* Check two lists of types for compatibility, returning 0 for\n    incompatible, 1 for compatible, or 2 for compatible with\n-   warning.  ENUM_AND_INT_P is as in comptypes_internal.  */\n+   warning.  ENUM_AND_INT_P and DIFFERENT_TYPES_P are as in\n+   comptypes_internal.  */\n \n static int\n type_lists_compatible_p (const_tree args1, const_tree args2,\n-\t\t\t bool *enum_and_int_p)\n+\t\t\t bool *enum_and_int_p, bool *different_types_p)\n {\n   /* 1 if no need for warning yet, 2 if warning cause has been seen.  */\n   int val = 1;\n@@ -1599,6 +1651,9 @@ type_lists_compatible_p (const_tree args1, const_tree args2,\n \t means there is supposed to be an argument\n \t but nothing is specified about what type it has.\n \t So match anything that self-promotes.  */\n+      if (different_types_p != NULL\n+\t  && (a1 == 0) != (a2 == 0))\n+\t*different_types_p = true;\n       if (a1 == 0)\n \t{\n \t  if (c_type_promotes_to (a2) != a2)\n@@ -1613,8 +1668,11 @@ type_lists_compatible_p (const_tree args1, const_tree args2,\n       else if (TREE_CODE (a1) == ERROR_MARK\n \t       || TREE_CODE (a2) == ERROR_MARK)\n \t;\n-      else if (!(newval = comptypes_internal (mv1, mv2, enum_and_int_p)))\n+      else if (!(newval = comptypes_internal (mv1, mv2, enum_and_int_p,\n+\t\t\t\t\t      different_types_p)))\n \t{\n+\t  if (different_types_p != NULL)\n+\t    *different_types_p = true;\n \t  /* Allow  wait (union {union wait *u; int *i} *)\n \t     and  wait (union wait *)  to be compatible.  */\n \t  if (TREE_CODE (a1) == UNION_TYPE\n@@ -1632,7 +1690,8 @@ type_lists_compatible_p (const_tree args1, const_tree args2,\n \t\t  if (mv3 && mv3 != error_mark_node\n \t\t      && TREE_CODE (mv3) != ARRAY_TYPE)\n \t\t    mv3 = TYPE_MAIN_VARIANT (mv3);\n-\t\t  if (comptypes_internal (mv3, mv2, enum_and_int_p))\n+\t\t  if (comptypes_internal (mv3, mv2, enum_and_int_p,\n+\t\t\t\t\t  different_types_p))\n \t\t    break;\n \t\t}\n \t      if (memb == 0)\n@@ -1653,7 +1712,8 @@ type_lists_compatible_p (const_tree args1, const_tree args2,\n \t\t  if (mv3 && mv3 != error_mark_node\n \t\t      && TREE_CODE (mv3) != ARRAY_TYPE)\n \t\t    mv3 = TYPE_MAIN_VARIANT (mv3);\n-\t\t  if (comptypes_internal (mv3, mv1, enum_and_int_p))\n+\t\t  if (comptypes_internal (mv3, mv1, enum_and_int_p,\n+\t\t\t\t\t  different_types_p))\n \t\t    break;\n \t\t}\n \t      if (memb == 0)"}, {"sha": "1e748af68650015ab1314a6f98f13ecb86f2973d", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc5027f47440baef6b984b029fb5c3e5ee59e5ba/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc5027f47440baef6b984b029fb5c3e5ee59e5ba/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=dc5027f47440baef6b984b029fb5c3e5ee59e5ba", "patch": "@@ -1,3 +1,9 @@\n+2010-05-23  Joseph Myers  <joseph@codesourcery.com>\n+\n+\t* gcc.dg/c1x-typedef-1.c, gcc.dg/c1x-typedef-2.c,\n+\tgcc.dg/c90-typedef-1.c, gcc.dg/c99-typedef-1.c: New tests.\n+\t* gcc.dg/decl-8.c: Use -std=gnu89 -pedantic-errors.\n+\n 2010-05-23  H.J. Lu  <hongjiu.lu@intel.com>\n \n \t* gcc.c-target/pr43869.c: Move \"dg-do run\" before lp64."}, {"sha": "2b0bc74208acce337609393a00ae5a2bfeb5b1f4", "filename": "gcc/testsuite/gcc.dg/c1x-typedef-1.c", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc5027f47440baef6b984b029fb5c3e5ee59e5ba/gcc%2Ftestsuite%2Fgcc.dg%2Fc1x-typedef-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc5027f47440baef6b984b029fb5c3e5ee59e5ba/gcc%2Ftestsuite%2Fgcc.dg%2Fc1x-typedef-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc1x-typedef-1.c?ref=dc5027f47440baef6b984b029fb5c3e5ee59e5ba", "patch": "@@ -0,0 +1,68 @@\n+/* Test typedef redeclaration in C1X.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=c1x -pedantic-errors\" } */\n+\n+/* C1X permits typedefs to be redeclared to the same type, but not to\n+   different-but-compatible types.  */\n+\n+#include <limits.h>\n+\n+typedef int TI;\n+typedef int TI2;\n+typedef TI2 TI;\n+typedef TI TI2;\n+\n+enum e { E1 = 0, E2 = INT_MAX, E3 = -1 };\n+typedef enum e TE;\n+typedef enum e TE; /* { dg-message \"previous declaration\" } */\n+typedef int TE; /* { dg-error \"with different type\" } */\n+\n+struct s;\n+typedef struct s TS;\n+struct s { int i; };\n+typedef struct s TS;\n+\n+typedef int IA[];\n+typedef TI2 IA[]; /* { dg-message \"previous declaration\" } */\n+typedef int A2[2];\n+typedef TI A2[2]; /* { dg-message \"previous declaration\" } */\n+typedef IA A2; /* { dg-error \"with different type\" } */\n+typedef int A3[3];\n+typedef A3 IA; /* { dg-error \"with different type\" } */\n+\n+typedef void F(int);\n+typedef void F(TI); /* { dg-message \"previous declaration\" } */\n+typedef void F(enum e); /* { dg-error \"with different type\" } */\n+\n+typedef int G(void);\n+typedef TI G(void); /* { dg-message \"previous declaration\" } */\n+typedef enum e G(void); /* { dg-error \"with different type\" } */\n+\n+typedef int *P;\n+typedef TI *P; /* { dg-message \"previous declaration\" } */\n+typedef enum e *P; /* { dg-error \"with different type\" } */\n+\n+typedef void F2();\n+typedef void F2(); /* { dg-message \"previous declaration\" } */\n+typedef void F2(int); /* { dg-error \"with different type\" } */\n+\n+void\n+f (void)\n+{\n+  int a = 1;\n+  int b = 2;\n+  typedef void FN(int (*p)[a]);\n+  typedef void FN(int (*p)[b]);\n+  typedef void FN(int (*p)[*]); /* { dg-message \"previous declaration\" } */\n+  typedef void FN(int (*p)[1]); /* { dg-error \"with different type\" } */\n+  typedef void FN2(int (*p)[a]);\n+  typedef void FN2(int (*p)[b]);\n+  typedef void FN2(int (*p)[*]); /* { dg-message \"previous declaration\" } */\n+  typedef void FN2(int (*p)[]); /* { dg-error \"with different type\" } */\n+  typedef int AV[a]; /* { dg-message \"previous declaration\" } */\n+  typedef int AV[b-1]; /* { dg-warning \"may be a constraint violation at runtime\" } */\n+  typedef int AAa[a];\n+  typedef int AAb[b-1];\n+  typedef AAa *VF(void); /* { dg-message \"previous declaration\" } */\n+  typedef AAb *VF(void); /* { dg-warning \"may be a constraint violation at runtime\" } */\n+}"}, {"sha": "fb5d918a5d38ba8d38e8e5966dd44360acfed35e", "filename": "gcc/testsuite/gcc.dg/c1x-typedef-2.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc5027f47440baef6b984b029fb5c3e5ee59e5ba/gcc%2Ftestsuite%2Fgcc.dg%2Fc1x-typedef-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc5027f47440baef6b984b029fb5c3e5ee59e5ba/gcc%2Ftestsuite%2Fgcc.dg%2Fc1x-typedef-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc1x-typedef-2.c?ref=dc5027f47440baef6b984b029fb5c3e5ee59e5ba", "patch": "@@ -0,0 +1,18 @@\n+/* Test typedef redeclaration in C1X.  Side effects from duplicate\n+   declarations still apply.  */\n+/* { dg-do run } */\n+/* { dg-options \"-std=c1x -pedantic-errors\" } */\n+\n+extern void exit (int);\n+extern void abort (void);\n+\n+int\n+main (void)\n+{\n+  int a = 1, b = 1;\n+  typedef int T[++a]; /* { dg-message \"previous declaration\" } */\n+  typedef int T[++b]; /* { dg-warning \"may be a constraint violation at runtime\" } */\n+  if (a != 2 || b != 2)\n+    abort ();\n+  exit (0);\n+}"}, {"sha": "1920f3b51918eb41123b63df75c86ba44a661708", "filename": "gcc/testsuite/gcc.dg/c90-typedef-1.c", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc5027f47440baef6b984b029fb5c3e5ee59e5ba/gcc%2Ftestsuite%2Fgcc.dg%2Fc90-typedef-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc5027f47440baef6b984b029fb5c3e5ee59e5ba/gcc%2Ftestsuite%2Fgcc.dg%2Fc90-typedef-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc90-typedef-1.c?ref=dc5027f47440baef6b984b029fb5c3e5ee59e5ba", "patch": "@@ -0,0 +1,6 @@\n+/* Test typedef redeclaration not permitted in C90.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=iso9899:1990 -pedantic-errors\" } */\n+\n+typedef int TI; /* { dg-message \"previous declaration\" } */\n+typedef int TI; /* { dg-error \"redefinition of typedef\" } */"}, {"sha": "8aacb3bc2d71c91159c42558ddb57d7b9a373ef3", "filename": "gcc/testsuite/gcc.dg/c99-typedef-1.c", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc5027f47440baef6b984b029fb5c3e5ee59e5ba/gcc%2Ftestsuite%2Fgcc.dg%2Fc99-typedef-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc5027f47440baef6b984b029fb5c3e5ee59e5ba/gcc%2Ftestsuite%2Fgcc.dg%2Fc99-typedef-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc99-typedef-1.c?ref=dc5027f47440baef6b984b029fb5c3e5ee59e5ba", "patch": "@@ -0,0 +1,6 @@\n+/* Test typedef redeclaration not permitted in C99.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=iso9899:1999 -pedantic-errors\" } */\n+\n+typedef int TI; /* { dg-message \"previous declaration\" } */\n+typedef int TI; /* { dg-error \"redefinition of typedef\" } */"}, {"sha": "485065b7aa12c08edcf87fad932ac37f3dbaacc3", "filename": "gcc/testsuite/gcc.dg/decl-8.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc5027f47440baef6b984b029fb5c3e5ee59e5ba/gcc%2Ftestsuite%2Fgcc.dg%2Fdecl-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc5027f47440baef6b984b029fb5c3e5ee59e5ba/gcc%2Ftestsuite%2Fgcc.dg%2Fdecl-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdecl-8.c?ref=dc5027f47440baef6b984b029fb5c3e5ee59e5ba", "patch": "@@ -1,7 +1,7 @@\n /* Test diagnostics for duplicate typedefs.  Basic diagnostics.  */\n /* Origin: Joseph Myers <joseph@codesourcery.com> */\n /* { dg-do compile } */\n-/* { dg-options \"\" } */\n+/* { dg-options \"-std=gnu89 -pedantic-errors\" } */\n \n typedef int I; /* { dg-message \"note: previous declaration of 'I' was here\" } */\n typedef int I; /* { dg-error \"redefinition of typedef 'I'\" } */"}]}