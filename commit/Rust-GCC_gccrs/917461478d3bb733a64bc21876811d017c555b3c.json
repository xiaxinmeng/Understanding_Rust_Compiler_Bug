{"sha": "917461478d3bb733a64bc21876811d017c555b3c", "node_id": "C_kwDOANBUbNoAKDkxNzQ2MTQ3OGQzYmI3MzNhNjRiYzIxODc2ODExZDAxN2M1NTViM2M", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2022-09-14T06:32:34Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2022-09-18T07:03:17Z"}, "message": "Rewrite NAN and sign handling in frange\n\nThe attatched patch rewrites the NAN and sign handling, dropping both\ntristates in favor of a pair of boolean flags for NANs, and nothing at\nall for signs.  The signs are tracked in the range itself, so now it's\npossible to describe things like [-0.0, +0.0] +NAN, [+0, +0], [-5, +0],\n[+0, 3] -NAN, etc.\n\nHere is an example of the various ranges and how they are displayed:\n\n    [frange] float VARYING NAN ;; Varying includes NAN\n    [frange] UNDEFINED                      ;; Empty set as always\n    [frange] float [] +-NAN                 ;; Unknown sign NAN\n    [frange] float [] -NAN                  ;; -NAN\n    [frange] float [] +NAN                  ;; +NAN\n    [frange] float [-0.0, 0.0]              ;; All zeros.\n    [frange] float [-0.0, -0.0] +-NAN       ;; -0 or NAN.\n    [frange] float [-5.0e+0, -1.0e+0] +NAN  ;; [-5, -1] or +NAN\n    [frange] float [-5.0e+0, -0.0] +-NAN    ;; [-5, -0] or NAN\n    [frange] float [-5.0e+0, -0.0]          ;; [-5, -0]\n    [frange] float [5.0e+0, 1.0e+1]         ;; [5, 10]\n\nNotice the NAN signs are decoupled from the range, so we can represent\na negative range with a positive NAN.  For this range,\nfrange::signbit_p() would return false, as only when the signs of the\nNANs and range agree can we be certain.\n\nThere is no longer any pessimization of ranges for intersects\ninvolving NANs.  Also, union and intersect work with signed zeros:\n\n//   [-0,  x] U [+0,  x] => [-0,  x]\n//   [ x, -0] U [ x, +0] => [ x, +0]\n//   [-0,  x] ^ [+0,  x] => [+0,  x]\n//   [ x, -0] ^ [ x, +0] => [ x, -0]\n\nThe special casing for signed zeros in the singleton code is gone in\nfavor of just making sure the signs in the range agree, that is\n[-0, -0] for example.\n\nI have removed the idea that a known NAN is a \"range\", so a NAN is no\nlonger in the endpoints itself.  Requesting the bound of a known NAN\nis a hard fail.  For that matter, we don't store the actual NAN in the\nrange.  The only information we have are the set of boolean flags.\nThis way we make sure nothing seeps into the frange.  This also means\nit's explicit that we don't track anything but the sign in NANs.  We\ncan revisit this if we desire to track signalling or whatever\nconcoction y'all can imagine.\n\nRegstrapped with mpfr tests on x86-64 and ppc64le Linux.  Selftests\nwere also run with -ffinite-math-only on x86-64.\n\nAt Jakub's suggestion, I built lapack with associated tests.  They\npass on x86-64 and ppc64le Linux with no regressions from mainline.\nAs a sanity check, I also ran them for -ffinite-math-only on x86 which\n(as expected) returned:\n\n\tNaN arithmetic did not perform per the ieee spec\n\nOtherwise, all tests pass for -ffinite-math-only.\n\ngcc/ChangeLog:\n\n\t* range-op-float.cc (frange_add_zeros): Replace set_signbit with\n\tunion of zero.\n\t* value-query.cc (range_query::get_tree_range): Remove set_signbit\n\tuse.\n\t* value-range-pretty-print.cc (vrange_printer::print_frange_prop):\n\tRemove.\n\t(vrange_printer::print_frange_nan): New.\n\t* value-range-pretty-print.h (print_frange_prop): Remove.\n\t(print_frange_nan): New.\n\t* value-range-storage.cc (frange_storage_slot::set_frange): Set\n\tkind and NAN fields.\n\t(frange_storage_slot::get_frange): Restore kind and NAN fields.\n\t* value-range-storage.h (class frange_storage_slot): Add kind and\n\tNAN fields.\n\t* value-range.cc (frange::update_nan): Remove.\n\t(frange::set_signbit): Remove.\n\t(frange::set): Adjust for NAN fields.\n\t(frange::normalize_kind): Remove m_props.\n\t(frange::combine_zeros): New.\n\t(frange::union_nans): New.\n\t(frange::union_): Handle new NAN fields.\n\t(frange::intersect_nans): New.\n\t(frange::intersect): Handle new NAN fields.\n\t(frange::operator=): Same.\n\t(frange::operator==): Same.\n\t(frange::contains_p): Same.\n\t(frange::singleton_p): Remove special case for signed zeros.\n\t(frange::verify_range): Adjust for new NAN fields.\n\t(frange::set_zero): Handle signed zeros.\n\t(frange::set_nonnegative): Same.\n\t(range_tests_nan): Adjust tests.\n\t(range_tests_signed_zeros): Same.\n\t(range_tests_signbit): Same.\n\t(range_tests_floats): Same.\n\t* value-range.h (class fp_prop): Remove.\n\t(FP_PROP_ACCESSOR): Remove.\n\t(class frange_props): Remove\n\t(frange::lower_bound): NANs don't have endpoints.\n\t(frange::upper_bound): Same.\n\t(frange_props::operator==): Remove.\n\t(frange_props::union_): Remove.\n\t(frange_props::intersect): Remove.\n\t(frange::update_nan): New.\n\t(frange::clear_nan): New.\n\t(frange::undefined_p): New.\n\t(frange::set_nan): New.\n\t(frange::known_finite): Adjust for new NAN representation.\n\t(frange::maybe_isnan): Same.\n\t(frange::known_isnan): Same.\n\t(frange::signbit_p): Same.\n\t* gimple-range-fold.cc (range_of_builtin_int_call): Rename\n\tknown_signbit_p into signbit_p.", "tree": {"sha": "c07d32f70967fcd5e4f78a469b18d7b879460cf8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c07d32f70967fcd5e4f78a469b18d7b879460cf8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/917461478d3bb733a64bc21876811d017c555b3c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/917461478d3bb733a64bc21876811d017c555b3c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/917461478d3bb733a64bc21876811d017c555b3c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/917461478d3bb733a64bc21876811d017c555b3c/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "205a6fb2a0c5285e77a4f25da36d0a1af7ab104a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/205a6fb2a0c5285e77a4f25da36d0a1af7ab104a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/205a6fb2a0c5285e77a4f25da36d0a1af7ab104a"}], "stats": {"total": 966, "additions": 481, "deletions": 485}, "files": [{"sha": "a45fc7ad4c61a6699c9f642272cfe835d78a31fe", "filename": "gcc/gimple-range-fold.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/917461478d3bb733a64bc21876811d017c555b3c/gcc%2Fgimple-range-fold.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/917461478d3bb733a64bc21876811d017c555b3c/gcc%2Fgimple-range-fold.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-fold.cc?ref=917461478d3bb733a64bc21876811d017c555b3c", "patch": "@@ -1030,7 +1030,7 @@ fold_using_range::range_of_builtin_int_call (irange &r, gcall *call,\n \tif (src.get_operand (tmp, arg))\n \t  {\n \t    bool signbit;\n-\t    if (tmp.known_signbit (signbit))\n+\t    if (tmp.signbit_p (signbit))\n \t      {\n \t\tif (signbit)\n \t\t  r.set_nonzero (type);"}, {"sha": "1e39a07ab978429bef510bf42f69e2e7d98e6abf", "filename": "gcc/range-op-float.cc", "status": "modified", "additions": 21, "deletions": 17, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/917461478d3bb733a64bc21876811d017c555b3c/gcc%2Frange-op-float.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/917461478d3bb733a64bc21876811d017c555b3c/gcc%2Frange-op-float.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frange-op-float.cc?ref=917461478d3bb733a64bc21876811d017c555b3c", "patch": "@@ -155,15 +155,15 @@ range_operator_float::op1_op2_relation (const irange &lhs ATTRIBUTE_UNUSED) cons\n static inline bool\n finite_operand_p (const frange &op1)\n {\n-  return flag_finite_math_only || !op1.maybe_nan ();\n+  return flag_finite_math_only || !op1.maybe_isnan ();\n }\n \n // Return TRUE if OP1 and OP2 are known to be free of NANs.\n \n static inline bool\n finite_operands_p (const frange &op1, const frange &op2)\n {\n-  return flag_finite_math_only || (!op1.maybe_nan () && !op2.maybe_nan ());\n+  return flag_finite_math_only || (!op1.maybe_isnan () && !op2.maybe_isnan ());\n }\n \n // Floating version of relop_early_resolve that takes into account NAN\n@@ -213,20 +213,24 @@ frange_drop_ninf (frange &r, tree type)\n static inline void\n frange_add_zeros (frange &r, tree type)\n {\n-  if (r.undefined_p () || r.known_nan ())\n+  if (r.undefined_p () || r.known_isnan ())\n     return;\n \n   if (HONOR_SIGNED_ZEROS (type)\n       && (real_iszero (&r.lower_bound ()) || real_iszero (&r.upper_bound ())))\n-    r.set_signbit (fp_prop::VARYING);\n+    {\n+      frange zero;\n+      zero.set_zero (type);\n+      r.union_ (zero);\n+    }\n }\n \n // Build a range that is <= VAL and store it in R.\n \n static bool\n build_le (frange &r, tree type, const frange &val)\n {\n-  if (val.known_nan ())\n+  if (val.known_isnan ())\n     {\n       r.set_undefined ();\n       return false;\n@@ -244,7 +248,7 @@ build_le (frange &r, tree type, const frange &val)\n static bool\n build_lt (frange &r, tree type, const frange &val)\n {\n-  if (val.known_nan ())\n+  if (val.known_isnan ())\n     {\n       r.set_undefined ();\n       return false;\n@@ -268,7 +272,7 @@ build_lt (frange &r, tree type, const frange &val)\n static bool\n build_ge (frange &r, tree type, const frange &val)\n {\n-  if (val.known_nan ())\n+  if (val.known_isnan ())\n     {\n       r.set_undefined ();\n       return false;\n@@ -286,7 +290,7 @@ build_ge (frange &r, tree type, const frange &val)\n static bool\n build_gt (frange &r, tree type, const frange &val)\n {\n-  if (val.known_nan ())\n+  if (val.known_isnan ())\n     {\n       r.set_undefined ();\n       return false;\n@@ -551,7 +555,7 @@ foperator_lt::fold_range (irange &r, tree type,\n       else\n \tr = range_true_and_false (type);\n     }\n-  else if (op1.known_nan () || op2.known_nan ())\n+  else if (op1.known_isnan () || op2.known_isnan ())\n     r = range_false (type);\n   else\n     r = range_true_and_false (type);\n@@ -653,7 +657,7 @@ foperator_le::fold_range (irange &r, tree type,\n       else\n \tr = range_true_and_false (type);\n     }\n-  else if (op1.known_nan () || op2.known_nan ())\n+  else if (op1.known_isnan () || op2.known_isnan ())\n     r = range_false (type);\n   else\n     r = range_true_and_false (type);\n@@ -747,7 +751,7 @@ foperator_gt::fold_range (irange &r, tree type,\n       else\n \tr = range_true_and_false (type);\n     }\n-  else if (op1.known_nan () || op2.known_nan ())\n+  else if (op1.known_isnan () || op2.known_isnan ())\n     r = range_false (type);\n   else\n     r = range_true_and_false (type);\n@@ -849,7 +853,7 @@ foperator_ge::fold_range (irange &r, tree type,\n       else\n \tr = range_true_and_false (type);\n     }\n-  else if (op1.known_nan () || op2.known_nan ())\n+  else if (op1.known_isnan () || op2.known_isnan ())\n     r = range_false (type);\n   else\n     r = range_true_and_false (type);\n@@ -932,10 +936,10 @@ foperator_unordered::fold_range (irange &r, tree type,\n \t\t\t\t relation_kind) const\n {\n   // UNORDERED is TRUE if either operand is a NAN.\n-  if (op1.known_nan () || op2.known_nan ())\n+  if (op1.known_isnan () || op2.known_isnan ())\n     r = range_true (type);\n   // UNORDERED is FALSE if neither operand is a NAN.\n-  else if (!op1.maybe_nan () && !op2.maybe_nan ())\n+  else if (!op1.maybe_isnan () && !op2.maybe_isnan ())\n     r = range_false (type);\n   else\n     r = range_true_and_false (type);\n@@ -954,7 +958,7 @@ foperator_unordered::op1_range (frange &r, tree type,\n       r.set_varying (type);\n       // Since at least one operand must be NAN, if one of them is\n       // not, the other must be.\n-      if (!op2.maybe_nan ())\n+      if (!op2.maybe_isnan ())\n \tr.set_nan (type);\n       break;\n \n@@ -998,9 +1002,9 @@ foperator_ordered::fold_range (irange &r, tree type,\n \t\t\t       const frange &op1, const frange &op2,\n \t\t\t       relation_kind) const\n {\n-  if (!op1.maybe_nan () && !op2.maybe_nan ())\n+  if (!op1.maybe_isnan () && !op2.maybe_isnan ())\n     r = range_true (type);\n-  else if (op1.known_nan () || op2.known_nan ())\n+  else if (op1.known_isnan () || op2.known_isnan ())\n     r = range_false (type);\n   else\n     r = range_true_and_false (type);"}, {"sha": "0bdd670982b50709b77b0bf02c6a089e615725c7", "filename": "gcc/value-query.cc", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/917461478d3bb733a64bc21876811d017c555b3c/gcc%2Fvalue-query.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/917461478d3bb733a64bc21876811d017c555b3c/gcc%2Fvalue-query.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-query.cc?ref=917461478d3bb733a64bc21876811d017c555b3c", "patch": "@@ -219,17 +219,8 @@ range_query::get_tree_range (vrange &r, tree expr, gimple *stmt)\n       {\n \tfrange &f = as_a <frange> (r);\n \tf.set (expr, expr);\n-\n-\t// Singletons from the tree world have known properties.\n-\tREAL_VALUE_TYPE *rv = TREE_REAL_CST_PTR (expr);\n-\tif (real_isnan (rv))\n-\t  f.update_nan (fp_prop::YES);\n-\telse\n+\tif (!real_isnan (TREE_REAL_CST_PTR (expr)))\n \t  f.clear_nan ();\n-\tif (real_isneg (rv))\n-\t  f.set_signbit (fp_prop::YES);\n-\telse\n-\t  f.set_signbit (fp_prop::NO);\n \treturn true;\n       }\n "}, {"sha": "eb7442229babf32f2ccdb8900cce30224898d28d", "filename": "gcc/value-range-pretty-print.cc", "status": "modified", "additions": 25, "deletions": 20, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/917461478d3bb733a64bc21876811d017c555b3c/gcc%2Fvalue-range-pretty-print.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/917461478d3bb733a64bc21876811d017c555b3c/gcc%2Fvalue-range-pretty-print.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-range-pretty-print.cc?ref=917461478d3bb733a64bc21876811d017c555b3c", "patch": "@@ -134,34 +134,39 @@ vrange_printer::visit (const frange &r) const\n   if (r.varying_p ())\n     {\n       pp_string (pp, \"VARYING\");\n+      print_frange_nan (r);\n       return;\n     }\n   pp_character (pp, '[');\n-  dump_generic_node (pp,\n-\t\t     build_real (type, r.lower_bound ()), 0, TDF_NONE, false);\n-  pp_string (pp, \", \");\n-  dump_generic_node (pp,\n-\t\t     build_real (type, r.upper_bound ()), 0, TDF_NONE, false);\n-  pp_string (pp, \"] \");\n-\n-  print_frange_prop (\"NAN\", r.get_nan ());\n-  print_frange_prop (\"SIGN\", r.get_signbit ());\n+  bool has_endpoints = !r.known_isnan ();\n+  if (has_endpoints)\n+    {\n+      dump_generic_node (pp,\n+\t\t\t build_real (type, r.lower_bound ()), 0, TDF_NONE, false);\n+      pp_string (pp, \", \");\n+      dump_generic_node (pp,\n+\t\t\t build_real (type, r.upper_bound ()), 0, TDF_NONE, false);\n+    }\n+  pp_character (pp, ']');\n+  print_frange_nan (r);\n }\n \n-// Print the FP properties in an frange.\n+// Print the NAN info for an frange.\n \n void\n-vrange_printer::print_frange_prop (const char *str, const fp_prop &prop) const\n+vrange_printer::print_frange_nan (const frange &r) const\n {\n-  if (prop.varying_p ())\n-    return;\n-\n-  if (prop.yes_p ())\n-    pp_string (pp, str);\n-  else if (prop.no_p ())\n+  if (r.maybe_isnan ())\n     {\n-      pp_character (pp, '!');\n-      pp_string (pp, str);\n+      if (r.m_pos_nan && r.m_neg_nan)\n+\t{\n+\t  pp_string (pp, \" +-NAN\");\n+\t  return;\n+\t}\n+      bool nan_sign = r.m_neg_nan;\n+      if (nan_sign)\n+\tpp_string (pp, \" -NAN\");\n+      else\n+\tpp_string (pp, \" +NAN\");\n     }\n-  pp_character (pp, ' ');\n }"}, {"sha": "20c26598fe75a414b94ef41b44faa009970104d8", "filename": "gcc/value-range-pretty-print.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/917461478d3bb733a64bc21876811d017c555b3c/gcc%2Fvalue-range-pretty-print.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/917461478d3bb733a64bc21876811d017c555b3c/gcc%2Fvalue-range-pretty-print.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-range-pretty-print.h?ref=917461478d3bb733a64bc21876811d017c555b3c", "patch": "@@ -31,7 +31,7 @@ class vrange_printer : public vrange_visitor\n private:\n   void print_irange_bound (const wide_int &w, tree type) const;\n   void print_irange_bitmasks (const irange &) const;\n-  void print_frange_prop (const char *str, const fp_prop &) const;\n+  void print_frange_nan (const frange &) const;\n \n   pretty_printer *pp;\n };"}, {"sha": "de7575ed48de0a29b18f23ba575b34a305ca909a", "filename": "gcc/value-range-storage.cc", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/917461478d3bb733a64bc21876811d017c555b3c/gcc%2Fvalue-range-storage.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/917461478d3bb733a64bc21876811d017c555b3c/gcc%2Fvalue-range-storage.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-range-storage.cc?ref=917461478d3bb733a64bc21876811d017c555b3c", "patch": "@@ -253,9 +253,11 @@ frange_storage_slot::set_frange (const frange &r)\n   gcc_checking_assert (fits_p (r));\n   gcc_checking_assert (!r.undefined_p ());\n \n+  m_kind = r.m_kind;\n   m_min = r.m_min;\n   m_max = r.m_max;\n-  m_props = r.m_props;\n+  m_pos_nan = r.m_pos_nan;\n+  m_neg_nan = r.m_neg_nan;\n }\n \n void\n@@ -264,11 +266,12 @@ frange_storage_slot::get_frange (frange &r, tree type) const\n   gcc_checking_assert (r.supports_type_p (type));\n \n   r.set_undefined ();\n-  r.m_kind = VR_RANGE;\n-  r.m_props = m_props;\n+  r.m_kind = m_kind;\n   r.m_type = type;\n   r.m_min = m_min;\n   r.m_max = m_max;\n+  r.m_pos_nan = m_pos_nan;\n+  r.m_neg_nan = m_neg_nan;\n   r.normalize_kind ();\n \n   if (flag_checking)"}, {"sha": "0cf95ebf7c127bf7bce9ffb4d966dc557efbcb9e", "filename": "gcc/value-range-storage.h", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/917461478d3bb733a64bc21876811d017c555b3c/gcc%2Fvalue-range-storage.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/917461478d3bb733a64bc21876811d017c555b3c/gcc%2Fvalue-range-storage.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-range-storage.h?ref=917461478d3bb733a64bc21876811d017c555b3c", "patch": "@@ -113,12 +113,11 @@ class GTY (()) frange_storage_slot\n   frange_storage_slot (const frange &r) { set_frange (r); }\n   DISABLE_COPY_AND_ASSIGN (frange_storage_slot);\n \n-  // We can get away with just storing the properties and the\n-  // endpoints because the type can be gotten from the SSA, and\n-  // UNDEFINED is unsupported, so it can only be a VR_RANGE.\n+  enum value_range_kind m_kind;\n   REAL_VALUE_TYPE m_min;\n   REAL_VALUE_TYPE m_max;\n-  frange_props m_props;\n+  bool m_pos_nan;\n+  bool m_neg_nan;\n };\n \n class obstack_vrange_allocator final: public vrange_allocator"}, {"sha": "55a216efd8bb1898b092e1af05d5f8877813e6f5", "filename": "gcc/value-range.cc", "status": "modified", "additions": 322, "deletions": 299, "changes": 621, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/917461478d3bb733a64bc21876811d017c555b3c/gcc%2Fvalue-range.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/917461478d3bb733a64bc21876811d017c555b3c/gcc%2Fvalue-range.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-range.cc?ref=917461478d3bb733a64bc21876811d017c555b3c", "patch": "@@ -267,106 +267,24 @@ tree_compare (tree_code code, tree op1, tree op2)\n   return !integer_zerop (fold_build2 (code, integer_type_node, op1, op2));\n }\n \n-// Set the NAN property.  Adjust the range if appopriate.\n-\n-void\n-frange::update_nan (fp_prop::kind k)\n-{\n-  if (k == fp_prop::YES)\n-    {\n-      if (!maybe_nan ())\n-\t{\n-\t  set_undefined ();\n-\t  return;\n-\t}\n-      gcc_checking_assert (!undefined_p ());\n-      set_nan (m_type);\n-      return;\n-    }\n-\n-  if (k == fp_prop::NO && known_nan ())\n-    {\n-      set_undefined ();\n-      return;\n-    }\n-\n-  // Setting VARYING on an obviously NAN range is a no-op.\n-  if (k == fp_prop::VARYING && real_isnan (&m_min))\n-    return;\n-\n-  m_props.set_nan (k);\n-  normalize_kind ();\n-  if (flag_checking)\n-    verify_range ();\n-}\n-\n-// Set the SIGNBIT property.  Adjust the range if appropriate.\n-\n-void\n-frange::set_signbit (fp_prop::kind k)\n-{\n-  gcc_checking_assert (m_type);\n-\n-  // No additional adjustments are needed for a NAN.\n-  if (known_nan ())\n-    {\n-      m_props.set_signbit (k);\n-      return;\n-    }\n-  // Ignore sign changes when they're set correctly.\n-  if (!maybe_nan ())\n-    {\n-      // It's negative and we're trying to make it negative or varying.\n-      if (real_less (&m_max, &dconst0) && (k == fp_prop::YES\n-\t\t\t\t\t   || k == fp_prop::VARYING))\n-\treturn;\n-      // It's positive and we're trying to make it positive or varying.\n-      if (real_less (&dconst0, &m_min) && (k == fp_prop::NO\n-\t\t\t\t\t   || k == fp_prop::VARYING))\n-\treturn;\n-    }\n-  // Adjust the range depending on the sign bit.\n-  if (k == fp_prop::YES)\n-    {\n-      // Crop the range to [-INF, 0].\n-      frange crop (m_type, dconstninf, dconst0);\n-      intersect (crop);\n-      if (!undefined_p ())\n-\tm_props.set_signbit (fp_prop::YES);\n-    }\n-  else if (k == fp_prop::NO)\n-    {\n-      // Crop the range to [0, +INF].\n-      frange crop (m_type, dconst0, dconstinf);\n-      intersect (crop);\n-      if (!undefined_p ())\n-\tm_props.set_signbit (fp_prop::NO);\n-    }\n-  else\n-    {\n-      m_props.set_signbit (fp_prop::VARYING);\n-      normalize_kind ();\n-    }\n-\n-  if (flag_checking)\n-    verify_range ();\n-}\n-\n // Setter for franges.\n \n void\n frange::set (tree min, tree max, value_range_kind kind)\n {\n-  if (kind == VR_UNDEFINED)\n+  switch (kind)\n     {\n+    case VR_UNDEFINED:\n       set_undefined ();\n       return;\n-    }\n-  // Treat VR_ANTI_RANGE and VR_VARYING as varying.\n-  if (kind != VR_RANGE)\n-    {\n+    case VR_VARYING:\n+    case VR_ANTI_RANGE:\n       set_varying (TREE_TYPE (min));\n       return;\n+    case VR_RANGE:\n+      break;\n+    default:\n+      gcc_unreachable ();\n     }\n \n   // Handle NANs.\n@@ -375,24 +293,25 @@ frange::set (tree min, tree max, value_range_kind kind)\n       gcc_checking_assert (real_identical (TREE_REAL_CST_PTR (min),\n \t\t\t\t\t   TREE_REAL_CST_PTR (max)));\n       tree type = TREE_TYPE (min);\n-      set_nan (type);\n+      bool sign = real_isneg (TREE_REAL_CST_PTR (min));\n+      set_nan (type, sign);\n       return;\n     }\n \n   m_kind = kind;\n   m_type = TREE_TYPE (min);\n-  m_props.set_varying ();\n   m_min = *TREE_REAL_CST_PTR (min);\n   m_max = *TREE_REAL_CST_PTR (max);\n-\n-  // Set SIGNBIT property for positive and negative ranges.\n-  if (real_less (&m_max, &dconst0))\n-    m_props.signbit_set_yes ();\n-  else if (real_less (&dconst0, &m_min))\n-    m_props.signbit_set_no ();\n-\n-  if (!HONOR_NANS (m_type))\n-    m_props.nan_set_no ();\n+  if (HONOR_NANS (m_type))\n+    {\n+      m_pos_nan = true;\n+      m_neg_nan = true;\n+    }\n+  else\n+    {\n+      m_pos_nan = false;\n+      m_neg_nan = false;\n+    }\n \n   // Check for swapped ranges.\n   gcc_checking_assert (tree_compare (LE_EXPR, min, max));\n@@ -423,37 +342,90 @@ frange::set (tree type,\n bool\n frange::normalize_kind ()\n {\n-  // Undefined is viral.\n-  if (m_props.nan_undefined_p () || m_props.signbit_undefined_p ())\n-    {\n-      set_undefined ();\n-      return true;\n-    }\n   if (m_kind == VR_RANGE\n       && real_isinf (&m_min, 1)\n       && real_isinf (&m_max, 0))\n     {\n-      // No FP properties set means varying.\n-      if (m_props.varying_p ())\n+      if (m_pos_nan && m_neg_nan)\n \t{\n \t  set_varying (m_type);\n \t  return true;\n \t}\n     }\n   else if (m_kind == VR_VARYING)\n     {\n-      // If a VARYING has any FP properties, it's no longer VARYING.\n-      if (!m_props.varying_p ())\n+      if (!m_pos_nan || !m_neg_nan)\n \t{\n \t  m_kind = VR_RANGE;\n \t  m_min = dconstninf;\n \t  m_max = dconstinf;\n \t  return true;\n \t}\n     }\n+  else if (m_kind == VR_NAN && !m_pos_nan && !m_neg_nan)\n+    set_undefined ();\n   return false;\n }\n \n+// Union or intersect the zero endpoints of two ranges.  For example:\n+//   [-0,  x] U [+0,  x] => [-0,  x]\n+//   [ x, -0] U [ x, +0] => [ x, +0]\n+//   [-0,  x] ^ [+0,  x] => [+0,  x]\n+//   [ x, -0] ^ [ x, +0] => [ x, -0]\n+//\n+// UNION_P is true when performing a union, or false when intersecting.\n+\n+bool\n+frange::combine_zeros (const frange &r, bool union_p)\n+{\n+  gcc_checking_assert (!undefined_p () && !known_isnan ());\n+\n+  bool changed = false;\n+  if (real_iszero (&m_min) && real_iszero (&r.m_min)\n+      && real_isneg (&m_min) != real_isneg (&r.m_min))\n+    {\n+      m_min.sign = union_p;\n+      changed = true;\n+    }\n+  if (real_iszero (&m_max) && real_iszero (&r.m_max)\n+      && real_isneg (&m_max) != real_isneg (&r.m_max))\n+    {\n+      m_max.sign = !union_p;\n+      changed = true;\n+    }\n+  // If the signs are swapped, the resulting range is empty.\n+  if (m_min.sign == 0 && m_max.sign == 1)\n+    {\n+      if (maybe_isnan ())\n+\tm_kind = VR_NAN;\n+      else\n+\tm_kind = VR_UNDEFINED;\n+      changed = true;\n+    }\n+  return changed;\n+}\n+\n+// Union two ranges when one is known to be a NAN.\n+\n+bool\n+frange::union_nans (const frange &r)\n+{\n+  gcc_checking_assert (known_isnan () || r.known_isnan ());\n+\n+  if (known_isnan ())\n+    {\n+      m_kind = r.m_kind;\n+      m_min = r.m_min;\n+      m_max = r.m_max;\n+    }\n+  m_pos_nan |= r.m_pos_nan;\n+  m_neg_nan |= r.m_neg_nan;\n+  normalize_kind ();\n+  if (flag_checking)\n+    verify_range ();\n+  return true;\n+}\n+\n bool\n frange::union_ (const vrange &v)\n {\n@@ -467,29 +439,18 @@ frange::union_ (const vrange &v)\n       return true;\n     }\n \n-  // If one side has a NAN, the union is the other side, plus the union\n-  // of the properties and the possibility of a NAN.\n-  if (known_nan ())\n+  // Combine NAN info.\n+  if (known_isnan () || r.known_isnan ())\n+    return union_nans (r);\n+  bool changed = false;\n+  if (m_pos_nan != r.m_pos_nan || m_neg_nan != r.m_neg_nan)\n     {\n-      frange_props save = m_props;\n-      *this = r;\n-      m_props = save;\n-      m_props.union_ (r.m_props);\n-      update_nan (fp_prop::VARYING);\n-      if (flag_checking)\n-\tverify_range ();\n-      return true;\n-    }\n-  if (r.known_nan ())\n-    {\n-      m_props.union_ (r.m_props);\n-      update_nan (fp_prop::VARYING);\n-      if (flag_checking)\n-\tverify_range ();\n-      return true;\n+      m_pos_nan |= r.m_pos_nan;\n+      m_neg_nan |= r.m_neg_nan;\n+      changed = true;\n     }\n \n-  bool changed = m_props.union_ (r.m_props);\n+  // Combine endpoints.\n   if (real_less (&r.m_min, &m_min))\n     {\n       m_min = r.m_min;\n@@ -500,13 +461,34 @@ frange::union_ (const vrange &v)\n       m_max = r.m_max;\n       changed = true;\n     }\n-  changed |= normalize_kind ();\n \n+  if (HONOR_SIGNED_ZEROS (m_type))\n+    changed |= combine_zeros (r, true);\n+\n+  changed |= normalize_kind ();\n   if (flag_checking)\n     verify_range ();\n   return changed;\n }\n \n+// Intersect two ranges when one is known to be a NAN.\n+\n+bool\n+frange::intersect_nans (const frange &r)\n+{\n+  gcc_checking_assert (known_isnan () || r.known_isnan ());\n+\n+  m_pos_nan &= r.m_pos_nan;\n+  m_neg_nan &= r.m_neg_nan;\n+  if (maybe_isnan ())\n+    m_kind = VR_NAN;\n+  else\n+    m_kind = VR_UNDEFINED;\n+  if (flag_checking)\n+    verify_range ();\n+  return true;\n+}\n+\n bool\n frange::intersect (const vrange &v)\n {\n@@ -525,25 +507,18 @@ frange::intersect (const vrange &v)\n       return true;\n     }\n \n-  // If two NANs are not exactly the same, drop to an unknown NAN,\n-  // otherwise there's nothing to do.\n-  if (known_nan () && r.known_nan ())\n-    {\n-      if (m_props == r.m_props)\n-\treturn false;\n-\n-      set_nan (m_type);\n-      return true;\n-    }\n-  // ?? Perhaps the intersection of a NAN and anything is a NAN ??.\n-  if (known_nan () || r.known_nan ())\n+  // Combine NAN info.\n+  if (known_isnan () || r.known_isnan ())\n+    return intersect_nans (r);\n+  bool changed = false;\n+  if (m_pos_nan != r.m_pos_nan || m_neg_nan != r.m_neg_nan)\n     {\n-      set_varying (m_type);\n-      return true;\n+      m_pos_nan &= r.m_pos_nan;\n+      m_neg_nan &= r.m_neg_nan;\n+      changed = true;\n     }\n \n-  bool changed = m_props.intersect (r.m_props);\n-\n+  // Combine endpoints.\n   if (real_less (&m_min, &r.m_min))\n     {\n       m_min = r.m_min;\n@@ -554,14 +529,22 @@ frange::intersect (const vrange &v)\n       m_max = r.m_max;\n       changed = true;\n     }\n-  // If the endpoints are swapped, the ranges are disjoint.\n+  // If the endpoints are swapped, the resulting range is empty.\n   if (real_less (&m_max, &m_min))\n     {\n-      set_undefined ();\n+      if (maybe_isnan ())\n+\tm_kind = VR_NAN;\n+      else\n+\tm_kind = VR_UNDEFINED;\n+      if (flag_checking)\n+\tverify_range ();\n       return true;\n     }\n-  changed |= normalize_kind ();\n \n+  if (HONOR_SIGNED_ZEROS (m_type))\n+    changed |= combine_zeros (r, false);\n+\n+  changed |= normalize_kind ();\n   if (flag_checking)\n     verify_range ();\n   return changed;\n@@ -574,7 +557,8 @@ frange::operator= (const frange &src)\n   m_type = src.m_type;\n   m_min = src.m_min;\n   m_max = src.m_max;\n-  m_props = src.m_props;\n+  m_pos_nan = src.m_pos_nan;\n+  m_neg_nan = src.m_neg_nan;\n \n   if (flag_checking)\n     verify_range ();\n@@ -592,12 +576,13 @@ frange::operator== (const frange &src) const\n       if (varying_p ())\n \treturn types_compatible_p (m_type, src.m_type);\n \n-      if (known_nan () || src.known_nan ())\n+      if (known_isnan () || src.known_isnan ())\n \treturn false;\n \n       return (real_identical (&m_min, &src.m_min)\n \t      && real_identical (&m_max, &src.m_max)\n-\t      && m_props == src.m_props\n+\t      && m_pos_nan == src.m_pos_nan\n+\t      && m_neg_nan == src.m_neg_nan\n \t      && types_compatible_p (m_type, src.m_type));\n     }\n   return false;\n@@ -617,21 +602,24 @@ frange::contains_p (tree cst) const\n   if (varying_p ())\n     return true;\n \n+  if (real_isnan (rv))\n+    {\n+      // No NAN in range.\n+      if (!m_pos_nan && !m_neg_nan)\n+\treturn false;\n+      // Both +NAN and -NAN are present.\n+      if (m_pos_nan && m_neg_nan)\n+\treturn true;\n+      return m_neg_nan == rv->sign;\n+    }\n+  if (known_isnan ())\n+    return false;\n \n   if (real_compare (GE_EXPR, rv, &m_min) && real_compare (LE_EXPR, rv, &m_max))\n     {\n+      // Make sure the signs are equal for signed zeros.\n       if (HONOR_SIGNED_ZEROS (m_type) && real_iszero (rv))\n-\t{\n-\t  // FIXME: This is still using get_signbit() instead of\n-\t  // known_signbit() because the latter bails on possible NANs\n-\t  // (for now).\n-\t  if (get_signbit ().yes_p ())\n-\t    return real_isneg (rv);\n-\t  else if (get_signbit ().no_p ())\n-\t    return !real_isneg (rv);\n-\t  else\n-\t    return true;\n-\t}\n+\treturn m_min.sign == m_max.sign && m_min.sign == rv->sign;\n       return true;\n     }\n   return false;\n@@ -648,29 +636,9 @@ frange::singleton_p (tree *result) const\n   if (m_kind == VR_RANGE && real_identical (&m_min, &m_max))\n     {\n       // Return false for any singleton that may be a NAN.\n-      if (HONOR_NANS (m_type) && maybe_nan ())\n+      if (HONOR_NANS (m_type) && maybe_isnan ())\n \treturn false;\n \n-      // Return the appropriate zero if known.\n-      if (HONOR_SIGNED_ZEROS (m_type) && zero_p ())\n-\t{\n-\t  bool signbit;\n-\t  if (known_signbit (signbit))\n-\t    {\n-\t      if (signbit)\n-\t\t{\n-\t\t  if (result)\n-\t\t    *result = build_real (m_type, real_value_negate (&dconst0));\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  if (result)\n-\t\t    *result = build_real (m_type, dconst0);\n-\t\t}\n-\t      return true;\n-\t    }\n-\t  return false;\n-\t}\n       if (result)\n \t*result = build_real (m_type, m_min);\n       return true;\n@@ -687,57 +655,40 @@ frange::supports_type_p (const_tree type) const\n void\n frange::verify_range ()\n {\n-  if (undefined_p ())\n+  switch (m_kind)\n     {\n-      gcc_checking_assert (m_props.undefined_p ());\n+    case VR_UNDEFINED:\n+      // m_type is ignored.\n       return;\n-    }\n-  gcc_checking_assert (!m_props.undefined_p ());\n-\n-  if (varying_p ())\n-    {\n-      gcc_checking_assert (m_props.varying_p ());\n+    case VR_VARYING:\n+      gcc_checking_assert (m_type);\n+      gcc_checking_assert (m_pos_nan && m_neg_nan);\n+      gcc_checking_assert (real_isinf (&m_min, 1));\n+      gcc_checking_assert (real_isinf (&m_max, 0));\n       return;\n+    case VR_RANGE:\n+      gcc_checking_assert (m_type);\n+      break;\n+    case VR_NAN:\n+      gcc_checking_assert (m_type);\n+      gcc_checking_assert (m_pos_nan || m_neg_nan);\n+      return;\n+    default:\n+      gcc_unreachable ();\n     }\n \n-  // We don't support the inverse of an frange (yet).\n-  gcc_checking_assert (m_kind == VR_RANGE);\n+  // NANs cannot appear in the endpoints of a range.\n+  gcc_checking_assert (!real_isnan (&m_min) && !real_isnan (&m_max));\n \n-  bool is_nan = real_isnan (&m_min) || real_isnan (&m_max);\n-  if (is_nan)\n-    {\n-      // If either is a NAN, both must be a NAN.\n-      gcc_checking_assert (real_identical (&m_min, &m_max));\n-      gcc_checking_assert (known_nan ());\n-    }\n-  else\n-    // Make sure we don't have swapped ranges.\n-    gcc_checking_assert (!real_less (&m_max, &m_min));\n+  // Make sure we don't have swapped ranges.\n+  gcc_checking_assert (!real_less (&m_max, &m_min));\n \n-  // If we're absolutely sure we have a NAN, the endpoints should\n-  // reflect this, otherwise we'd have more than one way to represent\n-  // a NAN.\n-  if (known_nan ())\n-    {\n-      gcc_checking_assert (real_isnan (&m_min));\n-      gcc_checking_assert (real_isnan (&m_max));\n-    }\n-  else\n-    {\n-      // Make sure the signbit and range agree.\n-      bool signbit;\n-      if (known_signbit (signbit))\n-\t{\n-\t  if (signbit)\n-\t    gcc_checking_assert (real_compare (LE_EXPR, &m_max, &dconst0));\n-\t  else\n-\t    gcc_checking_assert (real_compare (GE_EXPR, &m_min, &dconst0));\n-\t}\n-    }\n+  // [ +0.0, -0.0 ] is nonsensical.\n+  gcc_checking_assert (!(real_iszero (&m_min, 0) && real_iszero (&m_max, 1)));\n \n   // If all the properties are clear, we better not span the entire\n   // domain, because that would make us varying.\n-  if (m_props.varying_p ())\n+  if (m_pos_nan && m_neg_nan)\n     gcc_checking_assert (!real_isinf (&m_min, 1) || !real_isinf (&m_max, 0));\n }\n \n@@ -755,16 +706,24 @@ frange::nonzero_p () const\n   return false;\n }\n \n-// Set range to [+0.0, +0.0].\n+// Set range to [+0.0, +0.0] if honoring signed zeros, or [0.0, 0.0]\n+// otherwise.\n \n void\n frange::set_zero (tree type)\n {\n-  tree zero = build_zero_cst (type);\n-  set (zero, zero);\n+  if (HONOR_SIGNED_ZEROS (type))\n+    {\n+      REAL_VALUE_TYPE dconstm0 = dconst0;\n+      dconstm0.sign = 1;\n+      set (type, dconstm0, dconst0);\n+      clear_nan ();\n+    }\n+  else\n+    set (type, dconst0, dconst0);\n }\n \n-// Return TRUE for any [0.0, 0.0] regardless of sign.\n+// Return TRUE for any zero regardless of sign.\n \n bool\n frange::zero_p () const\n@@ -777,9 +736,7 @@ frange::zero_p () const\n void\n frange::set_nonnegative (tree type)\n {\n-  tree zero = build_zero_cst (type);\n-  tree inf = vrp_val_max (type);\n-  set (zero, inf);\n+  set (type, dconst0, dconstinf);\n }\n \n // Here we copy between any two irange's.  The ranges can be legacy or\n@@ -3637,8 +3594,21 @@ range_tests_nan ()\n       ASSERT_EQ (r0, r1);\n       r0.clear_nan ();\n       ASSERT_NE (r0, r1);\n+      r0.update_nan ();\n+      ASSERT_EQ (r0, r1);\n+\n+      // [10, 20] NAN ^ [30, 40] NAN = NAN.\n+      r0 = frange_float (\"10\", \"20\");\n+      r1 = frange_float (\"30\", \"40\");\n+      r0.intersect (r1);\n+      ASSERT_TRUE (r0.known_isnan ());\n+\n+      // [3,5] U [5,10] NAN = ... NAN\n+      r0 = frange_float (\"3\", \"5\");\n       r0.clear_nan ();\n-      ASSERT_NE (r0, r1);\n+      r1 = frange_float (\"5\", \"10\");\n+      r0.union_ (r1);\n+      ASSERT_TRUE (r0.maybe_isnan ());\n     }\n \n   // NAN ranges are not equal to each other.\n@@ -3657,40 +3627,75 @@ range_tests_nan ()\n   real_from_string (&r, \"6\");\n   ASSERT_TRUE (real_identical (&q, &r0.lower_bound ()));\n   ASSERT_TRUE (real_identical (&r, &r0.upper_bound ()));\n-  ASSERT_TRUE (r0.maybe_nan ());\n+  ASSERT_TRUE (r0.maybe_isnan ());\n \n   // NAN U NAN = NAN\n   r0.set_nan (float_type_node);\n   r1.set_nan (float_type_node);\n   r0.union_ (r1);\n-  ASSERT_TRUE (real_isnan (&r0.lower_bound ()));\n-  ASSERT_TRUE (real_isnan (&r1.upper_bound ()));\n-  ASSERT_TRUE (r0.known_nan ());\n+  ASSERT_TRUE (r0.known_isnan ());\n \n-  // [INF, INF] ^ NAN = VARYING\n+  // [INF, INF] NAN ^ NAN = NAN\n   r0.set_nan (float_type_node);\n   r1 = frange_float (\"+Inf\", \"+Inf\");\n+  if (!HONOR_NANS (float_type_node))\n+    r1.update_nan ();\n   r0.intersect (r1);\n-  ASSERT_TRUE (r0.varying_p ());\n+  ASSERT_TRUE (r0.known_isnan ());\n \n   // NAN ^ NAN = NAN\n   r0.set_nan (float_type_node);\n   r1.set_nan (float_type_node);\n   r0.intersect (r1);\n-  ASSERT_TRUE (r0.known_nan ());\n+  ASSERT_TRUE (r0.known_isnan ());\n+\n+  // +NAN ^ -NAN = UNDEFINED\n+  r0.set_nan (float_type_node, false);\n+  r1.set_nan (float_type_node, true);\n+  r0.intersect (r1);\n+  ASSERT_TRUE (r0.undefined_p ());\n \n   // VARYING ^ NAN = NAN.\n   r0.set_nan (float_type_node);\n   r1.set_varying (float_type_node);\n   r0.intersect (r1);\n-  ASSERT_TRUE (r0.known_nan ());\n+  ASSERT_TRUE (r0.known_isnan ());\n+\n+  // [3,4] ^ NAN = UNDEFINED.\n+  r0 = frange_float (\"3\", \"4\");\n+  r0.clear_nan ();\n+  r1.set_nan (float_type_node);\n+  r0.intersect (r1);\n+  ASSERT_TRUE (r0.undefined_p ());\n+\n+  // [-3, 5] ^ NAN = UNDEFINED\n+  r0 = frange_float (\"-3\", \"5\");\n+  r0.clear_nan ();\n+  r1.set_nan (float_type_node);\n+  r0.intersect (r1);\n+  ASSERT_TRUE (r0.undefined_p ());\n+\n+  // Setting the NAN bit to yes does not make us a known NAN.\n+  r0.set_varying (float_type_node);\n+  r0.update_nan ();\n+  ASSERT_FALSE (r0.known_isnan ());\n \n-  // Setting the NAN bit to yes, forces to range to [NAN, NAN].\n+  // NAN is in a VARYING.\n   r0.set_varying (float_type_node);\n-  r0.update_nan (fp_prop::YES);\n-  ASSERT_TRUE (r0.known_nan ());\n-  ASSERT_TRUE (real_isnan (&r0.lower_bound ()));\n-  ASSERT_TRUE (real_isnan (&r0.upper_bound ()));\n+  real_nan (&r, \"\", 1, TYPE_MODE (float_type_node));\n+  tree nan = build_real (float_type_node, r);\n+  ASSERT_TRUE (r0.contains_p (nan));\n+\n+  // -NAN is in a VARYING.\n+  r0.set_varying (float_type_node);\n+  q = real_value_negate (&r);\n+  tree neg_nan = build_real (float_type_node, q);\n+  ASSERT_TRUE (r0.contains_p (neg_nan));\n+\n+  // Clearing the NAN on a [] NAN is the empty set.\n+  r0.set_nan (float_type_node);\n+  r0.clear_nan ();\n+  ASSERT_TRUE (r0.undefined_p ());\n }\n \n static void\n@@ -3702,49 +3707,84 @@ range_tests_signed_zeros ()\n   frange r0, r1;\n   bool signbit;\n \n-  // Since -0.0 == +0.0, a range of [-0.0, -0.0] should contain +0.0\n-  // and vice versa.\n+  // [0,0] contains [0,0] but not [-0,-0] and vice versa.\n   r0 = frange (zero, zero);\n   r1 = frange (neg_zero, neg_zero);\n   ASSERT_TRUE (r0.contains_p (zero));\n-  ASSERT_TRUE (r0.contains_p (neg_zero));\n-  ASSERT_TRUE (r1.contains_p (zero));\n+  ASSERT_TRUE (!r0.contains_p (neg_zero));\n   ASSERT_TRUE (r1.contains_p (neg_zero));\n+  ASSERT_TRUE (!r1.contains_p (zero));\n \n   // Test contains_p() when we know the sign of the zero.\n-  r0 = frange(zero, zero);\n-  r0.set_signbit (fp_prop::NO);\n+  r0 = frange (zero, zero);\n   ASSERT_TRUE (r0.contains_p (zero));\n   ASSERT_FALSE (r0.contains_p (neg_zero));\n-  r0.set_signbit (fp_prop::YES);\n+  r0 = frange (neg_zero, neg_zero);\n   ASSERT_TRUE (r0.contains_p (neg_zero));\n   ASSERT_FALSE (r0.contains_p (zero));\n \n-  // The intersection of zeros that differ in sign is the empty set.\n-  r0 = frange (zero, zero);\n-  r0.set_signbit (fp_prop::YES);\n+  // The intersection of zeros that differ in sign is a NAN (or\n+  // undefined if not honoring NANs).\n+  r0 = frange (neg_zero, neg_zero);\n   r1 = frange (zero, zero);\n-  r1.set_signbit (fp_prop::NO);\n   r0.intersect (r1);\n-  ASSERT_TRUE (r0.undefined_p ());\n+  if (HONOR_NANS (float_type_node))\n+    ASSERT_TRUE (r0.known_isnan ());\n+  else\n+    ASSERT_TRUE (r0.undefined_p ());\n \n   // The union of zeros that differ in sign is a zero with unknown sign.\n   r0 = frange (zero, zero);\n-  r0.set_signbit (fp_prop::NO);\n-  r1 = frange (zero, zero);\n-  r1.set_signbit (fp_prop::YES);\n+  r1 = frange (neg_zero, neg_zero);\n   r0.union_ (r1);\n-  ASSERT_TRUE (r0.zero_p () && !r0.known_signbit (signbit));\n+  ASSERT_TRUE (r0.zero_p () && !r0.signbit_p (signbit));\n \n-  // NAN U [5,6] should be [5,6] with no sign info.\n+  // [-0, +0] has an unknown sign.\n+  r0 = frange (neg_zero, zero);\n+  ASSERT_TRUE (r0.zero_p () && !r0.signbit_p (signbit));\n+\n+  // [-0, +0] ^ [0, 0] is [0, 0]\n+  r0 = frange (neg_zero, zero);\n+  r1 = frange (zero, zero);\n+  r0.intersect (r1);\n+  ASSERT_TRUE (r0.zero_p ());\n+\n+  // NAN U [5,6] should be [5,6] NAN.\n   r0.set_nan (float_type_node);\n   r1 = frange_float (\"5\", \"6\");\n+  r1.clear_nan ();\n   r0.union_ (r1);\n   real_from_string (&q, \"5\");\n   real_from_string (&r, \"6\");\n   ASSERT_TRUE (real_identical (&q, &r0.lower_bound ()));\n   ASSERT_TRUE (real_identical (&r, &r0.upper_bound ()));\n-  ASSERT_TRUE (!r0.known_signbit (signbit));\n+  ASSERT_TRUE (!r0.signbit_p (signbit));\n+  ASSERT_TRUE (r0.maybe_isnan ());\n+\n+  r0 = frange_float (\"+0\", \"5\");\n+  r0.clear_nan ();\n+  ASSERT_TRUE (r0.signbit_p (signbit) && !signbit);\n+\n+  r0 = frange_float (\"-0\", \"5\");\n+  r0.clear_nan ();\n+  ASSERT_TRUE (!r0.signbit_p (signbit));\n+\n+  r0 = frange_float (\"-0\", \"10\");\n+  r1 = frange_float (\"0\", \"5\");\n+  r0.intersect (r1);\n+  ASSERT_TRUE (real_iszero (&r0.lower_bound (), false));\n+\n+  r0 = frange_float (\"-0\", \"5\");\n+  r1 = frange_float (\"0\", \"5\");\n+  r0.union_ (r1);\n+  ASSERT_TRUE (real_iszero (&r0.lower_bound (), true));\n+\n+  r0 = frange_float (\"-5\", \"-0\");\n+  r0.update_nan ();\n+  r1 = frange_float (\"0\", \"0\");\n+  r1.update_nan ();\n+  r0.intersect (r1);\n+  ASSERT_TRUE (r0.known_isnan ());\n }\n \n static void\n@@ -3753,52 +3793,25 @@ range_tests_signbit ()\n   frange r0, r1;\n   bool signbit;\n \n-  // Setting the signbit drops the range to [-INF, 0].\n-  r0.set_varying (float_type_node);\n-  r0.set_signbit (fp_prop::YES);\n-  ASSERT_TRUE (real_isinf (&r0.lower_bound (), 1));\n-  ASSERT_TRUE (real_iszero (&r0.upper_bound ()));\n-\n-  // Setting the signbit for [-5, 10] crops the range to [-5, 0] with\n-  // the signbit property set.\n-  r0 = frange_float (\"-5\", \"10\");\n-  r0.set_signbit (fp_prop::YES);\n-  r0.clear_nan ();\n-  ASSERT_TRUE (r0.known_signbit (signbit) && signbit);\n-  r1 = frange_float (\"-5\", \"0\");\n-  ASSERT_TRUE (real_identical (&r0.lower_bound (), &r1.lower_bound ()));\n-  ASSERT_TRUE (real_identical (&r0.upper_bound (), &r1.upper_bound ()));\n-\n   // Negative numbers should have the SIGNBIT set.\n   r0 = frange_float (\"-5\", \"-1\");\n   r0.clear_nan ();\n-  ASSERT_TRUE (r0.known_signbit (signbit) && signbit);\n+  ASSERT_TRUE (r0.signbit_p (signbit) && signbit);\n   // Positive numbers should have the SIGNBIT clear.\n   r0 = frange_float (\"1\", \"10\");\n   r0.clear_nan ();\n-  ASSERT_TRUE (r0.known_signbit (signbit) && !signbit);\n+  ASSERT_TRUE (r0.signbit_p (signbit) && !signbit);\n   // Numbers containing zero should have an unknown SIGNBIT.\n   r0 = frange_float (\"0\", \"10\");\n   r0.clear_nan ();\n-  ASSERT_TRUE (!r0.known_signbit (signbit));\n+  ASSERT_TRUE (r0.signbit_p (signbit) && !signbit);\n   // Numbers spanning both positive and negative should have an\n   // unknown SIGNBIT.\n   r0 = frange_float (\"-10\", \"10\");\n   r0.clear_nan ();\n-  ASSERT_TRUE (!r0.known_signbit (signbit));\n+  ASSERT_TRUE (!r0.signbit_p (signbit));\n   r0.set_varying (float_type_node);\n-  ASSERT_TRUE (!r0.known_signbit (signbit));\n-\n-  // Ignore signbit changes when the sign bit is obviously known from\n-  // the range.\n-  r0 = frange_float (\"5\", \"10\");\n-  r0.clear_nan ();\n-  r0.set_signbit (fp_prop::VARYING);\n-  ASSERT_TRUE (r0.known_signbit (signbit) && !signbit);\n-  r0 = frange_float (\"-5\", \"-1\");\n-  r0.set_signbit (fp_prop::NO);\n-  r0.clear_nan ();\n-  ASSERT_TRUE (r0.undefined_p ());\n+  ASSERT_TRUE (!r0.signbit_p (signbit));\n }\n \n static void\n@@ -3815,7 +3828,7 @@ range_tests_floats ()\n   // A range of [-INF,+INF] is actually VARYING if no other properties\n   // are set.\n   r0 = frange_float (\"-Inf\", \"+Inf\");\n-  if (r0.maybe_nan ())\n+  if (r0.maybe_isnan ())\n     ASSERT_TRUE (r0.varying_p ());\n   // ...unless it has some special property...\n   r0.clear_nan ();\n@@ -3896,9 +3909,19 @@ range_tests_floats ()\n   r0.intersect (r1);\n   ASSERT_EQ (r0, frange_float (\"15\", \"20\"));\n \n+  // [10,20] NAN ^ [21,25] NAN = [NAN]\n+  r0 = frange_float (\"10\", \"20\");\n+  r0.update_nan ();\n+  r1 = frange_float (\"21\", \"25\");\n+  r1.update_nan ();\n+  r0.intersect (r1);\n+  ASSERT_TRUE (r0.known_isnan ());\n+\n   // [10,20] ^ [21,25] = []\n   r0 = frange_float (\"10\", \"20\");\n+  r0.clear_nan ();\n   r1 = frange_float (\"21\", \"25\");\n+  r1.clear_nan ();\n   r0.intersect (r1);\n   ASSERT_TRUE (r0.undefined_p ());\n }"}, {"sha": "3a401f3e4e2c5780f019dc4fd21b47a0bb00ba4d", "filename": "gcc/value-range.h", "status": "modified", "additions": 101, "deletions": 130, "changes": 231, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/917461478d3bb733a64bc21876811d017c555b3c/gcc%2Fvalue-range.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/917461478d3bb733a64bc21876811d017c555b3c/gcc%2Fvalue-range.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-range.h?ref=917461478d3bb733a64bc21876811d017c555b3c", "patch": "@@ -35,6 +35,8 @@ enum value_range_kind\n   VR_RANGE,\n   /* Range is ~[MIN, MAX].  */\n   VR_ANTI_RANGE,\n+  /* Range is a NAN.  */\n+  VR_NAN,\n   /* Range is a nice guy.  */\n   VR_LAST\n };\n@@ -263,69 +265,10 @@ class unsupported_range : public vrange\n   virtual void accept (const vrange_visitor &v) const override;\n };\n \n-// Floating point property to represent possible values of a NAN, INF, etc.\n-\n-class fp_prop\n-{\n-public:\n-  enum kind {\n-    UNDEFINED\t= 0x0,\t\t// Prop is impossible.\n-    YES\t\t= 0x1,\t\t// Prop is definitely set.\n-    NO\t\t= 0x2,\t\t// Prop is definitely not set.\n-    VARYING\t= (YES | NO)\t// Prop may hold.\n-  };\n-  fp_prop (kind f) : m_kind (f) { }\n-  bool varying_p () const { return m_kind == VARYING; }\n-  bool undefined_p () const { return m_kind == UNDEFINED; }\n-  bool yes_p () const { return m_kind == YES; }\n-  bool no_p () const { return m_kind == NO; }\n-private:\n-  unsigned char m_kind : 2;\n-};\n-\n-// Accessors for individual FP properties.\n-\n-#define FP_PROP_ACCESSOR(NAME) \\\n-  void NAME##_set_varying () { u.bits.NAME = fp_prop::VARYING; }\t\\\n-  void NAME##_set_yes () { u.bits.NAME = fp_prop::YES; }\t\\\n-  void NAME##_set_no () { u.bits.NAME = fp_prop::NO; }\t\\\n-  bool NAME##_varying_p () const { return u.bits.NAME == fp_prop::VARYING; } \\\n-  bool NAME##_undefined_p () const { return u.bits.NAME == fp_prop::UNDEFINED; } \\\n-  bool NAME##_yes_p () const { return u.bits.NAME == fp_prop::YES; }\t\\\n-  bool NAME##_no_p () const { return u.bits.NAME == fp_prop::NO; } \\\n-  fp_prop get_##NAME () const\t\t\t\t   \\\n-  { return fp_prop ((fp_prop::kind) u.bits.NAME); } \\\n-  void set_##NAME (fp_prop::kind f) { u.bits.NAME = f; }\n-\n-// Aggregate of all the FP properties in an frange packed into one\n-// structure to save space.  Using explicit fp_prop's in the frange,\n-// would take one byte per property because of padding.  Instead, we\n-// can save all properties into one byte.\n-\n-class frange_props\n-{\n-public:\n-  frange_props () { set_varying (); }\n-  void set_varying () { u.bytes = 0xff; }\n-  void set_undefined () { u.bytes = 0; }\n-  bool varying_p () { return u.bytes == 0xff; }\n-  bool undefined_p () { return u.bytes == 0; }\n-  bool union_ (const frange_props &other);\n-  bool intersect (const frange_props &other);\n-  bool operator== (const frange_props &other) const;\n-  FP_PROP_ACCESSOR(nan)\n-  FP_PROP_ACCESSOR(signbit)\n-private:\n-  union {\n-    struct {\n-      unsigned char nan : 2;\n-      unsigned char signbit : 2;\n-    } bits;\n-    unsigned char bytes;\n-  } u;\n-};\n-\n // A floating point range.\n+//\n+// The representation is a type with a couple of endpoints, unioned\n+// with the set of { -NAN, +Nan }.\n \n class frange : public vrange\n {\n@@ -349,6 +292,7 @@ class frange : public vrange\n   void set (tree type, const REAL_VALUE_TYPE &, const REAL_VALUE_TYPE &,\n \t    value_range_kind = VR_RANGE);\n   void set_nan (tree type);\n+  void set_nan (tree type, bool sign);\n   virtual void set_varying (tree type) override;\n   virtual void set_undefined () override;\n   virtual bool union_ (const vrange &) override;\n@@ -367,42 +311,41 @@ class frange : public vrange\n   bool operator!= (const frange &r) const { return !(*this == r); }\n   const REAL_VALUE_TYPE &lower_bound () const;\n   const REAL_VALUE_TYPE &upper_bound () const;\n+  void update_nan ();\n+  void clear_nan ();\n \n   // fpclassify like API\n-  bool known_finite () const;\n-  bool maybe_inf () const;\n-  bool known_inf () const;\n-  bool maybe_nan () const;\n-  bool known_nan () const;\n-  bool known_signbit (bool &signbit) const;\n-\n-  // Accessors for FP properties.\n-  void update_nan (fp_prop::kind f);\n-  void clear_nan () { update_nan (fp_prop::NO); }\n-  void set_signbit (fp_prop::kind);\n+  bool known_isfinite () const;\n+  bool known_isnan () const;\n+  bool known_isinf () const;\n+  bool maybe_isnan () const;\n+  bool maybe_isinf () const;\n+  bool signbit_p (bool &signbit) const;\n private:\n-  fp_prop get_nan () const { return m_props.get_nan (); }\n-  fp_prop get_signbit () const { return m_props.get_signbit (); }\n   void verify_range ();\n   bool normalize_kind ();\n+  bool union_nans (const frange &);\n+  bool intersect_nans (const frange &);\n+  bool combine_zeros (const frange &, bool union_p);\n \n-  frange_props m_props;\n   tree m_type;\n   REAL_VALUE_TYPE m_min;\n   REAL_VALUE_TYPE m_max;\n+  bool m_pos_nan;\n+  bool m_neg_nan;\n };\n \n inline const REAL_VALUE_TYPE &\n frange::lower_bound () const\n {\n-  gcc_checking_assert (!undefined_p ());\n+  gcc_checking_assert (!undefined_p () && !known_isnan ());\n   return m_min;\n }\n \n inline const REAL_VALUE_TYPE &\n frange::upper_bound () const\n {\n-  gcc_checking_assert (!undefined_p ());\n+  gcc_checking_assert (!undefined_p () && !known_isnan ());\n   return m_max;\n }\n \n@@ -1082,30 +1025,6 @@ vrp_val_min (const_tree type)\n   return NULL_TREE;\n }\n \n-// Supporting methods for frange.\n-\n-inline bool\n-frange_props::operator== (const frange_props &other) const\n-{\n-  return u.bytes == other.u.bytes;\n-}\n-\n-inline bool\n-frange_props::union_ (const frange_props &other)\n-{\n-  unsigned char saved = u.bytes;\n-  u.bytes |= other.u.bytes;\n-  return u.bytes != saved;\n-}\n-\n-inline bool\n-frange_props::intersect (const frange_props &other)\n-{\n-  unsigned char saved = u.bytes;\n-  u.bytes &= other.u.bytes;\n-  return u.bytes != saved;\n-}\n-\n inline\n frange::frange ()\n {\n@@ -1154,15 +1073,42 @@ frange::set_varying (tree type)\n   m_type = type;\n   m_min = dconstninf;\n   m_max = dconstinf;\n-  m_props.set_varying ();\n+  m_pos_nan = true;\n+  m_neg_nan = true;\n }\n \n inline void\n frange::set_undefined ()\n {\n   m_kind = VR_UNDEFINED;\n-  m_type = NULL;\n-  m_props.set_undefined ();\n+  if (flag_checking)\n+    verify_range ();\n+}\n+\n+// Set the NAN bit and adjust the range.\n+\n+inline void\n+frange::update_nan ()\n+{\n+  gcc_checking_assert (!undefined_p ());\n+  m_pos_nan = true;\n+  m_neg_nan = true;\n+  normalize_kind ();\n+  if (flag_checking)\n+    verify_range ();\n+}\n+\n+// Clear the NAN bit and adjust the range.\n+\n+inline void\n+frange::clear_nan ()\n+{\n+  gcc_checking_assert (!undefined_p ());\n+  m_pos_nan = false;\n+  m_neg_nan = false;\n+  normalize_kind ();\n+  if (flag_checking)\n+    verify_range ();\n }\n \n // Set R to maximum representable value for TYPE.\n@@ -1186,41 +1132,48 @@ real_min_representable (REAL_VALUE_TYPE *r, tree type)\n   *r = real_value_negate (r);\n }\n \n-// Build a NAN of type TYPE.\n+// Build a signless NAN of type TYPE.\n \n inline void\n frange::set_nan (tree type)\n {\n-  REAL_VALUE_TYPE r;\n-  gcc_assert (real_nan (&r, \"\", 1, TYPE_MODE (type)));\n-  m_kind = VR_RANGE;\n+  m_kind = VR_NAN;\n   m_type = type;\n-  m_min = r;\n-  m_max = r;\n-  m_props.set_varying ();\n-  m_props.nan_set_yes ();\n+  m_pos_nan = true;\n+  m_neg_nan = true;\n+  if (flag_checking)\n+    verify_range ();\n+}\n+\n+// Build a NAN of type TYPE with SIGN.\n+\n+inline void\n+frange::set_nan (tree type, bool sign)\n+{\n+  m_kind = VR_NAN;\n+  m_type = type;\n+  m_neg_nan = sign;\n+  m_pos_nan = !sign;\n   if (flag_checking)\n     verify_range ();\n }\n \n // Return TRUE if range is known to be finite.\n \n inline bool\n-frange::known_finite () const\n+frange::known_isfinite () const\n {\n   if (undefined_p () || varying_p () || m_kind == VR_ANTI_RANGE)\n     return false;\n-  return (!real_isnan (&m_min)\n-\t  && !real_isinf (&m_min)\n-\t  && !real_isinf (&m_max));\n+  return (!maybe_isnan () && !real_isinf (&m_min) && !real_isinf (&m_max));\n }\n \n // Return TRUE if range may be infinite.\n \n inline bool\n-frange::maybe_inf () const\n+frange::maybe_isinf () const\n {\n-  if (undefined_p () || m_kind == VR_ANTI_RANGE)\n+  if (undefined_p () || m_kind == VR_ANTI_RANGE || m_kind == VR_NAN)\n     return false;\n   if (varying_p ())\n     return true;\n@@ -1230,7 +1183,7 @@ frange::maybe_inf () const\n // Return TRUE if range is known to be the [-INF,-INF] or [+INF,+INF].\n \n inline bool\n-frange::known_inf () const\n+frange::known_isinf () const\n {\n   return (m_kind == VR_RANGE\n \t  && real_identical (&m_min, &m_max)\n@@ -1240,32 +1193,50 @@ frange::known_inf () const\n // Return TRUE if range is possibly a NAN.\n \n inline bool\n-frange::maybe_nan () const\n+frange::maybe_isnan () const\n {\n-  return !get_nan ().no_p ();\n+  return m_pos_nan || m_neg_nan;\n }\n \n // Return TRUE if range is a +NAN or -NAN.\n \n inline bool\n-frange::known_nan () const\n+frange::known_isnan () const\n {\n-  return get_nan ().yes_p ();\n+  return m_kind == VR_NAN;\n }\n \n // If the signbit for the range is known, set it in SIGNBIT and return\n // TRUE.\n \n inline bool\n-frange::known_signbit (bool &signbit) const\n+frange::signbit_p (bool &signbit) const\n {\n-  // FIXME: Signed NANs are not supported yet.\n-  if (maybe_nan ())\n+  if (undefined_p ())\n     return false;\n-  if (get_signbit ().varying_p ())\n+\n+  // NAN with unknown sign.\n+  if (m_pos_nan && m_neg_nan)\n     return false;\n-  signbit = get_signbit ().yes_p ();\n-  return true;\n+  // No NAN.\n+  if (!m_pos_nan && !m_neg_nan)\n+    {\n+      if (m_min.sign == m_max.sign)\n+\t{\n+\t  signbit = m_min.sign;\n+\t  return true;\n+\t}\n+      return false;\n+    }\n+  // NAN with known sign.\n+  bool nan_sign = m_neg_nan;\n+  if (known_isnan ()\n+      || (nan_sign == m_min.sign && nan_sign == m_max.sign))\n+    {\n+      signbit = nan_sign;\n+      return true;\n+    }\n+  return false;\n }\n \n #endif // GCC_VALUE_RANGE_H"}]}