{"sha": "bb9f8221b43c3a500198fa3a504fa11f5f807988", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmI5ZjgyMjFiNDNjM2E1MDAxOThmYTNhNTA0ZmExMWY1ZjgwNzk4OA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@vlsi1.ultra.nyu.edu", "date": "2001-09-22T13:14:40Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2001-09-22T13:14:40Z"}, "message": "attribs.c: New file, from c-common.c.\n\n\t* attribs.c: New file, from c-common.c.\n\t(attribute_tables): Now four elements.\n\t(format_attribute_table, lang_attribute_common): New variables.\n\t(init_attributes): Reflect above changes.\n\t(handle_mode_attribute): Delete check for wider than uintmax.\n\t* c-common.c: Delete parts moved to attribs.c.\n\t(enum attrs): Deleted; unused.\n\t(c_format_attribute_table): New variable.\n\t(c_common_lang_init): Initialize format_attribute_table with it.\n\t* c-common.h (decl_attributes): Remove decl.\n\t* tree.h (decl_attribute): Move it to here.\n\t* Makefile.in (C_AND_OBJS_OBJS): Add attribs.o.\n\t(attribs.o): New rule.\n\t* ch/Make-lang.in (cc1chill): Add attribs.o.\n\t* cp/Make-lang.in (CXX_C_OBJS): Add attribs.o.\n\nFrom-SVN: r45749", "tree": {"sha": "00bc4e0b093a48235bf0c46b6102755bcd06cba0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/00bc4e0b093a48235bf0c46b6102755bcd06cba0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bb9f8221b43c3a500198fa3a504fa11f5f807988", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bb9f8221b43c3a500198fa3a504fa11f5f807988", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bb9f8221b43c3a500198fa3a504fa11f5f807988", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bb9f8221b43c3a500198fa3a504fa11f5f807988/comments", "author": null, "committer": null, "parents": [{"sha": "ab6e6969342d2aa3a7e59eb092767e80bd7852a4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab6e6969342d2aa3a7e59eb092767e80bd7852a4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ab6e6969342d2aa3a7e59eb092767e80bd7852a4"}], "stats": {"total": 2394, "additions": 1246, "deletions": 1148}, "files": [{"sha": "f32e149b38a5b6d93620061b3776d20fe1ec2bf5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb9f8221b43c3a500198fa3a504fa11f5f807988/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb9f8221b43c3a500198fa3a504fa11f5f807988/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bb9f8221b43c3a500198fa3a504fa11f5f807988", "patch": "@@ -1,3 +1,19 @@\n+Sat Sep 22 09:09:32 2001  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* attribs.c: New file, from c-common.c.\n+\t(attribute_tables): Now four elements.\n+\t(format_attribute_table, lang_attribute_common): New variables.\n+\t(init_attributes): Reflect above changes.\n+\t(handle_mode_attribute): Delete check for wider than uintmax.\n+\t* c-common.c: Delete parts moved to attribs.c.\n+\t(enum attrs): Deleted; unused.\n+\t(c_format_attribute_table): New variable.\n+\t(c_common_lang_init): Initialize format_attribute_table with it.\n+\t* c-common.h (decl_attributes): Remove decl.\n+\t* tree.h (decl_attribute): Move it to here.\n+\t* Makefile.in (C_AND_OBJS_OBJS): Add attribs.o.\n+\t(attribs.o): New rule.\n+\n 2001-09-22  Andreas Jaeger  <aj@suse.de>\n \n \t* builtins.c (c_getstr): Remove unused variable."}, {"sha": "1413dc267f9a8393d29d5e0a4bd99d8d3072491d", "filename": "gcc/attribs.c", "status": "added", "additions": 1201, "deletions": 0, "changes": 1201, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb9f8221b43c3a500198fa3a504fa11f5f807988/gcc%2Fattribs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb9f8221b43c3a500198fa3a504fa11f5f807988/gcc%2Fattribs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fattribs.c?ref=bb9f8221b43c3a500198fa3a504fa11f5f807988", "patch": "@@ -0,0 +1,1201 @@\n+/* Functions dealing with attribute handling, used by most front ends.\n+   Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001\n+   Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n+02111-1307, USA.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"tree.h\"\n+#include \"flags.h\"\n+#include \"toplev.h\"\n+#include \"output.h\"\n+#include \"rtl.h\"\n+#include \"ggc.h\"\n+#include \"expr.h\"\n+#include \"tm_p.h\"\n+#include \"obstack.h\"\n+#include \"cpplib.h\"\n+#include \"target.h\"\n+\n+static void init_attributes\t\tPARAMS ((void));\n+\n+/* Table of the tables of attributes (common, format, language, machine)\n+   searched.  */\n+static const struct attribute_spec *attribute_tables[4];\n+\n+static bool attributes_initialized = false;\n+\n+static tree handle_packed_attribute\tPARAMS ((tree *, tree, tree, int,\n+\t\t\t\t\t\t bool *));\n+static tree handle_nocommon_attribute\tPARAMS ((tree *, tree, tree, int,\n+\t\t\t\t\t\t bool *));\n+static tree handle_common_attribute\tPARAMS ((tree *, tree, tree, int,\n+\t\t\t\t\t\t bool *));\n+static tree handle_noreturn_attribute\tPARAMS ((tree *, tree, tree, int,\n+\t\t\t\t\t\t bool *));\n+static tree handle_unused_attribute\tPARAMS ((tree *, tree, tree, int,\n+\t\t\t\t\t\t bool *));\n+static tree handle_const_attribute\tPARAMS ((tree *, tree, tree, int,\n+\t\t\t\t\t\t bool *));\n+static tree handle_transparent_union_attribute PARAMS ((tree *, tree, tree,\n+\t\t\t\t\t\t\tint, bool *));\n+static tree handle_constructor_attribute PARAMS ((tree *, tree, tree, int,\n+\t\t\t\t\t\t  bool *));\n+static tree handle_destructor_attribute PARAMS ((tree *, tree, tree, int,\n+\t\t\t\t\t\t bool *));\n+static tree handle_mode_attribute\tPARAMS ((tree *, tree, tree, int,\n+\t\t\t\t\t\t bool *));\n+static tree handle_section_attribute\tPARAMS ((tree *, tree, tree, int,\n+\t\t\t\t\t\t bool *));\n+static tree handle_aligned_attribute\tPARAMS ((tree *, tree, tree, int,\n+\t\t\t\t\t\t bool *));\n+static tree handle_weak_attribute\tPARAMS ((tree *, tree, tree, int,\n+\t\t\t\t\t\t bool *));\n+static tree handle_alias_attribute\tPARAMS ((tree *, tree, tree, int,\n+\t\t\t\t\t\t bool *));\n+static tree handle_no_instrument_function_attribute PARAMS ((tree *, tree,\n+\t\t\t\t\t\t\t     tree, int,\n+\t\t\t\t\t\t\t     bool *));\n+static tree handle_no_check_memory_usage_attribute PARAMS ((tree *, tree, tree,\n+\t\t\t\t\t\t\t    int, bool *));\n+static tree handle_malloc_attribute\tPARAMS ((tree *, tree, tree, int,\n+\t\t\t\t\t\t bool *));\n+static tree handle_no_limit_stack_attribute PARAMS ((tree *, tree, tree, int,\n+\t\t\t\t\t\t     bool *));\n+static tree handle_pure_attribute\tPARAMS ((tree *, tree, tree, int,\n+\t\t\t\t\t\t bool *));\n+\n+/* Table of machine-independent attributes common to all C-like languages.  */\n+static const struct attribute_spec c_common_attribute_table[] =\n+{\n+  /* { name, min_len, max_len, decl_req, type_req, fn_type_req, handler } */\n+  { \"packed\",                 0, 0, false, false, false,\n+      \t\t\t      handle_packed_attribute },\n+  { \"nocommon\",               0, 0, true,  false, false,\n+\t\t\t      handle_nocommon_attribute },\n+  { \"common\",                 0, 0, true,  false, false,\n+\t\t\t      handle_common_attribute },\n+  /* FIXME: logically, noreturn attributes should be listed as\n+     \"false, true, true\" and apply to function types.  But implementing this\n+     would require all the places in the compiler that use TREE_THIS_VOLATILE\n+     on a decl to identify non-returning functions to be located and fixed\n+     to check the function type instead.  */\n+  { \"noreturn\",               0, 0, true,  false, false,\n+\t\t\t      handle_noreturn_attribute },\n+  { \"volatile\",               0, 0, true,  false, false,\n+\t\t\t      handle_noreturn_attribute },\n+  { \"unused\",                 0, 0, false, false, false,\n+\t\t\t      handle_unused_attribute },\n+  /* The same comments as for noreturn attributes apply to const ones.  */\n+  { \"const\",                  0, 0, true,  false, false,\n+\t\t\t      handle_const_attribute },\n+  { \"transparent_union\",      0, 0, false, false, false,\n+\t\t\t      handle_transparent_union_attribute },\n+  { \"constructor\",            0, 0, true,  false, false,\n+\t\t\t      handle_constructor_attribute },\n+  { \"destructor\",             0, 0, true,  false, false,\n+\t\t\t      handle_destructor_attribute },\n+  { \"mode\",                   1, 1, true,  false, false,\n+\t\t\t      handle_mode_attribute },\n+  { \"section\",                1, 1, true,  false, false,\n+\t\t\t      handle_section_attribute },\n+  { \"aligned\",                0, 1, false, false, false,\n+\t\t\t      handle_aligned_attribute },\n+  { \"weak\",                   0, 0, true,  false, false,\n+\t\t\t      handle_weak_attribute },\n+  { \"alias\",                  1, 1, true,  false, false,\n+\t\t\t      handle_alias_attribute },\n+  { \"no_instrument_function\", 0, 0, true,  false, false,\n+\t\t\t      handle_no_instrument_function_attribute },\n+  { \"no_check_memory_usage\",  0, 0, true,  false, false,\n+\t\t\t      handle_no_check_memory_usage_attribute },\n+  { \"malloc\",                 0, 0, true,  false, false,\n+\t\t\t      handle_malloc_attribute },\n+  { \"no_stack_limit\",         0, 0, true,  false, false,\n+\t\t\t      handle_no_limit_stack_attribute },\n+  { \"pure\",                   0, 0, true,  false, false,\n+\t\t\t      handle_pure_attribute },\n+  { NULL,                     0, 0, false, false, false, NULL }\n+};\n+\n+/* Default empty table of attributes.  */\n+static const struct attribute_spec empty_attribute_table[] =\n+{\n+  { NULL, 0, 0, false, false, false, NULL }\n+};\n+\n+/* Table of machine-independent attributes for checking formats, if used.  */\n+const struct attribute_spec *format_attribute_table = empty_attribute_table;\n+\n+/* Table of machine-independent attributes for a particular language.  */\n+const struct attribute_spec *lang_attribute_table = empty_attribute_table;\n+\n+/* Flag saying whether common language attributes are to be supported.  */\n+int lang_attribute_common = 1;\n+\n+/* Initialize attribute tables, and make some sanity checks\n+   if --enable-checking.  */\n+\n+static void\n+init_attributes ()\n+{\n+#ifdef ENABLE_CHECKING\n+  int i;\n+#endif\n+\n+  attribute_tables[0]\n+    = lang_attribute_common ? c_common_attribute_table : empty_attribute_table;\n+  attribute_tables[1] = lang_attribute_table;\n+  attribute_tables[2] = format_attribute_table;\n+  attribute_tables[3] = targetm.attribute_table;\n+\n+#ifdef ENABLE_CHECKING\n+  /* Make some sanity checks on the attribute tables.  */\n+  for (i = 0;\n+       i < (int) (sizeof (attribute_tables) / sizeof (attribute_tables[0]));\n+       i++)\n+    {\n+      int j;\n+\n+      for (j = 0; attribute_tables[i][j].name != NULL; j++)\n+\t{\n+\t  /* The name must not begin and end with __.  */\n+\t  const char *name = attribute_tables[i][j].name;\n+\t  int len = strlen (name);\n+\t  if (name[0] == '_' && name[1] == '_'\n+\t      && name[len - 1] == '_' && name[len - 2] == '_')\n+\t    abort ();\n+\t  /* The minimum and maximum lengths must be consistent.  */\n+\t  if (attribute_tables[i][j].min_length < 0)\n+\t    abort ();\n+\t  if (attribute_tables[i][j].max_length != -1\n+\t      && (attribute_tables[i][j].max_length\n+\t\t  < attribute_tables[i][j].min_length))\n+\t    abort ();\n+\t  /* An attribute cannot require both a DECL and a TYPE.  */\n+\t  if (attribute_tables[i][j].decl_required\n+\t      && attribute_tables[i][j].type_required)\n+\t    abort ();\n+\t  /* If an attribute requires a function type, in particular\n+\t     it requires a type.  */\n+\t  if (attribute_tables[i][j].function_type_required\n+\t      && !attribute_tables[i][j].type_required)\n+\t    abort ();\n+\t}\n+    }\n+\n+  /* Check that each name occurs just once in each table.  */\n+  for (i = 0;\n+       i < (int) (sizeof (attribute_tables) / sizeof (attribute_tables[0]));\n+       i++)\n+    {\n+      int j, k;\n+      for (j = 0; attribute_tables[i][j].name != NULL; j++)\n+\tfor (k = j + 1; attribute_tables[i][k].name != NULL; k++)\n+\t  if (!strcmp (attribute_tables[i][j].name,\n+\t\t       attribute_tables[i][k].name))\n+\t    abort ();\n+    }\n+  /* Check that no name occurs in more than one table.  */\n+  for (i = 0;\n+       i < (int) (sizeof (attribute_tables) / sizeof (attribute_tables[0]));\n+       i++)\n+    {\n+      int j, k, l;\n+\n+      for (j = i + 1;\n+\t   j < ((int) (sizeof (attribute_tables)\n+\t\t       / sizeof (attribute_tables[0])));\n+\t   j++)\n+\tfor (k = 0; attribute_tables[i][k].name != NULL; k++)\n+\t  for (l = 0; attribute_tables[j][l].name != NULL; l++)\n+\t    if (!strcmp (attribute_tables[i][k].name,\n+\t\t\t attribute_tables[j][l].name))\n+\t      abort ();\n+    }\n+#endif\n+\n+  attributes_initialized = true;\n+}\n+\f\n+/* Process the attributes listed in ATTRIBUTES and install them in *NODE,\n+   which is either a DECL (including a TYPE_DECL) or a TYPE.  If a DECL,\n+   it should be modified in place; if a TYPE, a copy should be created\n+   unless ATTR_FLAG_TYPE_IN_PLACE is set in FLAGS.  FLAGS gives further\n+   information, in the form of a bitwise OR of flags in enum attribute_flags\n+   from tree.h.  Depending on these flags, some attributes may be\n+   returned to be applied at a later stage (for example, to apply\n+   a decl attribute to the declaration rather than to its type).  */\n+\n+tree\n+decl_attributes (node, attributes, flags)\n+     tree *node, attributes;\n+     int flags;\n+{\n+  tree a;\n+  tree returned_attrs = NULL_TREE;\n+\n+  if (!attributes_initialized)\n+    init_attributes ();\n+\n+  (*targetm.insert_attributes) (*node, &attributes);\n+\n+  for (a = attributes; a; a = TREE_CHAIN (a))\n+    {\n+      tree name = TREE_PURPOSE (a);\n+      tree args = TREE_VALUE (a);\n+      tree *anode = node;\n+      const struct attribute_spec *spec = NULL;\n+      bool no_add_attrs = 0;\n+      int i;\n+\n+      for (i = 0;\n+\t   i < ((int) (sizeof (attribute_tables)\n+\t\t       / sizeof (attribute_tables[0])));\n+\t   i++)\n+\t{\n+\t  int j;\n+\n+\t  for (j = 0; attribute_tables[i][j].name != NULL; j++)\n+\t    {\n+\t      if (is_attribute_p (attribute_tables[i][j].name, name))\n+\t\t{\n+\t\t  spec = &attribute_tables[i][j];\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t  if (spec != NULL)\n+\t    break;\n+\t}\n+\n+      if (spec == NULL)\n+\t{\n+\t  warning (\"`%s' attribute directive ignored\",\n+\t\t   IDENTIFIER_POINTER (name));\n+\t  continue;\n+\t}\n+      else if (list_length (args) < spec->min_length\n+\t       || (spec->max_length >= 0\n+\t\t   && list_length (args) > spec->max_length))\n+\t{\n+\t  error (\"wrong number of arguments specified for `%s' attribute\",\n+\t\t IDENTIFIER_POINTER (name));\n+\t  continue;\n+\t}\n+\n+      if (spec->decl_required && !DECL_P (*anode))\n+\t{\n+\t  if (flags & ((int) ATTR_FLAG_DECL_NEXT\n+\t\t       | (int) ATTR_FLAG_FUNCTION_NEXT\n+\t\t       | (int) ATTR_FLAG_ARRAY_NEXT))\n+\t    {\n+\t      /* Pass on this attribute to be tried again.  */\n+\t      returned_attrs = tree_cons (name, args, returned_attrs);\n+\t      continue;\n+\t    }\n+\t  else\n+\t    {\n+\t      warning (\"`%s' attribute does not apply to types\",\n+\t\t       IDENTIFIER_POINTER (name));\n+\t      continue;\n+\t    }\n+\t}\n+\n+      if (spec->type_required && DECL_P (*anode))\n+\tanode = &TREE_TYPE (*anode);\n+\n+      if (spec->function_type_required && TREE_CODE (*anode) != FUNCTION_TYPE\n+\t  && TREE_CODE (*anode) != METHOD_TYPE)\n+\t{\n+\t  if (TREE_CODE (*anode) == POINTER_TYPE\n+\t      && (TREE_CODE (TREE_TYPE (*anode)) == FUNCTION_TYPE\n+\t\t  || TREE_CODE (TREE_TYPE (*anode)) == METHOD_TYPE))\n+\t    {\n+\t      if (!(flags & (int) ATTR_FLAG_TYPE_IN_PLACE))\n+\t\t*anode = build_type_copy (*anode);\n+\t      anode = &TREE_TYPE (*anode);\n+\t    }\n+\t  else if (flags & (int) ATTR_FLAG_FUNCTION_NEXT)\n+\t    {\n+\t      /* Pass on this attribute to be tried again.  */\n+\t      returned_attrs = tree_cons (name, args, returned_attrs);\n+\t      continue;\n+\t    }\n+\n+\t  if (TREE_CODE (*anode) != FUNCTION_TYPE\n+\t      && TREE_CODE (*anode) != METHOD_TYPE)\n+\t    {\n+\t      warning (\"`%s' attribute only applies to function types\",\n+\t\t       IDENTIFIER_POINTER (name));\n+\t      continue;\n+\t    }\n+\t}\n+\n+      if (spec->handler != NULL)\n+\treturned_attrs = chainon ((*spec->handler) (anode, name, args,\n+\t\t\t\t\t\t    flags, &no_add_attrs),\n+\t\t\t\t  returned_attrs);\n+      if (!no_add_attrs)\n+\t{\n+\t  tree old_attrs;\n+\t  tree a;\n+\n+\t  if (DECL_P (*anode))\n+\t    old_attrs = DECL_ATTRIBUTES (*anode);\n+\t  else\n+\t    old_attrs = TYPE_ATTRIBUTES (*anode);\n+\n+\t  for (a = lookup_attribute (spec->name, old_attrs);\n+\t       a != NULL_TREE;\n+\t       a = lookup_attribute (spec->name, TREE_CHAIN (a)))\n+\t    {\n+\t      if (simple_cst_equal (TREE_VALUE (a), args) == 1)\n+\t\tbreak;\n+\t    }\n+\n+\t  if (a == NULL_TREE)\n+\t    {\n+\t      /* This attribute isn't already in the list.  */\n+\t      if (DECL_P (*anode))\n+\t\tDECL_ATTRIBUTES (*anode) = tree_cons (name, args, old_attrs);\n+\t      else if (flags & (int) ATTR_FLAG_TYPE_IN_PLACE)\n+\t\tTYPE_ATTRIBUTES (*anode) = tree_cons (name, args, old_attrs);\n+\t      else\n+\t\t*anode = build_type_attribute_variant (*anode,\n+\t\t\t\t\t\t       tree_cons (name, args,\n+\t\t\t\t\t\t\t\t  old_attrs));\n+\t    }\n+\t}\n+    }\n+\n+  return returned_attrs;\n+}\n+\n+/* Handle a \"packed\" attribute; arguments as in\n+   struct attribute_spec.handler.  */\n+\n+static tree\n+handle_packed_attribute (node, name, args, flags, no_add_attrs)\n+     tree *node;\n+     tree name;\n+     tree args ATTRIBUTE_UNUSED;\n+     int flags;\n+     bool *no_add_attrs;\n+{\n+  tree *type = NULL;\n+  if (DECL_P (*node))\n+    {\n+      if (TREE_CODE (*node) == TYPE_DECL)\n+\ttype = &TREE_TYPE (*node);\n+    }\n+  else\n+    type = node;\n+\n+  if (type)\n+    {\n+      if (!(flags & (int) ATTR_FLAG_TYPE_IN_PLACE))\n+\t*type = build_type_copy (*type);\n+      TYPE_PACKED (*type) = 1;\n+    }\n+  else if (TREE_CODE (*node) == FIELD_DECL)\n+    DECL_PACKED (*node) = 1;\n+  /* We can't set DECL_PACKED for a VAR_DECL, because the bit is\n+     used for DECL_REGISTER.  It wouldn't mean anything anyway.  */\n+  else\n+    {\n+      warning (\"`%s' attribute ignored\", IDENTIFIER_POINTER (name));\n+      *no_add_attrs = true;\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n+/* Handle a \"nocommon\" attribute; arguments as in\n+   struct attribute_spec.handler.  */\n+\n+static tree\n+handle_nocommon_attribute (node, name, args, flags, no_add_attrs)\n+     tree *node;\n+     tree name;\n+     tree args ATTRIBUTE_UNUSED;\n+     int flags ATTRIBUTE_UNUSED;\n+     bool *no_add_attrs;\n+{\n+  if (TREE_CODE (*node) == VAR_DECL)\n+    DECL_COMMON (*node) = 0;\n+  else\n+    {\n+      warning (\"`%s' attribute ignored\", IDENTIFIER_POINTER (name));\n+      *no_add_attrs = true;\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n+/* Handle a \"common\" attribute; arguments as in\n+   struct attribute_spec.handler.  */\n+\n+static tree\n+handle_common_attribute (node, name, args, flags, no_add_attrs)\n+     tree *node;\n+     tree name;\n+     tree args ATTRIBUTE_UNUSED;\n+     int flags ATTRIBUTE_UNUSED;\n+     bool *no_add_attrs;\n+{\n+  if (TREE_CODE (*node) == VAR_DECL)\n+    DECL_COMMON (*node) = 1;\n+  else\n+    {\n+      warning (\"`%s' attribute ignored\", IDENTIFIER_POINTER (name));\n+      *no_add_attrs = true;\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n+/* Handle a \"noreturn\" attribute; arguments as in\n+   struct attribute_spec.handler.  */\n+\n+static tree\n+handle_noreturn_attribute (node, name, args, flags, no_add_attrs)\n+     tree *node;\n+     tree name;\n+     tree args ATTRIBUTE_UNUSED;\n+     int flags ATTRIBUTE_UNUSED;\n+     bool *no_add_attrs;\n+{\n+  tree type = TREE_TYPE (*node);\n+\n+  /* See FIXME comment in c_common_attribute_table.  */\n+  if (TREE_CODE (*node) == FUNCTION_DECL)\n+    TREE_THIS_VOLATILE (*node) = 1;\n+  else if (TREE_CODE (type) == POINTER_TYPE\n+\t   && TREE_CODE (TREE_TYPE (type)) == FUNCTION_TYPE)\n+    TREE_TYPE (*node)\n+      = build_pointer_type\n+\t(build_type_variant (TREE_TYPE (type),\n+\t\t\t     TREE_READONLY (TREE_TYPE (type)), 1));\n+  else\n+    {\n+      warning (\"`%s' attribute ignored\", IDENTIFIER_POINTER (name));\n+      *no_add_attrs = true;\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n+/* Handle a \"unused\" attribute; arguments as in\n+   struct attribute_spec.handler.  */\n+\n+static tree\n+handle_unused_attribute (node, name, args, flags, no_add_attrs)\n+     tree *node;\n+     tree name;\n+     tree args ATTRIBUTE_UNUSED;\n+     int flags;\n+     bool *no_add_attrs;\n+{\n+  if (DECL_P (*node))\n+    {\n+      tree decl = *node;\n+\n+      if (TREE_CODE (decl) == PARM_DECL\n+\t  || TREE_CODE (decl) == VAR_DECL\n+\t  || TREE_CODE (decl) == FUNCTION_DECL\n+\t  || TREE_CODE (decl) == LABEL_DECL\n+\t  || TREE_CODE (decl) == TYPE_DECL)\n+\tTREE_USED (decl) = 1;\n+      else\n+\t{\n+\t  warning (\"`%s' attribute ignored\", IDENTIFIER_POINTER (name));\n+\t  *no_add_attrs = true;\n+\t}\n+    }\n+  else\n+    {\n+      if (!(flags & (int) ATTR_FLAG_TYPE_IN_PLACE))\n+\t*node = build_type_copy (*node);\n+      TREE_USED (*node) = 1;\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n+/* Handle a \"const\" attribute; arguments as in\n+   struct attribute_spec.handler.  */\n+\n+static tree\n+handle_const_attribute (node, name, args, flags, no_add_attrs)\n+     tree *node;\n+     tree name;\n+     tree args ATTRIBUTE_UNUSED;\n+     int flags ATTRIBUTE_UNUSED;\n+     bool *no_add_attrs;\n+{\n+  tree type = TREE_TYPE (*node);\n+\n+  /* See FIXME comment on noreturn in c_common_attribute_table.  */\n+  if (TREE_CODE (*node) == FUNCTION_DECL)\n+    TREE_READONLY (*node) = 1;\n+  else if (TREE_CODE (type) == POINTER_TYPE\n+\t   && TREE_CODE (TREE_TYPE (type)) == FUNCTION_TYPE)\n+    TREE_TYPE (*node)\n+      = build_pointer_type\n+\t(build_type_variant (TREE_TYPE (type), 1,\n+\t\t\t     TREE_THIS_VOLATILE (TREE_TYPE (type))));\n+  else\n+    {\n+      warning (\"`%s' attribute ignored\", IDENTIFIER_POINTER (name));\n+      *no_add_attrs = true;\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n+/* Handle a \"transparent_union\" attribute; arguments as in\n+   struct attribute_spec.handler.  */\n+\n+static tree\n+handle_transparent_union_attribute (node, name, args, flags, no_add_attrs)\n+     tree *node;\n+     tree name;\n+     tree args ATTRIBUTE_UNUSED;\n+     int flags;\n+     bool *no_add_attrs;\n+{\n+  tree decl = NULL_TREE;\n+  tree *type = NULL;\n+  int is_type = 0;\n+\n+  if (DECL_P (*node))\n+    {\n+      decl = *node;\n+      type = &TREE_TYPE (decl);\n+      is_type = TREE_CODE (*node) == TYPE_DECL;\n+    }\n+  else if (TYPE_P (*node))\n+    type = node, is_type = 1;\n+\n+  if (is_type\n+      && TREE_CODE (*type) == UNION_TYPE\n+      && (decl == 0\n+\t  || (TYPE_FIELDS (*type) != 0\n+\t      && TYPE_MODE (*type) == DECL_MODE (TYPE_FIELDS (*type)))))\n+    {\n+      if (!(flags & (int) ATTR_FLAG_TYPE_IN_PLACE))\n+\t*type = build_type_copy (*type);\n+      TYPE_TRANSPARENT_UNION (*type) = 1;\n+    }\n+  else if (decl != 0 && TREE_CODE (decl) == PARM_DECL\n+\t   && TREE_CODE (*type) == UNION_TYPE\n+\t   && TYPE_MODE (*type) == DECL_MODE (TYPE_FIELDS (*type)))\n+    DECL_TRANSPARENT_UNION (decl) = 1;\n+  else\n+    {\n+      warning (\"`%s' attribute ignored\", IDENTIFIER_POINTER (name));\n+      *no_add_attrs = true;\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n+/* Handle a \"constructor\" attribute; arguments as in\n+   struct attribute_spec.handler.  */\n+\n+static tree\n+handle_constructor_attribute (node, name, args, flags, no_add_attrs)\n+     tree *node;\n+     tree name;\n+     tree args ATTRIBUTE_UNUSED;\n+     int flags ATTRIBUTE_UNUSED;\n+     bool *no_add_attrs;\n+{\n+  tree decl = *node;\n+  tree type = TREE_TYPE (decl);\n+\n+  if (TREE_CODE (decl) == FUNCTION_DECL\n+      && TREE_CODE (type) == FUNCTION_TYPE\n+      && decl_function_context (decl) == 0)\n+    {\n+      DECL_STATIC_CONSTRUCTOR (decl) = 1;\n+      TREE_USED (decl) = 1;\n+    }\n+  else\n+    {\n+      warning (\"`%s' attribute ignored\", IDENTIFIER_POINTER (name));\n+      *no_add_attrs = true;\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n+/* Handle a \"destructor\" attribute; arguments as in\n+   struct attribute_spec.handler.  */\n+\n+static tree\n+handle_destructor_attribute (node, name, args, flags, no_add_attrs)\n+     tree *node;\n+     tree name;\n+     tree args ATTRIBUTE_UNUSED;\n+     int flags ATTRIBUTE_UNUSED;\n+     bool *no_add_attrs;\n+{\n+  tree decl = *node;\n+  tree type = TREE_TYPE (decl);\n+\n+  if (TREE_CODE (decl) == FUNCTION_DECL\n+      && TREE_CODE (type) == FUNCTION_TYPE\n+      && decl_function_context (decl) == 0)\n+    {\n+      DECL_STATIC_DESTRUCTOR (decl) = 1;\n+      TREE_USED (decl) = 1;\n+    }\n+  else\n+    {\n+      warning (\"`%s' attribute ignored\", IDENTIFIER_POINTER (name));\n+      *no_add_attrs = true;\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n+/* Handle a \"mode\" attribute; arguments as in\n+   struct attribute_spec.handler.  */\n+\n+static tree\n+handle_mode_attribute (node, name, args, flags, no_add_attrs)\n+     tree *node;\n+     tree name;\n+     tree args;\n+     int flags ATTRIBUTE_UNUSED;\n+     bool *no_add_attrs;\n+{\n+  tree decl = *node;\n+  tree type = TREE_TYPE (decl);\n+\n+  *no_add_attrs = true;\n+\n+  if (TREE_CODE (TREE_VALUE (args)) != IDENTIFIER_NODE)\n+    warning (\"`%s' attribute ignored\", IDENTIFIER_POINTER (name));\n+  else\n+    {\n+      int j;\n+      const char *p = IDENTIFIER_POINTER (TREE_VALUE (args));\n+      int len = strlen (p);\n+      enum machine_mode mode = VOIDmode;\n+      tree typefm;\n+\n+      if (len > 4 && p[0] == '_' && p[1] == '_'\n+\t  && p[len - 1] == '_' && p[len - 2] == '_')\n+\t{\n+\t  char *newp = (char *) alloca (len - 1);\n+\n+\t  strcpy (newp, &p[2]);\n+\t  newp[len - 4] = '\\0';\n+\t  p = newp;\n+\t}\n+\n+      /* Give this decl a type with the specified mode.\n+\t First check for the special modes.  */\n+      if (! strcmp (p, \"byte\"))\n+\tmode = byte_mode;\n+      else if (!strcmp (p, \"word\"))\n+\tmode = word_mode;\n+      else if (! strcmp (p, \"pointer\"))\n+\tmode = ptr_mode;\n+      else\n+\tfor (j = 0; j < NUM_MACHINE_MODES; j++)\n+\t  if (!strcmp (p, GET_MODE_NAME (j)))\n+\t    mode = (enum machine_mode) j;\n+\n+      if (mode == VOIDmode)\n+\terror (\"unknown machine mode `%s'\", p);\n+      else if (0 == (typefm = type_for_mode (mode,\n+\t\t\t\t\t     TREE_UNSIGNED (type))))\n+\terror (\"no data type for mode `%s'\", p);\n+      else\n+\t{\n+\t  TREE_TYPE (decl) = type = typefm;\n+\t  DECL_SIZE (decl) = DECL_SIZE_UNIT (decl) = 0;\n+\t  if (TREE_CODE (decl) != FIELD_DECL)\n+\t    layout_decl (decl, 0);\n+\t}\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n+/* Handle a \"section\" attribute; arguments as in\n+   struct attribute_spec.handler.  */\n+\n+static tree\n+handle_section_attribute (node, name, args, flags, no_add_attrs)\n+     tree *node;\n+     tree name ATTRIBUTE_UNUSED;\n+     tree args;\n+     int flags ATTRIBUTE_UNUSED;\n+     bool *no_add_attrs;\n+{\n+  tree decl = *node;\n+\n+  if (targetm.have_named_sections)\n+    {\n+      if ((TREE_CODE (decl) == FUNCTION_DECL\n+\t   || TREE_CODE (decl) == VAR_DECL)\n+\t  && TREE_CODE (TREE_VALUE (args)) == STRING_CST)\n+\t{\n+\t  if (TREE_CODE (decl) == VAR_DECL\n+\t      && current_function_decl != NULL_TREE\n+\t      && ! TREE_STATIC (decl))\n+\t    {\n+\t      error_with_decl (decl,\n+\t\t\t       \"section attribute cannot be specified for local variables\");\n+\t      *no_add_attrs = true;\n+\t    }\n+\n+\t  /* The decl may have already been given a section attribute\n+\t     from a previous declaration.  Ensure they match.  */\n+\t  else if (DECL_SECTION_NAME (decl) != NULL_TREE\n+\t\t   && strcmp (TREE_STRING_POINTER (DECL_SECTION_NAME (decl)),\n+\t\t\t      TREE_STRING_POINTER (TREE_VALUE (args))) != 0)\n+\t    {\n+\t      error_with_decl (*node,\n+\t\t\t       \"section of `%s' conflicts with previous declaration\");\n+\t      *no_add_attrs = true;\n+\t    }\n+\t  else\n+\t    DECL_SECTION_NAME (decl) = TREE_VALUE (args);\n+\t}\n+      else\n+\t{\n+\t  error_with_decl (*node,\n+\t\t\t   \"section attribute not allowed for `%s'\");\n+\t  *no_add_attrs = true;\n+\t}\n+    }\n+  else\n+    {\n+      error_with_decl (*node,\n+\t\t       \"section attributes are not supported for this target\");\n+      *no_add_attrs = true;\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n+/* Handle a \"aligned\" attribute; arguments as in\n+   struct attribute_spec.handler.  */\n+\n+static tree\n+handle_aligned_attribute (node, name, args, flags, no_add_attrs)\n+     tree *node;\n+     tree name ATTRIBUTE_UNUSED;\n+     tree args;\n+     int flags;\n+     bool *no_add_attrs;\n+{\n+  tree decl = NULL_TREE;\n+  tree *type = NULL;\n+  int is_type = 0;\n+  tree align_expr = (args ? TREE_VALUE (args)\n+\t\t     : size_int (BIGGEST_ALIGNMENT / BITS_PER_UNIT));\n+  int i;\n+\n+  if (DECL_P (*node))\n+    {\n+      decl = *node;\n+      type = &TREE_TYPE (decl);\n+      is_type = TREE_CODE (*node) == TYPE_DECL;\n+    }\n+  else if (TYPE_P (*node))\n+    type = node, is_type = 1;\n+\n+  /* Strip any NOPs of any kind.  */\n+  while (TREE_CODE (align_expr) == NOP_EXPR\n+\t || TREE_CODE (align_expr) == CONVERT_EXPR\n+\t || TREE_CODE (align_expr) == NON_LVALUE_EXPR)\n+    align_expr = TREE_OPERAND (align_expr, 0);\n+\n+  if (TREE_CODE (align_expr) != INTEGER_CST)\n+    {\n+      error (\"requested alignment is not a constant\");\n+      *no_add_attrs = true;\n+    }\n+  else if ((i = tree_log2 (align_expr)) == -1)\n+    {\n+      error (\"requested alignment is not a power of 2\");\n+      *no_add_attrs = true;\n+    }\n+  else if (i > HOST_BITS_PER_INT - 2)\n+    {\n+      error (\"requested alignment is too large\");\n+      *no_add_attrs = true;\n+    }\n+  else if (is_type)\n+    {\n+      /* If we have a TYPE_DECL, then copy the type, so that we\n+\t don't accidentally modify a builtin type.  See pushdecl.  */\n+      if (decl && TREE_TYPE (decl) != error_mark_node\n+\t  && DECL_ORIGINAL_TYPE (decl) == NULL_TREE)\n+\t{\n+\t  tree tt = TREE_TYPE (decl);\n+\t  *type = build_type_copy (*type);\n+\t  DECL_ORIGINAL_TYPE (decl) = tt;\n+\t  TYPE_NAME (*type) = decl;\n+\t  TREE_USED (*type) = TREE_USED (decl);\n+\t  TREE_TYPE (decl) = *type;\n+\t}\n+      else if (!(flags & (int) ATTR_FLAG_TYPE_IN_PLACE))\n+\t*type = build_type_copy (*type);\n+\n+      TYPE_ALIGN (*type) = (1 << i) * BITS_PER_UNIT;\n+      TYPE_USER_ALIGN (*type) = 1;\n+    }\n+  else if (TREE_CODE (decl) != VAR_DECL\n+\t   && TREE_CODE (decl) != FIELD_DECL)\n+    {\n+      error_with_decl (decl,\n+\t\t       \"alignment may not be specified for `%s'\");\n+      *no_add_attrs = true;\n+    }\n+  else\n+    {\n+      DECL_ALIGN (decl) = (1 << i) * BITS_PER_UNIT;\n+      DECL_USER_ALIGN (decl) = 1;\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n+/* Handle a \"weak\" attribute; arguments as in\n+   struct attribute_spec.handler.  */\n+\n+static tree\n+handle_weak_attribute (node, name, args, flags, no_add_attrs)\n+     tree *node;\n+     tree name ATTRIBUTE_UNUSED;\n+     tree args ATTRIBUTE_UNUSED;\n+     int flags ATTRIBUTE_UNUSED;\n+     bool *no_add_attrs ATTRIBUTE_UNUSED;\n+{\n+  declare_weak (*node);\n+\n+  return NULL_TREE;\n+}\n+\n+/* Handle an \"alias\" attribute; arguments as in\n+   struct attribute_spec.handler.  */\n+\n+static tree\n+handle_alias_attribute (node, name, args, flags, no_add_attrs)\n+     tree *node;\n+     tree name;\n+     tree args;\n+     int flags ATTRIBUTE_UNUSED;\n+     bool *no_add_attrs;\n+{\n+  tree decl = *node;\n+\n+  if ((TREE_CODE (decl) == FUNCTION_DECL && DECL_INITIAL (decl))\n+      || (TREE_CODE (decl) != FUNCTION_DECL && ! DECL_EXTERNAL (decl)))\n+    {\n+      error_with_decl (decl,\n+\t\t       \"`%s' defined both normally and as an alias\");\n+      *no_add_attrs = true;\n+    }\n+  else if (decl_function_context (decl) == 0)\n+    {\n+      tree id;\n+\n+      id = TREE_VALUE (args);\n+      if (TREE_CODE (id) != STRING_CST)\n+\t{\n+\t  error (\"alias arg not a string\");\n+\t  *no_add_attrs = true;\n+\t  return NULL_TREE;\n+\t}\n+      id = get_identifier (TREE_STRING_POINTER (id));\n+      /* This counts as a use of the object pointed to.  */\n+      TREE_USED (id) = 1;\n+\n+      if (TREE_CODE (decl) == FUNCTION_DECL)\n+\tDECL_INITIAL (decl) = error_mark_node;\n+      else\n+\tDECL_EXTERNAL (decl) = 0;\n+      assemble_alias (decl, id);\n+    }\n+  else\n+    {\n+      warning (\"`%s' attribute ignored\", IDENTIFIER_POINTER (name));\n+      *no_add_attrs = true;\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n+/* Handle a \"no_instrument_function\" attribute; arguments as in\n+   struct attribute_spec.handler.  */\n+\n+static tree\n+handle_no_instrument_function_attribute (node, name, args, flags, no_add_attrs)\n+     tree *node;\n+     tree name;\n+     tree args ATTRIBUTE_UNUSED;\n+     int flags ATTRIBUTE_UNUSED;\n+     bool *no_add_attrs;\n+{\n+  tree decl = *node;\n+\n+  if (TREE_CODE (decl) != FUNCTION_DECL)\n+    {\n+      error_with_decl (decl,\n+\t\t       \"`%s' attribute applies only to functions\",\n+\t\t       IDENTIFIER_POINTER (name));\n+      *no_add_attrs = true;\n+    }\n+  else if (DECL_INITIAL (decl))\n+    {\n+      error_with_decl (decl,\n+\t\t       \"can't set `%s' attribute after definition\",\n+\t\t       IDENTIFIER_POINTER (name));\n+      *no_add_attrs = true;\n+    }\n+  else\n+    DECL_NO_INSTRUMENT_FUNCTION_ENTRY_EXIT (decl) = 1;\n+\n+  return NULL_TREE;\n+}\n+\n+/* Handle a \"no_check_memory_usage\" attribute; arguments as in\n+   struct attribute_spec.handler.  */\n+\n+static tree\n+handle_no_check_memory_usage_attribute (node, name, args, flags, no_add_attrs)\n+     tree *node;\n+     tree name;\n+     tree args ATTRIBUTE_UNUSED;\n+     int flags ATTRIBUTE_UNUSED;\n+     bool *no_add_attrs;\n+{\n+  tree decl = *node;\n+\n+  if (TREE_CODE (decl) != FUNCTION_DECL)\n+    {\n+      error_with_decl (decl,\n+\t\t       \"`%s' attribute applies only to functions\",\n+\t\t       IDENTIFIER_POINTER (name));\n+      *no_add_attrs = true;\n+    }\n+  else if (DECL_INITIAL (decl))\n+    {\n+      error_with_decl (decl,\n+\t\t       \"can't set `%s' attribute after definition\",\n+\t\t       IDENTIFIER_POINTER (name));\n+      *no_add_attrs = true;\n+    }\n+  else\n+    DECL_NO_CHECK_MEMORY_USAGE (decl) = 1;\n+\n+  return NULL_TREE;\n+}\n+\n+/* Handle a \"malloc\" attribute; arguments as in\n+   struct attribute_spec.handler.  */\n+\n+static tree\n+handle_malloc_attribute (node, name, args, flags, no_add_attrs)\n+     tree *node;\n+     tree name;\n+     tree args ATTRIBUTE_UNUSED;\n+     int flags ATTRIBUTE_UNUSED;\n+     bool *no_add_attrs;\n+{\n+  if (TREE_CODE (*node) == FUNCTION_DECL)\n+    DECL_IS_MALLOC (*node) = 1;\n+  /* ??? TODO: Support types.  */\n+  else\n+    {\n+      warning (\"`%s' attribute ignored\", IDENTIFIER_POINTER (name));\n+      *no_add_attrs = true;\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n+/* Handle a \"no_limit_stack\" attribute; arguments as in\n+   struct attribute_spec.handler.  */\n+\n+static tree\n+handle_no_limit_stack_attribute (node, name, args, flags, no_add_attrs)\n+     tree *node;\n+     tree name;\n+     tree args ATTRIBUTE_UNUSED;\n+     int flags ATTRIBUTE_UNUSED;\n+     bool *no_add_attrs;\n+{\n+  tree decl = *node;\n+\n+  if (TREE_CODE (decl) != FUNCTION_DECL)\n+    {\n+      error_with_decl (decl,\n+\t\t       \"`%s' attribute applies only to functions\",\n+\t\t       IDENTIFIER_POINTER (name));\n+      *no_add_attrs = true;\n+    }\n+  else if (DECL_INITIAL (decl))\n+    {\n+      error_with_decl (decl,\n+\t\t       \"can't set `%s' attribute after definition\",\n+\t\t       IDENTIFIER_POINTER (name));\n+      *no_add_attrs = true;\n+    }\n+  else\n+    DECL_NO_LIMIT_STACK (decl) = 1;\n+\n+  return NULL_TREE;\n+}\n+\n+/* Handle a \"pure\" attribute; arguments as in\n+   struct attribute_spec.handler.  */\n+\n+static tree\n+handle_pure_attribute (node, name, args, flags, no_add_attrs)\n+     tree *node;\n+     tree name;\n+     tree args ATTRIBUTE_UNUSED;\n+     int flags ATTRIBUTE_UNUSED;\n+     bool *no_add_attrs;\n+{\n+  if (TREE_CODE (*node) == FUNCTION_DECL)\n+    DECL_IS_PURE (*node) = 1;\n+  /* ??? TODO: Support types.  */\n+  else\n+    {\n+      warning (\"`%s' attribute ignored\", IDENTIFIER_POINTER (name));\n+      *no_add_attrs = true;\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n+/* Split SPECS_ATTRS, a list of declspecs and prefix attributes, into two\n+   lists.  SPECS_ATTRS may also be just a typespec (eg: RECORD_TYPE).\n+\n+   The head of the declspec list is stored in DECLSPECS.\n+   The head of the attribute list is stored in PREFIX_ATTRIBUTES.\n+\n+   Note that attributes in SPECS_ATTRS are stored in the TREE_PURPOSE of\n+   the list elements.  We drop the containing TREE_LIST nodes and link the\n+   resulting attributes together the way decl_attributes expects them.  */\n+\n+void\n+split_specs_attrs (specs_attrs, declspecs, prefix_attributes)\n+     tree specs_attrs;\n+     tree *declspecs, *prefix_attributes;\n+{\n+  tree t, s, a, next, specs, attrs;\n+\n+  /* This can happen after an __extension__ in pedantic mode.  */\n+  if (specs_attrs != NULL_TREE \n+      && TREE_CODE (specs_attrs) == INTEGER_CST)\n+    {\n+      *declspecs = NULL_TREE;\n+      *prefix_attributes = NULL_TREE;\n+      return;\n+    }\n+\n+  /* This can happen in c++ (eg: decl: typespec initdecls ';').  */\n+  if (specs_attrs != NULL_TREE\n+      && TREE_CODE (specs_attrs) != TREE_LIST)\n+    {\n+      *declspecs = specs_attrs;\n+      *prefix_attributes = NULL_TREE;\n+      return;\n+    }\n+\n+  /* Remember to keep the lists in the same order, element-wise.  */\n+\n+  specs = s = NULL_TREE;\n+  attrs = a = NULL_TREE;\n+  for (t = specs_attrs; t; t = next)\n+    {\n+      next = TREE_CHAIN (t);\n+      /* Declspecs have a non-NULL TREE_VALUE.  */\n+      if (TREE_VALUE (t) != NULL_TREE)\n+\t{\n+\t  if (specs == NULL_TREE)\n+\t    specs = s = t;\n+\t  else\n+\t    {\n+\t      TREE_CHAIN (s) = t;\n+\t      s = t;\n+\t    }\n+\t}\n+      /* The TREE_PURPOSE may also be empty in the case of\n+\t __attribute__(()).  */\n+      else if (TREE_PURPOSE (t) != NULL_TREE)\n+\t{\n+\t  if (attrs == NULL_TREE)\n+\t    attrs = a = TREE_PURPOSE (t);\n+\t  else\n+\t    {\n+\t      TREE_CHAIN (a) = TREE_PURPOSE (t);\n+\t      a = TREE_PURPOSE (t);\n+\t    }\n+\t  /* More attrs can be linked here, move A to the end.  */\n+\t  while (TREE_CHAIN (a) != NULL_TREE)\n+\t    a = TREE_CHAIN (a);\n+\t}\n+    }\n+\n+  /* Terminate the lists.  */\n+  if (s != NULL_TREE)\n+    TREE_CHAIN (s) = NULL_TREE;\n+  if (a != NULL_TREE)\n+    TREE_CHAIN (a) = NULL_TREE;\n+\n+  /* All done.  */\n+  *declspecs = specs;\n+  *prefix_attributes = attrs;\n+}\n+\n+/* Strip attributes from SPECS_ATTRS, a list of declspecs and attributes.\n+   This function is used by the parser when a rule will accept attributes\n+   in a particular position, but we don't want to support that just yet.\n+\n+   A warning is issued for every ignored attribute.  */\n+\n+tree\n+strip_attrs (specs_attrs)\n+     tree specs_attrs;\n+{\n+  tree specs, attrs;\n+\n+  split_specs_attrs (specs_attrs, &specs, &attrs);\n+\n+  while (attrs)\n+    {\n+      warning (\"`%s' attribute ignored\",\n+\t       IDENTIFIER_POINTER (TREE_PURPOSE (attrs)));\n+      attrs = TREE_CHAIN (attrs);\n+    }\n+\n+  return specs;\n+}"}, {"sha": "fd1aef1f3cce54febec9b1f0cacd3e795aead5aa", "filename": "gcc/c-common.c", "status": "modified", "additions": 15, "deletions": 1145, "changes": 1160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb9f8221b43c3a500198fa3a504fa11f5f807988/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb9f8221b43c3a500198fa3a504fa11f5f807988/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=bb9f8221b43c3a500198fa3a504fa11f5f807988", "patch": "@@ -216,12 +216,6 @@ void (*back_end_hook) PARAMS ((tree));\n    This is a count, since unevaluated expressions can nest.  */\n int skip_evaluation;\n \n-enum attrs {A_PACKED, A_NOCOMMON, A_COMMON, A_NORETURN, A_CONST, A_T_UNION,\n-\t    A_NO_CHECK_MEMORY_USAGE, A_NO_INSTRUMENT_FUNCTION,\n-\t    A_CONSTRUCTOR, A_DESTRUCTOR, A_MODE, A_SECTION, A_ALIGNED,\n-\t    A_UNUSED, A_FORMAT, A_FORMAT_ARG, A_WEAK, A_ALIAS, A_MALLOC,\n-\t    A_NO_LIMIT_STACK, A_PURE};\n-\n /* Information about how a function name is generated.  */\n struct fname_var_t\n {\n@@ -243,7 +237,6 @@ const struct fname_var_t fname_vars[] =\n   {NULL, 0, 0},\n };\n \n-static void init_attributes\t\tPARAMS ((void));\n static int constant_fits_type_p\t\tPARAMS ((tree, tree));\n \n /* Keep a stack of if statements.  We record the number of compound\n@@ -637,1144 +630,6 @@ combine_strings (strings)\n   return value;\n }\n \f\n-/* Table of the tables of attributes (common, language, machine) searched.  */\n-static const struct attribute_spec *attribute_tables[3];\n-\n-static bool attributes_initialized = false;\n-\n-static tree handle_packed_attribute PARAMS ((tree *, tree, tree, int, bool *));\n-static tree handle_nocommon_attribute PARAMS ((tree *, tree, tree, int, bool *));\n-static tree handle_common_attribute PARAMS ((tree *, tree, tree, int, bool *));\n-static tree handle_noreturn_attribute PARAMS ((tree *, tree, tree, int, bool *));\n-static tree handle_unused_attribute PARAMS ((tree *, tree, tree, int, bool *));\n-static tree handle_const_attribute PARAMS ((tree *, tree, tree, int, bool *));\n-static tree handle_transparent_union_attribute PARAMS ((tree *, tree, tree, int, bool *));\n-static tree handle_constructor_attribute PARAMS ((tree *, tree, tree, int, bool *));\n-static tree handle_destructor_attribute PARAMS ((tree *, tree, tree, int, bool *));\n-static tree handle_mode_attribute PARAMS ((tree *, tree, tree, int, bool *));\n-static tree handle_section_attribute PARAMS ((tree *, tree, tree, int, bool *));\n-static tree handle_aligned_attribute PARAMS ((tree *, tree, tree, int, bool *));\n-static tree handle_weak_attribute PARAMS ((tree *, tree, tree, int, bool *));\n-static tree handle_alias_attribute PARAMS ((tree *, tree, tree, int, bool *));\n-static tree handle_no_instrument_function_attribute PARAMS ((tree *, tree, tree, int, bool *));\n-static tree handle_no_check_memory_usage_attribute PARAMS ((tree *, tree, tree, int, bool *));\n-static tree handle_malloc_attribute PARAMS ((tree *, tree, tree, int, bool *));\n-static tree handle_no_limit_stack_attribute PARAMS ((tree *, tree, tree, int, bool *));\n-static tree handle_pure_attribute PARAMS ((tree *, tree, tree, int, bool *));\n-\n-/* Table of machine-independent attributes common to all C-like languages.  */\n-static const struct attribute_spec c_common_attribute_table[] =\n-{\n-  /* { name, min_len, max_len, decl_req, type_req, fn_type_req, handler } */\n-  { \"packed\",                 0, 0, false, false, false,\n-      \t\t\t      handle_packed_attribute },\n-  { \"nocommon\",               0, 0, true,  false, false,\n-\t\t\t      handle_nocommon_attribute },\n-  { \"common\",                 0, 0, true,  false, false,\n-\t\t\t      handle_common_attribute },\n-  /* FIXME: logically, noreturn attributes should be listed as\n-     \"false, true, true\" and apply to function types.  But implementing this\n-     would require all the places in the compiler that use TREE_THIS_VOLATILE\n-     on a decl to identify non-returning functions to be located and fixed\n-     to check the function type instead.  */\n-  { \"noreturn\",               0, 0, true,  false, false,\n-\t\t\t      handle_noreturn_attribute },\n-  { \"volatile\",               0, 0, true,  false, false,\n-\t\t\t      handle_noreturn_attribute },\n-  { \"unused\",                 0, 0, false, false, false,\n-\t\t\t      handle_unused_attribute },\n-  /* The same comments as for noreturn attributes apply to const ones.  */\n-  { \"const\",                  0, 0, true,  false, false,\n-\t\t\t      handle_const_attribute },\n-  { \"transparent_union\",      0, 0, false, false, false,\n-\t\t\t      handle_transparent_union_attribute },\n-  { \"constructor\",            0, 0, true,  false, false,\n-\t\t\t      handle_constructor_attribute },\n-  { \"destructor\",             0, 0, true,  false, false,\n-\t\t\t      handle_destructor_attribute },\n-  { \"mode\",                   1, 1, true,  false, false,\n-\t\t\t      handle_mode_attribute },\n-  { \"section\",                1, 1, true,  false, false,\n-\t\t\t      handle_section_attribute },\n-  { \"aligned\",                0, 1, false, false, false,\n-\t\t\t      handle_aligned_attribute },\n-  { \"format\",                 3, 3, true,  false, false,\n-\t\t\t      handle_format_attribute },\n-  { \"format_arg\",             1, 1, true,  false, false,\n-\t\t\t      handle_format_arg_attribute },\n-  { \"weak\",                   0, 0, true,  false, false,\n-\t\t\t      handle_weak_attribute },\n-  { \"alias\",                  1, 1, true,  false, false,\n-\t\t\t      handle_alias_attribute },\n-  { \"no_instrument_function\", 0, 0, true,  false, false,\n-\t\t\t      handle_no_instrument_function_attribute },\n-  { \"no_check_memory_usage\",  0, 0, true,  false, false,\n-\t\t\t      handle_no_check_memory_usage_attribute },\n-  { \"malloc\",                 0, 0, true,  false, false,\n-\t\t\t      handle_malloc_attribute },\n-  { \"no_stack_limit\",         0, 0, true,  false, false,\n-\t\t\t      handle_no_limit_stack_attribute },\n-  { \"pure\",                   0, 0, true,  false, false,\n-\t\t\t      handle_pure_attribute },\n-  { NULL,                     0, 0, false, false, false, NULL }\n-};\n-\n-/* Default empty table of language attributes.  */\n-static const struct attribute_spec default_lang_attribute_table[] =\n-{\n-  { NULL, 0, 0, false, false, false, NULL }\n-};\n-\n-/* Table of machine-independent attributes for a particular language.  */\n-const struct attribute_spec *lang_attribute_table\n-  = default_lang_attribute_table;\n-\n-/* Initialize attribute tables, and make some sanity checks\n-   if --enable-checking.  */\n-\n-static void\n-init_attributes ()\n-{\n-#ifdef ENABLE_CHECKING\n-  int i;\n-#endif\n-  attribute_tables[0] = c_common_attribute_table;\n-  attribute_tables[1] = lang_attribute_table;\n-  attribute_tables[2] = targetm.attribute_table;\n-#ifdef ENABLE_CHECKING\n-  /* Make some sanity checks on the attribute tables.  */\n-  for (i = 0;\n-       i < (int) (sizeof (attribute_tables) / sizeof (attribute_tables[0]));\n-       i++)\n-    {\n-      int j;\n-      for (j = 0; attribute_tables[i][j].name != NULL; j++)\n-\t{\n-\t  /* The name must not begin and end with __.  */\n-\t  const char *name = attribute_tables[i][j].name;\n-\t  int len = strlen (name);\n-\t  if (name[0] == '_' && name[1] == '_'\n-\t      && name[len - 1] == '_' && name[len - 2] == '_')\n-\t    abort ();\n-\t  /* The minimum and maximum lengths must be consistent.  */\n-\t  if (attribute_tables[i][j].min_length < 0)\n-\t    abort ();\n-\t  if (attribute_tables[i][j].max_length != -1\n-\t      && attribute_tables[i][j].max_length < attribute_tables[i][j].min_length)\n-\t    abort ();\n-\t  /* An attribute cannot require both a DECL and a TYPE.  */\n-\t  if (attribute_tables[i][j].decl_required\n-\t      && attribute_tables[i][j].type_required)\n-\t    abort ();\n-\t  /* If an attribute requires a function type, in particular\n-\t     it requires a type.  */\n-\t  if (attribute_tables[i][j].function_type_required\n-\t      && !attribute_tables[i][j].type_required)\n-\t    abort ();\n-\t}\n-    }\n-  /* Check that each name occurs just once in each table.  */\n-  for (i = 0;\n-       i < (int) (sizeof (attribute_tables) / sizeof (attribute_tables[0]));\n-       i++)\n-    {\n-      int j, k;\n-      for (j = 0; attribute_tables[i][j].name != NULL; j++)\n-\tfor (k = j + 1; attribute_tables[i][k].name != NULL; k++)\n-\t  if (!strcmp (attribute_tables[i][j].name,\n-\t\t       attribute_tables[i][k].name))\n-\t    abort ();\n-    }\n-  /* Check that no name occurs in more than one table.  */\n-  for (i = 0;\n-       i < (int) (sizeof (attribute_tables) / sizeof (attribute_tables[0]));\n-       i++)\n-    {\n-      int j;\n-      for (j = i + 1;\n-\t   j < (int) (sizeof (attribute_tables) / sizeof (attribute_tables[0]));\n-\t   j++)\n-\t{\n-\t  int k, l;\n-\t  for (k = 0; attribute_tables[i][k].name != NULL; k++)\n-\t    for (l = 0; attribute_tables[j][l].name != NULL; l++)\n-\t      if (!strcmp (attribute_tables[i][k].name,\n-\t\t\t   attribute_tables[j][l].name))\n-\t\tabort ();\n-\t}\n-    }\n-#endif\n-  attributes_initialized = true;\n-}\n-\f\n-/* Process the attributes listed in ATTRIBUTES and install them in *NODE,\n-   which is either a DECL (including a TYPE_DECL) or a TYPE.  If a DECL,\n-   it should be modified in place; if a TYPE, a copy should be created\n-   unless ATTR_FLAG_TYPE_IN_PLACE is set in FLAGS.  FLAGS gives further\n-   information, in the form of a bitwise OR of flags in enum attribute_flags\n-   from tree.h.  Depending on these flags, some attributes may be\n-   returned to be applied at a later stage (for example, to apply\n-   a decl attribute to the declaration rather than to its type).  */\n-\n-tree\n-decl_attributes (node, attributes, flags)\n-     tree *node, attributes;\n-     int flags;\n-{\n-  tree a;\n-  tree returned_attrs = NULL_TREE;\n-\n-  if (!attributes_initialized)\n-    init_attributes ();\n-\n-  (*targetm.insert_attributes) (*node, &attributes);\n-\n-  for (a = attributes; a; a = TREE_CHAIN (a))\n-    {\n-      tree name = TREE_PURPOSE (a);\n-      tree args = TREE_VALUE (a);\n-      tree *anode = node;\n-      const struct attribute_spec *spec = NULL;\n-      bool no_add_attrs = 0;\n-      int i;\n-\n-      for (i = 0;\n-\t   i < (int) (sizeof (attribute_tables) / sizeof (attribute_tables[0]));\n-\t   i++)\n-\t{\n-\t  int j;\n-\t  for (j = 0; attribute_tables[i][j].name != NULL; j++)\n-\t    {\n-\t      if (is_attribute_p (attribute_tables[i][j].name, name))\n-\t\t{\n-\t\t  spec = &attribute_tables[i][j];\n-\t\t  break;\n-\t\t}\n-\t    }\n-\t  if (spec != NULL)\n-\t    break;\n-\t}\n-\n-      if (spec == NULL)\n-\t{\n-\t  warning (\"`%s' attribute directive ignored\",\n-\t\t   IDENTIFIER_POINTER (name));\n-\t  continue;\n-\t}\n-      else if (list_length (args) < spec->min_length\n-\t       || (spec->max_length >= 0\n-\t\t   && list_length (args) > spec->max_length))\n-\t{\n-\t  error (\"wrong number of arguments specified for `%s' attribute\",\n-\t\t IDENTIFIER_POINTER (name));\n-\t  continue;\n-\t}\n-\n-      if (spec->decl_required && !DECL_P (*anode))\n-\t{\n-\t  if (flags & ((int) ATTR_FLAG_DECL_NEXT\n-\t\t       | (int) ATTR_FLAG_FUNCTION_NEXT\n-\t\t       | (int) ATTR_FLAG_ARRAY_NEXT))\n-\t    {\n-\t      /* Pass on this attribute to be tried again.  */\n-\t      returned_attrs = tree_cons (name, args, returned_attrs);\n-\t      continue;\n-\t    }\n-\t  else\n-\t    {\n-\t      warning (\"`%s' attribute does not apply to types\",\n-\t\t       IDENTIFIER_POINTER (name));\n-\t      continue;\n-\t    }\n-\t}\n-\n-      if (spec->type_required && DECL_P (*anode))\n-\t{\n-\t  anode = &TREE_TYPE (*anode);\n-\t}\n-\n-      if (spec->function_type_required && TREE_CODE (*anode) != FUNCTION_TYPE\n-\t  && TREE_CODE (*anode) != METHOD_TYPE)\n-\t{\n-\t  if (TREE_CODE (*anode) == POINTER_TYPE\n-\t      && (TREE_CODE (TREE_TYPE (*anode)) == FUNCTION_TYPE\n-\t\t  || TREE_CODE (TREE_TYPE (*anode)) == METHOD_TYPE))\n-\t    {\n-\t      if (!(flags & (int) ATTR_FLAG_TYPE_IN_PLACE))\n-\t\t*anode = build_type_copy (*anode);\n-\t      anode = &TREE_TYPE (*anode);\n-\t    }\n-\t  else if (flags & (int) ATTR_FLAG_FUNCTION_NEXT)\n-\t    {\n-\t      /* Pass on this attribute to be tried again.  */\n-\t      returned_attrs = tree_cons (name, args, returned_attrs);\n-\t      continue;\n-\t    }\n-\n-\t  if (TREE_CODE (*anode) != FUNCTION_TYPE\n-\t      && TREE_CODE (*anode) != METHOD_TYPE)\n-\t    {\n-\t      warning (\"`%s' attribute only applies to function types\",\n-\t\t       IDENTIFIER_POINTER (name));\n-\t      continue;\n-\t    }\n-\t}\n-\n-      if (spec->handler != NULL)\n-\treturned_attrs = chainon ((*spec->handler) (anode, name, args,\n-\t\t\t\t\t\t    flags, &no_add_attrs),\n-\t\t\t\t  returned_attrs);\n-      if (!no_add_attrs)\n-\t{\n-\t  tree old_attrs;\n-\t  tree a;\n-\n-\t  if (DECL_P (*anode))\n-\t    old_attrs = DECL_ATTRIBUTES (*anode);\n-\t  else\n-\t    old_attrs = TYPE_ATTRIBUTES (*anode);\n-\n-\t  for (a = lookup_attribute (spec->name, old_attrs);\n-\t       a != NULL_TREE;\n-\t       a = lookup_attribute (spec->name, TREE_CHAIN (a)))\n-\t    {\n-\t      if (simple_cst_equal (TREE_VALUE (a), args) == 1)\n-\t\tbreak;\n-\t    }\n-\n-\t  if (a == NULL_TREE)\n-\t    {\n-\t      /* This attribute isn't already in the list.  */\n-\t      if (DECL_P (*anode))\n-\t\tDECL_ATTRIBUTES (*anode) = tree_cons (name, args, old_attrs);\n-\t      else if (flags & (int) ATTR_FLAG_TYPE_IN_PLACE)\n-\t\tTYPE_ATTRIBUTES (*anode) = tree_cons (name, args, old_attrs);\n-\t      else\n-\t\t*anode = build_type_attribute_variant (*anode,\n-\t\t\t\t\t\t       tree_cons (name, args,\n-\t\t\t\t\t\t\t\t  old_attrs));\n-\t    }\n-\t}\n-    }\n-\n-  return returned_attrs;\n-}\n-\n-/* Handle a \"packed\" attribute; arguments as in\n-   struct attribute_spec.handler.  */\n-\n-static tree\n-handle_packed_attribute (node, name, args, flags, no_add_attrs)\n-     tree *node;\n-     tree name;\n-     tree args ATTRIBUTE_UNUSED;\n-     int flags;\n-     bool *no_add_attrs;\n-{\n-  tree *type = NULL;\n-  if (DECL_P (*node))\n-    {\n-      if (TREE_CODE (*node) == TYPE_DECL)\n-\ttype = &TREE_TYPE (*node);\n-    }\n-  else\n-    type = node;\n-  if (type)\n-    {\n-      if (!(flags & (int) ATTR_FLAG_TYPE_IN_PLACE))\n-\t*type = build_type_copy (*type);\n-      TYPE_PACKED (*type) = 1;\n-    }\n-  else if (TREE_CODE (*node) == FIELD_DECL)\n-    DECL_PACKED (*node) = 1;\n-  /* We can't set DECL_PACKED for a VAR_DECL, because the bit is\n-     used for DECL_REGISTER.  It wouldn't mean anything anyway.  */\n-  else\n-    {\n-      warning (\"`%s' attribute ignored\", IDENTIFIER_POINTER (name));\n-      *no_add_attrs = true;\n-    }\n-\n-  return NULL_TREE;\n-}\n-\n-/* Handle a \"nocommon\" attribute; arguments as in\n-   struct attribute_spec.handler.  */\n-\n-static tree\n-handle_nocommon_attribute (node, name, args, flags, no_add_attrs)\n-     tree *node;\n-     tree name;\n-     tree args ATTRIBUTE_UNUSED;\n-     int flags ATTRIBUTE_UNUSED;\n-     bool *no_add_attrs;\n-{\n-  if (TREE_CODE (*node) == VAR_DECL)\n-    DECL_COMMON (*node) = 0;\n-  else\n-    {\n-      warning (\"`%s' attribute ignored\", IDENTIFIER_POINTER (name));\n-      *no_add_attrs = true;\n-    }\n-\n-  return NULL_TREE;\n-}\n-\n-/* Handle a \"common\" attribute; arguments as in\n-   struct attribute_spec.handler.  */\n-\n-static tree\n-handle_common_attribute (node, name, args, flags, no_add_attrs)\n-     tree *node;\n-     tree name;\n-     tree args ATTRIBUTE_UNUSED;\n-     int flags ATTRIBUTE_UNUSED;\n-     bool *no_add_attrs;\n-{\n-  if (TREE_CODE (*node) == VAR_DECL)\n-    DECL_COMMON (*node) = 1;\n-  else\n-    {\n-      warning (\"`%s' attribute ignored\", IDENTIFIER_POINTER (name));\n-      *no_add_attrs = true;\n-    }\n-\n-  return NULL_TREE;\n-}\n-\n-/* Handle a \"noreturn\" attribute; arguments as in\n-   struct attribute_spec.handler.  */\n-\n-static tree\n-handle_noreturn_attribute (node, name, args, flags, no_add_attrs)\n-     tree *node;\n-     tree name;\n-     tree args ATTRIBUTE_UNUSED;\n-     int flags ATTRIBUTE_UNUSED;\n-     bool *no_add_attrs;\n-{\n-  tree type = TREE_TYPE (*node);\n-\n-  /* See FIXME comment in c_common_attribute_table.  */\n-  if (TREE_CODE (*node) == FUNCTION_DECL)\n-    TREE_THIS_VOLATILE (*node) = 1;\n-  else if (TREE_CODE (type) == POINTER_TYPE\n-\t   && TREE_CODE (TREE_TYPE (type)) == FUNCTION_TYPE)\n-    TREE_TYPE (*node)\n-      = build_pointer_type (build_type_variant (TREE_TYPE (type),\n-\t\t\t\t\t\tTREE_READONLY (TREE_TYPE (type)), 1));\n-  else\n-    {\n-      warning (\"`%s' attribute ignored\", IDENTIFIER_POINTER (name));\n-      *no_add_attrs = true;\n-    }\n-\n-  return NULL_TREE;\n-}\n-\n-/* Handle a \"unused\" attribute; arguments as in\n-   struct attribute_spec.handler.  */\n-\n-static tree\n-handle_unused_attribute (node, name, args, flags, no_add_attrs)\n-     tree *node;\n-     tree name;\n-     tree args ATTRIBUTE_UNUSED;\n-     int flags;\n-     bool *no_add_attrs;\n-{\n-  if (DECL_P (*node))\n-    {\n-      tree decl = *node;\n-\n-      if (TREE_CODE (decl) == PARM_DECL\n-\t  || TREE_CODE (decl) == VAR_DECL\n-\t  || TREE_CODE (decl) == FUNCTION_DECL\n-\t  || TREE_CODE (decl) == LABEL_DECL\n-\t  || TREE_CODE (decl) == TYPE_DECL)\n-\tTREE_USED (decl) = 1;\n-      else\n-\t{\n-\t  warning (\"`%s' attribute ignored\", IDENTIFIER_POINTER (name));\n-\t  *no_add_attrs = true;\n-\t}\n-    }\n-  else\n-    {\n-      if (!(flags & (int) ATTR_FLAG_TYPE_IN_PLACE))\n-\t*node = build_type_copy (*node);\n-      TREE_USED (*node) = 1;\n-    }\n-\n-  return NULL_TREE;\n-}\n-\n-/* Handle a \"const\" attribute; arguments as in\n-   struct attribute_spec.handler.  */\n-\n-static tree\n-handle_const_attribute (node, name, args, flags, no_add_attrs)\n-     tree *node;\n-     tree name;\n-     tree args ATTRIBUTE_UNUSED;\n-     int flags ATTRIBUTE_UNUSED;\n-     bool *no_add_attrs;\n-{\n-  tree type = TREE_TYPE (*node);\n-\n-  /* See FIXME comment on noreturn in c_common_attribute_table.  */\n-  if (TREE_CODE (*node) == FUNCTION_DECL)\n-    TREE_READONLY (*node) = 1;\n-  else if (TREE_CODE (type) == POINTER_TYPE\n-\t   && TREE_CODE (TREE_TYPE (type)) == FUNCTION_TYPE)\n-    TREE_TYPE (*node)\n-      = build_pointer_type (build_type_variant (TREE_TYPE (type), 1,\n-\t\t\t\t\t\tTREE_THIS_VOLATILE (TREE_TYPE (type))));\n-  else\n-    {\n-      warning (\"`%s' attribute ignored\", IDENTIFIER_POINTER (name));\n-      *no_add_attrs = true;\n-    }\n-\n-  return NULL_TREE;\n-}\n-\n-/* Handle a \"transparent_union\" attribute; arguments as in\n-   struct attribute_spec.handler.  */\n-\n-static tree\n-handle_transparent_union_attribute (node, name, args, flags, no_add_attrs)\n-     tree *node;\n-     tree name;\n-     tree args ATTRIBUTE_UNUSED;\n-     int flags;\n-     bool *no_add_attrs;\n-{\n-  tree decl = NULL_TREE;\n-  tree *type = NULL;\n-  int is_type = 0;\n-\n-  if (DECL_P (*node))\n-    {\n-      decl = *node;\n-      type = &TREE_TYPE (decl);\n-      is_type = TREE_CODE (*node) == TYPE_DECL;\n-    }\n-  else if (TYPE_P (*node))\n-    type = node, is_type = 1;\n-\n-  if (is_type\n-      && TREE_CODE (*type) == UNION_TYPE\n-      && (decl == 0\n-\t  || (TYPE_FIELDS (*type) != 0\n-\t      && TYPE_MODE (*type) == DECL_MODE (TYPE_FIELDS (*type)))))\n-    {\n-      if (!(flags & (int) ATTR_FLAG_TYPE_IN_PLACE))\n-\t*type = build_type_copy (*type);\n-      TYPE_TRANSPARENT_UNION (*type) = 1;\n-    }\n-  else if (decl != 0 && TREE_CODE (decl) == PARM_DECL\n-\t   && TREE_CODE (*type) == UNION_TYPE\n-\t   && TYPE_MODE (*type) == DECL_MODE (TYPE_FIELDS (*type)))\n-    DECL_TRANSPARENT_UNION (decl) = 1;\n-  else\n-    {\n-      warning (\"`%s' attribute ignored\", IDENTIFIER_POINTER (name));\n-      *no_add_attrs = true;\n-    }\n-\n-  return NULL_TREE;\n-}\n-\n-/* Handle a \"constructor\" attribute; arguments as in\n-   struct attribute_spec.handler.  */\n-\n-static tree\n-handle_constructor_attribute (node, name, args, flags, no_add_attrs)\n-     tree *node;\n-     tree name;\n-     tree args ATTRIBUTE_UNUSED;\n-     int flags ATTRIBUTE_UNUSED;\n-     bool *no_add_attrs;\n-{\n-  tree decl = *node;\n-  tree type = TREE_TYPE (decl);\n-\n-  if (TREE_CODE (decl) == FUNCTION_DECL\n-      && TREE_CODE (type) == FUNCTION_TYPE\n-      && decl_function_context (decl) == 0)\n-    {\n-      DECL_STATIC_CONSTRUCTOR (decl) = 1;\n-      TREE_USED (decl) = 1;\n-    }\n-  else\n-    {\n-      warning (\"`%s' attribute ignored\", IDENTIFIER_POINTER (name));\n-      *no_add_attrs = true;\n-    }\n-\n-  return NULL_TREE;\n-}\n-\n-/* Handle a \"destructor\" attribute; arguments as in\n-   struct attribute_spec.handler.  */\n-\n-static tree\n-handle_destructor_attribute (node, name, args, flags, no_add_attrs)\n-     tree *node;\n-     tree name;\n-     tree args ATTRIBUTE_UNUSED;\n-     int flags ATTRIBUTE_UNUSED;\n-     bool *no_add_attrs;\n-{\n-  tree decl = *node;\n-  tree type = TREE_TYPE (decl);\n-\n-  if (TREE_CODE (decl) == FUNCTION_DECL\n-      && TREE_CODE (type) == FUNCTION_TYPE\n-      && decl_function_context (decl) == 0)\n-    {\n-      DECL_STATIC_DESTRUCTOR (decl) = 1;\n-      TREE_USED (decl) = 1;\n-    }\n-  else\n-    {\n-      warning (\"`%s' attribute ignored\", IDENTIFIER_POINTER (name));\n-      *no_add_attrs = true;\n-    }\n-\n-  return NULL_TREE;\n-}\n-\n-/* Handle a \"mode\" attribute; arguments as in\n-   struct attribute_spec.handler.  */\n-\n-static tree\n-handle_mode_attribute (node, name, args, flags, no_add_attrs)\n-     tree *node;\n-     tree name;\n-     tree args;\n-     int flags ATTRIBUTE_UNUSED;\n-     bool *no_add_attrs;\n-{\n-  tree decl = *node;\n-  tree type = TREE_TYPE (decl);\n-\n-  *no_add_attrs = true;\n-\n-  if (TREE_CODE (TREE_VALUE (args)) != IDENTIFIER_NODE)\n-    warning (\"`%s' attribute ignored\", IDENTIFIER_POINTER (name));\n-  else\n-    {\n-      int j;\n-      const char *p = IDENTIFIER_POINTER (TREE_VALUE (args));\n-      int len = strlen (p);\n-      enum machine_mode mode = VOIDmode;\n-      tree typefm;\n-\n-      if (len > 4 && p[0] == '_' && p[1] == '_'\n-\t  && p[len - 1] == '_' && p[len - 2] == '_')\n-\t{\n-\t  char *newp = (char *) alloca (len - 1);\n-\n-\t  strcpy (newp, &p[2]);\n-\t  newp[len - 4] = '\\0';\n-\t  p = newp;\n-\t}\n-\n-      /* Give this decl a type with the specified mode.\n-\t First check for the special modes.  */\n-      if (! strcmp (p, \"byte\"))\n-\tmode = byte_mode;\n-      else if (!strcmp (p, \"word\"))\n-\tmode = word_mode;\n-      else if (! strcmp (p, \"pointer\"))\n-\tmode = ptr_mode;\n-      else\n-\tfor (j = 0; j < NUM_MACHINE_MODES; j++)\n-\t  if (!strcmp (p, GET_MODE_NAME (j)))\n-\t    mode = (enum machine_mode) j;\n-\n-      if (mode == VOIDmode)\n-\terror (\"unknown machine mode `%s'\", p);\n-      else if (0 == (typefm = type_for_mode (mode,\n-\t\t\t\t\t     TREE_UNSIGNED (type))))\n-\terror (\"no data type for mode `%s'\", p);\n-      else\n-\t{\n-\t  if (TYPE_PRECISION (typefm) > (TREE_UNSIGNED (type)\n-\t\t\t\t\t ? TYPE_PRECISION(uintmax_type_node)\n-\t\t\t\t\t : TYPE_PRECISION(intmax_type_node))\n-\t      && pedantic)\n-\t    pedwarn (\"type with more precision than %s\",\n-\t\t     TREE_UNSIGNED (type) ? \"uintmax_t\" : \"intmax_t\");\n-\t  TREE_TYPE (decl) = type = typefm;\n-\t  DECL_SIZE (decl) = DECL_SIZE_UNIT (decl) = 0;\n-\t  if (TREE_CODE (decl) != FIELD_DECL)\n-\t    layout_decl (decl, 0);\n-\t}\n-    }\n-\n-  return NULL_TREE;\n-}\n-\n-/* Handle a \"section\" attribute; arguments as in\n-   struct attribute_spec.handler.  */\n-\n-static tree\n-handle_section_attribute (node, name, args, flags, no_add_attrs)\n-     tree *node;\n-     tree name ATTRIBUTE_UNUSED;\n-     tree args;\n-     int flags ATTRIBUTE_UNUSED;\n-     bool *no_add_attrs;\n-{\n-  tree decl = *node;\n-\n-  if (targetm.have_named_sections)\n-    {\n-      if ((TREE_CODE (decl) == FUNCTION_DECL\n-\t   || TREE_CODE (decl) == VAR_DECL)\n-\t  && TREE_CODE (TREE_VALUE (args)) == STRING_CST)\n-\t{\n-\t  if (TREE_CODE (decl) == VAR_DECL\n-\t      && current_function_decl != NULL_TREE\n-\t      && ! TREE_STATIC (decl))\n-\t    {\n-\t      error_with_decl (decl,\n-\t\t\t       \"section attribute cannot be specified for local variables\");\n-\t      *no_add_attrs = true;\n-\t    }\n-\t  /* The decl may have already been given a section attribute\n-\t     from a previous declaration.  Ensure they match.  */\n-\t  else if (DECL_SECTION_NAME (decl) != NULL_TREE\n-\t\t   && strcmp (TREE_STRING_POINTER (DECL_SECTION_NAME (decl)),\n-\t\t\t      TREE_STRING_POINTER (TREE_VALUE (args))) != 0)\n-\t    {\n-\t      error_with_decl (*node,\n-\t\t\t       \"section of `%s' conflicts with previous declaration\");\n-\t      *no_add_attrs = true;\n-\t    }\n-\t  else\n-\t    DECL_SECTION_NAME (decl) = TREE_VALUE (args);\n-\t}\n-      else\n-\t{\n-\t  error_with_decl (*node,\n-\t\t\t   \"section attribute not allowed for `%s'\");\n-\t  *no_add_attrs = true;\n-\t}\n-    }\n-  else\n-    {\n-      error_with_decl (*node,\n-\t\t       \"section attributes are not supported for this target\");\n-      *no_add_attrs = true;\n-    }\n-\n-  return NULL_TREE;\n-}\n-\n-/* Handle a \"aligned\" attribute; arguments as in\n-   struct attribute_spec.handler.  */\n-\n-static tree\n-handle_aligned_attribute (node, name, args, flags, no_add_attrs)\n-     tree *node;\n-     tree name ATTRIBUTE_UNUSED;\n-     tree args;\n-     int flags;\n-     bool *no_add_attrs;\n-{\n-  tree decl = NULL_TREE;\n-  tree *type = NULL;\n-  int is_type = 0;\n-  tree align_expr = (args ? TREE_VALUE (args)\n-\t\t     : size_int (BIGGEST_ALIGNMENT / BITS_PER_UNIT));\n-  int i;\n-\n-  if (DECL_P (*node))\n-    {\n-      decl = *node;\n-      type = &TREE_TYPE (decl);\n-      is_type = TREE_CODE (*node) == TYPE_DECL;\n-    }\n-  else if (TYPE_P (*node))\n-    type = node, is_type = 1;\n-\n-  /* Strip any NOPs of any kind.  */\n-  while (TREE_CODE (align_expr) == NOP_EXPR\n-\t || TREE_CODE (align_expr) == CONVERT_EXPR\n-\t || TREE_CODE (align_expr) == NON_LVALUE_EXPR)\n-    align_expr = TREE_OPERAND (align_expr, 0);\n-\n-  if (TREE_CODE (align_expr) != INTEGER_CST)\n-    {\n-      error (\"requested alignment is not a constant\");\n-      *no_add_attrs = true;\n-    }\n-  else if ((i = tree_log2 (align_expr)) == -1)\n-    {\n-      error (\"requested alignment is not a power of 2\");\n-      *no_add_attrs = true;\n-    }\n-  else if (i > HOST_BITS_PER_INT - 2)\n-    {\n-      error (\"requested alignment is too large\");\n-      *no_add_attrs = true;\n-    }\n-  else if (is_type)\n-    {\n-      /* If we have a TYPE_DECL, then copy the type, so that we\n-\t don't accidentally modify a builtin type.  See pushdecl.  */\n-      if (decl && TREE_TYPE (decl) != error_mark_node\n-\t  && DECL_ORIGINAL_TYPE (decl) == NULL_TREE)\n-\t{\n-\t  tree tt = TREE_TYPE (decl);\n-\t  *type = build_type_copy (*type);\n-\t  DECL_ORIGINAL_TYPE (decl) = tt;\n-\t  TYPE_NAME (*type) = decl;\n-\t  TREE_USED (*type) = TREE_USED (decl);\n-\t  TREE_TYPE (decl) = *type;\n-\t}\n-      else if (!(flags & (int) ATTR_FLAG_TYPE_IN_PLACE))\n-\t*type = build_type_copy (*type);\n-\n-      TYPE_ALIGN (*type) = (1 << i) * BITS_PER_UNIT;\n-      TYPE_USER_ALIGN (*type) = 1;\n-    }\n-  else if (TREE_CODE (decl) != VAR_DECL\n-\t   && TREE_CODE (decl) != FIELD_DECL)\n-    {\n-      error_with_decl (decl,\n-\t\t       \"alignment may not be specified for `%s'\");\n-      *no_add_attrs = true;\n-    }\n-  else\n-    {\n-      DECL_ALIGN (decl) = (1 << i) * BITS_PER_UNIT;\n-      DECL_USER_ALIGN (decl) = 1;\n-    }\n-\n-  return NULL_TREE;\n-}\n-\n-/* Handle a \"weak\" attribute; arguments as in\n-   struct attribute_spec.handler.  */\n-\n-static tree\n-handle_weak_attribute (node, name, args, flags, no_add_attrs)\n-     tree *node;\n-     tree name ATTRIBUTE_UNUSED;\n-     tree args ATTRIBUTE_UNUSED;\n-     int flags ATTRIBUTE_UNUSED;\n-     bool *no_add_attrs ATTRIBUTE_UNUSED;\n-{\n-  declare_weak (*node);\n-\n-  return NULL_TREE;\n-}\n-\n-/* Handle an \"alias\" attribute; arguments as in\n-   struct attribute_spec.handler.  */\n-\n-static tree\n-handle_alias_attribute (node, name, args, flags, no_add_attrs)\n-     tree *node;\n-     tree name;\n-     tree args;\n-     int flags ATTRIBUTE_UNUSED;\n-     bool *no_add_attrs;\n-{\n-  tree decl = *node;\n-\n-  if ((TREE_CODE (decl) == FUNCTION_DECL && DECL_INITIAL (decl))\n-      || (TREE_CODE (decl) != FUNCTION_DECL && ! DECL_EXTERNAL (decl)))\n-    {\n-      error_with_decl (decl,\n-\t\t       \"`%s' defined both normally and as an alias\");\n-      *no_add_attrs = true;\n-    }\n-  else if (decl_function_context (decl) == 0)\n-    {\n-      tree id;\n-\n-      id = TREE_VALUE (args);\n-      if (TREE_CODE (id) != STRING_CST)\n-\t{\n-\t  error (\"alias arg not a string\");\n-\t  *no_add_attrs = true;\n-\t  return NULL_TREE;\n-\t}\n-      id = get_identifier (TREE_STRING_POINTER (id));\n-      /* This counts as a use of the object pointed to.  */\n-      TREE_USED (id) = 1;\n-\n-      if (TREE_CODE (decl) == FUNCTION_DECL)\n-\tDECL_INITIAL (decl) = error_mark_node;\n-      else\n-\tDECL_EXTERNAL (decl) = 0;\n-      assemble_alias (decl, id);\n-    }\n-  else\n-    {\n-      warning (\"`%s' attribute ignored\", IDENTIFIER_POINTER (name));\n-      *no_add_attrs = true;\n-    }\n-\n-  return NULL_TREE;\n-}\n-\n-/* Handle a \"no_instrument_function\" attribute; arguments as in\n-   struct attribute_spec.handler.  */\n-\n-static tree\n-handle_no_instrument_function_attribute (node, name, args, flags, no_add_attrs)\n-     tree *node;\n-     tree name;\n-     tree args ATTRIBUTE_UNUSED;\n-     int flags ATTRIBUTE_UNUSED;\n-     bool *no_add_attrs;\n-{\n-  tree decl = *node;\n-\n-  if (TREE_CODE (decl) != FUNCTION_DECL)\n-    {\n-      error_with_decl (decl,\n-\t\t       \"`%s' attribute applies only to functions\",\n-\t\t       IDENTIFIER_POINTER (name));\n-      *no_add_attrs = true;\n-    }\n-  else if (DECL_INITIAL (decl))\n-    {\n-      error_with_decl (decl,\n-\t\t       \"can't set `%s' attribute after definition\",\n-\t\t       IDENTIFIER_POINTER (name));\n-      *no_add_attrs = true;\n-    }\n-  else\n-    DECL_NO_INSTRUMENT_FUNCTION_ENTRY_EXIT (decl) = 1;\n-\n-  return NULL_TREE;\n-}\n-\n-/* Handle a \"no_check_memory_usage\" attribute; arguments as in\n-   struct attribute_spec.handler.  */\n-\n-static tree\n-handle_no_check_memory_usage_attribute (node, name, args, flags, no_add_attrs)\n-     tree *node;\n-     tree name;\n-     tree args ATTRIBUTE_UNUSED;\n-     int flags ATTRIBUTE_UNUSED;\n-     bool *no_add_attrs;\n-{\n-  tree decl = *node;\n-\n-  if (TREE_CODE (decl) != FUNCTION_DECL)\n-    {\n-      error_with_decl (decl,\n-\t\t       \"`%s' attribute applies only to functions\",\n-\t\t       IDENTIFIER_POINTER (name));\n-      *no_add_attrs = true;\n-    }\n-  else if (DECL_INITIAL (decl))\n-    {\n-      error_with_decl (decl,\n-\t\t       \"can't set `%s' attribute after definition\",\n-\t\t       IDENTIFIER_POINTER (name));\n-      *no_add_attrs = true;\n-    }\n-  else\n-    DECL_NO_CHECK_MEMORY_USAGE (decl) = 1;\n-\n-  return NULL_TREE;\n-}\n-\n-/* Handle a \"malloc\" attribute; arguments as in\n-   struct attribute_spec.handler.  */\n-\n-static tree\n-handle_malloc_attribute (node, name, args, flags, no_add_attrs)\n-     tree *node;\n-     tree name;\n-     tree args ATTRIBUTE_UNUSED;\n-     int flags ATTRIBUTE_UNUSED;\n-     bool *no_add_attrs;\n-{\n-  if (TREE_CODE (*node) == FUNCTION_DECL)\n-    DECL_IS_MALLOC (*node) = 1;\n-  /* ??? TODO: Support types.  */\n-  else\n-    {\n-      warning (\"`%s' attribute ignored\", IDENTIFIER_POINTER (name));\n-      *no_add_attrs = true;\n-    }\n-\n-  return NULL_TREE;\n-}\n-\n-/* Handle a \"no_limit_stack\" attribute; arguments as in\n-   struct attribute_spec.handler.  */\n-\n-static tree\n-handle_no_limit_stack_attribute (node, name, args, flags, no_add_attrs)\n-     tree *node;\n-     tree name;\n-     tree args ATTRIBUTE_UNUSED;\n-     int flags ATTRIBUTE_UNUSED;\n-     bool *no_add_attrs;\n-{\n-  tree decl = *node;\n-\n-  if (TREE_CODE (decl) != FUNCTION_DECL)\n-    {\n-      error_with_decl (decl,\n-\t\t       \"`%s' attribute applies only to functions\",\n-\t\t       IDENTIFIER_POINTER (name));\n-      *no_add_attrs = true;\n-    }\n-  else if (DECL_INITIAL (decl))\n-    {\n-      error_with_decl (decl,\n-\t\t       \"can't set `%s' attribute after definition\",\n-\t\t       IDENTIFIER_POINTER (name));\n-      *no_add_attrs = true;\n-    }\n-  else\n-    DECL_NO_LIMIT_STACK (decl) = 1;\n-\n-  return NULL_TREE;\n-}\n-\n-/* Handle a \"pure\" attribute; arguments as in\n-   struct attribute_spec.handler.  */\n-\n-static tree\n-handle_pure_attribute (node, name, args, flags, no_add_attrs)\n-     tree *node;\n-     tree name;\n-     tree args ATTRIBUTE_UNUSED;\n-     int flags ATTRIBUTE_UNUSED;\n-     bool *no_add_attrs;\n-{\n-  if (TREE_CODE (*node) == FUNCTION_DECL)\n-    DECL_IS_PURE (*node) = 1;\n-  /* ??? TODO: Support types.  */\n-  else\n-    {\n-      warning (\"`%s' attribute ignored\", IDENTIFIER_POINTER (name));\n-      *no_add_attrs = true;\n-    }\n-\n-  return NULL_TREE;\n-}\n-\n-/* Split SPECS_ATTRS, a list of declspecs and prefix attributes, into two\n-   lists.  SPECS_ATTRS may also be just a typespec (eg: RECORD_TYPE).\n-\n-   The head of the declspec list is stored in DECLSPECS.\n-   The head of the attribute list is stored in PREFIX_ATTRIBUTES.\n-\n-   Note that attributes in SPECS_ATTRS are stored in the TREE_PURPOSE of\n-   the list elements.  We drop the containing TREE_LIST nodes and link the\n-   resulting attributes together the way decl_attributes expects them.  */\n-\n-void\n-split_specs_attrs (specs_attrs, declspecs, prefix_attributes)\n-     tree specs_attrs;\n-     tree *declspecs, *prefix_attributes;\n-{\n-  tree t, s, a, next, specs, attrs;\n-\n-  /* This can happen after an __extension__ in pedantic mode.  */\n-  if (specs_attrs != NULL_TREE \n-      && TREE_CODE (specs_attrs) == INTEGER_CST)\n-    {\n-      *declspecs = NULL_TREE;\n-      *prefix_attributes = NULL_TREE;\n-      return;\n-    }\n-\n-  /* This can happen in c++ (eg: decl: typespec initdecls ';').  */\n-  if (specs_attrs != NULL_TREE\n-      && TREE_CODE (specs_attrs) != TREE_LIST)\n-    {\n-      *declspecs = specs_attrs;\n-      *prefix_attributes = NULL_TREE;\n-      return;\n-    }\n-\n-  /* Remember to keep the lists in the same order, element-wise.  */\n-\n-  specs = s = NULL_TREE;\n-  attrs = a = NULL_TREE;\n-  for (t = specs_attrs; t; t = next)\n-    {\n-      next = TREE_CHAIN (t);\n-      /* Declspecs have a non-NULL TREE_VALUE.  */\n-      if (TREE_VALUE (t) != NULL_TREE)\n-\t{\n-\t  if (specs == NULL_TREE)\n-\t    specs = s = t;\n-\t  else\n-\t    {\n-\t      TREE_CHAIN (s) = t;\n-\t      s = t;\n-\t    }\n-\t}\n-      /* The TREE_PURPOSE may also be empty in the case of\n-\t __attribute__(()).  */\n-      else if (TREE_PURPOSE (t) != NULL_TREE)\n-\t{\n-\t  if (attrs == NULL_TREE)\n-\t    attrs = a = TREE_PURPOSE (t);\n-\t  else\n-\t    {\n-\t      TREE_CHAIN (a) = TREE_PURPOSE (t);\n-\t      a = TREE_PURPOSE (t);\n-\t    }\n-\t  /* More attrs can be linked here, move A to the end.  */\n-\t  while (TREE_CHAIN (a) != NULL_TREE)\n-\t    a = TREE_CHAIN (a);\n-\t}\n-    }\n-\n-  /* Terminate the lists.  */\n-  if (s != NULL_TREE)\n-    TREE_CHAIN (s) = NULL_TREE;\n-  if (a != NULL_TREE)\n-    TREE_CHAIN (a) = NULL_TREE;\n-\n-  /* All done.  */\n-  *declspecs = specs;\n-  *prefix_attributes = attrs;\n-}\n-\n-/* Strip attributes from SPECS_ATTRS, a list of declspecs and attributes.\n-   This function is used by the parser when a rule will accept attributes\n-   in a particular position, but we don't want to support that just yet.\n-\n-   A warning is issued for every ignored attribute.  */\n-\n-tree\n-strip_attrs (specs_attrs)\n-     tree specs_attrs;\n-{\n-  tree specs, attrs;\n-\n-  split_specs_attrs (specs_attrs, &specs, &attrs);\n-\n-  while (attrs)\n-    {\n-      warning (\"`%s' attribute ignored\",\n-\t       IDENTIFIER_POINTER (TREE_PURPOSE (attrs)));\n-      attrs = TREE_CHAIN (attrs);\n-    }\n-\n-  return specs;\n-}\n-\f\n static int is_valid_printf_arglist PARAMS ((tree));\n static rtx c_expand_builtin PARAMS ((tree, rtx, enum machine_mode, enum expand_modifier));\n static rtx c_expand_builtin_printf PARAMS ((tree, rtx, enum machine_mode,\n@@ -4917,11 +3772,26 @@ boolean_increment (code, arg)\n   return val;\n }\n \f\n+/* Give the specifications for the format attributes, used by C and all\n+   descendents.  */\n+\n+static const struct attribute_spec c_format_attribute_table[] =\n+{\n+  { \"format\",                 3, 3, true,  false, false,\n+\t\t\t      handle_format_attribute },\n+  { \"format_arg\",             1, 1, true,  false, false,\n+\t\t\t      handle_format_arg_attribute },\n+  { NULL,                     0, 0, false, false, false, NULL }\n+};\n+\n+extern const struct attribute_spec *format_attribute_table;\n \n /* Do the parts of lang_init common to C and C++.  */\n void\n c_common_lang_init ()\n {\n+  format_attribute_table = c_format_attribute_table;\n+\n   /* If still \"unspecified\", make it match -fbounded-pointers.  */\n   if (flag_bounds_check < 0)\n     flag_bounds_check = flag_bounded_pointers;"}, {"sha": "3681ed222f02430f2f2654bd5777347f76221ee9", "filename": "gcc/c-common.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb9f8221b43c3a500198fa3a504fa11f5f807988/gcc%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb9f8221b43c3a500198fa3a504fa11f5f807988/gcc%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.h?ref=bb9f8221b43c3a500198fa3a504fa11f5f807988", "patch": "@@ -503,7 +503,6 @@ extern const char *fname_as_string\t\tPARAMS ((int));\n extern tree fname_decl\t\t\t\tPARAMS ((unsigned, tree));\n extern const char *fname_string\t\t\tPARAMS ((unsigned));\n \n-extern tree decl_attributes\t\t\tPARAMS ((tree *, tree, int));\n extern void init_function_format_info\t\tPARAMS ((void));\n extern void check_function_format\t\tPARAMS ((int *, tree, tree, tree));\n extern void set_Wformat\t\t\t\tPARAMS ((int));"}, {"sha": "d28d868ad1fe2d4bdbce3700ae423ea84539abf7", "filename": "gcc/ch/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb9f8221b43c3a500198fa3a504fa11f5f807988/gcc%2Fch%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb9f8221b43c3a500198fa3a504fa11f5f807988/gcc%2Fch%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2FChangeLog?ref=bb9f8221b43c3a500198fa3a504fa11f5f807988", "patch": "@@ -1,3 +1,7 @@\n+Sat Sep 22 09:15:08 2001  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* Make-lang.in (cc1chill): Add attribs.o.\n+\n 2001-08-18  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* tree.c (TYPE_HASH): Moved to ../tree.h."}, {"sha": "87965ab4581ecf4f9e524d9428f563025b77f7b9", "filename": "gcc/ch/Make-lang.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb9f8221b43c3a500198fa3a504fa11f5f807988/gcc%2Fch%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb9f8221b43c3a500198fa3a504fa11f5f807988/gcc%2Fch%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2FMake-lang.in?ref=bb9f8221b43c3a500198fa3a504fa11f5f807988", "patch": "@@ -95,7 +95,7 @@ chill-cross: $(srcdir)/ch/chill.in\n \n cc1chill$(exeext): $(P) $(CHILL_SRCS) $(LIBDEPS) $(BACKEND) \\\n \tinsn-config.h insn-flags.h insn-attr.h insn-codes.h \\\n-\tc-typeck.o c-aux-info.o c-common.o \\\n+\tattribs.o c-typeck.o c-aux-info.o c-common.o \\\n         ggc-callbacks.o\n \tcd ch; $(MAKE) $(LANG_FLAGS_TO_PASS) $(CHILL_FLAGS_TO_PASS) ../cc1chill$(exeext)\n "}, {"sha": "2fed13ffcfc1b6b875b195263a65bab1c9956071", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb9f8221b43c3a500198fa3a504fa11f5f807988/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb9f8221b43c3a500198fa3a504fa11f5f807988/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=bb9f8221b43c3a500198fa3a504fa11f5f807988", "patch": "@@ -1,3 +1,7 @@\n+Sat Sep 22 09:15:31 2001  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* Make-lang.in (CXX_C_OBJS): Add attribs.o.\n+\n 2001-09-21  Richard Henderson  <rth@redhat.com>\n \n \t* class.c (set_vindex): Mind TARGET_VTABLE_USES_DESCRIPTORS."}, {"sha": "21acc0157d8720ee13e7feb6953e2adaf44bb58a", "filename": "gcc/cp/Make-lang.in", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb9f8221b43c3a500198fa3a504fa11f5f807988/gcc%2Fcp%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb9f8221b43c3a500198fa3a504fa11f5f807988/gcc%2Fcp%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FMake-lang.in?ref=bb9f8221b43c3a500198fa3a504fa11f5f807988", "patch": "@@ -93,7 +93,8 @@ $(DEMANGLER_PROG): cxxmain.o underscore.o $(LIBDEPS)\n \n # The compiler itself.\n # Shared with C front end:\n-CXX_C_OBJS = c-common.o c-format.o c-pragma.o c-semantics.o c-lex.o c-dump.o $(CXX_TARGET_OBJS)\n+CXX_C_OBJS = attribs.o c-common.o c-format.o c-pragma.o c-semantics.o c-lex.o \\\n+ c-dump.o $(CXX_TARGET_OBJS)\n \n # Language-specific object files.\n CXX_OBJS = cp/call.o cp/decl.o cp/errfn.o cp/expr.o cp/pt.o cp/typeck2.o \\"}, {"sha": "8bec94f7ced433ad78b040b95d5e85fd008eeaf9", "filename": "gcc/tree.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb9f8221b43c3a500198fa3a504fa11f5f807988/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb9f8221b43c3a500198fa3a504fa11f5f807988/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=bb9f8221b43c3a500198fa3a504fa11f5f807988", "patch": "@@ -2906,6 +2906,9 @@ extern rtx emit_line_note\t\tPARAMS ((const char *, int));\n \n extern int setjmp_call_p\t\tPARAMS ((tree));\n \n+/* In attribs.c.  */\n+extern tree decl_attributes\t\tPARAMS ((tree *, tree, int));\n+\n /* In front end.  */\n \n extern int mark_addressable\t\tPARAMS ((tree));"}]}