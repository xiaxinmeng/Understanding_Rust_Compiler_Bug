{"sha": "b3def403fa7ae89679468b8f986cab7361c1034d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjNkZWY0MDNmYTdhZTg5Njc5NDY4YjhmOTg2Y2FiNzM2MWMxMDM0ZA==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2017-12-07T18:41:35Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-12-07T18:41:35Z"}, "message": "Use tree_vector_builder::new_binary_operation for folding\n\nThis patch makes fold-const.c operate directly on the VECTOR_CST\nencoding when folding an operation that has two VECTOR_CST inputs.\n\n2017-12-07  Richard Sandiford  <richard.sandiford@linaro.org>\n\ngcc/\n\t* tree-vector-builder.h\n\t(tree_vector_builder::new_binary_operation): Declare.\n\t* tree-vector-builder.c\n\t(tree_vector_builder::new_binary_operation): New function.\n\t* fold-const.c (fold_relational_const): Use it.\n\t(const_binop): Likewise.  Check that both input vectors have\n\tthe same number of elements, thus excluding things like WIDEN_SUM.\n\tCheck whether it is possible to operate directly on the encodings\n\tof stepped inputs.\n\nFrom-SVN: r255477", "tree": {"sha": "d1df9bee6f0c02966cfbd1044066b3e1bcea9f8e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d1df9bee6f0c02966cfbd1044066b3e1bcea9f8e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b3def403fa7ae89679468b8f986cab7361c1034d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b3def403fa7ae89679468b8f986cab7361c1034d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b3def403fa7ae89679468b8f986cab7361c1034d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b3def403fa7ae89679468b8f986cab7361c1034d/comments", "author": null, "committer": null, "parents": [{"sha": "059c18abcb9c88bb5a85eb3ce468ffa7252da230", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/059c18abcb9c88bb5a85eb3ce468ffa7252da230", "html_url": "https://github.com/Rust-GCC/gccrs/commit/059c18abcb9c88bb5a85eb3ce468ffa7252da230"}], "stats": {"total": 110, "additions": 98, "deletions": 12}, "files": [{"sha": "6fb516053546482cd109b7808a26d1ccecc2f4e3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3def403fa7ae89679468b8f986cab7361c1034d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3def403fa7ae89679468b8f986cab7361c1034d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b3def403fa7ae89679468b8f986cab7361c1034d", "patch": "@@ -1,3 +1,15 @@\n+2017-12-07  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\t* tree-vector-builder.h\n+\t(tree_vector_builder::new_binary_operation): Declare.\n+\t* tree-vector-builder.c\n+\t(tree_vector_builder::new_binary_operation): New function.\n+\t* fold-const.c (fold_relational_const): Use it.\n+\t(const_binop): Likewise.  Check that both input vectors have\n+\tthe same number of elements, thus excluding things like WIDEN_SUM.\n+\tCheck whether it is possible to operate directly on the encodings\n+\tof stepped inputs.\n+\n 2017-12-07  Richard Sandiford  <richard.sandiford@linaro.org>\n \n \t* fold-const.c (fold_negate_expr_1): Use tree_vector_builder and"}, {"sha": "1b098d9f4c91af002aeacd433ad92ffda0afb9ab", "filename": "gcc/fold-const.c", "status": "modified", "additions": 38, "deletions": 12, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3def403fa7ae89679468b8f986cab7361c1034d/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3def403fa7ae89679468b8f986cab7361c1034d/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=b3def403fa7ae89679468b8f986cab7361c1034d", "patch": "@@ -1435,13 +1435,40 @@ const_binop (enum tree_code code, tree arg1, tree arg2)\n     }\n \n   if (TREE_CODE (arg1) == VECTOR_CST\n-      && TREE_CODE (arg2) == VECTOR_CST)\n+      && TREE_CODE (arg2) == VECTOR_CST\n+      && (TYPE_VECTOR_SUBPARTS (TREE_TYPE (arg1))\n+\t  == TYPE_VECTOR_SUBPARTS (TREE_TYPE (arg2))))\n     {\n       tree type = TREE_TYPE (arg1);\n-      int count = VECTOR_CST_NELTS (arg1), i;\n-\n-      auto_vec<tree, 32> elts (count);\n-      for (i = 0; i < count; i++)\n+      bool step_ok_p;\n+      if (VECTOR_CST_STEPPED_P (arg1)\n+\t  && VECTOR_CST_STEPPED_P (arg2))\n+\t/* We can operate directly on the encoding if:\n+\n+\t      a3 - a2 == a2 - a1 && b3 - b2 == b2 - b1\n+\t    implies\n+\t      (a3 op b3) - (a2 op b2) == (a2 op b2) - (a1 op b1)\n+\n+\t   Addition and subtraction are the supported operators\n+\t   for which this is true.  */\n+\tstep_ok_p = (code == PLUS_EXPR || code == MINUS_EXPR);\n+      else if (VECTOR_CST_STEPPED_P (arg1))\n+\t/* We can operate directly on stepped encodings if:\n+\n+\t     a3 - a2 == a2 - a1\n+\t   implies:\n+\t     (a3 op c) - (a2 op c) == (a2 op c) - (a1 op c)\n+\n+\t   which is true if (x -> x op c) distributes over addition.  */\n+\tstep_ok_p = distributes_over_addition_p (code, 1);\n+      else\n+\t/* Similarly in reverse.  */\n+\tstep_ok_p = distributes_over_addition_p (code, 2);\n+      tree_vector_builder elts;\n+      if (!elts.new_binary_operation (type, arg1, arg2, step_ok_p))\n+\treturn NULL_TREE;\n+      unsigned int count = elts.encoded_nelts ();\n+      for (unsigned int i = 0; i < count; ++i)\n \t{\n \t  tree elem1 = VECTOR_CST_ELT (arg1, i);\n \t  tree elem2 = VECTOR_CST_ELT (arg2, i);\n@@ -1455,7 +1482,7 @@ const_binop (enum tree_code code, tree arg1, tree arg2)\n \t  elts.quick_push (elt);\n \t}\n \n-      return build_vector (type, elts);\n+      return elts.build ();\n     }\n \n   /* Shifts allow a scalar offset for a vector.  */\n@@ -13770,11 +13797,10 @@ fold_relational_const (enum tree_code code, tree type, tree op0, tree op1)\n \t    }\n \t  return constant_boolean_node (true, type);\n \t}\n-      unsigned count = VECTOR_CST_NELTS (op0);\n-      gcc_assert (VECTOR_CST_NELTS (op1) == count\n-\t\t  && TYPE_VECTOR_SUBPARTS (type) == count);\n-\n-      auto_vec<tree, 32> elts (count);\n+      tree_vector_builder elts;\n+      if (!elts.new_binary_operation (type, op0, op1, false))\n+\treturn NULL_TREE;\n+      unsigned int count = elts.encoded_nelts ();\n       for (unsigned i = 0; i < count; i++)\n \t{\n \t  tree elem_type = TREE_TYPE (type);\n@@ -13791,7 +13817,7 @@ fold_relational_const (enum tree_code code, tree type, tree op0, tree op1)\n \t\t\t\t\t  integer_zerop (tem) ? 0 : -1));\n \t}\n \n-      return build_vector (type, elts);\n+      return elts.build ();\n     }\n \n   /* From here on we only handle LT, LE, GT, GE, EQ and NE."}, {"sha": "a8a98970f37eee236419323307ac7b89bc98e409", "filename": "gcc/tree-vector-builder.c", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3def403fa7ae89679468b8f986cab7361c1034d/gcc%2Ftree-vector-builder.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3def403fa7ae89679468b8f986cab7361c1034d/gcc%2Ftree-vector-builder.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vector-builder.c?ref=b3def403fa7ae89679468b8f986cab7361c1034d", "patch": "@@ -49,6 +49,53 @@ tree_vector_builder::new_unary_operation (tree type, tree t,\n   return true;\n }\n \n+/* Try to start building a new vector of type TYPE that holds the result of\n+   a binary operation on VECTOR_CSTs T1 and T2.  ALLOW_STEPPED_P is true if\n+   the operation can handle stepped encodings directly, without having to\n+   expand the full sequence.\n+\n+   Return true if the operation is possible.  Leave the builder unchanged\n+   otherwise.  */\n+\n+bool\n+tree_vector_builder::new_binary_operation (tree type, tree t1, tree t2,\n+\t\t\t\t\t   bool allow_stepped_p)\n+{\n+  unsigned int full_nelts = TYPE_VECTOR_SUBPARTS (type);\n+  gcc_assert (full_nelts == TYPE_VECTOR_SUBPARTS (TREE_TYPE (t1))\n+\t      && full_nelts == TYPE_VECTOR_SUBPARTS (TREE_TYPE (t2)));\n+  /* Conceptually we split the patterns in T1 and T2 until we have\n+     an equal number for both.  Each split pattern requires the same\n+     number of elements per pattern as the original.  E.g. splitting:\n+\n+       { 1, 2, 3, ... }\n+\n+     into two gives:\n+\n+       { 1, 3, 5, ... }\n+       { 2, 4, 6, ... }\n+\n+     while splitting:\n+\n+       { 1, 0, ... }\n+\n+     into two gives:\n+\n+       { 1, 0, ... }\n+       { 0, 0, ... }.  */\n+  unsigned int npatterns = least_common_multiple (VECTOR_CST_NPATTERNS (t1),\n+\t\t\t\t\t\t  VECTOR_CST_NPATTERNS (t2));\n+  unsigned int nelts_per_pattern = MAX (VECTOR_CST_NELTS_PER_PATTERN (t1),\n+\t\t\t\t\tVECTOR_CST_NELTS_PER_PATTERN (t2));\n+  if (!allow_stepped_p && nelts_per_pattern > 2)\n+    {\n+      npatterns = full_nelts;\n+      nelts_per_pattern = 1;\n+    }\n+  new_vector (type, npatterns, nelts_per_pattern);\n+  return true;\n+}\n+\n /* Return a VECTOR_CST for the current constant.  */\n \n tree"}, {"sha": "b89d3ab3af629fca2bf0173341650f40621c90eb", "filename": "gcc/tree-vector-builder.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3def403fa7ae89679468b8f986cab7361c1034d/gcc%2Ftree-vector-builder.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3def403fa7ae89679468b8f986cab7361c1034d/gcc%2Ftree-vector-builder.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vector-builder.h?ref=b3def403fa7ae89679468b8f986cab7361c1034d", "patch": "@@ -38,6 +38,7 @@ class tree_vector_builder : public vector_builder<tree, tree_vector_builder>\n \n   void new_vector (tree, unsigned int, unsigned int);\n   bool new_unary_operation (tree, tree, bool);\n+  bool new_binary_operation (tree, tree, tree, bool);\n \n private:\n   bool equal_p (const_tree, const_tree) const;"}]}