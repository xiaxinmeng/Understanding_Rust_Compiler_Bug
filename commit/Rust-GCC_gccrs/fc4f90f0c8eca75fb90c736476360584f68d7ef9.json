{"sha": "fc4f90f0c8eca75fb90c736476360584f68d7ef9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmM0ZjkwZjBjOGVjYTc1ZmI5MGM3MzY0NzYzNjA1ODRmNjhkN2VmOQ==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2019-08-28T18:27:30Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2019-08-28T18:27:30Z"}, "message": "compiler, runtime: provide index information on bounds check failure\n    \n    This implements https://golang.org/cl/161477 in the gofrontend.\n    \n    Updates golang/go#30116\n    \n    Reviewed-on: https://go-review.googlesource.com/c/gofrontend/+/191881\n\nFrom-SVN: r274998", "tree": {"sha": "ff64bd8a2576d7eb0b85638a14cc3a761cb72db1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ff64bd8a2576d7eb0b85638a14cc3a761cb72db1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fc4f90f0c8eca75fb90c736476360584f68d7ef9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc4f90f0c8eca75fb90c736476360584f68d7ef9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fc4f90f0c8eca75fb90c736476360584f68d7ef9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc4f90f0c8eca75fb90c736476360584f68d7ef9/comments", "author": null, "committer": null, "parents": [{"sha": "464969eb9b47eb2f24403c74c16769a58dbaa638", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/464969eb9b47eb2f24403c74c16769a58dbaa638", "html_url": "https://github.com/Rust-GCC/gccrs/commit/464969eb9b47eb2f24403c74c16769a58dbaa638"}], "stats": {"total": 962, "additions": 739, "deletions": 223}, "files": [{"sha": "f596a6988400e42f53a6731667230922c0186960", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc4f90f0c8eca75fb90c736476360584f68d7ef9/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc4f90f0c8eca75fb90c736476360584f68d7ef9/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=fc4f90f0c8eca75fb90c736476360584f68d7ef9", "patch": "@@ -1,4 +1,4 @@\n-a6ddd0e1208a7d229c10be630c1110b3914038f5\n+189ff44b2c26f29f41f0eb159e0d8f3fa508ecae\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "939a5f7f3748a5da54d5217108dc4a2cfadec0fd", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 292, "deletions": 183, "changes": 475, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc4f90f0c8eca75fb90c736476360584f68d7ef9/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc4f90f0c8eca75fb90c736476360584f68d7ef9/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=fc4f90f0c8eca75fb90c736476360584f68d7ef9", "patch": "@@ -594,67 +594,110 @@ Expression::backend_numeric_constant_expression(Translate_context* context,\n   return ret;\n }\n \n-// Return an expression which evaluates to true if VAL, of arbitrary integer\n-// type, is negative or is more than the maximum value of the Go type \"int\".\n+// Insert bounds checks for an index expression.  Check that that VAL\n+// >= 0 and that it fits in an int.  Then check that VAL OP BOUND is\n+// true.  If any condition is false, call one of the CODE runtime\n+// functions, which will panic.\n \n-Expression*\n-Expression::check_bounds(Expression* val, Location loc)\n+void\n+Expression::check_bounds(Expression* val, Operator op, Expression* bound,\n+\t\t\t Runtime::Function code,\n+\t\t\t Runtime::Function code_u,\n+\t\t\t Runtime::Function code_extend,\n+\t\t\t Runtime::Function code_extend_u,\n+\t\t\t Statement_inserter* inserter,\n+\t\t\t Location loc)\n {\n-  Type* val_type = val->type();\n-  Type* bound_type = Type::lookup_integer_type(\"int\");\n+  go_assert(val->is_variable() || val->is_constant());\n+  go_assert(bound->is_variable() || bound->is_constant());\n \n-  int val_type_size;\n-  bool val_is_unsigned = false;\n-  if (val_type->integer_type() != NULL)\n-    {\n-      val_type_size = val_type->integer_type()->bits();\n-      val_is_unsigned = val_type->integer_type()->is_unsigned();\n-    }\n-  else\n-    {\n-      if (!val_type->is_numeric_type()\n-          || !Type::are_convertible(bound_type, val_type, NULL))\n-        {\n-          go_assert(saw_errors());\n-          return Expression::make_boolean(true, loc);\n-        }\n+  Type* int_type = Type::lookup_integer_type(\"int\");\n+  int int_type_size = int_type->integer_type()->bits();\n \n-      if (val_type->complex_type() != NULL)\n-        val_type_size = val_type->complex_type()->bits();\n-      else\n-        val_type_size = val_type->float_type()->bits();\n+  Type* val_type = val->type();\n+  if (val_type->integer_type() == NULL)\n+    {\n+      go_assert(saw_errors());\n+      return;\n     }\n+  int val_type_size = val_type->integer_type()->bits();\n+  bool val_is_unsigned = val_type->integer_type()->is_unsigned();\n \n-  Expression* negative_index = Expression::make_boolean(false, loc);\n-  Expression* index_overflows = Expression::make_boolean(false, loc);\n+  // Check that VAL >= 0.\n+  Expression* check = NULL;\n   if (!val_is_unsigned)\n     {\n       Expression* zero = Expression::make_integer_ul(0, val_type, loc);\n-      negative_index = Expression::make_binary(OPERATOR_LT, val, zero, loc);\n+      check = Expression::make_binary(OPERATOR_GE, val->copy(), zero, loc);\n     }\n \n-  int bound_type_size = bound_type->integer_type()->bits();\n-  if (val_type_size > bound_type_size\n-      || (val_type_size == bound_type_size\n+  // If VAL's type is larger than int, check that VAL fits in an int.\n+  if (val_type_size > int_type_size\n+      || (val_type_size == int_type_size\n \t  && val_is_unsigned))\n     {\n       mpz_t one;\n       mpz_init_set_ui(one, 1UL);\n \n-      // maxval = 2^(bound_type_size - 1) - 1\n+      // maxval = 2^(int_type_size - 1) - 1\n       mpz_t maxval;\n       mpz_init(maxval);\n-      mpz_mul_2exp(maxval, one, bound_type_size - 1);\n+      mpz_mul_2exp(maxval, one, int_type_size - 1);\n       mpz_sub_ui(maxval, maxval, 1);\n       Expression* max = Expression::make_integer_z(&maxval, val_type, loc);\n       mpz_clear(one);\n       mpz_clear(maxval);\n \n-      index_overflows = Expression::make_binary(OPERATOR_GT, val, max, loc);\n+      Expression* cmp = Expression::make_binary(OPERATOR_LE, val->copy(),\n+\t\t\t\t\t\tmax, loc);\n+      if (check == NULL)\n+\tcheck = cmp;\n+      else\n+\tcheck = Expression::make_binary(OPERATOR_ANDAND, check, cmp, loc);\n+    }\n+\n+  // For the final check we can assume that VAL fits in an int.\n+  Expression* ival;\n+  if (val_type == int_type)\n+    ival = val->copy();\n+  else\n+    ival = Expression::make_cast(int_type, val->copy(), loc);\n+\n+  // BOUND is assumed to fit in an int.  Either it comes from len or\n+  // cap, or it was checked by an earlier call.\n+  Expression* ibound;\n+  if (bound->type() == int_type)\n+    ibound = bound->copy();\n+  else\n+    ibound = Expression::make_cast(int_type, bound->copy(), loc);\n+\n+  Expression* cmp = Expression::make_binary(op, ival, ibound, loc);\n+  if (check == NULL)\n+    check = cmp;\n+  else\n+    check = Expression::make_binary(OPERATOR_ANDAND, check, cmp, loc);\n+\n+  Runtime::Function c;\n+  if (val_type_size > int_type_size)\n+    {\n+      if (val_is_unsigned)\n+\tc = code_extend_u;\n+      else\n+\tc = code_extend;\n+    }\n+  else\n+    {\n+      if (val_is_unsigned)\n+\tc = code_u;\n+      else\n+\tc = code;\n     }\n \n-  return Expression::make_binary(OPERATOR_OROR, negative_index, index_overflows,\n-                                 loc);\n+  Expression* ignore = Expression::make_boolean(true, loc);\n+  Expression* crash = Runtime::make_call(c, loc, 2,\n+\t\t\t\t\t val->copy(), bound->copy());\n+  Expression* cond = Expression::make_conditional(check, ignore, crash, loc);\n+  inserter->insert(Statement::make_statement(cond, true));\n }\n \n void\n@@ -12666,23 +12709,26 @@ Array_index_expression::do_check_types(Gogo*)\n   unsigned long v;\n   if (this->start_->type()->integer_type() == NULL\n       && !this->start_->type()->is_error()\n-      && (!this->start_->numeric_constant_value(&nc)\n+      && (!this->start_->type()->is_abstract()\n+\t  || !this->start_->numeric_constant_value(&nc)\n \t  || nc.to_unsigned_long(&v) == Numeric_constant::NC_UL_NOTINT))\n     this->report_error(_(\"index must be integer\"));\n   if (this->end_ != NULL\n       && this->end_->type()->integer_type() == NULL\n       && !this->end_->type()->is_error()\n       && !this->end_->is_nil_expression()\n       && !this->end_->is_error_expression()\n-      && (!this->end_->numeric_constant_value(&nc)\n+      && (!this->end_->type()->is_abstract()\n+\t  || !this->end_->numeric_constant_value(&nc)\n \t  || nc.to_unsigned_long(&v) == Numeric_constant::NC_UL_NOTINT))\n     this->report_error(_(\"slice end must be integer\"));\n   if (this->cap_ != NULL\n       && this->cap_->type()->integer_type() == NULL\n       && !this->cap_->type()->is_error()\n       && !this->cap_->is_nil_expression()\n       && !this->cap_->is_error_expression()\n-      && (!this->cap_->numeric_constant_value(&nc)\n+      && (!this->cap_->type()->is_abstract()\n+\t  || !this->cap_->numeric_constant_value(&nc)\n \t  || nc.to_unsigned_long(&v) == Numeric_constant::NC_UL_NOTINT))\n     this->report_error(_(\"slice capacity must be integer\"));\n \n@@ -12799,13 +12845,21 @@ Array_index_expression::do_must_eval_subexpressions_in_order(\n   return true;\n }\n \n-// Flatten array indexing by using temporary variables for slices and indexes.\n+// Flatten array indexing: add temporary variables and bounds checks.\n \n Expression*\n-Array_index_expression::do_flatten(Gogo*, Named_object*,\n+Array_index_expression::do_flatten(Gogo* gogo, Named_object*,\n                                    Statement_inserter* inserter)\n {\n+  if (this->is_flattened_)\n+    return this;\n+  this->is_flattened_ = true;\n+\n   Location loc = this->location();\n+\n+  if (this->is_error_expression())\n+    return Expression::make_error(loc);\n+\n   Expression* array = this->array_;\n   Expression* start = this->start_;\n   Expression* end = this->end_;\n@@ -12823,34 +12877,157 @@ Array_index_expression::do_flatten(Gogo*, Named_object*,\n       return Expression::make_error(loc);\n     }\n \n+  Array_type* array_type = this->array_->type()->array_type();\n+  if (array_type == NULL)\n+    {\n+      go_assert(saw_errors());\n+      return Expression::make_error(loc);\n+    }\n+\n   Temporary_statement* temp;\n-  if (array->type()->is_slice_type() && !array->is_variable())\n+  if (array_type->is_slice_type() && !array->is_variable())\n     {\n       temp = Statement::make_temporary(NULL, array, loc);\n       inserter->insert(temp);\n       this->array_ = Expression::make_temporary_reference(temp, loc);\n+      array = this->array_;\n     }\n-  if (!start->is_variable())\n+  if (!start->is_variable() && !start->is_constant())\n     {\n       temp = Statement::make_temporary(NULL, start, loc);\n       inserter->insert(temp);\n       this->start_ = Expression::make_temporary_reference(temp, loc);\n+      start = this->start_;\n     }\n   if (end != NULL\n       && !end->is_nil_expression()\n-      && !end->is_variable())\n+      && !end->is_variable()\n+      && !end->is_constant())\n     {\n       temp = Statement::make_temporary(NULL, end, loc);\n       inserter->insert(temp);\n       this->end_ = Expression::make_temporary_reference(temp, loc);\n+      end = this->end_;\n     }\n-  if (cap != NULL && !cap->is_variable())\n+  if (cap != NULL && !cap->is_variable() && !cap->is_constant())\n     {\n       temp = Statement::make_temporary(NULL, cap, loc);\n       inserter->insert(temp);\n       this->cap_ = Expression::make_temporary_reference(temp, loc);\n+      cap = this->cap_;\n+    }\n+\n+  if (!this->needs_bounds_check_)\n+    return this;\n+\n+  Expression* len;\n+  if (!array_type->is_slice_type())\n+    {\n+      len = array_type->get_length(gogo, this->array_);\n+      go_assert(len->is_constant());\n+    }\n+  else\n+    {\n+      len = array_type->get_length(gogo, this->array_->copy());\n+      temp = Statement::make_temporary(NULL, len, loc);\n+      inserter->insert(temp);\n+      len = Expression::make_temporary_reference(temp, loc);\n+    }\n+\n+  Expression* scap = NULL;\n+  if (array_type->is_slice_type())\n+    {\n+      scap = array_type->get_capacity(gogo, this->array_->copy());\n+      temp = Statement::make_temporary(NULL, scap, loc);\n+      inserter->insert(temp);\n+      scap = Expression::make_temporary_reference(temp, loc);\n     }\n \n+  // The order of bounds checks here matches the order used by the gc\n+  // compiler, as tested by issue30116[u].go.\n+\n+  if (cap != NULL)\n+    {\n+      if (array_type->is_slice_type())\n+\tExpression::check_bounds(cap, OPERATOR_LE, scap,\n+\t\t\t\t Runtime::PANIC_SLICE3_ACAP,\n+\t\t\t\t Runtime::PANIC_SLICE3_ACAP_U,\n+\t\t\t\t Runtime::PANIC_EXTEND_SLICE3_ACAP,\n+\t\t\t\t Runtime::PANIC_EXTEND_SLICE3_ACAP_U,\n+\t\t\t\t inserter, loc);\n+      else\n+\tExpression::check_bounds(cap, OPERATOR_LE, len,\n+\t\t\t\t Runtime::PANIC_SLICE3_ALEN,\n+\t\t\t\t Runtime::PANIC_SLICE3_ALEN_U,\n+\t\t\t\t Runtime::PANIC_EXTEND_SLICE3_ALEN,\n+\t\t\t\t Runtime::PANIC_EXTEND_SLICE3_ALEN_U,\n+\t\t\t\t inserter, loc);\n+\n+      Expression* start_bound = cap;\n+      if (end != NULL && !end->is_nil_expression())\n+\t{\n+\t  Expression::check_bounds(end, OPERATOR_LE, cap,\n+\t\t\t\t   Runtime::PANIC_SLICE3_B,\n+\t\t\t\t   Runtime::PANIC_SLICE3_B_U,\n+\t\t\t\t   Runtime::PANIC_EXTEND_SLICE3_B,\n+\t\t\t\t   Runtime::PANIC_EXTEND_SLICE3_B_U,\n+\t\t\t\t   inserter, loc);\n+\t  start_bound = end;\n+\t}\n+\n+      Expression::check_bounds(start, OPERATOR_LE, start_bound,\n+\t\t\t       Runtime::PANIC_SLICE3_C,\n+\t\t\t       Runtime::PANIC_SLICE3_C_U,\n+\t\t\t       Runtime::PANIC_EXTEND_SLICE3_C,\n+\t\t\t       Runtime::PANIC_EXTEND_SLICE3_C_U,\n+\t\t\t       inserter, loc);\n+    }\n+  else if (end != NULL && !end->is_nil_expression())\n+    {\n+      if (array_type->is_slice_type())\n+\tExpression::check_bounds(end, OPERATOR_LE, scap,\n+\t\t\t\t Runtime::PANIC_SLICE_ACAP,\n+\t\t\t\t Runtime::PANIC_SLICE_ACAP_U,\n+\t\t\t\t Runtime::PANIC_EXTEND_SLICE_ACAP,\n+\t\t\t\t Runtime::PANIC_EXTEND_SLICE_ACAP_U,\n+\t\t\t\t inserter, loc);\n+      else\n+\tExpression::check_bounds(end, OPERATOR_LE, len,\n+\t\t\t\t Runtime::PANIC_SLICE_ALEN,\n+\t\t\t\t Runtime::PANIC_SLICE_ALEN_U,\n+\t\t\t\t Runtime::PANIC_EXTEND_SLICE_ALEN,\n+\t\t\t\t Runtime::PANIC_EXTEND_SLICE_ALEN_U,\n+\t\t\t\t inserter, loc);\n+\n+      Expression::check_bounds(start, OPERATOR_LE, end,\n+\t\t\t       Runtime::PANIC_SLICE_B,\n+\t\t\t       Runtime::PANIC_SLICE_B_U,\n+\t\t\t       Runtime::PANIC_EXTEND_SLICE_B,\n+\t\t\t       Runtime::PANIC_EXTEND_SLICE_B_U,\n+\t\t\t       inserter, loc);\n+    }\n+  else if (end != NULL)\n+    {\n+      Expression* start_bound;\n+      if (array_type->is_slice_type())\n+\tstart_bound = scap;\n+      else\n+\tstart_bound = len;\n+      Expression::check_bounds(start, OPERATOR_LE, start_bound,\n+\t\t\t       Runtime::PANIC_SLICE_B,\n+\t\t\t       Runtime::PANIC_SLICE_B_U,\n+\t\t\t       Runtime::PANIC_EXTEND_SLICE_B,\n+\t\t\t       Runtime::PANIC_EXTEND_SLICE_B_U,\n+\t\t\t       inserter, loc);\n+    }\n+  else\n+    Expression::check_bounds(start, OPERATOR_LT, len,\n+\t\t\t     Runtime::PANIC_INDEX,\n+\t\t\t     Runtime::PANIC_INDEX_U,\n+\t\t\t     Runtime::PANIC_EXTEND_INDEX,\n+\t\t\t     Runtime::PANIC_EXTEND_INDEX_U,\n+\t\t\t     inserter, loc);\n+\n   return this;\n }\n \n@@ -12899,10 +13076,8 @@ Array_index_expression::do_get_backend(Translate_context* context)\n   Type* int_type = Type::lookup_integer_type(\"int\");\n   Btype* int_btype = int_type->get_backend(gogo);\n \n-  // We need to convert the length and capacity to the Go \"int\" type here\n-  // because the length of a fixed-length array could be of type \"uintptr\"\n-  // and gimple disallows binary operations between \"uintptr\" and other\n-  // integer types. FIXME.\n+  // Convert the length and capacity to \"int\".  FIXME: Do we need to\n+  // do this?\n   Bexpression* length = NULL;\n   if (this->end_ == NULL || this->end_->is_nil_expression())\n     {\n@@ -12939,53 +13114,18 @@ Array_index_expression::do_get_backend(Translate_context* context)\n   Bexpression* start = this->start_->get_backend(context);\n   start = gogo->backend()->convert_expression(int_btype, start, loc);\n \n-  Bexpression* crash = NULL;\n-  Bexpression* bad_index = NULL;\n-  if (this->needs_bounds_check_)\n-    {\n-      int code = (array_type->length() != NULL\n-                  ? (this->end_ == NULL\n-                     ? RUNTIME_ERROR_ARRAY_INDEX_OUT_OF_BOUNDS\n-                     : RUNTIME_ERROR_ARRAY_SLICE_OUT_OF_BOUNDS)\n-                  : (this->end_ == NULL\n-                     ? RUNTIME_ERROR_SLICE_INDEX_OUT_OF_BOUNDS\n-                     : RUNTIME_ERROR_SLICE_SLICE_OUT_OF_BOUNDS));\n-      crash = gogo->runtime_error(code, loc)->get_backend(context);\n-      bad_index = Expression::check_bounds(this->start_, loc)->get_backend(context);\n-      Bexpression* start_too_large =\n-        gogo->backend()->binary_expression((this->end_ == NULL\n-                                            ? OPERATOR_GE\n-                                            : OPERATOR_GT),\n-                                           start,\n-                                           (this->end_ == NULL\n-                                            ? length\n-                                            : capacity),\n-                                           loc);\n-      bad_index = gogo->backend()->binary_expression(OPERATOR_OROR,\n-                                                     start_too_large,\n-                                                     bad_index, loc);\n-    }\n-\n-\n   Bfunction* bfn = context->function()->func_value()->get_decl();\n   if (this->end_ == NULL)\n     {\n-      // Simple array indexing.  This has to return an l-value, so\n-      // wrap the index check into START.\n-      if (this->needs_bounds_check_)\n-        start =\n-          gogo->backend()->conditional_expression(bfn, int_btype, bad_index,\n-                                                  crash, start, loc);\n-\n+      // Simple array indexing.\n       Bexpression* ret;\n-      if (array_type->length() != NULL)\n+      if (!array_type->is_slice_type())\n \t{\n \t  Bexpression* array = this->array_->get_backend(context);\n \t  ret = gogo->backend()->array_index_expression(array, start, loc);\n \t}\n       else\n \t{\n-\t  // Slice.\n \t  Expression* valptr =\n               array_type->get_value_pointer(gogo, this->array_,\n                                             this->is_lvalue_);\n@@ -12999,31 +13139,7 @@ Array_index_expression::do_get_backend(Translate_context* context)\n       return ret;\n     }\n \n-  // Array slice.\n-\n-  if (this->cap_ != NULL)\n-    {\n-      cap_arg = gogo->backend()->convert_expression(int_btype, cap_arg, loc);\n-\n-      if (this->needs_bounds_check_)\n-        {\n-          Bexpression* bounds_bcheck =\n-            Expression::check_bounds(this->cap_, loc)->get_backend(context);\n-          bad_index =\n-            gogo->backend()->binary_expression(OPERATOR_OROR, bounds_bcheck,\n-                                               bad_index, loc);\n-\n-          Bexpression* cap_too_small =\n-            gogo->backend()->binary_expression(OPERATOR_LT, cap_arg, start, loc);\n-          Bexpression* cap_too_large =\n-            gogo->backend()->binary_expression(OPERATOR_GT, cap_arg, capacity, loc);\n-          Bexpression* bad_cap =\n-            gogo->backend()->binary_expression(OPERATOR_OROR, cap_too_small,\n-                                               cap_too_large, loc);\n-          bad_index = gogo->backend()->binary_expression(OPERATOR_OROR, bad_cap,\n-                                                         bad_index, loc);\n-        }\n-    }\n+  // Slice expression.\n \n   Bexpression* end;\n   if (this->end_->is_nil_expression())\n@@ -13032,24 +13148,6 @@ Array_index_expression::do_get_backend(Translate_context* context)\n     {\n       end = this->end_->get_backend(context);\n       end = gogo->backend()->convert_expression(int_btype, end, loc);\n-      if (this->needs_bounds_check_)\n-        {\n-          Bexpression* bounds_bcheck =\n-            Expression::check_bounds(this->end_, loc)->get_backend(context);\n-          bad_index =\n-            gogo->backend()->binary_expression(OPERATOR_OROR, bounds_bcheck,\n-                                               bad_index, loc);\n-\n-          Bexpression* end_too_small =\n-            gogo->backend()->binary_expression(OPERATOR_LT, end, start, loc);\n-          Bexpression* end_too_large =\n-            gogo->backend()->binary_expression(OPERATOR_GT, end, cap_arg, loc);\n-          Bexpression* bad_end =\n-            gogo->backend()->binary_expression(OPERATOR_OROR, end_too_small,\n-                                               end_too_large, loc);\n-          bad_index = gogo->backend()->binary_expression(OPERATOR_OROR, bad_end,\n-                                                         bad_index, loc);\n-        }\n     }\n \n   Bexpression* result_length =\n@@ -13081,12 +13179,7 @@ Array_index_expression::do_get_backend(Translate_context* context)\n   init.push_back(result_length);\n   init.push_back(result_capacity);\n \n-  Bexpression* ret =\n-    gogo->backend()->constructor_expression(struct_btype, init, loc);\n-  if (this->needs_bounds_check_)\n-    ret = gogo->backend()->conditional_expression(bfn, struct_btype, bad_index,\n-                                                  crash, ret, loc);\n-  return ret;\n+  return gogo->backend()->constructor_expression(struct_btype, init, loc);\n }\n \n // Export an array index expression.\n@@ -13164,7 +13257,15 @@ Expression*\n String_index_expression::do_flatten(Gogo*, Named_object*,\n                                     Statement_inserter* inserter)\n {\n+  if (this->is_flattened_)\n+    return this;\n+  this->is_flattened_ = true;\n+\n   Location loc = this->location();\n+\n+  if (this->is_error_expression())\n+    return Expression::make_error(loc);\n+\n   Expression* string = this->string_;\n   Expression* start = this->start_;\n   Expression* end = this->end_;\n@@ -13180,27 +13281,69 @@ String_index_expression::do_flatten(Gogo*, Named_object*,\n     }\n \n   Temporary_statement* temp;\n-  if (!this->string_->is_variable())\n+  if (!string->is_variable())\n     {\n-      temp = Statement::make_temporary(NULL, this->string_, loc);\n+      temp = Statement::make_temporary(NULL, string, loc);\n       inserter->insert(temp);\n       this->string_ = Expression::make_temporary_reference(temp, loc);\n+      string = this->string_;\n     }\n-  if (!this->start_->is_variable())\n+  if (!start->is_variable())\n     {\n-      temp = Statement::make_temporary(NULL, this->start_, loc);\n+      temp = Statement::make_temporary(NULL, start, loc);\n       inserter->insert(temp);\n       this->start_ = Expression::make_temporary_reference(temp, loc);\n+      start = this->start_;\n     }\n-  if (this->end_ != NULL\n-      && !this->end_->is_nil_expression()\n-      && !this->end_->is_variable())\n+  if (end != NULL\n+      && !end->is_nil_expression()\n+      && !end->is_variable())\n     {\n-      temp = Statement::make_temporary(NULL, this->end_, loc);\n+      temp = Statement::make_temporary(NULL, end, loc);\n       inserter->insert(temp);\n       this->end_ = Expression::make_temporary_reference(temp, loc);\n+      end = this->end_;\n     }\n \n+  Expression* len = Expression::make_string_info(string->copy(),\n+\t\t\t\t\t\t STRING_INFO_LENGTH, loc);\n+  temp = Statement::make_temporary(NULL, len, loc);\n+  inserter->insert(temp);\n+  len = Expression::make_temporary_reference(temp, loc);\n+\n+  // The order of bounds checks here matches the order used by the gc\n+  // compiler, as tested by issue30116[u].go.\n+\n+  if (end != NULL && !end->is_nil_expression())\n+    {\n+      Expression::check_bounds(end, OPERATOR_LE, len,\n+\t\t\t       Runtime::PANIC_SLICE_ALEN,\n+\t\t\t       Runtime::PANIC_SLICE_ALEN_U,\n+\t\t\t       Runtime::PANIC_EXTEND_SLICE_ALEN,\n+\t\t\t       Runtime::PANIC_EXTEND_SLICE_ALEN_U,\n+\t\t\t       inserter, loc);\n+      Expression::check_bounds(start, OPERATOR_LE, end,\n+\t\t\t       Runtime::PANIC_SLICE_B,\n+\t\t\t       Runtime::PANIC_SLICE_B_U,\n+\t\t\t       Runtime::PANIC_EXTEND_SLICE_B,\n+\t\t\t       Runtime::PANIC_EXTEND_SLICE_B_U,\n+\t\t\t       inserter, loc);\n+    }\n+  else if (end != NULL)\n+    Expression::check_bounds(start, OPERATOR_LE, len,\n+\t\t\t     Runtime::PANIC_SLICE_B,\n+\t\t\t     Runtime::PANIC_SLICE_B_U,\n+\t\t\t     Runtime::PANIC_EXTEND_SLICE_B,\n+\t\t\t     Runtime::PANIC_EXTEND_SLICE_B_U,\n+\t\t\t     inserter, loc);\n+  else\n+    Expression::check_bounds(start, OPERATOR_LT, len,\n+\t\t\t     Runtime::PANIC_INDEX,\n+\t\t\t     Runtime::PANIC_INDEX_U,\n+\t\t\t     Runtime::PANIC_EXTEND_INDEX,\n+\t\t\t     Runtime::PANIC_EXTEND_INDEX_U,\n+\t\t\t     inserter, loc);\n+\n   return this;\n }\n \n@@ -13245,15 +13388,17 @@ String_index_expression::do_check_types(Gogo*)\n   unsigned long v;\n   if (this->start_->type()->integer_type() == NULL\n       && !this->start_->type()->is_error()\n-      && (!this->start_->numeric_constant_value(&nc)\n+      && (!this->start_->type()->is_abstract()\n+\t  || !this->start_->numeric_constant_value(&nc)\n \t  || nc.to_unsigned_long(&v) == Numeric_constant::NC_UL_NOTINT))\n     this->report_error(_(\"index must be integer\"));\n   if (this->end_ != NULL\n       && this->end_->type()->integer_type() == NULL\n       && !this->end_->type()->is_error()\n       && !this->end_->is_nil_expression()\n       && !this->end_->is_error_expression()\n-      && (!this->end_->numeric_constant_value(&nc)\n+      && (!this->end_->type()->is_abstract()\n+\t  || !this->end_->numeric_constant_value(&nc)\n \t  || nc.to_unsigned_long(&v) == Numeric_constant::NC_UL_NOTINT))\n     this->report_error(_(\"slice end must be integer\"));\n \n@@ -13303,14 +13448,7 @@ Bexpression*\n String_index_expression::do_get_backend(Translate_context* context)\n {\n   Location loc = this->location();\n-  Expression* bad_index = Expression::check_bounds(this->start_, loc);\n-\n-  int code = (this->end_ == NULL\n-\t      ? RUNTIME_ERROR_STRING_INDEX_OUT_OF_BOUNDS\n-\t      : RUNTIME_ERROR_STRING_SLICE_OUT_OF_BOUNDS);\n-\n   Gogo* gogo = context->gogo();\n-  Bexpression* crash = gogo->runtime_error(code, loc)->get_backend(context);\n \n   Type* int_type = Type::lookup_integer_type(\"int\");\n \n@@ -13342,21 +13480,9 @@ String_index_expression::do_get_backend(Translate_context* context)\n \n   if (this->end_ == NULL)\n     {\n-      Expression* start_too_large =\n-          Expression::make_binary(OPERATOR_GE, start, length, loc);\n-      bad_index = Expression::make_binary(OPERATOR_OROR, start_too_large,\n-                                          bad_index, loc);\n-\n       ptr = gogo->backend()->pointer_offset_expression(ptr, bstart, loc);\n       Btype* ubtype = Type::lookup_integer_type(\"uint8\")->get_backend(gogo);\n-      Bexpression* index =\n-\tgogo->backend()->indirect_expression(ubtype, ptr, true, loc);\n-\n-      Btype* byte_btype = bytes->type()->points_to()->get_backend(gogo);\n-      Bexpression* index_error = bad_index->get_backend(context);\n-      return gogo->backend()->conditional_expression(bfn, byte_btype,\n-                                                     index_error, crash,\n-                                                     index, loc);\n+      return gogo->backend()->indirect_expression(ubtype, ptr, true, loc);\n     }\n \n   Expression* end = NULL;\n@@ -13365,20 +13491,8 @@ String_index_expression::do_get_backend(Translate_context* context)\n   else\n     {\n       go_assert(this->end_->is_variable());\n-      Expression* bounds_check = Expression::check_bounds(this->end_, loc);\n-      bad_index =\n-          Expression::make_binary(OPERATOR_OROR, bounds_check, bad_index, loc);\n       end = Expression::make_cast(int_type, this->end_, loc);\n-\n-      Expression* end_too_large =\n-        Expression::make_binary(OPERATOR_GT, end, length, loc);\n-      bad_index = Expression::make_binary(OPERATOR_OROR, end_too_large,\n-                                          bad_index, loc);\n     }\n-  Expression* start_too_large =\n-    Expression::make_binary(OPERATOR_GT, start->copy(), end->copy(), loc);\n-  bad_index = Expression::make_binary(OPERATOR_OROR, start_too_large,\n-                                      bad_index, loc);\n \n   end = end->copy();\n   Bexpression* bend = end->get_backend(context);\n@@ -13405,12 +13519,7 @@ String_index_expression::do_get_backend(Translate_context* context)\n   std::vector<Bexpression*> init;\n   init.push_back(ptr);\n   init.push_back(new_length);\n-  Bexpression* bstrslice =\n-    gogo->backend()->constructor_expression(str_btype, init, loc);\n-\n-  Bexpression* index_error = bad_index->get_backend(context);\n-  return gogo->backend()->conditional_expression(bfn, str_btype, index_error,\n-\t\t\t\t\t\t crash, bstrslice, loc);\n+  return gogo->backend()->constructor_expression(str_btype, init, loc);\n }\n \n // Export a string index expression."}, {"sha": "4c743daa8472eaf645e9d30d457c7465bc983d25", "filename": "gcc/go/gofrontend/expressions.h", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc4f90f0c8eca75fb90c736476360584f68d7ef9/gcc%2Fgo%2Fgofrontend%2Fexpressions.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc4f90f0c8eca75fb90c736476360584f68d7ef9/gcc%2Fgo%2Fgofrontend%2Fexpressions.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.h?ref=fc4f90f0c8eca75fb90c736476360584f68d7ef9", "patch": "@@ -1059,10 +1059,11 @@ class Expression\n   static Expression*\n   import_expression(Import_expression*, Location);\n \n-  // Return an expression which checks that VAL, of arbitrary integer type,\n-  // is non-negative and is not more than the maximum integer value.\n-  static Expression*\n-  check_bounds(Expression* val, Location);\n+  // Insert bounds checks for an index expression.\n+  static void\n+  check_bounds(Expression* val, Operator, Expression* bound, Runtime::Function,\n+\t       Runtime::Function, Runtime::Function, Runtime::Function,\n+\t       Statement_inserter*, Location);\n \n   // Return an expression for constructing a direct interface type from a\n   // pointer.\n@@ -2998,7 +2999,7 @@ class Array_index_expression : public Expression\n \t\t\t Expression* end, Expression* cap, Location location)\n     : Expression(EXPRESSION_ARRAY_INDEX, location),\n       array_(array), start_(start), end_(end), cap_(cap), type_(NULL),\n-      is_lvalue_(false), needs_bounds_check_(true)\n+      is_lvalue_(false), needs_bounds_check_(true), is_flattened_(false)\n   { }\n \n   // Return the array.\n@@ -3121,6 +3122,8 @@ class Array_index_expression : public Expression\n   bool is_lvalue_;\n   // Whether bounds check is needed.\n   bool needs_bounds_check_;\n+  // Whether this has already been flattened.\n+  bool is_flattened_;\n };\n \n // A string index.  This is used for both indexing and slicing.\n@@ -3131,7 +3134,7 @@ class String_index_expression : public Expression\n   String_index_expression(Expression* string, Expression* start,\n \t\t\t  Expression* end, Location location)\n     : Expression(EXPRESSION_STRING_INDEX, location),\n-      string_(string), start_(start), end_(end)\n+      string_(string), start_(start), end_(end), is_flattened_(false)\n   { }\n \n   // Return the string being indexed.\n@@ -3203,6 +3206,8 @@ class String_index_expression : public Expression\n   // The end index of a slice.  This may be NULL for a single index,\n   // or it may be a nil expression for the length of the string.\n   Expression* end_;\n+  // Whether this has already been flattened.\n+  bool is_flattened_;\n };\n \n // An index into a map."}, {"sha": "7aec0cf1be5292237ae4c068432bc46151559d03", "filename": "gcc/go/gofrontend/gogo.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc4f90f0c8eca75fb90c736476360584f68d7ef9/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc4f90f0c8eca75fb90c736476360584f68d7ef9/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.cc?ref=fc4f90f0c8eca75fb90c736476360584f68d7ef9", "patch": "@@ -6300,6 +6300,7 @@ Function_declaration::get_or_make_decl(Gogo* gogo, Named_object* no)\n \t    }\n \n \t  if (this->asm_name_ == \"runtime.gopanic\"\n+\t      || this->asm_name_.compare(0, 15, \"runtime.goPanic\") == 0\n \t      || this->asm_name_ == \"__go_runtime_error\"\n               || this->asm_name_ == \"runtime.panicdottype\"\n               || this->asm_name_ == \"runtime.block\")"}, {"sha": "3cc5ded3617641ea0d8cb04c43e75e88678cb00f", "filename": "gcc/go/gofrontend/runtime.cc", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc4f90f0c8eca75fb90c736476360584f68d7ef9/gcc%2Fgo%2Fgofrontend%2Fruntime.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc4f90f0c8eca75fb90c736476360584f68d7ef9/gcc%2Fgo%2Fgofrontend%2Fruntime.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fruntime.cc?ref=fc4f90f0c8eca75fb90c736476360584f68d7ef9", "patch": "@@ -30,6 +30,8 @@ enum Runtime_function_type\n   RFT_BOOLPTR,\n   // Go type int, C type intgo.\n   RFT_INT,\n+  // Go type uint, C type uintgo.\n+  RFT_UINT,\n   // Go type uint8, C type uint8_t.\n   RFT_UINT8,\n   // Go type uint16, C type uint16_t.\n@@ -113,6 +115,10 @@ runtime_function_type(Runtime_function_type bft)\n \t  t = Type::lookup_integer_type(\"int\");\n \t  break;\n \n+\tcase RFT_UINT:\n+\t  t = Type::lookup_integer_type(\"uint\");\n+\t  break;\n+\n \tcase RFT_UINT8:\n \t  t = Type::lookup_integer_type(\"uint8\");\n \t  break;\n@@ -262,6 +268,7 @@ convert_to_runtime_function_type(Runtime_function_type bft, Expression* e,\n     case RFT_BOOL:\n     case RFT_BOOLPTR:\n     case RFT_INT:\n+    case RFT_UINT:\n     case RFT_UINT8:\n     case RFT_UINT16:\n     case RFT_INT32:"}, {"sha": "d7f5ee2140c386a9b1518006bce66b59e8d2ecd0", "filename": "gcc/go/gofrontend/runtime.def", "status": "modified", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc4f90f0c8eca75fb90c736476360584f68d7ef9/gcc%2Fgo%2Fgofrontend%2Fruntime.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc4f90f0c8eca75fb90c736476360584f68d7ef9/gcc%2Fgo%2Fgofrontend%2Fruntime.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fruntime.def?ref=fc4f90f0c8eca75fb90c736476360584f68d7ef9", "patch": "@@ -499,6 +499,75 @@ DEF_GO_RUNTIME(ATOMIC_OR_FETCH_1, \"__atomic_or_fetch_1\",\n                P3(POINTER, UINT8, INT32),\n                R1(UINT8))\n \n+// Panics reporting an index or slice out of bounds error.\n+DEF_GO_RUNTIME(PANIC_INDEX, \"runtime.goPanicIndex\",\n+\t       P2(INT, INT), R0())\n+DEF_GO_RUNTIME(PANIC_INDEX_U, \"runtime.goPanicIndexU\",\n+\t       P2(UINT, INT), R0())\n+DEF_GO_RUNTIME(PANIC_SLICE_ALEN, \"runtime.goPanicSliceAlen\",\n+\t       P2(INT, INT), R0())\n+DEF_GO_RUNTIME(PANIC_SLICE_ALEN_U, \"runtime.goPanicSliceAlenU\",\n+\t       P2(UINT, INT), R0())\n+DEF_GO_RUNTIME(PANIC_SLICE_ACAP, \"runtime.goPanicSliceAcap\",\n+\t       P2(INT, INT), R0())\n+DEF_GO_RUNTIME(PANIC_SLICE_ACAP_U, \"runtime.goPanicSliceAcapU\",\n+\t       P2(UINT, INT), R0())\n+DEF_GO_RUNTIME(PANIC_SLICE_B, \"runtime.goPanicSliceB\",\n+\t       P2(INT, INT), R0())\n+DEF_GO_RUNTIME(PANIC_SLICE_B_U, \"runtime.goPanicSliceBU\",\n+\t       P2(UINT, INT), R0())\n+DEF_GO_RUNTIME(PANIC_SLICE3_ALEN, \"runtime.goPanicSlice3Alen\",\n+\t       P2(INT, INT), R0())\n+DEF_GO_RUNTIME(PANIC_SLICE3_ALEN_U, \"runtime.goPanicSlice3AlenU\",\n+\t       P2(UINT, INT), R0())\n+DEF_GO_RUNTIME(PANIC_SLICE3_ACAP, \"runtime.goPanicSlice3Acap\",\n+\t       P2(INT, INT), R0())\n+DEF_GO_RUNTIME(PANIC_SLICE3_ACAP_U, \"runtime.goPanicSlice3AcapU\",\n+\t       P2(UINT, INT), R0())\n+DEF_GO_RUNTIME(PANIC_SLICE3_B, \"runtime.goPanicSlice3B\",\n+\t       P2(INT, INT), R0())\n+DEF_GO_RUNTIME(PANIC_SLICE3_B_U, \"runtime.goPanicSlice3BU\",\n+\t       P2(UINT, INT), R0())\n+DEF_GO_RUNTIME(PANIC_SLICE3_C, \"runtime.goPanicSlice3C\",\n+\t       P2(INT, INT), R0())\n+DEF_GO_RUNTIME(PANIC_SLICE3_C_U, \"runtime.goPanicSlice3CU\",\n+\t       P2(UINT, INT), R0())\n+\n+// Panics reporting an index or slice out of bounds error with a\n+// 64-bit index type.  These are only used by 32-bit targets.\n+DEF_GO_RUNTIME(PANIC_EXTEND_INDEX, \"runtime.goPanicExtendIndex\",\n+\t       P2(INT64, INT), R0())\n+DEF_GO_RUNTIME(PANIC_EXTEND_INDEX_U, \"runtime.goPanicExtendIndexU\",\n+\t       P2(UINT64, INT), R0())\n+DEF_GO_RUNTIME(PANIC_EXTEND_SLICE_ALEN, \"runtime.goPanicExtendSliceAlen\",\n+\t       P2(INT64, INT), R0())\n+DEF_GO_RUNTIME(PANIC_EXTEND_SLICE_ALEN_U, \"runtime.goPanicExtendSliceAlenU\",\n+\t       P2(UINT64, INT), R0())\n+DEF_GO_RUNTIME(PANIC_EXTEND_SLICE_ACAP, \"runtime.goPanicExtendSliceAcap\",\n+\t       P2(INT64, INT), R0())\n+DEF_GO_RUNTIME(PANIC_EXTEND_SLICE_ACAP_U, \"runtime.goPanicExtendSliceAcapU\",\n+\t       P2(UINT64, INT), R0())\n+DEF_GO_RUNTIME(PANIC_EXTEND_SLICE_B, \"runtime.goPanicExtendSliceB\",\n+\t       P2(INT64, INT), R0())\n+DEF_GO_RUNTIME(PANIC_EXTEND_SLICE_B_U, \"runtime.goPanicExtendSliceBU\",\n+\t       P2(UINT64, INT), R0())\n+DEF_GO_RUNTIME(PANIC_EXTEND_SLICE3_ALEN, \"runtime.goPanicExtendSlice3Alen\",\n+\t       P2(INT64, INT), R0())\n+DEF_GO_RUNTIME(PANIC_EXTEND_SLICE3_ALEN_U, \"runtime.goPanicExtendSlice3AlenU\",\n+\t       P2(UINT64, INT), R0())\n+DEF_GO_RUNTIME(PANIC_EXTEND_SLICE3_ACAP, \"runtime.goPanicExtendSlice3Acap\",\n+\t       P2(INT64, INT), R0())\n+DEF_GO_RUNTIME(PANIC_EXTEND_SLICE3_ACAP_U, \"runtime.goPanicExtendSlice3AcapU\",\n+\t       P2(UINT64, INT), R0())\n+DEF_GO_RUNTIME(PANIC_EXTEND_SLICE3_B, \"runtime.goPanicExtendSlice3B\",\n+\t       P2(INT64, INT), R0())\n+DEF_GO_RUNTIME(PANIC_EXTEND_SLICE3_B_U, \"runtime.goPanicExtendSlice3BU\",\n+\t       P2(UINT64, INT), R0())\n+DEF_GO_RUNTIME(PANIC_EXTEND_SLICE3_C, \"runtime.goPanicExtendSlice3C\",\n+\t       P2(INT64, INT), R0())\n+DEF_GO_RUNTIME(PANIC_EXTEND_SLICE3_C_U, \"runtime.goPanicExtendSlice3CU\",\n+\t       P2(UINT64, INT), R0())\n+\n // Remove helper macros.\n #undef ABFT6\n #undef ABFT2"}, {"sha": "0c7f631988457080bb42b17c263eca090736db21", "filename": "libgo/go/runtime/error.go", "status": "modified", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc4f90f0c8eca75fb90c736476360584f68d7ef9/libgo%2Fgo%2Fruntime%2Ferror.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc4f90f0c8eca75fb90c736476360584f68d7ef9/libgo%2Fgo%2Fruntime%2Ferror.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Ferror.go?ref=fc4f90f0c8eca75fb90c736476360584f68d7ef9", "patch": "@@ -79,6 +79,21 @@ func unquote(s string) string {\n \treturn string(r[:j])\n }\n \n+//go:nosplit\n+// itoa converts val to a decimal representation. The result is\n+// written somewhere within buf and the location of the result is returned.\n+// buf must be at least 20 bytes.\n+func itoa(buf []byte, val uint64) []byte {\n+\ti := len(buf) - 1\n+\tfor val >= 10 {\n+\t\tbuf[i] = byte(val%10 + '0')\n+\t\ti--\n+\t\tval /= 10\n+\t}\n+\tbuf[i] = byte(val + '0')\n+\treturn buf[i:]\n+}\n+\n // An errorString represents a runtime error described by a single string.\n type errorString string\n \n@@ -114,6 +129,99 @@ func (e plainError) Error() string {\n \treturn string(e)\n }\n \n+// An boundsError represents a an indexing or slicing operation gone wrong.\n+type boundsError struct {\n+\tx int64\n+\ty int\n+\t// Values in an index or slice expression can be signed or unsigned.\n+\t// That means we'd need 65 bits to encode all possible indexes, from -2^63 to 2^64-1.\n+\t// Instead, we keep track of whether x should be interpreted as signed or unsigned.\n+\t// y is known to be nonnegative and to fit in an int.\n+\tsigned bool\n+\tcode   boundsErrorCode\n+}\n+\n+type boundsErrorCode uint8\n+\n+const (\n+\tboundsIndex boundsErrorCode = iota // s[x], 0 <= x < len(s) failed\n+\n+\tboundsSliceAlen // s[?:x], 0 <= x <= len(s) failed\n+\tboundsSliceAcap // s[?:x], 0 <= x <= cap(s) failed\n+\tboundsSliceB    // s[x:y], 0 <= x <= y failed (but boundsSliceA didn't happen)\n+\n+\tboundsSlice3Alen // s[?:?:x], 0 <= x <= len(s) failed\n+\tboundsSlice3Acap // s[?:?:x], 0 <= x <= cap(s) failed\n+\tboundsSlice3B    // s[?:x:y], 0 <= x <= y failed (but boundsSlice3A didn't happen)\n+\tboundsSlice3C    // s[x:y:?], 0 <= x <= y failed (but boundsSlice3A/B didn't happen)\n+\n+\t// Note: in the above, len(s) and cap(s) are stored in y\n+)\n+\n+// boundsErrorFmts provide error text for various out-of-bounds panics.\n+// Note: if you change these strings, you should adjust the size of the buffer\n+// in boundsError.Error below as well.\n+var boundsErrorFmts = [...]string{\n+\tboundsIndex:      \"index out of range [%x] with length %y\",\n+\tboundsSliceAlen:  \"slice bounds out of range [:%x] with length %y\",\n+\tboundsSliceAcap:  \"slice bounds out of range [:%x] with capacity %y\",\n+\tboundsSliceB:     \"slice bounds out of range [%x:%y]\",\n+\tboundsSlice3Alen: \"slice bounds out of range [::%x] with length %y\",\n+\tboundsSlice3Acap: \"slice bounds out of range [::%x] with capacity %y\",\n+\tboundsSlice3B:    \"slice bounds out of range [:%x:%y]\",\n+\tboundsSlice3C:    \"slice bounds out of range [%x:%y:]\",\n+}\n+\n+// boundsNegErrorFmts are overriding formats if x is negative. In this case there's no need to report y.\n+var boundsNegErrorFmts = [...]string{\n+\tboundsIndex:      \"index out of range [%x]\",\n+\tboundsSliceAlen:  \"slice bounds out of range [:%x]\",\n+\tboundsSliceAcap:  \"slice bounds out of range [:%x]\",\n+\tboundsSliceB:     \"slice bounds out of range [%x:]\",\n+\tboundsSlice3Alen: \"slice bounds out of range [::%x]\",\n+\tboundsSlice3Acap: \"slice bounds out of range [::%x]\",\n+\tboundsSlice3B:    \"slice bounds out of range [:%x:]\",\n+\tboundsSlice3C:    \"slice bounds out of range [%x::]\",\n+}\n+\n+func (e boundsError) RuntimeError() {}\n+\n+func appendIntStr(b []byte, v int64, signed bool) []byte {\n+\tif signed && v < 0 {\n+\t\tb = append(b, '-')\n+\t\tv = -v\n+\t}\n+\tvar buf [20]byte\n+\tb = append(b, itoa(buf[:], uint64(v))...)\n+\treturn b\n+}\n+\n+func (e boundsError) Error() string {\n+\tfmt := boundsErrorFmts[e.code]\n+\tif e.signed && e.x < 0 {\n+\t\tfmt = boundsNegErrorFmts[e.code]\n+\t}\n+\t// max message length is 99: \"runtime error: slice bounds out of range [::%x] with capacity %y\"\n+\t// x can be at most 20 characters. y can be at most 19.\n+\tb := make([]byte, 0, 100)\n+\tb = append(b, \"runtime error: \"...)\n+\tfor i := 0; i < len(fmt); i++ {\n+\t\tc := fmt[i]\n+\t\tif c != '%' {\n+\t\t\tb = append(b, c)\n+\t\t\tcontinue\n+\t\t}\n+\t\ti++\n+\t\tswitch fmt[i] {\n+\t\tcase 'x':\n+\t\t\tb = appendIntStr(b, e.x, e.signed)\n+\t\tcase 'y':\n+\t\t\tb = appendIntStr(b, int64(e.y), true)\n+\t\t}\n+\t}\n+\treturn string(b)\n+}\n+\n type stringer interface {\n \tString() string\n }"}, {"sha": "58684305ac0575b0213af068bd7187bd8e8b2c2e", "filename": "libgo/go/runtime/panic.go", "status": "modified", "additions": 139, "deletions": 31, "changes": 170, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc4f90f0c8eca75fb90c736476360584f68d7ef9/libgo%2Fgo%2Fruntime%2Fpanic.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc4f90f0c8eca75fb90c736476360584f68d7ef9/libgo%2Fgo%2Fruntime%2Fpanic.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fpanic.go?ref=fc4f90f0c8eca75fb90c736476360584f68d7ef9", "patch": "@@ -23,81 +23,189 @@ import (\n //go:linkname makefuncreturning runtime.makefuncreturning\n //go:linkname gorecover runtime.gorecover\n //go:linkname deferredrecover runtime.deferredrecover\n+//go:linkname goPanicIndex runtime.goPanicIndex\n+//go:linkname goPanicIndexU runtime.goPanicIndexU\n+//go:linkname goPanicSliceAlen runtime.goPanicSliceAlen\n+//go:linkname goPanicSliceAlenU runtime.goPanicSliceAlenU\n+//go:linkname goPanicSliceAcap runtime.goPanicSliceAcap\n+//go:linkname goPanicSliceAcapU runtime.goPanicSliceAcapU\n+//go:linkname goPanicSliceB runtime.goPanicSliceB\n+//go:linkname goPanicSliceBU runtime.goPanicSliceBU\n+//go:linkname goPanicSlice3Alen runtime.goPanicSlice3Alen\n+//go:linkname goPanicSlice3AlenU runtime.goPanicSlice3AlenU\n+//go:linkname goPanicSlice3Acap runtime.goPanicSlice3Acap\n+//go:linkname goPanicSlice3AcapU runtime.goPanicSlice3AcapU\n+//go:linkname goPanicSlice3B runtime.goPanicSlice3B\n+//go:linkname goPanicSlice3BU runtime.goPanicSlice3BU\n+//go:linkname goPanicSlice3C runtime.goPanicSlice3C\n+//go:linkname goPanicSlice3CU runtime.goPanicSlice3CU\n //go:linkname panicmem runtime.panicmem\n // Temporary for C code to call:\n //go:linkname throw runtime.throw\n \n-// Calling panic with one of the errors below will call errorString.Error\n-// which will call mallocgc to concatenate strings. That will fail if\n-// malloc is locked, causing a confusing error message. Throw a better\n-// error message instead.\n-func panicCheckMalloc(err error) {\n+// Check to make sure we can really generate a panic. If the panic\n+// was generated from the runtime, or from inside malloc, then convert\n+// to a throw of msg.\n+// pc should be the program counter of the compiler-generated code that\n+// triggered this panic.\n+func panicCheck1(pc uintptr, msg string) {\n+\tname, _, _, _ := funcfileline(pc-1, -1)\n+\tif hasPrefix(name, \"runtime.\") {\n+\t\tthrow(msg)\n+\t}\n+\t// TODO: is this redundant? How could we be in malloc\n+\t// but not in the runtime? runtime/internal/*, maybe?\n \tgp := getg()\n \tif gp != nil && gp.m != nil && gp.m.mallocing != 0 {\n-\t\tthrow(string(err.(errorString)))\n+\t\tthrow(msg)\n \t}\n }\n \n-var indexError = error(errorString(\"index out of range\"))\n+// Same as above, but calling from the runtime is allowed.\n+//\n+// Using this function is necessary for any panic that may be\n+// generated by runtime.sigpanic, since those are always called by the\n+// runtime.\n+func panicCheck2(err string) {\n+\t// panic allocates, so to avoid recursive malloc, turn panics\n+\t// during malloc into throws.\n+\tgp := getg()\n+\tif gp != nil && gp.m != nil && gp.m.mallocing != 0 {\n+\t\tthrow(err)\n+\t}\n+}\n \n-// The panicindex, panicslice, and panicdivide functions are called by\n+// Many of the following panic entry-points turn into throws when they\n+// happen in various runtime contexts. These should never happen in\n+// the runtime, and if they do, they indicate a serious issue and\n+// should not be caught by user code.\n+//\n+// The panic{Index,Slice,divide,shift} functions are called by\n // code generated by the compiler for out of bounds index expressions,\n-// out of bounds slice expressions, and division by zero. The\n-// panicdivide (again), panicoverflow, panicfloat, and panicmem\n+// out of bounds slice expressions, division by zero, and shift by negative.\n+// The panicdivide (again), panicoverflow, panicfloat, and panicmem\n // functions are called by the signal handler when a signal occurs\n // indicating the respective problem.\n //\n-// Since panicindex and panicslice are never called directly, and\n+// Since panic{Index,Slice,shift} are never called directly, and\n // since the runtime package should never have an out of bounds slice\n-// or array reference, if we see those functions called from the\n+// or array reference or negative shift, if we see those functions called from the\n // runtime package we turn the panic into a throw. That will dump the\n // entire runtime stack for easier debugging.\n+//\n+// The entry points called by the signal handler will be called from\n+// runtime.sigpanic, so we can't disallow calls from the runtime to\n+// these (they always look like they're called from the runtime).\n+// Hence, for these, we just check for clearly bad runtime conditions.\n+\n+// failures in the comparisons for s[x], 0 <= x < y (y == len(s))\n+func goPanicIndex(x int, y int) {\n+\tpanicCheck1(getcallerpc(), \"index out of range\")\n+\tpanic(boundsError{x: int64(x), signed: true, y: y, code: boundsIndex})\n+}\n+func goPanicIndexU(x uint, y int) {\n+\tpanicCheck1(getcallerpc(), \"index out of range\")\n+\tpanic(boundsError{x: int64(x), signed: false, y: y, code: boundsIndex})\n+}\n \n-func panicindex() {\n-\tname, _, _, _ := funcfileline(getcallerpc()-1, -1)\n-\tif hasPrefix(name, \"runtime.\") {\n-\t\tthrow(string(indexError.(errorString)))\n-\t}\n-\tpanicCheckMalloc(indexError)\n-\tpanic(indexError)\n+// failures in the comparisons for s[:x], 0 <= x <= y (y == len(s) or cap(s))\n+func goPanicSliceAlen(x int, y int) {\n+\tpanicCheck1(getcallerpc(), \"slice bounds out of range\")\n+\tpanic(boundsError{x: int64(x), signed: true, y: y, code: boundsSliceAlen})\n+}\n+func goPanicSliceAlenU(x uint, y int) {\n+\tpanicCheck1(getcallerpc(), \"slice bounds out of range\")\n+\tpanic(boundsError{x: int64(x), signed: false, y: y, code: boundsSliceAlen})\n+}\n+func goPanicSliceAcap(x int, y int) {\n+\tpanicCheck1(getcallerpc(), \"slice bounds out of range\")\n+\tpanic(boundsError{x: int64(x), signed: true, y: y, code: boundsSliceAcap})\n+}\n+func goPanicSliceAcapU(x uint, y int) {\n+\tpanicCheck1(getcallerpc(), \"slice bounds out of range\")\n+\tpanic(boundsError{x: int64(x), signed: false, y: y, code: boundsSliceAcap})\n }\n \n-var sliceError = error(errorString(\"slice bounds out of range\"))\n+// failures in the comparisons for s[x:y], 0 <= x <= y\n+func goPanicSliceB(x int, y int) {\n+\tpanicCheck1(getcallerpc(), \"slice bounds out of range\")\n+\tpanic(boundsError{x: int64(x), signed: true, y: y, code: boundsSliceB})\n+}\n+func goPanicSliceBU(x uint, y int) {\n+\tpanicCheck1(getcallerpc(), \"slice bounds out of range\")\n+\tpanic(boundsError{x: int64(x), signed: false, y: y, code: boundsSliceB})\n+}\n \n-func panicslice() {\n-\tname, _, _, _ := funcfileline(getcallerpc()-1, -1)\n-\tif hasPrefix(name, \"runtime.\") {\n-\t\tthrow(string(sliceError.(errorString)))\n-\t}\n-\tpanicCheckMalloc(sliceError)\n-\tpanic(sliceError)\n+// failures in the comparisons for s[::x], 0 <= x <= y (y == len(s) or cap(s))\n+func goPanicSlice3Alen(x int, y int) {\n+\tpanicCheck1(getcallerpc(), \"slice bounds out of range\")\n+\tpanic(boundsError{x: int64(x), signed: true, y: y, code: boundsSlice3Alen})\n+}\n+func goPanicSlice3AlenU(x uint, y int) {\n+\tpanicCheck1(getcallerpc(), \"slice bounds out of range\")\n+\tpanic(boundsError{x: int64(x), signed: false, y: y, code: boundsSlice3Alen})\n+}\n+func goPanicSlice3Acap(x int, y int) {\n+\tpanicCheck1(getcallerpc(), \"slice bounds out of range\")\n+\tpanic(boundsError{x: int64(x), signed: true, y: y, code: boundsSlice3Acap})\n+}\n+func goPanicSlice3AcapU(x uint, y int) {\n+\tpanicCheck1(getcallerpc(), \"slice bounds out of range\")\n+\tpanic(boundsError{x: int64(x), signed: false, y: y, code: boundsSlice3Acap})\n+}\n+\n+// failures in the comparisons for s[:x:y], 0 <= x <= y\n+func goPanicSlice3B(x int, y int) {\n+\tpanicCheck1(getcallerpc(), \"slice bounds out of range\")\n+\tpanic(boundsError{x: int64(x), signed: true, y: y, code: boundsSlice3B})\n+}\n+func goPanicSlice3BU(x uint, y int) {\n+\tpanicCheck1(getcallerpc(), \"slice bounds out of range\")\n+\tpanic(boundsError{x: int64(x), signed: false, y: y, code: boundsSlice3B})\n+}\n+\n+// failures in the comparisons for s[x:y:], 0 <= x <= y\n+func goPanicSlice3C(x int, y int) {\n+\tpanicCheck1(getcallerpc(), \"slice bounds out of range\")\n+\tpanic(boundsError{x: int64(x), signed: true, y: y, code: boundsSlice3C})\n+}\n+func goPanicSlice3CU(x uint, y int) {\n+\tpanicCheck1(getcallerpc(), \"slice bounds out of range\")\n+\tpanic(boundsError{x: int64(x), signed: false, y: y, code: boundsSlice3C})\n+}\n+\n+var shiftError = error(errorString(\"negative shift amount\"))\n+\n+func panicshift() {\n+\tpanicCheck1(getcallerpc(), \"negative shift amount\")\n+\tpanic(shiftError)\n }\n \n var divideError = error(errorString(\"integer divide by zero\"))\n \n func panicdivide() {\n-\tpanicCheckMalloc(divideError)\n+\tpanicCheck2(\"integer divide by zero\")\n \tpanic(divideError)\n }\n \n var overflowError = error(errorString(\"integer overflow\"))\n \n func panicoverflow() {\n-\tpanicCheckMalloc(overflowError)\n+\tpanicCheck2(\"integer overflow\")\n \tpanic(overflowError)\n }\n \n var floatError = error(errorString(\"floating point error\"))\n \n func panicfloat() {\n-\tpanicCheckMalloc(floatError)\n+\tpanicCheck2(\"floating point error\")\n \tpanic(floatError)\n }\n \n var memoryError = error(errorString(\"invalid memory address or nil pointer dereference\"))\n \n func panicmem() {\n-\tpanicCheckMalloc(memoryError)\n+\tpanicCheck2(\"invalid memory address or nil pointer dereference\")\n \tpanic(memoryError)\n }\n "}, {"sha": "f68d4c71b0b972404bb4f480136cdb463daeab75", "filename": "libgo/go/runtime/panic32.go", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc4f90f0c8eca75fb90c736476360584f68d7ef9/libgo%2Fgo%2Fruntime%2Fpanic32.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc4f90f0c8eca75fb90c736476360584f68d7ef9/libgo%2Fgo%2Fruntime%2Fpanic32.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fpanic32.go?ref=fc4f90f0c8eca75fb90c736476360584f68d7ef9", "patch": "@@ -0,0 +1,108 @@\n+// Copyright 2019 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build 386 amd64p32 arm mips mipsle m68k nios2 sh shbe\n+\n+package runtime\n+\n+import _ \"unsafe\" // for go:linkname\n+\n+// For gccgo, use go:linkname to rename compiler-called functions to\n+// themselves, so that the compiler will export them.\n+//\n+//go:linkname goPanicExtendIndex runtime.goPanicExtendIndex\n+//go:linkname goPanicExtendIndexU runtime.goPanicExtendIndexU\n+//go:linkname goPanicExtendSliceAlen runtime.goPanicExtendSliceAlen\n+//go:linkname goPanicExtendSliceAlenU runtime.goPanicExtendSliceAlenU\n+//go:linkname goPanicExtendSliceAcap runtime.goPanicExtendSliceAcap\n+//go:linkname goPanicExtendSliceAcapU runtime.goPanicExtendSliceAcapU\n+//go:linkname goPanicExtendSliceB runtime.goPanicExtendSliceB\n+//go:linkname goPanicExtendSliceBU runtime.goPanicExtendSliceBU\n+//go:linkname goPanicExtendSlice3Alen runtime.goPanicExtendSlice3Alen\n+//go:linkname goPanicExtendSlice3AlenU runtime.goPanicExtendSlice3AlenU\n+//go:linkname goPanicExtendSlice3Acap runtime.goPanicExtendSlice3Acap\n+//go:linkname goPanicExtendSlice3AcapU runtime.goPanicExtendSlice3AcapU\n+//go:linkname goPanicExtendSlice3B runtime.goPanicExtendSlice3B\n+//go:linkname goPanicExtendSlice3BU runtime.goPanicExtendSlice3BU\n+//go:linkname goPanicExtendSlice3C runtime.goPanicExtendSlice3C\n+//go:linkname goPanicExtendSlice3CU runtime.goPanicExtendSlice3CU\n+\n+// Additional index/slice error paths for 32-bit platforms.\n+// Used when the high word of a 64-bit index is not zero.\n+\n+// failures in the comparisons for s[x], 0 <= x < y (y == len(s))\n+func goPanicExtendIndex(x int64, y int) {\n+\tpanicCheck1(getcallerpc(), \"index out of range\")\n+\tpanic(boundsError{x: x, signed: true, y: y, code: boundsIndex})\n+}\n+func goPanicExtendIndexU(x uint64, y int) {\n+\tpanicCheck1(getcallerpc(), \"index out of range\")\n+\tpanic(boundsError{x: int64(x), signed: false, y: y, code: boundsIndex})\n+}\n+\n+// failures in the comparisons for s[:x], 0 <= x <= y (y == len(s) or cap(s))\n+func goPanicExtendSliceAlen(x int64, y int) {\n+\tpanicCheck1(getcallerpc(), \"slice bounds out of range\")\n+\tpanic(boundsError{x: x, signed: true, y: y, code: boundsSliceAlen})\n+}\n+func goPanicExtendSliceAlenU(x uint64, y int) {\n+\tpanicCheck1(getcallerpc(), \"slice bounds out of range\")\n+\tpanic(boundsError{x: int64(x), signed: false, y: y, code: boundsSliceAlen})\n+}\n+func goPanicExtendSliceAcap(x int64, y int) {\n+\tpanicCheck1(getcallerpc(), \"slice bounds out of range\")\n+\tpanic(boundsError{x: x, signed: true, y: y, code: boundsSliceAcap})\n+}\n+func goPanicExtendSliceAcapU(x uint64, y int) {\n+\tpanicCheck1(getcallerpc(), \"slice bounds out of range\")\n+\tpanic(boundsError{x: int64(x), signed: false, y: y, code: boundsSliceAcap})\n+}\n+\n+// failures in the comparisons for s[x:y], 0 <= x <= y\n+func goPanicExtendSliceB(x int64, y int) {\n+\tpanicCheck1(getcallerpc(), \"slice bounds out of range\")\n+\tpanic(boundsError{x: x, signed: true, y: y, code: boundsSliceB})\n+}\n+func goPanicExtendSliceBU(x uint64, y int) {\n+\tpanicCheck1(getcallerpc(), \"slice bounds out of range\")\n+\tpanic(boundsError{x: int64(x), signed: false, y: y, code: boundsSliceB})\n+}\n+\n+// failures in the comparisons for s[::x], 0 <= x <= y (y == len(s) or cap(s))\n+func goPanicExtendSlice3Alen(x int64, y int) {\n+\tpanicCheck1(getcallerpc(), \"slice bounds out of range\")\n+\tpanic(boundsError{x: x, signed: true, y: y, code: boundsSlice3Alen})\n+}\n+func goPanicExtendSlice3AlenU(x uint64, y int) {\n+\tpanicCheck1(getcallerpc(), \"slice bounds out of range\")\n+\tpanic(boundsError{x: int64(x), signed: false, y: y, code: boundsSlice3Alen})\n+}\n+func goPanicExtendSlice3Acap(x int64, y int) {\n+\tpanicCheck1(getcallerpc(), \"slice bounds out of range\")\n+\tpanic(boundsError{x: x, signed: true, y: y, code: boundsSlice3Acap})\n+}\n+func goPanicExtendSlice3AcapU(x uint64, y int) {\n+\tpanicCheck1(getcallerpc(), \"slice bounds out of range\")\n+\tpanic(boundsError{x: int64(x), signed: false, y: y, code: boundsSlice3Acap})\n+}\n+\n+// failures in the comparisons for s[:x:y], 0 <= x <= y\n+func goPanicExtendSlice3B(x int64, y int) {\n+\tpanicCheck1(getcallerpc(), \"slice bounds out of range\")\n+\tpanic(boundsError{x: x, signed: true, y: y, code: boundsSlice3B})\n+}\n+func goPanicExtendSlice3BU(x uint64, y int) {\n+\tpanicCheck1(getcallerpc(), \"slice bounds out of range\")\n+\tpanic(boundsError{x: int64(x), signed: false, y: y, code: boundsSlice3B})\n+}\n+\n+// failures in the comparisons for s[x:y:], 0 <= x <= y\n+func goPanicExtendSlice3C(x int64, y int) {\n+\tpanicCheck1(getcallerpc(), \"slice bounds out of range\")\n+\tpanic(boundsError{x: x, signed: true, y: y, code: boundsSlice3C})\n+}\n+func goPanicExtendSlice3CU(x uint64, y int) {\n+\tpanicCheck1(getcallerpc(), \"slice bounds out of range\")\n+\tpanic(boundsError{x: int64(x), signed: false, y: y, code: boundsSlice3C})\n+}"}, {"sha": "d29da9b6846b886b670162f6d6aabccad4984ede", "filename": "libgo/mkruntimeinc.sh", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc4f90f0c8eca75fb90c736476360584f68d7ef9/libgo%2Fmkruntimeinc.sh", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc4f90f0c8eca75fb90c736476360584f68d7ef9/libgo%2Fmkruntimeinc.sh", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmkruntimeinc.sh?ref=fc4f90f0c8eca75fb90c736476360584f68d7ef9", "patch": "@@ -15,14 +15,15 @@ rm -f runtime.inc.tmp2 runtime.inc.tmp3\n # types and should not be exported back to C\n # semt is a Go translation of the C type sem_t; it fails to convert on\n # some systems and need not be exported back to C.\n-# sigset conflicts with system type sigset on AIX, so we need to rename it\n+# sigset conflicts with system type sigset on AIX, so we need to rename it.\n+# boundsError has a field name that is a C keyword, and we don't need it.\n \n grep -v \"#define _\" ${IN} | grep -v \"#define [cm][01234] \" | grep -v \"#define empty \" | grep -v \"#define \\\\$\" > runtime.inc.tmp2\n for pattern in '_[GP][a-z]' _Max _Lock _Sig _Trace _MHeap _Num\n do\n   grep \"#define $pattern\" ${IN} >> runtime.inc.tmp2\n done\n-TYPES=\"_Complex_lock _Reader_lock semt\"\n+TYPES=\"_Complex_lock _Reader_lock semt boundsError\"\n for TYPE in $TYPES\n do\n   sed -e '/struct '${TYPE}' {/,/^}/s/^.*$//' runtime.inc.tmp2 > runtime.inc.tmp3;"}]}