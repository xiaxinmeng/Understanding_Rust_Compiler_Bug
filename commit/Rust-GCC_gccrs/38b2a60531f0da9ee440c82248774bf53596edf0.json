{"sha": "38b2a60531f0da9ee440c82248774bf53596edf0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzhiMmE2MDUzMWYwZGE5ZWU0NDBjODIyNDg3NzRiZjUzNTk2ZWRmMA==", "commit": {"author": {"name": "Richard Earnshaw", "email": "rearnsha@arm.com", "date": "2003-10-17T10:30:43Z"}, "committer": {"name": "Richard Earnshaw", "email": "rearnsha@gcc.gnu.org", "date": "2003-10-17T10:30:43Z"}, "message": "flow.c (init_propagate_block_info): Don't abort if a conditional jump is not a comparison of a register.\n\n* flow.c (init_propagate_block_info): Don't abort if a conditional\njump is not a comparison of a register.  Instead, just don't record\nconditional life information.\n\nFrom-SVN: r72594", "tree": {"sha": "928bee86d93980327cae8586d6a0f0b03207bc6e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/928bee86d93980327cae8586d6a0f0b03207bc6e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/38b2a60531f0da9ee440c82248774bf53596edf0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/38b2a60531f0da9ee440c82248774bf53596edf0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/38b2a60531f0da9ee440c82248774bf53596edf0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/38b2a60531f0da9ee440c82248774bf53596edf0/comments", "author": null, "committer": null, "parents": [{"sha": "b8fa9ea13306d2289541c6c1765d787b96d0451b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b8fa9ea13306d2289541c6c1765d787b96d0451b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b8fa9ea13306d2289541c6c1765d787b96d0451b"}], "stats": {"total": 85, "additions": 48, "deletions": 37}, "files": [{"sha": "9882de6a5a86d37a8ab1cc2d3cb87611fa10b29d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38b2a60531f0da9ee440c82248774bf53596edf0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38b2a60531f0da9ee440c82248774bf53596edf0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=38b2a60531f0da9ee440c82248774bf53596edf0", "patch": "@@ -1,3 +1,9 @@\n+2003-10-17  Richard Earnshaw  <rearnsha@arm.com>\n+\n+\t* flow.c (init_propagate_block_info): Don't abort if a conditional\n+\tjump is not a comparison of a register.  Instead, just don't record\n+\tconditional life information.\n+\n 2003-10-16  Jan Hubicka  <jh@suse.cz>\n \n \tPR optimization/12630"}, {"sha": "2694a0b07e0ae297ac791742ef51ee9cc6e00463", "filename": "gcc/flow.c", "status": "modified", "additions": 42, "deletions": 37, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38b2a60531f0da9ee440c82248774bf53596edf0/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38b2a60531f0da9ee440c82248774bf53596edf0/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=38b2a60531f0da9ee440c82248774bf53596edf0", "patch": "@@ -1861,16 +1861,15 @@ init_propagate_block_info (basic_block bb, regset live, regset local_set,\n \t\t\t\t       free_reg_cond_life_info);\n   pbi->reg_cond_reg = BITMAP_XMALLOC ();\n \n-  /* If this block ends in a conditional branch, for each register live\n-     from one side of the branch and not the other, record the register\n-     as conditionally dead.  */\n+  /* If this block ends in a conditional branch, for each register\n+     live from one side of the branch and not the other, record the\n+     register as conditionally dead.  */\n   if (GET_CODE (bb->end) == JUMP_INSN\n       && any_condjump_p (bb->end))\n     {\n       regset_head diff_head;\n       regset diff = INITIALIZE_REG_SET (diff_head);\n       basic_block bb_true, bb_false;\n-      rtx cond_true, cond_false, set_src;\n       int i;\n \n       /* Identify the successor blocks.  */\n@@ -1898,53 +1897,59 @@ init_propagate_block_info (basic_block bb, regset live, regset local_set,\n \t  bb_false = bb_true;\n \t}\n \n-      /* Extract the condition from the branch.  */\n-      set_src = SET_SRC (pc_set (bb->end));\n-      cond_true = XEXP (set_src, 0);\n-      cond_false = gen_rtx_fmt_ee (reverse_condition (GET_CODE (cond_true)),\n-\t\t\t\t   GET_MODE (cond_true), XEXP (cond_true, 0),\n-\t\t\t\t   XEXP (cond_true, 1));\n-      if (GET_CODE (XEXP (set_src, 1)) == PC)\n-\t{\n-\t  rtx t = cond_false;\n-\t  cond_false = cond_true;\n-\t  cond_true = t;\n-\t}\n-\n       /* Compute which register lead different lives in the successors.  */\n       if (bitmap_operation (diff, bb_true->global_live_at_start,\n \t\t\t    bb_false->global_live_at_start, BITMAP_XOR))\n \t{\n+\t  /* Extract the condition from the branch.  */\n+\t  rtx set_src = SET_SRC (pc_set (bb->end));\n+\t  rtx cond_true = XEXP (set_src, 0);\n \t  rtx reg = XEXP (cond_true, 0);\n \n \t  if (GET_CODE (reg) == SUBREG)\n \t    reg = SUBREG_REG (reg);\n \n-\t  if (GET_CODE (reg) != REG)\n-\t    abort ();\n+\t  /* We can only track conditional lifetimes if the condition is\n+\t     in the form of a comparison of a register against zero.  \n+\t     If the condition is more complex than that, then it is safe\n+\t     not to record any information.  */\n+\t  if (GET_CODE (reg) == REG\n+\t      && XEXP (cond_true, 1) == const0_rtx)\n+\t    {\n+\t      rtx cond_false\n+\t\t= gen_rtx_fmt_ee (reverse_condition (GET_CODE (cond_true)),\n+\t\t\t\t  GET_MODE (cond_true), XEXP (cond_true, 0),\n+\t\t\t\t  XEXP (cond_true, 1));\n+\t      if (GET_CODE (XEXP (set_src, 1)) == PC)\n+\t\t{\n+\t\t  rtx t = cond_false;\n+\t\t  cond_false = cond_true;\n+\t\t  cond_true = t;\n+\t\t}\n \n-\t  SET_REGNO_REG_SET (pbi->reg_cond_reg, REGNO (reg));\n+\t      SET_REGNO_REG_SET (pbi->reg_cond_reg, REGNO (reg));\n \n-\t  /* For each such register, mark it conditionally dead.  */\n-\t  EXECUTE_IF_SET_IN_REG_SET\n-\t    (diff, 0, i,\n-\t     {\n-\t       struct reg_cond_life_info *rcli;\n-\t       rtx cond;\n+\t      /* For each such register, mark it conditionally dead.  */\n+\t      EXECUTE_IF_SET_IN_REG_SET\n+\t\t(diff, 0, i,\n+\t\t {\n+\t\t   struct reg_cond_life_info *rcli;\n+\t\t   rtx cond;\n \n-\t       rcli = xmalloc (sizeof (*rcli));\n+\t\t   rcli = xmalloc (sizeof (*rcli));\n \n-\t       if (REGNO_REG_SET_P (bb_true->global_live_at_start, i))\n-\t\t cond = cond_false;\n-\t       else\n-\t\t cond = cond_true;\n-\t       rcli->condition = cond;\n-\t       rcli->stores = const0_rtx;\n-\t       rcli->orig_condition = cond;\n+\t\t   if (REGNO_REG_SET_P (bb_true->global_live_at_start, i))\n+\t\t     cond = cond_false;\n+\t\t   else\n+\t\t     cond = cond_true;\n+\t\t   rcli->condition = cond;\n+\t\t   rcli->stores = const0_rtx;\n+\t\t   rcli->orig_condition = cond;\n \n-\t       splay_tree_insert (pbi->reg_cond_dead, i,\n-\t\t\t\t  (splay_tree_value) rcli);\n-\t     });\n+\t\t   splay_tree_insert (pbi->reg_cond_dead, i,\n+\t\t\t\t      (splay_tree_value) rcli);\n+\t\t });\n+\t    }\n \t}\n \n       FREE_REG_SET (diff);"}]}