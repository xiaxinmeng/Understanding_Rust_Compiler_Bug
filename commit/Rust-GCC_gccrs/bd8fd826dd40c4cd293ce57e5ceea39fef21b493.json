{"sha": "bd8fd826dd40c4cd293ce57e5ceea39fef21b493", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmQ4ZmQ4MjZkZDQwYzRjZDI5M2NlNTdlNWNlZWEzOWZlZjIxYjQ5Mw==", "commit": {"author": {"name": "Loren J. Rittle", "email": "ljrittle@acm.org", "date": "2001-12-03T19:11:01Z"}, "committer": {"name": "Loren J. Rittle", "email": "ljrittle@gcc.gnu.org", "date": "2001-12-03T19:11:01Z"}, "message": "howto.html: Update commentary.\n\n\t* docs/html/ext/howto.html: Update commentary.\n\t* include/bits/c++config: Update threading configuration comment.\n\t(__STL_GTHREADS): Remove macro definition.\n\t(__STL_THREADS): Likewise.\n\t* include/bits/stl_threads.h: Leave only the configuration\n\tpath which had been guarded by __STL_GTHREADS.  Remove all\n\tguards related to __STL_GTHREADS, __STL_SGI_THREADS,\n\t__STL_PTHREADS, __STL_UITHREADS and __STL_WIN32THREADS.\n\t* include/bits/stl_alloc.h: Leave only the configuration path\n\twhich had been guarded by __STL_THREADS.  Remove configuration\n\tpath and guards for __STL_SGI_THREADS.\n\t(__NODE_ALLOCATOR_THREADS): Remove macro definition.  Unroll its use.\n\t(__NODE_ALLOCATOR_LOCK): Likewise.\n\t(__NODE_ALLOCATOR_UNLOCK): Likewise.\n\t(_NOTHREADS): Remove guards related to macro.\n\t* include/ext/stl_rope.h: Remove configuration path and guards\n\tfor __STL_SGI_THREADS.\n\t* src/stl-inst.cc: Remove use of __NODE_ALLOCATOR_THREADS.\n\nFrom-SVN: r47557", "tree": {"sha": "4db4015f12256f5fd41585709c2280c6502549b7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4db4015f12256f5fd41585709c2280c6502549b7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bd8fd826dd40c4cd293ce57e5ceea39fef21b493", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd8fd826dd40c4cd293ce57e5ceea39fef21b493", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bd8fd826dd40c4cd293ce57e5ceea39fef21b493", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd8fd826dd40c4cd293ce57e5ceea39fef21b493/comments", "author": null, "committer": null, "parents": [{"sha": "13f08f0368c33c9379540e9a1ca82f3570c86ff3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/13f08f0368c33c9379540e9a1ca82f3570c86ff3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/13f08f0368c33c9379540e9a1ca82f3570c86ff3"}], "stats": {"total": 452, "additions": 42, "deletions": 410}, "files": [{"sha": "71f422d27306ea671548be0fa2898b97a82ae185", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd8fd826dd40c4cd293ce57e5ceea39fef21b493/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd8fd826dd40c4cd293ce57e5ceea39fef21b493/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=bd8fd826dd40c4cd293ce57e5ceea39fef21b493", "patch": "@@ -1,3 +1,24 @@\n+2001-12-03  Loren J. Rittle  <ljrittle@acm.org>\n+\n+\t* docs/html/ext/howto.html: Update commentary.\n+\t* include/bits/c++config: Update threading configuration comment.\n+\t(__STL_GTHREADS): Remove macro definition.\n+\t(__STL_THREADS): Likewise.\n+\t* include/bits/stl_threads.h: Leave only the configuration\n+\tpath which had been guarded by __STL_GTHREADS.  Remove all\n+\tguards related to __STL_GTHREADS, __STL_SGI_THREADS,\n+\t__STL_PTHREADS, __STL_UITHREADS and __STL_WIN32THREADS.\n+\t* include/bits/stl_alloc.h: Leave only the configuration path\n+\twhich had been guarded by __STL_THREADS.  Remove configuration\n+\tpath and guards for __STL_SGI_THREADS.\n+\t(__NODE_ALLOCATOR_THREADS): Remove macro definition.  Unroll its use.\n+\t(__NODE_ALLOCATOR_LOCK): Likewise.\n+\t(__NODE_ALLOCATOR_UNLOCK): Likewise.\n+\t(_NOTHREADS): Remove guards related to macro.\n+\t* include/ext/stl_rope.h: Remove configuration path and guards\n+\tfor __STL_SGI_THREADS.\n+\t* src/stl-inst.cc: Remove use of __NODE_ALLOCATOR_THREADS.\n+\n 2001-12-02  Phil Edwards  <pme@gcc.gnu.org>\n \n \t* docs/html/ext/howto.html:  Update list of implemented DRs."}, {"sha": "85bba7115cdccf2d287cad9e191cc7eb071dbab4", "filename": "libstdc++-v3/docs/html/ext/howto.html", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd8fd826dd40c4cd293ce57e5ceea39fef21b493/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2Fext%2Fhowto.html", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd8fd826dd40c4cd293ce57e5ceea39fef21b493/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2Fext%2Fhowto.html", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2Fext%2Fhowto.html?ref=bd8fd826dd40c4cd293ce57e5ceea39fef21b493", "patch": "@@ -344,7 +344,8 @@ <h3>3.0.x</h3>\n       than you would depend on implementation-only names.\n    </p>\n    <p>Certain macros like <code>_NOTHREADS</code> and <code>__STL_THREADS</code>\n-      can affect the 3.0.x allocators.  Do not use them.\n+      can affect the 3.0.x allocators.  Do not use them.  Those macros have\n+      been completely removed for 3.1.\n    </p>\n    <p>More notes as we remember them...\n    </p>"}, {"sha": "a04c118ced6fa43a19c70778b20ab942819dfaa5", "filename": "libstdc++-v3/include/bits/c++config", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd8fd826dd40c4cd293ce57e5ceea39fef21b493/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fc%2B%2Bconfig", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd8fd826dd40c4cd293ce57e5ceea39fef21b493/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fc%2B%2Bconfig", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fc%2B%2Bconfig?ref=bd8fd826dd40c4cd293ce57e5ceea39fef21b493", "patch": "@@ -55,16 +55,12 @@\n // Use corrected code from the committee library group's issues list.\n #define _GLIBCPP_RESOLVE_LIB_DEFECTS 1\n \n-// Map gthr.h abstraction to that required for STL.  Do not key off of\n-// __GTHREADS at this point since we haven't seen the correct symbol\n-// yet, instead setup so that include/bits/stl_threads.h will know to\n-// include gthr.h instead of any other type of thread support.  Note:\n-// that gthr.h may well map to gthr-single.h which is a correct way to\n-// express no threads support in gcc.  As a user, do not define\n-// _NOTHREADS without consideration of the consequences (e.g. it is an\n-// internal ABI change).\n-#define __STL_GTHREADS\n-#define __STL_THREADS\n+// In those parts of the standard C++ library that use a mutex instead\n+// of a spin-lock, we now unconditionally use GCC's gthr.h mutex\n+// abstraction layer.  All support to directly map to various\n+// threading models has been removed.  Note: gthr.h may well map to\n+// gthr-single.h which is a correct way to express no threads support\n+// in gcc.  Support for the undocumented _NOTHREADS has been removed.\n \n // Default to the typically high-speed, pool-based allocator (as\n // libstdc++-v2) instead of the malloc-based allocator (libstdc++-v3"}, {"sha": "e14edca13e0293902d73c97773be18345cd21dd9", "filename": "libstdc++-v3/include/bits/stl_alloc.h", "status": "modified", "additions": 9, "deletions": 53, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd8fd826dd40c4cd293ce57e5ceea39fef21b493/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_alloc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd8fd826dd40c4cd293ce57e5ceea39fef21b493/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_alloc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_alloc.h?ref=bd8fd826dd40c4cd293ce57e5ceea39fef21b493", "patch": "@@ -73,39 +73,7 @@\n #include <bits/std_cstdlib.h>\n #include <bits/std_cstring.h>\n #include <bits/std_cassert.h>\n-\n-// To see the effects of this block of macro wrangling, jump to\n-// \"Default node allocator\" below.\n-#ifdef __STL_THREADS\n-# include <bits/stl_threads.h>\n-# define __NODE_ALLOCATOR_THREADS true\n-# ifdef __STL_SGI_THREADS\n-  // We test whether threads are in use before locking.\n-  // Perhaps this should be moved into stl_threads.h, but that\n-  // probably makes it harder to avoid the procedure call when\n-  // it isn't needed.\n-    extern \"C\" {\n-      extern int __us_rsthread_malloc;\n-    }\n-\t// The above is copied from malloc.h.  Including <malloc.h>\n-\t// would be cleaner but fails with certain levels of standard\n-\t// conformance.\n-#   define __NODE_ALLOCATOR_LOCK if (__threads && __us_rsthread_malloc) \\\n-                { _S_node_allocator_lock._M_acquire_lock(); }\n-#   define __NODE_ALLOCATOR_UNLOCK if (__threads && __us_rsthread_malloc) \\\n-                { _S_node_allocator_lock._M_release_lock(); }\n-# else /* !__STL_SGI_THREADS */\n-#   define __NODE_ALLOCATOR_LOCK \\\n-        { if (__threads) _S_node_allocator_lock._M_acquire_lock(); }\n-#   define __NODE_ALLOCATOR_UNLOCK \\\n-        { if (__threads) _S_node_allocator_lock._M_release_lock(); }\n-# endif\n-#else\n-//  Thread-unsafe\n-#   define __NODE_ALLOCATOR_LOCK\n-#   define __NODE_ALLOCATOR_UNLOCK\n-#   define __NODE_ALLOCATOR_THREADS false\n-#endif\n+#include <bits/stl_threads.h>\n \n namespace std\n {\n@@ -364,9 +332,7 @@ class __default_alloc_template\n   static char* _S_end_free;\n   static size_t _S_heap_size;\n \n-#ifdef __STL_THREADS\n-    static _STL_mutex_lock _S_node_allocator_lock;\n-#endif\n+  static _STL_mutex_lock _S_node_allocator_lock;\n \n   // It would be nice to use _STL_auto_lock here.  But we\n   // don't need the NULL check.  And we do need a test whether\n@@ -375,8 +341,8 @@ class __default_alloc_template\n   friend class _Lock;\n   class _Lock {\n     public:\n-      _Lock() { __NODE_ALLOCATOR_LOCK; }\n-      ~_Lock() { __NODE_ALLOCATOR_UNLOCK; }\n+      _Lock() { if (__threads) _S_node_allocator_lock._M_acquire_lock(); }\n+      ~_Lock() { if (__threads) _S_node_allocator_lock._M_release_lock(); }\n   };\n \n public:\n@@ -394,10 +360,7 @@ class __default_alloc_template\n \t// Acquire the lock here with a constructor call.\n \t// This ensures that it is released in exit or during stack\n \t// unwinding.\n-#     ifndef _NOTHREADS\n-\t/*REFERENCED*/\n \t_Lock __lock_instance;\n-#     endif\n \t_Obj* __restrict__ __result = *__my_free_list;\n \tif (__result == 0)\n \t  __ret = _S_refill(_S_round_up(__n));\n@@ -423,10 +386,7 @@ class __default_alloc_template\n \t_Obj* __q = (_Obj*)__p;\n \t\n \t// acquire lock\n-#       ifndef _NOTHREADS\n-\t/*REFERENCED*/\n \t_Lock __lock_instance;\n-#       endif /* _NOTHREADS */\n \t__q -> _M_free_list_link = *__my_free_list;\n \t*__my_free_list = __q;\n \t// lock is released here\n@@ -582,13 +542,10 @@ __default_alloc_template<threads, inst>::reallocate(void* __p,\n     return(__result);\n }\n \n-#ifdef __STL_THREADS\n-    template <bool __threads, int __inst>\n-    _STL_mutex_lock\n-    __default_alloc_template<__threads, __inst>::_S_node_allocator_lock\n-        __STL_MUTEX_INITIALIZER;\n-#endif\n-\n+template <bool __threads, int __inst>\n+_STL_mutex_lock\n+__default_alloc_template<__threads, __inst>::_S_node_allocator_lock\n+  __STL_MUTEX_INITIALIZER;\n \n template <bool __threads, int __inst>\n char* __default_alloc_template<__threads, __inst>::_S_start_free = 0;\n@@ -606,8 +563,7 @@ __default_alloc_template<__threads, __inst> ::_S_free_list[\n ] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};\n \n \n-// __NODE_ALLOCATOR_THREADS is predicated on __STL_THREADS being defined or not\n-typedef __default_alloc_template<__NODE_ALLOCATOR_THREADS, 0> alloc;\n+typedef __default_alloc_template<true, 0> alloc;\n typedef __default_alloc_template<false, 0> single_client_alloc;\n \n "}, {"sha": "21b6a1fd43c7abbaf047b7bb5fe466e1b92038dc", "filename": "libstdc++-v3/include/bits/stl_threads.h", "status": "modified", "additions": 3, "deletions": 342, "changes": 345, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd8fd826dd40c4cd293ce57e5ceea39fef21b493/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_threads.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd8fd826dd40c4cd293ce57e5ceea39fef21b493/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_threads.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_threads.h?ref=bd8fd826dd40c4cd293ce57e5ceea39fef21b493", "patch": "@@ -48,34 +48,8 @@\n #ifndef __SGI_STL_INTERNAL_THREADS_H\n #define __SGI_STL_INTERNAL_THREADS_H\n \n-// Supported threading models are native SGI, pthreads, uithreads\n-// (similar to pthreads, but based on an earlier draft of the Posix\n-// threads standard), and Win32 threads.  Uithread support by Jochen\n-// Schlick, 1999.\n-\n-// GCC extension begin\n-// In order to present a stable threading configuration, in all cases,\n-// gcc looks for it's own abstraction layer before all others.  All\n-// modifications to this file are marked to allow easier importation of\n-// STL upgrades.\n-#if defined(__STL_GTHREADS)\n+// The only supported threading model is GCC's own gthr.h abstraction layer.\n #include \"bits/gthr.h\"\n-#else\n-// GCC extension end\n-#if defined(__STL_SGI_THREADS)\n-#include <mutex.h>\n-#include <time.h>\n-#elif defined(__STL_PTHREADS)\n-#include <pthread.h>\n-#elif defined(__STL_UITHREADS)\n-#include <thread.h>\n-#include <synch.h>\n-#elif defined(__STL_WIN32THREADS)\n-#include <windows.h>\n-#endif\n-// GCC extension begin\n-#endif\n-// GCC extension end\n \n namespace std\n {\n@@ -84,29 +58,15 @@ namespace std\n // _M_ref_count, and member functions _M_incr and _M_decr, which perform\n // atomic preincrement/predecrement.  The constructor initializes \n // _M_ref_count.\n-\n-// Hack for SGI o32 compilers.\n-#if defined(__STL_SGI_THREADS) && !defined(__add_and_fetch) && \\\n-    (__mips < 3 || !(defined (_ABIN32) || defined(_ABI64)))\n-#  define __add_and_fetch(__l,__v) add_then_test((unsigned long*)__l,__v)  \n-#  define __test_and_set(__l,__v)  test_and_set(__l,__v)\n-#endif /* o32 */\n-\n struct _Refcount_Base\n {\n   // The type _RC_t\n-# ifdef __STL_WIN32THREADS\n-  typedef long _RC_t;\n-# else\n   typedef size_t _RC_t;\n-#endif\n   \n   // The data member _M_ref_count\n    volatile _RC_t _M_ref_count;\n \n   // Constructor\n-// GCC extension begin\n-#ifdef __STL_GTHREADS\n   __gthread_mutex_t _M_ref_count_lock;\n   _Refcount_Base(_RC_t __n) : _M_ref_count(__n)\n     {\n@@ -119,25 +79,7 @@ struct _Refcount_Base\n #error __GTHREAD_MUTEX_INIT or __GTHREAD_MUTEX_INIT_FUNCTION should be defined by gthr.h abstraction layer, report problem to libstdc++@gcc.gnu.org.\n #endif\n     }\n-#else\n-// GCC extension end\n-# ifdef __STL_PTHREADS\n-  pthread_mutex_t _M_ref_count_lock;\n-  _Refcount_Base(_RC_t __n) : _M_ref_count(__n)\n-    { pthread_mutex_init(&_M_ref_count_lock, 0); }\n-# elif defined(__STL_UITHREADS)\n-  mutex_t         _M_ref_count_lock;\n-  _Refcount_Base(_RC_t __n) : _M_ref_count(__n)\n-    { mutex_init(&_M_ref_count_lock, USYNC_THREAD, 0); }\n-# else\n-  _Refcount_Base(_RC_t __n) : _M_ref_count(__n) {}\n-# endif\n-// GCC extension begin\n-#endif\n-// GCC extension end\n \n-// GCC extension begin\n-#ifdef __STL_GTHREADS\n   void _M_incr() {\n     __gthread_mutex_lock(&_M_ref_count_lock);\n     ++_M_ref_count;\n@@ -149,59 +91,14 @@ struct _Refcount_Base\n     __gthread_mutex_unlock(&_M_ref_count_lock);\n     return __tmp;\n   }\n-#else\n-// GCC extension end\n-  // _M_incr and _M_decr\n-# ifdef __STL_SGI_THREADS\n-  void _M_incr() {  __add_and_fetch(&_M_ref_count, 1); }\n-  _RC_t _M_decr() { return __add_and_fetch(&_M_ref_count, (size_t) -1); }\n-# elif defined (__STL_WIN32THREADS)\n-   void _M_incr() { InterlockedIncrement((_RC_t*)&_M_ref_count); }\n-  _RC_t _M_decr() { return InterlockedDecrement((_RC_t*)&_M_ref_count); }\n-# elif defined(__STL_PTHREADS)\n-  void _M_incr() {\n-    pthread_mutex_lock(&_M_ref_count_lock);\n-    ++_M_ref_count;\n-    pthread_mutex_unlock(&_M_ref_count_lock);\n-  }\n-  _RC_t _M_decr() {\n-    pthread_mutex_lock(&_M_ref_count_lock);\n-    volatile _RC_t __tmp = --_M_ref_count;\n-    pthread_mutex_unlock(&_M_ref_count_lock);\n-    return __tmp;\n-  }\n-# elif defined(__STL_UITHREADS)\n-  void _M_incr() {\n-    mutex_lock(&_M_ref_count_lock);\n-    ++_M_ref_count;\n-    mutex_unlock(&_M_ref_count_lock);\n-  }\n-  _RC_t _M_decr() {\n-    mutex_lock(&_M_ref_count_lock);\n-    /*volatile*/ _RC_t __tmp = --_M_ref_count;\n-    mutex_unlock(&_M_ref_count_lock);\n-    return __tmp;\n-  }\n-# else  /* No threads */\n-  void _M_incr() { ++_M_ref_count; }\n-  _RC_t _M_decr() { return --_M_ref_count; }\n-# endif\n-// GCC extension begin\n-#endif\n-// GCC extension end\n };\n \n // Atomic swap on unsigned long\n // This is guaranteed to behave as though it were atomic only if all\n // possibly concurrent updates use _Atomic_swap.\n // In some cases the operation is emulated with a lock.\n-// GCC extension begin\n-#if defined (__STL_GTHREADS) && defined (__GTHREAD_MUTEX_INIT)\n-// We don't provide an _Atomic_swap in this configuration.  This only\n-// affects the use of ext/rope with threads.  Someone could add this\n-// later, if required.  You can start by cloning the __STL_PTHREADS\n-// path while making the obvious changes.  Later it could be optimized\n-// to use the atomicity.h abstraction layer from libstdc++-v3.\n+#if defined (__GTHREAD_MUTEX_INIT)\n+// This could be optimized to use the atomicity.h abstraction layer.\n // vyzo: simple _Atomic_swap implementation following the guidelines above\n        // We use a template here only to get a unique initialized instance.\n     template<int __dummy>\n@@ -223,100 +120,7 @@ struct _Refcount_Base\n         __gthread_mutex_unlock(&_Swap_lock_struct<0>::_S_swap_lock);\n         return __result;\n     }\n-\n-#else\n-// GCC extension end\n-# ifdef __STL_SGI_THREADS\n-    inline unsigned long _Atomic_swap(unsigned long * __p, unsigned long __q) {\n-#       if __mips < 3 || !(defined (_ABIN32) || defined(_ABI64))\n-            return test_and_set(__p, __q);\n-#       else\n-            return __test_and_set(__p, (unsigned long)__q);\n-#       endif\n-    }\n-# elif defined(__STL_WIN32THREADS)\n-    inline unsigned long _Atomic_swap(unsigned long * __p, unsigned long __q) {\n-        return (unsigned long) InterlockedExchange((LPLONG)__p, (LONG)__q);\n-    }\n-# elif defined(__STL_PTHREADS)\n-    // We use a template here only to get a unique initialized instance.\n-    template<int __dummy>\n-    struct _Swap_lock_struct {\n-        static pthread_mutex_t _S_swap_lock;\n-    };\n-\n-    template<int __dummy>\n-    pthread_mutex_t\n-    _Swap_lock_struct<__dummy>::_S_swap_lock = PTHREAD_MUTEX_INITIALIZER;\n-\n-    // This should be portable, but performance is expected\n-    // to be quite awful.  This really needs platform specific\n-    // code.\n-    inline unsigned long _Atomic_swap(unsigned long * __p, unsigned long __q) {\n-        pthread_mutex_lock(&_Swap_lock_struct<0>::_S_swap_lock);\n-        unsigned long __result = *__p;\n-        *__p = __q;\n-        pthread_mutex_unlock(&_Swap_lock_struct<0>::_S_swap_lock);\n-        return __result;\n-    }\n-# elif defined(__STL_UITHREADS)\n-    // We use a template here only to get a unique initialized instance.\n-    template<int __dummy>\n-    struct _Swap_lock_struct {\n-        static mutex_t _S_swap_lock;\n-    };\n-\n-    template<int __dummy>\n-    mutex_t\n-    _Swap_lock_struct<__dummy>::_S_swap_lock = DEFAULTMUTEX;\n-\n-    // This should be portable, but performance is expected\n-    // to be quite awful.  This really needs platform specific\n-    // code.\n-    inline unsigned long _Atomic_swap(unsigned long * __p, unsigned long __q) {\n-        mutex_lock(&_Swap_lock_struct<0>::_S_swap_lock);\n-        unsigned long __result = *__p;\n-        *__p = __q;\n-        mutex_unlock(&_Swap_lock_struct<0>::_S_swap_lock);\n-        return __result;\n-    }\n-# elif defined (__STL_SOLARIS_THREADS)\n-    // any better solutions ?\n-    // We use a template here only to get a unique initialized instance.\n-    template<int __dummy>\n-    struct _Swap_lock_struct {\n-        static mutex_t _S_swap_lock;\n-    };\n-\n-# if ( __STL_STATIC_TEMPLATE_DATA > 0 )\n-    template<int __dummy>\n-    mutex_t\n-    _Swap_lock_struct<__dummy>::_S_swap_lock = DEFAULTMUTEX;\n-#  else\n-    __DECLARE_INSTANCE(mutex_t, _Swap_lock_struct<__dummy>::_S_swap_lock, \n-                       =DEFAULTMUTEX);\n-# endif /* ( __STL_STATIC_TEMPLATE_DATA > 0 ) */\n-\n-    // This should be portable, but performance is expected\n-    // to be quite awful.  This really needs platform specific\n-    // code.\n-    inline unsigned long _Atomic_swap(unsigned long * __p, unsigned long __q) {\n-        mutex_lock(&_Swap_lock_struct<0>::_S_swap_lock);\n-        unsigned long __result = *__p;\n-        *__p = __q;\n-        mutex_unlock(&_Swap_lock_struct<0>::_S_swap_lock);\n-        return __result;\n-    }\n-# else\n-    static inline unsigned long _Atomic_swap(unsigned long * __p, unsigned long __q) {\n-        unsigned long __result = *__p;\n-        *__p = __q;\n-        return __result;\n-    }\n-# endif\n-// GCC extension begin\n #endif\n-// GCC extension end\n \n // Locking class.  Note that this class *does not have a constructor*.\n // It must be initialized either statically, with __STL_MUTEX_INITIALIZER,\n@@ -330,39 +134,16 @@ struct _Refcount_Base\n // constructors, no base classes, no virtual functions, and no private or\n // protected members.\n \n-// Helper struct.  This is a workaround for various compilers that don't\n-// handle static variables in inline functions properly.\n-template <int __inst>\n-struct _STL_mutex_spin {\n-  enum { __low_max = 30, __high_max = 1000 };\n-  // Low if we suspect uniprocessor, high for multiprocessor.\n-\n-  static unsigned __max;\n-  static unsigned __last;\n-};\n-\n-template <int __inst>\n-unsigned _STL_mutex_spin<__inst>::__max = _STL_mutex_spin<__inst>::__low_max;\n-\n-template <int __inst>\n-unsigned _STL_mutex_spin<__inst>::__last = 0;\n-\n-// GCC extension begin\n-#if defined(__STL_GTHREADS)\n #if !defined(__GTHREAD_MUTEX_INIT) && defined(__GTHREAD_MUTEX_INIT_FUNCTION)\n extern __gthread_mutex_t _GLIBCPP_mutex;\n extern __gthread_mutex_t *_GLIBCPP_mutex_address;\n extern __gthread_once_t _GLIBCPP_once;\n extern void _GLIBCPP_mutex_init (void);\n extern void _GLIBCPP_mutex_address_init (void);\n #endif\n-#endif\n-// GCC extension end\n \n struct _STL_mutex_lock\n {\n-// GCC extension begin\n-#if defined(__STL_GTHREADS)\n   // The class must be statically initialized with __STL_MUTEX_INITIALIZER.\n #if !defined(__GTHREAD_MUTEX_INIT) && defined(__GTHREAD_MUTEX_INIT_FUNCTION)\n   volatile int _M_init_flag;\n@@ -403,108 +184,8 @@ struct _STL_mutex_lock\n #endif\n     __gthread_mutex_unlock(&_M_lock);\n   }\n-#else\n-// GCC extension end\n-#if defined(__STL_SGI_THREADS) || defined(__STL_WIN32THREADS)\n-  // It should be relatively easy to get this to work on any modern Unix.\n-  volatile unsigned long _M_lock;\n-  void _M_initialize() { _M_lock = 0; }\n-  static void _S_nsec_sleep(int __log_nsec) {\n-#     ifdef __STL_SGI_THREADS\n-          struct timespec __ts;\n-          /* Max sleep is 2**27nsec ~ 60msec      */\n-          __ts.tv_sec = 0;\n-          __ts.tv_nsec = 1L << __log_nsec;\n-          nanosleep(&__ts, 0);\n-#     elif defined(__STL_WIN32THREADS)\n-          if (__log_nsec <= 20) {\n-              Sleep(0);\n-          } else {\n-              Sleep(1 << (__log_nsec - 20));\n-          }\n-#     else\n-#       error unimplemented\n-#     endif\n-  }\n-  void _M_acquire_lock() {\n-    volatile unsigned long* __lock = &this->_M_lock;\n-\n-    if (!_Atomic_swap((unsigned long*)__lock, 1)) {\n-      return;\n-    }\n-    unsigned __my_spin_max = _STL_mutex_spin<0>::__max;\n-    unsigned __my_last_spins = _STL_mutex_spin<0>::__last;\n-    volatile unsigned __junk = 17;      // Value doesn't matter.\n-    unsigned __i;\n-    for (__i = 0; __i < __my_spin_max; __i++) {\n-      if (__i < __my_last_spins/2 || *__lock) {\n-        __junk *= __junk; __junk *= __junk;\n-        __junk *= __junk; __junk *= __junk;\n-        continue;\n-      }\n-      if (!_Atomic_swap((unsigned long*)__lock, 1)) {\n-        // got it!\n-        // Spinning worked.  Thus we're probably not being scheduled\n-        // against the other process with which we were contending.\n-        // Thus it makes sense to spin longer the next time.\n-        _STL_mutex_spin<0>::__last = __i;\n-        _STL_mutex_spin<0>::__max = _STL_mutex_spin<0>::__high_max;\n-        return;\n-      }\n-    }\n-    // We are probably being scheduled against the other process.  Sleep.\n-    _STL_mutex_spin<0>::__max = _STL_mutex_spin<0>::__low_max;\n-    for (__i = 0 ;; ++__i) {\n-      int __log_nsec = __i + 6;\n-\n-      if (__log_nsec > 27) __log_nsec = 27;\n-      if (!_Atomic_swap((unsigned long *)__lock, 1)) {\n-        return;\n-      }\n-      _S_nsec_sleep(__log_nsec);\n-    }\n-  }\n-  void _M_release_lock() {\n-    volatile unsigned long* __lock = &_M_lock;\n-#   if defined(__STL_SGI_THREADS) && defined(__GNUC__) && __mips >= 3\n-        asm(\"sync\");\n-        *__lock = 0;\n-#   elif defined(__STL_SGI_THREADS) && __mips >= 3 \\\n-         && (defined (_ABIN32) || defined(_ABI64))\n-        __lock_release(__lock);\n-#   else \n-        *__lock = 0;\n-        // This is not sufficient on many multiprocessors, since\n-        // writes to protected variables and the lock may be reordered.\n-#   endif\n-  }\n-\n-// We no longer use win32 critical sections.\n-// They appear to be slower in the contention-free case,\n-// and they appear difficult to initialize without introducing a race.\n-\n-#elif defined(__STL_PTHREADS)\n-  pthread_mutex_t _M_lock;\n-  void _M_initialize()   { pthread_mutex_init(&_M_lock, NULL); }\n-  void _M_acquire_lock() { pthread_mutex_lock(&_M_lock); }\n-  void _M_release_lock() { pthread_mutex_unlock(&_M_lock); }\n-#elif defined(__STL_UITHREADS)\n-  mutex_t _M_lock;\n-  void _M_initialize()   { mutex_init(&_M_lock, USYNC_THREAD, 0); }\n-  void _M_acquire_lock() { mutex_lock(&_M_lock); }\n-  void _M_release_lock() { mutex_unlock(&_M_lock); }\n-#else /* No threads */\n-  void _M_initialize()   {}\n-  void _M_acquire_lock() {}\n-  void _M_release_lock() {}\n-#endif\n-// GCC extension begin\n-#endif\n-// GCC extension end\n };\n \n-// GCC extension begin\n-#if defined(__STL_GTHREADS)\n #ifdef __GTHREAD_MUTEX_INIT\n #define __STL_MUTEX_INITIALIZER = { __GTHREAD_MUTEX_INIT }\n #elif defined(__GTHREAD_MUTEX_INIT_FUNCTION)\n@@ -515,25 +196,6 @@ struct _STL_mutex_lock\n #define __STL_MUTEX_INITIALIZER = { 0, __GTHREAD_ONCE_INIT }\n #endif\n #endif\n-#else\n-// GCC extension end\n-#ifdef __STL_PTHREADS\n-// Pthreads locks must be statically initialized to something other than\n-// the default value of zero.\n-#   define __STL_MUTEX_INITIALIZER = { PTHREAD_MUTEX_INITIALIZER }\n-#elif defined(__STL_UITHREADS)\n-// UIthreads locks must be statically initialized to something other than\n-// the default value of zero.\n-#   define __STL_MUTEX_INITIALIZER = { DEFAULTMUTEX }\n-#elif defined(__STL_SGI_THREADS) || defined(__STL_WIN32THREADS)\n-#   define __STL_MUTEX_INITIALIZER = { 0 }\n-#else\n-#   define __STL_MUTEX_INITIALIZER\n-#endif\n-// GCC extension begin\n-#endif\n-// GCC extension end\n-\n \n // A locking class that uses _STL_mutex_lock.  The constructor takes a\n // reference to an _STL_mutex_lock, and acquires a lock.  The\n@@ -560,4 +222,3 @@ struct _STL_auto_lock\n // Local Variables:\n // mode:C++\n // End:\n-"}, {"sha": "2fae3ccaf0b963fe9615feb8ca4afa1c9c22357a", "filename": "libstdc++-v3/include/ext/stl_rope.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd8fd826dd40c4cd293ce57e5ceea39fef21b493/libstdc%2B%2B-v3%2Finclude%2Fext%2Fstl_rope.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd8fd826dd40c4cd293ce57e5ceea39fef21b493/libstdc%2B%2B-v3%2Finclude%2Fext%2Fstl_rope.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fstl_rope.h?ref=bd8fd826dd40c4cd293ce57e5ceea39fef21b493", "patch": "@@ -60,9 +60,6 @@\n #   include <bits/stl_threads.h>\n #   define __GC_CONST   // constant except for deallocation\n # endif\n-# ifdef __STL_SGI_THREADS\n-#    include <mutex.h>\n-# endif\n \n namespace std\n {"}, {"sha": "bc1246488ec60a1338581a1136ed889b03668238", "filename": "libstdc++-v3/src/stl-inst.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd8fd826dd40c4cd293ce57e5ceea39fef21b493/libstdc%2B%2B-v3%2Fsrc%2Fstl-inst.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd8fd826dd40c4cd293ce57e5ceea39fef21b493/libstdc%2B%2B-v3%2Fsrc%2Fstl-inst.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fstl-inst.cc?ref=bd8fd826dd40c4cd293ce57e5ceea39fef21b493", "patch": "@@ -42,7 +42,7 @@ namespace std\n   template class __malloc_alloc_template<0>;\n \n #ifndef __USE_MALLOC\n-  template class __default_alloc_template<__NODE_ALLOCATOR_THREADS, 0>;\n+  template class __default_alloc_template<true, 0>;\n #endif\n \n   template"}]}