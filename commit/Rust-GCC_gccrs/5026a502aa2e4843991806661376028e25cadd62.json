{"sha": "5026a502aa2e4843991806661376028e25cadd62", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTAyNmE1MDJhYTJlNDg0Mzk5MTgwNjY2MTM3NjAyOGUyNWNhZGQ2Mg==", "commit": {"author": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1999-01-20T02:09:52Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1999-01-20T02:09:52Z"}, "message": "loop.c (NUM_STORES): Delete.\n\n        * loop.c (NUM_STORES): Delete.\n        (loop_store_mems): Turn into an EXPR_LIST of MEMs.\n        (prescan_loop): Properly initialize loop_mems_idx.\n        (note_addr_stored): Simplify using list structure instead of\n        fixed sized array.\n        (invariant_p, check_dbra_loop, load_mems): Similarly.\n\nFrom-SVN: r24782", "tree": {"sha": "a9f85e4dbe33640837a87e79e8e647ca54720257", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a9f85e4dbe33640837a87e79e8e647ca54720257"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5026a502aa2e4843991806661376028e25cadd62", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5026a502aa2e4843991806661376028e25cadd62", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5026a502aa2e4843991806661376028e25cadd62", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5026a502aa2e4843991806661376028e25cadd62/comments", "author": null, "committer": null, "parents": [{"sha": "15e088b20edd4351b8e0913edfbae3b107175d1f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/15e088b20edd4351b8e0913edfbae3b107175d1f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/15e088b20edd4351b8e0913edfbae3b107175d1f"}], "stats": {"total": 60, "additions": 23, "deletions": 37}, "files": [{"sha": "905bcf25a4060a5bf525b61e13b64188c3b6c9a7", "filename": "gcc/loop.c", "status": "modified", "additions": 23, "deletions": 37, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5026a502aa2e4843991806661376028e25cadd62/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5026a502aa2e4843991806661376028e25cadd62/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=5026a502aa2e4843991806661376028e25cadd62", "patch": "@@ -159,14 +159,9 @@ static varray_type may_not_optimize;\n \n static char *moved_once;\n \n-/* Array of MEMs that are stored in this loop. If there are too many to fit\n-   here, we just turn on unknown_address_altered.  */\n+/* List of MEMs that are stored in this loop.  */\n \n-#define NUM_STORES 30\n-static rtx loop_store_mems[NUM_STORES];\n-\n-/* Index of first available slot in above array.  */\n-static int loop_store_mems_idx;\n+static rtx loop_store_mems;\n \n typedef struct loop_mem_info {\n   rtx mem;      /* The MEM itself.  */\n@@ -2356,7 +2351,7 @@ constant_high_bytes (p, loop_start)\n /* Scan a loop setting the variables `unknown_address_altered',\n    `num_mem_sets', `loop_continue', `loops_enclosed', `loop_has_call',\n    `loop_has_volatile', and `loop_has_tablejump'.\n-   Also, fill in the arrays `loop_mems' and `loop_store_mems'.  */\n+   Also, fill in the array `loop_mems' and the list `loop_store_mems'.  */\n \n static void\n prescan_loop (start, end)\n@@ -2377,7 +2372,7 @@ prescan_loop (start, end)\n   loop_has_call = 0;\n   loop_has_volatile = 0;\n   loop_has_tablejump = 0;\n-  loop_store_mems_idx = 0;\n+  loop_store_mems = NULL_RTX;\n   loop_mems_idx = 0;\n \n   num_mem_sets = 0;\n@@ -2981,8 +2976,6 @@ note_addr_stored (x, y)\n      rtx x;\n      rtx y ATTRIBUTE_UNUSED;\n {\n-  register int i;\n-\n   if (x == 0 || GET_CODE (x) != MEM)\n     return;\n \n@@ -2997,22 +2990,7 @@ note_addr_stored (x, y)\n   if (unknown_address_altered)\n     return;\n \n-  for (i = 0; i < loop_store_mems_idx; i++)\n-    if (rtx_equal_p (XEXP (loop_store_mems[i], 0), XEXP (x, 0)))\n-      {\n-\t/* We are storing at the same address as previously noted.  Save the\n-\t   wider reference.  */\n-\tif (GET_MODE_SIZE (GET_MODE (x))\n-\t    > GET_MODE_SIZE (GET_MODE (loop_store_mems[i])))\n-\t  loop_store_mems[i] = x;\n-\tbreak;\n-      }\n-\n-  if (i == NUM_STORES)\n-    unknown_address_altered = 1;\n-\n-  else if (i == loop_store_mems_idx)\n-    loop_store_mems[loop_store_mems_idx++] = x;\n+  loop_store_mems = gen_rtx_EXPR_LIST (VOIDmode, x, loop_store_mems);\n }\n \f\n /* Return nonzero if the rtx X is invariant over the current loop.\n@@ -3031,6 +3009,7 @@ invariant_p (x)\n   register enum rtx_code code;\n   register char *fmt;\n   int conditional = 0;\n+  rtx mem_list_entry;\n \n   if (x == 0)\n     return 1;\n@@ -3093,15 +3072,20 @@ invariant_p (x)\n       if (RTX_UNCHANGING_P (x))\n \tbreak;\n \n-      /* If we filled the table (or had a subroutine call), any location\n-\t in memory could have been clobbered.  */\n+      /* If we had a subroutine call, any location in memory could have been\n+\t clobbered.  */\n       if (unknown_address_altered)\n \treturn 0;\n \n       /* See if there is any dependence between a store and this load.  */\n-      for (i = loop_store_mems_idx - 1; i >= 0; i--)\n-\tif (true_dependence (loop_store_mems[i], VOIDmode, x, rtx_varies_p))\n-\t  return 0;\n+      mem_list_entry = loop_store_mems;\n+      while (mem_list_entry)\n+\t{\n+\t  if (true_dependence (XEXP (mem_list_entry, 0), VOIDmode,\n+\t\t\t       x, rtx_varies_p))\n+\t    return 0;\n+\t  mem_list_entry = XEXP (mem_list_entry, 1);\n+\t}\n \n       /* It's not invalidated by a store in memory\n \t but we must still verify the address is invariant.  */\n@@ -6804,7 +6788,7 @@ check_dbra_loop (loop_end, insn_count, loop_start, loop_info)\n \t  if (num_mem_sets == 1)\n \t    reversible_mem_store\n \t      = (! unknown_address_altered\n-\t\t && ! invariant_p (XEXP (loop_store_mems[0], 0)));\n+\t\t && ! invariant_p (XEXP (loop_store_mems, 0)));\n \t}\n       else\n \treturn 0;\n@@ -8427,10 +8411,10 @@ load_mems (scan_start, end, loop_top, start)\n       /* Actually move the MEMs.  */\n       for (i = 0; i < loop_mems_idx; ++i) \n \t{\n-\t  int j;\n \t  int written = 0;\n \t  rtx reg;\n \t  rtx mem = loop_mems[i].mem;\n+\t  rtx mem_list_entry;\n \n \t  if (MEM_VOLATILE_P (mem) \n \t      || invariant_p (XEXP (mem, 0)) != 1)\n@@ -8439,17 +8423,19 @@ load_mems (scan_start, end, loop_top, start)\n \n \t  /* Go through the MEMs written to in the loop to see if this\n \t     one is aliased by one of them.  */\n-\t  for (j = 0; j < loop_store_mems_idx; ++j) \n+\t  mem_list_entry = loop_store_mems;\n+\t  while (mem_list_entry)\n \t    {\n-\t      if (rtx_equal_p (mem, loop_store_mems[j]))\n+\t      if (rtx_equal_p (mem, XEXP (mem_list_entry, 0)))\n \t\twritten = 1;\n-\t      else if (true_dependence (loop_store_mems[j], VOIDmode,\n+\t      else if (true_dependence (XEXP (mem_list_entry, 0), VOIDmode,\n \t\t\t\t\tmem, rtx_varies_p))\n \t\t{\n \t\t  /* MEM is indeed aliased by this store.  */\n \t\t  loop_mems[i].optimize = 0;\n \t\t  break;\n \t\t}\n+\t      mem_list_entry = XEXP (mem_list_entry, 1);\n \t    }\n \t  \n \t  /* If this MEM is written to, we must be sure that there"}]}