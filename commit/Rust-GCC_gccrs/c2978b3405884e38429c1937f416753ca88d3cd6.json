{"sha": "c2978b3405884e38429c1937f416753ca88d3cd6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzI5NzhiMzQwNTg4NGUzODQyOWMxOTM3ZjQxNjc1M2NhODhkM2NkNg==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2020-10-01T16:41:15Z"}, "committer": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2020-10-01T16:41:15Z"}, "message": "arm: Add missing vec_cmp and vcond patterns\n\nThis patch does several things at once:\n\n(1) Add vector compare patterns (vec_cmp and vec_cmpu).\n\n(2) Add vector selects between floating-point modes when the\n    values being compared are integers (affects vcond and vcondu).\n\n(3) Add vector selects between integer modes when the values being\n    compared are floating-point (affects vcond).\n\n(4) Add standalone vector select patterns (vcond_mask).\n\n(5) Tweak the handling of compound comparisons with zeros.\n\nUnfortunately it proved too difficult (for me) to separate this\nout into a series of smaller patches, since everything is so\ninter-related.  Defining only some of the new patterns does\nnot leave things in a happy state.\n\nThe handling of comparisons is mostly taken from the vcond patterns.\nThis means that it remains non-compliant with IEEE: \u201cquiet\u201d comparisons\nuse signalling instructions.  But that shouldn't matter for floats,\nsince we require -funsafe-math-optimizations to vectorize for them\nanyway.\n\nIt remains the case that comparisons and selects aren't implemented\nat all for HF vectors.  Implementing those feels like separate work.\n\ngcc/\n\tPR target/96528\n\tPR target/97288\n\t* config/arm/arm-protos.h (arm_expand_vector_compare): Declare.\n\t(arm_expand_vcond): Likewise.\n\t* config/arm/arm.c (arm_expand_vector_compare): New function.\n\t(arm_expand_vcond): Likewise.\n\t* config/arm/neon.md (vec_cmp<VDQW:mode><v_cmp_result>): New pattern.\n\t(vec_cmpu<VDQW:mode><VDQW:mode>): Likewise.\n\t(vcond<VDQW:mode><VDQW:mode>): Require operand 5 to be a register\n\tor zero.  Use arm_expand_vcond.\n\t(vcond<V_cvtto><V32:mode>): New pattern.\n\t(vcondu<VDQIW:mode><VDQIW:mode>): Generalize to...\n\t(vcondu<VDQW:mode><v_cmp_result): ...this.  Require operand 5\n\tto be a register or zero.  Use arm_expand_vcond.\n\t(vcond_mask_<VDQW:mode><v_cmp_result>): New pattern.\n\t(neon_vc<cmp_op><mode>, neon_vc<cmp_op><mode>_insn): Add \"@\" marker.\n\t(neon_vbsl<mode>): Likewise.\n\t(neon_vc<cmp_op>u<mode>): Reexpress as...\n\t(@neon_vc<code><mode>): ...this.\n\ngcc/testsuite/\n\t* lib/target-supports.exp (check_effective_target_vect_cond_mixed): Add\n\tarm neon targets.\n\t* gcc.target/arm/neon-compare-1.c: New test.\n\t* gcc.target/arm/neon-compare-2.c: Likewise.\n\t* gcc.target/arm/neon-compare-3.c: Likewise.\n\t* gcc.target/arm/neon-compare-4.c: Likewise.\n\t* gcc.target/arm/neon-compare-5.c: Likewise.\n\t* gcc.target/arm/neon-vcond-gt.c: Expect comparisons with zero.\n\t* gcc.target/arm/neon-vcond-ltgt.c: Likewise.\n\t* gcc.target/arm/neon-vcond-unordered.c: Likewise.", "tree": {"sha": "fe6e29c08a7fdea3978d40ea566b34a25f356093", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fe6e29c08a7fdea3978d40ea566b34a25f356093"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c2978b3405884e38429c1937f416753ca88d3cd6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c2978b3405884e38429c1937f416753ca88d3cd6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c2978b3405884e38429c1937f416753ca88d3cd6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c2978b3405884e38429c1937f416753ca88d3cd6/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "92f2c04d382c325f9930ab12e1b7c7d680222ae3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/92f2c04d382c325f9930ab12e1b7c7d680222ae3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/92f2c04d382c325f9930ab12e1b7c7d680222ae3"}], "stats": {"total": 663, "additions": 442, "deletions": 221}, "files": [{"sha": "703d6160c242003ed67d6ccab718c39f1fbf7c14", "filename": "gcc/config/arm/arm-protos.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2978b3405884e38429c1937f416753ca88d3cd6/gcc%2Fconfig%2Farm%2Farm-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2978b3405884e38429c1937f416753ca88d3cd6/gcc%2Fconfig%2Farm%2Farm-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-protos.h?ref=c2978b3405884e38429c1937f416753ca88d3cd6", "patch": "@@ -372,9 +372,11 @@ extern void arm_emit_coreregs_64bit_shift (enum rtx_code, rtx, rtx, rtx, rtx,\n extern bool arm_fusion_enabled_p (tune_params::fuse_ops);\n extern bool arm_valid_symbolic_address_p (rtx);\n extern bool arm_validize_comparison (rtx *, rtx *, rtx *);\n+extern bool arm_expand_vector_compare (rtx, rtx_code, rtx, rtx, bool);\n #endif /* RTX_CODE */\n \n extern bool arm_gen_setmem (rtx *);\n+extern void arm_expand_vcond (rtx *, machine_mode);\n extern void arm_expand_vec_perm (rtx target, rtx op0, rtx op1, rtx sel);\n \n extern bool arm_autoinc_modes_ok_p (machine_mode, enum arm_auto_incmodes);"}, {"sha": "0e23246c27b2a0a53da4ab0fdad8c2eb904fc5ca", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 121, "deletions": 0, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2978b3405884e38429c1937f416753ca88d3cd6/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2978b3405884e38429c1937f416753ca88d3cd6/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=c2978b3405884e38429c1937f416753ca88d3cd6", "patch": "@@ -30634,6 +30634,127 @@ arm_split_atomic_op (enum rtx_code code, rtx old_out, rtx new_out, rtx mem,\n     arm_post_atomic_barrier (model);\n }\n \f\n+/* Expand code to compare vectors OP0 and OP1 using condition CODE.\n+   If CAN_INVERT, store either the result or its inverse in TARGET\n+   and return true if TARGET contains the inverse.  If !CAN_INVERT,\n+   always store the result in TARGET, never its inverse.\n+\n+   Note that the handling of floating-point comparisons is not\n+   IEEE compliant.  */\n+\n+bool\n+arm_expand_vector_compare (rtx target, rtx_code code, rtx op0, rtx op1,\n+\t\t\t   bool can_invert)\n+{\n+  machine_mode cmp_result_mode = GET_MODE (target);\n+  machine_mode cmp_mode = GET_MODE (op0);\n+\n+  bool inverted;\n+  switch (code)\n+    {\n+    /* For these we need to compute the inverse of the requested\n+       comparison.  */\n+    case UNORDERED:\n+    case UNLT:\n+    case UNLE:\n+    case UNGT:\n+    case UNGE:\n+    case UNEQ:\n+    case NE:\n+      code = reverse_condition_maybe_unordered (code);\n+      if (!can_invert)\n+\t{\n+\t  /* Recursively emit the inverted comparison into a temporary\n+\t     and then store its inverse in TARGET.  This avoids reusing\n+\t     TARGET (which for integer NE could be one of the inputs).  */\n+\t  rtx tmp = gen_reg_rtx (cmp_result_mode);\n+\t  if (arm_expand_vector_compare (tmp, code, op0, op1, true))\n+\t    gcc_unreachable ();\n+\t  emit_insn (gen_rtx_SET (target, gen_rtx_NOT (cmp_result_mode, tmp)));\n+\t  return false;\n+\t}\n+      inverted = true;\n+      break;\n+\n+    default:\n+      inverted = false;\n+      break;\n+    }\n+\n+  switch (code)\n+    {\n+    /* These are natively supported for zero comparisons, but otherwise\n+       require the operands to be swapped.  */\n+    case LE:\n+    case LT:\n+      if (op1 != CONST0_RTX (cmp_mode))\n+\t{\n+\t  code = swap_condition (code);\n+\t  std::swap (op0, op1);\n+\t}\n+      /* Fall through.  */\n+\n+    /* These are natively supported for both register and zero operands.  */\n+    case EQ:\n+    case GE:\n+    case GT:\n+      emit_insn (gen_neon_vc (code, cmp_mode, target, op0, op1));\n+      return inverted;\n+\n+    /* These are natively supported for register operands only.\n+       Comparisons with zero aren't useful and should be folded\n+       or canonicalized by target-independent code.  */\n+    case GEU:\n+    case GTU:\n+      emit_insn (gen_neon_vc (code, cmp_mode, target,\n+\t\t\t      op0, force_reg (cmp_mode, op1)));\n+      return inverted;\n+\n+    /* These require the operands to be swapped and likewise do not\n+       support comparisons with zero.  */\n+    case LEU:\n+    case LTU:\n+      emit_insn (gen_neon_vc (swap_condition (code), cmp_mode,\n+\t\t\t      target, force_reg (cmp_mode, op1), op0));\n+      return inverted;\n+\n+    /* These need a combination of two comparisons.  */\n+    case LTGT:\n+    case ORDERED:\n+      {\n+\t/* Operands are LTGT iff (a > b || a > b).\n+\t   Operands are ORDERED iff (a > b || a <= b).  */\n+\trtx gt_res = gen_reg_rtx (cmp_result_mode);\n+\trtx alt_res = gen_reg_rtx (cmp_result_mode);\n+\trtx_code alt_code = (code == LTGT ? LT : LE);\n+\tif (arm_expand_vector_compare (gt_res, GT, op0, op1, true)\n+\t    || arm_expand_vector_compare (alt_res, alt_code, op0, op1, true))\n+\t  gcc_unreachable ();\n+\temit_insn (gen_rtx_SET (target, gen_rtx_IOR (cmp_result_mode,\n+\t\t\t\t\t\t     gt_res, alt_res)));\n+\treturn inverted;\n+      }\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+\n+/* Expand a vcond or vcondu pattern with operands OPERANDS.\n+   CMP_RESULT_MODE is the mode of the comparison result.  */\n+\n+void\n+arm_expand_vcond (rtx *operands, machine_mode cmp_result_mode)\n+{\n+  rtx mask = gen_reg_rtx (cmp_result_mode);\n+  bool inverted = arm_expand_vector_compare (mask, GET_CODE (operands[3]),\n+\t\t\t\t\t     operands[4], operands[5], true);\n+  if (inverted)\n+    std::swap (operands[1], operands[2]);\n+  emit_insn (gen_neon_vbsl (GET_MODE (operands[0]), operands[0],\n+\t\t\t    mask, operands[1], operands[2]));\n+}\n+\f\n #define MAX_VECT_LEN 16\n \n struct expand_vec_perm_d"}, {"sha": "58832cbf484a706bce9d98d13f7fe1e33fd47a23", "filename": "gcc/config/arm/neon.md", "status": "modified", "additions": 64, "deletions": 217, "changes": 281, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2978b3405884e38429c1937f416753ca88d3cd6/gcc%2Fconfig%2Farm%2Fneon.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2978b3405884e38429c1937f416753ca88d3cd6/gcc%2Fconfig%2Farm%2Fneon.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fneon.md?ref=c2978b3405884e38429c1937f416753ca88d3cd6", "patch": "@@ -1530,6 +1530,30 @@\n   [(set_attr \"type\" \"neon_qsub<q>\")]\n )\n \n+(define_expand \"vec_cmp<mode><v_cmp_result>\"\n+  [(set (match_operand:<V_cmp_result> 0 \"s_register_operand\")\n+\t(match_operator:<V_cmp_result> 1 \"comparison_operator\"\n+\t  [(match_operand:VDQW 2 \"s_register_operand\")\n+\t   (match_operand:VDQW 3 \"reg_or_zero_operand\")]))]\n+  \"TARGET_NEON && (!<Is_float_mode> || flag_unsafe_math_optimizations)\"\n+{\n+  arm_expand_vector_compare (operands[0], GET_CODE (operands[1]),\n+\t\t\t     operands[2], operands[3], false);\n+  DONE;\n+})\n+\n+(define_expand \"vec_cmpu<mode><mode>\"\n+  [(set (match_operand:VDQIW 0 \"s_register_operand\")\n+\t(match_operator:VDQIW 1 \"comparison_operator\"\n+\t  [(match_operand:VDQIW 2 \"s_register_operand\")\n+\t   (match_operand:VDQIW 3 \"reg_or_zero_operand\")]))]\n+  \"TARGET_NEON\"\n+{\n+  arm_expand_vector_compare (operands[0], GET_CODE (operands[1]),\n+\t\t\t     operands[2], operands[3], false);\n+  DONE;\n+})\n+\n ;; Conditional instructions.  These are comparisons with conditional moves for\n ;; vectors.  They perform the assignment:\n ;;   \n@@ -1543,230 +1567,53 @@\n \t(if_then_else:VDQW\n \t  (match_operator 3 \"comparison_operator\"\n \t    [(match_operand:VDQW 4 \"s_register_operand\")\n-\t     (match_operand:VDQW 5 \"nonmemory_operand\")])\n+\t     (match_operand:VDQW 5 \"reg_or_zero_operand\")])\n \t  (match_operand:VDQW 1 \"s_register_operand\")\n \t  (match_operand:VDQW 2 \"s_register_operand\")))]\n   \"TARGET_NEON && (!<Is_float_mode> || flag_unsafe_math_optimizations)\"\n {\n-  int inverse = 0;\n-  int use_zero_form = 0;\n-  int swap_bsl_operands = 0;\n-  rtx mask = gen_reg_rtx (<V_cmp_result>mode);\n-  rtx tmp = gen_reg_rtx (<V_cmp_result>mode);\n-\n-  rtx (*base_comparison) (rtx, rtx, rtx);\n-  rtx (*complimentary_comparison) (rtx, rtx, rtx);\n-\n-  switch (GET_CODE (operands[3]))\n-    {\n-    case GE:\n-    case GT:\n-    case LE:\n-    case LT:\n-    case EQ:\n-      if (operands[5] == CONST0_RTX (<MODE>mode))\n-\t{\n-\t  use_zero_form = 1;\n-\t  break;\n-\t}\n-      /* Fall through.  */\n-    default:\n-      if (!REG_P (operands[5]))\n-\toperands[5] = force_reg (<MODE>mode, operands[5]);\n-    }\n-\n-  switch (GET_CODE (operands[3]))\n-    {\n-    case LT:\n-    case UNLT:\n-      inverse = 1;\n-      /* Fall through.  */\n-    case GE:\n-    case UNGE:\n-    case ORDERED:\n-    case UNORDERED:\n-      base_comparison = gen_neon_vcge<mode>;\n-      complimentary_comparison = gen_neon_vcgt<mode>;\n-      break;\n-    case LE:\n-    case UNLE:\n-      inverse = 1;\n-      /* Fall through.  */\n-    case GT:\n-    case UNGT:\n-      base_comparison = gen_neon_vcgt<mode>;\n-      complimentary_comparison = gen_neon_vcge<mode>;\n-      break;\n-    case EQ:\n-    case NE:\n-    case UNEQ:\n-      base_comparison = gen_neon_vceq<mode>;\n-      complimentary_comparison = gen_neon_vceq<mode>;\n-      break;\n-    default:\n-      gcc_unreachable ();\n-    }\n-\n-  switch (GET_CODE (operands[3]))\n-    {\n-    case LT:\n-    case LE:\n-    case GT:\n-    case GE:\n-    case EQ:\n-      /* The easy case.  Here we emit one of vcge, vcgt or vceq.\n-\t As a LT b <=> b GE a && a LE b <=> b GT a.  Our transformations are:\n-\t a GE b -> a GE b\n-\t a GT b -> a GT b\n-\t a LE b -> b GE a\n-\t a LT b -> b GT a\n-\t a EQ b -> a EQ b\n-\t Note that there also exist direct comparison against 0 forms,\n-\t so catch those as a special case.  */\n-      if (use_zero_form)\n-\t{\n-\t  inverse = 0;\n-\t  switch (GET_CODE (operands[3]))\n-\t    {\n-\t    case LT:\n-\t      base_comparison = gen_neon_vclt<mode>;\n-\t      break;\n-\t    case LE:\n-\t      base_comparison = gen_neon_vcle<mode>;\n-\t      break;\n-\t    default:\n-\t      /* Do nothing, other zero form cases already have the correct\n-\t\t base_comparison.  */\n-\t      break;\n-\t    }\n-\t}\n-\n-      if (!inverse)\n-\temit_insn (base_comparison (mask, operands[4], operands[5]));\n-      else\n-\temit_insn (complimentary_comparison (mask, operands[5], operands[4]));\n-      break;\n-    case UNLT:\n-    case UNLE:\n-    case UNGT:\n-    case UNGE:\n-    case NE:\n-      /* Vector compare returns false for lanes which are unordered, so if we use\n-\t the inverse of the comparison we actually want to emit, then\n-\t swap the operands to BSL, we will end up with the correct result.\n-\t Note that a NE NaN and NaN NE b are true for all a, b.\n-\n-\t Our transformations are:\n-\t a GE b -> !(b GT a)\n-\t a GT b -> !(b GE a)\n-\t a LE b -> !(a GT b)\n-\t a LT b -> !(a GE b)\n-\t a NE b -> !(a EQ b)  */\n-\n-      if (inverse)\n-\temit_insn (base_comparison (mask, operands[4], operands[5]));\n-      else\n-\temit_insn (complimentary_comparison (mask, operands[5], operands[4]));\n-\n-      swap_bsl_operands = 1;\n-      break;\n-    case UNEQ:\n-      /* We check (a > b ||  b > a).  combining these comparisons give us\n-\t true iff !(a != b && a ORDERED b), swapping the operands to BSL\n-\t will then give us (a == b ||  a UNORDERED b) as intended.  */\n-\n-      emit_insn (gen_neon_vcgt<mode> (mask, operands[4], operands[5]));\n-      emit_insn (gen_neon_vcgt<mode> (tmp, operands[5], operands[4]));\n-      emit_insn (gen_ior<v_cmp_result>3 (mask, mask, tmp));\n-      swap_bsl_operands = 1;\n-      break;\n-    case UNORDERED:\n-       /* Operands are ORDERED iff (a > b || b >= a).\n-\t Swapping the operands to BSL will give the UNORDERED case.  */\n-     swap_bsl_operands = 1;\n-     /* Fall through.  */\n-    case ORDERED:\n-      emit_insn (gen_neon_vcgt<mode> (tmp, operands[4], operands[5]));\n-      emit_insn (gen_neon_vcge<mode> (mask, operands[5], operands[4]));\n-      emit_insn (gen_ior<v_cmp_result>3 (mask, mask, tmp));\n-      break;\n-    default:\n-      gcc_unreachable ();\n-    }\n+  arm_expand_vcond (operands, <V_cmp_result>mode);\n+  DONE;\n+})\n \n-  if (swap_bsl_operands)\n-    emit_insn (gen_neon_vbsl<mode> (operands[0], mask, operands[2],\n-\t\t\t\t    operands[1]));\n-  else\n-    emit_insn (gen_neon_vbsl<mode> (operands[0], mask, operands[1],\n-\t\t\t\t    operands[2]));\n+(define_expand \"vcond<V_cvtto><mode>\"\n+  [(set (match_operand:<V_CVTTO> 0 \"s_register_operand\")\n+\t(if_then_else:<V_CVTTO>\n+\t  (match_operator 3 \"comparison_operator\"\n+\t    [(match_operand:V32 4 \"s_register_operand\")\n+\t     (match_operand:V32 5 \"reg_or_zero_operand\")])\n+\t  (match_operand:<V_CVTTO> 1 \"s_register_operand\")\n+\t  (match_operand:<V_CVTTO> 2 \"s_register_operand\")))]\n+  \"TARGET_NEON && (!<Is_float_mode> || flag_unsafe_math_optimizations)\"\n+{\n+  arm_expand_vcond (operands, <V_cmp_result>mode);\n   DONE;\n })\n \n-(define_expand \"vcondu<mode><mode>\"\n-  [(set (match_operand:VDQIW 0 \"s_register_operand\")\n-\t(if_then_else:VDQIW\n+(define_expand \"vcondu<mode><v_cmp_result>\"\n+  [(set (match_operand:VDQW 0 \"s_register_operand\")\n+\t(if_then_else:VDQW\n \t  (match_operator 3 \"arm_comparison_operator\"\n-\t    [(match_operand:VDQIW 4 \"s_register_operand\")\n-\t     (match_operand:VDQIW 5 \"s_register_operand\")])\n-\t  (match_operand:VDQIW 1 \"s_register_operand\")\n-\t  (match_operand:VDQIW 2 \"s_register_operand\")))]\n+\t    [(match_operand:<V_cmp_result> 4 \"s_register_operand\")\n+\t     (match_operand:<V_cmp_result> 5 \"reg_or_zero_operand\")])\n+\t  (match_operand:VDQW 1 \"s_register_operand\")\n+\t  (match_operand:VDQW 2 \"s_register_operand\")))]\n   \"TARGET_NEON\"\n {\n-  rtx mask;\n-  int inverse = 0, immediate_zero = 0;\n-  \n-  mask = gen_reg_rtx (<V_cmp_result>mode);\n-  \n-  if (operands[5] == CONST0_RTX (<MODE>mode))\n-    immediate_zero = 1;\n-  else if (!REG_P (operands[5]))\n-    operands[5] = force_reg (<MODE>mode, operands[5]);\n-  \n-  switch (GET_CODE (operands[3]))\n-    {\n-    case GEU:\n-      emit_insn (gen_neon_vcgeu<mode> (mask, operands[4], operands[5]));\n-      break;\n-    \n-    case GTU:\n-      emit_insn (gen_neon_vcgtu<mode> (mask, operands[4], operands[5]));\n-      break;\n-    \n-    case EQ:\n-      emit_insn (gen_neon_vceq<mode> (mask, operands[4], operands[5]));\n-      break;\n-    \n-    case LEU:\n-      if (immediate_zero)\n-\temit_insn (gen_neon_vcle<mode> (mask, operands[4], operands[5]));\n-      else\n-\temit_insn (gen_neon_vcgeu<mode> (mask, operands[5], operands[4]));\n-      break;\n-    \n-    case LTU:\n-      if (immediate_zero)\n-        emit_insn (gen_neon_vclt<mode> (mask, operands[4], operands[5]));\n-      else\n-\temit_insn (gen_neon_vcgtu<mode> (mask, operands[5], operands[4]));\n-      break;\n-    \n-    case NE:\n-      emit_insn (gen_neon_vceq<mode> (mask, operands[4], operands[5]));\n-      inverse = 1;\n-      break;\n-    \n-    default:\n-      gcc_unreachable ();\n-    }\n-  \n-  if (inverse)\n-    emit_insn (gen_neon_vbsl<mode> (operands[0], mask, operands[2],\n-\t\t\t\t    operands[1]));\n-  else\n-    emit_insn (gen_neon_vbsl<mode> (operands[0], mask, operands[1],\n-\t\t\t\t    operands[2]));\n+  arm_expand_vcond (operands, <V_cmp_result>mode);\n+  DONE;\n+})\n \n+(define_expand \"vcond_mask_<mode><v_cmp_result>\"\n+  [(set (match_operand:VDQW 0 \"s_register_operand\")\n+\t(if_then_else:VDQW\n+\t  (match_operand:<V_cmp_result> 3 \"s_register_operand\")\n+\t  (match_operand:VDQW 1 \"s_register_operand\")\n+\t  (match_operand:VDQW 2 \"s_register_operand\")))]\n+  \"TARGET_NEON\"\n+{\n+  emit_insn (gen_neon_vbsl<mode> (operands[0], operands[3], operands[1],\n+\t\t\t\t  operands[2]));\n   DONE;\n })\n \n@@ -2601,7 +2448,7 @@\n \n ;; These may expand to an UNSPEC pattern when a floating point mode is used\n ;; without unsafe math optimizations.\n-(define_expand \"neon_vc<cmp_op><mode>\"\n+(define_expand \"@neon_vc<cmp_op><mode>\"\n   [(match_operand:<V_cmp_result> 0 \"s_register_operand\")\n      (neg:<V_cmp_result>\n        (COMPARISONS:VDQW (match_operand:VDQW 1 \"s_register_operand\")\n@@ -2641,7 +2488,7 @@\n   }\n )\n \n-(define_insn \"neon_vc<cmp_op><mode>_insn\"\n+(define_insn \"@neon_vc<cmp_op><mode>_insn\"\n   [(set (match_operand:<V_cmp_result> 0 \"s_register_operand\" \"=w,w\")\n         (neg:<V_cmp_result>\n           (COMPARISONS:<V_cmp_result>\n@@ -2685,7 +2532,7 @@\n   [(set_attr \"type\" \"neon_fp_compare_s<q>\")]\n )\n \n-(define_expand \"neon_vc<cmp_op><mode>\"\n+(define_expand \"@neon_vc<cmp_op><mode>\"\n  [(match_operand:<V_cmp_result> 0 \"s_register_operand\")\n   (neg:<V_cmp_result>\n    (COMPARISONS:VH\n@@ -2751,7 +2598,7 @@\n }\n  [(set_attr \"type\" \"neon_fp_compare_s<q>\")])\n \n-(define_insn \"neon_vc<cmp_op>u<mode>\"\n+(define_insn \"@neon_vc<code><mode>\"\n   [(set (match_operand:<V_cmp_result> 0 \"s_register_operand\" \"=w\")\n         (neg:<V_cmp_result>\n           (GTUGEU:<V_cmp_result>\n@@ -4708,7 +4555,7 @@ if (BYTES_BIG_ENDIAN)\n   [(set_attr \"type\" \"neon_bsl<q>\")]\n )\n \n-(define_expand \"neon_vbsl<mode>\"\n+(define_expand \"@neon_vbsl<mode>\"\n   [(set (match_operand:VDQX 0 \"s_register_operand\")\n         (unspec:VDQX [(match_operand:<V_cmp_result> 1 \"s_register_operand\")\n                       (match_operand:VDQX 2 \"s_register_operand\")"}, {"sha": "c915eca6dbec35856280bace6d3e132c6d04f07e", "filename": "gcc/testsuite/gcc.target/arm/neon-compare-1.c", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2978b3405884e38429c1937f416753ca88d3cd6/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon-compare-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2978b3405884e38429c1937f416753ca88d3cd6/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon-compare-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon-compare-1.c?ref=c2978b3405884e38429c1937f416753ca88d3cd6", "patch": "@@ -0,0 +1,84 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-O1\" }  */\n+/* { dg-add-options arm_neon } */\n+\n+#define COMPARE_REG(NAME, OP, TYPE) \\\n+  TYPE \\\n+  cmp_##NAME##_##TYPE##_reg (TYPE a, TYPE b) \\\n+  { \\\n+    return a OP b; \\\n+  }\n+\n+#define COMPARE_REG_AND_ZERO(NAME, OP, TYPE) \\\n+  COMPARE_REG (NAME, OP, TYPE) \\\n+  \\\n+  TYPE \\\n+  cmp_##NAME##_##TYPE##_zero (TYPE a) \\\n+  { \\\n+    return a OP (TYPE) {}; \\\n+  }\n+\n+#define COMPARE_TYPE(TYPE, COMPARE_ORDERED) \\\n+  COMPARE_REG_AND_ZERO (eq, ==, TYPE) \\\n+  COMPARE_REG_AND_ZERO (ne, !=, TYPE) \\\n+  COMPARE_ORDERED (lt, <, TYPE) \\\n+  COMPARE_ORDERED (le, <=, TYPE) \\\n+  COMPARE_ORDERED (gt, >, TYPE) \\\n+  COMPARE_ORDERED (ge, >=, TYPE)\n+\n+#define TEST_TYPE(NAME, ELEM, COMPARE_ORDERED) \\\n+  typedef ELEM NAME __attribute__((vector_size(16))); \\\n+  COMPARE_TYPE (NAME, COMPARE_ORDERED)\n+\n+TEST_TYPE (vs8, __INT8_TYPE__, COMPARE_REG_AND_ZERO)\n+TEST_TYPE (vu8, __UINT8_TYPE__, COMPARE_REG)\n+TEST_TYPE (vs16, __INT16_TYPE__, COMPARE_REG_AND_ZERO)\n+TEST_TYPE (vu16, __UINT16_TYPE__, COMPARE_REG)\n+TEST_TYPE (vs32, __INT32_TYPE__, COMPARE_REG_AND_ZERO)\n+TEST_TYPE (vu32, __UINT32_TYPE__, COMPARE_REG)\n+\n+/* { s8, u8 } x { eq, ne }.\n+/* { dg-final { scan-assembler-times {\\tvceq.i8\\tq[0-9]+, q[0-9]+, q[0-9]+\\n} 4 } } */\n+/* { dg-final { scan-assembler-times {\\tvceq.i8\\tq[0-9]+, q[0-9]+, #0\\n} 4 } } */\n+\n+/* { dg-final { scan-assembler-times {\\tvcgt.s8\\tq[0-9]+, q[0-9]+, q[0-9]+\\n} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tvcgt.s8\\tq[0-9]+, q[0-9]+, #0\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tvclt.s8\\tq[0-9]+, q[0-9]+, #0\\n} 1 } } */\n+\n+/* { dg-final { scan-assembler-times {\\tvcge.s8\\tq[0-9]+, q[0-9]+, q[0-9]+\\n} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tvcge.s8\\tq[0-9]+, q[0-9]+, #0\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tvcle.s8\\tq[0-9]+, q[0-9]+, #0\\n} 1 } } */\n+\n+/* { dg-final { scan-assembler-times {\\tvcgt.u8\\tq[0-9]+, q[0-9]+, q[0-9]+\\n} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tvcge.u8\\tq[0-9]+, q[0-9]+, q[0-9]+\\n} 2 } } */\n+\n+/* { s16, u16 } x { eq, ne }.\n+/* { dg-final { scan-assembler-times {\\tvceq.i16\\tq[0-9]+, q[0-9]+, q[0-9]+\\n} 4 } } */\n+/* { dg-final { scan-assembler-times {\\tvceq.i16\\tq[0-9]+, q[0-9]+, #0\\n} 4 } } */\n+\n+/* { dg-final { scan-assembler-times {\\tvcgt.s16\\tq[0-9]+, q[0-9]+, q[0-9]+\\n} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tvcgt.s16\\tq[0-9]+, q[0-9]+, #0\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tvclt.s16\\tq[0-9]+, q[0-9]+, #0\\n} 1 } } */\n+\n+/* { dg-final { scan-assembler-times {\\tvcge.s16\\tq[0-9]+, q[0-9]+, q[0-9]+\\n} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tvcge.s16\\tq[0-9]+, q[0-9]+, #0\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tvcle.s16\\tq[0-9]+, q[0-9]+, #0\\n} 1 } } */\n+\n+/* { dg-final { scan-assembler-times {\\tvcgt.u16\\tq[0-9]+, q[0-9]+, q[0-9]+\\n} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tvcge.u16\\tq[0-9]+, q[0-9]+, q[0-9]+\\n} 2 } } */\n+\n+/* { s32, u32 } x { eq, ne }.\n+/* { dg-final { scan-assembler-times {\\tvceq.i32\\tq[0-9]+, q[0-9]+, q[0-9]+\\n} 4 } } */\n+/* { dg-final { scan-assembler-times {\\tvceq.i32\\tq[0-9]+, q[0-9]+, #0\\n} 4 } } */\n+\n+/* { dg-final { scan-assembler-times {\\tvcgt.s32\\tq[0-9]+, q[0-9]+, q[0-9]+\\n} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tvcgt.s32\\tq[0-9]+, q[0-9]+, #0\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tvclt.s32\\tq[0-9]+, q[0-9]+, #0\\n} 1 } } */\n+\n+/* { dg-final { scan-assembler-times {\\tvcge.s32\\tq[0-9]+, q[0-9]+, q[0-9]+\\n} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tvcge.s32\\tq[0-9]+, q[0-9]+, #0\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tvcle.s32\\tq[0-9]+, q[0-9]+, #0\\n} 1 } } */\n+\n+/* { dg-final { scan-assembler-times {\\tvcgt.u32\\tq[0-9]+, q[0-9]+, q[0-9]+\\n} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tvcge.u32\\tq[0-9]+, q[0-9]+, q[0-9]+\\n} 2 } } */"}, {"sha": "559c5e5d8fc75978abefa4cfb3ed23d2822fe359", "filename": "gcc/testsuite/gcc.target/arm/neon-compare-2.c", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2978b3405884e38429c1937f416753ca88d3cd6/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon-compare-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2978b3405884e38429c1937f416753ca88d3cd6/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon-compare-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon-compare-2.c?ref=c2978b3405884e38429c1937f416753ca88d3cd6", "patch": "@@ -0,0 +1,45 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-O1 -funsafe-math-optimizations\" }  */\n+/* { dg-add-options arm_neon } */\n+\n+#ifndef ELEM_TYPE\n+#define ELEM_TYPE float\n+#endif\n+#ifndef INT_ELEM_TYPE\n+#define INT_ELEM_TYPE __INT32_TYPE__\n+#endif\n+\n+#define COMPARE(NAME, OP) \\\n+  int_vec \\\n+  cmp_##NAME##_reg (vec a, vec b) \\\n+  { \\\n+    return a OP b; \\\n+  } \\\n+  \\\n+  int_vec \\\n+  cmp_##NAME##_zero (vec a) \\\n+  { \\\n+    return a OP (vec) {}; \\\n+  }\n+\n+typedef INT_ELEM_TYPE int_vec __attribute__((vector_size(16)));\n+typedef ELEM_TYPE vec __attribute__((vector_size(16)));\n+\n+COMPARE (eq, ==)\n+COMPARE (ne, !=)\n+COMPARE (lt, <)\n+COMPARE (le, <=)\n+COMPARE (gt, >)\n+COMPARE (ge, >=)\n+\n+/* { dg-final { scan-assembler-times {\\tvceq.f32\\tq[0-9]+, q[0-9]+, q[0-9]+\\n} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tvceq.f32\\tq[0-9]+, q[0-9]+, #0\\n} 2 } } */\n+\n+/* { dg-final { scan-assembler-times {\\tvcgt.f32\\tq[0-9]+, q[0-9]+, q[0-9]+\\n} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tvcgt.f32\\tq[0-9]+, q[0-9]+, #0\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tvclt.f32\\tq[0-9]+, q[0-9]+, #0\\n} 1 } } */\n+\n+/* { dg-final { scan-assembler-times {\\tvcge.f32\\tq[0-9]+, q[0-9]+, q[0-9]+\\n} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tvcge.f32\\tq[0-9]+, q[0-9]+, #0\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tvcle.f32\\tq[0-9]+, q[0-9]+, #0\\n} 1 } } */"}, {"sha": "efbe79728a9ea6f731310b216133121fd59f9d28", "filename": "gcc/testsuite/gcc.target/arm/neon-compare-3.c", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2978b3405884e38429c1937f416753ca88d3cd6/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon-compare-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2978b3405884e38429c1937f416753ca88d3cd6/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon-compare-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon-compare-3.c?ref=c2978b3405884e38429c1937f416753ca88d3cd6", "patch": "@@ -0,0 +1,44 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-O1 -ftree-vectorize -funsafe-math-optimizations\" }  */\n+/* { dg-add-options arm_neon } */\n+\n+#define ult(a, b) (!__builtin_isgreaterequal (a, b))\n+#define ule(a, b) (!__builtin_isgreater (a, b))\n+#define ugt(a, b) (!__builtin_islessequal (a, b))\n+#define uge(a, b) (!__builtin_isless (a, b))\n+\n+int x[16];\n+float a[16];\n+float b[16];\n+\n+#define COMPARE(NAME) \\\n+  void \\\n+  cmp_##NAME##_reg (void) \\\n+  { \\\n+    for (int i = 0; i < 16; ++i) \\\n+      x[i] = NAME (a[i], b[i]) ? 2 : 0; \\\n+  } \\\n+  \\\n+  void \\\n+  cmp_##NAME##_zero (void) \\\n+  { \\\n+    for (int i = 0; i < 16; ++i) \\\n+      x[i] = NAME (a[i], 0) ? 2 : 0; \\\n+  }\n+\n+typedef int int_vec __attribute__((vector_size(16)));\n+typedef float vec __attribute__((vector_size(16)));\n+\n+COMPARE (ult)\n+COMPARE (ule)\n+COMPARE (ugt)\n+COMPARE (uge)\n+\n+/* { dg-final { scan-assembler-times {\\tvcgt.f32\\tq[0-9]+, q[0-9]+, q[0-9]+\\n} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tvcgt.f32\\tq[0-9]+, q[0-9]+, #0\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tvclt.f32\\tq[0-9]+, q[0-9]+, #0\\n} 1 } } */\n+\n+/* { dg-final { scan-assembler-times {\\tvcge.f32\\tq[0-9]+, q[0-9]+, q[0-9]+\\n} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tvcge.f32\\tq[0-9]+, q[0-9]+, #0\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tvcle.f32\\tq[0-9]+, q[0-9]+, #0\\n} 1 } } */"}, {"sha": "3f8cc906c6699b00d94fb0f574fc85f221576b26", "filename": "gcc/testsuite/gcc.target/arm/neon-compare-4.c", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2978b3405884e38429c1937f416753ca88d3cd6/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon-compare-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2978b3405884e38429c1937f416753ca88d3cd6/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon-compare-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon-compare-4.c?ref=c2978b3405884e38429c1937f416753ca88d3cd6", "patch": "@@ -0,0 +1,38 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-O1 -ftree-vectorize -funsafe-math-optimizations\" }  */\n+/* { dg-add-options arm_neon } */\n+\n+#define ordered(a, b) (!__builtin_isunordered (a, b))\n+#define unordered(a, b) (__builtin_isunordered (a, b))\n+\n+int x[16];\n+float a[16];\n+float b[16];\n+\n+#define COMPARE(NAME) \\\n+  void \\\n+  cmp_##NAME##_reg (void) \\\n+  { \\\n+    for (int i = 0; i < 16; ++i) \\\n+      x[i] = NAME (a[i], b[i]) ? 2 : 0; \\\n+  } \\\n+  \\\n+  void \\\n+  cmp_##NAME##_zero (void) \\\n+  { \\\n+    for (int i = 0; i < 16; ++i) \\\n+      x[i] = NAME (a[i], 0) ? 2 : 0; \\\n+  }\n+\n+typedef int int_vec __attribute__((vector_size(16)));\n+typedef float vec __attribute__((vector_size(16)));\n+\n+COMPARE (ordered)\n+COMPARE (unordered)\n+\n+/* { dg-final { scan-assembler-times {\\tvcgt.f32\\tq[0-9]+, q[0-9]+, q[0-9]+\\n} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tvcgt.f32\\tq[0-9]+, q[0-9]+, #0\\n} 2 } } */\n+\n+/* { dg-final { scan-assembler-times {\\tvcge.f32\\tq[0-9]+, q[0-9]+, q[0-9]+\\n} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tvcle.f32\\tq[0-9]+, q[0-9]+, #0\\n} 2 } } */"}, {"sha": "cb6428d3f089ec2edfe1163424cb60fd79ae59ac", "filename": "gcc/testsuite/gcc.target/arm/neon-compare-5.c", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2978b3405884e38429c1937f416753ca88d3cd6/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon-compare-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2978b3405884e38429c1937f416753ca88d3cd6/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon-compare-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon-compare-5.c?ref=c2978b3405884e38429c1937f416753ca88d3cd6", "patch": "@@ -0,0 +1,37 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target arm_neon_ok } */\n+/* { dg-options \"-O1 -ftree-vectorize -funsafe-math-optimizations\" }  */\n+/* { dg-add-options arm_neon } */\n+\n+#define uneq(a, b) (!__builtin_islessgreater (a, b))\n+/* RTL's LTGT is a signaling comparison.  */\n+#define ltgt(a, b) (a < b || b < a)\n+\n+int x[16];\n+float a[16];\n+float b[16];\n+\n+#define COMPARE(NAME) \\\n+  void \\\n+  cmp_##NAME##_reg (void) \\\n+  { \\\n+    for (int i = 0; i < 16; ++i) \\\n+      x[i] = NAME (a[i], b[i]) ? 2 : 0; \\\n+  } \\\n+  \\\n+  void \\\n+  cmp_##NAME##_zero (void) \\\n+  { \\\n+    for (int i = 0; i < 16; ++i) \\\n+      x[i] = NAME (a[i], 0) ? 2 : 0; \\\n+  }\n+\n+typedef int int_vec __attribute__((vector_size(16)));\n+typedef float vec __attribute__((vector_size(16)));\n+\n+COMPARE (uneq)\n+COMPARE (ltgt)\n+\n+/* { dg-final { scan-assembler-times {\\tvcgt.f32\\tq[0-9]+, q[0-9]+, q[0-9]+\\n} 4 } } */\n+/* { dg-final { scan-assembler-times {\\tvcgt.f32\\tq[0-9]+, q[0-9]+, #0\\n} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tvclt.f32\\tq[0-9]+, q[0-9]+, #0\\n} 2 } } */"}, {"sha": "9f601a169d1022a1acc8ae0628a1c78e790201ae", "filename": "gcc/testsuite/gcc.target/arm/neon-vcond-gt.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2978b3405884e38429c1937f416753ca88d3cd6/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon-vcond-gt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2978b3405884e38429c1937f416753ca88d3cd6/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon-vcond-gt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon-vcond-gt.c?ref=c2978b3405884e38429c1937f416753ca88d3cd6", "patch": "@@ -13,5 +13,5 @@ void foo (int ilast,float* w, float* w2)\n   }\n }\n \n-/* { dg-final { scan-assembler \"vcgt\\\\.f32\\[\\\\t \\]*q\\[0-9\\]+,\\[\\\\t \\]*q\\[0-9\\]+,\\[\\\\t \\]*q\\[0-9\\]+\" } } */\n+/* { dg-final { scan-assembler \"vclt\\\\.f32\\[\\\\t \\]*q\\[0-9\\]+,\\[\\\\t \\]*q\\[0-9\\]+,\\[\\\\t \\]*#0\" } } */\n /* { dg-final { scan-assembler \"vbsl|vbit|vbif\\[\\\\t \\]*q\\[0-9\\]+,\\[\\\\t \\]*q\\[0-9\\]+,\\[\\\\t \\]*q\\[0-9\\]+\" } } */"}, {"sha": "74bc22046ad76f8a165ee91bf5452a883cc23245", "filename": "gcc/testsuite/gcc.target/arm/neon-vcond-ltgt.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2978b3405884e38429c1937f416753ca88d3cd6/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon-vcond-ltgt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2978b3405884e38429c1937f416753ca88d3cd6/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon-vcond-ltgt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon-vcond-ltgt.c?ref=c2978b3405884e38429c1937f416753ca88d3cd6", "patch": "@@ -13,6 +13,7 @@ void foo (int ilast,float* w, float* w2)\n   }\n }\n \n-/* { dg-final { scan-assembler-times \"vcgt\\\\.f32\\[\\\\t \\]*q\\[0-9\\]+,\\[\\\\t \\]*q\\[0-9\\]+,\\[\\\\t \\]*q\\[0-9\\]+\" 2 } } */\n+/* { dg-final { scan-assembler \"vclt\\\\.f32\\[\\\\t \\]*q\\[0-9\\]+,\\[\\\\t \\]*q\\[0-9\\]+,\\[\\\\t \\]*#0\" } } */\n+/* { dg-final { scan-assembler \"vcgt\\\\.f32\\[\\\\t \\]*q\\[0-9\\]+,\\[\\\\t \\]*q\\[0-9\\]+,\\[\\\\t \\]*#0\" } } */\n /* { dg-final { scan-assembler \"vorr\\[\\\\t \\]*q\\[0-9\\]+,\\[\\\\t \\]*q\\[0-9\\]+,\\[\\\\t \\]*q\\[0-9\\]+\" } } */\n /* { dg-final { scan-assembler \"vbsl|vbit|vbif\\[\\\\t \\]*q\\[0-9\\]+,\\[\\\\t \\]*q\\[0-9\\]+,\\[\\\\t \\]*q\\[0-9\\]+\" } } */"}, {"sha": "8d3187541e221b6a1edd756f4d54c16ebf18f2c1", "filename": "gcc/testsuite/gcc.target/arm/neon-vcond-unordered.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2978b3405884e38429c1937f416753ca88d3cd6/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon-vcond-unordered.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2978b3405884e38429c1937f416753ca88d3cd6/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon-vcond-unordered.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fneon-vcond-unordered.c?ref=c2978b3405884e38429c1937f416753ca88d3cd6", "patch": "@@ -13,7 +13,7 @@ void foo (int ilast,float* w, float* w2)\n   }\n }\n \n-/* { dg-final { scan-assembler \"vcgt\\\\.f32\\[\\\\t \\]*q\\[0-9\\]+,\\[\\\\t \\]*q\\[0-9\\]+,\\[\\\\t \\]*q\\[0-9\\]+\" } } */\n-/* { dg-final { scan-assembler \"vcge\\\\.f32\\[\\\\t \\]*q\\[0-9\\]+,\\[\\\\t \\]*q\\[0-9\\]+,\\[\\\\t \\]*q\\[0-9\\]+\" } } */\n+/* { dg-final { scan-assembler \"vcgt\\\\.f32\\[\\\\t \\]*q\\[0-9\\]+,\\[\\\\t \\]*q\\[0-9\\]+,\\[\\\\t \\]*#0\" } } */\n+/* { dg-final { scan-assembler \"vcle\\\\.f32\\[\\\\t \\]*q\\[0-9\\]+,\\[\\\\t \\]*q\\[0-9\\]+,\\[\\\\t \\]*#0\" } } */\n /* { dg-final { scan-assembler \"vorr\\[\\\\t \\]*q\\[0-9\\]+,\\[\\\\t \\]*q\\[0-9\\]+,\\[\\\\t \\]*q\\[0-9\\]+\" } } */\n /* { dg-final { scan-assembler \"vbsl|vbit|vbif\\[\\\\t \\]*q\\[0-9\\]+,\\[\\\\t \\]*q\\[0-9\\]+,\\[\\\\t \\]*q\\[0-9\\]+\" } } */"}, {"sha": "15f0649f8aebdbce28016256df4bbd05d3a81d1a", "filename": "gcc/testsuite/lib/target-supports.exp", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2978b3405884e38429c1937f416753ca88d3cd6/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2978b3405884e38429c1937f416753ca88d3cd6/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp?ref=c2978b3405884e38429c1937f416753ca88d3cd6", "patch": "@@ -7233,6 +7233,8 @@ proc check_effective_target_vect_cond_mixed { } {\n       expr { [istarget i?86-*-*] || [istarget x86_64-*-*]\n \t     || [istarget aarch64*-*-*]\n \t     || [istarget powerpc*-*-*] \n+\t     || ([istarget arm*-*-*]\n+\t\t && [check_effective_target_arm_neon_ok])\n \t     || ([istarget mips*-*-*]\n \t\t && [et-is-effective-target mips_msa])\n \t     || ([istarget s390*-*-*]"}]}