{"sha": "a6ab9fc0872bbc3330490c0e3ad5d0a61dbe4458", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTZhYjlmYzA4NzJiYmMzMzMwNDkwYzBlM2FkNWQwYTYxZGJlNDQ1OA==", "commit": {"author": {"name": "J\"orn Rennecke", "email": "joern.rennecke@st.com", "date": "2006-01-30T15:07:43Z"}, "committer": {"name": "Joern Rennecke", "email": "amylaar@gcc.gnu.org", "date": "2006-01-30T15:07:43Z"}, "message": "re PR target/14798 (In case of SH target with -O2 option #pragma interrupt doesn't get resetted.)\n\nPR target/14798:\n\ngcc:\n\t* sh.c (pragma_interrupt, trap_exit, sp_switch): Remove variable.\n\t(pragma_trap, pragma_nosave_low_regs): Likewise.\n\t(current_function_anonymous_args): Likewise.\n\t(sh_deferred_function_attributes): New variable.\n\t(sh_deferred_function_attributes_tail): Likewise.\n\t(print_operand): For '@', look up trap_exit attribute.\n\t(calc_live_regs): Look up trapa_handler attribute.  For trapa\n\thandlers, save/restore fpscr, but don't do any other\n\tinterrupt-specific saves.\n\tDon't save r0..r7 if the nosave_low_regs attribute is in effect.\n\tFix check for partially saved registers to check for SHmedia.\n\t(sh_expand_prologue, sh_expand_epilogue): Look up sp_switch attribute.\n\t(sh_output_function_epilogue): Don't clear any of the removed\n\tvariables.\n\t(sh_insert_attributes): Don't check pragma_interrupt.\n\tInsert deferred attributes.  Check that interrupt attribute is\n\tpresent for other attributes that require its presence.\n\t(sh_attribute_table): Add new attributes trapa_handler and\n\tnosave_low_regs.\n\t(sh_handle_sp_switch_attribute, sh_handle_trap_exit_attribute):\n\tDon't check for pragma_interrupt.  Don't store argument.\n\t* sh.h (pragma_interrupt, sp_switch): Don't declare.\n\t(sh_deferred_function_attributes): Declare.\n\t(sh_deferred_function_attributes_tail): Likewise.\n\t* sh.md (sp_switch_1): Add operand.  Change generator caller.\n\t(sh_pr_interrupt, sh_pr_trapa, sh_pr_nosave_low_regs): Remove.\n\t(*return_i): Don't use when trap_exit attribute is in effect.\n\t(*return_trapa): New insn pattern.\n\t* sh-c.c: New file.\n\t* config.gcc (sh[123456ble]*-* | sh-*-*): New trailer stanza,\n\tsetting c_target_objs and cxx_target_objs.\n\t* t-sh: Add rule for sh-c.o.\ngcc/testsuite:\n\t* gcc.dg/pragma-isr.c: Added target sh[1234ble]*-*-*.\n\t* gcc.dg/pragma-isr2.c, gcc.dg/pragma-isr-trapa.c: New tests.\n\t* gcc.dg/pragma-isr-trapa2.c: Likewise.\n\t* gcc.dg/pragma-isr-nosave_low_regs.c: Likewise.\n\t* gcc.dg/pragma-isr-trap_exit.c: Likewise.\n\t* gcc.dg/attr-isr.c, gcc.dg/attr-isr-trapa.c: Likewise.\n\t* gcc.dg/attr-isr-trap_exit.c: Likewise.\n\t* gcc.dg/attr-isr-nosave_low_regs.c: Likewise.\n\nFrom-SVN: r110398", "tree": {"sha": "2c0dc139501a3b56003fa7a9d0a9f3e5ae212d8e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2c0dc139501a3b56003fa7a9d0a9f3e5ae212d8e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a6ab9fc0872bbc3330490c0e3ad5d0a61dbe4458", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a6ab9fc0872bbc3330490c0e3ad5d0a61dbe4458", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a6ab9fc0872bbc3330490c0e3ad5d0a61dbe4458", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a6ab9fc0872bbc3330490c0e3ad5d0a61dbe4458/comments", "author": null, "committer": null, "parents": [{"sha": "52a64bd38e2af65bef3c1c4f4d93e0477c56ec15", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/52a64bd38e2af65bef3c1c4f4d93e0477c56ec15", "html_url": "https://github.com/Rust-GCC/gccrs/commit/52a64bd38e2af65bef3c1c4f4d93e0477c56ec15"}], "stats": {"total": 534, "additions": 427, "deletions": 107}, "files": [{"sha": "0a44292cb05cfa6a2eeee8a909cdbf1726dd66fe", "filename": "gcc/ChangeLog", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6ab9fc0872bbc3330490c0e3ad5d0a61dbe4458/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6ab9fc0872bbc3330490c0e3ad5d0a61dbe4458/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a6ab9fc0872bbc3330490c0e3ad5d0a61dbe4458", "patch": "@@ -1,3 +1,39 @@\n+2006-01-30  J\"orn Rennecke <joern.rennecke@st.com>\n+\n+\tPR target/14798:\n+\t* sh.c (pragma_interrupt, trap_exit, sp_switch): Remove variable.\n+\t(pragma_trap, pragma_nosave_low_regs): Likewise.\n+\t(current_function_anonymous_args): Likewise.\n+\t(sh_deferred_function_attributes): New variable.\n+\t(sh_deferred_function_attributes_tail): Likewise.\n+\t(print_operand): For '@', look up trap_exit attribute.\n+\t(calc_live_regs): Look up trapa_handler attribute.  For trapa\n+\thandlers, save/restore fpscr, but don't do any other\n+\tinterrupt-specific saves.\n+\tDon't save r0..r7 if the nosave_low_regs attribute is in effect.\n+\tFix check for partially saved registers to check for SHmedia.\n+\t(sh_expand_prologue, sh_expand_epilogue): Look up sp_switch attribute.\n+\t(sh_output_function_epilogue): Don't clear any of the removed\n+\tvariables.\n+\t(sh_insert_attributes): Don't check pragma_interrupt.\n+\tInsert deferred attributes.  Check that interrupt attribute is\n+\tpresent for other attributes that require its presence.\n+\t(sh_attribute_table): Add new attributes trapa_handler and\n+\tnosave_low_regs.\n+\t(sh_handle_sp_switch_attribute, sh_handle_trap_exit_attribute):\n+\tDon't check for pragma_interrupt.  Don't store argument.\n+\t* sh.h (pragma_interrupt, sp_switch): Don't declare.\n+\t(sh_deferred_function_attributes): Declare.\n+\t(sh_deferred_function_attributes_tail): Likewise.\n+\t* sh.md (sp_switch_1): Add operand.  Change generator caller.\n+\t(sh_pr_interrupt, sh_pr_trapa, sh_pr_nosave_low_regs): Remove.\n+\t(*return_i): Don't use when trap_exit attribute is in effect.\n+\t(*return_trapa): New insn pattern.\n+\t* sh-c.c: New file.\n+\t* config.gcc (sh[123456ble]*-* | sh-*-*): New trailer stanza,\n+\tsetting c_target_objs and cxx_target_objs.\n+\t* t-sh: Add rule for sh-c.o.\n+\n 2006-01-30  Richard Guenther  <rguenther@suse.de>\n \n \tPR c++/23372"}, {"sha": "0ac27c342a5979716da8bd19a7c52c8e3c866439", "filename": "gcc/config.gcc", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6ab9fc0872bbc3330490c0e3ad5d0a61dbe4458/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6ab9fc0872bbc3330490c0e3ad5d0a61dbe4458/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=a6ab9fc0872bbc3330490c0e3ad5d0a61dbe4458", "patch": "@@ -2938,6 +2938,11 @@ case ${target} in\n                 fi\n \t\t;;\n \n+\tsh[123456ble]*-*-* | sh-*-*)\n+\t\tc_target_objs=\"${c_target_objs} sh-c.o\"\n+\t\tcxx_target_objs=\"${cxx_target_objs} sh-c.o\"\n+\t\t;;\n+\n \tsparc*-*-*)\n \t\t# Some standard aliases.\n \t\tcase x$with_cpu in"}, {"sha": "7b9ec1c1e4ddda7c8a726fa158e4830d9bdca492", "filename": "gcc/config/sh/sh-c.c", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6ab9fc0872bbc3330490c0e3ad5d0a61dbe4458/gcc%2Fconfig%2Fsh%2Fsh-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6ab9fc0872bbc3330490c0e3ad5d0a61dbe4458/gcc%2Fconfig%2Fsh%2Fsh-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh-c.c?ref=a6ab9fc0872bbc3330490c0e3ad5d0a61dbe4458", "patch": "@@ -0,0 +1,69 @@\n+/* Pragma handling for GCC for Renesas / SuperH SH.\n+   Copyright (C) 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,\n+   2003, 2004, 2005, 2006 Free Software Foundation, Inc.\n+   Contributed by Joern Rennecke <joern.rennecke@st.com>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"tree.h\"\n+#include \"tm_p.h\"\n+\n+/* Handle machine specific pragmas to be semi-compatible with Renesas\n+   compiler.  */\n+\n+/* Add ATTR to the attributes of the current function.  If there is no\n+   such function, save it to be added to the attributes of the next\n+   function.  */\n+static void\n+sh_add_function_attribute (const char *attr)\n+{\n+  tree id = get_identifier (attr);\n+\n+  if (current_function_decl)\n+    decl_attributes (&current_function_decl,\n+\t\t     tree_cons (id, NULL_TREE, NULL_TREE), 0);\n+  else\n+    {\n+      *sh_deferred_function_attributes_tail\n+\t= tree_cons (id, NULL_TREE, *sh_deferred_function_attributes_tail);\n+      sh_deferred_function_attributes_tail\n+\t= &TREE_CHAIN (*sh_deferred_function_attributes_tail);\n+    }\n+}\n+\n+void\n+sh_pr_interrupt (struct cpp_reader *pfile ATTRIBUTE_UNUSED)\n+{\n+  sh_add_function_attribute (\"interrupt_handler\");\n+}\n+\n+void\n+sh_pr_trapa (struct cpp_reader *pfile ATTRIBUTE_UNUSED)\n+{\n+  sh_add_function_attribute (\"trapa_handler\");\n+}\n+\n+void\n+sh_pr_nosave_low_regs (struct cpp_reader *pfile ATTRIBUTE_UNUSED)\n+{\n+  sh_add_function_attribute (\"nosave_low_regs\");\n+}"}, {"sha": "6dfe282f4d9eed497453c08a474e71178263bb49", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 106, "deletions": 92, "changes": 198, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6ab9fc0872bbc3330490c0e3ad5d0a61dbe4458/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6ab9fc0872bbc3330490c0e3ad5d0a61dbe4458/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=a6ab9fc0872bbc3330490c0e3ad5d0a61dbe4458", "patch": "@@ -70,35 +70,8 @@ int code_for_indirect_jump_scratch = CODE_FOR_indirect_jump_scratch;\n /* Set to 1 by expand_prologue() when the function is an interrupt handler.  */\n int current_function_interrupt;\n \n-/* ??? The pragma interrupt support will not work for SH3.  */\n-/* This is set by #pragma interrupt and #pragma trapa, and causes gcc to\n-   output code for the next function appropriate for an interrupt handler.  */\n-int pragma_interrupt;\n-\n-/* This is set by the trap_exit attribute for functions.   It specifies\n-   a trap number to be used in a trapa instruction at function exit\n-   (instead of an rte instruction).  */\n-int trap_exit;\n-\n-/* This is used by the sp_switch attribute for functions.  It specifies\n-   a variable holding the address of the stack the interrupt function\n-   should switch to/from at entry/exit.  */\n-rtx sp_switch;\n-\n-/* This is set by #pragma trapa, and is similar to the above, except that\n-   the compiler doesn't emit code to preserve all registers.  */\n-static int pragma_trapa;\n-\n-/* This is set by #pragma nosave_low_regs.  This is useful on the SH3,\n-   which has a separate set of low regs for User and Supervisor modes.\n-   This should only be used for the lowest level of interrupts.  Higher levels\n-   of interrupts must save the registers in case they themselves are\n-   interrupted.  */\n-int pragma_nosave_low_regs;\n-\n-/* This is used for communication between TARGET_SETUP_INCOMING_VARARGS and\n-   sh_expand_prologue.  */\n-int current_function_anonymous_args;\n+tree sh_deferred_function_attributes;\n+tree *sh_deferred_function_attributes_tail = &sh_deferred_function_attributes;\n \n /* Global variables for machine-dependent things.  */\n \n@@ -696,6 +669,8 @@ print_operand (FILE *stream, rtx x, int code)\n \n   switch (code)\n     {\n+      tree trapa_attr;\n+\n     case '.':\n       if (final_sequence\n \t  && ! INSN_ANNULLED_BRANCH_P (XVECEXP (final_sequence, 0, 0))\n@@ -706,8 +681,11 @@ print_operand (FILE *stream, rtx x, int code)\n       fprintf (stream, \"%s\", LOCAL_LABEL_PREFIX);\n       break;\n     case '@':\n-      if (trap_exit)\n-\tfprintf (stream, \"trapa #%d\", trap_exit);\n+      trapa_attr = lookup_attribute (\"trap_exit\",\n+\t\t\t\t      DECL_ATTRIBUTES (current_function_decl));\n+      if (trapa_attr)\n+\tfprintf (stream, \"trapa #%ld\",\n+\t\t (long) TREE_INT_CST_LOW (TREE_VALUE (TREE_VALUE (trapa_attr))));\n       else if (sh_cfun_interrupt_handler_p ())\n \tfprintf (stream, \"rte\");\n       else\n@@ -5418,10 +5396,16 @@ calc_live_regs (HARD_REG_SET *live_regs_mask)\n {\n   unsigned int reg;\n   int count;\n-  int interrupt_handler;\n+  tree attrs;\n+  bool interrupt_or_trapa_handler, trapa_handler, interrupt_handler;\n+  bool nosave_low_regs;\n   int pr_live, has_call;\n \n-  interrupt_handler = sh_cfun_interrupt_handler_p ();\n+  attrs = DECL_ATTRIBUTES (current_function_decl);\n+  interrupt_or_trapa_handler = sh_cfun_interrupt_handler_p ();\n+  trapa_handler = lookup_attribute (\"trapa_handler\", attrs) != NULL_TREE;\n+  interrupt_handler = interrupt_or_trapa_handler && ! trapa_handler;\n+  nosave_low_regs = lookup_attribute (\"nosave_low_regs\", attrs) != NULL_TREE;\n \n   CLEAR_HARD_REG_SET (*live_regs_mask);\n   if ((TARGET_SH4 || TARGET_SH2A_DOUBLE) && TARGET_FMOVD && interrupt_handler\n@@ -5432,7 +5416,7 @@ calc_live_regs (HARD_REG_SET *live_regs_mask)\n     for (count = 0, reg = FIRST_FP_REG; reg <= LAST_FP_REG; reg += 2)\n       if (regs_ever_live[reg] && regs_ever_live[reg+1]\n \t  && (! call_really_used_regs[reg]\n-\t      || (interrupt_handler && ! pragma_trapa))\n+\t      || interrupt_handler)\n \t  && ++count > 2)\n \t{\n \t  target_flags &= ~MASK_FPU_SINGLE;\n@@ -5470,14 +5454,15 @@ calc_live_regs (HARD_REG_SET *live_regs_mask)\n     {\n       if (reg == (TARGET_SHMEDIA ? PR_MEDIA_REG : PR_REG)\n \t  ? pr_live\n-\t  : (interrupt_handler && ! pragma_trapa)\n+\t  : interrupt_handler\n \t  ? (/* Need to save all the regs ever live.  */\n \t     (regs_ever_live[reg]\n \t      || (call_really_used_regs[reg]\n \t\t  && (! fixed_regs[reg] || reg == MACH_REG || reg == MACL_REG\n \t\t      || reg == PIC_OFFSET_TABLE_REGNUM)\n \t\t  && has_call)\n-\t      || (has_call && REGISTER_NATURAL_MODE (reg) == SImode\n+\t      || (TARGET_SHMEDIA && has_call\n+\t\t  && REGISTER_NATURAL_MODE (reg) == SImode\n \t\t  && (GENERAL_REGISTER_P (reg) || TARGET_REGISTER_P (reg))))\n \t     && reg != STACK_POINTER_REGNUM && reg != ARG_POINTER_REGNUM\n \t     && reg != RETURN_ADDRESS_POINTER_REGNUM\n@@ -5489,7 +5474,9 @@ calc_live_regs (HARD_REG_SET *live_regs_mask)\n \t      && flag_pic\n \t      && current_function_args_info.call_cookie\n \t      && reg == PIC_OFFSET_TABLE_REGNUM)\n-\t     || (regs_ever_live[reg] && ! call_really_used_regs[reg])\n+\t     || (regs_ever_live[reg]\n+\t\t && (!call_really_used_regs[reg]\n+\t\t     || (trapa_handler && reg == FPSCR_REG && TARGET_FPU_ANY)))\n \t     || (current_function_calls_eh_return\n \t\t && (reg == EH_RETURN_DATA_REGNO (0)\n \t\t     || reg == EH_RETURN_DATA_REGNO (1)\n@@ -5521,6 +5508,8 @@ calc_live_regs (HARD_REG_SET *live_regs_mask)\n \t\t}\n \t    }\n \t}\n+      if (nosave_low_regs && reg == R8_REG)\n+\tbreak;\n     }\n   /* If we have a target register optimization pass after prologue / epilogue\n      threading, we need to assume all target registers will be live even if\n@@ -5724,6 +5713,8 @@ sh_expand_prologue (void)\n   int d_rounding = 0;\n   int save_flags = target_flags;\n   int pretend_args;\n+  tree sp_switch_attr\n+    = lookup_attribute (\"sp_switch\", DECL_ATTRIBUTES (current_function_decl));\n \n   current_function_interrupt = sh_cfun_interrupt_handler_p ();\n \n@@ -5813,8 +5804,16 @@ sh_expand_prologue (void)\n     }\n \n   /* If we're supposed to switch stacks at function entry, do so now.  */\n-  if (sp_switch)\n-    emit_insn (gen_sp_switch_1 ());\n+  if (sp_switch_attr)\n+    {\n+      /* The argument specifies a variable holding the address of the\n+\t stack the interrupt function should switch to/from at entry/exit.  */\n+      const char *s\n+\t= ggc_strdup (TREE_STRING_POINTER (TREE_VALUE (sp_switch_attr)));\n+      rtx sp_switch = gen_rtx_SYMBOL_REF (Pmode, s);\n+\n+      emit_insn (gen_sp_switch_1 (sp_switch));\n+    }\n \n   d = calc_live_regs (&live_regs_mask);\n   /* ??? Maybe we could save some switching if we can move a mode switch\n@@ -6333,7 +6332,7 @@ sh_expand_epilogue (bool sibcall_p)\n \t\t\t EH_RETURN_STACKADJ_RTX));\n \n   /* Switch back to the normal stack if necessary.  */\n-  if (sp_switch)\n+  if (lookup_attribute (\"sp_switch\", DECL_ATTRIBUTES (current_function_decl)))\n     emit_insn (gen_sp_switch_2 ());\n \n   /* Tell flow the insn that pops PR isn't dead.  */\n@@ -6435,9 +6434,7 @@ static void\n sh_output_function_epilogue (FILE *file ATTRIBUTE_UNUSED,\n \t\t\t     HOST_WIDE_INT size ATTRIBUTE_UNUSED)\n {\n-  trap_exit = pragma_interrupt = pragma_trapa = pragma_nosave_low_regs = 0;\n   sh_need_epilogue_known = 0;\n-  sp_switch = NULL_RTX;\n }\n \n static rtx\n@@ -7446,42 +7443,69 @@ initial_elimination_offset (int from, int to)\n     return total_auto_space;\n }\n \f\n-/* Handle machine specific pragmas to be semi-compatible with Renesas\n-   compiler.  */\n-\n-void\n-sh_pr_interrupt (struct cpp_reader *pfile ATTRIBUTE_UNUSED)\n-{\n-  pragma_interrupt = 1;\n-}\n-\n-void\n-sh_pr_trapa (struct cpp_reader *pfile ATTRIBUTE_UNUSED)\n-{\n-  pragma_interrupt = pragma_trapa = 1;\n-}\n-\n-void\n-sh_pr_nosave_low_regs (struct cpp_reader *pfile ATTRIBUTE_UNUSED)\n-{\n-  pragma_nosave_low_regs = 1;\n-}\n-\n-/* Generate 'handle_interrupt' attribute for decls */\n-\n+/* Insert any deferred function attributes from earlier pragmas.  */\n static void\n sh_insert_attributes (tree node, tree *attributes)\n {\n-  if (! pragma_interrupt\n-      || TREE_CODE (node) != FUNCTION_DECL)\n+  tree attrs;\n+\n+  if (TREE_CODE (node) != FUNCTION_DECL)\n     return;\n \n   /* We are only interested in fields.  */\n   if (!DECL_P (node))\n     return;\n \n-  /* Add a 'handle_interrupt' attribute.  */\n-  * attributes = tree_cons (get_identifier (\"interrupt_handler\"), NULL, * attributes);\n+  /* Append the attributes to the deferred attributes.  */\n+  *sh_deferred_function_attributes_tail = *attributes;\n+  attrs = sh_deferred_function_attributes;\n+  if (!attrs)\n+    return;\n+\n+  /* Some attributes imply or require the interrupt attribute.  */\n+  if (!lookup_attribute (\"interrupt_handler\", attrs)\n+      && !lookup_attribute (\"interrupt_handler\", DECL_ATTRIBUTES (node)))\n+    {\n+      /* If we have a trapa_handler, but no interrupt_handler attribute,\n+\t insert an interrupt_handler attribute.  */\n+      if (lookup_attribute (\"trapa_handler\", attrs) != NULL_TREE)\n+\t/* We can't use sh_pr_interrupt here because that's not in the\n+\t   java frontend.  */\n+\tattrs\n+\t  = tree_cons (get_identifier(\"interrupt_handler\"), NULL_TREE, attrs);\n+      /* However, for sp_switch, trap_exit and nosave_low_regs, if the\n+\t interrupt attribute is missing, we ignore the attribute and warn.  */\n+      else if (lookup_attribute (\"sp_switch\", attrs)\n+\t       || lookup_attribute (\"trap_exit\", attrs)\n+\t       || lookup_attribute (\"nosave_low_regs\", attrs))\n+\t{\n+\t  tree *tail;\n+\n+\t  for (tail = attributes; attrs; attrs = TREE_CHAIN (attrs))\n+\t    {\n+\t      if (is_attribute_p (\"sp_switch\", TREE_PURPOSE (attrs))\n+\t\t  || is_attribute_p (\"trap_exit\", TREE_PURPOSE (attrs))\n+\t\t  || is_attribute_p (\"nosave_low_regs\", TREE_PURPOSE (attrs)))\n+\t\twarning (OPT_Wattributes,\n+\t\t\t \"%qs attribute only applies to interrupt functions\",\n+\t\t\t IDENTIFIER_POINTER (TREE_PURPOSE (attrs)));\n+\t      else\n+\t\t{\n+\t\t  *tail = tree_cons (TREE_PURPOSE (attrs), NULL_TREE,\n+\t\t\t\t     NULL_TREE);\n+\t\t  tail = &TREE_CHAIN (*tail);\n+\t\t}\n+\t    }\n+\t  attrs = *attributes;\n+\t}\n+    }\n+\n+  /* Install the processed list.  */\n+  *attributes = attrs;\n+\n+  /* Clear deferred attributes.  */\n+  sh_deferred_function_attributes = NULL_TREE;\n+  sh_deferred_function_attributes_tail = &sh_deferred_function_attributes;\n \n   return;\n }\n@@ -7490,12 +7514,21 @@ sh_insert_attributes (tree node, tree *attributes)\n \n    interrupt_handler -- specifies this function is an interrupt handler.\n \n+   trapa_handler - like above, but don't save all registers.\n+\n    sp_switch -- specifies an alternate stack for an interrupt handler\n    to run on.\n \n    trap_exit -- use a trapa to exit an interrupt function instead of\n    an rte instruction.\n \n+   nosave_low_regs - don't save r0..r7 in an interrupt handler.\n+     This is useful on the SH3 and upwards,\n+     which has a separate set of low regs for User and Supervisor modes.\n+     This should only be used for the lowest level of interrupts.  Higher levels\n+     of interrupts must save the registers in case they themselves are\n+     interrupted.\n+\n    renesas -- use Renesas calling/layout conventions (functions and\n    structures).\n \n@@ -7508,6 +7541,8 @@ const struct attribute_spec sh_attribute_table[] =\n   { \"sp_switch\",         1, 1, true,  false, false, sh_handle_sp_switch_attribute },\n   { \"trap_exit\",         1, 1, true,  false, false, sh_handle_trap_exit_attribute },\n   { \"renesas\",           0, 0, false, true, false, sh_handle_renesas_attribute },\n+  { \"trapa_handler\",     0, 0, true,  false, false, sh_handle_interrupt_handler_attribute },\n+  { \"nosave_low_regs\",   0, 0, true,  false, false, sh_handle_interrupt_handler_attribute },\n #ifdef SYMBIAN\n   /* Symbian support adds three new attributes:\n      dllexport - for exporting a function/variable that will live in a dll\n@@ -7557,25 +7592,13 @@ sh_handle_sp_switch_attribute (tree *node, tree name, tree args,\n \t       IDENTIFIER_POINTER (name));\n       *no_add_attrs = true;\n     }\n-  else if (!pragma_interrupt)\n-    {\n-      /* The sp_switch attribute only has meaning for interrupt functions.  */\n-      warning (OPT_Wattributes, \"%qs attribute only applies to \"\n-\t       \"interrupt functions\", IDENTIFIER_POINTER (name));\n-      *no_add_attrs = true;\n-    }\n   else if (TREE_CODE (TREE_VALUE (args)) != STRING_CST)\n     {\n       /* The argument must be a constant string.  */\n       warning (OPT_Wattributes, \"%qs attribute argument not a string constant\",\n \t       IDENTIFIER_POINTER (name));\n       *no_add_attrs = true;\n     }\n-  else\n-    {\n-      const char *s = ggc_strdup (TREE_STRING_POINTER (TREE_VALUE (args)));\n-      sp_switch = gen_rtx_SYMBOL_REF (VOIDmode, s);\n-    }\n \n   return NULL_TREE;\n }\n@@ -7592,24 +7615,15 @@ sh_handle_trap_exit_attribute (tree *node, tree name, tree args,\n \t       IDENTIFIER_POINTER (name));\n       *no_add_attrs = true;\n     }\n-  else if (!pragma_interrupt)\n-    {\n-      /* The trap_exit attribute only has meaning for interrupt functions.  */\n-      warning (OPT_Wattributes, \"%qs attribute only applies to \"\n-\t       \"interrupt functions\", IDENTIFIER_POINTER (name));\n-      *no_add_attrs = true;\n-    }\n+  /* The argument specifies a trap number to be used in a trapa instruction\n+     at function exit (instead of an rte instruction).  */\n   else if (TREE_CODE (TREE_VALUE (args)) != INTEGER_CST)\n     {\n       /* The argument must be a constant integer.  */\n       warning (OPT_Wattributes, \"%qs attribute argument not an \"\n \t       \"integer constant\", IDENTIFIER_POINTER (name));\n       *no_add_attrs = true;\n     }\n-  else\n-    {\n-      trap_exit = TREE_INT_CST_LOW (TREE_VALUE (args));\n-    }\n \n   return NULL_TREE;\n }"}, {"sha": "72cd56391bb5ca5dc457bec21284a0ba2f6ca103", "filename": "gcc/config/sh/sh.h", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6ab9fc0872bbc3330490c0e3ad5d0a61dbe4458/gcc%2Fconfig%2Fsh%2Fsh.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6ab9fc0872bbc3330490c0e3ad5d0a61dbe4458/gcc%2Fconfig%2Fsh%2Fsh.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.h?ref=a6ab9fc0872bbc3330490c0e3ad5d0a61dbe4458", "patch": "@@ -3277,18 +3277,13 @@ extern enum mdep_reorg_phase_e mdep_reorg_phase;\n   c_register_pragma (0, \"nosave_low_regs\", sh_pr_nosave_low_regs);\t\\\n } while (0)\n \n-/* Set when processing a function with pragma interrupt turned on.  */\n-\n-extern int pragma_interrupt;\n+extern tree sh_deferred_function_attributes;\n+extern tree *sh_deferred_function_attributes_tail;\n \n /* Set when processing a function with interrupt attribute.  */\n \n extern int current_function_interrupt;\n \n-/* Set to an RTX containing the address of the stack to switch to\n-   for interrupt functions.  */\n-extern struct rtx_def *sp_switch;\n-\n \f\n /* Instructions with unfilled delay slots take up an\n    extra two bytes for the nop in the delay slot."}, {"sha": "e2e477f2a572ebe561d4cfbec7af3512cc2930ad", "filename": "gcc/config/sh/sh.md", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6ab9fc0872bbc3330490c0e3ad5d0a61dbe4458/gcc%2Fconfig%2Fsh%2Fsh.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6ab9fc0872bbc3330490c0e3ad5d0a61dbe4458/gcc%2Fconfig%2Fsh%2Fsh.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.md?ref=a6ab9fc0872bbc3330490c0e3ad5d0a61dbe4458", "patch": "@@ -8781,11 +8781,21 @@ mov.l\\\\t1f,r0\\\\n\\\\\n   \"TARGET_SH1 && ! (TARGET_SHCOMPACT\n \t\t    && (current_function_args_info.call_cookie\n \t\t\t& CALL_COOKIE_RET_TRAMP (1)))\n-   && reload_completed\"\n+   && reload_completed\n+   && lookup_attribute (\\\"trap_exit\\\",\n+\t\t\tDECL_ATTRIBUTES (current_function_decl)) == NULL_TREE\"\n   \"%@\t%#\"\n   [(set_attr \"type\" \"return\")\n    (set_attr \"needs_delay_slot\" \"yes\")])\n \n+;; trapa has no delay slot.\n+(define_insn \"*return_trapa\"\n+  [(return)]\n+  \"TARGET_SH1 && !TARGET_SHCOMPACT\n+   && reload_completed\"\n+  \"%@\"\n+  [(set_attr \"type\" \"return\")])\n+\n (define_expand \"shcompact_return_tramp\"\n   [(return)]\n   \"TARGET_SHCOMPACT\n@@ -11209,15 +11219,12 @@ mov.l\\\\t1f,r0\\\\n\\\\\n \n ;; Switch to a new stack with its address in sp_switch (a SYMBOL_REF).  */\n (define_insn \"sp_switch_1\"\n-  [(const_int 1)]\n+  [(const_int 1) (match_operand:SI 0 \"symbol_ref_operand\" \"s\")]\n   \"TARGET_SH1\"\n   \"*\n {\n-  rtx xoperands[1];\n-\n-  xoperands[0] = sp_switch;\n-  output_asm_insn (\\\"mov.l r0,@-r15\\;mov.l %0,r0\\\", xoperands);\n-  output_asm_insn (\\\"mov.l @r0,r0\\;mov.l r15,@-r0\\\", xoperands);\n+  output_asm_insn (\\\"mov.l r0,@-r15\\;mov.l %0,r0\\\", operands);\n+  output_asm_insn (\\\"mov.l @r0,r0\\;mov.l r15,@-r0\\\", operands);\n   return \\\"mov r0,r15\\\";\n }\"\n   [(set_attr \"length\" \"10\")])"}, {"sha": "db86ad18c1de5d141bd6f3fd6e18291ce5ebb2f8", "filename": "gcc/config/sh/t-sh", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6ab9fc0872bbc3330490c0e3ad5d0a61dbe4458/gcc%2Fconfig%2Fsh%2Ft-sh", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6ab9fc0872bbc3330490c0e3ad5d0a61dbe4458/gcc%2Fconfig%2Fsh%2Ft-sh", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Ft-sh?ref=a6ab9fc0872bbc3330490c0e3ad5d0a61dbe4458", "patch": "@@ -1,3 +1,7 @@\n+sh-c.o: $(srcdir)/config/sh/sh-c.c \\\n+  $(CONFIG_H) $(SYSTEM_H) $(TREE_H) $(TM_H) $(TM_P_H) coretypes.h\n+\t$(CC) -c $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) $(srcdir)/config/sh/sh-c.c\n+\n LIB1ASMSRC = sh/lib1funcs.asm\n LIB1ASMFUNCS = _ashiftrt _ashiftrt_n _ashiftlt _lshiftrt _movmem \\\n   _movmem_i4 _mulsi3 _sdivsi3 _sdivsi3_i4 _udivsi3 _udivsi3_i4 _set_fpscr \\"}, {"sha": "56b8eae371caf3d423ffeb4472e1f38e6ec285b3", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6ab9fc0872bbc3330490c0e3ad5d0a61dbe4458/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6ab9fc0872bbc3330490c0e3ad5d0a61dbe4458/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=a6ab9fc0872bbc3330490c0e3ad5d0a61dbe4458", "patch": "@@ -1,3 +1,15 @@\n+2006-01-30  J\"orn Rennecke <joern.rennecke@st.com>\n+\n+\tPR target/14798:\n+\t* gcc.dg/pragma-isr.c: Added target sh[1234ble]*-*-*.\n+\t* gcc.dg/pragma-isr2.c, gcc.dg/pragma-isr-trapa.c: New tests.\n+\t* gcc.dg/pragma-isr-trapa2.c: Likewise.\n+\t* gcc.dg/pragma-isr-nosave_low_regs.c: Likewise.\n+\t* gcc.dg/pragma-isr-trap_exit.c: Likewise.\n+\t* gcc.dg/attr-isr.c, gcc.dg/attr-isr-trapa.c: Likewise.\n+\t* gcc.dg/attr-isr-trap_exit.c: Likewise.\n+\t* gcc.dg/attr-isr-nosave_low_regs.c: Likewise.\n+\n 2006-01-30  Richard Guenther  <rguenther@suse.de>\n \n \tPR c++/23372"}, {"sha": "5f3acdf3d786cd079dc20509fa122424f8b02267", "filename": "gcc/testsuite/gcc.dg/attr-isr-nosave_low_regs.c", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6ab9fc0872bbc3330490c0e3ad5d0a61dbe4458/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-isr-nosave_low_regs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6ab9fc0872bbc3330490c0e3ad5d0a61dbe4458/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-isr-nosave_low_regs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-isr-nosave_low_regs.c?ref=a6ab9fc0872bbc3330490c0e3ad5d0a61dbe4458", "patch": "@@ -0,0 +1,28 @@\n+/* { dg-do compile { target sh-*-* sh[1234ble]*-*-*} } */\n+/* { dg-options \"-O\" } */\n+\n+extern void bar ();\n+\n+void foo ()\n+{\n+}\n+\n+#pragma interrupt\n+void ( __attribute__ ((nosave_low_regs)) isr) ()\n+{\n+  bar ();\n+}\n+\n+void delay(int a)\n+{\n+}\n+\n+/* { dg-final { scan-assembler-times \"rte\" 1} } */\n+/* A call will clobber all call-saved registers, but because of\n+   #pragma nosave_low_regs, r0..r7 need not be saved/restored.\n+   One of these registers will also do fine to hold the function address.\n+   Call-saved registers r8..r13 also don't need to be restored.  */\n+/* { dg-final { scan-assembler-not \"\\[^f\\]r\\[0-9\\]\\[ \\t\\]*,\" } } */\n+/* { dg-final { scan-assembler-not \"\\[^f\\]r\\[89\\]\" } } */\n+/* { dg-final { scan-assembler-not \"\\[^f\\]r1\\[,0-3\\]\" } } */\n+/* { dg-final { scan-assembler-times \"macl\" 2} } */"}, {"sha": "880db37ce73bcd118066ad92d5b01f2bc0625ebe", "filename": "gcc/testsuite/gcc.dg/attr-isr-trap_exit.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6ab9fc0872bbc3330490c0e3ad5d0a61dbe4458/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-isr-trap_exit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6ab9fc0872bbc3330490c0e3ad5d0a61dbe4458/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-isr-trap_exit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-isr-trap_exit.c?ref=a6ab9fc0872bbc3330490c0e3ad5d0a61dbe4458", "patch": "@@ -0,0 +1,23 @@\n+/* { dg-do compile { target sh-*-* sh[1234ble]*-*-*} } */\n+/* { dg-options \"-O\" } */\n+/* Check that trapa / interrput_handler attributes can paired in\n+   either order.  */\n+void h0() __attribute__ ((trap_exit (4))) __attribute__ ((interrupt_handler));\n+void h1() __attribute__ ((interrupt_handler)) __attribute__ ((trap_exit (5)));\n+\n+void foo ()\n+{\n+}\n+\n+void h0 () {}\n+/* { dg-final { scan-assembler \"trapa\\[ \\t\\]\\[ \\t\\]*#4\"} } */\n+/* { dg-final { scan-assembler-times \"trapa\" 1} } */\n+\n+void delay(int a)\n+{\n+}\n+int main()\n+{\n+  return 0;\n+}\n+"}, {"sha": "d17680589f8c96867aed11ffa5406e2fb9aa1e32", "filename": "gcc/testsuite/gcc.dg/attr-isr-trapa.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6ab9fc0872bbc3330490c0e3ad5d0a61dbe4458/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-isr-trapa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6ab9fc0872bbc3330490c0e3ad5d0a61dbe4458/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-isr-trapa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-isr-trapa.c?ref=a6ab9fc0872bbc3330490c0e3ad5d0a61dbe4458", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do compile { target sh-*-* sh[1234ble]*-*-*} } */\n+/* { dg-options \"-O\" } */\n+extern void foo ();\n+\n+void\n+(__attribute__ ((trapa_handler)) isr) ()\n+{\n+  foo ();\n+}\n+\n+/* { dg-final { scan-assembler-times \"rte\" 1} } */\n+/* No interrupt-specific saves should be needed.  /\n+/* { dg-final { scan-assembler-not \"\\[^f\\]r\\[0-7\\]\\[ \\t,\\]\\[^\\n\\]*r15\" } } */\n+/* { dg-final { scan-assembler-not \"@r15\\[^\\n\\]*\\[^f\\]r\\[0-7\\]\\n\" } } */\n+/* { dg-final { scan-assembler-not \"\\[^f\\]r\\[8-9\\]\" } } */\n+/* { dg-final { scan-assembler-not \"\\[^f\\]r1\\[,0-3\\]\" } } */\n+/* { dg-final { scan-assembler-not \"macl\" } } */"}, {"sha": "113ac21d43cc1e5b384c5810f1e02e3f87e63950", "filename": "gcc/testsuite/gcc.dg/attr-isr.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6ab9fc0872bbc3330490c0e3ad5d0a61dbe4458/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-isr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6ab9fc0872bbc3330490c0e3ad5d0a61dbe4458/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-isr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-isr.c?ref=a6ab9fc0872bbc3330490c0e3ad5d0a61dbe4458", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-do compile { target sh-*-* sh[1234ble]*-*-*} } */\n+/* { dg-options \"-O\" } */\n+extern void foo ();\n+\n+void\n+(__attribute ((interrupt_handler)) isr)()\n+{\n+  foo ();\n+}\n+\n+/* { dg-final { scan-assembler-times \"rte\" 1} } */\n+/* The call will clobber r0..r7, which will need not be saved/restored.\n+   One of these registers will do fine to hold the function address,\n+   hence the all-saved registers r8..r13 don't need to be restored.  */\n+/* { dg-final { scan-assembler-times \"r15\\[+\\],\\[ \\t\\]*r\\[0-9\\]\\[ \\t\\]*\\n\" 8 } } */\n+/* { dg-final { scan-assembler-times \"\\[^f\\]r\\[0-9\\]\\[ \\t\\]*,\" 8 } } */\n+/* { dg-final { scan-assembler-not \"\\[^f\\]r1\\[0-3\\]\" } } */\n+/* { dg-final { scan-assembler-times \"macl\" 2} } */"}, {"sha": "5e049224a7eb28d422cb22fee848f3ef107863c8", "filename": "gcc/testsuite/gcc.dg/pragma-isr-nosave_low_regs.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6ab9fc0872bbc3330490c0e3ad5d0a61dbe4458/gcc%2Ftestsuite%2Fgcc.dg%2Fpragma-isr-nosave_low_regs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6ab9fc0872bbc3330490c0e3ad5d0a61dbe4458/gcc%2Ftestsuite%2Fgcc.dg%2Fpragma-isr-nosave_low_regs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpragma-isr-nosave_low_regs.c?ref=a6ab9fc0872bbc3330490c0e3ad5d0a61dbe4458", "patch": "@@ -0,0 +1,20 @@\n+/* { dg-do compile { target sh-*-* sh[1234ble]*-*-*} } */\n+/* { dg-options \"-O\" } */\n+extern void foo ();\n+#pragma interrupt\n+#pragma nosave_low_regs\n+void\n+isr()\n+{\n+  foo ();\n+}\n+\n+/* { dg-final { scan-assembler-times \"rte\" 1} } */\n+/* A call will clobber all call-saved registers, but because of\n+   #pragma nosave_low_regs, r0..r7 need not be saved/restored.\n+   One of these registers will also do fine to hold the function address.\n+   Call-saved registers r8..r13 also don't need to be restored.  */\n+/* { dg-final { scan-assembler-not \"\\[^f\\]r\\[0-9\\]\\[ \\t\\]*,\" } } */\n+/* { dg-final { scan-assembler-not \"\\[^f\\]r\\[89\\]\" } } */\n+/* { dg-final { scan-assembler-not \"\\[^f\\]r1\\[,0-3\\]\" } } */\n+/* { dg-final { scan-assembler-times \"macl\" 2} } */"}, {"sha": "9b3233a36b552104430a53fb0145289ddcd9fadf", "filename": "gcc/testsuite/gcc.dg/pragma-isr-trap_exit.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6ab9fc0872bbc3330490c0e3ad5d0a61dbe4458/gcc%2Ftestsuite%2Fgcc.dg%2Fpragma-isr-trap_exit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6ab9fc0872bbc3330490c0e3ad5d0a61dbe4458/gcc%2Ftestsuite%2Fgcc.dg%2Fpragma-isr-trap_exit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpragma-isr-trap_exit.c?ref=a6ab9fc0872bbc3330490c0e3ad5d0a61dbe4458", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do compile { target sh-*-* sh[1234ble]*-*-*} } */\n+/* { dg-options \"-O\" } */\n+/* This test case will check whether trapa is generated only for isr.  */\n+#pragma interrupt\n+void isr() __attribute__ ((trap_exit (4)));\n+void isr()\n+{\n+}\n+void delay(int a)\n+{\n+}\n+int main()\n+{\n+  return 0;\n+}\n+\n+/* { dg-final { scan-assembler-times \"trapa\\[ \\t\\]\\[ \\t\\]*#4\" 1} } */"}, {"sha": "cd019d6e9cfc7b561b68de5461985dfb44d826ba", "filename": "gcc/testsuite/gcc.dg/pragma-isr-trapa.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6ab9fc0872bbc3330490c0e3ad5d0a61dbe4458/gcc%2Ftestsuite%2Fgcc.dg%2Fpragma-isr-trapa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6ab9fc0872bbc3330490c0e3ad5d0a61dbe4458/gcc%2Ftestsuite%2Fgcc.dg%2Fpragma-isr-trapa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpragma-isr-trapa.c?ref=a6ab9fc0872bbc3330490c0e3ad5d0a61dbe4458", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do compile { target sh-*-* sh[1234ble]*-*-*} } */\n+/* { dg-options \"-O\" } */\n+extern void foo ();\n+#pragma trapa\n+void\n+isr()\n+{\n+  foo ();\n+}\n+\n+/* { dg-final { scan-assembler-times \"rte\" 1} } */\n+/* No interrupt-specific saves should be needed.  /\n+/* { dg-final { scan-assembler-not \"r\\[0-7\\]\\[ \\t,\\]\\[^\\n\\]*r15\" } } */\n+/* { dg-final { scan-assembler-not \"@r15\\[^\\n\\]*r\\[0-7\\]\\n\" } } */\n+/* { dg-final { scan-assembler-not \"r\\[8-9\\]\" } } */\n+/* { dg-final { scan-assembler-not \"r1\\[,0-3\\]\" } } */\n+/* { dg-final { scan-assembler-not \"macl\" } } */"}, {"sha": "21c940b702cee6a32574913debec2159e99a18f0", "filename": "gcc/testsuite/gcc.dg/pragma-isr-trapa2.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6ab9fc0872bbc3330490c0e3ad5d0a61dbe4458/gcc%2Ftestsuite%2Fgcc.dg%2Fpragma-isr-trapa2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6ab9fc0872bbc3330490c0e3ad5d0a61dbe4458/gcc%2Ftestsuite%2Fgcc.dg%2Fpragma-isr-trapa2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpragma-isr-trapa2.c?ref=a6ab9fc0872bbc3330490c0e3ad5d0a61dbe4458", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-do compile { target sh-*-* sh4*-*-*} } */\n+/* { dg-options \"-O -m4\" } */\n+\n+extern void foo ();\n+#pragma trapa\n+void\n+isr()\n+{\n+  foo ();\n+}\n+\n+/* { dg-final { scan-assembler-times \"rte\" 1} } */\n+/* No interrupt-specific saves should be needed.\n+   The function call will require to load the address first into a register,\n+   then use that for a jsr or jmp.  It will also need to load a constant\n+   address in order to load fpscr.  */\n+/* { dg-final { scan-assembler-times \"r\\[0-7\\]\\n\" 3 } } */\n+/* { dg-final { scan-assembler-not \"r\\[8-9\\]\" } } */\n+/* { dg-final { scan-assembler-not \"r1\\[,0-3\\]\" } } */\n+/* { dg-final { scan-assembler-not \"macl\" } } */\n+/* fpscr needs to be saved, loaded and restored.  */\n+/* { dg-final { scan-assembler-times \"\\[^_\\]fpscr\" 3 } } */"}, {"sha": "07d8fa7f1f9d93186b985984256641140c6b101c", "filename": "gcc/testsuite/gcc.dg/pragma-isr.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6ab9fc0872bbc3330490c0e3ad5d0a61dbe4458/gcc%2Ftestsuite%2Fgcc.dg%2Fpragma-isr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6ab9fc0872bbc3330490c0e3ad5d0a61dbe4458/gcc%2Ftestsuite%2Fgcc.dg%2Fpragma-isr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpragma-isr.c?ref=a6ab9fc0872bbc3330490c0e3ad5d0a61dbe4458", "patch": "@@ -1,4 +1,4 @@\n-/* { dg-do compile { target h8300-*-* sh-*-*} } */\n+/* { dg-do compile { target h8300-*-* sh-*-* sh[1234ble]*-*-*} } */\n /* { dg-options \"-O3\" } */\n /* Test case will check whether rte is generated for two ISRs*/\n extern void foo();"}, {"sha": "7dba7f9bf614651549f1807c1a5f9ff6c193632f", "filename": "gcc/testsuite/gcc.dg/pragma-isr2.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6ab9fc0872bbc3330490c0e3ad5d0a61dbe4458/gcc%2Ftestsuite%2Fgcc.dg%2Fpragma-isr2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6ab9fc0872bbc3330490c0e3ad5d0a61dbe4458/gcc%2Ftestsuite%2Fgcc.dg%2Fpragma-isr2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpragma-isr2.c?ref=a6ab9fc0872bbc3330490c0e3ad5d0a61dbe4458", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do compile { target h8300-*-* sh-*-* sh[1234ble]*-*-*} } */\n+/* { dg-options \"-O\" } */\n+/* This test case will check whether rte is generated only for isr.  */\n+#pragma interrupt\n+void isr()\n+{\n+}\n+void delay(int a)\n+{\n+}\n+int main()\n+{\n+  return 0;\n+}\n+\n+/* { dg-final { scan-assembler-times \"rte\" 1} } */"}]}