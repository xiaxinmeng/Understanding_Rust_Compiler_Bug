{"sha": "968b956afbc4bc6ce30273784b4f6acf7a4ffa40", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTY4Yjk1NmFmYmM0YmM2Y2UzMDI3Mzc4NGI0ZjZhY2Y3YTRmZmE0MA==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2001-04-21T00:04:09Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2001-04-21T00:04:09Z"}, "message": "cp-tree.h (finish_enum): Change prototype.\n\n\t* cp-tree.h (finish_enum): Change prototype.\n\t* decl.c (finish_enum): Reorganize.\n\t* parse.y (structsp): Adjust calls to finish_enum.\n\nFrom-SVN: r41474", "tree": {"sha": "f9bea2e3279da3efaa324f6eccc016796be06efb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f9bea2e3279da3efaa324f6eccc016796be06efb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/968b956afbc4bc6ce30273784b4f6acf7a4ffa40", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/968b956afbc4bc6ce30273784b4f6acf7a4ffa40", "html_url": "https://github.com/Rust-GCC/gccrs/commit/968b956afbc4bc6ce30273784b4f6acf7a4ffa40", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/968b956afbc4bc6ce30273784b4f6acf7a4ffa40/comments", "author": null, "committer": null, "parents": [{"sha": "7230e19e96550047e2ba3527886f047d20c8bdc0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7230e19e96550047e2ba3527886f047d20c8bdc0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7230e19e96550047e2ba3527886f047d20c8bdc0"}], "stats": {"total": 226, "additions": 111, "deletions": 115}, "files": [{"sha": "f0f3204a4d477616a3bdaa71b1a8dd0f5ed65cd4", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/968b956afbc4bc6ce30273784b4f6acf7a4ffa40/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/968b956afbc4bc6ce30273784b4f6acf7a4ffa40/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=968b956afbc4bc6ce30273784b4f6acf7a4ffa40", "patch": "@@ -1,3 +1,9 @@\n+2001-04-20  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* cp-tree.h (finish_enum): Change prototype.\n+\t* decl.c (finish_enum): Reorganize.\n+\t* parse.y (structsp): Adjust calls to finish_enum.\n+\t\n 2001-04-20  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* tree.c (cp_tree_equal): Adjust final switch formatting. Add"}, {"sha": "d5c358a0176f922f33abca78f7a0c9f10449ff8d", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/968b956afbc4bc6ce30273784b4f6acf7a4ffa40/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/968b956afbc4bc6ce30273784b4f6acf7a4ffa40/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=968b956afbc4bc6ce30273784b4f6acf7a4ffa40", "patch": "@@ -3871,7 +3871,7 @@ extern tree xref_tag\t\t\t\tPARAMS ((tree, tree, int));\n extern tree xref_tag_from_type\t\t\tPARAMS ((tree, tree, int));\n extern void xref_basetypes\t\t\tPARAMS ((tree, tree, tree, tree));\n extern tree start_enum\t\t\t\tPARAMS ((tree));\n-extern tree finish_enum\t\t\t\tPARAMS ((tree));\n+extern void finish_enum\t\t\t\tPARAMS ((tree));\n extern void build_enumerator\t\t\tPARAMS ((tree, tree, tree));\n extern int start_function\t\t\tPARAMS ((tree, tree, tree, int));\n extern tree finish_function\t\t\tPARAMS ((int));"}, {"sha": "85a731013215e4d9f3edacb3846694a7221cb903", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 100, "deletions": 112, "changes": 212, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/968b956afbc4bc6ce30273784b4f6acf7a4ffa40/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/968b956afbc4bc6ce30273784b4f6acf7a4ffa40/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=968b956afbc4bc6ce30273784b4f6acf7a4ffa40", "patch": "@@ -12931,138 +12931,126 @@ start_enum (name)\n \n /* After processing and defining all the values of an enumeration type,\n    install their decls in the enumeration type and finish it off.\n-   ENUMTYPE is the type object and VALUES a list of name-value pairs.\n-   Returns ENUMTYPE.  */\n+   ENUMTYPE is the type object and VALUES a list of name-value pairs.  */\n \n-tree\n+void\n finish_enum (enumtype)\n      tree enumtype;\n {\n-  register tree minnode = NULL_TREE, maxnode = NULL_TREE;\n-  /* Calculate the maximum value of any enumerator in this type.  */\n+  tree pair;\n+  tree minnode;\n+  tree maxnode;\n+  tree t;\n+  bool unsignedp;\n+  int lowprec;\n+  int highprec; \n+  int precision;\n+\n+  /* We built up the VALUES in reverse order.  */\n+  TYPE_VALUES (enumtype) = nreverse (TYPE_VALUES (enumtype));\n+\n+  /* [dcl.enum]\n+\n+     Following the closing brace of an enum-specifier, each\n+     enumerator has the type of its enumeration.  Prior to the\n+     closing brace, the type of each enumerator is the type of\n+     its initializing value.  */\n+  for (pair = TYPE_VALUES (enumtype); pair; pair = TREE_CHAIN (pair))\n+    TREE_TYPE (TREE_VALUE (pair)) = enumtype;\n+  \n+  /* For a enum defined in a template, all further processing is\n+     postponed until the template is instantiated.  */\n+  if (processing_template_decl)\n+    {\n+      tree scope = current_scope ();\n+      if (scope && TREE_CODE (scope) == FUNCTION_DECL)\n+\tadd_stmt (build_min (TAG_DEFN, enumtype));\n \n-  tree values = TYPE_VALUES (enumtype);\n-  if (values)\n+      return;\n+    }\n+\n+  /* Figure out what the minimum and maximum values of the enumerators\n+     are.  */\n+  if (TYPE_VALUES (enumtype))\n     {\n-      tree pair;\n+      minnode = maxnode = NULL_TREE;\n \n-      for (pair = values; pair; pair = TREE_CHAIN (pair))\n+      for (pair = TYPE_VALUES (enumtype);\n+\t   pair;\n+\t   pair = TREE_CHAIN (pair))\n \t{\n-\t  tree decl;\n \t  tree value;\n \n-\t  /* The TREE_VALUE is a CONST_DECL for this enumeration\n-\t     constant.  */\n-\t  decl = TREE_VALUE (pair);\n-\n-\t  /* [dcl.enum]\n-\n-\t     Following the closing brace of an enum-specifier, each\n-\t     enumerator has the type of its enumeration.  Prior to the\n-\t     closing brace, the type of each enumerator is the type of\n-\t     its initializing value.  */\n-\t  TREE_TYPE (decl) = enumtype;\n-\n-\t  /* The DECL_INITIAL will be NULL if we are processing a\n-\t     template declaration and this enumeration constant had no\n-\t     explicit initializer.  */\n-\t  value = DECL_INITIAL (decl);\n-\t  if (value && !processing_template_decl)\n-\t    {\n-\t      /* Set the TREE_TYPE for the VALUE as well.  That's so\n-\t\t that when we call decl_constant_value we get an\n-\t\t entity of the right type (but with the constant\n-\t\t value).  Since we shouldn't ever call\n-\t\t decl_constant_value on a template type, there's no\n-\t\t reason to do that when processing_template_decl.\n-\t\t And, if the expression is something like a\n-\t\t TEMPLATE_PARM_INDEX or a CAST_EXPR doing so will\n-\t\t wreak havoc on the intended type of the expression.\n-\n-\t         Of course, there's also no point in trying to compute\n-\t\t minimum or maximum values if we're in a template.  */\n-\t      TREE_TYPE (value) = enumtype;\n-\n-\t      if (!minnode)\n-\t\tminnode = maxnode = value;\n-\t      else if (tree_int_cst_lt (maxnode, value))\n-\t\tmaxnode = value;\n-\t      else if (tree_int_cst_lt (value, minnode))\n-\t\tminnode = value;\n-\t    }\n+\t  value = DECL_INITIAL (TREE_VALUE (pair));\n \n-\t  if (processing_template_decl)\n-\t    /* If this is just a template, leave the CONST_DECL\n-\t       alone.  That way tsubst_copy will find CONST_DECLs for\n-\t       CONST_DECLs, and not INTEGER_CSTs.  */\n-\t    ;\n-\t  else\n-\t    /* In the list we're building up, we want the enumeration\n-\t       values, not the CONST_DECLs.  */\n-\t    TREE_VALUE (pair) = value;\n+\t  if (!minnode)\n+\t    minnode = maxnode = value;\n+\t  else if (tree_int_cst_lt (maxnode, value))\n+\t    maxnode = value;\n+\t  else if (tree_int_cst_lt (value, minnode))\n+\t    minnode = value;\n \t}\n     }\n   else\n-    maxnode = minnode = integer_zero_node;\n-\n-  TYPE_VALUES (enumtype) = nreverse (values);\n-\n-  if (processing_template_decl)\n-    {\n-      tree scope = current_scope ();\n-      if (scope && TREE_CODE (scope) == FUNCTION_DECL)\n-\tadd_stmt (build_min (TAG_DEFN, enumtype));\n-    }\n+    minnode = maxnode = integer_zero_node;\n+\n+  /* Compute the number of bits require to represent all values of the\n+     enumeration.  We must do this before the type of MINNODE and\n+     MAXNODE are transformed, since min_precision relies on the\n+     TREE_TYPE of the value it is passed.  */\n+  unsignedp = tree_int_cst_sgn (minnode) >= 0;\n+  lowprec = min_precision (minnode, unsignedp);\n+  highprec = min_precision (maxnode, unsignedp);\n+  precision = MAX (lowprec, highprec);\n+\n+  /* Set the TREE_TYPE for the values as well.  That's so that when we\n+     call decl_constant_value we get an entity of the right type (but\n+     with the constant value).  In addition, transform the TYPE_VALUES\n+     list to contain the values, rather than the CONST_DECLs for them.  */\n+  for (pair = TYPE_VALUES (enumtype); pair; pair = TREE_CHAIN (pair))\n+    {\n+      tree value = DECL_INITIAL (TREE_VALUE (pair));\n+\n+      TREE_TYPE (value) = enumtype;\n+      TREE_VALUE (pair) = value;\n+    }\n+\n+  /* Set TYPE_MIN_VALUE and TYPE_MAX_VALUE according to `precision'.  */\n+  TYPE_SIZE (enumtype) = NULL_TREE;\n+  TYPE_PRECISION (enumtype) = precision;\n+  if (unsignedp)\n+    fixup_unsigned_type (enumtype);\n   else\n-    {\n-      int unsignedp = tree_int_cst_sgn (minnode) >= 0;\n-      int lowprec = min_precision (minnode, unsignedp);\n-      int highprec = min_precision (maxnode, unsignedp);\n-      int precision = MAX (lowprec, highprec);\n-      tree tem;\n-\n-      TYPE_SIZE (enumtype) = NULL_TREE;\n+    fixup_signed_type (enumtype);\n \n-      /* Set TYPE_MIN_VALUE and TYPE_MAX_VALUE according to `precision'.  */\n-\n-      TYPE_PRECISION (enumtype) = precision;\n-      if (unsignedp)\n-\tfixup_unsigned_type (enumtype);\n-      else\n-\tfixup_signed_type (enumtype);\n-\n-      if (flag_short_enums || (precision > TYPE_PRECISION (integer_type_node)))\n-\t/* Use the width of the narrowest normal C type which is wide\n-\t   enough.  */\n-\tTYPE_PRECISION (enumtype) = TYPE_PRECISION (type_for_size\n-\t\t\t\t\t\t    (precision, 1));\n-      else\n-\tTYPE_PRECISION (enumtype) = TYPE_PRECISION (integer_type_node);\n-\n-      TYPE_SIZE (enumtype) = 0;\n-      layout_type (enumtype);\n+  if (flag_short_enums || (precision > TYPE_PRECISION (integer_type_node)))\n+    /* Use the width of the narrowest normal C type which is wide\n+       enough.  */\n+    TYPE_PRECISION (enumtype) = TYPE_PRECISION (type_for_size\n+\t\t\t\t\t\t(precision, 1));\n+  else\n+    TYPE_PRECISION (enumtype) = TYPE_PRECISION (integer_type_node);\n \n-      /* Fix up all variant types of this enum type.  */\n-      for (tem = TYPE_MAIN_VARIANT (enumtype); tem;\n-\t   tem = TYPE_NEXT_VARIANT (tem))\n-\t{\n-\t  TYPE_VALUES (tem) = TYPE_VALUES (enumtype);\n-\t  TYPE_MIN_VALUE (tem) = TYPE_MIN_VALUE (enumtype);\n-\t  TYPE_MAX_VALUE (tem) = TYPE_MAX_VALUE (enumtype);\n-\t  TYPE_SIZE (tem) = TYPE_SIZE (enumtype);\n-\t  TYPE_SIZE_UNIT (tem) = TYPE_SIZE_UNIT (enumtype);\n-\t  TYPE_MODE (tem) = TYPE_MODE (enumtype);\n-\t  TYPE_PRECISION (tem) = TYPE_PRECISION (enumtype);\n-\t  TYPE_ALIGN (tem) = TYPE_ALIGN (enumtype);\n-\t  TYPE_USER_ALIGN (tem) = TYPE_USER_ALIGN (enumtype);\n-\t  TREE_UNSIGNED (tem) = TREE_UNSIGNED (enumtype);\n-\t}\n+  TYPE_SIZE (enumtype) = NULL_TREE;\n+  layout_type (enumtype);\n \n-      /* Finish debugging output for this type.  */\n-      rest_of_type_compilation (enumtype, namespace_bindings_p ());\n+  /* Fix up all variant types of this enum type.  */\n+  for (t = TYPE_MAIN_VARIANT (enumtype); t; t = TYPE_NEXT_VARIANT (t))\n+    {\n+      TYPE_VALUES (t) = TYPE_VALUES (enumtype);\n+      TYPE_MIN_VALUE (t) = TYPE_MIN_VALUE (enumtype);\n+      TYPE_MAX_VALUE (t) = TYPE_MAX_VALUE (enumtype);\n+      TYPE_SIZE (t) = TYPE_SIZE (enumtype);\n+      TYPE_SIZE_UNIT (t) = TYPE_SIZE_UNIT (enumtype);\n+      TYPE_MODE (t) = TYPE_MODE (enumtype);\n+      TYPE_PRECISION (t) = TYPE_PRECISION (enumtype);\n+      TYPE_ALIGN (t) = TYPE_ALIGN (enumtype);\n+      TYPE_USER_ALIGN (t) = TYPE_USER_ALIGN (enumtype);\n+      TREE_UNSIGNED (t) = TREE_UNSIGNED (enumtype);\n     }\n \n-  return enumtype;\n+  /* Finish debugging output for this type.  */\n+  rest_of_type_compilation (enumtype, namespace_bindings_p ());\n }\n \n /* Build and install a CONST_DECL for an enumeration constant of the"}, {"sha": "37a2bb482f126e1383bfb4c1372c8885d1e472b0", "filename": "gcc/cp/parse.y", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/968b956afbc4bc6ce30273784b4f6acf7a4ffa40/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/968b956afbc4bc6ce30273784b4f6acf7a4ffa40/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=968b956afbc4bc6ce30273784b4f6acf7a4ffa40", "patch": "@@ -2237,15 +2237,17 @@ structsp:\n \t\t{ $<ttype>$ = current_enum_type;\n \t\t  current_enum_type = start_enum ($2); }\n \t  enumlist_opt '}'\n-\t\t{ $$.t = finish_enum (current_enum_type);\n+\t\t{ $$.t = current_enum_type;\n+\t\t  finish_enum (current_enum_type);\n \t\t  $$.new_type_flag = 1;\n \t\t  current_enum_type = $<ttype>4;\n \t\t  check_for_missing_semicolon ($$.t); }\n \t| ENUM '{'\n \t\t{ $<ttype>$ = current_enum_type;\n \t\t  current_enum_type = start_enum (make_anon_name ()); }\n \t  enumlist_opt '}'\n-                { $$.t = finish_enum (current_enum_type);\n+                { $$.t = current_enum_type;\n+\t\t  finish_enum (current_enum_type);\n \t\t  $$.new_type_flag = 1;\n \t\t  current_enum_type = $<ttype>3;\n \t\t  check_for_missing_semicolon ($$.t); }"}]}