{"sha": "7ad99d60f442253354e6a7b1be56748f6e627246", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2FkOTlkNjBmNDQyMjUzMzU0ZTZhN2IxYmU1Njc0OGY2ZTYyNzI0Ng==", "commit": {"author": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2008-05-04T08:06:02Z"}, "committer": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2008-05-04T08:06:02Z"}, "message": "re PR fortran/35990 (run-time abort for PACK of run-time zero sized array)\n\n2008-05-04  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\tPR libfortran/35990\n\t* intrinsics/pack_generic.c:  If an extent of the source\n\tarray is less then zero, set it to zero.  Set the source\n\tpointer to NULL if the source size is zero.  Set the total\n\tnumber of elements to zero if the vector has an extent\n\tless or equal to zero.\n\t* m4/pack.m4:  Set the source pointer to NULL if the\n\tsource array is zero-sized.  Set the total number of\n\telemements to zero if the vector has an extent less or\n\tequal to zero.\n\t* generated/pack_i1.c:  Regenerated.\n\t* generated/pack_i2.c:  Regenerated.\n\t* generated/pack_i4.c:  Regenerated.\n\t* generated/pack_i8.c:  Regenerated.\n\t* generated/pack_i16.c:  Regenerated.\n\t* generated/pack_r4.c:  Regenerated.\n\t* generated/pack_r8.c:  Regenerated.\n\t* generated/pack_r10.c:  Regenerated.\n\t* generated/pack_r16.c:  Regenerated.\n\t* generated/pack_c4.c:  Regenerated.\n\t* generated/pack_c8.c:  Regenerated.\n\t* generated/pack_c10.c:  Regenerated.\n\t* generated/pack_c16.c:  Regenerated.\n\n2008-05-04  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\tPR libfortran/35990\n\t* gfortran.dg/intrinsic_pack_4.f90:  New test case.\n\nFrom-SVN: r134927", "tree": {"sha": "8b1112ef5b4bc21bef6fd7da4fef8fc861f0618b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8b1112ef5b4bc21bef6fd7da4fef8fc861f0618b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7ad99d60f442253354e6a7b1be56748f6e627246", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7ad99d60f442253354e6a7b1be56748f6e627246", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7ad99d60f442253354e6a7b1be56748f6e627246", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7ad99d60f442253354e6a7b1be56748f6e627246/comments", "author": null, "committer": null, "parents": [{"sha": "3e438e2b76a87fd492bee3af425a450077fa4ef5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3e438e2b76a87fd492bee3af425a450077fa4ef5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3e438e2b76a87fd492bee3af425a450077fa4ef5"}], "stats": {"total": 272, "additions": 257, "deletions": 15}, "files": [{"sha": "ef2a4be73d8155dfbb2b0c117a21b6625b732773", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ad99d60f442253354e6a7b1be56748f6e627246/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ad99d60f442253354e6a7b1be56748f6e627246/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=7ad99d60f442253354e6a7b1be56748f6e627246", "patch": "@@ -1,3 +1,8 @@\n+2008-05-04  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\n+\tPR libfortran/35990\n+\t* gfortran.dg/intrinsic_pack_4.f90:  New test case.\n+\n 2008-05-03  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gnat.dg/discr6_pkg.ads: New helper."}, {"sha": "691036817df4cdb0ba328ffe06c572e0d3212296", "filename": "gcc/testsuite/gfortran.dg/intrinsic_pack_4.f90", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ad99d60f442253354e6a7b1be56748f6e627246/gcc%2Ftestsuite%2Fgfortran.dg%2Fintrinsic_pack_4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ad99d60f442253354e6a7b1be56748f6e627246/gcc%2Ftestsuite%2Fgfortran.dg%2Fintrinsic_pack_4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fintrinsic_pack_4.f90?ref=7ad99d60f442253354e6a7b1be56748f6e627246", "patch": "@@ -0,0 +1,72 @@\n+! { dg-do run }\n+! PR 35990 - some empty array sections caused pack to crash.\n+! Test case contributed by Dick Hendrickson, adjusted and\n+! extended by Thomas Koenig.\n+      program try_gf1048\n+\n+      call       gf1048a(  10,  8,  7,  1,  0,  .true.) \n+      call       gf1048b(  10,  8,  7,  1,  0,  .true.) \n+      call       gf1048c(  10,  8,  7,  1,  0,  .true.) \n+      call       gf1048d(  10,  8,  7,  1,  0,  .true.) \n+      call       P_inta (  10,  8,  7,  1,  0,  .true.)    \n+      call       P_intb (  10,  8,  7,  1,  0,  .true.)    \n+      call       P_intc (  10,  8,  7,  1,  0,  .true.)    \n+      call       P_intd (  10,  8,  7,  1,  0,  .true.)    \n+      end program\n+\n+      SUBROUTINE GF1048a(nf10,nf8,nf7,nf1,nf0,nf_true)\n+      logical nf_true\n+      CHARACTER(9) BDA(10)\n+      CHARACTER(9) BDA1(10)\n+      BDA(  8:7) = PACK(BDA1( 10:  1), NF_TRUE)\n+      END SUBROUTINE\n+\n+      SUBROUTINE GF1048b(nf10,nf8,nf7,nf1,nf0,nf_true)\n+      logical nf_true\n+      CHARACTER(9) BDA(10)\n+      CHARACTER(9) BDA1(nf10)\n+      BDA(NF8:NF7) = PACK(BDA1(NF8:NF7), NF_TRUE)\n+      END SUBROUTINE\n+\n+      SUBROUTINE GF1048c(nf10,nf8,nf7,nf1,nf0,nf_true)\n+      logical nf_true\n+      CHARACTER(9) BDA(10)\n+      CHARACTER(9) BDA1(10)\n+      BDA(NF8:NF7) = PACK(BDA1(NF10:NF1), NF_TRUE)\n+      END SUBROUTINE\n+\n+      SUBROUTINE GF1048d(nf10,nf8,nf7,nf1,nf0,nf_true)\n+      logical nf_true\n+      CHARACTER(9) BDA(10)\n+      CHARACTER(9) BDA1(nf10)\n+      BDA(NF8:NF7) = PACK(BDA1(NF10:NF1), NF_TRUE)\n+      END SUBROUTINE\n+\n+      SUBROUTINE P_INTa(nf10,nf8,nf7,nf1,nf0,nf_true)\n+      logical nf_true\n+      INTEGER BDA(10)\n+      INTEGER BDA1(10)\n+      BDA(  8:7) = PACK(BDA1( 10:  1), NF_TRUE)\n+      END SUBROUTINE\n+\n+      SUBROUTINE P_INTb(nf10,nf8,nf7,nf1,nf0,nf_true)\n+      logical nf_true\n+      INTEGER BDA(10)\n+      INTEGER BDA1(nf10)\n+      BDA(NF8:NF7) = PACK(BDA1(NF8:NF7), NF_TRUE)\n+      END SUBROUTINE\n+\n+      SUBROUTINE P_INTc(nf10,nf8,nf7,nf1,nf0,nf_true)\n+      logical nf_true\n+      INTEGER BDA(10)\n+      INTEGER BDA1(10)\n+      BDA(NF8:NF7) = PACK(BDA1(NF10:NF1), NF_TRUE)\n+      END SUBROUTINE\n+\n+      SUBROUTINE P_INTd(nf10,nf8,nf7,nf1,nf0,nf_true)\n+      logical nf_true\n+      INTEGER BDA(10)\n+      INTEGER BDA1(nf10)\n+      BDA(NF8:NF7) = PACK(BDA1(NF10:NF1), NF_TRUE)\n+      END SUBROUTINE\n+"}, {"sha": "89019b36f8a6321823c1ffb01c43614523613731", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ad99d60f442253354e6a7b1be56748f6e627246/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ad99d60f442253354e6a7b1be56748f6e627246/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=7ad99d60f442253354e6a7b1be56748f6e627246", "patch": "@@ -1,3 +1,29 @@\n+2008-05-04  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\n+\tPR libfortran/35990\n+\t* intrinsics/pack_generic.c:  If an extent of the source\n+\tarray is less then zero, set it to zero.  Set the source\n+\tpointer to NULL if the source size is zero.  Set the total\n+\tnumber of elements to zero if the vector has an extent\n+\tless or equal to zero.\n+\t* m4/pack.m4:  Set the source pointer to NULL if the\n+\tsource array is zero-sized.  Set the total number of\n+\telemements to zero if the vector has an extent less or\n+\tequal to zero.\n+\t* generated/pack_i1.c:  Regenerated.\n+\t* generated/pack_i2.c:  Regenerated.\n+\t* generated/pack_i4.c:  Regenerated.\n+\t* generated/pack_i8.c:  Regenerated.\n+\t* generated/pack_i16.c:  Regenerated.\n+\t* generated/pack_r4.c:  Regenerated.\n+\t* generated/pack_r8.c:  Regenerated.\n+\t* generated/pack_r10.c:  Regenerated.\n+\t* generated/pack_r16.c:  Regenerated.\n+\t* generated/pack_c4.c:  Regenerated.\n+\t* generated/pack_c8.c:  Regenerated.\n+\t* generated/pack_c10.c:  Regenerated.\n+\t* generated/pack_c16.c:  Regenerated.\n+\n 2008-05-01  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n \n \tPR libfortran/36094"}, {"sha": "0bad32385d87a566fd2ed5c7a7c8f4b59d738f4b", "filename": "libgfortran/generated/pack_c10.c", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ad99d60f442253354e6a7b1be56748f6e627246/libgfortran%2Fgenerated%2Fpack_c10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ad99d60f442253354e6a7b1be56748f6e627246/libgfortran%2Fgenerated%2Fpack_c10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fpack_c10.c?ref=7ad99d60f442253354e6a7b1be56748f6e627246", "patch": "@@ -103,7 +103,6 @@ pack_c10 (gfc_array_c10 *ret, const gfc_array_c10 *array,\n \n   dim = GFC_DESCRIPTOR_RANK (array);\n \n-  sptr = array->data;\n   mptr = mask->data;\n \n   /* Use the same loop for all logical types, by using GFC_LOGICAL_1\n@@ -139,6 +138,11 @@ pack_c10 (gfc_array_c10 *ret, const gfc_array_c10 *array,\n   if (mstride[0] == 0)\n     mstride[0] = mask_kind;\n \n+  if (zero_sized)\n+    sptr = NULL;\n+  else\n+    sptr = array->data;\n+\n   if (ret->data == NULL || compile_options.bounds_check)\n     {\n       /* Count the elements, either for allocating memory or\n@@ -149,6 +153,11 @@ pack_c10 (gfc_array_c10 *ret, const gfc_array_c10 *array,\n \t  /* The return array will have as many\n \t     elements as there are in VECTOR.  */\n \t  total = vector->dim[0].ubound + 1 - vector->dim[0].lbound;\n+\t  if (total < 0)\n+\t    {\n+\t      total = 0;\n+\t      vector = NULL;\n+\t    }\n \t}\n       else\n \t{\n@@ -308,3 +317,4 @@ pack_c10 (gfc_array_c10 *ret, const gfc_array_c10 *array,\n }\n \n #endif\n+"}, {"sha": "a0c87ec8a266855886af91043b19cd36cceba1b0", "filename": "libgfortran/generated/pack_c16.c", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ad99d60f442253354e6a7b1be56748f6e627246/libgfortran%2Fgenerated%2Fpack_c16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ad99d60f442253354e6a7b1be56748f6e627246/libgfortran%2Fgenerated%2Fpack_c16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fpack_c16.c?ref=7ad99d60f442253354e6a7b1be56748f6e627246", "patch": "@@ -103,7 +103,6 @@ pack_c16 (gfc_array_c16 *ret, const gfc_array_c16 *array,\n \n   dim = GFC_DESCRIPTOR_RANK (array);\n \n-  sptr = array->data;\n   mptr = mask->data;\n \n   /* Use the same loop for all logical types, by using GFC_LOGICAL_1\n@@ -139,6 +138,11 @@ pack_c16 (gfc_array_c16 *ret, const gfc_array_c16 *array,\n   if (mstride[0] == 0)\n     mstride[0] = mask_kind;\n \n+  if (zero_sized)\n+    sptr = NULL;\n+  else\n+    sptr = array->data;\n+\n   if (ret->data == NULL || compile_options.bounds_check)\n     {\n       /* Count the elements, either for allocating memory or\n@@ -149,6 +153,11 @@ pack_c16 (gfc_array_c16 *ret, const gfc_array_c16 *array,\n \t  /* The return array will have as many\n \t     elements as there are in VECTOR.  */\n \t  total = vector->dim[0].ubound + 1 - vector->dim[0].lbound;\n+\t  if (total < 0)\n+\t    {\n+\t      total = 0;\n+\t      vector = NULL;\n+\t    }\n \t}\n       else\n \t{\n@@ -308,3 +317,4 @@ pack_c16 (gfc_array_c16 *ret, const gfc_array_c16 *array,\n }\n \n #endif\n+"}, {"sha": "2fb6a20ad9c0d153bcd6c9d8e8b7484e31d83a65", "filename": "libgfortran/generated/pack_c4.c", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ad99d60f442253354e6a7b1be56748f6e627246/libgfortran%2Fgenerated%2Fpack_c4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ad99d60f442253354e6a7b1be56748f6e627246/libgfortran%2Fgenerated%2Fpack_c4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fpack_c4.c?ref=7ad99d60f442253354e6a7b1be56748f6e627246", "patch": "@@ -103,7 +103,6 @@ pack_c4 (gfc_array_c4 *ret, const gfc_array_c4 *array,\n \n   dim = GFC_DESCRIPTOR_RANK (array);\n \n-  sptr = array->data;\n   mptr = mask->data;\n \n   /* Use the same loop for all logical types, by using GFC_LOGICAL_1\n@@ -139,6 +138,11 @@ pack_c4 (gfc_array_c4 *ret, const gfc_array_c4 *array,\n   if (mstride[0] == 0)\n     mstride[0] = mask_kind;\n \n+  if (zero_sized)\n+    sptr = NULL;\n+  else\n+    sptr = array->data;\n+\n   if (ret->data == NULL || compile_options.bounds_check)\n     {\n       /* Count the elements, either for allocating memory or\n@@ -149,6 +153,11 @@ pack_c4 (gfc_array_c4 *ret, const gfc_array_c4 *array,\n \t  /* The return array will have as many\n \t     elements as there are in VECTOR.  */\n \t  total = vector->dim[0].ubound + 1 - vector->dim[0].lbound;\n+\t  if (total < 0)\n+\t    {\n+\t      total = 0;\n+\t      vector = NULL;\n+\t    }\n \t}\n       else\n \t{\n@@ -308,3 +317,4 @@ pack_c4 (gfc_array_c4 *ret, const gfc_array_c4 *array,\n }\n \n #endif\n+"}, {"sha": "1a4e78ec792447465148af9065884e35c71ae77d", "filename": "libgfortran/generated/pack_c8.c", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ad99d60f442253354e6a7b1be56748f6e627246/libgfortran%2Fgenerated%2Fpack_c8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ad99d60f442253354e6a7b1be56748f6e627246/libgfortran%2Fgenerated%2Fpack_c8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fpack_c8.c?ref=7ad99d60f442253354e6a7b1be56748f6e627246", "patch": "@@ -103,7 +103,6 @@ pack_c8 (gfc_array_c8 *ret, const gfc_array_c8 *array,\n \n   dim = GFC_DESCRIPTOR_RANK (array);\n \n-  sptr = array->data;\n   mptr = mask->data;\n \n   /* Use the same loop for all logical types, by using GFC_LOGICAL_1\n@@ -139,6 +138,11 @@ pack_c8 (gfc_array_c8 *ret, const gfc_array_c8 *array,\n   if (mstride[0] == 0)\n     mstride[0] = mask_kind;\n \n+  if (zero_sized)\n+    sptr = NULL;\n+  else\n+    sptr = array->data;\n+\n   if (ret->data == NULL || compile_options.bounds_check)\n     {\n       /* Count the elements, either for allocating memory or\n@@ -149,6 +153,11 @@ pack_c8 (gfc_array_c8 *ret, const gfc_array_c8 *array,\n \t  /* The return array will have as many\n \t     elements as there are in VECTOR.  */\n \t  total = vector->dim[0].ubound + 1 - vector->dim[0].lbound;\n+\t  if (total < 0)\n+\t    {\n+\t      total = 0;\n+\t      vector = NULL;\n+\t    }\n \t}\n       else\n \t{\n@@ -308,3 +317,4 @@ pack_c8 (gfc_array_c8 *ret, const gfc_array_c8 *array,\n }\n \n #endif\n+"}, {"sha": "44c6c677e445e2930a3f2acb75689ba1361ac2f4", "filename": "libgfortran/generated/pack_i1.c", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ad99d60f442253354e6a7b1be56748f6e627246/libgfortran%2Fgenerated%2Fpack_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ad99d60f442253354e6a7b1be56748f6e627246/libgfortran%2Fgenerated%2Fpack_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fpack_i1.c?ref=7ad99d60f442253354e6a7b1be56748f6e627246", "patch": "@@ -103,7 +103,6 @@ pack_i1 (gfc_array_i1 *ret, const gfc_array_i1 *array,\n \n   dim = GFC_DESCRIPTOR_RANK (array);\n \n-  sptr = array->data;\n   mptr = mask->data;\n \n   /* Use the same loop for all logical types, by using GFC_LOGICAL_1\n@@ -139,6 +138,11 @@ pack_i1 (gfc_array_i1 *ret, const gfc_array_i1 *array,\n   if (mstride[0] == 0)\n     mstride[0] = mask_kind;\n \n+  if (zero_sized)\n+    sptr = NULL;\n+  else\n+    sptr = array->data;\n+\n   if (ret->data == NULL || compile_options.bounds_check)\n     {\n       /* Count the elements, either for allocating memory or\n@@ -149,6 +153,11 @@ pack_i1 (gfc_array_i1 *ret, const gfc_array_i1 *array,\n \t  /* The return array will have as many\n \t     elements as there are in VECTOR.  */\n \t  total = vector->dim[0].ubound + 1 - vector->dim[0].lbound;\n+\t  if (total < 0)\n+\t    {\n+\t      total = 0;\n+\t      vector = NULL;\n+\t    }\n \t}\n       else\n \t{\n@@ -308,3 +317,4 @@ pack_i1 (gfc_array_i1 *ret, const gfc_array_i1 *array,\n }\n \n #endif\n+"}, {"sha": "e9c154379775d80054deaeb03a9dcf27f0f3be6f", "filename": "libgfortran/generated/pack_i16.c", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ad99d60f442253354e6a7b1be56748f6e627246/libgfortran%2Fgenerated%2Fpack_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ad99d60f442253354e6a7b1be56748f6e627246/libgfortran%2Fgenerated%2Fpack_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fpack_i16.c?ref=7ad99d60f442253354e6a7b1be56748f6e627246", "patch": "@@ -103,7 +103,6 @@ pack_i16 (gfc_array_i16 *ret, const gfc_array_i16 *array,\n \n   dim = GFC_DESCRIPTOR_RANK (array);\n \n-  sptr = array->data;\n   mptr = mask->data;\n \n   /* Use the same loop for all logical types, by using GFC_LOGICAL_1\n@@ -139,6 +138,11 @@ pack_i16 (gfc_array_i16 *ret, const gfc_array_i16 *array,\n   if (mstride[0] == 0)\n     mstride[0] = mask_kind;\n \n+  if (zero_sized)\n+    sptr = NULL;\n+  else\n+    sptr = array->data;\n+\n   if (ret->data == NULL || compile_options.bounds_check)\n     {\n       /* Count the elements, either for allocating memory or\n@@ -149,6 +153,11 @@ pack_i16 (gfc_array_i16 *ret, const gfc_array_i16 *array,\n \t  /* The return array will have as many\n \t     elements as there are in VECTOR.  */\n \t  total = vector->dim[0].ubound + 1 - vector->dim[0].lbound;\n+\t  if (total < 0)\n+\t    {\n+\t      total = 0;\n+\t      vector = NULL;\n+\t    }\n \t}\n       else\n \t{\n@@ -308,3 +317,4 @@ pack_i16 (gfc_array_i16 *ret, const gfc_array_i16 *array,\n }\n \n #endif\n+"}, {"sha": "51380c26ba72bc6b652fc05e7d39c53b86f9984d", "filename": "libgfortran/generated/pack_i2.c", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ad99d60f442253354e6a7b1be56748f6e627246/libgfortran%2Fgenerated%2Fpack_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ad99d60f442253354e6a7b1be56748f6e627246/libgfortran%2Fgenerated%2Fpack_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fpack_i2.c?ref=7ad99d60f442253354e6a7b1be56748f6e627246", "patch": "@@ -103,7 +103,6 @@ pack_i2 (gfc_array_i2 *ret, const gfc_array_i2 *array,\n \n   dim = GFC_DESCRIPTOR_RANK (array);\n \n-  sptr = array->data;\n   mptr = mask->data;\n \n   /* Use the same loop for all logical types, by using GFC_LOGICAL_1\n@@ -139,6 +138,11 @@ pack_i2 (gfc_array_i2 *ret, const gfc_array_i2 *array,\n   if (mstride[0] == 0)\n     mstride[0] = mask_kind;\n \n+  if (zero_sized)\n+    sptr = NULL;\n+  else\n+    sptr = array->data;\n+\n   if (ret->data == NULL || compile_options.bounds_check)\n     {\n       /* Count the elements, either for allocating memory or\n@@ -149,6 +153,11 @@ pack_i2 (gfc_array_i2 *ret, const gfc_array_i2 *array,\n \t  /* The return array will have as many\n \t     elements as there are in VECTOR.  */\n \t  total = vector->dim[0].ubound + 1 - vector->dim[0].lbound;\n+\t  if (total < 0)\n+\t    {\n+\t      total = 0;\n+\t      vector = NULL;\n+\t    }\n \t}\n       else\n \t{\n@@ -308,3 +317,4 @@ pack_i2 (gfc_array_i2 *ret, const gfc_array_i2 *array,\n }\n \n #endif\n+"}, {"sha": "861670d6865b7f7f61fe11708b5d9df49bb95b83", "filename": "libgfortran/generated/pack_i4.c", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ad99d60f442253354e6a7b1be56748f6e627246/libgfortran%2Fgenerated%2Fpack_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ad99d60f442253354e6a7b1be56748f6e627246/libgfortran%2Fgenerated%2Fpack_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fpack_i4.c?ref=7ad99d60f442253354e6a7b1be56748f6e627246", "patch": "@@ -103,7 +103,6 @@ pack_i4 (gfc_array_i4 *ret, const gfc_array_i4 *array,\n \n   dim = GFC_DESCRIPTOR_RANK (array);\n \n-  sptr = array->data;\n   mptr = mask->data;\n \n   /* Use the same loop for all logical types, by using GFC_LOGICAL_1\n@@ -139,6 +138,11 @@ pack_i4 (gfc_array_i4 *ret, const gfc_array_i4 *array,\n   if (mstride[0] == 0)\n     mstride[0] = mask_kind;\n \n+  if (zero_sized)\n+    sptr = NULL;\n+  else\n+    sptr = array->data;\n+\n   if (ret->data == NULL || compile_options.bounds_check)\n     {\n       /* Count the elements, either for allocating memory or\n@@ -149,6 +153,11 @@ pack_i4 (gfc_array_i4 *ret, const gfc_array_i4 *array,\n \t  /* The return array will have as many\n \t     elements as there are in VECTOR.  */\n \t  total = vector->dim[0].ubound + 1 - vector->dim[0].lbound;\n+\t  if (total < 0)\n+\t    {\n+\t      total = 0;\n+\t      vector = NULL;\n+\t    }\n \t}\n       else\n \t{\n@@ -308,3 +317,4 @@ pack_i4 (gfc_array_i4 *ret, const gfc_array_i4 *array,\n }\n \n #endif\n+"}, {"sha": "c547f3809f2be379648074960d59397dddd582de", "filename": "libgfortran/generated/pack_i8.c", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ad99d60f442253354e6a7b1be56748f6e627246/libgfortran%2Fgenerated%2Fpack_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ad99d60f442253354e6a7b1be56748f6e627246/libgfortran%2Fgenerated%2Fpack_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fpack_i8.c?ref=7ad99d60f442253354e6a7b1be56748f6e627246", "patch": "@@ -103,7 +103,6 @@ pack_i8 (gfc_array_i8 *ret, const gfc_array_i8 *array,\n \n   dim = GFC_DESCRIPTOR_RANK (array);\n \n-  sptr = array->data;\n   mptr = mask->data;\n \n   /* Use the same loop for all logical types, by using GFC_LOGICAL_1\n@@ -139,6 +138,11 @@ pack_i8 (gfc_array_i8 *ret, const gfc_array_i8 *array,\n   if (mstride[0] == 0)\n     mstride[0] = mask_kind;\n \n+  if (zero_sized)\n+    sptr = NULL;\n+  else\n+    sptr = array->data;\n+\n   if (ret->data == NULL || compile_options.bounds_check)\n     {\n       /* Count the elements, either for allocating memory or\n@@ -149,6 +153,11 @@ pack_i8 (gfc_array_i8 *ret, const gfc_array_i8 *array,\n \t  /* The return array will have as many\n \t     elements as there are in VECTOR.  */\n \t  total = vector->dim[0].ubound + 1 - vector->dim[0].lbound;\n+\t  if (total < 0)\n+\t    {\n+\t      total = 0;\n+\t      vector = NULL;\n+\t    }\n \t}\n       else\n \t{\n@@ -308,3 +317,4 @@ pack_i8 (gfc_array_i8 *ret, const gfc_array_i8 *array,\n }\n \n #endif\n+"}, {"sha": "4b8c5784aef88f028c8b22356f86f25f6a9614b6", "filename": "libgfortran/generated/pack_r10.c", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ad99d60f442253354e6a7b1be56748f6e627246/libgfortran%2Fgenerated%2Fpack_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ad99d60f442253354e6a7b1be56748f6e627246/libgfortran%2Fgenerated%2Fpack_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fpack_r10.c?ref=7ad99d60f442253354e6a7b1be56748f6e627246", "patch": "@@ -103,7 +103,6 @@ pack_r10 (gfc_array_r10 *ret, const gfc_array_r10 *array,\n \n   dim = GFC_DESCRIPTOR_RANK (array);\n \n-  sptr = array->data;\n   mptr = mask->data;\n \n   /* Use the same loop for all logical types, by using GFC_LOGICAL_1\n@@ -139,6 +138,11 @@ pack_r10 (gfc_array_r10 *ret, const gfc_array_r10 *array,\n   if (mstride[0] == 0)\n     mstride[0] = mask_kind;\n \n+  if (zero_sized)\n+    sptr = NULL;\n+  else\n+    sptr = array->data;\n+\n   if (ret->data == NULL || compile_options.bounds_check)\n     {\n       /* Count the elements, either for allocating memory or\n@@ -149,6 +153,11 @@ pack_r10 (gfc_array_r10 *ret, const gfc_array_r10 *array,\n \t  /* The return array will have as many\n \t     elements as there are in VECTOR.  */\n \t  total = vector->dim[0].ubound + 1 - vector->dim[0].lbound;\n+\t  if (total < 0)\n+\t    {\n+\t      total = 0;\n+\t      vector = NULL;\n+\t    }\n \t}\n       else\n \t{\n@@ -308,3 +317,4 @@ pack_r10 (gfc_array_r10 *ret, const gfc_array_r10 *array,\n }\n \n #endif\n+"}, {"sha": "a691f7c4041102c80f75ad2f57902b6120a23f5e", "filename": "libgfortran/generated/pack_r16.c", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ad99d60f442253354e6a7b1be56748f6e627246/libgfortran%2Fgenerated%2Fpack_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ad99d60f442253354e6a7b1be56748f6e627246/libgfortran%2Fgenerated%2Fpack_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fpack_r16.c?ref=7ad99d60f442253354e6a7b1be56748f6e627246", "patch": "@@ -103,7 +103,6 @@ pack_r16 (gfc_array_r16 *ret, const gfc_array_r16 *array,\n \n   dim = GFC_DESCRIPTOR_RANK (array);\n \n-  sptr = array->data;\n   mptr = mask->data;\n \n   /* Use the same loop for all logical types, by using GFC_LOGICAL_1\n@@ -139,6 +138,11 @@ pack_r16 (gfc_array_r16 *ret, const gfc_array_r16 *array,\n   if (mstride[0] == 0)\n     mstride[0] = mask_kind;\n \n+  if (zero_sized)\n+    sptr = NULL;\n+  else\n+    sptr = array->data;\n+\n   if (ret->data == NULL || compile_options.bounds_check)\n     {\n       /* Count the elements, either for allocating memory or\n@@ -149,6 +153,11 @@ pack_r16 (gfc_array_r16 *ret, const gfc_array_r16 *array,\n \t  /* The return array will have as many\n \t     elements as there are in VECTOR.  */\n \t  total = vector->dim[0].ubound + 1 - vector->dim[0].lbound;\n+\t  if (total < 0)\n+\t    {\n+\t      total = 0;\n+\t      vector = NULL;\n+\t    }\n \t}\n       else\n \t{\n@@ -308,3 +317,4 @@ pack_r16 (gfc_array_r16 *ret, const gfc_array_r16 *array,\n }\n \n #endif\n+"}, {"sha": "c008aadf4d435154a5f6d14afa5ee813df6cb647", "filename": "libgfortran/generated/pack_r4.c", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ad99d60f442253354e6a7b1be56748f6e627246/libgfortran%2Fgenerated%2Fpack_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ad99d60f442253354e6a7b1be56748f6e627246/libgfortran%2Fgenerated%2Fpack_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fpack_r4.c?ref=7ad99d60f442253354e6a7b1be56748f6e627246", "patch": "@@ -103,7 +103,6 @@ pack_r4 (gfc_array_r4 *ret, const gfc_array_r4 *array,\n \n   dim = GFC_DESCRIPTOR_RANK (array);\n \n-  sptr = array->data;\n   mptr = mask->data;\n \n   /* Use the same loop for all logical types, by using GFC_LOGICAL_1\n@@ -139,6 +138,11 @@ pack_r4 (gfc_array_r4 *ret, const gfc_array_r4 *array,\n   if (mstride[0] == 0)\n     mstride[0] = mask_kind;\n \n+  if (zero_sized)\n+    sptr = NULL;\n+  else\n+    sptr = array->data;\n+\n   if (ret->data == NULL || compile_options.bounds_check)\n     {\n       /* Count the elements, either for allocating memory or\n@@ -149,6 +153,11 @@ pack_r4 (gfc_array_r4 *ret, const gfc_array_r4 *array,\n \t  /* The return array will have as many\n \t     elements as there are in VECTOR.  */\n \t  total = vector->dim[0].ubound + 1 - vector->dim[0].lbound;\n+\t  if (total < 0)\n+\t    {\n+\t      total = 0;\n+\t      vector = NULL;\n+\t    }\n \t}\n       else\n \t{\n@@ -308,3 +317,4 @@ pack_r4 (gfc_array_r4 *ret, const gfc_array_r4 *array,\n }\n \n #endif\n+"}, {"sha": "7b36047962848f6d46a81567f421e8a9650f35d2", "filename": "libgfortran/generated/pack_r8.c", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ad99d60f442253354e6a7b1be56748f6e627246/libgfortran%2Fgenerated%2Fpack_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ad99d60f442253354e6a7b1be56748f6e627246/libgfortran%2Fgenerated%2Fpack_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fpack_r8.c?ref=7ad99d60f442253354e6a7b1be56748f6e627246", "patch": "@@ -103,7 +103,6 @@ pack_r8 (gfc_array_r8 *ret, const gfc_array_r8 *array,\n \n   dim = GFC_DESCRIPTOR_RANK (array);\n \n-  sptr = array->data;\n   mptr = mask->data;\n \n   /* Use the same loop for all logical types, by using GFC_LOGICAL_1\n@@ -139,6 +138,11 @@ pack_r8 (gfc_array_r8 *ret, const gfc_array_r8 *array,\n   if (mstride[0] == 0)\n     mstride[0] = mask_kind;\n \n+  if (zero_sized)\n+    sptr = NULL;\n+  else\n+    sptr = array->data;\n+\n   if (ret->data == NULL || compile_options.bounds_check)\n     {\n       /* Count the elements, either for allocating memory or\n@@ -149,6 +153,11 @@ pack_r8 (gfc_array_r8 *ret, const gfc_array_r8 *array,\n \t  /* The return array will have as many\n \t     elements as there are in VECTOR.  */\n \t  total = vector->dim[0].ubound + 1 - vector->dim[0].lbound;\n+\t  if (total < 0)\n+\t    {\n+\t      total = 0;\n+\t      vector = NULL;\n+\t    }\n \t}\n       else\n \t{\n@@ -308,3 +317,4 @@ pack_r8 (gfc_array_r8 *ret, const gfc_array_r8 *array,\n }\n \n #endif\n+"}, {"sha": "4f31ffdd15e7dc87d5cd44ea4c485ed87bd4cf29", "filename": "libgfortran/m4/pack.m4", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ad99d60f442253354e6a7b1be56748f6e627246/libgfortran%2Fm4%2Fpack.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ad99d60f442253354e6a7b1be56748f6e627246/libgfortran%2Fm4%2Fpack.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fm4%2Fpack.m4?ref=7ad99d60f442253354e6a7b1be56748f6e627246", "patch": "@@ -104,7 +104,6 @@ pack_'rtype_code` ('rtype` *ret, const 'rtype` *array,\n \n   dim = GFC_DESCRIPTOR_RANK (array);\n \n-  sptr = array->data;\n   mptr = mask->data;\n \n   /* Use the same loop for all logical types, by using GFC_LOGICAL_1\n@@ -140,6 +139,11 @@ pack_'rtype_code` ('rtype` *ret, const 'rtype` *array,\n   if (mstride[0] == 0)\n     mstride[0] = mask_kind;\n \n+  if (zero_sized)\n+    sptr = NULL;\n+  else\n+    sptr = array->data;\n+\n   if (ret->data == NULL || compile_options.bounds_check)\n     {\n       /* Count the elements, either for allocating memory or\n@@ -150,6 +154,11 @@ pack_'rtype_code` ('rtype` *ret, const 'rtype` *array,\n \t  /* The return array will have as many\n \t     elements as there are in VECTOR.  */\n \t  total = vector->dim[0].ubound + 1 - vector->dim[0].lbound;\n+\t  if (total < 0)\n+\t    {\n+\t      total = 0;\n+\t      vector = NULL;\n+\t    }\n \t}\n       else\n \t{\n@@ -309,4 +318,4 @@ pack_'rtype_code` ('rtype` *ret, const 'rtype` *array,\n }\n \n #endif\n-'\n\\ No newline at end of file\n+'"}]}