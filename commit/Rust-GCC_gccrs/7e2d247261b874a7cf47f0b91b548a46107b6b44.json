{"sha": "7e2d247261b874a7cf47f0b91b548a46107b6b44", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2UyZDI0NzI2MWI4NzRhN2NmNDdmMGI5MWI1NDhhNDYxMDdiNmI0NA==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2000-04-09T15:59:16Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2000-04-09T15:59:16Z"}, "message": "Prepend __ to implementation defined names.\n\n\t* inc/typeinfo (type_info): Rename _name to __name.\n\t(type_info::type_info): Rename parameter.\n\t(type_info::operator==, type_info::operator!=,\n\ttype_info::before): Likewise.\n\t(type_info::is_pointer_p, type_info::is_function_p,\n\ttype_info::do_catch, type_info::do_upcast): Prepend __. Rename\n\tparameters.\n\t* inc/cxxabi.h\n\t(__fundamental_type_info::__fundamental_type_info) Rename parameters.\n\t(__pointer_type_info::__pointer_type_info): Likewise.\n\t(__pointer_type_info::is_pointer_p,\n\t__pointer_type_info::do_catch): Prepend __. Rename parameters.\n\t(__array_type_info::__array_type_info): Rename parameters.\n\t(__function_type_info::__function_type_info): Likewise.\n\t(__function_type_info::is_function_p): Prepend __.\n\t(__enum_type_info::__enum_type_info): Rename parameters.\n\t(__pointer_to_member_type_info::__pointer_to_member_type_info):\n\tLikewise.\n\t(__pointer_to_member_type_info::do_catch): Prepend __. Rename\n\tparameters.\n\t(__base_class_info::is_virtual_p, is_public_p, offset): Prepend\t__.\n\t(__class_type_info::__class_type_info): Rename parameters.\n\t(__class_type_info::sub_kind): Prepend __. Adjust member names.\n\t(__class_type_info::upcast_result,\n\t__class_type_info::dyncast_result): Prepend __. Move definition\n\tinto tinfo.cc.\n\t(__class_type_info::do_upcast, __class_type_info::do_catch,\n\t__class_type_info::find_public_src,\n\t__class_type_info::do_dyncast,\n\t__class_type_info::do_find_public_src): Prepend __. Rename\n\tparameters.\n\t(__si_class_type_info::__si_class_type_info): Rename parameters.\n\t(__si_class_type_info::do_upcast, __si_class_type_info::do_dyncast,\n\t__si_class_type_info::do_find_public_src): Prepent __. Rename\n\tparameters.\n\t(__vmi_class_type_info::__vmi_class_type_info): Rename parameters.\n\t(__vmi_class_type_info::do_upcast, __vmi_class_type_info::do_dyncast,\n\t__vmi_class_type_info::do_find_public_src): Prepent __. Rename\n\tparameters.\n\t(__dynamic_cast): Rename parameters.\n\t* tinfo.cc (type_info::is_pointer_p, type_info::is_function_p,\n\ttype_info::do_catch, type_info::do_upcast): Prepend __.\n\t(contained_p, public_p, virtual_p, contained_public_p,\n\tcontained_nonpublic_p, contained_nonvirtual_p): Adjust.\n\t(__class_type_info::do_catch,\n\t__class_type_info::do_upcast): Prepend __. Adjust.\n\t(__class_type_info::__upcast_result,\n\t__class_type_info::__dyncast_result): Move from inc/cxxabi.h.\n\tAdjust.\n\t(__class_type_info::find_public_src): Prepend __. Adjust.\n\t(__class_type_info::do_find_public_src,\n\t__si_class_type_info::do_find_public_src,\n\t__vmi_class_type_info::do_find_public_src): Likewise.\n\t(__class_type_info::do_dyncast,\n\t__si_class_type_info::do_dyncast,\n\t__vmi_class_type_info::do_dyncast): Likewise.\n\t(__class_type_info::do_upcast,\n\t__si_class_type_info::do_upcast,\n\t__vmi_class_type_info::do_upcast): Likewise.\n\t(__dynamic_cast): Adjust.\n\t* tinfo2.cc (__pointer_type_info::is_pointer_p): Prepend __.\n\t(__function_type_info::is_function_p): Likewise.\n\t(__pointer_type_info::do_catch): Likewise. Adjust.\n\t(__pointer_to_member_type_info::do_catch): Likewise. Adjust.\n\t(__throw_type_match_rtti_2): Adjust.\n\t(__is_pointer): Adjust.\n\nFrom-SVN: r33041", "tree": {"sha": "5bc6e63c7f5748ffa81c8b2fdfef88f166f80269", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5bc6e63c7f5748ffa81c8b2fdfef88f166f80269"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7e2d247261b874a7cf47f0b91b548a46107b6b44", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e2d247261b874a7cf47f0b91b548a46107b6b44", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7e2d247261b874a7cf47f0b91b548a46107b6b44", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e2d247261b874a7cf47f0b91b548a46107b6b44/comments", "author": null, "committer": null, "parents": [{"sha": "c42f056abe054deb0044688a6b9e82627c2253e2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c42f056abe054deb0044688a6b9e82627c2253e2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c42f056abe054deb0044688a6b9e82627c2253e2"}], "stats": {"total": 684, "additions": 390, "deletions": 294}, "files": [{"sha": "f76ef3944774314375be71e4f8f045536147ffb3", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e2d247261b874a7cf47f0b91b548a46107b6b44/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e2d247261b874a7cf47f0b91b548a46107b6b44/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=7e2d247261b874a7cf47f0b91b548a46107b6b44", "patch": "@@ -1,3 +1,73 @@\n+2000-04-09  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\tPrepend __ to implementation defined names.\n+\t* inc/typeinfo (type_info): Rename _name to __name.\n+\t(type_info::type_info): Rename parameter.\n+\t(type_info::operator==, type_info::operator!=,\n+\ttype_info::before): Likewise.\n+\t(type_info::is_pointer_p, type_info::is_function_p,\n+\ttype_info::do_catch, type_info::do_upcast): Prepend __. Rename\n+\tparameters.\n+\t* inc/cxxabi.h\n+\t(__fundamental_type_info::__fundamental_type_info) Rename parameters.\n+\t(__pointer_type_info::__pointer_type_info): Likewise.\n+\t(__pointer_type_info::is_pointer_p,\n+\t__pointer_type_info::do_catch): Prepend __. Rename parameters.\n+\t(__array_type_info::__array_type_info): Rename parameters.\n+\t(__function_type_info::__function_type_info): Likewise.\n+\t(__function_type_info::is_function_p): Prepend __.\n+\t(__enum_type_info::__enum_type_info): Rename parameters.\n+\t(__pointer_to_member_type_info::__pointer_to_member_type_info):\n+\tLikewise.\n+\t(__pointer_to_member_type_info::do_catch): Prepend __. Rename\n+\tparameters.\n+\t(__base_class_info::is_virtual_p, is_public_p, offset): Prepend\t__.\n+\t(__class_type_info::__class_type_info): Rename parameters.\n+\t(__class_type_info::sub_kind): Prepend __. Adjust member names.\n+\t(__class_type_info::upcast_result,\n+\t__class_type_info::dyncast_result): Prepend __. Move definition\n+\tinto tinfo.cc.\n+\t(__class_type_info::do_upcast, __class_type_info::do_catch,\n+\t__class_type_info::find_public_src,\n+\t__class_type_info::do_dyncast,\n+\t__class_type_info::do_find_public_src): Prepend __. Rename\n+\tparameters.\n+\t(__si_class_type_info::__si_class_type_info): Rename parameters.\n+\t(__si_class_type_info::do_upcast, __si_class_type_info::do_dyncast,\n+\t__si_class_type_info::do_find_public_src): Prepent __. Rename\n+\tparameters.\n+\t(__vmi_class_type_info::__vmi_class_type_info): Rename parameters.\n+\t(__vmi_class_type_info::do_upcast, __vmi_class_type_info::do_dyncast,\n+\t__vmi_class_type_info::do_find_public_src): Prepent __. Rename\n+\tparameters.\n+\t(__dynamic_cast): Rename parameters.\n+\t* tinfo.cc (type_info::is_pointer_p, type_info::is_function_p,\n+\ttype_info::do_catch, type_info::do_upcast): Prepend __.\n+\t(contained_p, public_p, virtual_p, contained_public_p,\n+\tcontained_nonpublic_p, contained_nonvirtual_p): Adjust.\n+\t(__class_type_info::do_catch,\n+\t__class_type_info::do_upcast): Prepend __. Adjust.\n+\t(__class_type_info::__upcast_result,\n+\t__class_type_info::__dyncast_result): Move from inc/cxxabi.h.\n+\tAdjust.\n+\t(__class_type_info::find_public_src): Prepend __. Adjust.\n+\t(__class_type_info::do_find_public_src, \n+\t__si_class_type_info::do_find_public_src, \n+\t__vmi_class_type_info::do_find_public_src): Likewise.\n+\t(__class_type_info::do_dyncast,\n+\t__si_class_type_info::do_dyncast,\n+\t__vmi_class_type_info::do_dyncast): Likewise.\n+\t(__class_type_info::do_upcast,\n+\t__si_class_type_info::do_upcast,\n+\t__vmi_class_type_info::do_upcast): Likewise.\n+\t(__dynamic_cast): Adjust.\n+\t* tinfo2.cc (__pointer_type_info::is_pointer_p): Prepend __.\n+\t(__function_type_info::is_function_p): Likewise.\n+\t(__pointer_type_info::do_catch): Likewise. Adjust.\n+\t(__pointer_to_member_type_info::do_catch): Likewise. Adjust.\n+\t(__throw_type_match_rtti_2): Adjust.\n+\t(__is_pointer): Adjust.\n+\n 2000-04-08  Mark Mitchell  <mark@codesourcery.com>\n \n \t* cp-tree.h (cp_tree_index): Add CPTI_COMPLETE_CTOR_IDENTIFIER."}, {"sha": "66a6607e3846167158b05a9b1d70f85da0cc6ece", "filename": "gcc/cp/inc/cxxabi.h", "status": "modified", "additions": 104, "deletions": 117, "changes": 221, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e2d247261b874a7cf47f0b91b548a46107b6b44/gcc%2Fcp%2Finc%2Fcxxabi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e2d247261b874a7cf47f0b91b548a46107b6b44/gcc%2Fcp%2Finc%2Fcxxabi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finc%2Fcxxabi.h?ref=7e2d247261b874a7cf47f0b91b548a46107b6b44", "patch": "@@ -36,8 +36,8 @@ class __fundamental_type_info\n public:\n   virtual ~__fundamental_type_info ();\n public:\n-  explicit __fundamental_type_info (const char *n_)\n-    : std::type_info (n_)\n+  explicit __fundamental_type_info (const char *__n)\n+    : std::type_info (__n)\n     { }\n };\n \n@@ -54,10 +54,10 @@ class __pointer_type_info\n public:\n   virtual ~__pointer_type_info ();\n public:\n-  explicit __pointer_type_info (const char *n_,\n-                                int quals_,\n-                                const std::type_info *type_)\n-    : std::type_info (n_), quals (quals_), type (type_)\n+  explicit __pointer_type_info (const char *__n,\n+                                int __quals,\n+                                const std::type_info *__type)\n+    : std::type_info (__n), quals (__quals), type (__type)\n     { }\n \n /* implementation defined types */\n@@ -69,10 +69,10 @@ class __pointer_type_info\n \n /* implementation defined member functions */\n protected:\n-  virtual bool is_pointer_p () const;\n+  virtual bool __is_pointer_p () const;\n protected:\n-  virtual bool do_catch (const std::type_info *thr_type, void **thr_obj,\n-                         unsigned outer) const;\n+  virtual bool __do_catch (const std::type_info *__thr_type, void **__thr_obj,\n+                           unsigned __outer) const;\n };\n \n /* type information for array objects */\n@@ -83,8 +83,8 @@ class __array_type_info\n protected:\n   virtual ~__array_type_info ();\n public:\n-  explicit __array_type_info (const char *n_)\n-    : std::type_info (n_)\n+  explicit __array_type_info (const char *__n)\n+    : std::type_info (__n)\n     { }\n };\n \n@@ -96,13 +96,13 @@ class __function_type_info\n public:\n   virtual ~__function_type_info ();\n public:\n-  explicit __function_type_info (const char *n_)\n-    : std::type_info (n_)\n+  explicit __function_type_info (const char *__n)\n+    : std::type_info (__n)\n     { }\n   \n /* implementation defined member functions */\n protected:\n-  virtual bool is_function_p () const;\n+  virtual bool __is_function_p () const;\n };\n \n /* type information for enumerations */\n@@ -113,8 +113,8 @@ class __enum_type_info\n public:\n   virtual ~__enum_type_info ();\n public:\n-  explicit __enum_type_info (const char *n_)\n-    : std::type_info (n_)\n+  explicit __enum_type_info (const char *__n)\n+    : std::type_info (__n)\n     { }\n };\n \n@@ -132,11 +132,11 @@ class __pointer_to_member_type_info\n public:\n   virtual ~__pointer_to_member_type_info ();\n public:\n-  explicit __pointer_to_member_type_info (const char *n_,\n-                                          const __class_type_info *klass_,\n-                                          const std::type_info *type_,\n-                                          int quals_)\n-    : std::type_info (n_), klass (klass_), type (type_), quals (quals_)\n+  explicit __pointer_to_member_type_info (const char *__n,\n+                                          const __class_type_info *__klass,\n+                                          const std::type_info *__type,\n+                                          int __quals)\n+    : std::type_info (__n), klass (__klass), type (__type), quals (__quals)\n     { }\n \n /* implementation defined types */\n@@ -148,8 +148,8 @@ class __pointer_to_member_type_info\n \n /* implementation defined member functions */\n protected:\n-  virtual bool do_catch (const std::type_info *thr_type, void **thr_obj,\n-                         unsigned outer) const;\n+  virtual bool __do_catch (const std::type_info *__thr_type, void **__thr_obj,\n+                         unsigned __outer) const;\n };\n \n class __class_type_info;\n@@ -173,11 +173,11 @@ class __base_class_info\n   \n /* implementation defined member functions */\n public:\n-  bool is_virtual_p () const\n+  bool __is_virtual_p () const\n     { return vmi_offset_flags & virtual_mask; }\n-  bool is_public_p () const\n+  bool __is_public_p () const\n     { return vmi_offset_flags & public_mask; }\n-  std::ptrdiff_t offset () const\n+  std::ptrdiff_t __offset () const\n     { return std::ptrdiff_t (vmi_offset_flags) >> offset_shift; }\n };\n \n@@ -189,80 +189,52 @@ class __class_type_info\n public:\n   virtual ~__class_type_info ();\n public:\n-  explicit __class_type_info (const char *n_)\n-    : type_info (n_)\n+  explicit __class_type_info (const char *__n)\n+    : type_info (__n)\n     { }\n \n /* implementation defined types */\n public:\n   /* sub_kind tells us about how a base object is contained within a derived\n      object. We often do this lazily, hence the UNKNOWN value. At other times\n      we may use NOT_CONTAINED to mean not publicly contained. */\n-  enum sub_kind\n+  enum __sub_kind\n   {\n-    unknown = 0,              /* we have no idea */\n-    not_contained,            /* not contained within us (in some */\n-                              /* circumstances this might mean not contained */\n-                              /* publicly) */\n-    contained_ambig,          /* contained ambiguously */\n+    __unknown = 0,              /* we have no idea */\n+    __not_contained,            /* not contained within us (in some */\n+                                /* circumstances this might mean not contained */\n+                                /* publicly) */\n+    __contained_ambig,          /* contained ambiguously */\n     \n-    contained_virtual_mask = __base_class_info::virtual_mask, /* via a virtual path */\n-    contained_public_mask = __base_class_info::public_mask,   /* via a public path */\n-    contained_mask = 1 << __base_class_info::hwm_bit,         /* contained within us */\n+    __contained_virtual_mask = __base_class_info::virtual_mask, /* via a virtual path */\n+    __contained_public_mask = __base_class_info::public_mask,   /* via a public path */\n+    __contained_mask = 1 << __base_class_info::hwm_bit,         /* contained within us */\n     \n-    contained_private = contained_mask,\n-    contained_public = contained_mask | contained_public_mask\n+    __contained_private = __contained_mask,\n+    __contained_public = __contained_mask | __contained_public_mask\n   };\n \n public:  \n-  struct upcast_result\n-  {\n-    const void *dst_ptr;        /* pointer to caught object */\n-    sub_kind whole2dst;         /* path from most derived object to target */\n-    int src_details;            /* hints about the source type heirarchy */\n-    const __class_type_info *base_type; /* where we found the target, */\n-                                /* if in vbase the __class_type_info of vbase */\n-                                /* if a non-virtual base then 1 */\n-                                /* else NULL */\n-    public:\n-    upcast_result (int d)\n-      :dst_ptr (NULL), whole2dst (unknown), src_details (d), base_type (NULL)\n-      {}\n-  };\n-\n-public:\n-  /* dyncast_result is used to hold information during traversal of a class\n-     heirarchy when dynamic casting. */\n-  struct dyncast_result\n-  {\n-    const void *dst_ptr;        /* pointer to target object or NULL */\n-    sub_kind whole2dst;         /* path from most derived object to target */\n-    sub_kind whole2src;         /* path from most derived object to sub object */\n-    sub_kind dst2src;           /* path from target to sub object */\n-    \n-    public:\n-    dyncast_result ()\n-      :dst_ptr (NULL), whole2dst (unknown),\n-       whole2src (unknown), dst2src (unknown)\n-      {}\n-  };\n+  struct __upcast_result;\n+  struct __dyncast_result;\n \n /* implementation defined member functions */\n protected:\n-  virtual bool do_upcast (const __class_type_info *dst_type, void **obj_ptr) const;\n+  virtual bool __do_upcast (const __class_type_info *__dst_type, void **__obj_ptr) const;\n \n protected:\n-  virtual bool do_catch (const type_info *thr_type, void **thr_obj,\n-                         unsigned outer) const;\n+  virtual bool __do_catch (const type_info *__thr_type, void **__thr_obj,\n+                           unsigned __outer) const;\n \n \n public:\n   /* Helper for upcast. See if DST is us, or one of our bases. ACCESS_PATH */\n   /* gives the access from the start object. Return TRUE if we know the upcast */\n   /* fails. */\n-  virtual bool do_upcast (sub_kind access_path,\n-                          const __class_type_info *dst, const void *obj,\n-                          upcast_result &__restrict result) const;\n+  virtual bool __do_upcast (__sub_kind __access_path,\n+                            const __class_type_info *__dst,\n+                            const void *__obj,\n+                            __upcast_result &__restrict __result) const;\n \n public:\n   /* Indicate whether SRC_PTR of type SRC_TYPE is contained publicly within\n@@ -271,9 +243,10 @@ class __class_type_info\n      within this type.  If SRC_PTR is one of our SRC_TYPE bases, indicate the\n      virtuality. Returns not_contained for non containment or private\n      containment. */\n-  inline sub_kind find_public_src (std::ptrdiff_t src2dst, const void *obj_ptr,\n-                                   const __class_type_info *src_type,\n-                                   const void *src_ptr) const;\n+  inline __sub_kind __find_public_src (std::ptrdiff_t __src2dst,\n+                                       const void *__obj_ptr,\n+                                       const __class_type_info *__src_type,\n+                                       const void *__src_ptr) const;\n \n public:\n   /* dynamic cast helper. ACCESS_PATH gives the access from the most derived\n@@ -282,18 +255,22 @@ class __class_type_info\n      indicates the static type started from and SRC_PTR points to that base\n      within the most derived object. Fill in RESULT with what we find. Return\n      true if we have located an ambiguous match. */\n-  virtual bool do_dyncast (std::ptrdiff_t src2dst, sub_kind access_path,\n-                           const __class_type_info *dst_type, const void *obj_ptr,\n-                           const __class_type_info *src_type, const void *src_ptr,\n-                           dyncast_result &result) const;\n+  virtual bool __do_dyncast (std::ptrdiff_t __src2dst,\n+                             __sub_kind __access_path,\n+                             const __class_type_info *__dst_type,\n+                             const void *__obj_ptr,\n+                             const __class_type_info *__src_type,\n+                             const void *__src_ptr,\n+                             __dyncast_result &__result) const;\n public:\n   /* Helper for find_public_subobj. SRC2DST indicates how SRC_TYPE bases are\n      inherited by the type started from -- which is not necessarily the\n      current type. The current type will be a base of the destination type.\n      OBJ_PTR points to the current base. */\n-  virtual sub_kind do_find_public_src (std::ptrdiff_t src2dst, const void *obj_ptr,\n-                                       const __class_type_info *src_type,\n-                                       const void *src_ptr) const;\n+  virtual __sub_kind __do_find_public_src (std::ptrdiff_t __src2dst,\n+                                           const void *__obj_ptr,\n+                                           const __class_type_info *__src_type,\n+                                           const void *__src_ptr) const;\n };\n \n /* type information for a class with a single non-virtual base */\n@@ -308,23 +285,28 @@ class __si_class_type_info\n public:\n   virtual ~__si_class_type_info ();\n public:\n-  explicit __si_class_type_info (const char *n_,\n-                                 const __class_type_info *base_)\n-    : __class_type_info (n_), base (base_)\n+  explicit __si_class_type_info (const char *__n,\n+                                 const __class_type_info *__base)\n+    : __class_type_info (__n), base (__base)\n     { }\n \n /* implementation defined member functions */\n protected:\n-  virtual bool do_dyncast (std::ptrdiff_t src2dst, sub_kind access_path,\n-                           const __class_type_info *dst_type, const void *obj_ptr,\n-                           const __class_type_info *src_type, const void *src_ptr,\n-                           dyncast_result &result) const;\n-  virtual sub_kind do_find_public_src (std::ptrdiff_t src2dst, const void *obj_ptr,\n-                                       const __class_type_info *src_type,\n-                                       const void *sub_ptr) const;\n-  virtual bool do_upcast (sub_kind access_path,\n-                          const __class_type_info *dst, const void *obj,\n-                          upcast_result &__restrict result) const;\n+  virtual bool __do_dyncast (std::ptrdiff_t __src2dst,\n+                             __sub_kind __access_path,\n+                             const __class_type_info *__dst_type,\n+                             const void *__obj_ptr,\n+                             const __class_type_info *__src_type,\n+                             const void *__src_ptr,\n+                             __dyncast_result &__result) const;\n+  virtual __sub_kind __do_find_public_src (std::ptrdiff_t __src2dst,\n+                                           const void *__obj_ptr,\n+                                           const __class_type_info *__src_type,\n+                                           const void *__sub_ptr) const;\n+  virtual bool __do_upcast (__sub_kind __access_path,\n+                            const __class_type_info *__dst,\n+                            const void *__obj,\n+                            __upcast_result &__restrict __result) const;\n };\n \n /* type information for a class with multiple and/or virtual bases */\n@@ -342,9 +324,9 @@ class __vmi_class_type_info : public __class_type_info {\n public:\n   virtual ~__vmi_class_type_info ();\n public:\n-  explicit __vmi_class_type_info (const char *n_,\n-                                  int flags_)\n-    : __class_type_info (n_), vmi_flags (flags_), vmi_base_count (0)\n+  explicit __vmi_class_type_info (const char *__n,\n+                                  int __flags)\n+    : __class_type_info (__n), vmi_flags (__flags), vmi_base_count (0)\n     { }\n \n /* implementation defined types */\n@@ -355,28 +337,33 @@ class __vmi_class_type_info : public __class_type_info {\n     non_public_base_mask = 0x4,      /* has non-public direct or indirect base */\n     public_base_mask = 0x8,          /* has public base (direct) */\n     \n-    flags_unknown_mask = 0x10\n+    __flags_unknown_mask = 0x10\n   };\n \n /* implementation defined member functions */\n protected:\n-  virtual bool do_dyncast (std::ptrdiff_t src2dst, sub_kind access_path,\n-                           const __class_type_info *dst_type, const void *obj_ptr,\n-                           const __class_type_info *src_type, const void *src_ptr,\n-                           dyncast_result &result) const;\n-  virtual sub_kind do_find_public_src (std::ptrdiff_t src2dst, const void *obj_ptr,\n-                                       const __class_type_info *src_type,\n-                                       const void *src_ptr) const;\n-  virtual bool do_upcast (sub_kind access_path,\n-                          const __class_type_info *dst, const void *obj,\n-                          upcast_result &__restrict result) const;\n+  virtual bool __do_dyncast (std::ptrdiff_t __src2dst,\n+                             __sub_kind __access_path,\n+                             const __class_type_info *__dst_type,\n+                             const void *__obj_ptr,\n+                             const __class_type_info *__src_type,\n+                             const void *__src_ptr,\n+                             __dyncast_result &__result) const;\n+  virtual __sub_kind __do_find_public_src (std::ptrdiff_t __src2dst,\n+                                           const void *__obj_ptr,\n+                                           const __class_type_info *__src_type,\n+                                           const void *__src_ptr) const;\n+  virtual bool __do_upcast (__sub_kind __access_path,\n+                            const __class_type_info *__dst,\n+                            const void *__obj,\n+                            __upcast_result &__restrict __result) const;\n };\n \n /* dynamic cast runtime */\n-void *__dynamic_cast (const void *src_ptr,    /* object started from */\n-                      const __class_type_info *src_type, /* static type of object */\n-                      const __class_type_info *dst_type, /* desired target type */\n-                      std::ptrdiff_t src2dst); /* how src and dst are related */\n+void *__dynamic_cast (const void *__src_ptr,    /* object started from */\n+                      const __class_type_info *__src_type, /* static type of object */\n+                      const __class_type_info *__dst_type, /* desired target type */\n+                      std::ptrdiff_t __src2dst); /* how src and dst are related */\n \n     /* src2dst has the following possible values\n        >= 0: src_type is a unique public non-virtual base of dst_type"}, {"sha": "632e4533d6abcd31a6be08599f865aa33f3be247", "filename": "gcc/cp/inc/typeinfo", "status": "modified", "additions": 19, "deletions": 18, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e2d247261b874a7cf47f0b91b548a46107b6b44/gcc%2Fcp%2Finc%2Ftypeinfo", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e2d247261b874a7cf47f0b91b548a46107b6b44/gcc%2Fcp%2Finc%2Ftypeinfo", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finc%2Ftypeinfo?ref=7e2d247261b874a7cf47f0b91b548a46107b6b44", "patch": "@@ -38,10 +38,10 @@ private:\n   type_info (const type_info&);\n \n protected:\n-  const char *_name;\n+  const char *__name;\n \n protected:\n-  explicit type_info (const char *n): _name (n) { }\n+  explicit type_info (const char *__n): __name (__n) { }\n \n public:\n   // the public interface\n@@ -50,42 +50,43 @@ public:\n   // type. Uniqueness must use the _name value, not object address.\n   bool before (const type_info& arg) const;\n   const char* name () const\n-    { return _name; }\n-  bool operator== (const type_info& arg) const;\n-  bool operator!= (const type_info& arg) const\n-    { return !operator== (arg); }\n+    { return __name; }\n+  bool operator== (const type_info& __arg) const;\n+  bool operator!= (const type_info& __arg) const\n+    { return !operator== (__arg); }\n \n #else\n   // In new abi we can rely on type_info's being unique,\n   // and therefore address comparisons are sufficient.\n-  bool before (const type_info& arg) const\n-    { return this < &arg; }\n+  bool before (const type_info& __arg) const\n+    { return this < &__arg; }\n   const char* name () const\n-    { return _name; }\n-  bool operator== (const type_info& arg) const\n-    { return &arg == this; }\n-  bool operator!= (const type_info& arg) const\n-    { return !operator== (arg); }\n+    { return __name; }\n+  bool operator== (const type_info& __arg) const\n+    { return &__arg == this; }\n+  bool operator!= (const type_info& __arg) const\n+    { return !operator== (__arg); }\n #endif\n \n   // the internal interface\n #if defined(__GXX_ABI_VERSION) && __GXX_ABI_VERSION >= 100\n public:\n   // return true if this is a pointer type of some kind\n-  virtual bool is_pointer_p () const;\n+  virtual bool __is_pointer_p () const;\n   // return true if this is a function type\n-  virtual bool is_function_p () const;\n+  virtual bool __is_function_p () const;\n \n   // Try and catch a thrown type. Store an adjusted pointer to the caught type\n   // in THR_OBJ. If THR_TYPE is not a pointer type, then THR_OBJ points to the\n   // thrown object. If THR_TYPE is a pointer type, then THR_OBJ is the pointer\n   // itself. OUTER indicates the number of outer pointers, and whether they\n   // were const qualified.\n-  virtual bool do_catch (const type_info *thr_type, void **thr_obj,\n-                         unsigned outer) const;\n+  virtual bool __do_catch (const type_info *__thr_type, void **__thr_obj,\n+                         unsigned __outer) const;\n \n   // internally used during catch matching\n-  virtual bool do_upcast (const __cxxabiv1::__class_type_info *target, void **obj_ptr) const;\n+  virtual bool __do_upcast (const __cxxabiv1::__class_type_info *__target,\n+\t\t\t    void **__obj_ptr) const;\n #endif\n };\n "}, {"sha": "d84d83ee359c3af12ca42d1fce3a9e1c76d47005", "filename": "gcc/cp/tinfo.cc", "status": "modified", "additions": 184, "deletions": 146, "changes": 330, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e2d247261b874a7cf47f0b91b548a46107b6b44/gcc%2Fcp%2Ftinfo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e2d247261b874a7cf47f0b91b548a46107b6b44/gcc%2Fcp%2Ftinfo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftinfo.cc?ref=7e2d247261b874a7cf47f0b91b548a46107b6b44", "patch": "@@ -541,28 +541,28 @@ namespace std {\n \n // return true if this is a type_info for a pointer type\n bool type_info::\n-is_pointer_p () const\n+__is_pointer_p () const\n {\n   return false;\n }\n \n // return true if this is a type_info for a function type\n bool type_info::\n-is_function_p () const\n+__is_function_p () const\n {\n   return false;\n }\n \n // try and catch a thrown object.\n bool type_info::\n-do_catch (const type_info *thr_type, void **, unsigned) const\n+__do_catch (const type_info *thr_type, void **, unsigned) const\n {\n   return *this == *thr_type;\n }\n \n // upcast from this type to the target. __class_type_info will override\n bool type_info::\n-do_upcast (const abi::__class_type_info *, void **) const\n+__do_upcast (const abi::__class_type_info *, void **) const\n {\n   return false;\n }\n@@ -605,31 +605,34 @@ convert_to_base (void const *addr, bool is_virtual, ptrdiff_t offset)\n   return adjust_pointer<void> (addr, offset);\n }\n \n-// some predicate functions for __class_type_info::sub_kind\n-inline bool contained_p (__class_type_info::sub_kind access_path)\n+// some predicate functions for __class_type_info::__sub_kind\n+inline bool contained_p (__class_type_info::__sub_kind access_path)\n {\n-  return access_path >= __class_type_info::contained_mask;\n+  return access_path >= __class_type_info::__contained_mask;\n }\n-inline bool public_p (__class_type_info::sub_kind access_path)\n+inline bool public_p (__class_type_info::__sub_kind access_path)\n {\n-  return access_path & __class_type_info::contained_public_mask;\n+  return access_path & __class_type_info::__contained_public_mask;\n }\n-inline bool virtual_p (__class_type_info::sub_kind access_path)\n+inline bool virtual_p (__class_type_info::__sub_kind access_path)\n {\n-  return (access_path & __class_type_info::contained_virtual_mask);\n+  return (access_path & __class_type_info::__contained_virtual_mask);\n }\n-inline bool contained_public_p (__class_type_info::sub_kind access_path)\n+inline bool contained_public_p (__class_type_info::__sub_kind access_path)\n {\n-  return (access_path & __class_type_info::contained_public) == __class_type_info::contained_public;\n+  return ((access_path & __class_type_info::__contained_public)\n+          == __class_type_info::__contained_public);\n }\n-inline bool contained_nonpublic_p (__class_type_info::sub_kind access_path)\n+inline bool contained_nonpublic_p (__class_type_info::__sub_kind access_path)\n {\n-  return (access_path & __class_type_info::contained_public) == __class_type_info::contained_mask;\n+  return ((access_path & __class_type_info::__contained_public)\n+          == __class_type_info::__contained_mask);\n }\n-inline bool contained_nonvirtual_p (__class_type_info::sub_kind access_path)\n+inline bool contained_nonvirtual_p (__class_type_info::__sub_kind access_path)\n {\n-  return (access_path & (__class_type_info::contained_mask | __class_type_info::contained_virtual_mask))\n-         == __class_type_info::contained_mask;\n+  return ((access_path & (__class_type_info::__contained_mask\n+                          | __class_type_info::__contained_virtual_mask))\n+          == __class_type_info::__contained_mask);\n }\n \n static const __class_type_info *const nonvirtual_base_type =\n@@ -652,83 +655,118 @@ __vmi_class_type_info::\n ~__vmi_class_type_info ()\n {}\n \n+// __upcast_result is used to hold information during traversal of a class\n+// heirarchy when catch matching.\n+struct __class_type_info::__upcast_result\n+{\n+  const void *dst_ptr;        // pointer to caught object\n+  __sub_kind whole2dst;       // path from most derived object to target\n+  int src_details;            // hints about the source type heirarchy\n+  const __class_type_info *base_type; // where we found the target,\n+                              // if in vbase the __class_type_info of vbase\n+                              // if a non-virtual base then 1\n+                              // else NULL\n+  public:\n+  __upcast_result (int d)\n+    :dst_ptr (NULL), whole2dst (__unknown), src_details (d), base_type (NULL)\n+    {}\n+};\n+\n+// __dyncast_result is used to hold information during traversal of a class\n+// heirarchy when dynamic casting.\n+struct __class_type_info::__dyncast_result\n+{\n+  const void *dst_ptr;        // pointer to target object or NULL\n+  __sub_kind whole2dst;       // path from most derived object to target\n+  __sub_kind whole2src;       // path from most derived object to sub object\n+  __sub_kind dst2src;         // path from target to sub object\n+  \n+  public:\n+  __dyncast_result ()\n+    :dst_ptr (NULL), whole2dst (__unknown),\n+     whole2src (__unknown), dst2src (__unknown)\n+    {}\n+};\n+\n bool __class_type_info::\n-do_catch (const type_info *thr_type, void **thr_obj,\n-          unsigned outer) const\n+__do_catch (const type_info *thr_type,\n+            void **thr_obj,\n+            unsigned outer) const\n {\n   if (*this == *thr_type)\n     return true;\n   if (outer >= 4)\n     // Neither `A' nor `A *'.\n     return false;\n-  return thr_type->do_upcast (this, thr_obj);\n+  return thr_type->__do_upcast (this, thr_obj);\n }\n \n bool __class_type_info::\n-do_upcast (const __class_type_info *dst_type, void **obj_ptr) const\n+__do_upcast (const __class_type_info *dst_type,\n+             void **obj_ptr) const\n {\n-  upcast_result result (__vmi_class_type_info::flags_unknown_mask);\n+  __upcast_result result (__vmi_class_type_info::__flags_unknown_mask);\n   \n-  if (do_upcast (contained_public, dst_type, *obj_ptr, result))\n+  if (__do_upcast (__contained_public, dst_type, *obj_ptr, result))\n     return false;\n   *obj_ptr = const_cast <void *> (result.dst_ptr);\n   return contained_public_p (result.whole2dst);\n }\n \n-inline __class_type_info::sub_kind __class_type_info::\n-find_public_src (ptrdiff_t src2dst,\n-                 const void *obj_ptr,\n-                 const __class_type_info *src_type,\n-                 const void *src_ptr) const\n+inline __class_type_info::__sub_kind __class_type_info::\n+__find_public_src (ptrdiff_t src2dst,\n+                   const void *obj_ptr,\n+                   const __class_type_info *src_type,\n+                   const void *src_ptr) const\n {\n   if (src2dst >= 0)\n     return adjust_pointer <void> (obj_ptr, src2dst) == src_ptr\n-            ? contained_public : not_contained;\n+            ? __contained_public : __not_contained;\n   if (src2dst == -2)\n-    return not_contained;\n-  return do_find_public_src (src2dst, obj_ptr, src_type, src_ptr);\n+    return __not_contained;\n+  return __do_find_public_src (src2dst, obj_ptr, src_type, src_ptr);\n }\n \n-__class_type_info::sub_kind __class_type_info::\n-do_find_public_src (ptrdiff_t,\n-                    const void *obj_ptr,\n-                    const __class_type_info *,\n-                    const void *src_ptr) const\n+__class_type_info::__sub_kind __class_type_info::\n+__do_find_public_src (ptrdiff_t,\n+                      const void *obj_ptr,\n+                      const __class_type_info *,\n+                      const void *src_ptr) const\n {\n   if (src_ptr == obj_ptr)\n     // Must be our type, as the pointers match.\n-    return contained_public;\n-  return not_contained;\n+    return __contained_public;\n+  return __not_contained;\n }\n \n-__class_type_info::sub_kind __si_class_type_info::\n-do_find_public_src (ptrdiff_t src2dst,\n-                    const void *obj_ptr,\n-                    const __class_type_info *src_type,\n-                    const void *src_ptr) const\n+__class_type_info::__sub_kind __si_class_type_info::\n+__do_find_public_src (ptrdiff_t src2dst,\n+                      const void *obj_ptr,\n+                      const __class_type_info *src_type,\n+                      const void *src_ptr) const\n {\n   if (src_ptr == obj_ptr && *this == *src_type)\n-    return contained_public;\n-  return base->do_find_public_src (src2dst, obj_ptr, src_type, src_ptr);\n+    return __contained_public;\n+  return base->__do_find_public_src (src2dst, obj_ptr, src_type, src_ptr);\n }\n \n-__class_type_info::sub_kind __vmi_class_type_info::\n-do_find_public_src (ptrdiff_t src2dst,\n-                    const void *obj_ptr,\n-                    const __class_type_info *src_type,\n-                    const void *src_ptr) const\n+__class_type_info::__sub_kind __vmi_class_type_info::\n+__do_find_public_src (ptrdiff_t src2dst,\n+                      const void *obj_ptr,\n+                      const __class_type_info *src_type,\n+                      const void *src_ptr) const\n {\n   if (obj_ptr == src_ptr && *this == *src_type)\n-    return contained_public;\n+    return __contained_public;\n   \n   for (size_t i = vmi_base_count; i--;)\n     {\n-      if (!vmi_bases[i].is_public_p ())\n+      if (!vmi_bases[i].__is_public_p ())\n         continue; // Not public, can't be here.\n       \n       const void *base = obj_ptr;\n-      ptrdiff_t offset = vmi_bases[i].offset ();\n-      bool is_virtual = vmi_bases[i].is_virtual_p ();\n+      ptrdiff_t offset = vmi_bases[i].__offset ();\n+      bool is_virtual = vmi_bases[i].__is_virtual_p ();\n       \n       if (is_virtual)\n         {\n@@ -737,27 +775,27 @@ do_find_public_src (ptrdiff_t src2dst,\n         }\n       base = convert_to_base (base, is_virtual, offset);\n       \n-      sub_kind base_kind = vmi_bases[i].base->do_find_public_src\n+      __sub_kind base_kind = vmi_bases[i].base->__do_find_public_src\n                               (src2dst, base, src_type, src_ptr);\n       if (contained_p (base_kind))\n         {\n           if (is_virtual)\n-            base_kind = sub_kind (base_kind | contained_virtual_mask);\n+            base_kind = __sub_kind (base_kind | __contained_virtual_mask);\n           return base_kind;\n         }\n     }\n   \n-  return not_contained;\n+  return __not_contained;\n }\n \n bool __class_type_info::\n-do_dyncast (ptrdiff_t,\n-            sub_kind access_path,\n-            const __class_type_info *dst_type,\n-            const void *obj_ptr,\n-            const __class_type_info *src_type,\n-            const void *src_ptr,\n-            dyncast_result &__restrict result) const\n+__do_dyncast (ptrdiff_t,\n+              __sub_kind access_path,\n+              const __class_type_info *dst_type,\n+              const void *obj_ptr,\n+              const __class_type_info *src_type,\n+              const void *src_ptr,\n+              __dyncast_result &__restrict result) const\n {\n   if (obj_ptr == src_ptr && *this == *src_type)\n     {\n@@ -770,30 +808,30 @@ do_dyncast (ptrdiff_t,\n     {\n       result.dst_ptr = obj_ptr;\n       result.whole2dst = access_path;\n-      result.dst2src = not_contained;\n+      result.dst2src = __not_contained;\n       return false;\n     }\n   return false;\n }\n \n bool __si_class_type_info::\n-do_dyncast (ptrdiff_t src2dst,\n-            sub_kind access_path,\n-            const __class_type_info *dst_type,\n-            const void *obj_ptr,\n-            const __class_type_info *src_type,\n-            const void *src_ptr,\n-            dyncast_result &__restrict result) const\n+__do_dyncast (ptrdiff_t src2dst,\n+              __sub_kind access_path,\n+              const __class_type_info *dst_type,\n+              const void *obj_ptr,\n+              const __class_type_info *src_type,\n+              const void *src_ptr,\n+              __dyncast_result &__restrict result) const\n {\n   if (*this == *dst_type)\n     {\n       result.dst_ptr = obj_ptr;\n       result.whole2dst = access_path;\n       if (src2dst >= 0)\n         result.dst2src = adjust_pointer <void> (obj_ptr, src2dst) == src_ptr\n-              ? contained_public : not_contained;\n+              ? __contained_public : __not_contained;\n       else if (src2dst == -2)\n-        result.dst2src = not_contained;\n+        result.dst2src = __not_contained;\n       return false;\n     }\n   if (obj_ptr == src_ptr && *this == *src_type)\n@@ -803,8 +841,8 @@ do_dyncast (ptrdiff_t src2dst,\n       result.whole2src = access_path;\n       return false;\n     }\n-  return base->do_dyncast (src2dst, access_path, dst_type, obj_ptr,\n-                           src_type, src_ptr, result);\n+  return base->__do_dyncast (src2dst, access_path, dst_type, obj_ptr,\n+                             src_type, src_ptr, result);\n }\n \n // This is a big hairy function. Although the run-time behaviour of\n@@ -817,13 +855,13 @@ do_dyncast (ptrdiff_t src2dst,\n // work by filling in things lazily (when we know we need the information),\n // and opportunisticly take early success or failure results.\n bool __vmi_class_type_info::\n-do_dyncast (ptrdiff_t src2dst,\n-            sub_kind access_path,\n-            const __class_type_info *dst_type,\n-            const void *obj_ptr,\n-            const __class_type_info *src_type,\n-            const void *src_ptr,\n-            dyncast_result &__restrict result) const\n+__do_dyncast (ptrdiff_t src2dst,\n+              __sub_kind access_path,\n+              const __class_type_info *dst_type,\n+              const void *obj_ptr,\n+              const __class_type_info *src_type,\n+              const void *src_ptr,\n+              __dyncast_result &__restrict result) const\n {\n   if (obj_ptr == src_ptr && *this == *src_type)\n     {\n@@ -838,34 +876,34 @@ do_dyncast (ptrdiff_t src2dst,\n       result.whole2dst = access_path;\n       if (src2dst >= 0)\n         result.dst2src = adjust_pointer <void> (obj_ptr, src2dst) == src_ptr\n-              ? contained_public : not_contained;\n+              ? __contained_public : __not_contained;\n       else if (src2dst == -2)\n-        result.dst2src = not_contained;\n+        result.dst2src = __not_contained;\n       return false;\n     }\n   bool result_ambig = false;\n   for (size_t i = vmi_base_count; i--;)\n     {\n-      dyncast_result result2;\n+      __dyncast_result result2;\n       void const *base = obj_ptr;\n-      sub_kind base_access = access_path;\n-      ptrdiff_t offset = vmi_bases[i].offset ();\n-      bool is_virtual = vmi_bases[i].is_virtual_p ();\n+      __sub_kind base_access = access_path;\n+      ptrdiff_t offset = vmi_bases[i].__offset ();\n+      bool is_virtual = vmi_bases[i].__is_virtual_p ();\n       \n       if (is_virtual)\n-        base_access = sub_kind (base_access | contained_virtual_mask);\n+        base_access = __sub_kind (base_access | __contained_virtual_mask);\n       base = convert_to_base (base, is_virtual, offset);\n \n-      if (!vmi_bases[i].is_public_p ())\n-        base_access = sub_kind (base_access & ~contained_public_mask);\n+      if (!vmi_bases[i].__is_public_p ())\n+        base_access = __sub_kind (base_access & ~__contained_public_mask);\n       \n       bool result2_ambig\n-          = vmi_bases[i].base->do_dyncast (src2dst, base_access,\n-                                           dst_type, base,\n-                                           src_type, src_ptr, result2);\n-      result.whole2src = sub_kind (result.whole2src | result2.whole2src);\n-      if (result2.dst2src == contained_public\n-          || result2.dst2src == contained_ambig)\n+          = vmi_bases[i].base->__do_dyncast (src2dst, base_access,\n+                                             dst_type, base,\n+                                             src_type, src_ptr, result2);\n+      result.whole2src = __sub_kind (result.whole2src | result2.whole2src);\n+      if (result2.dst2src == __contained_public\n+          || result2.dst2src == __contained_ambig)\n         {\n           result.dst_ptr = result2.dst_ptr;\n           result.whole2dst = result2.whole2dst;\n@@ -887,7 +925,7 @@ do_dyncast (ptrdiff_t src2dst,\n           // Found at same address, must be via virtual.  Pick the most\n           // accessible path.\n           result.whole2dst =\n-              sub_kind (result.whole2dst | result2.whole2dst);\n+              __sub_kind (result.whole2dst | result2.whole2dst);\n         }\n       else if ((result.dst_ptr && result2.dst_ptr)\n                || (result_ambig && result2.dst_ptr)\n@@ -901,45 +939,45 @@ do_dyncast (ptrdiff_t src2dst,\n           // but don't yet fail as we might later find a third base which does\n           // contain SRC_PTR.\n         \n-          sub_kind new_sub_kind = result2.dst2src;\n-          sub_kind old_sub_kind = result.dst2src;\n+          __sub_kind new_sub_kind = result2.dst2src;\n+          __sub_kind old_sub_kind = result.dst2src;\n           \n           if (contained_nonvirtual_p (result.whole2src))\n             {\n               // We already found SRC_PTR as a non-virtual base of most\n               // derived. Therefore if it is in either choice, it can only be\n               // in one of them, and we will already know.\n-              if (old_sub_kind == unknown)\n-                old_sub_kind = not_contained;\n-              if (new_sub_kind == unknown)\n-                new_sub_kind = not_contained;\n+              if (old_sub_kind == __unknown)\n+                old_sub_kind = __not_contained;\n+              if (new_sub_kind == __unknown)\n+                new_sub_kind = __not_contained;\n             }\n           else\n             {\n-              if (old_sub_kind >= not_contained)\n+              if (old_sub_kind >= __not_contained)\n                 ;// already calculated\n               else if (contained_nonvirtual_p (new_sub_kind))\n                 // Already found non-virtually inside the other choice,\n                 // cannot be in this.\n-                old_sub_kind = not_contained;\n+                old_sub_kind = __not_contained;\n               else\n-                old_sub_kind = dst_type->find_public_src\n+                old_sub_kind = dst_type->__find_public_src\n                                 (src2dst, result.dst_ptr, src_type, src_ptr);\n           \n-              if (new_sub_kind >= not_contained)\n+              if (new_sub_kind >= __not_contained)\n                 ;// already calculated\n               else if (contained_nonvirtual_p (old_sub_kind))\n                 // Already found non-virtually inside the other choice,\n                 // cannot be in this.\n-                new_sub_kind = not_contained;\n+                new_sub_kind = __not_contained;\n               else\n-                new_sub_kind = dst_type->find_public_src\n+                new_sub_kind = dst_type->__find_public_src\n                                 (src2dst, result2.dst_ptr, src_type, src_ptr);\n             }\n           \n           // Neither sub_kind can be contained_ambig -- we bail out early\n           // when we find those.\n-          if (contained_p (sub_kind (new_sub_kind ^ old_sub_kind)))\n+          if (contained_p (__sub_kind (new_sub_kind ^ old_sub_kind)))\n             {\n               // Only on one choice, not ambiguous.\n               if (contained_p (new_sub_kind))\n@@ -956,11 +994,11 @@ do_dyncast (ptrdiff_t src2dst,\n               if (!virtual_p (result.dst2src))\n                 return false; // Found non-virtually can't be bettered\n             }\n-          else if (contained_p (sub_kind (new_sub_kind & old_sub_kind)))\n+          else if (contained_p (__sub_kind (new_sub_kind & old_sub_kind)))\n             {\n               // In both.\n               result.dst_ptr = NULL;\n-              result.dst2src = contained_ambig;\n+              result.dst2src = __contained_ambig;\n               return true;  // Fail.\n             }\n           else\n@@ -969,12 +1007,12 @@ do_dyncast (ptrdiff_t src2dst,\n               // looking. It is possible that it was private in one or\n               // both and therefore we should fail, but that's just tough.\n               result.dst_ptr = NULL;\n-              result.dst2src = not_contained;\n+              result.dst2src = __not_contained;\n               result_ambig = true;\n             }\n         }\n       \n-      if (result.whole2src == contained_private)\n+      if (result.whole2src == __contained_private)\n         // We found SRC_PTR as a private non-virtual base, therefore all\n         // cross casts will fail. We have already found a down cast, if\n         // there is one.\n@@ -985,9 +1023,9 @@ do_dyncast (ptrdiff_t src2dst,\n }\n \n bool __class_type_info::\n-do_upcast (sub_kind access_path,\n-           const __class_type_info *dst, const void *obj,\n-           upcast_result &__restrict result) const\n+__do_upcast (__sub_kind access_path,\n+             const __class_type_info *dst, const void *obj,\n+             __upcast_result &__restrict result) const\n {\n   if (*this == *dst)\n     {\n@@ -1000,9 +1038,9 @@ do_upcast (sub_kind access_path,\n }\n \n bool __si_class_type_info::\n-do_upcast (sub_kind access_path,\n-           const __class_type_info *dst, const void *obj_ptr,\n-           upcast_result &__restrict result) const\n+__do_upcast (__sub_kind access_path,\n+             const __class_type_info *dst, const void *obj_ptr,\n+             __upcast_result &__restrict result) const\n {\n   if (*this == *dst)\n     {\n@@ -1011,13 +1049,13 @@ do_upcast (sub_kind access_path,\n       result.whole2dst = access_path;\n       return contained_nonpublic_p (access_path);\n     }\n-  return base->do_upcast (access_path, dst, obj_ptr, result);\n+  return base->__do_upcast (access_path, dst, obj_ptr, result);\n }\n \n bool __vmi_class_type_info::\n-do_upcast (sub_kind access_path,\n-           const __class_type_info *dst, const void *obj_ptr,\n-           upcast_result &__restrict result) const\n+__do_upcast (__sub_kind access_path,\n+             const __class_type_info *dst, const void *obj_ptr,\n+             __upcast_result &__restrict result) const\n {\n   if (*this == *dst)\n     {\n@@ -1028,30 +1066,30 @@ do_upcast (sub_kind access_path,\n     }\n   \n   int src_details = result.src_details;\n-  if (src_details & flags_unknown_mask)\n+  if (src_details & __flags_unknown_mask)\n     src_details = vmi_flags;\n   \n   for (size_t i = vmi_base_count; i--;)\n     {\n-      upcast_result result2 (src_details);\n+      __upcast_result result2 (src_details);\n       const void *base = obj_ptr;\n-      sub_kind sub_access = access_path;\n-      ptrdiff_t offset = vmi_bases[i].offset ();\n-      bool is_virtual = vmi_bases[i].is_virtual_p ();\n+      __sub_kind sub_access = access_path;\n+      ptrdiff_t offset = vmi_bases[i].__offset ();\n+      bool is_virtual = vmi_bases[i].__is_virtual_p ();\n       \n-      if (!vmi_bases[i].is_public_p ())\n+      if (!vmi_bases[i].__is_public_p ())\n         {\n           if (!(src_details & non_diamond_repeat_mask))\n             // original cannot have an ambiguous base\n             continue;\n-          sub_access = sub_kind (sub_access & ~contained_public_mask);\n+          sub_access = __sub_kind (sub_access & ~__contained_public_mask);\n         }\n       if (is_virtual)\n-    \t  sub_access = sub_kind (sub_access | contained_virtual_mask);\n+    \t  sub_access = __sub_kind (sub_access | __contained_virtual_mask);\n       if (base)\n         base = convert_to_base (base, is_virtual, offset);\n       \n-      if (vmi_bases[i].base->do_upcast (sub_access, dst, base, result2))\n+      if (vmi_bases[i].base->__do_upcast (sub_access, dst, base, result2))\n         return true; // must fail\n       if (result2.base_type)\n         {\n@@ -1068,14 +1106,14 @@ do_upcast (sub_kind access_path,\n             {\n               // Found an ambiguity.\n \t      result.dst_ptr = NULL;\n-\t      result.whole2dst = contained_ambig;\n+\t      result.whole2dst = __contained_ambig;\n \t      return true;\n             }\n           else if (result.dst_ptr)\n             {\n               // Ok, found real object via a virtual path.\n               result.whole2dst\n-                  = sub_kind (result.whole2dst | result2.whole2dst);\n+                  = __sub_kind (result.whole2dst | result2.whole2dst);\n             }\n           else\n             {\n@@ -1087,7 +1125,7 @@ do_upcast (sub_kind access_path,\n                 {\n                   // Already ambiguous, not virtual or via different virtuals.\n                   // Cannot match.\n-                  result.whole2dst = contained_ambig;\n+                  result.whole2dst = __contained_ambig;\n                   return true;\n                 }\n             }\n@@ -1110,15 +1148,15 @@ __dynamic_cast (const void *src_ptr,    // object started from\n   const void *whole_ptr =\n       adjust_pointer <void> (src_ptr, prefix->whole_object);\n   const __class_type_info *whole_type = prefix->whole_type;\n-  __class_type_info::dyncast_result result;\n+  __class_type_info::__dyncast_result result;\n   \n-  whole_type->do_dyncast (src2dst, __class_type_info::contained_public,\n-                          dst_type, whole_ptr, src_type, src_ptr, result);\n+  whole_type->__do_dyncast (src2dst, __class_type_info::__contained_public,\n+                            dst_type, whole_ptr, src_type, src_ptr, result);\n   if (!result.dst_ptr)\n     return NULL;\n   if (contained_public_p (result.dst2src))\n     return const_cast <void *> (result.dst_ptr);\n-  if (contained_public_p (__class_type_info::sub_kind (result.whole2src & result.whole2dst)))\n+  if (contained_public_p (__class_type_info::__sub_kind (result.whole2src & result.whole2dst)))\n     // Found a valid cross cast\n     return const_cast <void *> (result.dst_ptr);\n   if (contained_nonvirtual_p (result.whole2src))\n@@ -1129,9 +1167,9 @@ __dynamic_cast (const void *src_ptr,    // object started from\n     // whole type has no private bases\n     return const_cast <void *> (result.dst_ptr);\n   #endif\n-  if (result.dst2src == __class_type_info::unknown)\n-    result.dst2src = dst_type->find_public_src (src2dst, result.dst_ptr,\n-                                                src_type, src_ptr);\n+  if (result.dst2src == __class_type_info::__unknown)\n+    result.dst2src = dst_type->__find_public_src (src2dst, result.dst_ptr,\n+                                                  src_type, src_ptr);\n   if (contained_public_p (result.dst2src))\n     // Found a valid down cast\n     return const_cast <void *> (result.dst_ptr);"}, {"sha": "b41b0715558df0c89abdddd95d71dc73ff1344f4", "filename": "gcc/cp/tinfo2.cc", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e2d247261b874a7cf47f0b91b548a46107b6b44/gcc%2Fcp%2Ftinfo2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e2d247261b874a7cf47f0b91b548a46107b6b44/gcc%2Fcp%2Ftinfo2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftinfo2.cc?ref=7e2d247261b874a7cf47f0b91b548a46107b6b44", "patch": "@@ -127,21 +127,21 @@ __pointer_to_member_type_info::\n {}\n \n bool __pointer_type_info::\n-is_pointer_p () const\n+__is_pointer_p () const\n {\n   return true;\n }\n \n bool __function_type_info::\n-is_function_p () const\n+__is_function_p () const\n {\n   return true;\n }\n \n bool __pointer_type_info::\n-do_catch (const type_info *thr_type,\n-          void **thr_obj,\n-          unsigned outer) const\n+__do_catch (const type_info *thr_type,\n+            void **thr_obj,\n+            unsigned outer) const\n {\n   if (*this == *thr_type)\n     return true;      // same type\n@@ -167,16 +167,16 @@ do_catch (const type_info *thr_type,\n   if (outer < 2 && *type == typeid (void))\n     {\n       // conversion to void\n-      return !thrown_type->is_function_p ();\n+      return !thrown_type->__is_function_p ();\n     }\n   \n-  return type->do_catch (thrown_type->type, thr_obj, outer + 2);\n+  return type->__do_catch (thrown_type->type, thr_obj, outer + 2);\n }\n \n bool __pointer_to_member_type_info::\n-do_catch (const type_info *thr_type,\n-          void **thr_obj,\n-          unsigned outer) const\n+__do_catch (const type_info *thr_type,\n+            void **thr_obj,\n+            unsigned outer) const\n {\n   if (*this == *thr_type)\n     return true;      // same type\n@@ -202,7 +202,7 @@ do_catch (const type_info *thr_type,\n   if (*klass != *thrown_type->klass)\n     return false;     // not pointers to member of same class\n   \n-  return type->do_catch (thrown_type->type, thr_obj, outer + 2);\n+  return type->__do_catch (thrown_type->type, thr_obj, outer + 2);\n }\n \n } // namespace std\n@@ -338,7 +338,7 @@ __throw_type_match_rtti_2 (const void *catch_type_r, const void *throw_type_r,\n #else\n // new abi\n   \n-  return catch_type.do_catch (&throw_type, valp, 1);\n+  return catch_type.__do_catch (&throw_type, valp, 1);\n #endif\n   return 0;\n }\n@@ -371,7 +371,7 @@ __is_pointer (void *p)\n   return pt != 0;\n #else\n // new abi\n-  return t->is_pointer_p ();\n+  return t->__is_pointer_p ();\n #endif\n }\n "}]}