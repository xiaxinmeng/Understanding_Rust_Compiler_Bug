{"sha": "127b81366e7ee0700cec2733126fc35e85a59122", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTI3YjgxMzY2ZTdlZTA3MDBjZWMyNzMzMTI2ZmMzNWU4NWE1OTEyMg==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2003-07-06T22:21:35Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2003-07-06T22:21:35Z"}, "message": "re PR c++/11345 (ICE in build_base_path)\n\n\tPR c++/11345\n\t* search.c (lookup_base_r): Remove is_non_public and\n\twithin_current_scope parameters.  Remove other dead code.\n\t(lookup_base): Adjust call to lookup_base_r.\n\t(adjust_result_of_qualified_name_lookup): Improve comment.\n\t* semantics.c (finish_call_expr): Use maybe_dummy_object.\n\nFrom-SVN: r69020", "tree": {"sha": "6523550b6fba087a12d7334a2c2ef107a8516309", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6523550b6fba087a12d7334a2c2ef107a8516309"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/127b81366e7ee0700cec2733126fc35e85a59122", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/127b81366e7ee0700cec2733126fc35e85a59122", "html_url": "https://github.com/Rust-GCC/gccrs/commit/127b81366e7ee0700cec2733126fc35e85a59122", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/127b81366e7ee0700cec2733126fc35e85a59122/comments", "author": null, "committer": null, "parents": [{"sha": "513dab32088cd1a2b6d361c04db7917fb3dcb8d9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/513dab32088cd1a2b6d361c04db7917fb3dcb8d9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/513dab32088cd1a2b6d361c04db7917fb3dcb8d9"}], "stats": {"total": 79, "additions": 25, "deletions": 54}, "files": [{"sha": "8ea3274440bc42ce1d9b8e691c59cee0fe70c119", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/127b81366e7ee0700cec2733126fc35e85a59122/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/127b81366e7ee0700cec2733126fc35e85a59122/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=127b81366e7ee0700cec2733126fc35e85a59122", "patch": "@@ -1,3 +1,12 @@\n+2003-07-06  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tPR c++/11345\n+\t* search.c (lookup_base_r): Remove is_non_public and\n+\twithin_current_scope parameters.  Remove other dead code.\n+\t(lookup_base): Adjust call to lookup_base_r.\n+\t(adjust_result_of_qualified_name_lookup): Improve comment.\n+\t* semantics.c (finish_call_expr): Use maybe_dummy_object.\n+\n 2003-07-06  Neil Booth  <neil@daikokuya.co.uk>\n \n \t* cp-lang.c (LANG_HOOKS_HANDLE_FILENAME,"}, {"sha": "b169ba072df2ab116af4d21f9c3e3f76c653695a", "filename": "gcc/cp/search.c", "status": "modified", "additions": 14, "deletions": 53, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/127b81366e7ee0700cec2733126fc35e85a59122/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/127b81366e7ee0700cec2733126fc35e85a59122/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=127b81366e7ee0700cec2733126fc35e85a59122", "patch": "@@ -83,8 +83,7 @@ struct vbase_info\n \n static tree dfs_check_overlap (tree, void *);\n static tree dfs_no_overlap_yet (tree, int, void *);\n-static base_kind lookup_base_r (tree, tree, base_access,\n-\t\t\t\tbool, bool, bool, tree *);\n+static base_kind lookup_base_r (tree, tree, base_access, bool, tree *);\n static int dynamic_cast_base_recurse (tree, tree, bool, tree *);\n static tree marked_pushdecls_p (tree, int, void *);\n static tree unmarked_pushdecls_p (tree, int, void *);\n@@ -147,12 +146,8 @@ static int n_contexts_saved;\n \f\n /* Worker for lookup_base.  BINFO is the binfo we are searching at,\n    BASE is the RECORD_TYPE we are searching for.  ACCESS is the\n-   required access checks.  WITHIN_CURRENT_SCOPE, IS_NON_PUBLIC and\n-   IS_VIRTUAL indicate how BINFO was reached from the start of the\n-   search.  WITHIN_CURRENT_SCOPE is true if we met the current scope,\n-   or friend thereof (this allows us to determine whether a protected\n-   base is accessible or not).  IS_NON_PUBLIC indicates whether BINFO\n-   is accessible and IS_VIRTUAL indicates if it is morally virtual.\n+   required access checks.  IS_VIRTUAL indicates if BINFO is morally\n+   virtual.\n \n    If BINFO is of the required type, then *BINFO_PTR is examined to\n    compare with any other instance of BASE we might have already\n@@ -163,24 +158,13 @@ static int n_contexts_saved;\n \n static base_kind\n lookup_base_r (tree binfo, tree base, base_access access,\n-\t       bool within_current_scope,\n-\t       bool is_non_public,\t\t/* inside a non-public part */\n \t       bool is_virtual,\t\t\t/* inside a virtual part */\n \t       tree *binfo_ptr)\n {\n   int i;\n   tree bases, accesses;\n   base_kind found = bk_not_base;\n   \n-  if (access == ba_check\n-      && !within_current_scope\n-      && is_friend (BINFO_TYPE (binfo), current_scope ()))\n-    {\n-      /* Do not clear is_non_public here.  If A is a private base of B, A\n-\t is not allowed to convert a B* to an A*.  */\n-      within_current_scope = 1;\n-    }\n-  \n   if (same_type_p (BINFO_TYPE (binfo), base))\n     {\n       /* We have found a base. Check against what we have found\n@@ -214,29 +198,11 @@ lookup_base_r (tree binfo, tree base, base_access access,\n       tree base_binfo = TREE_VEC_ELT (bases, i);\n       tree base_access = TREE_VEC_ELT (accesses, i);\n       \n-      int this_non_public = is_non_public;\n-      int this_virtual = is_virtual;\n       base_kind bk;\n \n-      if (access <= ba_ignore)\n-\t; /* no change */\n-      else if (base_access == access_public_node)\n-\t; /* no change */\n-      else if (access == ba_not_special)\n-\tthis_non_public = 1;\n-      else if (base_access == access_protected_node && within_current_scope)\n-\t; /* no change */\n-      else if (is_friend (BINFO_TYPE (binfo), current_scope ()))\n-\t; /* no change */\n-      else\n-\tthis_non_public = 1;\n-      \n-      if (TREE_VIA_VIRTUAL (base_binfo))\n-\tthis_virtual = 1;\n-      \n       bk = lookup_base_r (base_binfo, base,\n-\t\t    \t  access, within_current_scope,\n-\t\t\t  this_non_public, this_virtual,\n+\t\t    \t  access,\n+\t\t\t  is_virtual || TREE_VIA_VIRTUAL (base_binfo),\n \t\t\t  binfo_ptr);\n \n       switch (bk)\n@@ -247,14 +213,6 @@ lookup_base_r (tree binfo, tree base, base_access access,\n \t  found = bk;\n \t  break;\n \t  \n-\tcase bk_inaccessible:\n-\t  if (found == bk_not_base)\n-\t    found = bk;\n-\t  my_friendly_assert (found == bk_via_virtual\n-\t\t\t      || found == bk_inaccessible, 20010723);\n-\t  \n-\t  break;\n-\t  \n \tcase bk_same_type:\n \t  bk = bk_proper_base;\n \t  /* FALLTHROUGH */\n@@ -270,6 +228,9 @@ lookup_base_r (tree binfo, tree base, base_access access,\n \t  \n \tcase bk_not_base:\n \t  break;\n+\n+\tdefault:\n+\t  abort ();\n \t}\n     }\n   return found;\n@@ -312,8 +273,7 @@ lookup_base (tree t, tree base, base_access access, base_kind *kind_ptr)\n   t = complete_type (TYPE_MAIN_VARIANT (t));\n   base = complete_type (TYPE_MAIN_VARIANT (base));\n   \n-  bk = lookup_base_r (t_binfo, base, access & ~ba_quiet,\n-\t\t      0, 0, 0, &binfo);\n+  bk = lookup_base_r (t_binfo, base, access, 0, &binfo);\n \n   /* Check that the base is unambiguous and accessible.  */\n   if (access != ba_any)\n@@ -1530,10 +1490,11 @@ adjust_result_of_qualified_name_lookup (tree decl,\n \n       my_friendly_assert (CLASS_TYPE_P (context_class), 20020808);\n \n-      /* Look for the QUALIFYING_SCOPE as a base of the\n-\t CONTEXT_CLASS.  If QUALIFYING_SCOPE is ambiguous, we cannot\n-\t be sure yet than an error has occurred; perhaps the function\n-\t chosen by overload resolution will be static.  */\n+      /* Look for the QUALIFYING_SCOPE as a base of the CONTEXT_CLASS.\n+\t Because we do not yet know which function will be chosen by\n+\t overload resolution, we cannot yet check either accessibility\n+\t or ambiguity -- in either case, the choice of a static member\n+\t function might make the usage valid.  */\n       base = lookup_base (context_class, qualifying_scope,\n \t\t\t  ba_ignore | ba_quiet, NULL);\n       if (base)"}, {"sha": "7daffa69aeb0dc86f3c40dd38ac5fa66f05cc86a", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/127b81366e7ee0700cec2733126fc35e85a59122/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/127b81366e7ee0700cec2733126fc35e85a59122/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=127b81366e7ee0700cec2733126fc35e85a59122", "patch": "@@ -1425,7 +1425,8 @@ finish_call_expr (tree fn, tree args, bool disallow_virtual)\n \t  && DERIVED_FROM_P (BINFO_TYPE (BASELINK_ACCESS_BINFO (fn)),\n \t\t\t     current_class_type)\n \t  && current_class_ref)\n-\tobject = current_class_ref;\n+\tobject = maybe_dummy_object (BINFO_TYPE (BASELINK_ACCESS_BINFO (fn)),\n+\t\t\t\t     NULL);\n       else\n \t{\n \t  tree representative_fn;"}]}