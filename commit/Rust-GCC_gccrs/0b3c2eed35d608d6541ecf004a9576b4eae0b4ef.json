{"sha": "0b3c2eed35d608d6541ecf004a9576b4eae0b4ef", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGIzYzJlZWQzNWQ2MDhkNjU0MWVjZjAwNGE5NTc2YjRlYWUwYjRlZg==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "iant@golang.org", "date": "2020-02-05T22:33:27Z"}, "committer": {"name": "Ian Lance Taylor", "email": "iant@golang.org", "date": "2020-02-15T17:14:10Z"}, "message": "libgo: update to Go1.14rc1 release\n\nReviewed-on: https://go-review.googlesource.com/c/gofrontend/+/218017", "tree": {"sha": "c92c05d53eb054d8085d069800f4e9b586fef5a3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c92c05d53eb054d8085d069800f4e9b586fef5a3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/comments", "author": {"login": "ianlancetaylor", "id": 3194333, "node_id": "MDQ6VXNlcjMxOTQzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/3194333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ianlancetaylor", "html_url": "https://github.com/ianlancetaylor", "followers_url": "https://api.github.com/users/ianlancetaylor/followers", "following_url": "https://api.github.com/users/ianlancetaylor/following{/other_user}", "gists_url": "https://api.github.com/users/ianlancetaylor/gists{/gist_id}", "starred_url": "https://api.github.com/users/ianlancetaylor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ianlancetaylor/subscriptions", "organizations_url": "https://api.github.com/users/ianlancetaylor/orgs", "repos_url": "https://api.github.com/users/ianlancetaylor/repos", "events_url": "https://api.github.com/users/ianlancetaylor/events{/privacy}", "received_events_url": "https://api.github.com/users/ianlancetaylor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ianlancetaylor", "id": 3194333, "node_id": "MDQ6VXNlcjMxOTQzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/3194333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ianlancetaylor", "html_url": "https://github.com/ianlancetaylor", "followers_url": "https://api.github.com/users/ianlancetaylor/followers", "following_url": "https://api.github.com/users/ianlancetaylor/following{/other_user}", "gists_url": "https://api.github.com/users/ianlancetaylor/gists{/gist_id}", "starred_url": "https://api.github.com/users/ianlancetaylor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ianlancetaylor/subscriptions", "organizations_url": "https://api.github.com/users/ianlancetaylor/orgs", "repos_url": "https://api.github.com/users/ianlancetaylor/repos", "events_url": "https://api.github.com/users/ianlancetaylor/events{/privacy}", "received_events_url": "https://api.github.com/users/ianlancetaylor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41", "html_url": "https://github.com/Rust-GCC/gccrs/commit/17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41"}], "stats": {"total": 3365, "additions": 1523, "deletions": 1842}, "files": [{"sha": "e67d792a44c945c7c571ee8ab9ceec7d37079155", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=0b3c2eed35d608d6541ecf004a9576b4eae0b4ef", "patch": "@@ -1,4 +1,4 @@\n-3e46519cee5c916a9b39480fbac13f4ffc6a93b0\n+f368afbbd466941dcc6717412d7182e122b40c93\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "2d01b8759bfc55148b3208ca0e2b4f9ffd1beed5", "filename": "libgo/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMERGE?ref=0b3c2eed35d608d6541ecf004a9576b4eae0b4ef", "patch": "@@ -1,4 +1,4 @@\n-a5bfd9da1d1b24f326399b6b75558ded14514f23\n+a068054af141c01df5a4519844f4b77273605f4e\n \n The first line of this file holds the git revision number of the\n last merge done from the master library sources."}, {"sha": "5304c505acda36a0e0aaaf96f35780e5f795c088", "filename": "libgo/VERSION", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2FVERSION", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2FVERSION", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FVERSION?ref=0b3c2eed35d608d6541ecf004a9576b4eae0b4ef", "patch": "@@ -1 +1 @@\n-go1.14beta1\n+go1.14rc1"}, {"sha": "971a756b37d65ae3ddda711cff958ffbcf30edf5", "filename": "libgo/go/cmd/go/alldocs.go", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fcmd%2Fgo%2Falldocs.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fcmd%2Fgo%2Falldocs.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Falldocs.go?ref=0b3c2eed35d608d6541ecf004a9576b4eae0b4ef", "patch": "@@ -907,7 +907,7 @@\n //         Main      bool         // is this the main module?\n //         Indirect  bool         // is this module only an indirect dependency of main module?\n //         Dir       string       // directory holding files for this module, if any\n-//         GoMod     string       // path to go.mod file for this module, if any\n+//         GoMod     string       // path to go.mod file used when loading this module, if any\n //         GoVersion string       // go version used in module\n //         Error     *ModuleError // error loading module\n //     }\n@@ -916,6 +916,9 @@\n //         Err string // the error itself\n //     }\n //\n+// The file GoMod refers to may be outside the module directory if the\n+// module is in the module cache or if the -modfile flag is used.\n+//\n // The default output is to print the module path and then\n // information about the version and replacement if any.\n // For example, 'go list -m all' might print:\n@@ -1020,7 +1023,9 @@\n // execution. The \"go mod download\" command is useful mainly for pre-filling\n // the local cache or to compute the answers for a Go module proxy.\n //\n-// By default, download reports errors to standard error but is otherwise silent.\n+// By default, download writes nothing to standard output. It may print progress\n+// messages and errors to standard error.\n+//\n // The -json flag causes download to print a sequence of JSON objects\n // to standard output, describing each downloaded module (or failure),\n // corresponding to this Go struct:\n@@ -2346,14 +2351,15 @@\n //\n // Module support\n //\n-// Go 1.13 includes support for Go modules. Module-aware mode is active by default\n-// whenever a go.mod file is found in, or in a parent of, the current directory.\n+// The go command includes support for Go modules. Module-aware mode is active\n+// by default whenever a go.mod file is found in the current directory or in\n+// any parent directory.\n //\n // The quickest way to take advantage of module support is to check out your\n // repository, create a go.mod file (described in the next section) there, and run\n // go commands from within that file tree.\n //\n-// For more fine-grained control, Go 1.13 continues to respect\n+// For more fine-grained control, the go command continues to respect\n // a temporary environment variable, GO111MODULE, which can be set to one\n // of three string values: off, on, or auto (the default).\n // If GO111MODULE=on, then the go command requires the use of modules,"}, {"sha": "d535ea0ad34c6eaaa67ddc9ce7ad928dc15381b1", "filename": "libgo/go/cmd/go/go_test.go", "status": "modified", "additions": 10, "deletions": 402, "changes": 412, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fcmd%2Fgo%2Fgo_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fcmd%2Fgo%2Fgo_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fgo_test.go?ref=0b3c2eed35d608d6541ecf004a9576b4eae0b4ef", "patch": "@@ -638,7 +638,7 @@ func (tg *testgoData) grepStderrNot(match, msg string) {\n }\n \n // grepBothNot looks for a regular expression in the test run's\n-// standard output or stand error and fails, logging msg, if it is\n+// standard output or standard error and fails, logging msg, if it is\n // found.\n func (tg *testgoData) grepBothNot(match, msg string) {\n \ttg.t.Helper()\n@@ -913,6 +913,7 @@ func TestNewReleaseRebuildsStalePackagesInGOPATH(t *testing.T) {\n \n \ttg := testgo(t)\n \tdefer tg.cleanup()\n+\ttg.parallel()\n \n \t// Copy the runtime packages into a temporary GOROOT\n \t// so that we can change files.\n@@ -1026,28 +1027,6 @@ func TestInternalPackagesOutsideGOROOTAreRespected(t *testing.T) {\n \ttg.grepBoth(`testinternal2(\\/|\\\\)p\\.go\\:3\\:8\\: use of internal package .*internal/w not allowed`, \"wrote error message for testdata/testinternal2\")\n }\n \n-func TestRunInternal(t *testing.T) {\n-\ttg := testgo(t)\n-\tdefer tg.cleanup()\n-\tdir := filepath.Join(tg.pwd(), \"testdata\")\n-\ttg.setenv(\"GOPATH\", dir)\n-\ttg.run(\"run\", filepath.Join(dir, \"src/run/good.go\"))\n-\ttg.runFail(\"run\", filepath.Join(dir, \"src/run/bad.go\"))\n-\ttg.grepStderr(`testdata(\\/|\\\\)src(\\/|\\\\)run(\\/|\\\\)bad\\.go\\:3\\:8\\: use of internal package run/subdir/internal/private not allowed`, \"unexpected error for run/bad.go\")\n-}\n-\n-func TestRunPkg(t *testing.T) {\n-\ttg := testgo(t)\n-\tdefer tg.cleanup()\n-\tdir := filepath.Join(tg.pwd(), \"testdata\")\n-\ttg.setenv(\"GOPATH\", dir)\n-\ttg.run(\"run\", \"hello\")\n-\ttg.grepStderr(\"hello, world\", \"did not find hello, world\")\n-\ttg.cd(filepath.Join(dir, \"src/hello\"))\n-\ttg.run(\"run\", \".\")\n-\ttg.grepStderr(\"hello, world\", \"did not find hello, world\")\n-}\n-\n func TestInternalPackageErrorsAreHandled(t *testing.T) {\n \ttg := testgo(t)\n \tdefer tg.cleanup()\n@@ -1062,56 +1041,6 @@ func TestInternalCache(t *testing.T) {\n \ttg.grepStderr(\"internal\", \"did not fail to build p\")\n }\n \n-func TestImportCommandMatch(t *testing.T) {\n-\ttg := testgo(t)\n-\tdefer tg.cleanup()\n-\ttg.setenv(\"GOPATH\", filepath.Join(tg.pwd(), \"testdata/importcom\"))\n-\ttg.run(\"build\", \"./testdata/importcom/works.go\")\n-}\n-\n-func TestImportCommentMismatch(t *testing.T) {\n-\ttg := testgo(t)\n-\tdefer tg.cleanup()\n-\ttg.setenv(\"GOPATH\", filepath.Join(tg.pwd(), \"testdata/importcom\"))\n-\ttg.runFail(\"build\", \"./testdata/importcom/wrongplace.go\")\n-\ttg.grepStderr(`wrongplace expects import \"my/x\"`, \"go build did not mention incorrect import\")\n-}\n-\n-func TestImportCommentSyntaxError(t *testing.T) {\n-\ttg := testgo(t)\n-\tdefer tg.cleanup()\n-\ttg.setenv(\"GOPATH\", filepath.Join(tg.pwd(), \"testdata/importcom\"))\n-\ttg.runFail(\"build\", \"./testdata/importcom/bad.go\")\n-\ttg.grepStderr(\"cannot parse import comment\", \"go build did not mention syntax error\")\n-}\n-\n-func TestImportCommentConflict(t *testing.T) {\n-\ttg := testgo(t)\n-\tdefer tg.cleanup()\n-\ttg.setenv(\"GOPATH\", filepath.Join(tg.pwd(), \"testdata/importcom\"))\n-\ttg.runFail(\"build\", \"./testdata/importcom/conflict.go\")\n-\ttg.grepStderr(\"found import comments\", \"go build did not mention comment conflict\")\n-}\n-\n-func TestImportCycle(t *testing.T) {\n-\ttg := testgo(t)\n-\tdefer tg.cleanup()\n-\ttg.parallel()\n-\ttg.setenv(\"GOPATH\", filepath.Join(tg.pwd(), \"testdata/importcycle\"))\n-\ttg.runFail(\"build\", \"selfimport\")\n-\n-\tcount := tg.grepCountBoth(\"import cycle not allowed\")\n-\tif count == 0 {\n-\t\tt.Fatal(\"go build did not mention cyclical import\")\n-\t}\n-\tif count > 1 {\n-\t\tt.Fatal(\"go build mentioned import cycle more than once\")\n-\t}\n-\n-\t// Don't hang forever.\n-\ttg.run(\"list\", \"-e\", \"-json\", \"selfimport\")\n-}\n-\n // cmd/go: custom import path checking should not apply to Go packages without import comment.\n func TestIssue10952(t *testing.T) {\n \ttestenv.MustHaveExternalNetwork(t)\n@@ -1217,24 +1146,6 @@ func TestAccidentalGitCheckout(t *testing.T) {\n \t}\n }\n \n-func TestErrorMessageForSyntaxErrorInTestGoFileSaysFAIL(t *testing.T) {\n-\ttg := testgo(t)\n-\tdefer tg.cleanup()\n-\ttg.setenv(\"GOPATH\", filepath.Join(tg.pwd(), \"testdata\"))\n-\ttg.runFail(\"test\", \"syntaxerror\")\n-\ttg.grepStderr(\"x_test.go:\", \"did not diagnose error\")\n-\ttg.grepStdout(\"FAIL\", \"go test did not say FAIL\")\n-}\n-\n-func TestWildcardsDoNotLookInUselessDirectories(t *testing.T) {\n-\ttg := testgo(t)\n-\tdefer tg.cleanup()\n-\ttg.setenv(\"GOPATH\", filepath.Join(tg.pwd(), \"testdata\"))\n-\ttg.runFail(\"list\", \"...\")\n-\ttg.grepBoth(\"badpkg\", \"go list ... failure does not mention badpkg\")\n-\ttg.run(\"list\", \"m...\")\n-}\n-\n func TestRelativeImportsGoTest(t *testing.T) {\n \ttg := testgo(t)\n \tdefer tg.cleanup()\n@@ -1673,6 +1584,7 @@ func TestDefaultGOPATHGet(t *testing.T) {\n \n \ttg := testgo(t)\n \tdefer tg.cleanup()\n+\ttg.parallel()\n \ttg.setenv(\"GOPATH\", \"\")\n \ttg.tempDir(\"home\")\n \ttg.setenv(homeEnvName(), tg.path(\"home\"))\n@@ -1697,6 +1609,7 @@ func TestDefaultGOPATHGet(t *testing.T) {\n func TestDefaultGOPATHPrintedSearchList(t *testing.T) {\n \ttg := testgo(t)\n \tdefer tg.cleanup()\n+\ttg.parallel()\n \ttg.setenv(\"GOPATH\", \"\")\n \ttg.tempDir(\"home\")\n \ttg.setenv(homeEnvName(), tg.path(\"home\"))\n@@ -1819,16 +1732,6 @@ func TestGoTestMutexprofileDashOControlsBinaryLocation(t *testing.T) {\n \ttg.wantExecutable(\"myerrors.test\"+exeSuffix, \"go test -mutexprofile -o myerrors.test did not create myerrors.test\")\n }\n \n-func TestGoBuildNonMain(t *testing.T) {\n-\ttg := testgo(t)\n-\tdefer tg.cleanup()\n-\t// TODO: tg.parallel()\n-\ttg.setenv(\"GOPATH\", filepath.Join(tg.pwd(), \"testdata\"))\n-\ttg.runFail(\"build\", \"-buildmode=exe\", \"-o\", \"not_main\"+exeSuffix, \"not_main\")\n-\ttg.grepStderr(\"-buildmode=exe requires exactly one main package\", \"go build with -o and -buildmode=exe should on a non-main package should throw an error\")\n-\ttg.mustNotExist(\"not_main\" + exeSuffix)\n-}\n-\n func TestGoTestDashCDashOControlsBinaryLocation(t *testing.T) {\n \tskipIfGccgo(t, \"gccgo has no standard packages\")\n \ttooSlow(t)\n@@ -2192,33 +2095,6 @@ func TestCoverageNoStatements(t *testing.T) {\n \ttg.grepStdout(\"[no statements]\", \"expected [no statements] for pkg4\")\n }\n \n-func TestCoverageImportMainLoop(t *testing.T) {\n-\tskipIfGccgo(t, \"gccgo has no cover tool\")\n-\ttg := testgo(t)\n-\tdefer tg.cleanup()\n-\ttg.setenv(\"GOPATH\", filepath.Join(tg.pwd(), \"testdata\"))\n-\ttg.runFail(\"test\", \"importmain/test\")\n-\ttg.grepStderr(\"not an importable package\", \"did not detect import main\")\n-\ttg.runFail(\"test\", \"-cover\", \"importmain/test\")\n-\ttg.grepStderr(\"not an importable package\", \"did not detect import main\")\n-}\n-\n-func TestCoveragePattern(t *testing.T) {\n-\tskipIfGccgo(t, \"gccgo has no cover tool\")\n-\ttooSlow(t)\n-\ttg := testgo(t)\n-\tdefer tg.cleanup()\n-\ttg.parallel()\n-\ttg.makeTempdir()\n-\ttg.setenv(\"GOPATH\", filepath.Join(tg.pwd(), \"testdata\"))\n-\n-\t// If coverpkg=sleepy... expands by package loading\n-\t// (as opposed to pattern matching on deps)\n-\t// then it will try to load sleepybad, which does not compile,\n-\t// and the test command will fail.\n-\ttg.run(\"test\", \"-coverprofile=\"+tg.path(\"cover.out\"), \"-coverpkg=sleepy...\", \"-run=^$\", \"sleepy1\")\n-}\n-\n func TestCoverageErrorLine(t *testing.T) {\n \tskipIfGccgo(t, \"gccgo has no cover tool\")\n \ttooSlow(t)\n@@ -2291,20 +2167,6 @@ func TestCoverageDashC(t *testing.T) {\n \ttg.wantExecutable(tg.path(\"coverdep\"), \"go -test -c -coverprofile did not create executable\")\n }\n \n-func TestPluginNonMain(t *testing.T) {\n-\twd, err := os.Getwd()\n-\tif err != nil {\n-\t\tt.Fatal(err)\n-\t}\n-\n-\tpkg := filepath.Join(wd, \"testdata\", \"testdep\", \"p2\")\n-\n-\ttg := testgo(t)\n-\tdefer tg.cleanup()\n-\n-\ttg.runFail(\"build\", \"-buildmode=plugin\", pkg)\n-}\n-\n func TestTestEmpty(t *testing.T) {\n \tif !canRace {\n \t\tt.Skip(\"no race detector\")\n@@ -2389,39 +2251,6 @@ func main() {\n \ttg.grepStderrNot(`os.Stat .* no such file or directory`, \"unexpected stat of archive file\")\n }\n \n-func TestCoverageWithCgo(t *testing.T) {\n-\tskipIfGccgo(t, \"gccgo has no cover tool\")\n-\ttooSlow(t)\n-\tif !canCgo {\n-\t\tt.Skip(\"skipping because cgo not enabled\")\n-\t}\n-\n-\tfor _, dir := range []string{\"cgocover\", \"cgocover2\", \"cgocover3\", \"cgocover4\"} {\n-\t\tt.Run(dir, func(t *testing.T) {\n-\t\t\ttg := testgo(t)\n-\t\t\ttg.parallel()\n-\t\t\tdefer tg.cleanup()\n-\t\t\ttg.setenv(\"GOPATH\", filepath.Join(tg.pwd(), \"testdata\"))\n-\t\t\ttg.run(\"test\", \"-short\", \"-cover\", dir)\n-\t\t\tdata := tg.getStdout() + tg.getStderr()\n-\t\t\tcheckCoverage(tg, data)\n-\t\t})\n-\t}\n-}\n-\n-func TestCgoAsmError(t *testing.T) {\n-\tif !canCgo {\n-\t\tt.Skip(\"skipping because cgo not enabled\")\n-\t}\n-\n-\ttg := testgo(t)\n-\ttg.parallel()\n-\tdefer tg.cleanup()\n-\ttg.setenv(\"GOPATH\", filepath.Join(tg.pwd(), \"testdata\"))\n-\ttg.runFail(\"build\", \"cgoasm\")\n-\ttg.grepBoth(\"package using cgo has Go assembly file\", \"did not detect Go assembly file\")\n-}\n-\n func TestCgoDependsOnSyscall(t *testing.T) {\n \tif testing.Short() {\n \t\tt.Skip(\"skipping test that removes $GOROOT/pkg/*_race in short mode\")\n@@ -2435,6 +2264,8 @@ func TestCgoDependsOnSyscall(t *testing.T) {\n \n \ttg := testgo(t)\n \tdefer tg.cleanup()\n+\ttg.parallel()\n+\n \tfiles, err := filepath.Glob(filepath.Join(runtime.GOROOT(), \"pkg\", \"*_race\"))\n \ttg.must(err)\n \tfor _, file := range files {\n@@ -2648,14 +2479,6 @@ func TestListTemplateContextFunction(t *testing.T) {\n \t}\n }\n \n-// cmd/go: \"go test\" should fail if package does not build\n-func TestIssue7108(t *testing.T) {\n-\ttg := testgo(t)\n-\tdefer tg.cleanup()\n-\ttg.setenv(\"GOPATH\", filepath.Join(tg.pwd(), \"testdata\"))\n-\ttg.runFail(\"test\", \"notest\")\n-}\n-\n func TestGoBuildTestOnly(t *testing.T) {\n \ttg := testgo(t)\n \tdefer tg.cleanup()\n@@ -2677,17 +2500,6 @@ func TestGoBuildTestOnly(t *testing.T) {\n \ttg.run(\"install\", \"./testonly...\")\n }\n \n-func TestGoTestDetectsTestOnlyImportCycles(t *testing.T) {\n-\ttg := testgo(t)\n-\tdefer tg.cleanup()\n-\ttg.setenv(\"GOPATH\", filepath.Join(tg.pwd(), \"testdata\"))\n-\ttg.runFail(\"test\", \"-c\", \"testcycle/p3\")\n-\ttg.grepStderr(\"import cycle not allowed in test\", \"go test testcycle/p3 produced unexpected error\")\n-\n-\ttg.runFail(\"test\", \"-c\", \"testcycle/q1\")\n-\ttg.grepStderr(\"import cycle not allowed in test\", \"go test testcycle/q1 produced unexpected error\")\n-}\n-\n func TestGoTestFooTestWorks(t *testing.T) {\n \ttg := testgo(t)\n \tdefer tg.cleanup()\n@@ -2715,29 +2527,6 @@ func TestGoTestMainAsNormalTest(t *testing.T) {\n \ttg.grepBoth(okPattern, \"go test did not say ok\")\n }\n \n-func TestGoTestMainTwice(t *testing.T) {\n-\tif testing.Short() {\n-\t\tt.Skip(\"Skipping in short mode\")\n-\t}\n-\ttg := testgo(t)\n-\tdefer tg.cleanup()\n-\ttg.makeTempdir()\n-\ttg.setenv(\"GOCACHE\", tg.tempdir)\n-\ttg.setenv(\"GOPATH\", filepath.Join(tg.pwd(), \"testdata\"))\n-\ttg.run(\"test\", \"-v\", \"multimain\")\n-\tif strings.Count(tg.getStdout(), \"notwithstanding\") != 2 {\n-\t\tt.Fatal(\"tests did not run twice\")\n-\t}\n-}\n-\n-func TestGoTestFlagsAfterPackage(t *testing.T) {\n-\ttooSlow(t)\n-\ttg := testgo(t)\n-\tdefer tg.cleanup()\n-\ttg.run(\"test\", \"testdata/flag_test.go\", \"-v\", \"-args\", \"-v=7\") // Two distinct -v flags.\n-\ttg.run(\"test\", \"-v\", \"testdata/flag_test.go\", \"-args\", \"-v=7\") // Two distinct -v flags.\n-}\n-\n func TestGoTestXtestonlyWorks(t *testing.T) {\n \ttg := testgo(t)\n \tdefer tg.cleanup()\n@@ -2829,20 +2618,6 @@ func TestGoGenerateXTestPkgName(t *testing.T) {\n \t}\n }\n \n-func TestGoGenerateBadImports(t *testing.T) {\n-\tif runtime.GOOS == \"windows\" {\n-\t\tt.Skip(\"skipping because windows has no echo command\")\n-\t}\n-\n-\t// This package has an invalid import causing an import cycle,\n-\t// but go generate is supposed to still run.\n-\ttg := testgo(t)\n-\tdefer tg.cleanup()\n-\ttg.setenv(\"GOPATH\", filepath.Join(tg.pwd(), \"testdata\"))\n-\ttg.run(\"generate\", \"gencycle\")\n-\ttg.grepStdout(\"hello world\", \"go generate gencycle did not run generator\")\n-}\n-\n func TestGoGetCustomDomainWildcard(t *testing.T) {\n \ttestenv.MustHaveExternalNetwork(t)\n \ttestenv.MustHaveExecPath(t, \"git\")\n@@ -3268,43 +3043,6 @@ func TestGoTestRaceInstallCgo(t *testing.T) {\n \t}\n }\n \n-func TestGoTestRaceFailures(t *testing.T) {\n-\ttooSlow(t)\n-\n-\tif !canRace {\n-\t\tt.Skip(\"skipping because race detector not supported\")\n-\t}\n-\n-\ttg := testgo(t)\n-\ttg.parallel()\n-\tdefer tg.cleanup()\n-\ttg.setenv(\"GOPATH\", filepath.Join(tg.pwd(), \"testdata\"))\n-\n-\ttg.run(\"test\", \"testrace\")\n-\n-\ttg.runFail(\"test\", \"-race\", \"testrace\")\n-\ttg.grepStdout(\"FAIL: TestRace\", \"TestRace did not fail\")\n-\ttg.grepBothNot(\"PASS\", \"something passed\")\n-\n-\ttg.runFail(\"test\", \"-race\", \"testrace\", \"-run\", \"XXX\", \"-bench\", \".\")\n-\ttg.grepStdout(\"FAIL: BenchmarkRace\", \"BenchmarkRace did not fail\")\n-\ttg.grepBothNot(\"PASS\", \"something passed\")\n-}\n-\n-func TestGoTestImportErrorStack(t *testing.T) {\n-\tconst out = `package testdep/p1 (test)\n-\timports testdep/p2\n-\timports testdep/p3: build constraints exclude all Go files `\n-\n-\ttg := testgo(t)\n-\tdefer tg.cleanup()\n-\ttg.setenv(\"GOPATH\", filepath.Join(tg.pwd(), \"testdata\"))\n-\ttg.runFail(\"test\", \"testdep/p1\")\n-\tif !strings.Contains(tg.stderr.String(), out) {\n-\t\tt.Fatalf(\"did not give full import stack:\\n\\n%s\", tg.stderr.String())\n-\t}\n-}\n-\n func TestGoGetUpdate(t *testing.T) {\n \t// golang.org/issue/9224.\n \t// The recursive updating was trying to walk to\n@@ -3627,27 +3365,6 @@ func TestGoGetUpdateAllDoesNotTryToLoadDuplicates(t *testing.T) {\n \ttg.grepStderrNot(\"duplicate loads of\", \"did not remove old packages from cache\")\n }\n \n-// Issue 17119 more duplicate load errors\n-func TestIssue17119(t *testing.T) {\n-\ttestenv.MustHaveExternalNetwork(t)\n-\n-\ttg := testgo(t)\n-\tdefer tg.cleanup()\n-\ttg.parallel()\n-\ttg.setenv(\"GOPATH\", filepath.Join(tg.pwd(), \"testdata\"))\n-\ttg.runFail(\"build\", \"dupload\")\n-\ttg.grepBothNot(\"duplicate load|internal error\", \"internal error\")\n-}\n-\n-func TestFatalInBenchmarkCauseNonZeroExitStatus(t *testing.T) {\n-\ttg := testgo(t)\n-\tdefer tg.cleanup()\n-\t// TODO: tg.parallel()\n-\ttg.runFail(\"test\", \"-run\", \"^$\", \"-bench\", \".\", \"./testdata/src/benchfatal\")\n-\ttg.grepBothNot(\"^ok\", \"test passed unexpectedly\")\n-\ttg.grepBoth(\"FAIL.*benchfatal\", \"test did not run everything\")\n-}\n-\n func TestBinaryOnlyPackages(t *testing.T) {\n \ttooSlow(t)\n \n@@ -3813,16 +3530,6 @@ func TestMatchesNoTests(t *testing.T) {\n \ttg.grepBoth(noMatchesPattern, \"go test did not say [no tests to run]\")\n }\n \n-func TestMatchesNoTestsDoesNotOverrideBuildFailure(t *testing.T) {\n-\ttg := testgo(t)\n-\tdefer tg.cleanup()\n-\ttg.parallel()\n-\ttg.setenv(\"GOPATH\", filepath.Join(tg.pwd(), \"testdata\"))\n-\ttg.runFail(\"test\", \"-run\", \"ThisWillNotMatch\", \"syntaxerror\")\n-\ttg.grepBothNot(noMatchesPattern, \"go test did say [no tests to run]\")\n-\ttg.grepBoth(\"FAIL\", \"go test did not say FAIL\")\n-}\n-\n func TestMatchesNoBenchmarksIsOK(t *testing.T) {\n \ttg := testgo(t)\n \tdefer tg.cleanup()\n@@ -3850,18 +3557,6 @@ func TestMatchesOnlyBenchmarkIsOK(t *testing.T) {\n \ttg.grepBoth(okPattern, \"go test did not say ok\")\n }\n \n-func TestBenchmarkLabels(t *testing.T) {\n-\ttg := testgo(t)\n-\tdefer tg.cleanup()\n-\t// TODO: tg.parallel()\n-\ttg.setenv(\"GOPATH\", filepath.Join(tg.pwd(), \"testdata\"))\n-\ttg.run(\"test\", \"-run\", \"^$\", \"-bench\", \".\", \"bench\")\n-\ttg.grepStdout(`(?m)^goos: `+runtime.GOOS, \"go test did not print goos\")\n-\ttg.grepStdout(`(?m)^goarch: `+runtime.GOARCH, \"go test did not print goarch\")\n-\ttg.grepStdout(`(?m)^pkg: bench`, \"go test did not say pkg: bench\")\n-\ttg.grepBothNot(`(?s)pkg:.*pkg:`, \"go test said pkg multiple times\")\n-}\n-\n func TestBenchmarkLabelsOutsideGOPATH(t *testing.T) {\n \ttg := testgo(t)\n \tdefer tg.cleanup()\n@@ -4261,25 +3956,6 @@ func TestCgoFlagContainsSpace(t *testing.T) {\n \ttg.grepStderrNot(`\"-L[^\"]+c flags\".*\"-L[^\"]+c flags\"`, \"found too many quoted ld flags\")\n }\n \n-// Issue #20435.\n-func TestGoTestRaceCoverModeFailures(t *testing.T) {\n-\ttooSlow(t)\n-\tif !canRace {\n-\t\tt.Skip(\"skipping because race detector not supported\")\n-\t}\n-\n-\ttg := testgo(t)\n-\ttg.parallel()\n-\tdefer tg.cleanup()\n-\ttg.setenv(\"GOPATH\", filepath.Join(tg.pwd(), \"testdata\"))\n-\n-\ttg.run(\"test\", \"testrace\")\n-\n-\ttg.runFail(\"test\", \"-race\", \"-covermode=set\", \"testrace\")\n-\ttg.grepStderr(`-covermode must be \"atomic\", not \"set\", when -race is enabled`, \"-race -covermode=set was allowed\")\n-\ttg.grepBothNot(\"PASS\", \"something passed\")\n-}\n-\n // Issue 9737: verify that GOARM and GO386 affect the computed build ID.\n func TestBuildIDContainsArchModeEnv(t *testing.T) {\n \tif testing.Short() {\n@@ -4319,60 +3995,6 @@ func main() {}`)\n \t}))\n }\n \n-func TestTestRegexps(t *testing.T) {\n-\ttg := testgo(t)\n-\tdefer tg.cleanup()\n-\ttg.setenv(\"GOPATH\", filepath.Join(tg.pwd(), \"testdata\"))\n-\ttg.run(\"test\", \"-cpu=1\", \"-run=X/Y\", \"-bench=X/Y\", \"-count=2\", \"-v\", \"testregexp\")\n-\tvar lines []string\n-\tfor _, line := range strings.SplitAfter(tg.getStdout(), \"\\n\") {\n-\t\tif strings.Contains(line, \"=== RUN\") || strings.Contains(line, \"--- BENCH\") || strings.Contains(line, \"LOG\") {\n-\t\t\tlines = append(lines, line)\n-\t\t}\n-\t}\n-\n-\t// Important parts:\n-\t//\tTestX is run, twice\n-\t//\tTestX/Y is run, twice\n-\t//\tTestXX is run, twice\n-\t//\tTestZ is not run\n-\t//\tBenchmarkX is run but only with N=1, once\n-\t//\tBenchmarkXX is run but only with N=1, once\n-\t//\tBenchmarkX/Y is run in full, twice\n-\twant := `=== RUN   TestX\n-    TestX: x_test.go:6: LOG: X running\n-=== RUN   TestX/Y\n-    TestX/Y: x_test.go:8: LOG: Y running\n-=== RUN   TestXX\n-    TestXX: z_test.go:10: LOG: XX running\n-=== RUN   TestX\n-    TestX: x_test.go:6: LOG: X running\n-=== RUN   TestX/Y\n-    TestX/Y: x_test.go:8: LOG: Y running\n-=== RUN   TestXX\n-    TestXX: z_test.go:10: LOG: XX running\n-    BenchmarkX: x_test.go:13: LOG: X running N=1\n-    BenchmarkX/Y: x_test.go:15: LOG: Y running N=1\n-    BenchmarkX/Y: x_test.go:15: LOG: Y running N=100\n-    BenchmarkX/Y: x_test.go:15: LOG: Y running N=10000\n-    BenchmarkX/Y: x_test.go:15: LOG: Y running N=1000000\n-    BenchmarkX/Y: x_test.go:15: LOG: Y running N=100000000\n-    BenchmarkX/Y: x_test.go:15: LOG: Y running N=1000000000\n-    BenchmarkX/Y: x_test.go:15: LOG: Y running N=1\n-    BenchmarkX/Y: x_test.go:15: LOG: Y running N=100\n-    BenchmarkX/Y: x_test.go:15: LOG: Y running N=10000\n-    BenchmarkX/Y: x_test.go:15: LOG: Y running N=1000000\n-    BenchmarkX/Y: x_test.go:15: LOG: Y running N=100000000\n-    BenchmarkX/Y: x_test.go:15: LOG: Y running N=1000000000\n-    BenchmarkXX: z_test.go:18: LOG: XX running N=1\n-`\n-\n-\thave := strings.Join(lines, \"\")\n-\tif have != want {\n-\t\tt.Errorf(\"reduced output:<<<\\n%s>>> want:<<<\\n%s>>>\", have, want)\n-\t}\n-}\n-\n func TestListTests(t *testing.T) {\n \ttooSlow(t)\n \tvar tg *testgoData\n@@ -4408,6 +4030,7 @@ func TestBuildmodePIE(t *testing.T) {\n \n \ttg := testgo(t)\n \tdefer tg.cleanup()\n+\ttg.parallel()\n \n \ttg.tempFile(\"main.go\", `package main; func main() { print(\"hello\") }`)\n \tsrc := tg.path(\"main.go\")\n@@ -4571,6 +4194,7 @@ func TestUpxCompression(t *testing.T) {\n \n \ttg := testgo(t)\n \tdefer tg.cleanup()\n+\ttg.parallel()\n \n \ttg.tempFile(\"main.go\", `package main; import \"fmt\"; func main() { fmt.Print(\"hello upx\") }`)\n \tsrc := tg.path(\"main.go\")\n@@ -4964,14 +4588,6 @@ func TestInstallDeps(t *testing.T) {\n \ttg.mustExist(p1)\n }\n \n-func TestGoTestMinusN(t *testing.T) {\n-\t// Intent here is to verify that 'go test -n' works without crashing.\n-\t// This reuses flag_test.go, but really any test would do.\n-\ttg := testgo(t)\n-\tdefer tg.cleanup()\n-\ttg.run(\"test\", \"testdata/flag_test.go\", \"-n\", \"-args\", \"-v=7\")\n-}\n-\n func TestGoTestJSON(t *testing.T) {\n \tskipIfGccgo(t, \"gccgo does not have standard packages\")\n \ttooSlow(t)\n@@ -5109,6 +4725,7 @@ func init() {}\n func TestBadCommandLines(t *testing.T) {\n \ttg := testgo(t)\n \tdefer tg.cleanup()\n+\ttg.parallel()\n \n \ttg.tempFile(\"src/x/x.go\", \"package x\\n\")\n \ttg.setenv(\"GOPATH\", tg.path(\".\"))\n@@ -5329,6 +4946,7 @@ func TestCgoCache(t *testing.T) {\n func TestFilepathUnderCwdFormat(t *testing.T) {\n \ttg := testgo(t)\n \tdefer tg.cleanup()\n+\ttg.parallel()\n \ttg.run(\"test\", \"-x\", \"-cover\", \"log\")\n \ttg.grepStderrNot(`\\.log\\.cover\\.go`, \"-x output should contain correctly formatted filepath under cwd\")\n }\n@@ -5433,16 +5051,6 @@ func TestCDAndGOPATHAreDifferent(t *testing.T) {\n \t}\n }\n \n-// Issue 26242.\n-func TestGoTestWithoutTests(t *testing.T) {\n-\ttg := testgo(t)\n-\tdefer tg.cleanup()\n-\ttg.parallel()\n-\ttg.setenv(\"GOPATH\", filepath.Join(tg.pwd(), \"testdata\"))\n-\ttg.run(\"test\", \"testnorun\")\n-\ttg.grepStdout(`testnorun\\t\\[no test files\\]`, \"do not want test to run\")\n-}\n-\n // Issue 25579.\n func TestGoBuildDashODevNull(t *testing.T) {\n \ttooSlow(t)"}, {"sha": "69e17482b44d80274894a173be4233988335290c", "filename": "libgo/go/cmd/go/internal/clean/clean.go", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fclean%2Fclean.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fclean%2Fclean.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fclean%2Fclean.go?ref=0b3c2eed35d608d6541ecf004a9576b4eae0b4ef", "patch": "@@ -178,7 +178,9 @@ func runClean(cmd *base.Command, args []string) {\n \t\t\t\t}\n \t\t\t}\n \t\t\tif err != nil {\n-\t\t\t\tbase.Errorf(\"go clean -testcache: %v\", err)\n+\t\t\t\tif _, statErr := os.Stat(dir); !os.IsNotExist(statErr) {\n+\t\t\t\t\tbase.Errorf(\"go clean -testcache: %v\", err)\n+\t\t\t\t}\n \t\t\t}\n \t\t}\n \t}"}, {"sha": "8d979e276f1cde3271e395bc87af33c3c1d7502d", "filename": "libgo/go/cmd/go/internal/list/list.go", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flist%2Flist.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flist%2Flist.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flist%2Flist.go?ref=0b3c2eed35d608d6541ecf004a9576b4eae0b4ef", "patch": "@@ -211,7 +211,7 @@ applied to a Go struct, but now a Module struct:\n         Main      bool         // is this the main module?\n         Indirect  bool         // is this module only an indirect dependency of main module?\n         Dir       string       // directory holding files for this module, if any\n-        GoMod     string       // path to go.mod file for this module, if any\n+        GoMod     string       // path to go.mod file used when loading this module, if any\n         GoVersion string       // go version used in module\n         Error     *ModuleError // error loading module\n     }\n@@ -220,6 +220,9 @@ applied to a Go struct, but now a Module struct:\n         Err string // the error itself\n     }\n \n+The file GoMod refers to may be outside the module directory if the\n+module is in the module cache or if the -modfile flag is used.\n+\n The default output is to print the module path and then\n information about the version and replacement if any.\n For example, 'go list -m all' might print:\n@@ -387,15 +390,24 @@ func runList(cmd *base.Command, args []string) {\n \n \t\tmodload.InitMod() // Parses go.mod and sets cfg.BuildMod.\n \t\tif cfg.BuildMod == \"vendor\" {\n+\t\t\tconst actionDisabledFormat = \"go list -m: can't %s using the vendor directory\\n\\t(Use -mod=mod or -mod=readonly to bypass.)\"\n+\n+\t\t\tif *listVersions {\n+\t\t\t\tbase.Fatalf(actionDisabledFormat, \"determine available versions\")\n+\t\t\t}\n+\t\t\tif *listU {\n+\t\t\t\tbase.Fatalf(actionDisabledFormat, \"determine available upgrades\")\n+\t\t\t}\n+\n \t\t\tfor _, arg := range args {\n \t\t\t\t// In vendor mode, the module graph is incomplete: it contains only the\n \t\t\t\t// explicit module dependencies and the modules that supply packages in\n \t\t\t\t// the import graph. Reject queries that imply more information than that.\n \t\t\t\tif arg == \"all\" {\n-\t\t\t\t\tbase.Fatalf(\"go list -m: can't compute 'all' using the vendor directory\\n\\t(Use -mod=mod or -mod=readonly to bypass.)\")\n+\t\t\t\t\tbase.Fatalf(actionDisabledFormat, \"compute 'all'\")\n \t\t\t\t}\n \t\t\t\tif strings.Contains(arg, \"...\") {\n-\t\t\t\t\tbase.Fatalf(\"go list -m: can't match module patterns using the vendor directory\\n\\t(Use -mod=mod or -mod=readonly to bypass.)\")\n+\t\t\t\t\tbase.Fatalf(actionDisabledFormat, \"match module patterns\")\n \t\t\t\t}\n \t\t\t}\n \t\t}"}, {"sha": "7d5294dcd00f69b36d0032bb58e7f3f86311b1ab", "filename": "libgo/go/cmd/go/internal/modcmd/download.go", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fdownload.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fdownload.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fdownload.go?ref=0b3c2eed35d608d6541ecf004a9576b4eae0b4ef", "patch": "@@ -30,7 +30,9 @@ The go command will automatically download modules as needed during ordinary\n execution. The \"go mod download\" command is useful mainly for pre-filling\n the local cache or to compute the answers for a Go module proxy.\n \n-By default, download reports errors to standard error but is otherwise silent.\n+By default, download writes nothing to standard output. It may print progress\n+messages and errors to standard error.\n+\n The -json flag causes download to print a sequence of JSON objects\n to standard output, describing each downloaded module (or failure),\n corresponding to this Go struct:"}, {"sha": "947192bd83ee387bc94f23a8323cd5fb874e4454", "filename": "libgo/go/cmd/go/internal/modfetch/cache.go", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcache.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcache.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcache.go?ref=0b3c2eed35d608d6541ecf004a9576b4eae0b4ef", "patch": "@@ -13,7 +13,6 @@ import (\n \t\"os\"\n \t\"path/filepath\"\n \t\"strings\"\n-\t\"time\"\n \n \t\"cmd/go/internal/base\"\n \t\"cmd/go/internal/cfg\"\n@@ -28,8 +27,6 @@ import (\n \n var PkgMod string // $GOPATH/pkg/mod; set by package modload\n \n-const logFindingDelay = 1 * time.Second\n-\n func cacheDir(path string) (string, error) {\n \tif PkgMod == \"\" {\n \t\treturn \"\", fmt.Errorf(\"internal error: modfetch.PkgMod not set\")\n@@ -140,11 +137,6 @@ func (r *cachingRepo) Versions(prefix string) ([]string, error) {\n \t\terr  error\n \t}\n \tc := r.cache.Do(\"versions:\"+prefix, func() interface{} {\n-\t\tlogTimer := time.AfterFunc(logFindingDelay, func() {\n-\t\t\tfmt.Fprintf(os.Stderr, \"go: finding versions for %s\\n\", r.path)\n-\t\t})\n-\t\tdefer logTimer.Stop()\n-\n \t\tlist, err := r.r.Versions(prefix)\n \t\treturn cached{list, err}\n \t}).(cached)\n@@ -167,11 +159,6 @@ func (r *cachingRepo) Stat(rev string) (*RevInfo, error) {\n \t\t\treturn cachedInfo{info, nil}\n \t\t}\n \n-\t\tlogTimer := time.AfterFunc(logFindingDelay, func() {\n-\t\t\tfmt.Fprintf(os.Stderr, \"go: finding %s %s\\n\", r.path, rev)\n-\t\t})\n-\t\tdefer logTimer.Stop()\n-\n \t\tinfo, err = r.r.Stat(rev)\n \t\tif err == nil {\n \t\t\t// If we resolved, say, 1234abcde to v0.0.0-20180604122334-1234abcdef78,\n@@ -199,11 +186,6 @@ func (r *cachingRepo) Stat(rev string) (*RevInfo, error) {\n \n func (r *cachingRepo) Latest() (*RevInfo, error) {\n \tc := r.cache.Do(\"latest:\", func() interface{} {\n-\t\tlogTimer := time.AfterFunc(logFindingDelay, func() {\n-\t\t\tfmt.Fprintf(os.Stderr, \"go: finding %s latest\\n\", r.path)\n-\t\t})\n-\t\tdefer logTimer.Stop()\n-\n \t\tinfo, err := r.r.Latest()\n \n \t\t// Save info for likely future Stat call."}, {"sha": "f08df512f02539bcadfce7b112c99bfef33e6f9f", "filename": "libgo/go/cmd/go/internal/modfetch/codehost/git.go", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcodehost%2Fgit.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcodehost%2Fgit.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcodehost%2Fgit.go?ref=0b3c2eed35d608d6541ecf004a9576b4eae0b4ef", "patch": "@@ -682,8 +682,11 @@ func (r *gitRepo) RecentTag(rev, prefix, major string) (tag string, err error) {\n \n \t\t\tsemtag := line[len(prefix):]\n \t\t\t// Consider only tags that are valid and complete (not just major.minor prefixes).\n-\t\t\tif c := semver.Canonical(semtag); c != \"\" && strings.HasPrefix(semtag, c) && (major == \"\" || semver.Major(c) == major) {\n-\t\t\t\thighest = semver.Max(highest, semtag)\n+\t\t\t// NOTE: Do not replace the call to semver.Compare with semver.Max.\n+\t\t\t// We want to return the actual tag, not a canonicalized version of it,\n+\t\t\t// and semver.Max currently canonicalizes (see golang.org/issue/32700).\n+\t\t\tif c := semver.Canonical(semtag); c != \"\" && strings.HasPrefix(semtag, c) && (major == \"\" || semver.Major(c) == major) && semver.Compare(semtag, highest) > 0 {\n+\t\t\t\thighest = semtag\n \t\t\t}\n \t\t}\n "}, {"sha": "d1d24a40c96cdd76a28306e904ef4c833fb35ff8", "filename": "libgo/go/cmd/go/internal/modfetch/coderepo.go", "status": "modified", "additions": 42, "deletions": 38, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcoderepo.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcoderepo.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcoderepo.go?ref=0b3c2eed35d608d6541ecf004a9576b4eae0b4ef", "patch": "@@ -191,22 +191,6 @@ func (r *codeRepo) appendIncompatibleVersions(list, incompatible []string) ([]st\n \t\treturn list, nil\n \t}\n \n-\t// We assume that if the latest release of any major version has a go.mod\n-\t// file, all subsequent major versions will also have go.mod files (and thus\n-\t// be ineligible for use as +incompatible versions).\n-\t// If we're wrong about a major version, users will still be able to 'go get'\n-\t// specific higher versions explicitly \u2014 they just won't affect 'latest' or\n-\t// appear in 'go list'.\n-\t//\n-\t// Conversely, we assume that if the latest release of any major version lacks\n-\t// a go.mod file, all versions also lack go.mod files. If we're wrong, we may\n-\t// include a +incompatible version that isn't really valid, but most\n-\t// operations won't try to use that version anyway.\n-\t//\n-\t// These optimizations bring\n-\t// 'go list -versions -m github.com/openshift/origin' down from 1m58s to 0m37s.\n-\t// That's still not great, but a substantial improvement.\n-\n \tversionHasGoMod := func(v string) (bool, error) {\n \t\t_, err := r.code.ReadFile(v, \"go.mod\", codehost.MaxGoMod)\n \t\tif err == nil {\n@@ -241,32 +225,41 @@ func (r *codeRepo) appendIncompatibleVersions(list, incompatible []string) ([]st\n \t\t}\n \t}\n \n-\tvar lastMajor string\n+\tvar (\n+\t\tlastMajor         string\n+\t\tlastMajorHasGoMod bool\n+\t)\n \tfor i, v := range incompatible {\n \t\tmajor := semver.Major(v)\n-\t\tif major == lastMajor {\n-\t\t\tlist = append(list, v+\"+incompatible\")\n-\t\t\tcontinue\n-\t\t}\n \n-\t\trem := incompatible[i:]\n-\t\tj := sort.Search(len(rem), func(j int) bool {\n-\t\t\treturn semver.Major(rem[j]) != major\n-\t\t})\n-\t\tlatestAtMajor := rem[j-1]\n-\n-\t\tok, err := versionHasGoMod(latestAtMajor)\n-\t\tif err != nil {\n-\t\t\treturn nil, err\n-\t\t}\n-\t\tif ok {\n-\t\t\t// This major version has a go.mod file, so it is not allowed as\n-\t\t\t// +incompatible. Subsequent major versions are likely to also have\n-\t\t\t// go.mod files, so stop here.\n-\t\t\tbreak\n+\t\tif major != lastMajor {\n+\t\t\trem := incompatible[i:]\n+\t\t\tj := sort.Search(len(rem), func(j int) bool {\n+\t\t\t\treturn semver.Major(rem[j]) != major\n+\t\t\t})\n+\t\t\tlatestAtMajor := rem[j-1]\n+\n+\t\t\tvar err error\n+\t\t\tlastMajor = major\n+\t\t\tlastMajorHasGoMod, err = versionHasGoMod(latestAtMajor)\n+\t\t\tif err != nil {\n+\t\t\t\treturn nil, err\n+\t\t\t}\n \t\t}\n \n-\t\tlastMajor = major\n+\t\tif lastMajorHasGoMod {\n+\t\t\t// The latest release of this major version has a go.mod file, so it is\n+\t\t\t// not allowed as +incompatible. It would be confusing to include some\n+\t\t\t// minor versions of this major version as +incompatible but require\n+\t\t\t// semantic import versioning for others, so drop all +incompatible\n+\t\t\t// versions for this major version.\n+\t\t\t//\n+\t\t\t// If we're wrong about a minor version in the middle, users will still be\n+\t\t\t// able to 'go get' specific tags for that version explicitly \u2014 they just\n+\t\t\t// won't appear in 'go list' or as the results for queries with inequality\n+\t\t\t// bounds.\n+\t\t\tcontinue\n+\t\t}\n \t\tlist = append(list, v+\"+incompatible\")\n \t}\n \n@@ -708,7 +701,7 @@ func (r *codeRepo) findDir(version string) (rev, dir string, gomod []byte, err e\n \t\treturn \"\", \"\", nil, fmt.Errorf(\"reading %s/%s at revision %s: %v\", r.pathPrefix, file1, rev, err1)\n \t}\n \tmpath1 := modfile.ModulePath(gomod1)\n-\tfound1 := err1 == nil && isMajor(mpath1, r.pathMajor)\n+\tfound1 := err1 == nil && (isMajor(mpath1, r.pathMajor) || r.canReplaceMismatchedVersionDueToBug(mpath1))\n \n \tvar file2 string\n \tif r.pathMajor != \"\" && r.codeRoot != r.modPath && !strings.HasPrefix(r.pathMajor, \".\") {\n@@ -817,6 +810,17 @@ func isMajor(mpath, pathMajor string) bool {\n \treturn pathMajor[1:] == mpathMajor[1:]\n }\n \n+// canReplaceMismatchedVersionDueToBug reports whether versions of r\n+// could replace versions of mpath with otherwise-mismatched major versions\n+// due to a historical bug in the Go command (golang.org/issue/34254).\n+func (r *codeRepo) canReplaceMismatchedVersionDueToBug(mpath string) bool {\n+\t// The bug caused us to erroneously accept unversioned paths as replacements\n+\t// for versioned gopkg.in paths.\n+\tunversioned := r.pathMajor == \"\"\n+\treplacingGopkgIn := strings.HasPrefix(mpath, \"gopkg.in/\")\n+\treturn unversioned && replacingGopkgIn\n+}\n+\n func (r *codeRepo) GoMod(version string) (data []byte, err error) {\n \tif version != module.CanonicalVersion(version) {\n \t\treturn nil, fmt.Errorf(\"version %s is not canonical\", version)"}, {"sha": "d0642bccf8460605ce88f9c00a09bd6ab9f8cdc2", "filename": "libgo/go/cmd/go/internal/modload/build.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fbuild.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fbuild.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fbuild.go?ref=0b3c2eed35d608d6541ecf004a9576b4eae0b4ef", "patch": "@@ -112,7 +112,7 @@ func moduleInfo(m module.Version, fromBuildList bool) *modinfo.ModulePublic {\n \t\t}\n \t\tif HasModRoot() {\n \t\t\tinfo.Dir = ModRoot()\n-\t\t\tinfo.GoMod = filepath.Join(info.Dir, \"go.mod\")\n+\t\t\tinfo.GoMod = ModFilePath()\n \t\t\tif modFile.Go != nil {\n \t\t\t\tinfo.GoVersion = modFile.Go.Version\n \t\t\t}"}, {"sha": "66c1f70db735c812091788188c8d14d43eeff4f8", "filename": "libgo/go/cmd/go/internal/modload/help.go", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fhelp.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fhelp.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fhelp.go?ref=0b3c2eed35d608d6541ecf004a9576b4eae0b4ef", "patch": "@@ -21,14 +21,15 @@ which source files are used in a given build.\n \n Module support\n \n-Go 1.13 includes support for Go modules. Module-aware mode is active by default\n-whenever a go.mod file is found in, or in a parent of, the current directory.\n+The go command includes support for Go modules. Module-aware mode is active\n+by default whenever a go.mod file is found in the current directory or in\n+any parent directory.\n \n The quickest way to take advantage of module support is to check out your\n repository, create a go.mod file (described in the next section) there, and run\n go commands from within that file tree.\n \n-For more fine-grained control, Go 1.13 continues to respect\n+For more fine-grained control, the go command continues to respect\n a temporary environment variable, GO111MODULE, which can be set to one\n of three string values: off, on, or auto (the default).\n If GO111MODULE=on, then the go command requires the use of modules,"}, {"sha": "5906d648b49afdb7065211eb9bec97cc7f1fbbbd", "filename": "libgo/go/cmd/go/internal/modload/import.go", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fimport.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fimport.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fimport.go?ref=0b3c2eed35d608d6541ecf004a9576b4eae0b4ef", "patch": "@@ -203,7 +203,12 @@ func Import(path string) (m module.Version, dir string, err error) {\n \t\tlatest := map[string]string{} // path -> version\n \t\tfor _, r := range modFile.Replace {\n \t\t\tif maybeInModule(path, r.Old.Path) {\n-\t\t\t\tlatest[r.Old.Path] = semver.Max(r.Old.Version, latest[r.Old.Path])\n+\t\t\t\t// Don't use semver.Max here; need to preserve +incompatible suffix.\n+\t\t\t\tv := latest[r.Old.Path]\n+\t\t\t\tif semver.Compare(r.Old.Version, v) > 0 {\n+\t\t\t\t\tv = r.Old.Version\n+\t\t\t\t}\n+\t\t\t\tlatest[r.Old.Path] = v\n \t\t\t}\n \t\t}\n \n@@ -264,6 +269,8 @@ func Import(path string) (m module.Version, dir string, err error) {\n \t\treturn module.Version{}, \"\", &ImportMissingError{Path: path}\n \t}\n \n+\tfmt.Fprintf(os.Stderr, \"go: finding module for package %s\\n\", path)\n+\n \tcandidates, err := QueryPackage(path, \"latest\", Allowed)\n \tif err != nil {\n \t\tif errors.Is(err, os.ErrNotExist) {"}, {"sha": "7a8391d7e1ab9bec301123e496eae8965a277302", "filename": "libgo/go/cmd/go/internal/modload/load.go", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fload.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fload.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fload.go?ref=0b3c2eed35d608d6541ecf004a9576b4eae0b4ef", "patch": "@@ -1324,6 +1324,21 @@ func fetch(mod module.Version) (dir string, isLocal bool, err error) {\n \t\t\tif !filepath.IsAbs(dir) {\n \t\t\t\tdir = filepath.Join(ModRoot(), dir)\n \t\t\t}\n+\t\t\t// Ensure that the replacement directory actually exists:\n+\t\t\t// dirInModule does not report errors for missing modules,\n+\t\t\t// so if we don't report the error now, later failures will be\n+\t\t\t// very mysterious.\n+\t\t\tif _, err := os.Stat(dir); err != nil {\n+\t\t\t\tif os.IsNotExist(err) {\n+\t\t\t\t\t// Semantically the module version itself \u201cexists\u201d \u2014 we just don't\n+\t\t\t\t\t// have its source code. Remove the equivalence to os.ErrNotExist,\n+\t\t\t\t\t// and make the message more concise while we're at it.\n+\t\t\t\t\terr = fmt.Errorf(\"replacement directory %s does not exist\", r.Path)\n+\t\t\t\t} else {\n+\t\t\t\t\terr = fmt.Errorf(\"replacement directory %s: %w\", r.Path, err)\n+\t\t\t\t}\n+\t\t\t\treturn dir, true, module.VersionError(mod, err)\n+\t\t\t}\n \t\t\treturn dir, true, nil\n \t\t}\n \t\tmod = r"}, {"sha": "031e45938a5d7bf18f74016222c0a8571fd12591", "filename": "libgo/go/cmd/go/internal/modload/query.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fquery.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fquery.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fquery.go?ref=0b3c2eed35d608d6541ecf004a9576b4eae0b4ef", "patch": "@@ -79,7 +79,7 @@ func queryProxy(proxy, path, query, current string, allowed func(module.Version)\n \tif current != \"\" && !semver.IsValid(current) {\n \t\treturn nil, fmt.Errorf(\"invalid previous version %q\", current)\n \t}\n-\tif cfg.BuildMod != \"\" && cfg.BuildMod != \"mod\" {\n+\tif cfg.BuildMod == \"vendor\" {\n \t\treturn nil, errQueryDisabled\n \t}\n \tif allowed == nil {"}, {"sha": "15470e2685367b1ea8bdd8a3fe53de5dfb0ce145", "filename": "libgo/go/cmd/go/internal/modload/query_test.go", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fquery_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fquery_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fquery_test.go?ref=0b3c2eed35d608d6541ecf004a9576b4eae0b4ef", "patch": "@@ -64,7 +64,7 @@ var queryTests = []struct {\n \t\tgit add go.mod\n \t\tgit commit -m v1 go.mod\n \t\tgit tag start\n-\t\tfor i in v0.0.0-pre1 v0.0.0 v0.0.1 v0.0.2 v0.0.3 v0.1.0 v0.1.1 v0.1.2 v0.3.0 v1.0.0 v1.1.0 v1.9.0 v1.9.9 v1.9.10-pre1 v1.9.10-pre2+metadata; do\n+\t\tfor i in v0.0.0-pre1 v0.0.0 v0.0.1 v0.0.2 v0.0.3 v0.1.0 v0.1.1 v0.1.2 v0.3.0 v1.0.0 v1.1.0 v1.9.0 v1.9.9 v1.9.10-pre1 v1.9.10-pre2+metadata unversioned; do\n \t\t\techo before $i >status\n \t\t\tgit add status\n \t\t\tgit commit -m \"before $i\" status\n@@ -107,6 +107,7 @@ var queryTests = []struct {\n \t{path: queryRepo, query: \"v0.2\", err: `no matching versions for query \"v0.2\"`},\n \t{path: queryRepo, query: \"v0.0\", vers: \"v0.0.3\"},\n \t{path: queryRepo, query: \"v1.9.10-pre2+metadata\", vers: \"v1.9.10-pre2.0.20190513201126-42abcb6df8ee\"},\n+\t{path: queryRepo, query: \"ed5ffdaa\", vers: \"v1.9.10-pre2.0.20191220134614-ed5ffdaa1f5e\"},\n \n \t// golang.org/issue/29262: The major version for for a module without a suffix\n \t// should be based on the most recent tag (v1 as appropriate, not v0\n@@ -162,10 +163,14 @@ var queryTests = []struct {\n \t{path: queryRepoV2, query: \"v2.6.0-pre1\", vers: \"v2.6.0-pre1\"},\n \t{path: queryRepoV2, query: \"latest\", vers: \"v2.5.5\"},\n \n-\t// e0cf3de987e6 is the latest commit on the master branch, and it's actually\n-\t// v1.19.10-pre1, not anything resembling v3: attempting to query it as such\n-\t// should fail.\n+\t// Commit e0cf3de987e6 is actually v1.19.10-pre1, not anything resembling v3,\n+\t// and it has a go.mod file with a non-v3 module path. Attempting to query it\n+\t// as the v3 module should fail.\n \t{path: queryRepoV3, query: \"e0cf3de987e6\", err: `vcs-test.golang.org/git/querytest.git/v3@v3.0.0-20180704024501-e0cf3de987e6: invalid version: go.mod has non-.../v3 module path \"vcs-test.golang.org/git/querytest.git\" (and .../v3/go.mod does not exist) at revision e0cf3de987e6`},\n+\n+\t// The querytest repo does not have any commits tagged with major version 3,\n+\t// and the latest commit in the repo has a go.mod file specifying a non-v3 path.\n+\t// That should prevent us from resolving any version for the /v3 path.\n \t{path: queryRepoV3, query: \"latest\", err: `no matching versions for query \"latest\"`},\n \n \t{path: emptyRepo, query: \"latest\", vers: \"v0.0.0-20180704023549-7bb914627242\"},"}, {"sha": "7d17c0c01eda8c29099f0b3d96b8e1028df141d0", "filename": "libgo/go/cmd/go/internal/work/gc.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fgc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fgc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fgc.go?ref=0b3c2eed35d608d6541ecf004a9576b4eae0b4ef", "patch": "@@ -227,8 +227,8 @@ func (a *Action) trimpath() string {\n \t// For \"go build -trimpath\", rewrite package source directory\n \t// to a file system-independent path (just the import path).\n \tif cfg.BuildTrimpath {\n-\t\tif m := a.Package.Module; m != nil {\n-\t\t\trewrite += \";\" + m.Dir + \"=>\" + m.Path + \"@\" + m.Version\n+\t\tif m := a.Package.Module; m != nil && m.Version != \"\" {\n+\t\t\trewrite += \";\" + a.Package.Dir + \"=>\" + m.Path + \"@\" + m.Version + strings.TrimPrefix(a.Package.ImportPath, m.Path)\n \t\t} else {\n \t\t\trewrite += \";\" + a.Package.Dir + \"=>\" + a.Package.ImportPath\n \t\t}"}, {"sha": "f7f642387004c4e9e4657e30fdd69ca30fe2a804", "filename": "libgo/go/cmd/go/testdata/badmod/go.mod", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fbadmod%2Fgo.mod", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fbadmod%2Fgo.mod", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fbadmod%2Fgo.mod?ref=17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41", "patch": "@@ -1 +0,0 @@\n-module m"}, {"sha": "579fb086eeb744698ff9c095aa6250ec7fafebf0", "filename": "libgo/go/cmd/go/testdata/badmod/x.go", "status": "removed", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fbadmod%2Fx.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fbadmod%2Fx.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fbadmod%2Fx.go?ref=17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41", "patch": "@@ -1,4 +0,0 @@\n-package x\n-\n-import _ \"appengine\"\n-import _ \"nonexistent.rsc.io\" // domain does not exist"}, {"sha": "ddf613d870126ca62b6402718b2f1e466c77e4af", "filename": "libgo/go/cmd/go/testdata/flag_test.go", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fflag_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fflag_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fflag_test.go?ref=17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41", "patch": "@@ -1,16 +0,0 @@\n-package flag_test\n-\n-import (\n-\t\"flag\"\n-\t\"log\"\n-\t\"testing\"\n-)\n-\n-var v = flag.Int(\"v\", 0, \"v flag\")\n-\n-// Run this as go test pkg -v=7\n-func TestVFlagIsSet(t *testing.T) {\n-\tif *v != 7 {\n-\t\tlog.Fatal(\"v flag not set\")\n-\t}\n-}"}, {"sha": "e104c2e992b35026a3cece0a4e41ca42b6a26abd", "filename": "libgo/go/cmd/go/testdata/importcom/bad.go", "status": "removed", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fimportcom%2Fbad.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fimportcom%2Fbad.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fimportcom%2Fbad.go?ref=17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41", "patch": "@@ -1,3 +0,0 @@\n-package p\n-\n-import \"bad\""}, {"sha": "995556c51148eec79bf7d4332159fe5cab15238d", "filename": "libgo/go/cmd/go/testdata/importcom/conflict.go", "status": "removed", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fimportcom%2Fconflict.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fimportcom%2Fconflict.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fimportcom%2Fconflict.go?ref=17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41", "patch": "@@ -1,3 +0,0 @@\n-package p\n-\n-import \"conflict\""}, {"sha": "bc51fd3fdeeb120877a927a0548dcd0f94e3aadb", "filename": "libgo/go/cmd/go/testdata/importcom/src/bad/bad.go", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fimportcom%2Fsrc%2Fbad%2Fbad.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fimportcom%2Fsrc%2Fbad%2Fbad.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fimportcom%2Fsrc%2Fbad%2Fbad.go?ref=17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41", "patch": "@@ -1 +0,0 @@\n-package bad // import"}, {"sha": "2d677035119bab23b86a306ef0d0f9a0a0e8d25c", "filename": "libgo/go/cmd/go/testdata/importcom/src/conflict/a.go", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fimportcom%2Fsrc%2Fconflict%2Fa.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fimportcom%2Fsrc%2Fconflict%2Fa.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fimportcom%2Fsrc%2Fconflict%2Fa.go?ref=17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41", "patch": "@@ -1 +0,0 @@\n-package conflict // import \"a\""}, {"sha": "8fcfb3c8bd3c7f39844814b434a3aa92b34d62a2", "filename": "libgo/go/cmd/go/testdata/importcom/src/conflict/b.go", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fimportcom%2Fsrc%2Fconflict%2Fb.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fimportcom%2Fsrc%2Fconflict%2Fb.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fimportcom%2Fsrc%2Fconflict%2Fb.go?ref=17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41", "patch": "@@ -1 +0,0 @@\n-package conflict /* import \"b\" */"}, {"sha": "044c6eca803b62bca73e737d2c06fb037400014f", "filename": "libgo/go/cmd/go/testdata/importcom/src/works/x/x.go", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fimportcom%2Fsrc%2Fworks%2Fx%2Fx.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fimportcom%2Fsrc%2Fworks%2Fx%2Fx.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fimportcom%2Fsrc%2Fworks%2Fx%2Fx.go?ref=17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41", "patch": "@@ -1 +0,0 @@\n-package x // import \"works/x\""}, {"sha": "2449b29df51ef066e551ef72d9f7d17ce68a571f", "filename": "libgo/go/cmd/go/testdata/importcom/src/works/x/x1.go", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fimportcom%2Fsrc%2Fworks%2Fx%2Fx1.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fimportcom%2Fsrc%2Fworks%2Fx%2Fx1.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fimportcom%2Fsrc%2Fworks%2Fx%2Fx1.go?ref=17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41", "patch": "@@ -1 +0,0 @@\n-package x // important! not an import comment"}, {"sha": "b89849da78598b01ec6bfdca94fc4355f5174c8d", "filename": "libgo/go/cmd/go/testdata/importcom/src/wrongplace/x.go", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fimportcom%2Fsrc%2Fwrongplace%2Fx.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fimportcom%2Fsrc%2Fwrongplace%2Fx.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fimportcom%2Fsrc%2Fwrongplace%2Fx.go?ref=17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41", "patch": "@@ -1 +0,0 @@\n-package x // import \"my/x\""}, {"sha": "31b55d08a37f08e425e06c082bc2dd476b7d2c26", "filename": "libgo/go/cmd/go/testdata/importcom/works.go", "status": "removed", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fimportcom%2Fworks.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fimportcom%2Fworks.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fimportcom%2Fworks.go?ref=17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41", "patch": "@@ -1,3 +0,0 @@\n-package p\n-\n-import _ \"works/x\""}, {"sha": "e2535e01ae0efbb973995828a5a5cbd2b107d8bd", "filename": "libgo/go/cmd/go/testdata/importcom/wrongplace.go", "status": "removed", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fimportcom%2Fwrongplace.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fimportcom%2Fwrongplace.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fimportcom%2Fwrongplace.go?ref=17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41", "patch": "@@ -1,3 +0,0 @@\n-package p\n-\n-import \"wrongplace\""}, {"sha": "dc63c4b9f295b800294836b5531e175b4571a118", "filename": "libgo/go/cmd/go/testdata/importcycle/src/selfimport/selfimport.go", "status": "removed", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fimportcycle%2Fsrc%2Fselfimport%2Fselfimport.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fimportcycle%2Fsrc%2Fselfimport%2Fselfimport.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fimportcycle%2Fsrc%2Fselfimport%2Fselfimport.go?ref=17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41", "patch": "@@ -1,3 +0,0 @@\n-package selfimport\n-\n-import \"selfimport\""}, {"sha": "7dba6b394c9b628396f4211cc0b71dcc58d60b5b", "filename": "libgo/go/cmd/go/testdata/script/README", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2FREADME", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2FREADME", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2FREADME?ref=0b3c2eed35d608d6541ecf004a9576b4eae0b4ef", "patch": "@@ -40,7 +40,7 @@ Scripts also have access to these other environment variables:\n \tgoversion=<current Go version; for example, 1.12>\n \t:=<OS-specific path list separator>\n \n-The scripts supporting files are unpacked relative to $GOPATH/src (aka $WORK/gopath/src)\n+The scripts' supporting files are unpacked relative to $GOPATH/src (aka $WORK/gopath/src)\n and then the script begins execution in that directory as well. Thus the example above runs\n in $WORK/gopath/src with GOPATH=$WORK/gopath and $WORK/gopath/src/hello.go\n containing the listed contents."}, {"sha": "b3f32fe696af75b6ba36918f8c102dc5465baa05", "filename": "libgo/go/cmd/go/testdata/script/clean_testcache.txt", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fclean_testcache.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fclean_testcache.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fclean_testcache.txt?ref=0b3c2eed35d608d6541ecf004a9576b4eae0b4ef", "patch": "@@ -9,11 +9,18 @@ go clean -testcache\n go test x_test.go\n ! stdout 'cached'\n \n+# golang.org/issue/29100: 'go clean -testcache' should succeed\n+# if the cache directory doesn't exist at all.\n+# It should not write a testexpire.txt file, since there are no\n+# test results that need to be invalidated in the first place.\n+env GOCACHE=$WORK/nonexistent\n+go clean -testcache\n+! exists $WORK/nonexistent\n \n -- x/x_test.go --\n package x_test\n import (\n     \"testing\"\n )\n func TestMain(t *testing.T) {\n-}\n\\ No newline at end of file\n+}"}, {"sha": "03169bf5e9f1ddcd6c6428bafe0b7226dfd20b69", "filename": "libgo/go/cmd/go/testdata/script/link_syso_issue33139.txt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Flink_syso_issue33139.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Flink_syso_issue33139.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Flink_syso_issue33139.txt?ref=0b3c2eed35d608d6541ecf004a9576b4eae0b4ef", "patch": "@@ -8,6 +8,10 @@\n # See: https://github.com/golang/go/issues/8912\n [linux] [ppc64] skip\n \n+# External linking is not supported on linux/riscv64.\n+# See: https://github.com/golang/go/issues/36739\n+[linux] [riscv64] skip\n+\n # External linking is not supported on darwin/386 (10.14+).\n # See: https://github.com/golang/go/issues/31751\n [darwin] [386] skip"}, {"sha": "3680ca273d98f20b1dee02333703e1227837e67f", "filename": "libgo/go/cmd/go/testdata/script/mod_get_test.txt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_test.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_test.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_test.txt?ref=0b3c2eed35d608d6541ecf004a9576b4eae0b4ef", "patch": "@@ -33,7 +33,7 @@ grep 'rsc.io/quote v1.5.1$' go.mod\n \n # 'go get all' should consider test dependencies with or without -t.\n cp go.mod.empty go.mod\n-go get all\n+go get -d all\n grep 'rsc.io/quote v1.5.2$' go.mod\n \n -- go.mod.empty --"}, {"sha": "67d9a1584f51f8fcabbf62dc83a466bf95ae98db", "filename": "libgo/go/cmd/go/testdata/script/mod_load_badchain.txt", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_load_badchain.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_load_badchain.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_load_badchain.txt?ref=0b3c2eed35d608d6541ecf004a9576b4eae0b4ef", "patch": "@@ -75,12 +75,14 @@ go: example.com/badchain/a@v1.1.0 requires\n \tmodule declares its path as: badchain.example.com/c\n \t        but was required as: example.com/badchain/c\n -- list-missing-expected --\n+go: finding module for package example.com/badchain/c\n go: found example.com/badchain/c in example.com/badchain/c v1.1.0\n go: m/use imports\n \texample.com/badchain/c: example.com/badchain/c@v1.1.0: parsing go.mod:\n \tmodule declares its path as: badchain.example.com/c\n \t        but was required as: example.com/badchain/c\n -- list-missing-test-expected --\n+go: finding module for package example.com/badchain/c\n go: found example.com/badchain/c in example.com/badchain/c v1.1.0\n go: m/testuse tested by\n \tm/testuse.test imports"}, {"sha": "77fc735d5729a5ca86f190159d466050f9455937", "filename": "libgo/go/cmd/go/testdata/script/mod_readonly.txt", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_readonly.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_readonly.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_readonly.txt?ref=0b3c2eed35d608d6541ecf004a9576b4eae0b4ef", "patch": "@@ -34,6 +34,11 @@ go list all\n go clean -modcache\n go list all\n \n+# -mod=readonly must not cause 'go list -m' to fail.\n+# (golang.org/issue/36478)\n+go list -m all\n+! stderr 'cannot query module'\n+\n # -mod=readonly should reject inconsistent go.mod files\n # (ones that would be rewritten).\n go mod edit -require rsc.io/sampler@v1.2.0"}, {"sha": "28c1196284d9a5e2264a7125425d7248badcad9f", "filename": "libgo/go/cmd/go/testdata/script/mod_replace_gopkgin.txt", "status": "modified", "additions": 54, "deletions": 3, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_replace_gopkgin.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_replace_gopkgin.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_replace_gopkgin.txt?ref=0b3c2eed35d608d6541ecf004a9576b4eae0b4ef", "patch": "@@ -15,14 +15,65 @@ env GOSUMDB=off\n # Replacing gopkg.in/[\u2026].vN with a repository with a root go.mod file\n # specifying [\u2026].vN and a compatible version should succeed, even if\n # the replacement path is not a gopkg.in path.\n-cd dot-to-dot\n-go list gopkg.in/src-d/go-git.v4\n+cd 4-to-4\n+go list -m gopkg.in/src-d/go-git.v4\n \n--- dot-to-dot/go.mod --\n+# Previous versions of the \"go\" command accepted v0 and v1 pseudo-versions\n+# as replacements for gopkg.in/[\u2026].v4.\n+# As a special case, we continue to accept those.\n+\n+cd ../4-to-0\n+go list -m gopkg.in/src-d/go-git.v4\n+\n+cd ../4-to-1\n+go list -m gopkg.in/src-d/go-git.v4\n+\n+cd ../4-to-incompatible\n+go list -m gopkg.in/src-d/go-git.v4\n+\n+# A mismatched gopkg.in path should not be able to replace a different major version.\n+cd ../3-to-gomod-4\n+! go list -m gopkg.in/src-d/go-git.v3\n+stderr '^go: gopkg\\.in/src-d/go-git\\.v3@v3.0.0-20190801152248-0d1a009cbb60: invalid version: go\\.mod has non-\\.\\.\\.\\.v3 module path \"gopkg\\.in/src-d/go-git\\.v4\" at revision 0d1a009cbb60$'\n+\n+-- 4-to-4/go.mod --\n module golang.org/issue/34254\n \n go 1.13\n \n require gopkg.in/src-d/go-git.v4 v4.13.1\n \n replace gopkg.in/src-d/go-git.v4 v4.13.1 => github.com/src-d/go-git/v4 v4.13.1\n+-- 4-to-1/go.mod --\n+module golang.org/issue/34254\n+\n+go 1.13\n+\n+require gopkg.in/src-d/go-git.v4 v4.13.1\n+\n+replace gopkg.in/src-d/go-git.v4 v4.13.1 => github.com/src-d/go-git v1.0.1-0.20190801152248-0d1a009cbb60\n+-- 4-to-0/go.mod --\n+module golang.org/issue/34254\n+\n+go 1.13\n+\n+require gopkg.in/src-d/go-git.v4 v4.13.1\n+\n+replace gopkg.in/src-d/go-git.v4 v4.13.1 => github.com/src-d/go-git v0.0.0-20190801152248-0d1a009cbb60\n+-- 4-to-incompatible/go.mod --\n+module golang.org/issue/34254\n+\n+go 1.13\n+\n+require gopkg.in/src-d/go-git.v4 v4.13.1\n+\n+replace gopkg.in/src-d/go-git.v4 v4.13.1 => github.com/src-d/go-git v4.6.0+incompatible\n+-- 3-to-gomod-4/go.mod --\n+module golang.org/issue/34254\n+go 1.13\n+\n+require gopkg.in/src-d/go-git.v3 v3.2.0\n+\n+// This replacement has a go.mod file declaring its path to be\n+// gopkg.in/src-d/go-git.v4, so it cannot be used as a replacement for v3.\n+replace gopkg.in/src-d/go-git.v3 v3.2.0 => gopkg.in/src-d/go-git.v3 v3.0.0-20190801152248-0d1a009cbb60"}, {"sha": "fd5b04a498739b4b358aef1ea2514c2202eee5ed", "filename": "libgo/go/cmd/go/testdata/script/mod_replace_import.txt", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_replace_import.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_replace_import.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_replace_import.txt?ref=0b3c2eed35d608d6541ecf004a9576b4eae0b4ef", "patch": "@@ -28,7 +28,8 @@ stdout 'example.com/v v1.12.0 => ./v12'\n cd fail\n ! go list all\n stdout 'localhost.fail'\n-stderr '^can.t load package: m.go:3:8: module w@latest found \\(v0.0.0-00010101000000-000000000000, replaced by ../w\\), but does not contain package w$'\n+stderr '^can''t load package: m.go:4:2: module w@latest found \\(v0.0.0-00010101000000-000000000000, replaced by ../w\\), but does not contain package w$'\n+stderr '^can''t load package: m.go:5:2: nonexist@v0.1.0: replacement directory ../nonexist does not exist$'\n \n -- go.mod --\n module example.com/m\n@@ -54,13 +55,18 @@ replace (\n \texample.com/v => ./v\n )\n \n+replace (\n+\texample.com/i v2.0.0+incompatible => ./i2\n+)\n+\n -- m.go --\n package main\n import (\n \t_ \"example.com/a/b\"\n \t_ \"example.com/x/v3\"\n \t_ \"example.com/y/z/w\"\n \t_ \"example.com/v\"\n+\t_ \"example.com/i\"\n )\n func main() {}\n \n@@ -115,10 +121,18 @@ module v.localhost\n -- v/v.go --\n package v\n \n+-- i2/go.mod --\n+module example.com/i\n+-- i2/i.go --\n+package i\n+\n -- fail/m.go --\n package main\n \n-import _ \"w\"\n+import (\n+\t_ \"w\"\n+\t_ \"nonexist\"\n+)\n \n func main() {}\n \n@@ -127,3 +141,4 @@ module localhost.fail\n \n replace w => ../w\n \n+replace nonexist v0.1.0 => ../nonexist"}, {"sha": "653ad282be1ca5f671b65979a47e80c4c66bf854", "filename": "libgo/go/cmd/go/testdata/script/mod_run_internal.txt", "status": "removed", "additions": 0, "deletions": 46, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_run_internal.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_run_internal.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_run_internal.txt?ref=17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41", "patch": "@@ -1,46 +0,0 @@\n-env GO111MODULE=on\n-\n-go list -e -f '{{.Incomplete}}' runbad1.go\n-stdout true\n-! go run runbad1.go\n-stderr 'use of internal package m/x/internal not allowed'\n-\n-go list -e -f '{{.Incomplete}}' runbad2.go\n-stdout true\n-! go run runbad2.go\n-stderr 'use of internal package m/x/internal/y not allowed'\n-\n-go list -e -f '{{.Incomplete}}' runok.go\n-stdout false\n-go run runok.go\n-\n--- go.mod --\n-module m\n-\n--- x/internal/internal.go --\n-package internal\n-\n--- x/internal/y/y.go --\n-package y\n-\n--- internal/internal.go --\n-package internal\n-\n--- internal/z/z.go --\n-package z\n-\n--- runbad1.go --\n-package main\n-import _ \"m/x/internal\"\n-func main() {}\n-\n--- runbad2.go --\n-package main\n-import _ \"m/x/internal/y\"\n-func main() {}\n-\n--- runok.go --\n-package main\n-import _ \"m/internal\"\n-import _ \"m/internal/z\"\n-func main() {}"}, {"sha": "2622916f614140cf09b49cb4afba4a9655e22609", "filename": "libgo/go/cmd/go/testdata/script/mod_vendor.txt", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_vendor.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_vendor.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_vendor.txt?ref=0b3c2eed35d608d6541ecf004a9576b4eae0b4ef", "patch": "@@ -38,6 +38,12 @@ stdout 'src[\\\\/]vendor[\\\\/]x'\n go list -mod=vendor -f '{{.Version}} {{.Dir}}' -m x\n stdout '^v1.0.0 $'\n \n+# -mod=vendor should cause 'go list' flags that look up versions to fail.\n+! go list -mod=vendor -versions -m x\n+stderr '^go list -m: can''t determine available versions using the vendor directory\\n\\t\\(Use -mod=mod or -mod=readonly to bypass.\\)$'\n+! go list -mod=vendor -u -m x\n+stderr '^go list -m: can''t determine available upgrades using the vendor directory\\n\\t\\(Use -mod=mod or -mod=readonly to bypass.\\)$'\n+\n # 'go list -mod=vendor -m' on a transitive dependency that does not\n # provide vendored packages should give a helpful error rather than\n # 'not a known dependency'."}, {"sha": "f05bf03fbf0e73b4bdcaea143a0485d563d50859", "filename": "libgo/go/cmd/go/testdata/script/modfile_flag.txt", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmodfile_flag.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmodfile_flag.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmodfile_flag.txt?ref=0b3c2eed35d608d6541ecf004a9576b4eae0b4ef", "patch": "@@ -11,6 +11,15 @@ cp go.sum go.sum.orig\n go mod init example.com/m\n grep example.com/m go.alt.mod\n \n+# 'go env GOMOD' should print the path to the real file.\n+# 'go env' does not recognize the '-modfile' flag.\n+go env GOMOD\n+stdout '^\\$WORK[/\\\\]gopath[/\\\\]src[/\\\\]go.mod$'\n+\n+# 'go list -m' should print the effective go.mod file as GoMod though.\n+go list -m -f '{{.GoMod}}'\n+stdout '^go.alt.mod$'\n+\n # go mod edit should operate on the alternate file\n go mod edit -require rsc.io/quote@v1.5.2\n grep rsc.io/quote go.alt.mod"}, {"sha": "75b3b6870a755abf1d319657a342bbaf4e7d405e", "filename": "libgo/go/cmd/go/testdata/script/test_badtest.txt", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Ftest_badtest.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Ftest_badtest.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Ftest_badtest.txt?ref=0b3c2eed35d608d6541ecf004a9576b4eae0b4ef", "patch": "@@ -1,11 +1,21 @@\n env GO111MODULE=off\n \n-! go test badtest/...\n+! go test badtest/badexec\n ! stdout ^ok\n stdout ^FAIL\\tbadtest/badexec\n+\n+! go test badtest/badsyntax\n+! stdout ^ok\n stdout ^FAIL\\tbadtest/badsyntax\n+\n+! go test badtest/badvar\n+! stdout ^ok\n stdout ^FAIL\\tbadtest/badvar\n \n+! go test notest\n+! stdout ^ok\n+stderr '^notest.hello.go:6:1: .*declaration' # Exercise issue #7108\n+\n -- badtest/badexec/x_test.go --\n package badexec\n \n@@ -30,3 +40,10 @@ package badvar_test\n func f() {\n \t_ = notdefined\n }\n+-- notest/hello.go --\n+package notest\n+\n+func hello() {\n+\tprintln(\"hello world\")\n+}\n+Hello world"}, {"sha": "f6cbf6924db1414a3001acd3c6005eff2bb99b8b", "filename": "libgo/go/cmd/go/testdata/src/badc/x.c", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fbadc%2Fx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fbadc%2Fx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fbadc%2Fx.c?ref=17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41", "patch": "@@ -1 +0,0 @@\n-// C code!"}, {"sha": "bfa1de28bde5178ac93b88b3153efaa6cc56b9cc", "filename": "libgo/go/cmd/go/testdata/src/badc/x.go", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fbadc%2Fx.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fbadc%2Fx.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fbadc%2Fx.go?ref=17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41", "patch": "@@ -1 +0,0 @@\n-package badc"}, {"sha": "dda35e8ed3db96f40fe93a0f5a6ba71cb13180d1", "filename": "libgo/go/cmd/go/testdata/src/badpkg/x.go", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fbadpkg%2Fx.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fbadpkg%2Fx.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fbadpkg%2Fx.go?ref=17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41", "patch": "@@ -1 +0,0 @@\n-pkg badpkg"}, {"sha": "32cabf8a7be1a78659bb5bc8a03381ea9582de63", "filename": "libgo/go/cmd/go/testdata/src/bench/x_test.go", "status": "removed", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fbench%2Fx_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fbench%2Fx_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fbench%2Fx_test.go?ref=17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41", "patch": "@@ -1,6 +0,0 @@\n-package bench\n-\n-import \"testing\"\n-\n-func Benchmark(b *testing.B) {\n-}"}, {"sha": "8d3a5deced86161f16d113e16049508cb03ce251", "filename": "libgo/go/cmd/go/testdata/src/benchfatal/x_test.go", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fbenchfatal%2Fx_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fbenchfatal%2Fx_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fbenchfatal%2Fx_test.go?ref=17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41", "patch": "@@ -1,7 +0,0 @@\n-package benchfatal\n-\n-import \"testing\"\n-\n-func BenchmarkThatCallsFatal(b *testing.B) {\n-\tb.Fatal(\"called by benchmark\")\n-}"}, {"sha": "148b47f6a5b6bb1320c5efed8c92eb0350f87af6", "filename": "libgo/go/cmd/go/testdata/src/cgoasm/p.go", "status": "removed", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcgoasm%2Fp.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcgoasm%2Fp.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcgoasm%2Fp.go?ref=17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41", "patch": "@@ -1,8 +0,0 @@\n-package p\n-\n-/*\n-// hi\n-*/\n-import \"C\"\n-\n-func F() {}"}, {"sha": "aaade03a437067ae22796ced4624ad468737936c", "filename": "libgo/go/cmd/go/testdata/src/cgoasm/p.s", "status": "removed", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcgoasm%2Fp.s", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcgoasm%2Fp.s", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcgoasm%2Fp.s?ref=17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41", "patch": "@@ -1,2 +0,0 @@\n-TEXT asm(SB),$0\n-\tRET"}, {"sha": "a6a3891cd4e029d5e82f43ed0a3bedd0b158e30b", "filename": "libgo/go/cmd/go/testdata/src/cgocover/p.go", "status": "removed", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcgocover%2Fp.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcgocover%2Fp.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcgocover%2Fp.go?ref=17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41", "patch": "@@ -1,19 +0,0 @@\n-package p\n-\n-/*\n-void\n-f(void)\n-{\n-}\n-*/\n-import \"C\"\n-\n-var b bool\n-\n-func F() {\n-\tif b {\n-\t\tfor {\n-\t\t}\n-\t}\n-\tC.f()\n-}"}, {"sha": "a8f057e358767230643d2cb226c69cfb75303b52", "filename": "libgo/go/cmd/go/testdata/src/cgocover/p_test.go", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcgocover%2Fp_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcgocover%2Fp_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcgocover%2Fp_test.go?ref=17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41", "patch": "@@ -1,7 +0,0 @@\n-package p\n-\n-import \"testing\"\n-\n-func TestF(t *testing.T) {\n-\tF()\n-}"}, {"sha": "a6a3891cd4e029d5e82f43ed0a3bedd0b158e30b", "filename": "libgo/go/cmd/go/testdata/src/cgocover2/p.go", "status": "removed", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcgocover2%2Fp.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcgocover2%2Fp.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcgocover2%2Fp.go?ref=17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41", "patch": "@@ -1,19 +0,0 @@\n-package p\n-\n-/*\n-void\n-f(void)\n-{\n-}\n-*/\n-import \"C\"\n-\n-var b bool\n-\n-func F() {\n-\tif b {\n-\t\tfor {\n-\t\t}\n-\t}\n-\tC.f()\n-}"}, {"sha": "f4790d2367bbe59e313765d4cfdbf42f1f846818", "filename": "libgo/go/cmd/go/testdata/src/cgocover2/x_test.go", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcgocover2%2Fx_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcgocover2%2Fx_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcgocover2%2Fx_test.go?ref=17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41", "patch": "@@ -1,10 +0,0 @@\n-package p_test\n-\n-import (\n-\t. \"cgocover2\"\n-\t\"testing\"\n-)\n-\n-func TestF(t *testing.T) {\n-\tF()\n-}"}, {"sha": "a6a3891cd4e029d5e82f43ed0a3bedd0b158e30b", "filename": "libgo/go/cmd/go/testdata/src/cgocover3/p.go", "status": "removed", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcgocover3%2Fp.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcgocover3%2Fp.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcgocover3%2Fp.go?ref=17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41", "patch": "@@ -1,19 +0,0 @@\n-package p\n-\n-/*\n-void\n-f(void)\n-{\n-}\n-*/\n-import \"C\"\n-\n-var b bool\n-\n-func F() {\n-\tif b {\n-\t\tfor {\n-\t\t}\n-\t}\n-\tC.f()\n-}"}, {"sha": "c89cd18d0fe7d777c6008d0d9133c5bb808be6fc", "filename": "libgo/go/cmd/go/testdata/src/cgocover3/p_test.go", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcgocover3%2Fp_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcgocover3%2Fp_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcgocover3%2Fp_test.go?ref=17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41", "patch": "@@ -1 +0,0 @@\n-package p"}, {"sha": "97d0e0f0989b0adf5c01131c02e1b8bf52769f08", "filename": "libgo/go/cmd/go/testdata/src/cgocover3/x_test.go", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcgocover3%2Fx_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcgocover3%2Fx_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcgocover3%2Fx_test.go?ref=17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41", "patch": "@@ -1,10 +0,0 @@\n-package p_test\n-\n-import (\n-\t. \"cgocover3\"\n-\t\"testing\"\n-)\n-\n-func TestF(t *testing.T) {\n-\tF()\n-}"}, {"sha": "c89cd18d0fe7d777c6008d0d9133c5bb808be6fc", "filename": "libgo/go/cmd/go/testdata/src/cgocover4/notcgo.go", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcgocover4%2Fnotcgo.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcgocover4%2Fnotcgo.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcgocover4%2Fnotcgo.go?ref=17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41", "patch": "@@ -1 +0,0 @@\n-package p"}, {"sha": "a6a3891cd4e029d5e82f43ed0a3bedd0b158e30b", "filename": "libgo/go/cmd/go/testdata/src/cgocover4/p.go", "status": "removed", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcgocover4%2Fp.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcgocover4%2Fp.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcgocover4%2Fp.go?ref=17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41", "patch": "@@ -1,19 +0,0 @@\n-package p\n-\n-/*\n-void\n-f(void)\n-{\n-}\n-*/\n-import \"C\"\n-\n-var b bool\n-\n-func F() {\n-\tif b {\n-\t\tfor {\n-\t\t}\n-\t}\n-\tC.f()\n-}"}, {"sha": "fd9bae743cc28c696c74d75722dbf7f038008369", "filename": "libgo/go/cmd/go/testdata/src/cgocover4/x_test.go", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcgocover4%2Fx_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcgocover4%2Fx_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcgocover4%2Fx_test.go?ref=17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41", "patch": "@@ -1,10 +0,0 @@\n-package p_test\n-\n-import (\n-\t. \"cgocover4\"\n-\t\"testing\"\n-)\n-\n-func TestF(t *testing.T) {\n-\tF()\n-}"}, {"sha": "2f078525b9de63095992379c996abab455afc1bf", "filename": "libgo/go/cmd/go/testdata/src/dupload/dupload.go", "status": "removed", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fdupload%2Fdupload.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fdupload%2Fdupload.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fdupload%2Fdupload.go?ref=17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41", "patch": "@@ -1,8 +0,0 @@\n-package main\n-\n-import (\n-\t_ \"dupload/p2\"\n-\t_ \"p\"\n-)\n-\n-func main() {}"}, {"sha": "c89cd18d0fe7d777c6008d0d9133c5bb808be6fc", "filename": "libgo/go/cmd/go/testdata/src/dupload/p/p.go", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fdupload%2Fp%2Fp.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fdupload%2Fp%2Fp.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fdupload%2Fp%2Fp.go?ref=17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41", "patch": "@@ -1 +0,0 @@\n-package p"}, {"sha": "8a80979b4e6c6866fc34f40a4ae13ff5176c3953", "filename": "libgo/go/cmd/go/testdata/src/dupload/p2/p2.go", "status": "removed", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fdupload%2Fp2%2Fp2.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fdupload%2Fp2%2Fp2.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fdupload%2Fp2%2Fp2.go?ref=17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41", "patch": "@@ -1,3 +0,0 @@\n-package p2\n-\n-import _ \"dupload/vendor/p\""}, {"sha": "c89cd18d0fe7d777c6008d0d9133c5bb808be6fc", "filename": "libgo/go/cmd/go/testdata/src/dupload/vendor/p/p.go", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fdupload%2Fvendor%2Fp%2Fp.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fdupload%2Fvendor%2Fp%2Fp.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fdupload%2Fvendor%2Fp%2Fp.go?ref=17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41", "patch": "@@ -1 +0,0 @@\n-package p"}, {"sha": "600afd93e93a6c9af1ed79a33a43f4ed5640dc30", "filename": "libgo/go/cmd/go/testdata/src/gencycle/gencycle.go", "status": "removed", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fgencycle%2Fgencycle.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fgencycle%2Fgencycle.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fgencycle%2Fgencycle.go?ref=17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41", "patch": "@@ -1,5 +0,0 @@\n-//go:generate echo hello world\n-\n-package gencycle\n-\n-import _ \"gencycle\""}, {"sha": "bf019076dd57d3592fd70bc143dbbc52a65a9845", "filename": "libgo/go/cmd/go/testdata/src/importmain/ismain/main.go", "status": "removed", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fimportmain%2Fismain%2Fmain.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fimportmain%2Fismain%2Fmain.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fimportmain%2Fismain%2Fmain.go?ref=17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41", "patch": "@@ -1,5 +0,0 @@\n-package main\n-\n-import _ \"importmain/test\"\n-\n-func main() {}"}, {"sha": "56e54040790227aab12ae1b2f43991b9f00f87f6", "filename": "libgo/go/cmd/go/testdata/src/importmain/test/test.go", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fimportmain%2Ftest%2Ftest.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fimportmain%2Ftest%2Ftest.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fimportmain%2Ftest%2Ftest.go?ref=17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41", "patch": "@@ -1 +0,0 @@\n-package test"}, {"sha": "2268a8267edd1e02db3f5b94d4e938f82980287e", "filename": "libgo/go/cmd/go/testdata/src/importmain/test/test_test.go", "status": "removed", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fimportmain%2Ftest%2Ftest_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fimportmain%2Ftest%2Ftest_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fimportmain%2Ftest%2Ftest_test.go?ref=17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41", "patch": "@@ -1,6 +0,0 @@\n-package test_test\n-\n-import \"testing\"\n-import _ \"importmain/ismain\"\n-\n-func TestCase(t *testing.T) {}"}, {"sha": "007a86a5da8f128febcddc0ad00597e32a1a7338", "filename": "libgo/go/cmd/go/testdata/src/multimain/multimain_test.go", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fmultimain%2Fmultimain_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fmultimain%2Fmultimain_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fmultimain%2Fmultimain_test.go?ref=17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41", "patch": "@@ -1,16 +0,0 @@\n-package multimain_test\n-\n-import \"testing\"\n-\n-func TestMain(m *testing.M) {\n-\t// Some users run m.Run multiple times, changing\n-\t// some kind of global state between runs.\n-\t// This used to work so I guess now it has to keep working.\n-\t// See golang.org/issue/23129.\n-\tm.Run()\n-\tm.Run()\n-}\n-\n-func Test(t *testing.T) {\n-\tt.Log(\"notwithstanding\")\n-}"}, {"sha": "75a397c6cbac4528e38f31665e41e9a85b3fe700", "filename": "libgo/go/cmd/go/testdata/src/not_main/not_main.go", "status": "removed", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fnot_main%2Fnot_main.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fnot_main%2Fnot_main.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fnot_main%2Fnot_main.go?ref=17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41", "patch": "@@ -1,3 +0,0 @@\n-package not_main\n-\n-func F() {}"}, {"sha": "7c42c32fb0abcae9ad478b2e9b324b4de4814526", "filename": "libgo/go/cmd/go/testdata/src/notest/hello.go", "status": "removed", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fnotest%2Fhello.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fnotest%2Fhello.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fnotest%2Fhello.go?ref=17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41", "patch": "@@ -1,6 +0,0 @@\n-package notest\n-\n-func hello() {\n-\tprintln(\"hello world\")\n-}\n-Hello world"}, {"sha": "c1cc3ac6c8147831fc8f644f5c7e9097aab08f3e", "filename": "libgo/go/cmd/go/testdata/src/run/bad.go", "status": "removed", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Frun%2Fbad.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Frun%2Fbad.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Frun%2Fbad.go?ref=17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41", "patch": "@@ -1,5 +0,0 @@\n-package main\n-\n-import _ \"run/subdir/internal/private\"\n-\n-func main() {}"}, {"sha": "0b67dceeee346b83536f27a705e8efec548e394d", "filename": "libgo/go/cmd/go/testdata/src/run/good.go", "status": "removed", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Frun%2Fgood.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Frun%2Fgood.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Frun%2Fgood.go?ref=17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41", "patch": "@@ -1,5 +0,0 @@\n-package main\n-\n-import _ \"run/internal\"\n-\n-func main() {}"}, {"sha": "5bf0569ce8cb32a1272137a64ea617b4314f98da", "filename": "libgo/go/cmd/go/testdata/src/run/internal/internal.go", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Frun%2Finternal%2Finternal.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Frun%2Finternal%2Finternal.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Frun%2Finternal%2Finternal.go?ref=17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41", "patch": "@@ -1 +0,0 @@\n-package internal"}, {"sha": "735e4dc819d1e1515e3a91749178626bc373e8bd", "filename": "libgo/go/cmd/go/testdata/src/run/subdir/internal/private/private.go", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Frun%2Fsubdir%2Finternal%2Fprivate%2Fprivate.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Frun%2Fsubdir%2Finternal%2Fprivate%2Fprivate.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Frun%2Fsubdir%2Finternal%2Fprivate%2Fprivate.go?ref=17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41", "patch": "@@ -1 +0,0 @@\n-package private"}, {"sha": "333be7d8e4c67190059b20f1e352e2aacd762a8c", "filename": "libgo/go/cmd/go/testdata/src/sleepy1/p_test.go", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fsleepy1%2Fp_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fsleepy1%2Fp_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fsleepy1%2Fp_test.go?ref=17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41", "patch": "@@ -1,10 +0,0 @@\n-package p\n-\n-import (\n-\t\"testing\"\n-\t\"time\"\n-)\n-\n-func Test1(t *testing.T) {\n-\ttime.Sleep(200 * time.Millisecond)\n-}"}, {"sha": "333be7d8e4c67190059b20f1e352e2aacd762a8c", "filename": "libgo/go/cmd/go/testdata/src/sleepy2/p_test.go", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fsleepy2%2Fp_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fsleepy2%2Fp_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fsleepy2%2Fp_test.go?ref=17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41", "patch": "@@ -1,10 +0,0 @@\n-package p\n-\n-import (\n-\t\"testing\"\n-\t\"time\"\n-)\n-\n-func Test1(t *testing.T) {\n-\ttime.Sleep(200 * time.Millisecond)\n-}"}, {"sha": "e05b403e3928670c24c4cc041604d3757d8643c4", "filename": "libgo/go/cmd/go/testdata/src/sleepybad/p.go", "status": "removed", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fsleepybad%2Fp.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fsleepybad%2Fp.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fsleepybad%2Fp.go?ref=17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41", "patch": "@@ -1,5 +0,0 @@\n-package p\n-\n-// missing import\n-\n-var _ = io.DoesNotExist"}, {"sha": "c89cd18d0fe7d777c6008d0d9133c5bb808be6fc", "filename": "libgo/go/cmd/go/testdata/src/syntaxerror/x.go", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fsyntaxerror%2Fx.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fsyntaxerror%2Fx.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fsyntaxerror%2Fx.go?ref=17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41", "patch": "@@ -1 +0,0 @@\n-package p"}, {"sha": "2460743e50186d66712857889ed1506286f2b53f", "filename": "libgo/go/cmd/go/testdata/src/syntaxerror/x_test.go", "status": "removed", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fsyntaxerror%2Fx_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fsyntaxerror%2Fx_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fsyntaxerror%2Fx_test.go?ref=17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41", "patch": "@@ -1,4 +0,0 @@\n-package p\n-\n-func f() (x.y, z int) {\n-}"}, {"sha": "65ab76d4e1e8bafc5e3a1e10dd5be1200625228f", "filename": "libgo/go/cmd/go/testdata/src/testcycle/p1/p1.go", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Ftestcycle%2Fp1%2Fp1.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Ftestcycle%2Fp1%2Fp1.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Ftestcycle%2Fp1%2Fp1.go?ref=17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41", "patch": "@@ -1,7 +0,0 @@\n-package p1\n-\n-import _ \"testcycle/p2\"\n-\n-func init() {\n-\tprintln(\"p1 init\")\n-}"}, {"sha": "75abb13e6d0349938d6d1e1136e225e230ab19f4", "filename": "libgo/go/cmd/go/testdata/src/testcycle/p1/p1_test.go", "status": "removed", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Ftestcycle%2Fp1%2Fp1_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Ftestcycle%2Fp1%2Fp1_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Ftestcycle%2Fp1%2Fp1_test.go?ref=17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41", "patch": "@@ -1,6 +0,0 @@\n-package p1\n-\n-import \"testing\"\n-\n-func Test(t *testing.T) {\n-}"}, {"sha": "7e26cdf19c913f3c4638944540967e93a507caa5", "filename": "libgo/go/cmd/go/testdata/src/testcycle/p2/p2.go", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Ftestcycle%2Fp2%2Fp2.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Ftestcycle%2Fp2%2Fp2.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Ftestcycle%2Fp2%2Fp2.go?ref=17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41", "patch": "@@ -1,7 +0,0 @@\n-package p2\n-\n-import _ \"testcycle/p3\"\n-\n-func init() {\n-\tprintln(\"p2 init\")\n-}"}, {"sha": "bb0a2f4f6569229b75b37b6636c5dede5d35fc62", "filename": "libgo/go/cmd/go/testdata/src/testcycle/p3/p3.go", "status": "removed", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Ftestcycle%2Fp3%2Fp3.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Ftestcycle%2Fp3%2Fp3.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Ftestcycle%2Fp3%2Fp3.go?ref=17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41", "patch": "@@ -1,5 +0,0 @@\n-package p3\n-\n-func init() {\n-\tprintln(\"p3 init\")\n-}"}, {"sha": "9b4b0757f82acca7121fbceb6223c0700e322bb1", "filename": "libgo/go/cmd/go/testdata/src/testcycle/p3/p3_test.go", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Ftestcycle%2Fp3%2Fp3_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Ftestcycle%2Fp3%2Fp3_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Ftestcycle%2Fp3%2Fp3_test.go?ref=17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41", "patch": "@@ -1,10 +0,0 @@\n-package p3\n-\n-import (\n-\t\"testing\"\n-\n-\t_ \"testcycle/p1\"\n-)\n-\n-func Test(t *testing.T) {\n-}"}, {"sha": "7a471f0cc05a38b6c173ada43a7a68e82968456d", "filename": "libgo/go/cmd/go/testdata/src/testcycle/q1/q1.go", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Ftestcycle%2Fq1%2Fq1.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Ftestcycle%2Fq1%2Fq1.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Ftestcycle%2Fq1%2Fq1.go?ref=17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41", "patch": "@@ -1 +0,0 @@\n-package q1"}, {"sha": "ca81bd2bf80b18f01b6a8248a7999fe3d7d20b00", "filename": "libgo/go/cmd/go/testdata/src/testcycle/q1/q1_test.go", "status": "removed", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Ftestcycle%2Fq1%2Fq1_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Ftestcycle%2Fq1%2Fq1_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Ftestcycle%2Fq1%2Fq1_test.go?ref=17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41", "patch": "@@ -1,6 +0,0 @@\n-package q1\n-\n-import \"testing\"\n-import _ \"testcycle/q1\"\n-\n-func Test(t *testing.T) {}"}, {"sha": "a457035a4300f39249b3b263624b537909bd2951", "filename": "libgo/go/cmd/go/testdata/src/testdep/p1/p1.go", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Ftestdep%2Fp1%2Fp1.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Ftestdep%2Fp1%2Fp1.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Ftestdep%2Fp1%2Fp1.go?ref=17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41", "patch": "@@ -1 +0,0 @@\n-package p1"}, {"sha": "8be75334425d606a4070f7e7be41ee83f8d760cb", "filename": "libgo/go/cmd/go/testdata/src/testdep/p1/p1_test.go", "status": "removed", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Ftestdep%2Fp1%2Fp1_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Ftestdep%2Fp1%2Fp1_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Ftestdep%2Fp1%2Fp1_test.go?ref=17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41", "patch": "@@ -1,3 +0,0 @@\n-package p1\n-\n-import _ \"testdep/p2\""}, {"sha": "15ba2eacea5c6e4a26884238c7f98f0149132f71", "filename": "libgo/go/cmd/go/testdata/src/testdep/p2/p2.go", "status": "removed", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Ftestdep%2Fp2%2Fp2.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Ftestdep%2Fp2%2Fp2.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Ftestdep%2Fp2%2Fp2.go?ref=17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41", "patch": "@@ -1,3 +0,0 @@\n-package p2\n-\n-import _ \"testdep/p3\""}, {"sha": "0219e7fae507e173b49c71e668b8fd2811715178", "filename": "libgo/go/cmd/go/testdata/src/testdep/p3/p3.go", "status": "removed", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Ftestdep%2Fp3%2Fp3.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Ftestdep%2Fp3%2Fp3.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Ftestdep%2Fp3%2Fp3.go?ref=17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41", "patch": "@@ -1,3 +0,0 @@\n-// +build ignore\n-\n-package ignored"}, {"sha": "71a9a561ef939c7ed27f76bedfab0d22db272b56", "filename": "libgo/go/cmd/go/testdata/src/testnorun/p.go", "status": "removed", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Ftestnorun%2Fp.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Ftestnorun%2Fp.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Ftestnorun%2Fp.go?ref=17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41", "patch": "@@ -1,5 +0,0 @@\n-package p\n-\n-func init() {\n-\tpanic(\"go test must not link and run test binaries without tests\")\n-}"}, {"sha": "7ec0c6d17a33505ac351db73a26176ca3ff8e1d6", "filename": "libgo/go/cmd/go/testdata/src/testrace/race_test.go", "status": "removed", "additions": 0, "deletions": 31, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Ftestrace%2Frace_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Ftestrace%2Frace_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Ftestrace%2Frace_test.go?ref=17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41", "patch": "@@ -1,31 +0,0 @@\n-package testrace\n-\n-import \"testing\"\n-\n-func TestRace(t *testing.T) {\n-\tfor i := 0; i < 10; i++ {\n-\t\tc := make(chan int)\n-\t\tx := 1\n-\t\tgo func() {\n-\t\t\tx = 2\n-\t\t\tc <- 1\n-\t\t}()\n-\t\tx = 3\n-\t\t<-c\n-\t\t_ = x\n-\t}\n-}\n-\n-func BenchmarkRace(b *testing.B) {\n-\tfor i := 0; i < b.N; i++ {\n-\t\tc := make(chan int)\n-\t\tx := 1\n-\t\tgo func() {\n-\t\t\tx = 2\n-\t\t\tc <- 1\n-\t\t}()\n-\t\tx = 3\n-\t\t<-c\n-\t\t_ = x\n-\t}\n-}"}, {"sha": "7573e79e167d992a188e862138fdb2777c43aca7", "filename": "libgo/go/cmd/go/testdata/src/testregexp/x_test.go", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Ftestregexp%2Fx_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Ftestregexp%2Fx_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Ftestregexp%2Fx_test.go?ref=17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41", "patch": "@@ -1,17 +0,0 @@\n-package x\n-\n-import \"testing\"\n-\n-func TestX(t *testing.T) {\n-\tt.Logf(\"LOG: X running\")\n-\tt.Run(\"Y\", func(t *testing.T) {\n-\t\tt.Logf(\"LOG: Y running\")\n-\t})\n-}\n-\n-func BenchmarkX(b *testing.B) {\n-\tb.Logf(\"LOG: X running N=%d\", b.N)\n-\tb.Run(\"Y\", func(b *testing.B) {\n-\t\tb.Logf(\"LOG: Y running N=%d\", b.N)\n-\t})\n-}"}, {"sha": "4fd1979154403d6ef446a1fb648ece78aea580e5", "filename": "libgo/go/cmd/go/testdata/src/testregexp/z_test.go", "status": "removed", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Ftestregexp%2Fz_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Ftestregexp%2Fz_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Ftestregexp%2Fz_test.go?ref=17edb3310d8ce9d5f6c9e53f6c1f7d611c2a5a41", "patch": "@@ -1,19 +0,0 @@\n-package x\n-\n-import \"testing\"\n-\n-func TestZ(t *testing.T) {\n-\tt.Logf(\"LOG: Z running\")\n-}\n-\n-func TestXX(t *testing.T) {\n-\tt.Logf(\"LOG: XX running\")\n-}\n-\n-func BenchmarkZ(b *testing.B) {\n-\tb.Logf(\"LOG: Z running N=%d\", b.N)\n-}\n-\n-func BenchmarkXX(b *testing.B) {\n-\tb.Logf(\"LOG: XX running N=%d\", b.N)\n-}"}, {"sha": "af44485f44ebb758ad7e41c18656fa2cf24a44de", "filename": "libgo/go/crypto/tls/tls.go", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fcrypto%2Ftls%2Ftls.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fcrypto%2Ftls%2Ftls.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Ftls.go?ref=0b3c2eed35d608d6541ecf004a9576b4eae0b4ef", "patch": "@@ -116,9 +116,10 @@ func DialWithDialer(dialer *net.Dialer, network, addr string, config *Config) (*\n \n \tif timeout != 0 {\n \t\terrChannel = make(chan error, 2)\n-\t\ttime.AfterFunc(timeout, func() {\n+\t\ttimer := time.AfterFunc(timeout, func() {\n \t\t\terrChannel <- timeoutError{}\n \t\t})\n+\t\tdefer timer.Stop()\n \t}\n \n \trawConn, err := dialer.Dial(network, addr)"}, {"sha": "8a54282a6b2d17e4d155327be3f7ca4815d03f05", "filename": "libgo/go/crypto/x509/root_cgo_darwin.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fcrypto%2Fx509%2Froot_cgo_darwin.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fcrypto%2Fx509%2Froot_cgo_darwin.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Froot_cgo_darwin.go?ref=0b3c2eed35d608d6541ecf004a9576b4eae0b4ef", "patch": "@@ -159,7 +159,7 @@ static Boolean isRootCertificate(SecCertificateRef cert, CFErrorRef *errRef) {\n //\n // Note: The CFDataRef returned in pemRoots and untrustedPemRoots must\n // be released (using CFRelease) after we've consumed its content.\n-int CopyPEMRoots(CFDataRef *pemRoots, CFDataRef *untrustedPemRoots, bool debugDarwinRoots) {\n+static int CopyPEMRoots(CFDataRef *pemRoots, CFDataRef *untrustedPemRoots, bool debugDarwinRoots) {\n \tint i;\n \n \tif (debugDarwinRoots) {"}, {"sha": "34d585318d480f83096203807c556cbea565ae87", "filename": "libgo/go/crypto/x509/root_windows.go", "status": "modified", "additions": 18, "deletions": 2, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fcrypto%2Fx509%2Froot_windows.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fcrypto%2Fx509%2Froot_windows.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Froot_windows.go?ref=0b3c2eed35d608d6541ecf004a9576b4eae0b4ef", "patch": "@@ -219,10 +219,26 @@ func (c *Certificate) systemVerify(opts *VerifyOptions) (chains [][]*Certificate\n \tif err != nil {\n \t\treturn nil, err\n \t}\n+\tif len(chain) < 1 {\n+\t\treturn nil, errors.New(\"x509: internal error: system verifier returned an empty chain\")\n+\t}\n \n-\tchains = append(chains, chain)\n+\t// Mitigate CVE-2020-0601, where the Windows system verifier might be\n+\t// tricked into using custom curve parameters for a trusted root, by\n+\t// double-checking all ECDSA signatures. If the system was tricked into\n+\t// using spoofed parameters, the signature will be invalid for the correct\n+\t// ones we parsed. (We don't support custom curves ourselves.)\n+\tfor i, parent := range chain[1:] {\n+\t\tif parent.PublicKeyAlgorithm != ECDSA {\n+\t\t\tcontinue\n+\t\t}\n+\t\tif err := parent.CheckSignature(chain[i].SignatureAlgorithm,\n+\t\t\tchain[i].RawTBSCertificate, chain[i].Signature); err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t}\n \n-\treturn chains, nil\n+\treturn [][]*Certificate{chain}, nil\n }\n \n func loadSystemRoots() (*CertPool, error) {"}, {"sha": "6f59260cdab57335e1dc21ab4541bf4cada65315", "filename": "libgo/go/database/sql/sql_test.go", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fdatabase%2Fsql%2Fsql_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fdatabase%2Fsql%2Fsql_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdatabase%2Fsql%2Fsql_test.go?ref=0b3c2eed35d608d6541ecf004a9576b4eae0b4ef", "patch": "@@ -629,14 +629,18 @@ func TestPoolExhaustOnCancel(t *testing.T) {\n \t\tgo func() {\n \t\t\trows, err := db.Query(\"SELECT|people|name,photo|\")\n \t\t\tif err != nil {\n-\t\t\t\tt.Fatalf(\"Query: %v\", err)\n+\t\t\t\tt.Errorf(\"Query: %v\", err)\n+\t\t\t\treturn\n \t\t\t}\n \t\t\trows.Close()\n \t\t\tsaturateDone.Done()\n \t\t}()\n \t}\n \n \tsaturate.Wait()\n+\tif t.Failed() {\n+\t\tt.FailNow()\n+\t}\n \tstate = 2\n \n \t// Now cancel the request while it is waiting."}, {"sha": "4d11223b96c418ac384266dc4639ffa3871f832d", "filename": "libgo/go/go/build/build_test.go", "status": "modified", "additions": 32, "deletions": 14, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fgo%2Fbuild%2Fbuild_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fgo%2Fbuild%2Fbuild_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fbuild%2Fbuild_test.go?ref=0b3c2eed35d608d6541ecf004a9576b4eae0b4ef", "patch": "@@ -342,20 +342,38 @@ func TestImportDirNotExist(t *testing.T) {\n \t\t{\"Import(full, FindOnly)\", \"go/build/doesnotexist\", \"\", FindOnly},\n \t\t{\"Import(local, FindOnly)\", \"./doesnotexist\", filepath.Join(ctxt.GOROOT, \"src/go/build\"), FindOnly},\n \t}\n-\tfor _, test := range tests {\n-\t\tp, err := ctxt.Import(test.path, test.srcDir, test.mode)\n-\t\tif err == nil || !strings.HasPrefix(err.Error(), \"cannot find package\") {\n-\t\t\tt.Errorf(`%s got error: %q, want \"cannot find package\" error`, test.label, err)\n-\t\t}\n-\t\t// If an error occurs, build.Import is documented to return\n-\t\t// a non-nil *Package containing partial information.\n-\t\tif p == nil {\n-\t\t\tt.Fatalf(`%s got nil p, want non-nil *Package`, test.label)\n-\t\t}\n-\t\t// Verify partial information in p.\n-\t\tif p.ImportPath != \"go/build/doesnotexist\" {\n-\t\t\tt.Errorf(`%s got p.ImportPath: %q, want \"go/build/doesnotexist\"`, test.label, p.ImportPath)\n-\t\t}\n+\n+\tdefer os.Setenv(\"GO111MODULE\", os.Getenv(\"GO111MODULE\"))\n+\n+\tfor _, GO111MODULE := range []string{\"off\", \"on\"} {\n+\t\tt.Run(\"GO111MODULE=\"+GO111MODULE, func(t *testing.T) {\n+\t\t\tos.Setenv(\"GO111MODULE\", GO111MODULE)\n+\n+\t\t\tfor _, test := range tests {\n+\t\t\t\tp, err := ctxt.Import(test.path, test.srcDir, test.mode)\n+\n+\t\t\t\terrOk := (err != nil && strings.HasPrefix(err.Error(), \"cannot find package\"))\n+\t\t\t\twantErr := `\"cannot find package\" error`\n+\t\t\t\tif test.srcDir == \"\" {\n+\t\t\t\t\tif err != nil && strings.Contains(err.Error(), \"is not in GOROOT\") {\n+\t\t\t\t\t\terrOk = true\n+\t\t\t\t\t}\n+\t\t\t\t\twantErr = `\"cannot find package\" or \"is not in GOROOT\" error`\n+\t\t\t\t}\n+\t\t\t\tif !errOk {\n+\t\t\t\t\tt.Errorf(\"%s got error: %q, want %s\", test.label, err, wantErr)\n+\t\t\t\t}\n+\t\t\t\t// If an error occurs, build.Import is documented to return\n+\t\t\t\t// a non-nil *Package containing partial information.\n+\t\t\t\tif p == nil {\n+\t\t\t\t\tt.Fatalf(`%s got nil p, want non-nil *Package`, test.label)\n+\t\t\t\t}\n+\t\t\t\t// Verify partial information in p.\n+\t\t\t\tif p.ImportPath != \"go/build/doesnotexist\" {\n+\t\t\t\t\tt.Errorf(`%s got p.ImportPath: %q, want \"go/build/doesnotexist\"`, test.label, p.ImportPath)\n+\t\t\t\t}\n+\t\t\t}\n+\t\t})\n \t}\n }\n "}, {"sha": "a64c2b32419cdd769d7eef7ff576c8a7f081aee5", "filename": "libgo/go/go/build/deps_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fgo%2Fbuild%2Fdeps_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fgo%2Fbuild%2Fdeps_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fbuild%2Fdeps_test.go?ref=0b3c2eed35d608d6541ecf004a9576b4eae0b4ef", "patch": "@@ -168,7 +168,7 @@ var pkgDeps = map[string][]string{\n \t},\n \n \t\"internal/cfg\":     {\"L0\"},\n-\t\"internal/poll\":    {\"L0\", \"internal/oserror\", \"internal/race\", \"syscall\", \"time\", \"unicode/utf16\", \"unicode/utf8\", \"internal/syscall/windows\"},\n+\t\"internal/poll\":    {\"L0\", \"internal/oserror\", \"internal/race\", \"syscall\", \"time\", \"unicode/utf16\", \"unicode/utf8\", \"internal/syscall/windows\", \"internal/syscall/unix\"},\n \t\"internal/testlog\": {\"L0\"},\n \t\"os\":               {\"L1\", \"os\", \"syscall\", \"time\", \"internal/oserror\", \"internal/poll\", \"internal/syscall/windows\", \"internal/syscall/unix\", \"internal/testlog\"},\n \t\"path/filepath\":    {\"L2\", \"os\", \"syscall\", \"internal/syscall/windows\"},"}, {"sha": "a010d3a85ab588a324db1dc0b1b6a010b755ee41", "filename": "libgo/go/go/doc/example.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fgo%2Fdoc%2Fexample.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fgo%2Fdoc%2Fexample.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Fexample.go?ref=0b3c2eed35d608d6541ecf004a9576b4eae0b4ef", "patch": "@@ -62,7 +62,7 @@ func Examples(testFiles ...*ast.File) []*Example {\n \t\t\tif !ok || f.Recv != nil {\n \t\t\t\tcontinue\n \t\t\t}\n-\t\t\tif params := f.Type.Params; params.List != nil {\n+\t\t\tif params := f.Type.Params; len(params.List) != 0 {\n \t\t\t\tcontinue // function has params; not a valid example\n \t\t\t}\n \t\t\tnumDecl++"}, {"sha": "3756303dfbca9327c3b254e398e5777da0fa1d83", "filename": "libgo/go/go/types/builtins.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fgo%2Ftypes%2Fbuiltins.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fgo%2Ftypes%2Fbuiltins.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Fbuiltins.go?ref=0b3c2eed35d608d6541ecf004a9576b4eae0b4ef", "patch": "@@ -559,7 +559,7 @@ func (check *Checker) builtin(x *operand, call *ast.CallExpr, id builtinId) (_ b\n \n \t\tbase := derefStructPtr(x.typ)\n \t\tsel := selx.Sel.Name\n-\t\tobj, index, indirect := check.LookupFieldOrMethod(base, false, check.pkg, sel)\n+\t\tobj, index, indirect := check.lookupFieldOrMethod(base, false, check.pkg, sel)\n \t\tswitch obj.(type) {\n \t\tcase nil:\n \t\t\tcheck.invalidArg(x.pos(), \"%s has no single field %s\", base, sel)"}, {"sha": "689ef8744c446e765bed1ec903b430609bd24f52", "filename": "libgo/go/go/types/call.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fgo%2Ftypes%2Fcall.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fgo%2Ftypes%2Fcall.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Fcall.go?ref=0b3c2eed35d608d6541ecf004a9576b4eae0b4ef", "patch": "@@ -370,7 +370,7 @@ func (check *Checker) selector(x *operand, e *ast.SelectorExpr) {\n \t\tgoto Error\n \t}\n \n-\tobj, index, indirect = check.LookupFieldOrMethod(x.typ, x.mode == variable, check.pkg, sel)\n+\tobj, index, indirect = check.lookupFieldOrMethod(x.typ, x.mode == variable, check.pkg, sel)\n \tif obj == nil {\n \t\tswitch {\n \t\tcase index != nil:"}, {"sha": "342c8baab24f2628662feffc8f8b5f31431abd9c", "filename": "libgo/go/go/types/lookup.go", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fgo%2Ftypes%2Flookup.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fgo%2Ftypes%2Flookup.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypes%2Flookup.go?ref=0b3c2eed35d608d6541ecf004a9576b4eae0b4ef", "patch": "@@ -33,19 +33,19 @@ package types\n //\tthe method's formal receiver base type, nor was the receiver addressable.\n //\n func LookupFieldOrMethod(T Type, addressable bool, pkg *Package, name string) (obj Object, index []int, indirect bool) {\n-\treturn (*Checker)(nil).LookupFieldOrMethod(T, addressable, pkg, name)\n+\treturn (*Checker)(nil).lookupFieldOrMethod(T, addressable, pkg, name)\n }\n \n-// Internal use of Checker.LookupFieldOrMethod: If the obj result is a method\n+// Internal use of Checker.lookupFieldOrMethod: If the obj result is a method\n // associated with a concrete (non-interface) type, the method's signature\n // may not be fully set up. Call Checker.objDecl(obj, nil) before accessing\n // the method's type.\n // TODO(gri) Now that we provide the *Checker, we can probably remove this\n-// caveat by calling Checker.objDecl from LookupFieldOrMethod. Investigate.\n+// caveat by calling Checker.objDecl from lookupFieldOrMethod. Investigate.\n \n-// LookupFieldOrMethod is like the external version but completes interfaces\n+// lookupFieldOrMethod is like the external version but completes interfaces\n // as necessary.\n-func (check *Checker) LookupFieldOrMethod(T Type, addressable bool, pkg *Package, name string) (obj Object, index []int, indirect bool) {\n+func (check *Checker) lookupFieldOrMethod(T Type, addressable bool, pkg *Package, name string) (obj Object, index []int, indirect bool) {\n \t// Methods cannot be associated to a named pointer type\n \t// (spec: \"The type denoted by T is called the receiver base type;\n \t// it must not be a pointer or interface type and it must be declared\n@@ -55,24 +55,24 @@ func (check *Checker) LookupFieldOrMethod(T Type, addressable bool, pkg *Package\n \t// not have found it for T (see also issue 8590).\n \tif t, _ := T.(*Named); t != nil {\n \t\tif p, _ := t.underlying.(*Pointer); p != nil {\n-\t\t\tobj, index, indirect = check.lookupFieldOrMethod(p, false, pkg, name)\n+\t\t\tobj, index, indirect = check.rawLookupFieldOrMethod(p, false, pkg, name)\n \t\t\tif _, ok := obj.(*Func); ok {\n \t\t\t\treturn nil, nil, false\n \t\t\t}\n \t\t\treturn\n \t\t}\n \t}\n \n-\treturn check.lookupFieldOrMethod(T, addressable, pkg, name)\n+\treturn check.rawLookupFieldOrMethod(T, addressable, pkg, name)\n }\n \n // TODO(gri) The named type consolidation and seen maps below must be\n //           indexed by unique keys for a given type. Verify that named\n //           types always have only one representation (even when imported\n //           indirectly via different packages.)\n \n-// lookupFieldOrMethod should only be called by LookupFieldOrMethod and missingMethod.\n-func (check *Checker) lookupFieldOrMethod(T Type, addressable bool, pkg *Package, name string) (obj Object, index []int, indirect bool) {\n+// rawLookupFieldOrMethod should only be called by lookupFieldOrMethod and missingMethod.\n+func (check *Checker) rawLookupFieldOrMethod(T Type, addressable bool, pkg *Package, name string) (obj Object, index []int, indirect bool) {\n \t// WARNING: The code in this function is extremely subtle - do not modify casually!\n \t//          This function and NewMethodSet should be kept in sync.\n \n@@ -297,7 +297,7 @@ func (check *Checker) missingMethod(V Type, T *Interface, static bool) (method *\n \n \t// A concrete type implements T if it implements all methods of T.\n \tfor _, m := range T.allMethods {\n-\t\tobj, _, _ := check.lookupFieldOrMethod(V, false, m.pkg, m.name)\n+\t\tobj, _, _ := check.rawLookupFieldOrMethod(V, false, m.pkg, m.name)\n \n \t\t// we must have a method (not a field of matching function type)\n \t\tf, _ := obj.(*Func)"}, {"sha": "f930f7e5266c6cb31f241d7fc94bad603e562c22", "filename": "libgo/go/golang.org/x/crypto/cryptobyte/asn1.go", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fgolang.org%2Fx%2Fcrypto%2Fcryptobyte%2Fasn1.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fgolang.org%2Fx%2Fcrypto%2Fcryptobyte%2Fasn1.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgolang.org%2Fx%2Fcrypto%2Fcryptobyte%2Fasn1.go?ref=0b3c2eed35d608d6541ecf004a9576b4eae0b4ef", "patch": "@@ -470,7 +470,8 @@ func (s *String) ReadASN1GeneralizedTime(out *time.Time) bool {\n // It reports whether the read was successful.\n func (s *String) ReadASN1BitString(out *encoding_asn1.BitString) bool {\n \tvar bytes String\n-\tif !s.ReadASN1(&bytes, asn1.BIT_STRING) || len(bytes) == 0 {\n+\tif !s.ReadASN1(&bytes, asn1.BIT_STRING) || len(bytes) == 0 ||\n+\t\tlen(bytes)*8/8 != len(bytes) {\n \t\treturn false\n \t}\n \n@@ -740,7 +741,7 @@ func (s *String) readASN1(out *String, outTag *asn1.Tag, skipHeader bool) bool {\n \t\tlength = headerLen + len32\n \t}\n \n-\tif uint32(int(length)) != length || !s.ReadBytes((*[]byte)(out), int(length)) {\n+\tif int(length) < 0 || !s.ReadBytes((*[]byte)(out), int(length)) {\n \t\treturn false\n \t}\n \tif skipHeader && !out.Skip(int(headerLen)) {"}, {"sha": "589d297e6be8f6d5f2a179a02f2216536263efb5", "filename": "libgo/go/golang.org/x/crypto/cryptobyte/string.go", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fgolang.org%2Fx%2Fcrypto%2Fcryptobyte%2Fstring.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fgolang.org%2Fx%2Fcrypto%2Fcryptobyte%2Fstring.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgolang.org%2Fx%2Fcrypto%2Fcryptobyte%2Fstring.go?ref=0b3c2eed35d608d6541ecf004a9576b4eae0b4ef", "patch": "@@ -24,7 +24,7 @@ type String []byte\n // read advances a String by n bytes and returns them. If less than n bytes\n // remain, it returns nil.\n func (s *String) read(n int) []byte {\n-\tif len(*s) < n {\n+\tif len(*s) < n || n < 0 {\n \t\treturn nil\n \t}\n \tv := (*s)[:n]\n@@ -105,11 +105,6 @@ func (s *String) readLengthPrefixed(lenLen int, outChild *String) bool {\n \t\tlength = length << 8\n \t\tlength = length | uint32(b)\n \t}\n-\tif int(length) < 0 {\n-\t\t// This currently cannot overflow because we read uint24 at most, but check\n-\t\t// anyway in case that changes in the future.\n-\t\treturn false\n-\t}\n \tv := s.read(int(length))\n \tif v == nil {\n \t\treturn false"}, {"sha": "32a9cef6bbfff6f8d390417afa7c0c145284e15d", "filename": "libgo/go/golang.org/x/crypto/poly1305/sum_noasm.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fgolang.org%2Fx%2Fcrypto%2Fpoly1305%2Fsum_noasm.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fgolang.org%2Fx%2Fcrypto%2Fpoly1305%2Fsum_noasm.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgolang.org%2Fx%2Fcrypto%2Fpoly1305%2Fsum_noasm.go?ref=0b3c2eed35d608d6541ecf004a9576b4eae0b4ef", "patch": "@@ -2,7 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// +build s390x,!go1.11 !arm,!amd64,!s390x,!ppc64le gccgo appengine nacl\n+// +build s390x,!go1.11 !amd64,!s390x,!ppc64le gccgo appengine nacl\n \n package poly1305\n "}, {"sha": "467d25e689629d4b254a162261e002da80c0e867", "filename": "libgo/go/golang.org/x/mod/sumdb/note/note.go", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fgolang.org%2Fx%2Fmod%2Fsumdb%2Fnote%2Fnote.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fgolang.org%2Fx%2Fmod%2Fsumdb%2Fnote%2Fnote.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgolang.org%2Fx%2Fmod%2Fsumdb%2Fnote%2Fnote.go?ref=0b3c2eed35d608d6541ecf004a9576b4eae0b4ef", "patch": "@@ -4,9 +4,6 @@\n \n // Package note defines the notes signed by the Go module database server.\n //\n-// This package is part of a DRAFT of what the Go module database server will look like.\n-// Do not assume the details here are final!\n-//\n // A note is text signed by one or more server keys.\n // The text should be ignored unless the note is signed by\n // a trusted server key and the signature has been verified"}, {"sha": "18c8a48b9c387c2919652abd58a8d053e84dd5b7", "filename": "libgo/go/golang.org/x/sys/cpu/cpu_riscv64.go", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fgolang.org%2Fx%2Fsys%2Fcpu%2Fcpu_riscv64.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fgolang.org%2Fx%2Fsys%2Fcpu%2Fcpu_riscv64.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgolang.org%2Fx%2Fsys%2Fcpu%2Fcpu_riscv64.go?ref=0b3c2eed35d608d6541ecf004a9576b4eae0b4ef", "patch": "@@ -0,0 +1,7 @@\n+// Copyright 2019 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build riscv64\n+\n+package cpu"}, {"sha": "e6bfe71539183f813649652ef4225c56a55b65d9", "filename": "libgo/go/golang.org/x/tools/go/analysis/passes/asmdecl/asmdecl.go", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fgolang.org%2Fx%2Ftools%2Fgo%2Fanalysis%2Fpasses%2Fasmdecl%2Fasmdecl.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fgolang.org%2Fx%2Ftools%2Fgo%2Fanalysis%2Fpasses%2Fasmdecl%2Fasmdecl.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgolang.org%2Fx%2Ftools%2Fgo%2Fanalysis%2Fpasses%2Fasmdecl%2Fasmdecl.go?ref=0b3c2eed35d608d6541ecf004a9576b4eae0b4ef", "patch": "@@ -87,6 +87,7 @@ var (\n \tasmArchMips64LE = asmArch{name: \"mips64le\", bigEndian: false, stack: \"R29\", lr: true}\n \tasmArchPpc64    = asmArch{name: \"ppc64\", bigEndian: true, stack: \"R1\", lr: true}\n \tasmArchPpc64LE  = asmArch{name: \"ppc64le\", bigEndian: false, stack: \"R1\", lr: true}\n+\tasmArchRISCV64  = asmArch{name: \"riscv64\", bigEndian: false, stack: \"SP\", lr: true}\n \tasmArchS390X    = asmArch{name: \"s390x\", bigEndian: true, stack: \"R15\", lr: true}\n \tasmArchWasm     = asmArch{name: \"wasm\", bigEndian: false, stack: \"SP\", lr: false}\n \n@@ -101,6 +102,7 @@ var (\n \t\t&asmArchMips64LE,\n \t\t&asmArchPpc64,\n \t\t&asmArchPpc64LE,\n+\t\t&asmArchRISCV64,\n \t\t&asmArchS390X,\n \t\t&asmArchWasm,\n \t}"}, {"sha": "1dc12873b0fa9ea5e6727a6d29256b58c23b670d", "filename": "libgo/go/html/escape.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fhtml%2Fescape.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fhtml%2Fescape.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhtml%2Fescape.go?ref=0b3c2eed35d608d6541ecf004a9576b4eae0b4ef", "patch": "@@ -12,7 +12,7 @@ import (\n \n // These replacements permit compatibility with old numeric entities that\n // assumed Windows-1252 encoding.\n-// http://www.whatwg.org/specs/web-apps/current-work/multipage/tokenization.html#consume-a-character-reference\n+// https://html.spec.whatwg.org/multipage/parsing.html#numeric-character-reference-end-state\n var replacementTable = [...]rune{\n \t'\\u20AC', // First entry is what 0x80 should be replaced with.\n \t'\\u0081',"}, {"sha": "120fc1195fe6ec1fc71a7f3550d2dd23f442cda9", "filename": "libgo/go/internal/poll/fcntl_js.go", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Finternal%2Fpoll%2Ffcntl_js.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Finternal%2Fpoll%2Ffcntl_js.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Finternal%2Fpoll%2Ffcntl_js.go?ref=0b3c2eed35d608d6541ecf004a9576b4eae0b4ef", "patch": "@@ -0,0 +1,14 @@\n+// Copyright 2019 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build js,wasm\n+\n+package poll\n+\n+import \"syscall\"\n+\n+// fcntl not supported on js/wasm\n+func fcntl(fd int, cmd int, arg int) (int, error) {\n+\treturn 0, syscall.ENOSYS\n+}"}, {"sha": "ed00f76ce586cb056d3e0b7c69c61bdbb48780b0", "filename": "libgo/go/internal/poll/fcntl_libc.go", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Finternal%2Fpoll%2Ffcntl_libc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Finternal%2Fpoll%2Ffcntl_libc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Finternal%2Fpoll%2Ffcntl_libc.go?ref=0b3c2eed35d608d6541ecf004a9576b4eae0b4ef", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2019 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build aix darwin solaris\n+\n+package poll\n+\n+import (\n+\t\"syscall\"\n+)\n+\n+// Use a helper function to call fcntl.  This is defined in C in\n+// libgo/runtime.\n+//extern __go_fcntl_uintptr\n+func libc_fcntl(uintptr, uintptr, uintptr) (uintptr, uintptr)\n+\n+func fcntl(fd int, cmd int, arg int) (int, error) {\n+\tsyscall.Entersyscall()\n+\tr, e := libc_fcntl(uintptr(fd), uintptr(cmd), uintptr(arg))\n+\tsyscall.Exitsyscall()\n+\tif e != 0 {\n+\t\treturn int(r), syscall.Errno(e)\n+\t}\n+\treturn int(r), nil\n+}"}, {"sha": "d232e51411a9a4899c3abf93ccc4f763ff7fb2d6", "filename": "libgo/go/internal/poll/fcntl_syscall.go", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Finternal%2Fpoll%2Ffcntl_syscall.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Finternal%2Fpoll%2Ffcntl_syscall.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Finternal%2Fpoll%2Ffcntl_syscall.go?ref=0b3c2eed35d608d6541ecf004a9576b4eae0b4ef", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2019 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build dragonfly freebsd linux netbsd openbsd\n+\n+package poll\n+\n+import (\n+\t\"syscall\"\n+)\n+\n+// Use a helper function to call fcntl.  This is defined in C in\n+// libgo/runtime.\n+//extern __go_fcntl_uintptr\n+func libc_fcntl(uintptr, uintptr, uintptr) (uintptr, uintptr)\n+\n+func fcntl(fd int, cmd int, arg int) (int, error) {\n+\tsyscall.Entersyscall()\n+\tr, e := libc_fcntl(uintptr(fd), uintptr(cmd), uintptr(arg))\n+\tsyscall.Exitsyscall()\n+\tif e != 0 {\n+\t\treturn int(r), syscall.Errno(e)\n+\t}\n+\treturn int(r), nil\n+}"}, {"sha": "91751496a413e866626d257a19d399d99ce0deeb", "filename": "libgo/go/internal/poll/fd_fsync_darwin.go", "status": "modified", "additions": 1, "deletions": 19, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Finternal%2Fpoll%2Ffd_fsync_darwin.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Finternal%2Fpoll%2Ffd_fsync_darwin.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Finternal%2Fpoll%2Ffd_fsync_darwin.go?ref=0b3c2eed35d608d6541ecf004a9576b4eae0b4ef", "patch": "@@ -4,10 +4,7 @@\n \n package poll\n \n-import (\n-\t\"syscall\"\n-\t_ \"unsafe\" // for go:linkname\n-)\n+import \"syscall\"\n \n // Fsync invokes SYS_FCNTL with SYS_FULLFSYNC because\n // on OS X, SYS_FSYNC doesn't fully flush contents to disk.\n@@ -21,18 +18,3 @@ func (fd *FD) Fsync() error {\n \t_, e1 := fcntl(fd.Sysfd, syscall.F_FULLFSYNC, 0)\n \treturn e1\n }\n-\n-// Use a helper function to call fcntl.  This is defined in C in\n-// libgo/runtime.\n-//extern __go_fcntl_uintptr\n-func libc_fcntl(uintptr, uintptr, uintptr) (uintptr, uintptr)\n-\n-func fcntl(fd int, cmd int, arg int) (int, error) {\n-\tsyscall.Entersyscall()\n-\tr, e := libc_fcntl(uintptr(fd), uintptr(cmd), uintptr(arg))\n-\tsyscall.Exitsyscall()\n-\tif e != 0 {\n-\t\treturn int(r), syscall.Errno(e)\n-\t}\n-\treturn int(r), nil\n-}"}, {"sha": "dfc8b77e91029ad925a57c09f726a042eb8e1c3f", "filename": "libgo/go/internal/poll/fd_fsync_posix.go", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Finternal%2Fpoll%2Ffd_fsync_posix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Finternal%2Fpoll%2Ffd_fsync_posix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Finternal%2Fpoll%2Ffd_fsync_posix.go?ref=0b3c2eed35d608d6541ecf004a9576b4eae0b4ef", "patch": "@@ -8,11 +8,6 @@ package poll\n \n import \"syscall\"\n \n-// Use a helper function to call fcntl.  This is defined in C in\n-// libgo/runtime.\n-//extern __go_fcntl_uintptr\n-func libc_fcntl(uintptr, uintptr, uintptr) (uintptr, uintptr)\n-\n // Fsync wraps syscall.Fsync.\n func (fd *FD) Fsync() error {\n \tif err := fd.incref(); err != nil {\n@@ -21,13 +16,3 @@ func (fd *FD) Fsync() error {\n \tdefer fd.decref()\n \treturn syscall.Fsync(fd.Sysfd)\n }\n-\n-func fcntl(fd int, cmd int, arg int) (int, error) {\n-\tsyscall.Entersyscall()\n-\tr, e := libc_fcntl(uintptr(fd), uintptr(cmd), uintptr(arg))\n-\tsyscall.Exitsyscall()\n-\tif e != 0 {\n-\t\treturn int(r), syscall.Errno(e)\n-\t}\n-\treturn int(r), nil\n-}"}, {"sha": "213e815a307ddca99d0cbff13c172d9bb6f4644e", "filename": "libgo/go/internal/poll/fd_unix.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Finternal%2Fpoll%2Ffd_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Finternal%2Fpoll%2Ffd_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Finternal%2Fpoll%2Ffd_unix.go?ref=0b3c2eed35d608d6541ecf004a9576b4eae0b4ef", "patch": "@@ -451,7 +451,7 @@ var tryDupCloexec = int32(1)\n \n // DupCloseOnExec dups fd and marks it close-on-exec.\n func DupCloseOnExec(fd int) (int, string, error) {\n-\tif atomic.LoadInt32(&tryDupCloexec) == 1 {\n+\tif syscall.F_DUPFD_CLOEXEC != 0 && atomic.LoadInt32(&tryDupCloexec) == 1 {\n \t\tr0, e1 := fcntl(fd, syscall.F_DUPFD_CLOEXEC, 0)\n \t\tif e1 == nil {\n \t\t\treturn r0, \"\", nil"}, {"sha": "9b39bb240878b2165711f54b052675f8acf4db37", "filename": "libgo/go/internal/syscall/unix/nonblocking.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Finternal%2Fsyscall%2Funix%2Fnonblocking.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Finternal%2Fsyscall%2Funix%2Fnonblocking.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Finternal%2Fsyscall%2Funix%2Fnonblocking.go?ref=0b3c2eed35d608d6541ecf004a9576b4eae0b4ef", "patch": "@@ -2,7 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// +build aix dragonfly freebsd hurd linux netbsd openbsd solaris\n+// +build dragonfly freebsd linux netbsd openbsd\n \n package unix\n "}, {"sha": "464314d31976df61895acce89b5a7ca08d048a75", "filename": "libgo/go/internal/syscall/unix/nonblocking_libc.go", "status": "renamed", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Finternal%2Fsyscall%2Funix%2Fnonblocking_libc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Finternal%2Fsyscall%2Funix%2Fnonblocking_libc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Finternal%2Fsyscall%2Funix%2Fnonblocking_libc.go?ref=0b3c2eed35d608d6541ecf004a9576b4eae0b4ef", "patch": "@@ -2,23 +2,19 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// +build darwin\n+// +build aix darwin solaris\n \n package unix\n \n-import (\n-\t\"syscall\"\n-\t_ \"unsafe\" // for go:linkname\n-)\n+import \"syscall\"\n+\n+//extern __go_fcntl_uintptr\n+func fcntl(uintptr, uintptr, uintptr) (uintptr, uintptr)\n \n func IsNonblock(fd int) (nonblocking bool, err error) {\n-\tflag, e1 := fcntl(fd, syscall.F_GETFL, 0)\n-\tif e1 != nil {\n-\t\treturn false, e1\n+\tflag, e1 := fcntl(uintptr(fd), syscall.F_GETFL, 0)\n+\tif e1 != 0 {\n+\t\treturn false, syscall.Errno(e1)\n \t}\n \treturn flag&syscall.O_NONBLOCK != 0, nil\n }\n-\n-// Implemented in syscall/syscall_darwin.go.\n-//go:linkname fcntl syscall.fcntl\n-func fcntl(fd int, cmd int, arg int) (int, error)", "previous_filename": "libgo/go/internal/syscall/unix/nonblocking_darwin.go"}, {"sha": "2eaab678c9f613b8aed47b70d910d00ecd542973", "filename": "libgo/go/io/example_test.go", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fio%2Fexample_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fio%2Fexample_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fio%2Fexample_test.go?ref=0b3c2eed35d608d6541ecf004a9576b4eae0b4ef", "patch": "@@ -59,7 +59,7 @@ func ExampleCopyN() {\n func ExampleReadAtLeast() {\n \tr := strings.NewReader(\"some io.Reader stream to be read\\n\")\n \n-\tbuf := make([]byte, 33)\n+\tbuf := make([]byte, 14)\n \tif _, err := io.ReadAtLeast(r, buf, 4); err != nil {\n \t\tlog.Fatal(err)\n \t}\n@@ -78,10 +78,9 @@ func ExampleReadAtLeast() {\n \t}\n \n \t// Output:\n-\t// some io.Reader stream to be read\n-\t//\n+\t// some io.Reader\n \t// error: short buffer\n-\t// error: EOF\n+\t// error: unexpected EOF\n }\n \n func ExampleReadFull() {"}, {"sha": "0a139f189dc9d661b07ecf48d29db9dd4ed039a6", "filename": "libgo/go/math/big/arith_decl.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fmath%2Fbig%2Farith_decl.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fmath%2Fbig%2Farith_decl.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmath%2Fbig%2Farith_decl.go?ref=0b3c2eed35d608d6541ecf004a9576b4eae0b4ef", "patch": "@@ -3,7 +3,7 @@\n // license that can be found in the LICENSE file.\n \n // +build ignore\n-// +build !math_big_pure_go\n+// +build !math_big_pure_go,!riscv64\n \n package big\n "}, {"sha": "8853eb68540bd03709429c1392e8a6179c58673d", "filename": "libgo/go/math/big/arith_decl_pure.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fmath%2Fbig%2Farith_decl_pure.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fmath%2Fbig%2Farith_decl_pure.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmath%2Fbig%2Farith_decl_pure.go?ref=0b3c2eed35d608d6541ecf004a9576b4eae0b4ef", "patch": "@@ -2,7 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// -build math_big_pure_go\n+// -build math_big_pure_go riscv64\n \n package big\n "}, {"sha": "bec0a81b20bd94eaf616472312b7514b88939182", "filename": "libgo/go/math/big/int.go", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fmath%2Fbig%2Fint.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fmath%2Fbig%2Fint.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmath%2Fbig%2Fint.go?ref=0b3c2eed35d608d6541ecf004a9576b4eae0b4ef", "patch": "@@ -504,9 +504,14 @@ func (z *Int) Exp(x, y, m *Int) *Int {\n \n // GCD sets z to the greatest common divisor of a and b and returns z.\n // If x or y are not nil, GCD sets their value such that z = a*x + b*y.\n+//\n+// a and b may be positive, zero or negative.\n // Regardless of the signs of a and b, z is always >= 0.\n+//\n // If a == b == 0, GCD sets z = x = y = 0.\n+//\n // If a == 0 and b != 0, GCD sets z = |b|, x = 0, y = sign(b) * 1.\n+//\n // If a != 0 and b == 0, GCD sets z = |a|, x = sign(a) * 1, y = 0.\n func (z *Int) GCD(x, y, a, b *Int) *Int {\n \tif len(a.abs) == 0 || len(b.abs) == 0 {"}, {"sha": "493cdfc6481a68fe1525ec36b093e3b6559f7988", "filename": "libgo/go/net/dial_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fnet%2Fdial_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fnet%2Fdial_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fdial_test.go?ref=0b3c2eed35d608d6541ecf004a9576b4eae0b4ef", "patch": "@@ -174,7 +174,7 @@ func dialClosedPort(t *testing.T) (actual, expected time.Duration) {\n \t}\n \taddr := l.Addr().String()\n \tl.Close()\n-\t// On OpenBSD, interference from TestSelfConnect is mysteriously\n+\t// On OpenBSD, interference from TestTCPSelfConnect is mysteriously\n \t// causing the first attempt to hang for a few seconds, so we throw\n \t// away the first result and keep the second.\n \tfor i := 1; ; i++ {"}, {"sha": "e8f81e829053bd0f567760da16b2708e980229e1", "filename": "libgo/go/net/dnsclient_unix_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fnet%2Fdnsclient_unix_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fnet%2Fdnsclient_unix_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fdnsclient_unix_test.go?ref=0b3c2eed35d608d6541ecf004a9576b4eae0b4ef", "patch": "@@ -173,7 +173,7 @@ func TestAvoidDNSName(t *testing.T) {\n \n \t\t// Without stuff before onion/local, they're fine to\n \t\t// use DNS. With a search path,\n-\t\t// \"onion.vegegtables.com\" can use DNS. Without a\n+\t\t// \"onion.vegetables.com\" can use DNS. Without a\n \t\t// search path (or with a trailing dot), the queries\n \t\t// are just kinda useless, but don't reveal anything\n \t\t// private."}, {"sha": "32d59c09a3c52be726386978852960b3677c45b0", "filename": "libgo/go/net/http/cgi/integration_test.go", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fnet%2Fhttp%2Fcgi%2Fintegration_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fnet%2Fhttp%2Fcgi%2Fintegration_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fcgi%2Fintegration_test.go?ref=0b3c2eed35d608d6541ecf004a9576b4eae0b4ef", "previous_filename": "libgo/go/net/http/cgi/matryoshka_test.go"}, {"sha": "a496f1c0c7534ee45ccd86765dd558fa22c5780c", "filename": "libgo/go/net/http/client.go", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fnet%2Fhttp%2Fclient.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fnet%2Fhttp%2Fclient.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fclient.go?ref=0b3c2eed35d608d6541ecf004a9576b4eae0b4ef", "patch": "@@ -288,10 +288,17 @@ func timeBeforeContextDeadline(t time.Time, ctx context.Context) bool {\n \n // knownRoundTripperImpl reports whether rt is a RoundTripper that's\n // maintained by the Go team and known to implement the latest\n-// optional semantics (notably contexts).\n-func knownRoundTripperImpl(rt RoundTripper) bool {\n-\tswitch rt.(type) {\n-\tcase *Transport, *http2Transport:\n+// optional semantics (notably contexts). The Request is used\n+// to check whether this particular request is using an alternate protocol,\n+// in which case we need to check the RoundTripper for that protocol.\n+func knownRoundTripperImpl(rt RoundTripper, req *Request) bool {\n+\tswitch t := rt.(type) {\n+\tcase *Transport:\n+\t\tif altRT := t.alternateRoundTripper(req); altRT != nil {\n+\t\t\treturn knownRoundTripperImpl(altRT, req)\n+\t\t}\n+\t\treturn true\n+\tcase *http2Transport, http2noDialH2RoundTripper:\n \t\treturn true\n \t}\n \t// There's a very minor chance of a false positive with this.\n@@ -319,7 +326,7 @@ func setRequestCancel(req *Request, rt RoundTripper, deadline time.Time) (stopTi\n \tif deadline.IsZero() {\n \t\treturn nop, alwaysFalse\n \t}\n-\tknownTransport := knownRoundTripperImpl(rt)\n+\tknownTransport := knownRoundTripperImpl(rt, req)\n \toldCtx := req.Context()\n \n \tif req.Cancel == nil && knownTransport {"}, {"sha": "4d6a085f60ae3f38e0f506a7da38117e57c523e3", "filename": "libgo/go/net/http/httputil/reverseproxy.go", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fnet%2Fhttp%2Fhttputil%2Freverseproxy.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fnet%2Fhttp%2Fhttputil%2Freverseproxy.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fhttputil%2Freverseproxy.go?ref=0b3c2eed35d608d6541ecf004a9576b4eae0b4ef", "patch": "@@ -24,6 +24,14 @@ import (\n // ReverseProxy is an HTTP Handler that takes an incoming request and\n // sends it to another server, proxying the response back to the\n // client.\n+//\n+// ReverseProxy automatically sets the client IP as the value of the\n+// X-Forwarded-For header.\n+// If an X-Forwarded-For header already exists, the client IP is\n+// appended to the existing values.\n+// To prevent IP spoofing, be sure to delete any pre-existing\n+// X-Forwarded-For header coming from the client or\n+// an untrusted proxy.\n type ReverseProxy struct {\n \t// Director must be a function which modifies\n \t// the request into a new request to be sent"}, {"sha": "307d93a3b14b3c7464ac1dce9924fbc5cc9c640f", "filename": "libgo/go/net/http/omithttp2.go", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fnet%2Fhttp%2Fomithttp2.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fnet%2Fhttp%2Fomithttp2.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fomithttp2.go?ref=0b3c2eed35d608d6541ecf004a9576b4eae0b4ef", "patch": "@@ -36,6 +36,10 @@ type http2erringRoundTripper struct{}\n \n func (http2erringRoundTripper) RoundTrip(*Request) (*Response, error) { panic(noHTTP2) }\n \n+type http2noDialH2RoundTripper struct{}\n+\n+func (http2noDialH2RoundTripper) RoundTrip(*Request) (*Response, error) { panic(noHTTP2) }\n+\n type http2noDialClientConnPool struct {\n \thttp2clientConnPool http2clientConnPool\n }"}, {"sha": "88fa0939f246e365b5fc2b65465f6b53d4463f50", "filename": "libgo/go/net/http/request.go", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fnet%2Fhttp%2Frequest.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fnet%2Fhttp%2Frequest.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Frequest.go?ref=0b3c2eed35d608d6541ecf004a9576b4eae0b4ef", "patch": "@@ -1223,17 +1223,17 @@ func parsePostForm(r *Request) (vs url.Values, err error) {\n // For all requests, ParseForm parses the raw query from the URL and updates\n // r.Form.\n //\n-// For POST, PUT, and PATCH requests, it also parses the request body as a form\n-// and puts the results into both r.PostForm and r.Form. Request body parameters\n-// take precedence over URL query string values in r.Form.\n+// For POST, PUT, and PATCH requests, it also reads the request body, parses it\n+// as a form and puts the results into both r.PostForm and r.Form. Request body\n+// parameters take precedence over URL query string values in r.Form.\n+//\n+// If the request Body's size has not already been limited by MaxBytesReader,\n+// the size is capped at 10MB.\n //\n // For other HTTP methods, or when the Content-Type is not\n // application/x-www-form-urlencoded, the request Body is not read, and\n // r.PostForm is initialized to a non-nil, empty value.\n //\n-// If the request Body's size has not already been limited by MaxBytesReader,\n-// the size is capped at 10MB.\n-//\n // ParseMultipartForm calls ParseForm automatically.\n // ParseForm is idempotent.\n func (r *Request) ParseForm() error {"}, {"sha": "2e01a07f84fccdbf8ded4873f31ee151a8d2b414", "filename": "libgo/go/net/http/transfer.go", "status": "modified", "additions": 13, "deletions": 112, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fnet%2Fhttp%2Ftransfer.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fnet%2Fhttp%2Ftransfer.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Ftransfer.go?ref=0b3c2eed35d608d6541ecf004a9576b4eae0b4ef", "patch": "@@ -7,7 +7,6 @@ package http\n import (\n \t\"bufio\"\n \t\"bytes\"\n-\t\"compress/gzip\"\n \t\"errors\"\n \t\"fmt\"\n \t\"io\"\n@@ -467,34 +466,6 @@ func suppressedHeaders(status int) []string {\n \treturn nil\n }\n \n-// proxyingReadCloser is a composite type that accepts and proxies\n-// io.Read and io.Close calls to its respective Reader and Closer.\n-//\n-// It is composed of:\n-// a) a top-level reader e.g. the result of decompression\n-// b) a symbolic Closer e.g. the result of decompression, the\n-//    original body and the connection itself.\n-type proxyingReadCloser struct {\n-\tio.Reader\n-\tio.Closer\n-}\n-\n-// multiCloser implements io.Closer and allows a bunch of io.Closer values\n-// to all be closed once.\n-// Example usage is with proxyingReadCloser if we are decompressing a response\n-// body on the fly and would like to close both *gzip.Reader and underlying body.\n-type multiCloser []io.Closer\n-\n-func (mc multiCloser) Close() error {\n-\tvar err error\n-\tfor _, c := range mc {\n-\t\tif err1 := c.Close(); err1 != nil && err == nil {\n-\t\t\terr = err1\n-\t\t}\n-\t}\n-\treturn err\n-}\n-\n // msg is *Request or *Response.\n func readTransfer(msg interface{}, r *bufio.Reader) (err error) {\n \tt := &transferReader{RequestMethod: \"GET\"}\n@@ -572,7 +543,7 @@ func readTransfer(msg interface{}, r *bufio.Reader) (err error) {\n \t// Prepare body reader. ContentLength < 0 means chunked encoding\n \t// or close connection when finished, since multipart is not supported yet\n \tswitch {\n-\tcase chunked(t.TransferEncoding) || implicitlyChunked(t.TransferEncoding):\n+\tcase chunked(t.TransferEncoding):\n \t\tif noResponseBodyExpected(t.RequestMethod) || !bodyAllowedForStatus(t.StatusCode) {\n \t\t\tt.Body = NoBody\n \t\t} else {\n@@ -593,21 +564,6 @@ func readTransfer(msg interface{}, r *bufio.Reader) (err error) {\n \t\t}\n \t}\n \n-\t// Finally if \"gzip\" was one of the requested transfer-encodings,\n-\t// we'll unzip the concatenated body/payload of the request.\n-\t// TODO: As we support more transfer-encodings, extract\n-\t// this code and apply the un-codings in reverse.\n-\tif t.Body != NoBody && gzipped(t.TransferEncoding) {\n-\t\tzr, err := gzip.NewReader(t.Body)\n-\t\tif err != nil {\n-\t\t\treturn fmt.Errorf(\"http: failed to gunzip body: %v\", err)\n-\t\t}\n-\t\tt.Body = &proxyingReadCloser{\n-\t\t\tReader: zr,\n-\t\t\tCloser: multiCloser{zr, t.Body},\n-\t\t}\n-\t}\n-\n \t// Unify output\n \tswitch rr := msg.(type) {\n \tcase *Request:\n@@ -627,41 +583,8 @@ func readTransfer(msg interface{}, r *bufio.Reader) (err error) {\n \treturn nil\n }\n \n-// Checks whether chunked is the last part of the encodings stack\n-func chunked(te []string) bool { return len(te) > 0 && te[len(te)-1] == \"chunked\" }\n-\n-// implicitlyChunked is a helper to check for implicity of chunked, because\n-// RFC 7230 Section 3.3.1 says that the sender MUST apply chunked as the final\n-// payload body to ensure that the message is framed for both the request\n-// and the body. Since \"identity\" is incompatible with any other transformational\n-// encoding cannot co-exist, the presence of \"identity\" will cause implicitlyChunked\n-// to return false.\n-func implicitlyChunked(te []string) bool {\n-\tif len(te) == 0 { // No transfer-encodings passed in, so not implicitly chunked.\n-\t\treturn false\n-\t}\n-\tfor _, tei := range te {\n-\t\tif tei == \"identity\" {\n-\t\t\treturn false\n-\t\t}\n-\t}\n-\treturn true\n-}\n-\n-func isGzipTransferEncoding(tei string) bool {\n-\t// RFC 7230 4.2.3 requests that \"x-gzip\" SHOULD be considered the same as \"gzip\".\n-\treturn tei == \"gzip\" || tei == \"x-gzip\"\n-}\n-\n-// Checks where either of \"gzip\" or \"x-gzip\" are contained in transfer encodings.\n-func gzipped(te []string) bool {\n-\tfor _, tei := range te {\n-\t\tif isGzipTransferEncoding(tei) {\n-\t\t\treturn true\n-\t\t}\n-\t}\n-\treturn false\n-}\n+// Checks whether chunked is part of the encodings stack\n+func chunked(te []string) bool { return len(te) > 0 && te[0] == \"chunked\" }\n \n // Checks whether the encoding is explicitly \"identity\".\n func isIdentity(te []string) bool { return len(te) == 1 && te[0] == \"identity\" }\n@@ -697,47 +620,25 @@ func (t *transferReader) fixTransferEncoding() error {\n \n \tencodings := strings.Split(raw[0], \",\")\n \tte := make([]string, 0, len(encodings))\n-\n-\t// When adding new encodings, please maintain the invariant:\n-\t//   if chunked encoding is present, it must always\n-\t//   come last and it must be applied only once.\n-\t// See RFC 7230 Section 3.3.1 Transfer-Encoding.\n-\tfor i, encoding := range encodings {\n+\t// TODO: Even though we only support \"identity\" and \"chunked\"\n+\t// encodings, the loop below is designed with foresight. One\n+\t// invariant that must be maintained is that, if present,\n+\t// chunked encoding must always come first.\n+\tfor _, encoding := range encodings {\n \t\tencoding = strings.ToLower(strings.TrimSpace(encoding))\n-\n+\t\t// \"identity\" encoding is not recorded\n \t\tif encoding == \"identity\" {\n-\t\t\t// \"identity\" should not be mixed with other transfer-encodings/compressions\n-\t\t\t// because it means \"no compression, no transformation\".\n-\t\t\tif len(encodings) != 1 {\n-\t\t\t\treturn &badStringError{`\"identity\" when present must be the only transfer encoding`, strings.Join(encodings, \",\")}\n-\t\t\t}\n-\t\t\t// \"identity\" is not recorded.\n \t\t\tbreak\n \t\t}\n-\n-\t\tswitch {\n-\t\tcase encoding == \"chunked\":\n-\t\t\t// \"chunked\" MUST ALWAYS be the last\n-\t\t\t// encoding as per the  loop invariant.\n-\t\t\t// That is:\n-\t\t\t//     Invalid: [chunked, gzip]\n-\t\t\t//     Valid:   [gzip, chunked]\n-\t\t\tif i+1 != len(encodings) {\n-\t\t\t\treturn &badStringError{\"chunked must be applied only once, as the last encoding\", strings.Join(encodings, \",\")}\n-\t\t\t}\n-\t\t\t// Supported otherwise.\n-\n-\t\tcase isGzipTransferEncoding(encoding):\n-\t\t\t// Supported\n-\n-\t\tdefault:\n+\t\tif encoding != \"chunked\" {\n \t\t\treturn &unsupportedTEError{fmt.Sprintf(\"unsupported transfer encoding: %q\", encoding)}\n \t\t}\n-\n \t\tte = te[0 : len(te)+1]\n \t\tte[len(te)-1] = encoding\n \t}\n-\n+\tif len(te) > 1 {\n+\t\treturn &badStringError{\"too many transfer encodings\", strings.Join(te, \",\")}\n+\t}\n \tif len(te) > 0 {\n \t\t// RFC 7230 3.3.2 says \"A sender MUST NOT send a\n \t\t// Content-Length header field in any message that"}, {"sha": "65009ee8bf7fd5c9cb97a04e393d194ccc964aa0", "filename": "libgo/go/net/http/transfer_test.go", "status": "modified", "additions": 2, "deletions": 282, "changes": 284, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fnet%2Fhttp%2Ftransfer_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fnet%2Fhttp%2Ftransfer_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Ftransfer_test.go?ref=0b3c2eed35d608d6541ecf004a9576b4eae0b4ef", "patch": "@@ -7,7 +7,6 @@ package http\n import (\n \t\"bufio\"\n \t\"bytes\"\n-\t\"compress/gzip\"\n \t\"crypto/rand\"\n \t\"fmt\"\n \t\"io\"\n@@ -62,6 +61,7 @@ func TestFinalChunkedBodyReadEOF(t *testing.T) {\n \tbuf := make([]byte, len(want))\n \tn, err := res.Body.Read(buf)\n \tif n != len(want) || err != io.EOF {\n+\t\tt.Logf(\"body = %#v\", res.Body)\n \t\tt.Errorf(\"Read = %v, %v; want %d, EOF\", n, err, len(want))\n \t}\n \tif string(buf) != want {\n@@ -290,7 +290,7 @@ func TestFixTransferEncoding(t *testing.T) {\n \t\t},\n \t\t{\n \t\t\thdr:     Header{\"Transfer-Encoding\": {\"chunked, chunked\", \"identity\", \"chunked\"}},\n-\t\t\twantErr: &badStringError{\"chunked must be applied only once, as the last encoding\", \"chunked, chunked\"},\n+\t\t\twantErr: &badStringError{\"too many transfer encodings\", \"chunked,chunked\"},\n \t\t},\n \t\t{\n \t\t\thdr:     Header{\"Transfer-Encoding\": {\"chunked\"}},\n@@ -310,283 +310,3 @@ func TestFixTransferEncoding(t *testing.T) {\n \t\t}\n \t}\n }\n-\n-func gzipIt(s string) string {\n-\tbuf := new(bytes.Buffer)\n-\tgw := gzip.NewWriter(buf)\n-\tgw.Write([]byte(s))\n-\tgw.Close()\n-\treturn buf.String()\n-}\n-\n-func TestUnitTestProxyingReadCloserClosesBody(t *testing.T) {\n-\tvar checker closeChecker\n-\tbuf := new(bytes.Buffer)\n-\tbuf.WriteString(\"Hello, Gophers!\")\n-\tprc := &proxyingReadCloser{\n-\t\tReader: buf,\n-\t\tCloser: &checker,\n-\t}\n-\tprc.Close()\n-\n-\tread, err := ioutil.ReadAll(prc)\n-\tif err != nil {\n-\t\tt.Fatalf(\"Read error: %v\", err)\n-\t}\n-\tif g, w := string(read), \"Hello, Gophers!\"; g != w {\n-\t\tt.Errorf(\"Read mismatch: got %q want %q\", g, w)\n-\t}\n-\n-\tif checker.closed != true {\n-\t\tt.Fatal(\"closeChecker.Close was never invoked\")\n-\t}\n-}\n-\n-func TestGzipTransferEncoding_request(t *testing.T) {\n-\thelloWorldGzipped := gzipIt(\"Hello, World!\")\n-\n-\ttests := []struct {\n-\t\tpayload  string\n-\t\twantErr  string\n-\t\twantBody string\n-\t}{\n-\n-\t\t{\n-\t\t\t// The case of \"chunked\" properly applied as the last encoding\n-\t\t\t// and a gzipped request payload that is streamed in 3 parts.\n-\t\t\tpayload: `POST / HTTP/1.1\n-Host: golang.org\n-Transfer-Encoding: gzip, chunked\n-Content-Type: text/html; charset=UTF-8\n-\n-` + fmt.Sprintf(\"%02x\\r\\n%s\\r\\n%02x\\r\\n%s\\r\\n%02x\\r\\n%s\\r\\n0\\r\\n\\r\\n\",\n-\t\t\t\t3, helloWorldGzipped[:3],\n-\t\t\t\t5, helloWorldGzipped[3:8],\n-\t\t\t\tlen(helloWorldGzipped)-8, helloWorldGzipped[8:]),\n-\t\t\twantBody: `Hello, World!`,\n-\t\t},\n-\n-\t\t{\n-\t\t\t// The request specifies \"Transfer-Encoding: chunked\" so its body must be left untouched.\n-\t\t\tpayload: `PUT / HTTP/1.1\n-Host: golang.org\n-Transfer-Encoding: chunked\n-Connection: close\n-Content-Type: text/html; charset=UTF-8\n-\n-` + fmt.Sprintf(\"%0x\\r\\n%s\\r\\n0\\r\\n\\r\\n\", len(helloWorldGzipped), helloWorldGzipped),\n-\t\t\t// We want that payload as it was sent.\n-\t\t\twantBody: helloWorldGzipped,\n-\t\t},\n-\n-\t\t{\n-\t\t\t// Valid request, the body doesn't have \"Transfer-Encoding: chunked\" but implicitly encoded\n-\t\t\t// for chunking as per the advisory from RFC 7230 3.3.1 which advises for cases where.\n-\t\t\tpayload: `POST / HTTP/1.1\n-Host: localhost\n-Transfer-Encoding: gzip\n-Content-Type: text/html; charset=UTF-8\n-\n-` + fmt.Sprintf(\"%0x\\r\\n%s\\r\\n0\\r\\n\\r\\n\", len(helloWorldGzipped), helloWorldGzipped),\n-\t\t\twantBody: `Hello, World!`,\n-\t\t},\n-\n-\t\t{\n-\t\t\t// Invalid request, the body isn't chunked nor is the connection terminated immediately\n-\t\t\t// hence invalid as per the advisory from RFC 7230 3.3.1 which advises for cases where\n-\t\t\t// a Transfer-Encoding that isn't finally chunked is provided.\n-\t\t\tpayload: `PUT / HTTP/1.1\n-Host: golang.org\n-Transfer-Encoding: gzip\n-Content-Length: 0\n-Connection: close\n-Content-Type: text/html; charset=UTF-8\n-\n-`,\n-\t\t\twantErr: `EOF`,\n-\t\t},\n-\n-\t\t{\n-\t\t\t// The case of chunked applied before another encoding.\n-\t\t\tpayload: `PUT / HTTP/1.1\n-Location: golang.org\n-Transfer-Encoding: chunked, gzip\n-Content-Length: 0\n-Connection: close\n-Content-Type: text/html; charset=UTF-8\n-\n-`,\n-\t\t\twantErr: `chunked must be applied only once, as the last encoding \"chunked, gzip\"`,\n-\t\t},\n-\n-\t\t{\n-\t\t\t// The case of chunked properly applied as the\n-\t\t\t// last encoding BUT with a bad \"Content-Length\".\n-\t\t\tpayload: `POST / HTTP/1.1\n-Host: golang.org\n-Transfer-Encoding: gzip, chunked\n-Content-Length: 10\n-Connection: close\n-Content-Type: text/html; charset=UTF-8\n-\n-` + \"0\\r\\n\\r\\n\",\n-\t\t\twantErr: \"EOF\",\n-\t\t},\n-\t}\n-\n-\tfor i, tt := range tests {\n-\t\treq, err := ReadRequest(bufio.NewReader(strings.NewReader(tt.payload)))\n-\t\tif tt.wantErr != \"\" {\n-\t\t\tif err == nil || !strings.Contains(err.Error(), tt.wantErr) {\n-\t\t\t\tt.Errorf(\"test %d. Error mismatch\\nGot:  %v\\nWant: %s\", i, err, tt.wantErr)\n-\t\t\t}\n-\t\t\tcontinue\n-\t\t}\n-\n-\t\tif err != nil {\n-\t\t\tt.Errorf(\"test %d. Unexpected ReadRequest error: %v\\nPayload:\\n%s\", i, err, tt.payload)\n-\t\t\tcontinue\n-\t\t}\n-\n-\t\tgot, err := ioutil.ReadAll(req.Body)\n-\t\treq.Body.Close()\n-\t\tif err != nil {\n-\t\t\tt.Errorf(\"test %d. Failed to read response body: %v\", i, err)\n-\t\t}\n-\t\tif g, w := string(got), tt.wantBody; g != w {\n-\t\t\tt.Errorf(\"test %d. Request body mimsatch\\nGot:\\n%s\\n\\nWant:\\n%s\", i, g, w)\n-\t\t}\n-\t}\n-}\n-\n-func TestGzipTransferEncoding_response(t *testing.T) {\n-\thelloWorldGzipped := gzipIt(\"Hello, World!\")\n-\n-\ttests := []struct {\n-\t\tpayload  string\n-\t\twantErr  string\n-\t\twantBody string\n-\t}{\n-\n-\t\t{\n-\t\t\t// The case of \"chunked\" properly applied as the last encoding\n-\t\t\t// and a gzipped payload that is streamed in 3 parts.\n-\t\t\tpayload: `HTTP/1.1 302 Found\n-Location: https://golang.org/\n-Transfer-Encoding: gzip, chunked\n-Connection: close\n-Content-Type: text/html; charset=UTF-8\n-\n-` + fmt.Sprintf(\"%02x\\r\\n%s\\r\\n%02x\\r\\n%s\\r\\n%02x\\r\\n%s\\r\\n0\\r\\n\\r\\n\",\n-\t\t\t\t3, helloWorldGzipped[:3],\n-\t\t\t\t5, helloWorldGzipped[3:8],\n-\t\t\t\tlen(helloWorldGzipped)-8, helloWorldGzipped[8:]),\n-\t\t\twantBody: `Hello, World!`,\n-\t\t},\n-\n-\t\t{\n-\t\t\t// The response specifies \"Transfer-Encoding: chunked\" so response body must be left untouched.\n-\t\t\tpayload: `HTTP/1.1 302 Found\n-Location: https://golang.org/\n-Transfer-Encoding: chunked\n-Connection: close\n-Content-Type: text/html; charset=UTF-8\n-\n-` + fmt.Sprintf(\"%0x\\r\\n%s\\r\\n0\\r\\n\\r\\n\", len(helloWorldGzipped), helloWorldGzipped),\n-\t\t\t// We want that payload as it was sent.\n-\t\t\twantBody: helloWorldGzipped,\n-\t\t},\n-\n-\t\t{\n-\t\t\t// Valid response, the body doesn't have \"Transfer-Encoding: chunked\" but implicitly encoded\n-\t\t\t// for chunking as per the advisory from RFC 7230 3.3.1 which advises for cases where.\n-\t\t\tpayload: `HTTP/1.1 302 Found\n-Location: https://golang.org/\n-Transfer-Encoding: gzip\n-Connection: close\n-Content-Type: text/html; charset=UTF-8\n-\n-` + fmt.Sprintf(\"%0x\\r\\n%s\\r\\n0\\r\\n\\r\\n\", len(helloWorldGzipped), helloWorldGzipped),\n-\t\t\twantBody: `Hello, World!`,\n-\t\t},\n-\n-\t\t{\n-\t\t\t// Invalid response, the body isn't chunked nor is the connection terminated immediately\n-\t\t\t// hence invalid as per the advisory from RFC 7230 3.3.1 which advises for cases where\n-\t\t\t// a Transfer-Encoding that isn't finally chunked is provided.\n-\t\t\tpayload: `HTTP/1.1 302 Found\n-Location: https://golang.org/\n-Transfer-Encoding: gzip\n-Content-Length: 0\n-Connection: close\n-Content-Type: text/html; charset=UTF-8\n-\n-`,\n-\t\t\twantErr: `EOF`,\n-\t\t},\n-\n-\t\t{\n-\t\t\t// The case of chunked applied before another encoding.\n-\t\t\tpayload: `HTTP/1.1 302 Found\n-Location: https://golang.org/\n-Transfer-Encoding: chunked, gzip\n-Content-Length: 0\n-Connection: close\n-Content-Type: text/html; charset=UTF-8\n-\n-`,\n-\t\t\twantErr: `chunked must be applied only once, as the last encoding \"chunked, gzip\"`,\n-\t\t},\n-\n-\t\t{\n-\t\t\t// The case of chunked properly applied as the\n-\t\t\t// last encoding BUT with a bad \"Content-Length\".\n-\t\t\tpayload: `HTTP/1.1 302 Found\n-Location: https://golang.org/\n-Transfer-Encoding: gzip, chunked\n-Content-Length: 10\n-Connection: close\n-Content-Type: text/html; charset=UTF-8\n-\n-` + \"0\\r\\n\\r\\n\",\n-\t\t\twantErr: \"EOF\",\n-\t\t},\n-\n-\t\t{\n-\t\t\t// Including \"identity\" more than once.\n-\t\t\tpayload: `HTTP/1.1 200 OK\n-Location: https://golang.org/\n-Transfer-Encoding: identity, identity\n-Content-Length: 0\n-Connection: close\n-Content-Type: text/html; charset=UTF-8\n-\n-` + \"0\\r\\n\\r\\n\",\n-\t\t\twantErr: `\"identity\" when present must be the only transfer encoding \"identity, identity\"`,\n-\t\t},\n-\t}\n-\n-\tfor i, tt := range tests {\n-\t\tres, err := ReadResponse(bufio.NewReader(strings.NewReader(tt.payload)), nil)\n-\t\tif tt.wantErr != \"\" {\n-\t\t\tif err == nil || !strings.Contains(err.Error(), tt.wantErr) {\n-\t\t\t\tt.Errorf(\"test %d. Error mismatch\\nGot:  %v\\nWant: %s\", i, err, tt.wantErr)\n-\t\t\t}\n-\t\t\tcontinue\n-\t\t}\n-\n-\t\tif err != nil {\n-\t\t\tt.Errorf(\"test %d. Unexpected ReadResponse error: %v\\nPayload:\\n%s\", i, err, tt.payload)\n-\t\t\tcontinue\n-\t\t}\n-\n-\t\tgot, err := ioutil.ReadAll(res.Body)\n-\t\tres.Body.Close()\n-\t\tif err != nil {\n-\t\t\tt.Errorf(\"test %d. Failed to read response body: %v\", i, err)\n-\t\t}\n-\t\tif g, w := string(got), tt.wantBody; g != w {\n-\t\t\tt.Errorf(\"test %d. Response body mimsatch\\nGot:\\n%s\\n\\nWant:\\n%s\", i, g, w)\n-\t\t}\n-\t}\n-}"}, {"sha": "d0bfdb412cb834db70238008e1a58d3a5449c6b9", "filename": "libgo/go/net/http/transport.go", "status": "modified", "additions": 18, "deletions": 9, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fnet%2Fhttp%2Ftransport.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fnet%2Fhttp%2Ftransport.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Ftransport.go?ref=0b3c2eed35d608d6541ecf004a9576b4eae0b4ef", "patch": "@@ -469,6 +469,17 @@ func (t *Transport) useRegisteredProtocol(req *Request) bool {\n \treturn true\n }\n \n+// alternateRoundTripper returns the alternate RoundTripper to use\n+// for this request if the Request's URL scheme requires one,\n+// or nil for the normal case of using the Transport.\n+func (t *Transport) alternateRoundTripper(req *Request) RoundTripper {\n+\tif !t.useRegisteredProtocol(req) {\n+\t\treturn nil\n+\t}\n+\taltProto, _ := t.altProto.Load().(map[string]RoundTripper)\n+\treturn altProto[req.URL.Scheme]\n+}\n+\n // roundTrip implements a RoundTripper over HTTP.\n func (t *Transport) roundTrip(req *Request) (*Response, error) {\n \tt.nextProtoOnce.Do(t.onceSetNextProtoDefaults)\n@@ -500,12 +511,9 @@ func (t *Transport) roundTrip(req *Request) (*Response, error) {\n \t\t}\n \t}\n \n-\tif t.useRegisteredProtocol(req) {\n-\t\taltProto, _ := t.altProto.Load().(map[string]RoundTripper)\n-\t\tif altRT := altProto[scheme]; altRT != nil {\n-\t\t\tif resp, err := altRT.RoundTrip(req); err != ErrSkipAltProtocol {\n-\t\t\t\treturn resp, err\n-\t\t\t}\n+\tif altRT := t.alternateRoundTripper(req); altRT != nil {\n+\t\tif resp, err := altRT.RoundTrip(req); err != ErrSkipAltProtocol {\n+\t\t\treturn resp, err\n \t\t}\n \t}\n \tif !isHTTP {\n@@ -1559,15 +1567,16 @@ func (t *Transport) dialConn(ctx context.Context, cm connectMethod) (pconn *pers\n \t\tif hdr == nil {\n \t\t\thdr = make(Header)\n \t\t}\n+\t\tif pa := cm.proxyAuth(); pa != \"\" {\n+\t\t\thdr = hdr.Clone()\n+\t\t\thdr.Set(\"Proxy-Authorization\", pa)\n+\t\t}\n \t\tconnectReq := &Request{\n \t\t\tMethod: \"CONNECT\",\n \t\t\tURL:    &url.URL{Opaque: cm.targetAddr},\n \t\t\tHost:   cm.targetAddr,\n \t\t\tHeader: hdr,\n \t\t}\n-\t\tif pa := cm.proxyAuth(); pa != \"\" {\n-\t\t\tconnectReq.Header.Set(\"Proxy-Authorization\", pa)\n-\t\t}\n \n \t\t// If there's no done channel (no deadline or cancellation\n \t\t// from the caller possible), at least set some (long)"}, {"sha": "1e0334d2eb20a7f3f2b65056dd041e71a671c109", "filename": "libgo/go/net/http/transport_test.go", "status": "modified", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fnet%2Fhttp%2Ftransport_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fnet%2Fhttp%2Ftransport_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Ftransport_test.go?ref=0b3c2eed35d608d6541ecf004a9576b4eae0b4ef", "patch": "@@ -1550,6 +1550,44 @@ func TestTransportDialPreservesNetOpProxyError(t *testing.T) {\n \t}\n }\n \n+// Issue 36431: calls to RoundTrip should not mutate t.ProxyConnectHeader.\n+//\n+// (A bug caused dialConn to instead write the per-request Proxy-Authorization\n+// header through to the shared Header instance, introducing a data race.)\n+func TestTransportProxyDialDoesNotMutateProxyConnectHeader(t *testing.T) {\n+\tsetParallel(t)\n+\tdefer afterTest(t)\n+\n+\tproxy := httptest.NewTLSServer(NotFoundHandler())\n+\tdefer proxy.Close()\n+\tc := proxy.Client()\n+\n+\ttr := c.Transport.(*Transport)\n+\ttr.Proxy = func(*Request) (*url.URL, error) {\n+\t\tu, _ := url.Parse(proxy.URL)\n+\t\tu.User = url.UserPassword(\"aladdin\", \"opensesame\")\n+\t\treturn u, nil\n+\t}\n+\th := tr.ProxyConnectHeader\n+\tif h == nil {\n+\t\th = make(Header)\n+\t}\n+\ttr.ProxyConnectHeader = h.Clone()\n+\n+\treq, err := NewRequest(\"GET\", \"https://golang.fake.tld/\", nil)\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\t_, err = c.Do(req)\n+\tif err == nil {\n+\t\tt.Errorf(\"unexpected Get success\")\n+\t}\n+\n+\tif !reflect.DeepEqual(tr.ProxyConnectHeader, h) {\n+\t\tt.Errorf(\"tr.ProxyConnectHeader = %v; want %v\", tr.ProxyConnectHeader, h)\n+\t}\n+}\n+\n // TestTransportGzipRecursive sends a gzip quine and checks that the\n // client gets the same value back. This is more cute than anything,\n // but checks that we don't recurse forever, and checks that\n@@ -6109,3 +6147,35 @@ func TestTransportDecrementConnWhenIdleConnRemoved(t *testing.T) {\n \t\tt.Errorf(\"error occurred: %v\", err)\n \t}\n }\n+\n+// Issue 36820\n+// Test that we use the older backward compatible cancellation protocol\n+// when a RoundTripper is registered via RegisterProtocol.\n+func TestAltProtoCancellation(t *testing.T) {\n+\tdefer afterTest(t)\n+\ttr := &Transport{}\n+\tc := &Client{\n+\t\tTransport: tr,\n+\t\tTimeout:   time.Millisecond,\n+\t}\n+\ttr.RegisterProtocol(\"timeout\", timeoutProto{})\n+\t_, err := c.Get(\"timeout://bar.com/path\")\n+\tif err == nil {\n+\t\tt.Error(\"request unexpectedly succeeded\")\n+\t} else if !strings.Contains(err.Error(), timeoutProtoErr.Error()) {\n+\t\tt.Errorf(\"got error %q, does not contain expected string %q\", err, timeoutProtoErr)\n+\t}\n+}\n+\n+var timeoutProtoErr = errors.New(\"canceled as expected\")\n+\n+type timeoutProto struct{}\n+\n+func (timeoutProto) RoundTrip(req *Request) (*Response, error) {\n+\tselect {\n+\tcase <-req.Cancel:\n+\t\treturn nil, timeoutProtoErr\n+\tcase <-time.After(5 * time.Second):\n+\t\treturn nil, errors.New(\"request was not canceled\")\n+\t}\n+}"}, {"sha": "2bc5592d5ad730c4c5da39a57d1cc63de5b10887", "filename": "libgo/go/net/lookup_test.go", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fnet%2Flookup_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fnet%2Flookup_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Flookup_test.go?ref=0b3c2eed35d608d6541ecf004a9576b4eae0b4ef", "patch": "@@ -998,12 +998,16 @@ func TestConcurrentPreferGoResolversDial(t *testing.T) {\n \t\t\tdefer wg.Done()\n \t\t\t_, err := r.LookupIPAddr(context.Background(), \"google.com\")\n \t\t\tif err != nil {\n-\t\t\t\tt.Fatalf(\"lookup failed for resolver %d: %q\", index, err)\n+\t\t\t\tt.Errorf(\"lookup failed for resolver %d: %q\", index, err)\n \t\t\t}\n \t\t}(resolver.Resolver, i)\n \t}\n \twg.Wait()\n \n+\tif t.Failed() {\n+\t\tt.FailNow()\n+\t}\n+\n \tfor i, resolver := range resolvers {\n \t\tif !resolver.dialed {\n \t\t\tt.Errorf(\"custom resolver %d not dialed during lookup\", i)\n@@ -1175,12 +1179,9 @@ func TestWithUnexpiredValuesPreserved(t *testing.T) {\n \t}\n }\n \n-// Issue 31586: don't crash on null byte in name\n+// Issue 31597: don't panic on null byte in name\n func TestLookupNullByte(t *testing.T) {\n \ttestenv.MustHaveExternalNetwork(t)\n \ttestenv.SkipFlakyNet(t)\n-\t_, err := LookupHost(\"foo\\x00bar\") // used to crash on Windows\n-\tif err == nil {\n-\t\tt.Errorf(\"unexpected success\")\n-\t}\n+\tLookupHost(\"foo\\x00bar\") // check that it doesn't panic; it used to on Windows\n }"}, {"sha": "1d7e5e7f65253198a2400064cc76ac0597316236", "filename": "libgo/go/net/net.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fnet%2Fnet.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fnet%2Fnet.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fnet.go?ref=0b3c2eed35d608d6541ecf004a9576b4eae0b4ef", "patch": "@@ -452,6 +452,7 @@ type OpError struct {\n \tAddr Addr\n \n \t// Err is the error that occurred during the operation.\n+\t// The Error method panics if the error is nil.\n \tErr error\n }\n "}, {"sha": "9f8c82718bb60c6ba72d4959643edc2160b41ea7", "filename": "libgo/go/os/file.go", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fos%2Ffile.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fos%2Ffile.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Ffile.go?ref=0b3c2eed35d608d6541ecf004a9576b4eae0b4ef", "patch": "@@ -204,6 +204,10 @@ func (f *File) WriteAt(b []byte, off int64) (n int, err error) {\n // relative to the current offset, and 2 means relative to the end.\n // It returns the new offset and an error, if any.\n // The behavior of Seek on a file opened with O_APPEND is not specified.\n+//\n+// If f is a directory, the behavior of Seek varies by operating\n+// system; you can seek to the beginning of the directory on Unix-like\n+// operating systems, but not on Windows.\n func (f *File) Seek(offset int64, whence int) (ret int64, err error) {\n \tif err := f.checkValid(\"seek\"); err != nil {\n \t\treturn 0, err"}, {"sha": "33d02aea8496821acf9dfb4f5cbf31c5f564145b", "filename": "libgo/go/reflect/all_test.go", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Freflect%2Fall_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Freflect%2Fall_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Freflect%2Fall_test.go?ref=0b3c2eed35d608d6541ecf004a9576b4eae0b4ef", "patch": "@@ -4864,6 +4864,9 @@ func TestStructOfExportRules(t *testing.T) {\n \t\t\tif exported != test.exported {\n \t\t\t\tt.Errorf(\"test-%d: got exported=%v want exported=%v\", i, exported, test.exported)\n \t\t\t}\n+\t\t\tif field.PkgPath != test.field.PkgPath {\n+\t\t\t\tt.Errorf(\"test-%d: got PkgPath=%q want pkgPath=%q\", i, field.PkgPath, test.field.PkgPath)\n+\t\t\t}\n \t\t})\n \t}\n }\n@@ -5327,6 +5330,24 @@ func TestStructOfTooManyFields(t *testing.T) {\n \t}\n }\n \n+func TestStructOfDifferentPkgPath(t *testing.T) {\n+\tfields := []StructField{\n+\t\t{\n+\t\t\tName:    \"f1\",\n+\t\t\tPkgPath: \"p1\",\n+\t\t\tType:    TypeOf(int(0)),\n+\t\t},\n+\t\t{\n+\t\t\tName:    \"f2\",\n+\t\t\tPkgPath: \"p2\",\n+\t\t\tType:    TypeOf(int(0)),\n+\t\t},\n+\t}\n+\tshouldPanic(func() {\n+\t\tStructOf(fields)\n+\t})\n+}\n+\n func TestChanOf(t *testing.T) {\n \t// check construction and use of type not in binary\n \ttype T string"}, {"sha": "9c003a43dd94528e6b85da0f753cb82b5324d9a9", "filename": "libgo/go/reflect/type.go", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Freflect%2Ftype.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Freflect%2Ftype.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Freflect%2Ftype.go?ref=0b3c2eed35d608d6541ecf004a9576b4eae0b4ef", "patch": "@@ -1993,6 +1993,7 @@ func StructOf(fields []StructField) Type {\n \n \tlastzero := uintptr(0)\n \trepr = append(repr, \"struct {\"...)\n+\tpkgpath := \"\"\n \tfor i, field := range fields {\n \t\tif field.Name == \"\" {\n \t\t\tpanic(\"reflect.StructOf: field \" + strconv.Itoa(i) + \" has no name\")\n@@ -2003,11 +2004,18 @@ func StructOf(fields []StructField) Type {\n \t\tif field.Type == nil {\n \t\t\tpanic(\"reflect.StructOf: field \" + strconv.Itoa(i) + \" has no type\")\n \t\t}\n-\t\tf := runtimeStructField(field)\n+\t\tf, fpkgpath := runtimeStructField(field)\n \t\tft := f.typ\n \t\tif ft.kind&kindGCProg != 0 {\n \t\t\thasGCProg = true\n \t\t}\n+\t\tif fpkgpath != \"\" {\n+\t\t\tif pkgpath == \"\" {\n+\t\t\t\tpkgpath = fpkgpath\n+\t\t\t} else if pkgpath != fpkgpath {\n+\t\t\t\tpanic(\"reflect.Struct: fields with different PkgPath \" + pkgpath + \" and \" + fpkgpath)\n+\t\t\t}\n+\t\t}\n \n \t\t// Update string and hash\n \t\tname := *f.name\n@@ -2229,7 +2237,10 @@ func StructOf(fields []StructField) Type {\n \treturn addToCache(&typ.rtype)\n }\n \n-func runtimeStructField(field StructField) structField {\n+// runtimeStructField takes a StructField value passed to StructOf and\n+// returns both the corresponding internal representation, of type\n+// structField, and the pkgpath value to use for this field.\n+func runtimeStructField(field StructField) (structField, string) {\n \tif field.Anonymous && field.PkgPath != \"\" {\n \t\tpanic(\"reflect.StructOf: field \\\"\" + field.Name + \"\\\" is anonymous but has PkgPath set\")\n \t}\n@@ -2263,13 +2274,14 @@ func runtimeStructField(field StructField) structField {\n \t\ts := field.PkgPath\n \t\tpkgPath = &s\n \t}\n-\treturn structField{\n+\tf := structField{\n \t\tname:        name,\n \t\tpkgPath:     pkgPath,\n \t\ttyp:         field.Type.common(),\n \t\ttag:         tag,\n \t\toffsetEmbed: offsetEmbed,\n \t}\n+\treturn f, field.PkgPath\n }\n \n // typeptrdata returns the length in bytes of the prefix of t"}, {"sha": "ec8252bb32aa12d11d720db6d37bd04068da9976", "filename": "libgo/go/runtime/chan.go", "status": "modified", "additions": 19, "deletions": 57, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fruntime%2Fchan.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fruntime%2Fchan.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fchan.go?ref=0b3c2eed35d608d6541ecf004a9576b4eae0b4ef", "patch": "@@ -133,21 +133,6 @@ func chanbuf(c *hchan, i uint) unsafe.Pointer {\n \treturn add(c.buf, uintptr(i)*uintptr(c.elemsize))\n }\n \n-// full reports whether a send on c would block (that is, the channel is full).\n-// It uses a single word-sized read of mutable state, so although\n-// the answer is instantaneously true, the correct answer may have changed\n-// by the time the calling function receives the return value.\n-func full(c *hchan) bool {\n-\t// c.dataqsiz is immutable (never written after the channel is created)\n-\t// so it is safe to read at any time during channel operation.\n-\tif c.dataqsiz == 0 {\n-\t\t// Assumes that a pointer read is relaxed-atomic.\n-\t\treturn c.recvq.first == nil\n-\t}\n-\t// Assumes that a uint read is relaxed-atomic.\n-\treturn c.qcount == c.dataqsiz\n-}\n-\n // entry point for c <- x from compiled code\n //go:nosplit\n func chansend1(c *hchan, elem unsafe.Pointer) {\n@@ -192,7 +177,7 @@ func chansend(c *hchan, ep unsafe.Pointer, block bool, callerpc uintptr) bool {\n \t//\n \t// After observing that the channel is not closed, we observe that the channel is\n \t// not ready for sending. Each of these observations is a single word-sized read\n-\t// (first c.closed and second full()).\n+\t// (first c.closed and second c.recvq.first or c.qcount depending on kind of channel).\n \t// Because a closed channel cannot transition from 'ready for sending' to\n \t// 'not ready for sending', even if the channel is closed between the two observations,\n \t// they imply a moment between the two when the channel was both not yet closed\n@@ -201,10 +186,9 @@ func chansend(c *hchan, ep unsafe.Pointer, block bool, callerpc uintptr) bool {\n \t//\n \t// It is okay if the reads are reordered here: if we observe that the channel is not\n \t// ready for sending and then observe that it is not closed, that implies that the\n-\t// channel wasn't closed during the first observation. However, nothing here\n-\t// guarantees forward progress. We rely on the side effects of lock release in\n-\t// chanrecv() and closechan() to update this thread's view of c.closed and full().\n-\tif !block && c.closed == 0 && full(c) {\n+\t// channel wasn't closed during the first observation.\n+\tif !block && c.closed == 0 && ((c.dataqsiz == 0 && c.recvq.first == nil) ||\n+\t\t(c.dataqsiz > 0 && c.qcount == c.dataqsiz)) {\n \t\treturn false\n \t}\n \n@@ -434,16 +418,6 @@ func closechan(c *hchan) {\n \t}\n }\n \n-// empty reports whether a read from c would block (that is, the channel is\n-// empty).  It uses a single atomic read of mutable state.\n-func empty(c *hchan) bool {\n-\t// c.dataqsiz is immutable.\n-\tif c.dataqsiz == 0 {\n-\t\treturn atomic.Loadp(unsafe.Pointer(&c.sendq.first)) == nil\n-\t}\n-\treturn atomic.Loaduint(&c.qcount) == 0\n-}\n-\n // entry points for <- c from compiled code\n //go:nosplit\n func chanrecv1(c *hchan, elem unsafe.Pointer) {\n@@ -484,33 +458,21 @@ func chanrecv(c *hchan, ep unsafe.Pointer, block bool) (selected, received bool)\n \t}\n \n \t// Fast path: check for failed non-blocking operation without acquiring the lock.\n-\tif !block && empty(c) {\n-\t\t// After observing that the channel is not ready for receiving, we observe whether the\n-\t\t// channel is closed.\n-\t\t//\n-\t\t// Reordering of these checks could lead to incorrect behavior when racing with a close.\n-\t\t// For example, if the channel was open and not empty, was closed, and then drained,\n-\t\t// reordered reads could incorrectly indicate \"open and empty\". To prevent reordering,\n-\t\t// we use atomic loads for both checks, and rely on emptying and closing to happen in\n-\t\t// separate critical sections under the same lock.  This assumption fails when closing\n-\t\t// an unbuffered channel with a blocked send, but that is an error condition anyway.\n-\t\tif atomic.Load(&c.closed) == 0 {\n-\t\t\t// Because a channel cannot be reopened, the later observation of the channel\n-\t\t\t// being not closed implies that it was also not closed at the moment of the\n-\t\t\t// first observation. We behave as if we observed the channel at that moment\n-\t\t\t// and report that the receive cannot proceed.\n-\t\t\treturn\n-\t\t}\n-\t\t// The channel is irreversibly closed. Re-check whether the channel has any pending data\n-\t\t// to receive, which could have arrived between the empty and closed checks above.\n-\t\t// Sequential consistency is also required here, when racing with such a send.\n-\t\tif empty(c) {\n-\t\t\t// The channel is irreversibly closed and empty.\n-\t\t\tif ep != nil {\n-\t\t\t\ttypedmemclr(c.elemtype, ep)\n-\t\t\t}\n-\t\t\treturn true, false\n-\t\t}\n+\t//\n+\t// After observing that the channel is not ready for receiving, we observe that the\n+\t// channel is not closed. Each of these observations is a single word-sized read\n+\t// (first c.sendq.first or c.qcount, and second c.closed).\n+\t// Because a channel cannot be reopened, the later observation of the channel\n+\t// being not closed implies that it was also not closed at the moment of the\n+\t// first observation. We behave as if we observed the channel at that moment\n+\t// and report that the receive cannot proceed.\n+\t//\n+\t// The order of operations is important here: reversing the operations can lead to\n+\t// incorrect behavior when racing with a close.\n+\tif !block && (c.dataqsiz == 0 && c.sendq.first == nil ||\n+\t\tc.dataqsiz > 0 && atomic.Loaduint(&c.qcount) == 0) &&\n+\t\tatomic.Load(&c.closed) == 0 {\n+\t\treturn\n \t}\n \n \tvar t0 int64"}, {"sha": "c194781ede9894f4c7b13b64e4300ea3036cef5d", "filename": "libgo/go/runtime/chan_test.go", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fruntime%2Fchan_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fruntime%2Fchan_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fchan_test.go?ref=0b3c2eed35d608d6541ecf004a9576b4eae0b4ef", "patch": "@@ -1132,20 +1132,6 @@ func BenchmarkChanPopular(b *testing.B) {\n \twg.Wait()\n }\n \n-func BenchmarkChanClosed(b *testing.B) {\n-\tc := make(chan struct{})\n-\tclose(c)\n-\tb.RunParallel(func(pb *testing.PB) {\n-\t\tfor pb.Next() {\n-\t\t\tselect {\n-\t\t\tcase <-c:\n-\t\t\tdefault:\n-\t\t\t\tb.Error(\"Unreachable\")\n-\t\t\t}\n-\t\t}\n-\t})\n-}\n-\n var (\n \talwaysFalse = false\n \tworkSink    = 0"}, {"sha": "974f0a060b76f382156aa43a7c1091665af208ac", "filename": "libgo/go/runtime/checkptr.go", "status": "modified", "additions": 4, "deletions": 27, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fruntime%2Fcheckptr.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fruntime%2Fcheckptr.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fcheckptr.go?ref=0b3c2eed35d608d6541ecf004a9576b4eae0b4ef", "patch": "@@ -8,45 +8,22 @@ package runtime\n \n import \"unsafe\"\n \n-type ptrAlignError struct {\n-\tptr  unsafe.Pointer\n-\telem *_type\n-\tn    uintptr\n-}\n-\n-func (e ptrAlignError) RuntimeError() {}\n-\n-func (e ptrAlignError) Error() string {\n-\treturn \"runtime error: unsafe pointer conversion\"\n-}\n-\n func checkptrAlignment(p unsafe.Pointer, elem *_type, n uintptr) {\n \t// Check that (*[n]elem)(p) is appropriately aligned.\n \t// TODO(mdempsky): What about fieldAlign?\n \tif uintptr(p)&(uintptr(elem.align)-1) != 0 {\n-\t\tpanic(ptrAlignError{p, elem, n})\n+\t\tthrow(\"checkptr: unsafe pointer conversion\")\n \t}\n \n \t// Check that (*[n]elem)(p) doesn't straddle multiple heap objects.\n \tif size := n * elem.size; size > 1 && checkptrBase(p) != checkptrBase(add(p, size-1)) {\n-\t\tpanic(ptrAlignError{p, elem, n})\n+\t\tthrow(\"checkptr: unsafe pointer conversion\")\n \t}\n }\n \n-type ptrArithError struct {\n-\tptr       unsafe.Pointer\n-\toriginals []unsafe.Pointer\n-}\n-\n-func (e ptrArithError) RuntimeError() {}\n-\n-func (e ptrArithError) Error() string {\n-\treturn \"runtime error: unsafe pointer arithmetic\"\n-}\n-\n func checkptrArithmetic(p unsafe.Pointer, originals []unsafe.Pointer) {\n \tif 0 < uintptr(p) && uintptr(p) < minLegalPointer {\n-\t\tpanic(ptrArithError{p, originals})\n+\t\tthrow(\"checkptr: unsafe pointer arithmetic\")\n \t}\n \n \t// Check that if the computed pointer p points into a heap\n@@ -63,7 +40,7 @@ func checkptrArithmetic(p unsafe.Pointer, originals []unsafe.Pointer) {\n \t\t}\n \t}\n \n-\tpanic(ptrArithError{p, originals})\n+\tthrow(\"checkptr: unsafe pointer arithmetic\")\n }\n \n // checkptrBase returns the base address for the allocation containing"}, {"sha": "ab3058f7336784606cfb30aebe739532d22f5c62", "filename": "libgo/go/runtime/checkptr_test.go", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fruntime%2Fcheckptr_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fruntime%2Fcheckptr_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fcheckptr_test.go?ref=0b3c2eed35d608d6541ecf004a9576b4eae0b4ef", "patch": "@@ -0,0 +1,50 @@\n+// Copyright 2020 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package runtime_test\n+\n+import (\n+\t\"internal/testenv\"\n+\t\"os/exec\"\n+\t\"runtime\"\n+\t\"strings\"\n+\t\"testing\"\n+)\n+\n+func TestCheckPtr(t *testing.T) {\n+\tif runtime.Compiler == \"gccgo\" {\n+\t\tt.Skip(\"gccgo does not have -d=checkptr\")\n+\t}\n+\tt.Parallel()\n+\ttestenv.MustHaveGoRun(t)\n+\n+\texe, err := buildTestProg(t, \"testprog\", \"-gcflags=all=-d=checkptr=1\")\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\n+\ttestCases := []struct {\n+\t\tcmd  string\n+\t\twant string\n+\t}{\n+\t\t{\"CheckPtrAlignment\", \"fatal error: checkptr: unsafe pointer conversion\\n\"},\n+\t\t{\"CheckPtrArithmetic\", \"fatal error: checkptr: unsafe pointer arithmetic\\n\"},\n+\t\t{\"CheckPtrSize\", \"fatal error: checkptr: unsafe pointer conversion\\n\"},\n+\t\t{\"CheckPtrSmall\", \"fatal error: checkptr: unsafe pointer arithmetic\\n\"},\n+\t}\n+\n+\tfor _, tc := range testCases {\n+\t\ttc := tc\n+\t\tt.Run(tc.cmd, func(t *testing.T) {\n+\t\t\tt.Parallel()\n+\t\t\tgot, err := testenv.CleanCmdEnv(exec.Command(exe, tc.cmd)).CombinedOutput()\n+\t\t\tif err != nil {\n+\t\t\t\tt.Log(err)\n+\t\t\t}\n+\t\t\tif !strings.HasPrefix(string(got), tc.want) {\n+\t\t\t\tt.Errorf(\"output:\\n%s\\n\\nwant output starting with: %s\", got, tc.want)\n+\t\t\t}\n+\t\t})\n+\t}\n+}"}, {"sha": "e480466b4d571dbd9f0d62ec9087b261e6603ceb", "filename": "libgo/go/runtime/debug.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fruntime%2Fdebug.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fruntime%2Fdebug.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fdebug.go?ref=0b3c2eed35d608d6541ecf004a9576b4eae0b4ef", "patch": "@@ -26,12 +26,12 @@ func GOMAXPROCS(n int) int {\n \t\treturn ret\n \t}\n \n-\tstopTheWorldGC(\"GOMAXPROCS\")\n+\tstopTheWorld(\"GOMAXPROCS\")\n \n \t// newprocs will be processed by startTheWorld\n \tnewprocs = int32(n)\n \n-\tstartTheWorldGC()\n+\tstartTheWorld()\n \treturn ret\n }\n "}, {"sha": "b60c19bbcec8b49c64ff3f8d5884a4de466fe773", "filename": "libgo/go/runtime/export_test.go", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fruntime%2Fexport_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fruntime%2Fexport_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fexport_test.go?ref=0b3c2eed35d608d6541ecf004a9576b4eae0b4ef", "patch": "@@ -45,6 +45,9 @@ var NetpollGenericInit = netpollGenericInit\n \n var ParseRelease = parseRelease\n \n+var Memmove = memmove\n+var MemclrNoHeapPointers = memclrNoHeapPointers\n+\n const PreemptMSupported = preemptMSupported\n \n type LFNode struct {\n@@ -573,6 +576,7 @@ const (\n \tPageSize         = pageSize\n \tPallocChunkPages = pallocChunkPages\n \tPageAlloc64Bit   = pageAlloc64Bit\n+\tPallocSumBytes   = pallocSumBytes\n )\n \n // Expose pallocSum for testing."}, {"sha": "96af6063f82806ec89d8e60553179beda8357b15", "filename": "libgo/go/runtime/extern.go", "status": "modified", "additions": 13, "deletions": 15, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fruntime%2Fextern.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fruntime%2Fextern.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fextern.go?ref=0b3c2eed35d608d6541ecf004a9576b4eae0b4ef", "patch": "@@ -78,21 +78,6 @@ It is a comma-separated list of name=val pairs setting these named variables:\n \tIf the line ends with \"(forced)\", this GC was forced by a\n \truntime.GC() call.\n \n-\tSetting gctrace to any value > 0 also causes the garbage collector\n-\tto emit a summary when memory is released back to the system.\n-\tThis process of returning memory to the system is called scavenging.\n-\tThe format of this summary is subject to change.\n-\tCurrently it is:\n-\t\tscvg#: # MB released  printed only if non-zero\n-\t\tscvg#: inuse: # idle: # sys: # released: # consumed: # (MB)\n-\twhere the fields are as follows:\n-\t\tscvg#        the scavenge cycle number, incremented at each scavenge\n-\t\tinuse: #     MB used or partially used spans\n-\t\tidle: #      MB spans pending scavenging\n-\t\tsys: #       MB mapped from the system\n-\t\treleased: #  MB released to the system\n-\t\tconsumed: #  MB allocated from the system\n-\n \tmadvdontneed: setting madvdontneed=1 will use MADV_DONTNEED\n \tinstead of MADV_FREE on Linux when returning memory to the\n \tkernel. This is less efficient, but causes RSS numbers to drop\n@@ -112,6 +97,19 @@ It is a comma-separated list of name=val pairs setting these named variables:\n \n \tscavenge: scavenge=1 enables debugging mode of heap scavenger.\n \n+\tscavtrace: setting scavtrace=1 causes the runtime to emit a single line to standard\n+\terror, roughly once per GC cycle, summarizing the amount of work done by the\n+\tscavenger as well as the total amount of memory returned to the operating system\n+\tand an estimate of physical memory utilization. The format of this line is subject\n+\tto change, but currently it is:\n+\t\tscav # KiB work, # KiB total, #% util\n+\twhere the fields are as follows:\n+\t\t# KiB work   the amount of memory returned to the OS since the last scav line\n+\t\t# KiB total  how much of the heap at this point in time has been released to the OS\n+\t\t#% util      the fraction of all unscavenged memory which is in-use\n+\tIf the line ends with \"(forced)\", then scavenging was forced by a\n+\tdebug.FreeOSMemory() call.\n+\n \tscheddetail: setting schedtrace=X and scheddetail=1 causes the scheduler to emit\n \tdetailed multiline info every X milliseconds, describing state of the scheduler,\n \tprocessors, threads and goroutines."}, {"sha": "ddbe5dd5feadd5bba698a8ef9e54a6c7970fef2d", "filename": "libgo/go/runtime/gcinfo_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fruntime%2Fgcinfo_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fruntime%2Fgcinfo_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fgcinfo_test.go?ref=0b3c2eed35d608d6541ecf004a9576b4eae0b4ef", "patch": "@@ -165,7 +165,7 @@ func infoBigStruct() []byte {\n \t\t\ttypeScalar, typeScalar, typeScalar, typeScalar, // t int; y uint16; u uint64\n \t\t\ttypePointer, typeScalar, // i string\n \t\t}\n-\tcase \"arm64\", \"amd64\", \"mips64\", \"mips64le\", \"ppc64\", \"ppc64le\", \"s390x\", \"wasm\":\n+\tcase \"arm64\", \"amd64\", \"mips64\", \"mips64le\", \"ppc64\", \"ppc64le\", \"riscv64\", \"s390x\", \"wasm\":\n \t\treturn []byte{\n \t\t\ttypePointer,                        // q *int\n \t\t\ttypeScalar, typeScalar, typeScalar, // w byte; e [17]byte"}, {"sha": "704bbe6f62bc9a6a79df8be630f7c3e2ff10a73d", "filename": "libgo/go/runtime/hash64.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fruntime%2Fhash64.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fruntime%2Fhash64.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fhash64.go?ref=0b3c2eed35d608d6541ecf004a9576b4eae0b4ef", "patch": "@@ -6,7 +6,7 @@\n //   xxhash: https://code.google.com/p/xxhash/\n // cityhash: https://code.google.com/p/cityhash/\n \n-// +build amd64 amd64p32 arm64 mips64 mips64le ppc64 ppc64le s390x wasm alpha arm64be ia64 mips64p32 mips64p32le sparc64 riscv64\n+// +build amd64 arm64 mips64 mips64le ppc64 ppc64le riscv64 s390x wasm alpha amd64p32 arm64be ia64 mips64p32 mips64p32le sparc64\n \n package runtime\n "}, {"sha": "af9e7d164b93eeec575edd6de54a3ea56388a931", "filename": "libgo/go/runtime/lfstack_64bit.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fruntime%2Flfstack_64bit.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fruntime%2Flfstack_64bit.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Flfstack_64bit.go?ref=0b3c2eed35d608d6541ecf004a9576b4eae0b4ef", "patch": "@@ -2,7 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// +build amd64 arm64 mips64 mips64le ppc64 ppc64le s390x wasm arm64be alpha sparc64 ia64 riscv64\n+// +build amd64 arm64 mips64 mips64le ppc64 ppc64le riscv64 s390x wasm arm64be alpha sparc64 ia64\n \n package runtime\n "}, {"sha": "35ace7f073da87af6caaf7561493c500ba5087ac", "filename": "libgo/go/runtime/malloc.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fruntime%2Fmalloc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fruntime%2Fmalloc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fmalloc.go?ref=0b3c2eed35d608d6541ecf004a9576b4eae0b4ef", "patch": "@@ -513,6 +513,7 @@ func mallocinit() {\n \t\t// allocation at 0x40 << 32 because when using 4k pages with 3-level\n \t\t// translation buffers, the user address space is limited to 39 bits\n \t\t// On darwin/arm64, the address space is even smaller.\n+\t\t//\n \t\t// On AIX, mmaps starts at 0x0A00000000000000 for 64-bit.\n \t\t// processes.\n \t\tfor i := 0x7f; i >= 0; i-- {"}, {"sha": "45555eeebc8ea3b73fd1e6285797a863817f4fca", "filename": "libgo/go/runtime/malloc_test.go", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fruntime%2Fmalloc_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fruntime%2Fmalloc_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fmalloc_test.go?ref=0b3c2eed35d608d6541ecf004a9576b4eae0b4ef", "patch": "@@ -206,14 +206,6 @@ type acLink struct {\n var arenaCollisionSink []*acLink\n \n func TestArenaCollision(t *testing.T) {\n-\tif GOOS == \"darwin\" && race.Enabled {\n-\t\t// Skip this test on Darwin in race mode because Darwin 10.10 has\n-\t\t// issues following arena hints and runs out of them in race mode, so\n-\t\t// MAP_FIXED is used to ensure we keep the heap in the memory region the\n-\t\t// race detector expects.\n-\t\t// TODO(mknyszek): Delete this when Darwin 10.10 is no longer supported.\n-\t\tt.Skip(\"disabled on Darwin with race mode since MAP_FIXED is used\")\n-\t}\n \ttestenv.MustHaveExec(t)\n \n \t// Test that mheap.sysAlloc handles collisions with other"}, {"sha": "396c1304c56c397921c63e68f1fadf718d0b2df9", "filename": "libgo/go/runtime/memmove_test.go", "status": "modified", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fruntime%2Fmemmove_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fruntime%2Fmemmove_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fmemmove_test.go?ref=0b3c2eed35d608d6541ecf004a9576b4eae0b4ef", "patch": "@@ -11,7 +11,9 @@ import (\n \t\"internal/race\"\n \t\"internal/testenv\"\n \t. \"runtime\"\n+\t\"sync/atomic\"\n \t\"testing\"\n+\t\"unsafe\"\n )\n \n func TestMemmove(t *testing.T) {\n@@ -206,6 +208,71 @@ func cmpb(a, b []byte) int {\n \treturn l\n }\n \n+// Ensure that memmove writes pointers atomically, so the GC won't\n+// observe a partially updated pointer.\n+func TestMemmoveAtomicity(t *testing.T) {\n+\tif race.Enabled {\n+\t\tt.Skip(\"skip under the race detector -- this test is intentionally racy\")\n+\t}\n+\n+\tvar x int\n+\n+\tfor _, backward := range []bool{true, false} {\n+\t\tfor _, n := range []int{3, 4, 5, 6, 7, 8, 9, 10, 15, 25, 49} {\n+\t\t\tn := n\n+\n+\t\t\t// test copying [N]*int.\n+\t\t\tsz := uintptr(n * PtrSize)\n+\t\t\tname := fmt.Sprint(sz)\n+\t\t\tif backward {\n+\t\t\t\tname += \"-backward\"\n+\t\t\t} else {\n+\t\t\t\tname += \"-forward\"\n+\t\t\t}\n+\t\t\tt.Run(name, func(t *testing.T) {\n+\t\t\t\t// Use overlapping src and dst to force forward/backward copy.\n+\t\t\t\tvar s [100]*int\n+\t\t\t\tsrc := s[n-1 : 2*n-1]\n+\t\t\t\tdst := s[:n]\n+\t\t\t\tif backward {\n+\t\t\t\t\tsrc, dst = dst, src\n+\t\t\t\t}\n+\t\t\t\tfor i := range src {\n+\t\t\t\t\tsrc[i] = &x\n+\t\t\t\t}\n+\t\t\t\tfor i := range dst {\n+\t\t\t\t\tdst[i] = nil\n+\t\t\t\t}\n+\n+\t\t\t\tvar ready uint32\n+\t\t\t\tgo func() {\n+\t\t\t\t\tsp := unsafe.Pointer(&src[0])\n+\t\t\t\t\tdp := unsafe.Pointer(&dst[0])\n+\t\t\t\t\tatomic.StoreUint32(&ready, 1)\n+\t\t\t\t\tfor i := 0; i < 10000; i++ {\n+\t\t\t\t\t\tMemmove(dp, sp, sz)\n+\t\t\t\t\t\tMemclrNoHeapPointers(dp, sz)\n+\t\t\t\t\t}\n+\t\t\t\t\tatomic.StoreUint32(&ready, 2)\n+\t\t\t\t}()\n+\n+\t\t\t\tfor atomic.LoadUint32(&ready) == 0 {\n+\t\t\t\t\tGosched()\n+\t\t\t\t}\n+\n+\t\t\t\tfor atomic.LoadUint32(&ready) != 2 {\n+\t\t\t\t\tfor i := range dst {\n+\t\t\t\t\t\tp := dst[i]\n+\t\t\t\t\t\tif p != nil && p != &x {\n+\t\t\t\t\t\t\tt.Fatalf(\"got partially updated pointer %p at dst[%d], want either nil or %p\", p, i, &x)\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t})\n+\t\t}\n+\t}\n+}\n+\n func benchmarkSizes(b *testing.B, sizes []int, fn func(b *testing.B, n int)) {\n \tfor _, n := range sizes {\n \t\tb.Run(fmt.Sprint(n), func(b *testing.B) {"}, {"sha": "8ded306ae6b9f1960f34e9a9d411557aaf46dbe8", "filename": "libgo/go/runtime/mgc.go", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fruntime%2Fmgc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fruntime%2Fmgc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fmgc.go?ref=0b3c2eed35d608d6541ecf004a9576b4eae0b4ef", "patch": "@@ -1271,7 +1271,6 @@ func gcStart(trigger gcTrigger) {\n \t}\n \n \t// Ok, we're doing it! Stop everybody else\n-\tsemacquire(&gcsema)\n \tsemacquire(&worldsema)\n \n \tif trace.enabled {\n@@ -1370,13 +1369,6 @@ func gcStart(trigger gcTrigger) {\n \t\twork.pauseNS += now - work.pauseStart\n \t\twork.tMark = now\n \t})\n-\n-\t// Release the world sema before Gosched() in STW mode\n-\t// because we will need to reacquire it later but before\n-\t// this goroutine becomes runnable again, and we could\n-\t// self-deadlock otherwise.\n-\tsemrelease(&worldsema)\n-\n \t// In STW mode, we could block the instant systemstack\n \t// returns, so don't do anything important here. Make sure we\n \t// block rather than returning to user code.\n@@ -1446,10 +1438,6 @@ top:\n \t\treturn\n \t}\n \n-\t// forEachP needs worldsema to execute, and we'll need it to\n-\t// stop the world later, so acquire worldsema now.\n-\tsemacquire(&worldsema)\n-\n \t// Flush all local buffers and collect flushedWork flags.\n \tgcMarkDoneFlushed = 0\n \tsystemstack(func() {\n@@ -1510,7 +1498,6 @@ top:\n \t\t// work to do. Keep going. It's possible the\n \t\t// transition condition became true again during the\n \t\t// ragged barrier, so re-check it.\n-\t\tsemrelease(&worldsema)\n \t\tgoto top\n \t}\n \n@@ -1587,7 +1574,6 @@ top:\n \t\t\t\tnow := startTheWorldWithSema(true)\n \t\t\t\twork.pauseNS += now - work.pauseStart\n \t\t\t})\n-\t\t\tsemrelease(&worldsema)\n \t\t\tgoto top\n \t\t}\n \t}\n@@ -1802,7 +1788,6 @@ func gcMarkTermination(nextTriggerRatio float64) {\n \t}\n \n \tsemrelease(&worldsema)\n-\tsemrelease(&gcsema)\n \t// Careful: another GC cycle may start now.\n \n \treleasem(mp)"}, {"sha": "3b60b3d51fde8c8ebec00f7e6d3da6320a9fcf69", "filename": "libgo/go/runtime/mgcscavenge.go", "status": "modified", "additions": 55, "deletions": 12, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fruntime%2Fmgcscavenge.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fruntime%2Fmgcscavenge.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fmgcscavenge.go?ref=0b3c2eed35d608d6541ecf004a9576b4eae0b4ef", "patch": "@@ -80,6 +80,17 @@ const (\n \t// maxPagesPerPhysPage is the maximum number of supported runtime pages per\n \t// physical page, based on maxPhysPageSize.\n \tmaxPagesPerPhysPage = maxPhysPageSize / pageSize\n+\n+\t// scavengeCostRatio is the approximate ratio between the costs of using previously\n+\t// scavenged memory and scavenging memory.\n+\t//\n+\t// For most systems the cost of scavenging greatly outweighs the costs\n+\t// associated with using scavenged memory, making this constant 0. On other systems\n+\t// (especially ones where \"sysUsed\" is not just a no-op) this cost is non-trivial.\n+\t//\n+\t// This ratio is used as part of multiplicative factor to help the scavenger account\n+\t// for the additional costs of using scavenged memory in its pacing.\n+\tscavengeCostRatio = 0.7 * sys.GoosDarwin\n )\n \n // heapRetained returns an estimate of the current heap RSS.\n@@ -248,7 +259,7 @@ func bgscavenge(c chan int) {\n \t\treleased := uintptr(0)\n \n \t\t// Time in scavenging critical section.\n-\t\tcrit := int64(0)\n+\t\tcrit := float64(0)\n \n \t\t// Run on the system stack since we grab the heap lock,\n \t\t// and a stack growth with the heap lock means a deadlock.\n@@ -266,23 +277,25 @@ func bgscavenge(c chan int) {\n \t\t\t// Scavenge one page, and measure the amount of time spent scavenging.\n \t\t\tstart := nanotime()\n \t\t\treleased = mheap_.pages.scavengeOne(physPageSize, false)\n-\t\t\tcrit = nanotime() - start\n+\t\t\tatomic.Xadduintptr(&mheap_.pages.scavReleased, released)\n+\t\t\tcrit = float64(nanotime() - start)\n \t\t})\n \n-\t\tif debug.gctrace > 0 {\n-\t\t\tif released > 0 {\n-\t\t\t\tprint(\"scvg: \", released>>10, \" KB released\\n\")\n-\t\t\t}\n-\t\t\tprint(\"scvg: inuse: \", memstats.heap_inuse>>20, \", idle: \", memstats.heap_idle>>20, \", sys: \", memstats.heap_sys>>20, \", released: \", memstats.heap_released>>20, \", consumed: \", (memstats.heap_sys-memstats.heap_released)>>20, \" (MB)\\n\")\n-\t\t}\n-\n \t\tif released == 0 {\n \t\t\tlock(&scavenge.lock)\n \t\t\tscavenge.parked = true\n \t\t\tgoparkunlock(&scavenge.lock, waitReasonGCScavengeWait, traceEvGoBlock, 1)\n \t\t\tcontinue\n \t\t}\n \n+\t\t// Multiply the critical time by 1 + the ratio of the costs of using\n+\t\t// scavenged memory vs. scavenging memory. This forces us to pay down\n+\t\t// the cost of reusing this memory eagerly by sleeping for a longer period\n+\t\t// of time and scavenging less frequently. More concretely, we avoid situations\n+\t\t// where we end up scavenging so often that we hurt allocation performance\n+\t\t// because of the additional overheads of using scavenged memory.\n+\t\tcrit *= 1 + scavengeCostRatio\n+\n \t\t// If we spent more than 10 ms (for example, if the OS scheduled us away, or someone\n \t\t// put their machine to sleep) in the critical section, bound the time we use to\n \t\t// calculate at 10 ms to avoid letting the sleep time get arbitrarily high.\n@@ -298,13 +311,13 @@ func bgscavenge(c chan int) {\n \t\t// much, then scavengeEMWA < idealFraction, so we'll adjust the sleep time\n \t\t// down.\n \t\tadjust := scavengeEWMA / idealFraction\n-\t\tsleepTime := int64(adjust * float64(crit) / (scavengePercent / 100.0))\n+\t\tsleepTime := int64(adjust * crit / (scavengePercent / 100.0))\n \n \t\t// Go to sleep.\n \t\tslept := scavengeSleep(sleepTime)\n \n \t\t// Compute the new ratio.\n-\t\tfraction := float64(crit) / float64(crit+slept)\n+\t\tfraction := crit / (crit + float64(slept))\n \n \t\t// Set a lower bound on the fraction.\n \t\t// Due to OS-related anomalies we may \"sleep\" for an inordinate amount\n@@ -348,12 +361,39 @@ func (s *pageAlloc) scavenge(nbytes uintptr, locked bool) uintptr {\n \treturn released\n }\n \n+// printScavTrace prints a scavenge trace line to standard error.\n+//\n+// released should be the amount of memory released since the last time this\n+// was called, and forced indicates whether the scavenge was forced by the\n+// application.\n+func printScavTrace(released uintptr, forced bool) {\n+\tprintlock()\n+\tprint(\"scav \",\n+\t\treleased>>10, \" KiB work, \",\n+\t\tatomic.Load64(&memstats.heap_released)>>10, \" KiB total, \",\n+\t\t(atomic.Load64(&memstats.heap_inuse)*100)/heapRetained(), \"% util\",\n+\t)\n+\tif forced {\n+\t\tprint(\" (forced)\")\n+\t}\n+\tprintln()\n+\tprintunlock()\n+}\n+\n // resetScavengeAddr sets the scavenge start address to the top of the heap's\n // address space. This should be called each time the scavenger's pacing\n // changes.\n //\n // s.mheapLock must be held.\n func (s *pageAlloc) resetScavengeAddr() {\n+\treleased := atomic.Loaduintptr(&s.scavReleased)\n+\tif debug.scavtrace > 0 {\n+\t\tprintScavTrace(released, false)\n+\t}\n+\t// Subtract from scavReleased instead of just setting it to zero because\n+\t// the scavenger could have increased scavReleased concurrently with the\n+\t// load above, and we may miss an update by just blindly zeroing the field.\n+\tatomic.Xadduintptr(&s.scavReleased, -released)\n \ts.scavAddr = chunkBase(s.end) - 1\n }\n \n@@ -415,7 +455,10 @@ func (s *pageAlloc) scavengeOne(max uintptr, locked bool) uintptr {\n \n \t// Check the chunk containing the scav addr, starting at the addr\n \t// and see if there are any free and unscavenged pages.\n-\tif s.summary[len(s.summary)-1][ci].max() >= uint(minPages) {\n+\t//\n+\t// Only check this if s.scavAddr is covered by any address range\n+\t// in s.inUse, so that we know our check of the summary is safe.\n+\tif s.inUse.contains(s.scavAddr) && s.summary[len(s.summary)-1][ci].max() >= uint(minPages) {\n \t\t// We only bother looking for a candidate if there at least\n \t\t// minPages free pages at all. It's important that we only\n \t\t// continue if the summary says we can because that's how"}, {"sha": "58f9e3a80d3ebfc6676d9049ee28d101a245d252", "filename": "libgo/go/runtime/mgcscavenge_test.go", "status": "modified", "additions": 26, "deletions": 2, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fruntime%2Fmgcscavenge_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fruntime%2Fmgcscavenge_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fmgcscavenge_test.go?ref=0b3c2eed35d608d6541ecf004a9576b4eae0b4ef", "patch": "@@ -272,19 +272,23 @@ func TestPallocDataFindScavengeCandidate(t *testing.T) {\n \n // Tests end-to-end scavenging on a pageAlloc.\n func TestPageAllocScavenge(t *testing.T) {\n+\tif GOOS == \"openbsd\" && testing.Short() {\n+\t\tt.Skip(\"skipping because virtual memory is limited; see #36210\")\n+\t}\n \ttype test struct {\n \t\trequest, expect uintptr\n \t}\n \tminPages := PhysPageSize / PageSize\n \tif minPages < 1 {\n \t\tminPages = 1\n \t}\n-\ttests := map[string]struct {\n+\ttype setup struct {\n \t\tbeforeAlloc map[ChunkIdx][]BitRange\n \t\tbeforeScav  map[ChunkIdx][]BitRange\n \t\texpect      []test\n \t\tafterScav   map[ChunkIdx][]BitRange\n-\t}{\n+\t}\n+\ttests := map[string]setup{\n \t\t\"AllFreeUnscavExhaust\": {\n \t\t\tbeforeAlloc: map[ChunkIdx][]BitRange{\n \t\t\t\tBaseChunkIdx:     {},\n@@ -393,6 +397,26 @@ func TestPageAllocScavenge(t *testing.T) {\n \t\t\t},\n \t\t},\n \t}\n+\tif PageAlloc64Bit != 0 {\n+\t\ttests[\"ScavAllVeryDiscontiguous\"] = setup{\n+\t\t\tbeforeAlloc: map[ChunkIdx][]BitRange{\n+\t\t\t\tBaseChunkIdx:          {},\n+\t\t\t\tBaseChunkIdx + 0x1000: {},\n+\t\t\t},\n+\t\t\tbeforeScav: map[ChunkIdx][]BitRange{\n+\t\t\t\tBaseChunkIdx:          {},\n+\t\t\t\tBaseChunkIdx + 0x1000: {},\n+\t\t\t},\n+\t\t\texpect: []test{\n+\t\t\t\t{^uintptr(0), 2 * PallocChunkPages * PageSize},\n+\t\t\t\t{^uintptr(0), 0},\n+\t\t\t},\n+\t\t\tafterScav: map[ChunkIdx][]BitRange{\n+\t\t\t\tBaseChunkIdx:          {{0, PallocChunkPages}},\n+\t\t\t\tBaseChunkIdx + 0x1000: {{0, PallocChunkPages}},\n+\t\t\t},\n+\t\t}\n+\t}\n \tfor name, v := range tests {\n \t\tv := v\n \t\trunTest := func(t *testing.T, locked bool) {"}, {"sha": "c40c9e26628566104daf514ce1faf3bdfe44f0e5", "filename": "libgo/go/runtime/mheap.go", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fruntime%2Fmheap.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fruntime%2Fmheap.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fmheap.go?ref=0b3c2eed35d608d6541ecf004a9576b4eae0b4ef", "patch": "@@ -70,7 +70,7 @@ type mheap struct {\n \t// on the swept stack.\n \tsweepSpans [2]gcSweepBuf\n \n-\t_ uint32 // align uint64 fields on 32-bit for atomics\n+\t// _ uint32 // align uint64 fields on 32-bit for atomics\n \n \t// Proportional sweep\n \t//\n@@ -786,7 +786,9 @@ func (h *mheap) reclaim(npage uintptr) {\n // reclaimChunk sweeps unmarked spans that start at page indexes [pageIdx, pageIdx+n).\n // It returns the number of pages returned to the heap.\n //\n-// h.lock must be held and the caller must be non-preemptible.\n+// h.lock must be held and the caller must be non-preemptible. Note: h.lock may be\n+// temporarily unlocked and re-locked in order to do sweeping or if tracing is\n+// enabled.\n func (h *mheap) reclaimChunk(arenas []arenaIdx, pageIdx, n uintptr) uintptr {\n \t// The heap lock must be held because this accesses the\n \t// heapArena.spans arrays using potentially non-live pointers.\n@@ -842,8 +844,10 @@ func (h *mheap) reclaimChunk(arenas []arenaIdx, pageIdx, n uintptr) uintptr {\n \t\tn -= uintptr(len(inUse) * 8)\n \t}\n \tif trace.enabled {\n+\t\tunlock(&h.lock)\n \t\t// Account for pages scanned but not reclaimed.\n \t\ttraceGCSweepSpan((n0 - nFreed) * pageSize)\n+\t\tlock(&h.lock)\n \t}\n \treturn nFreed\n }\n@@ -1430,11 +1434,8 @@ func (h *mheap) scavengeAll() {\n \tunlock(&h.lock)\n \tgp.m.mallocing--\n \n-\tif debug.gctrace > 0 {\n-\t\tif released > 0 {\n-\t\t\tprint(\"forced scvg: \", released>>20, \" MB released\\n\")\n-\t\t}\n-\t\tprint(\"forced scvg: inuse: \", memstats.heap_inuse>>20, \", idle: \", memstats.heap_idle>>20, \", sys: \", memstats.heap_sys>>20, \", released: \", memstats.heap_released>>20, \", consumed: \", (memstats.heap_sys-memstats.heap_released)>>20, \" (MB)\\n\")\n+\tif debug.scavtrace > 0 {\n+\t\tprintScavTrace(released, true)\n \t}\n }\n "}, {"sha": "64e220772e1ba2b229a40f10a478616c2b17ef6a", "filename": "libgo/go/runtime/mkpreempt.go", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fruntime%2Fmkpreempt.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fruntime%2Fmkpreempt.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fmkpreempt.go?ref=0b3c2eed35d608d6541ecf004a9576b4eae0b4ef", "patch": "@@ -83,6 +83,7 @@ var arches = map[string]func(){\n \t\"mips64x\": func() { genMIPS(true) },\n \t\"mipsx\":   func() { genMIPS(false) },\n \t\"ppc64x\":  genPPC64,\n+\t\"riscv64\": genRISCV64,\n \t\"s390x\":   genS390X,\n \t\"wasm\":    genWasm,\n }\n@@ -478,6 +479,11 @@ func genPPC64() {\n \tp(\"JMP (CTR)\")\n }\n \n+func genRISCV64() {\n+\tp(\"// No async preemption on riscv64 - see issue 36711\")\n+\tp(\"UNDEF\")\n+}\n+\n func genS390X() {\n \t// Add integer registers R0-R12\n \t// R13 (g), R14 (LR), R15 (SP) are special, and not saved here."}, {"sha": "bb751f1f8edff688cdadda7064560fae2042e5ef", "filename": "libgo/go/runtime/mpagealloc.go", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fruntime%2Fmpagealloc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fruntime%2Fmpagealloc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fmpagealloc.go?ref=0b3c2eed35d608d6541ecf004a9576b4eae0b4ef", "patch": "@@ -225,7 +225,9 @@ type pageAlloc struct {\n \t// the bitmaps align better on zero-values.\n \tchunks [1 << pallocChunksL1Bits]*[1 << pallocChunksL2Bits]pallocData\n \n-\t// The address to start an allocation search with.\n+\t// The address to start an allocation search with. It must never\n+\t// point to any memory that is not contained in inUse, i.e.\n+\t// inUse.contains(searchAddr) must always be true.\n \t//\n \t// When added with arenaBaseOffset, we guarantee that\n \t// all valid heap addresses (when also added with\n@@ -237,9 +239,15 @@ type pageAlloc struct {\n \t// space on architectures with segmented address spaces.\n \tsearchAddr uintptr\n \n-\t// The address to start a scavenge candidate search with.\n+\t// The address to start a scavenge candidate search with. It\n+\t// need not point to memory contained in inUse.\n \tscavAddr uintptr\n \n+\t// The amount of memory scavenged since the last scavtrace print.\n+\t//\n+\t// Read and updated atomically.\n+\tscavReleased uintptr\n+\n \t// start and end represent the chunk indices\n \t// which pageAlloc knows about. It assumes\n \t// chunks in the range [start, end) are"}, {"sha": "385b7b3e7a7a5819b8d90710e6f31f7781231b03", "filename": "libgo/go/runtime/mpagealloc_64bit.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fruntime%2Fmpagealloc_64bit.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fruntime%2Fmpagealloc_64bit.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fmpagealloc_64bit.go?ref=0b3c2eed35d608d6541ecf004a9576b4eae0b4ef", "patch": "@@ -2,7 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// +build amd64 !darwin,arm64 mips64 mips64le ppc64 ppc64le s390x arm64be alpha sparc64 ia64 riscv64\n+// +build amd64 !darwin,arm64 mips64 mips64le ppc64 ppc64le riscv64 s390x arm64be alpha sparc64 ia64\n \n // See mpagealloc_32bit.go for why darwin/arm64 is excluded here.\n "}, {"sha": "89a4a2502cec6e3fe71d7f1ff89be4d583e03f73", "filename": "libgo/go/runtime/mpagealloc_test.go", "status": "modified", "additions": 60, "deletions": 3, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fruntime%2Fmpagealloc_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fruntime%2Fmpagealloc_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fmpagealloc_test.go?ref=0b3c2eed35d608d6541ecf004a9576b4eae0b4ef", "patch": "@@ -41,6 +41,9 @@ func checkPageAlloc(t *testing.T, want, got *PageAlloc) {\n }\n \n func TestPageAllocGrow(t *testing.T) {\n+\tif GOOS == \"openbsd\" && testing.Short() {\n+\t\tt.Skip(\"skipping because virtual memory is limited; see #36210\")\n+\t}\n \ttype test struct {\n \t\tchunks []ChunkIdx\n \t\tinUse  []AddrRange\n@@ -216,15 +219,19 @@ func TestPageAllocGrow(t *testing.T) {\n }\n \n func TestPageAllocAlloc(t *testing.T) {\n+\tif GOOS == \"openbsd\" && testing.Short() {\n+\t\tt.Skip(\"skipping because virtual memory is limited; see #36210\")\n+\t}\n \ttype hit struct {\n \t\tnpages, base, scav uintptr\n \t}\n-\ttests := map[string]struct {\n+\ttype test struct {\n \t\tscav   map[ChunkIdx][]BitRange\n \t\tbefore map[ChunkIdx][]BitRange\n \t\tafter  map[ChunkIdx][]BitRange\n \t\thits   []hit\n-\t}{\n+\t}\n+\ttests := map[string]test{\n \t\t\"AllFree1\": {\n \t\t\tbefore: map[ChunkIdx][]BitRange{\n \t\t\t\tBaseChunkIdx: {},\n@@ -365,7 +372,6 @@ func TestPageAllocAlloc(t *testing.T) {\n \t\t\t\tBaseChunkIdx: {{0, 195}},\n \t\t\t},\n \t\t},\n-\t\t// TODO(mknyszek): Add tests close to the chunk size.\n \t\t\"ExhaustPallocChunkPages-3\": {\n \t\t\tbefore: map[ChunkIdx][]BitRange{\n \t\t\t\tBaseChunkIdx: {},\n@@ -565,6 +571,48 @@ func TestPageAllocAlloc(t *testing.T) {\n \t\t\t},\n \t\t},\n \t}\n+\tif PageAlloc64Bit != 0 {\n+\t\tconst chunkIdxBigJump = 0x100000 // chunk index offset which translates to O(TiB)\n+\n+\t\t// This test attempts to trigger a bug wherein we look at unmapped summary\n+\t\t// memory that isn't just in the case where we exhaust the heap.\n+\t\t//\n+\t\t// It achieves this by placing a chunk such that its summary will be\n+\t\t// at the very end of a physical page. It then also places another chunk\n+\t\t// much further up in the address space, such that any allocations into the\n+\t\t// first chunk do not exhaust the heap and the second chunk's summary is not in the\n+\t\t// page immediately adjacent to the first chunk's summary's page.\n+\t\t// Allocating into this first chunk to exhaustion and then into the second\n+\t\t// chunk may then trigger a check in the allocator which erroneously looks at\n+\t\t// unmapped summary memory and crashes.\n+\n+\t\t// Figure out how many chunks are in a physical page, then align BaseChunkIdx\n+\t\t// to a physical page in the chunk summary array. Here we only assume that\n+\t\t// each summary array is aligned to some physical page.\n+\t\tsumsPerPhysPage := ChunkIdx(PhysPageSize / PallocSumBytes)\n+\t\tbaseChunkIdx := BaseChunkIdx &^ (sumsPerPhysPage - 1)\n+\t\ttests[\"DiscontiguousMappedSumBoundary\"] = test{\n+\t\t\tbefore: map[ChunkIdx][]BitRange{\n+\t\t\t\tbaseChunkIdx + sumsPerPhysPage - 1: {},\n+\t\t\t\tbaseChunkIdx + chunkIdxBigJump:     {},\n+\t\t\t},\n+\t\t\tscav: map[ChunkIdx][]BitRange{\n+\t\t\t\tbaseChunkIdx + sumsPerPhysPage - 1: {},\n+\t\t\t\tbaseChunkIdx + chunkIdxBigJump:     {},\n+\t\t\t},\n+\t\t\thits: []hit{\n+\t\t\t\t{PallocChunkPages - 1, PageBase(baseChunkIdx+sumsPerPhysPage-1, 0), 0},\n+\t\t\t\t{1, PageBase(baseChunkIdx+sumsPerPhysPage-1, PallocChunkPages-1), 0},\n+\t\t\t\t{1, PageBase(baseChunkIdx+chunkIdxBigJump, 0), 0},\n+\t\t\t\t{PallocChunkPages - 1, PageBase(baseChunkIdx+chunkIdxBigJump, 1), 0},\n+\t\t\t\t{1, 0, 0},\n+\t\t\t},\n+\t\t\tafter: map[ChunkIdx][]BitRange{\n+\t\t\t\tbaseChunkIdx + sumsPerPhysPage - 1: {{0, PallocChunkPages}},\n+\t\t\t\tbaseChunkIdx + chunkIdxBigJump:     {{0, PallocChunkPages}},\n+\t\t\t},\n+\t\t}\n+\t}\n \tfor name, v := range tests {\n \t\tv := v\n \t\tt.Run(name, func(t *testing.T) {\n@@ -589,6 +637,9 @@ func TestPageAllocAlloc(t *testing.T) {\n }\n \n func TestPageAllocExhaust(t *testing.T) {\n+\tif GOOS == \"openbsd\" && testing.Short() {\n+\t\tt.Skip(\"skipping because virtual memory is limited; see #36210\")\n+\t}\n \tfor _, npages := range []uintptr{1, 2, 3, 4, 5, 8, 16, 64, 1024, 1025, 2048, 2049} {\n \t\tnpages := npages\n \t\tt.Run(fmt.Sprintf(\"%d\", npages), func(t *testing.T) {\n@@ -638,6 +689,9 @@ func TestPageAllocExhaust(t *testing.T) {\n }\n \n func TestPageAllocFree(t *testing.T) {\n+\tif GOOS == \"openbsd\" && testing.Short() {\n+\t\tt.Skip(\"skipping because virtual memory is limited; see #36210\")\n+\t}\n \ttests := map[string]struct {\n \t\tbefore map[ChunkIdx][]BitRange\n \t\tafter  map[ChunkIdx][]BitRange\n@@ -867,6 +921,9 @@ func TestPageAllocFree(t *testing.T) {\n }\n \n func TestPageAllocAllocAndFree(t *testing.T) {\n+\tif GOOS == \"openbsd\" && testing.Short() {\n+\t\tt.Skip(\"skipping because virtual memory is limited; see #36210\")\n+\t}\n \ttype hit struct {\n \t\talloc  bool\n \t\tnpages uintptr"}, {"sha": "b8cc0bd965f5924941f4fb2041dc8a477ff0e7ad", "filename": "libgo/go/runtime/mpagecache_test.go", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fruntime%2Fmpagecache_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fruntime%2Fmpagecache_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fmpagecache_test.go?ref=0b3c2eed35d608d6541ecf004a9576b4eae0b4ef", "patch": "@@ -180,6 +180,9 @@ func TestPageCacheAlloc(t *testing.T) {\n }\n \n func TestPageCacheFlush(t *testing.T) {\n+\tif GOOS == \"openbsd\" && testing.Short() {\n+\t\tt.Skip(\"skipping because virtual memory is limited; see #36210\")\n+\t}\n \tbits64ToBitRanges := func(bits uint64, base uint) []BitRange {\n \t\tvar ranges []BitRange\n \t\tstart, size := uint(0), uint(0)\n@@ -254,6 +257,9 @@ func TestPageCacheFlush(t *testing.T) {\n }\n \n func TestPageAllocAllocToCache(t *testing.T) {\n+\tif GOOS == \"openbsd\" && testing.Short() {\n+\t\tt.Skip(\"skipping because virtual memory is limited; see #36210\")\n+\t}\n \ttests := map[string]struct {\n \t\tbefore map[ChunkIdx][]BitRange\n \t\tscav   map[ChunkIdx][]BitRange"}, {"sha": "a8011341bce06a114b68c21643c609276ef72930", "filename": "libgo/go/runtime/mpallocbits.go", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fruntime%2Fmpallocbits.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fruntime%2Fmpallocbits.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fmpallocbits.go?ref=0b3c2eed35d608d6541ecf004a9576b4eae0b4ef", "patch": "@@ -202,17 +202,11 @@ func (b *pallocBits) summarize() pallocSum {\n // If find fails to find any free space, it returns an index of ^uint(0) and\n // the new searchIdx should be ignored.\n //\n-// The returned searchIdx is always the index of the first free page found\n-// in this bitmap during the search, except if npages == 1, in which\n-// case it will be the index just after the first free page, because the\n-// index returned as the first result is assumed to be allocated and so\n-// represents a minor optimization for that case.\n+// Note that if npages == 1, the two returned values will always be identical.\n func (b *pallocBits) find(npages uintptr, searchIdx uint) (uint, uint) {\n \tif npages == 1 {\n \t\taddr := b.find1(searchIdx)\n-\t\t// Return a searchIdx of addr + 1 since we assume addr will be\n-\t\t// allocated.\n-\t\treturn addr, addr + 1\n+\t\treturn addr, addr\n \t} else if npages <= 64 {\n \t\treturn b.findSmallN(npages, searchIdx)\n \t}"}, {"sha": "b13385165b3bff23d432614800996529eb634d58", "filename": "libgo/go/runtime/mranges.go", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fruntime%2Fmranges.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fruntime%2Fmranges.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fmranges.go?ref=0b3c2eed35d608d6541ecf004a9576b4eae0b4ef", "patch": "@@ -29,6 +29,11 @@ func (a addrRange) size() uintptr {\n \treturn a.limit - a.base\n }\n \n+// contains returns whether or not the range contains a given address.\n+func (a addrRange) contains(addr uintptr) bool {\n+\treturn addr >= a.base && addr < a.limit\n+}\n+\n // subtract takes the addrRange toPrune and cuts out any overlap with\n // from, then returns the new range. subtract assumes that a and b\n // either don't overlap at all, only overlap on one side, or are equal.\n@@ -87,6 +92,15 @@ func (a *addrRanges) findSucc(base uintptr) int {\n \treturn len(a.ranges)\n }\n \n+// contains returns true if a covers the address addr.\n+func (a *addrRanges) contains(addr uintptr) bool {\n+\ti := a.findSucc(addr)\n+\tif i == 0 {\n+\t\treturn false\n+\t}\n+\treturn a.ranges[i-1].contains(addr)\n+}\n+\n // add inserts a new address range to a.\n //\n // r must not overlap with any address range in a."}, {"sha": "3066a1521eb644aaad772885cbb578d5e4f4b74e", "filename": "libgo/go/runtime/preempt_nonwindows.go", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fruntime%2Fpreempt_nonwindows.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fruntime%2Fpreempt_nonwindows.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fpreempt_nonwindows.go?ref=0b3c2eed35d608d6541ecf004a9576b4eae0b4ef", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2020 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build !windows\n+\n+package runtime\n+\n+//go:nosplit\n+func osPreemptExtEnter(mp *m) {}\n+\n+//go:nosplit\n+func osPreemptExtExit(mp *m) {}"}, {"sha": "f75cacf3f43eba630231dc3451a993bae2cea424", "filename": "libgo/go/runtime/proc.go", "status": "modified", "additions": 59, "deletions": 58, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fruntime%2Fproc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fruntime%2Fproc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fproc.go?ref=0b3c2eed35d608d6541ecf004a9576b4eae0b4ef", "patch": "@@ -841,23 +841,8 @@ func casGFromPreempted(gp *g, old, new uint32) bool {\n // goroutines.\n func stopTheWorld(reason string) {\n \tsemacquire(&worldsema)\n-\tgp := getg()\n-\tgp.m.preemptoff = reason\n-\tsystemstack(func() {\n-\t\t// Mark the goroutine which called stopTheWorld preemptible so its\n-\t\t// stack may be scanned.\n-\t\t// This lets a mark worker scan us while we try to stop the world\n-\t\t// since otherwise we could get in a mutual preemption deadlock.\n-\t\t// We must not modify anything on the G stack because a stack shrink\n-\t\t// may occur. A stack shrink is otherwise OK though because in order\n-\t\t// to return from this function (and to leave the system stack) we\n-\t\t// must have preempted all goroutines, including any attempting\n-\t\t// to scan our stack, in which case, any stack shrinking will\n-\t\t// have already completed by the time we exit.\n-\t\tcasgstatus(gp, _Grunning, _Gwaiting)\n-\t\tstopTheWorldWithSema()\n-\t\tcasgstatus(gp, _Gwaiting, _Grunning)\n-\t})\n+\tgetg().m.preemptoff = reason\n+\tsystemstack(stopTheWorldWithSema)\n }\n \n // startTheWorld undoes the effects of stopTheWorld.\n@@ -869,31 +854,10 @@ func startTheWorld() {\n \tgetg().m.preemptoff = \"\"\n }\n \n-// stopTheWorldGC has the same effect as stopTheWorld, but blocks\n-// until the GC is not running. It also blocks a GC from starting\n-// until startTheWorldGC is called.\n-func stopTheWorldGC(reason string) {\n-\tsemacquire(&gcsema)\n-\tstopTheWorld(reason)\n-}\n-\n-// startTheWorldGC undoes the effects of stopTheWorldGC.\n-func startTheWorldGC() {\n-\tstartTheWorld()\n-\tsemrelease(&gcsema)\n-}\n-\n-// Holding worldsema grants an M the right to try to stop the world.\n+// Holding worldsema grants an M the right to try to stop the world\n+// and prevents gomaxprocs from changing concurrently.\n var worldsema uint32 = 1\n \n-// Holding gcsema grants the M the right to block a GC, and blocks\n-// until the current GC is done. In particular, it prevents gomaxprocs\n-// from changing concurrently.\n-//\n-// TODO(mknyszek): Once gomaxprocs and the execution tracer can handle\n-// being changed/enabled during a GC, remove this.\n-var gcsema uint32 = 1\n-\n // stopTheWorldWithSema is the core implementation of stopTheWorld.\n // The caller is responsible for acquiring worldsema and disabling\n // preemption first and then should stopTheWorldWithSema on the system\n@@ -2577,6 +2541,27 @@ func dropg() {\n // We pass now in and out to avoid extra calls of nanotime.\n //go:yeswritebarrierrec\n func checkTimers(pp *p, now int64) (rnow, pollUntil int64, ran bool) {\n+\t// If there are no timers to adjust, and the first timer on\n+\t// the heap is not yet ready to run, then there is nothing to do.\n+\tif atomic.Load(&pp.adjustTimers) == 0 {\n+\t\tnext := int64(atomic.Load64(&pp.timer0When))\n+\t\tif next == 0 {\n+\t\t\treturn now, 0, false\n+\t\t}\n+\t\tif now == 0 {\n+\t\t\tnow = nanotime()\n+\t\t}\n+\t\tif now < next {\n+\t\t\t// Next timer is not ready to run.\n+\t\t\t// But keep going if we would clear deleted timers.\n+\t\t\t// This corresponds to the condition below where\n+\t\t\t// we decide whether to call clearDeletedTimers.\n+\t\t\tif pp != getg().m.p.ptr() || int(atomic.Load(&pp.deletedTimers)) <= int(atomic.Load(&pp.numTimers)/4) {\n+\t\t\t\treturn now, next, false\n+\t\t\t}\n+\t\t}\n+\t}\n+\n \tlock(&pp.timersLock)\n \n \tadjusttimers(pp)\n@@ -2599,6 +2584,13 @@ func checkTimers(pp *p, now int64) (rnow, pollUntil int64, ran bool) {\n \t\t}\n \t}\n \n+\t// If this is the local P, and there are a lot of deleted timers,\n+\t// clear them out. We only do this for the local P to reduce\n+\t// lock contention on timersLock.\n+\tif pp == getg().m.p.ptr() && int(atomic.Load(&pp.deletedTimers)) > len(pp.timers)/4 {\n+\t\tclearDeletedTimers(pp)\n+\t}\n+\n \tunlock(&pp.timersLock)\n \n \treturn rnow, pollUntil, ran\n@@ -2723,14 +2715,17 @@ func preemptPark(gp *g) {\n }\n \n // goyield is like Gosched, but it:\n-// - does not emit a GoSched trace event\n+// - emits a GoPreempt trace event instead of a GoSched trace event\n // - puts the current G on the runq of the current P instead of the globrunq\n func goyield() {\n \tcheckTimeouts()\n \tmcall(goyield_m)\n }\n \n func goyield_m(gp *g) {\n+\tif trace.enabled {\n+\t\ttraceGoPreempt()\n+\t}\n \tpp := gp.m.p.ptr()\n \tcasgstatus(gp, _Grunning, _Grunnable)\n \tdropg()\n@@ -3816,7 +3811,10 @@ func (pp *p) destroy() {\n \t\tlock(&pp.timersLock)\n \t\tmoveTimers(plocal, pp.timers)\n \t\tpp.timers = nil\n+\t\tpp.numTimers = 0\n \t\tpp.adjustTimers = 0\n+\t\tpp.deletedTimers = 0\n+\t\tatomic.Store64(&pp.timer0When, 0)\n \t\tunlock(&pp.timersLock)\n \t\tunlock(&plocal.timersLock)\n \t}\n@@ -4122,23 +4120,26 @@ func checkdead() {\n \t}\n \n \t// Maybe jump time forward for playground.\n-\t_p_ := timejump()\n-\tif _p_ != nil {\n-\t\tfor pp := &sched.pidle; *pp != 0; pp = &(*pp).ptr().link {\n-\t\t\tif (*pp).ptr() == _p_ {\n-\t\t\t\t*pp = _p_.link\n-\t\t\t\tbreak\n+\tif faketime != 0 {\n+\t\twhen, _p_ := timeSleepUntil()\n+\t\tif _p_ != nil {\n+\t\t\tfaketime = when\n+\t\t\tfor pp := &sched.pidle; *pp != 0; pp = &(*pp).ptr().link {\n+\t\t\t\tif (*pp).ptr() == _p_ {\n+\t\t\t\t\t*pp = _p_.link\n+\t\t\t\t\tbreak\n+\t\t\t\t}\n \t\t\t}\n+\t\t\tmp := mget()\n+\t\t\tif mp == nil {\n+\t\t\t\t// There should always be a free M since\n+\t\t\t\t// nothing is running.\n+\t\t\t\tthrow(\"checkdead: no m for timer\")\n+\t\t\t}\n+\t\t\tmp.nextp.set(_p_)\n+\t\t\tnotewakeup(&mp.park)\n+\t\t\treturn\n \t\t}\n-\t\tmp := mget()\n-\t\tif mp == nil {\n-\t\t\t// There should always be a free M since\n-\t\t\t// nothing is running.\n-\t\t\tthrow(\"checkdead: no m for timer\")\n-\t\t}\n-\t\tmp.nextp.set(_p_)\n-\t\tnotewakeup(&mp.park)\n-\t\treturn\n \t}\n \n \t// There are no goroutines running, so we can look at the P's.\n@@ -4183,7 +4184,7 @@ func sysmon() {\n \t\t}\n \t\tusleep(delay)\n \t\tnow := nanotime()\n-\t\tnext := timeSleepUntil()\n+\t\tnext, _ := timeSleepUntil()\n \t\tif debug.schedtrace <= 0 && (sched.gcwaiting != 0 || atomic.Load(&sched.npidle) == uint32(gomaxprocs)) {\n \t\t\tlock(&sched.lock)\n \t\t\tif atomic.Load(&sched.gcwaiting) != 0 || atomic.Load(&sched.npidle) == uint32(gomaxprocs) {\n@@ -4205,7 +4206,7 @@ func sysmon() {\n \t\t\t\t\t\tosRelax(false)\n \t\t\t\t\t}\n \t\t\t\t\tnow = nanotime()\n-\t\t\t\t\tnext = timeSleepUntil()\n+\t\t\t\t\tnext, _ = timeSleepUntil()\n \t\t\t\t\tlock(&sched.lock)\n \t\t\t\t\tatomic.Store(&sched.sysmonwait, 0)\n \t\t\t\t\tnoteclear(&sched.sysmonnote)"}, {"sha": "6edf7a5acec7e36918819b12fbb64c15d23f4d0e", "filename": "libgo/go/runtime/runtime1.go", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fruntime%2Fruntime1.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fruntime%2Fruntime1.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fruntime1.go?ref=0b3c2eed35d608d6541ecf004a9576b4eae0b4ef", "patch": "@@ -323,6 +323,7 @@ var debug struct {\n \tmadvdontneed       int32 // for Linux; issue 28466\n \tsbrk               int32\n \tscavenge           int32\n+\tscavtrace          int32\n \tscheddetail        int32\n \tschedtrace         int32\n \ttracebackancestors int32\n@@ -343,6 +344,7 @@ var dbgvars = []dbgVar{\n \t{\"madvdontneed\", &debug.madvdontneed},\n \t{\"sbrk\", &debug.sbrk},\n \t{\"scavenge\", &debug.scavenge},\n+\t{\"scavtrace\", &debug.scavtrace},\n \t{\"scheddetail\", &debug.scheddetail},\n \t{\"schedtrace\", &debug.schedtrace},\n \t{\"tracebackancestors\", &debug.tracebackancestors},"}, {"sha": "f5bfc089c103e29624fae65ba5cfbadea265d2d1", "filename": "libgo/go/runtime/runtime2.go", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fruntime%2Fruntime2.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fruntime%2Fruntime2.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fruntime2.go?ref=0b3c2eed35d608d6541ecf004a9576b4eae0b4ef", "patch": "@@ -677,6 +677,11 @@ type p struct {\n \n \t_ uint32 // Alignment for atomic fields below\n \n+\t// The when field of the first entry on the timer heap.\n+\t// This is updated using atomic functions.\n+\t// This is 0 if the timer heap is empty.\n+\ttimer0When uint64\n+\n \t// Per-P GC state\n \tgcAssistTime         int64    // Nanoseconds in assistAlloc\n \tgcFractionalMarkTime int64    // Nanoseconds in fractional mark worker (atomic)\n@@ -708,12 +713,20 @@ type p struct {\n \t// Must hold timersLock to access.\n \ttimers []*timer\n \n+\t// Number of timers in P's heap.\n+\t// Modified using atomic instructions.\n+\tnumTimers uint32\n+\n \t// Number of timerModifiedEarlier timers on P's heap.\n \t// This should only be modified while holding timersLock,\n \t// or while the timer status is in a transient state\n \t// such as timerModifying.\n \tadjustTimers uint32\n \n+\t// Number of timerDeleted timers in P's heap.\n+\t// Modified using atomic instructions.\n+\tdeletedTimers uint32\n+\n \t// Race context used while executing timer functions.\n \t// Not for gccgo: timerRaceCtx uintptr\n "}, {"sha": "b6fab6daca75f0752c15731b3eb5d02f9fcb2121", "filename": "libgo/go/runtime/sema.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fruntime%2Fsema.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fruntime%2Fsema.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fsema.go?ref=0b3c2eed35d608d6541ecf004a9576b4eae0b4ef", "patch": "@@ -199,9 +199,9 @@ func semrelease1(addr *uint32, handoff bool, skipframes int) {\n \t\t\t// the waiter G immediately.\n \t\t\t// Note that waiter inherits our time slice: this is desirable\n \t\t\t// to avoid having a highly contended semaphore hog the P\n-\t\t\t// indefinitely. goyield is like Gosched, but it does not emit a\n-\t\t\t// GoSched trace event and, more importantly, puts the current G\n-\t\t\t// on the local runq instead of the global one.\n+\t\t\t// indefinitely. goyield is like Gosched, but it emits a\n+\t\t\t// \"preempted\" trace event instead and, more importantly, puts\n+\t\t\t// the current G on the local runq instead of the global one.\n \t\t\t// We only do this in the starving regime (handoff=true), as in\n \t\t\t// the non-starving case it is possible for a different waiter\n \t\t\t// to acquire the semaphore while we are yielding/scheduling,"}, {"sha": "150345f05122c644df29fe76640ed744646f7ee9", "filename": "libgo/go/runtime/signal_unix.go", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fruntime%2Fsignal_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fruntime%2Fsignal_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fsignal_unix.go?ref=0b3c2eed35d608d6541ecf004a9576b4eae0b4ef", "patch": "@@ -399,6 +399,16 @@ func sigtrampgo(sig uint32, info *_siginfo_t, ctx unsafe.Pointer) {\n \t\t\tsigprofNonGo(pc)\n \t\t\treturn\n \t\t}\n+\t\tif sig == sigPreempt && preemptMSupported && debug.asyncpreemptoff == 0 {\n+\t\t\t// This is probably a signal from preemptM sent\n+\t\t\t// while executing Go code but received while\n+\t\t\t// executing non-Go code.\n+\t\t\t// We got past sigfwdgo, so we know that there is\n+\t\t\t// no non-Go signal handler for sigPreempt.\n+\t\t\t// The default behavior for sigPreempt is to ignore\n+\t\t\t// the signal, so badsignal will be a no-op anyway.\n+\t\t\treturn\n+\t\t}\n \t\tbadsignal(uintptr(sig), &c)\n \t\treturn\n \t}"}, {"sha": "177db38e5ab68e3103790878bb36484573ed95c5", "filename": "libgo/go/runtime/testdata/testprog/checkptr.go", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fruntime%2Ftestdata%2Ftestprog%2Fcheckptr.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fruntime%2Ftestdata%2Ftestprog%2Fcheckptr.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Ftestdata%2Ftestprog%2Fcheckptr.go?ref=0b3c2eed35d608d6541ecf004a9576b4eae0b4ef", "patch": "@@ -0,0 +1,36 @@\n+// Copyright 2020 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package main\n+\n+import \"unsafe\"\n+\n+func init() {\n+\tregister(\"CheckPtrAlignment\", CheckPtrAlignment)\n+\tregister(\"CheckPtrArithmetic\", CheckPtrArithmetic)\n+\tregister(\"CheckPtrSize\", CheckPtrSize)\n+\tregister(\"CheckPtrSmall\", CheckPtrSmall)\n+}\n+\n+func CheckPtrAlignment() {\n+\tvar x [2]int64\n+\tp := unsafe.Pointer(&x[0])\n+\tsink2 = (*int64)(unsafe.Pointer(uintptr(p) + 1))\n+}\n+\n+func CheckPtrArithmetic() {\n+\tvar x int\n+\ti := uintptr(unsafe.Pointer(&x))\n+\tsink2 = (*int)(unsafe.Pointer(i))\n+}\n+\n+func CheckPtrSize() {\n+\tp := new(int64)\n+\tsink2 = p\n+\tsink2 = (*[100]int64)(unsafe.Pointer(p))\n+}\n+\n+func CheckPtrSmall() {\n+\tsink2 = unsafe.Pointer(uintptr(1))\n+}"}, {"sha": "d0dd3a49e4112f1aa8c382f8fa457f1ec770cab8", "filename": "libgo/go/runtime/time.go", "status": "modified", "additions": 169, "deletions": 70, "changes": 239, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fruntime%2Ftime.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fruntime%2Ftime.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Ftime.go?ref=0b3c2eed35d608d6541ecf004a9576b4eae0b4ef", "patch": "@@ -73,14 +73,15 @@ type timer struct {\n //   timerNoStatus   -> timerWaiting\n //   anything else   -> panic: invalid value\n // deltimer:\n-//   timerWaiting    -> timerDeleted\n-//   timerModifiedXX -> timerDeleted\n-//   timerNoStatus   -> do nothing\n-//   timerDeleted    -> do nothing\n-//   timerRemoving   -> do nothing\n-//   timerRemoved    -> do nothing\n-//   timerRunning    -> wait until status changes\n-//   timerMoving     -> wait until status changes\n+//   timerWaiting         -> timerDeleted\n+//   timerModifiedEarlier -> timerModifying -> timerDeleted\n+//   timerModifiedLater   -> timerDeleted\n+//   timerNoStatus        -> do nothing\n+//   timerDeleted         -> do nothing\n+//   timerRemoving        -> do nothing\n+//   timerRemoved         -> do nothing\n+//   timerRunning         -> wait until status changes\n+//   timerMoving          -> wait until status changes\n //   timerModifying  -> panic: concurrent deltimer/modtimer calls\n // modtimer:\n //   timerWaiting    -> timerModifying -> timerModifiedXX\n@@ -168,6 +169,10 @@ const (\n // maxWhen is the maximum value for timer's when field.\n const maxWhen = 1<<63 - 1\n \n+// verifyTimers can be set to true to add debugging checks that the\n+// timer heaps are valid.\n+const verifyTimers = false\n+\n // Package time APIs.\n // Godoc uses the comments in package time, not these.\n \n@@ -283,7 +288,12 @@ func doaddtimer(pp *p, t *timer) bool {\n \tt.pp.set(pp)\n \ti := len(pp.timers)\n \tpp.timers = append(pp.timers, t)\n-\treturn siftupTimer(pp.timers, i)\n+\tok := siftupTimer(pp.timers, i)\n+\tif t == pp.timers[0] {\n+\t\tatomic.Store64(&pp.timer0When, uint64(t.when))\n+\t}\n+\tatomic.Xadd(&pp.numTimers, 1)\n+\treturn ok\n }\n \n // deltimer deletes the timer t. It may be on some other P, so we can't\n@@ -294,7 +304,9 @@ func deltimer(t *timer) bool {\n \tfor {\n \t\tswitch s := atomic.Load(&t.status); s {\n \t\tcase timerWaiting, timerModifiedLater:\n+\t\t\ttpp := t.pp.ptr()\n \t\t\tif atomic.Cas(&t.status, s, timerDeleted) {\n+\t\t\t\tatomic.Xadd(&tpp.deletedTimers, 1)\n \t\t\t\t// Timer was not yet run.\n \t\t\t\treturn true\n \t\t\t}\n@@ -305,6 +317,7 @@ func deltimer(t *timer) bool {\n \t\t\t\tif !atomic.Cas(&t.status, timerModifying, timerDeleted) {\n \t\t\t\t\tbadTimer()\n \t\t\t\t}\n+\t\t\t\tatomic.Xadd(&tpp.deletedTimers, 1)\n \t\t\t\t// Timer was not yet run.\n \t\t\t\treturn true\n \t\t\t}\n@@ -355,6 +368,10 @@ func dodeltimer(pp *p, i int) bool {\n \t\t\tok = false\n \t\t}\n \t}\n+\tif i == 0 {\n+\t\tupdateTimer0When(pp)\n+\t}\n+\tatomic.Xadd(&pp.numTimers, -1)\n \treturn ok\n }\n \n@@ -378,6 +395,8 @@ func dodeltimer0(pp *p) bool {\n \tif last > 0 {\n \t\tok = siftdownTimer(pp.timers, 0)\n \t}\n+\tupdateTimer0When(pp)\n+\tatomic.Xadd(&pp.numTimers, -1)\n \treturn ok\n }\n \n@@ -485,6 +504,7 @@ func resettimer(t *timer, when int64) {\n \t\t\t\treturn\n \t\t\t}\n \t\tcase timerDeleted:\n+\t\t\ttpp := t.pp.ptr()\n \t\t\tif atomic.Cas(&t.status, s, timerModifying) {\n \t\t\t\tt.nextwhen = when\n \t\t\t\tnewStatus := uint32(timerModifiedLater)\n@@ -495,6 +515,7 @@ func resettimer(t *timer, when int64) {\n \t\t\t\tif !atomic.Cas(&t.status, timerModifying, newStatus) {\n \t\t\t\t\tbadTimer()\n \t\t\t\t}\n+\t\t\t\tatomic.Xadd(&tpp.deletedTimers, -1)\n \t\t\t\tif newStatus == timerModifiedEarlier {\n \t\t\t\t\twakeNetPoller(when)\n \t\t\t\t}\n@@ -542,6 +563,7 @@ func cleantimers(pp *p) bool {\n \t\t\tif !atomic.Cas(&t.status, timerRemoving, timerRemoved) {\n \t\t\t\treturn false\n \t\t\t}\n+\t\t\tatomic.Xadd(&pp.deletedTimers, -1)\n \t\tcase timerModifiedEarlier, timerModifiedLater:\n \t\t\tif !atomic.Cas(&t.status, s, timerMoving) {\n \t\t\t\tcontinue\n@@ -630,9 +652,13 @@ func adjusttimers(pp *p) {\n \t\treturn\n \t}\n \tif atomic.Load(&pp.adjustTimers) == 0 {\n+\t\tif verifyTimers {\n+\t\t\tverifyTimerHeap(pp)\n+\t\t}\n \t\treturn\n \t}\n \tvar moved []*timer\n+loop:\n \tfor i := 0; i < len(pp.timers); i++ {\n \t\tt := pp.timers[i]\n \t\tif t.pp.ptr() != pp {\n@@ -647,6 +673,7 @@ func adjusttimers(pp *p) {\n \t\t\t\tif !atomic.Cas(&t.status, timerRemoving, timerRemoved) {\n \t\t\t\t\tbadTimer()\n \t\t\t\t}\n+\t\t\t\tatomic.Xadd(&pp.deletedTimers, -1)\n \t\t\t\t// Look at this heap position again.\n \t\t\t\ti--\n \t\t\t}\n@@ -664,10 +691,11 @@ func adjusttimers(pp *p) {\n \t\t\t\tmoved = append(moved, t)\n \t\t\t\tif s == timerModifiedEarlier {\n \t\t\t\t\tif n := atomic.Xadd(&pp.adjustTimers, -1); int32(n) <= 0 {\n-\t\t\t\t\t\taddAdjustedTimers(pp, moved)\n-\t\t\t\t\t\treturn\n+\t\t\t\t\t\tbreak loop\n \t\t\t\t\t}\n \t\t\t\t}\n+\t\t\t\t// Look at this heap position again.\n+\t\t\t\ti--\n \t\t\t}\n \t\tcase timerNoStatus, timerRunning, timerRemoving, timerRemoved, timerMoving:\n \t\t\tbadTimer()\n@@ -685,6 +713,10 @@ func adjusttimers(pp *p) {\n \tif len(moved) > 0 {\n \t\taddAdjustedTimers(pp, moved)\n \t}\n+\n+\tif verifyTimers {\n+\t\tverifyTimerHeap(pp)\n+\t}\n }\n \n // addAdjustedTimers adds any timers we adjusted in adjusttimers\n@@ -708,17 +740,11 @@ func addAdjustedTimers(pp *p, moved []*timer) {\n // The netpoller M will wake up and adjust timers before sleeping again.\n //go:nowritebarrierrec\n func nobarrierWakeTime(pp *p) int64 {\n-\tlock(&pp.timersLock)\n-\tret := int64(0)\n-\tif len(pp.timers) > 0 {\n-\t\tif atomic.Load(&pp.adjustTimers) > 0 {\n-\t\t\tret = nanotime()\n-\t\t} else {\n-\t\t\tret = pp.timers[0].when\n-\t\t}\n+\tif atomic.Load(&pp.adjustTimers) > 0 {\n+\t\treturn nanotime()\n+\t} else {\n+\t\treturn int64(atomic.Load64(&pp.timer0When))\n \t}\n-\tunlock(&pp.timersLock)\n-\treturn ret\n }\n \n // runtimer examines the first timer in timers. If it is ready based on now,\n@@ -759,6 +785,7 @@ func runtimer(pp *p, now int64) int64 {\n \t\t\tif !atomic.Cas(&t.status, timerRemoving, timerRemoved) {\n \t\t\t\tbadTimer()\n \t\t\t}\n+\t\t\tatomic.Xadd(&pp.deletedTimers, -1)\n \t\t\tif len(pp.timers) == 0 {\n \t\t\t\treturn -1\n \t\t\t}\n@@ -817,6 +844,7 @@ func runOneTimer(pp *p, t *timer, now int64) {\n \t\tif !atomic.Cas(&t.status, timerRunning, timerWaiting) {\n \t\t\tbadTimer()\n \t\t}\n+\t\tupdateTimer0When(pp)\n \t} else {\n \t\t// Remove from heap.\n \t\tif !dodeltimer0(pp) {\n@@ -834,69 +862,131 @@ func runOneTimer(pp *p, t *timer, now int64) {\n \tlock(&pp.timersLock)\n }\n \n-func timejump() *p {\n-\tif faketime == 0 {\n-\t\treturn nil\n-\t}\n-\n-\t// Nothing is running, so we can look at all the P's.\n-\t// Determine a timer bucket with minimum when.\n-\tvar (\n-\t\tminT    *timer\n-\t\tminWhen int64\n-\t\tminP    *p\n-\t)\n-\tfor _, pp := range allp {\n-\t\tif pp.status != _Pidle && pp.status != _Pdead {\n-\t\t\tthrow(\"non-idle P in timejump\")\n-\t\t}\n-\t\tif len(pp.timers) == 0 {\n-\t\t\tcontinue\n-\t\t}\n-\t\tc := pp.adjustTimers\n-\t\tfor _, t := range pp.timers {\n+// clearDeletedTimers removes all deleted timers from the P's timer heap.\n+// This is used to avoid clogging up the heap if the program\n+// starts a lot of long-running timers and then stops them.\n+// For example, this can happen via context.WithTimeout.\n+//\n+// This is the only function that walks through the entire timer heap,\n+// other than moveTimers which only runs when the world is stopped.\n+//\n+// The caller must have locked the timers for pp.\n+func clearDeletedTimers(pp *p) {\n+\tcdel := int32(0)\n+\tcearlier := int32(0)\n+\tto := 0\n+\tchangedHeap := false\n+\ttimers := pp.timers\n+nextTimer:\n+\tfor _, t := range timers {\n+\t\tfor {\n \t\t\tswitch s := atomic.Load(&t.status); s {\n \t\t\tcase timerWaiting:\n-\t\t\t\tif minT == nil || t.when < minWhen {\n-\t\t\t\t\tminT = t\n-\t\t\t\t\tminWhen = t.when\n-\t\t\t\t\tminP = pp\n+\t\t\t\tif changedHeap {\n+\t\t\t\t\ttimers[to] = t\n+\t\t\t\t\tsiftupTimer(timers, to)\n \t\t\t\t}\n+\t\t\t\tto++\n+\t\t\t\tcontinue nextTimer\n \t\t\tcase timerModifiedEarlier, timerModifiedLater:\n-\t\t\t\tif minT == nil || t.nextwhen < minWhen {\n-\t\t\t\t\tminT = t\n-\t\t\t\t\tminWhen = t.nextwhen\n-\t\t\t\t\tminP = pp\n+\t\t\t\tif atomic.Cas(&t.status, s, timerMoving) {\n+\t\t\t\t\tt.when = t.nextwhen\n+\t\t\t\t\ttimers[to] = t\n+\t\t\t\t\tsiftupTimer(timers, to)\n+\t\t\t\t\tto++\n+\t\t\t\t\tchangedHeap = true\n+\t\t\t\t\tif !atomic.Cas(&t.status, timerMoving, timerWaiting) {\n+\t\t\t\t\t\tbadTimer()\n+\t\t\t\t\t}\n+\t\t\t\t\tif s == timerModifiedEarlier {\n+\t\t\t\t\t\tcearlier++\n+\t\t\t\t\t}\n+\t\t\t\t\tcontinue nextTimer\n \t\t\t\t}\n-\t\t\t\tif s == timerModifiedEarlier {\n-\t\t\t\t\tc--\n+\t\t\tcase timerDeleted:\n+\t\t\t\tif atomic.Cas(&t.status, s, timerRemoving) {\n+\t\t\t\t\tt.pp = 0\n+\t\t\t\t\tcdel++\n+\t\t\t\t\tif !atomic.Cas(&t.status, timerRemoving, timerRemoved) {\n+\t\t\t\t\t\tbadTimer()\n+\t\t\t\t\t}\n+\t\t\t\t\tchangedHeap = true\n+\t\t\t\t\tcontinue nextTimer\n \t\t\t\t}\n-\t\t\tcase timerRunning, timerModifying, timerMoving:\n+\t\t\tcase timerModifying:\n+\t\t\t\t// Loop until modification complete.\n+\t\t\t\tosyield()\n+\t\t\tcase timerNoStatus, timerRemoved:\n+\t\t\t\t// We should not see these status values in a timer heap.\n+\t\t\t\tbadTimer()\n+\t\t\tcase timerRunning, timerRemoving, timerMoving:\n+\t\t\t\t// Some other P thinks it owns this timer,\n+\t\t\t\t// which should not happen.\n+\t\t\t\tbadTimer()\n+\t\t\tdefault:\n \t\t\t\tbadTimer()\n-\t\t\t}\n-\t\t\t// The timers are sorted, so we only have to check\n-\t\t\t// the first timer for each P, unless there are\n-\t\t\t// some timerModifiedEarlier timers. The number\n-\t\t\t// of timerModifiedEarlier timers is in the adjustTimers\n-\t\t\t// field, used to initialize c, above.\n-\t\t\tif c == 0 {\n-\t\t\t\tbreak\n \t\t\t}\n \t\t}\n \t}\n \n-\tif minT == nil || minWhen <= faketime {\n-\t\treturn nil\n+\t// Set remaining slots in timers slice to nil,\n+\t// so that the timer values can be garbage collected.\n+\tfor i := to; i < len(timers); i++ {\n+\t\ttimers[i] = nil\n+\t}\n+\n+\tatomic.Xadd(&pp.deletedTimers, -cdel)\n+\tatomic.Xadd(&pp.numTimers, -cdel)\n+\tatomic.Xadd(&pp.adjustTimers, -cearlier)\n+\n+\ttimers = timers[:to]\n+\tpp.timers = timers\n+\tupdateTimer0When(pp)\n+\n+\tif verifyTimers {\n+\t\tverifyTimerHeap(pp)\n+\t}\n+}\n+\n+// verifyTimerHeap verifies that the timer heap is in a valid state.\n+// This is only for debugging, and is only called if verifyTimers is true.\n+// The caller must have locked the timers.\n+func verifyTimerHeap(pp *p) {\n+\tfor i, t := range pp.timers {\n+\t\tif i == 0 {\n+\t\t\t// First timer has no parent.\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\t// The heap is 4-ary. See siftupTimer and siftdownTimer.\n+\t\tp := (i - 1) / 4\n+\t\tif t.when < pp.timers[p].when {\n+\t\t\tprint(\"bad timer heap at \", i, \": \", p, \": \", pp.timers[p].when, \", \", i, \": \", t.when, \"\\n\")\n+\t\t\tthrow(\"bad timer heap\")\n+\t\t}\n+\t}\n+\tif numTimers := int(atomic.Load(&pp.numTimers)); len(pp.timers) != numTimers {\n+\t\tprintln(\"timer heap len\", len(pp.timers), \"!= numTimers\", numTimers)\n+\t\tthrow(\"bad timer heap len\")\n \t}\n+}\n \n-\tfaketime = minWhen\n-\treturn minP\n+// updateTimer0When sets the P's timer0When field.\n+// The caller must have locked the timers for pp.\n+func updateTimer0When(pp *p) {\n+\tif len(pp.timers) == 0 {\n+\t\tatomic.Store64(&pp.timer0When, 0)\n+\t} else {\n+\t\tatomic.Store64(&pp.timer0When, uint64(pp.timers[0].when))\n+\t}\n }\n \n-// timeSleepUntil returns the time when the next timer should fire.\n-// This is only called by sysmon.\n-func timeSleepUntil() int64 {\n+// timeSleepUntil returns the time when the next timer should fire,\n+// and the P that holds the timer heap that that timer is on.\n+// This is only called by sysmon and checkdead.\n+func timeSleepUntil() (int64, *p) {\n \tnext := int64(maxWhen)\n+\tvar pret *p\n \n \t// Prevent allp slice changes. This is like retake.\n \tlock(&allpLock)\n@@ -907,8 +997,17 @@ func timeSleepUntil() int64 {\n \t\t\tcontinue\n \t\t}\n \n-\t\tlock(&pp.timersLock)\n \t\tc := atomic.Load(&pp.adjustTimers)\n+\t\tif c == 0 {\n+\t\t\tw := int64(atomic.Load64(&pp.timer0When))\n+\t\t\tif w != 0 && w < next {\n+\t\t\t\tnext = w\n+\t\t\t\tpret = pp\n+\t\t\t}\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\tlock(&pp.timersLock)\n \t\tfor _, t := range pp.timers {\n \t\t\tswitch s := atomic.Load(&t.status); s {\n \t\t\tcase timerWaiting:\n@@ -943,7 +1042,7 @@ func timeSleepUntil() int64 {\n \t}\n \tunlock(&allpLock)\n \n-\treturn next\n+\treturn next, pret\n }\n \n // Heap maintenance algorithms."}, {"sha": "358674b5ae8358b8bd4d02bd0ea24012c38394fc", "filename": "libgo/go/runtime/trace.go", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fruntime%2Ftrace.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fruntime%2Ftrace.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Ftrace.go?ref=0b3c2eed35d608d6541ecf004a9576b4eae0b4ef", "patch": "@@ -181,12 +181,9 @@ func traceBufPtrOf(b *traceBuf) traceBufPtr {\n // Most clients should use the runtime/trace package or the testing package's\n // -test.trace flag instead of calling StartTrace directly.\n func StartTrace() error {\n-\t// Stop the world so that we can take a consistent snapshot\n+\t// Stop the world, so that we can take a consistent snapshot\n \t// of all goroutines at the beginning of the trace.\n-\t// Do not stop the world during GC so we ensure we always see\n-\t// a consistent view of GC-related events (e.g. a start is always\n-\t// paired with an end).\n-\tstopTheWorldGC(\"start tracing\")\n+\tstopTheWorld(\"start tracing\")\n \n \t// We are in stop-the-world, but syscalls can finish and write to trace concurrently.\n \t// Exitsyscall could check trace.enabled long before and then suddenly wake up\n@@ -197,7 +194,7 @@ func StartTrace() error {\n \n \tif trace.enabled || trace.shutdown {\n \t\tunlock(&trace.bufLock)\n-\t\tstartTheWorldGC()\n+\t\tstartTheWorld()\n \t\treturn errorString(\"tracing is already enabled\")\n \t}\n \n@@ -268,7 +265,7 @@ func StartTrace() error {\n \n \tunlock(&trace.bufLock)\n \n-\tstartTheWorldGC()\n+\tstartTheWorld()\n \treturn nil\n }\n \n@@ -277,14 +274,14 @@ func StartTrace() error {\n func StopTrace() {\n \t// Stop the world so that we can collect the trace buffers from all p's below,\n \t// and also to avoid races with traceEvent.\n-\tstopTheWorldGC(\"stop tracing\")\n+\tstopTheWorld(\"stop tracing\")\n \n \t// See the comment in StartTrace.\n \tlock(&trace.bufLock)\n \n \tif !trace.enabled {\n \t\tunlock(&trace.bufLock)\n-\t\tstartTheWorldGC()\n+\t\tstartTheWorld()\n \t\treturn\n \t}\n \n@@ -321,7 +318,7 @@ func StopTrace() {\n \ttrace.shutdown = true\n \tunlock(&trace.bufLock)\n \n-\tstartTheWorldGC()\n+\tstartTheWorld()\n \n \t// The world is started but we've set trace.shutdown, so new tracing can't start.\n \t// Wait for the trace reader to flush pending buffers and stop."}, {"sha": "62c06e67d9d37436ec34c5469f5eb01f6eff63fa", "filename": "libgo/go/runtime/trace/trace_stack_test.go", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fruntime%2Ftrace%2Ftrace_stack_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fruntime%2Ftrace%2Ftrace_stack_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Ftrace%2Ftrace_stack_test.go?ref=0b3c2eed35d608d6541ecf004a9576b4eae0b4ef", "patch": "@@ -233,7 +233,6 @@ func TestTraceSymbolize(t *testing.T) {\n \t\t}},\n \t\t{trace.EvGomaxprocs, []frame{\n \t\t\t{\"runtime.startTheWorld\", 0}, // this is when the current gomaxprocs is logged.\n-\t\t\t{\"runtime.startTheWorldGC\", 0},\n \t\t\t{\"runtime.GOMAXPROCS\", 0},\n \t\t\t{\"runtime/trace_test.TestTraceSymbolize\", 0},\n \t\t\t{\"testing.tRunner\", 0},"}, {"sha": "a404a33e8785cec4fe1821130471448dc702fd5e", "filename": "libgo/go/runtime/utf8.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fruntime%2Futf8.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fruntime%2Futf8.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Futf8.go?ref=0b3c2eed35d608d6541ecf004a9576b4eae0b4ef", "patch": "@@ -13,7 +13,7 @@ import _ \"unsafe\" // For go:linkname.\n // Numbers fundamental to the encoding.\n const (\n \truneError = '\\uFFFD'     // the \"error\" Rune or \"Unicode replacement character\"\n-\truneSelf  = 0x80         // characters below Runeself are represented as themselves in a single byte.\n+\truneSelf  = 0x80         // characters below runeSelf are represented as themselves in a single byte.\n \tmaxRune   = '\\U0010FFFF' // Maximum valid Unicode code point.\n )\n "}, {"sha": "bcbdbc514d21a8b72f8f83fecd5cc8cb5b9d4c49", "filename": "libgo/go/strconv/quote.go", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fstrconv%2Fquote.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fstrconv%2Fquote.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fstrconv%2Fquote.go?ref=0b3c2eed35d608d6541ecf004a9576b4eae0b4ef", "patch": "@@ -145,8 +145,9 @@ func AppendQuoteToASCII(dst []byte, s string) []byte {\n }\n \n // QuoteToGraphic returns a double-quoted Go string literal representing s.\n-// The returned string uses Go escape sequences (\\t, \\n, \\xFF, \\u0100) for\n-// non-ASCII characters and non-printable characters as defined by IsGraphic.\n+// The returned string leaves Unicode graphic characters, as defined by\n+// IsGraphic, unchanged and uses Go escape sequences (\\t, \\n, \\xFF, \\u0100)\n+// for non-graphic characters.\n func QuoteToGraphic(s string) string {\n \treturn quoteWith(s, '\"', false, true)\n }\n@@ -185,9 +186,9 @@ func AppendQuoteRuneToASCII(dst []byte, r rune) []byte {\n }\n \n // QuoteRuneToGraphic returns a single-quoted Go character literal representing\n-// the rune. The returned string uses Go escape sequences (\\t, \\n, \\xFF,\n-// \\u0100) for non-ASCII characters and non-printable characters as defined\n-// by IsGraphic.\n+// the rune. If the rune is not a Unicode graphic character,\n+// as defined by IsGraphic, the returned string will use a Go escape sequence\n+// (\\t, \\n, \\xFF, \\u0100).\n func QuoteRuneToGraphic(r rune) string {\n \treturn quoteRuneWith(r, '\\'', false, true)\n }"}, {"sha": "238d657f61bd8d484c1a8c6b26d9b092c0478280", "filename": "libgo/go/strings/strings.go", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fstrings%2Fstrings.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fstrings%2Fstrings.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fstrings%2Fstrings.go?ref=0b3c2eed35d608d6541ecf004a9576b4eae0b4ef", "patch": "@@ -420,24 +420,24 @@ func FieldsFunc(s string, f func(rune) bool) []string {\n \treturn a\n }\n \n-// Join concatenates the elements of a to create a single string. The separator string\n-// sep is placed between elements in the resulting string.\n-func Join(a []string, sep string) string {\n-\tswitch len(a) {\n+// Join concatenates the elements of its first argument to create a single string. The separator\n+// string sep is placed between elements in the resulting string.\n+func Join(elems []string, sep string) string {\n+\tswitch len(elems) {\n \tcase 0:\n \t\treturn \"\"\n \tcase 1:\n-\t\treturn a[0]\n+\t\treturn elems[0]\n \t}\n-\tn := len(sep) * (len(a) - 1)\n-\tfor i := 0; i < len(a); i++ {\n-\t\tn += len(a[i])\n+\tn := len(sep) * (len(elems) - 1)\n+\tfor i := 0; i < len(elems); i++ {\n+\t\tn += len(elems[i])\n \t}\n \n \tvar b Builder\n \tb.Grow(n)\n-\tb.WriteString(a[0])\n-\tfor _, s := range a[1:] {\n+\tb.WriteString(elems[0])\n+\tfor _, s := range elems[1:] {\n \t\tb.WriteString(sep)\n \t\tb.WriteString(s)\n \t}"}, {"sha": "af0b8831997112c5a0da6d9dcfd3e068e1b893bd", "filename": "libgo/go/syscall/syscall_aix.go", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fsyscall%2Fsyscall_aix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Fsyscall%2Fsyscall_aix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Fsyscall_aix.go?ref=0b3c2eed35d608d6541ecf004a9576b4eae0b4ef", "patch": "@@ -4,7 +4,9 @@\n \n package syscall\n \n-import \"unsafe\"\n+import (\n+\t\"unsafe\"\n+)\n \n func (ts *StTimespec) Unix() (sec int64, nsec int64) {\n \treturn int64(ts.Sec), int64(ts.Nsec)"}, {"sha": "93f461b07a22d32e3ea6ee15ad077885de0b2679", "filename": "libgo/go/testing/benchmark.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Ftesting%2Fbenchmark.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Ftesting%2Fbenchmark.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftesting%2Fbenchmark.go?ref=0b3c2eed35d608d6541ecf004a9576b4eae0b4ef", "patch": "@@ -86,7 +86,7 @@ type InternalBenchmark struct {\n // may be called simultaneously from multiple goroutines.\n //\n // Like in tests, benchmark logs are accumulated during execution\n-// and dumped to standard error when done. Unlike in tests, benchmark logs\n+// and dumped to standard output when done. Unlike in tests, benchmark logs\n // are always printed, so as not to hide output whose existence may be\n // affecting benchmark results.\n type B struct {"}, {"sha": "6b8b95391df16e810e3d99b77253b8616277d17f", "filename": "libgo/go/testing/panic_test.go", "status": "modified", "additions": 128, "deletions": 1, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Ftesting%2Fpanic_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Ftesting%2Fpanic_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftesting%2Fpanic_test.go?ref=0b3c2eed35d608d6541ecf004a9576b4eae0b4ef", "patch": "@@ -16,6 +16,9 @@ import (\n )\n \n var testPanicTest = flag.String(\"test_panic_test\", \"\", \"TestPanic: indicates which test should panic\")\n+var testPanicParallel = flag.Bool(\"test_panic_parallel\", false, \"TestPanic: run subtests in parallel\")\n+var testPanicCleanup = flag.Bool(\"test_panic_cleanup\", false, \"TestPanic: indicates whether test should call Cleanup\")\n+var testPanicCleanupPanic = flag.String(\"test_panic_cleanup_panic\", \"\", \"TestPanic: indicate whether test should call Cleanup function that panics\")\n \n func TestPanic(t *testing.T) {\n \ttestenv.MustHaveExec(t)\n@@ -35,6 +38,98 @@ func TestPanic(t *testing.T) {\n \t\tdesc:  \"subtest panics\",\n \t\tflags: []string{\"-test_panic_test=TestPanicHelper/1\"},\n \t\twant: `\n+--- FAIL: TestPanicHelper (N.NNs)\n+    panic_test.go:NNN: TestPanicHelper\n+    --- FAIL: TestPanicHelper/1 (N.NNs)\n+        panic_test.go:NNN: TestPanicHelper/1\n+`,\n+\t}, {\n+\t\tdesc:  \"subtest panics with cleanup\",\n+\t\tflags: []string{\"-test_panic_test=TestPanicHelper/1\", \"-test_panic_cleanup\"},\n+\t\twant: `\n+ran inner cleanup 1\n+ran middle cleanup 1\n+ran outer cleanup\n+--- FAIL: TestPanicHelper (N.NNs)\n+    panic_test.go:NNN: TestPanicHelper\n+    --- FAIL: TestPanicHelper/1 (N.NNs)\n+        panic_test.go:NNN: TestPanicHelper/1\n+`,\n+\t}, {\n+\t\tdesc:  \"subtest panics with outer cleanup panic\",\n+\t\tflags: []string{\"-test_panic_test=TestPanicHelper/1\", \"-test_panic_cleanup\", \"-test_panic_cleanup_panic=outer\"},\n+\t\twant: `\n+ran inner cleanup 1\n+ran middle cleanup 1\n+ran outer cleanup\n+--- FAIL: TestPanicHelper (N.NNs)\n+    panic_test.go:NNN: TestPanicHelper\n+`,\n+\t}, {\n+\t\tdesc:  \"subtest panics with middle cleanup panic\",\n+\t\tflags: []string{\"-test_panic_test=TestPanicHelper/1\", \"-test_panic_cleanup\", \"-test_panic_cleanup_panic=middle\"},\n+\t\twant: `\n+ran inner cleanup 1\n+ran middle cleanup 1\n+ran outer cleanup\n+--- FAIL: TestPanicHelper (N.NNs)\n+    panic_test.go:NNN: TestPanicHelper\n+    --- FAIL: TestPanicHelper/1 (N.NNs)\n+        panic_test.go:NNN: TestPanicHelper/1\n+`,\n+\t}, {\n+\t\tdesc:  \"subtest panics with inner cleanup panic\",\n+\t\tflags: []string{\"-test_panic_test=TestPanicHelper/1\", \"-test_panic_cleanup\", \"-test_panic_cleanup_panic=inner\"},\n+\t\twant: `\n+ran inner cleanup 1\n+ran middle cleanup 1\n+ran outer cleanup\n+--- FAIL: TestPanicHelper (N.NNs)\n+    panic_test.go:NNN: TestPanicHelper\n+    --- FAIL: TestPanicHelper/1 (N.NNs)\n+        panic_test.go:NNN: TestPanicHelper/1\n+`,\n+\t}, {\n+\t\tdesc:  \"parallel subtest panics with cleanup\",\n+\t\tflags: []string{\"-test_panic_test=TestPanicHelper/1\", \"-test_panic_cleanup\", \"-test_panic_parallel\"},\n+\t\twant: `\n+ran inner cleanup 1\n+ran middle cleanup 1\n+ran outer cleanup\n+--- FAIL: TestPanicHelper (N.NNs)\n+    panic_test.go:NNN: TestPanicHelper\n+    --- FAIL: TestPanicHelper/1 (N.NNs)\n+        panic_test.go:NNN: TestPanicHelper/1\n+`,\n+\t}, {\n+\t\tdesc:  \"parallel subtest panics with outer cleanup panic\",\n+\t\tflags: []string{\"-test_panic_test=TestPanicHelper/1\", \"-test_panic_cleanup\", \"-test_panic_cleanup_panic=outer\", \"-test_panic_parallel\"},\n+\t\twant: `\n+ran inner cleanup 1\n+ran middle cleanup 1\n+ran outer cleanup\n+--- FAIL: TestPanicHelper (N.NNs)\n+    panic_test.go:NNN: TestPanicHelper\n+`,\n+\t}, {\n+\t\tdesc:  \"parallel subtest panics with middle cleanup panic\",\n+\t\tflags: []string{\"-test_panic_test=TestPanicHelper/1\", \"-test_panic_cleanup\", \"-test_panic_cleanup_panic=middle\", \"-test_panic_parallel\"},\n+\t\twant: `\n+ran inner cleanup 1\n+ran middle cleanup 1\n+ran outer cleanup\n+--- FAIL: TestPanicHelper (N.NNs)\n+    panic_test.go:NNN: TestPanicHelper\n+    --- FAIL: TestPanicHelper/1 (N.NNs)\n+        panic_test.go:NNN: TestPanicHelper/1\n+`,\n+\t}, {\n+\t\tdesc:  \"parallel subtest panics with inner cleanup panic\",\n+\t\tflags: []string{\"-test_panic_test=TestPanicHelper/1\", \"-test_panic_cleanup\", \"-test_panic_cleanup_panic=inner\", \"-test_panic_parallel\"},\n+\t\twant: `\n+ran inner cleanup 1\n+ran middle cleanup 1\n+ran outer cleanup\n --- FAIL: TestPanicHelper (N.NNs)\n     panic_test.go:NNN: TestPanicHelper\n     --- FAIL: TestPanicHelper/1 (N.NNs)\n@@ -72,10 +167,42 @@ func TestPanicHelper(t *testing.T) {\n \tif t.Name() == *testPanicTest {\n \t\tpanic(\"panic\")\n \t}\n+\tswitch *testPanicCleanupPanic {\n+\tcase \"\", \"outer\", \"middle\", \"inner\":\n+\tdefault:\n+\t\tt.Fatalf(\"bad -test_panic_cleanup_panic: %s\", *testPanicCleanupPanic)\n+\t}\n+\tt.Cleanup(func() {\n+\t\tfmt.Println(\"ran outer cleanup\")\n+\t\tif *testPanicCleanupPanic == \"outer\" {\n+\t\t\tpanic(\"outer cleanup\")\n+\t\t}\n+\t})\n \tfor i := 0; i < 3; i++ {\n+\t\ti := i\n \t\tt.Run(fmt.Sprintf(\"%v\", i), func(t *testing.T) {\n+\t\t\tchosen := t.Name() == *testPanicTest\n+\t\t\tif chosen && *testPanicCleanup {\n+\t\t\t\tt.Cleanup(func() {\n+\t\t\t\t\tfmt.Printf(\"ran middle cleanup %d\\n\", i)\n+\t\t\t\t\tif *testPanicCleanupPanic == \"middle\" {\n+\t\t\t\t\t\tpanic(\"middle cleanup\")\n+\t\t\t\t\t}\n+\t\t\t\t})\n+\t\t\t}\n+\t\t\tif chosen && *testPanicParallel {\n+\t\t\t\tt.Parallel()\n+\t\t\t}\n \t\t\tt.Log(t.Name())\n-\t\t\tif t.Name() == *testPanicTest {\n+\t\t\tif chosen {\n+\t\t\t\tif *testPanicCleanup {\n+\t\t\t\t\tt.Cleanup(func() {\n+\t\t\t\t\t\tfmt.Printf(\"ran inner cleanup %d\\n\", i)\n+\t\t\t\t\t\tif *testPanicCleanupPanic == \"inner\" {\n+\t\t\t\t\t\t\tpanic(\"inner cleanup\")\n+\t\t\t\t\t\t}\n+\t\t\t\t\t})\n+\t\t\t\t}\n \t\t\t\tpanic(\"panic\")\n \t\t\t}\n \t\t})"}, {"sha": "3dc30ee72e2077ecd79f078ccf1395978a0d1a93", "filename": "libgo/go/testing/sub_test.go", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Ftesting%2Fsub_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Ftesting%2Fsub_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftesting%2Fsub_test.go?ref=0b3c2eed35d608d6541ecf004a9576b4eae0b4ef", "patch": "@@ -460,6 +460,21 @@ func TestTRun(t *T) {\n \t\t\t<-ch\n \t\t\tt.Errorf(\"error\")\n \t\t},\n+\t}, {\n+\t\t// If a subtest panics we should run cleanups.\n+\t\tdesc:   \"cleanup when subtest panics\",\n+\t\tok:     false,\n+\t\tchatty: false,\n+\t\toutput: `\n+--- FAIL: cleanup when subtest panics (N.NNs)\n+    --- FAIL: cleanup when subtest panics/sub (N.NNs)\n+    sub_test.go:NNN: running cleanup`,\n+\t\tf: func(t *T) {\n+\t\t\tt.Cleanup(func() { t.Log(\"running cleanup\") })\n+\t\t\tt.Run(\"sub\", func(t2 *T) {\n+\t\t\t\tt2.FailNow()\n+\t\t\t})\n+\t\t},\n \t}}\n \tfor _, tc := range testCases {\n \t\tctx := newTestContext(tc.maxPar, newMatcher(regexp.MatchString, \"\", \"\"))\n@@ -855,3 +870,19 @@ func TestRunCleanup(t *T) {\n \t\tt.Errorf(\"unexpected outer cleanup count; got %d want 0\", outerCleanup)\n \t}\n }\n+\n+func TestCleanupParallelSubtests(t *T) {\n+\tranCleanup := 0\n+\tt.Run(\"test\", func(t *T) {\n+\t\tt.Cleanup(func() { ranCleanup++ })\n+\t\tt.Run(\"x\", func(t *T) {\n+\t\t\tt.Parallel()\n+\t\t\tif ranCleanup > 0 {\n+\t\t\t\tt.Error(\"outer cleanup ran before parallel subtest\")\n+\t\t\t}\n+\t\t})\n+\t})\n+\tif ranCleanup != 1 {\n+\t\tt.Errorf(\"unexpected cleanup count; got %d want 1\", ranCleanup)\n+\t}\n+}"}, {"sha": "67892d71fd07334aa2024a290f6d37aef53b4d7e", "filename": "libgo/go/testing/testing.go", "status": "modified", "additions": 47, "deletions": 8, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Ftesting%2Ftesting.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Ftesting%2Ftesting.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftesting%2Ftesting.go?ref=0b3c2eed35d608d6541ecf004a9576b4eae0b4ef", "patch": "@@ -812,9 +812,9 @@ func (c *common) Helper() {\n \tc.helpers[callerName(1)] = struct{}{}\n }\n \n-// Cleanup registers a function to be called when the test finishes.\n-// Cleanup functions will be called in last added, first called\n-// order.\n+// Cleanup registers a function to be called when the test and all its\n+// subtests complete. Cleanup functions will be called in last added,\n+// first called order.\n func (c *common) Cleanup(f func()) {\n \tc.mu.Lock()\n \tdefer c.mu.Unlock()\n@@ -827,15 +827,34 @@ func (c *common) Cleanup(f func()) {\n \t}\n }\n \n+// panicHanding is an argument to runCleanup.\n+type panicHandling int\n+\n+const (\n+\tnormalPanic panicHandling = iota\n+\trecoverAndReturnPanic\n+)\n+\n // runCleanup is called at the end of the test.\n-func (c *common) runCleanup() {\n+// If catchPanic is true, this will catch panics, and return the recovered\n+// value if any.\n+func (c *common) runCleanup(ph panicHandling) (panicVal interface{}) {\n \tc.mu.Lock()\n \tcleanup := c.cleanup\n \tc.cleanup = nil\n \tc.mu.Unlock()\n-\tif cleanup != nil {\n-\t\tcleanup()\n+\tif cleanup == nil {\n+\t\treturn nil\n+\t}\n+\n+\tif ph == recoverAndReturnPanic {\n+\t\tdefer func() {\n+\t\t\tpanicVal = recover()\n+\t\t}()\n \t}\n+\n+\tcleanup()\n+\treturn nil\n }\n \n // callerName gives the function name (qualified with a package path)\n@@ -938,19 +957,29 @@ func tRunner(t *T, fn func(t *T)) {\n \t\t\t\t}\n \t\t\t}\n \t\t}\n-\t\tif err != nil {\n+\n+\t\tdoPanic := func(err interface{}) {\n \t\t\tt.Fail()\n+\t\t\tif r := t.runCleanup(recoverAndReturnPanic); r != nil {\n+\t\t\t\tt.Logf(\"cleanup panicked with %v\", r)\n+\t\t\t}\n \t\t\t// Flush the output log up to the root before dying.\n \t\t\tt.mu.Lock()\n \t\t\troot := &t.common\n \t\t\tfor ; root.parent != nil; root = root.parent {\n \t\t\t\troot.duration += time.Since(root.start)\n \t\t\t\tfmt.Fprintf(root.parent.w, \"--- FAIL: %s (%s)\\n\", root.name, fmtDuration(root.duration))\n+\t\t\t\tif r := root.parent.runCleanup(recoverAndReturnPanic); r != nil {\n+\t\t\t\t\tfmt.Fprintf(root.parent.w, \"cleanup panicked with %v\", r)\n+\t\t\t\t}\n \t\t\t\troot.parent.mu.Lock()\n \t\t\t\tio.Copy(root.parent.w, bytes.NewReader(root.output))\n \t\t\t}\n \t\t\tpanic(err)\n \t\t}\n+\t\tif err != nil {\n+\t\t\tdoPanic(err)\n+\t\t}\n \n \t\tt.duration += time.Since(t.start)\n \n@@ -964,6 +993,12 @@ func tRunner(t *T, fn func(t *T)) {\n \t\t\tfor _, sub := range t.sub {\n \t\t\t\t<-sub.signal\n \t\t\t}\n+\t\t\tcleanupStart := time.Now()\n+\t\t\terr := t.runCleanup(recoverAndReturnPanic)\n+\t\t\tt.duration += time.Since(cleanupStart)\n+\t\t\tif err != nil {\n+\t\t\t\tdoPanic(err)\n+\t\t\t}\n \t\t\tif !t.isParallel {\n \t\t\t\t// Reacquire the count for sequential tests. See comment in Run.\n \t\t\t\tt.context.waitParallel()\n@@ -983,7 +1018,11 @@ func tRunner(t *T, fn func(t *T)) {\n \t\t}\n \t\tt.signal <- signal\n \t}()\n-\tdefer t.runCleanup()\n+\tdefer func() {\n+\t\tif len(t.sub) == 0 {\n+\t\t\tt.runCleanup(normalPanic)\n+\t\t}\n+\t}()\n \n \tt.start = time.Now()\n \tt.raceErrors = -race.Errors()"}, {"sha": "f92ac6f92ff6655ef220ba3f173327d140138672", "filename": "libgo/go/text/template/exec_test.go", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Ftext%2Ftemplate%2Fexec_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Ftext%2Ftemplate%2Fexec_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftext%2Ftemplate%2Fexec_test.go?ref=0b3c2eed35d608d6541ecf004a9576b4eae0b4ef", "patch": "@@ -502,6 +502,7 @@ var execTests = []execTest{\n \t{\"map MUI64S\", \"{{index .MUI64S 3}}\", \"ui643\", tVal, true},\n \t{\"map MI8S\", \"{{index .MI8S 3}}\", \"i83\", tVal, true},\n \t{\"map MUI8S\", \"{{index .MUI8S 2}}\", \"u82\", tVal, true},\n+\t{\"index of an interface field\", \"{{index .Empty3 0}}\", \"7\", tVal, true},\n \n \t// Slicing.\n \t{\"slice[:]\", \"{{slice .SI}}\", \"[3 4 5]\", tVal, true},\n@@ -527,12 +528,14 @@ var execTests = []execTest{\n \t{\"string[1:2]\", \"{{slice .S 1 2}}\", \"y\", tVal, true},\n \t{\"out of range\", \"{{slice .S 1 5}}\", \"\", tVal, false},\n \t{\"3-index slice of string\", \"{{slice .S 1 2 2}}\", \"\", tVal, false},\n+\t{\"slice of an interface field\", \"{{slice .Empty3 0 1}}\", \"[7]\", tVal, true},\n \n \t// Len.\n \t{\"slice\", \"{{len .SI}}\", \"3\", tVal, true},\n \t{\"map\", \"{{len .MSI }}\", \"3\", tVal, true},\n \t{\"len of int\", \"{{len 3}}\", \"\", tVal, false},\n \t{\"len of nothing\", \"{{len .Empty0}}\", \"\", tVal, false},\n+\t{\"len of an interface field\", \"{{len .Empty3}}\", \"2\", tVal, true},\n \n \t// With.\n \t{\"with true\", \"{{with true}}{{.}}{{end}}\", \"true\", tVal, true},"}, {"sha": "46125bc2168b9dffc1545d382b2b9350074706f8", "filename": "libgo/go/text/template/funcs.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Ftext%2Ftemplate%2Ffuncs.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Ftext%2Ftemplate%2Ffuncs.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftext%2Ftemplate%2Ffuncs.go?ref=0b3c2eed35d608d6541ecf004a9576b4eae0b4ef", "patch": "@@ -264,13 +264,13 @@ func slice(item reflect.Value, indexes ...reflect.Value) (reflect.Value, error)\n \t\treturn reflect.Value{}, fmt.Errorf(\"invalid slice index: %d > %d\", idx[0], idx[1])\n \t}\n \tif len(indexes) < 3 {\n-\t\treturn item.Slice(idx[0], idx[1]), nil\n+\t\treturn v.Slice(idx[0], idx[1]), nil\n \t}\n \t// given item[i:j:k], make sure i <= j <= k.\n \tif idx[1] > idx[2] {\n \t\treturn reflect.Value{}, fmt.Errorf(\"invalid slice index: %d > %d\", idx[1], idx[2])\n \t}\n-\treturn item.Slice3(idx[0], idx[1], idx[2]), nil\n+\treturn v.Slice3(idx[0], idx[1], idx[2]), nil\n }\n \n // Length"}, {"sha": "30371f28626761633106b1dc4460833cff83a9a6", "filename": "libgo/go/text/template/parse/lex.go", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Ftext%2Ftemplate%2Fparse%2Flex.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Ftext%2Ftemplate%2Fparse%2Flex.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftext%2Ftemplate%2Fparse%2Flex.go?ref=0b3c2eed35d608d6541ecf004a9576b4eae0b4ef", "patch": "@@ -411,7 +411,6 @@ func lexInsideAction(l *lexer) stateFn {\n \t\t}\n \tcase r <= unicode.MaxASCII && unicode.IsPrint(r):\n \t\tl.emit(itemChar)\n-\t\treturn lexInsideAction\n \tdefault:\n \t\treturn l.errorf(\"unrecognized character in action: %#U\", r)\n \t}"}, {"sha": "9beb5d9a48fcbbd4d3f8c1f9f0021e207e38bb11", "filename": "libgo/go/time/format.go", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Ftime%2Fformat.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Ftime%2Fformat.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftime%2Fformat.go?ref=0b3c2eed35d608d6541ecf004a9576b4eae0b4ef", "patch": "@@ -792,6 +792,9 @@ func skip(value, prefix string) (string, error) {\n // Years must be in the range 0000..9999. The day of the week is checked\n // for syntax but it is otherwise ignored.\n //\n+// For layouts specifying the two-digit year 06, a value NN >= 69 will be treated\n+// as 19NN and a value NN < 69 will be treated as 20NN.\n+//\n // In the absence of a time zone indicator, Parse returns a time in UTC.\n //\n // When parsing a time with a zone offset like -0700, if the offset corresponds"}, {"sha": "9c4de6deb532aa9830cd24316aa005927ae6e4f9", "filename": "libgo/go/time/sleep_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Ftime%2Fsleep_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Ftime%2Fsleep_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftime%2Fsleep_test.go?ref=0b3c2eed35d608d6541ecf004a9576b4eae0b4ef", "patch": "@@ -357,7 +357,7 @@ func TestTimerStopStress(t *testing.T) {\n \tfor i := 0; i < 100; i++ {\n \t\tgo func(i int) {\n \t\t\ttimer := AfterFunc(2*Second, func() {\n-\t\t\t\tt.Fatalf(\"timer %d was not stopped\", i)\n+\t\t\t\tt.Errorf(\"timer %d was not stopped\", i)\n \t\t\t})\n \t\t\tSleep(1 * Second)\n \t\t\ttimer.Stop()"}, {"sha": "5dc9fa68ac17a5bc5d125dc1e52d1aff190ded8c", "filename": "libgo/go/time/time.go", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Ftime%2Ftime.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Ftime%2Ftime.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftime%2Ftime.go?ref=0b3c2eed35d608d6541ecf004a9576b4eae0b4ef", "patch": "@@ -1148,6 +1148,9 @@ func (t Time) Zone() (name string, offset int) {\n // Unix returns t as a Unix time, the number of seconds elapsed\n // since January 1, 1970 UTC. The result does not depend on the\n // location associated with t.\n+// Unix-like operating systems often record time as a 32-bit\n+// count of seconds, but since the method here returns a 64-bit\n+// value it is valid for billions of years into the past or future.\n func (t Time) Unix() int64 {\n \treturn t.unixSec()\n }"}, {"sha": "b8368fce41e83443ffb44c967ac91e755b593c82", "filename": "libgo/go/unicode/utf8/utf8.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Funicode%2Futf8%2Futf8.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fgo%2Funicode%2Futf8%2Futf8.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Funicode%2Futf8%2Futf8.go?ref=0b3c2eed35d608d6541ecf004a9576b4eae0b4ef", "patch": "@@ -14,7 +14,7 @@ package utf8\n // Numbers fundamental to the encoding.\n const (\n \tRuneError = '\\uFFFD'     // the \"error\" Rune or \"Unicode replacement character\"\n-\tRuneSelf  = 0x80         // characters below Runeself are represented as themselves in a single byte.\n+\tRuneSelf  = 0x80         // characters below RuneSelf are represented as themselves in a single byte.\n \tMaxRune   = '\\U0010FFFF' // Maximum valid Unicode code point.\n \tUTFMax    = 4            // maximum number of bytes of a UTF-8 encoded Unicode character.\n )"}, {"sha": "bddb1320098b340401b6a974c15552cd18bafd3d", "filename": "libgo/merge.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fmerge.sh", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fmerge.sh", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmerge.sh?ref=0b3c2eed35d608d6541ecf004a9576b4eae0b4ef", "patch": "@@ -150,7 +150,7 @@ done\n (cd ${NEWDIR}/src && find . -name testdata -print) | while read d; do\n   skip=false\n   case \"$d\" in\n-  ./cmd/buildid/* | ./cmd/cgo/* | ./cmd/go/* | ./cmd/gofmt/* | ./cmd/testjson/* | ./cmd/vet/* | ./cmd/internal/browser/* | ./cmd/internal/buildid/* | ./cmd/internal/diff/* | | ./cmd/internal/edit/* | ./cmd/internal/objabi/* | ./cmd/internal/testj2on/* | ./cmd/internal/sys/* | ./cmd/vendor/golang.org/x/tools/* )\n+  ./cmd/buildid/* | ./cmd/cgo/* | ./cmd/go/* | ./cmd/gofmt/* | ./cmd/testjson/* | ./cmd/vet/* | ./cmd/internal/browser/* | ./cmd/internal/buildid/* | ./cmd/internal/diff/* | ./cmd/internal/edit/* | ./cmd/internal/objabi/* | ./cmd/internal/testj2on/* | ./cmd/internal/sys/* | ./cmd/vendor/golang.org/x/tools/*)\n     ;;\n   ./cmd/*)\n     skip=true"}, {"sha": "d13246bd84afdea8995c2e1ab2b5a2c69c2cc4ca", "filename": "libgo/misc/cgo/test/issue21897.go", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue21897.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue21897.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue21897.go?ref=0b3c2eed35d608d6541ecf004a9576b4eae0b4ef", "patch": "@@ -2,16 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// We skip this test in race mode because, for unknown reasons,\n-// linking against CoreFoundation on macOS 10.10 causes mmap to ignore\n-// the hint address, which makes the Go allocator incompatible with\n-// TSAN. See golang.org/issue/26475.\n-//\n-// TODO(austin): Once support for macOS 10.10 is dropped, remove the\n-// race constraint (and the one in issue21897b.go). See\n-// golang.org/issue/26513.\n-\n-// +build darwin,cgo,!internal,!race\n+// +build darwin,cgo,!internal\n \n package cgotest\n "}, {"sha": "08b5f4d808e240853d6b666ffd41ba2b5192d75f", "filename": "libgo/misc/cgo/test/issue21897b.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue21897b.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue21897b.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftest%2Fissue21897b.go?ref=0b3c2eed35d608d6541ecf004a9576b4eae0b4ef", "patch": "@@ -2,7 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// +build !darwin !cgo internal race\n+// +build !darwin !cgo internal\n \n package cgotest\n "}, {"sha": "e60eb4e9178c3a8ba0430089837928a37eb684cf", "filename": "libgo/misc/cgo/test/testdata/issue24161_darwin_test.go", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fmisc%2Fcgo%2Ftest%2Ftestdata%2Fissue24161_darwin_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fmisc%2Fcgo%2Ftest%2Ftestdata%2Fissue24161_darwin_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftest%2Ftestdata%2Fissue24161_darwin_test.go?ref=0b3c2eed35d608d6541ecf004a9576b4eae0b4ef", "patch": "@@ -2,14 +2,6 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// See issue21897.go and golang.org/issue/26475 for why this is\n-// skipped in race mode.\n-//\n-// TODO(austin): Once support for macOS 10.10 is dropped, remove the\n-// race constraint. See golang.org/issue/26513.\n-\n-// +build !race\n-\n package cgotest\n \n import ("}, {"sha": "efe53458d8709c9dfc0ffe2b42094d001335e6a8", "filename": "libgo/misc/cgo/test/testdata/issue24161e0/main.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fmisc%2Fcgo%2Ftest%2Ftestdata%2Fissue24161e0%2Fmain.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fmisc%2Fcgo%2Ftest%2Ftestdata%2Fissue24161e0%2Fmain.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftest%2Ftestdata%2Fissue24161e0%2Fmain.go?ref=0b3c2eed35d608d6541ecf004a9576b4eae0b4ef", "patch": "@@ -12,7 +12,7 @@ package issue24161e0\n #include <TargetConditionals.h>\n #include <CoreFoundation/CoreFoundation.h>\n #include <Security/Security.h>\n-#if TARGET_OS_IPHONE == 0 && __ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__ < 101200\n+#if TARGET_OS_IPHONE == 0 && __MAC_OS_X_VERSION_MAX_ALLOWED < 101200\n   typedef CFStringRef SecKeyAlgorithm;\n   static CFDataRef SecKeyCreateSignature(SecKeyRef key, SecKeyAlgorithm algorithm, CFDataRef dataToSign, CFErrorRef *error){return NULL;}\n   #define kSecKeyAlgorithmECDSASignatureDigestX962SHA1 foo()"}, {"sha": "82bf172b7d79481f7b620ecbb6e80b9698d7161c", "filename": "libgo/misc/cgo/test/testdata/issue24161e1/main.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fmisc%2Fcgo%2Ftest%2Ftestdata%2Fissue24161e1%2Fmain.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fmisc%2Fcgo%2Ftest%2Ftestdata%2Fissue24161e1%2Fmain.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftest%2Ftestdata%2Fissue24161e1%2Fmain.go?ref=0b3c2eed35d608d6541ecf004a9576b4eae0b4ef", "patch": "@@ -12,7 +12,7 @@ package issue24161e1\n #include <TargetConditionals.h>\n #include <CoreFoundation/CoreFoundation.h>\n #include <Security/Security.h>\n-#if TARGET_OS_IPHONE == 0 && __ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__ < 101200\n+#if TARGET_OS_IPHONE == 0 && __MAC_OS_X_VERSION_MAX_ALLOWED < 101200\n   typedef CFStringRef SecKeyAlgorithm;\n   static CFDataRef SecKeyCreateSignature(SecKeyRef key, SecKeyAlgorithm algorithm, CFDataRef dataToSign, CFErrorRef *error){return NULL;}\n   #define kSecKeyAlgorithmECDSASignatureDigestX962SHA1 foo()"}, {"sha": "82d2ec1296cca16845bb3d69ede14e628c6bc25f", "filename": "libgo/misc/cgo/test/testdata/issue24161e2/main.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fmisc%2Fcgo%2Ftest%2Ftestdata%2Fissue24161e2%2Fmain.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b3c2eed35d608d6541ecf004a9576b4eae0b4ef/libgo%2Fmisc%2Fcgo%2Ftest%2Ftestdata%2Fissue24161e2%2Fmain.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ftest%2Ftestdata%2Fissue24161e2%2Fmain.go?ref=0b3c2eed35d608d6541ecf004a9576b4eae0b4ef", "patch": "@@ -12,7 +12,7 @@ package issue24161e2\n #include <TargetConditionals.h>\n #include <CoreFoundation/CoreFoundation.h>\n #include <Security/Security.h>\n-#if TARGET_OS_IPHONE == 0 && __ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__ < 101200\n+#if TARGET_OS_IPHONE == 0 && __MAC_OS_X_VERSION_MAX_ALLOWED < 101200\n   typedef CFStringRef SecKeyAlgorithm;\n   static CFDataRef SecKeyCreateSignature(SecKeyRef key, SecKeyAlgorithm algorithm, CFDataRef dataToSign, CFErrorRef *error){return NULL;}\n   #define kSecKeyAlgorithmECDSASignatureDigestX962SHA1 foo()"}]}