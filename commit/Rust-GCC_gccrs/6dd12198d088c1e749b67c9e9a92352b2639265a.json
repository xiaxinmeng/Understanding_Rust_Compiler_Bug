{"sha": "6dd12198d088c1e749b67c9e9a92352b2639265a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmRkMTIxOThkMDg4YzFlNzQ5YjY3YzllOWE5MjM1MmIyNjM5MjY1YQ==", "commit": {"author": {"name": "Steve Ellcey", "email": "sje@cup.hp.com", "date": "2001-07-19T23:26:51Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2001-07-19T23:26:51Z"}, "message": "* tm.texi (POINTERS_EXTEND_UNSIGNED) Modify definition.\n\n\t* optabs.c (can_extend_p) Check HAVE_ptr_extend for a specialized\n\tpointer extension instruction.\n\t* combine.c (nonzero_bits,num_sign_bit_copies) Likewise.\n\t* simplify-rtx.c (simplify_unary_operation) Likewise.\n\t* explow.c (convert_memory_address) Check value of\n\tPOINTERS_EXTEND_UNSIGNED to avoid some conversions when\n\tless than zero.\n\t* config/ia64/t-hpux (LIBGCC, INSTALL_LIBGCC, MULTILIB_OPTIONS,\n\tMULTILIB_DIRNAMES, MULTILIB_MATCHES) Add multilib support.\n\t* config/ia64/hpux.h (CPP_SPEC, ASM_SPEC, SUBTARGET_SWITCHES)\n\tAdd Multilib Support.\n\t(POINTERS_EXTEND_UNSIGNED)  Define for ILP32 support.\n\t* config/ia64/ia64.h (MASK_ILP32, TARGET_ILP32, SUBTARGET_SWITCHES)\n\tAdd Multilib Support.\n\t(POINTER_SIZE, LONG_TYPE_SIZE, MAX_LONG_TYPE_SIZE) Modify for ILP32\n\tsupport.\n\t* config/ia64/ia64.c (rtx_needs_barrier) Add support for addp4.\n\t* config/ia64/ia64.md (ptr_extend) New instruction to \"swizzle\"\n\ta 32 bit HP-UX pointer into a 64 bit HP-UX pointer.\n\nFrom-SVN: r44166", "tree": {"sha": "a9b47fb91c9fd09f19a418557090e5dd7abf596d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a9b47fb91c9fd09f19a418557090e5dd7abf596d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6dd12198d088c1e749b67c9e9a92352b2639265a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6dd12198d088c1e749b67c9e9a92352b2639265a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6dd12198d088c1e749b67c9e9a92352b2639265a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6dd12198d088c1e749b67c9e9a92352b2639265a/comments", "author": null, "committer": null, "parents": [{"sha": "0248ce054752e353be11bdf52dae7c5f6d2cb7f0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0248ce054752e353be11bdf52dae7c5f6d2cb7f0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0248ce054752e353be11bdf52dae7c5f6d2cb7f0"}], "stats": {"total": 163, "additions": 124, "deletions": 39}, "files": [{"sha": "5850d78669060deed3ffb6aca25e93afbb8b1e52", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6dd12198d088c1e749b67c9e9a92352b2639265a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6dd12198d088c1e749b67c9e9a92352b2639265a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6dd12198d088c1e749b67c9e9a92352b2639265a", "patch": "@@ -1,3 +1,26 @@\n+2001-07-19  Steve Ellcey <sje@cup.hp.com>\n+\n+\t* tm.texi (POINTERS_EXTEND_UNSIGNED) Modify definition.\n+\t* optabs.c (can_extend_p) Check HAVE_ptr_extend for a specialized\n+\tpointer extension instruction.\n+\t* combine.c (nonzero_bits,num_sign_bit_copies) Likewise.\n+\t* simplify-rtx.c (simplify_unary_operation) Likewise.\n+\t* explow.c (convert_memory_address) Check value of \n+\tPOINTERS_EXTEND_UNSIGNED to avoid some conversions when\n+\tless than zero.\n+\t* config/ia64/t-hpux (LIBGCC, INSTALL_LIBGCC, MULTILIB_OPTIONS,\n+\tMULTILIB_DIRNAMES, MULTILIB_MATCHES) Add multilib support.\n+\t* config/ia64/hpux.h (CPP_SPEC, ASM_SPEC, SUBTARGET_SWITCHES)\n+\tAdd Multilib Support.\n+\t(POINTERS_EXTEND_UNSIGNED)  Define for ILP32 support.\n+\t* config/ia64/ia64.h (MASK_ILP32, TARGET_ILP32, SUBTARGET_SWITCHES)\n+\tAdd Multilib Support.\n+\t(POINTER_SIZE, LONG_TYPE_SIZE, MAX_LONG_TYPE_SIZE) Modify for ILP32\n+\tsupport.\n+\t* config/ia64/ia64.c (rtx_needs_barrier) Add support for addp4.\n+\t* config/ia64/ia64.md (ptr_extend) New instruction to \"swizzle\"\n+\ta 32 bit HP-UX pointer into a 64 bit HP-UX pointer.\n+\n 2001-07-19  Alexandre Oliva  <aoliva@redhat.com>\n \n \t* simplify-rtx.c (simplify_replace_rtx): Try to obtain mode from"}, {"sha": "8658aadbddb1a5a2fbcf5a206b548f61ee2b480d", "filename": "gcc/combine.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6dd12198d088c1e749b67c9e9a92352b2639265a/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6dd12198d088c1e749b67c9e9a92352b2639265a/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=6dd12198d088c1e749b67c9e9a92352b2639265a", "patch": "@@ -7905,7 +7905,7 @@ nonzero_bits (x, mode)\n   switch (code)\n     {\n     case REG:\n-#ifdef POINTERS_EXTEND_UNSIGNED\n+#if defined(POINTERS_EXTEND_UNSIGNED) && !defined(HAVE_ptr_extend)\n       /* If pointers extend unsigned and this is a pointer in Pmode, say that\n \t all the bits above ptr_mode are known to be zero.  */\n       if (POINTERS_EXTEND_UNSIGNED && GET_MODE (x) == Pmode\n@@ -8182,7 +8182,7 @@ nonzero_bits (x, mode)\n \t/* If pointers extend unsigned and this is an addition or subtraction\n \t   to a pointer in Pmode, all the bits above ptr_mode are known to be\n \t   zero.  */\n-\tif (POINTERS_EXTEND_UNSIGNED && GET_MODE (x) == Pmode\n+\tif (POINTERS_EXTEND_UNSIGNED > 0 && GET_MODE (x) == Pmode\n \t    && (code == PLUS || code == MINUS)\n \t    && GET_CODE (XEXP (x, 0)) == REG && REG_POINTER (XEXP (x, 0)))\n \t  nonzero &= GET_MODE_MASK (ptr_mode);\n@@ -8363,7 +8363,7 @@ num_sign_bit_copies (x, mode)\n     {\n     case REG:\n \n-#ifdef POINTERS_EXTEND_UNSIGNED\n+#if defined(POINTERS_EXTEND_UNSIGNED) && !defined(HAVE_ptr_extend)\n       /* If pointers extend signed and this is a pointer in Pmode, say that\n \t all the bits above ptr_mode are known to be sign bit copies.  */\n       if (! POINTERS_EXTEND_UNSIGNED && GET_MODE (x) == Pmode && mode == Pmode"}, {"sha": "c9df25bc818a9525a5d8d1c8f970a7f4aa4e5988", "filename": "gcc/config/ia64/hpux.h", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6dd12198d088c1e749b67c9e9a92352b2639265a/gcc%2Fconfig%2Fia64%2Fhpux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6dd12198d088c1e749b67c9e9a92352b2639265a/gcc%2Fconfig%2Fia64%2Fhpux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fhpux.h?ref=6dd12198d088c1e749b67c9e9a92352b2639265a", "patch": "@@ -35,14 +35,15 @@ Boston, MA 02111-1307, USA.  */\n #undef CPP_SPEC\n #define CPP_SPEC \"\\\n   %{mcpu=itanium:-D__itanium__} \\\n-  -D__LP64__ -D__LONG_MAX__=9223372036854775807L \\\n+  %{mlp64:-D__LP64__ -D__LONG_MAX__=9223372036854775807L} \\\n   %{!ansi:%{!std=c*:%{!std=i*: -D_HPUX_SOURCE -D__STDC_EXT__}}} \\\n   -D__fpreg=long\\\\ double \\\n   -D__float80=long\\\\ double \\\n   -D__float128=long\\\\ double\"\n \n #undef ASM_SPEC\n-#define ASM_SPEC \"-x %{mconstant-gp} %{mauto-pic}\"\n+#define ASM_SPEC \"-x %{mconstant-gp} %{mauto-pic} \\\n+  %{milp32:-milp32} %{mlp64:-mlp64}\"\n \n #undef ENDFILE_SPEC\n \n@@ -66,6 +67,18 @@ Boston, MA 02111-1307, USA.  */\n #undef  LIB_SPEC\n #define LIB_SPEC \"%{!shared:%{!symbolic:-lc}}\"\n \n+#undef SUBTARGET_SWITCHES\n+#define SUBTARGET_SWITCHES \\\n+  { \"ilp32\",    MASK_ILP32,     \"Generate ILP32 code\" }, \\\n+  { \"lp64\",    -MASK_ILP32,     \"Generate LP64 code\" },\n+\n+/* A C expression whose value is zero if pointers that need to be extended\n+   from being `POINTER_SIZE' bits wide to `Pmode' are sign-extended and\n+   greater then zero if they are zero-extended and less then zero if the\n+   ptr_extend instruction should be used.  */\n+\n+#define POINTERS_EXTEND_UNSIGNED -1\n+\n #define DONT_USE_BUILTIN_SETJMP\n #define JMP_BUF_SIZE  (8 * 76)\n "}, {"sha": "63181c755f4c1d96d1e0f16c0f1d1621428d916d", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6dd12198d088c1e749b67c9e9a92352b2639265a/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6dd12198d088c1e749b67c9e9a92352b2639265a/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=6dd12198d088c1e749b67c9e9a92352b2639265a", "patch": "@@ -4423,6 +4423,10 @@ rtx_needs_barrier (x, flags, pred)\n \tcase 23: /* cycle display */\n           break;\n \n+        case 24: /* addp4 */\n+\t  need_barrier = rtx_needs_barrier (XVECEXP (x, 0, 0), flags, pred);\n+\t  break;\n+\n \tcase 5: /* recip_approx */\n \t  need_barrier = rtx_needs_barrier (XVECEXP (x, 0, 0), flags, pred);\n \t  need_barrier |= rtx_needs_barrier (XVECEXP (x, 0, 1), flags, pred);"}, {"sha": "7da33a4d4feda756ff2a19242179c89e891da5f9", "filename": "gcc/config/ia64/ia64.h", "status": "modified", "additions": 17, "deletions": 13, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6dd12198d088c1e749b67c9e9a92352b2639265a/gcc%2Fconfig%2Fia64%2Fia64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6dd12198d088c1e749b67c9e9a92352b2639265a/gcc%2Fconfig%2Fia64%2Fia64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.h?ref=6dd12198d088c1e749b67c9e9a92352b2639265a", "patch": "@@ -53,7 +53,7 @@ extern int target_flags;\n \n #define MASK_VOL_ASM_STOP 0x00000010\t/* Emit stop bits for vol ext asm.  */\n \n-/* 0x00000020 is available.  */\n+#define MASK_ILP32      0x00000020      /* Generate ILP32 code. */\n \n #define MASK_B_STEP\t0x00000040\t/* Emit code for Itanium B step.  */\n \n@@ -81,6 +81,8 @@ extern int target_flags;\n \n #define TARGET_VOL_ASM_STOP\t(target_flags & MASK_VOL_ASM_STOP)\n \n+#define TARGET_ILP32            (target_flags & MASK_ILP32)\n+\n #define TARGET_B_STEP\t\t(target_flags & MASK_B_STEP)\n \n #define TARGET_REG_NAMES\t(target_flags & MASK_REG_NAMES)\n@@ -144,6 +146,7 @@ extern int target_flags;\n       N_(\"Enable Dwarf 2 line debug info via GNU as\")},\t\t\t\\\n   { \"no-dwarf2-asm\", \t-MASK_DWARF2_ASM,\t\t\t\t\\\n       N_(\"Disable Dwarf 2 line debug info via GNU as\")},\t\t\\\n+  SUBTARGET_SWITCHES\t\t\t\t\t\t\t\\\n   { \"\",\t\t\tTARGET_DEFAULT | TARGET_CPU_DEFAULT,\t\t\\\n       NULL }\t\t\t\t\t\t\t\t\\\n }\n@@ -158,6 +161,10 @@ extern int target_flags;\n #define TARGET_CPU_DEFAULT 0\n #endif\n \n+#ifndef SUBTARGET_SWITCHES\n+#define SUBTARGET_SWITCHES\n+#endif\n+\n /* This macro is similar to `TARGET_SWITCHES' but defines names of command\n    options that have values.  Its definition is an initializer with a\n    subgrouping for each command option.  */\n@@ -210,7 +217,7 @@ extern const char *ia64_fixed_range_string;\n    This should be defined if `SIZE_TYPE' depends on target dependent flags\n    which are not accessible to the preprocessor.  Otherwise, it should not be\n    defined.  */\n-/* ??? Needs to be defined for P64 code.  */\n+/* This is always \"long\" so it doesn't \"change\" in ILP32 vs. LP64.  */\n /* #define NO_BUILTIN_SIZE_TYPE */\n \n /* If this macro is defined, the preprocessor will not define the builtin macro\n@@ -220,7 +227,7 @@ extern const char *ia64_fixed_range_string;\n    This should be defined if `PTRDIFF_TYPE' depends on target dependent flags\n    which are not accessible to the preprocessor.  Otherwise, it should not be\n    defined.  */\n-/* ??? Needs to be defined for P64 code.  */\n+/* This is always \"long\" so it doesn't \"change\" in ILP32 vs. LP64.  */\n /* #define NO_BUILTIN_PTRDIFF_TYPE */\n \n /* A C string constant that tells the GNU CC driver program options to pass to\n@@ -306,16 +313,15 @@ extern const char *ia64_fixed_range_string;\n /* Width of a pointer, in bits.  You must specify a value no wider than the\n    width of `Pmode'.  If it is not equal to the width of `Pmode', you must\n    define `POINTERS_EXTEND_UNSIGNED'.  */\n-/* ??? Implement optional 32 bit pointer size later?  */\n-#define POINTER_SIZE 64\n+#define POINTER_SIZE (TARGET_ILP32 ? 32 : 64)\n \n-/* A C expression whose value is nonzero if pointers that need to be extended\n-   from being `POINTER_SIZE' bits wide to `Pmode' are sign-extended and zero if\n-   they are zero-extended.\n+/* A C expression whose value is zero if pointers that need to be extended\n+   from being `POINTER_SIZE' bits wide to `Pmode' are sign-extended and one if\n+   they are zero-extended and negative one if there is an ptr_extend operation.\n \n    You need not define this macro if the `POINTER_SIZE' is equal to the width\n    of `Pmode'.  */\n-/* ??? May need this for 32 bit pointers.  */\n+/* Need this for 32 bit pointers, see hpux.h for setting it.  */\n /* #define POINTERS_EXTEND_UNSIGNED */\n \n /* A macro to update MODE and UNSIGNEDP when an object whose type is TYPE and\n@@ -436,15 +442,13 @@ while (0)\n \n /* A C expression for the size in bits of the type `long' on the target\n    machine.  If you don't define this, the default is one word.  */\n-/* ??? Should be 32 for ILP32 code.  */\n-#define LONG_TYPE_SIZE 64\n+#define LONG_TYPE_SIZE (TARGET_ILP32 ? 32 : 64)\n \n /* Maximum number for the size in bits of the type `long' on the target\n    machine.  If this is undefined, the default is `LONG_TYPE_SIZE'.  Otherwise,\n    it is the constant value that is the largest value that `LONG_TYPE_SIZE' can\n    have at run-time.  This is used in `cpp'.  */\n-/* ??? Should be 64 for ILP32 code.  */\n-/* #define MAX_LONG_TYPE_SIZE */\n+#define MAX_LONG_TYPE_SIZE 64\n \n /* A C expression for the size in bits of the type `long long' on the target\n    machine.  If you don't define this, the default is two words.  If you want"}, {"sha": "8959fbda88da9cdcf0cd45049f4f6ebf796a0a0b", "filename": "gcc/config/ia64/ia64.md", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6dd12198d088c1e749b67c9e9a92352b2639265a/gcc%2Fconfig%2Fia64%2Fia64.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6dd12198d088c1e749b67c9e9a92352b2639265a/gcc%2Fconfig%2Fia64%2Fia64.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.md?ref=6dd12198d088c1e749b67c9e9a92352b2639265a", "patch": "@@ -66,6 +66,7 @@\n ;;\t21\tflushrs\n ;;\t22      bundle selector\n ;;\t23      cycle display\n+;;      24      addp4\n ;;\n ;; unspec_volatile:\n ;;\t0\talloc\n@@ -5169,3 +5170,15 @@\n   [(set_attr \"itanium_class\" \"ignore\")\n    (set_attr \"predicable\" \"no\")])\n \n+;;\n+;;\n+;; UNSPEC instruction definition to \"swizzle\" 32 bit pointer into 64 bit\n+;; pointer.  This is used by the HP-UX 32 bit mode.\n+\n+(define_insn \"ptr_extend\"\n+  [(set (match_operand:DI 0 \"gr_register_operand\" \"=r\")\n+        (unspec:DI [(match_operand:SI 1 \"gr_register_operand\" \"r\")] 24))]\n+  \"\"\n+  \"addp4 %0 = 0,%1\"\n+  [(set_attr \"itanium_class\" \"ialu\")])\n+"}, {"sha": "9f8296ba892df1535937e7898a75b209efcc7693", "filename": "gcc/config/ia64/t-hpux", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6dd12198d088c1e749b67c9e9a92352b2639265a/gcc%2Fconfig%2Fia64%2Ft-hpux", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6dd12198d088c1e749b67c9e9a92352b2639265a/gcc%2Fconfig%2Fia64%2Ft-hpux", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Ft-hpux?ref=6dd12198d088c1e749b67c9e9a92352b2639265a", "patch": "@@ -1,3 +1,12 @@\n+# We need multilib support for HPUX's ILP32 & LP64 modes.\n+\n+LIBGCC = stmp-multilib\n+INSTALL_LIBGCC = install-multilib\n+\n+MULTILIB_OPTIONS = milp32/mlp64\n+MULTILIB_DIRNAMES = hpux32 hpux64\n+MULTILIB_MATCHES =\n+\n # Support routines for HP-UX 128 bit floats.\n \n LIB2FUNCS_EXTRA=quadlib.c"}, {"sha": "162dc9e4f96651bc0fdedcd9cfe7522ac8503056", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6dd12198d088c1e749b67c9e9a92352b2639265a/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6dd12198d088c1e749b67c9e9a92352b2639265a/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=6dd12198d088c1e749b67c9e9a92352b2639265a", "patch": "@@ -954,9 +954,11 @@ you must define @code{POINTERS_EXTEND_UNSIGNED}.\n \n @findex POINTERS_EXTEND_UNSIGNED\n @item POINTERS_EXTEND_UNSIGNED\n-A C expression whose value is nonzero if pointers that need to be\n+A C expression whose value is greater than zero if pointers that need to be\n extended from being @code{POINTER_SIZE} bits wide to @code{Pmode} are to\n-be zero-extended and zero if they are to be sign-extended.\n+be zero-extended and zero if they are to be sign-extended.  If the value\n+is less then zero then there must be an \"ptr_extend\" instruction that\n+extends a pointer from @code{POINTER_SIZE} to @code{Pmode}.\n \n You need not define this macro if the @code{POINTER_SIZE} is equal\n to the width of @code{Pmode}."}, {"sha": "a8249999c9849b3e233d870297353c94d1906fc0", "filename": "gcc/explow.c", "status": "modified", "additions": 27, "deletions": 15, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6dd12198d088c1e749b67c9e9a92352b2639265a/gcc%2Fexplow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6dd12198d088c1e749b67c9e9a92352b2639265a/gcc%2Fexplow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexplow.c?ref=6dd12198d088c1e749b67c9e9a92352b2639265a", "patch": "@@ -365,36 +365,48 @@ convert_memory_address (to_mode, x)\n       return x;\n \n     case SUBREG:\n-      if (GET_MODE (SUBREG_REG (x)) == to_mode)\n+      if (POINTERS_EXTEND_UNSIGNED >= 0\n+\t  && GET_MODE (SUBREG_REG (x)) == to_mode)\n \treturn SUBREG_REG (x);\n       break;\n \n     case LABEL_REF:\n-      temp = gen_rtx_LABEL_REF (to_mode, XEXP (x, 0));\n-      LABEL_REF_NONLOCAL_P (temp) = LABEL_REF_NONLOCAL_P (x);\n-      return temp;\n+      if (POINTERS_EXTEND_UNSIGNED >= 0)\n+\t{\n+\t  temp = gen_rtx_LABEL_REF (to_mode, XEXP (x, 0));\n+\t  LABEL_REF_NONLOCAL_P (temp) = LABEL_REF_NONLOCAL_P (x);\n+\t  return temp;\n+\t}\n+      break;\n \n     case SYMBOL_REF:\n-      temp = gen_rtx_SYMBOL_REF (to_mode, XSTR (x, 0));\n-      SYMBOL_REF_FLAG (temp) = SYMBOL_REF_FLAG (x);\n-      CONSTANT_POOL_ADDRESS_P (temp) = CONSTANT_POOL_ADDRESS_P (x);\n-      STRING_POOL_ADDRESS_P (temp) = STRING_POOL_ADDRESS_P (x);\n-      return temp;\n+      if (POINTERS_EXTEND_UNSIGNED >= 0)\n+\t{\n+\t  temp = gen_rtx_SYMBOL_REF (to_mode, XSTR (x, 0));\n+\t  SYMBOL_REF_FLAG (temp) = SYMBOL_REF_FLAG (x);\n+\t  CONSTANT_POOL_ADDRESS_P (temp) = CONSTANT_POOL_ADDRESS_P (x);\n+\t  STRING_POOL_ADDRESS_P (temp) = STRING_POOL_ADDRESS_P (x);\n+\t  return temp;\n+\t}\n+      break;\n \n     case CONST:\n-      return gen_rtx_CONST (to_mode, \n-\t\t\t    convert_memory_address (to_mode, XEXP (x, 0)));\n+      if (POINTERS_EXTEND_UNSIGNED >= 0)\n+        return gen_rtx_CONST (to_mode, \n+\t\t\t      convert_memory_address (to_mode, XEXP (x, 0)));\n+      break;\n \n     case PLUS:\n     case MULT:\n       /* For addition the second operand is a small constant, we can safely\n \t permute the conversion and addition operation.  We can always safely\n \t permute them if we are making the address narrower.  In addition,\n \t always permute the operations if this is a constant.  */\n-      if (GET_MODE_SIZE (to_mode) < GET_MODE_SIZE (from_mode)\n-\t  || (GET_CODE (x) == PLUS && GET_CODE (XEXP (x, 1)) == CONST_INT\n-\t      && (INTVAL (XEXP (x, 1)) + 20000 < 40000\n-\t\t  || CONSTANT_P (XEXP (x, 0)))))\n+      if (POINTERS_EXTEND_UNSIGNED >= 0\n+\t  && (GET_MODE_SIZE (to_mode) < GET_MODE_SIZE (from_mode)\n+\t      || (GET_CODE (x) == PLUS && GET_CODE (XEXP (x, 1)) == CONST_INT\n+\t\t  && (INTVAL (XEXP (x, 1)) + 20000 < 40000\n+\t\t      || CONSTANT_P (XEXP (x, 0))))))\n \treturn gen_rtx_fmt_ee (GET_CODE (x), to_mode, \n \t\t\t       convert_memory_address (to_mode, XEXP (x, 0)),\n \t\t\t       convert_memory_address (to_mode, XEXP (x, 1)));"}, {"sha": "f135ad1876518a51945e607d6813b50d35004307", "filename": "gcc/optabs.c", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6dd12198d088c1e749b67c9e9a92352b2639265a/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6dd12198d088c1e749b67c9e9a92352b2639265a/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=6dd12198d088c1e749b67c9e9a92352b2639265a", "patch": "@@ -3919,7 +3919,12 @@ can_extend_p (to_mode, from_mode, unsignedp)\n      enum machine_mode to_mode, from_mode;\n      int unsignedp;\n {\n-  return extendtab[(int) to_mode][(int) from_mode][unsignedp != 0];\n+#ifdef HAVE_ptr_extend\n+  if (unsignedp < 0)\n+    return CODE_FOR_ptr_extend;\n+  else\n+#endif\n+    return extendtab[(int) to_mode][(int) from_mode][unsignedp != 0];\n }\n \n /* Generate the body of an insn to extend Y (with mode MFROM)"}, {"sha": "ed7b0ea6e55054f6bf7f327d36b085336849dd87", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6dd12198d088c1e749b67c9e9a92352b2639265a/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6dd12198d088c1e749b67c9e9a92352b2639265a/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=6dd12198d088c1e749b67c9e9a92352b2639265a", "patch": "@@ -699,7 +699,7 @@ simplify_unary_operation (code, mode, op, op_mode)\n \t      && GET_CODE (XEXP (XEXP (op, 0), 1)) == LABEL_REF)\n \t    return XEXP (op, 0);\n \n-#ifdef POINTERS_EXTEND_UNSIGNED\n+#if defined(POINTERS_EXTEND_UNSIGNED) && !defined(HAVE_ptr_extend)\n \t  if (! POINTERS_EXTEND_UNSIGNED\n \t      && mode == Pmode && GET_MODE (op) == ptr_mode\n \t      && (CONSTANT_P (op)\n@@ -711,9 +711,9 @@ simplify_unary_operation (code, mode, op, op_mode)\n #endif\n \t  break;\n \n-#ifdef POINTERS_EXTEND_UNSIGNED\n+#if defined(POINTERS_EXTEND_UNSIGNED) && !defined(HAVE_ptr_extend)\n \tcase ZERO_EXTEND:\n-\t  if (POINTERS_EXTEND_UNSIGNED\n+\t  if (POINTERS_EXTEND_UNSIGNED > 0\n \t      && mode == Pmode && GET_MODE (op) == ptr_mode\n \t      && (CONSTANT_P (op)\n \t\t  || (GET_CODE (op) == SUBREG"}]}