{"sha": "eebb98a55b8a102555c0e9823ed5597f8dc7cefb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWViYjk4YTU1YjhhMTAyNTU1YzBlOTgyM2VkNTU5N2Y4ZGM3Y2VmYg==", "commit": {"author": {"name": "Tobias Burnus", "email": "burnus@net-b.de", "date": "2013-07-08T13:48:19Z"}, "committer": {"name": "Tobias Burnus", "email": "burnus@gcc.gnu.org", "date": "2013-07-08T13:48:19Z"}, "message": "re PR fortran/57785 (DOT_PRODUCT error with constant complex array)\n\n2013-07-08  Tobias Burnus  <burnus@net-b.de>\n\n        PR fortran/57785\n        * simplify.c (compute_dot_product): Complex conjugate for\n        dot_product.\n        (gfc_simplify_dot_product, gfc_simplify_matmul): Update call.\n\n2013-07-08  Tobias Burnus  <burnus@net-b.de>\n\n        PR fortran/57785\n        * gfortran.dg/dot_product_2.f90: New.\n\nFrom-SVN: r200786", "tree": {"sha": "3f6d6786dfac40f27ff5bcdded308b2f403c82cb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3f6d6786dfac40f27ff5bcdded308b2f403c82cb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/eebb98a55b8a102555c0e9823ed5597f8dc7cefb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eebb98a55b8a102555c0e9823ed5597f8dc7cefb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eebb98a55b8a102555c0e9823ed5597f8dc7cefb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eebb98a55b8a102555c0e9823ed5597f8dc7cefb/comments", "author": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c8877f40377038ad919467e472ca09625559b1c7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c8877f40377038ad919467e472ca09625559b1c7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c8877f40377038ad919467e472ca09625559b1c7"}], "stats": {"total": 70, "additions": 62, "deletions": 8}, "files": [{"sha": "f6bc080bfb07dbf5da91f98a791b7f7ffab05077", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eebb98a55b8a102555c0e9823ed5597f8dc7cefb/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eebb98a55b8a102555c0e9823ed5597f8dc7cefb/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=eebb98a55b8a102555c0e9823ed5597f8dc7cefb", "patch": "@@ -1,3 +1,10 @@\n+2013-07-08  Tobias Burnus  <burnus@net-b.de>\n+\n+\tPR fortran/57785\n+\t* simplify.c (compute_dot_product): Complex conjugate for\n+\tdot_product.\n+\t(gfc_simplify_dot_product, gfc_simplify_matmul): Update call.\n+\n 2013-07-08  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/57469"}, {"sha": "32b8332fa9ea22a09d34166bd1633831aa79f321", "filename": "gcc/fortran/simplify.c", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eebb98a55b8a102555c0e9823ed5597f8dc7cefb/gcc%2Ffortran%2Fsimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eebb98a55b8a102555c0e9823ed5597f8dc7cefb/gcc%2Ffortran%2Fsimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsimplify.c?ref=eebb98a55b8a102555c0e9823ed5597f8dc7cefb", "patch": "@@ -333,13 +333,15 @@ init_result_expr (gfc_expr *e, int init, gfc_expr *array)\n }\n \n \n-/* Helper function for gfc_simplify_dot_product() and gfc_simplify_matmul.  */\n+/* Helper function for gfc_simplify_dot_product() and gfc_simplify_matmul;\n+   if conj_a is true, the matrix_a is complex conjugated.  */\n \n static gfc_expr *\n compute_dot_product (gfc_expr *matrix_a, int stride_a, int offset_a,\n-\t\t     gfc_expr *matrix_b, int stride_b, int offset_b)\n+\t\t     gfc_expr *matrix_b, int stride_b, int offset_b,\n+\t\t     bool conj_a)\n {\n-  gfc_expr *result, *a, *b;\n+  gfc_expr *result, *a, *b, *c;\n \n   result = gfc_get_constant_expr (matrix_a->ts.type, matrix_a->ts.kind,\n \t\t\t\t  &matrix_a->where);\n@@ -362,9 +364,11 @@ compute_dot_product (gfc_expr *matrix_a, int stride_a, int offset_a,\n \t  case BT_INTEGER:\n \t  case BT_REAL:\n \t  case BT_COMPLEX:\n-\t    result = gfc_add (result,\n-\t\t\t      gfc_multiply (gfc_copy_expr (a),\n-\t\t\t\t\t    gfc_copy_expr (b)));\n+\t    if (conj_a && a->ts.type == BT_COMPLEX)\n+\t      c = gfc_simplify_conjg (a);\n+\t    else\n+\t      c = gfc_copy_expr (a);\n+\t    result = gfc_add (result, gfc_multiply (c, gfc_copy_expr (b)));\n \t    break;\n \n \t  default:\n@@ -1882,7 +1886,7 @@ gfc_simplify_dot_product (gfc_expr *vector_a, gfc_expr *vector_b)\n   gcc_assert (vector_b->rank == 1);\n   gcc_assert (gfc_compare_types (&vector_a->ts, &vector_b->ts));\n \n-  return compute_dot_product (vector_a, 1, 0, vector_b, 1, 0);\n+  return compute_dot_product (vector_a, 1, 0, vector_b, 1, 0, true);\n }\n \n \n@@ -3910,7 +3914,7 @@ gfc_simplify_matmul (gfc_expr *matrix_a, gfc_expr *matrix_b)\n       for (row = 0; row < result_rows; ++row)\n \t{\n \t  gfc_expr *e = compute_dot_product (matrix_a, stride_a, offset_a,\n-\t\t\t\t\t     matrix_b, 1, offset_b);\n+\t\t\t\t\t     matrix_b, 1, offset_b, false);\n \t  gfc_constructor_append_expr (&result->value.constructor,\n \t\t\t\t       e, NULL);\n "}, {"sha": "f7f4d9701c83ec5720a396949b58faf4e619efbe", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eebb98a55b8a102555c0e9823ed5597f8dc7cefb/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eebb98a55b8a102555c0e9823ed5597f8dc7cefb/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=eebb98a55b8a102555c0e9823ed5597f8dc7cefb", "patch": "@@ -1,3 +1,8 @@\n+2013-07-08  Tobias Burnus  <burnus@net-b.de>\n+\n+\tPR fortran/57785\n+\t* gfortran.dg/dot_product_2.f90: New.\n+\n 2013-07-08  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/57469"}, {"sha": "a5fe3b0517850ac37e82228d6c818224870396c4", "filename": "gcc/testsuite/gfortran.dg/dot_product_2.f90", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eebb98a55b8a102555c0e9823ed5597f8dc7cefb/gcc%2Ftestsuite%2Fgfortran.dg%2Fdot_product_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eebb98a55b8a102555c0e9823ed5597f8dc7cefb/gcc%2Ftestsuite%2Fgfortran.dg%2Fdot_product_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdot_product_2.f90?ref=eebb98a55b8a102555c0e9823ed5597f8dc7cefb", "patch": "@@ -0,0 +1,38 @@\n+! { dg-do compile }\n+! { dg-options \"-fdump-tree-original\" }\n+!\n+! PR fortran/57785\n+!\n+! Contributed by Kontantinos Anagnostopoulos\n+!\n+! The implicit complex conjugate was missing for DOT_PRODUCT\n+\n+\n+! For the following, the compile-time simplification fails for SUM;\n+! see PR fortran/56342. Hence, a manually expanded SUM is used.\n+\n+!if (DOT_PRODUCT ((/ (1.0, 2.0), (2.0, 3.0) /), (/ (1.0, 1.0), (1.0, 4.0) /))   &\n+!   /= SUM (CONJG ((/ (1.0, 2.0), (2.0, 3.0) /))*(/ (1.0, 1.0), (1.0, 4.0) /))) &\n+!   call abort ()\n+!\n+!if (ANY (MATMUL ((/ (1.0, 2.0), (2.0, 3.0) /),                                 &\n+!                 RESHAPE ((/ (1.0, 1.0), (1.0, 4.0) /),(/2, 1/))) /=           &\n+!         SUM ((/ (1.0, 2.0), (2.0, 3.0) /)*(/ (1.0, 1.0), (1.0, 4.0) /))))     &\n+!    call abort ()      \n+\n+\n+if (DOT_PRODUCT ((/ (1.0, 2.0), (2.0, 3.0) /), (/ (1.0, 1.0), (1.0, 4.0) /))  &\n+    /= CONJG (cmplx(1.0, 2.0)) * cmplx(1.0, 1.0)                              &\n+     + CONJG (cmplx(2.0, 3.0)) * cmplx(1.0, 4.0)) &\n+  call abort ()\n+\n+if (ANY (MATMUL ((/ (1.0, 2.0), (2.0, 3.0) /),                                &\n+                 RESHAPE ((/ (1.0, 1.0), (1.0, 4.0) /),(/2, 1/)))             &\n+         /= cmplx(1.0, 2.0) * cmplx(1.0, 1.0)                                 &\n+          + cmplx(2.0, 3.0) * cmplx(1.0, 4.0)))                               &\n+  call abort ()      \n+end\n+\n+\n+! { dg-final { scan-tree-dump-not \"abort\" \"original\" } }\n+! { dg-final { cleanup-tree-dump \"original\" } }"}]}