{"sha": "7beb0596ea999005a74327e48c6174988eb61ced", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2JlYjA1OTZlYTk5OTAwNWE3NDMyN2U0OGM2MTc0OTg4ZWI2MWNlZA==", "commit": {"author": {"name": "Jie Zhang", "email": "jie@codesourcery.com", "date": "2010-07-12T17:22:48Z"}, "committer": {"name": "Jie Zhang", "email": "jiez@gcc.gnu.org", "date": "2010-07-12T17:22:48Z"}, "message": "postreload.c (reg_symbol_ref[]): New.\n\n\t* postreload.c (reg_symbol_ref[]): New.\n\t(move2add_use_add2_insn): New.\n\t(move2add_use_add3_insn): New.\n\t(reload_cse_move2add): Handle SYMBOL + OFFSET case.\n\t(move2add_note_store): Likewise.\n\nFrom-SVN: r162085", "tree": {"sha": "ed9ff177455269951cf87c1344d8c02c0b648300", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ed9ff177455269951cf87c1344d8c02c0b648300"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7beb0596ea999005a74327e48c6174988eb61ced", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7beb0596ea999005a74327e48c6174988eb61ced", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7beb0596ea999005a74327e48c6174988eb61ced", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7beb0596ea999005a74327e48c6174988eb61ced/comments", "author": null, "committer": null, "parents": [{"sha": "2bc7b00c496efb9634f6d3cd80416ea545713f57", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2bc7b00c496efb9634f6d3cd80416ea545713f57", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2bc7b00c496efb9634f6d3cd80416ea545713f57"}], "stats": {"total": 321, "additions": 255, "deletions": 66}, "files": [{"sha": "2cd8630d6263d79d6b7340fee23d6718a0dc21a4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7beb0596ea999005a74327e48c6174988eb61ced/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7beb0596ea999005a74327e48c6174988eb61ced/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7beb0596ea999005a74327e48c6174988eb61ced", "patch": "@@ -1,3 +1,11 @@\n+2010-07-12  Jie Zhang  <jie@codesourcery.com>\n+\n+\t* postreload.c (reg_symbol_ref[]): New.\n+\t(move2add_use_add2_insn): New.\n+\t(move2add_use_add3_insn): New.\n+\t(reload_cse_move2add): Handle SYMBOL + OFFSET case.\n+\t(move2add_note_store): Likewise.\n+\n 2010-07-12  Joern Rennecke  <joern.rennecke@embecosm.com>\n \n \tPR rtl-optimization/44752"}, {"sha": "116c9c433e2f3c9e20aca1f27b940588c7f21978", "filename": "gcc/postreload.c", "status": "modified", "additions": 247, "deletions": 66, "changes": 313, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7beb0596ea999005a74327e48c6174988eb61ced/gcc%2Fpostreload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7beb0596ea999005a74327e48c6174988eb61ced/gcc%2Fpostreload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpostreload.c?ref=7beb0596ea999005a74327e48c6174988eb61ced", "patch": "@@ -1160,17 +1160,19 @@ reload_combine_note_use (rtx *xp, rtx insn)\n    information about register contents we have would be costly, so we\n    use move2add_last_label_luid to note where the label is and then\n    later disable any optimization that would cross it.\n-   reg_offset[n] / reg_base_reg[n] / reg_mode[n] are only valid if\n-   reg_set_luid[n] is greater than move2add_last_label_luid.  */\n+   reg_offset[n] / reg_base_reg[n] / reg_symbol_ref[n] / reg_mode[n]\n+   are only valid if reg_set_luid[n] is greater than\n+   move2add_last_label_luid.  */\n static int reg_set_luid[FIRST_PSEUDO_REGISTER];\n \n /* If reg_base_reg[n] is negative, register n has been set to\n-   reg_offset[n] in mode reg_mode[n] .\n+   reg_offset[n] or reg_symbol_ref[n] + reg_offset[n] in mode reg_mode[n].\n    If reg_base_reg[n] is non-negative, register n has been set to the\n    sum of reg_offset[n] and the value of register reg_base_reg[n]\n    before reg_set_luid[n], calculated in mode reg_mode[n] .  */\n static HOST_WIDE_INT reg_offset[FIRST_PSEUDO_REGISTER];\n static int reg_base_reg[FIRST_PSEUDO_REGISTER];\n+static rtx reg_symbol_ref[FIRST_PSEUDO_REGISTER];\n static enum machine_mode reg_mode[FIRST_PSEUDO_REGISTER];\n \n /* move2add_luid is linearly increased while scanning the instructions\n@@ -1190,14 +1192,165 @@ static int move2add_last_label_luid;\n        && TRULY_NOOP_TRUNCATION (GET_MODE_BITSIZE (OUTMODE), \\\n \t\t\t\t GET_MODE_BITSIZE (INMODE))))\n \n+/* This function is called with INSN that sets REG to (SYM + OFF),\n+   while REG is known to already have value (SYM + offset).\n+   This function tries to change INSN into an add instruction\n+   (set (REG) (plus (REG) (OFF - offset))) using the known value.\n+   It also updates the information about REG's known value.  */\n+\n+static void\n+move2add_use_add2_insn (rtx reg, rtx sym, rtx off, rtx insn)\n+{\n+  rtx pat = PATTERN (insn);\n+  rtx src = SET_SRC (pat);\n+  int regno = REGNO (reg);\n+  rtx new_src = gen_int_mode (INTVAL (off) - reg_offset[regno],\n+\t\t\t      GET_MODE (reg));\n+  bool speed = optimize_bb_for_speed_p (BLOCK_FOR_INSN (insn));\n+\n+  /* (set (reg) (plus (reg) (const_int 0))) is not canonical;\n+     use (set (reg) (reg)) instead.\n+     We don't delete this insn, nor do we convert it into a\n+     note, to avoid losing register notes or the return\n+     value flag.  jump2 already knows how to get rid of\n+     no-op moves.  */\n+  if (new_src == const0_rtx)\n+    {\n+      /* If the constants are different, this is a\n+\t truncation, that, if turned into (set (reg)\n+\t (reg)), would be discarded.  Maybe we should\n+\t try a truncMN pattern?  */\n+      if (INTVAL (off) == reg_offset [regno])\n+\tvalidate_change (insn, &SET_SRC (pat), reg, 0);\n+    }\n+  else if (rtx_cost (new_src, PLUS, speed) < rtx_cost (src, SET, speed)\n+\t   && have_add2_insn (reg, new_src))\n+    {\n+      rtx tem = gen_rtx_PLUS (GET_MODE (reg), reg, new_src);\n+      validate_change (insn, &SET_SRC (pat), tem, 0);\n+    }\n+  else if (sym == NULL_RTX && GET_MODE (reg) != BImode)\n+    {\n+      enum machine_mode narrow_mode;\n+      for (narrow_mode = GET_CLASS_NARROWEST_MODE (MODE_INT);\n+\t   narrow_mode != VOIDmode\n+\t     && narrow_mode != GET_MODE (reg);\n+\t   narrow_mode = GET_MODE_WIDER_MODE (narrow_mode))\n+\t{\n+\t  if (have_insn_for (STRICT_LOW_PART, narrow_mode)\n+\t      && ((reg_offset[regno]\n+\t\t   & ~GET_MODE_MASK (narrow_mode))\n+\t\t  == (INTVAL (off)\n+\t\t      & ~GET_MODE_MASK (narrow_mode))))\n+\t    {\n+\t      rtx narrow_reg = gen_rtx_REG (narrow_mode,\n+\t\t\t\t\t    REGNO (reg));\n+\t      rtx narrow_src = gen_int_mode (INTVAL (off),\n+\t\t\t\t\t     narrow_mode);\n+\t      rtx new_set =\n+\t\tgen_rtx_SET (VOIDmode,\n+\t\t\t     gen_rtx_STRICT_LOW_PART (VOIDmode,\n+\t\t\t\t\t\t      narrow_reg),\n+\t\t\t     narrow_src);\n+\t      if (validate_change (insn, &PATTERN (insn),\n+\t\t\t\t   new_set, 0))\n+\t\tbreak;\n+\t    }\n+\t}\n+    }\n+  reg_set_luid[regno] = move2add_luid;\n+  reg_base_reg[regno] = -1;\n+  reg_mode[regno] = GET_MODE (reg);\n+  reg_symbol_ref[regno] = sym;\n+  reg_offset[regno] = INTVAL (off);\n+}\n+\n+\n+/* This function is called with INSN that sets REG to (SYM + OFF),\n+   but REG doesn't have known value (SYM + offset).  This function\n+   tries to find another register which is known to already have\n+   value (SYM + offset) and change INSN into an add instruction\n+   (set (REG) (plus (the found register) (OFF - offset))) if such\n+   a register is found.  It also updates the information about\n+   REG's known value.  */\n+\n+static void\n+move2add_use_add3_insn (rtx reg, rtx sym, rtx off, rtx insn)\n+{\n+  rtx pat = PATTERN (insn);\n+  rtx src = SET_SRC (pat);\n+  int regno = REGNO (reg);\n+  int min_cost = INT_MAX;\n+  int min_regno;\n+  bool speed = optimize_bb_for_speed_p (BLOCK_FOR_INSN (insn));\n+  int i;\n+\n+  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+    if (reg_set_luid[i] > move2add_last_label_luid\n+\t&& reg_mode[i] == GET_MODE (reg)\n+\t&& reg_base_reg[i] < 0\n+\t&& reg_symbol_ref[i] != NULL_RTX\n+\t&& rtx_equal_p (sym, reg_symbol_ref[i]))\n+      {\n+\trtx new_src = gen_int_mode (INTVAL (off) - reg_offset[i],\n+\t\t\t\t    GET_MODE (reg));\n+\t/* (set (reg) (plus (reg) (const_int 0))) is not canonical;\n+\t   use (set (reg) (reg)) instead.\n+\t   We don't delete this insn, nor do we convert it into a\n+\t   note, to avoid losing register notes or the return\n+\t   value flag.  jump2 already knows how to get rid of\n+\t   no-op moves.  */\n+\tif (new_src == const0_rtx)\n+\t  {\n+\t    min_cost = 0;\n+\t    min_regno = i;\n+\t    break;\n+\t  }\n+\telse\n+\t  {\n+\t    int cost = rtx_cost (new_src, PLUS, speed);\n+\t    if (cost < min_cost)\n+\t      {\n+\t\tmin_cost = cost;\n+\t\tmin_regno = i;\n+\t      }\n+\t  }\n+      }\n+\n+  if (min_cost < rtx_cost (src, SET, speed))\n+    {\n+      rtx tem;\n+\n+      tem = gen_rtx_REG (GET_MODE (reg), min_regno);\n+      if (i != min_regno)\n+\t{\n+\t  rtx new_src = gen_int_mode (INTVAL (off) - reg_offset[min_regno],\n+\t\t\t\t      GET_MODE (reg));\n+\t  tem = gen_rtx_PLUS (GET_MODE (reg), tem, new_src);\n+\t}\n+      validate_change (insn, &SET_SRC (pat), tem, 0);\n+    }\n+  reg_set_luid[regno] = move2add_luid;\n+  reg_base_reg[regno] = -1;\n+  reg_mode[regno] = GET_MODE (reg);\n+  reg_symbol_ref[regno] = sym;\n+  reg_offset[regno] = INTVAL (off);\n+}\n+\n static void\n reload_cse_move2add (rtx first)\n {\n   int i;\n   rtx insn;\n \n   for (i = FIRST_PSEUDO_REGISTER - 1; i >= 0; i--)\n-    reg_set_luid[i] = 0;\n+    {\n+      reg_set_luid[i] = 0;\n+      reg_offset[i] = 0;\n+      reg_base_reg[i] = 0;\n+      reg_symbol_ref[i] = NULL_RTX;\n+      reg_mode[i] = VOIDmode;\n+    }\n \n   move2add_last_label_luid = 0;\n   move2add_luid = 2;\n@@ -1245,65 +1398,11 @@ reload_cse_move2add (rtx first)\n \t\t\t\t  (set (STRICT_LOW_PART (REGX)) (CONST_INT B))\n \t      */\n \n-\t      if (CONST_INT_P (src) && reg_base_reg[regno] < 0)\n+\t      if (CONST_INT_P (src)\n+\t\t  && reg_base_reg[regno] < 0\n+\t\t  && reg_symbol_ref[regno] == NULL_RTX)\n \t\t{\n-\t\t  rtx new_src = gen_int_mode (INTVAL (src) - reg_offset[regno],\n-\t\t\t\t\t      GET_MODE (reg));\n-\t\t  bool speed = optimize_bb_for_speed_p (BLOCK_FOR_INSN (insn));\n-\n-\t\t  /* (set (reg) (plus (reg) (const_int 0))) is not canonical;\n-\t\t     use (set (reg) (reg)) instead.\n-\t\t     We don't delete this insn, nor do we convert it into a\n-\t\t     note, to avoid losing register notes or the return\n-\t\t     value flag.  jump2 already knows how to get rid of\n-\t\t     no-op moves.  */\n-\t\t  if (new_src == const0_rtx)\n-\t\t    {\n-\t\t      /* If the constants are different, this is a\n-\t\t\t truncation, that, if turned into (set (reg)\n-\t\t\t (reg)), would be discarded.  Maybe we should\n-\t\t\t try a truncMN pattern?  */\n-\t\t      if (INTVAL (src) == reg_offset [regno])\n-\t\t\tvalidate_change (insn, &SET_SRC (pat), reg, 0);\n-\t\t    }\n-\t\t  else if (rtx_cost (new_src, PLUS, speed) < rtx_cost (src, SET, speed)\n-\t\t\t   && have_add2_insn (reg, new_src))\n-\t\t    {\n-\t\t      rtx tem = gen_rtx_PLUS (GET_MODE (reg), reg, new_src);\n-\t\t      validate_change (insn, &SET_SRC (pat), tem, 0);\n-\t\t    }\n-\t\t  else if (GET_MODE (reg) != BImode)\n-\t\t    {\n-\t\t      enum machine_mode narrow_mode;\n-\t\t      for (narrow_mode = GET_CLASS_NARROWEST_MODE (MODE_INT);\n-\t\t\t   narrow_mode != VOIDmode\n-\t\t\t   && narrow_mode != GET_MODE (reg);\n-\t\t\t   narrow_mode = GET_MODE_WIDER_MODE (narrow_mode))\n-\t\t\t{\n-\t\t\t  if (have_insn_for (STRICT_LOW_PART, narrow_mode)\n-\t\t\t      && ((reg_offset[regno]\n-\t\t\t\t   & ~GET_MODE_MASK (narrow_mode))\n-\t\t\t\t  == (INTVAL (src)\n-\t\t\t\t      & ~GET_MODE_MASK (narrow_mode))))\n-\t\t\t    {\n-\t\t\t      rtx narrow_reg = gen_rtx_REG (narrow_mode,\n-\t\t\t\t\t\t\t    REGNO (reg));\n-\t\t\t      rtx narrow_src = gen_int_mode (INTVAL (src),\n-\t\t\t\t\t\t\t     narrow_mode);\n-\t\t\t      rtx new_set =\n-\t\t\t\tgen_rtx_SET (VOIDmode,\n-\t\t\t\t\t     gen_rtx_STRICT_LOW_PART (VOIDmode,\n-\t\t\t\t\t\t\t\t      narrow_reg),\n-\t\t\t\t\t     narrow_src);\n-\t\t\t      if (validate_change (insn, &PATTERN (insn),\n-\t\t\t\t\t\t   new_set, 0))\n-\t\t\t\tbreak;\n-\t\t\t    }\n-\t\t\t}\n-\t\t    }\n-\t\t  reg_set_luid[regno] = move2add_luid;\n-\t\t  reg_mode[regno] = GET_MODE (reg);\n-\t\t  reg_offset[regno] = INTVAL (src);\n+\t\t  move2add_use_add2_insn (reg, NULL_RTX, src, insn);\n \t\t  continue;\n \t\t}\n \n@@ -1373,6 +1472,51 @@ reload_cse_move2add (rtx first)\n \t\t    }\n \t\t}\n \t    }\n+\n+\t  /* Try to transform\n+\t     (set (REGX) (CONST (PLUS (SYMBOL_REF) (CONST_INT A))))\n+\t     ...\n+\t     (set (REGY) (CONST (PLUS (SYMBOL_REF) (CONST_INT B))))\n+\t     to\n+\t     (set (REGX) (CONST (PLUS (SYMBOL_REF) (CONST_INT A))))\n+\t     ...\n+\t     (set (REGY) (CONST (PLUS (REGX) (CONST_INT B-A))))  */\n+\t  if ((GET_CODE (src) == SYMBOL_REF\n+\t       || (GET_CODE (src) == CONST\n+\t\t   && GET_CODE (XEXP (src, 0)) == PLUS\n+\t\t   && GET_CODE (XEXP (XEXP (src, 0), 0)) == SYMBOL_REF\n+\t\t   && CONST_INT_P (XEXP (XEXP (src, 0), 1))))\n+\t      && dbg_cnt (cse2_move2add))\n+\t    {\n+\t      rtx sym, off;\n+\n+\t      if (GET_CODE (src) == SYMBOL_REF)\n+\t\t{\n+\t\t  sym = src;\n+\t\t  off = const0_rtx;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  sym = XEXP (XEXP (src, 0), 0);\n+\t\t  off = XEXP (XEXP (src, 0), 1);\n+\t\t}\n+\n+\t      /* If the reg already contains the value which is sum of\n+\t\t sym and some constant value, we can use an add2 insn.  */\n+\t      if (reg_set_luid[regno] > move2add_last_label_luid\n+\t\t  && MODES_OK_FOR_MOVE2ADD (GET_MODE (reg), reg_mode[regno])\n+\t\t  && reg_base_reg[regno] < 0\n+\t\t  && reg_symbol_ref[regno] != NULL_RTX\n+\t\t  && rtx_equal_p (sym, reg_symbol_ref[regno]))\n+\t\tmove2add_use_add2_insn (reg, sym, off, insn);\n+\n+\t      /* Otherwise, we have to find a register whose value is sum\n+\t\t of sym and some constant value.  */\n+\t      else\n+\t\tmove2add_use_add3_insn (reg, sym, off, insn);\n+\n+\t      continue;\n+\t    }\n \t}\n \n       for (note = REG_NOTES (insn); note; note = XEXP (note, 1))\n@@ -1386,7 +1530,7 @@ reload_cse_move2add (rtx first)\n \t\treg_set_luid[regno] = 0;\n \t    }\n \t}\n-      note_stores (PATTERN (insn), move2add_note_store, NULL);\n+      note_stores (PATTERN (insn), move2add_note_store, insn);\n \n       /* If INSN is a conditional branch, we try to extract an\n \t implicit set out of it.  */\n@@ -1408,7 +1552,7 @@ reload_cse_move2add (rtx first)\n \t    {\n \t      rtx implicit_set =\n \t\tgen_rtx_SET (VOIDmode, XEXP (cnd, 0), XEXP (cnd, 1));\n-\t      move2add_note_store (SET_DEST (implicit_set), implicit_set, 0);\n+\t      move2add_note_store (SET_DEST (implicit_set), implicit_set, insn);\n \t    }\n \t}\n \n@@ -1426,13 +1570,15 @@ reload_cse_move2add (rtx first)\n     }\n }\n \n-/* SET is a SET or CLOBBER that sets DST.\n+/* SET is a SET or CLOBBER that sets DST.  DATA is the insn which\n+   contains SET.\n    Update reg_set_luid, reg_offset and reg_base_reg accordingly.\n    Called from reload_cse_move2add via note_stores.  */\n \n static void\n-move2add_note_store (rtx dst, const_rtx set, void *data ATTRIBUTE_UNUSED)\n+move2add_note_store (rtx dst, const_rtx set, void *data)\n {\n+  rtx insn = (rtx) data;\n   unsigned int regno = 0;\n   unsigned int nregs = 0;\n   unsigned int i;\n@@ -1465,6 +1611,38 @@ move2add_note_store (rtx dst, const_rtx set, void *data ATTRIBUTE_UNUSED)\n   if (!nregs)\n     nregs = hard_regno_nregs[regno][mode];\n \n+  if (SCALAR_INT_MODE_P (GET_MODE (dst))\n+      && nregs == 1 && GET_CODE (set) == SET)\n+    {\n+      rtx note, sym = NULL_RTX;\n+      HOST_WIDE_INT off;\n+\n+      note = find_reg_equal_equiv_note (insn);\n+      if (note && GET_CODE (XEXP (note, 0)) == SYMBOL_REF)\n+\t{\n+\t  sym = XEXP (note, 0);\n+\t  off = 0;\n+\t}\n+      else if (note && GET_CODE (XEXP (note, 0)) == CONST\n+\t       && GET_CODE (XEXP (XEXP (note, 0), 0)) == PLUS\n+\t       && GET_CODE (XEXP (XEXP (XEXP (note, 0), 0), 0)) == SYMBOL_REF\n+\t       && CONST_INT_P (XEXP (XEXP (XEXP (note, 0), 0), 1)))\n+\t{\n+\t  sym = XEXP (XEXP (XEXP (note, 0), 0), 0);\n+\t  off = INTVAL (XEXP (XEXP (XEXP (note, 0), 0), 1));\n+\t}\n+\n+      if (sym != NULL_RTX)\n+\t{\n+\t  reg_base_reg[regno] = -1;\n+\t  reg_symbol_ref[regno] = sym;\n+\t  reg_offset[regno] = off;\n+\t  reg_mode[regno] = mode;\n+\t  reg_set_luid[regno] = move2add_luid;\n+\t  return;\n+\t}\n+    }\n+\n   if (SCALAR_INT_MODE_P (GET_MODE (dst))\n       && nregs == 1 && GET_CODE (set) == SET\n       && GET_CODE (SET_DEST (set)) != ZERO_EXTRACT\n@@ -1525,6 +1703,7 @@ move2add_note_store (rtx dst, const_rtx set, void *data ATTRIBUTE_UNUSED)\n \tcase CONST_INT:\n \t  /* Start tracking the register as a constant.  */\n \t  reg_base_reg[regno] = -1;\n+\t  reg_symbol_ref[regno] = NULL_RTX;\n \t  reg_offset[regno] = INTVAL (SET_SRC (set));\n \t  /* We assign the same luid to all registers set to constants.  */\n \t  reg_set_luid[regno] = move2add_last_label_luid + 1;\n@@ -1545,6 +1724,7 @@ move2add_note_store (rtx dst, const_rtx set, void *data ATTRIBUTE_UNUSED)\n       if (reg_set_luid[base_regno] <= move2add_last_label_luid)\n \t{\n \t  reg_base_reg[base_regno] = base_regno;\n+\t  reg_symbol_ref[base_regno] = NULL_RTX;\n \t  reg_offset[base_regno] = 0;\n \t  reg_set_luid[base_regno] = move2add_luid;\n \t  reg_mode[base_regno] = mode;\n@@ -1558,6 +1738,7 @@ move2add_note_store (rtx dst, const_rtx set, void *data ATTRIBUTE_UNUSED)\n       /* Copy base information from our base register.  */\n       reg_set_luid[regno] = reg_set_luid[base_regno];\n       reg_base_reg[regno] = reg_base_reg[base_regno];\n+      reg_symbol_ref[regno] = reg_symbol_ref[base_regno];\n \n       /* Compute the sum of the offsets or constants.  */\n       reg_offset[regno] = trunc_int_for_mode (offset"}]}