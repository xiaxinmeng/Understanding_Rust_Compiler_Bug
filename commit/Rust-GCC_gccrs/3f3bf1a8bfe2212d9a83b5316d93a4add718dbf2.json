{"sha": "3f3bf1a8bfe2212d9a83b5316d93a4add718dbf2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2YzYmYxYThiZmUyMjEyZDlhODNiNTMxNmQ5M2E0YWRkNzE4ZGJmMg==", "commit": {"author": {"name": "Greta Yorsh", "email": "greta.yorsh@arm.com", "date": "2013-04-05T15:52:25Z"}, "committer": {"name": "Greta Yorsh", "email": "gretay@gcc.gnu.org", "date": "2013-04-05T15:52:25Z"}, "message": "arm.md (andsi_iorsi3_notsi): Convert define_insn into define_insn_and_split.\n\n2013-04-05  Greta Yorsh  <Greta.Yorsh@arm.com>\n\n\t* config/arm/arm.md (andsi_iorsi3_notsi): Convert define_insn into\n\tdefine_insn_and_split.\n\t(arm_negdi2,arm_abssi2,arm_neg_abssi2): Likewise.\n\t(arm_cmpdi_insn,arm_cmpdi_unsigned): Likewise.\n\nFrom-SVN: r197522", "tree": {"sha": "bfb596ed3f4a872951e928851443e297d440d564", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bfb596ed3f4a872951e928851443e297d440d564"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3f3bf1a8bfe2212d9a83b5316d93a4add718dbf2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f3bf1a8bfe2212d9a83b5316d93a4add718dbf2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3f3bf1a8bfe2212d9a83b5316d93a4add718dbf2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f3bf1a8bfe2212d9a83b5316d93a4add718dbf2/comments", "author": null, "committer": null, "parents": [{"sha": "b0b495563618f288188f2f3fb0de390d8d19166f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b0b495563618f288188f2f3fb0de390d8d19166f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b0b495563618f288188f2f3fb0de390d8d19166f"}], "stats": {"total": 191, "additions": 175, "deletions": 16}, "files": [{"sha": "f3a799ca64b5c055344edde42e40a9c24c6a5034", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f3bf1a8bfe2212d9a83b5316d93a4add718dbf2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f3bf1a8bfe2212d9a83b5316d93a4add718dbf2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3f3bf1a8bfe2212d9a83b5316d93a4add718dbf2", "patch": "@@ -1,3 +1,10 @@\n+2013-04-05  Greta Yorsh  <Greta.Yorsh@arm.com>\n+\n+\t* config/arm/arm.md (andsi_iorsi3_notsi): Convert define_insn into\n+\tdefine_insn_and_split.\n+\t(arm_negdi2,arm_abssi2,arm_neg_abssi2): Likewise.\n+\t(arm_cmpdi_insn,arm_cmpdi_unsigned): Likewise.\n+\n 2013-04-05  Greta Yorsh  <Greta.Yorsh@arm.com>\n \n \t* config/arm/arm.md (arm_subdi3): Convert define_insn into"}, {"sha": "5c6d30e4534ec0a4960aa6dc4109e53b3f4a7526", "filename": "gcc/config/arm/arm.md", "status": "modified", "additions": 168, "deletions": 16, "changes": 184, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f3bf1a8bfe2212d9a83b5316d93a4add718dbf2/gcc%2Fconfig%2Farm%2Farm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f3bf1a8bfe2212d9a83b5316d93a4add718dbf2/gcc%2Fconfig%2Farm%2Farm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.md?ref=3f3bf1a8bfe2212d9a83b5316d93a4add718dbf2", "patch": "@@ -3215,13 +3215,17 @@\n   \"\"\n )\n \n-(define_insn \"*andsi_iorsi3_notsi\"\n+(define_insn_and_split \"*andsi_iorsi3_notsi\"\n   [(set (match_operand:SI 0 \"s_register_operand\" \"=&r,&r,&r\")\n \t(and:SI (ior:SI (match_operand:SI 1 \"s_register_operand\" \"%0,r,r\")\n \t\t\t(match_operand:SI 2 \"arm_rhs_operand\" \"rI,0,rI\"))\n \t\t(not:SI (match_operand:SI 3 \"arm_rhs_operand\" \"rI,rI,rI\"))))]\n   \"TARGET_32BIT\"\n-  \"orr%?\\\\t%0, %1, %2\\;bic%?\\\\t%0, %0, %3\"\n+  \"#\"   ; \"orr%?\\\\t%0, %1, %2\\;bic%?\\\\t%0, %0, %3\"\n+  \"&& reload_completed\"\n+  [(set (match_dup 0) (ior:SI (match_dup 1) (match_dup 2)))\n+   (set (match_dup 0) (and:SI (not:SI (match_dup 3)) (match_dup 0)))]\n+  \"\"\n   [(set_attr \"length\" \"8\")\n    (set_attr \"ce_count\" \"2\")\n    (set_attr \"predicable\" \"yes\")]\n@@ -4273,12 +4277,24 @@\n \n ;; The constraints here are to prevent a *partial* overlap (where %Q0 == %R1).\n ;; The first alternative allows the common case of a *full* overlap.\n-(define_insn \"*arm_negdi2\"\n+(define_insn_and_split \"*arm_negdi2\"\n   [(set (match_operand:DI         0 \"s_register_operand\" \"=r,&r\")\n \t(neg:DI (match_operand:DI 1 \"s_register_operand\"  \"0,r\")))\n    (clobber (reg:CC CC_REGNUM))]\n   \"TARGET_ARM\"\n-  \"rsbs\\\\t%Q0, %Q1, #0\\;rsc\\\\t%R0, %R1, #0\"\n+  \"#\"   ; \"rsbs\\\\t%Q0, %Q1, #0\\;rsc\\\\t%R0, %R1, #0\"\n+  \"&& reload_completed\"\n+  [(parallel [(set (reg:CC CC_REGNUM)\n+\t\t   (compare:CC (const_int 0) (match_dup 1)))\n+\t      (set (match_dup 0) (minus:SI (const_int 0) (match_dup 1)))])\n+   (set (match_dup 2) (minus:SI (minus:SI (const_int 0) (match_dup 3))\n+                                (ltu:SI (reg:CC_C CC_REGNUM) (const_int 0))))]\n+  {\n+    operands[2] = gen_highpart (SImode, operands[0]);\n+    operands[0] = gen_lowpart (SImode, operands[0]);\n+    operands[3] = gen_highpart (SImode, operands[1]);\n+    operands[1] = gen_lowpart (SImode, operands[1]);\n+  }\n   [(set_attr \"conds\" \"clob\")\n    (set_attr \"length\" \"8\")]\n )\n@@ -4346,14 +4362,67 @@\n     operands[2] = gen_rtx_REG (CCmode, CC_REGNUM);\n \")\n \n-(define_insn \"*arm_abssi2\"\n+(define_insn_and_split \"*arm_abssi2\"\n   [(set (match_operand:SI 0 \"s_register_operand\" \"=r,&r\")\n \t(abs:SI (match_operand:SI 1 \"s_register_operand\" \"0,r\")))\n    (clobber (reg:CC CC_REGNUM))]\n   \"TARGET_ARM\"\n-  \"@\n-   cmp\\\\t%0, #0\\;rsblt\\\\t%0, %0, #0\n-   eor%?\\\\t%0, %1, %1, asr #31\\;sub%?\\\\t%0, %0, %1, asr #31\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(const_int 0)]\n+  {\n+   /* if (which_alternative == 0) */\n+   if (REGNO(operands[0]) == REGNO(operands[1]))\n+     {\n+      /* Emit the pattern:\n+         cmp\\\\t%0, #0\\;rsblt\\\\t%0, %0, #0\n+         [(set (reg:CC CC_REGNUM)\n+               (compare:CC (match_dup 0) (const_int 0)))\n+          (cond_exec (lt:CC (reg:CC CC_REGNUM) (const_int 0))\n+                     (set (match_dup 0) (minus:SI (const_int 0) (match_dup 1))))]\n+      */\n+      emit_insn (gen_rtx_SET (VOIDmode,\n+                              gen_rtx_REG (CCmode, CC_REGNUM),\n+                              gen_rtx_COMPARE (CCmode, operands[0], const0_rtx)));\n+      emit_insn (gen_rtx_COND_EXEC (VOIDmode,\n+                                    (gen_rtx_LT (SImode,\n+                                                 gen_rtx_REG (CCmode, CC_REGNUM),\n+                                                 const0_rtx)),\n+                                    (gen_rtx_SET (VOIDmode,\n+                                                  operands[0],\n+                                                  (gen_rtx_MINUS (SImode,\n+                                                                  const0_rtx,\n+                                                                  operands[1]))))));\n+      DONE;\n+     }\n+   else\n+     {\n+      /* Emit the pattern:\n+         alt1: eor%?\\\\t%0, %1, %1, asr #31\\;sub%?\\\\t%0, %0, %1, asr #31\n+         [(set (match_dup 0)\n+               (xor:SI (match_dup 1)\n+                       (ashiftrt:SI (match_dup 1) (const_int 31))))\n+          (set (match_dup 0)\n+               (minus:SI (match_dup 0)\n+                      (ashiftrt:SI (match_dup 1) (const_int 31))))]\n+      */\n+      emit_insn (gen_rtx_SET (VOIDmode,\n+                              operands[0],\n+                              gen_rtx_XOR (SImode,\n+                                           gen_rtx_ASHIFTRT (SImode,\n+                                                             operands[1],\n+                                                             GEN_INT (31)),\n+                                           operands[1])));\n+      emit_insn (gen_rtx_SET (VOIDmode,\n+                              operands[0],\n+                              gen_rtx_MINUS (SImode,\n+                                             operands[0],\n+                                             gen_rtx_ASHIFTRT (SImode,\n+                                                               operands[1],\n+                                                               GEN_INT (31)))));\n+      DONE;\n+     }\n+  }\n   [(set_attr \"conds\" \"clob,*\")\n    (set_attr \"shift\" \"1\")\n    (set_attr \"predicable\" \"no, yes\")\n@@ -4374,14 +4443,56 @@\n   [(set_attr \"length\" \"6\")]\n )\n \n-(define_insn \"*arm_neg_abssi2\"\n+(define_insn_and_split \"*arm_neg_abssi2\"\n   [(set (match_operand:SI 0 \"s_register_operand\" \"=r,&r\")\n \t(neg:SI (abs:SI (match_operand:SI 1 \"s_register_operand\" \"0,r\"))))\n    (clobber (reg:CC CC_REGNUM))]\n   \"TARGET_ARM\"\n-  \"@\n-   cmp\\\\t%0, #0\\;rsbgt\\\\t%0, %0, #0\n-   eor%?\\\\t%0, %1, %1, asr #31\\;rsb%?\\\\t%0, %0, %1, asr #31\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(const_int 0)]\n+  {\n+   /* if (which_alternative == 0) */\n+   if (REGNO (operands[0]) == REGNO (operands[1]))\n+     {\n+      /* Emit the pattern:\n+         cmp\\\\t%0, #0\\;rsbgt\\\\t%0, %0, #0\n+      */\n+      emit_insn (gen_rtx_SET (VOIDmode,\n+                              gen_rtx_REG (CCmode, CC_REGNUM),\n+                              gen_rtx_COMPARE (CCmode, operands[0], const0_rtx)));\n+      emit_insn (gen_rtx_COND_EXEC (VOIDmode,\n+                                    gen_rtx_GT (SImode,\n+                                                gen_rtx_REG (CCmode, CC_REGNUM),\n+                                                const0_rtx),\n+                                    gen_rtx_SET (VOIDmode,\n+                                                 operands[0],\n+                                                 (gen_rtx_MINUS (SImode,\n+                                                                 const0_rtx,\n+                                                                 operands[1])))));\n+     }\n+   else\n+     {\n+      /* Emit the pattern:\n+         eor%?\\\\t%0, %1, %1, asr #31\\;rsb%?\\\\t%0, %0, %1, asr #31\n+      */\n+      emit_insn (gen_rtx_SET (VOIDmode,\n+                              operands[0],\n+                              gen_rtx_XOR (SImode,\n+                                           gen_rtx_ASHIFTRT (SImode,\n+                                                             operands[1],\n+                                                             GEN_INT (31)),\n+                                           operands[1])));\n+      emit_insn (gen_rtx_SET (VOIDmode,\n+                              operands[0],\n+                              gen_rtx_MINUS (SImode,\n+                                             gen_rtx_ASHIFTRT (SImode,\n+                                                               operands[1],\n+                                                               GEN_INT (31)),\n+                                             operands[0])));\n+     }\n+   DONE;\n+  }\n   [(set_attr \"conds\" \"clob,*\")\n    (set_attr \"shift\" \"1\")\n    (set_attr \"predicable\" \"no, yes\")\n@@ -7736,23 +7847,64 @@\n ;; if-conversion can not reduce to a conditional compare, so we do\n ;; that directly.\n \n-(define_insn \"*arm_cmpdi_insn\"\n+(define_insn_and_split \"*arm_cmpdi_insn\"\n   [(set (reg:CC_NCV CC_REGNUM)\n \t(compare:CC_NCV (match_operand:DI 0 \"s_register_operand\" \"r\")\n \t\t\t(match_operand:DI 1 \"arm_di_operand\"\t   \"rDi\")))\n    (clobber (match_scratch:SI 2 \"=r\"))]\n   \"TARGET_32BIT\"\n-  \"cmp\\\\t%Q0, %Q1\\;sbcs\\\\t%2, %R0, %R1\"\n+  \"#\"   ; \"cmp\\\\t%Q0, %Q1\\;sbcs\\\\t%2, %R0, %R1\"\n+  \"&& reload_completed\"\n+  [(set (reg:CC CC_REGNUM)\n+        (compare:CC (match_dup 0) (match_dup 1)))\n+   (parallel [(set (reg:CC CC_REGNUM)\n+                   (compare:CC (match_dup 3) (match_dup 4)))\n+              (set (match_dup 2)\n+                   (minus:SI (match_dup 5)\n+                            (ltu:SI (reg:CC_C CC_REGNUM) (const_int 0))))])]\n+  {\n+    operands[3] = gen_highpart (SImode, operands[0]);\n+    operands[0] = gen_lowpart (SImode, operands[0]);\n+    if (CONST_INT_P (operands[1]))\n+      {\n+        operands[4] = GEN_INT (~INTVAL (gen_highpart_mode (SImode,\n+                                                           DImode,\n+                                                           operands[1])));\n+        operands[5] = gen_rtx_PLUS (SImode, operands[3], operands[4]);\n+      }\n+    else\n+      {\n+        operands[4] = gen_highpart (SImode, operands[1]);\n+        operands[5] = gen_rtx_MINUS (SImode, operands[3], operands[4]);\n+      }\n+    operands[1] = gen_lowpart (SImode, operands[1]);\n+    operands[2] = gen_lowpart (SImode, operands[2]);\n+  }\n   [(set_attr \"conds\" \"set\")\n    (set_attr \"length\" \"8\")]\n )\n \n-(define_insn \"*arm_cmpdi_unsigned\"\n+(define_insn_and_split \"*arm_cmpdi_unsigned\"\n   [(set (reg:CC_CZ CC_REGNUM)\n \t(compare:CC_CZ (match_operand:DI 0 \"s_register_operand\" \"r\")\n \t\t       (match_operand:DI 1 \"arm_di_operand\"\t\"rDi\")))]\n   \"TARGET_32BIT\"\n-  \"cmp\\\\t%R0, %R1\\;it eq\\;cmpeq\\\\t%Q0, %Q1\"\n+  \"#\"   ; \"cmp\\\\t%R0, %R1\\;it eq\\;cmpeq\\\\t%Q0, %Q1\"\n+  \"&& reload_completed\"\n+  [(set (reg:CC CC_REGNUM)\n+        (compare:CC (match_dup 2) (match_dup 3)))\n+   (cond_exec (eq:SI (reg:CC CC_REGNUM) (const_int 0))\n+              (set (reg:CC CC_REGNUM)\n+                   (compare:CC (match_dup 0) (match_dup 1))))]\n+  {\n+    operands[2] = gen_highpart (SImode, operands[0]);\n+    operands[0] = gen_lowpart (SImode, operands[0]);\n+    if (CONST_INT_P (operands[1]))\n+      operands[3] = gen_highpart_mode (SImode, DImode, operands[1]);\n+    else\n+      operands[3] = gen_highpart (SImode, operands[1]);\n+    operands[1] = gen_lowpart (SImode, operands[1]);\n+  }\n   [(set_attr \"conds\" \"set\")\n    (set_attr \"length\" \"8\")]\n )"}]}