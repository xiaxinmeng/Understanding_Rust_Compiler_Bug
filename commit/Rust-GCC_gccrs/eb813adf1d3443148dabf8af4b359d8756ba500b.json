{"sha": "eb813adf1d3443148dabf8af4b359d8756ba500b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWI4MTNhZGYxZDM0NDMxNDhkYWJmOGFmNGIzNTlkODc1NmJhNTAwYg==", "commit": {"author": {"name": "Guilhem Lavaux", "email": "guilhem@kaffe.org", "date": "2003-12-31T11:04:21Z"}, "committer": {"name": "Michael Koch", "email": "mkoch@gcc.gnu.org", "date": "2003-12-31T11:04:21Z"}, "message": "2003-12-31  Guilhem Lavaux  <guilhem@kaffe.org>\n\n\t* java/io/ObjectOutputStream.java\n\t(putFields): Reindented. Fixed behaviour: currentPutField should be\n\tnull\n\tbefore calling this method.\n\t(writeFields): Likewise.\n\t(markFieldsWritten): Fixed the exception message.\n\t(callWriteMethod): Ensure currentPutField is null.\n\t(getBooleanField): Translate IllegalArgumentException into\n\tInvalidClassException.\n\t(getByteField): Likewise.\n\t(getCharField): Likewise.\n\t(getDoubleField): Likewise.\n\t(getFloatField): Likewise.\n\t(getIntField): Likewise.\n\t(getLongField): Likewise.\n\t(getShortField): Likewise.\n\t(getObjectField): Check the type code before returning the object.\n\t(getField): Translate NoSuchFieldException into InvalidClassException\n\tdirectly.\n\nFrom-SVN: r75265", "tree": {"sha": "090301558a106672953dc317d4505fd4824724e0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/090301558a106672953dc317d4505fd4824724e0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/eb813adf1d3443148dabf8af4b359d8756ba500b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eb813adf1d3443148dabf8af4b359d8756ba500b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eb813adf1d3443148dabf8af4b359d8756ba500b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eb813adf1d3443148dabf8af4b359d8756ba500b/comments", "author": null, "committer": null, "parents": [{"sha": "d415865929d00608b5eeedd824ee679e673f18f3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d415865929d00608b5eeedd824ee679e673f18f3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d415865929d00608b5eeedd824ee679e673f18f3"}], "stats": {"total": 398, "additions": 260, "deletions": 138}, "files": [{"sha": "c60998e527c3aba0f3b7594429264243e7f0f4fd", "filename": "libjava/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb813adf1d3443148dabf8af4b359d8756ba500b/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb813adf1d3443148dabf8af4b359d8756ba500b/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=eb813adf1d3443148dabf8af4b359d8756ba500b", "patch": "@@ -1,3 +1,25 @@\n+2003-12-31  Guilhem Lavaux  <guilhem@kaffe.org>\n+\n+\t* java/io/ObjectOutputStream.java\n+\t(putFields): Reindented. Fixed behaviour: currentPutField should be\n+\tnull\n+\tbefore calling this method.\n+\t(writeFields): Likewise.\n+\t(markFieldsWritten): Fixed the exception message.\n+\t(callWriteMethod): Ensure currentPutField is null.\n+\t(getBooleanField): Translate IllegalArgumentException into\n+\tInvalidClassException.\n+\t(getByteField): Likewise.\n+\t(getCharField): Likewise.\n+\t(getDoubleField): Likewise.\n+\t(getFloatField): Likewise.\n+\t(getIntField): Likewise.\n+\t(getLongField): Likewise.\n+\t(getShortField): Likewise.\n+\t(getObjectField): Check the type code before returning the object.\n+\t(getField): Translate NoSuchFieldException into InvalidClassException\n+\tdirectly.\n+\n 2003-12-31 Guilhem Lavaux <guilhem@kaffe.org>\n \n \t* java/net/URL.java"}, {"sha": "b60f3b6a100d7b40796c9fc5023e946be06179e9", "filename": "libjava/java/io/ObjectOutputStream.java", "status": "modified", "additions": 238, "deletions": 138, "changes": 376, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb813adf1d3443148dabf8af4b359d8756ba500b/libjava%2Fjava%2Fio%2FObjectOutputStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb813adf1d3443148dabf8af4b359d8756ba500b/libjava%2Fjava%2Fio%2FObjectOutputStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FObjectOutputStream.java?ref=eb813adf1d3443148dabf8af4b359d8756ba500b", "patch": "@@ -162,6 +162,9 @@ public ObjectOutputStream (OutputStream out) throws IOException\n    * @exception NotSerializableException An attempt was made to\n    * serialize an <code>Object</code> that is not serializable.\n    *\n+   * @exception InvalidClassException Somebody tried to serialize\n+   * an object which is wrongly formatted.\n+   *\n    * @exception IOException Exception from underlying\n    * <code>OutputStream</code>.\n    */\n@@ -447,7 +450,7 @@ private void markFieldsWritten() throws IOException\n \n     if (fieldsAlreadyWritten)\n       throw new IOException\n-\t(\"Only one of putFields and defaultWriteObject may be called, and it may only be called once\");\n+\t(\"Only one of writeFields and defaultWriteObject may be called, and it may only be called once\");\n \n     fieldsAlreadyWritten = true;\n   }\n@@ -870,142 +873,150 @@ public void writeUTF(String data) throws IOException\n \n   public PutField putFields() throws IOException\n   {\n-    if (currentPutField == null)\n+    if (currentPutField != null)\n+      return currentPutField;\n+\n+    currentPutField = new PutField()\n       {\n-\tcurrentPutField = new PutField ()\n-\t  {\n-\t    private byte[] prim_field_data =\n-\t      new byte[currentObjectStreamClass.primFieldSize];\n-\t    private Object[] objs =\n-\t      new Object[currentObjectStreamClass.objectFieldCount];\n+\tprivate byte[] prim_field_data\n+\t  = new byte[currentObjectStreamClass.primFieldSize];\n+\tprivate Object[] objs\n+\t  = new Object[currentObjectStreamClass.objectFieldCount];\n \n-\t    public void put (String name, boolean value)\n-\t    {\n-\t      ObjectStreamField field\n-\t\t= currentObjectStreamClass.getField (name);\n-\t      checkType (field, 'Z');\n-\t      prim_field_data[field.getOffset ()] = (byte)(value ? 1 : 0);\n-\t    }\n+\tprivate ObjectStreamField getField (String name)\n+\t{\n+\t  ObjectStreamField field\n+\t    = currentObjectStreamClass.getField(name);\n+\t  \n+\t  if (field == null)\n+\t    throw new IllegalArgumentException(\"no such serializable field \" + name);\n+\t  \n+\t  return field;\n+\t}\n+\t\n+\tpublic void put(String name, boolean value)\n+\t{\n+\t  ObjectStreamField field = getField(name);\n \n-\t    public void put (String name, byte value)\n-\t    {\n-\t      ObjectStreamField field\n-\t\t= currentObjectStreamClass.getField (name);\n-\t      checkType (field, 'B');\n-\t      prim_field_data[field.getOffset ()] = value;\n-\t    }\n+\t  checkType(field, 'Z');\n+\t  prim_field_data[field.getOffset ()] = (byte)(value ? 1 : 0);\n+\t}\n \n-\t    public void put (String name, char value)\n-\t    {\n-\t      ObjectStreamField field\n-\t\t= currentObjectStreamClass.getField (name);\n-\t      checkType (field, 'C');\n-\t      int off = field.getOffset ();\n-\t      prim_field_data[off++] = (byte)(value >>> 8);\n-\t      prim_field_data[off] = (byte)value;\n-\t    }\n+\tpublic void put(String name, byte value)\n+\t{\n+\t  ObjectStreamField field = getField(name);\n \n-\t    public void put (String name, double value)\n-\t    {\n-\t      ObjectStreamField field\n-\t\t= currentObjectStreamClass.getField (name);\n-\t      checkType (field, 'D');\n-\t      int off = field.getOffset ();\n-\t      long l_value = Double.doubleToLongBits (value);\n-\t      prim_field_data[off++] = (byte)(l_value >>> 52);\n-\t      prim_field_data[off++] = (byte)(l_value >>> 48);\n-\t      prim_field_data[off++] = (byte)(l_value >>> 40);\n-\t      prim_field_data[off++] = (byte)(l_value >>> 32);\n-\t      prim_field_data[off++] = (byte)(l_value >>> 24);\n-\t      prim_field_data[off++] = (byte)(l_value >>> 16);\n-\t      prim_field_data[off++] = (byte)(l_value >>> 8);\n-\t      prim_field_data[off] = (byte)l_value;\n-\t    }\n+\t  checkType(field, 'B');\n+\t  prim_field_data[field.getOffset()] = value;\n+\t}\n \n-\t    public void put (String name, float value)\n-\t    {\n-\t      ObjectStreamField field\n-\t\t= currentObjectStreamClass.getField (name);\n-\t      checkType (field, 'F');\n-\t      int off = field.getOffset ();\n-\t      int i_value = Float.floatToIntBits (value);\n-\t      prim_field_data[off++] = (byte)(i_value >>> 24);\n-\t      prim_field_data[off++] = (byte)(i_value >>> 16);\n-\t      prim_field_data[off++] = (byte)(i_value >>> 8);\n-\t      prim_field_data[off] = (byte)i_value;\n-\t    }\n+\tpublic void put(String name, char value)\n+\t{\n+\t  ObjectStreamField field = getField(name);\n \n-\t    public void put (String name, int value)\n-\t    {\n-\t      ObjectStreamField field\n-\t\t= currentObjectStreamClass.getField (name);\n-\t      checkType (field, 'I');\n-\t      int off = field.getOffset ();\n-\t      prim_field_data[off++] = (byte)(value >>> 24);\n-\t      prim_field_data[off++] = (byte)(value >>> 16);\n-\t      prim_field_data[off++] = (byte)(value >>> 8);\n-\t      prim_field_data[off] = (byte)value;\n-\t    }\n+\t  checkType(field, 'C');\n+\t  int off = field.getOffset();\n+\t  prim_field_data[off++] = (byte)(value >>> 8);\n+\t  prim_field_data[off] = (byte)value;\n+\t}\n \n-\t    public void put (String name, long value)\n-\t    {\n-\t      ObjectStreamField field\n-\t\t= currentObjectStreamClass.getField (name);\n-\t      checkType (field, 'J');\n-\t      int off = field.getOffset ();\n-\t      prim_field_data[off++] = (byte)(value >>> 52);\n-\t      prim_field_data[off++] = (byte)(value >>> 48);\n-\t      prim_field_data[off++] = (byte)(value >>> 40);\n-\t      prim_field_data[off++] = (byte)(value >>> 32);\n-\t      prim_field_data[off++] = (byte)(value >>> 24);\n-\t      prim_field_data[off++] = (byte)(value >>> 16);\n-\t      prim_field_data[off++] = (byte)(value >>> 8);\n-\t      prim_field_data[off] = (byte)value;\n-\t    }\n+\tpublic void put(String name, double value)\n+\t{\n+\t  ObjectStreamField field = getField (name);\n+\n+\t  checkType(field, 'D');\n+\t  int off = field.getOffset();\n+\t  long l_value = Double.doubleToLongBits (value);\n+\t  prim_field_data[off++] = (byte)(l_value >>> 52);\n+\t  prim_field_data[off++] = (byte)(l_value >>> 48);\n+\t  prim_field_data[off++] = (byte)(l_value >>> 40);\n+\t  prim_field_data[off++] = (byte)(l_value >>> 32);\n+\t  prim_field_data[off++] = (byte)(l_value >>> 24);\n+\t  prim_field_data[off++] = (byte)(l_value >>> 16);\n+\t  prim_field_data[off++] = (byte)(l_value >>> 8);\n+\t  prim_field_data[off] = (byte)l_value;\n+\t}\n \n-\t    public void put (String name, short value)\n-\t    {\n-\t      ObjectStreamField field\n-\t\t= currentObjectStreamClass.getField (name);\n-\t      checkType (field, 'S');\n-\t      int off = field.getOffset ();\n-\t      prim_field_data[off++] = (byte)(value >>> 8);\n-\t      prim_field_data[off] = (byte)value;\n-\t    }\n+\tpublic void put(String name, float value)\n+\t{\n+\t  ObjectStreamField field = getField(name);\n+\n+\t  checkType(field, 'F');\n+\t  int off = field.getOffset();\n+\t  int i_value = Float.floatToIntBits(value);\n+\t  prim_field_data[off++] = (byte)(i_value >>> 24);\n+\t  prim_field_data[off++] = (byte)(i_value >>> 16);\n+\t  prim_field_data[off++] = (byte)(i_value >>> 8);\n+\t  prim_field_data[off] = (byte)i_value;\n+\t}\n \n-\t    public void put (String name, Object value)\n-\t    {\n-\t      ObjectStreamField field\n-\t\t= currentObjectStreamClass.getField (name);\n-\t      if (field == null)\n-\t\tthrow new IllegalArgumentException ();\n-\t      if (value != null &&\n-\t\t  ! field.getType ().isAssignableFrom (value.getClass ()))\n-\t\tthrow new IllegalArgumentException ();\n-\t      objs[field.getOffset ()] = value;\n-\t    }\n+\tpublic void put(String name, int value)\n+\t{\n+\t  ObjectStreamField field = getField(name);\n+\t  checkType(field, 'I');\n+\t  int off = field.getOffset();\n+\t  prim_field_data[off++] = (byte)(value >>> 24);\n+\t  prim_field_data[off++] = (byte)(value >>> 16);\n+\t  prim_field_data[off++] = (byte)(value >>> 8);\n+\t  prim_field_data[off] = (byte)value;\n+\t}\n \n-\t    public void write (ObjectOutput out) throws IOException\n-\t    {\n-\t      // Apparently Block data is not used with PutField as per\n-\t      // empirical evidence against JDK 1.2.  Also see Mauve test\n-\t      // java.io.ObjectInputOutput.Test.GetPutField.\n-\t      boolean oldmode = setBlockDataMode (false);\n-\t      out.write (prim_field_data);\n-\t      for (int i = 0; i < objs.length; ++ i)\n-\t\tout.writeObject (objs[i]);\n-\t      setBlockDataMode (oldmode);\n-\t    }\n+\tpublic void put(String name, long value)\n+\t{\n+\t  ObjectStreamField field = getField(name);\n+\t  checkType(field, 'J');\n+\t  int off = field.getOffset();\n+\t  prim_field_data[off++] = (byte)(value >>> 52);\n+\t  prim_field_data[off++] = (byte)(value >>> 48);\n+\t  prim_field_data[off++] = (byte)(value >>> 40);\n+\t  prim_field_data[off++] = (byte)(value >>> 32);\n+\t  prim_field_data[off++] = (byte)(value >>> 24);\n+\t  prim_field_data[off++] = (byte)(value >>> 16);\n+\t  prim_field_data[off++] = (byte)(value >>> 8);\n+\t  prim_field_data[off] = (byte)value;\n+\t}\n \n-\t    private void checkType (ObjectStreamField field, char type)\n-\t      throws IllegalArgumentException\n-\t    {\n-\t      if (TypeSignature.getEncodingOfClass(field.getType ()).charAt(0)\n-\t\t  != type)\n-\t\tthrow new IllegalArgumentException ();\n-\t    }\n-\t  };\n-      }\n+\tpublic void put(String name, short value)\n+\t{\n+\t  ObjectStreamField field = getField(name);\n+\t  checkType(field, 'S');\n+\t  int off = field.getOffset();\n+\t  prim_field_data[off++] = (byte)(value >>> 8);\n+\t  prim_field_data[off] = (byte)value;\n+\t}\n+\n+\tpublic void put(String name, Object value)\n+\t{\n+\t  ObjectStreamField field = getField(name);\n+\n+\t  if (value != null &&\n+\t      ! field.getType().isAssignableFrom(value.getClass ()))\t    \n+\t    throw new IllegalArgumentException(\"Class \" + value.getClass() +\n+\t\t\t\t\t       \" cannot be cast to \" + field.getType());\n+\t  objs[field.getOffset()] = value;\n+\t}\n+\n+\tpublic void write(ObjectOutput out) throws IOException\n+\t{\n+\t  // Apparently Block data is not used with PutField as per\n+\t  // empirical evidence against JDK 1.2.  Also see Mauve test\n+\t  // java.io.ObjectInputOutput.Test.GetPutField.\n+\t  boolean oldmode = setBlockDataMode(false);\n+\t  out.write(prim_field_data);\n+\t  for (int i = 0; i < objs.length; ++ i)\n+\t    out.writeObject(objs[i]);\n+\t  setBlockDataMode(oldmode);\n+\t}\n+\n+\tprivate void checkType(ObjectStreamField field, char type)\n+\t  throws IllegalArgumentException\n+\t{\n+\t  if (TypeSignature.getEncodingOfClass(field.getType()).charAt(0)\n+\t      != type)\n+\t    throw new IllegalArgumentException();\n+\t}\n+      };\n+    // end PutFieldImpl\n \n     return currentPutField;\n   }\n@@ -1016,11 +1027,8 @@ public void writeFields() throws IOException\n     if (currentPutField == null)\n       throw new NotActiveException(\"writeFields can only be called after putFields has been called\");\n \n-    // putFields may be called more than once, but not writeFields.\n     markFieldsWritten();\n-\n     currentPutField.write(this);\n-    currentPutField = null;\n   }\n \n \n@@ -1210,6 +1218,7 @@ private void callWriteMethod(Object obj, ObjectStreamClass osc)\n     throws IOException\n   {\n     Class klass = osc.forClass();\n+    currentPutField = null;\n     try\n       {\n \tClass classArgs[] = {ObjectOutputStream.class};\n@@ -1255,6 +1264,15 @@ private boolean getBooleanField(Object obj, Class klass, String field_name)\n \tboolean b = f.getBoolean(obj);\n \treturn b;\n       }\n+    catch (IllegalArgumentException _)\n+      {\n+\tthrow new InvalidClassException\n+\t  (\"invalid requested type for field \" + field_name + \" in class \" + klass.getName());\n+      }\n+    catch (IOException e)\n+      {\n+\tthrow e;\n+      }\n     catch (Exception _)\n       {\n \tthrow new IOException(\"Unexpected exception \" + _);\n@@ -1270,6 +1288,15 @@ private byte getByteField (Object obj, Class klass, String field_name)\n \tbyte b = f.getByte (obj);\n \treturn b;\n       }\n+    catch (IllegalArgumentException _)\n+      {\n+\tthrow new InvalidClassException\n+\t  (\"invalid requested type for field \" + field_name + \" in class \" + klass.getName());\n+      }\n+    catch (IOException e)\n+      {\n+\tthrow e;\n+      }\n     catch (Exception _)\n       {\n \tthrow new IOException(\"Unexpected exception \" + _);\n@@ -1285,6 +1312,15 @@ private char getCharField (Object obj, Class klass, String field_name)\n \tchar b = f.getChar (obj);\n \treturn b;\n       }\n+    catch (IllegalArgumentException _)\n+      {\n+\tthrow new InvalidClassException\n+\t  (\"invalid requested type for field \" + field_name + \" in class \" + klass.getName());\n+      }\n+    catch (IOException e)\n+      {\n+\tthrow e;\n+      }\n     catch (Exception _)\n       {\n \tthrow new IOException(\"Unexpected exception \" + _);\n@@ -1300,6 +1336,15 @@ private double getDoubleField (Object obj, Class klass, String field_name)\n \tdouble b = f.getDouble (obj);\n \treturn b;\n       }\n+    catch (IllegalArgumentException _)\n+      {\n+\tthrow new InvalidClassException\n+\t  (\"invalid requested type for field \" + field_name + \" in class \" + klass.getName());\n+      }\n+    catch (IOException e)\n+      {\n+\tthrow e;\n+      }\n     catch (Exception _)\n       {\n \tthrow new IOException(\"Unexpected exception \" + _);\n@@ -1315,6 +1360,15 @@ private float getFloatField (Object obj, Class klass, String field_name)\n \tfloat b = f.getFloat (obj);\n \treturn b;\n       }\n+    catch (IllegalArgumentException _)\n+      {\n+\tthrow new InvalidClassException\n+\t  (\"invalid requested type for field \" + field_name + \" in class \" + klass.getName());\n+      }\n+    catch (IOException e)\n+      {\n+\tthrow e;\n+      }\n     catch (Exception _)\n       {\n \tthrow new IOException(\"Unexpected exception \" + _);\n@@ -1330,6 +1384,15 @@ private int getIntField (Object obj, Class klass, String field_name)\n \tint b = f.getInt (obj);\n \treturn b;\n       }\n+    catch (IllegalArgumentException _)\n+      {\n+\tthrow new InvalidClassException\n+\t  (\"invalid requested type for field \" + field_name + \" in class \" + klass.getName());\n+      }\n+    catch (IOException e)\n+      {\n+\tthrow e;\n+      }\n     catch (Exception _)\n       {\n \tthrow new IOException(\"Unexpected exception \" + _);\n@@ -1345,6 +1408,15 @@ private long getLongField (Object obj, Class klass, String field_name)\n \tlong b = f.getLong (obj);\n \treturn b;\n       }\n+    catch (IllegalArgumentException _)\n+      {\n+\tthrow new InvalidClassException\n+\t  (\"invalid requested type for field \" + field_name + \" in class \" + klass.getName());\n+      }\n+    catch (IOException e)\n+      {\n+\tthrow e;\n+      }\n     catch (Exception _)\n       {\n \tthrow new IOException(\"Unexpected exception \" + _);\n@@ -1360,6 +1432,15 @@ private short getShortField (Object obj, Class klass, String field_name)\n \tshort b = f.getShort (obj);\n \treturn b;\n       }\n+    catch (IllegalArgumentException _)\n+      {\n+\tthrow new InvalidClassException\n+\t  (\"invalid requested type for field \" + field_name + \" in class \" + klass.getName());\n+      }\n+    catch (IOException e)\n+      {\n+       throw e;\n+      }\n     catch (Exception _)\n       {\n \tthrow new IOException(\"Unexpected exception \" + _);\n@@ -1372,29 +1453,48 @@ private Object getObjectField (Object obj, Class klass, String field_name,\n     try\n       {\n \tField f = getField (klass, field_name);\n+\tObjectStreamField of = new ObjectStreamField(f.getName(), f.getType());\n+\n+\tif (of.getTypeString() == null ||\n+\t    !of.getTypeString().equals(type_code))\n+\t  throw new InvalidClassException\n+\t    (\"invalid type code for \" + field_name + \" in class \" + klass.getName());\n+\n \tObject o = f.get (obj);\n \t// FIXME: We should check the type_code here\n \treturn o;\n       }\n+    catch (IOException e)\n+      {\n+\tthrow e;\n+      }\n     catch (Exception e)\n       {\n \tthrow new IOException ();\n       }    \n   }\n \n   private static Field getField (Class klass, String name)\n-    throws java.lang.NoSuchFieldException\n+    throws java.io.InvalidClassException\n   {\n-    final Field f = klass.getDeclaredField(name);\n-    AccessController.doPrivileged(new PrivilegedAction()\n+    try\n       {\n-\tpublic Object run()\n-\t{\n-\t  f.setAccessible(true);\n-\t  return null;\n-\t}\n-      });\n-    return f;\n+\tfinal Field f = klass.getDeclaredField(name);\n+\tAccessController.doPrivileged(new PrivilegedAction()\n+\t  {\n+\t    public Object run()\n+\t    {\n+\t      f.setAccessible(true);\n+\t      return null;\n+\t    }\n+\t  });\n+\treturn f;\n+      }\n+    catch (java.lang.NoSuchFieldException e)\n+      {\n+\tthrow new InvalidClassException\n+\t  (\"no field called \" + name + \" in class \" + klass.getName());\n+      }\n   }\n \n   private static Method getMethod (Class klass, String name, Class[] args)"}]}