{"sha": "e33eba75933fdd7bd895a3b35ef1b1b710ddbb13", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTMzZWJhNzU5MzNmZGQ3YmQ4OTVhM2IzNWVmMWIxYjcxMGRkYmIxMw==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2011-03-11T15:43:37Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2011-03-11T15:43:37Z"}, "message": "re PR c++/48035 (Mismatch on size of class when initializing hierarchy involving virtual inheritance and empty base classes)\n\n\tPR c++/48035\n\t* init.c (build_zero_init_1): Extracted from build_zero_init.\n\tAdd FIELD_SIZE argument, if non-NULL and field bit_position\n\tas not smaller than that, don't add that field's initializer.\n\tPass DECL_SIZE as last argument to build_zero_init_1\n\tfor DECL_FIELD_IS_BASE fields.\n\t(build_zero_init): Use build_zero_init_1.\n\n\t* g++.dg/inherit/virtual8.C: New test.\n\nFrom-SVN: r170874", "tree": {"sha": "646fcf3880fcf55f5b06c27e45a7d9a15287445c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/646fcf3880fcf55f5b06c27e45a7d9a15287445c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e33eba75933fdd7bd895a3b35ef1b1b710ddbb13", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e33eba75933fdd7bd895a3b35ef1b1b710ddbb13", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e33eba75933fdd7bd895a3b35ef1b1b710ddbb13", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e33eba75933fdd7bd895a3b35ef1b1b710ddbb13/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "4074f163fc39eedabb09f1ddcbd4c78bf55cb19b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4074f163fc39eedabb09f1ddcbd4c78bf55cb19b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4074f163fc39eedabb09f1ddcbd4c78bf55cb19b"}], "stats": {"total": 121, "additions": 110, "deletions": 11}, "files": [{"sha": "da75a77c3a98013f27673ce0f3f26717cfae6e53", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e33eba75933fdd7bd895a3b35ef1b1b710ddbb13/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e33eba75933fdd7bd895a3b35ef1b1b710ddbb13/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=e33eba75933fdd7bd895a3b35ef1b1b710ddbb13", "patch": "@@ -1,3 +1,13 @@\n+2011-03-11  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR c++/48035\n+\t* init.c (build_zero_init_1): Extracted from build_zero_init.\n+\tAdd FIELD_SIZE argument, if non-NULL and field bit_position\n+\tas not smaller than that, don't add that field's initializer.\n+\tPass DECL_SIZE as last argument to build_zero_init_1\n+\tfor DECL_FIELD_IS_BASE fields.\n+\t(build_zero_init): Use build_zero_init_1.\n+\n 2011-03-10  Jason Merrill  <jason@redhat.com>\n \n \tPR c++/48029"}, {"sha": "e1961c8ee77429ecd1c3d2c3357977c820c4a4cc", "filename": "gcc/cp/init.c", "status": "modified", "additions": 49, "deletions": 11, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e33eba75933fdd7bd895a3b35ef1b1b710ddbb13/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e33eba75933fdd7bd895a3b35ef1b1b710ddbb13/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=e33eba75933fdd7bd895a3b35ef1b1b710ddbb13", "patch": "@@ -1,7 +1,7 @@\n /* Handle initialization things in C++.\n    Copyright (C) 1987, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n-   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010\n-   Free Software Foundation, Inc.\n+   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010,\n+   2011 Free Software Foundation, Inc.\n    Contributed by Michael Tiemann (tiemann@cygnus.com)\n \n This file is part of GCC.\n@@ -140,10 +140,13 @@ initialize_vtbl_ptrs (tree addr)\n    is the number of elements in the array.  If STATIC_STORAGE_P is\n    TRUE, initializers are only generated for entities for which\n    zero-initialization does not simply mean filling the storage with\n-   zero bytes.  */\n+   zero bytes.  FIELD_SIZE, if non-NULL, is the bit size of the field,\n+   subfields with bit positions at or above that bit size shouldn't\n+   be added.  */\n \n-tree\n-build_zero_init (tree type, tree nelts, bool static_storage_p)\n+static tree\n+build_zero_init_1 (tree type, tree nelts, bool static_storage_p,\n+\t\t   tree field_size)\n {\n   tree init = NULL_TREE;\n \n@@ -188,15 +191,32 @@ build_zero_init (tree type, tree nelts, bool static_storage_p)\n \t  if (TREE_CODE (field) != FIELD_DECL)\n \t    continue;\n \n+\t  /* Don't add virtual bases for base classes if they are beyond\n+\t     the size of the current field, that means it is present\n+\t     somewhere else in the object.  */\n+\t  if (field_size)\n+\t    {\n+\t      tree bitpos = bit_position (field);\n+\t      if (TREE_CODE (bitpos) == INTEGER_CST\n+\t\t  && !tree_int_cst_lt (bitpos, field_size))\n+\t\tcontinue;\n+\t    }\n+\n \t  /* Note that for class types there will be FIELD_DECLs\n \t     corresponding to base classes as well.  Thus, iterating\n \t     over TYPE_FIELDs will result in correct initialization of\n \t     all of the subobjects.  */\n \t  if (!static_storage_p || !zero_init_p (TREE_TYPE (field)))\n \t    {\n-\t      tree value = build_zero_init (TREE_TYPE (field),\n-\t\t\t\t\t    /*nelts=*/NULL_TREE,\n-\t\t\t\t\t    static_storage_p);\n+\t      tree new_field_size\n+\t\t= (DECL_FIELD_IS_BASE (field)\n+\t\t   && DECL_SIZE (field)\n+\t\t   && TREE_CODE (DECL_SIZE (field)) == INTEGER_CST)\n+\t\t  ? DECL_SIZE (field) : NULL_TREE;\n+\t      tree value = build_zero_init_1 (TREE_TYPE (field),\n+\t\t\t\t\t      /*nelts=*/NULL_TREE,\n+\t\t\t\t\t      static_storage_p,\n+\t\t\t\t\t      new_field_size);\n \t      if (value)\n \t\tCONSTRUCTOR_APPEND_ELT(v, field, value);\n \t    }\n@@ -244,9 +264,9 @@ build_zero_init (tree type, tree nelts, bool static_storage_p)\n \t    ce->index = build2 (RANGE_EXPR, sizetype, size_zero_node,\n \t\t\t\tmax_index);\n \n-\t  ce->value = build_zero_init (TREE_TYPE (type),\n-\t\t\t\t       /*nelts=*/NULL_TREE,\n-\t\t\t\t       static_storage_p);\n+\t  ce->value = build_zero_init_1 (TREE_TYPE (type),\n+\t\t\t\t\t /*nelts=*/NULL_TREE,\n+\t\t\t\t\t static_storage_p, NULL_TREE);\n \t}\n \n       /* Build a constructor to contain the initializations.  */\n@@ -264,6 +284,24 @@ build_zero_init (tree type, tree nelts, bool static_storage_p)\n   return init;\n }\n \n+/* Return an expression for the zero-initialization of an object with\n+   type T.  This expression will either be a constant (in the case\n+   that T is a scalar), or a CONSTRUCTOR (in the case that T is an\n+   aggregate), or NULL (in the case that T does not require\n+   initialization).  In either case, the value can be used as\n+   DECL_INITIAL for a decl of the indicated TYPE; it is a valid static\n+   initializer. If NELTS is non-NULL, and TYPE is an ARRAY_TYPE, NELTS\n+   is the number of elements in the array.  If STATIC_STORAGE_P is\n+   TRUE, initializers are only generated for entities for which\n+   zero-initialization does not simply mean filling the storage with\n+   zero bytes.  */\n+\n+tree\n+build_zero_init (tree type, tree nelts, bool static_storage_p)\n+{\n+  return build_zero_init_1 (type, nelts, static_storage_p, NULL_TREE);\n+}\n+\n /* Return a suitable initializer for value-initializing an object of type\n    TYPE, as described in [dcl.init].  */\n "}, {"sha": "7e7b9243da599425b9f824b01a9173a8705ff10d", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e33eba75933fdd7bd895a3b35ef1b1b710ddbb13/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e33eba75933fdd7bd895a3b35ef1b1b710ddbb13/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=e33eba75933fdd7bd895a3b35ef1b1b710ddbb13", "patch": "@@ -1,5 +1,8 @@\n 2011-03-11  Jakub Jelinek  <jakub@redhat.com>\n \n+\tPR c++/48035\n+\t* g++.dg/inherit/virtual8.C: New test.\n+\n \tPR middle-end/48044\n \t* gcc.dg/torture/pr48044.c: New test.\n "}, {"sha": "4f6a119b2879efe42cfd1f720536c0ef21090dca", "filename": "gcc/testsuite/g++.dg/inherit/virtual8.C", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e33eba75933fdd7bd895a3b35ef1b1b710ddbb13/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finherit%2Fvirtual8.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e33eba75933fdd7bd895a3b35ef1b1b710ddbb13/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finherit%2Fvirtual8.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finherit%2Fvirtual8.C?ref=e33eba75933fdd7bd895a3b35ef1b1b710ddbb13", "patch": "@@ -0,0 +1,48 @@\n+// PR c++/48035\n+// { dg-do run }\n+\n+#include <new>\n+#include <cstring>\n+#include <cstdlib>\n+\n+struct A\n+{\n+  virtual void foo (void) {}\n+  virtual ~A () {}\n+};\n+\n+struct B : public A\n+{\n+  virtual ~B () {}\n+};\n+\n+struct C\n+{\n+  virtual ~C () {}\n+  int c;\n+};\n+\n+struct D : public virtual B, public C\n+{\n+  virtual ~D () {}\n+};\n+\n+struct E : public virtual D\n+{\n+  virtual ~E () {}\n+};\n+\n+int\n+main ()\n+{\n+  char *v = new char[sizeof (E) + 16];\n+  memset (v, 0x55, sizeof (E) + 16);\n+  E *e = new (v) E ();\n+  e->~E ();\n+\n+  for (unsigned i = sizeof (E); i < sizeof (E) + 16; ++i)\n+    if (v[i] != 0x55)\n+      abort ();\n+\n+  delete[] v;\n+}"}]}