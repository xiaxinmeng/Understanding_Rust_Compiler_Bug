{"sha": "2a9f2bb90143fab29da3d99b424cef091279eb04", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmE5ZjJiYjkwMTQzZmFiMjlkYTNkOTliNDI0Y2VmMDkxMjc5ZWIwNA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-09-12T22:25:25Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-09-12T22:25:25Z"}, "message": "Initial revision\n\nFrom-SVN: r10337", "tree": {"sha": "48c43c5fc21d920316b630bf897c6fe94bf52379", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/48c43c5fc21d920316b630bf897c6fe94bf52379"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2a9f2bb90143fab29da3d99b424cef091279eb04", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a9f2bb90143fab29da3d99b424cef091279eb04", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2a9f2bb90143fab29da3d99b424cef091279eb04", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a9f2bb90143fab29da3d99b424cef091279eb04/comments", "author": null, "committer": null, "parents": [{"sha": "929e7d86d45278d62c80b07dbd570c4be0378f42", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/929e7d86d45278d62c80b07dbd570c4be0378f42", "html_url": "https://github.com/Rust-GCC/gccrs/commit/929e7d86d45278d62c80b07dbd570c4be0378f42"}], "stats": {"total": 922, "additions": 922, "deletions": 0}, "files": [{"sha": "59f7dc1c6effb2a05bec3fd4a5f7092a69b16e09", "filename": "gcc/config/winnt/dirent.c", "status": "added", "additions": 360, "deletions": 0, "changes": 360, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a9f2bb90143fab29da3d99b424cef091279eb04/gcc%2Fconfig%2Fwinnt%2Fdirent.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a9f2bb90143fab29da3d99b424cef091279eb04/gcc%2Fconfig%2Fwinnt%2Fdirent.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fwinnt%2Fdirent.c?ref=2a9f2bb90143fab29da3d99b424cef091279eb04", "patch": "@@ -0,0 +1,360 @@\n+/*\n+ * @(#)msd_dir.c 1.4 87/11/06\tPublic Domain.\n+ *\n+ *  A public domain implementation of BSD directory routines for\n+ *  MS-DOS.  Written by Michael Rendell ({uunet,utai}michael@garfield),\n+ *  August 1897\n+ *\n+ *  Modified by Ian Stewartson, Data Logic (istewart@datlog.co.uk).\n+ *\n+ *  Updates:  1.  To support OS/2 1.x\n+ *\t      2.  To support HPFS long filenames\n+ *\t      3.  To support OS/2 2.x\n+ *\t      4.  To support TurboC\n+ *\t      5.  To support Windows NT\n+ */\n+\n+#include <sys/types.h>\n+#include <sys/stat.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+\n+#include <malloc.h>\n+\n+#include <string.h>\n+#include <limits.h>\n+#include <ctype.h>\n+#include <errno.h>\n+#include <dirent.h>\n+\n+\n+#define WIN32_LEAN_AND_MEAN\n+#include <windows.h>\n+\n+#define FILE_NAME_E\t\tcFileName\n+#define OS_CloseFH(a)\t\tFindClose (a)\n+#define FIND_BUFFER\t\tWIN32_FIND_DATA\n+#define DISABLE_HARD_ERRORS\tSetErrorMode (0)\n+#define ENABLE_HARD_ERRORS\tSetErrorMode (SEM_FAILCRITICALERRORS | \\\n+\t\t\t\t\t      SEM_NOOPENFILEERRORBOX);\n+\n+#  define ERROR_EMPTY_DIR\tERROR_FILE_NOT_FOUND\n+\n+#  define ATTRIBUTES\t\t(_A_SUBDIR | _A_HIDDEN | _A_SYSTEM | \\\n+\t\t\t\t _A_NORMAL | _A_RDONLY | _A_ARCH)\n+\n+/*\n+ * missing ??\n+ */\n+\n+#ifndef ENOTDIR\n+#  define ENOTDIR\t120\t/* Not a directory\t\t\t*/\n+#endif\n+\n+#ifndef S_IFMT\n+#  define\tS_IFMT\t0xf000\t/* type of file\t\t\t\t*/\n+#endif\n+\n+#ifndef S_ISDIR\n+#  define S_ISDIR(m)\t((((m) & S_IFMT) == S_IFDIR))\n+#endif\n+\n+/*\n+ * Internals\n+ */\n+\n+typedef struct _dircontents\tDIRCONT;\n+static void\t\t\tfree_dircontents (DIRCONT *);\n+\n+/*\n+ * Open the directory stream\n+ */\n+\n+DIR *\n+opendir (name)\n+    const char\t*name;\n+{\n+    struct stat\t\tstatb;\n+    DIR\t\t\t*dirp;\n+    char\t\t*last;\n+    DIRCONT\t\t*dp;\n+    char\t\t*nbuf;\n+    int\t\t\tlen = strlen (name);\n+    unsigned long\trc;\n+    FIND_BUFFER\t\tdtabuf;\n+    HANDLE\t\td_handle;\n+    bool\t\tHPFS = FALSE;\n+\n+    if (!len)\n+    {\n+\terrno = ENOTDIR;\n+\treturn (DIR *)NULL;\n+    }\n+\n+    if ((nbuf = malloc (len + 5)) == (char *)NULL)\n+\treturn (DIR *) NULL;\n+\n+    strcpy (nbuf, name);\n+    last = &nbuf[len - 1];\n+\n+/* Ok, DOS is very picky about its directory names.  The following are\n+ * valid.\n+ *\n+ *  c:/\n+ *  c:.\n+ *  c:name/name1\n+ *\n+ *  c:name/ is not valid\n+ */\n+\n+    if (((*last == '\\\\') || (*last == '/')) && (len > 1) &&\n+\t(!((len == 3) && (name[1] == ':'))))\n+\t*(last--) = 0;\n+\n+/* Check its a directory */\n+\n+    DISABLE_HARD_ERRORS;\n+    rc = stat (nbuf, &statb);\n+    ENABLE_HARD_ERRORS;\n+\n+    if (rc)\n+    {\n+\tfree (nbuf);\n+\treturn (DIR *) NULL;\n+    }\n+\n+    if (!S_ISDIR (statb.st_mode))\n+    {\n+\tfree (nbuf);\n+\terrno = ENOTDIR;\n+\treturn (DIR *)NULL;\n+    }\n+\n+    if ((dirp = (DIR *) malloc (sizeof (DIR))) == (DIR *) NULL)\n+    {\n+\tfree (nbuf);\n+\treturn (DIR *) NULL;\n+    }\n+\n+/* Set up to find everything */\n+\n+    if ((*last != '\\\\') && (*last != '/'))\n+\tstrcat (last, \"/\");\n+\n+    strcat (last, \"*.*\");\n+\n+/* Find the file system type */\n+\n+    HPFS = IsHPFSFileSystem (nbuf);\n+\n+    dirp->dd_loc      = 0;\n+    dirp->dd_cp       = (DIRCONT *) NULL;\n+    dirp->dd_contents = (DIRCONT *) NULL;\n+\n+    DISABLE_HARD_ERRORS;\n+\n+    d_handle = FindFirstFile (nbuf, &dtabuf);\n+    rc = (d_handle == INVALID_HANDLE_VALUE) ? GetLastError () : 0;\n+\n+    ENABLE_HARD_ERRORS;\n+\n+/* Check for errors */\n+\n+    if (rc)\n+    {\n+\tfree (nbuf);\n+\n+/* Empty directory */\n+\n+#if defined (ERROR_EMPTY_DIR)\n+\tif (rc == ERROR_EMPTY_DIR)\n+\t    return dirp;\n+#endif\n+\n+\tfree (dirp);\n+\treturn (DIR *) NULL;\n+    }\n+\n+/* Process the directory */\n+\n+    do\n+    {\n+\tif (((dp = (DIRCONT *) malloc (sizeof (DIRCONT))) == (DIRCONT *)NULL) ||\n+\t    ((dp->_d_entry = strdup (dtabuf.FILE_NAME_E)) == (char *) NULL))\n+\t{\n+\t    if (dp->_d_entry != (char *)NULL)\n+\t\tfree ((char *)dp);\n+\n+\t    free (nbuf);\n+\t    free_dircontents (dirp->dd_contents);\n+\n+\t    OS_CloseFH (d_handle);\n+\t    return (DIR *) NULL;\n+\t}\n+\n+\tif (!HPFS)\n+\t    strlwr (dp->_d_entry);\n+\n+\tif (dirp->dd_contents != (DIRCONT *) NULL)\n+\t    dirp->dd_cp = dirp->dd_cp->_d_next = dp;\n+\n+\telse\n+\t    dirp->dd_contents = dirp->dd_cp = dp;\n+\n+\tdp->_d_next = (DIRCONT *) NULL;\n+\n+    } while (FindNextFile (d_handle, &dtabuf));\n+\n+    dirp->dd_cp = dirp->dd_contents;\n+    free (nbuf);\n+\n+    OS_CloseFH (d_handle);\n+    return dirp;\n+}\n+\n+\n+/*\n+ * Close the directory stream\n+ */\n+\n+int\n+closedir (dirp)\n+    DIR *dirp;\n+{\n+    if (dirp != (DIR *)NULL)\n+    {\n+\tfree_dircontents (dirp->dd_contents);\n+\tfree ((char *)dirp);\n+    }\n+\n+    return 0;\n+}\n+\n+/*\n+ * Read the next record from the stream\n+ */\n+\n+struct dirent *\n+readdir (dirp)\n+    DIR\t*dirp;\n+{\n+    static struct dirent\tdp;\n+\n+    if ((dirp == (DIR *)NULL) || (dirp->dd_cp == (DIRCONT *) NULL))\n+\treturn (struct dirent *) NULL;\n+\n+    dp.d_reclen = strlen (strcpy (dp.d_name, dirp->dd_cp->_d_entry));\n+    dp.d_off    = dirp->dd_loc * 32;\n+    dp.d_ino    = (ino_t)++dirp->dd_loc;\n+    dirp->dd_cp = dirp->dd_cp->_d_next;\n+\n+    return &dp;\n+}\n+\n+/*\n+ * Restart the directory stream\n+ */\n+\n+void\n+rewinddir (dirp)\n+    DIR *dirp;\n+{\n+    seekdir (dirp, (off_t)0);\n+}\n+\n+/*\n+ * Move to a know position in the stream\n+ */\n+\n+void\n+seekdir (dirp, off)\n+    DIR *dirp;\n+    off_t off;\n+{\n+    long\ti = off;\n+    DIRCONT\t*dp;\n+\n+    if ((dirp == (DIR *)NULL) || (off < 0L))\n+\treturn;\n+\n+    for (dp = dirp->dd_contents; (--i >= 0) && (dp != (DIRCONT *)NULL);\n+\t dp = dp->_d_next)\n+\t;\n+\n+    dirp->dd_loc = off - (i + 1);\n+    dirp->dd_cp = dp;\n+}\n+\n+/*\n+ * Get the current position\n+ */\n+\n+off_t\n+telldir(dirp)\n+    DIR *dirp;\n+{\n+    return (dirp == (DIR *)NULL) ? (off_t) -1 : dirp->dd_loc;\n+}\n+\n+/*\n+ * Release the internal structure\n+ */\n+\n+static void\n+free_dircontents (dp)\n+    DIRCONT *dp;\n+{\n+    DIRCONT\t*odp;\n+\n+    while ((odp = dp) != (DIRCONT *)NULL)\n+    {\n+\tif (dp->_d_entry != (char *)NULL)\n+\t    free (dp->_d_entry);\n+\n+\tdp = dp->_d_next;\n+\tfree ((char *)odp);\n+    }\n+}\n+\n+\n+/*\n+ * Windows NT version\n+ */\n+\n+bool\n+IsHPFSFileSystem (directory)\n+    char *directory;\n+{\n+    char\t\tbName[4];\n+    DWORD\t\tflags;\n+    DWORD\t\tmaxname;\n+    BOOL\t\trc;\n+    unsigned int\tnDrive;\n+    char\t\tszCurDir [MAX_PATH];\n+\n+    if (isalpha (directory[0]) && (directory[1] == ':'))\n+\tnDrive = toupper (directory[0]) - '@';\n+\n+    else\n+    {\n+\tGetCurrentDirectory (MAX_PATH, szCurDir);\n+\tnDrive = szCurDir[0] - 'A' + 1;\n+    }\n+\n+/* Set up the drive name */\n+\n+    strcpy (bName, \"x:\\\\\");\n+    bName[0] = (char) (nDrive + '@');\n+\n+/* Read the volume info, if we fail - assume non-HPFS */\n+\n+    DISABLE_HARD_ERRORS;\n+\n+    rc = GetVolumeInformation (bName, (LPTSTR)NULL, 0, (LPDWORD)NULL,\n+\t\t\t       &maxname, &flags, (LPTSTR)NULL, 0);\n+    ENABLE_HARD_ERRORS;\n+\n+    return ((rc) && (flags & (FS_CASE_SENSITIVE | FS_CASE_IS_PRESERVED)))\n+    \t\t? TRUE : FALSE;\n+}\n+"}, {"sha": "822bd2cab06d04ea7614cbf7b00aa11006b7cc59", "filename": "gcc/config/winnt/dirent.h", "status": "added", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a9f2bb90143fab29da3d99b424cef091279eb04/gcc%2Fconfig%2Fwinnt%2Fdirent.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a9f2bb90143fab29da3d99b424cef091279eb04/gcc%2Fconfig%2Fwinnt%2Fdirent.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fwinnt%2Fdirent.h?ref=2a9f2bb90143fab29da3d99b424cef091279eb04", "patch": "@@ -0,0 +1,96 @@\n+/*\n+ * dirent.h\n+ */\n+\n+#ifndef _DIRENT_H\n+#  define _DIRENT_H\n+\n+#  include <sys/types.h>\n+#  include <limits.h>\n+\n+#define MAXNAMLEN\t255\t/* maximum filename length\t\t*/\n+\n+#ifndef NAME_MAX\n+#define\tNAME_MAX\t(MAXNAMLEN - 1)\n+#endif\n+\n+struct dirent\t\t\t/* data from getdents()/readdir()\t*/\n+{\n+    ino_t\td_ino;\t\t/* inode number of entry\t\t*/\n+    off_t\td_off;\t\t/* offset of disk directory entry\t*/\n+    wchar_t\td_reclen;\t/* length of this record\t\t*/\n+    char\td_name[MAXNAMLEN + 1];\n+};\n+\n+\n+/* The following nonportable ugliness could have been avoided by defining\n+ * DIRENTSIZ and DIRENTBASESIZ to also have (struct dirent *) arguments.\n+ * There shouldn't be any problem if you avoid using the DIRENTSIZ() macro.\n+ */\n+\n+#define\tDIRENTBASESIZ\t\t(((struct dirent *)0)->d_name \\\n+\t\t\t\t- (char *)&((struct dirent *)0)->d_ino)\n+\n+#define\tDIRENTSIZ(namlen)\t((DIRENTBASESIZ + sizeof(long) + (namlen)) \\\n+\t\t\t\t/ sizeof(long) * sizeof(long))\n+\n+\n+\n+#  ifndef _BOOL_T_DEFINED\n+typedef unsigned char\tbool;\n+#  define _BOOL_T_DEFINED\n+#  endif\n+\n+#  define DIRBUF\t8192\t/* buffer size for fs-indep. dirs\t*/\n+\t\t\t\t/* must in general be larger than the\t*/\n+\t\t\t\t/* filesystem buffer size\t\t*/\n+\n+struct _dircontents {\n+    char\t\t*_d_entry;\n+    struct _dircontents\t*_d_next;\n+};\n+\n+typedef struct _dirdesc {\n+    int\t\t\tdd_id;\t/* uniquely identify each open directory */\n+    long\t\tdd_loc;\t/* where we are in directory entry is this */\n+    struct _dircontents\t*dd_contents;\t/* pointer to contents of dir\t*/\n+    struct _dircontents\t*dd_cp;\t\t/* pointer to current position\t*/\n+} DIR;\n+\n+\n+#if defined (__STDC__)\n+#  define _PROTO(p)\tp\n+#else\n+#  define _PROTO(p)\t()\n+#  undef  const\n+#  undef  volatile\n+#endif\n+\n+/* Functions */\n+\n+extern DIR *\t\topendir\t_PROTO ((const char *));\n+extern struct dirent * \treaddir _PROTO ((DIR *));\n+extern void\t\trewinddir _PROTO ((DIR *));\n+\n+extern int\t\tclosedir _PROTO ((DIR *));\n+extern void\t\tseekdir\t_PROTO ((DIR *, off_t));\n+extern off_t\t\ttelldir\t_PROTO ((DIR *));\n+\n+extern int\t\tchdir _PROTO ((const char *));\n+extern char * \t\tgetcwd _PROTO ((char *, size_t));\n+\n+extern int\t\tmkdir _PROTO ((const char *));\n+\n+extern int\t\trmdir _PROTO ((const char *));\n+extern int\t\tscandir _PROTO ((char *,\n+\t\t\t struct dirent ***,\n+\t\t\t int (*)(const void *, const void *),\n+\t\t\t int (*)(const void *, const void *)));\n+\n+extern int\t\t_chdrive _PROTO ((int));\n+extern int\t\t_getdrive _PROTO ((void));\n+extern char * \t\t_getdcwd _PROTO ((int, char *, int));\n+\n+extern bool\t\tIsHPFSFileSystem _PROTO ((char *));\n+\n+#endif"}, {"sha": "f49d6dda1bd6884b40df29c9ded8b7adb9c2a2fa", "filename": "gcc/config/winnt/fixinc-nt.c", "status": "added", "additions": 260, "deletions": 0, "changes": 260, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a9f2bb90143fab29da3d99b424cef091279eb04/gcc%2Fconfig%2Fwinnt%2Ffixinc-nt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a9f2bb90143fab29da3d99b424cef091279eb04/gcc%2Fconfig%2Fwinnt%2Ffixinc-nt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fwinnt%2Ffixinc-nt.c?ref=2a9f2bb90143fab29da3d99b424cef091279eb04", "patch": "@@ -0,0 +1,260 @@\n+#include <stdlib.h>\n+#include <string.h>\n+#include <sys/stat.h>\n+#include <dirent.h>\n+#include <stdio.h>\n+#include <io.h>\n+#include <fcntl.h>\n+#include <process.h>\n+\n+static char *concat();\n+static char *concat3();\n+static char *concat4();\n+static int onlyonedir;\n+static int atleastone;\n+static char *fixeddirs, *origdirs;\n+\n+/* Convert all /'s to \\'s */\n+\n+char *\n+slash2slash (dirname)\n+  char *dirname;\n+{\n+  int i;\n+  for (i=0; dirname[i]; i++)\n+    if (dirname [i] == '/')\n+      dirname [i] = '\\\\';\n+\n+  return dirname;\n+}\n+\n+/* Examine each directory component of a path and create the directory */\n+\n+int\n+mkdirpath (dirpath)\n+  char *dirpath;\n+{\n+  char *ndirpath = strdup (dirpath);\n+  char *bp, *fp;\n+\n+  fp = bp = ndirpath;\n+\n+  while (bp) \n+    {\n+      bp = strchr (fp, '\\\\');\n+      if (bp)\n+        {\n+          *bp = 0;\n+          _mkdir (ndirpath);\n+          *bp = '\\\\';\n+          fp = ++bp;\n+        }\n+      else\n+        _mkdir (ndirpath);\n+    }\n+}\n+\n+/* Construct a relative directory path from a given path by removing the\n+   leading slash, if it exists and changing a drive letter from X: to X-. */\n+\n+char *\n+newname (olddirname)\n+  char *olddirname;\n+{\n+  char *newname = strdup (olddirname);\n+\n+  if ((strlen (newname) >= 2)\n+      && (isalpha (newname[0]) && newname[1] == ':'))\n+    newname [1] = '-';\n+  else if ((strlen (newname) >= 1) \n+           && (newname [0] == '/' || newname [0] == '\\\\'))\n+    newname = &newname[1];\n+\n+  return newname;\n+ \n+}\n+\n+/* Run the sed script on one header file.  If no modifications were made, then\n+   delete the newly created file. */\n+\n+int\n+doheader (oneheader, outheader, oldsize)\n+  char *oneheader, *outheader;\n+  int oldsize;\n+{\n+  char *newbuff, *oldbuff;\n+  char *newheader = concat3 (\"include\", \"\\\\\", newname (outheader));\n+  struct _stat newstatbuf;\n+  int newdesc, olddesc;\n+  int i;\n+\n+  system (concat4 (\"sed -f fixinc-nt.sed \", oneheader, \" > \", newheader));\n+  _stat (newheader, &newstatbuf);\n+  if (oldsize != newstatbuf.st_size) \n+    {\n+      atleastone = 1;\n+      printf (\"Fixing: %s\\n\", oneheader);\n+      return 0;\n+    }\n+  oldbuff = malloc (oldsize);\n+  newbuff = malloc (newstatbuf.st_size);\n+  olddesc = open (oneheader, _O_RDONLY | _O_BINARY);\n+  newdesc = open (newheader, _O_RDONLY | _O_BINARY);\n+  read (olddesc, oldbuff, oldsize);\n+  read (newdesc, newbuff, newstatbuf.st_size);\n+  close (olddesc);\n+  close (newdesc);\n+  for (i=0; i<oldsize; i++)\n+    {\n+      if (oldbuff [i] != newbuff [i])\n+        {\n+          free (oldbuff);\n+          free (newbuff);\n+          atleastone = 1;\n+          printf (\"Fixing: %s\\n\", oneheader);\n+          return 0;\n+        }\n+    }\n+  free (oldbuff);\n+  free (newbuff);\n+  unlink (newheader);\n+  return 0;\n+  \n+}\n+\n+/* Examine the contents of a directory and call doheader () for a regular file\n+   and recursively call dodir () for an enclosed directory. */\n+\n+int\n+dodir (indir, outdir)\n+  char *indir, *outdir;\n+{\n+  DIR *dir;\n+  struct dirent *dire;\n+  struct _stat statbuf;\n+  char *intempbuf, *outtempbuf;\n+\n+  dir = opendir (indir);\n+  if (!dir) return 0;\n+\n+  mkdirpath (concat3 (\"include\", \"\\\\\", newname (outdir)));\n+  while ((dire = readdir (dir)))\n+    {\n+      if (dire->d_name[0] == '.')\n+        continue;\n+  \n+      intempbuf = slash2slash (concat3 (indir, \"\\\\\", dire->d_name));\n+      outtempbuf = slash2slash (concat3 (outdir, \"\\\\\", dire->d_name));\n+      _stat (intempbuf, &statbuf);\n+  \n+      /* If directory ... */\n+      if (statbuf.st_mode & _S_IFDIR)\n+        dodir (intempbuf, outtempbuf);\n+  \n+      /* If regular file ... */\n+      if (statbuf.st_mode & _S_IFREG)\n+        doheader (intempbuf, outtempbuf, statbuf.st_size);\n+    }\n+  closedir (dir);\n+  return 0;\n+}\n+\n+/* Retrieve the value of the Include environment variable, copy it into a\n+   temporary and append a semi-colon for book-keeping purposes. Then call\n+   dodir () for each complete directory that is named therein.  If there is\n+   only one directory, then direct the output to use include\\. as the\n+   root instead of include/<directory path>, where <directory path> is a path\n+   constructed from the path named in the Include environment variable.  \n+   I.e. if Include=C:\\MSTOOLS\\Include;D:\\MSVC20\\Include then the modified\n+   header files will be in include\\C-\\MSTOOLS\\Include and \n+   include\\D-\\MSVC20\\Include.  However if Include=C:\\MSTOOLS\\Include then the\n+   modified files will be in include\\. */\n+\n+int\n+main ()\n+{\n+  char *fp, *bp, *foobar;\n+  char *incvar = getenv (\"Include\");\n+  int varlen = 0;\n+  struct _stat statbuf;\n+\n+  if (incvar == NULL) return 0;\n+\n+  varlen = strlen (incvar);\n+  foobar = (char *) malloc (varlen + 2);\n+\n+  strcpy (foobar, incvar);\n+  foobar = slash2slash (foobar);\n+  if (foobar [varlen-1] != ';') strcat (foobar, \";\");\n+  fp = bp = foobar;\n+\n+  if (strchr (fp, ';') == strrchr (fp, ';'))\n+    onlyonedir = 1;\n+  else\n+    onlyonedir = 0;\n+\n+  fixeddirs = strdup(\".\\\\include\");\n+  origdirs = strdup(\"\");\n+\n+  while (bp)\n+    {\n+      bp = strchr (fp, ';');\n+      if (bp)\n+        {\n+          *bp = 0;\n+          _stat (fp, &statbuf);\n+          if (statbuf.st_mode & _S_IFDIR)\n+            {\n+              atleastone = 0;\n+              if (onlyonedir) \n+                dodir (fp, \".\");\n+              else\n+                dodir (fp, fp);\n+              if (atleastone && !onlyonedir)\n+                {\n+                  origdirs = concat3 (origdirs, \";\", fp);\n+                  fixeddirs = concat3 (fixeddirs, \";\", \n+                    concat3 (\".\\\\include\", \"\\\\\", newname(fp)));\n+                }\n+            }\n+          fp = ++bp;\n+        }\n+    }\n+  printf (\"set C_Include_Path=%s%s\\n\", fixeddirs, origdirs);\n+  return 0;\n+}\n+\n+/* Utility function that mallocs space and concatenates two strings. */\n+\n+static char *\n+concat (s1, s2)\n+     char *s1, *s2;\n+{\n+  int len1 = strlen (s1);\n+  int len2 = strlen (s2);\n+  char *result = malloc (len1 + len2 + 1);\n+\n+  strcpy (result, s1);\n+  strcpy (result + len1, s2);\n+  *(result + len1 + len2) = 0;\n+\n+  return result;\n+}\n+\n+/* Utility function that concatenates three strings. */\n+\n+static char *\n+concat3 (s1, s2, s3)\n+     char *s1, *s2, *s3;\n+{\n+  return concat (concat (s1, s2), s3);\n+}\n+\n+/* Utility function that concatenates four strings. */\n+\n+static char *\n+concat4 (s1, s2, s3, s4)\n+     char *s1, *s2, *s3, *s4;\n+{\n+  return concat (concat (s1, s2), concat (s3, s4));\n+}"}, {"sha": "69ef8598acaf72bc1d697ad6eff195ab4fd3c615", "filename": "gcc/config/winnt/headers.mak", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a9f2bb90143fab29da3d99b424cef091279eb04/gcc%2Fconfig%2Fwinnt%2Fheaders.mak", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a9f2bb90143fab29da3d99b424cef091279eb04/gcc%2Fconfig%2Fwinnt%2Fheaders.mak", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fwinnt%2Fheaders.mak?ref=2a9f2bb90143fab29da3d99b424cef091279eb04", "patch": "@@ -0,0 +1,51 @@\n+# Build the include directory.  The stamp files are stmp-* rather than\n+# stamp-* so that mostlyclean does not force the include directory to\n+# be rebuilt.\n+\n+\n+# Copy in the headers provided with gcc.\n+USER_H = $(srcdir)\\ginclude\\stdarg.h $(srcdir)\\ginclude\\stddef.h \\\n+    $(srcdir)\\ginclude\\varargs.h $(srcdir)\\ginclude\\va-alpha.h \\\n+    $(srcdir)\\ginclude\\va-h8300.h $(srcdir)\\ginclude\\va-i860.h \\\n+    $(srcdir)\\ginclude\\va-i960.h $(srcdir)\\ginclude\\va-mips.h \\\n+    $(srcdir)\\ginclude\\va-m88k.h $(srcdir)\\ginclude\\va-pa.h \\\n+    $(srcdir)\\ginclude\\va-pyr.h $(srcdir)\\ginclude\\va-sparc.h \\\n+    $(srcdir)\\ginclude\\va-clipper.h $(srcdir)\\ginclude\\va-spur.h \\\n+    $(srcdir)\\ginclude\\iso646.h \\\n+    $(srcdir)\\ginclude\\proto.h\n+\n+# Build the include directory except for float.h (which depends upon\n+# enquire).\n+\n+stmp-int-hdrs: $(USER_H)\n+\ttype $(srcdir)\\limitx.h >xlimits.h\n+\ttype $(srcdir)\\glimits.h >>xlimits.h\n+\ttype $(srcdir)\\limity.h >>xlimits.h\n+\n+\t-mkdir include\t\n+\tfor %%f in ($(USER_H)) do copy %%f include\n+\tdel include\\limits.h\n+\tcopy xlimits.h include\\limits.h\n+\tdel include\\syslimits.h\n+\tcopy $(srcdir)\\gsyslimits.h include\\syslimits.h\n+\tcopy include\\limits.h include\\syslimits.h\n+\tdel include\\README\n+\tcopy $(srcdir)\\README-fixinc include\\README\n+\ttouch stmp-int-hdrs\n+\n+stmp-headers: stmp-int-hdrs fixinc-nt.exe\n+\tfixinc-nt\n+\ttouch stmp-headers\n+\n+# Build float.h.\n+stmp-float_h: libgcc.lib enquire.exe\n+\t-.\\enquire -f > tmp-float.h\n+\tdel include\\float.h\n+\tcopy tmp-float.h include\\float.h\n+\ttouch stmp-float_h\n+\n+fixinc-nt.obj: $(srcdir)/config/winnt/fixinc-nt.c\n+\tcl -c -I. -I$(srcdir) -I$(srcdir)/include $(srcdir)/config/winnt/fixinc-nt.c\n+\n+fixinc-nt.exe: fixinc-nt.obj dirent.obj\n+\tcl fixinc-nt.obj dirent.obj libc.lib kernel32.lib"}, {"sha": "adfb57e63cc8056e05c929509ad048fc446106e5", "filename": "gcc/config/winnt/libgcc.mak", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a9f2bb90143fab29da3d99b424cef091279eb04/gcc%2Fconfig%2Fwinnt%2Flibgcc.mak", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a9f2bb90143fab29da3d99b424cef091279eb04/gcc%2Fconfig%2Fwinnt%2Flibgcc.mak", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fwinnt%2Flibgcc.mak?ref=2a9f2bb90143fab29da3d99b424cef091279eb04", "patch": "@@ -0,0 +1,19 @@\n+# Build libgcc.a\n+\n+libgcc.lib : libgcc1.c libgcc2.c mklibgcc.exe\n+\tmklibgcc -c\n+\tmklibgcc \"cl -c $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES)\" libgcc1.c $(LIB1FUNCS)\n+\tmklibgcc \"xgcc -B./ -c $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES)\" libgcc2.c $(LIB2FUNCS)\n+\tmklibnow.bat\n+\t-del libgcc.lib\n+\tlib -verbose -out:libgcc.lib lgcctmp/*.obj\n+\n+mklibgcc.obj : $(srcdir)/config/winnt/mklibgcc.c\n+\tcl -I. -I$(srcdir) -I$(srcdir)/config/winnt -c $(srcdir)/config/winnt/mklibgcc.c\n+\n+dirent.obj : $(srcdir)/config/winnt/dirent.c stmp-int-hdrs\n+\tcl -I. -I$(srcdir) -I$(srcdir)/include -I$(srcdir)/config/winnt -c $(srcdir)/config/winnt/dirent.c\n+\n+mklibgcc.exe : mklibgcc.obj dirent.obj\n+\tcl mklibgcc.obj dirent.obj libc.lib kernel32.lib\n+"}, {"sha": "081e4ec22c49395363ee9205b992886d1698414d", "filename": "gcc/config/winnt/mklibgcc.c", "status": "added", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a9f2bb90143fab29da3d99b424cef091279eb04/gcc%2Fconfig%2Fwinnt%2Fmklibgcc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a9f2bb90143fab29da3d99b424cef091279eb04/gcc%2Fconfig%2Fwinnt%2Fmklibgcc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fwinnt%2Fmklibgcc.c?ref=2a9f2bb90143fab29da3d99b424cef091279eb04", "patch": "@@ -0,0 +1,97 @@\n+#include <stdio.h>\n+#include <string.h>\n+#include <dirent.h>\n+\n+char *skips[] = {\n+  0\n+};\n+\n+int\n+do_clean()\n+{\n+  DIR *dir;\n+  struct dirent *de;\n+  remove(\"mklibnow.bat\");\n+\n+  dir = opendir(\"lgcctmp\");\n+  if (!dir)\n+    return 0;\n+  while ((de=readdir(dir)))\n+    {\n+      char buf[30];\n+      if (de->d_name[0] == '.')\n+        continue;\n+      sprintf(buf, \"lgcctmp/%s\", de->d_name);\n+      unlink(buf);\n+    }\n+  closedir(dir);\n+  return 0;\n+}\n+\n+int\n+main(int argc, char **argv)\n+{\n+  char *cc = argv[1];\n+  char *csrc=argv[2];\n+  int i;\n+  FILE *batfile;\n+  FILE *cfile;\n+\n+  if (argc > 1 && strcmp(argv[1], \"-c\")==0)\n+    return do_clean();\n+\n+  _mkdir(\"lgcctmp\", 0755);\n+\n+  batfile = fopen(\"mklibnow.bat\", \"a\");\n+  if (!batfile)\n+    {\n+      perror(\"mklibnow.bat\");\n+      return 1;\n+    }\n+/*  fprintf(batfile, \"@echo off\\n\"); */\n+\n+  for (i=3; i<argc; i++)\n+    {\n+      char dirname[30], basename[30], fullname[30], *bp;\n+      int s;\n+      for (s=0; skips[s]; s++)\n+        if (strcmp(skips[s], argv[i]) == 0)\n+  \tbreak;\n+      if (skips[s])\n+        continue;\n+      strcpy(dirname, \"lgcctmp/\");\n+      strcpy(basename, \"\\0\");\n+      if (strncmp(argv[i], \"_fix\", 4)==0)\n+        {\n+          strcat(basename, \"fx\");\n+          strcat(basename, argv[i]+4);\n+        }\n+      else if (strncmp(argv[i], \"_float\", 4)==0)\n+        {\n+          strcat(basename, \"flt\");\n+          strcat(basename, argv[i]+6);\n+        }\n+      else\n+        {\n+          strcat(basename, argv[i]);\n+        }\n+      strcpy (fullname, dirname);\n+      strcat (fullname, basename);\n+      fprintf(batfile, \"%s -c lgcctmp/%s.c\\n\", cc, basename);\n+      fprintf(batfile, \"copy %s.obj lgcctmp\\n\", basename);\n+      bp = fullname + strlen(fullname);\n+      strcpy(bp, \".c\");\n+      cfile = fopen(fullname, \"w\");\n+      if (cfile)\n+        {\n+          *bp = 0;\n+          fprintf(cfile, \"#define L%s\\n#include \\\"%s\\\"\\n\", argv[i], csrc);\n+          fclose(cfile);\n+        }\n+      else\n+        perror(fullname);\n+    }\n+\n+  fclose(batfile);\n+  return 0;\n+}"}, {"sha": "36e36b9c1a259ba436fc3671576adaab1ae962e0", "filename": "gcc/config/winnt/x-winnt", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a9f2bb90143fab29da3d99b424cef091279eb04/gcc%2Fconfig%2Fwinnt%2Fx-winnt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a9f2bb90143fab29da3d99b424cef091279eb04/gcc%2Fconfig%2Fwinnt%2Fx-winnt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fwinnt%2Fx-winnt?ref=2a9f2bb90143fab29da3d99b424cef091279eb04", "patch": "@@ -0,0 +1,34 @@\n+STMP_FIXPROTO =\n+OTHER_FIXINCLUDES_DIRS=${srcdir}\n+RANLIB = :\n+RANLIB_TEST = false\n+OLDCC = cl\n+MAKE = make\n+SHELL = sh\n+SYMLINK = cp\n+INSTALL = $(srcdir)/install.sh -c\n+.SUFFIXES: .obj\n+.c.obj:\n+\t$(CC) -c $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) $<\n+.adb.obj:\n+\t$(CC) -c $(ALL_ADAFLAGS) $<\n+.ads.obj:\n+\t$(CC) -c $(ALL_ADAFLAGS) $<\n+exeext = .exe\n+objext = .obj\n+\n+CC = gcc\n+CLIB = \n+LDFLAGS = \n+\n+ld.o: $(srcdir)/config/winnt/ld.c\n+\t$(CC) -I. -I$(srcdir) -I$(srcdir)/config -c $(srcdir)/config/winnt/ld.c\n+ \n+ld.exe: ld.o\n+\t$(CC) -o ld.exe ld.o\n+\n+oldnames.o: $(srcdir)/config/winnt/oldnames.c\n+\t$(CC) -I. -I$(srcdir) -I$(srcdir)/config -c $(srcdir)/config/winnt/oldnames.c\n+\n+spawnv.o: $(srcdir)/config/winnt/spawnv.c\n+\t$(CC) -I. -I$(srcdir) -I$(srcdir)/config -c $(srcdir)/config/winnt/spawnv.c"}, {"sha": "a8119b93030d0c8f27244f4384e83731fa8c9dfa", "filename": "gcc/fixinc-nt.sed", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a9f2bb90143fab29da3d99b424cef091279eb04/gcc%2Ffixinc-nt.sed", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a9f2bb90143fab29da3d99b424cef091279eb04/gcc%2Ffixinc-nt.sed", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffixinc-nt.sed?ref=2a9f2bb90143fab29da3d99b424cef091279eb04", "patch": "@@ -0,0 +1,5 @@\n+s/!__STDC__/!defined (__STRICT_ANSI__)/g\n+s/getcwd(char \\*, int)/getcwd(char *, size_t)/\n+s/Format\\[\\]/Format\\[1\\]/\n+s/^#if !defined (__cplusplus)/#if 0/\n+s/^#define DECLSPEC_IMPORT __declspec(dllimport)/#define DECLSPEC_IMPORT/"}]}