{"sha": "8ad46d34787e65fc43810ce8ba3eec545bfddd98", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGFkNDZkMzQ3ODdlNjVmYzQzODEwY2U4YmEzZWVjNTQ1YmZkZGQ5OA==", "commit": {"author": {"name": "Hans-Peter Nilsson", "email": "hp@axis.com", "date": "2004-07-22T10:10:56Z"}, "committer": {"name": "Hans-Peter Nilsson", "email": "hp@gcc.gnu.org", "date": "2004-07-22T10:10:56Z"}, "message": "cris.md: Tweak formatting.\n\n\t* config/cris/cris.md: Tweak formatting.\n\t(asrandb, asrandw, lsrandb, lsrandw, moversideqi, movemsideqi)\n\t(mover2side, moverside, movemside, movei, op3, andu): Replace\n\tlive define_peephole:s with define_peephole2 near-equivalents.\n\tDelete the rest.\n \t(\"*mov_sidesisf_biap\"): Rename from \"*mov_sidesi_biap\".  Match all\n\tword-size modes.\n\t(\"*mov_sidesisf\", \"*mov_sidesisf_biap_mem\", \"*mov_sidesisf_mem\"):\n\tSimilar for \"*mov_sidesi\", \"*mov_sidesi_biap_mem\" and\n\t\"*mov_sidesi_mem\" respectively.\n\nFrom-SVN: r85041", "tree": {"sha": "ae0709eaed3f8e12602305ef53a58d8d9ff5776c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ae0709eaed3f8e12602305ef53a58d8d9ff5776c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8ad46d34787e65fc43810ce8ba3eec545bfddd98", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8ad46d34787e65fc43810ce8ba3eec545bfddd98", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8ad46d34787e65fc43810ce8ba3eec545bfddd98", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8ad46d34787e65fc43810ce8ba3eec545bfddd98/comments", "author": {"login": "hpataxisdotcom", "id": 80339731, "node_id": "MDQ6VXNlcjgwMzM5NzMx", "avatar_url": "https://avatars.githubusercontent.com/u/80339731?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hpataxisdotcom", "html_url": "https://github.com/hpataxisdotcom", "followers_url": "https://api.github.com/users/hpataxisdotcom/followers", "following_url": "https://api.github.com/users/hpataxisdotcom/following{/other_user}", "gists_url": "https://api.github.com/users/hpataxisdotcom/gists{/gist_id}", "starred_url": "https://api.github.com/users/hpataxisdotcom/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hpataxisdotcom/subscriptions", "organizations_url": "https://api.github.com/users/hpataxisdotcom/orgs", "repos_url": "https://api.github.com/users/hpataxisdotcom/repos", "events_url": "https://api.github.com/users/hpataxisdotcom/events{/privacy}", "received_events_url": "https://api.github.com/users/hpataxisdotcom/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7413a13251eaeedb7e4a41b7110b9c064188816c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7413a13251eaeedb7e4a41b7110b9c064188816c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7413a13251eaeedb7e4a41b7110b9c064188816c"}], "stats": {"total": 604, "additions": 290, "deletions": 314}, "files": [{"sha": "05e5884e225dda3a4d309d4f4f539891d9384d00", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ad46d34787e65fc43810ce8ba3eec545bfddd98/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ad46d34787e65fc43810ce8ba3eec545bfddd98/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8ad46d34787e65fc43810ce8ba3eec545bfddd98", "patch": "@@ -1,3 +1,16 @@\n+2004-07-22  Hans-Peter Nilsson  <hp@axis.com>\n+\n+\t* config/cris/cris.md: Tweak formatting.\n+\t(asrandb, asrandw, lsrandb, lsrandw, moversideqi, movemsideqi)\n+\t(mover2side, moverside, movemside, movei, op3, andu): Replace\n+\tlive define_peephole:s with define_peephole2 near-equivalents.\n+\tDelete the rest.\n+ \t(\"*mov_sidesisf_biap\"): Rename from \"*mov_sidesi_biap\".  Match all\n+\tword-size modes.\n+\t(\"*mov_sidesisf\", \"*mov_sidesisf_biap_mem\", \"*mov_sidesisf_mem\"):\n+\tSimilar for \"*mov_sidesi\", \"*mov_sidesi_biap_mem\" and\n+\t\"*mov_sidesi_mem\" respectively.\n+\n 2004-07-22  Paolo Bonzini  <bonzini@gnu.org>\n \n \t* tree-cfg.c (gimplify_val): Move from tree-complex.c."}, {"sha": "4001a2a3b31d55777342991f3ab45ecc311090f7", "filename": "gcc/config/cris/cris.md", "status": "modified", "additions": 277, "deletions": 314, "changes": 591, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ad46d34787e65fc43810ce8ba3eec545bfddd98/gcc%2Fconfig%2Fcris%2Fcris.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ad46d34787e65fc43810ce8ba3eec545bfddd98/gcc%2Fconfig%2Fcris%2Fcris.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Fcris.md?ref=8ad46d34787e65fc43810ce8ba3eec545bfddd98", "patch": "@@ -470,17 +470,18 @@\n \n ;; SImode\n \n-(define_insn \"*mov_sidesi_biap\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n-\t(mem:SI (plus:SI\n-\t\t (mult:SI (match_operand:SI 1 \"register_operand\" \"r,r\")\n-\t\t\t  (match_operand:SI 2 \"const_int_operand\" \"n,n\"))\n-\t\t (match_operand:SI 3 \"register_operand\" \"r,r\"))))\n+(define_insn \"*mov_sidesisf_biap\"\n+  [(set (match_operand 0 \"register_operand\" \"=r,r\")\n+\t(mem (plus:SI\n+\t      (mult:SI (match_operand:SI 1 \"register_operand\" \"r,r\")\n+\t\t       (match_operand:SI 2 \"const_int_operand\" \"n,n\"))\n+\t      (match_operand:SI 3 \"register_operand\" \"r,r\"))))\n    (set (match_operand:SI 4 \"register_operand\" \"=*3,r\")\n \t(plus:SI (mult:SI (match_dup 1)\n \t\t\t  (match_dup 2))\n \t\t (match_dup 3)))]\n-  \"cris_side_effect_mode_ok (MULT, operands, 4, 3, 1, 2, 0)\"\n+  \"GET_MODE_SIZE (GET_MODE (operands[0])) == UNITS_PER_WORD\n+   && cris_side_effect_mode_ok (MULT, operands, 4, 3, 1, 2, 0)\"\n   \"@\n    #\n    move.%s0 [%4=%3+%1%T2],%0\")\n@@ -539,15 +540,16 @@\n \n ;; SImode\n \n-(define_insn \"*mov_sidesi\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r,r,r\")\n-\t(mem:SI\n+(define_insn \"*mov_sidesisf\"\n+  [(set (match_operand 0 \"register_operand\" \"=r,r,r\")\n+\t(mem\n \t (plus:SI (match_operand:SI 1 \"cris_bdap_operand\" \"%r,r,r\")\n \t\t  (match_operand:SI 2 \"cris_bdap_operand\" \"r>Rn,r,>Rn\"))))\n    (set (match_operand:SI 3 \"register_operand\" \"=*1,r,r\")\n \t(plus:SI (match_dup 1)\n \t\t (match_dup 2)))]\n-  \"cris_side_effect_mode_ok (PLUS, operands, 3, 1, 2, -1, 0)\"\n+  \"GET_MODE_SIZE (GET_MODE (operands[0])) == UNITS_PER_WORD\n+   && cris_side_effect_mode_ok (PLUS, operands, 3, 1, 2, -1, 0)\"\n   \"*\n {\n   if (which_alternative == 0\n@@ -618,17 +620,18 @@\n \n ;; SImode\n \n-(define_insn \"*mov_sidesi_biap_mem\"\n-  [(set (mem:SI (plus:SI\n-\t\t (mult:SI (match_operand:SI 0 \"register_operand\" \"r,r,r\")\n-\t\t\t  (match_operand:SI 1 \"const_int_operand\" \"n,n,n\"))\n-\t\t (match_operand:SI 2 \"register_operand\" \"r,r,r\")))\n-\t(match_operand:SI 3 \"register_operand\" \"r,r,r\"))\n+(define_insn \"*mov_sidesisf_biap_mem\"\n+  [(set (mem (plus:SI\n+\t      (mult:SI (match_operand:SI 0 \"register_operand\" \"r,r,r\")\n+\t\t       (match_operand:SI 1 \"const_int_operand\" \"n,n,n\"))\n+\t      (match_operand:SI 2 \"register_operand\" \"r,r,r\")))\n+\t(match_operand 3 \"register_operand\" \"r,r,r\"))\n    (set (match_operand:SI 4 \"register_operand\" \"=*2,!3,r\")\n \t(plus:SI (mult:SI (match_dup 0)\n \t\t\t  (match_dup 1))\n \t\t (match_dup 2)))]\n-  \"cris_side_effect_mode_ok (MULT, operands, 4, 2, 0, 1, 3)\"\n+  \"GET_MODE_SIZE (GET_MODE (operands[3])) == UNITS_PER_WORD\n+   && cris_side_effect_mode_ok (MULT, operands, 4, 2, 0, 1, 3)\"\n   \"@\n    #\n    #\n@@ -722,15 +725,16 @@\n \n ;; SImode\n \n-(define_insn \"*mov_sidesi_mem\"\n-  [(set (mem:SI\n+(define_insn \"*mov_sidesisf_mem\"\n+  [(set (mem\n \t (plus:SI (match_operand:SI 0 \"cris_bdap_operand\" \"%r,r,r,r\")\n \t\t  (match_operand:SI 1 \"cris_bdap_operand\" \"r>Rn,r>Rn,r,>Rn\")))\n-\t(match_operand:SI 2 \"register_operand\" \"r,r,r,r\"))\n+\t(match_operand 2 \"register_operand\" \"r,r,r,r\"))\n    (set (match_operand:SI 3 \"register_operand\" \"=*0,!2,r,r\")\n \t(plus:SI (match_dup 0)\n \t\t (match_dup 1)))]\n-  \"cris_side_effect_mode_ok (PLUS, operands, 3, 0, 1, -1, 2)\"\n+  \"GET_MODE_SIZE (GET_MODE (operands[2])) == UNITS_PER_WORD\n+   && cris_side_effect_mode_ok (PLUS, operands, 3, 0, 1, -1, 2)\"\n   \"*\n {\n   if (which_alternative == 0\n@@ -4219,13 +4223,13 @@\n \t\t      (match_operand:SI 2 \"const_int_operand\" \"\"))\n \t     (match_operand:SI 3 \"register_operand\" \"\"))]))\n      (set (match_operand:SI 4 \"register_operand\" \"\")\n-\t   (plus:SI (mult:SI (match_dup 1)\n-\t\t\t     (match_dup 2))\n+\t  (plus:SI (mult:SI (match_dup 1)\n+\t\t\t    (match_dup 2))\n \t\t    (match_dup 3)))])]\n   \"REG_P (operands[3]) && REG_P (operands[4])\n    && REGNO (operands[3]) == REGNO (operands[4])\"\n   [(set (match_dup 4) (plus:SI (mult:SI (match_dup 1) (match_dup 2))\n-\t\t\t\t(match_dup 3)))\n+\t\t\t       (match_dup 3)))\n    (set (match_dup 0) (match_dup 5))]\n   \"operands[5] = replace_equiv_address (operands[6], operands[3]);\")\n \n@@ -4693,91 +4697,71 @@\n ;; We have trouble with and:s and shifts.  Maybe something is broken in\n ;; gcc?  Or it could just be that bit-field insn expansion is a bit\n ;; suboptimal when not having extzv insns.\n+;; Testcase for the following four peepholes: gcc.dg/cris-peep2-xsrand.c\n \n-(define_peephole\n-  [(set (match_operand 0 \"register_operand\" \"=r\")\n+(define_peephole2 ; asrandb (peephole casesi+31)\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n \t(ashiftrt:SI (match_dup 0)\n-\t\t     (match_operand:SI 1 \"const_int_operand\" \"n\")))\n+\t\t     (match_operand:SI 1 \"const_int_operand\" \"\")))\n    (set (match_dup 0)\n \t(and:SI (match_dup 0)\n-\t\t(match_operand 2 \"const_int_operand\" \"n\")))]\n+\t\t(match_operand 2 \"const_int_operand\" \"\")))]\n   \"INTVAL (operands[2]) > 31\n    && INTVAL (operands[2]) < 255\n-   && INTVAL (operands[1]) > 23\"\n-\n-;; The m flag should be ignored, because this will be a *byte* \"and\"\n-;; operation.\n-\n-  \"*\n-{\n-  cc_status.flags |= CC_NOT_NEGATIVE;\n-\n-  return \\\"lsrq %1,%0\\;and.b %2,%0\\\";\n-}\")\n-\n-(define_peephole\n-  [(set (match_operand 0 \"register_operand\" \"=r\")\n+   && INTVAL (operands[1]) > 23\n+   /* Check that the and-operation enables us to use logical-shift.  */\n+   && (INTVAL (operands[2])\n+\t  & ((HOST_WIDE_INT) -1 << (32 - INTVAL (operands[1])))) == 0\"\n+  [(set (match_dup 0) (lshiftrt:SI (match_dup 0) (match_dup 1)))\n+   (set (match_dup 3) (and:QI (match_dup 3) (match_dup 2)))]\n+  ;; FIXME: CC0 is valid except for the M bit.\n+  \"operands[3] = gen_rtx_REG (QImode, REGNO (operands[0]));\")\n+\n+(define_peephole2 ; asrandw (peephole casesi+32)\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n \t(ashiftrt:SI (match_dup 0)\n-\t\t     (match_operand:SI 1 \"const_int_operand\" \"n\")))\n+\t\t     (match_operand:SI 1 \"const_int_operand\" \"\")))\n    (set (match_dup 0)\n-\t(and:SI (match_dup 0)\n-\t\t(match_operand 2 \"const_int_operand\" \"n\")))]\n+\t(and:SI (match_dup 0) (match_operand 2 \"const_int_operand\" \"\")))]\n   \"INTVAL (operands[2]) > 31\n    && INTVAL (operands[2]) < 65535\n    && INTVAL (operands[2]) != 255\n-   && INTVAL (operands[1]) > 15\"\n-\n-;; The m flag should be ignored, because this will be a *word* \"and\"\n-;; operation.\n-\n-  \"*\n-{\n-  cc_status.flags |= CC_NOT_NEGATIVE;\n-\n-  return \\\"lsrq %1,%0\\;and.w %2,%0\\\";\n-}\")\n-\n-(define_peephole\n-  [(set (match_operand 0 \"register_operand\" \"=r\")\n+   && INTVAL (operands[1]) > 15\n+   /* Check that the and-operation enables us to use logical-shift.  */\n+   && (INTVAL (operands[2])\n+       & ((HOST_WIDE_INT) -1 << (32 - INTVAL (operands[1])))) == 0\"\n+  [(set (match_dup 0) (lshiftrt:SI (match_dup 0) (match_dup 1)))\n+   (set (match_dup 3) (and:HI (match_dup 3) (match_dup 2)))]\n+  ;; FIXME: CC0 is valid except for the M bit.\n+  \"operands[3] = gen_rtx_REG (HImode, REGNO (operands[0]));\")\n+\n+(define_peephole2 ; lsrandb (peephole casesi+33)\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n \t(lshiftrt:SI (match_dup 0)\n-\t\t     (match_operand:SI 1 \"const_int_operand\" \"n\")))\n+\t\t     (match_operand:SI 1 \"const_int_operand\" \"\")))\n    (set (match_dup 0)\n-\t(and:SI (match_dup 0)\n-\t\t(match_operand 2 \"const_int_operand\" \"n\")))]\n+\t(and:SI (match_dup 0) (match_operand 2 \"const_int_operand\" \"\")))]\n   \"INTVAL (operands[2]) > 31\n    && INTVAL (operands[2]) < 255\n    && INTVAL (operands[1]) > 23\"\n+  [(set (match_dup 0) (lshiftrt:SI (match_dup 0) (match_dup 1)))\n+   (set (match_dup 3) (and:QI (match_dup 3) (match_dup 2)))]\n+  ;; FIXME: CC0 is valid except for the M bit.\n+  \"operands[3] = gen_rtx_REG (QImode, REGNO (operands[0]));\")\n \n-;; The m flag should be ignored, because this will be a *byte* \"and\"\n-;; operation.\n-\n-  \"*\n-{\n-  cc_status.flags |= CC_NOT_NEGATIVE;\n-\n-  return \\\"lsrq %1,%0\\;and.b %2,%0\\\";\n-}\")\n-\n-(define_peephole\n-  [(set (match_operand 0 \"register_operand\" \"=r\")\n+(define_peephole2 ; lsrandw (peephole casesi+34)\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n \t(lshiftrt:SI (match_dup 0)\n-\t\t     (match_operand:SI 1 \"const_int_operand\" \"n\")))\n+\t\t     (match_operand:SI 1 \"const_int_operand\" \"\")))\n    (set (match_dup 0)\n-\t(and:SI (match_dup 0)\n-\t\t(match_operand 2 \"const_int_operand\" \"n\")))]\n+\t(and:SI (match_dup 0) (match_operand 2 \"const_int_operand\" \"\")))]\n   \"INTVAL (operands[2]) > 31 && INTVAL (operands[2]) < 65535\n    && INTVAL (operands[2]) != 255\n    && INTVAL (operands[1]) > 15\"\n-\n-;; The m flag should be ignored, because this will be a *word* \"and\"\n-;; operation.\n-\n-  \"*\n-{\n-  cc_status.flags |= CC_NOT_NEGATIVE;\n-\n-  return \\\"lsrq %1,%0\\;and.w %2,%0\\\";\n-}\")\n+  [(set (match_dup 0) (lshiftrt:SI (match_dup 0) (match_dup 1)))\n+   (set (match_dup 3) (and:HI (match_dup 3) (match_dup 2)))]\n+  ;; FIXME: CC0 is valid except for the M bit.\n+  \"operands[3] = gen_rtx_REG (HImode, REGNO (operands[0]));\")\n \f\n \n ;; Change\n@@ -4787,38 +4771,64 @@\n ;;  move [rx=rx+n],ry\n ;; when -128 <= n <= 127.\n ;; This will reduce the size of the assembler code for n = [-128..127],\n-;; and speed up accordingly.\n-\n-(define_peephole\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(plus:SI (match_operand:SI 1 \"register_operand\" \"0\")\n-\t\t (match_operand:SI 2 \"const_int_operand\" \"n\")))\n-   (set (match_operand 3 \"register_operand\" \"=r\")\n-\t(mem (match_dup 0)))]\n-  \"GET_MODE (operands[3]) != DImode\n-    && REGNO (operands[3]) != REGNO (operands[0])\n-    && (BASE_P (operands[1]) || BASE_P (operands[2]))\n-    && ! CONST_OK_FOR_LETTER_P (INTVAL (operands[2]), 'J')\n-    && ! CONST_OK_FOR_LETTER_P (INTVAL (operands[2]), 'N')\n-    && (INTVAL (operands[2]) >= -128 && INTVAL (operands[2]) < 128)\"\n-  \"move.%s3 [%0=%1%S2],%3\")\n+;; and speed up accordingly.  Don't match if the previous insn is\n+;; (set rx rz) because that combination is matched by another peephole.\n+;; No stable test-case.\n+\n+(define_peephole2 ; moversideqi (peephole casesi+35)\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(plus:SI (match_operand:SI 1 \"register_operand\" \"\")\n+\t\t (match_operand:SI 2 \"const_int_operand\" \"\")))\n+   (set (match_operand 3 \"register_operand\" \"\")\n+\t(match_operator 4 \"cris_mem_op\" [(match_dup 0)]))]\n+  \"GET_MODE_SIZE (GET_MODE (operands[4])) <= UNITS_PER_WORD\n+   && REGNO (operands[3]) != REGNO (operands[0])\n+   && (BASE_P (operands[1]) || BASE_P (operands[2]))\n+   && ! CONST_OK_FOR_LETTER_P (INTVAL (operands[2]), 'J')\n+   && ! CONST_OK_FOR_LETTER_P (INTVAL (operands[2]), 'N')\n+   && (INTVAL (operands[2]) >= -128 && INTVAL (operands[2]) < 128)\"\n+  [(parallel\n+    [(set (match_dup 3) (match_dup 5))\n+     (set (match_dup 0) (plus:SI (match_dup 1) (match_dup 2)))])]\n+  ;; Checking the previous insn is a bit too awkward for the condition.\n+{\n+  rtx prev = prev_nonnote_insn (curr_insn);\n+  if (prev != NULL_RTX)\n+    {\n+      rtx set = single_set (prev);\n+      if (set != NULL_RTX\n+\t  && REG_S_P (SET_DEST (set))\n+\t  && REGNO (SET_DEST (set)) == REGNO (operands[0])\n+\t  && REG_S_P (SET_SRC (set)))\n+\tFAIL;\n+    }\n+  operands[5]\n+    = replace_equiv_address (operands[4],\n+\t\t\t     gen_rtx_PLUS (SImode,\n+\t\t\t\t\t   operands[1], operands[2]));\n+})\n \n ;; Vice versa: move ry,[rx=rx+n]\n \n-(define_peephole\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(plus:SI (match_operand:SI 1 \"register_operand\" \"0\")\n-\t\t (match_operand:SI 2 \"const_int_operand\" \"n\")))\n-   (set (mem (match_dup 0))\n-\t(match_operand 3 \"register_operand\" \"=r\"))]\n-  \"GET_MODE (operands[3]) != DImode\n-    && REGNO (operands[3]) != REGNO (operands[0])\n-    && (BASE_P (operands[1]) || BASE_P (operands[2]))\n-    && ! CONST_OK_FOR_LETTER_P (INTVAL (operands[2]), 'J')\n-    && ! CONST_OK_FOR_LETTER_P (INTVAL (operands[2]), 'N')\n-    && (INTVAL (operands[2]) >= -128 && INTVAL (operands[2]) < 128)\"\n-  \"move.%s3 %3,[%0=%1%S2]\"\n-  [(set_attr \"cc\" \"none\")])\n+(define_peephole2 ; movemsideqi (peephole casesi+36)\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(plus:SI (match_operand:SI 1 \"register_operand\" \"\")\n+\t\t (match_operand:SI 2 \"const_int_operand\" \"\")))\n+   (set (match_operator 3 \"cris_mem_op\" [(match_dup 0)])\n+\t(match_operand 4 \"register_operand\" \"\"))]\n+  \"GET_MODE_SIZE (GET_MODE (operands[4])) <= UNITS_PER_WORD\n+   && REGNO (operands[4]) != REGNO (operands[0])\n+   && (BASE_P (operands[1]) || BASE_P (operands[2]))\n+   && ! CONST_OK_FOR_LETTER_P (INTVAL (operands[2]), 'J')\n+   && ! CONST_OK_FOR_LETTER_P (INTVAL (operands[2]), 'N')\n+   && (INTVAL (operands[2]) >= -128 && INTVAL (operands[2]) < 128)\"\n+  [(parallel\n+    [(set (match_dup 5) (match_dup 4))\n+     (set (match_dup 0) (plus:SI (match_dup 1) (match_dup 2)))])]\n+  \"operands[5]\n+     = replace_equiv_address (operands[3],\n+\t\t\t      gen_rtx_PLUS (SImode,\n+\t\t\t\t\t    operands[1], operands[2]));\")\n \f\n ;; As above, change:\n ;;  add.d n,rx\n@@ -4831,175 +4841,144 @@\n ;; out of hand.  They probably will not save the time they take typing in,\n ;; not to mention the bugs that creep in.  FIXME: Get rid of as many of\n ;; the splits and peepholes as possible.\n-\n-(define_peephole\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(plus:SI (match_operand:SI 1 \"register_operand\" \"0\")\n-\t\t (match_operand:SI 2 \"const_int_operand\" \"n\")))\n-   (set (match_operand 3 \"register_operand\" \"=r\")\n-\t(match_operator 4 \"cris_orthogonal_operator\"\n-\t\t\t   [(match_dup 3)\n-\t\t\t    (mem (match_dup 0))]))]\n+;; No stable test-case.\n+\n+(define_peephole2 ; mover2side (peephole casesi+37)\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(plus:SI (match_operand:SI 1 \"register_operand\" \"\")\n+\t\t (match_operand:SI 2 \"const_int_operand\" \"\")))\n+   (set (match_operand 3 \"register_operand\" \"\")\n+\t  (match_operator 4 \"cris_orthogonal_operator\"\n+\t\t\t  [(match_dup 3)\n+\t\t\t   (match_operator\n+\t\t\t    5 \"cris_mem_op\" [(match_dup 0)])]))]\n   \"GET_MODE (operands[3]) != DImode\n-    && REGNO (operands[0]) != REGNO (operands[3])\n-    && ! CONST_OK_FOR_LETTER_P (INTVAL (operands[2]), 'J')\n-    && ! CONST_OK_FOR_LETTER_P (INTVAL (operands[2]), 'N')\n-    && INTVAL (operands[2]) >= -128\n-    && INTVAL (operands[2]) <= 127\"\n-  \"%x4.%s3 [%0=%1%S2],%3\")\n+   && REGNO (operands[0]) != REGNO (operands[3])\n+   && ! CONST_OK_FOR_LETTER_P (INTVAL (operands[2]), 'J')\n+   && ! CONST_OK_FOR_LETTER_P (INTVAL (operands[2]), 'N')\n+   && INTVAL (operands[2]) >= -128\n+   && INTVAL (operands[2]) <= 127\"\n+  [(parallel\n+    [(set (match_dup 3) (match_op_dup 4 [(match_dup 3) (match_dup 6)]))\n+     (set (match_dup 0) (plus:SI (match_dup 1) (match_dup 2)))])]\n+  \"operands[6]\n+     = replace_equiv_address (operands[5],\n+\t\t\t      gen_rtx_PLUS (SImode,\n+\t\t\t\t\t    operands[1], operands[2]));\")\n \n ;; Sometimes, for some reason the pattern\n ;;  move x,rx\n ;;  add y,rx\n ;;  move [rx],rz\n ;; will occur.  Solve this, and likewise for to-memory.\n+;; No stable test-case.\n \n-(define_peephole\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r,r,r,r\")\n-\t(match_operand:SI 1 \"cris_bdap_biap_operand\" \"r,>Rn,r,>Rn\"))\n+(define_peephole2 ; moverside (peephole casesi+38)\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(match_operand:SI 1 \"cris_bdap_biap_operand\" \"\"))\n    (set (match_dup 0)\n-\t(plus:SI (match_operand:SI 2 \"cris_bdap_biap_operand\" \"0,0,r>Rn,r\")\n-\t\t (match_operand:SI 3 \"cris_bdap_biap_operand\" \"r>Rn,r,0,0\")))\n-   (set (match_operand 4 \"register_operand\" \"=r,r,r,r\")\n-\t(mem (match_dup 0)))]\n+\t(plus:SI (match_operand:SI 2 \"cris_bdap_biap_operand\" \"\")\n+\t\t (match_operand:SI 3 \"cris_bdap_biap_operand\" \"\")))\n+   (set (match_operand 4 \"register_operand\" \"\")\n+\t(match_operator 5 \"cris_mem_op\" [(match_dup 0)]))]\n   \"(rtx_equal_p (operands[2], operands[0])\n     || rtx_equal_p (operands[3], operands[0]))\n    && cris_side_effect_mode_ok (PLUS, operands, 0,\n-                                (REG_S_P (operands[1])\n-                                 ? 1\n-                                 : (rtx_equal_p (operands[2], operands[0])\n-                                    ? 3 : 2)),\n-                                (! REG_S_P (operands[1])\n-                                 ? 1\n-                                 : (rtx_equal_p (operands[2], operands[0])\n-                                    ? 3 : 2)),\n-                                -1, 4)\"\n-  \"@\n-   move.%s4 [%0=%1%S3],%4\n-   move.%s4 [%0=%3%S1],%4\n-   move.%s4 [%0=%1%S2],%4\n-   move.%s4 [%0=%2%S1],%4\")\n+\t\t\t\t(REG_S_P (operands[1])\n+\t\t\t\t ? 1\n+\t\t\t\t : (rtx_equal_p (operands[2], operands[0])\n+\t\t\t\t    ? 3 : 2)),\n+\t\t\t\t(! REG_S_P (operands[1])\n+\t\t\t\t ? 1\n+\t\t\t\t : (rtx_equal_p (operands[2], operands[0])\n+\t\t\t\t    ? 3 : 2)),\n+\t\t\t\t-1, 4)\"\n+  [(parallel\n+    [(set (match_dup 4) (match_dup 6))\n+     (set (match_dup 0) (plus:SI (match_dup 7) (match_dup 8)))])]\n+{\n+  rtx reg\n+    = rtx_equal_p (operands[2], operands[0]) ? operands[3] : operands[2];\n+\n+  if (REG_S_P (operands[1]))\n+    {\n+      operands[7] = operands[1];\n+      operands[8] = reg;\n+    }\n+  else\n+    {\n+      operands[7] = reg;\n+      operands[8] = operands[1];\n+    }\n+  operands[6]\n+    = replace_equiv_address (operands[5],\n+\t\t\t     gen_rtx_PLUS (SImode,\n+\t\t\t\t\t   operands[7], operands[8]));\n+})\n \n ;; As above but to memory.\n+;; FIXME: Split movemside and moverside into variants and prune\n+;; the ones that don't trig.\n+;; No stable test-case.\n \n-(define_peephole\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r,r,r,r\")\n-\t(match_operand:SI 1 \"cris_bdap_biap_operand\" \"r,>Rn,r,>Rn\"))\n+(define_peephole2 ; movemside (peephole casesi+39)\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(match_operand:SI 1 \"cris_bdap_biap_operand\" \"\"))\n    (set (match_dup 0)\n-\t(plus:SI (match_operand:SI 2 \"cris_bdap_biap_operand\" \"0,0,r>Rn,r\")\n-\t\t (match_operand:SI 3 \"cris_bdap_biap_operand\" \"r>Rn,r,0,0\")))\n-   (set (mem (match_dup 0))\n-\t(match_operand 4 \"register_operand\" \"=r,r,r,r\"))]\n+\t(plus:SI (match_operand:SI 2 \"cris_bdap_biap_operand\" \"\")\n+\t\t (match_operand:SI 3 \"cris_bdap_biap_operand\" \"\")))\n+   (set (match_operator 4 \"cris_mem_op\" [(match_dup 0)])\n+\t(match_operand 5 \"register_operand\" \"\"))]\n   \"(rtx_equal_p (operands[2], operands[0])\n     || rtx_equal_p (operands[3], operands[0]))\n    && cris_side_effect_mode_ok (PLUS, operands, 0,\n-                                (REG_S_P (operands[1])\n-                                 ? 1\n-                                 : (rtx_equal_p (operands[2], operands[0])\n-                                    ? 3 : 2)),\n-                                (! REG_S_P (operands[1])\n-                                   ? 1\n-                                 : (rtx_equal_p (operands[2], operands[0])\n-                                    ? 3 : 2)),\n-                                -1, 4)\"\n-  \"@\n-   move.%s4 %4,[%0=%1%S3]\n-   move.%s4 %4,[%0=%3%S1]\n-   move.%s4 %4,[%0=%1%S2]\n-   move.%s4 %4,[%0=%2%S1]\"\n-  [(set_attr \"cc\" \"none\")])\n-\n-\n-;; As the move from-memory above, but with an operation.\n-\n-(define_peephole\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r,r,r,r\")\n-\t(match_operand:SI 1 \"cris_bdap_biap_operand\" \"r,>Rn,r,>Rn\"))\n-   (set (match_dup 0)\n-\t(plus:SI (match_operand:SI 2 \"cris_bdap_biap_operand\" \"0,0,r>Rn,r\")\n-\t\t (match_operand:SI 3 \"cris_bdap_biap_operand\" \"r>Rn,r,0,0\")))\n-   (set (match_operand 4 \"register_operand\" \"=r,r,r,r\")\n-\t(match_operator 5 \"cris_orthogonal_operator\"\n-\t\t\t[(match_dup 3)\n-\t\t\t (mem (match_dup 0))]))]\n-  \"(rtx_equal_p (operands[2], operands[0])\n-    || rtx_equal_p (operands[3], operands[0]))\n-   && cris_side_effect_mode_ok (PLUS, operands, 0,\n-                                (REG_S_P (operands[1])\n-                                 ? 1\n-                                 : (rtx_equal_p (operands[2], operands[0])\n-                                    ? 3 : 2)),\n-                                (! REG_S_P (operands[1])\n-                                 ? 1\n-                                 : (rtx_equal_p (operands[2], operands[0])\n-                                    ? 3 : 2)),\n-                                -1, 4)\"\n-  \"@\n-   %x5.%s4 [%0=%1%S3],%4\n-   %x5.%s4 [%0=%3%S1],%4\n-   %x5.%s4 [%0=%1%S2],%4\n-   %x5.%s4 [%0=%2%S1],%4\")\n-\n-;; Same, but with swapped operands (and commutative operation).\n+\t\t\t\t(REG_S_P (operands[1])\n+\t\t\t\t ? 1\n+\t\t\t\t : (rtx_equal_p (operands[2], operands[0])\n+\t\t\t\t    ? 3 : 2)),\n+\t\t\t\t(! REG_S_P (operands[1])\n+\t\t\t\t   ? 1\n+\t\t\t\t : (rtx_equal_p (operands[2], operands[0])\n+\t\t\t\t    ? 3 : 2)),\n+\t\t\t\t-1, 5)\"\n+  [(parallel\n+    [(set (match_dup 6) (match_dup 5))\n+     (set (match_dup 0) (plus:SI (match_dup 7) (match_dup 8)))])]\n+{\n+  rtx reg\n+    = rtx_equal_p (operands[2], operands[0]) ? operands[3] : operands[2];\n \n-(define_peephole\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r,r,r,r\")\n-\t(match_operand:SI 1 \"cris_bdap_biap_operand\" \"r,>Rn,r,>Rn\"))\n-   (set (match_dup 0)\n-\t(plus:SI (match_operand:SI 2 \"cris_bdap_biap_operand\" \"0,0,r>Rn,r\")\n-\t\t (match_operand:SI 3 \"cris_bdap_biap_operand\" \"r>Rn,r,0,0\")))\n-   (set (match_operand 4 \"register_operand\" \"=r,r,r,r\")\n-\t(match_operator 5 \"cris_commutative_orth_op\"\n-\t\t\t[(mem (match_dup 0))\n-\t\t\t (match_dup 3)]))]\n-  \"(rtx_equal_p (operands[2], operands[0])\n-    || rtx_equal_p (operands[3], operands[0]))\n-   && cris_side_effect_mode_ok (PLUS, operands, 0,\n-\t\t\t   (REG_S_P (operands[1])\n-\t\t\t    ? 1\n-\t\t\t    : (rtx_equal_p (operands[2], operands[0])\n-\t\t\t       ? 3 : 2)),\n-\t\t\t   (! REG_S_P (operands[1])\n-\t\t\t    ? 1\n-\t\t\t    : (rtx_equal_p (operands[2], operands[0])\n-\t\t\t       ? 3 : 2)),\n-\t\t\t   -1, 4)\"\n-  \"@\n-   %x5.%s4 [%0=%1%S3],%4\n-   %x5.%s4 [%0=%3%S1],%4\n-   %x5.%s4 [%0=%1%S2],%4\n-   %x5.%s4 [%0=%2%S1],%4\")\n+  if (REG_S_P (operands[1]))\n+    {\n+      operands[7] = operands[1];\n+      operands[8] = reg;\n+    }\n+  else\n+    {\n+      operands[7] = reg;\n+      operands[8] = operands[1];\n+    }\n+  operands[6]\n+    = replace_equiv_address (operands[4],\n+\t\t\t     gen_rtx_PLUS (SImode,\n+\t\t\t\t\t   operands[7], operands[8]));\n+})\n \n ;; Another spotted bad code:\n ;;   move rx,ry\n ;;   move [ry],ry\n+;; No stable test-case.\n \n-(define_peephole\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(match_operand:SI 1 \"register_operand\" \"r\"))\n-   (set (match_operand 2 \"register_operand\" \"=r\")\n-\t(mem (match_dup 0)))]\n+(define_peephole2 ; movei (peephole casesi+42)\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(match_operand:SI 1 \"register_operand\" \"\"))\n+   (set (match_operand 2 \"register_operand\" \"\")\n+\t(match_operator 3 \"cris_mem_op\" [(match_dup 0)]))]\n   \"REGNO (operands[0]) == REGNO (operands[2])\n    && GET_MODE_SIZE (GET_MODE (operands[2])) <= UNITS_PER_WORD\"\n-  \"move.%s2 [%1],%0\"\n-  [(set_attr \"slottable\" \"yes\")])\n+  [(set (match_dup 2) (match_dup 4))]\n+  \"operands[4] = replace_equiv_address (operands[3], operands[1]);\")\n \n-;; And a simple variant with extended operand.\n-\n-(define_peephole\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(match_operand:SI 1 \"register_operand\" \"r\"))\n-   (set (match_operand 2 \"register_operand\" \"=r\")\n-\t(match_operator 3 \"cris_extend_operator\" [(mem (match_dup 0))]))]\n-  \"REGNO (operands[0]) == REGNO (operands[2])\n-   && GET_MODE_SIZE (GET_MODE (operands[2])) <= UNITS_PER_WORD\"\n-  \"mov%e3.%m3 [%1],%0\"\n-  [(set_attr \"slottable\" \"yes\")])\n-\f\n-;; Here are all peepholes that have a saved testcase.\n-;; Do not add new peepholes without testcases.\n-\n-;; peep-1:\n ;;   move.d [r10+16],r9\n ;;   and.d r12,r9\n ;; change to\n@@ -5012,28 +4991,29 @@\n ;; register pressure.\n ;;  Note that adding the noncommutative variant did not show any matches\n ;; in ipps and cc1, so it's not here.\n+;; No stable test-case.\n \n-(define_peephole\n-  [(set (match_operand 0 \"register_operand\" \"=r,r,r,r\")\n-\t(mem (plus:SI\n-\t      (match_operand:SI 1 \"cris_bdap_biap_operand\" \"r,r>Rn,r,r>Rn\")\n-\t      (match_operand:SI 2 \"cris_bdap_biap_operand\" \"r>Rn,r,r>Rn,r\"))))\n+(define_peephole2 ; op3 (peephole casesi+44)\n+  [(set (match_operand 0 \"register_operand\" \"\")\n+\t(match_operator\n+\t 6 \"cris_mem_op\"\n+\t [(plus:SI\n+\t   (match_operand:SI 1 \"cris_bdap_biap_operand\" \"\")\n+\t   (match_operand:SI 2 \"cris_bdap_biap_operand\" \"\"))]))\n    (set (match_dup 0)\n-\t(match_operator 5 \"cris_commutative_orth_op\"\n-\t\t\t[(match_operand 3 \"register_operand\" \"0,0,r,r\")\n-\t\t\t (match_operand 4 \"register_operand\" \"r,r,0,0\")]))]\n+\t(match_operator\n+\t 5 \"cris_commutative_orth_op\"\n+\t [(match_operand 3 \"register_operand\" \"\")\n+\t  (match_operand 4 \"register_operand\" \"\")]))]\n   \"(rtx_equal_p (operands[3], operands[0])\n     || rtx_equal_p (operands[4], operands[0]))\n    && ! rtx_equal_p (operands[3], operands[4])\n    && (REG_S_P (operands[1]) || REG_S_P (operands[2]))\n    && GET_MODE_SIZE (GET_MODE (operands[0])) <= UNITS_PER_WORD\"\n-  \"@\n-   %x5.%s0 [%1%S2],%4,%0\n-   %x5.%s0 [%2%S1],%4,%0\n-   %x5.%s0 [%1%S2],%3,%0\n-   %x5.%s0 [%2%S1],%3,%0\")\n+  [(set (match_dup 0) (match_op_dup 5 [(match_dup 7) (match_dup 6)]))]\n+  \"operands[7]\n+     = rtx_equal_p (operands[3], operands[0]) ? operands[4] : operands[3];\")\n \n-;; peep-2:\n ;;  I cannot tell GCC (2.1, 2.7.2) how to correctly reload an instruction\n ;; that looks like\n ;;   and.b some_byte,const,reg_32\n@@ -5045,57 +5025,40 @@\n ;;   move.b some_byte,reg_32\n ;;   and.d const,reg_32\n ;; Fix it here.\n+;; Testcases: gcc.dg/cris-peep2-andu1.c gcc.dg/cris-peep2-andu2.c\n \n-(define_peephole\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(match_operand:SI 1 \"nonimmediate_operand\" \"rm\"))\n-   (set (match_operand:SI 2 \"register_operand\" \"=0\")\n+(define_peephole2 ; andu (casesi+45)\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(match_operand:SI 1 \"nonimmediate_operand\" \"\"))\n+   (set (match_operand:SI 2 \"register_operand\" \"\")\n \t(and:SI (match_dup 0)\n-\t\t(match_operand:SI 3 \"const_int_operand\" \"n\")))]\n-\n+\t\t(match_operand:SI 3 \"const_int_operand\" \"\")))]\n    ;; Since the size of the memory access could be made different here,\n    ;; don't do this for a mem-volatile access.\n-\n   \"REGNO (operands[2]) == REGNO (operands[0])\n    && INTVAL (operands[3]) <= 65535 && INTVAL (operands[3]) >= 0\n    && ! CONST_OK_FOR_LETTER_P (INTVAL (operands[3]), 'I')\n    && (GET_CODE (operands[1]) != MEM || ! MEM_VOLATILE_P (operands[1]))\"\n-  \"*\n-{\n-  if (CONST_OK_FOR_LETTER_P (INTVAL (operands[3]), 'O'))\n-    return \\\"movu.%z3 %1,%0\\;andq %b3,%0\\\";\n-\n-  cc_status.flags |= CC_NOT_NEGATIVE;\n-\n-  return \\\"movu.%z3 %1,%0\\;and.%z3 %3,%0\\\";\n-}\")\n-\n-;; peep-3\n-\n-(define_peephole\n-  [(set (match_operand 0 \"register_operand\" \"=r\")\n-\t(match_operand 1 \"nonimmediate_operand\" \"rm\"))\n-   (set (match_operand:SI 2 \"register_operand\" \"=r\")\n-\t(and:SI (subreg:SI (match_dup 0) 0)\n-\t\t(match_operand 3 \"const_int_operand\" \"n\")))]\n-\n-   ;; Since the size of the memory access could be made different here,\n-   ;; don't do this for a mem-volatile access.\n-\n-  \"REGNO (operands[0]) == REGNO (operands[2])\n-   && INTVAL (operands[3]) > 0\n-   && INTVAL (operands[3]) <= 65535\n-   && ! CONST_OK_FOR_LETTER_P (INTVAL (operands[3]), 'I')\n-   && (GET_CODE (operands[1]) != MEM || ! MEM_VOLATILE_P (operands[1]))\"\n-  \"*\n+  ;; FIXME: CC0 valid except for M (i.e. CC_NOT_NEGATIVE).\n+  [(set (match_dup 0) (match_dup 4))\n+   (set (match_dup 5) (match_dup 6))]\n {\n-  if (CONST_OK_FOR_LETTER_P (INTVAL (operands[3]), 'O'))\n-    return \\\"movu.%z3 %1,%0\\;andq %b3,%0\\\";\n-\n-  cc_status.flags |= CC_NOT_NEGATIVE;\n-\n-  return \\\"movu.%z3 %1,%0\\;and.%z3 %3,%0\\\";\n-}\")\n+  enum machine_mode zmode = INTVAL (operands[3]) <= 255 ? QImode : HImode;\n+  enum machine_mode amode\n+    = CONST_OK_FOR_LETTER_P (INTVAL (operands[3]), 'O') ? SImode : zmode;\n+  rtx op1\n+    = (REG_S_P (operands[1])\n+       ? gen_rtx_REG (zmode, REGNO (operands[1]))\n+       : adjust_address (operands[1], zmode, 0));\n+  operands[4]\n+    = gen_rtx_ZERO_EXTEND (SImode, op1);\n+  operands[5] = gen_rtx_REG (amode, REGNO (operands[0]));\n+  operands[6]\n+    = gen_rtx_AND (amode, gen_rtx_REG (amode, REGNO (operands[0])),\n+\t\t   GEN_INT (trunc_int_for_mode (INTVAL (operands[3]),\n+\t\t\t\t\t\tamode == SImode\n+\t\t\t\t\t\t? QImode : amode)));\n+})\n \f\n ;; Local variables:\n ;; mode:emacs-lisp"}]}