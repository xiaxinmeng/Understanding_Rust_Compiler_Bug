{"sha": "8cf81ddffd26ef1262e2d93f7232d72b92cd72be", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGNmODFkZGZmZDI2ZWYxMjYyZTJkOTNmNzIzMmQ3MmI5MmNkNzJiZQ==", "commit": {"author": {"name": "Dorit Nuzman", "email": "dorit@il.ibm.com", "date": "2007-04-18T07:55:34Z"}, "committer": {"name": "Dorit Nuzman", "email": "dorit@gcc.gnu.org", "date": "2007-04-18T07:55:34Z"}, "message": "tree-vect-analyze.c (process_use): New function.\n\n        * tree-vect-analyze.c (process_use): New function.\n        (vect_mark_stmts_to_be_vectorized): Factor out code to process_use.\n        Check phis in all bbs.\n        * tree-vectorizer.c (vect_is_simple_use): Remove a no longer relavant\n        assert.\n\nFrom-SVN: r123943", "tree": {"sha": "0ad09efa2980fbea19fc13f434aa01aa5eac044f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0ad09efa2980fbea19fc13f434aa01aa5eac044f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8cf81ddffd26ef1262e2d93f7232d72b92cd72be", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8cf81ddffd26ef1262e2d93f7232d72b92cd72be", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8cf81ddffd26ef1262e2d93f7232d72b92cd72be", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8cf81ddffd26ef1262e2d93f7232d72b92cd72be/comments", "author": null, "committer": null, "parents": [{"sha": "7b715e2e18f941bef4c263de3978c3050cabb60a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7b715e2e18f941bef4c263de3978c3050cabb60a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7b715e2e18f941bef4c263de3978c3050cabb60a"}], "stats": {"total": 219, "additions": 136, "deletions": 83}, "files": [{"sha": "0c19d7ea14b995a16e519d62b3f0647df12dd1c2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cf81ddffd26ef1262e2d93f7232d72b92cd72be/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cf81ddffd26ef1262e2d93f7232d72b92cd72be/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8cf81ddffd26ef1262e2d93f7232d72b92cd72be", "patch": "@@ -1,3 +1,11 @@\n+2007-04-18  Dorit Nuzman  <dorit@il.ibm.com>\n+\n+\t* tree-vect-analyze.c (process_use): New function.\n+\t(vect_mark_stmts_to_be_vectorized): Factor out code to process_use.\n+\tCheck phis in all bbs.\n+\t* tree-vectorizer.c (vect_is_simple_use): Remove a no longer relavant\n+\tassert.\n+\n 2007-04-18  Bernd Schmidt  <bernd.schmidt@analog.com>\n \n \t* reload1.c (eliminte_regs_in_insn): Use REG_EQUIV notes the same way"}, {"sha": "ea28a2c145f33a86e0431b51109380fb56adcee7", "filename": "gcc/tree-vect-analyze.c", "status": "modified", "additions": 127, "deletions": 72, "changes": 199, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cf81ddffd26ef1262e2d93f7232d72b92cd72be/gcc%2Ftree-vect-analyze.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cf81ddffd26ef1262e2d93f7232d72b92cd72be/gcc%2Ftree-vect-analyze.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-analyze.c?ref=8cf81ddffd26ef1262e2d93f7232d72b92cd72be", "patch": "@@ -2191,6 +2191,81 @@ vect_stmt_relevant_p (tree stmt, loop_vec_info loop_vinfo,\n }\n \n \n+/* \n+   Function process_use.\n+\n+   Inputs:\n+   - a USE in STMT in a loop represented by LOOP_VINFO\n+   - LIVE_P, RELEVANT - enum values to be set in the STMT_VINFO of the stmt \n+     that defined USE. This is dont by calling mark_relevant and passing it\n+     the WORKLIST (to add DEF_STMT to the WORKlist in case itis relevant). \n+\n+   Outputs:\n+   Generally, LIVE_P and RELEVANT are used to define the liveness and\n+   relevance info of the DEF_STMT of this USE:\n+       STMT_VINFO_LIVE_P (DEF_STMT_info) <-- live_p\n+       STMT_VINFO_RELEVANT (DEF_STMT_info) <-- relevant\n+   Exceptions:\n+   - case 1: If USE is used only for address computations (e.g. array indexing),\n+   which does not need to be directly vectorized, then the liveness/relevance \n+   of the respective DEF_STMT is left unchanged.\n+   - case 2: If STMT is a reduction phi and DEF_STMT is a reduction stmt, we \n+   skip DEF_STMT cause it had already been processed.  \n+\n+   Return true if everyting is as expected. Return false otherwise.  */\n+\n+static bool\n+process_use (tree stmt, tree use, loop_vec_info loop_vinfo, bool live_p, \n+\t     enum vect_relevant relevant, VEC(tree,heap) **worklist)\n+{\n+  struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n+  stmt_vec_info stmt_vinfo = vinfo_for_stmt (stmt);\n+  stmt_vec_info dstmt_vinfo;\n+  basic_block def_bb;\n+  tree def, def_stmt;\n+  enum vect_def_type dt;\n+\n+  /* case 1: we are only interested in uses that need to be vectorized.  Uses \n+     that are used for address computation are not considered relevant.  */\n+  if (!exist_non_indexing_operands_for_use_p (use, stmt))\n+     return true;\n+\n+  if (!vect_is_simple_use (use, loop_vinfo, &def_stmt, &def, &dt))\n+    { \n+      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS))\n+        fprintf (vect_dump, \"not vectorized: unsupported use in stmt.\");\n+      return false;\n+    }\n+\n+  if (!def_stmt || IS_EMPTY_STMT (def_stmt))\n+    return true;\n+\n+  def_bb = bb_for_stmt (def_stmt);\n+  if (!flow_bb_inside_loop_p (loop, def_bb))\n+    return true;\n+\n+  /* case 2: A reduction phi defining a reduction stmt (DEF_STMT). DEF_STMT \n+     must have already been processed, so we just check that everything is as \n+     expected, and we are done.  */\n+  dstmt_vinfo = vinfo_for_stmt (def_stmt);\n+  if (TREE_CODE (stmt) == PHI_NODE\n+      && STMT_VINFO_DEF_TYPE (stmt_vinfo) == vect_reduction_def\n+      && TREE_CODE (def_stmt) != PHI_NODE\n+      && STMT_VINFO_DEF_TYPE (dstmt_vinfo) == vect_reduction_def)\n+    {\n+      if (STMT_VINFO_IN_PATTERN_P (dstmt_vinfo))\n+\tdstmt_vinfo = vinfo_for_stmt (STMT_VINFO_RELATED_STMT (dstmt_vinfo));\n+      gcc_assert (STMT_VINFO_RELEVANT (dstmt_vinfo) < vect_used_by_reduction);\n+      gcc_assert (STMT_VINFO_LIVE_P (dstmt_vinfo) \n+\t\t  || STMT_VINFO_RELEVANT (dstmt_vinfo) > vect_unused_in_loop);\n+      return true;\n+    }\n+\n+  vect_mark_relevant (worklist, def_stmt, relevant, live_p);\n+  return true;\n+}\n+\n+\n /* Function vect_mark_stmts_to_be_vectorized.\n \n    Not all stmts in the loop need to be vectorized. For example:\n@@ -2215,17 +2290,14 @@ vect_mark_stmts_to_be_vectorized (loop_vec_info loop_vinfo)\n   basic_block *bbs = LOOP_VINFO_BBS (loop_vinfo);\n   unsigned int nbbs = loop->num_nodes;\n   block_stmt_iterator si;\n-  tree stmt, use;\n+  tree stmt;\n   stmt_ann_t ann;\n-  ssa_op_iter iter;\n   unsigned int i;\n   stmt_vec_info stmt_vinfo;\n   basic_block bb;\n   tree phi;\n   bool live_p;\n   enum vect_relevant relevant;\n-  tree def, def_stmt;\n-  enum vect_def_type dt;\n \n   if (vect_print_dump_info (REPORT_DETAILS))\n     fprintf (vect_dump, \"=== vect_mark_stmts_to_be_vectorized ===\");\n@@ -2261,99 +2333,82 @@ vect_mark_stmts_to_be_vectorized (loop_vec_info loop_vinfo)\n \t}\n     }\n \n-\n   /* 2. Process_worklist */\n-\n   while (VEC_length (tree, worklist) > 0)\n     {\n-      stmt = VEC_pop (tree, worklist);\n+      use_operand_p use_p;\n+      ssa_op_iter iter;\n \n+      stmt = VEC_pop (tree, worklist);\n       if (vect_print_dump_info (REPORT_DETAILS))\n \t{\n           fprintf (vect_dump, \"worklist: examine stmt: \");\n           print_generic_expr (vect_dump, stmt, TDF_SLIM);\n \t}\n \n-      /* Examine the USEs of STMT. For each ssa-name USE that is defined\n-         in the loop, mark the stmt that defines it (DEF_STMT) as\n-         relevant/irrelevant and live/dead according to the liveness and\n-         relevance properties of STMT.\n-       */\n-\n+      /* Examine the USEs of STMT. For each USE, mark the stmt that defines it \n+\t (DEF_STMT) as relevant/irrelevant and live/dead according to the \n+\t liveness and relevance properties of STMT.  */\n       ann = stmt_ann (stmt);\n       stmt_vinfo = vinfo_for_stmt (stmt);\n-\n       relevant = STMT_VINFO_RELEVANT (stmt_vinfo);\n       live_p = STMT_VINFO_LIVE_P (stmt_vinfo);\n \n       /* Generally, the liveness and relevance properties of STMT are\n-         propagated to the DEF_STMTs of its USEs:\n-             STMT_VINFO_LIVE_P (DEF_STMT_info) <-- live_p\n-             STMT_VINFO_RELEVANT (DEF_STMT_info) <-- relevant\n-\n-         Exceptions:\n-\n-\t (case 1)\n-           If USE is used only for address computations (e.g. array indexing),\n-           which does not need to be directly vectorized, then the\n-           liveness/relevance of the respective DEF_STMT is left unchanged.\n-\n-\t (case 2)\n-           If STMT has been identified as defining a reduction variable, then\n-           we want to set liveness/relevance as follows:\n-               STMT_VINFO_LIVE_P (DEF_STMT_info) <-- false\n-               STMT_VINFO_RELEVANT (DEF_STMT_info) <-- vect_used_by_reduction\n-             because even though STMT is classified as live (since it defines a\n-             value that is used across loop iterations) and irrelevant (since it\n-             is not used inside the loop), it will be vectorized, and therefore\n-             the corresponding DEF_STMTs need to marked as relevant.\n-\t     We distinguish between two kinds of relevant stmts - those that are\n-\t     used by a reduction computation, and those that are (also) used by\n- \t     a regular computation. This allows us later on to identify stmts\n-\t     that are used solely by a reduction, and therefore the order of \n-\t     the results that they produce does not have to be kept.\n-       */\n-\n-      /* case 2.2:  */\n+\t propagated as is to the DEF_STMTs of its USEs:\n+\t  live_p <-- STMT_VINFO_LIVE_P (STMT_VINFO)\n+\t  relevant <-- STMT_VINFO_RELEVANT (STMT_VINFO)\n+\n+\t One exception is when STMT has been identified as defining a reduction\n+\t variable; in this case we set the liveness/relevance as follows:\n+\t   live_p = false\n+\t   relevant = vect_used_by_reduction\n+\t This is because we distinguish between two kinds of relevant stmts -\n+\t those that are used by a reduction computation, and those that are \n+\t (also) used by a regular computation. This allows us later on to \n+\t identify stmts that are used solely by a reduction, and therefore the \n+\t order of the results that they produce does not have to be kept.\n+\n+         Reduction phis are expected to be used by a reduction stmt;  Other \n+\t reduction stmts are expected to be unused in the loop.  These are the \n+\t expected values of \"relevant\" for reduction phis/stmts in the loop:\n+\n+\t relevance:\t\t\t\tphi\tstmt\n+\t vect_unused_in_loop\t\t\t\tok\n+\t vect_used_by_reduction\t\t\tok\n+\t vect_used_in_loop \t\t\t\t\t\t  */\n+\n       if (STMT_VINFO_DEF_TYPE (stmt_vinfo) == vect_reduction_def)\n-\t{\n+        {\n+\t  switch (relevant)\n+\t    {\n+\t    case vect_unused_in_loop:\n+\t      gcc_assert (TREE_CODE (stmt) != PHI_NODE);\n+\t      break;\n+\t    case vect_used_by_reduction:\n+\t      if (TREE_CODE (stmt) == PHI_NODE)\n+\t\tbreak;\n+\t    case vect_used_in_loop:\n+\t    default:\n+\t      if (vect_print_dump_info (REPORT_DETAILS))\n+\t        fprintf (vect_dump, \"unsupported use of reduction.\");\n+\t      VEC_free (tree, heap, worklist);\n+\t      return false;\n+\t    }\n \t  relevant = vect_used_by_reduction;\n-\t  live_p = false;\n+\t  live_p = false;\t\n \t}\n \n-      i = 0;\n-      FOR_EACH_SSA_TREE_OPERAND (use, stmt, iter, SSA_OP_USE)\n+      FOR_EACH_PHI_OR_STMT_USE (use_p, stmt, iter, SSA_OP_USE)\n \t{\n-\t  if (vect_print_dump_info (REPORT_DETAILS))\n+\t  tree op = USE_FROM_PTR (use_p);\n+\t  if (!process_use (stmt, op, loop_vinfo, live_p, relevant, &worklist))\n \t    {\n-\t      fprintf (vect_dump, \"worklist: examine use %d: \", i++);\n-\t      print_generic_expr (vect_dump, use, TDF_SLIM);\n-\t    }\n-\n-\t  /* case 1: we are only interested in uses that need to be vectorized. \n-\t     Uses that are used for address computation are not considered \n-\t     relevant.\n-\t   */\n-\t  if (!exist_non_indexing_operands_for_use_p (use, stmt))\n-\t    continue;\n-\n-\t  if (!vect_is_simple_use (use, loop_vinfo, &def_stmt, &def, &dt))\n-\t    {\n-\t      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS))\n-\t\tfprintf (vect_dump, \"not vectorized: unsupported use in stmt.\");\n \t      VEC_free (tree, heap, worklist);\n \t      return false;\n-            }\n-\n-\t  if (!def_stmt || IS_EMPTY_STMT (def_stmt))\n-\t    continue;\n-\n-\t  bb = bb_for_stmt (def_stmt);\n-\t  if (!flow_bb_inside_loop_p (loop, bb))\n-\t    continue;\n-\t  vect_mark_relevant (&worklist, def_stmt, relevant, live_p);\n+\t    }\n \t}\n-    }\t\t\t\t/* while worklist */\n+    } /* while worklist */\n \n   VEC_free (tree, heap, worklist);\n   return true;"}, {"sha": "212b584991fb53992e9cbf0947a44cf7e48c4bee", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 1, "deletions": 11, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cf81ddffd26ef1262e2d93f7232d72b92cd72be/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cf81ddffd26ef1262e2d93f7232d72b92cd72be/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=8cf81ddffd26ef1262e2d93f7232d72b92cd72be", "patch": "@@ -1714,15 +1714,6 @@ vect_is_simple_use (tree operand, loop_vec_info loop_vinfo, tree *def_stmt,\n       return false;\n     }\n \n-  /* stmts inside the loop that have been identified as performing\n-     a reduction operation cannot have uses in the loop.  */\n-  if (*dt == vect_reduction_def && TREE_CODE (*def_stmt) != PHI_NODE)\n-    {\n-      if (vect_print_dump_info (REPORT_DETAILS))\n-        fprintf (vect_dump, \"reduction used in loop.\");\n-      return false;\n-    }\n-\n   if (vect_print_dump_info (REPORT_DETAILS))\n     fprintf (vect_dump, \"type of def: %d.\",*dt);\n \n@@ -1731,12 +1722,11 @@ vect_is_simple_use (tree operand, loop_vec_info loop_vinfo, tree *def_stmt,\n     case PHI_NODE:\n       *def = PHI_RESULT (*def_stmt);\n       gcc_assert (*dt == vect_induction_def || *dt == vect_reduction_def\n-                  || *dt == vect_invariant_def);\n+\t\t  || *dt == vect_invariant_def);\n       break;\n \n     case GIMPLE_MODIFY_STMT:\n       *def = GIMPLE_STMT_OPERAND (*def_stmt, 0);\n-      gcc_assert (*dt == vect_loop_def || *dt == vect_invariant_def);\n       break;\n \n     default:"}]}