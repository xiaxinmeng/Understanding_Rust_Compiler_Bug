{"sha": "d2b9548f38c77edc29ab0e24e516f1fb341ecea7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDJiOTU0OGYzOGM3N2VkYzI5YWIwZTI0ZTUxNmYxZmIzNDFlY2VhNw==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2020-01-30T23:49:29Z"}, "committer": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2020-01-31T23:19:31Z"}, "message": "c++: Reduce memory consumption for large static arrays.\n\nPR14179 and the C counterpart PR12245 are about memory consumption of very\nlarge file-scope arrays.  Recently, location wrappers increased memory\nconsumption significantly: in an array of integer constants, each one will\nhave a location wrapper, which added up to over 500MB in the 14179\ntestcase.  For this kind of testcase tracking these locations isn't worth\nthe cost, so this patch turns the wrappers off after 256 elements; any array\nthat size or larger isn't likely to be interested in the location of\nindividual integer constants.\n\n\tPR c++/14179\n\t* parser.c (cp_parser_initializer_list): Suppress location wrappers\n\tafter 256 elements.", "tree": {"sha": "37078747238504a649c820bb088f9f5d14890ce9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/37078747238504a649c820bb088f9f5d14890ce9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d2b9548f38c77edc29ab0e24e516f1fb341ecea7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d2b9548f38c77edc29ab0e24e516f1fb341ecea7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d2b9548f38c77edc29ab0e24e516f1fb341ecea7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d2b9548f38c77edc29ab0e24e516f1fb341ecea7/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6775172431a8e6f0d20ac0c4946d6b5db2f46450", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6775172431a8e6f0d20ac0c4946d6b5db2f46450", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6775172431a8e6f0d20ac0c4946d6b5db2f46450"}], "stats": {"total": 24, "additions": 24, "deletions": 0}, "files": [{"sha": "f8140885dab408e680d8802cdddfc3fe84711aa0", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2b9548f38c77edc29ab0e24e516f1fb341ecea7/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2b9548f38c77edc29ab0e24e516f1fb341ecea7/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=d2b9548f38c77edc29ab0e24e516f1fb341ecea7", "patch": "@@ -1,3 +1,9 @@\n+2020-01-31  Jason Merrill  <jason@redhat.com>\n+\n+\tPR c++/14179\n+\t* parser.c (cp_parser_initializer_list): Suppress location wrappers\n+\tafter 256 elements.\n+\n 2020-01-29  Jason Merrill  <jason@redhat.com>\n \n \tPR c++/82521"}, {"sha": "e0f72302e5e0f4b0033b71c000314327c16206d6", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2b9548f38c77edc29ab0e24e516f1fb341ecea7/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2b9548f38c77edc29ab0e24e516f1fb341ecea7/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=d2b9548f38c77edc29ab0e24e516f1fb341ecea7", "patch": "@@ -23311,6 +23311,9 @@ cp_parser_initializer_list (cp_parser* parser, bool* non_constant_p,\n   /* Assume all of the expressions are constant.  */\n   *non_constant_p = false;\n \n+  unsigned nelts = 0;\n+  int suppress = suppress_location_wrappers;\n+\n   /* Parse the rest of the list.  */\n   while (true)\n     {\n@@ -23450,6 +23453,19 @@ cp_parser_initializer_list (cp_parser* parser, bool* non_constant_p,\n       if (token->type == CPP_CLOSE_BRACE)\n \tbreak;\n \n+      /* Suppress location wrappers in a long initializer to save memory\n+\t (14179).  The cutoff is chosen arbitrarily.  */\n+      const unsigned loc_max = 256;\n+      unsigned incr = 1;\n+      if (TREE_CODE (initializer) == CONSTRUCTOR)\n+\t/* Look one level down because it's easy.  Looking deeper would require\n+\t   passing down a nelts pointer, and I don't think multi-level massive\n+\t   initializers are common enough to justify this.  */\n+\tincr = CONSTRUCTOR_NELTS (initializer);\n+      nelts += incr;\n+      if (nelts >= loc_max && (nelts - incr) < loc_max)\n+\t++suppress_location_wrappers;\n+\n       /* Consume the `,' token.  */\n       cp_lexer_consume_token (parser->lexer);\n     }\n@@ -23479,6 +23495,8 @@ cp_parser_initializer_list (cp_parser* parser, bool* non_constant_p,\n \t  IDENTIFIER_MARKED (designator) = 0;\n     }\n \n+  suppress_location_wrappers = suppress;\n+\n   *designated = first_designator != NULL_TREE;\n   return v;\n }"}]}