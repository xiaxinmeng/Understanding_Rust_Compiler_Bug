{"sha": "705037247447f44826bd6fc2c777c69237fcef39", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzA1MDM3MjQ3NDQ3ZjQ0ODI2YmQ2ZmMyYzc3N2M2OTIzN2ZjZWYzOQ==", "commit": {"author": {"name": "Tim Shen", "email": "timshen@google.com", "date": "2017-06-27T18:19:03Z"}, "committer": {"name": "Tim Shen", "email": "timshen@gcc.gnu.org", "date": "2017-06-27T18:19:03Z"}, "message": "re PR libstdc++/80187 (C++ variant should be trivially copy constructible if possible)\n\n\tPR libstdc++/80187\n\t* include/std/variant (variant::variant, variant::~variant,\n\tvariant::operator=): Implement triviality forwarding for four\n\tspecial member functions.\n\t* testsuite/20_util/variant/compile.cc: Tests.\n\nFrom-SVN: r249706", "tree": {"sha": "8f01a51301ae0f61f8a6e5ea3442568da419df6f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8f01a51301ae0f61f8a6e5ea3442568da419df6f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/705037247447f44826bd6fc2c777c69237fcef39", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/705037247447f44826bd6fc2c777c69237fcef39", "html_url": "https://github.com/Rust-GCC/gccrs/commit/705037247447f44826bd6fc2c777c69237fcef39", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/705037247447f44826bd6fc2c777c69237fcef39/comments", "author": {"login": "timshen91", "id": 1157432, "node_id": "MDQ6VXNlcjExNTc0MzI=", "avatar_url": "https://avatars.githubusercontent.com/u/1157432?v=4", "gravatar_id": "", "url": "https://api.github.com/users/timshen91", "html_url": "https://github.com/timshen91", "followers_url": "https://api.github.com/users/timshen91/followers", "following_url": "https://api.github.com/users/timshen91/following{/other_user}", "gists_url": "https://api.github.com/users/timshen91/gists{/gist_id}", "starred_url": "https://api.github.com/users/timshen91/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/timshen91/subscriptions", "organizations_url": "https://api.github.com/users/timshen91/orgs", "repos_url": "https://api.github.com/users/timshen91/repos", "events_url": "https://api.github.com/users/timshen91/events{/privacy}", "received_events_url": "https://api.github.com/users/timshen91/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8c2805bbbb937cbce2c86fac1146515d6aee81e4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c2805bbbb937cbce2c86fac1146515d6aee81e4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8c2805bbbb937cbce2c86fac1146515d6aee81e4"}], "stats": {"total": 423, "additions": 341, "deletions": 82}, "files": [{"sha": "770b5789da7355e353162167d646048059021b99", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/705037247447f44826bd6fc2c777c69237fcef39/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/705037247447f44826bd6fc2c777c69237fcef39/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=705037247447f44826bd6fc2c777c69237fcef39", "patch": "@@ -1,3 +1,11 @@\n+2017-06-27  Tim Shen  <timshen@google.com>\n+\n+\tPR libstdc++/80187\n+\t* include/std/variant (variant::variant, variant::~variant,\n+\tvariant::operator=): Implement triviality forwarding for four\n+\tspecial member functions.\n+\t* testsuite/20_util/variant/compile.cc: Tests.\n+\n 2017-06-27  Jonathan Wakely  <jwakely@redhat.com>\n \n \tPR libstdc++/81221"}, {"sha": "06646f6b7986fb2b36c1654f81b470d6543cd48d", "filename": "libstdc++-v3/include/std/variant", "status": "modified", "additions": 233, "deletions": 79, "changes": 312, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/705037247447f44826bd6fc2c777c69237fcef39/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fvariant", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/705037247447f44826bd6fc2c777c69237fcef39/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fvariant", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fvariant?ref=705037247447f44826bd6fc2c777c69237fcef39", "patch": "@@ -295,6 +295,46 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t  __variant::__ref_cast<_Tp>(__t));\n     }\n \n+  template<typename... _Types>\n+    struct _Traits\n+    {\n+      static constexpr bool _S_default_ctor =\n+          is_default_constructible_v<typename _Nth_type<0, _Types...>::type>;\n+      static constexpr bool _S_copy_ctor =\n+          (is_copy_constructible_v<_Types> && ...);\n+      static constexpr bool _S_move_ctor =\n+          (is_move_constructible_v<_Types> && ...);\n+      static constexpr bool _S_copy_assign =\n+          _S_copy_ctor && _S_move_ctor\n+          && (is_copy_assignable_v<_Types> && ...);\n+      static constexpr bool _S_move_assign =\n+          _S_move_ctor\n+          && (is_move_assignable_v<_Types> && ...);\n+\n+      static constexpr bool _S_trivial_dtor =\n+          (is_trivially_destructible_v<_Types> && ...);\n+      static constexpr bool _S_trivial_copy_ctor =\n+          (is_trivially_copy_constructible_v<_Types> && ...);\n+      static constexpr bool _S_trivial_move_ctor =\n+          (is_trivially_move_constructible_v<_Types> && ...);\n+      static constexpr bool _S_trivial_copy_assign =\n+          _S_trivial_dtor && (is_trivially_copy_assignable_v<_Types> && ...);\n+      static constexpr bool _S_trivial_move_assign =\n+          _S_trivial_dtor && (is_trivially_move_assignable_v<_Types> && ...);\n+\n+      // The following nothrow traits are for non-trivial SMFs. Trivial SMFs\n+      // are always nothrow.\n+      static constexpr bool _S_nothrow_default_ctor =\n+          is_nothrow_default_constructible_v<\n+              typename _Nth_type<0, _Types...>::type>;\n+      static constexpr bool _S_nothrow_copy_ctor = false;\n+      static constexpr bool _S_nothrow_move_ctor =\n+          (is_nothrow_move_constructible_v<_Types> && ...);\n+      static constexpr bool _S_nothrow_copy_assign = false;\n+      static constexpr bool _S_nothrow_move_assign =\n+          _S_nothrow_move_ctor && (is_nothrow_move_assignable_v<_Types> && ...);\n+    };\n+\n   // Defines members and ctors.\n   template<typename... _Types>\n     union _Variadic_union { };\n@@ -360,6 +400,19 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       ~_Variant_storage()\n       { _M_reset(); }\n \n+      void*\n+      _M_storage() const\n+      {\n+\treturn const_cast<void*>(static_cast<const void*>(\n+\t    std::addressof(_M_u)));\n+      }\n+\n+      constexpr bool\n+      _M_valid() const noexcept\n+      {\n+\treturn this->_M_index != __index_type(variant_npos);\n+      }\n+\n       _Variadic_union<_Types...> _M_u;\n       using __index_type = __select_index<_Types...>;\n       __index_type _M_index;\n@@ -379,76 +432,125 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       void _M_reset()\n       { _M_index = variant_npos; }\n \n+      void*\n+      _M_storage() const\n+      {\n+\treturn const_cast<void*>(static_cast<const void*>(\n+\t    std::addressof(_M_u)));\n+      }\n+\n+      constexpr bool\n+      _M_valid() const noexcept\n+      {\n+\treturn this->_M_index != __index_type(variant_npos);\n+      }\n+\n       _Variadic_union<_Types...> _M_u;\n       using __index_type = __select_index<_Types...>;\n       __index_type _M_index;\n     };\n \n-  // Helps SFINAE on special member functions. Otherwise it can live in variant\n-  // class.\n   template<typename... _Types>\n-    struct _Variant_base :\n-      _Variant_storage<(std::is_trivially_destructible_v<_Types> && ...),\n-\t\t\t_Types...>\n-    {\n-      using _Storage =\n-\t  _Variant_storage<(std::is_trivially_destructible_v<_Types> && ...),\n-\t\t\t    _Types...>;\n+    using _Variant_storage_alias =\n+        _Variant_storage<_Traits<_Types...>::_S_trivial_dtor, _Types...>;\n \n-      constexpr\n-      _Variant_base()\n-      noexcept(is_nothrow_default_constructible_v<\n-\t\t variant_alternative_t<0, variant<_Types...>>>)\n-      : _Variant_base(in_place_index<0>) { }\n+  // The following are (Copy|Move) (ctor|assign) layers for forwarding\n+  // triviality and handling non-trivial SMF behaviors.\n+\n+  template<bool, typename... _Types>\n+    struct _Copy_ctor_base : _Variant_storage_alias<_Types...>\n+    {\n+      using _Base = _Variant_storage_alias<_Types...>;\n+      using _Base::_Base;\n \n-      _Variant_base(const _Variant_base& __rhs)\n+      _Copy_ctor_base(const _Copy_ctor_base& __rhs)\n+          noexcept(_Traits<_Types...>::_S_nothrow_copy_ctor)\n       {\n \tif (__rhs._M_valid())\n \t  {\n \t    static constexpr void (*_S_vtable[])(void*, void*) =\n \t      { &__erased_ctor<_Types&, const _Types&>... };\n-\t    _S_vtable[__rhs._M_index](_M_storage(), __rhs._M_storage());\n+\t    _S_vtable[__rhs._M_index](this->_M_storage(), __rhs._M_storage());\n \t    this->_M_index = __rhs._M_index;\n \t  }\n       }\n \n-      _Variant_base(_Variant_base&& __rhs)\n-      noexcept((is_nothrow_move_constructible_v<_Types> && ...))\n+      _Copy_ctor_base(_Copy_ctor_base&&) = default;\n+      _Copy_ctor_base& operator=(const _Copy_ctor_base&) = default;\n+      _Copy_ctor_base& operator=(_Copy_ctor_base&&) = default;\n+    };\n+\n+  template<typename... _Types>\n+    struct _Copy_ctor_base<true, _Types...> : _Variant_storage_alias<_Types...>\n+    {\n+      using _Base = _Variant_storage_alias<_Types...>;\n+      using _Base::_Base;\n+    };\n+\n+  template<typename... _Types>\n+    using _Copy_ctor_alias =\n+        _Copy_ctor_base<_Traits<_Types...>::_S_trivial_copy_ctor, _Types...>;\n+\n+  template<bool, typename... _Types>\n+    struct _Move_ctor_base : _Copy_ctor_alias<_Types...>\n+    {\n+      using _Base = _Copy_ctor_alias<_Types...>;\n+      using _Base::_Base;\n+\n+      _Move_ctor_base(_Move_ctor_base&& __rhs)\n+          noexcept(_Traits<_Types...>::_S_nothrow_move_ctor)\n       {\n \tif (__rhs._M_valid())\n \t  {\n \t    static constexpr void (*_S_vtable[])(void*, void*) =\n \t      { &__erased_ctor<_Types&, _Types&&>... };\n-\t    _S_vtable[__rhs._M_index](_M_storage(), __rhs._M_storage());\n+\t    _S_vtable[__rhs._M_index](this->_M_storage(), __rhs._M_storage());\n \t    this->_M_index = __rhs._M_index;\n \t  }\n       }\n \n-      template<size_t _Np, typename... _Args>\n-\tconstexpr explicit\n-\t_Variant_base(in_place_index_t<_Np> __i, _Args&&... __args)\n-\t: _Storage(__i, std::forward<_Args>(__args)...)\n-\t{ }\n+      _Move_ctor_base(const _Move_ctor_base&) = default;\n+      _Move_ctor_base& operator=(const _Move_ctor_base&) = default;\n+      _Move_ctor_base& operator=(_Move_ctor_base&&) = default;\n+    };\n+\n+  template<typename... _Types>\n+    struct _Move_ctor_base<true, _Types...> : _Copy_ctor_alias<_Types...>\n+    {\n+      using _Base = _Copy_ctor_alias<_Types...>;\n+      using _Base::_Base;\n+    };\n+\n+  template<typename... _Types>\n+    using _Move_ctor_alias =\n+        _Move_ctor_base<_Traits<_Types...>::_S_trivial_move_ctor, _Types...>;\n+\n+  template<bool, typename... _Types>\n+    struct _Copy_assign_base : _Move_ctor_alias<_Types...>\n+    {\n+      using _Base = _Move_ctor_alias<_Types...>;\n+      using _Base::_Base;\n \n-      _Variant_base&\n-      operator=(const _Variant_base& __rhs)\n+      _Copy_assign_base&\n+      operator=(const _Copy_assign_base& __rhs)\n+          noexcept(_Traits<_Types...>::_S_nothrow_copy_assign)\n       {\n \tif (this->_M_index == __rhs._M_index)\n \t  {\n \t    if (__rhs._M_valid())\n \t      {\n \t\tstatic constexpr void (*_S_vtable[])(void*, void*) =\n \t\t  { &__erased_assign<_Types&, const _Types&>... };\n-\t\t_S_vtable[__rhs._M_index](_M_storage(), __rhs._M_storage());\n+\t\t_S_vtable[__rhs._M_index](this->_M_storage(), __rhs._M_storage());\n \t      }\n \t  }\n \telse\n \t  {\n-\t    _Variant_base __tmp(__rhs);\n-\t    this->~_Variant_base();\n+\t    _Copy_assign_base __tmp(__rhs);\n+\t    this->~_Copy_assign_base();\n \t    __try\n \t      {\n-\t\t::new (this) _Variant_base(std::move(__tmp));\n+\t\t::new (this) _Copy_assign_base(std::move(__tmp));\n \t      }\n \t    __catch (...)\n \t      {\n@@ -460,12 +562,35 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \treturn *this;\n       }\n \n-      void _M_destructive_move(_Variant_base&& __rhs)\n+      _Copy_assign_base(const _Copy_assign_base&) = default;\n+      _Copy_assign_base(_Copy_assign_base&&) = default;\n+      _Copy_assign_base& operator=(_Copy_assign_base&&) = default;\n+    };\n+\n+  template<typename... _Types>\n+    struct _Copy_assign_base<true, _Types...> : _Move_ctor_alias<_Types...>\n+    {\n+      using _Base = _Move_ctor_alias<_Types...>;\n+      using _Base::_Base;\n+    };\n+\n+  template<typename... _Types>\n+    using _Copy_assign_alias =\n+        _Copy_assign_base<_Traits<_Types...>::_S_trivial_copy_assign,\n+                          _Types...>;\n+\n+  template<bool, typename... _Types>\n+    struct _Move_assign_base : _Copy_assign_alias<_Types...>\n+    {\n+      using _Base = _Copy_assign_alias<_Types...>;\n+      using _Base::_Base;\n+\n+      void _M_destructive_move(_Move_assign_base&& __rhs)\n       {\n-\tthis->~_Variant_base();\n+\tthis->~_Move_assign_base();\n \t__try\n \t  {\n-\t    ::new (this) _Variant_base(std::move(__rhs));\n+\t    ::new (this) _Move_assign_base(std::move(__rhs));\n \t  }\n \t__catch (...)\n \t  {\n@@ -474,40 +599,74 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t  }\n       }\n \n-      _Variant_base&\n-      operator=(_Variant_base&& __rhs)\n-      noexcept((is_nothrow_move_constructible_v<_Types> && ...)\n-\t  && (is_nothrow_move_assignable_v<_Types> && ...))\n+      _Move_assign_base&\n+      operator=(_Move_assign_base&& __rhs)\n+          noexcept(_Traits<_Types...>::_S_nothrow_move_assign)\n       {\n \tif (this->_M_index == __rhs._M_index)\n \t  {\n \t    if (__rhs._M_valid())\n \t      {\n \t\tstatic constexpr void (*_S_vtable[])(void*, void*) =\n-\t\t  { &__erased_assign<_Types&, _Types&&>... };\n-\t\t_S_vtable[__rhs._M_index](_M_storage(), __rhs._M_storage());\n+\t\t  { &__erased_assign<_Types&, const _Types&>... };\n+\t\t_S_vtable[__rhs._M_index](this->_M_storage(), __rhs._M_storage());\n \t      }\n \t  }\n \telse\n \t  {\n-\t    _M_destructive_move(std::move(__rhs));\n+\t    _Move_assign_base __tmp(__rhs);\n+\t    this->~_Move_assign_base();\n+\t    __try\n+\t      {\n+\t\t::new (this) _Move_assign_base(std::move(__tmp));\n+\t      }\n+\t    __catch (...)\n+\t      {\n+\t\tthis->_M_index = variant_npos;\n+\t\t__throw_exception_again;\n+\t      }\n \t  }\n+\t__glibcxx_assert(this->_M_index == __rhs._M_index);\n \treturn *this;\n       }\n \n-      void*\n-      _M_storage() const\n-      {\n-\treturn const_cast<void*>(static_cast<const void*>(\n-\t    std::addressof(_Storage::_M_u)));\n-      }\n+      _Move_assign_base(const _Move_assign_base&) = default;\n+      _Move_assign_base(_Move_assign_base&&) = default;\n+      _Move_assign_base& operator=(const _Move_assign_base&) = default;\n+    };\n \n-      constexpr bool\n-      _M_valid() const noexcept\n-      {\n-\treturn this->_M_index !=\n-\t  typename _Storage::__index_type(variant_npos);\n-      }\n+  template<typename... _Types>\n+    struct _Move_assign_base<true, _Types...> : _Copy_assign_alias<_Types...>\n+    {\n+      using _Base = _Copy_assign_alias<_Types...>;\n+      using _Base::_Base;\n+    };\n+\n+  template<typename... _Types>\n+    using _Move_assign_alias =\n+        _Move_assign_base<_Traits<_Types...>::_S_trivial_move_assign,\n+                          _Types...>;\n+\n+  template<typename... _Types>\n+    struct _Variant_base : _Move_assign_alias<_Types...>\n+    {\n+      using _Base = _Move_assign_alias<_Types...>;\n+\n+      constexpr\n+      _Variant_base()\n+          noexcept(_Traits<_Types...>::_S_nothrow_default_ctor)\n+      : _Variant_base(in_place_index<0>) { }\n+\n+      template<size_t _Np, typename... _Args>\n+\tconstexpr explicit\n+\t_Variant_base(in_place_index_t<_Np> __i, _Args&&... __args)\n+\t: _Base(__i, std::forward<_Args>(__args)...)\n+\t{ }\n+\n+      _Variant_base(const _Variant_base&) = default;\n+      _Variant_base(_Variant_base&&) = default;\n+      _Variant_base& operator=(const _Variant_base&) = default;\n+      _Variant_base& operator=(_Variant_base&&) = default;\n     };\n \n   // For how many times does _Tp appear in _Tuple?\n@@ -882,16 +1041,13 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     class variant\n     : private __detail::__variant::_Variant_base<_Types...>,\n       private _Enable_default_constructor<\n-\tis_default_constructible_v<\n-\t  variant_alternative_t<0, variant<_Types...>>>, variant<_Types...>>,\n+        __detail::__variant::_Traits<_Types...>::_S_default_ctor,\n+\t  variant<_Types...>>,\n       private _Enable_copy_move<\n-\t(is_copy_constructible_v<_Types> && ...),\n-\t(is_copy_constructible_v<_Types> && ...)\n-\t     && (is_move_constructible_v<_Types> && ...)\n-\t     && (is_copy_assignable_v<_Types> && ...),\n-\t(is_move_constructible_v<_Types> && ...),\n-\t(is_move_constructible_v<_Types> && ...)\n-\t     && (is_move_assignable_v<_Types> && ...),\n+        __detail::__variant::_Traits<_Types...>::_S_copy_ctor,\n+        __detail::__variant::_Traits<_Types...>::_S_copy_assign,\n+        __detail::__variant::_Traits<_Types...>::_S_move_ctor,\n+        __detail::__variant::_Traits<_Types...>::_S_move_assign,\n \tvariant<_Types...>>\n     {\n     private:\n@@ -904,9 +1060,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n       using _Base = __detail::__variant::_Variant_base<_Types...>;\n       using _Default_ctor_enabler =\n-\t_Enable_default_constructor<\n-\t  is_default_constructible_v<\n-\t    variant_alternative_t<0, variant<_Types...>>>, variant<_Types...>>;\n+        _Enable_default_constructor<\n+          __detail::__variant::_Traits<_Types...>::_S_default_ctor,\n+            variant<_Types...>>;\n \n       template<typename _Tp>\n \tstatic constexpr bool\n@@ -933,12 +1089,15 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \tstatic constexpr size_t __index_of =\n \t  __detail::__variant::__index_of_v<_Tp, _Types...>;\n \n+      using _Traits = __detail::__variant::_Traits<_Types...>;\n+\n     public:\n-      constexpr variant()\n-      noexcept(is_nothrow_default_constructible_v<__to_type<0>>) = default;\n-      variant(const variant&) = default;\n-      variant(variant&&)\n-      noexcept((is_nothrow_move_constructible_v<_Types> && ...)) = default;\n+      variant() = default;\n+      variant(const variant& __rhs) = default;\n+      variant(variant&&) = default;\n+      variant& operator=(const variant&) = default;\n+      variant& operator=(variant&&) = default;\n+      ~variant() = default;\n \n       template<typename _Tp,\n \t       typename = enable_if_t<!is_same_v<decay_t<_Tp>, variant>>,\n@@ -947,15 +1106,17 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \tconstexpr\n \tvariant(_Tp&& __t)\n \tnoexcept(is_nothrow_constructible_v<__accepted_type<_Tp&&>, _Tp&&>)\n-\t: variant(in_place_index<__accepted_index<_Tp&&>>, std::forward<_Tp>(__t))\n+\t: variant(in_place_index<__accepted_index<_Tp&&>>,\n+                  std::forward<_Tp>(__t))\n \t{ __glibcxx_assert(holds_alternative<__accepted_type<_Tp&&>>(*this)); }\n \n       template<typename _Tp, typename... _Args,\n \t       typename = enable_if_t<__exactly_once<_Tp>\n \t\t\t  && is_constructible_v<_Tp, _Args&&...>>>\n \tconstexpr explicit\n \tvariant(in_place_type_t<_Tp>, _Args&&... __args)\n-\t: variant(in_place_index<__index_of<_Tp>>, std::forward<_Args>(__args)...)\n+\t: variant(in_place_index<__index_of<_Tp>>,\n+                  std::forward<_Args>(__args)...)\n \t{ __glibcxx_assert(holds_alternative<_Tp>(*this)); }\n \n       template<typename _Tp, typename _Up, typename... _Args,\n@@ -988,13 +1149,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t_Default_ctor_enabler(_Enable_default_constructor_tag{})\n \t{ __glibcxx_assert(index() == _Np); }\n \n-      ~variant() = default;\n-\n-      variant& operator=(const variant&) = default;\n-      variant& operator=(variant&&)\n-      noexcept((is_nothrow_move_constructible_v<_Types> && ...)\n-\t  && (is_nothrow_move_assignable_v<_Types> && ...)) = default;\n-\n       template<typename _Tp>\n \tenable_if_t<__exactly_once<__accepted_type<_Tp&&>>\n \t\t    && is_constructible_v<__accepted_type<_Tp&&>, _Tp&&>\n@@ -1089,7 +1243,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       constexpr size_t index() const noexcept\n       {\n \tif (this->_M_index ==\n-\t    typename _Base::_Storage::__index_type(variant_npos))\n+\t    typename _Base::__index_type(variant_npos))\n \t  return variant_npos;\n \treturn this->_M_index;\n       }"}, {"sha": "e5f7538ba42c69da496d277c560e2ac56926829f", "filename": "libstdc++-v3/testsuite/20_util/variant/compile.cc", "status": "modified", "additions": 100, "deletions": 3, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/705037247447f44826bd6fc2c777c69237fcef39/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fvariant%2Fcompile.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/705037247447f44826bd6fc2c777c69237fcef39/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fvariant%2Fcompile.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fvariant%2Fcompile.cc?ref=705037247447f44826bd6fc2c777c69237fcef39", "patch": "@@ -88,10 +88,12 @@ void copy_ctor()\n {\n   static_assert(is_copy_constructible_v<variant<int, string>>, \"\");\n   static_assert(!is_copy_constructible_v<variant<AllDeleted, string>>, \"\");\n+  static_assert(is_trivially_copy_constructible_v<variant<int>>, \"\");\n+  static_assert(!is_trivially_copy_constructible_v<variant<std::string>>, \"\");\n \n   {\n     variant<int> a;\n-    static_assert(!noexcept(variant<int>(a)), \"\");\n+    static_assert(noexcept(variant<int>(a)), \"\");\n   }\n   {\n     variant<string> a;\n@@ -103,14 +105,16 @@ void copy_ctor()\n   }\n   {\n     variant<int, char> a;\n-    static_assert(!noexcept(variant<int, char>(a)), \"\");\n+    static_assert(noexcept(variant<int, char>(a)), \"\");\n   }\n }\n \n void move_ctor()\n {\n   static_assert(is_move_constructible_v<variant<int, string>>, \"\");\n   static_assert(!is_move_constructible_v<variant<AllDeleted, string>>, \"\");\n+  static_assert(is_trivially_move_constructible_v<variant<int>>, \"\");\n+  static_assert(!is_trivially_move_constructible_v<variant<std::string>>, \"\");\n   static_assert(!noexcept(variant<int, Empty>(declval<variant<int, Empty>>())), \"\");\n   static_assert(noexcept(variant<int, DefaultNoexcept>(declval<variant<int, DefaultNoexcept>>())), \"\");\n }\n@@ -148,20 +152,24 @@ void copy_assign()\n {\n   static_assert(is_copy_assignable_v<variant<int, string>>, \"\");\n   static_assert(!is_copy_assignable_v<variant<AllDeleted, string>>, \"\");\n+  static_assert(is_trivially_copy_assignable_v<variant<int>>, \"\");\n+  static_assert(!is_trivially_copy_assignable_v<variant<string>>, \"\");\n   {\n     variant<Empty> a;\n     static_assert(!noexcept(a = a), \"\");\n   }\n   {\n     variant<DefaultNoexcept> a;\n-    static_assert(!noexcept(a = a), \"\");\n+    static_assert(noexcept(a = a), \"\");\n   }\n }\n \n void move_assign()\n {\n   static_assert(is_move_assignable_v<variant<int, string>>, \"\");\n   static_assert(!is_move_assignable_v<variant<AllDeleted, string>>, \"\");\n+  static_assert(is_trivially_move_assignable_v<variant<int>>, \"\");\n+  static_assert(!is_trivially_move_assignable_v<variant<string>>, \"\");\n   {\n     variant<Empty> a;\n     static_assert(!noexcept(a = std::move(a)), \"\");\n@@ -454,3 +462,92 @@ void test_emplace()\n   static_assert(!has_type_emplace<variant<AllDeleted>, AllDeleted>(0), \"\");\n   static_assert(!has_index_emplace<variant<AllDeleted>, 0>(0), \"\");\n }\n+\n+void test_triviality()\n+{\n+#define TEST_TEMPLATE(DT, CC, MC, CA, MA, CC_VAL, MC_VAL, CA_VAL, MA_VAL) \\\n+  { \\\n+    struct A \\\n+    { \\\n+      ~A() DT; \\\n+      A(const A&) CC; \\\n+      A(A&&) MC; \\\n+      A& operator=(const A&) CA; \\\n+      A& operator=(A&&) MA; \\\n+    }; \\\n+    static_assert(CC_VAL == is_trivially_copy_constructible_v<variant<A>>, \"\"); \\\n+    static_assert(MC_VAL == is_trivially_move_constructible_v<variant<A>>, \"\"); \\\n+    static_assert(CA_VAL == is_trivially_copy_assignable_v<variant<A>>, \"\"); \\\n+    static_assert(MA_VAL == is_trivially_move_assignable_v<variant<A>>, \"\"); \\\n+  }\n+  TEST_TEMPLATE(=default, =default, =default, =default, =default,  true,  true,  true,  true)\n+  TEST_TEMPLATE(=default, =default, =default, =default,       {},  true,  true,  true, false)\n+  TEST_TEMPLATE(=default, =default, =default,       {}, =default,  true,  true, false,  true)\n+  TEST_TEMPLATE(=default, =default, =default,       {},       {},  true,  true, false, false)\n+  TEST_TEMPLATE(=default, =default,       {}, =default, =default,  true, false,  true,  true)\n+  TEST_TEMPLATE(=default, =default,       {}, =default,       {},  true, false,  true, false)\n+  TEST_TEMPLATE(=default, =default,       {},       {}, =default,  true, false, false,  true)\n+  TEST_TEMPLATE(=default, =default,       {},       {},       {},  true, false, false, false)\n+  TEST_TEMPLATE(=default,       {}, =default, =default, =default, false,  true,  true,  true)\n+  TEST_TEMPLATE(=default,       {}, =default, =default,       {}, false,  true,  true, false)\n+  TEST_TEMPLATE(=default,       {}, =default,       {}, =default, false,  true, false,  true)\n+  TEST_TEMPLATE(=default,       {}, =default,       {},       {}, false,  true, false, false)\n+  TEST_TEMPLATE(=default,       {},       {}, =default, =default, false, false,  true,  true)\n+  TEST_TEMPLATE(=default,       {},       {}, =default,       {}, false, false,  true, false)\n+  TEST_TEMPLATE(=default,       {},       {},       {}, =default, false, false, false,  true)\n+  TEST_TEMPLATE(=default,       {},       {},       {},       {}, false, false, false, false)\n+  TEST_TEMPLATE(      {}, =default, =default, =default, =default, false, false, false, false)\n+  TEST_TEMPLATE(      {}, =default, =default, =default,       {}, false, false, false, false)\n+  TEST_TEMPLATE(      {}, =default, =default,       {}, =default, false, false, false, false)\n+  TEST_TEMPLATE(      {}, =default, =default,       {},       {}, false, false, false, false)\n+  TEST_TEMPLATE(      {}, =default,       {}, =default, =default, false, false, false, false)\n+  TEST_TEMPLATE(      {}, =default,       {}, =default,       {}, false, false, false, false)\n+  TEST_TEMPLATE(      {}, =default,       {},       {}, =default, false, false, false, false)\n+  TEST_TEMPLATE(      {}, =default,       {},       {},       {}, false, false, false, false)\n+  TEST_TEMPLATE(      {},       {}, =default, =default, =default, false, false, false, false)\n+  TEST_TEMPLATE(      {},       {}, =default, =default,       {}, false, false, false, false)\n+  TEST_TEMPLATE(      {},       {}, =default,       {}, =default, false, false, false, false)\n+  TEST_TEMPLATE(      {},       {}, =default,       {},       {}, false, false, false, false)\n+  TEST_TEMPLATE(      {},       {},       {}, =default, =default, false, false, false, false)\n+  TEST_TEMPLATE(      {},       {},       {}, =default,       {}, false, false, false, false)\n+  TEST_TEMPLATE(      {},       {},       {},       {}, =default, false, false, false, false)\n+  TEST_TEMPLATE(      {},       {},       {},       {},       {}, false, false, false, false)\n+#undef TEST_TEMPLATE\n+\n+#define TEST_TEMPLATE(CC, MC, CA, MA) \\\n+  { \\\n+    struct A \\\n+    { \\\n+      A(const A&) CC; \\\n+      A(A&&) MC; \\\n+      A& operator=(const A&) CA; \\\n+      A& operator=(A&&) MA; \\\n+    }; \\\n+    static_assert(!is_trivially_copy_constructible_v<variant<AllDeleted, A>>, \"\"); \\\n+    static_assert(!is_trivially_move_constructible_v<variant<AllDeleted, A>>, \"\"); \\\n+    static_assert(!is_trivially_copy_assignable_v<variant<AllDeleted, A>>, \"\"); \\\n+    static_assert(!is_trivially_move_assignable_v<variant<AllDeleted, A>>, \"\"); \\\n+  }\n+  TEST_TEMPLATE(=default, =default, =default, =default)\n+  TEST_TEMPLATE(=default, =default, =default,       {})\n+  TEST_TEMPLATE(=default, =default,       {}, =default)\n+  TEST_TEMPLATE(=default, =default,       {},       {})\n+  TEST_TEMPLATE(=default,       {}, =default, =default)\n+  TEST_TEMPLATE(=default,       {}, =default,       {})\n+  TEST_TEMPLATE(=default,       {},       {}, =default)\n+  TEST_TEMPLATE(=default,       {},       {},       {})\n+  TEST_TEMPLATE(      {}, =default, =default, =default)\n+  TEST_TEMPLATE(      {}, =default, =default,       {})\n+  TEST_TEMPLATE(      {}, =default,       {}, =default)\n+  TEST_TEMPLATE(      {}, =default,       {},       {})\n+  TEST_TEMPLATE(      {},       {}, =default, =default)\n+  TEST_TEMPLATE(      {},       {}, =default,       {})\n+  TEST_TEMPLATE(      {},       {},       {}, =default)\n+  TEST_TEMPLATE(      {},       {},       {},       {})\n+#undef TEST_TEMPLATE\n+\n+  static_assert(is_trivially_copy_constructible_v<variant<DefaultNoexcept, int, char, float, double>>, \"\");\n+  static_assert(is_trivially_move_constructible_v<variant<DefaultNoexcept, int, char, float, double>>, \"\");\n+  static_assert(is_trivially_copy_assignable_v<variant<DefaultNoexcept, int, char, float, double>>, \"\");\n+  static_assert(is_trivially_move_assignable_v<variant<DefaultNoexcept, int, char, float, double>>, \"\");\n+}"}]}