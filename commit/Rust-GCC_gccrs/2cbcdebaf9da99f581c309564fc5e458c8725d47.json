{"sha": "2cbcdebaf9da99f581c309564fc5e458c8725d47", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmNiY2RlYmFmOWRhOTlmNTgxYzMwOTU2NGZjNWU0NThjODcyNWQ0Nw==", "commit": {"author": {"name": "Paul Brook", "email": "paul@codesourcery.com", "date": "2004-11-10T02:19:27Z"}, "committer": {"name": "Paul Brook", "email": "pbrook@gcc.gnu.org", "date": "2004-11-10T02:19:27Z"}, "message": "re PR fortran/18218 (Miscompare in sixtrack benchmark caused by loss of precision)\n\n\tPR fortran/18218\n\t* configure.ac: Check for strtof.\n\t* configure: Regenerate.\n\t* config.h.in: Regenerate.\n\t* io/read.c (convert_real): Use strtof if available.\n\t(convert_precision_real): Remove.\n\t(read_f): Avoid poor exponentiation algorithm.\ngcc/testsuite/\n\t* gfortran.dg/list_read.c: New test.\n\nFrom-SVN: r90382", "tree": {"sha": "f1a70346c066ae259be7cf608066ff4eebd910b6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f1a70346c066ae259be7cf608066ff4eebd910b6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2cbcdebaf9da99f581c309564fc5e458c8725d47", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2cbcdebaf9da99f581c309564fc5e458c8725d47", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2cbcdebaf9da99f581c309564fc5e458c8725d47", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2cbcdebaf9da99f581c309564fc5e458c8725d47/comments", "author": null, "committer": null, "parents": [{"sha": "4ef509c05829d8ae5df462a4fdf12208fa2745ac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ef509c05829d8ae5df462a4fdf12208fa2745ac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4ef509c05829d8ae5df462a4fdf12208fa2745ac"}], "stats": {"total": 274, "additions": 118, "deletions": 156}, "files": [{"sha": "ce5a2b13aefddc9481b9d92b2c6d6dea94dd5b90", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cbcdebaf9da99f581c309564fc5e458c8725d47/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cbcdebaf9da99f581c309564fc5e458c8725d47/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=2cbcdebaf9da99f581c309564fc5e458c8725d47", "patch": "@@ -1,3 +1,8 @@\n+2004-11-10  Paul Brook  <paul@codesourcery.com>\n+\n+\tPR fortran/18218\n+\t* gfortran.dg/list_read.c: New test.\n+\n 2004-11-09  Joseph S. Myers  <joseph@codesourcery.com>\n \n \tPR c/18322"}, {"sha": "e38036f8b92c846ee3e44b10cab0c8472791fd4e", "filename": "gcc/testsuite/gfortran.dg/read_float_1.f90", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cbcdebaf9da99f581c309564fc5e458c8725d47/gcc%2Ftestsuite%2Fgfortran.dg%2Fread_float_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cbcdebaf9da99f581c309564fc5e458c8725d47/gcc%2Ftestsuite%2Fgfortran.dg%2Fread_float_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fread_float_1.f90?ref=2cbcdebaf9da99f581c309564fc5e458c8725d47", "patch": "@@ -0,0 +1,12 @@\n+! { dg-do run }\n+! PR18218\n+! The IO library has an algorithm that involved repeated multiplication by 10,\n+! resulting in introducing large cumulative floating point errors.\n+program foo\n+  character*20 s\n+  real*8 d\n+  s = \"-.18774312893273    \"\n+  read(unit=s, fmt='(g20.14)') d\n+  if (d + 0.18774312893273d0 .gt. 1d-13) call abort\n+end program\n+"}, {"sha": "000d49656d01de14d825e49a920ca678dd281c49", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cbcdebaf9da99f581c309564fc5e458c8725d47/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cbcdebaf9da99f581c309564fc5e458c8725d47/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=2cbcdebaf9da99f581c309564fc5e458c8725d47", "patch": "@@ -1,3 +1,13 @@\n+2004-11-10  Paul Brook  <paul@codesourcery.com>\n+\n+\tPR fortran/18218\n+\t* configure.ac: Check for strtof.\n+\t* configure: Regenerate.\n+\t* config.h.in: Regenerate.\n+\t* io/read.c (convert_real): Use strtof if available.\n+\t(convert_precision_real): Remove.\n+\t(read_f): Avoid poor exponentiation algorithm.\n+\n 2004-11-05  Andreas Schwab  <schwab@suse.de>\n \n \t* configure.ac: Use AC_PROG_FC, FC and FCFLAGS instead of"}, {"sha": "d31c21b84c944de8de3b96c6d2a6674e0b49714e", "filename": "libgfortran/config.h.in", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cbcdebaf9da99f581c309564fc5e458c8725d47/libgfortran%2Fconfig.h.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cbcdebaf9da99f581c309564fc5e458c8725d47/libgfortran%2Fconfig.h.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fconfig.h.in?ref=2cbcdebaf9da99f581c309564fc5e458c8725d47", "patch": "@@ -156,6 +156,9 @@\n /* Define to 1 if you have the <string.h> header file. */\n #undef HAVE_STRING_H\n \n+/* Define to 1 if you have the `strtof' function. */\n+#undef HAVE_STRTOF\n+\n /* Define to 1 if you have the <sys/mman.h> header file. */\n #undef HAVE_SYS_MMAN_H\n "}, {"sha": "e486b4e9ec8d1934894b3d8c9e025e9e1ac45b98", "filename": "libgfortran/configure", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cbcdebaf9da99f581c309564fc5e458c8725d47/libgfortran%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cbcdebaf9da99f581c309564fc5e458c8725d47/libgfortran%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fconfigure?ref=2cbcdebaf9da99f581c309564fc5e458c8725d47", "patch": "@@ -6821,7 +6821,8 @@ fi\n \n \n \n-for ac_func in getrusage times mkstemp\n+\n+for ac_func in getrusage times mkstemp strtof\n do\n as_ac_var=`echo \"ac_cv_func_$ac_func\" | $as_tr_sh`\n echo \"$as_me:$LINENO: checking for $ac_func\" >&5"}, {"sha": "3adcfd61c3d5756950567283d9c5edf834f7805d", "filename": "libgfortran/configure.ac", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cbcdebaf9da99f581c309564fc5e458c8725d47/libgfortran%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cbcdebaf9da99f581c309564fc5e458c8725d47/libgfortran%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fconfigure.ac?ref=2cbcdebaf9da99f581c309564fc5e458c8725d47", "patch": "@@ -159,7 +159,7 @@ AC_CHECK_HEADER([complex.h],[AC_DEFINE([HAVE_COMPLEX_H], [1], [complex.h exists]\n AC_CHECK_LIB([m],[csin],[need_math=\"no\"],[need_math=\"yes\"])\n \n # Check for library functions.\n-AC_CHECK_FUNCS(getrusage times mkstemp)\n+AC_CHECK_FUNCS(getrusage times mkstemp strtof)\n \n # Check libc for getgid, getpid, getuid\n AC_CHECK_LIB([c],[getgid],[AC_DEFINE([HAVE_GETGID],[1],[libc includes getgid])])"}, {"sha": "6999158c13ac5a02466d6f8dfdd85caf1b8467be", "filename": "libgfortran/io/read.c", "status": "modified", "additions": 85, "deletions": 154, "changes": 239, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cbcdebaf9da99f581c309564fc5e458c8725d47/libgfortran%2Fio%2Fread.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cbcdebaf9da99f581c309564fc5e458c8725d47/libgfortran%2Fio%2Fread.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fread.c?ref=2cbcdebaf9da99f581c309564fc5e458c8725d47", "patch": "@@ -24,6 +24,7 @@ Boston, MA 02111-1307, USA.  */\n #include <errno.h>\n #include <ctype.h>\n #include <stdlib.h>\n+#include <stdio.h>\n #include \"libgfortran.h\"\n #include \"io.h\"\n \n@@ -89,8 +90,7 @@ max_value (int length, int signed_flag)\n /* convert_real()-- Convert a character representation of a floating\n  * point number to the machine number.  Returns nonzero if there is a\n  * range problem during conversion.  TODO: handle not-a-numbers and\n- * infinities.  Handling of kind 4 is probably wrong because of double\n- * rounding. */\n+ * infinities.  */\n \n int\n convert_real (void *dest, const char *buffer, int length)\n@@ -101,13 +101,18 @@ convert_real (void *dest, const char *buffer, int length)\n   switch (length)\n     {\n     case 4:\n-      *((float *) dest) = (float) strtod (buffer, NULL);\n+      *((float *) dest) =\n+#if defined(HAVE_STRTOF)\n+\tstrtof (buffer, NULL);\n+#else\n+\t(float) strtod (buffer, NULL);\n+#endif\n       break;\n     case 8:\n       *((double *) dest) = strtod (buffer, NULL);\n       break;\n     default:\n-      internal_error (\"Bad real number kind\");\n+      internal_error (\"Unsupported real kind during IO\");\n     }\n \n   if (errno != 0)\n@@ -120,114 +125,6 @@ convert_real (void *dest, const char *buffer, int length)\n   return 0;\n }\n \n-static int\n-convert_precision_real (void *dest, int sign,\n-                       char *buffer, int length, int exponent)\n-{\n-  int w, new_dp_pos, i, slen, k, dp;\n-  char * p, c;\n-  double fval;\n-  float tf;\n-\n-  fval =0.0;\n-  tf = 0.0;\n-  dp = 0;\n-  new_dp_pos = 0;\n-\n-  slen = strlen (buffer);\n-  w = slen;\n-  p = buffer;\n-\n-/*  for (i = w - 1; i > 0; i --)\n-    {\n-       if (buffer[i] == '0' || buffer[i] == 0)\n-         buffer[i] = 0;\n-       else\n-         break;\n-    }\n-*/\n-  for (i = 0; i < w; i++)\n-    {\n-       if (buffer[i] == '.')\n-         break;\n-    }\n-\n-  new_dp_pos = i;\n-  new_dp_pos += exponent;\n-\n-  while (w > 0)\n-    {\n-      c = *p;\n-      switch (c)\n-        {\n-        case '0':\n-        case '1':\n-        case '2':\n-        case '3':\n-        case '4':\n-        case '5':\n-        case '6':\n-        case '7':\n-        case '8':\n-        case '9':\n-          fval = fval * 10.0 + c - '0';\n-          p++;\n-          w--;\n-          break;\n-\n-        case '.':\n-          dp = 1;\n-          p++;\n-          w--;\n-          break;\n-\n-       default:\n-          p++;\n-          w--;\n-          break;\n-     }\n-  }\n-\n-  if (sign)\n-    fval = - fval;\n-\n-  i = new_dp_pos - slen + dp;\n-  k = abs(i);\n-  tf = 1.0;\n-\n-  while (k > 0)\n-    {\n-       tf *= 10.0 ;\n-       k -- ;\n-    }\n-\n-  if (fval != 0.0)\n-    {\n-       if (i < 0)\n-         {\n-           fval = fval / tf;\n-         }\n-        else\n-         {\n-           fval = fval * tf;\n-         }\n-    }\n-\n-  switch (length)\n-    {\n-    case 4:\n-      *((float *) dest) = (float)fval;\n-      break;\n-    case 8:\n-      *((double *) dest) = fval;\n-      break;\n-    default:\n-      internal_error (\"Bad real number kind\");\n-    }\n-\n-  return 0;\n-}\n-\n \n /* read_l()-- Read a logical value */\n \n@@ -576,19 +473,23 @@ read_radix (fnode * f, char *dest, int length, int radix)\n \n \n /* read_f()-- Read a floating point number with F-style editing, which\n- * is what all of the other floating point descriptors behave as.  The\n- * tricky part is that optional spaces are allowed after an E or D,\n- * and the implicit decimal point if a decimal point is not present in\n- * the input. */\n+   is what all of the other floating point descriptors behave as.  The\n+   tricky part is that optional spaces are allowed after an E or D,\n+   and the implicit decimal point if a decimal point is not present in\n+   the input.  */\n \n void\n read_f (fnode * f, char *dest, int length)\n {\n   int w, seen_dp, exponent;\n   int exponent_sign, val_sign;\n-  char *p, *buffer, *n;\n+  int ndigits;\n+  int edigits;\n+  int i;\n+  char *p, *buffer;\n+  char *digits;\n \n-  val_sign = 0;\n+  val_sign = 1;\n   seen_dp = 0;\n   w = f->u.w;\n   p = read_block (&w);\n@@ -601,32 +502,26 @@ read_f (fnode * f, char *dest, int length)\n       switch (length)\n \t{\n \tcase 4:\n-\t  *((float *) dest) = 0.0;\n+\t  *((float *) dest) = 0.0f;\n \t  break;\n \n \tcase 8:\n \t  *((double *) dest) = 0.0;\n \t  break;\n+\n+\tdefault:\n+\t  internal_error (\"Unsupported real kind during IO\");\n \t}\n \n       return;\n     }\n \n-  if (w + 2 < SCRATCH_SIZE)\n-    buffer = scratch;\n-  else\n-    buffer = get_mem (w + 2);\n-\n-  memset(buffer, 0, w + 2);\n-\n-  n = buffer;\n-\n   /* Optional sign */\n \n   if (*p == '-' || *p == '+')\n     {\n       if (*p == '-')\n-        val_sign = 1;\n+        val_sign = -1;\n       p++;\n \n       if (--w == 0)\n@@ -640,10 +535,21 @@ read_f (fnode * f, char *dest, int length)\n   if (!isdigit (*p) && *p != '.')\n     goto bad_float;\n \n+  /* Remember the position of the first digit.  */\n+  digits = p;\n+  ndigits = 0;\n+\n+  /* Scan through the string to find the exponent.  */\n   while (w > 0)\n     {\n       switch (*p)\n \t{\n+\tcase '.':\n+\t  if (seen_dp)\n+\t    goto bad_float;\n+\t  seen_dp = 1;\n+\t  /* Fall through */\n+\n \tcase '0':\n \tcase '1':\n \tcase '2':\n@@ -654,23 +560,9 @@ read_f (fnode * f, char *dest, int length)\n \tcase '7':\n \tcase '8':\n \tcase '9':\n-\t  *n++ = *p++;\n-\t  w--;\n-\t  break;\n-\n-\tcase '.':\n-\t  if (seen_dp)\n-\t    goto bad_float;\n-\t  seen_dp = 1;\n-\n-\t  *n++ = *p++;\n-\t  w--;\n-\t  break;\n-\n \tcase ' ':\n-\t  if (g.blank_status == BLANK_ZERO)\n-\t    *n++ = '0';\n-\t  p++;\n+\t  ndigits++;\n+\t  *p++;\n \t  w--;\n \t  break;\n \n@@ -732,8 +624,8 @@ read_f (fnode * f, char *dest, int length)\n     goto bad_float;\n \n /* At this point a digit string is required.  We calculate the value\n- * of the exponent in order to take account of the scale factor and\n- * the d parameter before explict conversion takes place. */\n+   of the exponent in order to take account of the scale factor and\n+   the d parameter before explict conversion takes place. */\n \n exp2:\n   if (!isdigit (*p))\n@@ -746,9 +638,6 @@ read_f (fnode * f, char *dest, int length)\n   while (w > 0 && isdigit (*p))\n     {\n       exponent = 10 * exponent + *p - '0';\n-      if (exponent > 999999)\n-\tgoto bad_float;\n-\n       p++;\n       w--;\n     }\n@@ -766,14 +655,56 @@ read_f (fnode * f, char *dest, int length)\n   exponent = exponent * exponent_sign;\n \n done:\n+  /* Use the precision specified in the format if no decimal point has been\n+     seen.  */\n   if (!seen_dp)\n     exponent -= f->u.real.d;\n \n-  /* The number is syntactically correct and ready for conversion.\n-   * The only thing that can go wrong at this point is overflow or\n-   * underflow. */\n+  if (exponent > 0)\n+    {\n+      edigits = 2;\n+      i = exponent;\n+    }\n+  else\n+    {\n+      edigits = 3;\n+      i = -exponent;\n+    }\n+\n+  while (i >= 10)\n+    {\n+      i /= 10;\n+      edigits++;\n+    }\n+\n+  i = ndigits + edigits + 1;\n+  if (val_sign < 0)\n+    i++;\n+\n+  if (i < SCRATCH_SIZE) \n+    buffer = scratch;\n+  else\n+    buffer = get_mem (i);\n+\n+  /* Reformat the string into a temporary buffer.  As we're using atof it's\n+     easiest to just leave the dcimal point in place.  */\n+  p = buffer;\n+  if (val_sign < 0)\n+    *(p++) = '-';\n+  for (; ndigits > 0; ndigits--)\n+    {\n+      if (*digits == ' ' && g.blank_status == BLANK_ZERO)\n+\t*p = '0';\n+      else\n+\t*p = *digits;\n+      p++;\n+      digits++;\n+    }\n+  *(p++) = 'e';\n+  sprintf (p, \"%d\", exponent);\n \n-  convert_precision_real (dest, val_sign, buffer, length, exponent);\n+  /* Do the actual conversion.  */\n+  string_to_real (dest, buffer, length);\n \n   if (buffer != scratch)\n      free_mem (buffer);"}]}