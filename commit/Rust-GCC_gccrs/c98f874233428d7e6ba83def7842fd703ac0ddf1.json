{"sha": "c98f874233428d7e6ba83def7842fd703ac0ddf1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yzk4Zjg3NDIzMzQyOGQ3ZTZiYTgzZGVmNzg0MmZkNzAzYWMwZGRmMQ==", "commit": {"author": {"name": "James Van Artsdalen", "email": "jrv@gnu.org", "date": "1992-02-09T13:28:48Z"}, "committer": {"name": "James Van Artsdalen", "email": "jrv@gnu.org", "date": "1992-02-09T13:28:48Z"}, "message": "Initial revision\n\nFrom-SVN: r295", "tree": {"sha": "9a738b9ae15919cc022e8df5890e5101f3a67012", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9a738b9ae15919cc022e8df5890e5101f3a67012"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c98f874233428d7e6ba83def7842fd703ac0ddf1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c98f874233428d7e6ba83def7842fd703ac0ddf1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c98f874233428d7e6ba83def7842fd703ac0ddf1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c98f874233428d7e6ba83def7842fd703ac0ddf1/comments", "author": null, "committer": null, "parents": [{"sha": "48c8b6b7b8a33fa8e24c7923c82ad9fea525289d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/48c8b6b7b8a33fa8e24c7923c82ad9fea525289d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/48c8b6b7b8a33fa8e24c7923c82ad9fea525289d"}], "stats": {"total": 1393, "additions": 1393, "deletions": 0}, "files": [{"sha": "c0cd287b3d2f0c5d66baf1b8ed168239639771e9", "filename": "gcc/config/i386/i386.h", "status": "added", "additions": 1393, "deletions": 0, "changes": 1393, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c98f874233428d7e6ba83def7842fd703ac0ddf1/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c98f874233428d7e6ba83def7842fd703ac0ddf1/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=c98f874233428d7e6ba83def7842fd703ac0ddf1", "patch": "@@ -0,0 +1,1393 @@\n+/* Definitions of target machine for GNU compiler for Intel 80386.\n+   Copyright (C) 1988, 1992 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+\n+/* The purpose of this file is to define the characteristics of the i386,\n+   independant of assembler syntax or operating system.\n+\n+   Three other files build on this one to describe a specific assembler syntax:\n+   bsd386.h, att386.h, and sun386.h.\n+\n+   The actual tm.h file for a particular system should include\n+   this file, and then the file for the appropriate assembler syntax.\n+\n+   Many macros that specify assembler syntax are omitted entirely from\n+   this file because they really belong in the files for particular\n+   assemblers.  These include AS1, AS2, AS3, RP, IP, LPREFIX, L_SIZE,\n+   PUT_OP_SIZE, USE_STAR, ADDR_BEG, ADDR_END, PRINT_IREG, PRINT_SCALE,\n+   PRINT_B_I_S, and many that start with ASM_ or end in ASM_OP.  */\n+\n+/* Names to predefine in the preprocessor for this target machine.  */\n+\n+#define I386 1\n+\n+/* Run-time compilation parameters selecting different hardware subsets.  */\n+\n+extern int target_flags;\n+\n+/* Macros used in the machine description to test the flags.  */\n+\n+/* Compile 80387 insns for floating point (not library calls).  */\n+#define TARGET_80387 (target_flags & 1)\n+/* Compile code for an i486. */\n+#define TARGET_486 (target_flags & 2)\n+/* Compile using ret insn that pops args.\n+   This will not work unless you use prototypes at least\n+   for all functions that can take varying numbers of args.  */  \n+#define TARGET_RTD (target_flags & 8)\n+/* Compile passing first two args in regs 0 and 1.\n+   This exists only to test compiler features that will\n+   be needed for RISC chips.  It is not usable\n+   and is not intended to be usable on this cpu.  */\n+#define TARGET_REGPARM (target_flags & 020)\n+\n+/* Macro to define tables used to set the flags.\n+   This is a list in braces of pairs in braces,\n+   each pair being { \"NAME\", VALUE }\n+   where VALUE is the bits to set or minus the bits to clear.\n+   An empty string NAME is used to identify the default VALUE.  */\n+\n+#define TARGET_SWITCHES  \\\n+  { { \"80387\", 1},\t\t\t\t\\\n+    { \"soft-float\", -1},\t\t\t\\\n+    { \"486\", 2},\t\t\t\t\\\n+    { \"no486\", -2},\t\t\t\t\\\n+    { \"386\", -2},\t\t\t\t\\\n+    { \"rtd\", 8},\t\t\t\t\\\n+    { \"nortd\", -8},\t\t\t\t\\\n+    { \"regparm\", 020},\t\t\t\t\\\n+    { \"noregparm\", -020},\t\t\t\\\n+    { \"\", TARGET_DEFAULT}}\n+\f\n+/* target machine storage layout */\n+\n+/* Define this if most significant byte of a word is the lowest numbered.  */\n+/* That is true on the 80386.  */\n+\n+#define BITS_BIG_ENDIAN 0\n+\n+/* Define this if most significant byte of a word is the lowest numbered.  */\n+/* That is not true on the 80386.  */\n+#define BYTES_BIG_ENDIAN 0\n+\n+/* Define this if most significant word of a multiword number is the lowest\n+   numbered.  */\n+/* Not true for 80386 */\n+#define WORDS_BIG_ENDIAN 0\n+\n+/* number of bits in an addressible storage unit */\n+#define BITS_PER_UNIT 8\n+\n+/* Width in bits of a \"word\", which is the contents of a machine register.\n+   Note that this is not necessarily the width of data type `int';\n+   if using 16-bit ints on a 80386, this would still be 32.\n+   But on a machine with 16-bit registers, this would be 16.  */\n+#define BITS_PER_WORD 32\n+\n+/* Width of a word, in units (bytes).  */\n+#define UNITS_PER_WORD 4\n+\n+/* Width in bits of a pointer.\n+   See also the macro `Pmode' defined below.  */\n+#define POINTER_SIZE 32\n+\n+/* Allocation boundary (in *bits*) for storing arguments in argument list.  */\n+#define PARM_BOUNDARY 32\n+\n+/* Boundary (in *bits*) on which stack pointer should be aligned.  */\n+#define STACK_BOUNDARY 32\n+\n+/* Allocation boundary (in *bits*) for the code of a function.\n+   For i486, we get better performance by aligning to a cache\n+   line (i.e. 16 byte) boundary.  */\n+#define FUNCTION_BOUNDARY (TARGET_486 ? 128 : 32)\n+\n+/* Alignment of field after `int : 0' in a structure. */\n+\n+#define EMPTY_FIELD_BOUNDARY 32\n+\n+/* Minimum size in bits of the largest boundary to which any\n+   and all fundamental data types supported by the hardware\n+   might need to be aligned. No data type wants to be aligned\n+   rounder than this.  The i386 supports 64-bit floating point\n+   quantities, but these can be aligned on any 32-bit boundary.  */\n+#define BIGGEST_ALIGNMENT 32\n+\n+/* Define this if move instructions will actually fail to work\n+   when given unaligned data.  */\n+/* #define STRICT_ALIGNMENT */\n+\n+/* If bit field type is int, don't let it cross an int,\n+   and give entire struct the alignment of an int.  */\n+/* Required on the 386 since it doesn't have bitfield insns.  */\n+#define PCC_BITFIELD_TYPE_MATTERS 1\n+\n+/* Align loop starts for optimal branching.  */\n+#define ASM_OUTPUT_LOOP_ALIGN(FILE) \\\n+  ASM_OUTPUT_ALIGN (FILE, 2)\n+\n+/* This is how to align an instruction for optimal branching.\n+   On i486 we'll get better performance by aligning on a\n+   cache line (i.e. 16 byte) boundary.  */\n+#define ASM_OUTPUT_ALIGN_CODE(FILE)\t\\\n+  ASM_OUTPUT_ALIGN ((FILE), (TARGET_486 ? 4 : 2))\n+\f\n+/* Standard register usage.  */\n+\n+/* This processor has special stack-like registers.  See reg-stack.c\n+   for details. */\n+\n+#define STACK_REGS\n+\n+/* Number of actual hardware registers.\n+   The hardware registers are assigned numbers for the compiler\n+   from 0 to just below FIRST_PSEUDO_REGISTER.\n+   All registers that the compiler knows about must be given numbers,\n+   even those that are not normally considered general registers.\n+\n+   In the 80386 we give the 8 general purpose registers the numbers 0-7.\n+   We number the floating point registers 8-15.\n+   Note that registers 0-7 can be accessed as a  short or int,\n+   while only 0-3 may be used with byte `mov' instructions.\n+\n+   Reg 16 does not correspond to any hardware register, but instead\n+   appears in the RTL as an argument pointer prior to reload, and is\n+   eliminated during reloading in favor of either the stack or frame\n+   pointer. */\n+\n+#define FIRST_PSEUDO_REGISTER 17\n+\n+/* 1 for registers that have pervasive standard uses\n+   and are not available for the register allocator.\n+   On the 80386, the stack pointer is such, as is the arg pointer. */\n+#define FIXED_REGISTERS \\\n+/*ax,dx,cx,bx,si,di,bp,sp,st,st1,st2,st3,st4,st5,st6,st7,arg*/       \\\n+{  0, 0, 0, 0, 0, 0, 0, 1, 0,  0,  0,  0,  0,  0,  0,  0,  1 }\n+\n+/* 1 for registers not available across function calls.\n+   These must include the FIXED_REGISTERS and also any\n+   registers that can be used without being saved.\n+   The latter must include the registers where values are returned\n+   and the register where structure-value addresses are passed.\n+   Aside from that, you can include as many other registers as you like.  */\n+\n+#define CALL_USED_REGISTERS \\\n+/*ax,dx,cx,bx,si,di,bp,sp,st,st1,st2,st3,st4,st5,st6,st7,arg*/ \\\n+{  1, 1, 1, 0, 0, 0, 0, 1, 1,  1,  1,  1,  1,  1,  1,  1,  1 }\n+\n+/* Macro to conditionally modify fixed_regs/call_used_regs.  */\n+#define CONDITIONAL_REGISTER_USAGE\t\t\t\\\n+  {\t\t\t\t\t\t\t\\\n+    if (flag_pic)\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\\\n+\tfixed_regs[PIC_OFFSET_TABLE_REGNUM] = 1;\t\\\n+\tcall_used_regs[PIC_OFFSET_TABLE_REGNUM] = 1;\t\\\n+      }\t\t\t\t\t\t\t\\\n+  }\n+\n+/* Return number of consecutive hard regs needed starting at reg REGNO\n+   to hold something of mode MODE.\n+   This is ordinarily the length in words of a value of mode MODE\n+   but can be less for certain modes in special long registers.\n+\n+   Actually there are no two word move instructions for consecutive \n+   registers.  And only registers 0-3 may have mov byte instructions\n+   applied to them.\n+   */\n+\n+#define HARD_REGNO_NREGS(REGNO, MODE)   \\\n+  (FP_REGNO_P (REGNO) ? 1 \\\n+   : ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD))\n+\n+/* Value is 1 if hard register REGNO can hold a value of machine-mode MODE.\n+   On the 80386, the first 4 cpu registers can hold any mode\n+   while the floating point registers may hold only floating point.\n+   Make it clear that the fp regs could not hold a 16-byte float.  */\n+\n+#define HARD_REGNO_MODE_OK(REGNO, MODE) \\\n+  ((REGNO) < 2 ? 1\t\t\t\t\t\t\t\\\n+   : (REGNO) < 4 ? 1\t\t\t\t\t\t\t\\\n+   : (REGNO) >= 8 ? ((GET_MODE_CLASS (MODE) == MODE_FLOAT\t\t\\\n+\t\t      || GET_MODE_CLASS (MODE) == MODE_COMPLEX_FLOAT)\t\\\n+\t\t     && GET_MODE_UNIT_SIZE (MODE) <= 8)\t\t\t\\\n+   : (MODE) != QImode)\n+\n+/* Value is 1 if it is a good idea to tie two pseudo registers\n+   when one has mode MODE1 and one has mode MODE2.\n+   If HARD_REGNO_MODE_OK could produce different values for MODE1 and MODE2,\n+   for any hard reg, then this must be 0 for correct output.  */\n+\n+#define MODES_TIEABLE_P(MODE1, MODE2) ((MODE1) == (MODE2))\n+\n+/* A C expression returning the cost of moving data from a register of class\n+   CLASS1 to one of CLASS2.\n+\n+   On the i386, copying between floating-point and fixed-point\n+   registers is expensive.  */\n+\n+#define REGISTER_MOVE_COST(CLASS1, CLASS2)\t\t\\\n+  ((((CLASS1) == FLOAT_REGS && (CLASS2) != FLOAT_REGS)\t\\\n+    || ((CLASS2) == FLOAT_REGS && (CLASS1) != FLOAT_REGS))\t\\\n+   ? 10 : 2)\n+\n+/* Specify the registers used for certain standard purposes.\n+   The values of these macros are register numbers.  */\n+\n+/* on the 386 the pc register is %eip, and is not usable as a general\n+   register.  The ordinary mov instructions won't work */\n+/* #define PC_REGNUM  */\n+\n+/* Register to use for pushing function arguments.  */\n+#define STACK_POINTER_REGNUM 7\n+\n+/* Base register for access to local variables of the function.  */\n+#define FRAME_POINTER_REGNUM 6\n+\n+/* First floating point reg */\n+#define FIRST_FLOAT_REG 8\n+\n+/* First & last stack-like regs */\n+#define FIRST_STACK_REG FIRST_FLOAT_REG\n+#define LAST_STACK_REG (FIRST_FLOAT_REG + 7)\n+\n+/* Value should be nonzero if functions must have frame pointers.\n+   Zero means the frame pointer need not be set up (and parms\n+   may be accessed via the stack pointer) in functions that seem suitable.\n+   This is computed in `reload', in reload1.c.  */\n+#define FRAME_POINTER_REQUIRED 0\n+\n+/* Base register for access to arguments of the function.  */\n+#define ARG_POINTER_REGNUM 16\n+\n+/* Register in which static-chain is passed to a function.  */\n+#define STATIC_CHAIN_REGNUM 2\n+\n+/* Register to hold the addressing base for position independent\n+   code access to data items.  */\n+#define PIC_OFFSET_TABLE_REGNUM 3\n+\n+/* Register in which address to store a structure value\n+   arrives in the function.  On the 386, the prologue\n+   copies this from the stack to register %eax.  */\n+#define STRUCT_VALUE_INCOMING 0\n+\n+/* Place in which caller passes the structure value address.\n+   0 means push the value on the stack like an argument.  */\n+#define STRUCT_VALUE 0\n+\f\n+/* Define the classes of registers for register constraints in the\n+   machine description.  Also define ranges of constants.\n+\n+   One of the classes must always be named ALL_REGS and include all hard regs.\n+   If there is more than one class, another class must be named NO_REGS\n+   and contain no registers.\n+\n+   The name GENERAL_REGS must be the name of a class (or an alias for\n+   another name such as ALL_REGS).  This is the class of registers\n+   that is allowed by \"g\" or \"r\" in a register constraint.\n+   Also, registers outside this class are allocated only when\n+   instructions express preferences for them.\n+\n+   The classes must be numbered in nondecreasing order; that is,\n+   a larger-numbered class must never be contained completely\n+   in a smaller-numbered class.\n+\n+   For any two classes, it is very desirable that there be another\n+   class that represents their union.  */\n+   \n+\n+enum reg_class\n+{\n+  NO_REGS,\n+  AREG, DREG, CREG,\n+  Q_REGS,\t\t\t/* %eax %ebx %ecx %edx */\n+  SIREG, DIREG,\n+  INDEX_REGS,\t\t\t/* %eax %ebx %ecx %edx %esi %edi %ebp */\n+  GENERAL_REGS,\t\t\t/* %eax %ebx %ecx %edx %esi %edi %ebp %esp */\n+  FP_TOP_REG, FP_SECOND_REG,\t/* %st(0) %st(1) */\n+  FLOAT_REGS,\n+  ALL_REGS, LIM_REG_CLASSES\n+};\n+\n+#define N_REG_CLASSES (int) LIM_REG_CLASSES\n+\n+/* Give names of register classes as strings for dump file.   */\n+\n+#define REG_CLASS_NAMES \\\n+{  \"NO_REGS\",\t\t\t\t\\\n+   \"AREG\", \"DREG\", \"CREG\",\t\t\\\n+   \"Q_REGS\",\t\t\t\t\\\n+   \"SIREG\", \"DIREG\",\t\t\t\\\n+   \"INDEX_REGS\",\t\t\t\\\n+   \"GENERAL_REGS\",\t\t\t\\\n+   \"FP_TOP_REG\", \"FP_SECOND_REG\",\t\\\n+   \"FLOAT_REGS\",\t\t\t\\\n+   \"ALL_REGS\" }\n+\n+/* Define which registers fit in which classes.\n+   This is an initializer for a vector of HARD_REG_SET\n+   of length N_REG_CLASSES.  */\n+\n+#define REG_CLASS_CONTENTS \\\n+{      0,\t\t\t\t\t\t\t\\\n+     0x1,    0x2,  0x4,\t\t/* AREG, DREG, CREG */\t\t\\\n+     0xf,\t\t\t/* Q_REGS */\t\t\t\\\n+    0x10,   0x20,\t\t/* SIREG, DIREG */\t\t\\\n+ 0x1007f,\t\t\t/* INDEX_REGS */\t\t\\\n+ 0x100ff,\t\t\t/* GENERAL_REGS */\t\t\\\n+  0x0100, 0x0200,\t\t/* FP_TOP_REG, FP_SECOND_REG */\t\\\n+  0xff00,\t\t\t/* FLOAT_REGS */\t\t\\\n+ 0x1ffff }\n+\n+/* The same information, inverted:\n+   Return the class number of the smallest class containing\n+   reg number REGNO.  This could be a conditional expression\n+   or could index an array.  */\n+\n+extern enum reg_class regclass_map[FIRST_PSEUDO_REGISTER];\n+#define REGNO_REG_CLASS(REGNO) (regclass_map[REGNO])\n+\n+/* When defined, the compiler allows registers explicitly used in the\n+   rtl to be used as spill registers but prevents the compiler from\n+   extending the lifetime of these registers. */\n+\n+#define SMALL_REGISTER_CLASSES\n+\n+#define QI_REG_P(X) \\\n+  (REG_P (X) && REGNO (X) < 4)\n+#define NON_QI_REG_P(X) \\\n+  (REG_P (X) && REGNO (X) >= 4 && REGNO (X) < FIRST_PSEUDO_REGISTER)\n+\n+#define FP_REG_P(X) (REG_P (X) && FP_REGNO_P (REGNO (X)))\n+#define FP_REGNO_P(n) ((n) >= FIRST_STACK_REG && (n) <= LAST_STACK_REG)\n+  \n+#define STACK_REG_P(xop) (REG_P (xop) &&\t\t       \t\\\n+\t\t\t  REGNO (xop) >= FIRST_STACK_REG &&\t\\\n+\t\t\t  REGNO (xop) <= LAST_STACK_REG)\n+\n+#define NON_STACK_REG_P(xop) (REG_P (xop) && ! STACK_REG_P (xop))\n+\n+#define STACK_TOP_P(xop) (REG_P (xop) && REGNO (xop) == FIRST_STACK_REG)\n+\n+/* Try to maintain the accuracy of the death notes for regs satisfying the\n+   following.  Important for stack like regs, to know when to pop. */\n+\n+/* #define PRESERVE_DEATH_INFO_REGNO_P(x) FP_REGNO_P(x) */\n+\n+/* 1 if register REGNO can magically overlap other regs.\n+   Note that nonzero values work only in very special circumstances. */\n+\n+/* #define OVERLAPPING_REGNO_P(REGNO) FP_REGNO_P (REGNO) */\n+\n+/* The class value for index registers, and the one for base regs.  */\n+\n+#define INDEX_REG_CLASS INDEX_REGS\n+#define BASE_REG_CLASS GENERAL_REGS\n+\n+/* Get reg_class from a letter such as appears in the machine description.  */\n+\n+#define REG_CLASS_FROM_LETTER(C)\t\\\n+  ((C) == 'r' ? GENERAL_REGS :\t\t\\\n+   (C) == 'q' ? Q_REGS :\t\t\\\n+   (C) == 'f' ? FLOAT_REGS :\t\t\\\n+   (C) == 't' ? FP_TOP_REG :\t\t\\\n+   (C) == 'u' ? FP_SECOND_REG :\t\t\\\n+   (C) == 'a' ? AREG :\t\t\t\\\n+   (C) == 'c' ? CREG :\t\t\t\\\n+   (C) == 'd' ? DREG :\t\t\t\\\n+   (C) == 'D' ? DIREG :\t\t\t\\\n+   (C) == 'S' ? SIREG : NO_REGS)\n+\n+/* The letters I, J, K, L and M in a register constraint string\n+   can be used to stand for particular ranges of immediate operands.\n+   This macro defines what the ranges are.\n+   C is the letter, and VALUE is a constant value.\n+   Return 1 if VALUE is in the range specified by C.\n+\n+   I is for non-DImode shifts.\n+   J is for DImode shifts.\n+   K and L are for an `andsi' optimization.\n+   M is for shifts that can be executed by the \"lea\" opcode.\n+   */\n+\n+#define CONST_OK_FOR_LETTER_P(VALUE, C)  \\\n+  ((C) == 'I' ? (VALUE) >= 0 && (VALUE) <= 31 :\t\\\n+   (C) == 'J' ? (VALUE) >= 0 && (VALUE) <= 63 :\t\\\n+   (C) == 'K' ? (VALUE) == 0xff :\t\t\\\n+   (C) == 'L' ? (VALUE) == 0xffff :\t\t\\\n+   (C) == 'M' ? (VALUE) >= 0 && (VALUE) <= 3 :\t\\\n+   0)\n+\n+/* Similar, but for floating constants, and defining letters G and H.\n+   Here VALUE is the CONST_DOUBLE rtx itself.  */\n+\n+#define CONST_DOUBLE_OK_FOR_LETTER_P(VALUE, C)  \\\n+  ((C) == 'G' ? (TARGET_80387 && standard_80387_constant_p (VALUE)) : 0)\n+\n+/* Place additional restrictions on the register class to use when it\n+   is necessary to be able to hold a value of mode @var{mode} in a reload\n+   register for which class @var{class} would ordinarily be used. */\n+\n+#define LIMIT_RELOAD_CLASS(MODE, CLASS) \\\n+  ((MODE) == QImode && ((CLASS) == ALL_REGS || (CLASS) == GENERAL_REGS) \\\n+   ? Q_REGS : (CLASS))\n+\n+/* Given an rtx X being reloaded into a reg required to be\n+   in class CLASS, return the class of reg to actually use.\n+   In general this is just CLASS; but on some machines\n+   in some cases it is preferable to use a more restrictive class.\n+   On the 80386 series, we prevent floating constants from being\n+   reloaded into floating registers (since no move-insn can do that)\n+   and we ensure that QImodes aren't reloaded into the esi or edi reg.  */\n+\n+/* Don't put CONST_DOUBLE into FLOAT_REGS.\n+   QImode must go into class Q_REGS.\n+   MODE_INT must not go into FLOAT_REGS. */\n+\n+#define PREFERRED_RELOAD_CLASS(X,CLASS)\t\t\t\\\n+  (GET_CODE (X) == CONST_DOUBLE\t\t\t\t\\\n+   ? (reg_class_subset_p ((CLASS), GENERAL_REGS) || (CLASS) == ALL_REGS \\\n+      ? (CLASS) : NO_REGS)\t\t\t\t\\\n+   : GET_MODE (X) == QImode\t\t\t\t\\\n+   ? (! reg_class_subset_p ((CLASS), Q_REGS) ? Q_REGS : (CLASS))\t\\\n+   : (GET_MODE_CLASS (GET_MODE (X)) == MODE_INT && (CLASS) == FLOAT_REGS ? \\\n+      GENERAL_REGS : (CLASS)))\n+\n+/* Return the maximum number of consecutive registers\n+   needed to represent mode MODE in a register of class CLASS.  */\n+/* On the 80386, this is the size of MODE in words,\n+   except in the FP regs, where a single reg is always enough.  */\n+#define CLASS_MAX_NREGS(CLASS, MODE)\t\\\n+ ((CLASS) == FLOAT_REGS ? 1 :\t\t\\\n+  (CLASS) == FP_TOP_REG ? 1 :\t\t\\\n+  (CLASS) == FP_SECOND_REG ? 1 :\t\\\n+   ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD))\n+\f\n+/* Stack layout; function entry, exit and calling.  */\n+\n+/* Define this if pushing a word on the stack\n+   makes the stack pointer a smaller address.  */\n+#define STACK_GROWS_DOWNWARD\n+\n+/* Define this if the nominal address of the stack frame\n+   is at the high-address end of the local variables;\n+   that is, each additional local variable allocated\n+   goes at a more negative offset in the frame.  */\n+#define FRAME_GROWS_DOWNWARD\n+\n+/* Offset within stack frame to start allocating local variables at.\n+   If FRAME_GROWS_DOWNWARD, this is the offset to the END of the\n+   first local allocated.  Otherwise, it is the offset to the BEGINNING\n+   of the first local allocated.  */\n+#define STARTING_FRAME_OFFSET 0\n+\n+/* If we generate an insn to push BYTES bytes,\n+   this says how many the stack pointer really advances by.\n+   On 386 pushw decrements by exactly 2 no matter what the position was.\n+   On the 386 there is no pushb; we use pushw instead, and this\n+   has the effect of rounding up to 2.  */\n+\n+#define PUSH_ROUNDING(BYTES) (((BYTES) + 1) & (-2))\n+\n+/* Offset of first parameter from the argument pointer register value.  */\n+#define FIRST_PARM_OFFSET(FNDECL) 0\n+\n+/* Value is the number of bytes of arguments automatically\n+   popped when returning from a subroutine call.\n+   FUNTYPE is the data type of the function (as a tree),\n+   or for a library call it is an identifier node for the subroutine name.\n+   SIZE is the number of bytes of arguments passed on the stack.\n+\n+   On the 80386, the RTD insn may be used to pop them if the number\n+     of args is fixed, but if the number is variable then the caller\n+     must pop them all.  RTD can't be used for library calls now\n+     because the library is compiled with the Unix compiler.\n+   Use of RTD is a selectable option, since it is incompatible with\n+   standard Unix calling sequences.  If the option is not selected,\n+   the caller must always pop the args.  */\n+\n+#define RETURN_POPS_ARGS(FUNTYPE,SIZE)   \\\n+  (TREE_CODE (FUNTYPE) == IDENTIFIER_NODE ? 0\t\t\t\\\n+   : (TARGET_RTD\t\t\t\t\t\t\\\n+      && (TYPE_ARG_TYPES (FUNTYPE) == 0\t\t\t\t\\\n+\t  || (TREE_VALUE (tree_last (TYPE_ARG_TYPES (FUNTYPE)))\t\\\n+\t      == void_type_node))) ? (SIZE)\t\t\t\\\n+   : (aggregate_value_p (FUNTYPE)) ? GET_MODE_SIZE (Pmode) : 0)\n+\n+#define FUNCTION_VALUE(VALTYPE, FUNC)  \\\n+   gen_rtx (REG, TYPE_MODE (VALTYPE), \\\n+\t    VALUE_REGNO (TYPE_MODE (VALTYPE)))\n+\n+/* Define how to find the value returned by a library function\n+   assuming the value has mode MODE.  */\n+\n+#define LIBCALL_VALUE(MODE) \\\n+  gen_rtx (REG, MODE, VALUE_REGNO (MODE))\n+\n+/* 1 if N is a possible register number for function argument passing.\n+   On the 80386, no registers are used in this way.\n+      *NOTE* -mregparm does not work.\n+   It exists only to test register calling conventions.  */\n+\n+#define FUNCTION_ARG_REGNO_P(N) 0\n+\n+/* Define a data type for recording info about an argument list\n+   during the scan of that argument list.  This data type should\n+   hold all necessary information about the function itself\n+   and about the args processed so far, enough to enable macros\n+   such as FUNCTION_ARG to determine where the next arg should go.\n+\n+   On the 80386, this is a single integer, which is a number of bytes\n+   of arguments scanned so far.  */\n+\n+#define CUMULATIVE_ARGS int\n+\n+/* Initialize a variable CUM of type CUMULATIVE_ARGS\n+   for a call to a function whose data type is FNTYPE.\n+   For a library call, FNTYPE is 0.\n+\n+   On the 80386, the offset starts at 0.  */\n+\n+#define INIT_CUMULATIVE_ARGS(CUM,FNTYPE,LIBNAME)\t\\\n+ ((CUM) = 0)\n+\n+/* Update the data in CUM to advance over an argument\n+   of mode MODE and data type TYPE.\n+   (TYPE is null for libcalls where that information may not be available.)  */\n+\n+#define FUNCTION_ARG_ADVANCE(CUM, MODE, TYPE, NAMED)\t\\\n+ ((CUM) += ((MODE) != BLKmode\t\t\t\\\n+\t    ? (GET_MODE_SIZE (MODE) + 3) & ~3\t\\\n+\t    : (int_size_in_bytes (TYPE) + 3) & ~3))\n+\n+/* Define where to put the arguments to a function.\n+   Value is zero to push the argument on the stack,\n+   or a hard register in which to store the argument.\n+\n+   MODE is the argument's machine mode.\n+   TYPE is the data type of the argument (as a tree).\n+    This is null for libcalls where that information may\n+    not be available.\n+   CUM is a variable of type CUMULATIVE_ARGS which gives info about\n+    the preceding args and about the function being called.\n+   NAMED is nonzero if this argument is a named parameter\n+    (otherwise it is an extra parameter matching an ellipsis).  */\n+\n+\n+/* On the 80386 all args are pushed, except if -mregparm is specified\n+   then the first two words of arguments are passed in EAX, EDX.\n+   *NOTE* -mregparm does not work.\n+   It exists only to test register calling conventions.  */\n+\n+#define FUNCTION_ARG(CUM, MODE, TYPE, NAMED) \\\n+((TARGET_REGPARM && (CUM) < 8) ? gen_rtx (REG, (MODE), (CUM) / 4) : 0)\n+\n+/* For an arg passed partly in registers and partly in memory,\n+   this is the number of registers used.\n+   For args passed entirely in registers or entirely in memory, zero.  */\n+\n+\n+#define FUNCTION_ARG_PARTIAL_NREGS(CUM, MODE, TYPE, NAMED) \\\n+((TARGET_REGPARM && (CUM) < 8\t\t\t\t\t\\\n+  && 8 < ((CUM) + ((MODE) == BLKmode\t\t\t\t\\\n+\t\t      ? int_size_in_bytes (TYPE)\t\t\\\n+\t\t      : GET_MODE_SIZE (MODE))))  \t\t\\\n+ ? 2 - (CUM) / 4 : 0)\n+\n+/* This macro generates the assembly code for function entry.\n+   FILE is a stdio stream to output the code to.\n+   SIZE is an int: how many units of temporary storage to allocate.\n+   Refer to the array `regs_ever_live' to determine which registers\n+   to save; `regs_ever_live[I]' is nonzero if register number I\n+   is ever used in the function.  This macro is responsible for\n+   knowing which registers should not be saved even if used.  */\n+\n+#define FUNCTION_PROLOGUE(FILE, SIZE)     \\\n+  function_prologue (FILE, SIZE)\n+\n+/* Output assembler code to FILE to increment profiler label # LABELNO\n+   for profiling a function entry.  */\n+\n+#define FUNCTION_PROFILER(FILE, LABELNO)  \\\n+{\t\t\t\t\t\t\t\t\t\\\n+  if (flag_pic)\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      fprintf (FILE, \"\\tleal %sP%d@GOTOFF(%%ebx),%%edx\\n\",\t\t\\\n+\t       LPREFIX, (LABELNO));\t\t\t\t\t\\\n+      fprintf (FILE, \"\\tcall *_mcount@GOT(%%ebx)\\n\");\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  else\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      fprintf (FILE, \"\\tmovl $%sP%d,%%edx\\n\", LPREFIX, (LABELNO));\t\\\n+      fprintf (FILE, \"\\tcall _mcount\\n\");\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+}\n+\n+/* EXIT_IGNORE_STACK should be nonzero if, when returning from a function,\n+   the stack pointer does not matter.  The value is tested only in\n+   functions that have frame pointers.\n+   No definition is equivalent to always zero.  */\n+/* Note on the 386 it might be more efficient not to define this since \n+   we have to restore it ourselves from the frame pointer, in order to\n+   use pop */\n+\n+#define EXIT_IGNORE_STACK 1\n+\n+/* This macro generates the assembly code for function exit,\n+   on machines that need it.  If FUNCTION_EPILOGUE is not defined\n+   then individual return instructions are generated for each\n+   return statement.  Args are same as for FUNCTION_PROLOGUE.\n+\n+   The function epilogue should not depend on the current stack pointer!\n+   It should use the frame pointer only.  This is mandatory because\n+   of alloca; we also take advantage of it to omit stack adjustments\n+   before returning.\n+\n+   If the last non-note insn in the function is a BARRIER, then there\n+   is no need to emit a function prologue, because control does not fall\n+   off the end.  This happens if the function ends in an \"exit\" call, or\n+   if a `return' insn is emitted directly into the function. */\n+\n+#define FUNCTION_EPILOGUE(FILE, SIZE) \t\t\\\n+do {\t\t\t\t\t\t\\\n+  rtx last = get_last_insn ();\t\t\t\\\n+  if (last && GET_CODE (last) == NOTE)\t\t\\\n+    last = prev_nonnote_insn (last);\t\t\\\n+  if (! last || GET_CODE (last) != BARRIER)\t\\\n+    function_epilogue (FILE, SIZE);\t\t\\\n+} while (0)\n+\n+/* Output assembler code for a block containing the constant parts\n+   of a trampoline, leaving space for the variable parts.  */\n+\n+/* On the 386, the trampoline contains three instructions:\n+     mov #STATIC,ecx\n+     mov #FUNCTION,eax\n+     jmp @eax  */\n+#define TRAMPOLINE_TEMPLATE(FILE)\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  ASM_OUTPUT_CHAR (FILE, gen_rtx (CONST_INT, VOIDmode, 0xb9));\t\t\\\n+  ASM_OUTPUT_SHORT (FILE, const0_rtx);\t\t\t\t\t\\\n+  ASM_OUTPUT_SHORT (FILE, const0_rtx);\t\t\t\t\t\\\n+  ASM_OUTPUT_CHAR (FILE, gen_rtx (CONST_INT, VOIDmode, 0xb8));\t\t\\\n+  ASM_OUTPUT_SHORT (FILE, const0_rtx);\t\t\t\t\t\\\n+  ASM_OUTPUT_SHORT (FILE, const0_rtx);\t\t\t\t\t\\\n+  ASM_OUTPUT_CHAR (FILE, gen_rtx (CONST_INT, VOIDmode, 0xff));\t\t\\\n+  ASM_OUTPUT_CHAR (FILE, gen_rtx (CONST_INT, VOIDmode, 0xe0));\t\t\\\n+}\n+\n+/* Length in units of the trampoline for entering a nested function.  */\n+\n+#define TRAMPOLINE_SIZE 12\n+\n+/* Emit RTL insns to initialize the variable parts of a trampoline.\n+   FNADDR is an RTX for the address of the function's pure code.\n+   CXT is an RTX for the static chain value for the function.  */\n+\n+#define INITIALIZE_TRAMPOLINE(TRAMP, FNADDR, CXT)\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  emit_move_insn (gen_rtx (MEM, SImode, plus_constant (TRAMP, 1)), CXT); \\\n+  emit_move_insn (gen_rtx (MEM, SImode, plus_constant (TRAMP, 6)), FNADDR); \\\n+}\n+\f\n+/* Definitions for register eliminations.\n+\n+   This is an array of structures.  Each structure initializes one pair\n+   of eliminable registers.  The \"from\" register number is given first,\n+   followed by \"to\".  Eliminations of the same \"from\" register are listed\n+   in order of preference.\n+\n+   We have two registers that can be eliminated on the i386.  First, the\n+   frame pointer register can often be eliminated in favor of the stack\n+   pointer register.  Secondly, the argument pointer register can always be\n+   eliminated; it is replaced with either the stack or frame pointer. */\n+\n+#define ELIMINABLE_REGS\t\t\t\t\\\n+{{ ARG_POINTER_REGNUM, STACK_POINTER_REGNUM},\t\\\n+ { ARG_POINTER_REGNUM, FRAME_POINTER_REGNUM},   \\\n+ { FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM}}\n+\n+/* Given FROM and TO register numbers, say whether this elimination is allowed.\n+   Frame pointer elimination is automatically handled.\n+\n+   For the i386, if frame pointer elimination is being done, we would like to\n+   convert ap into sp, not fp.\n+\n+   All other eliminations are valid.  */\n+\n+#define CAN_ELIMINATE(FROM, TO)\t\t\t\t\t\\\n+ ((FROM) == ARG_POINTER_REGNUM && (TO) == STACK_POINTER_REGNUM\t\\\n+  ? ! frame_pointer_needed\t\t\t\t\t\\\n+  : 1)\n+\n+/* Define the offset between two registers, one to be eliminated, and the other\n+   its replacement, at the start of a routine.  */\n+\n+#define INITIAL_ELIMINATION_OFFSET(FROM, TO, OFFSET)\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  if ((FROM) == ARG_POINTER_REGNUM && (TO) == FRAME_POINTER_REGNUM)\t\\\n+    (OFFSET) = 8;\t/* Skip saved PC and previous frame pointer */\t\\\n+  else\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      int regno;\t\t\t\t\t\t\t\\\n+      int offset = 0;\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+      for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\t\t\\\n+\tif ((regs_ever_live[regno] && ! call_used_regs[regno])\t\t\\\n+\t    || (current_function_uses_pic_offset_table\t\t\t\\\n+\t\t&& regno == PIC_OFFSET_TABLE_REGNUM))\t\t\t\\\n+\t  offset += 4;\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+      (OFFSET) = offset + get_frame_size ();\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+      if ((FROM) == ARG_POINTER_REGNUM && (TO) == STACK_POINTER_REGNUM)\t\\\n+\t(OFFSET) += 4;\t/* Skip saved PC */\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+}\n+\f\n+/* Addressing modes, and classification of registers for them.  */\n+\n+/* #define HAVE_POST_INCREMENT */\n+/* #define HAVE_POST_DECREMENT */\n+\n+/* #define HAVE_PRE_DECREMENT */\n+/* #define HAVE_PRE_INCREMENT */\n+\n+/* Macros to check register numbers against specific register classes.  */\n+\n+/* These assume that REGNO is a hard or pseudo reg number.\n+   They give nonzero only if REGNO is a hard reg of the suitable class\n+   or a pseudo reg currently allocated to a suitable hard reg.\n+   Since they use reg_renumber, they are safe only once reg_renumber\n+   has been allocated, which happens in local-alloc.c.  */\n+\n+#define REGNO_OK_FOR_INDEX_P(REGNO) \\\n+  ((REGNO) < STACK_POINTER_REGNUM \\\n+   || (unsigned) reg_renumber[REGNO] < STACK_POINTER_REGNUM)\n+\n+#define REGNO_OK_FOR_BASE_P(REGNO) \\\n+  ((REGNO) <= STACK_POINTER_REGNUM \\\n+   || (REGNO) == ARG_POINTER_REGNUM \\\n+   || (unsigned) reg_renumber[REGNO] <= STACK_POINTER_REGNUM)\n+\n+#define REGNO_OK_FOR_SIREG_P(REGNO) ((REGNO) == 4 || reg_renumber[REGNO] == 4)\n+#define REGNO_OK_FOR_DIREG_P(REGNO) ((REGNO) == 5 || reg_renumber[REGNO] == 5)\n+\n+/* The macros REG_OK_FOR..._P assume that the arg is a REG rtx\n+   and check its validity for a certain class.\n+   We have two alternate definitions for each of them.\n+   The usual definition accepts all pseudo regs; the other rejects\n+   them unless they have been allocated suitable hard regs.\n+   The symbol REG_OK_STRICT causes the latter definition to be used.\n+\n+   Most source files want to accept pseudo regs in the hope that\n+   they will get allocated to the class that the insn wants them to be in.\n+   Source files for reload pass need to be strict.\n+   After reload, it makes no difference, since pseudo regs have\n+   been eliminated by then.  */\n+\n+#ifndef REG_OK_STRICT\n+\n+/* Nonzero if X is a hard reg that can be used as an index or if\n+   it is a pseudo reg.  */\n+\n+#define REG_OK_FOR_INDEX_P(X) \\\n+  (REGNO (X) < STACK_POINTER_REGNUM \\\n+   || REGNO (X) >= FIRST_PSEUDO_REGISTER)\n+\n+/* Nonzero if X is a hard reg that can be used as a base reg\n+   of if it is a pseudo reg.  */\n+  /* ?wfs */\n+\n+#define REG_OK_FOR_BASE_P(X) \\\n+  (REGNO (X) <= STACK_POINTER_REGNUM \\\n+   || REGNO (X) == ARG_POINTER_REGNUM \\\n+   || REGNO(X) >= FIRST_PSEUDO_REGISTER)\n+\n+#define REG_OK_FOR_STRREG_P(X) \\\n+  (REGNO (X) == 4 || REGNO (X) == 5 || REGNO (X) >= FIRST_PSEUDO_REGISTER)\n+\n+#else\n+\n+/* Nonzero if X is a hard reg that can be used as an index.  */\n+#define REG_OK_FOR_INDEX_P(X) REGNO_OK_FOR_INDEX_P (REGNO (X))\n+/* Nonzero if X is a hard reg that can be used as a base reg.  */\n+#define REG_OK_FOR_BASE_P(X) REGNO_OK_FOR_BASE_P (REGNO (X))\n+#define REG_OK_FOR_STRREG_P(X) \\\n+  (REGNO_OK_FOR_DIREG_P (REGNO (X)) || REGNO_OK_FOR_SIREG_P (REGNO (X)))\n+\n+#endif\n+\n+/* GO_IF_LEGITIMATE_ADDRESS recognizes an RTL expression\n+   that is a valid memory address for an instruction.\n+   The MODE argument is the machine mode for the MEM expression\n+   that wants to use this address.\n+\n+   The other macros defined here are used only in GO_IF_LEGITIMATE_ADDRESS,\n+   except for CONSTANT_ADDRESS_P which is usually machine-independent.\n+\n+   See legitimize_pic_address in i386.c for details as to what\n+   constitutes a legitimate address when -fpic is used.  */\n+\n+#define MAX_REGS_PER_ADDRESS 2\n+\n+#define CONSTANT_ADDRESS_P(X)   CONSTANT_P (X)\n+\n+/* Nonzero if the constant value X is a legitimate general operand.\n+   It is given that X satisfies CONSTANT_P or is a CONST_DOUBLE.  */\n+\n+#define LEGITIMATE_CONSTANT_P(X) 1\n+\n+#define GO_IF_INDEXABLE_BASE(X, ADDR)\t\\\n+ if (GET_CODE (X) == REG && REG_OK_FOR_BASE_P (X)) goto ADDR\n+\n+#define LEGITIMATE_INDEX_REG_P(X)   \\\n+  (GET_CODE (X) == REG && REG_OK_FOR_INDEX_P (X))\n+\n+/* Return 1 if X is an index or an index times a scale.  */\n+\n+#define LEGITIMATE_INDEX_P(X)   \\\n+   (LEGITIMATE_INDEX_REG_P (X)\t\t\t\t\\\n+    || (GET_CODE (X) == MULT\t\t\t\t\\\n+\t&& LEGITIMATE_INDEX_REG_P (XEXP (X, 0))\t\t\\\n+\t&& GET_CODE (XEXP (X, 1)) == CONST_INT\t\t\\\n+\t&& (INTVAL (XEXP (X, 1)) == 2\t\t\t\\\n+\t    || INTVAL (XEXP (X, 1)) == 4\t\t\\\n+\t    || INTVAL (XEXP (X, 1)) == 8)))\n+\n+/* Go to ADDR if X is an index term, a base reg, or a sum of those.  */\n+\n+#define GO_IF_INDEXING(X, ADDR)\t\\\n+{ if (LEGITIMATE_INDEX_P (X)) goto ADDR;\t\t\t\t\\\n+  GO_IF_INDEXABLE_BASE (X, ADDR);\t\t\t\t\t\\\n+  if (GET_CODE (X) == PLUS && LEGITIMATE_INDEX_P (XEXP (X, 0)))\t\t\\\n+    { GO_IF_INDEXABLE_BASE (XEXP (X, 1), ADDR); }\t\t\t\\\n+  if (GET_CODE (X) == PLUS && LEGITIMATE_INDEX_P (XEXP (X, 1)))\t\t\\\n+    { GO_IF_INDEXABLE_BASE (XEXP (X, 0), ADDR); } }\n+\n+/* We used to allow this, but it isn't ever used.\n+   || ((GET_CODE (X) == POST_DEC || GET_CODE (X) == POST_INC)\t\t\\\n+       && REG_P (XEXP (X, 0))\t\t\t\t\t\t\\\n+       && REG_OK_FOR_STRREG_P (XEXP (X, 0)))\t\t\t\t\\\n+*/\n+\n+#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR)\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  if (CONSTANT_ADDRESS_P (X)\t\t\t\t\t\t\\\n+      && (! flag_pic || LEGITIMATE_PIC_OPERAND_P (X)))\t\t\t\\\n+    goto ADDR;\t\t\t\t\t\t\t\t\\\n+  GO_IF_INDEXING (X, ADDR);\t\t\t\t\t\t\\\n+  if (GET_CODE (X) == PLUS && CONSTANT_ADDRESS_P (XEXP (X, 1)))\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      rtx x0 = XEXP (X, 0);\t\t\t\t\t\t\\\n+      if (! flag_pic || ! SYMBOLIC_CONST (XEXP (X, 1)))\t\t\t\\\n+\t{ GO_IF_INDEXING (x0, ADDR); }\t\t\t\t\t\\\n+      else if (x0 == pic_offset_table_rtx)\t\t\t\t\\\n+\tgoto ADDR;\t\t\t\t\t\t\t\\\n+      else if (GET_CODE (x0) == PLUS)\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  if (XEXP (x0, 0) == pic_offset_table_rtx)\t\t\t\\\n+\t    { GO_IF_INDEXABLE_BASE (XEXP (x0, 1), ADDR); }\t\t\\\n+\t  if (XEXP (x0, 1) == pic_offset_table_rtx)\t\t\t\\\n+\t    { GO_IF_INDEXABLE_BASE (XEXP (x0, 0), ADDR); }\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+}\n+\n+/* Try machine-dependent ways of modifying an illegitimate address\n+   to be legitimate.  If we find one, return the new, valid address.\n+   This macro is used in only one place: `memory_address' in explow.c.\n+\n+   OLDX is the address as it was before break_out_memory_refs was called.\n+   In some cases it is useful to look at this to decide what needs to be done.\n+\n+   MODE and WIN are passed so that this macro can use\n+   GO_IF_LEGITIMATE_ADDRESS.\n+\n+   It is always safe for this macro to do nothing.  It exists to recognize\n+   opportunities to optimize the output.\n+\n+   For the 80386, we handle X+REG by loading X into a register R and\n+   using R+REG.  R will go in a general reg and indexing will be used.\n+   However, if REG is a broken-out memory address or multiplication,\n+   nothing needs to be done because REG can certainly go in a general reg.\n+\n+   When -fpic is used, special handling is needed for symbolic references.\n+   See comments by legitimize_pic_address in i386.c for details.  */\n+\n+#define LEGITIMIZE_ADDRESS(X,OLDX,MODE,WIN)   \\\n+{ extern rtx legitimize_pic_address ();\t\t\t\t\t\\\n+  int ch = (X) != (OLDX);\t\t\t\t\t\t\\\n+  if (flag_pic && SYMBOLIC_CONST (X))\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      (X) = legitimize_pic_address (X, 0);\t\t\t\t\\\n+      if (memory_address_p (MODE, X))\t\t\t\t\t\\\n+\tgoto WIN;\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  if (GET_CODE (X) == PLUS)\t\t\t\t\t\t\\\n+    { if (GET_CODE (XEXP (X, 0)) == MULT)\t\t\t\t\\\n+\tch = 1, XEXP (X, 0) = force_operand (XEXP (X, 0), 0);\t\t\\\n+      if (GET_CODE (XEXP (X, 1)) == MULT)\t\t\t\t\\\n+\tch = 1, XEXP (X, 1) = force_operand (XEXP (X, 1), 0);\t\t\\\n+      if (ch && GET_CODE (XEXP (X, 1)) == REG\t\t\t\t\\\n+\t  && GET_CODE (XEXP (X, 0)) == REG)\t\t\t\t\\\n+\tgoto WIN;\t\t\t\t\t\t\t\\\n+      if (flag_pic && SYMBOLIC_CONST (XEXP (X, 1)))\t\t\t\\\n+        ch = 1, (X) = legitimize_pic_address (X, 0);\t\t\t\\\n+      if (ch) { GO_IF_LEGITIMATE_ADDRESS (MODE, X, WIN); }\t\t\\\n+      if (GET_CODE (XEXP (X, 0)) == REG)                                \\\n+\t{ register rtx temp = gen_reg_rtx (Pmode);\t\t\t\\\n+\t  register rtx val = force_operand (XEXP (X, 1), temp);\t\t\\\n+\t  if (val != temp) emit_move_insn (temp, val, 0);\t\t\\\n+\t  XEXP (X, 1) = temp;\t\t\t\t\t\t\\\n+\t  goto WIN; }\t\t\t\t\t\t\t\\\n+      else if (GET_CODE (XEXP (X, 1)) == REG)\t\t\t\t\\\n+\t{ register rtx temp = gen_reg_rtx (Pmode);\t\t\t\\\n+\t  register rtx val = force_operand (XEXP (X, 0), temp);\t\t\\\n+\t  if (val != temp) emit_move_insn (temp, val, 0);\t\t\\\n+\t  XEXP (X, 0) = temp;\t\t\t\t\t\t\\\n+\t  goto WIN; }}}\n+\n+/* Nonzero if the constant value X is a legitimate general operand\n+   when generating PIC code.  It is given that flag_pic is on and \n+   that X satisfies CONSTANT_P or is a CONST_DOUBLE.  */\n+\n+#define LEGITIMATE_PIC_OPERAND_P(X) \\\n+  (! SYMBOLIC_CONST (X)\t\t\t\t\t\t\t\\\n+   || (GET_CODE (X) == SYMBOL_REF && CONSTANT_POOL_ADDRESS_P (X)))\n+\n+#define SYMBOLIC_CONST(X)\t\\\n+(GET_CODE (X) == SYMBOL_REF\t\t\t\t\t\t\\\n+ || GET_CODE (X) == LABEL_REF\t\t\t\t\t\t\\\n+ || (GET_CODE (X) == CONST && symbolic_reference_mentioned_p (X)))\n+\n+/* Go to LABEL if ADDR (a legitimate address expression)\n+   has an effect that depends on the machine mode it is used for.\n+   On the 80386, only postdecrement and postincrement address depend thus\n+   (the amount of decrement or increment being the length of the operand).  */\n+#define GO_IF_MODE_DEPENDENT_ADDRESS(ADDR,LABEL)\t\\\n+ if (GET_CODE (ADDR) == POST_INC || GET_CODE (ADDR) == POST_DEC) goto LABEL\n+\f\n+/* Define this macro if references to a symbol must be treated\n+   differently depending on something about the variable or\n+   function named by the symbol (such as what section it is in).\n+\n+   On i386, if using PIC, mark a SYMBOL_REF for a static declaration\n+   so that we may access it directly in the GOT.  */\n+\n+#define ENCODE_SECTION_INFO(DECL) \\\n+do\t\t\t\t\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    if (flag_pic)\t\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\trtx decl_rtl = (TREE_CODE_CLASS (TREE_CODE (DECL)) == 'c'\t\\\n+\t\t\t? TREE_CST_RTL (DECL) : DECL_RTL (DECL));\t\\\n+\tSYMBOL_REF_FLAG (XEXP (decl_rtl, 0)) = ! TREE_PUBLIC (DECL);\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+  }\t\t\t\t\t\t\t\t\t\\\n+while (0)\n+\f\n+/* Specify the machine mode that this machine uses\n+   for the index in the tablejump instruction.  */\n+#define CASE_VECTOR_MODE Pmode\n+\n+/* Define this if the tablejump instruction expects the table\n+   to contain offsets from the address of the table.\n+   Do not define this if the table should contain absolute addresses.  */\n+/* #define CASE_VECTOR_PC_RELATIVE */\n+\n+/* Specify the tree operation to be used to convert reals to integers.\n+   This should be changed to take advantage of fist --wfs ??\n+ */\n+#define IMPLICIT_FIX_EXPR FIX_ROUND_EXPR\n+\n+/* This is the kind of divide that is easiest to do in the general case.  */\n+#define EASY_DIV_EXPR TRUNC_DIV_EXPR\n+\n+/* Define this as 1 if `char' should by default be signed; else as 0.  */\n+#define DEFAULT_SIGNED_CHAR 1\n+\n+/* Max number of bytes we can move from memory to memory\n+   in one reasonably fast instruction.  */\n+#define MOVE_MAX 4\n+\n+/* MOVE_RATIO is the number of move instructions that is better than a\n+   block move.  Make this large on i386, since the block move is very\n+   inefficient with small blocks, and the hard register needs of the\n+   block move require much reload work. */\n+#define MOVE_RATIO 5\n+\n+/* Define this if zero-extension is slow (more than one real instruction).  */\n+/* #define SLOW_ZERO_EXTEND */\n+\n+/* Nonzero if access to memory by bytes is slow and undesirable.  */\n+#define SLOW_BYTE_ACCESS 0\n+\n+/* Define if shifts truncate the shift count\n+   which implies one can omit a sign-extension or zero-extension\n+   of a shift count.  */\n+/* One i386, shifts do truncate the count.  But bit opcodes don't. */\n+\n+/* #define SHIFT_COUNT_TRUNCATED */\n+\n+/* Value is 1 if truncating an integer of INPREC bits to OUTPREC bits\n+   is done just by pretending it is already truncated.  */\n+#define TRULY_NOOP_TRUNCATION(OUTPREC, INPREC) 1\n+\n+/* We assume that the store-condition-codes instructions store 0 for false\n+   and some other value for true.  This is the value stored for true.  */\n+\n+#define STORE_FLAG_VALUE 1\n+\n+/* When a prototype says `char' or `short', really pass an `int'.\n+   (The 386 can't easily push less than an int.)  */\n+\n+#define PROMOTE_PROTOTYPES\n+\n+/* Specify the machine mode that pointers have.\n+   After generation of rtl, the compiler makes no further distinction\n+   between pointers and any other objects of this machine mode.  */\n+#define Pmode SImode\n+\n+/* A function address in a call instruction\n+   is a byte address (for indexing purposes)\n+   so give the MEM rtx a byte's mode.  */\n+#define FUNCTION_MODE QImode\n+\n+/* Define this if addresses of constant functions\n+   shouldn't be put through pseudo regs where they can be cse'd.\n+   Desirable on the 386 because a CALL with a constant address is\n+   not much slower than one with a register address.  */\n+#define NO_FUNCTION_CSE\n+\n+/* Provide the costs of a rtl expression.  This is in the body of a\n+   switch on CODE. */\n+\n+#define RTX_COSTS(X,CODE)\t\t\t\t\\\n+  case MULT:\t\t\t\t\t\t\\\n+    return COSTS_N_INSNS (10);\t\t\t\t\\\n+  case DIV:\t\t\t\t\t\t\\\n+  case UDIV:\t\t\t\t\t\t\\\n+  case MOD:\t\t\t\t\t\t\\\n+  case UMOD:\t\t\t\t\t\t\\\n+    return COSTS_N_INSNS (40);\n+\n+\n+/* Compute the cost of computing a constant rtl expression RTX\n+   whose rtx-code is CODE.  The body of this macro is a portion\n+   of a switch statement.  If the code is computed here,\n+   return it with a return statement.  Otherwise, break from the switch.  */\n+\n+#define CONST_COSTS(RTX,CODE) \\\n+  case CONST_INT:\t\t\t\t\t\t\\\n+  case CONST:\t\t\t\t\t\t\t\\\n+  case LABEL_REF:\t\t\t\t\t\t\\\n+  case SYMBOL_REF:\t\t\t\t\t\t\\\n+    return flag_pic && SYMBOLIC_CONST (RTX) ? 2 : 0;\t\t\\\n+  case CONST_DOUBLE:\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      int code = standard_80387_constant_p (RTX);\t\t\\\n+      return code == 1 ? 0 :\t\t\t\t\t\\\n+\t     code == 2 ? 1 :\t\t\t\t\t\\\n+\t\t\t 2;\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  case PLUS:\t\t\t\t\t\t\t\\\n+    if (GET_CODE (XEXP (RTX, 0)) == REG\t\t\t\t\\\n+        && GET_CODE (XEXP (RTX, 1)) == CONST_INT)\t\t\\\n+      return 1;\n+\n+/* Compute the cost of an address.  This is meant to approximate the size\n+   and/or execution delay of an insn using that address.  If the cost is\n+   approximated by the RTL complexity, including CONST_COSTS above, as\n+   is usually the case for CISC machines, this macro should not be defined.\n+   For aggressively RISCy machines, only one insn format is allowed, so\n+   this macro should be a constant.  The value of this macro only matters\n+   for valid addresses.\n+\n+   For i386, it is better to use a complex address than let gcc copy\n+   the address into a reg and make a new pseudo.  But not if the address\n+   requires to two regs - that would mean more pseudos with longer\n+   lifetimes.  */\n+\n+#define ADDRESS_COST(RTX) \\\n+  ((CONSTANT_P (RTX)\t\t\t\t\t\t\\\n+    || (GET_CODE (RTX) == PLUS && CONSTANT_P (XEXP (RTX, 1))\t\\\n+\t&& REG_P (XEXP (RTX, 0)))) ? 0\t\t\t\t\\\n+   : REG_P (RTX) ? 1\t\t\t\t\t\t\\\n+   : 2)\n+\f\n+/* Tell final.c how to eliminate redundant test instructions.  */\n+\n+/* Here we define machine-dependent flags and fields in cc_status\n+   (see `conditions.h').  */\n+\n+/* Set if the cc value is actually in the 80387, so a floating point\n+   conditional branch must be output.  */\n+#define CC_IN_80387 04000\n+\n+/* Set if the CC value was stored in a nonstandard way, so that\n+   the state of equality is indicated by zero in the carry bit.  */\n+#define CC_Z_IN_NOT_C 010000\n+\n+/* Store in cc_status the expressions\n+   that the condition codes will describe\n+   after execution of an instruction whose pattern is EXP.\n+   Do not alter them if the instruction would not alter the cc's.  */\n+\n+#define NOTICE_UPDATE_CC(EXP, INSN) \\\n+  notice_update_cc((EXP))\n+\n+/* Output a signed jump insn.  Use template NORMAL ordinarily, or\n+   FLOAT following a floating point comparison.\n+   Use NO_OV following an arithmetic insn that set the cc's\n+   before a test insn that was deleted.\n+   NO_OV may be zero, meaning final should reinsert the test insn\n+   because the jump cannot be handled properly without it.  */\n+\n+#define OUTPUT_JUMP(NORMAL, FLOAT, NO_OV)\t\t\t\\\n+{\t\t\t\t\t\t\t\t\\\n+  if (cc_prev_status.flags & CC_IN_80387)\t\t\t\\\n+    return FLOAT;\t\t\t\t\t\t\\\n+  if (cc_prev_status.flags & CC_NO_OVERFLOW)\t\t\t\\\n+    return NO_OV;\t\t\t\t\t\t\\\n+  return NORMAL;\t\t\t\t\t\t\\\n+}\n+\f\n+/* Control the assembler format that we output, to the extent\n+   this does not vary between assemblers.  */\n+\n+/* How to refer to registers in assembler output.\n+   This sequence is indexed by compiler's hard-register-number (see above). */\n+\n+/* In order to refer to the first 8 regs as 32 bit regs prefix an \"e\"\n+   For non floating point regs, the following are the HImode names.\n+\n+   For float regs, the stack top is sometimes referred to as \"%st(0)\"\n+   instead of just \"%st\".  PRINT_REG in i386.c handles with with the\n+   \"y\" code.  */\n+\n+#define HI_REGISTER_NAMES \\\n+{\"ax\",\"dx\",\"cx\",\"bx\",\"si\",\"di\",\"bp\",\"sp\",          \\\n+ \"st\",\"st(1)\",\"st(2)\",\"st(3)\",\"st(4)\",\"st(5)\",\"st(6)\",\"st(7)\",\"\" }\n+\n+#define REGISTER_NAMES HI_REGISTER_NAMES\n+\n+/* Table of additional register names to use in user input.  */\n+\n+#define ADDITIONAL_REGISTER_NAMES \\\n+{ \"eax\", 0, \"edx\", 1, \"ecx\", 2, \"ebx\", 3,\t\\\n+  \"esi\", 4, \"edi\", 5, \"ebp\", 6, \"esp\", 7,\t\\\n+  \"al\", 0, \"dl\", 1, \"cl\", 2, \"bl\", 3,\t\t\\\n+  \"ah\", 0, \"dh\", 1, \"ch\", 2, \"bh\", 3 }\n+\n+/* Note we are omitting these since currently I don't know how\n+to get gcc to use these, since they want the same but different\n+number as al, and ax.\n+*/\n+\n+/* note the last four are not really qi_registsers, but\n+   the md will have to never output movb into one of them\n+   only a movw .  There is no movb into the last four regs */\n+\n+#define QI_REGISTER_NAMES \\\n+{\"al\", \"dl\", \"cl\", \"bl\", \"si\", \"di\", \"bp\", \"sp\",}\n+\n+/* These parallel the array above, and can be used to access bits 8:15\n+   of regs 0 through 3. */\n+\n+#define QI_HIGH_REGISTER_NAMES \\\n+{\"ah\", \"dh\", \"ch\", \"bh\", }\n+\n+/* How to renumber registers for dbx and gdb.  */\n+\n+/* {0,2,1,3,6,7,4,5,12,13,14,15,16,17}  */\n+#define DBX_REGISTER_NUMBER(n) \\\n+((n) == 0 ? 0 : \\\n+ (n) == 1 ? 2 : \\\n+ (n) == 2 ? 1 : \\\n+ (n) == 3 ? 3 : \\\n+ (n) == 4 ? 6 : \\\n+ (n) == 5 ? 7 : \\\n+ (n) == 6 ? 4 : \\\n+ (n) == 7 ? 5 : \\\n+ (n) + 4)\n+\n+/* This is how to output the definition of a user-level label named NAME,\n+   such as the label on a static function or variable NAME.  */\n+\n+#define ASM_OUTPUT_LABEL(FILE,NAME)\t\\\n+  (assemble_name (FILE, NAME), fputs (\":\\n\", FILE))\n+\n+/* This is how to output an assembler line defining a `double' constant.  */\n+\n+#define ASM_OUTPUT_DOUBLE(FILE,VALUE)  \\\n+  fprintf (FILE, \"%s %.22e\\n\", ASM_DOUBLE, (VALUE))\n+\n+\n+/* This is how to output an assembler line defining a `float' constant.  */\n+\n+#define ASM_OUTPUT_FLOAT(FILE,VALUE)  \\\n+do { union { float f; long l;} tem;\t\t\t\\\n+     tem.f = (VALUE);\t\t\t\t\t\\\n+     fprintf((FILE), \"%s 0x%x\\n\", ASM_LONG, tem.l);\t\\\n+   } while (0)\n+\n+\n+/* Store in OUTPUT a string (made with alloca) containing\n+   an assembler-name for a local static variable named NAME.\n+   LABELNO is an integer which is different for each call.  */\n+\n+#define ASM_FORMAT_PRIVATE_NAME(OUTPUT, NAME, LABELNO)\t\\\n+( (OUTPUT) = (char *) alloca (strlen ((NAME)) + 10),\t\\\n+  sprintf ((OUTPUT), \"%s.%d\", (NAME), (LABELNO)))\n+\n+\n+\n+/* This is how to output an assembler line defining an `int' constant.  */\n+\n+#define ASM_OUTPUT_INT(FILE,VALUE)  \\\n+( fprintf (FILE, \"%s \", ASM_LONG),\t\t\\\n+  output_addr_const (FILE,(VALUE)),\t\t\\\n+  putc('\\n',FILE))\n+\n+/* Likewise for `char' and `short' constants.  */\n+/* is this supposed to do align too?? */\n+\n+#define ASM_OUTPUT_SHORT(FILE,VALUE)  \\\n+( fprintf (FILE, \"%s \", ASM_SHORT),\t\t\\\n+  output_addr_const (FILE,(VALUE)),\t\t\\\n+  putc('\\n',FILE))\n+\n+/*\n+#define ASM_OUTPUT_SHORT(FILE,VALUE)  \\\n+( fprintf (FILE, \"%s \", ASM_BYTE_OP),\t\t\\\n+  output_addr_const (FILE,(VALUE)),\t\t\\\n+  fputs (\",\", FILE),\t\t      \t\t\\\n+  output_addr_const (FILE,(VALUE)),\t\t\\\n+  fputs (\" >> 8\\n\",FILE))\n+*/\n+\n+\n+#define ASM_OUTPUT_CHAR(FILE,VALUE)  \\\n+( fprintf (FILE, \"%s \", ASM_BYTE_OP),\t\t\\\n+  output_addr_const (FILE, (VALUE)),\t\t\\\n+  putc ('\\n', FILE))\n+\n+/* This is how to output an assembler line for a numeric constant byte.  */\n+\n+#define ASM_OUTPUT_BYTE(FILE,VALUE)  \\\n+  fprintf ((FILE), \"%s 0x%x\\n\", ASM_BYTE_OP, (VALUE))\n+\n+/* This is how to output an insn to push a register on the stack.\n+   It need not be very fast code.  */\n+\n+#define ASM_OUTPUT_REG_PUSH(FILE,REGNO)  \\\n+  fprintf (FILE, \"\\tpushl e%s\\n\", reg_names[REGNO])\n+\n+/* This is how to output an insn to pop a register from the stack.\n+   It need not be very fast code.  */\n+\n+#define ASM_OUTPUT_REG_POP(FILE,REGNO)  \\\n+  fprintf (FILE, \"\\tpopl e%s\\n\", reg_names[REGNO])\n+\n+/* This is how to output an element of a case-vector that is absolute.\n+     */\n+\n+#define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE)  \\\n+  fprintf (FILE, \"%s %s%d\\n\", ASM_LONG, LPREFIX, VALUE)\n+\n+/* This is how to output an element of a case-vector that is relative.\n+   We don't use these on the 386 yet, because the ATT assembler can't do\n+   forward reference the differences.  \n+ */\n+\n+#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, VALUE, REL) \\\n+  fprintf (FILE, \"\\t.word %s%d-%s%d\\n\",LPREFIX, VALUE,LPREFIX, REL)\n+\n+/* Define the parentheses used to group arithmetic operations\n+   in assembler code.  */\n+\n+#define ASM_OPEN_PAREN \"\"\n+#define ASM_CLOSE_PAREN \"\"\n+\n+/* Define results of standard character escape sequences.  */\n+#define TARGET_BELL 007\n+#define TARGET_BS 010\n+#define TARGET_TAB 011\n+#define TARGET_NEWLINE 012\n+#define TARGET_VT 013\n+#define TARGET_FF 014\n+#define TARGET_CR 015\n+\n+/* Print operand X (an rtx) in assembler syntax to file FILE.\n+   CODE is a letter or dot (`z' in `%z0') or 0 if no letter was specified.\n+   The CODE z takes the size of operand from the following digit, and\n+   outputs b,w,or l respectively.\n+\n+   On the 80386, we use several such letters:\n+   f -- float insn (print a CONST_DOUBLE as a float rather than in hex).\n+   L,W,B,Q,S -- print the opcode suffix for specified size of operand.\n+   R -- print the prefix for register names.\n+   z -- print the opcode suffix for the size of the current operand.\n+   * -- print a star (in certain assembler syntax)\n+   w -- print the operand as if it's a \"word\" (HImode) even if it isn't.\n+   b -- print the operand as if it's a byte (QImode) even if it isn't.\n+   c -- don't print special prefixes before constant operands.  */\n+\n+#define PRINT_OPERAND_PUNCT_VALID_P(CODE)\t\t\t\t\\\n+  ((CODE) == '*')\n+\n+#define PRINT_OPERAND(FILE, X, CODE)  \\\n+  print_operand (FILE, X, CODE)\n+\f\n+\n+#define PRINT_OPERAND_ADDRESS(FILE, ADDR)  \\\n+  print_operand_address (FILE, ADDR)\n+\n+/* Output the prefix for an immediate operand, or for an offset operand.  */\n+#define PRINT_IMMED_PREFIX(FILE)  fputs (IP, (FILE))\n+#define PRINT_OFFSET_PREFIX(FILE)  fputs (IP, (FILE))\n+\n+/* Routines in libgcc that return floats must return them in an fp reg,\n+   just as other functions do which return such values.\n+   These macros make that happen.  */\n+\n+#define FLOAT_VALUE_TYPE float\n+#define INTIFY(FLOATVAL) FLOATVAL\n+\n+/* Nonzero if INSN magically clobbers register REGNO.  */\n+\n+/* #define INSN_CLOBBERS_REGNO_P(INSN, REGNO)\t\\\n+    (FP_REGNO_P (REGNO)\t\t\t\t\\\n+     && (GET_CODE (INSN) == JUMP_INSN || GET_CODE (INSN) == BARRIER))\n+*/\n+\n+/* a letter which is not needed by the normal asm syntax, which\n+   we can use for operand syntax in the extended asm */\n+\n+#define ASM_OPERAND_LETTER '#'\n+\f\n+#define RET return \"\"\n+#define AT_SP(mode) (gen_rtx (MEM, (mode), stack_pointer_rtx))\n+\f\n+/*\n+Local variables:\n+version-control: t\n+End:\n+*/"}]}