{"sha": "7c3e70560bcf162884f414c54720efcd8e68304f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2MzZTcwNTYwYmNmMTYyODg0ZjQxNGM1NDcyMGVmY2Q4ZTY4MzA0Zg==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2015-09-20T06:37:39Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2015-09-20T06:37:39Z"}, "message": "[PATCH] Fix 47679 by improving jump threading\n\n\tPR tree-optimization/47679\n\t* tree-ssa-dom.c (record_temporary_equivalences): No longer static.\n\t* tree-ssa-dom.h (record_temporary_equivalences): Add prototype.\n\t* tree-ssa-threadedge.c: Include tree-ssa-dom.h.\n\t(thread_through_normal_block): Use record_temporary_equivalences.\n\n        PR tree-optimization/47679\n\t* g++.dg/warn/Wuninitialized-6.C: New test.\n\nFrom-SVN: r227942", "tree": {"sha": "87f5dbd47dbca4f2aefeff30e3c2a034cfa4be0b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/87f5dbd47dbca4f2aefeff30e3c2a034cfa4be0b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7c3e70560bcf162884f414c54720efcd8e68304f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7c3e70560bcf162884f414c54720efcd8e68304f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7c3e70560bcf162884f414c54720efcd8e68304f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7c3e70560bcf162884f414c54720efcd8e68304f/comments", "author": null, "committer": null, "parents": [{"sha": "355fe0884b8097c32e859f0df57c83bde0c6bd26", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/355fe0884b8097c32e859f0df57c83bde0c6bd26", "html_url": "https://github.com/Rust-GCC/gccrs/commit/355fe0884b8097c32e859f0df57c83bde0c6bd26"}], "stats": {"total": 356, "additions": 355, "deletions": 1}, "files": [{"sha": "8bb16d04bd37d791e971550e4bcf70a45c9e107f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c3e70560bcf162884f414c54720efcd8e68304f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c3e70560bcf162884f414c54720efcd8e68304f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7c3e70560bcf162884f414c54720efcd8e68304f", "patch": "@@ -1,3 +1,11 @@\n+2015-09-20  Jeff Law  <law@redhat.com>\n+\n+\tPR tree-optimization/47679\n+\t* tree-ssa-dom.c (record_temporary_equivalences): No longer static.\n+\t* tree-ssa-dom.h (record_temporary_equivalences): Add prototype.\n+\t* tree-ssa-threadedge.c: Include tree-ssa-dom.h.\n+\t(thread_through_normal_block): Use record_temporary_equivalences.\n+\n 2015-09-19  Trevor Saunders  <tbsaunde@tbsaunde.org>\n \n \t* coretypes.h (gimple): Change typedef to be a forward"}, {"sha": "74afa641325c705fa67a481d361e9d45b70e2f9b", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c3e70560bcf162884f414c54720efcd8e68304f/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c3e70560bcf162884f414c54720efcd8e68304f/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=7c3e70560bcf162884f414c54720efcd8e68304f", "patch": "@@ -1,3 +1,8 @@\n+2015-09-20  Jeff Law  <law@redhat.com>\n+\n+        PR tree-optimization/47679\n+\t* g++.dg/warn/Wuninitialized-6.C: New test.\n+\n 2015-09-18  Ville Voutilainen  <ville.voutilainen@gmail.com>\n \n \tImplement nested namespace definitions."}, {"sha": "771752c7562c727447a60d2021e11905e431cd2b", "filename": "gcc/testsuite/g++.dg/warn/Wuninitialized-6.C", "status": "added", "additions": 333, "deletions": 0, "changes": 333, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c3e70560bcf162884f414c54720efcd8e68304f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWuninitialized-6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c3e70560bcf162884f414c54720efcd8e68304f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWuninitialized-6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWuninitialized-6.C?ref=7c3e70560bcf162884f414c54720efcd8e68304f", "patch": "@@ -0,0 +1,333 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-Wuninitialized -O2\" } */\n+\n+namespace std {\n+     typedef __SIZE_TYPE__ size_t;\n+   }\n+    extern \"C++\" {\n+   inline void* operator new(std::size_t, void* __p) throw() {\n+  return __p;\n+  }\n+   }\n+    namespace boost{\n+      __extension__ typedef long long long_long_type;\n+   }\n+    namespace mpl_ {\n+   namespace aux {\n+ }\n+   }\n+    namespace boost {\n+   namespace mpl {\n+  using namespace mpl_;\n+  }\n+  }\n+    namespace mpl_ {\n+   struct integral_c_tag {\n+  };\n+   template< int N > struct int_ {\n+  };\n+   }\n+    namespace boost {\n+   namespace mpl {\n+ }\n+  }\n+    namespace mpl_ {\n+   template< bool C_ > struct bool_;\n+   typedef bool_<true> true_;\n+   typedef bool_<false> false_;\n+   }\n+    namespace mpl_ {\n+   template< bool C_ > struct bool_ {\n+      static const bool value = C_;\n+  };\n+   template< typename T, T N > struct integral_c {\n+      static const T value = N;\n+  };\n+   }\n+    namespace boost{\n+   template <class T, T val> struct integral_constant : public mpl::integral_c<T, val> {\n+  };\n+   template<> struct integral_constant<bool,false> : public mpl::false_ {\n+     typedef integral_constant<bool,false> type;\n+  };\n+   template< typename T > struct is_lvalue_reference : ::boost::integral_constant<bool,false> {\n+  };\n+   template< typename T > struct is_rvalue_reference : ::boost::integral_constant<bool,false> {\n+  };\n+   namespace type_traits {\n+  template <bool b1, bool b2, bool b3 = false, bool b4 = false, bool b5 = false, bool b6 = false, bool b7 = false> struct ice_or;\n+  template <> struct ice_or<false, false, false, false, false, false, false> {\n+     static const bool value = false;\n+ };\n+  }\n+   }\n+    namespace boost {\n+   namespace detail {\n+  template <typename T> struct is_reference_impl {\n+    static const bool value = (::boost::type_traits::ice_or< ::boost::is_lvalue_reference<T>::value, ::boost::is_rvalue_reference<T>::value >::value)                  ;\n+ };\n+  }\n+   template< typename T > struct is_reference : ::boost::integral_constant<bool,::boost::detail::is_reference_impl<T>::value> {\n+  };\n+   namespace detail {\n+  template< typename T > struct alignment_of_impl {\n+    static const std::size_t value = __alignof__(T);\n+ };\n+  }\n+   template< typename T > struct alignment_of : ::boost::integral_constant<std::size_t,::boost::detail::alignment_of_impl<T>::value> {\n+  };\n+   }\n+    namespace mpl_ {\n+   struct na {\n+  };\n+   }\n+    namespace boost {\n+   namespace mpl {\n+  }\n+  }\n+    namespace boost {\n+   namespace mpl {\n+  template<       bool C     , typename T1     , typename T2     > struct if_c {\n+     typedef T1 type;\n+ };\n+  template<       typename T1     , typename T2     > struct if_c<false,T1,T2> {\n+     typedef T2 type;\n+ };\n+  template<       typename T1 = na     , typename T2 = na     , typename T3 = na     > struct if_ {\n+  private:     typedef if_c<           static_cast<bool>(T1::value)         , T2         , T3         > almost_type_;\n+  public:     typedef typename almost_type_::type type;\n+ };\n+  }\n+  }\n+    namespace boost{\n+   template <bool x> struct STATIC_ASSERTION_FAILURE;\n+   template <> struct STATIC_ASSERTION_FAILURE<true> {\n+  };\n+   template<int x> struct static_assert_test{\n+ };\n+   namespace detail {\n+  class alignment_dummy;\n+  typedef void (*function_ptr)();\n+  typedef int (alignment_dummy::*member_ptr);\n+  typedef int (alignment_dummy::*member_function_ptr)();\n+  template <bool found, std::size_t target, class TestType> struct lower_alignment_helper {\n+     typedef char type;\n+     enum { value = true };\n+ };\n+  template <std::size_t target, class TestType> struct lower_alignment_helper<false,target,TestType> {\n+     enum { value = (alignment_of<TestType>::value == target) };\n+     typedef typename mpl::if_c<value, TestType, char>::type type;\n+ };\n+  template <typename T> struct has_one_T {\n+   T data;\n+ };\n+  template <std::size_t target> union lower_alignment {\n+     enum { found0 = false };\n+  typename lower_alignment_helper< found0,target,char >::type t0;\n+ enum { found1 = lower_alignment_helper<found0,target,char >::value };\n+ typename lower_alignment_helper< found1,target,short >::type t1;\n+ enum { found2 = lower_alignment_helper<found1,target,short >::value };\n+ typename lower_alignment_helper< found2,target,int >::type t2;\n+ enum { found3 = lower_alignment_helper<found2,target,int >::value };\n+ typename lower_alignment_helper< found3,target,long >::type t3;\n+ enum { found4 = lower_alignment_helper<found3,target,long >::value };\n+ typename lower_alignment_helper< found4,target,::boost::long_long_type >::type t4;\n+ enum { found5 = lower_alignment_helper<found4,target,::boost::long_long_type >::value };\n+ typename lower_alignment_helper< found5,target,float >::type t5;\n+ enum { found6 = lower_alignment_helper<found5,target,float >::value };\n+ typename lower_alignment_helper< found6,target,double >::type t6;\n+ enum { found7 = lower_alignment_helper<found6,target,double >::value };\n+ typename lower_alignment_helper< found7,target,long double >::type t7;\n+ enum { found8 = lower_alignment_helper<found7,target,long double >::value };\n+ typename lower_alignment_helper< found8,target,void* >::type t8;\n+ enum { found9 = lower_alignment_helper<found8,target,void* >::value };\n+ typename lower_alignment_helper< found9,target,function_ptr >::type t9;\n+ enum { found10 = lower_alignment_helper<found9,target,function_ptr >::value };\n+ typename lower_alignment_helper< found10,target,member_ptr >::type t10;\n+ enum { found11 = lower_alignment_helper<found10,target,member_ptr >::value };\n+ typename lower_alignment_helper< found11,target,member_function_ptr >::type t11;\n+ enum { found12 = lower_alignment_helper<found11,target,member_function_ptr >::value };\n+ typename lower_alignment_helper< found12,target,boost::detail::has_one_T< char > >::type t12;\n+ enum { found13 = lower_alignment_helper<found12,target,boost::detail::has_one_T< char > >::value };\n+ typename lower_alignment_helper< found13,target,boost::detail::has_one_T< short > >::type t13;\n+ enum { found14 = lower_alignment_helper<found13,target,boost::detail::has_one_T< short > >::value };\n+ typename lower_alignment_helper< found14,target,boost::detail::has_one_T< int > >::type t14;\n+ enum { found15 = lower_alignment_helper<found14,target,boost::detail::has_one_T< int > >::value };\n+ typename lower_alignment_helper< found15,target,boost::detail::has_one_T< long > >::type t15;\n+ enum { found16 = lower_alignment_helper<found15,target,boost::detail::has_one_T< long > >::value };\n+ typename lower_alignment_helper< found16,target,boost::detail::has_one_T< ::boost::long_long_type > >::type t16;\n+ enum { found17 = lower_alignment_helper<found16,target,boost::detail::has_one_T< ::boost::long_long_type > >::value };\n+ typename lower_alignment_helper< found17,target,boost::detail::has_one_T< float > >::type t17;\n+ enum { found18 = lower_alignment_helper<found17,target,boost::detail::has_one_T< float > >::value };\n+ typename lower_alignment_helper< found18,target,boost::detail::has_one_T< double > >::type t18;\n+ enum { found19 = lower_alignment_helper<found18,target,boost::detail::has_one_T< double > >::value };\n+ typename lower_alignment_helper< found19,target,boost::detail::has_one_T< long double > >::type t19;\n+ enum { found20 = lower_alignment_helper<found19,target,boost::detail::has_one_T< long double > >::value };\n+ typename lower_alignment_helper< found20,target,boost::detail::has_one_T< void* > >::type t20;\n+ enum { found21 = lower_alignment_helper<found20,target,boost::detail::has_one_T< void* > >::value };\n+ typename lower_alignment_helper< found21,target,boost::detail::has_one_T< function_ptr > >::type t21;\n+ enum { found22 = lower_alignment_helper<found21,target,boost::detail::has_one_T< function_ptr > >::value };\n+ typename lower_alignment_helper< found22,target,boost::detail::has_one_T< member_ptr > >::type t22;\n+ enum { found23 = lower_alignment_helper<found22,target,boost::detail::has_one_T< member_ptr > >::value };\n+ typename lower_alignment_helper< found23,target,boost::detail::has_one_T< member_function_ptr > >::type t23;\n+ enum { found24 = lower_alignment_helper<found23,target,boost::detail::has_one_T< member_function_ptr > >::value };\n+ };\n+  union max_align {\n+ };\n+  template<std::size_t TAlign, std::size_t Align> struct is_aligned {\n+     static const bool value = (TAlign >= Align) & (TAlign % Align == 0)          ;\n+ };\n+  template <std::size_t Align> class type_with_alignment_imp {\n+     typedef ::boost::detail::lower_alignment<Align> t1;\n+     typedef typename mpl::if_c<           ::boost::detail::is_aligned< ::boost::alignment_of<t1>::value,Align >::value         , t1         , ::boost::detail::max_align         >::type align_t;\n+     static const std::size_t found = alignment_of<align_t>::value;\n+     typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((found >= Align) == 0 ? false : true) >)> boost_static_assert_typedef_206;\n+     typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((found % Align == 0) == 0 ? false : true) >)> boost_static_assert_typedef_207;\n+  public:     typedef align_t type;\n+ };\n+  }\n+   template <std::size_t Align> class type_with_alignment   : public ::boost::detail::type_with_alignment_imp<Align> {\n+  };\n+   }\n+    namespace boost {\n+   namespace detail{\n+  }\n+   template< typename T > struct remove_reference {\n+  };\n+   }\n+    namespace boost {\n+   namespace mpl {\n+  namespace aux {\n+ template< typename T > struct nested_type_wknd     : T::type { };\n+ }\n+ }\n+   namespace mpl {\n+  namespace aux {\n+ template< long C_ > struct not_impl     : bool_<!C_> { };\n+ }\n+  template<       typename T = na     > struct not_     : aux::not_impl<           ::boost::mpl::aux::nested_type_wknd<T>::value         > {\n+ };\n+  }\n+   namespace detail {\n+  template <typename T> struct make_reference_content {\n+     typedef T type;\n+ };\n+  }\n+   namespace detail {\n+  struct none_helper{\n+};\n+  }\n+   typedef int detail::none_helper::*none_t ;\n+   }\n+    namespace boost_optional_detail {\n+     template <class T, class Factory>   inline void construct(Factory const& factory, void* address)   {\n+    }\n+   }\n+    namespace boost {\n+   class in_place_factory_base ;\n+   class typed_in_place_factory_base ;\n+   namespace optional_detail {\n+  template <class T> class aligned_storage {\n+     union     __attribute__((may_alias))     dummy_u     {         char data[ sizeof(T) ];         typename type_with_alignment<           ::boost::alignment_of<T>::value >::type aligner_;     }\n+ dummy_ ;\n+   public:     void const* address() const { return &dummy_; }\n+     void * address() { return &dummy_; }\n+ }\n+  ;\n+  template<class T> struct types_when_isnt_ref {\n+   typedef T const& reference_const_type ;\n+   typedef T & reference_type ;\n+   typedef T const* pointer_const_type ;\n+   typedef T * pointer_type ;\n+   typedef T const& argument_type ;\n+ }\n+  ;\n+  template<class T> struct types_when_is_ref {\n+   typedef typename remove_reference<T>::type raw_type ;\n+   typedef raw_type& reference_const_type ;\n+   typedef raw_type& argument_type ;\n+ }\n+  ;\n+  struct optional_tag {\n+}\n+  ;\n+  template<class T> struct optional_base : public optional_tag {\n+     typedef     typename     ::boost::detail::make_reference_content<T>::type internal_type ;\n+     typedef aligned_storage<internal_type> storage_type ;\n+     typedef types_when_isnt_ref<T> types_when_not_ref ;\n+     typedef types_when_is_ref<T> types_when_ref ;\n+     typedef optional_base<T> this_type ;\n+     typedef T value_type ;\n+     typedef mpl::true_ is_reference_tag ;\n+     typedef mpl::false_ is_not_reference_tag ;\n+     typedef typename is_reference<T>::type is_reference_predicate ;\n+     typedef typename mpl::if_<is_reference_predicate,types_when_ref,types_when_not_ref>::type types ;\n+     typedef bool (this_type::*unspecified_bool_type)() const;\n+     typedef typename types::reference_type reference_type ;\n+     typedef typename types::reference_const_type reference_const_type ;\n+     typedef typename types::pointer_type pointer_type ;\n+     typedef typename types::pointer_const_type pointer_const_type ;\n+     typedef typename types::argument_type argument_type ;\n+     optional_base() : m_initialized(false) {}\n+     optional_base ( argument_type val ) : m_initialized(false)     {       construct(val);     }\n+     optional_base ( bool cond, argument_type val ) : m_initialized(false)     {       if ( cond )         construct(val);     }\n+     optional_base ( optional_base const& rhs )       :       m_initialized(false)     {       if ( rhs.is_initialized() )         construct(rhs.get_impl());     }\n+     pointer_const_type get_ptr() const { return m_initialized ? get_ptr_impl() : 0 ; }\n+     pointer_type get_ptr() { return m_initialized ? get_ptr_impl() : 0 ; }\n+     bool is_initialized() const { return m_initialized ; }\n+     void construct ( argument_type val )      {        new (m_storage.address()) internal_type(val) ;        m_initialized = true ;      }\n+     template<class Expr>     void construct ( Expr const& factory, in_place_factory_base const* )      {        typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((::boost::mpl::not_<is_reference_predicate>::value) == 0 ? false : true) >)> boost_static_assert_typedef_355 ;        boost_optional_detail::construct<value_type>(factory, m_storage.address());        m_initialized = true ;      }\n+     template<class Expr>     void construct ( Expr const& factory, typed_in_place_factory_base const* )      {        typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((::boost::mpl::not_<is_reference_predicate>::value) == 0 ? false : true) >)> boost_static_assert_typedef_364 ;        factory.apply(m_storage.address()) ;        m_initialized = true ;      }\n+     void destroy()     {     }\n+     unspecified_bool_type safe_bool() const { return m_initialized ? &this_type::is_initialized : 0 ; }\n+     reference_const_type get_impl() const { return dereference(get_object(), is_reference_predicate() ) ; }\n+     reference_type get_impl() { return dereference(get_object(), is_reference_predicate() ) ; }\n+     pointer_const_type get_ptr_impl() const { return cast_ptr(get_object(), is_reference_predicate() ) ; }\n+     pointer_type get_ptr_impl() { return cast_ptr(get_object(), is_reference_predicate() ) ; }\n+     internal_type const* get_object() const     {         union { void const* ap_pvoid; internal_type const* as_ptype; } caster = { m_storage.address() };         return caster.as_ptype;     }\n+     internal_type * get_object()     {         union { void* ap_pvoid; internal_type* as_ptype; } caster = { m_storage.address() };         return caster.as_ptype;     }\n+     reference_const_type dereference( internal_type const* p, is_not_reference_tag ) const { return *p ; }\n+     pointer_type cast_ptr( internal_type * p, is_reference_tag ) { return &p->get() ; }\n+     bool m_initialized ;\n+     storage_type m_storage ;\n+ }\n+  ;\n+  }\n+   template<class T> class optional : public optional_detail::optional_base<T> {\n+      typedef optional_detail::optional_base<T> base ;\n+    public :     typedef optional<T> this_type ;\n+      typedef typename base::reference_const_type reference_const_type ;\n+      reference_const_type get() const {\n+ (static_cast<void> (0)) ;\n+ return this->get_impl();\n+ }\n+      reference_const_type operator *() const {\n+ return this->get() ;\n+ }\n+      bool operator!() const {\n+ return !this->is_initialized() ;\n+ }\n+  }\n+   ;\n+   template<class OptionalPointee> inline bool equal_pointees2 ( OptionalPointee const& x, OptionalPointee const& y ) {\n+    return (!x) != (!y) ? false : ( !x ? true : (*x) == (*y) ) ;\n+  }\n+   template<class T> inline bool operator == ( optional<T> const& x, optional<T> const& y ) {\n+  return equal_pointees2(x,y);\n+  }\n+   template<class T> inline bool operator != ( optional<T> const& x, optional<T> const& y ) {\n+  return !( x == y ) ;\n+  }\n+   }\n+    ::boost::optional< std::size_t > getitem();\n+    class BAR {\n+   public:     int FOO();\n+   private:     ::boost::optional< std::size_t > m_aHoveredItem;\n+   };\n+    int BAR::FOO() {\n+          ::boost::optional< std::size_t > aOldItem(getitem());\n+          ::boost::optional< std::size_t > aNewItem(m_aHoveredItem);\n+          if (aOldItem != aNewItem)             return 1;\n+\treturn 0;\n+   }\n+ "}, {"sha": "2c51e365b0c7d637cd5b7b05687e5efd1679b295", "filename": "gcc/tree-ssa-dom.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c3e70560bcf162884f414c54720efcd8e68304f/gcc%2Ftree-ssa-dom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c3e70560bcf162884f414c54720efcd8e68304f/gcc%2Ftree-ssa-dom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.c?ref=7c3e70560bcf162884f414c54720efcd8e68304f", "patch": "@@ -780,7 +780,7 @@ dom_valueize (tree t)\n    by traversing edge E (which are cached in E->aux).\n \n    Callers are responsible for managing the unwinding markers.  */\n-static void\n+void\n record_temporary_equivalences (edge e,\n \t\t\t       class const_and_copies *const_and_copies,\n \t\t\t       class avail_exprs_stack *avail_exprs_stack)"}, {"sha": "15a2d166fdafeb2dd157ab541220e4c438889d1f", "filename": "gcc/tree-ssa-dom.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c3e70560bcf162884f414c54720efcd8e68304f/gcc%2Ftree-ssa-dom.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c3e70560bcf162884f414c54720efcd8e68304f/gcc%2Ftree-ssa-dom.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.h?ref=7c3e70560bcf162884f414c54720efcd8e68304f", "patch": "@@ -21,5 +21,8 @@ along with GCC; see the file COPYING3.  If not see\n #define GCC_TREE_SSA_DOM_H\n \n extern bool simple_iv_increment_p (gimple *);\n+extern void record_temporary_equivalences (edge,\n+\t\t\t\t\t   class const_and_copies *,\n+\t\t\t\t\t   class avail_exprs_stack *);\n \n #endif /* GCC_TREE_SSA_DOM_H */"}, {"sha": "c58b5e354080bafd4212cd2043b6a929d3725706", "filename": "gcc/tree-ssa-threadedge.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c3e70560bcf162884f414c54720efcd8e68304f/gcc%2Ftree-ssa-threadedge.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c3e70560bcf162884f414c54720efcd8e68304f/gcc%2Ftree-ssa-threadedge.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadedge.c?ref=7c3e70560bcf162884f414c54720efcd8e68304f", "patch": "@@ -44,6 +44,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-ssa-scopedtables.h\"\n #include \"tree-ssa-threadedge.h\"\n #include \"tree-ssa-loop.h\"\n+#include \"tree-ssa-dom.h\"\n #include \"builtins.h\"\n #include \"cfganal.h\"\n \n@@ -1213,6 +1214,10 @@ thread_through_normal_block (edge e,\n   if (*backedge_seen_p)\n     simplify = dummy_simplify;\n \n+  /* We want to record any equivalences created by traversing E.  */\n+  if (!handle_dominating_asserts)\n+    record_temporary_equivalences (e, const_and_copies, avail_exprs_stack);\n+\n   /* PHIs create temporary equivalences.\n      Note that if we found a PHI that made the block non-threadable, then\n      we need to bubble that up to our caller in the same manner we do"}]}