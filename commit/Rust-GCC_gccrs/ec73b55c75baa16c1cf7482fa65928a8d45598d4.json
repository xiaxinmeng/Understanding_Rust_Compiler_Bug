{"sha": "ec73b55c75baa16c1cf7482fa65928a8d45598d4", "node_id": "C_kwDOANBUbNoAKGVjNzNiNTVjNzViYWExNmMxY2Y3NDgyZmE2NTkyOGE4ZDQ1NTk4ZDQ", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2022-11-24T09:38:42Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2022-11-24T09:38:42Z"}, "message": "libstdc++: Another merge from fast_float upstream [PR107468]\n\nUpstream fast_float came up with a cheaper test for\nfegetround () == FE_TONEAREST using one float addition, one subtraction\nand one comparison.  If we know we are rounding to nearest, we can use\nfast path in more cases as before.\nThe following patch merges those changes into libstdc++.\n\n2022-11-24  Jakub Jelinek  <jakub@redhat.com>\n\n\tPR libstdc++/107468\n\t* src/c++17/fast_float/MERGE: Adjust for merge from upstream.\n\t* src/c++17/fast_float/fast_float.h: Merge from fast_float\n\t2ef9abbcf6a11958b6fa685a89d0150022e82e78 commit.", "tree": {"sha": "cf9fa65f5e75a84d8d8e7495d7672a86f0b36cd3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cf9fa65f5e75a84d8d8e7495d7672a86f0b36cd3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ec73b55c75baa16c1cf7482fa65928a8d45598d4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec73b55c75baa16c1cf7482fa65928a8d45598d4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ec73b55c75baa16c1cf7482fa65928a8d45598d4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec73b55c75baa16c1cf7482fa65928a8d45598d4/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d1389be011f0fac422e98e795c55156052c4d960", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d1389be011f0fac422e98e795c55156052c4d960", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d1389be011f0fac422e98e795c55156052c4d960"}], "stats": {"total": 132, "additions": 111, "deletions": 21}, "files": [{"sha": "82cca63704c0f7a6832125470c010d0dab0c52c9", "filename": "libstdc++-v3/src/c++17/fast_float/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec73b55c75baa16c1cf7482fa65928a8d45598d4/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2Ffast_float%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec73b55c75baa16c1cf7482fa65928a8d45598d4/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2Ffast_float%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2Ffast_float%2FMERGE?ref=ec73b55c75baa16c1cf7482fa65928a8d45598d4", "patch": "@@ -1,4 +1,4 @@\n-662497742fea7055f0e0ee27e5a7ddc382c2c38e\n+2ef9abbcf6a11958b6fa685a89d0150022e82e78\n \n The first line of this file holds the git revision number of the\n last merge done from the master library sources."}, {"sha": "7551c4f89ef7b89c638995852e086109c1f43b4f", "filename": "libstdc++-v3/src/c++17/fast_float/fast_float.h", "status": "modified", "additions": 110, "deletions": 20, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec73b55c75baa16c1cf7482fa65928a8d45598d4/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2Ffast_float%2Ffast_float.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec73b55c75baa16c1cf7482fa65928a8d45598d4/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2Ffast_float%2Ffast_float.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2Ffast_float%2Ffast_float.h?ref=ec73b55c75baa16c1cf7482fa65928a8d45598d4", "patch": "@@ -99,21 +99,21 @@ from_chars_result from_chars_advanced(const char *first, const char *last,\n        || defined(__MINGW64__)                                          \\\n        || defined(__s390x__)                                            \\\n        || (defined(__ppc64__) || defined(__PPC64__) || defined(__ppc64le__) || defined(__PPC64LE__)) )\n-#define FASTFLOAT_64BIT\n+#define FASTFLOAT_64BIT 1\n #elif (defined(__i386) || defined(__i386__) || defined(_M_IX86)   \\\n      || defined(__arm__) || defined(_M_ARM)                   \\\n      || defined(__MINGW32__) || defined(__EMSCRIPTEN__))\n-#define FASTFLOAT_32BIT\n+#define FASTFLOAT_32BIT 1\n #else\n   // Need to check incrementally, since SIZE_MAX is a size_t, avoid overflow.\n   // We can never tell the register width, but the SIZE_MAX is a good approximation.\n   // UINTPTR_MAX and INTPTR_MAX are optional, so avoid them for max portability.\n   #if SIZE_MAX == 0xffff\n     #error Unknown platform (16-bit, unsupported)\n   #elif SIZE_MAX == 0xffffffff\n-    #define FASTFLOAT_32BIT\n+    #define FASTFLOAT_32BIT 1\n   #elif SIZE_MAX == 0xffffffffffffffff\n-    #define FASTFLOAT_64BIT\n+    #define FASTFLOAT_64BIT 1\n   #else\n     #error Unknown platform (not 32-bit, not 64-bit?)\n   #endif\n@@ -359,10 +359,12 @@ template <typename T> struct binary_format {\n   static inline constexpr int minimum_exponent();\n   static inline constexpr int infinite_power();\n   static inline constexpr int sign_index();\n+  static inline constexpr int min_exponent_fast_path(); // used when fegetround() == FE_TONEAREST\n   static inline constexpr int max_exponent_fast_path();\n   static inline constexpr int max_exponent_round_to_even();\n   static inline constexpr int min_exponent_round_to_even();\n   static inline constexpr uint64_t max_mantissa_fast_path(int64_t power);\n+  static inline constexpr uint64_t max_mantissa_fast_path(); // used when fegetround() == FE_TONEAREST\n   static inline constexpr int largest_power_of_ten();\n   static inline constexpr int smallest_power_of_ten();\n   static inline constexpr T exact_power_of_ten(int64_t power);\n@@ -372,6 +374,22 @@ template <typename T> struct binary_format {\n   static inline constexpr equiv_uint hidden_bit_mask();\n };\n \n+template <> inline constexpr int binary_format<double>::min_exponent_fast_path() {\n+#if (FLT_EVAL_METHOD != 1) && (FLT_EVAL_METHOD != 0)\n+  return 0;\n+#else\n+  return -22;\n+#endif\n+}\n+\n+template <> inline constexpr int binary_format<float>::min_exponent_fast_path() {\n+#if (FLT_EVAL_METHOD != 1) && (FLT_EVAL_METHOD != 0)\n+  return 0;\n+#else\n+  return -10;\n+#endif\n+}\n+\n template <> inline constexpr int binary_format<double>::mantissa_explicit_bits() {\n   return 52;\n }\n@@ -418,13 +436,18 @@ template <> inline constexpr int binary_format<double>::max_exponent_fast_path()\n template <> inline constexpr int binary_format<float>::max_exponent_fast_path() {\n   return 10;\n }\n-\n+template <> inline constexpr uint64_t binary_format<double>::max_mantissa_fast_path() {\n+  return uint64_t(2) << mantissa_explicit_bits();\n+}\n template <> inline constexpr uint64_t binary_format<double>::max_mantissa_fast_path(int64_t power) {\n   // caller is responsible to ensure that\n   // power >= 0 && power <= 22\n   //\n   return max_mantissa_double[power];\n }\n+template <> inline constexpr uint64_t binary_format<float>::max_mantissa_fast_path() {\n+  return uint64_t(2) << mantissa_explicit_bits();\n+}\n template <> inline constexpr uint64_t binary_format<float>::max_mantissa_fast_path(int64_t power) {\n   // caller is responsible to ensure that\n   // power >= 0 && power <= 10\n@@ -619,10 +642,6 @@ parsed_number_string parse_number_string(const char *p, const char *pend, parse_\n \n   uint64_t i = 0; // an unsigned int avoids signed overflows (which are bad)\n \n-  while ((std::distance(p, pend) >= 8) && is_made_of_eight_digits_fast(p)) {\n-    i = i * 100000000 + parse_eight_digits_unrolled(p); // in rare cases, this will overflow, but that's ok\n-    p += 8;\n-  }\n   while ((p != pend) && is_integer(*p)) {\n     // a multiplication by 10 is cheaper than an arbitrary integer\n     // multiplication\n@@ -1640,7 +1659,7 @@ namespace fast_float {\n // we might have platforms where `CHAR_BIT` is not 8, so let's avoid\n // doing `8 * sizeof(limb)`.\n #if defined(FASTFLOAT_64BIT) && !defined(__sparc)\n-#define FASTFLOAT_64BIT_LIMB\n+#define FASTFLOAT_64BIT_LIMB 1\n typedef uint64_t limb;\n constexpr size_t limb_bits = 64;\n #else\n@@ -2314,10 +2333,6 @@ parsed_number_string parse_number_string(const char *p, const char *pend, parse_\n \n   uint64_t i = 0; // an unsigned int avoids signed overflows (which are bad)\n \n-  while ((std::distance(p, pend) >= 8) && is_made_of_eight_digits_fast(p)) {\n-    i = i * 100000000 + parse_eight_digits_unrolled(p); // in rare cases, this will overflow, but that's ok\n-    p += 8;\n-  }\n   while ((p != pend) && is_integer(*p)) {\n     // a multiplication by 10 is cheaper than an arbitrary integer\n     // multiplication\n@@ -2892,6 +2907,48 @@ from_chars_result parse_infnan(const char *first, const char *last, T &value)  n\n   return answer;\n }\n \n+/**\n+ * Returns true if the floating-pointing rounding mode is to 'nearest'.\n+ * It is the default on most system. This function is meant to be inexpensive.\n+ * Credit : @mwalcott3\n+ */\n+fastfloat_really_inline bool rounds_to_nearest() noexcept {\n+  // See\n+  // A fast function to check your floating-point rounding mode\n+  // https://lemire.me/blog/2022/11/16/a-fast-function-to-check-your-floating-point-rounding-mode/\n+  //\n+  // This function is meant to be equivalent to :\n+  // prior: #include <cfenv>\n+  //  return fegetround() == FE_TONEAREST;\n+  // However, it is expected to be much faster than the fegetround()\n+  // function call.\n+  //\n+  // The volatile keywoard prevents the compiler from computing the function\n+  // at compile-time.\n+  // There might be other ways to prevent compile-time optimizations (e.g., asm).\n+  // The value does not need to be std::numeric_limits<float>::min(), any small\n+  // value so that 1 + x should round to 1 would do (after accounting for excess\n+  // precision, as in 387 instructions).\n+  static volatile float fmin = std::numeric_limits<float>::min();\n+  float fmini = fmin; // we copy it so that it gets loaded at most once.\n+  //\n+  // Explanation:\n+  // Only when fegetround() == FE_TONEAREST do we have that\n+  // fmin + 1.0f == 1.0f - fmin.\n+  //\n+  // FE_UPWARD:\n+  //  fmin + 1.0f > 1\n+  //  1.0f - fmin == 1\n+  //\n+  // FE_DOWNWARD or  FE_TOWARDZERO:\n+  //  fmin + 1.0f == 1\n+  //  1.0f - fmin < 1\n+  //\n+  // Note: This may fail to be accurate if fast-math has been\n+  // enabled, as rounding conventions may not apply.\n+  return (fmini + 1.0f == 1.0f - fmini);\n+}\n+\n } // namespace detail\n \n template<typename T>\n@@ -2919,12 +2976,45 @@ from_chars_result from_chars_advanced(const char *first, const char *last,\n   }\n   answer.ec = std::errc(); // be optimistic\n   answer.ptr = pns.lastmatch;\n-  // Next is a modified Clinger's fast path, inspired by Jakub Jel\u00ednek's proposal\n-  if (pns.exponent >= 0 && pns.exponent <= binary_format<T>::max_exponent_fast_path() && pns.mantissa <=binary_format<T>::max_mantissa_fast_path(pns.exponent) && !pns.too_many_digits) {\n-    value = T(pns.mantissa);\n-    value = value * binary_format<T>::exact_power_of_ten(pns.exponent);\n-    if (pns.negative) { value = -value; }\n-    return answer;\n+  // The implementation of the Clinger's fast path is convoluted because\n+  // we want round-to-nearest in all cases, irrespective of the rounding mode\n+  // selected on the thread.\n+  // We proceed optimistically, assuming that detail::rounds_to_nearest() returns\n+  // true.\n+  if (binary_format<T>::min_exponent_fast_path() <= pns.exponent && pns.exponent <= binary_format<T>::max_exponent_fast_path() && !pns.too_many_digits) {\n+    // Unfortunately, the conventional Clinger's fast path is only possible\n+    // when the system rounds to the nearest float.\n+    //\n+    // We expect the next branch to almost always be selected.\n+    // We could check it first (before the previous branch), but\n+    // there might be performance advantages at having the check\n+    // be last.\n+    if(detail::rounds_to_nearest())  {\n+      // We have that fegetround() == FE_TONEAREST.\n+      // Next is Clinger's fast path.\n+      if (pns.mantissa <=binary_format<T>::max_mantissa_fast_path()) {\n+        value = T(pns.mantissa);\n+        if (pns.exponent < 0) { value = value / binary_format<T>::exact_power_of_ten(-pns.exponent); }\n+        else { value = value * binary_format<T>::exact_power_of_ten(pns.exponent); }\n+        if (pns.negative) { value = -value; }\n+        return answer;\n+      }\n+    } else {\n+      // We do not have that fegetround() == FE_TONEAREST.\n+      // Next is a modified Clinger's fast path, inspired by Jakub Jel\u00ednek's proposal\n+      if (pns.exponent >= 0 && pns.mantissa <=binary_format<T>::max_mantissa_fast_path(pns.exponent)) {\n+#if (defined(_WIN32) && defined(__clang__))\n+        // ClangCL may map 0 to -0.0 when fegetround() == FE_DOWNWARD\n+        if(pns.mantissa == 0) {\n+          value = 0;\n+          return answer;\n+        }\n+#endif\n+        value = T(pns.mantissa) * binary_format<T>::exact_power_of_ten(pns.exponent);\n+        if (pns.negative) { value = -value; }\n+        return answer;\n+      }\n+    }\n   }\n   adjusted_mantissa am = compute_float<binary_format<T>>(pns.exponent, pns.mantissa);\n   if(pns.too_many_digits && am.power2 >= 0) {"}]}