{"sha": "e4de5a1022973b0fffdecfc2931fc6ec0f235784", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTRkZTVhMTAyMjk3M2IwZmZmZGVjZmMyOTMxZmM2ZWMwZjIzNTc4NA==", "commit": {"author": {"name": "Per Bothner", "email": "bothner@gcc.gnu.org", "date": "1998-10-12T12:43:53Z"}, "committer": {"name": "Per Bothner", "email": "bothner@gcc.gnu.org", "date": "1998-10-12T12:43:53Z"}, "message": "\ufffd\nMerge from Cygnus internal source tree.\n\nFrom-SVN: r23025", "tree": {"sha": "6b8fd99c924c31f0820d242808644e6ac851276e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6b8fd99c924c31f0820d242808644e6ac851276e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e4de5a1022973b0fffdecfc2931fc6ec0f235784", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e4de5a1022973b0fffdecfc2931fc6ec0f235784", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e4de5a1022973b0fffdecfc2931fc6ec0f235784", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e4de5a1022973b0fffdecfc2931fc6ec0f235784/comments", "author": null, "committer": null, "parents": [{"sha": "8376a32eb13b751abe718b098877a58d4c6c76ef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8376a32eb13b751abe718b098877a58d4c6c76ef", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8376a32eb13b751abe718b098877a58d4c6c76ef"}], "stats": {"total": 2273, "additions": 1749, "deletions": 524}, "files": [{"sha": "d7e009d4a49f83c23d29192e4d9938a415e537d3", "filename": "gcc/java/Makefile.in", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4de5a1022973b0fffdecfc2931fc6ec0f235784/gcc%2Fjava%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4de5a1022973b0fffdecfc2931fc6ec0f235784/gcc%2Fjava%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FMakefile.in?ref=e4de5a1022973b0fffdecfc2931fc6ec0f235784", "patch": "@@ -148,10 +148,12 @@ ALL_CFLAGS = $(INTERNAL_CFLAGS) $(X_CFLAGS) $(T_CFLAGS) $(CFLAGS) $(XCFLAGS)\n # Likewise.\n ALL_CPPFLAGS = $(CPPFLAGS) $(X_CPPFLAGS) $(T_CPPFLAGS)\n \n+# CYGNUS LOCAL: SUBDIR_USE_ALLOCA is different from FSF.\n # Even if ALLOCA is set, don't use it if compiling with GCC.\n \n SUBDIR_OBSTACK = `if [ x$(OBSTACK) != x ]; then echo ../$(OBSTACK); else true; fi`\n-SUBDIR_USE_ALLOCA = `case \"${CC}\" in \"${OLDCC}\") if [ x$(ALLOCA) != x ]; then echo ../$(ALLOCA); else true; fi ;; esac`\n+#SUBDIR_USE_ALLOCA = `case \"${CC}\" in \"${OLDCC}\") if [ x$(ALLOCA) != x ]; then echo ../$(ALLOCA); else true; fi ;; esac`\n+SUBDIR_USE_ALLOCA = `if [ x$(ALLOCA) != x ]; then echo ../$(ALLOCA); else true; fi`\n SUBDIR_MALLOC = `if [ x$(MALLOC) != x ]; then echo ../$(MALLOC); else true; fi`\n \n # How to link with both our special library facilities\n@@ -226,19 +228,22 @@ RTL_H = $(srcdir)/../rtl.h $(srcdir)/../rtl.def \\\n         $(srcdir)/../machmode.h $(srcdir)/../machmode.def\n EXPR_H = $(srcdir)/../expr.h ../insn-codes.h\n \n+# CYGNUS LOCAL: we put these files into the build dir.\n+PARSE_C = parse.c\n+PARSE_SCAN_C = parse-scan.c\n PARSE_H = $(srcdir)/parse.h\n-PARSE_C = $(srcdir)/parse.c\n-PARSE_SCAN_C = $(srcdir)/parse-scan.c\n \n $(PARSE_C):  $(srcdir)/parse.y $(srcdir)/lex.c $(PARSE_H) $(srcdir)/lex.h\n \t$(BISON) -t -v $(BISONFLAGS) $(JAVABISONFLAGS) -o $(PARSE_C) \\\n \t  $(srcdir)/parse.y\n $(PARSE_SCAN_C):  $(srcdir)/parse-scan.y $(srcdir)/lex.c $(PARSE_H) \\\n-\t\t$(srcdir)/lex.h\n+\t  $(srcdir)/lex.h\n \t$(BISON) -t -v $(BISONFLAGS) -o $(PARSE_SCAN_C) $(srcdir)/parse-scan.y\n \n lex.c: keyword.h lex.h\n \n+lang.o: $(srcdir)/java-tree.def\n+\n keyword.h: keyword.gperf\n \tgperf -L KR-C -F ', 0' -p -t -j1 -i 1 -g -o -N java_keyword -k1,3,$$ \\\n \tkeyword.gperf > keyword.h\n@@ -258,8 +263,9 @@ TAGS: force\n mostlyclean:\n \trm -f *.o\n \n+# CYGNUS LOCAL: Remove these files, as they are in the build dir.\n clean:  mostlyclean\n-\trm -f parse.c\n+\trm -f parse.c parse-scan.c\n \n force:\n "}, {"sha": "924f6e0f276ea6d93553bc1b6a84c2a973749c4d", "filename": "gcc/java/buffer.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4de5a1022973b0fffdecfc2931fc6ec0f235784/gcc%2Fjava%2Fbuffer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4de5a1022973b0fffdecfc2931fc6ec0f235784/gcc%2Fjava%2Fbuffer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fbuffer.h?ref=e4de5a1022973b0fffdecfc2931fc6ec0f235784", "patch": "@@ -36,6 +36,9 @@ struct buffer\n \n #define NULL_BUFFER { (void*) 0, (void*) 0, (void*) 0 }\n \n+#define BUFFER_INIT(BUFP) \\\n+  ((BUFP)->data = NULL, (BUFP)->ptr = NULL, (BUFP)->limit = NULL)\n+\n #define BUFFER_LENGTH(BUFP) ((BUFP)->ptr - (BUFP)->data)\n \n #define BUFFER_RESET(BUFP) ((BUFP)->ptr = (BUFP)->data)"}, {"sha": "caa2a313c64dfd1dd0c9d6563c8bd7fd30a81972", "filename": "gcc/java/except.c", "status": "modified", "additions": 34, "deletions": 18, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4de5a1022973b0fffdecfc2931fc6ec0f235784/gcc%2Fjava%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4de5a1022973b0fffdecfc2931fc6ec0f235784/gcc%2Fjava%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fexcept.c?ref=e4de5a1022973b0fffdecfc2931fc6ec0f235784", "patch": "@@ -161,6 +161,12 @@ method_init_exceptions ()\n   whole_range.first_child = NULL;\n   whole_range.next_sibling = NULL;\n   cache_range_start = 0xFFFFFF;\n+  java_set_exception_lang_code ();\n+}\n+\n+void\n+java_set_exception_lang_code ()\n+{\n   set_exception_lang_code (EH_LANG_Java);\n   set_exception_version_code (1);\n }\n@@ -183,6 +189,32 @@ expand_start_java_handler (range)\n   expand_eh_region_start ();\n }\n \n+tree\n+prepare_eh_table_type (type)\n+    tree type;\n+{\n+  tree exp;\n+\n+  /* The \"type\" (metch_info) in a (Java) exception table is one:\n+   * a) NULL - meaning match any type in a try-finally.\n+   * b) a pointer to a (ccmpiled) class (low-order bit 0).\n+   * c) a pointer to the Utf8Const name of the class, plus one\n+   * (which yields a value with low-order bit 1). */\n+\n+  push_obstacks (&permanent_obstack, &permanent_obstack);\n+  if (type == NULL_TREE)\n+    exp = null_pointer_node;\n+  else if (is_compiled_class (type))\n+    exp = build_class_ref (type);\n+  else\n+    exp = fold (build \n+\t\t(PLUS_EXPR, ptr_type_node,\n+\t\t build_utf8_ref (build_internal_class_name (type)),\n+\t\t size_one_node));\n+  pop_obstacks ();\n+  return exp;\n+}\n+\n /* if there are any handlers for this range, isssue end of range,\n    and then all handler blocks */\n void\n@@ -193,24 +225,8 @@ expand_end_java_handler (range)\n   expand_start_all_catch ();\n   for ( ; handler != NULL_TREE; handler = TREE_CHAIN (handler))\n     {\n-      tree type = TREE_PURPOSE (handler);\n-      tree exp;\n-      /* The \"type\" (metch_info) in a (Java) exception table is one:\n-       * a) NULL - meaning match any type in a try-finally.\n-       * b) a pointer to a (ccmpiled) class (low-order bit 0).\n-       * c) a pointer to the Utf8Const name of the class, plus one\n-       * (which yields a value with low-order bit 1). */\n-      push_obstacks (&permanent_obstack, &permanent_obstack);\n-      if (type == NULL_TREE)\n-\texp = null_pointer_node;\n-      else if (is_compiled_class (type))\n-\texp = build_class_ref (type);\n-      else\n-\texp = fold (build (PLUS_EXPR, ptr_type_node,\n-\t\t\t   build_utf8_ref (build_internal_class_name (type)),\n-\t\t\t   size_one_node));\n-      pop_obstacks ();\n-      start_catch_handler (exp);\n+      start_catch_handler (prepare_eh_table_type (TREE_PURPOSE (handler)));\n+      /* Push the thrown object on the top of the stack */\n       expand_goto (TREE_VALUE (handler));\n     }\n   expand_end_all_catch ();"}, {"sha": "8322d616315fa350326170f0c67626121b4ac0bc", "filename": "gcc/java/expr.c", "status": "modified", "additions": 105, "deletions": 37, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4de5a1022973b0fffdecfc2931fc6ec0f235784/gcc%2Fjava%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4de5a1022973b0fffdecfc2931fc6ec0f235784/gcc%2Fjava%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fexpr.c?ref=e4de5a1022973b0fffdecfc2931fc6ec0f235784", "patch": "@@ -460,7 +460,7 @@ java_stack_dup (size, offset)\n     }\n }\n \n-/* Calls soft_athrow.  Discard the contents of the value stack. */\n+/* Calls _Jv_Throw.  Discard the contents of the value stack. */\n \n tree\n build_java_athrow (node)\n@@ -526,15 +526,16 @@ decode_newarray_type  (int atype)\n     }\n }\n \n-/* Build a call to soft_badarrayindex(), the ArrayIndexOfBoundsException\n-   exception handler.  */\n+/* Build a call to _Jv_ThrowBadArrayIndex(), the\n+   ArrayIndexOfBoundsException exception handler.  */\n \n static tree\n-build_java_throw_out_of_bounds_exception ()\n+build_java_throw_out_of_bounds_exception (index)\n+    tree index;\n {\n   tree node = build (CALL_EXPR, int_type_node,\n \t\t     build_address_of (soft_badarrayindex_node), \n-\t\t     NULL_TREE, NULL_TREE );\n+\t\t     build_tree_list (NULL_TREE, index), NULL_TREE);\n   TREE_SIDE_EFFECTS (node) = 1;\t/* Allows expansion within ANDIF */\n   return (node);\n }\n@@ -629,7 +630,7 @@ build_java_arrayaccess (array, type, index)\n       if (! integer_zerop (test))\n \t{\n \t  throw = build (TRUTH_ANDIF_EXPR, int_type_node, test,\n-\t\t\t build_java_throw_out_of_bounds_exception ());\n+\t\t\t build_java_throw_out_of_bounds_exception (index));\n \t  /* allows expansion within COMPOUND */\n \t  TREE_SIDE_EFFECTS( throw ) = 1;\n \t}\n@@ -677,7 +678,7 @@ build_java_check_indexed_type (array_node, indexed_type)\n     return indexed_type;\n }\n \n-/* newarray triggers a call to soft_newarray. This function should be called\n+/* newarray triggers a call to _Jv_NewArray. This function should be called\n    with an integer code (the type of array to create) and get from the stack\n    the size of the dimmension.  */\n \n@@ -706,7 +707,7 @@ build_anewarray (class_type, length)\n     tree class_type;\n     tree length;\n {\n-  tree type = build_java_array_type (promote_type (class_type),\n+  tree type = build_java_array_type (class_type,\n \t\t\t\t     TREE_CODE (length) == INTEGER_CST\n \t\t\t\t     ? TREE_INT_CST_LOW (length)\n \t\t\t\t     : -1);\n@@ -719,9 +720,9 @@ build_anewarray (class_type, length)\n \t\tNULL_TREE);\n }\n \n-/* Generates a call to multianewarray. multianewarray expects a class pointer,\n-   a number of dimensions and the matching number of dimensions. The argument\n-   list is NULL terminated.  */\n+/* Generates a call to _Jv_NewMultiArray. multianewarray expects a\n+   class pointer, a number of dimensions and the matching number of\n+   dimensions. The argument list is NULL terminated.  */\n \n void\n expand_java_multianewarray (class_type, ndim)\n@@ -829,8 +830,8 @@ expand_java_array_length ()\n   push_value (build_java_arraynull_check (array, length, int_type_node));\n }\n \n-/* Emit code for the call to soft_monitor{enter,exit}. CALL can be either\n-   soft_monitorenter_node or soft_monitorexit_node.  */\n+/* Emit code for the call to _Jv_Monitor{Enter,Exit}. CALL can be\n+   either soft_monitorenter_node or soft_monitorexit_node.  */\n \n tree\n build_java_monitor (call, object)\n@@ -1147,6 +1148,18 @@ lookup_label (pc)\n     }\n }\n \n+/* Generate a unique name for the purpose of loops and switches\n+   labels, and try-catch-finally blocks label or temporary variables.  */\n+\n+tree\n+generate_name ()\n+{\n+  static int l_number = 0;\n+  char buff [20];\n+  sprintf (buff, \"$L%d\", l_number++);\n+  return get_identifier (buff);\n+}\n+\n tree\n create_label_decl (name)\n      tree name;\n@@ -1175,7 +1188,6 @@ note_label (current_pc, target_pc)\n /* Emit code to jump to TARGET_PC if VALUE1 CONDITION VALUE2,\n    where CONDITION is one of one the compare operators. */\n \n-\n void\n expand_compare (condition, value1, value2, target_pc)\n      enum tree_code condition;\n@@ -1279,7 +1291,14 @@ pop_arguments (arg_types)\n   if (TREE_CODE (arg_types) == TREE_LIST)\n     {\n       tree tail = pop_arguments (TREE_CHAIN (arg_types));\n-      return tree_cons (NULL_TREE, pop_value (TREE_VALUE (arg_types)), tail);\n+      tree type = TREE_VALUE (arg_types);\n+      tree arg = pop_value (type);\n+#ifdef PROMOTE_PROTOTYPES\n+      if (TYPE_PRECISION (type) < TYPE_PRECISION (integer_type_node)\n+\t  && INTEGRAL_TYPE_P (type))\n+\targ = convert (integer_type_node, arg);\n+#endif\n+      return tree_cons (NULL_TREE, arg, tail);\n     }\n   abort ();\n }\n@@ -1490,17 +1509,6 @@ expand_invoke (opcode, method_ref_index, nargs)\n   arg_list = pop_arguments (TYPE_ARG_TYPES (method_type));\n   flush_quick_stack ();\n \n-  if (opcode == OPCODE_invokestatic || opcode == OPCODE_invokespecial\n-      && ! inherits_from_p (current_class, self_type))\n-    { /* FIXME probably not needed for invokespecial if done by NEW. */\n-      /* Ensure self_type is initialized. */ \n-      func = build (CALL_EXPR, void_type_node, soft_initclass_node,\n-\t\t    build_tree_list (NULL_TREE,\n-\t\t\t\t     build_class_ref (self_type)),\n-\t\t    NULL_TREE);\n-      expand_expr_stmt (func);\n-    }\n-\n   func = NULL_TREE;\n   if (opcode == OPCODE_invokestatic || opcode == OPCODE_invokespecial\n       || (opcode == OPCODE_invokevirtual\n@@ -1515,9 +1523,9 @@ expand_invoke (opcode, method_ref_index, nargs)\n \tfunc = build_invokevirtual (dtable, method);\n       else\n \t{\n-\t  /* We expand invokeinterface here. soft_lookupinterfacemethod () will\n-\t     ensure that the selected method exists, is public and not abstract\n-\t     nor static.  */\n+\t  /* We expand invokeinterface here.\n+\t     _Jv_LookupInterfaceMethod() will ensure that the selected\n+\t     method exists, is public and not abstract nor static.  */\n \t    \n \t  tree lookup_arg;\n \n@@ -1543,12 +1551,6 @@ expand_invoke (opcode, method_ref_index, nargs)\n   call = build (CALL_EXPR, TREE_TYPE (method_type), func, arg_list, NULL_TREE);\n   TREE_SIDE_EFFECTS (call) = 1;\n \n-  if (opcode == OPCODE_invokestatic || opcode == OPCODE_invokespecial)\n-    { /* FIXME probably not needed for invokespecial if done by NEW. */\n-      /* Ensure self_type is initialized. */ \n-      call = build_class_init (self_type, call);\n-    }\n-\n   if (TREE_CODE (TREE_TYPE (method_type)) == VOID_TYPE)\n     expand_expr_stmt (call);\n   else\n@@ -1600,7 +1602,7 @@ expand_java_field_op (is_static, is_putting, field_ref_index)\n   if (is_error)\n     {\n       if (! is_putting)\n-\tpush_value (convert (promote_type (field_type), integer_zero_node));\n+\tpush_value (convert (field_type, integer_zero_node));\n       flush_quick_stack ();\n       return;\n     }\n@@ -1610,7 +1612,7 @@ expand_java_field_op (is_static, is_putting, field_ref_index)\n      this is also needed to avoid circularities in the implementation\n      of these fields in libjava. */\n   if (field_name == TYPE_identifier_node && ! is_putting\n-      && field_type == class_type_node\n+      && field_type == class_ptr_type\n       && strncmp (self_name, \"java.lang.\", 10) == 0)\n     {\n       char *class_name = self_name+10;\n@@ -1693,6 +1695,8 @@ java_lang_expand_expr (exp, target, tmode, modifier)\n   tree type = TREE_TYPE (exp);\n   register enum machine_mode mode = TYPE_MODE (type);\n   int unsignedp = TREE_UNSIGNED (type);\n+  tree node, current;\n+  int has_finally_p;\n \n   switch (TREE_CODE (exp))\n     {\n@@ -1719,6 +1723,61 @@ java_lang_expand_expr (exp, target, tmode, modifier)\n \t}\n       break;\n \n+    case SWITCH_EXPR:\n+      java_expand_switch (exp);\n+      return const0_rtx;\n+\n+    case TRY_EXPR:\n+      /* We expand a try[-catch][-finally] block */\n+\n+      /* Expand the try block */\n+      expand_eh_region_start ();\n+      expand_expr_stmt (TREE_OPERAND (exp, 0));\n+      expand_start_all_catch ();\n+      has_finally_p = (TREE_OPERAND (exp, 2) ? 1 : 0);\n+\n+      /* Expand all catch clauses (EH handlers) */\n+      for (current = TREE_OPERAND (exp, 1); current; \n+\t   current = TREE_CHAIN (current))\n+\t{\n+\t  extern rtx return_label;\n+\t  tree type;\n+\t  /* If we have a finally, the last exception handler is the\n+\t     one that is supposed to catch everything. */\n+\t  if (has_finally_p && !TREE_CHAIN (current))\n+\t    type = NULL_TREE;\n+\t  else\n+\t    {\n+\t      tree catch = java_get_catch_block (current, has_finally_p);\n+\t      tree decl = BLOCK_EXPR_DECLS (catch);\n+\t      type = TREE_TYPE (TREE_TYPE (decl));\n+\t    }\n+\t  start_catch_handler (prepare_eh_table_type (type));\n+\t  expand_expr_stmt (TREE_OPERAND (current, 0));\n+\n+\t  /* Need to expand a goto to the end of the function here,\n+\t     but not for the catch everything handler. */\n+\t  if (type)\n+\t    {\n+\t      if (return_label)\n+\t\temit_jump (return_label);\n+\t      else\n+\t\tfatal (\"No return_label for this function - \"\n+\t\t       \"java_lang_expand_expr\");\n+\t    }\n+\t  end_catch_handler ();\n+\t}\n+\n+      /* Expand the finally block, if any */\n+      if (has_finally_p)\n+\t{\n+\t  tree finally = TREE_OPERAND (exp, 2);\n+\t  emit_label (label_rtx (FINALLY_EXPR_LABEL (finally)));\n+\t  expand_expr_stmt (FINALLY_EXPR_BLOCK (finally));\n+\t}\n+      expand_end_all_catch ();\n+      break;\n+\n     default:\n       fatal (\"Can't expand '%s' tree - java_lang_expand_expr\",\n \t     tree_code_name [TREE_CODE (exp)]);\n@@ -1984,6 +2043,15 @@ process_jvm_instruction (PC, byte_ops, length)\n { \n   char *opname; /* Temporary ??? */\n   int oldpc = PC; /* PC at instruction start. */\n+\n+  /* If the instruction is at the beginning of a exception handler,\n+     replace the top of the stack with the thrown object reference */\n+  if (instruction_bits [PC] & BCODE_EXCEPTION_TARGET)\n+    {\n+      pop_value (ptr_type_node);\n+      push_value (soft_exceptioninfo_call_node);\n+    }\n+\n   switch (byte_ops[PC++])\n     {\n #define JAVAOP(OPNAME, OPCODE, OPKIND, OPERAND_TYPE, OPERAND_VALUE) \\"}, {"sha": "b6229cc3a77196a5d29bbb9a60274c23e37b322a", "filename": "gcc/java/gjavah.c", "status": "modified", "additions": 256, "deletions": 125, "changes": 381, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4de5a1022973b0fffdecfc2931fc6ec0f235784/gcc%2Fjava%2Fgjavah.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4de5a1022973b0fffdecfc2931fc6ec0f235784/gcc%2Fjava%2Fgjavah.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fgjavah.c?ref=e4de5a1022973b0fffdecfc2931fc6ec0f235784", "patch": "@@ -84,11 +84,21 @@ static JCF_u2 last_access;\n \n #define ACC_VISIBILITY (ACC_PUBLIC | ACC_PRIVATE | ACC_PROTECTED)\n \n-int seen_fields = 0;\n+/* We keep a linked list of all method names we have seen.  This lets\n+   us determine if a method name and a field name are in conflict.  */\n+struct method_name\n+{\n+  unsigned char *name;\n+  int length;\n+  struct method_name *next;\n+};\n+\n+/* List of method names we've seen.  */\n+static struct method_name *method_name_list;\n \n static void print_field_info PROTO ((FILE *, JCF*, int, int, JCF_u2));\n static void print_method_info PROTO ((FILE *, JCF*, int, int, JCF_u2));\n-static void print_c_decl PROTO ((FILE*, JCF*, int, int, JCF_u2, int));\n+static void print_c_decl PROTO ((FILE*, JCF*, int, int, JCF_u2, int, char *));\n \n JCF_u2 current_field_name;\n JCF_u2 current_field_value;\n@@ -99,9 +109,15 @@ JCF_u2 current_field_flags;\n ( current_field_name = (NAME), current_field_signature = (SIGNATURE), \\\n   current_field_flags = (ACCESS_FLAGS), current_field_value = 0)\n \n+/* We pass over fields twice.  The first time we just note the start\n+   of the methods.  Then we go back and parse the fields for real.\n+   This is ugly.  */\n+static int field_pass;\n+\n #define HANDLE_END_FIELD() \\\n-  print_field_info (out, jcf, current_field_name, current_field_signature, \\\n-\t\t    current_field_flags);\n+  if (field_pass) print_field_info (out, jcf, current_field_name, \\\n+\t\t\t\t    current_field_signature, \\\n+\t\t\t\t    current_field_flags);\n \n #define HANDLE_CONSTANTVALUE(VALUEINDEX) current_field_value = (VALUEINDEX)\n \n@@ -242,11 +258,29 @@ generate_access (stream, flags)\n     }\n }\n \n+/* See if NAME is already the name of a method.  */\n+static int\n+name_is_method_p (name, length)\n+     unsigned char *name;\n+     int length;\n+{\n+  struct method_name *p;\n+\n+  for (p = method_name_list; p != NULL; p = p->next)\n+    {\n+      if (p->length == length && ! memcmp (p->name, name, length))\n+\treturn 1;\n+    }\n+  return 0;\n+}\n+\n static void\n DEFUN(print_field_info, (stream, jcf, name_index, sig_index, flags),\n       FILE *stream AND JCF* jcf\n       AND int name_index AND int sig_index AND JCF_u2 flags)\n {\n+  char *override = NULL;\n+\n   if (flags & ACC_FINAL)\n     {\n       if (current_field_value > 0)\n@@ -305,12 +339,42 @@ DEFUN(print_field_info, (stream, jcf, name_index, sig_index, flags),\n \n   generate_access (stream, flags);\n   fputs (\"  \", out);\n-  if (flags & ACC_STATIC)\n+  if ((flags & ACC_STATIC))\n     fputs (\"static \", out);\n-  print_c_decl (out, jcf, name_index, sig_index, flags, 0);\n+\n+  if (JPOOL_TAG (jcf, name_index) != CONSTANT_Utf8)\n+    {\n+      fprintf (stream, \"<not a UTF8 constant>\");\n+      found_error = 1;\n+    }\n+  else\n+    {\n+      unsigned char *name = JPOOL_UTF_DATA (jcf, name_index);\n+      int length = JPOOL_UTF_LENGTH (jcf, name_index);\n+\n+      if (name_is_method_p (name, length))\n+\t{\n+\t  /* This field name matches a method.  So override the name\n+\t     with a dummy name.  This is yucky, but it isn't clear\n+\t     what else to do.  FIXME: if the field is static, then\n+\t     we'll be in real trouble.  */\n+\t  if ((flags & ACC_STATIC))\n+\t    {\n+\t      fprintf (stderr, \"static field has same name as method\\n\");\n+\t      found_error = 1;\n+\t    }\n+\n+\t  override = (char *) malloc (length + 3);\n+\t  memcpy (override, name, length);\n+\t  strcpy (override + length, \"__\");\n+\t}\n+    }\n+\n+  print_c_decl (out, jcf, name_index, sig_index, flags, 0, override);\n   fputs (\";\\n\", out);\n-  if (! (flags & ACC_STATIC))\n-    seen_fields++;\n+\n+  if (override)\n+    free (override);\n }\n \n static void\n@@ -320,6 +384,7 @@ DEFUN(print_method_info, (stream, jcf, name_index, sig_index, flags),\n {\n   unsigned char *str;\n   int length, is_init = 0;\n+  char *override = NULL;\n \n   if (JPOOL_TAG (jcf, name_index) != CONSTANT_Utf8)\n     fprintf (stream, \"<not a UTF8 constant>\");\n@@ -334,13 +399,33 @@ DEFUN(print_method_info, (stream, jcf, name_index, sig_index, flags),\n       else  \n \treturn;\n     }\n+  else\n+    {\n+      struct method_name *nn;\n+\n+      nn = (struct method_name *) malloc (sizeof (struct method_name));\n+      nn->name = (char *) malloc (length);\n+      memcpy (nn->name, str, length);\n+      nn->length = length;\n+      nn->next = method_name_list;\n+      method_name_list = nn;\n+    }\n \n   /* We can't generate a method whose name is a C++ reserved word.\n      For now the only problem has been `delete'; add more here as\n-     required.  FIXME: we need a better solution than just ignoring\n-     the method.  */\n+     required.  We can't just ignore the function, because that will\n+     cause incorrect code to be generated if the function is virtual\n+     (not only for calls to this function for for other functions\n+     after it in the vtbl).  So we give it a dummy name instead.  */\n   if (! utf8_cmp (str, length, \"delete\"))\n-    return;\n+    {\n+      /* If the method is static, we can safely skip it.  If we don't\n+\t skip it then we'll have problems since the mangling will be\n+\t wrong.  FIXME.  */\n+      if ((flags & ACC_STATIC))\n+\treturn;\n+      override = \"__dummy_delete\";\n+    }\n \n   generate_access (stream, flags);\n \n@@ -353,162 +438,193 @@ DEFUN(print_method_info, (stream, jcf, name_index, sig_index, flags),\n       if (! is_init)\n \tfputs (\"virtual \", out);\n     }\n-  print_c_decl (out, jcf, name_index, sig_index, flags, is_init);\n+  print_c_decl (out, jcf, name_index, sig_index, flags, is_init, override);\n \n   /* FIXME: it would be nice to decompile small methods here.  That\n      would allow for inlining.  */\n \n   fprintf(out, \";\\n\");\n }\n \n+/* Print one piece of a signature.  Returns pointer to next parseable\n+   character on success, NULL on error.  */\n+static unsigned char *\n+decode_signature_piece (stream, signature, limit, need_space)\n+     FILE *stream;\n+     unsigned char *signature, *limit;\n+     int *need_space;\n+{\n+  char *ctype;\n+\n+  switch (signature[0])\n+    {\n+    case '[':\n+      for (signature++; (signature < limit\n+\t\t\t && *signature >= '0'\n+\t\t\t && *signature <= '9'); signature++)\n+\t;\n+      switch (*signature)\n+\t{\n+\tcase 'B': ctype = \"jbyteArray\";  goto printit;\n+\tcase 'C': ctype = \"jcharArray\";  goto printit;\n+\tcase 'D': ctype = \"jdoubleArray\";  goto printit;\n+\tcase 'F': ctype = \"jfloatArray\";  goto printit;\n+\tcase 'I': ctype = \"jintArray\";  goto printit;\n+\tcase 'S': ctype = \"jshortArray\";  goto printit;\n+\tcase 'J': ctype = \"jlongArray\";  goto printit;\n+\tcase 'Z': ctype = \"jbooleanArray\";  goto printit;\n+\tcase '[': ctype = \"jobjectArray\"; goto printit;\n+\tcase 'L':\n+\t  /* We have to generate a reference to JArray here,\n+\t     so that our output matches what the compiler\n+\t     does.  */\n+\t  ++signature;\n+\t  fputs (\"JArray<\", stream);\n+\t  while (signature < limit && *signature != ';')\n+\t    {\n+\t      int ch = UTF8_GET (signature, limit);\n+\t      if (ch == '/')\n+\t\tfputs (\"::\", stream);\n+\t      else\n+\t\tjcf_print_char (stream, ch);\n+\t    }\n+\t  fputs (\" *> *\", stream);\n+\t  *need_space = 0;\n+\t  ++signature;\n+\t  break;\n+\tdefault:\n+\t  /* Unparseable signature.  */\n+\t  return NULL;\n+\t}\n+      break;\n+\n+    case '(':\n+    case ')':\n+      /* This shouldn't happen.  */\n+      return NULL;\n+\n+    case 'B': ctype = \"jbyte\";  goto printit;\n+    case 'C': ctype = \"jchar\";  goto printit;\n+    case 'D': ctype = \"jdouble\";  goto printit;\n+    case 'F': ctype = \"jfloat\";  goto printit;\n+    case 'I': ctype = \"jint\";  goto printit;\n+    case 'J': ctype = \"jlong\";  goto printit;\n+    case 'S': ctype = \"jshort\";  goto printit;\n+    case 'Z': ctype = \"jboolean\";  goto printit;\n+    case 'V': ctype = \"void\";  goto printit;\n+    case 'L':\n+      ++signature;\n+      while (*signature && *signature != ';')\n+\t{\n+\t  int ch = UTF8_GET (signature, limit);\n+\t  if (ch == '/')\n+\t    fputs (\"::\", stream);\n+\t  else\n+\t    jcf_print_char (stream, ch);\n+\t}\n+      fputs (\" *\", stream);\n+      if (*signature == ';')\n+\tsignature++;\n+      *need_space = 0;\n+      break;\n+    default:\n+      *need_space = 1;\n+      jcf_print_char (stream, *signature++);\n+      break;\n+    printit:\n+      signature++;\n+      *need_space = 1;\n+      fputs (ctype, stream);\n+      break;\n+    }\n+\n+  return signature;\n+}\n+\n static void\n-DEFUN(print_c_decl, (stream, jcf, name_index, signature_index, flags, is_init),\n+DEFUN(print_c_decl, (stream, jcf, name_index, signature_index, flags, is_init,\n+\t\t     name_override),\n       FILE* stream AND JCF* jcf\n       AND int name_index AND int signature_index AND JCF_u2 flags\n-      AND int is_init)\n+      AND int is_init AND char *name_override)\n {\n   if (JPOOL_TAG (jcf, signature_index) != CONSTANT_Utf8)\n-    fprintf (stream, \"<not a UTF8 constant>\");\n+    {\n+      fprintf (stream, \"<not a UTF8 constant>\");\n+      found_error = 1;\n+    }\n   else\n     {\n       int length = JPOOL_UTF_LENGTH (jcf, signature_index);\n       unsigned char *str0 = JPOOL_UTF_DATA (jcf, signature_index);\n       register  unsigned char *str = str0;\n       unsigned char *limit = str + length;\n-      int j;\n-      char *ctype;\n       int need_space = 0;\n       int is_method = str[0] == '(';\n+      unsigned char *next;\n \n-      if (is_method)\n+      /* If printing a method, skip to the return signature and print\n+\t that first.  However, there is no return value if this is a\n+\t constructor.  */\n+      if (is_method && ! is_init)\n \t{\n-\t  /* Skip to the return signature, and print that first.\n-\t     However, don't do this is we are printing a construtcor.\n-\t     */\n-\t  if (is_init)\n+\t  while (str < limit)\n \t    {\n-\t      str = str0 + 1;\n-\t      /* FIXME: Most programmers love Celtic knots because\n-\t\t they see their own code in the interconnected loops.\n-\t\t That is, this is spaghetti.  */\n-\t      goto have_constructor;\n-\t    }\n-\t  else\n-\t    {\n-\t      while (str < limit)\n-\t\t{\n-\t\t  int ch = *str++;\n-\t\t  if (ch == ')')\n-\t\t    break;\n-\t\t}\n+\t      int ch = *str++;\n+\t      if (ch == ')')\n+\t\tbreak;\n \t    }\n \t}\n \n-    again:\n-      while (str < limit)\n+      /* If printing a field or an ordinary method, then print the\n+\t \"return value\" now.  */\n+      if (! is_method || ! is_init)\n \t{\n-\t  switch (str[0])\n+\t  next = decode_signature_piece (stream, str, limit, &need_space);\n+\t  if (! next)\n \t    {\n-\t    case '[':\n-\t      for (str++; str < limit && *str >= '0' && *str <= '9'; str++)\n-\t\t;\n-\t      switch (*str)\n-\t\t{\n-\t\tcase 'B': ctype = \"jbyteArray\";  goto printit;\n-\t\tcase 'C': ctype = \"jcharArray\";  goto printit;\n-\t\tcase 'D': ctype = \"jdoubleArray\";  goto printit;\n-\t\tcase 'F': ctype = \"jfloatArray\";  goto printit;\n-\t\tcase 'I': ctype = \"jintArray\";  goto printit;\n-\t\tcase 'S': ctype = \"jshortArray\";  goto printit;\n-\t\tcase 'J': ctype = \"jlongArray\";  goto printit;\n-\t\tcase 'Z': ctype = \"jbooleanArray\";  goto printit;\n-\t\tcase '[': ctype = \"jobjectArray\"; goto printit;\n-\t\tcase 'L':\n-\t\t  /* We have to generate a reference to JArray here,\n-\t\t     so that our output matches what the compiler\n-\t\t     does.  */\n-\t\t  ++str;\n-\t\t  fputs (\"JArray<\", out);\n-\t\t  while (str < limit && *str != ';')\n-\t\t    {\n-\t\t      int ch = UTF8_GET (str, limit);\n-\t\t      if (ch == '/')\n-\t\t\tfputs (\"::\", stream);\n-\t\t      else\n-\t\t\tjcf_print_char (stream, ch);\n-\t\t    }\n-\t\t  fputs (\" *> *\", out);\n-\t\t  need_space = 0;\n-\t\t  ++str;\n-\t\t  break;\n-\t\tdefault:\n-\t\t  fprintf (stderr, \"unparseable signature `%s'\\n\", str0);\n-\t\t  found_error = 1;\n-\t\t  ctype = \"???\"; goto printit;\n-\t\t}\n-\t      break;\n-\t    case '(':\n-\t      fputc (*str++, stream);\n-\t      continue;\n-\t    case ')':\n-\t      fputc (*str++, stream);\n-\t      /* the return signature was printed in the first pass. */\n+\t      fprintf (stderr, \"unparseable signature: `%s'\\n\", str0);\n+\t      found_error = 1;\n \t      return;\n-\t    case 'B': ctype = \"jbyte\";  goto printit;\n-\t    case 'C': ctype = \"jchar\";  goto printit;\n-\t    case 'D': ctype = \"jdouble\";  goto printit;\n-\t    case 'F': ctype = \"jfloat\";  goto printit;\n-\t    case 'I': ctype = \"jint\";  goto printit;\n-\t    case 'J': ctype = \"jlong\";  goto printit;\n-\t    case 'S': ctype = \"jshort\";  goto printit;\n-\t    case 'Z': ctype = \"jboolean\";  goto printit;\n-\t    case 'V': ctype = \"void\";  goto printit;\n-\t    case 'L':\n-\t      ++str;\n-\t      while (*str && *str != ';')\n-\t\t{\n-\t\t  int ch = UTF8_GET (str, limit);\n-\t\t  if (ch == '/')\n-\t\t    fputs (\"::\", stream);\n-\t\t  else\n-\t\t    jcf_print_char (stream, ch);\n-\t\t}\n-\t      fputs (\" *\", stream);\n-\t      if (*str == ';')\n-\t\tstr++;\n-\t      need_space = 0;\n-\t      break;\n-\t    default:\n-\t      need_space = 1;\n-\t      jcf_print_char (stream, *str++);\n-\t      break;\n-\t    printit:\n-\t      str++;\n-\t      need_space = 1;\n-\t      fputs (ctype, stream);\n-\t      break;\n \t    }\n-\n-\t  if (is_method && str < limit && *str != ')')\n-\t    fputs (\", \", stream);\n \t}\n-    have_constructor:\n-      if (name_index)\n+\n+      /* Now print the name of the thing.  */\n+      if (need_space)\n+\tfputs (\" \", stream);\n+      if (name_override)\n+\tfputs (name_override, stream);\n+      else if (name_index)\n \t{\n-\t  if (need_space)\n-\t    fprintf (stream, \" \");\n \t  /* Declare constructors specially.  */\n \t  if (is_init)\n \t    print_base_classname (stream, jcf, jcf->this_class);\n \t  else\n \t    print_name (stream, jcf, name_index);\n \t}\n+\n       if (is_method)\n \t{\n+\t  /* Have a method or a constructor.  Print signature pieces\n+\t     until done.  */\n \t  fputs (\" (\", stream);\n-\t  /* Go to beginning, skipping '('. */\n \t  str = str0 + 1;\n-\t  goto again; /* To handle argument signatures. */\n+\t  while (str < limit && *str != ')')\n+\t    {\n+\t      next = decode_signature_piece (stream, str, limit, &need_space);\n+\t      if (! next)\n+\t\t{\n+\t\t  fprintf (stderr, \"unparseable signature: `%s'\\n\", str0);\n+\t\t  found_error = 1;\n+\t\t  return;\n+\t\t}\n+\n+\t      if (next < limit && *next != ')')\n+\t\tfputs (\", \", stream);\n+\t      str = next;\n+\t    }\n+\n+\t  fputs (\")\", stream);\n \t}\n     }\n }\n@@ -613,6 +729,7 @@ DEFUN(process_file, (jcf, out),\n       JCF *jcf AND FILE *out)\n {\n   int code, i;\n+  uint32 field_start, method_end;\n \n   current_jcf = main_jcf = jcf;\n \n@@ -700,8 +817,22 @@ DEFUN(process_file, (jcf, out),\n      as we see them.  We have to list the methods in the same order\n      that they appear in the class file, so that the Java and C++\n      vtables have the same layout.  */\n+  /* We want to parse the methods first.  But we need to find where\n+     they start.  So first we skip the fields, then parse the\n+     methods.  Then we parse the fields and skip the methods.  FIXME:\n+     this is ugly.  */\n+  field_pass = 0;\n+  field_start = JCF_TELL (jcf);\n   jcf_parse_fields (jcf);\n+\n   jcf_parse_methods (jcf);\n+  method_end = JCF_TELL (jcf);\n+\n+  field_pass = 1;\n+  JCF_SEEK (jcf, field_start);\n+  jcf_parse_fields (jcf);\n+  JCF_SEEK (jcf, method_end);\n+\n   jcf_parse_final_attributes (jcf);\n \n   /* Generate friend decl if we still must.  */"}, {"sha": "e6b8ba1be483e3c513fad50d0f08373de7fe7c51", "filename": "gcc/java/jcf-parse.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4de5a1022973b0fffdecfc2931fc6ec0f235784/gcc%2Fjava%2Fjcf-parse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4de5a1022973b0fffdecfc2931fc6ec0f235784/gcc%2Fjava%2Fjcf-parse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-parse.c?ref=e4de5a1022973b0fffdecfc2931fc6ec0f235784", "patch": "@@ -408,7 +408,7 @@ get_class_constant (JCF *jcf , int i)\n       char *name = JPOOL_UTF_DATA (jcf, name_index);\n       int nlength = JPOOL_UTF_LENGTH (jcf, name_index);\n       if (name[0] == '[')  /* Handle array \"classes\". */\n-\t  type = parse_signature_string (name, nlength);\n+\t  type = TREE_TYPE (parse_signature_string (name, nlength));\n       else\n         { \n           tree cname = unmangle_classname (name, nlength);"}, {"sha": "deda8c1f60050acab95e27de5ced6e31e227b502", "filename": "gcc/java/jcf-write.c", "status": "modified", "additions": 1228, "deletions": 313, "changes": 1541, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4de5a1022973b0fffdecfc2931fc6ec0f235784/gcc%2Fjava%2Fjcf-write.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4de5a1022973b0fffdecfc2931fc6ec0f235784/gcc%2Fjava%2Fjcf-write.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-write.c?ref=e4de5a1022973b0fffdecfc2931fc6ec0f235784", "patch": "@@ -35,19 +35,16 @@ The Free Software Foundation is independent of Sun Microsystems, Inc.  */\n \n extern struct obstack temporary_obstack;\n \n-/* The buffer allocated for bytecode for the current method. */\n-\n-struct buffer bytecode = NULL_BUFFER;\n-\n /* Make sure bytecode.data is big enough for at least N more bytes. */\n \n #define RESERVE(N) \\\n-  do { if (bytecode.ptr + (N) > bytecode.limit) buffer_grow (&bytecode, N); } while (0)\n+  do { if (state->bytecode.ptr + (N) > state->bytecode.limit) \\\n+    buffer_grow (&state->bytecode, N); } while (0)\n \n /* Add a 1-byte instruction/operand I to bytecode.data,\n    assuming space has already been RESERVE'd. */\n \n-#define OP1(I) (*bytecode.ptr++ = (I))\n+#define OP1(I) (*state->bytecode.ptr++ = (I))\n \n /* Like OP1, but I is a 2-byte big endian integer. */\n \n@@ -73,12 +70,14 @@ CPool *code_cpool;\n /* Macro to call each time we push I words on the JVM stack. */\n \n #define NOTE_PUSH(I) \\\n-  do { code_SP += (I); if (code_SP > code_SP_max) code_SP_max = code_SP; } while (0)\n+  do { state->code_SP += (I); \\\n+    if (state->code_SP > state->code_SP_max) \\\n+      state->code_SP_max = state->code_SP; } while (0)\n \n /* Macro to call each time we pop I words from the JVM stack. */\n \n #define NOTE_POP(I) \\\n-  do { code_SP -= (I); if (code_SP < 0) abort(); } while (0)\n+  do { state->code_SP -= (I); if (state->code_SP < 0) abort(); } while (0)\n \n /* A chunk or segment of a .class file. */\n \n@@ -94,6 +93,103 @@ struct chunk\n   int size;\n };\n \n+/* Each \"block\" represents a label plus the bytecode instructions following.\n+   There may be branches out of the block, but no incoming jumps, except\n+   to the beginning of the block. */\n+\n+struct jcf_block\n+{\n+  /* For blocks that that are defined, the next block (in pc order).\n+     For blocks that are the not-yet-defined end label of a LABELED_BLOCK_EXPR,\n+     this is the next (outer) such end label, in a stack heaed by\n+     labeled_blocks in jcf_partial. */\n+  struct jcf_block *next;\n+\n+  /* Until perform_relocations is finished, this is the maximum possible\n+     value of the bytecode offset at the begnning of this block.\n+     After perform_relocations, it is the actual offset (pc). */\n+  int pc;\n+\n+  int linenumber;\n+\n+  struct chunk *chunk;\n+\n+  union {\n+    /* Set of relocations (in reverse offset order) for this block. */\n+    struct jcf_relocation *relocations;\n+\n+    /* If this block is that of the not-yet-defined end label of\n+       a LABELED_BLOCK_EXPR, where LABELED_BLOCK is that LABELED_BLOCK_EXPR. */\n+    tree labeled_block;\n+  } u;\n+};\n+\n+struct jcf_relocation\n+{\n+  /* Next relocation for the current jcf_block. */\n+  struct jcf_relocation *next;\n+\n+  /* The (byte) offset within the current block that needs to be relocated. */\n+  int offset;\n+\n+  /* 0 if offset is a 4-byte relative offset.\n+     -1 if offset is a 2-byte relative offset.\n+     < 0 if offset is the address of an instruction with a 2-byte offset\n+     that does not have a corresponding 4-byte offset version, in which\n+     case the absolute value of kind is the inverted opcode.\n+     > 0 if offset is the address of an instruction (such as jsr) with a\n+     2-byte offset that does have a corresponding 4-byte offset version,\n+     in which case kind is the opcode of the 4-byte version (such as jsr_w). */\n+  int kind;\n+\n+  /* The label the relocation wants to actually transfer to. */\n+  struct jcf_block *label;\n+};\n+\n+/* This structure is used to contain the various pieces that will\n+   become a .class file. */\n+\n+struct jcf_partial\n+{\n+  struct chunk *first;\n+  struct chunk *chunk;\n+  struct obstack *chunk_obstack;\n+  tree current_method;\n+\n+  /* List of basic blocks for the current method. */\n+  struct jcf_block *blocks;\n+  struct jcf_block *last_block;\n+\n+  struct localvar_info *first_lvar;\n+  struct localvar_info *last_lvar;\n+  int lvar_count;\n+\n+  CPool cpool;\n+\n+  int linenumber_count;\n+\n+  /* Until perform_relocations, this is a upper bound on the number\n+     of bytes (so far) in the instructions for the current method. */\n+  int code_length;\n+\n+  /* Stack of undefined ending labels for LABELED_BLOCK_EXPR. */\n+  struct jcf_block *labeled_blocks;\n+  \n+  /* The current stack size (stack pointer) in the current method. */\n+  int code_SP;\n+\n+  /* The largest extent of stack size (stack pointer) in the current method. */\n+  int code_SP_max;\n+\n+  /* Contains a mapping from local var slot number to localvar_info. */\n+  struct buffer localvars;\n+\n+  /* The buffer allocated for bytecode for the current jcf_block. */\n+  struct buffer bytecode;\n+};\n+\n+static void generate_bytecode_insns PROTO ((tree, int, struct jcf_partial *));\n+\n /* Utility macros for appending (big-endian) data to a buffer.\n    We assume a local variable 'ptr' points into where we want to\n    write next, and we assume enoygh space has been allocated. */\n@@ -104,162 +200,228 @@ struct chunk\n #define PUTN(P, N)  (bcopy(P, ptr, N), ptr += (N))\n \n \f\n-/* A buffer for storing line number entries for the current method. */\n-struct buffer linenumbers = NULL_BUFFER;\n+/* Allocate a new chunk on obstack WORK, and link it in after LAST.\n+   Set the data and size fields to DATA and SIZE, respectively.\n+   However, if DATA is NULL and SIZE>0, allocate a buffer as well. */\n+\n+struct chunk *\n+alloc_chunk (last, data, size, work)\n+     struct chunk *last;\n+     unsigned char *data;\n+     int size;\n+     struct obstack *work;\n+{\n+  struct chunk *chunk = (struct chunk *)\n+    obstack_alloc (work, sizeof(struct chunk));\n+\n+  if (data == NULL && size > 0)\n+    data = obstack_alloc (work, size);\n+\n+  chunk->next = NULL;\n+  chunk->data = data;\n+  chunk->size = size;\n+  if (last != NULL)\n+    last->next = chunk;\n+  return chunk;\n+}\n+\n+unsigned char *\n+append_chunk (data, size, state)\n+     unsigned char *data;\n+     int size;\n+     struct jcf_partial *state;\n+{\n+  state->chunk = alloc_chunk (state->chunk, data, size, state->chunk_obstack);\n+  if (state->first == NULL)\n+    state->first = state->chunk;\n+  return state->chunk->data;\n+}\n+\n+void\n+append_chunk_copy (data, size, state)\n+     unsigned char *data;\n+     int size;\n+     struct jcf_partial *state;\n+{\n+  unsigned char *ptr = append_chunk (NULL, size, state);\n+  bcopy (data, ptr, size);\n+}\n+\f\n+struct jcf_block *\n+gen_jcf_label (state)\n+     struct jcf_partial *state;\n+{\n+  struct jcf_block *block = (struct jcf_block *)\n+    obstack_alloc (state->chunk_obstack, sizeof (struct jcf_block));\n+  block->next =\tNULL;\n+  block->linenumber = -1;\n+  block->pc = -1;\n+  return block;\n+}\n+\n+void\n+finish_jcf_block (state)\n+     struct jcf_partial *state;\n+{\n+  struct jcf_block *block = state->last_block;\n+  struct jcf_relocation *reloc;\n+  int pc = state->code_length;\n+  append_chunk_copy (state->bytecode.data, BUFFER_LENGTH (&state->bytecode),\n+\t\t     state);\n+  BUFFER_RESET (&state->bytecode);\n+  block->chunk = state->chunk;\n+\n+  /* Calculate code_length to the maximum value it can have. */\n+  pc += block->chunk->size;\n+  for (reloc = block->u.relocations;  reloc != NULL;  reloc = reloc->next)\n+    {\n+      int kind = reloc->kind;\n+      if (kind > 0)\n+\tpc += 2; /* 2-byte offset may grow to 4-byte offset */\n+      else if (kind < -1)\n+\tpc += 5; /* May need to add a goto_w. */\n+    }\n+  state->code_length = pc;\n+}\n+\n+void\n+define_jcf_label (label, state)\n+     struct jcf_block *label;\n+     struct jcf_partial *state;\n+{\n+  if (state->last_block != NULL)\n+    finish_jcf_block (state);\n+  label->pc = state->code_length;\n+  if (state->blocks == NULL)\n+    state->blocks = label;\n+  else\n+    state->last_block->next = label;\n+  state->last_block = label;\n+  label->next = NULL;\n+  label->u.relocations = NULL;\n+}\n+\n+struct jcf_block *\n+get_jcf_label_here (state)\n+     struct jcf_partial *state;\n+{\n+  if (state->last_block != NULL && BUFFER_LENGTH (&state->bytecode) == 0)\n+    return state->last_block;\n+  else\n+    {\n+      struct jcf_block *label = gen_jcf_label (state);\n+      define_jcf_label (label, state);\n+      return label;\n+    }\n+}\n \n-/* Append a line number entry for the given PC and LINE into\n-   linenumbers.data.  This will later before a LineNumberTable attribute. */\n+/* Note a line number entry for the current PC and given LINE. */\n \n void\n-put_linenumber (pc, line)\n-     int pc, line;\n+put_linenumber (line, state)\n+     int line;\n+     struct jcf_partial *state;\n {\n-  register unsigned char *ptr;\n-  if (linenumbers.ptr == linenumbers.limit)\n-    buffer_grow (&linenumbers, 4);\n-  ptr = linenumbers.ptr;\n-  PUT2 (pc);\n-  PUT2 (line);\n-  linenumbers.ptr = ptr;\n+  (get_jcf_label_here (state))->linenumber = line;\n+  state->linenumber_count++;\n }\n+\n \f\n /* The index of jvm local variable allocated for this DECL.\n-   This is assign when generating .class files;\n-   contrast DECL_LOCAL_SLOT_NUMBER whcih is set when *reading* a .class file.\n+   This is assigned when generating .class files;\n+   contrast DECL_LOCAL_SLOT_NUMBER which is set when *reading* a .class file.\n    (We don't allocate DECL_LANG_SPECIFIC for locals from Java sourc code.) */\n \n #define DECL_LOCAL_INDEX(DECL) DECL_ALIGN(DECL)\n \n struct localvar_info\n {\n-  tree decl;\n+  struct localvar_info *next;\n \n-  int start_pc;\n-\n-  /* Offset in LocalVariableTable. */\n-  int debug_offset;\n+  tree decl;\n+  struct jcf_block *start_label;\n+  struct jcf_block *end_label;\n };\n \n-struct buffer localvars = NULL_BUFFER;\n-\n-#define localvar_buffer ((struct localvar_info*) localvars.data)\n-#define localvar_max ((struct localvar_info*) localvars.ptr - localvar_buffer)\n-\n-/* A buffer for storing LocalVariableTable entries entries. */\n-\n-struct buffer localvartable = NULL_BUFFER;\n+#define localvar_buffer ((struct localvar_info**) state->localvars.data)\n+#define localvar_max \\\n+  ((struct localvar_info**) state->localvars.ptr - localvar_buffer)\n \n int\n-localvar_alloc (decl, start_pc)\n+localvar_alloc (decl, state)\n      tree decl;\n-     int start_pc;\n+     struct jcf_partial *state;\n {\n+  struct jcf_block *start_label = get_jcf_label_here (state);\n   int wide = TYPE_IS_WIDE (TREE_TYPE (decl));\n   int index;\n-  register struct localvar_info *info = (struct localvar_info*)localvars.data;\n-  register struct localvar_info *limit = (struct localvar_info*)localvars.ptr;\n-  for (index = 0;  info < limit;  index++, info++)\n+  register struct localvar_info *info;\n+  register struct localvar_info **ptr = localvar_buffer;\n+  register struct localvar_info **limit\n+    = (struct localvar_info**) state->localvars.ptr;\n+  for (index = 0;  ptr < limit;  index++, ptr++)\n     {\n-      if (info->decl == NULL_TREE\n-\t  && (! wide || (info+1)->decl == NULL_TREE))\n+      if (ptr[0] == NULL\n+\t  && (! wide || ((ptr+1) < limit && ptr[1] == NULL)))\n \tbreak;\n     }\n-  if (info == limit)\n+  if (ptr == limit)\n     {\n-      buffer_grow (&localvars, sizeof (struct localvar_info));\n-      info = (struct localvar_info*)localvars.data + index;\n-      localvars.ptr = (unsigned char *) (info + 1 + wide);\n+      buffer_grow (&state->localvars, 2 * sizeof (struct localvar_info*));\n+      ptr = (struct localvar_info**) state->localvars.data + index;\n+      state->localvars.ptr = (unsigned char *) (ptr + 1 + wide);\n     }\n-  info->decl = decl;\n+  info = (struct localvar_info *)\n+    obstack_alloc (state->chunk_obstack, sizeof (struct localvar_info));\n+  ptr[0] = info;\n   if (wide)\n-    (info+1)->decl = TYPE_SECOND;\n+    ptr[1] = (struct localvar_info *)(~0);\n   DECL_LOCAL_INDEX (decl) = index;\n-  info->start_pc = start_pc;\n+  info->decl = decl;\n+  info->start_label = start_label;\n \n   if (DECL_NAME (decl) != NULL_TREE)\n     {\n       /* Generate debugging info. */\n-      int i;\n-      register unsigned char *ptr;\n-      buffer_grow (&localvartable, 10);\n-      ptr = localvartable.ptr;\n-      info->debug_offset = ptr - localvartable.data;\n-      PUT2 (start_pc);\n-      PUT2 (0);  /* length - fill in later */\n-      i = find_utf8_constant (code_cpool, DECL_NAME (decl));\n-      PUT2 (i); /* name_index*/\n-      i = find_utf8_constant (code_cpool,\n-\t\t\t      build_java_signature (TREE_TYPE (decl)));\n-      PUT2 (i);  /* descriptor_index */\n-      PUT2 (index);\n-      localvartable.ptr = ptr;\n+      info->next = NULL;\n+      if (state->last_lvar != NULL)\n+\tstate->last_lvar->next = info;\n+      else\n+\tstate->first_lvar = info;\n+      state->last_lvar = info;\n+      state->lvar_count++;\n     }\n-  else\n-    info->debug_offset = -1;\n }\n \n int\n-localvar_free (decl, end_pc)\n-     tree decl;\n-     int end_pc;\n+localvar_free (decl, state)\n+     tree decl;     \n+     struct jcf_partial *state;\n {\n-  register unsigned char *ptr;\n+  struct jcf_block *end_label = get_jcf_label_here (state);\n   int index = DECL_LOCAL_INDEX (decl);\n-  register struct localvar_info *info = &localvar_buffer [index];\n+  register struct localvar_info **ptr = &localvar_buffer [index];\n+  register struct localvar_info *info = *ptr;\n   int wide = TYPE_IS_WIDE (TREE_TYPE (decl));\n   int i;\n \n-  i = info->debug_offset;\n-  if (i >= 0)\n-    {\n-      register unsigned char *ptr;\n-      /* Point to length field of local_variable_table. */\n-      ptr = localvartable.data + i + 2;\n-      i = end_pc - info->start_pc;\n-      PUT2 (i);\n-    }\n+  info->end_label = end_label;\n \n   if (info->decl != decl)\n     abort ();\n-  info->decl = NULL_TREE;\n+  ptr[0] = NULL;\n   if (wide)\n     {\n-      info++;\n-      if (info->decl != TYPE_SECOND)\n+      if (ptr[1] !=  (struct localvar_info *)(~0))\n \tabort ();\n-      info->decl = NULL_TREE;\n+      ptr[1] = NULL;\n     }\n-\n }\n \n \f\n #define STACK_TARGET 1\n #define IGNORE_TARGET 2\n \n-/* Allocate a new chunk on obstack WORK, and link it in after LAST.\n-   Set the data and size fields to DATA and SIZE, respectively.\n-   However, if DATA is NULL and SIZE>0, allocate a buffer as well. */\n-\n-struct chunk *\n-alloc_chunk (last, data, size, work)\n-     struct chunk *last;\n-     unsigned char *data;\n-     int size;\n-     struct obstack *work;\n-{\n-  struct chunk *chunk = (struct chunk *)\n-    obstack_alloc (work, sizeof(struct chunk));\n-\n-  if (data == NULL && size > 0)\n-    data = obstack_alloc (work, size);\n-\n-  chunk->next = NULL;\n-  chunk->data = data;\n-  chunk->size = size;\n-  last->next = chunk;\n-  return chunk;\n-}\n-\n /* Get the access flags of a class (TYPE_DECL), a method (FUNCTION_DECL), or\n    a field (FIELD_DECL or VAR_DECL, if static), as encoded in a .class file. */\n \n@@ -327,9 +489,10 @@ write_chunks (stream, chunks)\n     fwrite (chunks->data, chunks->size, 1, stream);\n }\n \n-void\n-push_constant1 (index)\n+static void\n+push_constant1 (index, state)\n      int index;\n+     struct jcf_partial *state;\n {\n   if (index < 256)\n     {\n@@ -343,18 +506,23 @@ push_constant1 (index)\n     }\n }\n \n-void\n-push_constant2 (index)\n+static void\n+push_constant2 (index, state)\n      int index;\n+     struct jcf_partial *state;\n {\n   RESERVE (3);\n   OP1 (OPCODE_ldc2_w);\n   OP2 (index);\n }\n \n-void\n-push_int_const (i)\n+/* Push 32-bit integer constant on VM stack.\n+   Caller is responsible for doing NOTE_PUSH. */\n+\n+static void\n+push_int_const (i, state)\n      HOST_WIDE_INT i;\n+     struct jcf_partial *state;\n {\n   RESERVE(3);\n   if (i >= -1 && i <= 5)\n@@ -368,17 +536,22 @@ push_int_const (i)\n     {\n       OP1(OPCODE_sipush);\n       OP2(i);\n+      NOTE_PUSH (1);\n     }\n   else\n     {\n-      i = find_constant1 (code_cpool, CONSTANT_Integer, i & 0xFFFFFFFF);\n+      i = find_constant1 (&state->cpool, CONSTANT_Integer, i & 0xFFFFFFFF);\n       push_constant1 (i);\n     }\n }\n \n-void\n-push_long_const (lo, hi)\n+/* Push 64-bit long constant on VM stack.\n+   Caller is responsible for doing NOTE_PUSH. */\n+\n+static void\n+push_long_const (lo, hi, state)\n      HOST_WIDE_INT lo, hi;\n+     struct jcf_partial *state;\n {\n   if (hi == 0 && lo >= 0 && lo <= 1)\n     {\n@@ -388,7 +561,7 @@ push_long_const (lo, hi)\n #if 0\n     else if ((jlong) (jint) i == i)\n       {\n-        push_int_const ((jint) i);\n+        push_int_const ((jint) i, state);\n         RESERVE (1);\n         OP1 (OPCODE_i2l);\n       }\n@@ -397,18 +570,19 @@ push_long_const (lo, hi)\n     {\n       HOST_WIDE_INT w1, w2;\n       lshift_double (lo, hi, -32, 64, &w1, &w2, 1);\n-      hi = find_constant1 (code_cpool, CONSTANT_Long,\n+      hi = find_constant1 (&state->cpool, CONSTANT_Long,\n \t\t\t   w1 & 0xFFFFFFFF, lo & 0xFFFFFFFF);\n       push_constant2 (hi);\n     }\n }\n \n-void\n-field_op (field, opcode)\n+static void\n+field_op (field, opcode, state)\n      tree field;\n      int opcode;\n+     struct jcf_partial *state;\n {\n-  int index = find_fieldref_index (code_cpool, field);\n+  int index = find_fieldref_index (&state->cpool, field);\n   RESERVE (3);\n   OP1 (opcode);\n   OP2 (index);\n@@ -424,10 +598,12 @@ adjust_typed_op (type)\n {\n   switch (TREE_CODE (type))\n     {\n-    case BOOLEAN_TYPE:  return 5;\n-    case CHAR_TYPE:     return 6;\n     case POINTER_TYPE:\n     case RECORD_TYPE:   return 4;\n+    case BOOLEAN_TYPE:\n+      return TYPE_PRECISION (type) == 32 ? 0 : 5;\n+    case CHAR_TYPE:\n+      return TYPE_PRECISION (type) == 32 ? 0 : 6;\n     case INTEGER_TYPE:\n       switch (TYPE_PRECISION (type))\n \t{\n@@ -448,14 +624,15 @@ adjust_typed_op (type)\n   abort ();\n }\n \n-void\n-maybe_wide (opcode, index)\n+static void\n+maybe_wide (opcode, index, state)\n      int opcode, index;\n+     struct jcf_partial *state;\n {\n   if (index >= 256)\n     {\n       RESERVE (4);\n-      OP1 (196); /* wide */\n+      OP1 (OPCODE_wide);\n       OP1 (opcode);\n       OP2 (index);\n     }\n@@ -467,21 +644,382 @@ maybe_wide (opcode, index)\n     }\n }\n \n-#define PC BUFFER_LENGTH(&bytecode)\n+/* Compile code to duplicate with offset, where\n+   SIZE is the size of the stack item to duplicate (1 or 2), abd\n+   OFFSET is where to insert the result (must be 0, 1, or 2).\n+   (The new words get inserted at stack[SP-size-offset].) */\n \n-/* Generate byetcode for sub-expression EXP of METHOD.\n-   TARGET is one of STACK_TARGET or IGNORE_TARGET. */\n+static void\n+emit_dup (size, offset, state)\n+     int size, offset;\n+     struct jcf_partial *state;\n+{\n+  int kind;\n+  if (size == 0)\n+    return;\n+  RESERVE(1);\n+  if (offset == 0)\n+    kind = size == 1 ? OPCODE_dup : OPCODE_dup2;\n+  else if (offset == 1)\n+    kind = size == 1 ? OPCODE_dup_x1 : OPCODE_dup2_x1;\n+  else if (offset == 2)\n+    kind = size == 1 ? OPCODE_dup_x2 : OPCODE_dup2_x2;\n+  else\n+    abort();\n+  OP1 (kind);\n+  NOTE_PUSH (size);\n+}\n+\n+static void\n+emit_pop (size, state)\n+     int size;\n+     struct jcf_partial *state;\n+{\n+  RESERVE (1);\n+  OP1 (OPCODE_pop - 1 + size);\n+}\n+\n+static void\n+emit_iinc (var, value, state)\n+     tree var;\n+     int value;\n+     struct jcf_partial *state;\n+{\n+  int slot = DECL_LOCAL_INDEX (var);\n+\n+  if (value < -128 || value > 127 || slot >= 256)\n+    {\n+      RESERVE (6);\n+      OP1 (OPCODE_wide);\n+      OP1 (OPCODE_iinc);\n+      OP2 (slot);\n+      OP2 (value);\n+    }\n+  else\n+    {\n+      RESERVE (3);\n+      OP1 (OPCODE_iinc);\n+      OP1 (slot);\n+      OP1 (value);\n+    }\n+}\n+\n+static void\n+emit_load_or_store (var, opcode, state)\n+     tree var;\n+     struct jcf_partial *state;\n+{\n+  tree type = TREE_TYPE (var);\n+  int kind = adjust_typed_op (type);\n+  int index = DECL_LOCAL_INDEX (var);\n+  if (index <= 3)\n+    {\n+      RESERVE (1);\n+      OP1 (opcode + 5 + 4 * kind + index);    /* [ilfda]{load,store}_[0123] */\n+    }\n+  else\n+    maybe_wide (opcode + kind, index);  /* [ilfda]{load,store} */\n+}\n+\n+static void\n+emit_load (var, state)\n+     tree var;\n+     struct jcf_partial *state;\n+{\n+  emit_load_or_store (var, OPCODE_iload, state);\n+  NOTE_PUSH (TYPE_IS_WIDE (TREE_TYPE (var)) ? 2 : 1);\n+}\n+\n+static void\n+emit_store (var, state)\n+     tree var;\n+     struct jcf_partial *state;\n+{\n+  emit_load_or_store (var, OPCODE_istore, state);\n+  NOTE_POP (TYPE_IS_WIDE (TREE_TYPE (var)) ? 2 : 1);\n+}\n+\n+static void\n+emit_binop (opcode, type, state)\n+     enum java_opcode opcode;\n+     tree type;\n+     struct jcf_partial *state;\n+{\n+  int size = TYPE_IS_WIDE (type) ? 2 : 1;\n+  RESERVE(1);\n+  OP1 (opcode);\n+  NOTE_POP (size);\n+}\n+\n+/* Emit a conditional jump to TARGET with a 2-byte relative jump offset\n+   The opcode is OPCODE, the inverted opcode is INV_OPCODE. */\n+\n+static void\n+emit_if (target, opcode, inv_opcode, state)\n+     struct jcf_block *target;\n+     int opcode, inv_opcode;\n+     struct jcf_partial *state;\n+{\n+  struct jcf_relocation *reloc = (struct jcf_relocation *)\n+    obstack_alloc (state->chunk_obstack, sizeof (struct jcf_relocation));\n+  struct jcf_block *block = state->last_block;\n+  reloc->next = block->u.relocations;\n+  block->u.relocations = reloc;\n+  OP1 (opcode);\n+  reloc->offset = BUFFER_LENGTH (&state->bytecode);\n+  OP2 (1); // 1 byte from reloc back to start of instruction.\n+  reloc->kind = - inv_opcode;\n+  reloc->label = target;\n+}\n+\n+static void\n+emit_goto_or_jsr (target, opcode, opcode_w, state)\n+     struct jcf_block *target;\n+     int opcode, opcode_w;\n+     struct jcf_partial *state;\n+{\n+  struct jcf_relocation *reloc = (struct jcf_relocation *)\n+    obstack_alloc (state->chunk_obstack, sizeof (struct jcf_relocation));\n+  struct jcf_block *block = state->last_block;\n+  reloc->next = block->u.relocations;\n+  block->u.relocations = reloc;\n+  OP1 (opcode);\n+  reloc->offset = BUFFER_LENGTH (&state->bytecode);\n+  OP2 (1); // 1 byte from reloc back to start of instruction.\n+  reloc->kind = opcode_w;\n+  reloc->label = target;\n+}\n+\n+static void\n+emit_goto (target, state)\n+     struct jcf_block *target;\n+     struct jcf_partial *state;\n+{\n+  emit_goto_or_jsr (target, OPCODE_goto, OPCODE_goto_w, state);\n+}\n+\n+static void\n+emit_jsr (target, state)\n+     struct jcf_block *target;\n+     struct jcf_partial *state;\n+{\n+  emit_goto_or_jsr (target, OPCODE_jsr, OPCODE_jsr_w, state);\n+}\n+\n+/* Generate code to evaluate EXP.  If the result is true,\n+   branch to TRUE_LABEL; otherwise, branch to FALSE_LABEL.\n+   TRUE_BRANCH_FIRST is a code geneation hint that the\n+   TRUE_LABEL may follow right after this. (The idea is that we\n+   may be able to optimize away GOTO TRUE_LABEL; TRUE_LABEL:) */\n \n void\n-generate_bytecode_insns (method, exp, target)\n-     tree method;\n+generate_bytecode_conditional (exp, true_label, false_label,\n+\t\t\t       true_branch_first, state)\n+     tree exp;\n+     struct jcf_block *true_label;\n+     struct jcf_block *false_label;\n+     int true_branch_first;\n+     struct jcf_partial *state;\n+{\n+  int kind;\n+  tree exp0, exp1, type;\n+  int save_SP = state->code_SP;\n+  enum java_opcode op, negop;\n+  switch (TREE_CODE (exp))\n+    {\n+    case INTEGER_CST:\n+      emit_goto (integer_zerop (exp) ? false_label : true_label, state);\n+      break;\n+    case COND_EXPR:\n+      {\n+\tstruct jcf_block *then_label = gen_jcf_label (state);\n+\tstruct jcf_block *else_label = gen_jcf_label (state);\n+\tint save_SP_before, save_SP_after;\n+\tgenerate_bytecode_conditional (TREE_OPERAND (exp, 0),\n+\t\t\t\t       then_label, else_label, 1, state);\n+\tdefine_jcf_label (then_label, state);\n+\tsave_SP_before = state->code_SP;\n+\tgenerate_bytecode_conditional (TREE_OPERAND (exp, 1),\n+\t\t\t\t       true_label, false_label, 1, state);\n+\tsave_SP_after = state->code_SP;\n+\tstate->code_SP = save_SP_before;\n+\tdefine_jcf_label (else_label, state);\n+\tgenerate_bytecode_conditional (TREE_OPERAND (exp, 2),\n+\t\t\t\t       true_label, false_label,\n+\t\t\t\t       true_branch_first, state);\n+\tif (state->code_SP != save_SP_after)\n+\t  fatal (\"internal error  non-matching SP\");\n+      }\n+      break;\n+    case TRUTH_ANDIF_EXPR:\n+      {\n+\tstruct jcf_block *next_label = gen_jcf_label (state);\n+\tgenerate_bytecode_conditional (TREE_OPERAND (exp, 0),\n+\t\t\t\t       next_label, false_label, 1, state);\n+\tdefine_jcf_label (next_label, state);\n+\tgenerate_bytecode_conditional (TREE_OPERAND (exp, 1),\n+\t\t\t\t       true_label, false_label, 1, state);\n+      }\n+      break;\n+    case TRUTH_ORIF_EXPR:\n+      {\n+\tstruct jcf_block *next_label = gen_jcf_label (state);\n+\tgenerate_bytecode_conditional (TREE_OPERAND (exp, 0),\n+\t\t\t\t       true_label, next_label, 1, state);\n+\tdefine_jcf_label (next_label, state);\n+\tgenerate_bytecode_conditional (TREE_OPERAND (exp, 1),\n+\t\t\t\t       true_label, false_label, 1, state);\n+      }\n+      break;\n+    compare_1:\n+      /* Assuming op is one of the 2-operand if_icmp<COND> instructions,\n+\t set it to the corresponding 1-operand if<COND> instructions. */\n+      op = op - 6;\n+      /* FALLTHROUGH */\n+    compare_2:\n+      /* The opcodes with their inverses are allocated in pairs.\n+\t E.g.  The inverse of if_icmplt (161) is if_icmpge (162). */\n+      negop = (op & 1) ? op + 1 : op - 1;\n+    compare_2_ptr:\n+      if (true_branch_first)\n+\t{\n+\t  emit_if (false_label, negop, op, state);\n+\t  emit_goto (true_label, state);\n+\t}\n+      else\n+\t{\n+\t  emit_if (true_label, op, negop, state);\n+\t  emit_goto (false_label, state);\n+\t}\n+      break;\n+    case EQ_EXPR:\n+      op = OPCODE_if_icmpeq;\n+      goto compare;\n+    case NE_EXPR:\n+      op = OPCODE_if_icmpne;\n+      goto compare;\n+    case GT_EXPR:\n+      op = OPCODE_if_icmpgt;\n+      goto compare;\n+    case LT_EXPR:\n+      op = OPCODE_if_icmplt;\n+      goto compare;\n+    case GE_EXPR:\n+      op = OPCODE_if_icmpge;\n+      goto compare;\n+    case LE_EXPR:\n+      op = OPCODE_if_icmple;\n+      goto compare;\n+    compare:\n+      exp0 = TREE_OPERAND (exp, 0);\n+      exp1 = TREE_OPERAND (exp, 1);\n+      type = TREE_TYPE (exp0);\n+      switch (TREE_CODE (type))\n+\t{\n+\tcase POINTER_TYPE:  case RECORD_TYPE:\n+\t  switch (TREE_CODE (exp))\n+\t    {\n+\t    case EQ_EXPR:  op = OPCODE_if_acmpeq;  break;\n+\t    case NE_EXPR:  op = OPCODE_if_acmpne;  break;\n+\t    default:  abort();\n+\t    }\n+\t  if (integer_zerop (exp1) || integer_zerop (exp0))\n+\t    {\n+\t      generate_bytecode_insns (integer_zerop (exp1) ? exp0 : exp0,\n+\t\t\t\t       STACK_TARGET, state);\n+\t      op = op + (OPCODE_ifnull - OPCODE_if_acmpeq);\n+\t      negop = (op & 1) ? op - 1 : op + 1;\n+\t      NOTE_POP (1);\n+\t      goto compare_2_ptr;\n+\t    }\n+\t  generate_bytecode_insns (exp0, STACK_TARGET, state);\n+\t  generate_bytecode_insns (exp1, STACK_TARGET, state);\n+\t  NOTE_POP (2);\n+\t  goto compare_2;\n+\tcase REAL_TYPE:\n+\t  fatal (\"float comparison not implemented\");\n+\tcase INTEGER_TYPE:\n+\t  if (TYPE_PRECISION (type) > 32)\n+\t    {\n+\t      generate_bytecode_insns (exp0, STACK_TARGET, state);\n+\t      generate_bytecode_insns (exp1, STACK_TARGET, state);\n+\t      NOTE_POP (4);\n+\t      RESERVE (1);\n+\t      OP1 (OPCODE_lcmp);\n+\t      goto compare_1;\n+\t    }\n+\t  /* FALLTHOUGH */\n+\tdefault:\n+\t  if (integer_zerop (exp1))\n+\t    {\n+\t      generate_bytecode_insns (exp0, STACK_TARGET, state);\n+\t      NOTE_POP (1);\n+\t      goto compare_1;\n+\t    }\n+\t  if (integer_zerop (exp0))\n+\t    {\n+\t      switch (op)\n+\t\t{\n+\t\tcase OPCODE_if_icmplt:\n+\t\tcase OPCODE_if_icmpge:\n+\t\t  op += 2;\n+\t\t  break;\n+\t\tcase OPCODE_if_icmpgt:\n+\t\tcase OPCODE_if_icmple:\n+\t\t  op -= 2;\n+\t\t  break;\n+\t\t}\n+\t      generate_bytecode_insns (exp1, STACK_TARGET, state);\n+\t      NOTE_POP (1);\n+\t      goto compare_1;\n+\t    }\n+\t  generate_bytecode_insns (exp0, STACK_TARGET, state);\n+\t  generate_bytecode_insns (exp1, STACK_TARGET, state);\n+\t  NOTE_POP (2);\n+\t  goto compare_2;\n+\t}\n+\n+    default:\n+      generate_bytecode_insns (exp, STACK_TARGET, state);\n+      NOTE_POP (1);\n+      if (true_branch_first)\n+\t{\n+\t  emit_if (false_label, OPCODE_ifeq, OPCODE_ifne, state);\n+\t  emit_goto (true_label, state);\n+\t}\n+      else\n+\t{\n+\t  emit_if (true_label, OPCODE_ifne, OPCODE_ifeq, state);\n+\t  emit_goto (false_label, state);\n+\t}\n+      break;\n+    }\n+  if (save_SP != state->code_SP)\n+    fatal (\"inetrnal error - SP mismatch\");\n+}\n+\n+/* Generate bytecode for sub-expression EXP of METHOD.\n+   TARGET is one of STACK_TARGET or IGNORE_TARGET. */\n+\n+static void\n+generate_bytecode_insns (exp, target, state)\n      tree exp;\n      int target;\n+     struct jcf_partial *state;\n {\n-  rtx value;\n-  tree type = TREE_TYPE (exp);\n+  tree type;\n   enum java_opcode jopcode;\n   int op;\n+  HOST_WIDE_INT value;\n+  int post_op;\n+  int size;\n+  int offset;\n+\n+  if (exp == NULL && target == IGNORE_TARGET)\n+    return;\n+\n+  type = TREE_TYPE (exp);\n+\n   switch (TREE_CODE (exp))\n     {\n     case BLOCK:\n@@ -491,21 +1029,21 @@ generate_bytecode_insns (method, exp, target)\n \t  for (local = BLOCK_EXPR_DECLS (exp); local; )\n \t    {\n \t      tree next = TREE_CHAIN (local);\n-\t      localvar_alloc (local, PC);\n+\t      localvar_alloc (local, state);\n \t      local = next;\n \t    }\n-\t  generate_bytecode_insns (method, BLOCK_EXPR_BODY (exp), target);\n+\t  generate_bytecode_insns (BLOCK_EXPR_BODY (exp), target, state);\n \t  for (local = BLOCK_EXPR_DECLS (exp); local; )\n \t    {\n \t      tree next = TREE_CHAIN (local);\n-\t      localvar_free (local, PC);\n+\t      localvar_free (local, state);\n \t      local = next;\n \t    }\n \t}\n       break;\n       case COMPOUND_EXPR:\t\n-\tgenerate_bytecode_insns (method, TREE_OPERAND (exp, 0), IGNORE_TARGET);\n-\tgenerate_bytecode_insns (method, TREE_OPERAND (exp, 1), target);\n+\tgenerate_bytecode_insns (TREE_OPERAND (exp, 0), IGNORE_TARGET, state);\n+\tgenerate_bytecode_insns (TREE_OPERAND (exp, 1), target, state);\n       break;\n     case EXPR_WITH_FILE_LOCATION:\n       {\n@@ -514,8 +1052,8 @@ generate_bytecode_insns (method, exp, target)\n \tinput_filename = EXPR_WFL_FILENAME (exp);\n \tlineno = EXPR_WFL_LINENO (exp);\n \tif (EXPR_WFL_EMIT_LINE_NOTE (exp))\n-\t  put_linenumber (PC, EXPR_WFL_LINENO (exp));\n-\tgenerate_bytecode_insns (method, EXPR_WFL_NODE (exp), target);\n+\t  put_linenumber (EXPR_WFL_LINENO (exp), state);\n+\tgenerate_bytecode_insns (EXPR_WFL_NODE (exp), target, state);\n \tinput_filename = saved_input_filename;\n \tlineno = saved_lineno;\n       }\n@@ -532,55 +1070,48 @@ generate_bytecode_insns (method, exp, target)\n \t}\n       else if (TYPE_PRECISION (type) <= 32)\n \t{\n-\t  push_int_const (TREE_INT_CST_LOW (exp));\n+\t  push_int_const (TREE_INT_CST_LOW (exp), state);\n \t  NOTE_PUSH (1);\n \t}\n       else\n \t{\n-\t  push_long_const (TREE_INT_CST_LOW (exp), TREE_INT_CST_HIGH (exp));\n+\t  push_long_const (TREE_INT_CST_LOW (exp), TREE_INT_CST_HIGH (exp),\n+\t\t\t   state);\n \t  NOTE_PUSH (2);\n \t}\n       break;\n     case VAR_DECL:\n       if (TREE_STATIC (exp))\n \t{\n-\t  field_op (exp, OPCODE_getstatic);\n+\t  field_op (exp, OPCODE_getstatic, state);\n+\t  NOTE_PUSH (TYPE_IS_WIDE (TREE_TYPE (exp)) ? 2 : 1);\n \t  break;\n \t}\n       /* ... fall through ... */\n     case PARM_DECL:\n-      {\n-\tint kind = adjust_typed_op (type);\n-\tint index = DECL_LOCAL_INDEX (exp);\n-\tif (index <= 3)\n-\t  {\n-\t    RESERVE (1);\n-\t    OP1 (26 + 4 * kind + index);    /* [ilfda]load_[0123] */\n-\t  }\n-\telse\n-\t  maybe_wide (21 + kind, index);  /* [ilfda]load */\n-      }\n+      emit_load (exp, state);\n       break;\n     case INDIRECT_REF:\n-      generate_bytecode_insns (method, TREE_OPERAND (exp, 0), target);\n+      generate_bytecode_insns (TREE_OPERAND (exp, 0), target, state);\n       break;\n     case ARRAY_REF:\n-      generate_bytecode_insns (method, TREE_OPERAND (exp, 0), target);\n-      generate_bytecode_insns (method, TREE_OPERAND (exp, 1), target);\n+      generate_bytecode_insns (TREE_OPERAND (exp, 0), target, state);\n+      generate_bytecode_insns (TREE_OPERAND (exp, 1), target, state);\n       if (target != IGNORE_TARGET)\n \t{\n \t  jopcode = OPCODE_iaload + adjust_typed_op (type);\n \t  RESERVE(1);\n \t  OP1 (jopcode);\n+\t  NOTE_POP (2);\n \t}\n       break;\n     case COMPONENT_REF:\n       {\n \ttree obj = TREE_OPERAND (exp, 0);\n \ttree field = TREE_OPERAND (exp, 1);\n \tint is_static = FIELD_STATIC (field);\n-\tgenerate_bytecode_insns (method, obj,\n-\t\t\t\t is_static ? IGNORE_TARGET : target);\n+\tgenerate_bytecode_insns (obj,\n+\t\t\t\t is_static ? IGNORE_TARGET : target, state);\n \tif (target != IGNORE_TARGET)\n \t  {\n \t    if (DECL_NAME (field) == length_identifier_node && !is_static\n@@ -590,10 +1121,54 @@ generate_bytecode_insns (method, exp, target)\n \t\tOP1 (OPCODE_arraylength);\n \t      }\n \t    else\n-\t      field_op (field, is_static ? OPCODE_getstatic : OPCODE_getfield);\n+\t      {\n+\t\tfield_op (field, is_static ? OPCODE_getstatic : OPCODE_getfield,\n+\t\t\t  state);\n+\t\tif (! is_static)\n+\t\t  NOTE_POP (1);\n+\t\tNOTE_PUSH (TYPE_IS_WIDE (TREE_TYPE (field)) ? 2 : 1);\n+\t      }\n \t  }\n       }\n       break;\n+    case TRUTH_ANDIF_EXPR:\n+    case TRUTH_ORIF_EXPR:\n+    case EQ_EXPR:\n+    case NE_EXPR:\n+    case GT_EXPR:\n+    case LT_EXPR:\n+    case GE_EXPR:\n+    case LE_EXPR:\n+      {\n+\tstruct jcf_block *then_label = gen_jcf_label (state);\n+\tstruct jcf_block *else_label = gen_jcf_label (state);\n+\tstruct jcf_block *end_label = gen_jcf_label (state);\n+\tgenerate_bytecode_conditional (exp,\n+\t\t\t\t       then_label, else_label, 1, state);\n+\tdefine_jcf_label (then_label, state);\n+\tpush_int_const (1, state);\n+\temit_goto (end_label, state);\n+\tdefine_jcf_label (else_label, state);\n+\tpush_int_const (0, state);\n+\tdefine_jcf_label (end_label, state);\n+\tNOTE_PUSH (1);\n+      }\n+      break;\n+    case COND_EXPR:\n+      {\n+\tstruct jcf_block *then_label = gen_jcf_label (state);\n+\tstruct jcf_block *else_label = gen_jcf_label (state);\n+\tstruct jcf_block *end_label = gen_jcf_label (state);\n+\tgenerate_bytecode_conditional (TREE_OPERAND (exp, 0),\n+\t\t\t\t       then_label, else_label, 1, state);\n+\tdefine_jcf_label (then_label, state);\n+\tgenerate_bytecode_insns (TREE_OPERAND (exp, 1), target, state);\n+\temit_goto (end_label, state);\n+\tdefine_jcf_label (else_label, state);\n+\tgenerate_bytecode_insns (TREE_OPERAND (exp, 2), target, state);\n+\tdefine_jcf_label (end_label, state);\n+      }\n+      break;\n     case RETURN_EXPR:\n       if (!TREE_OPERAND (exp, 0))\n \top = OPCODE_return;\n@@ -604,89 +1179,234 @@ generate_bytecode_insns (method, exp, target)\n \t    abort ();\n \t  exp = TREE_OPERAND (exp, 1);\n \t  op = OPCODE_ireturn + adjust_typed_op (TREE_TYPE (exp));\n-\t  generate_bytecode_insns (method, exp, STACK_TARGET);\n+\t  generate_bytecode_insns (exp, STACK_TARGET, state);\n \t}\n       RESERVE (1);\n       OP1 (op);\n       break;\n-    case MODIFY_EXPR:\n+    case LABELED_BLOCK_EXPR:\n       {\n-\ttree lhs = TREE_OPERAND (exp, 0);\n-\ttree rhs = TREE_OPERAND (exp, 1);\n-\tHOST_WIDE_INT value;\n+\tstruct jcf_block *end_label = gen_jcf_label (state);\n+\tend_label->next = state->labeled_blocks;\n+\tstate->labeled_blocks = end_label;\n+\tend_label->u.labeled_block = exp;\n+\tif (LABELED_BLOCK_BODY (exp))\n+\t  generate_bytecode_insns (LABELED_BLOCK_BODY (exp), target, state);\n+\tif (state->labeled_blocks != end_label)\n+\t  abort();\n+\tstate->labeled_blocks = end_label->next;\n+\tdefine_jcf_label (end_label, state);\n+      }\n+      break;\n+    case LOOP_EXPR:\n+      {\n+\ttree body = TREE_OPERAND (exp, 0);\n #if 0\n-\tif (TREE_CODE (rhs) == PLUS_EXPR\n-\t    && TREE_CODE (lhs) == VAR_DECL\n-\t    /* && FIXME lhs is a local variable */\n-\t    && TYPE_MODE (TREE)TYPE (lhs) == SImode /* ??? */\n-\t    && TREE_OPERAND (rhs, 0) == lhs\n-\t    && TREE_CODE (TREE_OPERAND (rhs, 1)) == INTEGER_CST\n-\t    /* or vice versa FIXME */\n-\t    && (value = TREE_INT_CST_LOW (TREE_OPERAND (rhs, 1)),\n-\t\t(value >= -32768 && value <= 32767)))\n+\tif (TREE_CODE (body) == COMPOUND_EXPR\n+\t    && TREE_CODE (TREE_OPERAND (body, 0)) == EXIT_EXPR)\n \t  {\n-\t    emit_insn (gen_rtx (SET, SImode,\n-\t\t\t\tDECL_RTL (lhs),\n-\t\t\t\tgen_rtx (PLUS, SImode,\n-\t\t\t\t\t DECL_RTL (lhs),\n-\t\t\t\t\t gen_rtx_CONST_INT (SImode, value))));\n-\t    return DECL_RTL (lhs);\n+\t    /* Optimize:  H: if (TEST) GOTO L; BODY; GOTO H; L:\n+\t       to:  GOTO L;  BODY;  L:  if (!TEST) GOTO L; */\n+\t    struct jcf_block *head_label;\n+\t    struct jcf_block *body_label;\n+\t    struct jcf_block *end_label = gen_jcf_label (state);\n+\t    struct jcf_block *exit_label = state->labeled_blocks;\n+\t    head_label = gen_jcf_label (state);\n+\t    emit_goto (head_label, state);\n+\t    body_label = get_jcf_label_here (state);\n+\t    generate_bytecode_insns (TREE_OPERAND (body, 1), target, state);\n+\t    define_jcf_label (head_label, state);\n+\t    generate_bytecode_conditional (TREE_OPERAND (body, 0),\n+\t\t\t\t\t   end_label, body_label, 1, state);\n+\t    define_jcf_label (end_label, state);\n \t  }\n+\telse\n #endif\n-\tif (TREE_CODE (lhs) == COMPONENT_REF)\n-\t  generate_bytecode_insns (method, TREE_OPERAND (lhs, 0), STACK_TARGET);\n-\telse if (TREE_CODE (lhs) == ARRAY_REF)\n-\t  {\n-\t    generate_bytecode_insns (method,\n-\t\t\t\t     TREE_OPERAND (lhs, 0), STACK_TARGET);\n-\t    generate_bytecode_insns (method,\n-\t\t\t\t     TREE_OPERAND (lhs, 1), STACK_TARGET);\n-\t  }\n-\tgenerate_bytecode_insns (method, rhs, STACK_TARGET);\n-\tif (target != IGNORE_TARGET)\n-\t  {\n-\t    RESERVE (1);\n-\t    OP1 (TYPE_IS_WIDE (type) ? OPCODE_dup2_x1 : OPCODE_dup_x1);\n-\t  }\n-\tif (TREE_CODE (lhs) == COMPONENT_REF)\n \t  {\n-\t    tree field = TREE_OPERAND (lhs, 1);\n-\t    field_op (field,\n-\t\t      FIELD_STATIC (field) ? OPCODE_putstatic\n-\t\t      : OPCODE_putfield);\n+\t    struct jcf_block *head_label = get_jcf_label_here (state);\n+\t    generate_bytecode_insns (body, IGNORE_TARGET, state);\n+\t    emit_goto (head_label, state);\n \t  }\n-\telse if (TREE_CODE (lhs) == VAR_DECL\n-\t\t || TREE_CODE (lhs) == PARM_DECL)\n+      }\n+      break;\n+    case EXIT_EXPR:\n+      {\n+\tstruct jcf_block *label = state->labeled_blocks;\n+\tstruct jcf_block *end_label = gen_jcf_label (state);\n+\tgenerate_bytecode_conditional (TREE_OPERAND (exp, 0),\n+\t\t\t\t       label, end_label, 0, state);\n+\tdefine_jcf_label (end_label, state);\n+      }\n+      break;\n+    case EXIT_BLOCK_EXPR:\n+      {\n+\tstruct jcf_block *label = state->labeled_blocks;\n+\tif (TREE_OPERAND (exp, 1) != NULL) goto notimpl;\n+\twhile (label->u.labeled_block != TREE_OPERAND (exp, 0))\n+\t  label = label->next;\n+\temit_goto (label, state);\n+      }\n+      break;\n+\n+    case PREDECREMENT_EXPR:  value = -1; post_op = 0;  goto increment;\n+    case PREINCREMENT_EXPR:  value =  1; post_op = 0;  goto increment;\n+    case POSTDECREMENT_EXPR: value = -1; post_op = 1;  goto increment;\n+    case POSTINCREMENT_EXPR: value =  1; post_op = 1;  goto increment;\n+    increment:\n+\n+      exp = TREE_OPERAND (exp, 0);\n+      type = TREE_TYPE (exp);\n+      size = TYPE_IS_WIDE (type) ? 2 : 1;\n+      if ((TREE_CODE (exp) == VAR_DECL || TREE_CODE (exp) == PARM_DECL)\n+\t  && ! TREE_STATIC (exp)\n+\t  && TREE_CODE (type) == INTEGER_TYPE\n+\t  && TYPE_PRECISION (type) == 32)\n+\t{\n+\t  if (target != IGNORE_TARGET && post_op)\n+\t    emit_load (exp, state);\n+\t  emit_iinc (exp, value, state);\n+\t  if (target != IGNORE_TARGET)\n+\t    {\n+\t      if (! post_op)\n+\t\temit_load (exp, state);\n+\t      NOTE_PUSH (1);\n+\t    }\n+\t  break;\n+\t}\n+      if (TREE_CODE (exp) == COMPONENT_REF)\n+\t{\n+\t  generate_bytecode_insns (TREE_OPERAND (exp, 0), STACK_TARGET, state);\n+\t  emit_dup (1, 0, state);\n+\t  /* Stack:  ..., objectref, objectref. */\n+\t  field_op (TREE_OPERAND (exp, 1), OPCODE_getstatic, state);\n+\t  NOTE_PUSH (size);\n+\t  /* Stack:  ..., objectref, oldvalue. */\n+\t  offset = 1;\n+\t}\n+      else if (TREE_CODE (exp) == ARRAY_REF)\n+\t{\n+\t  generate_bytecode_insns (TREE_OPERAND (exp, 0), STACK_TARGET, state);\n+\t  generate_bytecode_insns (TREE_OPERAND (exp, 1), STACK_TARGET, state);\n+\t  emit_dup (2, 0, state);\n+\t  /* Stack:  ..., array, index, array, index. */\n+\t  jopcode = OPCODE_iaload + adjust_typed_op (TREE_TYPE (exp));\n+\t  RESERVE(1);\n+\t  OP1 (jopcode);\n+\t  NOTE_POP (2-size);\n+\t  /* Stack:  ..., array, index, oldvalue. */\n+\t  offset = 2;\n+\t}\n+      else if (TREE_CODE (exp) == VAR_DECL || TREE_CODE (exp) == PARM_DECL)\n+\t{\n+\t  generate_bytecode_insns (exp, STACK_TARGET, state);\n+\t  /* Stack:  ..., oldvalue. */\n+\t  offset = 0;\n+\t}\n+      else\n+\tabort ();\n+\n+      if (target != IGNORE_TARGET && post_op)\n+\temit_dup (size, offset, state);\n+      /* Stack, if ARRAY_REF:  ..., [result, ] array, index, oldvalue. */\n+      /* Stack, if COMPONENT_REF:  ..., [result, ] objectref, oldvalue. */\n+      /* Stack, otherwise:  ..., [result, ] oldvalue. */\n+      push_int_const (value, state); /* FIXME - assumes int! */\n+      NOTE_PUSH (1);\n+      emit_binop (OPCODE_iadd + adjust_typed_op (type), type, state);\n+      if (target != IGNORE_TARGET && ! post_op)\n+\temit_dup (size, offset, state);\n+      /* Stack:  ..., [result,] newvalue. */\n+      goto finish_assignment;\n+\n+    case MODIFY_EXPR:\n+      {\n+\ttree lhs = TREE_OPERAND (exp, 0);\n+\ttree rhs = TREE_OPERAND (exp, 1);\n+\n+\t/* See if we can use the iinc instruction. */\n+\tif ((TREE_CODE (lhs) == VAR_DECL || TREE_CODE (lhs) == PARM_DECL)\n+\t    && ! TREE_STATIC (lhs)\n+\t    && TREE_CODE (TREE_TYPE (lhs)) == INTEGER_TYPE\n+\t    && TYPE_PRECISION (TREE_TYPE (lhs)) == 32\n+\t    && (TREE_CODE (rhs) == PLUS_EXPR || TREE_CODE (rhs) == MINUS_EXPR))\n \t  {\n-\t    if (FIELD_STATIC (lhs))\n+\t    tree arg0 = TREE_OPERAND (rhs, 0);\n+\t    tree arg1 = TREE_OPERAND (rhs, 1);\n+\t    HOST_WIDE_INT min_value = -32768;\n+\t    HOST_WIDE_INT max_value = 32767;\n+\t    if (TREE_CODE (rhs) == MINUS_EXPR)\n \t      {\n-\t\tfield_op (lhs, OPCODE_putstatic);\n+\t\tmin_value++;\n+\t\tmax_value++;\n \t      }\n-\t    else\n+\t    else if (arg1 == lhs)\n \t      {\n-\t\tint index = DECL_LOCAL_INDEX (lhs);\n-\t\tint opcode = adjust_typed_op (TREE_TYPE (lhs));\n-\t\tif (index <= 3)\n-\t\t  {\n-\t\t    RESERVE (1);\n-\t\t    opcode = 59 + 4 * opcode + index;\n-\t\t    OP1 (opcode);  /* [ilfda]store_[0123] */\n-\t\t  }\n-\t\telse\n+\t\targ0 = arg1;\n+\t\targ1 = TREE_OPERAND (rhs, 0);\n+\t      }\n+\t    if (lhs == arg0 && TREE_CODE (arg1) == INTEGER_CST)\n+\t      {\n+\t\tHOST_WIDE_INT hi_value = TREE_INT_CST_HIGH (arg1);\n+\t\tvalue = TREE_INT_CST_LOW (arg1);\n+\t\tif ((hi_value == 0 && value <= max_value)\n+\t\t    || (hi_value == -1 && value >= min_value))\n \t\t  {\n-\t\t    maybe_wide (54 + opcode, index);  /* [ilfda]store */\n+\t\t    if (TREE_CODE (rhs) == MINUS_EXPR)\n+\t\t      value = -value;\n+\t\t    emit_iinc (lhs, value, state);\n+\t\t    break;\n \t\t  }\n \t      }\n \t  }\n+\n+\tif (TREE_CODE (lhs) == COMPONENT_REF)\n+\t  generate_bytecode_insns (TREE_OPERAND (lhs, 0), STACK_TARGET, state);\n \telse if (TREE_CODE (lhs) == ARRAY_REF)\n \t  {\n-\t    jopcode = OPCODE_iastore + adjust_typed_op (TREE_TYPE (lhs));\n-\t    RESERVE(1);\n-\t    OP1 (jopcode);\n+\t    generate_bytecode_insns (TREE_OPERAND(lhs, 0), STACK_TARGET, state);\n+\t    generate_bytecode_insns (TREE_OPERAND(lhs, 1), STACK_TARGET, state);\n \t  }\n-\telse\n-\t  fatal (\"internal error (bad lhs to MODIFY_EXPR)\");\n+\tgenerate_bytecode_insns (rhs, STACK_TARGET, state);\n+\tif (target != IGNORE_TARGET)\n+\t  emit_dup (TYPE_IS_WIDE (type) ? 2 : 1 , 1, state);\n+\texp = lhs;\n       }\n+      /* FALLTHOUGH */\n+\n+    finish_assignment:\n+      if (TREE_CODE (exp) == COMPONENT_REF)\n+\t{\n+\t  tree field = TREE_OPERAND (exp, 1);\n+\t  if (! FIELD_STATIC (field))\n+\t    NOTE_POP (1);\n+\t  field_op (field,\n+\t\t    FIELD_STATIC (field) ? OPCODE_putstatic\n+\t\t    : OPCODE_putfield,\n+\t\t    state);\n+\n+\t  NOTE_PUSH (TYPE_IS_WIDE (TREE_TYPE (field)) ? 2 : 1);\n+\t}\n+      else if (TREE_CODE (exp) == VAR_DECL\n+\t       || TREE_CODE (exp) == PARM_DECL)\n+\t{\n+\t  if (FIELD_STATIC (exp))\n+\t    {\n+\t      field_op (exp, OPCODE_putstatic, state);\n+\t      NOTE_PUSH (TYPE_IS_WIDE (TREE_TYPE (exp)) ? 2 : 1);\n+\t    }\n+\t  else\n+\t    emit_store (exp, state);\n+\t}\n+      else if (TREE_CODE (exp) == ARRAY_REF)\n+\t{\n+\t  NOTE_POP (2);\n+\t  jopcode = OPCODE_iastore + adjust_typed_op (TREE_TYPE (exp));\n+\t  RESERVE(1);\n+\t  OP1 (jopcode);\n+\t  NOTE_PUSH (TYPE_IS_WIDE (TREE_TYPE (exp)) ? 2 : 1);\n+\t}\n+      else\n+\tfatal (\"internal error (bad lhs to MODIFY_EXPR)\");\n       break;\n     case PLUS_EXPR:\n       jopcode = OPCODE_iadd + adjust_typed_op (type);\n@@ -702,25 +1422,24 @@ generate_bytecode_insns (method, exp, target)\n       jopcode = OPCODE_idiv + adjust_typed_op (type);\n       goto binop;\n     binop:\n-      generate_bytecode_insns (method, TREE_OPERAND (exp, 0), target);\n-      generate_bytecode_insns (method, TREE_OPERAND (exp, 1), target);\n+      generate_bytecode_insns (TREE_OPERAND (exp, 0), target, state);\n+      generate_bytecode_insns (TREE_OPERAND (exp, 1), target, state);\n       if (target == STACK_TARGET)\n-\t{\n-\t  RESERVE(1);\n-\t  OP1 (jopcode);\n-\t}\n+\temit_binop (jopcode, type, state);\n       break;\n     case CALL_EXPR:\n       {\n \ttree t;\n+\tint save_SP = state->code_SP;\n \tfor (t = TREE_OPERAND (exp, 1);  t != NULL_TREE;  t = TREE_CHAIN (t))\n \t  {\n-\t    generate_bytecode_insns (method, TREE_VALUE (t), STACK_TARGET);\n+\t    generate_bytecode_insns (TREE_VALUE (t), STACK_TARGET, state);\n \t  }\n \tt = TREE_OPERAND (exp, 0);\n+\tstate->code_SP = save_SP;\n \tif (TREE_CODE (t) == FUNCTION_DECL)\n \t  {\n-\t    int index = find_methodref_index (code_cpool, t);\n+\t    int index = find_methodref_index (&state->cpool, t);\n \t    RESERVE (3);\n \t    if (DECL_CONSTRUCTOR_P (t))\n \t      OP1 (OPCODE_invokespecial);\n@@ -729,59 +1448,232 @@ generate_bytecode_insns (method, exp, target)\n \t    else\n \t      OP1 (OPCODE_invokevirtual);\n \t    OP2 (index);\n+\t    t = TREE_TYPE (TREE_TYPE (t));\n+\t    if (TREE_CODE (t) != VOID_TYPE)\n+\t      {\n+\t\tint size = TYPE_IS_WIDE (t) ? 2 : 1;\n+\t\tif (target == IGNORE_TARGET)\n+\t\t  emit_pop (size, state);\n+\t\telse\n+\t\t  NOTE_PUSH (size);\n+\t      }\n \t    break;\n \t  }\n       }\n       /* fall through */\n+    notimpl:\n     default:\n-      error(\"internal error - tree code not implemented: \", TREE_CODE (exp));\n+      error(\"internal error - tree code not implemented: %s\",\n+\t    tree_code_name [(int) TREE_CODE (exp)]);\n     }\n }\n \n+void\n+perform_relocations (state)\n+     struct jcf_partial *state;\n+{\n+  struct jcf_block *block;\n+  struct jcf_relocation *reloc;\n+  int pc;\n+  int shrink;\n+\n+  /* Figure out the actual locations of each block. */\n+  pc = 0;\n+  shrink = 0;\n+  for (block = state->blocks;  block != NULL;  block = block->next)\n+    {\n+      int block_size = block->chunk->size;\n+\n+      block->pc = pc;\n+\n+      /* Optimize GOTO L; L: by getting rid of the redundant goto.\n+\t Assumes relocations are in reverse order. */\n+      reloc = block->u.relocations;\n+      while (reloc != NULL\n+\t     && reloc->label->pc == block->next->pc\n+\t     && reloc->offset + 2 == block_size\n+\t     && reloc->kind == OPCODE_goto_w)\n+\t{\n+\t  reloc = reloc->next;\n+\t  block->u.relocations = reloc;\n+\t  block->chunk->size -= 3;\n+\t  block_size -= 3;\n+\t  shrink += 3;\n+\t}\n+\n+      for (reloc = block->u.relocations;  reloc != NULL;  reloc = reloc->next)\n+\t{\n+\t  if (reloc->kind < -1 || reloc->kind > 0)\n+\t    {\n+\t      int delta = reloc->label->pc - (pc + reloc->offset - 1);\n+\t      int expand = reloc->kind > 0 ? 2 : 5;\n+\n+\t      if (delta > 0)\n+\t\tdelta -= shrink;\n+\t      if (delta >= -32768 && delta <= 32767)\n+\t\t{\n+\t\t  shrink += expand;\n+\t\t  reloc->kind = -1;\n+\t\t}\n+\t      else\n+\t\tblock_size += expand;\n+\t    }\n+\t}\n+      pc += block_size;\n+    }\n+\n+  for (block = state->blocks;  block != NULL;  block = block->next)\n+    {\n+      struct chunk *chunk = block->chunk;\n+      int old_size = chunk->size;\n+      int next_pc = block->next == NULL ? pc : block->next->pc;\n+      int new_size = next_pc - block->pc;\n+      int offset = 0;\n+      unsigned char *new_ptr;\n+      unsigned char *old_buffer = chunk->data;\n+      unsigned char *old_ptr = old_buffer + old_size;\n+      int new_end = new_size;\n+      if (new_size != old_size)\n+\t{\n+\t  chunk->data = (unsigned char *)\n+\t    obstack_alloc (state->chunk_obstack, new_size);\n+\t}\n+      new_ptr = chunk->data + new_size;\n+\n+      /* We do the relocations from back to front, because\n+\t thre relocations are in reverse order. */\n+      for (reloc = block->u.relocations; ; reloc = reloc->next)\n+\t{\n+\t  /* Lower old index of piece to be copied with no relocation. */\n+\t  int start = reloc == NULL ? 0\n+\t    : reloc->kind == 0 ? reloc->offset + 4\n+\t    : reloc->offset + 2;\n+\t  int32 value;\n+\t  int new_offset;\n+\t  int n = (old_ptr - old_buffer) - start;\n+\t  new_ptr -= n;\n+\t  old_ptr -= n;\n+\t  if (n > 0)\n+\t    bcopy (old_ptr, new_ptr, n);\n+\t  if (old_ptr == old_buffer)\n+\t    break;\n+\n+\t  if (reloc->kind == 0)\n+\t    {\n+\t      old_ptr -= 4;\n+\t      value = GET_u4 (old_ptr);\n+\t    }\n+\t  else\n+\t    {\n+\t      old_ptr -= 2;\n+\t      value = GET_u2 (old_ptr);\n+\t    }\n+\t  new_offset = new_ptr - chunk->data - (reloc->kind == -1 ? 2 : 4);\n+\t  value += reloc->label->pc - (block->pc + new_offset);\n+\t  *--new_ptr = (unsigned char) value;  value >>= 8;\n+\t  *--new_ptr = (unsigned char) value;  value >>= 8;\n+\t  if (reloc->kind != -1)\n+\t    {\n+\t      *--new_ptr = (unsigned char) value;  value >>= 8;\n+\t      *--new_ptr = (unsigned char) value;\n+\t    }\n+\t  if (reloc->kind > 0)\n+\t    {\n+\t      /* Convert: OP TARGET to: OP_w TARGET;  (OP is goto or jsr). */\n+\t      --old_ptr;\n+\t      *--new_ptr = reloc->kind;\n+\t    }\n+\t  else if (reloc->kind < -1)\n+\t    {\n+\t      /* Convert: ifCOND TARGET to: ifNCOND T; goto_w TARGET; T: */\n+\t      --old_ptr;\n+\t      *--new_ptr = OPCODE_goto_w;\n+\t      *--new_ptr = 3;\n+\t      *--new_ptr = 0;\n+\t      *--new_ptr = - reloc->kind;\n+\t    }\n+\t}\n+    }\n+  state->code_length = pc;\n+}\n+\n+void\n+init_jcf_state (state, work)\n+     struct jcf_partial *state;\n+     struct obstack *work;\n+{\n+  state->chunk_obstack = work;\n+  state->first = state->chunk = NULL;\n+  CPOOL_INIT (&state->cpool);\n+  BUFFER_INIT (&state->localvars);\n+  BUFFER_INIT (&state->bytecode);\n+}\n+\n+void\n+init_jcf_method (state, method)\n+     struct jcf_partial *state;\n+     tree method;\n+{\n+  state->current_method = method;\n+  state->blocks = state->last_block = NULL;\n+  state->linenumber_count = 0;\n+  state->first_lvar = state->last_lvar = NULL;\n+  state->lvar_count = 0;\n+  state->labeled_blocks = NULL;\n+  state->code_length = 0;\n+  BUFFER_RESET (&state->bytecode);\n+  BUFFER_RESET (&state->localvars);\n+  state->code_SP = 0;\n+  state->code_SP_max = 0;\n+}\n+\n+void\n+release_jcf_state (state)\n+     struct jcf_partial *state;\n+{\n+  CPOOL_FINISH (&state->cpool);\n+  obstack_free (state->chunk_obstack, state->first);\n+}\n+\n /* Generate and return a list of chunks containing the class CLAS\n    in the .class file representation.  The list can be written to a\n    .class file using write_chunks.  Allocate chunks from obstack WORK. */\n \n-/* Currently does not write any attributes i.e. no code. */\n-\n struct chunk *\n-generate_classfile (clas, work)\n+generate_classfile (clas, state)\n      tree clas;\n-     struct obstack *work;\n+     struct jcf_partial *state;\n {\n-  CPool cpool;\n-  struct chunk head;\n-  struct chunk *chunk;\n   struct chunk *cpool_chunk;\n+  char *source_file;\n   char *ptr;\n   int i;\n   char *fields_count_ptr;\n   int fields_count = 0;\n   char *methods_count_ptr;\n   int methods_count = 0;\n+  static tree SourceFile_node = NULL_TREE;\n   tree part;\n   int total_supers\n     = clas == object_type_node ? 0\n     : TREE_VEC_LENGTH (TYPE_BINFO_BASETYPES (clas));\n-\n-  chunk = alloc_chunk (&head, NULL, 8, work);\n-  ptr = chunk->data;\n+  \n+  ptr = append_chunk (NULL, 8, state);\n   PUT4 (0xCafeBabe);  /* Magic number */\n   PUT2 (3);  /* Minor version */\n   PUT2 (45);  /* Major version */\n   \n-  CPOOL_INIT(&cpool);\n-  cpool_chunk = chunk = alloc_chunk (chunk, NULL, 0, work);\n+  append_chunk (NULL, 0, state);\n+  cpool_chunk = state->chunk;\n \n   /* Next allocate the chunk containing acces_flags through fields_counr. */\n   if (clas == object_type_node)\n     i = 10;\n   else\n     i = 8 + 2 * total_supers;\n-  chunk = alloc_chunk (chunk, NULL, i, work);\n-  ptr = chunk->data;\n+  ptr = append_chunk (NULL, i, state);\n   i = get_access_flags (TYPE_NAME (clas));  PUT2 (i); /* acces_flags */\n-  i = find_class_constant (&cpool, clas);  PUT2 (i);  /* this_class */\n+  i = find_class_constant (&state->cpool, clas);  PUT2 (i);  /* this_class */\n   if (clas == object_type_node)\n     {\n       PUT2(0);  /* super_class */\n@@ -791,12 +1683,13 @@ generate_classfile (clas, work)\n     {\n       tree basetypes = TYPE_BINFO_BASETYPES (clas);\n       tree base = BINFO_TYPE (TREE_VEC_ELT (basetypes, 0));\n-      int j = find_class_constant (&cpool, base);  PUT2 (j);  /* super_class */\n+      int j = find_class_constant (&state->cpool, base);\n+      PUT2 (j);  /* super_class */\n       PUT2 (total_supers - 1);  /* interfaces_count */\n       for (i = 1;  i < total_supers;  i++)\n \t{\n \t  base = BINFO_TYPE (TREE_VEC_ELT (basetypes, i));\n-\t  j = find_class_constant (&cpool, base);\n+\t  j = find_class_constant (&state->cpool, base);\n \t  PUT2 (j);\n \t}\n     }\n@@ -806,132 +1699,152 @@ generate_classfile (clas, work)\n     {\n       if (DECL_NAME (part) == NULL_TREE)\n \tcontinue;\n-      chunk = alloc_chunk (chunk, NULL, 8, work);\n-      ptr = chunk->data;\n+      ptr = append_chunk (NULL, 8, state);\n       i = get_access_flags (part);  PUT2 (i);\n-      i = find_utf8_constant (&cpool, DECL_NAME (part));  PUT2 (i);\n-      i = find_utf8_constant (&cpool, build_java_signature (TREE_TYPE (part)));\n+      i = find_utf8_constant (&state->cpool, DECL_NAME (part));  PUT2 (i);\n+      i = find_utf8_constant (&state->cpool, build_java_signature (TREE_TYPE (part)));\n       PUT2(i);\n       PUT2 (0);  /* attributes_count */\n       /* FIXME - emit ConstantValue attribute when appropriate */\n       fields_count++;\n     }\n   ptr = fields_count_ptr;  PUT2 (fields_count);\n \n-  chunk = alloc_chunk (chunk, NULL, 2, work);\n-  ptr = methods_count_ptr = chunk->data;\n+  ptr = methods_count_ptr = append_chunk (NULL, 2, state);\n   PUT2 (0);\n \n   for (part = TYPE_METHODS (clas);  part;  part = TREE_CHAIN (part))\n     {\n+      struct jcf_block *block;\n       tree body = BLOCK_EXPR_BODY (DECL_FUNCTION_BODY (part));\n-      int linenumber_size;  /* 4 * number of line number entries */\n-      chunk = alloc_chunk (chunk, NULL, 8, work);\n-      ptr = chunk->data;\n+      tree name = DECL_CONSTRUCTOR_P (part) ? init_identifier_node\n+\t: DECL_NAME (part);\n+      tree type = TREE_TYPE (part);\n+      ptr = append_chunk (NULL, 8, state);\n       i = get_access_flags (part);  PUT2 (i);\n-      i = find_utf8_constant (&cpool, DECL_NAME (part));  PUT2 (i);\n-      i = find_utf8_constant (&cpool, build_java_signature (TREE_TYPE (part)));\n+      i = find_utf8_constant (&state->cpool, name);  PUT2 (i);\n+      i = find_utf8_constant (&state->cpool, build_java_signature (type));\n       PUT2 (i);\n       PUT2 (body != NULL_TREE ? 1 : 0);   /* attributes_count */\n       if (body != NULL_TREE)\n \t{\n \t  int code_attributes_count = 0;\n-\t  int linenumber_size;  /* 4 * number of line number entries */\n-\t  int localvartable_size;  /* 10 * number of local variable entries */\n \t  static tree Code_node = NULL_TREE;\n \t  tree t;\n \t  char *attr_len_ptr;\n-\t  int code_length;\n \t  if (Code_node == NULL_TREE)\n \t    Code_node = get_identifier (\"Code\");\n-\t  chunk = alloc_chunk (chunk, NULL, 14, work);\n-\t  ptr = chunk->data;\n-\t  i = find_utf8_constant (&cpool, Code_node);  PUT2 (i);\n+\t  ptr = append_chunk (NULL, 14, state);\n+\t  i = find_utf8_constant (&state->cpool, Code_node);  PUT2 (i);\n \t  attr_len_ptr = ptr;\n-\t  BUFFER_RESET (&bytecode);\n-\t  BUFFER_RESET (&localvartable);\n-\t  BUFFER_RESET (&linenumbers);\n-\t  BUFFER_RESET (&localvars);\n-\t  code_SP = 0;\n-\t  code_SP_max = 0;\n-\t  code_cpool = &cpool;\n+\t  init_jcf_method (state, part);\n+\t  get_jcf_label_here (state);  /* Force a first block. */\n \t  for (t = DECL_ARGUMENTS (part);  t != NULL_TREE;  t = TREE_CHAIN (t))\n-\t    localvar_alloc (t, 0);\n-\t  generate_bytecode_insns (part, body, IGNORE_TARGET);\n-\t  code_length = PC;\t\n+\t    localvar_alloc (t, state);\n+\t  generate_bytecode_insns (body, IGNORE_TARGET, state);\n \t  for (t = DECL_ARGUMENTS (part);  t != NULL_TREE;  t = TREE_CHAIN (t))\n-\t    localvar_free (t, code_length);\n-\t  linenumber_size = BUFFER_LENGTH (&linenumbers);\n-\t  localvartable_size = BUFFER_LENGTH (&localvartable);\n-\t  chunk = alloc_chunk (chunk, NULL, code_length, work);\n-\t  bcopy (bytecode.data, chunk->data, code_length);\n+\t    localvar_free (t, state);\n+\t  finish_jcf_block (state);\n+\t  perform_relocations (state);\n+\n \t  ptr = attr_len_ptr;\n-\t  i = 8 + code_length + 4;\n-\t  if (linenumber_size > 0)\n+\t  i = 8 + state->code_length + 4;\n+\t  if (state->linenumber_count > 0)\n \t    {\n \t      code_attributes_count++;\n-\t      i += 8 + linenumber_size;\n+\t      i += 8 + 4 * state->linenumber_count;\n \t    }\n-\t  if (localvartable_size > 0)\n+\t  if (state->lvar_count > 0)\n \t    {\n \t      code_attributes_count++;\n-\t      i += 8 + localvartable_size;\n+\t      i += 8 + 10 * state->lvar_count;\n \t    }\n \t  PUT4 (i); /* attribute_length */\n-\t  PUT2 (code_SP_max);  /* max_stack */\n+\t  PUT2 (state->code_SP_max);  /* max_stack */\n \t  PUT2 (localvar_max);  /* max_locals */\n-\t  PUT4 (code_length);\n-\t  chunk = alloc_chunk (chunk, NULL, 4, work);\n-\t  ptr = chunk->data;\n+\t  PUT4 (state->code_length);\n+\t  ptr = append_chunk (NULL, 4, state);\n \t  PUT2 (0);  /* exception_table_length */\n \t  PUT2 (code_attributes_count);\n \n \t  /* Write the LineNumberTable attribute. */\n-\t  if (linenumber_size > 0)\n+\t  if (state->linenumber_count > 0)\n \t    {\n \t      static tree LineNumberTable_node = NULL_TREE;\n-\t      chunk = alloc_chunk (chunk, NULL, 8 + linenumber_size, work);\n-\t      ptr = chunk->data;\n+\t      ptr = append_chunk (NULL, 8 + 4 * state->linenumber_count, state);\n \t      if (LineNumberTable_node == NULL_TREE)\n \t\tLineNumberTable_node = get_identifier (\"LineNumberTable\");\n-\t      i = find_utf8_constant (&cpool, LineNumberTable_node);\n+\t      i = find_utf8_constant (&state->cpool, LineNumberTable_node);\n \t      PUT2 (i);  /* attribute_name_index */\n-\t      i = 2 + linenumber_size;  PUT4 (i);  /* attribute_length */\n-\t      i = linenumber_size >> 2;  PUT2 (i);\n-\t      PUTN (linenumbers.data, linenumber_size);\n+\t      i = 2+4*state->linenumber_count;  PUT4(i); /* attribute_length */\n+\t      i = state->linenumber_count;  PUT2 (i);\n+\t      for (block = state->blocks;  block != NULL;  block = block->next)\n+\t\t{\n+\t\t  int line = block->linenumber;\n+\t\t  if (line > 0)\n+\t\t    {\n+\t\t      PUT2 (block->pc);\n+\t\t      PUT2 (line);\n+\t\t    }\n+\t\t}\n \t    }\n \n \t  /* Write the LocalVariableTable attribute. */\n-\t  if (localvartable_size > 0)\n+\t  if (state->lvar_count > 0)\n \t    {\n \t      static tree LocalVariableTable_node = NULL_TREE;\n-\t      chunk = alloc_chunk (chunk, NULL, 8 + localvartable_size, work);\n-\t      ptr = chunk->data;\n+\t      struct localvar_info *lvar = state->first_lvar;\n+\t      ptr = append_chunk (NULL, 8 + 10 * state->lvar_count, state);\n \t      if (LocalVariableTable_node == NULL_TREE)\n \t\tLocalVariableTable_node = get_identifier(\"LocalVariableTable\");\n-\t      i = find_utf8_constant (&cpool, LocalVariableTable_node);\n+\t      i = find_utf8_constant (&state->cpool, LocalVariableTable_node);\n \t      PUT2 (i);  /* attribute_name_index */\n-\t      i = 2 + localvartable_size;  PUT4 (i);  /* attribute_length */\n-\t      i = localvartable_size / 10;  PUT2 (i);\n-\t      PUTN (localvartable.data, localvartable_size);\n+\t      i = 2 + 10 * state->lvar_count;  PUT4 (i); /* attribute_length */\n+\t      i = state->lvar_count;  PUT2 (i);\n+\t      for ( ; lvar != NULL;  lvar = lvar->next)\n+\t\t{\n+\t\t  tree name = DECL_NAME (lvar->decl);\n+\t\t  tree sig = build_java_signature (TREE_TYPE (lvar->decl));\n+\t\t  i = lvar->start_label->pc;  PUT2 (i);\n+\t\t  i = lvar->end_label->pc - i;  PUT2 (i);\n+\t\t  i = find_utf8_constant (&state->cpool, name);  PUT2 (i);\n+\t\t  i = find_utf8_constant (&state->cpool, sig);  PUT2 (i);\n+\t\t  i = DECL_LOCAL_INDEX (lvar->decl);  PUT2 (i);\n+\t\t}\n \t    }\n \t}\n       methods_count++;\n     }\n   ptr = methods_count_ptr;  PUT2 (methods_count);\n \n-  chunk = alloc_chunk (chunk, NULL, 2, work);\n-  ptr = chunk->data;\n-  PUT2 (0);  /* attributes_count */\n+  source_file = DECL_SOURCE_FILE (TYPE_NAME (clas));\n+  for (ptr = source_file;  ;  ptr++)\n+    {\n+      char ch = *ptr;\n+      if (ch == '\\0')\n+\tbreak;\n+      if (ch == '/' || ch == '\\\\')\n+\tsource_file = ptr+1;\n+    }\n+  ptr = append_chunk (NULL, 10, state);\n+  PUT2 (1);  /* attributes_count */\n+\n+  /* generate the SourceFile attribute. */\n+  if (SourceFile_node == NULL_TREE) \n+    SourceFile_node = get_identifier (\"SourceFile\");\n+  i = find_utf8_constant (&state->cpool, SourceFile_node);\n+  PUT2 (i);  /* attribute_name_index */\n+  PUT4 (2);\n+  i = find_utf8_constant (&state->cpool, get_identifier (source_file));\n+  PUT2 (i);\n \n   /* New finally generate the contents of the constant pool chunk. */\n-  i = count_constant_pool_bytes (&cpool);\n-  ptr = obstack_alloc (work, i);\n+  i = count_constant_pool_bytes (&state->cpool);\n+  ptr = obstack_alloc (state->chunk_obstack, i);\n   cpool_chunk->data = ptr;\n   cpool_chunk->size = i;\n-  write_constant_pool (&cpool, ptr, i);\n-  CPOOL_FINISH (&cpool);\n-  return head.next;\n+  write_constant_pool (&state->cpool, ptr, i);\n+  return state->first;\n }\n \n char*\n@@ -951,14 +1864,16 @@ write_classfile (clas)\n      tree clas;\n {\n   struct obstack *work = &temporary_obstack;\n+  struct jcf_partial state[1];\n   char *class_file_name = make_class_file_name (clas);\n   struct chunk *chunks;\n   FILE* stream = fopen (class_file_name, \"wb\");\n   if (stream == NULL)\n     fatal (\"failed to open `%s' for writing\", class_file_name);\n-  chunks = generate_classfile (clas, work);\n+  init_jcf_state (state, work);\n+  chunks = generate_classfile (clas, state);\n   write_chunks (stream, chunks);\n   if (fclose (stream))\n     fatal (\"failed to close after writing `%s'\", class_file_name);\n-  obstack_free (work, chunks);\n+  release_jcf_state (state);\n }"}, {"sha": "21c30c131f1140dbf7a658460cabfae83cec1f21", "filename": "gcc/java/lang.c", "status": "modified", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4de5a1022973b0fffdecfc2931fc6ec0f235784/gcc%2Fjava%2Flang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4de5a1022973b0fffdecfc2931fc6ec0f235784/gcc%2Fjava%2Flang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Flang.c?ref=e4de5a1022973b0fffdecfc2931fc6ec0f235784", "patch": "@@ -32,6 +32,40 @@ The Free Software Foundation is independent of Sun Microsystems, Inc.  */\n #include \"jcf.h\"\n #include \"toplev.h\"\n \n+/* Table indexed by tree code giving a string containing a character\n+   classifying the tree code.  Possibilities are\n+   t, d, s, c, r, <, 1 and 2.  See java/java-tree.def for details.  */\n+\n+#define DEFTREECODE(SYM, NAME, TYPE, LENGTH) TYPE,\n+\n+char java_tree_code_type[] = {\n+  'x',\n+#include \"java-tree.def\"\n+};\n+#undef DEFTREECODE\n+\n+/* Table indexed by tree code giving number of expression\n+   operands beyond the fixed part of the node structure.\n+   Not used for types or decls.  */\n+\n+#define DEFTREECODE(SYM, NAME, TYPE, LENGTH) LENGTH,\n+\n+int java_tree_code_length[] = {\n+  0,\n+#include \"java-tree.def\"\n+};\n+#undef DEFTREECODE\n+\n+/* Names of tree components.\n+   Used for printing out the tree and error messages.  */\n+#define DEFTREECODE(SYM, NAME, TYPE, LEN) NAME,\n+\n+char *java_tree_code_name[] = {\n+  \"@@dummy\",\n+#include \"java-tree.def\"\n+};\n+#undef DEFTREECODE\n+\n int compiling_from_source;\n \n char *language_string = \"GNU Java\";\n@@ -320,6 +354,20 @@ lang_init ()\n   current_jcf = main_jcf;\n \n   flag_exceptions = 1;\n+\n+  /* Append to Gcc tree node definition arrays */\n+\n+  bcopy (java_tree_code_type,\n+\t tree_code_type + (int) LAST_AND_UNUSED_TREE_CODE,\n+\t (int)LAST_JAVA_TREE_CODE - (int)LAST_AND_UNUSED_TREE_CODE);\n+  bcopy ((char *)java_tree_code_length,\n+\t (char *)(tree_code_length + (int) LAST_AND_UNUSED_TREE_CODE),\n+\t (LAST_JAVA_TREE_CODE - \n+\t  (int)LAST_AND_UNUSED_TREE_CODE) * sizeof (int));\n+  bcopy ((char *)java_tree_code_name,\n+\t (char *)(tree_code_name + (int) LAST_AND_UNUSED_TREE_CODE),\n+\t (LAST_JAVA_TREE_CODE - \n+\t  (int)LAST_AND_UNUSED_TREE_CODE) * sizeof (char *));\n }\n \n /* This doesn't do anything on purpose. It's used to satisfy the"}, {"sha": "1e78e328ab88656e01eb6ca2f582ab4ee5f7c614", "filename": "gcc/java/parse.h", "status": "modified", "additions": 60, "deletions": 22, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4de5a1022973b0fffdecfc2931fc6ec0f235784/gcc%2Fjava%2Fparse.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4de5a1022973b0fffdecfc2931fc6ec0f235784/gcc%2Fjava%2Fparse.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.h?ref=e4de5a1022973b0fffdecfc2931fc6ec0f235784", "patch": "@@ -148,22 +148,32 @@ extern tree stabilize_reference PROTO ((tree));\n     EXPR_WFL_EMIT_LINE_NOTE (node) = 1, node : node)\n \n /* Types classification, according to the JLS, section 4.2 */\n-#define JFLOAT_TYPE_P(TYPE)      (TREE_CODE ((TYPE)) == REAL_TYPE)\n-#define JINTEGRAL_TYPE_P(TYPE)   ((TREE_CODE ((TYPE)) == INTEGER_TYPE)\t\\\n-\t\t\t\t  || (TREE_CODE ((TYPE)) == CHAR_TYPE))\n-#define JNUMERIC_TYPE_P(TYPE)    (JFLOAT_TYPE_P ((TYPE)) \t\\\n-\t\t\t\t  || JINTEGRAL_TYPE_P ((TYPE)))\n-#define JPRIMITIVE_TYPE_P(TYPE)  (JNUMERIC_TYPE_P ((TYPE)) \t\t   \\\n-\t\t\t\t  || (TREE_CODE ((TYPE)) == BOOLEAN_TYPE))\n+#define JFLOAT_TYPE_P(TYPE)      (TYPE && TREE_CODE ((TYPE)) == REAL_TYPE)\n+#define JINTEGRAL_TYPE_P(TYPE)   ((TYPE) \t\t\t\t   \\\n+\t\t\t\t  && (TREE_CODE ((TYPE)) == INTEGER_TYPE   \\\n+\t\t\t\t      || TREE_CODE ((TYPE)) == CHAR_TYPE))\n+#define JNUMERIC_TYPE_P(TYPE)    ((TYPE)\t\t\t\t\\\n+\t\t\t\t  && (JFLOAT_TYPE_P ((TYPE))\t\t\\\n+\t\t\t\t      || JINTEGRAL_TYPE_P ((TYPE))))\n+#define JPRIMITIVE_TYPE_P(TYPE)  ((TYPE) \t\t\t\t  \\\n+\t\t\t\t  && (JNUMERIC_TYPE_P ((TYPE))\t\t  \\\n+\t\t\t\t  || TREE_CODE ((TYPE)) == BOOLEAN_TYPE))\n \n /* Not defined in the LRM */\n-#define JSTRING_TYPE_P(TYPE) ((TYPE) == string_type_node ||\t\t\\\n-\t\t\t (TREE_CODE (TYPE) == POINTER_TYPE &&\t\t\\\n-\t\t\t  TREE_TYPE (op1_type) == string_type_node))\n-\n-#define JREFERENCE_TYPE_P(TYPE) (TREE_CODE (TYPE) == RECORD_TYPE ||\t\\\n-\t\t\t\t (TREE_CODE (TYPE) == POINTER_TYPE &&\t\\\n-\t\t\t\t TREE_CODE (TREE_TYPE (TYPE)) == RECORD_TYPE))\n+#define JSTRING_TYPE_P(TYPE) ((TYPE) \t\t\t\t\t   \\\n+\t\t\t      && ((TYPE) == string_type_node ||\t\t   \\\n+\t\t\t\t  (TREE_CODE (TYPE) == POINTER_TYPE &&\t   \\\n+\t\t\t\t   TREE_TYPE (TYPE) == string_type_node)))\n+#define JSTRING_P(NODE) ((NODE)\t\t\t\t\t\t\\\n+\t\t\t && (TREE_CODE (NODE) == STRING_CST\t\t\\\n+\t\t\t     || IS_CRAFTED_STRING_BUFFER_P (NODE)\t\\\n+\t\t\t     || JSTRING_TYPE_P (TREE_TYPE (NODE))))\n+\n+#define JREFERENCE_TYPE_P(TYPE) ((TYPE)\t\t\t\t\t      \\\n+\t\t\t\t && (TREE_CODE (TYPE) == RECORD_TYPE \t      \\\n+\t\t\t\t     ||\t(TREE_CODE (TYPE) == POINTER_TYPE     \\\n+\t\t\t\t\t &&  TREE_CODE (TREE_TYPE (TYPE)) ==  \\\n+\t\t\t\t\t RECORD_TYPE)))\n \n /* Other predicate */\n #define DECL_P(NODE) (NODE && (TREE_CODE (NODE) == PARM_DECL\t\t\\\n@@ -198,12 +208,12 @@ extern tree stabilize_reference PROTO ((tree));\n \n #define ERROR_VARIABLE_NOT_INITIALIZED(WFL, V)\t\t\t\\\n   parse_error_context\t\t\t\t\t\t\\\n-    ((WFL), \"Variable `%s' may not have been initialized\", \t\\\n+    ((WFL), \"Variable `%s' may not have been initialized\",\t\\\n      IDENTIFIER_POINTER (V))\n \n-/* Definition for loop handling. This Java's own definition of a loop\n-   body. See parse.y for documentation. It's valid once you hold a\n-   loop's body (LOOP_EXPR_BODY) */\n+/* Definition for loop handling. This is Java's own definition of a\n+   loop body. See parse.y for documentation. It's valid once you hold\n+   a loop's body (LOOP_EXPR_BODY) */\n \n /* The loop main block is the one hold the condition and the loop body */\n #define LOOP_EXPR_BODY_MAIN_BLOCK(NODE) TREE_OPERAND (NODE, 0)\n@@ -252,7 +262,6 @@ extern tree stabilize_reference PROTO ((tree));\n   }\n #define POP_LOOP() ctxp->current_loop = TREE_CHAIN (ctxp->current_loop)\n \n-\n /* Invocation modes, as returned by invocation_mode (). */\n enum {\n   INVOKE_STATIC,\n@@ -414,6 +423,14 @@ static jdeplist *reverse_jdep_list ();\n #define COMPLETE_CHECK_OP_0(NODE) COMPLETE_CHECK_OP(NODE, 0)\n #define COMPLETE_CHECK_OP_1(NODE) COMPLETE_CHECK_OP(NODE, 1)\n \n+/* Building invocations: append(ARG) and StringBuffer(ARG) */\n+#define BUILD_APPEND(ARG)\t\t\t\t\t\t     \\\n+  build_method_invocation (wfl_append, \t\t\t\t\t     \\\n+\t\t\t   (ARG ? build_tree_list (NULL, (ARG)): NULL_TREE))\n+#define BUILD_STRING_BUFFER(ARG)\t\t\t\t\t      \\\n+  build_new_invocation (wfl_string_buffer, \t\t\t\t      \\\n+\t\t\t(ARG ? build_tree_list (NULL, (ARG)) : NULL_TREE))\n+\n /* Parser context data structure. */\n struct parser_ctxt {\n \n@@ -472,7 +489,8 @@ struct parser_ctxt {\n #ifndef JC1_LITE\n static char *java_accstring_lookup PROTO ((int));\n static void  parse_error PROTO ((char *));\n-static void  redefinition_error PROTO ((char *,tree, tree, tree));\n+static void  classitf_redefinition_error PROTO ((char *,tree, tree, tree));\n+static void  variable_redefinition_error PROTO ((tree, tree, tree, int));\n static void  check_modifiers PROTO ((char *, int, int));\n static tree  create_class PROTO ((int, tree, tree, tree));\n static tree  create_interface PROTO ((int, tree, tree));\n@@ -490,6 +508,7 @@ static tree method_header PROTO ((int, tree, tree, tree));\n static tree method_declarator PROTO ((tree, tree));\n static void parse_error_context VPROTO ((tree cl, char *msg, ...));\n static void parse_warning_context VPROTO ((tree cl, char *msg, ...));\n+static tree parse_jdk1_1_error PROTO ((char *));\n static void complete_class_report_errors PROTO ((jdep *));\n static int process_imports PROTO ((void));\n static void read_import_dir PROTO ((tree));\n@@ -514,7 +533,9 @@ static tree resolve_and_layout PROTO ((tree, tree));\n static tree resolve_no_layout PROTO ((tree, tree));\n static int identical_subpath_p PROTO ((tree, tree));\n static int invocation_mode PROTO ((tree, int));\n-static tree refine_accessible_methods_list PROTO ((int, tree));\n+static tree find_applicable_accessible_methods_list PROTO ((tree, tree, tree));\n+static tree find_most_specific_methods_list PROTO ((tree));\n+static int argument_types_convertible PROTO ((tree, tree));\n static tree patch_invoke PROTO ((tree, tree, tree, tree));\n static tree lookup_method_invoke PROTO ((int, tree, tree, tree, tree));\n static tree register_incomplete_type PROTO ((int, tree, tree, tree));\n@@ -525,10 +546,12 @@ static int  unresolved_type_p PROTO ((tree, tree *));\n static void create_jdep_list PROTO ((struct parser_ctxt *));\n static tree build_expr_block PROTO ((tree, tree));\n static tree enter_block PROTO ((void));\n+static tree enter_a_block PROTO ((tree));\n static tree exit_block PROTO ((void));\n static tree lookup_name_in_blocks PROTO ((tree));\n static void maybe_absorb_scoping_blocks PROTO ((void));\n static tree build_method_invocation PROTO ((tree, tree));\n+static tree build_new_invocation PROTO ((tree, tree));\n static tree build_assignment PROTO ((int, int, tree, tree));\n static tree build_binop PROTO ((enum tree_code, int, tree, tree));\n static tree patch_assignment PROTO ((tree, tree, tree ));\n@@ -539,7 +562,11 @@ static tree patch_unaryop PROTO ((tree, tree));\n static tree build_cast PROTO ((int, tree, tree));\n static tree patch_cast PROTO ((tree, tree, tree));\n static int valid_ref_assignconv_cast_p PROTO ((tree, tree, int));\n-static int can_cast_to_p PROTO ((tree, tree));\n+static int valid_builtin_assignconv_identity_widening_p PROTO ((tree, tree));\n+static int valid_cast_to_p PROTO ((tree, tree));\n+static int valid_method_invocation_conversion_p PROTO ((tree, tree));\n+static tree try_builtin_assignconv PROTO ((tree, tree, tree));\n+static tree try_reference_assignconv PROTO ((tree, tree));\n static tree build_unresolved_array_type PROTO ((tree));\n static tree build_array_ref PROTO ((int, tree, tree));\n static tree patch_array_ref PROTO ((tree, tree, tree));\n@@ -565,6 +592,7 @@ static int class_in_current_package PROTO ((tree));\n static tree build_if_else_statement PROTO ((int, tree, tree, tree));\n static tree patch_if_else_statement PROTO ((tree));\n static tree add_stmt_to_compound PROTO ((tree, tree, tree));\n+static tree add_stmt_to_block PROTO ((tree, tree, tree));\n static tree patch_exit_expr PROTO ((tree));\n static tree build_labeled_block PROTO ((int, tree, tree));\n static tree generate_labeled_block PROTO (());\n@@ -577,6 +605,14 @@ static tree build_loop_body PROTO ((int, tree, int));\n static tree complete_loop_body PROTO ((int, tree, tree, int));\n static tree build_debugable_stmt PROTO ((int, tree));\n static tree complete_for_loop PROTO ((int, tree, tree, tree));\n+static tree patch_switch_statement PROTO ((tree));\n+static tree string_constant_concatenation PROTO ((tree, tree));\n+static tree build_string_concatenation PROTO ((tree, tree));\n+static tree patch_string_cst PROTO ((tree));\n+static tree patch_string PROTO ((tree));\n+static tree build_jump_to_finally PROTO ((tree, tree, tree, tree));\n+static tree build_try_statement PROTO ((int, tree, tree, tree));\n+static tree patch_try_statement PROTO ((tree));\n \n void safe_layout_class PROTO ((tree));\n void java_complete_class PROTO ((void));\n@@ -586,6 +622,8 @@ void java_check_methods PROTO ((void));\n void java_layout_classes PROTO ((void));\n tree java_method_add_stmt PROTO ((tree, tree));\n char *java_get_line_col PROTO ((char *, int, int));\n+void java_expand_switch PROTO ((tree));\n+tree java_get_catch_block PROTO ((tree, int));\n #endif /* JC1_LITE */\n \n /* Always in use, no matter what you compile */"}, {"sha": "d73c52af6a62819f08170f86383ff64ae5f5f830", "filename": "gcc/java/verify.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4de5a1022973b0fffdecfc2931fc6ec0f235784/gcc%2Fjava%2Fverify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4de5a1022973b0fffdecfc2931fc6ec0f235784/gcc%2Fjava%2Fverify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fverify.c?ref=e4de5a1022973b0fffdecfc2931fc6ec0f235784", "patch": "@@ -930,14 +930,14 @@ verify_jvm_instructions (jcf, byte_ops, length)\n \tcase OPCODE_instanceof:\n \t  pop_type (ptr_type_node);\n \t  get_class_constant (current_jcf, IMMEDIATE_u2);\n-\t  push_type (integer_type_node);\n+\t  push_type (int_type_node);\n \t  break;\n \n \tcase OPCODE_tableswitch:\n \t  {\n \t    jint default_val, low, high;\n \n-\t    pop_type (integer_type_node);\n+\t    pop_type (int_type_node);\n \t    while (PC%4)\n \t      {\n \t        if (byte_ops[PC++])\n@@ -959,7 +959,7 @@ verify_jvm_instructions (jcf, byte_ops, length)\n \t  {\n \t    jint npairs, last, not_registered = 1;\n \n-\t    pop_type (integer_type_node);\n+\t    pop_type (int_type_node);\n \t    while (PC%4)\n \t      {\n \t        if (byte_ops[PC++])"}]}