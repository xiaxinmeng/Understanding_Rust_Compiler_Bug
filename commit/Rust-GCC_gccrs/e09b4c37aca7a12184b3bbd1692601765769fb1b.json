{"sha": "e09b4c37aca7a12184b3bbd1692601765769fb1b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTA5YjRjMzdhY2E3YTEyMTg0YjNiYmQxNjkyNjAxNzY1NzY5ZmIxYg==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2016-06-08T13:17:41Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2016-06-08T13:17:41Z"}, "message": "tree-vect-stmts.c (vectorizable_load): Remove restrictions on strided SLP loads and fall back to scalar loads in case...\n\n2016-06-08  Richard Biener  <rguenther@suse.de>\n\n\t* tree-vect-stmts.c (vectorizable_load): Remove restrictions\n\ton strided SLP loads and fall back to scalar loads in case\n\twe can't chunk them.\n\n\t* gcc.dg/vect/slp-43.c: New testcase.\n\nFrom-SVN: r237215", "tree": {"sha": "59061fe2da254d2d451ceb452cf97d5736dd533b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/59061fe2da254d2d451ceb452cf97d5736dd533b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e09b4c37aca7a12184b3bbd1692601765769fb1b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e09b4c37aca7a12184b3bbd1692601765769fb1b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e09b4c37aca7a12184b3bbd1692601765769fb1b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e09b4c37aca7a12184b3bbd1692601765769fb1b/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "72d50660ad57224cefc7ad40b81c994b49a503b6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/72d50660ad57224cefc7ad40b81c994b49a503b6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/72d50660ad57224cefc7ad40b81c994b49a503b6"}], "stats": {"total": 182, "additions": 134, "deletions": 48}, "files": [{"sha": "474b064ff0480bba7d8fb8540135b48729672b8f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e09b4c37aca7a12184b3bbd1692601765769fb1b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e09b4c37aca7a12184b3bbd1692601765769fb1b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e09b4c37aca7a12184b3bbd1692601765769fb1b", "patch": "@@ -1,3 +1,9 @@\n+2016-06-08  Richard Biener  <rguenther@suse.de>\n+\n+\t* tree-vect-stmts.c (vectorizable_load): Remove restrictions\n+\ton strided SLP loads and fall back to scalar loads in case\n+\twe can't chunk them.\n+\n 2016-06-08  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/71452"}, {"sha": "1d80915d65e773d0612d0e98cbbad8496a7bf3e9", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e09b4c37aca7a12184b3bbd1692601765769fb1b/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e09b4c37aca7a12184b3bbd1692601765769fb1b/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=e09b4c37aca7a12184b3bbd1692601765769fb1b", "patch": "@@ -1,3 +1,7 @@\n+2016-06-08  Richard Biener  <rguenther@suse.de>\n+\n+\t* gcc.dg/vect/slp-43.c: New testcase.\n+\n 2016-06-08  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/71452"}, {"sha": "4e8df46c86304664952acc8e2463235f0c4fe161", "filename": "gcc/testsuite/gcc.dg/vect/slp-43.c", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e09b4c37aca7a12184b3bbd1692601765769fb1b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-43.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e09b4c37aca7a12184b3bbd1692601765769fb1b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-43.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-43.c?ref=e09b4c37aca7a12184b3bbd1692601765769fb1b", "patch": "@@ -0,0 +1,78 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target vect_int } */\n+/* { dg-additional-options \"-O3\" } */\n+\n+#include <string.h>\n+#include \"tree-vect.h\"\n+\n+#define FOO(T,N) \\\n+void __attribute__((noinline,noclone)) \\\n+foo_ ## T ## _ ## N (T * __restrict__ in_, T * __restrict__ out_, int s) \\\n+{ \\\n+  T *in = __builtin_assume_aligned (in_, __BIGGEST_ALIGNMENT__); \\\n+  T *out = __builtin_assume_aligned (out_, __BIGGEST_ALIGNMENT__); \\\n+  for (int i = 0; i < 16; i++) \\\n+    { \\\n+      for (int j = 0; j < N; ++j) \\\n+        out[j] = in[j]; \\\n+      in += s*N; \\\n+      out += N; \\\n+    } \\\n+}\n+\n+#define TEST(T,N) \\\n+ do { \\\n+  memset (out, 0, 4096); \\\n+  foo_ ## T ## _ ## N ((T *)in, (T *)out, 1); \\\n+  if (memcmp (in, out, sizeof (T) * 16 * N) != 0) \\\n+    __builtin_abort (); \\\n+  for (int i = sizeof (T) * 16 * N; i < 4096; ++i) \\\n+    if (out[i] != 0) \\\n+      __builtin_abort (); \\\n+ } while (0)\n+\n+FOO(char, 1)\n+FOO(char, 2)\n+FOO(char, 3)\n+FOO(char, 4)\n+FOO(char, 6)\n+FOO(char, 8)\n+FOO(int, 1)\n+FOO(int, 2)\n+FOO(int, 3)\n+FOO(int, 4)\n+FOO(int, 6)\n+FOO(int, 8)\n+FOO(int, 16)\n+\n+char in[4096] __attribute__((aligned(__BIGGEST_ALIGNMENT__)));\n+char out[4096] __attribute__((aligned(__BIGGEST_ALIGNMENT__)));\n+\n+int main()\n+{\n+  check_vect ();\n+\n+  for (int i = 0; i < 4096; ++i)\n+    {\n+      in[i] = i;\n+      __asm__ volatile (\"\" : : : \"memory\");\n+    }\n+\n+  TEST(char, 1);\n+  TEST(char, 2);\n+  TEST(char, 3);\n+  TEST(char, 4);\n+  TEST(char, 6);\n+  TEST(char, 8);\n+  TEST(int, 1);\n+  TEST(int, 2);\n+  TEST(int, 3);\n+  TEST(int, 4);\n+  TEST(int, 6);\n+  TEST(int, 8);\n+  TEST(int, 16);\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 13 \"vect\" } } */"}, {"sha": "bee064ef38e583ebb06fce3bef89e80623205dc2", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 46, "deletions": 48, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e09b4c37aca7a12184b3bbd1692601765769fb1b/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e09b4c37aca7a12184b3bbd1692601765769fb1b/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=e09b4c37aca7a12184b3bbd1692601765769fb1b", "patch": "@@ -6440,17 +6440,7 @@ vectorizable_load (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \t}\n     }\n   else if (STMT_VINFO_STRIDED_P (stmt_info))\n-    {\n-      if (grouped_load\n-\t  && slp\n-\t  && (group_size > nunits\n-\t      || nunits % group_size != 0))\n-\t{\n-\t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t   \"unhandled strided group load\\n\");\n-\t  return false;\n-\t}\n-    }\n+    ;\n   else\n     {\n       negative = tree_int_cst_compare (nested_in_vect_loop\n@@ -6744,16 +6734,29 @@ vectorizable_load (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n       running_off = offvar;\n       alias_off = build_int_cst (reference_alias_ptr_type (DR_REF (first_dr)), 0);\n       int nloads = nunits;\n+      int lnel = 1;\n       tree ltype = TREE_TYPE (vectype);\n       auto_vec<tree> dr_chain;\n       if (slp)\n \t{\n-\t  nloads = nunits / group_size;\n-\t  if (group_size < nunits)\n-\t    ltype = build_vector_type (TREE_TYPE (vectype), group_size);\n-\t  else\n-\t    ltype = vectype;\n-\t  ltype = build_aligned_type (ltype, TYPE_ALIGN (TREE_TYPE (vectype)));\n+\t  if (group_size < nunits\n+\t      && nunits % group_size == 0)\n+\t    {\n+\t      nloads = nunits / group_size;\n+\t      lnel = group_size;\n+\t      ltype = build_vector_type (TREE_TYPE (vectype), group_size);\n+\t      ltype = build_aligned_type (ltype,\n+\t\t\t\t\t  TYPE_ALIGN (TREE_TYPE (vectype)));\n+\t    }\n+\t  else if (group_size >= nunits\n+\t\t   && group_size % nunits == 0)\n+\t    {\n+\t      nloads = 1;\n+\t      lnel = nunits;\n+\t      ltype = vectype;\n+\t      ltype = build_aligned_type (ltype,\n+\t\t\t\t\t  TYPE_ALIGN (TREE_TYPE (vectype)));\n+\t    }\n \t  /* For SLP permutation support we need to load the whole group,\n \t     not only the number of vector stmts the permutation result\n \t     fits in.  */\n@@ -6765,48 +6768,43 @@ vectorizable_load (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \t  else\n \t    ncopies = SLP_TREE_NUMBER_OF_VEC_STMTS (slp_node);\n \t}\n+      int group_el = 0;\n+      unsigned HOST_WIDE_INT\n+\telsz = tree_to_uhwi (TYPE_SIZE_UNIT (TREE_TYPE (vectype)));\n       for (j = 0; j < ncopies; j++)\n \t{\n-\t  tree vec_inv;\n-\n \t  if (nloads > 1)\n+\t    vec_alloc (v, nloads);\n+\t  for (i = 0; i < nloads; i++)\n \t    {\n-\t      vec_alloc (v, nloads);\n-\t      for (i = 0; i < nloads; i++)\n+\t      tree this_off = build_int_cst (TREE_TYPE (alias_off),\n+\t\t\t\t\t     group_el * elsz);\n+\t      new_stmt = gimple_build_assign (make_ssa_name (ltype),\n+\t\t\t\t\t      build2 (MEM_REF, ltype,\n+\t\t\t\t\t\t      running_off, this_off));\n+\t      vect_finish_stmt_generation (stmt, new_stmt, gsi);\n+\t      if (nloads > 1)\n+\t\tCONSTRUCTOR_APPEND_ELT (v, NULL_TREE,\n+\t\t\t\t\tgimple_assign_lhs (new_stmt));\n+\n+\t      group_el += lnel;\n+\t      if (! slp\n+\t\t  || group_el == group_size)\n \t\t{\n-\t\t  tree newref, newoff;\n-\t\t  gimple *incr;\n-\t\t  newref = build2 (MEM_REF, ltype, running_off, alias_off);\n-\n-\t\t  newref = force_gimple_operand_gsi (gsi, newref, true,\n-\t\t\t\t\t\t     NULL_TREE, true,\n-\t\t\t\t\t\t     GSI_SAME_STMT);\n-\t\t  CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, newref);\n-\t\t  newoff = copy_ssa_name (running_off);\n-\t\t  incr = gimple_build_assign (newoff, POINTER_PLUS_EXPR,\n-\t\t\t\t\t      running_off, stride_step);\n+\t\t  tree newoff = copy_ssa_name (running_off);\n+\t\t  gimple *incr = gimple_build_assign (newoff, POINTER_PLUS_EXPR,\n+\t\t\t\t\t\t      running_off, stride_step);\n \t\t  vect_finish_stmt_generation (stmt, incr, gsi);\n \n \t\t  running_off = newoff;\n+\t\t  group_el = 0;\n \t\t}\n-\n-\t      vec_inv = build_constructor (vectype, v);\n-\t      new_temp = vect_init_vector (stmt, vec_inv, vectype, gsi);\n-\t      new_stmt = SSA_NAME_DEF_STMT (new_temp);\n \t    }\n-\t  else\n+\t  if (nloads > 1)\n \t    {\n-\t      new_stmt = gimple_build_assign (make_ssa_name (ltype),\n-\t\t\t\t\t      build2 (MEM_REF, ltype,\n-\t\t\t\t\t\t      running_off, alias_off));\n-\t      vect_finish_stmt_generation (stmt, new_stmt, gsi);\n-\n-\t      tree newoff = copy_ssa_name (running_off);\n-\t      gimple *incr = gimple_build_assign (newoff, POINTER_PLUS_EXPR,\n-\t\t\t\t\t  running_off, stride_step);\n-\t      vect_finish_stmt_generation (stmt, incr, gsi);\n-\n-\t      running_off = newoff;\n+\t      tree vec_inv = build_constructor (vectype, v);\n+\t      new_temp = vect_init_vector (stmt, vec_inv, vectype, gsi);\n+\t      new_stmt = SSA_NAME_DEF_STMT (new_temp);\n \t    }\n \n \t  if (slp)"}]}