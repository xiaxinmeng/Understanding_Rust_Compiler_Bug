{"sha": "91382288079e2b47f7a18252051036e4f76c6ada", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTEzODIyODgwNzllMmI0N2Y3YTE4MjUyMDUxMDM2ZTRmNzZjNmFkYQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2010-06-01T15:43:27Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2010-06-01T15:43:27Z"}, "message": "cgraph.h (tree_function_versioning): Update prototype.\n\n\t* cgraph.h (tree_function_versioning): Update prototype.\n\t(cgraph_function_versioning): Update prototype.\n\t* cgraphunit.c (cgraph_copy_node_for_versioning): Accept bbs_to_copy\n\tbitmap.\n\t(cgraph_function_versioning): Accept new_entry_block and bbs_to_copy. \n\t(cgraph_materialize_clone, save_inline_function_body): Update use of\n\ttree_function_versioning.\n\t* tree-inline.c (copy_bb): Look for previous copied block to link after;\n\tfix debug output.\n\t(copy_cfg_body): Accept new_entry_block and bbs_to_copy.\n\t(copy_body): Likewise.\n\t(expand_call_inline): Update use of copy_body.\n\t(tree_function_versioning): Update use of copy body; accept\n\tblocks_to_copy and new_entry.\n\nFrom-SVN: r160110", "tree": {"sha": "40b6483e885e19cfee06a54fdb8b5bec8bff3a8b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/40b6483e885e19cfee06a54fdb8b5bec8bff3a8b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/91382288079e2b47f7a18252051036e4f76c6ada", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/91382288079e2b47f7a18252051036e4f76c6ada", "html_url": "https://github.com/Rust-GCC/gccrs/commit/91382288079e2b47f7a18252051036e4f76c6ada", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/91382288079e2b47f7a18252051036e4f76c6ada/comments", "author": null, "committer": null, "parents": [{"sha": "6ac9d3a3c3ede0fd799548829eb08341d9c8b784", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6ac9d3a3c3ede0fd799548829eb08341d9c8b784", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6ac9d3a3c3ede0fd799548829eb08341d9c8b784"}], "stats": {"total": 196, "additions": 154, "deletions": 42}, "files": [{"sha": "0ff31f1281b6f341c4b6eec5b4bb37c9623031e9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91382288079e2b47f7a18252051036e4f76c6ada/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91382288079e2b47f7a18252051036e4f76c6ada/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=91382288079e2b47f7a18252051036e4f76c6ada", "patch": "@@ -1,3 +1,20 @@\n+2010-06-01  Jan Hubicka  <jh@suse.cz>\n+\n+\t* cgraph.h (tree_function_versioning): Update prototype.\n+\t(cgraph_function_versioning): Update prototype.\n+\t* cgraphunit.c (cgraph_copy_node_for_versioning): Accept bbs_to_copy\n+\tbitmap.\n+\t(cgraph_function_versioning): Accept new_entry_block and bbs_to_copy. \n+\t(cgraph_materialize_clone, save_inline_function_body): Update use of\n+\ttree_function_versioning.\n+\t* tree-inline.c (copy_bb): Look for previous copied block to link after;\n+\tfix debug output.\n+\t(copy_cfg_body): Accept new_entry_block and bbs_to_copy.\n+\t(copy_body): Likewise.\n+\t(expand_call_inline): Update use of copy_body.\n+\t(tree_function_versioning): Update use of copy body; accept\n+\tblocks_to_copy and new_entry.\n+\n 2010-06-01  Jan Hubicka  <jh@suse.cz>\n \n \t* gegenrtl.c: Remove unnecesary prototypes."}, {"sha": "c82fc181ebef64bab9de49f810c91909371570cf", "filename": "gcc/cgraph.h", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91382288079e2b47f7a18252051036e4f76c6ada/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91382288079e2b47f7a18252051036e4f76c6ada/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=91382288079e2b47f7a18252051036e4f76c6ada", "patch": "@@ -616,8 +616,10 @@ void init_cgraph (void);\n struct cgraph_node *cgraph_function_versioning (struct cgraph_node *,\n \t\t\t\t\t\tVEC(cgraph_edge_p,heap)*,\n \t\t\t\t\t\tVEC(ipa_replace_map_p,gc)*,\n-\t\t\t\t\t\tbitmap, const char *);\n-void tree_function_versioning (tree, tree, VEC (ipa_replace_map_p,gc)*, bool, bitmap);\n+\t\t\t\t\t\tbitmap, bitmap, basic_block,\n+\t\t\t\t\t\tconst char *);\n+void tree_function_versioning (tree, tree, VEC (ipa_replace_map_p,gc)*, bool, bitmap,\n+\t\t\t       bitmap, basic_block);\n struct cgraph_node *save_inline_function_body (struct cgraph_node *);\n void record_references_in_initializer (tree, bool);\n bool cgraph_process_new_functions (void);"}, {"sha": "47686a4212aa6931c3e04dd20256a3e943fceaf2", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 32, "deletions": 17, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91382288079e2b47f7a18252051036e4f76c6ada/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91382288079e2b47f7a18252051036e4f76c6ada/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=91382288079e2b47f7a18252051036e4f76c6ada", "patch": "@@ -2102,13 +2102,18 @@ update_call_expr (struct cgraph_node *new_version)\n    edges which should be redirected to point to\n    NEW_VERSION.  ALL the callees edges of OLD_VERSION\n    are cloned to the new version node.  Return the new\n-   version node.  */\n+   version node. \n+\n+   If non-NULL BLOCK_TO_COPY determine what basic blocks \n+   was copied to prevent duplications of calls that are dead\n+   in the clone.  */\n \n static struct cgraph_node *\n cgraph_copy_node_for_versioning (struct cgraph_node *old_version,\n \t\t\t\t tree new_decl,\n-\t\t\t\t VEC(cgraph_edge_p,heap) *redirect_callers)\n-{\n+\t\t\t\t VEC(cgraph_edge_p,heap) *redirect_callers,\n+\t\t\t\t bitmap bbs_to_copy)\n+ {\n    struct cgraph_node *new_version;\n    struct cgraph_edge *e;\n    unsigned i;\n@@ -2128,15 +2133,19 @@ cgraph_copy_node_for_versioning (struct cgraph_node *old_version,\n    new_version->count = old_version->count;\n \n    for (e = old_version->callees; e; e=e->next_callee)\n-     cgraph_clone_edge (e, new_version, e->call_stmt,\n-\t\t\te->lto_stmt_uid, REG_BR_PROB_BASE,\n-\t\t\tCGRAPH_FREQ_BASE,\n-\t\t\te->loop_nest, true);\n+     if (!bbs_to_copy\n+\t || bitmap_bit_p (bbs_to_copy, gimple_bb (e->call_stmt)->index))\n+       cgraph_clone_edge (e, new_version, e->call_stmt,\n+\t\t\t  e->lto_stmt_uid, REG_BR_PROB_BASE,\n+\t\t\t  CGRAPH_FREQ_BASE,\n+\t\t\t  e->loop_nest, true);\n    for (e = old_version->indirect_calls; e; e=e->next_callee)\n-     cgraph_clone_edge (e, new_version, e->call_stmt,\n-\t\t\te->lto_stmt_uid, REG_BR_PROB_BASE,\n-\t\t\tCGRAPH_FREQ_BASE,\n-\t\t\te->loop_nest, true);\n+     if (!bbs_to_copy\n+\t || bitmap_bit_p (bbs_to_copy, gimple_bb (e->call_stmt)->index))\n+       cgraph_clone_edge (e, new_version, e->call_stmt,\n+\t\t\t  e->lto_stmt_uid, REG_BR_PROB_BASE,\n+\t\t\t  CGRAPH_FREQ_BASE,\n+\t\t\t  e->loop_nest, true);\n    for (i = 0; VEC_iterate (cgraph_edge_p, redirect_callers, i, e); i++)\n      {\n        /* Redirect calls to the old version node to point to its new\n@@ -2159,14 +2168,18 @@ cgraph_copy_node_for_versioning (struct cgraph_node *old_version,\n     new ones (according to results of prior analysis).\n     OLD_VERSION_NODE is the node that is versioned.\n     It returns the new version's cgraph node.\n-    ARGS_TO_SKIP lists arguments to be omitted from functions\n-    */\n+    If non-NULL ARGS_TO_SKIP determine function parameters to remove\n+    from new version.\n+    If non-NULL BLOCK_TO_COPY determine what basic blocks to copy.\n+    If non_NULL NEW_ENTRY determine new entry BB of the clone.  */\n \n struct cgraph_node *\n cgraph_function_versioning (struct cgraph_node *old_version_node,\n \t\t\t    VEC(cgraph_edge_p,heap) *redirect_callers,\n \t\t\t    VEC (ipa_replace_map_p,gc)* tree_map,\n \t\t\t    bitmap args_to_skip,\n+\t\t\t    bitmap bbs_to_copy,\n+\t\t\t    basic_block new_entry_block,\n \t\t\t    const char *clone_name)\n {\n   tree old_decl = old_version_node->decl;\n@@ -2193,10 +2206,11 @@ cgraph_function_versioning (struct cgraph_node *old_version_node,\n      and update the edges of the new node. */\n   new_version_node =\n     cgraph_copy_node_for_versioning (old_version_node, new_decl,\n-\t\t\t\t     redirect_callers);\n+\t\t\t\t     redirect_callers, bbs_to_copy);\n \n   /* Copy the OLD_VERSION_NODE function tree to the new version.  */\n-  tree_function_versioning (old_decl, new_decl, tree_map, false, args_to_skip);\n+  tree_function_versioning (old_decl, new_decl, tree_map, false, args_to_skip,\n+\t\t\t    bbs_to_copy, new_entry_block);\n \n   /* Update the new version's properties.\n      Make The new version visible only within this translation unit.  Make sure\n@@ -2267,7 +2281,8 @@ save_inline_function_body (struct cgraph_node *node)\n       }\n \n   /* Copy the OLD_VERSION_NODE function tree to the new version.  */\n-  tree_function_versioning (node->decl, first_clone->decl, NULL, true, NULL);\n+  tree_function_versioning (node->decl, first_clone->decl, NULL, true, NULL,\n+\t\t\t    NULL, NULL);\n \n   DECL_EXTERNAL (first_clone->decl) = 0;\n   DECL_COMDAT_GROUP (first_clone->decl) = NULL_TREE;\n@@ -2296,7 +2311,7 @@ cgraph_materialize_clone (struct cgraph_node *node)\n   /* Copy the OLD_VERSION_NODE function tree to the new version.  */\n   tree_function_versioning (node->clone_of->decl, node->decl,\n   \t\t\t    node->clone.tree_map, true,\n-\t\t\t    node->clone.args_to_skip);\n+\t\t\t    node->clone.args_to_skip, NULL, NULL);\n   if (cgraph_dump_file)\n     {\n       dump_function_to_file (node->clone_of->decl, cgraph_dump_file, dump_flags);"}, {"sha": "eb71c64910e325c7e46bb27d23d1fe06a71b7d05", "filename": "gcc/testsuite/gcc.dg/lto/noreturn-1_0.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91382288079e2b47f7a18252051036e4f76c6ada/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2Fnoreturn-1_0.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91382288079e2b47f7a18252051036e4f76c6ada/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2Fnoreturn-1_0.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2Fnoreturn-1_0.c?ref=91382288079e2b47f7a18252051036e4f76c6ada", "patch": "@@ -0,0 +1,21 @@\n+void exit (int);\n+__attribute__ ((noreturn))\n+int\n+call_me (void)\n+{\n+  exit (0);\n+}\n+void exit (int);\n+__attribute__ ((noreturn))\n+int\n+call_me (void)\n+{\n+  exit (0);\n+}\n+void exit (int);\n+__attribute__ ((noreturn))\n+int\n+call_me (void)\n+{\n+  exit (0);\n+}"}, {"sha": "8e8b0607cdda0d4d69f289a005fcfd2d364bc8ff", "filename": "gcc/testsuite/gcc.dg/lto/noreturn-1_1.c", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91382288079e2b47f7a18252051036e4f76c6ada/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2Fnoreturn-1_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91382288079e2b47f7a18252051036e4f76c6ada/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2Fnoreturn-1_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2Fnoreturn-1_1.c?ref=91382288079e2b47f7a18252051036e4f76c6ada", "patch": "@@ -0,0 +1,27 @@\n+/* { dg-lto-do run } */\n+/* { dg-lto-options {{-O2 -fwhopr} } } */\n+\n+int call_me (void);\n+int\n+main(void)\n+{\n+ return call_me ();\n+}\n+/* { dg-lto-do run } */\n+/* { dg-lto-options {{-O2 -fwhopr} } } */\n+\n+int call_me (void);\n+int\n+main(void)\n+{\n+ return call_me ();\n+}\n+/* { dg-lto-do run } */\n+/* { dg-lto-options {{-O2 -fwhopr} } } */\n+\n+int call_me (void);\n+int\n+main(void)\n+{\n+ return call_me ();\n+}"}, {"sha": "fce6ae54a6ba98f425e4c9794aa6e771612819b0", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 53, "deletions": 23, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91382288079e2b47f7a18252051036e4f76c6ada/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91382288079e2b47f7a18252051036e4f76c6ada/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=91382288079e2b47f7a18252051036e4f76c6ada", "patch": "@@ -1488,11 +1488,17 @@ copy_bb (copy_body_data *id, basic_block bb, int frequency_scale,\n   basic_block copy_basic_block;\n   tree decl;\n   gcov_type freq;\n+  basic_block prev;\n+\n+  /* Search for previous copied basic block.  */\n+  prev = bb->prev_bb;\n+  while (!prev->aux)\n+    prev = prev->prev_bb;\n \n   /* create_basic_block() will append every new block to\n      basic_block_info automatically.  */\n   copy_basic_block = create_basic_block (NULL, (void *) 0,\n-                                         (basic_block) bb->prev_bb->aux);\n+                                         (basic_block) prev->aux);\n   copy_basic_block->count = bb->count * count_scale / REG_BR_PROB_BASE;\n \n   /* We are going to rebuild frequencies from scratch.  These values\n@@ -1728,7 +1734,7 @@ copy_bb (copy_body_data *id, basic_block bb, int frequency_scale,\n \t\t      = CIF_ORIGINALLY_INDIRECT_CALL;\n \t\t  if (dump_file)\n \t\t    {\n-\t\t      fprintf (dump_file, \"Created new direct edge to %s\",\n+\t\t      fprintf (dump_file, \"Created new direct edge to %s\\n\",\n \t\t\t       cgraph_node_name (dest));\n \t\t    }\n \t\t}\n@@ -2131,7 +2137,8 @@ maybe_move_debug_stmts_to_successors (copy_body_data *id, basic_block new_bb)\n \n static tree\n copy_cfg_body (copy_body_data * id, gcov_type count, int frequency_scale,\n-\t       basic_block entry_block_map, basic_block exit_block_map)\n+\t       basic_block entry_block_map, basic_block exit_block_map,\n+\t       bitmap blocks_to_copy, basic_block new_entry)\n {\n   tree callee_fndecl = id->src_fn;\n   /* Original cfun for the callee, doesn't change.  */\n@@ -2170,32 +2177,46 @@ copy_cfg_body (copy_body_data * id, gcov_type count, int frequency_scale,\n \n   /* Use aux pointers to map the original blocks to copy.  */\n   FOR_EACH_BB_FN (bb, cfun_to_copy)\n-    {\n-      basic_block new_bb = copy_bb (id, bb, frequency_scale, count_scale);\n-      bb->aux = new_bb;\n-      new_bb->aux = bb;\n-    }\n+    if (!blocks_to_copy || bitmap_bit_p (blocks_to_copy, bb->index))\n+      {\n+\tbasic_block new_bb = copy_bb (id, bb, frequency_scale, count_scale);\n+\tbb->aux = new_bb;\n+\tnew_bb->aux = bb;\n+      }\n \n   last = last_basic_block;\n \n   /* Now that we've duplicated the blocks, duplicate their edges.  */\n   FOR_ALL_BB_FN (bb, cfun_to_copy)\n-    need_debug_cleanup |= copy_edges_for_bb (bb, count_scale, exit_block_map);\n+    if (!blocks_to_copy\n+        || (bb->index > 0 && bitmap_bit_p (blocks_to_copy, bb->index)))\n+      need_debug_cleanup |= copy_edges_for_bb (bb, count_scale, exit_block_map);\n \n   if (gimple_in_ssa_p (cfun))\n     FOR_ALL_BB_FN (bb, cfun_to_copy)\n-      copy_phis_for_bb (bb, id);\n+      if (!blocks_to_copy\n+\t  || (bb->index > 0 && bitmap_bit_p (blocks_to_copy, bb->index)))\n+\tcopy_phis_for_bb (bb, id);\n \n-  FOR_ALL_BB_FN (bb, cfun_to_copy)\n+  if (new_entry)\n     {\n-      if (need_debug_cleanup\n-\t  && bb->index != ENTRY_BLOCK\n-\t  && bb->index != EXIT_BLOCK)\n-\tmaybe_move_debug_stmts_to_successors (id, (basic_block) bb->aux);\n-      ((basic_block)bb->aux)->aux = NULL;\n-      bb->aux = NULL;\n+      edge e;\n+      e = make_edge (entry_block_map, (basic_block)new_entry->aux, EDGE_FALLTHRU);\n+      e->probability = REG_BR_PROB_BASE;\n+      e->count = entry_block_map->count;\n     }\n \n+  FOR_ALL_BB_FN (bb, cfun_to_copy)\n+    if (bb->aux)\n+      {\n+\tif (need_debug_cleanup\n+\t    && bb->index != ENTRY_BLOCK\n+\t    && bb->index != EXIT_BLOCK)\n+\t  maybe_move_debug_stmts_to_successors (id, (basic_block) bb->aux);\n+\t((basic_block)bb->aux)->aux = NULL;\n+\tbb->aux = NULL;\n+      }\n+\n   /* Zero out AUX fields of newly created block during EH edge\n      insertion. */\n   for (; last < last_basic_block; last++)\n@@ -2317,14 +2338,16 @@ copy_tree_body (copy_body_data *id)\n \n static tree\n copy_body (copy_body_data *id, gcov_type count, int frequency_scale,\n-\t   basic_block entry_block_map, basic_block exit_block_map)\n+\t   basic_block entry_block_map, basic_block exit_block_map,\n+\t   bitmap blocks_to_copy, basic_block new_entry)\n {\n   tree fndecl = id->src_fn;\n   tree body;\n \n   /* If this body has a CFG, walk CFG and copy.  */\n   gcc_assert (ENTRY_BLOCK_PTR_FOR_FUNCTION (DECL_STRUCT_FUNCTION (fndecl)));\n-  body = copy_cfg_body (id, count, frequency_scale, entry_block_map, exit_block_map);\n+  body = copy_cfg_body (id, count, frequency_scale, entry_block_map, exit_block_map,\n+\t\t        blocks_to_copy, new_entry);\n   copy_debug_stmts (id);\n \n   return body;\n@@ -3924,7 +3947,7 @@ expand_call_inline (basic_block bb, gimple stmt, copy_body_data *id)\n      duplicate our body before altering anything.  */\n   copy_body (id, bb->count,\n   \t     cg_edge->frequency * REG_BR_PROB_BASE / CGRAPH_FREQ_BASE,\n-\t     bb, return_block);\n+\t     bb, return_block, NULL, NULL);\n \n   /* Reset the escaped solution.  */\n   if (cfun->gimple_df)\n@@ -4957,11 +4980,18 @@ update_clone_info (copy_body_data * id)\n    tree with another tree while duplicating the function's\n    body, TREE_MAP represents the mapping between these\n    trees. If UPDATE_CLONES is set, the call_stmt fields\n-   of edges of clones of the function will be updated.  */\n+   of edges of clones of the function will be updated.  \n+\n+   If non-NULL ARGS_TO_SKIP determine function parameters to remove\n+   from new version.\n+   If non-NULL BLOCK_TO_COPY determine what basic blocks to copy.\n+   If non_NULL NEW_ENTRY determine new entry BB of the clone.\n+*/\n void\n tree_function_versioning (tree old_decl, tree new_decl,\n \t\t\t  VEC(ipa_replace_map_p,gc)* tree_map,\n-\t\t\t  bool update_clones, bitmap args_to_skip)\n+\t\t\t  bool update_clones, bitmap args_to_skip,\n+\t\t\t  bitmap blocks_to_copy, basic_block new_entry)\n {\n   struct cgraph_node *old_version_node;\n   struct cgraph_node *new_version_node;\n@@ -5113,7 +5143,7 @@ tree_function_versioning (tree old_decl, tree new_decl,\n \n   /* Copy the Function's body.  */\n   copy_body (&id, old_entry_block->count, REG_BR_PROB_BASE,\n-\t     ENTRY_BLOCK_PTR, EXIT_BLOCK_PTR);\n+\t     ENTRY_BLOCK_PTR, EXIT_BLOCK_PTR, blocks_to_copy, new_entry);\n \n   if (DECL_RESULT (old_decl) != NULL_TREE)\n     {"}]}