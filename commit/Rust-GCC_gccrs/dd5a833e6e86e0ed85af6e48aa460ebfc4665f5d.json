{"sha": "dd5a833e6e86e0ed85af6e48aa460ebfc4665f5d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGQ1YTgzM2U2ZTg2ZTBlZDg1YWY2ZTQ4YWE0NjBlYmZjNDY2NWY1ZA==", "commit": {"author": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "2011-04-10T18:46:45Z"}, "committer": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "2011-04-10T18:46:45Z"}, "message": "Remove doubled up words.\n\nFrom-SVN: r172247", "tree": {"sha": "bf95262adeb1e48387900226345da1050170321b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bf95262adeb1e48387900226345da1050170321b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dd5a833e6e86e0ed85af6e48aa460ebfc4665f5d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dd5a833e6e86e0ed85af6e48aa460ebfc4665f5d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dd5a833e6e86e0ed85af6e48aa460ebfc4665f5d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dd5a833e6e86e0ed85af6e48aa460ebfc4665f5d/comments", "author": null, "committer": null, "parents": [{"sha": "4b9726d48cc7eea7e51b51e00e3720104cd2774f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b9726d48cc7eea7e51b51e00e3720104cd2774f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4b9726d48cc7eea7e51b51e00e3720104cd2774f"}], "stats": {"total": 181, "additions": 93, "deletions": 88}, "files": [{"sha": "f582e7dfb0e391b534fc6215b1200292208a4504", "filename": "gcc/c-family/c-ada-spec.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd5a833e6e86e0ed85af6e48aa460ebfc4665f5d/gcc%2Fc-family%2Fc-ada-spec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd5a833e6e86e0ed85af6e48aa460ebfc4665f5d/gcc%2Fc-family%2Fc-ada-spec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-ada-spec.c?ref=dd5a833e6e86e0ed85af6e48aa460ebfc4665f5d", "patch": "@@ -3233,7 +3233,7 @@ dump_ads (const char *source_file,\n \n   pkg_name = get_ada_package (source_file);\n \n-  /* Construct the the .ads filename and package name.  */\n+  /* Construct the .ads filename and package name.  */\n   ads_name = xstrdup (pkg_name);\n \n   for (s = ads_name; *s; s++)"}, {"sha": "e27bbb2c6be79bbcb8edc5ff470cc6953d2874d6", "filename": "gcc/cfganal.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd5a833e6e86e0ed85af6e48aa460ebfc4665f5d/gcc%2Fcfganal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd5a833e6e86e0ed85af6e48aa460ebfc4665f5d/gcc%2Fcfganal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfganal.c?ref=dd5a833e6e86e0ed85af6e48aa460ebfc4665f5d", "patch": "@@ -650,7 +650,7 @@ connect_infinite_loops_to_exit (void)\n }\n \f\n /* Compute reverse top sort order.  This is computing a post order\n-   numbering of the graph.  If INCLUDE_ENTRY_EXIT is true, then then\n+   numbering of the graph.  If INCLUDE_ENTRY_EXIT is true, then\n    ENTRY_BLOCK and EXIT_BLOCK are included.  If DELETE_UNREACHABLE is\n    true, unreachable blocks are deleted.  */\n "}, {"sha": "15660a7e7f810db13f3d6fdc1c638ac95fbb774a", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd5a833e6e86e0ed85af6e48aa460ebfc4665f5d/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd5a833e6e86e0ed85af6e48aa460ebfc4665f5d/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=dd5a833e6e86e0ed85af6e48aa460ebfc4665f5d", "patch": "@@ -45,9 +45,9 @@ along with GCC; see the file COPYING3.  If not see\n       This function is called once (source level) compilation unit is finalized\n       and it will no longer change.\n \n-      In the the call-graph construction and local function\n-      analysis takes place here.  Bodies of unreachable functions are released\n-      to conserve memory usage.\n+      In the call-graph construction and local function analysis takes\n+      place here.  Bodies of unreachable functions are released to\n+      conserve memory usage.\n \n       The function can be called multiple times when multiple source level\n       compilation units are combined (such as in C frontend)"}, {"sha": "55d5883c983d53f1f3a80bcc59a55c3be61e7edf", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd5a833e6e86e0ed85af6e48aa460ebfc4665f5d/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd5a833e6e86e0ed85af6e48aa460ebfc4665f5d/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=dd5a833e6e86e0ed85af6e48aa460ebfc4665f5d", "patch": "@@ -9505,7 +9505,7 @@ compute_offset_order (int nops, HOST_WIDE_INT *unsorted_offsets, int *order,\n    from that base register.\n    REGS is an array filled in with the destination register numbers.\n    SAVED_ORDER (if nonnull), is an array filled in with an order that maps\n-   insn numbers to to an ascending order of stores.  If CHECK_REGS is true,\n+   insn numbers to an ascending order of stores.  If CHECK_REGS is true,\n    the sequence of registers in REGS matches the loads from ascending memory\n    locations, and the function verifies that the register numbers are\n    themselves ascending.  If CHECK_REGS is false, the register numbers\n@@ -9653,7 +9653,7 @@ load_multiple_sequence (rtx *operands, int nops, int *regs, int *saved_order,\n    array filled in with the source register numbers, REG_RTXS (if nonnull) is\n    likewise filled with the corresponding rtx's.\n    SAVED_ORDER (if nonnull), is an array filled in with an order that maps insn\n-   numbers to to an ascending order of stores.\n+   numbers to an ascending order of stores.\n    If CHECK_REGS is true, the sequence of registers in *REGS matches the stores\n    from ascending memory locations, and the function verifies that the register\n    numbers are themselves ascending.  If CHECK_REGS is false, the register\n@@ -23007,7 +23007,7 @@ arm_emit (int label ATTRIBUTE_UNUSED, const char *pattern, rtx *operands)\n static unsigned arm_insn_count;\n \n /* An emitter that counts emitted instructions but does not actually\n-   emit instruction into the the instruction stream.  */\n+   emit instruction into the instruction stream.  */\n static void\n arm_count (int label,\n \t   const char *pattern ATTRIBUTE_UNUSED,"}, {"sha": "febbbe28aea4dcb58ff0ac0e42875757ad76b8ad", "filename": "gcc/config/arm/arm.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd5a833e6e86e0ed85af6e48aa460ebfc4665f5d/gcc%2Fconfig%2Farm%2Farm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd5a833e6e86e0ed85af6e48aa460ebfc4665f5d/gcc%2Fconfig%2Farm%2Farm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.md?ref=dd5a833e6e86e0ed85af6e48aa460ebfc4665f5d", "patch": "@@ -97,7 +97,7 @@\n                         ; generate correct unwind information.\n   UNSPEC_PIC_OFFSET     ; A symbolic 12-bit OFFSET that has been treated\n                         ; correctly for PIC usage.\n-  UNSPEC_GOTSYM_OFF     ; The offset of the start of the the GOT from a\n+  UNSPEC_GOTSYM_OFF     ; The offset of the start of the GOT from a\n                         ; a given symbolic address.\n   UNSPEC_THUMB1_CASESI  ; A Thumb1 compressed dispatch-table call.\n   UNSPEC_RBIT           ; rbit operation."}, {"sha": "8af8a06531d1b2468ba8ba707e3cf495b7eb4440", "filename": "gcc/config/cris/cris.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd5a833e6e86e0ed85af6e48aa460ebfc4665f5d/gcc%2Fconfig%2Fcris%2Fcris.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd5a833e6e86e0ed85af6e48aa460ebfc4665f5d/gcc%2Fconfig%2Fcris%2Fcris.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Fcris.md?ref=dd5a833e6e86e0ed85af6e48aa460ebfc4665f5d", "patch": "@@ -2509,7 +2509,7 @@\n \n ;; The addi insn as it is normally used.\n \n-;; Make the the ACR alternative taste bad enough to not choose it as a\n+;; Make the ACR alternative taste bad enough to not choose it as a\n ;; preference to avoid spilling problems (unwind-dw2-fde.c at build).\n ;; FIXME: Revisit for new register allocator.\n "}, {"sha": "490d195a44e70f4b962549c4166efa05fecbe03d", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd5a833e6e86e0ed85af6e48aa460ebfc4665f5d/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd5a833e6e86e0ed85af6e48aa460ebfc4665f5d/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=dd5a833e6e86e0ed85af6e48aa460ebfc4665f5d", "patch": "@@ -16249,7 +16249,7 @@ ix86_expand_unary_operator (enum rtx_code code, enum machine_mode mode,\n }\n \n /* Split 32bit/64bit divmod with 8bit unsigned divmod if dividend and\n-   divisor are within the the range [0-255].  */\n+   divisor are within the range [0-255].  */\n \n void\n ix86_split_idivmod (enum machine_mode mode, rtx operands[],\n@@ -16283,7 +16283,7 @@ ix86_split_idivmod (enum machine_mode mode, rtx operands[],\n \n   scratch = gen_reg_rtx (mode);\n \n-  /* Use 8bit unsigned divimod if dividend and divisor are within the\n+  /* Use 8bit unsigned divimod if dividend and divisor are within\n      the range [0-255].  */\n   emit_move_insn (scratch, operands[2]);\n   scratch = expand_simple_binop (mode, IOR, scratch, operands[3],\n@@ -20984,23 +20984,24 @@ smallest_pow2_greater_than (int val)\n   return ret;\n }\n \n-/* Expand string move (memcpy) operation.  Use i386 string operations when\n-   profitable.  expand_setmem contains similar code.  The code depends upon\n-   architecture, block size and alignment, but always has the same\n-   overall structure:\n+/* Expand string move (memcpy) operation.  Use i386 string operations\n+   when profitable.  expand_setmem contains similar code.  The code\n+   depends upon architecture, block size and alignment, but always has\n+   the same overall structure:\n \n    1) Prologue guard: Conditional that jumps up to epilogues for small\n-      blocks that can be handled by epilogue alone.  This is faster but\n-      also needed for correctness, since prologue assume the block is larger\n-      than the desired alignment.\n+      blocks that can be handled by epilogue alone.  This is faster\n+      but also needed for correctness, since prologue assume the block\n+      is larger than the desired alignment.\n \n       Optional dynamic check for size and libcall for large\n       blocks is emitted here too, with -minline-stringops-dynamically.\n \n-   2) Prologue: copy first few bytes in order to get destination aligned\n-      to DESIRED_ALIGN.  It is emitted only when ALIGN is less than\n-      DESIRED_ALIGN and and up to DESIRED_ALIGN - ALIGN bytes can be copied.\n-      We emit either a jump tree on power of two sized blocks, or a byte loop.\n+   2) Prologue: copy first few bytes in order to get destination\n+      aligned to DESIRED_ALIGN.  It is emitted only when ALIGN is less\n+      than DESIRED_ALIGN and up to DESIRED_ALIGN - ALIGN bytes can be\n+      copied.  We emit either a jump tree on power of two sized\n+      blocks, or a byte loop.\n \n    3) Main body: the copying loop itself, copying in SIZE_NEEDED chunks\n       with specified algorithm."}, {"sha": "9a04b7a1b15b9cb73673cf43b8d85e387f2ff385", "filename": "gcc/config/i386/smmintrin.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd5a833e6e86e0ed85af6e48aa460ebfc4665f5d/gcc%2Fconfig%2Fi386%2Fsmmintrin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd5a833e6e86e0ed85af6e48aa460ebfc4665f5d/gcc%2Fconfig%2Fi386%2Fsmmintrin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fsmmintrin.h?ref=dd5a833e6e86e0ed85af6e48aa460ebfc4665f5d", "patch": "@@ -597,7 +597,7 @@ _mm_stream_load_si128 (__m128i *__X)\n #define _SIDD_CMP_EQUAL_EACH\t\t0x08\n #define _SIDD_CMP_EQUAL_ORDERED\t\t0x0c\n \n-/* These macros specify the the polarity.  */\n+/* These macros specify the polarity.  */\n #define _SIDD_POSITIVE_POLARITY\t\t0x00\n #define _SIDD_NEGATIVE_POLARITY\t\t0x10\n #define _SIDD_MASKED_POSITIVE_POLARITY\t0x20"}, {"sha": "b28b0b391656c8ddf589170444a0a2f826c0439a", "filename": "gcc/config/mips/mips-protos.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd5a833e6e86e0ed85af6e48aa460ebfc4665f5d/gcc%2Fconfig%2Fmips%2Fmips-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd5a833e6e86e0ed85af6e48aa460ebfc4665f5d/gcc%2Fconfig%2Fmips%2Fmips-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips-protos.h?ref=dd5a833e6e86e0ed85af6e48aa460ebfc4665f5d", "patch": "@@ -72,7 +72,7 @@ enum mips_symbol_context {\n \n    SYMBOL_GOTOFF_DISP\n        An UNSPEC wrapper around a SYMBOL_GOT_DISP.  It represents the\n-       the offset from _gp of the symbol's GOT entry.\n+       offset from _gp of the symbol's GOT entry.\n \n    SYMBOL_GOTOFF_CALL\n        Like SYMBOL_GOTOFF_DISP, but used when calling a global function."}, {"sha": "f65964b63e8a20af2a2671267dc2ef74afb4d0b6", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd5a833e6e86e0ed85af6e48aa460ebfc4665f5d/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd5a833e6e86e0ed85af6e48aa460ebfc4665f5d/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=dd5a833e6e86e0ed85af6e48aa460ebfc4665f5d", "patch": "@@ -10783,25 +10783,26 @@ mips_cannot_change_mode_class (enum machine_mode from ATTRIBUTE_UNUSED,\n \t\t\t       enum machine_mode to ATTRIBUTE_UNUSED,\n \t\t\t       enum reg_class rclass)\n {\n-  /* There are several problems with changing the modes of values\n-     in floating-point registers:\n+  /* There are several problems with changing the modes of values in\n+     floating-point registers:\n \n      - When a multi-word value is stored in paired floating-point\n-       registers, the first register always holds the low word.\n-       We therefore can't allow FPRs to change between single-word\n-       and multi-word modes on big-endian targets.\n+       registers, the first register always holds the low word.  We\n+       therefore can't allow FPRs to change between single-word and\n+       multi-word modes on big-endian targets.\n \n-     - GCC assumes that each word of a multiword register can be accessed\n-       individually using SUBREGs.  This is not true for floating-point\n-       registers if they are bigger than a word.\n+     - GCC assumes that each word of a multiword register can be\n+       accessed individually using SUBREGs.  This is not true for\n+       floating-point registers if they are bigger than a word.\n \n      - Loading a 32-bit value into a 64-bit floating-point register\n-       will not sign-extend the value, despite what LOAD_EXTEND_OP says.\n-       We can't allow FPRs to change from SImode to to a wider mode on\n-       64-bit targets.\n+       will not sign-extend the value, despite what LOAD_EXTEND_OP\n+       says.  We can't allow FPRs to change from SImode to a wider\n+       mode on 64-bit targets.\n \n-     - If the FPU has already interpreted a value in one format, we must\n-       not ask it to treat the value as having a different format.\n+     - If the FPU has already interpreted a value in one format, we\n+       must not ask it to treat the value as having a different\n+       format.\n \n      We therefore disallow all mode changes involving FPRs.  */\n   return reg_classes_intersect_p (FP_REGS, rclass);"}, {"sha": "caee07758fe1f8dd3e179f719f36759a27f62a0e", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd5a833e6e86e0ed85af6e48aa460ebfc4665f5d/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd5a833e6e86e0ed85af6e48aa460ebfc4665f5d/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=dd5a833e6e86e0ed85af6e48aa460ebfc4665f5d", "patch": "@@ -4012,7 +4012,7 @@ s390_legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED,\n }\n \n /* Try a machine-dependent way of reloading an illegitimate address AD\n-   operand.  If we find one, push the reload and and return the new address.\n+   operand.  If we find one, push the reload and return the new address.\n \n    MODE is the mode of the enclosing MEM.  OPNUM is the operand number\n    and TYPE is the reload type of the current reload.  */"}, {"sha": "78f6f0f4fa3ceb8a24f277828402b0561f0befcf", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd5a833e6e86e0ed85af6e48aa460ebfc4665f5d/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd5a833e6e86e0ed85af6e48aa460ebfc4665f5d/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=dd5a833e6e86e0ed85af6e48aa460ebfc4665f5d", "patch": "@@ -9105,7 +9105,7 @@ sh2a_is_function_vector_call (rtx x)\n   return 0;\n }\n \n-/* Returns the function vector number, if the the attribute\n+/* Returns the function vector number, if the attribute\n    'function_vector' is assigned, otherwise returns zero.  */\n int\n sh2a_get_function_vector_number (rtx x)"}, {"sha": "941194b4b67e1f1c8507adcceb72288db1e75d9a", "filename": "gcc/config/spu/spu.c", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd5a833e6e86e0ed85af6e48aa460ebfc4665f5d/gcc%2Fconfig%2Fspu%2Fspu.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd5a833e6e86e0ed85af6e48aa460ebfc4665f5d/gcc%2Fconfig%2Fspu%2Fspu.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fspu.c?ref=dd5a833e6e86e0ed85af6e48aa460ebfc4665f5d", "patch": "@@ -2662,13 +2662,14 @@ insert_hbrp_for_ilb_runout (rtx first)\n \n /* The SPU might hang when it executes 48 inline instructions after a\n    hinted branch jumps to its hinted target.  The beginning of a\n-   function and the return from a call might have been hinted, and must\n-   be handled as well.  To prevent a hang we insert 2 hbrps.  The first\n-   should be within 6 insns of the branch target.  The second should be\n-   within 22 insns of the branch target.  When determining if hbrps are\n-   necessary, we look for only 32 inline instructions, because up to to\n-   12 nops and 4 hbrps could be inserted.  Similarily, when inserting\n-   new hbrps, we insert them within 4 and 16 insns of the target.  */\n+   function and the return from a call might have been hinted, and\n+   must be handled as well.  To prevent a hang we insert 2 hbrps.  The\n+   first should be within 6 insns of the branch target.  The second\n+   should be within 22 insns of the branch target.  When determining\n+   if hbrps are necessary, we look for only 32 inline instructions,\n+   because up to 12 nops and 4 hbrps could be inserted.  Similarily,\n+   when inserting new hbrps, we insert them within 4 and 16 insns of\n+   the target.  */\n static void\n insert_hbrp (void)\n {\n@@ -4370,7 +4371,7 @@ store_with_one_insn_p (rtx mem)\n     {\n       /* We use the associated declaration to make sure the access is\n          referring to the whole object.\n-         We check both MEM_EXPR and and SYMBOL_REF_DECL.  I'm not sure\n+         We check both MEM_EXPR and SYMBOL_REF_DECL.  I'm not sure\n          if it is necessary.  Will there be cases where one exists, and\n          the other does not?  Will there be cases where both exist, but\n          have different types?  */"}, {"sha": "55ae173a02dd0906a3c91bdc3c9f3f86f8e56403", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd5a833e6e86e0ed85af6e48aa460ebfc4665f5d/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd5a833e6e86e0ed85af6e48aa460ebfc4665f5d/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=dd5a833e6e86e0ed85af6e48aa460ebfc4665f5d", "patch": "@@ -1089,7 +1089,7 @@ warn_extern_redeclared_static (tree newdecl, tree olddecl)\n     return;\n \n   /* If the old declaration was `static', or the new one isn't, then\n-     then everything is OK.  */\n+     everything is OK.  */\n   if (DECL_THIS_STATIC (olddecl) || !DECL_THIS_STATIC (newdecl))\n     return;\n "}, {"sha": "b95dd7f2354ba7b96fdf3cc2291b9e5db2976239", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd5a833e6e86e0ed85af6e48aa460ebfc4665f5d/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd5a833e6e86e0ed85af6e48aa460ebfc4665f5d/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=dd5a833e6e86e0ed85af6e48aa460ebfc4665f5d", "patch": "@@ -4146,10 +4146,10 @@ qualified_lookup_using_namespace (tree name, tree scope,\n   /* Look through namespace aliases.  */\n   scope = ORIGINAL_NAMESPACE (scope);\n \n-  /* Algorithm: Starting with SCOPE, walk through the the set of used\n+  /* Algorithm: Starting with SCOPE, walk through the set of used\n      namespaces.  For each used namespace, look through its inline\n-     namespace set for any bindings and usings.  If no bindings are found,\n-     add any usings seen to the set of used namespaces.  */\n+     namespace set for any bindings and usings.  If no bindings are\n+     found, add any usings seen to the set of used namespaces.  */\n   VEC_safe_push (tree, gc, todo, scope);\n \n   while (VEC_length (tree, todo))"}, {"sha": "89eb525caa9ed0e9f93b748c4f015fb03e9d3e28", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd5a833e6e86e0ed85af6e48aa460ebfc4665f5d/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd5a833e6e86e0ed85af6e48aa460ebfc4665f5d/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=dd5a833e6e86e0ed85af6e48aa460ebfc4665f5d", "patch": "@@ -7708,7 +7708,7 @@ or in GNU ld 2.21 or newer.\n \n This option enables the extraction of object files with GIMPLE bytecode out of\n library archives. This improves the quality of optimization by exposing more\n-code the the link time optimizer.  This information specify what symbols \n+code the link time optimizer.  This information specify what symbols \n can be accessed externally (by non-LTO object or during dynamic linking).\n Resulting code quality improvements on binaries (and shared libraries that do\n use hidden visibility) is similar to @code{-fwhole-program}.  See"}, {"sha": "de0381fcb1bb2ae6a90b49d6bc53a568fb38c840", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd5a833e6e86e0ed85af6e48aa460ebfc4665f5d/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd5a833e6e86e0ed85af6e48aa460ebfc4665f5d/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=dd5a833e6e86e0ed85af6e48aa460ebfc4665f5d", "patch": "@@ -94,7 +94,7 @@ from being defined in the @file{.h} file to being part of the\n Similarly, there is a @code{targetcm} variable for hooks that are\n specific to front ends for C-family languages, documented as ``C\n Target Hook''.  This is declared in @file{c-family/c-target.h}, the\n-the initializer @code{TARGETCM_INITIALIZER} in\n+initializer @code{TARGETCM_INITIALIZER} in\n @file{c-family/c-target-def.h}.  If targets initialize @code{targetcm}\n themselves, they should set @code{target_has_targetcm=yes} in\n @file{config.gcc}; otherwise a default definition is used.\n@@ -2332,7 +2332,7 @@ either a floating point (coprocessor) register or a general register for a\n certain operand, you should define a class @code{FLOAT_OR_GENERAL_REGS}\n which includes both of them.  Otherwise you will get suboptimal code,\n or even internal compiler errors when reload cannot find a register in the\n-the class computed via @code{reg_class_subunion}.\n+class computed via @code{reg_class_subunion}.\n \n You must also specify certain redundant information about the register\n classes: for each class, which classes contain it and which ones are"}, {"sha": "8ae45957663ea9399e0b7778b681ba782cf8d0da", "filename": "gcc/doc/tm.texi.in", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd5a833e6e86e0ed85af6e48aa460ebfc4665f5d/gcc%2Fdoc%2Ftm.texi.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd5a833e6e86e0ed85af6e48aa460ebfc4665f5d/gcc%2Fdoc%2Ftm.texi.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi.in?ref=dd5a833e6e86e0ed85af6e48aa460ebfc4665f5d", "patch": "@@ -94,7 +94,7 @@ from being defined in the @file{.h} file to being part of the\n Similarly, there is a @code{targetcm} variable for hooks that are\n specific to front ends for C-family languages, documented as ``C\n Target Hook''.  This is declared in @file{c-family/c-target.h}, the\n-the initializer @code{TARGETCM_INITIALIZER} in\n+initializer @code{TARGETCM_INITIALIZER} in\n @file{c-family/c-target-def.h}.  If targets initialize @code{targetcm}\n themselves, they should set @code{target_has_targetcm=yes} in\n @file{config.gcc}; otherwise a default definition is used.\n@@ -2322,7 +2322,7 @@ either a floating point (coprocessor) register or a general register for a\n certain operand, you should define a class @code{FLOAT_OR_GENERAL_REGS}\n which includes both of them.  Otherwise you will get suboptimal code,\n or even internal compiler errors when reload cannot find a register in the\n-the class computed via @code{reg_class_subunion}.\n+class computed via @code{reg_class_subunion}.\n \n You must also specify certain redundant information about the register\n classes: for each class, which classes contain it and which ones are"}, {"sha": "b8288a850438f16fb1b70c53bf18b7dac8d8dfa6", "filename": "gcc/fortran/frontend-passes.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd5a833e6e86e0ed85af6e48aa460ebfc4665f5d/gcc%2Ffortran%2Ffrontend-passes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd5a833e6e86e0ed85af6e48aa460ebfc4665f5d/gcc%2Ffortran%2Ffrontend-passes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ffrontend-passes.c?ref=dd5a833e6e86e0ed85af6e48aa460ebfc4665f5d", "patch": "@@ -886,7 +886,7 @@ gfc_expr_walker (gfc_expr **e, walk_expr_fn_t exprfn, void *data)\n \t      break;\n \n \t    /* Fall through to the variable case in order to walk the\n-\t       the reference.  */\n+\t       reference.  */\n \n \t  case EXPR_SUBSTRING:\n \t  case EXPR_VARIABLE:"}, {"sha": "bbd8b2e4697aef560d1900c12bc35f54ad6bf522", "filename": "gcc/fortran/gfortran.texi", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd5a833e6e86e0ed85af6e48aa460ebfc4665f5d/gcc%2Ffortran%2Fgfortran.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd5a833e6e86e0ed85af6e48aa460ebfc4665f5d/gcc%2Ffortran%2Fgfortran.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.texi?ref=dd5a833e6e86e0ed85af6e48aa460ebfc4665f5d", "patch": "@@ -810,7 +810,7 @@ list can be found below.  See also the\n including @code{PASS}, @code{PROCEDURE} and @code{GENERIC}, and\n operators bound to a type.\n \n-@item Abstract interfaces and and type extension with the possibility to\n+@item Abstract interfaces and type extension with the possibility to\n override type-bound procedures or to have deferred binding.\n \n @item Polymorphic entities (``@code{CLASS}'') for derived types -- including"}, {"sha": "ebffb1233a3c2270b4d591ec2fcc69b859712902", "filename": "gcc/fortran/intrinsic.texi", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd5a833e6e86e0ed85af6e48aa460ebfc4665f5d/gcc%2Ffortran%2Fintrinsic.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd5a833e6e86e0ed85af6e48aa460ebfc4665f5d/gcc%2Ffortran%2Fintrinsic.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.texi?ref=dd5a833e6e86e0ed85af6e48aa460ebfc4665f5d", "patch": "@@ -2763,7 +2763,7 @@ the @code{COMPILER_OPTIONS} intrinsic.\n @smallexample\n    use iso_fortran_env\n    print '(4a)', 'This file was compiled by ', &\n-                 compiler_version(), ' using the the options ', &\n+                 compiler_version(), ' using the options ', &\n                  compiler_options()\n    end\n @end smallexample\n@@ -2805,7 +2805,7 @@ It contains the name of the compiler and its version number.\n @smallexample\n    use iso_fortran_env\n    print '(4a)', 'This file was compiled by ', &\n-                 compiler_version(), ' using the the options ', &\n+                 compiler_version(), ' using the options ', &\n                  compiler_options()\n    end\n @end smallexample"}, {"sha": "03a5b58c8a38c7b69f79563397b0174bbee0dcea", "filename": "gcc/fortran/target-memory.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd5a833e6e86e0ed85af6e48aa460ebfc4665f5d/gcc%2Ffortran%2Ftarget-memory.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd5a833e6e86e0ed85af6e48aa460ebfc4665f5d/gcc%2Ffortran%2Ftarget-memory.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftarget-memory.c?ref=dd5a833e6e86e0ed85af6e48aa460ebfc4665f5d", "patch": "@@ -495,7 +495,7 @@ gfc_interpret_derived (unsigned char *buffer, size_t buffer_size, gfc_expr *resu\n       /* The constructor points to the component.  */\n       c->n.component = cmp;\n \n-      /* Calculate the offset, which consists of the the FIELD_OFFSET in\n+      /* Calculate the offset, which consists of the FIELD_OFFSET in\n \t bytes, which appears in multiples of DECL_OFFSET_ALIGN-bit-sized,\n \t and additional bits of FIELD_BIT_OFFSET. The code assumes that all\n \t sizes of the components are multiples of BITS_PER_UNIT,"}, {"sha": "acd6c4a43510093100886b54c7194a8bcf0a7d35", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd5a833e6e86e0ed85af6e48aa460ebfc4665f5d/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd5a833e6e86e0ed85af6e48aa460ebfc4665f5d/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=dd5a833e6e86e0ed85af6e48aa460ebfc4665f5d", "patch": "@@ -1697,7 +1697,7 @@ gfc_get_extern_function_decl (gfc_symbol * sym)\n \n   /* Initialize DECL_EXTERNAL and TREE_PUBLIC before calling decl_attributes;\n      TREE_PUBLIC specifies whether a function is globally addressable (i.e.\n-     the the opposite of declaring a function as static in C).  */\n+     the opposite of declaring a function as static in C).  */\n   DECL_EXTERNAL (fndecl) = 1;\n   TREE_PUBLIC (fndecl) = 1;\n \n@@ -1780,7 +1780,7 @@ build_function_decl (gfc_symbol * sym, bool global)\n \n   /* Initialize DECL_EXTERNAL and TREE_PUBLIC before calling decl_attributes;\n      TREE_PUBLIC specifies whether a function is globally addressable (i.e.\n-     the the opposite of declaring a function as static in C).  */\n+     the opposite of declaring a function as static in C).  */\n   DECL_EXTERNAL (fndecl) = 0;\n \n   if (!current_function_decl"}, {"sha": "dc9168a0957814eb86ce2724c08e43c85f98cca0", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd5a833e6e86e0ed85af6e48aa460ebfc4665f5d/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd5a833e6e86e0ed85af6e48aa460ebfc4665f5d/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=dd5a833e6e86e0ed85af6e48aa460ebfc4665f5d", "patch": "@@ -3600,7 +3600,7 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n   /* If there are alternate return labels, function type should be\n      integer.  Can't modify the type in place though, since it can be shared\n      with other functions.  For dummy arguments, the typing is done to\n-     to this result, even if it has to be repeated for each call.  */\n+     this result, even if it has to be repeated for each call.  */\n   if (has_alternate_specifier\n       && TREE_TYPE (TREE_TYPE (TREE_TYPE (se->expr))) != integer_type_node)\n     {"}, {"sha": "ebc8c23bdbd71608aaf97a6b1bc6cbdbb94db194", "filename": "gcc/fortran/trans-types.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd5a833e6e86e0ed85af6e48aa460ebfc4665f5d/gcc%2Ffortran%2Ftrans-types.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd5a833e6e86e0ed85af6e48aa460ebfc4665f5d/gcc%2Ffortran%2Ftrans-types.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-types.c?ref=dd5a833e6e86e0ed85af6e48aa460ebfc4665f5d", "patch": "@@ -2225,7 +2225,7 @@ gfc_get_derived_type (gfc_symbol * derived)\n     goto copy_derived_types;\n \n   /* If a whole file compilation, the derived types from an earlier\n-     namespace can be used as the the canonical type.  */\n+     namespace can be used as the canonical type.  */\n   if (gfc_option.flag_whole_file\n \t&& derived->backend_decl == NULL\n \t&& !derived->attr.use_assoc"}, {"sha": "20c5d45727c1e4abea1e5c1175cf79a3ed19ed0f", "filename": "gcc/gengtype.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd5a833e6e86e0ed85af6e48aa460ebfc4665f5d/gcc%2Fgengtype.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd5a833e6e86e0ed85af6e48aa460ebfc4665f5d/gcc%2Fgengtype.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype.c?ref=dd5a833e6e86e0ed85af6e48aa460ebfc4665f5d", "patch": "@@ -1952,7 +1952,7 @@ matching_file_name_substitute (const char *filnam, regmatch_t pmatch[10],\n \n /* An output file, suitable for definitions, that can see declarations\n    made in INPF and is linked into every language that uses INPF.\n-   Since the the result is cached inside INPF, that argument cannot be\n+   Since the result is cached inside INPF, that argument cannot be\n    declared constant, but is \"almost\" constant. */\n \n outf_p"}, {"sha": "d70c4fe8b89daa42349f2371bf1b325ab1f5c0dd", "filename": "gcc/genhooks.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd5a833e6e86e0ed85af6e48aa460ebfc4665f5d/gcc%2Fgenhooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd5a833e6e86e0ed85af6e48aa460ebfc4665f5d/gcc%2Fgenhooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenhooks.c?ref=dd5a833e6e86e0ed85af6e48aa460ebfc4665f5d", "patch": "@@ -37,7 +37,7 @@ static struct hook_desc hook_array[] = {\n #undef DEFHOOK\n };\n \n-/* For each @Fcode in the the first paragraph of the documentation string DOC,\n+/* For each @Fcode in the first paragraph of the documentation string DOC,\n    print an @findex directive.  HOOK_NAME is the name of the hook this bit of\n    documentation pertains to.  */\n static void"}, {"sha": "1cc16d4bc51811a31bfc4a6107716e1259c6fde9", "filename": "gcc/gimple.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd5a833e6e86e0ed85af6e48aa460ebfc4665f5d/gcc%2Fgimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd5a833e6e86e0ed85af6e48aa460ebfc4665f5d/gcc%2Fgimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.c?ref=dd5a833e6e86e0ed85af6e48aa460ebfc4665f5d", "patch": "@@ -2314,7 +2314,7 @@ gimple_has_side_effects (const_gimple s)\n /* Return true if the RHS of statement S has side effects.\n    We may use it to determine if it is admissable to replace\n    an assignment or call with a copy of a previously-computed\n-   value.  In such cases, side-effects due the the LHS are\n+   value.  In such cases, side-effects due to the LHS are\n    preserved.  */\n \n bool"}, {"sha": "3b05f1b7471a405eb89c14cef6148528c352ead3", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd5a833e6e86e0ed85af6e48aa460ebfc4665f5d/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd5a833e6e86e0ed85af6e48aa460ebfc4665f5d/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=dd5a833e6e86e0ed85af6e48aa460ebfc4665f5d", "patch": "@@ -852,7 +852,7 @@ dep_cost_1 (dep_t link, dw_t dw)\n   /* A USE insn should never require the value used to be computed.\n      This allows the computation of a function's result and parameter\n      values to overlap the return and call.  We don't care about the\n-     the dependence cost when only decreasing register pressure.  */\n+     dependence cost when only decreasing register pressure.  */\n   if (recog_memoized (used) < 0)\n     {\n       cost = 0;"}, {"sha": "edeffc2533c2955de21cf5cd8ce2f498c55ce42a", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd5a833e6e86e0ed85af6e48aa460ebfc4665f5d/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd5a833e6e86e0ed85af6e48aa460ebfc4665f5d/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=dd5a833e6e86e0ed85af6e48aa460ebfc4665f5d", "patch": "@@ -1515,9 +1515,9 @@ ipa_analyze_params_uses (struct cgraph_node *node,\n   info->uses_analysis_done = 1;\n }\n \n-/* Initialize the array describing properties of of formal parameters of NODE,\n-   analyze their uses and and compute jump functions associated with actual\n-   arguments of calls from within NODE.  */\n+/* Initialize the array describing properties of of formal parameters\n+   of NODE, analyze their uses and compute jump functions associated\n+   with actual arguments of calls from within NODE.  */\n \n void\n ipa_analyze_node (struct cgraph_node *node)"}, {"sha": "01a94420aa8e50ba6d0c2b3d0f45b6b5ce08c2e2", "filename": "gcc/ira-emit.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd5a833e6e86e0ed85af6e48aa460ebfc4665f5d/gcc%2Fira-emit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd5a833e6e86e0ed85af6e48aa460ebfc4665f5d/gcc%2Fira-emit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-emit.c?ref=dd5a833e6e86e0ed85af6e48aa460ebfc4665f5d", "patch": "@@ -229,7 +229,7 @@ free_move_list (move_t head)\n     }\n }\n \n-/* Return TRUE if the the move list LIST1 and LIST2 are equal (two\n+/* Return TRUE if the move list LIST1 and LIST2 are equal (two\n    moves are equal if they involve the same allocnos).  */\n static bool\n eq_move_lists_p (move_t list1, move_t list2)"}, {"sha": "ed7ffe5852ff4393894e0ab57bed6977207d1a83", "filename": "gcc/ira-int.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd5a833e6e86e0ed85af6e48aa460ebfc4665f5d/gcc%2Fira-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd5a833e6e86e0ed85af6e48aa460ebfc4665f5d/gcc%2Fira-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-int.h?ref=dd5a833e6e86e0ed85af6e48aa460ebfc4665f5d", "patch": "@@ -805,7 +805,7 @@ struct target_ira_int {\n   int x_ira_class_subset_p[N_REG_CLASSES][N_REG_CLASSES];\n \n   /* Array of the number of hard registers of given class which are\n-     available for allocation.  The order is defined by the the hard\n+     available for allocation.  The order is defined by the hard\n      register numbers.  */\n   short x_ira_non_ordered_class_hard_regs[N_REG_CLASSES][FIRST_PSEUDO_REGISTER];\n "}, {"sha": "feeddadb50f9329e0168d26726ec270568e13b51", "filename": "gcc/java/jcf-parse.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd5a833e6e86e0ed85af6e48aa460ebfc4665f5d/gcc%2Fjava%2Fjcf-parse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd5a833e6e86e0ed85af6e48aa460ebfc4665f5d/gcc%2Fjava%2Fjcf-parse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-parse.c?ref=dd5a833e6e86e0ed85af6e48aa460ebfc4665f5d", "patch": "@@ -1762,7 +1762,7 @@ java_parse_file (void)\n \t      next = list + count;\n \t      avail = avail - count;\n \t    }\n-\t  /* Subtract to to guarantee space for final '\\0'. */\n+\t  /* Subtract one to guarantee space for final '\\0'. */\n \t  count = fread (next, 1, avail - 1, finput);\n \t  if (count == 0)\n \t    {"}, {"sha": "c6738d27e641cab06ae751ffd7dc527b9dfd850e", "filename": "gcc/lto-streamer.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd5a833e6e86e0ed85af6e48aa460ebfc4665f5d/gcc%2Flto-streamer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd5a833e6e86e0ed85af6e48aa460ebfc4665f5d/gcc%2Flto-streamer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer.c?ref=dd5a833e6e86e0ed85af6e48aa460ebfc4665f5d", "patch": "@@ -529,7 +529,7 @@ lto_record_common_node (tree *nodep, VEC(tree, heap) **common_nodes,\n \n \n /* Generate a vector of common nodes and make sure they are merged\n-   properly according to the the gimple type table.  */\n+   properly according to the gimple type table.  */\n \n static VEC(tree,heap) *\n lto_get_common_nodes (void)"}, {"sha": "45bdb703427b85f93c68e48da73bafcef6393f16", "filename": "gcc/lto/lto.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd5a833e6e86e0ed85af6e48aa460ebfc4665f5d/gcc%2Flto%2Flto.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd5a833e6e86e0ed85af6e48aa460ebfc4665f5d/gcc%2Flto%2Flto.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto.c?ref=dd5a833e6e86e0ed85af6e48aa460ebfc4665f5d", "patch": "@@ -186,9 +186,10 @@ lto_materialize_function (struct cgraph_node *node)\n }\n \n \n-/* Decode the content of memory pointed to by DATA in the the\n-   in decl state object STATE. DATA_IN points to a data_in structure for\n-   decoding. Return the address after the decoded object in the input.  */\n+/* Decode the content of memory pointed to by DATA in the in decl\n+   state object STATE. DATA_IN points to a data_in structure for\n+   decoding. Return the address after the decoded object in the\n+   input.  */\n \n static const uint32_t *\n lto_read_in_decl_state (struct data_in *data_in, const uint32_t *data,"}, {"sha": "d2d4fa181c612aed3ab6261c2eb30650571d308c", "filename": "gcc/matrix-reorg.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd5a833e6e86e0ed85af6e48aa460ebfc4665f5d/gcc%2Fmatrix-reorg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd5a833e6e86e0ed85af6e48aa460ebfc4665f5d/gcc%2Fmatrix-reorg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmatrix-reorg.c?ref=dd5a833e6e86e0ed85af6e48aa460ebfc4665f5d", "patch": "@@ -846,7 +846,7 @@ analyze_matrix_allocation_site (struct matrix_info *mi, gimple stmt,\n }\n \n /* The transposing decision making.\n-   In order to to calculate the profitability of transposing, we collect two\n+   In order to calculate the profitability of transposing, we collect two\n    types of information regarding the accesses:\n    1. profiling information used to express the hotness of an access, that\n    is how often the matrix is accessed by this access site (count of the"}, {"sha": "4ce0159691fe611142b84a2694859b0a604c18b1", "filename": "gcc/objc/objc-next-runtime-abi-02.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd5a833e6e86e0ed85af6e48aa460ebfc4665f5d/gcc%2Fobjc%2Fobjc-next-runtime-abi-02.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd5a833e6e86e0ed85af6e48aa460ebfc4665f5d/gcc%2Fobjc%2Fobjc-next-runtime-abi-02.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-next-runtime-abi-02.c?ref=dd5a833e6e86e0ed85af6e48aa460ebfc4665f5d", "patch": "@@ -2159,7 +2159,7 @@ build_v2_protocol_list_address_table (void)\n     }\n \n     /* TODO: delete the vec.  */\n-    /* TODO: upgrade to the the clang/llvm hidden version.  */\n+    /* TODO: upgrade to the clang/llvm hidden version.  */\n }\n \n /* This routine declares a variable to hold meta data for 'struct"}, {"sha": "f8f2b1a7ce18c91a077776822527695a220746e7", "filename": "gcc/regs.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd5a833e6e86e0ed85af6e48aa460ebfc4665f5d/gcc%2Fregs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd5a833e6e86e0ed85af6e48aa460ebfc4665f5d/gcc%2Fregs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregs.h?ref=dd5a833e6e86e0ed85af6e48aa460ebfc4665f5d", "patch": "@@ -44,7 +44,7 @@ extern int max_regno;\n    regstat_init_n_sets_and_refs from the current values of\n    DF_REG_DEF_COUNT and DF_REG_USE_COUNT.  REG_N_REFS and REG_N_SETS\n    should only be used if a pass need to change these values in some\n-   magical way or or the pass needs to have accurate values for these\n+   magical way or the pass needs to have accurate values for these\n    and is not using incremental df scanning.\n \n    At the end of a pass that uses REG_N_REFS and REG_N_SETS, a call"}, {"sha": "bfd743bffd4fa6852420d4ee186de20a13b43bc3", "filename": "gcc/regstat.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd5a833e6e86e0ed85af6e48aa460ebfc4665f5d/gcc%2Fregstat.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd5a833e6e86e0ed85af6e48aa460ebfc4665f5d/gcc%2Fregstat.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregstat.c?ref=dd5a833e6e86e0ed85af6e48aa460ebfc4665f5d", "patch": "@@ -42,7 +42,7 @@ struct regstat_n_sets_and_refs_t *regstat_n_sets_and_refs;\n    REG_N_SETS and REG_N_REFS.\n    ----------------------------------------------------------------------------*/\n \n-/* If a pass need to change these values in some magical way or or the\n+/* If a pass need to change these values in some magical way or the\n    pass needs to have accurate values for these and is not using\n    incremental df scanning, then it should use REG_N_SETS and\n    REG_N_USES.  If the pass is doing incremental scanning then it"}, {"sha": "be56ded153bdae59a0737fd7bdba76a8a9b411f2", "filename": "gcc/sel-sched.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd5a833e6e86e0ed85af6e48aa460ebfc4665f5d/gcc%2Fsel-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd5a833e6e86e0ed85af6e48aa460ebfc4665f5d/gcc%2Fsel-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsel-sched.c?ref=dd5a833e6e86e0ed85af6e48aa460ebfc4665f5d", "patch": "@@ -2741,7 +2741,7 @@ compute_av_set_at_bb_end (insn_t insn, ilist_t p, int ws)\n         sel_print (\"real successors num: %d\\n\", sinfo->all_succs_n);\n     }\n \n-  /* Add insn to to the tail of current path.  */\n+  /* Add insn to the tail of current path.  */\n   ilist_add (&p, insn);\n \n   FOR_EACH_VEC_ELT (rtx, sinfo->succs_ok, is, succ)"}, {"sha": "93a2c305c8b80318833f236e5d83e05cbb1561dd", "filename": "gcc/targhooks.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd5a833e6e86e0ed85af6e48aa460ebfc4665f5d/gcc%2Ftarghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd5a833e6e86e0ed85af6e48aa460ebfc4665f5d/gcc%2Ftarghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.c?ref=dd5a833e6e86e0ed85af6e48aa460ebfc4665f5d", "patch": "@@ -1189,9 +1189,10 @@ default_target_can_inline_p (tree caller, tree callee)\n   else if (!caller_opts)\n     ret = false;\n \n-  /* If both caller and callee have attributes, assume that if the pointer is\n-     different, the the two functions have different target options since\n-     build_target_option_node uses a hash table for the options.  */\n+  /* If both caller and callee have attributes, assume that if the\n+     pointer is different, the two functions have different target\n+     options since build_target_option_node uses a hash table for the\n+     options.  */\n   else\n     ret = (callee_opts == caller_opts);\n "}]}