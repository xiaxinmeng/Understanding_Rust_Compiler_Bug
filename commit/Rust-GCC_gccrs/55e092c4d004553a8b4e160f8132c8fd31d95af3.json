{"sha": "55e092c4d004553a8b4e160f8132c8fd31d95af3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTVlMDkyYzRkMDA0NTUzYThiNGUxNjBmODEzMmM4ZmQzMWQ5NWFmMw==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2007-04-28T08:20:08Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2007-04-28T08:20:08Z"}, "message": "alpha.c (alpha_output_mi_thunk_osf): Use insn_locators_alloc instead of insn_locators_initialize...\n\n\n\t* config/alpha/alpha.c (alpha_output_mi_thunk_osf): Use\n\tinsn_locators_alloc instead of insn_locators_initialize;\n\tcall reset_block_changes.\n\t* config/sparc/sparc.c (sparc_output_mi_thunk): Likewise.\n\t* config/sh/sh.c (sparc_output_mi_thunk): Likewise.\n\t* config/is64/ia64.c (ia64_output_mi_thunk): Likewise.\n\t* config/rs6000/rs6000.c (rs6000_output_mi_thunk): Likewise.\n\t* config/score/score.c (th_output_mi_thunk): Likewise.\n\t* config/mips/mips.c (mips_output_mi_thunk): Likewise.\n\t* cfglyaout.c (set_curr_insn_source_location, set_curr_insn_block):\n\ttolerate uninitialized locator info.\n\n\tRe-apply:\n\t* function.c (init_function_start): Don't init line number info.\n\t(expand_function_end): Update.\n\t(reset_block_changes, record_block_change, finalize_block_changes,\n\tcheck_block_change, free_block_changes): Kill.\n\t* function.h (reset_block_changes, record_block_change,\n\tfinalize_block_changes, check_block_change, free_block_changes): Remove\n\tprototypes.\n\t(struct function): Remove ib_boundaries_block.\n\t* emit-rtl.c (make_insn_raw, make_jump_insn_raw, make_call_insn_raw):\n\tUse curr_insn_locator to initialize locator.\n\t(emit_line_note): Remove.\n\t* cfgexpand.c (expand_gimple_cond_expr): Update.\n\t(construct_exit_block): Likewise.\n\t(tree_expand_cfg): Initialize/finalize locators.\n\t* expr.c (expand_expr_real): Update.\n\t* cfglayout.c (line_locators_locs, line_locators_lines,\n\tfile_locators_locs, file_locators_files): Remove.\n\t(set_block_levels): Move to cfgexpand.c.\n\t(insn_locators_initialize): Remove.\n\t(pass_insn_locators_initialize): Remove.\n\t(locations_locators_locs, locations_locators_vals): New static vars.\n\t(curr_location, last_location, curr_block, last_block, curr_rtl_loc):\n\tLikewise.\n\t(insn_locators_alloc, insn_locators_finalize,\n\tset_curr_insn_source_location, set_curr_insn_block, curr_insn_locator):\n\tNew functions.\n\t(locator_location): New.\n\t(locator_line, locator_file): Rewrite.\n\t* rtl.h (emit_line_note): Kill.\n\t(insn_locators_alloc, insn_locators_finalize,\n\tset_curr_insn_source_location, set_curr_insn_block, curr_insn_locator):\n\tDeclare.\n\t* tree-inline.c (initialize_cfun): Do not initialize\n\tib_boundaries_block.\n\t* passes.c (pass_insn_locators_initialize): Remove.\n\nFrom-SVN: r124258", "tree": {"sha": "9fd420c1917b17a0fa1e409f993e1a80d266278e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9fd420c1917b17a0fa1e409f993e1a80d266278e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/55e092c4d004553a8b4e160f8132c8fd31d95af3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/55e092c4d004553a8b4e160f8132c8fd31d95af3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/55e092c4d004553a8b4e160f8132c8fd31d95af3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/55e092c4d004553a8b4e160f8132c8fd31d95af3/comments", "author": null, "committer": null, "parents": [{"sha": "3722506a9eed8354b1bc45562f98e2c551d23c28", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3722506a9eed8354b1bc45562f98e2c551d23c28", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3722506a9eed8354b1bc45562f98e2c551d23c28"}], "stats": {"total": 511, "additions": 219, "deletions": 292}, "files": [{"sha": "682195135c53ece36ddda2206e4a43935e6a2f88", "filename": "gcc/ChangeLog", "status": "modified", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55e092c4d004553a8b4e160f8132c8fd31d95af3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55e092c4d004553a8b4e160f8132c8fd31d95af3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=55e092c4d004553a8b4e160f8132c8fd31d95af3", "patch": "@@ -1,3 +1,54 @@\n+2007-04-28  Jan Hubicka  <jh@suse.cz>\n+\n+\t* config/alpha/alpha.c (alpha_output_mi_thunk_osf): Use\n+\tinsn_locators_alloc instead of insn_locators_initialize;\n+\tcall reset_block_changes.\n+\t* config/sparc/sparc.c (sparc_output_mi_thunk): Likewise.\n+\t* config/sh/sh.c (sparc_output_mi_thunk): Likewise.\n+\t* config/is64/ia64.c (ia64_output_mi_thunk): Likewise.\n+\t* config/rs6000/rs6000.c (rs6000_output_mi_thunk): Likewise.\n+\t* config/score/score.c (th_output_mi_thunk): Likewise.\n+\t* config/mips/mips.c (mips_output_mi_thunk): Likewise.\n+\t* cfglyaout.c (set_curr_insn_source_location, set_curr_insn_block):\n+\ttolerate uninitialized locator info.\n+\n+\tRe-apply:\n+\t* function.c (init_function_start): Don't init line number info.\n+\t(expand_function_end): Update.\n+\t(reset_block_changes, record_block_change, finalize_block_changes,\n+\tcheck_block_change, free_block_changes): Kill.\n+\t* function.h (reset_block_changes, record_block_change,\n+\tfinalize_block_changes, check_block_change, free_block_changes): Remove\n+\tprototypes.\n+\t(struct function): Remove ib_boundaries_block.\n+\t* emit-rtl.c (make_insn_raw, make_jump_insn_raw, make_call_insn_raw):\n+\tUse curr_insn_locator to initialize locator.\n+\t(emit_line_note): Remove.\n+\t* cfgexpand.c (expand_gimple_cond_expr): Update.\n+\t(construct_exit_block): Likewise.\n+\t(tree_expand_cfg): Initialize/finalize locators.\n+\t* expr.c (expand_expr_real): Update.\n+\t* cfglayout.c (line_locators_locs, line_locators_lines,\n+\tfile_locators_locs, file_locators_files): Remove.\n+\t(set_block_levels): Move to cfgexpand.c.\n+\t(insn_locators_initialize): Remove.\n+\t(pass_insn_locators_initialize): Remove.\n+\t(locations_locators_locs, locations_locators_vals): New static vars.\n+\t(curr_location, last_location, curr_block, last_block, curr_rtl_loc):\n+\tLikewise.\n+\t(insn_locators_alloc, insn_locators_finalize,\n+\tset_curr_insn_source_location, set_curr_insn_block, curr_insn_locator):\n+\tNew functions.\n+\t(locator_location): New.\n+\t(locator_line, locator_file): Rewrite.\n+\t* rtl.h (emit_line_note): Kill.\n+\t(insn_locators_alloc, insn_locators_finalize,\n+\tset_curr_insn_source_location, set_curr_insn_block, curr_insn_locator):\n+\tDeclare.\n+\t* tree-inline.c (initialize_cfun): Do not initialize\n+\tib_boundaries_block.\n+\t* passes.c (pass_insn_locators_initialize): Remove.\n+\n 2007-04-28  Zdenek Dvorak  <dvorakz@suse.cz>\n \n \t* tree-cfg.c (move_block_to_fn): Release bb from dominance"}, {"sha": "c8d446f12bd9ce5ede98649c69d9b025cf94b96a", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 35, "deletions": 11, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55e092c4d004553a8b4e160f8132c8fd31d95af3/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55e092c4d004553a8b4e160f8132c8fd31d95af3/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=55e092c4d004553a8b4e160f8132c8fd31d95af3", "patch": "@@ -1297,8 +1297,8 @@ expand_gimple_cond_expr (basic_block bb, tree stmt)\n   extract_true_false_edges_from_block (bb, &true_edge, &false_edge);\n   if (EXPR_LOCUS (stmt))\n     {\n-      emit_line_note (*(EXPR_LOCUS (stmt)));\n-      record_block_change (TREE_BLOCK (stmt));\n+      set_curr_insn_source_location (*(EXPR_LOCUS (stmt)));\n+      set_curr_insn_block (TREE_BLOCK (stmt));\n     }\n \n   /* These flags have no purpose in RTL land.  */\n@@ -1313,7 +1313,7 @@ expand_gimple_cond_expr (basic_block bb, tree stmt)\n       add_reg_br_prob_note (last, true_edge->probability);\n       maybe_dump_rtl_for_tree_stmt (stmt, last);\n       if (true_edge->goto_locus)\n-\temit_line_note (*true_edge->goto_locus);\n+  \tset_curr_insn_source_location (*true_edge->goto_locus);\n       false_edge->flags |= EDGE_FALLTHRU;\n       return NULL;\n     }\n@@ -1323,7 +1323,7 @@ expand_gimple_cond_expr (basic_block bb, tree stmt)\n       add_reg_br_prob_note (last, false_edge->probability);\n       maybe_dump_rtl_for_tree_stmt (stmt, last);\n       if (false_edge->goto_locus)\n-\temit_line_note (*false_edge->goto_locus);\n+  \tset_curr_insn_source_location (*false_edge->goto_locus);\n       true_edge->flags |= EDGE_FALLTHRU;\n       return NULL;\n     }\n@@ -1354,7 +1354,7 @@ expand_gimple_cond_expr (basic_block bb, tree stmt)\n   maybe_dump_rtl_for_tree_stmt (stmt, last2);\n \n   if (false_edge->goto_locus)\n-    emit_line_note (*false_edge->goto_locus);\n+    set_curr_insn_source_location (*false_edge->goto_locus);\n \n   return new_bb;\n }\n@@ -1608,7 +1608,7 @@ expand_gimple_basic_block (basic_block bb)\n     {\n       emit_jump (label_rtx_for_bb (e->dest));\n       if (e->goto_locus)\n-\temit_line_note (*e->goto_locus);\n+        set_curr_insn_source_location (*e->goto_locus);\n       e->flags &= ~EDGE_FALLTHRU;\n     }\n \n@@ -1679,6 +1679,19 @@ construct_init_block (void)\n   return init_block;\n }\n \n+/* For each lexical block, set BLOCK_NUMBER to the depth at which it is\n+   found in the block tree.  */\n+\n+static void\n+set_block_levels (tree block, int level)\n+{\n+  while (block)\n+    {\n+      BLOCK_NUMBER (block) = level;\n+      set_block_levels (BLOCK_SUBBLOCKS (block), level + 1);\n+      block = BLOCK_CHAIN (block);\n+    }\n+}\n \n /* Create a block containing landing pads and similar stuff.  */\n \n@@ -1703,7 +1716,7 @@ construct_exit_block (void)\n     input_location = cfun->function_end_locus;\n \n   /* The following insns belong to the top scope.  */\n-  record_block_change (DECL_INITIAL (current_function_decl));\n+  set_curr_insn_block (DECL_INITIAL (current_function_decl));\n \n   /* Generate rtl for function exit.  */\n   expand_function_end ();\n@@ -1831,8 +1844,16 @@ tree_expand_cfg (void)\n   /* Some backends want to know that we are expanding to RTL.  */\n   currently_expanding_to_rtl = 1;\n \n-  /* Prepare the rtl middle end to start recording block changes.  */\n-  reset_block_changes ();\n+  insn_locators_alloc ();\n+  if (!DECL_BUILT_IN (current_function_decl))\n+    set_curr_insn_source_location (DECL_SOURCE_LOCATION (current_function_decl));\n+  set_curr_insn_block (DECL_INITIAL (current_function_decl));\n+  prologue_locator = curr_insn_locator ();\n+\n+  /* Make sure first insn is a note even if we don't want linenums.\n+     This makes sure the first insn will never be deleted.\n+     Also, final expects a note to appear there.  */\n+  emit_note (NOTE_INSN_DELETED);\n \n   /* Mark arrays indexed with non-constant indices with TREE_ADDRESSABLE.  */\n   discover_nonconstant_array_refs ();\n@@ -1879,6 +1900,8 @@ tree_expand_cfg (void)\n     bb = expand_gimple_basic_block (bb);\n \n   construct_exit_block ();\n+  set_curr_insn_block (DECL_INITIAL (current_function_decl));\n+  insn_locators_finalize ();\n \n   /* We're done expanding trees to RTL.  */\n   currently_expanding_to_rtl = 0;\n@@ -1909,8 +1932,6 @@ tree_expand_cfg (void)\n      more CONCATs anywhere.  */\n   generating_concat_p = 0;\n \n-  finalize_block_changes ();\n-\n   if (dump_file)\n     {\n       fprintf (dump_file,\n@@ -1941,6 +1962,9 @@ tree_expand_cfg (void)\n   return_label = NULL;\n   naked_return_label = NULL;\n   free_histograms ();\n+  /* Tag the blocks with a depth number so that change_scope can find\n+     the common parent easily.  */\n+  set_block_levels (DECL_INITIAL (cfun->decl), 0);\n   return 0;\n }\n "}, {"sha": "b40695fa306d9e39baf3d08fd1d7e2690cdd4f6c", "filename": "gcc/cfglayout.c", "status": "modified", "additions": 113, "deletions": 142, "changes": 255, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55e092c4d004553a8b4e160f8132c8fd31d95af3/gcc%2Fcfglayout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55e092c4d004553a8b4e160f8132c8fd31d95af3/gcc%2Fcfglayout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfglayout.c?ref=55e092c4d004553a8b4e160f8132c8fd31d95af3", "patch": "@@ -48,7 +48,6 @@ static void record_effective_endpoints (void);\n static rtx label_for_bb (basic_block);\n static void fixup_reorder_chain (void);\n \n-static void set_block_levels (tree, int);\n static void change_scope (rtx, tree, tree);\n \n void verify_insn_chain (void);\n@@ -232,120 +231,111 @@ record_effective_endpoints (void)\n    than the following one.  Similarly for the other properties.  */\n static VEC(int,heap) *block_locators_locs;\n static GTY(()) VEC(tree,gc) *block_locators_blocks;\n-static VEC(int,heap) *line_locators_locs;\n-static VEC(int,heap) *line_locators_lines;\n-static VEC(int,heap) *file_locators_locs;\n-static GTY(()) varray_type file_locators_files;\n+static VEC(int,heap) *locations_locators_locs;\n+DEF_VEC_O(location_t);\n+DEF_VEC_ALLOC_O(location_t,heap);\n+static VEC(location_t,heap) *locations_locators_vals;\n int prologue_locator;\n int epilogue_locator;\n \n-/* During the RTL expansion the lexical blocks and line numbers are\n-   represented via INSN_NOTEs.  Replace them by representation using\n-   INSN_LOCATORs.  */\n+/* Hold current location information and last location information, so the\n+   datastructures are built lazilly only when some instructions in given\n+   place are needed.  */\n+location_t curr_location, last_location;\n+static tree curr_block, last_block;\n+static int curr_rtl_loc = -1;\n \n-unsigned int\n-insn_locators_initialize (void)\n+/* Allocate insn locator datastructure.  */\n+void\n+insn_locators_alloc (void)\n {\n-  tree block = NULL;\n-  tree last_block = NULL;\n-  rtx insn, next;\n-  int loc = 0;\n-  int line_number = 0, last_line_number = 0;\n-  const char *file_name = NULL, *last_file_name = NULL;\n-\n   prologue_locator = epilogue_locator = 0;\n \n   block_locators_locs = VEC_alloc (int, heap, 32);\n   block_locators_blocks = VEC_alloc (tree, gc, 32);\n-  line_locators_locs = VEC_alloc (int, heap, 32);\n-  line_locators_lines = VEC_alloc (int, heap, 32);\n-  file_locators_locs = VEC_alloc (int, heap, 32);\n-  VARRAY_CHAR_PTR_INIT (file_locators_files, 32, \"file_locators_files\");\n-\n-  for (insn = get_insns (); insn; insn = next)\n-    {\n-      int active = 0;\n-\n-      next = NEXT_INSN (insn);\n-\n-      if (NOTE_P (insn))\n-\t{\n-\t  gcc_assert (NOTE_LINE_NUMBER (insn) != NOTE_INSN_BLOCK_BEG\n-\t\t      && NOTE_LINE_NUMBER (insn) != NOTE_INSN_BLOCK_END);\n-\t  if (NOTE_LINE_NUMBER (insn) > 0)\n-\t    {\n-\t      expanded_location xloc;\n-\t      NOTE_EXPANDED_LOCATION (xloc, insn);\n-\t      line_number = xloc.line;\n-\t      file_name = xloc.file;\n-\t      delete_insn (insn);\n-\t    }\n-\t}\n-      else\n-\tactive = (active_insn_p (insn)\n-\t\t  && GET_CODE (PATTERN (insn)) != ADDR_VEC\n-\t\t  && GET_CODE (PATTERN (insn)) != ADDR_DIFF_VEC);\n-\n-      check_block_change (insn, &block);\n+  locations_locators_locs = VEC_alloc (int, heap, 32);\n+  locations_locators_vals = VEC_alloc (location_t, heap, 32);\n+\n+#ifdef USE_MAPPED_LOCATION\n+  last_location = -1;\n+  curr_location = -1;\n+#else\n+  last_location.line = -1;\n+  curr_location.line = -1;\n+#endif\n+  curr_block = NULL;\n+  last_block = NULL;\n+  curr_rtl_loc = 0;\n+}\n \n-      if (active\n-\t  || !next\n-\t  || (!prologue_locator && file_name))\n-\t{\n-\t  if (last_block != block)\n-\t    {\n-\t      loc++;\n-\t      VEC_safe_push (int, heap, block_locators_locs, loc);\n-\t      VEC_safe_push (tree, gc, block_locators_blocks, block);\n-\t      last_block = block;\n-\t    }\n-\t  if (last_line_number != line_number)\n-\t    {\n-\t      loc++;\n-\t      VEC_safe_push (int, heap, line_locators_locs, loc);\n-\t      VEC_safe_push (int, heap, line_locators_lines, line_number);\n-\t      last_line_number = line_number;\n-\t    }\n-\t  if (last_file_name != file_name)\n-\t    {\n-\t      loc++;\n-\t      VEC_safe_push (int, heap, file_locators_locs, loc);\n-\t      VARRAY_PUSH_CHAR_PTR (file_locators_files, (char *) file_name);\n-\t      last_file_name = file_name;\n-\t    }\n-\t  if (!prologue_locator && file_name)\n-\t    prologue_locator = loc;\n-\t  if (!next)\n-\t    epilogue_locator = loc;\n-\t  if (active)\n-\t    INSN_LOCATOR (insn) = loc;\n-\t}\n-    }\n+/* At the end of emit stage, clear current location.  */\n+void\n+insn_locators_finalize (void)\n+{\n+  if (curr_rtl_loc >= 0)\n+    epilogue_locator = curr_insn_locator ();\n+  curr_rtl_loc = -1;\n+}\n \n-  /* Tag the blocks with a depth number so that change_scope can find\n-     the common parent easily.  */\n-  set_block_levels (DECL_INITIAL (cfun->decl), 0);\n+/* Set current location.  */\n+void\n+set_curr_insn_source_location (location_t location)\n+{\n+  /* IV opts calls into RTL expansion to compute costs of operations.  At this\n+     time locators are not initialized.  */\n+  if (curr_rtl_loc == -1)\n+    return;\n+#ifdef USE_MAPPED_LOCATION\n+  if (location == last_location)\n+    return;\n+#else\n+  if (location.file && last_location.file\n+      && !strcmp (location.file, last_location.file)\n+      && location.line == last_location.line)\n+    return;\n+#endif\n+  curr_location = location;\n+}\n \n-  free_block_changes ();\n-  return 0;\n+/* Set current scope block. */\n+void\n+set_curr_insn_block (tree b)\n+{\n+  /* IV opts calls into RTL expansion to compute costs of operations.  At this\n+     time locators are not initialized.  */\n+  if (curr_rtl_loc == -1)\n+    return;\n+  if (b)\n+    curr_block = b;\n }\n \n-struct tree_opt_pass pass_insn_locators_initialize =\n+/* Return current insn locator.  */\n+int\n+curr_insn_locator (void)\n {\n-  \"locators\",                           /* name */\n-  NULL,                                 /* gate */\n-  insn_locators_initialize,             /* execute */\n-  NULL,                                 /* sub */\n-  NULL,                                 /* next */\n-  0,                                    /* static_pass_number */\n-  0,                                    /* tv_id */\n-  0,                                    /* properties_required */\n-  0,                                    /* properties_provided */\n-  0,                                    /* properties_destroyed */\n-  0,                                    /* todo_flags_start */\n-  TODO_dump_func,                       /* todo_flags_finish */\n-  0                                     /* letter */\n-};\n+  if (curr_rtl_loc == -1)\n+    return 0;\n+  if (last_block != curr_block)\n+    {\n+      curr_rtl_loc++;\n+      VEC_safe_push (int, heap, block_locators_locs, curr_rtl_loc);\n+      VEC_safe_push (tree, gc, block_locators_blocks, curr_block);\n+      last_block = curr_block;\n+    }\n+#ifdef USE_MAPPED_LOCATION\n+  if (last_location != curr_location)\n+#else\n+  if (last_location.file != curr_location.file\n+      || last_location.line != curr_location.line)\n+#endif\n+    {\n+      curr_rtl_loc++;\n+      VEC_safe_push (int, heap, locations_locators_locs, curr_rtl_loc);\n+      VEC_safe_push (location_t, heap, locations_locators_vals, &curr_location);\n+      last_location = curr_location;\n+    }\n+  return curr_rtl_loc;\n+}\n \n static unsigned int\n into_cfg_layout_mode (void)\n@@ -401,20 +391,6 @@ struct tree_opt_pass pass_outof_cfg_layout_mode =\n   TODO_dump_func,                       /* todo_flags_finish */\n   0                                     /* letter */\n };\n-\n-/* For each lexical block, set BLOCK_NUMBER to the depth at which it is\n-   found in the block tree.  */\n-\n-static void\n-set_block_levels (tree block, int level)\n-{\n-  while (block)\n-    {\n-      BLOCK_NUMBER (block) = level;\n-      set_block_levels (BLOCK_SUBBLOCKS (block), level + 1);\n-      block = BLOCK_CHAIN (block);\n-    }\n-}\n \f\n /* Return sope resulting from combination of S1 and S2.  */\n static tree\n@@ -514,18 +490,16 @@ insn_scope (rtx insn)\n }\n \n /* Return line number of the statement specified by the locator.  */\n-int\n-locator_line (int loc)\n+static location_t\n+locator_location (int loc)\n {\n-  int max = VEC_length (int, line_locators_locs);\n+  int max = VEC_length (int, locations_locators_locs);\n   int min = 0;\n \n-  if (!max || !loc)\n-    return 0;\n   while (1)\n     {\n       int pos = (min + max) / 2;\n-      int tmp = VEC_index (int, line_locators_locs, pos);\n+      int tmp = VEC_index (int, locations_locators_locs, pos);\n \n       if (tmp <= loc && min != pos)\n \tmin = pos;\n@@ -537,7 +511,19 @@ locator_line (int loc)\n \t  break;\n \t}\n     }\n-  return VEC_index (int, line_locators_lines, min);\n+  return *VEC_index (location_t, locations_locators_vals, min);\n+}\n+\n+/* Return source line of the statement that produced this insn.  */\n+int\n+locator_line (int loc)\n+{\n+  expanded_location xloc;\n+  if (!loc)\n+    return 0;\n+  else\n+    xloc = expand_location (locator_location (loc));\n+  return xloc.line;\n }\n \n /* Return line number of the statement that produced this insn.  */\n@@ -551,27 +537,12 @@ insn_line (rtx insn)\n const char *\n locator_file (int loc)\n {\n-  int max = VEC_length (int, file_locators_locs);\n-  int min = 0;\n-\n-  if (!max || !loc)\n-    return NULL;\n-  while (1)\n-    {\n-      int pos = (min + max) / 2;\n-      int tmp = VEC_index (int, file_locators_locs, pos);\n-\n-      if (tmp <= loc && min != pos)\n-\tmin = pos;\n-      else if (tmp > loc && max != pos)\n-\tmax = pos;\n-      else\n-\t{\n-\t  min = pos;\n-\t  break;\n-\t}\n-    }\n-   return VARRAY_CHAR_PTR (file_locators_files, min);\n+  expanded_location xloc;\n+  if (!loc)\n+    return 0;\n+  else\n+    xloc = expand_location (locator_location (loc));\n+  return xloc.file;\n }\n \n /* Return source file of the statement that produced this insn.  */"}, {"sha": "55d35a45f59ee98716e2fa65c4ba7f0099d909a4", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55e092c4d004553a8b4e160f8132c8fd31d95af3/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55e092c4d004553a8b4e160f8132c8fd31d95af3/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=55e092c4d004553a8b4e160f8132c8fd31d95af3", "patch": "@@ -8264,8 +8264,6 @@ alpha_output_mi_thunk_osf (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,\n   HOST_WIDE_INT hi, lo;\n   rtx this, insn, funexp;\n \n-  reset_block_changes ();\n-\n   /* We always require a valid GP.  */\n   emit_insn (gen_prologue_ldgp ());\n   emit_note (NOTE_INSN_PROLOGUE_END);\n@@ -8342,7 +8340,7 @@ alpha_output_mi_thunk_osf (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,\n      instruction scheduling worth while.  Note that use_thunk calls\n      assemble_start_function and assemble_end_function.  */\n   insn = get_insns ();\n-  insn_locators_initialize ();\n+  insn_locators_alloc ();\n   shorten_branches (insn);\n   final_start_function (insn, file, 1);\n   final (insn, file, 1);"}, {"sha": "87056ddcc54eb99b1ea3ded33a1405d0de1fbd47", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55e092c4d004553a8b4e160f8132c8fd31d95af3/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55e092c4d004553a8b4e160f8132c8fd31d95af3/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=55e092c4d004553a8b4e160f8132c8fd31d95af3", "patch": "@@ -9370,7 +9370,6 @@ ia64_output_mi_thunk (FILE *file, tree thunk ATTRIBUTE_UNUSED,\n   reload_completed = 1;\n   epilogue_completed = 1;\n   no_new_pseudos = 1;\n-  reset_block_changes ();\n \n   /* Set things up as ia64_expand_prologue might.  */\n   last_scratch_gr_reg = 15;\n@@ -9485,7 +9484,7 @@ ia64_output_mi_thunk (FILE *file, tree thunk ATTRIBUTE_UNUSED,\n      instruction scheduling worth while.  Note that use_thunk calls\n      assemble_start_function and assemble_end_function.  */\n \n-  insn_locators_initialize ();\n+  insn_locators_alloc ();\n   emit_all_insn_group_barriers (NULL);\n   insn = get_insns ();\n   shorten_branches (insn);"}, {"sha": "f975e06fea99d385124d18e013a4d6b2df3ca034", "filename": "gcc/config/m68k/m68k.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55e092c4d004553a8b4e160f8132c8fd31d95af3/gcc%2Fconfig%2Fm68k%2Fm68k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55e092c4d004553a8b4e160f8132c8fd31d95af3/gcc%2Fconfig%2Fm68k%2Fm68k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.c?ref=55e092c4d004553a8b4e160f8132c8fd31d95af3", "patch": "@@ -4112,7 +4112,6 @@ m68k_output_mi_thunk (FILE *file, tree thunk ATTRIBUTE_UNUSED,\n   /* Pretend to be a post-reload pass while generating rtl.  */\n   no_new_pseudos = 1;\n   reload_completed = 1;\n-  reset_block_changes ();\n   allocate_reg_info (FIRST_PSEUDO_REGISTER, true, true);\n \n   /* The \"this\" pointer is stored at 4(%sp).  */"}, {"sha": "55bacf7bb19d54d25ab4dcddd096532967c4c11a", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55e092c4d004553a8b4e160f8132c8fd31d95af3/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55e092c4d004553a8b4e160f8132c8fd31d95af3/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=55e092c4d004553a8b4e160f8132c8fd31d95af3", "patch": "@@ -7172,7 +7172,6 @@ mips_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,\n   /* Pretend to be a post-reload pass while generating rtl.  */\n   no_new_pseudos = 1;\n   reload_completed = 1;\n-  reset_block_changes ();\n \n   /* Pick a global pointer.  Use a call-clobbered register if\n      TARGET_CALL_SAVED_GP, so that we can use a sibcall.  */\n@@ -7258,7 +7257,7 @@ mips_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,\n   /* Run just enough of rest_of_compilation.  This sequence was\n      \"borrowed\" from alpha.c.  */\n   insn = get_insns ();\n-  insn_locators_initialize ();\n+  insn_locators_alloc ();\n   split_all_insns_noflow ();\n   if (TARGET_MIPS16)\n     mips16_lay_out_constants ();"}, {"sha": "acbc7080aa26504f8d9966862f1236a9e967a3ab", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55e092c4d004553a8b4e160f8132c8fd31d95af3/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55e092c4d004553a8b4e160f8132c8fd31d95af3/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=55e092c4d004553a8b4e160f8132c8fd31d95af3", "patch": "@@ -16039,7 +16039,6 @@ rs6000_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,\n   reload_completed = 1;\n   epilogue_completed = 1;\n   no_new_pseudos = 1;\n-  reset_block_changes ();\n \n   /* Mark the end of the (empty) prologue.  */\n   emit_note (NOTE_INSN_PROLOGUE_END);\n@@ -16119,7 +16118,7 @@ rs6000_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,\n      instruction scheduling worth while.  Note that use_thunk calls\n      assemble_start_function and assemble_end_function.  */\n   insn = get_insns ();\n-  insn_locators_initialize ();\n+  insn_locators_alloc ();\n   shorten_branches (insn);\n   final_start_function (insn, file, 1);\n   final (insn, file, 1);"}, {"sha": "9fc179e15345d81398ed9dec7100d16bc2ae102e", "filename": "gcc/config/score/score.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55e092c4d004553a8b4e160f8132c8fd31d95af3/gcc%2Fconfig%2Fscore%2Fscore.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55e092c4d004553a8b4e160f8132c8fd31d95af3/gcc%2Fconfig%2Fscore%2Fscore.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fscore%2Fscore.c?ref=55e092c4d004553a8b4e160f8132c8fd31d95af3", "patch": "@@ -183,7 +183,6 @@ th_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,\n   /* Pretend to be a post-reload pass while generating rtl.  */\n   no_new_pseudos = 1;\n   reload_completed = 1;\n-  reset_block_changes ();\n \n   /* We need two temporary registers in some cases.  */\n   temp1 = gen_rtx_REG (Pmode, 8);\n@@ -231,7 +230,7 @@ th_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,\n   /* Run just enough of rest_of_compilation.  This sequence was\n      \"borrowed\" from alpha.c.  */\n   insn = get_insns ();\n-  insn_locators_initialize ();\n+  insn_locators_alloc ();\n   split_all_insns_noflow ();\n   shorten_branches (insn);\n   final_start_function (insn, file, 1);"}, {"sha": "ab9ea90232b1871bcdfe550b1d48fb0ad0d28f7c", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55e092c4d004553a8b4e160f8132c8fd31d95af3/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55e092c4d004553a8b4e160f8132c8fd31d95af3/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=55e092c4d004553a8b4e160f8132c8fd31d95af3", "patch": "@@ -10167,7 +10167,6 @@ sh_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,\n   epilogue_completed = 1;\n   no_new_pseudos = 1;\n   current_function_uses_only_leaf_regs = 1;\n-  reset_block_changes ();\n \n   emit_note (NOTE_INSN_PROLOGUE_END);\n \n@@ -10324,7 +10323,7 @@ sh_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,\n      the insns emitted.  Note that use_thunk calls\n      assemble_start_function and assemble_end_function.  */\n \n-  insn_locators_initialize ();\n+  insn_locators_alloc ();\n   insns = get_insns ();\n \n   if (optimize > 0)"}, {"sha": "be07ce7d3d0e0cd6c4589e47a21ec8f66d5157d9", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55e092c4d004553a8b4e160f8132c8fd31d95af3/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55e092c4d004553a8b4e160f8132c8fd31d95af3/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=55e092c4d004553a8b4e160f8132c8fd31d95af3", "patch": "@@ -8546,7 +8546,6 @@ sparc_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,\n   reload_completed = 1;\n   epilogue_completed = 1;\n   no_new_pseudos = 1;\n-  reset_block_changes ();\n \n   emit_note (NOTE_INSN_PROLOGUE_END);\n \n@@ -8724,7 +8723,7 @@ sparc_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,\n      instruction scheduling worth while.  Note that use_thunk calls\n      assemble_start_function and assemble_end_function.  */\n   insn = get_insns ();\n-  insn_locators_initialize ();\n+  insn_locators_alloc ();\n   shorten_branches (insn);\n   final_start_function (insn, file, 1);\n   final (insn, file, 1);"}, {"sha": "e816026a3d44851097b3071d2711c67aca58c817", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 3, "deletions": 39, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55e092c4d004553a8b4e160f8132c8fd31d95af3/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55e092c4d004553a8b4e160f8132c8fd31d95af3/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=55e092c4d004553a8b4e160f8132c8fd31d95af3", "patch": "@@ -3336,7 +3336,7 @@ make_insn_raw (rtx pattern)\n   INSN_CODE (insn) = -1;\n   LOG_LINKS (insn) = NULL;\n   REG_NOTES (insn) = NULL;\n-  INSN_LOCATOR (insn) = 0;\n+  INSN_LOCATOR (insn) = curr_insn_locator ();\n   BLOCK_FOR_INSN (insn) = NULL;\n \n #ifdef ENABLE_RTL_CHECKING\n@@ -3369,7 +3369,7 @@ make_jump_insn_raw (rtx pattern)\n   LOG_LINKS (insn) = NULL;\n   REG_NOTES (insn) = NULL;\n   JUMP_LABEL (insn) = NULL;\n-  INSN_LOCATOR (insn) = 0;\n+  INSN_LOCATOR (insn) = curr_insn_locator ();\n   BLOCK_FOR_INSN (insn) = NULL;\n \n   return insn;\n@@ -3390,7 +3390,7 @@ make_call_insn_raw (rtx pattern)\n   LOG_LINKS (insn) = NULL;\n   REG_NOTES (insn) = NULL;\n   CALL_INSN_FUNCTION_USAGE (insn) = NULL;\n-  INSN_LOCATOR (insn) = 0;\n+  INSN_LOCATOR (insn) = curr_insn_locator ();\n   BLOCK_FOR_INSN (insn) = NULL;\n \n   return insn;\n@@ -4460,42 +4460,6 @@ emit_barrier (void)\n   return barrier;\n }\n \n-/* Make line numbering NOTE insn for LOCATION add it to the end\n-   of the doubly-linked list, but only if line-numbers are desired for\n-   debugging info and it doesn't match the previous one.  */\n-\n-rtx\n-emit_line_note (location_t location)\n-{\n-  rtx note;\n-  \n-#ifdef USE_MAPPED_LOCATION\n-  if (location == last_location)\n-    return NULL_RTX;\n-#else\n-  if (location.file && last_location.file\n-      && !strcmp (location.file, last_location.file)\n-      && location.line == last_location.line)\n-    return NULL_RTX;\n-#endif\n-  last_location = location;\n-  \n-  if (no_line_numbers)\n-    {\n-      cur_insn_uid++;\n-      return NULL_RTX;\n-    }\n-\n-#ifdef USE_MAPPED_LOCATION\n-  note = emit_note ((int) location);\n-#else\n-  note = emit_note (location.line);\n-  NOTE_SOURCE_FILE (note) = location.file;\n-#endif\n-  \n-  return note;\n-}\n-\n /* Emit a copy of note ORIG.  */\n \n rtx"}, {"sha": "e8630f5cc8686b1b7cccff77f07c27c38b009415", "filename": "gcc/expr.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55e092c4d004553a8b4e160f8132c8fd31d95af3/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55e092c4d004553a8b4e160f8132c8fd31d95af3/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=55e092c4d004553a8b4e160f8132c8fd31d95af3", "patch": "@@ -6777,14 +6777,14 @@ expand_expr_real (tree exp, rtx target, enum machine_mode tmode,\n      information.  It would be better of the diagnostic routines\n      used the file/line information embedded in the tree nodes rather\n      than globals.  */\n-  if (cfun && cfun->ib_boundaries_block && EXPR_HAS_LOCATION (exp))\n+  if (cfun && EXPR_HAS_LOCATION (exp))\n     {\n       location_t saved_location = input_location;\n       input_location = EXPR_LOCATION (exp);\n-      emit_line_note (input_location);\n+      set_curr_insn_source_location (input_location);\n \n       /* Record where the insns produced belong.  */\n-      record_block_change (TREE_BLOCK (exp));\n+      set_curr_insn_block (TREE_BLOCK (exp));\n \n       ret = expand_expr_real_1 (exp, target, tmode, modifier, alt_rtl);\n "}, {"sha": "70047939501b0662c316eecce95ca51c1b459bea", "filename": "gcc/function.c", "status": "modified", "additions": 1, "deletions": 69, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55e092c4d004553a8b4e160f8132c8fd31d95af3/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55e092c4d004553a8b4e160f8132c8fd31d95af3/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=55e092c4d004553a8b4e160f8132c8fd31d95af3", "patch": "@@ -3843,18 +3843,6 @@ init_function_start (tree subr)\n {\n   prepare_function_start (subr);\n \n-  /* Prevent ever trying to delete the first instruction of a\n-     function.  Also tell final how to output a linenum before the\n-     function prologue.  Note linenums could be missing, e.g. when\n-     compiling a Java .class file.  */\n-  if (! DECL_IS_BUILTIN (subr))\n-    emit_line_note (DECL_SOURCE_LOCATION (subr));\n-\n-  /* Make sure first insn is a note even if we don't want linenums.\n-     This makes sure the first insn will never be deleted.\n-     Also, final expects a note to appear there.  */\n-  emit_note (NOTE_INSN_DELETED);\n-\n   /* Warn if this value is an aggregate type,\n      regardless of which calling convention we are using for it.  */\n   if (AGGREGATE_TYPE_P (TREE_TYPE (DECL_RESULT (subr))))\n@@ -4305,7 +4293,7 @@ expand_function_end (void)\n   /* Output a linenumber for the end of the function.\n      SDB depends on this.  */\n   force_next_line_note ();\n-  emit_line_note (input_location);\n+  set_curr_insn_source_location (input_location);\n \n   /* Before the return label (if any), clobber the return\n      registers so that they are not propagated live to the rest of\n@@ -5348,62 +5336,6 @@ reposition_prologue_and_epilogue_notes (rtx f ATTRIBUTE_UNUSED)\n #endif /* HAVE_prologue or HAVE_epilogue */\n }\n \n-/* Resets insn_block_boundaries array.  */\n-\n-void\n-reset_block_changes (void)\n-{\n-  cfun->ib_boundaries_block = VEC_alloc (tree, gc, 100);\n-  VEC_quick_push (tree, cfun->ib_boundaries_block, NULL_TREE);\n-}\n-\n-/* Record the boundary for BLOCK.  */\n-void\n-record_block_change (tree block)\n-{\n-  int i, n;\n-  tree last_block;\n-\n-  if (!block)\n-    return;\n-\n-  if(!cfun->ib_boundaries_block)\n-    return;\n-\n-  last_block = VEC_pop (tree, cfun->ib_boundaries_block);\n-  n = get_max_uid ();\n-  for (i = VEC_length (tree, cfun->ib_boundaries_block); i < n; i++)\n-    VEC_safe_push (tree, gc, cfun->ib_boundaries_block, last_block);\n-\n-  VEC_safe_push (tree, gc, cfun->ib_boundaries_block, block);\n-}\n-\n-/* Finishes record of boundaries.  */\n-void\n-finalize_block_changes (void)\n-{\n-  record_block_change (DECL_INITIAL (current_function_decl));\n-}\n-\n-/* For INSN return the BLOCK it belongs to.  */ \n-void\n-check_block_change (rtx insn, tree *block)\n-{\n-  unsigned uid = INSN_UID (insn);\n-\n-  if (uid >= VEC_length (tree, cfun->ib_boundaries_block))\n-    return;\n-\n-  *block = VEC_index (tree, cfun->ib_boundaries_block, uid);\n-}\n-\n-/* Releases the ib_boundaries_block records.  */\n-void\n-free_block_changes (void)\n-{\n-  VEC_free (tree, gc, cfun->ib_boundaries_block);\n-}\n-\n /* Returns the name of the current function.  */\n const char *\n current_function_name (void)"}, {"sha": "a5afd1b8ddd879e44d57f5ad285087097933ea4c", "filename": "gcc/function.h", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55e092c4d004553a8b4e160f8132c8fd31d95af3/gcc%2Ffunction.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55e092c4d004553a8b4e160f8132c8fd31d95af3/gcc%2Ffunction.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.h?ref=55e092c4d004553a8b4e160f8132c8fd31d95af3", "patch": "@@ -347,9 +347,6 @@ struct function GTY(())\n   /* Line number of the end of the function.  */\n   location_t function_end_locus;\n \n-  /* Array mapping insn uids to blocks.  */\n-  VEC(tree,gc) *ib_boundaries_block;\n-\n   /* The variables unexpanded so far.  */\n   tree unexpanded_var_list;\n \n@@ -552,11 +549,6 @@ extern void number_blocks (tree);\n \n extern void clear_block_marks (tree);\n extern tree blocks_nreverse (tree);\n-extern void reset_block_changes (void);\n-extern void record_block_change (tree);\n-extern void finalize_block_changes (void);\n-extern void check_block_change (rtx, tree *);\n-extern void free_block_changes (void);\n \n /* Return size needed for stack frame based on slots so far allocated.\n    This size counts from zero.  It is not rounded to STACK_BOUNDARY;"}, {"sha": "9650e894cd6d5c47fa90208628fc0e07bc9cfa96", "filename": "gcc/passes.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55e092c4d004553a8b4e160f8132c8fd31d95af3/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55e092c4d004553a8b4e160f8132c8fd31d95af3/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=55e092c4d004553a8b4e160f8132c8fd31d95af3", "patch": "@@ -654,7 +654,6 @@ init_optimization_passes (void)\n       struct tree_opt_pass **p = &pass_rest_of_compilation.sub;\n       NEXT_PASS (pass_init_function);\n       NEXT_PASS (pass_jump);\n-      NEXT_PASS (pass_insn_locators_initialize);\n       NEXT_PASS (pass_rtl_eh);\n       NEXT_PASS (pass_initial_value_sets);\n       NEXT_PASS (pass_unshare_all_rtl);"}, {"sha": "2ba7c8a471d43d4ef53cddeb1ef91df1dc42213c", "filename": "gcc/rtl.h", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55e092c4d004553a8b4e160f8132c8fd31d95af3/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55e092c4d004553a8b4e160f8132c8fd31d95af3/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=55e092c4d004553a8b4e160f8132c8fd31d95af3", "patch": "@@ -1562,7 +1562,6 @@ extern rtx emit_label (rtx);\n extern rtx emit_barrier (void);\n extern rtx emit_note (int);\n extern rtx emit_note_copy (rtx);\n-extern rtx emit_line_note (location_t);\n extern rtx make_insn_raw (rtx);\n extern rtx make_jump_insn_raw (rtx);\n extern void add_function_usage_to (rtx, rtx);\n@@ -2298,4 +2297,10 @@ extern const struct rtl_hooks general_rtl_hooks;\n /* Keep this for the nonce.  */\n #define gen_lowpart rtl_hooks.gen_lowpart\n \n+extern void insn_locators_alloc (void);\n+extern void insn_locators_finalize (void);\n+extern void set_curr_insn_source_location (location_t);\n+extern void set_curr_insn_block (tree);\n+extern int curr_insn_locator (void);\n+\n #endif /* ! GCC_RTL_H */"}, {"sha": "a6dfc683d59e250b5405aca3a35c96a0504edd0d", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55e092c4d004553a8b4e160f8132c8fd31d95af3/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55e092c4d004553a8b4e160f8132c8fd31d95af3/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=55e092c4d004553a8b4e160f8132c8fd31d95af3", "patch": "@@ -1117,7 +1117,6 @@ initialize_cfun (tree new_fndecl, tree callee_fndecl, gcov_type count,\n   new_cfun->unexpanded_var_list = NULL;\n   new_cfun->cfg = NULL;\n   new_cfun->decl = new_fndecl /*= copy_node (callee_fndecl)*/;\n-  new_cfun->ib_boundaries_block = NULL;\n   DECL_STRUCT_FUNCTION (new_fndecl) = new_cfun;\n   push_cfun (new_cfun);\n   init_empty_tree_cfg ();"}, {"sha": "b77243582b6da1491b06563a0ac9bc3ce0c9aeb9", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55e092c4d004553a8b4e160f8132c8fd31d95af3/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55e092c4d004553a8b4e160f8132c8fd31d95af3/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=55e092c4d004553a8b4e160f8132c8fd31d95af3", "patch": "@@ -332,7 +332,6 @@ extern struct tree_opt_pass pass_fixup_cfg;\n \n extern struct tree_opt_pass pass_init_function;\n extern struct tree_opt_pass pass_jump;\n-extern struct tree_opt_pass pass_insn_locators_initialize;\n extern struct tree_opt_pass pass_rtl_eh;\n extern struct tree_opt_pass pass_initial_value_sets;\n extern struct tree_opt_pass pass_unshare_all_rtl;"}]}