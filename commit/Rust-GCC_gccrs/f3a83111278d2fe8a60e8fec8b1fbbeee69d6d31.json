{"sha": "f3a83111278d2fe8a60e8fec8b1fbbeee69d6d31", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjNhODMxMTEyNzhkMmZlOGE2MGU4ZmVjOGIxZmJiZWVlNjlkNmQzMQ==", "commit": {"author": {"name": "Steve Ellcey", "email": "sje@cup.hp.com", "date": "2009-05-19T18:18:08Z"}, "committer": {"name": "Steve Ellcey", "email": "sje@gcc.gnu.org", "date": "2009-05-19T18:18:08Z"}, "message": "ia64-protos.h (ia64_dconst_0_5): New.\n\n\t* config/ia64/ia64-protos.h (ia64_dconst_0_5): New.\n\t(ia64_dconst_0_375): New.\n\t* config/ia64/ia64.c (ia64_override_options): Remove\n\t-minline-sqrt-min-latency warning.\n\t(ia64_dconst_0_5_rtx, ia64_dconst_0_5): New.\n\t(ia64_dconst_0_375_rtx, ia64_dconst_0_375): New\n\t* config/ia64/ia64.md (*sqrt_approx): Remove.\n\t(sqrtsf2): Remove #if 0.\n\t(sqrtsf2_internal_thr): Rewrite and move to div.md.\n\t(sqrtdf): Remove assert.\n\t(sqrtdf2_internal_thr): Rewrite and move to div.md.\n\t(sqrtxf2): Remove #if 0.\n\t(sqrtxf2_internal_thr): Rewrite and move to div.md.\n\t* div.md (sqrt_approx_rf): New.\n\t(sqrtsf2_internal_thr): New implementation.\n\t(sqrtsf2_internal_lat): New.\n\t(sqrtdf2_internal_thr: New implementation.\n\t(sqrtxf2_internal): New implementation.\n\nFrom-SVN: r147713", "tree": {"sha": "09f6fa1806cdc0177422ec6b1a176bb043076c3a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/09f6fa1806cdc0177422ec6b1a176bb043076c3a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f3a83111278d2fe8a60e8fec8b1fbbeee69d6d31", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f3a83111278d2fe8a60e8fec8b1fbbeee69d6d31", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f3a83111278d2fe8a60e8fec8b1fbbeee69d6d31", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f3a83111278d2fe8a60e8fec8b1fbbeee69d6d31/comments", "author": null, "committer": null, "parents": [{"sha": "1ffc7157ef3f33a65c7acbf23b204030b21d82fe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ffc7157ef3f33a65c7acbf23b204030b21d82fe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1ffc7157ef3f33a65c7acbf23b204030b21d82fe"}], "stats": {"total": 757, "additions": 336, "deletions": 421}, "files": [{"sha": "658a3c63aa8d36f91bb2cc31a455ea951c7c3403", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3a83111278d2fe8a60e8fec8b1fbbeee69d6d31/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3a83111278d2fe8a60e8fec8b1fbbeee69d6d31/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f3a83111278d2fe8a60e8fec8b1fbbeee69d6d31", "patch": "@@ -1,3 +1,24 @@\n+2009-05-19  Steve Ellcey  <sje@cup.hp.com>\n+\n+\t* config/ia64/ia64-protos.h (ia64_dconst_0_5): New.\n+\t(ia64_dconst_0_375): New.\n+\t* config/ia64/ia64.c (ia64_override_options): Remove\n+\t-minline-sqrt-min-latency warning.\n+\t(ia64_dconst_0_5_rtx, ia64_dconst_0_5): New.\n+\t(ia64_dconst_0_375_rtx, ia64_dconst_0_375): New\n+\t* config/ia64/ia64.md (*sqrt_approx): Remove.\n+\t(sqrtsf2): Remove #if 0.\n+\t(sqrtsf2_internal_thr): Rewrite and move to div.md.\n+\t(sqrtdf): Remove assert.\n+\t(sqrtdf2_internal_thr): Rewrite and move to div.md.\n+\t(sqrtxf2): Remove #if 0.\n+\t(sqrtxf2_internal_thr): Rewrite and move to div.md.\n+\t* div.md (sqrt_approx_rf): New.\n+\t(sqrtsf2_internal_thr): New implementation.\n+\t(sqrtsf2_internal_lat): New.\n+\t(sqrtdf2_internal_thr: New implementation.\n+\t(sqrtxf2_internal): New implementation.\n+\n 2009-05-19  Francois-Xavier Coudert  <fxcoudert@gmail.com>\n \t    Hans-Peter Nilsson  <hp@axis.com>\n "}, {"sha": "583e9e3dbeee33a73c4c7ecdb0b3f174b841d7c4", "filename": "gcc/config/ia64/div.md", "status": "modified", "additions": 278, "deletions": 0, "changes": 278, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3a83111278d2fe8a60e8fec8b1fbbeee69d6d31/gcc%2Fconfig%2Fia64%2Fdiv.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3a83111278d2fe8a60e8fec8b1fbbeee69d6d31/gcc%2Fconfig%2Fia64%2Fdiv.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fdiv.md?ref=f3a83111278d2fe8a60e8fec8b1fbbeee69d6d31", "patch": "@@ -518,3 +518,281 @@\n   emit_insn (gen_truncrfxf2 (operands[0], q_res));\n   DONE;\n })\n+\n+\n+;; SQRT operations\n+\n+\n+(define_insn \"sqrt_approx_rf\"\n+  [(set (match_operand:RF 0 \"fr_register_operand\" \"=f\")\n+                (unspec:RF [(match_operand:RF 1 \"fr_reg_or_fp01_operand\" \"fG\")]\n+\t\t\t   UNSPEC_FR_SQRT_RECIP_APPROX_RES))\n+   (set (match_operand:BI 2 \"register_operand\" \"=c\")\n+        (unspec:BI [(match_dup 1)] UNSPEC_FR_SQRT_RECIP_APPROX))\n+   (use (match_operand:SI 3 \"const_int_operand\" \"\"))]\n+  \"\"\n+  \"frsqrta.s%3 %0, %2 = %F1\"\n+  [(set_attr \"itanium_class\" \"fmisc\")\n+   (set_attr \"predicable\" \"no\")])\n+\n+(define_expand \"sqrtsf2_internal_thr\"\n+  [(set (match_operand:SF 0 \"fr_register_operand\" \"\")\n+        (sqrt:SF (match_operand:SF 1 \"fr_register_operand\" \"\")))]\n+  \"TARGET_INLINE_SQRT\"\n+{\n+  rtx y         = gen_reg_rtx (RFmode);\n+  rtx b         = gen_reg_rtx (RFmode);\n+  rtx g         = gen_reg_rtx (RFmode);\n+  rtx e         = gen_reg_rtx (RFmode);\n+  rtx s         = gen_reg_rtx (RFmode);\n+  rtx f         = gen_reg_rtx (RFmode);\n+  rtx y1        = gen_reg_rtx (RFmode);\n+  rtx g1        = gen_reg_rtx (RFmode);\n+  rtx h         = gen_reg_rtx (RFmode);\n+  rtx d         = gen_reg_rtx (RFmode);\n+  rtx g2        = gen_reg_rtx (RFmode);\n+  rtx cond      = gen_reg_rtx (BImode);\n+  rtx zero      = CONST0_RTX (RFmode);\n+  rtx one       = CONST1_RTX (RFmode);\n+  rtx c1        = ia64_dconst_0_5();\n+  rtx c2        = ia64_dconst_0_375();\n+  rtx reg_df_c1\t= gen_reg_rtx (DFmode);\n+  rtx reg_df_c2\t= gen_reg_rtx (DFmode);\n+  rtx reg_rf_c1 = gen_reg_rtx (RFmode);\n+  rtx reg_rf_c2 = gen_reg_rtx (RFmode);\n+  rtx status0   = CONST0_RTX (SImode);\n+  rtx status1   = CONST1_RTX (SImode);\n+  rtx trunc_sgl = CONST0_RTX (SImode);\n+  rtx trunc_off = CONST2_RTX (SImode);\n+\n+  /* Put needed constants into registers.\t */\n+  emit_insn (gen_movdf (reg_df_c1, c1));\n+  emit_insn (gen_movdf (reg_df_c2, c2));\n+  emit_insn (gen_extenddfrf2 (reg_rf_c1, reg_df_c1));\n+  emit_insn (gen_extenddfrf2 (reg_rf_c2, reg_df_c2));\n+  /* Empty conversion to put input into RFmode.  */\n+  emit_insn (gen_extendsfrf2 (b, operands[1]));\n+  /* y = sqrt (1 / b)\t\t\t*/\n+  emit_insn (gen_sqrt_approx_rf (y, b, cond, status0));\n+  /* g = b * y\t\t\t\t*/\n+  emit_insn (gen_mulrf3_cond (g, cond, b, y, zero, status1, trunc_off));\n+  /* e = 1 - (g * y)\t\t\t*/\n+  emit_insn (gen_m2subrf4_cond (e, cond, one, g, y, zero, status1, trunc_off));\n+  /* s = 0.5 + (0.375 * e)\t\t*/\n+  emit_insn (gen_m2addrf4_cond (s, cond, reg_rf_c1, reg_rf_c2, e, zero, status1, trunc_off));\n+  /* f = y * e\t\t\t\t*/\n+  emit_insn (gen_mulrf3_cond (f, cond, y, e, zero, status1, trunc_off));\n+  /* y1 = y + (f * s)\t\t\t*/\n+  emit_insn (gen_m2addrf4_cond (y1, cond, y, f, s, zero, status1, trunc_off));\n+  /* g1 = single (b * y1)\t\t*/\n+  emit_insn (gen_mulrf3_cond (g1, cond, b, y1, zero, status1, trunc_sgl));\n+  /* h = 0.5 * y1\t\t\t*/\n+  emit_insn (gen_mulrf3_cond (h, cond, reg_rf_c1, y1, zero, status1, trunc_off));\n+  /* d = b - g1 * g1\t\t\t*/\n+  emit_insn (gen_m2subrf4_cond (d, cond, b, g1, g1, zero, status1, trunc_off));\n+  /* g2 = single(g1 + (d * h))\t\t*/\n+  emit_insn (gen_m2addrf4_cond (g2, cond, g1, d, h, y, status0, trunc_sgl));\n+  /* Conversion back into SFmode.       */\n+  emit_insn (gen_truncrfsf2 (operands[0], g2));\n+  DONE;\n+})\n+\n+(define_expand \"sqrtsf2_internal_lat\"\n+  [(set (match_operand:SF 0 \"fr_register_operand\" \"\")\n+        (sqrt:SF (match_operand:SF 1 \"fr_register_operand\" \"\")))]\n+  \"TARGET_INLINE_SQRT\"\n+{\n+  rtx y         = gen_reg_rtx (RFmode);\n+  rtx b         = gen_reg_rtx (RFmode);\n+  rtx g         = gen_reg_rtx (RFmode);\n+  rtx g1        = gen_reg_rtx (RFmode);\n+  rtx g2        = gen_reg_rtx (RFmode);\n+  rtx e         = gen_reg_rtx (RFmode);\n+  rtx s         = gen_reg_rtx (RFmode);\n+  rtx f         = gen_reg_rtx (RFmode);\n+  rtx f1        = gen_reg_rtx (RFmode);\n+  rtx h         = gen_reg_rtx (RFmode);\n+  rtx h1        = gen_reg_rtx (RFmode);\n+  rtx d         = gen_reg_rtx (RFmode);\n+  rtx cond      = gen_reg_rtx (BImode);\n+  rtx zero      = CONST0_RTX (RFmode);\n+  rtx one       = CONST1_RTX (RFmode);\n+  rtx c1        = ia64_dconst_0_5();\n+  rtx c2        = ia64_dconst_0_375();\n+  rtx reg_df_c1\t= gen_reg_rtx (DFmode);\n+  rtx reg_df_c2\t= gen_reg_rtx (DFmode);\n+  rtx reg_rf_c1 = gen_reg_rtx (RFmode);\n+  rtx reg_rf_c2 = gen_reg_rtx (RFmode);\n+  rtx status0   = CONST0_RTX (SImode);\n+  rtx status1   = CONST1_RTX (SImode);\n+  rtx trunc_sgl = CONST0_RTX (SImode);\n+  rtx trunc_off = CONST2_RTX (SImode);\n+\n+  /* Put needed constants into registers.\t */\n+  emit_insn (gen_movdf (reg_df_c1, c1));\n+  emit_insn (gen_movdf (reg_df_c2, c2));\n+  emit_insn (gen_extenddfrf2 (reg_rf_c1, reg_df_c1));\n+  emit_insn (gen_extenddfrf2 (reg_rf_c2, reg_df_c2));\n+  /* Empty conversion to put input into RFmode.  */\n+  emit_insn (gen_extendsfrf2 (b, operands[1]));\n+  /* y = sqrt (1 / b)\t\t\t*/\n+  emit_insn (gen_sqrt_approx_rf (y, b, cond, status0));\n+  /* g = b * y\t\t\t\t*/\n+  emit_insn (gen_mulrf3_cond (g, cond, b, y, zero, status1, trunc_off));\n+  /* e = 1 - (g * y)\t\t\t*/\n+  emit_insn (gen_m2subrf4_cond (e, cond, one, g, y, zero, status1, trunc_off));\n+  /* h = 0.5 * y\t\t\t*/\n+  emit_insn (gen_mulrf3_cond (h, cond, reg_rf_c1, y, zero, status1, trunc_off));\n+  /* s = 0.5 + (0.375 * e)\t\t*/\n+  emit_insn (gen_m2addrf4_cond (s, cond, reg_rf_c1, reg_rf_c2, e, zero, status1, trunc_off));\n+  /* f = e * g\t\t\t\t*/\n+  emit_insn (gen_mulrf3_cond (f, cond, e, g, zero, status1, trunc_off));\n+  /* g1 = single (g + (f * s))\t\t*/\n+  emit_insn (gen_m2addrf4_cond (g1, cond, g, f, s, zero, status1, trunc_sgl));\n+  /* f1 = e * h\t\t\t\t*/\n+  emit_insn (gen_mulrf3_cond (f1, cond, e, h, zero, status1, trunc_off));\n+  /* d = b - g1 * g1\t\t\t*/\n+  emit_insn (gen_m2subrf4_cond (d, cond, b, g1, g1, zero, status1, trunc_off));\n+  /* h1 = h + (f1 * s)\t\t\t*/\n+  emit_insn (gen_m2addrf4_cond (h1, cond, h, f1, s, zero, status1, trunc_off));\n+  /* g2 = single(g1 + (d * h1))\t\t*/\n+  emit_insn (gen_m2addrf4_cond (g2, cond, g1, d, h1, y, status0, trunc_sgl));\n+  /* Conversion back into SFmode.       */\n+  emit_insn (gen_truncrfsf2 (operands[0], g2));\n+  DONE;\n+})\n+\n+(define_expand \"sqrtdf2_internal_thr\"\n+  [(set (match_operand:DF 0 \"fr_register_operand\" \"\")\n+        (sqrt:DF (match_operand:DF 1 \"fr_register_operand\" \"\")))]\n+  \"TARGET_INLINE_SQRT\"\n+{\n+  rtx y         = gen_reg_rtx (RFmode);\n+  rtx b         = gen_reg_rtx (RFmode);\n+  rtx g         = gen_reg_rtx (RFmode);\n+  rtx g1        = gen_reg_rtx (RFmode);\n+  rtx g2        = gen_reg_rtx (RFmode);\n+  rtx g3        = gen_reg_rtx (RFmode);\n+  rtx g4        = gen_reg_rtx (RFmode);\n+  rtx r         = gen_reg_rtx (RFmode);\n+  rtx r1        = gen_reg_rtx (RFmode);\n+  rtx h         = gen_reg_rtx (RFmode);\n+  rtx h1        = gen_reg_rtx (RFmode);\n+  rtx h2        = gen_reg_rtx (RFmode);\n+  rtx d         = gen_reg_rtx (RFmode);\n+  rtx d1        = gen_reg_rtx (RFmode);\n+  rtx cond      = gen_reg_rtx (BImode);\n+  rtx zero      = CONST0_RTX (RFmode);\n+  rtx c1        = ia64_dconst_0_5();\n+  rtx reg_df_c1\t= gen_reg_rtx (DFmode);\n+  rtx reg_rf_c1 = gen_reg_rtx (RFmode);\n+  rtx status0   = CONST0_RTX (SImode);\n+  rtx status1   = CONST1_RTX (SImode);\n+  rtx trunc_dbl = CONST1_RTX (SImode);\n+  rtx trunc_off = CONST2_RTX (SImode);\n+\n+  /* Put needed constants into registers.\t */\n+  emit_insn (gen_movdf (reg_df_c1, c1));\n+  emit_insn (gen_extenddfrf2 (reg_rf_c1, reg_df_c1));\n+  /* Empty conversion to put input into RFmode.  */\n+  emit_insn (gen_extenddfrf2 (b, operands[1]));\n+  /* y = sqrt (1 / b)\t\t\t*/\n+  emit_insn (gen_sqrt_approx_rf (y, b, cond, status0));\n+  /* g = b * y\t\t\t\t*/\n+  emit_insn (gen_mulrf3_cond (g, cond, b, y, zero, status1, trunc_off));\n+  /* h = 0.5 * y\t\t\t*/\n+  emit_insn (gen_mulrf3_cond (h, cond, reg_rf_c1, y, zero, status1, trunc_off));\n+  /* r = 0.5 - (g * h)\t\t\t*/\n+  emit_insn (gen_m2subrf4_cond (r, cond, reg_rf_c1, g, h, zero, status1, trunc_off));\n+  /* g1 = g + (g * r)\t\t\t*/\n+  emit_insn (gen_m2addrf4_cond (g1, cond, g, g, r, zero, status1, trunc_off));\n+  /* h1 = h + (h * r)\t\t\t*/\n+  emit_insn (gen_m2addrf4_cond (h1, cond, h, h, r, zero, status1, trunc_off));\n+  /* r1 = 0.5 - (g1 * h1)\t\t*/\n+  emit_insn (gen_m2subrf4_cond (r1, cond, reg_rf_c1, g1, h1, zero, status1, trunc_off));\n+  /* g2 = g1 + (g1 * r1)\t\t*/\n+  emit_insn (gen_m2addrf4_cond (g2, cond, g1, g1, r1, zero, status1, trunc_off));\n+  /* h2 = h1 + (h1 * r1)\t\t*/\n+  emit_insn (gen_m2addrf4_cond (h2, cond, h1, h1, r1, zero, status1, trunc_off));\n+  /* d = b - (g2 * g2)\t\t\t*/\n+  emit_insn (gen_m2subrf4_cond (d, cond, b, g2, g2, zero, status1, trunc_off));\n+  /* g3 = g2 + (d * h2)\t\t\t*/\n+  emit_insn (gen_m2addrf4_cond (g3, cond, g2, d, h2, zero, status1, trunc_off));\n+  /* d1 = b - (g3 * g3)\t\t\t*/\n+  emit_insn (gen_m2subrf4_cond (d1, cond, b, g3, g3, zero, status1, trunc_off));\n+  /* g4 = g3 + (d1 * h2)\t\t*/\n+  emit_insn (gen_m2addrf4_cond (g4, cond, g3, d1, h2, y, status1, trunc_dbl));\n+  /* Conversion back into SFmode.       */\n+  emit_insn (gen_truncrfdf2 (operands[0], g4));\n+  DONE;\n+})\n+\n+(define_expand \"sqrtxf2_internal\"\n+  [(set (match_operand:XF 0 \"fr_register_operand\" \"\")\n+        (sqrt:XF (match_operand:XF 1 \"fr_register_operand\" \"\")))]\n+  \"TARGET_INLINE_SQRT\"\n+{\n+  rtx y         = gen_reg_rtx (RFmode);\n+  rtx b         = gen_reg_rtx (RFmode);\n+  rtx g         = gen_reg_rtx (RFmode);\n+  rtx g1        = gen_reg_rtx (RFmode);\n+  rtx g2        = gen_reg_rtx (RFmode);\n+  rtx g3        = gen_reg_rtx (RFmode);\n+  rtx g4        = gen_reg_rtx (RFmode);\n+  rtx e         = gen_reg_rtx (RFmode);\n+  rtx e1        = gen_reg_rtx (RFmode);\n+  rtx e2        = gen_reg_rtx (RFmode);\n+  rtx h         = gen_reg_rtx (RFmode);\n+  rtx h1        = gen_reg_rtx (RFmode);\n+  rtx h2        = gen_reg_rtx (RFmode);\n+  rtx h3        = gen_reg_rtx (RFmode);\n+  rtx d         = gen_reg_rtx (RFmode);\n+  rtx d1        = gen_reg_rtx (RFmode);\n+  rtx cond      = gen_reg_rtx (BImode);\n+  rtx zero      = CONST0_RTX (RFmode);\n+  rtx c1        = ia64_dconst_0_5();\n+  rtx reg_df_c1\t= gen_reg_rtx (DFmode);\n+  rtx reg_rf_c1 = gen_reg_rtx (RFmode);\n+  rtx status0   = CONST0_RTX (SImode);\n+  rtx status1   = CONST1_RTX (SImode);\n+  rtx trunc_off = CONST2_RTX (SImode);\n+\n+  /* Put needed constants into registers.\t */\n+  emit_insn (gen_movdf (reg_df_c1, c1));\n+  emit_insn (gen_extenddfrf2 (reg_rf_c1, reg_df_c1));\n+  /* Empty conversion to put input into RFmode.  */\n+  emit_insn (gen_extendxfrf2 (b, operands[1]));\n+  /* y = sqrt (1 / b)\t\t\t*/\n+  emit_insn (gen_sqrt_approx_rf (y, b, cond, status0));\n+  /* g = b * y\t\t\t\t*/\n+  emit_insn (gen_mulrf3_cond (g, cond, b, y, zero, status1, trunc_off));\n+  /* h = 0.5 * y\t\t\t*/\n+  emit_insn (gen_mulrf3_cond (h, cond, reg_rf_c1, y, zero, status1, trunc_off));\n+  /* e = 0.5 - (g * h)\t\t\t*/\n+  emit_insn (gen_m2subrf4_cond (e, cond, reg_rf_c1, g, h, zero, status1, trunc_off));\n+  /* g1 = g + (g * e)\t\t\t*/\n+  emit_insn (gen_m2addrf4_cond (g1, cond, g, g, e, zero, status1, trunc_off));\n+  /* h1 = h + (h * e)\t\t\t*/\n+  emit_insn (gen_m2addrf4_cond (h1, cond, h, h, e, zero, status1, trunc_off));\n+  /* e1 = 0.5 - (g1 * h1)\t\t*/\n+  emit_insn (gen_m2subrf4_cond (e1, cond, reg_rf_c1, g1, h1, zero, status1, trunc_off));\n+  /* g2 = g1 + (g1 * e1)\t\t*/\n+  emit_insn (gen_m2addrf4_cond (g2, cond, g1, g1, e1, zero, status1, trunc_off));\n+  /* h2 = h1 + (h1 * e1)\t\t*/\n+  emit_insn (gen_m2addrf4_cond (h2, cond, h1, h1, e1, zero, status1, trunc_off));\n+  /* d = b - (g2 * g2)\t\t\t*/\n+  emit_insn (gen_m2subrf4_cond (d, cond, b, g2, g2, zero, status1, trunc_off));\n+  /* e2 = 0.5 - (g2 * h2)\t\t*/\n+  emit_insn (gen_m2subrf4_cond (e2, cond, reg_rf_c1, g2, h2, zero, status1, trunc_off));\n+  /* g3 = g2 + (d * h2)\t\t\t*/\n+  emit_insn (gen_m2addrf4_cond (g3, cond, g2, d, h2, zero, status1, trunc_off));\n+  /* h3 = h2 + (e2 * h2)\t\t*/\n+  emit_insn (gen_m2addrf4_cond (h3, cond, h2, e2, h2, zero, status1, trunc_off));\n+  /* d1 = b - (g3 * g3)\t\t\t*/\n+  emit_insn (gen_m2subrf4_cond (d1, cond, b, g3, g3, zero, status1, trunc_off));\n+  /* g4 = g3 + (d1 * h3)\t\t*/\n+  emit_insn (gen_m2addrf4_cond (g4, cond, g3, d1, h3, y, status1, trunc_off));\n+  /* Conversion back into SFmode.       */\n+  emit_insn (gen_truncrfxf2 (operands[0], g4));\n+  DONE;\n+})"}, {"sha": "5a68854296f0b645fe930e303601bcd3ec8e384c", "filename": "gcc/config/ia64/ia64-protos.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3a83111278d2fe8a60e8fec8b1fbbeee69d6d31/gcc%2Fconfig%2Fia64%2Fia64-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3a83111278d2fe8a60e8fec8b1fbbeee69d6d31/gcc%2Fconfig%2Fia64%2Fia64-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64-protos.h?ref=f3a83111278d2fe8a60e8fec8b1fbbeee69d6d31", "patch": "@@ -102,3 +102,6 @@ extern void ia64_profile_hook (int);\n \n extern void ia64_optimization_options (int, int);\n extern void ia64_init_expanders (void);\n+\n+extern rtx ia64_dconst_0_5 (void);\n+extern rtx ia64_dconst_0_375 (void);"}, {"sha": "f9b84606964d0f162fe4c331b8eb6ef73e91a30d", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 29, "deletions": 6, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3a83111278d2fe8a60e8fec8b1fbbeee69d6d31/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3a83111278d2fe8a60e8fec8b1fbbeee69d6d31/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=f3a83111278d2fe8a60e8fec8b1fbbeee69d6d31", "patch": "@@ -5280,12 +5280,6 @@ ia64_override_options (void)\n   if (TARGET_AUTO_PIC)\n     target_flags |= MASK_CONST_GP;\n \n-  if (TARGET_INLINE_SQRT == INL_MIN_LAT)\n-    {\n-      warning (0, \"not yet implemented: latency-optimized inline square root\");\n-      TARGET_INLINE_SQRT = INL_MAX_THR;\n-    }\n-\n   ia64_flag_schedule_insns2 = flag_schedule_insns_after_reload;\n   flag_schedule_insns_after_reload = 0;\n \n@@ -10571,4 +10565,33 @@ ia64_c_mode_for_suffix (char suffix)\n   return VOIDmode;\n }\n \n+static GTY(()) rtx ia64_dconst_0_5_rtx;\n+\n+rtx\n+ia64_dconst_0_5 (void)\n+{\n+  if (! ia64_dconst_0_5_rtx)\n+    {\n+      REAL_VALUE_TYPE rv;\n+      real_from_string (&rv, \"0.5\");\n+      ia64_dconst_0_5_rtx = const_double_from_real_value (rv, DFmode);\n+    }\n+  return ia64_dconst_0_5_rtx;\n+}\n+\n+static GTY(()) rtx ia64_dconst_0_375_rtx;\n+\n+rtx\n+ia64_dconst_0_375 (void)\n+{\n+  if (! ia64_dconst_0_375_rtx)\n+    {\n+      REAL_VALUE_TYPE rv;\n+      real_from_string (&rv, \"0.375\");\n+      ia64_dconst_0_375_rtx = const_double_from_real_value (rv, DFmode);\n+    }\n+  return ia64_dconst_0_375_rtx;\n+}\n+\n+\n #include \"gt-ia64.h\""}, {"sha": "29197724f56c72d1ac43009b306da290c039b7aa", "filename": "gcc/config/ia64/ia64.md", "status": "modified", "additions": 5, "deletions": 415, "changes": 420, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3a83111278d2fe8a60e8fec8b1fbbeee69d6d31/gcc%2Fconfig%2Fia64%2Fia64.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3a83111278d2fe8a60e8fec8b1fbbeee69d6d31/gcc%2Fconfig%2Fia64%2Fia64.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.md?ref=f3a83111278d2fe8a60e8fec8b1fbbeee69d6d31", "patch": "@@ -3161,21 +3161,6 @@\n   DONE;\n })\n \n-;; Inline square root.\n-\n-(define_insn \"*sqrt_approx\"\n-  [(set (match_operand:XF 0 \"fr_register_operand\" \"=f\")\n-        (div:XF (const_int 1)\n-\t\t(unspec:XF [(match_operand:XF 2 \"fr_reg_or_fp01_operand\" \"fG\")]\n-\t\t\t   UNSPEC_FR_SQRT_RECIP_APPROX_RES)))\n-   (set (match_operand:BI 1 \"register_operand\" \"=c\")\n-        (unspec:BI [(match_dup 2)] UNSPEC_FR_SQRT_RECIP_APPROX))\n-   (use (match_operand:SI 3 \"const_int_operand\" \"\")) ]\n-  \"\"\n-  \"frsqrta.s%3 %0, %1 = %2\"\n-  [(set_attr \"itanium_class\" \"fmisc\")\n-   (set_attr \"predicable\" \"no\")])\n-\n (define_insn \"setf_exp_xf\"\n   [(set (match_operand:XF 0 \"fr_register_operand\" \"=f\")\n         (unspec:XF [(match_operand:DI 1 \"register_operand\" \"r\")]\n@@ -3184,133 +3169,22 @@\n   \"setf.exp %0 = %1\"\n   [(set_attr \"itanium_class\" \"frfr\")])\n \n+\n+;; Inline square root.\n+\n (define_expand \"sqrtsf2\"\n   [(set (match_operand:SF 0 \"fr_register_operand\" \"=&f\")\n \t(sqrt:SF (match_operand:SF 1 \"fr_reg_or_fp01_operand\" \"fG\")))]\n   \"TARGET_INLINE_SQRT\"\n {\n   rtx insn;\n-#if 0\n   if (TARGET_INLINE_SQRT == INL_MIN_LAT)\n     insn = gen_sqrtsf2_internal_lat (operands[0], operands[1]);\n   else\n-#else\n-  gcc_assert (TARGET_INLINE_SQRT != INL_MIN_LAT);\n-#endif\n-  insn = gen_sqrtsf2_internal_thr (operands[0], operands[1]);\n+    insn = gen_sqrtsf2_internal_thr (operands[0], operands[1]);\n   emit_insn (insn);\n   DONE;\n })\n-\n-;; Latency-optimized square root.\n-;; FIXME: Implement.\n-\n-;; Throughput-optimized square root.\n-\n-(define_insn_and_split \"sqrtsf2_internal_thr\"\n-  [(set (match_operand:SF 0 \"fr_register_operand\" \"=&f\")\n-\t(sqrt:SF (match_operand:SF 1 \"fr_reg_or_fp01_operand\" \"fG\")))\n-   ;; Register r2 in optimization guide.\n-   (clobber (match_scratch:DI 2 \"=r\"))\n-   ;; Register f8 in optimization guide\n-   (clobber (match_scratch:XF 3 \"=&f\"))\n-   ;; Register f9 in optimization guide\n-   (clobber (match_scratch:XF 4 \"=&f\"))\n-   ;; Register f10 in optimization guide\n-   (clobber (match_scratch:XF 5 \"=&f\"))\n-   ;; Register p6 in optimization guide.\n-   (clobber (match_scratch:BI 6 \"=c\"))]\n-  \"TARGET_INLINE_SQRT == INL_MAX_THR\"\n-  \"#\"\n-  \"&& reload_completed\"\n-  [ ;; exponent of +1/2 in r2\n-    (set (match_dup 2) (const_int 65534))\n-    ;; +1/2 in f8\n-    (set (match_dup 3) \n-         (unspec:XF [(match_dup 2)] UNSPEC_SETF_EXP))\n-    ;; Step 1\n-    ;; y0 = 1/sqrt(a) in f7\n-    (parallel [(set (match_dup 7)\n-                    (div:XF (const_int 1)\n-\t\t\t    (unspec:XF [(match_dup 8)]\n-\t\t\t\t       UNSPEC_FR_SQRT_RECIP_APPROX_RES)))\n-               (set (match_dup 6)\n-                    (unspec:BI [(match_dup 8)]\n-\t\t\t       UNSPEC_FR_SQRT_RECIP_APPROX))\n-               (use (const_int 0))])\n-    ;; Step 2\n-    ;; H0 = 1/2 * y0 in f9\n-    (cond_exec (ne (match_dup 6) (const_int 0))\n-      (parallel [(set (match_dup 4)\n-                      (plus:XF (mult:XF (match_dup 3) (match_dup 7))\n-                               (match_dup 9)))\n-                 (use (const_int 1))]))\n-    ;; Step 3\n-    ;; S0 = a * y0 in f7\n-    (cond_exec (ne (match_dup 6) (const_int 0))\n-      (parallel [(set (match_dup 7)\n-                      (plus:XF (mult:XF (match_dup 8) (match_dup 7))\n-                               (match_dup 9)))\n-                 (use (const_int 1))]))\n-    ;; Step 4\n-    ;; d = 1/2 - S0 * H0 in f10\n-    (cond_exec (ne (match_dup 6) (const_int 0))\n-      (parallel [(set (match_dup 5)\n-                      (minus:XF (match_dup 3)\n-\t\t\t\t(mult:XF (match_dup 7) (match_dup 4))))\n-                 (use (const_int 1))]))\n-    ;; Step 5\n-    ;; d' = d + 1/2 * d in f8\n-    (cond_exec (ne (match_dup 6) (const_int 0))\n-       (parallel [(set (match_dup 3)\n-                       (plus:XF (mult:XF (match_dup 3) (match_dup 5))\n-                                (match_dup 5)))\n-                  (use (const_int 1))]))\n-    ;; Step 6\n-    ;; e = d + d * d' in f8\n-    (cond_exec (ne (match_dup 6) (const_int 0))\n-       (parallel [(set (match_dup 3)\n-                       (plus:XF (mult:XF (match_dup 5) (match_dup 3))\n-                                (match_dup 5)))\n-                  (use (const_int 1))]))\n-    ;; Step 7\n-    ;; S1 = S0 + e * S0 in f7\n-    (cond_exec (ne (match_dup 6) (const_int 0))\n-      (parallel [(set (match_dup 0)\n-\t\t      (float_truncate:SF\n-                        (plus:XF (mult:XF (match_dup 3) (match_dup 7))\n-                                 (match_dup 7))))\n-                 (use (const_int 1))]))\n-    ;; Step 8\n-    ;; H1 = H0 + e * H0 in f8\n-    (cond_exec (ne (match_dup 6) (const_int 0))\n-       (parallel [(set (match_dup 3)\n-                       (plus:XF (mult:XF (match_dup 3) (match_dup 4))\n-                                (match_dup 4)))\n-                  (use (const_int 1))]))\n-    ;; Step 9 \n-    ;; d1 = a - S1 * S1 in f9\n-    (cond_exec (ne (match_dup 6) (const_int 0))\n-       (parallel [(set (match_dup 4)\n-                       (minus:XF (match_dup 8)\n-\t\t\t\t (mult:XF (match_dup 7) (match_dup 7))))\n-                  (use (const_int 1))]))\n-    ;; Step 10\n-    ;; S = S1 + d1 * H1 in f7\n-    (cond_exec (ne (match_dup 6) (const_int 0))\n-       (parallel [(set (match_dup 0)\n-                       (float_truncate:SF\n-                         (plus:XF (mult:XF (match_dup 4) (match_dup 3))\n-                                  (match_dup 7))))\n-                  (use (const_int 0))]))]\n-{\n-  /* Generate 82-bit versions of the input and output operands.  */\n-  operands[7] = gen_rtx_REG (XFmode, REGNO (operands[0]));\n-  operands[8] = gen_rtx_REG (XFmode, REGNO (operands[1]));\n-  /* Generate required floating-point constants.  */\n-  operands[9] = CONST0_RTX (XFmode);\n-}\n-  [(set_attr \"predicable\" \"no\")])\n \f\n ;; ::::::::::::::::::::\n ;; ::\n@@ -3546,143 +3420,11 @@\n   if (TARGET_INLINE_SQRT == INL_MIN_LAT)\n     insn = gen_sqrtdf2_internal_lat (operands[0], operands[1]);\n   else\n-#else\n-  gcc_assert (TARGET_INLINE_SQRT != INL_MIN_LAT);\n #endif\n   insn = gen_sqrtdf2_internal_thr (operands[0], operands[1]);\n   emit_insn (insn);\n   DONE;\n })\n-\n-;; Latency-optimized square root.\n-;; FIXME: Implement.\n-\n-;; Throughput-optimized square root.\n-\n-(define_insn_and_split \"sqrtdf2_internal_thr\"\n-  [(set (match_operand:DF 0 \"fr_register_operand\" \"=&f\")\n-\t(sqrt:DF (match_operand:DF 1 \"fr_reg_or_fp01_operand\" \"fG\")))\n-   ;; Register r2 in optimization guide.\n-   (clobber (match_scratch:DI 2 \"=r\"))\n-   ;; Register f8 in optimization guide\n-   (clobber (match_scratch:XF 3 \"=&f\"))\n-   ;; Register f9 in optimization guide\n-   (clobber (match_scratch:XF 4 \"=&f\"))\n-   ;; Register f10 in optimization guide\n-   (clobber (match_scratch:XF 5 \"=&f\"))\n-   ;; Register p6 in optimization guide.\n-   (clobber (match_scratch:BI 6 \"=c\"))]\n-  \"TARGET_INLINE_SQRT == INL_MAX_THR\"\n-  \"#\"\n-  \"&& reload_completed\"\n-  [ ;; exponent of +1/2 in r2\n-    (set (match_dup 2) (const_int 65534))\n-    ;; +1/2 in f10\n-    (set (match_dup 5) \n-         (unspec:XF [(match_dup 2)] UNSPEC_SETF_EXP))\n-    ;; Step 1\n-    ;; y0 = 1/sqrt(a) in f7\n-    (parallel [(set (match_dup 7)\n-                    (div:XF (const_int 1)\n-\t\t\t    (unspec:XF [(match_dup 8)]\n-\t\t\t\t       UNSPEC_FR_SQRT_RECIP_APPROX_RES)))\n-               (set (match_dup 6)\n-                    (unspec:BI [(match_dup 8)]\n-\t\t\t       UNSPEC_FR_SQRT_RECIP_APPROX))\n-               (use (const_int 0))])\n-    ;; Step 2\n-    ;; H0 = 1/2 * y0 in f8\n-    (cond_exec (ne (match_dup 6) (const_int 0))\n-      (parallel [(set (match_dup 3)\n-                      (plus:XF (mult:XF (match_dup 5) (match_dup 7))\n-                               (match_dup 9)))\n-                 (use (const_int 1))]))\n-    ;; Step 3\n-    ;; G0 = a * y0 in f7\n-    (cond_exec (ne (match_dup 6) (const_int 0))\n-      (parallel [(set (match_dup 7)\n-                      (plus:XF (mult:XF (match_dup 8) (match_dup 7))\n-                               (match_dup 9)))\n-                 (use (const_int 1))]))\n-    ;; Step 4\n-    ;; r0 = 1/2 - G0 * H0 in f9\n-    (cond_exec (ne (match_dup 6) (const_int 0))\n-      (parallel [(set (match_dup 4)\n-                      (minus:XF (match_dup 5)\n-\t\t\t\t(mult:XF (match_dup 7) (match_dup 3))))\n-                 (use (const_int 1))]))\n-    ;; Step 5\n-    ;; H1 = H0 + r0 * H0 in f8\n-    (cond_exec (ne (match_dup 6) (const_int 0))\n-       (parallel [(set (match_dup 3)\n-                       (plus:XF (mult:XF (match_dup 4) (match_dup 3))\n-                                (match_dup 3)))\n-                  (use (const_int 1))]))\n-    ;; Step 6\n-    ;; G1 = G0 + r0 * G0 in f7\n-    (cond_exec (ne (match_dup 6) (const_int 0))\n-       (parallel [(set (match_dup 7)\n-                       (plus:XF (mult:XF (match_dup 4) (match_dup 7))\n-                                (match_dup 7)))\n-                  (use (const_int 1))]))\n-    ;; Step 7\n-    ;; r1 = 1/2 - G1 * H1 in f9\n-    (cond_exec (ne (match_dup 6) (const_int 0))\n-      (parallel [(set (match_dup 4)\n-                      (minus:XF (match_dup 5)\n-\t\t\t\t(mult:XF (match_dup 7) (match_dup 3))))\n-                 (use (const_int 1))]))\n-    ;; Step 8\n-    ;; H2 = H1 + r1 * H1 in f8\n-    (cond_exec (ne (match_dup 6) (const_int 0))\n-       (parallel [(set (match_dup 3)\n-                       (plus:XF (mult:XF (match_dup 4) (match_dup 3))\n-                                (match_dup 3)))\n-                  (use (const_int 1))]))\n-    ;; Step 9 \n-    ;; G2 = G1 + r1 * G1 in f7\n-    (cond_exec (ne (match_dup 6) (const_int 0))\n-       (parallel [(set (match_dup 7)\n-                       (plus:XF (mult:XF (match_dup 4) (match_dup 7))\n-                                (match_dup 7)))\n-                  (use (const_int 1))]))\n-    ;; Step 10\n-    ;; d2 = a - G2 * G2 in f9\n-    (cond_exec (ne (match_dup 6) (const_int 0))\n-       (parallel [(set (match_dup 4)\n-                       (minus:XF (match_dup 8)\n-\t\t\t\t (mult:XF (match_dup 7) (match_dup 7))))\n-                  (use (const_int 1))]))\n-    ;; Step 11\n-    ;; G3 = G2 + d2 * H2 in f7\n-    (cond_exec (ne (match_dup 6) (const_int 0))\n-       (parallel [(set (match_dup 7)\n-                       (plus:XF (mult:XF (match_dup 4) (match_dup 3))\n-                                (match_dup 7)))\n-                  (use (const_int 1))]))\n-    ;; Step 12\n-    ;; d3 = a - G3 * G3 in f9\n-    (cond_exec (ne (match_dup 6) (const_int 0))\n-       (parallel [(set (match_dup 4)\n-                       (minus:XF (match_dup 8)\n-\t\t\t\t (mult:XF (match_dup 7) (match_dup 7))))\n-                  (use (const_int 1))]))\n-    ;; Step 13\n-    ;; S = G3 + d3 * H2 in f7\n-    (cond_exec (ne (match_dup 6) (const_int 0))\n-       (parallel [(set (match_dup 0)\n-                       (float_truncate:DF\n-                         (plus:XF (mult:XF (match_dup 4) (match_dup 3))\n-                                  (match_dup 7))))\n-                  (use (const_int 0))]))]\n-{\n-  /* Generate 82-bit versions of the input and output operands.  */\n-  operands[7] = gen_rtx_REG (XFmode, REGNO (operands[0]));\n-  operands[8] = gen_rtx_REG (XFmode, REGNO (operands[1]));\n-  /* Generate required floating-point constants.  */\n-  operands[9] = CONST0_RTX (XFmode);\n-}\n-  [(set_attr \"predicable\" \"no\")])\n \f\n ;; ::::::::::::::::::::\n ;; ::\n@@ -4056,163 +3798,11 @@\n   \"TARGET_INLINE_SQRT\"\n {\n   rtx insn;\n-#if 0\n-  if (TARGET_INLINE_SQRT == INL_MIN_LAT)\n-    insn = gen_sqrtxf2_internal_lat (operands[0], operands[1]);\n-  else\n-#else\n-  gcc_assert (TARGET_INLINE_SQRT != INL_MIN_LAT);\n-#endif\n-  insn = gen_sqrtxf2_internal_thr (operands[0], operands[1]);\n+  insn = gen_sqrtxf2_internal (operands[0], operands[1]);\n   emit_insn (insn);\n   DONE;\n })\n \n-;; Latency-optimized square root.\n-;; FIXME: Implement.\n-\n-;; Throughput-optimized square root.\n-\n-(define_insn_and_split \"sqrtxf2_internal_thr\"\n-  [(set (match_operand:XF 0 \"fr_register_operand\" \"=&f\")\n-\t(sqrt:XF (match_operand:XF 1 \"fr_reg_or_fp01_operand\" \"fG\")))\n-   ;; Register r2 in optimization guide.\n-   (clobber (match_scratch:DI 2 \"=r\"))\n-   ;; Register f8 in optimization guide\n-   (clobber (match_scratch:XF 3 \"=&f\"))\n-   ;; Register f9 in optimization guide\n-   (clobber (match_scratch:XF 4 \"=&f\"))\n-   ;; Register f10 in optimization guide\n-   (clobber (match_scratch:XF 5 \"=&f\"))\n-   ;; Register f11 in optimization guide\n-   (clobber (match_scratch:XF 6 \"=&f\"))\n-   ;; Register p6 in optimization guide.\n-   (clobber (match_scratch:BI 7 \"=c\"))]\n-  \"TARGET_INLINE_SQRT == INL_MAX_THR\"\n-  \"#\"\n-  \"&& reload_completed\"\n-  [ ;; exponent of +1/2 in r2\n-    (set (match_dup 2) (const_int 65534))\n-    ;; +1/2 in f8.  The Intel manual mistakenly specifies f10.\n-    (set (match_dup 3) \n-         (unspec:XF [(match_dup 2)] UNSPEC_SETF_EXP))\n-    ;; Step 1\n-    ;; y0 = 1/sqrt(a) in f7\n-    (parallel [(set (match_dup 8)\n-                    (div:XF (const_int 1)\n-\t\t\t    (unspec:XF [(match_dup 9)]\n-\t\t\t\t       UNSPEC_FR_SQRT_RECIP_APPROX_RES)))\n-               (set (match_dup 7)\n-                    (unspec:BI [(match_dup 9)]\n-\t\t\t       UNSPEC_FR_SQRT_RECIP_APPROX))\n-               (use (const_int 0))])\n-    ;; Step 2\n-    ;; H0 = 1/2 * y0 in f9\n-    (cond_exec (ne (match_dup 7) (const_int 0))\n-      (parallel [(set (match_dup 4)\n-                      (plus:XF (mult:XF (match_dup 3) (match_dup 8))\n-                               (match_dup 10)))\n-                 (use (const_int 1))]))\n-    ;; Step 3\n-    ;; S0 = a * y0 in f7\n-    (cond_exec (ne (match_dup 7) (const_int 0))\n-      (parallel [(set (match_dup 8)\n-                      (plus:XF (mult:XF (match_dup 9) (match_dup 8))\n-                               (match_dup 10)))\n-                 (use (const_int 1))]))\n-    ;; Step 4\n-    ;; d0 = 1/2 - S0 * H0 in f10\n-    (cond_exec (ne (match_dup 7) (const_int 0))\n-      (parallel [(set (match_dup 5)\n-                      (minus:XF (match_dup 3)\n-\t\t\t\t(mult:XF (match_dup 8) (match_dup 4))))\n-                 (use (const_int 1))]))\n-    ;; Step 5\n-    ;; H1 = H0 + d0 * H0 in f9\n-    (cond_exec (ne (match_dup 7) (const_int 0))\n-       (parallel [(set (match_dup 4)\n-                       (plus:XF (mult:XF (match_dup 5) (match_dup 4))\n-                                (match_dup 4)))\n-                  (use (const_int 1))]))\n-    ;; Step 6\n-    ;; S1 = S0 + d0 * S0 in f7\n-    (cond_exec (ne (match_dup 7) (const_int 0))\n-       (parallel [(set (match_dup 8)\n-                       (plus:XF (mult:XF (match_dup 5) (match_dup 8))\n-                                (match_dup 8)))\n-                  (use (const_int 1))]))\n-    ;; Step 7\n-    ;; d1 = 1/2 - S1 * H1 in f10\n-    (cond_exec (ne (match_dup 7) (const_int 0))\n-      (parallel [(set (match_dup 5)\n-                      (minus:XF (match_dup 3)\n-\t\t\t\t(mult:XF (match_dup 8) (match_dup 4))))\n-                 (use (const_int 1))]))\n-    ;; Step 8\n-    ;; H2 = H1 + d1 * H1 in f9\n-    (cond_exec (ne (match_dup 7) (const_int 0))\n-       (parallel [(set (match_dup 4)\n-                       (plus:XF (mult:XF (match_dup 5) (match_dup 4))\n-                                (match_dup 4)))\n-                  (use (const_int 1))]))\n-    ;; Step 9 \n-    ;; S2 = S1 + d1 * S1 in f7\n-    (cond_exec (ne (match_dup 7) (const_int 0))\n-       (parallel [(set (match_dup 8)\n-                       (plus:XF (mult:XF (match_dup 5) (match_dup 8))\n-                                (match_dup 8)))\n-                  (use (const_int 1))]))\n-    ;; Step 10\n-    ;; d2 = 1/2 - S2 * H2 in f10\n-    (cond_exec (ne (match_dup 7) (const_int 0))\n-       (parallel [(set (match_dup 5)\n-                       (minus:XF (match_dup 3)\n-\t\t\t\t (mult:XF (match_dup 8) (match_dup 4))))\n-                  (use (const_int 1))]))\n-    ;; Step 11\n-    ;; e2 = a - S2 * S2 in f8\n-    (cond_exec (ne (match_dup 7) (const_int 0))\n-       (parallel [(set (match_dup 3)\n-                       (minus:XF (match_dup 9)\n-\t\t\t\t (mult:XF (match_dup 8) (match_dup 8))))\n-                  (use (const_int 1))]))\n-    ;; Step 12\n-    ;; S3 = S2 + e2 * H2 in f7\n-    (cond_exec (ne (match_dup 7) (const_int 0))\n-       (parallel [(set (match_dup 8)\n-                       (plus:XF (mult:XF (match_dup 3) (match_dup 4))\n-                                (match_dup 8)))\n-                  (use (const_int 1))]))\n-    ;; Step 13\n-    ;; H3 = H2 + d2 * H2 in f9\n-    (cond_exec (ne (match_dup 7) (const_int 0))\n-       (parallel [(set (match_dup 4)\n-                       (plus:XF (mult:XF (match_dup 5) (match_dup 4))\n-                                (match_dup 4)))\n-                  (use (const_int 1))]))\n-    ;; Step 14\n-    ;; e3 = a - S3 * S3 in f8\n-    (cond_exec (ne (match_dup 7) (const_int 0))\n-       (parallel [(set (match_dup 3)\n-                       (minus:XF (match_dup 9)\n-\t\t\t\t (mult:XF (match_dup 8) (match_dup 8))))\n-                  (use (const_int 1))]))\n-    ;; Step 15\n-    ;; S = S3 + e3 * H3 in f7\n-    (cond_exec (ne (match_dup 7) (const_int 0))\n-       (parallel [(set (match_dup 0)\n-                       (plus:XF (mult:XF (match_dup 3) (match_dup 4))\n-                                (match_dup 8)))\n-                  (use (const_int 0))]))]\n-{\n-  /* Generate 82-bit versions of the input and output operands.  */\n-  operands[8] = gen_rtx_REG (XFmode, REGNO (operands[0]));\n-  operands[9] = gen_rtx_REG (XFmode, REGNO (operands[1]));\n-  /* Generate required floating-point constants.  */\n-  operands[10] = CONST0_RTX (XFmode);\n-}\n-  [(set_attr \"predicable\" \"no\")])\n-\n ;; ??? frcpa works like cmp.foo.unc.\n \n (define_insn \"*recip_approx\""}]}