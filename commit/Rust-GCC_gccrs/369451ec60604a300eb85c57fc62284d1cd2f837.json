{"sha": "369451ec60604a300eb85c57fc62284d1cd2f837", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzY5NDUxZWM2MDYwNGEzMDBlYjg1YzU3ZmM2MjI4NGQxY2QyZjgzNw==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2010-05-06T08:39:32Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2010-05-06T08:39:32Z"}, "message": "cgraphbuild.c (record_reference_ctx): Add varpool_node.\n\n\t* cgraphbuild.c (record_reference_ctx): Add varpool_node.\n\t(record_reference, mark_address, mark_load, mark_store): Record\n\treferences.\n\t(record_references_in_initializer): Update call of record_references.\n\t(rebuild_cgraph_edges): Remove all references before rebuiding.\n\t* cgraph.c (cgraph_create_node): Clear ref list.\n\t(cgraph_remove_node): Remove references.\n\t(dump_cgraph_node): Dump references.\n\t(cgraph_clone_node): Clone references.\n\t* cgraph.h: Include ipa-ref.h and ipa-ref-inline.h\n\t(struct cgraph_node, varpool_node): Add ref_lst.\n\t* ipa-ref.c: New file.\n\t* ipa-ref.h: New file.\n\t* ipa-ref-inline.h: New file.\n\t* lto-cgraph.c (output_varpool): Take cgrag node set argument.\n\t(referenced_from_other_partition_p): New function.\n\t(lto_output_varpool_node): Take set arugment; call\n\treferenced_from_other_partition.\n\t(lto_output_ref): New.\n\t(add_references): New.\n\t(output_refs): New.\n\t(output_cgraph): Compute boundary based on references;\n\toutput refs.\n\t(output_varpool): Accept cgraph_node_set argument.\n\t(input_ref): New.\n\t(input_refs): New.\n\t(input_cgraph): Call input_refs.\n\t* lto-section-in.c (lto_section_name): Add refs.\n\t* Makefile.in: (cgraph.h): Include ipa-ref.h and ipa-ref-inline.h\n\t(ipa-ref.o): New file.\n\t* varpool.c (varpool_node): Clear ipa ref list.\n\t(varpool_remove_node): Remove references.\n\t(dump_varpool_node): Dump references.\n\t(varpool_assemble_decl): Only compile finalized ones.\n\t(varpool_extra_name_alias): Initialize ref list.\n\t* lto-streamer.c (lto-get_section_name): Add .refs section.\n\t* lto-streamer.h (lto_section_type): Add LTO_section_refs.\n\t(referenced_from_other_partition_p): Declared.\n\nFrom-SVN: r159097", "tree": {"sha": "e48d1955485a825be1e84a6a3218ce8974043c2a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e48d1955485a825be1e84a6a3218ce8974043c2a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/369451ec60604a300eb85c57fc62284d1cd2f837", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/369451ec60604a300eb85c57fc62284d1cd2f837", "html_url": "https://github.com/Rust-GCC/gccrs/commit/369451ec60604a300eb85c57fc62284d1cd2f837", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/369451ec60604a300eb85c57fc62284d1cd2f837/comments", "author": null, "committer": null, "parents": [{"sha": "03a904b5a683713f848ef028aef63e0cfd16c4eb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/03a904b5a683713f848ef028aef63e0cfd16c4eb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/03a904b5a683713f848ef028aef63e0cfd16c4eb"}], "stats": {"total": 840, "additions": 807, "deletions": 33}, "files": [{"sha": "3994866d007e2d0c656e3d6ce71c817f4f119d22", "filename": "gcc/ChangeLog", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/369451ec60604a300eb85c57fc62284d1cd2f837/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/369451ec60604a300eb85c57fc62284d1cd2f837/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=369451ec60604a300eb85c57fc62284d1cd2f837", "patch": "@@ -1,3 +1,44 @@\n+2010-05-06  Jan Hubicka  <jh@suse.cz>\n+\n+\t* cgraphbuild.c (record_reference_ctx): Add varpool_node.\n+\t(record_reference, mark_address, mark_load, mark_store): Record\n+\treferences.\n+\t(record_references_in_initializer): Update call of record_references.\n+\t(rebuild_cgraph_edges): Remove all references before rebuiding.\n+\t* cgraph.c (cgraph_create_node): Clear ref list.\n+\t(cgraph_remove_node): Remove references.\n+\t(dump_cgraph_node): Dump references.\n+\t(cgraph_clone_node): Clone references.\n+\t* cgraph.h: Include ipa-ref.h and ipa-ref-inline.h\n+\t(struct cgraph_node, varpool_node): Add ref_lst.\n+\t* ipa-ref.c: New file.\n+\t* ipa-ref.h: New file.\n+\t* ipa-ref-inline.h: New file.\n+\t* lto-cgraph.c (output_varpool): Take cgrag node set argument.\n+\t(referenced_from_other_partition_p): New function.\n+\t(lto_output_varpool_node): Take set arugment; call\n+\treferenced_from_other_partition.\n+\t(lto_output_ref): New.\n+\t(add_references): New.\n+\t(output_refs): New.\n+\t(output_cgraph): Compute boundary based on references;\n+\toutput refs.\n+\t(output_varpool): Accept cgraph_node_set argument.\n+\t(input_ref): New.\n+\t(input_refs): New.\n+\t(input_cgraph): Call input_refs.\n+\t* lto-section-in.c (lto_section_name): Add refs.\n+\t* Makefile.in: (cgraph.h): Include ipa-ref.h and ipa-ref-inline.h\n+\t(ipa-ref.o): New file.\n+\t* varpool.c (varpool_node): Clear ipa ref list.\n+\t(varpool_remove_node): Remove references.\n+\t(dump_varpool_node): Dump references.\n+\t(varpool_assemble_decl): Only compile finalized ones.\n+\t(varpool_extra_name_alias): Initialize ref list.\n+\t* lto-streamer.c (lto-get_section_name): Add .refs section.\n+\t* lto-streamer.h (lto_section_type): Add LTO_section_refs.\n+\t(referenced_from_other_partition_p): Declared.\n+\n 2010-05-06  Ira Rosen  <irar@il.ibm.com>\n \n \tPR tree-optimization/43901"}, {"sha": "f19def735197944445b1c0241ae2bf1015cc0751", "filename": "gcc/Makefile.in", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/369451ec60604a300eb85c57fc62284d1cd2f837/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/369451ec60604a300eb85c57fc62284d1cd2f837/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=369451ec60604a300eb85c57fc62284d1cd2f837", "patch": "@@ -904,7 +904,7 @@ CFGLOOP_H = cfgloop.h $(BASIC_BLOCK_H) $(RTL_H) vecprim.h double-int.h\n IPA_UTILS_H = ipa-utils.h $(TREE_H) $(CGRAPH_H)\n IPA_REFERENCE_H = ipa-reference.h $(BITMAP_H) $(TREE_H)\n IPA_TYPE_ESCAPE_H = ipa-type-escape.h $(TREE_H)\n-CGRAPH_H = cgraph.h $(TREE_H) $(BASIC_BLOCK_H) cif-code.def\n+CGRAPH_H = cgraph.h $(TREE_H) $(BASIC_BLOCK_H) cif-code.def ipa-ref.h ipa-ref-inline.h\n DF_H = df.h $(BITMAP_H) $(BASIC_BLOCK_H) alloc-pool.h $(TIMEVAR_H)\n RESOURCE_H = resource.h hard-reg-set.h $(DF_H)\n DDG_H = ddg.h sbitmap.h $(DF_H)\n@@ -1425,6 +1425,7 @@ OBJS-archive = \\\n \tipa-prop.o \\\n \tipa-pure-const.o \\\n \tipa-reference.o \\\n+\tipa-ref.o \\\n \tipa-struct-reorg.o \\\n \tipa-type-escape.o \\\n \tipa-utils.o \\\n@@ -2902,6 +2903,9 @@ ipa-prop.o : ipa-prop.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n    langhooks.h $(GGC_H) $(TARGET_H) $(CGRAPH_H) $(IPA_PROP_H) $(DIAGNOSTIC_H) \\\n    $(TREE_FLOW_H) $(TM_H) $(TREE_PASS_H) $(FLAGS_H) $(TREE_H) \\\n    $(TREE_INLINE_H) $(TIMEVAR_H)\n+ipa-ref.o : ipa-ref.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n+   langhooks.h $(GGC_H) $(TARGET_H) $(CGRAPH_H)  $(TREE_H) $(TARGET_H) \\\n+   $(TREE_FLOW_H) $(TM_H) $(TREE_PASS_H) $(FLAGS_H) $(TREE_H) $(GGC_H) \n ipa-cp.o : ipa-cp.c $(CONFIG_H) $(SYSTEM_H) coretypes.h  \\\n    $(TREE_H) $(TARGET_H) $(CGRAPH_H) $(IPA_PROP_H) $(TREE_FLOW_H) \\\n    $(TREE_PASS_H) $(FLAGS_H) $(TIMEVAR_H) $(DIAGNOSTIC_H) $(TREE_DUMP_H) \\\n@@ -3584,7 +3588,7 @@ GTFILES = $(CPP_ID_DATA_H) $(srcdir)/input.h $(srcdir)/coretypes.h \\\n   $(srcdir)/real.h $(srcdir)/function.h $(srcdir)/insn-addr.h $(srcdir)/hwint.h \\\n   $(srcdir)/fixed-value.h \\\n   $(srcdir)/ipa-reference.h $(srcdir)/output.h $(srcdir)/cfgloop.h \\\n-  $(srcdir)/cselib.h $(srcdir)/basic-block.h  $(srcdir)/cgraph.h \\\n+  $(srcdir)/cselib.h $(srcdir)/basic-block.h  $(srcdir)/ipa-ref.h $(srcdir)/cgraph.h \\\n   $(srcdir)/reload.h $(srcdir)/caller-save.c \\\n   $(srcdir)/alias.c $(srcdir)/bitmap.c $(srcdir)/cselib.c $(srcdir)/cgraph.c \\\n   $(srcdir)/ipa-prop.c $(srcdir)/ipa-cp.c $(srcdir)/ipa-inline.c $(srcdir)/matrix-reorg.c \\"}, {"sha": "64a9c6559ccba7b8ceda0dbc6f063c1c8d1cb8d9", "filename": "gcc/cgraph.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/369451ec60604a300eb85c57fc62284d1cd2f837/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/369451ec60604a300eb85c57fc62284d1cd2f837/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=369451ec60604a300eb85c57fc62284d1cd2f837", "patch": "@@ -463,6 +463,7 @@ cgraph_create_node (void)\n   node->previous = NULL;\n   node->global.estimated_growth = INT_MIN;\n   node->frequency = NODE_FREQUENCY_NORMAL;\n+  ipa_empty_ref_list (&node->ref_list);\n   cgraph_nodes = node;\n   cgraph_n_nodes++;\n   return node;\n@@ -1412,6 +1413,8 @@ cgraph_remove_node (struct cgraph_node *node)\n   cgraph_call_node_removal_hooks (node);\n   cgraph_node_remove_callers (node);\n   cgraph_node_remove_callees (node);\n+  ipa_remove_all_references (&node->ref_list);\n+  ipa_remove_all_refering (&node->ref_list);\n   VEC_free (ipa_opt_pass, heap,\n             node->ipa_transforms_to_apply);\n \n@@ -1853,6 +1856,10 @@ dump_cgraph_node (FILE *f, struct cgraph_node *node)\n \tfprintf(f, \"(can throw external) \");\n     }\n   fprintf (f, \"\\n\");\n+  fprintf (f, \"  References: \");\n+  ipa_dump_references (f, &node->ref_list);\n+  fprintf (f, \"  Refering this function: \");\n+  ipa_dump_refering (f, &node->ref_list);\n \n   for (edge = node->indirect_calls; edge; edge = edge->next_callee)\n     indirect_calls_count++;\n@@ -2081,6 +2088,7 @@ cgraph_clone_node (struct cgraph_node *n, gcov_type count, int freq,\n   for (e = n->indirect_calls; e; e = e->next_callee)\n     cgraph_clone_edge (e, new_node, e->call_stmt, e->lto_stmt_uid,\n \t\t       count_scale, freq, loop_nest, update_original);\n+  ipa_clone_references (new_node, NULL, &n->ref_list);\n \n   new_node->next_sibling_clone = n->clones;\n   if (n->clones)"}, {"sha": "93488c3a5d2d2e22cb761182858b072c510fa2d6", "filename": "gcc/cgraph.h", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/369451ec60604a300eb85c57fc62284d1cd2f837/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/369451ec60604a300eb85c57fc62284d1cd2f837/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=369451ec60604a300eb85c57fc62284d1cd2f837", "patch": "@@ -23,6 +23,7 @@ along with GCC; see the file COPYING3.  If not see\n #define GCC_CGRAPH_H\n #include \"tree.h\"\n #include \"basic-block.h\"\n+#include \"ipa-ref.h\"\n \n enum availability\n {\n@@ -224,6 +225,7 @@ struct GTY((chain_next (\"%h.next\"), chain_prev (\"%h.previous\"))) cgraph_node {\n      per-function in order to allow IPA passes to introduce new functions.  */\n   VEC(ipa_opt_pass,heap) * GTY((skip)) ipa_transforms_to_apply;\n \n+  struct ipa_ref_list ref_list;\n   struct cgraph_local_info local;\n   struct cgraph_global_info global;\n   struct cgraph_rtl_info rtl;\n@@ -427,7 +429,7 @@ DEF_VEC_ALLOC_P(cgraph_edge_p,heap);\n /* The varpool data structure.\n    Each static variable decl has assigned varpool_node.  */\n \n-struct GTY((chain_next (\"%h.next\"))) varpool_node {\n+struct GTY((chain_next (\"%h.next\"), chain_prev (\"%h.prev\"))) varpool_node {\n   tree decl;\n   /* Pointer to the next function in varpool_nodes.  */\n   struct varpool_node *next, *prev;\n@@ -436,6 +438,7 @@ struct GTY((chain_next (\"%h.next\"))) varpool_node {\n   /* For normal nodes a pointer to the first extra name alias.  For alias\n      nodes a pointer to the normal node.  */\n   struct varpool_node *extra_name;\n+  struct ipa_ref_list ref_list;\n   /* Ordering of all cgraph nodes.  */\n   int order;\n \n@@ -864,4 +867,6 @@ cgraph_can_remove_if_no_direct_calls_p (struct cgraph_node *node)\n /* Constant pool accessor function.  */\n htab_t constant_pool_htab (void);\n \n+#include \"ipa-ref-inline.h\"\n+\n #endif  /* GCC_CGRAPH_H  */"}, {"sha": "ec190c7211c75e0a803117b214059f965ef59082", "filename": "gcc/cgraphbuild.c", "status": "modified", "additions": 38, "deletions": 5, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/369451ec60604a300eb85c57fc62284d1cd2f837/gcc%2Fcgraphbuild.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/369451ec60604a300eb85c57fc62284d1cd2f837/gcc%2Fcgraphbuild.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphbuild.c?ref=369451ec60604a300eb85c57fc62284d1cd2f837", "patch": "@@ -37,6 +37,7 @@ along with GCC; see the file COPYING3.  If not see\n struct record_reference_ctx\n {\n   bool only_vars;\n+  struct varpool_node *varpool_node;\n };\n \n /* Walk tree and record all calls and references to functions/variables.\n@@ -63,15 +64,26 @@ record_reference (tree *tp, int *walk_subtrees, void *data)\n       /* Record dereferences to the functions.  This makes the\n \t functions reachable unconditionally.  */\n       decl = get_base_var (*tp);\n-      if (TREE_CODE (decl) == FUNCTION_DECL && !ctx->only_vars)\n-\tcgraph_mark_address_taken_node (cgraph_node (decl));\n+      if (TREE_CODE (decl) == FUNCTION_DECL)\n+\t{\n+\t  if (!ctx->only_vars)\n+\t  cgraph_mark_address_taken_node (cgraph_node (decl));\n+\t  ipa_record_reference (NULL, ctx->varpool_node,\n+\t\t\t        cgraph_node (decl), NULL,\n+\t\t\t        IPA_REF_ADDR, NULL);\n+\t}\n \n       if (TREE_CODE (decl) == VAR_DECL)\n \t{\n-\t  gcc_assert (TREE_STATIC (decl) || DECL_EXTERNAL (decl));\n+\t  struct varpool_node *vnode = varpool_node (decl);\n \t  if (lang_hooks.callgraph.analyze_expr)\n \t    lang_hooks.callgraph.analyze_expr (&decl, walk_subtrees);\n-\t  varpool_mark_needed_node (varpool_node (decl));\n+\t  varpool_mark_needed_node (vnode);\n+\t  if (vnode->alias && vnode->extra_name)\n+\t    vnode = vnode->extra_name;\n+\t  ipa_record_reference (NULL, ctx->varpool_node,\n+\t\t\t\tNULL, vnode,\n+\t\t\t\tIPA_REF_ADDR, NULL);\n \t}\n       *walk_subtrees = 0;\n       break;\n@@ -148,6 +160,9 @@ mark_address (gimple stmt ATTRIBUTE_UNUSED, tree addr,\n     {\n       struct cgraph_node *node = cgraph_node (addr);\n       cgraph_mark_address_taken_node (node);\n+      ipa_record_reference ((struct cgraph_node *)data, NULL,\n+\t\t\t    node, NULL,\n+\t\t\t    IPA_REF_ADDR, stmt);\n     }\n   else\n     {\n@@ -161,6 +176,11 @@ mark_address (gimple stmt ATTRIBUTE_UNUSED, tree addr,\n \t  if (lang_hooks.callgraph.analyze_expr)\n \t    lang_hooks.callgraph.analyze_expr (&addr, &walk_subtrees);\n \t  varpool_mark_needed_node (vnode);\n+\t  if (vnode->alias && vnode->extra_name)\n+\t    vnode = vnode->extra_name;\n+\t  ipa_record_reference ((struct cgraph_node *)data, NULL,\n+\t\t\t\tNULL, vnode,\n+\t\t\t\tIPA_REF_ADDR, stmt);\n \t}\n     }\n \n@@ -183,6 +203,11 @@ mark_load (gimple stmt ATTRIBUTE_UNUSED, tree t,\n       if (lang_hooks.callgraph.analyze_expr)\n \tlang_hooks.callgraph.analyze_expr (&t, &walk_subtrees);\n       varpool_mark_needed_node (vnode);\n+      if (vnode->alias && vnode->extra_name)\n+\tvnode = vnode->extra_name;\n+      ipa_record_reference ((struct cgraph_node *)data, NULL,\n+\t\t\t    NULL, vnode,\n+\t\t\t    IPA_REF_LOAD, stmt);\n     }\n   return false;\n }\n@@ -203,6 +228,11 @@ mark_store (gimple stmt ATTRIBUTE_UNUSED, tree t,\n       if (lang_hooks.callgraph.analyze_expr)\n \tlang_hooks.callgraph.analyze_expr (&t, &walk_subtrees);\n       varpool_mark_needed_node (vnode);\n+      if (vnode->alias && vnode->extra_name)\n+\tvnode = vnode->extra_name;\n+      ipa_record_reference ((struct cgraph_node *)data, NULL,\n+\t\t\t    NULL, vnode,\n+\t\t\t    IPA_REF_STORE, NULL);\n      }\n   return false;\n }\n@@ -299,8 +329,10 @@ void\n record_references_in_initializer (tree decl, bool only_vars)\n {\n   struct pointer_set_t *visited_nodes = pointer_set_create ();\n-  struct record_reference_ctx ctx = {false};\n+  struct varpool_node *node = varpool_node (decl);\n+  struct record_reference_ctx ctx = {false, NULL};\n \n+  ctx.varpool_node = node;\n   ctx.only_vars = only_vars;\n   walk_tree (&DECL_INITIAL (decl), record_reference,\n              &ctx, visited_nodes);\n@@ -318,6 +350,7 @@ rebuild_cgraph_edges (void)\n   gimple_stmt_iterator gsi;\n \n   cgraph_node_remove_callees (node);\n+  ipa_remove_all_references (&node->ref_list);\n \n   node->count = ENTRY_BLOCK_PTR->count;\n "}, {"sha": "6ca9ba08f30df773bf6e3d2e12db7da135b2bd8c", "filename": "gcc/ipa-ref-inline.h", "status": "modified", "additions": 119, "deletions": 0, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/369451ec60604a300eb85c57fc62284d1cd2f837/gcc%2Fipa-ref-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/369451ec60604a300eb85c57fc62284d1cd2f837/gcc%2Fipa-ref-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-ref-inline.h?ref=369451ec60604a300eb85c57fc62284d1cd2f837", "patch": "@@ -0,0 +1,119 @@\n+/* IPA reference lists.\n+   Copyright (C) 2010\n+   Free Software Foundation, Inc.\n+   Contributed by Jan Hubicka\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+/* Return callgraph node REF is refering.  */\n+static inline struct cgraph_node *\n+ipa_ref_node (struct ipa_ref *ref)\n+{\n+  gcc_assert (ref->refered_type == IPA_REF_CGRAPH);\n+  return ref->refered.cgraph_node;\n+}\n+\n+/* Return varpool node REF is refering.  */\n+\n+static inline struct varpool_node *\n+ipa_ref_varpool_node (struct ipa_ref *ref)\n+{\n+  gcc_assert (ref->refered_type == IPA_REF_VARPOOL);\n+  return ref->refered.varpool_node;\n+}\n+\n+/* Return cgraph node REF is in.  */\n+\n+static inline struct cgraph_node *\n+ipa_ref_refering_node (struct ipa_ref *ref)\n+{\n+  gcc_assert (ref->refering_type == IPA_REF_CGRAPH);\n+  return ref->refering.cgraph_node;\n+}\n+\n+/* Return varpool node REF is in.  */\n+\n+static inline struct varpool_node *\n+ipa_ref_refering_varpool_node (struct ipa_ref *ref)\n+{\n+  gcc_assert (ref->refering_type == IPA_REF_VARPOOL);\n+  return ref->refering.varpool_node;\n+}\n+\n+/* Return reference list REF is in.  */\n+\n+static inline struct ipa_ref_list *\n+ipa_ref_refering_ref_list (struct ipa_ref *ref)\n+{\n+  if (ref->refering_type == IPA_REF_CGRAPH)\n+    return &ipa_ref_refering_node (ref)->ref_list;\n+  else\n+    return &ipa_ref_refering_varpool_node (ref)->ref_list;\n+}\n+\n+/* Return reference list REF is in.  */\n+\n+static inline struct ipa_ref_list *\n+ipa_ref_refered_ref_list (struct ipa_ref *ref)\n+{\n+  if (ref->refered_type == IPA_REF_CGRAPH)\n+    return &ipa_ref_node (ref)->ref_list;\n+  else\n+    return &ipa_ref_varpool_node (ref)->ref_list;\n+}\n+\n+/* Return first reference in LIST or NULL if empty.  */\n+\n+static inline struct ipa_ref *\n+ipa_ref_list_first_reference (struct ipa_ref_list *list)\n+{\n+  if (!VEC_length (ipa_ref_t, list->references))\n+    return NULL;\n+  return VEC_index (ipa_ref_t, list->references, 0);\n+}\n+\n+/* Return first refering ref in LIST or NULL if empty.  */\n+\n+static inline struct ipa_ref *\n+ipa_ref_list_first_refering (struct ipa_ref_list *list)\n+{\n+  if (!VEC_length (ipa_ref_ptr, list->refering))\n+    return NULL;\n+  return VEC_index (ipa_ref_ptr, list->refering, 0);\n+}\n+\n+/* Clear reference list.  */\n+\n+static inline void\n+ipa_empty_ref_list (struct ipa_ref_list *list)\n+{\n+  list->refering = NULL;\n+  list->references = NULL;\n+}\n+\n+/* Clear reference list.  */\n+\n+static inline unsigned int\n+ipa_ref_list_nreferences (struct ipa_ref_list *list)\n+{\n+  return VEC_length (ipa_ref_t, list->references);\n+}\n+\n+#define ipa_ref_list_reference_iterate(L,I,P) \\\n+   VEC_iterate(ipa_ref_t, (L)->references, (I), (P))\n+#define ipa_ref_list_refering_iterate(L,I,P) \\\n+   VEC_iterate(ipa_ref_ptr, (L)->refering, (I), (P))"}, {"sha": "dd6b009ce58bf14fa7369d6aa61550a26b1c9423", "filename": "gcc/ipa-ref.c", "status": "modified", "additions": 235, "deletions": 0, "changes": 235, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/369451ec60604a300eb85c57fc62284d1cd2f837/gcc%2Fipa-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/369451ec60604a300eb85c57fc62284d1cd2f837/gcc%2Fipa-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-ref.c?ref=369451ec60604a300eb85c57fc62284d1cd2f837", "patch": "@@ -0,0 +1,235 @@\n+/* Interprocedural reference lists.\n+   Copyright (C) 2010\n+   Free Software Foundation, Inc.\n+   Contributed by Jan Hubicka\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tree.h\"\n+#include \"ggc.h\"\n+#include \"target.h\"\n+#include \"cgraph.h\"\n+\n+static const char *ipa_ref_use_name[] = {\"read\",\"write\",\"addr\"};\n+\n+/* Return ipa reference from REFERING_NODE or REFERING_VARPOOL_NODE\n+   to REFERED_NODE or REFERED_VARPOOL_NODE. USE_TYPE specify type\n+   of the use and STMT the statement (if it exists).  */\n+\n+struct ipa_ref *\n+ipa_record_reference (struct cgraph_node *refering_node,\n+\t\t      struct varpool_node *refering_varpool_node,\n+\t\t      struct cgraph_node *refered_node,\n+\t\t      struct varpool_node *refered_varpool_node,\n+\t\t      enum ipa_ref_use use_type, gimple stmt)\n+{\n+  struct ipa_ref *ref;\n+  struct ipa_ref_list *list, *list2;\n+  VEC(ipa_ref_t,gc) *old_references;\n+  gcc_assert ((!refering_node) ^ (!refering_varpool_node));\n+  gcc_assert ((!refered_node) ^ (!refered_varpool_node));\n+  gcc_assert (!stmt || refering_node);\n+\n+  list = (refering_node ? &refering_node->ref_list\n+\t  : &refering_varpool_node->ref_list);\n+  old_references = list->references;\n+  VEC_safe_grow (ipa_ref_t, gc, list->references,\n+\t\t VEC_length (ipa_ref_t, list->references) + 1);\n+  ref = VEC_last (ipa_ref_t, list->references);\n+\n+  list2 = (refered_node ? &refered_node->ref_list\n+\t   : &refered_varpool_node->ref_list);\n+  VEC_safe_push (ipa_ref_ptr, heap, list2->refering, ref);\n+  ref->refered_index = VEC_length (ipa_ref_ptr, list2->refering) - 1;\n+  if (refering_node)\n+    {\n+      ref->refering.cgraph_node = refering_node;\n+      ref->refering_type = IPA_REF_CGRAPH;\n+    }\n+  else\n+    {\n+      ref->refering.varpool_node = refering_varpool_node;\n+      ref->refering_type = IPA_REF_VARPOOL;\n+      gcc_assert (use_type == IPA_REF_ADDR);\n+    }\n+  if (refered_node)\n+    {\n+      ref->refered.cgraph_node = refered_node;\n+      ref->refered_type = IPA_REF_CGRAPH;\n+      gcc_assert (use_type == IPA_REF_ADDR);\n+    }\n+  else\n+    {\n+      varpool_mark_needed_node (refered_varpool_node);\n+      ref->refered.varpool_node = refered_varpool_node;\n+      ref->refered_type = IPA_REF_VARPOOL;\n+    }\n+  ref->stmt = stmt;\n+  ref->use = use_type;\n+\n+  /* If vector was moved in memory, update pointers.  */\n+  if (old_references != list->references)\n+    {\n+      int i;\n+      for (i = 0; ipa_ref_list_reference_iterate (list, i, ref); i++)\n+\tVEC_replace (ipa_ref_ptr,\n+\t\t     ipa_ref_refered_ref_list (ref)->refering,\n+\t\t     ref->refered_index, ref);\n+    }\n+  return ref;\n+}\n+\n+/* Remove reference REF.  */\n+\n+void\n+ipa_remove_reference (struct ipa_ref *ref)\n+{\n+  struct ipa_ref_list *list = ipa_ref_refered_ref_list (ref);\n+  struct ipa_ref_list *list2 = ipa_ref_refering_ref_list (ref);\n+  VEC(ipa_ref_t,gc) *old_references = list2->references;\n+  struct ipa_ref *last;\n+\n+  gcc_assert (VEC_index (ipa_ref_ptr, list->refering, ref->refered_index) == ref);\n+  last = VEC_last (ipa_ref_ptr, list->refering);\n+  if (ref != last)\n+    {\n+      VEC_replace (ipa_ref_ptr, list->refering,\n+\t\t   ref->refered_index,\n+\t\t   VEC_last (ipa_ref_ptr, list->refering));\n+      VEC_index (ipa_ref_ptr, list->refering,\n+\t\t ref->refered_index)->refered_index = ref->refered_index;\n+    }\n+  VEC_pop (ipa_ref_ptr, list->refering);\n+\n+  last = VEC_last (ipa_ref_t, list2->references);\n+  if (ref != last)\n+    {\n+      *ref = *last;\n+      VEC_replace (ipa_ref_ptr,\n+\t\t   ipa_ref_refered_ref_list (ref)->refering,\n+\t\t   ref->refered_index, ref);\n+    }\n+  VEC_pop (ipa_ref_t, list2->references);\n+  gcc_assert (list2->references == old_references);\n+}\n+\n+/* Remove all references in ref list LIST.  */\n+\n+void\n+ipa_remove_all_references (struct ipa_ref_list *list)\n+{\n+  while (VEC_length (ipa_ref_t, list->references))\n+    ipa_remove_reference (VEC_last (ipa_ref_t, list->references));\n+  VEC_free (ipa_ref_t, gc, list->references);\n+  list->references = NULL;\n+}\n+\n+/* Remove all references in ref list LIST.  */\n+\n+void\n+ipa_remove_all_refering (struct ipa_ref_list *list)\n+{\n+  while (VEC_length (ipa_ref_ptr, list->refering))\n+    ipa_remove_reference (VEC_last (ipa_ref_ptr, list->refering));\n+  VEC_free (ipa_ref_ptr, heap, list->refering);\n+  list->refering = NULL;\n+}\n+\n+/* Dump references in LIST to FILE.  */\n+\n+void\n+ipa_dump_references (FILE * file, struct ipa_ref_list *list)\n+{\n+  struct ipa_ref *ref;\n+  int i;\n+  for (i = 0; ipa_ref_list_reference_iterate (list, i, ref); i++)\n+    {\n+      if (ref->refered_type == IPA_REF_CGRAPH)\n+\t{\n+\t  fprintf (file, \" fn:%s/%i (%s)\", cgraph_node_name (ipa_ref_node (ref)),\n+\t\t   ipa_ref_node (ref)->uid,\n+\t\t   ipa_ref_use_name [ref->use]);\n+\t}\n+      else\n+\tfprintf (file, \" var:%s (%s)\",\n+\t\t varpool_node_name (ipa_ref_varpool_node (ref)),\n+\t\t ipa_ref_use_name [ref->use]);\n+    }\n+  fprintf (file, \"\\n\");\n+}\n+\n+/* Dump refering in LIST to FILE.  */\n+\n+void\n+ipa_dump_refering (FILE * file, struct ipa_ref_list *list)\n+{\n+  struct ipa_ref *ref;\n+  int i;\n+  for (i = 0; ipa_ref_list_refering_iterate (list, i, ref); i++)\n+    {\n+      if (ref->refering_type == IPA_REF_CGRAPH)\n+\tfprintf (file, \" fn:%s/%i (%s)\",\n+\t\t cgraph_node_name (ipa_ref_refering_node (ref)),\n+\t\t ipa_ref_refering_node (ref)->uid,\n+\t\t ipa_ref_use_name [ref->use]);\n+      else\n+\tfprintf (file, \" var:%s (%s)\",\n+\t\t varpool_node_name (ipa_ref_refering_varpool_node (ref)),\n+\t\t ipa_ref_use_name [ref->use]);\n+    }\n+  fprintf (file, \"\\n\");\n+}\n+\n+/* Clone all references from SRC to DEST_NODE or DEST_VARPOL_NODE.  */\n+\n+void\n+ipa_clone_references (struct cgraph_node *dest_node,\n+\t\t      struct varpool_node *dest_varpool_node,\n+\t\t      struct ipa_ref_list *src)\n+{\n+  struct ipa_ref *ref;\n+  int i;\n+  for (i = 0; ipa_ref_list_reference_iterate (src, i, ref); i++)\n+    ipa_record_reference (dest_node, dest_varpool_node,\n+\t\t\t  ref->refered_type == IPA_REF_CGRAPH\n+\t\t\t  ? ipa_ref_node (ref) : NULL,\n+\t\t\t  ref->refered_type == IPA_REF_VARPOOL\n+\t\t\t  ? ipa_ref_varpool_node (ref) : NULL,\n+\t\t\t  ref->use, ref->stmt);\n+}\n+\n+/* Clone all refering from SRC to DEST_NODE or DEST_VARPOL_NODE.  */\n+\n+void\n+ipa_clone_refering (struct cgraph_node *dest_node,\n+\t\t    struct varpool_node *dest_varpool_node,\n+\t\t    struct ipa_ref_list *src)\n+{\n+  struct ipa_ref *ref;\n+  int i;\n+  for (i = 0; ipa_ref_list_refering_iterate (src, i, ref); i++)\n+    ipa_record_reference (\n+\t\t\t  ref->refering_type == IPA_REF_CGRAPH\n+\t\t\t  ? ipa_ref_refering_node (ref) : NULL,\n+\t\t\t  ref->refering_type == IPA_REF_VARPOOL\n+\t\t\t  ? ipa_ref_refering_varpool_node (ref) : NULL,\n+\t\t\t  dest_node, dest_varpool_node,\n+\t\t\t  ref->use, ref->stmt);\n+}"}, {"sha": "98912db185135701e98bba7fbc5ddf7b88b12e52", "filename": "gcc/ipa-ref.h", "status": "modified", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/369451ec60604a300eb85c57fc62284d1cd2f837/gcc%2Fipa-ref.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/369451ec60604a300eb85c57fc62284d1cd2f837/gcc%2Fipa-ref.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-ref.h?ref=369451ec60604a300eb85c57fc62284d1cd2f837", "patch": "@@ -0,0 +1,91 @@\n+/* IPA reference lists.\n+   Copyright (C) 2010\n+   Free Software Foundation, Inc.\n+   Contributed by Jan Hubicka\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+struct cgraph_node;\n+struct varpool_node;\n+\n+/* How the reference is done.  */\n+enum GTY(()) ipa_ref_use\n+{\n+  IPA_REF_LOAD,\n+  IPA_REF_STORE,\n+  IPA_REF_ADDR\n+};\n+\n+/* Type of refering or refered type.  */\n+enum GTY(()) ipa_ref_type\n+{\n+  IPA_REF_CGRAPH,\n+  IPA_REF_VARPOOL\n+};\n+\n+/* We can have references spanning both callgraph and varpool,\n+   so all pointers needs to be of both types.  */\n+union GTY(()) ipa_ref_ptr_u\n+{\n+  struct cgraph_node * GTY((tag (\"IPA_REF_CGRAPH\"))) cgraph_node;\n+  struct varpool_node * GTY((tag (\"IPA_REF_VARPOOL\"))) varpool_node;\n+};\n+\n+/* Record of reference in callgraph or varpool.  */\n+struct GTY(()) ipa_ref\n+{\n+  union ipa_ref_ptr_u GTY ((desc (\"%1.refering_type\"))) refering;\n+  union ipa_ref_ptr_u GTY ((desc (\"%1.refered_type\"))) refered;\n+  gimple stmt;\n+  unsigned int refered_index;\n+  ENUM_BITFIELD (ipa_ref_type) refering_type:1;\n+  ENUM_BITFIELD (ipa_ref_type) refered_type:1;\n+  ENUM_BITFIELD (ipa_ref_use) use:2;\n+};\n+\n+typedef struct ipa_ref ipa_ref_t;\n+typedef struct ipa_ref *ipa_ref_ptr;\n+\n+DEF_VEC_O(ipa_ref_t);\n+DEF_VEC_ALLOC_O(ipa_ref_t,gc);\n+DEF_VEC_P(ipa_ref_ptr);\n+DEF_VEC_ALLOC_P(ipa_ref_ptr,heap);\n+\n+/* List of references.  This is stored in both callgraph and varpool nodes.  */\n+struct GTY(()) ipa_ref_list\n+{\n+  /* Store actual references in references vector.  */\n+  VEC(ipa_ref_t,gc) *references;\n+  /* Refering is vector of pointers to references.  It must not live in GGC space\n+     or GGC will try to mark middle of references vectors.  */\n+  VEC(ipa_ref_ptr,heap) * GTY((skip)) refering;\n+};\n+\n+struct ipa_ref * ipa_record_reference (struct cgraph_node *,\n+\t\t\t\t       struct varpool_node *,\n+\t\t\t\t       struct cgraph_node *,\n+\t\t\t\t       struct varpool_node *,\n+\t\t\t\t       enum ipa_ref_use, gimple);\n+\n+void ipa_remove_reference (struct ipa_ref *);\n+void ipa_remove_all_references (struct ipa_ref_list *);\n+void ipa_remove_all_refering (struct ipa_ref_list *);\n+void ipa_dump_references (FILE *, struct ipa_ref_list *);\n+void ipa_dump_refering (FILE *, struct ipa_ref_list *);\n+void ipa_clone_references (struct cgraph_node *, struct varpool_node *, struct ipa_ref_list *);\n+void ipa_clone_refering (struct cgraph_node *, struct varpool_node *, struct ipa_ref_list *);\n+"}, {"sha": "5d057312ac555f2e8d9dc7db902dbf833e1f0b75", "filename": "gcc/lto-cgraph.c", "status": "modified", "additions": 211, "deletions": 11, "changes": 222, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/369451ec60604a300eb85c57fc62284d1cd2f837/gcc%2Flto-cgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/369451ec60604a300eb85c57fc62284d1cd2f837/gcc%2Flto-cgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-cgraph.c?ref=369451ec60604a300eb85c57fc62284d1cd2f837", "patch": "@@ -46,7 +46,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"lto-streamer.h\"\n #include \"gcov-io.h\"\n \n-static void output_varpool (varpool_node_set);\n+static void output_varpool (cgraph_node_set, varpool_node_set);\n \n /* Cgraph streaming is organized as set of record whose type\n    is indicated by a tag.  */\n@@ -286,6 +286,30 @@ lto_output_edge (struct lto_simple_output_block *ob, struct cgraph_edge *edge,\n   bitpack_delete (bp);\n }\n \n+/* Return if LIST contain references from other partitions.  */\n+bool\n+referenced_from_other_partition_p (struct ipa_ref_list *list, cgraph_node_set set,\n+\t\t\t\t   varpool_node_set vset)\n+{\n+  int i;\n+  struct ipa_ref *ref;\n+  for (i = 0; ipa_ref_list_refering_iterate (list, i, ref); i++)\n+    {\n+      if (ref->refering_type == IPA_REF_CGRAPH)\n+\t{\n+\t  if (!cgraph_node_in_set_p (ipa_ref_refering_node (ref), set))\n+\t    return true;\n+\t}\n+      else\n+\t{\n+\t  if (!varpool_node_in_set_p (ipa_ref_refering_varpool_node (ref),\n+\t\t\t\t      vset))\n+\t    return true;\n+\t}\n+    }\n+  return false;\n+}\n+\n /* Return true when node is reachable from other partition.  */\n \n static bool\n@@ -460,9 +484,9 @@ lto_output_node (struct lto_simple_output_block *ob, struct cgraph_node *node,\n \n static void\n lto_output_varpool_node (struct lto_simple_output_block *ob, struct varpool_node *node,\n-\t\t         varpool_node_set set)\n+\t\t         cgraph_node_set set, varpool_node_set vset)\n {\n-  bool boundary_p = !varpool_node_in_set_p (node, set) && node->analyzed;\n+  bool boundary_p = !varpool_node_in_set_p (node, vset) && node->analyzed;\n   struct bitpack_d *bp;\n   struct varpool_node *alias;\n   int count = 0;\n@@ -486,9 +510,9 @@ lto_output_varpool_node (struct lto_simple_output_block *ob, struct varpool_node\n     }\n   else\n     {\n-      /* FIXME: We have no idea how we move references around.  For moment assume that\n-\t everything is used externally.  */\n-      bp_pack_value (bp, flag_wpa, 1);  /* used_from_other_parition.  */\n+      bp_pack_value (bp, node->analyzed\n+\t\t     && referenced_from_other_partition_p (&node->ref_list,\n+\t\t\t\t\t\t\t   set, vset), 1);\n       bp_pack_value (bp, boundary_p, 1);  /* in_other_partition.  */\n     }\n   /* Also emit any extra name aliases.  */\n@@ -506,6 +530,34 @@ lto_output_varpool_node (struct lto_simple_output_block *ob, struct varpool_node\n     }\n }\n \n+/* Output the varpool NODE to OB. \n+   If NODE is not in SET, then NODE is a boundary.  */\n+\n+static void\n+lto_output_ref (struct lto_simple_output_block *ob, struct ipa_ref *ref,\n+\t\tlto_cgraph_encoder_t encoder,\n+\t\tlto_varpool_encoder_t varpool_encoder)\n+{\n+  struct bitpack_d *bp = bitpack_create ();\n+  bp_pack_value (bp, ref->refered_type, 1);\n+  bp_pack_value (bp, ref->use, 2);\n+  lto_output_bitpack (ob->main_stream, bp);\n+  bitpack_delete (bp);\n+  if (ref->refered_type == IPA_REF_CGRAPH)\n+    {\n+      int nref = lto_cgraph_encoder_lookup (encoder, ipa_ref_node (ref));\n+      gcc_assert (nref != LCC_NOT_FOUND);\n+      lto_output_sleb128_stream (ob->main_stream, nref);\n+    }\n+  else\n+    {\n+      int nref = lto_varpool_encoder_lookup (varpool_encoder,\n+\t\t\t\t             ipa_ref_varpool_node (ref));\n+      gcc_assert (nref != LCC_NOT_FOUND);\n+      lto_output_sleb128_stream (ob->main_stream, nref);\n+    }\n+}\n+\n /* Stream out profile_summary to OB.  */\n \n static void\n@@ -534,6 +586,25 @@ add_node_to (lto_cgraph_encoder_t encoder, struct cgraph_node *node)\n   lto_cgraph_encoder_encode (encoder, node);\n }\n \n+/* Add all references in LIST to encoders.  */\n+\n+static void\n+add_references (lto_cgraph_encoder_t encoder,\n+\t\tlto_varpool_encoder_t varpool_encoder,\n+\t\tstruct ipa_ref_list *list)\n+{\n+  int i;\n+  struct ipa_ref *ref;\n+  for (i = 0; ipa_ref_list_reference_iterate (list, i, ref); i++)\n+    if (ref->refered_type == IPA_REF_CGRAPH)\n+      add_node_to (encoder, ipa_ref_node (ref));\n+    else\n+      {\n+\tstruct varpool_node *vnode = ipa_ref_varpool_node (ref);\n+        lto_varpool_encoder_encode (varpool_encoder, vnode);\n+      }\n+}\n+\n /* Output all callees or indirect outgoing edges.  EDGE must be the first such\n    edge.  */\n \n@@ -553,6 +624,61 @@ output_outgoing_cgraph_edges (struct cgraph_edge *edge,\n     lto_output_edge (ob, edge, encoder);\n }\n \n+/* Output the part of the cgraph in SET.  */\n+\n+static void\n+output_refs (cgraph_node_set set, varpool_node_set vset,\n+\t     lto_cgraph_encoder_t encoder,\n+\t     lto_varpool_encoder_t varpool_encoder)\n+{\n+  cgraph_node_set_iterator csi;\n+  varpool_node_set_iterator vsi;\n+  struct lto_simple_output_block *ob;\n+  int count;\n+  struct ipa_ref *ref;\n+  int i;\n+\n+  ob = lto_create_simple_output_block (LTO_section_refs);\n+\n+  for (csi = csi_start (set); !csi_end_p (csi); csi_next (&csi))\n+    {\n+      struct cgraph_node *node = csi_node (csi);\n+\n+      count = ipa_ref_list_nreferences (&node->ref_list);\n+      if (count)\n+\t{\n+\t  lto_output_uleb128_stream (ob->main_stream, count);\n+\t  lto_output_uleb128_stream (ob->main_stream,\n+\t\t\t\t     lto_cgraph_encoder_lookup (encoder, node));\n+\t  for (i = 0; ipa_ref_list_reference_iterate (&node->ref_list, i, ref); i++)\n+\t    lto_output_ref (ob, ref, encoder, varpool_encoder);\n+\t}\n+    }\n+\n+  lto_output_uleb128_stream (ob->main_stream, 0);\n+\n+  for (vsi = vsi_start (vset); !vsi_end_p (vsi); vsi_next (&vsi))\n+    {\n+      struct varpool_node *node = vsi_node (vsi);\n+\n+      count = ipa_ref_list_nreferences (&node->ref_list);\n+      if (count)\n+\t{\n+\t  lto_output_uleb128_stream (ob->main_stream, count);\n+\t  lto_output_uleb128_stream (ob->main_stream,\n+\t\t\t\t     lto_varpool_encoder_lookup (varpool_encoder,\n+\t\t\t\t\t\t\t\t node));\n+\t  for (i = 0; ipa_ref_list_reference_iterate (&node->ref_list, i, ref); i++)\n+\t    lto_output_ref (ob, ref, encoder, varpool_encoder);\n+\t}\n+    }\n+\n+  lto_output_uleb128_stream (ob->main_stream, 0);\n+\n+  lto_destroy_simple_output_block (ob);\n+}\n+\n+\n /* Output the part of the cgraph in SET.  */\n \n void\n@@ -591,16 +717,18 @@ output_cgraph (cgraph_node_set set, varpool_node_set vset)\n     {\n       node = csi_node (csi);\n       add_node_to (encoder, node);\n+      add_references (encoder, varpool_encoder, &node->ref_list);\n     }\n   for (vsi = vsi_start (vset); !vsi_end_p (vsi); vsi_next (&vsi))\n     {\n       struct varpool_node *vnode = vsi_node (vsi);\n       gcc_assert (!vnode->alias);\n       lto_varpool_encoder_encode (varpool_encoder, vnode);\n       lto_set_varpool_encoder_encode_initializer (varpool_encoder, vnode);\n+      add_references (encoder, varpool_encoder, &vnode->ref_list);\n     }\n-  /* FIXME: We do not track references, so for now we need to include all possibly\n-     used variables in the encoder set.  */\n+  /* FIXME: We can not currenlty remove any varpool nodes or we get ICE merging\n+     binfos.  */\n   for (vnode = varpool_nodes; vnode; vnode = vnode->next)\n     if (vnode->needed)\n       lto_varpool_encoder_encode (varpool_encoder, vnode);\n@@ -617,6 +745,7 @@ output_cgraph (cgraph_node_set set, varpool_node_set vset)\n \t      ||  TREE_READONLY (vnode->decl)))\n \t{\n \t  lto_set_varpool_encoder_encode_initializer (varpool_encoder, vnode);\n+\t  add_references (encoder, varpool_encoder, &vnode->ref_list);\n \t}\n     }\n \n@@ -672,7 +801,8 @@ output_cgraph (cgraph_node_set set, varpool_node_set vset)\n   lto_output_uleb128_stream (ob->main_stream, 0);\n \n   lto_destroy_simple_output_block (ob);\n-  output_varpool (vset);\n+  output_varpool (set, vset);\n+  output_refs (set, vset, encoder, varpool_encoder);\n }\n \n /* Overwrite the information in NODE based on FILE_DATA, TAG, FLAGS,\n@@ -727,7 +857,7 @@ input_overwrite_node (struct lto_file_decl_data *file_data,\n /* Output the part of the cgraph in SET.  */\n \n static void\n-output_varpool (varpool_node_set vset)\n+output_varpool (cgraph_node_set set, varpool_node_set vset)\n {\n   struct lto_simple_output_block *ob = lto_create_simple_output_block (LTO_section_varpool);\n   lto_varpool_encoder_t varpool_encoder = ob->decl_state->varpool_node_encoder;\n@@ -741,7 +871,7 @@ output_varpool (varpool_node_set vset)\n   for (i = 0; i < len; i++)\n     {\n       lto_output_varpool_node (ob, lto_varpool_encoder_deref (varpool_encoder, i),\n-\t\t\t       vset);\n+\t\t\t       set, vset);\n     }\n \n   lto_destroy_simple_output_block (ob);\n@@ -889,6 +1019,33 @@ input_varpool_node (struct lto_file_decl_data *file_data,\n   return node;\n }\n \n+/* Read a node from input_block IB.  TAG is the node's tag just read.\n+   Return the node read or overwriten.  */\n+\n+static void\n+input_ref (struct lto_input_block *ib,\n+\t   struct cgraph_node *refering_node,\n+\t   struct varpool_node *refering_varpool_node,\n+\t   VEC(cgraph_node_ptr, heap) *nodes,\n+\t   VEC(varpool_node_ptr, heap) *varpool_nodes)\n+{\n+  struct cgraph_node *node = NULL;\n+  struct varpool_node *varpool_node = NULL;\n+  struct bitpack_d *bp;\n+  enum ipa_ref_type type;\n+  enum ipa_ref_use use;\n+\n+  bp = lto_input_bitpack (ib);\n+  type = (enum ipa_ref_type) bp_unpack_value (bp, 1);\n+  use = (enum ipa_ref_use) bp_unpack_value (bp, 2);\n+  bitpack_delete (bp);\n+  if (type == IPA_REF_CGRAPH)\n+    node = VEC_index (cgraph_node_ptr, nodes, lto_input_sleb128 (ib));\n+  else\n+    varpool_node = VEC_index (varpool_node_ptr, varpool_nodes, lto_input_sleb128 (ib));\n+  ipa_record_reference (refering_node, refering_varpool_node,\n+\t\t        node, varpool_node, use, NULL);\n+}\n \n /* Read an edge from IB.  NODES points to a vector of previously read nodes for\n    decoding caller and callee of the edge to be read.  If INDIRECT is true, the\n@@ -1036,6 +1193,44 @@ input_varpool_1 (struct lto_file_decl_data *file_data,\n   return varpool;\n }\n \n+/* Input ipa_refs.  */\n+\n+static void\n+input_refs (struct lto_input_block *ib,\n+\t    VEC(cgraph_node_ptr, heap) *nodes,\n+\t    VEC(varpool_node_ptr, heap) *varpool)\n+{\n+  int count;\n+  int idx;\n+  while (true)\n+    {\n+      struct cgraph_node *node;\n+      count = lto_input_uleb128 (ib);\n+      if (!count)\n+\tbreak;\n+      idx = lto_input_uleb128 (ib);\n+      node = VEC_index (cgraph_node_ptr, nodes, idx);\n+      while (count)\n+\t{\n+\t  input_ref (ib, node, NULL, nodes, varpool);\n+\t  count--;\n+\t}\n+    }\n+  while (true)\n+    {\n+      struct varpool_node *node;\n+      count = lto_input_uleb128 (ib);\n+      if (!count)\n+\tbreak;\n+      node = VEC_index (varpool_node_ptr, varpool, lto_input_uleb128 (ib));\n+      while (count)\n+\t{\n+\t  input_ref (ib, NULL, node, nodes, varpool);\n+\t  count--;\n+\t}\n+    }\n+}\n+\t    \n \n static struct gcov_ctr_summary lto_gcov_summary;\n \n@@ -1100,6 +1295,11 @@ input_cgraph (void)\n       lto_destroy_simple_input_block (file_data, LTO_section_varpool,\n \t\t\t\t      ib, data, len);\n \n+      ib = lto_create_simple_input_block (file_data, LTO_section_refs,\n+\t\t\t\t\t  &data, &len);\n+      input_refs (ib, nodes, varpool);\n+      lto_destroy_simple_input_block (file_data, LTO_section_refs,\n+\t\t\t\t      ib, data, len);\n       VEC_free (cgraph_node_ptr, heap, nodes);\n       VEC_free (varpool_node_ptr, heap, varpool);\n     }"}, {"sha": "44b3e1ce100137501569fca6dddb86534e661ccb", "filename": "gcc/lto-section-in.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/369451ec60604a300eb85c57fc62284d1cd2f837/gcc%2Flto-section-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/369451ec60604a300eb85c57fc62284d1cd2f837/gcc%2Flto-section-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-section-in.c?ref=369451ec60604a300eb85c57fc62284d1cd2f837", "patch": "@@ -53,6 +53,7 @@ const char *lto_section_name[LTO_N_SECTION_TYPES] =\n   \"static_initializer\",\n   \"cgraph\",\n   \"varpool\",\n+  \"refs\",\n   \"jump_funcs\"\n   \"ipa_pure_const\",\n   \"ipa_reference\","}, {"sha": "01703f1a981074c563c1ec5dfe0404fa230a360b", "filename": "gcc/lto-streamer.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/369451ec60604a300eb85c57fc62284d1cd2f837/gcc%2Flto-streamer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/369451ec60604a300eb85c57fc62284d1cd2f837/gcc%2Flto-streamer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer.c?ref=369451ec60604a300eb85c57fc62284d1cd2f837", "patch": "@@ -163,6 +163,9 @@ lto_get_section_name (int section_type, const char *name)\n     case LTO_section_varpool:\n       return concat (LTO_SECTION_NAME_PREFIX, \".vars\", NULL);\n \n+    case LTO_section_refs:\n+      return concat (LTO_SECTION_NAME_PREFIX, \".refs\", NULL);\n+\n     case LTO_section_jump_functions:\n       return concat (LTO_SECTION_NAME_PREFIX, \".jmpfuncs\", NULL);\n "}, {"sha": "4f3d60d89939aedd5ceb54e7179c3c868d2f6d8c", "filename": "gcc/lto-streamer.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/369451ec60604a300eb85c57fc62284d1cd2f837/gcc%2Flto-streamer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/369451ec60604a300eb85c57fc62284d1cd2f837/gcc%2Flto-streamer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer.h?ref=369451ec60604a300eb85c57fc62284d1cd2f837", "patch": "@@ -257,6 +257,7 @@ enum lto_section_type\n   LTO_section_static_initializer,\n   LTO_section_cgraph,\n   LTO_section_varpool,\n+  LTO_section_refs,\n   LTO_section_jump_functions,\n   LTO_section_ipa_pure_const,\n   LTO_section_ipa_reference,\n@@ -855,6 +856,9 @@ bool lto_varpool_encoder_encode_initializer_p (lto_varpool_encoder_t,\n \t\t\t\t\t       struct varpool_node *);\n void output_cgraph (cgraph_node_set, varpool_node_set);\n void input_cgraph (void);\n+bool referenced_from_other_partition_p (struct ipa_ref_list *,\n+\t\t\t\t        cgraph_node_set,\n+\t\t\t\t        varpool_node_set vset);\n \n \n /* In lto-symtab.c.  */"}, {"sha": "83a64bbf345fa487e8810a251c325b2056fd5e6d", "filename": "gcc/lto-symtab.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/369451ec60604a300eb85c57fc62284d1cd2f837/gcc%2Flto-symtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/369451ec60604a300eb85c57fc62284d1cd2f837/gcc%2Flto-symtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-symtab.c?ref=369451ec60604a300eb85c57fc62284d1cd2f837", "patch": "@@ -214,6 +214,8 @@ lto_cgraph_replace_node (struct cgraph_node *node,\n       next = e->next_caller;\n       cgraph_redirect_edge_callee (e, prevailing_node);\n     }\n+  /* Redirect incomming references.  */\n+  ipa_clone_refering (prevailing_node, NULL, &node->ref_list);\n \n   if (node->same_body)\n     {\n@@ -273,6 +275,12 @@ lto_varpool_replace_node (struct varpool_node *vnode,\n   gcc_assert (!vnode->finalized || prevailing_node->finalized);\n   gcc_assert (!vnode->analyzed || prevailing_node->analyzed);\n \n+  /* When replacing by an alias, the references goes to the original\n+     variable.  */\n+  if (prevailing_node->alias && prevailing_node->extra_name)\n+    prevailing_node = prevailing_node->extra_name;\n+  ipa_clone_refering (NULL, prevailing_node, &vnode->ref_list);\n+\n   /* Finally remove the replaced node.  */\n   varpool_remove_node (vnode);\n }"}, {"sha": "304bf6e514dca982aaa08bc8919f76dd1d2b0ac9", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/369451ec60604a300eb85c57fc62284d1cd2f837/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/369451ec60604a300eb85c57fc62284d1cd2f837/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=369451ec60604a300eb85c57fc62284d1cd2f837", "patch": "@@ -1,3 +1,7 @@\n+2010-05-05  Jan Hubicka  <jh@suse.cz>\n+\n+\t* lto.c (lto_promote_cross_file_statics): Compute boundary based on refs.\n+\n 2010-05-05  Jan Hubicka  <jh@suse.cz>\n \n \t* lto.c (lto_1_to_1_map): Partition only needed nodes."}, {"sha": "44b4a843671ffa3a5ec943f1bc0f531bb9b316e4", "filename": "gcc/lto/lto.c", "status": "modified", "additions": 24, "deletions": 14, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/369451ec60604a300eb85c57fc62284d1cd2f837/gcc%2Flto%2Flto.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/369451ec60604a300eb85c57fc62284d1cd2f837/gcc%2Flto%2Flto.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto.c?ref=369451ec60604a300eb85c57fc62284d1cd2f837", "patch": "@@ -718,36 +718,30 @@ lto_promote_cross_file_statics (void)\n   struct varpool_node *vnode;\n   unsigned i, n_sets;\n   cgraph_node_set set;\n+  varpool_node_set vset;\n   cgraph_node_set_iterator csi;\n+  varpool_node_set_iterator vsi;\n \n   gcc_assert (flag_wpa);\n \n-  /* At moment we make no attempt to figure out who is refering the variables,\n-     so all must become global.  \n-\n-     Constant pool references use internal labels and thus can not be made global.\n-     It is sensible to keep those ltrans local to allow better optimization.  */\n-  for (vnode = varpool_nodes; vnode; vnode = vnode->next)\n-    if (!vnode->externally_visible && vnode->analyzed\n-\t&& !DECL_IN_CONSTANT_POOL (vnode->decl))\n-       {\n-\t  TREE_PUBLIC (vnode->decl) = 1;\n-\t  DECL_VISIBILITY (vnode->decl) = VISIBILITY_HIDDEN;\n-       }\n   n_sets = VEC_length (cgraph_node_set, lto_cgraph_node_sets);\n   for (i = 0; i < n_sets; i++)\n     {\n       set = VEC_index (cgraph_node_set, lto_cgraph_node_sets, i);\n+      vset = VEC_index (varpool_node_set, lto_varpool_node_sets, i);\n \n       /* If node has either address taken (and we have no clue from where)\n \t or it is called from other partition, it needs to be globalized.  */\n       for (csi = csi_start (set); !csi_end_p (csi); csi_next (&csi))\n \t{\n \t  struct cgraph_node *node = csi_node (csi);\n-\t  bool globalize = node->address_taken || node->local.vtable_method;\n+\t  bool globalize = node->local.vtable_method;\n \t  struct cgraph_edge *e;\n \t  if (node->local.externally_visible)\n \t    continue;\n+\t  if (!globalize\n+\t      && referenced_from_other_partition_p (&node->ref_list, set, vset))\n+\t    globalize = true;\n \t  for (e = node->callers; e && !globalize; e = e->next_caller)\n \t    {\n \t      struct cgraph_node *caller = e->caller;\n@@ -758,6 +752,7 @@ lto_promote_cross_file_statics (void)\n \t    }\n \t  if (globalize)\n \t     {\n+\t\tgcc_assert (flag_wpa);\n \t\tTREE_PUBLIC (node->decl) = 1;\n \t\tDECL_VISIBILITY (node->decl) = VISIBILITY_HIDDEN;\n \t\tif (node->same_body)\n@@ -772,6 +767,21 @@ lto_promote_cross_file_statics (void)\n \t\t  }\n \t     }\n \t}\n+      for (vsi = vsi_start (vset); !vsi_end_p (vsi); vsi_next (&vsi))\n+\t{\n+\t  vnode = vsi_node (vsi);\n+\t  /* Constant pool references use internal labels and thus can not\n+\t     be made global.  It is sensible to keep those ltrans local to\n+\t     allow better optimization.  */\n+\t  if (!DECL_IN_CONSTANT_POOL (vnode->decl)\n+\t      && !vnode->externally_visible && vnode->analyzed\n+\t      && referenced_from_other_partition_p (&vnode->ref_list, set, vset))\n+\t    {\n+\t      gcc_assert (flag_wpa);\n+\t      TREE_PUBLIC (vnode->decl) = 1;\n+\t      DECL_VISIBILITY (vnode->decl) = VISIBILITY_HIDDEN;\n+\t    }\n+\t}\n \n     }\n }\n@@ -1457,7 +1467,7 @@ lto_fixup_tree (tree *tp, int *walk_subtrees, void *data)\n \n   t = *tp;\n   *walk_subtrees = 0;\n-  if (pointer_set_contains (fixup_data->seen, t))\n+  if (!t || pointer_set_contains (fixup_data->seen, t))\n     return NULL;\n \n   if (TREE_CODE (t) == VAR_DECL || TREE_CODE (t) == FUNCTION_DECL)"}, {"sha": "a540d035a7e3a9ec17c507b3132e627c6e845a13", "filename": "gcc/varpool.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/369451ec60604a300eb85c57fc62284d1cd2f837/gcc%2Fvarpool.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/369451ec60604a300eb85c57fc62284d1cd2f837/gcc%2Fvarpool.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarpool.c?ref=369451ec60604a300eb85c57fc62284d1cd2f837", "patch": "@@ -141,6 +141,7 @@ varpool_node (tree decl)\n   node->decl = decl;\n   node->order = cgraph_order++;\n   node->next = varpool_nodes;\n+  ipa_empty_ref_list (&node->ref_list);\n   if (varpool_nodes)\n     varpool_nodes->prev = node;\n   varpool_nodes = node;\n@@ -193,6 +194,8 @@ varpool_remove_node (struct varpool_node *node)\n       gcc_assert (varpool_nodes_queue == node);\n       varpool_nodes_queue = node->next_needed;\n     }\n+  ipa_remove_all_references (&node->ref_list);\n+  ipa_remove_all_refering (&node->ref_list);\n   if (DECL_INITIAL (node->decl))\n     DECL_INITIAL (node->decl) = error_mark_node;\n   ggc_free (node);\n@@ -228,6 +231,10 @@ dump_varpool_node (FILE *f, struct varpool_node *node)\n   else if (node->used_from_other_partition)\n     fprintf (f, \" used_from_other_partition\");\n   fprintf (f, \"\\n\");\n+  fprintf (f, \"  References: \");\n+  ipa_dump_references (f, &node->ref_list);\n+  fprintf (f, \"  Refering this var: \");\n+  ipa_dump_refering (f, &node->ref_list);\n }\n \n /* Dump the variable pool.  */\n@@ -633,6 +640,7 @@ varpool_extra_name_alias (tree alias, tree decl)\n   alias_node->alias = 1;\n   alias_node->extra_name = decl_node;\n   alias_node->next = decl_node->extra_name;\n+  ipa_empty_ref_list (&alias_node->ref_list);\n   if (decl_node->extra_name)\n     decl_node->extra_name->prev = alias_node;\n   decl_node->extra_name = alias_node;"}]}