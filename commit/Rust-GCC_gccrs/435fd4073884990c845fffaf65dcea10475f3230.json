{"sha": "435fd4073884990c845fffaf65dcea10475f3230", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDM1ZmQ0MDczODg0OTkwYzg0NWZmZmFmNjVkY2VhMTA0NzVmMzIzMA==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2016-11-15T16:16:49Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2016-11-15T16:16:49Z"}, "message": "tree-ssa-threadbackward.c (fsm_find_thread_path): Remove unneeded parameter.\n\n\t* tree-ssa-threadbackward.c (fsm_find_thread_path): Remove unneeded\n\tparameter.  Callers changed.\n\t(check-subpath_and_update_thread_path): Extracted from\n\tfsm_find_control_statement_thread_paths.\n\t(handle_phi, handle_assignment, handle_assignment_p): Likewise.\n\t(handle_phi, handle_assignment): Allow any constant node, not\n\tjust INTEGER_CST.\n\nFrom-SVN: r242431", "tree": {"sha": "ef973f2517d7d2bb3099a220cbc6dc2c3a234ab1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ef973f2517d7d2bb3099a220cbc6dc2c3a234ab1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/435fd4073884990c845fffaf65dcea10475f3230", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/435fd4073884990c845fffaf65dcea10475f3230", "html_url": "https://github.com/Rust-GCC/gccrs/commit/435fd4073884990c845fffaf65dcea10475f3230", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/435fd4073884990c845fffaf65dcea10475f3230/comments", "author": null, "committer": null, "parents": [{"sha": "5a0e7889408ce1bf586216b29de7012643493a97", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a0e7889408ce1bf586216b29de7012643493a97", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5a0e7889408ce1bf586216b29de7012643493a97"}], "stats": {"total": 376, "additions": 240, "deletions": 136}, "files": [{"sha": "a54423ad7d59bd709310884eabed9b718517c697", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/435fd4073884990c845fffaf65dcea10475f3230/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/435fd4073884990c845fffaf65dcea10475f3230/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=435fd4073884990c845fffaf65dcea10475f3230", "patch": "@@ -1,3 +1,13 @@\n+2016-11-15  Jeff Law  <law@redhat.com>\n+\n+\t* tree-ssa-threadbackward.c (fsm_find_thread_path): Remove unneeded\n+\tparameter.  Callers changed.\n+\t(check-subpath_and_update_thread_path): Extracted from\n+\tfsm_find_control_statement_thread_paths.\n+\t(handle_phi, handle_assignment, handle_assignment_p): Likewise.\n+\t(handle_phi, handle_assignment): Allow any constant node, not\n+\tjust INTEGER_CST.\n+\n 2016-11-15  Claudiu Zissulescu  <claziss@synopsys.com>\n \n \t* config/arc/arc-arch.h: New file."}, {"sha": "203e20e712f07bba3c5c15ba174f7d281cd86182", "filename": "gcc/tree-ssa-threadbackward.c", "status": "modified", "additions": 230, "deletions": 136, "changes": 366, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/435fd4073884990c845fffaf65dcea10475f3230/gcc%2Ftree-ssa-threadbackward.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/435fd4073884990c845fffaf65dcea10475f3230/gcc%2Ftree-ssa-threadbackward.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadbackward.c?ref=435fd4073884990c845fffaf65dcea10475f3230", "patch": "@@ -62,14 +62,12 @@ get_gimple_control_stmt (basic_block bb)\n /* Return true if the CFG contains at least one path from START_BB to END_BB.\n    When a path is found, record in PATH the blocks from END_BB to START_BB.\n    VISITED_BBS is used to make sure we don't fall into an infinite loop.  Bound\n-   the recursion to basic blocks belonging to LOOP.\n-   SPEED_P indicate that we could increase code size to improve the code path */\n+   the recursion to basic blocks belonging to LOOP.  */\n \n static bool\n fsm_find_thread_path (basic_block start_bb, basic_block end_bb,\n \t\t      vec<basic_block, va_gc> *&path,\n-\t\t      hash_set<basic_block> *visited_bbs, loop_p loop,\n-\t\t      bool speed_p)\n+\t\t      hash_set<basic_block> *visited_bbs, loop_p loop)\n {\n   if (loop != start_bb->loop_father)\n     return false;\n@@ -85,8 +83,7 @@ fsm_find_thread_path (basic_block start_bb, basic_block end_bb,\n       edge e;\n       edge_iterator ei;\n       FOR_EACH_EDGE (e, ei, start_bb->succs)\n-\tif (fsm_find_thread_path (e->dest, end_bb, path, visited_bbs, loop,\n-\t\t\t\t  speed_p))\n+\tif (fsm_find_thread_path (e->dest, end_bb, path, visited_bbs, loop))\n \t  {\n \t    vec_safe_push (path, start_bb);\n \t    return true;\n@@ -427,6 +424,222 @@ convert_and_register_jump_thread_path (vec<basic_block, va_gc> *path,\n   --max_threaded_paths;\n }\n \n+/* While following a chain of SSA_NAME definitions, we jumped from a definition\n+   in LAST_BB to a definition in VAR_BB (walking backwards).\n+\n+   Verify there is a single path between the blocks and none of the blocks\n+   in the path is already in VISITED_BBS.  If so, then update VISISTED_BBS,\n+   add the new blocks to PATH and return TRUE.  Otherwise return FALSE.\n+\n+   Store the length of the subpath in NEXT_PATH_LENGTH.  */\n+\n+static bool\n+check_subpath_and_update_thread_path (basic_block last_bb, basic_block new_bb,\n+\t\t\t\t      hash_set<basic_block> *visited_bbs,\n+\t\t\t\t      vec<basic_block, va_gc> *&path,\n+\t\t\t\t      int *next_path_length)\n+{\n+  edge e;\n+  int e_count = 0;\n+  edge_iterator ei;\n+  vec<basic_block, va_gc> *next_path;\n+  vec_alloc (next_path, 10);\n+\n+  FOR_EACH_EDGE (e, ei, last_bb->preds)\n+    {\n+      hash_set<basic_block> *visited_bbs = new hash_set<basic_block>;\n+\n+      if (fsm_find_thread_path (new_bb, e->src, next_path, visited_bbs,\n+\t\t\t\te->src->loop_father))\n+\t++e_count;\n+\n+      delete visited_bbs;\n+\n+      /* If there is more than one path, stop.  */\n+      if (e_count > 1)\n+\t{\n+\t  vec_free (next_path);\n+\t  return false;\n+\t}\n+    }\n+\n+  /* Stop if we have not found a path: this could occur when the recursion\n+     is stopped by one of the bounds.  */\n+  if (e_count == 0)\n+    {\n+      vec_free (next_path);\n+      return false;\n+    }\n+\n+  /* Make sure we haven't already visited any of the nodes in\n+     NEXT_PATH.  Don't add them here to avoid pollution.  */\n+  for (unsigned int i = 0; i < next_path->length () - 1; i++)\n+    {\n+      if (visited_bbs->contains ((*next_path)[i]))\n+\t{\n+\t  vec_free (next_path);\n+\t  return false;\n+\t}\n+    }\n+\n+  /* Now add the nodes to VISISTED_BBS.  */\n+  for (unsigned int i = 0; i < next_path->length () - 1; i++)\n+    visited_bbs->add ((*next_path)[i]);\n+\n+  /* Append all the nodes from NEXT_PATH to PATH.  */\n+  vec_safe_splice (path, next_path);\n+  *next_path_length = next_path->length ();\n+  vec_free (next_path);\n+\n+  return true;\n+}\n+\n+static void fsm_find_control_statement_thread_paths (tree,\n+\t\t\t\t\t\t     hash_set<basic_block> *,\n+\t\t\t\t\t\t     vec<basic_block, va_gc> *&,\n+\t\t\t\t\t\t     bool, bool);\n+\n+/* Given PHI which defines NAME in block VAR_BB, recurse through the\n+   PHI's arguments searching for paths where NAME will ultimately have\n+   a constant value.\n+\n+   VISITED_BBS tracks the blocks that have been encountered.\n+\n+   PATH contains the series of blocks to traverse that will result in\n+   NAME having a constant value.\n+\n+   SEEN_LOOP_PHI tracks if we have recursed through a loop PHI node.\n+\n+   SPEED_P indicates if we are optimizing for speed over space.  */\n+\n+static void\n+handle_phi (gphi *phi, tree name, basic_block var_bb,\n+\t    hash_set<basic_block> *visited_bbs,\n+\t    vec<basic_block, va_gc> *&path,\n+\t    bool seen_loop_phi, bool speed_p)\n+{\n+  /* Iterate over the arguments of PHI.  */\n+  for (unsigned int i = 0; i < gimple_phi_num_args (phi); i++)\n+    {\n+      tree arg = gimple_phi_arg_def (phi, i);\n+      basic_block bbi = gimple_phi_arg_edge (phi, i)->src;\n+\n+      /* Skip edges pointing outside the current loop.  */\n+      if (!arg || var_bb->loop_father != bbi->loop_father)\n+\tcontinue;\n+\n+      if (TREE_CODE (arg) == SSA_NAME)\n+\t{\n+\t  vec_safe_push (path, bbi);\n+\t  /* Recursively follow SSA_NAMEs looking for a constant\n+\t     definition.  */\n+\t  fsm_find_control_statement_thread_paths (arg, visited_bbs, path,\n+\t\t\t\t\t\t   seen_loop_phi, speed_p);\n+\n+\t  path->pop ();\n+\t  continue;\n+\t}\n+\n+      if (TREE_CODE_CLASS (TREE_CODE (arg)) != tcc_constant)\n+\tcontinue;\n+\n+      /* If this is a profitable jump thread path, then convert it\n+\t into the canonical form and register it.  */\n+      bool irreducible = false;\n+      edge taken_edge = profitable_jump_thread_path (path, bbi, name, arg,\n+\t\t\t\t\t\t     speed_p, &irreducible);\n+      if (taken_edge)\n+\t{\n+\t  convert_and_register_jump_thread_path (path, taken_edge);\n+\t  path->pop ();\n+\n+\t  if (irreducible)\n+\t    vect_free_loop_info_assumptions ((*path)[0]->loop_father);\n+\t}\n+    }\n+}\n+\n+/* Return TRUE if STMT is a gimple assignment we want to either directly\n+   handle or recurse through.  Return FALSE otherwise.\n+\n+   Note that adding more cases here requires adding cases to handle_assignment\n+   below.  */\n+\n+static bool\n+handle_assignment_p (gimple *stmt)\n+{\n+  if (is_gimple_assign (stmt))\n+    {\n+      enum tree_code def_code = gimple_assign_rhs_code (stmt);\n+\n+      /* If the RHS is an SSA_NAME, then we will recurse through it.\n+\t Go ahead and filter out cases where the SSA_NAME is a default\n+\t definition.  There's little to be gained by trying to handle that.  */\n+      if (def_code == SSA_NAME\n+\t  && !SSA_NAME_IS_DEFAULT_DEF (gimple_assign_rhs1 (stmt)))\n+\treturn true;\n+\n+      /* If the RHS is a constant, then it's a terminal that we'll want\n+\t to handle as well.  */\n+      if (TREE_CODE_CLASS (def_code) == tcc_constant)\n+\treturn true;\n+    }\n+\n+  /* Anything not explicitly allowed is not handled.  */\n+  return false;\n+}\n+\n+/* Given STMT which defines NAME in block VAR_BB, recurse through the\n+   PHI's arguments searching for paths where NAME will ultimately have\n+   a constant value.\n+\n+   VISITED_BBS tracks the blocks that have been encountered.\n+\n+   PATH contains the series of blocks to traverse that will result in\n+   NAME having a constant value.\n+\n+   SEEN_LOOP_PHI tracks if we have recursed through a loop PHI node.\n+\n+   SPEED_P indicates if we are optimizing for speed over space.  */\n+\n+static void\n+handle_assignment (gimple *stmt, tree name, basic_block var_bb,\n+\t\t   hash_set<basic_block> *visited_bbs,\n+\t\t   vec<basic_block, va_gc> *&path,\n+\t\t   bool seen_loop_phi, bool speed_p)\n+{\n+  tree arg = gimple_assign_rhs1 (stmt);\n+\n+  if (TREE_CODE (arg) == SSA_NAME)\n+    fsm_find_control_statement_thread_paths (arg, visited_bbs,\n+\t\t\t\t\t     path, seen_loop_phi, speed_p);\n+\n+  else\n+    {\n+      /* profitable_jump_thread_path is going to push the current\n+\t block onto the path.  But the path will always have the current\n+\t block at this point.  So we can just pop it.  */\n+      path->pop ();\n+\n+      bool irreducible = false;\n+      edge taken_edge = profitable_jump_thread_path (path, var_bb,\n+\t\t\t\t\t\t     name, arg, speed_p,\n+\t\t\t\t\t\t     &irreducible);\n+      if (taken_edge)\n+\t{\n+\t  convert_and_register_jump_thread_path (path, taken_edge);\n+\t  path->pop ();\n+\n+\t  if (irreducible)\n+\t    vect_free_loop_info_assumptions ((*path)[0]->loop_father);\n+\t}\n+\n+      /* And put the current block back onto the path so that the\n+\t state of the stack is unchanged when we leave.  */\n+      vec_safe_push (path, var_bb);\n+    }\n+}\n+\n /* We trace the value of the SSA_NAME NAME back through any phi nodes looking\n    for places where it gets a constant value and save the path.  Stop after\n    having recorded MAX_PATHS jump threading paths.\n@@ -461,9 +674,8 @@ fsm_find_control_statement_thread_paths (tree name,\n \t  >= (unsigned) PARAM_VALUE (PARAM_FSM_MAXIMUM_PHI_ARGUMENTS)))\n     return;\n \n-  if (gimple_code (def_stmt) == GIMPLE_ASSIGN\n-      && gimple_assign_rhs_code (def_stmt) != INTEGER_CST\n-      && gimple_assign_rhs_code (def_stmt) != SSA_NAME)\n+  if (is_gimple_assign (def_stmt)\n+      && ! handle_assignment_p (def_stmt))\n     return;\n \n   /* Avoid infinite recursion.  */\n@@ -486,143 +698,25 @@ fsm_find_control_statement_thread_paths (tree name,\n      different, append to PATH the blocks from LAST_BB_IN_PATH to VAR_BB.  */\n   if (var_bb != last_bb_in_path)\n     {\n-      edge e;\n-      int e_count = 0;\n-      edge_iterator ei;\n-      vec<basic_block, va_gc> *next_path;\n-      vec_alloc (next_path, 10);\n-\n       /* When VAR_BB == LAST_BB_IN_PATH, then the first block in the path\n \t will already be in VISITED_BBS.  When they are not equal, then we\n \t must ensure that first block is accounted for to ensure we do not\n \t create bogus jump threading paths.  */\n       visited_bbs->add ((*path)[0]);\n-      FOR_EACH_EDGE (e, ei, last_bb_in_path->preds)\n-\t{\n-\t  hash_set<basic_block> *visited_bbs = new hash_set<basic_block>;\n-\n-\t  if (fsm_find_thread_path (var_bb, e->src, next_path, visited_bbs,\n-\t\t\t\t    e->src->loop_father, speed_p))\n-\t    ++e_count;\n-\n-\t  delete visited_bbs;\n-\n-\t  /* If there is more than one path, stop.  */\n-\t  if (e_count > 1)\n-\t    {\n-\t      vec_free (next_path);\n-\t      return;\n-\t    }\n-\t}\n-\n-      /* Stop if we have not found a path: this could occur when the recursion\n-\t is stopped by one of the bounds.  */\n-      if (e_count == 0)\n-\t{\n-\t  vec_free (next_path);\n-\t  return;\n-\t}\n-\n-      /* Make sure we haven't already visited any of the nodes in\n-\t NEXT_PATH.  Don't add them here to avoid pollution.  */\n-      for (unsigned int i = 0; i < next_path->length () - 1; i++)\n-\t{\n-\t  if (visited_bbs->contains ((*next_path)[i]))\n-\t    {\n-\t      vec_free (next_path);\n-\t      return;\n-\t    }\n-\t}\n-\n-      /* Now add the nodes to VISISTED_BBS.  */\n-      for (unsigned int i = 0; i < next_path->length () - 1; i++)\n-\tvisited_bbs->add ((*next_path)[i]);\n-\n-      /* Append all the nodes from NEXT_PATH to PATH.  */\n-      vec_safe_splice (path, next_path);\n-      next_path_length = next_path->length ();\n-      vec_free (next_path);\n+      if (!check_subpath_and_update_thread_path (last_bb_in_path, var_bb,\n+\t\t\t\t\t\t visited_bbs, path,\n+\t\t\t\t\t\t &next_path_length))\n+\treturn;\n     }\n \n   gcc_assert (path->last () == var_bb);\n \n-  /* Iterate over the arguments of PHI.  */\n-  unsigned int i;\n   if (gimple_code (def_stmt) == GIMPLE_PHI)\n-    {\n-      gphi *phi = as_a <gphi *> (def_stmt);\n-      for (i = 0; i < gimple_phi_num_args (phi); i++)\n-\t{\n-\t  tree arg = gimple_phi_arg_def (phi, i);\n-\t  basic_block bbi = gimple_phi_arg_edge (phi, i)->src;\n-\n-\t  /* Skip edges pointing outside the current loop.  */\n-\t  if (!arg || var_bb->loop_father != bbi->loop_father)\n-\t    continue;\n-\n-\t  if (TREE_CODE (arg) == SSA_NAME)\n-\t    {\n-\t      vec_safe_push (path, bbi);\n-\t      /* Recursively follow SSA_NAMEs looking for a constant\n-\t\t definition.  */\n-\t      fsm_find_control_statement_thread_paths (arg, visited_bbs, path,\n-\t\t\t\t\t\t       seen_loop_phi, speed_p);\n-\n-\t      path->pop ();\n-\t      continue;\n-\t    }\n-\n-\t  if (TREE_CODE (arg) != INTEGER_CST)\n-\t    continue;\n-\n-\t  /* If this is a profitable jump thread path, then convert it\n-\t     into the canonical form and register it.  */\n-\t  bool irreducible = false;\n-\t  edge taken_edge = profitable_jump_thread_path (path, bbi, name, arg,\n-\t\t\t\t\t\t\t speed_p, &irreducible);\n-\t  if (taken_edge)\n-\t    {\n-\t      convert_and_register_jump_thread_path (path, taken_edge);\n-\t      path->pop ();\n-\n-\t      if (irreducible)\n-\t\tvect_free_loop_info_assumptions ((*path)[0]->loop_father);\n-\t    }\n-\t}\n-    }\n+    handle_phi (as_a <gphi *> (def_stmt), name, var_bb,\n+\t\tvisited_bbs, path, seen_loop_phi, speed_p);\n   else if (gimple_code (def_stmt) == GIMPLE_ASSIGN)\n-    {\n-      tree arg = gimple_assign_rhs1 (def_stmt);\n-\n-      if (TREE_CODE (arg) == SSA_NAME)\n-\tfsm_find_control_statement_thread_paths (arg, visited_bbs,\n-\t\t\t\t\t\t path, seen_loop_phi, speed_p);\n-\n-      else\n-\t{\n-\t  /* profitable_jump_thread_path is going to push the current\n-\t     block onto the path.  But the path will always have the current\n-\t     block at this point.  So we can just pop it.  */\n-\t  path->pop ();\n-\n-\t  bool irreducible = false;\n-\t  edge taken_edge = profitable_jump_thread_path (path, var_bb,\n-\t\t\t\t\t\t         name, arg, speed_p,\n-\t\t\t\t\t\t\t &irreducible);\n-\t  if (taken_edge)\n-\t    {\n-\t      convert_and_register_jump_thread_path (path, taken_edge);\n-\t      path->pop ();\n-\n-\t      if (irreducible)\n-\t\tvect_free_loop_info_assumptions ((*path)[0]->loop_father);\n-\t    }\n-\n-\t  /* And put the current block back onto the path so that the\n-\t     state of the stack is unchanged when we leave.  */\n-\t  vec_safe_push (path, var_bb);\n-\t}\n-    }\n+    handle_assignment (def_stmt, name, var_bb,\n+\t\t       visited_bbs, path, seen_loop_phi, speed_p);\n \n   /* Remove all the nodes that we added from NEXT_PATH.  */\n   if (next_path_length)\n@@ -652,7 +746,7 @@ find_jump_threads_backwards (basic_block bb, bool speed_p)\n   else if (code == GIMPLE_COND)\n     {\n       if (TREE_CODE (gimple_cond_lhs (stmt)) == SSA_NAME\n-\t  && TREE_CODE (gimple_cond_rhs (stmt)) == INTEGER_CST\n+\t  && TREE_CODE_CLASS (TREE_CODE (gimple_cond_rhs (stmt))) == tcc_constant\n \t  && (INTEGRAL_TYPE_P (TREE_TYPE (gimple_cond_lhs (stmt)))\n \t      || POINTER_TYPE_P (TREE_TYPE (gimple_cond_lhs (stmt)))))\n \tname = gimple_cond_lhs (stmt);"}]}