{"sha": "57dbca5e34c7455a47aa4d0a54a10ea26b5ddb8b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTdkYmNhNWUzNGM3NDU1YTQ3YWE0ZDBhNTRhMTBlYTI2YjVkZGI4Yg==", "commit": {"author": {"name": "Bernd Schmidt", "email": "crux@pool.informatik.rwth-aachen.de", "date": "1998-03-12T12:43:42Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1998-03-12T12:43:42Z"}, "message": "i386.c (ix86_logical_operator): New function.\n\n        * i386.c (ix86_logical_operator): New function.\n        (split_di): Ensure that when a MEM is split, the resulting MEMs have\n        SImode.\n        * i386.md (anddi3, xordi3, iordi3): New patterns. Add a define_split\n        to implement them.\n\nFrom-SVN: r18514", "tree": {"sha": "31dcee181d8f939ebc4a43b36beded033d5802ca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/31dcee181d8f939ebc4a43b36beded033d5802ca"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/57dbca5e34c7455a47aa4d0a54a10ea26b5ddb8b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/57dbca5e34c7455a47aa4d0a54a10ea26b5ddb8b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/57dbca5e34c7455a47aa4d0a54a10ea26b5ddb8b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/57dbca5e34c7455a47aa4d0a54a10ea26b5ddb8b/comments", "author": null, "committer": null, "parents": [{"sha": "8625fab57c81a961ed9b8cbfdffeced61149ef4a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8625fab57c81a961ed9b8cbfdffeced61149ef4a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8625fab57c81a961ed9b8cbfdffeced61149ef4a"}], "stats": {"total": 137, "additions": 129, "deletions": 8}, "files": [{"sha": "f339a1eb02f2f7b2a811aef271ec1237125408d5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57dbca5e34c7455a47aa4d0a54a10ea26b5ddb8b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57dbca5e34c7455a47aa4d0a54a10ea26b5ddb8b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=57dbca5e34c7455a47aa4d0a54a10ea26b5ddb8b", "patch": "@@ -1,3 +1,11 @@\n+Thu Mar 12 13:43:25 1998  Bernd Schmidt <crux@Pool.Informatik.RWTH-Aachen.DE>\n+\n+\t* i386.c (ix86_logical_operator): New function.\n+\t(split_di): Ensure that when a MEM is split, the resulting MEMs have\n+\tSImode.\n+\t* i386.md (anddi3, xordi3, iordi3): New patterns. Add a define_split\n+\tto implement them.\n+\n Thu Mar 12 15:13:16 1998  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n                           Richard Earnshaw <rearnsha@arm.com>\n                           Nick Clifton  <nickc@cygnus.com>"}, {"sha": "9f565ae18977b4d751631ba82dc5e7c7b7577d08", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 20, "deletions": 8, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57dbca5e34c7455a47aa4d0a54a10ea26b5ddb8b/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57dbca5e34c7455a47aa4d0a54a10ea26b5ddb8b/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=57dbca5e34c7455a47aa4d0a54a10ea26b5ddb8b", "patch": "@@ -1698,6 +1698,15 @@ arithmetic_comparison_operator (op, mode)\n \n   return (code != GT && code != LE);\n }\n+\n+int\n+ix86_logical_operator (op, mode)\n+     register rtx op;\n+     enum machine_mode mode;\n+{\n+  return GET_CODE (op) == AND || GET_CODE (op) == IOR || GET_CODE (op) == XOR;\n+}\n+\n \f\n /* Returns 1 if OP contains a symbol reference */\n \n@@ -3688,17 +3697,20 @@ split_di (operands, num, lo_half, hi_half)\n {\n   while (num--)\n     {\n-      if (GET_CODE (operands[num]) == REG)\n+      rtx op = operands[num];\n+      if (GET_CODE (op) == REG)\n \t{\n-\t  lo_half[num] = gen_rtx_REG (SImode, REGNO (operands[num]));\n-\t  hi_half[num] = gen_rtx_REG (SImode, REGNO (operands[num]) + 1);\n+\t  lo_half[num] = gen_rtx_REG (SImode, REGNO (op));\n+\t  hi_half[num] = gen_rtx_REG (SImode, REGNO (op) + 1);\n \t}\n-      else if (CONSTANT_P (operands[num]))\n-\tsplit_double (operands[num], &lo_half[num], &hi_half[num]);\n-      else if (offsettable_memref_p (operands[num]))\n+      else if (CONSTANT_P (op))\n+\tsplit_double (op, &lo_half[num], &hi_half[num]);\n+      else if (offsettable_memref_p (op))\n \t{\n-\t  lo_half[num] = operands[num];\n-\t  hi_half[num] = adj_offsettable_operand (operands[num], 4);\n+\t  rtx lo_addr = XEXP (op, 0);\n+\t  rtx hi_addr = XEXP (adj_offsettable_operand (op, 4), 0);\n+\t  lo_half[num] = change_address (op, SImode, lo_addr);\n+\t  hi_half[num] = change_address (op, SImode, hi_addr);\n \t}\n       else\n \tabort();"}, {"sha": "ae084aee83f90c614e3dd4e4fe16acc564788db0", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 101, "deletions": 0, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57dbca5e34c7455a47aa4d0a54a10ea26b5ddb8b/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57dbca5e34c7455a47aa4d0a54a10ea26b5ddb8b/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=57dbca5e34c7455a47aa4d0a54a10ea26b5ddb8b", "patch": "@@ -4253,6 +4253,107 @@ byte_xor_operation:\n   \"\"\n   \"* return AS2 (xor%B0,%2,%0);\")\n \f\n+;; logical operations for DImode\n+\n+\n+(define_insn \"anddi3\"\n+  [(set (match_operand:DI 0 \"general_operand\" \"=&r,&ro,!r,o,!&r,!o,!o\")\n+\t(and:DI (match_operand:DI 1 \"general_operand\" \"%0,0,0,0iF,or,riF,o\")\n+\t\t(match_operand:DI 2 \"general_operand\" \"o,riF,0,or,or,oriF,o\")))\n+   (clobber (match_scratch:SI 3 \"=X,X,X,&r,X,&r,&r\"))]\n+  \"\"\n+  \"#\")\n+\n+(define_insn \"iordi3\"\n+  [(set (match_operand:DI 0 \"general_operand\" \"=&r,&ro,!r,o,!&r,!o,!o\")\n+\t(ior:DI (match_operand:DI 1 \"general_operand\" \"%0,0,0,0iF,or,riF,o\")\n+\t\t(match_operand:DI 2 \"general_operand\" \"o,riF,0,or,or,oriF,o\")))\n+   (clobber (match_scratch:SI 3 \"=X,X,X,&r,X,&r,&r\"))]\n+  \"\"\n+  \"#\")\n+  \n+(define_insn \"xordi3\"\n+  [(set (match_operand:DI 0 \"general_operand\" \"=&r,&ro,!r,o,!&r,!o,!o\")\n+\t(xor:DI (match_operand:DI 1 \"general_operand\" \"%0,0,0,0iF,or,riF,o\")\n+\t\t(match_operand:DI 2 \"general_operand\" \"o,riF,0,or,or,oriF,o\")))\n+   (clobber (match_scratch:SI 3 \"=X,X,X,&r,X,&r,&r\"))]\n+  \"\"\n+  \"#\")\n+\n+(define_split\n+  [(set (match_operand:DI 0 \"general_operand\" \"=&r,&ro,!r,o,!&r,!o,!o\")\n+\t(match_operator:DI 4 \"ix86_logical_operator\"\n+\t  [(match_operand:DI 1 \"general_operand\" \"%0,0,0,0iF,or,riF,o\")\n+\t   (match_operand:DI 2 \"general_operand\" \"o,riF,0,or,or,oriF,o\")]))\n+   (clobber (match_scratch:SI 3 \"=X,X,X,&r,X,&r,&r\"))]\n+  \"reload_completed\"\n+  [(const_int 0)]\n+  \"\n+{\n+  rtx low[3], high[3], xops[7], temp;\n+  rtx (*genfunc)() = (GET_CODE (operands[4]) == AND ? gen_andsi3\n+\t\t      : GET_CODE (operands[4]) == IOR ? gen_iorsi3\n+\t\t      : GET_CODE (operands[4]) == XOR ? gen_xorsi3\n+\t\t      : 0);\n+\n+  if (rtx_equal_p (operands[0], operands[2]))\n+    {\n+      temp = operands[1];\n+      operands[1] = operands[2];\n+      operands[2] = temp;\n+    }\n+\n+  split_di (operands, 3, low, high);\n+  if (!rtx_equal_p (operands[0], operands[1]))\n+    {\n+      xops[0] = high[0];\n+      xops[1] = low[0];\n+      xops[2] = high[1];\n+      xops[3] = low[1];\n+\n+      if (GET_CODE (operands[0]) != MEM)\n+\t{\n+\t  emit_insn (gen_movsi (xops[1], xops[3]));\n+\t  emit_insn (gen_movsi (xops[0], xops[2]));\n+\t}\n+      else\n+\t{\n+\t  xops[4] = high[2];\n+\t  xops[5] = low[2];\n+\t  xops[6] = operands[3];\n+\t  emit_insn (gen_movsi (xops[6], xops[3]));\n+\t  emit_insn ((*genfunc) (xops[6], xops[6], xops[5]));\n+\t  emit_insn (gen_movsi (xops[1], xops[6]));\n+\t  emit_insn (gen_movsi (xops[6], xops[2]));\n+\t  emit_insn ((*genfunc) (xops[6], xops[6], xops[4]));\n+\t  emit_insn (gen_movsi (xops[0], xops[6]));\n+\t  DONE;\n+\t}\n+    }\n+\n+  if (GET_CODE (operands[3]) == REG && GET_CODE (operands[2]) != REG)\n+    {\n+      xops[0] = high[0];\n+      xops[1] = low[0];\n+      xops[2] = high[2];\n+      xops[3] = low[2];\n+      xops[4] = operands[3];\n+\n+      emit_insn (gen_movsi (xops[4], xops[3]));\n+      emit_insn ((*genfunc) (xops[1], xops[1], xops[4]));\n+      emit_insn (gen_movsi (xops[4], xops[2]));\n+      emit_insn ((*genfunc) (xops[0], xops[0], xops[4]));\n+    }\n+\n+  else\n+    {\n+      emit_insn ((*genfunc) (low[0], low[0], low[2]));\n+      emit_insn ((*genfunc) (high[0], high[0], high[2]));\n+    }\n+\n+  DONE;\n+}\")\n+\n ;;- negation instructions\n \n (define_insn \"negdi2\""}]}