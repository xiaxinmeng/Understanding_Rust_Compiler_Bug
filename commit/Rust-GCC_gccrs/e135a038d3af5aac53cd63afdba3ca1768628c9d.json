{"sha": "e135a038d3af5aac53cd63afdba3ca1768628c9d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTEzNWEwMzhkM2FmNWFhYzUzY2Q2M2FmZGJhM2NhMTc2ODYyOGM5ZA==", "commit": {"author": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2004-01-07T20:55:06Z"}, "committer": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2004-01-07T20:55:06Z"}, "message": "[multiple changes]\n\n\n2004-01-07  Gawain Bolton  <gp.bolton@computer.org>\n\n\t* include/bits/stl_list.h:\n\t* include/bits/list.tc:\n\t* src/list.cc:\n        Performance enhancements for destructor, push_front(),\n        push_back(), pop_front(), pop_back(), sort()\n        Eliminated static_casts where possible.\n        Moved code out of header files into new src/list.cc\n        implementation file for library where possible.\n        Remove inheritance from iterator class and create separate\n        classes for non-constant and constant iterators.\n\t* include/bits/stl_tree.h (_Rb_tree class):\n\t* src/tree.cc:\n        Only erase contents in destructor.\n        Eliminate unnecessary initialization in assignment operator.\n        Optimize for the nominal case by not checking whether\n        container is empty in clear().\n        Re-order test in _M_insert() to improve performance.\n        Move initialization of new node's left & right pointers to\n        src/tree.cc to where new node's colour is initialized\n        and to reduce the amount of inline code.\n        Use  _M_leftmost() and _M_end() to improve readability where\n        appropriate.\n        Create separate classes for non-constant and constant\n        iterators to clarify code, avoid extra template parameters and\n        casting away constness.\n\n2004-01-07  Benjamin Kosnik  <bkoz@redhat.com>\n\n\t* src/Makefile.am (sources): Add list.cc, tree.cc.\n\t* src/stl_tree.cc: Move to...\n\t* src/tree.cc: ...here.\n\t* src/list.cc: Add.\n\t* config/linker-map.gnu: Tweaks.\n\t* testsuite/23_containers/map/operators/1_neg.cc: Add excess errors.\n\t* testsuite/23_containers/set/operators/1_neg.cc: Add excess errors.\n\n\t* bits/stl_vector.h: Column wrap comments.\n\nFrom-SVN: r75515", "tree": {"sha": "ed69c0f62c1780d04db24bca830ea61d1a7e875e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ed69c0f62c1780d04db24bca830ea61d1a7e875e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e135a038d3af5aac53cd63afdba3ca1768628c9d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e135a038d3af5aac53cd63afdba3ca1768628c9d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e135a038d3af5aac53cd63afdba3ca1768628c9d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e135a038d3af5aac53cd63afdba3ca1768628c9d/comments", "author": null, "committer": null, "parents": [{"sha": "85b58ca564339627b6c5589e5dba7f5e38a3b065", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/85b58ca564339627b6c5589e5dba7f5e38a3b065", "html_url": "https://github.com/Rust-GCC/gccrs/commit/85b58ca564339627b6c5589e5dba7f5e38a3b065"}], "stats": {"total": 1029, "additions": 659, "deletions": 370}, "files": [{"sha": "efbd7c78368b50e82d9b26c34d71c4570dd918c8", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e135a038d3af5aac53cd63afdba3ca1768628c9d/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e135a038d3af5aac53cd63afdba3ca1768628c9d/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=e135a038d3af5aac53cd63afdba3ca1768628c9d", "patch": "@@ -1,3 +1,43 @@\n+2004-01-07  Gawain Bolton  <gp.bolton@computer.org>\n+\n+\t* include/bits/stl_list.h:\n+\t* include/bits/list.tc:\n+\t* src/list.cc:\n+        Performance enhancements for destructor, push_front(),\n+        push_back(), pop_front(), pop_back(), sort()\n+        Eliminated static_casts where possible.\n+        Moved code out of header files into new src/list.cc\n+        implementation file for library where possible.\n+        Remove inheritance from iterator class and create separate\n+        classes for non-constant and constant iterators.\n+\t* include/bits/stl_tree.h (_Rb_tree class):\n+\t* src/tree.cc: \n+        Only erase contents in destructor.\n+        Eliminate unnecessary initialization in assignment operator.\n+        Optimize for the nominal case by not checking whether\n+        container is empty in clear().\n+        Re-order test in _M_insert() to improve performance.\n+        Move initialization of new node's left & right pointers to\n+        src/tree.cc to where new node's colour is initialized\n+        and to reduce the amount of inline code.\n+        Use  _M_leftmost() and _M_end() to improve readability where\n+        appropriate.\n+        Create separate classes for non-constant and constant\n+        iterators to clarify code, avoid extra template parameters and \n+        casting away constness.\t\t\n+\t\n+2004-01-07  Benjamin Kosnik  <bkoz@redhat.com>\n+\n+\t* src/Makefile.am (sources): Add list.cc, tree.cc.\n+\t* src/stl_tree.cc: Move to...\n+\t* src/tree.cc: ...here.\n+\t* src/list.cc: Add.\n+\t* config/linker-map.gnu: Tweaks.\n+\t* testsuite/23_containers/map/operators/1_neg.cc: Add excess errors.\n+\t* testsuite/23_containers/set/operators/1_neg.cc: Add excess errors.\n+\n+\t* bits/stl_vector.h: Column wrap comments.\n+\t\n 2004-01-07  Loren J. Rittle  <ljrittle@acm.org>\n \n \t(re-open) PR libstdc++/12658"}, {"sha": "2d46e884888e3edfe6b58d585f23725f11f0db7f", "filename": "libstdc++-v3/config/linker-map.gnu", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e135a038d3af5aac53cd63afdba3ca1768628c9d/libstdc%2B%2B-v3%2Fconfig%2Flinker-map.gnu", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e135a038d3af5aac53cd63afdba3ca1768628c9d/libstdc%2B%2B-v3%2Fconfig%2Flinker-map.gnu", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Flinker-map.gnu?ref=e135a038d3af5aac53cd63afdba3ca1768628c9d", "patch": "@@ -112,13 +112,15 @@ GLIBCXX_3.4 {\n     _ZSt9has_facet*;\n \n     # _Rb_tree\n+    _ZSt18_Rb_tree_decrementPKSt18_Rb_tree_node_base;\n     _ZSt18_Rb_tree_decrementPSt18_Rb_tree_node_base;\n+    _ZSt18_Rb_tree_incrementPKSt18_Rb_tree_node_base;\n     _ZSt18_Rb_tree_incrementPSt18_Rb_tree_node_base;\n-    _ZSt18_Rb_tree_rebalancePSt18_Rb_tree_node_baseRS0_;\n     _ZSt20_Rb_tree_black_countPKSt18_Rb_tree_node_baseS1_;\n     _ZSt20_Rb_tree_rotate_leftPSt18_Rb_tree_node_baseRS0_;\n     _ZSt21_Rb_tree_rotate_rightPSt18_Rb_tree_node_baseRS0_;\n     _ZSt28_Rb_tree_rebalance_for_erasePSt18_Rb_tree_node_baseRS_;\n+    _ZSt29_Rb_tree_insert_and_rebalancebPSt18_Rb_tree_node_baseS0_RS_;\n \n     # std::__codecvt_abstract_base*\n     _ZNStSt23__codecvt_abstract_base*;"}, {"sha": "2b50518e44e4268f05ea7e3e21777cde722d6fff", "filename": "libstdc++-v3/include/bits/list.tcc", "status": "modified", "additions": 45, "deletions": 96, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e135a038d3af5aac53cd63afdba3ca1768628c9d/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flist.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e135a038d3af5aac53cd63afdba3ca1768628c9d/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flist.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flist.tcc?ref=e135a038d3af5aac53cd63afdba3ca1768628c9d", "patch": "@@ -77,45 +77,6 @@ namespace __gnu_norm\n         std::_Destroy(&__tmp->_M_data);\n         _M_put_node(__tmp);\n       }\n-      this->_M_node._M_next = &this->_M_node;\n-      this->_M_node._M_prev = &this->_M_node;\n-    }\n-  \n-  template<typename _Tp, typename _Alloc>\n-    void list<_Tp, _Alloc>::\n-    swap(list<_Tp, _Alloc>& __x)\n-    {\n-      if ( this->_M_node._M_next == &this->_M_node )\n-      {\n-        if ( __x._M_node._M_next != &__x._M_node )\n-        {\n-          this->_M_node._M_next = __x._M_node._M_next;\n-          this->_M_node._M_prev = __x._M_node._M_prev;\n-          \n-\t  this->_M_node._M_prev->_M_next = &this->_M_node;\n-          this->_M_node._M_next->_M_prev = this->_M_node._M_prev->_M_next;\n-          __x._M_node._M_next = __x._M_node._M_prev = &__x._M_node;\n-        }\n-      }\n-      else if ( __x._M_node._M_next == &__x._M_node )\n-      {\n-        __x._M_node._M_next = this->_M_node._M_next;\n-        __x._M_node._M_prev = this->_M_node._M_prev;\n-        \n-\t__x._M_node._M_prev->_M_next = &__x._M_node;\n-        __x._M_node._M_next->_M_prev = __x._M_node._M_prev->_M_next;\n-        this->_M_node._M_next = this->_M_node._M_prev = &this->_M_node;\n-      }\n-      else\n-      {\n-        std::swap(this->_M_node._M_next,__x._M_node._M_next);\n-        std::swap(this->_M_node._M_prev,__x._M_node._M_prev);\n-      \n-\tthis->_M_node._M_prev->_M_next = &this->_M_node;\n-        this->_M_node._M_next->_M_prev = this->_M_node._M_prev->_M_next;\n-\t__x._M_node._M_prev->_M_next = &__x._M_node;\n-        __x._M_node._M_next->_M_prev = __x._M_node._M_prev->_M_next;\n-      } \n     }\n  \n   template<typename _Tp, typename _Alloc>\n@@ -124,10 +85,7 @@ namespace __gnu_norm\n     insert(iterator __position, const value_type& __x)\n     {\n       _Node* __tmp = _M_create_node(__x);\n-      __tmp->_M_next = __position._M_node;\n-      __tmp->_M_prev = __position._M_node->_M_prev;\n-      __position._M_node->_M_prev->_M_next = __tmp;\n-      __position._M_node->_M_prev = __tmp;\n+      __tmp->hook(__position._M_node);\n       return __tmp;\n     }\n   \n@@ -136,14 +94,9 @@ namespace __gnu_norm\n     list<_Tp,_Alloc>::\n     erase(iterator __position)\n     {\n-      _List_node_base* __next_node = __position._M_node->_M_next;\n-      _List_node_base* __prev_node = __position._M_node->_M_prev;\n-      _Node* __n = static_cast<_Node*>(__position._M_node);\n-      __prev_node->_M_next = __next_node;\n-      __next_node->_M_prev = __prev_node;\n-      std::_Destroy(&__n->_M_data);\n-      _M_put_node(__n);\n-      return iterator(static_cast<_Node*>(__next_node));\n+      iterator __ret = __position._M_node->_M_next;\n+      _M_erase(__position);\n+      return __ret;\n     }\n   \n   template<typename _Tp, typename _Alloc>\n@@ -226,7 +179,7 @@ namespace __gnu_norm\n         iterator __next = __first;\n         ++__next;\n         if (*__first == __value)\n-          erase(__first);\n+          _M_erase(__first);\n         __first = __next;\n       }\n     }\n@@ -243,7 +196,7 @@ namespace __gnu_norm\n       while (++__next != __last)\n       {\n         if (*__first == *__next)\n-          erase(__next);\n+          _M_erase(__next);\n         else\n           __first = __next;\n         __next = __first;\n@@ -277,19 +230,6 @@ namespace __gnu_norm\n \t}\n     }\n   \n-  // FIXME put this somewhere else\n-  inline void\n-  __List_base_reverse(_List_node_base* __p)\n-  {\n-    _List_node_base* __tmp = __p;\n-    do \n-      {\n-\tstd::swap(__tmp->_M_next, __tmp->_M_prev);\n-\t__tmp = __tmp->_M_prev;     // Old next node is now prev.\n-      } \n-    while (__tmp != __p);\n-  }\n-  \n   template<typename _Tp, typename _Alloc>\n     void\n     list<_Tp,_Alloc>::\n@@ -300,24 +240,28 @@ namespace __gnu_norm\n \t  && this->_M_node._M_next->_M_next != &this->_M_node)\n       {\n         list __carry;\n-        list __counter[64];\n-        int __fill = 0;\n-        while (!empty())\n+        list __tmp[64];\n+        list * __fill = &__tmp[0];\n+        list * __counter;\n+\n+        do\n         {\n           __carry.splice(__carry.begin(), *this, begin());\n-          int __i = 0;\n-          while(__i < __fill && !__counter[__i].empty())\n+\n+          for(__counter = &__tmp[0];\n+              (__counter != __fill) && !__counter->empty();\n+              ++__counter)\n           {\n-            __counter[__i].merge(__carry);\n-            __carry.swap(__counter[__i++]);\n+            __counter->merge(__carry);\n+            __carry.swap(*__counter);\n           }\n-          __carry.swap(__counter[__i]);\n-          if (__i == __fill) ++__fill;\n-        }\n-  \n-        for (int __i = 1; __i < __fill; ++__i)\n-          __counter[__i].merge(__counter[__i-1]);\n-        swap(__counter[__fill-1]);\n+          __carry.swap(*__counter);\n+          if (__counter == __fill) ++__fill;\n+        } while ( !empty() );\n+\n+        for (__counter =  &__tmp[1]; __counter != __fill; ++__counter)\n+          __counter->merge( *(__counter-1) );\n+        swap( *(__fill-1) );\n       }\n     }\n   \n@@ -333,7 +277,7 @@ namespace __gnu_norm\n         {\n           iterator __next = __first;\n           ++__next;\n-          if (__pred(*__first)) erase(__first);\n+          if (__pred(*__first)) _M_erase(__first);\n           __first = __next;\n         }\n       }\n@@ -351,7 +295,7 @@ namespace __gnu_norm\n         while (++__next != __last)\n         {\n           if (__binary_pred(*__first, *__next))\n-            erase(__next);\n+            _M_erase(__next);\n           else\n             __first = __next;\n           __next = __first;\n@@ -397,26 +341,31 @@ namespace __gnu_norm\n \t  this->_M_node._M_next->_M_next != &this->_M_node)\n       {\n         list __carry;\n-        list __counter[64];\n-        int __fill = 0;\n-        while (!empty())\n+        list __tmp[64];\n+        list * __fill = &__tmp[0];\n+        list * __counter;\n+\n+        do\n         {\n           __carry.splice(__carry.begin(), *this, begin());\n-          int __i = 0;\n-          while(__i < __fill && !__counter[__i].empty())\n+\n+          for(__counter = &__tmp[0];\n+              (__counter != __fill) && !__counter->empty();\n+              ++__counter)\n           {\n-            __counter[__i].merge(__carry, __comp);\n-            __carry.swap(__counter[__i++]);\n+            __counter->merge(__carry, __comp);\n+            __carry.swap(*__counter);\n           }\n-          __carry.swap(__counter[__i]);\n-          if (__i == __fill) ++__fill;\n-        }\n-  \n-        for (int __i = 1; __i < __fill; ++__i)\n-          __counter[__i].merge(__counter[__i-1], __comp);\n-        swap(__counter[__fill-1]);\n+          __carry.swap(*__counter);\n+          if (__counter == __fill) ++__fill;\n+        } while ( !empty() );\n+        \n+        for (__counter =  &__tmp[1]; __counter != __fill; ++__counter)\n+          __counter->merge( *(__counter-1), __comp );\n+        swap( *(__fill-1) );\n       }\n     }\n } // namespace __gnu_norm\n \n #endif /* _LIST_TCC */\n+"}, {"sha": "fca21e9ed0cccd3e5bfeb41c06c182b3a0365b7f", "filename": "libstdc++-v3/include/bits/stl_list.h", "status": "modified", "additions": 180, "deletions": 103, "changes": 283, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e135a038d3af5aac53cd63afdba3ca1768628c9d/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_list.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e135a038d3af5aac53cd63afdba3ca1768628c9d/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_list.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_list.h?ref=e135a038d3af5aac53cd63afdba3ca1768628c9d", "patch": "@@ -1,6 +1,6 @@\n // List implementation -*- C++ -*-\n \n-// Copyright (C) 2001, 2002, 2003 Free Software Foundation, Inc.\n+// Copyright (C) 2001, 2002, 2003, 2004 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -75,6 +75,16 @@ namespace __gnu_norm\n   {\n     _List_node_base* _M_next;   ///< Self-explanatory\n     _List_node_base* _M_prev;   ///< Self-explanatory\n+\n+    static void swap(_List_node_base& __x,\n+                     _List_node_base& __y);\n+\n+    void transfer(_List_node_base * const __first,\n+                  _List_node_base * const __last);\n+\n+    void reverse();\n+    void hook(_List_node_base * const __position);\n+    void unhook();\n   };\n   \n   /// @if maint An actual node in the %list.  @endif\n@@ -86,117 +96,173 @@ namespace __gnu_norm\n   \n   \n   /**\n-   *  @if maint\n-   *  @brief Common part of a list::iterator.\n+   *  @brief A list::iterator.\n    *\n-   *  A simple type to walk a doubly-linked list.  All operations here\n-   *  should be self-explanatory after taking any decent introductory\n-   *  data structures course.\n+   *  @if maint\n+   *  All the functions are op overloads.\n    *  @endif\n   */\n-  struct _List_iterator_base\n-  {\n-    typedef size_t                        size_type;\n-    typedef ptrdiff_t                     difference_type;\n-    typedef bidirectional_iterator_tag    iterator_category;\n-  \n-    /// The only member points to the %list element.\n-    _List_node_base* _M_node;\n-  \n-    _List_iterator_base(_List_node_base* __x)\n-    : _M_node(__x) { }\n-  \n-    _List_iterator_base() { }\n-  \n-    /// Walk the %list forward.\n-    void\n-    _M_incr()\n-    { _M_node = _M_node->_M_next; }\n-  \n-    /// Walk the %list backward.\n-    void\n-    _M_decr()\n-    { _M_node = _M_node->_M_prev; }\n+  template<typename _Tp>\n+    struct _List_iterator\n+    {\n+      typedef _List_iterator<_Tp>           _Self;\n+      typedef _List_node<_Tp>               _Node;\n+      \n+      typedef ptrdiff_t                     difference_type;\n+      typedef bidirectional_iterator_tag    iterator_category;\n+      typedef _Tp                           value_type;\n+      typedef _Tp*                          pointer;\n+      typedef _Tp&                          reference;\n+      \n+      _List_iterator() { }\n+\n+      _List_iterator(_List_node_base* __x)\n+      : _M_node(__x) { }\n+\n+      // Must downcast from List_node_base to _List_node to get to _M_data.\n+      reference\n+      operator*() const\n+      { return static_cast<_Node*>(_M_node)->_M_data; }\n+\n+      pointer\n+      operator->() const\n+      { return &static_cast<_Node*>(_M_node)->_M_data; }\n+      \n+      _Self&\n+      operator++()\n+      {\n+\t_M_node = _M_node->_M_next;\n+\treturn *this;\n+      }\n   \n-    bool\n-    operator==(const _List_iterator_base& __x) const\n-    { return _M_node == __x._M_node; }\n+      _Self\n+      operator++(int)\n+      {\n+\t_Self __tmp = *this;\n+\t_M_node = _M_node->_M_next;\n+\treturn __tmp;\n+      }\n+      \n+      _Self&\n+      operator--()\n+      {\n+\t_M_node = _M_node->_M_prev;\n+\treturn *this;\n+      }\n   \n-    bool\n-    operator!=(const _List_iterator_base& __x) const\n-    { return _M_node != __x._M_node; }\n-  };\n+      _Self\n+      operator--(int)\n+      {\n+\t_Self __tmp = *this;\n+\t_M_node = _M_node->_M_prev;\n+\treturn __tmp;\n+      }\n+      \n+      bool\n+      operator==(const _Self& __x) const\n+      { return _M_node == __x._M_node; }\n+\n+      bool\n+      operator!=(const _Self& __x) const\n+      { return _M_node != __x._M_node; }\n+      \n+      // The only member points to the %list element.\n+      _List_node_base* _M_node;\n+    };\n   \n   /**\n-   *  @brief A list::iterator.\n-   *\n-   *  In addition to being used externally, a list holds one of these\n-   *  internally, pointing to the sequence of data.\n+   *  @brief A list::const_iterator.\n    *\n    *  @if maint\n    *  All the functions are op overloads.\n    *  @endif\n   */\n-  template<typename _Tp, typename _Ref, typename _Ptr>\n-    struct _List_iterator : public _List_iterator_base\n+  template<typename _Tp>\n+    struct _List_const_iterator\n     {\n-      typedef _List_iterator<_Tp,_Tp&,_Tp*>             iterator;\n-      typedef _List_iterator<_Tp,const _Tp&,const _Tp*> const_iterator;\n-      typedef _List_iterator<_Tp,_Ref,_Ptr>             _Self;\n-      \n-      typedef _Tp                                       value_type;\n-      typedef _Ptr                                      pointer;\n-      typedef _Ref                                      reference;\n-      typedef _List_node<_Tp>                           _Node;\n+      typedef _List_const_iterator<_Tp>     _Self;\n+      typedef const _List_node<_Tp>         _Node;\n+      typedef _List_iterator<_Tp>           iterator;\n       \n-      _List_iterator(_Node* __x)\n-      : _List_iterator_base(__x) { }\n-  \n-      _List_iterator() { }\n+      typedef ptrdiff_t                     difference_type;\n+      typedef bidirectional_iterator_tag    iterator_category;\n+      typedef _Tp                           value_type;\n+      typedef const _Tp*                    pointer;\n+      typedef const _Tp&                    reference;\n       \n-      _List_iterator(const iterator& __x)\n-      : _List_iterator_base(__x._M_node) { }\n-  \n-      // Must downcast from List_node_base to _List_node to get to _M_data.\n+      _List_const_iterator() { }\n+\n+      _List_const_iterator(const _List_node_base* __x)\n+      : _M_node(__x) { }\n+\n+      _List_const_iterator(const iterator& __x)\n+      : _M_node(__x._M_node) { }\n+\n+      // Must downcast from List_node_base to _List_node to get to\n+      // _M_data.\n       reference\n       operator*() const\n       { return static_cast<_Node*>(_M_node)->_M_data; }\n \n       pointer\n       operator->() const\n-      { return &(operator*()); }\n+      { return &static_cast<_Node*>(_M_node)->_M_data; }\n       \n       _Self&\n       operator++()\n       {\n-\tthis->_M_incr();\n+\t_M_node = _M_node->_M_next;\n \treturn *this;\n       }\n       \n       _Self\n       operator++(int)\n       {\n \t_Self __tmp = *this;\n-\tthis->_M_incr();\n+\t_M_node = _M_node->_M_next;\n \treturn __tmp;\n       }\n       \n       _Self&\n       operator--()\n       {\n-\tthis->_M_decr();\n+\t_M_node = _M_node->_M_prev;\n \treturn *this;\n       }\n-      \n+  \n       _Self\n       operator--(int)\n       {\n \t_Self __tmp = *this;\n-\tthis->_M_decr();\n-      return __tmp;\n+\t_M_node = _M_node->_M_prev;\n+\treturn __tmp;\n       }\n+      \n+      bool\n+      operator==(const _Self& __x) const\n+      { return _M_node == __x._M_node; }\n+      \n+      bool\n+      operator!=(const _Self& __x) const\n+      { return _M_node != __x._M_node; }\n+      \n+      // The only member points to the %list element.\n+      const _List_node_base* _M_node;\n     };\n   \n+  template<typename _Val>\n+    inline bool \n+    operator==(const _List_iterator<_Val>& __x, \n+\t       const _List_const_iterator<_Val>& __y) \n+    { return __x._M_node == __y._M_node; }\n+\n+  template<typename _Val>\n+    inline bool \n+    operator!=(const _List_iterator<_Val>& __x,\n+               const _List_const_iterator<_Val>& __y) \n+    { return __x._M_node != __y._M_node; }\n+\n+  \n   /**\n    *  @if maint\n    *  See bits/stl_deque.h's _Deque_base for an explanation.\n@@ -242,17 +308,21 @@ namespace __gnu_norm\n \n       _List_base(const allocator_type& __a)\n       : _Node_Alloc_type(__a)\n-      {\n-\tthis->_M_node._M_next = &this->_M_node;\n-\tthis->_M_node._M_prev = &this->_M_node;\n-      }\n+      { _M_init(); }\n   \n       // This is what actually destroys the list.\n       ~_List_base()\n       { _M_clear(); }\n       \n       void\n       _M_clear();\n+\n+      void\n+      _M_init()\n+      {\n+        this->_M_node._M_next = &this->_M_node;\n+        this->_M_node._M_prev = &this->_M_node;\n+      }\n     };\n   \n   \n@@ -313,8 +383,8 @@ namespace __gnu_norm\n       typedef _Tp                                       value_type;\n       typedef value_type*                               pointer;\n       typedef const value_type*                         const_pointer;\n-      typedef _List_iterator<_Tp,_Tp&,_Tp*>             iterator;\n-      typedef _List_iterator<_Tp,const _Tp&,const _Tp*> const_iterator;\n+      typedef _List_iterator<_Tp>                       iterator;\n+      typedef _List_const_iterator<_Tp>                 const_iterator;\n       typedef std::reverse_iterator<const_iterator>     const_reverse_iterator;\n       typedef std::reverse_iterator<iterator>           reverse_iterator;\n       typedef value_type&                               reference;\n@@ -511,32 +581,31 @@ namespace __gnu_norm\n        *  %list.  Iteration is done in ordinary element order.\n        */\n       iterator\n-      begin() { return static_cast<_Node*>(this->_M_node._M_next); }\n+      begin() { return this->_M_node._M_next; }\n       \n       /**\n        *  Returns a read-only (constant) iterator that points to the\n        *  first element in the %list.  Iteration is done in ordinary\n        *  element order.\n        */\n       const_iterator\n-      begin() const { return static_cast<_Node*>(this->_M_node._M_next); }\n+      begin() const { return this->_M_node._M_next; }\n       \n       /**\n        *  Returns a read/write iterator that points one past the last\n        *  element in the %list.  Iteration is done in ordinary element\n        *  order.\n        */\n       iterator\n-      end() { return static_cast<_Node*>(&this->_M_node); }\n+      end() { return &this->_M_node; }\n       \n       /**\n        *  Returns a read-only (constant) iterator that points one past\n        *  the last element in the %list.  Iteration is done in ordinary\n        *  element order.\n        */\n       const_iterator\n-      end() const \n-      { return const_cast<_Node*>(static_cast<const _Node*>(&this->_M_node)); }\n+      end() const { return &this->_M_node; }\n       \n       /**\n        *  Returns a read/write reverse iterator that points to the last\n@@ -653,7 +722,7 @@ namespace __gnu_norm\n        *  references.\n        */\n       void\n-      push_front(const value_type& __x) { this->insert(begin(), __x); }\n+      push_front(const value_type& __x) { this->_M_insert(begin(), __x); }\n   \n       /**\n        *  @brief  Removes first element.\n@@ -668,7 +737,7 @@ namespace __gnu_norm\n        *  called.\n        */\n       void\n-      pop_front() { this->erase(begin()); }\n+      pop_front() { this->_M_erase(begin()); }\n       \n       /**\n        *  @brief  Add data to the end of the %list.\n@@ -681,7 +750,7 @@ namespace __gnu_norm\n        *  references.\n        */\n       void\n-      push_back(const value_type& __x) { this->insert(end(), __x); }\n+      push_back(const value_type& __x) { this->_M_insert(end(), __x); }\n       \n       /**\n        *  @brief  Removes last element.\n@@ -695,11 +764,7 @@ namespace __gnu_norm\n        *  is needed, it should be retrieved before pop_back() is called.\n        */\n       void\n-      pop_back()\n-      {\n-\titerator __tmp = end();\n-\tthis->erase(--__tmp);\n-      }\n+      pop_back() { this->_M_erase(this->_M_node._M_prev); }\n       \n       /**\n        *  @brief  Inserts given value into %list before specified iterator.\n@@ -797,7 +862,7 @@ namespace __gnu_norm\n       erase(iterator __first, iterator __last)\n       {\n \twhile (__first != __last)\n-\t  erase(__first++);\n+\t  __first = erase(__first);\n \treturn __last;\n       }\n   \n@@ -811,7 +876,7 @@ namespace __gnu_norm\n        *  function.\n        */\n       void\n-      swap(list& __x);\n+      swap(list& __x) { _List_node_base::swap(this->_M_node,__x._M_node); }\n   \n       /**\n        *  Erases all the elements.  Note that this function only erases\n@@ -820,7 +885,11 @@ namespace __gnu_norm\n        *  Managing the pointer is the user's responsibilty.\n        */\n       void\n-      clear() { _Base::_M_clear(); }\n+      clear()\n+      {\n+        _Base::_M_clear();\n+        _Base::_M_init();\n+      }\n   \n       // [23.2.2.4] list operations\n       /**\n@@ -968,7 +1037,7 @@ namespace __gnu_norm\n        *  Reverse the order of elements in the list in linear time.\n        */\n       void\n-      reverse() { __List_base_reverse(&this->_M_node); }\n+      reverse() { this->_M_node.reverse(); }\n   \n       /**\n        *  @brief  Sort the elements.\n@@ -1033,7 +1102,7 @@ namespace __gnu_norm\n \t\t\t   __false_type)\n         {\n \t  for ( ; __first != __last; ++__first)\n-\t    insert(__pos, *__first);\n+\t    _M_insert(__pos, *__first);\n \t}\n       \n       // Called by insert(p,n,x), and the range insert when it turns out\n@@ -1042,27 +1111,34 @@ namespace __gnu_norm\n       _M_fill_insert(iterator __pos, size_type __n, const value_type& __x)\n       {\n \tfor ( ; __n > 0; --__n)\n-\t  insert(__pos, __x);\n+\t  _M_insert(__pos, __x);\n       }\n       \n       \n       // Moves the elements from [first,last) before position.\n       void\n       _M_transfer(iterator __position, iterator __first, iterator __last)\n       {\n-\tif (__position != __last) \n-\t  {\n-\t    // Remove [first, last) from its old position.\n-\t    __last._M_node->_M_prev->_M_next     = __position._M_node;\n-\t    __first._M_node->_M_prev->_M_next    = __last._M_node;\n-\t    __position._M_node->_M_prev->_M_next = __first._M_node;\n-\t    \n-\t    // Splice [first, last) into its new position.\n-\t    _List_node_base* __tmp      = __position._M_node->_M_prev;\n-\t    __position._M_node->_M_prev = __last._M_node->_M_prev;\n-\t    __last._M_node->_M_prev     = __first._M_node->_M_prev;\n-\t    __first._M_node->_M_prev    = __tmp;\n-\t  }\n+        __position._M_node->transfer(__first._M_node,__last._M_node);\n+      }\n+\n+      // Inserts new element at position given and with value given.\n+      void\n+      _M_insert(iterator __position, const value_type& __x)\n+      {\n+        _Node* __tmp = _M_create_node(__x);\n+\n+        __tmp->hook(__position._M_node);\n+      }\n+\n+      // Erases element at position given.\n+      void\n+      _M_erase(iterator __position)\n+      {\n+        __position._M_node->unhook();\n+        _Node* __n = static_cast<_Node*>(__position._M_node);\n+        std::_Destroy(&__n->_M_data);\n+        _M_put_node(__n);\n       }\n     };\n   \n@@ -1146,3 +1222,4 @@ namespace __gnu_norm\n } // namespace __gnu_norm\n \n #endif /* _LIST_H */\n+"}, {"sha": "81428b28876768e0bb5cd3c7c946c102d0ae281f", "filename": "libstdc++-v3/include/bits/stl_tree.h", "status": "modified", "additions": 133, "deletions": 107, "changes": 240, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e135a038d3af5aac53cd63afdba3ca1768628c9d/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e135a038d3af5aac53cd63afdba3ca1768628c9d/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_tree.h?ref=e135a038d3af5aac53cd63afdba3ca1768628c9d", "patch": "@@ -141,36 +141,34 @@ namespace std\n   _Rb_tree_node_base*\n   _Rb_tree_increment(_Rb_tree_node_base* __x);\n \n+  const _Rb_tree_node_base*\n+  _Rb_tree_increment(const _Rb_tree_node_base* __x);\n+\n   _Rb_tree_node_base*\n   _Rb_tree_decrement(_Rb_tree_node_base* __x);\n \n-  template<typename _Val, typename _Ref, typename _Ptr>\n+  const _Rb_tree_node_base*\n+  _Rb_tree_decrement(const _Rb_tree_node_base* __x);\n+\n+  template<typename _Tp>\n     struct _Rb_tree_iterator\n     {\n-      typedef _Val value_type;\n-      typedef _Ref reference;\n-      typedef _Ptr pointer;\n-      typedef _Rb_tree_iterator<_Val, _Val&, _Val*> iterator;\n-      typedef _Rb_tree_iterator<_Val, const _Val&, const _Val*> \n-      const_iterator;\n-      typedef _Rb_tree_node_base::_Base_ptr _Base_ptr;\n+      typedef _Tp  value_type;\n+      typedef _Tp& reference;\n+      typedef _Tp* pointer;\n+\n       typedef bidirectional_iterator_tag iterator_category;\n-      typedef ptrdiff_t difference_type;\n-      typedef _Rb_tree_iterator<_Val, _Ref, _Ptr> _Self;\n-      typedef _Rb_tree_node<_Val>* _Link_type;\n-      typedef const _Rb_tree_node<_Val>* _Const_Link_type;\n+      typedef ptrdiff_t                  difference_type;\n+\n+      typedef _Rb_tree_iterator<_Tp>        _Self;\n+      typedef _Rb_tree_node_base::_Base_ptr _Base_ptr;\n+      typedef _Rb_tree_node<_Tp>*           _Link_type;\n       \n       _Rb_tree_iterator() {}\n \n       _Rb_tree_iterator(_Link_type __x)\n       : _M_node(__x) {}\n \n-      _Rb_tree_iterator(_Const_Link_type __x)\n-      : _M_node(const_cast<_Link_type>(__x)) {}\n-\n-      _Rb_tree_iterator(const iterator& __it)\n-      : _M_node(__it._M_node) {}\n-\n       reference \n       operator*() const\n       { return static_cast<_Link_type>(_M_node)->_M_value_field; }\n@@ -209,53 +207,115 @@ namespace std\n \treturn __tmp;\n       }\n \n+      bool\n+      operator==(const _Self& __x) const\n+      { return _M_node == __x._M_node; }\n+\n+      bool\n+      operator!=(const _Self& __x) const\n+      { return _M_node != __x._M_node; }\n+\n       _Base_ptr _M_node;\n   };\n \n-  template<typename _Val, typename _Ref, typename _Ptr>\n-    inline bool \n-    operator==(const _Rb_tree_iterator<_Val, _Ref, _Ptr>& __x,\n-\t       const _Rb_tree_iterator<_Val, _Ref, _Ptr>& __y) \n-    { return __x._M_node == __y._M_node; }\n+  template<typename _Tp>\n+    struct _Rb_tree_const_iterator\n+    {\n+      typedef _Tp        value_type;\n+      typedef const _Tp& reference;\n+      typedef const _Tp* pointer;\n \n-  template<typename _Val>\n-    inline bool \n-    operator==(const _Rb_tree_iterator<_Val, const _Val&, const _Val*>& __x,\n-\t       const _Rb_tree_iterator<_Val, _Val&, _Val*>& __y) \n-    { return __x._M_node == __y._M_node; }\n+      typedef _Rb_tree_iterator<_Tp> iterator;\n \n-  template<typename _Val>\n-    inline bool \n-    operator==(const _Rb_tree_iterator<_Val, _Val&, _Val*>& __x,\n-\t       const _Rb_tree_iterator<_Val, const _Val&, const _Val*>& __y) \n-    { return __x._M_node == __y._M_node; }\n+      typedef bidirectional_iterator_tag iterator_category;\n+      typedef ptrdiff_t                  difference_type;\n \n-  template<typename _Val, typename _Ref, typename _Ptr>\n-    inline bool \n-    operator!=(const _Rb_tree_iterator<_Val, _Ref, _Ptr>& __x,\n-\t       const _Rb_tree_iterator<_Val, _Ref, _Ptr>& __y) \n-    { return __x._M_node != __y._M_node; }\n+      typedef _Rb_tree_const_iterator<_Tp>        _Self;\n+      typedef _Rb_tree_node_base::_Const_Base_ptr _Base_ptr;\n+      typedef const _Rb_tree_node<_Tp>*           _Link_type;\n+      \n+      _Rb_tree_const_iterator() {}\n+\n+      _Rb_tree_const_iterator(_Link_type __x)\n+      : _M_node(__x) {}\n+\n+      _Rb_tree_const_iterator(const iterator& __it)\n+      : _M_node(__it._M_node) {}\n+\n+      reference\n+      operator*() const\n+      { return static_cast<_Link_type>(_M_node)->_M_value_field; }\n+\n+      pointer\n+      operator->() const\n+      { return &static_cast<_Link_type>(_M_node)->_M_value_field; }\n+\n+      _Self& \n+      operator++() \n+      { \n+\t_M_node = _Rb_tree_increment(_M_node);\n+\treturn *this; \n+      }\n+\n+      _Self \n+      operator++(int) \n+      {\n+\t_Self __tmp = *this;\n+\t_M_node = _Rb_tree_increment(_M_node);\n+\treturn __tmp;\n+      }\n+    \n+      _Self& \n+      operator--()\n+      {\n+\t_M_node = _Rb_tree_decrement(_M_node);\n+\treturn *this;\n+      }\n+\n+      _Self \n+      operator--(int) \n+      {\n+\t_Self __tmp = *this;\n+\t_M_node = _Rb_tree_decrement(_M_node);\n+\treturn __tmp;\n+      }\n+\n+      bool\n+      operator==(const _Self& __x) const\n+      { return _M_node == __x._M_node; }\n+\n+      bool\n+      operator!=(const _Self& __x) const\n+      { return _M_node != __x._M_node; }\n+\n+      _Base_ptr _M_node;\n+  };\n \n   template<typename _Val>\n     inline bool \n-    operator!=(const _Rb_tree_iterator<_Val, const _Val&, const _Val*>& __x,\n-\t       const _Rb_tree_iterator<_Val, _Val&, _Val*>& __y) \n-    { return __x._M_node != __y._M_node; }\n+    operator==(const _Rb_tree_iterator<_Val>& __x,\n+               const _Rb_tree_const_iterator<_Val>& __y) \n+    { return __x._M_node == __y._M_node; }\n \n   template<typename _Val>\n     inline bool \n-    operator!=(const _Rb_tree_iterator<_Val, _Val&, _Val*>& __x,\n-\t       const _Rb_tree_iterator<_Val, const _Val&, const _Val*>& __y) \n+    operator!=(const _Rb_tree_iterator<_Val>& __x,\n+               const _Rb_tree_const_iterator<_Val>& __y) \n     { return __x._M_node != __y._M_node; }\n \n   void \n-  _Rb_tree_rotate_left(_Rb_tree_node_base* const __x, _Rb_tree_node_base*& __root);\n+  _Rb_tree_rotate_left(_Rb_tree_node_base* const __x,\n+                       _Rb_tree_node_base*& __root);\n \n   void \n-  _Rb_tree_rotate_right(_Rb_tree_node_base* const __x, _Rb_tree_node_base*& __root);\n+  _Rb_tree_rotate_right(_Rb_tree_node_base* const __x,\n+                        _Rb_tree_node_base*& __root);\n \n   void \n-  _Rb_tree_rebalance(_Rb_tree_node_base* __x, _Rb_tree_node_base*& __root);\n+  _Rb_tree_insert_and_rebalance(const bool          __insert_left,\n+                                _Rb_tree_node_base* __x,\n+                                _Rb_tree_node_base* __p,\n+                                _Rb_tree_node_base& __header);\n \n   _Rb_tree_node_base*\n   _Rb_tree_rebalance_for_erase(_Rb_tree_node_base* const __z, \n@@ -407,12 +467,11 @@ namespace std\n       { return _Rb_tree_node_base::_S_maximum(__x); }\n \n     public:\n-      typedef _Rb_tree_iterator<value_type, reference, pointer> iterator;\n-      typedef _Rb_tree_iterator<value_type, const_reference, const_pointer> \n-      const_iterator;\n+      typedef _Rb_tree_iterator<value_type>       iterator;\n+      typedef _Rb_tree_const_iterator<value_type> const_iterator;\n \n+      typedef std::reverse_iterator<iterator>       reverse_iterator;\n       typedef std::reverse_iterator<const_iterator> const_reverse_iterator;\n-      typedef std::reverse_iterator<iterator> reverse_iterator;\n \n     private:\n       iterator \n@@ -461,7 +520,7 @@ namespace std\n \t_M_node_count = __x._M_node_count;\n       }\n \n-      ~_Rb_tree() { clear(); }\n+      ~_Rb_tree() { _M_erase(_M_begin()); }\n \n       _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>& \n       operator=(const _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>& __x);\n@@ -550,18 +609,15 @@ namespace std\n       void \n       erase(const key_type* __first, const key_type* __last);\n \n-      void \n-      clear() \n+      void\n+      clear()\n       {\n-\tif (_M_node_count != 0) \n-\t  {\n-\t    _M_erase(_M_begin());\n-\t    _M_leftmost() = _M_end();\n-\t    _M_root() = 0;\n-\t    _M_rightmost() = _M_end();\n-\t    _M_node_count = 0;\n-\t  }\n-      }      \n+        _M_erase(_M_begin());\n+        _M_leftmost() = _M_end();\n+        _M_root() = 0;\n+        _M_rightmost() = _M_end();\n+        _M_node_count = 0;\n+      }\n \n       // Set operations.\n       iterator \n@@ -661,15 +717,8 @@ namespace std\n \t{\n \t  // Note that _Key may be a constant type.\n \t  clear();\n-\t  _M_node_count = 0;\n \t  _M_key_compare = __x._M_key_compare;        \n-\t  if (__x._M_root() == 0) \n-\t    {\n-\t      _M_root() = 0;\n-\t      _M_leftmost() = _M_end();\n-\t      _M_rightmost() = _M_end();\n-\t    }\n-\t  else \n+\t  if (__x._M_root() != 0) \n \t    {\n \t      _M_root() = _M_copy(__x._M_begin(), _M_end());\n \t      _M_leftmost() = _S_minimum(_M_root());\n@@ -684,38 +733,15 @@ namespace std\n            typename _Compare, typename _Alloc>\n     typename _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator\n     _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::\n-    _M_insert(_Base_ptr __x_, _Base_ptr __y_, const _Val& __v)\n+    _M_insert(_Base_ptr __x, _Base_ptr __p, const _Val& __v)\n     {\n-      _Link_type __x = static_cast<_Link_type>(__x_);\n-      _Link_type __y = static_cast<_Link_type>(__y_);\n-      _Link_type __z;\n-      \n-      if (__y == &this->_M_header || __x != 0 || \n-\t  _M_key_compare(_KeyOfValue()(__v), _S_key(__y))) \n-\t{\n-\t  __z = _M_create_node(__v);\n-\t  __y->_M_left = __z;               // also makes _M_leftmost() = __z\n-\t  //    when __y == &_M_header\n-\t  if (__y == &this->_M_header) \n-\t    {\n-\t      _M_root() = __z;\n-\t      _M_rightmost() = __z;\n-\t    }\n-\t  else if (__y == _M_leftmost())\n-\t    _M_leftmost() = __z; // maintain _M_leftmost() pointing to min node\n-\t}\n-      else \n-\t{\n-\t  __z = _M_create_node(__v);\n-\t  __y->_M_right = __z;\n-\t  // Maintain _M_rightmost() pointing to max node.\n-\t  if (__y == _M_rightmost())\n-\t    _M_rightmost() = __z; \n-\t}\n-      __z->_M_parent = __y;\n-      __z->_M_left = 0;\n-      __z->_M_right = 0;\n-      _Rb_tree_rebalance(__z, this->_M_header._M_parent);\n+      _Link_type __z = _M_create_node(__v);\n+      bool __insert_left;\n+\n+      __insert_left = __x != 0 || __p == _M_end() ||\n+                      _M_key_compare(_KeyOfValue()(__v), _S_key(__p));\n+\n+      _Rb_tree_insert_and_rebalance(__insert_left, __z, __p,  this->_M_header);\n       ++_M_node_count;\n       return iterator(__z);\n     }\n@@ -816,7 +842,7 @@ namespace std\n     _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::\n     insert_unique(iterator __position, const _Val& __v)\n     {\n-      if (__position._M_node == this->_M_header._M_left) \n+      if (__position._M_node == _M_leftmost())\n \t{ \n \t  // begin()\n \t  if (size() > 0 && \n@@ -826,7 +852,7 @@ namespace std\n \t  else\n \t    return insert_unique(__v).first;\n \t} \n-      else if (__position._M_node == &this->_M_header) \n+      else if (__position._M_node == _M_end()) \n \t{ \n \t  // end()\n \t  if (_M_key_compare(_S_key(_M_rightmost()), _KeyOfValue()(__v)))\n@@ -858,7 +884,7 @@ namespace std\n     _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::\n     insert_equal(iterator __position, const _Val& __v)\n     {\n-      if (__position._M_node == this->_M_header._M_left) \n+      if (__position._M_node == _M_leftmost())\n \t{ \n \t  // begin()\n \t  if (size() > 0 && \n@@ -868,7 +894,7 @@ namespace std\n \t  else\n \t    return insert_equal(__v);\n \t} \n-      else if (__position._M_node == &this->_M_header) \n+      else if (__position._M_node == _M_end()) \n \t{\n \t  // end()\n \t  if (!_M_key_compare(_KeyOfValue()(__v), _S_key(_M_rightmost())))\n@@ -1168,8 +1194,8 @@ namespace std\n     {\n     if (_M_node_count == 0 || begin() == end())\n       return _M_node_count == 0 && begin() == end() &&\n-\tthis->_M_header._M_left == &this->_M_header &&\n-\tthis->_M_header._M_right == &this->_M_header;\n+\tthis->_M_header._M_left == _M_end() &&\n+\tthis->_M_header._M_right == _M_end();\n   \n     unsigned int __len = _Rb_tree_black_count(_M_leftmost(), _M_root());\n     for (const_iterator __it = begin(); __it != end(); ++__it) "}, {"sha": "83d13ad028ea96e4c7741e8cb6c6977b3e7bdaf6", "filename": "libstdc++-v3/include/bits/stl_vector.h", "status": "modified", "additions": 48, "deletions": 37, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e135a038d3af5aac53cd63afdba3ca1768628c9d/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_vector.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e135a038d3af5aac53cd63afdba3ca1768628c9d/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_vector.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_vector.h?ref=e135a038d3af5aac53cd63afdba3ca1768628c9d", "patch": "@@ -112,8 +112,8 @@ namespace __gnu_norm\n   \n   \n   /**\n-   *  @brief  A standard container which offers fixed time access to individual\n-   *  elements in any order.\n+   *  @brief A standard container which offers fixed time access to\n+   *  individual elements in any order.\n    *\n    *  @ingroup Containers\n    *  @ingroup Sequences\n@@ -124,10 +124,11 @@ namespace __gnu_norm\n    *  <a href=\"tables.html#68\">optional sequence requirements</a> with the\n    *  %exception of @c push_front and @c pop_front.\n    *\n-   *  In some terminology a %vector can be described as a dynamic C-style array,\n-   *  it offers fast and efficient access to individual elements in any order\n-   *  and saves the user from worrying about memory and size allocation.\n-   *  Subscripting ( @c [] ) access is also provided as with C-style arrays.\n+   *  In some terminology a %vector can be described as a dynamic\n+   *  C-style array, it offers fast and efficient access to individual\n+   *  elements in any order and saves the user from worrying about\n+   *  memory and size allocation.  Subscripting ( @c [] ) access is\n+   *  also provided as with C-style arrays.\n   */\n   template<typename _Tp, typename _Alloc = allocator<_Tp> >\n     class vector : protected _Vector_base<_Tp, _Alloc>\n@@ -185,7 +186,8 @@ namespace __gnu_norm\n       vector(size_type __n, const value_type& __value,\n \t     const allocator_type& __a = allocator_type())\n       : _Base(__n, __a)\n-      { this->_M_finish = std::uninitialized_fill_n(this->_M_start, __n, __value); }\n+      { this->_M_finish = std::uninitialized_fill_n(this->_M_start, \n+\t\t\t\t\t\t    __n, __value); }\n   \n       /**\n        *  @brief  Create a %vector with default elements.\n@@ -223,11 +225,12 @@ namespace __gnu_norm\n        *  Create a %vector consisting of copies of the elements from\n        *  [first,last).\n        *\n-       *  If the iterators are forward, bidirectional, or random-access, then\n-       *  this will call the elements' copy constructor N times (where N is\n-       *  distance(first,last)) and do no memory reallocation.  But if only\n-       *  input iterators are used, then this will do at most 2N calls to the\n-       *  copy constructor, and logN memory reallocations.\n+       *  If the iterators are forward, bidirectional, or\n+       *  random-access, then this will call the elements' copy\n+       *  constructor N times (where N is distance(first,last)) and do\n+       *  no memory reallocation.  But if only input iterators are\n+       *  used, then this will do at most 2N calls to the copy\n+       *  constructor, and logN memory reallocations.\n        */\n       template<typename _InputIterator>\n         vector(_InputIterator __first, _InputIterator __last,\n@@ -240,9 +243,10 @@ namespace __gnu_norm\n \t}\n       \n       /**\n-       *  The dtor only erases the elements, and note that if the elements\n-       *  themselves are pointers, the pointed-to memory is not touched in any\n-       *  way.  Managing the pointer is the user's responsibilty.\n+       *  The dtor only erases the elements, and note that if the\n+       *  elements themselves are pointers, the pointed-to memory is\n+       *  not touched in any way.  Managing the pointer is the user's\n+       *  responsibilty.\n        */\n       ~vector() { std::_Destroy(this->_M_start, this->_M_finish); }\n   \n@@ -297,8 +301,9 @@ namespace __gnu_norm\n       \n       // iterators\n       /**\n-       *  Returns a read/write iterator that points to the first element in the\n-       *  %vector.  Iteration is done in ordinary element order.\n+       *  Returns a read/write iterator that points to the first\n+       *  element in the %vector.  Iteration is done in ordinary\n+       *  element order.\n        */\n       iterator\n       begin() { return iterator (this->_M_start); }\n@@ -320,8 +325,9 @@ namespace __gnu_norm\n       end() { return iterator (this->_M_finish); }\n       \n       /**\n-       *  Returns a read-only (constant) iterator that points one past the last\n-       *  element in the %vector.  Iteration is done in ordinary element order.\n+       *  Returns a read-only (constant) iterator that points one past\n+       *  the last element in the %vector.  Iteration is done in\n+       *  ordinary element order.\n        */\n       const_iterator\n       end() const { return const_iterator (this->_M_finish); }\n@@ -343,9 +349,9 @@ namespace __gnu_norm\n       rbegin() const { return const_reverse_iterator(end()); }\n       \n       /**\n-       *  Returns a read/write reverse iterator that points to one before the\n-       *  first element in the %vector.  Iteration is done in reverse element\n-       *  order.\n+       *  Returns a read/write reverse iterator that points to one\n+       *  before the first element in the %vector.  Iteration is done\n+       *  in reverse element order.\n        */\n       reverse_iterator\n       rend() { return reverse_iterator(begin()); }\n@@ -401,8 +407,8 @@ namespace __gnu_norm\n       resize(size_type __new_size) { resize(__new_size, value_type()); }\n       \n       /**\n-       *  Returns the total number of elements that the %vector can hold before\n-       *  needing to allocate more memory.\n+       *  Returns the total number of elements that the %vector can\n+       *  hold before needing to allocate more memory.\n        */\n       size_type\n       capacity() const\n@@ -438,7 +444,8 @@ namespace __gnu_norm\n       // element access\n       /**\n        *  @brief  Subscript access to the data contained in the %vector.\n-       *  @param  n  The index of the element for which data should be accessed.\n+       *  @param n The index of the element for which data should be\n+       *  accessed.\n        *  @return  Read/write reference to data.\n        *\n        *  This operator allows for easy, array-style, data access.\n@@ -480,9 +487,9 @@ namespace __gnu_norm\n        *  @return  Read/write reference to data.\n        *  @throw  std::out_of_range  If @a n is an invalid index.\n        *\n-       *  This function provides for safer data access.  The parameter is first\n-       *  checked that it is in the range of the vector.  The function throws\n-       *  out_of_range if the check fails.\n+       *  This function provides for safer data access.  The parameter\n+       *  is first checked that it is in the range of the vector.  The\n+       *  function throws out_of_range if the check fails.\n        */\n       reference\n       at(size_type __n) { _M_range_check(__n); return (*this)[__n]; }\n@@ -516,15 +523,15 @@ namespace __gnu_norm\n       front() const { return *begin(); }\n       \n       /**\n-       *  Returns a read/write reference to the data at the last element of the\n-       *  %vector.\n+       *  Returns a read/write reference to the data at the last\n+       *  element of the %vector.\n        */\n       reference\n       back() { return *(end() - 1); }\n       \n       /**\n-       *  Returns a read-only (constant) reference to the data at the last\n-       *  element of the %vector.\n+       *  Returns a read-only (constant) reference to the data at the\n+       *  last element of the %vector.\n        */\n       const_reference\n       back() const { return *(end() - 1); }\n@@ -557,8 +564,9 @@ namespace __gnu_norm\n        *\n        *  This is a typical stack operation. It shrinks the %vector by one.\n        *\n-       *  Note that no data is returned, and if the last element's data is\n-       *  needed, it should be retrieved before pop_back() is called.\n+       *  Note that no data is returned, and if the last element's\n+       *  data is needed, it should be retrieved before pop_back() is\n+       *  called.\n        */\n       void\n       pop_back()\n@@ -614,7 +622,8 @@ namespace __gnu_norm\n        */\n       template<typename _InputIterator>\n         void\n-        insert(iterator __position, _InputIterator __first, _InputIterator __last)\n+        insert(iterator __position, _InputIterator __first, \n+\t       _InputIterator __last)\n         {\n \t  // Check whether it's an integral type.  If so, it's not an iterator.\n \t  typedef typename _Is_integer<_InputIterator>::_Integral _Integral;\n@@ -721,7 +730,8 @@ namespace __gnu_norm\n         {\n \t  this->_M_start = _M_allocate(__n);\n \t  this->_M_end_of_storage = this->_M_start + __n;\n-\t  this->_M_finish = std::uninitialized_fill_n(this->_M_start, __n, __value);\n+\t  this->_M_finish = std::uninitialized_fill_n(this->_M_start, \n+\t\t\t\t\t\t      __n, __value);\n \t}\n       \n       // Called by the range constructor to implement [23.1.1]/9\n@@ -774,7 +784,8 @@ namespace __gnu_norm\n       // Called by the range assign to implement [23.1.1]/9\n       template<typename _InputIterator>\n         void\n-        _M_assign_dispatch(_InputIterator __first, _InputIterator __last, __false_type)\n+        _M_assign_dispatch(_InputIterator __first, _InputIterator __last, \n+\t\t\t   __false_type)\n         {\n \t  typedef typename iterator_traits<_InputIterator>::iterator_category\n \t    _IterCategory;"}, {"sha": "3b4f67501c51d96d1c0f1fc2e3bd13bd4b21410b", "filename": "libstdc++-v3/src/Makefile.am", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e135a038d3af5aac53cd63afdba3ca1768628c9d/libstdc%2B%2B-v3%2Fsrc%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e135a038d3af5aac53cd63afdba3ca1768628c9d/libstdc%2B%2B-v3%2Fsrc%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2FMakefile.am?ref=e135a038d3af5aac53cd63afdba3ca1768628c9d", "patch": "@@ -104,13 +104,14 @@ sources = \\\n \tios_init.cc \\\n \tios_locale.cc \\\n \tlimits.cc \\\n+\tlist.cc \\\n \tlocale.cc \\\n \tlocale_init.cc \\\n \tlocale_facets.cc \\\n \tlocalename.cc \\\n \tstdexcept.cc \\\n-\tstl_tree.cc \\\n \tstrstream.cc \\\n+\ttree.cc \\\n \tallocator-inst.cc \\\n \tconcept-inst.cc \\\n \tfstream-inst.cc \\"}, {"sha": "d6cc47cbb8884dc0ff83df6016da71cb56617ede", "filename": "libstdc++-v3/src/Makefile.in", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e135a038d3af5aac53cd63afdba3ca1768628c9d/libstdc%2B%2B-v3%2Fsrc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e135a038d3af5aac53cd63afdba3ca1768628c9d/libstdc%2B%2B-v3%2Fsrc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2FMakefile.in?ref=e135a038d3af5aac53cd63afdba3ca1768628c9d", "patch": "@@ -260,13 +260,14 @@ sources = \\\n \tios_init.cc \\\n \tios_locale.cc \\\n \tlimits.cc \\\n+\tlist.cc \\\n \tlocale.cc \\\n \tlocale_init.cc \\\n \tlocale_facets.cc \\\n \tlocalename.cc \\\n \tstdexcept.cc \\\n-\tstl_tree.cc \\\n \tstrstream.cc \\\n+\ttree.cc \\\n \tallocator-inst.cc \\\n \tconcept-inst.cc \\\n \tfstream-inst.cc \\\n@@ -361,13 +362,13 @@ am__objects_1 = codecvt_members.lo collate_members.lo ctype_members.lo \\\n am__objects_2 = basic_file.lo c++locale.lo\n am__objects_3 = codecvt.lo complex_io.lo ctype.lo debug.lo demangle.lo \\\n \tfunctexcept.lo globals_locale.lo globals_io.lo ios.lo \\\n-\tios_failure.lo ios_init.lo ios_locale.lo limits.lo locale.lo \\\n-\tlocale_init.lo locale_facets.lo localename.lo stdexcept.lo \\\n-\tstl_tree.lo strstream.lo allocator-inst.lo concept-inst.lo \\\n-\tfstream-inst.lo ext-inst.lo io-inst.lo istream-inst.lo \\\n-\tlocale-inst.lo locale-misc-inst.lo misc-inst.lo ostream-inst.lo \\\n-\tsstream-inst.lo streambuf-inst.lo string-inst.lo \\\n-\tvalarray-inst.lo wlocale-inst.lo wstring-inst.lo \\\n+\tios_failure.lo ios_init.lo ios_locale.lo limits.lo list.lo \\\n+\tlocale.lo locale_init.lo locale_facets.lo localename.lo \\\n+\tstdexcept.lo strstream.lo tree.lo allocator-inst.lo \\\n+\tconcept-inst.lo fstream-inst.lo ext-inst.lo io-inst.lo \\\n+\tistream-inst.lo locale-inst.lo locale-misc-inst.lo misc-inst.lo \\\n+\tostream-inst.lo sstream-inst.lo streambuf-inst.lo \\\n+\tstring-inst.lo valarray-inst.lo wlocale-inst.lo wstring-inst.lo \\\n \t$(am__objects_1) $(am__objects_2)\n am_libstdc___la_OBJECTS = $(am__objects_3)\n libstdc___la_OBJECTS = $(am_libstdc___la_OBJECTS)"}, {"sha": "2be2d7131938b752984c62653a37771502e0a113", "filename": "libstdc++-v3/src/list.cc", "status": "added", "additions": 141, "deletions": 0, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e135a038d3af5aac53cd63afdba3ca1768628c9d/libstdc%2B%2B-v3%2Fsrc%2Flist.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e135a038d3af5aac53cd63afdba3ca1768628c9d/libstdc%2B%2B-v3%2Fsrc%2Flist.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Flist.cc?ref=e135a038d3af5aac53cd63afdba3ca1768628c9d", "patch": "@@ -0,0 +1,141 @@\n+// std::list utilities implementation -*- C++ -*-\n+\n+// Copyright (C) 2003 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+/*\n+ *\n+ * Copyright (c) 1994\n+ * Hewlett-Packard Company\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Hewlett-Packard Company makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ *\n+ *\n+ * Copyright (c) 1996,1997\n+ * Silicon Graphics Computer Systems, Inc.\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Silicon Graphics makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ */\n+\n+#include <list>\n+\n+namespace __gnu_norm\n+{\n+  void\n+  _List_node_base::swap(_List_node_base& __x, _List_node_base& __y)\n+  {\n+    if ( __x._M_next != &__x )\n+    {\n+      if ( __y._M_next != &__y )\n+      {\n+        // Both __x and __y are not empty.\n+        std::swap(__x._M_next,__y._M_next);\n+        std::swap(__x._M_prev,__y._M_prev);\n+        __x._M_next->_M_prev = __x._M_prev->_M_next = &__x;\n+        __y._M_next->_M_prev = __y._M_prev->_M_next = &__y;\n+      }\n+      else\n+      {\n+        // __x is not empty, __y is empty.\n+        __y._M_next = __x._M_next;\n+        __y._M_prev = __x._M_prev;\n+        __y._M_next->_M_prev = __y._M_prev->_M_next = &__y;        \n+        __x._M_next = __x._M_prev = &__x;\n+      }\n+    }\n+    else if ( __y._M_next != &__y )\n+    {\n+      // __x is empty, __y is not empty.\n+      __x._M_next = __y._M_next;\n+      __x._M_prev = __y._M_prev;\n+      __x._M_next->_M_prev = __x._M_prev->_M_next = &__x;      \n+      __y._M_next = __y._M_prev = &__y;\n+    }\n+  }\n+\n+  void\n+  _List_node_base::transfer(_List_node_base * const __first,\n+                            _List_node_base * const __last)\n+  {\n+    if (this != __last)\n+    {\n+      // Remove [first, last) from its old position.\n+      __last->_M_prev->_M_next  = this;\n+      __first->_M_prev->_M_next = __last;\n+      this->_M_prev->_M_next    = __first;\n+  \n+      // Splice [first, last) into its new position.\n+      _List_node_base* const __tmp = this->_M_prev;\n+      this->_M_prev                = __last->_M_prev;\n+      __last->_M_prev              = __first->_M_prev;\n+      __first->_M_prev             = __tmp;\n+    }\n+  }\n+\n+  void\n+  _List_node_base::reverse()\n+  {\n+    _List_node_base* __tmp = this;\n+    do\n+    {\n+      std::swap(__tmp->_M_next, __tmp->_M_prev);\n+      __tmp = __tmp->_M_prev;     // Old next node is now prev.\n+    } \n+    while (__tmp != this);\n+  }\n+\n+  void\n+  _List_node_base::hook(_List_node_base * const __position)\n+  {\n+    this->_M_next = __position;\n+    this->_M_prev = __position->_M_prev;\n+    __position->_M_prev->_M_next = this;\n+    __position->_M_prev = this;\n+  }\n+\n+  void\n+  _List_node_base::unhook()\n+  {\n+    _List_node_base* const __next_node = this->_M_next;\n+    _List_node_base* const __prev_node = this->_M_prev;\n+    __prev_node->_M_next = __next_node;\n+    __next_node->_M_prev = __prev_node;\n+  }\n+} // namespace __gnu_norm\n+"}, {"sha": "0cef30c104e9c64ffb3277622079f9f1d287e06f", "filename": "libstdc++-v3/src/tree.cc", "status": "renamed", "additions": 46, "deletions": 1, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e135a038d3af5aac53cd63afdba3ca1768628c9d/libstdc%2B%2B-v3%2Fsrc%2Ftree.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e135a038d3af5aac53cd63afdba3ca1768628c9d/libstdc%2B%2B-v3%2Fsrc%2Ftree.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Ftree.cc?ref=e135a038d3af5aac53cd63afdba3ca1768628c9d", "patch": "@@ -82,6 +82,12 @@ namespace std\n     return __x;\n   }\n \n+  const _Rb_tree_node_base*\n+  _Rb_tree_increment(const _Rb_tree_node_base* __x)\n+  {\n+    return _Rb_tree_increment(const_cast<_Rb_tree_node_base*>(__x));\n+  }\n+\n   _Rb_tree_node_base*\n   _Rb_tree_decrement(_Rb_tree_node_base* __x)\n   {\n@@ -108,6 +114,12 @@ namespace std\n     return __x;\n   }\n \n+  const _Rb_tree_node_base*\n+  _Rb_tree_decrement(const _Rb_tree_node_base* __x)\n+  {\n+    return _Rb_tree_decrement(const_cast<_Rb_tree_node_base*>(__x));\n+  }\n+\n   void \n   _Rb_tree_rotate_left(_Rb_tree_node_base* const __x, \n \t\t       _Rb_tree_node_base*& __root)\n@@ -151,10 +163,43 @@ namespace std\n   }\n \n   void \n-  _Rb_tree_rebalance(_Rb_tree_node_base* __x, _Rb_tree_node_base*& __root)\n+  _Rb_tree_insert_and_rebalance(const bool          __insert_left,\n+                                _Rb_tree_node_base* __x,\n+                                _Rb_tree_node_base* __p,\n+                                _Rb_tree_node_base& __header)\n   {\n+    _Rb_tree_node_base *& __root = __header._M_parent;\n+\n+    // Initialize fields in new node to insert.\n+    __x->_M_parent = __p;\n+    __x->_M_left = 0;\n+    __x->_M_right = 0;\n     __x->_M_color = _S_red;\n \n+    // Insert.\n+    // Make new node child of parent and maintain root, leftmost and\n+    // rightmost nodes.\n+    // N.B. First node is always inserted left.\n+    if (__insert_left)\n+      {\n+        __p->_M_left = __x; // also makes leftmost = __x when __p == &__header\n+\n+        if (__p == &__header)\n+        {\n+            __header._M_parent = __x;\n+            __header._M_right = __x;\n+        }\n+        else if (__p == __header._M_left)\n+          __header._M_left = __x; // maintain leftmost pointing to min node\n+      }\n+    else\n+      {\n+        __p->_M_right = __x;\n+\n+        if (__p == __header._M_right)\n+          __header._M_right = __x; // maintain rightmost pointing to max node\n+      }\n+    // Rebalance.\n     while (__x != __root \n \t   && __x->_M_parent->_M_color == _S_red) \n       {", "previous_filename": "libstdc++-v3/src/stl_tree.cc"}, {"sha": "84302328b4d3031349e4fd2dd653c151c08966c9", "filename": "libstdc++-v3/testsuite/23_containers/map/operators/1_neg.cc", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e135a038d3af5aac53cd63afdba3ca1768628c9d/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmap%2Foperators%2F1_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e135a038d3af5aac53cd63afdba3ca1768628c9d/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmap%2Foperators%2F1_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmap%2Foperators%2F1_neg.cc?ref=e135a038d3af5aac53cd63afdba3ca1768628c9d", "patch": "@@ -1,6 +1,6 @@\n-// 2000-09-07 bgarcia@laurelnetworks.com\n+// { dg-do compile }\n \n-// Copyright (C) 2000, 2001, 2002 Free Software Foundation, Inc.\n+// Copyright (C) 2000, 2001, 2002, 2004 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -19,12 +19,11 @@\n // USA.\n \n // 23.3.4 template class multiset negative tests\n+// 2000-09-07 bgarcia@laurelnetworks.com\n \n #include <map>\n #include <string>\n \n-// { dg-do compile }\n-\n // libstdc++/86: map & set iterator comparisons are not type-safe\n void test01()\n {\n@@ -42,8 +41,5 @@ void test01()\n   test &= itr == mapByName.end(); // { dg-error \"no\" } \n }\n  \n-int main()\n-{\n-  test01();\n-  return 0;\n-}\n+// { dg-error \"candidates are\" \"\" { target *-*-* } 212 } \n+// { dg-error \"candidates are\" \"\" { target *-*-* } 216 }"}, {"sha": "e178b8c3918a5f28f30c972bdf66869d088c9544", "filename": "libstdc++-v3/testsuite/23_containers/set/operators/1_neg.cc", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e135a038d3af5aac53cd63afdba3ca1768628c9d/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fset%2Foperators%2F1_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e135a038d3af5aac53cd63afdba3ca1768628c9d/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fset%2Foperators%2F1_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fset%2Foperators%2F1_neg.cc?ref=e135a038d3af5aac53cd63afdba3ca1768628c9d", "patch": "@@ -1,6 +1,6 @@\n-// 2000-09-07 bgarcia@laurelnetworks.com\n+// { dg-do compile }\n \n-// Copyright (C) 2000, 2001, 2002 Free Software Foundation, Inc.\n+// Copyright (C) 2000, 2001, 2002, 2004 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -19,14 +19,13 @@\n // USA.\n \n // 23.3.4 template class multiset negative tests\n+// 2000-09-07 bgarcia@laurelnetworks.com\n \n #include <set>\n #include <string>\n \n-// { dg-do compile }\n-\n // libstdc++/86: map & set iterator comparisons are not type-safe\n-int main(void)\n+void test01()\n {\n   bool test __attribute__((unused)) = true;\n \n@@ -38,6 +37,7 @@ int main(void)\n   // NB: it's not setByIndex!!\n   test &= itr != setByName.end(); // { dg-error \"no\" } \n   test &= itr == setByName.end(); // { dg-error \"no\" } \n-\n-  return 0;\n }\n+\n+// { dg-error \"candidates are\" \"\" { target *-*-* } 285 }\n+// { dg-error \"candidates are\" \"\" { target *-*-* } 289 } "}]}