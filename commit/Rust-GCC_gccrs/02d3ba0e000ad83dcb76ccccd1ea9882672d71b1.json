{"sha": "02d3ba0e000ad83dcb76ccccd1ea9882672d71b1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDJkM2JhMGUwMDBhZDgzZGNiNzZjY2NjZDFlYTk4ODI2NzJkNzFiMQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2017-07-27T09:38:54Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-07-27T09:38:54Z"}, "message": "[rs6000] Avoid rotates of floating-point modes\n\nThe little-endian VSX code uses rotates to swap the two 64-bit halves of\n128-bit scalar modes.  This is fine for TImode and V1TImode, but it\nisn't really valid to use RTL rotates on floating-point modes like\nKFmode and TFmode, and doing that triggered an assert added by the\nSVE series.  This patch uses bit-casts to V1TImode instead.\n\n2017-07-27  Richard Sandiford  <richard.sandiford@linaro.org>\n\ngcc/\n\t* config/rs6000/rs6000-protos.h (rs6000_emit_le_vsx_permute): Declare.\n\t* config/rs6000/rs6000.c (rs6000_gen_le_vsx_permute): Replace with...\n\t(rs6000_emit_le_vsx_permute): ...this.  Take the destination as input.\n\tEmit instructions rather than returning an expression.  Handle TFmode\n\tand KFmode by casting to TImode.\n\t(rs6000_emit_le_vsx_load): Update to use rs6000_emit_le_vsx_permute.\n\t(rs6000_emit_le_vsx_store): Likewise.\n\t* config/rs6000/vsx.md (VSX_TI): New iterator.\n\t(*vsx_le_permute_<mode>): Use it instead of VSX_LE_128.\n\t(*vsx_le_undo_permute_<mode>): Likewise.\n\t(*vsx_le_perm_load_<mode>): Use rs6000_emit_le_vsx_permute to\n\temit the split sequence.\n\t(*vsx_le_perm_store_<mode>): Likewise.\n\nFrom-SVN: r250615", "tree": {"sha": "63d75fb9aea209c71ea9ee3b902b48fcd381c5a7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/63d75fb9aea209c71ea9ee3b902b48fcd381c5a7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/02d3ba0e000ad83dcb76ccccd1ea9882672d71b1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/02d3ba0e000ad83dcb76ccccd1ea9882672d71b1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/02d3ba0e000ad83dcb76ccccd1ea9882672d71b1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/02d3ba0e000ad83dcb76ccccd1ea9882672d71b1/comments", "author": null, "committer": null, "parents": [{"sha": "7d25ac209de8262e39e5551585da5094a4c5c317", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d25ac209de8262e39e5551585da5094a4c5c317", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7d25ac209de8262e39e5551585da5094a4c5c317"}], "stats": {"total": 130, "additions": 74, "deletions": 56}, "files": [{"sha": "7444943bb80929e55a8ce5cf93c8f7bc47b6b93b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02d3ba0e000ad83dcb76ccccd1ea9882672d71b1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02d3ba0e000ad83dcb76ccccd1ea9882672d71b1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=02d3ba0e000ad83dcb76ccccd1ea9882672d71b1", "patch": "@@ -1,3 +1,19 @@\n+2017-07-27  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\t* config/rs6000/rs6000-protos.h (rs6000_emit_le_vsx_permute): Declare.\n+\t* config/rs6000/rs6000.c (rs6000_gen_le_vsx_permute): Replace with...\n+\t(rs6000_emit_le_vsx_permute): ...this.  Take the destination as input.\n+\tEmit instructions rather than returning an expression.  Handle TFmode\n+\tand KFmode by casting to TImode.\n+\t(rs6000_emit_le_vsx_load): Update to use rs6000_emit_le_vsx_permute.\n+\t(rs6000_emit_le_vsx_store): Likewise.\n+\t* config/rs6000/vsx.md (VSX_TI): New iterator.\n+\t(*vsx_le_permute_<mode>): Use it instead of VSX_LE_128.\n+\t(*vsx_le_undo_permute_<mode>): Likewise.\n+\t(*vsx_le_perm_load_<mode>): Use rs6000_emit_le_vsx_permute to\n+\temit the split sequence.\n+\t(*vsx_le_perm_store_<mode>): Likewise.\n+\n 2017-07-27  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR tree-optimization/81555"}, {"sha": "1b4932eba1eaf16482061f7916cb244ea36db31a", "filename": "gcc/config/rs6000/rs6000-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02d3ba0e000ad83dcb76ccccd1ea9882672d71b1/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02d3ba0e000ad83dcb76ccccd1ea9882672d71b1/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h?ref=02d3ba0e000ad83dcb76ccccd1ea9882672d71b1", "patch": "@@ -151,6 +151,7 @@ extern rtx rs6000_longcall_ref (rtx);\n extern void rs6000_fatal_bad_address (rtx);\n extern rtx create_TOC_reference (rtx, rtx);\n extern void rs6000_split_multireg_move (rtx, rtx);\n+extern void rs6000_emit_le_vsx_permute (rtx, rtx, machine_mode);\n extern void rs6000_emit_le_vsx_move (rtx, rtx, machine_mode);\n extern bool valid_sf_si_move (rtx, rtx, machine_mode);\n extern void rs6000_emit_move (rtx, rtx, machine_mode);"}, {"sha": "7461decd99c776af44dc8e7ef1032f1935d98c04", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 26, "deletions": 23, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02d3ba0e000ad83dcb76ccccd1ea9882672d71b1/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02d3ba0e000ad83dcb76ccccd1ea9882672d71b1/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=02d3ba0e000ad83dcb76ccccd1ea9882672d71b1", "patch": "@@ -10374,19 +10374,30 @@ rs6000_const_vec (machine_mode mode)\n   return v;\n }\n \n-/* Generate a permute rtx that represents an lxvd2x, stxvd2x, or xxpermdi\n-   for a VSX load or store operation.  */\n-rtx\n-rs6000_gen_le_vsx_permute (rtx source, machine_mode mode)\n+/* Emit an lxvd2x, stxvd2x, or xxpermdi instruction for a VSX load or\n+   store operation.  */\n+void\n+rs6000_emit_le_vsx_permute (rtx dest, rtx source, machine_mode mode)\n {\n-  /* Use ROTATE instead of VEC_SELECT on IEEE 128-bit floating point, and\n-     128-bit integers if they are allowed in VSX registers.  */\n-  if (FLOAT128_VECTOR_P (mode) || mode == TImode || mode == V1TImode)\n-    return gen_rtx_ROTATE (mode, source, GEN_INT (64));\n+  /* Scalar permutations are easier to express in integer modes rather than\n+     floating-point modes, so cast them here.  We use V1TImode instead\n+     of TImode to ensure that the values don't go through GPRs.  */\n+  if (FLOAT128_VECTOR_P (mode))\n+    {\n+      dest = gen_lowpart (V1TImode, dest);\n+      source = gen_lowpart (V1TImode, source);\n+      mode = V1TImode;\n+    }\n+\n+  /* Use ROTATE instead of VEC_SELECT if the mode contains only a single\n+     scalar.  */\n+  if (mode == TImode || mode == V1TImode)\n+    emit_insn (gen_rtx_SET (dest, gen_rtx_ROTATE (mode, source,\n+\t\t\t\t\t\t  GEN_INT (64))));\n   else\n     {\n       rtx par = gen_rtx_PARALLEL (VOIDmode, rs6000_const_vec (mode));\n-      return gen_rtx_VEC_SELECT (mode, source, par);\n+      emit_insn (gen_rtx_SET (dest, gen_rtx_VEC_SELECT (mode, source, par)));\n     }\n }\n \n@@ -10396,8 +10407,6 @@ rs6000_gen_le_vsx_permute (rtx source, machine_mode mode)\n void\n rs6000_emit_le_vsx_load (rtx dest, rtx source, machine_mode mode)\n {\n-  rtx tmp, permute_mem, permute_reg;\n-\n   /* Use V2DImode to do swaps of types with 128-bit scalare parts (TImode,\n      V1TImode).  */\n   if (mode == TImode || mode == V1TImode)\n@@ -10407,11 +10416,9 @@ rs6000_emit_le_vsx_load (rtx dest, rtx source, machine_mode mode)\n       source = adjust_address (source, V2DImode, 0);\n     }\n \n-  tmp = can_create_pseudo_p () ? gen_reg_rtx_and_attrs (dest) : dest;\n-  permute_mem = rs6000_gen_le_vsx_permute (source, mode);\n-  permute_reg = rs6000_gen_le_vsx_permute (tmp, mode);\n-  emit_insn (gen_rtx_SET (tmp, permute_mem));\n-  emit_insn (gen_rtx_SET (dest, permute_reg));\n+  rtx tmp = can_create_pseudo_p () ? gen_reg_rtx_and_attrs (dest) : dest;\n+  rs6000_emit_le_vsx_permute (tmp, source, mode);\n+  rs6000_emit_le_vsx_permute (dest, tmp, mode);\n }\n \n /* Emit a little-endian store to vector memory location DEST from VSX\n@@ -10420,8 +10427,6 @@ rs6000_emit_le_vsx_load (rtx dest, rtx source, machine_mode mode)\n void\n rs6000_emit_le_vsx_store (rtx dest, rtx source, machine_mode mode)\n {\n-  rtx tmp, permute_src, permute_tmp;\n-\n   /* This should never be called during or after reload, because it does\n      not re-permute the source register.  It is intended only for use\n      during expand.  */\n@@ -10436,11 +10441,9 @@ rs6000_emit_le_vsx_store (rtx dest, rtx source, machine_mode mode)\n       source = gen_lowpart (V2DImode, source);\n     }\n \n-  tmp = can_create_pseudo_p () ? gen_reg_rtx_and_attrs (source) : source;\n-  permute_src = rs6000_gen_le_vsx_permute (source, mode);\n-  permute_tmp = rs6000_gen_le_vsx_permute (tmp, mode);\n-  emit_insn (gen_rtx_SET (tmp, permute_src));\n-  emit_insn (gen_rtx_SET (dest, permute_tmp));\n+  rtx tmp = can_create_pseudo_p () ? gen_reg_rtx_and_attrs (source) : source;\n+  rs6000_emit_le_vsx_permute (tmp, source, mode);\n+  rs6000_emit_le_vsx_permute (dest, tmp, mode);\n }\n \n /* Emit a sequence representing a little-endian VSX load or store,"}, {"sha": "b2b85c1e3849f4916b0b4e3b309a4e60ad81d531", "filename": "gcc/config/rs6000/vsx.md", "status": "modified", "additions": 31, "deletions": 33, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02d3ba0e000ad83dcb76ccccd1ea9882672d71b1/gcc%2Fconfig%2Frs6000%2Fvsx.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02d3ba0e000ad83dcb76ccccd1ea9882672d71b1/gcc%2Fconfig%2Frs6000%2Fvsx.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fvsx.md?ref=02d3ba0e000ad83dcb76ccccd1ea9882672d71b1", "patch": "@@ -37,6 +37,9 @@\n \t\t\t\t  (TI\t\"TARGET_VSX_TIMODE\")\n \t\t\t\t  V1TI])\n \n+;; Iterator for 128-bit integer types that go in a single vector register.\n+(define_mode_iterator VSX_TI [(TI \"TARGET_VSX_TIMODE\") V1TI])\n+\n ;; Iterator for the 2 32-bit vector types\n (define_mode_iterator VSX_W [V4SF V4SI])\n \n@@ -756,9 +759,9 @@\n ;; special V1TI container class, which it is not appropriate to use vec_select\n ;; for the type.\n (define_insn \"*vsx_le_permute_<mode>\"\n-  [(set (match_operand:VSX_LE_128 0 \"nonimmediate_operand\" \"=<VSa>,<VSa>,Z\")\n-\t(rotate:VSX_LE_128\n-\t (match_operand:VSX_LE_128 1 \"input_operand\" \"<VSa>,Z,<VSa>\")\n+  [(set (match_operand:VSX_TI 0 \"nonimmediate_operand\" \"=<VSa>,<VSa>,Z\")\n+\t(rotate:VSX_TI\n+\t (match_operand:VSX_TI 1 \"input_operand\" \"<VSa>,Z,<VSa>\")\n \t (const_int 64)))]\n   \"!BYTES_BIG_ENDIAN && TARGET_VSX && !TARGET_P9_VECTOR\"\n   \"@\n@@ -769,10 +772,10 @@\n    (set_attr \"type\" \"vecperm,vecload,vecstore\")])\n \n (define_insn_and_split \"*vsx_le_undo_permute_<mode>\"\n-  [(set (match_operand:VSX_LE_128 0 \"vsx_register_operand\" \"=<VSa>,<VSa>\")\n-\t(rotate:VSX_LE_128\n-\t (rotate:VSX_LE_128\n-\t  (match_operand:VSX_LE_128 1 \"vsx_register_operand\" \"0,<VSa>\")\n+  [(set (match_operand:VSX_TI 0 \"vsx_register_operand\" \"=<VSa>,<VSa>\")\n+\t(rotate:VSX_TI\n+\t (rotate:VSX_TI\n+\t  (match_operand:VSX_TI 1 \"vsx_register_operand\" \"0,<VSa>\")\n \t  (const_int 64))\n \t (const_int 64)))]\n   \"!BYTES_BIG_ENDIAN && TARGET_VSX\"\n@@ -797,16 +800,15 @@\n   \"!BYTES_BIG_ENDIAN && TARGET_VSX && !TARGET_P9_VECTOR\"\n   \"#\"\n   \"!BYTES_BIG_ENDIAN && TARGET_VSX && !TARGET_P9_VECTOR\"\n-  [(set (match_dup 2)\n-\t(rotate:VSX_LE_128 (match_dup 1)\n-\t\t\t   (const_int 64)))\n-   (set (match_dup 0)\n-\t(rotate:VSX_LE_128 (match_dup 2)\n-\t\t\t   (const_int 64)))]\n+  [(const_int 0)]\n   \"\n {\n-  operands[2] = can_create_pseudo_p () ? gen_reg_rtx_and_attrs (operands[0])\n-                                       : operands[0];\n+  rtx tmp = (can_create_pseudo_p ()\n+\t     ? gen_reg_rtx_and_attrs (operands[0])\n+\t     : operands[0]);\n+  rs6000_emit_le_vsx_permute (tmp, operands[1], <MODE>mode);\n+  rs6000_emit_le_vsx_permute (operands[0], tmp, <MODE>mode);\n+  DONE;\n }\n   \"\n   [(set_attr \"type\" \"vecload\")\n@@ -824,15 +826,14 @@\n   [(set (match_operand:VSX_LE_128 0 \"memory_operand\" \"\")\n         (match_operand:VSX_LE_128 1 \"vsx_register_operand\" \"\"))]\n   \"!BYTES_BIG_ENDIAN && TARGET_VSX && !reload_completed && !TARGET_P9_VECTOR\"\n-  [(set (match_dup 2)\n-\t(rotate:VSX_LE_128 (match_dup 1)\n-\t\t\t   (const_int 64)))\n-   (set (match_dup 0)\n-\t(rotate:VSX_LE_128 (match_dup 2)\n-\t\t\t   (const_int 64)))]\n+  [(const_int 0)]\n {\n-  operands[2] = can_create_pseudo_p () ? gen_reg_rtx_and_attrs (operands[0])\n-                                       : operands[0];\n+  rtx tmp = (can_create_pseudo_p ()\n+\t     ? gen_reg_rtx_and_attrs (operands[0])\n+\t     : operands[0]);\n+  rs6000_emit_le_vsx_permute (tmp, operands[1], <MODE>mode);\n+  rs6000_emit_le_vsx_permute (operands[0], tmp, <MODE>mode);\n+  DONE;\n })\n \n ;; Peephole to catch memory to memory transfers for TImode if TImode landed in\n@@ -856,16 +857,13 @@\n   [(set (match_operand:VSX_LE_128 0 \"memory_operand\" \"\")\n         (match_operand:VSX_LE_128 1 \"vsx_register_operand\" \"\"))]\n   \"!BYTES_BIG_ENDIAN && TARGET_VSX && reload_completed && !TARGET_P9_VECTOR\"\n-  [(set (match_dup 1)\n-\t(rotate:VSX_LE_128 (match_dup 1)\n-\t\t\t   (const_int 64)))\n-   (set (match_dup 0)\n-\t(rotate:VSX_LE_128 (match_dup 1)\n-\t\t\t   (const_int 64)))\n-   (set (match_dup 1)\n-\t(rotate:VSX_LE_128 (match_dup 1)\n-\t\t\t   (const_int 64)))]\n-  \"\")\n+  [(const_int 0)]\n+{\n+  rs6000_emit_le_vsx_permute (operands[1], operands[1], <MODE>mode);\n+  rs6000_emit_le_vsx_permute (operands[0], operands[1], <MODE>mode);\n+  rs6000_emit_le_vsx_permute (operands[1], operands[1], <MODE>mode);\n+  DONE;\n+})\n \n ;; Vector constants that can be generated with XXSPLTIB that was added in ISA\n ;; 3.0.  Both (const_vector [..]) and (vec_duplicate ...) forms are recognized."}]}