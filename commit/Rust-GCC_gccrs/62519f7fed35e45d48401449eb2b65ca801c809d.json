{"sha": "62519f7fed35e45d48401449eb2b65ca801c809d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjI1MTlmN2ZlZDM1ZTQ1ZDQ4NDAxNDQ5ZWIyYjY1Y2E4MDFjODA5ZA==", "commit": {"author": {"name": "Jie Zhang", "email": "jie@codesourcery.com", "date": "2010-10-22T00:40:15Z"}, "committer": {"name": "Jie Zhang", "email": "jiez@gcc.gnu.org", "date": "2010-10-22T00:40:15Z"}, "message": "expr.c (emit_group_load_1): Update calls to extract_bit_field.\n\n\t* expr.c (emit_group_load_1): Update calls to extract_bit_field.\n\t(copy_blkmode_from_reg): Likewise.\n\t(read_complex_part): Likewise.\n\t(expand_expr_real_1): Calculate packedp and pass it to\n\textract_bit_field.\n\t* expr.h (extract_bit_field): Update declaration.\n\t* calls.c (store_unaligned_arguments_into_pseudos): Update call\n\tto extract_bit_field.\n\t* expmed.c (extract_fixed_bit_field): Update calls to\n\textract_fixed_bit_field.\n\t(store_split_bit_field): Likewise.\n\t(extract_bit_field_1): Add new argument packedp.\n\t(extract_bit_field): Add new argument packedp.\n\t(extract_fixed_bit_field): Add new argument packedp and let\n\tpacked attribute override volatile.\n\t* stmt.c (expand_return): Update call to extract_bit_field.\n\nFrom-SVN: r165799", "tree": {"sha": "62a5cfc99aa1dfe7f47f018537dc4cb2a3f259d6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/62a5cfc99aa1dfe7f47f018537dc4cb2a3f259d6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/62519f7fed35e45d48401449eb2b65ca801c809d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/62519f7fed35e45d48401449eb2b65ca801c809d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/62519f7fed35e45d48401449eb2b65ca801c809d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/62519f7fed35e45d48401449eb2b65ca801c809d/comments", "author": null, "committer": null, "parents": [{"sha": "f40872465cb60b433d661735d2e74c3ec93891c5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f40872465cb60b433d661735d2e74c3ec93891c5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f40872465cb60b433d661735d2e74c3ec93891c5"}], "stats": {"total": 87, "additions": 66, "deletions": 21}, "files": [{"sha": "552617b29c6279302a52a8469ac356cd12f551df", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62519f7fed35e45d48401449eb2b65ca801c809d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62519f7fed35e45d48401449eb2b65ca801c809d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=62519f7fed35e45d48401449eb2b65ca801c809d", "patch": "@@ -1,3 +1,22 @@\n+2010-10-22  Jie Zhang  <jie@codesourcery.com>\n+\n+\t* expr.c (emit_group_load_1): Update calls to extract_bit_field.\n+\t(copy_blkmode_from_reg): Likewise.\n+\t(read_complex_part): Likewise.\n+\t(expand_expr_real_1): Calculate packedp and pass it to\n+\textract_bit_field.\n+\t* expr.h (extract_bit_field): Update declaration.\n+\t* calls.c (store_unaligned_arguments_into_pseudos): Update call\n+\tto extract_bit_field.\n+\t* expmed.c (extract_fixed_bit_field): Update calls to\n+\textract_fixed_bit_field.\n+\t(store_split_bit_field): Likewise.\n+\t(extract_bit_field_1): Add new argument packedp.\n+\t(extract_bit_field): Add new argument packedp.\n+\t(extract_fixed_bit_field): Add new argument packedp and let\n+\tpacked attribute override volatile.\n+\t* stmt.c (expand_return): Update call to extract_bit_field.\n+\n 2010-10-21  Nathan Froyd  <froydnj@codesourcery.com>\n \n \t* config/spu/spu.c (spu_function_arg): Dereference CUM parameter."}, {"sha": "e6b0ef56acb8c253287ebad5f1e74a8205540e21", "filename": "gcc/calls.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62519f7fed35e45d48401449eb2b65ca801c809d/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62519f7fed35e45d48401449eb2b65ca801c809d/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=62519f7fed35e45d48401449eb2b65ca801c809d", "patch": "@@ -886,7 +886,7 @@ store_unaligned_arguments_into_pseudos (struct arg_data *args, int num_actuals)\n \t    int bitsize = MIN (bytes * BITS_PER_UNIT, BITS_PER_WORD);\n \n \t    args[i].aligned_regs[j] = reg;\n-\t    word = extract_bit_field (word, bitsize, 0, 1, NULL_RTX,\n+\t    word = extract_bit_field (word, bitsize, 0, 1, false, NULL_RTX,\n \t\t\t\t      word_mode, word_mode);\n \n \t    /* There is no need to restrict this code to loading items"}, {"sha": "7ff55e7bafd3b75d7a0005356fcef5b48ae7dff5", "filename": "gcc/expmed.c", "status": "modified", "additions": 32, "deletions": 12, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62519f7fed35e45d48401449eb2b65ca801c809d/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62519f7fed35e45d48401449eb2b65ca801c809d/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=62519f7fed35e45d48401449eb2b65ca801c809d", "patch": "@@ -53,7 +53,7 @@ static void store_split_bit_field (rtx, unsigned HOST_WIDE_INT,\n static rtx extract_fixed_bit_field (enum machine_mode, rtx,\n \t\t\t\t    unsigned HOST_WIDE_INT,\n \t\t\t\t    unsigned HOST_WIDE_INT,\n-\t\t\t\t    unsigned HOST_WIDE_INT, rtx, int);\n+\t\t\t\t    unsigned HOST_WIDE_INT, rtx, int, bool);\n static rtx mask_rtx (enum machine_mode, int, int, int);\n static rtx lshift_value (enum machine_mode, rtx, int, int);\n static rtx extract_split_bit_field (rtx, unsigned HOST_WIDE_INT,\n@@ -1083,7 +1083,7 @@ store_split_bit_field (rtx op0, unsigned HOST_WIDE_INT bitsize,\n \t       endianness compensation) to fetch the piece we want.  */\n \t    part = extract_fixed_bit_field (word_mode, value, 0, thissize,\n \t\t\t\t\t    total_bits - bitsize + bitsdone,\n-\t\t\t\t\t    NULL_RTX, 1);\n+\t\t\t\t\t    NULL_RTX, 1, false);\n \t}\n       else\n \t{\n@@ -1094,7 +1094,7 @@ store_split_bit_field (rtx op0, unsigned HOST_WIDE_INT bitsize,\n \t\t\t    & (((HOST_WIDE_INT) 1 << thissize) - 1));\n \t  else\n \t    part = extract_fixed_bit_field (word_mode, value, 0, thissize,\n-\t\t\t\t\t    bitsdone, NULL_RTX, 1);\n+\t\t\t\t\t    bitsdone, NULL_RTX, 1, false);\n \t}\n \n       /* If OP0 is a register, then handle OFFSET here.\n@@ -1160,7 +1160,8 @@ convert_extracted_bit_field (rtx x, enum machine_mode mode,\n \n static rtx\n extract_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n-\t\t     unsigned HOST_WIDE_INT bitnum, int unsignedp, rtx target,\n+\t\t     unsigned HOST_WIDE_INT bitnum,\n+\t\t     int unsignedp, bool packedp, rtx target,\n \t\t     enum machine_mode mode, enum machine_mode tmode,\n \t\t     bool fallback_p)\n {\n@@ -1441,7 +1442,7 @@ extract_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n \t  rtx result_part\n \t    = extract_bit_field (op0, MIN (BITS_PER_WORD,\n \t\t\t\t\t   bitsize - i * BITS_PER_WORD),\n-\t\t\t\t bitnum + bit_offset, 1, target_part, mode,\n+\t\t\t\t bitnum + bit_offset, 1, false, target_part, mode,\n \t\t\t\t word_mode);\n \n \t  gcc_assert (target_part);\n@@ -1640,7 +1641,7 @@ extract_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n \t      xop0 = adjust_address (op0, bestmode, xoffset);\n \t      xop0 = force_reg (bestmode, xop0);\n \t      result = extract_bit_field_1 (xop0, bitsize, xbitpos,\n-\t\t\t\t\t    unsignedp, target,\n+\t\t\t\t\t    unsignedp, packedp, target,\n \t\t\t\t\t    mode, tmode, false);\n \t      if (result)\n \t\treturn result;\n@@ -1654,7 +1655,7 @@ extract_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n     return NULL;\n \n   target = extract_fixed_bit_field (int_mode, op0, offset, bitsize,\n-\t\t\t\t    bitpos, target, unsignedp);\n+\t\t\t\t    bitpos, target, unsignedp, packedp);\n   return convert_extracted_bit_field (target, mode, tmode, unsignedp);\n }\n \n@@ -1665,6 +1666,7 @@ extract_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n \n    STR_RTX is the structure containing the byte (a REG or MEM).\n    UNSIGNEDP is nonzero if this is an unsigned bit field.\n+   PACKEDP is nonzero if the field has the packed attribute.\n    MODE is the natural mode of the field value once extracted.\n    TMODE is the mode the caller would like the value to have;\n    but the value may be returned with type MODE instead.\n@@ -1676,10 +1678,10 @@ extract_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n \n rtx\n extract_bit_field (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n-\t\t   unsigned HOST_WIDE_INT bitnum, int unsignedp, rtx target,\n-\t\t   enum machine_mode mode, enum machine_mode tmode)\n+\t\t   unsigned HOST_WIDE_INT bitnum, int unsignedp, bool packedp,\n+\t\t   rtx target, enum machine_mode mode, enum machine_mode tmode)\n {\n-  return extract_bit_field_1 (str_rtx, bitsize, bitnum, unsignedp,\n+  return extract_bit_field_1 (str_rtx, bitsize, bitnum, unsignedp, packedp,\n \t\t\t      target, mode, tmode, true);\n }\n \f\n@@ -1695,6 +1697,8 @@ extract_bit_field (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n      which is significant on bigendian machines.)\n \n    UNSIGNEDP is nonzero for an unsigned bit field (don't sign-extend value).\n+   PACKEDP is true if the field has the packed attribute.\n+\n    If TARGET is nonzero, attempts to store the value there\n    and return TARGET, but this is not guaranteed.\n    If TARGET is not used, create a pseudo-reg of mode TMODE for the value.  */\n@@ -1704,7 +1708,7 @@ extract_fixed_bit_field (enum machine_mode tmode, rtx op0,\n \t\t\t unsigned HOST_WIDE_INT offset,\n \t\t\t unsigned HOST_WIDE_INT bitsize,\n \t\t\t unsigned HOST_WIDE_INT bitpos, rtx target,\n-\t\t\t int unsignedp)\n+\t\t\t int unsignedp, bool packedp)\n {\n   unsigned int total_bits = BITS_PER_WORD;\n   enum machine_mode mode;\n@@ -1769,6 +1773,22 @@ extract_fixed_bit_field (enum machine_mode tmode, rtx op0,\n \t      static bool informed_about_misalignment = false;\n \t      bool warned;\n \n+\t      if (packedp)\n+\t\t{\n+\t\t  if (bitsize == total_bits)\n+\t\t    warned = warning_at (input_location, OPT_fstrict_volatile_bitfields,\n+\t\t\t\t\t \"multiple accesses to volatile structure member\"\n+\t\t\t\t\t \" because of packed attribute\");\n+\t\t  else\n+\t\t    warned = warning_at (input_location, OPT_fstrict_volatile_bitfields,\n+\t\t\t\t\t \"multiple accesses to volatile structure bitfield\"\n+\t\t\t\t\t \" because of packed attribute\");\n+\n+\t\t  return extract_split_bit_field (op0, bitsize,\n+\t\t\t\t\t\t  bitpos + offset * BITS_PER_UNIT,\n+\t\t\t\t\t\t  unsignedp);\n+\t\t}\n+\n \t      if (bitsize == total_bits)\n \t\twarned = warning_at (input_location, OPT_fstrict_volatile_bitfields,\n \t\t\t\t     \"mis-aligned access used for structure member\");\n@@ -1971,7 +1991,7 @@ extract_split_bit_field (rtx op0, unsigned HOST_WIDE_INT bitsize,\n \t extract_fixed_bit_field wants offset in bytes.  */\n       part = extract_fixed_bit_field (word_mode, word,\n \t\t\t\t      offset * unit / BITS_PER_UNIT,\n-\t\t\t\t      thissize, thispos, 0, 1);\n+\t\t\t\t      thissize, thispos, 0, 1, false);\n       bitsdone += thissize;\n \n       /* Shift this part into place for the result.  */"}, {"sha": "56f6edaeda2844a49b36f6a6431c611da1c59d4a", "filename": "gcc/expr.c", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62519f7fed35e45d48401449eb2b65ca801c809d/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62519f7fed35e45d48401449eb2b65ca801c809d/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=62519f7fed35e45d48401449eb2b65ca801c809d", "patch": "@@ -1703,7 +1703,7 @@ emit_group_load_1 (rtx *tmps, rtx dst, rtx orig_src, tree type, int ssize)\n \t\t  && (!REG_P (tmps[i]) || GET_MODE (tmps[i]) != mode))\n \t\ttmps[i] = extract_bit_field (tmps[i], bytelen * BITS_PER_UNIT,\n \t\t\t\t\t     (bytepos % slen0) * BITS_PER_UNIT,\n-\t\t\t\t\t     1, NULL_RTX, mode, mode);\n+\t\t\t\t\t     1, false, NULL_RTX, mode, mode);\n \t    }\n \t  else\n \t    {\n@@ -1713,7 +1713,7 @@ emit_group_load_1 (rtx *tmps, rtx dst, rtx orig_src, tree type, int ssize)\n \t      mem = assign_stack_temp (GET_MODE (src), slen, 0);\n \t      emit_move_insn (mem, src);\n \t      tmps[i] = extract_bit_field (mem, bytelen * BITS_PER_UNIT,\n-\t\t\t\t\t   0, 1, NULL_RTX, mode, mode);\n+\t\t\t\t\t   0, 1, false, NULL_RTX, mode, mode);\n \t    }\n \t}\n       /* FIXME: A SIMD parallel will eventually lead to a subreg of a\n@@ -1754,7 +1754,7 @@ emit_group_load_1 (rtx *tmps, rtx dst, rtx orig_src, tree type, int ssize)\n \ttmps[i] = src;\n       else\n \ttmps[i] = extract_bit_field (src, bytelen * BITS_PER_UNIT,\n-\t\t\t\t     bytepos * BITS_PER_UNIT, 1, NULL_RTX,\n+\t\t\t\t     bytepos * BITS_PER_UNIT, 1, false, NULL_RTX,\n \t\t\t\t     mode, mode);\n \n       if (shift)\n@@ -2167,7 +2167,7 @@ copy_blkmode_from_reg (rtx tgtblk, rtx srcreg, tree type)\n \t bitpos for the destination store (left justified).  */\n       store_bit_field (dst, bitsize, bitpos % BITS_PER_WORD, copy_mode,\n \t\t       extract_bit_field (src, bitsize,\n-\t\t\t\t\t  xbitpos % BITS_PER_WORD, 1,\n+\t\t\t\t\t  xbitpos % BITS_PER_WORD, 1, false,\n \t\t\t\t\t  NULL_RTX, copy_mode, copy_mode));\n     }\n \n@@ -2924,7 +2924,7 @@ read_complex_part (rtx cplx, bool imag_p)\n     }\n \n   return extract_bit_field (cplx, ibitsize, imag_p ? ibitsize : 0,\n-\t\t\t    true, NULL_RTX, imode, imode);\n+\t\t\t    true, false, NULL_RTX, imode, imode);\n }\n \f\n /* A subroutine of emit_move_insn_1.  Yet another lowpart generator.\n@@ -8938,6 +8938,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \tHOST_WIDE_INT bitsize, bitpos;\n \ttree offset;\n \tint volatilep = 0, must_force_mem;\n+\tbool packedp = false;\n \ttree tem = get_inner_reference (exp, &bitsize, &bitpos, &offset,\n \t\t\t\t\t&mode1, &unsignedp, &volatilep, true);\n \trtx orig_op0, memloc;\n@@ -8947,6 +8948,11 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t   infinitely recurse.  */\n \tgcc_assert (tem != exp);\n \n+\tif (TYPE_PACKED (TREE_TYPE (TREE_OPERAND (exp, 0)))\n+\t    || (TREE_CODE (TREE_OPERAND (exp, 1)) == FIELD_DECL\n+\t\t&& DECL_PACKED (TREE_OPERAND (exp, 1))))\n+\t  packedp = true;\n+\n \t/* If TEM's type is a union of variable size, pass TARGET to the inner\n \t   computation, since it will need a temporary and TARGET is known\n \t   to have to do.  This occurs in unchecked conversion in Ada.  */\n@@ -9159,7 +9165,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t    if (MEM_P (op0) && REG_P (XEXP (op0, 0)))\n \t      mark_reg_pointer (XEXP (op0, 0), MEM_ALIGN (op0));\n \n-\t    op0 = extract_bit_field (op0, bitsize, bitpos, unsignedp,\n+\t    op0 = extract_bit_field (op0, bitsize, bitpos, unsignedp, packedp,\n \t\t\t\t     (modifier == EXPAND_STACK_PARM\n \t\t\t\t      ? NULL_RTX : target),\n \t\t\t\t     ext_mode, ext_mode);"}, {"sha": "263f861ca619bc397edb67540dee758255c014aa", "filename": "gcc/expr.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62519f7fed35e45d48401449eb2b65ca801c809d/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62519f7fed35e45d48401449eb2b65ca801c809d/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=62519f7fed35e45d48401449eb2b65ca801c809d", "patch": "@@ -668,7 +668,7 @@ mode_for_extraction (enum extraction_pattern, int);\n extern void store_bit_field (rtx, unsigned HOST_WIDE_INT,\n \t\t\t     unsigned HOST_WIDE_INT, enum machine_mode, rtx);\n extern rtx extract_bit_field (rtx, unsigned HOST_WIDE_INT,\n-\t\t\t      unsigned HOST_WIDE_INT, int, rtx,\n+\t\t\t      unsigned HOST_WIDE_INT, int, bool, rtx,\n \t\t\t      enum machine_mode, enum machine_mode);\n extern rtx extract_low_bits (enum machine_mode, enum machine_mode, rtx);\n extern rtx expand_mult (enum machine_mode, rtx, rtx, rtx, int);"}, {"sha": "9096d8385ddbe2863b1bad8bbc536fda711f7ff1", "filename": "gcc/stmt.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62519f7fed35e45d48401449eb2b65ca801c809d/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62519f7fed35e45d48401449eb2b65ca801c809d/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=62519f7fed35e45d48401449eb2b65ca801c809d", "patch": "@@ -1739,7 +1739,7 @@ expand_return (tree retval)\n \t     xbitpos for the destination store (right justified).  */\n \t  store_bit_field (dst, bitsize, xbitpos % BITS_PER_WORD, word_mode,\n \t\t\t   extract_bit_field (src, bitsize,\n-\t\t\t\t\t      bitpos % BITS_PER_WORD, 1,\n+\t\t\t\t\t      bitpos % BITS_PER_WORD, 1, false,\n \t\t\t\t\t      NULL_RTX, word_mode, word_mode));\n \t}\n "}]}