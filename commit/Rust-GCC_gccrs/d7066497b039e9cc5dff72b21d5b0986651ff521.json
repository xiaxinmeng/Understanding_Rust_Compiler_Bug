{"sha": "d7066497b039e9cc5dff72b21d5b0986651ff521", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDcwNjY0OTdiMDM5ZTljYzVkZmY3MmIyMWQ1YjA5ODY2NTFmZjUyMQ==", "commit": {"author": {"name": "Johannes Singler", "email": "singler@ira.uka.de", "date": "2008-04-23T07:26:53Z"}, "committer": {"name": "Johannes Singler", "email": "singler@gcc.gnu.org", "date": "2008-04-23T07:26:53Z"}, "message": "quicksort.h: Reformat,\n\n2008-04-23  Johannes Singler  <singler@ira.uka.de>\n\n        * include/parallel/quicksort.h: Reformat,\n        (parallel_sort_qs): Do not pass number of elements.\n        * include/parallel/balanced_quicksort.h: Reformat,\n        (parallel_sort_qsb): Do not pass number of elements.\n        * include/parallel/tags.h:\n        Introduce new tags for compile-time choice.\n        * include/parallel/merge.h:\n        (parallel_merge_advance):Beautified.\n        * include/parallel/algo.h: Reformatting (spaces for tabs)\n        New sort and stable_sort variants, corresponding to the tags.\n        * include/parallel/sort.h:\n        New sort and stable_sort variants, corresponding to the tags.\n        Changed determining the desired number of threads.\n\nFrom-SVN: r134582", "tree": {"sha": "d4c5d467cc26efea3b4f2e39d1e292301b025d29", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d4c5d467cc26efea3b4f2e39d1e292301b025d29"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d7066497b039e9cc5dff72b21d5b0986651ff521", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d7066497b039e9cc5dff72b21d5b0986651ff521", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d7066497b039e9cc5dff72b21d5b0986651ff521", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d7066497b039e9cc5dff72b21d5b0986651ff521/comments", "author": null, "committer": null, "parents": [{"sha": "214ece2920ee4e27aca97c1fef963d1d0f61921e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/214ece2920ee4e27aca97c1fef963d1d0f61921e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/214ece2920ee4e27aca97c1fef963d1d0f61921e"}], "stats": {"total": 2015, "additions": 1226, "deletions": 789}, "files": [{"sha": "dfa4a476397645b48dfe8274c57f2ed1ada0503e", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7066497b039e9cc5dff72b21d5b0986651ff521/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7066497b039e9cc5dff72b21d5b0986651ff521/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=d7066497b039e9cc5dff72b21d5b0986651ff521", "patch": "@@ -1,3 +1,19 @@\n+2008-04-23  Johannes Singler  <singler@ira.uka.de>\n+\n+        * include/parallel/quicksort.h: Reformat,\n+        (parallel_sort_qs): Do not pass number of elements.\n+        * include/parallel/balanced_quicksort.h: Reformat,\n+        (parallel_sort_qsb): Do not pass number of elements.\n+        * include/parallel/tags.h:\n+        Introduce new tags for compile-time choice.\n+        * include/parallel/merge.h:\n+        (parallel_merge_advance):Beautified.\n+        * include/parallel/algo.h: Reformatting (spaces for tabs)\n+        New sort and stable_sort variants, corresponding to the tags.\n+        * include/parallel/sort.h:\n+        New sort and stable_sort variants, corresponding to the tags.\n+        Changed determining the desired number of threads. \n+\n 2008-04-23  Johannes Singler  <singler@ira.uka.de>\n \n         * include/parallel/multiway_merge.h"}, {"sha": "397d7cbcb4f94892b39739d6a898348c29d65520", "filename": "libstdc++-v3/include/parallel/algo.h", "status": "modified", "additions": 953, "deletions": 739, "changes": 1692, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7066497b039e9cc5dff72b21d5b0986651ff521/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Falgo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7066497b039e9cc5dff72b21d5b0986651ff521/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Falgo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Falgo.h?ref=d7066497b039e9cc5dff72b21d5b0986651ff521"}, {"sha": "d94cf332a73da87be4b5e20582562a4f686ef5c8", "filename": "libstdc++-v3/include/parallel/balanced_quicksort.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7066497b039e9cc5dff72b21d5b0986651ff521/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fbalanced_quicksort.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7066497b039e9cc5dff72b21d5b0986651ff521/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fbalanced_quicksort.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fbalanced_quicksort.h?ref=d7066497b039e9cc5dff72b21d5b0986651ff521", "patch": "@@ -252,7 +252,8 @@ template<typename RandomAccessIterator, typename Comparator>\n \n     QSBThreadLocal<RandomAccessIterator>& tl = *tls[iam];\n \n-    difference_type base_case_n = _Settings::get().sort_qsb_base_case_maximal_n;\n+    difference_type base_case_n =\n+        _Settings::get().sort_qsb_base_case_maximal_n;\n     if (base_case_n < 2)\n       base_case_n = 2;\n     thread_index_t num_threads = tl.num_threads;\n@@ -415,16 +416,13 @@ template<typename RandomAccessIterator, typename Comparator>\n   *  @param begin Begin iterator of sequence.\n   *  @param end End iterator of sequence.\n   *  @param comp Comparator.\n-  *  @param n Length of the sequence to sort.\n   *  @param num_threads Number of threads that are allowed to work on\n   *  this part.\n   */\n template<typename RandomAccessIterator, typename Comparator>\n   void\n   parallel_sort_qsb(RandomAccessIterator begin, RandomAccessIterator end,\n                     Comparator comp,\n-                    typename std::iterator_traits<RandomAccessIterator>\n-                        ::difference_type n,\n                     thread_index_t num_threads)\n   {\n     _GLIBCXX_CALL(end - begin)\n@@ -436,6 +434,8 @@ template<typename RandomAccessIterator, typename Comparator>\n \n     typedef QSBThreadLocal<RandomAccessIterator> tls_type;\n \n+    difference_type n = end - begin;\n+\n     if (n <= 1)\n       return;\n "}, {"sha": "cabd5bd4de2ec598f6de8e8307c88256fff6d8fd", "filename": "libstdc++-v3/include/parallel/merge.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7066497b039e9cc5dff72b21d5b0986651ff521/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fmerge.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7066497b039e9cc5dff72b21d5b0986651ff521/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fmerge.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fmerge.h?ref=d7066497b039e9cc5dff72b21d5b0986651ff521", "patch": "@@ -248,7 +248,7 @@ namespace __gnu_parallel\n       typedef typename std::pair<RandomAccessIterator1, RandomAccessIterator1>\n         iterator_pair;\n \n-      std::pair<RandomAccessIterator1, RandomAccessIterator1>\n+      iterator_pair\n \tseqs[2] = { std::make_pair(begin1, end1),\n \t\t    std::make_pair(begin2, end2) };\n       RandomAccessIterator3"}, {"sha": "8ef5b7c03c64302b09fbfd4c52d066153a0cbdcc", "filename": "libstdc++-v3/include/parallel/quicksort.h", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7066497b039e9cc5dff72b21d5b0986651ff521/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fquicksort.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7066497b039e9cc5dff72b21d5b0986651ff521/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fquicksort.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fquicksort.h?ref=d7066497b039e9cc5dff72b21d5b0986651ff521", "patch": "@@ -87,7 +87,8 @@ namespace __gnu_parallel\n \n       __gnu_parallel::binder2nd<Comparator, value_type, value_type, bool>\n         pred(comp, pivot);\n-      difference_type split = parallel_partition(begin, end, pred, num_threads);\n+      difference_type split =\n+          parallel_partition(begin, end, pred, num_threads);\n \n       ::operator delete(samples);\n \n@@ -154,30 +155,27 @@ namespace __gnu_parallel\n    *  @param begin Begin iterator of input sequence.\n    *  @param end End iterator input sequence, ignored.\n    *  @param comp Comparator.\n-   *  @param n Length of input sequence.\n    *  @param num_threads Number of threads that are allowed to work on\n    *  this part.\n    */\n   template<typename RandomAccessIterator, typename Comparator>\n     void\n     parallel_sort_qs(RandomAccessIterator begin,\n \t\t     RandomAccessIterator end,\n-\t\t     Comparator comp, typename std::iterator_traits\n-\t\t     <RandomAccessIterator>::difference_type n,\n-\t\t     int num_threads)\n+\t\t     Comparator comp,\n+\t\t     thread_index_t num_threads)\n     {\n       _GLIBCXX_CALL(n)\n \n       typedef std::iterator_traits<RandomAccessIterator> traits_type;\n       typedef typename traits_type::value_type value_type;\n       typedef typename traits_type::difference_type difference_type;\n \n-      if (n == 0)\n-\treturn;\n+      difference_type n = end - begin;\n \n       // At least one element per processor.\n       if (num_threads > n)\n-\tnum_threads = static_cast<thread_index_t>(n);\n+        num_threads = static_cast<thread_index_t>(n);\n \n       // Hard to avoid.\n       omp_set_num_threads(num_threads);"}, {"sha": "559ed1cc19e1382d5413a32fade752bd12ea9ee9", "filename": "libstdc++-v3/include/parallel/sort.h", "status": "modified", "additions": 147, "deletions": 34, "changes": 181, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7066497b039e9cc5dff72b21d5b0986651ff521/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fsort.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7066497b039e9cc5dff72b21d5b0986651ff521/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fsort.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fsort.h?ref=d7066497b039e9cc5dff72b21d5b0986651ff521", "patch": "@@ -60,62 +60,175 @@\n \n namespace __gnu_parallel\n {\n+\t//prototype\n+  template<bool stable, typename RandomAccessIterator,\n+           typename Comparator, typename Parallelism>\n+  void\n+  parallel_sort(RandomAccessIterator begin, RandomAccessIterator end,\n+  Comparator comp, Parallelism parallelism);\n+\t\n   /** \n+   *  @brief Choose multiway mergesort, splitting variant at run-time,\n+   *  for parallel sorting.\n+   *  @param begin Begin iterator of input sequence.\n+   *  @param end End iterator of input sequence.\n+   *  @param comp Comparator.\n+   *  @callgraph \n+   */\n+  template<bool stable, typename RandomAccessIterator, typename Comparator>\n+  inline void\n+  parallel_sort(RandomAccessIterator begin, RandomAccessIterator end,\n+    Comparator comp, multiway_mergesort_tag parallelism)\n+  {\n+    _GLIBCXX_CALL(end - begin)\n+\n+    if(_Settings::get().sort_splitting == EXACT)\n+      parallel_sort_mwms<stable, true>\n+        (begin, end, comp, parallelism.get_num_threads());\n+    else\n+      parallel_sort_mwms<stable, false>\n+        (begin, end, comp, parallelism.get_num_threads());\n+  }\n+\n+  /** \n+   *  @brief Choose multiway mergesort with exact splitting,\n+   *  for parallel sorting.\n+   *  @param begin Begin iterator of input sequence.\n+   *  @param end End iterator of input sequence.\n+   *  @param comp Comparator.\n+   *  @callgraph \n+   */\n+  template<bool stable, typename RandomAccessIterator, typename Comparator>\n+  inline void\n+  parallel_sort(RandomAccessIterator begin, RandomAccessIterator end,\n+    Comparator comp, multiway_mergesort_exact_tag parallelism)\n+  {\n+    _GLIBCXX_CALL(end - begin)\n+\n+      parallel_sort_mwms<stable, true>\n+        (begin, end, comp, parallelism.get_num_threads());\n+  }\n+\n+  /** \n+   *  @brief Choose multiway mergesort with splitting by sampling,\n+   *  for parallel sorting.\n+   *  @param begin Begin iterator of input sequence.\n+   *  @param end End iterator of input sequence.\n+   *  @param comp Comparator.\n+   *  @callgraph \n+   */\n+  template<bool stable, typename RandomAccessIterator, typename Comparator>\n+  inline void\n+  parallel_sort(RandomAccessIterator begin, RandomAccessIterator end,\n+    Comparator comp, multiway_mergesort_sampling_tag parallelism)\n+  {\n+    _GLIBCXX_CALL(end - begin)\n+\n+    parallel_sort_mwms<stable, false>\n+      (begin, end, comp, parallelism.get_num_threads());\n+  }\n+\n+  /**\n+   *  @brief Choose quicksort for parallel sorting.\n+   *  @param begin Begin iterator of input sequence.\n+   *  @param end End iterator of input sequence.\n+   *  @param comp Comparator.\n+   *  @callgraph \n+   */\n+  template<bool stable, typename RandomAccessIterator, typename Comparator>\n+  inline void\n+  parallel_sort(RandomAccessIterator begin, RandomAccessIterator end,\n+    Comparator comp, quicksort_tag parallelism)\n+  {\n+    _GLIBCXX_CALL(end - begin)\n+\n+    _GLIBCXX_PARALLEL_ASSERT(stable == false);\n+\n+    parallel_sort_qs(begin, end, comp, parallelism.get_num_threads());\n+  }\n+\n+  /**\n+   *  @brief Choose balanced quicksort for parallel sorting.\n+   *  @param begin Begin iterator of input sequence.\n+   *  @param end End iterator of input sequence.\n+   *  @param comp Comparator.\n+   *  @param stable Sort stable.\n+   *  @callgraph \n+   */\n+  template<bool stable, typename RandomAccessIterator, typename Comparator>\n+  inline void\n+  parallel_sort(RandomAccessIterator begin, RandomAccessIterator end,\n+    Comparator comp, balanced_quicksort_tag parallelism)\n+  {\n+    _GLIBCXX_CALL(end - begin)\n+\n+    _GLIBCXX_PARALLEL_ASSERT(stable == false);\n+\n+    parallel_sort_qsb(begin, end, comp, parallelism.get_num_threads());\n+  }\n+\n+\n+  /** \n+   *  @brief Choose multiway mergesort with exact splitting,\n+   *  for parallel sorting.\n+   *  @param begin Begin iterator of input sequence.\n+   *  @param end End iterator of input sequence.\n+   *  @param comp Comparator.\n+   *  @callgraph \n+   */\n+  template<bool stable, typename RandomAccessIterator, typename Comparator>\n+  inline void\n+  parallel_sort(RandomAccessIterator begin, RandomAccessIterator end,\n+    Comparator comp, default_parallel_tag parallelism)\n+  {\n+    _GLIBCXX_CALL(end - begin)\n+\n+    parallel_sort<stable>\n+      (begin, end, comp,\n+        multiway_mergesort_exact_tag(parallelism.get_num_threads()));\n+  }\n+\n+\n+  /**\n    *  @brief Choose a parallel sorting algorithm.\n    *  @param begin Begin iterator of input sequence.\n    *  @param end End iterator of input sequence.\n    *  @param comp Comparator.\n    *  @param stable Sort stable.\n    *  @callgraph \n    */\n-  template<typename RandomAccessIterator, typename Comparator>\n+  template<bool stable, typename RandomAccessIterator, typename Comparator>\n     inline void\n     parallel_sort(RandomAccessIterator begin, RandomAccessIterator end,\n-                  Comparator comp, bool stable)\n+                  Comparator comp, parallel_tag parallelism)\n     {\n       _GLIBCXX_CALL(end - begin)\n       typedef std::iterator_traits<RandomAccessIterator> traits_type;\n       typedef typename traits_type::value_type value_type;\n       typedef typename traits_type::difference_type difference_type;\n \n-      if (begin != end)\n-      {\n-        difference_type n = end - begin;\n-\n-        if (false) ;\n+      if (false) ;\n #if _GLIBCXX_MERGESORT\n-        else if (stable)\n-          {\n-            if(_Settings::get().sort_splitting == EXACT)\n-              parallel_sort_mwms<true, true>\n-                (begin, end, comp, get_max_threads());\n-            else\n-              parallel_sort_mwms<true, false>\n-                (begin, end, comp, get_max_threads());\n-          }\n-        else if (_Settings::get().sort_algorithm == MWMS)\n-          {\n-            if(_Settings::get().sort_splitting == EXACT)\n-              parallel_sort_mwms<false, true>\n-                (begin, end, comp, get_max_threads());\n-            else\n-              parallel_sort_mwms<false, false>\n-                (begin, end, comp, get_max_threads());\n-          }\n+      else if (stable || _Settings::get().sort_algorithm == MWMS)\n+        {\n+          if(_Settings::get().sort_splitting == EXACT)\n+            parallel_sort_mwms<stable, true>\n+              (begin, end, comp, parallelism.get_num_threads());\n+          else\n+            parallel_sort_mwms<false, false>\n+              (begin, end, comp, parallelism.get_num_threads());\n+        }\n #endif\n #if _GLIBCXX_QUICKSORT\n-        else if (!stable && _Settings::get().sort_algorithm == QS)\n-          parallel_sort_qs(begin, end, comp, n, get_max_threads());\n+      else if (_Settings::get().sort_algorithm == QS)\n+        parallel_sort_qs(begin, end, comp, parallelism.get_num_threads());\n #endif\n #if _GLIBCXX_BAL_QUICKSORT\n-        else if (!stable && _Settings::get().sort_algorithm == QS_BALANCED)\n-          parallel_sort_qsb(begin, end, comp, n, get_max_threads());\n+      else if (_Settings::get().sort_algorithm == QS_BALANCED)\n+        parallel_sort_qsb(begin, end, comp, parallelism.get_num_threads());\n #endif\n-        else if(stable)\n-          __gnu_sequential::stable_sort(begin, end, comp);\n-        else\n-          __gnu_sequential::sort(begin, end, comp);\n-      }\n+      else\n+        __gnu_sequential::sort(begin, end, comp);\n     }\n } // end namespace __gnu_parallel\n "}, {"sha": "cf937af49525c6258355a3b7fe92a278a3293153", "filename": "libstdc++-v3/include/parallel/tags.h", "status": "modified", "additions": 99, "deletions": 3, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7066497b039e9cc5dff72b21d5b0986651ff521/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ftags.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7066497b039e9cc5dff72b21d5b0986651ff521/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ftags.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ftags.h?ref=d7066497b039e9cc5dff72b21d5b0986651ff521", "patch": "@@ -1,6 +1,6 @@\n // -*- C++ -*-\n \n-// Copyright (C) 2007 Free Software Foundation, Inc.\n+// Copyright (C) 2007, 2008 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the terms\n@@ -39,6 +39,9 @@\n #ifndef _GLIBCXX_PARALLEL_TAGS_H\n #define _GLIBCXX_PARALLEL_TAGS_H 1\n \n+#include <omp.h>\n+#include <parallel/types.h>\n+\n namespace __gnu_parallel\n {\n   /** @brief Forces sequential execution at compile time. */\n@@ -47,8 +50,53 @@ namespace __gnu_parallel\n   /** @brief Forces exact splitting in multiway merge at compile time. */\n   struct exact_tag { };\n \n-  /** @brief Recommends parallel execution at compile time. */\n-  struct parallel_tag { };\n+  /** @brief Recommends parallel execution at compile time,\n+   *  optionally using a user-specified number of threads. */\n+  struct parallel_tag\n+  {\n+    private:\n+      thread_index_t num_threads;\n+\n+    public:\n+      /** @brief Default constructor. Use default number of threads. */\n+      parallel_tag()\n+      {\n+        this->num_threads = 0;\n+      }\n+\n+      /** @brief Default constructor. Recommend number of threads to use.\n+       *  @param num_threads Desired number of threads. */\n+      parallel_tag(thread_index_t num_threads)\n+      {\n+        this->num_threads = num_threads;\n+      }\n+\n+      /** @brief Find out desired number of threads.\n+       *  @return Desired number of threads. */\n+      inline thread_index_t get_num_threads()\n+      {\n+        if(num_threads == 0)\n+          return omp_get_max_threads();\n+        else\n+          return num_threads;\n+      }\n+\n+      /** @brief Set the desired number of threads.\n+       *  @param num_threads Desired number of threads. */\n+      inline void set_num_threads(thread_index_t num_threads)\n+      {\n+        this->num_threads = num_threads;\n+      }\n+  };\n+\n+  /** @brief Recommends parallel execution using the\n+      default parallel algorithm. */\n+  struct default_parallel_tag : public parallel_tag\n+  {\n+      default_parallel_tag() { }\n+      default_parallel_tag(thread_index_t num_threads)\n+          : parallel_tag(num_threads) { }\n+  };\n \n   /** @brief Recommends parallel execution using dynamic\n       load-balancing at compile time. */\n@@ -67,8 +115,56 @@ namespace __gnu_parallel\n   struct omp_loop_static_tag : public parallel_tag { };\n \n \n+  /** @brief Base class for for std::find() variants. */\n   struct find_tag { };\n \n+\n+  /** @brief Forces parallel sorting using multiway mergesort\n+   *  at compile time. */\n+  struct multiway_mergesort_tag : public parallel_tag\n+  {\n+      multiway_mergesort_tag() { }\n+      multiway_mergesort_tag(thread_index_t num_threads)\n+          : parallel_tag(num_threads) { }\n+  };\n+\n+  /** @brief Forces parallel sorting using multiway mergesort\n+   *  with exact splitting at compile time. */\n+  struct multiway_mergesort_exact_tag : public parallel_tag\n+  {\n+      multiway_mergesort_exact_tag() { }\n+      multiway_mergesort_exact_tag(thread_index_t num_threads)\n+          : parallel_tag(num_threads) { }\n+  };\n+\n+  /** @brief Forces parallel sorting using multiway mergesort\n+   *  with splitting by sampling at compile time. */\n+  struct multiway_mergesort_sampling_tag : public parallel_tag\n+  {\n+      multiway_mergesort_sampling_tag() { }\n+      multiway_mergesort_sampling_tag(thread_index_t num_threads)\n+          : parallel_tag(num_threads) { }\n+  };\n+\n+  /** @brief Forces parallel sorting using unbalanced quicksort\n+   *  at compile time. */\n+  struct quicksort_tag : public parallel_tag\n+  {\n+      quicksort_tag() { }\n+      quicksort_tag(thread_index_t num_threads)\n+          : parallel_tag(num_threads) { }\n+  };\n+\n+  /** @brief Forces parallel sorting using balanced quicksort\n+   *  at compile time. */\n+  struct balanced_quicksort_tag : public parallel_tag\n+  {\n+      balanced_quicksort_tag() { }\n+      balanced_quicksort_tag(thread_index_t num_threads)\n+          : parallel_tag(num_threads) { }\n+  };\n+\n+\n   /** @brief Selects the growing block size variant for std::find().\n       @see _GLIBCXX_FIND_GROWING_BLOCKS */\n   struct growing_blocks_tag : public find_tag { };"}]}