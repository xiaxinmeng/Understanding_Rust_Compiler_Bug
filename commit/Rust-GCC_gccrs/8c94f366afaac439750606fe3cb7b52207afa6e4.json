{"sha": "8c94f366afaac439750606fe3cb7b52207afa6e4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGM5NGYzNjZhZmFhYzQzOTc1MDYwNmZlM2NiN2I1MjIwN2FmYTZlNA==", "commit": {"author": {"name": "Zack Weinberg", "email": "zackw@panix.com", "date": "2006-01-23T15:15:52Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2006-01-23T15:15:52Z"}, "message": "r110127@banpei: zack | 2006-01-22 14:49:27 -0800\n\n r110127@banpei:  zack | 2006-01-22 14:49:27 -0800\n \t* genattrtab.c: Don't include genattrtab.h.  Define ATTR_NONE\n \tand ATTR_SPECIAL (from genattrtab.h).  Don't define num_dfa_decls\n \tnor any of the random handful of variables that used to be necessary\n \twhen this program was linked with rtlanal.o.  Prune set of forward\n \tfunction declarations.\n \t(struct attr_desc): Remove static_p field.\n \t(hash_obstack, temp_obstack, attr_hash_table, attr_printf)\n \t(check_attr_test, make_internal_attr, make_numeric_value): Make static.\n \t(attr_string): Do not read the character one past the length of\n \tthe string.\n \t(write_attr_get, find_attr, make_internal_attr): Don't touch static_p.\n \t(struct insn_reserv, all_insn_reservs, last_insn_reserv_p)\n \t(n_insn_reservs, gen_insn_reserv, struct bypass_list, all_bypasses)\n \t(n_bypasses, gen_bypass_1, gen_bypass, process_bypasses)\n \t(make_automaton_attrs): New.\n \t(main): Do not call into genautomata.  Call local gen_bypass\n \tand gen_insn_reserv as appropriate.  Call make_automaton_attrs.\n \tRemove special case for insn_alts.\n \t* genautomata.c: Include gensupport.h; not genattrtab.h nor\n \tvarray.h (leftover from previous change).  Prune set of forward\n \tfunction declarations.  Remove state_alts fields from all\n \tstructures.  Remove state_alts_table from struct automaton.\n \tMake everything except main static.  Do not maintain num_dfa_decls.\n \tDo not maintain state_alts fields of various structures.\n \t(process_decls): Don't validate condexp for dm_insn_reserv decls.\n \t(add_arc): Remove state_alts argument.  All callers updated.\n \t(output_reserved_units_table): Emit #ifdef here...\n \t(output_tables): ...not here.  Don't generate state_alts tables.\n \t(expand_automata): Don't generate attributes.\n \t(write_automata): Don't generate state_alts functions.\n \t(main): New function.\n \t(it_is_empty_reserv_sets, output_state_alts_full_vect_name)\n \t(output_state_alts_comb_vect_name, output_state_alts_check_vect_name)\n \t(AUTOMATON_STATE_ALTS_MACRO_NAME, INTERNAL_STATE_ALTS_FUNC_NAME)\n \t(STATE_ALTS_FUNC_NAME, INSN_DEFAULT_LATENCY_FUNC_NAME)\n \t(BYPASS_P_FUNC_NAME, output_state_alts_table)\n \t(output_automata_list_state_alts_code, output_internal_state_alts_func)\n \t(output_state_alts_func, make_insn_alts_attr, make_bypass_attr)\n \t(make_internal_dfa_insn_code_attr, make_default_insn_latency_attr):\n \tDelete.\n \t* genattr.c: Declare internal_dfa_insn_code in insn-attr.h.\n \t* genattrtab.h: Delete file.\n \t* Makefile.in (OBJS-common): Add insn-automata.o.\n \t(insn-automata.o): New rule.\n \t(simple_generated_c): Add insn-automata.c.\n \t(build/genattrtab.o, build/genautomata.o): Update dependencies.\n \t(genprogmd): Add automata.\n \t(build/genattrtab): Needs no extra objects nor libraries.\n \t(build/genautomata): Needs build/vec.o and -lm.\n\nFrom-SVN: r110123", "tree": {"sha": "e315ad25f6c7c0742772baee24304e78ebe61107", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e315ad25f6c7c0742772baee24304e78ebe61107"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8c94f366afaac439750606fe3cb7b52207afa6e4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c94f366afaac439750606fe3cb7b52207afa6e4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8c94f366afaac439750606fe3cb7b52207afa6e4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c94f366afaac439750606fe3cb7b52207afa6e4/comments", "author": {"login": "zackw", "id": 325899, "node_id": "MDQ6VXNlcjMyNTg5OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/325899?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zackw", "html_url": "https://github.com/zackw", "followers_url": "https://api.github.com/users/zackw/followers", "following_url": "https://api.github.com/users/zackw/following{/other_user}", "gists_url": "https://api.github.com/users/zackw/gists{/gist_id}", "starred_url": "https://api.github.com/users/zackw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zackw/subscriptions", "organizations_url": "https://api.github.com/users/zackw/orgs", "repos_url": "https://api.github.com/users/zackw/repos", "events_url": "https://api.github.com/users/zackw/events{/privacy}", "received_events_url": "https://api.github.com/users/zackw/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "5f2f0edd8e6bdc48ee5f2383a87e91c301cf286a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f2f0edd8e6bdc48ee5f2383a87e91c301cf286a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5f2f0edd8e6bdc48ee5f2383a87e91c301cf286a"}], "stats": {"total": 1469, "additions": 428, "deletions": 1041}, "files": [{"sha": "12b58aac295650c48dbf0143db35e92bcfb4ec38", "filename": "gcc/ChangeLog", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c94f366afaac439750606fe3cb7b52207afa6e4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c94f366afaac439750606fe3cb7b52207afa6e4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8c94f366afaac439750606fe3cb7b52207afa6e4", "patch": "@@ -1,3 +1,55 @@\n+2006-01-22  Zack Weinberg  <zackw@panix.com>\n+\n+\t* genattrtab.c: Don't include genattrtab.h.  Define ATTR_NONE\n+\tand ATTR_SPECIAL (from genattrtab.h).  Don't define num_dfa_decls\n+\tnor any of the random handful of variables that used to be necessary\n+\twhen this program was linked with rtlanal.o.  Prune set of forward\n+\tfunction declarations.\n+\t(struct attr_desc): Remove static_p field.\n+\t(hash_obstack, temp_obstack, attr_hash_table, attr_printf)\n+\t(check_attr_test, make_internal_attr, make_numeric_value): Make static.\n+\t(attr_string): Do not read the character one past the length of\n+\tthe string.\n+\t(write_attr_get, find_attr, make_internal_attr): Don't touch static_p.\n+\t(struct insn_reserv, all_insn_reservs, last_insn_reserv_p)\n+\t(n_insn_reservs, gen_insn_reserv, struct bypass_list, all_bypasses)\n+\t(n_bypasses, gen_bypass_1, gen_bypass, process_bypasses)\n+\t(make_automaton_attrs): New.\n+\t(main): Do not call into genautomata.  Call local gen_bypass\n+\tand gen_insn_reserv as appropriate.  Call make_automaton_attrs.\n+\tRemove special case for insn_alts.\n+\t* genautomata.c: Include gensupport.h; not genattrtab.h nor\n+\tvarray.h (leftover from previous change).  Prune set of forward\n+\tfunction declarations.  Remove state_alts fields from all\n+\tstructures.  Remove state_alts_table from struct automaton.\n+\tMake everything except main static.  Do not maintain num_dfa_decls.\n+\tDo not maintain state_alts fields of various structures.\n+\t(process_decls): Don't validate condexp for dm_insn_reserv decls.\n+\t(add_arc): Remove state_alts argument.  All callers updated.\n+\t(output_reserved_units_table): Emit #ifdef here...\n+\t(output_tables): ...not here.  Don't generate state_alts tables.\n+\t(expand_automata): Don't generate attributes.\n+\t(write_automata): Don't generate state_alts functions.\n+\t(main): New function.\n+\t(it_is_empty_reserv_sets, output_state_alts_full_vect_name)\n+\t(output_state_alts_comb_vect_name, output_state_alts_check_vect_name)\n+\t(AUTOMATON_STATE_ALTS_MACRO_NAME, INTERNAL_STATE_ALTS_FUNC_NAME)\n+\t(STATE_ALTS_FUNC_NAME, INSN_DEFAULT_LATENCY_FUNC_NAME)\n+\t(BYPASS_P_FUNC_NAME, output_state_alts_table)\n+\t(output_automata_list_state_alts_code, output_internal_state_alts_func)\n+\t(output_state_alts_func, make_insn_alts_attr, make_bypass_attr)\n+\t(make_internal_dfa_insn_code_attr, make_default_insn_latency_attr):\n+\tDelete.\n+\t* genattr.c: Declare internal_dfa_insn_code in insn-attr.h.\n+\t* genattrtab.h: Delete file.\n+\t* Makefile.in (OBJS-common): Add insn-automata.o.\n+\t(insn-automata.o): New rule.\n+\t(simple_generated_c): Add insn-automata.c.\n+\t(build/genattrtab.o, build/genautomata.o): Update dependencies.\n+\t(genprogmd): Add automata.\n+\t(build/genattrtab): Needs no extra objects nor libraries.\n+\t(build/genautomata): Needs build/vec.o and -lm.\n+\n 2006-01-22  Zack Weinberg  <zackw@panix.com>\n \n \t* genautomata.c (process_state_longest_path, max_dfa_issue_rate)"}, {"sha": "6cc74fe85fda54c0e76643c2376851e1f44adf1e", "filename": "gcc/Makefile.in", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c94f366afaac439750606fe3cb7b52207afa6e4/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c94f366afaac439750606fe3cb7b52207afa6e4/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=8c94f366afaac439750606fe3cb7b52207afa6e4", "patch": "@@ -981,7 +981,7 @@ OBJS-common = \\\n  integrate.o intl.o jump.o  langhooks.o lcm.o lists.o local-alloc.o  \t   \\\n  loop.o mode-switching.o modulo-sched.o optabs.o options.o opts.o\t   \\\n  params.o postreload.o postreload-gcse.o predict.o\t\t\t   \\\n- insn-preds.o pointer-set.o \t\t\t\t\t   \t   \\\n+ insn-preds.o insn-automata.o pointer-set.o \t\t\t   \t   \\\n  print-rtl.o print-tree.o profile.o value-prof.o var-tracking.o\t\t   \\\n  real.o recog.o reg-stack.o regclass.o regmove.o regrename.o\t\t   \\\n  reload.o reload1.o reorg.o resource.o rtl.o rtlanal.o rtl-error.o\t   \\\n@@ -2639,6 +2639,8 @@ genrtl.o : genrtl.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H)\t$(RTL_H)\\\n insn-attrtab.o : insn-attrtab.c $(CONFIG_H) $(SYSTEM_H) coretypes.h\t\\\n   $(TM_H) $(RTL_H) $(REGS_H) real.h output.h $(INSN_ATTR_H)\t\t\\\n   insn-config.h toplev.h $(RECOG_H) $(TM_P_H) $(FLAGS_H)\n+insn-automata.o : insn-automata.c $(CONFIG_H) $(SYSTEM_H) coretypes.h\t\\\n+  $(TM_H) $(RTL_H) $(INSN_ATTR_H)\n insn-emit.o : insn-emit.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H)\t\\\n   $(RTL_H) $(EXPR_H) real.h output.h insn-config.h $(OPTABS_H)\t\t\\\n   reload.h $(RECOG_H) toplev.h $(FUNCTION_H) $(FLAGS_H) hard-reg-set.h\t\\\n@@ -2675,9 +2677,9 @@ insn-recog.o : insn-recog.c $(CONFIG_H) $(SYSTEM_H) coretypes.h\t\t\\\n \n simple_generated_h = insn-attr.h insn-codes.h insn-config.h insn-flags.h \n \n-simple_generated_c = insn-attrtab.c insn-emit.c insn-extract.c\t\\\n-\t\t     insn-opinit.c insn-output.c insn-peep.c\t\\\n-\t\t     insn-recog.c\n+simple_generated_c = insn-attrtab.c insn-automata.c insn-emit.c \\\n+\t\t     insn-extract.c insn-opinit.c insn-output.c \\\n+\t\t     insn-peep.c insn-recog.c\n \n $(simple_generated_h): insn-%.h: s-%; @true\n \n@@ -2906,10 +2908,10 @@ build/genattr.o : genattr.c $(RTL_BASE_H) $(BCONFIG_H) $(SYSTEM_H)\t\\\n   coretypes.h $(GTM_H) errors.h gensupport.h\n build/genattrtab.o : genattrtab.c $(RTL_BASE_H) $(OBSTACK_H)\t\t\\\n   $(BCONFIG_H) $(SYSTEM_H) coretypes.h $(GTM_H) errors.h $(GGC_H)\t\\\n-  gensupport.h genattrtab.h\n+  gensupport.h\n build/genautomata.o : genautomata.c $(RTL_BASE_H) $(OBSTACK_H)\t\t\\\n   $(BCONFIG_H) $(SYSTEM_H) coretypes.h $(GTM_H) errors.h vec.h\t\t\\\n-  genattrtab.h $(HASHTAB_H)\n+  $(HASHTAB_H) gensupport.h\n build/gencheck.o : gencheck.c gencheck.h tree.def $(BCONFIG_H) $(GTM_H)\t\\\n \t$(SYSTEM_H) coretypes.h $(lang_tree_files)\n build/genchecksum.o : genchecksum.c $(BCONFIG_H) $(SYSTEM_H) $(MD5_H)\n@@ -2960,14 +2962,15 @@ build/gen%$(build_exeext): build/gen%.o $(BUILD_LIBDEPS)\n \t    $(filter-out $(BUILD_LIBDEPS), $^) $(BUILD_LIBS)\n \n # All these programs use the MD reader ($(BUILD_RTL)).\n-genprogmd = attr attrtab codes conditions config constants emit extract \\\n-\t    flags mddeps opinit output peep preds recog\n+genprogmd = attr attrtab automata codes conditions config constants emit \\\n+\t    extract flags mddeps opinit output peep preds recog\n $(genprogmd:%=build/gen%$(build_exeext)): $(BUILD_RTL) $(BUILD_ERRORS)\n \n # These programs need files over and above what they get from the above list.\n build/genextract$(build_exeext) : build/vec.o\n-build/genattrtab$(build_exeext) : build/genautomata.o build/vec.o\n-build/genattrtab$(build_exeext) : BUILD_LIBS += -lm\n+\n+build/genautomata$(build_exeext) : build/vec.o\n+build/genautomata$(build_exeext) : BUILD_LIBS += -lm\n \n # These programs are not linked with the MD reader.\n build/gengenrtl$(build_exeext) : $(BUILD_ERRORS)"}, {"sha": "9d8cf95f0ae50a8c09f4e230f5b92fa8986c5a3f", "filename": "gcc/genattr.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c94f366afaac439750606fe3cb7b52207afa6e4/gcc%2Fgenattr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c94f366afaac439750606fe3cb7b52207afa6e4/gcc%2Fgenattr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenattr.c?ref=8c94f366afaac439750606fe3cb7b52207afa6e4", "patch": "@@ -174,6 +174,8 @@ main (int argc, char **argv)\n       printf (\"#define CPU_UNITS_QUERY 0\\n\");\n       printf (\"#endif\\n\\n\");\n       /* Interface itself: */\n+      printf (\"/* Internal insn code number used by automata.  */\\n\");\n+      printf (\"extern int internal_dfa_insn_code (rtx);\\n\\n\");\n       printf (\"/* Insn latency time defined in define_insn_reservation. */\\n\");\n       printf (\"extern int insn_default_latency (rtx);\\n\\n\");\n       printf (\"/* Return nonzero if there is a bypass for given insn\\n\");"}, {"sha": "755a9a41f027d9c1d037de0b0bfec8e365e73805", "filename": "gcc/genattrtab.c", "status": "modified", "additions": 215, "deletions": 179, "changes": 394, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c94f366afaac439750606fe3cb7b52207afa6e4/gcc%2Fgenattrtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c94f366afaac439750606fe3cb7b52207afa6e4/gcc%2Fgenattrtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenattrtab.c?ref=8c94f366afaac439750606fe3cb7b52207afa6e4", "patch": "@@ -109,23 +109,17 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"coretypes.h\"\n #include \"tm.h\"\n #include \"rtl.h\"\n-#include \"ggc.h\"\n #include \"gensupport.h\"\n-\n-#ifdef HAVE_SYS_RESOURCE_H\n-# include <sys/resource.h>\n-#endif\n-\n-/* We must include obstack.h after <sys/time.h>, to avoid lossage with\n-   /usr/include/sys/stdtypes.h on Sun OS 4.x.  */\n #include \"obstack.h\"\n #include \"errors.h\"\n \n-#include \"genattrtab.h\"\n+/* Flags for make_internal_attr's `special' parameter.  */\n+#define ATTR_NONE\t\t0\n+#define ATTR_SPECIAL\t\t(1 << 0)\n \n static struct obstack obstack1, obstack2;\n-struct obstack *hash_obstack = &obstack1;\n-struct obstack *temp_obstack = &obstack2;\n+static struct obstack *hash_obstack = &obstack1;\n+static struct obstack *temp_obstack = &obstack2;\n \n /* enough space to reserve for printing out ints */\n #define MAX_DIGITS (HOST_BITS_PER_INT * 3 / 10 + 3)\n@@ -183,7 +177,6 @@ struct attr_desc\n   unsigned is_numeric\t: 1;\t/* Values of this attribute are numeric.  */\n   unsigned is_const\t: 1;\t/* Attribute value constant for each run.  */\n   unsigned is_special\t: 1;\t/* Don't call `write_attr_set'.  */\n-  unsigned static_p\t: 1;\t/* Make the output function static.  */\n };\n \n /* Structure for each DEFINE_DELAY.  */\n@@ -217,8 +210,6 @@ static int num_delays;\n static int have_annul_true, have_annul_false;\n static int num_insn_ents;\n \n-int num_dfa_decls;\n-\n /* Stores, for each insn code, the number of constraint alternatives.  */\n \n static int *insn_n_alternatives;\n@@ -240,16 +231,6 @@ static const char *delay_type_str;\n static const char *delay_1_0_str;\n static const char *num_delay_slots_str;\n \n-/* Indicate that REG_DEAD notes are valid if dead_or_set_p is ever\n-   called.  */\n-\n-int reload_completed = 0;\n-\n-/* Some machines test `optimize' in macros called from rtlanal.c, so we need\n-   to define it here.  */\n-\n-int optimize = 0;\n-\n /* Simplify an expression.  Only call the routine if there is something to\n    simplify.  */\n #define SIMPLIFY_TEST_EXP(EXP,INSN_CODE,INSN_INDEX)\t\\\n@@ -258,88 +239,44 @@ int optimize = 0;\n \n #define DEF_ATTR_STRING(S) (attr_string ((S), strlen (S)))\n \n-/* These are referenced by rtlanal.c and hence need to be defined somewhere.\n-   They won't actually be used.  */\n-\n-rtx global_rtl[GR_MAX];\n-rtx pic_offset_table_rtx;\n-\n-static void attr_hash_add_rtx\t(int, rtx);\n-static void attr_hash_add_string (int, char *);\n-static rtx attr_rtx\t\t(enum rtx_code, ...);\n-static rtx attr_rtx_1\t\t(enum rtx_code, va_list);\n-static char *attr_string        (const char *, int);\n-static rtx check_attr_value\t(rtx, struct attr_desc *);\n-static rtx convert_set_attr_alternative (rtx, struct insn_def *);\n-static rtx convert_set_attr\t(rtx, struct insn_def *);\n-static void check_defs\t\t(void);\n-static rtx make_canonical\t(struct attr_desc *, rtx);\n-static struct attr_value *get_attr_value (rtx, struct attr_desc *, int);\n-static rtx copy_rtx_unchanging\t(rtx);\n-static rtx copy_boolean\t\t(rtx);\n-static void expand_delays\t(void);\n-static void fill_attr\t\t(struct attr_desc *);\n-static rtx substitute_address\t(rtx, rtx (*) (rtx), rtx (*) (rtx));\n-static void make_length_attrs\t(void);\n-static rtx identity_fn\t\t(rtx);\n-static rtx zero_fn\t\t(rtx);\n-static rtx one_fn\t\t(rtx);\n-static rtx max_fn\t\t(rtx);\n-static rtx min_fn\t\t(rtx);\n-static void write_length_unit_log (void);\n-static rtx simplify_cond\t(rtx, int, int);\n-static void clear_struct_flag (rtx);\n-static void remove_insn_ent  (struct attr_value *, struct insn_ent *);\n-static void insert_insn_ent  (struct attr_value *, struct insn_ent *);\n-static rtx insert_right_side\t(enum rtx_code, rtx, rtx, int, int);\n-static rtx make_alternative_compare (int);\n-static int compute_alternative_mask (rtx, enum rtx_code);\n-static rtx evaluate_eq_attr\t(rtx, rtx, int, int);\n-static rtx simplify_and_tree\t(rtx, rtx *, int, int);\n-static rtx simplify_or_tree\t(rtx, rtx *, int, int);\n-static rtx simplify_test_exp\t(rtx, int, int);\n-static rtx simplify_test_exp_in_temp (rtx, int, int);\n-static void optimize_attrs\t(void);\n-static void gen_attr\t\t(rtx, int);\n-static int count_alternatives\t(rtx);\n-static int compares_alternatives_p (rtx);\n-static int contained_in_p\t(rtx, rtx);\n-static void gen_insn\t\t(rtx, int);\n-static void gen_delay\t\t(rtx, int);\n-static void write_test_expr\t(rtx, int);\n-static int max_attr_value\t(rtx, int*);\n-static int min_attr_value\t(rtx, int*);\n-static int or_attr_value\t(rtx, int*);\n-static void walk_attr_value\t(rtx);\n-static void write_attr_get\t(struct attr_desc *);\n-static rtx eliminate_known_true (rtx, rtx, int, int);\n-static void write_attr_set\t(struct attr_desc *, int, rtx,\n-\t\t\t\t const char *, const char *, rtx,\n-\t\t\t\t int, int);\n-static void write_insn_cases\t(struct insn_ent *, int);\n-static void write_attr_case\t(struct attr_desc *, struct attr_value *,\n-\t\t\t\t int, const char *, const char *, int, rtx);\n-static void write_attr_valueq\t(struct attr_desc *, const char *);\n-static void write_attr_value\t(struct attr_desc *, rtx);\n-static void write_upcase\t(const char *);\n-static void write_indent\t(int);\n-static void write_eligible_delay (const char *);\n-static int write_expr_attr_cache (rtx, struct attr_desc *);\n-static void write_const_num_delay_slots (void);\n-static char *next_comma_elt\t(const char **);\n+/* Forward declarations of functions used before their definitions, only.  */\n+static char *attr_string           (const char *, int);\n+static char *attr_printf           (unsigned int, const char *, ...)\n+  ATTRIBUTE_PRINTF_2;\n+static rtx make_numeric_value      (int);\n static struct attr_desc *find_attr (const char **, int);\n-static struct attr_value *find_most_used  (struct attr_desc *);\n-static rtx attr_eq\t\t(const char *, const char *);\n-static const char *attr_numeral\t(int);\n-static int attr_equal_p\t\t(rtx, rtx);\n-static rtx attr_copy_rtx\t(rtx);\n-static int attr_rtx_cost\t(rtx);\n-static bool attr_alt_subset_p (rtx, rtx);\n+static rtx mk_attr_alt             (int);\n+static char *next_comma_elt\t   (const char **);\n+static rtx insert_right_side\t   (enum rtx_code, rtx, rtx, int, int);\n+static rtx copy_boolean\t\t   (rtx);\n+static int compares_alternatives_p (rtx);\n+static void make_internal_attr     (const char *, rtx, int);\n+static void insert_insn_ent        (struct attr_value *, struct insn_ent *);\n+static void walk_attr_value\t   (rtx);\n+static int max_attr_value\t   (rtx, int*);\n+static int min_attr_value\t   (rtx, int*);\n+static int or_attr_value\t   (rtx, int*);\n+static rtx simplify_test_exp\t   (rtx, int, int);\n+static rtx simplify_test_exp_in_temp (rtx, int, int);\n+static rtx copy_rtx_unchanging\t   (rtx);\n+static bool attr_alt_subset_p      (rtx, rtx);\n static bool attr_alt_subset_of_compl_p (rtx, rtx);\n-static rtx attr_alt_intersection (rtx, rtx);\n-static rtx attr_alt_union (rtx, rtx);\n-static rtx attr_alt_complement (rtx);\n-static rtx mk_attr_alt (int);\n+static void clear_struct_flag      (rtx);\n+static void write_attr_valueq\t   (struct attr_desc *, const char *);\n+static struct attr_value *find_most_used  (struct attr_desc *);\n+static void write_attr_set\t   (struct attr_desc *, int, rtx,\n+\t\t\t\t    const char *, const char *, rtx,\n+\t\t\t\t    int, int);\n+static void write_attr_case\t   (struct attr_desc *, struct attr_value *,\n+\t\t\t\t    int, const char *, const char *, int, rtx);\n+static void write_attr_value\t   (struct attr_desc *, rtx);\n+static void write_upcase\t   (const char *);\n+static void write_indent\t   (int);\n+static rtx identity_fn\t\t   (rtx);\n+static rtx zero_fn\t\t   (rtx);\n+static rtx one_fn\t\t   (rtx);\n+static rtx max_fn\t\t   (rtx);\n+static rtx min_fn\t\t   (rtx);\n \n #define oballoc(size) obstack_alloc (hash_obstack, size)\n \n@@ -368,7 +305,7 @@ struct attr_hash\n    for each.  */\n \n #define RTL_HASH_SIZE 4093\n-struct attr_hash *attr_hash_table[RTL_HASH_SIZE];\n+static struct attr_hash *attr_hash_table[RTL_HASH_SIZE];\n \n /* Here is how primitive or already-shared RTL's hash\n    codes are made.  */\n@@ -603,7 +540,7 @@ attr_rtx (enum rtx_code code, ...)\n \n    rtx attr_printf (len, format, [arg1, ..., argn])  */\n \n-char *\n+static char *\n attr_printf (unsigned int len, const char *fmt, ...)\n {\n   char str[256];\n@@ -644,7 +581,7 @@ attr_string (const char *str, int len)\n \n   /* Compute the hash code.  */\n   hashcode = (len + 1) * 613 + (unsigned) str[0];\n-  for (i = 1; i <= len; i += 2)\n+  for (i = 1; i < len; i += 2)\n     hashcode = ((hashcode * 613) + (unsigned) str[i]);\n   if (hashcode < 0)\n     hashcode = -hashcode;\n@@ -773,7 +710,7 @@ attr_copy_rtx (rtx orig)\n \n    Return the new expression, if any.  */\n \n-rtx\n+static rtx\n check_attr_test (rtx exp, int is_const, int lineno)\n {\n   struct attr_desc *attr;\n@@ -3711,8 +3648,6 @@ write_attr_get (struct attr_desc *attr)\n \n   /* Write out start of function, then all values with explicit `case' lines,\n      then a `default', then the value with the most uses.  */\n-  if (attr->static_p)\n-    printf (\"static \");\n   if (!attr->is_numeric)\n     printf (\"enum attr_%s\\n\", attr->name);\n   else\n@@ -4281,7 +4216,6 @@ find_attr (const char **name_p, int create)\n   attr->name = DEF_ATTR_STRING (name);\n   attr->first_value = attr->default_val = NULL;\n   attr->is_numeric = attr->is_const = attr->is_special = 0;\n-  attr->static_p = 0;\n   attr->next = attrs[index];\n   attrs[index] = attr;\n \n@@ -4292,7 +4226,7 @@ find_attr (const char **name_p, int create)\n \n /* Create internal attribute with the given default value.  */\n \n-void\n+static void\n make_internal_attr (const char *name, rtx value, int special)\n {\n   struct attr_desc *attr;\n@@ -4303,7 +4237,6 @@ make_internal_attr (const char *name, rtx value, int special)\n   attr->is_numeric = 1;\n   attr->is_const = 0;\n   attr->is_special = (special & ATTR_SPECIAL) != 0;\n-  attr->static_p = (special & ATTR_STATIC) != 0;\n   attr->default_val = get_attr_value (value, attr, -2);\n }\n \n@@ -4328,7 +4261,7 @@ find_most_used (struct attr_desc *attr)\n \n /* Return (attr_value \"n\") */\n \n-rtx\n+static rtx\n make_numeric_value (int n)\n {\n   static rtx int_values[20];\n@@ -4388,6 +4321,168 @@ write_const_num_delay_slots (void)\n       printf (\"    }\\n}\\n\\n\");\n     }\n }\n+\f\n+/* Synthetic attributes used by insn-automata.c and the scheduler.\n+   These are primarily concerned with (define_insn_reservation)\n+   patterns.  */\n+\n+struct insn_reserv\n+{\n+  struct insn_reserv *next;\n+\n+  const char *name;\n+  int default_latency;\n+  rtx condexp;\n+\n+  /* Sequence number of this insn.  */\n+  int insn_num;\n+\n+  /* Whether a (define_bypass) construct names this insn in its\n+     output list.  */\n+  bool bypassed;\n+};\n+\n+static struct insn_reserv *all_insn_reservs = 0;\n+static struct insn_reserv **last_insn_reserv_p = &all_insn_reservs;\n+static size_t n_insn_reservs;\n+\n+/* Store information from a DEFINE_INSN_RESERVATION for future\n+   attribute generation.  */\n+static void\n+gen_insn_reserv (rtx def)\n+{\n+  struct insn_reserv *decl = oballoc (sizeof (struct insn_reserv));\n+\n+  decl->name            = DEF_ATTR_STRING (XSTR (def, 0));\n+  decl->default_latency = XINT (def, 1);\n+  decl->condexp         = check_attr_test (XEXP (def, 2), 0, 0);\n+  decl->insn_num        = n_insn_reservs;\n+  decl->bypassed\t= false;\n+  decl->next            = 0;\n+  \n+  *last_insn_reserv_p = decl;\n+  last_insn_reserv_p  = &decl->next;\n+  n_insn_reservs++;\n+}\n+\n+/* Store information from a DEFINE_BYPASS for future attribute\n+   generation.  The only thing we care about is the list of output\n+   insns, which will later be used to tag reservation structures with\n+   a 'bypassed' bit.  */\n+\n+struct bypass_list\n+{\n+  struct bypass_list *next;\n+  const char *insn;\n+};\n+\n+static struct bypass_list *all_bypasses;\n+static size_t n_bypasses;\n+\n+static void\n+gen_bypass_1 (const char *s, size_t len)\n+{\n+  struct bypass_list *b;\n+\n+  if (len == 0)\n+    return;\n+\n+  s = attr_string (s, len);\n+  for (b = all_bypasses; b; b = b->next)\n+    if (s == b->insn)\n+      return;  /* already got that one */\n+\n+  b = oballoc (sizeof (struct bypass_list));\n+  b->insn = s;\n+  b->next = all_bypasses;\n+  all_bypasses = b;\n+  n_bypasses++;\n+}\n+\n+static void\n+gen_bypass (rtx def)\n+{\n+  const char *p, *base;\n+\n+  for (p = base = XSTR (def, 1); *p; p++)\n+    if (*p == ',')\n+      {\n+\tgen_bypass_1 (base, p - base);\n+\tbase = p + 1;\n+      }\n+  gen_bypass_1 (base, p - base);\n+}\n+\n+/* Find and mark all of the bypassed insns.  */\n+static void\n+process_bypasses (void)\n+{\n+  struct bypass_list *b;\n+  struct insn_reserv *r;\n+\n+  /* The reservation list is likely to be much longer than the bypass\n+     list.  */\n+  for (r = all_insn_reservs; r; r = r->next)\n+    for (b = all_bypasses; b; b = b->next)\n+      if (r->name == b->insn)\n+\tr->bypassed = true;\n+}\n+\n+/* Create all of the attributes that describe automaton properties.  */\n+static void\n+make_automaton_attrs (void)\n+{\n+  int i;\n+  struct insn_reserv *decl;\n+  rtx code_exp, lats_exp, byps_exp;\n+\n+  if (n_insn_reservs == 0)\n+    return;\n+\n+  code_exp = rtx_alloc (COND);\n+  lats_exp = rtx_alloc (COND);\n+  \n+  XVEC (code_exp, 0) = rtvec_alloc (n_insn_reservs * 2);\n+  XVEC (lats_exp, 0) = rtvec_alloc (n_insn_reservs * 2);\n+\n+  XEXP (code_exp, 1) = make_numeric_value (n_insn_reservs + 1);\n+  XEXP (lats_exp, 1) = make_numeric_value (0);\n+\n+  for (decl = all_insn_reservs, i = 0;\n+       decl;\n+       decl = decl->next, i += 2)\n+    {\n+      XVECEXP (code_exp, 0, i)   = decl->condexp;\n+      XVECEXP (lats_exp, 0, i)   = decl->condexp;\n+      \n+      XVECEXP (code_exp, 0, i+1) = make_numeric_value (decl->insn_num);\n+      XVECEXP (lats_exp, 0, i+1) = make_numeric_value (decl->default_latency);\n+    }\n+\n+  if (n_bypasses == 0)\n+    byps_exp = make_numeric_value (0);\n+  else\n+    {\n+      process_bypasses ();\n+\n+      byps_exp = rtx_alloc (COND);\n+      XVEC (byps_exp, 0) = rtvec_alloc (n_bypasses * 2);\n+      XEXP (byps_exp, 1) = make_numeric_value (0);\n+      for (decl = all_insn_reservs, i = 0;\n+\t   decl;\n+\t   decl = decl->next)\n+\tif (decl->bypassed)\n+\t  {\n+\t    XVECEXP (byps_exp, 0, i)   = decl->condexp;\n+\t    XVECEXP (byps_exp, 0, i+1) = make_numeric_value (1);\n+\t    i += 2;\n+\t  }\n+    }\n+\n+  make_internal_attr (\"*internal_dfa_insn_code\", code_exp, ATTR_NONE);\n+  make_internal_attr (\"*insn_default_latency\",   lats_exp, ATTR_NONE);\n+  make_internal_attr (\"*bypass_p\",               byps_exp, ATTR_NONE);\n+}\n \n int\n main (int argc, char **argv)\n@@ -4425,7 +4520,6 @@ from the machine description file `md'.  */\\n\\n\");\n \n   /* Read the machine description.  */\n \n-  initiate_automaton_gen (argc, argv);\n   while (1)\n     {\n       int lineno;\n@@ -4450,54 +4544,14 @@ from the machine description file `md'.  */\\n\\n\");\n \t  gen_delay (desc, lineno);\n \t  break;\n \n-\tcase DEFINE_CPU_UNIT:\n-\t  gen_cpu_unit (desc);\n-\t  break;\n-\n-\tcase DEFINE_QUERY_CPU_UNIT:\n-\t  gen_query_cpu_unit (desc);\n+\tcase DEFINE_INSN_RESERVATION:\n+\t  gen_insn_reserv (desc);\n \t  break;\n \n \tcase DEFINE_BYPASS:\n \t  gen_bypass (desc);\n \t  break;\n \n-\tcase EXCLUSION_SET:\n-\t  gen_excl_set (desc);\n-\t  break;\n-\n-\tcase PRESENCE_SET:\n-\t  gen_presence_set (desc);\n-\t  break;\n-\n-\tcase FINAL_PRESENCE_SET:\n-\t  gen_final_presence_set (desc);\n-\t  break;\n-\n-\tcase ABSENCE_SET:\n-\t  gen_absence_set (desc);\n-\t  break;\n-\n-\tcase FINAL_ABSENCE_SET:\n-\t  gen_final_absence_set (desc);\n-\t  break;\n-\n-\tcase DEFINE_AUTOMATON:\n-\t  gen_automaton (desc);\n-\t  break;\n-\n-\tcase AUTOMATA_OPTION:\n-\t  gen_automata_option (desc);\n-\t  break;\n-\n-\tcase DEFINE_RESERVATION:\n-\t  gen_reserv (desc);\n-\t  break;\n-\n-\tcase DEFINE_INSN_RESERVATION:\n-\t  gen_insn_reserv (desc);\n-\t  break;\n-\n \tdefault:\n \t  break;\n \t}\n@@ -4522,11 +4576,6 @@ from the machine description file `md'.  */\\n\\n\");\n   if (num_delays)\n     expand_delays ();\n \n-  /* Build DFA, output some functions and expand DFA information\n-     to new attributes.  */\n-  if (num_dfa_decls)\n-    expand_automata ();\n-\n   printf (\"#include \\\"config.h\\\"\\n\");\n   printf (\"#include \\\"system.h\\\"\\n\");\n   printf (\"#include \\\"coretypes.h\\\"\\n\");\n@@ -4557,6 +4606,9 @@ from the machine description file `md'.  */\\n\\n\");\n     if (id->insn_code >= 0)\n       insn_n_alternatives[id->insn_code] = id->num_alternatives;\n \n+  /* Construct extra attributes for automata.  */\n+  make_automaton_attrs ();\n+\n   /* Prepare to write out attribute subroutines by checking everything stored\n      away and building the attribute cases.  */\n \n@@ -4587,18 +4639,7 @@ from the machine description file `md'.  */\\n\\n\");\n     for (attr = attrs[i]; attr; attr = attr->next)\n       {\n \tif (! attr->is_special && ! attr->is_const)\n-\t  {\n-\t    int insn_alts_p;\n-\n-\t    insn_alts_p\n-\t      = (attr->name [0] == '*'\n-\t\t && strcmp (&attr->name[1], INSN_ALTS_FUNC_NAME) == 0);\n-\t    if (insn_alts_p)\n-\t      printf (\"\\n#if AUTOMATON_ALTS\\n\");\n-\t    write_attr_get (attr);\n-\t    if (insn_alts_p)\n-\t      printf (\"#endif\\n\\n\");\n-\t  }\n+\t  write_attr_get (attr);\n       }\n \n   /* Write out delay eligibility information, if DEFINE_DELAY present.\n@@ -4613,11 +4654,6 @@ from the machine description file `md'.  */\\n\\n\");\n \twrite_eligible_delay (\"annul_false\");\n     }\n \n-  /* Output code for pipeline hazards recognition based on DFA\n-     (deterministic finite-state automata).  */\n-  if (num_dfa_decls)\n-    write_automata ();\n-\n   /* Write out constant delay slot info.  */\n   write_const_num_delay_slots ();\n "}, {"sha": "72f6277214cc271aa2383a9024142083d5bf86af", "filename": "gcc/genattrtab.h", "status": "removed", "additions": 0, "deletions": 54, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f2f0edd8e6bdc48ee5f2383a87e91c301cf286a/gcc%2Fgenattrtab.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f2f0edd8e6bdc48ee5f2383a87e91c301cf286a/gcc%2Fgenattrtab.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenattrtab.h?ref=5f2f0edd8e6bdc48ee5f2383a87e91c301cf286a", "patch": "@@ -1,54 +0,0 @@\n-/* External definitions of source files of genattrtab.\n-   Copyright (C)  2001, 2003, 2005 Free Software Foundation, Inc.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 51 Franklin Street, Fifth Floor,\n-Boston, MA 02110-1301, USA.  */\n-\n-/* Name of function (attribute) to translate insn into number of insn\n-   alternatives reservation.  */\n-#define INSN_ALTS_FUNC_NAME \"insn_alts\"\n-\n-/* Defined in genattrtab.c: */\n-extern rtx check_attr_test (rtx, int, int);\n-extern rtx make_numeric_value (int);\n-extern void make_internal_attr (const char *, rtx, int);\n-extern char *attr_printf (unsigned int, const char *, ...)\n-  ATTRIBUTE_PRINTF_2;\n-\n-extern int num_dfa_decls;\n-\n-/* Defined in genautomata.c: */\n-extern void gen_cpu_unit (rtx);\n-extern void gen_query_cpu_unit (rtx);\n-extern void gen_bypass (rtx);\n-extern void gen_excl_set (rtx);\n-extern void gen_presence_set (rtx);\n-extern void gen_final_presence_set (rtx);\n-extern void gen_absence_set (rtx);\n-extern void gen_final_absence_set (rtx);\n-extern void gen_automaton (rtx);\n-extern void gen_automata_option (rtx);\n-extern void gen_reserv (rtx);\n-extern void gen_insn_reserv (rtx);\n-extern void initiate_automaton_gen (int, char **);\n-extern void expand_automata (void);\n-extern void write_automata (void);\n-\n-/* Flags for make_internal_attr's `special' parameter.  */\n-#define ATTR_NONE\t\t0\n-#define ATTR_SPECIAL\t\t(1 << 0)\n-#define ATTR_STATIC\t\t(1 << 1)"}, {"sha": "75cb8c7e870dae234941c8dde7c0299b4dcc96df", "filename": "gcc/genautomata.c", "status": "modified", "additions": 146, "deletions": 798, "changes": 944, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c94f366afaac439750606fe3cb7b52207afa6e4/gcc%2Fgenautomata.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c94f366afaac439750606fe3cb7b52207afa6e4/gcc%2Fgenautomata.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenautomata.c?ref=8c94f366afaac439750606fe3cb7b52207afa6e4", "patch": "@@ -109,18 +109,16 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"rtl.h\"\n #include \"obstack.h\"\n #include \"errors.h\"\n+#include \"gensupport.h\"\n \n #include <math.h>\n #include \"hashtab.h\"\n-#include \"varray.h\"\n #include \"vec.h\"\n \n #ifndef CHAR_BIT\n #define CHAR_BIT 8\n #endif\n \n-#include \"genattrtab.h\"\n-\n /* Positions in machine description file.  Now they are not used.  But\n    they could be used in the future for better diagnostic messages.  */\n typedef int pos_t;\n@@ -197,316 +195,6 @@ typedef struct automaton *automaton_t;\n typedef struct automata_list_el *automata_list_el_t;\n typedef struct state_ainsn_table *state_ainsn_table_t;\n \n-\n-/* Prototypes of functions gen_cpu_unit, gen_query_cpu_unit,\n-   gen_bypass, gen_excl_set, gen_presence_set, gen_final_presence_set,\n-   gen_absence_set, gen_final_absence_set, gen_automaton,\n-   gen_automata_option, gen_reserv, gen_insn_reserv,\n-   initiate_automaton_gen, expand_automata, write_automata are\n-   described on the file top because the functions are called from\n-   function `main'.  */\n-\n-static void *create_node             (size_t);\n-static void *copy_node               (const void *, size_t);\n-static const char *check_name        (const char *, pos_t);\n-static char *next_sep_el             (const char **, int, int);\n-static int n_sep_els                 (const char *, int, int);\n-static char **get_str_vect           (const char *, int *, int, int);\n-static void gen_presence_absence_set (rtx, int, int);\n-static regexp_t gen_regexp_el        (const char *);\n-static regexp_t gen_regexp_repeat    (const char *);\n-static regexp_t gen_regexp_allof     (const char *);\n-static regexp_t gen_regexp_oneof     (const char *);\n-static regexp_t gen_regexp_sequence  (const char *);\n-static regexp_t gen_regexp           (const char *);\n-\n-static unsigned string_hash          (const char *);\n-static unsigned automaton_decl_hash  (const void *);\n-static int automaton_decl_eq_p       (const void *,\n-\t\t\t\t      const void *);\n-static decl_t insert_automaton_decl       (decl_t);\n-static decl_t find_automaton_decl         (const char *);\n-static void initiate_automaton_decl_table (void);\n-static void finish_automaton_decl_table   (void);\n-\n-static hashval_t insn_decl_hash           (const void *);\n-static int insn_decl_eq_p                 (const void *,\n-\t\t\t\t\t   const void *);\n-static decl_t insert_insn_decl            (decl_t);\n-static decl_t find_insn_decl              (const char *);\n-static void initiate_insn_decl_table      (void);\n-static void finish_insn_decl_table        (void);\n-\n-static hashval_t decl_hash                (const void *);\n-static int decl_eq_p                      (const void *,\n-\t\t\t\t\t   const void *);\n-static decl_t insert_decl                 (decl_t);\n-static decl_t find_decl                   (const char *);\n-static void initiate_decl_table           (void);\n-static void finish_decl_table             (void);\n-\n-static unit_set_el_t process_excls       (char **, int, pos_t);\n-static void add_excls                    (unit_set_el_t, unit_set_el_t,\n-\t\t\t\t\t  pos_t);\n-static unit_set_el_t process_presence_absence_names\n-\t\t\t\t\t (char **, int, pos_t,\n-\t\t\t\t\t  int, int);\n-static pattern_set_el_t process_presence_absence_patterns\n-\t\t\t\t\t (char ***, int, pos_t,\n-\t\t\t\t\t  int, int);\n-static void add_presence_absence\t (unit_set_el_t,\n-\t\t\t\t\t  pattern_set_el_t,\n-\t\t\t\t\t  pos_t, int, int);\n-static void process_decls                (void);\n-static struct bypass_decl *find_bypass   (struct bypass_decl *,\n-\t\t\t\t\t  struct insn_reserv_decl *);\n-static void check_automaton_usage        (void);\n-static regexp_t process_regexp           (regexp_t);\n-static void process_regexp_decls         (void);\n-static void check_usage                  (void);\n-static int loop_in_regexp                (regexp_t, decl_t);\n-static void check_loops_in_regexps       (void);\n-static void process_regexp_cycles        (regexp_t, int, int,\n-\t\t\t\t\t  int *, int *);\n-static void evaluate_max_reserv_cycles   (void);\n-static void check_all_description        (void);\n-\n-static ticker_t create_ticker               (void);\n-static void ticker_off                      (ticker_t *);\n-static void ticker_on                       (ticker_t *);\n-static int active_time                      (ticker_t);\n-static void print_active_time               (FILE *, ticker_t);\n-\n-static void add_advance_cycle_insn_decl     (void);\n-\n-static alt_state_t get_free_alt_state (void);\n-static void free_alt_state              (alt_state_t);\n-static void free_alt_states             (alt_state_t);\n-static int alt_state_cmp                (const void *alt_state_ptr_1,\n-\t\t\t\t\t const void *alt_state_ptr_2);\n-static alt_state_t uniq_sort_alt_states (alt_state_t);\n-static int alt_states_eq                (alt_state_t, alt_state_t);\n-static void initiate_alt_states         (void);\n-static void finish_alt_states           (void);\n-\n-static reserv_sets_t alloc_empty_reserv_sets (void);\n-static unsigned reserv_sets_hash_value (reserv_sets_t);\n-static int reserv_sets_cmp             (reserv_sets_t, reserv_sets_t);\n-static int reserv_sets_eq              (reserv_sets_t, reserv_sets_t);\n-static void set_unit_reserv            (reserv_sets_t, int, int);\n-static int test_unit_reserv            (reserv_sets_t, int, int);\n-static int it_is_empty_reserv_sets     (reserv_sets_t)\n-                                            ATTRIBUTE_UNUSED;\n-static int reserv_sets_are_intersected (reserv_sets_t, reserv_sets_t);\n-static void reserv_sets_shift          (reserv_sets_t, reserv_sets_t);\n-static void reserv_sets_or             (reserv_sets_t, reserv_sets_t,\n-\t\t\t\t\treserv_sets_t);\n-static void reserv_sets_and            (reserv_sets_t, reserv_sets_t,\n-\t\t\t\t\treserv_sets_t)\n-                                            ATTRIBUTE_UNUSED;\n-static void output_cycle_reservs       (FILE *, reserv_sets_t,\n-\t\t\t\t\tint, int);\n-static void output_reserv_sets         (FILE *, reserv_sets_t);\n-static state_t get_free_state          (int, automaton_t);\n-static void free_state                 (state_t);\n-static hashval_t state_hash            (const void *);\n-static int state_eq_p                  (const void *, const void *);\n-static state_t insert_state            (state_t);\n-static void set_state_reserv           (state_t, int, int);\n-static int intersected_state_reservs_p (state_t, state_t);\n-static state_t states_union            (state_t, state_t, reserv_sets_t);\n-static state_t state_shift             (state_t, reserv_sets_t);\n-static void initiate_states            (void);\n-static void finish_states              (void);\n-\n-static void free_arc           (arc_t);\n-static void remove_arc         (state_t, arc_t);\n-static arc_t find_arc          (state_t, state_t, ainsn_t);\n-static arc_t add_arc           (state_t, state_t, ainsn_t, int);\n-static arc_t first_out_arc     (state_t);\n-static arc_t next_out_arc      (arc_t);\n-static void initiate_arcs      (void);\n-static void finish_arcs        (void);\n-\n-static automata_list_el_t get_free_automata_list_el (void);\n-static void free_automata_list_el (automata_list_el_t);\n-static void free_automata_list (automata_list_el_t);\n-static hashval_t automata_list_hash (const void *);\n-static int automata_list_eq_p (const void *, const void *);\n-static void initiate_automata_lists (void);\n-static void automata_list_start (void);\n-static void automata_list_add (automaton_t);\n-static automata_list_el_t automata_list_finish (void);\n-static void finish_automata_lists (void);\n-\n-static void initiate_excl_sets             (void);\n-static reserv_sets_t get_excl_set          (reserv_sets_t);\n-\n-static pattern_reserv_t form_reserv_sets_list (pattern_set_el_t);\n-static void initiate_presence_absence_pattern_sets     (void);\n-static int check_presence_pattern_sets     (reserv_sets_t,\n-\t\t\t\t\t    reserv_sets_t, int);\n-static int check_absence_pattern_sets  (reserv_sets_t, reserv_sets_t,\n-\t\t\t\t\tint);\n-\n-static regexp_t copy_insn_regexp     (regexp_t);\n-static regexp_t transform_1          (regexp_t);\n-static regexp_t transform_2          (regexp_t);\n-static regexp_t transform_3          (regexp_t);\n-static regexp_t regexp_transform_func\n-                       (regexp_t, regexp_t (*) (regexp_t));\n-static regexp_t transform_regexp            (regexp_t);\n-static void transform_insn_regexps          (void);\n-\n-static void store_alt_unit_usage (regexp_t, regexp_t, int, int);\n-static void check_regexp_units_distribution   (const char *, regexp_t);\n-static void check_unit_distributions_to_automata (void);\n-\n-static int process_seq_for_forming_states   (regexp_t, automaton_t,\n-\t\t\t\t\t     int);\n-static void finish_forming_alt_state        (alt_state_t,\n-\t\t\t\t\t     automaton_t);\n-static void process_alts_for_forming_states (regexp_t,\n-\t\t\t\t\t     automaton_t, int);\n-static void create_alt_states               (automaton_t);\n-\n-static void form_ainsn_with_same_reservs    (automaton_t);\n-\n-static reserv_sets_t form_reservs_matter (automaton_t);\n-static void make_automaton           (automaton_t);\n-static void form_arcs_marked_by_insn (state_t);\n-static void NDFA_to_DFA              (automaton_t);\n-static void pass_state_graph         (state_t, void (*) (state_t));\n-static void pass_states              (automaton_t,\n-\t\t\t\t      void (*) (state_t));\n-static void initiate_pass_states       (void);\n-static void add_achieved_state         (state_t);\n-static int set_out_arc_insns_equiv_num (state_t, int);\n-static void clear_arc_insns_equiv_num  (state_t);\n-static int first_cycle_unit_presence   (state_t, int);\n-static int state_is_differed           (state_t, state_t, int, int);\n-static void set_new_cycle_flags        (state_t);\n-static void minimize_DFA               (automaton_t);\n-static void incr_states_and_arcs_nums  (state_t);\n-static void count_states_and_arcs      (automaton_t, int *, int *);\n-static void build_automaton            (automaton_t);\n-\n-static void set_order_state_num              (state_t);\n-static void enumerate_states                 (automaton_t);\n-\n-static ainsn_t insert_ainsn_into_equiv_class       (ainsn_t, ainsn_t);\n-static void delete_ainsn_from_equiv_class          (ainsn_t);\n-static void process_insn_equiv_class               (ainsn_t, arc_t *);\n-static void process_state_for_insn_equiv_partition (state_t);\n-static void set_insn_equiv_classes                 (automaton_t);\n-\n-static double estimate_one_automaton_bound     (void);\n-static int compare_max_occ_cycle_nums          (const void *,\n-\t\t\t\t\t\tconst void *);\n-static void units_to_automata_heuristic_distr  (void);\n-static ainsn_t create_ainsns                   (void);\n-static void units_to_automata_distr            (void);\n-static void create_automata                    (void);\n-\n-static void form_regexp                      (regexp_t);\n-static const char *regexp_representation     (regexp_t);\n-static void finish_regexp_representation     (void);\n-\n-static void output_range_type            (FILE *, long int, long int);\n-static int longest_path_length           (state_t);\n-static void output_chip_member_name      (FILE *, automaton_t);\n-static void output_temp_chip_member_name (FILE *, automaton_t);\n-static void output_translate_vect_name   (FILE *, automaton_t);\n-static void output_trans_full_vect_name  (FILE *, automaton_t);\n-static void output_trans_comb_vect_name  (FILE *, automaton_t);\n-static void output_trans_check_vect_name (FILE *, automaton_t);\n-static void output_trans_base_vect_name  (FILE *, automaton_t);\n-static void output_state_alts_full_vect_name    (FILE *, automaton_t);\n-static void output_state_alts_comb_vect_name    (FILE *, automaton_t);\n-static void output_state_alts_check_vect_name   (FILE *, automaton_t);\n-static void output_state_alts_base_vect_name    (FILE *, automaton_t);\n-static void output_min_issue_delay_vect_name    (FILE *, automaton_t);\n-static void output_dead_lock_vect_name   (FILE *, automaton_t);\n-static void output_reserved_units_table_name    (FILE *, automaton_t);\n-static void output_state_member_type     (FILE *, automaton_t);\n-static void output_chip_definitions      (void);\n-static void output_translate_vect        (automaton_t);\n-static int comb_vect_p                   (state_ainsn_table_t);\n-static state_ainsn_table_t create_state_ainsn_table (automaton_t);\n-static void output_state_ainsn_table\n-   (state_ainsn_table_t, const char *, void (*) (FILE *, automaton_t),\n-    void (*) (FILE *, automaton_t), void (*) (FILE *, automaton_t),\n-    void (*) (FILE *, automaton_t));\n-static int out_state_arcs_num            (state_t);\n-static int compare_transition_els_num    (const void *, const void *);\n-static void add_states_vect_el           (state_t);\n-static void output_trans_table           (automaton_t);\n-static void output_state_alts_table      (automaton_t);\n-static int min_issue_delay_pass_states   (state_t, ainsn_t);\n-static int min_issue_delay               (state_t, ainsn_t);\n-static void initiate_min_issue_delay_pass_states (void);\n-static void output_min_issue_delay_table (automaton_t);\n-static void output_dead_lock_vect        (automaton_t);\n-static void output_reserved_units_table  (automaton_t);\n-static void output_tables                (void);\n-static void output_max_insn_queue_index_def (void);\n-static void output_insn_code_cases   (void (*) (automata_list_el_t));\n-static void output_automata_list_min_issue_delay_code (automata_list_el_t);\n-static void output_internal_min_issue_delay_func (void);\n-static void output_automata_list_transition_code (automata_list_el_t);\n-static void output_internal_trans_func   (void);\n-static void output_internal_insn_code_evaluation (const char *,\n-\t\t\t\t\t\t  const char *, int);\n-static void output_dfa_insn_code_func\t        (void);\n-static void output_trans_func                   (void);\n-static void output_automata_list_state_alts_code (automata_list_el_t);\n-static void output_internal_state_alts_func     (void);\n-static void output_state_alts_func              (void);\n-static void output_min_issue_delay_func         (void);\n-static void output_internal_dead_lock_func      (void);\n-static void output_dead_lock_func               (void);\n-static void output_internal_reset_func          (void);\n-static void output_size_func\t\t        (void);\n-static void output_reset_func                   (void);\n-static void output_min_insn_conflict_delay_func (void);\n-static void output_internal_insn_latency_func   (void);\n-static void output_insn_latency_func            (void);\n-static void output_print_reservation_func       (void);\n-static int units_cmp\t\t\t        (const void *,\n-\t\t\t\t\t\t const void *);\n-static void output_get_cpu_unit_code_func       (void);\n-static void output_cpu_unit_reservation_p       (void);\n-static void output_dfa_clean_insn_cache_func    (void);\n-static void output_dfa_start_func\t        (void);\n-static void output_dfa_finish_func\t        (void);\n-\n-static void output_regexp                  (regexp_t );\n-static void output_unit_set_el_list\t   (unit_set_el_t);\n-static void output_pattern_set_el_list\t   (pattern_set_el_t);\n-static void output_description             (void);\n-static void output_automaton_name          (FILE *, automaton_t);\n-static void output_automaton_units         (automaton_t);\n-static void add_state_reservs              (state_t);\n-static void output_state_arcs              (state_t);\n-static int state_reservs_cmp               (const void *,\n-\t\t\t\t\t    const void *);\n-static void remove_state_duplicate_reservs (void);\n-static void output_state                   (state_t);\n-static void output_automaton_descriptions  (void);\n-static void output_statistics              (FILE *);\n-static void output_time_statistics         (FILE *);\n-static void generate                       (void);\n-\n-static void make_insn_alts_attr                (void);\n-static void make_internal_dfa_insn_code_attr   (void);\n-static void make_default_insn_latency_attr     (void);\n-static void make_bypass_attr                   (void);\n-static const char *file_name_suffix            (const char *);\n-static const char *base_file_name              (const char *);\n-static void check_automata_insn_issues\t       (void);\n-static void add_automaton_state                (state_t);\n-static void form_important_insn_automata_lists (void);\n-\n /* Undefined position.  */\n static pos_t no_pos = 0;\n \n@@ -530,6 +218,19 @@ DEF_VEC_ALLOC_P(reserv_sets_t,heap);\n DEF_VEC_I(vect_el_t);\n DEF_VEC_ALLOC_I(vect_el_t, heap);\n typedef VEC(vect_el_t,heap) *vla_hwint_t;\n+\f\n+/* Forward declarations of functions used before their definitions, only.  */\n+static regexp_t gen_regexp_sequence    (const char *);\n+static void reserv_sets_or             (reserv_sets_t, reserv_sets_t,\n+\t\t\t\t        reserv_sets_t);\n+static reserv_sets_t get_excl_set      (reserv_sets_t);\n+static int check_presence_pattern_sets (reserv_sets_t,\n+\t\t\t\t\treserv_sets_t, int);\n+static int check_absence_pattern_sets  (reserv_sets_t, reserv_sets_t,\n+\t\t\t\t\tint);\n+static arc_t first_out_arc             (state_t);\n+static arc_t next_out_arc              (arc_t);\n+\n \f\n \n /* Options with the following names can be set up in automata_option\n@@ -780,10 +481,6 @@ struct insn_reserv_decl\n      which arc marked by given insn enters from a state (fixed during\n      an automaton minimization).  */\n   int equiv_class_num;\n-  /* The field value is state_alts of arc leaving a state (fixed\n-     during an automaton minimization) and marked by given insn\n-     enters.  */\n-  int state_alts;\n   /* The following member value is the list to automata which can be\n      changed by the insn issue.  */\n   automata_list_el_t important_automata_list;\n@@ -1041,10 +738,6 @@ struct arc\n   /* List of arcs marked given insn is formed with the following\n      field.  The field is used in transformation NDFA -> DFA.  */\n   arc_t next_arc_marked_by_insn;\n-  /* The following field is defined if NDFA_FLAG is zero.  The member\n-     value is number of alternative reservations which can be used for\n-     transition for given state by given insn.  */\n-  int state_alts;\n };\n \n /* The following node type describes a deterministic alternative in\n@@ -1142,10 +835,9 @@ struct automaton\n   /* The following field value is defined only if minimization of DFA\n      is used.  */\n   int minimal_DFA_arcs_num;\n-  /* The following two members refer for two table state x ainsn ->\n-     int.  */\n+  /* The following member refers for two table state x ainsn -> int.\n+     ??? Above sentence is incomprehensible.  */\n   state_ainsn_table_t trans_table;\n-  state_ainsn_table_t state_alts_table;\n   /* The following member value is maximal value of min issue delay\n      for insns of the automaton.  */\n   int max_min_delay;\n@@ -1541,7 +1233,7 @@ get_str_vect (const char *str, int *els_num, int sep, int paren_p)\n \n    This gives information about a unit contained in CPU.  We fill a\n    struct unit_decl with information used later by `expand_automata'.  */\n-void\n+static void\n gen_cpu_unit (rtx def)\n {\n   decl_t decl;\n@@ -1563,15 +1255,14 @@ gen_cpu_unit (rtx def)\n       DECL_UNIT (decl)->min_occ_cycle_num = -1;\n       DECL_UNIT (decl)->in_set_p = 0;\n       VEC_safe_push (decl_t,heap, decls, decl);\n-      num_dfa_decls++;\n     }\n }\n \n /* Process a DEFINE_QUERY_CPU_UNIT.\n \n    This gives information about a unit contained in CPU.  We fill a\n    struct unit_decl with information used later by `expand_automata'.  */\n-void\n+static void\n gen_query_cpu_unit (rtx def)\n {\n   decl_t decl;\n@@ -1592,7 +1283,6 @@ gen_query_cpu_unit (rtx def)\n       DECL_UNIT (decl)->automaton_name = XSTR (def, 1);\n       DECL_UNIT (decl)->query_p = 1;\n       VEC_safe_push (decl_t,heap, decls, decl);\n-      num_dfa_decls++;\n     }\n }\n \n@@ -1601,7 +1291,7 @@ gen_query_cpu_unit (rtx def)\n    This gives information about a unit contained in the CPU.  We fill\n    in a struct bypass_decl with information used later by\n    `expand_automata'.  */\n-void\n+static void\n gen_bypass (rtx def)\n {\n   decl_t decl;\n@@ -1628,7 +1318,6 @@ gen_bypass (rtx def)\n \tDECL_BYPASS (decl)->in_insn_name = in_insns [j];\n \tDECL_BYPASS (decl)->bypass_guard_name = XSTR (def, 3);\n \tVEC_safe_push (decl_t,heap, decls, decl);\n-\tnum_dfa_decls++;\n       }\n }\n \n@@ -1637,7 +1326,7 @@ gen_bypass (rtx def)\n    This gives information about a cpu unit conflicts.  We fill a\n    struct excl_rel_decl (excl) with information used later by\n    `expand_automata'.  */\n-void\n+static void\n gen_excl_set (rtx def)\n {\n   decl_t decl;\n@@ -1668,7 +1357,6 @@ gen_excl_set (rtx def)\n       DECL_EXCL (decl)->names [i]\n \t= second_str_cpu_units [i - first_vect_length];\n   VEC_safe_push (decl_t,heap, decls, decl);\n-  num_dfa_decls++;\n }\n \n /* Process a PRESENCE_SET, a FINAL_PRESENCE_SET, an ABSENCE_SET,\n@@ -1738,15 +1426,14 @@ gen_presence_absence_set (rtx def, int presence_p, int final_p)\n       DECL_ABSENCE (decl)->final_p = final_p;\n     }\n   VEC_safe_push (decl_t,heap, decls, decl);\n-  num_dfa_decls++;\n }\n \n /* Process a PRESENCE_SET.\n \n     This gives information about a cpu unit reservation requirements.\n    We fill a struct unit_pattern_rel_decl (presence) with information\n    used later by `expand_automata'.  */\n-void\n+static void\n gen_presence_set (rtx def)\n {\n   gen_presence_absence_set (def, TRUE, FALSE);\n@@ -1757,7 +1444,7 @@ gen_presence_set (rtx def)\n    This gives information about a cpu unit reservation requirements.\n    We fill a struct unit_pattern_rel_decl (presence) with information\n    used later by `expand_automata'.  */\n-void\n+static void\n gen_final_presence_set (rtx def)\n {\n   gen_presence_absence_set (def, TRUE, TRUE);\n@@ -1768,7 +1455,7 @@ gen_final_presence_set (rtx def)\n    This gives information about a cpu unit reservation requirements.\n    We fill a struct unit_pattern_rel_decl (absence) with information\n    used later by `expand_automata'.  */\n-void\n+static void\n gen_absence_set (rtx def)\n {\n   gen_presence_absence_set (def, FALSE, FALSE);\n@@ -1779,7 +1466,7 @@ gen_absence_set (rtx def)\n    This gives information about a cpu unit reservation requirements.\n    We fill a struct unit_pattern_rel_decl (absence) with information\n    used later by `expand_automata'.  */\n-void\n+static void\n gen_final_absence_set (rtx def)\n {\n   gen_presence_absence_set (def, FALSE, TRUE);\n@@ -1790,7 +1477,7 @@ gen_final_absence_set (rtx def)\n    This gives information about a finite state automaton used for\n    recognizing pipeline hazards.  We fill a struct automaton_decl\n    with information used later by `expand_automata'.  */\n-void\n+static void\n gen_automaton (rtx def)\n {\n   decl_t decl;\n@@ -1808,15 +1495,14 @@ gen_automaton (rtx def)\n       decl->pos = 0;\n       DECL_AUTOMATON (decl)->name = check_name (str_automata [i], decl->pos);\n       VEC_safe_push (decl_t,heap, decls, decl);\n-      num_dfa_decls++;\n     }\n }\n \n /* Process an AUTOMATA_OPTION.\n \n    This gives information how to generate finite state automaton used\n    for recognizing pipeline hazards.  */\n-void\n+static void\n gen_automata_option (rtx def)\n {\n   if (strcmp (XSTR (def, 0), NO_MINIMIZATION_OPTION + 1) == 0)\n@@ -1997,7 +1683,7 @@ gen_regexp (const char *str)\n    This gives information about a reservation of cpu units.  We fill\n    in a struct reserv_decl with information used later by\n    `expand_automata'.  */\n-void\n+static void\n gen_reserv (rtx def)\n {\n   decl_t decl;\n@@ -2008,15 +1694,14 @@ gen_reserv (rtx def)\n   DECL_RESERV (decl)->name = check_name (XSTR (def, 0), decl->pos);\n   DECL_RESERV (decl)->regexp = gen_regexp (XSTR (def, 1));\n   VEC_safe_push (decl_t,heap, decls, decl);\n-  num_dfa_decls++;\n }\n \n /* Process a DEFINE_INSN_RESERVATION.\n \n    This gives information about the reservation of cpu units by an\n    insn.  We fill a struct insn_reserv_decl with information used\n    later by `expand_automata'.  */\n-void\n+static void\n gen_insn_reserv (rtx def)\n {\n   decl_t decl;\n@@ -2030,7 +1715,6 @@ gen_insn_reserv (rtx def)\n   DECL_INSN_RESERV (decl)->condexp = XEXP (def, 2);\n   DECL_INSN_RESERV (decl)->regexp = gen_regexp (XSTR (def, 3));\n   VEC_safe_push (decl_t,heap, decls, decl);\n-  num_dfa_decls++;\n }\n \n \f\n@@ -2732,8 +2416,6 @@ process_decls (void)\n       decl = description->decls [i];\n       if (decl->mode == dm_insn_reserv)\n \t{\n-          DECL_INSN_RESERV (decl)->condexp\n-\t    = check_attr_test (DECL_INSN_RESERV (decl)->condexp, 0, 0);\n \t  if (DECL_INSN_RESERV (decl)->default_latency < 0)\n \t    error (\"define_insn_reservation `%s' has negative latency time\",\n \t\t   DECL_INSN_RESERV (decl)->name);\n@@ -3435,7 +3117,6 @@ add_advance_cycle_insn_decl (void)\n   description->decls [description->decls_num] = advance_cycle_insn_decl;\n   description->decls_num++;\n   description->insns_num++;\n-  num_dfa_decls++;\n }\n \n \f\n@@ -3752,23 +3433,6 @@ test_unit_reserv (reserv_sets_t reservs, int cycle_num, int unit_num)\n \t\t   * sizeof (set_el_t) * CHAR_BIT + unit_num);\n }\n \n-/* The function checks that the reservation set represents no one unit\n-   reservation.  */\n-static int\n-it_is_empty_reserv_sets (reserv_sets_t operand)\n-{\n-  set_el_t *reserv_ptr;\n-  int reservs_num;\n-\n-  gcc_assert (operand);\n-  for (reservs_num = els_in_reservs, reserv_ptr = operand;\n-       reservs_num != 0;\n-       reserv_ptr++, reservs_num--)\n-    if (*reserv_ptr != 0)\n-      return 0;\n-  return 1;\n-}\n-\n /* The function checks that the reservation sets are intersected,\n    i.e. there is a unit reservation on a cycle in both reservation\n    sets.  */\n@@ -4214,12 +3878,10 @@ find_arc (state_t from_state, state_t to_state, ainsn_t insn)\n   return NULL;\n }\n \n-/* The function adds arc from FROM_STATE to TO_STATE marked by AINSN\n-   and with given STATE_ALTS.  The function returns added arc (or\n-   already existing arc).  */\n+/* The function adds arc from FROM_STATE to TO_STATE marked by AINSN.\n+   The function returns added arc (or already existing arc).  */\n static arc_t\n-add_arc (state_t from_state, state_t to_state, ainsn_t ainsn,\n-\t int state_alts)\n+add_arc (state_t from_state, state_t to_state, ainsn_t ainsn)\n {\n   arc_t new_arc;\n \n@@ -4247,7 +3909,6 @@ add_arc (state_t from_state, state_t to_state, ainsn_t ainsn,\n   new_arc->next_out_arc = from_state->first_out_arc;\n   from_state->first_out_arc = new_arc;\n   new_arc->next_arc_marked_by_insn = NULL;\n-  new_arc->state_alts = state_alts;\n   return new_arc;\n }\n \n@@ -5702,22 +5363,17 @@ make_automaton (automaton_t automaton)\n \t\t\t    if (progress_flag && states_n % 100 == 0)\n \t\t\t      fprintf (stderr, \".\");\n                           }\n-\t\t\tadded_arc = add_arc (state, state2, ainsn, 1);\n+\t\t\tadded_arc = add_arc (state, state2, ainsn);\n \t\t\tif (!ndfa_flag)\n \t\t\t  break;\n                       }\n                   }\n \t\tif (!ndfa_flag && added_arc != NULL)\n \t\t  {\n-\t\t    added_arc->state_alts = 0;\n \t\t    for (alt_state = ainsn->alt_states;\n \t\t\t alt_state != NULL;\n \t\t\t alt_state = alt_state->next_alt_state)\n-\t\t      {\n-\t\t\tstate2 = alt_state->state;\n-\t\t\tif (!intersected_state_reservs_p (state, state2))\n-\t\t\t  added_arc->state_alts++;\n-\t\t      }\n+\t\t      state2 = alt_state->state;\n \t\t  }\n               }\n             else\n@@ -5734,7 +5390,7 @@ make_automaton (automaton_t automaton)\n \t    fprintf (stderr, \".\");\n         }\n       gcc_assert (advance_cycle_ainsn);\n-      add_arc (state, state2, advance_cycle_ainsn, 1);\n+      add_arc (state, state2, advance_cycle_ainsn);\n     }\n   VEC_free (state_t,heap, state_stack);\n }\n@@ -5842,7 +5498,7 @@ create_composed_state (state_t original_state, arc_t arcs_marked_by_insn,\n                 for (curr_arc = first_out_arc (curr_alt_state->state);\n                      curr_arc != NULL;\n                      curr_arc = next_out_arc (curr_arc))\n-\t\t  add_arc (state, curr_arc->to_state, curr_arc->insn, 1);\n+\t\t  add_arc (state, curr_arc->to_state, curr_arc->insn);\n             }\n           arcs_marked_by_insn->to_state = state;\n           for (alts_number = 0,\n@@ -5854,7 +5510,6 @@ create_composed_state (state_t original_state, arc_t arcs_marked_by_insn,\n               remove_arc (original_state, curr_arc);\n \t      alts_number++;\n             }\n-\t  arcs_marked_by_insn->state_alts = alts_number;\n         }\n     }\n   if (!state->it_was_placed_in_stack_for_DFA_forming)\n@@ -5968,16 +5623,13 @@ set_out_arc_insns_equiv_num (state_t state, int odd_iteration_flag)\n   state_out_arcs_num = 0;\n   for (arc = first_out_arc (state); arc != NULL; arc = next_out_arc (arc))\n     {\n-      gcc_assert (!arc->insn->insn_reserv_decl->equiv_class_num\n-\t\t  && !arc->insn->insn_reserv_decl->state_alts);\n+      gcc_assert (!arc->insn->insn_reserv_decl->equiv_class_num);\n       state_out_arcs_num++;\n       arc->insn->insn_reserv_decl->equiv_class_num\n \t= (odd_iteration_flag\n            ? arc->to_state->equiv_class_num_1\n \t   : arc->to_state->equiv_class_num_2);\n-      arc->insn->insn_reserv_decl->state_alts = arc->state_alts;\n-      gcc_assert (arc->insn->insn_reserv_decl->equiv_class_num\n-\t\t  && arc->insn->insn_reserv_decl->state_alts > 0);\n+      gcc_assert (arc->insn->insn_reserv_decl->equiv_class_num);\n     }\n   return state_out_arcs_num;\n }\n@@ -5990,10 +5642,7 @@ clear_arc_insns_equiv_num (state_t state)\n   arc_t arc;\n \n   for (arc = first_out_arc (state); arc != NULL; arc = next_out_arc (arc))\n-    {\n-      arc->insn->insn_reserv_decl->equiv_class_num = 0;\n-      arc->insn->insn_reserv_decl->state_alts = 0;\n-    }\n+    arc->insn->insn_reserv_decl->equiv_class_num = 0;\n }\n \n \n@@ -6037,8 +5686,7 @@ state_is_differed (state_t state, state_t another_state,\n       if ((odd_iteration_flag\n            ? arc->to_state->equiv_class_num_1\n \t   : arc->to_state->equiv_class_num_2)\n-          != arc->insn->insn_reserv_decl->equiv_class_num\n-\t  || (arc->insn->insn_reserv_decl->state_alts != arc->state_alts))\n+          != arc->insn->insn_reserv_decl->equiv_class_num)\n         return 1;\n     }\n   if (state_out_arcs_num != another_state_out_arcs_num)\n@@ -6261,7 +5909,7 @@ merge_states (automaton_t automaton, VEC(state_t,heap) *equiv_classes)\n \t       curr_arc = next_out_arc (curr_arc))\n \t    add_arc (first_class_state->equiv_class_state,\n \t\t     curr_arc->to_state->equiv_class_state,\n-\t\t     curr_arc->insn, curr_arc->state_alts);\n+\t\t     curr_arc->insn);\n \t  /* Delete output arcs from states of given class equivalence.  */\n \t  for (curr_state = first_class_state;\n \t       curr_state != NULL;\n@@ -7126,53 +6774,6 @@ output_trans_base_vect_name (FILE *f, automaton_t automaton)\n     fprintf (f, \"%s_base\", automaton->corresponding_automaton_decl->name);\n }\n \n-/* Output name for simple alternatives number representation.  */\n-static void\n-output_state_alts_full_vect_name (FILE *f, automaton_t automaton)\n-{\n-  if (automaton->corresponding_automaton_decl == NULL)\n-    fprintf (f, \"state_alts_%d\", automaton->automaton_order_num);\n-  else\n-    fprintf (f, \"%s_state_alts\",\n-             automaton->corresponding_automaton_decl->name);\n-}\n-\n-/* Output name of comb vector of the alternatives number table for given\n-   automaton.  */\n-static void\n-output_state_alts_comb_vect_name (FILE *f, automaton_t automaton)\n-{\n-  if (automaton->corresponding_automaton_decl == NULL)\n-    fprintf (f, \"state_alts_%d\", automaton->automaton_order_num);\n-  else\n-    fprintf (f, \"%s_state_alts\",\n-             automaton->corresponding_automaton_decl->name);\n-}\n-\n-/* Output name of check vector of the alternatives number table for given\n-   automaton.  */\n-static void\n-output_state_alts_check_vect_name (FILE *f, automaton_t automaton)\n-{\n-  if (automaton->corresponding_automaton_decl == NULL)\n-    fprintf (f, \"check_state_alts_%d\", automaton->automaton_order_num);\n-  else\n-    fprintf (f, \"%s_check_state_alts\",\n-\t     automaton->corresponding_automaton_decl->name);\n-}\n-\n-/* Output name of base vector of the alternatives number table for given\n-   automaton.  */\n-static void\n-output_state_alts_base_vect_name (FILE *f, automaton_t automaton)\n-{\n-  if (automaton->corresponding_automaton_decl == NULL)\n-    fprintf (f, \"base_state_alts_%d\", automaton->automaton_order_num);\n-  else\n-    fprintf (f, \"%s_base_state_alts\",\n-\t     automaton->corresponding_automaton_decl->name);\n-}\n-\n /* Output name of simple min issue delay table representation.  */\n static void\n output_min_issue_delay_vect_name (FILE *f, automaton_t automaton)\n@@ -7205,9 +6806,6 @@ output_reserved_units_table_name (FILE *f, automaton_t automaton)\n \t     automaton->corresponding_automaton_decl->name);\n }\n \n-/* Name of the PHR interface macro.  */\n-#define AUTOMATON_STATE_ALTS_MACRO_NAME \"AUTOMATON_STATE_ALTS\"\n-\n /* Name of the PHR interface macro.  */\n #define CPU_UNITS_QUERY_MACRO_NAME \"CPU_UNITS_QUERY\"\n \n@@ -7219,8 +6817,6 @@ output_reserved_units_table_name (FILE *f, automaton_t automaton)\n \n #define INTERNAL_TRANSITION_FUNC_NAME \"internal_state_transition\"\n \n-#define INTERNAL_STATE_ALTS_FUNC_NAME \"internal_state_alts\"\n-\n #define INTERNAL_RESET_FUNC_NAME \"internal_reset\"\n \n #define INTERNAL_DEAD_LOCK_FUNC_NAME \"internal_state_dead_lock_p\"\n@@ -7238,8 +6834,6 @@ output_reserved_units_table_name (FILE *f, automaton_t automaton)\n \n #define TRANSITION_FUNC_NAME \"state_transition\"\n \n-#define STATE_ALTS_FUNC_NAME \"state_alts\"\n-\n #define MIN_ISSUE_DELAY_FUNC_NAME \"min_issue_delay\"\n \n #define MIN_INSN_CONFLICT_DELAY_FUNC_NAME \"min_insn_conflict_delay\"\n@@ -7299,14 +6893,6 @@ output_reserved_units_table_name (FILE *f, automaton_t automaton)\n    code with caching.  */\n #define DFA_INSN_CODE_FUNC_NAME \"dfa_insn_code\"\n \n-/* Name of function (attribute) to translate insn into internal insn\n-   code.  */\n-#define INSN_DEFAULT_LATENCY_FUNC_NAME \"insn_default_latency\"\n-\n-/* Name of function (attribute) to translate insn into internal insn\n-   code.  */\n-#define BYPASS_P_FUNC_NAME \"bypass_p\"\n-\n /* Output C type which is used for representation of codes of states\n    of AUTOMATON.  */\n static void\n@@ -7738,54 +7324,6 @@ output_trans_table (automaton_t automaton)\n   VEC_free (vect_el_t,heap, transition_vect);\n }\n \n-/* Form and output vectors (comb, check, base or simple vect)\n-   representing alts number table of AUTOMATON.  The table is state x\n-   ainsn -> number of possible alternative reservations by the\n-   ainsn.  */\n-static void\n-output_state_alts_table (automaton_t automaton)\n-{\n-  size_t i;\n-  arc_t arc;\n-  vla_hwint_t state_alts_vect;\n-\n-  undefined_vect_el_value = 0; /* no alts when transition is not possible */\n-  automaton->state_alts_table = create_state_ainsn_table (automaton);\n-  /* Create vect of pointers to states ordered by num of transitions\n-     from the state (state with the maximum num is the first).  */\n-  output_states_vect = 0;\n-  pass_states (automaton, add_states_vect_el);\n-  qsort (VEC_address (state_t, output_states_vect),\n-\t VEC_length (state_t, output_states_vect),\n-         sizeof (state_t), compare_transition_els_num);\n-\n-  /* Create base, comb, and check vectors.  */\n-  state_alts_vect = 0;\n-\n-  for (i = 0; i < VEC_length (state_t, output_states_vect); i++)\n-    {\n-      VEC_truncate (vect_el_t, state_alts_vect, 0);\n-      for (arc = first_out_arc (VEC_index (state_t, output_states_vect, i));\n-\t   arc != NULL;\n-\t   arc = next_out_arc (arc))\n-        {\n-          gcc_assert (arc->insn);\n-          if (arc->insn->first_ainsn_with_given_equivalence_num)\n-            add_vect_el (&state_alts_vect, arc->insn, arc->state_alts);\n-        }\n-      add_vect (automaton->state_alts_table,\n-\t\tVEC_index (state_t, output_states_vect, i)->order_state_num,\n-                state_alts_vect);\n-    }\n-  output_state_ainsn_table\n-    (automaton->state_alts_table, \"state insn alternatives\",\n-     output_state_alts_full_vect_name, output_state_alts_comb_vect_name,\n-     output_state_alts_check_vect_name, output_state_alts_base_vect_name);\n-\n-  VEC_free (state_t,heap, output_states_vect);\n-  VEC_free (vect_el_t,heap, state_alts_vect);\n-}\n-\n /* The current number of passing states to find minimal issue delay\n    value for an ainsn and state.  */\n static int curr_state_pass_num;\n@@ -8022,14 +7560,17 @@ output_reserved_units_table (automaton_t automaton)\n \t    VEC_replace (vect_el_t, reserved_units_table, ri, x);\n \t  }\n     }\n+  fprintf (output_file, \"\\n#if %s\\n\", CPU_UNITS_QUERY_MACRO_NAME);\n   fprintf (output_file, \"/* Vector for reserved units of states.  */\\n\");\n   fprintf (output_file, \"static const \");\n   output_range_type (output_file, 0, 255);\n   fprintf (output_file, \" \");\n   output_reserved_units_table_name (output_file, automaton);\n   fprintf (output_file, \"[] = {\\n\");\n   output_vect (reserved_units_table);\n-  fprintf (output_file, \"};\\n\\n\");\n+  fprintf (output_file, \"};\\n\");\n+  fprintf (output_file, \"\\n#endif /* #if %s */\\n\\n\",\n+\t   CPU_UNITS_QUERY_MACRO_NAME);\n \n   VEC_free (state_t,heap, output_states_vect);\n   VEC_free (vect_el_t,heap, reserved_units_table);\n@@ -8049,16 +7590,9 @@ output_tables (void)\n     {\n       output_translate_vect (automaton);\n       output_trans_table (automaton);\n-      fprintf (output_file, \"\\n#if %s\\n\", AUTOMATON_STATE_ALTS_MACRO_NAME);\n-      output_state_alts_table (automaton);\n-      fprintf (output_file, \"\\n#endif /* #if %s */\\n\\n\",\n-\t       AUTOMATON_STATE_ALTS_MACRO_NAME);\n       output_min_issue_delay_table (automaton);\n       output_dead_lock_vect (automaton);\n-      fprintf (output_file, \"\\n#if %s\\n\\n\", CPU_UNITS_QUERY_MACRO_NAME);\n       output_reserved_units_table (automaton);\n-      fprintf (output_file, \"\\n#endif /* #if %s */\\n\\n\",\n-\t       CPU_UNITS_QUERY_MACRO_NAME);\n     }\n   fprintf (output_file, \"\\n#define %s %d\\n\\n\", ADVANCE_CYCLE_VALUE_NAME,\n            DECL_INSN_RESERV (advance_cycle_insn_decl)->insn_num);\n@@ -8409,99 +7943,6 @@ output_trans_func (void)\n \t   INTERNAL_TRANSITION_FUNC_NAME, INTERNAL_INSN_CODE_NAME, STATE_NAME);\n }\n \n-/* The function outputs a code for evaluation of alternative states\n-   number for insns which have reservations in given AUTOMATA_LIST.  */\n-static void\n-output_automata_list_state_alts_code (automata_list_el_t automata_list)\n-{\n-  automata_list_el_t el;\n-  automaton_t automaton;\n-\n-  fprintf (output_file, \"      {\\n\");\n-  for (el = automata_list; el != NULL; el = el->next_automata_list_el)\n-    if (comb_vect_p (el->automaton->state_alts_table))\n-      {\n-\tfprintf (output_file, \"        int %s;\\n\", TEMPORARY_VARIABLE_NAME);\n-\tbreak;\n-      }\n-  for (el = automata_list; el != NULL; el = el->next_automata_list_el)\n-    {\n-      automaton = el->automaton;\n-      if (comb_vect_p (automaton->state_alts_table))\n-\t{\n-\t  fprintf (output_file, \"\\n        %s = \", TEMPORARY_VARIABLE_NAME);\n-\t  output_state_alts_base_vect_name (output_file, automaton);\n-\t  fprintf (output_file, \" [%s->\", CHIP_PARAMETER_NAME);\n-\t  output_chip_member_name (output_file, automaton);\n-\t  fprintf (output_file, \"] + \");\n-\t  output_translate_vect_name (output_file, automaton);\n-\t  fprintf (output_file, \" [%s];\\n\", INTERNAL_INSN_CODE_NAME);\n-\t  fprintf (output_file, \"        if (\");\n-\t  output_state_alts_check_vect_name (output_file, automaton);\n-\t  fprintf (output_file, \" [%s] != %s->\",\n-\t\t   TEMPORARY_VARIABLE_NAME, CHIP_PARAMETER_NAME);\n-\t  output_chip_member_name (output_file, automaton);\n-\t  fprintf (output_file, \")\\n\");\n-\t  fprintf (output_file, \"          return 0;\\n\");\n-\t  fprintf (output_file, \"        else\\n\");\n-\t  fprintf (output_file,\n-\t\t   (el == automata_list\n-\t\t    ? \"          %s = \" : \"          %s += \"),\n-\t\t   RESULT_VARIABLE_NAME);\n-\t  output_state_alts_comb_vect_name (output_file, automaton);\n-\t  fprintf (output_file, \" [%s];\\n\", TEMPORARY_VARIABLE_NAME);\n-\t}\n-      else\n-\t{\n-\t  fprintf (output_file,\n-\t\t   (el == automata_list\n-\t\t    ? \"\\n        %s = \" : \"        %s += \"),\n-\t\t   RESULT_VARIABLE_NAME);\n-\t  output_state_alts_full_vect_name (output_file, automaton);\n-\t  fprintf (output_file, \" [\");\n-\t  output_translate_vect_name (output_file, automaton);\n-\t  fprintf (output_file, \" [%s] + \", INTERNAL_INSN_CODE_NAME);\n-\t  fprintf (output_file, \"%s->\", CHIP_PARAMETER_NAME);\n-\t  output_chip_member_name (output_file, automaton);\n-\t  fprintf (output_file, \" * %d];\\n\",\n-\t\t   automaton->insn_equiv_classes_num);\n-\t}\n-    }\n-  fprintf (output_file, \"        break;\\n      }\\n\\n\");\n-}\n-\n-/* Output function `internal_state_alts'.  */\n-static void\n-output_internal_state_alts_func (void)\n-{\n-  fprintf (output_file,\n-\t   \"static int\\n%s (int %s, struct %s *%s)\\n\",\n-\t   INTERNAL_STATE_ALTS_FUNC_NAME, INTERNAL_INSN_CODE_NAME,\n-\t   CHIP_NAME, CHIP_PARAMETER_NAME);\n-  fprintf (output_file, \"{\\n  int %s;\\n\", RESULT_VARIABLE_NAME);\n-  fprintf (output_file, \"\\n  switch (%s)\\n    {\\n\", INTERNAL_INSN_CODE_NAME);\n-  output_insn_code_cases (output_automata_list_state_alts_code);\n-  fprintf (output_file,\n-\t   \"\\n    default:\\n      %s = 0;\\n      break;\\n    }\\n\",\n-\t   RESULT_VARIABLE_NAME);\n-  fprintf (output_file, \"  return %s;\\n\", RESULT_VARIABLE_NAME);\n-  fprintf (output_file, \"}\\n\\n\");\n-}\n-\n-/* The function outputs PHR interface function `state_alts'.  */\n-static void\n-output_state_alts_func (void)\n-{\n-  fprintf (output_file, \"int\\n%s (%s, %s)\\n\\t%s %s;\\n\\trtx %s;\\n\",\n-\t   STATE_ALTS_FUNC_NAME, STATE_NAME, INSN_PARAMETER_NAME,\n-\t   STATE_TYPE_NAME, STATE_NAME, INSN_PARAMETER_NAME);\n-  fprintf (output_file, \"{\\n  int %s;\\n\", INTERNAL_INSN_CODE_NAME);\n-  output_internal_insn_code_evaluation (INSN_PARAMETER_NAME,\n-\t\t\t\t\tINTERNAL_INSN_CODE_NAME, 0);\n-  fprintf (output_file, \"  return %s (%s, %s);\\n}\\n\\n\",\n-\t   INTERNAL_STATE_ALTS_FUNC_NAME, INTERNAL_INSN_CODE_NAME, STATE_NAME);\n-}\n-\n /* Output function `min_issue_delay'.  */\n static void\n output_min_issue_delay_func (void)\n@@ -9168,8 +8609,8 @@ output_state_arcs (state_t state)\n           ainsn = ainsn->next_same_reservs_insn;\n         }\n       while (ainsn != NULL);\n-      fprintf (output_description_file, \"    %d (%d)\\n\",\n-\t       arc->to_state->order_state_num, arc->state_alts);\n+      fprintf (output_description_file, \"    %d \\n\",\n+\t       arc->to_state->order_state_num);\n     }\n   fprintf (output_description_file, \"\\n\");\n }\n@@ -9266,8 +8707,6 @@ output_statistics (FILE *f)\n #ifndef NDEBUG\n   int transition_comb_vect_els = 0;\n   int transition_full_vect_els = 0;\n-  int state_alts_comb_vect_els = 0;\n-  int state_alts_full_vect_els = 0;\n   int min_issue_delay_vect_els = 0;\n   int locked_states = 0;\n #endif\n@@ -9300,12 +8739,6 @@ output_statistics (FILE *f)\n \t (long) VEC_length (vect_el_t, automaton->trans_table->full_vect),\n \t (comb_vect_p (automaton->trans_table)\n \t  ? \"use comb vect\" : \"use simple vect\"));\n-      fprintf\n-        (f, \"%5ld state alts comb vector els, %5ld state alts table els: %s\\n\",\n-         (long) VEC_length (vect_el_t, automaton->state_alts_table->comb_vect),\n-         (long) VEC_length (vect_el_t, automaton->state_alts_table->full_vect),\n-         (comb_vect_p (automaton->state_alts_table)\n-          ? \"use comb vect\" : \"use simple vect\"));\n       fprintf\n         (f, \"%5ld min delay table els, compression factor %d\\n\",\n          (long) states_num * automaton->insn_equiv_classes_num,\n@@ -9314,10 +8747,6 @@ output_statistics (FILE *f)\n \t+= VEC_length (vect_el_t, automaton->trans_table->comb_vect);\n       transition_full_vect_els\n         += VEC_length (vect_el_t, automaton->trans_table->full_vect);\n-      state_alts_comb_vect_els\n-        += VEC_length (vect_el_t, automaton->state_alts_table->comb_vect);\n-      state_alts_full_vect_els\n-        += VEC_length (vect_el_t, automaton->state_alts_table->full_vect);\n       min_issue_delay_vect_els\n \t+= states_num * automaton->insn_equiv_classes_num;\n       locked_states\n@@ -9331,9 +8760,6 @@ output_statistics (FILE *f)\n \t   allocated_alt_states_num);\n   fprintf (f, \"%5d all transition comb vector els, %5d all trans table els\\n\",\n \t   transition_comb_vect_els, transition_full_vect_els);\n-  fprintf\n-    (f, \"%5d all state alts comb vector els, %5d all state alts table els\\n\",\n-     state_alts_comb_vect_els, state_alts_full_vect_els);\n   fprintf (f, \"%5d all min delay table els\\n\", min_issue_delay_vect_els);\n   fprintf (f, \"%5d all locked states\\n\", locked_states);\n #endif\n@@ -9386,160 +8812,6 @@ generate (void)\n \n \f\n \n-/* The following function creates insn attribute whose values are\n-   number alternatives in insn reservations.  */\n-static void\n-make_insn_alts_attr (void)\n-{\n-  int i, insn_num;\n-  decl_t decl;\n-  rtx condexp;\n-\n-  condexp = rtx_alloc (COND);\n-  XVEC (condexp, 0) = rtvec_alloc ((description->insns_num - 1) * 2);\n-  XEXP (condexp, 1) = make_numeric_value (0);\n-  for (i = insn_num = 0; i < description->decls_num; i++)\n-    {\n-      decl = description->decls [i];\n-      if (decl->mode == dm_insn_reserv && decl != advance_cycle_insn_decl)\n-\t{\n-          XVECEXP (condexp, 0, 2 * insn_num)\n-\t    = DECL_INSN_RESERV (decl)->condexp;\n-          XVECEXP (condexp, 0, 2 * insn_num + 1)\n-            = make_numeric_value\n-\t      (DECL_INSN_RESERV (decl)->transformed_regexp->mode != rm_oneof\n-\t       ? 1 : REGEXP_ONEOF (DECL_INSN_RESERV (decl)\n-\t\t\t\t   ->transformed_regexp)->regexps_num);\n-          insn_num++;\n-        }\n-    }\n-  gcc_assert (description->insns_num == insn_num + 1);\n-  make_internal_attr (attr_printf (sizeof (\"*\")\n-\t\t\t\t   + strlen (INSN_ALTS_FUNC_NAME) + 1,\n-\t\t\t\t   \"*%s\", INSN_ALTS_FUNC_NAME),\n-\t\t      condexp, ATTR_NONE);\n-}\n-\n-\f\n-\n-/* The following function creates attribute which is order number of\n-   insn in pipeline hazard description translator.  */\n-static void\n-make_internal_dfa_insn_code_attr (void)\n-{\n-  int i, insn_num;\n-  decl_t decl;\n-  rtx condexp;\n-\n-  condexp = rtx_alloc (COND);\n-  XVEC (condexp, 0) = rtvec_alloc ((description->insns_num - 1) * 2);\n-  XEXP (condexp, 1)\n-    = make_numeric_value (DECL_INSN_RESERV (advance_cycle_insn_decl)\n-\t\t\t  ->insn_num + 1);\n-  for (i = insn_num = 0; i < description->decls_num; i++)\n-    {\n-      decl = description->decls [i];\n-      if (decl->mode == dm_insn_reserv && decl != advance_cycle_insn_decl)\n-\t{\n-          XVECEXP (condexp, 0, 2 * insn_num)\n-\t    = DECL_INSN_RESERV (decl)->condexp;\n-          XVECEXP (condexp, 0, 2 * insn_num + 1)\n-            = make_numeric_value (DECL_INSN_RESERV (decl)->insn_num);\n-          insn_num++;\n-        }\n-    }\n-  gcc_assert (description->insns_num == insn_num + 1);\n-  make_internal_attr\n-    (attr_printf (sizeof (\"*\")\n-\t\t  + strlen (INTERNAL_DFA_INSN_CODE_FUNC_NAME) + 1,\n-\t\t  \"*%s\", INTERNAL_DFA_INSN_CODE_FUNC_NAME),\n-     condexp, ATTR_STATIC);\n-}\n-\n-\f\n-\n-/* The following function creates attribute which order number of insn\n-   in pipeline hazard description translator.  */\n-static void\n-make_default_insn_latency_attr (void)\n-{\n-  int i, insn_num;\n-  decl_t decl;\n-  rtx condexp;\n-\n-  condexp = rtx_alloc (COND);\n-  XVEC (condexp, 0) = rtvec_alloc ((description->insns_num - 1) * 2);\n-  XEXP (condexp, 1) = make_numeric_value (0);\n-  for (i = insn_num = 0; i < description->decls_num; i++)\n-    {\n-      decl = description->decls [i];\n-      if (decl->mode == dm_insn_reserv && decl != advance_cycle_insn_decl)\n-\t{\n-          XVECEXP (condexp, 0, 2 * insn_num)\n-\t    = DECL_INSN_RESERV (decl)->condexp;\n-          XVECEXP (condexp, 0, 2 * insn_num + 1)\n-            = make_numeric_value (DECL_INSN_RESERV (decl)->default_latency);\n-          insn_num++;\n-        }\n-    }\n-  gcc_assert (description->insns_num == insn_num + 1);\n-  make_internal_attr (attr_printf (sizeof (\"*\")\n-\t\t\t\t   + strlen (INSN_DEFAULT_LATENCY_FUNC_NAME)\n-\t\t\t\t   + 1, \"*%s\", INSN_DEFAULT_LATENCY_FUNC_NAME),\n-\t\t      condexp, ATTR_NONE);\n-}\n-\n-\f\n-\n-/* The following function creates attribute which returns 1 if given\n-   output insn has bypassing and 0 otherwise.  */\n-static void\n-make_bypass_attr (void)\n-{\n-  int i, bypass_insn;\n-  int bypass_insns_num = 0;\n-  decl_t decl;\n-  rtx result_rtx;\n-\n-  for (i = 0; i < description->decls_num; i++)\n-    {\n-      decl = description->decls [i];\n-      if (decl->mode == dm_insn_reserv\n-\t  && DECL_INSN_RESERV (decl)->condexp != NULL\n-\t  && DECL_INSN_RESERV (decl)->bypass_list != NULL)\n-\tbypass_insns_num++;\n-    }\n-  if (bypass_insns_num == 0)\n-    result_rtx = make_numeric_value (0);\n-  else\n-    {\n-      result_rtx = rtx_alloc (COND);\n-      XVEC (result_rtx, 0) = rtvec_alloc (bypass_insns_num * 2);\n-      XEXP (result_rtx, 1) = make_numeric_value (0);\n-\n-      for (i = bypass_insn = 0; i < description->decls_num; i++)\n-        {\n-          decl = description->decls [i];\n-          if (decl->mode == dm_insn_reserv\n-\t      && DECL_INSN_RESERV (decl)->condexp != NULL\n-\t      && DECL_INSN_RESERV (decl)->bypass_list != NULL)\n-\t    {\n-              XVECEXP (result_rtx, 0, 2 * bypass_insn)\n-\t\t= DECL_INSN_RESERV (decl)->condexp;\n-              XVECEXP (result_rtx, 0, 2 * bypass_insn + 1)\n-\t        = make_numeric_value (1);\n-              bypass_insn++;\n-            }\n-        }\n-    }\n-  make_internal_attr (attr_printf (sizeof (\"*\")\n-\t\t\t\t   + strlen (BYPASS_P_FUNC_NAME) + 1,\n-\t\t\t\t   \"*%s\", BYPASS_P_FUNC_NAME),\n-\t\t      result_rtx, ATTR_NONE);\n-}\n-\n-\f\n-\n /* This page mainly contains top level functions of pipeline hazards\n    description translator.  */\n \n@@ -9582,7 +8854,7 @@ base_file_name (const char *file_name)\n \n /* The following is top level function to initialize the work of\n    pipeline hazards description translator.  */\n-void\n+static void\n initiate_automaton_gen (int argc, char **argv)\n {\n   const char *base_name;\n@@ -9756,7 +9028,7 @@ form_important_insn_automata_lists (void)\n \n /* The following is top level function to generate automat(a,on) for\n    fast recognition of pipeline hazards.  */\n-void\n+static void\n expand_automata (void)\n {\n   int i;\n@@ -9796,31 +9068,15 @@ expand_automata (void)\n   if (!have_error)\n     {\n       form_important_insn_automata_lists ();\n-      if (progress_flag)\n-\tfprintf (stderr, \"Generation of attributes...\");\n-      make_internal_dfa_insn_code_attr ();\n-      make_insn_alts_attr ();\n-      make_default_insn_latency_attr ();\n-      make_bypass_attr ();\n-      if (progress_flag)\n-\tfprintf (stderr, \"done\\n\");\n     }\n   ticker_off (&generation_time);\n-  ticker_off (&all_time);\n-  if (progress_flag)\n-    fprintf (stderr, \"All other genattrtab stuff...\");\n }\n \n /* The following is top level function to output PHR and to finish\n    work with pipeline description translator.  */\n-void\n+static void\n write_automata (void)\n {\n-  if (progress_flag)\n-    fprintf (stderr, \"done\\n\");\n-  if (have_error)\n-    fatal (\"Errors in DFA description\");\n-  ticker_on (&all_time);\n   output_time = create_ticker ();\n   if (progress_flag)\n     fprintf (stderr, \"Forming and outputting automata tables...\");\n@@ -9840,11 +9096,6 @@ write_automata (void)\n \t   DFA_INSN_CODES_LENGTH_VARIABLE_NAME);\n   output_dfa_insn_code_func ();\n   output_trans_func ();\n-  fprintf (output_file, \"\\n#if %s\\n\\n\", AUTOMATON_STATE_ALTS_MACRO_NAME);\n-  output_internal_state_alts_func ();\n-  output_state_alts_func ();\n-  fprintf (output_file, \"\\n#endif /* #if %s */\\n\\n\",\n-\t   AUTOMATON_STATE_ALTS_MACRO_NAME);\n   output_min_issue_delay_func ();\n   output_internal_dead_lock_func ();\n   output_dead_lock_func ();\n@@ -9915,3 +9166,100 @@ write_automata (void)\n   if (have_error && output_description_file != NULL)\n     remove (output_description_file_name);\n }\n+\n+int\n+main (int argc, char **argv)\n+{\n+  rtx desc;\n+\n+  progname = \"genautomata\";\n+\n+  if (init_md_reader_args (argc, argv) != SUCCESS_EXIT_CODE)\n+    return (FATAL_EXIT_CODE);\n+\n+  initiate_automaton_gen (argc, argv);\n+  while (1)\n+    {\n+      int lineno;\n+      int insn_code_number;\n+\n+      desc = read_md_rtx (&lineno, &insn_code_number);\n+      if (desc == NULL)\n+\tbreak;\n+\n+      switch (GET_CODE (desc))\n+\t{\n+\tcase DEFINE_CPU_UNIT:\n+\t  gen_cpu_unit (desc);\n+\t  break;\n+\n+\tcase DEFINE_QUERY_CPU_UNIT:\n+\t  gen_query_cpu_unit (desc);\n+\t  break;\n+\n+\tcase DEFINE_BYPASS:\n+\t  gen_bypass (desc);\n+\t  break;\n+\n+\tcase EXCLUSION_SET:\n+\t  gen_excl_set (desc);\n+\t  break;\n+\n+\tcase PRESENCE_SET:\n+\t  gen_presence_set (desc);\n+\t  break;\n+\n+\tcase FINAL_PRESENCE_SET:\n+\t  gen_final_presence_set (desc);\n+\t  break;\n+\n+\tcase ABSENCE_SET:\n+\t  gen_absence_set (desc);\n+\t  break;\n+\n+\tcase FINAL_ABSENCE_SET:\n+\t  gen_final_absence_set (desc);\n+\t  break;\n+\n+\tcase DEFINE_AUTOMATON:\n+\t  gen_automaton (desc);\n+\t  break;\n+\n+\tcase AUTOMATA_OPTION:\n+\t  gen_automata_option (desc);\n+\t  break;\n+\n+\tcase DEFINE_RESERVATION:\n+\t  gen_reserv (desc);\n+\t  break;\n+\n+\tcase DEFINE_INSN_RESERVATION:\n+\t  gen_insn_reserv (desc);\n+\t  break;\n+\n+\tdefault:\n+\t  break;\n+\t}\n+    }\n+\n+  if (have_error)\n+    return FATAL_EXIT_CODE;\n+\n+  puts (\"/* Generated automatically by the program `genautomata'\\n\"\n+\t\"   from the machine description file `md'.  */\\n\\n\"\n+\t\"#include \\\"config.h\\\"\\n\"\n+\t\"#include \\\"system.h\\\"\\n\"\n+\t\"#include \\\"coretypes.h\\\"\\n\"\n+\t\"#include \\\"tm.h\\\"\\n\"\n+\t\"#include \\\"rtl.h\\\"\\n\"\n+\t\"#include \\\"insn-attr.h\\\"\\n\");\n+\n+  if (VEC_length (decl_t, decls) > 0)\n+    {\n+      expand_automata ();\n+      write_automata ();\n+    }\n+\n+  fflush (stdout);\n+  return (ferror (stdout) != 0 ? FATAL_EXIT_CODE : SUCCESS_EXIT_CODE);\n+}"}]}