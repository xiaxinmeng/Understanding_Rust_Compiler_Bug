{"sha": "5d723e5434e83d9de5271f6d1c24a694826450a8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWQ3MjNlNTQzNGU4M2Q5ZGU1MjcxZjZkMWMyNGE2OTQ4MjY0NTBhOA==", "commit": {"author": {"name": "Francois-Xavier Coudert", "email": "coudert@clipper.ens.fr", "date": "2005-11-13T09:33:19Z"}, "committer": {"name": "Fran\u00e7ois-Xavier Coudert", "email": "fxcoudert@gcc.gnu.org", "date": "2005-11-13T09:33:19Z"}, "message": "fget.c: New file.\n\n\t* intrinsics/fget.c: New file.\n\t* intrinsics/ftell.c: New file.\n\t* io/unix.c (stream_offset): New function.\n\t* io/io.h: Add prototype for stream_offset.\n\t* Makefile.am: Add intrinsics/fget.c and intrinsics/ftell.c.\n\t* Makefile.in: Regenerate.\n\n\t* intrinsic.c (add_functions): Add COMPLEX, FTELL, FGETC, FGET,\n\tFPUTC, FPUT, AND, XOR and OR intrinsic functions.\n\t(add_subroutines): Add FGETC, FGET, FPUTC, FPUT and FTELL intrinsic\n\tsubroutines.\n\t* gfortran.h: Add GFC_ISYM_AND, GFC_ISYM_COMPLEX, GFC_ISYM_FGET,\n\tGFC_ISYM_FGETC, GFC_ISYM_FPUT, GFC_ISYM_FPUTC, GFC_ISYM_FTELL,\n\tGFC_ISYM_OR, GFC_ISYM_XOR.\n\t* iresolve.c (gfc_resolve_and, gfc_resolve_complex,\n\tgfc_resolve_or, gfc_resolve_fgetc, gfc_resolve_fget,\n\tgfc_resolve_fputc, gfc_resolve_fput, gfc_resolve_ftell,\n\tgfc_resolve_xor, gfc_resolve_fgetc_sub, gfc_resolve_fget_sub,\n\tgfc_resolve_fputc_sub, gfc_resolve_fput_sub, gfc_resolve_ftell_sub):\n\tNew functions.\n\t* check.c (gfc_check_complex, gfc_check_fgetputc_sub,\n\tgfc_check_fgetputc, gfc_check_fgetput_sub, gfc_check_fgetput,\n\tgfc_check_ftell, gfc_check_ftell_sub, gfc_check_and): New functions.\n\t* simplify.c (gfc_simplify_and, gfc_simplify_complex, gfc_simplify_or,\n\tgfc_simplify_xor): New functions.\n\t* trans-intrinsic.c (gfc_conv_intrinsic_function): Add cases for\n\tGFC_ISYM_AND, GFC_ISYM_COMPLEX, GFC_ISYM_FGET, GFC_ISYM_FGETC,\n\tGFC_ISYM_FPUT, GFC_ISYM_FPUTC, GFC_ISYM_FTELL, GFC_ISYM_OR and\n\tGFC_ISYM_XOR.\n\t* intrinsic.h: Add prototypes for all functions added to iresolve.c,\n\tsimplify.c and check.c.\n\n\t* gfortran.dg/complex_intrinsic_1.f90: New test.\n\t* gfortran.dg/complex_intrinsic_2.f90: New test.\n\t* gfortran.dg/fgetc_1.f90: New test.\n\t* gfortran.dg/fgetc_2.f90: New test.\n\t* gfortran.dg/fgetc_3.f90: New test.\n\t* gfortran.dg/ftell_1.f90: New test.\n\t* gfortran.dg/ftell_2.f90: New test.\n\t* gfortran.dg/gnu_logical_1.F: New test.\n\t* gfortran.dg/gnu_logical_2.f90: New test.\n\nFrom-SVN: r106859", "tree": {"sha": "e0ec7b23d7872520a826e03806116b99255edffd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e0ec7b23d7872520a826e03806116b99255edffd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5d723e5434e83d9de5271f6d1c24a694826450a8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d723e5434e83d9de5271f6d1c24a694826450a8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5d723e5434e83d9de5271f6d1c24a694826450a8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d723e5434e83d9de5271f6d1c24a694826450a8/comments", "author": null, "committer": {"login": "fxcoudert", "id": 1980544, "node_id": "MDQ6VXNlcjE5ODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1980544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fxcoudert", "html_url": "https://github.com/fxcoudert", "followers_url": "https://api.github.com/users/fxcoudert/followers", "following_url": "https://api.github.com/users/fxcoudert/following{/other_user}", "gists_url": "https://api.github.com/users/fxcoudert/gists{/gist_id}", "starred_url": "https://api.github.com/users/fxcoudert/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fxcoudert/subscriptions", "organizations_url": "https://api.github.com/users/fxcoudert/orgs", "repos_url": "https://api.github.com/users/fxcoudert/repos", "events_url": "https://api.github.com/users/fxcoudert/events{/privacy}", "received_events_url": "https://api.github.com/users/fxcoudert/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a8bd670c5a5021e73a7727d585ac2bd806046295", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a8bd670c5a5021e73a7727d585ac2bd806046295", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a8bd670c5a5021e73a7727d585ac2bd806046295"}], "stats": {"total": 1273, "additions": 1260, "deletions": 13}, "files": [{"sha": "0a24084f4cc8776d2138aed33231ccc75fe021ba", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d723e5434e83d9de5271f6d1c24a694826450a8/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d723e5434e83d9de5271f6d1c24a694826450a8/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=5d723e5434e83d9de5271f6d1c24a694826450a8", "patch": "@@ -1,3 +1,30 @@\n+2005-11-13  Francois-Xavier Coudert  <coudert@clipper.ens.fr>\n+\n+\t* intrinsic.c (add_functions): Add COMPLEX, FTELL, FGETC, FGET,\n+\tFPUTC, FPUT, AND, XOR and OR intrinsic functions.\n+\t(add_subroutines): Add FGETC, FGET, FPUTC, FPUT and FTELL intrinsic\n+\tsubroutines.\n+\t* gfortran.h: Add GFC_ISYM_AND, GFC_ISYM_COMPLEX, GFC_ISYM_FGET,\n+\tGFC_ISYM_FGETC, GFC_ISYM_FPUT, GFC_ISYM_FPUTC, GFC_ISYM_FTELL,\n+\tGFC_ISYM_OR, GFC_ISYM_XOR.\n+\t* iresolve.c (gfc_resolve_and, gfc_resolve_complex,\n+\tgfc_resolve_or, gfc_resolve_fgetc, gfc_resolve_fget,\n+\tgfc_resolve_fputc, gfc_resolve_fput, gfc_resolve_ftell,\n+\tgfc_resolve_xor, gfc_resolve_fgetc_sub, gfc_resolve_fget_sub,\n+\tgfc_resolve_fputc_sub, gfc_resolve_fput_sub, gfc_resolve_ftell_sub):\n+\tNew functions.\n+\t* check.c (gfc_check_complex, gfc_check_fgetputc_sub,\n+\tgfc_check_fgetputc, gfc_check_fgetput_sub, gfc_check_fgetput,\n+\tgfc_check_ftell, gfc_check_ftell_sub, gfc_check_and): New functions.\n+\t* simplify.c (gfc_simplify_and, gfc_simplify_complex, gfc_simplify_or,\n+\tgfc_simplify_xor): New functions.\n+\t* trans-intrinsic.c (gfc_conv_intrinsic_function): Add cases for\n+\tGFC_ISYM_AND, GFC_ISYM_COMPLEX, GFC_ISYM_FGET, GFC_ISYM_FGETC,\n+\tGFC_ISYM_FPUT, GFC_ISYM_FPUTC, GFC_ISYM_FTELL, GFC_ISYM_OR and\n+\tGFC_ISYM_XOR.\n+\t* intrinsic.h: Add prototypes for all functions added to iresolve.c,\n+\tsimplify.c and check.c.\n+\n 2005-11-10  Paul Thomas  <pault@gcc.gnu.org>\n \t    Steven G. Kargl <kargls@comcast.net>\n "}, {"sha": "bc757ff86b874bb83bb5348b5f57f4240edeb53e", "filename": "gcc/fortran/check.c", "status": "modified", "additions": 156, "deletions": 0, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d723e5434e83d9de5271f6d1c24a694826450a8/gcc%2Ffortran%2Fcheck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d723e5434e83d9de5271f6d1c24a694826450a8/gcc%2Ffortran%2Fcheck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fcheck.c?ref=5d723e5434e83d9de5271f6d1c24a694826450a8", "patch": "@@ -631,6 +631,33 @@ gfc_check_cmplx (gfc_expr * x, gfc_expr * y, gfc_expr * kind)\n }\n \n \n+try\n+gfc_check_complex (gfc_expr * x, gfc_expr * y)\n+{\n+  if (x->ts.type != BT_INTEGER && x->ts.type != BT_REAL)\n+    {\n+      gfc_error (\n+\t\"'%s' argument of '%s' intrinsic at %L must be INTEGER or REAL\",\n+\tgfc_current_intrinsic_arg[0], gfc_current_intrinsic, &x->where);\n+      return FAILURE;\n+    }\n+  if (scalar_check (x, 0) == FAILURE)\n+    return FAILURE;\n+\n+  if (y->ts.type != BT_INTEGER && y->ts.type != BT_REAL)\n+    {\n+      gfc_error (\n+\t\"'%s' argument of '%s' intrinsic at %L must be INTEGER or REAL\",\n+\tgfc_current_intrinsic_arg[1], gfc_current_intrinsic, &y->where);\n+      return FAILURE;\n+    }\n+  if (scalar_check (y, 1) == FAILURE)\n+    return FAILURE;\n+\n+  return SUCCESS;\n+}\n+\n+\n try\n gfc_check_count (gfc_expr * mask, gfc_expr * dim)\n {\n@@ -2003,6 +2030,64 @@ gfc_check_spread (gfc_expr * source, gfc_expr * dim, gfc_expr * ncopies)\n }\n \n \n+/* Functions for checking FGETC, FPUTC, FGET and FPUT (subroutines and\n+   functions).  */\n+try\n+gfc_check_fgetputc_sub (gfc_expr * unit, gfc_expr * c, gfc_expr * status)\n+{\n+  if (type_check (unit, 0, BT_INTEGER) == FAILURE)\n+    return FAILURE;\n+\n+  if (scalar_check (unit, 0) == FAILURE)\n+    return FAILURE;\n+\n+  if (type_check (c, 1, BT_CHARACTER) == FAILURE)\n+    return FAILURE;\n+\n+  if (status == NULL)\n+    return SUCCESS;\n+\n+  if (type_check (status, 2, BT_INTEGER) == FAILURE\n+      || kind_value_check (status, 2, gfc_default_integer_kind) == FAILURE\n+      || scalar_check (status, 2) == FAILURE)\n+    return FAILURE;\n+\n+  return SUCCESS;\n+}\n+\n+\n+try\n+gfc_check_fgetputc (gfc_expr * unit, gfc_expr * c)\n+{\n+  return gfc_check_fgetputc_sub (unit, c, NULL);\n+}\n+\n+\n+try\n+gfc_check_fgetput_sub (gfc_expr * c, gfc_expr * status)\n+{\n+  if (type_check (c, 0, BT_CHARACTER) == FAILURE)\n+    return FAILURE;\n+\n+  if (status == NULL)\n+    return SUCCESS;\n+\n+  if (type_check (status, 1, BT_INTEGER) == FAILURE\n+      || kind_value_check (status, 1, gfc_default_integer_kind) == FAILURE\n+      || scalar_check (status, 1) == FAILURE)\n+    return FAILURE;\n+\n+  return SUCCESS;\n+}\n+\n+\n+try\n+gfc_check_fgetput (gfc_expr * c)\n+{\n+  return gfc_check_fgetput_sub (c, NULL);\n+}\n+\n+\n try\n gfc_check_fstat (gfc_expr * unit, gfc_expr * array)\n {\n@@ -2053,6 +2138,38 @@ gfc_check_fstat_sub (gfc_expr * unit, gfc_expr * array, gfc_expr * status)\n }\n \n \n+try\n+gfc_check_ftell (gfc_expr * unit)\n+{\n+  if (type_check (unit, 0, BT_INTEGER) == FAILURE)\n+    return FAILURE;\n+\n+  if (scalar_check (unit, 0) == FAILURE)\n+    return FAILURE;\n+\n+  return SUCCESS;\n+}\n+\n+\n+try\n+gfc_check_ftell_sub (gfc_expr * unit, gfc_expr * offset)\n+{\n+  if (type_check (unit, 0, BT_INTEGER) == FAILURE)\n+    return FAILURE;\n+\n+  if (scalar_check (unit, 0) == FAILURE)\n+    return FAILURE;\n+\n+  if (type_check (offset, 1, BT_INTEGER) == FAILURE)\n+    return FAILURE;\n+\n+  if (scalar_check (offset, 1) == FAILURE)\n+    return FAILURE;\n+\n+  return SUCCESS;\n+}\n+\n+\n try\n gfc_check_stat (gfc_expr * name, gfc_expr * array)\n {\n@@ -2922,3 +3039,42 @@ gfc_check_system_sub (gfc_expr * cmd, gfc_expr * status)\n \n   return SUCCESS;\n }\n+\n+\n+/* This is used for the GNU intrinsics AND, OR and XOR.  */\n+try\n+gfc_check_and (gfc_expr * i, gfc_expr * j)\n+{\n+  if (i->ts.type != BT_INTEGER && i->ts.type != BT_LOGICAL)\n+    {\n+      gfc_error (\n+\t\"'%s' argument of '%s' intrinsic at %L must be INTEGER or LOGICAL\",\n+\tgfc_current_intrinsic_arg[0], gfc_current_intrinsic, &i->where);\n+      return FAILURE;\n+    }\n+\n+  if (j->ts.type != BT_INTEGER && j->ts.type != BT_LOGICAL)\n+    {\n+      gfc_error (\n+\t\"'%s' argument of '%s' intrinsic at %L must be INTEGER or LOGICAL\",\n+\tgfc_current_intrinsic_arg[1], gfc_current_intrinsic, &j->where);\n+      return FAILURE;\n+    }\n+\n+  if (i->ts.type != j->ts.type)\n+    {\n+      gfc_error (\"'%s' and '%s' arguments of '%s' intrinsic at %L must \"\n+\t\t \"have the same type\", gfc_current_intrinsic_arg[0],\n+\t\t gfc_current_intrinsic_arg[1], gfc_current_intrinsic,\n+\t\t &j->where);\n+      return FAILURE;\n+    }\n+\n+  if (scalar_check (i, 0) == FAILURE)\n+    return FAILURE;\n+\n+  if (scalar_check (j, 1) == FAILURE)\n+    return FAILURE;\n+\n+  return SUCCESS;\n+}"}, {"sha": "a0d0e8c66951ba8c34bc0b1a1dc21ae809511daf", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d723e5434e83d9de5271f6d1c24a694826450a8/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d723e5434e83d9de5271f6d1c24a694826450a8/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=5d723e5434e83d9de5271f6d1c24a694826450a8", "patch": "@@ -291,6 +291,7 @@ enum gfc_generic_isym_id\n   GFC_ISYM_ALL,\n   GFC_ISYM_ALLOCATED,\n   GFC_ISYM_ANINT,\n+  GFC_ISYM_AND,\n   GFC_ISYM_ANY,\n   GFC_ISYM_ASIN,\n   GFC_ISYM_ASINH,\n@@ -310,6 +311,7 @@ enum gfc_generic_isym_id\n   GFC_ISYM_CHDIR,\n   GFC_ISYM_CMPLX,\n   GFC_ISYM_COMMAND_ARGUMENT_COUNT,\n+  GFC_ISYM_COMPLEX,\n   GFC_ISYM_CONJG,\n   GFC_ISYM_COS,\n   GFC_ISYM_COSH,\n@@ -327,10 +329,15 @@ enum gfc_generic_isym_id\n   GFC_ISYM_EXP,\n   GFC_ISYM_EXPONENT,\n   GFC_ISYM_FDATE,\n+  GFC_ISYM_FGET,\n+  GFC_ISYM_FGETC,\n   GFC_ISYM_FLOOR,\n   GFC_ISYM_FNUM,\n+  GFC_ISYM_FPUT,\n+  GFC_ISYM_FPUTC,\n   GFC_ISYM_FRACTION,\n   GFC_ISYM_FSTAT,\n+  GFC_ISYM_FTELL,\n   GFC_ISYM_GETCWD,\n   GFC_ISYM_GETGID,\n   GFC_ISYM_GETPID,\n@@ -379,6 +386,7 @@ enum gfc_generic_isym_id\n   GFC_ISYM_NEAREST,\n   GFC_ISYM_NINT,\n   GFC_ISYM_NOT,\n+  GFC_ISYM_OR,\n   GFC_ISYM_PACK,\n   GFC_ISYM_PRESENT,\n   GFC_ISYM_PRODUCT,\n@@ -421,6 +429,7 @@ enum gfc_generic_isym_id\n   GFC_ISYM_UNLINK,\n   GFC_ISYM_UNPACK,\n   GFC_ISYM_VERIFY,\n+  GFC_ISYM_XOR,\n   GFC_ISYM_CONVERSION\n };\n typedef enum gfc_generic_isym_id gfc_generic_isym_id;"}, {"sha": "7963eec8216a6717c6e52b37e54e93a4aa97d458", "filename": "gcc/fortran/intrinsic.c", "status": "modified", "additions": 77, "deletions": 1, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d723e5434e83d9de5271f6d1c24a694826450a8/gcc%2Ffortran%2Fintrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d723e5434e83d9de5271f6d1c24a694826450a8/gcc%2Ffortran%2Fintrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.c?ref=5d723e5434e83d9de5271f6d1c24a694826450a8", "patch": "@@ -1152,6 +1152,12 @@ add_functions (void)\n \n   make_generic (\"cmplx\", GFC_ISYM_CMPLX, GFC_STD_F77);\n \n+  add_sym_2 (\"complex\", 1, 1, BT_COMPLEX, dz, GFC_STD_GNU,\n+\t     gfc_check_complex, gfc_simplify_complex, gfc_resolve_complex,\n+\t     x, BT_UNKNOWN, dr, REQUIRED, y, BT_UNKNOWN, dr, REQUIRED);\n+\n+  make_generic (\"complex\", GFC_ISYM_COMPLEX, GFC_STD_GNU);\n+\n   /* Making dcmplx a specific of cmplx causes cmplx to return a double\n      complex instead of the default complex.  */\n \n@@ -1365,6 +1371,36 @@ add_functions (void)\n \n   make_generic (\"fstat\", GFC_ISYM_FSTAT, GFC_STD_GNU);\n \n+  add_sym_1 (\"ftell\", 0, 1, BT_INTEGER, ii, GFC_STD_GNU,\n+\t     gfc_check_ftell, NULL, gfc_resolve_ftell,\n+\t     ut, BT_INTEGER, di, REQUIRED);\n+\n+  make_generic (\"ftell\", GFC_ISYM_FTELL, GFC_STD_GNU);\n+\n+  add_sym_2 (\"fgetc\", 0, 1, BT_INTEGER, di, GFC_STD_GNU,\n+\t     gfc_check_fgetputc, NULL, gfc_resolve_fgetc,\n+\t     ut, BT_INTEGER, di, REQUIRED, c, BT_CHARACTER, dc, REQUIRED);\n+\n+  make_generic (\"fgetc\", GFC_ISYM_FGETC, GFC_STD_GNU);\n+\n+  add_sym_1 (\"fget\", 0, 1, BT_INTEGER, di, GFC_STD_GNU,\n+\t     gfc_check_fgetput, NULL, gfc_resolve_fget,\n+\t     c, BT_CHARACTER, dc, REQUIRED);\n+\n+  make_generic (\"fget\", GFC_ISYM_FGET, GFC_STD_GNU);\n+\n+  add_sym_2 (\"fputc\", 0, 1, BT_INTEGER, di, GFC_STD_GNU,\n+\t     gfc_check_fgetputc, NULL, gfc_resolve_fputc,\n+\t     ut, BT_INTEGER, di, REQUIRED, c, BT_CHARACTER, dc, REQUIRED);\n+\n+  make_generic (\"fputc\", GFC_ISYM_FPUTC, GFC_STD_GNU);\n+\n+  add_sym_1 (\"fput\", 0, 1, BT_INTEGER, di, GFC_STD_GNU,\n+\t     gfc_check_fgetput, NULL, gfc_resolve_fput,\n+\t     c, BT_CHARACTER, dc, REQUIRED);\n+\n+  make_generic (\"fput\", GFC_ISYM_FPUT, GFC_STD_GNU);\n+\n   /* Unix IDs (g77 compatibility)  */\n   add_sym_1 (\"getcwd\", 0, 1, BT_INTEGER, di,  GFC_STD_GNU,\n \t     NULL, NULL, gfc_resolve_getcwd,\n@@ -1411,6 +1447,12 @@ add_functions (void)\n \n   make_generic (\"iand\", GFC_ISYM_IAND, GFC_STD_F95);\n \n+  add_sym_2 (\"and\", 1, 0, BT_UNKNOWN, 0, GFC_STD_GNU,\n+\t     gfc_check_and, gfc_simplify_and, gfc_resolve_and,\n+\t     i, BT_UNKNOWN, 0, REQUIRED, j, BT_UNKNOWN, 0, REQUIRED);\n+\n+  make_generic (\"and\", GFC_ISYM_AND, GFC_STD_GNU);\n+\n   add_sym_0 (\"iargc\", 1, 1, BT_INTEGER, di, GFC_STD_GNU,\n \t     NULL, NULL, NULL);\n \n@@ -1453,6 +1495,12 @@ add_functions (void)\n \n   make_generic (\"ieor\", GFC_ISYM_IEOR, GFC_STD_F95);\n \n+  add_sym_2 (\"xor\", 1, 0, BT_UNKNOWN, 0, GFC_STD_GNU,\n+\t     gfc_check_and, gfc_simplify_xor, gfc_resolve_xor,\n+\t     i, BT_UNKNOWN, 0, REQUIRED, j, BT_UNKNOWN, 0, REQUIRED);\n+\n+  make_generic (\"xor\", GFC_ISYM_XOR, GFC_STD_GNU);\n+\n   add_sym_0 (\"ierrno\", 1, 0, BT_INTEGER, di, GFC_STD_GNU,\n \t     NULL, NULL, gfc_resolve_ierrno);\n \n@@ -1485,6 +1533,12 @@ add_functions (void)\n \n   make_generic (\"ior\", GFC_ISYM_IOR, GFC_STD_F95);\n \n+  add_sym_2 (\"or\", 1, 0, BT_UNKNOWN, 0, GFC_STD_GNU,\n+\t     gfc_check_and, gfc_simplify_or, gfc_resolve_or,\n+\t     i, BT_UNKNOWN, 0, REQUIRED, j, BT_UNKNOWN, 0, REQUIRED);\n+\n+  make_generic (\"or\", GFC_ISYM_OR, GFC_STD_GNU);\n+\n   /* The following function is for G77 compatibility.  */\n   add_sym_1 (\"irand\", 0, 1, BT_INTEGER, 4, GFC_STD_GNU,\n              gfc_check_irand, NULL, NULL,\n@@ -2158,7 +2212,7 @@ add_subroutines (void)\n     *com = \"command\", *length = \"length\", *st = \"status\",\n     *val = \"value\", *num = \"number\", *name = \"name\",\n     *trim_name = \"trim_name\", *ut = \"unit\", *han = \"handler\",\n-    *sec = \"seconds\", *res = \"result\";\n+    *sec = \"seconds\", *res = \"result\", *of = \"offset\";\n \n   int di, dr, dc, dl, ii;\n \n@@ -2278,13 +2332,35 @@ add_subroutines (void)\n \n   make_noreturn();\n \n+  add_sym_3s (\"fgetc\", 0, 1, BT_UNKNOWN, 0, GFC_STD_GNU,\n+\t      gfc_check_fgetputc_sub, NULL, gfc_resolve_fgetc_sub,\n+\t      ut, BT_INTEGER, di, REQUIRED, c, BT_CHARACTER, dc, REQUIRED,\n+\t      st, BT_INTEGER, di, OPTIONAL);\n+\n+  add_sym_2s (\"fget\", 0, 1, BT_UNKNOWN, 0, GFC_STD_GNU,\n+\t      gfc_check_fgetput_sub, NULL, gfc_resolve_fget_sub,\n+\t      c, BT_CHARACTER, dc, REQUIRED, st, BT_INTEGER, di, OPTIONAL);\n+\n   add_sym_1s (\"flush\", 0, 1, BT_UNKNOWN, 0, GFC_STD_GNU,\n \t      gfc_check_flush, NULL, gfc_resolve_flush,\n \t      c, BT_INTEGER, di, OPTIONAL);\n \n+  add_sym_3s (\"fputc\", 0, 1, BT_UNKNOWN, 0, GFC_STD_GNU,\n+\t      gfc_check_fgetputc_sub, NULL, gfc_resolve_fputc_sub,\n+\t      ut, BT_INTEGER, di, REQUIRED, c, BT_CHARACTER, dc, REQUIRED,\n+\t      st, BT_INTEGER, di, OPTIONAL);\n+\n+  add_sym_2s (\"fput\", 0, 1, BT_UNKNOWN, 0, GFC_STD_GNU,\n+\t      gfc_check_fgetput_sub, NULL, gfc_resolve_fput_sub,\n+\t      c, BT_CHARACTER, dc, REQUIRED, st, BT_INTEGER, di, OPTIONAL);\n+\n   add_sym_1s (\"free\", 0, 1, BT_UNKNOWN, 0, GFC_STD_GNU, gfc_check_free,\n \t      NULL, gfc_resolve_free, c, BT_INTEGER, ii, REQUIRED);\n \n+  add_sym_2s (\"ftell\", 0, 1, BT_UNKNOWN, 0, GFC_STD_GNU,\n+\t      gfc_check_ftell_sub, NULL, gfc_resolve_ftell_sub,\n+\t      ut, BT_INTEGER, di, REQUIRED, of, BT_INTEGER, ii, REQUIRED);\n+\n   add_sym_2s (\"hostnm\", 0, 1, BT_UNKNOWN, 0, GFC_STD_GNU,\n           gfc_check_hostnm_sub, NULL, gfc_resolve_hostnm_sub,\n \t      c, BT_CHARACTER, dc, REQUIRED, st, BT_INTEGER, di, OPTIONAL);"}, {"sha": "880f41863c139664c70eaa3501c5b3fa0f316d53", "filename": "gcc/fortran/intrinsic.h", "status": "modified", "additions": 28, "deletions": 2, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d723e5434e83d9de5271f6d1c24a694826450a8/gcc%2Ffortran%2Fintrinsic.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d723e5434e83d9de5271f6d1c24a694826450a8/gcc%2Ffortran%2Fintrinsic.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.h?ref=5d723e5434e83d9de5271f6d1c24a694826450a8", "patch": "@@ -42,6 +42,7 @@ try gfc_check_btest (gfc_expr *, gfc_expr *);\n try gfc_check_char (gfc_expr *, gfc_expr *);\n try gfc_check_chdir (gfc_expr *);\n try gfc_check_cmplx (gfc_expr *, gfc_expr *, gfc_expr *);\n+try gfc_check_complex (gfc_expr *, gfc_expr *);\n try gfc_check_count (gfc_expr *, gfc_expr *);\n try gfc_check_cshift (gfc_expr *, gfc_expr *, gfc_expr *);\n try gfc_check_ctime (gfc_expr *);\n@@ -51,7 +52,10 @@ try gfc_check_digits (gfc_expr *);\n try gfc_check_dot_product (gfc_expr *, gfc_expr *);\n try gfc_check_eoshift (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *);\n try gfc_check_etime (gfc_expr *);\n+try gfc_check_fgetputc (gfc_expr *, gfc_expr *);\n+try gfc_check_fgetput (gfc_expr *);\n try gfc_check_fstat (gfc_expr *, gfc_expr *);\n+try gfc_check_ftell (gfc_expr *);\n try gfc_check_fn_c (gfc_expr *);\n try gfc_check_fn_r (gfc_expr *);\n try gfc_check_fn_rc (gfc_expr *);\n@@ -61,6 +65,7 @@ try gfc_check_hostnm (gfc_expr *);\n try gfc_check_huge (gfc_expr *);\n try gfc_check_i (gfc_expr *);\n try gfc_check_iand (gfc_expr *, gfc_expr *);\n+try gfc_check_and (gfc_expr *, gfc_expr *);\n try gfc_check_ibclr (gfc_expr *, gfc_expr *);\n try gfc_check_ibits (gfc_expr *, gfc_expr *, gfc_expr *);\n try gfc_check_ibset (gfc_expr *, gfc_expr *);\n@@ -138,17 +143,20 @@ try gfc_check_ctime_sub (gfc_expr *, gfc_expr *);\n try gfc_check_system_clock (gfc_expr *, gfc_expr *, gfc_expr *);\n try gfc_check_date_and_time (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *);\n try gfc_check_exit (gfc_expr *);\n+try gfc_check_fdate_sub (gfc_expr *);\n try gfc_check_flush (gfc_expr *);\n try gfc_check_free (gfc_expr *);\n try gfc_check_fstat_sub (gfc_expr *, gfc_expr *, gfc_expr *);\n-try gfc_check_fdate_sub (gfc_expr *);\n try gfc_check_gerror (gfc_expr *);\n try gfc_check_getlog (gfc_expr *);\n try gfc_check_mvbits (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *,\n \t\t      gfc_expr *);\n try gfc_check_random_number (gfc_expr *);\n try gfc_check_random_seed (gfc_expr *, gfc_expr *, gfc_expr *);\n try gfc_check_etime_sub (gfc_expr *, gfc_expr *);\n+try gfc_check_fgetputc_sub (gfc_expr *, gfc_expr *, gfc_expr *);\n+try gfc_check_fgetput_sub (gfc_expr *, gfc_expr *);\n+try gfc_check_ftell_sub (gfc_expr *, gfc_expr *);\n try gfc_check_getcwd_sub (gfc_expr *, gfc_expr *);\n try gfc_check_hostnm_sub (gfc_expr *, gfc_expr *);\n try gfc_check_kill_sub (gfc_expr *, gfc_expr *, gfc_expr *);\n@@ -177,6 +185,7 @@ gfc_expr *gfc_simplify_aint (gfc_expr *, gfc_expr *);\n gfc_expr *gfc_simplify_dint (gfc_expr *);\n gfc_expr *gfc_simplify_anint (gfc_expr *, gfc_expr *);\n gfc_expr *gfc_simplify_dnint (gfc_expr *);\n+gfc_expr *gfc_simplify_and (gfc_expr *, gfc_expr *);\n gfc_expr *gfc_simplify_asin (gfc_expr *);\n gfc_expr *gfc_simplify_asinh (gfc_expr *);\n gfc_expr *gfc_simplify_atan (gfc_expr *);\n@@ -187,6 +196,7 @@ gfc_expr *gfc_simplify_btest (gfc_expr *, gfc_expr *);\n gfc_expr *gfc_simplify_ceiling (gfc_expr *, gfc_expr *);\n gfc_expr *gfc_simplify_char (gfc_expr *, gfc_expr *);\n gfc_expr *gfc_simplify_cmplx (gfc_expr *, gfc_expr *, gfc_expr *);\n+gfc_expr *gfc_simplify_complex (gfc_expr *, gfc_expr *);\n gfc_expr *gfc_simplify_conjg (gfc_expr *);\n gfc_expr *gfc_simplify_cos (gfc_expr *);\n gfc_expr *gfc_simplify_cosh (gfc_expr *);\n@@ -240,6 +250,7 @@ gfc_expr *gfc_simplify_nint (gfc_expr *, gfc_expr *);\n gfc_expr *gfc_simplify_null (gfc_expr *);\n gfc_expr *gfc_simplify_idnint (gfc_expr *);\n gfc_expr *gfc_simplify_not (gfc_expr *);\n+gfc_expr *gfc_simplify_or (gfc_expr *, gfc_expr *);\n gfc_expr *gfc_simplify_precision (gfc_expr *);\n gfc_expr *gfc_simplify_radix (gfc_expr *);\n gfc_expr *gfc_simplify_range (gfc_expr *);\n@@ -268,6 +279,7 @@ gfc_expr *gfc_simplify_tiny (gfc_expr *);\n gfc_expr *gfc_simplify_trim (gfc_expr *);\n gfc_expr *gfc_simplify_ubound (gfc_expr *, gfc_expr *);\n gfc_expr *gfc_simplify_verify (gfc_expr *, gfc_expr *, gfc_expr *);\n+gfc_expr *gfc_simplify_xor (gfc_expr *, gfc_expr *);\n \n /* Constant conversion simplification.  */\n gfc_expr *gfc_convert_constant (gfc_expr *, bt, int);\n@@ -283,6 +295,7 @@ void gfc_resolve_dint (gfc_expr *, gfc_expr *);\n void gfc_resolve_all (gfc_expr *, gfc_expr *, gfc_expr *);\n void gfc_resolve_anint (gfc_expr *, gfc_expr *, gfc_expr *);\n void gfc_resolve_dnint (gfc_expr *, gfc_expr *);\n+void gfc_resolve_and (gfc_expr *, gfc_expr *, gfc_expr *);\n void gfc_resolve_any (gfc_expr *, gfc_expr *, gfc_expr *);\n void gfc_resolve_asin (gfc_expr *, gfc_expr *);\n void gfc_resolve_asinh (gfc_expr *, gfc_expr *);\n@@ -296,6 +309,7 @@ void gfc_resolve_char (gfc_expr *, gfc_expr *, gfc_expr *);\n void gfc_resolve_chdir (gfc_expr *, gfc_expr *);\n void gfc_resolve_cmplx (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *);\n void gfc_resolve_dcmplx (gfc_expr *, gfc_expr *, gfc_expr *);\n+void gfc_resolve_complex (gfc_expr *, gfc_expr *, gfc_expr *);\n void gfc_resolve_conjg (gfc_expr *, gfc_expr *);\n void gfc_resolve_cos (gfc_expr *, gfc_expr *);\n void gfc_resolve_cosh (gfc_expr *, gfc_expr *);\n@@ -316,6 +330,11 @@ void gfc_resolve_floor (gfc_expr *, gfc_expr *, gfc_expr *);\n void gfc_resolve_fnum (gfc_expr *, gfc_expr *);\n void gfc_resolve_fraction (gfc_expr *, gfc_expr *);\n void gfc_resolve_fstat (gfc_expr *, gfc_expr *, gfc_expr *);\n+void gfc_resolve_ftell (gfc_expr *, gfc_expr *);\n+void gfc_resolve_fgetc (gfc_expr *, gfc_expr *, gfc_expr *);\n+void gfc_resolve_fget (gfc_expr *, gfc_expr *);\n+void gfc_resolve_fputc (gfc_expr *, gfc_expr *, gfc_expr *);\n+void gfc_resolve_fput (gfc_expr *, gfc_expr *);\n void gfc_resolve_g77_math1 (gfc_expr *, gfc_expr *);\n void gfc_resolve_getcwd (gfc_expr *, gfc_expr *);\n void gfc_resolve_getgid (gfc_expr *);\n@@ -358,6 +377,7 @@ void gfc_resolve_modulo (gfc_expr *, gfc_expr *, gfc_expr *);\n void gfc_resolve_nearest (gfc_expr *, gfc_expr *, gfc_expr *);\n void gfc_resolve_nint (gfc_expr *, gfc_expr *, gfc_expr *);\n void gfc_resolve_not (gfc_expr *, gfc_expr *);\n+void gfc_resolve_or (gfc_expr *, gfc_expr *, gfc_expr *);\n void gfc_resolve_pack (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *);\n void gfc_resolve_product (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *);\n void gfc_resolve_real (gfc_expr *, gfc_expr *, gfc_expr *);\n@@ -398,6 +418,7 @@ void gfc_resolve_umask (gfc_expr *, gfc_expr *);\n void gfc_resolve_unlink (gfc_expr *, gfc_expr *);\n void gfc_resolve_unpack (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *);\n void gfc_resolve_verify (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *);\n+void gfc_resolve_xor (gfc_expr *, gfc_expr *, gfc_expr *);\n \n \n /* Intrinsic subroutine resolution.  */\n@@ -406,10 +427,15 @@ void gfc_resolve_chdir_sub (gfc_code *);\n void gfc_resolve_cpu_time (gfc_code *);\n void gfc_resolve_ctime_sub (gfc_code *);\n void gfc_resolve_exit (gfc_code *);\n+void gfc_resolve_fdate_sub (gfc_code *);\n void gfc_resolve_flush (gfc_code *);\n void gfc_resolve_free (gfc_code *);\n void gfc_resolve_fstat_sub (gfc_code *);\n-void gfc_resolve_fdate_sub (gfc_code *);\n+void gfc_resolve_ftell_sub (gfc_code *);\n+void gfc_resolve_fgetc_sub (gfc_code *);\n+void gfc_resolve_fget_sub (gfc_code *);\n+void gfc_resolve_fputc_sub (gfc_code *);\n+void gfc_resolve_fput_sub (gfc_code *);\n void gfc_resolve_gerror (gfc_code *);\n void gfc_resolve_getarg (gfc_code *);\n void gfc_resolve_getcwd_sub (gfc_code *);"}, {"sha": "de3c2718956d746686fb04c052dc575454fdddb1", "filename": "gcc/fortran/iresolve.c", "status": "modified", "additions": 281, "deletions": 0, "changes": 281, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d723e5434e83d9de5271f6d1c24a694826450a8/gcc%2Ffortran%2Firesolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d723e5434e83d9de5271f6d1c24a694826450a8/gcc%2Ffortran%2Firesolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Firesolve.c?ref=5d723e5434e83d9de5271f6d1c24a694826450a8", "patch": "@@ -117,6 +117,26 @@ gfc_resolve_aimag (gfc_expr * f, gfc_expr * x)\n }\n \n \n+void\n+gfc_resolve_and (gfc_expr * f, gfc_expr * i, gfc_expr * j)\n+{\n+  f->ts.type = i->ts.type;\n+  f->ts.kind = gfc_kind_max (i,j);\n+\n+  if (i->ts.kind != j->ts.kind)\n+    {\n+      if (i->ts.kind == gfc_kind_max (i,j))\n+\tgfc_convert_type(j, &i->ts, 2);\n+      else\n+\tgfc_convert_type(i, &j->ts, 2);\n+    }\n+\n+  f->value.function.name = gfc_get_string (\"__and_%c%d\",\n+\t\t\t\t\t   gfc_type_letter (i->ts.type),\n+\t\t\t\t\t   f->ts.kind);\n+}\n+\n+\n void\n gfc_resolve_aint (gfc_expr * f, gfc_expr * a, gfc_expr * kind)\n {\n@@ -356,6 +376,36 @@ gfc_resolve_dcmplx (gfc_expr * f, gfc_expr * x, gfc_expr * y)\n   gfc_resolve_cmplx (f, x, y, gfc_int_expr (gfc_default_double_kind));\n }\n \n+void\n+gfc_resolve_complex (gfc_expr * f, gfc_expr * x, gfc_expr * y)\n+{\n+  int kind;\n+\n+  if (x->ts.type == BT_INTEGER)\n+    {\n+      if (y->ts.type == BT_INTEGER)\n+\tkind = gfc_default_real_kind;\n+      else\n+\tkind = y->ts.kind;\n+    }\n+  else\n+    {\n+      if (y->ts.type == BT_REAL)\n+\tkind = (x->ts.kind > y->ts.kind) ? x->ts.kind : y->ts.kind;\n+      else\n+\tkind = x->ts.kind;\n+    }\n+\n+  f->ts.type = BT_COMPLEX;\n+  f->ts.kind = kind;\n+\n+  f->value.function.name =\n+    gfc_get_string (\"__cmplx1_%d_%c%d_%c%d\", f->ts.kind,\n+\t\t    gfc_type_letter (x->ts.type), x->ts.kind,\n+\t\t    gfc_type_letter (y->ts.type), y->ts.kind);\n+}\n+\n+\n void\n gfc_resolve_conjg (gfc_expr * f, gfc_expr * x)\n {\n@@ -1177,6 +1227,26 @@ gfc_resolve_not (gfc_expr * f, gfc_expr * i)\n }\n \n \n+void\n+gfc_resolve_or (gfc_expr * f, gfc_expr * i, gfc_expr * j)\n+{\n+  f->ts.type = i->ts.type;\n+  f->ts.kind = gfc_kind_max (i,j);\n+\n+  if (i->ts.kind != j->ts.kind)\n+    {\n+      if (i->ts.kind == gfc_kind_max (i,j))\n+\tgfc_convert_type(j, &i->ts, 2);\n+      else\n+\tgfc_convert_type(i, &j->ts, 2);\n+    }\n+\n+  f->value.function.name = gfc_get_string (\"__or_%c%d\",\n+\t\t\t\t\t   gfc_type_letter (i->ts.type),\n+\t\t\t\t\t   f->ts.kind);\n+}\n+\n+\n void\n gfc_resolve_pack (gfc_expr * f, gfc_expr * array, gfc_expr * mask,\n \t\t  gfc_expr * vector ATTRIBUTE_UNUSED)\n@@ -1553,6 +1623,84 @@ gfc_resolve_fstat (gfc_expr * f, gfc_expr * n, gfc_expr * a ATTRIBUTE_UNUSED)\n }\n \n \n+void\n+gfc_resolve_fgetc (gfc_expr * f, gfc_expr * u, gfc_expr * c ATTRIBUTE_UNUSED)\n+{\n+  gfc_typespec ts;\n+\n+  f->ts.type = BT_INTEGER;\n+  f->ts.kind = gfc_c_int_kind;\n+  if (u->ts.kind != gfc_c_int_kind)\n+    {\n+      ts.type = BT_INTEGER;\n+      ts.kind = gfc_c_int_kind;\n+      ts.derived = NULL;\n+      ts.cl = NULL;\n+      gfc_convert_type (u, &ts, 2);\n+    }\n+\n+  f->value.function.name = gfc_get_string (PREFIX(\"fgetc\"));\n+}\n+\n+\n+void\n+gfc_resolve_fget (gfc_expr * f, gfc_expr * c ATTRIBUTE_UNUSED)\n+{\n+  f->ts.type = BT_INTEGER;\n+  f->ts.kind = gfc_c_int_kind;\n+  f->value.function.name = gfc_get_string (PREFIX(\"fget\"));\n+}\n+\n+\n+void\n+gfc_resolve_fputc (gfc_expr * f, gfc_expr * u, gfc_expr * c ATTRIBUTE_UNUSED)\n+{\n+  gfc_typespec ts;\n+\n+  f->ts.type = BT_INTEGER;\n+  f->ts.kind = gfc_c_int_kind;\n+  if (u->ts.kind != gfc_c_int_kind)\n+    {\n+      ts.type = BT_INTEGER;\n+      ts.kind = gfc_c_int_kind;\n+      ts.derived = NULL;\n+      ts.cl = NULL;\n+      gfc_convert_type (u, &ts, 2);\n+    }\n+\n+  f->value.function.name = gfc_get_string (PREFIX(\"fputc\"));\n+}\n+\n+\n+void\n+gfc_resolve_fput (gfc_expr * f, gfc_expr * c ATTRIBUTE_UNUSED)\n+{\n+  f->ts.type = BT_INTEGER;\n+  f->ts.kind = gfc_c_int_kind;\n+  f->value.function.name = gfc_get_string (PREFIX(\"fput\"));\n+}\n+\n+\n+void\n+gfc_resolve_ftell (gfc_expr * f, gfc_expr * u)\n+{\n+  gfc_typespec ts;\n+\n+  f->ts.type = BT_INTEGER;\n+  f->ts.kind = gfc_index_integer_kind;\n+  if (u->ts.kind != gfc_c_int_kind)\n+    {\n+      ts.type = BT_INTEGER;\n+      ts.kind = gfc_c_int_kind;\n+      ts.derived = NULL;\n+      ts.cl = NULL;\n+      gfc_convert_type (u, &ts, 2);\n+    }\n+\n+  f->value.function.name = gfc_get_string (PREFIX(\"ftell\"));\n+}\n+\n+\n void\n gfc_resolve_sum (gfc_expr * f, gfc_expr * array, gfc_expr * dim,\n \t\t gfc_expr * mask)\n@@ -1799,6 +1947,26 @@ gfc_resolve_verify (gfc_expr * f, gfc_expr * string,\n }\n \n \n+void\n+gfc_resolve_xor (gfc_expr * f, gfc_expr * i, gfc_expr * j)\n+{\n+  f->ts.type = i->ts.type;\n+  f->ts.kind = gfc_kind_max (i,j);\n+\n+  if (i->ts.kind != j->ts.kind)\n+    {\n+      if (i->ts.kind == gfc_kind_max (i,j))\n+\tgfc_convert_type(j, &i->ts, 2);\n+      else\n+\tgfc_convert_type(i, &j->ts, 2);\n+    }\n+\n+  f->value.function.name = gfc_get_string (\"__xor_%c%d\",\n+\t\t\t\t\t   gfc_type_letter (i->ts.type),\n+\t\t\t\t\t   f->ts.kind);\n+}\n+\n+\n /* Intrinsic subroutine resolution.  */\n \n void\n@@ -2265,6 +2433,119 @@ gfc_resolve_fstat_sub (gfc_code * c)\n }\n \n \n+void\n+gfc_resolve_fgetc_sub (gfc_code * c)\n+{\n+  const char *name;\n+  gfc_typespec ts;\n+  gfc_expr *u, *st;\n+\n+  u = c->ext.actual->expr;\n+  st = c->ext.actual->next->next->expr;\n+\n+  if (u->ts.kind != gfc_c_int_kind)\n+    {\n+      ts.type = BT_INTEGER;\n+      ts.kind = gfc_c_int_kind;\n+      ts.derived = NULL;\n+      ts.cl = NULL;\n+      gfc_convert_type (u, &ts, 2);\n+    }\n+\n+  if (st != NULL)\n+    name = gfc_get_string (PREFIX(\"fgetc_i%d_sub\"), st->ts.kind);\n+  else\n+    name = gfc_get_string (PREFIX(\"fgetc_i%d_sub\"), gfc_default_integer_kind);\n+\n+  c->resolved_sym = gfc_get_intrinsic_sub_symbol (name);\n+}\n+\n+\n+void\n+gfc_resolve_fget_sub (gfc_code * c)\n+{\n+  const char *name;\n+  gfc_expr *st;\n+\n+  st = c->ext.actual->next->expr;\n+  if (st != NULL)\n+    name = gfc_get_string (PREFIX(\"fget_i%d_sub\"), st->ts.kind);\n+  else\n+    name = gfc_get_string (PREFIX(\"fget_i%d_sub\"), gfc_default_integer_kind);\n+\n+  c->resolved_sym = gfc_get_intrinsic_sub_symbol (name);\n+}\n+\n+\n+void\n+gfc_resolve_fputc_sub (gfc_code * c)\n+{\n+  const char *name;\n+  gfc_typespec ts;\n+  gfc_expr *u, *st;\n+\n+  u = c->ext.actual->expr;\n+  st = c->ext.actual->next->next->expr;\n+\n+  if (u->ts.kind != gfc_c_int_kind)\n+    {\n+      ts.type = BT_INTEGER;\n+      ts.kind = gfc_c_int_kind;\n+      ts.derived = NULL;\n+      ts.cl = NULL;\n+      gfc_convert_type (u, &ts, 2);\n+    }\n+\n+  if (st != NULL)\n+    name = gfc_get_string (PREFIX(\"fputc_i%d_sub\"), st->ts.kind);\n+  else\n+    name = gfc_get_string (PREFIX(\"fputc_i%d_sub\"), gfc_default_integer_kind);\n+\n+  c->resolved_sym = gfc_get_intrinsic_sub_symbol (name);\n+}\n+\n+\n+void\n+gfc_resolve_fput_sub (gfc_code * c)\n+{\n+  const char *name;\n+  gfc_expr *st;\n+\n+  st = c->ext.actual->next->expr;\n+  if (st != NULL)\n+    name = gfc_get_string (PREFIX(\"fput_i%d_sub\"), st->ts.kind);\n+  else\n+    name = gfc_get_string (PREFIX(\"fput_i%d_sub\"), gfc_default_integer_kind);\n+\n+  c->resolved_sym = gfc_get_intrinsic_sub_symbol (name);\n+}\n+\n+\n+void\n+gfc_resolve_ftell_sub (gfc_code * c)\n+{\n+  const char *name;\n+  gfc_expr *unit;\n+  gfc_expr *offset;\n+  gfc_typespec ts;\n+\n+  unit = c->ext.actual->expr;\n+  offset = c->ext.actual->next->expr;\n+\n+  if (unit->ts.kind != gfc_c_int_kind)\n+    {\n+      ts.type = BT_INTEGER;\n+      ts.kind = gfc_c_int_kind;\n+      ts.derived = NULL;\n+      ts.cl = NULL;\n+      gfc_convert_type (unit, &ts, 2);\n+    }\n+\n+  name = gfc_get_string (PREFIX(\"ftell_i%d_sub\"), offset->ts.kind);\n+  c->resolved_sym = gfc_get_intrinsic_sub_symbol (name);\n+}\n+\n+\n void\n gfc_resolve_ttynam_sub (gfc_code * c)\n {"}, {"sha": "b6931f112e12f7fc298cc4de7c8f5afc6f42ec88", "filename": "gcc/fortran/simplify.c", "status": "modified", "additions": 106, "deletions": 0, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d723e5434e83d9de5271f6d1c24a694826450a8/gcc%2Ffortran%2Fsimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d723e5434e83d9de5271f6d1c24a694826450a8/gcc%2Ffortran%2Fsimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsimplify.c?ref=5d723e5434e83d9de5271f6d1c24a694826450a8", "patch": "@@ -449,6 +449,31 @@ gfc_simplify_anint (gfc_expr * e, gfc_expr * k)\n }\n \n \n+gfc_expr *\n+gfc_simplify_and (gfc_expr * x, gfc_expr * y)\n+{\n+  gfc_expr *result;\n+  int kind;\n+\n+  if (x->expr_type != EXPR_CONSTANT || y->expr_type != EXPR_CONSTANT)\n+    return NULL;\n+\n+  kind = x->ts.kind > y->ts.kind ? x->ts.kind : y->ts.kind;\n+  if (x->ts.type == BT_INTEGER)\n+    {\n+      result = gfc_constant_result (BT_INTEGER, kind, &x->where);\n+      mpz_and (result->value.integer, x->value.integer, y->value.integer);\n+    }\n+  else /* BT_LOGICAL */\n+    {\n+      result = gfc_constant_result (BT_LOGICAL, kind, &x->where);\n+      result->value.logical = x->value.logical && y->value.logical;\n+    }\n+\n+  return range_check (result, \"AND\");\n+}\n+\n+\n gfc_expr *\n gfc_simplify_dnint (gfc_expr * e)\n {\n@@ -723,6 +748,34 @@ gfc_simplify_cmplx (gfc_expr * x, gfc_expr * y, gfc_expr * k)\n }\n \n \n+gfc_expr *\n+gfc_simplify_complex (gfc_expr * x, gfc_expr * y)\n+{\n+  int kind;\n+\n+  if (x->expr_type != EXPR_CONSTANT\n+      || (y != NULL && y->expr_type != EXPR_CONSTANT))\n+    return NULL;\n+\n+  if (x->ts.type == BT_INTEGER)\n+    {\n+      if (y->ts.type == BT_INTEGER)\n+\tkind = gfc_default_real_kind;\n+      else\n+\tkind = y->ts.kind;\n+    }\n+  else\n+    {\n+      if (y->ts.type == BT_REAL)\n+\tkind = (x->ts.kind > y->ts.kind) ? x->ts.kind : y->ts.kind;\n+      else\n+\tkind = x->ts.kind;\n+    }\n+\n+  return simplify_cmplx (\"COMPLEX\", x, y, kind);\n+}\n+\n+\n gfc_expr *\n gfc_simplify_conjg (gfc_expr * e)\n {\n@@ -2479,6 +2532,31 @@ gfc_simplify_null (gfc_expr * mold)\n }\n \n \n+gfc_expr *\n+gfc_simplify_or (gfc_expr * x, gfc_expr * y)\n+{\n+  gfc_expr *result;\n+  int kind;\n+\n+  if (x->expr_type != EXPR_CONSTANT || y->expr_type != EXPR_CONSTANT)\n+    return NULL;\n+\n+  kind = x->ts.kind > y->ts.kind ? x->ts.kind : y->ts.kind;\n+  if (x->ts.type == BT_INTEGER)\n+    {\n+      result = gfc_constant_result (BT_INTEGER, kind, &x->where);\n+      mpz_ior (result->value.integer, x->value.integer, y->value.integer);\n+    }\n+  else /* BT_LOGICAL */\n+    {\n+      result = gfc_constant_result (BT_LOGICAL, kind, &x->where);\n+      result->value.logical = x->value.logical || y->value.logical;\n+    }\n+\n+  return range_check (result, \"OR\");\n+}\n+\n+\n gfc_expr *\n gfc_simplify_precision (gfc_expr * e)\n {\n@@ -3706,6 +3784,34 @@ gfc_simplify_verify (gfc_expr * s, gfc_expr * set, gfc_expr * b)\n   return result;\n }\n \n+\n+gfc_expr *\n+gfc_simplify_xor (gfc_expr * x, gfc_expr * y)\n+{\n+  gfc_expr *result;\n+  int kind;\n+\n+  if (x->expr_type != EXPR_CONSTANT || y->expr_type != EXPR_CONSTANT)\n+    return NULL;\n+\n+  kind = x->ts.kind > y->ts.kind ? x->ts.kind : y->ts.kind;\n+  if (x->ts.type == BT_INTEGER)\n+    {\n+      result = gfc_constant_result (BT_INTEGER, kind, &x->where);\n+      mpz_xor (result->value.integer, x->value.integer, y->value.integer);\n+    }\n+  else /* BT_LOGICAL */\n+    {\n+      result = gfc_constant_result (BT_LOGICAL, kind, &x->where);\n+      result->value.logical = (x->value.logical && ! y->value.logical)\n+\t\t\t      || (! x->value.logical && y->value.logical);\n+    }\n+\n+  return range_check (result, \"XOR\");\n+}\n+\n+\n+\n /****************** Constant simplification *****************/\n \n /* Master function to convert one constant to another.  While this is"}, {"sha": "ea9c2e3b7db11a0fe67e2643e7ac60a16d5f6b1e", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d723e5434e83d9de5271f6d1c24a694826450a8/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d723e5434e83d9de5271f6d1c24a694826450a8/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=5d723e5434e83d9de5271f6d1c24a694826450a8", "patch": "@@ -2983,6 +2983,10 @@ gfc_conv_intrinsic_function (gfc_se * se, gfc_expr * expr)\n       gfc_conv_intrinsic_aint (se, expr, FIX_ROUND_EXPR);\n       break;\n \n+    case GFC_ISYM_AND:\n+      gfc_conv_intrinsic_bitop (se, expr, BIT_AND_EXPR);\n+      break;\n+\n     case GFC_ISYM_ANY:\n       gfc_conv_intrinsic_anyall (se, expr, NE_EXPR);\n       break;\n@@ -3037,6 +3041,10 @@ gfc_conv_intrinsic_function (gfc_se * se, gfc_expr * expr)\n       gfc_conv_intrinsic_iargc (se, expr);\n       break;\n \n+    case GFC_ISYM_COMPLEX:\n+      gfc_conv_intrinsic_cmplx (se, expr, 1);\n+      break;\n+\n     case GFC_ISYM_CONJG:\n       gfc_conv_intrinsic_conjg (se, expr);\n       break;\n@@ -3167,6 +3175,10 @@ gfc_conv_intrinsic_function (gfc_se * se, gfc_expr * expr)\n       gfc_conv_intrinsic_not (se, expr);\n       break;\n \n+    case GFC_ISYM_OR:\n+      gfc_conv_intrinsic_bitop (se, expr, BIT_IOR_EXPR);\n+      break;\n+\n     case GFC_ISYM_PRESENT:\n       gfc_conv_intrinsic_present (se, expr);\n       break;\n@@ -3199,15 +3211,24 @@ gfc_conv_intrinsic_function (gfc_se * se, gfc_expr * expr)\n       gfc_conv_intrinsic_bound (se, expr, 1);\n       break;\n \n+    case GFC_ISYM_XOR:\n+      gfc_conv_intrinsic_bitop (se, expr, BIT_XOR_EXPR);\n+      break;\n+\n     case GFC_ISYM_LOC:\n       gfc_conv_intrinsic_loc (se, expr);\n       break;\n \n     case GFC_ISYM_CHDIR:\n     case GFC_ISYM_DOT_PRODUCT:\n     case GFC_ISYM_ETIME:\n+    case GFC_ISYM_FGET:\n+    case GFC_ISYM_FGETC:\n     case GFC_ISYM_FNUM:\n+    case GFC_ISYM_FPUT:\n+    case GFC_ISYM_FPUTC:\n     case GFC_ISYM_FSTAT:\n+    case GFC_ISYM_FTELL:\n     case GFC_ISYM_GETCWD:\n     case GFC_ISYM_GETGID:\n     case GFC_ISYM_GETPID:"}, {"sha": "ae3265f36e1c7b4e0c1734f4aada24eb0186738f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d723e5434e83d9de5271f6d1c24a694826450a8/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d723e5434e83d9de5271f6d1c24a694826450a8/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=5d723e5434e83d9de5271f6d1c24a694826450a8", "patch": "@@ -1,3 +1,15 @@\n+2005-11-13  Francois-Xavier Coudert  <coudert@clipper.ens.fr>\n+\n+\t* gfortran.dg/complex_intrinsic_1.f90: New test.\n+\t* gfortran.dg/complex_intrinsic_2.f90: New test.\n+\t* gfortran.dg/fgetc_1.f90: New test.\n+\t* gfortran.dg/fgetc_2.f90: New test.\n+\t* gfortran.dg/fgetc_3.f90: New test.\n+\t* gfortran.dg/ftell_1.f90: New test.\n+\t* gfortran.dg/ftell_2.f90: New test.\n+\t* gfortran.dg/gnu_logical_1.F: New test.\n+\t* gfortran.dg/gnu_logical_2.f90: New test.\n+\n 2005-11-13  Andrew Pinski  <pinskia@physics.uc.edu>\n \n \tPR middle-end/24820"}, {"sha": "3c299151e9e02e07c0e1d977ddc0678aa5bbedaa", "filename": "gcc/testsuite/gfortran.dg/complex_intrinsic_1.f90", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d723e5434e83d9de5271f6d1c24a694826450a8/gcc%2Ftestsuite%2Fgfortran.dg%2Fcomplex_intrinsic_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d723e5434e83d9de5271f6d1c24a694826450a8/gcc%2Ftestsuite%2Fgfortran.dg%2Fcomplex_intrinsic_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcomplex_intrinsic_1.f90?ref=5d723e5434e83d9de5271f6d1c24a694826450a8", "patch": "@@ -0,0 +1,5 @@\n+! Testcase for the COMPLEX intrinsic\n+! { dg-do run }\n+  if (complex(1_1, -1_2) /= complex(1.0_4, -1.0_8)) call abort\n+  if (complex(1_4, -1.0) /= complex(1.0_4, -1_8)) call abort\n+  end"}, {"sha": "1327e4a952b3496182acec6c0bee6465dc37b7a2", "filename": "gcc/testsuite/gfortran.dg/complex_intrinsic_2.f90", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d723e5434e83d9de5271f6d1c24a694826450a8/gcc%2Ftestsuite%2Fgfortran.dg%2Fcomplex_intrinsic_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d723e5434e83d9de5271f6d1c24a694826450a8/gcc%2Ftestsuite%2Fgfortran.dg%2Fcomplex_intrinsic_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcomplex_intrinsic_2.f90?ref=5d723e5434e83d9de5271f6d1c24a694826450a8", "patch": "@@ -0,0 +1,7 @@\n+! Testcase for the COMPLEX intrinsic\n+! { dg-do compile }\n+  complex c\n+  c = complex(.true.,1.0) ! { dg-error \"must be INTEGER or REAL\" }\n+  c = complex(1) ! { dg-error \"Missing actual argument\" }\n+  c = complex(1,c) ! { dg-error \"must be INTEGER or REAL\" }\n+  end"}, {"sha": "966e15a98a4ce166a0d6e42d8e64b07192f91890", "filename": "gcc/testsuite/gfortran.dg/fgetc_1.f90", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d723e5434e83d9de5271f6d1c24a694826450a8/gcc%2Ftestsuite%2Fgfortran.dg%2Ffgetc_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d723e5434e83d9de5271f6d1c24a694826450a8/gcc%2Ftestsuite%2Fgfortran.dg%2Ffgetc_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ffgetc_1.f90?ref=5d723e5434e83d9de5271f6d1c24a694826450a8", "patch": "@@ -0,0 +1,39 @@\n+! Testcase for the FGETC and FPUTC intrinsics\n+! { dg-do run }\n+  character(len=5) s\n+  integer st\n+\n+  s = \"12345\"\n+  open(10,status=\"scratch\")\n+  write(10,\"(A)\") \"abcde\"\n+  rewind(10)\n+  call fgetc(10,s,st)\n+  if ((st /= 0) .or. (s /= \"a    \")) call abort\n+  call fgetc(10,s,st)\n+  close(10)\n+\n+  open(10,status=\"scratch\")\n+  s = \"12345\"\n+  call fputc(10,s,st)\n+  if (st /= 0) call abort\n+  call fputc(10,\"2\",st)\n+  if (st /= 0) call abort\n+  call fputc(10,\"3 \",st)\n+  if (st /= 0) call abort\n+  rewind(10)\n+  call fgetc(10,s)\n+  if (s(1:1) /= \"1\") call abort\n+  call fgetc(10,s)\n+  if (s(1:1) /= \"2\") call abort\n+  call fgetc(10,s,st)\n+  if ((s(1:1) /= \"3\") .or. (st /= 0)) call abort\n+  call fgetc(10,s,st)\n+  if (st /= -1) call abort\n+  close (10)\n+\n+! FGETC and FPUTC on units not opened should not work\n+  call fgetc(12,s,st)\n+  if (st /= -1) call abort\n+  call fputc(12,s,st)\n+  if (st /= -1) call abort\n+  end"}, {"sha": "6dd12c4e242bad6399083cc076cdc1f37b33de9f", "filename": "gcc/testsuite/gfortran.dg/fgetc_2.f90", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d723e5434e83d9de5271f6d1c24a694826450a8/gcc%2Ftestsuite%2Fgfortran.dg%2Ffgetc_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d723e5434e83d9de5271f6d1c24a694826450a8/gcc%2Ftestsuite%2Fgfortran.dg%2Ffgetc_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ffgetc_2.f90?ref=5d723e5434e83d9de5271f6d1c24a694826450a8", "patch": "@@ -0,0 +1,39 @@\n+! Testcase for the FGETC and FPUTC intrinsics\n+! { dg-do run }\n+  character(len=5) s\n+  integer st\n+\n+  s = \"12345\"\n+  open(10,status=\"scratch\")\n+  write(10,\"(A)\") \"abcde\"\n+  rewind(10)\n+  st = fgetc(10,s)\n+  if ((st /= 0) .or. (s /= \"a    \")) call abort\n+  st = fgetc(10,s)\n+  close(10)\n+\n+  open(10,status=\"scratch\")\n+  s = \"12345\"\n+  st = fputc(10,s)\n+  if (st /= 0) call abort\n+  st = fputc(10,\"2\")\n+  if (st /= 0) call abort\n+  st = fputc(10,\"3 \")\n+  if (st /= 0) call abort\n+  rewind(10)\n+  st = fgetc(10,s)\n+  if (s(1:1) /= \"1\") call abort\n+  st = fgetc(10,s)\n+  if (s(1:1) /= \"2\") call abort\n+  st = fgetc(10,s)\n+  if ((s(1:1) /= \"3\") .or. (st /= 0)) call abort\n+  st = fgetc(10,s)\n+  if (st /= -1) call abort\n+  close (10)\n+\n+! FGETC and FPUTC on units not opened should not work\n+  st = fgetc(12,s)\n+  if (st /= -1) call abort\n+  st = fputc(12,s)\n+  if (st /= -1) call abort\n+  end"}, {"sha": "3706b67a81fc0fcd99ad17c14adcd365697da6f2", "filename": "gcc/testsuite/gfortran.dg/fgetc_3.f90", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d723e5434e83d9de5271f6d1c24a694826450a8/gcc%2Ftestsuite%2Fgfortran.dg%2Ffgetc_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d723e5434e83d9de5271f6d1c24a694826450a8/gcc%2Ftestsuite%2Fgfortran.dg%2Ffgetc_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ffgetc_3.f90?ref=5d723e5434e83d9de5271f6d1c24a694826450a8", "patch": "@@ -0,0 +1,34 @@\n+! Testcase for the FGETC and FPUTC intrinsics\n+! { dg-do compile }\n+  character(len=5) s\n+  integer st\n+\n+  s = \"12345\"\n+  open(status=\"scratch\")\n+  write(*,\"(A)\") \"abcde\"\n+  rewind(10)\n+  st = fget(s)\n+  if ((st /= 0) .or. (s /= \"a    \")) call abort\n+  st = fget(s)\n+  close(10)\n+\n+  open(status=\"scratch\")\n+  s = \"12345\"\n+  st = fput(s)\n+  if (st /= 0) call abort\n+  st = fput(\"2\")\n+  if (st /= 0) call abort\n+  st = fput(\"3 \")\n+  if (st /= 0) call abort\n+  rewind(10)\n+  st = fget(s)\n+  if (s(1:1) /= \"1\") call abort\n+  st = fget(s)\n+  if (s(1:1) /= \"2\") call abort\n+  st = fget(s)\n+  if ((s(1:1) /= \"3\") .or. (st /= 0)) call abort\n+  st = fget(s)\n+  if (st /= -1) call abort\n+  close (10)\n+\n+  end"}, {"sha": "bd154f1fca4b2e98dbaac16e80dfb54e383caee4", "filename": "gcc/testsuite/gfortran.dg/ftell_1.f90", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d723e5434e83d9de5271f6d1c24a694826450a8/gcc%2Ftestsuite%2Fgfortran.dg%2Fftell_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d723e5434e83d9de5271f6d1c24a694826450a8/gcc%2Ftestsuite%2Fgfortran.dg%2Fftell_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fftell_1.f90?ref=5d723e5434e83d9de5271f6d1c24a694826450a8", "patch": "@@ -0,0 +1,13 @@\n+! { dg-do run }\n+  integer*8 o\n+\n+  open (10, status=\"scratch\")\n+  call ftell (10, o)\n+  if (o /= 0) call abort\n+  write (10,\"(A)\") \"1234567\"\n+  call ftell (10, o)\n+  if (o /= 8) call abort\n+  close (10)\n+  call ftell (10, o)\n+  if (o /= -1) call abort\n+  end"}, {"sha": "1dda1fbfd789b3996a5961e66911eedfd63c11c8", "filename": "gcc/testsuite/gfortran.dg/ftell_2.f90", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d723e5434e83d9de5271f6d1c24a694826450a8/gcc%2Ftestsuite%2Fgfortran.dg%2Fftell_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d723e5434e83d9de5271f6d1c24a694826450a8/gcc%2Ftestsuite%2Fgfortran.dg%2Fftell_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fftell_2.f90?ref=5d723e5434e83d9de5271f6d1c24a694826450a8", "patch": "@@ -0,0 +1,8 @@\n+! { dg-do run }\n+  open (10, status=\"scratch\")\n+  if (ftell(10) /= 0) call abort\n+  write (10,\"(A)\") \"1234567\"\n+  if (ftell(10) /= 8) call abort\n+  close (10)\n+  if (ftell(10) /= -1) call abort\n+  end"}, {"sha": "3b6d60775ad74d24acb6b43c0737999295615c7a", "filename": "gcc/testsuite/gfortran.dg/gnu_logical_1.F", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d723e5434e83d9de5271f6d1c24a694826450a8/gcc%2Ftestsuite%2Fgfortran.dg%2Fgnu_logical_1.F", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d723e5434e83d9de5271f6d1c24a694826450a8/gcc%2Ftestsuite%2Fgfortran.dg%2Fgnu_logical_1.F", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgnu_logical_1.F?ref=5d723e5434e83d9de5271f6d1c24a694826450a8", "patch": "@@ -0,0 +1,91 @@\n+! Testcases for the AND, OR and XOR functions (GNU intrinsics).\n+! { dg-do run }\n+! { dg-options \"-ffixed-line-length-none\" }\n+      integer*1 i1, j1\n+      integer*2 i2, j2\n+      integer*4 i4, j4\n+      integer*8 i8, j8\n+      logical*1 l1, k1\n+      logical*2 l2, k2\n+      logical*4 l4, k4\n+      logical*8 l8, k8\n+\n+#define TEST_INTEGER(u,ukind,v,vkind) \\\n+      ukind = u;\\\n+      vkind = v;\\\n+      if (iand(u,v) /= and(ukind, vkind)) call abort;\\\n+      if (iand(u,v) /= and(vkind, ukind)) call abort;\\\n+      if (ieor(u,v) /= xor(ukind, vkind)) call abort;\\\n+      if (ieor(u,v) /= xor(vkind, ukind)) call abort;\\\n+      if (ior(u,v) /= or(ukind, vkind)) call abort;\\\n+      if (ior(u,v) /= or(vkind, ukind)) call abort\n+\n+      TEST_INTEGER(19,i1,6,j1)\n+      TEST_INTEGER(19,i1,6,j2)\n+      TEST_INTEGER(19,i1,6,j4)\n+      TEST_INTEGER(19,i1,6,j8)\n+\n+      TEST_INTEGER(19,i2,6,j1)\n+      TEST_INTEGER(19,i2,6,j2)\n+      TEST_INTEGER(19,i2,6,j4)\n+      TEST_INTEGER(19,i2,6,j8)\n+\n+      TEST_INTEGER(19,i4,6,j1)\n+      TEST_INTEGER(19,i4,6,j2)\n+      TEST_INTEGER(19,i4,6,j4)\n+      TEST_INTEGER(19,i4,6,j8)\n+\n+      TEST_INTEGER(19,i8,6,j1)\n+      TEST_INTEGER(19,i8,6,j2)\n+      TEST_INTEGER(19,i8,6,j4)\n+      TEST_INTEGER(19,i8,6,j8)\n+\n+\n+\n+#define TEST_LOGICAL(u,ukind,v,vkind) \\\n+      ukind = u;\\\n+      vkind = v;\\\n+      if ((u .and. v) .neqv. and(ukind, vkind)) call abort;\\\n+      if ((u .and. v) .neqv. and(vkind, ukind)) call abort;\\\n+      if (((u .and. .not. v) .or. (.not. u .and. v)) .neqv. xor(ukind, vkind)) call abort;\\\n+      if (((u .and. .not. v) .or. (.not. u .and. v)) .neqv. xor(vkind, ukind)) call abort;\\\n+      if ((u .or. v) .neqv. or(ukind, vkind)) call abort;\\\n+      if ((u .or. v) .neqv. or(vkind, ukind)) call abort\n+\n+      TEST_LOGICAL(.true.,l1,.false.,k1)\n+      TEST_LOGICAL(.true.,l1,.true.,k1)\n+      TEST_LOGICAL(.true.,l1,.false.,k2)\n+      TEST_LOGICAL(.true.,l1,.true.,k2)\n+      TEST_LOGICAL(.true.,l1,.false.,k4)\n+      TEST_LOGICAL(.true.,l1,.true.,k4)\n+      TEST_LOGICAL(.true.,l1,.false.,k8)\n+      TEST_LOGICAL(.true.,l1,.true.,k8)\n+\n+      TEST_LOGICAL(.true.,l2,.false.,k1)\n+      TEST_LOGICAL(.true.,l2,.true.,k1)\n+      TEST_LOGICAL(.true.,l2,.false.,k2)\n+      TEST_LOGICAL(.true.,l2,.true.,k2)\n+      TEST_LOGICAL(.true.,l2,.false.,k4)\n+      TEST_LOGICAL(.true.,l2,.true.,k4)\n+      TEST_LOGICAL(.true.,l2,.false.,k8)\n+      TEST_LOGICAL(.true.,l2,.true.,k8)\n+\n+      TEST_LOGICAL(.true.,l4,.false.,k1)\n+      TEST_LOGICAL(.true.,l4,.true.,k1)\n+      TEST_LOGICAL(.true.,l4,.false.,k2)\n+      TEST_LOGICAL(.true.,l4,.true.,k2)\n+      TEST_LOGICAL(.true.,l4,.false.,k4)\n+      TEST_LOGICAL(.true.,l4,.true.,k4)\n+      TEST_LOGICAL(.true.,l4,.false.,k8)\n+      TEST_LOGICAL(.true.,l4,.true.,k8)\n+\n+      TEST_LOGICAL(.true.,l8,.false.,k1)\n+      TEST_LOGICAL(.true.,l8,.true.,k1)\n+      TEST_LOGICAL(.true.,l8,.false.,k2)\n+      TEST_LOGICAL(.true.,l8,.true.,k2)\n+      TEST_LOGICAL(.true.,l8,.false.,k4)\n+      TEST_LOGICAL(.true.,l8,.true.,k4)\n+      TEST_LOGICAL(.true.,l8,.false.,k8)\n+      TEST_LOGICAL(.true.,l8,.true.,k8)\n+\n+      end"}, {"sha": "4ff70fac23917c30f9e50ed5429097c3de34d58b", "filename": "gcc/testsuite/gfortran.dg/gnu_logical_2.f90", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d723e5434e83d9de5271f6d1c24a694826450a8/gcc%2Ftestsuite%2Fgfortran.dg%2Fgnu_logical_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d723e5434e83d9de5271f6d1c24a694826450a8/gcc%2Ftestsuite%2Fgfortran.dg%2Fgnu_logical_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgnu_logical_2.f90?ref=5d723e5434e83d9de5271f6d1c24a694826450a8", "patch": "@@ -0,0 +1,29 @@\n+! Testcases for the AND, OR and XOR functions (GNU intrinsics).\n+! { dg-do compile }\n+  integer i\n+  logical l\n+  real r\n+  complex c\n+\n+  print *, and(i,i)\n+  print *, and(l,l)\n+  print *, and(i,r) ! { dg-error \"must be INTEGER or LOGICAL\" }\n+  print *, and(c,l) ! { dg-error \"must be INTEGER or LOGICAL\" }\n+  print *, and(i,l) ! { dg-error \"must have the same type\" }\n+  print *, and(l,i) ! { dg-error \"must have the same type\" }\n+\n+  print *, or(i,i)\n+  print *, or(l,l)\n+  print *, or(i,r) ! { dg-error \"must be INTEGER or LOGICAL\" }\n+  print *, or(c,l) ! { dg-error \"must be INTEGER or LOGICAL\" }\n+  print *, or(i,l) ! { dg-error \"must have the same type\" }\n+  print *, or(l,i) ! { dg-error \"must have the same type\" }\n+\n+  print *, xor(i,i)\n+  print *, xor(l,l)\n+  print *, xor(i,r) ! { dg-error \"must be INTEGER or LOGICAL\" }\n+  print *, xor(c,l) ! { dg-error \"must be INTEGER or LOGICAL\" }\n+  print *, xor(i,l) ! { dg-error \"must have the same type\" }\n+  print *, xor(l,i) ! { dg-error \"must have the same type\" }\n+\n+  end"}, {"sha": "022ae4fb14b1ec0bdb3376fca4ab6a900efb2cf8", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d723e5434e83d9de5271f6d1c24a694826450a8/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d723e5434e83d9de5271f6d1c24a694826450a8/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=5d723e5434e83d9de5271f6d1c24a694826450a8", "patch": "@@ -1,3 +1,12 @@\n+2005-11-13  Francois-Xavier Coudert  <coudert@clipper.ens.fr>\n+\n+\t* intrinsics/fget.c: New file.\n+\t* intrinsics/ftell.c: New file.\n+\t* io/unix.c (stream_offset): New function.\n+\t* io/io.h: Add prototype for stream_offset.\n+\t* Makefile.am: Add intrinsics/fget.c and intrinsics/ftell.c.\n+\t* Makefile.in: Regenerate.\n+\n 2005-11-12  Steven G. Kargl  <kargls@comcast.net>\n \n \tPR libgfortran/24787"}, {"sha": "4fdb4b3511e323665f91f71457356e5017cc2320", "filename": "libgfortran/Makefile.am", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d723e5434e83d9de5271f6d1c24a694826450a8/libgfortran%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d723e5434e83d9de5271f6d1c24a694826450a8/libgfortran%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FMakefile.am?ref=5d723e5434e83d9de5271f6d1c24a694826450a8", "patch": "@@ -53,8 +53,10 @@ intrinsics/eoshift0.c \\\n intrinsics/eoshift2.c \\\n intrinsics/etime.c \\\n intrinsics/exit.c \\\n+intrinsics/fget.c \\\n intrinsics/flush.c \\\n intrinsics/fnum.c \\\n+intrinsics/ftell.c \\\n intrinsics/gerror.c \\\n intrinsics/getcwd.c \\\n intrinsics/getlog.c \\"}, {"sha": "a8a37f54d8c17d442676be180976d97d014976c4", "filename": "libgfortran/Makefile.in", "status": "modified", "additions": 18, "deletions": 10, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d723e5434e83d9de5271f6d1c24a694826450a8/libgfortran%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d723e5434e83d9de5271f6d1c24a694826450a8/libgfortran%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FMakefile.in?ref=5d723e5434e83d9de5271f6d1c24a694826450a8", "patch": "@@ -167,16 +167,16 @@ am__objects_32 = close.lo file_pos.lo format.lo inquire.lo \\\n am__objects_33 = associated.lo abort.lo args.lo bessel.lo \\\n \tc99_functions.lo chdir.lo cpu_time.lo cshift0.lo ctime.lo \\\n \tdate_and_time.lo env.lo erf.lo eoshift0.lo eoshift2.lo \\\n-\tetime.lo exit.lo flush.lo fnum.lo gerror.lo getcwd.lo \\\n-\tgetlog.lo getXid.lo hyper.lo hostnm.lo kill.lo ierrno.lo \\\n-\tishftc.lo link.lo malloc.lo mvbits.lo pack_generic.lo \\\n-\tperror.lo signal.lo size.lo sleep.lo spread_generic.lo \\\n-\tstring_intrinsics.lo system.lo rand.lo random.lo rename.lo \\\n-\treshape_generic.lo reshape_packed.lo selected_int_kind.lo \\\n-\tselected_real_kind.lo stat.lo symlnk.lo system_clock.lo \\\n-\ttime.lo transpose_generic.lo tty.lo umask.lo unlink.lo \\\n-\tunpack_generic.lo in_pack_generic.lo in_unpack_generic.lo \\\n-\tnormalize.lo\n+\tetime.lo exit.lo fget.lo flush.lo fnum.lo ftell.lo gerror.lo \\\n+\tgetcwd.lo getlog.lo getXid.lo hyper.lo hostnm.lo kill.lo \\\n+\tierrno.lo ishftc.lo link.lo malloc.lo mvbits.lo \\\n+\tpack_generic.lo perror.lo signal.lo size.lo sleep.lo \\\n+\tspread_generic.lo string_intrinsics.lo system.lo rand.lo \\\n+\trandom.lo rename.lo reshape_generic.lo reshape_packed.lo \\\n+\tselected_int_kind.lo selected_real_kind.lo stat.lo symlnk.lo \\\n+\tsystem_clock.lo time.lo transpose_generic.lo tty.lo umask.lo \\\n+\tunlink.lo unpack_generic.lo in_pack_generic.lo \\\n+\tin_unpack_generic.lo normalize.lo\n am__objects_34 =\n am__objects_35 = _abs_c4.lo _abs_c8.lo _abs_c10.lo _abs_c16.lo \\\n \t_abs_i4.lo _abs_i8.lo _abs_i16.lo _abs_r4.lo _abs_r8.lo \\\n@@ -394,8 +394,10 @@ intrinsics/eoshift0.c \\\n intrinsics/eoshift2.c \\\n intrinsics/etime.c \\\n intrinsics/exit.c \\\n+intrinsics/fget.c \\\n intrinsics/flush.c \\\n intrinsics/fnum.c \\\n+intrinsics/ftell.c \\\n intrinsics/gerror.c \\\n intrinsics/getcwd.c \\\n intrinsics/getlog.c \\\n@@ -2264,12 +2266,18 @@ etime.lo: intrinsics/etime.c\n exit.lo: intrinsics/exit.c\n \t$(LIBTOOL) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o exit.lo `test -f 'intrinsics/exit.c' || echo '$(srcdir)/'`intrinsics/exit.c\n \n+fget.lo: intrinsics/fget.c\n+\t$(LIBTOOL) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o fget.lo `test -f 'intrinsics/fget.c' || echo '$(srcdir)/'`intrinsics/fget.c\n+\n flush.lo: intrinsics/flush.c\n \t$(LIBTOOL) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o flush.lo `test -f 'intrinsics/flush.c' || echo '$(srcdir)/'`intrinsics/flush.c\n \n fnum.lo: intrinsics/fnum.c\n \t$(LIBTOOL) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o fnum.lo `test -f 'intrinsics/fnum.c' || echo '$(srcdir)/'`intrinsics/fnum.c\n \n+ftell.lo: intrinsics/ftell.c\n+\t$(LIBTOOL) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o ftell.lo `test -f 'intrinsics/ftell.c' || echo '$(srcdir)/'`intrinsics/ftell.c\n+\n gerror.lo: intrinsics/gerror.c\n \t$(LIBTOOL) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o gerror.lo `test -f 'intrinsics/gerror.c' || echo '$(srcdir)/'`intrinsics/gerror.c\n "}, {"sha": "8eb96e3b98d8c0bd8b74d7d67670d3231a8096fa", "filename": "libgfortran/intrinsics/fget.c", "status": "added", "additions": 173, "deletions": 0, "changes": 173, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d723e5434e83d9de5271f6d1c24a694826450a8/libgfortran%2Fintrinsics%2Ffget.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d723e5434e83d9de5271f6d1c24a694826450a8/libgfortran%2Fintrinsics%2Ffget.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fintrinsics%2Ffget.c?ref=5d723e5434e83d9de5271f6d1c24a694826450a8", "patch": "@@ -0,0 +1,173 @@\n+/* Implementation of the FGET, FGETC, FPUT and FPUTC intrinsics.\n+   Copyright (C) 2005 Free Software Foundation, Inc.\n+   Contributed by Fran\u00e7ois-Xavier Coudert <coudert@clipper.ens.fr>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"config.h\"\n+#include \"libgfortran.h\"\n+\n+#include <string.h>\n+\n+#include \"../io/io.h\"\n+\n+static const int five = 5;\n+static const int six = 6;\n+\n+extern int PREFIX(fgetc) (const int *, char *, gfc_charlen_type);\n+export_proto_np(PREFIX(fgetc));\n+\n+int\n+PREFIX(fgetc) (const int * unit, char * c, gfc_charlen_type c_len)\n+{\n+  int ret;\n+  size_t s;\n+  gfc_unit * u = find_unit (*unit);\n+\n+  if (u == NULL)\n+    return -1;\n+\n+  s = 1;\n+  memset (c, ' ', c_len);\n+  ret = sread (u->s, c, &s);\n+\n+  if (ret != 0)\n+    return ret;\n+\n+  if (s != 1)\n+    return -1;\n+  else\n+    return 0;\n+}\n+\n+\n+#define FGETC_SUB(kind) \\\n+  extern void fgetc_i ## kind ## _sub \\\n+    (const int *, char *, GFC_INTEGER_ ## kind *, gfc_charlen_type); \\\n+  export_proto(fgetc_i ## kind ## _sub); \\\n+  void fgetc_i ## kind ## _sub \\\n+  (const int * unit, char * c, GFC_INTEGER_ ## kind * st, gfc_charlen_type c_len) \\\n+    { if (st != NULL) \\\n+        *st = PREFIX(fgetc) (unit, c, c_len); \\\n+      else \\\n+        PREFIX(fgetc) (unit, c, c_len); }\n+\n+FGETC_SUB(1)\n+FGETC_SUB(2)\n+FGETC_SUB(4)\n+FGETC_SUB(8)\n+\n+\n+extern int PREFIX(fget) (char *, gfc_charlen_type);\n+export_proto_np(PREFIX(fget));\n+\n+int\n+PREFIX(fget) (char * c, gfc_charlen_type c_len)\n+{\n+  return PREFIX(fgetc) (&five, c, c_len);\n+}\n+\n+\n+#define FGET_SUB(kind) \\\n+  extern void fget_i ## kind ## _sub \\\n+    (char *, GFC_INTEGER_ ## kind *, gfc_charlen_type); \\\n+  export_proto(fget_i ## kind ## _sub); \\\n+  void fget_i ## kind ## _sub \\\n+  (char * c, GFC_INTEGER_ ## kind * st, gfc_charlen_type c_len) \\\n+    { if (st != NULL) \\\n+        *st = PREFIX(fgetc) (&five, c, c_len); \\\n+      else \\\n+        PREFIX(fgetc) (&five, c, c_len); }\n+\n+FGET_SUB(1)\n+FGET_SUB(2)\n+FGET_SUB(4)\n+FGET_SUB(8)\n+\n+\n+\n+extern int PREFIX(fputc) (const int *, char *, gfc_charlen_type);\n+export_proto_np(PREFIX(fputc));\n+\n+int\n+PREFIX(fputc) (const int * unit, char * c,\n+\t       gfc_charlen_type c_len __attribute__((unused)))\n+{\n+  size_t s;\n+  gfc_unit * u = find_unit (*unit);\n+\n+  if (u == NULL)\n+    return -1;\n+\n+  s = 1;\n+  return swrite (u->s, c, &s);\n+}\n+\n+\n+#define FPUTC_SUB(kind) \\\n+  extern void fputc_i ## kind ## _sub \\\n+    (const int *, char *, GFC_INTEGER_ ## kind *, gfc_charlen_type); \\\n+  export_proto(fputc_i ## kind ## _sub); \\\n+  void fputc_i ## kind ## _sub \\\n+  (const int * unit, char * c, GFC_INTEGER_ ## kind * st, gfc_charlen_type c_len) \\\n+    { if (st != NULL) \\\n+        *st = PREFIX(fputc) (unit, c, c_len); \\\n+      else \\\n+        PREFIX(fputc) (unit, c, c_len); }\n+\n+FPUTC_SUB(1)\n+FPUTC_SUB(2)\n+FPUTC_SUB(4)\n+FPUTC_SUB(8)\n+\n+\n+extern int PREFIX(fput) (char *, gfc_charlen_type);\n+export_proto_np(PREFIX(fput));\n+\n+int\n+PREFIX(fput) (char * c, gfc_charlen_type c_len)\n+{\n+  return PREFIX(fputc) (&six, c, c_len);\n+}\n+\n+\n+#define FPUT_SUB(kind) \\\n+  extern void fput_i ## kind ## _sub \\\n+    (char *, GFC_INTEGER_ ## kind *, gfc_charlen_type); \\\n+  export_proto(fput_i ## kind ## _sub); \\\n+  void fput_i ## kind ## _sub \\\n+  (char * c, GFC_INTEGER_ ## kind * st, gfc_charlen_type c_len) \\\n+    { if (st != NULL) \\\n+        *st = PREFIX(fputc) (&six, c, c_len); \\\n+      else \\\n+        PREFIX(fputc) (&six, c, c_len); }\n+\n+FPUT_SUB(1)\n+FPUT_SUB(2)\n+FPUT_SUB(4)\n+FPUT_SUB(8)\n+"}, {"sha": "16cf275c4dc616513b2bc39bf304b029493bda36", "filename": "libgfortran/intrinsics/ftell.c", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d723e5434e83d9de5271f6d1c24a694826450a8/libgfortran%2Fintrinsics%2Fftell.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d723e5434e83d9de5271f6d1c24a694826450a8/libgfortran%2Fintrinsics%2Fftell.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fintrinsics%2Fftell.c?ref=5d723e5434e83d9de5271f6d1c24a694826450a8", "patch": "@@ -0,0 +1,67 @@\n+/* Implementation of the FTELL intrinsic.\n+   Copyright (C) 2005 Free Software Foundation, Inc.\n+   Contributed by Fran\u00e7ois-Xavier Coudert <coudert@clipper.ens.fr>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"config.h\"\n+#include \"libgfortran.h\"\n+\n+#include <string.h>\n+\n+#include \"../io/io.h\"\n+\n+extern size_t PREFIX(ftell) (int *);\n+export_proto_np(PREFIX(ftell));\n+\n+size_t\n+PREFIX(ftell) (int * unit)\n+{\n+  gfc_unit * u = find_unit (*unit);\n+  if (u == NULL)\n+    return ((size_t) -1);\n+  else\n+    return ((size_t) stream_offset (u->s));\n+}\n+\n+#define FTELL_SUB(kind) \\\n+  extern void ftell_i ## kind ## _sub (int *, GFC_INTEGER_ ## kind *); \\\n+  export_proto(ftell_i ## kind ## _sub); \\\n+  void \\\n+  ftell_i ## kind ## _sub (int * unit, GFC_INTEGER_ ## kind * offset) \\\n+  { \\\n+    gfc_unit * u = find_unit (*unit); \\\n+    if (u == NULL) \\\n+      *offset = -1; \\\n+    else \\\n+      *offset = stream_offset (u->s); \\\n+  }\n+\n+FTELL_SUB(1)\n+FTELL_SUB(2)\n+FTELL_SUB(4)\n+FTELL_SUB(8)"}, {"sha": "e26267720e1acd345eaf007953409dce62aefc32", "filename": "libgfortran/io/io.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d723e5434e83d9de5271f6d1c24a694826450a8/libgfortran%2Fio%2Fio.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d723e5434e83d9de5271f6d1c24a694826450a8/libgfortran%2Fio%2Fio.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fio.h?ref=5d723e5434e83d9de5271f6d1c24a694826450a8", "patch": "@@ -520,6 +520,9 @@ internal_proto(stream_isatty);\n extern char * stream_ttyname (stream *);\n internal_proto(stream_ttyname);\n \n+extern gfc_offset stream_offset (stream *s);\n+internal_proto(stream_offset);\n+\n extern int unit_to_fd (int);\n internal_proto(unit_to_fd);\n "}, {"sha": "2f08aad27afcffb637198dae0e6909f758b5d3b2", "filename": "libgfortran/io/unix.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d723e5434e83d9de5271f6d1c24a694826450a8/libgfortran%2Fio%2Funix.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d723e5434e83d9de5271f6d1c24a694826450a8/libgfortran%2Fio%2Funix.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Funix.c?ref=5d723e5434e83d9de5271f6d1c24a694826450a8", "patch": "@@ -1640,6 +1640,12 @@ stream_ttyname (stream *s)\n #endif\n }\n \n+gfc_offset\n+stream_offset (stream *s)\n+{\n+  return (((unix_stream *) s)->logical_offset);\n+}\n+\n \n /* How files are stored:  This is an operating-system specific issue,\n    and therefore belongs here.  There are three cases to consider."}]}