{"sha": "14aeb3cd27717e1dd11ad5044e738a350e7d946b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTRhZWIzY2QyNzcxN2UxZGQxMWFkNTA0NGU3MzhhMzUwZTdkOTQ2Yg==", "commit": {"author": {"name": "Mikael Morin", "email": "mikael@gcc.gnu.org", "date": "2015-05-09T13:36:14Z"}, "committer": {"name": "Mikael Morin", "email": "mikael@gcc.gnu.org", "date": "2015-05-09T13:36:14Z"}, "message": "Fix fortran/65894 elemental procedures wrong-code\n\ngcc/fortran/\n2015-05-09  Mikael Morin  <mikael@gcc.gnu.org>\n\n\tPR fortran/65894\n\t* trans-array.h (gfc_scalar_elemental_arg_saved_as_reference):\n\tNew prototype.\n\t* trans-array.c (gfc_scalar_elemental_arg_saved_as_reference):\n\tNew function.\n\t(gfc_add_loop_ss_code): Use gfc_scalar_elemental_arg_saved_as_reference\n\tas conditional.\n\t(gfc_walk_elemental_function_args): Set the dummy_arg field.\n\t* trans.h (gfc_ss_info): New subfield dummy_arg.\n\t* trans-expr.c (gfc_conv_procedure_call): Revert the change\n\tof revision 222361.\n\t(gfc_conv_expr): Use gfc_scalar_elemental_arg_saved_as_reference\n\tas conditional.\n\ngcc/testsuite/\n2015-05-09  Andre Vehreschild  <vehre@gmx.de>\n\n\tPR fortran/65894\n\t* gfortran.dg/elemental_subroutine_11.f90: New test.\n\nFrom-SVN: r222968", "tree": {"sha": "fff70f7f0c28192df8e62ca16e07ccec8557141d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fff70f7f0c28192df8e62ca16e07ccec8557141d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/14aeb3cd27717e1dd11ad5044e738a350e7d946b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/14aeb3cd27717e1dd11ad5044e738a350e7d946b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/14aeb3cd27717e1dd11ad5044e738a350e7d946b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/14aeb3cd27717e1dd11ad5044e738a350e7d946b/comments", "author": null, "committer": null, "parents": [{"sha": "1f0e2688af26e66efa9db498d6db01760832fee3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f0e2688af26e66efa9db498d6db01760832fee3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1f0e2688af26e66efa9db498d6db01760832fee3"}], "stats": {"total": 346, "additions": 317, "deletions": 29}, "files": [{"sha": "9c952a1012b97942b683eb28308f79ec2c6ff372", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14aeb3cd27717e1dd11ad5044e738a350e7d946b/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14aeb3cd27717e1dd11ad5044e738a350e7d946b/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=14aeb3cd27717e1dd11ad5044e738a350e7d946b", "patch": "@@ -1,3 +1,19 @@\n+2015-05-09  Mikael Morin  <mikael@gcc.gnu.org>\n+\n+\tPR fortran/65894\n+\t* trans-array.h (gfc_scalar_elemental_arg_saved_as_reference):\n+\tNew prototype.\n+\t* trans-array.c (gfc_scalar_elemental_arg_saved_as_reference):\n+\tNew function.\n+\t(gfc_add_loop_ss_code): Use gfc_scalar_elemental_arg_saved_as_reference\n+\tas conditional.\n+\t(gfc_walk_elemental_function_args): Set the dummy_arg field.\n+\t* trans.h (gfc_ss_info): New subfield dummy_arg.\n+\t* trans-expr.c (gfc_conv_procedure_call): Revert the change\n+\tof revision 222361.\n+\t(gfc_conv_expr): Use gfc_scalar_elemental_arg_saved_as_reference\n+\tas conditional.\n+\n 2015-05-08  Mikael Morin  <mikael@gcc.gnu.org>\n \n \t* trans-array.c (gfc_walk_elemental_function_args):"}, {"sha": "8267f6a41f9bbaf468aa93712a57ca7b320ed473", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 40, "deletions": 12, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14aeb3cd27717e1dd11ad5044e738a350e7d946b/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14aeb3cd27717e1dd11ad5044e738a350e7d946b/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=14aeb3cd27717e1dd11ad5044e738a350e7d946b", "patch": "@@ -2427,6 +2427,41 @@ set_vector_loop_bounds (gfc_ss * ss)\n }\n \n \n+/* Tells whether a scalar argument to an elemental procedure is saved out\n+   of a scalarization loop as a value or as a reference.  */\n+\n+bool\n+gfc_scalar_elemental_arg_saved_as_reference (gfc_ss_info * ss_info)\n+{\n+  if (ss_info->type != GFC_SS_REFERENCE)\n+    return false;\n+\n+  /* If the actual argument can be absent (in other words, it can\n+     be a NULL reference), don't try to evaluate it; pass instead\n+     the reference directly.  */\n+  if (ss_info->can_be_null_ref)\n+    return true;\n+\n+  /* If the expression is of polymorphic type, it's actual size is not known,\n+     so we avoid copying it anywhere.  */\n+  if (ss_info->data.scalar.dummy_arg\n+      && ss_info->data.scalar.dummy_arg->ts.type == BT_CLASS\n+      && ss_info->expr->ts.type == BT_CLASS)\n+    return true;\n+\n+  /* If the expression is a data reference of aggregate type,\n+     avoid a copy by saving a reference to the content.  */\n+  if (ss_info->expr->expr_type == EXPR_VARIABLE\n+      && (ss_info->expr->ts.type == BT_DERIVED\n+\t  || ss_info->expr->ts.type == BT_CLASS))\n+    return true;\n+\n+  /* Otherwise the expression is evaluated to a temporary variable before the\n+     scalarization loop.  */\n+  return false;\n+}\n+\n+\n /* Add the pre and post chains for all the scalar expressions in a SS chain\n    to loop.  This is called after the loop parameters have been calculated,\n    but before the actual scalarizing loops.  */\n@@ -2495,19 +2530,11 @@ gfc_add_loop_ss_code (gfc_loopinfo * loop, gfc_ss * ss, bool subscript,\n \tcase GFC_SS_REFERENCE:\n \t  /* Scalar argument to elemental procedure.  */\n \t  gfc_init_se (&se, NULL);\n-\t  if (ss_info->can_be_null_ref || (expr->symtree\n-\t\t\t     && (expr->symtree->n.sym->ts.type == BT_DERIVED\n-\t\t\t\t || expr->symtree->n.sym->ts.type == BT_CLASS)))\n-\t    {\n-\t      /* If the actual argument can be absent (in other words, it can\n-\t\t be a NULL reference), don't try to evaluate it; pass instead\n-\t\t the reference directly.  The reference is also needed when\n-\t\t expr is of type class or derived.  */\n-\t      gfc_conv_expr_reference (&se, expr);\n-\t    }\n+\t  if (gfc_scalar_elemental_arg_saved_as_reference (ss_info))\n+\t    gfc_conv_expr_reference (&se, expr);\n \t  else\n \t    {\n-\t      /* Otherwise, evaluate the argument outside the loop and pass\n+\t      /* Evaluate the argument outside the loop and pass\n \t\t a reference to the value.  */\n \t      gfc_conv_expr (&se, expr);\n \t    }\n@@ -9101,7 +9128,8 @@ gfc_walk_elemental_function_args (gfc_ss * ss, gfc_actual_arglist *arg,\n \t  gcc_assert (type == GFC_SS_SCALAR || type == GFC_SS_REFERENCE);\n \t  newss = gfc_get_scalar_ss (head, arg->expr);\n \t  newss->info->type = type;\n-\n+\t  if (dummy_arg)\n+\t    newss->info->data.scalar.dummy_arg = dummy_arg->sym;\n \t}\n       else\n \tscalar = 0;"}, {"sha": "2155b58ba8e319b2fd4161374563d52b41f5380a", "filename": "gcc/fortran/trans-array.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14aeb3cd27717e1dd11ad5044e738a350e7d946b/gcc%2Ffortran%2Ftrans-array.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14aeb3cd27717e1dd11ad5044e738a350e7d946b/gcc%2Ffortran%2Ftrans-array.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.h?ref=14aeb3cd27717e1dd11ad5044e738a350e7d946b", "patch": "@@ -103,6 +103,8 @@ gfc_ss *gfc_get_temp_ss (tree, tree, int);\n /* Allocate a new scalar type ss.  */\n gfc_ss *gfc_get_scalar_ss (gfc_ss *, gfc_expr *);\n \n+bool gfc_scalar_elemental_arg_saved_as_reference (gfc_ss_info *);\n+\n /* Calculates the lower bound and stride of array sections.  */\n void gfc_conv_ss_startstride (gfc_loopinfo *);\n "}, {"sha": "c71037f7b9a465c8e6ae102a3f09fc98e87efcd4", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 3, "deletions": 17, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14aeb3cd27717e1dd11ad5044e738a350e7d946b/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14aeb3cd27717e1dd11ad5044e738a350e7d946b/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=14aeb3cd27717e1dd11ad5044e738a350e7d946b", "patch": "@@ -4735,19 +4735,7 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t  gfc_init_se (&parmse, se);\n \t  parm_kind = ELEMENTAL;\n \n-\t  /* For all value functions or polymorphic scalar non-pointer\n-\t     non-allocatable variables use the expression in e directly.  This\n-\t     ensures, that initializers of polymorphic entities are correctly\n-\t     copied.  */\n-\t  if (fsym && (fsym->attr.value\n-\t\t       || (e->expr_type == EXPR_VARIABLE\n-\t\t\t   && fsym->ts.type == BT_DERIVED\n-\t\t\t   && e->ts.type == BT_DERIVED\n-\t\t\t   && !e->ts.u.derived->attr.dimension\n-\t\t\t   && !e->rank\n-\t\t\t   && (!e->symtree\n-\t\t\t       || (!e->symtree->n.sym->attr.allocatable\n-\t\t\t\t   && !e->symtree->n.sym->attr.pointer)))))\n+\t  if (fsym && fsym->attr.value)\n \t    gfc_conv_expr (&parmse, e);\n \t  else\n \t    gfc_conv_expr_reference (&parmse, e);\n@@ -7310,11 +7298,9 @@ gfc_conv_expr (gfc_se * se, gfc_expr * expr)\n \n       ss_info = ss->info;\n       /* Substitute a scalar expression evaluated outside the scalarization\n-         loop.  */\n+\t loop.  */\n       se->expr = ss_info->data.scalar.value;\n-      /* If the reference can be NULL, the value field contains the reference,\n-\t not the value the reference points to (see gfc_add_loop_ss_code).  */\n-      if (ss_info->can_be_null_ref)\n+      if (gfc_scalar_elemental_arg_saved_as_reference (ss_info))\n \tse->expr = build_fold_indirect_ref_loc (input_location, se->expr);\n \n       se->string_length = ss_info->string_length;"}, {"sha": "570b5b88e30d88d17cb469c3d10a140086af7dd0", "filename": "gcc/fortran/trans.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14aeb3cd27717e1dd11ad5044e738a350e7d946b/gcc%2Ffortran%2Ftrans.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14aeb3cd27717e1dd11ad5044e738a350e7d946b/gcc%2Ffortran%2Ftrans.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.h?ref=14aeb3cd27717e1dd11ad5044e738a350e7d946b", "patch": "@@ -206,6 +206,9 @@ typedef struct gfc_ss_info\n     /* If type is GFC_SS_SCALAR or GFC_SS_REFERENCE.  */\n     struct\n     {\n+      /* If the scalar is passed as actual argument to an (elemental) procedure,\n+\t this is the symbol of the corresponding dummy argument.  */\n+      gfc_symbol *dummy_arg;\n       tree value;\n     }\n     scalar;"}, {"sha": "d3beeb9ce9f803dceb21587124d47146ecab6c33", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14aeb3cd27717e1dd11ad5044e738a350e7d946b/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14aeb3cd27717e1dd11ad5044e738a350e7d946b/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=14aeb3cd27717e1dd11ad5044e738a350e7d946b", "patch": "@@ -1,3 +1,8 @@\n+2015-05-09  Andre Vehreschild  <vehre@gmx.de>\n+\n+\tPR fortran/65894\n+\t* gfortran.dg/elemental_subroutine_11.f90: New test.\n+\n 2015-05-08  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/66036"}, {"sha": "02ac7c7251bbf907b2aaa7a0025034f7bec369f6", "filename": "gcc/testsuite/gfortran.dg/elemental_subroutine_11.f90", "status": "added", "additions": 248, "deletions": 0, "changes": 248, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14aeb3cd27717e1dd11ad5044e738a350e7d946b/gcc%2Ftestsuite%2Fgfortran.dg%2Felemental_subroutine_11.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14aeb3cd27717e1dd11ad5044e738a350e7d946b/gcc%2Ftestsuite%2Fgfortran.dg%2Felemental_subroutine_11.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Felemental_subroutine_11.f90?ref=14aeb3cd27717e1dd11ad5044e738a350e7d946b", "patch": "@@ -0,0 +1,248 @@\n+! { dg-do run }\n+!\n+! Check error of pr65894 are fixed.\n+! Contributed by Juergen Reuter  <juergen.reuter@desy.de>\n+!                Andre Vehreschild  <vehre@gcc.gnu.org>\n+\n+module simple_string\n+  ! Minimal iso_varying_string implementation needed.\n+  implicit none\n+\n+  type string_t\n+    private\n+    character(len=1), dimension(:), allocatable :: cs\n+  end type string_t\n+\n+contains\n+  elemental function var_str(c) result (s)\n+    character(*), intent(in) :: c\n+    type(string_t) :: s\n+    integer :: l,i\n+\n+    l = len(c)\n+    allocate(s%cs(l))\n+    forall(i = 1:l)\n+      s%cs(i) = c(i:i)\n+    end forall\n+  end function var_str\n+\n+end module simple_string\n+module model_data\n+  use simple_string\n+\n+  implicit none\n+  private\n+\n+  public :: field_data_t\n+  public :: model_data_t\n+\n+  type :: field_data_t\n+     !private\n+     integer :: pdg = 0\n+     type(string_t), dimension(:), allocatable :: name\n+   contains\n+     procedure :: init => field_data_init\n+     procedure :: get_pdg => field_data_get_pdg\n+  end type field_data_t\n+\n+  type :: model_data_t\n+     !private\n+     type(string_t) :: name\n+     type(field_data_t), dimension(:), allocatable :: field\n+   contains\n+     generic :: init => model_data_init\n+     procedure, private :: model_data_init\n+     generic :: get_pdg => &\n+          model_data_get_field_pdg_index\n+     procedure, private :: model_data_get_field_pdg_index\n+     generic :: get_field_ptr => &\n+          model_data_get_field_ptr_pdg\n+     procedure, private :: model_data_get_field_ptr_pdg\n+     procedure :: get_field_ptr_by_index => model_data_get_field_ptr_index\n+     procedure :: init_sm_test => model_data_init_sm_test\n+  end type model_data_t\n+\n+contains\n+\n+  subroutine field_data_init (prt, pdg)\n+    class(field_data_t), intent(out) :: prt\n+    integer, intent(in) :: pdg\n+    prt%pdg = pdg\n+  end subroutine field_data_init\n+\n+  elemental function field_data_get_pdg (prt) result (pdg)\n+    integer :: pdg\n+    class(field_data_t), intent(in) :: prt\n+    pdg = prt%pdg\n+  end function field_data_get_pdg\n+\n+  subroutine model_data_init (model, name, &\n+       n_field)\n+    class(model_data_t), intent(out) :: model\n+    type(string_t), intent(in) :: name\n+    integer, intent(in) :: n_field\n+    model%name = name\n+    allocate (model%field (n_field))\n+  end subroutine model_data_init\n+\n+  function model_data_get_field_pdg_index (model, i) result (pdg)\n+    class(model_data_t), intent(in) :: model\n+    integer, intent(in) :: i\n+    integer :: pdg\n+    pdg = model%field(i)%get_pdg ()\n+  end function model_data_get_field_pdg_index\n+\n+  function model_data_get_field_ptr_pdg (model, pdg, check) result (ptr)\n+    class(model_data_t), intent(in), target :: model\n+    integer, intent(in) :: pdg\n+    logical, intent(in), optional :: check\n+    type(field_data_t), pointer :: ptr\n+    integer :: i, pdg_abs\n+    if (pdg == 0) then\n+       ptr => null ()\n+       return\n+    end if\n+    pdg_abs = abs (pdg)\n+    if (lbound(model%field, 1) /= 1) call abort()\n+    if (ubound(model%field, 1) /= 19) call abort()\n+    do i = 1, size (model%field)\n+       if (model%field(i)%get_pdg () == pdg_abs) then\n+          ptr => model%field(i)\n+          return\n+       end if\n+    end do\n+    ptr => null ()\n+  end function model_data_get_field_ptr_pdg\n+\n+  function model_data_get_field_ptr_index (model, i) result (ptr)\n+    class(model_data_t), intent(in), target :: model\n+    integer, intent(in) :: i\n+    type(field_data_t), pointer :: ptr\n+    if (lbound(model%field, 1) /= 1) call abort()\n+    if (ubound(model%field, 1) /= 19) call abort()\n+    ptr => model%field(i)\n+  end function model_data_get_field_ptr_index\n+\n+  subroutine model_data_init_sm_test (model)\n+    class(model_data_t), intent(out) :: model\n+    type(field_data_t), pointer :: field\n+    integer, parameter :: n_field = 19\n+    call model%init (var_str (\"SM_test\"), &\n+         n_field)\n+    field => model%get_field_ptr_by_index (1)\n+    call field%init (1)\n+  end subroutine model_data_init_sm_test\n+\n+end module model_data\n+\n+module flavors\n+  use model_data\n+\n+  implicit none\n+  private\n+\n+  public :: flavor_t\n+\n+  type :: flavor_t\n+     private\n+     integer :: f = 0\n+     type(field_data_t), pointer :: field_data => null ()\n+   contains\n+     generic :: init => &\n+          flavor_init0_model\n+     procedure, private :: flavor_init0_model\n+  end type flavor_t\n+\n+contains\n+\n+  impure elemental subroutine flavor_init0_model (flv, f, model)\n+    class(flavor_t), intent(inout) :: flv\n+    integer, intent(in) :: f\n+    class(model_data_t), intent(in), target :: model\n+    ! Check the field l/ubound at various stages, because w/o the patch\n+    ! the bounds get mixed up.\n+    if (lbound(model%field, 1) /= 1) call abort()\n+    if (ubound(model%field, 1) /= 19) call abort()\n+    flv%f = f\n+    flv%field_data => model%get_field_ptr (f, check=.true.)\n+  end subroutine flavor_init0_model\n+end module flavors\n+\n+module beams\n+  use model_data\n+  use flavors\n+  implicit none\n+  private\n+  public :: beam_1\n+  public :: beam_2\n+contains\n+  subroutine beam_1 (u)\n+    integer, intent(in) :: u\n+    type(flavor_t), dimension(2) :: flv\n+    real, dimension(2) :: pol_f\n+    type(model_data_t), target :: model\n+    call model%init_sm_test ()\n+    call flv%init ([1,-1], model)\n+    pol_f(1) = 0.5\n+  end subroutine beam_1\n+  subroutine beam_2 (u, model)\n+    integer, intent(in) :: u\n+    type(flavor_t), dimension(2) :: flv\n+    real, dimension(2) :: pol_f\n+    class(model_data_t), intent(in), target :: model\n+    call flv%init ([1,-1], model)\n+    pol_f(1) = 0.5\n+  end subroutine beam_2\n+end module beams\n+\n+module evaluators\n+  ! This module is just here for a compile check.\n+  implicit none\n+  private\n+  type :: quantum_numbers_mask_t\n+   contains\n+     generic :: operator(.or.) => quantum_numbers_mask_or\n+     procedure, private :: quantum_numbers_mask_or\n+  end type quantum_numbers_mask_t\n+\n+  type :: index_map_t\n+     integer, dimension(:), allocatable :: entry\n+  end type index_map_t\n+  type :: prt_mask_t\n+     logical, dimension(:), allocatable :: entry\n+  end type prt_mask_t\n+  type :: qn_mask_array_t\n+     type(quantum_numbers_mask_t), dimension(:), allocatable :: mask\n+  end type qn_mask_array_t\n+\n+contains\n+  elemental function quantum_numbers_mask_or (mask1, mask2) result (mask)\n+    type(quantum_numbers_mask_t) :: mask\n+    class(quantum_numbers_mask_t), intent(in) :: mask1, mask2\n+  end function quantum_numbers_mask_or\n+\n+  subroutine make_product_interaction &\n+      (prt_is_connected, qn_mask_in, qn_mask_rest)\n+    type(prt_mask_t), dimension(2), intent(in) :: prt_is_connected\n+    type(qn_mask_array_t), dimension(2), intent(in) :: qn_mask_in\n+    type(quantum_numbers_mask_t), intent(in) :: qn_mask_rest\n+    type(index_map_t), dimension(2) :: prt_index_in\n+    integer :: i\n+    type(quantum_numbers_mask_t), dimension(:), allocatable :: qn_mask\n+    allocate (qn_mask (2))\n+    do i = 1, 2\n+       qn_mask(prt_index_in(i)%entry) = &\n+            pack (qn_mask_in(i)%mask, prt_is_connected(i)%entry) &\n+            .or. qn_mask_rest\n+      ! Without the patch above line produced an ICE.\n+    end do\n+  end subroutine make_product_interaction\n+end module evaluators\n+program main\n+  use beams\n+  use model_data\n+  type(model_data_t) :: model\n+  call model%init_sm_test()\n+  call beam_1 (6)\n+  call beam_2 (6, model)\n+end program main"}]}