{"sha": "8179efe00e04285184112de7dbb977a75852197c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODE3OWVmZTAwZTA0Mjg1MTg0MTEyZGU3ZGJiOTc3YTc1ODUyMTk3Yw==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2018-02-01T11:04:00Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2018-02-01T11:04:00Z"}, "message": "[AArch64] Prefer LD1RQ for big-endian SVE\n\nThis patch deals with cases in which a CONST_VECTOR contains a\nrepeating bit pattern that is wider than one element but narrower\nthan 128 bits.  The current code:\n\n* treats the repeating pattern as a single element\n* uses the associated LD1R to load and replicate it (such as LD1RD\n  for 64-bit patterns)\n* uses a subreg to cast the result back to the original vector type\n\nThe problem is that for big-endian targets, the final cast is\neffectively a form of element reverse.  E.g. say we're using LD1RD to load\n16-bit elements, with h being the high parts and l being the low parts:\n\n                               +-----+-----+-----+-----+-----+----\n                         lanes |  0  |  1  |  2  |  3  |  4  | ...\n                               +-----+-----+-----+-----+-----+----\n     memory              bytes |h0 l0 h1 l1 h2 l2 h3 l3 h0 l0 ....\n                               +----------------------------------\n                                 V  V  V  V  V  V  V  V\n                     ----------+-----------------------+\n    register         ....      |           0           |\n     after           ----------+-----------------------+  lsb\n     LD1RD           .... h3 l3 h0 l0 h1 l1 h2 l2 h3 l3|\n                     ----------------------------------+\n\n                     ----+-----+-----+-----+-----+-----+\n    expected         ... |  4  |  3  |  2  |  1  |  0  |\n    register         ----+-----+-----+-----+-----+-----+  lsb\n    contents         .... h0 l0 h3 l3 h2 l2 h1 l1 h0 l0|\n                     ----------------------------------+\n\nA later patch fixes the handling of general subregs to account\nfor this, but it means that we need to do a REV instruction\nafter the load.  It seems better to use LD1RQ[BHW] on a 128-bit\npattern instead, since that gets the endianness right without\na separate fixup instruction.\n\n2018-02-01  Richard Sandiford  <richard.sandiford@linaro.org>\n\ngcc/\n\t* config/aarch64/aarch64.c (aarch64_expand_sve_const_vector): Prefer\n\tthe TImode handling for big-endian targets.\n\ngcc/testsuite/\n\t* gcc.target/aarch64/sve/slp_2.c: Expect LD1RQ to be used instead\n\tof LD1R[HWD] for multi-element constants on big-endian targets.\n\t* gcc.target/aarch64/sve/slp_3.c: Likewise.\n\t* gcc.target/aarch64/sve/slp_4.c: Likewise.\n\nReviewed-by: James Greenhalgh <james.greenhalgh@arm.com>\n\nFrom-SVN: r257288", "tree": {"sha": "5a7162b0e53a7fb9c7dbbc86cf05d9a3619cbda2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5a7162b0e53a7fb9c7dbbc86cf05d9a3619cbda2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8179efe00e04285184112de7dbb977a75852197c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8179efe00e04285184112de7dbb977a75852197c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8179efe00e04285184112de7dbb977a75852197c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8179efe00e04285184112de7dbb977a75852197c/comments", "author": null, "committer": null, "parents": [{"sha": "947b137212d16d432eec201fe7f800dfdb481203", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/947b137212d16d432eec201fe7f800dfdb481203", "html_url": "https://github.com/Rust-GCC/gccrs/commit/947b137212d16d432eec201fe7f800dfdb481203"}], "stats": {"total": 48, "additions": 38, "deletions": 10}, "files": [{"sha": "db763a636485adf0895d542a960c5cd6af72e32c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8179efe00e04285184112de7dbb977a75852197c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8179efe00e04285184112de7dbb977a75852197c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8179efe00e04285184112de7dbb977a75852197c", "patch": "@@ -1,3 +1,8 @@\n+2018-02-01  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\t* config/aarch64/aarch64.c (aarch64_expand_sve_const_vector): Prefer\n+\tthe TImode handling for big-endian targets.\n+\n 2018-02-01  Richard Sandiford  <richard.sandiford@linaro.org>\n \n \t* config/aarch64/aarch64-sve.md (sve_ld1rq): Replace with..."}, {"sha": "6296ffe959f62ac5515a3d32e617a909f829f090", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8179efe00e04285184112de7dbb977a75852197c/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8179efe00e04285184112de7dbb977a75852197c/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=8179efe00e04285184112de7dbb977a75852197c", "patch": "@@ -2824,10 +2824,18 @@ aarch64_expand_sve_const_vector (rtx dest, rtx src)\n       /* The constant is a repeating seqeuence of at least two elements,\n \t where the repeating elements occupy no more than 128 bits.\n \t Get an integer representation of the replicated value.  */\n-      unsigned int int_bits = GET_MODE_UNIT_BITSIZE (mode) * npatterns;\n-      gcc_assert (int_bits <= 128);\n-\n-      scalar_int_mode int_mode = int_mode_for_size (int_bits, 0).require ();\n+      scalar_int_mode int_mode;\n+      if (BYTES_BIG_ENDIAN)\n+\t/* For now, always use LD1RQ to load the value on big-endian\n+\t   targets, since the handling of smaller integers includes a\n+\t   subreg that is semantically an element reverse.  */\n+\tint_mode = TImode;\n+      else\n+\t{\n+\t  unsigned int int_bits = GET_MODE_UNIT_BITSIZE (mode) * npatterns;\n+\t  gcc_assert (int_bits <= 128);\n+\t  int_mode = int_mode_for_size (int_bits, 0).require ();\n+\t}\n       rtx int_value = simplify_gen_subreg (int_mode, src, mode, 0);\n       if (int_value\n \t  && aarch64_expand_sve_widened_duplicate (dest, int_mode, int_value))"}, {"sha": "522938f61ba92a7f08ea4105f64e84ed7522c832", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8179efe00e04285184112de7dbb977a75852197c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8179efe00e04285184112de7dbb977a75852197c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=8179efe00e04285184112de7dbb977a75852197c", "patch": "@@ -1,3 +1,10 @@\n+2018-02-01  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\t* gcc.target/aarch64/sve/slp_2.c: Expect LD1RQ to be used instead\n+\tof LD1R[HWD] for multi-element constants on big-endian targets.\n+\t* gcc.target/aarch64/sve/slp_3.c: Likewise.\n+\t* gcc.target/aarch64/sve/slp_4.c: Likewise.\n+\n 2018-02-01  Richard Sandiford  <richard.sandiford@linaro.org>\n \n \t* gcc.target/aarch64/sve/slp_2.c: Expect LD1RQD rather than LD1RQB."}, {"sha": "413532c076fab9fe83db241a7bd97b8db79701d3", "filename": "gcc/testsuite/gcc.target/aarch64/sve/slp_2.c", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8179efe00e04285184112de7dbb977a75852197c/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fslp_2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8179efe00e04285184112de7dbb977a75852197c/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fslp_2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fslp_2.c?ref=8179efe00e04285184112de7dbb977a75852197c", "patch": "@@ -29,9 +29,12 @@ vec_slp_##TYPE (TYPE *restrict a, int n)\t\t\t\\\n \n TEST_ALL (VEC_PERM)\n \n-/* { dg-final { scan-assembler-times {\\tld1rh\\tz[0-9]+\\.h, } 2 } } */\n-/* { dg-final { scan-assembler-times {\\tld1rw\\tz[0-9]+\\.s, } 3 } } */\n-/* { dg-final { scan-assembler-times {\\tld1rd\\tz[0-9]+\\.d, } 3 } } */\n+/* { dg-final { scan-assembler-times {\\tld1rh\\tz[0-9]+\\.h, } 2 { target aarch64_little_endian } } } */\n+/* { dg-final { scan-assembler-times {\\tld1rqb\\tz[0-9]+\\.b, } 2 { target aarch64_big_endian } } } */\n+/* { dg-final { scan-assembler-times {\\tld1rw\\tz[0-9]+\\.s, } 3 { target aarch64_little_endian } } } */\n+/* { dg-final { scan-assembler-times {\\tld1rqh\\tz[0-9]+\\.h, } 3 { target aarch64_big_endian } } } */\n+/* { dg-final { scan-assembler-times {\\tld1rd\\tz[0-9]+\\.d, } 3 { target aarch64_little_endian } } } */\n+/* { dg-final { scan-assembler-times {\\tld1rqw\\tz[0-9]+\\.s, } 3 { target aarch64_big_endian } } } */\n /* { dg-final { scan-assembler-times {\\tld1rqd\\tz[0-9]+\\.d, } 3 } } */\n /* { dg-final { scan-assembler-not {\\tzip1\\t} } } */\n /* { dg-final { scan-assembler-not {\\tzip2\\t} } } */"}, {"sha": "0f9f01a00565b1d6f702b3d784a67a08d570dbaf", "filename": "gcc/testsuite/gcc.target/aarch64/sve/slp_3.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8179efe00e04285184112de7dbb977a75852197c/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fslp_3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8179efe00e04285184112de7dbb977a75852197c/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fslp_3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fslp_3.c?ref=8179efe00e04285184112de7dbb977a75852197c", "patch": "@@ -32,9 +32,12 @@ vec_slp_##TYPE (TYPE *restrict a, int n)\t\t\t\\\n TEST_ALL (VEC_PERM)\n \n /* 1 for each 8-bit type.  */\n-/* { dg-final { scan-assembler-times {\\tld1rw\\tz[0-9]+\\.s, } 2 } } */\n+/* { dg-final { scan-assembler-times {\\tld1rw\\tz[0-9]+\\.s, } 2 { target aarch64_little_endian } } } */\n+/* { dg-final { scan-assembler-times {\\tld1rqb\\tz[0-9]+\\.b, } 2 { target aarch64_big_endian } } } */\n /* 1 for each 16-bit type and 4 for double.  */\n-/* { dg-final { scan-assembler-times {\\tld1rd\\tz[0-9]+\\.d, } 7 } } */\n+/* { dg-final { scan-assembler-times {\\tld1rd\\tz[0-9]+\\.d, } 7 { target aarch64_little_endian } } } */\n+/* { dg-final { scan-assembler-times {\\tld1rqh\\tz[0-9]+\\.h, } 3 { target aarch64_big_endian } } } */\n+/* { dg-final { scan-assembler-times {\\tld1rd\\tz[0-9]+\\.d, } 4 { target aarch64_big_endian } } } */\n /* 1 for each 32-bit type.  */\n /* { dg-final { scan-assembler-times {\\tld1rqw\\tz[0-9]+\\.s, } 3 } } */\n /* { dg-final { scan-assembler-times {\\tmov\\tz[0-9]+\\.d, #41\\n} 2 } } */"}, {"sha": "8d9d5ab5887d66729fbc20cb3be31a3ca9302c8c", "filename": "gcc/testsuite/gcc.target/aarch64/sve/slp_4.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8179efe00e04285184112de7dbb977a75852197c/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fslp_4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8179efe00e04285184112de7dbb977a75852197c/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fslp_4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fslp_4.c?ref=8179efe00e04285184112de7dbb977a75852197c", "patch": "@@ -36,7 +36,9 @@ vec_slp_##TYPE (TYPE *restrict a, int n)\t\t\t\\\n TEST_ALL (VEC_PERM)\n \n /* 1 for each 8-bit type, 4 for each 32-bit type and 8 for double.  */\n-/* { dg-final { scan-assembler-times {\\tld1rd\\tz[0-9]+\\.d, } 22 } } */\n+/* { dg-final { scan-assembler-times {\\tld1rd\\tz[0-9]+\\.d, } 22 { target aarch64_little_endian } } } */\n+/* { dg-final { scan-assembler-times {\\tld1rqb\\tz[0-9]+\\.b, } 2 { target aarch64_big_endian } } } */\n+/* { dg-final { scan-assembler-times {\\tld1rd\\tz[0-9]+\\.d, } 20 { target aarch64_big_endian } } } */\n /* 1 for each 16-bit type.  */\n /* { dg-final { scan-assembler-times {\\tld1rqh\\tz[0-9]\\.h, } 3 } } */\n /* { dg-final { scan-assembler-times {\\tmov\\tz[0-9]+\\.d, #99\\n} 2 } } */"}]}