{"sha": "a33f291d93be2788324ee4a5d4e5236906ebf950", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTMzZjI5MWQ5M2JlMjc4ODMyNGVlNGE1ZDRlNTIzNjkwNmViZjk1MA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-07-05T10:49:52Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-07-05T10:49:52Z"}, "message": "[multiple changes]\n\n2013-07-05  Claire Dross  <dross@adacore.com>\n\n\t* a-cfdlli.ads, a-cfhama.ads, a-cfhase.ads, a-cforma.ads,\n\ta-cforse.ads, a-cofove.ads: Add preconditions when needed +\n\tcontainer types are not tagged any more.\n\n2013-07-05  Thomas Quinot  <quinot@adacore.com>\n\n\t* freeze.adb (Freeze_Entity): For an object with captured\n\tinitialization statements, do not remove Init_Stmts from the\n\tenclosing list, as Freeze_All might rely on it to know where to\n\tstop freezing.\n\nFrom-SVN: r200708", "tree": {"sha": "e9e799e7137d278bfce878c0136824279fd52f5e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e9e799e7137d278bfce878c0136824279fd52f5e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a33f291d93be2788324ee4a5d4e5236906ebf950", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a33f291d93be2788324ee4a5d4e5236906ebf950", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a33f291d93be2788324ee4a5d4e5236906ebf950", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a33f291d93be2788324ee4a5d4e5236906ebf950/comments", "author": null, "committer": null, "parents": [{"sha": "16788d44af6621f4bb0b51f3527a3e406cdfddca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16788d44af6621f4bb0b51f3527a3e406cdfddca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/16788d44af6621f4bb0b51f3527a3e406cdfddca"}], "stats": {"total": 487, "additions": 347, "deletions": 140}, "files": [{"sha": "1c3bbabfc00f3adb1a7398d54506962f8ad1bc49", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a33f291d93be2788324ee4a5d4e5236906ebf950/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a33f291d93be2788324ee4a5d4e5236906ebf950/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=a33f291d93be2788324ee4a5d4e5236906ebf950", "patch": "@@ -1,3 +1,16 @@\n+2013-07-05  Claire Dross  <dross@adacore.com>\n+\n+\t* a-cfdlli.ads, a-cfhama.ads, a-cfhase.ads, a-cforma.ads,\n+\ta-cforse.ads, a-cofove.ads: Add preconditions when needed +\n+\tcontainer types are not tagged any more.\n+\n+2013-07-05  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* freeze.adb (Freeze_Entity): For an object with captured\n+\tinitialization statements, do not remove Init_Stmts from the\n+\tenclosing list, as Freeze_All might rely on it to know where to\n+\tstop freezing.\n+\n 2013-07-05  Robert Dewar  <dewar@adacore.com>\n \n \t* exp_ch4.adb, a-cfdlli.ads, a-ngelfu.ads, s-bignum.adb: Minor"}, {"sha": "bfa8ffbcb90ab57dbd8076a535004dcb4daae89a", "filename": "gcc/ada/a-cfdlli.ads", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a33f291d93be2788324ee4a5d4e5236906ebf950/gcc%2Fada%2Fa-cfdlli.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a33f291d93be2788324ee4a5d4e5236906ebf950/gcc%2Fada%2Fa-cfdlli.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cfdlli.ads?ref=a33f291d93be2788324ee4a5d4e5236906ebf950", "patch": "@@ -153,15 +153,11 @@ package Ada.Containers.Formal_Doubly_Linked_Lists is\n \n    procedure Delete_First\n      (Container : in out List;\n-      Count     : Count_Type := 1)\n-   with\n-     Pre => not Is_Empty (Container);\n+      Count     : Count_Type := 1);\n \n    procedure Delete_Last\n      (Container : in out List;\n-      Count     : Count_Type := 1)\n-   with\n-     Pre => not Is_Empty (Container);\n+      Count     : Count_Type := 1);\n \n    procedure Reverse_Elements (Container : in out List);\n "}, {"sha": "93a47c56817d42141e0304c63f8a0265aae3da87", "filename": "gcc/ada/a-cfhama.ads", "status": "modified", "additions": 52, "deletions": 24, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a33f291d93be2788324ee4a5d4e5236906ebf950/gcc%2Fada%2Fa-cfhama.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a33f291d93be2788324ee4a5d4e5236906ebf950/gcc%2Fada%2Fa-cfhama.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cfhama.ads?ref=a33f291d93be2788324ee4a5d4e5236906ebf950", "patch": "@@ -64,7 +64,7 @@ generic\n package Ada.Containers.Formal_Hashed_Maps is\n    pragma Pure;\n \n-   type Map (Capacity : Count_Type; Modulus : Hash_Type) is tagged private;\n+   type Map (Capacity : Count_Type; Modulus : Hash_Type) is private;\n    pragma Preelaborable_Initialization (Map);\n \n    type Cursor is private;\n@@ -80,75 +80,101 @@ package Ada.Containers.Formal_Hashed_Maps is\n \n    procedure Reserve_Capacity\n      (Container : in out Map;\n-      Capacity  : Count_Type);\n+      Capacity  : Count_Type)\n+   with\n+     Pre => Capacity <= Container.Capacity;\n \n    function Length (Container : Map) return Count_Type;\n \n    function Is_Empty (Container : Map) return Boolean;\n \n    procedure Clear (Container : in out Map);\n \n-   procedure Assign (Target : in out Map; Source : Map);\n+   procedure Assign (Target : in out Map; Source : Map) with\n+     Pre => Target.Capacity >= Length (Source);\n \n-   --  Copy returns a container stricty equal to Source\n-   --  It must have the same cursors associated to each element\n-   --  Therefore:\n-   --  - capacity=0 means use container.capacity as cap of tgt\n-   --  - the modulus cannot be changed.\n    function Copy\n      (Source   : Map;\n-      Capacity : Count_Type := 0) return Map;\n+      Capacity : Count_Type := 0) return Map\n+   with\n+     Pre => Capacity >= Source.Capacity;\n+   --  Copy returns a container stricty equal to Source. It must have\n+   --  the same cursors associated with each element. Therefore:\n+   --  - capacity=0 means use container.capacity as capacity of target\n+   --  - the modulus cannot be changed.\n \n-   function Key (Container : Map; Position : Cursor) return Key_Type;\n+   function Key (Container : Map; Position : Cursor) return Key_Type with\n+     Pre => Has_Element (Container, Position);\n \n-   function Element (Container : Map; Position : Cursor) return Element_Type;\n+   function Element\n+     (Container : Map;\n+      Position  : Cursor) return Element_Type\n+   with\n+     Pre => Has_Element (Container, Position);\n \n    procedure Replace_Element\n      (Container : in out Map;\n       Position  : Cursor;\n-      New_Item  : Element_Type);\n+      New_Item  : Element_Type)\n+   with\n+     Pre => Has_Element (Container, Position);\n \n-   procedure Move (Target : in out Map; Source : in out Map);\n+   procedure Move (Target : in out Map; Source : in out Map) with\n+     Pre => Target.Capacity >= Length (Source);\n \n    procedure Insert\n      (Container : in out Map;\n       Key       : Key_Type;\n       New_Item  : Element_Type;\n       Position  : out Cursor;\n-      Inserted  : out Boolean);\n+      Inserted  : out Boolean)\n+   with\n+     Pre => Length (Container) < Container.Capacity;\n \n    procedure Insert\n      (Container : in out Map;\n       Key       : Key_Type;\n-      New_Item  : Element_Type);\n+      New_Item  : Element_Type)\n+   with\n+     Pre => Length (Container) < Container.Capacity\n+              and then (not Contains (Container, Key));\n \n    procedure Include\n      (Container : in out Map;\n       Key       : Key_Type;\n-      New_Item  : Element_Type);\n+      New_Item  : Element_Type)\n+   with\n+     Pre => Length (Container) < Container.Capacity;\n \n    procedure Replace\n      (Container : in out Map;\n       Key       : Key_Type;\n-      New_Item  : Element_Type);\n+      New_Item  : Element_Type)\n+   with\n+     Pre => Contains (Container, Key);\n \n    procedure Exclude (Container : in out Map; Key : Key_Type);\n \n-   procedure Delete (Container : in out Map; Key : Key_Type);\n+   procedure Delete (Container : in out Map; Key : Key_Type) with\n+     Pre => Contains (Container, Key);\n \n-   procedure Delete (Container : in out Map; Position : in out Cursor);\n+   procedure Delete (Container : in out Map; Position : in out Cursor) with\n+     Pre => Has_Element (Container, Position);\n \n    function First (Container : Map) return Cursor;\n \n-   function Next (Container : Map; Position : Cursor) return Cursor;\n+   function Next (Container : Map; Position : Cursor) return Cursor with\n+     Pre => Has_Element (Container, Position) or else Position = No_Element;\n \n-   procedure Next (Container : Map; Position : in out Cursor);\n+   procedure Next (Container : Map; Position : in out Cursor) with\n+     Pre => Has_Element (Container, Position) or else Position = No_Element;\n \n    function Find (Container : Map; Key : Key_Type) return Cursor;\n \n    function Contains (Container : Map; Key : Key_Type) return Boolean;\n \n-   function Element (Container : Map; Key : Key_Type) return Element_Type;\n+   function Element (Container : Map; Key : Key_Type) return Element_Type with\n+     Pre => Contains (Container, Key);\n \n    function Has_Element (Container : Map; Position : Cursor) return Boolean;\n \n@@ -175,8 +201,10 @@ package Ada.Containers.Formal_Hashed_Maps is\n    --  they are structurally equal (function \"=\" returns True) and that they\n    --  have the same set of cursors.\n \n-   function Left  (Container : Map; Position : Cursor) return Map;\n-   function Right (Container : Map; Position : Cursor) return Map;\n+   function Left  (Container : Map; Position : Cursor) return Map with\n+     Pre => Has_Element (Container, Position) or else Position = No_Element;\n+   function Right (Container : Map; Position : Cursor) return Map with\n+     Pre => Has_Element (Container, Position) or else Position = No_Element;\n    --  Left returns a container containing all elements preceding Position\n    --  (excluded) in Container. Right returns a container containing all\n    --  elements following Position (included) in Container. These two new"}, {"sha": "22bfda97e892fe89de451851f9620a786c34f5cb", "filename": "gcc/ada/a-cfhase.ads", "status": "modified", "additions": 47, "deletions": 20, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a33f291d93be2788324ee4a5d4e5236906ebf950/gcc%2Fada%2Fa-cfhase.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a33f291d93be2788324ee4a5d4e5236906ebf950/gcc%2Fada%2Fa-cfhase.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cfhase.ads?ref=a33f291d93be2788324ee4a5d4e5236906ebf950", "patch": "@@ -66,7 +66,7 @@ generic\n package Ada.Containers.Formal_Hashed_Sets is\n    pragma Pure;\n \n-   type Set (Capacity : Count_Type; Modulus : Hash_Type) is tagged private;\n+   type Set (Capacity : Count_Type; Modulus : Hash_Type) is private;\n    pragma Preelaborable_Initialization (Set);\n \n    type Cursor is private;\n@@ -86,47 +86,70 @@ package Ada.Containers.Formal_Hashed_Sets is\n \n    procedure Reserve_Capacity\n      (Container : in out Set;\n-      Capacity  : Count_Type);\n+      Capacity  : Count_Type)\n+   with\n+     Pre => Capacity <= Container.Capacity;\n \n    function Length (Container : Set) return Count_Type;\n \n    function Is_Empty (Container : Set) return Boolean;\n \n    procedure Clear (Container : in out Set);\n \n-   procedure Assign (Target : in out Set; Source : Set);\n+   procedure Assign (Target : in out Set; Source : Set) with\n+     Pre => Target.Capacity >= Length (Source);\n \n-   function Copy (Source   : Set;\n-                  Capacity : Count_Type := 0) return Set;\n+   function Copy\n+     (Source   : Set;\n+      Capacity : Count_Type := 0) return Set\n+   with\n+     Pre => Capacity >= Source.Capacity;\n \n-   function Element (Container : Set; Position : Cursor) return Element_Type;\n+   function Element\n+     (Container : Set;\n+      Position  : Cursor) return Element_Type\n+   with\n+     Pre => Has_Element (Container, Position);\n \n    procedure Replace_Element\n      (Container : in out Set;\n       Position  : Cursor;\n-      New_Item  : Element_Type);\n+      New_Item  : Element_Type)\n+   with\n+     Pre => Has_Element (Container, Position);\n \n-   procedure Move (Target : in out Set; Source : in out Set);\n+   procedure Move (Target : in out Set; Source : in out Set) with\n+     Pre => Target.Capacity >= Length (Source);\n \n    procedure Insert\n      (Container : in out Set;\n       New_Item  : Element_Type;\n       Position  : out Cursor;\n-      Inserted  : out Boolean);\n+      Inserted  : out Boolean)\n+   with\n+     Pre => Length (Container) < Container.Capacity;\n \n-   procedure Insert  (Container : in out Set; New_Item : Element_Type);\n+   procedure Insert  (Container : in out Set; New_Item : Element_Type) with\n+     Pre => Length (Container) < Container.Capacity\n+              and then (not Contains (Container, New_Item));\n \n-   procedure Include (Container : in out Set; New_Item : Element_Type);\n+   procedure Include (Container : in out Set; New_Item : Element_Type) with\n+     Pre => Length (Container) < Container.Capacity;\n \n-   procedure Replace (Container : in out Set; New_Item : Element_Type);\n+   procedure Replace (Container : in out Set; New_Item : Element_Type) with\n+     Pre => Contains (Container, New_Item);\n \n    procedure Exclude (Container : in out Set; Item     : Element_Type);\n \n-   procedure Delete  (Container : in out Set; Item     : Element_Type);\n+   procedure Delete  (Container : in out Set; Item     : Element_Type) with\n+     Pre => Contains (Container, Item);\n \n-   procedure Delete (Container : in out Set; Position  : in out Cursor);\n+   procedure Delete (Container : in out Set; Position  : in out Cursor) with\n+     Pre => Has_Element (Container, Position);\n \n-   procedure Union (Target : in out Set; Source : Set);\n+   procedure Union (Target : in out Set; Source : Set) with\n+     Pre => Length (Target) + Length (Source) -\n+              Length (Intersection (Target, Source)) <= Target.Capacity;\n \n    function Union (Left, Right : Set) return Set;\n \n@@ -149,17 +172,19 @@ package Ada.Containers.Formal_Hashed_Sets is\n    function Symmetric_Difference (Left, Right : Set) return Set;\n \n    function \"xor\" (Left, Right : Set) return Set\n-                   renames Symmetric_Difference;\n+     renames Symmetric_Difference;\n \n    function Overlap (Left, Right : Set) return Boolean;\n \n    function Is_Subset (Subset : Set; Of_Set : Set) return Boolean;\n \n    function First (Container : Set) return Cursor;\n \n-   function Next (Container : Set; Position : Cursor) return Cursor;\n+   function Next (Container : Set; Position : Cursor) return Cursor with\n+     Pre => Has_Element (Container, Position) or else Position = No_Element;\n \n-   procedure Next (Container : Set; Position : in out Cursor);\n+   procedure Next (Container : Set; Position : in out Cursor) with\n+     Pre => Has_Element (Container, Position) or else Position = No_Element;\n \n    function Find\n      (Container : Set;\n@@ -217,8 +242,10 @@ package Ada.Containers.Formal_Hashed_Sets is\n    --  they are structurally equal (function \"=\" returns True) and that they\n    --  have the same set of cursors.\n \n-   function Left  (Container : Set; Position : Cursor) return Set;\n-   function Right (Container : Set; Position : Cursor) return Set;\n+   function Left  (Container : Set; Position : Cursor) return Set with\n+     Pre => Has_Element (Container, Position) or else Position = No_Element;\n+   function Right (Container : Set; Position : Cursor) return Set with\n+     Pre => Has_Element (Container, Position) or else Position = No_Element;\n    --  Left returns a container containing all elements preceding Position\n    --  (excluded) in Container. Right returns a container containing all\n    --  elements following Position (included) in Container. These two new"}, {"sha": "8e323e19dfb39e8d23eed461f77d46e296b6a22f", "filename": "gcc/ada/a-cforma.ads", "status": "modified", "additions": 56, "deletions": 24, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a33f291d93be2788324ee4a5d4e5236906ebf950/gcc%2Fada%2Fa-cforma.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a33f291d93be2788324ee4a5d4e5236906ebf950/gcc%2Fada%2Fa-cforma.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cforma.ads?ref=a33f291d93be2788324ee4a5d4e5236906ebf950", "patch": "@@ -67,7 +67,7 @@ package Ada.Containers.Formal_Ordered_Maps is\n \n    function Equivalent_Keys (Left, Right : Key_Type) return Boolean;\n \n-   type Map (Capacity : Count_Type) is tagged private;\n+   type Map (Capacity : Count_Type) is private;\n    pragma Preelaborable_Initialization (Map);\n \n    type Cursor is private;\n@@ -85,76 +85,106 @@ package Ada.Containers.Formal_Ordered_Maps is\n \n    procedure Clear (Container : in out Map);\n \n-   procedure Assign (Target : in out Map; Source : Map);\n+   procedure Assign (Target : in out Map; Source : Map) with\n+     Pre => Target.Capacity >= Length (Source);\n \n-   function Copy (Source : Map; Capacity : Count_Type := 0) return Map;\n+   function Copy (Source : Map; Capacity : Count_Type := 0) return Map with\n+     Pre => Capacity >= Source.Capacity;\n \n-   function Key (Container : Map; Position : Cursor) return Key_Type;\n+   function Key (Container : Map; Position : Cursor) return Key_Type with\n+     Pre => Has_Element (Container, Position);\n \n-   function Element (Container : Map; Position : Cursor) return Element_Type;\n+   function Element\n+     (Container : Map;\n+      Position  : Cursor) return Element_Type\n+   with\n+     Pre => Has_Element (Container, Position);\n \n    procedure Replace_Element\n      (Container : in out Map;\n       Position  : Cursor;\n-      New_Item  : Element_Type);\n+      New_Item  : Element_Type)\n+   with\n+     Pre => Has_Element (Container, Position);\n \n-   procedure Move (Target : in out Map; Source : in out Map);\n+   procedure Move (Target : in out Map; Source : in out Map) with\n+     Pre => Target.Capacity >= Length (Source);\n \n    procedure Insert\n      (Container : in out Map;\n       Key       : Key_Type;\n       New_Item  : Element_Type;\n       Position  : out Cursor;\n-      Inserted  : out Boolean);\n+      Inserted  : out Boolean)\n+   with\n+     Pre => Length (Container) < Container.Capacity;\n \n    procedure Insert\n      (Container : in out Map;\n       Key       : Key_Type;\n-      New_Item  : Element_Type);\n+      New_Item  : Element_Type)\n+   with\n+     Pre => Length (Container) < Container.Capacity\n+              and then (not Contains (Container, Key));\n \n    procedure Include\n      (Container : in out Map;\n       Key       : Key_Type;\n-      New_Item  : Element_Type);\n+      New_Item  : Element_Type)\n+   with\n+     Pre => Length (Container) < Container.Capacity;\n \n    procedure Replace\n      (Container : in out Map;\n       Key       : Key_Type;\n-      New_Item  : Element_Type);\n+      New_Item  : Element_Type)\n+   with\n+     Pre => Contains (Container, Key);\n \n    procedure Exclude (Container : in out Map; Key : Key_Type);\n \n-   procedure Delete (Container : in out Map; Key : Key_Type);\n+   procedure Delete (Container : in out Map; Key : Key_Type) with\n+     Pre => Contains (Container, Key);\n \n-   procedure Delete (Container : in out Map; Position : in out Cursor);\n+   procedure Delete (Container : in out Map; Position : in out Cursor) with\n+     Pre => Has_Element (Container, Position);\n \n    procedure Delete_First (Container : in out Map);\n \n    procedure Delete_Last (Container : in out Map);\n \n    function First (Container : Map) return Cursor;\n \n-   function First_Element (Container : Map) return Element_Type;\n+   function First_Element (Container : Map) return Element_Type with\n+     Pre => not Is_Empty (Container);\n \n-   function First_Key (Container : Map) return Key_Type;\n+   function First_Key (Container : Map) return Key_Type with\n+     Pre => not Is_Empty (Container);\n \n    function Last (Container : Map) return Cursor;\n \n-   function Last_Element (Container : Map) return Element_Type;\n+   function Last_Element (Container : Map) return Element_Type with\n+     Pre => not Is_Empty (Container);\n \n-   function Last_Key (Container : Map) return Key_Type;\n+   function Last_Key (Container : Map) return Key_Type with\n+     Pre => not Is_Empty (Container);\n \n-   function Next (Container : Map; Position : Cursor) return Cursor;\n+   function Next (Container : Map; Position : Cursor) return Cursor with\n+     Pre => Has_Element (Container, Position) or else Position = No_Element;\n \n-   procedure Next (Container : Map; Position : in out Cursor);\n+   procedure Next (Container : Map; Position : in out Cursor) with\n+     Pre => Has_Element (Container, Position) or else Position = No_Element;\n \n-   function Previous (Container : Map; Position : Cursor) return Cursor;\n+   function Previous (Container : Map; Position : Cursor) return Cursor with\n+     Pre => Has_Element (Container, Position) or else Position = No_Element;\n \n-   procedure Previous (Container : Map; Position : in out Cursor);\n+   procedure Previous (Container : Map; Position : in out Cursor) with\n+     Pre => Has_Element (Container, Position) or else Position = No_Element;\n \n    function Find (Container : Map; Key : Key_Type) return Cursor;\n \n-   function Element (Container : Map; Key : Key_Type) return Element_Type;\n+   function Element (Container : Map; Key : Key_Type) return Element_Type with\n+     Pre => Contains (Container, Key);\n \n    function Floor (Container : Map; Key : Key_Type) return Cursor;\n \n@@ -169,8 +199,10 @@ package Ada.Containers.Formal_Ordered_Maps is\n    --  they are structurally equal (function \"=\" returns True) and that they\n    --  have the same set of cursors.\n \n-   function Left  (Container : Map; Position : Cursor) return Map;\n-   function Right (Container : Map; Position : Cursor) return Map;\n+   function Left  (Container : Map; Position : Cursor) return Map with\n+     Pre => Has_Element (Container, Position) or else Position = No_Element;\n+   function Right (Container : Map; Position : Cursor) return Map with\n+     Pre => Has_Element (Container, Position) or else Position = No_Element;\n    --  Left returns a container containing all elements preceding Position\n    --  (excluded) in Container. Right returns a container containing all\n    --  elements following Position (included) in Container. These two new"}, {"sha": "35e4613b9a881de7434568e8812a40ec9ca4ebea", "filename": "gcc/ada/a-cforse.ads", "status": "modified", "additions": 54, "deletions": 23, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a33f291d93be2788324ee4a5d4e5236906ebf950/gcc%2Fada%2Fa-cforse.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a33f291d93be2788324ee4a5d4e5236906ebf950/gcc%2Fada%2Fa-cforse.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cforse.ads?ref=a33f291d93be2788324ee4a5d4e5236906ebf950", "patch": "@@ -65,9 +65,8 @@ package Ada.Containers.Formal_Ordered_Sets is\n \n    function Equivalent_Elements (Left, Right : Element_Type) return Boolean;\n \n-   type Set (Capacity : Count_Type) is tagged private;\n-   --  why is this commented out ???\n-   --  pragma Preelaborable_Initialization (Set);\n+   type Set (Capacity : Count_Type) is private;\n+   pragma Preelaborable_Initialization (Set);\n \n    type Cursor is private;\n    pragma Preelaborable_Initialization (Cursor);\n@@ -88,54 +87,78 @@ package Ada.Containers.Formal_Ordered_Sets is\n \n    procedure Clear (Container : in out Set);\n \n-   procedure Assign (Target : in out Set; Source : Set);\n+   procedure Assign (Target : in out Set; Source : Set) with\n+     Pre => Target.Capacity >= Length (Source);\n \n-   function Copy (Source : Set; Capacity : Count_Type := 0) return Set;\n+   function Copy (Source : Set; Capacity : Count_Type := 0) return Set with\n+     Pre => Capacity >= Source.Capacity;\n \n-   function Element (Container : Set; Position : Cursor) return Element_Type;\n+   function Element\n+     (Container : Set;\n+      Position  : Cursor) return Element_Type\n+   with\n+     Pre => Has_Element (Container, Position);\n \n    procedure Replace_Element\n      (Container : in out Set;\n       Position  : Cursor;\n-      New_Item  : Element_Type);\n+      New_Item  : Element_Type)\n+   with\n+     Pre => Has_Element (Container, Position);\n \n-   procedure Move (Target : in out Set; Source : in out Set);\n+   procedure Move (Target : in out Set; Source : in out Set) with\n+     Pre => Target.Capacity >= Length (Source);\n \n    procedure Insert\n      (Container : in out Set;\n       New_Item  : Element_Type;\n       Position  : out Cursor;\n-      Inserted  : out Boolean);\n+      Inserted  : out Boolean)\n+   with\n+     Pre => Length (Container) < Container.Capacity;\n \n    procedure Insert\n      (Container : in out Set;\n-      New_Item  : Element_Type);\n+      New_Item  : Element_Type)\n+   with\n+     Pre => Length (Container) < Container.Capacity\n+              and then (not Contains (Container, New_Item));\n \n    procedure Include\n      (Container : in out Set;\n-      New_Item  : Element_Type);\n+      New_Item  : Element_Type)\n+   with\n+     Pre => Length (Container) < Container.Capacity;\n \n    procedure Replace\n      (Container : in out Set;\n-      New_Item  : Element_Type);\n+      New_Item  : Element_Type)\n+   with\n+     Pre => Contains (Container, New_Item);\n \n    procedure Exclude\n      (Container : in out Set;\n       Item      : Element_Type);\n \n    procedure Delete\n      (Container : in out Set;\n-      Item      : Element_Type);\n+      Item      : Element_Type)\n+   with\n+     Pre => Contains (Container, Item);\n \n    procedure Delete\n      (Container : in out Set;\n-      Position  : in out Cursor);\n+      Position  : in out Cursor)\n+   with\n+     Pre => Has_Element (Container, Position);\n \n    procedure Delete_First (Container : in out Set);\n \n    procedure Delete_Last (Container : in out Set);\n \n-   procedure Union (Target : in out Set; Source : Set);\n+   procedure Union (Target : in out Set; Source : Set) with\n+     Pre => Length (Target) + Length (Source) -\n+              Length (Intersection (Target, Source)) <= Target.Capacity;\n \n    function Union (Left, Right : Set) return Set;\n \n@@ -165,19 +188,25 @@ package Ada.Containers.Formal_Ordered_Sets is\n \n    function First (Container : Set) return Cursor;\n \n-   function First_Element (Container : Set) return Element_Type;\n+   function First_Element (Container : Set) return Element_Type with\n+     Pre => not Is_Empty (Container);\n \n    function Last (Container : Set) return Cursor;\n \n-   function Last_Element (Container : Set) return Element_Type;\n+   function Last_Element (Container : Set) return Element_Type with\n+     Pre => not Is_Empty (Container);\n \n-   function Next (Container : Set; Position : Cursor) return Cursor;\n+   function Next (Container : Set; Position : Cursor) return Cursor with\n+     Pre => Has_Element (Container, Position) or else Position = No_Element;\n \n-   procedure Next (Container : Set; Position : in out Cursor);\n+   procedure Next (Container : Set; Position : in out Cursor) with\n+     Pre => Has_Element (Container, Position) or else Position = No_Element;\n \n-   function Previous (Container : Set; Position : Cursor) return Cursor;\n+   function Previous (Container : Set; Position : Cursor) return Cursor with\n+     Pre => Has_Element (Container, Position) or else Position = No_Element;\n \n-   procedure Previous (Container : Set; Position : in out Cursor);\n+   procedure Previous (Container : Set; Position : in out Cursor) with\n+     Pre => Has_Element (Container, Position) or else Position = No_Element;\n \n    function Find (Container : Set; Item : Element_Type) return Cursor;\n \n@@ -228,8 +257,10 @@ package Ada.Containers.Formal_Ordered_Sets is\n    --  they are structurally equal (function \"=\" returns True) and that they\n    --  have the same set of cursors.\n \n-   function Left  (Container : Set; Position : Cursor) return Set;\n-   function Right (Container : Set; Position : Cursor) return Set;\n+   function Left  (Container : Set; Position : Cursor) return Set with\n+     Pre => Has_Element (Container, Position) or else Position = No_Element;\n+   function Right (Container : Set; Position : Cursor) return Set with\n+     Pre => Has_Element (Container, Position) or else Position = No_Element;\n    --  Left returns a container containing all elements preceding Position\n    --  (excluded) in Container. Right returns a container containing all\n    --  elements following Position (included) in Container. These two new"}, {"sha": "240715dca75249e98333f94616075b81ef6810fb", "filename": "gcc/ada/a-cofove.adb", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a33f291d93be2788324ee4a5d4e5236906ebf950/gcc%2Fada%2Fa-cofove.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a33f291d93be2788324ee4a5d4e5236906ebf950/gcc%2Fada%2Fa-cofove.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cofove.adb?ref=a33f291d93be2788324ee4a5d4e5236906ebf950", "patch": "@@ -251,7 +251,7 @@ package body Ada.Containers.Formal_Vectors is\n          raise Constraint_Error;\n       end if;\n \n-      Target.Clear;\n+      Clear (Target);\n \n       Target.Elements (1 .. LS) := Source.Elements (1 .. LS);\n       Target.Last := Source.Last;\n@@ -641,10 +641,10 @@ package body Ada.Containers.Formal_Vectors is\n             --  I think we're missing this check in a-convec.adb...  ???\n \n             I := Length (Target);\n-            Target.Set_Length (I + Length (Source));\n+            Set_Length (Target, I + Length (Source));\n \n             J := Length (Target);\n-            while not Source.Is_Empty loop\n+            while not Is_Empty (Source) loop\n                pragma Assert (Length (Source) <= 1\n                  or else not (SA (Length (Source)) <\n                      SA (Length (Source) - 1)));\n@@ -1487,20 +1487,20 @@ package body Ada.Containers.Formal_Vectors is\n \n    procedure Set_Length\n      (Container : in out Vector;\n-      Length    : Count_Type)\n+      New_Length    : Count_Type)\n    is\n    begin\n-      if Length = Formal_Vectors.Length (Container) then\n+      if New_Length = Formal_Vectors.Length (Container) then\n          return;\n       end if;\n \n-      if Length > Container.Capacity then\n+      if New_Length > Container.Capacity then\n          raise Constraint_Error;  -- ???\n       end if;\n \n       declare\n          Last_As_Int : constant Int'Base :=\n-           Int (Index_Type'First) + Int (Length) - 1;\n+           Int (Index_Type'First) + Int (New_Length) - 1;\n       begin\n          Container.Last := Index_Type'Base (Last_As_Int);\n       end;"}, {"sha": "9ca84da460fc0d795d46a833cac8615b2b57dc89", "filename": "gcc/ada/a-cofove.ads", "status": "modified", "additions": 106, "deletions": 35, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a33f291d93be2788324ee4a5d4e5236906ebf950/gcc%2Fada%2Fa-cofove.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a33f291d93be2788324ee4a5d4e5236906ebf950/gcc%2Fada%2Fa-cofove.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cofove.ads?ref=a33f291d93be2788324ee4a5d4e5236906ebf950", "patch": "@@ -73,7 +73,7 @@ package Ada.Containers.Formal_Vectors is\n \n    No_Index : constant Extended_Index := Extended_Index'First;\n \n-   type Vector (Capacity : Count_Type) is tagged private;\n+   type Vector (Capacity : Count_Type) is private;\n \n    type Cursor is private;\n    pragma Preelaborable_Initialization (Cursor);\n@@ -100,23 +100,30 @@ package Ada.Containers.Formal_Vectors is\n \n    procedure Reserve_Capacity\n      (Container : in out Vector;\n-      Capacity  : Count_Type);\n+      Capacity  : Count_Type)\n+   with\n+     Pre => Capacity <= Container.Capacity;\n \n    function Length (Container : Vector) return Count_Type;\n \n    procedure Set_Length\n      (Container : in out Vector;\n-      Length    : Count_Type);\n+      New_Length    : Count_Type)\n+   with\n+     Pre => New_Length <= Length (Container);\n \n    function Is_Empty (Container : Vector) return Boolean;\n \n    procedure Clear (Container : in out Vector);\n \n-   procedure Assign (Target : in out Vector; Source : Vector);\n+   procedure Assign (Target : in out Vector; Source : Vector) with\n+     Pre => Length (Source) <= Target.Capacity;\n \n    function Copy\n      (Source   : Vector;\n-      Capacity : Count_Type := 0) return Vector;\n+      Capacity : Count_Type := 0) return Vector\n+   with\n+     Pre => Length (Source) <= Capacity;\n \n    function To_Cursor\n      (Container : Vector;\n@@ -126,86 +133,134 @@ package Ada.Containers.Formal_Vectors is\n \n    function Element\n      (Container : Vector;\n-      Index     : Index_Type) return Element_Type;\n+      Index     : Index_Type) return Element_Type\n+   with\n+     Pre => First_Index (Container) <= Index\n+              and then Index <= Last_Index (Container);\n \n    function Element\n      (Container : Vector;\n-      Position  : Cursor) return Element_Type;\n+      Position  : Cursor) return Element_Type\n+   with\n+     Pre => Has_Element (Container, Position);\n \n    procedure Replace_Element\n      (Container : in out Vector;\n       Index     : Index_Type;\n-      New_Item  : Element_Type);\n+      New_Item  : Element_Type)\n+   with\n+     Pre => First_Index (Container) <= Index\n+              and then Index <= Last_Index (Container);\n \n    procedure Replace_Element\n      (Container : in out Vector;\n       Position  : Cursor;\n-      New_Item  : Element_Type);\n+      New_Item  : Element_Type)\n+   with\n+     Pre => Has_Element (Container, Position);\n \n-   procedure Move (Target : in out Vector; Source : in out Vector);\n+   procedure Move (Target : in out Vector; Source : in out Vector) with\n+     Pre => Length (Source) <= Target.Capacity;\n \n    procedure Insert\n      (Container : in out Vector;\n       Before    : Extended_Index;\n-      New_Item  : Vector);\n+      New_Item  : Vector)\n+   with\n+     Pre => First_Index (Container) <= Before\n+              and then Before <= Last_Index (Container) + 1\n+              and then Length (Container) < Container.Capacity;\n \n    procedure Insert\n      (Container : in out Vector;\n       Before    : Cursor;\n-      New_Item  : Vector);\n+      New_Item  : Vector)\n+   with\n+     Pre => Length (Container) < Container.Capacity\n+              and then (Has_Element (Container, Before)\n+                         or else Before = No_Element);\n \n    procedure Insert\n      (Container : in out Vector;\n       Before    : Cursor;\n       New_Item  : Vector;\n-      Position  : out Cursor);\n+      Position  : out Cursor)\n+   with\n+     Pre => Length (Container) < Container.Capacity\n+              and then (Has_Element (Container, Before)\n+                         or else Before = No_Element);\n \n    procedure Insert\n      (Container : in out Vector;\n       Before    : Extended_Index;\n       New_Item  : Element_Type;\n-      Count     : Count_Type := 1);\n+      Count     : Count_Type := 1)\n+   with\n+     Pre => First_Index (Container) <= Before\n+              and then Before <= Last_Index (Container) + 1\n+              and then Length (Container) + Count <= Container.Capacity;\n \n    procedure Insert\n      (Container : in out Vector;\n       Before    : Cursor;\n       New_Item  : Element_Type;\n-      Count     : Count_Type := 1);\n+      Count     : Count_Type := 1)\n+   with\n+     Pre => Length (Container) + Count <= Container.Capacity\n+              and then (Has_Element (Container, Before)\n+                         or else Before = No_Element);\n \n    procedure Insert\n      (Container : in out Vector;\n       Before    : Cursor;\n       New_Item  : Element_Type;\n       Position  : out Cursor;\n-      Count     : Count_Type := 1);\n+      Count     : Count_Type := 1)\n+   with\n+     Pre => Length (Container) + Count <= Container.Capacity\n+              and then (Has_Element (Container, Before)\n+                         or else Before = No_Element);\n \n    procedure Prepend\n      (Container : in out Vector;\n-      New_Item  : Vector);\n+      New_Item  : Vector)\n+   with\n+     Pre => Length (Container) < Container.Capacity;\n \n    procedure Prepend\n      (Container : in out Vector;\n       New_Item  : Element_Type;\n-      Count     : Count_Type := 1);\n+      Count     : Count_Type := 1)\n+   with\n+     Pre => Length (Container) + Count <= Container.Capacity;\n \n    procedure Append\n      (Container : in out Vector;\n-      New_Item  : Vector);\n+      New_Item  : Vector)\n+   with\n+     Pre => Length (Container) < Container.Capacity;\n \n    procedure Append\n      (Container : in out Vector;\n       New_Item  : Element_Type;\n-      Count     : Count_Type := 1);\n+      Count     : Count_Type := 1)\n+   with\n+     Pre => Length (Container) + Count <= Container.Capacity;\n \n    procedure Delete\n      (Container : in out Vector;\n       Index     : Extended_Index;\n-      Count     : Count_Type := 1);\n+      Count     : Count_Type := 1)\n+   with\n+     Pre => First_Index (Container) <= Index\n+              and then Index <= Last_Index (Container) + 1;\n \n    procedure Delete\n      (Container : in out Vector;\n       Position  : in out Cursor;\n-      Count     : Count_Type := 1);\n+      Count     : Count_Type := 1)\n+   with\n+     Pre => Has_Element (Container, Position);\n \n    procedure Delete_First\n      (Container : in out Vector;\n@@ -217,29 +272,39 @@ package Ada.Containers.Formal_Vectors is\n \n    procedure Reverse_Elements (Container : in out Vector);\n \n-   procedure Swap (Container : in out Vector; I, J : Index_Type);\n+   procedure Swap (Container : in out Vector; I, J : Index_Type) with\n+     Pre => First_Index (Container) <= I and then I <= Last_Index (Container)\n+              and then First_Index (Container) <= J\n+              and then J <= Last_Index (Container);\n \n-   procedure Swap (Container : in out Vector; I, J : Cursor);\n+   procedure Swap (Container : in out Vector; I, J : Cursor) with\n+     Pre => Has_Element (Container, I) and then Has_Element (Container, J);\n \n    function First_Index (Container : Vector) return Index_Type;\n \n    function First (Container : Vector) return Cursor;\n \n-   function First_Element (Container : Vector) return Element_Type;\n+   function First_Element (Container : Vector) return Element_Type with\n+     Pre => not Is_Empty (Container);\n \n    function Last_Index (Container : Vector) return Extended_Index;\n \n    function Last (Container : Vector) return Cursor;\n \n-   function Last_Element (Container : Vector) return Element_Type;\n+   function Last_Element (Container : Vector) return Element_Type with\n+     Pre => not Is_Empty (Container);\n \n-   function Next (Container : Vector; Position : Cursor) return Cursor;\n+   function Next (Container : Vector; Position : Cursor) return Cursor with\n+     Pre => Has_Element (Container, Position) or else Position = No_Element;\n \n-   procedure Next (Container : Vector; Position : in out Cursor);\n+   procedure Next (Container : Vector; Position : in out Cursor) with\n+     Pre => Has_Element (Container, Position) or else Position = No_Element;\n \n-   function Previous (Container : Vector; Position : Cursor) return Cursor;\n+   function Previous (Container : Vector; Position : Cursor) return Cursor with\n+     Pre => Has_Element (Container, Position) or else Position = No_Element;\n \n-   procedure Previous (Container : Vector; Position : in out Cursor);\n+   procedure Previous (Container : Vector; Position : in out Cursor) with\n+     Pre => Has_Element (Container, Position) or else Position = No_Element;\n \n    function Find_Index\n      (Container : Vector;\n@@ -249,7 +314,9 @@ package Ada.Containers.Formal_Vectors is\n    function Find\n      (Container : Vector;\n       Item      : Element_Type;\n-      Position  : Cursor := No_Element) return Cursor;\n+      Position  : Cursor := No_Element) return Cursor\n+   with\n+     Pre => Has_Element (Container, Position) or else Position = No_Element;\n \n    function Reverse_Find_Index\n      (Container : Vector;\n@@ -259,7 +326,9 @@ package Ada.Containers.Formal_Vectors is\n    function Reverse_Find\n      (Container : Vector;\n       Item      : Element_Type;\n-      Position  : Cursor := No_Element) return Cursor;\n+      Position  : Cursor := No_Element) return Cursor\n+   with\n+     Pre => Has_Element (Container, Position) or else Position = No_Element;\n \n    function Contains\n      (Container : Vector;\n@@ -279,9 +348,11 @@ package Ada.Containers.Formal_Vectors is\n \n    end Generic_Sorting;\n \n-   function Left (Container : Vector; Position : Cursor) return Vector;\n+   function Left (Container : Vector; Position : Cursor) return Vector with\n+     Pre => Has_Element (Container, Position) or else Position = No_Element;\n \n-   function Right (Container : Vector; Position : Cursor) return Vector;\n+   function Right (Container : Vector; Position : Cursor) return Vector with\n+     Pre => Has_Element (Container, Position) or else Position = No_Element;\n \n private\n \n@@ -298,7 +369,7 @@ private\n    type Elements_Array is array (Count_Type range <>) of Element_Type;\n    function \"=\" (L, R : Elements_Array) return Boolean is abstract;\n \n-   type Vector (Capacity : Count_Type) is tagged record\n+   type Vector (Capacity : Count_Type) is record\n       Elements : Elements_Array (1 .. Capacity);\n       Last     : Extended_Index := No_Index;\n    end record;"}, {"sha": "81a9359e5480e1bb94afbb14c25524b3a75f3ac4", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a33f291d93be2788324ee4a5d4e5236906ebf950/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a33f291d93be2788324ee4a5d4e5236906ebf950/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=a33f291d93be2788324ee4a5d4e5236906ebf950", "patch": "@@ -3360,7 +3360,16 @@ package body Freeze is\n                     and then Nkind (Expression (Init_Stmts)) = N_Null_Statement\n                   then\n                      Insert_List_Before (Init_Stmts, Actions (Init_Stmts));\n-                     Remove (Init_Stmts);\n+\n+                     --  Note that we rewrite Init_Stmts into a NULL statement,\n+                     --  rather than just removing it, because Freeze_All may\n+                     --  depend on this particular Node_Id still being present\n+                     --  in the enclosing list to signal where to stop\n+                     --  freezing.\n+\n+                     Rewrite (Init_Stmts,\n+                       Make_Null_Statement (Sloc (Init_Stmts)));\n+\n                      Set_Initialization_Statements (E, Empty);\n                   end if;\n                end;"}]}