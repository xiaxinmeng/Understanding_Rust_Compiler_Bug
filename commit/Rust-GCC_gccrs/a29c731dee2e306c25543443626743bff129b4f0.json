{"sha": "a29c731dee2e306c25543443626743bff129b4f0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTI5YzczMWRlZTJlMzA2YzI1NTQzNDQzNjI2NzQzYmZmMTI5YjRmMA==", "commit": {"author": {"name": "Janis Johnson", "email": "janis187@us.ibm.com", "date": "2005-02-11T22:36:53Z"}, "committer": {"name": "Janis Johnson", "email": "janis@gcc.gnu.org", "date": "2005-02-11T22:36:53Z"}, "message": "gcc-dg.exp: (dg-require-weak...\n\n\t* lib/gcc-dg.exp: (dg-require-weak, dg-require-visibility,\n\tdg-require-alias, dg-require-gc-sections, dg-require-profiling,\n\tdg-require-dll, dg-require-iconv, dg-require-named-sections,\n\tdg-require-effective-target, dg-skip-if, dg-xfail-if, selector_opd,\n\tselector_list, selector_expression, dg-process-target): Move to new\n\tfile target-supports-dg.exp.\n\t* lib/target-supports-dg.exp: New.\n\nFrom-SVN: r94901", "tree": {"sha": "f32ecfcbb6fdb380737d39d829b35aac3aa52331", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f32ecfcbb6fdb380737d39d829b35aac3aa52331"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a29c731dee2e306c25543443626743bff129b4f0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a29c731dee2e306c25543443626743bff129b4f0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a29c731dee2e306c25543443626743bff129b4f0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a29c731dee2e306c25543443626743bff129b4f0/comments", "author": null, "committer": null, "parents": [{"sha": "56afd7aae3b441be06695812bc4614e2ad2dbf36", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/56afd7aae3b441be06695812bc4614e2ad2dbf36", "html_url": "https://github.com/Rust-GCC/gccrs/commit/56afd7aae3b441be06695812bc4614e2ad2dbf36"}], "stats": {"total": 616, "additions": 335, "deletions": 281}, "files": [{"sha": "75c0514e6f6353161a54f1d1d1e12181b2520488", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a29c731dee2e306c25543443626743bff129b4f0/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a29c731dee2e306c25543443626743bff129b4f0/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=a29c731dee2e306c25543443626743bff129b4f0", "patch": "@@ -1,5 +1,13 @@\n 2005-02-11  Janis Johnson  <janis187@us.ibm.com>\n \n+\t* lib/gcc-dg.exp: (dg-require-weak, dg-require-visibility,\n+\tdg-require-alias, dg-require-gc-sections, dg-require-profiling,\n+\tdg-require-dll, dg-require-iconv, dg-require-named-sections,\n+\tdg-require-effective-target, dg-skip-if, dg-xfail-if, selector_opd,\n+\tselector_list, selector_expression, dg-process-target): Move to new\n+\tfile target-supports-dg.exp.\n+\t* lib/target-supports-dg.exp: New.\n+\n \t* lib/target-supports.exp (check_effective_target_broken_cplxf_arg):\n \tNew.\n "}, {"sha": "9f55b02cb93dfd6f515067b73d9fe4599cbc3f90", "filename": "gcc/testsuite/lib/gcc-dg.exp", "status": "modified", "additions": 1, "deletions": 281, "changes": 282, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a29c731dee2e306c25543443626743bff129b4f0/gcc%2Ftestsuite%2Flib%2Fgcc-dg.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a29c731dee2e306c25543443626743bff129b4f0/gcc%2Ftestsuite%2Flib%2Fgcc-dg.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Fgcc-dg.exp?ref=a29c731dee2e306c25543443626743bff129b4f0", "patch": "@@ -17,6 +17,7 @@\n load_lib dg.exp\n load_lib file-format.exp\n load_lib target-supports.exp\n+load_lib target-supports-dg.exp\n load_lib scanasm.exp\n load_lib scantree.exp\n load_lib prune.exp\n@@ -298,157 +299,6 @@ proc gcc-dg-debug-runtest { target_compile trivial opt_opts testcases } {\n     }\n }\n \n-# If this target does not support weak symbols, skip this test.\n-\n-proc dg-require-weak { args } {\n-    set weak_available [ check_weak_available ]\n-    if { $weak_available == -1 } {\n-\tupvar name name\n-\tunresolved \"$name\"\n-    }\n-    if { $weak_available != 1 } {\n-\tupvar dg-do-what dg-do-what\n-\tset dg-do-what [list [lindex ${dg-do-what} 0] \"N\" \"P\"]\n-    }\n-}\n-\n-# If this target does not support the \"visibility\" attribute, skip this\n-# test.\n-\n-proc dg-require-visibility { args } {\n-    set visibility_available [ check_visibility_available ]\n-    if { $visibility_available == -1 } {\n-\tupvar name name\n-\tunresolved \"$name\"\n-    }\n-    if { $visibility_available != 1 } {\n-\tupvar dg-do-what dg-do-what\n-\tset dg-do-what [list [lindex ${dg-do-what} 0] \"N\" \"P\"]\n-    }\n-}\n-\n-# If this target does not support the \"alias\" attribute, skip this\n-# test.\n-\n-proc dg-require-alias { args } {\n-    set alias_available [ check_alias_available ]\n-    if { $alias_available == -1 } {\n-\tupvar name name\n-\tunresolved \"$name\"\n-    }\n-    if { $alias_available < 2 } {\n-\tupvar dg-do-what dg-do-what\n-\tset dg-do-what [list [lindex ${dg-do-what} 0] \"N\" \"P\"]\n-    }\n-}\n-\n-# If this target's linker does not support the --gc-sections flag,\n-# skip this test.\n-\n-proc dg-require-gc-sections { args } {\n-    if { ![ check_gc_sections_available ] } {\n-\tupvar dg-do-what dg-do-what\n-\tset dg-do-what [list [lindex ${dg-do-what} 0] \"N\" \"P\"]\n-    }\n-}\n-\n-# If this target does not support profiling, skip this test.\n-\n-proc dg-require-profiling { args } {\n-    if { ![ check_profiling_available ${args} ] } {\n-\tupvar dg-do-what dg-do-what\n-\tset dg-do-what [list [lindex ${dg-do-what} 0] \"N\" \"P\"]\n-    }\n-}\n-\n-# If this target does not support DLL attributes skip this test.\n-\n-proc dg-require-dll { args } {\n-    global target_triplet\n-    # As a special case, the mcore-*-elf supports these attributes.\n-    # All Symbian OS targets also support these attributes.\n-    if { [string match \"mcore-*-elf\" $target_triplet]\n-         || [string match \"*-*-symbianelf\" $target_triplet]} {\n-\treturn\n-    }\n-    # PE/COFF targets support dllimport/dllexport.\n-    if { [gcc_target_object_format] == \"pe\" } {\n-\treturn\n-    }\n-\n-    upvar dg-do-what dg-do-what\n-    set dg-do-what [list [lindex ${dg-do-what} 0] \"N\" \"P\"]\n-}\n-\n-proc dg-require-iconv { args } {\n-    if { ![ check_iconv_available ${args} ] } {\n-\tupvar dg-do-what dg-do-what\n-        set dg-do-what [list [lindex ${dg-do-what} 0] \"N\" \"P\"]\n-    }\n-}\n-\n-# If this target does not support named sections skip this test.\n-\n-proc dg-require-named-sections { args } {\n-    if { ![ check_named_sections_available ] } {\n-\tupvar dg-do-what dg-do-what\n-        set dg-do-what [list [lindex ${dg-do-what} 0] \"N\" \"P\"]\n-    }\n-}\n-\n-# If the target does not match the required effective target, skip this test.\n-\n-proc dg-require-effective-target { args } {\n-    set args [lreplace $args 0 0]\n-    if { ![is-effective-target [lindex $args 0]] } {\n-\tupvar dg-do-what dg-do-what\n-        set dg-do-what [list [lindex ${dg-do-what} 0] \"N\" \"P\"]\n-    }\n-}\n-\n-# Skip the test (report it as UNSUPPORTED) if the target list and\n-# included flags are matched and the excluded flags are not matched.\n-#\n-# The first argument is the line number of the dg-skip-if directive\n-# within the test file.   Remaining arguments are as for xfail lists:\n-# message { targets } { include } { exclude }\n-#\n-# This tests against multilib flags plus either the default flags for this\n-# group of tests or flags specified with a previous dg-options command.\n-\n-proc dg-skip-if { args } {\n-    set args [lreplace $args 0 0]\n-\n-    set selector \"target [join [lindex $args 1]]\"\n-    if { [dg-process-target $selector] == \"S\" } {\n-\t# The target list matched; now check the flags.  The DejaGnu proc\n-\t# check_conditional_xfail will look at the options in compiler_flags,\n-\t# so set that up for this test based on flags we know about.  Start\n-\t# the list with a dummy tool name so the list will match \"*\" if\n-\t# there are no flags.\n-\n-\tglobal compiler_flags\n-\tupvar dg-extra-tool-flags extra_tool_flags\n-\n-\tset compiler_flags \" toolname \"\n-\tappend compiler_flags $extra_tool_flags\n-\tset dest [target_info name]\n-\tif [board_info $dest exists multilib_flags] {\n-\t    append compiler_flags \"[board_info $dest multilib_flags] \"\n-\t}\n-\n-\t# The target list might be an effective-target keyword, so replace\n-\t# the original list with \"*-*-*\".\n-\tif [check_conditional_xfail [lreplace $args 1 1 \"*-*-*\"]] {\n-\t    upvar dg-do-what dg-do-what\n-            set dg-do-what [list [lindex ${dg-do-what} 0] \"N\" \"P\"]\n-\t}\n-\n-\t# Any value in this variable was left over from an earlier test.\n-\tset compiler_flags \"\"\n-    }\n-}\n-\n # Prune any messages matching ARGS[1] (a regexp) from test output.\n proc dg-prune-output { args } {\n     global additional_prunes\n@@ -461,23 +311,6 @@ proc dg-prune-output { args } {\n     lappend additional_prunes [lindex $args 1]\n }\n \n-# Like check_conditional_xfail, but callable from a dg test.\n-\n-proc dg-xfail-if { args } {\n-    # Don't change anything if we're already skipping the test.\n-    upvar dg-do-what dg-do-what\n-    if { [lindex ${dg-do-what} 1] == \"N\" } {\n-      return\n-    }\n-\n-    set args [lreplace $args 0 0]\n-    set selector \"target [join [lindex $args 1]]\"\n-    if { [dg-process-target $selector] == \"S\" } {\n-\tglobal compiler_conditional_xfail_data\n-\tset compiler_conditional_xfail_data [lreplace $args 1 1 \"*-*-*\"]\n-    }\n-}\n-\n # We need to make sure that additional_* are cleared out after every\n # test.  It is not enough to clear them out *before* the next test run\n # because gcc-target-compile gets run directly from some .exp files\n@@ -515,117 +348,4 @@ if { [info procs saved-dg-test] == [list] } {\n     }\n }\n \n-# Intercept the call to the DejaGnu version of dg-process-target to\n-# support use of an effective-target keyword in place of a list of\n-# target triplets to xfail or skip a test.\n-#\n-# selector is one of:\n-#    xfail target-triplet-1 ...\n-#    xfail effective-target-keyword\n-#    xfail selector-expression\n-#    target target-triplet-1 ...\n-#    target effective-target-keyword\n-#    target selector-expression\n-#\n-# For a target list the result is \"S\" if the target is selected, \"N\" otherwise.\n-# For an xfail list the result is \"F\" if the target is affected, \"P\" otherwise.\n-#\n-# A selector expression appears within curly braces and uses a single logical\n-# operator: !, &&, or ||.  An operand is another selector expression, an\n-# effective-target keyword, or a list of target triplets within quotes or\n-# curly braces.\n-\n-if { [info procs saved-dg-process-target] == [list] } {\n-    rename dg-process-target saved-dg-process-target\n-\n-    # Evaluate an operand within a selector expression.\n-    proc selector_opd { op } {\n-\tset selector \"target\"\n-\tlappend selector $op\n-\tset answer [ expr { [dg-process-target $selector] == \"S\" } ]\n-\tverbose \"selector_opd: `$op' $answer\" 2\n-\treturn $answer\n-    }\n-\n-    # Evaluate a target triplet list within a selector expression.\n-    # Unlike other operands, this needs to be expanded from a list to\n-    # the same string as \"target\".\n-    proc selector_list { op } {\n-\tset selector \"target [join $op]\"\n-\tset answer [ expr { [dg-process-target $selector] == \"S\" } ]\n-\tverbose \"selector_list: `$op' $answer\" 2\n-\treturn $answer\n-    }\n-\n-    # Evaluate a selector expression.\n-    proc selector_expression { exp } {\n-\tif { [llength $exp] == 2 } {\n-\t    if [string match \"!\" [lindex $exp 0]] {\n-\t\tset op1 [lindex $exp 1]\n-\t\tset answer [expr { ! [selector_opd $op1] }]\n-\t    } else {\n-\t\t# Assume it's a list of target triplets.\n-\t\tset answer [selector_list $exp]\n-\t    }\n-\t} elseif { [llength $exp] == 3 } {\n-\t    set op1 [lindex $exp 0]\n-\t    set opr [lindex $exp 1]\n-\t    set op2 [lindex $exp 2]\n-\t    if [string match \"&&\" $opr] {\n-\t\tset answer [expr { [selector_opd $op1] && [selector_opd $op2] }]\n-\t    } elseif [string match \"||\" $opr] {\n-\t\tset answer [expr { [selector_opd $op1] || [selector_opd $op2] }]\n-\t    } else {\n-\t\t# Assume it's a list of target triplets.\n-\t\tset answer [selector_list $exp]\n-\t    }\n-\t} else {\n-\t    # Assume it's a list of target triplets.\n-\t    set answer [selector_list $exp]\n-\t}\n-\n-\tverbose \"selector_expression: `$exp' $answer\" 2\n-\treturn $answer\n-    }\n-\n-    proc dg-process-target { args } {\n-\tverbose \"replacement dg-process-target: `$args'\" 2\n-\t\n-\t# Extract the 'what' keyword from the argument list.\n-\tset selector [string trim [lindex $args 0]]\n-\tif [regexp \"^xfail \" $selector] {\n-\t    set what \"xfail\"\n-\t} elseif [regexp \"^target \" $selector] {\n-\t    set what \"target\"\n-\t} else {\n-\t    error \"syntax error in target selector \\\"$selector\\\"\"\n-\t}\n-\n-\t# Extract the rest of the list, which might be a keyword.\n-\tregsub \"^${what}\" $selector \"\" rest\n-\tset rest [string trim $rest]\n-\n-\tif [is-effective-target-keyword $rest] {\n-\t    # The selector is an effective target keyword.\n-\t    if [is-effective-target $rest] {\n-\t\treturn [expr { $what == \"xfail\" ? \"F\" : \"S\" }]\n-\t    } else {\n-\t\treturn [expr { $what == \"xfail\" ? \"P\" : \"N\" }]\n-\t    }\n-\t}\n-\n-\tif [string match \"{*}\" $rest] {\n-\t    if [selector_expression [lindex $rest 0]] {\n-\t\treturn [expr { $what == \"xfail\" ? \"F\" : \"S\" }]\n-\t    } else {\n-\t\treturn [expr { $what == \"xfail\" ? \"P\" : \"N\" }]\n-\t    }\n-\t}\n-\n-\t# The selector is not an effective-target keyword, so process\n-\t# the list of target triplets.\n-\treturn [saved-dg-process-target $selector]\n-    }\n-}\n-\n set additional_prunes \"\""}, {"sha": "e3ad1d540fad9ec0d2a4fc2347cc8a7da8da895b", "filename": "gcc/testsuite/lib/target-supports-dg.exp", "status": "added", "additions": 326, "deletions": 0, "changes": 326, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a29c731dee2e306c25543443626743bff129b4f0/gcc%2Ftestsuite%2Flib%2Ftarget-supports-dg.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a29c731dee2e306c25543443626743bff129b4f0/gcc%2Ftestsuite%2Flib%2Ftarget-supports-dg.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Ftarget-supports-dg.exp?ref=a29c731dee2e306c25543443626743bff129b4f0", "patch": "@@ -0,0 +1,326 @@\n+#   Copyright (C) 1997, 1999, 2000, 2003, 2004, 2005 Free Software Foundation, Inc.\n+\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 2 of the License, or\n+# (at your option) any later version.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with this program; if not, write to the Free Software\n+# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n+\n+# If this target does not support weak symbols, skip this test.\n+\n+proc dg-require-weak { args } {\n+    set weak_available [ check_weak_available ]\n+    if { $weak_available == -1 } {\n+\tupvar name name\n+\tunresolved \"$name\"\n+    }\n+    if { $weak_available != 1 } {\n+\tupvar dg-do-what dg-do-what\n+\tset dg-do-what [list [lindex ${dg-do-what} 0] \"N\" \"P\"]\n+    }\n+}\n+\n+# If this target does not support the \"visibility\" attribute, skip this\n+# test.\n+\n+proc dg-require-visibility { args } {\n+    set visibility_available [ check_visibility_available ]\n+    if { $visibility_available == -1 } {\n+\tupvar name name\n+\tunresolved \"$name\"\n+    }\n+    if { $visibility_available != 1 } {\n+\tupvar dg-do-what dg-do-what\n+\tset dg-do-what [list [lindex ${dg-do-what} 0] \"N\" \"P\"]\n+    }\n+}\n+\n+# If this target does not support the \"alias\" attribute, skip this\n+# test.\n+\n+proc dg-require-alias { args } {\n+    set alias_available [ check_alias_available ]\n+    if { $alias_available == -1 } {\n+\tupvar name name\n+\tunresolved \"$name\"\n+    }\n+    if { $alias_available < 2 } {\n+\tupvar dg-do-what dg-do-what\n+\tset dg-do-what [list [lindex ${dg-do-what} 0] \"N\" \"P\"]\n+    }\n+}\n+\n+# If this target's linker does not support the --gc-sections flag,\n+# skip this test.\n+\n+proc dg-require-gc-sections { args } {\n+    if { ![ check_gc_sections_available ] } {\n+\tupvar dg-do-what dg-do-what\n+\tset dg-do-what [list [lindex ${dg-do-what} 0] \"N\" \"P\"]\n+    }\n+}\n+\n+# If this target does not support profiling, skip this test.\n+\n+proc dg-require-profiling { args } {\n+    if { ![ check_profiling_available ${args} ] } {\n+\tupvar dg-do-what dg-do-what\n+\tset dg-do-what [list [lindex ${dg-do-what} 0] \"N\" \"P\"]\n+    }\n+}\n+\n+# If this target does not support DLL attributes skip this test.\n+\n+proc dg-require-dll { args } {\n+    global target_triplet\n+    # As a special case, the mcore-*-elf supports these attributes.\n+    # All Symbian OS targets also support these attributes.\n+    if { [string match \"mcore-*-elf\" $target_triplet]\n+         || [string match \"*-*-symbianelf\" $target_triplet]} {\n+\treturn\n+    }\n+    # PE/COFF targets support dllimport/dllexport.\n+    if { [gcc_target_object_format] == \"pe\" } {\n+\treturn\n+    }\n+\n+    upvar dg-do-what dg-do-what\n+    set dg-do-what [list [lindex ${dg-do-what} 0] \"N\" \"P\"]\n+}\n+\n+proc dg-require-iconv { args } {\n+    if { ![ check_iconv_available ${args} ] } {\n+\tupvar dg-do-what dg-do-what\n+        set dg-do-what [list [lindex ${dg-do-what} 0] \"N\" \"P\"]\n+    }\n+}\n+\n+# If this target does not support named sections skip this test.\n+\n+proc dg-require-named-sections { args } {\n+    if { ![ check_named_sections_available ] } {\n+\tupvar dg-do-what dg-do-what\n+        set dg-do-what [list [lindex ${dg-do-what} 0] \"N\" \"P\"]\n+    }\n+}\n+\n+# If the target does not match the required effective target, skip this test.\n+\n+proc dg-require-effective-target { args } {\n+    set args [lreplace $args 0 0]\n+    if { ![is-effective-target [lindex $args 0]] } {\n+\tupvar dg-do-what dg-do-what\n+        set dg-do-what [list [lindex ${dg-do-what} 0] \"N\" \"P\"]\n+    }\n+}\n+\n+# Check the flags with which the test will be run against options in\n+# a test directive that will skip or xfail that test.  The DejaGnu proc\n+# check_conditional_xfail will look at the options in compiler_flags, so\n+# set that up for this test based on flags we know about.\n+\n+proc check_test_flags { args } {\n+    global compiler_flags\n+    upvar 2 dg-extra-tool-flags extra_tool_flags\n+\n+    # Pull the args out of the enclosing list.\n+    set args [lindex $args 0]\n+\n+    # Start the list with a dummy tool name so the list will match \"*\"\n+    # if there are no flags.\n+    set compiler_flags \" toolname \"\n+    append compiler_flags $extra_tool_flags\n+    set dest [target_info name]\n+    if [board_info $dest exists multilib_flags] {\n+\tappend compiler_flags \"[board_info $dest multilib_flags] \"\n+    }\n+\n+    set answer [check_conditional_xfail $args]\n+\n+    # Any value in this variable originally was left over from an earlier test.\n+    set compiler_flags \"\"\n+\n+    verbose \"check_test_flags: $args $answer\" 2\n+    return $answer\n+}\n+\n+# Skip the test (report it as UNSUPPORTED) if the target list and\n+# included flags are matched and the excluded flags are not matched.\n+#\n+# The first argument is the line number of the dg-skip-if directive\n+# within the test file.   Remaining arguments are as for xfail lists:\n+# message { targets } { include } { exclude }\n+#\n+# This tests against multilib flags plus either the default flags for this\n+# group of tests or flags specified with a previous dg-options command.\n+\n+proc dg-skip-if { args } {\n+    set args [lreplace $args 0 0]\n+\n+    set selector \"target [join [lindex $args 1]]\"\n+    if { [dg-process-target $selector] == \"S\" } {\n+\t# The target list matched; now check the flags.  The DejaGnu proc\n+\t# check_conditional_xfail will look at the options in compiler_flags,\n+\t# so set that up for this test based on flags we know about.  Start\n+\t# the list with a dummy tool name so the list will match \"*\" if\n+\t# there are no flags.\n+\n+\tglobal compiler_flags\n+\tupvar dg-extra-tool-flags extra_tool_flags\n+\n+\tset compiler_flags \" toolname \"\n+\tappend compiler_flags $extra_tool_flags\n+\tset dest [target_info name]\n+\tif [board_info $dest exists multilib_flags] {\n+\t    append compiler_flags \"[board_info $dest multilib_flags] \"\n+\t}\n+\n+\t# The target list might be an effective-target keyword, so replace\n+\t# the original list with \"*-*-*\".\n+\tif [check_conditional_xfail [lreplace $args 1 1 \"*-*-*\"]] {\n+\t    upvar dg-do-what dg-do-what\n+            set dg-do-what [list [lindex ${dg-do-what} 0] \"N\" \"P\"]\n+\t}\n+\n+\t# Any value in this variable was left over from an earlier test.\n+\tset compiler_flags \"\"\n+    }\n+}\n+\n+# Like check_conditional_xfail, but callable from a dg test.\n+\n+proc dg-xfail-if { args } {\n+    # Don't change anything if we're already skipping the test.\n+    upvar dg-do-what dg-do-what\n+    if { [lindex ${dg-do-what} 1] == \"N\" } {\n+      return\n+    }\n+\n+    set args [lreplace $args 0 0]\n+    set selector \"target [join [lindex $args 1]]\"\n+    if { [dg-process-target $selector] == \"S\" } {\n+\tglobal compiler_conditional_xfail_data\n+\tset compiler_conditional_xfail_data [lreplace $args 1 1 \"*-*-*\"]\n+    }\n+}\n+\n+# Intercept the call to the DejaGnu version of dg-process-target to\n+# support use of an effective-target keyword in place of a list of\n+# target triplets to xfail or skip a test.\n+#\n+# selector is one of:\n+#    xfail target-triplet-1 ...\n+#    xfail effective-target-keyword\n+#    xfail selector-expression\n+#    target target-triplet-1 ...\n+#    target effective-target-keyword\n+#    target selector-expression\n+#\n+# For a target list the result is \"S\" if the target is selected, \"N\" otherwise.\n+# For an xfail list the result is \"F\" if the target is affected, \"P\" otherwise.\n+#\n+# A selector expression appears within curly braces and uses a single logical\n+# operator: !, &&, or ||.  An operand is another selector expression, an\n+# effective-target keyword, or a list of target triplets within quotes or\n+# curly braces.\n+\n+if { [info procs saved-dg-process-target] == [list] } {\n+    rename dg-process-target saved-dg-process-target\n+\n+    # Evaluate an operand within a selector expression.\n+    proc selector_opd { op } {\n+\tset selector \"target\"\n+\tlappend selector $op\n+\tset answer [ expr { [dg-process-target $selector] == \"S\" } ]\n+\tverbose \"selector_opd: `$op' $answer\" 2\n+\treturn $answer\n+    }\n+\n+    # Evaluate a target triplet list within a selector expression.\n+    # Unlike other operands, this needs to be expanded from a list to\n+    # the same string as \"target\".\n+    proc selector_list { op } {\n+\tset selector \"target [join $op]\"\n+\tset answer [ expr { [dg-process-target $selector] == \"S\" } ]\n+\tverbose \"selector_list: `$op' $answer\" 2\n+\treturn $answer\n+    }\n+\n+    # Evaluate a selector expression.\n+    proc selector_expression { exp } {\n+\tif { [llength $exp] == 2 } {\n+\t    if [string match \"!\" [lindex $exp 0]] {\n+\t\tset op1 [lindex $exp 1]\n+\t\tset answer [expr { ! [selector_opd $op1] }]\n+\t    } else {\n+\t\t# Assume it's a list of target triplets.\n+\t\tset answer [selector_list $exp]\n+\t    }\n+\t} elseif { [llength $exp] == 3 } {\n+\t    set op1 [lindex $exp 0]\n+\t    set opr [lindex $exp 1]\n+\t    set op2 [lindex $exp 2]\n+\t    if [string match \"&&\" $opr] {\n+\t\tset answer [expr { [selector_opd $op1] && [selector_opd $op2] }]\n+\t    } elseif [string match \"||\" $opr] {\n+\t\tset answer [expr { [selector_opd $op1] || [selector_opd $op2] }]\n+\t    } else {\n+\t\t# Assume it's a list of target triplets.\n+\t\tset answer [selector_list $exp]\n+\t    }\n+\t} else {\n+\t    # Assume it's a list of target triplets.\n+\t    set answer [selector_list $exp]\n+\t}\n+\n+\tverbose \"selector_expression: `$exp' $answer\" 2\n+\treturn $answer\n+    }\n+\n+    proc dg-process-target { args } {\n+\tverbose \"replacement dg-process-target: `$args'\" 2\n+\t\n+\t# Extract the 'what' keyword from the argument list.\n+\tset selector [string trim [lindex $args 0]]\n+\tif [regexp \"^xfail \" $selector] {\n+\t    set what \"xfail\"\n+\t} elseif [regexp \"^target \" $selector] {\n+\t    set what \"target\"\n+\t} else {\n+\t    error \"syntax error in target selector \\\"$selector\\\"\"\n+\t}\n+\n+\t# Extract the rest of the list, which might be a keyword.\n+\tregsub \"^${what}\" $selector \"\" rest\n+\tset rest [string trim $rest]\n+\n+\tif [is-effective-target-keyword $rest] {\n+\t    # The selector is an effective target keyword.\n+\t    if [is-effective-target $rest] {\n+\t\treturn [expr { $what == \"xfail\" ? \"F\" : \"S\" }]\n+\t    } else {\n+\t\treturn [expr { $what == \"xfail\" ? \"P\" : \"N\" }]\n+\t    }\n+\t}\n+\n+\tif [string match \"{*}\" $rest] {\n+\t    if [selector_expression [lindex $rest 0]] {\n+\t\treturn [expr { $what == \"xfail\" ? \"F\" : \"S\" }]\n+\t    } else {\n+\t\treturn [expr { $what == \"xfail\" ? \"P\" : \"N\" }]\n+\t    }\n+\t}\n+\n+\t# The selector is not an effective-target keyword, so process\n+\t# the list of target triplets.\n+\treturn [saved-dg-process-target $selector]\n+    }\n+}"}]}