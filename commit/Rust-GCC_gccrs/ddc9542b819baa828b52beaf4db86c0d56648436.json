{"sha": "ddc9542b819baa828b52beaf4db86c0d56648436", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGRjOTU0MmI4MTliYWE4MjhiNTJiZWFmNGRiODZjMGQ1NjY0ODQzNg==", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2003-05-31T23:46:41Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@gcc.gnu.org", "date": "2003-05-31T23:46:41Z"}, "message": "toplev.c (botch): Remove.\n\n2003-05-31  Aldy Hernandez  <aldyh@redhat.com>\n\n\t* toplev.c (botch): Remove.\n\t(do_abort): Remove.\n\t(set_Wunused): Comment.\n\t(set_Wextra): Comment.\n\tRemove ^L's.\n\t(rest_of_compilation): Factor out common code into functions.\n\t(rest_of_handle_inlining): New.\n\t(rest_of_handle_ssa): New.\n\t(rest_of_handle_cse): New.\n\t(rest_of_handle_gcse): New.\n\t(rest_of_handle_loop_optimize): New.\n\t(rest_of_handle_jump_bypass): New.\n\t(rest_of_handle_sibling_calls): New.\n\t(rest_of_handle_null_pointer): New.\n\t(rest_of_handle_addresof): New.\n\t(rest_of_handle_flow): New.\n\t(rest_of_handle_branch_prob): New.\n\t(rest_of_handle_if_conversion): New.\n\t(rest_of_handle_tracer): New.\n\t(rest_of_handle_loop2): New.\n\t(rest_of_handle_cse2): New.\n\t(rest_of_handle_life): New.\n\t(rest_of_handle_combine): New.\n\t(rest_of_handle_if_after_combine): New.\n\t(rest_of_handle_regmove): New.\n\t(rest_of_handle_sched): New.\n\t(rest_of_handle_old_regalloc): New.\n\t(rest_of_handle_new_regalloc): New.\n\t(rest_of_handle_regrename): New.\n\t(rest_of_handle_reorder_blocks): New.\n\t(rest_of_handle_sched2): New.\n\t(rest_of_handle_new_regalloc): New.\n\t(rest_of_handle_old_regalloc): New.\n\t(rest_of_handle_regrename): New.\n\t(rest_of_handle_reorder_blocks): New.\n\t(rest_of_handle_stack_regs): New.\n\t(rest_of_handle_machine_reorg): New.\n\t(rest_of_handle_delay_slots): New.\n\t(rest_of_handle_final): New.\n\n\t* toplev.h (botch): Remove prototype.\n\t(do_abort): Same.\n\nFrom-SVN: r67281", "tree": {"sha": "b962abebdf751e972ae7bf78a3893cb9c679b462", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b962abebdf751e972ae7bf78a3893cb9c679b462"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ddc9542b819baa828b52beaf4db86c0d56648436", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ddc9542b819baa828b52beaf4db86c0d56648436", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ddc9542b819baa828b52beaf4db86c0d56648436", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ddc9542b819baa828b52beaf4db86c0d56648436/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c487d8b6077e9735abe832a636b43db2cd621585", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c487d8b6077e9735abe832a636b43db2cd621585", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c487d8b6077e9735abe832a636b43db2cd621585"}], "stats": {"total": 2211, "additions": 1221, "deletions": 990}, "files": [{"sha": "ec269ccc75c320491becc16aa23eb4d6ed6b742c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddc9542b819baa828b52beaf4db86c0d56648436/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddc9542b819baa828b52beaf4db86c0d56648436/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ddc9542b819baa828b52beaf4db86c0d56648436", "patch": "@@ -1,3 +1,48 @@\n+2003-05-31  Aldy Hernandez  <aldyh@redhat.com>\n+\n+        * toplev.c (botch): Remove.\n+        (do_abort): Remove.\n+        (set_Wunused): Comment.\n+        (set_Wextra): Comment.\n+        Remove ^L's.\n+        (rest_of_compilation): Factor out common code into functions.\n+        (rest_of_handle_inlining): New.\n+        (rest_of_handle_ssa): New.\n+        (rest_of_handle_cse): New.\n+        (rest_of_handle_gcse): New.\n+        (rest_of_handle_loop_optimize): New.\n+        (rest_of_handle_jump_bypass): New.\n+        (rest_of_handle_sibling_calls): New.\n+        (rest_of_handle_null_pointer): New.\n+        (rest_of_handle_addresof): New.\n+        (rest_of_handle_flow): New.\n+        (rest_of_handle_branch_prob): New.\n+        (rest_of_handle_if_conversion): New.\n+        (rest_of_handle_tracer): New.\n+        (rest_of_handle_loop2): New.\n+        (rest_of_handle_cse2): New.\n+        (rest_of_handle_life): New.\n+        (rest_of_handle_combine): New.\n+        (rest_of_handle_if_after_combine): New.\n+        (rest_of_handle_regmove): New.\n+        (rest_of_handle_sched): New.\n+        (rest_of_handle_old_regalloc): New.\n+        (rest_of_handle_new_regalloc): New.\n+        (rest_of_handle_regrename): New.\n+        (rest_of_handle_reorder_blocks): New.\n+        (rest_of_handle_sched2): New.\n+        (rest_of_handle_new_regalloc): New.\n+        (rest_of_handle_old_regalloc): New.\n+        (rest_of_handle_regrename): New.\n+        (rest_of_handle_reorder_blocks): New.\n+        (rest_of_handle_stack_regs): New.\n+        (rest_of_handle_machine_reorg): New.\n+        (rest_of_handle_delay_slots): New.\n+        (rest_of_handle_final): New.\n+\n+        * toplev.h (botch): Remove prototype.\n+        (do_abort): Same.\n+\n 2003-05-31  Neil Booth  <neil@daikokuya.co.uk>\n \n \t* Makefile.in (c-opts.o, c-options.h): Update dependencies."}, {"sha": "77a3bb9e90e3848757fa22440e0b0d00bcdc0dcc", "filename": "gcc/toplev.c", "status": "modified", "additions": 1176, "deletions": 987, "changes": 2163, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddc9542b819baa828b52beaf4db86c0d56648436/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddc9542b819baa828b52beaf4db86c0d56648436/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=ddc9542b819baa828b52beaf4db86c0d56648436", "patch": "@@ -93,7 +93,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"xcoffout.h\"\t\t/* Needed for external data\n \t\t\t\t   declarations for e.g. AIX 4.x.  */\n #endif\n-\f\n+\n /* Carry information from ASM_DECLARE_OBJECT_NAME\n    to ASM_FINISH_DECLARE_OBJECT.  */\n \n@@ -133,6 +133,43 @@ static int print_single_switch PARAMS ((FILE *, int, int, const char *,\n static void print_switch_values PARAMS ((FILE *, int, int, const char *,\n \t\t\t\t       const char *, const char *));\n \n+/* Rest of compilation helper functions.  */\n+static bool rest_of_handle_inlining (tree);\n+static rtx rest_of_handle_ssa (tree, rtx);\n+static void rest_of_handle_cse (tree, rtx);\n+static void rest_of_handle_cse2 (tree, rtx);\n+static void rest_of_handle_gcse (tree, rtx);\n+static void rest_of_handle_life (tree, rtx);\n+static void rest_of_handle_loop_optimize (tree, rtx);\n+static void rest_of_handle_loop2 (tree, rtx);\n+static void rest_of_handle_jump_bypass (tree, rtx);\n+static void rest_of_handle_sibling_calls (rtx);\n+static void rest_of_handle_null_pointer (tree, rtx);\n+static void rest_of_handle_addresof (tree, rtx);\n+static void rest_of_handle_cfg (tree, rtx);\n+static void rest_of_handle_branch_prob (tree, rtx);\n+static void rest_of_handle_if_conversion (tree, rtx);\n+static void rest_of_handle_if_after_combine (tree, rtx);\n+static void rest_of_handle_tracer (tree, rtx);\n+static void rest_of_handle_combine (tree, rtx);\n+static void rest_of_handle_regmove (tree, rtx);\n+static void rest_of_handle_sched (tree, rtx);\n+#ifdef INSN_SCHEDULING\n+static void rest_of_handle_sched2 (tree, rtx);\n+#endif\n+static bool rest_of_handle_new_regalloc (tree, rtx, int *);\n+static bool rest_of_handle_old_regalloc (tree, rtx, int *);\n+static void rest_of_handle_regrename (tree, rtx);\n+static void rest_of_handle_reorder_blocks (tree, rtx);\n+#ifdef STACK_REGS\n+static void rest_of_handle_stack_regs (tree, rtx);\n+#endif\n+static void rest_of_handle_machine_reorg (tree, rtx);\n+#ifdef DELAY_SLOTS\n+static void rest_of_handle_delay_slots (tree, rtx);\n+#endif\n+static void rest_of_handle_final (tree, rtx);\n+\n /* Nonzero to dump debug info whilst parsing (-dy option).  */\n static int set_yydebug;\n \n@@ -149,7 +186,7 @@ const char *progname;\n /* Copy of arguments to toplev_main.  */\n int save_argc;\n char **save_argv;\n-\f\n+\n /* Name of top-level original source file (what was input to cpp).\n    This comes from the #-command at the beginning of the actual input.\n    If there isn't any there, then this is the cc1 input file name.  */\n@@ -438,7 +475,6 @@ int mem_report = 0;\n    and to print them when we are done.  */\n int flag_detailed_statistics = 0;\n \n-\f\n /* -f flags.  */\n \n /* Nonzero means `char' should be signed.  */\n@@ -1437,7 +1473,7 @@ static const struct\n }\n target_options[] = TARGET_OPTIONS;\n #endif\n-\f\n+\n /* Options controlling warnings.  */\n \n /* Don't print warning messages.  -w.  */\n@@ -1596,6 +1632,7 @@ static const lang_independent_options W_options[] =\n    N_ (\"Warn about code which might break the strict aliasing rules\") }\n };\n \n+/* Initialize unused warning flags.  */\n void\n set_Wunused (setting)\n      int setting;\n@@ -1613,6 +1650,7 @@ set_Wunused (setting)\n   warn_unused_value = setting;\n }\n \n+/* Initialize more unused warning flags.  */\n static void\n set_Wextra (setting)\n      int setting;\n@@ -1655,7 +1693,6 @@ fast_math_flags_set_p ()\n \t  && !flag_errno_math);\n }\n \n-\f\n /* Output files for assembler code (real compiler output)\n    and debugging dumps.  */\n \n@@ -1693,26 +1730,7 @@ read_integral_parameter (p, pname, defval)\n \n   return atoi (p);\n }\n-\f\n-/* This calls abort and is used to avoid problems when abort is a macro.\n-   It is used when we need to pass the address of abort.  */\n-\n-void\n-do_abort ()\n-{\n-  abort ();\n-}\n \n-/* When `malloc.c' is compiled with `rcheck' defined,\n-   it calls this function to report clobberage.  */\n-\n-void\n-botch (s)\n-     const char *s ATTRIBUTE_UNUSED;\n-{\n-  abort ();\n-}\n-\f\n /* Return the logarithm of X, base 2, considering X unsigned,\n    if X is a power of 2.  Otherwise, returns -1.\n \n@@ -1877,7 +1895,7 @@ output_file_directive (asm_file, input_name)\n #endif\n #endif\n }\n-\f\n+\n /* Routine to open a dump file.  Return true if the dump file is enabled.  */\n \n static int\n@@ -2283,7 +2301,7 @@ compile_file ()\n       timevar_pop (TV_DUMP);\n     }\n }\n-\f\n+\n /* This is called from various places for FUNCTION_DECL, VAR_DECL,\n    and TYPE_DECL nodes.\n \n@@ -2424,499 +2442,451 @@ rest_of_type_compilation (type, toplev)\n   timevar_pop (TV_SYMOUT);\n }\n \n-/* This is called from finish_function (within langhooks.parse_file)\n-   after each top-level definition is parsed.\n-   It is supposed to compile that function or variable\n-   and output the assembler code for it.\n-   After we return, the tree storage is freed.  */\n-\n-void\n-rest_of_compilation (decl)\n-     tree decl;\n+/* Turn the RTL into assembly.  */\n+static void\n+rest_of_handle_final (tree decl, rtx insns)\n {\n-  rtx insns;\n-  int tem;\n-  int failure = 0;\n-  int rebuild_label_notes_after_reload;\n+  timevar_push (TV_FINAL);\n+  {\n+    rtx x;\n+    const char *fnname;\n \n-  timevar_push (TV_REST_OF_COMPILATION);\n+    /* Get the function's name, as described by its RTL.  This may be\n+       different from the DECL_NAME name used in the source file.  */\n \n-  /* Now that we're out of the frontend, we shouldn't have any more\n-     CONCATs anywhere.  */\n-  generating_concat_p = 0;\n+    x = DECL_RTL (decl);\n+    if (GET_CODE (x) != MEM)\n+      abort ();\n+    x = XEXP (x, 0);\n+    if (GET_CODE (x) != SYMBOL_REF)\n+      abort ();\n+    fnname = XSTR (x, 0);\n \n-  /* When processing delayed functions, prepare_function_start() won't\n-     have been run to re-initialize it.  */\n-  cse_not_expected = ! optimize;\n+    assemble_start_function (decl, fnname);\n+    final_start_function (insns, asm_out_file, optimize);\n+    final (insns, asm_out_file, optimize, 0);\n+    final_end_function ();\n \n-  /* First, make sure that NOTE_BLOCK is set correctly for each\n-     NOTE_INSN_BLOCK_BEG/NOTE_INSN_BLOCK_END note.  */\n-  if (!cfun->x_whole_function_mode_p)\n-    identify_blocks ();\n+#ifdef IA64_UNWIND_INFO\n+    /* ??? The IA-64 \".handlerdata\" directive must be issued before\n+       the \".endp\" directive that closes the procedure descriptor.  */\n+    output_function_exception_table ();\n+#endif\n \n-  /* In function-at-a-time mode, we do not attempt to keep the BLOCK\n-     tree in sensible shape.  So, we just recalculate it here.  */\n-  if (cfun->x_whole_function_mode_p)\n-    reorder_blocks ();\n+    assemble_end_function (decl, fnname);\n \n-  init_flow ();\n+#ifndef IA64_UNWIND_INFO\n+    /* Otherwise, it feels unclean to switch sections in the middle.  */\n+    output_function_exception_table ();\n+#endif\n \n-  /* If we are reconsidering an inline function\n-     at the end of compilation, skip the stuff for making it inline.  */\n+    if (! quiet_flag)\n+      fflush (asm_out_file);\n \n-  if (DECL_SAVED_INSNS (decl) == 0)\n-    {\n-      int inlinable = 0;\n-      tree parent;\n-      const char *lose;\n-\n-      /* If this is nested inside an inlined external function, pretend\n-\t it was only declared.  Since we cannot inline such functions,\n-\t generating code for this one is not only not necessary but will\n-\t confuse some debugging output writers.  */\n-      for (parent = DECL_CONTEXT (current_function_decl);\n-\t   parent != NULL_TREE;\n-\t   parent = get_containing_scope (parent))\n-\tif (TREE_CODE (parent) == FUNCTION_DECL\n-\t    && DECL_INLINE (parent) && DECL_EXTERNAL (parent))\n-\t  {\n-\t    DECL_INITIAL (decl) = 0;\n-\t    goto exit_rest_of_compilation;\n-\t  }\n-\telse if (TYPE_P (parent))\n-\t  /* A function in a local class should be treated normally.  */\n-\t  break;\n+    /* Release all memory allocated by flow.  */\n+    free_basic_block_vars (0);\n \n-      /* If requested, consider whether to make this function inline.  */\n-      if ((DECL_INLINE (decl) && !flag_no_inline)\n-\t  || flag_inline_functions)\n-\t{\n-\t  timevar_push (TV_INTEGRATION);\n-\t  lose = function_cannot_inline_p (decl);\n-\t  timevar_pop (TV_INTEGRATION);\n-\t  if (lose || ! optimize)\n-\t    {\n-\t      if (warn_inline && DECL_INLINE (decl))\n-\t\twarning_with_decl (decl, lose);\n-\t      DECL_ABSTRACT_ORIGIN (decl) = 0;\n-\t      /* Don't really compile an extern inline function.\n-\t\t If we can't make it inline, pretend\n-\t\t it was only declared.  */\n-\t      if (DECL_EXTERNAL (decl))\n-\t\t{\n-\t\t  DECL_INITIAL (decl) = 0;\n-\t\t  goto exit_rest_of_compilation;\n-\t\t}\n-\t    }\n-\t  else {\n-\t    /* ??? Note that we used to just make it look like if\n-\t         the \"inline\" keyword was specified when we decide\n-\t         to inline it (because of -finline-functions).\n-\t         garloff@suse.de, 2002-04-24: Add another flag to\n-\t         actually record this piece of information.  */\n-\t    if (!DECL_INLINE (decl))\n-\t       DID_INLINE_FUNC (decl) = 1;\n-\t    inlinable = DECL_INLINE (decl) = 1;\n-\t  }\n-\t}\n+    /* Release all memory held by regsets now.  */\n+    regset_release_memory ();\n+  }\n+  timevar_pop (TV_FINAL);\n \n-      insns = get_insns ();\n+  ggc_collect ();\n+}\n \n-      /* Dump the rtl code if we are dumping rtl.  */\n+#ifdef DELAY_SLOTS\n+/* Run delay slot optimization.  */\n+static void\n+rest_of_handle_delay_slots (tree decl, rtx insns)\n+{\n+  timevar_push (TV_DBR_SCHED);\n+  open_dump_file (DFI_dbr, decl);\n \n-      if (open_dump_file (DFI_rtl, decl))\n-\t{\n-\t  if (DECL_SAVED_INSNS (decl))\n-\t    fprintf (rtl_dump_file, \";; (integrable)\\n\\n\");\n-\t  close_dump_file (DFI_rtl, print_rtl, insns);\n-\t}\n+  dbr_schedule (insns, rtl_dump_file);\n \n-      /* Convert from NOTE_INSN_EH_REGION style notes, and do other\n-\t sorts of eh initialization.  Delay this until after the\n-         initial rtl dump so that we can see the original nesting.  */\n-      convert_from_eh_region_ranges ();\n-\n-      /* If function is inline, and we don't yet know whether to\n-         compile it by itself, defer decision till end of compilation.\n-         wrapup_global_declarations will (indirectly) call\n-         rest_of_compilation again for those functions that need to\n-         be output.  Also defer those functions that we are supposed\n-         to defer.  */\n-\n-      if (inlinable\n-\t  || (DECL_INLINE (decl)\n-\t      && flag_inline_functions\n-\t      && ((! TREE_PUBLIC (decl) && ! TREE_ADDRESSABLE (decl)\n-\t\t   && ! TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (decl))\n-\t\t   && ! flag_keep_inline_functions)\n-\t\t  || DECL_EXTERNAL (decl))))\n-\tDECL_DEFER_OUTPUT (decl) = 1;\n-\n-      if (DECL_INLINE (decl))\n-\t/* DWARF wants separate debugging info for abstract and\n-\t   concrete instances of all inline functions, including those\n-\t   declared inline but not inlined, and those inlined even\n-\t   though they weren't declared inline.  Conveniently, that's\n-\t   what DECL_INLINE means at this point.  */\n-\t(*debug_hooks->deferred_inline_function) (decl);\n-\n-      if (DECL_DEFER_OUTPUT (decl))\n-\t{\n-\t  /* If -Wreturn-type, we have to do a bit of compilation.  We just\n-\t     want to call cleanup the cfg to figure out whether or not we can\n-\t     fall off the end of the function; we do the minimum amount of\n-\t     work necessary to make that safe.  */\n-\t  if (warn_return_type)\n-\t    {\n-\t      int saved_optimize = optimize;\n+  close_dump_file (DFI_dbr, print_rtl, insns);\n+  timevar_pop (TV_DBR_SCHED);\n \n-\t      optimize = 0;\n-\t      rebuild_jump_labels (insns);\n-\t      find_exception_handler_labels ();\n-\t      find_basic_blocks (insns, max_reg_num (), rtl_dump_file);\n-\t      cleanup_cfg (CLEANUP_PRE_SIBCALL | CLEANUP_PRE_LOOP);\n-\t      optimize = saved_optimize;\n+  ggc_collect ();\n+}\n+#endif\n \n-\t      /* CFG is no longer maintained up-to-date.  */\n-\t      free_bb_for_insn ();\n-\t    }\n+#ifdef STACK_REGS\n+/* Convert register usage from flat register file usage to a stack\n+   register file.  */\n+static void\n+rest_of_handle_stack_regs (tree decl, rtx insns)\n+{\n+  timevar_push (TV_REG_STACK);\n+  open_dump_file (DFI_stack, decl);\n \n-\t  set_nothrow_function_flags ();\n-\t  if (current_function_nothrow)\n-\t    /* Now we know that this can't throw; set the flag for the benefit\n-\t       of other functions later in this translation unit.  */\n-\t    TREE_NOTHROW (current_function_decl) = 1;\n-\n-\t  timevar_push (TV_INTEGRATION);\n-\t  save_for_inline (decl);\n-\t  timevar_pop (TV_INTEGRATION);\n-\t  DECL_SAVED_INSNS (decl)->inlinable = inlinable;\n-\t  goto exit_rest_of_compilation;\n+  if (reg_to_stack (insns, rtl_dump_file) && optimize)\n+    {\n+      if (cleanup_cfg (CLEANUP_EXPENSIVE | CLEANUP_POST_REGSTACK\n+\t\t       | (flag_crossjumping ? CLEANUP_CROSSJUMP : 0))\n+\t  && flag_reorder_blocks)\n+\t{\n+\t  reorder_basic_blocks ();\n+\t  cleanup_cfg (CLEANUP_EXPENSIVE | CLEANUP_POST_REGSTACK);\n \t}\n-\n-      /* If specified extern inline but we aren't inlining it, we are\n-\t done.  This goes for anything that gets here with DECL_EXTERNAL\n-\t set, not just things with DECL_INLINE.  */\n-      if (DECL_EXTERNAL (decl))\n-\tgoto exit_rest_of_compilation;\n     }\n \n-  /* If we're emitting a nested function, make sure its parent gets\n-     emitted as well.  Doing otherwise confuses debug info.  */\n-  {\n-    tree parent;\n-    for (parent = DECL_CONTEXT (current_function_decl);\n-\t parent != NULL_TREE;\n-\t parent = get_containing_scope (parent))\n-      if (TREE_CODE (parent) == FUNCTION_DECL)\n-\tTREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (parent)) = 1;\n-  }\n-\n-  /* We are now committed to emitting code for this function.  Do any\n-     preparation, such as emitting abstract debug info for the inline\n-     before it gets mangled by optimization.  */\n-  if (DECL_INLINE (decl))\n-    (*debug_hooks->outlining_inline_function) (decl);\n-\n-  /* Remove any notes we don't need.  That will make iterating\n-     over the instruction sequence faster, and allow the garbage\n-     collector to reclaim the memory used by the notes.  */\n-  remove_unnecessary_notes ();\n-  reorder_blocks ();\n+  close_dump_file (DFI_stack, print_rtl_with_bb, insns);\n+  timevar_pop (TV_REG_STACK);\n \n   ggc_collect ();\n+}\n+#endif\n \n-  /* Initialize some variables used by the optimizers.  */\n-  init_function_for_compilation ();\n \n-  if (! DECL_DEFER_OUTPUT (decl))\n-    TREE_ASM_WRITTEN (decl) = 1;\n+/* Machine independent reorg pass.  */\n+static void\n+rest_of_handle_machine_reorg (tree decl, rtx insns)\n+{\n+  timevar_push (TV_MACH_DEP);\n+  open_dump_file (DFI_mach, decl);\n \n-  /* Now that integrate will no longer see our rtl, we need not\n-     distinguish between the return value of this function and the\n-     return value of called functions.  Also, we can remove all SETs\n-     of subregs of hard registers; they are only here because of\n-     integrate.  Also, we can now initialize pseudos intended to\n-     carry magic hard reg data throughout the function.  */\n-  rtx_equal_function_value_matters = 0;\n-  purge_hard_subreg_sets (get_insns ());\n+  (*targetm.machine_dependent_reorg) ();\n \n-  /* Early return if there were errors.  We can run afoul of our\n-     consistency checks, and there's not really much point in fixing them.\n-     Don't return yet if -Wreturn-type; we need to do cleanup_cfg.  */\n-  if (((rtl_dump_and_exit || flag_syntax_only) && !warn_return_type)\n-      || errorcount || sorrycount)\n-    goto exit_rest_of_compilation;\n+  close_dump_file (DFI_mach, print_rtl, insns);\n+  timevar_pop (TV_MACH_DEP);\n \n-  timevar_push (TV_JUMP);\n-  open_dump_file (DFI_sibling, decl);\n-  insns = get_insns ();\n-  rebuild_jump_labels (insns);\n-  find_exception_handler_labels ();\n-  find_basic_blocks (insns, max_reg_num (), rtl_dump_file);\n+  ggc_collect ();\n+}\n \n-  delete_unreachable_blocks ();\n \n-  /* We have to issue these warnings now already, because CFG cleanups\n-     further down may destroy the required information.  */\n-  check_function_return_warnings ();\n+/* Run new register allocator.  Return TRUE if we must exit\n+   rest_of_compilation upon return.  */\n+static bool\n+rest_of_handle_new_regalloc (tree decl, rtx insns, int *rebuild_notes)\n+{\n+  int failure;\n \n-  /* Turn NOTE_INSN_PREDICTIONs into branch predictions.  */\n-  if (flag_guess_branch_prob)\n-    {\n-      timevar_push (TV_BRANCH_PROB);\n-      note_prediction_to_br_prob ();\n-      timevar_pop (TV_BRANCH_PROB);\n-    }\n+  delete_trivially_dead_insns (insns, max_reg_num ());\n+  reg_alloc ();\n \n-  /* We may have potential sibling or tail recursion sites.  Select one\n-     (of possibly multiple) methods of performing the call.  */\n-  if (flag_optimize_sibling_calls)\n+  timevar_pop (TV_LOCAL_ALLOC);\n+  if (dump_file[DFI_lreg].enabled)\n     {\n-      rtx insn;\n-      optimize_sibling_and_tail_recursive_calls ();\n+      timevar_push (TV_DUMP);\n \n-      /* Recompute the CFG as sibling optimization clobbers it randomly.  */\n-      free_bb_for_insn ();\n-      find_exception_handler_labels ();\n-      rebuild_jump_labels (insns);\n-      find_basic_blocks (insns, max_reg_num (), rtl_dump_file);\n+      close_dump_file (DFI_lreg, NULL, NULL);\n+      timevar_pop (TV_DUMP);\n+    }\n \n-      /* There is pass ordering problem - we must lower NOTE_INSN_PREDICTION\n-         notes before simplifying cfg and we must do lowering after sibcall\n-         that unhides parts of RTL chain and cleans up the CFG.\n+  /* XXX clean up the whole mess to bring live info in shape again.  */\n+  timevar_push (TV_GLOBAL_ALLOC);\n+  open_dump_file (DFI_greg, decl);\n \n-         Until sibcall is replaced by tree-level optimizer, lets just\n-         sweep away the NOTE_INSN_PREDICTION notes that leaked out.  */\n-      for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n-\tif (GET_CODE (insn) == NOTE\n-\t    && NOTE_LINE_NUMBER (insn) == NOTE_INSN_PREDICTION)\n-\t  delete_insn (insn);\n-    }\n-  close_dump_file (DFI_sibling, print_rtl, get_insns ());\n-  timevar_pop (TV_JUMP);\n+  build_insn_chain (insns);\n+  failure = reload (insns, 0);\n \n-  scope_to_insns_initialize ();\n-  /* Complete generation of exception handling code.  */\n-  if (doing_eh (0))\n+  timevar_pop (TV_GLOBAL_ALLOC);\n+\n+  if (dump_file[DFI_greg].enabled)\n     {\n-      timevar_push (TV_JUMP);\n-      open_dump_file (DFI_eh, decl);\n+      timevar_push (TV_DUMP);\n \n-      finish_eh_generation ();\n+      dump_global_regs (rtl_dump_file);\n \n-      close_dump_file (DFI_eh, print_rtl, get_insns ());\n-      timevar_pop (TV_JUMP);\n+      close_dump_file (DFI_greg, print_rtl_with_bb, insns);\n+      timevar_pop (TV_DUMP);\n     }\n \n-  /* Delay emitting hard_reg_initial_value sets until after EH landing pad\n-     generation, which might create new sets.  */\n-  emit_initial_value_sets ();\n-\n-#ifdef FINALIZE_PIC\n-  /* If we are doing position-independent code generation, now\n-     is the time to output special prologues and epilogues.\n-     We do not want to do this earlier, because it just clutters\n-     up inline functions with meaningless insns.  */\n-  if (flag_pic)\n-    FINALIZE_PIC;\n-#endif\n+  if (failure)\n+    return true;\n \n-  insns = get_insns ();\n+  reload_completed = 1;\n+  *rebuild_notes = 0;\n \n-  /* Copy any shared structure that should not be shared.  */\n-  unshare_all_rtl (current_function_decl, insns);\n+  return false;\n+}\n \n-#ifdef SETJMP_VIA_SAVE_AREA\n-  /* This must be performed before virtual register instantiation.\n-     Please be aware the everything in the compiler that can look\n-     at the RTL up to this point must understand that REG_SAVE_AREA\n-     is just like a use of the REG contained inside.  */\n-  if (current_function_calls_alloca)\n-    optimize_save_area_alloca (insns);\n-#endif\n+/* Run old register allocator.  Return TRUE if we must exit\n+   rest_of_compilation upon return.  */\n+static bool\n+rest_of_handle_old_regalloc (tree decl, rtx insns, int *rebuild_notes)\n+{\n+  int failure;\n \n-  /* Instantiate all virtual registers.  */\n-  instantiate_virtual_regs (current_function_decl, insns);\n+  /* Allocate the reg_renumber array.  */\n+  allocate_reg_info (max_regno, FALSE, TRUE);\n \n-  open_dump_file (DFI_jump, decl);\n+  /* And the reg_equiv_memory_loc array.  */\n+  reg_equiv_memory_loc = (rtx *) xcalloc (max_regno, sizeof (rtx));\n \n-  /* Always do one jump optimization pass to ensure that JUMP_LABEL fields\n-     are initialized and to compute whether control can drop off the end\n-     of the function.  */\n+  allocate_initial_values (reg_equiv_memory_loc);\n \n-  timevar_push (TV_JUMP);\n-  /* Turn NOTE_INSN_EXPECTED_VALUE into REG_BR_PROB.  Do this\n-     before jump optimization switches branch directions.  */\n-  if (flag_guess_branch_prob)\n-    expected_value_to_br_prob ();\n+  regclass (insns, max_reg_num (), rtl_dump_file);\n+  *rebuild_notes = local_alloc ();\n \n-  reg_scan (insns, max_reg_num (), 0);\n-  rebuild_jump_labels (insns);\n-  find_basic_blocks (insns, max_reg_num (), rtl_dump_file);\n-  delete_trivially_dead_insns (insns, max_reg_num ());\n-  if (rtl_dump_file)\n-    dump_flow_info (rtl_dump_file);\n-  cleanup_cfg ((optimize ? CLEANUP_EXPENSIVE : 0) | CLEANUP_PRE_LOOP\n-\t       | (flag_thread_jumps ? CLEANUP_THREADING : 0));\n+  timevar_pop (TV_LOCAL_ALLOC);\n \n-  if (optimize)\n+  if (dump_file[DFI_lreg].enabled)\n     {\n-      free_bb_for_insn ();\n-      copy_loop_headers (insns);\n-      find_basic_blocks (insns, max_reg_num (), rtl_dump_file);\n+      timevar_push (TV_DUMP);\n+\n+      dump_flow_info (rtl_dump_file);\n+      dump_local_alloc (rtl_dump_file);\n+\n+      close_dump_file (DFI_lreg, print_rtl_with_bb, insns);\n+      timevar_pop (TV_DUMP);\n     }\n-  purge_line_number_notes (insns);\n \n-  timevar_pop (TV_JUMP);\n-  close_dump_file (DFI_jump, print_rtl, insns);\n+  ggc_collect ();\n \n-  /* Now is when we stop if -fsyntax-only and -Wreturn-type.  */\n-  if (rtl_dump_and_exit || flag_syntax_only || DECL_DEFER_OUTPUT (decl))\n+  timevar_push (TV_GLOBAL_ALLOC);\n+  open_dump_file (DFI_greg, decl);\n+\n+  /* If optimizing, allocate remaining pseudo-regs.  Do the reload\n+     pass fixing up any insns that are invalid.  */\n+\n+  if (optimize)\n+    failure = global_alloc (rtl_dump_file);\n+  else\n     {\n-      goto exit_rest_of_compilation;\n+      build_insn_chain (insns);\n+      failure = reload (insns, 0);\n     }\n \n-  /* Long term, this should probably move before the jump optimizer too,\n-     but I didn't want to disturb the rtl_dump_and_exit and related\n-     stuff at this time.  */\n-  if (optimize > 0 && flag_ssa)\n-    {\n-      /* Convert to SSA form.  */\n+  timevar_pop (TV_GLOBAL_ALLOC);\n \n-      timevar_push (TV_TO_SSA);\n-      open_dump_file (DFI_ssa, decl);\n+  if (dump_file[DFI_greg].enabled)\n+    {\n+      timevar_push (TV_DUMP);\n \n-      cleanup_cfg (CLEANUP_EXPENSIVE | CLEANUP_PRE_LOOP);\n-      convert_to_ssa ();\n+      dump_global_regs (rtl_dump_file);\n \n-      close_dump_file (DFI_ssa, print_rtl_with_bb, insns);\n-      timevar_pop (TV_TO_SSA);\n+      close_dump_file (DFI_greg, print_rtl_with_bb, insns);\n+      timevar_pop (TV_DUMP);\n+    }\n \n-      /* Perform sparse conditional constant propagation, if requested.  */\n-      if (flag_ssa_ccp)\n-\t{\n-\t  timevar_push (TV_SSA_CCP);\n-\t  open_dump_file (DFI_ssa_ccp, decl);\n+  return failure;\n+}\n \n-\t  ssa_const_prop ();\n+/* Run the regrename and cprop passes.  */\n+static void\n+rest_of_handle_regrename (tree decl, rtx insns)\n+{\n+  timevar_push (TV_RENAME_REGISTERS);\n+  open_dump_file (DFI_rnreg, decl);\n \n-\t  close_dump_file (DFI_ssa_ccp, print_rtl_with_bb, get_insns ());\n-\t  timevar_pop (TV_SSA_CCP);\n-\t}\n+  if (flag_rename_registers)\n+    regrename_optimize ();\n+  if (flag_cprop_registers)\n+    copyprop_hardreg_forward ();\n \n-      /* It would be useful to cleanup the CFG at this point, but block\n-\t merging and possibly other transformations might leave a PHI\n-\t node in the middle of a basic block, which is a strict no-no.  */\n+  close_dump_file (DFI_rnreg, print_rtl_with_bb, insns);\n+  timevar_pop (TV_RENAME_REGISTERS);\n+}\n \n-      /* The SSA implementation uses basic block numbers in its phi\n-\t nodes.  Thus, changing the control-flow graph or the basic\n-\t blocks, e.g., calling find_basic_blocks () or cleanup_cfg (),\n-\t may cause problems.  */\n+/* Reorder basic blocks.  */\n+static void\n+rest_of_handle_reorder_blocks (tree decl, rtx insns)\n+{\n+  timevar_push (TV_REORDER_BLOCKS);\n+  open_dump_file (DFI_bbro, decl);\n+\n+  /* Last attempt to optimize CFG, as scheduling, peepholing and insn\n+     splitting possibly introduced more crossjumping opportunities.  */\n+  cleanup_cfg (CLEANUP_EXPENSIVE | CLEANUP_UPDATE_LIFE\n+\t       | (flag_crossjumping ? CLEANUP_CROSSJUMP : 0));\n+\n+  if (flag_sched2_use_traces && flag_schedule_insns_after_reload)\n+    tracer ();\n+  if (flag_reorder_blocks)\n+    reorder_basic_blocks ();\n+  if (flag_reorder_blocks\n+      || (flag_sched2_use_traces && flag_schedule_insns_after_reload))\n+    cleanup_cfg (CLEANUP_EXPENSIVE | CLEANUP_UPDATE_LIFE);\n+\n+  close_dump_file (DFI_bbro, print_rtl_with_bb, insns);\n+  timevar_pop (TV_REORDER_BLOCKS);\n+}  \n+\n+/* Run instruction scheduler.  */\n+static void\n+rest_of_handle_sched (tree decl, rtx insns)\n+{\n+  timevar_push (TV_SCHED);\n+#ifdef INSN_SCHEDULING\n \n-      if (flag_ssa_dce)\n-\t{\n-\t  /* Remove dead code.  */\n+  /* Print function header into sched dump now\n+     because doing the sched analysis makes some of the dump.  */\n+  if (optimize > 0 && flag_schedule_insns)\n+    {\n+      open_dump_file (DFI_sched, decl);\n \n-\t  timevar_push (TV_SSA_DCE);\n-\t  open_dump_file (DFI_ssa_dce, decl);\n+      /* Do control and data sched analysis,\n+\t and write some of the results to dump file.  */\n \n-\t  insns = get_insns ();\n-\t  ssa_eliminate_dead_code ();\n+      schedule_insns (rtl_dump_file);\n \n-\t  close_dump_file (DFI_ssa_dce, print_rtl_with_bb, insns);\n-\t  timevar_pop (TV_SSA_DCE);\n-\t}\n+      close_dump_file (DFI_sched, print_rtl_with_bb, insns);\n+    }\n+#endif\n+  timevar_pop (TV_SCHED);\n \n-      /* Convert from SSA form.  */\n+  ggc_collect ();\n+}\n \n-      timevar_push (TV_FROM_SSA);\n-      open_dump_file (DFI_ussa, decl);\n+#ifdef INSN_SCHEDULING\n+/* Run second scheduling pass after reload.  */\n+static void\n+rest_of_handle_sched2 (tree decl, rtx insns)\n+{\n+  timevar_push (TV_SCHED2);\n+  open_dump_file (DFI_sched2, decl);\n \n-      convert_from_ssa ();\n-      /* New registers have been created.  Rescan their usage.  */\n-      reg_scan (insns, max_reg_num (), 1);\n+  /* Do control and data sched analysis again,\n+     and write some more of the results to dump file.  */\n \n-      close_dump_file (DFI_ussa, print_rtl_with_bb, insns);\n-      timevar_pop (TV_FROM_SSA);\n+  split_all_insns (1);\n \n-      ggc_collect ();\n+  if (flag_sched2_use_superblocks || flag_sched2_use_traces)\n+    {\n+      schedule_ebbs (rtl_dump_file);\n+      /* No liveness updating code yet, but it should be easy to do.\n+\t reg-stack recompute the liveness when needed for now.  */\n+      count_or_remove_death_notes (NULL, 1);\n+      cleanup_cfg (CLEANUP_EXPENSIVE);\n     }\n+  else\n+    schedule_insns (rtl_dump_file);\n \n-  timevar_push (TV_JUMP);\n-  if (optimize)\n-    cleanup_cfg (CLEANUP_EXPENSIVE | CLEANUP_PRE_LOOP);\n-\n-  /* Try to identify useless null pointer tests and delete them.  */\n-  if (flag_delete_null_pointer_checks)\n-    {\n-      open_dump_file (DFI_null, decl);\n-      if (rtl_dump_file)\n-\tdump_flow_info (rtl_dump_file);\n+  close_dump_file (DFI_sched2, print_rtl_with_bb, insns);\n+  timevar_pop (TV_SCHED2);\n \n-      if (delete_null_pointer_checks (insns))\n-        cleanup_cfg (CLEANUP_EXPENSIVE | CLEANUP_PRE_LOOP);\n+  ggc_collect ();\n+}\n+#endif\n \n-      close_dump_file (DFI_null, print_rtl_with_bb, insns);\n-    }\n+/* Register allocation pre-pass, to reduce number of moves necessary\n+   for two-address machines.  */\n+static void\n+rest_of_handle_regmove (tree decl, rtx insns)\n+{\n+  timevar_push (TV_REGMOVE);\n+  open_dump_file (DFI_regmove, decl);\n \n-  /* Jump optimization, and the removal of NULL pointer checks, may\n-     have reduced the number of instructions substantially.  CSE, and\n-     future passes, allocate arrays whose dimensions involve the\n-     maximum instruction UID, so if we can reduce the maximum UID\n-     we'll save big on memory.  */\n-  renumber_insns (rtl_dump_file);\n-  timevar_pop (TV_JUMP);\n+  regmove_optimize (insns, max_reg_num (), rtl_dump_file);\n \n-  close_dump_file (DFI_jump, print_rtl_with_bb, insns);\n+  cleanup_cfg (CLEANUP_EXPENSIVE | CLEANUP_UPDATE_LIFE);\n+  close_dump_file (DFI_regmove, print_rtl_with_bb, insns);\n+  timevar_pop (TV_REGMOVE);\n \n   ggc_collect ();\n+}\n \n-  /* Perform common subexpression elimination.\n-     Nonzero value from `cse_main' means that jumps were simplified\n-     and some code may now be unreachable, so do\n-     jump optimization again.  */\n+/* Run tracer.  */\n+static void\n+rest_of_handle_tracer (tree decl, rtx insns)\n+{\n+  timevar_push (TV_TRACER);\n+  open_dump_file (DFI_tracer, decl);\n+  if (rtl_dump_file)\n+    dump_flow_info (rtl_dump_file);\n+  tracer ();\n+  cleanup_cfg (CLEANUP_EXPENSIVE);\n+  reg_scan (insns, max_reg_num (), 0);\n+  close_dump_file (DFI_tracer, print_rtl_with_bb, get_insns ());\n+  timevar_pop (TV_TRACER);\n+}\n \n-  if (optimize > 0)\n+/* If-conversion and CFG cleanup.  */\n+static void\n+rest_of_handle_if_conversion (tree decl, rtx insns)\n+{\n+  open_dump_file (DFI_ce1, decl);\n+  if (flag_if_conversion)\n     {\n-      open_dump_file (DFI_cse, decl);\n+      timevar_push (TV_IFCVT);\n       if (rtl_dump_file)\n \tdump_flow_info (rtl_dump_file);\n-      timevar_push (TV_CSE);\n+      cleanup_cfg (CLEANUP_EXPENSIVE);\n+      reg_scan (insns, max_reg_num (), 0);\n+      if_convert (0);\n+      timevar_pop (TV_IFCVT);\n+    }\n+  timevar_push (TV_JUMP);\n+  cleanup_cfg (CLEANUP_EXPENSIVE);\n+  reg_scan (insns, max_reg_num (), 0);\n+  timevar_pop (TV_JUMP);\n+  close_dump_file (DFI_ce1, print_rtl_with_bb, get_insns ());\n+}\n \n-      reg_scan (insns, max_reg_num (), 1);\n+/* Rerun if-conversion, as combine may have simplified things enough\n+   to now meet sequence length restrictions.  */\n+static void\n+rest_of_handle_if_after_combine (tree decl, rtx insns)\n+{\n+  timevar_push (TV_IFCVT);\n+  open_dump_file (DFI_ce2, decl);\n \n-      tem = cse_main (insns, max_reg_num (), 0, rtl_dump_file);\n-      if (tem)\n-\trebuild_jump_labels (insns);\n-      purge_all_dead_edges (0);\n+  no_new_pseudos = 0;\n+  if_convert (1);\n+  no_new_pseudos = 1;\n \n-      delete_trivially_dead_insns (insns, max_reg_num ());\n+  close_dump_file (DFI_ce2, print_rtl_with_bb, insns);\n+  timevar_pop (TV_IFCVT);\n+}\n \n-      /* If we are not running more CSE passes, then we are no longer\n-\t expecting CSE to be run.  But always rerun it in a cheap mode.  */\n-      cse_not_expected = !flag_rerun_cse_after_loop && !flag_gcse;\n+/* Do branch profiling and static profile estimation passes.  */\n+static void\n+rest_of_handle_branch_prob (tree decl, rtx insns)\n+{\n+  struct loops loops;\n \n-      if (tem || optimize > 1)\n-\tcleanup_cfg (CLEANUP_EXPENSIVE | CLEANUP_PRE_LOOP);\n-      /* Try to identify useless null pointer tests and delete them.  */\n-      if (flag_delete_null_pointer_checks)\n-\t{\n-\t  timevar_push (TV_JUMP);\n+  timevar_push (TV_BRANCH_PROB);\n+  open_dump_file (DFI_bp, decl);\n+  if (profile_arc_flag || flag_test_coverage || flag_branch_probabilities)\n+    branch_prob ();\n \n-\t  if (delete_null_pointer_checks (insns))\n-\t    cleanup_cfg (CLEANUP_EXPENSIVE | CLEANUP_PRE_LOOP);\n-\t  timevar_pop (TV_JUMP);\n-\t}\n+  /* Discover and record the loop depth at the head of each basic\n+     block.  The loop infrastructure does the real job for us.  */\n+  flow_loops_find (&loops, LOOP_TREE);\n+\n+  if (rtl_dump_file)\n+    flow_loops_dump (&loops, rtl_dump_file, NULL, 0);\n \n-      /* The second pass of jump optimization is likely to have\n-         removed a bunch more instructions.  */\n-      renumber_insns (rtl_dump_file);\n+  /* Estimate using heuristics if no profiling info is available.  */\n+  if (flag_guess_branch_prob)\n+    estimate_probability (&loops);\n \n-      timevar_pop (TV_CSE);\n-      close_dump_file (DFI_cse, print_rtl_with_bb, insns);\n-    }\n+  flow_loops_free (&loops);\n+  close_dump_file (DFI_bp, print_rtl_with_bb, insns);\n+  timevar_pop (TV_BRANCH_PROB);\n+}\n+\n+/* Do control and data flow analysis; write some of the results to the\n+   dump file.  */\n+static void\n+rest_of_handle_cfg (tree decl, rtx insns)\n+{\n+  open_dump_file (DFI_cfg, decl);\n+  if (rtl_dump_file)\n+    dump_flow_info (rtl_dump_file);\n+  if (optimize)\n+    cleanup_cfg (CLEANUP_EXPENSIVE\n+\t\t | (flag_thread_jumps ? CLEANUP_THREADING : 0));\n+\n+  /* It may make more sense to mark constant functions after dead code is\n+     eliminated by life_analysis, but we need to do it early, as -fprofile-arcs\n+     may insert code making function non-constant, but we still must consider\n+     it as constant, otherwise -fbranch-probabilities will not read data back.\n+\n+     life_analysis rarely eliminates modification of external memory.\n+   */\n+  if (optimize)\n+    mark_constant_function ();\n \n+  close_dump_file (DFI_cfg, print_rtl_with_bb, insns);\n+}\n+\n+/* Purge addressofs.  */\n+static void\n+rest_of_handle_addresof (tree decl, rtx insns)\n+{\n   open_dump_file (DFI_addressof, decl);\n \n   purge_addressof (insns);\n@@ -2925,395 +2895,859 @@ rest_of_compilation (decl)\n   reg_scan (insns, max_reg_num (), 1);\n \n   close_dump_file (DFI_addressof, print_rtl, insns);\n+}\n \n-  ggc_collect ();\n+/* We may have potential sibling or tail recursion sites.  Select one\n+   (of possibly multiple) methods of performing the call.  */\n+static void\n+rest_of_handle_sibling_calls (rtx insns)\n+{\n+  rtx insn;\n+  optimize_sibling_and_tail_recursive_calls ();\n+\n+  /* Recompute the CFG as sibling optimization clobbers it randomly.  */\n+  free_bb_for_insn ();\n+  find_exception_handler_labels ();\n+  rebuild_jump_labels (insns);\n+  find_basic_blocks (insns, max_reg_num (), rtl_dump_file);\n \n-  /* Perform global cse.  */\n+  /* There is pass ordering problem - we must lower NOTE_INSN_PREDICTION\n+     notes before simplifying cfg and we must do lowering after sibcall\n+     that unhides parts of RTL chain and cleans up the CFG.\n \n-  if (optimize > 0 && flag_gcse)\n-    {\n-      int save_csb, save_cfj;\n-      int tem2 = 0;\n+     Until sibcall is replaced by tree-level optimizer, lets just\n+     sweep away the NOTE_INSN_PREDICTION notes that leaked out.  */\n+  for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n+    if (GET_CODE (insn) == NOTE\n+\t&& NOTE_LINE_NUMBER (insn) == NOTE_INSN_PREDICTION)\n+      delete_insn (insn);\n+\n+  close_dump_file (DFI_sibling, print_rtl, get_insns ());\n+}\n+\n+/* Perform jump bypassing and control flow optimizations.  */\n+static void\n+rest_of_handle_jump_bypass (tree decl, rtx insns)\n+{\n+  timevar_push (TV_BYPASS);\n+  open_dump_file (DFI_bypass, decl);\n \n-      timevar_push (TV_GCSE);\n-      open_dump_file (DFI_gcse, decl);\n+  cleanup_cfg (CLEANUP_EXPENSIVE);\n \n-      tem = gcse_main (insns, rtl_dump_file);\n+  if (bypass_jumps (rtl_dump_file))\n+    {\n       rebuild_jump_labels (insns);\n+      cleanup_cfg (CLEANUP_EXPENSIVE);\n       delete_trivially_dead_insns (insns, max_reg_num ());\n+    }\n \n-      save_csb = flag_cse_skip_blocks;\n-      save_cfj = flag_cse_follow_jumps;\n-      flag_cse_skip_blocks = flag_cse_follow_jumps = 0;\n+  close_dump_file (DFI_bypass, print_rtl_with_bb, insns);\n+  timevar_pop (TV_BYPASS);\n \n-      /* Instantiate any remaining CONSTANT_P_RTX nodes.  */\n-      if (current_function_calls_constant_p)\n-\tpurge_builtin_constant_p ();\n+  ggc_collect ();\n \n-      /* If -fexpensive-optimizations, re-run CSE to clean up things done\n-\t by gcse.  */\n-      if (flag_expensive_optimizations)\n-\t{\n-\t  timevar_push (TV_CSE);\n-\t  reg_scan (insns, max_reg_num (), 1);\n-\t  tem2 = cse_main (insns, max_reg_num (), 0, rtl_dump_file);\n-\t  purge_all_dead_edges (0);\n-\t  delete_trivially_dead_insns (insns, max_reg_num ());\n-\t  timevar_pop (TV_CSE);\n-\t  cse_not_expected = !flag_rerun_cse_after_loop;\n-\t}\n+#ifdef ENABLE_CHECKING\n+  verify_flow_info ();\n+#endif\n+}\n \n-      /* If gcse or cse altered any jumps, rerun jump optimizations to clean\n-\t things up.  Then possibly re-run CSE again.  */\n-      while (tem || tem2)\n-\t{\n-\t  tem = tem2 = 0;\n-\t  timevar_push (TV_JUMP);\n-\t  rebuild_jump_labels (insns);\n-\t  cleanup_cfg (CLEANUP_EXPENSIVE | CLEANUP_PRE_LOOP);\n-\t  timevar_pop (TV_JUMP);\n+/* Handle inlining of functions in rest_of_compilation.  Return TRUE\n+   if we must exit rest_of_compilation upon return.  */\n+static bool\n+rest_of_handle_inlining (tree decl)\n+{\n+  rtx insns;\n+  int inlinable = 0;\n+  tree parent;\n+  const char *lose;\n+\n+  /* If we are reconsidering an inline function at the end of\n+     compilation, skip the stuff for making it inline.  */\n+  if (DECL_SAVED_INSNS (decl) != 0)\n+    return 0;\n+\n+  /* If this is nested inside an inlined external function, pretend\n+     it was only declared.  Since we cannot inline such functions,\n+     generating code for this one is not only not necessary but will\n+     confuse some debugging output writers.  */\n+  for (parent = DECL_CONTEXT (current_function_decl);\n+       parent != NULL_TREE;\n+       parent = get_containing_scope (parent))\n+    if (TREE_CODE (parent) == FUNCTION_DECL\n+\t&& DECL_INLINE (parent) && DECL_EXTERNAL (parent))\n+      {\n+\tDECL_INITIAL (decl) = 0;\n+\treturn true;\n+      }\n+    else if (TYPE_P (parent))\n+      /* A function in a local class should be treated normally.  */\n+      break;\n \n-\t  if (flag_expensive_optimizations)\n+  /* If requested, consider whether to make this function inline.  */\n+  if ((DECL_INLINE (decl) && !flag_no_inline)\n+      || flag_inline_functions)\n+    {\n+      timevar_push (TV_INTEGRATION);\n+      lose = function_cannot_inline_p (decl);\n+      timevar_pop (TV_INTEGRATION);\n+      if (lose || ! optimize)\n+\t{\n+\t  if (warn_inline && DECL_INLINE (decl))\n+\t    warning_with_decl (decl, lose);\n+\t  DECL_ABSTRACT_ORIGIN (decl) = 0;\n+\t  /* Don't really compile an extern inline function.\n+\t     If we can't make it inline, pretend\n+\t     it was only declared.  */\n+\t  if (DECL_EXTERNAL (decl))\n \t    {\n-\t      timevar_push (TV_CSE);\n-\t      reg_scan (insns, max_reg_num (), 1);\n-\t      tem2 = cse_main (insns, max_reg_num (), 0, rtl_dump_file);\n-\t      purge_all_dead_edges (0);\n-\t      delete_trivially_dead_insns (insns, max_reg_num ());\n-\t      timevar_pop (TV_CSE);\n+\t      DECL_INITIAL (decl) = 0;\n+\t      return true;\n \t    }\n \t}\n-\n-      close_dump_file (DFI_gcse, print_rtl_with_bb, insns);\n-      timevar_pop (TV_GCSE);\n-\n-      ggc_collect ();\n-      flag_cse_skip_blocks = save_csb;\n-      flag_cse_follow_jumps = save_cfj;\n-#ifdef ENABLE_CHECKING\n-      verify_flow_info ();\n-#endif\n+      else {\n+\t/* ??? Note that we used to just make it look like if\n+\t   the \"inline\" keyword was specified when we decide\n+\t   to inline it (because of -finline-functions).\n+\t   garloff@suse.de, 2002-04-24: Add another flag to\n+\t   actually record this piece of information.  */\n+\tif (!DECL_INLINE (decl))\n+\t  DID_INLINE_FUNC (decl) = 1;\n+\tinlinable = DECL_INLINE (decl) = 1;\n+      }\n     }\n \n-  /* Move constant computations out of loops.  */\n+  insns = get_insns ();\n+\n+  /* Dump the rtl code if we are dumping rtl.  */\n \n-  if (optimize > 0 && flag_loop_optimize)\n+  if (open_dump_file (DFI_rtl, decl))\n     {\n-      int do_unroll, do_prefetch;\n+      if (DECL_SAVED_INSNS (decl))\n+\tfprintf (rtl_dump_file, \";; (integrable)\\n\\n\");\n+      close_dump_file (DFI_rtl, print_rtl, insns);\n+    }\n \n-      timevar_push (TV_LOOP);\n-      delete_dead_jumptables ();\n-      cleanup_cfg (CLEANUP_EXPENSIVE | CLEANUP_PRE_LOOP);\n-      open_dump_file (DFI_loop, decl);\n-      /* CFG is no longer maintained up-to-date.  */\n-      free_bb_for_insn ();\n+  /* Convert from NOTE_INSN_EH_REGION style notes, and do other\n+     sorts of eh initialization.  Delay this until after the\n+     initial rtl dump so that we can see the original nesting.  */\n+  convert_from_eh_region_ranges ();\n+\n+  /* If function is inline, and we don't yet know whether to\n+     compile it by itself, defer decision till end of compilation.\n+     wrapup_global_declarations will (indirectly) call\n+     rest_of_compilation again for those functions that need to\n+     be output.  Also defer those functions that we are supposed\n+     to defer.  */\n+\n+  if (inlinable\n+      || (DECL_INLINE (decl)\n+\t  && flag_inline_functions\n+\t  && ((! TREE_PUBLIC (decl) && ! TREE_ADDRESSABLE (decl)\n+\t       && ! TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (decl))\n+\t       && ! flag_keep_inline_functions)\n+\t      || DECL_EXTERNAL (decl))))\n+    DECL_DEFER_OUTPUT (decl) = 1;\n \n-      if (flag_unroll_loops)\n-\tdo_unroll = 0;\t\t/* Having two unrollers is useless.  */\n-      else\n-\tdo_unroll = flag_old_unroll_loops ? LOOP_UNROLL : LOOP_AUTO_UNROLL;\n-      do_prefetch = flag_prefetch_loop_arrays ? LOOP_PREFETCH : 0;\n-      if (flag_rerun_loop_opt)\n+  if (DECL_INLINE (decl))\n+    /* DWARF wants separate debugging info for abstract and\n+       concrete instances of all inline functions, including those\n+       declared inline but not inlined, and those inlined even\n+       though they weren't declared inline.  Conveniently, that's\n+       what DECL_INLINE means at this point.  */\n+    (*debug_hooks->deferred_inline_function) (decl);\n+\n+  if (DECL_DEFER_OUTPUT (decl))\n+    {\n+      /* If -Wreturn-type, we have to do a bit of compilation.  We just\n+\t want to call cleanup the cfg to figure out whether or not we can\n+\t fall off the end of the function; we do the minimum amount of\n+\t work necessary to make that safe.  */\n+      if (warn_return_type)\n \t{\n-\t  cleanup_barriers ();\n+\t  int saved_optimize = optimize;\n \n-\t  /* We only want to perform unrolling once.  */\n-\t  loop_optimize (insns, rtl_dump_file, do_unroll);\n-\t  do_unroll = 0;\n-\n-\t  /* The first call to loop_optimize makes some instructions\n-\t     trivially dead.  We delete those instructions now in the\n-\t     hope that doing so will make the heuristics in loop work\n-\t     better and possibly speed up compilation.  */\n-\t  delete_trivially_dead_insns (insns, max_reg_num ());\n+\t  optimize = 0;\n+\t  rebuild_jump_labels (insns);\n+\t  find_exception_handler_labels ();\n+\t  find_basic_blocks (insns, max_reg_num (), rtl_dump_file);\n+\t  cleanup_cfg (CLEANUP_PRE_SIBCALL | CLEANUP_PRE_LOOP);\n+\t  optimize = saved_optimize;\n \n-\t  /* The regscan pass is currently necessary as the alias\n-\t\t  analysis code depends on this information.  */\n-\t  reg_scan (insns, max_reg_num (), 1);\n+\t  /* CFG is no longer maintained up-to-date.  */\n+\t  free_bb_for_insn ();\n \t}\n-      cleanup_barriers ();\n-      loop_optimize (insns, rtl_dump_file, do_unroll | LOOP_BCT | do_prefetch);\n-\n-      /* Loop can create trivially dead instructions.  */\n-      delete_trivially_dead_insns (insns, max_reg_num ());\n-      close_dump_file (DFI_loop, print_rtl, insns);\n-      timevar_pop (TV_LOOP);\n-      find_basic_blocks (insns, max_reg_num (), rtl_dump_file);\n \n-      ggc_collect ();\n+      set_nothrow_function_flags ();\n+      if (current_function_nothrow)\n+\t/* Now we know that this can't throw; set the flag for the benefit\n+\t   of other functions later in this translation unit.  */\n+\tTREE_NOTHROW (current_function_decl) = 1;\n+\n+      timevar_push (TV_INTEGRATION);\n+      save_for_inline (decl);\n+      timevar_pop (TV_INTEGRATION);\n+      DECL_SAVED_INSNS (decl)->inlinable = inlinable;\n+      return true;\n     }\n \n-  /* Perform jump bypassing and control flow optimizations.  */\n-  if (optimize > 0 && flag_gcse)\n-    {\n-      timevar_push (TV_BYPASS);\n-      open_dump_file (DFI_bypass, decl);\n+  /* If specified extern inline but we aren't inlining it, we are\n+     done.  This goes for anything that gets here with DECL_EXTERNAL\n+     set, not just things with DECL_INLINE.  */\n+  return (bool) DECL_EXTERNAL (decl);\n+}\n \n-      cleanup_cfg (CLEANUP_EXPENSIVE);\n-      tem = bypass_jumps (rtl_dump_file);\n+/* Rest of compilation helper to convert the rtl to SSA form.  */\n+static rtx\n+rest_of_handle_ssa (tree decl, rtx insns)\n+{\n+  timevar_push (TV_TO_SSA);\n+  open_dump_file (DFI_ssa, decl);\n \n-      if (tem)\n-        {\n-          rebuild_jump_labels (insns);\n-          cleanup_cfg (CLEANUP_EXPENSIVE);\n-          delete_trivially_dead_insns (insns, max_reg_num ());\n-        }\n+  cleanup_cfg (CLEANUP_EXPENSIVE | CLEANUP_PRE_LOOP);\n+  convert_to_ssa ();\n \n-      close_dump_file (DFI_bypass, print_rtl_with_bb, insns);\n-      timevar_pop (TV_BYPASS);\n+  close_dump_file (DFI_ssa, print_rtl_with_bb, insns);\n+  timevar_pop (TV_TO_SSA);\n \n-      ggc_collect ();\n+  /* Perform sparse conditional constant propagation, if requested.  */\n+  if (flag_ssa_ccp)\n+    {\n+      timevar_push (TV_SSA_CCP);\n+      open_dump_file (DFI_ssa_ccp, decl);\n \n-#ifdef ENABLE_CHECKING\n-      verify_flow_info ();\n-#endif\n+      ssa_const_prop ();\n+\n+      close_dump_file (DFI_ssa_ccp, print_rtl_with_bb, get_insns ());\n+      timevar_pop (TV_SSA_CCP);\n     }\n \n-  /* Do control and data flow analysis; wrote some of the results to\n-     the dump file.  */\n+  /* It would be useful to cleanup the CFG at this point, but block\n+     merging and possibly other transformations might leave a PHI\n+     node in the middle of a basic block, which is a strict no-no.  */\n \n-  timevar_push (TV_FLOW);\n-  open_dump_file (DFI_cfg, decl);\n-  if (rtl_dump_file)\n-    dump_flow_info (rtl_dump_file);\n-  if (optimize)\n-    cleanup_cfg (CLEANUP_EXPENSIVE\n-\t\t | (flag_thread_jumps ? CLEANUP_THREADING : 0));\n+  /* The SSA implementation uses basic block numbers in its phi\n+     nodes.  Thus, changing the control-flow graph or the basic\n+     blocks, e.g., calling find_basic_blocks () or cleanup_cfg (),\n+     may cause problems.  */\n \n-  /* It may make more sense to mark constant functions after dead code is\n-     eliminated by life_analysis, but we need to do it early, as -fprofile-arcs\n-     may insert code making function non-constant, but we still must consider\n-     it as constant, otherwise -fbranch-probabilities will not read data back.\n+  if (flag_ssa_dce)\n+    {\n+      /* Remove dead code.  */\n \n-     life_analysis rarely eliminates modification of external memory.\n-   */\n-  if (optimize)\n-    mark_constant_function ();\n+      timevar_push (TV_SSA_DCE);\n+      open_dump_file (DFI_ssa_dce, decl);\n \n-  close_dump_file (DFI_cfg, print_rtl_with_bb, insns);\n+      insns = get_insns ();\n+      ssa_eliminate_dead_code ();\n \n-  /* Do branch profiling and static profile estimation passes.  */\n-  if (optimize > 0\n-      || profile_arc_flag || flag_test_coverage || flag_branch_probabilities)\n-    {\n-      struct loops loops;\n+      close_dump_file (DFI_ssa_dce, print_rtl_with_bb, insns);\n+      timevar_pop (TV_SSA_DCE);\n+    }\n \n-      timevar_push (TV_BRANCH_PROB);\n-      open_dump_file (DFI_bp, decl);\n-      if (profile_arc_flag || flag_test_coverage || flag_branch_probabilities)\n-\tbranch_prob ();\n+  /* Convert from SSA form.  */\n \n-      /* Discover and record the loop depth at the head of each basic\n-\t block.  The loop infrastructure does the real job for us.  */\n-      flow_loops_find (&loops, LOOP_TREE);\n+  timevar_push (TV_FROM_SSA);\n+  open_dump_file (DFI_ussa, decl);\n \n-      if (rtl_dump_file)\n-\tflow_loops_dump (&loops, rtl_dump_file, NULL, 0);\n+  convert_from_ssa ();\n+  /* New registers have been created.  Rescan their usage.  */\n+  reg_scan (insns, max_reg_num (), 1);\n \n-      /* Estimate using heuristics if no profiling info is available.  */\n-      if (flag_guess_branch_prob)\n-\testimate_probability (&loops);\n+  close_dump_file (DFI_ussa, print_rtl_with_bb, insns);\n+  timevar_pop (TV_FROM_SSA);\n \n-      flow_loops_free (&loops);\n-      close_dump_file (DFI_bp, print_rtl_with_bb, insns);\n-      timevar_pop (TV_BRANCH_PROB);\n+  ggc_collect ();\n+\n+  return insns;\n+}\n+\n+/* Try to identify useless null pointer tests and delete them.  */\n+static void\n+rest_of_handle_null_pointer (tree decl, rtx insns)\n+{\n+  open_dump_file (DFI_null, decl);\n+  if (rtl_dump_file)\n+    dump_flow_info (rtl_dump_file);\n+\n+  if (delete_null_pointer_checks (insns))\n+    cleanup_cfg (CLEANUP_EXPENSIVE | CLEANUP_PRE_LOOP);\n+\n+  close_dump_file (DFI_null, print_rtl_with_bb, insns);\n+}\n+\n+/* Try combining insns through substitution.  */\n+static void\n+rest_of_handle_combine (tree decl, rtx insns)\n+{\n+  int rebuild_jump_labels_after_combine = 0;\n+\n+  timevar_push (TV_COMBINE);\n+  open_dump_file (DFI_combine, decl);\n+\n+  rebuild_jump_labels_after_combine\n+    = combine_instructions (insns, max_reg_num ());\n+\n+  /* Combining insns may have turned an indirect jump into a\n+     direct jump.  Rebuild the JUMP_LABEL fields of jumping\n+     instructions.  */\n+  if (rebuild_jump_labels_after_combine)\n+    {\n+      timevar_push (TV_JUMP);\n+      rebuild_jump_labels (insns);\n+      timevar_pop (TV_JUMP);\n+\n+      cleanup_cfg (CLEANUP_EXPENSIVE | CLEANUP_UPDATE_LIFE);\n     }\n-  if (optimize > 0)\n+\n+  close_dump_file (DFI_combine, print_rtl_with_bb, insns);\n+  timevar_pop (TV_COMBINE);\n+\n+  ggc_collect ();\n+}\n+\n+/* Perform life analysis.  */\n+static void\n+rest_of_handle_life (tree decl, rtx insns)\n+{\n+  open_dump_file (DFI_life, decl);\n+  regclass_init ();\n+\n+#ifdef ENABLE_CHECKING\n+  verify_flow_info ();\n+#endif\n+  life_analysis (insns, rtl_dump_file, PROP_FINAL);\n+  if (optimize)\n+    cleanup_cfg ((optimize ? CLEANUP_EXPENSIVE : 0) | CLEANUP_UPDATE_LIFE\n+\t\t | (flag_thread_jumps ? CLEANUP_THREADING : 0));\n+  timevar_pop (TV_FLOW);\n+\n+  if (warn_uninitialized)\n     {\n-      open_dump_file (DFI_ce1, decl);\n-      if (flag_if_conversion)\n+      uninitialized_vars_warning (DECL_INITIAL (decl));\n+      if (extra_warnings)\n+\tsetjmp_args_warning ();\n+    }\n+\n+  if (optimize)\n+    {\n+      if (!flag_new_regalloc && initialize_uninitialized_subregs ())\n \t{\n-\t  timevar_push (TV_IFCVT);\n-\t  if (rtl_dump_file)\n-\t    dump_flow_info (rtl_dump_file);\n-\t  cleanup_cfg (CLEANUP_EXPENSIVE);\n-\t  reg_scan (insns, max_reg_num (), 0);\n-\t  if_convert (0);\n-\t  timevar_pop (TV_IFCVT);\n+\t  /* Insns were inserted, and possibly pseudos created, so\n+\t     things might look a bit different.  */\n+\t  insns = get_insns ();\n+\t  allocate_reg_life_data ();\n+\t  update_life_info (NULL, UPDATE_LIFE_GLOBAL_RM_NOTES,\n+\t\t\t    PROP_LOG_LINKS | PROP_REG_INFO | PROP_DEATH_NOTES);\n \t}\n+    }\n+\n+  no_new_pseudos = 1;\n+\n+  close_dump_file (DFI_life, print_rtl_with_bb, insns);\n+\n+  ggc_collect ();\n+}\n+\n+/* Perform common subexpression elimination.  Nonzero value from\n+   `cse_main' means that jumps were simplified and some code may now\n+   be unreachable, so do jump optimization again.  */\n+static void\n+rest_of_handle_cse (tree decl, rtx insns)\n+{\n+  int tem;\n+\n+  open_dump_file (DFI_cse, decl);\n+  if (rtl_dump_file)\n+    dump_flow_info (rtl_dump_file);\n+  timevar_push (TV_CSE);\n+\n+  reg_scan (insns, max_reg_num (), 1);\n+\n+  tem = cse_main (insns, max_reg_num (), 0, rtl_dump_file);\n+  if (tem)\n+    rebuild_jump_labels (insns);\n+  purge_all_dead_edges (0);\n+\n+  delete_trivially_dead_insns (insns, max_reg_num ());\n+\n+  /* If we are not running more CSE passes, then we are no longer\n+     expecting CSE to be run.  But always rerun it in a cheap mode.  */\n+  cse_not_expected = !flag_rerun_cse_after_loop && !flag_gcse;\n+\n+  if (tem || optimize > 1)\n+    cleanup_cfg (CLEANUP_EXPENSIVE | CLEANUP_PRE_LOOP);\n+  /* Try to identify useless null pointer tests and delete them.  */\n+  if (flag_delete_null_pointer_checks)\n+    {\n       timevar_push (TV_JUMP);\n-      cleanup_cfg (CLEANUP_EXPENSIVE);\n-      reg_scan (insns, max_reg_num (), 0);\n+\n+      if (delete_null_pointer_checks (insns))\n+\tcleanup_cfg (CLEANUP_EXPENSIVE | CLEANUP_PRE_LOOP);\n       timevar_pop (TV_JUMP);\n-      close_dump_file (DFI_ce1, print_rtl_with_bb, get_insns ());\n     }\n-  if (flag_tracer)\n+\n+  /* The second pass of jump optimization is likely to have\n+     removed a bunch more instructions.  */\n+  renumber_insns (rtl_dump_file);\n+\n+  timevar_pop (TV_CSE);\n+  close_dump_file (DFI_cse, print_rtl_with_bb, insns);\n+}\n+\n+/* Run second CSE pass after loop optimizations.  */\n+static void\n+rest_of_handle_cse2 (tree decl, rtx insns)\n+{\n+  int tem;\n+\n+  timevar_push (TV_CSE2);\n+  open_dump_file (DFI_cse2, decl);\n+  if (rtl_dump_file)\n+    dump_flow_info (rtl_dump_file);\n+  /* CFG is no longer maintained up-to-date.  */\n+  tem = cse_main (insns, max_reg_num (), 1, rtl_dump_file);\n+  purge_all_dead_edges (0);\n+  delete_trivially_dead_insns (insns, max_reg_num ());\n+\n+  if (tem)\n     {\n-      timevar_push (TV_TRACER);\n-      open_dump_file (DFI_tracer, decl);\n-      if (rtl_dump_file)\n-\tdump_flow_info (rtl_dump_file);\n-      tracer ();\n+      timevar_push (TV_JUMP);\n+      rebuild_jump_labels (insns);\n       cleanup_cfg (CLEANUP_EXPENSIVE);\n-      reg_scan (insns, max_reg_num (), 0);\n-      close_dump_file (DFI_tracer, print_rtl_with_bb, get_insns ());\n-      timevar_pop (TV_TRACER);\n+      timevar_pop (TV_JUMP);\n     }\n+  reg_scan (insns, max_reg_num (), 0);\n+  close_dump_file (DFI_cse2, print_rtl_with_bb, insns);\n+  ggc_collect ();\n+  timevar_pop (TV_CSE2);\n+}\n \n-  /* Perform loop optimalizations.  It might be better to do them a bit\n-     sooner, but we want the profile feedback to work more efficiently.  */\n-  if (optimize > 0\n-      && (flag_unswitch_loops\n-\t  || flag_peel_loops\n-\t  || flag_unroll_loops))\n-    {\n-      struct loops *loops;\n-      timevar_push (TV_LOOP);\n-      open_dump_file (DFI_loop2, decl);\n-      if (rtl_dump_file)\n-\tdump_flow_info (rtl_dump_file);\n+/* Perform global cse.  */\n+static void\n+rest_of_handle_gcse (tree decl, rtx insns)\n+{\n+  int save_csb, save_cfj;\n+  int tem2 = 0, tem;\n \n-      loops = loop_optimizer_init (rtl_dump_file);\n+  timevar_push (TV_GCSE);\n+  open_dump_file (DFI_gcse, decl);\n \n-      if (loops)\n-\t{\n-\t  /* The optimalizations:  */\n-\t  if (flag_unswitch_loops)\n-\t    unswitch_loops (loops);\n+  tem = gcse_main (insns, rtl_dump_file);\n+  rebuild_jump_labels (insns);\n+  delete_trivially_dead_insns (insns, max_reg_num ());\n \n- \t  if (flag_peel_loops || flag_unroll_loops)\n- \t    unroll_and_peel_loops (loops,\n-\t\t(flag_peel_loops ? UAP_PEEL : 0) |\n-\t\t(flag_unroll_loops ? UAP_UNROLL : 0) |\n-\t\t(flag_unroll_all_loops ? UAP_UNROLL_ALL : 0));\n+  save_csb = flag_cse_skip_blocks;\n+  save_cfj = flag_cse_follow_jumps;\n+  flag_cse_skip_blocks = flag_cse_follow_jumps = 0;\n \n-\t  loop_optimizer_finalize (loops, rtl_dump_file);\n-\t}\n+  /* Instantiate any remaining CONSTANT_P_RTX nodes.  */\n+  if (current_function_calls_constant_p)\n+    purge_builtin_constant_p ();\n \n-      cleanup_cfg (CLEANUP_EXPENSIVE);\n+  /* If -fexpensive-optimizations, re-run CSE to clean up things done\n+     by gcse.  */\n+  if (flag_expensive_optimizations)\n+    {\n+      timevar_push (TV_CSE);\n+      reg_scan (insns, max_reg_num (), 1);\n+      tem2 = cse_main (insns, max_reg_num (), 0, rtl_dump_file);\n+      purge_all_dead_edges (0);\n       delete_trivially_dead_insns (insns, max_reg_num ());\n-      reg_scan (insns, max_reg_num (), 0);\n-      if (rtl_dump_file)\n-\tdump_flow_info (rtl_dump_file);\n-      close_dump_file (DFI_loop2, print_rtl_with_bb, get_insns ());\n-      timevar_pop (TV_LOOP);\n-      ggc_collect ();\n+      timevar_pop (TV_CSE);\n+      cse_not_expected = !flag_rerun_cse_after_loop;\n     }\n \n-  if (flag_rerun_cse_after_loop)\n+  /* If gcse or cse altered any jumps, rerun jump optimizations to clean\n+     things up.  Then possibly re-run CSE again.  */\n+  while (tem || tem2)\n     {\n-      timevar_push (TV_CSE2);\n-      open_dump_file (DFI_cse2, decl);\n-      if (rtl_dump_file)\n-\tdump_flow_info (rtl_dump_file);\n-      /* CFG is no longer maintained up-to-date.  */\n-      tem = cse_main (insns, max_reg_num (), 1, rtl_dump_file);\n-      purge_all_dead_edges (0);\n-      delete_trivially_dead_insns (insns, max_reg_num ());\n+      tem = tem2 = 0;\n+      timevar_push (TV_JUMP);\n+      rebuild_jump_labels (insns);\n+      cleanup_cfg (CLEANUP_EXPENSIVE | CLEANUP_PRE_LOOP);\n+      timevar_pop (TV_JUMP);\n \n-      if (tem)\n+      if (flag_expensive_optimizations)\n \t{\n-\t  timevar_push (TV_JUMP);\n-\t  rebuild_jump_labels (insns);\n-\t  cleanup_cfg (CLEANUP_EXPENSIVE);\n-\t  timevar_pop (TV_JUMP);\n+\t  timevar_push (TV_CSE);\n+\t  reg_scan (insns, max_reg_num (), 1);\n+\t  tem2 = cse_main (insns, max_reg_num (), 0, rtl_dump_file);\n+\t  purge_all_dead_edges (0);\n+\t  delete_trivially_dead_insns (insns, max_reg_num ());\n+\t  timevar_pop (TV_CSE);\n \t}\n-      reg_scan (insns, max_reg_num (), 0);\n-      close_dump_file (DFI_cse2, print_rtl_with_bb, insns);\n-      ggc_collect ();\n-      timevar_pop (TV_CSE2);\n     }\n \n-  cse_not_expected = 1;\n-\n-  open_dump_file (DFI_life, decl);\n-  regclass_init ();\n+  close_dump_file (DFI_gcse, print_rtl_with_bb, insns);\n+  timevar_pop (TV_GCSE);\n \n+  ggc_collect ();\n+  flag_cse_skip_blocks = save_csb;\n+  flag_cse_follow_jumps = save_cfj;\n #ifdef ENABLE_CHECKING\n   verify_flow_info ();\n #endif\n-  life_analysis (insns, rtl_dump_file, PROP_FINAL);\n-  if (optimize)\n-    cleanup_cfg ((optimize ? CLEANUP_EXPENSIVE : 0) | CLEANUP_UPDATE_LIFE\n-\t\t | (flag_thread_jumps ? CLEANUP_THREADING : 0));\n-  timevar_pop (TV_FLOW);\n+}\n+\n+/* Move constant computations out of loops.  */\n+static void\n+rest_of_handle_loop_optimize (tree decl, rtx insns)\n+{\n+  int do_unroll, do_prefetch;\n+\n+  timevar_push (TV_LOOP);\n+  delete_dead_jumptables ();\n+  cleanup_cfg (CLEANUP_EXPENSIVE | CLEANUP_PRE_LOOP);\n+  open_dump_file (DFI_loop, decl);\n+\n+  /* CFG is no longer maintained up-to-date.  */\n+  free_bb_for_insn ();\n+\n+  if (flag_unroll_loops)\n+    do_unroll = 0;\t\t/* Having two unrollers is useless.  */\n+  else\n+    do_unroll = flag_old_unroll_loops ? LOOP_UNROLL : LOOP_AUTO_UNROLL;\n+  do_prefetch = flag_prefetch_loop_arrays ? LOOP_PREFETCH : 0;\n+\n+  if (flag_rerun_loop_opt)\n+    {\n+      cleanup_barriers ();\n+\n+      /* We only want to perform unrolling once.  */\n+      loop_optimize (insns, rtl_dump_file, do_unroll);\n+      do_unroll = 0;\n+\n+      /* The first call to loop_optimize makes some instructions\n+\t trivially dead.  We delete those instructions now in the\n+\t hope that doing so will make the heuristics in loop work\n+\t better and possibly speed up compilation.  */\n+      delete_trivially_dead_insns (insns, max_reg_num ());\n+\n+      /* The regscan pass is currently necessary as the alias\n+\t analysis code depends on this information.  */\n+      reg_scan (insns, max_reg_num (), 1);\n+    }\n+  cleanup_barriers ();\n+  loop_optimize (insns, rtl_dump_file, do_unroll | LOOP_BCT | do_prefetch);\n+\n+  /* Loop can create trivially dead instructions.  */\n+  delete_trivially_dead_insns (insns, max_reg_num ());\n+  close_dump_file (DFI_loop, print_rtl, insns);\n+  timevar_pop (TV_LOOP);\n+  find_basic_blocks (insns, max_reg_num (), rtl_dump_file);\n+\n+  ggc_collect ();\n+}\n+\n+/* Perform loop optimalizations.  It might be better to do them a bit\n+   sooner, but we want the profile feedback to work more\n+   efficiently.  */\n+static void\n+rest_of_handle_loop2 (tree decl, rtx insns)\n+{\n+  struct loops *loops;\n+  timevar_push (TV_LOOP);\n+  open_dump_file (DFI_loop2, decl);\n+  if (rtl_dump_file)\n+    dump_flow_info (rtl_dump_file);\n+\n+  loops = loop_optimizer_init (rtl_dump_file);\n+\n+  if (loops)\n+    {\n+      /* The optimalizations:  */\n+      if (flag_unswitch_loops)\n+\tunswitch_loops (loops);\n+\n+      if (flag_peel_loops || flag_unroll_loops)\n+\tunroll_and_peel_loops (loops,\n+\t\t\t       (flag_peel_loops ? UAP_PEEL : 0) |\n+\t\t\t       (flag_unroll_loops ? UAP_UNROLL : 0) |\n+\t\t\t       (flag_unroll_all_loops ? UAP_UNROLL_ALL : 0));\n+\n+      loop_optimizer_finalize (loops, rtl_dump_file);\n+    }\n+\n+  cleanup_cfg (CLEANUP_EXPENSIVE);\n+  delete_trivially_dead_insns (insns, max_reg_num ());\n+  reg_scan (insns, max_reg_num (), 0);\n+  if (rtl_dump_file)\n+    dump_flow_info (rtl_dump_file);\n+  close_dump_file (DFI_loop2, print_rtl_with_bb, get_insns ());\n+  timevar_pop (TV_LOOP);\n+  ggc_collect ();\n+}\n+\n+/* This is called from finish_function (within langhooks.parse_file)\n+   after each top-level definition is parsed.\n+   It is supposed to compile that function or variable\n+   and output the assembler code for it.\n+   After we return, the tree storage is freed.  */\n+\n+void\n+rest_of_compilation (decl)\n+     tree decl;\n+{\n+  rtx insns;\n+  int rebuild_label_notes_after_reload;\n+\n+  timevar_push (TV_REST_OF_COMPILATION);\n+\n+  /* Now that we're out of the frontend, we shouldn't have any more\n+     CONCATs anywhere.  */\n+  generating_concat_p = 0;\n+\n+  /* When processing delayed functions, prepare_function_start() won't\n+     have been run to re-initialize it.  */\n+  cse_not_expected = ! optimize;\n+\n+  /* First, make sure that NOTE_BLOCK is set correctly for each\n+     NOTE_INSN_BLOCK_BEG/NOTE_INSN_BLOCK_END note.  */\n+  if (!cfun->x_whole_function_mode_p)\n+    identify_blocks ();\n+\n+  /* In function-at-a-time mode, we do not attempt to keep the BLOCK\n+     tree in sensible shape.  So, we just recalculate it here.  */\n+  if (cfun->x_whole_function_mode_p)\n+    reorder_blocks ();\n+\n+  init_flow ();\n+\n+  if (rest_of_handle_inlining (decl))\n+    goto exit_rest_of_compilation;\n+\n+  /* If we're emitting a nested function, make sure its parent gets\n+     emitted as well.  Doing otherwise confuses debug info.  */\n+  {\n+    tree parent;\n+    for (parent = DECL_CONTEXT (current_function_decl);\n+\t parent != NULL_TREE;\n+\t parent = get_containing_scope (parent))\n+      if (TREE_CODE (parent) == FUNCTION_DECL)\n+\tTREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (parent)) = 1;\n+  }\n+\n+  /* We are now committed to emitting code for this function.  Do any\n+     preparation, such as emitting abstract debug info for the inline\n+     before it gets mangled by optimization.  */\n+  if (DECL_INLINE (decl))\n+    (*debug_hooks->outlining_inline_function) (decl);\n+\n+  /* Remove any notes we don't need.  That will make iterating\n+     over the instruction sequence faster, and allow the garbage\n+     collector to reclaim the memory used by the notes.  */\n+  remove_unnecessary_notes ();\n+  reorder_blocks ();\n+\n+  ggc_collect ();\n+\n+  /* Initialize some variables used by the optimizers.  */\n+  init_function_for_compilation ();\n+\n+  if (! DECL_DEFER_OUTPUT (decl))\n+    TREE_ASM_WRITTEN (decl) = 1;\n+\n+  /* Now that integrate will no longer see our rtl, we need not\n+     distinguish between the return value of this function and the\n+     return value of called functions.  Also, we can remove all SETs\n+     of subregs of hard registers; they are only here because of\n+     integrate.  Also, we can now initialize pseudos intended to\n+     carry magic hard reg data throughout the function.  */\n+  rtx_equal_function_value_matters = 0;\n+  purge_hard_subreg_sets (get_insns ());\n+\n+  /* Early return if there were errors.  We can run afoul of our\n+     consistency checks, and there's not really much point in fixing them.\n+     Don't return yet if -Wreturn-type; we need to do cleanup_cfg.  */\n+  if (((rtl_dump_and_exit || flag_syntax_only) && !warn_return_type)\n+      || errorcount || sorrycount)\n+    goto exit_rest_of_compilation;\n+\n+  timevar_push (TV_JUMP);\n+  open_dump_file (DFI_sibling, decl);\n+  insns = get_insns ();\n+  rebuild_jump_labels (insns);\n+  find_exception_handler_labels ();\n+  find_basic_blocks (insns, max_reg_num (), rtl_dump_file);\n+\n+  delete_unreachable_blocks ();\n+\n+  /* We have to issue these warnings now already, because CFG cleanups\n+     further down may destroy the required information.  */\n+  check_function_return_warnings ();\n+\n+  /* Turn NOTE_INSN_PREDICTIONs into branch predictions.  */\n+  if (flag_guess_branch_prob)\n+    {\n+      timevar_push (TV_BRANCH_PROB);\n+      note_prediction_to_br_prob ();\n+      timevar_pop (TV_BRANCH_PROB);\n+    }\n+\n+  if (flag_optimize_sibling_calls)\n+    rest_of_handle_sibling_calls (insns);\n+\n+  timevar_pop (TV_JUMP);\n+\n+  scope_to_insns_initialize ();\n+  /* Complete generation of exception handling code.  */\n+  if (doing_eh (0))\n+    {\n+      timevar_push (TV_JUMP);\n+      open_dump_file (DFI_eh, decl);\n+\n+      finish_eh_generation ();\n+\n+      close_dump_file (DFI_eh, print_rtl, get_insns ());\n+      timevar_pop (TV_JUMP);\n+    }\n+\n+  /* Delay emitting hard_reg_initial_value sets until after EH landing pad\n+     generation, which might create new sets.  */\n+  emit_initial_value_sets ();\n+\n+#ifdef FINALIZE_PIC\n+  /* If we are doing position-independent code generation, now\n+     is the time to output special prologues and epilogues.\n+     We do not want to do this earlier, because it just clutters\n+     up inline functions with meaningless insns.  */\n+  if (flag_pic)\n+    FINALIZE_PIC;\n+#endif\n+\n+  insns = get_insns ();\n+\n+  /* Copy any shared structure that should not be shared.  */\n+  unshare_all_rtl (current_function_decl, insns);\n+\n+#ifdef SETJMP_VIA_SAVE_AREA\n+  /* This must be performed before virtual register instantiation.\n+     Please be aware the everything in the compiler that can look\n+     at the RTL up to this point must understand that REG_SAVE_AREA\n+     is just like a use of the REG contained inside.  */\n+  if (current_function_calls_alloca)\n+    optimize_save_area_alloca (insns);\n+#endif\n+\n+  /* Instantiate all virtual registers.  */\n+  instantiate_virtual_regs (current_function_decl, insns);\n+\n+  open_dump_file (DFI_jump, decl);\n+\n+  /* Always do one jump optimization pass to ensure that JUMP_LABEL fields\n+     are initialized and to compute whether control can drop off the end\n+     of the function.  */\n+\n+  timevar_push (TV_JUMP);\n+  /* Turn NOTE_INSN_EXPECTED_VALUE into REG_BR_PROB.  Do this\n+     before jump optimization switches branch directions.  */\n+  if (flag_guess_branch_prob)\n+    expected_value_to_br_prob ();\n+\n+  reg_scan (insns, max_reg_num (), 0);\n+  rebuild_jump_labels (insns);\n+  find_basic_blocks (insns, max_reg_num (), rtl_dump_file);\n+  delete_trivially_dead_insns (insns, max_reg_num ());\n+  if (rtl_dump_file)\n+    dump_flow_info (rtl_dump_file);\n+  cleanup_cfg ((optimize ? CLEANUP_EXPENSIVE : 0) | CLEANUP_PRE_LOOP\n+\t       | (flag_thread_jumps ? CLEANUP_THREADING : 0));\n \n-  if (warn_uninitialized)\n+  if (optimize)\n     {\n-      uninitialized_vars_warning (DECL_INITIAL (decl));\n-      if (extra_warnings)\n-\tsetjmp_args_warning ();\n+      free_bb_for_insn ();\n+      copy_loop_headers (insns);\n+      find_basic_blocks (insns, max_reg_num (), rtl_dump_file);\n     }\n+  purge_line_number_notes (insns);\n+\n+  timevar_pop (TV_JUMP);\n+  close_dump_file (DFI_jump, print_rtl, insns);\n+\n+  /* Now is when we stop if -fsyntax-only and -Wreturn-type.  */\n+  if (rtl_dump_and_exit || flag_syntax_only || DECL_DEFER_OUTPUT (decl))\n+    goto exit_rest_of_compilation;\n+\n+  /* Long term, this should probably move before the jump optimizer too,\n+     but I didn't want to disturb the rtl_dump_and_exit and related\n+     stuff at this time.  */\n+  if (optimize > 0 && flag_ssa)\n+    insns = rest_of_handle_ssa (decl, insns);\n+\n+  timevar_push (TV_JUMP);\n \n   if (optimize)\n-    {\n-      if (!flag_new_regalloc && initialize_uninitialized_subregs ())\n-\t{\n-\t  /* Insns were inserted, and possibly pseudos created, so\n-\t     things might look a bit different.  */\n-\t  insns = get_insns ();\n-\t  allocate_reg_life_data ();\n-\t  update_life_info (NULL, UPDATE_LIFE_GLOBAL_RM_NOTES,\n-\t\t\t    PROP_LOG_LINKS | PROP_REG_INFO | PROP_DEATH_NOTES);\n-\t}\n-    }\n+    cleanup_cfg (CLEANUP_EXPENSIVE | CLEANUP_PRE_LOOP);\n \n-  no_new_pseudos = 1;\n+  if (flag_delete_null_pointer_checks)\n+    rest_of_handle_null_pointer (decl, insns);\n \n-  close_dump_file (DFI_life, print_rtl_with_bb, insns);\n+  /* Jump optimization, and the removal of NULL pointer checks, may\n+     have reduced the number of instructions substantially.  CSE, and\n+     future passes, allocate arrays whose dimensions involve the\n+     maximum instruction UID, so if we can reduce the maximum UID\n+     we'll save big on memory.  */\n+  renumber_insns (rtl_dump_file);\n+  timevar_pop (TV_JUMP);\n+\n+  close_dump_file (DFI_jump, print_rtl_with_bb, insns);\n \n   ggc_collect ();\n \n-  /* If -opt, try combining insns through substitution.  */\n+  if (optimize > 0)\n+    rest_of_handle_cse (decl, insns);\n+\n+  rest_of_handle_addresof (decl, insns);\n+\n+  ggc_collect ();\n \n   if (optimize > 0)\n     {\n-      int rebuild_jump_labels_after_combine = 0;\n+      if (flag_gcse)\n+\trest_of_handle_gcse (decl, insns);\n \n-      timevar_push (TV_COMBINE);\n-      open_dump_file (DFI_combine, decl);\n+      if (flag_loop_optimize)\n+\trest_of_handle_loop_optimize (decl, insns);\n \n-      rebuild_jump_labels_after_combine\n-\t= combine_instructions (insns, max_reg_num ());\n+      if (flag_gcse)\n+\trest_of_handle_jump_bypass (decl, insns);\n+    }\n \n-      /* Combining insns may have turned an indirect jump into a\n-\t direct jump.  Rebuild the JUMP_LABEL fields of jumping\n-\t instructions.  */\n-      if (rebuild_jump_labels_after_combine)\n-\t{\n-\t  timevar_push (TV_JUMP);\n-\t  rebuild_jump_labels (insns);\n-\t  timevar_pop (TV_JUMP);\n+  timevar_push (TV_FLOW);\n \n-\t  cleanup_cfg (CLEANUP_EXPENSIVE | CLEANUP_UPDATE_LIFE);\n-\t}\n+  rest_of_handle_cfg (decl, insns);\n \n-      close_dump_file (DFI_combine, print_rtl_with_bb, insns);\n-      timevar_pop (TV_COMBINE);\n+  if (optimize > 0\n+      || profile_arc_flag || flag_test_coverage || flag_branch_probabilities)\n+    rest_of_handle_branch_prob (decl, insns);\n \n-      ggc_collect ();\n-    }\n+  if (optimize > 0)\n+    rest_of_handle_if_conversion (decl, insns);\n \n-  /* Rerun if-conversion, as combine may have simplified things enough to\n-     now meet sequence length restrictions.  */\n-  if (flag_if_conversion)\n-    {\n-      timevar_push (TV_IFCVT);\n-      open_dump_file (DFI_ce2, decl);\n+  if (flag_tracer)\n+    rest_of_handle_tracer (decl, insns);\n \n-      no_new_pseudos = 0;\n-      if_convert (1);\n-      no_new_pseudos = 1;\n+  if (optimize > 0\n+      && (flag_unswitch_loops\n+\t  || flag_peel_loops\n+\t  || flag_unroll_loops))\n+    rest_of_handle_loop2 (decl, insns);\n \n-      close_dump_file (DFI_ce2, print_rtl_with_bb, insns);\n-      timevar_pop (TV_IFCVT);\n-    }\n+  if (flag_rerun_cse_after_loop)\n+    rest_of_handle_cse2 (decl, insns);\n \n-  /* Register allocation pre-pass, to reduce number of moves\n-     necessary for two-address machines.  */\n-  if (optimize > 0 && (flag_regmove || flag_expensive_optimizations))\n-    {\n-      timevar_push (TV_REGMOVE);\n-      open_dump_file (DFI_regmove, decl);\n+  cse_not_expected = 1;\n \n-      regmove_optimize (insns, max_reg_num (), rtl_dump_file);\n+  rest_of_handle_life (decl, insns);\n \n-      cleanup_cfg (CLEANUP_EXPENSIVE | CLEANUP_UPDATE_LIFE);\n-      close_dump_file (DFI_regmove, print_rtl_with_bb, insns);\n-      timevar_pop (TV_REGMOVE);\n+  if (optimize > 0)\n+    rest_of_handle_combine (decl, insns);\n \n-      ggc_collect ();\n-    }\n+  if (flag_if_conversion)\n+    rest_of_handle_if_after_combine (decl, insns);\n+\n+  if (optimize > 0 && (flag_regmove || flag_expensive_optimizations))\n+    rest_of_handle_regmove (decl, insns);\n \n   /* Do unconditional splitting before register allocation to allow machine\n      description to add extra information not needed previously.  */\n@@ -3334,27 +3768,7 @@ rest_of_compilation (decl)\n      (see handling of reg_known_equiv in init_alias_analysis).  */\n   recompute_reg_usage (insns, !optimize_size);\n \n-  timevar_push (TV_SCHED);\n-\n-#ifdef INSN_SCHEDULING\n-\n-  /* Print function header into sched dump now\n-     because doing the sched analysis makes some of the dump.  */\n-  if (optimize > 0 && flag_schedule_insns)\n-    {\n-      open_dump_file (DFI_sched, decl);\n-\n-      /* Do control and data sched analysis,\n-\t and write some of the results to dump file.  */\n-\n-      schedule_insns (rtl_dump_file);\n-\n-      close_dump_file (DFI_sched, print_rtl_with_bb, insns);\n-    }\n-#endif\n-  timevar_pop (TV_SCHED);\n-\n-  ggc_collect ();\n+  rest_of_handle_sched (decl, insns);\n \n   /* Determine if the current function is a leaf before running reload\n      since this can impact optimizations done by the prologue and\n@@ -3364,104 +3778,16 @@ rest_of_compilation (decl)\n   timevar_push (TV_LOCAL_ALLOC);\n   open_dump_file (DFI_lreg, decl);\n \n-  /* Allocate pseudo-regs that are used only within 1 basic block.\n-\n-     RUN_JUMP_AFTER_RELOAD records whether or not we need to rerun the\n-     jump optimizer after register allocation and reloading are finished.  */\n-\n   if (flag_new_regalloc)\n     {\n-      delete_trivially_dead_insns (insns, max_reg_num ());\n-      reg_alloc ();\n-\n-      timevar_pop (TV_LOCAL_ALLOC);\n-      if (dump_file[DFI_lreg].enabled)\n-        {\n-          timevar_push (TV_DUMP);\n-\n-          close_dump_file (DFI_lreg, NULL, NULL);\n-          timevar_pop (TV_DUMP);\n-        }\n-\n-      /* XXX clean up the whole mess to bring live info in shape again.  */\n-      timevar_push (TV_GLOBAL_ALLOC);\n-      open_dump_file (DFI_greg, decl);\n-\n-      build_insn_chain (insns);\n-      failure = reload (insns, 0);\n-\n-      timevar_pop (TV_GLOBAL_ALLOC);\n-\n-      if (dump_file[DFI_greg].enabled)\n-        {\n-          timevar_push (TV_DUMP);\n-\n-          dump_global_regs (rtl_dump_file);\n-\n-          close_dump_file (DFI_greg, print_rtl_with_bb, insns);\n-          timevar_pop (TV_DUMP);\n-        }\n-\n-      if (failure)\n-        goto exit_rest_of_compilation;\n-      reload_completed = 1;\n-      rebuild_label_notes_after_reload = 0;\n+      if (rest_of_handle_new_regalloc (decl, insns,\n+\t\t\t\t       &rebuild_label_notes_after_reload))\n+\tgoto exit_rest_of_compilation;\n     }\n   else\n     {\n-      /* Allocate the reg_renumber array.  */\n-      allocate_reg_info (max_regno, FALSE, TRUE);\n-\n-      /* And the reg_equiv_memory_loc array.  */\n-      reg_equiv_memory_loc = (rtx *) xcalloc (max_regno, sizeof (rtx));\n-\n-      allocate_initial_values (reg_equiv_memory_loc);\n-\n-      regclass (insns, max_reg_num (), rtl_dump_file);\n-      rebuild_label_notes_after_reload = local_alloc ();\n-\n-      timevar_pop (TV_LOCAL_ALLOC);\n-\n-      if (dump_file[DFI_lreg].enabled)\n-\t{\n-\t  timevar_push (TV_DUMP);\n-\n-\t  dump_flow_info (rtl_dump_file);\n-\t  dump_local_alloc (rtl_dump_file);\n-\n-\t  close_dump_file (DFI_lreg, print_rtl_with_bb, insns);\n-\t  timevar_pop (TV_DUMP);\n-\t}\n-\n-      ggc_collect ();\n-\n-      timevar_push (TV_GLOBAL_ALLOC);\n-      open_dump_file (DFI_greg, decl);\n-\n-      /* If optimizing, allocate remaining pseudo-regs.  Do the reload\n-\t pass fixing up any insns that are invalid.  */\n-\n-      if (optimize)\n-\tfailure = global_alloc (rtl_dump_file);\n-      else\n-\t{\n-\t  build_insn_chain (insns);\n-\t  failure = reload (insns, 0);\n-\t}\n-\n-      timevar_pop (TV_GLOBAL_ALLOC);\n-\n-      if (dump_file[DFI_greg].enabled)\n-\t{\n-\t  timevar_push (TV_DUMP);\n-\n-\t  dump_global_regs (rtl_dump_file);\n-\n-\t  close_dump_file (DFI_greg, print_rtl_with_bb, insns);\n-\t  timevar_pop (TV_DUMP);\n-\t}\n-\n-      if (failure)\n+      if (rest_of_handle_old_regalloc (decl, insns,\n+\t\t\t\t       &rebuild_label_notes_after_reload))\n \tgoto exit_rest_of_compilation;\n     }\n \n@@ -3551,40 +3877,12 @@ rest_of_compilation (decl)\n     }\n #endif\n \n-  if (optimize > 0 && (flag_rename_registers || flag_cprop_registers))\n-    {\n-      timevar_push (TV_RENAME_REGISTERS);\n-      open_dump_file (DFI_rnreg, decl);\n-\n-      if (flag_rename_registers)\n-\tregrename_optimize ();\n-      if (flag_cprop_registers)\n-\tcopyprop_hardreg_forward ();\n-\n-      close_dump_file (DFI_rnreg, print_rtl_with_bb, insns);\n-      timevar_pop (TV_RENAME_REGISTERS);\n-    }\n-\n   if (optimize > 0)\n     {\n-      timevar_push (TV_REORDER_BLOCKS);\n-      open_dump_file (DFI_bbro, decl);\n-\n-      /* Last attempt to optimize CFG, as scheduling, peepholing and insn\n-\t splitting possibly introduced more crossjumping opportunities.  */\n-      cleanup_cfg (CLEANUP_EXPENSIVE | CLEANUP_UPDATE_LIFE\n-\t\t   | (flag_crossjumping ? CLEANUP_CROSSJUMP : 0));\n+      if (flag_rename_registers || flag_cprop_registers)\n+\trest_of_handle_regrename (decl, insns);\n \n-      if (flag_sched2_use_traces && flag_schedule_insns_after_reload)\n-        tracer ();\n-      if (flag_reorder_blocks)\n-\treorder_basic_blocks ();\n-      if (flag_reorder_blocks\n-\t  || (flag_sched2_use_traces && flag_schedule_insns_after_reload))\n-\t  cleanup_cfg (CLEANUP_EXPENSIVE | CLEANUP_UPDATE_LIFE);\n-\n-      close_dump_file (DFI_bbro, print_rtl_with_bb, insns);\n-      timevar_pop (TV_REORDER_BLOCKS);\n+      rest_of_handle_reorder_blocks (decl, insns);\n     }\n \n   if (flag_if_conversion2)\n@@ -3600,31 +3898,7 @@ rest_of_compilation (decl)\n \n #ifdef INSN_SCHEDULING\n   if (optimize > 0 && flag_schedule_insns_after_reload)\n-    {\n-      timevar_push (TV_SCHED2);\n-      open_dump_file (DFI_sched2, decl);\n-\n-      /* Do control and data sched analysis again,\n-\t and write some more of the results to dump file.  */\n-\n-      split_all_insns (1);\n-\n-      if (flag_sched2_use_superblocks || flag_sched2_use_traces)\n-\t{\n-\t  schedule_ebbs (rtl_dump_file);\n-\t  /* No liveness updating code yet, but it should be easy to do.\n-\t     reg-stack recompute the liveness when needed for now.  */\n-\t  count_or_remove_death_notes (NULL, 1);\n-\t  cleanup_cfg (CLEANUP_EXPENSIVE);\n-\t}\n-      else\n-        schedule_insns (rtl_dump_file);\n-\n-      close_dump_file (DFI_sched2, print_rtl_with_bb, insns);\n-      timevar_pop (TV_SCHED2);\n-\n-      ggc_collect ();\n-    }\n+    rest_of_handle_sched2 (decl, insns);\n #endif\n \n #ifdef LEAF_REGISTERS\n@@ -3633,63 +3907,23 @@ rest_of_compilation (decl)\n #endif\n \n #ifdef STACK_REGS\n-  timevar_push (TV_REG_STACK);\n-  open_dump_file (DFI_stack, decl);\n-\n-  if (reg_to_stack (insns, rtl_dump_file) && optimize)\n-    {\n-      if (cleanup_cfg (CLEANUP_EXPENSIVE | CLEANUP_POST_REGSTACK\n-\t\t       | (flag_crossjumping ? CLEANUP_CROSSJUMP : 0))\n-\t  && flag_reorder_blocks)\n-\t{\n-\t  reorder_basic_blocks ();\n-\t  cleanup_cfg (CLEANUP_EXPENSIVE | CLEANUP_POST_REGSTACK);\n-\t}\n-    }\n-\n-  close_dump_file (DFI_stack, print_rtl_with_bb, insns);\n-  timevar_pop (TV_REG_STACK);\n-\n-  ggc_collect ();\n+  rest_of_handle_stack_regs (decl, insns);\n #endif\n+\n   compute_alignments ();\n \n   /* CFG is no longer maintained up-to-date.  */\n   free_bb_for_insn ();\n \n-  /* If a machine dependent reorganization is needed, call it.  */\n   if (targetm.machine_dependent_reorg != 0)\n-    {\n-      timevar_push (TV_MACH_DEP);\n-      open_dump_file (DFI_mach, decl);\n-\n-      (*targetm.machine_dependent_reorg) ();\n-\n-      close_dump_file (DFI_mach, print_rtl, insns);\n-      timevar_pop (TV_MACH_DEP);\n-\n-      ggc_collect ();\n-    }\n+    rest_of_handle_machine_reorg (decl, insns);\n \n   purge_line_number_notes (insns);\n   cleanup_barriers ();\n \n-  /* If a scheduling pass for delayed branches is to be done,\n-     call the scheduling code.  */\n-\n #ifdef DELAY_SLOTS\n   if (optimize > 0 && flag_delayed_branch)\n-    {\n-      timevar_push (TV_DBR_SCHED);\n-      open_dump_file (DFI_dbr, decl);\n-\n-      dbr_schedule (insns, rtl_dump_file);\n-\n-      close_dump_file (DFI_dbr, print_rtl, insns);\n-      timevar_pop (TV_DBR_SCHED);\n-\n-      ggc_collect ();\n-    }\n+    rest_of_handle_delay_slots (decl, insns);\n #endif\n \n #if defined (HAVE_ATTR_length) && !defined (STACK_REGS)\n@@ -3711,54 +3945,7 @@ rest_of_compilation (decl)\n        of other functions later in this translation unit.  */\n     TREE_NOTHROW (current_function_decl) = 1;\n \n-  /* Now turn the rtl into assembler code.  */\n-\n-  timevar_push (TV_FINAL);\n-  {\n-    rtx x;\n-    const char *fnname;\n-\n-    /* Get the function's name, as described by its RTL.  This may be\n-       different from the DECL_NAME name used in the source file.  */\n-\n-    x = DECL_RTL (decl);\n-    if (GET_CODE (x) != MEM)\n-      abort ();\n-    x = XEXP (x, 0);\n-    if (GET_CODE (x) != SYMBOL_REF)\n-      abort ();\n-    fnname = XSTR (x, 0);\n-\n-    assemble_start_function (decl, fnname);\n-    final_start_function (insns, asm_out_file, optimize);\n-    final (insns, asm_out_file, optimize, 0);\n-    final_end_function ();\n-\n-#ifdef IA64_UNWIND_INFO\n-    /* ??? The IA-64 \".handlerdata\" directive must be issued before\n-       the \".endp\" directive that closes the procedure descriptor.  */\n-    output_function_exception_table ();\n-#endif\n-\n-    assemble_end_function (decl, fnname);\n-\n-#ifndef IA64_UNWIND_INFO\n-    /* Otherwise, it feels unclean to switch sections in the middle.  */\n-    output_function_exception_table ();\n-#endif\n-\n-    if (! quiet_flag)\n-      fflush (asm_out_file);\n-\n-    /* Release all memory allocated by flow.  */\n-    free_basic_block_vars (0);\n-\n-    /* Release all memory held by regsets now.  */\n-    regset_release_memory ();\n-  }\n-  timevar_pop (TV_FINAL);\n-\n-  ggc_collect ();\n+  rest_of_handle_final (decl, insns);\n \n   /* Write DBX symbols if requested.  */\n \n@@ -3842,7 +4029,8 @@ rest_of_compilation (decl)\n \n   timevar_pop (TV_REST_OF_COMPILATION);\n }\n-\f\n+\n+/* Display help for generic options.  */\n static void\n display_help ()\n {\n@@ -3976,6 +4164,7 @@ display_help ()\n   display_target_options ();\n }\n \n+/* Display help for target options.  */\n static void\n display_target_options ()\n {\n@@ -4045,7 +4234,7 @@ display_target_options ()\n \t}\n     }\n }\n-\f\n+\n /* Parse a -d... command line switch.  */\n \n static void\n@@ -4662,7 +4851,7 @@ independent_decode_option (argc, argv)\n \n   return 1;\n }\n-\f\n+\n /* Decode -m switches.  */\n /* Decode the switch -mNAME.  */\n \n@@ -4717,7 +4906,7 @@ set_target_switch (name)\n   if (!valid_target_option)\n     error (\"invalid option `%s'\", name);\n }\n-\f\n+\n /* Print version information to FILE.\n    Each line begins with INDENT (for the case where FILE is the\n    assembler output file).  */\n@@ -4858,7 +5047,7 @@ print_switch_values (file, pos, max, indent, sep, term)\n \n   fprintf (file, \"%s\", term);\n }\n-\f\n+\n /* Open assembly code output file.  Do this even if -fsyntax-only is\n    on, because then the driver will have provided the name of a\n    temporary file or bit bucket for us.  NAME is the file specified on\n@@ -4913,7 +5102,7 @@ init_asm_output (name)\n #endif\n     }\n }\n-\f\n+\n /* Initialization of the front end environment, before command line\n    options are parsed.  Signal handlers, internationalization etc.\n    ARGV0 is main's argv[0].  */\n@@ -4967,7 +5156,7 @@ general_init (argv0)\n   init_stringpool ();\n   init_ttree ();\n }\n-\f\n+\n /* Parse command line options and set default flag values, called\n    after language-independent option-independent initialization.  Do\n    minimal options processing.  Outputting diagnostics is OK, but GC\n@@ -5217,7 +5406,7 @@ parse_options_and_default_flags (argc, argv)\n   if (flag_really_no_inline == 2)\n     flag_really_no_inline = flag_no_inline;\n }\n-\f\n+\n /* Process the options that have been parsed.  */\n static void\n process_options ()\n@@ -5428,7 +5617,7 @@ process_options ()\n     if (flag_signaling_nans)\n       flag_trapping_math = 1;\n }\n-\f\n+\n /* Initialize the compiler back end.  */\n static void\n backend_init ()\n@@ -5459,7 +5648,7 @@ backend_init ()\n     init_caller_save ();\n   expand_dummy_function_end ();\n }\n-\f\n+\n /* Language-dependent initialization.  Returns nonzero on success.  */\n static int\n lang_dependent_init (name)\n@@ -5505,7 +5694,7 @@ lang_dependent_init (name)\n \n   return 1;\n }\n-\f\n+\n /* Clean up: close opened files, etc.  */\n \n static void\n@@ -5562,7 +5751,7 @@ finalize ()\n   /* Language-specific end of compilation actions.  */\n   (*lang_hooks.finish) ();\n }\n-\f\n+\n /* Initialize the compiler, and compile the input file.  */\n static void\n do_compile ()\n@@ -5593,7 +5782,7 @@ do_compile ()\n   timevar_stop (TV_TOTAL);\n   timevar_print (stderr);\n }\n-\f\n+\n /* Entry point of cc1, cc1plus, jc1, f771, etc.\n    Decode command args, then call compile_file.\n    Exit code is FATAL_EXIT_CODE if can't open files or if there were"}, {"sha": "1f77e3268381dbd03410afc2d261ab6192c0b6d9", "filename": "gcc/toplev.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddc9542b819baa828b52beaf4db86c0d56648436/gcc%2Ftoplev.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddc9542b819baa828b52beaf4db86c0d56648436/gcc%2Ftoplev.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.h?ref=ddc9542b819baa828b52beaf4db86c0d56648436", "patch": "@@ -84,9 +84,6 @@ extern void output_clean_symbol_name    PARAMS ((FILE *, const char *));\n extern void output_quoted_string\tPARAMS ((FILE *, const char *));\n extern void output_file_directive\tPARAMS ((FILE *, const char *));\n #endif\n-extern void do_abort\t\t\tPARAMS ((void)) ATTRIBUTE_NORETURN;\n-extern void botch\t\t\tPARAMS ((const char *))\n-  ATTRIBUTE_NORETURN;\n \n #ifdef BUFSIZ\n   /* N.B. Unlike all the others, fnotice is just gettext+fprintf, and"}]}