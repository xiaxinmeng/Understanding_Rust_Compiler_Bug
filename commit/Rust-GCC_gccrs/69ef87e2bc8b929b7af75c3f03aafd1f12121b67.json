{"sha": "69ef87e2bc8b929b7af75c3f03aafd1f12121b67", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjllZjg3ZTJiYzhiOTI5YjdhZjc1YzNmMDNhYWZkMWYxMjEyMWI2Nw==", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@gcc.gnu.org", "date": "2002-02-19T02:53:41Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@gcc.gnu.org", "date": "2002-02-19T02:53:41Z"}, "message": "i386.md (\"mmx_uavgv8qi3\"): Use const_vector.\n\n2002-02-19  Aldy Hernandez  <aldyh@redhat.com>\n\n\t* config/i386/i386.md (\"mmx_uavgv8qi3\"): Use const_vector.\n\t(\"mmx_uavgv4hi3\"): Same.\n\t(\"pmulhrwv4hi3\"): Same.\n\n\t* tree-inline.c (walk_tree): Handle vectors.\n\n\t* c-common.c (constant_expression_warning): Handle vectors.\n\t(overflow_warning): Same.\n\n\t* sched-deps.c (sched_analyze_2): Handle vectors.\n\n\t* rtlanal.c (rtx_unstable_p): Handle vectors.\n\t(rtx_varies_p): Same.\n\t(count_occurrences): Same.\n\t(regs_set_between_p): Same.\n\t(modified_between_p): Same.\n\t(modified_in_p): Same.\n\t(volatile_insn_p): Same.\n\t(volatile_refs_p): Same.\n\t(side_effects_p): Same.\n\t(may_trap_p): Same.\n\t(inequality_comparisons_p): Same.\n\t(replace_regs): Same.\n\t(computed_jump_p_1): Same.\n\n\t* rtl.c (DEF_MACHMODE): Change all definitions to accept 8th\n\targument.\n\t(inner_mode_array): New.\n\t(copy_rtx): Handle vectors.\n\t(copy_most_rtx): Same.\n\t(rtx_equal_p): Same.\n\t(get_mode_alignment): Adjust for vectors.\n\n\t* resource.c (mark_referenced_resources): Handle vectors.\n\t(mark_set_resources): Same.\n\n\t* reload1.c (eliminate_regs): Handle vectors.\n\t(elimination_effects): Same.\n\t(scan_paradoxical_subregs): Same.\n\n\t* reload.c (subst_reg_equivs): Handle vectors.\n\n\t* regrename.c (scan_rtx): Handle vectors.\n\n\t* regclass.c (reg_scan_mark_refs): Handle vectors.\n\n\t* recog.c (find_single_use_1): Handle vectors.\n\n\t* local-alloc.c (equiv_init_varies_p): Handle vectors.\n\t(contains_replace_regs): Same.\n\t(memref_referenced_p): Same.\n\n\t* integrate.c (copy_rtx_and_substitute): Handle vectors.\n\t(subst_constants): Same.\n\n\t* genattrtab.c (attr_copy_rtx): Handle vectors.\n\t(encode_units_mask): Same.\n\t(clear_struct_flag): Same.\n\t(count_sub_rtxs): Same.\n\n\t* gcse.c (want_to_gcse_p): Handle vectors.\n\t(oprs_unchanged_p): Same.\n\t(hash_expr_1): Same.\n\t(oprs_not_set_p): Same.\n\t(expr_killed_p): Same.\n\t(compute_transp): Same.\n\t(store_ops_ok): Same.\n\n\t* function.c (purge_addressof_1): Do not allow paradoxical subregs\n\tof vectors.\n\t(fixup_var_refs_1): Same.\n\t(instantiate_virtual_regs_1): Same.\n\n\t* fold-const.c (operand_equal_p): Handle vectors.\n\t(fold): Same.\n\t(rtl_expr_nonnegative_p): Same.\n\n\t* flow.c (mark_used_regs): Handle vectors.\n\n\t* df.c (df_uses_record): Handle vectors.\n\n\t* cselib.c (cselib_subst_to_values): Handle vectors.\n\t(cselib_mem_conflict_p): Same.\n\t(hash_rtx): Same.\n\n\t* cse.c (canon_reg): Handle vectors.\n\t(fold_rt): Same.\n\t(cse_process_notes): Same.\n\t(count_reg_usage): Same.\n\t(canon_hash): Same.\n\n\t* alias.c (nonlocal_mentioned_p): Add case for CONST_VECTOR.\n\n\t* combine.c (mark_used_regs_combine): Add case for CONST_VECTOR.\n\n\t* emit-rtl.c (init_emit_once): Generate const0_rtx for vectors.\n\t(gen_rtx): Handle CONST_VECTOR.\n\t(gen_const_vector_0): New.\n\t(copy_rtx_if_shared): CONST_VECTORs can be shared.\n\t(reset_used_flags): Same.\n\t(copy_insn_1): Same.\n\t(initializer_constant_valid_p): Handle VECTOR_CST.\n\n\t* doc/c-tree.texi (Expression trees): Document VECTOR_CST.\n\n\t* doc/rtl.texi (Constants): Document const_vector.\n\t(CONST0_RTX): Update for vectors.\n\t(RTL sharing): Same.\n\n\t* print-tree.c (print_node): Add case for VECTOR_CST.\n\n\t* tree.h (TREE_VECTOR_CST_ELTS): New.\n\t(struct tree_vector): New.\n\t(union tree_node): Add vector node.\n\t(build_vector): Add prototype.\n\n\t* tree.def (VECTOR_CST): New.\n\n\t* tree.c (build_vector): New.\n\n\t* expmed.c (make_tree): Handle CONST_VECTOR.\n\n\t* rtl.h (CONSTANT_P): CONST_VECTORs are constants too.\n\t(CONST_VECTOR_ELT): New.\n\t(CONST_VECTOR_NUNITS): New.\n\n\t* machmode.h (GET_MODE_INNER): New.\n\t(DEF_MACHMODE): Accept 8th arg.\n\n\t* machmode.def: Add 8th argument for vector inner mode.\n\tAdd inner vector modes for vectors.\n\n\t* rtl.def (VEC_CONST): Remove.\n\t(CONST_VECTOR): New.\n\n\t* expr.c (clear_storage): Allow vectors.\n\t(is_zeros_p): Handle VECTOR_CST.\n\n\t* varasm.c (output_constant_pool): Handle vectors.\n\t(rtx_const): Add veclo and vechi fields.\n\t(kind): Add RTX_VECTOR.\n\t(decode_rtx_const): Add case for vector.\n\n\t* config/rs6000/rs6000-protos.h: Add zero_constant.\n\n\t* config/rs6000/rs6000.c (rs6000_emit_move): Handle vector\n\tconstants.  Force easy vector constants into memory.\n\t(easy_vector_constant): New.\n\t(emit_easy_vector_constant): New.\n\t(rs6000_legitimize_reload_address): Do not generate bad reloads on\n\tdarwin.\n\n\t* config/rs6000/rs6000.md (\"altivec_lvx\"): Reflect what\n\tinstruction does.\n\t(\"altivec_lvxl\"): Same.\n\t(altivec_lvebx): Same.\n\t(altivec_lvehx): Same.\n\t(altivec_lvewx): Same.\n\t(\"*movv4si_const0\"): New.\n\t(\"*movv4sf_const0\"): New.\n\t(\"*movv8hi_const0\"): New.\n\t(\"*movv16qi_const0\"): New.\n\nFrom-SVN: r49853", "tree": {"sha": "2c0a4b4f6d2f35e63ff2d03006bbc29f28ccb665", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2c0a4b4f6d2f35e63ff2d03006bbc29f28ccb665"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/69ef87e2bc8b929b7af75c3f03aafd1f12121b67", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/69ef87e2bc8b929b7af75c3f03aafd1f12121b67", "html_url": "https://github.com/Rust-GCC/gccrs/commit/69ef87e2bc8b929b7af75c3f03aafd1f12121b67", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/69ef87e2bc8b929b7af75c3f03aafd1f12121b67/comments", "author": null, "committer": null, "parents": [{"sha": "336669e7b08e8dc86bd324702013a0a968151bea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/336669e7b08e8dc86bd324702013a0a968151bea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/336669e7b08e8dc86bd324702013a0a968151bea"}], "stats": {"total": 781, "additions": 648, "deletions": 133}, "files": [{"sha": "5d017eb73c953f19a45915cc665e76855ffb7675", "filename": "gcc/alias.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69ef87e2bc8b929b7af75c3f03aafd1f12121b67/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69ef87e2bc8b929b7af75c3f03aafd1f12121b67/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=69ef87e2bc8b929b7af75c3f03aafd1f12121b67", "patch": "@@ -2276,6 +2276,7 @@ nonlocal_mentioned_p (x)\n     case CC0:\n     case CONST_INT:\n     case CONST_DOUBLE:\n+    case CONST_VECTOR:\n     case CONST:\n     case LABEL_REF:\n       return 0;"}, {"sha": "b2bdf50ef28c12f1963882ab3f9c4bc9eb9deccd", "filename": "gcc/c-common.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69ef87e2bc8b929b7af75c3f03aafd1f12121b67/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69ef87e2bc8b929b7af75c3f03aafd1f12121b67/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=69ef87e2bc8b929b7af75c3f03aafd1f12121b67", "patch": "@@ -702,6 +702,7 @@ constant_expression_warning (value)\n      tree value;\n {\n   if ((TREE_CODE (value) == INTEGER_CST || TREE_CODE (value) == REAL_CST\n+       || TREE_CODE (value) == VECTOR_CST\n        || TREE_CODE (value) == COMPLEX_CST)\n       && TREE_CONSTANT_OVERFLOW (value) && pedantic)\n     pedwarn (\"overflow in constant expression\");\n@@ -736,6 +737,12 @@ overflow_warning (value)\n       if (skip_evaluation == 0)\n \twarning (\"floating point overflow in expression\");\n     }\n+  else if (TREE_CODE (value) == VECTOR_CST && TREE_OVERFLOW (value))\n+    {\n+      TREE_OVERFLOW (value) = 0;\n+      if (skip_evaluation == 0)\n+\twarning (\"vector overflow in expression\");\n+    }\n }\n \n /* Print a warning if a large constant is truncated to unsigned,"}, {"sha": "eb825311613682bc2b83978a4bd9963a9343be57", "filename": "gcc/combine.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69ef87e2bc8b929b7af75c3f03aafd1f12121b67/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69ef87e2bc8b929b7af75c3f03aafd1f12121b67/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=69ef87e2bc8b929b7af75c3f03aafd1f12121b67", "patch": "@@ -11603,6 +11603,7 @@ mark_used_regs_combine (x)\n     case CONST_INT:\n     case CONST:\n     case CONST_DOUBLE:\n+    case CONST_VECTOR:\n     case PC:\n     case ADDR_VEC:\n     case ADDR_DIFF_VEC:"}, {"sha": "1d7091d2d9bef9db8c2c5b438e946f3f625963c8", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 17, "deletions": 18, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69ef87e2bc8b929b7af75c3f03aafd1f12121b67/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69ef87e2bc8b929b7af75c3f03aafd1f12121b67/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=69ef87e2bc8b929b7af75c3f03aafd1f12121b67", "patch": "@@ -18999,14 +18999,14 @@\n \t (plus:V8QI (plus:V8QI\n \t\t     (match_operand:V8QI 1 \"register_operand\" \"0\")\n \t\t     (match_operand:V8QI 2 \"nonimmediate_operand\" \"ym\"))\n-\t\t    (vec_const:V8QI (parallel [(const_int 1)\n-\t\t\t\t\t       (const_int 1)\n-\t\t\t\t\t       (const_int 1)\n-\t\t\t\t\t       (const_int 1)\n-\t\t\t\t\t       (const_int 1)\n-\t\t\t\t\t       (const_int 1)\n-\t\t\t\t\t       (const_int 1)\n-\t\t\t\t\t       (const_int 1)])))\n+\t\t    (const_vector:V8QI [(const_int 1)\n+\t\t\t\t\t(const_int 1)\n+\t\t\t\t\t(const_int 1)\n+\t\t\t\t\t(const_int 1)\n+\t\t\t\t\t(const_int 1)\n+\t\t\t\t\t(const_int 1)\n+\t\t\t\t\t(const_int 1)\n+\t\t\t\t\t(const_int 1)]))\n \t (const_int 1)))]\n   \"TARGET_SSE || TARGET_3DNOW_A\"\n   \"pavgb\\t{%2, %0|%0, %2}\"\n@@ -19018,10 +19018,10 @@\n \t (plus:V4HI (plus:V4HI\n \t\t     (match_operand:V4HI 1 \"register_operand\" \"0\")\n \t\t     (match_operand:V4HI 2 \"nonimmediate_operand\" \"ym\"))\n-\t\t    (vec_const:V4HI (parallel [(const_int 1)\n-\t\t\t\t\t       (const_int 1)\n-\t\t\t\t\t       (const_int 1)\n-\t\t\t\t\t       (const_int 1)])))\n+\t\t    (const_vector:V4HI [(const_int 1)\n+\t\t\t\t\t(const_int 1)\n+\t\t\t\t\t(const_int 1)\n+\t\t\t\t\t(const_int 1)]))\n \t (const_int 1)))]\n   \"TARGET_SSE || TARGET_3DNOW_A\"\n   \"pavgw\\t{%2, %0|%0, %2}\"\n@@ -19735,12 +19735,11 @@\n \t\t       (match_operand:V4HI 1 \"register_operand\" \"0\"))\n \t            (sign_extend:V4SI\n \t\t       (match_operand:V4HI 2 \"nonimmediate_operand\" \"ym\")))\n-\t      (vec_const:V4SI\n-\t         (parallel [(const_int 32768)\n-\t\t\t    (const_int 32768)\n-\t\t\t    (const_int 32768)\n-\t\t\t    (const_int 32768)])))\n-\t   (const_int 16))))]\n+\t\t (const_vector:V4SI [(const_int 32768)\n+\t\t\t\t     (const_int 32768)\n+\t\t\t\t     (const_int 32768)\n+\t\t\t\t     (const_int 32768)]))\n+\t      (const_int 16))))]\n   \"TARGET_3DNOW\"\n   \"pmulhrw\\\\t{%2, %0|%0, %2}\"\n   [(set_attr \"type\" \"mmx\")])"}, {"sha": "19aeb07b9e0c26ca65f3142b7e20980857f6e35e", "filename": "gcc/config/rs6000/rs6000-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69ef87e2bc8b929b7af75c3f03aafd1f12121b67/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69ef87e2bc8b929b7af75c3f03aafd1f12121b67/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h?ref=69ef87e2bc8b929b7af75c3f03aafd1f12121b67", "patch": "@@ -52,6 +52,7 @@ extern int got_no_const_operand PARAMS ((rtx, enum machine_mode));\n extern int num_insns_constant PARAMS ((rtx, enum machine_mode));\n extern int easy_fp_constant PARAMS ((rtx, enum machine_mode));\n extern int zero_fp_constant PARAMS ((rtx, enum machine_mode));\n+extern int zero_constant PARAMS ((rtx, enum machine_mode));\n extern int volatile_mem_operand PARAMS ((rtx, enum machine_mode));\n extern int offsettable_mem_operand PARAMS ((rtx, enum machine_mode));\n extern int mem_or_easy_const_operand PARAMS ((rtx, enum machine_mode));"}, {"sha": "5e3a7353c3328161215153ea54a96bac2ebe9779", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 56, "deletions": 5, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69ef87e2bc8b929b7af75c3f03aafd1f12121b67/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69ef87e2bc8b929b7af75c3f03aafd1f12121b67/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=69ef87e2bc8b929b7af75c3f03aafd1f12121b67", "patch": "@@ -174,6 +174,7 @@ static void is_altivec_return_reg PARAMS ((rtx, void *));\n int vrsave_operation PARAMS ((rtx, enum machine_mode));\n static rtx generate_set_vrsave PARAMS ((rtx, rs6000_stack_t *, int));\n static void altivec_frame_fixup PARAMS ((rtx, rtx, HOST_WIDE_INT));\n+static int easy_vector_constant PARAMS ((rtx));\n \f\n /* Default register names.  */\n char rs6000_reg_names[][8] =\n@@ -1194,6 +1195,54 @@ easy_fp_constant (op, mode)\n     abort ();\n }\n \n+/* Return 1 if the operand is a CONST_INT and can be put into a\n+   register with one instruction.  */\n+\n+static int\n+easy_vector_constant (op)\n+     rtx op;\n+{\n+  rtx elt;\n+  int units, i;\n+\n+  if (GET_CODE (op) != CONST_VECTOR)\n+    return 0;\n+\n+  units = CONST_VECTOR_NUNITS (op);\n+\n+  /* We can generate 0 easily.  Look for that.  */\n+  for (i = 0; i < units; ++i)\n+    {\n+      elt = CONST_VECTOR_ELT (op, i);\n+\n+      /* We could probably simplify this by just checking for equality\n+\t with CONST0_RTX for the current mode, but let's be safe\n+\t instead.  */\n+\n+      if (GET_CODE (elt) == CONST_INT && INTVAL (elt) != 0)\n+\treturn 0;\n+\n+      if (GET_CODE (elt) == CONST_DOUBLE\n+\t       && (CONST_DOUBLE_LOW (elt) != 0\n+\t\t   || CONST_DOUBLE_HIGH (elt) != 0))\n+\treturn 0;\n+    }\n+\n+  /* We could probably generate a few other constants trivially, but\n+     gcc doesn't generate them yet.  FIXME later.  */\n+  return 0;\n+}\n+\n+/* Return 1 if the operand is the constant 0.  This works for scalars\n+   as well as vectors.  */\n+int\n+zero_constant (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  return op == CONST0_RTX (mode);\n+}\n+\n /* Return 1 if the operand is 0.0.  */\n int\n zero_fp_constant (op, mode)\n@@ -1892,6 +1941,7 @@ rs6000_legitimize_reload_address (x, mode, opnum, type, ind_levels, win)\n #if TARGET_MACHO\n   if (GET_CODE (x) == SYMBOL_REF\n       && DEFAULT_ABI == ABI_DARWIN\n+      && !ALTIVEC_VECTOR_MODE (mode)\n       && flag_pic)\n     {\n       /* Darwin load of floating point constant.  */\n@@ -2186,9 +2236,10 @@ rs6000_emit_move (dest, source, mode)\n \n   /* Handle the case where reload calls us with an invalid address;\n      and the case of CONSTANT_P_RTX.  */\n-  if (! general_operand (operands[1], mode)\n-      || ! nonimmediate_operand (operands[0], mode)\n-      || GET_CODE (operands[1]) == CONSTANT_P_RTX)\n+  if (!VECTOR_MODE_P (mode)\n+      && (! general_operand (operands[1], mode)\n+\t  || ! nonimmediate_operand (operands[0], mode)\n+\t  || GET_CODE (operands[1]) == CONSTANT_P_RTX))\n     {\n       emit_insn (gen_rtx_SET (VOIDmode, operands[0], operands[1]));\n       return;\n@@ -2218,8 +2269,8 @@ rs6000_emit_move (dest, source, mode)\n     case V8HImode:\n     case V4SFmode:\n     case V4SImode:\n-      /* fixme: aldyh -- allow vector constants when they are implemented.  */\n-      if (CONSTANT_P (operands[1]))\n+      if (CONSTANT_P (operands[1])\n+\t  && !easy_vector_constant (operands[1]))\n \toperands[1] = force_const_mem (mode, operands[1]);\n       break;\n       "}, {"sha": "cdbe3361a91f234a8ed876ec7e650054a785f0e1", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69ef87e2bc8b929b7af75c3f03aafd1f12121b67/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69ef87e2bc8b929b7af75c3f03aafd1f12121b67/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=69ef87e2bc8b929b7af75c3f03aafd1f12121b67", "patch": "@@ -638,10 +638,13 @@ extern int rs6000_altivec_abi;\n /* A bitfield declared as `int' forces `int' alignment for the struct.  */\n #define PCC_BITFIELD_TYPE_MATTERS 1\n \n-/* Make strings word-aligned so strcpy from constants will be faster.  */\n-#define CONSTANT_ALIGNMENT(EXP, ALIGN)  \\\n-  (TREE_CODE (EXP) == STRING_CST\t\\\n-   && (ALIGN) < BITS_PER_WORD ? BITS_PER_WORD : (ALIGN))\n+/* Make strings word-aligned so strcpy from constants will be faster.\n+   Make vector constants quadword aligned.  */\n+#define CONSTANT_ALIGNMENT(EXP, ALIGN)                           \\\n+  (TREE_CODE (EXP) == STRING_CST\t                         \\\n+   && (ALIGN) < BITS_PER_WORD                                    \\\n+   ? BITS_PER_WORD                                               \\\n+   : (ALIGN))\n \n /* Make arrays of chars word-aligned for the same reasons.\n    Align vectors to 128 bits.  */"}, {"sha": "d83538ba6253abbe435298e2a4db04d38854e5ed", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 59, "deletions": 17, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69ef87e2bc8b929b7af75c3f03aafd1f12121b67/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69ef87e2bc8b929b7af75c3f03aafd1f12121b67/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=69ef87e2bc8b929b7af75c3f03aafd1f12121b67", "patch": "@@ -14017,6 +14017,36 @@\n   \"mtvrsave %1\"\n   [(set_attr \"type\" \"altivec\")])\n \n+;; Vector clears\n+(define_insn \"*movv4si_const0\"\n+  [(set (match_operand:V4SI 0 \"altivec_register_operand\" \"=v\")\n+\t(match_operand:V4SI 1 \"zero_constant\" \"\"))]\n+  \"TARGET_ALTIVEC\"\n+  \"vxor %0,%0,%0\"\n+  [(set_attr \"type\" \"vecsimple\")])\n+\n+(define_insn \"*movv4sf_const0\"\n+  [(set (match_operand:V4SF 0 \"altivec_register_operand\" \"=v\")\n+\t(match_operand:V4SF 1 \"zero_constant\" \"\"))]\n+\t\t\t\t\t \n+  \"TARGET_ALTIVEC\"\n+  \"vxor %0,%0,%0\"\n+  [(set_attr \"type\" \"vecsimple\")])\n+\n+(define_insn \"*movv8hi_const0\"\n+  [(set (match_operand:V8HI 0 \"altivec_register_operand\" \"=v\")\n+\t(match_operand:V8HI 1 \"zero_constant\" \"\"))]\n+  \"TARGET_ALTIVEC\"\n+  \"vxor %0,%0,%0\"\n+  [(set_attr \"type\" \"vecsimple\")])\n+\n+(define_insn \"*movv16qi_const0\"\n+  [(set (match_operand:V16QI 0 \"altivec_register_operand\" \"=v\")\n+\t(match_operand:V16QI 1 \"zero_constant\" \"\"))]\n+  \"TARGET_ALTIVEC\"\n+  \"vxor %0,%0,%0\"\n+  [(set_attr \"type\" \"vecsimple\")])\n+\n ;; Simple binary operations.\n \n (define_insn \"addv16qi3\"\n@@ -15481,49 +15511,61 @@\n   \"lvsr %0,%1,%2\"\n   [(set_attr \"type\" \"vecload\")])\n \n+;; Parallel some of the LVE* and STV*'s with unspecs because some have\n+;; identical rtl but different instructions-- and gcc gets confused.\n+\n (define_insn \"altivec_lvebx\"\n-  [(set (match_operand:V16QI 0 \"register_operand\" \"=v\")\n-\t(unspec:V16QI [(match_operand:SI 1 \"register_operand\" \"b\")\n-\t\t       (match_operand:SI 2 \"register_operand\" \"r\")] 196))]\n+  [(parallel\n+    [(set (match_operand:V16QI 0 \"register_operand\" \"=v\")\n+\t  (mem:V16QI (plus:SI (match_operand:SI 1 \"register_operand\" \"b\")\n+\t\t\t      (match_operand:SI 2 \"register_operand\" \"r\"))))\n+     (unspec [(const_int 0)] 196)])]\n   \"TARGET_ALTIVEC\"\n   \"lvebx %0,%1,%2\"\n   [(set_attr \"type\" \"vecload\")])\n \n (define_insn \"altivec_lvehx\"\n-  [(set (match_operand:V8HI 0 \"register_operand\" \"=v\")\n-\t(unspec:V8HI [(match_operand:SI 1 \"register_operand\" \"b\")\n-\t\t      (match_operand:SI 2 \"register_operand\" \"r\")] 197))]\n+  [(parallel\n+    [(set (match_operand:V8HI 0 \"register_operand\" \"=v\")\n+\t  (mem:V8HI\n+\t   (and:SI (plus:SI (match_operand:SI 1 \"register_operand\" \"b\")\n+\t\t\t    (match_operand:SI 2 \"register_operand\" \"r\"))\n+\t\t   (const_int -2))))\n+     (unspec [(const_int 0)] 197)])]\n   \"TARGET_ALTIVEC\"\n   \"lvehx %0,%1,%2\"\n   [(set_attr \"type\" \"vecload\")])\n \n (define_insn \"altivec_lvewx\"\n-  [(set (match_operand:V4SI 0 \"register_operand\" \"=v\")\n-\t(unspec:V4SI [(match_operand:SI 1 \"register_operand\" \"b\")\n-\t\t      (match_operand:SI 2 \"register_operand\" \"r\")] 198))]\n+  [(parallel\n+    [(set (match_operand:V4SI 0 \"register_operand\" \"=v\")\n+\t  (mem:V4SI\n+\t   (and:SI (plus:SI (match_operand:SI 1 \"register_operand\" \"b\")\n+\t\t\t    (match_operand:SI 2 \"register_operand\" \"r\"))\n+\t\t   (const_int -4))))\n+     (unspec [(const_int 0)] 198)])]\n   \"TARGET_ALTIVEC\"\n   \"lvewx %0,%1,%2\"\n   [(set_attr \"type\" \"vecload\")])\n \n (define_insn \"altivec_lvxl\"\n-  [(set (match_operand:V4SI 0 \"register_operand\" \"=v\")\n-\t(unspec:V4SI [(match_operand:SI 1 \"register_operand\" \"b\")\n-\t\t      (match_operand:SI 2 \"register_operand\" \"r\")] 199))]\n+  [(parallel\n+    [(set (match_operand:V4SI 0 \"register_operand\" \"=v\")\n+\t  (mem:V4SI (plus:SI (match_operand:SI 1 \"register_operand\" \"b\")\n+\t\t\t     (match_operand:SI 2 \"register_operand\" \"r\"))))\n+     (unspec [(const_int 0)] 213)])]\n   \"TARGET_ALTIVEC\"\n   \"lvxl %0,%1,%2\"\n   [(set_attr \"type\" \"vecload\")])\n \n (define_insn \"altivec_lvx\"\n   [(set (match_operand:V4SI 0 \"register_operand\" \"=v\")\n-\t(unspec:V4SI [(match_operand:SI 1 \"register_operand\" \"b\")\n-\t\t      (match_operand:SI 2 \"register_operand\" \"r\")] 200))]\n+\t(mem:V4SI (plus:SI (match_operand:SI 1 \"register_operand\" \"b\")\n+\t\t\t   (match_operand:SI 2 \"register_operand\" \"r\"))))]\n   \"TARGET_ALTIVEC\"\n   \"lvx %0,%1,%2\"\n   [(set_attr \"type\" \"vecload\")])\n \n-;; Parallel the STV*'s with unspecs because some of them have\n-;; identical rtl but are different instructions-- and gcc gets confused.\n-\n (define_insn \"altivec_stvx\"\n   [(parallel\n     [(set (mem:V4SI"}, {"sha": "a607b0c46f34987a73eaf2e9298c3201eb812274", "filename": "gcc/cse.c", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69ef87e2bc8b929b7af75c3f03aafd1f12121b67/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69ef87e2bc8b929b7af75c3f03aafd1f12121b67/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=69ef87e2bc8b929b7af75c3f03aafd1f12121b67", "patch": "@@ -2323,6 +2323,22 @@ canon_hash (x, mode)\n \t\t + (unsigned) CONST_DOUBLE_HIGH (x));\n       return hash;\n \n+    case CONST_VECTOR:\n+      {\n+\tint units;\n+\trtx elt;\n+\n+\tunits = CONST_VECTOR_NUNITS (x);\n+\n+\tfor (i = 0; i < units; ++i)\n+\t  {\n+\t    elt = CONST_VECTOR_ELT (x, i);\n+\t    hash += canon_hash (elt, GET_MODE (elt));\n+\t  }\n+\n+\treturn hash;\n+      }\n+\n       /* Assume there is only one rtx object for any given label.  */\n     case LABEL_REF:\n       hash += ((unsigned) LABEL_REF << 7) + (unsigned long) XEXP (x, 0);\n@@ -2776,6 +2792,7 @@ canon_reg (x, insn)\n     case CONST:\n     case CONST_INT:\n     case CONST_DOUBLE:\n+    case CONST_VECTOR:\n     case SYMBOL_REF:\n     case LABEL_REF:\n     case ADDR_VEC:\n@@ -3317,6 +3334,7 @@ fold_rtx (x, insn)\n     case CONST:\n     case CONST_INT:\n     case CONST_DOUBLE:\n+    case CONST_VECTOR:\n     case SYMBOL_REF:\n     case LABEL_REF:\n     case REG:\n@@ -3727,6 +3745,7 @@ fold_rtx (x, insn)\n \t  case SYMBOL_REF:\n \t  case LABEL_REF:\n \t  case CONST_DOUBLE:\n+\t  case CONST_VECTOR:\n \t    const_arg = arg;\n \t    break;\n \n@@ -6425,6 +6444,7 @@ cse_process_notes (x, object)\n     case SYMBOL_REF:\n     case LABEL_REF:\n     case CONST_DOUBLE:\n+    case CONST_VECTOR:\n     case PC:\n     case CC0:\n     case LO_SUM:\n@@ -7416,6 +7436,7 @@ count_reg_usage (x, counts, dest, incr)\n     case CONST:\n     case CONST_INT:\n     case CONST_DOUBLE:\n+    case CONST_VECTOR:\n     case SYMBOL_REF:\n     case LABEL_REF:\n       return;"}, {"sha": "0eb17b8a836224803ce6e919ac955cc28cd0afe8", "filename": "gcc/cselib.c", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69ef87e2bc8b929b7af75c3f03aafd1f12121b67/gcc%2Fcselib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69ef87e2bc8b929b7af75c3f03aafd1f12121b67/gcc%2Fcselib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcselib.c?ref=69ef87e2bc8b929b7af75c3f03aafd1f12121b67", "patch": "@@ -593,6 +593,22 @@ hash_rtx (x, mode, create)\n \t\t + (unsigned) CONST_DOUBLE_HIGH (x));\n       return hash ? hash : (unsigned int) CONST_DOUBLE;\n \n+    case CONST_VECTOR:\n+      {\n+\tint units;\n+\trtx elt;\n+\n+\tunits = CONST_VECTOR_NUNITS (x);\n+\n+\tfor (i = 0; i < units; ++i)\n+\t  {\n+\t    elt = CONST_VECTOR_ELT (x, i);\n+\t    hash += hash_rtx (elt, GET_MODE (elt), 0);\n+\t  }\n+\n+\treturn hash;\n+      }\n+\n       /* Assume there is only one rtx object for any given label.  */\n     case LABEL_REF:\n       hash\n@@ -794,6 +810,7 @@ cselib_subst_to_values (x)\n       return e->u.val_rtx;\n \n     case CONST_DOUBLE:\n+    case CONST_VECTOR:\n     case CONST_INT:\n       return x;\n \n@@ -1009,6 +1026,7 @@ cselib_mem_conflict_p (mem_base, val)\n     case CONST:\n     case CONST_INT:\n     case CONST_DOUBLE:\n+    case CONST_VECTOR:\n     case SYMBOL_REF:\n     case LABEL_REF:\n       return 0;"}, {"sha": "3d50ea79fb768c33b9a1bdf8507923070d453e32", "filename": "gcc/df.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69ef87e2bc8b929b7af75c3f03aafd1f12121b67/gcc%2Fdf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69ef87e2bc8b929b7af75c3f03aafd1f12121b67/gcc%2Fdf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf.c?ref=69ef87e2bc8b929b7af75c3f03aafd1f12121b67", "patch": "@@ -1032,6 +1032,7 @@ df_uses_record (df, loc, ref_type, bb, insn, flags)\n     case CONST_INT:\n     case CONST:\n     case CONST_DOUBLE:\n+    case CONST_VECTOR:\n     case PC:\n     case ADDR_VEC:\n     case ADDR_DIFF_VEC:"}, {"sha": "849d07948b6718a8fc11c4c4a265455b75744db1", "filename": "gcc/doc/c-tree.texi", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69ef87e2bc8b929b7af75c3f03aafd1f12121b67/gcc%2Fdoc%2Fc-tree.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69ef87e2bc8b929b7af75c3f03aafd1f12121b67/gcc%2Fdoc%2Fc-tree.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fc-tree.texi?ref=69ef87e2bc8b929b7af75c3f03aafd1f12121b67", "patch": "@@ -1712,6 +1712,7 @@ This macro returns the attributes on the type @var{type}.\n @findex tree_int_cst_equal\n @tindex REAL_CST\n @tindex COMPLEX_CST\n+@tindex VECTOR_CST\n @tindex STRING_CST\n @findex TREE_STRING_LENGTH\n @findex TREE_STRING_POINTER\n@@ -1858,6 +1859,12 @@ These nodes are used to represent complex number constants, that is a\n @code{TREE_REALPART} and @code{TREE_IMAGPART} return the real and the\n imaginary parts respectively.\n \n+@item VECTOR_CST\n+These nodes are used to represent vector constants, whose parts are\n+constant nodes.  Each individual constant node is either an integer or a\n+double constant node.  The first operand is a @code{TREE_LIST} of the\n+constant nodes and is accessed through @code{TREE_VECTOR_CST_ELTS}.\n+\n @item STRING_CST\n These nodes represent string-constants.  The @code{TREE_STRING_LENGTH}\n returns the length of the string, as an @code{int}.  The"}, {"sha": "6963950301f7e780b6b19adbf6007d9ae198fc14", "filename": "gcc/doc/rtl.texi", "status": "modified", "additions": 26, "deletions": 3, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69ef87e2bc8b929b7af75c3f03aafd1f12121b67/gcc%2Fdoc%2Frtl.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69ef87e2bc8b929b7af75c3f03aafd1f12121b67/gcc%2Fdoc%2Frtl.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Frtl.texi?ref=69ef87e2bc8b929b7af75c3f03aafd1f12121b67", "patch": "@@ -1156,6 +1156,20 @@ bits but small enough to fit within twice that number of bits (GCC\n does not provide a mechanism to represent even larger constants).  In\n the latter case, @var{m} will be @code{VOIDmode}.\n \n+@findex const_vector\n+@item (const_vector:@var{m} [@var{x0} @var{x1} @dots{}])\n+Represents a vector constant.  The square brackets stand for the vector\n+containing the constant elements.  @var{x0}, @var{x1} and so on are\n+the @code{const_int} or @code{const_double} elements.\n+\n+The number of units in a @code{const_vector} is obtained with the macro\n+@code{CONST_VECTOR_NUNITS} as in @code{CONST_VECTOR_NUNITS (@var{v})}.\n+\n+Individual elements in a vector constant are accessed with the macro\n+@code{CONST_VECTOR_ELT} as in @code{CONST_VECTOR_ELT (@var{v}, @var{n})\n+where @var{v} is the vector constant and @var{n} is the element\n+desired.\n+\n @findex CONST_DOUBLE_MEM\n @findex CONST_DOUBLE_CHAIN\n @var{addr} is used to contain the @code{mem} expression that corresponds\n@@ -1185,10 +1199,14 @@ the precise bit pattern used by the target machine, use the macro\n @findex CONST2_RTX\n The macro @code{CONST0_RTX (@var{mode})} refers to an expression with\n value 0 in mode @var{mode}.  If mode @var{mode} is of mode class\n-@code{MODE_INT}, it returns @code{const0_rtx}.  Otherwise, it returns a\n-@code{CONST_DOUBLE} expression in mode @var{mode}.  Similarly, the macro\n+@code{MODE_INT}, it returns @code{const0_rtx}.  If mode @var{mode} is of\n+mode class @code{MODE_FLOAT}, it returns a @code{CONST_DOUBLE}\n+expression in mode @var{mode}.  Otherwise, it returns a\n+@code{CONST_VECTOR} expression in mode @var{mode}.  Similarly, the macro\n @code{CONST1_RTX (@var{mode})} refers to an expression with value 1 in\n-mode @var{mode} and similarly for @code{CONST2_RTX}.\n+mode @var{mode} and similarly for @code{CONST2_RTX}.  The\n+@code{CONST1_RTX} and @code{CONST2_RTX} macros are undefined\n+for vector modes.\n \n @findex const_string\n @item (const_string @var{str})\n@@ -3331,6 +3349,11 @@ There is only one @code{cc0} expression.\n There is only one @code{const_double} expression with value 0 for\n each floating point mode.  Likewise for values 1 and 2.\n \n+@cindex @code{const_vector}, RTL sharing\n+@item\n+There is only one @code{const_vector} expression with value 0 for\n+each vector mode, be it an integer or a double constant vector.\n+\n @cindex @code{label_ref}, RTL sharing\n @cindex @code{scratch}, RTL sharing\n @item"}, {"sha": "82dd61a5f64fcaca9d4e63351533a41180de0890", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69ef87e2bc8b929b7af75c3f03aafd1f12121b67/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69ef87e2bc8b929b7af75c3f03aafd1f12121b67/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=69ef87e2bc8b929b7af75c3f03aafd1f12121b67", "patch": "@@ -196,6 +196,7 @@ static mem_attrs *get_mem_attrs\t\tPARAMS ((HOST_WIDE_INT, tree, rtx,\n \t\t\t\t\t\t rtx, unsigned int,\n \t\t\t\t\t\t enum machine_mode));\n static tree component_ref_for_mem_expr\tPARAMS ((tree));\n+static rtx gen_const_vector_0 PARAMS ((enum mode_class, enum machine_mode));\n \n /* Probability of the conditional branch currently proceeded by try_split.\n    Set to -1 otherwise.  */\n@@ -2390,6 +2391,7 @@ copy_rtx_if_shared (orig)\n     case QUEUED:\n     case CONST_INT:\n     case CONST_DOUBLE:\n+    case CONST_VECTOR:\n     case SYMBOL_REF:\n     case CODE_LABEL:\n     case PC:\n@@ -2506,6 +2508,7 @@ reset_used_flags (x)\n     case QUEUED:\n     case CONST_INT:\n     case CONST_DOUBLE:\n+    case CONST_VECTOR:\n     case SYMBOL_REF:\n     case CODE_LABEL:\n     case PC:\n@@ -4541,6 +4544,7 @@ copy_insn_1 (orig)\n     case QUEUED:\n     case CONST_INT:\n     case CONST_DOUBLE:\n+    case CONST_VECTOR:\n     case SYMBOL_REF:\n     case CODE_LABEL:\n     case PC:\n@@ -4779,6 +4783,35 @@ mark_emit_status (es)\n   ggc_mark_rtx (es->x_first_insn);\n }\n \n+/* Generate the constant 0.  The first argument is MODE_VECTOR_INT for\n+   integers or MODE_VECTOR_FLOAT for floats.  */\n+\n+static rtx\n+gen_const_vector_0 (type, mode)\n+     enum mode_class type;\n+     enum machine_mode mode;\n+{\n+  rtx tem;\n+  rtvec v;\n+  int units, i;\n+  enum machine_mode inner;\n+\n+  units = GET_MODE_NUNITS (mode);\n+  inner = GET_MODE_INNER (mode);\n+\n+  v = rtvec_alloc (units);\n+\n+  /* We need to call this function after we to set CONST0_RTX first.  */\n+  if (!CONST0_RTX (inner))\n+    abort ();\n+\n+  for (i = 0; i < units; ++i)\n+    RTVEC_ELT (v, i) = CONST0_RTX (inner);\n+\n+  tem = gen_rtx_CONST_VECTOR (mode, v);\n+  return tem;\n+}\n+\n /* Create some permanent unique rtl objects shared between all functions.\n    LINE_NUMBERS is nonzero if line numbers are to be generated.  */\n \n@@ -4920,6 +4953,18 @@ init_emit_once (line_numbers)\n \tconst_tiny_rtx[i][(int) mode] = GEN_INT (i);\n     }\n \n+  for (mode = GET_CLASS_NARROWEST_MODE (MODE_VECTOR_INT);\n+       mode != VOIDmode;\n+       mode = GET_MODE_WIDER_MODE (mode))\n+    const_tiny_rtx[0][(int) mode]\n+      = gen_const_vector_0 (MODE_VECTOR_INT, mode);\n+\n+  for (mode = GET_CLASS_NARROWEST_MODE (MODE_VECTOR_FLOAT);\n+       mode != VOIDmode;\n+       mode = GET_MODE_WIDER_MODE (mode))\n+    const_tiny_rtx[0][(int) mode]\n+      = gen_const_vector_0 (MODE_VECTOR_FLOAT, mode);\n+\n   for (i = (int) CCmode; i < (int) MAX_MACHINE_MODE; ++i)\n     if (GET_MODE_CLASS ((enum machine_mode) i) == MODE_CC)\n       const_tiny_rtx[0][i] = const0_rtx;"}, {"sha": "ad87865a06317ac032fe11e4f9f82fcf676839d0", "filename": "gcc/expmed.c", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69ef87e2bc8b929b7af75c3f03aafd1f12121b67/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69ef87e2bc8b929b7af75c3f03aafd1f12121b67/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=69ef87e2bc8b929b7af75c3f03aafd1f12121b67", "patch": "@@ -4038,7 +4038,25 @@ make_tree (type, x)\n \t}\n \n       return t;\n-\t  \n+\n+    case CONST_VECTOR:\n+      {\n+\tint i, units;\n+\trtx elt;\n+\ttree t = NULL_TREE;\n+\n+\tunits = CONST_VECTOR_NUNITS (x);\n+\n+\t/* Build a tree with vector elements.  */\n+\tfor (i = units - 1; i >= 0; --i)\n+\t  {\n+\t    elt = CONST_VECTOR_ELT (x, i);\n+\t    t = tree_cons (NULL_TREE, make_tree (type, elt), t);\n+\t  }\n+\t\n+\treturn build_vector (type, t);\n+      }\n+\n     case PLUS:\n       return fold (build (PLUS_EXPR, type, make_tree (type, XEXP (x, 0)),\n \t\t\t  make_tree (type, XEXP (x, 1))));"}, {"sha": "f56f88640dc58f2df8902d9b783846f36f1fe623", "filename": "gcc/expr.c", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69ef87e2bc8b929b7af75c3f03aafd1f12121b67/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69ef87e2bc8b929b7af75c3f03aafd1f12121b67/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=69ef87e2bc8b929b7af75c3f03aafd1f12121b67", "patch": "@@ -2562,8 +2562,7 @@ clear_storage (object, size)\n \n   /* If OBJECT is not BLKmode and SIZE is the same size as its mode,\n      just move a zero.  Otherwise, do this a piece at a time.  */\n-  if ((GET_MODE (object) != BLKmode\n-       && !VECTOR_MODE_P (GET_MODE (object)))\n+  if (GET_MODE (object) != BLKmode\n       && GET_CODE (size) == CONST_INT\n       && GET_MODE_SIZE (GET_MODE (object)) == (unsigned int) INTVAL (size))\n     emit_move_insn (object, CONST0_RTX (GET_MODE (object)));\n@@ -4245,6 +4244,14 @@ is_zeros_p (exp)\n     case REAL_CST:\n       return REAL_VALUES_IDENTICAL (TREE_REAL_CST (exp), dconst0);\n \n+    case VECTOR_CST:\n+      for (elt = TREE_VECTOR_CST_ELTS (exp); elt;\n+\t   elt = TREE_CHAIN (elt))\n+\tif (!is_zeros_p (TREE_VALUE (elt)))\n+\t  return 0;\n+\n+      return 1;\n+\n     case CONSTRUCTOR:\n       if (TREE_TYPE (exp) && TREE_CODE (TREE_TYPE (exp)) == SET_TYPE)\n \treturn CONSTRUCTOR_ELTS (exp) == NULL_TREE;"}, {"sha": "6c3cd564d7db1ee42385373e11acf5a21334f902", "filename": "gcc/flow.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69ef87e2bc8b929b7af75c3f03aafd1f12121b67/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69ef87e2bc8b929b7af75c3f03aafd1f12121b67/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=69ef87e2bc8b929b7af75c3f03aafd1f12121b67", "patch": "@@ -3635,6 +3635,7 @@ mark_used_regs (pbi, x, cond, insn)\n     case CONST_INT:\n     case CONST:\n     case CONST_DOUBLE:\n+    case CONST_VECTOR:\n     case PC:\n     case ADDR_VEC:\n     case ADDR_DIFF_VEC:"}, {"sha": "7c9a5ec99ee8a9e00c22b2b36ea1a6748b3576f8", "filename": "gcc/fold-const.c", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69ef87e2bc8b929b7af75c3f03aafd1f12121b67/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69ef87e2bc8b929b7af75c3f03aafd1f12121b67/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=69ef87e2bc8b929b7af75c3f03aafd1f12121b67", "patch": "@@ -2427,6 +2427,27 @@ operand_equal_p (arg0, arg1, only_const)\n \t\t&& REAL_VALUES_IDENTICAL (TREE_REAL_CST (arg0),\n \t\t\t\t\t  TREE_REAL_CST (arg1)));\n \n+      case VECTOR_CST:\n+\t{\n+\t  tree v1, v2;\n+\n+\t  if (TREE_CONSTANT_OVERFLOW (arg0)\n+\t      || TREE_CONSTANT_OVERFLOW (arg1))\n+\t    return 0;\n+\n+\t  v1 = TREE_VECTOR_CST_ELTS (arg0);\n+\t  v2 = TREE_VECTOR_CST_ELTS (arg1);\n+\t  while (v1 && v2)\n+\t    {\n+\t      if (!operand_equal_p (v1, v2, only_const))\n+\t\treturn 0;\n+\t      v1 = TREE_CHAIN (v1);\n+\t      v2 = TREE_CHAIN (v2);\n+\t    }\n+\n+\t  return 1;\n+\t}\n+\n       case COMPLEX_CST:\n \treturn (operand_equal_p (TREE_REALPART (arg0), TREE_REALPART (arg1),\n \t\t\t\t only_const)\n@@ -5184,6 +5205,7 @@ fold (expr)\n     {\n     case INTEGER_CST:\n     case REAL_CST:\n+    case VECTOR_CST:\n     case STRING_CST:\n     case COMPLEX_CST:\n     case CONSTRUCTOR:\n@@ -7586,6 +7608,23 @@ rtl_expr_nonnegative_p (r)\n \treturn CONST_DOUBLE_HIGH (r) >= 0;\n       return 0;\n \n+    case CONST_VECTOR:\n+      {\n+\tint units, i;\n+\trtx elt;\n+\n+\tunits = CONST_VECTOR_NUNITS (r);\n+\n+\tfor (i = 0; i < units; ++i)\n+\t  {\n+\t    elt = CONST_VECTOR_ELT (r, i);\n+\t    if (!rtl_expr_nonnegative_p (elt))\n+\t      return 0;\n+\t  }\n+\n+\treturn 1;\n+      }\n+\n     case SYMBOL_REF:\n     case LABEL_REF:\n       /* These are always nonnegative.  */"}, {"sha": "0c2298c2474487ca6f7e9453f2c072a28d5f122a", "filename": "gcc/function.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69ef87e2bc8b929b7af75c3f03aafd1f12121b67/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69ef87e2bc8b929b7af75c3f03aafd1f12121b67/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=69ef87e2bc8b929b7af75c3f03aafd1f12121b67", "patch": "@@ -1994,6 +1994,7 @@ fixup_var_refs_1 (var, promoted_mode, loc, insn, replacements)\n     case SYMBOL_REF:\n     case LABEL_REF:\n     case CONST_DOUBLE:\n+    case CONST_VECTOR:\n       return;\n \n     case SIGN_EXTRACT:\n@@ -3722,6 +3723,7 @@ instantiate_virtual_regs_1 (loc, object, extra_insns)\n     {\n     case CONST_INT:\n     case CONST_DOUBLE:\n+    case CONST_VECTOR:\n     case CONST:\n     case SYMBOL_REF:\n     case CODE_LABEL:"}, {"sha": "b7b08f2840a8090a81937dbefa99a219ce06f632", "filename": "gcc/gcse.c", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69ef87e2bc8b929b7af75c3f03aafd1f12121b67/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69ef87e2bc8b929b7af75c3f03aafd1f12121b67/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=69ef87e2bc8b929b7af75c3f03aafd1f12121b67", "patch": "@@ -1315,6 +1315,7 @@ want_to_gcse_p (x)\n     case SUBREG:\n     case CONST_INT:\n     case CONST_DOUBLE:\n+    case CONST_VECTOR:\n     case CALL:\n       return 0;\n \n@@ -1400,6 +1401,7 @@ oprs_unchanged_p (x, insn, avail_p)\n     case CONST:\n     case CONST_INT:\n     case CONST_DOUBLE:\n+    case CONST_VECTOR:\n     case SYMBOL_REF:\n     case LABEL_REF:\n     case ADDR_VEC:\n@@ -1635,6 +1637,22 @@ hash_expr_1 (x, mode, do_not_record_p)\n \t\t + (unsigned int) CONST_DOUBLE_HIGH (x));\n       return hash;\n \n+    case CONST_VECTOR:\n+      {\n+\tint units;\n+\trtx elt;\n+\n+\tunits = CONST_VECTOR_NUNITS (x);\n+\n+\tfor (i = 0; i < units; ++i)\n+\t  {\n+\t    elt = CONST_VECTOR_ELT (x, i);\n+\t    hash += hash_expr_1 (elt, GET_MODE (elt), do_not_record_p);\n+\t  }\n+\n+\treturn hash;\n+      }\n+\n       /* Assume there is only one rtx object for any given label.  */\n     case LABEL_REF:\n       /* We don't hash on the address of the CODE_LABEL to avoid bootstrap\n@@ -2756,6 +2774,7 @@ oprs_not_set_p (x, insn)\n     case CONST:\n     case CONST_INT:\n     case CONST_DOUBLE:\n+    case CONST_VECTOR:\n     case SYMBOL_REF:\n     case LABEL_REF:\n     case ADDR_VEC:\n@@ -3089,6 +3108,7 @@ expr_killed_p (x, bb)\n     case CONST:\n     case CONST_INT:\n     case CONST_DOUBLE:\n+    case CONST_VECTOR:\n     case SYMBOL_REF:\n     case LABEL_REF:\n     case ADDR_VEC:\n@@ -3789,6 +3809,7 @@ compute_transp (x, indx, bmap, set_p)\n     case CONST:\n     case CONST_INT:\n     case CONST_DOUBLE:\n+    case CONST_VECTOR:\n     case SYMBOL_REF:\n     case LABEL_REF:\n     case ADDR_VEC:\n@@ -6289,6 +6310,7 @@ store_ops_ok (x, bb)\n     case CONST:\n     case CONST_INT:\n     case CONST_DOUBLE:\n+    case CONST_VECTOR:\n     case SYMBOL_REF:\n     case LABEL_REF:\n     case ADDR_VEC:"}, {"sha": "a485deef61c5987a26f8b3c1c4a482664b435e71", "filename": "gcc/genattrtab.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69ef87e2bc8b929b7af75c3f03aafd1f12121b67/gcc%2Fgenattrtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69ef87e2bc8b929b7af75c3f03aafd1f12121b67/gcc%2Fgenattrtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenattrtab.c?ref=69ef87e2bc8b929b7af75c3f03aafd1f12121b67", "patch": "@@ -839,6 +839,7 @@ attr_copy_rtx (orig)\n     case QUEUED:\n     case CONST_INT:\n     case CONST_DOUBLE:\n+    case CONST_VECTOR:\n     case SYMBOL_REF:\n     case CODE_LABEL:\n     case PC:\n@@ -2278,6 +2279,7 @@ encode_units_mask (x)\n     case QUEUED:\n     case CONST_INT:\n     case CONST_DOUBLE:\n+    case CONST_VECTOR:\n     case SYMBOL_REF:\n     case CODE_LABEL:\n     case PC:\n@@ -4112,6 +4114,7 @@ clear_struct_flag (x)\n     case QUEUED:\n     case CONST_INT:\n     case CONST_DOUBLE:\n+    case CONST_VECTOR:\n     case SYMBOL_REF:\n     case CODE_LABEL:\n     case PC:\n@@ -4167,6 +4170,7 @@ count_sub_rtxs (x, max)\n     case QUEUED:\n     case CONST_INT:\n     case CONST_DOUBLE:\n+    case CONST_VECTOR:\n     case SYMBOL_REF:\n     case CODE_LABEL:\n     case PC:"}, {"sha": "ad6b2a1f52aaa64c4cdecb8e95adbaff1a0a1939", "filename": "gcc/integrate.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69ef87e2bc8b929b7af75c3f03aafd1f12121b67/gcc%2Fintegrate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69ef87e2bc8b929b7af75c3f03aafd1f12121b67/gcc%2Fintegrate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintegrate.c?ref=69ef87e2bc8b929b7af75c3f03aafd1f12121b67", "patch": "@@ -2120,6 +2120,7 @@ copy_rtx_and_substitute (orig, map, for_lhs)\n     case PC:\n     case CC0:\n     case CONST_INT:\n+    case CONST_VECTOR:\n       return orig;\n \n     case SYMBOL_REF:\n@@ -2479,6 +2480,7 @@ subst_constants (loc, insn, map, memonly)\n     case PC:\n     case CONST_INT:\n     case CONST_DOUBLE:\n+    case CONST_VECTOR:\n     case SYMBOL_REF:\n     case CONST:\n     case LABEL_REF:"}, {"sha": "c44f3686bb895de426686b8dbb0ed976693a2830", "filename": "gcc/local-alloc.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69ef87e2bc8b929b7af75c3f03aafd1f12121b67/gcc%2Flocal-alloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69ef87e2bc8b929b7af75c3f03aafd1f12121b67/gcc%2Flocal-alloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flocal-alloc.c?ref=69ef87e2bc8b929b7af75c3f03aafd1f12121b67", "patch": "@@ -539,6 +539,7 @@ equiv_init_varies_p (x)\n     case CONST:\n     case CONST_INT:\n     case CONST_DOUBLE:\n+    case CONST_VECTOR:\n     case SYMBOL_REF:\n     case LABEL_REF:\n       return 0;\n@@ -658,6 +659,7 @@ contains_replace_regs (x)\n     case LABEL_REF:\n     case SYMBOL_REF:\n     case CONST_DOUBLE:\n+    case CONST_VECTOR:\n     case PC:\n     case CC0:\n     case HIGH:\n@@ -708,6 +710,7 @@ memref_referenced_p (memref, x)\n     case LABEL_REF:\n     case SYMBOL_REF:\n     case CONST_DOUBLE:\n+    case CONST_VECTOR:\n     case PC:\n     case CC0:\n     case HIGH:"}, {"sha": "16abebb8f3189b99c59eaa47e3db10fa0c72bcaf", "filename": "gcc/machmode.def", "status": "modified", "additions": 61, "deletions": 57, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69ef87e2bc8b929b7af75c3f03aafd1f12121b67/gcc%2Fmachmode.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69ef87e2bc8b929b7af75c3f03aafd1f12121b67/gcc%2Fmachmode.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmachmode.def?ref=69ef87e2bc8b929b7af75c3f03aafd1f12121b67", "patch": "@@ -63,94 +63,98 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n    there is none.  Vector modes use this field to point to the next\n    vector size, so we can iterate through the different vectors modes.\n    The ordering is by increasing byte size, with QI coming before HI,\n-   HI before SI, etc.  */\n+   HI before SI, etc.\n+\n+   Eigth arg is the mode of the internal elements in a vector.\n+   VOIDmode if not a vector.\n+*/\n \n /* VOIDmode is used when no mode needs to be specified,\n    as for example on CONST_INT RTL expressions.  */\n-DEF_MACHMODE (VOIDmode, \"VOID\", MODE_RANDOM, 0, 0, 0, VOIDmode)\n+DEF_MACHMODE (VOIDmode, \"VOID\", MODE_RANDOM, 0, 0, 0, VOIDmode, VOIDmode)\n \n-DEF_MACHMODE (BImode, \"BI\", MODE_INT, 1, 1, 1, QImode)\n-DEF_MACHMODE (QImode, \"QI\", MODE_INT, BITS_PER_UNIT, 1, 1, HImode)\n-DEF_MACHMODE (HImode, \"HI\", MODE_INT, BITS_PER_UNIT*2, 2, 2, SImode)\n-DEF_MACHMODE (SImode, \"SI\", MODE_INT, BITS_PER_UNIT*4, 4, 4, DImode)\n-DEF_MACHMODE (DImode, \"DI\", MODE_INT, BITS_PER_UNIT*8, 8, 8, TImode)\n-DEF_MACHMODE (TImode, \"TI\", MODE_INT, BITS_PER_UNIT*16, 16, 16, OImode)\n-DEF_MACHMODE (OImode, \"OI\", MODE_INT, BITS_PER_UNIT*32, 32, 32, VOIDmode)\n+DEF_MACHMODE (BImode, \"BI\", MODE_INT, 1, 1, 1, QImode, VOIDmode)\n+DEF_MACHMODE (QImode, \"QI\", MODE_INT, BITS_PER_UNIT, 1, 1, HImode, VOIDmode)\n+DEF_MACHMODE (HImode, \"HI\", MODE_INT, BITS_PER_UNIT*2, 2, 2, SImode, VOIDmode)\n+DEF_MACHMODE (SImode, \"SI\", MODE_INT, BITS_PER_UNIT*4, 4, 4, DImode, VOIDmode)\n+DEF_MACHMODE (DImode, \"DI\", MODE_INT, BITS_PER_UNIT*8, 8, 8, TImode, VOIDmode)\n+DEF_MACHMODE (TImode, \"TI\", MODE_INT, BITS_PER_UNIT*16, 16, 16, OImode, VOIDmode)\n+DEF_MACHMODE (OImode, \"OI\", MODE_INT, BITS_PER_UNIT*32, 32, 32, VOIDmode, VOIDmode)\n \n /* Pointers on some machines use these types to distinguish them from\n    ints.  Useful if a pointer is 4 bytes but has some bits that are\n    not significant, so it is really not quite as wide as an integer.  */\n-DEF_MACHMODE (PQImode, \"PQI\", MODE_PARTIAL_INT, BITS_PER_UNIT, 1, 1, PHImode)\n-DEF_MACHMODE (PHImode, \"PHI\", MODE_PARTIAL_INT, BITS_PER_UNIT*2, 2, 2, PSImode)\n-DEF_MACHMODE (PSImode, \"PSI\", MODE_PARTIAL_INT, BITS_PER_UNIT*4, 4, 4, PDImode)\n-DEF_MACHMODE (PDImode, \"PDI\", MODE_PARTIAL_INT, BITS_PER_UNIT*8, 8, 8, VOIDmode)\n-\n-DEF_MACHMODE (QFmode, \"QF\", MODE_FLOAT, BITS_PER_UNIT, 1, 1, HFmode)\n-DEF_MACHMODE (HFmode, \"HF\", MODE_FLOAT, BITS_PER_UNIT*2, 2, 2, TQFmode)\n-DEF_MACHMODE (TQFmode, \"TQF\", MODE_FLOAT, BITS_PER_UNIT*3, 3, 3, SFmode) /* MIL-STD-1750A */\n-DEF_MACHMODE (SFmode, \"SF\", MODE_FLOAT, BITS_PER_UNIT*4, 4, 4, DFmode)\n-DEF_MACHMODE (DFmode, \"DF\", MODE_FLOAT, BITS_PER_UNIT*8, 8, 8, XFmode)\n-DEF_MACHMODE (XFmode, \"XF\", MODE_FLOAT, BITS_PER_UNIT*12, 12, 12, TFmode) /* IEEE extended */\n-DEF_MACHMODE (TFmode, \"TF\", MODE_FLOAT, BITS_PER_UNIT*16, 16, 16, VOIDmode)\n+DEF_MACHMODE (PQImode, \"PQI\", MODE_PARTIAL_INT, BITS_PER_UNIT, 1, 1, PHImode, VOIDmode)\n+DEF_MACHMODE (PHImode, \"PHI\", MODE_PARTIAL_INT, BITS_PER_UNIT*2, 2, 2, PSImode, VOIDmode)\n+DEF_MACHMODE (PSImode, \"PSI\", MODE_PARTIAL_INT, BITS_PER_UNIT*4, 4, 4, PDImode, VOIDmode)\n+DEF_MACHMODE (PDImode, \"PDI\", MODE_PARTIAL_INT, BITS_PER_UNIT*8, 8, 8, VOIDmode, VOIDmode)\n+\n+DEF_MACHMODE (QFmode, \"QF\", MODE_FLOAT, BITS_PER_UNIT, 1, 1, HFmode, VOIDmode)\n+DEF_MACHMODE (HFmode, \"HF\", MODE_FLOAT, BITS_PER_UNIT*2, 2, 2, TQFmode, VOIDmode)\n+DEF_MACHMODE (TQFmode, \"TQF\", MODE_FLOAT, BITS_PER_UNIT*3, 3, 3, SFmode, VOIDmode) /* MIL-STD-1750A */\n+DEF_MACHMODE (SFmode, \"SF\", MODE_FLOAT, BITS_PER_UNIT*4, 4, 4, DFmode, VOIDmode)\n+DEF_MACHMODE (DFmode, \"DF\", MODE_FLOAT, BITS_PER_UNIT*8, 8, 8, XFmode, VOIDmode)\n+DEF_MACHMODE (XFmode, \"XF\", MODE_FLOAT, BITS_PER_UNIT*12, 12, 12, TFmode, VOIDmode) /* IEEE extended */\n+DEF_MACHMODE (TFmode, \"TF\", MODE_FLOAT, BITS_PER_UNIT*16, 16, 16, VOIDmode, VOIDmode)\n \n /* Complex modes.  */\n-DEF_MACHMODE (QCmode, \"QC\", MODE_COMPLEX_FLOAT, BITS_PER_UNIT*2, 2, 1, HCmode)\n-DEF_MACHMODE (HCmode, \"HC\", MODE_COMPLEX_FLOAT, BITS_PER_UNIT*4, 4, 2, SCmode)\n-DEF_MACHMODE (SCmode, \"SC\", MODE_COMPLEX_FLOAT, BITS_PER_UNIT*8, 8, 4, DCmode)\n-DEF_MACHMODE (DCmode, \"DC\", MODE_COMPLEX_FLOAT, BITS_PER_UNIT*16, 16, 8, XCmode)\n-DEF_MACHMODE (XCmode, \"XC\", MODE_COMPLEX_FLOAT, BITS_PER_UNIT*24, 24, 12, TCmode)\n-DEF_MACHMODE (TCmode, \"TC\", MODE_COMPLEX_FLOAT, BITS_PER_UNIT*32, 32, 16, VOIDmode)\n-\n-DEF_MACHMODE (CQImode, \"CQI\", MODE_COMPLEX_INT, BITS_PER_UNIT*2, 2, 1, CHImode)\n-DEF_MACHMODE (CHImode, \"CHI\", MODE_COMPLEX_INT, BITS_PER_UNIT*4, 4, 2, CSImode)\n-DEF_MACHMODE (CSImode, \"CSI\", MODE_COMPLEX_INT, BITS_PER_UNIT*8, 8, 4, CDImode)\n-DEF_MACHMODE (CDImode, \"CDI\", MODE_COMPLEX_INT, BITS_PER_UNIT*16, 16, 8, CTImode)\n-DEF_MACHMODE (CTImode, \"CTI\", MODE_COMPLEX_INT, BITS_PER_UNIT*32, 32, 16, COImode)\n-DEF_MACHMODE (COImode, \"COI\", MODE_COMPLEX_INT, BITS_PER_UNIT*64, 64, 32, VOIDmode)\n+DEF_MACHMODE (QCmode, \"QC\", MODE_COMPLEX_FLOAT, BITS_PER_UNIT*2, 2, 1, HCmode, VOIDmode)\n+DEF_MACHMODE (HCmode, \"HC\", MODE_COMPLEX_FLOAT, BITS_PER_UNIT*4, 4, 2, SCmode, VOIDmode)\n+DEF_MACHMODE (SCmode, \"SC\", MODE_COMPLEX_FLOAT, BITS_PER_UNIT*8, 8, 4, DCmode, VOIDmode)\n+DEF_MACHMODE (DCmode, \"DC\", MODE_COMPLEX_FLOAT, BITS_PER_UNIT*16, 16, 8, XCmode, VOIDmode)\n+DEF_MACHMODE (XCmode, \"XC\", MODE_COMPLEX_FLOAT, BITS_PER_UNIT*24, 24, 12, TCmode, VOIDmode)\n+DEF_MACHMODE (TCmode, \"TC\", MODE_COMPLEX_FLOAT, BITS_PER_UNIT*32, 32, 16, VOIDmode, VOIDmode)\n+\n+DEF_MACHMODE (CQImode, \"CQI\", MODE_COMPLEX_INT, BITS_PER_UNIT*2, 2, 1, CHImode, VOIDmode)\n+DEF_MACHMODE (CHImode, \"CHI\", MODE_COMPLEX_INT, BITS_PER_UNIT*4, 4, 2, CSImode, VOIDmode)\n+DEF_MACHMODE (CSImode, \"CSI\", MODE_COMPLEX_INT, BITS_PER_UNIT*8, 8, 4, CDImode, VOIDmode)\n+DEF_MACHMODE (CDImode, \"CDI\", MODE_COMPLEX_INT, BITS_PER_UNIT*16, 16, 8, CTImode, VOIDmode)\n+DEF_MACHMODE (CTImode, \"CTI\", MODE_COMPLEX_INT, BITS_PER_UNIT*32, 32, 16, COImode, VOIDmode)\n+DEF_MACHMODE (COImode, \"COI\", MODE_COMPLEX_INT, BITS_PER_UNIT*64, 64, 32, VOIDmode, VOIDmode)\n \n /* Vector modes.  */\n /* There are no V1xx vector modes.  These are equivalent to normal\n    scalar modes.  */\n /* The wider mode field for vectors follows in order of increasing bit\n    size with QI coming before HI, HI before SI, and SI before DI\n    within same bit sizes.  */\n-DEF_MACHMODE (V2QImode, \"V2QI\", MODE_VECTOR_INT, BITS_PER_UNIT*2, 2, 1, V4QImode)\n-DEF_MACHMODE (V2HImode, \"V2HI\", MODE_VECTOR_INT, BITS_PER_UNIT*4, 4, 2, V8QImode)\n-DEF_MACHMODE (V2SImode, \"V2SI\", MODE_VECTOR_INT, BITS_PER_UNIT*8, 8, 4, V16QImode)\n-DEF_MACHMODE (V2DImode, \"V2DI\", MODE_VECTOR_INT, BITS_PER_UNIT*16, 16, 8, V8SImode)\n+DEF_MACHMODE (V2QImode, \"V2QI\", MODE_VECTOR_INT, BITS_PER_UNIT*2, 2, 1, V4QImode, QImode)\n+DEF_MACHMODE (V2HImode, \"V2HI\", MODE_VECTOR_INT, BITS_PER_UNIT*4, 4, 2, V8QImode, HImode)\n+DEF_MACHMODE (V2SImode, \"V2SI\", MODE_VECTOR_INT, BITS_PER_UNIT*8, 8, 4, V16QImode, SImode)\n+DEF_MACHMODE (V2DImode, \"V2DI\", MODE_VECTOR_INT, BITS_PER_UNIT*16, 16, 8, V8SImode, DImode)\n \n-DEF_MACHMODE (V4QImode, \"V4QI\", MODE_VECTOR_INT, BITS_PER_UNIT*4, 4, 1, V2HImode)\n-DEF_MACHMODE (V4HImode, \"V4HI\", MODE_VECTOR_INT, BITS_PER_UNIT*8, 8, 2, V2SImode)\n-DEF_MACHMODE (V4SImode, \"V4SI\", MODE_VECTOR_INT, BITS_PER_UNIT*16, 16, 4, V2DImode)\n-DEF_MACHMODE (V4DImode, \"V4DI\", MODE_VECTOR_INT, BITS_PER_UNIT*32, 32, 8, V8DImode)\n+DEF_MACHMODE (V4QImode, \"V4QI\", MODE_VECTOR_INT, BITS_PER_UNIT*4, 4, 1, V2HImode, QImode)\n+DEF_MACHMODE (V4HImode, \"V4HI\", MODE_VECTOR_INT, BITS_PER_UNIT*8, 8, 2, V2SImode, HImode)\n+DEF_MACHMODE (V4SImode, \"V4SI\", MODE_VECTOR_INT, BITS_PER_UNIT*16, 16, 4, V2DImode, SImode)\n+DEF_MACHMODE (V4DImode, \"V4DI\", MODE_VECTOR_INT, BITS_PER_UNIT*32, 32, 8, V8DImode, DImode)\n \n-DEF_MACHMODE (V8QImode, \"V8QI\", MODE_VECTOR_INT, BITS_PER_UNIT*8, 8, 1, V4HImode)\n-DEF_MACHMODE (V8HImode, \"V8HI\", MODE_VECTOR_INT, BITS_PER_UNIT*16, 16, 2, V4SImode)\n-DEF_MACHMODE (V8SImode, \"V8SI\", MODE_VECTOR_INT, BITS_PER_UNIT*32, 32, 4, V4DImode)\n-DEF_MACHMODE (V8DImode, \"V8DI\", MODE_VECTOR_INT, BITS_PER_UNIT*64, 64, 8, VOIDmode)\n+DEF_MACHMODE (V8QImode, \"V8QI\", MODE_VECTOR_INT, BITS_PER_UNIT*8, 8, 1, V4HImode, QImode)\n+DEF_MACHMODE (V8HImode, \"V8HI\", MODE_VECTOR_INT, BITS_PER_UNIT*16, 16, 2, V4SImode, HImode)\n+DEF_MACHMODE (V8SImode, \"V8SI\", MODE_VECTOR_INT, BITS_PER_UNIT*32, 32, 4, V4DImode, SImode)\n+DEF_MACHMODE (V8DImode, \"V8DI\", MODE_VECTOR_INT, BITS_PER_UNIT*64, 64, 8, VOIDmode, DImode)\n \n-DEF_MACHMODE (V16QImode, \"V16QI\", MODE_VECTOR_INT, BITS_PER_UNIT*16, 16, 1, V8HImode)\n+DEF_MACHMODE (V16QImode, \"V16QI\", MODE_VECTOR_INT, BITS_PER_UNIT*16, 16, 1, V8HImode, QImode)\n \n-DEF_MACHMODE (V2SFmode, \"V2SF\", MODE_VECTOR_FLOAT, BITS_PER_UNIT*8, 8, 4, V4SFmode)\n-DEF_MACHMODE (V2DFmode, \"V2DF\", MODE_VECTOR_FLOAT, BITS_PER_UNIT*16, 16, 8, V8SFmode)\n+DEF_MACHMODE (V2SFmode, \"V2SF\", MODE_VECTOR_FLOAT, BITS_PER_UNIT*8, 8, 4, V4SFmode, SFmode)\n+DEF_MACHMODE (V2DFmode, \"V2DF\", MODE_VECTOR_FLOAT, BITS_PER_UNIT*16, 16, 8, V8SFmode, DFmode)\n \n-DEF_MACHMODE (V4SFmode, \"V4SF\", MODE_VECTOR_FLOAT, BITS_PER_UNIT*16, 16, 4, V2DFmode)\n-DEF_MACHMODE (V4DFmode, \"V4DF\", MODE_VECTOR_FLOAT, BITS_PER_UNIT*32, 32, 8, V8DFmode)\n+DEF_MACHMODE (V4SFmode, \"V4SF\", MODE_VECTOR_FLOAT, BITS_PER_UNIT*16, 16, 4, V2DFmode, SFmode)\n+DEF_MACHMODE (V4DFmode, \"V4DF\", MODE_VECTOR_FLOAT, BITS_PER_UNIT*32, 32, 8, V8DFmode, DFmode)\n \n-DEF_MACHMODE (V8SFmode, \"V8SF\", MODE_VECTOR_FLOAT, BITS_PER_UNIT*32, 32, 4,V4DFmode)\n-DEF_MACHMODE (V8DFmode, \"V8DF\", MODE_VECTOR_FLOAT, BITS_PER_UNIT*64, 64, 8, VOIDmode)\n-DEF_MACHMODE (V16SFmode, \"V16SF\", MODE_VECTOR_FLOAT, 512, 64, 4, VOIDmode)\n+DEF_MACHMODE (V8SFmode, \"V8SF\", MODE_VECTOR_FLOAT, BITS_PER_UNIT*32, 32, 4,V4DFmode, SFmode)\n+DEF_MACHMODE (V8DFmode, \"V8DF\", MODE_VECTOR_FLOAT, BITS_PER_UNIT*64, 64, 8, VOIDmode, DFmode)\n+DEF_MACHMODE (V16SFmode, \"V16SF\", MODE_VECTOR_FLOAT, 512, 64, 4, VOIDmode, SFmode)\n \n /* BLKmode is used for structures, arrays, etc.\n    that fit no more specific mode.  */\n-DEF_MACHMODE (BLKmode, \"BLK\", MODE_RANDOM, 0, 0, 0, VOIDmode)\n+DEF_MACHMODE (BLKmode, \"BLK\", MODE_RANDOM, 0, 0, 0, VOIDmode, VOIDmode)\n \n /* The modes for representing the condition codes come last.  CCmode\n    is always defined.  Additional modes for the condition code can be\n    specified in the EXTRA_CC_MODES macro.  All MODE_CC modes are the\n    same width as SImode and have VOIDmode as their next wider mode.  */\n \n-#define CC(E, M)  DEF_MACHMODE (E, M, MODE_CC, BITS_PER_UNIT*4, 4, 4, VOIDmode)\n+#define CC(E, M)  DEF_MACHMODE (E, M, MODE_CC, BITS_PER_UNIT*4, 4, 4, VOIDmode, VOIDmode)\n \n CC (CCmode, \"CC\")\n \n@@ -167,7 +171,7 @@ EXTRA_CC_MODES\n    lot of redundancy in ports that support both 32-bit and 64-bit targets.  */\n #ifdef GENERATOR_FILE\n #undef Pmode\n-DEF_MACHMODE (Pmode, \"P\", MODE_RANDOM, 0, 0, 0, VOIDmode)\n+DEF_MACHMODE (Pmode, \"P\", MODE_RANDOM, 0, 0, 0, VOIDmode, VOIDmode)\n #endif\n \n /*"}, {"sha": "f581cd041bd7bc74c5ca9e458f9ee00f6b33ee1c", "filename": "gcc/machmode.h", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69ef87e2bc8b929b7af75c3f03aafd1f12121b67/gcc%2Fmachmode.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69ef87e2bc8b929b7af75c3f03aafd1f12121b67/gcc%2Fmachmode.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmachmode.h?ref=69ef87e2bc8b929b7af75c3f03aafd1f12121b67", "patch": "@@ -24,7 +24,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n \n /* Make an enum class that gives all the machine modes.  */\n \n-#define DEF_MACHMODE(SYM, NAME, TYPE, BITSIZE, SIZE, UNIT, WIDER)  SYM,\n+#define DEF_MACHMODE(SYM, NAME, TYPE, BITSIZE, SIZE, UNIT, WIDER, INNER)  SYM,\n \n enum machine_mode {\n #include \"machmode.def\"\n@@ -107,6 +107,12 @@ extern const unsigned HOST_WIDE_INT mode_mask_array[NUM_MACHINE_MODES];\n \n #define GET_MODE_MASK(MODE) mode_mask_array[(int) (MODE)]\n \n+extern const enum machine_mode inner_mode_array[NUM_MACHINE_MODES];\n+\n+/* Return the mode of the inner elements in a vector.  */\n+\n+#define GET_MODE_INNER(MODE) inner_mode_array[(int) (MODE)]\n+\n #endif /* defined (HOST_WIDE_INT) && ! defined GET_MODE_MASK */\n \n #if ! defined GET_MODE_WIDER_MODE || ! defined GET_MODE_ALIGNMENT \\"}, {"sha": "adb1881728813c19ef868b6ef49ca4f2954dfe7d", "filename": "gcc/print-tree.c", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69ef87e2bc8b929b7af75c3f03aafd1f12121b67/gcc%2Fprint-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69ef87e2bc8b929b7af75c3f03aafd1f12121b67/gcc%2Fprint-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-tree.c?ref=69ef87e2bc8b929b7af75c3f03aafd1f12121b67", "patch": "@@ -707,6 +707,22 @@ print_node (file, prefix, node, indent)\n \t  }\n \t  break;\n \n+\tcase VECTOR_CST:\n+\t  {\n+\t    tree vals = TREE_VECTOR_CST_ELTS (node);\n+\t    char buf[10];\n+\t    tree link;\n+\t    int i;\n+\n+\t    i = 0;\n+\t    for (link = vals; link; link = TREE_CHAIN (link), ++i)\n+\t      {\n+\t\tsprintf (buf, \"elt%d: \", i);\n+\t\tprint_node (file, buf, TREE_VALUE (link), indent + 4);\n+\t      }\n+\t  }\n+\t  break;\n+\n \tcase COMPLEX_CST:\n \t  print_node (file, \"real\", TREE_REALPART (node), indent + 4);\n \t  print_node (file, \"imag\", TREE_IMAGPART (node), indent + 4);"}, {"sha": "6039c4d607a9b430abc7809eca570df88ec7d0b0", "filename": "gcc/recog.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69ef87e2bc8b929b7af75c3f03aafd1f12121b67/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69ef87e2bc8b929b7af75c3f03aafd1f12121b67/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=69ef87e2bc8b929b7af75c3f03aafd1f12121b67", "patch": "@@ -753,6 +753,7 @@ find_single_use_1 (dest, loc)\n     case LABEL_REF:\n     case SYMBOL_REF:\n     case CONST_DOUBLE:\n+    case CONST_VECTOR:\n     case CLOBBER:\n       return 0;\n "}, {"sha": "93a5edbaf2a20d40634517730fac9b074f1718e1", "filename": "gcc/regclass.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69ef87e2bc8b929b7af75c3f03aafd1f12121b67/gcc%2Fregclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69ef87e2bc8b929b7af75c3f03aafd1f12121b67/gcc%2Fregclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregclass.c?ref=69ef87e2bc8b929b7af75c3f03aafd1f12121b67", "patch": "@@ -2416,6 +2416,7 @@ reg_scan_mark_refs (x, insn, note_flag, min_regno)\n     case CONST:\n     case CONST_INT:\n     case CONST_DOUBLE:\n+    case CONST_VECTOR:\n     case CC0:\n     case PC:\n     case SYMBOL_REF:"}, {"sha": "6277398945d651457e1d63a0df7bc57124c1697b", "filename": "gcc/regrename.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69ef87e2bc8b929b7af75c3f03aafd1f12121b67/gcc%2Fregrename.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69ef87e2bc8b929b7af75c3f03aafd1f12121b67/gcc%2Fregrename.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregrename.c?ref=69ef87e2bc8b929b7af75c3f03aafd1f12121b67", "patch": "@@ -678,6 +678,7 @@ scan_rtx (insn, loc, class, action, type, earlyclobber)\n     case CONST:\n     case CONST_INT:\n     case CONST_DOUBLE:\n+    case CONST_VECTOR:\n     case SYMBOL_REF:\n     case LABEL_REF:\n     case CC0:"}, {"sha": "c4231a2ea123d2b38537b689aa29ca9e8f93320a", "filename": "gcc/reload.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69ef87e2bc8b929b7af75c3f03aafd1f12121b67/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69ef87e2bc8b929b7af75c3f03aafd1f12121b67/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=69ef87e2bc8b929b7af75c3f03aafd1f12121b67", "patch": "@@ -4927,6 +4927,7 @@ subst_reg_equivs (ad, insn)\n     case CONST_INT:\n     case CONST:\n     case CONST_DOUBLE:\n+    case CONST_VECTOR:\n     case SYMBOL_REF:\n     case LABEL_REF:\n     case PC:"}, {"sha": "7b420a1ea3d5282b0974c62f59da451a5202dba4", "filename": "gcc/reload1.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69ef87e2bc8b929b7af75c3f03aafd1f12121b67/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69ef87e2bc8b929b7af75c3f03aafd1f12121b67/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=69ef87e2bc8b929b7af75c3f03aafd1f12121b67", "patch": "@@ -2282,6 +2282,7 @@ eliminate_regs (x, mem_mode, insn)\n     {\n     case CONST_INT:\n     case CONST_DOUBLE:\n+    case CONST_VECTOR:\n     case CONST:\n     case SYMBOL_REF:\n     case CODE_LABEL:\n@@ -2660,6 +2661,7 @@ elimination_effects (x, mem_mode)\n     {\n     case CONST_INT:\n     case CONST_DOUBLE:\n+    case CONST_VECTOR:\n     case CONST:\n     case SYMBOL_REF:\n     case CODE_LABEL:\n@@ -3749,6 +3751,7 @@ scan_paradoxical_subregs (x)\n     case SYMBOL_REF:\n     case LABEL_REF:\n     case CONST_DOUBLE:\n+    case CONST_VECTOR: /* shouldn't happen, but just in case.  */\n     case CC0:\n     case PC:\n     case USE:"}, {"sha": "f306abb304ef467d0430410eedcb7fb3a599f439", "filename": "gcc/resource.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69ef87e2bc8b929b7af75c3f03aafd1f12121b67/gcc%2Fresource.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69ef87e2bc8b929b7af75c3f03aafd1f12121b67/gcc%2Fresource.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fresource.c?ref=69ef87e2bc8b929b7af75c3f03aafd1f12121b67", "patch": "@@ -212,6 +212,7 @@ mark_referenced_resources (x, res, include_delayed_effects)\n     case CONST:\n     case CONST_INT:\n     case CONST_DOUBLE:\n+    case CONST_VECTOR:\n     case PC:\n     case SYMBOL_REF:\n     case LABEL_REF:\n@@ -645,6 +646,7 @@ mark_set_resources (x, res, in_dest, mark_type)\n     case USE:\n     case CONST_INT:\n     case CONST_DOUBLE:\n+    case CONST_VECTOR:\n     case LABEL_REF:\n     case SYMBOL_REF:\n     case CONST:"}, {"sha": "6077232d0e7a72e152165071be68e16472c010d8", "filename": "gcc/rtl.c", "status": "modified", "additions": 28, "deletions": 8, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69ef87e2bc8b929b7af75c3f03aafd1f12121b67/gcc%2Frtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69ef87e2bc8b929b7af75c3f03aafd1f12121b67/gcc%2Frtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.c?ref=69ef87e2bc8b929b7af75c3f03aafd1f12121b67", "patch": "@@ -115,7 +115,7 @@ const char * const rtx_name[NUM_RTX_CODE] = {\n /* Indexed by machine mode, gives the name of that machine mode.\n    This name does not include the letters \"mode\".  */\n \n-#define DEF_MACHMODE(SYM, NAME, CLASS, BITSIZE, SIZE, UNIT, WIDER)  NAME,\n+#define DEF_MACHMODE(SYM, NAME, CLASS, BITSIZE, SIZE, UNIT, WIDER, INNER)  NAME,\n \n const char * const mode_name[NUM_MACHINE_MODES] = {\n #include \"machmode.def\"\n@@ -125,7 +125,7 @@ const char * const mode_name[NUM_MACHINE_MODES] = {\n \n /* Indexed by machine mode, gives the class mode for GET_MODE_CLASS.  */\n \n-#define DEF_MACHMODE(SYM, NAME, CLASS, BITSIZE, SIZE, UNIT, WIDER)  CLASS,\n+#define DEF_MACHMODE(SYM, NAME, CLASS, BITSIZE, SIZE, UNIT, WIDER, INNER)  CLASS,\n \n const enum mode_class mode_class[NUM_MACHINE_MODES] = {\n #include \"machmode.def\"\n@@ -136,7 +136,7 @@ const enum mode_class mode_class[NUM_MACHINE_MODES] = {\n /* Indexed by machine mode, gives the length of the mode, in bits.\n    GET_MODE_BITSIZE uses this.  */\n \n-#define DEF_MACHMODE(SYM, NAME, CLASS, BITSIZE, SIZE, UNIT, WIDER)  BITSIZE,\n+#define DEF_MACHMODE(SYM, NAME, CLASS, BITSIZE, SIZE, UNIT, WIDER, INNER)  BITSIZE,\n \n const unsigned short mode_bitsize[NUM_MACHINE_MODES] = {\n #include \"machmode.def\"\n@@ -147,7 +147,7 @@ const unsigned short mode_bitsize[NUM_MACHINE_MODES] = {\n /* Indexed by machine mode, gives the length of the mode, in bytes.\n    GET_MODE_SIZE uses this.  */\n \n-#define DEF_MACHMODE(SYM, NAME, CLASS, BITSIZE, SIZE, UNIT, WIDER)  SIZE,\n+#define DEF_MACHMODE(SYM, NAME, CLASS, BITSIZE, SIZE, UNIT, WIDER, INNER)  SIZE,\n \n const unsigned char mode_size[NUM_MACHINE_MODES] = {\n #include \"machmode.def\"\n@@ -158,7 +158,7 @@ const unsigned char mode_size[NUM_MACHINE_MODES] = {\n /* Indexed by machine mode, gives the length of the mode's subunit.\n    GET_MODE_UNIT_SIZE uses this.  */\n \n-#define DEF_MACHMODE(SYM, NAME, CLASS, BITSIZE, SIZE, UNIT, WIDER)  UNIT,\n+#define DEF_MACHMODE(SYM, NAME, CLASS, BITSIZE, SIZE, UNIT, WIDER, INNER)  UNIT,\n \n const unsigned char mode_unit_size[NUM_MACHINE_MODES] = {\n #include \"machmode.def\"\t\t/* machine modes are documented here */\n@@ -170,7 +170,7 @@ const unsigned char mode_unit_size[NUM_MACHINE_MODES] = {\n    (QI -> HI -> SI -> DI, etc.)  Widening multiply instructions\n    use this.  */\n \n-#define DEF_MACHMODE(SYM, NAME, CLASS, BITSIZE, SIZE, UNIT, WIDER)  \\\n+#define DEF_MACHMODE(SYM, NAME, CLASS, BITSIZE, SIZE, UNIT, WIDER, INNER)  \\\n   (unsigned char) WIDER,\n \n const unsigned char mode_wider_mode[NUM_MACHINE_MODES] = {\n@@ -179,7 +179,7 @@ const unsigned char mode_wider_mode[NUM_MACHINE_MODES] = {\n \n #undef DEF_MACHMODE\n \n-#define DEF_MACHMODE(SYM, NAME, CLASS, BITSIZE, SIZE, UNIT, WIDER)  \\\n+#define DEF_MACHMODE(SYM, NAME, CLASS, BITSIZE, SIZE, UNIT, WIDER, INNER)  \\\n   ((BITSIZE) >= HOST_BITS_PER_WIDE_INT) ? ~(unsigned HOST_WIDE_INT) 0 : ((unsigned HOST_WIDE_INT) 1 << (BITSIZE)) - 1,\n \n /* Indexed by machine mode, gives mask of significant bits in mode.  */\n@@ -188,6 +188,17 @@ const unsigned HOST_WIDE_INT mode_mask_array[NUM_MACHINE_MODES] = {\n #include \"machmode.def\"\n };\n \n+#undef DEF_MACHMODE\n+\n+#define DEF_MACHMODE(SYM, NAME, CLASS, BITSIZE, SIZE, UNIT, WIDER, INNER) INNER,\n+\n+/* Indexed by machine mode, gives the mode of the inner elements in a\n+   vector type.  */\n+\n+const enum machine_mode inner_mode_array[NUM_MACHINE_MODES] = {\n+#include \"machmode.def\"\n+};\n+\n /* Indexed by mode class, gives the narrowest mode for each class.\n    The Q modes are always of width 1 (2 for complex) - it is impossible\n    for any mode to be narrower.\n@@ -346,6 +357,7 @@ copy_rtx (orig)\n     case QUEUED:\n     case CONST_INT:\n     case CONST_DOUBLE:\n+    case CONST_VECTOR:\n     case SYMBOL_REF:\n     case CODE_LABEL:\n     case PC:\n@@ -455,6 +467,7 @@ copy_most_rtx (orig, may_share)\n     case QUEUED:\n     case CONST_INT:\n     case CONST_DOUBLE:\n+    case CONST_VECTOR:\n     case SYMBOL_REF:\n     case CODE_LABEL:\n     case PC:\n@@ -560,7 +573,13 @@ unsigned int\n get_mode_alignment (mode)\n      enum machine_mode mode;\n {\n-  unsigned int alignment = GET_MODE_UNIT_SIZE (mode);\n+  unsigned int alignment;\n+\n+  if (GET_MODE_CLASS (mode) == MODE_COMPLEX_FLOAT\n+      || GET_MODE_CLASS (mode) == MODE_COMPLEX_INT)\n+    alignment = GET_MODE_UNIT_SIZE (mode);\n+  else\n+    alignment = GET_MODE_SIZE (mode);\n   \n   /* Extract the LSB of the size.  */\n   alignment = alignment & -alignment;\n@@ -626,6 +645,7 @@ rtx_equal_p (x, y)\n     case SCRATCH:\n     case CONST_DOUBLE:\n     case CONST_INT:\n+    case CONST_VECTOR:\n       return 0;\n \n     default:"}, {"sha": "8fad65018647b1c3324dbb6fb226b96d969dc3ce", "filename": "gcc/rtl.def", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69ef87e2bc8b929b7af75c3f03aafd1f12121b67/gcc%2Frtl.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69ef87e2bc8b929b7af75c3f03aafd1f12121b67/gcc%2Frtl.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.def?ref=69ef87e2bc8b929b7af75c3f03aafd1f12121b67", "patch": "@@ -585,6 +585,9 @@ DEF_RTL_EXPR(CONST_INT, \"const_int\", \"w\", 'o')\n    there may be from 1 to 4; see rtl.c.  */\n DEF_RTL_EXPR(CONST_DOUBLE, \"const_double\", CONST_DOUBLE_FORMAT, 'o')\n \n+/* Describes a vector constant.  */\n+DEF_RTL_EXPR(CONST_VECTOR, \"const_vector\", \"E\", 'x')\n+\n /* String constant.  Used only for attributes right now.  */\n DEF_RTL_EXPR(CONST_STRING, \"const_string\", \"s\", 'o')\n \n@@ -972,10 +975,6 @@ DEF_RTL_EXPR(VEC_SELECT, \"vec_select\", \"ee\", 'x')\n    combined and is the concatenation of the two source vectors.  */\n DEF_RTL_EXPR(VEC_CONCAT, \"vec_concat\", \"ee\", 'x')\n \n-/* Describes a vector constant.  Each part of the PARALLEL that is operand 0\n-   describes a constant for one of the subparts.  */\n-DEF_RTL_EXPR(VEC_CONST, \"vec_const\", \"e\", 'x')\n-\n /* Describes an operation that converts a small vector into a larger one by\n    duplicating the input values.  The output vector mode must have the same\n    submodes as the input vector mode, and the number of output parts must be"}, {"sha": "714faac91c694d50ec31cd099b69cdfe452088dd", "filename": "gcc/rtl.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69ef87e2bc8b929b7af75c3f03aafd1f12121b67/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69ef87e2bc8b929b7af75c3f03aafd1f12121b67/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=69ef87e2bc8b929b7af75c3f03aafd1f12121b67", "patch": "@@ -255,6 +255,7 @@ struct rtvec_def {\n   (GET_CODE (X) == LABEL_REF || GET_CODE (X) == SYMBOL_REF\t\t\\\n    || GET_CODE (X) == CONST_INT || GET_CODE (X) == CONST_DOUBLE\t\t\\\n    || GET_CODE (X) == CONST || GET_CODE (X) == HIGH\t\t\t\\\n+   || GET_CODE (X) == CONST_VECTOR\t                                \\\n    || GET_CODE (X) == CONSTANT_P_RTX)\n \n /* General accessor macros for accessing the fields of an rtx.  */\n@@ -823,6 +824,12 @@ extern const char * const note_insn_name[NOTE_INSN_MAX - NOTE_INSN_BIAS];\n /* Link for chain of all CONST_DOUBLEs in use in current function.  */\n #define CONST_DOUBLE_CHAIN(r) XCEXP (r, 0, CONST_DOUBLE)\n \n+/* For a CONST_VECTOR, return element #n.  */\n+#define CONST_VECTOR_ELT(RTX, N) XCVECEXP (RTX, 0, N, CONST_VECTOR)\n+\n+/* For a CONST_VECTOR, return the number of elements in a vector.  */\n+#define CONST_VECTOR_NUNITS(RTX) XCVECLEN (RTX, 0, CONST_VECTOR)\n+\n /* For a SUBREG rtx, SUBREG_REG extracts the value we want a subreg of.\n    SUBREG_BYTE extracts the byte-number.  */\n "}, {"sha": "37f1e64910acebee9188b8d25936ea59b7900662", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69ef87e2bc8b929b7af75c3f03aafd1f12121b67/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69ef87e2bc8b929b7af75c3f03aafd1f12121b67/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=69ef87e2bc8b929b7af75c3f03aafd1f12121b67", "patch": "@@ -64,6 +64,7 @@ rtx_unstable_p (x)\n     case CONST:\n     case CONST_INT:\n     case CONST_DOUBLE:\n+    case CONST_VECTOR:\n     case SYMBOL_REF:\n     case LABEL_REF:\n       return 0;\n@@ -139,6 +140,7 @@ rtx_varies_p (x, for_alias)\n     case CONST:\n     case CONST_INT:\n     case CONST_DOUBLE:\n+    case CONST_VECTOR:\n     case SYMBOL_REF:\n     case LABEL_REF:\n       return 0;\n@@ -502,6 +504,7 @@ count_occurrences (x, find, count_dest)\n     case REG:\n     case CONST_INT:\n     case CONST_DOUBLE:\n+    case CONST_VECTOR:\n     case SYMBOL_REF:\n     case CODE_LABEL:\n     case PC:\n@@ -580,7 +583,8 @@ reg_mentioned_p (reg, in)\n \n     case CONST_INT:\n       return GET_CODE (reg) == CONST_INT && INTVAL (in) == INTVAL (reg);\n-      \n+\n+    case CONST_VECTOR:\n     case CONST_DOUBLE:\n       /* These are kept unique for a given value.  */\n       return 0;\n@@ -829,6 +833,7 @@ regs_set_between_p (x, start, end)\n     {\n     case CONST_INT:\n     case CONST_DOUBLE:\n+    case CONST_VECTOR:\n     case CONST:\n     case SYMBOL_REF:\n     case LABEL_REF:\n@@ -875,6 +880,7 @@ modified_between_p (x, start, end)\n     {\n     case CONST_INT:\n     case CONST_DOUBLE:\n+    case CONST_VECTOR:\n     case CONST:\n     case SYMBOL_REF:\n     case LABEL_REF:\n@@ -930,6 +936,7 @@ modified_in_p (x, insn)\n     {\n     case CONST_INT:\n     case CONST_DOUBLE:\n+    case CONST_VECTOR:\n     case CONST:\n     case SYMBOL_REF:\n     case LABEL_REF:\n@@ -2021,6 +2028,7 @@ volatile_insn_p (x)\n     case CONST_INT:\n     case CONST:\n     case CONST_DOUBLE:\n+    case CONST_VECTOR:\n     case CC0:\n     case PC:\n     case REG:\n@@ -2087,6 +2095,7 @@ volatile_refs_p (x)\n     case CONST_INT:\n     case CONST:\n     case CONST_DOUBLE:\n+    case CONST_VECTOR:\n     case CC0:\n     case PC:\n     case REG:\n@@ -2153,6 +2162,7 @@ side_effects_p (x)\n     case CONST_INT:\n     case CONST:\n     case CONST_DOUBLE:\n+    case CONST_VECTOR:\n     case CC0:\n     case PC:\n     case REG:\n@@ -2231,6 +2241,7 @@ may_trap_p (x)\n       /* Handle these cases quickly.  */\n     case CONST_INT:\n     case CONST_DOUBLE:\n+    case CONST_VECTOR:\n     case SYMBOL_REF:\n     case LABEL_REF:\n     case CONST:\n@@ -2339,6 +2350,7 @@ inequality_comparisons_p (x)\n     case CC0:\n     case CONST_INT:\n     case CONST_DOUBLE:\n+    case CONST_VECTOR:\n     case CONST:\n     case LABEL_REF:\n     case SYMBOL_REF:\n@@ -2452,6 +2464,7 @@ replace_regs (x, reg_map, nregs, replace_dest)\n     case CC0:\n     case CONST_INT:\n     case CONST_DOUBLE:\n+    case CONST_VECTOR:\n     case CONST:\n     case SYMBOL_REF:\n     case LABEL_REF:\n@@ -2542,6 +2555,7 @@ computed_jump_p_1 (x)\n     case CONST:\n     case CONST_INT:\n     case CONST_DOUBLE:\n+    case CONST_VECTOR:\n     case SYMBOL_REF:\n     case REG:\n       return 1;"}, {"sha": "5fb23b76d9b9bc1fd731e573fa260a6cb86e508a", "filename": "gcc/sched-deps.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69ef87e2bc8b929b7af75c3f03aafd1f12121b67/gcc%2Fsched-deps.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69ef87e2bc8b929b7af75c3f03aafd1f12121b67/gcc%2Fsched-deps.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-deps.c?ref=69ef87e2bc8b929b7af75c3f03aafd1f12121b67", "patch": "@@ -723,6 +723,7 @@ sched_analyze_2 (deps, x, insn)\n     {\n     case CONST_INT:\n     case CONST_DOUBLE:\n+    case CONST_VECTOR:\n     case SYMBOL_REF:\n     case CONST:\n     case LABEL_REF:"}, {"sha": "f8ca55c780f0514b3e7f4992fa4a69818ee3fe91", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69ef87e2bc8b929b7af75c3f03aafd1f12121b67/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69ef87e2bc8b929b7af75c3f03aafd1f12121b67/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=69ef87e2bc8b929b7af75c3f03aafd1f12121b67", "patch": "@@ -1223,6 +1223,7 @@ walk_tree (tp, func, data, htab_)\n     case IDENTIFIER_NODE:\n     case INTEGER_CST:\n     case REAL_CST:\n+    case VECTOR_CST:\n     case STRING_CST:\n     case REAL_TYPE:\n     case COMPLEX_TYPE:"}, {"sha": "764aa798ed8cb27d8f6371e0c71f5387b652700c", "filename": "gcc/tree.c", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69ef87e2bc8b929b7af75c3f03aafd1f12121b67/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69ef87e2bc8b929b7af75c3f03aafd1f12121b67/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=69ef87e2bc8b929b7af75c3f03aafd1f12121b67", "patch": "@@ -558,6 +558,35 @@ build_int_2_wide (low, hi)\n   return t;\n }\n \n+/* Return a new VECTOR_CST node whose type is TYPE and whose values\n+   are in a list pointed by VALS.  */\n+\n+tree\n+build_vector (type, vals)\n+     tree type, vals;\n+{\n+  tree v = make_node (VECTOR_CST);\n+  int over1 = 0, over2 = 0;\n+  tree link;\n+\n+  TREE_VECTOR_CST_ELTS (v) = vals;\n+  TREE_TYPE (v) = type;\n+\n+  /* Iterate through elements and check for overflow.  */\n+  for (link = vals; link; link = TREE_CHAIN (link))\n+    {\n+      tree value = TREE_VALUE (link);\n+\n+      over1 |= TREE_OVERFLOW (value);\n+      over2 |= TREE_CONSTANT_OVERFLOW (value);\n+    }\n+  \n+  TREE_OVERFLOW (v) = over1;\n+  TREE_CONSTANT_OVERFLOW (v) = over2;\n+\n+  return v;\n+}\n+\n /* Return a new REAL_CST node whose type is TYPE and value is D.  */\n \n tree"}, {"sha": "9cfe139ac5716939776d7c0b9e0b0abc06c217f7", "filename": "gcc/tree.def", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69ef87e2bc8b929b7af75c3f03aafd1f12121b67/gcc%2Ftree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69ef87e2bc8b929b7af75c3f03aafd1f12121b67/gcc%2Ftree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.def?ref=69ef87e2bc8b929b7af75c3f03aafd1f12121b67", "patch": "@@ -269,6 +269,9 @@ DEFTREECODE (REAL_CST, \"real_cst\", 'c', 3)\n    Also there is TREE_CST_RTL.  */\n DEFTREECODE (COMPLEX_CST, \"complex_cst\", 'c', 3)\n \n+/* Contents are in TREE_VECTOR_CST_ELTS field.  */\n+DEFTREECODE (VECTOR_CST, \"vector_cst\", 'c', 3)     \n+\n /* Contents are TREE_STRING_LENGTH and TREE_STRING_POINTER fields.\n    Also there is TREE_CST_RTL.  */\n DEFTREECODE (STRING_CST, \"string_cst\", 'c', 3)"}, {"sha": "d4f4c50c636b54ad72742816b3161c2c879072c5", "filename": "gcc/tree.h", "status": "modified", "additions": 25, "deletions": 11, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69ef87e2bc8b929b7af75c3f03aafd1f12121b67/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69ef87e2bc8b929b7af75c3f03aafd1f12121b67/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=69ef87e2bc8b929b7af75c3f03aafd1f12121b67", "patch": "@@ -175,14 +175,14 @@ struct tree_common\n        TREE_VIA_VIRTUAL in\n            TREE_LIST or TREE_VEC\n        TREE_CONSTANT_OVERFLOW in\n-           INTEGER_CST, REAL_CST, COMPLEX_CST\n+           INTEGER_CST, REAL_CST, COMPLEX_CST, VECTOR_CST\n        TREE_SYMBOL_REFERENCED in\n            IDENTIFIER_NODE\n \n    public_flag:\n \n        TREE_OVERFLOW in\n-           INTEGER_CST, REAL_CST, COMPLEX_CST\n+           INTEGER_CST, REAL_CST, COMPLEX_CST, VECTOR_CST\n        TREE_PUBLIC in\n            VAR_DECL or FUNCTION_DECL or IDENTIFIER_NODE\n        TREE_VIA_PUBLIC in\n@@ -512,19 +512,21 @@ extern void tree_class_check_failed PARAMS ((const tree, int,\n    chain is via a `virtual' declaration.  */\n #define TREE_VIA_VIRTUAL(NODE) ((NODE)->common.static_flag)\n \n-/* In an INTEGER_CST, REAL_CST, or COMPLEX_CST, this means there was an\n-   overflow in folding.  This is distinct from TREE_OVERFLOW because ANSI C\n-   requires a diagnostic when overflows occur in constant expressions.  */\n+/* In an INTEGER_CST, REAL_CST, COMPLEX_CST, or VECTOR_CST this means\n+   there was an overflow in folding.  This is distinct from\n+   TREE_OVERFLOW because ANSI C requires a diagnostic when overflows\n+   occur in constant expressions.  */\n #define TREE_CONSTANT_OVERFLOW(NODE) ((NODE)->common.static_flag)\n \n /* In an IDENTIFIER_NODE, this means that assemble_name was called with\n    this string as an argument.  */\n #define TREE_SYMBOL_REFERENCED(NODE) \\\n   (IDENTIFIER_NODE_CHECK (NODE)->common.static_flag)\n \n-/* In an INTEGER_CST, REAL_CST, of COMPLEX_CST, this means there was an\n-   overflow in folding, and no warning has been issued for this subexpression.\n-   TREE_OVERFLOW implies TREE_CONSTANT_OVERFLOW, but not vice versa.  */\n+/* In an INTEGER_CST, REAL_CST, COMPLEX_CST, or VECTOR_CST, this means\n+   there was an overflow in folding, and no warning has been issued\n+   for this subexpression.  TREE_OVERFLOW implies\n+   TREE_CONSTANT_OVERFLOW, but not vice versa.  */\n #define TREE_OVERFLOW(NODE) ((NODE)->common.public_flag)\n \n /* In a VAR_DECL or FUNCTION_DECL,\n@@ -707,9 +709,9 @@ struct tree_int_cst\n   } int_cst;\n };\n \n-/* In REAL_CST, STRING_CST, COMPLEX_CST nodes, and CONSTRUCTOR nodes,\n-   and generally in all kinds of constants that could\n-   be given labels (rather than being immediate).  */\n+/* In REAL_CST, STRING_CST, COMPLEX_CST, VECTOR_CST nodes, and\n+   CONSTRUCTOR nodes, and generally in all kinds of constants that\n+   could be given labels (rather than being immediate).  */\n \n #define TREE_CST_RTL(NODE) (CST_OR_CONSTRUCTOR_CHECK (NODE)->real_cst.rtl)\n \n@@ -752,6 +754,16 @@ struct tree_complex\n   tree real;\n   tree imag;\n };\n+\n+/* In a VECTOR_CST node.  */\n+#define TREE_VECTOR_CST_ELTS(NODE) (VECTOR_CST_CHECK (NODE)->vector.elements)\n+\n+struct tree_vector\n+{\n+  struct tree_common common;\n+  rtx rtl;\n+  tree elements;\n+};\n \f\n #include \"hashtable.h\"\n \n@@ -1843,6 +1855,7 @@ union tree_node\n   struct tree_common common;\n   struct tree_int_cst int_cst;\n   struct tree_real_cst real_cst;\n+  struct tree_vector vector;\n   struct tree_string string;\n   struct tree_complex complex;\n   struct tree_identifier identifier;\n@@ -2093,6 +2106,7 @@ extern tree build\t\t\tPARAMS ((enum tree_code, tree, ...));\n extern tree build_nt\t\t\tPARAMS ((enum tree_code, ...));\n \n extern tree build_int_2_wide\t\tPARAMS ((unsigned HOST_WIDE_INT, HOST_WIDE_INT));\n+extern tree build_vector                PARAMS ((tree, tree));\n extern tree build_real\t\t\tPARAMS ((tree, REAL_VALUE_TYPE));\n extern tree build_real_from_int_cst \tPARAMS ((tree, tree));\n extern tree build_complex\t\tPARAMS ((tree, tree, tree));"}, {"sha": "67d64e6263b69dfff00e96fdc88fc41386646797", "filename": "gcc/varasm.c", "status": "modified", "additions": 75, "deletions": 1, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69ef87e2bc8b929b7af75c3f03aafd1f12121b67/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69ef87e2bc8b929b7af75c3f03aafd1f12121b67/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=69ef87e2bc8b929b7af75c3f03aafd1f12121b67", "patch": "@@ -2382,7 +2382,8 @@ decode_addr_const (exp, value)\n   value->offset = offset;\n }\n \f\n-enum kind { RTX_UNKNOWN, RTX_DOUBLE, RTX_INT, RTX_UNSPEC };\n+/* We do RTX_UNSPEC + XINT (blah), so nothing can go after RTX_UNSPEC.  */\n+enum kind { RTX_UNKNOWN, RTX_DOUBLE, RTX_INT, RTX_VECTOR, RTX_UNSPEC };\n struct rtx_const\n {\n   ENUM_BITFIELD(kind) kind : 16;\n@@ -2391,6 +2392,10 @@ struct rtx_const\n     union real_extract du;\n     struct addr_const addr;\n     struct {HOST_WIDE_INT high, low;} di;\n+\n+    /* The max vector size we have is 8 wide.  This should be enough.  */\n+    HOST_WIDE_INT veclo[16];\n+    HOST_WIDE_INT vechi[16];\n   } un;\n };\n \n@@ -3580,6 +3585,34 @@ decode_rtx_const (mode, x, value)\n \t}\n       break;\n \n+    case CONST_VECTOR:\n+      {\n+\tint units, i;\n+\trtx elt;\n+\n+\tunits = CONST_VECTOR_NUNITS (x);\n+\tvalue->kind = RTX_VECTOR;\n+\tvalue->mode = mode;\n+\n+\tfor (i = 0; i < units; ++i)\n+\t  {\n+\t    elt = CONST_VECTOR_ELT (x, i);\n+\t    if (GET_MODE_CLASS (mode) == MODE_VECTOR_INT)\n+\t      {\n+\t\tvalue->un.veclo[i] = (HOST_WIDE_INT) INTVAL (elt);\n+\t\tvalue->un.vechi[i] = 0;\n+\t      }\n+\t    else if (GET_MODE_CLASS (mode) == MODE_VECTOR_FLOAT)\n+\t      {\n+\t\tvalue->un.veclo[i] = (HOST_WIDE_INT) CONST_DOUBLE_LOW (elt);\n+\t\tvalue->un.vechi[i] = (HOST_WIDE_INT) CONST_DOUBLE_HIGH (elt);\n+\t      }\n+\t    else\n+\t      abort ();\n+\t  }\n+      }\n+      break;\n+\n     case CONST_INT:\n       value->un.addr.offset = INTVAL (x);\n       break;\n@@ -4007,6 +4040,46 @@ output_constant_pool (fnname, fndecl)\n \t  assemble_integer (x, GET_MODE_SIZE (pool->mode), pool->align, 1);\n \t  break;\n \n+\tcase MODE_VECTOR_FLOAT:\n+\t  {\n+\t    int i, units;\n+\t    rtx elt;\n+\n+\t    if (GET_CODE (x) != CONST_VECTOR)\n+\t      abort ();\n+\n+\t    units = CONST_VECTOR_NUNITS (x);\n+\n+\t    for (i = 0; i < units; i++)\n+\t      {\n+\t\telt = CONST_VECTOR_ELT (x, i);\n+\t\tmemcpy ((char *) &u,\n+\t\t\t(char *) &CONST_DOUBLE_LOW (elt),\n+\t\t\tsizeof u);\n+\t\tassemble_real (u.d, GET_MODE_INNER (pool->mode), pool->align);\n+\t      }\n+\t  }\n+\t  break;\n+\n+        case MODE_VECTOR_INT:\n+\t  {\n+\t    int i, units;\n+\t    rtx elt;\n+\n+\t    if (GET_CODE (x) != CONST_VECTOR)\n+\t      abort ();\n+\n+\t    units = CONST_VECTOR_NUNITS (x);\n+\n+\t    for (i = 0; i < units; i++)\n+\t      {\n+\t\telt = CONST_VECTOR_ELT (x, i);\n+\t\tassemble_integer (elt, GET_MODE_UNIT_SIZE (pool->mode),\n+\t\t\t\t  pool->align, 1);\n+\t      }\n+\t  }\n+\t  break;\n+\n \tdefault:\n \t  abort ();\n \t}\n@@ -4255,6 +4328,7 @@ initializer_constant_valid_p (value, endtype)\n       return TREE_STATIC (value) ? null_pointer_node : 0;\n \n     case INTEGER_CST:\n+    case VECTOR_CST:\n     case REAL_CST:\n     case STRING_CST:\n     case COMPLEX_CST:"}]}