{"sha": "78b1add95968f632ca5e107d58e449e32fdc390c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzhiMWFkZDk1OTY4ZjYzMmNhNWUxMDdkNThlNDQ5ZTMyZmRjMzkwYw==", "commit": {"author": {"name": "Matthew Wahab", "email": "matthew.wahab@arm.com", "date": "2015-05-05T10:37:00Z"}, "committer": {"name": "Matthew Wahab", "email": "mwahab@gcc.gnu.org", "date": "2015-05-05T10:37:00Z"}, "message": "[docs] Update __atomic builtins documentation.\n\n\t* doc/extend.texi (__atomic Builtins): Move implementation details\n\tto the end of the description, rewrite opening paragraphs, state\n\tdifference with __sync builtins, state C11/C++11 assumptions,\n\tweaken itemized descriptions, add explanation of memory model\n\tbehaviour, expand description of compare-exchange, simplify text.\n\nFrom-SVN: r222803", "tree": {"sha": "ad72e13f40f655414c541626796cf853713e2e98", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ad72e13f40f655414c541626796cf853713e2e98"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/78b1add95968f632ca5e107d58e449e32fdc390c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/78b1add95968f632ca5e107d58e449e32fdc390c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/78b1add95968f632ca5e107d58e449e32fdc390c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/78b1add95968f632ca5e107d58e449e32fdc390c/comments", "author": null, "committer": null, "parents": [{"sha": "98314a7e82279efd7e415cbd26effb8be43f3e97", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/98314a7e82279efd7e415cbd26effb8be43f3e97", "html_url": "https://github.com/Rust-GCC/gccrs/commit/98314a7e82279efd7e415cbd26effb8be43f3e97"}], "stats": {"total": 98, "additions": 64, "deletions": 34}, "files": [{"sha": "1ae9a1c2136078469ef31b99b0de0a9e6c5e868c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78b1add95968f632ca5e107d58e449e32fdc390c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78b1add95968f632ca5e107d58e449e32fdc390c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=78b1add95968f632ca5e107d58e449e32fdc390c", "patch": "@@ -1,3 +1,11 @@\n+2015-05-05  Matthew Wahab  <matthew.wahab@arm.com>\n+\n+\t* doc/extend.texi (__atomic Builtins): Move implementation details\n+\tto the end of the description, rewrite opening paragraphs, state\n+\tdifference with __sync builtins, state C11/C++11 assumptions,\n+\tweaken itemized descriptions, add explanation of memory model\n+\tbehaviour, expand description of compare-exchange, simplify text.\n+\n 2015-05-05  Renlin Li  <renlin.li@arm.com>\n \n \t* config/aarch64/aarch64.md (add<mode>3): Use mov when allowed."}, {"sha": "4ae301ff23548e17846ae15b494627d3eb35030d", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 56, "deletions": 34, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78b1add95968f632ca5e107d58e449e32fdc390c/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78b1add95968f632ca5e107d58e449e32fdc390c/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=78b1add95968f632ca5e107d58e449e32fdc390c", "patch": "@@ -8820,45 +8820,47 @@ are not prevented from being speculated to before the barrier.\n @node __atomic Builtins\n @section Built-in Functions for Memory Model Aware Atomic Operations\n \n-The following built-in functions approximately match the requirements for\n-C++11 memory model. Many are similar to the @samp{__sync} prefixed built-in\n-functions, but all also have a memory model parameter.  These are all\n-identified by being prefixed with @samp{__atomic}, and most are overloaded\n-such that they work with multiple types.\n-\n-GCC allows any integral scalar or pointer type that is 1, 2, 4, or 8\n-bytes in length. 16-byte integral types are also allowed if\n-@samp{__int128} (@pxref{__int128}) is supported by the architecture.\n-\n-Target architectures are encouraged to provide their own patterns for\n-each of these built-in functions.  If no target is provided, the original \n-non-memory model set of @samp{__sync} atomic built-in functions are\n-utilized, along with any required synchronization fences surrounding it in\n-order to achieve the proper behavior.  Execution in this case is subject\n-to the same restrictions as those built-in functions.\n-\n-If there is no pattern or mechanism to provide a lock free instruction\n-sequence, a call is made to an external routine with the same parameters\n-to be resolved at run time.\n+The following built-in functions approximately match the requirements\n+for C++11 concurrency and memory models.  They are all\n+identified by being prefixed with @samp{__atomic} and most are\n+overloaded so that they work with multiple types.\n+\n+These functions are intended to replace the legacy @samp{__sync}\n+builtins.  The main difference is that the memory model to be used is a\n+parameter to the functions.  New code should always use the\n+@samp{__atomic} builtins rather than the @samp{__sync} builtins.\n+\n+Note that the @samp{__atomic} builtins assume that programs will\n+conform to the C++11 model for concurrency.  In particular, they assume\n+that programs are free of data races.  See the C++11 standard for\n+detailed definitions.\n+\n+The @samp{__atomic} builtins can be used with any integral scalar or\n+pointer type that is 1, 2, 4, or 8 bytes in length.  16-byte integral\n+types are also allowed if @samp{__int128} (@pxref{__int128}) is\n+supported by the architecture.\n \n The four non-arithmetic functions (load, store, exchange, and \n compare_exchange) all have a generic version as well.  This generic\n version works on any data type.  If the data type size maps to one\n of the integral sizes that may have lock free support, the generic\n-version utilizes the lock free built-in function.  Otherwise an\n+version uses the lock free built-in function.  Otherwise an\n external call is left to be resolved at run time.  This external call is\n the same format with the addition of a @samp{size_t} parameter inserted\n as the first parameter indicating the size of the object being pointed to.\n All objects must be the same size.\n \n There are 6 different memory models that can be specified.  These map\n-to the same names in the C++11 standard.  Refer there or to the\n-@uref{http://gcc.gnu.org/wiki/Atomic/GCCMM/AtomicSync,GCC wiki on\n-atomic synchronization} for more detailed definitions.  These memory\n-models integrate both barriers to code motion as well as synchronization\n-requirements with other threads. These are listed in approximately\n-ascending order of strength. It is also possible to use target specific\n-flags for memory model flags, like Hardware Lock Elision.\n+to the C++11 memory models with the same names, see the C++11 standard\n+or the @uref{http://gcc.gnu.org/wiki/Atomic/GCCMM/AtomicSync,GCC wiki\n+on atomic synchronization} for detailed definitions.  Individual\n+targets may also support additional memory models for use on specific\n+architectures.  Refer to the target documentation for details of\n+these.\n+\n+The memory models integrate both barriers to code motion as well as\n+synchronization requirements with other threads.  They are listed here\n+in approximately ascending order of strength.\n \n @table  @code\n @item __ATOMIC_RELAXED\n@@ -8873,13 +8875,32 @@ semantic stores from another thread.\n Barrier to sinking of code and synchronizes with acquire (or stronger)\n semantic loads from another thread.\n @item __ATOMIC_ACQ_REL\n-Full barrier in both directions and synchronizes with acquire loads and\n+Barrier in both directions and synchronizes with acquire loads and\n release stores in another thread.\n @item __ATOMIC_SEQ_CST\n-Full barrier in both directions and synchronizes with acquire loads and\n+Barrier in both directions and synchronizes with acquire loads and\n release stores in all threads.\n @end table\n \n+Note that the scope of a C++11 memory model depends on whether or not\n+the function being called is a @emph{fence} (such as\n+@samp{__atomic_thread_fence}).  In a fence, all memory accesses are\n+subject to the restrictions of the memory model.  When the function is\n+an operation on a location, the restrictions apply only to those\n+memory accesses that could affect or that could depend on the\n+location.\n+\n+Target architectures are encouraged to provide their own patterns for\n+each of these built-in functions.  If no target is provided, the original\n+non-memory model set of @samp{__sync} atomic built-in functions are\n+used, along with any required synchronization fences surrounding it in\n+order to achieve the proper behavior.  Execution in this case is subject\n+to the same restrictions as those built-in functions.\n+\n+If there is no pattern or mechanism to provide a lock free instruction\n+sequence, a call is made to an external routine with the same parameters\n+to be resolved at run time.\n+\n When implementing patterns for these built-in functions, the memory model\n parameter can be ignored as long as the pattern implements the most\n restrictive @code{__ATOMIC_SEQ_CST} model.  Any of the other memory models\n@@ -8950,19 +8971,20 @@ of @code{*@var{ptr}} is copied into @code{*@var{ret}}.\n @deftypefn {Built-in Function} bool __atomic_compare_exchange_n (@var{type} *ptr, @var{type} *expected, @var{type} desired, bool weak, int success_memmodel, int failure_memmodel)\n This built-in function implements an atomic compare and exchange operation.\n This compares the contents of @code{*@var{ptr}} with the contents of\n-@code{*@var{expected}} and if equal, writes @var{desired} into\n-@code{*@var{ptr}}.  If they are not equal, the current contents of\n+@code{*@var{expected}}. If equal, the operation is a @emph{read-modify-write}\n+which writes @var{desired} into @code{*@var{ptr}}.  If they are not\n+equal, the operation is a @emph{read} and the current contents of\n @code{*@var{ptr}} is written into @code{*@var{expected}}.  @var{weak} is true\n for weak compare_exchange, and false for the strong variation.  Many targets \n only offer the strong variation and ignore the parameter.  When in doubt, use\n the strong variation.\n \n True is returned if @var{desired} is written into\n-@code{*@var{ptr}} and the execution is considered to conform to the\n+@code{*@var{ptr}} and the operation is considered to conform to the\n memory model specified by @var{success_memmodel}.  There are no\n restrictions on what memory model can be used here.\n \n-False is returned otherwise, and the execution is considered to conform\n+False is returned otherwise, and the operation is considered to conform\n to @var{failure_memmodel}. This memory model cannot be\n @code{__ATOMIC_RELEASE} nor @code{__ATOMIC_ACQ_REL}.  It also cannot be a\n stronger model than that specified by @var{success_memmodel}."}]}