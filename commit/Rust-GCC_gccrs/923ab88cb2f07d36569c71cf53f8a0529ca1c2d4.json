{"sha": "923ab88cb2f07d36569c71cf53f8a0529ca1c2d4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTIzYWI4OGNiMmYwN2QzNjU2OWM3MWNmNTNmOGEwNTI5Y2ExYzJkNA==", "commit": {"author": {"name": "Tobias Schl\u00fcter", "email": "tobias.schlueter@physik.uni-muenchen.de", "date": "2004-08-25T15:50:36Z"}, "committer": {"name": "Tobias Schl\u00fcter", "email": "tobi@gcc.gnu.org", "date": "2004-08-25T15:50:36Z"}, "message": "trans.h (build2_v, build3_v): New macros.\n\n* trans.h (build2_v, build3_v): New macros.\n(build_v): Remove.\n* f95-lang.c (gfc_truthvalue_conversion): Use build2 instead of\nbuild.\n* trans-array.c (gfc_conv_descriptor_data,\ngfc_conv_descriptor_offset, gfc_conv_descriptor_dimension,\ngfc_conv_descriptor_stride, gfc_conv_descriptor_lbound,\ngfc_conv_descriptor_ubound, gfc_trans_allocate_array_storage,\ngfc_trans_allocate_temp_array,\ngfc_trans_array_constructor_subarray,\ngfc_trans_array_constructor_value, gfc_conv_array_index_ref,\ngfc_trans_array_bound_check, gfc_conv_array_index_offset,\ngfc_conv_scalarized_array_ref, gfc_conv_array_ref,\ngfc_conv_array_ref, gfc_trans_preloop_setup,\ngfc_trans_scalarized_loop_end, gfc_conv_ss_startstride,\ngfc_conv_loop_setup, gfc_array_init_size,\ngfc_conv_array_initializer, gfc_trans_array_bounds,\ngfc_trans_auto_array_allocation, gfc_trans_dummy_array_bias,\ngfc_conv_expr_descriptor, gfc_conv_array_parameter,\ngfc_trans_deferred_array): Use buildN and buildN_v macros instead\nof build and build_v as appropriate.\n* trans-common.c (create_common): Same.\n* trans-decl.c (gfc_trans_auto_character_variable,\ngfc_trans_entry_master_switch, gfc_generate_function_code): Same.\n* trans-expr.c (gfc_conv_expr_present, gfc_conv_substring,\ngfc_conv_component_ref, gfc_conv_unary_op, gfc_conv_powi,\ngfc_conv_cst_int_power, gfc_conv_string_tmp, gfc_conv_concat_op,\ngfc_conv_expr_op, gfc_conv_function_call,\ngfc_trans_structure_assign): Same.\n* trans-intrinsic.c (build_fixbound_expr, build_round_expr,\ngfc_conv_intrinsic_aint, gfc_conv_intrinsic_bound,\ngfc_conv_intrinsic_cmplx, gfc_conv_intrinsic_mod,\ngfc_conv_intrinsic_dim, gfc_conv_intrinsic_sign,\ngfc_conv_intrinsic_dprod, gfc_conv_intrinsic_minmax,\ngfc_conv_intrinsic_anyall, gfc_conv_intrinsic_count,\ngfc_conv_intrinsic_arith, gfc_conv_intrinsic_minmaxloc,\ngfc_conv_intrinsic_minmaxval, gfc_conv_intrinsic_btest,\ngfc_conv_intrinsic_bitop, gfc_conv_intrinsic_singlebitop,\ngfc_conv_intrinsic_ibits, gfc_conv_intrinsic_ishft,\ngfc_conv_intrinsic_merge, gfc_conv_intrinsic_strcmp,\ngfc_conv_allocated, gfc_conv_associated, prepare_arg_info,\ngfc_conv_intrinsic_spacing, gfc_conv_intrinsic_rrspacing,\ngfc_conv_intrinsic_trim, gfc_conv_intrinsic_repeat,\ngfc_conv_intrinsic_iargc): Same.\n* trans-io.c (set_parameter_value, set_parameter_ref, set_string,\nset_flag, add_case, io_result, transfer_namelist_element,\ntransfer_expr): Same.\n* trans-stmt.c (gfc_trans_goto, gfc_trans_return, gfc_trans_if_1,\ngfc_trans_arithmetic_if, gfc_trans_do, gfc_trans_do_while,\ngfc_trans_integer_select, gfc_trans_logical_select,\ngfc_trans_character_select, gfc_trans_forall_loop,\ngfc_trans_nested_forall_loop, gfc_do_allocate,\ngenerate_loop_for_temp_to_lhs, generate_loop_for_rhs_to_temp,\ncompute_inner_temp_size, compute_overall_iter_number,\nallocate_temp_for_forall_nest, gfc_trans_pointer_assign_need_temp,\ngfc_trans_forall_1, gfc_evaluate_where_mask,\ngfc_trans_where_assign, gfc_trans_allocate): Same.\n* trans-types.c (gfc_get_dtype, gfc_get_array_type_bounds): Same.\n* trans.c (gfc_add_modify_expr, gfc_finish_block,\ngfc_build_array_ref, gfc_build_function_call,\ngfc_trans_runtime_check): Same.\n\nFrom-SVN: r86554", "tree": {"sha": "9edb54600069aa62a022452e36d5e099d7183bf8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9edb54600069aa62a022452e36d5e099d7183bf8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/923ab88cb2f07d36569c71cf53f8a0529ca1c2d4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/923ab88cb2f07d36569c71cf53f8a0529ca1c2d4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/923ab88cb2f07d36569c71cf53f8a0529ca1c2d4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/923ab88cb2f07d36569c71cf53f8a0529ca1c2d4/comments", "author": {"login": "TobiSchluter", "id": 11887541, "node_id": "MDQ6VXNlcjExODg3NTQx", "avatar_url": "https://avatars.githubusercontent.com/u/11887541?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TobiSchluter", "html_url": "https://github.com/TobiSchluter", "followers_url": "https://api.github.com/users/TobiSchluter/followers", "following_url": "https://api.github.com/users/TobiSchluter/following{/other_user}", "gists_url": "https://api.github.com/users/TobiSchluter/gists{/gist_id}", "starred_url": "https://api.github.com/users/TobiSchluter/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TobiSchluter/subscriptions", "organizations_url": "https://api.github.com/users/TobiSchluter/orgs", "repos_url": "https://api.github.com/users/TobiSchluter/repos", "events_url": "https://api.github.com/users/TobiSchluter/events{/privacy}", "received_events_url": "https://api.github.com/users/TobiSchluter/received_events", "type": "User", "site_admin": false}, "committer": {"login": "TobiSchluter", "id": 11887541, "node_id": "MDQ6VXNlcjExODg3NTQx", "avatar_url": "https://avatars.githubusercontent.com/u/11887541?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TobiSchluter", "html_url": "https://github.com/TobiSchluter", "followers_url": "https://api.github.com/users/TobiSchluter/followers", "following_url": "https://api.github.com/users/TobiSchluter/following{/other_user}", "gists_url": "https://api.github.com/users/TobiSchluter/gists{/gist_id}", "starred_url": "https://api.github.com/users/TobiSchluter/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TobiSchluter/subscriptions", "organizations_url": "https://api.github.com/users/TobiSchluter/orgs", "repos_url": "https://api.github.com/users/TobiSchluter/repos", "events_url": "https://api.github.com/users/TobiSchluter/events{/privacy}", "received_events_url": "https://api.github.com/users/TobiSchluter/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "905af9e968a904475e846afc73cc3cf07c5b359a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/905af9e968a904475e846afc73cc3cf07c5b359a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/905af9e968a904475e846afc73cc3cf07c5b359a"}], "stats": {"total": 985, "additions": 525, "deletions": 460}, "files": [{"sha": "f93b3a434dc41959bd8182bb6e09a8109120452c", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/923ab88cb2f07d36569c71cf53f8a0529ca1c2d4/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/923ab88cb2f07d36569c71cf53f8a0529ca1c2d4/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=923ab88cb2f07d36569c71cf53f8a0529ca1c2d4", "patch": "@@ -1,3 +1,67 @@\n+2004-08-25  Tobias Schlueter  <tobias.schlueter@physik.uni-muenchen.de>\n+\n+\t* trans.h (build2_v, build3_v): New macros.\n+\t(build_v): Remove.\n+\t* f95-lang.c (gfc_truthvalue_conversion): Use build2 instead of\n+\tbuild.\n+\t* trans-array.c (gfc_conv_descriptor_data,\n+\tgfc_conv_descriptor_offset, gfc_conv_descriptor_dimension,\n+\tgfc_conv_descriptor_stride, gfc_conv_descriptor_lbound, \n+\tgfc_conv_descriptor_ubound, gfc_trans_allocate_array_storage,\n+\tgfc_trans_allocate_temp_array,\n+\tgfc_trans_array_constructor_subarray,\n+\tgfc_trans_array_constructor_value, gfc_conv_array_index_ref,\n+\tgfc_trans_array_bound_check, gfc_conv_array_index_offset,\n+\tgfc_conv_scalarized_array_ref, gfc_conv_array_ref,\n+\tgfc_conv_array_ref, gfc_trans_preloop_setup,\n+\tgfc_trans_scalarized_loop_end, gfc_conv_ss_startstride,\n+\tgfc_conv_loop_setup, gfc_array_init_size,\n+\tgfc_conv_array_initializer, gfc_trans_array_bounds,\n+\tgfc_trans_auto_array_allocation, gfc_trans_dummy_array_bias,\n+\tgfc_conv_expr_descriptor, gfc_conv_array_parameter,\n+\tgfc_trans_deferred_array): Use buildN and buildN_v macros instead\n+\tof build and build_v as appropriate.\n+\t* trans-common.c (create_common): Same.\n+\t* trans-decl.c (gfc_trans_auto_character_variable,\n+\tgfc_trans_entry_master_switch, gfc_generate_function_code): Same.\n+\t* trans-expr.c (gfc_conv_expr_present, gfc_conv_substring,\n+\tgfc_conv_component_ref, gfc_conv_unary_op, gfc_conv_powi,\n+\tgfc_conv_cst_int_power, gfc_conv_string_tmp, gfc_conv_concat_op,\n+\tgfc_conv_expr_op, gfc_conv_function_call,\n+\tgfc_trans_structure_assign): Same.\n+\t* trans-intrinsic.c (build_fixbound_expr, build_round_expr,\n+\tgfc_conv_intrinsic_aint, gfc_conv_intrinsic_bound,\n+\tgfc_conv_intrinsic_cmplx, gfc_conv_intrinsic_mod,\n+\tgfc_conv_intrinsic_dim, gfc_conv_intrinsic_sign,\n+\tgfc_conv_intrinsic_dprod, gfc_conv_intrinsic_minmax,\n+\tgfc_conv_intrinsic_anyall, gfc_conv_intrinsic_count,\n+\tgfc_conv_intrinsic_arith, gfc_conv_intrinsic_minmaxloc,\n+\tgfc_conv_intrinsic_minmaxval, gfc_conv_intrinsic_btest,\n+\tgfc_conv_intrinsic_bitop, gfc_conv_intrinsic_singlebitop,\n+\tgfc_conv_intrinsic_ibits, gfc_conv_intrinsic_ishft,\n+\tgfc_conv_intrinsic_merge, gfc_conv_intrinsic_strcmp,\n+\tgfc_conv_allocated, gfc_conv_associated, prepare_arg_info,\n+\tgfc_conv_intrinsic_spacing, gfc_conv_intrinsic_rrspacing,\n+\tgfc_conv_intrinsic_trim, gfc_conv_intrinsic_repeat,\n+\tgfc_conv_intrinsic_iargc): Same.\n+\t* trans-io.c (set_parameter_value, set_parameter_ref, set_string,\n+\tset_flag, add_case, io_result, transfer_namelist_element,\n+\ttransfer_expr): Same.\n+\t* trans-stmt.c (gfc_trans_goto, gfc_trans_return, gfc_trans_if_1,\n+\tgfc_trans_arithmetic_if, gfc_trans_do, gfc_trans_do_while,\n+\tgfc_trans_integer_select, gfc_trans_logical_select,\n+\tgfc_trans_character_select, gfc_trans_forall_loop,\n+\tgfc_trans_nested_forall_loop, gfc_do_allocate,\n+\tgenerate_loop_for_temp_to_lhs, generate_loop_for_rhs_to_temp,\n+\tcompute_inner_temp_size, compute_overall_iter_number,\n+\tallocate_temp_for_forall_nest, gfc_trans_pointer_assign_need_temp,\n+\tgfc_trans_forall_1, gfc_evaluate_where_mask,\n+\tgfc_trans_where_assign, gfc_trans_allocate): Same.\n+\t* trans-types.c (gfc_get_dtype, gfc_get_array_type_bounds): Same.\n+\t* trans.c (gfc_add_modify_expr, gfc_finish_block,\n+\tgfc_build_array_ref, gfc_build_function_call,\n+\tgfc_trans_runtime_check): Same.\n+\n 2004-08-25  Tobias Schlueter  <tobias.schlueter@physik.uni-muenchen.de>\n \n \t* trans-const.c (gfc_conv_mpz_to_tree): Change call to "}, {"sha": "77950e945f3ee4726cd560281480a797c3cdabfc", "filename": "gcc/fortran/f95-lang.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/923ab88cb2f07d36569c71cf53f8a0529ca1c2d4/gcc%2Ffortran%2Ff95-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/923ab88cb2f07d36569c71cf53f8a0529ca1c2d4/gcc%2Ffortran%2Ff95-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ff95-lang.c?ref=923ab88cb2f07d36569c71cf53f8a0529ca1c2d4", "patch": "@@ -237,7 +237,7 @@ gfc_truthvalue_conversion (tree expr)\n       if (TREE_CODE (expr) == INTEGER_CST)\n \treturn integer_zerop (expr) ? boolean_false_node : boolean_true_node;\n       else\n-        return build (NE_EXPR, boolean_type_node, expr, integer_zero_node);\n+        return build2 (NE_EXPR, boolean_type_node, expr, integer_zero_node);\n \n     default:\n       internal_error (\"Unexpected type in truthvalue_conversion\");"}, {"sha": "b8480fdfa32f0074e1692cad315c48b60bd2dc62", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 140, "deletions": 144, "changes": 284, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/923ab88cb2f07d36569c71cf53f8a0529ca1c2d4/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/923ab88cb2f07d36569c71cf53f8a0529ca1c2d4/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=923ab88cb2f07d36569c71cf53f8a0529ca1c2d4", "patch": "@@ -189,7 +189,7 @@ gfc_conv_descriptor_data (tree desc)\n \t  && TREE_CODE (TREE_TYPE (field)) == POINTER_TYPE\n \t  && TREE_CODE (TREE_TYPE (TREE_TYPE (field))) == ARRAY_TYPE);\n \n-  return build (COMPONENT_REF, TREE_TYPE (field), desc, field, NULL_TREE);\n+  return build3 (COMPONENT_REF, TREE_TYPE (field), desc, field, NULL_TREE);\n }\n \n tree\n@@ -204,7 +204,7 @@ gfc_conv_descriptor_offset (tree desc)\n   field = gfc_advance_chain (TYPE_FIELDS (type), OFFSET_FIELD);\n   assert (field != NULL_TREE && TREE_TYPE (field) == gfc_array_index_type);\n \n-  return build (COMPONENT_REF, TREE_TYPE (field), desc, field, NULL_TREE);\n+  return build3 (COMPONENT_REF, TREE_TYPE (field), desc, field, NULL_TREE);\n }\n \n tree\n@@ -219,7 +219,7 @@ gfc_conv_descriptor_dtype (tree desc)\n   field = gfc_advance_chain (TYPE_FIELDS (type), DTYPE_FIELD);\n   assert (field != NULL_TREE && TREE_TYPE (field) == gfc_array_index_type);\n \n-  return build (COMPONENT_REF, TREE_TYPE (field), desc, field, NULL_TREE);\n+  return build3 (COMPONENT_REF, TREE_TYPE (field), desc, field, NULL_TREE);\n }\n \n static tree\n@@ -237,7 +237,7 @@ gfc_conv_descriptor_dimension (tree desc, tree dim)\n \t  && TREE_CODE (TREE_TYPE (field)) == ARRAY_TYPE\n \t  && TREE_CODE (TREE_TYPE (TREE_TYPE (field))) == RECORD_TYPE);\n \n-  tmp = build (COMPONENT_REF, TREE_TYPE (field), desc, field, NULL_TREE);\n+  tmp = build3 (COMPONENT_REF, TREE_TYPE (field), desc, field, NULL_TREE);\n   tmp = gfc_build_array_ref (tmp, dim);\n   return tmp;\n }\n@@ -253,7 +253,7 @@ gfc_conv_descriptor_stride (tree desc, tree dim)\n   field = gfc_advance_chain (field, STRIDE_SUBFIELD);\n   assert (field != NULL_TREE && TREE_TYPE (field) == gfc_array_index_type);\n \n-  tmp = build (COMPONENT_REF, TREE_TYPE (field), tmp, field, NULL_TREE);\n+  tmp = build3 (COMPONENT_REF, TREE_TYPE (field), tmp, field, NULL_TREE);\n   return tmp;\n }\n \n@@ -268,7 +268,7 @@ gfc_conv_descriptor_lbound (tree desc, tree dim)\n   field = gfc_advance_chain (field, LBOUND_SUBFIELD);\n   assert (field != NULL_TREE && TREE_TYPE (field) == gfc_array_index_type);\n \n-  tmp = build (COMPONENT_REF, TREE_TYPE (field), tmp, field, NULL_TREE);\n+  tmp = build3 (COMPONENT_REF, TREE_TYPE (field), tmp, field, NULL_TREE);\n   return tmp;\n }\n \n@@ -283,7 +283,7 @@ gfc_conv_descriptor_ubound (tree desc, tree dim)\n   field = gfc_advance_chain (field, UBOUND_SUBFIELD);\n   assert (field != NULL_TREE && TREE_TYPE (field) == gfc_array_index_type);\n \n-  tmp = build (COMPONENT_REF, TREE_TYPE (field), tmp, field, NULL_TREE);\n+  tmp = build3 (COMPONENT_REF, TREE_TYPE (field), tmp, field, NULL_TREE);\n   return tmp;\n }\n \n@@ -469,8 +469,8 @@ gfc_trans_allocate_array_storage (gfc_loopinfo * loop, gfc_ss_info * info,\n       if (onstack)\n \t{\n \t  /* Make a temporary variable to hold the data.  */\n-\t  tmp = fold (build (MINUS_EXPR, TREE_TYPE (nelem), nelem,\n-\t\t\t     integer_one_node));\n+\t  tmp = fold (build2 (MINUS_EXPR, TREE_TYPE (nelem), nelem,\n+\t\t\t      integer_one_node));\n \t  tmp = build_range_type (gfc_array_index_type, gfc_index_zero_node,\n \t\t\t\t  tmp);\n \t  tmp = build_array_type (gfc_get_element_type (TREE_TYPE (desc)),\n@@ -548,8 +548,8 @@ gfc_trans_allocate_temp_array (gfc_loopinfo * loop, gfc_ss_info * info,\n \t{\n \t  /* Callee allocated arrays may not have a known bound yet.  */\n           if (loop->to[n])\n-              loop->to[n] = fold (build (MINUS_EXPR, gfc_array_index_type,\n-\t\t\t\t     loop->to[n], loop->from[n]));\n+              loop->to[n] = fold (build2 (MINUS_EXPR, gfc_array_index_type,\n+\t\t\t\t\t  loop->to[n], loop->from[n]));\n \t  loop->from[n] = gfc_index_zero_node;\n \t}\n \n@@ -592,9 +592,9 @@ gfc_trans_allocate_temp_array (gfc_loopinfo * loop, gfc_ss_info * info,\n         {\n \t  /* For a callee allocated array express the loop bounds in terms\n \t     of the descriptor fields.  */\n-          tmp = build (MINUS_EXPR, gfc_array_index_type,\n-                       gfc_conv_descriptor_ubound (desc, gfc_rank_cst[n]),\n-                       gfc_conv_descriptor_lbound (desc, gfc_rank_cst[n]));\n+          tmp = build2 (MINUS_EXPR, gfc_array_index_type,\n+\t\t\tgfc_conv_descriptor_ubound (desc, gfc_rank_cst[n]),\n+\t\t\tgfc_conv_descriptor_lbound (desc, gfc_rank_cst[n]));\n           loop->to[n] = tmp;\n           size = NULL_TREE;\n           continue;\n@@ -610,10 +610,10 @@ gfc_trans_allocate_temp_array (gfc_loopinfo * loop, gfc_ss_info * info,\n       tmp = gfc_conv_descriptor_ubound (desc, gfc_rank_cst[n]);\n       gfc_add_modify_expr (&loop->pre, tmp, loop->to[n]);\n \n-      tmp = fold (build (PLUS_EXPR, gfc_array_index_type,\n-\t\t\t loop->to[n], gfc_index_one_node));\n+      tmp = fold (build2 (PLUS_EXPR, gfc_array_index_type,\n+\t\t\t  loop->to[n], gfc_index_one_node));\n \n-      size = fold (build (MULT_EXPR, gfc_array_index_type, size, tmp));\n+      size = fold (build2 (MULT_EXPR, gfc_array_index_type, size, tmp));\n       size = gfc_evaluate_now (size, &loop->pre);\n     }\n \n@@ -624,8 +624,8 @@ gfc_trans_allocate_temp_array (gfc_loopinfo * loop, gfc_ss_info * info,\n   /* Get the size of the array.  */\n   nelem = size;\n   if (size)\n-    size = fold (build (MULT_EXPR, gfc_array_index_type, size,\n-\t\t      TYPE_SIZE_UNIT (gfc_get_element_type (type))));\n+    size = fold (build2 (MULT_EXPR, gfc_array_index_type, size,\n+\t\t\t TYPE_SIZE_UNIT (gfc_get_element_type (type))));\n \n   gfc_trans_allocate_array_storage (loop, info, size, nelem);\n \n@@ -697,7 +697,7 @@ gfc_trans_array_constructor_subarray (stmtblock_t * pblock,\n   gfc_add_modify_expr (&body, tmp, se.expr);\n \n   /* Increment the offset.  */\n-  tmp = build (PLUS_EXPR, gfc_array_index_type, *poffset, gfc_index_one_node);\n+  tmp = build2 (PLUS_EXPR, gfc_array_index_type, *poffset, gfc_index_one_node);\n   gfc_add_modify_expr (&body, *poffset, tmp);\n \n   /* Finish the loop.  */\n@@ -772,8 +772,8 @@ gfc_trans_array_constructor_value (stmtblock_t * pblock, tree type,\n \t\t\t\t   fold_convert (TREE_TYPE (ref), se.expr));\n \t      gfc_add_block_to_block (&body, &se.post);\n \n-\t      *poffset = fold (build (PLUS_EXPR, gfc_array_index_type,\n-\t\t\t\t      *poffset, gfc_index_one_node));\n+\t      *poffset = fold (build2 (PLUS_EXPR, gfc_array_index_type,\n+\t\t\t\t       *poffset, gfc_index_one_node));\n \t    }\n \t  else\n \t    {\n@@ -829,8 +829,8 @@ gfc_trans_array_constructor_value (stmtblock_t * pblock, tree type,\n \t\t\t\t\t     tmp);\n \t      gfc_add_expr_to_block (&body, tmp);\n \n-\t      *poffset = fold (build (PLUS_EXPR, gfc_array_index_type,\n-\t\t\t\t      *poffset, bound));\n+\t      *poffset = fold (build2 (PLUS_EXPR, gfc_array_index_type,\n+\t\t\t\t       *poffset, bound));\n \t    }\n \t  if (!INTEGER_CST_P (*poffset))\n             {\n@@ -875,22 +875,22 @@ gfc_trans_array_constructor_value (stmtblock_t * pblock, tree type,\n \t  gfc_start_block (&body);\n \n \t  /* Generate the exit condition.  */\n-\t  end = build (GT_EXPR, boolean_type_node, loopvar, end);\n+\t  end = build2 (GT_EXPR, boolean_type_node, loopvar, end);\n \t  tmp = build1_v (GOTO_EXPR, exit_label);\n \t  TREE_USED (exit_label) = 1;\n-\t  tmp = build_v (COND_EXPR, end, tmp, build_empty_stmt ());\n+\t  tmp = build3_v (COND_EXPR, end, tmp, build_empty_stmt ());\n \t  gfc_add_expr_to_block (&body, tmp);\n \n \t  /* The main loop body.  */\n \t  gfc_add_expr_to_block (&body, loopbody);\n \n \t  /* Increment the loop variable.  */\n-\t  tmp = build (PLUS_EXPR, TREE_TYPE (loopvar), loopvar, step);\n+\t  tmp = build2 (PLUS_EXPR, TREE_TYPE (loopvar), loopvar, step);\n \t  gfc_add_modify_expr (&body, loopvar, tmp);\n \n \t  /* Finish the loop.  */\n \t  tmp = gfc_finish_block (&body);\n-\t  tmp = build_v (LOOP_EXPR, tmp);\n+\t  tmp = build1_v (LOOP_EXPR, tmp);\n \t  gfc_add_expr_to_block (pblock, tmp);\n \n \t  /* Add the exit label.  */\n@@ -1300,9 +1300,9 @@ gfc_conv_array_index_ref (gfc_se * se, tree pointer, tree * indices,\n     {\n       /* index = index + stride[n]*indices[n] */\n       tmp = gfc_conv_array_stride (se->expr, n);\n-      tmp = fold (build (MULT_EXPR, gfc_array_index_type, indices[n], tmp));\n+      tmp = fold (build2 (MULT_EXPR, gfc_array_index_type, indices[n], tmp));\n \n-      index = fold (build (PLUS_EXPR, gfc_array_index_type, index, tmp));\n+      index = fold (build2 (PLUS_EXPR, gfc_array_index_type, index, tmp));\n     }\n \n   /* Result = data[index].  */\n@@ -1330,11 +1330,11 @@ gfc_trans_array_bound_check (gfc_se * se, tree descriptor, tree index, int n)\n   index = gfc_evaluate_now (index, &se->pre);\n   /* Check lower bound.  */\n   tmp = gfc_conv_array_lbound (descriptor, n);\n-  fault = fold (build (LT_EXPR, boolean_type_node, index, tmp));\n+  fault = fold (build2 (LT_EXPR, boolean_type_node, index, tmp));\n   /* Check upper bound.  */\n   tmp = gfc_conv_array_ubound (descriptor, n);\n-  cond = fold (build (GT_EXPR, boolean_type_node, index, tmp));\n-  fault = fold (build (TRUTH_OR_EXPR, boolean_type_node, fault, cond));\n+  cond = fold (build2 (GT_EXPR, boolean_type_node, index, tmp));\n+  fault = fold (build2 (TRUTH_OR_EXPR, boolean_type_node, fault, cond));\n \n   gfc_trans_runtime_check (fault, gfc_strconst_fault, &se->pre);\n \n@@ -1429,10 +1429,10 @@ gfc_conv_array_index_offset (gfc_se * se, gfc_ss_info * info, int dim, int i,\n \n           /* Multiply the loop variable by the stride and dela.  */\n \t  index = se->loop->loopvar[i];\n-\t  index = fold (build (MULT_EXPR, gfc_array_index_type, index,\n-\t\t\t       info->stride[i]));\n-\t  index = fold (build (PLUS_EXPR, gfc_array_index_type, index,\n-\t\t\t       info->delta[i]));\n+\t  index = fold (build2 (MULT_EXPR, gfc_array_index_type, index,\n+\t\t\t\tinfo->stride[i]));\n+\t  index = fold (build2 (PLUS_EXPR, gfc_array_index_type, index,\n+\t\t\t\tinfo->delta[i]));\n \n \t  if (ar->dimen_type[dim] == DIMEN_VECTOR)\n \t    {\n@@ -1453,12 +1453,12 @@ gfc_conv_array_index_offset (gfc_se * se, gfc_ss_info * info, int dim, int i,\n       assert (se->loop);\n       index = se->loop->loopvar[se->loop->order[i]];\n       if (!integer_zerop (info->delta[i]))\n-\tindex = fold (build (PLUS_EXPR, gfc_array_index_type, index,\n-\t\t\t     info->delta[i]));\n+\tindex = fold (build2 (PLUS_EXPR, gfc_array_index_type,\n+\t\t\t      index, info->delta[i]));\n     }\n \n   /* Multiply by the stride.  */\n-  index = fold (build (MULT_EXPR, gfc_array_index_type, index, stride));\n+  index = fold (build2 (MULT_EXPR, gfc_array_index_type, index, stride));\n \n   return index;\n }\n@@ -1484,7 +1484,7 @@ gfc_conv_scalarized_array_ref (gfc_se * se, gfc_array_ref * ar)\n \t\t\t\t       info->stride0);\n   /* Add the offset for this dimension to the stored offset for all other\n      dimensions.  */\n-  index = fold (build (PLUS_EXPR, gfc_array_index_type, index, info->offset));\n+  index = fold (build2 (PLUS_EXPR, gfc_array_index_type, index, info->offset));\n \n   tmp = gfc_build_indirect_ref (info->data);\n   se->expr = gfc_build_array_ref (tmp, index);\n@@ -1548,31 +1548,33 @@ gfc_conv_array_ref (gfc_se * se, gfc_array_ref * ar)\n \t  indexse.expr = gfc_evaluate_now (indexse.expr, &se->pre);\n \n \t  tmp = gfc_conv_array_lbound (se->expr, n);\n-\t  cond = fold (build (LT_EXPR, boolean_type_node, indexse.expr, tmp));\n+\t  cond = fold (build2 (LT_EXPR, boolean_type_node, \n+\t\t\t       indexse.expr, tmp));\n \t  fault =\n-\t    fold (build (TRUTH_OR_EXPR, boolean_type_node, fault, cond));\n+\t    fold (build2 (TRUTH_OR_EXPR, boolean_type_node, fault, cond));\n \n \t  tmp = gfc_conv_array_ubound (se->expr, n);\n-\t  cond = fold (build (GT_EXPR, boolean_type_node, indexse.expr, tmp));\n+\t  cond = fold (build2 (GT_EXPR, boolean_type_node, \n+\t\t\t       indexse.expr, tmp));\n \t  fault =\n-\t    fold (build (TRUTH_OR_EXPR, boolean_type_node, fault, cond));\n+\t    fold (build2 (TRUTH_OR_EXPR, boolean_type_node, fault, cond));\n \t}\n \n       /* Multiply the index by the stride.  */\n       stride = gfc_conv_array_stride (se->expr, n);\n-      tmp = fold (build (MULT_EXPR, gfc_array_index_type, indexse.expr,\n-\t\t\t stride));\n+      tmp = fold (build2 (MULT_EXPR, gfc_array_index_type, indexse.expr,\n+\t\t\t  stride));\n \n       /* And add it to the total.  */\n-      index = fold (build (PLUS_EXPR, gfc_array_index_type, index, tmp));\n+      index = fold (build2 (PLUS_EXPR, gfc_array_index_type, index, tmp));\n     }\n \n   if (flag_bounds_check)\n     gfc_trans_runtime_check (fault, gfc_strconst_fault, &se->pre);\n \n   tmp = gfc_conv_array_offset (se->expr);\n   if (!integer_zerop (tmp))\n-    index = fold (build (PLUS_EXPR, gfc_array_index_type, index, tmp));\n+    index = fold (build2 (PLUS_EXPR, gfc_array_index_type, index, tmp));\n       \n   /* Access the calculated element.  */\n   tmp = gfc_conv_array_data (se->expr);\n@@ -1633,8 +1635,8 @@ gfc_trans_preloop_setup (gfc_loopinfo * loop, int dim, int flag,\n \t\t\t\t\t\t       stride);\n \t\t  gfc_add_block_to_block (pblock, &se.pre);\n \n-\t\t  info->offset = fold (build (PLUS_EXPR, gfc_array_index_type,\n-\t\t\t\t\t      info->offset, index));\n+\t\t  info->offset = fold (build2 (PLUS_EXPR, gfc_array_index_type,\n+\t\t\t\t\t       info->offset, index));\n \t\t  info->offset = gfc_evaluate_now (info->offset, pblock);\n \t\t}\n \n@@ -1672,8 +1674,8 @@ gfc_trans_preloop_setup (gfc_loopinfo * loop, int dim, int flag,\n \t  index = gfc_conv_array_index_offset (&se, info, info->dim[i], i,\n \t\t\t\t\t       ar, stride);\n \t  gfc_add_block_to_block (pblock, &se.pre);\n-\t  info->offset = fold (build (PLUS_EXPR, gfc_array_index_type,\n-\t\t\t\t      info->offset, index));\n+\t  info->offset = fold (build2 (PLUS_EXPR, gfc_array_index_type,\n+\t\t\t\t       info->offset, index));\n \t  info->offset = gfc_evaluate_now (info->offset, pblock);\n \t}\n \n@@ -1739,23 +1741,23 @@ gfc_trans_scalarized_loop_end (gfc_loopinfo * loop, int n,\n   gfc_init_block (&block);\n \n   /* The exit condition.  */\n-  cond = build (GT_EXPR, boolean_type_node, loop->loopvar[n], loop->to[n]);\n+  cond = build2 (GT_EXPR, boolean_type_node, loop->loopvar[n], loop->to[n]);\n   tmp = build1_v (GOTO_EXPR, exit_label);\n   TREE_USED (exit_label) = 1;\n-  tmp = build_v (COND_EXPR, cond, tmp, build_empty_stmt ());\n+  tmp = build3_v (COND_EXPR, cond, tmp, build_empty_stmt ());\n   gfc_add_expr_to_block (&block, tmp);\n \n   /* The main body.  */\n   gfc_add_expr_to_block (&block, loopbody);\n \n   /* Increment the loopvar.  */\n-  tmp = build (PLUS_EXPR, gfc_array_index_type,\n-\t       loop->loopvar[n], gfc_index_one_node);\n+  tmp = build2 (PLUS_EXPR, gfc_array_index_type,\n+\t\tloop->loopvar[n], gfc_index_one_node);\n   gfc_add_modify_expr (&block, loop->loopvar[n], tmp);\n \n   /* Build the loop.  */\n   tmp = gfc_finish_block (&block);\n-  tmp = build_v (LOOP_EXPR, tmp);\n+  tmp = build1_v (LOOP_EXPR, tmp);\n   gfc_add_expr_to_block (&loop->code[n], tmp);\n \n   /* Add the exit label.  */\n@@ -2071,30 +2073,30 @@ gfc_conv_ss_startstride (gfc_loopinfo * loop)\n \t      /* Check lower bound.  */\n \t      bound = gfc_conv_array_lbound (desc, dim);\n \t      tmp = info->start[n];\n-\t      tmp = fold (build (LT_EXPR, boolean_type_node, tmp, bound));\n-\t      fault = fold (build (TRUTH_OR_EXPR, boolean_type_node, fault,\n-\t\t\t\t   tmp));\n+\t      tmp = fold (build2 (LT_EXPR, boolean_type_node, tmp, bound));\n+\t      fault = fold (build2 (TRUTH_OR_EXPR, boolean_type_node, fault,\n+\t\t\t\t    tmp));\n \n \t      /* Check the upper bound.  */\n \t      bound = gfc_conv_array_ubound (desc, dim);\n \t      end = gfc_conv_section_upper_bound (ss, n, &block);\n-\t      tmp = fold (build (GT_EXPR, boolean_type_node, end, bound));\n-\t      fault = fold (build (TRUTH_OR_EXPR, boolean_type_node, fault,\n-\t\t\t\t   tmp));\n+\t      tmp = fold (build2 (GT_EXPR, boolean_type_node, end, bound));\n+\t      fault = fold (build2 (TRUTH_OR_EXPR, boolean_type_node, fault,\n+\t\t\t\t    tmp));\n \n \t      /* Check the section sizes match.  */\n-\t      tmp = fold (build (MINUS_EXPR, gfc_array_index_type, end,\n-\t\t\t\t info->start[n]));\n-\t      tmp = fold (build (FLOOR_DIV_EXPR, gfc_array_index_type, tmp,\n-\t\t\t\t info->stride[n]));\n+\t      tmp = fold (build2 (MINUS_EXPR, gfc_array_index_type, end,\n+\t\t\t\t  info->start[n]));\n+\t      tmp = fold (build2 (FLOOR_DIV_EXPR, gfc_array_index_type, tmp,\n+\t\t\t\t  info->stride[n]));\n \t      /* We remember the size of the first section, and check all the\n \t         others against this.  */\n \t      if (size[n])\n \t\t{\n \t\t  tmp =\n-\t\t    fold (build (NE_EXPR, boolean_type_node, tmp, size[n]));\n+\t\t    fold (build2 (NE_EXPR, boolean_type_node, tmp, size[n]));\n \t\t  fault =\n-\t\t    build (TRUTH_OR_EXPR, boolean_type_node, fault, tmp);\n+\t\t    build2 (TRUTH_OR_EXPR, boolean_type_node, fault, tmp);\n \t\t}\n \t      else\n \t\tsize[n] = gfc_evaluate_now (tmp, &block);\n@@ -2370,12 +2372,10 @@ gfc_conv_loop_setup (gfc_loopinfo * loop)\n \t  /* To = from + (size - 1) * stride.  */\n \t  tmp = gfc_conv_mpz_to_tree (i, gfc_index_integer_kind);\n \t  if (!integer_onep (info->stride[n]))\n-\t    {\n-\t      tmp = fold (build (MULT_EXPR, gfc_array_index_type,\n-\t\t\t\t tmp, info->stride[n]));\n-\t    }\n-\t  loop->to[n] = fold (build (PLUS_EXPR, gfc_array_index_type,\n-\t\t\t      loop->from[n], tmp));\n+\t    tmp = fold (build2 (MULT_EXPR, gfc_array_index_type,\n+\t\t\t\ttmp, info->stride[n]));\n+\t  loop->to[n] = fold (build2 (PLUS_EXPR, gfc_array_index_type,\n+\t\t\t\t      loop->from[n], tmp));\n \t}\n       else\n \t{\n@@ -2413,10 +2413,10 @@ gfc_conv_loop_setup (gfc_loopinfo * loop)\n \t     with start = 0, this simplifies to\n \t     last = end / step;\n \t     for (i = 0; i<=last; i++){...};  */\n-\t  tmp = fold (build (MINUS_EXPR, gfc_array_index_type, loop->to[n],\n-\t\t\t     loop->from[n]));\n-\t  tmp = fold (build (TRUNC_DIV_EXPR, gfc_array_index_type, tmp,\n-\t\t\t     info->stride[n]));\n+\t  tmp = fold (build2 (MINUS_EXPR, gfc_array_index_type,\n+\t\t\t      loop->to[n], loop->from[n]));\n+\t  tmp = fold (build2 (TRUNC_DIV_EXPR, gfc_array_index_type, \n+\t\t\t      tmp, info->stride[n]));\n \t  loop->to[n] = gfc_evaluate_now (tmp, &loop->pre);\n \t  /* Make the loop variable start at 0.  */\n \t  loop->from[n] = gfc_index_zero_node;\n@@ -2469,12 +2469,12 @@ gfc_conv_loop_setup (gfc_loopinfo * loop)\n \t    {\n \t      /* Calculate the offset relative to the loop variable.\n \t         First multiply by the stride.  */\n-\t      tmp = fold (build (MULT_EXPR, gfc_array_index_type,\n-\t\t\t\t loop->from[n], info->stride[n]));\n+\t      tmp = fold (build2 (MULT_EXPR, gfc_array_index_type,\n+\t\t\t\t  loop->from[n], info->stride[n]));\n \n \t      /* Then subtract this from our starting value.  */\n-\t      tmp = fold (build (MINUS_EXPR, gfc_array_index_type,\n-\t\t\t\t info->start[n], tmp));\n+\t      tmp = fold (build2 (MINUS_EXPR, gfc_array_index_type,\n+\t\t\t\t  info->start[n], tmp));\n \n \t      info->delta[n] = gfc_evaluate_now (tmp, &loop->pre);\n \t    }\n@@ -2557,12 +2557,12 @@ gfc_array_init_size (tree descriptor, int rank, tree * poffset,\n       gfc_add_modify_expr (pblock, tmp, se.expr);\n \n       /* Work out the offset for this component.  */\n-      tmp = fold (build (MULT_EXPR, gfc_array_index_type, se.expr, stride));\n-      offset = fold (build (MINUS_EXPR, gfc_array_index_type, offset, tmp));\n+      tmp = fold (build2 (MULT_EXPR, gfc_array_index_type, se.expr, stride));\n+      offset = fold (build2 (MINUS_EXPR, gfc_array_index_type, offset, tmp));\n \n       /* Start the calculation for the size of this dimension.  */\n-      size = build (MINUS_EXPR, gfc_array_index_type,\n-\t\t    gfc_index_one_node, se.expr);\n+      size = build2 (MINUS_EXPR, gfc_array_index_type,\n+\t\t     gfc_index_one_node, se.expr);\n \n       /* Set upper bound.  */\n       gfc_init_se (&se, NULL);\n@@ -2578,17 +2578,17 @@ gfc_array_init_size (tree descriptor, int rank, tree * poffset,\n       gfc_add_modify_expr (pblock, tmp, stride);\n \n       /* Calculate the size of this dimension.  */\n-      size = fold (build (PLUS_EXPR, gfc_array_index_type, se.expr, size));\n+      size = fold (build2 (PLUS_EXPR, gfc_array_index_type, se.expr, size));\n \n       /* Multiply the stride by the number of elements in this dimension.  */\n-      stride = fold (build (MULT_EXPR, gfc_array_index_type, stride, size));\n+      stride = fold (build2 (MULT_EXPR, gfc_array_index_type, stride, size));\n       stride = gfc_evaluate_now (stride, pblock);\n     }\n \n   /* The stride is the number of elements in the array, so multiply by the\n      size of an element to get the total size.  */\n   tmp = TYPE_SIZE_UNIT (gfc_get_element_type (type));\n-  size = fold (build (MULT_EXPR, gfc_array_index_type, stride, tmp));\n+  size = fold (build2 (MULT_EXPR, gfc_array_index_type, stride, tmp));\n \n   if (poffset != NULL)\n     {\n@@ -2776,7 +2776,7 @@ gfc_conv_array_initializer (tree type, gfc_expr * expr)\n               else\n                 tmp1 = gfc_conv_mpz_to_tree (c->n.offset, gfc_index_integer_kind);\n \n-              range = build (RANGE_EXPR, integer_type_node, tmp1, tmp2);\n+              range = build2 (RANGE_EXPR, integer_type_node, tmp1, tmp2);\n             }\n           else\n             range = NULL;\n@@ -2864,8 +2864,8 @@ gfc_trans_array_bounds (tree type, gfc_symbol * sym, tree * poffset,\n           gfc_add_modify_expr (pblock, ubound, se.expr);\n         }\n       /* The offset of this dimension.  offset = offset - lbound * stride. */\n-      tmp = fold (build (MULT_EXPR, gfc_array_index_type, lbound, size));\n-      offset = fold (build (MINUS_EXPR, gfc_array_index_type, offset, tmp));\n+      tmp = fold (build2 (MULT_EXPR, gfc_array_index_type, lbound, size));\n+      offset = fold (build2 (MINUS_EXPR, gfc_array_index_type, offset, tmp));\n \n       /* The size of this dimension, and the stride of the next.  */\n       if (dim + 1 < as->rank)\n@@ -2876,10 +2876,10 @@ gfc_trans_array_bounds (tree type, gfc_symbol * sym, tree * poffset,\n       if (ubound != NULL_TREE && !(stride && INTEGER_CST_P (stride)))\n         {\n           /* Calculate stride = size * (ubound + 1 - lbound).  */\n-          tmp = fold (build (MINUS_EXPR, gfc_array_index_type,\n-                             gfc_index_one_node, lbound));\n-          tmp = fold (build (PLUS_EXPR, gfc_array_index_type, ubound, tmp));\n-          tmp = fold (build (MULT_EXPR, gfc_array_index_type, size, tmp));\n+          tmp = fold (build2 (MINUS_EXPR, gfc_array_index_type,\n+\t\t\t      gfc_index_one_node, lbound));\n+          tmp = fold (build2 (PLUS_EXPR, gfc_array_index_type, ubound, tmp));\n+          tmp = fold (build2 (MULT_EXPR, gfc_array_index_type, size, tmp));\n           if (stride)\n             gfc_add_modify_expr (pblock, stride, tmp);\n           else\n@@ -2927,7 +2927,7 @@ gfc_trans_auto_array_allocation (tree decl, gfc_symbol * sym, tree fnbody)\n \n       /* Emit a DECL_EXPR for this variable, which will cause the\n \t gimplifier to allocate stoage, and all that good stuff.  */\n-      tmp = build (DECL_EXPR, TREE_TYPE (decl), decl);\n+      tmp = build1 (DECL_EXPR, TREE_TYPE (decl), decl);\n       gfc_add_expr_to_block (&block, tmp);\n     }\n \n@@ -2952,7 +2952,7 @@ gfc_trans_auto_array_allocation (tree decl, gfc_symbol * sym, tree fnbody)\n   /* The size is the number of elements in the array, so multiply by the\n      size of an element to get the total size.  */\n   tmp = TYPE_SIZE_UNIT (gfc_get_element_type (type));\n-  size = fold (build (MULT_EXPR, gfc_array_index_type, size, tmp));\n+  size = fold (build2 (MULT_EXPR, gfc_array_index_type, size, tmp));\n \n   /* Allocate memory to hold the data.  */\n   tmp = gfc_chainon_list (NULL_TREE, size);\n@@ -3110,7 +3110,7 @@ gfc_trans_dummy_array_bias (gfc_symbol * sym, tree tmpdesc, tree body)\n       partial = gfc_create_var (boolean_type_node, \"partial\");\n       TREE_USED (partial) = 1;\n       tmp = gfc_conv_descriptor_stride (dumdesc, gfc_rank_cst[0]);\n-      tmp = fold (build (EQ_EXPR, boolean_type_node, tmp, integer_one_node));\n+      tmp = fold (build2 (EQ_EXPR, boolean_type_node, tmp, integer_one_node));\n       gfc_add_modify_expr (&block, partial, tmp);\n     }\n   else\n@@ -3126,9 +3126,9 @@ gfc_trans_dummy_array_bias (gfc_symbol * sym, tree tmpdesc, tree body)\n       stride = gfc_conv_descriptor_stride (dumdesc, gfc_rank_cst[0]);\n       stride = gfc_evaluate_now (stride, &block);\n \n-      tmp = build (EQ_EXPR, boolean_type_node, stride, integer_zero_node);\n-      tmp = build (COND_EXPR, gfc_array_index_type, tmp,\n-                   gfc_index_one_node, stride);\n+      tmp = build2 (EQ_EXPR, boolean_type_node, stride, integer_zero_node);\n+      tmp = build3 (COND_EXPR, gfc_array_index_type, tmp,\n+\t\t    gfc_index_one_node, stride);\n       stride = GFC_TYPE_ARRAY_STRIDE (type, 0);\n       gfc_add_modify_expr (&block, stride, tmp);\n \n@@ -3157,8 +3157,8 @@ gfc_trans_dummy_array_bias (gfc_symbol * sym, tree tmpdesc, tree body)\n   if (stmt_packed != NULL_TREE && stmt_unpacked != NULL_TREE)\n     {\n       /* Don't repack unknown shape arrays when the first stride is 1.  */\n-      tmp = build (COND_EXPR, TREE_TYPE (stmt_packed), partial,\n-                   stmt_packed, stmt_unpacked);\n+      tmp = build3 (COND_EXPR, TREE_TYPE (stmt_packed), partial,\n+\t\t    stmt_packed, stmt_unpacked);\n     }\n   else\n     tmp = stmt_packed != NULL_TREE ? stmt_packed : stmt_unpacked;\n@@ -3211,25 +3211,25 @@ gfc_trans_dummy_array_bias (gfc_symbol * sym, tree tmpdesc, tree body)\n \t    {\n \t      /* Check (ubound(a) - lbound(a) == ubound(b) - lbound(b)).  */\n \n-\t      tmp = fold (build (MINUS_EXPR, gfc_array_index_type, ubound,\n-\t\t\t\t lbound));\n-              stride = build (MINUS_EXPR, gfc_array_index_type, dubound,\n-                            dlbound);\n-              tmp = fold (build (NE_EXPR, gfc_array_index_type, tmp, stride));\n+\t      tmp = fold (build2 (MINUS_EXPR, gfc_array_index_type,\n+\t\t\t\t  ubound, lbound));\n+              stride = build2 (MINUS_EXPR, gfc_array_index_type,\n+\t\t\t       dubound, dlbound);\n+              tmp = fold (build2 (NE_EXPR, gfc_array_index_type, tmp, stride));\n \t      gfc_trans_runtime_check (tmp, gfc_strconst_bounds, &block);\n \t    }\n \t}\n       else\n \t{\n \t  /* For assumed shape arrays move the upper bound by the same amount\n \t     as the lower bound.  */\n-          tmp = build (MINUS_EXPR, gfc_array_index_type, dubound, dlbound);\n-          tmp = fold (build (PLUS_EXPR, gfc_array_index_type, tmp, lbound));\n+          tmp = build2 (MINUS_EXPR, gfc_array_index_type, dubound, dlbound);\n+          tmp = fold (build2 (PLUS_EXPR, gfc_array_index_type, tmp, lbound));\n           gfc_add_modify_expr (&block, ubound, tmp);\n \t}\n       /* The offset of this dimension.  offset = offset - lbound * stride. */\n-      tmp = fold (build (MULT_EXPR, gfc_array_index_type, lbound, stride));\n-      offset = fold (build (MINUS_EXPR, gfc_array_index_type, offset, tmp));\n+      tmp = fold (build2 (MULT_EXPR, gfc_array_index_type, lbound, stride));\n+      offset = fold (build2 (MINUS_EXPR, gfc_array_index_type, offset, tmp));\n \n       /* The size of this dimension, and the stride of the next.  */\n       if (n + 1 < sym->as->rank)\n@@ -3250,21 +3250,19 @@ gfc_trans_dummy_array_bias (gfc_symbol * sym, tree tmpdesc, tree body)\n               else\n                 {\n                   /* Calculate stride = size * (ubound + 1 - lbound).  */\n-                  tmp = fold (build (MINUS_EXPR, gfc_array_index_type,\n-                                     gfc_index_one_node, lbound));\n-                  tmp = fold (build (PLUS_EXPR, gfc_array_index_type,\n-                                     ubound, tmp));\n-                  size = fold (build (MULT_EXPR, gfc_array_index_type,\n-                                      size, tmp));\n+                  tmp = fold (build2 (MINUS_EXPR, gfc_array_index_type,\n+\t\t\t\t      gfc_index_one_node, lbound));\n+                  tmp = fold (build2 (PLUS_EXPR, gfc_array_index_type,\n+\t\t\t\t      ubound, tmp));\n+                  size = fold (build2 (MULT_EXPR, gfc_array_index_type,\n+\t\t\t\t       size, tmp));\n                   stmt_packed = size;\n                 }\n \n               /* Assign the stride.  */\n               if (stmt_packed != NULL_TREE && stmt_unpacked != NULL_TREE)\n-                {\n-                  tmp = build (COND_EXPR, gfc_array_index_type, partial,\n-                               stmt_unpacked, stmt_packed);\n-                }\n+\t\ttmp = build3 (COND_EXPR, gfc_array_index_type, partial,\n+\t\t\t      stmt_unpacked, stmt_packed);\n               else\n                 tmp = (stmt_packed != NULL_TREE) ? stmt_packed : stmt_unpacked;\n               gfc_add_modify_expr (&block, stride, tmp);\n@@ -3286,7 +3284,7 @@ gfc_trans_dummy_array_bias (gfc_symbol * sym, tree tmpdesc, tree body)\n   if (optional_arg)\n     {\n       tmp = gfc_conv_expr_present (sym);\n-      stmt = build_v (COND_EXPR, tmp, stmt, build_empty_stmt ());\n+      stmt = build3_v (COND_EXPR, tmp, stmt, build_empty_stmt ());\n     }\n   gfc_add_expr_to_block (&block, stmt);\n \n@@ -3317,13 +3315,13 @@ gfc_trans_dummy_array_bias (gfc_symbol * sym, tree tmpdesc, tree body)\n       /* Only do the cleanup if the array was repacked.  */\n       tmp = gfc_build_indirect_ref (dumdesc);\n       tmp = gfc_conv_descriptor_data (tmp);\n-      tmp = build (NE_EXPR, boolean_type_node, tmp, tmpdesc);\n-      stmt = build_v (COND_EXPR, tmp, stmt, build_empty_stmt ());\n+      tmp = build2 (NE_EXPR, boolean_type_node, tmp, tmpdesc);\n+      stmt = build3_v (COND_EXPR, tmp, stmt, build_empty_stmt ());\n \n       if (optional_arg)\n         {\n           tmp = gfc_conv_expr_present (sym);\n-          stmt = build_v (COND_EXPR, tmp, stmt, build_empty_stmt ());\n+          stmt = build3_v (COND_EXPR, tmp, stmt, build_empty_stmt ());\n         }\n       gfc_add_expr_to_block (&block, stmt);\n     }\n@@ -3646,10 +3644,10 @@ gfc_conv_expr_descriptor (gfc_se * se, gfc_expr * expr, gfc_ss * ss)\n \t    }\n \n \t  tmp = gfc_conv_array_lbound (desc, n);\n-\t  tmp = fold (build (MINUS_EXPR, TREE_TYPE (tmp), start, tmp));\n+\t  tmp = fold (build2 (MINUS_EXPR, TREE_TYPE (tmp), start, tmp));\n \n-\t  tmp = fold (build (MULT_EXPR, TREE_TYPE (tmp), tmp, stride));\n-\t  offset = fold (build (PLUS_EXPR, TREE_TYPE (tmp), offset, tmp));\n+\t  tmp = fold (build2 (MULT_EXPR, TREE_TYPE (tmp), tmp, stride));\n+\t  offset = fold (build2 (PLUS_EXPR, TREE_TYPE (tmp), offset, tmp));\n \n \t  if (info->ref->u.ar.dimen_type[n] == DIMEN_ELEMENT)\n \t    {\n@@ -3666,9 +3664,9 @@ gfc_conv_expr_descriptor (gfc_se * se, gfc_expr * expr, gfc_ss * ss)\n           if (!integer_onep (from))\n \t    {\n \t      /* Make sure the new section starts at 1.  */\n-\t      tmp = fold (build (MINUS_EXPR, gfc_array_index_type,\n+\t      tmp = fold (build2 (MINUS_EXPR, gfc_array_index_type,\n \t\t\t\t gfc_index_one_node, from));\n-\t      to = fold (build (PLUS_EXPR, gfc_array_index_type, to, tmp));\n+\t      to = fold (build2 (PLUS_EXPR, gfc_array_index_type, to, tmp));\n \t      from = gfc_index_one_node;\n \t    }\n \t  tmp = gfc_conv_descriptor_lbound (parm, gfc_rank_cst[dim]);\n@@ -3680,14 +3678,12 @@ gfc_conv_expr_descriptor (gfc_se * se, gfc_expr * expr, gfc_ss * ss)\n \n \t  /* Multiply the stride by the section stride to get the\n \t     total stride.  */\n-\t  stride = fold (build (MULT_EXPR, gfc_array_index_type, stride,\n-\t\t\t\tinfo->stride[dim]));\n+\t  stride = fold (build2 (MULT_EXPR, gfc_array_index_type,\n+\t\t\t\t stride, info->stride[dim]));\n \n \t  if (se->direct_byref)\n-\t    {\n-\t      base = fold (build (MINUS_EXPR, TREE_TYPE (base),\n-\t\t\t\t  base, stride));\n-\t    }\n+\t    base = fold (build2 (MINUS_EXPR, TREE_TYPE (base),\n+\t\t\t\t base, stride));\n \n \t  /* Store the new stride.  */\n \t  tmp = gfc_conv_descriptor_stride (parm, gfc_rank_cst[dim]);\n@@ -3810,8 +3806,8 @@ gfc_conv_array_parameter (gfc_se * se, gfc_expr * expr, gfc_ss * ss, int g77)\n          loop cleanup code.  */\n       tmp = gfc_build_indirect_ref (desc);\n       tmp = gfc_conv_array_data (tmp);\n-      tmp = build (NE_EXPR, boolean_type_node, ptr, tmp);\n-      tmp = build_v (COND_EXPR, tmp, stmt, build_empty_stmt ());\n+      tmp = build2 (NE_EXPR, boolean_type_node, ptr, tmp);\n+      tmp = build3_v (COND_EXPR, tmp, stmt, build_empty_stmt ());\n \n       gfc_add_expr_to_block (&block, tmp);\n       gfc_add_block_to_block (&block, &se->post);\n@@ -3887,8 +3883,8 @@ gfc_trans_deferred_array (gfc_symbol * sym, tree body)\n       deallocate = gfc_array_deallocate (descriptor);\n \n       tmp = gfc_conv_descriptor_data (descriptor);\n-      tmp = build (NE_EXPR, boolean_type_node, tmp, integer_zero_node);\n-      tmp = build_v (COND_EXPR, tmp, deallocate, build_empty_stmt ());\n+      tmp = build2 (NE_EXPR, boolean_type_node, tmp, integer_zero_node);\n+      tmp = build3_v (COND_EXPR, tmp, deallocate, build_empty_stmt ());\n       gfc_add_expr_to_block (&block, tmp);\n \n       tmp = gfc_finish_block (&block);"}, {"sha": "69cb1a3a20b04793beda7796f5240c1a444c51d7", "filename": "gcc/fortran/trans-common.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/923ab88cb2f07d36569c71cf53f8a0529ca1c2d4/gcc%2Ffortran%2Ftrans-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/923ab88cb2f07d36569c71cf53f8a0529ca1c2d4/gcc%2Ffortran%2Ftrans-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-common.c?ref=923ab88cb2f07d36569c71cf53f8a0529ca1c2d4", "patch": "@@ -422,8 +422,8 @@ create_common (gfc_common_head *com)\n   /* Build component reference for each variable.  */\n   for (s = current_common; s; s = next_s)\n     {\n-      s->sym->backend_decl = build (COMPONENT_REF, TREE_TYPE (s->field),\n-                                    decl, s->field, NULL_TREE);\n+      s->sym->backend_decl = build3 (COMPONENT_REF, TREE_TYPE (s->field),\n+\t\t\t\t     decl, s->field, NULL_TREE);\n \n       next_s = s->next;\n       gfc_free (s);"}, {"sha": "9f6af8efc58149926f3a04036f8f4039fe6fe276", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/923ab88cb2f07d36569c71cf53f8a0529ca1c2d4/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/923ab88cb2f07d36569c71cf53f8a0529ca1c2d4/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=923ab88cb2f07d36569c71cf53f8a0529ca1c2d4", "patch": "@@ -1856,7 +1856,7 @@ gfc_trans_auto_character_variable (gfc_symbol * sym, tree fnbody)\n \n   /* Emit a DECL_EXPR for this variable, which will cause the\n      gimplifier to allocate storage, and all that good stuff.  */\n-  tmp = build (DECL_EXPR, TREE_TYPE (decl), decl);\n+  tmp = build1 (DECL_EXPR, TREE_TYPE (decl), decl);\n   gfc_add_expr_to_block (&body, tmp);\n \n   gfc_add_expr_to_block (&body, fnbody);\n@@ -2114,7 +2114,7 @@ gfc_trans_entry_master_switch (gfc_entry_list * el)\n       label = build_decl (LABEL_DECL, NULL_TREE, NULL_TREE);\n       DECL_CONTEXT (label) = current_function_decl;\n       val = build_int_cst (gfc_array_index_type, el->id);\n-      tmp = build_v (CASE_LABEL_EXPR, val, NULL_TREE, label);\n+      tmp = build3_v (CASE_LABEL_EXPR, val, NULL_TREE, label);\n       gfc_add_expr_to_block (&block, tmp);\n       \n       /* And jump to the actual entry point.  */\n@@ -2130,7 +2130,7 @@ gfc_trans_entry_master_switch (gfc_entry_list * el)\n   tmp = gfc_finish_block (&block);\n   /* The first argument selects the entry point.  */\n   val = DECL_ARGUMENTS (current_function_decl);\n-  tmp = build_v (SWITCH_EXPR, val, tmp, NULL_TREE);\n+  tmp = build3_v (SWITCH_EXPR, val, tmp, NULL_TREE);\n   return tmp;\n }\n \n@@ -2233,9 +2233,9 @@ gfc_generate_function_code (gfc_namespace * ns)\n       else\n \t{\n \t  /* Set the return value to the dummy result variable.  */\n-\t  tmp = build (MODIFY_EXPR, TREE_TYPE (result),\n-\t\t       DECL_RESULT (fndecl), result);\n-\t  tmp = build_v (RETURN_EXPR, tmp);\n+\t  tmp = build2 (MODIFY_EXPR, TREE_TYPE (result),\n+\t\t\tDECL_RESULT (fndecl), result);\n+\t  tmp = build1_v (RETURN_EXPR, tmp);\n \t  gfc_add_expr_to_block (&block, tmp);\n \t}\n     }"}, {"sha": "50aa9ca338aaa11c4c8d7646dcdd0ae1d41159c0", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 36, "deletions": 36, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/923ab88cb2f07d36569c71cf53f8a0529ca1c2d4/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/923ab88cb2f07d36569c71cf53f8a0529ca1c2d4/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=923ab88cb2f07d36569c71cf53f8a0529ca1c2d4", "patch": "@@ -136,8 +136,8 @@ gfc_conv_expr_present (gfc_symbol * sym)\n              || GFC_ARRAY_TYPE_P (TREE_TYPE (decl)));\n       decl = GFC_DECL_SAVED_DESCRIPTOR (decl);\n     }\n-  return build (NE_EXPR, boolean_type_node, decl,\n-\t\tfold_convert (TREE_TYPE (decl), null_pointer_node));\n+  return build2 (NE_EXPR, boolean_type_node, decl,\n+\t\t fold_convert (TREE_TYPE (decl), null_pointer_node));\n }\n \n \n@@ -199,10 +199,10 @@ gfc_conv_substring (gfc_se * se, gfc_ref * ref, int kind)\n       gfc_add_block_to_block (&se->pre, &end.pre);\n     }\n   tmp =\n-    build (MINUS_EXPR, gfc_strlen_type_node,\n-\t   fold_convert (gfc_strlen_type_node, integer_one_node),\n-\t   start.expr);\n-  tmp = build (PLUS_EXPR, gfc_strlen_type_node, end.expr, tmp);\n+    build2 (MINUS_EXPR, gfc_strlen_type_node,\n+\t    fold_convert (gfc_strlen_type_node, integer_one_node),\n+\t    start.expr);\n+  tmp = build2 (PLUS_EXPR, gfc_strlen_type_node, end.expr, tmp);\n   se->string_length = fold (tmp);\n }\n \n@@ -224,7 +224,7 @@ gfc_conv_component_ref (gfc_se * se, gfc_ref * ref)\n   field = c->backend_decl;\n   assert (TREE_CODE (field) == FIELD_DECL);\n   decl = se->expr;\n-  tmp = build (COMPONENT_REF, TREE_TYPE (field), decl, field, NULL_TREE);\n+  tmp = build3 (COMPONENT_REF, TREE_TYPE (field), decl, field, NULL_TREE);\n \n   se->expr = tmp;\n \n@@ -379,8 +379,8 @@ gfc_conv_unary_op (enum tree_code code, gfc_se * se, gfc_expr * expr)\n      We must convert it to a compare to 0 (e.g. EQ_EXPR (op1, 0)).\n      All other unary operators have an equivalent GIMPLE unary operator.  */\n   if (code == TRUTH_NOT_EXPR)\n-    se->expr = build (EQ_EXPR, type, operand.expr,\n-\t\t      convert (type, integer_zero_node));\n+    se->expr = build2 (EQ_EXPR, type, operand.expr,\n+\t\t       convert (type, integer_zero_node));\n   else\n     se->expr = build1 (code, type, operand.expr);\n \n@@ -469,7 +469,7 @@ gfc_conv_powi (gfc_se * se, int n, tree * tmpvar)\n       op1 = op0;\n     }\n \n-  tmp = fold (build (MULT_EXPR, TREE_TYPE (op0), op0, op1));\n+  tmp = fold (build2 (MULT_EXPR, TREE_TYPE (op0), op0, op1));\n   tmp = gfc_evaluate_now (tmp, &se->pre);\n \n   if (n < POWI_TABLE_SIZE)\n@@ -508,29 +508,29 @@ gfc_conv_cst_int_power (gfc_se * se, tree lhs, tree rhs)\n   /* If rhs < 0 and lhs is an integer, the result is -1, 0 or 1.  */\n   if ((sgn == -1) && (TREE_CODE (type) == INTEGER_TYPE))\n     {\n-      tmp = build (EQ_EXPR, boolean_type_node, lhs,\n-\t\t   fold_convert (TREE_TYPE (lhs), integer_minus_one_node));\n-      cond = build (EQ_EXPR, boolean_type_node, lhs,\n-\t\t    convert (TREE_TYPE (lhs), integer_one_node));\n+      tmp = build2 (EQ_EXPR, boolean_type_node, lhs,\n+\t\t    fold_convert (TREE_TYPE (lhs), integer_minus_one_node));\n+      cond = build2 (EQ_EXPR, boolean_type_node, lhs,\n+\t\t     convert (TREE_TYPE (lhs), integer_one_node));\n \n       /* If rhs is even,\n \t result = (lhs == 1 || lhs == -1) ? 1 : 0.  */\n       if ((n & 1) == 0)\n         {\n-\t  tmp = build (TRUTH_OR_EXPR, boolean_type_node, tmp, cond);\n-\t  se->expr = build (COND_EXPR, type, tmp,\n-\t\t\t    convert (type, integer_one_node),\n-\t\t\t    convert (type, integer_zero_node));\n+\t  tmp = build2 (TRUTH_OR_EXPR, boolean_type_node, tmp, cond);\n+\t  se->expr = build3 (COND_EXPR, type, tmp,\n+\t\t\t     convert (type, integer_one_node),\n+\t\t\t     convert (type, integer_zero_node));\n \t  return 1;\n \t}\n       /* If rhs is odd,\n \t result = (lhs == 1) ? 1 : (lhs == -1) ? -1 : 0.  */\n-      tmp = build (COND_EXPR, type, tmp,\n-\t\t   convert (type, integer_minus_one_node),\n-\t\t   convert (type, integer_zero_node));\n-      se->expr = build (COND_EXPR, type, cond,\n-\t\t\tconvert (type, integer_one_node),\n-\t\t\ttmp);\n+      tmp = build3 (COND_EXPR, type, tmp,\n+\t\t    convert (type, integer_minus_one_node),\n+\t\t    convert (type, integer_zero_node));\n+      se->expr = build3 (COND_EXPR, type, cond,\n+\t\t\t convert (type, integer_one_node),\n+\t\t\t tmp);\n       return 1;\n     }\n \n@@ -539,7 +539,7 @@ gfc_conv_cst_int_power (gfc_se * se, tree lhs, tree rhs)\n   if (sgn == -1)\n     {\n       tmp = gfc_build_const (type, integer_one_node);\n-      vartmp[1] = build (RDIV_EXPR, type, tmp, vartmp[1]);\n+      vartmp[1] = build2 (RDIV_EXPR, type, tmp, vartmp[1]);\n     }\n \n   se->expr = gfc_conv_powi (se, n, vartmp);\n@@ -691,9 +691,9 @@ gfc_conv_string_tmp (gfc_se * se, tree type, tree len)\n   if (gfc_can_put_var_on_stack (len))\n     {\n       /* Create a temporary variable to hold the result.  */\n-      tmp = fold (build (MINUS_EXPR, gfc_strlen_type_node, len,\n-\t\t\t convert (gfc_strlen_type_node,\n-\t\t\t\t  integer_one_node)));\n+      tmp = fold (build2 (MINUS_EXPR, gfc_strlen_type_node, len,\n+\t\t\t  convert (gfc_strlen_type_node,\n+\t\t\t\t   integer_one_node)));\n       tmp = build_range_type (gfc_array_index_type, gfc_index_zero_node, tmp);\n       tmp = build_array_type (gfc_character1_type_node, tmp);\n       var = gfc_create_var (tmp, \"str\");\n@@ -750,8 +750,8 @@ gfc_conv_concat_op (gfc_se * se, gfc_expr * expr)\n   len = TYPE_MAX_VALUE (TYPE_DOMAIN (type));\n   if (len == NULL_TREE)\n     {\n-      len = fold (build (PLUS_EXPR, TREE_TYPE (lse.string_length),\n-\t\t\t lse.string_length, rse.string_length));\n+      len = fold (build2 (PLUS_EXPR, TREE_TYPE (lse.string_length),\n+\t\t\t  lse.string_length, rse.string_length));\n     }\n \n   type = build_pointer_type (type);\n@@ -944,11 +944,11 @@ gfc_conv_expr_op (gfc_se * se, gfc_expr * expr)\n   if (lop)\n     {\n       /* The result of logical ops is always boolean_type_node.  */\n-      tmp = fold (build (code, type, lse.expr, rse.expr));\n+      tmp = fold (build2 (code, type, lse.expr, rse.expr));\n       se->expr = convert (type, tmp);\n     }\n   else\n-    se->expr = fold (build (code, type, lse.expr, rse.expr));\n+    se->expr = fold (build2 (code, type, lse.expr, rse.expr));\n \n   /* Add the post blocks.  */\n   gfc_add_block_to_block (&se->post, &rse.post);\n@@ -1167,8 +1167,8 @@ gfc_conv_function_call (gfc_se * se, gfc_symbol * sym,\n     TREE_TYPE (TREE_TYPE (TREE_TYPE (se->expr))) = integer_type_node;\n \n   fntype = TREE_TYPE (TREE_TYPE (se->expr));\n-  se->expr = build (CALL_EXPR, TREE_TYPE (fntype), se->expr,\n-\t\t    arglist, NULL_TREE);\n+  se->expr = build3 (CALL_EXPR, TREE_TYPE (fntype), se->expr,\n+\t\t     arglist, NULL_TREE);\n \n   /* A pure function may still have side-effects - it may modify its\n      parameters.  */\n@@ -1193,7 +1193,7 @@ gfc_conv_function_call (gfc_se * se, gfc_symbol * sym,\n \t\t  /* Check the data pointer hasn't been modified.  This would\n \t\t     happen in a function returning a pointer.  */\n \t\t  tmp = gfc_conv_descriptor_data (info->descriptor);\n-\t\t  tmp = build (NE_EXPR, boolean_type_node, tmp, info->data);\n+\t\t  tmp = build2 (NE_EXPR, boolean_type_node, tmp, info->data);\n \t\t  gfc_trans_runtime_check (tmp, gfc_strconst_fault, &se->pre);\n \t\t}\n \t      se->expr = info->descriptor;\n@@ -1617,7 +1617,7 @@ gfc_trans_structure_assign (tree dest, gfc_expr * expr)\n         continue;\n \n       field = cm->backend_decl;\n-      tmp = build (COMPONENT_REF, TREE_TYPE (field), dest, field, NULL_TREE);\n+      tmp = build3 (COMPONENT_REF, TREE_TYPE (field), dest, field, NULL_TREE);\n       tmp = gfc_trans_subcomponent_assign (tmp, cm, c->expr);\n       gfc_add_expr_to_block (&block, tmp);\n     }"}, {"sha": "cfcbd2fb13d889f7e8d9b2c45ec08f5ba1478469", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 145, "deletions": 146, "changes": 291, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/923ab88cb2f07d36569c71cf53f8a0529ca1c2d4/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/923ab88cb2f07d36569c71cf53f8a0529ca1c2d4/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=923ab88cb2f07d36569c71cf53f8a0529ca1c2d4", "patch": "@@ -226,11 +226,11 @@ build_fixbound_expr (stmtblock_t * pblock, tree arg, tree type, int up)\n   intval = gfc_evaluate_now (intval, pblock);\n \n   tmp = convert (argtype, intval);\n-  cond = build (up ? GE_EXPR : LE_EXPR, boolean_type_node, tmp, arg);\n+  cond = build2 (up ? GE_EXPR : LE_EXPR, boolean_type_node, tmp, arg);\n \n-  tmp = build (up ? PLUS_EXPR : MINUS_EXPR, type, intval,\n-\t       convert (type, integer_one_node));\n-  tmp = build (COND_EXPR, type, cond, intval, tmp);\n+  tmp = build2 (up ? PLUS_EXPR : MINUS_EXPR, type, intval,\n+\t\tconvert (type, integer_one_node));\n+  tmp = build3 (COND_EXPR, type, cond, intval, tmp);\n   return tmp;\n }\n \n@@ -258,10 +258,10 @@ build_round_expr (stmtblock_t * pblock, tree arg, tree type)\n   neg = build_real (argtype, r);\n \n   tmp = gfc_build_const (argtype, integer_zero_node);\n-  cond = fold (build (GT_EXPR, boolean_type_node, arg, tmp));\n+  cond = fold (build2 (GT_EXPR, boolean_type_node, arg, tmp));\n \n-  tmp = fold (build (COND_EXPR, argtype, cond, pos, neg));\n-  tmp = fold (build (PLUS_EXPR, argtype, arg, tmp));\n+  tmp = fold (build3 (COND_EXPR, argtype, cond, pos, neg));\n+  tmp = fold (build2 (PLUS_EXPR, argtype, arg, tmp));\n   return fold (build1 (FIX_TRUNC_EXPR, type, tmp));\n }\n \n@@ -368,17 +368,17 @@ gfc_conv_intrinsic_aint (gfc_se * se, gfc_expr * expr, int op)\n   n = gfc_validate_kind (BT_INTEGER, kind);\n   mpfr_set_z (huge, gfc_integer_kinds[n].huge, GFC_RND_MODE);\n   tmp = gfc_conv_mpfr_to_tree (huge, kind);\n-  cond = build (LT_EXPR, boolean_type_node, arg, tmp);\n+  cond = build2 (LT_EXPR, boolean_type_node, arg, tmp);\n \n   mpfr_neg (huge, huge, GFC_RND_MODE);\n   tmp = gfc_conv_mpfr_to_tree (huge, kind);\n-  tmp = build (GT_EXPR, boolean_type_node, arg, tmp);\n-  cond = build (TRUTH_AND_EXPR, boolean_type_node, cond, tmp);\n+  tmp = build2 (GT_EXPR, boolean_type_node, arg, tmp);\n+  cond = build2 (TRUTH_AND_EXPR, boolean_type_node, cond, tmp);\n   itype = gfc_get_int_type (kind);\n \n   tmp = build_fix_expr (&se->pre, arg, itype, op);\n   tmp = convert (type, tmp);\n-  se->expr = build (COND_EXPR, type, cond, tmp, arg);\n+  se->expr = build3 (COND_EXPR, type, cond, tmp, arg);\n   mpfr_clear (huge);\n }\n \n@@ -641,8 +641,8 @@ gfc_conv_intrinsic_bound (gfc_se * se, gfc_expr * expr, int upper)\n       assert (se->ss->expr == expr);\n       gfc_advance_se_ss_chain (se);\n       bound = se->loop->loopvar[0];\n-      bound = fold (build (MINUS_EXPR, gfc_array_index_type, bound,\n-                           se->loop->from[0]));\n+      bound = fold (build2 (MINUS_EXPR, gfc_array_index_type, bound,\n+\t\t\t    se->loop->from[0]));\n     }\n   else\n     {\n@@ -653,8 +653,8 @@ gfc_conv_intrinsic_bound (gfc_se * se, gfc_expr * expr, int upper)\n       gfc_add_block_to_block (&se->pre, &argse.pre);\n       bound = argse.expr;\n       /* Convert from one based to zero based.  */\n-      bound = fold (build (MINUS_EXPR, gfc_array_index_type, bound,\n-\t\t\t   gfc_index_one_node));\n+      bound = fold (build2 (MINUS_EXPR, gfc_array_index_type, bound,\n+\t\t\t    gfc_index_one_node));\n     }\n \n   /* TODO: don't re-evaluate the descriptor on each iteration.  */\n@@ -679,11 +679,12 @@ gfc_conv_intrinsic_bound (gfc_se * se, gfc_expr * expr, int upper)\n       if (flag_bounds_check)\n         {\n           bound = gfc_evaluate_now (bound, &se->pre);\n-          cond = fold (build (LT_EXPR, boolean_type_node, bound,\n-                              convert (TREE_TYPE (bound), integer_zero_node)));\n+          cond = fold (build2 (LT_EXPR, boolean_type_node, \n+\t\t\t       bound, convert (TREE_TYPE (bound), \n+\t\t\t\t\t       integer_zero_node)));\n           tmp = gfc_rank_cst[GFC_TYPE_ARRAY_RANK (TREE_TYPE (desc))];\n-          tmp = fold (build (GE_EXPR, boolean_type_node, bound, tmp));\n-          cond = fold(build (TRUTH_ORIF_EXPR, boolean_type_node, cond, tmp));\n+          tmp = fold (build2 (GE_EXPR, boolean_type_node, bound, tmp));\n+          cond = fold(build2 (TRUTH_ORIF_EXPR, boolean_type_node, cond, tmp));\n           gfc_trans_runtime_check (cond, gfc_strconst_fault, &se->pre);\n         }\n     }\n@@ -761,7 +762,7 @@ gfc_conv_intrinsic_cmplx (gfc_se * se, gfc_expr * expr, int both)\n   else\n     imag = build_real_from_int_cst (TREE_TYPE (type), integer_zero_node);\n \n-  se->expr = fold (build (COMPLEX_EXPR, type, real, imag));\n+  se->expr = fold (build2 (COMPLEX_EXPR, type, real, imag));\n }\n \n /* Remainder function MOD(A, P) = A - INT(A / P) * P.\n@@ -791,34 +792,34 @@ gfc_conv_intrinsic_mod (gfc_se * se, gfc_expr * expr, int modulo)\n     {\n     case BT_INTEGER:\n       /* Integer case is easy, we've got a builtin op.  */\n-      se->expr = build (TRUNC_MOD_EXPR, type, arg, arg2);\n+      se->expr = build2 (TRUNC_MOD_EXPR, type, arg, arg2);\n       break;\n \n     case BT_REAL:\n       /* Real values we have to do the hard way.  */\n       arg = gfc_evaluate_now (arg, &se->pre);\n       arg2 = gfc_evaluate_now (arg2, &se->pre);\n \n-      tmp = build (RDIV_EXPR, type, arg, arg2);\n+      tmp = build2 (RDIV_EXPR, type, arg, arg2);\n       /* Test if the value is too large to handle sensibly.  */\n       gfc_set_model_kind (expr->ts.kind);\n       mpfr_init (huge);\n       n = gfc_validate_kind (BT_INTEGER, expr->ts.kind);\n       mpfr_set_z (huge, gfc_integer_kinds[n].huge, GFC_RND_MODE);\n       test = gfc_conv_mpfr_to_tree (huge, expr->ts.kind);\n-      test2 = build (LT_EXPR, boolean_type_node, tmp, test);\n+      test2 = build2 (LT_EXPR, boolean_type_node, tmp, test);\n \n       mpfr_neg (huge, huge, GFC_RND_MODE);\n       test = gfc_conv_mpfr_to_tree (huge, expr->ts.kind);\n-      test = build (GT_EXPR, boolean_type_node, tmp, test);\n-      test2 = build (TRUTH_AND_EXPR, boolean_type_node, test, test2);\n+      test = build2 (GT_EXPR, boolean_type_node, tmp, test);\n+      test2 = build2 (TRUTH_AND_EXPR, boolean_type_node, test, test2);\n \n       itype = gfc_get_int_type (expr->ts.kind);\n       tmp = build_fix_expr (&se->pre, tmp, itype, FIX_TRUNC_EXPR);\n       tmp = convert (type, tmp);\n-      tmp = build (COND_EXPR, type, test2, tmp, arg);\n-      tmp = build (MULT_EXPR, type, tmp, arg2);\n-      se->expr = build (MINUS_EXPR, type, arg, tmp);\n+      tmp = build3 (COND_EXPR, type, test2, tmp, arg);\n+      tmp = build2 (MULT_EXPR, type, tmp, arg2);\n+      se->expr = build2 (MINUS_EXPR, type, arg, tmp);\n       mpfr_clear (huge);\n       break;\n \n@@ -830,16 +831,16 @@ gfc_conv_intrinsic_mod (gfc_se * se, gfc_expr * expr, int modulo)\n     {\n      zero = gfc_build_const (type, integer_zero_node);\n      /* Build !(A > 0 .xor. P > 0).  */\n-     test = build (GT_EXPR, boolean_type_node, arg, zero);\n-     test2 = build (GT_EXPR, boolean_type_node, arg2, zero);\n-     test = build (TRUTH_XOR_EXPR, boolean_type_node, test, test2);\n+     test = build2 (GT_EXPR, boolean_type_node, arg, zero);\n+     test2 = build2 (GT_EXPR, boolean_type_node, arg2, zero);\n+     test = build2 (TRUTH_XOR_EXPR, boolean_type_node, test, test2);\n      test = build1 (TRUTH_NOT_EXPR, boolean_type_node, test);\n      /* Build (A == 0) .or. !(A > 0 .xor. P > 0).  */\n-     test2 = build (EQ_EXPR, boolean_type_node, arg, zero);\n-     test = build (TRUTH_OR_EXPR, boolean_type_node, test, test2);\n+     test2 = build2 (EQ_EXPR, boolean_type_node, arg, zero);\n+     test = build2 (TRUTH_OR_EXPR, boolean_type_node, test, test2);\n \n-     se->expr = build (COND_EXPR, type, test, se->expr, \n-               build (PLUS_EXPR, type, se->expr, arg2));\n+     se->expr = build3 (COND_EXPR, type, test, se->expr, \n+\t\t\tbuild2 (PLUS_EXPR, type, se->expr, arg2));\n     }\n }\n \n@@ -860,12 +861,12 @@ gfc_conv_intrinsic_dim (gfc_se * se, gfc_expr * expr)\n   arg = TREE_VALUE (arg);\n   type = TREE_TYPE (arg);\n \n-  val = build (MINUS_EXPR, type, arg, arg2);\n+  val = build2 (MINUS_EXPR, type, arg, arg2);\n   val = gfc_evaluate_now (val, &se->pre);\n \n   zero = gfc_build_const (type, integer_zero_node);\n-  tmp = build (LE_EXPR, boolean_type_node, val, zero);\n-  se->expr = build (COND_EXPR, type, tmp, zero, val);\n+  tmp = build2 (LE_EXPR, boolean_type_node, val, zero);\n+  se->expr = build3 (COND_EXPR, type, tmp, zero, val);\n }\n \n \n@@ -910,11 +911,11 @@ gfc_conv_intrinsic_sign (gfc_se * se, gfc_expr * expr)\n   type = TREE_TYPE (arg);\n   zero = gfc_build_const (type, integer_zero_node);\n \n-  testa = fold (build (GE_EXPR, boolean_type_node, arg, zero));\n-  testb = fold (build (GE_EXPR, boolean_type_node, arg2, zero));\n-  tmp = fold (build (TRUTH_XOR_EXPR, boolean_type_node, testa, testb));\n-  se->expr = fold (build (COND_EXPR, type, tmp,\n-\t\t\t  build1 (NEGATE_EXPR, type, arg), arg));\n+  testa = fold (build2 (GE_EXPR, boolean_type_node, arg, zero));\n+  testb = fold (build2 (GE_EXPR, boolean_type_node, arg2, zero));\n+  tmp = fold (build2 (TRUTH_XOR_EXPR, boolean_type_node, testa, testb));\n+  se->expr = fold (build3 (COND_EXPR, type, tmp,\n+\t\t\t   build1 (NEGATE_EXPR, type, arg), arg));\n }\n \n \n@@ -949,7 +950,7 @@ gfc_conv_intrinsic_dprod (gfc_se * se, gfc_expr * expr)\n   type = gfc_typenode_for_spec (&expr->ts);\n   arg = convert (type, arg);\n   arg2 = convert (type, arg2);\n-  se->expr = build (MULT_EXPR, type, arg, arg2);\n+  se->expr = build2 (MULT_EXPR, type, arg, arg2);\n }\n \n \n@@ -1016,7 +1017,7 @@ gfc_conv_intrinsic_minmax (gfc_se * se, gfc_expr * expr, int op)\n     limit = gfc_evaluate_now(limit, &se->pre);\n \n   mvar = gfc_create_var (type, \"M\");\n-  elsecase = build_v (MODIFY_EXPR, mvar, limit);\n+  elsecase = build2_v (MODIFY_EXPR, mvar, limit);\n   for (arg = TREE_CHAIN (arg); arg != NULL_TREE; arg = TREE_CHAIN (arg))\n     {\n       val = TREE_VALUE (arg);\n@@ -1027,10 +1028,10 @@ gfc_conv_intrinsic_minmax (gfc_se * se, gfc_expr * expr, int op)\n       if (TREE_CODE (val) != VAR_DECL && !TREE_CONSTANT (val))\n         val = gfc_evaluate_now(val, &se->pre);\n \n-      thencase = build_v (MODIFY_EXPR, mvar, convert (type, val));\n+      thencase = build2_v (MODIFY_EXPR, mvar, convert (type, val));\n \n-      tmp = build (op, boolean_type_node, val, limit);\n-      tmp = build_v (COND_EXPR, tmp, thencase, elsecase);\n+      tmp = build2 (op, boolean_type_node, val, limit);\n+      tmp = build3_v (COND_EXPR, tmp, thencase, elsecase);\n       gfc_add_expr_to_block (&se->pre, tmp);\n       elsecase = build_empty_stmt ();\n       limit = mvar;\n@@ -1177,10 +1178,10 @@ gfc_conv_intrinsic_anyall (gfc_se * se, gfc_expr * expr, int op)\n   gfc_conv_expr_val (&arrayse, actual->expr);\n \n   gfc_add_block_to_block (&body, &arrayse.pre);\n-  tmp = build (op, boolean_type_node, arrayse.expr,\n-\t       fold_convert (TREE_TYPE (arrayse.expr),\n-\t\t\t     integer_zero_node));\n-  tmp = build_v (COND_EXPR, tmp, found, build_empty_stmt ());\n+  tmp = build2 (op, boolean_type_node, arrayse.expr,\n+\t\tfold_convert (TREE_TYPE (arrayse.expr),\n+\t\t\t      integer_zero_node));\n+  tmp = build3_v (COND_EXPR, tmp, found, build_empty_stmt ());\n   gfc_add_expr_to_block (&body, tmp);\n   gfc_add_block_to_block (&body, &arrayse.post);\n \n@@ -1239,15 +1240,15 @@ gfc_conv_intrinsic_count (gfc_se * se, gfc_expr * expr)\n   /* Generate the loop body.  */\n   gfc_start_scalarized_body (&loop, &body);\n \n-  tmp = build (PLUS_EXPR, TREE_TYPE (resvar), resvar,\n-\t       convert (TREE_TYPE (resvar), integer_one_node));\n-  tmp = build_v (MODIFY_EXPR, resvar, tmp);\n+  tmp = build2 (PLUS_EXPR, TREE_TYPE (resvar), resvar,\n+\t\tconvert (TREE_TYPE (resvar), integer_one_node));\n+  tmp = build2_v (MODIFY_EXPR, resvar, tmp);\n \n   gfc_init_se (&arrayse, NULL);\n   gfc_copy_loopinfo_to_se (&arrayse, &loop);\n   arrayse.ss = arrayss;\n   gfc_conv_expr_val (&arrayse, actual->expr);\n-  tmp = build_v (COND_EXPR, arrayse.expr, tmp, build_empty_stmt ());\n+  tmp = build3_v (COND_EXPR, arrayse.expr, tmp, build_empty_stmt ());\n \n   gfc_add_block_to_block (&body, &arrayse.pre);\n   gfc_add_expr_to_block (&body, tmp);\n@@ -1350,7 +1351,7 @@ gfc_conv_intrinsic_arith (gfc_se * se, gfc_expr * expr, int op)\n   gfc_conv_expr_val (&arrayse, arrayexpr);\n   gfc_add_block_to_block (&block, &arrayse.pre);\n \n-  tmp = build (op, type, resvar, arrayse.expr);\n+  tmp = build2 (op, type, resvar, arrayse.expr);\n   gfc_add_modify_expr (&block, resvar, tmp);\n   gfc_add_block_to_block (&block, &arrayse.post);\n \n@@ -1359,7 +1360,7 @@ gfc_conv_intrinsic_arith (gfc_se * se, gfc_expr * expr, int op)\n       /* We enclose the above in if (mask) {...} .  */\n       tmp = gfc_finish_block (&block);\n \n-      tmp = build_v (COND_EXPR, maskse.expr, tmp, build_empty_stmt ());\n+      tmp = build3_v (COND_EXPR, maskse.expr, tmp, build_empty_stmt ());\n     }\n   else\n     tmp = gfc_finish_block (&block);\n@@ -1460,12 +1461,12 @@ gfc_conv_intrinsic_minmaxloc (gfc_se * se, gfc_expr * expr, int op)\n      size we need to return zero.  Otherwise use the first element of the\n      array, in case all elements are equal to the limit.\n      ie. pos = (ubound >= lbound) ? lbound, lbound - 1;  */\n-  tmp = fold (build (MINUS_EXPR, gfc_array_index_type,\n-\t             loop.from[0], gfc_index_one_node));\n-  cond = fold (build (GE_EXPR, boolean_type_node,\n-\t\t      loop.to[0], loop.from[0]));\n-  tmp = fold (build (COND_EXPR, gfc_array_index_type, cond,\n-\t\t     loop.from[0], tmp));\n+  tmp = fold (build2 (MINUS_EXPR, gfc_array_index_type,\n+\t\t      loop.from[0], gfc_index_one_node));\n+  cond = fold (build2 (GE_EXPR, boolean_type_node,\n+\t\t       loop.to[0], loop.from[0]));\n+  tmp = fold (build3 (COND_EXPR, gfc_array_index_type, cond,\n+\t\t      loop.from[0], tmp));\n   gfc_add_modify_expr (&loop.pre, pos, tmp);\n       \n   gfc_mark_ss_chain_used (arrayss, 1);\n@@ -1507,16 +1508,16 @@ gfc_conv_intrinsic_minmaxloc (gfc_se * se, gfc_expr * expr, int op)\n   ifbody = gfc_finish_block (&ifblock);\n \n   /* If it is a more extreme value.  */\n-  tmp = build (op, boolean_type_node, arrayse.expr, limit);\n-  tmp = build_v (COND_EXPR, tmp, ifbody, build_empty_stmt ());\n+  tmp = build2 (op, boolean_type_node, arrayse.expr, limit);\n+  tmp = build3_v (COND_EXPR, tmp, ifbody, build_empty_stmt ());\n   gfc_add_expr_to_block (&block, tmp);\n \n   if (maskss)\n     {\n       /* We enclose the above in if (mask) {...}.  */\n       tmp = gfc_finish_block (&block);\n \n-      tmp = build_v (COND_EXPR, maskse.expr, tmp, build_empty_stmt ());\n+      tmp = build3_v (COND_EXPR, maskse.expr, tmp, build_empty_stmt ());\n     }\n   else\n     tmp = gfc_finish_block (&block);\n@@ -1529,9 +1530,9 @@ gfc_conv_intrinsic_minmaxloc (gfc_se * se, gfc_expr * expr, int op)\n   gfc_cleanup_loop (&loop);\n \n   /* Return a value in the range 1..SIZE(array).  */\n-  tmp = fold (build (MINUS_EXPR, gfc_array_index_type, loop.from[0],\n-\t\t     gfc_index_one_node));\n-  tmp = fold (build (MINUS_EXPR, gfc_array_index_type, pos, tmp));\n+  tmp = fold (build2 (MINUS_EXPR, gfc_array_index_type, loop.from[0],\n+\t\t      gfc_index_one_node));\n+  tmp = fold (build2 (MINUS_EXPR, gfc_array_index_type, pos, tmp));\n   /* And convert to the required type.  */\n   se->expr = convert (type, tmp);\n }\n@@ -1639,20 +1640,18 @@ gfc_conv_intrinsic_minmaxval (gfc_se * se, gfc_expr * expr, int op)\n   gfc_add_block_to_block (&block, &arrayse.pre);\n \n   /* Assign the value to the limit...  */\n-  ifbody = build_v (MODIFY_EXPR, limit, arrayse.expr);\n+  ifbody = build2_v (MODIFY_EXPR, limit, arrayse.expr);\n \n   /* If it is a more extreme value.  */\n-  tmp = build (op, boolean_type_node, arrayse.expr, limit);\n-  tmp = build_v (COND_EXPR, tmp, ifbody, build_empty_stmt ());\n+  tmp = build2 (op, boolean_type_node, arrayse.expr, limit);\n+  tmp = build3_v (COND_EXPR, tmp, ifbody, build_empty_stmt ());\n   gfc_add_expr_to_block (&block, tmp);\n   gfc_add_block_to_block (&block, &arrayse.post);\n \n   tmp = gfc_finish_block (&block);\n   if (maskss)\n-    {\n-      /* We enclose the above in if (mask) {...}.  */\n-      tmp = build_v (COND_EXPR, maskse.expr, tmp, build_empty_stmt ());\n-    }\n+    /* We enclose the above in if (mask) {...}.  */\n+    tmp = build3_v (COND_EXPR, maskse.expr, tmp, build_empty_stmt ());\n   gfc_add_expr_to_block (&body, tmp);\n \n   gfc_trans_scalarizing_loops (&loop, &body);\n@@ -1678,10 +1677,10 @@ gfc_conv_intrinsic_btest (gfc_se * se, gfc_expr * expr)\n   arg = TREE_VALUE (arg);\n   type = TREE_TYPE (arg);\n \n-  tmp = build (LSHIFT_EXPR, type, convert (type, integer_one_node), arg2);\n-  tmp = build (BIT_AND_EXPR, type, arg, tmp);\n-  tmp = fold (build (NE_EXPR, boolean_type_node, tmp,\n-\t\t     convert (type, integer_zero_node)));\n+  tmp = build2 (LSHIFT_EXPR, type, convert (type, integer_one_node), arg2);\n+  tmp = build2 (BIT_AND_EXPR, type, arg, tmp);\n+  tmp = fold (build2 (NE_EXPR, boolean_type_node, tmp,\n+\t\t      convert (type, integer_zero_node)));\n   type = gfc_typenode_for_spec (&expr->ts);\n   se->expr = convert (type, tmp);\n }\n@@ -1699,7 +1698,7 @@ gfc_conv_intrinsic_bitop (gfc_se * se, gfc_expr * expr, int op)\n   arg = TREE_VALUE (arg);\n   type = TREE_TYPE (arg);\n \n-  se->expr = fold (build (op, type, arg, arg2));\n+  se->expr = fold (build2 (op, type, arg, arg2));\n }\n \n /* Bitwise not.  */\n@@ -1729,7 +1728,7 @@ gfc_conv_intrinsic_singlebitop (gfc_se * se, gfc_expr * expr, int set)\n   arg = TREE_VALUE (arg);\n   type = TREE_TYPE (arg);\n \n-  tmp = fold (build (LSHIFT_EXPR, type,\n+  tmp = fold (build2 (LSHIFT_EXPR, type,\n \t\t     convert (type, integer_one_node), arg2));\n   if (set)\n     op = BIT_IOR_EXPR;\n@@ -1738,7 +1737,7 @@ gfc_conv_intrinsic_singlebitop (gfc_se * se, gfc_expr * expr, int set)\n       op = BIT_AND_EXPR;\n       tmp = fold (build1 (BIT_NOT_EXPR, type, tmp));\n     }\n-  se->expr = fold (build (op, type, arg, tmp));\n+  se->expr = fold (build2 (op, type, arg, tmp));\n }\n \n /* Extract a sequence of bits.\n@@ -1761,12 +1760,12 @@ gfc_conv_intrinsic_ibits (gfc_se * se, gfc_expr * expr)\n   type = TREE_TYPE (arg);\n \n   mask = build_int_cst (NULL_TREE, -1);\n-  mask = build (LSHIFT_EXPR, type, mask, arg3);\n+  mask = build2 (LSHIFT_EXPR, type, mask, arg3);\n   mask = build1 (BIT_NOT_EXPR, type, mask);\n \n-  tmp = build (RSHIFT_EXPR, type, arg, arg2);\n+  tmp = build2 (RSHIFT_EXPR, type, arg, arg2);\n \n-  se->expr = fold (build (BIT_AND_EXPR, type, tmp, mask));\n+  se->expr = fold (build2 (BIT_AND_EXPR, type, tmp, mask));\n }\n \n /* ISHFT (I, SHIFT) = (shift >= 0) ? i << shift : i >> -shift.  */\n@@ -1786,21 +1785,21 @@ gfc_conv_intrinsic_ishft (gfc_se * se, gfc_expr * expr)\n   type = TREE_TYPE (arg);\n \n   /* Left shift if positive.  */\n-  lshift = build (LSHIFT_EXPR, type, arg, arg2);\n+  lshift = build2 (LSHIFT_EXPR, type, arg, arg2);\n \n   /* Right shift if negative.  This will perform an arithmetic shift as\n      we are dealing with signed integers.  Section 13.5.7 allows this.  */\n   tmp = build1 (NEGATE_EXPR, TREE_TYPE (arg2), arg2);\n-  rshift = build (RSHIFT_EXPR, type, arg, tmp);\n+  rshift = build2 (RSHIFT_EXPR, type, arg, tmp);\n \n-  tmp = build (GT_EXPR, boolean_type_node, arg2,\n-\t       convert (TREE_TYPE (arg2), integer_zero_node));\n-  rshift = build (COND_EXPR, type, tmp, lshift, rshift);\n+  tmp = build2 (GT_EXPR, boolean_type_node, arg2,\n+\t\tconvert (TREE_TYPE (arg2), integer_zero_node));\n+  rshift = build3 (COND_EXPR, type, tmp, lshift, rshift);\n \n   /* Do nothing if shift == 0.  */\n-  tmp = build (EQ_EXPR, boolean_type_node, arg2,\n-\t       convert (TREE_TYPE (arg2), integer_zero_node));\n-  se->expr = build (COND_EXPR, type, tmp, arg, rshift);\n+  tmp = build2 (EQ_EXPR, boolean_type_node, arg2,\n+\t\tconvert (TREE_TYPE (arg2), integer_zero_node));\n+  se->expr = build3 (COND_EXPR, type, tmp, arg, rshift);\n }\n \n /* Circular shift.  AKA rotate or barrel shift.  */\n@@ -1849,20 +1848,20 @@ gfc_conv_intrinsic_ishftc (gfc_se * se, gfc_expr * expr)\n   type = TREE_TYPE (arg);\n \n   /* Rotate left if positive.  */\n-  lrot = build (LROTATE_EXPR, type, arg, arg2);\n+  lrot = build2 (LROTATE_EXPR, type, arg, arg2);\n \n   /* Rotate right if negative.  */\n   tmp = build1 (NEGATE_EXPR, TREE_TYPE (arg2), arg2);\n-  rrot = build (RROTATE_EXPR, type, arg, tmp);\n+  rrot = build2 (RROTATE_EXPR, type, arg, tmp);\n \n-  tmp = build (GT_EXPR, boolean_type_node, arg2,\n-\t       convert (TREE_TYPE (arg2), integer_zero_node));\n-  rrot = build (COND_EXPR, type, tmp, lrot, rrot);\n+  tmp = build2 (GT_EXPR, boolean_type_node, arg2,\n+\t\tconvert (TREE_TYPE (arg2), integer_zero_node));\n+  rrot = build3 (COND_EXPR, type, tmp, lrot, rrot);\n \n   /* Do nothing if shift == 0.  */\n-  tmp = build (EQ_EXPR, boolean_type_node, arg2,\n-\t       convert (TREE_TYPE (arg2), integer_zero_node));\n-  se->expr = build (COND_EXPR, type, tmp, arg, rrot);\n+  tmp = build2 (EQ_EXPR, boolean_type_node, arg2,\n+\t\tconvert (TREE_TYPE (arg2), integer_zero_node));\n+  se->expr = build3 (COND_EXPR, type, tmp, arg, rrot);\n }\n \n /* The length of a character string.  */\n@@ -1998,7 +1997,7 @@ gfc_conv_intrinsic_merge (gfc_se * se, gfc_expr * expr)\n   mask = TREE_VALUE (arg);\n \n   type = TREE_TYPE (tsource);\n-  se->expr = fold (build (COND_EXPR, type, mask, tsource, fsource));\n+  se->expr = fold (build3 (COND_EXPR, type, mask, tsource, fsource));\n }\n \n \n@@ -2054,8 +2053,8 @@ gfc_conv_intrinsic_strcmp (gfc_se * se, gfc_expr * expr, int op)\n   se->expr = gfc_build_function_call (gfor_fndecl_compare_string, args);\n \n   type = gfc_typenode_for_spec (&expr->ts);\n-  se->expr = build (op, type, se->expr,\n-\t\t    convert (TREE_TYPE (se->expr), integer_zero_node));\n+  se->expr = build2 (op, type, se->expr,\n+\t\t     convert (TREE_TYPE (se->expr), integer_zero_node));\n }\n \n /* Generate a call to the adjustl/adjustr library function.  */\n@@ -2145,8 +2144,8 @@ gfc_conv_allocated (gfc_se *se, gfc_expr *expr)\n   gfc_conv_expr_descriptor (&arg1se, arg1->expr, ss1);\n \n   tmp = gfc_conv_descriptor_data (arg1se.expr);\n-  tmp = build (NE_EXPR, boolean_type_node, tmp,\n-\t       fold_convert (TREE_TYPE (tmp), null_pointer_node));\n+  tmp = build2 (NE_EXPR, boolean_type_node, tmp,\n+\t\tfold_convert (TREE_TYPE (tmp), null_pointer_node));\n   se->expr = convert (gfc_typenode_for_spec (&expr->ts), tmp);\n }\n \n@@ -2192,8 +2191,8 @@ gfc_conv_associated (gfc_se *se, gfc_expr *expr)\n           gfc_conv_expr_lhs (&arg1se, arg1->expr);\n           tmp2 = gfc_conv_descriptor_data (arg1se.expr);\n         }\n-      tmp = build (NE_EXPR, boolean_type_node, tmp2,\n-\t\t   fold_convert (TREE_TYPE (tmp2), null_pointer_node));\n+      tmp = build2 (NE_EXPR, boolean_type_node, tmp2,\n+\t\t    fold_convert (TREE_TYPE (tmp2), null_pointer_node));\n       se->expr = tmp;\n     }\n   else\n@@ -2208,7 +2207,7 @@ gfc_conv_associated (gfc_se *se, gfc_expr *expr)\n           gfc_conv_expr (&arg1se, arg1->expr);\n           arg2se.want_pointer = 1;\n           gfc_conv_expr (&arg2se, arg2->expr);\n-          tmp = build (EQ_EXPR, boolean_type_node, arg1se.expr, arg2se.expr);\n+          tmp = build2 (EQ_EXPR, boolean_type_node, arg1se.expr, arg2se.expr);\n           se->expr = tmp;\n         }\n       else\n@@ -2333,29 +2332,29 @@ void prepare_arg_info (gfc_se * se, gfc_expr * expr,\n    rcs->fdigits = convert (masktype, tmp);\n    wbits = build_int_cst (NULL_TREE, TYPE_PRECISION (rcs->type) - 1);\n    wbits = convert (masktype, wbits);\n-   rcs->edigits = fold (build (MINUS_EXPR, masktype, wbits, tmp));\n+   rcs->edigits = fold (build2 (MINUS_EXPR, masktype, wbits, tmp));\n \n    /* Form masks for exponent/fraction/sign  */\n    one = gfc_build_const (masktype, integer_one_node);\n-   rcs->smask = fold (build (LSHIFT_EXPR, masktype, one, wbits));\n-   rcs->f1 = fold (build (LSHIFT_EXPR, masktype, one, rcs->fdigits));\n-   rcs->emask = fold (build (MINUS_EXPR, masktype, rcs->smask, rcs->f1));\n-   rcs->fmask = fold (build (MINUS_EXPR, masktype, rcs->f1, one));\n+   rcs->smask = fold (build2 (LSHIFT_EXPR, masktype, one, wbits));\n+   rcs->f1 = fold (build2 (LSHIFT_EXPR, masktype, one, rcs->fdigits));\n+   rcs->emask = fold (build2 (MINUS_EXPR, masktype, rcs->smask, rcs->f1));\n+   rcs->fmask = fold (build2 (MINUS_EXPR, masktype, rcs->f1, one));\n    /* Form bias.  */\n-   tmp = fold (build (MINUS_EXPR, masktype, rcs->edigits, one));\n-   tmp = fold (build (LSHIFT_EXPR, masktype, one, tmp));\n-   rcs->bias = fold (build (MINUS_EXPR, masktype, tmp ,one));\n+   tmp = fold (build2 (MINUS_EXPR, masktype, rcs->edigits, one));\n+   tmp = fold (build2 (LSHIFT_EXPR, masktype, one, tmp));\n+   rcs->bias = fold (build2 (MINUS_EXPR, masktype, tmp ,one));\n \n    if (all)\n    { \n      /* exponent, and fraction  */\n-     tmp = build (BIT_AND_EXPR, masktype, arg, rcs->emask);\n-     tmp = build (RSHIFT_EXPR, masktype, tmp, rcs->fdigits);\n+     tmp = build2 (BIT_AND_EXPR, masktype, arg, rcs->emask);\n+     tmp = build2 (RSHIFT_EXPR, masktype, tmp, rcs->fdigits);\n      exponent = gfc_create_var (masktype, \"exponent\");\n      gfc_add_modify_expr(&se->pre, exponent, tmp);\n      rcs->expn = exponent;\n \n-     tmp = build (BIT_AND_EXPR, masktype, arg, rcs->fmask);\n+     tmp = build2 (BIT_AND_EXPR, masktype, arg, rcs->fmask);\n      fraction = gfc_create_var (masktype, \"fraction\");\n      gfc_add_modify_expr(&se->pre, fraction, tmp);\n      rcs->frac = fraction;\n@@ -2409,12 +2408,12 @@ gfc_conv_intrinsic_spacing (gfc_se * se, gfc_expr * expr)\n    fdigits = rcs.fdigits;\n    tiny = rcs.f1;\n    zero = gfc_build_const (masktype, integer_zero_node);\n-   tmp = build (BIT_AND_EXPR, masktype, rcs.emask, arg);\n-   tmp = build (RSHIFT_EXPR, masktype, tmp, fdigits);\n-   tmp = build (MINUS_EXPR, masktype, tmp, fdigits);\n-   cond = build (LE_EXPR, boolean_type_node, tmp, zero);\n-   t1 = build (LSHIFT_EXPR, masktype, tmp, fdigits);\n-   tmp = build (COND_EXPR, masktype, cond, tiny, t1);\n+   tmp = build2 (BIT_AND_EXPR, masktype, rcs.emask, arg);\n+   tmp = build2 (RSHIFT_EXPR, masktype, tmp, fdigits);\n+   tmp = build2 (MINUS_EXPR, masktype, tmp, fdigits);\n+   cond = build2 (LE_EXPR, boolean_type_node, tmp, zero);\n+   t1 = build2 (LSHIFT_EXPR, masktype, tmp, fdigits);\n+   tmp = build3 (COND_EXPR, masktype, cond, tiny, t1);\n    tmp = build1 (VIEW_CONVERT_EXPR, rcs.type, tmp);\n \n    se->expr = tmp;\n@@ -2452,23 +2451,23 @@ gfc_conv_intrinsic_rrspacing (gfc_se * se, gfc_expr * expr)\n    fraction = rcs.frac;\n    one = gfc_build_const (masktype, integer_one_node);\n    zero = gfc_build_const (masktype, integer_zero_node);\n-   t2 = build (PLUS_EXPR, masktype, rcs.edigits, one);\n+   t2 = build2 (PLUS_EXPR, masktype, rcs.edigits, one);\n \n    t1 = call_builtin_clz (masktype, fraction);\n-   tmp = build (PLUS_EXPR, masktype, t1, one);\n-   tmp = build (LSHIFT_EXPR, masktype, fraction, tmp);\n-   tmp = build (RSHIFT_EXPR, masktype, tmp, t2);\n-   cond = build (EQ_EXPR, boolean_type_node, rcs.expn, zero);\n-   fraction = build (COND_EXPR, masktype, cond, tmp, fraction);\n+   tmp = build2 (PLUS_EXPR, masktype, t1, one);\n+   tmp = build2 (LSHIFT_EXPR, masktype, fraction, tmp);\n+   tmp = build2 (RSHIFT_EXPR, masktype, tmp, t2);\n+   cond = build2 (EQ_EXPR, boolean_type_node, rcs.expn, zero);\n+   fraction = build3 (COND_EXPR, masktype, cond, tmp, fraction);\n \n-   tmp = build (PLUS_EXPR, masktype, rcs.bias, fdigits);\n-   tmp = build (LSHIFT_EXPR, masktype, tmp, fdigits);\n-   tmp = build (BIT_IOR_EXPR, masktype, tmp, fraction);\n+   tmp = build2 (PLUS_EXPR, masktype, rcs.bias, fdigits);\n+   tmp = build2 (LSHIFT_EXPR, masktype, tmp, fdigits);\n+   tmp = build2 (BIT_IOR_EXPR, masktype, tmp, fraction);\n \n-   cond2 = build (EQ_EXPR, boolean_type_node, rcs.frac, zero);\n-   cond = build (TRUTH_ANDIF_EXPR, boolean_type_node, cond, cond2);\n-   tmp = build (COND_EXPR, masktype, cond,\n-\t\tconvert (masktype, integer_zero_node), tmp);\n+   cond2 = build2 (EQ_EXPR, boolean_type_node, rcs.frac, zero);\n+   cond = build2 (TRUTH_ANDIF_EXPR, boolean_type_node, cond, cond2);\n+   tmp = build3 (COND_EXPR, masktype, cond,\n+\t\t convert (masktype, integer_zero_node), tmp);\n \n    tmp = build1 (VIEW_CONVERT_EXPR, rcs.type, tmp);\n    se->expr = tmp;\n@@ -2545,11 +2544,11 @@ gfc_conv_intrinsic_trim (gfc_se * se, gfc_expr * expr)\n   gfc_add_expr_to_block (&se->pre, tmp);\n \n   /* Free the temporary afterwards, if necessary.  */\n-  cond = build (GT_EXPR, boolean_type_node, len,\n-\t\tconvert (TREE_TYPE (len), integer_zero_node));\n+  cond = build2 (GT_EXPR, boolean_type_node, len,\n+\t\t convert (TREE_TYPE (len), integer_zero_node));\n   arglist = gfc_chainon_list (NULL_TREE, var);\n   tmp = gfc_build_function_call (gfor_fndecl_internal_free, arglist);\n-  tmp = build_v (COND_EXPR, cond, tmp, build_empty_stmt ());\n+  tmp = build3_v (COND_EXPR, cond, tmp, build_empty_stmt ());\n   gfc_add_expr_to_block (&se->post, tmp);\n \n   se->expr = var;\n@@ -2574,7 +2573,7 @@ gfc_conv_intrinsic_repeat (gfc_se * se, gfc_expr * expr)\n   len = TREE_VALUE (args);\n   tmp = gfc_advance_chain (args, 2);\n   ncopies = TREE_VALUE (tmp);\n-  len = fold (build (MULT_EXPR, gfc_int4_type_node, len, ncopies));\n+  len = fold (build2 (MULT_EXPR, gfc_int4_type_node, len, ncopies));\n   type = gfc_get_character_type (expr->ts.kind, expr->ts.cl);\n   var = gfc_conv_string_tmp (se, build_pointer_type (type), len);\n \n@@ -2608,7 +2607,7 @@ gfc_conv_intrinsic_iargc (gfc_se * se, gfc_expr * expr, bool args_only)\n   tmp = fold_convert (type, tmp);\n \n   if (args_only)\n-    tmp = build (MINUS_EXPR, type, tmp, convert (type, integer_one_node));\n+    tmp = build2 (MINUS_EXPR, type, tmp, convert (type, integer_one_node));\n   se->expr = tmp;\n }\n "}, {"sha": "2c3c8b6a96d5b2920ce15fe7e13c08e1302c9ab7", "filename": "gcc/fortran/trans-io.c", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/923ab88cb2f07d36569c71cf53f8a0529ca1c2d4/gcc%2Ffortran%2Ftrans-io.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/923ab88cb2f07d36569c71cf53f8a0529ca1c2d4/gcc%2Ffortran%2Ftrans-io.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-io.c?ref=923ab88cb2f07d36569c71cf53f8a0529ca1c2d4", "patch": "@@ -360,7 +360,7 @@ set_parameter_value (stmtblock_t * block, tree var, gfc_expr * e)\n   gfc_conv_expr_type (&se, e, TREE_TYPE (var));\n   gfc_add_block_to_block (block, &se.pre);\n \n-  tmp = build (COMPONENT_REF, TREE_TYPE (var), ioparm_var, var, NULL_TREE);\n+  tmp = build3 (COMPONENT_REF, TREE_TYPE (var), ioparm_var, var, NULL_TREE);\n   gfc_add_modify_expr (block, tmp, se.expr);\n }\n \n@@ -380,7 +380,7 @@ set_parameter_ref (stmtblock_t * block, tree var, gfc_expr * e)\n   gfc_conv_expr_type (&se, e, TREE_TYPE (var));\n   gfc_add_block_to_block (block, &se.pre);\n \n-  tmp = build (COMPONENT_REF, TREE_TYPE (var), ioparm_var, var, NULL_TREE);\n+  tmp = build3 (COMPONENT_REF, TREE_TYPE (var), ioparm_var, var, NULL_TREE);\n   gfc_add_modify_expr (block, tmp, se.expr);\n }\n \n@@ -401,18 +401,18 @@ set_string (stmtblock_t * block, stmtblock_t * postblock, tree var,\n   gfc_init_se (&se, NULL);\n   gfc_conv_expr (&se, e);\n \n-  io = build (COMPONENT_REF, TREE_TYPE (var), ioparm_var, var, NULL_TREE);\n-  len = build (COMPONENT_REF, TREE_TYPE (var_len), ioparm_var, var_len,\n-\t       NULL_TREE);\n+  io = build3 (COMPONENT_REF, TREE_TYPE (var), ioparm_var, var, NULL_TREE);\n+  len = build3 (COMPONENT_REF, TREE_TYPE (var_len), ioparm_var, var_len,\n+\t\tNULL_TREE);\n \n   /* Integer variable assigned a format label.  */\n   if (e->ts.type == BT_INTEGER && e->symtree->n.sym->attr.assign == 1)\n     {\n       msg =\n         gfc_build_string_const (37, \"Assigned label is not a format label\");\n       tmp = GFC_DECL_STRING_LEN (se.expr);\n-      tmp = build (LE_EXPR, boolean_type_node,\n-\t\t   tmp, convert (TREE_TYPE (tmp), integer_minus_one_node));\n+      tmp = build2 (LE_EXPR, boolean_type_node,\n+\t\t    tmp, convert (TREE_TYPE (tmp), integer_minus_one_node));\n       gfc_trans_runtime_check (tmp, msg, &se.pre);\n       gfc_add_modify_expr (&se.pre, io, GFC_DECL_ASSIGN_ADDR (se.expr));\n       gfc_add_modify_expr (&se.pre, len, GFC_DECL_STRING_LEN (se.expr));\n@@ -436,7 +436,7 @@ set_flag (stmtblock_t *block, tree var)\n {\n   tree tmp, type = TREE_TYPE (var);\n \n-  tmp = build (COMPONENT_REF, type, ioparm_var, var, NULL_TREE);\n+  tmp = build3 (COMPONENT_REF, type, ioparm_var, var, NULL_TREE);\n   gfc_add_modify_expr (block, tmp, convert (type, integer_one_node));\n }\n \n@@ -458,7 +458,7 @@ add_case (int label_value, gfc_st_label * label, stmtblock_t * body)\n   DECL_CONTEXT (tmp) = current_function_decl;\n \n   /* And the case itself.  */\n-  tmp = build_v (CASE_LABEL_EXPR, value, NULL_TREE, tmp);\n+  tmp = build3_v (CASE_LABEL_EXPR, value, NULL_TREE, tmp);\n   gfc_add_expr_to_block (body, tmp);\n \n   /* Jump to the label.  */\n@@ -498,10 +498,10 @@ io_result (stmtblock_t * block, gfc_st_label * err_label,\n \n   tmp = gfc_finish_block (&body);\n \n-  rc = build (COMPONENT_REF, TREE_TYPE (ioparm_library_return), ioparm_var,\n-\t      ioparm_library_return, NULL_TREE);\n+  rc = build3 (COMPONENT_REF, TREE_TYPE (ioparm_library_return), ioparm_var,\n+\t       ioparm_library_return, NULL_TREE);\n \n-  tmp = build_v (SWITCH_EXPR, rc, tmp, NULL_TREE);\n+  tmp = build3_v (SWITCH_EXPR, rc, tmp, NULL_TREE);\n \n   gfc_add_expr_to_block (block, tmp);\n }\n@@ -873,7 +873,8 @@ transfer_namelist_element (stmtblock_t * block, gfc_typespec * ts, tree addr_exp\n         {\n           tree field = c->backend_decl;\n           assert (field && TREE_CODE (field) == FIELD_DECL);\n-          tmp = build (COMPONENT_REF, TREE_TYPE (field), expr, field, NULL_TREE);\n+          tmp = build3 (COMPONENT_REF, TREE_TYPE (field), \n+\t\t\texpr, field, NULL_TREE);\n \n           if (c->dimension)\n             gfc_todo_error (\"NAMELIST IO of array in derived type\");\n@@ -1185,8 +1186,8 @@ transfer_expr (gfc_se * se, gfc_typespec * ts, tree addr_expr)\n \t  field = c->backend_decl;\n \t  assert (field && TREE_CODE (field) == FIELD_DECL);\n \n-\t  tmp = build (COMPONENT_REF, TREE_TYPE (field), expr, field,\n-\t\t       NULL_TREE);\n+\t  tmp = build3 (COMPONENT_REF, TREE_TYPE (field), expr, field,\n+\t\t\tNULL_TREE);\n \n \t  if (c->ts.type == BT_CHARACTER)\n \t    {"}, {"sha": "1df24153feaf6176d7afb66f179b206a4e9cc148", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 99, "deletions": 98, "changes": 197, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/923ab88cb2f07d36569c71cf53f8a0529ca1c2d4/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/923ab88cb2f07d36569c71cf53f8a0529ca1c2d4/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=923ab88cb2f07d36569c71cf53f8a0529ca1c2d4", "patch": "@@ -147,7 +147,7 @@ gfc_trans_goto (gfc_code * code)\n   assign_error =\n     gfc_build_string_const (37, \"Assigned label is not a target label\");\n   tmp = GFC_DECL_STRING_LEN (se.expr);\n-  tmp = build (NE_EXPR, boolean_type_node, tmp, integer_minus_one_node);\n+  tmp = build2 (NE_EXPR, boolean_type_node, tmp, integer_minus_one_node);\n   gfc_trans_runtime_check (tmp, assign_error, &se.pre);\n \n   assigned_goto = GFC_DECL_ASSIGN_ADDR (se.expr);\n@@ -168,8 +168,8 @@ gfc_trans_goto (gfc_code * code)\n     {\n       tmp = gfc_get_label_decl (code->label);\n       tmp = gfc_build_addr_expr (pvoid_type_node, tmp);\n-      tmp = build (EQ_EXPR, boolean_type_node, tmp, assigned_goto);\n-      tmp = build_v (COND_EXPR, tmp, target, build_empty_stmt ());\n+      tmp = build2 (EQ_EXPR, boolean_type_node, tmp, assigned_goto);\n+      tmp = build3_v (COND_EXPR, tmp, target, build_empty_stmt ());\n       gfc_add_expr_to_block (&se.pre, tmp);\n       code = code->block;\n     }\n@@ -256,7 +256,7 @@ gfc_trans_return (gfc_code * code ATTRIBUTE_UNUSED)\n \n       gfc_conv_expr (&se, code->expr);\n \n-      tmp = build (MODIFY_EXPR, TREE_TYPE (result), result, se.expr);\n+      tmp = build2 (MODIFY_EXPR, TREE_TYPE (result), result, se.expr);\n       gfc_add_expr_to_block (&se.pre, tmp);\n \n       tmp = build1_v (GOTO_EXPR, gfc_get_return_label ());\n@@ -414,7 +414,7 @@ gfc_trans_if_1 (gfc_code * code)\n     elsestmt = build_empty_stmt ();\n \n   /* Build the condition expression and add it to the condition block.  */\n-  stmt = build_v (COND_EXPR, if_se.expr, stmt, elsestmt);\n+  stmt = build3_v (COND_EXPR, if_se.expr, stmt, elsestmt);\n   \n   gfc_add_expr_to_block (&if_se.pre, stmt);\n \n@@ -471,13 +471,13 @@ gfc_trans_arithmetic_if (gfc_code * code)\n   branch1 = build1_v (GOTO_EXPR, gfc_get_label_decl (code->label));\n   branch2 = build1_v (GOTO_EXPR, gfc_get_label_decl (code->label2));\n \n-  tmp = build (LT_EXPR, boolean_type_node, se.expr, zero);\n-  branch1 = build_v (COND_EXPR, tmp, branch1, branch2);\n+  tmp = build2 (LT_EXPR, boolean_type_node, se.expr, zero);\n+  branch1 = build3_v (COND_EXPR, tmp, branch1, branch2);\n \n   /* if (cond <= 0) take branch1 else take branch2.  */\n   branch2 = build1_v (GOTO_EXPR, gfc_get_label_decl (code->label3));\n-  tmp = build (LE_EXPR, boolean_type_node, se.expr, zero);\n-  branch1 = build_v (COND_EXPR, tmp, branch1, branch2);\n+  tmp = build2 (LE_EXPR, boolean_type_node, se.expr, zero);\n+  branch1 = build3_v (COND_EXPR, tmp, branch1, branch2);\n \n   /* Append the COND_EXPR to the evaluation of COND, and return.  */\n   gfc_add_expr_to_block (&se.pre, branch1);\n@@ -574,9 +574,9 @@ gfc_trans_do (gfc_code * code)\n   /* Initialise loop count. This code is executed before we enter the\n      loop body. We generate: count = (to + step - from) / step.  */\n \n-  tmp = fold (build (MINUS_EXPR, type, step, from));\n-  tmp = fold (build (PLUS_EXPR, type, to, tmp));\n-  tmp = fold (build (TRUNC_DIV_EXPR, type, tmp, step));\n+  tmp = fold (build2 (MINUS_EXPR, type, step, from));\n+  tmp = fold (build2 (PLUS_EXPR, type, to, tmp));\n+  tmp = fold (build2 (TRUNC_DIV_EXPR, type, tmp, step));\n \n   count = gfc_create_var (type, \"count\");\n   gfc_add_modify_expr (&block, count, tmp);\n@@ -592,10 +592,10 @@ gfc_trans_do (gfc_code * code)\n   exit_label = gfc_build_label_decl (NULL_TREE);\n \n   /* Start with the loop condition.  Loop until count <= 0.  */\n-  cond = build (LE_EXPR, boolean_type_node, count, integer_zero_node);\n+  cond = build2 (LE_EXPR, boolean_type_node, count, integer_zero_node);\n   tmp = build1_v (GOTO_EXPR, exit_label);\n   TREE_USED (exit_label) = 1;\n-  tmp = build_v (COND_EXPR, cond, tmp, build_empty_stmt ());\n+  tmp = build3_v (COND_EXPR, cond, tmp, build_empty_stmt ());\n   gfc_add_expr_to_block (&body, tmp);\n \n   /* Put these labels where they can be found later. We put the\n@@ -617,18 +617,18 @@ gfc_trans_do (gfc_code * code)\n     }\n \n   /* Increment the loop variable.  */\n-  tmp = build (PLUS_EXPR, type, dovar, step);\n+  tmp = build2 (PLUS_EXPR, type, dovar, step);\n   gfc_add_modify_expr (&body, dovar, tmp);\n \n   /* Decrement the loop count.  */\n-  tmp = build (MINUS_EXPR, type, count, gfc_index_one_node);\n+  tmp = build2 (MINUS_EXPR, type, count, gfc_index_one_node);\n   gfc_add_modify_expr (&body, count, tmp);\n \n   /* End of loop body.  */\n   tmp = gfc_finish_block (&body);\n \n   /* The for loop itself.  */\n-  tmp = build_v (LOOP_EXPR, tmp);\n+  tmp = build1_v (LOOP_EXPR, tmp);\n   gfc_add_expr_to_block (&block, tmp);\n \n   /* Add the exit label.  */\n@@ -690,7 +690,7 @@ gfc_trans_do_while (gfc_code * code)\n   /* Build \"IF (! cond) GOTO exit_label\".  */\n   tmp = build1_v (GOTO_EXPR, exit_label);\n   TREE_USED (exit_label) = 1;\n-  tmp = build_v (COND_EXPR, cond.expr, tmp, build_empty_stmt ());\n+  tmp = build3_v (COND_EXPR, cond.expr, tmp, build_empty_stmt ());\n   gfc_add_expr_to_block (&block, tmp);\n \n   /* The main body of the loop.  */\n@@ -709,7 +709,7 @@ gfc_trans_do_while (gfc_code * code)\n \n   gfc_init_block (&block);\n   /* Build the loop.  */\n-  tmp = build_v (LOOP_EXPR, tmp);\n+  tmp = build1_v (LOOP_EXPR, tmp);\n   gfc_add_expr_to_block (&block, tmp);\n \n   /* Add the exit label.  */\n@@ -842,7 +842,7 @@ gfc_trans_integer_select (gfc_code * code)\n \n \t  /* Add this case label.\n              Add parameter 'label', make it match GCC backend.  */\n-\t  tmp = build (CASE_LABEL_EXPR, void_type_node, low, high, label);\n+\t  tmp = build3 (CASE_LABEL_EXPR, void_type_node, low, high, label);\n \t  gfc_add_expr_to_block (&body, tmp);\n \t}\n \n@@ -856,7 +856,7 @@ gfc_trans_integer_select (gfc_code * code)\n     }\n \n   tmp = gfc_finish_block (&body);\n-  tmp = build_v (SWITCH_EXPR, se.expr, tmp, NULL_TREE);\n+  tmp = build3_v (SWITCH_EXPR, se.expr, tmp, NULL_TREE);\n   gfc_add_expr_to_block (&block, tmp);\n \n   tmp = build1_v (LABEL_EXPR, end_label);\n@@ -957,8 +957,8 @@ gfc_trans_logical_select (gfc_code * code)\n       if (f != NULL)\n \tfalse_tree = gfc_trans_code (f->next);\n \n-      gfc_add_expr_to_block (&block, build_v (COND_EXPR, se.expr,\n-\t\t\t\t\t      true_tree, false_tree));\n+      gfc_add_expr_to_block (&block, build3_v (COND_EXPR, se.expr,\n+\t\t\t\t\t       true_tree, false_tree));\n     }\n \n   return gfc_finish_block (&block);\n@@ -1044,14 +1044,14 @@ gfc_trans_character_select (gfc_code *code)\n     {\n       for (d = c->ext.case_list; d; d = d->next)\n         {\n-          tmp = build_v (LABEL_EXPR, labels[d->n]);\n+          tmp = build1_v (LABEL_EXPR, labels[d->n]);\n           gfc_add_expr_to_block (&body, tmp);\n         }\n \n       tmp = gfc_trans_code (c->next);\n       gfc_add_expr_to_block (&body, tmp);\n \n-      tmp = build_v (GOTO_EXPR, end_label);\n+      tmp = build1_v (GOTO_EXPR, end_label);\n       gfc_add_expr_to_block (&body, tmp);\n     }\n \n@@ -1138,7 +1138,7 @@ gfc_trans_character_select (gfc_code *code)\n \n   tmp = gfc_finish_block (&body);\n   gfc_add_expr_to_block (&block, tmp);\n-  tmp = build_v (LABEL_EXPR, end_label);\n+  tmp = build1_v (LABEL_EXPR, end_label);\n   gfc_add_expr_to_block (&block, tmp);\n \n   if (n != 0)\n@@ -1227,16 +1227,16 @@ gfc_trans_forall_loop (forall_info *forall_tmp, int nvar, tree body, int mask_fl\n       gfc_init_block (&block);\n \n       /* The exit condition.  */\n-      cond = build (LE_EXPR, boolean_type_node, count, integer_zero_node);\n+      cond = build2 (LE_EXPR, boolean_type_node, count, integer_zero_node);\n       tmp = build1_v (GOTO_EXPR, exit_label);\n-      tmp = build_v (COND_EXPR, cond, tmp, build_empty_stmt ());\n+      tmp = build3_v (COND_EXPR, cond, tmp, build_empty_stmt ());\n       gfc_add_expr_to_block (&block, tmp);\n \n       /* The main loop body.  */\n       gfc_add_expr_to_block (&block, body);\n \n       /* Increment the loop variable.  */\n-      tmp = build (PLUS_EXPR, TREE_TYPE (var), var, step);\n+      tmp = build2 (PLUS_EXPR, TREE_TYPE (var), var, step);\n       gfc_add_modify_expr (&block, var, tmp);\n \n       /* Advance to the next mask element.  */\n@@ -1246,13 +1246,13 @@ gfc_trans_forall_loop (forall_info *forall_tmp, int nvar, tree body, int mask_fl\n           maskindex = forall_tmp->maskindex;\n           if (mask)\n             {\n-              tmp = build (PLUS_EXPR, gfc_array_index_type,\n-                           maskindex, gfc_index_one_node);\n+              tmp = build2 (PLUS_EXPR, gfc_array_index_type,\n+\t\t\t    maskindex, gfc_index_one_node);\n               gfc_add_modify_expr (&block, maskindex, tmp);\n             }\n         }\n       /* Decrement the loop counter.  */\n-      tmp = build (MINUS_EXPR, TREE_TYPE (var), count, gfc_index_one_node);\n+      tmp = build2 (MINUS_EXPR, TREE_TYPE (var), count, gfc_index_one_node);\n       gfc_add_modify_expr (&block, count, tmp);\n \n       body = gfc_finish_block (&block);\n@@ -1262,13 +1262,13 @@ gfc_trans_forall_loop (forall_info *forall_tmp, int nvar, tree body, int mask_fl\n       gfc_add_modify_expr (&block, var, start);\n \n       /* Initialize the loop counter.  */\n-      tmp = fold (build (MINUS_EXPR, TREE_TYPE (var), step, start));\n-      tmp = fold (build (PLUS_EXPR, TREE_TYPE (var), end, tmp));\n-      tmp = fold (build (TRUNC_DIV_EXPR, TREE_TYPE (var), tmp, step));\n+      tmp = fold (build2 (MINUS_EXPR, TREE_TYPE (var), step, start));\n+      tmp = fold (build2 (PLUS_EXPR, TREE_TYPE (var), end, tmp));\n+      tmp = fold (build2 (TRUNC_DIV_EXPR, TREE_TYPE (var), tmp, step));\n       gfc_add_modify_expr (&block, count, tmp);\n \n       /* The loop expression.  */\n-      tmp = build_v (LOOP_EXPR, body);\n+      tmp = build1_v (LOOP_EXPR, body);\n       gfc_add_expr_to_block (&block, tmp);\n \n       /* The exit label.  */\n@@ -1321,7 +1321,7 @@ gfc_trans_nested_forall_loop (forall_info * nested_forall_info, tree body,\n                     tmp = mask;\n                   tmp = gfc_build_array_ref (tmp, maskindex);\n \n-                  body = build_v (COND_EXPR, tmp, body, build_empty_stmt ());\n+                  body = build3_v (COND_EXPR, tmp, body, build_empty_stmt ());\n                 }\n             }\n           nvar = forall_tmp->nvar;\n@@ -1353,8 +1353,8 @@ gfc_do_allocate (tree bytesize, tree size, tree * pdata, stmtblock_t * pblock,\n \n   if (INTEGER_CST_P (size))\n     {\n-      tmp = fold (build (MINUS_EXPR, gfc_array_index_type, size,\n-\t\t\t gfc_index_one_node));\n+      tmp = fold (build2 (MINUS_EXPR, gfc_array_index_type, size,\n+\t\t\t  gfc_index_one_node));\n     }\n   else\n     tmp = NULL_TREE;\n@@ -1422,7 +1422,7 @@ generate_loop_for_temp_to_lhs (gfc_expr *expr, tree tmp1, tree size,\n       gfc_add_block_to_block (&block, &lse.post);\n \n       /* Increment the count1.  */\n-      tmp = fold (build (PLUS_EXPR, TREE_TYPE (count1), count1, size));\n+      tmp = fold (build2 (PLUS_EXPR, TREE_TYPE (count1), count1, size));\n       gfc_add_modify_expr (&block, count1, tmp);\n       tmp = gfc_finish_block (&block);\n     }\n@@ -1456,8 +1456,8 @@ generate_loop_for_temp_to_lhs (gfc_expr *expr, tree tmp1, tree size,\n       /* Form the expression of the temporary.  */\n       if (lss != gfc_ss_terminator)\n         {\n-          index = fold (build (PLUS_EXPR, gfc_array_index_type,\n-\t\t\t       count1, count2));\n+          index = fold (build2 (PLUS_EXPR, gfc_array_index_type,\n+\t\t\t\tcount1, count2));\n           rse.expr = gfc_build_array_ref (tmp1, index);\n         }\n       /* Translate expr.  */\n@@ -1476,25 +1476,25 @@ generate_loop_for_temp_to_lhs (gfc_expr *expr, tree tmp1, tree size,\n          while (tmp2)\n            {\n              tmp1 = gfc_build_array_ref (tmp2, count3);\n-             wheremaskexpr = build (TRUTH_AND_EXPR, TREE_TYPE (tmp1),\n-                                    wheremaskexpr, tmp1);\n+             wheremaskexpr = build2 (TRUTH_AND_EXPR, TREE_TYPE (tmp1),\n+\t\t\t\t     wheremaskexpr, tmp1);\n              tmp2 = TREE_CHAIN (tmp2);\n            }\n-         tmp = build_v (COND_EXPR, wheremaskexpr, tmp, build_empty_stmt ());\n+         tmp = build3_v (COND_EXPR, wheremaskexpr, tmp, build_empty_stmt ());\n        }\n \n       gfc_add_expr_to_block (&body, tmp);\n \n       /* Increment count2.  */\n-      tmp = fold (build (PLUS_EXPR, gfc_array_index_type,\n-\t\t\t count2, gfc_index_one_node));\n+      tmp = fold (build2 (PLUS_EXPR, gfc_array_index_type,\n+\t\t\t  count2, gfc_index_one_node));\n       gfc_add_modify_expr (&body, count2, tmp);\n \n       /* Increment count3.  */\n       if (count3)\n         {\n-          tmp = fold (build (PLUS_EXPR, gfc_array_index_type,\n-                             count3, gfc_index_one_node));\n+          tmp = fold (build2 (PLUS_EXPR, gfc_array_index_type,\n+\t\t\t      count3, gfc_index_one_node));\n           gfc_add_modify_expr (&body, count3, tmp);\n         }\n \n@@ -1505,7 +1505,7 @@ generate_loop_for_temp_to_lhs (gfc_expr *expr, tree tmp1, tree size,\n       gfc_cleanup_loop (&loop1);\n \n       /* Increment count1.  */\n-      tmp = fold (build (PLUS_EXPR, TREE_TYPE (count1), count1, size));\n+      tmp = fold (build2 (PLUS_EXPR, TREE_TYPE (count1), count1, size));\n       gfc_add_modify_expr (&block, count1, tmp);\n       tmp = gfc_finish_block (&block);\n     }\n@@ -1565,7 +1565,7 @@ generate_loop_for_rhs_to_temp (gfc_expr *expr2, tree tmp1, tree size,\n       gfc_conv_expr (&rse, expr2);\n \n       /* Form the expression of the temporary.  */\n-      index = fold (build (PLUS_EXPR, gfc_array_index_type, count1, count2));\n+      index = fold (build2 (PLUS_EXPR, gfc_array_index_type, count1, count2));\n       lse.expr = gfc_build_array_ref (tmp1, index);\n     }\n \n@@ -1582,11 +1582,11 @@ generate_loop_for_rhs_to_temp (gfc_expr *expr2, tree tmp1, tree size,\n       while (tmp2)\n         {\n           tmp1 = gfc_build_array_ref (tmp2, count3);\n-          wheremaskexpr = build (TRUTH_AND_EXPR, TREE_TYPE (tmp1),\n-                                 wheremaskexpr, tmp1);\n+          wheremaskexpr = build2 (TRUTH_AND_EXPR, TREE_TYPE (tmp1),\n+\t\t\t\t  wheremaskexpr, tmp1);\n           tmp2 = TREE_CHAIN (tmp2);\n         }\n-      tmp = build_v (COND_EXPR, wheremaskexpr, tmp, build_empty_stmt ());\n+      tmp = build3_v (COND_EXPR, wheremaskexpr, tmp, build_empty_stmt ());\n     }\n \n   gfc_add_expr_to_block (&body1, tmp);\n@@ -1598,15 +1598,15 @@ generate_loop_for_rhs_to_temp (gfc_expr *expr2, tree tmp1, tree size,\n   else\n     {\n       /* Increment count2.  */\n-      tmp = fold (build (PLUS_EXPR, gfc_array_index_type,\n-\t\t\t count2, gfc_index_one_node));\n+      tmp = fold (build2 (PLUS_EXPR, gfc_array_index_type,\n+\t\t\t  count2, gfc_index_one_node));\n       gfc_add_modify_expr (&body1, count2, tmp);\n \n       /* Increment count3.  */\n       if (count3)\n         {\n-          tmp = fold (build (PLUS_EXPR, gfc_array_index_type,\n-                             count3, gfc_index_one_node));\n+          tmp = fold (build2 (PLUS_EXPR, gfc_array_index_type,\n+\t\t\t      count3, gfc_index_one_node));\n           gfc_add_modify_expr (&body1, count3, tmp);\n         }\n \n@@ -1621,7 +1621,7 @@ generate_loop_for_rhs_to_temp (gfc_expr *expr2, tree tmp1, tree size,\n          as tree nodes in SS may not be valid in different scope.  */\n     }\n   /* Increment count1.  */\n-  tmp = fold (build (PLUS_EXPR, TREE_TYPE (count1), count1, size));\n+  tmp = fold (build2 (PLUS_EXPR, TREE_TYPE (count1), count1, size));\n   gfc_add_modify_expr (&block, count1, tmp);\n \n   tmp = gfc_finish_block (&block);\n@@ -1678,11 +1678,11 @@ compute_inner_temp_size (gfc_expr *expr1, gfc_expr *expr2,\n       /* Figure out how many elements we need.  */\n       for (i = 0; i < loop.dimen; i++)\n         {\n-\t  tmp = fold (build (MINUS_EXPR, gfc_array_index_type,\n-\t\t\t     gfc_index_one_node, loop.from[i]));\n-          tmp = fold (build (PLUS_EXPR, gfc_array_index_type,\n-\t\t\t     tmp, loop.to[i]));\n-          size = fold (build (MULT_EXPR, gfc_array_index_type, size, tmp));\n+\t  tmp = fold (build2 (MINUS_EXPR, gfc_array_index_type,\n+\t\t\t      gfc_index_one_node, loop.from[i]));\n+          tmp = fold (build2 (PLUS_EXPR, gfc_array_index_type,\n+\t\t\t      tmp, loop.to[i]));\n+          size = fold (build2 (MULT_EXPR, gfc_array_index_type, size, tmp));\n         }\n       gfc_add_block_to_block (pblock, &loop.pre);\n       size = gfc_evaluate_now (size, pblock);\n@@ -1711,8 +1711,8 @@ compute_overall_iter_number (forall_info *nested_forall_info, tree inner_size,\n \n   gfc_start_block (&body);\n   if (nested_forall_info)\n-    tmp = build (PLUS_EXPR, gfc_array_index_type, number,\n-                 inner_size);\n+    tmp = build2 (PLUS_EXPR, gfc_array_index_type, number,\n+\t\t  inner_size);\n   else\n     tmp = inner_size;\n   gfc_add_modify_expr (&body, number, tmp);\n@@ -1746,7 +1746,7 @@ allocate_temp_for_forall_nest (forall_info * nested_forall_info, tree type,\n   size = compute_overall_iter_number (nested_forall_info, inner_size, block);\n \n   unit = TYPE_SIZE_UNIT (type);\n-  bytesize = fold (build (MULT_EXPR, gfc_array_index_type, size, unit));\n+  bytesize = fold (build2 (MULT_EXPR, gfc_array_index_type, size, unit));\n \n   *ptemp1 = NULL;\n   temp1 = gfc_do_allocate (bytesize, size, ptemp1, block, type);\n@@ -1911,8 +1911,8 @@ gfc_trans_pointer_assign_need_temp (gfc_expr * expr1, gfc_expr * expr2,\n       gfc_add_block_to_block (&body, &rse.post);\n \n       /* Increment count.  */\n-      tmp = fold (build (PLUS_EXPR, gfc_array_index_type,\n-                         count, gfc_index_one_node));\n+      tmp = fold (build2 (PLUS_EXPR, gfc_array_index_type,\n+\t\t\t  count, gfc_index_one_node));\n       gfc_add_modify_expr (&body, count, tmp);\n \n       tmp = gfc_finish_block (&body);\n@@ -1956,8 +1956,8 @@ gfc_trans_pointer_assign_need_temp (gfc_expr * expr1, gfc_expr * expr2,\n       gfc_add_modify_expr (&body, lse.expr, rse.expr);\n       gfc_add_block_to_block (&body, &lse.post);\n       /* Increment count.  */\n-      tmp = fold (build (PLUS_EXPR, gfc_array_index_type,\n-                         count, gfc_index_one_node));\n+      tmp = fold (build2 (PLUS_EXPR, gfc_array_index_type,\n+\t\t\t  count, gfc_index_one_node));\n       gfc_add_modify_expr (&body, count, tmp);\n       tmp = gfc_finish_block (&body);\n \n@@ -2000,8 +2000,8 @@ gfc_trans_pointer_assign_need_temp (gfc_expr * expr1, gfc_expr * expr2,\n       gfc_add_block_to_block (&body, &lse.post);\n \n       /* Increment count.  */\n-      tmp = fold (build (PLUS_EXPR, gfc_array_index_type,\n-                         count, gfc_index_one_node));\n+      tmp = fold (build2 (PLUS_EXPR, gfc_array_index_type,\n+\t\t\t  count, gfc_index_one_node));\n       gfc_add_modify_expr (&body, count, tmp);\n \n       tmp = gfc_finish_block (&body);\n@@ -2045,8 +2045,8 @@ gfc_trans_pointer_assign_need_temp (gfc_expr * expr1, gfc_expr * expr2,\n       gfc_add_block_to_block (&body, &lse.post);\n \n       /* Increment count.  */\n-      tmp = fold (build (PLUS_EXPR, gfc_array_index_type,\n-                         count, gfc_index_one_node));\n+      tmp = fold (build2 (PLUS_EXPR, gfc_array_index_type,\n+\t\t\t  count, gfc_index_one_node));\n       gfc_add_modify_expr (&body, count, tmp);\n \n       tmp = gfc_finish_block (&body);\n@@ -2223,13 +2223,14 @@ gfc_trans_forall_1 (gfc_code * code, forall_info * nested_forall_info)\n \tlenvar = NULL_TREE;\n \n       /* size = (end + step - start) / step.  */\n-      tmp = fold (build (MINUS_EXPR, TREE_TYPE (start[n]), step[n], start[n]));\n-      tmp = fold (build (PLUS_EXPR, TREE_TYPE (end[n]), end[n], tmp));\n+      tmp = fold (build2 (MINUS_EXPR, TREE_TYPE (start[n]), \n+\t\t\t  step[n], start[n]));\n+      tmp = fold (build2 (PLUS_EXPR, TREE_TYPE (end[n]), end[n], tmp));\n \n-      tmp = fold (build (FLOOR_DIV_EXPR, TREE_TYPE (tmp), tmp, step[n]));\n+      tmp = fold (build2 (FLOOR_DIV_EXPR, TREE_TYPE (tmp), tmp, step[n]));\n       tmp = convert (gfc_array_index_type, tmp);\n \n-      size = fold (build (MULT_EXPR, gfc_array_index_type, size, tmp));\n+      size = fold (build2 (MULT_EXPR, gfc_array_index_type, size, tmp));\n     }\n \n   /* Record the nvar and size of current forall level.  */\n@@ -2253,8 +2254,8 @@ gfc_trans_forall_1 (gfc_code * code, forall_info * nested_forall_info)\n   if (code->expr)\n     {\n       /* Allocate the mask temporary.  */\n-      bytesize = fold (build (MULT_EXPR, gfc_array_index_type, size,\n-\t\t\t      TYPE_SIZE_UNIT (boolean_type_node)));\n+      bytesize = fold (build2 (MULT_EXPR, gfc_array_index_type, size,\n+\t\t\t       TYPE_SIZE_UNIT (boolean_type_node)));\n \n       mask = gfc_do_allocate (bytesize, size, &pmask, &block, boolean_type_node);\n \n@@ -2285,7 +2286,7 @@ gfc_trans_forall_1 (gfc_code * code, forall_info * nested_forall_info)\n       gfc_add_modify_expr (&body, tmp, se.expr);\n \n       /* Advance to the next mask element.  */\n-      tmp = build (PLUS_EXPR, gfc_array_index_type,\n+      tmp = build2 (PLUS_EXPR, gfc_array_index_type,\n \t\t   maskindex, gfc_index_one_node);\n       gfc_add_modify_expr (&body, maskindex, tmp);\n \n@@ -2536,7 +2537,7 @@ gfc_evaluate_where_mask (gfc_expr * me, forall_info * nested_forall_info,\n   else\n     {\n       /* Increment count.  */\n-      tmp1 = fold (build (PLUS_EXPR, gfc_array_index_type, count,\n+      tmp1 = fold (build2 (PLUS_EXPR, gfc_array_index_type, count,\n                           gfc_index_one_node));\n       gfc_add_modify_expr (&body1, count, tmp1);\n \n@@ -2691,20 +2692,20 @@ gfc_trans_where_assign (gfc_expr *expr1, gfc_expr *expr2, tree mask,\n   while (tmp)\n     {\n       tmp1 = gfc_build_array_ref (tmp, index);\n-      maskexpr = build (TRUTH_AND_EXPR, TREE_TYPE (tmp1), maskexpr, tmp1);\n+      maskexpr = build2 (TRUTH_AND_EXPR, TREE_TYPE (tmp1), maskexpr, tmp1);\n       tmp = TREE_CHAIN (tmp);\n     }\n   /* Use the scalar assignment as is.  */\n   tmp = gfc_trans_scalar_assign (&lse, &rse, expr1->ts.type);\n-  tmp = build_v (COND_EXPR, maskexpr, tmp, build_empty_stmt ());\n+  tmp = build3_v (COND_EXPR, maskexpr, tmp, build_empty_stmt ());\n \n   gfc_add_expr_to_block (&body, tmp);\n \n   if (lss == gfc_ss_terminator)\n     {\n       /* Increment count1.  */\n-      tmp = fold (build (PLUS_EXPR, gfc_array_index_type,\n-                         count1, gfc_index_one_node));\n+      tmp = fold (build2 (PLUS_EXPR, gfc_array_index_type,\n+\t\t\t  count1, gfc_index_one_node));\n       gfc_add_modify_expr (&body, count1, tmp);\n \n       /* Use the scalar assignment as is.  */\n@@ -2721,8 +2722,8 @@ gfc_trans_where_assign (gfc_expr *expr1, gfc_expr *expr2, tree mask,\n         {\n           /* Increment count1 before finish the main body of a scalarized\n              expression.  */\n-          tmp = fold (build (PLUS_EXPR, gfc_array_index_type,\n-                             count1, gfc_index_one_node));\n+          tmp = fold (build2 (PLUS_EXPR, gfc_array_index_type,\n+\t\t\t      count1, gfc_index_one_node));\n           gfc_add_modify_expr (&body, count1, tmp);\n           gfc_trans_scalarized_loop_boundary (&loop, &body);\n \n@@ -2757,25 +2758,25 @@ gfc_trans_where_assign (gfc_expr *expr1, gfc_expr *expr2, tree mask,\n           while (tmp)\n             {\n               tmp1 = gfc_build_array_ref (tmp, index);\n-              maskexpr = build (TRUTH_AND_EXPR, TREE_TYPE (tmp1), maskexpr,\n-                                tmp1);\n+              maskexpr = build2 (TRUTH_AND_EXPR, TREE_TYPE (tmp1),\n+\t\t\t\t maskexpr, tmp1);\n               tmp = TREE_CHAIN (tmp);\n             }\n           /* Use the scalar assignment as is.  */\n           tmp = gfc_trans_scalar_assign (&lse, &rse, expr1->ts.type);\n-          tmp = build_v (COND_EXPR, maskexpr, tmp, build_empty_stmt ());\n+          tmp = build3_v (COND_EXPR, maskexpr, tmp, build_empty_stmt ());\n           gfc_add_expr_to_block (&body, tmp);\n \n           /* Increment count2.  */\n-          tmp = fold (build (PLUS_EXPR, gfc_array_index_type,\n-                             count2, gfc_index_one_node));\n+          tmp = fold (build2 (PLUS_EXPR, gfc_array_index_type,\n+\t\t\t      count2, gfc_index_one_node));\n           gfc_add_modify_expr (&body, count2, tmp);\n         }\n       else\n         {\n           /* Increment count1.  */\n-          tmp = fold (build (PLUS_EXPR, gfc_array_index_type,\n-                             count1, gfc_index_one_node));\n+          tmp = fold (build2 (PLUS_EXPR, gfc_array_index_type,\n+\t\t\t      count1, gfc_index_one_node));\n           gfc_add_modify_expr (&body, count1, tmp);\n         }\n \n@@ -3073,8 +3074,8 @@ gfc_trans_allocate (gfc_code * code)\n \t    {\n \t      tmp = build1_v (GOTO_EXPR, error_label);\n \t      parm =\n-\t\tbuild (NE_EXPR, boolean_type_node, stat, integer_zero_node);\n-\t      tmp = build_v (COND_EXPR, parm, tmp, build_empty_stmt ());\n+\t\tbuild2 (NE_EXPR, boolean_type_node, stat, integer_zero_node);\n+\t      tmp = build3_v (COND_EXPR, parm, tmp, build_empty_stmt ());\n \t      gfc_add_expr_to_block (&se.pre, tmp);\n \t    }\n \t}"}, {"sha": "6fdb84a26453d5fb0781e9025c6e614ca70848cb", "filename": "gcc/fortran/trans-types.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/923ab88cb2f07d36569c71cf53f8a0529ca1c2d4/gcc%2Ffortran%2Ftrans-types.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/923ab88cb2f07d36569c71cf53f8a0529ca1c2d4/gcc%2Ffortran%2Ftrans-types.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-types.c?ref=923ab88cb2f07d36569c71cf53f8a0529ca1c2d4", "patch": "@@ -603,8 +603,8 @@ gfc_get_dtype (tree type, int rank)\n   if (size && !INTEGER_CST_P (size))\n     {\n       tmp = build_int_cst (gfc_array_index_type, GFC_DTYPE_SIZE_SHIFT);\n-      tmp  = fold (build (LSHIFT_EXPR, gfc_array_index_type, size, tmp));\n-      dtype = fold (build (PLUS_EXPR, gfc_array_index_type, tmp, dtype));\n+      tmp  = fold (build2 (LSHIFT_EXPR, gfc_array_index_type, size, tmp));\n+      dtype = fold (build2 (PLUS_EXPR, gfc_array_index_type, tmp, dtype));\n     }\n   /* If we don't know the size we leave it as zero.  This should never happen\n      for anything that is actually used.  */\n@@ -836,11 +836,11 @@ gfc_get_array_type_bounds (tree etype, int dimen, tree * lbound,\n \n       if (upper != NULL_TREE && lower != NULL_TREE && stride != NULL_TREE)\n \t{\n-\t  tmp = fold (build (MINUS_EXPR, gfc_array_index_type, upper, lower));\n-\t  tmp = fold (build (PLUS_EXPR, gfc_array_index_type, tmp,\n-\t\t\t     gfc_index_one_node));\n+\t  tmp = fold (build2 (MINUS_EXPR, gfc_array_index_type, upper, lower));\n+\t  tmp = fold (build2 (PLUS_EXPR, gfc_array_index_type, tmp,\n+\t\t\t      gfc_index_one_node));\n \t  stride =\n-\t    fold (build (MULT_EXPR, gfc_array_index_type, tmp, stride));\n+\t    fold (build2 (MULT_EXPR, gfc_array_index_type, tmp, stride));\n \t  /* Check the folding worked.  */\n \t  assert (INTEGER_CST_P (stride));\n \t}"}, {"sha": "74bab19735b2e84f7897ddc18027a64c33d42c6a", "filename": "gcc/fortran/trans.c", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/923ab88cb2f07d36569c71cf53f8a0529ca1c2d4/gcc%2Ffortran%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/923ab88cb2f07d36569c71cf53f8a0529ca1c2d4/gcc%2Ffortran%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.c?ref=923ab88cb2f07d36569c71cf53f8a0529ca1c2d4", "patch": "@@ -156,7 +156,7 @@ gfc_add_modify_expr (stmtblock_t * pblock, tree lhs, tree rhs)\n     abort ();\n #endif\n \n-  tmp = fold (build_v (MODIFY_EXPR, lhs, rhs));\n+  tmp = fold (build2_v (MODIFY_EXPR, lhs, rhs));\n   gfc_add_expr_to_block (pblock, tmp);\n }\n \n@@ -238,7 +238,7 @@ gfc_finish_block (stmtblock_t * stmtblock)\n       if (decl)\n \t{\n \t  block = poplevel (1, 0, 0);\n-\t  expr = build_v (BIND_EXPR, decl, expr, block);\n+\t  expr = build3_v (BIND_EXPR, decl, expr, block);\n \t}\n       else\n \tpoplevel (0, 0, 0);\n@@ -316,7 +316,7 @@ gfc_build_array_ref (tree base, tree offset)\n   if (DECL_P (base))\n     TREE_ADDRESSABLE (base) = 1;\n \n-  return build (ARRAY_REF, type, base, offset, NULL_TREE, NULL_TREE);\n+  return build4 (ARRAY_REF, type, base, offset, NULL_TREE, NULL_TREE);\n }\n \n \n@@ -330,7 +330,8 @@ gfc_build_function_call (tree fndecl, tree arglist)\n   tree call;\n \n   fn = gfc_build_addr_expr (NULL, fndecl);\n-  call = build (CALL_EXPR, TREE_TYPE (TREE_TYPE (fndecl)), fn, arglist, NULL);\n+  call = build3 (CALL_EXPR, TREE_TYPE (TREE_TYPE (fndecl)), \n+\t\t fn, arglist, NULL);\n   TREE_SIDE_EFFECTS (call) = 1;\n \n   return call;\n@@ -384,7 +385,7 @@ gfc_trans_runtime_check (tree cond, tree msg, stmtblock_t * pblock)\n       tmp = gfc_chainon_list (tmp, integer_zero_node);\n       cond = gfc_build_function_call (built_in_decls[BUILT_IN_EXPECT], tmp);\n \n-      tmp = build_v (COND_EXPR, cond, body, build_empty_stmt ());\n+      tmp = build3_v (COND_EXPR, cond, body, build_empty_stmt ());\n       gfc_add_expr_to_block (pblock, tmp);\n     }\n }"}, {"sha": "b9b467bb33fa73ab2ceed04e36bcf2167b564b52", "filename": "gcc/fortran/trans.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/923ab88cb2f07d36569c71cf53f8a0529ca1c2d4/gcc%2Ffortran%2Ftrans.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/923ab88cb2f07d36569c71cf53f8a0529ca1c2d4/gcc%2Ffortran%2Ftrans.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.h?ref=923ab88cb2f07d36569c71cf53f8a0529ca1c2d4", "patch": "@@ -557,7 +557,10 @@ struct lang_decl\t\tGTY(())\n \n /* Build an expression with void type.  */\n #define build1_v(code, arg) build(code, void_type_node, arg)\n-#define build_v(code, args...) build(code, void_type_node, args)\n+#define build2_v(code, arg1, arg2) build2(code, void_type_node, \\\n+                                          arg1, arg2)\n+#define build3_v(code, arg1, arg2, arg3) build3(code, void_type_node, \\\n+                                                arg1, arg2, arg3)\n \n /* flag for alternative return labels.  */\n extern int has_alternate_specifier;  /* for caller */"}]}