{"sha": "ca9fef16af6d5678e16a3165f7d54ad3fa26c58b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2E5ZmVmMTZhZjZkNTY3OGUxNmEzMTY1ZjdkNTRhZDNmYTI2YzU4Yg==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2001-07-24T23:42:40Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2001-07-24T23:42:40Z"}, "message": "flow.c (try_simplify_condjump): Avoid duplicated edges.\n\n\t* flow.c (try_simplify_condjump): Avoid duplicated edges.\n\t(verify_flow_info): Check for duplicated edges; clarify\n\terror reporting.\n\n\t* flow.c (block_label): Update basic_block_for_insn.\n\t(commit_edge_insertions): Call compute_bb_for_insn.\n\n\t* flow.c (purge_dead_edges): Handle conditional jumps and conditional\n\treturns too.\n\n\t* flow.c (redirect_edge_and_branch,\n\ttry_optimize_cfg): Use redirect_edge_succ_nodup\n\t(redirect_edge_succ_nodup): New.\n\t* basic_block.h (redirect_edge_succ_nodup): Declare.\n\n\t* toplev.c (rest_of_compilation): Rebuild CFG before cfg_cleanup\n\tafter gcse.\n\nFrom-SVN: r44320", "tree": {"sha": "d1ee1391800621b2b6ec28beb4ce0ea486728f56", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d1ee1391800621b2b6ec28beb4ce0ea486728f56"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ca9fef16af6d5678e16a3165f7d54ad3fa26c58b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca9fef16af6d5678e16a3165f7d54ad3fa26c58b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ca9fef16af6d5678e16a3165f7d54ad3fa26c58b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca9fef16af6d5678e16a3165f7d54ad3fa26c58b/comments", "author": null, "committer": null, "parents": [{"sha": "40fc4e6a9ff481ac5f01a89bd924bf30ad305b78", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/40fc4e6a9ff481ac5f01a89bd924bf30ad305b78", "html_url": "https://github.com/Rust-GCC/gccrs/commit/40fc4e6a9ff481ac5f01a89bd924bf30ad305b78"}], "stats": {"total": 145, "additions": 113, "deletions": 32}, "files": [{"sha": "010e14cddefdd23f5c0339af4d47fe8318ea6f8c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca9fef16af6d5678e16a3165f7d54ad3fa26c58b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca9fef16af6d5678e16a3165f7d54ad3fa26c58b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ca9fef16af6d5678e16a3165f7d54ad3fa26c58b", "patch": "@@ -1,3 +1,23 @@\n+Wed Jul 25 01:41:27 CEST 2001  Jan Hubicka  <jh@suse.cz>\n+\n+\t* flow.c (try_simplify_condjump): Avoid duplicated edges.\n+\t(verify_flow_info): Check for duplicated edges; clarify\n+\terror reporting.\n+\n+\t* flow.c (block_label): Update basic_block_for_insn.\n+\t(commit_edge_insertions): Call compute_bb_for_insn.\n+\n+\t* flow.c (purge_dead_edges): Handle conditional jumps and conditional\n+\treturns too.\n+\n+\t* flow.c (redirect_edge_and_branch,\n+\ttry_optimize_cfg): Use redirect_edge_succ_nodup\n+\t(redirect_edge_succ_nodup): New.\n+\t* basic_block.h (redirect_edge_succ_nodup): Declare.\n+\n+\t* toplev.c (rest_of_compilation): Rebuild CFG before cfg_cleanup\n+\tafter gcse.\n+\n Wed Jul 25 00:32:49 CEST 2001  Jan Hubicka  <jh@suse.cz>\n \n \t* flow.c (try_forward_edges): Accept fallthru edge; Update comment."}, {"sha": "c069ad57edd5857f6586e098775dcb4d9428253b", "filename": "gcc/basic-block.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca9fef16af6d5678e16a3165f7d54ad3fa26c58b/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca9fef16af6d5678e16a3165f7d54ad3fa26c58b/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=ca9fef16af6d5678e16a3165f7d54ad3fa26c58b", "patch": "@@ -296,6 +296,7 @@ extern void make_edge\t\t\tPARAMS ((sbitmap *, basic_block,\n \t\t\t\t\t\t basic_block, int));\n extern void remove_edge\t\t\tPARAMS ((edge));\n extern void redirect_edge_succ\t\tPARAMS ((edge, basic_block));\n+extern void redirect_edge_succ_nodup\tPARAMS ((edge, basic_block));\n extern void redirect_edge_pred\t\tPARAMS ((edge, basic_block));\n extern void create_basic_block\t\tPARAMS ((int, rtx, rtx, rtx));\n extern int flow_delete_block\t\tPARAMS ((basic_block));"}, {"sha": "733eae047bc472adaa867c4d52f9884bd6ac20f3", "filename": "gcc/flow.c", "status": "modified", "additions": 90, "deletions": 32, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca9fef16af6d5678e16a3165f7d54ad3fa26c58b/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca9fef16af6d5678e16a3165f7d54ad3fa26c58b/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=ca9fef16af6d5678e16a3165f7d54ad3fa26c58b", "patch": "@@ -1592,7 +1592,11 @@ block_label (block)\n   if (block == EXIT_BLOCK_PTR)\n     return NULL_RTX;\n   if (GET_CODE (block->head) != CODE_LABEL)\n-    block->head = emit_label_before (gen_label_rtx (), block->head);\n+    {\n+      block->head = emit_label_before (gen_label_rtx (), block->head);\n+      if (basic_block_for_insn)\n+\tset_block_for_insn (block->head, block);\n+    }\n   return block->head;\n }\n \n@@ -1834,22 +1838,7 @@ redirect_edge_and_branch (e, target)\n     fprintf (rtl_dump_file, \"Edge %i->%i redirected to %i\\n\",\n \t     e->src->index, e->dest->index, target->index);\n   if (e->dest != target)\n-    {\n-      edge s;\n-      /* Check whether the edge is already present.  */\n-      for (s = src->succ; s; s=s->succ_next)\n-\tif (s->dest == target)\n-\t  break;\n-      if (s)\n-\t{\n-\t  s->flags |= e->flags;\n-\t  s->probability += e->probability;\n-\t  s->count += e->count;\n-\t  remove_edge (e);\n-\t}\n-      else\n-\tredirect_edge_succ (e, target);\n-    }\n+    redirect_edge_succ_nodup (e, target);\n   return true;\n }\n \n@@ -2293,6 +2282,7 @@ commit_edge_insertions ()\n {\n   int i;\n   basic_block bb;\n+  compute_bb_for_insn (get_max_uid ());\n \n #ifdef ENABLE_CHECKING\n   verify_flow_info ();\n@@ -3076,8 +3066,8 @@ try_simplify_condjump (cbranch_block)\n   /* Success.  Update the CFG to match.  Note that after this point\n      the edge variable names appear backwards; the redirection is done\n      this way to preserve edge profile data.  */\n-  redirect_edge_succ (cbranch_jump_edge, cbranch_dest_block);\n-  redirect_edge_succ (cbranch_fallthru_edge, jump_dest_block);\n+  redirect_edge_succ_nodup (cbranch_jump_edge, cbranch_dest_block);\n+  redirect_edge_succ_nodup (cbranch_fallthru_edge, jump_dest_block);\n   cbranch_jump_edge->flags |= EDGE_FALLTHRU;\n   cbranch_fallthru_edge->flags &= ~EDGE_FALLTHRU;\n   \n@@ -3820,7 +3810,7 @@ try_optimize_cfg (mode)\n \t\tfprintf (rtl_dump_file, \"Deleting fallthru block %i.\\n\",\n \t\t\t b->index);\n \t      c = BASIC_BLOCK (b->index ? b->index - 1 : 1);\n-\t      redirect_edge_succ (b->pred, b->succ->dest);\n+\t      redirect_edge_succ_nodup (b->pred, b->succ->dest);\n \t      flow_delete_block (b);\n \t      changed = true;\n \t      b = c;\n@@ -7979,11 +7969,13 @@ verify_flow_info ()\n   const int max_uid = get_max_uid ();\n   const rtx rtx_first = get_insns ();\n   rtx last_head = get_last_insn ();\n-  basic_block *bb_info;\n+  basic_block *bb_info, *last_visited;\n   rtx x;\n   int i, last_bb_num_seen, num_bb_notes, err = 0;\n \n   bb_info = (basic_block *) xcalloc (max_uid, sizeof (basic_block));\n+  last_visited = (basic_block *) xcalloc (n_basic_blocks + 2,\n+\t\t\t\t\t  sizeof (basic_block));\n \n   for (i = n_basic_blocks - 1; i >= 0; i--)\n     {\n@@ -8040,6 +8032,14 @@ verify_flow_info ()\n       e = bb->succ;\n       while (e)\n \t{\n+\t  if (last_visited [e->dest->index + 2] == bb)\n+\t    {\n+\t      error (\"verify_flow_info: Duplicate edge %i->%i\",\n+\t\t     e->src->index, e->dest->index);\n+\t      err = 1;\n+\t    }\n+\t  last_visited [e->dest->index + 2] = bb;\n+\n \t  if ((e->flags & EDGE_FALLTHRU)\n \t      && e->src != ENTRY_BLOCK_PTR\n \t      && e->dest != EXIT_BLOCK_PTR\n@@ -8166,8 +8166,7 @@ verify_flow_info ()\n \t  basic_block bb = NOTE_BASIC_BLOCK (x);\n \t  num_bb_notes++;\n \t  if (bb->index != last_bb_num_seen + 1)\n-\t    /* Basic blocks not numbered consecutively.  */\n-\t    abort ();\n+\t    internal_error (\"Basic blocks not numbered consecutively.\");\n \t       \n \t  last_bb_num_seen = bb->index;\n \t}\n@@ -8213,10 +8212,11 @@ verify_flow_info ()\n        num_bb_notes, n_basic_blocks);\n \n   if (err)\n-    abort ();\n+    internal_error (\"verify_flow_info failed.\");\n \n   /* Clean up.  */\n   free (bb_info);\n+  free (last_visited);\n }\n \f\n /* Functions to access an edge list with a vector representation.\n@@ -8629,6 +8629,29 @@ redirect_edge_succ (e, new_succ)\n   e->dest = new_succ;\n }\n \n+/* Like previous but avoid possible dupplicate edge.  */\n+\n+void\n+redirect_edge_succ_nodup (e, new_succ)\n+     edge e;\n+     basic_block new_succ;\n+{\n+  edge s;\n+  /* Check whether the edge is already present.  */\n+  for (s = e->src->succ; s; s = s->succ_next)\n+    if (s->dest == new_succ && s != e)\n+      break;\n+  if (s)\n+    {\n+      s->flags |= e->flags;\n+      s->probability += e->probability;\n+      s->count += e->count;\n+      remove_edge (e);\n+    }\n+  else\n+    redirect_edge_succ (e, new_succ);\n+}\n+\n /* Redirect an edge's predecessor from one block to another.  */\n \n void\n@@ -9794,21 +9817,56 @@ purge_dead_edges (bb)\n     return;\n   if (GET_CODE (insn) == JUMP_INSN)\n     {\n+      int removed = 0;\n+      rtx note;\n+      edge b,f;\n+      /* We do care only about conditional jumps and simplejumps.  */\n+      if (!any_condjump_p (insn)\n+\t  && !returnjump_p (insn)\n+\t  && !simplejump_p (insn))\n+\treturn;\n       for (e = bb->succ; e; e = next)\n \t{\n \t  next = e->succ_next;\n-\t  if (e->dest == EXIT_BLOCK_PTR || e->dest->head != JUMP_LABEL (insn))\n-\t    remove_edge (e);\n+\n+\t  /* Check purposes we can have edge.  */\n+\t  if ((e->flags & EDGE_FALLTHRU)\n+\t      && any_condjump_p (insn))\n+\t    continue;\n+\t  if (e->dest != EXIT_BLOCK_PTR\n+\t      && e->dest->head == JUMP_LABEL (insn))\n+\t    continue;\n+\t  if (e->dest == EXIT_BLOCK_PTR\n+\t      && returnjump_p (insn))\n+\t    continue;\n+\t  removed = 1;\n+\t  remove_edge (e);\n \t}\n-      if (bb->succ && bb->succ->succ_next)\n-\tabort ();\n-      if (!bb->succ)\n+      if (!bb->succ || !removed)\n \treturn;\n-      bb->succ->probability = REG_BR_PROB_BASE;\n-      bb->succ->count = bb->count;\n-\n       if (rtl_dump_file)\n \tfprintf (rtl_dump_file, \"Purged edges from bb %i\\n\", bb->index);\n+      if (!optimize)\n+\treturn;\n+\n+      /* Redistribute probabilities.  */\n+      if (!bb->succ->succ_next)\n+\t{\n+\t  bb->succ->probability = REG_BR_PROB_BASE;\n+\t  bb->succ->count = bb->count;\n+        }\n+      else\n+\t{\n+\t  note = find_reg_note (insn, REG_BR_PROB, NULL);\n+\t  if (!note)\n+\t    return;\n+\t  b = BRANCH_EDGE (bb);\n+\t  f = FALLTHRU_EDGE (bb);\n+\t  b->probability = INTVAL (XEXP (note, 0));\n+\t  f->probability = REG_BR_PROB_BASE - b->probability;\n+\t  b->count = bb->count * b->probability / REG_BR_PROB_BASE;\n+\t  f->count = bb->count * f->probability / REG_BR_PROB_BASE;\n+\t}\n       return;\n     }\n   /* If we don't see a jump insn, we don't know exactly why the block would"}, {"sha": "02bb24ab6a7758b67c80041b92e449e1e9c751a2", "filename": "gcc/toplev.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca9fef16af6d5678e16a3165f7d54ad3fa26c58b/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca9fef16af6d5678e16a3165f7d54ad3fa26c58b/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=ca9fef16af6d5678e16a3165f7d54ad3fa26c58b", "patch": "@@ -3060,6 +3060,8 @@ rest_of_compilation (decl)\n \t  tem = tem2 = 0;\n \t  timevar_push (TV_JUMP);\n \t  rebuild_jump_labels (insns);\n+\t  delete_trivially_dead_insns (insns, max_reg_num (), 0);\n+\t  find_basic_blocks (insns, max_reg_num (), rtl_dump_file);\n \t  cleanup_cfg (CLEANUP_EXPENSIVE);\n \t  timevar_pop (TV_JUMP);\n "}]}