{"sha": "83685efd5fd1623cfc4e4c435ce2773d95d458d1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODM2ODVlZmQ1ZmQxNjIzY2ZjNGU0YzQzNWNlMjc3M2Q5NWQ0NThkMQ==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2020-10-09T20:48:43Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2020-10-12T15:05:55Z"}, "message": "Generalize compute_objsize to return maximum size/offset instead of failing (PR middle-end/97023).\n\nAlso resolves:\nPR middle-end/97342 - bogus -Wstringop-overflow with nonzero signed and unsigned offsets\nPR middle-end/97023 - missing warning on buffer overflow in chained mempcpy\nPR middle-end/96384 - bogus -Wstringop-overflow= storing into multidimensional array with index in range\n\ngcc/ChangeLog:\n\n\tPR middle-end/97342\n\tPR middle-end/97023\n\tPR middle-end/96384\n\t* builtins.c (access_ref::access_ref): Initialize new member.  Use\n\tnew enum.\n\t(access_ref::size_remaining): Define new member function.\n\t(inform_access): Handle expressions referencing objects.\n\t(gimple_call_alloc_size): Call get_size_range instead of get_range.\n\t(gimple_call_return_array): New function.\n\t(get_range): Rename...\n\t(get_offset_range): ...to this.  Improve detection of ranges from\n\ttypes of expressions.\n\t(gimple_call_return_array): Adjust calls to get_range per above.\n\t(compute_objsize): Same.  Set maximum size or offset instead of\n\tfailing for unknown objects and handle more kinds of expressions.\n\t(compute_objsize): Call access_ref::size_remaining.\n\t(compute_objsize): Have transitional wrapper fail for pointers\n\tinto unknown objects.\n\t(expand_builtin_strncmp): Call access_ref::size_remaining and\n\thandle new cases.\n\t* builtins.h (access_ref::size_remaining): Declare new member function.\n\t(access_ref::set_max_size_range): Define new member function.\n\t(access_ref::add_ofset, access_ref::add_max_ofset): Same.\n\t(access_ref::add_base0): New data member.\n\t* calls.c (get_size_range): Change argument type.  Handle new\n\tcondition.\n\t* calls.h (get_size_range): Adjust signature.\n\t(enum size_range_flags): Define new type.\n\t* gimple-ssa-warn-restrict.c (builtin_memref::builtin_memref): Correct\n\targument to get_size_range.\n\t* tree-ssa-strlen.c (get_range): Handle anti-ranges.\n\t(maybe_warn_overflow): Check DECL_P before assuming it's one.\n\ngcc/testsuite/ChangeLog:\n\n\tPR middle-end/97342\n\tPR middle-end/97023\n\tPR middle-end/96384\n\t* c-c++-common/Wrestrict.c: Adjust comment.\n\t* gcc.dg/Wstringop-overflow-34.c: Remove xfail.\n\t* gcc.dg/Wstringop-overflow-43.c: Remove xfails.  Adjust regex patterns.\n\t* gcc.dg/pr51683.c: Prune out expected warning.\n\t* gcc.target/i386/pr60693.c: Same.\n\t* g++.dg/warn/Wplacement-new-size-8.C: New test.\n\t* gcc.dg/Wstringop-overflow-41.c: New test.\n\t* gcc.dg/Wstringop-overflow-44.s: New test.\n\t* gcc.dg/Wstringop-overflow-45.c: New test.\n\t* gcc.dg/Wstringop-overflow-46.c: New test.\n\t* gcc.dg/Wstringop-overflow-47.c: New test.\n\t* gcc.dg/Wstringop-overflow-49.c: New test.\n\t* gcc.dg/Wstringop-overflow-50.c: New test.\n\t* gcc.dg/Wstringop-overflow-51.c: New test.\n\t* gcc.dg/Wstringop-overflow-52.c: New test.\n\t* gcc.dg/Wstringop-overflow-53.c: New test.\n\t* gcc.dg/Wstringop-overflow-54.c: New test.\n\t* gcc.dg/Wstringop-overflow-55.c: New test.\n\t* gcc.dg/Wstringop-overread-5.c: New test.", "tree": {"sha": "5a6514717cd82b39bcec8872ba61871599c5684a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5a6514717cd82b39bcec8872ba61871599c5684a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/83685efd5fd1623cfc4e4c435ce2773d95d458d1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/83685efd5fd1623cfc4e4c435ce2773d95d458d1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/83685efd5fd1623cfc4e4c435ce2773d95d458d1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/83685efd5fd1623cfc4e4c435ce2773d95d458d1/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "de05c19d5fd661ae16dd75a895b49d32d12f5edc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/de05c19d5fd661ae16dd75a895b49d32d12f5edc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/de05c19d5fd661ae16dd75a895b49d32d12f5edc"}], "stats": {"total": 2543, "additions": 2339, "deletions": 204}, "files": [{"sha": "3a77da2b10ceeec04c731b3e670b305b93dc1d6f", "filename": "gcc/builtins.c", "status": "modified", "additions": 495, "deletions": 164, "changes": 659, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83685efd5fd1623cfc4e4c435ce2773d95d458d1/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83685efd5fd1623cfc4e4c435ce2773d95d458d1/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=83685efd5fd1623cfc4e4c435ce2773d95d458d1", "patch": "@@ -183,8 +183,6 @@ static void maybe_emit_chk_warning (tree, enum built_in_function);\n static void maybe_emit_sprintf_chk_warning (tree, enum built_in_function);\n static void maybe_emit_free_warning (tree);\n static tree fold_builtin_object_size (tree, tree);\n-static bool get_range (tree, gimple *, signop, offset_int[2],\n-\t\t       range_query * = NULL);\n static bool check_read_access (tree, tree, tree = NULL_TREE, int = 1);\n \n unsigned HOST_WIDE_INT target_newline;\n@@ -200,7 +198,7 @@ static void expand_builtin_sync_synchronize (void);\n \n access_ref::access_ref (tree bound /* = NULL_TREE */,\n \t\t\tbool minaccess /* = false */)\n-: ref (), eval ([](tree x){ return x; }), trail1special (true)\n+: ref (), eval ([](tree x){ return x; }), trail1special (true), base0 (true)\n {\n   /* Set to valid.  */\n   offrng[0] = offrng[1] = 0;\n@@ -215,14 +213,139 @@ access_ref::access_ref (tree bound /* = NULL_TREE */,\n      set the bounds of the access to reflect both it and MINACCESS.\n      BNDRNG[0] is the size of the minimum access.  */\n   tree rng[2];\n-  if (bound && get_size_range (bound, rng, true))\n+  if (bound && get_size_range (bound, rng, SR_ALLOW_ZERO))\n     {\n       bndrng[0] = wi::to_offset (rng[0]);\n       bndrng[1] = wi::to_offset (rng[1]);\n       bndrng[0] = bndrng[0] > 0 && minaccess ? 1 : 0;\n     }\n }\n \n+/* Return the maximum amount of space remaining and if non-null, set\n+   argument to the minimum.  */\n+\n+offset_int\n+access_ref::size_remaining (offset_int *pmin /* = NULL */) const\n+{\n+  offset_int minbuf;\n+  if (!pmin)\n+    pmin = &minbuf;\n+\n+  /* add_offset() ensures the offset range isn't inverted.  */\n+  gcc_checking_assert (offrng[0] <= offrng[1]);\n+\n+  if (base0)\n+    {\n+      /* The offset into referenced object is zero-based (i.e., it's\n+\t not referenced by a pointer into middle of some unknown object).  */\n+      if (offrng[0] < 0 && offrng[1] < 0)\n+\t{\n+\t  /* If the offset is negative the remaining size is zero.  */\n+\t  *pmin = 0;\n+\t  return 0;\n+\t}\n+\n+      if (sizrng[1] <= offrng[0])\n+\t{\n+\t  /* If the starting offset is greater than or equal to the upper\n+\t     bound on the size of the object, the space remaining is zero.\n+\t     As a special case, if it's equal, set *PMIN to -1 to let\n+\t     the caller know the offset is valid and just past the end.  */\n+\t  *pmin = sizrng[1] == offrng[0] ? -1 : 0;\n+\t  return 0;\n+\t}\n+\n+      /* Otherwise return the size minus the lower bound of the offset.  */\n+      offset_int or0 = offrng[0] < 0 ? 0 : offrng[0];\n+\n+      *pmin = sizrng[0] - or0;\n+      return sizrng[1] - or0;\n+    }\n+\n+  /* The offset to the referenced object isn't zero-based (i.e., it may\n+     refer to a byte other than the first.  The size of such an object\n+     is constrained only by the size of the address space (the result\n+     of max_object_size()).  */\n+  if (sizrng[1] <= offrng[0])\n+    {\n+      *pmin = 0;\n+      return 0;\n+    }\n+\n+  offset_int or0 = offrng[0] < 0 ? 0 : offrng[0];\n+\n+  *pmin = sizrng[0] - or0;\n+  return sizrng[1] - or0;\n+}\n+\n+/* Add the range [MIN, MAX] to the offset range.  For known objects (with\n+   zero-based offsets) at least one of whose offset's bounds is in range,\n+   constrain the other (or both) to the bounds of the object (i.e., zero\n+   and the upper bound of its size).  This improves the quality of\n+   diagnostics.  */\n+\n+void access_ref::add_offset (const offset_int &min, const offset_int &max)\n+{\n+  if (min <= max)\n+    {\n+      /* To add an ordinary range just add it to the bounds.  */\n+      offrng[0] += min;\n+      offrng[1] += max;\n+    }\n+  else if (!base0)\n+    {\n+      /* To add an inverted range to an offset to an unknown object\n+\t expand it to the maximum.  */\n+      add_max_offset ();\n+      return;\n+    }\n+  else\n+    {\n+      /* To add an inverted range to an offset to an known object set\n+\t the upper bound to the maximum representable offset value\n+\t (which may be greater than MAX_OBJECT_SIZE).\n+\t The lower bound is either the sum of the current offset and\n+\t MIN when abs(MAX) is greater than the former, or zero otherwise.\n+\t Zero because then then inverted range includes the negative of\n+\t the lower bound.  */\n+      offset_int maxoff = wi::to_offset (TYPE_MAX_VALUE (ptrdiff_type_node));\n+      offrng[1] = maxoff;\n+\n+      if (max >= 0)\n+\t{\n+\t  offrng[0] = 0;\n+\t  return;\n+\t}\n+\n+      offrng[1] = maxoff;\n+      offset_int absmax = wi::abs (max);\n+      if (offrng[0] < absmax)\n+\toffrng[0] += min;\n+      else\n+\toffrng[0] = 0;\n+    }\n+\n+  if (!base0)\n+    return;\n+\n+  /* When referencing a known object check to see if the offset computed\n+     so far is in bounds... */\n+  offset_int remrng[2];\n+  remrng[1] = size_remaining (remrng);\n+  if (remrng[1] > 0 || remrng[0] < 0)\n+    {\n+      /* ...if so, constrain it so that neither bound exceeds the size of\n+\t the object.  Out of bounds offsets are left unchanged, and, for\n+\t better or worse, become in bounds later.  They should be detected\n+\t and diagnosed at the point they first become invalid by\n+\t -Warray-bounds.  */\n+      if (offrng[0] < 0)\n+\toffrng[0] = 0;\n+      if (offrng[1] > sizrng[1])\n+\toffrng[1] = sizrng[1];\n+    }\n+}\n+\n /* Return true if NAME starts with __builtin_ or __sync_.  */\n \n static bool\n@@ -3757,15 +3880,24 @@ inform_access (const access_ref &ref, access_mode mode)\n   if (!ref.ref)\n     return;\n \n-  /* Convert offset range and avoid including a zero range since it isn't\n-     necessarily meaningful.  */\n-  long long minoff = 0, maxoff = 0;\n-  if (wi::fits_shwi_p (ref.offrng[0])\n-      && wi::fits_shwi_p (ref.offrng[1]))\n-    {\n-      minoff = ref.offrng[0].to_shwi ();\n-      maxoff = ref.offrng[1].to_shwi ();\n-    }\n+  /* Convert offset range and avoid including a zero range since it\n+     isn't necessarily meaningful.  */\n+  HOST_WIDE_INT diff_min = tree_to_shwi (TYPE_MIN_VALUE (ptrdiff_type_node));\n+  HOST_WIDE_INT diff_max = tree_to_shwi (TYPE_MAX_VALUE (ptrdiff_type_node));\n+  HOST_WIDE_INT minoff;\n+  HOST_WIDE_INT maxoff = diff_max;\n+  if (wi::fits_shwi_p (ref.offrng[0]))\n+    minoff = ref.offrng[0].to_shwi ();\n+  else\n+    minoff = ref.offrng[0] < 0 ? diff_min : diff_max;\n+\n+  if (wi::fits_shwi_p (ref.offrng[1]))\n+    maxoff = ref.offrng[1].to_shwi ();\n+\n+  if (maxoff <= diff_min || maxoff >= diff_max)\n+    /* Avoid mentioning an upper bound that's equal to or in excess\n+       of the maximum of ptrdiff_t.  */\n+    maxoff = minoff;\n \n   /* Convert size range and always include it since all sizes are\n      meaningful. */\n@@ -3799,23 +3931,27 @@ inform_access (const access_ref &ref, access_mode mode)\n \tsprintf (sizestr, \"[%llu, %llu]\", minsize, maxsize);\n \n     }\n-  else\n+  else if (DECL_P (ref.ref))\n     loc = DECL_SOURCE_LOCATION (ref.ref);\n+  else if (EXPR_P (ref.ref) && EXPR_HAS_LOCATION (ref.ref))\n+    loc = EXPR_LOCATION (ref.ref);\n+  else\n+    return;\n \n   if (mode == access_read_write || mode == access_write_only)\n     {\n-      if (DECL_P (ref.ref))\n+      if (allocfn == NULL_TREE)\n \t{\n \t  if (minoff == maxoff)\n \t    {\n \t      if (minoff == 0)\n-\t\tinform (loc, \"destination object %qD\", ref.ref);\n+\t\tinform (loc, \"destination object %qE\", ref.ref);\n \t      else\n-\t\tinform (loc, \"at offset %lli into destination object %qD\",\n+\t\tinform (loc, \"at offset %wi into destination object %qE\",\n \t\t\tminoff, ref.ref);\n \t    }\n \t  else\n-\t    inform (loc, \"at offset [%lli, %lli] into destination object %qD\",\n+\t    inform (loc, \"at offset [%wi, %wi] into destination object %qE\",\n \t\t    minoff, maxoff, ref.ref);\n \t  return;\n \t}\n@@ -3827,12 +3963,12 @@ inform_access (const access_ref &ref, access_mode mode)\n \t\t    sizestr, allocfn);\n \t  else\n \t    inform (loc,\n-\t\t    \"at offset %lli into destination object of size %s \"\n+\t\t    \"at offset %wi into destination object of size %s \"\n \t\t    \"allocated by %qE\", minoff, sizestr, allocfn);\n \t}\n       else\n \tinform (loc,\n-\t\t\"at offset [%lli, %lli] into destination object of size %s \"\n+\t\t\"at offset [%wi, %wi] into destination object of size %s \"\n \t\t\"allocated by %qE\",\n \t\tminoff, maxoff, sizestr, allocfn);\n \n@@ -3846,11 +3982,11 @@ inform_access (const access_ref &ref, access_mode mode)\n \t  if (minoff == 0)\n \t    inform (loc, \"source object %qD\", ref.ref);\n \t  else\n-\t    inform (loc, \"at offset %lli into source object %qD\",\n+\t    inform (loc, \"at offset %wi into source object %qD\",\n \t\t    minoff, ref.ref);\n \t}\n       else\n-\tinform (loc, \"at offset [%lli, %lli] into source object %qD\",\n+\tinform (loc, \"at offset [%wi, %wi] into source object %qD\",\n \t\tminoff, maxoff, ref.ref);\n       return;\n     }\n@@ -3862,12 +3998,12 @@ inform_access (const access_ref &ref, access_mode mode)\n \t\tsizestr, allocfn);\n       else\n \tinform (loc,\n-\t\t\"at offset %lli into source object of size %s \"\n+\t\t\"at offset %wi into source object of size %s \"\n \t\t\"allocated by %qE\", minoff, sizestr, allocfn);\n     }\n   else\n     inform (loc,\n-\t    \"at offset [%lli, %lli] into source object of size %s \"\n+\t    \"at offset [%wi, %wi] into source object of size %s \"\n \t    \"allocated by %qE\",\n \t    minoff, maxoff, sizestr, allocfn);\n }\n@@ -4152,8 +4288,14 @@ check_access (tree exp, tree dstwrite,\n \t\t   && range[0]\n \t\t   && TREE_CODE (slen) == INTEGER_CST\n \t\t   && tree_int_cst_lt (slen, range[0]));\n-\n-  if (!overread && pad && pad->src.sizrng[1] >= 0 && pad->src.offrng[0] >= 0)\n+  /* If none is determined try to get a better answer based on the details\n+     in PAD.  */\n+  if (!overread\n+      && pad\n+      && pad->src.sizrng[1] >= 0\n+      && pad->src.offrng[0] >= 0\n+      && (pad->src.offrng[1] < 0\n+\t  || pad->src.offrng[0] <= pad->src.offrng[1]))\n     {\n       /* Set RANGE to that of MAXREAD, bounded by PAD->SRC.BNDRNG if\n \t PAD is nonnull and BNDRNG is valid.  */\n@@ -4215,7 +4357,7 @@ check_read_access (tree exp, tree src, tree bound /* = NULL_TREE */,\n \n tree\n gimple_call_alloc_size (gimple *stmt, wide_int rng1[2] /* = NULL */,\n-\t\t\trange_query *rvals /* = NULL */)\n+\t\t\trange_query * /* = NULL */)\n {\n   if (!stmt)\n     return NULL_TREE;\n@@ -4267,14 +4409,17 @@ gimple_call_alloc_size (gimple *stmt, wide_int rng1[2] /* = NULL */,\n   if (!rng1)\n     rng1 = rng1_buf;\n \n+  /* Use maximum precision to avoid overflow below.  */\n   const int prec = ADDR_MAX_PRECISION;\n-  const tree size_max = TYPE_MAX_VALUE (sizetype);\n-  if (!get_range (size, stmt, rng1, rvals))\n-    {\n-      /* Use the full non-negative range on failure.  */\n-      rng1[0] = wi::zero (prec);\n-      rng1[1] = wi::to_wide (size_max, prec);\n-    }\n+\n+  {\n+    tree r[2];\n+    /* Determine the largest valid range size, including zero.  */\n+    if (!get_size_range (size, r, SR_ALLOW_ZERO | SR_USE_LARGEST))\n+      return NULL_TREE;\n+    rng1[0] = wi::to_wide (r[0], prec);\n+    rng1[1] = wi::to_wide (r[1], prec);\n+  }\n \n   if (argidx2 > nargs && TREE_CODE (size) == INTEGER_CST)\n     return fold_convert (sizetype, size);\n@@ -4283,26 +4428,24 @@ gimple_call_alloc_size (gimple *stmt, wide_int rng1[2] /* = NULL */,\n      of the upper bounds as a constant.  Ignore anti-ranges.  */\n   tree n = argidx2 < nargs ? gimple_call_arg (stmt, argidx2) : integer_one_node;\n   wide_int rng2[2];\n-\t  if (!get_range (n, stmt, rng2, rvals))\n-    {\n+  {\n+    tree r[2];\n       /* As above, use the full non-negative range on failure.  */\n-      rng2[0] = wi::zero (prec);\n-      rng2[1] = wi::to_wide (size_max, prec);\n-    }\n-\n-  /* Extend to the maximum precision to avoid overflow.  */\n-  rng1[0] = wide_int::from (rng1[0], prec, UNSIGNED);\n-  rng1[1] = wide_int::from (rng1[1], prec, UNSIGNED);\n-  rng2[0] = wide_int::from (rng2[0], prec, UNSIGNED);\n-  rng2[1] = wide_int::from (rng2[1], prec, UNSIGNED);\n+    if (!get_size_range (n, r, SR_ALLOW_ZERO | SR_USE_LARGEST))\n+      return NULL_TREE;\n+    rng2[0] = wi::to_wide (r[0], prec);\n+    rng2[1] = wi::to_wide (r[1], prec);\n+  }\n \n   /* Compute products of both bounds for the caller but return the lesser\n      of SIZE_MAX and the product of the upper bounds as a constant.  */\n   rng1[0] = rng1[0] * rng2[0];\n   rng1[1] = rng1[1] * rng2[1];\n+\n+  const tree size_max = TYPE_MAX_VALUE (sizetype);\n   if (wi::gtu_p (rng1[1], wi::to_wide (size_max, prec)))\n     {\n-      rng1[1] = wi::to_wide (size_max);\n+      rng1[1] = wi::to_wide (size_max, prec);\n       return size_max;\n     }\n \n@@ -4315,7 +4458,8 @@ gimple_call_alloc_size (gimple *stmt, wide_int rng1[2] /* = NULL */,\n    Return the function parameter on success and null otherwise.  */\n \n tree\n-gimple_parm_array_size (tree ptr, wide_int rng[2], range_query * /* = NULL */)\n+gimple_parm_array_size (tree ptr, wide_int rng[2],\n+\t\t\trange_query * /* = NULL */)\n {\n   /* For a function argument try to determine the byte size of the array\n      from the current function declaratation (e.g., attribute access or\n@@ -4363,34 +4507,51 @@ gimple_parm_array_size (tree ptr, wide_int rng[2], range_query * /* = NULL */)\n   return var;\n }\n \n-/* Wrapper around the wide_int overload of get_range.  Returns the same\n-   result but accepts offset_int instead.  */\n+/* Wrapper around the wide_int overload of get_range that accepts\n+   offset_int instead.  For middle end expressions returns the same\n+   result.  For a subset of nonconstamt expressions emitted by the front\n+   end determines a more precise range than would be possible otherwise.  */\n \n static bool\n-get_range (tree x, gimple *stmt, signop sgn, offset_int r[2],\n-\t   range_query *rvals /* = NULL */)\n+get_offset_range (tree x, gimple *stmt, offset_int r[2], range_query *rvals)\n {\n-  tree type = TREE_TYPE (x);\n-  if (TREE_CODE (x) != INTEGER_CST\n-      && TREE_CODE (x) != SSA_NAME)\n+  offset_int add = 0;\n+  if (TREE_CODE (x) == PLUS_EXPR)\n     {\n-      if (TYPE_UNSIGNED (type))\n+      /* Handle constant offsets in pointer addition expressions seen\n+\t n the front end IL.  */\n+      tree op = TREE_OPERAND (x, 1);\n+      if (TREE_CODE (op) == INTEGER_CST)\n \t{\n-\t  if (sgn == SIGNED)\n-\t    type = signed_type_for (type);\n+\t  op = fold_convert (signed_type_for (TREE_TYPE (op)), op);\n+\t  add = wi::to_offset (op);\n+\t  x = TREE_OPERAND (x, 0);\n \t}\n-      else if (sgn == UNSIGNED)\n-\ttype = unsigned_type_for (type);\n+    }\n+\n+  if (TREE_CODE (x) == NOP_EXPR)\n+    /* Also handle conversions to sizetype seen in the front end IL.  */\n+    x = TREE_OPERAND (x, 0);\n+\n+  tree type = TREE_TYPE (x);\n \n-      r[0] = wi::to_offset (TYPE_MIN_VALUE (type));\n-      r[1] = wi::to_offset (TYPE_MAX_VALUE (type));\n+   if (TREE_CODE (x) != INTEGER_CST\n+      && TREE_CODE (x) != SSA_NAME)\n+    {\n+      if (TYPE_UNSIGNED (type)\n+\t  && TYPE_PRECISION (type) == TYPE_PRECISION (sizetype))\n+\ttype = signed_type_for (type);\n+\n+      r[0] = wi::to_offset (TYPE_MIN_VALUE (type)) + add;\n+      r[1] = wi::to_offset (TYPE_MAX_VALUE (type)) + add;\n       return x;\n     }\n \n   wide_int wr[2];\n   if (!get_range (x, stmt, wr, rvals))\n     return false;\n \n+  signop sgn = SIGNED;\n   /* Only convert signed integers or unsigned sizetype to a signed\n      offset and avoid converting large positive values in narrower\n      types to negative offsets.  */\n@@ -4403,6 +4564,83 @@ get_range (tree x, gimple *stmt, signop sgn, offset_int r[2],\n   return true;\n }\n \n+/* Return the argument that the call STMT to a built-in function returns\n+   or null if it doesn't.  On success, set OFFRNG[] to the range of offsets\n+   from the argument reflected in the value returned by the built-in if it\n+   can be determined, otherwise to 0 and HWI_M1U respectively.  */\n+\n+static tree\n+gimple_call_return_array (gimple *stmt, offset_int offrng[2],\n+\t\t\t  range_query *rvals)\n+{\n+  if (!gimple_call_builtin_p (stmt, BUILT_IN_NORMAL)\n+      || gimple_call_num_args (stmt) < 1)\n+    return NULL_TREE;\n+\n+  tree fn = gimple_call_fndecl (stmt);\n+  switch (DECL_FUNCTION_CODE (fn))\n+    {\n+    case BUILT_IN_MEMCPY:\n+    case BUILT_IN_MEMCPY_CHK:\n+    case BUILT_IN_MEMMOVE:\n+    case BUILT_IN_MEMMOVE_CHK:\n+    case BUILT_IN_MEMSET:\n+    case BUILT_IN_STPCPY:\n+    case BUILT_IN_STPCPY_CHK:\n+    case BUILT_IN_STPNCPY:\n+    case BUILT_IN_STPNCPY_CHK:\n+    case BUILT_IN_STRCAT:\n+    case BUILT_IN_STRCAT_CHK:\n+    case BUILT_IN_STRCPY:\n+    case BUILT_IN_STRCPY_CHK:\n+    case BUILT_IN_STRNCAT:\n+    case BUILT_IN_STRNCAT_CHK:\n+    case BUILT_IN_STRNCPY:\n+    case BUILT_IN_STRNCPY_CHK:\n+      offrng[0] = offrng[1] = 0;\n+      return gimple_call_arg (stmt, 0);\n+\n+    case BUILT_IN_MEMPCPY:\n+    case BUILT_IN_MEMPCPY_CHK:\n+      {\n+\ttree off = gimple_call_arg (stmt, 2);\n+\tif (!get_offset_range (off, stmt, offrng, rvals))\n+\t  {\n+\t    offrng[0] = 0;\n+\t    offrng[1] = HOST_WIDE_INT_M1U;\n+\t  }\n+\treturn gimple_call_arg (stmt, 0);\n+      }\n+\n+    case BUILT_IN_MEMCHR:\n+      {\n+\ttree off = gimple_call_arg (stmt, 2);\n+\tif (get_offset_range (off, stmt, offrng, rvals))\n+\t  offrng[0] = 0;\n+\telse\n+\t  {\n+\t    offrng[0] = 0;\n+\t    offrng[1] = HOST_WIDE_INT_M1U;\n+\t  }\n+\treturn gimple_call_arg (stmt, 0);\n+      }\n+\n+    case BUILT_IN_STRCHR:\n+    case BUILT_IN_STRRCHR:\n+    case BUILT_IN_STRSTR:\n+      {\n+\toffrng[0] = 0;\n+\toffrng[1] = HOST_WIDE_INT_M1U;\n+      }\n+      return gimple_call_arg (stmt, 0);\n+\n+    default:\n+      break;\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n /* Helper to compute the size of the object referenced by the PTR\n    expression which must have pointer type, using Object Size type\n    OSTYPE (only the least significant 2 bits are used).\n@@ -4412,7 +4650,8 @@ get_range (tree x, gimple *stmt, signop sgn, offset_int r[2],\n    the object(s).\n    VISITED is used to avoid visiting the same PHI operand multiple\n    times, and, when nonnull, RVALS to determine range information.\n-   Returns true on success, false when the size cannot be determined.\n+   Returns true on success, false when a meaningful size (or range)\n+   cannot be determined.\n \n    The function is intended for diagnostics and should not be used\n    to influence code generation or optimization.  */\n@@ -4429,53 +4668,70 @@ compute_objsize (tree ptr, int ostype, access_ref *pref, bitmap *visited,\n \n   if (DECL_P (ptr))\n     {\n-      /* Bail if the reference is to the pointer itself (as opposed\n-\t to what it points to).  */\n+      pref->ref = ptr;\n+\n       if (!addr && POINTER_TYPE_P (TREE_TYPE (ptr)))\n-\treturn false;\n+\t{\n+\t  /* Set the maximum size if the reference is to the pointer\n+\t     itself (as opposed to what it points to).  */\n+\t  pref->set_max_size_range ();\n+\t  return true;\n+\t}\n \n-      pref->ref = ptr;\n       if (tree size = decl_init_size (ptr, false))\n \tif (TREE_CODE (size) == INTEGER_CST)\n \t  {\n \t    pref->sizrng[0] = pref->sizrng[1] = wi::to_offset (size);\n \t    return true;\n \t  }\n-      pref->sizrng[0] = 0;\n-      pref->sizrng[1] = wi::to_offset (TYPE_MAX_VALUE (ptrdiff_type_node));\n+\n+      pref->set_max_size_range ();\n       return true;\n     }\n \n   const tree_code code = TREE_CODE (ptr);\n \n+  if (code == BIT_FIELD_REF)\n+    {\n+      tree ref = TREE_OPERAND (ptr, 0);\n+      if (!compute_objsize (ref, ostype, pref, visited, rvals))\n+\treturn false;\n+\n+      offset_int off = wi::to_offset (pref->eval (TREE_OPERAND (ptr, 2)));\n+      pref->add_offset (off / BITS_PER_UNIT);\n+      return true;\n+    }\n+\n   if (code == COMPONENT_REF)\n     {\n       tree ref = TREE_OPERAND (ptr, 0);\n       tree field = TREE_OPERAND (ptr, 1);\n \n       if (ostype == 0)\n \t{\n-\t  /* For raw memory functions like memcpy bail if the size\n-\t     of the enclosing object cannot be determined.  */\n-\t  if (!compute_objsize (ref, ostype, pref, visited, rvals)\n-\t      || !pref->ref)\n+\t  /* In OSTYPE zero (for raw memory functions like memcpy), use\n+\t     the maximum size instead if the identity of the enclosing\n+\t     object cannot be determined.  */\n+\t  if (!compute_objsize (ref, ostype, pref, visited, rvals))\n \t    return false;\n \n \t  /* Otherwise, use the size of the enclosing object and add\n \t     the offset of the member to the offset computed so far.  */\n \t  tree offset = byte_position (field);\n-\t  if (TREE_CODE (offset) != INTEGER_CST)\n-\t    return false;\n-\t  offset_int off = wi::to_offset (offset);\n-\t  pref->offrng[0] += off;\n-\t  pref->offrng[1] += off;\n+\t  if (TREE_CODE (offset) == INTEGER_CST)\n+\t    pref->add_offset (wi::to_offset (offset));\n+\t  else\n+\t    pref->add_max_offset ();\n \t  return true;\n \t}\n \n-      /* Bail if the reference is to the pointer itself (as opposed\n-\t to what it points to).  */\n       if (!addr && POINTER_TYPE_P (TREE_TYPE (field)))\n-\treturn false;\n+\t{\n+\t  /* Set maximum size if the reference is to the pointer member\n+\t     itself (as opposed to what it points to).  */\n+\t  pref->set_max_size_range ();\n+\t  return true;\n+\t}\n \n       pref->ref = field;\n \n@@ -4530,9 +4786,12 @@ compute_objsize (tree ptr, int ostype, access_ref *pref, bitmap *visited,\n \n       offset_int orng[2];\n       tree off = pref->eval (TREE_OPERAND (ptr, 1));\n-      if (!get_range (off, NULL, SIGNED, orng, rvals))\n-\t/* Fail unless the size of the object is zero.  */\n-\treturn pref->sizrng[0] == 0 && pref->sizrng[0] == pref->sizrng[1];\n+      if (!get_offset_range (off, NULL, orng, rvals))\n+\t{\n+\t  /* Set ORNG to the maximum offset representable in ptrdiff_t.  */\n+\t  orng[1] = wi::to_offset (TYPE_MAX_VALUE (ptrdiff_type_node));\n+\t  orng[0] = -orng[1] - 1;\n+\t}\n \n       if (TREE_CODE (ptr) == ARRAY_REF)\n \t{\n@@ -4551,7 +4810,10 @@ compute_objsize (tree ptr, int ostype, access_ref *pref, bitmap *visited,\n \t  tree eltype = TREE_TYPE (ptr);\n \t  tree tpsize = TYPE_SIZE_UNIT (eltype);\n \t  if (!tpsize || TREE_CODE (tpsize) != INTEGER_CST)\n-\t    return false;\n+\t    {\n+\t      pref->add_max_offset ();\n+\t      return true;\n+\t    }\n \n \t  offset_int sz = wi::to_offset (tpsize);\n \t  orng[0] *= sz;\n@@ -4578,29 +4840,59 @@ compute_objsize (tree ptr, int ostype, access_ref *pref, bitmap *visited,\n \t    }\n \t}\n \n-      pref->offrng[0] += orng[0];\n-      pref->offrng[1] += orng[1];\n+      pref->add_offset (orng[0], orng[1]);\n+      return true;\n+    }\n \n+  if (code == TARGET_MEM_REF)\n+    {\n+      tree ref = TREE_OPERAND (ptr, 0);\n+      if (!compute_objsize (ref, ostype, pref, visited, rvals))\n+\treturn false;\n+\n+      /* TODO: Handle remaining operands.  Until then, add maximum offset.  */\n+      pref->ref = ptr;\n+      pref->add_max_offset ();\n+      return true;\n+    }\n+\n+  if (code == INTEGER_CST)\n+    {\n+      /* Pointer constants other than null are most likely the result\n+\t of erroneous null pointer addition/subtraction.  Set size to\n+\t zero.  For null pointers, set size to the maximum for now\n+\t since those may be the result of jump threading.  */\n+      if (integer_zerop (ptr))\n+\tpref->set_max_size_range ();\n+      else\n+\tpref->sizrng[0] = pref->sizrng[1] = 0;\n+      pref->ref = ptr;\n+\n+      return true;\n+    }\n+\n+  if (code == STRING_CST)\n+    {\n+      pref->sizrng[0] = pref->sizrng[1] = TREE_STRING_LENGTH (ptr);\n       return true;\n     }\n-  else if (code == POINTER_PLUS_EXPR)\n+\n+  if (code == POINTER_PLUS_EXPR)\n     {\n       tree ref = TREE_OPERAND (ptr, 0);\n       if (!compute_objsize (ref, ostype, pref, visited, rvals))\n \treturn false;\n \n       offset_int orng[2];\n       tree off = pref->eval (TREE_OPERAND (ptr, 1));\n-      if (!get_range (off, NULL, SIGNED, orng, rvals))\n-\t/* Fail unless the size of the object is zero.  */\n-\treturn pref->sizrng[0] == 0 && pref->sizrng[0] == pref->sizrng[1];\n-\n-      pref->offrng[0] += orng[0];\n-      pref->offrng[1] += orng[1];\n-\n+      if (get_offset_range (off, NULL, orng, rvals))\n+\tpref->add_offset (orng[0], orng[1]);\n+      else\n+\tpref->add_max_offset ();\n       return true;\n     }\n-  else if (code == VIEW_CONVERT_EXPR)\n+\n+  if (code == VIEW_CONVERT_EXPR)\n     {\n       ptr = TREE_OPERAND (ptr, 0);\n       return compute_objsize (ptr, ostype, pref, visited, rvals);\n@@ -4612,17 +4904,53 @@ compute_objsize (tree ptr, int ostype, access_ref *pref, bitmap *visited,\n       if (is_gimple_call (stmt))\n \t{\n \t  /* If STMT is a call to an allocation function get the size\n-\t     from its argument(s).  If successful, also set *PDECL to\n-\t     PTR for the caller to include in diagnostics.  */\n+\t     from its argument(s).  If successful, also set *PREF->REF\n+\t     to PTR for the caller to include in diagnostics.  */\n \t  wide_int wr[2];\n \t  if (gimple_call_alloc_size (stmt, wr, rvals))\n \t    {\n \t      pref->ref = ptr;\n \t      pref->sizrng[0] = offset_int::from (wr[0], UNSIGNED);\n \t      pref->sizrng[1] = offset_int::from (wr[1], UNSIGNED);\n-\t      return true;\n+\t      /* Constrain both bounds to a valid size.  */\n+\t      offset_int maxsize = wi::to_offset (max_object_size ());\n+\t      if (pref->sizrng[0] > maxsize)\n+\t\tpref->sizrng[0] = maxsize;\n+\t      if (pref->sizrng[1] > maxsize)\n+\t\tpref->sizrng[1] = maxsize;\n \t    }\n-\t  return false;\n+\t  else\n+\t    {\n+\t      /* For functions known to return one of their pointer arguments\n+\t\t try to determine what the returned pointer points to, and on\n+\t\t success add OFFRNG which was set to the offset added by\n+\t\t the function (e.g., memchr) to the overall offset.  */\n+\t      offset_int offrng[2];\n+\t      if (tree ret = gimple_call_return_array (stmt, offrng, rvals))\n+\t\t{\n+\t\t  if (!compute_objsize (ret, ostype, pref, visited, rvals))\n+\t\t    return false;\n+\n+\t\t  /* Cap OFFRNG[1] to at most the remaining size of\n+\t\t     the object.  */\n+\t\t  offset_int remrng[2];\n+\t\t  remrng[1] = pref->size_remaining (remrng);\n+\t\t  if (remrng[1] < offrng[1])\n+\t\t    offrng[1] = remrng[1];\n+\t\t  pref->add_offset (offrng[0], offrng[1]);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  /* For other calls that might return arbitrary pointers\n+\t\t     including into the middle of objects set the size\n+\t\t     range to maximum, clear PREF->BASE0, and also set\n+\t\t     PREF->REF to include in diagnostics.  */\n+\t\t  pref->set_max_size_range ();\n+\t\t  pref->base0 = false;\n+\t\t  pref->ref = ptr;\n+\t\t}\n+\t    }\n+\t  return true;\n \t}\n \n       if (gimple_nop_p (stmt))\n@@ -4631,62 +4959,74 @@ compute_objsize (tree ptr, int ostype, access_ref *pref, bitmap *visited,\n \t     of the array from the current function declaratation\n \t     (e.g., attribute access or related).  */\n \t  wide_int wr[2];\n-\t  tree ref = gimple_parm_array_size (ptr, wr, rvals);\n-\t  if (!ref)\n-\t    return NULL_TREE;\n-\t  pref->ref = ref;\n-\t  pref->sizrng[0] = offset_int::from (wr[0], UNSIGNED);\n-\t  pref->sizrng[1] = offset_int::from (wr[1], UNSIGNED);\n+\t  if (tree ref = gimple_parm_array_size (ptr, wr, rvals))\n+\t    {\n+\t      pref->sizrng[0] = offset_int::from (wr[0], UNSIGNED);\n+\t      pref->sizrng[1] = offset_int::from (wr[1], UNSIGNED);\n+\t      pref->ref = ref;\n+\t      return true;\n+\t    }\n+\n+\t  pref->set_max_size_range ();\n+\t  pref->base0 = false;\n+\t  pref->ref = ptr;\n+\t  if (tree var = SSA_NAME_VAR (ptr))\n+\t    if (TREE_CODE (var) == PARM_DECL)\n+\t      pref->ref = var;\n+\n \t  return true;\n \t}\n \n       /* TODO: Handle PHI.  */\n \n       if (!is_gimple_assign (stmt))\n-\treturn false;\n+\t{\n+\t  /* Clear BASE0 since the assigned pointer might point into\n+\t     the middle of the object, set the maximum size range and,\n+\t     if the SSA_NAME refers to a function argumnent, set\n+\t     PREF->REF to it.  */\n+\t  pref->base0 = false;\n+\t  pref->set_max_size_range ();\n+\t  if (tree var = SSA_NAME_VAR (ptr))\n+\t    if (TREE_CODE (var) == PARM_DECL)\n+\t      pref->ref = var;\n+\t  return true;\n+\t}\n \n       ptr = gimple_assign_rhs1 (stmt);\n \n       tree_code code = gimple_assign_rhs_code (stmt);\n-      if (TREE_CODE (TREE_TYPE (ptr)) != POINTER_TYPE)\n-\t/* Avoid conversions from non-pointers.  */\n-\treturn false;\n \n-      if (code == POINTER_PLUS_EXPR)\n+      if (code == POINTER_PLUS_EXPR\n+\t  && TREE_CODE (TREE_TYPE (ptr)) == POINTER_TYPE)\n \t{\n-\t  /* If the the offset in the expression can be determined use\n-\t     it to adjust the overall offset.  Otherwise, set the overall\n-\t     offset to the maximum.  */\n+\t  /* Compute the size of the object first. */\n+\t  if (!compute_objsize (ptr, ostype, pref, visited, rvals))\n+\t    return false;\n+\n \t  offset_int orng[2];\n \t  tree off = gimple_assign_rhs2 (stmt);\n-\t  if (!get_range (off, stmt, SIGNED, orng, rvals))\n-\t    {\n-\t      orng[0] = wi::to_offset (TYPE_MIN_VALUE (ptrdiff_type_node));\n-\t      orng[1] = wi::to_offset (TYPE_MAX_VALUE (ptrdiff_type_node));\n-\t    }\n-\n-\t  pref->offrng[0] += orng[0];\n-\t  pref->offrng[1] += orng[1];\n+\t  if (get_offset_range (off, stmt, orng, rvals))\n+\t    pref->add_offset (orng[0], orng[1]);\n+\t  else\n+\t    pref->add_max_offset ();\n+\t  return true;\n \t}\n-      else if (code != ADDR_EXPR)\n-\treturn false;\n \n-      return compute_objsize (ptr, ostype, pref, visited, rvals);\n-    }\n-\n-  tree type = TREE_TYPE (ptr);\n-  type = TYPE_MAIN_VARIANT (type);\n-  if (TREE_CODE (ptr) == ADDR_EXPR)\n-    ptr = TREE_OPERAND (ptr, 0);\n+      if (code == ADDR_EXPR)\n+\treturn compute_objsize (ptr, ostype, pref, visited, rvals);\n \n-  if (TREE_CODE (type) == ARRAY_TYPE\n-      && !array_at_struct_end_p (ptr))\n-    {\n-      if (tree size = TYPE_SIZE_UNIT (type))\n-\treturn get_range (size, NULL, UNSIGNED, pref->sizrng, rvals);\n+      /* This could be an assignment from a nonlocal pointer.  Save PTR\n+\t to mention in diagnostics but otherwise treat it as a pointer\n+\t to an unknown object.  */\n+      pref->ref = ptr;\n     }\n \n-  return false;\n+  /* Assume all other expressions point into an unknown object\n+     of the maximum valid size.  */\n+  pref->base0 = false;\n+  pref->set_max_size_range ();\n+  return true;\n }\n \n /* A \"public\" wrapper around the above.  Clients should use this overload\n@@ -4707,41 +5047,24 @@ compute_objsize (tree ptr, int ostype, access_ref *pref,\n   if (!success)\n     return NULL_TREE;\n \n-  if (pref->offrng[1] < pref->offrng[0])\n-    {\n-      if (pref->offrng[1] < 0\n-\t  && pref->sizrng[1] <= pref->offrng[0])\n-\treturn size_zero_node;\n-\n-      return wide_int_to_tree (sizetype, pref->sizrng[1]);\n-    }\n-\n-  if (pref->offrng[0] < 0)\n-    {\n-      if (pref->offrng[1] < 0)\n-\treturn size_zero_node;\n-\n-      pref->offrng[0] = 0;\n-    }\n-\n-  if (pref->sizrng[1] <= pref->offrng[0])\n-    return size_zero_node;\n-\n-  return wide_int_to_tree (sizetype, pref->sizrng[1] - pref->offrng[0]);\n+  offset_int maxsize = pref->size_remaining ();\n+  if (pref->base0 && pref->offrng[0] < 0 && pref->offrng[1] >= 0)\n+    pref->offrng[0] = 0;\n+  return wide_int_to_tree (sizetype, maxsize);\n }\n \n /* Transitional wrapper around the above.  The function should be removed\n    once callers transition to one of the two above.  */\n \n tree\n compute_objsize (tree ptr, int ostype, tree *pdecl /* = NULL */,\n-\t\t tree *poff /* = NULL */, class range_query *rvals /* = NULL */)\n+\t\t tree *poff /* = NULL */, range_query *rvals /* = NULL */)\n {\n   /* Set the initial offsets to zero and size to negative to indicate\n      none has been computed yet.  */\n   access_ref ref;\n   tree size = compute_objsize (ptr, ostype, &ref, rvals);\n-  if (!size)\n+  if (!size || !ref.base0)\n     return NULL_TREE;\n \n   if (pdecl)\n@@ -6020,13 +6343,21 @@ expand_builtin_strncmp (tree exp, ATTRIBUTE_UNUSED rtx target,\n \t  tree size2 = compute_objsize (arg2, 1, &ref2);\n \t  tree func = get_callee_fndecl (exp);\n \n-\t  if (size1 && size2)\n+\t  if (size1 && size2 && bndrng[0] && !integer_zerop (bndrng[0]))\n \t    {\n-\t      tree maxsize = tree_int_cst_le (size1, size2) ? size2 : size1;\n-\n-\t      if (tree_int_cst_lt (maxsize, bndrng[0]))\n+\t      offset_int rem1 = ref1.size_remaining ();\n+\t      offset_int rem2 = ref2.size_remaining ();\n+\t      if (rem1 == 0 || rem2 == 0)\n \t\tmaybe_warn_for_bound (OPT_Wstringop_overread, loc, exp, func,\n-\t\t\t\t      bndrng, maxsize);\n+\t\t\t\t      bndrng, integer_zero_node);\n+\t      else\n+\t\t{\n+\t\t  offset_int maxrem = wi::max (rem1, rem2, UNSIGNED);\n+\t\t  if (maxrem < wi::to_offset (bndrng[0]))\n+\t\t    maybe_warn_for_bound (OPT_Wstringop_overread, loc, exp,\n+\t\t\t\t\t  func, bndrng,\n+\t\t\t\t\t  wide_int_to_tree (sizetype, maxrem));\n+\t\t}\n \t    }\n \t  else if (bndrng[0]\n \t\t   && !integer_zerop (bndrng[0])"}, {"sha": "c09f36da02b76bea2ce6df700c05642fe2603a03", "filename": "gcc/builtins.h", "status": "modified", "additions": 35, "deletions": 6, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83685efd5fd1623cfc4e4c435ce2773d95d458d1/gcc%2Fbuiltins.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83685efd5fd1623cfc4e4c435ce2773d95d458d1/gcc%2Fbuiltins.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.h?ref=83685efd5fd1623cfc4e4c435ce2773d95d458d1", "patch": "@@ -180,15 +180,45 @@ struct access_ref\n     return offrng[0] == 0 && offrng[1] == 0;\n   }\n \n-  /* Return true if OFFRNG is bounded to a subrange of possible offset\n-     values.  */\n+  /* Return true if OFFRNG is bounded to a subrange of offset values\n+     valid for the largest possible object.  */\n   bool offset_bounded () const;\n \n+  /* Return the maximum amount of space remaining and if non-null, set\n+     argument to the minimum.  */\n+  offset_int size_remaining (offset_int * = NULL) const;\n+\n+  /* Set the size range to the maximum.  */\n+  void set_max_size_range ()\n+  {\n+    sizrng[0] = 0;\n+    sizrng[1] = wi::to_offset (max_object_size ());\n+  }\n+\n+  /* Add OFF to the offset range.  */\n+  void add_offset (const offset_int &off)\n+  {\n+    add_offset (off, off);\n+  }\n+\n+  /* Add the range [MIN, MAX] to the offset range.  */\n+  void add_offset (const offset_int &, const offset_int &);\n+\n+  /* Add the maximum representable offset to the offset range.  */\n+  void add_max_offset ()\n+  {\n+    offset_int maxoff = wi::to_offset (TYPE_MAX_VALUE (ptrdiff_type_node));\n+    add_offset (-maxoff - 1, maxoff);\n+  }\n+\n   /* Used to fold integer expressions when called from front ends.  */\n   tree (*eval)(tree);\n   /* Set if trailing one-element arrays should be treated as flexible\n      array members.  */\n   bool trail1special;\n+  /* Set if valid offsets must start at zero (for declared and allocated\n+     objects but not for others referenced by pointers).  */\n+  bool base0;\n };\n \n /* Describes a pair of references used in an access by built-in\n@@ -216,11 +246,10 @@ class range_query;\n extern tree gimple_call_alloc_size (gimple *, wide_int[2] = NULL,\n \t\t\t\t    range_query * = NULL);\n extern tree gimple_parm_array_size (tree, wide_int[2], range_query * = NULL);\n+extern tree compute_objsize (tree, int, access_ref *, range_query * = NULL);\n extern tree compute_objsize (tree, int, tree * = NULL, tree * = NULL,\n \t\t\t     range_query * = NULL);\n-extern tree compute_objsize (tree, int, access_ref *, range_query * = NULL);\n-\n-extern bool check_access (tree, tree, tree, tree, tree, access_mode,\n-\t\t\t  const access_data * = NULL);\n+extern bool check_access (tree, tree, tree, tree, tree,\n+\t\t\t  access_mode, const access_data * = NULL);\n \n #endif /* GCC_BUILTINS_H */"}, {"sha": "d3120b23f6066b9cc50cfa382e9e24e4aa012deb", "filename": "gcc/calls.c", "status": "modified", "additions": 48, "deletions": 21, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83685efd5fd1623cfc4e4c435ce2773d95d458d1/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83685efd5fd1623cfc4e4c435ce2773d95d458d1/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=83685efd5fd1623cfc4e4c435ce2773d95d458d1", "patch": "@@ -1235,14 +1235,16 @@ alloc_max_size (void)\n    after adjusting it if necessary to make EXP a represents a valid size\n    of object, or a valid size argument to an allocation function declared\n    with attribute alloc_size (whose argument may be signed), or to a string\n-   manipulation function like memset.  When ALLOW_ZERO is true, allow\n-   returning a range of [0, 0] for a size in an anti-range [1, N] where\n-   N > PTRDIFF_MAX.  A zero range is a (nearly) invalid argument to\n-   allocation functions like malloc but it is a valid argument to\n-   functions like memset.  */\n+   manipulation function like memset.\n+   When ALLOW_ZERO is set in FLAGS, allow returning a range of [0, 0] for\n+   a size in an anti-range [1, N] where N > PTRDIFF_MAX.  A zero range is\n+   a (nearly) invalid argument to allocation functions like malloc but it\n+   is a valid argument to functions like memset.\n+   When USE_LARGEST is set in FLAGS set RANGE to the largest valid subrange\n+   in a multi-range, otherwise to the smallest valid subrange.  */\n \n bool\n-get_size_range (tree exp, tree range[2], bool allow_zero /* = false */)\n+get_size_range (tree exp, tree range[2], int flags /* = 0 */)\n {\n   if (!exp)\n     return false;\n@@ -1314,25 +1316,50 @@ get_size_range (tree exp, tree range[2], bool allow_zero /* = false */)\n \t      min = wi::zero (expprec);\n \t    }\n \t}\n-      else if (wi::eq_p (0, min - 1))\n+      else\n \t{\n-\t  /* EXP is unsigned and not in the range [1, MAX].  That means\n-\t     it's either zero or greater than MAX.  Even though 0 would\n-\t     normally be detected by -Walloc-zero, unless ALLOW_ZERO\n-\t     is true, set the range to [MAX, TYPE_MAX] so that when MAX\n-\t     is greater than the limit the whole range is diagnosed.  */\n-\t  if (allow_zero)\n-\t    min = max = wi::zero (expprec);\n-\t  else\n+\t  wide_int maxsize = wi::to_wide (max_object_size ());\n+\t  min = wide_int::from (min, maxsize.get_precision (), UNSIGNED);\n+\t  max = wide_int::from (max, maxsize.get_precision (), UNSIGNED);\n+\t  if (wi::eq_p (0, min - 1))\n \t    {\n+\t      /* EXP is unsigned and not in the range [1, MAX].  That means\n+\t\t it's either zero or greater than MAX.  Even though 0 would\n+\t\t normally be detected by -Walloc-zero, unless ALLOW_ZERO\n+\t\t is set, set the range to [MAX, TYPE_MAX] so that when MAX\n+\t\t is greater than the limit the whole range is diagnosed.  */\n+\t      wide_int maxsize = wi::to_wide (max_object_size ());\n+\t      if (flags & SR_ALLOW_ZERO)\n+\t\t{\n+\t\t  if (wi::leu_p (maxsize, max + 1)\n+\t\t      || !(flags & SR_USE_LARGEST))\n+\t\t    min = max = wi::zero (expprec);\n+\t\t  else\n+\t\t    {\n+\t\t      min = max + 1;\n+\t\t      max = wi::to_wide (TYPE_MAX_VALUE (exptype));\n+\t\t    }\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  min = max + 1;\n+\t\t  max = wi::to_wide (TYPE_MAX_VALUE (exptype));\n+\t\t}\n+\t    }\n+\t  else if ((flags & SR_USE_LARGEST)\n+\t\t   && wi::ltu_p (max + 1, maxsize))\n+\t    {\n+\t      /* When USE_LARGEST is set and the larger of the two subranges\n+\t\t is a valid size, use it...  */\n \t      min = max + 1;\n-\t      max = wi::to_wide (TYPE_MAX_VALUE (exptype));\n+\t      max = maxsize;\n+\t    }\n+\t  else\n+\t    {\n+\t      /* ...otherwise use the smaller subrange.  */\n+\t      max = min - 1;\n+\t      min = wi::zero (expprec);\n \t    }\n-\t}\n-      else\n-\t{\n-\t  max = min - 1;\n-\t  min = wi::zero (expprec);\n \t}\n     }\n "}, {"sha": "644ec45d92c4abc2e5fb87bac9f71a40b9fc4f28", "filename": "gcc/calls.h", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83685efd5fd1623cfc4e4c435ce2773d95d458d1/gcc%2Fcalls.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83685efd5fd1623cfc4e4c435ce2773d95d458d1/gcc%2Fcalls.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.h?ref=83685efd5fd1623cfc4e4c435ce2773d95d458d1", "patch": "@@ -133,7 +133,15 @@ extern bool reference_callee_copied (CUMULATIVE_ARGS *,\n extern void maybe_warn_alloc_args_overflow (tree, tree, tree[2], int[2]);\n extern tree get_attr_nonstring_decl (tree, tree * = NULL);\n extern bool maybe_warn_nonstring_arg (tree, tree);\n-extern bool get_size_range (tree, tree[2], bool = false);\n+enum size_range_flags\n+  {\n+   /* Set to consider zero a valid range.  */\n+   SR_ALLOW_ZERO = 1,\n+   /* Set to use the largest subrange of a set of ranges as opposed\n+      to the smallest.  */\n+   SR_USE_LARGEST = 2\n+  };\n+extern bool get_size_range (tree, tree[2], int = 0);\n extern rtx rtx_for_static_chain (const_tree, bool);\n extern bool cxx17_empty_base_field_p (const_tree);\n "}, {"sha": "e2734c81456940497964bd55af2246653bd33e00", "filename": "gcc/gimple-ssa-warn-restrict.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83685efd5fd1623cfc4e4c435ce2773d95d458d1/gcc%2Fgimple-ssa-warn-restrict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83685efd5fd1623cfc4e4c435ce2773d95d458d1/gcc%2Fgimple-ssa-warn-restrict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-warn-restrict.c?ref=83685efd5fd1623cfc4e4c435ce2773d95d458d1", "patch": "@@ -264,7 +264,7 @@ builtin_memref::builtin_memref (tree expr, tree size)\n       tree range[2];\n       /* Determine the size range, allowing for the result to be [0, 0]\n \t for SIZE in the anti-range ~[0, N] where N >= PTRDIFF_MAX.  */\n-      get_size_range (size, range, true);\n+      get_size_range (size, range, SR_ALLOW_ZERO);\n       sizrange[0] = wi::to_offset (range[0]);\n       sizrange[1] = wi::to_offset (range[1]);\n       /* get_size_range returns SIZE_MAX for the maximum size."}, {"sha": "9eb02bdbfcb172ee2ccd1477096f9d6fe4588fa2", "filename": "gcc/testsuite/c-c++-common/Wrestrict.c", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83685efd5fd1623cfc4e4c435ce2773d95d458d1/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWrestrict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83685efd5fd1623cfc4e4c435ce2773d95d458d1/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWrestrict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWrestrict.c?ref=83685efd5fd1623cfc4e4c435ce2773d95d458d1", "patch": "@@ -320,14 +320,17 @@ void test_memcpy_anti_range (char *d, const char *s)\n \n   T (d, d + SAR (0, 3), UR (DIFF_MAX - 2, DIFF_MAX));               /* { dg-warning \"accessing \\[0-9\\]+ or more bytes at offsets 0 and \\\\\\[-?\\[0-9\\]+, -?\\[0-9\\]+] overlaps \\[0-9\\]+ bytes at offset 2\" \"memcpy\" } */\n \n-  /* Verify that a size in an anti-range ~[0, N] where N >= PTRDIFF_MAX\n-     doesn't trigger a warning.  */\n+  /* Verify that a size in an anti-range ~[1, N] where N >= PTRDIFF_MAX - 2\n+     doesn't trigger a warning.\n+     With ~[1, PTRDIFF_MAX - 1] the difference between the just-past-the-end\n+     pointer to A and A for char A[PTRDIFF_MAX] wouldn't be representable in\n+     ptrdiff_t.  Since such a large object cannot exist, so the size of\n+     the region must be zero.  */\n+  T (d, s, UAR (1, DIFF_MAX / 2 - 1));\n   T (d, s, UAR (1, DIFF_MAX - 1));\n   T (d, s, UAR (1, DIFF_MAX));\n   T (d, s, UAR (1, SIZE_MAX - 1));\n-\n-  /* This causes the last dg-warning test to fail for some reason.\n-     T (d, s, UAR (1, SIZE_MAX)); */\n+  T (d, s, UAR (1, SIZE_MAX));\n }\n \n /* Verify calls to memcpy() where the combination of offsets in some"}, {"sha": "a0d136266ea4f12a83822dfc2e8c9432a3018a50", "filename": "gcc/testsuite/g++.dg/warn/Wplacement-new-size-8.C", "status": "added", "additions": 147, "deletions": 0, "changes": 147, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83685efd5fd1623cfc4e4c435ce2773d95d458d1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWplacement-new-size-8.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83685efd5fd1623cfc4e4c435ce2773d95d458d1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWplacement-new-size-8.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWplacement-new-size-8.C?ref=83685efd5fd1623cfc4e4c435ce2773d95d458d1", "patch": "@@ -0,0 +1,147 @@\n+/* Verify informational notes following the warning.\n+   { dg-do compile }\n+   { dg-options \"-Wall\" } */\n+\n+#define DISS_MAX  __PTRDIFF_MAX__\n+#define SIZE_MAX  __SIZE_MAX__\n+\n+typedef __SIZE_TYPE__  size_t;\n+\n+template <int N> struct S { char a[N]; };\n+\n+void* operator new (size_t, void *p) { return p; }\n+void* operator new[] (size_t, void *p) { return p; }\n+\n+\n+void test_cst_off ()\n+{\n+  {\n+    char ca0[0];                // { dg-message \"'ca0' declared here\" \"note\" }\n+    new (ca0 + 0) S<1>;         // { dg-warning \"constructing an object of type 'S<1>' and size '1' in a region of type 'char \\\\\\[0]' and size '0'\" }\n+  }\n+  {\n+    char ca1[1];\n+    new (ca1 + 0) S<1>;\n+  }\n+  {\n+    char ca1[1];                // { dg-message \"'ca1' declared here\" \"note\" }\n+    new (ca1 + 0) S<2>;         // { dg-warning \"constructing an object of type 'S<2>' and size '2' in a region of type 'char \\\\\\[1]' and size '1'\" }\n+  }\n+  {\n+    char ca1[1];                // { dg-message \"at offset 1 from 'ca1' declared here\" \"note\" }\n+    new (ca1 + 1) S<1>;         // { dg-warning \"constructing an object of type 'S<1>' and size '1' in a region of type 'char \\\\\\[1]' and size '0'\" }\n+  }\n+  {\n+    char ca1[1];                // { dg-message \"at offset 2 from 'ca1' declared here\" \"note\" }\n+    new (ca1 + 2) S<1>;         // { dg-warning \"constructing an object of type 'S<1>' and size '1' in a region of type 'char \\\\\\[1]' and size '0'\" }\n+  }\n+  {\n+    char ca1[1];                // { dg-message \"at offset -1 from 'ca1' declared here\" \"note\" }\n+    new (ca1 - 1) S<1>;         // { dg-warning \"constructing an object of type 'S<1>' and size '1' in a region of type 'char \\\\\\[1]' and size '0'\" }\n+  }\n+  {\n+    /* Offsets are treated as signed so SIZE_MAX is indistinguishable\n+       from -1.  */\n+    char ca1[1];                // { dg-message \"at offset \\\\d+ from 'ca1' declared here\" \"note\" { xfail *-*-* } }\n+                                // { dg-message \"at offset -1 from 'ca1' declared here\" \"note\" { target *-*-* } .-1 }\n+    new (ca1 + SIZE_MAX) S<1>;  // { dg-warning \"constructing an object of type 'S<1>' and size '1' in a region of type 'char \\\\\\[1]' and size '0'\" }\n+  }\n+}\n+\n+\n+/* Verify that the range of the offset included in the note corresponds\n+   to the range of its type (plus the optional constant).  */\n+\n+void test_var_off_uchar (unsigned char i)\n+{\n+  {\n+    // Verify that the nore doesn't mention an offset.\n+    char ca0[0];                // { dg-message \": 'ca0' declared here\" \"note\" }\n+    new (ca0 + i) S<1>;         // { dg-warning \"constructing an object of type 'S<1>' and size '1' in a region of type 'char \\\\\\[0]' and size '0'\" }\n+  }\n+  {\n+    char ca1[1];\n+    new (ca1 + i) S<1>;\n+  }\n+  {\n+    // Verify that the nore doesn't mention an offset.\n+    char ca1[1];                // { dg-message \": 'ca1' declared here\" \"note\" }\n+    new (ca1 + i) S<2>;         // { dg-warning \"constructing an object of type 'S<2>' and size '2' in a region of type 'char \\\\\\[1]' and size at most '1'\" }\n+  }\n+  {\n+    char ca2[2];\n+    new (ca2 + i) S<2>;\n+    new (ca2 + 1 - i) S<2>;\n+    new (ca2 - i + 1) S<2>;\n+    new (ca2 - 2 + i) S<2>;\n+    new (ca2 - i + 2) S<2>;\n+    new (ca2 - i + i) S<2>;\n+    new (ca2 + i + i) S<2>;\n+  }\n+  {\n+    char ca2[2];                // { dg-message \"at offset \\\\\\[1, 2] from 'ca2' declared here\" \"note\" }\n+    new (ca2 + i + 1) S<2>;     // { dg-warning \"constructing an object of type 'S<2>' and size '2' in a region of type 'char \\\\\\[2]' and size at most '1'\" }\n+  }\n+\n+  {\n+    char a[65281];\n+    new (a + i + 65280) S<1>;\n+  }\n+  {\n+    char a[65281];              // { dg-message \"at offset 65281 from 'a' declared here\" \"note\" }\n+    new (a + i + 65281) S<1>;   // { dg-warning \"constructing an object of type 'S<1>' and size '1' in a region of type 'char \\\\\\[65281]' and size '0'\" }\n+  }\n+  {\n+    char a[65281];              // { dg-message \"at offset \\\\\\[65154, 65281] from 'a' declared here\" \"note\" }\n+    new (a + i + 65154) S<128>; // { dg-warning \"constructing an object of type 'S<128>' and size '128' in a region of type 'char \\\\\\[65281]' and size at most '127'\" }\n+  }\n+}\n+\n+\n+/* Same as above but also verify that the signedness of the offset is\n+   considered in the issuing the warning.  */\n+\n+void test_var_off_schar (signed char i)\n+{\n+  {\n+    // Verify that the nore doesn't mention an offset.\n+    char ca0[0];                // { dg-message \": 'ca0' declared here\" \"note\" }\n+    new (ca0 + i) S<1>;         // { dg-warning \"constructing an object of type 'S<1>' and size '1' in a region of type 'char \\\\\\[0]' and size '0'\" }\n+  }\n+  {\n+    char ca1[1];\n+    new (ca1 + i) S<1>;\n+    new (ca1 - i) S<1>;\n+    new (ca1 + i + 1) S<1>;\n+    new (ca1 - i + 1) S<1>;\n+    new (ca1 + i + i) S<1>;\n+    new (ca1 - i - i) S<1>;\n+  }\n+  {\n+    // Verify that the nore doesn't mention an offset.\n+    char ca1[1];                // { dg-message \": 'ca1' declared here\" \"note\" }\n+    new (ca1 + i) S<2>;         // { dg-warning \"constructing an object of type 'S<2>' and size '2' in a region of type 'char \\\\\\[1]' and size at most '1'\" }\n+  }\n+  {\n+    char ca2[2];\n+    new (ca2 + i) S<2>;\n+    new (ca2 + 1 - i) S<2>;\n+    new (ca2 - i + 1) S<2>;\n+    new (ca2 - 2 + i) S<2>;\n+    new (ca2 - i + 2) S<2>;\n+    new (ca2 - i + i) S<2>;\n+    new (ca2 + i + i) S<2>;\n+  }\n+  {\n+    char ca2[2];\n+    new (ca2 + i + 1) S<2>;\n+  }\n+\n+  {\n+    char a[65281];              // { dg-message \"at offset \\\\\\[65153, 65408] from 'a'\" }\n+    new (a + i + 65280) S<1>;\n+    new (a + i + 65281) S<1>;\n+    new (a + i + 65281) S<128>;\n+    new (a + i + 65281) S<129>; // { dg-warning \"constructing an object of type 'S<129>' and size '129' in a region of type 'char \\\\\\[65281]' and size at most '128'\" }\n+  }\n+}"}, {"sha": "a1b103918cff509d241217875d74e3a7a9e3678e", "filename": "gcc/testsuite/gcc.dg/Wstringop-overflow-34.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83685efd5fd1623cfc4e4c435ce2773d95d458d1/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-34.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83685efd5fd1623cfc4e4c435ce2773d95d458d1/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-34.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-34.c?ref=83685efd5fd1623cfc4e4c435ce2773d95d458d1", "patch": "@@ -112,7 +112,7 @@ void s2_warn_cstoff_cstidx (struct S2 *p)\n void s2_warn_varoff_cstdix (struct S2 *p, int i)\n {\n   char *q = p->a + i;\n-  q[2] = __LINE__;            // { dg-warning \"\\\\\\[-Wstringop-overflow\" \"pr?????\" { xfail *-*-* }  }\n+  q[2] = __LINE__;            // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n }\n \n void s2_warn_cstoff_varidx (struct S2 *p, int i)"}, {"sha": "9b2d2cbc5015d96e46805d49d4cda3bec5343e15", "filename": "gcc/testsuite/gcc.dg/Wstringop-overflow-41.c", "status": "added", "additions": 120, "deletions": 0, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83685efd5fd1623cfc4e4c435ce2773d95d458d1/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-41.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83685efd5fd1623cfc4e4c435ce2773d95d458d1/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-41.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-41.c?ref=83685efd5fd1623cfc4e4c435ce2773d95d458d1", "patch": "@@ -0,0 +1,120 @@\n+/* Verify that writes at excessive offsets into declared or allocated\n+   objects of unknown size are diagnosed.\n+   { dg-do compile }\n+   { dg-options \"-O2\" } */\n+\n+#define DIFF_MAX __PTRDIFF_MAX__\n+\n+typedef __SIZE_TYPE__ size_t;\n+\n+void* malloc (size_t);\n+void* memcpy (void*, const void*, size_t);\n+void* memset (void*, int, size_t);\n+\n+void sink (void*);\n+\n+\n+void char_array_cst_off_cst_size (void)\n+{\n+  extern char caxcc[];                  // { dg-message \"at offset \\\\d+ into destination object 'caxcc'\" }\n+\n+  char *p = caxcc;\n+  size_t idx = DIFF_MAX - 3;\n+\n+  memset (p + idx, 0, 3);\n+  sink (p);\n+\n+  ++idx;\n+  memset (p + idx, 0, 3);               // { dg-warning \"writing 3 bytes into a region of size 2\" }\n+  sink (p);\n+\n+  ++idx;\n+  memset (p + idx, 0, 3);               // { dg-warning \"writing 3 bytes into a region of size 1\" \"pr?????\" { xfail ilp32 } }\n+\n+  ++idx;\n+  memset (p + idx, 0, 3);               // { dg-warning \"writing 3 bytes into a region of size 0\" }\n+  sink (p);\n+}\n+\n+\n+void char_array_var_off_cst_size (size_t idx)\n+{\n+  /* The offset is a range with a very large lower bound and an upper\n+     bound of DIFF_MAX.  There's not point in also mentioning the latter\n+     (it wouldn't make the note any more meaningful) so verify it only\n+     mentions the lower bound.  */\n+  extern char caxvc[];                  // { dg-message \"at offset \\\\d+ into destination object 'caxvc'\" \"note\" }\n+\n+  char *p = caxvc;\n+\n+  if (idx < DIFF_MAX - 3)\n+    idx = DIFF_MAX - 3;\n+\n+  memset (p + idx, 0, 3);\n+  sink (p);\n+\n+  memset (p + idx, 0, 5);               // { dg-warning \"writing 5 bytes into a region of size 3\" }\n+  sink (p);\n+}\n+\n+\n+void char_array_var_off_var_size (size_t idx, size_t n)\n+{\n+  extern char caxvv[];                  // { dg-message \"at offset \\\\d+ into destination object 'caxvv'\" \"note\" }\n+\n+  char *p = caxvv;\n+\n+  if (idx < DIFF_MAX - 3)\n+    idx = DIFF_MAX - 3;\n+\n+  if (n < 3 || 7 < n)\n+    n = 3;\n+\n+  memset (p + idx, 0, n);\n+  sink (p);\n+\n+  ++n;\n+  memset (p + idx, 0, n);               // { dg-warning \"writing between 4 and 8 bytes into a region of size 3\" }\n+  sink (p);\n+}\n+\n+\n+void alloc_array_var_off_cst_size (size_t n, size_t idx)\n+{\n+  char *p = malloc (n);                 // { dg-message \"at offset \\\\d+ into destination object\" \"note\" }\n+\n+  if (idx < DIFF_MAX - 3)\n+    idx = DIFF_MAX - 3;\n+\n+  memset (p + idx, 0, 3);\n+  sink (p);\n+\n+  memset (p + idx, 0, 5);               // { dg-warning \"writing 5 bytes into a region of size 3\" }\n+  sink (p);\n+}\n+\n+\n+void int_array_cst_off_cst_size (void)\n+{\n+  extern int iaxc[];                    // { dg-message \"at offset \\[1-9\\]\\[0-9\\]+ into destination object 'iaxc'\" }\n+\n+  int *p = iaxc;\n+  size_t idx = DIFF_MAX / sizeof *iaxc;\n+\n+  memset (p + idx, 0, 3);\n+  sink (p);\n+\n+  memset (p + idx, 0, 5);               // { dg-warning \"writing 5 bytes into a region of size 3\" }\n+  sink (p);\n+}\n+\n+\n+void* nowarn_anti_range_1 (char *p, char *q)\n+{\n+  size_t n = q - p;\n+  if (!n) return 0;\n+\n+  char *d = __builtin_malloc (n + 1);\n+  memcpy (d, p, n + 1);                 // { dg-bogus \"-Wstringop-overflow\" }\n+  return d;\n+}"}, {"sha": "14ab925afdce9263582f3a0aecc7c29f3b29df54", "filename": "gcc/testsuite/gcc.dg/Wstringop-overflow-43.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83685efd5fd1623cfc4e4c435ce2773d95d458d1/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-43.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83685efd5fd1623cfc4e4c435ce2773d95d458d1/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-43.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-43.c?ref=83685efd5fd1623cfc4e4c435ce2773d95d458d1", "patch": "@@ -159,9 +159,10 @@ void warn_memset_reversed_range (void)\n \n   char *p = &a11[11];\n \n-  /* The below is represented as a true anti-range as opposed to a range\n-     with reversed bounds and the former aren't handled.  */\n-  T1 (p, SAR (INT_MIN, -11), n11);      // { dg-warning \"writing 11 or more bytes into a region of size 0\" \"pr?????\" { xfail *-*-* } }\n+  /* Since the offset is excessive, either starting before &a11[0]\n+     ot just past &a[11], the region size in the warning should\n+     probably be zero, but accept other sizes too.  */\n+  T1 (p, SAR (INT_MIN, -11), n11);      // { dg-warning \"writing 11 or more bytes into a region of size \\\\d+\" }\n \n   /* The following are represented as ordinary ranges with reversed bounds\n      and those are handled. */\n@@ -171,7 +172,7 @@ void warn_memset_reversed_range (void)\n   T1 (p, SAR (INT_MIN,   1), n11);      // { dg-warning \"writing 11 or more bytes into a region of size 0\" \"pr?????\" { xfail ilp32 } }\n   T1 (p, SAR (INT_MIN,   0), n11);      // { dg-warning \"writing 11 or more bytes into a region of size 0\" }\n   /* Also represented as a true anti-range.  */\n-  T1 (p, SAR (    -12, -11), n11);      // { dg-warning \"writing 11 or more bytes into a region of size 0\" \"pr?????\" { xfail *-*-* } }\n+  T1 (p, SAR (    -12, -11), n11);      // { dg-warning \"writing 11 or more bytes into a region of size \\\\d+\" }\n   T1 (p, SAR (    -12,  -1), n11);      // { dg-warning \"writing 11 or more bytes into a region of size 0\" }\n   T1 (p, SAR (    -11,   0), n11);      // { dg-warning \"writing 11 or more bytes into a region of size 0\" }\n   T1 (p, SAR (    -11,  11), n11);      // { dg-warning \"writing 11 or more bytes into a region of size 0\" }"}, {"sha": "0fc73a99078a260badbfea906ff2f4a790a0c1a5", "filename": "gcc/testsuite/gcc.dg/Wstringop-overflow-44.s", "status": "added", "additions": 271, "deletions": 0, "changes": 271, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83685efd5fd1623cfc4e4c435ce2773d95d458d1/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-44.s", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83685efd5fd1623cfc4e4c435ce2773d95d458d1/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-44.s", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-44.s?ref=83685efd5fd1623cfc4e4c435ce2773d95d458d1", "patch": "@@ -0,0 +1,271 @@\n+\t.file\t\"Wstringop-overflow-44.c\"\n+\t.text\n+\t.p2align 4\n+\t.globl\tf0\n+\t.type\tf0, @function\n+f0:\n+.LFB0:\n+\t.cfi_startproc\n+\tret\n+\t.cfi_endproc\n+.LFE0:\n+\t.size\tf0, .-f0\n+\t.p2align 4\n+\t.globl\tf1\n+\t.type\tf1, @function\n+f1:\n+.LFB1:\n+\t.cfi_startproc\n+\tret\n+\t.cfi_endproc\n+.LFE1:\n+\t.size\tf1, .-f1\n+\t.p2align 4\n+\t.globl\tf2\n+\t.type\tf2, @function\n+f2:\n+.LFB2:\n+\t.cfi_startproc\n+\tmovl\tn(%rip), %eax\n+\ttestl\t%eax, %eax\n+\tjle\t.L12\n+.L4:\n+\tret\n+\t.p2align 4,,10\n+\t.p2align 3\n+.L12:\n+\tmovslq\t%eax, %rdx\n+\tmovq\td(%rip), %rcx\n+\ttestq\t%rdx, %rdx\n+\tje\t.L4\n+\txorl\t%eax, %eax\n+.L6:\n+\tmovb\t$0, (%rcx,%rax)\n+\taddq\t$1, %rax\n+\tcmpq\t%rdx, %rax\n+\tjb\t.L6\n+\tret\n+\t.cfi_endproc\n+.LFE2:\n+\t.size\tf2, .-f2\n+\t.p2align 4\n+\t.globl\tf3\n+\t.type\tf3, @function\n+f3:\n+.LFB3:\n+\t.cfi_startproc\n+\tmovslq\tn(%rip), %rdx\n+\ttestl\t%edx, %edx\n+\tjle\t.L15\n+\tret\n+\t.p2align 4,,10\n+\t.p2align 3\n+.L15:\n+\tmovq\t%rdi, %rsi\n+\tmovq\td(%rip), %rdi\n+\tjmp\tstrncpy\n+\t.cfi_endproc\n+.LFE3:\n+\t.size\tf3, .-f3\n+\t.p2align 4\n+\t.globl\tf4\n+\t.type\tf4, @function\n+f4:\n+.LFB4:\n+\t.cfi_startproc\n+\tmovl\tn(%rip), %eax\n+\ttestl\t%eax, %eax\n+\tjle\t.L18\n+\tret\n+\t.p2align 4,,10\n+\t.p2align 3\n+.L18:\n+\tmovq\td(%rip), %rax\n+\tmovq\t%rdi, %rsi\n+\tmovb\t$0, (%rax)\n+\tmovslq\tn(%rip), %rdx\n+\tmovq\td(%rip), %rdi\n+\tjmp\tstrncat\n+\t.cfi_endproc\n+.LFE4:\n+\t.size\tf4, .-f4\n+\t.p2align 4\n+\t.globl\tg0\n+\t.type\tg0, @function\n+g0:\n+.LFB5:\n+\t.cfi_startproc\n+\tmovl\tn(%rip), %eax\n+\ttestl\t%eax, %eax\n+\tjle\t.L25\n+\tret\n+\t.p2align 4,,10\n+\t.p2align 3\n+.L25:\n+\tsubq\t$24, %rsp\n+\t.cfi_def_cfa_offset 32\n+\tleaq\t15(%rsp), %rdi\n+\tcall\tsink\n+\taddq\t$24, %rsp\n+\t.cfi_def_cfa_offset 8\n+\tret\n+\t.cfi_endproc\n+.LFE5:\n+\t.size\tg0, .-g0\n+\t.p2align 4\n+\t.globl\tg1\n+\t.type\tg1, @function\n+g1:\n+.LFB6:\n+\t.cfi_startproc\n+\tmovl\tn(%rip), %eax\n+\ttestl\t%eax, %eax\n+\tjle\t.L32\n+\tret\n+\t.p2align 4,,10\n+\t.p2align 3\n+.L32:\n+\tsubq\t$24, %rsp\n+\t.cfi_def_cfa_offset 32\n+\tleaq\t15(%rsp), %rdi\n+\tcall\tsink\n+\taddq\t$24, %rsp\n+\t.cfi_def_cfa_offset 8\n+\tret\n+\t.cfi_endproc\n+.LFE6:\n+\t.size\tg1, .-g1\n+\t.p2align 4\n+\t.globl\tg2\n+\t.type\tg2, @function\n+g2:\n+.LFB7:\n+\t.cfi_startproc\n+\tmovl\tn(%rip), %eax\n+\ttestl\t%eax, %eax\n+\tjle\t.L45\n+\tret\n+\t.p2align 4,,10\n+\t.p2align 3\n+.L45:\n+\tmovslq\t%eax, %rdx\n+\tsubq\t$24, %rsp\n+\t.cfi_def_cfa_offset 32\n+\ttestq\t%rdx, %rdx\n+\tje\t.L36\n+\txorl\t%eax, %eax\n+.L35:\n+\tmovb\t$0, 15(%rsp,%rax)\n+\taddq\t$1, %rax\n+\tcmpq\t%rdx, %rax\n+\tjb\t.L35\n+.L36:\n+\tleaq\t15(%rsp), %rdi\n+\tcall\tsink\n+\taddq\t$24, %rsp\n+\t.cfi_def_cfa_offset 8\n+\tret\n+\t.cfi_endproc\n+.LFE7:\n+\t.size\tg2, .-g2\n+\t.p2align 4\n+\t.globl\tg3\n+\t.type\tg3, @function\n+g3:\n+.LFB8:\n+\t.cfi_startproc\n+\tmovslq\tn(%rip), %rdx\n+\ttestl\t%edx, %edx\n+\tjle\t.L52\n+\tret\n+\t.p2align 4,,10\n+\t.p2align 3\n+.L52:\n+\tsubq\t$24, %rsp\n+\t.cfi_def_cfa_offset 32\n+\tmovq\t%rdi, %rsi\n+\tleaq\t15(%rsp), %rdi\n+\tcall\tstrncpy\n+\tleaq\t15(%rsp), %rdi\n+\tcall\tsink\n+\taddq\t$24, %rsp\n+\t.cfi_def_cfa_offset 8\n+\tret\n+\t.cfi_endproc\n+.LFE8:\n+\t.size\tg3, .-g3\n+\t.p2align 4\n+\t.globl\tg4\n+\t.type\tg4, @function\n+g4:\n+.LFB9:\n+\t.cfi_startproc\n+\tmovslq\tn(%rip), %rdx\n+\ttestl\t%edx, %edx\n+\tjle\t.L59\n+\tret\n+\t.p2align 4,,10\n+\t.p2align 3\n+.L59:\n+\tsubq\t$24, %rsp\n+\t.cfi_def_cfa_offset 32\n+\tmovq\t%rdi, %rsi\n+\tleaq\t15(%rsp), %rdi\n+\tmovb\t$0, 15(%rsp)\n+\tcall\tstrncat\n+\tleaq\t15(%rsp), %rdi\n+\tcall\tsink\n+\taddq\t$24, %rsp\n+\t.cfi_def_cfa_offset 8\n+\tret\n+\t.cfi_endproc\n+.LFE9:\n+\t.size\tg4, .-g4\n+\t.p2align 4\n+\t.globl\th0\n+\t.type\th0, @function\n+h0:\n+.LFB10:\n+\t.cfi_startproc\n+\tmovl\tn(%rip), %eax\n+\ttestl\t%eax, %eax\n+\tjle\t.L66\n+\tret\n+\t.p2align 4,,10\n+\t.p2align 3\n+.L66:\n+\tsubq\t$8, %rsp\n+\t.cfi_def_cfa_offset 16\n+\tmovl\t$1, %edi\n+\tcall\tmalloc\n+\tmovq\t%rax, d(%rip)\n+\taddq\t$8, %rsp\n+\t.cfi_def_cfa_offset 8\n+\tret\n+\t.cfi_endproc\n+.LFE10:\n+\t.size\th0, .-h0\n+\t.p2align 4\n+\t.globl\th1\n+\t.type\th1, @function\n+h1:\n+.LFB16:\n+\t.cfi_startproc\n+\tmovl\tn(%rip), %eax\n+\ttestl\t%eax, %eax\n+\tjle\t.L73\n+\tret\n+\t.p2align 4,,10\n+\t.p2align 3\n+.L73:\n+\tsubq\t$8, %rsp\n+\t.cfi_def_cfa_offset 16\n+\tmovl\t$1, %edi\n+\tcall\tmalloc\n+\tmovq\t%rax, d(%rip)\n+\taddq\t$8, %rsp\n+\t.cfi_def_cfa_offset 8\n+\tret\n+\t.cfi_endproc\n+.LFE16:\n+\t.size\th1, .-h1"}, {"sha": "112d79a5ae7b329104845771847c58999a29f782", "filename": "gcc/testsuite/gcc.dg/Wstringop-overflow-45.c", "status": "added", "additions": 255, "deletions": 0, "changes": 255, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83685efd5fd1623cfc4e4c435ce2773d95d458d1/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-45.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83685efd5fd1623cfc4e4c435ce2773d95d458d1/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-45.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-45.c?ref=83685efd5fd1623cfc4e4c435ce2773d95d458d1", "patch": "@@ -0,0 +1,255 @@\n+/* PR middle-end/97023 - missing warning on buffer overflow in chained mempcpy\n+   Verify that out of bounds writes by built-ins to objects through pointers\n+   returned by other built-ins are diagnosed.\n+   { dg-do compile }\n+   { dg-options \"-O2\" } */\n+\n+#include \"range.h\"\n+\n+void* malloc (size_t);\n+void* memcpy (void*, const void*, size_t);\n+void* memmove (void*, const void*, size_t);\n+void* mempcpy (void*, const void*, size_t);\n+\n+void sink (void*, ...);\n+\n+\n+void nowarn_memcpy (const void *s)\n+{\n+  extern char cpy_a4[4];\n+  unsigned n = sizeof cpy_a4;\n+\n+  void *p = cpy_a4;\n+  p = memcpy (p, s, n);\n+  sink (p);\n+  memcpy (p, s, n);\n+  sink (p);\n+\n+  p = cpy_a4 + 1;\n+  p = memcpy (p, s, n - 1);\n+  sink (p);\n+  memcpy (p, s, n - 1);\n+  sink (p);\n+\n+  p = cpy_a4 + 2;\n+  p = memcpy (p, s, n - 2);\n+  sink (p);\n+  memcpy (p, s, n - 2);\n+  sink (p);\n+\n+  p = cpy_a4 + 3;\n+  p = memcpy (p, s, n - 3);\n+  sink (p);\n+  memcpy (p, s, n - 3);\n+  sink (p);\n+\n+  p = cpy_a4 + 4;\n+  p = memcpy (p, s, n - 4);\n+  sink (p);\n+  memcpy (p, s, n - 4);\n+  sink (p);\n+}\n+\n+\n+void nowarn_memcpy_chain (const void *s)\n+{\n+  extern char cpy_a8[8];\n+\n+  char *p = cpy_a8;\n+\n+  p = memcpy (p + 1, s, 7);\n+  sink (p);\n+\n+  p = memcpy (p + 2 , s, 5);\n+  sink (p);\n+\n+  p = memcpy (p + 3 , s, 2);\n+  sink (p);\n+\n+  p = memcpy (p + 1 , s, 1);\n+  sink (p);\n+\n+  p = memcpy (p - 7 , s, 8);\n+  sink (p);\n+\n+  memcpy (p + 1, s, 7);\n+}\n+\n+\n+void warn_memcpy (const void *s)\n+{\n+  extern char cpy_a5[5];                // { dg-message \"destination object 'cpy_a5'\" \"note\" }\n+\n+  unsigned n = sizeof cpy_a5;\n+  void *p = cpy_a5;\n+\n+  p = memcpy (p, s, n);\n+  sink (p);\n+  memcpy (p, s, n + 1);                 // { dg-warning \"writing 6 bytes into a region of size 5\" }\n+  sink (p);\n+\n+  p = cpy_a5;\n+  p = memcpy (p, s, n);\n+  sink (p);\n+  memcpy (p, s, n + 1);                 // { dg-warning \"writing 6 bytes into a region of size 5\" }\n+  sink (p);\n+\n+  p = cpy_a5 + 1;\n+  p = memcpy (p, s, n - 1);\n+  sink (p);\n+  memcpy (p, s, n);                     // { dg-warning \"writing 5 bytes into a region of size 4\" }\n+  sink (p);\n+}\n+\n+\n+void warn_memcpy_chain (const void *s)\n+{\n+  extern char cpy_a8[8];                // { dg-message \"destination object 'cpy_a8'\" \"note\" }\n+\n+  char *p = cpy_a8;\n+\n+  p = memcpy (p, s, 9);                 // { dg-warning \"writing 9 bytes into a region of size 8\" }\n+  sink (p);\n+\n+  p = memcpy (p + 2, s, 7);             // { dg-warning \"writing 7 bytes into a region of size 6\" }\n+  sink (p);\n+\n+  p = memcpy (p + 3, s, 5);             // { dg-warning \"writing 5 bytes into a region of size 3\" }\n+  sink (p);\n+\n+  p = memcpy (p + 3, s, 3);             // { dg-warning \"writing 3 bytes into a region of size 0\" }\n+  sink (p);\n+}\n+\n+\n+void nowarn_mempcpy (const void *s)\n+{\n+  extern char a4[4];\n+  unsigned n = sizeof a4;\n+\n+  char *p = mempcpy (a4, s, n);\n+  sink (p);\n+  mempcpy (p - 4, s, n);\n+  sink (p);\n+\n+  p = mempcpy (a4 + 1, s, n - 1);\n+  sink (p);\n+  mempcpy (p - 4, s, n);\n+  sink (p);\n+\n+  p = mempcpy (a4 + 2, s, n - 2);\n+  sink (p);\n+  mempcpy (p - 4, s, n);\n+  sink (p);\n+\n+  p = mempcpy (a4 + 3, s, n - 3);\n+  sink (p);\n+  mempcpy (p - 4, s, n);\n+  sink (p);\n+\n+  p = mempcpy (a4 + 4, s, n - 4);\n+  sink (p);\n+  mempcpy (p - 4, s, n);\n+  sink (p);\n+}\n+\n+\n+void nowarn_mempcpy_chain (const void *s)\n+{\n+  extern char pcpy_a8[8];\n+\n+  char *p = pcpy_a8;\n+\n+  p = mempcpy (p + 1, s, 7);\n+  sink (p);\n+\n+  p = mempcpy (p - 7 , s, 7);\n+  sink (p);\n+\n+  p = mempcpy (p - 5 , s, 5);\n+  sink (p);\n+\n+  p = mempcpy (p - 3 , s, 3);\n+  sink (p);\n+\n+  p = mempcpy (p - 2 , s, 2);\n+  sink (p);\n+\n+  mempcpy (p - 1, s, 1);\n+  sink (p);\n+\n+  mempcpy (p - 8, s, 8);\n+}\n+\n+\n+void warn_mempcpy (const void *s)\n+{\n+  extern char pcpy_a5[5];               // { dg-message \"destination object 'pcpy_a5'\" \"note\" }\n+\n+  char *p = pcpy_a5;\n+\n+  p = mempcpy (p, s, 5);\n+  sink (p);\n+  mempcpy (p - 5, s, 6);                // { dg-warning \"writing 6 bytes into a region of size 5 \" }\n+  sink (p);\n+\n+  p = pcpy_a5;\n+  p = mempcpy (p, s, 3);\n+  sink (p);\n+  mempcpy (p, s, 3);                    // { dg-warning \"writing 3 bytes into a region of size 2 \" }\n+  sink (p);\n+\n+  p = pcpy_a5 + 1;\n+  p = mempcpy (p, s, 3);\n+  sink (p);\n+  mempcpy (p - 1, s, 5);                // { dg-warning \"writing 5 bytes into a region of size 2 \" }\n+  sink (p);\n+}\n+\n+\n+void warn_mempcpy_chain_3 (const void *s)\n+{\n+  char *p = malloc (5);                 // { dg-message \"at offset \\\\\\[3, 5] into destination object of size 5\" \"note\" }\n+  p = mempcpy (p, s, UR (1, 2));\n+  p = mempcpy (p, s, UR (2, 3));\n+  p = mempcpy (p, s, UR (3, 4));        // { dg-warning \"writing between 3 and 4 bytes into a region of size 2 \" }\n+\n+  sink (p);\n+}\n+\n+void warn_mempcpy_offrng_chain_3 (const void *s)\n+{\n+  char *p = malloc (11);                 // { dg-message \"at offset \\\\\\[9, 11] into destination object of size 11 \" \"note\" }\n+  size_t r1_2 = UR (1, 2);\n+  size_t r2_3 = r1_2 + 1;\n+  size_t r3_4 = r2_3 + 1;\n+\n+  p = mempcpy (p + r1_2, s, r1_2);\n+  p = mempcpy (p + r2_3, s, r2_3);\n+  p = mempcpy (p + r3_4, s, r3_4);       // { dg-warning \"writing between 3 and 4 bytes into a region of size 2 \" }\n+\n+  sink (p);\n+}\n+\n+void warn_mempcpy_chain_4 (const void *s)\n+{\n+  char *p = malloc (9);                 // { dg-message \"at offset \\\\\\[6, 9] into destination object of size 9 \" \"note\" }\n+  p = mempcpy (p, s, UR (1, 2));\n+  p = mempcpy (p, s, UR (2, 3));\n+  p = mempcpy (p, s, UR (3, 4));\n+  p = mempcpy (p, s, UR (4, 5));        // { dg-warning \"writing between 4 and 5 bytes into a region of size 3 \" }\n+\n+  sink (p);\n+}\n+\n+void warn_mempcpy_chain_5 (const void *s)\n+{\n+  char *p = malloc (14);                // { dg-message \"at offset \\\\\\[10, 14] into destination object of size 14 \" \"note\" }\n+  p = mempcpy (p, s, UR (1, 2));\n+  p = mempcpy (p, s, UR (2, 3));\n+  p = mempcpy (p, s, UR (3, 4));\n+  p = mempcpy (p, s, UR (4, 5));\n+  p = mempcpy (p, s, UR (5, 6));        // { dg-warning \"writing between 5 and 6 bytes into a region of size 4 \" }\n+\n+  sink (p);\n+}"}, {"sha": "a4d78b21cd142b63aff071cfdece78aef6bc41f9", "filename": "gcc/testsuite/gcc.dg/Wstringop-overflow-46.c", "status": "added", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83685efd5fd1623cfc4e4c435ce2773d95d458d1/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-46.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83685efd5fd1623cfc4e4c435ce2773d95d458d1/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-46.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-46.c?ref=83685efd5fd1623cfc4e4c435ce2773d95d458d1", "patch": "@@ -0,0 +1,97 @@\n+/* PR middle-end/97023 - missing warning on buffer overflow in chained mempcpy\n+   Verify that out of bounds writes by built-ins to objects through pointers\n+   returned by memchr() are diagnosed.\n+   { dg-do compile }\n+   { dg-options \"-O2\" } */\n+\n+#include \"range.h\"\n+\n+void* malloc (size_t);\n+void* memchr (void*, int, size_t);\n+void* memset (void*, int, size_t);\n+\n+void sink (void*, ...);\n+\n+void nowarn_memchr_cst_memset_cst (const void *s)\n+{\n+  char *p = malloc (4);\n+  sink (p);\n+\n+  p = memchr (p, '1', 4);\n+  memset (p, 0, 4);\n+}\n+\n+void nowarn_memchr_uint_memset_cst (const void *s, unsigned n)\n+{\n+  char *p = malloc (4);\n+  sink (p);\n+\n+  p = memchr (p, '1', n);\n+  memset (p, 0, 4);\n+}\n+\n+void nowarn_memchr_sz_memset_cst (const void *s, size_t n)\n+{\n+  char *p = malloc (4);\n+  sink (p);\n+\n+  p = memchr (p, '1', n);\n+  memset (p, 0, 4);\n+}\n+\n+void nowarn_memchr_anti_range_memset_cst (const void *s, size_t n)\n+{\n+  char *p = malloc (4);\n+  sink (p);\n+\n+  if (n == 0)\n+    n = 1;\n+\n+  p = memchr (p, '1', n);\n+  memset (p, 0, 4);\n+}\n+\n+void warn_memchr_cst_memset_cst (const void *s)\n+{\n+  char *p = malloc (4);                 // { dg-message \"at offset \\\\\\[0, 4] into destination object of size 4 \" \"note\" }\n+  sink (p);\n+\n+  p = memchr (p, '1', 4);\n+  memset (p, 0, 5);                     // { dg-warning \"writing 5 bytes into a region of size 4 \" }\n+}\n+\n+void warn_memchr_var_memset_cst (const void *s, unsigned n)\n+{\n+  char *p = malloc (4);                 // { dg-message \"at offset \\\\\\[0, 4] into destination object of size 4 \" \"note\" }\n+  sink (p);\n+\n+  p = memchr (p, '1', n);\n+  memset (p, 0, 5);                     // { dg-warning \"writing 5 bytes into a region of size 4 \" }\n+}\n+\n+void warn_memchr_var_memset_range (const void *s, unsigned n)\n+{\n+  /* The offsets in the first two notes are bounded by the size of\n+     the allocated object.  The real upper bound of the offset in\n+     the last note includes the upper bound f the offset of the pointer\n+     returned from the previous memchr() call, but it ends up getting\n+     constrained to the bounds of the allocated object so it's the same\n+     as in the first two notes.  The exact value probably isn't too\n+     important. */\n+  char *p0 = malloc (UR (5, 7));\n+  // { dg-message \"at offset \\\\\\[0, 7] into destination object of size \\\\\\[5, 7]\" \"note\" { target *-*-* } .-1 }\n+  // { dg-message \"at offset \\\\\\[1, 7] into destination object of size \\\\\\[5, 7]\" \"note\"  { target *-*-* } .-2 }\n+  // { dg-message \"at offset \\\\\\[2, 7] into destination object of size \\\\\\[5, 7]\" \"note\"  { target *-*-* } .-3 }\n+\n+  sink (p0);\n+  char *p1 = memchr (p0, '1', n);\n+  memset (p1, 0, UR (8, 9));            // { dg-warning \"writing between 8 and 9 bytes into a region of size 7 \" }\n+\n+  sink (p0);\n+  p1 = memchr (p0 + 1, '2', n);\n+  memset (p1, 0, UR (7, 9));            // { dg-warning \"writing between 7 and 9 bytes into a region of size 6 \" }\n+\n+  sink (p0);\n+  char *p2 = memchr (p1 + 1, '3', n);\n+  memset (p2, 0, UR (6, 9));            // { dg-warning \"writing between 6 and 9 bytes into a region of size 5 \" }\n+}"}, {"sha": "02b14ee2eda245ec88cb9dd744aea8c5869966a7", "filename": "gcc/testsuite/gcc.dg/Wstringop-overflow-47.c", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83685efd5fd1623cfc4e4c435ce2773d95d458d1/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-47.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83685efd5fd1623cfc4e4c435ce2773d95d458d1/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-47.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-47.c?ref=83685efd5fd1623cfc4e4c435ce2773d95d458d1", "patch": "@@ -0,0 +1,69 @@\n+/* Verify that storing a bigger vector into smaller space is diagnosed.\n+   { dg-do compile }\n+   { dg-options \"-O2\" } */\n+\n+typedef __INT16_TYPE__                         int16_t;\n+typedef __attribute__ ((__vector_size__ (32))) char C32;\n+\n+typedef __attribute__ ((__vector_size__ (64))) int16_t I16_64;\n+\n+void sink (void*);\n+\n+\n+void nowarn_c32 (char c)\n+{\n+  extern char nowarn_a32[32];\n+\n+  void *p = nowarn_a32;\n+  *(C32*)p = (C32){ c };\n+  sink (p);\n+\n+  char a32[32];\n+  p = a32;\n+  *(C32*)p = (C32){ c };\n+  sink (p);\n+}\n+\n+void warn_c32 (char c)\n+{\n+  extern char warn_a32[32];   // { dg-message \"at offset 32 to object 'warn_a32' with size 32\" }\n+\n+  void *p = warn_a32 + 1;\n+  *(C32*)p = (C32){ c };      // { dg-warning \"writing 1 byte into a region of size 0\" }\n+\n+  /* Verify a local variable too. */\n+  char a32[32];\n+  p = a32 + 1;\n+  *(C32*)p = (C32){ c };      // { dg-warning \"writing 1 byte into a region of size 0\" }\n+  sink (p);\n+}\n+\n+\n+void nowarn_i16_64 (int16_t i)\n+{\n+  extern char nowarn_a64[64];\n+\n+  void *p = nowarn_a64;\n+  I16_64 *q = (I16_64*)p;\n+  *q = (I16_64){ i };\n+\n+  char a64[64];\n+  q = (I16_64*)a64;\n+  *q = (I16_64){ i };\n+  sink (q);\n+}\n+\n+void warn_i16_64 (int16_t i)\n+{\n+  extern char warn_a64[64];   // { dg-message \"at offset 128 to object 'warn_a64' with size 64\" \"pr97027\" { xfail *-*-* } }\n+\n+  void *p = warn_a64 + 1;\n+  I16_64 *q = (I16_64*)p;\n+  *q = (I16_64){ i };         // { dg-warning \"writing 1 byte into a region of size 0\" \"pr97027\" { xfail *-*-* } }\n+\n+  char a64[64];\n+  p = a64 + 1;\n+  q = (I16_64*)p;\n+  *q = (I16_64){ i };         // { dg-warning \"writing 1 byte into a region of size 0\" \"pr97027\" { xfail *-*-* } }\n+  sink (p);\n+}"}, {"sha": "84b6c94fa7e17b5e4fca1b3d349cd8fc0a596454", "filename": "gcc/testsuite/gcc.dg/Wstringop-overflow-49.c", "status": "added", "additions": 146, "deletions": 0, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83685efd5fd1623cfc4e4c435ce2773d95d458d1/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-49.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83685efd5fd1623cfc4e4c435ce2773d95d458d1/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-49.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-49.c?ref=83685efd5fd1623cfc4e4c435ce2773d95d458d1", "patch": "@@ -0,0 +1,146 @@\n+/* Verify the handling of anti-ranges/multi-ranges by allocation functions\n+   and subsequent accesses.\n+   { dg-do compile }\n+   { dg-options \"-O2\" } */\n+\n+typedef __SIZE_TYPE__ size_t;\n+\n+void* malloc (size_t);\n+void  bzero (void*, size_t);\n+void* memset (void*, int, size_t);\n+\n+\n+/* Exercise size_t (via malloc and memset) and unsigned/signed int.  */\n+\n+__attribute__ ((alloc_size (1))) void*\n+alloc_int (int);\n+\n+__attribute__ ((access (write_only, 1, 2))) void\n+access_int (void*, int);\n+\n+__attribute__ ((alloc_size (1))) void*\n+alloc_uint (unsigned);\n+\n+__attribute__ ((access (write_only, 1, 2))) void\n+access_uint (void*, unsigned);\n+\n+\n+void* nowarn_malloc_memset_same_anti_range (size_t n)\n+{\n+  /* Set N to the anti-range ~[3, 3].  */\n+  if (n == 3)\n+    n = 4;\n+  void *p = malloc (n);\n+\n+  /* Verify there is no warning for an access to N bytes at P.\n+     This means the warning has to assume the value of N in the call\n+     to alloc() is in the larger subrange [4, UINT_MAX], while in\n+     the call to access() in [0, 3].  */\n+  return memset (p, 0, n);\n+}\n+\n+/* Same as above but with two valid ranges.  */\n+\n+void* nowarn_malloc_memset_anti_range (size_t n1, size_t n2)\n+{\n+  /* Set N1 to the anti-range ~[3, 3].  */\n+  if (n1 == 3)\n+    n1 = 4;\n+  void *p = malloc (n1);\n+\n+  /* Set N2 to the anti-range ~[7, 7].  */\n+  if (n2 == 7)\n+    n2 = 8;\n+\n+  return memset (p, 0, n2);\n+}\n+\n+\n+void nowarn_alloc_access_same_anti_range_int (int n)\n+{\n+  /* Set N to the anti-range ~[3, 3].  */\n+  if (n == 3)\n+    n = 4;\n+  void *p = alloc_int (n);\n+\n+  /* Verify there is no warning for an access to N bytes at P.\n+     This means the warning has to assume the value of N in the call\n+     to alloc() is in the larger subrange [4, UINT_MAX], while in\n+     the call to access() in [0, 3].  */\n+  access_int (p, n);\n+}\n+\n+/* Same as above but with two valid ranges.  */\n+\n+void nowarn_alloc_access_anti_range_int (int n1, int n2)\n+{\n+  /* Set N1 to the anti-range ~[3, 3].  */\n+  if (n1 == 3)\n+    n1 = 4;\n+  void *p = alloc_int (n1);\n+\n+  /* Set N2 to the anti-range ~[7, 7].  */\n+  if (n2 == 7)\n+    n2 = 8;\n+\n+  access_int (p, n2);\n+}\n+\n+\n+void nowarn_alloc_access_same_anti_range_uint (unsigned n)\n+{\n+  /* Set N to the anti-range ~[3, 3].  */\n+  if (n == 3)\n+    n = 4;\n+  void *p = alloc_uint (n);\n+\n+  /* Verify there is no warning for an access to N bytes at P.\n+     This means the warning has to assume the value of N in the call\n+     to alloc() is in the larger subrange [4, UINT_MAX], while in\n+     the call to access() in [0, 3].  */\n+  access_uint (p, n);\n+}\n+\n+/* Same as above but with two valid ranges.  */\n+\n+void nowarn_alloc_access_anti_range_uint (unsigned n1, unsigned n2)\n+{\n+  /* Set N1 to the anti-range ~[3, 3].  */\n+  if (n1 == 3)\n+    n1 = 4;\n+  void *p = alloc_uint (n1);\n+\n+  /* Set N2 to the anti-range ~[7, 7].  */\n+  if (n2 == 7)\n+    n2 = 8;\n+\n+  access_uint (p, n2);\n+}\n+\n+\n+void* nowarn_malloc_anti_range_memset_range (size_t n1, size_t n2)\n+{\n+  /* Set N1 to the anti-range ~[3, 3].  */\n+  if (n1 == 3)\n+    n1 = 4;\n+  void *p = malloc (n1);\n+\n+  /* Set N2 to the range [5, MAX].  */\n+  if (n2 < 5)\n+    n2 = 5;\n+  return memset (p, 0, n2);\n+}\n+\n+void* nowarn_malloc_range_bzero_anti_range (size_t n1, size_t n2)\n+{\n+  /* Set N1 to the anti-range ~[3, 3].  */\n+  if (n1 > 4)\n+    n1 = 4;\n+  void *p = malloc (n1);\n+\n+  /* Set N2 to the range [5, MAX].  */\n+  if (n2 <= 3 || 5 <= n2)\n+    n2 = 4;\n+  bzero (p, n2);\n+  return p;\n+}"}, {"sha": "7df58e5209e12b4a623f6a64caaa30c02eb0559b", "filename": "gcc/testsuite/gcc.dg/Wstringop-overflow-50.c", "status": "added", "additions": 125, "deletions": 0, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83685efd5fd1623cfc4e4c435ce2773d95d458d1/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-50.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83685efd5fd1623cfc4e4c435ce2773d95d458d1/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-50.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-50.c?ref=83685efd5fd1623cfc4e4c435ce2773d95d458d1", "patch": "@@ -0,0 +1,125 @@\n+/* Verify that writes at excessive offsets into objects of unknown size\n+   pointed to by function arguments are diagnosed.\n+   { dg-do compile }\n+   { dg-options \"-O2\" } */\n+\n+#define DIFF_MAX __PTRDIFF_MAX__\n+\n+typedef __PTRDIFF_TYPE__ ptrdiff_t;\n+typedef __SIZE_TYPE__    size_t;\n+\n+void* memset (void*, int, size_t);\n+\n+void sink (void*);\n+\n+char* fcall (void);\n+\n+void char_ptr_cst_off_cst_size (char *p)\n+                                        // { dg-message \"at offset \\[1-9\\]\\[0-9\\]+ into destination object 'p'\" \"note\" { target *-*-* } .-1 }\n+{\n+  size_t idx = DIFF_MAX - 3;\n+\n+  memset (p + idx, 0, 3);\n+  sink (p);\n+\n+  ++idx;\n+  memset (p + idx, 0, 3);               // { dg-warning \"writing 3 bytes into a region of size 2\" }\n+  sink (p);\n+\n+  ++idx;\n+  memset (p + idx, 0, 3);               // { dg-warning \"writing 3 bytes into a region of size 1\" }\n+\n+  ++idx;\n+  memset (p + idx, 0, 3);               // { dg-warning \"writing 3 bytes into a region of size 0\" }\n+}\n+\n+\n+void char_ptr_var_difoff_cst_size (ptrdiff_t idx)\n+{\n+  char *p = fcall ();\n+  /* The offset is a range with a very large lower bound and an upper\n+     bound of DIFF_MAX.  There's not point in also mentioning the latter\n+     (it wouldn't make the note any more meaningful) so verify it only\n+     mentions the lower bound.\n+     { dg-message \"at offset \\\\d+ into destination object of size \\\\\\[0, \\\\d+] (allocated|returned) by 'fcall'\" \"note\" { target *-*-* } .-5 } */\n+\n+  if (idx < DIFF_MAX - 3)\n+    idx = DIFF_MAX - 3;\n+\n+  memset (p + idx, 0, 3);\n+  sink (p);\n+\n+  memset (p + idx, 0, 5);               // { dg-warning \"writing 5 bytes into a region of size 3\" }\n+}\n+\n+\n+void char_ptr_var_szoff_cst_size (size_t idx)\n+{\n+  extern char* gptr;\n+  // { dg-message \"at offset \\\\d+ into destination object 'gptr'\" \"note\" { target *-*-* } .-1 }\n+\n+  char *p = gptr;\n+\n+  if (idx < DIFF_MAX - 3)\n+    idx = DIFF_MAX - 3;\n+\n+  memset (p + idx, 0, 3);\n+  sink (p);\n+\n+  memset (p + idx, 0, 5);               // { dg-warning \"writing 5 bytes into a region of size 3\" \"\" { xfail *-*-* } }\n+\n+  if (idx > DIFF_MAX)\n+    idx = DIFF_MAX;\n+\n+  memset (p + idx, 0, 7);               // { dg-warning \"writing 7 bytes into a region of size 3\" }\n+}\n+\n+\n+void char_ptr_var_difoff_var_size (char *p, ptrdiff_t idx, size_t n)\n+                                        // { dg-message \"at offset \\\\d+ into destination object 'p'\" \"note\" { target *-*-* } .-1 }\n+{\n+  if (idx < DIFF_MAX - 3)\n+    idx = DIFF_MAX - 3;\n+\n+  if (n < 3 || 7 < n)\n+    n = 3;\n+\n+  memset (p + idx, 0, n);\n+  sink (p);\n+\n+  ++n;\n+  memset (p + idx, 0, n);               // { dg-warning \"writing between 4 and 8 bytes into a region of size 3\" }\n+}\n+\n+\n+void char_ptr_var_szoff_var_size (char *p, size_t idx, size_t n)\n+                                        // { dg-message \"at offset \\\\\\[\\[1-9\\]\\[0-9\\]+, \\[1-9\\]\\[0-9\\]+] into destination object 'p'\" \"note\" { xfail *-*-* } .-1 }\n+{\n+  if (idx < DIFF_MAX - 3)\n+    idx = DIFF_MAX - 3;\n+\n+  if (n < 3 || 7 < n)\n+    n = 3;\n+\n+  memset (p + idx, 0, n);\n+  sink (p);\n+\n+  ++n;\n+  /* With an unsigned offset large values are interpreted as negative\n+     so the addition (p + idx) is effectively treated as subtraction,\n+     making an overflow indistinguishable from a valid (if unlikely)\n+     store.  */\n+  memset (p + idx, 0, n);               // { dg-warning \"writing between 4 and 8 bytes into a region of size 3\" \"pr?????\" { xfail *-*-* } }\n+}\n+\n+\n+void int_ptr_cst_off_cst_size (int *p)\n+                                        // { dg-message \"at offset \\[1-9\\]\\[0-9\\]+ into destination object 'p'\" \"note\" { target *-*-* } .-1 }\n+{\n+  size_t idx = DIFF_MAX / sizeof *p;\n+\n+  memset (p + idx, 0, 3);\n+  sink (p);\n+\n+  memset (p + idx, 0, 5);               // { dg-warning \"writing 5 bytes into a region of size 3\" }\n+}"}, {"sha": "6f36643c8bb60216f0b955244cce9bdb393ce8fe", "filename": "gcc/testsuite/gcc.dg/Wstringop-overflow-51.c", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83685efd5fd1623cfc4e4c435ce2773d95d458d1/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-51.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83685efd5fd1623cfc4e4c435ce2773d95d458d1/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-51.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-51.c?ref=83685efd5fd1623cfc4e4c435ce2773d95d458d1", "patch": "@@ -0,0 +1,34 @@\n+/* Test case derived from Binutils/GDB's readline/readline/histexpand.c.\n+   { dg-do compile }\n+   { dg-options \"-O2 -Wall\" } */\n+\n+char *\n+get_subst_pattern (char *str, int *iptr, int delimiter, int is_rhs, int *lenptr)\n+{\n+  int si, i, j, k;\n+  char *s;\n+\n+  s = 0;\n+  i = *iptr;\n+\n+  for (si = i; str[si] && str[si] != delimiter; si++)\n+      if (str[si] == '\\\\' && str[si + 1] == delimiter)\n+\tsi++;\n+\n+  if (si > i || is_rhs)\n+    {\n+      s = (char *)__builtin_malloc (si - i + 1);\n+      for (j = 0, k = i; k < si; j++, k++)\n+\t{\n+\t  /* Remove a backslash quoting the search string delimiter. */\n+\t  if (str[k] == '\\\\' && str[k + 1] == delimiter)\n+\t    k++;\n+\t  s[j] = str[k];   // { dg-bogus \"-Wstringop-overflow\" }\n+\t}\n+      s[j] = '\\0';\n+      if (lenptr)\n+\t*lenptr = j;\n+    }\n+\n+  return s;\n+}"}, {"sha": "a28965557c3de83a63194f50c4dff3b7ec95802b", "filename": "gcc/testsuite/gcc.dg/Wstringop-overflow-52.c", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83685efd5fd1623cfc4e4c435ce2773d95d458d1/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-52.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83685efd5fd1623cfc4e4c435ce2773d95d458d1/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-52.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-52.c?ref=83685efd5fd1623cfc4e4c435ce2773d95d458d1", "patch": "@@ -0,0 +1,62 @@\n+\n+/* PR middle-end/97023 - missing warning on buffer overflow in chained mempcpy\n+   Verify that writes by built-in functions to objects through pointers\n+   returned by ordinary (non-built-int) function are assumed to point to\n+   the beginning of objects.\n+   { dg-do compile }\n+   { dg-options \"-O2\" } */\n+\n+#include \"range.h\"\n+\n+void* memcpy (void*, const void*, size_t);\n+void* memset (void*, int, size_t);\n+\n+void sink (void*, ...);\n+\n+extern char* arrptr[];\n+extern char* ptr;\n+extern char* retptr (void);\n+struct S { char *p; };\n+extern struct S retstruct (void);\n+\n+void nowarn_ptr (void)\n+{\n+  {\n+    void *p = arrptr;\n+    memset (p - 1, 0, 12345);           // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+    memset (p,0, 12345);\n+    memset (p,0, DIFF_MAX - 1);\n+  }\n+\n+  {\n+    char *p = arrptr[0];\n+    memset (p - 1, 0, 12345);\n+    memset (p - 12345, 0, 12345);\n+    memset (p - 1234, 0, DIFF_MAX - 1);\n+    memset (p - DIFF_MAX + 1, 0, 12345);\n+  }\n+\n+  {\n+    char *p = ptr;\n+    memset (p - 1, 0, 12345);\n+    memset (p - 12345, 0, 12345);\n+    memset (p - 1234, 0, DIFF_MAX - 1);\n+    memset (p - DIFF_MAX + 1, 0, 12345);\n+  }\n+\n+  {\n+    char *p = retptr ();\n+    memset (p - 1, 0, 12345);\n+    memset (p - 12345, 0, 12345);\n+    memset (p - 1234, 0, DIFF_MAX - 1);\n+    memset (p - DIFF_MAX + 1, 0, 12345);\n+  }\n+\n+  {\n+    char *p = retstruct ().p;\n+    memset (p - 1, 0, 12345);\n+    memset (p - 12345, 0, 12345);\n+    memset (p - 1234, 0, DIFF_MAX - 1);\n+    memset (p - DIFF_MAX + 1, 0, 12345);\n+  }\n+}"}, {"sha": "cd8fa3202eb686722b1fb6c718bd9ebdb6ae64e1", "filename": "gcc/testsuite/gcc.dg/Wstringop-overflow-53.c", "status": "added", "additions": 116, "deletions": 0, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83685efd5fd1623cfc4e4c435ce2773d95d458d1/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-53.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83685efd5fd1623cfc4e4c435ce2773d95d458d1/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-53.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-53.c?ref=83685efd5fd1623cfc4e4c435ce2773d95d458d1", "patch": "@@ -0,0 +1,116 @@\n+/* PR middle-end/96384 - bogus -Wstringop-overflow= storing into\n+   multidimensional array with index in range\n+   { dg-do compile }\n+   { dg-options \"-O2 -Wall\" } */\n+\n+#define SHRT_MAX   __SHRT_MAX__\n+#define SHRT_MIN   (-SHRT_MAX - 1)\n+#define INT_MAX    __INT_MAX__\n+#define INT_MIN    (-INT_MAX - 1)\n+#define LONG_MAX   __LONG_MAX__\n+#define LONG_MIN   (-LONG_MAX - 1)\n+\n+#define USHRT_MAX  (SHRT_MAX * 2 + 1)\n+#define UINT_MAX   ~0U\n+#define ULONG_MAX  ~0LU\n+\n+char ca3_5_7[3][5][7];\n+\n+void nowarn_ca_3_5_ssi (short i)\n+{\n+  if (i > SHRT_MAX - 1)\n+    i = SHRT_MAX - 1;\n+\n+  ca3_5_7[i][0][0] = __LINE__;\n+  ca3_5_7[i][0][1] = __LINE__;\n+  ca3_5_7[i][0][2] = __LINE__;\n+  ca3_5_7[i][0][3] = __LINE__;\n+  ca3_5_7[i][0][4] = __LINE__;\n+  ca3_5_7[i][0][5] = __LINE__;\n+  ca3_5_7[i][0][6] = __LINE__;\n+\n+  ca3_5_7[i][1][0] = __LINE__;\n+  ca3_5_7[i][1][1] = __LINE__;\n+  ca3_5_7[i][1][2] = __LINE__;\n+  ca3_5_7[i][1][3] = __LINE__;\n+  ca3_5_7[i][1][4] = __LINE__;\n+  ca3_5_7[i][1][5] = __LINE__;\n+  ca3_5_7[i][1][6] = __LINE__;\n+\n+  ca3_5_7[i][2][0] = __LINE__;\n+  ca3_5_7[i][2][1] = __LINE__;\n+  ca3_5_7[i][2][2] = __LINE__;\n+  ca3_5_7[i][2][3] = __LINE__;\n+  ca3_5_7[i][2][4] = __LINE__;\n+  ca3_5_7[i][2][5] = __LINE__;\n+  ca3_5_7[i][2][6] = __LINE__;\n+\n+  ca3_5_7[i][3][0] = __LINE__;\n+  ca3_5_7[i][3][1] = __LINE__;\n+  ca3_5_7[i][3][2] = __LINE__;\n+  ca3_5_7[i][3][3] = __LINE__;\n+  ca3_5_7[i][3][4] = __LINE__;\n+  ca3_5_7[i][3][5] = __LINE__;\n+  ca3_5_7[i][3][6] = __LINE__;\n+\n+  ca3_5_7[i][4][0] = __LINE__;\n+  ca3_5_7[i][4][1] = __LINE__;\n+  ca3_5_7[i][4][2] = __LINE__;\n+  ca3_5_7[i][4][3] = __LINE__;\n+  ca3_5_7[i][4][4] = __LINE__;\n+  ca3_5_7[i][4][5] = __LINE__;\n+  ca3_5_7[i][4][6] = __LINE__;\n+\n+  ca3_5_7[1][i][5] = __LINE__;\n+  ca3_5_7[2][3][i] = __LINE__;\n+}\n+\n+void nowarn_ca_3_5_usi (unsigned short i)\n+{\n+  if (i > USHRT_MAX - 1)\n+    i = USHRT_MAX - 1;\n+\n+  ca3_5_7[i][3][5] = __LINE__;\n+  ca3_5_7[1][i][5] = __LINE__;\n+  ca3_5_7[2][3][i] = __LINE__;\n+}\n+\n+void nowarn_ca_3_5_si (int i)\n+{\n+  if (i > INT_MAX - 1)\n+    i = INT_MAX - 1;\n+\n+  ca3_5_7[i][3][5] = __LINE__;\n+  ca3_5_7[1][i][5] = __LINE__;\n+  ca3_5_7[2][3][i] = __LINE__;\n+}\n+\n+void nowarn_ca_3_5_ui (unsigned i)\n+{\n+  if (i > UINT_MAX - 1)\n+    i = UINT_MAX - 1;\n+\n+  ca3_5_7[i][3][5] = __LINE__;\n+  ca3_5_7[1][i][5] = __LINE__;\n+  ca3_5_7[2][3][i] = __LINE__;\n+}\n+\n+void nowarn_ca_3_5_li (long i)\n+{\n+  if (i > LONG_MAX - 1)\n+    i = LONG_MAX - 1;\n+\n+  ca3_5_7[i][3][5] = __LINE__;\n+  ca3_5_7[1][i][5] = __LINE__;\n+  ca3_5_7[2][3][i] = __LINE__;\n+}\n+\n+void nowarn_ca_3_5_uli (unsigned long i)\n+{\n+  if (i > ULONG_MAX - 1)\n+    i = ULONG_MAX - 1;\n+\n+  ca3_5_7[i][3][5] = __LINE__;\n+  ca3_5_7[1][i][5] = __LINE__;\n+  ca3_5_7[2][3][i] = __LINE__;\n+}"}, {"sha": "26568f8366dfb3d0a4fd042710d92e8bd50a3e85", "filename": "gcc/testsuite/gcc.dg/Wstringop-overflow-54.c", "status": "added", "additions": 103, "deletions": 0, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83685efd5fd1623cfc4e4c435ce2773d95d458d1/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-54.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83685efd5fd1623cfc4e4c435ce2773d95d458d1/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-54.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-54.c?ref=83685efd5fd1623cfc4e4c435ce2773d95d458d1", "patch": "@@ -0,0 +1,103 @@\n+/* Verify that writes at excessive offsets into flexible array members\n+   of extern or allocated objects of unknow size are diagnosed.\n+   { dg-do compile }\n+   { dg-options \"-O2\" } */\n+\n+#define DIFF_MAX __PTRDIFF_MAX__\n+\n+typedef __PTRDIFF_TYPE__ ptrdiff_t;\n+typedef __SIZE_TYPE__    size_t;\n+\n+void* memset (void*, int, size_t);\n+\n+void sink (void*);\n+\n+void char_flexarray_cst_off_cst_size (void)\n+{\n+  extern struct { char n, a[]; }\n+    caxcc;                              // { dg-message \"at offset \\[1-9\\]\\[0-9\\]+ into destination object 'caxcc'\" }\n+\n+  char *p = caxcc.a;\n+  size_t idx = DIFF_MAX - 4;\n+\n+  memset (p + idx, 0, 3);\n+  sink (p);\n+\n+  ++idx;\n+  memset (p + idx, 0, 3);               // { dg-warning \"writing 3 bytes into a region of size 2\" }\n+  sink (p);\n+\n+  ++idx;\n+  memset (p + idx, 0, 3);               // { dg-warning \"writing 3 bytes into a region of size 1\" }\n+\n+  ++idx;\n+  memset (p + idx, 0, 3);               // { dg-warning \"writing 3 bytes into a region of size 0\" }\n+}\n+\n+\n+void char_flexarray_var_off_cst_size (ptrdiff_t idx)\n+{\n+  extern struct { char n, a[]; }\n+    caxvc;                              // { dg-message \"destination object 'caxvc'\" }\n+\n+  char *p = caxvc.a;\n+\n+  if (idx < DIFF_MAX - 4)\n+    idx = DIFF_MAX - 4;\n+\n+  memset (p + idx, 0, 3);\n+  sink (p);\n+\n+  memset (p + idx, 0, 5);               // { dg-warning \"writing 5 bytes into a region of size 3\" }\n+}\n+\n+\n+void char_flexarray_var_off_var_size (size_t n, ptrdiff_t idx)\n+{\n+  extern struct { char n, a[]; }\n+    caxvv;                              // { dg-message \"destination object 'caxvv'\" }\n+\n+  char *p = caxvv.a;\n+\n+  if (idx < DIFF_MAX - 4)\n+    idx = DIFF_MAX - 4;\n+\n+  if (n < 3 || 7 < n)\n+    n = 3;\n+\n+  memset (p + idx, 0, n);\n+  sink (p);\n+\n+  ++n;\n+  memset (p + idx, 0, n);               // { dg-warning \"writing between 4 and 8 bytes into a region of size 3\" }\n+}\n+\n+\n+void alloc_array_var_off_cst_size (size_t n, ptrdiff_t idx)\n+{\n+  struct { char n, a[]; }\n+    *p = __builtin_malloc (n);          // { dg-message \"at offset \\\\d+ into destination object\" }\n+\n+  if (idx < DIFF_MAX - 4)\n+    idx = DIFF_MAX - 4;\n+\n+  memset (p->a + idx, 0, 3);\n+  sink (p);\n+\n+  memset (p->a + idx, 0, 5);            // { dg-warning \"writing 5 bytes into a region of size 3\" }\n+}\n+\n+\n+void int_array_cst_off_cst_size (void)\n+{\n+  extern struct { int n, a[]; }\n+    iaxc;                               // { dg-message \"at offset \\[1-9\\]\\[0-9\\]+ into destination object 'iaxc'\" }\n+\n+  int *p = iaxc.a;\n+  size_t idx = DIFF_MAX / sizeof *p - 1;\n+\n+  memset (p + idx, 0, 3);\n+  sink (p);\n+\n+  memset (p + idx, 0, 5);               // { dg-warning \"writing 5 bytes into a region of size 3\" }\n+}"}, {"sha": "25f5b82d9bec7a8f3d944fb3e34a273e752bece0", "filename": "gcc/testsuite/gcc.dg/Wstringop-overflow-55.c", "status": "added", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83685efd5fd1623cfc4e4c435ce2773d95d458d1/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-55.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83685efd5fd1623cfc4e4c435ce2773d95d458d1/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-55.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-55.c?ref=83685efd5fd1623cfc4e4c435ce2773d95d458d1", "patch": "@@ -0,0 +1,97 @@\n+/* Verify that offsets in \"anti-ranges\" are handled correctly.\n+   { dg-do compile }\n+   { dg-options \"-O2 -Wall -ftrack-macro-expansion=0\" } */\n+\n+typedef __PTRDIFF_TYPE__ ptrdiff_t;\n+typedef __SIZE_TYPE__    size_t;\n+\n+void* memset (void*, int, size_t);\n+\n+void sink (void*, ...);\n+#define T(x) sink (x)\n+\n+\n+void int_range_add_sub_ (int i, int j)\n+{\n+  if (i < 1) i = 1;\n+  if (j > -1) j = -1;\n+\n+  char ca5[5];              // { dg-message \"at offset \\\\\\[1, 5]\" \"note\" }\n+  char *p0 = ca5;           // offset\n+  char *p1 = p0 + i;        //  1-5\n+  char *p2 = p1 + i;        //  2-5\n+  char *p3 = p2 + j;        //  0-4\n+  char *p4 = p3 + j;        //  0-3\n+  char *p5 = p4 + j;        //  0-2\n+  char *p6 = p5 + j;        //  0-1\n+  char *p7 = p6 + i;        //  1-2\n+\n+  memset (p7, 0, 5);        // { dg-warning \"writing 5 bytes into a region of size 4\" }\n+\n+  sink (p0, p1, p2, p3, p4, p5, p6, p7);\n+}\n+\n+\n+void ruint_arint_add (unsigned i, int j)\n+{\n+  i |= 1;   // [1, UINT_MAX]\n+  j |= 1;   // [INT_MIN + 1, -1] U [1, INT_MAX]\n+\n+  char a[5];                // { dg-message \"at offset \\\\\\[1, 5]\" \"note\" }\n+  char *p0 = a;             // offset\n+  char *p1 = p0 + i;        //  1-5\n+  T (memset (p1, 0, 4));\n+\n+  char *p2 = p1 + j;        //  0-5\n+  T (memset (p2, 0, 5));\n+\n+  char *p3 = p2 + i;        //  1-5\n+  T (memset (p3, 0, 4));\n+\n+  char *p4 = p3 + j;        //  0-5\n+  T (memset (p4, 0, 5));\n+\n+  char *p5 = p4 + i;        //  1-5\n+  T (memset (p5, 0, 4));\n+\n+  char *p6 = p5 + j;        //  0-5\n+  T (memset (p6, 0, 5));\n+\n+  char *p7 = p6 + i;        //  1-5\n+  T (memset (p7, 0, 5));    // { dg-warning \"writing 5 bytes into a region of size 4\" \"\" }\n+}\n+\n+\n+void warn_ptrdiff_anti_range_add (ptrdiff_t i)\n+{\n+  i |= 1;\n+\n+  char ca5[5];              // { dg-message \"at offset \\\\\\[1, 5]\" \"pr?????\" { xfail *-*-* } }\n+  char *p0 = ca5;           // offset\n+  char *p1 = p0 + i;        //  1-5\n+  char *p2 = p1 + i;        //  2-5\n+  char *p3 = p2 + i;        //  3-5\n+  char *p4 = p3 + i;        //  4-5\n+  char *p5 = p4 + i;        //   5\n+\n+  memset (p5, 0, 5);        // { dg-warning \"writing 5 bytes into a region of size 0\" \"pr?????\" { xfail *-*-* } }\n+\n+  sink (p0, p1, p2, p3, p4, p5);\n+}\n+\n+void warn_int_anti_range (int i)\n+{\n+  i |= 1;\n+\n+  char ca5[5];              // { dg-message \"at offset \\\\\\[1, 5]\" \"pr?????\" { xfail *-*-* } }\n+  char *p0 = ca5;           // offset\n+  char *p1 = p0 + i;        //  1-5\n+  char *p2 = p1 + i;        //  2-5\n+  char *p3 = p2 + i;        //  3-5\n+  char *p4 = p3 + i;        //  4-5\n+  char *p5 = p4 + i;        //   5\n+\n+  memset (p5, 0, 5);        // { dg-warning \"writing 5 bytes into a region of size 0\" \"pr?????\" { xfail *-*-* } }\n+\n+  sink (p0, p1, p2, p3, p4, p5);\n+}"}, {"sha": "b75002b4295f63064348bed99253d57ad312060f", "filename": "gcc/testsuite/gcc.dg/Wstringop-overread-5.c", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83685efd5fd1623cfc4e4c435ce2773d95d458d1/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overread-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83685efd5fd1623cfc4e4c435ce2773d95d458d1/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overread-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overread-5.c?ref=83685efd5fd1623cfc4e4c435ce2773d95d458d1", "patch": "@@ -0,0 +1,76 @@\n+/* Verify -Wstringop-overread with a source pointer pointing either\n+   before the beginning or past the end of an object.\n+   { dg-do compile }\n+   { dg-options \"-O -Wall -Wno-array-bounds\" } */\n+\n+typedef __SIZE_TYPE__ size_t;\n+\n+size_t strlen (const char *);\n+\n+void sink (void*, ...);\n+\n+void off_sz_or_1 (size_t i)\n+{\n+  i |= 1;\n+\n+  /* Verify the offset in the notes only mentions the meaningful lower\n+     bound and not a range with the excessive (and meaningless) upper\n+     bound like [2, 9223372036854775807].  */\n+  extern char a[1];\n+  // { dg-message \"at offset 1 into source object 'a'\" \"note\" { target *-*-* } .-1 }\n+  // { dg-message \"at offset 2 \" \"note\" { target *-*-* } .-2 }\n+\n+  char *p1 = a + i;\n+  char *p2 = p1 + 1;\n+  char *p3 = p1 - 1;\n+\n+  size_t n = 0;\n+  n += strlen (p1);     // { dg-warning \"reading 1 or more bytes from a region of size 0\" }\n+  n += strlen (p2);     // { dg-warning \"reading 1 or more bytes from a region of size 0\" }\n+  n += strlen (p3);\n+\n+  sink (p1, p2, p3, n);\n+}\n+\n+\n+void off_sz_or_2 (size_t i)\n+{\n+  i |= 2;\n+\n+  extern char b[2];\n+  // { dg-message \"at offset 2 \" \"note\" { target *-*-* } .-1 }\n+  // { dg-message \"at offset 3 \" \"note\" { target *-*-* } .-2 }\n+\n+  char *p1 = b + i;\n+  char *p2 = p1 + 1;\n+  char *p3 = p1 - 1;\n+\n+  size_t n = 0;\n+  n += strlen (p1);     // { dg-warning \"reading 1 or more bytes from a region of size 0\" }\n+  n += strlen (p2);     // { dg-warning \"reading 1 or more bytes from a region of size 0\" }\n+  n += strlen (p3);\n+\n+  sink (p1, p2, p3, n);\n+}\n+\n+\n+void off_sz_or_4 (size_t i)\n+{\n+  i |= 4;\n+\n+  extern char c[3];\n+  // { dg-message \"at offset 4 \" \"note\" { target *-*-* } .-1 }\n+  // { dg-message \"at offset 5 \" \"note\" { target *-*-* } .-2 }\n+  // { dg-message \"at offset 3 \" \"note\" { target *-*-* } .-3 }\n+\n+  char *p1 = c + i;\n+  char *p2 = p1 + 1;\n+  char *p3 = p1 - 1;\n+\n+  size_t n = 0;\n+  n += strlen (p1);     // { dg-warning \"reading 1 or more bytes from a region of size 0\" }\n+  n += strlen (p2);     // { dg-warning \"reading 1 or more bytes from a region of size 0\" }\n+  n += strlen (p3);     // { dg-warning \"reading 1 or more bytes from a region of size 0\" }\n+\n+  sink (p1, p2, p3, n);\n+}"}, {"sha": "7a624e4055d1622e295586e29796c9f16c69d9c1", "filename": "gcc/testsuite/gcc.dg/pr51683.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83685efd5fd1623cfc4e4c435ce2773d95d458d1/gcc%2Ftestsuite%2Fgcc.dg%2Fpr51683.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83685efd5fd1623cfc4e4c435ce2773d95d458d1/gcc%2Ftestsuite%2Fgcc.dg%2Fpr51683.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr51683.c?ref=83685efd5fd1623cfc4e4c435ce2773d95d458d1", "patch": "@@ -12,6 +12,9 @@ void *\n foo (void *p)\n {\n   return bar ((void *) 0x12345000, p, 256);\n+  /* Integers converted to pointers are assumed to be the result of\n+     (invalid) arithmetic on null pointers.\n+     { dg-prune-output \"writing 256 bytes into a region of size 0\" } */\n }\n \n /* { dg-final { scan-tree-dump \"memcpy\" \"optimized\" } } */"}, {"sha": "962c705f18f1be67407bec3b6e53beb8ab54effb", "filename": "gcc/testsuite/gcc.target/i386/pr60693.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83685efd5fd1623cfc4e4c435ce2773d95d458d1/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr60693.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83685efd5fd1623cfc4e4c435ce2773d95d458d1/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr60693.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr60693.c?ref=83685efd5fd1623cfc4e4c435ce2773d95d458d1", "patch": "@@ -11,3 +11,6 @@ foo (void)\n   __builtin_memcpy (buf, (void *) 0x8000, 4096);\n   bar (buf);\n }\n+\n+/* Reading from a constant address might triggers:\n+   { dg-prune-output \"\\\\\\[-Wstringop-overread\" } */"}, {"sha": "ebb17cd852c87a6323f64d326858a144963556a1", "filename": "gcc/tree-ssa-strlen.c", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83685efd5fd1623cfc4e4c435ce2773d95d458d1/gcc%2Ftree-ssa-strlen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83685efd5fd1623cfc4e4c435ce2773d95d458d1/gcc%2Ftree-ssa-strlen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-strlen.c?ref=83685efd5fd1623cfc4e4c435ce2773d95d458d1", "patch": "@@ -228,8 +228,20 @@ get_range (tree val, gimple *stmt, wide_int minmax[2],\n \n   value_range_kind rng = get_range_info (val, minmax, minmax + 1);\n   if (rng == VR_RANGE)\n+    /* This may be an inverted range whose MINMAX[1] < MINMAX[0].  */\n     return val;\n \n+  if (rng == VR_ANTI_RANGE)\n+    {\n+      /* An anti-range is the same as an ordinary range with inverted\n+\t bounds (where MINMAX[1] < MINMAX[0] is true) that may result\n+\t from the conversion of a signed anti-range to unsigned.  */\n+      wide_int tmp = minmax[0];\n+      minmax[0] = minmax[1] + 1;\n+      minmax[1] = wi::sub (tmp, 1);\n+      return val;\n+    }\n+\n   /* Do not handle anti-ranges and instead make use of the on-demand\n      VRP if/when it becomes available (hopefully in GCC 11).  */\n   return NULL_TREE;\n@@ -2243,7 +2255,7 @@ maybe_warn_overflow (gimple *stmt, tree len,\n     sprintf (offstr, \"[%lli, %lli]\",\n \t     (long long) offrng[0].to_shwi (), (long long) offrng[1].to_shwi ());\n \n-  if (destdecl)\n+  if (destdecl && DECL_P (destdecl))\n     {\n       if (tree size = DECL_SIZE_UNIT (destdecl))\n \tinform (DECL_SOURCE_LOCATION (destdecl),"}]}