{"sha": "3476f949088b2f18c0cee16a36ea4ea330248138", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzQ3NmY5NDkwODhiMmYxOGMwY2VlMTZhMzZlYTRlYTMzMDI0ODEzOA==", "commit": {"author": {"name": "Javier Miranda", "email": "miranda@adacore.com", "date": "2006-10-31T17:54:22Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2006-10-31T17:54:22Z"}, "message": "exp_ch3.ads, [...] (Expand_N_Object_Declaration): Do not register in the final list objects containing class-wide interfaces...\n\n2006-10-31  Javier Miranda  <miranda@adacore.com>\n\t    Robert Dewar  <dewar@adacore.com>\n\t    Ed Schonberg  <schonberg@adacore.com>\n\t    Gary Dismukes  <dismukes@adacore.com>\n\n        * exp_ch3.ads, exp_ch3.adb (Expand_N_Object_Declaration): Do not\n\tregister in the final list objects containing class-wide interfaces;\n\totherwise we incorrectly register the tag of the interface in the final\n\tlist.\n        (Make_Controlling_Function_Wrappers): Add missing barrier to do not\n        generate the wrapper if the parent primitive is abstract. This is\n        required to report the correct error message.\n        (Expand_N_Subtype_Indication): Do validity checks on range\n\t(Clean_Task_Names): If an initialization procedure includes a call to\n\tinitialize a task (sub)component, indicate that the procedure will use\n\tthe secondary stack.\n\t(Build_Init_Procedure, Init_Secondary_Tags): Enable full ABI\n\tcompatibility for interfacing with CPP by default.\n\t(Expand_N_Object_Declaration): Only build an Adjust call when the\n\tobject's type is a nonlimited controlled type.\n\t* exp_ch3.adb: Add with and use of Exp_Ch6.\n\t(Expand_N_Object_Declaration): Check for object initialization that is a\n\tcall to build-in-place function and apply Make_Build_In_Place_Call_In_\n\tObject_Declaration to the call.\n\t(Freeze_Type): When the designated type of an RACW was not frozen at the\n\tpoint where the RACW was declared, validate the primitive operations\n\twith respect to E.2.2(14) when it finally is frozen.\n\t(Build_Initialization_Call,Expand_Record_Controller): Rename\n\tIs_Return_By_Reference_Type to be Is_Inherently_Limited_Type, because\n\treturn-by-reference has no meaning in Ada 2005.\n\t(Init_Secondary_Tags): Add missing call to Set_Offset_To_Top\n\tto register tag of the immediate ancestor interfaces in the\n\trun-time structure.\n\t(Init_Secondary_Tags): Moved to the specification to allow the\n\tinitialization of extension aggregates with abstract interfaces.\n\t(Build_Master_Renaming): Make public, for use by function declarations\n\twhose return type is an anonymous access type.\n\t(Freeze_Record_Type): Replace call to Insert_List_Before by call to\n\tInsert_List_Before_And_Analyze after the generation of the specs\n\tassociated with null procedures.\n\t(Expand_Tagged_Root): Update documentation in its specification.\n\t(Init_Secondary_Tags): Update documentation.\n\t(Build_Init_Procedure): If we are compiling under CPP full ABI compa-\n\ttibility mode and the immediate ancestor is a CPP_Pragma tagged type\n\tthen generate code to inherit the contents of the dispatch table\n\tdirectly from the ancestor.\n\t(Expand_Record_Controller): Insert controller component after tags of\n\timplemented interfaces.\n\t(Freeze_Record_Type): Call new procedure Make_Null_Procedure_Specs to\n\tcreate null procedure overridings when null procedures are inherited\n\tfrom interfaces.\n\t(Make_Null_Procedure_Specs): New procedure to generate null procedure\n\tdeclarations for overriding null primitives inherited from interfaces.\n\t(Is_Null_Interface_Procedure): New function in\n\tMake_Null_Procedure_Specs.\n\t(Make_Predefined_Primitive_Specs/Predefined_Primitive_Bodies): If the\n\timmediate ancestor of a tagged type is an abstract interface type we\n\tmust generate the specification of the predefined primitives associated\n\twith controlled types (because the dispatch table of the ancestor is\n\tnull and hence these entries cannot be inherited). This is required to\n\telaborate well the dispatch table.\n\nFrom-SVN: r118256", "tree": {"sha": "dd2b8ec9fcfe908fe25e7a51eecacd05a96a6884", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dd2b8ec9fcfe908fe25e7a51eecacd05a96a6884"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3476f949088b2f18c0cee16a36ea4ea330248138", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3476f949088b2f18c0cee16a36ea4ea330248138", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3476f949088b2f18c0cee16a36ea4ea330248138", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3476f949088b2f18c0cee16a36ea4ea330248138/comments", "author": {"login": "miranda-adacore", "id": 54413934, "node_id": "MDQ6VXNlcjU0NDEzOTM0", "avatar_url": "https://avatars.githubusercontent.com/u/54413934?v=4", "gravatar_id": "", "url": "https://api.github.com/users/miranda-adacore", "html_url": "https://github.com/miranda-adacore", "followers_url": "https://api.github.com/users/miranda-adacore/followers", "following_url": "https://api.github.com/users/miranda-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/miranda-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/miranda-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/miranda-adacore/subscriptions", "organizations_url": "https://api.github.com/users/miranda-adacore/orgs", "repos_url": "https://api.github.com/users/miranda-adacore/repos", "events_url": "https://api.github.com/users/miranda-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/miranda-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d705ba7827180320fdfee7b87896942f481e6951", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d705ba7827180320fdfee7b87896942f481e6951", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d705ba7827180320fdfee7b87896942f481e6951"}], "stats": {"total": 971, "additions": 676, "deletions": 295}, "files": [{"sha": "4e08bedaaf39d621d25217c60bfb3eb590710ae9", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 654, "deletions": 294, "changes": 948, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3476f949088b2f18c0cee16a36ea4ea330248138/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3476f949088b2f18c0cee16a36ea4ea330248138/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=3476f949088b2f18c0cee16a36ea4ea330248138", "patch": "@@ -26,10 +26,12 @@\n \n with Atree;    use Atree;\n with Checks;   use Checks;\n+with Debug;    use Debug;\n with Einfo;    use Einfo;\n with Errout;   use Errout;\n with Exp_Aggr; use Exp_Aggr;\n with Exp_Ch4;  use Exp_Ch4;\n+with Exp_Ch6;  use Exp_Ch6;\n with Exp_Ch7;  use Exp_Ch7;\n with Exp_Ch9;  use Exp_Ch9;\n with Exp_Ch11; use Exp_Ch11;\n@@ -49,6 +51,7 @@ with Rident;   use Rident;\n with Rtsfind;  use Rtsfind;\n with Sem;      use Sem;\n with Sem_Attr; use Sem_Attr;\n+with Sem_Cat;  use Sem_Cat;\n with Sem_Ch3;  use Sem_Ch3;\n with Sem_Ch8;  use Sem_Ch8;\n with Sem_Disp; use Sem_Disp;\n@@ -89,19 +92,6 @@ package body Exp_Ch3 is\n    --  of the type. Otherwise new identifiers are created, with the source\n    --  names of the discriminants.\n \n-   procedure Build_Master_Renaming (N : Node_Id; T : Entity_Id);\n-   --  If the designated type of an access type is a task type or contains\n-   --  tasks, we make sure that a _Master variable is declared in the current\n-   --  scope, and then declare a renaming for it:\n-   --\n-   --    atypeM : Master_Id renames _Master;\n-   --\n-   --  where atyp is the name of the access type. This declaration is\n-   --  used when an allocator for the access type is expanded. The node N\n-   --  is the full declaration of the designated type that contains tasks.\n-   --  The renaming declaration is inserted before N, and after the Master\n-   --  declaration.\n-\n    procedure Build_Record_Init_Proc (N : Node_Id; Pe : Entity_Id);\n    --  Build record initialization procedure. N is the type declaration\n    --  node, and Pe is the corresponding entity for the record type.\n@@ -122,11 +112,18 @@ package body Exp_Ch3 is\n    --  stream-attributes, then any limited component of the extension also\n    --  has the corresponding user-defined stream attributes.\n \n+   procedure Clean_Task_Names\n+     (Typ     : Entity_Id;\n+      Proc_Id : Entity_Id);\n+   --  If an initialization procedure includes calls to generate names\n+   --  for task subcomponents, indicate that secondary stack cleanup is\n+   --  needed after an initialization. Typ is the component type, and Proc_Id\n+   --  the initialization procedure for the enclosing composite type.\n+\n    procedure Expand_Tagged_Root (T : Entity_Id);\n    --  Add a field _Tag at the beginning of the record. This field carries\n    --  the value of the access to the Dispatch table. This procedure is only\n-   --  called on root (non CPP_Class) types, the _Tag field being inherited\n-   --  by the descendants.\n+   --  called on root type, the _Tag field being inherited by the descendants.\n \n    procedure Expand_Record_Controller (T : Entity_Id);\n    --  T must be a record type that Has_Controlled_Component. Add a field\n@@ -249,6 +246,14 @@ package body Exp_Ch3 is\n    --  invoking the inherited subprogram's parent subprogram and extended\n    --  with a null association list.\n \n+   procedure Make_Null_Procedure_Specs\n+     (Tag_Typ   : Entity_Id;\n+      Decl_List : out List_Id);\n+   --  Ada 2005 (AI-251): Makes specs for null procedures associated with any\n+   --  null procedures inherited from an interface type that have not been\n+   --  overridden. Only one null procedure will be created for a given set of\n+   --  inherited null procedures with homographic profiles.\n+\n    function Predef_Spec_Or_Body\n      (Loc      : Source_Ptr;\n       Tag_Typ  : Entity_Id;\n@@ -501,6 +506,7 @@ package body Exp_Ch3 is\n                     (Comp_Type, Loc, Component_Size (A_Type))));\n \n          else\n+            Clean_Task_Names (Comp_Type, Proc_Id);\n             return\n               Build_Initialization_Call (Loc, Comp, Comp_Type, True, A_Type);\n          end if;\n@@ -1153,7 +1159,8 @@ package body Exp_Ch3 is\n                 Strval => \"\"));\n \n          else\n-            Decls := Build_Task_Image_Decls (Loc, Id_Ref, Enclos_Type);\n+            Decls :=\n+              Build_Task_Image_Decls (Loc, Id_Ref, Enclos_Type, In_Init_Proc);\n             Decl  := Last (Decls);\n \n             Append_To (Args,\n@@ -1307,7 +1314,7 @@ package body Exp_Ch3 is\n            and then Has_New_Controlled_Component (Enclos_Type)\n            and then Has_Controlled_Component (Typ)\n          then\n-            if Is_Return_By_Reference_Type (Typ) then\n+            if Is_Inherently_Limited_Type (Typ) then\n                Controller_Typ := RTE (RE_Limited_Record_Controller);\n             else\n                Controller_Typ := RTE (RE_Record_Controller);\n@@ -1715,18 +1722,10 @@ package body Exp_Ch3 is\n                     New_Reference_To (Discriminal (Entity (Arg)), Loc));\n \n                --  Case of access discriminants. We replace the reference\n-               --  to the type by a reference to the actual object\n+               --  to the type by a reference to the actual object.\n \n---     ??? why is this code deleted without comment\n-\n---               elsif Nkind (Arg) = N_Attribute_Reference\n---                 and then Is_Entity_Name (Prefix (Arg))\n---                 and then Is_Type (Entity (Prefix (Arg)))\n---               then\n---                  Append_To (Args,\n---                    Make_Attribute_Reference (Loc,\n---                      Prefix         => New_Copy (Prefix (Id_Ref)),\n---                      Attribute_Name => Name_Unrestricted_Access));\n+               --  Is above comment right??? Use of New_Copy below seems mighty\n+               --  suspicious ???\n \n                else\n                   Append_To (Args, New_Copy (Arg));\n@@ -1879,223 +1878,6 @@ package body Exp_Ch3 is\n          Record_Extension_Node : Node_Id;\n          Init_Tag              : Node_Id;\n \n-         procedure Init_Secondary_Tags (Typ : Entity_Id);\n-         --  Ada 2005 (AI-251): Initialize the tags of all the secondary\n-         --  tables associated with abstract interface types\n-\n-         -------------------------\n-         -- Init_Secondary_Tags --\n-         -------------------------\n-\n-         procedure Init_Secondary_Tags (Typ : Entity_Id) is\n-            ADT : Elmt_Id;\n-\n-            procedure Init_Secondary_Tags_Internal (Typ : Entity_Id);\n-            --  Internal subprogram used to recursively climb to the root type\n-\n-            ----------------------------------\n-            -- Init_Secondary_Tags_Internal --\n-            ----------------------------------\n-\n-            procedure Init_Secondary_Tags_Internal (Typ : Entity_Id) is\n-               Aux_N  : Node_Id;\n-               E      : Entity_Id;\n-               Iface  : Entity_Id;\n-               Prev_E : Entity_Id;\n-\n-            begin\n-               --  Climb to the ancestor (if any) handling private types\n-\n-               if Present (Full_View (Etype (Typ))) then\n-                  if Full_View (Etype (Typ)) /= Typ then\n-                     Init_Secondary_Tags_Internal (Full_View (Etype (Typ)));\n-                  end if;\n-\n-               elsif Etype (Typ) /= Typ then\n-                  Init_Secondary_Tags_Internal (Etype (Typ));\n-               end if;\n-\n-               if Present (Abstract_Interfaces (Typ))\n-                 and then not Is_Empty_Elmt_List (Abstract_Interfaces (Typ))\n-               then\n-                  E := First_Entity (Typ);\n-                  while Present (E) loop\n-                     if Is_Tag (E)\n-                       and then Chars (E) /= Name_uTag\n-                     then\n-                        Aux_N := Node (ADT);\n-                        pragma Assert (Present (Aux_N));\n-\n-                        Iface := Find_Interface (Typ, E);\n-\n-                        --  Initialize the pointer to the secondary DT\n-                        --  associated with the interface\n-\n-                        Append_To (Body_Stmts,\n-                          Make_Assignment_Statement (Loc,\n-                            Name =>\n-                              Make_Selected_Component (Loc,\n-                                Prefix => Make_Identifier (Loc, Name_uInit),\n-                                Selector_Name =>\n-                                  New_Reference_To (E, Loc)),\n-                            Expression =>\n-                              New_Reference_To (Aux_N, Loc)));\n-\n-                        --  Issue error if Set_Offset_To_Top is not available\n-                        --  in a configurable run-time environment.\n-\n-                        if not RTE_Available (RE_Set_Offset_To_Top) then\n-                           Error_Msg_CRT (\"abstract interface types\", Typ);\n-                           return;\n-                        end if;\n-\n-                        --  We generate a different call to Set_Offset_To_Top\n-                        --  when the parent of the type has discriminants\n-\n-                        if Typ /= Etype (Typ)\n-                          and then Has_Discriminants (Etype (Typ))\n-                        then\n-                           pragma Assert (Present (DT_Offset_To_Top_Func (E)));\n-\n-                           --  Generate:\n-                           --    Set_Offset_To_Top\n-                           --      (This         => Init,\n-                           --       Interface_T  => Iface'Tag,\n-                           --       Is_Constant  => False,\n-                           --       Offset_Value => n,\n-                           --       Offset_Func  => Fn'Address)\n-\n-                           Append_To (Body_Stmts,\n-                             Make_Procedure_Call_Statement (Loc,\n-                               Name => New_Reference_To\n-                                         (RTE (RE_Set_Offset_To_Top), Loc),\n-                               Parameter_Associations => New_List (\n-                                 Make_Attribute_Reference (Loc,\n-                                   Prefix => Make_Identifier (Loc,\n-                                               Name_uInit),\n-                                   Attribute_Name => Name_Address),\n-\n-                                 Unchecked_Convert_To (RTE (RE_Tag),\n-                                   New_Reference_To\n-                                     (Node (First_Elmt\n-                                            (Access_Disp_Table (Iface))),\n-                                      Loc)),\n-\n-                                 New_Occurrence_Of (Standard_False, Loc),\n-\n-                                 Unchecked_Convert_To (RTE (RE_Storage_Offset),\n-                                   Make_Attribute_Reference (Loc,\n-                                     Prefix         =>\n-                                       Make_Selected_Component (Loc,\n-                                         Prefix => Make_Identifier (Loc,\n-                                                     Name_uInit),\n-                                         Selector_Name => New_Reference_To\n-                                                            (E, Loc)),\n-                                     Attribute_Name => Name_Position)),\n-\n-                                 Unchecked_Convert_To (RTE (RE_Address),\n-                                   Make_Attribute_Reference (Loc,\n-                                     Prefix => New_Reference_To\n-                                                 (DT_Offset_To_Top_Func (E),\n-                                                  Loc),\n-                                     Attribute_Name =>\n-                                       Name_Address)))));\n-\n-                           --  In this case the next component stores the value\n-                           --  of the offset to the top\n-\n-                           Prev_E := E;\n-                           Next_Entity (E);\n-                           pragma Assert (Present (E));\n-\n-                           Append_To (Body_Stmts,\n-                             Make_Assignment_Statement (Loc,\n-                               Name =>\n-                                 Make_Selected_Component (Loc,\n-                                   Prefix => Make_Identifier (Loc,\n-                                               Name_uInit),\n-                                   Selector_Name =>\n-                                     New_Reference_To (E, Loc)),\n-                               Expression =>\n-                                 Make_Attribute_Reference (Loc,\n-                                   Prefix         =>\n-                                     Make_Selected_Component (Loc,\n-                                       Prefix => Make_Identifier (Loc,\n-                                                   Name_uInit),\n-                                       Selector_Name => New_Reference_To\n-                                                          (Prev_E, Loc)),\n-                                 Attribute_Name => Name_Position)));\n-\n-                        --  Normal case: No discriminants in the parent type\n-\n-                        else\n-                           --  Generate:\n-                           --    Set_Offset_To_Top\n-                           --      (This         => Init,\n-                           --       Interface_T  => Iface'Tag,\n-                           --       Is_Constant  => True,\n-                           --       Offset_Value => n,\n-                           --       Offset_Func  => null);\n-\n-                           Append_To (Body_Stmts,\n-                             Make_Procedure_Call_Statement (Loc,\n-                               Name => New_Reference_To\n-                                         (RTE (RE_Set_Offset_To_Top), Loc),\n-                               Parameter_Associations => New_List (\n-                                 Make_Attribute_Reference (Loc,\n-                                   Prefix => Make_Identifier (Loc, Name_uInit),\n-                                   Attribute_Name => Name_Address),\n-\n-                                 Unchecked_Convert_To (RTE (RE_Tag),\n-                                   New_Reference_To\n-                                     (Node (First_Elmt\n-                                            (Access_Disp_Table (Iface))),\n-                                      Loc)),\n-\n-                                 New_Occurrence_Of (Standard_True, Loc),\n-\n-                                 Unchecked_Convert_To (RTE (RE_Storage_Offset),\n-                                   Make_Attribute_Reference (Loc,\n-                                     Prefix         =>\n-                                      Make_Selected_Component (Loc,\n-                                        Prefix         => Make_Identifier (Loc,\n-                                                            Name_uInit),\n-                                        Selector_Name  => New_Reference_To\n-                                                            (E, Loc)),\n-                                    Attribute_Name => Name_Position)),\n-\n-                                 New_Reference_To\n-                                   (RTE (RE_Null_Address), Loc))));\n-                        end if;\n-\n-                        Next_Elmt (ADT);\n-                     end if;\n-\n-                     Next_Entity (E);\n-                  end loop;\n-               end if;\n-            end Init_Secondary_Tags_Internal;\n-\n-         --  Start of processing for Init_Secondary_Tags\n-\n-         begin\n-            --  Skip the first _Tag, which is the main tag of the\n-            --  tagged type. Following tags correspond with abstract\n-            --  interfaces.\n-\n-            ADT := Next_Elmt (First_Elmt (Access_Disp_Table (Typ)));\n-\n-            --  Handle private types\n-\n-            if Present (Full_View (Typ)) then\n-               Init_Secondary_Tags_Internal (Full_View (Typ));\n-            else\n-               Init_Secondary_Tags_Internal (Typ);\n-            end if;\n-         end Init_Secondary_Tags;\n-\n-      --  Start of processing for Build_Init_Procedure\n-\n       begin\n          Body_Stmts := New_List;\n          Body_Node := New_Node (N_Subprogram_Body, Loc);\n@@ -2217,26 +1999,19 @@ package body Exp_Ch3 is\n             --  the parent. In that case we insert the tag initialization\n             --  after the calls to initialize the parent.\n \n-            Init_Tag :=\n-              Make_If_Statement (Loc,\n-                Condition => New_Occurrence_Of (Set_Tag, Loc),\n-                Then_Statements => New_List (Init_Tag));\n-\n             if not Is_CPP_Class (Etype (Rec_Type)) then\n-               Prepend_To (Body_Stmts, Init_Tag);\n+               Init_Tag :=\n+                 Make_If_Statement (Loc,\n+                   Condition => New_Occurrence_Of (Set_Tag, Loc),\n+                   Then_Statements => New_List (Init_Tag));\n \n-               --  Ada 2005 (AI-251): Initialization of all the tags\n-               --  corresponding with abstract interfaces\n-\n-               if Ada_Version >= Ada_05\n-                 and then not Is_Interface (Rec_Type)\n-               then\n-                  Init_Secondary_Tags (Rec_Type);\n-               end if;\n+               Prepend_To (Body_Stmts, Init_Tag);\n \n             else\n                declare\n-                  Nod : Node_Id := First (Body_Stmts);\n+                  Nod   : Node_Id := First (Body_Stmts);\n+                  New_N : Node_Id;\n+                  Args  : List_Id;\n \n                begin\n                   --  We assume the first init_proc call is for the parent\n@@ -2248,9 +2023,99 @@ package body Exp_Ch3 is\n                      Nod := Next (Nod);\n                   end loop;\n \n-                  Insert_After (Nod, Init_Tag);\n+                  --  Generate:\n+                  --     ancestor_constructor (_init.parent);\n+                  --     if Arg2 then\n+                  --        _init._tag := new_dt;\n+                  --     end if;\n+\n+                  if Debug_Flag_QQ then\n+                     Init_Tag :=\n+                       Make_If_Statement (Loc,\n+                         Condition => New_Occurrence_Of (Set_Tag, Loc),\n+                         Then_Statements => New_List (Init_Tag));\n+                     Insert_After (Nod, Init_Tag);\n+\n+                  --  Generate:\n+                  --     ancestor_constructor (_init.parent);\n+                  --     if Arg2 then\n+                  --        inherit_dt (_init._tag, new_dt, num_prims);\n+                  --        _init._tag := new_dt;\n+                  --     end if;\n+                  else\n+                     Args := New_List (\n+                        Node1 =>\n+                          Make_Selected_Component (Loc,\n+                            Prefix => Make_Identifier (Loc, Name_uInit),\n+                            Selector_Name =>\n+                              New_Reference_To\n+                                (First_Tag_Component (Rec_Type), Loc)),\n+\n+                        Node2 =>\n+                          New_Reference_To\n+                            (Node (First_Elmt (Access_Disp_Table (Rec_Type))),\n+                             Loc),\n+\n+                        Node3 =>\n+                          Make_Integer_Literal (Loc,\n+                            DT_Entry_Count (First_Tag_Component (Rec_Type))));\n+\n+                     New_N :=\n+                       Make_Procedure_Call_Statement (Loc,\n+                         Name => New_Reference_To (RTE (RE_Inherit_CPP_DT),\n+                                                   Loc),\n+                         Parameter_Associations => Args);\n+\n+                     Init_Tag :=\n+                       Make_If_Statement (Loc,\n+                         Condition => New_Occurrence_Of (Set_Tag, Loc),\n+                         Then_Statements => New_List (New_N, Init_Tag));\n+\n+                     Insert_After (Nod, Init_Tag);\n+\n+                     --  We have inherited the whole contents of the DT table\n+                     --  from the CPP side. Therefore all our previous initia-\n+                     --  lization has been lost and we must refill entries\n+                     --  associated with Ada primitives. This needs more work\n+                     --  to avoid its execution each time an object is\n+                     --  initialized???\n+\n+                     declare\n+                        E    : Elmt_Id;\n+                        Prim : Node_Id;\n+\n+                     begin\n+                        E := First_Elmt (Primitive_Operations (Rec_Type));\n+                        while Present (E) loop\n+                           Prim := Node (E);\n+\n+                           if not Is_Imported (Prim)\n+                             and then Convention (Prim) = Convention_CPP\n+                             and then not Present (Abstract_Interface_Alias\n+                                                    (Prim))\n+                           then\n+                              Insert_After (Init_Tag,\n+                                 Fill_DT_Entry (Loc, Prim));\n+                           end if;\n+\n+                           Next_Elmt (E);\n+                        end loop;\n+                     end;\n+                  end if;\n                end;\n             end if;\n+\n+            --  Ada 2005 (AI-251): Initialization of all the tags\n+            --  corresponding with abstract interfaces\n+\n+            if Ada_Version >= Ada_05\n+              and then not Is_Interface (Rec_Type)\n+            then\n+               Init_Secondary_Tags\n+                 (Typ        => Rec_Type,\n+                  Target     => Make_Identifier (Loc, Name_uInit),\n+                  Stmts_List => Body_Stmts);\n+            end if;\n          end if;\n \n          Handled_Stmt_Node := New_Node (N_Handled_Sequence_Of_Statements, Loc);\n@@ -2383,6 +2248,8 @@ package body Exp_Ch3 is\n                        Rec_Type,\n                        Discr_Map => Discr_Map);\n \n+                  Clean_Task_Names (Typ, Proc_Id);\n+\n                --  Case of component needing simple initialization\n \n                elsif Component_Needs_Simple_Initialization (Typ) then\n@@ -2448,6 +2315,8 @@ package body Exp_Ch3 is\n                            Selector_Name => New_Occurrence_Of (Id, Loc)),\n                          Typ, True, Rec_Type, Discr_Map => Discr_Map));\n \n+                     Clean_Task_Names (Typ, Proc_Id);\n+\n                   elsif Component_Needs_Simple_Initialization (Typ) then\n                      Append_List_To (Statement_List,\n                        Build_Assignment\n@@ -2861,10 +2730,8 @@ package body Exp_Ch3 is\n       then\n          declare\n             Disc : Entity_Id;\n-\n          begin\n             Disc := First_Discriminant (Rec_Type);\n-\n             while Present (Disc) loop\n                Append_Elmt (Disc, Discr_Map);\n                Append_Elmt (Discriminal (Disc), Discr_Map);\n@@ -3708,6 +3575,7 @@ package body Exp_Ch3 is\n       Typ     : constant Entity_Id  := Etype (Def_Id);\n       Loc     : constant Source_Ptr := Sloc (N);\n       Expr    : constant Node_Id    := Expression (N);\n+\n       New_Ref : Node_Id;\n       Id_Ref  : Node_Id;\n       Expr_Q  : Node_Id;\n@@ -3886,6 +3754,19 @@ package body Exp_Ch3 is\n             Convert_Aggr_In_Object_Decl (N);\n \n          else\n+            --  Ada 2005 (AI-318-02): If the initialization expression is a\n+            --  call to a build-in-place function, then access to the declared\n+            --  object must be passed to the function. Currently we limit such\n+            --  functions to those with constrained limited result subtypes,\n+            --  but eventually we plan to expand the allowed forms of funtions\n+            --  that are treated as build-in-place.\n+\n+            if Ada_Version >= Ada_05\n+              and then Is_Build_In_Place_Function_Call (Expr_Q)\n+            then\n+               Make_Build_In_Place_Call_In_Object_Declaration (N, Expr_Q);\n+            end if;\n+\n             --  In most cases, we must check that the initial value meets any\n             --  constraint imposed by the declared type. However, there is one\n             --  very important exception to this rule. If the entity has an\n@@ -3914,7 +3795,19 @@ package body Exp_Ch3 is\n             --  list and adjust the target after the copy. This\n             --  ??? incomplete sentence\n \n-            if Controlled_Type (Typ) then\n+            --  Ada 2005 (AI-251): Do not register in the final list objects\n+            --  containing class-wide interfaces; otherwise we erroneously\n+            --  register the tag of the interface in the final list. Example:\n+\n+            --    Obj1 : T; --  Controlled object that implements Iface\n+            --    Obj2 : Iface'Class := Iface'Class (Obj1);\n+\n+            --  Obj1 is registered in the final list; Obj2 is not registered.\n+\n+            if Controlled_Type (Typ)\n+              and then not (Is_Interface (Typ)\n+                             and then Is_Class_Wide_Type (Typ))\n+            then\n                declare\n                   Flist : Node_Id;\n                   F     : Entity_Id;\n@@ -3942,12 +3835,17 @@ package body Exp_Ch3 is\n                      Flist := Find_Final_List (Def_Id);\n                   end if;\n \n-                  Insert_Actions_After (N,\n-                    Make_Adjust_Call (\n-                      Ref          => New_Reference_To (Def_Id, Loc),\n-                      Typ          => Base_Type (Typ),\n-                      Flist_Ref    => Flist,\n-                      With_Attach  => Make_Integer_Literal (Loc, 1)));\n+                  --  Adjustment is only needed when the controlled type is not\n+                  --  limited.\n+\n+                  if not Is_Limited_Type (Typ) then\n+                     Insert_Actions_After (N,\n+                       Make_Adjust_Call (\n+                         Ref          => New_Reference_To (Def_Id, Loc),\n+                         Typ          => Base_Type (Typ),\n+                         Flist_Ref    => Flist,\n+                         With_Attach  => Make_Integer_Literal (Loc, 1)));\n+                  end if;\n                end;\n             end if;\n \n@@ -4071,14 +3969,19 @@ package body Exp_Ch3 is\n    --  Add a check on the range of the subtype. The static case is partially\n    --  duplicated by Process_Range_Expr_In_Decl in Sem_Ch3, but we still need\n    --  to check here for the static case in order to avoid generating\n-   --  extraneous expanded code.\n+   --  extraneous expanded code. Also deal with validity checking.\n \n    procedure Expand_N_Subtype_Indication (N : Node_Id) is\n       Ran : constant Node_Id   := Range_Expression (Constraint (N));\n       Typ : constant Entity_Id := Entity (Subtype_Mark (N));\n \n    begin\n-      if Nkind (Parent (N)) = N_Constrained_Array_Definition or else\n+      if Nkind (Constraint (N)) = N_Range_Constraint then\n+         Validity_Check_Range (Range_Expression (Constraint (N)));\n+      end if;\n+\n+      if Nkind (Parent (N)) = N_Constrained_Array_Definition\n+           or else\n          Nkind (Parent (N)) = N_Slice\n       then\n          Resolve (Ran, Typ);\n@@ -4169,7 +4072,7 @@ package body Exp_Ch3 is\n          Loc := Sloc (First (Component_Items (Comp_List)));\n       end if;\n \n-      if Is_Return_By_Reference_Type (T) then\n+      if Is_Inherently_Limited_Type (T) then\n          Controller_Type := RTE (RE_Limited_Record_Controller);\n       else\n          Controller_Type := RTE (RE_Record_Controller);\n@@ -4198,12 +4101,31 @@ package body Exp_Ch3 is\n \n          First_Comp := First (Component_Items (Comp_List));\n \n-         if Chars (Defining_Identifier (First_Comp)) /= Name_uParent\n-           and then Chars (Defining_Identifier (First_Comp)) /= Name_uTag\n-         then\n+         if not Is_Tagged_Type (T) then\n             Insert_Before (First_Comp, Comp_Decl);\n+\n+         --  if T is a tagged type, place controller declaration after\n+         --  parent field and after eventual tags of implemented\n+         --  interfaces, if present.\n+\n          else\n-            Insert_After (First_Comp, Comp_Decl);\n+            while Present (First_Comp)\n+              and then\n+                (Chars (Defining_Identifier (First_Comp)) = Name_uParent\n+                   or else Is_Tag (Defining_Identifier (First_Comp)))\n+            loop\n+               Next (First_Comp);\n+            end loop;\n+\n+            --  An empty tagged extension might consist only of the parent\n+            --  component. Otherwise insert the controller before the first\n+            --  component that is neither parent nor tag.\n+\n+            if Present (First_Comp) then\n+               Insert_Before (First_Comp, Comp_Decl);\n+            else\n+               Append (Comp_Decl, Component_Items (Comp_List));\n+            end if;\n          end if;\n       end if;\n \n@@ -4300,6 +4222,23 @@ package body Exp_Ch3 is\n          return;\n    end Expand_Tagged_Root;\n \n+   ----------------------\n+   -- Clean_Task_Names --\n+   ----------------------\n+\n+   procedure Clean_Task_Names\n+     (Typ     : Entity_Id;\n+      Proc_Id : Entity_Id)\n+   is\n+   begin\n+      if Has_Task (Typ)\n+        and then not Restriction_Active (No_Implicit_Heap_Allocations)\n+        and then not Global_Discard_Names\n+      then\n+         Set_Uses_Sec_Stack (Proc_Id);\n+      end if;\n+   end Clean_Task_Names;\n+\n    -----------------------\n    -- Freeze_Array_Type --\n    -----------------------\n@@ -4685,8 +4624,9 @@ package body Exp_Ch3 is\n       Renamed_Eq  : Node_Id := Empty;\n       --  Could use some comments ???\n \n-      Wrapper_Decl_List : List_Id := No_List;\n-      Wrapper_Body_List : List_Id := No_List;\n+      Wrapper_Decl_List   : List_Id := No_List;\n+      Wrapper_Body_List   : List_Id := No_List;\n+      Null_Proc_Decl_List : List_Id := No_List;\n \n    begin\n       --  Build discriminant checking functions if not a derived type (for\n@@ -4849,6 +4789,20 @@ package body Exp_Ch3 is\n                Insert_List_Before_And_Analyze (N, Wrapper_Decl_List);\n             end if;\n \n+            --  Ada 2005 (AI-251): For a nonabstract type extension, build\n+            --  null procedure declarations for each set of homographic null\n+            --  procedures that are inherited from interface types but not\n+            --  overridden. This is done to ensure that the dispatch table\n+            --  entry associated with such null primitives are properly filled.\n+\n+            if Ada_Version >= Ada_05\n+              and then Etype (Def_Id) /= Def_Id\n+              and then not Is_Abstract (Def_Id)\n+            then\n+               Make_Null_Procedure_Specs (Def_Id, Null_Proc_Decl_List);\n+               Insert_Actions (N, Null_Proc_Decl_List);\n+            end if;\n+\n             Set_Is_Frozen (Def_Id, True);\n             Set_All_DT_Position (Def_Id);\n \n@@ -4929,9 +4883,9 @@ package body Exp_Ch3 is\n                   --  Handle private types\n \n                   if Present (Full_View (Def_Id)) then\n-                     Add_Secondary_Tables  (Full_View (Def_Id));\n+                     Add_Secondary_Tables (Full_View (Def_Id));\n                   else\n-                     Add_Secondary_Tables  (Def_Id);\n+                     Add_Secondary_Tables (Def_Id);\n                   end if;\n \n                   Set_Access_Disp_Table (Def_Id, ADT);\n@@ -5126,6 +5080,7 @@ package body Exp_Ch3 is\n             while Present (E) loop\n \n                if Is_Remote_Access_To_Class_Wide_Type (Node (E)) then\n+                  Validate_RACW_Primitives (Node (E));\n                   RACW_Seen := True;\n                end if;\n \n@@ -5182,7 +5137,7 @@ package body Exp_Ch3 is\n             then\n                --  The freeze node is only used to introduce the controller,\n                --  the back-end has no use for it for a discriminated\n-               --   component.\n+               --  component.\n \n                Set_Freeze_Node (Def_Id, Empty);\n                Set_Has_Delayed_Freeze (Def_Id, False);\n@@ -5903,9 +5858,304 @@ package body Exp_Ch3 is\n          return Empty_List;\n    end Init_Formals;\n \n-   -------------------------------------\n-   -- Make_Predefined_Primitive_Specs --\n-   -------------------------------------\n+   -------------------------\n+   -- Init_Secondary_Tags --\n+   -------------------------\n+\n+   procedure Init_Secondary_Tags\n+     (Typ        : Entity_Id;\n+      Target     : Node_Id;\n+      Stmts_List : List_Id)\n+   is\n+      Loc      : constant Source_Ptr := Sloc (Target);\n+      ADT      : Elmt_Id;\n+      Full_Typ : Entity_Id;\n+\n+      procedure Init_Secondary_Tags_Internal (Typ : Entity_Id);\n+      --  Internal subprogram used to recursively climb to the root type.\n+      --  We assume that all the primitives of the imported C++ class are\n+      --  defined in the C side.\n+\n+      ----------------------------------\n+      -- Init_Secondary_Tags_Internal --\n+      ----------------------------------\n+\n+      procedure Init_Secondary_Tags_Internal (Typ : Entity_Id) is\n+         Args   : List_Id;\n+         Aux_N  : Node_Id;\n+         E      : Entity_Id;\n+         Iface  : Entity_Id;\n+         New_N  : Node_Id;\n+         Prev_E : Entity_Id;\n+\n+      begin\n+         --  Climb to the ancestor (if any) handling private types\n+\n+         if Present (Full_View (Etype (Typ))) then\n+            if Full_View (Etype (Typ)) /= Typ then\n+               Init_Secondary_Tags_Internal (Full_View (Etype (Typ)));\n+            end if;\n+\n+         elsif Etype (Typ) /= Typ then\n+            Init_Secondary_Tags_Internal (Etype (Typ));\n+         end if;\n+\n+         if Is_Interface (Typ) then\n+            --  Generate:\n+            --    Set_Offset_To_Top\n+            --      (This         => Init,\n+            --       Interface_T  => Iface'Tag,\n+            --       Is_Constant  => True,\n+            --       Offset_Value => 0,\n+            --       Offset_Func  => null)\n+\n+            Append_To (Stmts_List,\n+              Make_Procedure_Call_Statement (Loc,\n+                Name => New_Reference_To (RTE (RE_Set_Offset_To_Top), Loc),\n+                Parameter_Associations => New_List (\n+                  Make_Attribute_Reference (Loc,\n+                    Prefix => New_Copy_Tree (Target),\n+                    Attribute_Name => Name_Address),\n+\n+                  Unchecked_Convert_To (RTE (RE_Tag),\n+                    New_Reference_To\n+                      (Node (First_Elmt (Access_Disp_Table (Typ))),\n+                       Loc)),\n+\n+                  New_Occurrence_Of (Standard_True, Loc),\n+\n+                  Make_Integer_Literal (Loc, Uint_0),\n+\n+                  New_Reference_To (RTE (RE_Null_Address), Loc))));\n+         end if;\n+\n+         if Present (Abstract_Interfaces (Typ))\n+           and then not Is_Empty_Elmt_List (Abstract_Interfaces (Typ))\n+         then\n+            E := First_Entity (Typ);\n+            while Present (E) loop\n+               if Is_Tag (E)\n+                 and then Chars (E) /= Name_uTag\n+               then\n+                  Aux_N := Node (ADT);\n+                  pragma Assert (Present (Aux_N));\n+\n+                  Iface := Find_Interface (Typ, E);\n+\n+                  --  If we are compiling under the CPP full ABI compatibility\n+                  --  mode and the ancestor is a CPP_Pragma tagged type then\n+                  --  we generate code to inherit the contents of the dispatch\n+                  --  table directly from the ancestor.\n+\n+                  if Is_CPP_Class (Etype (Typ))\n+                    and then not Debug_Flag_QQ\n+                  then\n+                     Args := New_List (\n+                       Node1 =>\n+                         Unchecked_Convert_To (RTE (RE_Tag),\n+                           Make_Selected_Component (Loc,\n+                             Prefix        => New_Copy_Tree (Target),\n+                             Selector_Name => New_Reference_To (E, Loc))),\n+                       Node2 =>\n+                         Unchecked_Convert_To (RTE (RE_Tag),\n+                           New_Reference_To (Aux_N, Loc)),\n+\n+                       Node3 =>\n+                         Make_Integer_Literal (Loc,\n+                           DT_Entry_Count (First_Tag_Component (Iface))));\n+\n+                     --  Issue error if Inherit_CPP_DT is not available\n+                     --  in a configurable run-time environment.\n+\n+                     if not RTE_Available (RE_Inherit_CPP_DT) then\n+                        Error_Msg_CRT (\"cpp interfacing\", Typ);\n+                        return;\n+                     end if;\n+\n+                     New_N :=\n+                       Make_Procedure_Call_Statement (Loc,\n+                         Name => New_Reference_To (RTE (RE_Inherit_CPP_DT),\n+                                                   Loc),\n+                         Parameter_Associations => Args);\n+\n+                     Append_To (Stmts_List, New_N);\n+                  end if;\n+\n+                  --  Initialize the pointer to the secondary DT associated\n+                  --  with the interface\n+\n+                  Append_To (Stmts_List,\n+                    Make_Assignment_Statement (Loc,\n+                      Name =>\n+                        Make_Selected_Component (Loc,\n+                          Prefix => New_Copy_Tree (Target),\n+                          Selector_Name => New_Reference_To (E, Loc)),\n+                      Expression =>\n+                        New_Reference_To (Aux_N, Loc)));\n+\n+                  --  If the ancestor is CPP_Class, nothing else to do here\n+\n+                  if Is_CPP_Class (Etype (Typ)) and then not Debug_Flag_QQ then\n+                     null;\n+\n+                  --  Otherwise, comment required ???\n+\n+                  else\n+                     --  Issue error if Set_Offset_To_Top is not available in a\n+                     --  configurable run-time environment.\n+\n+                     if not RTE_Available (RE_Set_Offset_To_Top) then\n+                        Error_Msg_CRT (\"abstract interface types\", Typ);\n+                        return;\n+                     end if;\n+\n+                     --  We generate a different call when the parent of the\n+                     --  type has discriminants.\n+\n+                     if Typ /= Etype (Typ)\n+                       and then Has_Discriminants (Etype (Typ))\n+                     then\n+                        pragma Assert\n+                          (Present (DT_Offset_To_Top_Func (E)));\n+\n+                        --  Generate:\n+                        --    Set_Offset_To_Top\n+                        --      (This         => Init,\n+                        --       Interface_T  => Iface'Tag,\n+                        --       Is_Constant  => False,\n+                        --       Offset_Value => n,\n+                        --       Offset_Func  => Fn'Address)\n+\n+                        Append_To (Stmts_List,\n+                          Make_Procedure_Call_Statement (Loc,\n+                            Name => New_Reference_To\n+                                      (RTE (RE_Set_Offset_To_Top), Loc),\n+                            Parameter_Associations => New_List (\n+                              Make_Attribute_Reference (Loc,\n+                                Prefix => New_Copy_Tree (Target),\n+                                Attribute_Name => Name_Address),\n+\n+                              Unchecked_Convert_To (RTE (RE_Tag),\n+                                New_Reference_To\n+                                  (Node (First_Elmt\n+                                         (Access_Disp_Table (Iface))),\n+                                   Loc)),\n+\n+                              New_Occurrence_Of (Standard_False, Loc),\n+\n+                              Unchecked_Convert_To\n+                                (RTE (RE_Storage_Offset),\n+                                 Make_Attribute_Reference (Loc,\n+                                   Prefix         =>\n+                                     Make_Selected_Component (Loc,\n+                                       Prefix => New_Copy_Tree (Target),\n+                                       Selector_Name =>\n+                                         New_Reference_To (E, Loc)),\n+                                   Attribute_Name => Name_Position)),\n+\n+                              Unchecked_Convert_To (RTE (RE_Address),\n+                                Make_Attribute_Reference (Loc,\n+                                  Prefix => New_Reference_To\n+                                              (DT_Offset_To_Top_Func (E),\n+                                               Loc),\n+                                  Attribute_Name =>\n+                                    Name_Address)))));\n+\n+                        --  In this case the next component stores the\n+                        --  value of the offset to the top.\n+\n+                        Prev_E := E;\n+                        Next_Entity (E);\n+                        pragma Assert (Present (E));\n+\n+                        Append_To (Stmts_List,\n+                          Make_Assignment_Statement (Loc,\n+                            Name =>\n+                              Make_Selected_Component (Loc,\n+                                Prefix => New_Copy_Tree (Target),\n+                                Selector_Name => New_Reference_To (E, Loc)),\n+                            Expression =>\n+                              Make_Attribute_Reference (Loc,\n+                                Prefix         =>\n+                                  Make_Selected_Component (Loc,\n+                                    Prefix => New_Copy_Tree (Target),\n+                                    Selector_Name =>\n+                                      New_Reference_To (Prev_E, Loc)),\n+                              Attribute_Name => Name_Position)));\n+\n+                     --  Normal case: No discriminants in the parent type\n+\n+                     else\n+                        --  Generate:\n+                        --    Set_Offset_To_Top\n+                        --      (This         => Init,\n+                        --       Interface_T  => Iface'Tag,\n+                        --       Is_Constant  => True,\n+                        --       Offset_Value => n,\n+                        --       Offset_Func  => null);\n+\n+                        Append_To (Stmts_List,\n+                          Make_Procedure_Call_Statement (Loc,\n+                            Name => New_Reference_To\n+                                      (RTE (RE_Set_Offset_To_Top), Loc),\n+                            Parameter_Associations => New_List (\n+                              Make_Attribute_Reference (Loc,\n+                                Prefix => New_Copy_Tree (Target),\n+                                Attribute_Name => Name_Address),\n+\n+                              Unchecked_Convert_To (RTE (RE_Tag),\n+                                New_Reference_To\n+                                  (Node (First_Elmt\n+                                         (Access_Disp_Table (Iface))),\n+                                   Loc)),\n+\n+                              New_Occurrence_Of (Standard_True, Loc),\n+\n+                              Unchecked_Convert_To\n+                                (RTE (RE_Storage_Offset),\n+                                 Make_Attribute_Reference (Loc,\n+                                   Prefix =>\n+                                    Make_Selected_Component (Loc,\n+                                      Prefix => New_Copy_Tree (Target),\n+                                      Selector_Name  =>\n+                                        New_Reference_To (E, Loc)),\n+                                  Attribute_Name => Name_Position)),\n+\n+                              New_Reference_To\n+                                (RTE (RE_Null_Address), Loc))));\n+                     end if;\n+                  end if;\n+\n+                  Next_Elmt (ADT);\n+               end if;\n+\n+               Next_Entity (E);\n+            end loop;\n+         end if;\n+      end Init_Secondary_Tags_Internal;\n+\n+   --  Start of processing for Init_Secondary_Tags\n+\n+   begin\n+      --  Skip the first _Tag, which is the main tag of the tagged type.\n+      --  Following tags correspond with abstract interfaces.\n+\n+      ADT := Next_Elmt (First_Elmt (Access_Disp_Table (Typ)));\n+\n+      --  Handle private types\n+\n+      if Present (Full_View (Typ)) then\n+         Full_Typ := Full_View (Typ);\n+      else\n+         Full_Typ := Typ;\n+      end if;\n+\n+      Init_Secondary_Tags_Internal (Full_Typ);\n+   end Init_Secondary_Tags;\n+\n+   ----------------------------------------\n+   -- Make_Controlling_Function_Wrappers --\n+   ----------------------------------------\n \n    procedure Make_Controlling_Function_Wrappers\n      (Tag_Typ   : Entity_Id;\n@@ -5937,16 +6187,17 @@ package body Exp_Ch3 is\n          --  If a primitive function with a controlling result of the type has\n          --  not been overridden by the user, then we must create a wrapper\n          --  function here that effectively overrides it and invokes the\n-         --  abstract inherited function's nonabstract parent. This can only\n-         --  occur for a null extension. Note that functions with anonymous\n-         --  controlling access results don't qualify and must be overridden.\n-         --  We also exclude Input attributes, since each type will have its\n-         --  own version of Input constructed by the expander. The test for\n-         --  Comes_From_Source is needed to distinguish inherited operations\n-         --  from renamings (which also have Alias set).\n+         --  (non-abstract) parent function. This can only occur for a null\n+         --  extension. Note that functions with anonymous controlling access\n+         --  results don't qualify and must be overridden. We also exclude\n+         --  Input attributes, since each type will have its own version of\n+         --  Input constructed by the expander. The test for Comes_From_Source\n+         --  is needed to distinguish inherited operations from renamings\n+         --  (which also have Alias set).\n \n          if Is_Abstract (Subp)\n            and then Present (Alias (Subp))\n+           and then not Is_Abstract (Alias (Subp))\n            and then not Comes_From_Source (Subp)\n            and then Ekind (Subp) = E_Function\n            and then Has_Controlling_Result (Subp)\n@@ -6207,6 +6458,96 @@ package body Exp_Ch3 is\n       end if;\n    end Make_Eq_If;\n \n+   -------------------------------\n+   -- Make_Null_Procedure_Specs --\n+   -------------------------------\n+\n+   procedure Make_Null_Procedure_Specs\n+     (Tag_Typ   : Entity_Id;\n+      Decl_List : out List_Id)\n+   is\n+      Loc         : constant Source_Ptr := Sloc (Tag_Typ);\n+      Formal      : Entity_Id;\n+      Formal_List : List_Id;\n+      Parent_Subp : Entity_Id;\n+      Prim_Elmt   : Elmt_Id;\n+      Proc_Spec   : Node_Id;\n+      Proc_Decl   : Node_Id;\n+      Subp        : Entity_Id;\n+\n+      function Is_Null_Interface_Primitive (E : Entity_Id) return Boolean;\n+      --  Returns True if E is a null procedure that is an interface primitive\n+\n+      ---------------------------------\n+      -- Is_Null_Interface_Primitive --\n+      ---------------------------------\n+\n+      function Is_Null_Interface_Primitive (E : Entity_Id) return Boolean is\n+      begin\n+         return Comes_From_Source (E)\n+           and then Is_Dispatching_Operation (E)\n+           and then Ekind (E) = E_Procedure\n+           and then Null_Present (Parent (E))\n+           and then Is_Interface (Find_Dispatching_Type (E));\n+      end Is_Null_Interface_Primitive;\n+\n+   --  Start of processing for Make_Null_Procedure_Specs\n+\n+   begin\n+      Decl_List := New_List;\n+      Prim_Elmt := First_Elmt (Primitive_Operations (Tag_Typ));\n+      while Present (Prim_Elmt) loop\n+         Subp := Node (Prim_Elmt);\n+\n+         --  If a null procedure inherited from an interface has not been\n+         --  overridden, then we build a null procedure declaration to\n+         --  override the inherited procedure.\n+\n+         Parent_Subp := Alias (Subp);\n+\n+         if Present (Parent_Subp)\n+           and then Is_Null_Interface_Primitive (Parent_Subp)\n+         then\n+            Formal_List := No_List;\n+            Formal := First_Formal (Subp);\n+\n+            if Present (Formal) then\n+               Formal_List := New_List;\n+\n+               while Present (Formal) loop\n+                  Append\n+                    (Make_Parameter_Specification (Loc,\n+                       Defining_Identifier =>\n+                         Make_Defining_Identifier (Sloc (Formal),\n+                           Chars => Chars (Formal)),\n+                       In_Present  => In_Present (Parent (Formal)),\n+                       Out_Present => Out_Present (Parent (Formal)),\n+                       Parameter_Type =>\n+                         New_Reference_To (Etype (Formal), Loc),\n+                       Expression =>\n+                         New_Copy_Tree (Expression (Parent (Formal)))),\n+                     Formal_List);\n+\n+                  Next_Formal (Formal);\n+               end loop;\n+            end if;\n+\n+            Proc_Spec :=\n+              Make_Procedure_Specification (Loc,\n+                Defining_Unit_Name =>\n+                  Make_Defining_Identifier (Loc, Chars (Subp)),\n+                Parameter_Specifications => Formal_List);\n+            Set_Null_Present (Proc_Spec);\n+\n+            Proc_Decl := Make_Subprogram_Declaration (Loc, Proc_Spec);\n+            Append_To (Decl_List, Proc_Decl);\n+            Analyze (Proc_Decl);\n+         end if;\n+\n+         Next_Elmt (Prim_Elmt);\n+      end loop;\n+   end Make_Null_Procedure_Specs;\n+\n    -------------------------------------\n    -- Make_Predefined_Primitive_Specs --\n    -------------------------------------\n@@ -6475,7 +6816,17 @@ package body Exp_Ch3 is\n       elsif Restriction_Active (No_Finalization) then\n          null;\n \n-      elsif Etype (Tag_Typ) = Tag_Typ or else Controlled_Type (Tag_Typ) then\n+      elsif Etype (Tag_Typ) = Tag_Typ\n+        or else Controlled_Type (Tag_Typ)\n+\n+         --  Ada 2005 (AI-251): We must also generate these subprograms if\n+         --  the immediate ancestor is an interface to ensure the correct\n+         --  initialization of its dispatch table.\n+\n+        or else (not Is_Interface (Tag_Typ)\n+                   and then\n+                 Is_Interface (Etype (Tag_Typ)))\n+      then\n          if not Is_Limited_Type (Tag_Typ) then\n             Append_To (Res,\n               Predef_Deep_Spec (Loc, Tag_Typ, TSS_Deep_Adjust));\n@@ -6953,7 +7304,16 @@ package body Exp_Ch3 is\n       elsif Restriction_Active (No_Finalization) then\n          null;\n \n-      elsif (Etype (Tag_Typ) = Tag_Typ or else Is_Controlled (Tag_Typ))\n+      elsif (Etype (Tag_Typ) = Tag_Typ\n+             or else Is_Controlled (Tag_Typ)\n+\n+               --  Ada 2005 (AI-251): We must also generate these subprograms\n+               --  if the immediate ancestor of Tag_Typ is an interface to\n+               --  ensure the correct initialization of its dispatch table.\n+\n+             or else (not Is_Interface (Tag_Typ)\n+                        and then\n+                      Is_Interface (Etype (Tag_Typ))))\n         and then not Has_Controlled_Component (Tag_Typ)\n       then\n          if not Is_Limited_Type (Tag_Typ) then"}, {"sha": "8260ce0123679ec18340a11aaf2d12ba9791c4c2", "filename": "gcc/ada/exp_ch3.ads", "status": "modified", "additions": 22, "deletions": 1, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3476f949088b2f18c0cee16a36ea4ea330248138/gcc%2Fada%2Fexp_ch3.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3476f949088b2f18c0cee16a36ea4ea330248138/gcc%2Fada%2Fexp_ch3.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.ads?ref=3476f949088b2f18c0cee16a36ea4ea330248138", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2006, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -91,13 +91,34 @@ package Exp_Ch3 is\n    --  initialization call corresponds to a default initialized component\n    --  of an aggregate.\n \n+   procedure Build_Master_Renaming (N : Node_Id; T : Entity_Id);\n+   --  If the designated type of an access type is a task type or contains\n+   --  tasks, we make sure that a _Master variable is declared in the current\n+   --  scope, and then declare a renaming for it:\n+   --\n+   --    atypeM : Master_Id renames _Master;\n+   --\n+   --  where atyp is the name of the access type. This declaration is\n+   --  used when an allocator for the access type is expanded. The node N\n+   --  is the full declaration of the designated type that contains tasks.\n+   --  The renaming declaration is inserted before N, and after the Master\n+   --  declaration.\n+\n    function Freeze_Type (N : Node_Id) return Boolean;\n    --  This function executes the freezing actions associated with the given\n    --  freeze type node N and returns True if the node is to be deleted. We\n    --  delete the node if it is present just for front end purpose and we don't\n    --  want Gigi to see the node. This function can't delete the node itself\n    --  since it would confuse any remaining processing of the freeze node.\n \n+   procedure Init_Secondary_Tags\n+     (Typ        : Entity_Id;\n+      Target     : Node_Id;\n+      Stmts_List : List_Id);\n+   --  Ada 2005 (AI-251): Initialize the tags of all the secondary tables\n+   --  associated with the abstract interfaces of Typ. The generated code\n+   --  referencing tag fields of Target is appended to Stmts_List.\n+\n    function Needs_Simple_Initialization (T : Entity_Id) return Boolean;\n    --  Certain types need initialization even though there is no specific\n    --  initialization routine. In this category are access types (which need"}]}