{"sha": "7a12ea32b2cf7ee53d0c43e26e12eb41e9853db1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2ExMmVhMzJiMmNmN2VlNTNkMGM0M2UyNmUxMmViNDFlOTg1M2RiMQ==", "commit": {"author": {"name": "Monk Chiang", "email": "sh.chiang04@gmail.com", "date": "2018-03-03T16:05:25Z"}, "committer": {"name": "Chung-Ju Wu", "email": "jasonwucj@gcc.gnu.org", "date": "2018-03-03T16:05:25Z"}, "message": "[NDS32] Rewrite infrastructure for intrinsic.\n\ngcc/\n\t* config/nds32/nds32-intrinsic.c\n\t(nds32_expand_builtin_null_ftype_reg): Delete.\n\t(nds32_expand_builtin_reg_ftype_imm): Ditto.\n\t(nds32_expand_builtin_null_ftype_reg_imm): Ditto.\n\t(nds32_read_argument): New.\n\t(nds32_legitimize_target): Ditto.\n\t(nds32_legitimize_argument): Ditto.\n\t(nds32_check_constant_argument): Ditto.\n\t(nds32_expand_unop_builtin): Ditto.\n\t(nds32_expand_unopimm_builtin): Ditto.\n\t(nds32_expand_binop_builtin): Ditto.\n\t(nds32_builtin_decl_impl): Ditto.\n\t(builtin_description): Ditto.\n\t(nds32_expand_builtin_impl): Rewrite with new infrastructure.\n\t(nds32_init_builtins_impl): Ditto.\n\t* config/nds32/nds32.c (TARGET_BUILTIN_DECL): Define.\n\t(nds32_builtin_decl): New.\n\t* config/nds32/nds32.h (nds32_builtins): Add NDS32_BUILTIN_COUNT.\n\t* config/nds32/nds32-protos.h (nds32_builtin_decl_impl): Declare.\n\nCo-Authored-By: Chung-Ju Wu <jasonwucj@gmail.com>\nCo-Authored-By: Kito Cheng <kito.cheng@gmail.com>\n\nFrom-SVN: r258211", "tree": {"sha": "f1ebb05bea89f7805a76ff8ed2289d81ebaa4f23", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f1ebb05bea89f7805a76ff8ed2289d81ebaa4f23"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7a12ea32b2cf7ee53d0c43e26e12eb41e9853db1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a12ea32b2cf7ee53d0c43e26e12eb41e9853db1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7a12ea32b2cf7ee53d0c43e26e12eb41e9853db1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a12ea32b2cf7ee53d0c43e26e12eb41e9853db1/comments", "author": {"login": "monkchiang", "id": 62004175, "node_id": "MDQ6VXNlcjYyMDA0MTc1", "avatar_url": "https://avatars.githubusercontent.com/u/62004175?v=4", "gravatar_id": "", "url": "https://api.github.com/users/monkchiang", "html_url": "https://github.com/monkchiang", "followers_url": "https://api.github.com/users/monkchiang/followers", "following_url": "https://api.github.com/users/monkchiang/following{/other_user}", "gists_url": "https://api.github.com/users/monkchiang/gists{/gist_id}", "starred_url": "https://api.github.com/users/monkchiang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/monkchiang/subscriptions", "organizations_url": "https://api.github.com/users/monkchiang/orgs", "repos_url": "https://api.github.com/users/monkchiang/repos", "events_url": "https://api.github.com/users/monkchiang/events{/privacy}", "received_events_url": "https://api.github.com/users/monkchiang/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c8bd326c4794fc26b4385a5736dd72a721fd5983", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c8bd326c4794fc26b4385a5736dd72a721fd5983", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c8bd326c4794fc26b4385a5736dd72a721fd5983"}], "stats": {"total": 451, "additions": 312, "deletions": 139}, "files": [{"sha": "e5aa19d0022a7a8463570d80495cd7b8a419ea0c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a12ea32b2cf7ee53d0c43e26e12eb41e9853db1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a12ea32b2cf7ee53d0c43e26e12eb41e9853db1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7a12ea32b2cf7ee53d0c43e26e12eb41e9853db1", "patch": "@@ -1,3 +1,27 @@\n+2018-03-03  Monk Chiang  <sh.chiang04@gmail.com>\n+\t    Kito Cheng  <kito.cheng@gmail.com>\n+\t    Chung-Ju Wu  <jasonwucj@gmail.com>\n+\n+\t* config/nds32/nds32-intrinsic.c\n+\t(nds32_expand_builtin_null_ftype_reg): Delete.\n+\t(nds32_expand_builtin_reg_ftype_imm): Ditto.\n+\t(nds32_expand_builtin_null_ftype_reg_imm): Ditto.\n+\t(nds32_read_argument): New.\n+\t(nds32_legitimize_target): Ditto.\n+\t(nds32_legitimize_argument): Ditto.\n+\t(nds32_check_constant_argument): Ditto.\n+\t(nds32_expand_unop_builtin): Ditto.\n+\t(nds32_expand_unopimm_builtin): Ditto.\n+\t(nds32_expand_binop_builtin): Ditto.\n+\t(nds32_builtin_decl_impl): Ditto.\n+\t(builtin_description): Ditto.\n+\t(nds32_expand_builtin_impl): Rewrite with new infrastructure.\n+\t(nds32_init_builtins_impl): Ditto.\n+\t* config/nds32/nds32.c (TARGET_BUILTIN_DECL): Define.\n+\t(nds32_builtin_decl): New.\n+\t* config/nds32/nds32.h (nds32_builtins): Add NDS32_BUILTIN_COUNT.\n+\t* config/nds32/nds32-protos.h (nds32_builtin_decl_impl): Declare.\n+\n 2018-03-02  Jeff Law  <law@redhat.com>\n \n \t* reorg.c (stop_search_p): Handle DEBUG_INSN."}, {"sha": "ad744c846e0ee87e748a25638b418814fce4592b", "filename": "gcc/config/nds32/nds32-intrinsic.c", "status": "modified", "additions": 275, "deletions": 138, "changes": 413, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a12ea32b2cf7ee53d0c43e26e12eb41e9853db1/gcc%2Fconfig%2Fnds32%2Fnds32-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a12ea32b2cf7ee53d0c43e26e12eb41e9853db1/gcc%2Fconfig%2Fnds32%2Fnds32-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32-intrinsic.c?ref=7a12ea32b2cf7ee53d0c43e26e12eb41e9853db1", "patch": "@@ -28,209 +28,346 @@\n #include \"backend.h\"\n #include \"target.h\"\n #include \"rtl.h\"\n+#include \"memmodel.h\"\n+#include \"emit-rtl.h\"\n #include \"tree.h\"\n #include \"memmodel.h\"\n #include \"optabs.h\"\t\t/* For GEN_FCN.  */\n #include \"diagnostic-core.h\"\n #include \"stor-layout.h\"\n #include \"expr.h\"\n #include \"langhooks.h\"\t\t/* For add_builtin_function().  */\n+#include \"recog.h\"\n+#include \"explow.h\"\n \n /* ------------------------------------------------------------------------ */\n \n-/* Function to expand builtin function for\n-   '[(unspec_volatile [(reg)])]'.  */\n+/* Read the requested argument from the EXP given by INDEX.\n+   Return the value as an rtx.  */\n static rtx\n-nds32_expand_builtin_null_ftype_reg (enum insn_code icode,\n-\t\t\t\t     tree exp, rtx target)\n+nds32_read_argument (tree exp, unsigned int index)\n {\n-  /* Mapping:\n-       ops[0] <--> value0 <--> arg0 */\n-  struct expand_operand ops[1];\n-  tree arg0;\n-  rtx value0;\n+  return expand_normal (CALL_EXPR_ARG (exp, index));\n+}\n \n-  /* Grab the incoming arguments and extract its rtx.  */\n-  arg0 = CALL_EXPR_ARG (exp, 0);\n-  value0 = expand_normal (arg0);\n+/* Return a legitimate rtx for instruction ICODE's return value.  Use TARGET\n+   if it's not null, has the right mode, and satisfies operand 0's\n+   predicate.  */\n+static rtx\n+nds32_legitimize_target (enum insn_code icode, rtx target)\n+{\n+  enum machine_mode mode = insn_data[icode].operand[0].mode;\n+\n+  if (! target\n+      || GET_MODE (target) != mode\n+      || ! (*insn_data[icode].operand[0].predicate) (target, mode))\n+    return gen_reg_rtx (mode);\n+  else\n+    return target;\n+}\n \n-  /* Create operands.  */\n-  create_input_operand (&ops[0], value0, TYPE_MODE (TREE_TYPE (arg0)));\n+/* Given that ARG is being passed as operand OPNUM to instruction ICODE,\n+   check whether ARG satisfies the operand's constraints.  If it doesn't,\n+   copy ARG to a temporary register and return that.  Otherwise return ARG\n+   itself.  */\n+static rtx\n+nds32_legitimize_argument (enum insn_code icode, int opnum, rtx arg)\n+{\n+  enum machine_mode mode = insn_data[icode].operand[opnum].mode;\n \n-  /* Emit new instruction.  */\n-  if (!maybe_expand_insn (icode, 1, ops))\n-    error (\"invalid argument to built-in function\");\n+  if ((*insn_data[icode].operand[opnum].predicate) (arg, mode))\n+    return arg;\n+  else if (VECTOR_MODE_P (mode) && CONST_INT_P (arg))\n+    {\n+      /* Handle CONST_INT covert to CONST_VECTOR.  */\n+      int nunits = GET_MODE_NUNITS (mode);\n+      int i, shift = 0;\n+      rtvec v = rtvec_alloc (nunits);\n+      int val = INTVAL (arg);\n+      enum machine_mode val_mode = (mode == V4QImode) ? QImode : HImode;\n+      int shift_acc = (val_mode == QImode) ? 8 : 16;\n+      int mask = (val_mode == QImode) ? 0xff : 0xffff;\n+      int tmp_val = val;\n+\n+      if (TARGET_BIG_ENDIAN)\n+\tfor (i = 0; i < nunits; i++)\n+\t  {\n+\t    tmp_val = (val >> shift) & mask;\n+\t    RTVEC_ELT (v, nunits - i - 1) = gen_int_mode (tmp_val, val_mode);\n+\t    shift += shift_acc;\n+\t  }\n+      else\n+\tfor (i = 0; i < nunits; i++)\n+\t  {\n+\t    tmp_val = (val >> shift) & mask;\n+\t    RTVEC_ELT (v, i) = gen_int_mode (tmp_val, val_mode);\n+\t    shift += shift_acc;\n+\t  }\n+\n+      return copy_to_mode_reg (mode, gen_rtx_CONST_VECTOR (mode, v));\n+    }\n+  else\n+    {\n+      rtx tmp_rtx = gen_reg_rtx (mode);\n+      convert_move (tmp_rtx, arg, false);\n+      return tmp_rtx;\n+    }\n+}\n \n-  return target;\n+/* Return true if OPVAL can be used for operand OPNUM of instruction ICODE.\n+   The instruction should require a constant operand of some sort.  The\n+   function prints an error if OPVAL is not valid.  */\n+static int\n+nds32_check_constant_argument (enum insn_code icode, int opnum, rtx opval,\n+\t\t\t       const char *name)\n+{\n+  if (GET_CODE (opval) != CONST_INT)\n+    {\n+      error (\"invalid argument to built-in function %s\", name);\n+      return false;\n+    }\n+  if (! (*insn_data[icode].operand[opnum].predicate) (opval, VOIDmode))\n+    {\n+      error (\"constant argument out of range for %s\", name);\n+\n+      return false;\n+    }\n+  return true;\n }\n \n-/* Function to expand builtin function for\n-   '[(set (reg) (unspec_volatile [(imm)]))]'.  */\n+/* Expand builtins that take one operand.  */\n static rtx\n-nds32_expand_builtin_reg_ftype_imm (enum insn_code icode,\n-\t\t\t\t    tree exp, rtx target)\n+nds32_expand_unop_builtin (enum insn_code icode, tree exp, rtx target,\n+\t\t\t   bool return_p)\n {\n-  /* Mapping:\n-       ops[0] <--> target <--> exp\n-       ops[1] <--> value0 <--> arg0 */\n-  struct expand_operand ops[2];\n-  tree arg0;\n-  rtx value0;\n+  rtx pat;\n+  rtx op0 = nds32_read_argument (exp, 0);\n+  int op0_num = return_p ? 1 : 0;\n+\n+  if (return_p)\n+    target = nds32_legitimize_target (icode, target);\n \n-  /* Grab the incoming arguments and extract its rtx.  */\n-  arg0 = CALL_EXPR_ARG (exp, 0);\n-  value0 = expand_normal (arg0);\n+  op0 = nds32_legitimize_argument (icode, op0_num, op0);\n \n-  /* Create operands.  */\n-  create_output_operand (&ops[0], target, TYPE_MODE (TREE_TYPE (exp)));\n-  create_input_operand (&ops[1], value0, TYPE_MODE (TREE_TYPE (arg0)));\n+  /* Emit and return the new instruction. */\n+  if (return_p)\n+    pat = GEN_FCN (icode) (target, op0);\n+  else\n+    pat = GEN_FCN (icode) (op0);\n \n-  /* Emit new instruction.  */\n-  if (!maybe_expand_insn (icode, 2, ops))\n-    error (\"invalid argument to built-in function\");\n+  if (! pat)\n+    return NULL_RTX;\n \n+  emit_insn (pat);\n   return target;\n }\n \n-/* Function to expand builtin function for\n-   '[(unspec_volatile [(reg) (imm)])]' pattern.  */\n+/* Expand builtins that take one operands and the first is immediate.  */\n static rtx\n-nds32_expand_builtin_null_ftype_reg_imm (enum insn_code icode,\n-\t\t\t\t\t tree exp, rtx target)\n+nds32_expand_unopimm_builtin (enum insn_code icode, tree exp, rtx target,\n+\t\t\t      bool return_p, const char *name)\n {\n-  /* Mapping:\n-       ops[0] <--> value0 <--> arg0\n-       ops[1] <--> value1 <--> arg1 */\n-  struct expand_operand ops[2];\n-  tree arg0, arg1;\n-  rtx value0, value1;\n-\n-  /* Grab the incoming arguments and extract its rtx.  */\n-  arg0 = CALL_EXPR_ARG (exp, 0);\n-  arg1 = CALL_EXPR_ARG (exp, 1);\n-  value0 = expand_normal (arg0);\n-  value1 = expand_normal (arg1);\n-\n-  /* Create operands.  */\n-  create_input_operand (&ops[0], value0, TYPE_MODE (TREE_TYPE (arg0)));\n-  create_input_operand (&ops[1], value1, TYPE_MODE (TREE_TYPE (arg1)));\n-\n-  /* Emit new instruction.  */\n-  if (!maybe_expand_insn (icode, 2, ops))\n-    error (\"invalid argument to built-in function\");\n+  rtx pat;\n+  rtx op0 = nds32_read_argument (exp, 0);\n+  int op0_num = return_p ? 1 : 0;\n+\n+  if (return_p)\n+    target = nds32_legitimize_target (icode, target);\n+\n+  if (!nds32_check_constant_argument (icode, op0_num, op0, name))\n+    return NULL_RTX;\n+\n+  op0 = nds32_legitimize_argument (icode, op0_num, op0);\n+\n+  /* Emit and return the new instruction. */\n+  if (return_p)\n+    pat = GEN_FCN (icode) (target, op0);\n+  else\n+    pat = GEN_FCN (icode) (op0);\n \n+  if (! pat)\n+    return NULL_RTX;\n+\n+  emit_insn (pat);\n   return target;\n }\n \n-/* ------------------------------------------------------------------------ */\n-\n-void\n-nds32_init_builtins_impl (void)\n+/* Expand builtins that take two operands.  */\n+static rtx\n+nds32_expand_binop_builtin (enum insn_code icode, tree exp, rtx target,\n+\t\t\t    bool return_p)\n {\n-  tree pointer_type_node  = build_pointer_type (integer_type_node);\n+  rtx pat;\n+  rtx op0 = nds32_read_argument (exp, 0);\n+  rtx op1 = nds32_read_argument (exp, 1);\n+  int op0_num = return_p ? 1 : 0;\n+  int op1_num = return_p ? 2 : 1;\n \n-  tree void_ftype_void    = build_function_type (void_type_node,\n-\t\t\t\t\t\t void_list_node);\n+  if (return_p)\n+    target = nds32_legitimize_target (icode, target);\n \n-  tree void_ftype_pint    = build_function_type_list (void_type_node,\n-\t\t\t\t\t\t      pointer_type_node,\n-\t\t\t\t\t\t      NULL_TREE);\n+  op0 = nds32_legitimize_argument (icode, op0_num, op0);\n+  op1 = nds32_legitimize_argument (icode, op1_num, op1);\n \n-  tree int_ftype_int      = build_function_type_list (integer_type_node,\n-\t\t\t\t\t\t      integer_type_node,\n-\t\t\t\t\t\t      NULL_TREE);\n+  /* Emit and return the new instruction. */\n+  if (return_p)\n+    pat = GEN_FCN (icode) (target, op0, op1);\n+  else\n+    pat = GEN_FCN (icode) (op0, op1);\n \n-  tree void_ftype_int_int = build_function_type_list (void_type_node,\n-\t\t\t\t\t\t      integer_type_node,\n-\t\t\t\t\t\t      integer_type_node,\n-\t\t\t\t\t\t      NULL_TREE);\n+  if (! pat)\n+    return NULL_RTX;\n \n-  /* Cache.  */\n-  add_builtin_function (\"__builtin_nds32_isync\",  void_ftype_pint,\n-\t\t\tNDS32_BUILTIN_ISYNC,\n-\t\t\tBUILT_IN_MD, NULL, NULL_TREE);\n-  add_builtin_function (\"__builtin_nds32_isb\",  void_ftype_void,\n-\t\t\tNDS32_BUILTIN_ISB,\n-\t\t\tBUILT_IN_MD, NULL, NULL_TREE);\n+  emit_insn (pat);\n+  return target;\n+}\n \n-  /* Register Transfer.  */\n-  add_builtin_function (\"__builtin_nds32_mfsr\",  int_ftype_int,\n-\t\t\tNDS32_BUILTIN_MFSR,\n-\t\t\tBUILT_IN_MD, NULL, NULL_TREE);\n-  add_builtin_function (\"__builtin_nds32_mfusr\", int_ftype_int,\n-\t\t\tNDS32_BUILTIN_MFUSR,\n-\t\t\tBUILT_IN_MD, NULL, NULL_TREE);\n-  add_builtin_function (\"__builtin_nds32_mtsr\",  void_ftype_int_int,\n-\t\t\tNDS32_BUILTIN_MTSR,\n-\t\t\tBUILT_IN_MD, NULL, NULL_TREE);\n-  add_builtin_function (\"__builtin_nds32_mtusr\", void_ftype_int_int,\n-\t\t\tNDS32_BUILTIN_MTUSR,\n-\t\t\tBUILT_IN_MD, NULL, NULL_TREE);\n+struct builtin_description\n+{\n+  const enum insn_code icode;\n+  const char *name;\n+  enum nds32_builtins code;\n+  bool return_p;\n+};\n+\n+#define NDS32_BUILTIN(code, string, builtin) \\\n+  { CODE_FOR_##code, \"__nds32__\" string, \\\n+    NDS32_BUILTIN_##builtin, true },\n+\n+#define NDS32_NO_TARGET_BUILTIN(code, string, builtin) \\\n+  { CODE_FOR_##code, \"__nds32__\" string, \\\n+    NDS32_BUILTIN_##builtin, false },\n+\n+/* Intrinsics that take just one argument.  */\n+static struct builtin_description bdesc_1arg[] =\n+{\n+  NDS32_NO_TARGET_BUILTIN(unspec_volatile_isync, \"isync\", ISYNC)\n+};\n \n-  /* Interrupt.  */\n-  add_builtin_function (\"__builtin_nds32_setgie_en\",  void_ftype_void,\n-\t\t\tNDS32_BUILTIN_SETGIE_EN,\n-\t\t\tBUILT_IN_MD, NULL, NULL_TREE);\n-  add_builtin_function (\"__builtin_nds32_setgie_dis\", void_ftype_void,\n-\t\t\tNDS32_BUILTIN_SETGIE_DIS,\n-\t\t\tBUILT_IN_MD, NULL, NULL_TREE);\n-}\n+/* Intrinsics that take just one argument. and the argument is immediate.  */\n+static struct builtin_description bdesc_1argimm[] =\n+{\n+  NDS32_BUILTIN(unspec_volatile_mfsr, \"mfsr\", MFSR)\n+  NDS32_BUILTIN(unspec_volatile_mfusr, \"mfsr\", MFUSR)\n+};\n \n+/* Intrinsics that take two arguments.  */\n+static struct builtin_description bdesc_2arg[] =\n+{\n+  NDS32_NO_TARGET_BUILTIN(unspec_volatile_mtsr, \"mtsr\", MTSR)\n+  NDS32_NO_TARGET_BUILTIN(unspec_volatile_mtusr, \"mtusr\", MTUSR)\n+};\n \n rtx\n nds32_expand_builtin_impl (tree exp,\n \t\t\t   rtx target,\n \t\t\t   rtx subtarget ATTRIBUTE_UNUSED,\n-\t\t\t   machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t\t   enum machine_mode mode ATTRIBUTE_UNUSED,\n \t\t\t   int ignore ATTRIBUTE_UNUSED)\n {\n   tree fndecl = TREE_OPERAND (CALL_EXPR_FN (exp), 0);\n+  unsigned int fcode = DECL_FUNCTION_CODE (fndecl);\n+  unsigned i;\n+  struct builtin_description *d;\n \n-  int fcode = DECL_FUNCTION_CODE (fndecl);\n-\n+  /* Since there are no result and operands, we can simply emit this rtx.  */\n   switch (fcode)\n     {\n-    /* Cache.  */\n-    case NDS32_BUILTIN_ISYNC:\n-      return nds32_expand_builtin_null_ftype_reg\n-\t     (CODE_FOR_unspec_volatile_isync, exp, target);\n     case NDS32_BUILTIN_ISB:\n-      /* Since there are no result and operands for isb instruciton,\n-         we can simply emit this rtx.  */\n       emit_insn (gen_unspec_volatile_isb ());\n       return target;\n-\n-    /* Register Transfer.  */\n-    case NDS32_BUILTIN_MFSR:\n-      return nds32_expand_builtin_reg_ftype_imm\n-\t     (CODE_FOR_unspec_volatile_mfsr, exp, target);\n-    case NDS32_BUILTIN_MFUSR:\n-      return nds32_expand_builtin_reg_ftype_imm\n-\t     (CODE_FOR_unspec_volatile_mfusr, exp, target);\n-    case NDS32_BUILTIN_MTSR:\n-      return nds32_expand_builtin_null_ftype_reg_imm\n-\t     (CODE_FOR_unspec_volatile_mtsr, exp, target);\n-    case NDS32_BUILTIN_MTUSR:\n-      return nds32_expand_builtin_null_ftype_reg_imm\n-\t     (CODE_FOR_unspec_volatile_mtusr, exp, target);\n-\n-    /* Interrupt.  */\n     case NDS32_BUILTIN_SETGIE_EN:\n-      /* Since there are no result and operands for setgie.e instruciton,\n-         we can simply emit this rtx.  */\n       emit_insn (gen_unspec_volatile_setgie_en ());\n       return target;\n     case NDS32_BUILTIN_SETGIE_DIS:\n-      /* Since there are no result and operands for setgie.d instruciton,\n-         we can simply emit this rtx.  */\n       emit_insn (gen_unspec_volatile_setgie_dis ());\n       return target;\n-\n     default:\n-      gcc_unreachable ();\n+      break;\n     }\n \n+  /* Expand groups of builtins.  */\n+  for (i = 0, d = bdesc_1arg; i < ARRAY_SIZE (bdesc_1arg); i++, d++)\n+    if (d->code == fcode)\n+      return nds32_expand_unop_builtin (d->icode, exp, target, d->return_p);\n+\n+  for (i = 0, d = bdesc_1argimm; i < ARRAY_SIZE (bdesc_1argimm); i++, d++)\n+    if (d->code == fcode)\n+      return nds32_expand_unopimm_builtin (d->icode, exp, target,\n+\t\t\t\t\t   d->return_p, d->name);\n+\n+  for (i = 0, d = bdesc_2arg; i < ARRAY_SIZE (bdesc_2arg); i++, d++)\n+    if (d->code == fcode)\n+      return nds32_expand_binop_builtin (d->icode, exp, target, d->return_p);\n+\n+\n   return NULL_RTX;\n }\n \n-/* ------------------------------------------------------------------------ */\n+static GTY(()) tree nds32_builtin_decls[NDS32_BUILTIN_COUNT];\n+\n+/* Return the NDS32 builtin for CODE.  */\n+tree\n+nds32_builtin_decl_impl (unsigned code, bool initialize_p ATTRIBUTE_UNUSED)\n+{\n+  if (code >= NDS32_BUILTIN_COUNT)\n+    return error_mark_node;\n+\n+  return nds32_builtin_decls[code];\n+}\n+\n+void\n+nds32_init_builtins_impl (void)\n+{\n+#define ADD_NDS32_BUILTIN0(NAME, RET_TYPE, CODE)\t\t\\\n+  nds32_builtin_decls[NDS32_BUILTIN_ ## CODE] =\t\t\t\\\n+  add_builtin_function (\"__builtin_nds32_\" NAME,\t\t\\\n+\t\t\tbuild_function_type_list (RET_TYPE##_type_node, \\\n+\t\t\t\t\t\t  NULL_TREE),\t\t\\\n+\t\t\tNDS32_BUILTIN_ ## CODE, BUILT_IN_MD, NULL, NULL_TREE)\n+\n+#define ADD_NDS32_BUILTIN1(NAME, RET_TYPE, ARG_TYPE, CODE)\t\\\n+  nds32_builtin_decls[NDS32_BUILTIN_ ## CODE] =\t\t\t\\\n+  add_builtin_function (\"__builtin_nds32_\" NAME,\t\t\\\n+\t\t\tbuild_function_type_list (RET_TYPE##_type_node, \\\n+\t\t\t\t\t\t  ARG_TYPE##_type_node, \\\n+\t\t\t\t\t\t  NULL_TREE),\t\t\\\n+\t\t\tNDS32_BUILTIN_ ## CODE, BUILT_IN_MD, NULL, NULL_TREE)\n+\n+#define ADD_NDS32_BUILTIN2(NAME, RET_TYPE, ARG_TYPE1, ARG_TYPE2, CODE)\t\\\n+  nds32_builtin_decls[NDS32_BUILTIN_ ## CODE] =\t\t\t\t\\\n+  add_builtin_function (\"__builtin_nds32_\" NAME,\t\t\t\\\n+\t\t\tbuild_function_type_list (RET_TYPE##_type_node, \\\n+\t\t\t\t\t\t  ARG_TYPE1##_type_node,\\\n+\t\t\t\t\t\t  ARG_TYPE2##_type_node,\\\n+\t\t\t\t\t\t  NULL_TREE),\t\t\\\n+\t\t\tNDS32_BUILTIN_ ## CODE, BUILT_IN_MD, NULL, NULL_TREE)\n+\n+#define ADD_NDS32_BUILTIN3(NAME, RET_TYPE,\t\t\t\t\\\n+\t\t\t   ARG_TYPE1, ARG_TYPE2, ARG_TYPE3, CODE)\t\\\n+  nds32_builtin_decls[NDS32_BUILTIN_ ## CODE] =\t\t\t\t\\\n+  add_builtin_function (\"__builtin_nds32_\" NAME,\t\t\t\\\n+\t\t\tbuild_function_type_list (RET_TYPE##_type_node,\t\\\n+\t\t\t\t\t\t  ARG_TYPE1##_type_node,\\\n+\t\t\t\t\t\t  ARG_TYPE2##_type_node,\\\n+\t\t\t\t\t\t  ARG_TYPE3##_type_node,\\\n+\t\t\t\t\t\t  NULL_TREE),\t\t\\\n+\t\t\tNDS32_BUILTIN_ ## CODE, BUILT_IN_MD, NULL, NULL_TREE)\n+\n+  /* Looking for return type and argument can be found in tree.h file.  */\n+  tree ptr_uint_type_node = build_pointer_type (unsigned_type_node);\n+\n+  /* Cache.  */\n+  ADD_NDS32_BUILTIN1 (\"isync\", void, ptr_uint, ISYNC);\n+  ADD_NDS32_BUILTIN0 (\"isb\", void, ISB);\n+\n+  /* Register Transfer.  */\n+  ADD_NDS32_BUILTIN1 (\"mfsr\", unsigned, integer, MFSR);\n+  ADD_NDS32_BUILTIN1 (\"mfusr\", unsigned, integer, MFUSR);\n+  ADD_NDS32_BUILTIN2 (\"mtsr\", void, unsigned, integer, MTSR);\n+  ADD_NDS32_BUILTIN2 (\"mtusr\", void, unsigned, integer, MTUSR);\n+\n+  /* Interrupt.  */\n+  ADD_NDS32_BUILTIN0 (\"setgie_en\", void, SETGIE_EN);\n+  ADD_NDS32_BUILTIN0 (\"setgie_dis\", void, SETGIE_DIS);\n+}"}, {"sha": "a989c3f0d234f37a06f2d2c639a22a8197c8f21e", "filename": "gcc/config/nds32/nds32-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a12ea32b2cf7ee53d0c43e26e12eb41e9853db1/gcc%2Fconfig%2Fnds32%2Fnds32-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a12ea32b2cf7ee53d0c43e26e12eb41e9853db1/gcc%2Fconfig%2Fnds32%2Fnds32-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32-protos.h?ref=7a12ea32b2cf7ee53d0c43e26e12eb41e9853db1", "patch": "@@ -125,6 +125,7 @@ extern int nds32_target_alignment (rtx_insn *);\n extern void nds32_init_builtins_impl (void);\n extern rtx nds32_expand_builtin_impl (tree, rtx, rtx,\n \t\t\t\t      machine_mode, int);\n+extern tree nds32_builtin_decl_impl (unsigned, bool);\n \n /* Auxiliary functions for ISR implementation.  */\n "}, {"sha": "085a7b86ade0b88bfe848757980a93b33dd1fee4", "filename": "gcc/config/nds32/nds32.c", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a12ea32b2cf7ee53d0c43e26e12eb41e9853db1/gcc%2Fconfig%2Fnds32%2Fnds32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a12ea32b2cf7ee53d0c43e26e12eb41e9853db1/gcc%2Fconfig%2Fnds32%2Fnds32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32.c?ref=7a12ea32b2cf7ee53d0c43e26e12eb41e9853db1", "patch": "@@ -2728,6 +2728,13 @@ nds32_init_builtins (void)\n   nds32_init_builtins_impl ();\n }\n \n+static tree\n+nds32_builtin_decl (unsigned code, bool initialize_p)\n+{\n+  /* Implement in nds32-intrinsic.c.  */\n+  return nds32_builtin_decl_impl (code, initialize_p);\n+}\n+\n static rtx\n nds32_expand_builtin (tree exp,\n \t\t      rtx target,\n@@ -3825,6 +3832,9 @@ nds32_target_alignment (rtx_insn *label)\n #undef TARGET_INIT_BUILTINS\n #define TARGET_INIT_BUILTINS nds32_init_builtins\n \n+#undef  TARGET_BUILTIN_DECL\n+#define TARGET_BUILTIN_DECL nds32_builtin_decl\n+\n #undef TARGET_EXPAND_BUILTIN\n #define TARGET_EXPAND_BUILTIN nds32_expand_builtin\n "}, {"sha": "5b33e3cc45057f17199119a5121f61968412758c", "filename": "gcc/config/nds32/nds32.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a12ea32b2cf7ee53d0c43e26e12eb41e9853db1/gcc%2Fconfig%2Fnds32%2Fnds32.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a12ea32b2cf7ee53d0c43e26e12eb41e9853db1/gcc%2Fconfig%2Fnds32%2Fnds32.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32.h?ref=7a12ea32b2cf7ee53d0c43e26e12eb41e9853db1", "patch": "@@ -345,7 +345,8 @@ enum nds32_builtins\n   NDS32_BUILTIN_MTSR,\n   NDS32_BUILTIN_MTUSR,\n   NDS32_BUILTIN_SETGIE_EN,\n-  NDS32_BUILTIN_SETGIE_DIS\n+  NDS32_BUILTIN_SETGIE_DIS,\n+  NDS32_BUILTIN_COUNT\n };\n \n /* ------------------------------------------------------------------------ */"}]}