{"sha": "82567e3386ed9d11a425f12d822ed1ee6b1c949b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODI1NjdlMzM4NmVkOWQxMWE0MjVmMTJkODIyZWQxZWU2YjFjOTQ5Yg==", "commit": {"author": {"name": "Ira Rosen", "email": "irar@il.ibm.com", "date": "2009-01-08T07:59:40Z"}, "committer": {"name": "Ira Rosen", "email": "irar@gcc.gnu.org", "date": "2009-01-08T07:59:40Z"}, "message": "re PR tree-optimization/37194 (Autovectorization of small constant iteration loop degrades performance)\n\n\tPR tree-optimization/37194\n\t* tree-vect-transform.c (vect_estimate_min_profitable_iters):\n\tDon't add the cost of cost model guard in prologue to scalar \n\toutside cost in case of known number of iterations.\n\nFrom-SVN: r143183", "tree": {"sha": "5cd604855fe17a73ebe3eb589b7ab54b64ac8d70", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5cd604855fe17a73ebe3eb589b7ab54b64ac8d70"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/82567e3386ed9d11a425f12d822ed1ee6b1c949b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/82567e3386ed9d11a425f12d822ed1ee6b1c949b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/82567e3386ed9d11a425f12d822ed1ee6b1c949b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/82567e3386ed9d11a425f12d822ed1ee6b1c949b/comments", "author": {"login": "irar2", "id": 16818592, "node_id": "MDQ6VXNlcjE2ODE4NTky", "avatar_url": "https://avatars.githubusercontent.com/u/16818592?v=4", "gravatar_id": "", "url": "https://api.github.com/users/irar2", "html_url": "https://github.com/irar2", "followers_url": "https://api.github.com/users/irar2/followers", "following_url": "https://api.github.com/users/irar2/following{/other_user}", "gists_url": "https://api.github.com/users/irar2/gists{/gist_id}", "starred_url": "https://api.github.com/users/irar2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/irar2/subscriptions", "organizations_url": "https://api.github.com/users/irar2/orgs", "repos_url": "https://api.github.com/users/irar2/repos", "events_url": "https://api.github.com/users/irar2/events{/privacy}", "received_events_url": "https://api.github.com/users/irar2/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "9982752346aac68d257d258332591df1f7b7817d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9982752346aac68d257d258332591df1f7b7817d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9982752346aac68d257d258332591df1f7b7817d"}], "stats": {"total": 69, "additions": 52, "deletions": 17}, "files": [{"sha": "33652905d4bb136ec55ac170edf446a2fefc13bd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82567e3386ed9d11a425f12d822ed1ee6b1c949b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82567e3386ed9d11a425f12d822ed1ee6b1c949b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=82567e3386ed9d11a425f12d822ed1ee6b1c949b", "patch": "@@ -1,3 +1,10 @@\n+2009-01-08  Ira Rosen  <irar@il.ibm.com>\n+\n+\tPR tree-optimization/37194\n+\t* tree-vect-transform.c (vect_estimate_min_profitable_iters):\n+\tDon't add the cost of cost model guard in prologue to scalar \n+\toutside cost in case of known number of iterations.\n+\n 2009-01-07  Nathan Froyd  <froydnj@codesourcery.com>\n \t    Alan Modra  <amodra@bigpond.net.au>\n "}, {"sha": "0c6c3a7e7e25d7ba6442adffc2e75f288db612a9", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82567e3386ed9d11a425f12d822ed1ee6b1c949b/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82567e3386ed9d11a425f12d822ed1ee6b1c949b/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=82567e3386ed9d11a425f12d822ed1ee6b1c949b", "patch": "@@ -1,3 +1,8 @@\n+2009-01-08  Ira Rosen  <irar@il.ibm.com>\n+\n+\tPR tree-optimization/37194\n+\t* gcc.dg/vect/costmodel/ppc/costmodel-pr37194.c: New test.\n+\n 2009-01-07  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c++/38725"}, {"sha": "76c7850fa10aeb240c5d83cd379c64a1ccdcf88c", "filename": "gcc/testsuite/gcc.dg/vect/costmodel/ppc/costmodel-pr37194.c", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82567e3386ed9d11a425f12d822ed1ee6b1c949b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fppc%2Fcostmodel-pr37194.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82567e3386ed9d11a425f12d822ed1ee6b1c949b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fppc%2Fcostmodel-pr37194.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fppc%2Fcostmodel-pr37194.c?ref=82567e3386ed9d11a425f12d822ed1ee6b1c949b", "patch": "@@ -0,0 +1,28 @@\n+/* { dg-require-effective-target vect_float } */\n+/* { dg-do compile } */\n+\n+#include <stdlib.h>\n+#include \"../../tree-vect.h\"\n+\n+__attribute__ ((noinline)) void \n+ggSpectrum_Set8(float * data, float d) \n+{\n+   int i;\n+\n+   for (i = 0; i < 8; i++)\n+      data[i] = d;\n+}\n+\n+__attribute__ ((noinline)) void \n+ggSpectrum_Set20(float * data, float d) \n+{\n+   int i;\n+\n+   for (i = 0; i < 20; i++)\n+      data[i] = d;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorization not profitable\" 1 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+"}, {"sha": "5b3344ad730cd51db35b684ccb9d490d1192a033", "filename": "gcc/tree-vect-transform.c", "status": "modified", "additions": 12, "deletions": 17, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82567e3386ed9d11a425f12d822ed1ee6b1c949b/gcc%2Ftree-vect-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82567e3386ed9d11a425f12d822ed1ee6b1c949b/gcc%2Ftree-vect-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-transform.c?ref=82567e3386ed9d11a425f12d822ed1ee6b1c949b", "patch": "@@ -122,7 +122,6 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo)\n   int vec_outside_cost = 0;\n   int scalar_single_iter_cost = 0;\n   int scalar_outside_cost = 0;\n-  bool runtime_test = false;\n   int vf = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n   struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n   basic_block *bbs = LOOP_VINFO_BBS (loop_vinfo);\n@@ -141,15 +140,7 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo)\n       return 0;\n     }\n \n-  /* If the number of iterations is unknown, or the\n-     peeling-for-misalignment amount is unknown, we will have to generate\n-     a runtime test to test the loop count against the threshold.    */\n-  if (!LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo)\n-      || (byte_misalign < 0))\n-    runtime_test = true;\n-\n   /* Requires loop versioning tests to handle misalignment.  */\n-\n   if (VEC_length (gimple, LOOP_VINFO_MAY_MISALIGN_STMTS (loop_vinfo)))\n     {\n       /*  FIXME: Make cost depend on complexity of individual check.  */\n@@ -240,12 +231,11 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo)\n                  \"peeling for alignment is unknown .\");\n \n       /* If peeled iterations are unknown, count a taken branch and a not taken\n-\t branch per peeled loop. Even if scalar loop iterations are known, \n-\t vector iterations are not known since peeled prologue iterations are\n-\t not known. Hence guards remain the same.  */\n+         branch per peeled loop. Even if scalar loop iterations are known,\n+         vector iterations are not known since peeled prologue iterations are\n+         not known. Hence guards remain the same.  */\n       peel_guard_costs +=  2 * (TARG_COND_TAKEN_BRANCH_COST\n-\t\t\t       + TARG_COND_NOT_TAKEN_BRANCH_COST);\n-\n+                              + TARG_COND_NOT_TAKEN_BRANCH_COST);\n     }\n   else \n     {\n@@ -337,16 +327,21 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo)\n      conditions/branch directions.  Change the estimates below to\n      something more reasonable.  */\n \n-  if (runtime_test)\n+  /* If the number of iterations is known and we do not do versioning, we can\n+     decide whether to vectorize at compile time. Hence the scalar version\n+     do not carry cost model guard costs.  */\n+  if (!LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo)\n+      || VEC_length (gimple, LOOP_VINFO_MAY_MISALIGN_STMTS (loop_vinfo))\n+      || VEC_length (ddr_p, LOOP_VINFO_MAY_ALIAS_DDRS (loop_vinfo)))\n     {\n       /* Cost model check occurs at versioning.  */\n       if (VEC_length (gimple, LOOP_VINFO_MAY_MISALIGN_STMTS (loop_vinfo))\n \t  || VEC_length (ddr_p, LOOP_VINFO_MAY_ALIAS_DDRS (loop_vinfo)))\n \tscalar_outside_cost += TARG_COND_NOT_TAKEN_BRANCH_COST;\n       else\n \t{\n-\t  /* Cost model occurs at prologue generation.  */\n-\t  if (LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo))\n+\t  /* Cost model check occurs at prologue generation.  */\n+\t  if (LOOP_PEELING_FOR_ALIGNMENT (loop_vinfo) < 0)\n \t    scalar_outside_cost += 2 * TARG_COND_TAKEN_BRANCH_COST\n \t      + TARG_COND_NOT_TAKEN_BRANCH_COST;\n \t  /* Cost model check occurs at epilogue generation.  */"}]}