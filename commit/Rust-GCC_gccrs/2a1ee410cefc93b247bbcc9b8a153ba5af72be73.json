{"sha": "2a1ee410cefc93b247bbcc9b8a153ba5af72be73", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmExZWU0MTBjZWZjOTNiMjQ3YmJjYzliOGExNTNiYTVhZjcyYmU3Mw==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2001-05-12T06:03:20Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2001-05-12T06:03:20Z"}, "message": "defaults.h (ASM_PREFERRED_EH_DATA_FORMAT): New.\n\n\t* defaults.h (ASM_PREFERRED_EH_DATA_FORMAT): New.\n\t* dwarf2asm.c (dw2_force_const_mem, dw2_output_indirect_constant_1,\n\tdw2_output_indirect_constants, dw2_asm_output_encoded_addr_rtx): New.\n\t* dwarf2asm.h (dw2_asm_output_encoded_addr_rtx): Prototype.\n\t(dw2_output_indirect_constants): Prototype.\n\t* dwarf2out.c (dwarf2out_begin_prologue): Generate\n\tcurrent_function_func_begin_label if we'll need it for EH.  Exit\n\tearly for IA64_UNWIND_INFO.\n\t* except.c: Get DW_EH_PE_* defines from dwarf2.h.\n\t(eh_data_format_name): Update for indirect references.\n\t(output_function_exception_table): Care for IA64_UNWIND_INFO.\n\tHandle ASM_PREFERRED_EH_DATA_FORMAT.\n\t* except.h (MUST_USE_SJLJ_EXCEPTIONS): IA64_UNWIND_INFO needn't\n\tdefine HAVE_eh_return etc.\n\t* final.c (final_start_function): Always call dwarf2out_begin_prologue.\n\t(final_end_function): Don't call output_function_exception_table.\n\t* toplev.c (compile_file): Call dw2_output_indirect_constants.\n\t(rest_of_compilation): Invoke output_function_exception_table\n\tfor ia64 before assemble_end_function.\n\t* tm.texi (ASM_PREFERRED_EH_DATA_FORMAT): Document.\n\t(ASM_MAYBE_OUTPUT_ENCODED_ADDR_RTX): Document.\n\n\t* unwind-dw2.c (_Unwind_GetTextRelBase, _Unwind_GetDataRelBase): New.\n\t* unwind.h: Declare them.\n\t* libgcc-std.ver: Export them.\n\t* unwind-pe.h: New file.\n\n\t* config/alpha/elf.h (ASM_PREFERRED_EH_DATA_FORMAT): New.\n\n\t* config/ia64/fde-glibc.c: Use \"struct unw_table_entry\"\n\tinstead of \"fde\".\n\t(find_fde_for_dso): Extract DT_PLTGOT.\n\t(_Unwind_FindTableEntry): Rename from __ia64_find_fde; return\n\tthe segment and gp as well.\n\t* config/ia64/frame-ia64.c: Remove file.\n\t* config/ia64/frame-ia64.h: Remove file.\n\t* config/ia64/unwind-ia64.c: New file.\n\t* config/ia64/unwind-ia64.h: New file.\n\t* config/ia64/ia64.h (ASM_OUTPUT_EH_CHAR): Remove.\n\t(ASM_OUTPUT_EH_SHORT, ASM_OUTPUT_EH_INT): Remove.\n\t(ASM_OUTPUT_EH_DOUBLE_INT): Remove.\n\t(ASM_PREFERRED_EH_DATA_FORMAT): New.\n\t(ASM_MAYBE_OUTPUT_ENCODED_ADDR_RTX): New.\n\t(IA64_UNWIND_INFO): Re-enable.\n\t(HANDLER_SECTION): Remove.\n\t(EH_RETURN_DATA_REGNO): New.\n\t* config/ia64/ia64.md (exception_receiver): Remove.\n\t* config/ia64/t-glibc (LIB2ADDEH): Re-enable.\n\t* config/ia64/t-ia64 (LIB2ADDEH): Re-enable.\n\nFrom-SVN: r41981", "tree": {"sha": "41492fd525139d18c6f3c8bd8894fcdf4cbcd139", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/41492fd525139d18c6f3c8bd8894fcdf4cbcd139"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2a1ee410cefc93b247bbcc9b8a153ba5af72be73", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a1ee410cefc93b247bbcc9b8a153ba5af72be73", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2a1ee410cefc93b247bbcc9b8a153ba5af72be73", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a1ee410cefc93b247bbcc9b8a153ba5af72be73/comments", "author": null, "committer": null, "parents": [{"sha": "f12f25a7f625fc69ab610b8997e1f6f5c1ccf982", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f12f25a7f625fc69ab610b8997e1f6f5c1ccf982", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f12f25a7f625fc69ab610b8997e1f6f5c1ccf982"}], "stats": {"total": 4202, "additions": 2771, "deletions": 1431}, "files": [{"sha": "cd72d9006e60c06a8b6c120619eb5b1d238dc735", "filename": "gcc/ChangeLog", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a1ee410cefc93b247bbcc9b8a153ba5af72be73/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a1ee410cefc93b247bbcc9b8a153ba5af72be73/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2a1ee410cefc93b247bbcc9b8a153ba5af72be73", "patch": "@@ -1,3 +1,55 @@\n+2001-05-11  Richard Henderson  <rth@redhat.com>\n+\n+\t* defaults.h (ASM_PREFERRED_EH_DATA_FORMAT): New.\n+\t* dwarf2asm.c (dw2_force_const_mem, dw2_output_indirect_constant_1,\n+\tdw2_output_indirect_constants, dw2_asm_output_encoded_addr_rtx): New.\n+\t* dwarf2asm.h (dw2_asm_output_encoded_addr_rtx): Prototype.\n+\t(dw2_output_indirect_constants): Prototype.\n+\t* dwarf2out.c (dwarf2out_begin_prologue): Generate\n+\tcurrent_function_func_begin_label if we'll need it for EH.  Exit\n+\tearly for IA64_UNWIND_INFO.\n+\t* except.c: Get DW_EH_PE_* defines from dwarf2.h.\n+\t(eh_data_format_name): Update for indirect references.\n+\t(output_function_exception_table): Care for IA64_UNWIND_INFO.\n+\tHandle ASM_PREFERRED_EH_DATA_FORMAT.\n+\t* except.h (MUST_USE_SJLJ_EXCEPTIONS): IA64_UNWIND_INFO needn't\n+\tdefine HAVE_eh_return etc.\n+\t* final.c (final_start_function): Always call dwarf2out_begin_prologue.\n+\t(final_end_function): Don't call output_function_exception_table.\n+\t* toplev.c (compile_file): Call dw2_output_indirect_constants.\n+\t(rest_of_compilation): Invoke output_function_exception_table \n+\tfor ia64 before assemble_end_function.\n+\t* tm.texi (ASM_PREFERRED_EH_DATA_FORMAT): Document.\n+\t(ASM_MAYBE_OUTPUT_ENCODED_ADDR_RTX): Document.\n+\n+\t* unwind-dw2.c (_Unwind_GetTextRelBase, _Unwind_GetDataRelBase): New.\n+\t* unwind.h: Declare them.\n+\t* libgcc-std.ver: Export them.\n+\t* unwind-pe.h: New file.\n+\n+\t* config/alpha/elf.h (ASM_PREFERRED_EH_DATA_FORMAT): New.\n+\n+\t* config/ia64/fde-glibc.c: Use \"struct unw_table_entry\"\n+\tinstead of \"fde\".\n+\t(find_fde_for_dso): Extract DT_PLTGOT.\n+\t(_Unwind_FindTableEntry): Rename from __ia64_find_fde; return\n+\tthe segment and gp as well.\n+\t* config/ia64/frame-ia64.c: Remove file.\n+\t* config/ia64/frame-ia64.h: Remove file.\n+\t* config/ia64/unwind-ia64.c: New file.\n+\t* config/ia64/unwind-ia64.h: New file.\n+\t* config/ia64/ia64.h (ASM_OUTPUT_EH_CHAR): Remove.\n+\t(ASM_OUTPUT_EH_SHORT, ASM_OUTPUT_EH_INT): Remove.\n+\t(ASM_OUTPUT_EH_DOUBLE_INT): Remove.\n+\t(ASM_PREFERRED_EH_DATA_FORMAT): New.\n+\t(ASM_MAYBE_OUTPUT_ENCODED_ADDR_RTX): New.\n+\t(IA64_UNWIND_INFO): Re-enable.\n+\t(HANDLER_SECTION): Remove.\n+\t(EH_RETURN_DATA_REGNO): New.\n+\t* config/ia64/ia64.md (exception_receiver): Remove.\n+\t* config/ia64/t-glibc (LIB2ADDEH): Re-enable.\n+\t* config/ia64/t-ia64 (LIB2ADDEH): Re-enable.\n+\n 2001-05-11  Richard Henderson  <rth@redhat.com>\n \n \t* config/ia64/ia64.c (group_barrier_needed_p): Don't allow"}, {"sha": "fd0874eee94de91e65c56ccc3a379a747d27b308", "filename": "gcc/config/alpha/elf.h", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a1ee410cefc93b247bbcc9b8a153ba5af72be73/gcc%2Fconfig%2Falpha%2Felf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a1ee410cefc93b247bbcc9b8a153ba5af72be73/gcc%2Fconfig%2Falpha%2Felf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Felf.h?ref=2a1ee410cefc93b247bbcc9b8a153ba5af72be73", "patch": "@@ -685,3 +685,16 @@ void FN ()\t\t\t\t\t\\\n #undef UNALIGNED_SHORT_ASM_OP\n #undef UNALIGNED_INT_ASM_OP\n #undef UNALIGNED_DOUBLE_INT_ASM_OP\n+\n+/* ??? This should be possible for ECOFF as well, since the relocations\n+   exist.  But the assembler doesn't seem to create them.  */\n+/* Select a format to encode pointers in exception handling data.  CODE\n+   is 0 for data, 1 for code labels, 2 for function pointers.  GLOBAL is\n+   true if the symbol may be affected by dynamic relocations.\n+\n+   Since application size is already constrained to <2GB by the form of\n+   the ldgp relocation, we can use a 32-bit pc-relative relocation to\n+   static data.  Dynamic data is accessed indirectly to allow for read\n+   only EH sections.  */\n+#define ASM_PREFERRED_EH_DATA_FORMAT(CODE,GLOBAL)       \\\n+  (((GLOBAL) ? DW_EH_PE_indirect : 0) | DW_EH_PE_pcrel | DW_EH_PE_sdata4)"}, {"sha": "7dd698452aef811e8ea3f29427f15fa7f671083e", "filename": "gcc/config/ia64/fde-glibc.c", "status": "modified", "additions": 54, "deletions": 29, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a1ee410cefc93b247bbcc9b8a153ba5af72be73/gcc%2Fconfig%2Fia64%2Ffde-glibc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a1ee410cefc93b247bbcc9b8a153ba5af72be73/gcc%2Fconfig%2Fia64%2Ffde-glibc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Ffde-glibc.c?ref=2a1ee410cefc93b247bbcc9b8a153ba5af72be73", "patch": "@@ -31,7 +31,7 @@\n #include <stdlib.h>\n #include <link.h>\n #include <bits/libc-lock.h>\n-#include \"frame-ia64.h\"\n+#include \"unwind-ia64.h\"\n \n \n /* Initialized by crtbegin from the main application.  */\n@@ -41,20 +41,17 @@ extern Elf64_Ehdr *__ia64_app_header;\n    appear in <link.h> in a new glibc version.  */\n __libc_lock_define (extern, _dl_load_lock)\n \n-/* ??? _dl_load_lock is not exported from glibc 2.1, but it is \n-   from glibc 2.2.  Remove this when folks have migrated.  */\n-#pragma weak _dl_load_lock\n-\n /* This always exists, even in a static application.  */\n extern struct link_map *_dl_loaded;\n \n-static fde *\n-find_fde_for_dso (Elf64_Addr pc, Elf64_Ehdr *ehdr)\n+static struct unw_table_entry *\n+find_fde_for_dso (Elf64_Addr pc, Elf64_Ehdr *ehdr,\n+\t\t  unsigned long *pseg_base, unsigned long *pgp)\n {\n-  Elf64_Phdr *phdr, *p_unwind;\n+  Elf64_Phdr *phdr, *p_unwind, *p_dynamic;\n   long n, match;\n   Elf64_Addr load_base, seg_base;\n-  fde *f_base;\n+  struct unw_table_entry *f_base, *f;\n   size_t lo, hi;\n \n   /* Verify that we are looking at an ELF header.  */\n@@ -71,6 +68,7 @@ find_fde_for_dso (Elf64_Addr pc, Elf64_Ehdr *ehdr)\n   phdr = (Elf64_Phdr *)((char *)ehdr + ehdr->e_phoff);\n   load_base = (ehdr->e_type == ET_DYN ? (Elf64_Addr)ehdr : 0);\n   p_unwind = NULL;\n+  p_dynamic = NULL;\n \n   /* See if PC falls into one of the loaded segments.  Find the unwind\n      segment at the same time.  */\n@@ -84,69 +82,96 @@ find_fde_for_dso (Elf64_Addr pc, Elf64_Ehdr *ehdr)\n \t}\n       else if (phdr->p_type == PT_IA_64_UNWIND)\n \tp_unwind = phdr;\n+      else if (phdr->p_type == PT_DYNAMIC)\n+\tp_dynamic = phdr;\n     }\n   if (!match || !p_unwind)\n     return NULL;\n \n   /* Search for the FDE within the unwind segment.  */\n \n-  f_base = (fde *) (p_unwind->p_vaddr + load_base);\n+  f_base = (struct unw_table_entry *) (p_unwind->p_vaddr + load_base);\n   seg_base = (Elf64_Addr) ehdr;\n   lo = 0;\n-  hi = p_unwind->p_memsz / sizeof (fde);\n+  hi = p_unwind->p_memsz / sizeof (struct unw_table_entry);\n \n   while (lo < hi)\n     {\n       size_t mid = (lo + hi) / 2;\n-      fde *f = f_base + mid;\n \n+      f = f_base + mid;\n       if (pc < f->start_offset + seg_base)\n \thi = mid;\n       else if (pc >= f->end_offset + seg_base)\n \tlo = mid + 1;\n       else\n-        return f;\n+        goto found;\n     }\n-\n   return NULL;\n+\n+ found:\n+  *pseg_base = seg_base;\n+  *pgp = 0;\n+\n+  if (p_dynamic)\n+    {\n+      /* For dynamicly linked executables and shared libraries,\n+\t DT_PLTGOT is the gp value for that object.  */\n+      Elf64_Dyn *dyn = (Elf64_Dyn *)(p_dynamic->p_vaddr + load_base);\n+      for (; dyn->d_tag != DT_NULL ; dyn++)\n+\tif (dyn->d_tag == DT_PLTGOT)\n+\t  {\n+\t    /* ??? Glibc seems to have relocated this already.  */\n+\t    *pgp = dyn->d_un.d_ptr;\n+\t    break;\n+\t  }\n+    }\n+  else\n+    {\n+      /* Otherwise this is a static executable with no _DYNAMIC.\n+\t The gp is constant program-wide.  */\n+      register unsigned long gp __asm__(\"gp\");\n+      *pgp = gp;\n+    }\n+\n+  return f;\n }\n \n-/* Return a pointer to the FDE for the function containing PC.  */\n-fde *\n-__ia64_find_fde (void *pc, void **pc_base)\n+/* Return a pointer to the unwind table entry for the function\n+   containing PC.  */\n+\n+struct unw_table_entry *\n+_Unwind_FindTableEntry (void *pc, unsigned long *segment_base,\n+                        unsigned long *gp)\n {\n-  fde *ret;\n+  struct unw_table_entry *ret;\n   struct link_map *map;\n \n   /* Check the main application first, hoping that most of the user's\n      code is there instead of in some library.  */\n-  ret = find_fde_for_dso ((Elf64_Addr)pc, __ia64_app_header);\n+  ret = find_fde_for_dso ((Elf64_Addr)pc, __ia64_app_header,\n+\t\t\t  segment_base, gp);\n   if (ret)\n-    {\n-      *pc_base = __ia64_app_header;\n-      return ret;\n-    }\n+    return ret;\n \n   /* Glibc is probably unique in that we can (with certain restrictions)\n      dynamicly load libraries into staticly linked applications.  Thus\n      we _always_ check _dl_loaded.  */\n \n-  if (&_dl_load_lock)\n-    __libc_lock_lock (_dl_load_lock);\n+  __libc_lock_lock (_dl_load_lock);\n \n   for (map = _dl_loaded; map ; map = map->l_next)\n     {\n       /* Skip the main application's entry.  */\n       if (map->l_name[0] == 0)\n \tcontinue;\n-      ret = find_fde_for_dso ((Elf64_Addr)pc, (Elf64_Ehdr *)map->l_addr);\n+      ret = find_fde_for_dso ((Elf64_Addr)pc, (Elf64_Ehdr *)map->l_addr,\n+\t\t\t      segment_base, gp);\n       if (ret)\n \tbreak;\n     }\n \n-  if (&_dl_load_lock)\n-    __libc_lock_unlock (_dl_load_lock);\n+  __libc_lock_unlock (_dl_load_lock);\n \n-  *pc_base = (void *)(map ? map->l_addr : 0);\n   return ret;\n }"}, {"sha": "4834a8b3cdfb9525edf857f05130e6ebd6678ffe", "filename": "gcc/config/ia64/frame-ia64.c", "status": "removed", "additions": 0, "deletions": 1272, "changes": 1272, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f12f25a7f625fc69ab610b8997e1f6f5c1ccf982/gcc%2Fconfig%2Fia64%2Fframe-ia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f12f25a7f625fc69ab610b8997e1f6f5c1ccf982/gcc%2Fconfig%2Fia64%2Fframe-ia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fframe-ia64.c?ref=f12f25a7f625fc69ab610b8997e1f6f5c1ccf982", "patch": "@@ -1,1272 +0,0 @@\n-/* Subroutines needed for unwinding IA-64 standard format stack frame\n-   info for exception handling.  */\n-/* Compile this one with gcc.  */\n-/* Copyright (C) 1997, 1998, 1999, 2000, 2001 Free Software Foundation, Inc.\n-   Contributed by Andrew MacLeod  <amacleod@cygnus.com>\n-                  Andrew Haley  <aph@cygnus.com>\n-\n-This file is part of GNU CC.\n-\n-GNU CC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU CC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-/* As a special exception, if you link this library with other files,\n-   some of which are compiled with GCC, to produce an executable,\n-   this library does not by itself cause the resulting executable\n-   to be covered by the GNU General Public License.\n-   This exception does not however invalidate any other reasons why\n-   the executable file might be covered by the GNU General Public License.  */\n-\n-/* It is incorrect to include config.h here, because this file is being\n-   compiled for the target, and hence definitions concerning only the host\n-   do not apply.  */\n-\n-#include \"tconfig.h\"\n-\n-/* We disable this when inhibit_libc, so that gcc can still be built without\n-   needing header files first.  */\n-/* ??? This is not a good solution, since prototypes may be required in\n-   some cases for correct code.  See also libgcc2.c/crtstuff.c.  */\n-#ifndef inhibit_libc\n-#include <stdlib.h>\n-#include <unistd.h>\n-#else\n-#include <stddef.h>\n-#endif\n-\n-#include \"frame-ia64.h\"\n-#include \"eh-common.h\"\n-\n-/* Some types used by the DWARF 2 spec.  */\n-\n-typedef          int  sword __attribute__ ((mode (SI)));\n-typedef unsigned int  uword __attribute__ ((mode (SI)));\n-typedef unsigned int  uaddr __attribute__ ((mode (pointer)));\n-typedef          int  saddr __attribute__ ((mode (pointer)));\n-typedef unsigned char ubyte;\n-\n-#include \"frame.h\" \n-\n-/* Decode the unsigned LEB128 constant at BUF and return it. The value at\n-   MEM is updated to reflect the next position in the buffer.  */\n-\n-static unsigned long\n-read_uleb128 (unsigned char **mem)\n-{\n-  unsigned shift = 0;\n-  unsigned long result = 0;\n-  unsigned char *buf = *mem;\n-\n-  while (1)\n-    {\n-      unsigned long byte = *buf++;\n-      result |= (byte & 0x7f) << shift;\n-      if ((byte & 0x80) == 0)\n-        break;\n-      shift += 7;\n-    }\n-  *mem = buf;\n-  return result;\n-}\n-\n-\n-static unsigned char *\n-read_R_record (unwind_record *data, unsigned char val, unsigned char *ptr)\n-{\n-  if ((val & 0x40) == 0)\n-    {\n-      /* R1 format.  */\n-      if (val & 0x20)\n-        data->type = body;\n-      else\n-        data->type = prologue;\n-      data->record.r.rlen = (val & 0x1f);\n-      return ptr;\n-    }\n-\n-  if ((val & 0xF8) == UNW_R2)\n-    {\n-      /* R2 format.  */\n-      unsigned char mask = (val & 0x07) << 1;\n-      if (*ptr & 0x80) \n-        mask = mask | 1;\n-      data->type = prologue_gr;\n-      data->record.r.mask = mask;\n-      data->record.r.grsave = (*ptr++ & 0x7f);\n-      data->record.r.rlen = read_uleb128 (&ptr);\n-      return ptr;\n-    }\n-\n-  if ((val & 0xFC) == UNW_R3)\n-    {\n-      /* R3 format.  */\n-      val = (val & 0x03);\n-      if (val == 0)\n-        data->type = prologue;\n-      else\n-        if (val == 1)\n-\t  data->type = body;\n-\telse\n-\t  abort ();\n-      data->record.r.rlen = read_uleb128 (&ptr);\n-      return ptr;\n-    }\n-  abort ();\n-}\n-\n-static void\n-process_a_b_reg_code(unwind_record *data, unsigned char val)\n-{\n-  int code = (val & 0x60) >> 5;\n-  int reg = (val & 0x1f);\n-  switch (code) \n-    {\n-      case 0:\n-\tdata->record.x.reg = GR_REG (reg);\n-        break;\n-      case 1:\n-\tdata->record.x.reg = FR_REG (reg);\n-        break;\n-      case 2:\n-\tdata->record.x.reg = BR_REG (reg);\n-        break;\n-      case 3:\n-        /* TODO. We need to encode the specialty regs here. The table is \n-\t   on page B-9 of the runtime manual (under the X1 description.) */\n-        break;\n-    }\n-}\n-\n-static unsigned char *\n-read_X_record (unwind_record *data, unsigned char val, unsigned char *ptr)\n-{\n-  unsigned long tmp;\n-  int byte1, byte2;\n-  switch (val) \n-    {\n-      case UNW_X1:\n-        byte1 = *ptr++;\n-\tdata->record.x.t = read_uleb128 (&ptr);\n-\ttmp = read_uleb128 (&ptr);\n-\tif ((byte1 & 0x80) == 0)\n-\t  {\n-\t    data->type = spill_psprel;\n-\t    data->record.x.pspoff = tmp;\n-\t  }\n-\telse\n-\t  {\n-\t    data->type = spill_sprel;\n-\t    data->record.x.spoff = tmp;\n-\t  }\n-\tprocess_a_b_reg_code (data, byte1);\n-\treturn ptr;\n-      case UNW_X4:\n-        byte1 = *ptr++;\n-\tdata->record.x.qp = PR_REG (byte1 & 0x3f);\n-\tdata->type = spill_reg_p;\n-      case UNW_X2:\n-        {\n-\t  int xy;\n-\t  int treg;\n-\t  /* Only set type if we didn't fall through the UNW_X4 case.  */\n-\t  if (val == UNW_X2)\n-\t    data->type = spill_reg;\n-\t  byte1 = *ptr++;\n-\t  byte2 = *ptr++;\n-\t  process_a_b_reg_code (data, byte1);\n-\t  xy = (((byte1 >> 7) << 1 ) | (byte2 >> 7));\n-\t  treg = (byte2 & 0x7f);\n-\t  switch (xy) \n-\t    {\n-\t      case 0:\n-\t        data->record.x.treg = GR_REG (treg);\n-\t        break;\n-\t      case 1:\n-\t        data->record.x.treg = FR_REG (treg);\n-\t        break;\n-\t      case 2:\n-\t        data->record.x.treg = BR_REG (treg);\n-\t        break;\n-\t      case 3:\n-\t        abort ();\n-\t    }\n-\t  data->record.x.t = read_uleb128 (&ptr);\n-        }\n-\treturn ptr;\n-      case UNW_X3:\n-        byte1 = *ptr++;\n-\tbyte2 = *ptr++;\n-\tdata->record.x.qp = PR_REG (byte1 & 0x3f);\n-\tprocess_a_b_reg_code (data, byte2);\n-\tdata->record.x.t = read_uleb128 (&ptr);\n-\ttmp = read_uleb128 (&ptr);\n-\tif ((byte1 & 0x80) == 0)\n-\t  {\n-\t    data->type = spill_psprel_p;\n-\t    data->record.x.pspoff = tmp;\n-\t  }\n-\telse\n-\t  {\n-\t    data->type = spill_sprel_p;\n-\t    data->record.x.spoff = tmp;\n-\t  }\t\n-\treturn ptr;\n-      default:\n-\tabort ();\n-    }\n-  return NULL;\n-}\n-\n-static unsigned char *\n-read_B_record (unwind_record *data, unsigned char val, unsigned char *ptr)\n-{\n-  if ((val & 0xc0) == 0x80)\n-    {\n-      /* B1 format.  */\n-      if ((val & 0x20) == 0)\n-        data->type = label_state;\n-      else\n-        data->type = copy_state;\n-      data->record.b.label = (val & 0x1f);\n-      return ptr;\n-    }\n-  \n-  if ((val & 0xe0) == 0xc0)\n-    {\n-      /* B2 format.  */\n-      data->type = epilogue;\n-      data->record.b.ecount = (val & 0x1f);\n-      data->record.b.t = read_uleb128 (&ptr);\n-      return ptr;\n-    }\n-\n-  if (val == UNW_B3)\n-    {\n-      /* B3 format.  */\n-      data->type = epilogue;\n-      data->record.b.t = read_uleb128 (&ptr);\n-      data->record.b.ecount = read_uleb128 (&ptr);\n-      return ptr;\n-    }\n-\n-  if (val == UNW_B4)\n-    {\n-      /* B4 format, with r == 0.  */\n-      data->type = label_state;\n-      data->record.b.label = read_uleb128 (&ptr);\n-      return ptr;\n-    }\n-\n-  if (val == (UNW_B4 | 0x08))\n-    {\n-      /* B4 format, with r == 1.  */\n-      data->type = copy_state;\n-      data->record.b.label = read_uleb128 (&ptr);\n-      return ptr;\n-    }\n-  abort ();\n-}\n-\n-/* This array is used to set the TYPE field for format P3.  */\n-static unw_record_type const P3_record_types[] = {\n-  psp_gr, rp_gr, pfs_gr, preds_gr, unat_gr, lc_gr, rp_br, rnat_gr,\n-  bsp_gr, bspstore_gr, fpsr_gr, priunat_gr\n-};\n-\n-/* This array is used to set the TYPE field for format P7.  */\n-static unw_record_type const P7_record_types[] = {\n-  mem_stack_f, mem_stack_v, spill_base, psp_sprel, rp_when, rp_psprel,\n-  pfs_when, pfs_psprel, preds_when, preds_psprel, lc_when, lc_psprel,\n-  unat_when, unat_psprel, fpsr_when, fpsr_psprel\n-};\n-\n-/* These values and the array are used to determine which additional ULEB128\n-   fields are required for the P7 format.  */\n-#define P7_T_SIZE\t0\n-#define P7_T\t\t1\n-#define P7_PSPOFF       2\n-#define P7_SPOFF\t3\n-static unsigned char const P7_additional_fields [] = {\n-   P7_T_SIZE, P7_T, P7_PSPOFF, P7_SPOFF, P7_T, P7_PSPOFF, \n-   P7_T, P7_PSPOFF, P7_T, P7_PSPOFF, P7_T, P7_PSPOFF, P7_T, P7_PSPOFF\n-};\n-\n-/* This array is used to set the TYPE field for format P8. \n-   Note that entry 0 is not used in this array, so it is filled with\n-   rp_spel for completely arbitrary reasons.  */\n-static unw_record_type const P8_record_types[] = {\n-  rp_sprel, rp_sprel, pfs_sprel, preds_sprel, lc_sprel, unat_sprel, fpsr_sprel, \n-  bsp_when, bsp_psprel, bsp_sprel, bspstore_when, bspstore_psprel,\n-  bspstore_sprel, rnat_when, rnat_psprel, rnat_sprel, priunat_when_gr,\n-  priunat_psprel, priunat_sprel, priunat_when_mem\n-};\n-\n-/* These values and the array are used to determine which additional ULEB128\n-   fields are required for the P8 format.  */\n-#define P8_T\t\t0\n-#define P8_PSPOFF       1\n-#define P8_SPOFF\t2\n-static unsigned char const P8_additional_fields [] = {\n-  P8_SPOFF, P8_SPOFF, P8_SPOFF, P8_SPOFF, P8_SPOFF, P8_SPOFF,\n-  P8_T, P8_PSPOFF, P8_SPOFF, P8_T, P8_PSPOFF, P8_SPOFF,\n-  P8_T, P8_PSPOFF, P8_SPOFF, P8_T, P8_PSPOFF, P8_SPOFF, P8_T\n-};\n-\n-\n-static unsigned char *\n-read_P_record (unwind_record *data, unsigned char val, unsigned char *ptr,\n-\t       unwind_record *header)\n-{\n-  if ((val & 0xe0) == 0x80)\n-    {\n-      /* P1 format.  */\n-      data->type = br_mem;\n-      data->record.p.brmask = (val & 0x1f);\n-      return ptr;\n-    }\n-\n-  if ((val & 0xf0) == 0xa0)\n-    {\n-      /* P2 format.  */\n-      int byte1;\n-      data->type = br_gr;\n-      byte1 = *ptr++;\n-      data->record.p.brmask = ((val & 0x0f) << 1) + (byte1 >> 7);\n-      data->record.p.gr = GR_REG (byte1 & 0x7f);\n-      return ptr;\n-    }\n-\n-  if ((val & 0xf8) == 0xB0)\n-    {\n-      /* P3 format.  */\n-      int byte1 = *ptr++;\n-      int r = ((val & 0x07) << 1) + (byte1 >> 7);\n-      data->type = P3_record_types[r];\n-      if (r == 6)\n-        data->record.p.br = BR_REG (byte1 & 0x7f);\n-      else\n-        data->record.p.gr = GR_REG (byte1 & 0x7f);\n-      if (r > 11)\n-        abort ();\n-      return ptr;\n-    }\n-\n-  if (val == UNW_P4)\n-    {\n-      /* P4 format.  */\n-      int size = (header->record.r.rlen * 2 + 7) / 8;\n-\n-      data->type = spill_mask;\n-      data->record.p.imask = ptr;\n-      return ptr+size;\n-    }\n-\n-  if (val == UNW_P5)\n-    {\n-      /* P5 format.  */\n-      int byte1 = *ptr++;\n-      int byte2 = *ptr++;\n-      int byte3 = *ptr++;\n-      data->type = frgr_mem;\n-      data->record.p.grmask = (byte1 >> 4);\n-      data->record.p.frmask = ((byte1 & 0x0f) << 16) | (byte2 << 8) | byte3;\n-      return ptr;\n-    }\n-  \n-  if ((val & 0xe0) == UNW_P6)\n-    {\n-      /* P6 format.  */\n-      if ((val & 0x10) == 0)\n-        data->type = fr_mem;\n-      else\n-        data->type = gr_mem;\n-      data->record.p.rmask = (val & 0x0f);\n-      return ptr;\n-    }\n-  \n-  if ((val & 0xf0) == UNW_P7)\n-    {\n-      /* P7 format.  */\n-      int r = (val & 0x0f);\n-      data->type = P7_record_types[r];\n-      switch (P7_additional_fields[r])\n-        {\n-\t  case P7_T_SIZE:\n-\t    data->record.p.t = read_uleb128 (&ptr);\n-\t    data->record.p.size = read_uleb128 (&ptr) << 4;\n-\t    break;\n-\t  case P7_T:\n-\t    data->record.p.t = read_uleb128 (&ptr);\n-\t    break;\n-\t  case P7_PSPOFF:\n-\t    data->record.p.pspoff = read_uleb128 (&ptr);\n-\t    break;\n-\t  case P7_SPOFF:\n-\t    data->record.p.spoff = read_uleb128 (&ptr);\n-\t    break;\n-\t}\n-      return ptr;\n-    }\n- \n-  if (val == UNW_P8)\n-    {\n-      /* P8 format.  */\n-      int r = *ptr++;\n-      data->type = P8_record_types[r];\n-      switch (P8_additional_fields[r])\n-        {\n-\t  case P8_T:\n-\t    data->record.p.t = read_uleb128 (&ptr);\n-\t    break;\n-\t  case P8_PSPOFF:\n-\t    data->record.p.pspoff = read_uleb128 (&ptr);\n-\t    break;\n-\t  case P8_SPOFF:\n-\t    data->record.p.spoff = read_uleb128 (&ptr);\n-\t    break;\n-\t}\n-      return ptr;\n-    }\n-  \n-  if (val == UNW_P9)\n-    {\n-      /* P9 format.  */\n-      int byte1 = *ptr++;\n-      int byte2 = *ptr++;\n-      data->type = gr_gr;\n-      data->record.p.grmask = (byte1 & 0x0f);\n-      data->record.p.gr = GR_REG (byte2 & 0x7f);\n-      return ptr;\n-    }\n-  \n-  if (val == UNW_P10)\n-    {\n-#if 0\n-      /* P10 format.  */\n-      int abi = ptr[0];\n-      int context = ptr[1];\n-      /* TODO. something about abi entries.  */\n-#endif\n-      return ptr + 2;\n-    }\n-\n-  return ptr;\n-}\n-\n-/* This routine will determine what type of record the memory pointer\n-   is refering to, and fill in the appropriate fields for that record type. \n-   HEADER is a pointer to the last region header unwind record.\n-   DATA is a pointer to an unwind record which will be filled in.\n-   PTR is a pointer to the current location in the unwind table where we\n-   will read the next record from.  \n-   The return value is the start of the next record.  */\n-\n-static unsigned char *\n-get_unwind_record (unwind_record *header, unwind_record *data,\n-\t\t   unsigned char *ptr)\n-{\n-  unsigned char val = *ptr++;\n-\n-  if ((val & 0x80) == 0)\n-    return read_R_record (data, val, ptr);\n-\n-  if (val == UNW_X1 || val == UNW_X2 || val == UNW_X3 || val == UNW_X4)\n-    return read_X_record (data, val, ptr);\n-\n-  if (header->type != body)\n-    return read_P_record (data, val, ptr, header);\n-  else\n-    return read_B_record (data, val, ptr);\n-}\n-\f\n-/* Frame processing routines.  */\n-\n-/* Initialize a single register structure.  */\n-static inline void \n-init_ia64_reg_loc (ia64_reg_loc *reg, short size)\n-{\n-  reg->when = -1;\n-  reg->loc_type = IA64_UNW_LOC_TYPE_NONE;\n-  reg->l.mem = (void *)0;\n-  reg->reg_size = size;\n-}\n-\n-/* Iniitialize an entire frame to the default of nothing.  */\n-static void\n-init_ia64_unwind_frame (ia64_frame_state *frame) \n-{\n-  int x;\n-  \n-  for (x = 0; x < 4; x++)\n-    init_ia64_reg_loc (&frame->gr[x], 8);\n-  for (x = 0; x < 20; x++)\n-    init_ia64_reg_loc (&frame->fr[x], 16);\n-  for (x = 0; x < 5; x++)\n-    init_ia64_reg_loc (&frame->br[x], 8);\n-\n-  init_ia64_reg_loc (&frame->rp, 8);\n-  init_ia64_reg_loc (&frame->fpsr, 8);\n-  init_ia64_reg_loc (&frame->bsp, 8);\n-  init_ia64_reg_loc (&frame->bspstore, 8);\n-  init_ia64_reg_loc (&frame->rnat, 8);\n-  init_ia64_reg_loc (&frame->pfs, 8);\n-  init_ia64_reg_loc (&frame->unat, 8);\n-  init_ia64_reg_loc (&frame->lc, 8);\n-  init_ia64_reg_loc (&frame->pr, 8);\n-  init_ia64_reg_loc (&frame->priunat, 8);\n-  init_ia64_reg_loc (&frame->sp, 8);\n-  init_ia64_reg_loc (&frame->psp, 8);\n-  init_ia64_reg_loc (&frame->spill_base, 8);\n-}\n-\n-/* This fuction will process a single descriptor.\n-   addr is a pointer to the descriptor record to read, \n-   frame is the current frame state structure, which will be\n-     modified to reflect this descriptor.\n-   len is the length of a prologue region, or -1 if it wasn't one.\n-   the return value is a pointer to the start of the next descriptor.  */\n-\n-static void *\n-execute_one_ia64_descriptor (void *addr, ia64_frame_state *frame, long *len)\n-{\n-  /* The last region_header.  Needed to distinguish between prologue and body\n-     descriptors.  Also needed for length of P4 format.  */\n-  static unwind_record region_header;\n-\n-  unwind_record r;\n-  ia64_reg_loc *loc_ptr = NULL;\n-  int grmask = 0, frmask = 0;\n-\n-  *len = -1;\n-  addr = get_unwind_record (&region_header, &r, addr);\n-\n-  /* Process it in 2 phases, the first phase will either do the work,\n-     or set up a pointer to the records we care about \n-     (ie a special purpose ar perhaps, and the second will actually \n-     fill in the record.  */\n-  switch (r.type) \n-    {\n-      case prologue:\n-      case body:\n-\t*len = r.record.r.rlen;\n-\tregion_header = r;\n-\tbreak;\n-      case prologue_gr:\n-        {\n-\t  int val, reg;\n-\n-\t  *len = r.record.r.rlen;\n-\t  val = r.record.r.mask;\n-\t  reg = r.record.r.grsave;\n-\t  if (val & 0x08)\n-\t    {\n-\t      frame->rp.when = 0;\n-\t      frame->rp.loc_type  = IA64_UNW_LOC_TYPE_GR;\n-\t      frame->rp.l.regno = reg++;\n-\t    }\n-\t  if (val & 0x04)\n-\t    {\n-\t      frame->pfs.when = 0;\n-\t      frame->pfs.loc_type  = IA64_UNW_LOC_TYPE_GR;\n-\t      frame->pfs.l.regno = reg++;\n-\t    }\n-\t  if (val & 0x02)\n-\t    {\n-\t      frame->psp.when = 0;\n-\t      frame->psp.loc_type  = IA64_UNW_LOC_TYPE_GR;\n-\t      frame->psp.l.regno = reg++;\n-\t    }\n-\t  if (val & 0x01)\n-\t    {\n-\t      frame->pr.when = 0;\n-\t      frame->pr.loc_type  = IA64_UNW_LOC_TYPE_GR;\n-\t      frame->pr.l.regno = reg++;\n-\t    }\n-\t  region_header = r;\n-\t  break;\n-\t}\n-      case mem_stack_f:\n-\tframe->sp.l.offset = r.record.p.size;\n-\tframe->sp.loc_type = IA64_UNW_LOC_TYPE_OFFSET;\n-        frame->sp.when = r.record.p.t; \n-\tbreak;\n-      case mem_stack_v:\n-\tframe->psp.when = r.record.p.t;\n-\tbreak;\n-      case psp_gr:\n-      case psp_sprel:\n-        loc_ptr = &frame->psp;\n-\tbreak;\n-      case rp_br:\n-      case rp_gr:\n-      case rp_when:\n-      case rp_psprel:\n-      case rp_sprel:\n-        loc_ptr = &frame->rp;\n-\tbreak;\n-      case pfs_gr:\n-      case pfs_when:\n-      case pfs_psprel:\n-      case pfs_sprel:\n-        loc_ptr = &frame->pfs;\n-\tbreak;\n-      case preds_gr:\n-      case preds_when:\n-      case preds_psprel:\n-      case preds_sprel:\n-        loc_ptr = &frame->pr;\n-\tbreak;\n-      case unat_gr:\n-      case unat_when:\n-      case unat_psprel:\n-      case unat_sprel:\n-        loc_ptr = &frame->unat;\n-\tbreak;\n-      case lc_gr:\n-      case lc_when:\n-      case lc_psprel:\n-      case lc_sprel:\n-        loc_ptr = &frame->lc;\n-\tbreak;\n-      case fpsr_gr:\n-      case fpsr_when:\n-      case fpsr_psprel:\n-      case fpsr_sprel:\n-        loc_ptr = &frame->fpsr;\n-\tbreak;\n-      case priunat_gr:\n-      case priunat_sprel:\n-      case priunat_when_gr:\n-      case priunat_when_mem:\n-      case priunat_psprel:\n-        loc_ptr = &frame->priunat;\n-\tbreak;\n-      case bsp_gr:\n-      case bsp_sprel:\n-      case bsp_when:\n-      case bsp_psprel:\n-        loc_ptr = &frame->bsp;\n-\tbreak;\n-      case bspstore_gr:\n-      case bspstore_sprel:\n-      case bspstore_when:\n-      case bspstore_psprel:\n-        loc_ptr = &frame->bspstore;\n-\tbreak;\n-      case rnat_gr:\n-      case rnat_sprel:\n-      case rnat_when:\n-      case rnat_psprel:\n-        loc_ptr = &frame->rnat;\n-\tbreak;\n-      case spill_base:\n-        loc_ptr = &frame->spill_base;\n-\tbreak;\n-      case fr_mem:\n-        frmask = r.record.p.rmask;\n-\tbreak;\n-      case gr_mem:\n-        grmask = r.record.p.rmask;\n-\tbreak;\n-      case frgr_mem:\n-        frmask = r.record.p.frmask;\n-        grmask = r.record.p.grmask;\n-\tbreak;\n-      case br_mem:\n-        {\n-\t  int x, mask = 0x01;\n-\t  int saved = r.record.p.brmask;\n-\t  for (x = 0; x < 5; x++)\n-\t    {\n-\t      if (saved & mask)\n-\t\tframe->br[x].loc_type = IA64_UNW_LOC_TYPE_SPILLBASE;\n-\t      mask = mask << 1;\n-\t    }\n-\t  break;\n-\t}\n-      case br_gr:\n-        {\n-\t  int x, mask = 0x01;\n-\t  int reg = r.record.p.gr;\n-\t  int saved = r.record.p.brmask;\n-\t  for (x = 0; x < 5; x++)\n-\t    {\n-\t      if (saved & mask)\n-\t        {\n-\t\t  frame->br[x].loc_type = IA64_UNW_LOC_TYPE_GR;\n-\t\t  frame->br[x].l.regno = reg++;\n-\t\t}\n-\t      mask = mask << 1;\n-\t    }\n-\t  break;\n-\t}\n-      case gr_gr:\n-        {\n-\t  int x, mask = 0x01;\n-\t  int reg = r.record.p.gr;\n-\t  int saved = r.record.p.grmask;\n-\t  for (x = 0; x < 4; x++)\n-\t    {\n-\t      if (saved & mask)\n-\t        {\n-\t\t  frame->br[x].loc_type = IA64_UNW_LOC_TYPE_GR;\n-\t\t  frame->br[x].l.regno = reg++;\n-\t\t}\n-\t      mask = mask << 1;\n-\t    }\n-\t  break;\n-\t}\n-      case spill_mask:\n-        /* TODO.  */\n-\tbreak;\n-      case epilogue:\n-        /* TODO.  */\n-\tbreak;\n-      case label_state:\n-        /* TODO.  */\n-\tbreak;\n-      case copy_state: \n-        /* TODO. */\n-\tbreak;\n-      case spill_psprel:\n-      case spill_sprel:\n-      case spill_reg:\n-      case spill_psprel_p:\n-      case spill_sprel_p:\n-      case spill_reg_p:\n-        /* TODO. */\n-\tbreak;\n-      default:\n-\tabort ();\n-\tbreak;\n-    }\n-\n-  if (frmask)\n-    {\n-      int x, mask = 0x01;\n-      for (x = 0; x < 20; x++)\n-\t{\n-\t  if (frmask & mask)\n-\t    frame->fr[x].loc_type = IA64_UNW_LOC_TYPE_SPILLBASE;\n-\t  mask = mask << 1;\n-\t}\n-    }\n-\n-  if (grmask)\n-    {\n-      int x, mask = 0x01;\n-      for (x = 0; x < 4; x++)\n-\t{\n-\t  if (grmask & mask)\n-\t    frame->gr[x].loc_type = IA64_UNW_LOC_TYPE_SPILLBASE;\n-\t  mask = mask << 1;\n-\t}\n-    }\n-\n-  /* If there is more to do:  */\n-  if (loc_ptr != NULL)\n-    switch (r.type) \n-      {\n-\tcase psp_gr:\n-\tcase rp_gr:\n-\tcase pfs_gr:\n-\tcase preds_gr:\n-\tcase unat_gr:\n-\tcase lc_gr:\n-\tcase fpsr_gr:\n-\tcase priunat_gr:\n-\tcase bsp_gr:\n-\tcase bspstore_gr:\n-\tcase rnat_gr:\n-\t  loc_ptr->loc_type = IA64_UNW_LOC_TYPE_GR;\n-\t  loc_ptr->l.regno = r.record.p.gr;\n-\t  break;\n-\tcase rp_br:\n-\t  loc_ptr->loc_type = IA64_UNW_LOC_TYPE_BR;\n-\t  loc_ptr->l.regno = r.record.p.br;\n-\t  break;\n-\tcase rp_when:\n-\tcase pfs_when:\n-\tcase preds_when:\n-\tcase unat_when:\n-\tcase lc_when:\n-\tcase fpsr_when:\n-\tcase priunat_when_gr:\n-\tcase priunat_when_mem:\n-\tcase bsp_when:\n-\tcase bspstore_when:\n-\tcase rnat_when:\n-\t  loc_ptr->when = r.record.p.t;\n-\t  break;\n-\tcase rp_psprel:\n-\tcase pfs_psprel:\n-\tcase preds_psprel:\n-\tcase unat_psprel:\n-\tcase lc_psprel:\n-\tcase fpsr_psprel:\n-\tcase priunat_psprel:\n-\tcase bsp_psprel:\n-\tcase bspstore_psprel:\n-\tcase rnat_psprel:\n-\tcase spill_base:\n-\t  loc_ptr->loc_type = IA64_UNW_LOC_TYPE_PSPOFF;\n-\t  loc_ptr->l.offset = r.record.p.pspoff;\n-\t  break;\n-\tcase psp_sprel:\n-\tcase rp_sprel:\n-\tcase pfs_sprel:\n-\tcase preds_sprel:\n-\tcase unat_sprel:\n-\tcase lc_sprel:\n-\tcase fpsr_sprel:\n-\tcase priunat_sprel:\n-\tcase bsp_sprel:\n-\tcase bspstore_sprel:\n-\tcase rnat_sprel:\n-\t  loc_ptr->loc_type = IA64_UNW_LOC_TYPE_SPOFF;\n-\t  loc_ptr->l.offset = r.record.p.spoff;\n-\t  break;\n-\tdefault:\n-\t  abort ();\n-\t  break;\n-      }\n-  return addr;\n-}\n-\n-\n-#define IS_NaT_COLLECTION_ADDR(addr) ((((long)(addr) >> 3) & 0x3f) == 0x3f)\n-\n-/* Returns the address of the slot that's NSLOTS slots away from\n-   the address ADDR. NSLOTS may be positive or negative. */\n-static void *\n-rse_address_add(unsigned char *addr, int nslots)\n-{\n-  unsigned char *new_addr;\n-  int mandatory_nat_slots = nslots / 63;\n-  int direction = nslots < 0 ? -1 : 1;\n-\n-  new_addr = addr + 8 * (nslots + mandatory_nat_slots);\n-\n-  if (((long)new_addr >> 9)\n-      != ((long)(addr + 8 * 64 * mandatory_nat_slots) >> 9))\n-    new_addr += 8 * direction;\n-\n-  if (IS_NaT_COLLECTION_ADDR(new_addr))\n-    new_addr += 8 * direction;\n-\n-  return new_addr;\n-}\n-\n-\n-/* Normalize a record to originate in either a register or memory \n-   location.  */\n-static void\n-normalize_reg_loc (ia64_frame_state *frame, ia64_reg_loc *reg)\n-{\n-  unsigned char *tmp;\n-  switch (reg->loc_type)\n-    {\n-      case IA64_UNW_LOC_TYPE_MEM:\n-        /* Already done.  */\n-        break;\n-      case IA64_UNW_LOC_TYPE_GR:\n-        /* If the register its saved in is a LOCAL register, we know\n-\t   its actually in memory, so we'll pick it up from there.  */\n-        if (reg->l.regno >= 32 && frame->my_bsp != 0)\n-\t  {\n-\t   /* Get from backing store.  */\n-\t    tmp = rse_address_add(frame->my_bsp, reg->l.regno - 32);\n-\t    reg->l.mem = tmp;\n-\t    reg->loc_type = IA64_UNW_LOC_TYPE_MEM;\n-\t  }\n-        break;\n-      case IA64_UNW_LOC_TYPE_FR:\n-        /* If the register its saved in is a LOCAL register, we know\n-\t   its actually in memory, so we'll pick it up from there.  */\n-        if (reg->l.regno >= 32)\n-\t  {\n-\t   /* TODO. get from backing store.  */\n-\t  }\n-        break;\n-      case IA64_UNW_LOC_TYPE_BR:\n-        break;\n-      case IA64_UNW_LOC_TYPE_SPOFF:\n-        /* Offset from the stack pointer, calculate the memory address\n-\t   now.  */\n-\ttmp = (unsigned char *)frame->my_sp + reg->l.offset * 4;\n-\treg->l.mem = tmp;\n-\treg->loc_type = IA64_UNW_LOC_TYPE_MEM;\n-        break;\n-      case IA64_UNW_LOC_TYPE_PSPOFF:\n-        /* Actualy go get the value of the PSP add the offset, and thats \n-\t   the mem location we can find this value at. */\n-\ttmp = (unsigned char *)frame->my_psp + 16 - reg->l.offset * 4;\n-\treg->l.mem = tmp;\n-\treg->loc_type = IA64_UNW_LOC_TYPE_MEM;\n-        break;\n-      case IA64_UNW_LOC_TYPE_SPILLBASE:\n-        /* located at the current spill base memory location, and we\n-\t   have to bump it as well. */\n-\treg->l.mem = frame->spill_base.l.mem;\n-\treg->loc_type = IA64_UNW_LOC_TYPE_MEM;\n-\tframe->spill_base.l.mem += 8;\n-        break;\n-    }\n-\n-}\n-\n-/* This function looks at a reg_loc and determines if its going\n-   to be an executed record or not between time start and end.  \n-   It is executed if it is exectued at START time. It is NOT\n-   executed if it happens at END time. */\n-static void \n-maybe_normalize_reg_loc (ia64_frame_state *frame, ia64_reg_loc *reg,\n-\t\t\t long start, long end)\n-{\n-  if (reg->loc_type != IA64_UNW_LOC_TYPE_NONE \n-      && reg->when >= start && reg->when < end)\n-    normalize_reg_loc (frame, reg);\n-}\n-\n-\n-/* Only works for 8 byte or less registers.  */\n-void *\n-__get_real_reg_value (ia64_reg_loc *reg)\n-{\n-  if (reg->loc_type == IA64_UNW_LOC_TYPE_MEM)\n-    return *((void **)(reg->l.mem));\n-  \n-  /* All registers should be in memory if we've saved them. Local \n-     registers will be in backing store.  */\n-  abort ();\n-}\n-\n-void\n-__set_real_reg_value (ia64_reg_loc *reg, void *val) \n-{\n-  if (reg->loc_type == IA64_UNW_LOC_TYPE_MEM)\n-    {\n-      void **ptr = reg->l.mem;\n-      *ptr = val;\n-      return;\n-    }\n-  abort ();\n-}\n-\n-static void\n-copy_reg_value (ia64_reg_loc *src, ia64_reg_loc *dest)\n-{\n-  void **p = dest->l.mem;\n-  if (src->loc_type == IA64_UNW_LOC_TYPE_NONE)\n-    return;\n-  \n-  if (src->reg_size != dest->reg_size)\n-    abort ();\n-  if (src->reg_size <= 8)\n-    *p = __get_real_reg_value (src);\n-  else\n-    {\n-      void **d;\n-      if (src->reg_size > 16)\n-        abort ();\n-      if (dest->loc_type != IA64_UNW_LOC_TYPE_MEM)\n-        abort ();\n-      d = (void **)(dest->l.mem);\n-      *p++ = *d++;\n-      *p = *d;\n-    }\n-  return;\n-}\n-\n-/* Copy the values of any relevant saved registers in one frame \n-   to another for unwinding.  */\n-void \n-__copy_saved_reg_state (ia64_frame_state *dest, ia64_frame_state *src)\n-{\n-  int x;\n-  for (x = 0; x < 4 ; x++)\n-    copy_reg_value (&src->gr[x], &dest->gr[x]);\n-  for (x = 0; x < 20 ; x++)\n-    copy_reg_value (&src->fr[x], &dest->fr[x]);\n-  for (x = 0; x < 5 ; x++)\n-    copy_reg_value (&src->br[x], &dest->br[x]);\n-      \n-  copy_reg_value (&src->fpsr, &dest->fpsr);\n-  copy_reg_value (&src->rnat, &dest->rnat);\n-  copy_reg_value (&src->unat, &dest->unat);\n-  copy_reg_value (&src->lc, &dest->lc);\n-  copy_reg_value (&src->pr, &dest->pr);\n-  copy_reg_value (&src->priunat, &dest->priunat);\n-  copy_reg_value (&src->pfs, &dest->pfs);\n-}\n-\n-\n-static void \n-process_state_between (ia64_frame_state *frame, long start, long end)\n-{\n-  int x;\n-  /* PSP, RP, SP, and PFS are handled seperately from here. */\n-\n-  /* GR's, FR's and BR's are saved at an arbitrary point, so we\n-     should handle them at the very beginning.  */\n-  /* ??? Err, no they aren't.  There's the spill_mask record that\n-     tells us when each is processed.  */\n-  if (start == 0)\n-    {\n-      for (x = 0; x < 4 ; x++)\n-\tnormalize_reg_loc (frame, &frame->gr[x]);\n-      for (x = 0; x < 20 ; x++)\n-\tnormalize_reg_loc (frame, &frame->fr[x]);\n-      for (x = 0; x < 5 ; x++)\n-\tnormalize_reg_loc (frame, &frame->br[x]);\n-    }\n-  \n-  maybe_normalize_reg_loc (frame, &frame->fpsr, start, end);\n-  maybe_normalize_reg_loc (frame, &frame->bsp, start, end);\n-  maybe_normalize_reg_loc (frame, &frame->bspstore, start, end);\n-  maybe_normalize_reg_loc (frame, &frame->rnat, start, end);\n-  maybe_normalize_reg_loc (frame, &frame->unat, start, end);\n-  maybe_normalize_reg_loc (frame, &frame->lc, start, end);\n-  maybe_normalize_reg_loc (frame, &frame->pr, start, end);\n-  maybe_normalize_reg_loc (frame, &frame->priunat, start, end);\n-}\n-\n-/* This function will take a frame state, and translate all the location\n-   records into actual memory address, or register numbers, based on\n-   what the ia64_reg_loc fields require to actually go get the values.  \n-   (ie, this translates SPOFF and PSPOFF, etc into MEM types. \n-   frame is the frame to be changed.\n-   unwind_time is the insn slot number we are unwinding to.  Anything \n-     that has a WHEN record beyond this time is cleared since it\n-     isn't relevant.  */\n-static void\n-frame_translate (ia64_frame_state *frame, long unwind_time)\n-{\n-  /* ??? Is this supposed to mark the end of the stack?  */\n-  if (frame->rp.loc_type == IA64_UNW_LOC_TYPE_NONE)\n-    return;\n-\n-  /* At function entry, SP == PSP.  */\n-  frame->my_psp = frame->my_sp;\n-  if (frame->psp.loc_type != IA64_UNW_LOC_TYPE_NONE)\n-    {\n-      /* We've saved a frame pointer somewhere.  This will be the\n-\t canonical PSP for the function.  */\n-      normalize_reg_loc (frame, &frame->psp);\n-      if (frame->psp.when < unwind_time)\n-\tframe->my_psp = __get_real_reg_value (&frame->psp);\n-    }\n-  else if (frame->sp.loc_type == IA64_UNW_LOC_TYPE_OFFSET)\n-    {\n-      /* We've a fixed sized stack frame.  The PSP is at a known offset.  */\n-\t\n-      if (frame->sp.when < unwind_time)\n-        frame->my_psp = frame->my_sp + frame->sp.l.offset;\n-    }\n-  /* Otherwise the stack frame size was zero and no adjustment needed.  */\n-\n-  /* Find PFS, RP and the spill base.  All of which might have\n-     addresses based off the PSP computed above.  */\n-  normalize_reg_loc (frame, &frame->pfs);\n-  normalize_reg_loc (frame, &frame->rp);\n-\n-  if (frame->spill_base.loc_type != IA64_UNW_LOC_TYPE_NONE)\n-    normalize_reg_loc (frame, &frame->spill_base);\n-  else\n-    {\n-      /* Otherwise we're supposed to infer it from the size of the\n-\t saved GR/BR/FR registers, putting the top at psp+16.  */\n-      long size = 0, i;\n-      for (i = 0; i < 4; ++i)\n-\tif (frame->gr[i].when >= 0)\n-\t  size += 8;\n-      for (i = 0; i < 5; ++i)\n-\tif (frame->br[i].when >= 0)\n-\t  size += 8;\n-      for (i = 0; i < 20; ++i)\n-\tif (frame->fr[i].when >= 0)\n-\t  size += 16;\n-      frame->spill_base.l.mem = frame->my_psp + 16 - size;\n-    }\n-\n-  /* If the SP is adjusted, process records up to where it\n-     is adjusted, then adjust it, then process the rest.  */\n-  if (frame->sp.when >= 0)\n-    {\n-      process_state_between (frame, 0, frame->sp.when);\n-      if (frame->sp.loc_type != IA64_UNW_LOC_TYPE_OFFSET)\n-\tabort ();\n-      frame->my_sp = frame->my_psp - frame->sp.l.offset;\n-      process_state_between (frame, frame->sp.when, unwind_time);\n-    }\n-  else\n-    process_state_between (frame, 0, unwind_time);\n-}\n-\n-/* This function will set a frame_state with all the required fields\n-   from a functions unwind descriptors.\n-   pc is the location we need info up until (ie, the unwind point)\n-   frame is the frame_state structure to be set up.\n-   Returns a pointer to the unwind info pointer for the frame.  */\n-unwind_info_ptr *\n-__build_ia64_frame_state (unsigned char *pc, ia64_frame_state *frame,\n-\t\t\t  void *bsp, void *sp, void **pc_base_ptr)\n-{\n-  long len;\n-  int region_offset = 0;\n-  int last_region_size = 0;\n-  void *addr, *end;\n-  unwind_table_entry *entry;\n-  unsigned char *start_pc;\n-  void *pc_base;\n-  int pc_offset;\n-  struct unwind_info_ptr *unw_info_ptr;\n-\n-  entry = __ia64_find_fde (pc, &pc_base);\n-  if (!entry)\n-    return 0;\n-\n-  start_pc = pc_base + entry->start_offset;\n-  unw_info_ptr = ((struct unwind_info_ptr *)(pc_base + entry->unwind_offset));\n-  addr = unw_info_ptr->unwind_descriptors;\n-  end = addr + IA64_UNW_HDR_LENGTH (unw_info_ptr->header) * 8;\n-  pc_offset = (pc - start_pc) / 16 * 3;\n-\n-  init_ia64_unwind_frame (frame);\n-  frame->my_bsp = bsp;\n-  frame->my_sp = sp;\n-\n-  /* Stop when we get to the end of the descriptor list, or if we\n-     encounter a region whose initial offset is already past the\n-     PC we are unwinding too.  */\n-\n-  while (addr < end && pc_offset > region_offset)\n-    {\n-      /* First one must be a record header.  */\n-      addr = execute_one_ia64_descriptor (addr, frame, &len);\n-      if (len > 0)\n-        {\n-\t  region_offset += last_region_size;\n-\t  last_region_size = len;\n-\t}\n-    }\n-\n-  /* Now we go get the actual values.  */\n-  frame_translate (frame, pc_offset);\n-  if (pc_base_ptr)\n-    *pc_base_ptr = pc_base;\n-  return unw_info_ptr;\n-}\n-\n-/* Given an unwind info pointer, return the personality routine.  */\n-void *\n-__get_personality (unwind_info_ptr *ptr)\n-{\n-  void **p;\n-\n-  /* There is a personality routine only if one of the EHANDLER or UHANDLER\n-     bits is set.  */\n-  if (! (IA64_UNW_HDR_FLAGS (ptr->header)\n-\t & (IA64_UNW_EHANDLER|IA64_UNW_UHANDLER)))\n-    return 0;\n-\n-  p = (void **) (ptr->unwind_descriptors\n-\t\t + IA64_UNW_HDR_LENGTH (ptr->header) * 8);\n-  return *p;\n-}\n-\n-/* Given an unwind info pointer, return the exception table.  */\n-void *\n-__get_except_table (unwind_info_ptr *ptr)\n-{\n-  void *table;\n-\n-  /* If there is no personality, there is no handler data.\n-     There is a personality routine only if one of the EHANDLER or UHANDLER\n-     bits is set.  */\n-  if (! (IA64_UNW_HDR_FLAGS (ptr->header)\n-\t & (IA64_UNW_EHANDLER|IA64_UNW_UHANDLER)))\n-    return 0;\n-\n-  table = (void *) (ptr->unwind_descriptors\n-\t\t    + IA64_UNW_HDR_LENGTH (ptr->header) * 8 + 8);\n-  return table;\n-}\n-\n-/* Given a PFS value, and the current BSp, calculate the BSp of the caller.  */\n-void *\n-__calc_caller_bsp (long pfs, unsigned char *bsp)\n-{\n-  int size_of_locals;\n-\n-  /* The PFS looks like :  xxxx SOL:7 SOF:7. The SOF is bits 0-7 and SOL \n-     is bits 8-15. We only care about SOL.  */\n-\n-  size_of_locals = (pfs >> 7) & 0x7f;\n-  return rse_address_add (bsp, -size_of_locals);\n-}\n-\n-static int \n-ia64_backtrace_helper (void **array, ia64_frame_state *throw_frame,\n-\t\t       ia64_frame_state *frame, void *bsp, void *sp, int size)\n-{\n-  void *throw_pc = __builtin_return_address (0);\n-  void *pc = NULL;\n-  int frame_count = 0;\n-  unwind_info_ptr *info;\n-\n-  __builtin_ia64_flushrs ();      /*  Make the local register stacks available.  */\n-\n-  /* Start at our stack frame, get our state.  */\n-  info = __build_ia64_frame_state (throw_pc, throw_frame, bsp, sp, NULL);\n-\n-  *frame = *throw_frame;\n-\n-  while (info && frame_count < size)\n-    {\n-      pc = array[frame_count++] = __get_real_reg_value (&frame->rp);\n-      --pc;\n-      bsp = __calc_caller_bsp \n-\t((long)__get_real_reg_value (&frame->pfs), frame->my_bsp);\n-      info = __build_ia64_frame_state (pc, frame, bsp, frame->my_psp, NULL);\n-      if (frame->rp.loc_type == IA64_UNW_LOC_TYPE_NONE) /* We've finished. */\n-\tbreak;\n-    }\n-\n-  return frame_count;\n-}\n-\n-/* This is equivalent to glibc's backtrace(). */\n-\n-extern int __ia64_backtrace (void **array, int size);\n-  \n-int\n-__ia64_backtrace (void **array, int size)\n-{\n-  register void *stack_pointer __asm__(\"r12\");\n-  ia64_frame_state my_frame;\n-  ia64_frame_state originator;\t/* For the context handler is in.  */\n-  void *bsp;\n- \n-  /* Do any necessary initialization to access arbitrary stack frames.\n-     This forces gcc to save memory in our stack frame for saved\n-     registers. */\n-  __builtin_unwind_init ();\n-\n-  bsp = __builtin_ia64_bsp ();\n-  \n-  return ia64_backtrace_helper (array, &my_frame, &originator, bsp,\n-\t\t\t\tstack_pointer, size);\n-}"}, {"sha": "62cc4fb239c309634a53545d9619be76e008dead", "filename": "gcc/config/ia64/ia64.h", "status": "modified", "additions": 29, "deletions": 56, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a1ee410cefc93b247bbcc9b8a153ba5af72be73/gcc%2Fconfig%2Fia64%2Fia64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a1ee410cefc93b247bbcc9b8a153ba5af72be73/gcc%2Fconfig%2Fia64%2Fia64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.h?ref=2a1ee410cefc93b247bbcc9b8a153ba5af72be73", "patch": "@@ -2149,19 +2149,6 @@ do {\t\t\t\t\t\t\t\t\t\\\n } while (0)\n \n \n-/* Output EH data to the unwind segment. */\n-#define ASM_OUTPUT_EH_CHAR(FILE, VALUE)\t\t\t\t\t\\\n-\t\tASM_OUTPUT_XDATA_CHAR(FILE, \".IA_64.unwind_info\", VALUE)\n-\n-#define ASM_OUTPUT_EH_SHORT(FILE, VALUE)\t\t\t\t\\\n-\t\tASM_OUTPUT_XDATA_SHORT(FILE, \".IA_64.unwind_info\", VALUE)\n-\n-#define ASM_OUTPUT_EH_INT(FILE, VALUE)\t\t\t\t\t\\\n-\t\tASM_OUTPUT_XDATA_INT(FILE, \".IA_64.unwind_info\", VALUE)\n-\n-#define ASM_OUTPUT_EH_DOUBLE_INT(FILE, VALUE)\t\t\t\t\\\n-\t\tASM_OUTPUT_XDATA_DOUBLE_INT(FILE, \".IA_64.unwind_info\", VALUE)\n-\n /* A C statement to output to the stdio stream STREAM an assembler instruction\n    to assemble a single byte containing the number VALUE.  */\n \n@@ -2473,26 +2460,6 @@ do {\t\t\t\t\t\t\t\t\t\\\n \f\n /* Assembler Commands for Exception Regions.  */\n \n-/* ??? This entire section of ia64.h needs to be implemented and then cleaned\n-   up.  */\n-\n-/* A C expression to output text to mark the start of an exception region.\n-\n-   This macro need not be defined on most platforms.  */\n-/* #define ASM_OUTPUT_EH_REGION_BEG() */\n-\n-/* A C expression to output text to mark the end of an exception region.\n-\n-   This macro need not be defined on most platforms.  */\n-/* #define ASM_OUTPUT_EH_REGION_END() */\n-\n-/* A C expression to switch to the section in which the main exception table is\n-   to be placed.  The default is a section named `.gcc_except_table' on machines\n-   that support named sections via `ASM_OUTPUT_SECTION_NAME', otherwise if `-fpic'\n-   or `-fPIC' is in effect, the `data_section', otherwise the\n-   `readonly_data_section'.  */\n-/* #define EXCEPTION_SECTION() */\n-\n /* If defined, a C string constant for the assembler operation to switch to the\n    section for exception handling frame unwind information.  If not defined,\n    GNU CC will provide a default definition if the target supports named\n@@ -2503,26 +2470,34 @@ do {\t\t\t\t\t\t\t\t\t\\\n    information and the default definition does not work.  */\n #define EH_FRAME_SECTION_ASM_OP \"\\t.section\\t.IA_64.unwind,\\\"aw\\\"\"\n \n-/* A C expression that is nonzero if the normal exception table output should\n-   be omitted.\n-\n-   This macro need not be defined on most platforms.  */\n-/* #define OMIT_EH_TABLE() */\n-\n-/* Alternate runtime support for looking up an exception at runtime and finding\n-   the associated handler, if the default method won't work.\n-\n-   This macro need not be defined on most platforms.  */\n-/* #define EH_TABLE_LOOKUP() */\n-\n-/* A C expression that decides whether or not the current function needs to\n-   have a function unwinder generated for it.  See the file `except.c' for\n-   details on when to define this, and how.  */\n-/* #define DOESNT_NEED_UNWINDER */\n+/* Select a format to encode pointers in exception handling data.  CODE\n+   is 0 for data, 1 for code labels, 2 for function pointers.  GLOBAL is\n+   true if the symbol may be affected by dynamic relocations.  */\n+#define ASM_PREFERRED_EH_DATA_FORMAT(CODE,GLOBAL)\t\\\n+  (((CODE) == 1 ? DW_EH_PE_textrel : DW_EH_PE_datarel)\t\\\n+   | ((GLOBAL) ? DW_EH_PE_indirect : 0) | DW_EH_PE_udata8)\n+\n+/* Handle special EH pointer encodings.  Absolute, pc-relative, and\n+   indirect are handled automatically.  */\n+#define ASM_MAYBE_OUTPUT_ENCODED_ADDR_RTX(FILE, ENCODING, SIZE, ADDR, DONE) \\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    const char *reltag = NULL;\t\t\t\t\t\t\\\n+    if (((ENCODING) & 0xF0) == DW_EH_PE_textrel)\t\t\t\\\n+      reltag = \"@segrel(\";\t\t\t\t\t\t\\\n+    else if (((ENCODING) & 0xF0) == DW_EH_PE_datarel)\t\t\t\\\n+      reltag = \"@gprel(\";\t\t\t\t\t\t\\\n+    if (reltag)\t\t\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\tfputs (((SIZE) == 4 ? UNALIGNED_INT_ASM_OP\t\t\t\\\n+\t        : (SIZE) == 8 ? UNALIGNED_DOUBLE_INT_ASM_OP\t\t\\\n+\t\t: (abort (), \"\")), FILE);\t\t\t\t\\\n+\tfputs (reltag, FILE);\t\t\t\t\t\t\\\n+\tassemble_name (FILE, XSTR (ADDR, 0));\t\t\t\t\\\n+\tfputc (')', FILE);\t\t\t\t\t\t\\\n+\tgoto DONE;\t\t\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+  } while (0)\n \n-/* An rtx used to mask the return address found via RETURN_ADDR_RTX, so that it\n-   does not contain any extraneous set bits in it.  */\n-/* #define MASK_RETURN_ADDR */\n \f\n /* Assembler Commands for Alignment.  */\n \n@@ -2846,13 +2821,11 @@ do {\t\t\t\t\t\t\t\t\t\\\n \n extern int ia64_final_schedule;\n \n-/* ??? Hack until frame-ia64.c is updated.\n #define IA64_UNWIND_INFO\t1\n-*/\n-\n-#define HANDLER_SECTION fprintf (asm_out_file, \"\\t.personality\\t__ia64_personality_v1\\n\\t.handlerdata\\n\");\n #define IA64_UNWIND_EMIT(f,i)\tprocess_for_unwind_directive (f,i)\n \n+#define EH_RETURN_DATA_REGNO(N) ((N) < 4 ? (N) + 15 : INVALID_REGNUM)\n+\n /* This function contains machine specific function data.  */\n struct machine_function\n {"}, {"sha": "98507779b2d83036637065359dba23b921f3e03e", "filename": "gcc/config/ia64/ia64.md", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a1ee410cefc93b247bbcc9b8a153ba5af72be73/gcc%2Fconfig%2Fia64%2Fia64.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a1ee410cefc93b247bbcc9b8a153ba5af72be73/gcc%2Fconfig%2Fia64%2Fia64.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.md?ref=2a1ee410cefc93b247bbcc9b8a153ba5af72be73", "patch": "@@ -4979,13 +4979,6 @@\n   DONE;\n }\")\n \n-;; Restore the GP after the exception/longjmp.  The preceeding call will\n-;; have tucked it away.\n-(define_expand \"exception_receiver\"\n-  [(set (reg:DI 1) (match_dup 0))]\n-  \"\"\n-  \"operands[0] = ia64_gp_save_reg (0);\")\n-\n ;; The rest of the setjmp processing happens with the nonlocal_goto expander.\n ;; ??? This is not tested.\n (define_expand \"builtin_setjmp_setup\""}, {"sha": "a1056628b501443b7310beeca41cdd7f76458fd7", "filename": "gcc/config/ia64/t-glibc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a1ee410cefc93b247bbcc9b8a153ba5af72be73/gcc%2Fconfig%2Fia64%2Ft-glibc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a1ee410cefc93b247bbcc9b8a153ba5af72be73/gcc%2Fconfig%2Fia64%2Ft-glibc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Ft-glibc?ref=2a1ee410cefc93b247bbcc9b8a153ba5af72be73", "patch": "@@ -1 +1 @@\n-# LIB2ADDEH += $(srcdir)/config/ia64/fde-glibc.c\n+LIB2ADDEH += $(srcdir)/config/ia64/fde-glibc.c"}, {"sha": "274f9a44826c137a1a47a6552a922ed454cd278d", "filename": "gcc/config/ia64/t-ia64", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a1ee410cefc93b247bbcc9b8a153ba5af72be73/gcc%2Fconfig%2Fia64%2Ft-ia64", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a1ee410cefc93b247bbcc9b8a153ba5af72be73/gcc%2Fconfig%2Fia64%2Ft-ia64", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Ft-ia64?ref=2a1ee410cefc93b247bbcc9b8a153ba5af72be73", "patch": "@@ -41,4 +41,4 @@ crtendS.o: $(srcdir)/config/ia64/crtend.asm $(GCC_PASSES)\n \t$(GCC_FOR_TARGET) -DSHARED -c -o crtendS.o -x assembler-with-cpp $(srcdir)/config/ia64/crtend.asm\n \n EXTRA_HEADERS = $(srcdir)/config/ia64/ia64intrin.h\n-# LIB2ADDEH = $(srcdir)/config/ia64/frame-ia64.c\n+LIB2ADDEH = $(srcdir)/config/ia64/unwind-ia64.c $(srcdir)/unwind-sjlj.c"}, {"sha": "15d668303e153f6b76187f9d9780c3b0bc881928", "filename": "gcc/config/ia64/unwind-ia64.c", "status": "added", "additions": 2015, "deletions": 0, "changes": 2015, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a1ee410cefc93b247bbcc9b8a153ba5af72be73/gcc%2Fconfig%2Fia64%2Funwind-ia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a1ee410cefc93b247bbcc9b8a153ba5af72be73/gcc%2Fconfig%2Fia64%2Funwind-ia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Funwind-ia64.c?ref=2a1ee410cefc93b247bbcc9b8a153ba5af72be73", "patch": "@@ -0,0 +1,2015 @@\n+/* Subroutines needed for unwinding IA-64 standard format stack frame\n+   info for exception handling.\n+   Copyright (C) 1997, 1998, 1999, 2000, 2001 Free Software Foundation, Inc.\n+   Contributed by Andrew MacLeod  <amacleod@cygnus.com>\n+\t          Andrew Haley  <aph@cygnus.com>\n+\t\t  David Mosberger-Tang <davidm@hpl.hp.com>\n+\n+   This file is part of GNU CC.\n+\n+   GNU CC is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 2, or (at your option)\n+   any later version.\n+\n+   GNU CC is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GNU CC; see the file COPYING.  If not, write to\n+   the Free Software Foundation, 59 Temple Place - Suite 330,\n+   Boston, MA 02111-1307, USA.  */\n+\n+/* As a special exception, if you link this library with other files,\n+   some of which are compiled with GCC, to produce an executable,\n+   this library does not by itself cause the resulting executable\n+   to be covered by the GNU General Public License.\n+   This exception does not however invalidate any other reasons why\n+   the executable file might be covered by the GNU General Public License.  */\n+\n+\n+#include \"tconfig.h\"\n+#include \"tsystem.h\"\n+#include \"unwind.h\"\n+#include \"unwind-ia64.h\"\n+\n+#if !USING_SJLJ_EXCEPTIONS\n+\n+#define inline\n+\f\n+#define UNW_VER(x)\t\t((x) >> 48)\n+#define UNW_FLAG_MASK\t\t0x0000ffff00000000\n+#define UNW_FLAG_OSMASK\t\t0x0000f00000000000\n+#define UNW_FLAG_EHANDLER(x)\t((x) & 0x0000000100000000L)\n+#define UNW_FLAG_UHANDLER(x)\t((x) & 0x0000000200000000L)\n+#define UNW_LENGTH(x)\t\t((x) & 0x00000000ffffffffL)\n+\n+enum unw_application_register\n+{\n+  UNW_AR_BSP,\n+  UNW_AR_BSPSTORE,\n+  UNW_AR_PFS,\n+  UNW_AR_RNAT,\n+  UNW_AR_UNAT,\n+  UNW_AR_LC,\n+  UNW_AR_EC,\n+  UNW_AR_FPSR,\n+  UNW_AR_RSC,\n+  UNW_AR_CCV\n+};\n+\n+enum unw_register_index\n+{\n+  /* Primary UNAT.  */\n+  UNW_REG_PRI_UNAT_GR,\n+  UNW_REG_PRI_UNAT_MEM,\n+\n+  /* Memory Stack.  */\n+  UNW_REG_PSP,\t\t\t/* previous memory stack pointer */\n+\n+  /* Register Stack.  */\n+  UNW_REG_BSP,\t\t\t/* register stack pointer */\n+  UNW_REG_BSPSTORE,\n+  UNW_REG_PFS,\t\t\t/* previous function state */\n+  UNW_REG_RNAT,\n+  /* Return Pointer.  */\n+  UNW_REG_RP,\n+\n+  /* Special preserved registers.  */\n+  UNW_REG_UNAT, UNW_REG_PR, UNW_REG_LC, UNW_REG_FPSR,\n+\n+  /* Non-stacked general registers.  */\n+  UNW_REG_R2,\n+  UNW_REG_R4 = UNW_REG_R2 + 2,\n+  UNW_REG_R7 = UNW_REG_R2 + 5,\n+  UNW_REG_R31 = UNW_REG_R2 + 29,\n+\n+  /* Non-stacked floating point registers.  */\n+  UNW_REG_F2,\n+  UNW_REG_F5 = UNW_REG_F2 + 3,\n+  UNW_REG_F16 = UNW_REG_F2 + 14,\n+  UNW_REG_F31 = UNW_REG_F2 + 29,\n+\n+  /* Branch registers.  */\n+  UNW_REG_B1,\n+  UNW_REG_B5 = UNW_REG_B1 + 4,\n+\n+  UNW_NUM_REGS\n+};\n+\n+enum unw_where\n+{\n+  UNW_WHERE_NONE,\t/* register isn't saved at all */\n+  UNW_WHERE_GR,\t\t/* register is saved in a general register */\n+  UNW_WHERE_FR,\t\t/* register is saved in a floating-point register */\n+  UNW_WHERE_BR,\t\t/* register is saved in a branch register */\n+  UNW_WHERE_SPREL,\t/* register is saved on memstack (sp-relative) */\n+  UNW_WHERE_PSPREL,\t/* register is saved on memstack (psp-relative) */\n+ \n+ /* At the end of each prologue these locations get resolved to\n+     UNW_WHERE_PSPREL and UNW_WHERE_GR, respectively.  */\n+  UNW_WHERE_SPILL_HOME,\t/* register is saved in its spill home */\n+  UNW_WHERE_GR_SAVE\t/* register is saved in next general register */\n+};\n+\n+#define UNW_WHEN_NEVER  0x7fffffff\n+\n+struct unw_reg_info\n+{\n+  unsigned long val;\t\t/* save location: register number or offset */\n+  enum unw_where where;\t\t/* where the register gets saved */\n+  int when;\t\t\t/* when the register gets saved */\n+};\n+\n+typedef struct unw_state_record\n+{\n+  unsigned int first_region : 1;\t/* is this the first region? */\n+  unsigned int done : 1;\t\t/* are we done scanning descriptors? */\n+  unsigned int any_spills : 1;\t\t/* got any register spills? */\n+  unsigned int in_body : 1;\t/* are we inside a body? */\n+\n+  unsigned char *imask;\t\t/* imask of of spill_mask record or NULL */\n+  unsigned long pr_val;\t\t/* predicate values */\n+  unsigned long pr_mask;\t/* predicate mask */\n+  long spill_offset;\t\t/* psp-relative offset for spill base */\n+  int region_start;\n+  int region_len;\n+  int epilogue_start;\n+  int epilogue_count;\n+  int when_target;\n+\n+  unsigned char gr_save_loc;\t/* next general register to use for saving */\n+  unsigned char return_link_reg; /* branch register for return link */\n+\n+  struct unw_reg_state {\n+    struct unw_reg_state *next;\n+    unsigned long label;\t/* label of this state record */\n+    struct unw_reg_info reg[UNW_NUM_REGS];\n+  } curr, *stack, *reg_state_list;\n+\n+  _Unwind_Personality_Fn personality;\n+  \n+} _Unwind_FrameState;\n+\n+enum unw_nat_type\n+{\n+  UNW_NAT_NONE,\t\t\t/* NaT not represented */\n+  UNW_NAT_VAL,\t\t\t/* NaT represented by NaT value (fp reg) */\n+  UNW_NAT_MEMSTK,\t\t/* NaT value is in unat word at offset OFF  */\n+  UNW_NAT_REGSTK\t\t/* NaT is in rnat */\n+};\n+\n+struct unw_stack\n+{\n+  unsigned long limit;\n+  unsigned long top;\n+};\n+\n+struct _Unwind_Context\n+{\n+  /* Initial frame info.  */\n+  unsigned long rnat;\t\t/* rse nat collection */\n+  unsigned long regstk_top;\t/* bsp for first frame */\n+\n+  /* Current frame info.  */\n+  unsigned long bsp;\t\t/* backing store pointer value */\n+  unsigned long sp;\t\t/* stack pointer value */\n+  unsigned long psp;\t\t/* previous sp value */\n+  unsigned long rp;\t\t/* return pointer */\n+  unsigned long pr;\t\t/* predicate collection */\n+\n+  unsigned long region_start;\t/* start of unwind region */\n+  unsigned long gp;\t\t/* global pointer value */\n+  void *lsda;\t\t\t/* language specific data area */\n+\n+  /* Preserved state.  */\n+  unsigned long *bsp_loc;\t/* previous bsp save location */\n+  unsigned long *bspstore_loc;\n+  unsigned long *pfs_loc;\n+  unsigned long *pri_unat_loc;\n+  unsigned long *unat_loc;\n+  unsigned long *lc_loc;\n+  unsigned long *fpsr_loc;\n+\n+  unsigned long eh_data[4];\n+\n+  struct unw_ireg\n+  {\n+    unsigned long *loc;\n+    struct unw_ireg_nat\n+    {\n+      enum unw_nat_type type : 3;\n+      signed long off : 61;\t\t/* NaT word is at loc+nat.off */\n+    } nat;\n+  } ireg[32 - 2];\n+\n+  unsigned long *br_loc[6 - 1];\n+  void *fr_loc[32 - 2];\n+};\n+\n+typedef unsigned long unw_word;\n+\n+/* Implicit register save order.  See section 11.4.2.3 Rules for Using\n+   Unwind Descriptors, rule 3.  */\n+\n+static unsigned char const save_order[] =\n+{\n+  UNW_REG_RP, UNW_REG_PFS, UNW_REG_PSP, UNW_REG_PR,\n+  UNW_REG_UNAT, UNW_REG_LC, UNW_REG_FPSR, UNW_REG_PRI_UNAT_GR\n+};\n+\n+\f\n+#define MIN(X, Y) ((X) < (Y) ? (X) : (Y))\n+\n+/* Unwind decoder routines */\n+\n+static void\n+push (struct unw_state_record *sr)\n+{\n+  struct unw_reg_state *rs;\n+\n+  rs = malloc (sizeof (struct unw_reg_state));\n+  memcpy (rs, &sr->curr, sizeof (*rs));\n+  rs->next = sr->stack;\n+  sr->stack = rs;\n+}\n+\n+static void\n+pop (struct unw_state_record *sr)\n+{\n+  struct unw_reg_state *rs;\n+\n+  rs = sr->stack;\n+  sr->stack = rs->next;\n+  free (rs);\n+}\n+\n+static enum unw_register_index __attribute__((const))\n+decode_abreg (unsigned char abreg, int memory)\n+{\n+  switch (abreg)\n+    {\n+    case 0x04 ... 0x07: return UNW_REG_R4 + (abreg - 0x04);\n+    case 0x22 ... 0x25: return UNW_REG_F2 + (abreg - 0x22);\n+    case 0x30 ... 0x3f: return UNW_REG_F16 + (abreg - 0x30);\n+    case 0x41 ... 0x45: return UNW_REG_B1 + (abreg - 0x41);\n+    case 0x60: return UNW_REG_PR;\n+    case 0x61: return UNW_REG_PSP;\n+    case 0x62: return memory ? UNW_REG_PRI_UNAT_MEM : UNW_REG_PRI_UNAT_GR;\n+    case 0x63: return UNW_REG_RP;\n+    case 0x64: return UNW_REG_BSP;\n+    case 0x65: return UNW_REG_BSPSTORE;\n+    case 0x66: return UNW_REG_RNAT;\n+    case 0x67: return UNW_REG_UNAT;\n+    case 0x68: return UNW_REG_FPSR;\n+    case 0x69: return UNW_REG_PFS;\n+    case 0x6a: return UNW_REG_LC;\n+    default:\n+      abort ();\n+  }\n+}\n+\n+static void\n+set_reg (struct unw_reg_info *reg, enum unw_where where,\n+\t int when, unsigned long val)\n+{\n+  reg->val = val;\n+  reg->where = where;\n+  if (reg->when == UNW_WHEN_NEVER)\n+    reg->when = when;\n+}\n+\n+static void\n+alloc_spill_area (unsigned long *offp, unsigned long regsize,\n+\t\t  struct unw_reg_info *lo, struct unw_reg_info *hi)\n+{\n+  struct unw_reg_info *reg;\n+\n+  for (reg = hi; reg >= lo; --reg)\n+    {\n+      if (reg->where == UNW_WHERE_SPILL_HOME)\n+\t{\n+\t  reg->where = UNW_WHERE_PSPREL;\n+\t  reg->val = 0x10 - *offp;\n+\t  *offp += regsize;\n+\t}\n+    }\n+}\n+\n+static inline void\n+spill_next_when (struct unw_reg_info **regp, struct unw_reg_info *lim,\n+\t\t unw_word t)\n+{\n+  struct unw_reg_info *reg;\n+\n+  for (reg = *regp; reg <= lim; ++reg)\n+    {\n+      if (reg->where == UNW_WHERE_SPILL_HOME)\n+\t{\n+\t  reg->when = t;\n+\t  *regp = reg + 1;\n+\t  return;\n+\t}\n+    }\n+  /* Excess spill.  */\n+  abort ();\n+}\n+\n+static void\n+finish_prologue (struct unw_state_record *sr)\n+{\n+  struct unw_reg_info *reg;\n+  unsigned long off;\n+  int i;\n+\n+  /* First, resolve implicit register save locations\n+     (see Section \"11.4.2.3 Rules for Using Unwind Descriptors\", rule 3).  */\n+\n+  for (i = 0; i < (int) sizeof(save_order); ++i)\n+    {\n+      reg = sr->curr.reg + save_order[i];\n+      if (reg->where == UNW_WHERE_GR_SAVE)\n+\t{\n+\t  reg->where = UNW_WHERE_GR;\n+\t  reg->val = sr->gr_save_loc++;\n+\t}\n+    }\n+\n+  /* Next, compute when the fp, general, and branch registers get saved.\n+     This must come before alloc_spill_area() because we need to know\n+     which registers are spilled to their home locations.  */\n+  if (sr->imask)\n+    {\n+      static unsigned char const limit[3] = {\n+\tUNW_REG_F31, UNW_REG_R7, UNW_REG_B5\n+      };\n+\n+      unsigned char kind, mask = 0, *cp = sr->imask;\n+      int t;\n+      struct unw_reg_info *(regs[3]);\n+\n+      regs[0] = sr->curr.reg + UNW_REG_F2;\n+      regs[1] = sr->curr.reg + UNW_REG_R4;\n+      regs[2] = sr->curr.reg + UNW_REG_B1;\n+\n+      for (t = 0; t < sr->region_len; ++t)\n+\t{\n+\t  if ((t & 3) == 0)\n+\t    mask = *cp++;\n+\t  kind = (mask >> 2*(3-(t & 3))) & 3;\n+\t  if (kind > 0)\n+\t    spill_next_when(&regs[kind - 1], sr->curr.reg + limit[kind - 1],\n+\t\t\t    sr->region_start + t);\n+\t}\n+    }\n+\n+  /* Next, lay out the memory stack spill area.  */\n+  if (sr->any_spills)\n+    {\n+      off = sr->spill_offset;\n+      alloc_spill_area(&off, 16, sr->curr.reg + UNW_REG_F2,\n+\t\t       sr->curr.reg + UNW_REG_F31); \n+      alloc_spill_area(&off,  8, sr->curr.reg + UNW_REG_B1,\n+\t\t       sr->curr.reg + UNW_REG_B5);\n+      alloc_spill_area(&off,  8, sr->curr.reg + UNW_REG_R4,\n+\t\t       sr->curr.reg + UNW_REG_R7);\n+    }\n+}\n+\n+/*\n+ * Region header descriptors.\n+ */\n+\n+static void\n+desc_prologue (int body, unw_word rlen, unsigned char mask,\n+\t       unsigned char grsave, struct unw_state_record *sr)\n+{\n+  int i;\n+\n+  if (!(sr->in_body || sr->first_region))\n+    finish_prologue(sr);\n+  sr->first_region = 0;\n+\n+  /* Check if we're done.  */\n+  if (body && sr->when_target < sr->region_start + sr->region_len)\n+    {\n+      sr->done = 1;\n+      return;\n+    }\n+\n+  for (i = 0; i < sr->epilogue_count; ++i)\n+    pop(sr);\n+  sr->epilogue_count = 0;\n+  sr->epilogue_start = UNW_WHEN_NEVER;\n+\n+  if (!body)\n+    push(sr);\n+\n+  sr->region_start += sr->region_len;\n+  sr->region_len = rlen;\n+  sr->in_body = body;\n+\n+  if (!body)\n+    {\n+      for (i = 0; i < 4; ++i)\n+\t{\n+\t  if (mask & 0x8)\n+\t    set_reg (sr->curr.reg + save_order[i], UNW_WHERE_GR,\n+\t\t     sr->region_start + sr->region_len - 1, grsave++);\n+\t  mask <<= 1;\n+\t}\n+      sr->gr_save_loc = grsave;\n+      sr->any_spills = 0;\n+      sr->imask = 0;\n+      sr->spill_offset = 0x10;\t/* default to psp+16 */\n+    }\n+}\n+\n+/*\n+ * Prologue descriptors.\n+ */\n+\n+static inline void\n+desc_abi (unsigned char abi __attribute__((unused)),\n+\t  unsigned char context __attribute__((unused)),\n+\t  struct unw_state_record *sr __attribute__((unused)))\n+{\n+  /* Anything to do?  */\n+}\n+\n+static inline void\n+desc_br_gr (unsigned char brmask, unsigned char gr,\n+\t    struct unw_state_record *sr)\n+{\n+  int i;\n+\n+  for (i = 0; i < 5; ++i)\n+    {\n+      if (brmask & 1)\n+\tset_reg (sr->curr.reg + UNW_REG_B1 + i, UNW_WHERE_GR,\n+\t\t sr->region_start + sr->region_len - 1, gr++);\n+      brmask >>= 1;\n+    }\n+}\n+\n+static inline void\n+desc_br_mem (unsigned char brmask, struct unw_state_record *sr)\n+{\n+  int i;\n+\n+  for (i = 0; i < 5; ++i)\n+    {\n+      if (brmask & 1)\n+\t{\n+\t  set_reg (sr->curr.reg + UNW_REG_B1 + i, UNW_WHERE_SPILL_HOME,\n+\t\t   sr->region_start + sr->region_len - 1, 0);\n+\t  sr->any_spills = 1;\n+\t}\n+      brmask >>= 1;\n+    }\n+}\n+\n+static inline void\n+desc_frgr_mem (unsigned char grmask, unw_word frmask,\n+\t       struct unw_state_record *sr)\n+{\n+  int i;\n+\n+  for (i = 0; i < 4; ++i)\n+    {\n+      if ((grmask & 1) != 0)\n+\t{\n+\t  set_reg (sr->curr.reg + UNW_REG_R4 + i, UNW_WHERE_SPILL_HOME,\n+\t\t   sr->region_start + sr->region_len - 1, 0);\n+\t  sr->any_spills = 1;\n+\t}\n+      grmask >>= 1;\n+    }\n+  for (i = 0; i < 20; ++i)\n+    {\n+      if ((frmask & 1) != 0)\n+\t{\n+\t  set_reg (sr->curr.reg + UNW_REG_F2 + i, UNW_WHERE_SPILL_HOME,\n+\t\t   sr->region_start + sr->region_len - 1, 0);\n+\t  sr->any_spills = 1;\n+\t}\n+      frmask >>= 1;\n+    }\n+}\n+\n+static inline void\n+desc_fr_mem (unsigned char frmask, struct unw_state_record *sr)\n+{\n+  int i;\n+\n+  for (i = 0; i < 4; ++i)\n+    {\n+      if ((frmask & 1) != 0)\n+\t{\n+\t  set_reg (sr->curr.reg + UNW_REG_F2 + i, UNW_WHERE_SPILL_HOME,\n+\t\t   sr->region_start + sr->region_len - 1, 0);\n+\t  sr->any_spills = 1;\n+\t}\n+      frmask >>= 1;\n+    }\n+}\n+\n+static inline void\n+desc_gr_gr (unsigned char grmask, unsigned char gr,\n+\t    struct unw_state_record *sr)\n+{\n+  int i;\n+\n+  for (i = 0; i < 4; ++i)\n+    {\n+      if ((grmask & 1) != 0)\n+\tset_reg (sr->curr.reg + UNW_REG_R4 + i, UNW_WHERE_GR,\n+\t\t sr->region_start + sr->region_len - 1, gr++);\n+      grmask >>= 1;\n+    }\n+}\n+\n+static inline void\n+desc_gr_mem (unsigned char grmask, struct unw_state_record *sr)\n+{\n+  int i;\n+\n+  for (i = 0; i < 4; ++i)\n+    {\n+      if ((grmask & 1) != 0)\n+\t{\n+\t  set_reg (sr->curr.reg + UNW_REG_R4 + i, UNW_WHERE_SPILL_HOME,\n+\t\t   sr->region_start + sr->region_len - 1, 0);\n+\t  sr->any_spills = 1;\n+\t}\n+      grmask >>= 1;\n+    }\n+}\n+\n+static inline void\n+desc_mem_stack_f (unw_word t, unw_word size, struct unw_state_record *sr)\n+{\n+  set_reg (sr->curr.reg + UNW_REG_PSP, UNW_WHERE_NONE,\n+\t   sr->region_start + MIN ((int)t, sr->region_len - 1), 16*size);\n+}\n+\n+static inline void\n+desc_mem_stack_v (unw_word t, struct unw_state_record *sr)\n+{\n+  sr->curr.reg[UNW_REG_PSP].when\n+    = sr->region_start + MIN ((int)t, sr->region_len - 1);\n+}\n+\n+static inline void\n+desc_reg_gr (unsigned char reg, unsigned char dst, struct unw_state_record *sr)\n+{\n+  set_reg (sr->curr.reg + reg, UNW_WHERE_GR,\n+\t   sr->region_start + sr->region_len - 1, dst);\n+}\n+\n+static inline void\n+desc_reg_psprel (unsigned char reg, unw_word pspoff,\n+\t\t struct unw_state_record *sr)\n+{\n+  set_reg (sr->curr.reg + reg, UNW_WHERE_PSPREL,\n+\t   sr->region_start + sr->region_len - 1,\n+\t   0x10 - 4*pspoff);\n+}\n+\n+static inline void\n+desc_reg_sprel (unsigned char reg, unw_word spoff, struct unw_state_record *sr)\n+{\n+  set_reg (sr->curr.reg + reg, UNW_WHERE_SPREL,\n+\t   sr->region_start + sr->region_len - 1,\n+\t   4*spoff);\n+}\n+\n+static inline void\n+desc_rp_br (unsigned char dst, struct unw_state_record *sr)\n+{\n+  sr->return_link_reg = dst;\n+}\n+\n+static inline void\n+desc_reg_when (unsigned char regnum, unw_word t, struct unw_state_record *sr)\n+{\n+  struct unw_reg_info *reg = sr->curr.reg + regnum;\n+\n+  if (reg->where == UNW_WHERE_NONE)\n+    reg->where = UNW_WHERE_GR_SAVE;\n+  reg->when = sr->region_start + MIN ((int)t, sr->region_len - 1);\n+}\n+\n+static inline void\n+desc_spill_base (unw_word pspoff, struct unw_state_record *sr)\n+{\n+  sr->spill_offset = 0x10 - 4*pspoff;\n+}\n+\n+static inline unsigned char *\n+desc_spill_mask (unsigned char *imaskp, struct unw_state_record *sr)\n+{\n+  sr->imask = imaskp;\n+  return imaskp + (2*sr->region_len + 7)/8;\n+}\n+\n+/*\n+ * Body descriptors.\n+ */\n+static inline void\n+desc_epilogue (unw_word t, unw_word ecount, struct unw_state_record *sr)\n+{\n+  sr->epilogue_start = sr->region_start + sr->region_len - 1 - t;\n+  sr->epilogue_count = ecount + 1;\n+}\n+\n+static inline void\n+desc_copy_state (unw_word label, struct unw_state_record *sr)\n+{\n+  struct unw_reg_state *rs;\n+\n+  for (rs = sr->reg_state_list; rs; rs = rs->next)\n+    {\n+      if (rs->label == label)\n+\t{\n+\t  memcpy (&sr->curr, rs, sizeof(sr->curr));\n+\t  return;\n+\t}\n+    }\n+  abort ();\n+}\n+\n+static inline void\n+desc_label_state (unw_word label, struct unw_state_record *sr)\n+{\n+  struct unw_reg_state *rs;\n+\n+  rs = malloc (sizeof (struct unw_reg_state));\n+  memcpy (rs, &sr->curr, sizeof (*rs));\n+  rs->label = label;\n+  rs->next = sr->reg_state_list;\n+  sr->reg_state_list = rs;\n+}\n+\n+/*\n+ * General descriptors.\n+ */\n+\n+static inline int\n+desc_is_active (unsigned char qp, unw_word t, struct unw_state_record *sr)\n+{\n+  if (sr->when_target <= sr->region_start + MIN ((int)t, sr->region_len - 1))\n+    return 0;\n+  if (qp > 0)\n+    {\n+      if ((sr->pr_val & (1UL << qp)) == 0) \n+\treturn 0;\n+      sr->pr_mask |= (1UL << qp);\n+    }\n+  return 1;\n+}\n+\n+static inline void\n+desc_restore_p (unsigned char qp, unw_word t, unsigned char abreg,\n+\t\tstruct unw_state_record *sr)\n+{\n+  struct unw_reg_info *r;\n+\n+  if (! desc_is_active (qp, t, sr))\n+    return;\n+\n+  r = sr->curr.reg + decode_abreg (abreg, 0);\n+  r->where = UNW_WHERE_NONE;\n+  r->when = sr->region_start + MIN ((int)t, sr->region_len - 1);\n+  r->val = 0;\n+}\n+\n+static inline void\n+desc_spill_reg_p (unsigned char qp, unw_word t, unsigned char abreg,\n+\t\t  unsigned char x, unsigned char ytreg,\n+\t\t  struct unw_state_record *sr)\n+{\n+  enum unw_where where = UNW_WHERE_GR;\n+  struct unw_reg_info *r;\n+\n+  if (! desc_is_active (qp, t, sr))\n+    return;\n+\n+  if (x)\n+    where = UNW_WHERE_BR;\n+  else if (ytreg & 0x80)\n+    where = UNW_WHERE_FR;\n+\n+  r = sr->curr.reg + decode_abreg (abreg, 0);\n+  r->where = where;\n+  r->when = sr->region_start + MIN ((int)t, sr->region_len - 1);\n+  r->val = ytreg & 0x7f;\n+}\n+\n+static inline void\n+desc_spill_psprel_p (unsigned char qp, unw_word t, unsigned char abreg,\n+\t\t     unw_word pspoff, struct unw_state_record *sr)\n+{\n+  struct unw_reg_info *r;\n+\n+  if (! desc_is_active (qp, t, sr))\n+    return;\n+\n+  r = sr->curr.reg + decode_abreg (abreg, 1);\n+  r->where = UNW_WHERE_PSPREL;\n+  r->when = sr->region_start + MIN((int)t, sr->region_len - 1);\n+  r->val = 0x10 - 4*pspoff;\n+}\n+\n+static inline void\n+desc_spill_sprel_p (unsigned char qp, unw_word t, unsigned char abreg,\n+\t\t    unw_word spoff, struct unw_state_record *sr)\n+{\n+  struct unw_reg_info *r;\n+\n+  if (! desc_is_active (qp, t, sr))\n+    return;\n+\n+  r = sr->curr.reg + decode_abreg (abreg, 1);\n+  r->where = UNW_WHERE_SPREL;\n+  r->when = sr->region_start + MIN ((int)t, sr->region_len - 1);\n+  r->val = 4*spoff;\n+}\n+\n+\f\n+#define UNW_DEC_BAD_CODE(code)\t\t\tabort ();\n+\n+/* Region headers.  */\n+#define UNW_DEC_PROLOGUE_GR(fmt,r,m,gr,arg)\tdesc_prologue(0,r,m,gr,arg)\n+#define UNW_DEC_PROLOGUE(fmt,b,r,arg)\t\tdesc_prologue(b,r,0,32,arg)\n+\n+/* Prologue descriptors. */\n+#define UNW_DEC_ABI(fmt,a,c,arg)\t\tdesc_abi(a,c,arg)\n+#define UNW_DEC_BR_GR(fmt,b,g,arg)\t\tdesc_br_gr(b,g,arg)\n+#define UNW_DEC_BR_MEM(fmt,b,arg)\t\tdesc_br_mem(b,arg)\n+#define UNW_DEC_FRGR_MEM(fmt,g,f,arg)\t\tdesc_frgr_mem(g,f,arg)\n+#define UNW_DEC_FR_MEM(fmt,f,arg)\t\tdesc_fr_mem(f,arg)\n+#define UNW_DEC_GR_GR(fmt,m,g,arg)\t\tdesc_gr_gr(m,g,arg)\n+#define UNW_DEC_GR_MEM(fmt,m,arg)\t\tdesc_gr_mem(m,arg)\n+#define UNW_DEC_MEM_STACK_F(fmt,t,s,arg)\tdesc_mem_stack_f(t,s,arg)\n+#define UNW_DEC_MEM_STACK_V(fmt,t,arg)\t\tdesc_mem_stack_v(t,arg)\n+#define UNW_DEC_REG_GR(fmt,r,d,arg)\t\tdesc_reg_gr(r,d,arg)\n+#define UNW_DEC_REG_PSPREL(fmt,r,o,arg)\t\tdesc_reg_psprel(r,o,arg)\n+#define UNW_DEC_REG_SPREL(fmt,r,o,arg)\t\tdesc_reg_sprel(r,o,arg)\n+#define UNW_DEC_REG_WHEN(fmt,r,t,arg)\t\tdesc_reg_when(r,t,arg)\n+#define UNW_DEC_PRIUNAT_WHEN_GR(fmt,t,arg)\tdesc_reg_when(UNW_REG_PRI_UNAT_GR,t,arg)\n+#define UNW_DEC_PRIUNAT_WHEN_MEM(fmt,t,arg)\tdesc_reg_when(UNW_REG_PRI_UNAT_MEM,t,arg)\n+#define UNW_DEC_PRIUNAT_GR(fmt,r,arg)\t\tdesc_reg_gr(UNW_REG_PRI_UNAT_GR,r,arg)\n+#define UNW_DEC_PRIUNAT_PSPREL(fmt,o,arg)\tdesc_reg_psprel(UNW_REG_PRI_UNAT_MEM,o,arg)\n+#define UNW_DEC_PRIUNAT_SPREL(fmt,o,arg)\tdesc_reg_sprel(UNW_REG_PRI_UNAT_MEM,o,arg)\n+#define UNW_DEC_RP_BR(fmt,d,arg)\t\tdesc_rp_br(d,arg)\n+#define UNW_DEC_SPILL_BASE(fmt,o,arg)\t\tdesc_spill_base(o,arg)\n+#define UNW_DEC_SPILL_MASK(fmt,m,arg)\t\t(m = desc_spill_mask(m,arg))\n+\n+/* Body descriptors.  */\n+#define UNW_DEC_EPILOGUE(fmt,t,c,arg)\t\tdesc_epilogue(t,c,arg)\n+#define UNW_DEC_COPY_STATE(fmt,l,arg)\t\tdesc_copy_state(l,arg)\n+#define UNW_DEC_LABEL_STATE(fmt,l,arg)\t\tdesc_label_state(l,arg)\n+\n+/* General unwind descriptors.  */\n+#define UNW_DEC_SPILL_REG_P(f,p,t,a,x,y,arg)\tdesc_spill_reg_p(p,t,a,x,y,arg)\n+#define UNW_DEC_SPILL_REG(f,t,a,x,y,arg)\tdesc_spill_reg_p(0,t,a,x,y,arg)\n+#define UNW_DEC_SPILL_PSPREL_P(f,p,t,a,o,arg)\tdesc_spill_psprel_p(p,t,a,o,arg)\n+#define UNW_DEC_SPILL_PSPREL(f,t,a,o,arg)\tdesc_spill_psprel_p(0,t,a,o,arg)\n+#define UNW_DEC_SPILL_SPREL_P(f,p,t,a,o,arg)\tdesc_spill_sprel_p(p,t,a,o,arg)\n+#define UNW_DEC_SPILL_SPREL(f,t,a,o,arg)\tdesc_spill_sprel_p(0,t,a,o,arg)\n+#define UNW_DEC_RESTORE_P(f,p,t,a,arg)\t\tdesc_restore_p(p,t,a,arg)\n+#define UNW_DEC_RESTORE(f,t,a,arg)\t\tdesc_restore_p(0,t,a,arg)\n+\n+\f\n+/*\n+ * Generic IA-64 unwind info decoder.\n+ *\n+ * This file is used both by the Linux kernel and objdump.  Please keep\n+ * the copies of this file in sync.\n+ *\n+ * You need to customize the decoder by defining the following\n+ * macros/constants before including this file:\n+ *\n+ *  Types:\n+ *\tunw_word\tUnsigned integer type with at least 64 bits \n+ *\n+ *  Register names:\n+ *\tUNW_REG_BSP\n+ *\tUNW_REG_BSPSTORE\n+ *\tUNW_REG_FPSR\n+ *\tUNW_REG_LC\n+ *\tUNW_REG_PFS\n+ *\tUNW_REG_PR\n+ *\tUNW_REG_RNAT\n+ *\tUNW_REG_PSP\n+ *\tUNW_REG_RP\n+ *\tUNW_REG_UNAT\n+ *\n+ *  Decoder action macros:\n+ *\tUNW_DEC_BAD_CODE(code)\n+ *\tUNW_DEC_ABI(fmt,abi,context,arg)\n+ *\tUNW_DEC_BR_GR(fmt,brmask,gr,arg)\n+ *\tUNW_DEC_BR_MEM(fmt,brmask,arg)\n+ *\tUNW_DEC_COPY_STATE(fmt,label,arg)\n+ *\tUNW_DEC_EPILOGUE(fmt,t,ecount,arg)\n+ *\tUNW_DEC_FRGR_MEM(fmt,grmask,frmask,arg)\n+ *\tUNW_DEC_FR_MEM(fmt,frmask,arg)\n+ *\tUNW_DEC_GR_GR(fmt,grmask,gr,arg)\n+ *\tUNW_DEC_GR_MEM(fmt,grmask,arg)\n+ *\tUNW_DEC_LABEL_STATE(fmt,label,arg)\n+ *\tUNW_DEC_MEM_STACK_F(fmt,t,size,arg)\n+ *\tUNW_DEC_MEM_STACK_V(fmt,t,arg)\n+ *\tUNW_DEC_PRIUNAT_GR(fmt,r,arg)\n+ *\tUNW_DEC_PRIUNAT_WHEN_GR(fmt,t,arg)\n+ *\tUNW_DEC_PRIUNAT_WHEN_MEM(fmt,t,arg)\n+ *\tUNW_DEC_PRIUNAT_WHEN_PSPREL(fmt,pspoff,arg)\n+ *\tUNW_DEC_PRIUNAT_WHEN_SPREL(fmt,spoff,arg)\n+ *\tUNW_DEC_PROLOGUE(fmt,body,rlen,arg)\n+ *\tUNW_DEC_PROLOGUE_GR(fmt,rlen,mask,grsave,arg)\n+ *\tUNW_DEC_REG_PSPREL(fmt,reg,pspoff,arg)\n+ *\tUNW_DEC_REG_REG(fmt,src,dst,arg)\n+ *\tUNW_DEC_REG_SPREL(fmt,reg,spoff,arg)\n+ *\tUNW_DEC_REG_WHEN(fmt,reg,t,arg)\n+ *\tUNW_DEC_RESTORE(fmt,t,abreg,arg)\n+ *\tUNW_DEC_RESTORE_P(fmt,qp,t,abreg,arg)\n+ *\tUNW_DEC_SPILL_BASE(fmt,pspoff,arg)\n+ *\tUNW_DEC_SPILL_MASK(fmt,imaskp,arg)\n+ *\tUNW_DEC_SPILL_PSPREL(fmt,t,abreg,pspoff,arg)\n+ *\tUNW_DEC_SPILL_PSPREL_P(fmt,qp,t,abreg,pspoff,arg)\n+ *\tUNW_DEC_SPILL_REG(fmt,t,abreg,x,ytreg,arg)\n+ *\tUNW_DEC_SPILL_REG_P(fmt,qp,t,abreg,x,ytreg,arg)\n+ *\tUNW_DEC_SPILL_SPREL(fmt,t,abreg,spoff,arg)\n+ *\tUNW_DEC_SPILL_SPREL_P(fmt,qp,t,abreg,pspoff,arg)\n+ */\n+\n+static unw_word\n+unw_decode_uleb128 (unsigned char **dpp)\n+{\n+  unsigned shift = 0;\n+  unw_word byte, result = 0;\n+  unsigned char *bp = *dpp;\n+\n+  while (1)\n+    {\n+      byte = *bp++;\n+      result |= (byte & 0x7f) << shift;\n+      if ((byte & 0x80) == 0)\n+\tbreak;\n+      shift += 7;\n+    }\n+  *dpp = bp;\n+  return result;\n+}\n+\n+static unsigned char *\n+unw_decode_x1 (unsigned char *dp,\n+\t       unsigned char code __attribute__((unused)),\n+\t       void *arg)\n+{\n+  unsigned char byte1, abreg;\n+  unw_word t, off;\n+\n+  byte1 = *dp++;\n+  t = unw_decode_uleb128 (&dp);\n+  off = unw_decode_uleb128 (&dp);\n+  abreg = (byte1 & 0x7f);\n+  if (byte1 & 0x80)\n+\t  UNW_DEC_SPILL_SPREL(X1, t, abreg, off, arg);\n+  else\n+\t  UNW_DEC_SPILL_PSPREL(X1, t, abreg, off, arg);\n+  return dp;\n+}\n+\n+static unsigned char *\n+unw_decode_x2 (unsigned char *dp,\n+\t       unsigned char code __attribute__((unused)),\n+\t       void *arg)\n+{\n+  unsigned char byte1, byte2, abreg, x, ytreg;\n+  unw_word t;\n+\n+  byte1 = *dp++; byte2 = *dp++;\n+  t = unw_decode_uleb128 (&dp);\n+  abreg = (byte1 & 0x7f);\n+  ytreg = byte2;\n+  x = (byte1 >> 7) & 1;\n+  if ((byte1 & 0x80) == 0 && ytreg == 0)\n+    UNW_DEC_RESTORE(X2, t, abreg, arg);\n+  else\n+    UNW_DEC_SPILL_REG(X2, t, abreg, x, ytreg, arg);\n+  return dp;\n+}\n+\n+static unsigned char *\n+unw_decode_x3 (unsigned char *dp,\n+\t       unsigned char code __attribute__((unused)),\n+\t       void *arg)\n+{\n+  unsigned char byte1, byte2, abreg, qp;\n+  unw_word t, off;\n+\n+  byte1 = *dp++; byte2 = *dp++;\n+  t = unw_decode_uleb128 (&dp);\n+  off = unw_decode_uleb128 (&dp);\n+\n+  qp = (byte1 & 0x3f);\n+  abreg = (byte2 & 0x7f);\n+\n+  if (byte1 & 0x80)\n+    UNW_DEC_SPILL_SPREL_P(X3, qp, t, abreg, off, arg);\n+  else\n+    UNW_DEC_SPILL_PSPREL_P(X3, qp, t, abreg, off, arg);\n+  return dp;\n+}\n+\n+static unsigned char *\n+unw_decode_x4 (unsigned char *dp,\n+\t       unsigned char code __attribute__((unused)),\n+\t       void *arg)\n+{\n+  unsigned char byte1, byte2, byte3, qp, abreg, x, ytreg;\n+  unw_word t;\n+\n+  byte1 = *dp++; byte2 = *dp++; byte3 = *dp++;\n+  t = unw_decode_uleb128 (&dp);\n+\n+  qp = (byte1 & 0x3f);\n+  abreg = (byte2 & 0x7f);\n+  x = (byte2 >> 7) & 1;\n+  ytreg = byte3;\n+\n+  if ((byte2 & 0x80) == 0 && byte3 == 0)\n+    UNW_DEC_RESTORE_P(X4, qp, t, abreg, arg);\n+  else\n+    UNW_DEC_SPILL_REG_P(X4, qp, t, abreg, x, ytreg, arg);\n+  return dp;\n+}\n+\n+static unsigned char *\n+unw_decode_r1 (unsigned char *dp, unsigned char code, void *arg)\n+{\n+  int body = (code & 0x20) != 0;\n+  unw_word rlen;\n+\n+  rlen = (code & 0x1f);\n+  UNW_DEC_PROLOGUE(R1, body, rlen, arg);\n+  return dp;\n+}\n+\n+static unsigned char *\n+unw_decode_r2 (unsigned char *dp, unsigned char code, void *arg)\n+{\n+  unsigned char byte1, mask, grsave;\n+  unw_word rlen;\n+\n+  byte1 = *dp++;\n+\n+  mask = ((code & 0x7) << 1) | ((byte1 >> 7) & 1);\n+  grsave = (byte1 & 0x7f);\n+  rlen = unw_decode_uleb128 (&dp);\n+  UNW_DEC_PROLOGUE_GR(R2, rlen, mask, grsave, arg);\n+  return dp;\n+}\n+\n+static unsigned char *\n+unw_decode_r3 (unsigned char *dp, unsigned char code, void *arg)\n+{\n+  unw_word rlen;\n+\n+  rlen = unw_decode_uleb128 (&dp);\n+  UNW_DEC_PROLOGUE(R3, ((code & 0x3) == 1), rlen, arg);\n+  return dp;\n+}\n+\n+static unsigned char *\n+unw_decode_p1 (unsigned char *dp, unsigned char code, void *arg)\n+{\n+  unsigned char brmask = (code & 0x1f);\n+\n+  UNW_DEC_BR_MEM(P1, brmask, arg);\n+  return dp;\n+}\n+\n+static unsigned char *\n+unw_decode_p2_p5 (unsigned char *dp, unsigned char code, void *arg)\n+{\n+  if ((code & 0x10) == 0)\n+    {\n+      unsigned char byte1 = *dp++;\n+\n+      UNW_DEC_BR_GR(P2, ((code & 0xf) << 1) | ((byte1 >> 7) & 1),\n+\t\t    (byte1 & 0x7f), arg);\n+    }\n+  else if ((code & 0x08) == 0)\n+    {\n+      unsigned char byte1 = *dp++, r, dst;\n+\n+      r = ((code & 0x7) << 1) | ((byte1 >> 7) & 1);\n+      dst = (byte1 & 0x7f);\n+      switch (r)\n+\t{\n+\tcase 0: UNW_DEC_REG_GR(P3, UNW_REG_PSP, dst, arg); break;\n+\tcase 1: UNW_DEC_REG_GR(P3, UNW_REG_RP, dst, arg); break;\n+\tcase 2: UNW_DEC_REG_GR(P3, UNW_REG_PFS, dst, arg); break;\n+\tcase 3: UNW_DEC_REG_GR(P3, UNW_REG_PR, dst, arg); break;\n+\tcase 4: UNW_DEC_REG_GR(P3, UNW_REG_UNAT, dst, arg); break;\n+\tcase 5: UNW_DEC_REG_GR(P3, UNW_REG_LC, dst, arg); break;\n+\tcase 6: UNW_DEC_RP_BR(P3, dst, arg); break;\n+\tcase 7: UNW_DEC_REG_GR(P3, UNW_REG_RNAT, dst, arg); break;\n+\tcase 8: UNW_DEC_REG_GR(P3, UNW_REG_BSP, dst, arg); break;\n+\tcase 9: UNW_DEC_REG_GR(P3, UNW_REG_BSPSTORE, dst, arg); break;\n+\tcase 10: UNW_DEC_REG_GR(P3, UNW_REG_FPSR, dst, arg); break;\n+\tcase 11: UNW_DEC_PRIUNAT_GR(P3, dst, arg); break;\n+\tdefault: UNW_DEC_BAD_CODE(r); break;\n+\t}\n+    }\n+  else if ((code & 0x7) == 0)\n+    UNW_DEC_SPILL_MASK(P4, dp, arg);\n+  else if ((code & 0x7) == 1)\n+    {\n+      unw_word grmask, frmask, byte1, byte2, byte3;\n+\n+      byte1 = *dp++; byte2 = *dp++; byte3 = *dp++;\n+      grmask = ((byte1 >> 4) & 0xf);\n+      frmask = ((byte1 & 0xf) << 16) | (byte2 << 8) | byte3;\n+      UNW_DEC_FRGR_MEM(P5, grmask, frmask, arg);\n+    }\n+  else\n+    UNW_DEC_BAD_CODE(code);\n+  return dp;\n+}\n+\n+static unsigned char *\n+unw_decode_p6 (unsigned char *dp, unsigned char code, void *arg)\n+{\n+  int gregs = (code & 0x10) != 0;\n+  unsigned char mask = (code & 0x0f);\n+\n+  if (gregs)\n+    UNW_DEC_GR_MEM(P6, mask, arg);\n+  else\n+    UNW_DEC_FR_MEM(P6, mask, arg);\n+  return dp;\n+}\n+\n+static unsigned char *\n+unw_decode_p7_p10 (unsigned char *dp, unsigned char code, void *arg)\n+{\n+  unsigned char r, byte1, byte2;\n+  unw_word t, size;\n+\n+  if ((code & 0x10) == 0)\n+    {\n+      r = (code & 0xf);\n+      t = unw_decode_uleb128 (&dp);\n+      switch (r)\n+\t{\n+\tcase 0:\n+\t  size = unw_decode_uleb128 (&dp);\n+\t  UNW_DEC_MEM_STACK_F(P7, t, size, arg);\n+\t  break;\n+\n+\tcase 1: UNW_DEC_MEM_STACK_V(P7, t, arg); break;\n+\tcase 2: UNW_DEC_SPILL_BASE(P7, t, arg); break;\n+\tcase 3: UNW_DEC_REG_SPREL(P7, UNW_REG_PSP, t, arg); break;\n+\tcase 4: UNW_DEC_REG_WHEN(P7, UNW_REG_RP, t, arg); break;\n+\tcase 5: UNW_DEC_REG_PSPREL(P7, UNW_REG_RP, t, arg); break;\n+\tcase 6: UNW_DEC_REG_WHEN(P7, UNW_REG_PFS, t, arg); break;\n+\tcase 7: UNW_DEC_REG_PSPREL(P7, UNW_REG_PFS, t, arg); break;\n+\tcase 8: UNW_DEC_REG_WHEN(P7, UNW_REG_PR, t, arg); break;\n+\tcase 9: UNW_DEC_REG_PSPREL(P7, UNW_REG_PR, t, arg); break;\n+\tcase 10: UNW_DEC_REG_WHEN(P7, UNW_REG_LC, t, arg); break;\n+\tcase 11: UNW_DEC_REG_PSPREL(P7, UNW_REG_LC, t, arg); break;\n+\tcase 12: UNW_DEC_REG_WHEN(P7, UNW_REG_UNAT, t, arg); break;\n+\tcase 13: UNW_DEC_REG_PSPREL(P7, UNW_REG_UNAT, t, arg); break;\n+\tcase 14: UNW_DEC_REG_WHEN(P7, UNW_REG_FPSR, t, arg); break;\n+\tcase 15: UNW_DEC_REG_PSPREL(P7, UNW_REG_FPSR, t, arg); break;\n+\tdefault: UNW_DEC_BAD_CODE(r); break;\n+\t}\n+    }\n+  else\n+    {\n+      switch (code & 0xf)\n+\t{\n+\tcase 0x0: /* p8 */\n+\t  {\n+\t    r = *dp++;\n+\t    t = unw_decode_uleb128 (&dp);\n+\t    switch (r)\n+\t      {\n+\t      case  1: UNW_DEC_REG_SPREL(P8, UNW_REG_RP, t, arg); break;\n+\t      case  2: UNW_DEC_REG_SPREL(P8, UNW_REG_PFS, t, arg); break;\n+\t      case  3: UNW_DEC_REG_SPREL(P8, UNW_REG_PR, t, arg); break;\n+\t      case  4: UNW_DEC_REG_SPREL(P8, UNW_REG_LC, t, arg); break;\n+\t      case  5: UNW_DEC_REG_SPREL(P8, UNW_REG_UNAT, t, arg); break;\n+\t      case  6: UNW_DEC_REG_SPREL(P8, UNW_REG_FPSR, t, arg); break;\n+\t      case  7: UNW_DEC_REG_WHEN(P8, UNW_REG_BSP, t, arg); break;\n+\t      case  8: UNW_DEC_REG_PSPREL(P8, UNW_REG_BSP, t, arg); break;\n+\t      case  9: UNW_DEC_REG_SPREL(P8, UNW_REG_BSP, t, arg); break;\n+\t      case 10: UNW_DEC_REG_WHEN(P8, UNW_REG_BSPSTORE, t, arg); break;\n+\t      case 11: UNW_DEC_REG_PSPREL(P8, UNW_REG_BSPSTORE, t, arg); break;\n+\t      case 12: UNW_DEC_REG_SPREL(P8, UNW_REG_BSPSTORE, t, arg); break;\n+\t      case 13: UNW_DEC_REG_WHEN(P8, UNW_REG_RNAT, t, arg); break;\n+\t      case 14: UNW_DEC_REG_PSPREL(P8, UNW_REG_RNAT, t, arg); break;\n+\t      case 15: UNW_DEC_REG_SPREL(P8, UNW_REG_RNAT, t, arg); break;\n+\t      case 16: UNW_DEC_PRIUNAT_WHEN_GR(P8, t, arg); break;\n+\t      case 17: UNW_DEC_PRIUNAT_PSPREL(P8, t, arg); break;\n+\t      case 18: UNW_DEC_PRIUNAT_SPREL(P8, t, arg); break;\n+\t      case 19: UNW_DEC_PRIUNAT_WHEN_MEM(P8, t, arg); break;\n+\t      default: UNW_DEC_BAD_CODE(r); break;\n+\t    }\n+\t  }\n+\t  break;\n+\n+\tcase 0x1:\n+\t  byte1 = *dp++; byte2 = *dp++;\n+\t  UNW_DEC_GR_GR(P9, (byte1 & 0xf), (byte2 & 0x7f), arg);\n+\t  break;\n+\n+\tcase 0xf: /* p10 */\n+\t  byte1 = *dp++; byte2 = *dp++;\n+\t  UNW_DEC_ABI(P10, byte1, byte2, arg);\n+\t  break;\n+\n+\tcase 0x9:\n+\t  return unw_decode_x1 (dp, code, arg);\n+\n+\tcase 0xa:\n+\t  return unw_decode_x2 (dp, code, arg);\n+\n+\tcase 0xb:\n+\t  return unw_decode_x3 (dp, code, arg);\n+\n+\tcase 0xc:\n+\t  return unw_decode_x4 (dp, code, arg);\n+\n+\tdefault:\n+\t  UNW_DEC_BAD_CODE(code);\n+\t  break;\n+\t}\n+    }\n+  return dp;\n+}\n+\n+static unsigned char *\n+unw_decode_b1 (unsigned char *dp, unsigned char code, void *arg)\n+{\n+  unw_word label = (code & 0x1f);\n+\n+  if ((code & 0x20) != 0)\n+    UNW_DEC_COPY_STATE(B1, label, arg);\n+  else\n+    UNW_DEC_LABEL_STATE(B1, label, arg);\n+  return dp;\n+}\n+\n+static unsigned char *\n+unw_decode_b2 (unsigned char *dp, unsigned char code, void *arg)\n+{\n+  unw_word t;\n+\n+  t = unw_decode_uleb128 (&dp);\n+  UNW_DEC_EPILOGUE(B2, t, (code & 0x1f), arg);\n+  return dp;\n+}\n+\n+static unsigned char *\n+unw_decode_b3_x4 (unsigned char *dp, unsigned char code, void *arg)\n+{\n+  unw_word t, ecount, label;\n+\n+  if ((code & 0x10) == 0)\n+    {\n+      t = unw_decode_uleb128 (&dp);\n+      ecount = unw_decode_uleb128 (&dp);\n+      UNW_DEC_EPILOGUE(B3, t, ecount, arg);\n+    }\n+  else if ((code & 0x07) == 0)\n+    {\n+      label = unw_decode_uleb128 (&dp);\n+      if ((code & 0x08) != 0)\n+\tUNW_DEC_COPY_STATE(B4, label, arg);\n+      else\n+\tUNW_DEC_LABEL_STATE(B4, label, arg);\n+    }\n+  else\n+    switch (code & 0x7)\n+      {\n+      case 1: return unw_decode_x1 (dp, code, arg);\n+      case 2: return unw_decode_x2 (dp, code, arg);\n+      case 3: return unw_decode_x3 (dp, code, arg);\n+      case 4: return unw_decode_x4 (dp, code, arg);\n+      default: UNW_DEC_BAD_CODE(code); break;\n+      }\n+  return dp;\n+}\n+\n+typedef unsigned char *(*unw_decoder) (unsigned char *, unsigned char, void *);\n+\n+static unw_decoder unw_decode_table[2][8] =\n+{\n+  /* prologue table: */\n+  {\n+    unw_decode_r1,\t/* 0 */\n+    unw_decode_r1,\n+    unw_decode_r2,\n+    unw_decode_r3,\n+    unw_decode_p1,\t/* 4 */\n+    unw_decode_p2_p5,\n+    unw_decode_p6,\n+    unw_decode_p7_p10\n+  },\n+  {\n+    unw_decode_r1,\t/* 0 */\n+    unw_decode_r1,\n+    unw_decode_r2,\n+    unw_decode_r3,\n+    unw_decode_b1,\t/* 4 */\n+    unw_decode_b1,\n+    unw_decode_b2,\n+    unw_decode_b3_x4\n+  }\n+};\n+\n+/*\n+ * Decode one descriptor and return address of next descriptor.\n+ */\n+static inline unsigned char *\n+unw_decode (unsigned char *dp, int inside_body, void *arg)\n+{\n+  unw_decoder decoder;\n+  unsigned char code;\n+\n+  code = *dp++;\n+  decoder = unw_decode_table[inside_body][code >> 5];\n+  dp = (*decoder) (dp, code, arg);\n+  return dp;\n+}\n+\n+\f\n+/* RSE helper functions.  */\n+\n+static inline unsigned long\n+ia64_rse_slot_num (unsigned long *addr)\n+{\n+  return (((unsigned long) addr) >> 3) & 0x3f;\n+}\n+\n+/* Return TRUE if ADDR is the address of an RNAT slot.  */\n+static inline unsigned long\n+ia64_rse_is_rnat_slot (unsigned long *addr)\n+{\n+  return ia64_rse_slot_num (addr) == 0x3f;\n+}\n+\n+/* Returns the address of the RNAT slot that covers the slot at\n+   address SLOT_ADDR.  */\n+static inline unsigned long *\n+ia64_rse_rnat_addr (unsigned long *slot_addr)\n+{\n+  return (unsigned long *) ((unsigned long) slot_addr | (0x3f << 3));\n+}\n+\n+/* Calcuate the number of registers in the dirty partition starting at\n+   BSPSTORE with a size of DIRTY bytes.  This isn't simply DIRTY\n+   divided by eight because the 64th slot is used to store ar.rnat.  */\n+static inline unsigned long\n+ia64_rse_num_regs (unsigned long *bspstore, unsigned long *bsp)\n+{\n+  unsigned long slots = (bsp - bspstore);\n+\n+  return slots - (ia64_rse_slot_num (bspstore) + slots)/0x40;\n+}\n+\n+/* The inverse of the above: given bspstore and the number of\n+   registers, calculate ar.bsp.  */\n+static inline unsigned long *\n+ia64_rse_skip_regs (unsigned long *addr, long num_regs)\n+{\n+  long delta = ia64_rse_slot_num (addr) + num_regs;\n+\n+  if (num_regs < 0)\n+    delta -= 0x3e;\n+  return addr + num_regs + delta/0x3f;\n+}\n+\n+\f\n+/* Unwind accessors.  */\n+\n+static void\n+unw_access_gr (struct _Unwind_Context *info, int regnum,\n+\t       unsigned long *val, char *nat, int write)\n+{\n+  unsigned long *addr, *nat_addr = 0, nat_mask = 0, dummy_nat;\n+  struct unw_ireg *ireg;\n+\n+  if ((unsigned) regnum - 1 >= 127)\n+    abort ();\n+\n+  if (regnum < 1)\n+    {\n+      nat_addr = addr = &dummy_nat;\n+      dummy_nat = 0;\n+    }\n+  else if (regnum < 32)\n+    {\n+      /* Access a non-stacked register.  */\n+      ireg = &info->ireg[regnum - 1];\n+      addr = ireg->loc;\n+      if (addr)\n+\t{\n+\t  nat_addr = addr + ireg->nat.off;\n+\t  switch (ireg->nat.type)\n+\t    {\n+\t    case UNW_NAT_VAL:\n+\t      /* Simulate getf.sig/setf.sig.  */\n+\t      if (write)\n+\t\t{\n+\t\t  if (*nat)\n+\t\t    {\n+\t\t      /* Write NaTVal and be done with it.  */\n+\t\t      addr[0] = 0;\n+\t\t      addr[1] = 0x1fffe;\n+\t\t      return;\n+\t\t    }\n+\t\t  addr[1] = 0x1003e;\n+\t\t}\n+\t      else if (addr[0] == 0 && addr[1] == 0x1ffe)\n+\t\t{\n+\t\t  /* Return NaT and be done with it.  */\n+\t\t  *val = 0;\n+\t\t  *nat = 1;\n+\t\t  return;\n+\t\t}\n+\t      /* FALLTHRU */\n+\n+\t    case UNW_NAT_NONE:\n+\t      dummy_nat = 0;\n+\t      nat_addr = &dummy_nat;\n+\t      break;\n+\n+\t    case UNW_NAT_MEMSTK:\n+\t      nat_mask = 1UL << ((long) addr & 0x1f8)/8;\n+\t      break;\n+\n+\t    case UNW_NAT_REGSTK:\n+\t      nat_addr = ia64_rse_rnat_addr (addr);\n+\t      if ((unsigned long) nat_addr >= info->regstk_top)\n+\t\tnat_addr = &info->rnat;\n+\t      nat_mask = 1UL << ia64_rse_slot_num (addr);\n+\t      break;\n+\t    }\n+\t}\n+    }\n+  else\n+    {\n+      /* Access a stacked register.  */\n+      addr = ia64_rse_skip_regs ((unsigned long *) info->bsp, regnum - 32);\n+      nat_addr = ia64_rse_rnat_addr (addr);\n+      if ((unsigned long) nat_addr >= info->regstk_top)\n+\tnat_addr = &info->rnat;\n+      nat_mask = 1UL << ia64_rse_slot_num (addr);\n+    }\n+\n+  if (write)\n+    {\n+      *addr = *val;\n+      if (*nat)\n+\t*nat_addr |= nat_mask;\n+      else\n+\t*nat_addr &= ~nat_mask;\n+    }\n+  else\n+    {\n+      *val = *addr;\n+      *nat = (*nat_addr & nat_mask) != 0;\n+    }\n+}\n+\f\n+/* Get the value of register REG as saved in CONTEXT.  */\n+\n+_Unwind_Word\n+_Unwind_GetGR (struct _Unwind_Context *context, int index)\n+{\n+  _Unwind_Word ret;\n+  char nat;\n+\n+  if (index == 1)\n+    return context->gp;\n+  else if (index >= 15 && index <= 18)\n+    return context->eh_data[index - 15];\n+  else\n+    unw_access_gr (context, index, &ret, &nat, 0);\n+\n+  return ret;\n+}\n+\n+/* Overwrite the saved value for register REG in CONTEXT with VAL.  */\n+\n+void\n+_Unwind_SetGR (struct _Unwind_Context *context, int index, _Unwind_Word val)\n+{\n+  char nat = 0;\n+\n+  if (index == 1)\n+    context->gp = val;\n+  else if (index >= 15 && index <= 18)\n+    context->eh_data[index - 15] = val;\n+  else\n+    unw_access_gr (context, index, &val, &nat, 1);\n+}\n+\n+/* Retrieve the return address for CONTEXT.  */\n+\n+inline _Unwind_Ptr\n+_Unwind_GetIP (struct _Unwind_Context *context)\n+{\n+  return context->rp;\n+}\n+\n+/* Overwrite the return address for CONTEXT with VAL.  */\n+\n+inline void\n+_Unwind_SetIP (struct _Unwind_Context *context, _Unwind_Ptr val)\n+{\n+  context->rp = val;\n+}\n+\n+void *\n+_Unwind_GetLanguageSpecificData (struct _Unwind_Context *context)\n+{\n+  return context->lsda;\n+}\n+\n+_Unwind_Ptr\n+_Unwind_GetRegionStart (struct _Unwind_Context *context)\n+{\n+  return context->region_start;\n+}\n+\n+\f\n+static _Unwind_Reason_Code\n+uw_frame_state_for (struct _Unwind_Context *context, _Unwind_FrameState *fs)\n+{\n+  struct unw_table_entry *ent;\n+  unsigned long *unw, header, length;\n+  unsigned char *insn, *insn_end;\n+  unsigned long segment_base;\n+\n+  memset (fs, 0, sizeof (*fs));\n+  context->lsda = 0;\n+\n+  ent = _Unwind_FindTableEntry ((void *) context->rp,\n+\t\t\t\t&segment_base, &context->gp);\n+  if (ent == NULL)\n+    {\n+      /* Couldn't find unwind info for this function.  Try an\n+\t os-specific fallback mechanism.  This will necessarily\n+\t not profide a personality routine or LSDA.  */\n+#ifdef MD_FALLBACK_FRAME_STATE_FOR\n+      MD_FALLBACK_FRAME_STATE_FOR (context, fs, success);\n+      return _URC_END_OF_STACK;\n+    success:\n+      return _URC_NO_REASON;\n+#else\n+      return _URC_END_OF_STACK;\n+#endif\n+    }\n+\n+  context->region_start = ent->start_offset + segment_base;\n+  fs->when_target = (context->rp - context->region_start) / 16 * 3;\n+\n+  unw = (unsigned long *) (ent->info_offset + segment_base);\n+  header = *unw;\n+  length = UNW_LENGTH (header);\n+\n+  /* ??? Perhaps check UNW_VER / UNW_FLAG_OSMASK.  */\n+\n+  if (UNW_FLAG_EHANDLER (header) | UNW_FLAG_UHANDLER (header))\n+    {\n+      fs->personality =\n+\t*(_Unwind_Personality_Fn *) (unw[length + 1] + context->gp);\n+      context->lsda = unw + length + 2;\n+    }\n+\n+  insn = (unsigned char *) (unw + 1);\n+  insn_end = (unsigned char *) (unw + 1 + length);\n+  while (!fs->done && insn < insn_end)\n+    insn = unw_decode (insn, fs->in_body, fs);\n+\n+  /* If we're in the epilogue, sp has been restored and all values\n+     on the memory stack below psp also have been restored.  */\n+  if (fs->when_target > fs->epilogue_start)\n+    {\n+      struct unw_reg_info *r;\n+\n+      fs->curr.reg[UNW_REG_PSP].where = UNW_WHERE_NONE;\n+      fs->curr.reg[UNW_REG_PSP].val = 0;\n+      for (r = fs->curr.reg; r < fs->curr.reg + UNW_NUM_REGS; ++r)\n+\tif ((r->where == UNW_WHERE_PSPREL && r->val <= 0x10)\n+\t    || r->where == UNW_WHERE_SPREL)\n+\t  r->where = UNW_WHERE_NONE;\n+    }\n+\n+  /* If RP did't get saved, generate entry for the return link register.  */\n+  if (fs->curr.reg[UNW_REG_RP].when >= fs->when_target)\n+    {\n+      fs->curr.reg[UNW_REG_RP].where = UNW_WHERE_BR;\n+      fs->curr.reg[UNW_REG_RP].when = -1;\n+      fs->curr.reg[UNW_REG_RP].val = fs->return_link_reg;\n+    }\n+\n+  return _URC_NO_REASON;\n+}\n+\n+static void\n+uw_update_reg_address (struct _Unwind_Context *context,\n+\t\t       _Unwind_FrameState *fs,\n+\t\t       enum unw_register_index regno)\n+{\n+  struct unw_reg_info *r = fs->curr.reg + regno;\n+  void *addr;\n+  unsigned long rval;\n+\n+  if (r->where == UNW_WHERE_NONE || r->when >= fs->when_target)\n+    return;\n+\n+  rval = r->val;\n+  switch (r->where)\n+    {\n+    case UNW_WHERE_GR:\n+      if (rval >= 32)\n+\taddr = ia64_rse_skip_regs ((unsigned long *) context->bsp, rval - 32);\n+      else if (rval >= 2)\n+\taddr = context->ireg[rval - 2].loc;\n+      else\n+\tabort ();\n+      break;\n+\n+    case UNW_WHERE_FR:\n+      if (rval >= 2 && rval < 32)\n+\taddr = context->fr_loc[rval - 2];\n+      else\n+\tabort ();\n+      break;\n+\n+    case UNW_WHERE_BR:\n+      if (rval >= 1 && rval <= 5)\n+\taddr = context->br_loc[rval - 1];\n+      else\n+\tabort ();\n+      break;\n+\n+    case UNW_WHERE_SPREL:\n+      addr = (void *)(context->sp + rval);\n+      break;\n+\n+    case UNW_WHERE_PSPREL:\n+      addr = (void *)(context->psp + rval);\n+      break;\n+\n+    default:\n+      abort ();\n+    }\n+\n+  switch (regno)\n+    {\n+    case UNW_REG_R2 ... UNW_REG_R31:\n+      context->ireg[regno - UNW_REG_R2].loc = addr;\n+      switch (r->where)\n+      {\n+      case UNW_WHERE_GR:\n+\tif (rval >= 32)\n+\t  {\n+\t    context->ireg[regno - UNW_REG_R2].nat.type = UNW_NAT_MEMSTK;\n+\t    context->ireg[regno - UNW_REG_R2].nat.off\n+\t      = context->pri_unat_loc - (unsigned long *) addr;\n+\t  }\n+\telse if (rval >= 2)\n+\t  {\n+\t    context->ireg[regno - UNW_REG_R2].nat\n+\t      = context->ireg[rval - 2].nat;\n+\t  }\n+\telse\n+\t  abort ();\n+\tbreak;\n+\n+      case UNW_WHERE_FR:\n+\tcontext->ireg[regno - UNW_REG_R2].nat.type = UNW_NAT_VAL;\n+\tcontext->ireg[regno - UNW_REG_R2].nat.off = 0;\n+\tbreak;\n+\n+      case UNW_WHERE_BR:\n+\tcontext->ireg[regno - UNW_REG_R2].nat.type = UNW_NAT_NONE;\n+\tcontext->ireg[regno - UNW_REG_R2].nat.off = 0;\n+\tbreak;\n+\n+      case UNW_WHERE_PSPREL:\n+      case UNW_WHERE_SPREL:\n+\tcontext->ireg[regno - UNW_REG_R2].nat.type = UNW_NAT_MEMSTK;\n+\tcontext->ireg[regno - UNW_REG_R2].nat.off\n+\t  = context->pri_unat_loc - (unsigned long *) addr;\n+\tbreak;\n+\n+      default:\n+\tabort ();\n+      }\n+      break;\n+\n+    case UNW_REG_F2 ... UNW_REG_F31:\n+      context->fr_loc[regno - UNW_REG_F2] = addr;\n+      break;\n+\n+    case UNW_REG_B1 ... UNW_REG_B5:\n+      context->br_loc[regno - UNW_REG_B1] = addr;\n+      break;\n+\n+    case UNW_REG_BSP:\n+      context->bsp_loc = addr;\n+      break;\n+    case UNW_REG_BSPSTORE:\n+      context->bspstore_loc = addr;\n+      break;\n+    case UNW_REG_PFS:\n+      context->pfs_loc = addr;\n+      break;\n+    case UNW_REG_RP:\n+      context->rp = *(unsigned long *)addr;\n+      break;\n+    case UNW_REG_UNAT:\n+      context->unat_loc = addr;\n+      break;\n+    case UNW_REG_PR:\n+      context->pr = *(unsigned long *) addr;\n+      break;\n+    case UNW_REG_LC:\n+      context->lc_loc = addr;\n+      break;\n+    case UNW_REG_FPSR:\n+      context->fpsr_loc = addr;\n+      break;\n+\n+    case UNW_REG_PSP:\n+      context->psp = *(unsigned long *)addr;\n+      break;\n+\n+    case UNW_REG_RNAT:\n+    case UNW_NUM_REGS:\n+      abort ();\n+    }\n+}\n+\n+static void\n+uw_update_context (struct _Unwind_Context *context, _Unwind_FrameState *fs)\n+{\n+  long i;\n+\n+  context->sp = context->psp;\n+\n+  /* First, set PSP.  Subsequent instructions may depend on this value.  */\n+  if (fs->when_target > fs->curr.reg[UNW_REG_PSP].when)\n+    {\n+      if (fs->curr.reg[UNW_REG_PSP].where == UNW_WHERE_NONE)\n+\tcontext->psp = context->psp + fs->curr.reg[UNW_REG_PSP].val;\n+      else\n+\tuw_update_reg_address (context, fs, UNW_REG_PSP);\n+    }\n+\n+  /* Determine the location of the primary UNaT.  */\n+  {\n+    int i;\n+    if (fs->when_target < fs->curr.reg[UNW_REG_PRI_UNAT_GR].when)\n+      i = UNW_REG_PRI_UNAT_MEM;\n+    else if (fs->when_target < fs->curr.reg[UNW_REG_PRI_UNAT_MEM].when)\n+      i = UNW_REG_PRI_UNAT_GR;\n+    else if (fs->curr.reg[UNW_REG_PRI_UNAT_MEM].when\n+\t     > fs->curr.reg[UNW_REG_PRI_UNAT_GR].when)\n+      i = UNW_REG_PRI_UNAT_MEM;\n+    else\n+      i = UNW_REG_PRI_UNAT_GR;\n+    uw_update_reg_address (context, fs, i);\n+  }\n+\n+  /* Compute the addresses of all registers saved in this frame.  */\n+  for (i = UNW_REG_BSP; i < UNW_NUM_REGS; ++i)\n+    uw_update_reg_address (context, fs, i);\n+\n+  /* Unwind BSP for the local registers allocated this frame.  */\n+  /* ??? What to do with stored BSP or BSPSTORE registers.  */\n+  if (fs->when_target > fs->curr.reg[UNW_REG_PFS].when)\n+    {\n+      unsigned long pfs = *context->pfs_loc;\n+      unsigned long sol = (pfs >> 7) & 0x7f;\n+      context->bsp = (unsigned long)\n+\tia64_rse_skip_regs ((unsigned long *) context->bsp, -sol);\n+    }\n+}\n+\n+/* Fill in CONTEXT for top-of-stack.  The only valid registers at this\n+   level will be the return address and the CFA.  */\n+   \n+#define uw_init_context(CONTEXT) \\\n+  uw_init_context_1 (CONTEXT, __builtin_dwarf_cfa (), __builtin_ia64_bsp ())\n+\n+static void\n+uw_init_context_1 (struct _Unwind_Context *context, void *psp, void *bsp)\n+{\n+  void *rp = __builtin_extract_return_addr (__builtin_return_address (0));\n+  void *sp = __builtin_dwarf_cfa ();\n+  _Unwind_FrameState fs;\n+\n+  /* Flush the register stack to memory so that we can access it.  */\n+  __builtin_ia64_flushrs ();\n+\n+  memset (context, 0, sizeof (struct _Unwind_Context));\n+  context->bsp = (unsigned long) bsp;\n+  context->sp = (unsigned long) sp;\n+  context->psp = (unsigned long) psp;\n+  context->rp = (unsigned long) rp;\n+\n+  asm (\"mov %0 = pr\" : \"=r\" (context->pr));\n+  /* ??? Get rnat.  Don't we have to turn off the rse for that?  */\n+\n+  if (uw_frame_state_for (context, &fs) != _URC_NO_REASON)\n+    abort ();\n+\n+  /* Force the frame state to use the known cfa value.  */\n+  fs.curr.reg[UNW_REG_PSP].when = -1;\n+  fs.curr.reg[UNW_REG_PSP].where = UNW_WHERE_NONE;\n+  fs.curr.reg[UNW_REG_PSP].val = sp - psp;\n+\n+  uw_update_context (context, &fs);\n+}\n+\n+/* Install (ie longjmp to) the contents of TARGET.  */\n+\n+static void __attribute__((noreturn))\n+uw_install_context (struct _Unwind_Context *current __attribute__((unused)),\n+\t\t    struct _Unwind_Context *target)\n+{\n+  unsigned long ireg_buf[4], ireg_nat = 0, ireg_pr = 0;\n+  long i;\n+\n+  /* Copy integer register data from the target context to a\n+     temporary buffer.  Do this so that we can frob AR.UNAT\n+     to get the NaT bits for these registers set properly.  */\n+  for (i = 4; i <= 7; ++i)\n+    {\n+      char nat;\n+      void *t = target->ireg[i - 2].loc;\n+      if (t)\n+\t{\n+\t  unw_access_gr (target, i, &ireg_buf[i - 4], &nat, 0);\n+          ireg_nat |= (long)nat << (((size_t)&ireg_buf[i - 4] >> 3) & 0x3f);\n+\t  /* Set p6 - p9.  */\n+\t  ireg_pr |= 4L << i;\n+\t}\n+    }\n+\n+  /* The value in uc_bsp that we've computed is that for the \n+     target function.  The value that we install below will be\n+     adjusted by the BR.RET instruction based on the contents\n+     of AR.PFS.  So we must unadjust that here.  */\n+  target->bsp\n+    = ia64_rse_skip_regs (target->bsp, (*target->pfs_loc >> 7) & 0x7f);\n+\n+  /* Provide assembly with the offsets into the _Unwind_Context.  */\n+  asm volatile (\"uc_rnat = %0\"\n+\t\t: : \"i\"(offsetof (struct _Unwind_Context, rnat)));\n+  asm volatile (\"uc_bsp = %0\"\n+\t\t: : \"i\"(offsetof (struct _Unwind_Context, bsp)));\n+  asm volatile (\"uc_psp = %0\"\n+\t\t: : \"i\"(offsetof (struct _Unwind_Context, psp)));\n+  asm volatile (\"uc_rp = %0\"\n+\t\t: : \"i\"(offsetof (struct _Unwind_Context, rp)));\n+  asm volatile (\"uc_pr = %0\"\n+\t\t: : \"i\"(offsetof (struct _Unwind_Context, pr)));\n+  asm volatile (\"uc_gp = %0\"\n+\t\t: : \"i\"(offsetof (struct _Unwind_Context, gp)));\n+  asm volatile (\"uc_pfs_loc = %0\"\n+\t\t: : \"i\"(offsetof (struct _Unwind_Context, pfs_loc)));\n+  asm volatile (\"uc_unat_loc = %0\"\n+\t\t: : \"i\"(offsetof (struct _Unwind_Context, unat_loc)));\n+  asm volatile (\"uc_lc_loc = %0\"\n+\t\t: : \"i\"(offsetof (struct _Unwind_Context, lc_loc)));\n+  asm volatile (\"uc_fpsr_loc = %0\"\n+\t\t: : \"i\"(offsetof (struct _Unwind_Context, fpsr_loc)));\n+  asm volatile (\"uc_eh_data = %0\"\n+\t\t: : \"i\"(offsetof (struct _Unwind_Context, eh_data)));\n+  asm volatile (\"uc_br_loc = %0\"\n+\t\t: : \"i\"(offsetof (struct _Unwind_Context, br_loc)));\n+  asm volatile (\"uc_fr_loc = %0\"\n+\t\t: : \"i\"(offsetof (struct _Unwind_Context, fr_loc)));\n+\n+  asm volatile (\n+\t/* Load up call-saved non-window integer registers from ireg_buf.  */\n+\t\"add r20 = 8, %1\t\t\t\\n\\t\"\n+\t\"mov ar.unat = %2\t\t\t\\n\\t\"\n+\t\"mov pr = %3, 0x3c0\t\t\t\\n\\t\"\n+\t\";;\t\t\t\t\t\\n\\t\"\n+\t\"(p6) ld8.fill r4 = [%1]\t\t\\n\\t\"\n+\t\"(p7) ld8.fill r5 = [r20]\t\t\\n\\t\"\n+\t\"add r21 = uc_br_loc + 8, %0\t\t\\n\\t\"\n+\t\"adds %1 = 16, %1\t\t\t\\n\\t\"\n+\t\"adds r20 = 16, r20\t\t\t\\n\\t\"\n+\t\";;\t\t\t\t\t\\n\\t\"\n+\t\"(p8) ld8.fill r6 = [%1]\t\t\\n\\t\"\n+\t\"(p9) ld8.fill r7 = [r20]\t\t\\n\\t\"\n+\t\"add r20 = uc_br_loc, %0\t\t\\n\\t\"\n+\t\";;\t\t\t\t\t\\n\\t\"\n+\t/* Load up call-saved branch registers.  */\n+\t\"ld8 r22 = [r20], 16\t\t\t\\n\\t\"\n+\t\"ld8 r23 = [r21], 16\t\t\t\\n\\t\"\n+\t\";;\t\t\t\t\t\\n\\t\"\n+\t\"ld8 r24 = [r20], 16\t\t\t\\n\\t\"\n+\t\"ld8 r25 = [r21], uc_fr_loc - (uc_br_loc + 24)\\n\\t\"\n+\t\";;\t\t\t\t\t\\n\\t\"\n+\t\"ld8 r26 = [r20], uc_fr_loc + 8 - (uc_br_loc + 32)\\n\\t\"\n+\t\"ld8 r27 = [r21], 24\t\t\t\\n\\t\"\n+\t\"cmp.ne p6, p0 = r0, r22\t\t\\n\\t\"\n+\t\";;\t\t\t\t\t\\n\\t\"\n+\t\"ld8 r28 = [r20], 8\t\t\t\\n\\t\"\n+\t\"(p6) ld8 r22 = [r22]\t\t\t\\n\\t\"\n+\t\"cmp.ne p7, p0 = r0, r23\t\t\\n\\t\"\n+\t\";;\t\t\t\t\t\\n\\t\"\n+\t\"(p7) ld8 r23 = [r23]\t\t\t\\n\\t\"\n+\t\"cmp.ne p8, p0 = r0, r24\t\t\\n\\t\"\n+\t\";;\t\t\t\t\t\\n\\t\"\n+\t\"(p8) ld8 r24 = [r24]\t\t\t\\n\\t\"\n+\t\"(p6) mov b1 = r22\t\t\t\\n\\t\"\n+\t\"cmp.ne p9, p0 = r0, r25\t\t\\n\\t\"\n+\t\";;\t\t\t\t\t\\n\\t\"\n+\t\"(p9) ld8 r25 = [r25]\t\t\t\\n\\t\"\n+\t\"(p7) mov b2 = r23\t\t\t\\n\\t\"\n+\t\"cmp.ne p6, p0 = r0, r26\t\t\\n\\t\"\n+\t\";;\t\t\t\t\t\\n\\t\"\n+\t\"(p6) ld8 r26 = [r26]\t\t\t\\n\\t\"\n+\t\"(p8) mov b3 = r24\t\t\t\\n\\t\"\n+\t\"cmp.ne p7, p0 = r0, r27\t\t\\n\\t\"\n+\t\";;\t\t\t\t\t\\n\\t\"\n+\t/* Load up call-saved fp registers.  */\n+\t\"(p7) ldf.fill f2 = [r27]\t\t\\n\\t\"\n+\t\"(p9) mov b4 = r25\t\t\t\\n\\t\"\n+\t\"cmp.ne p8, p0 = r0, r28\t\t\\n\\t\"\n+\t\";;\t\t\t\t\t\\n\\t\"\n+\t\"(p8) ldf.fill f3 = [r28]\t\t\\n\\t\"\n+\t\"(p6) mov b5 = r26\t\t\t\\n\\t\"\n+\t\";;\t\t\t\t\t\\n\\t\"\n+\t\"ld8 r29 = [r20], 16*8 - 4*8\t\t\\n\\t\"\n+\t\"ld8 r30 = [r21], 17*8 - 5*8\t\t\\n\\t\"\n+\t\";;\t\t\t\t\t\\n\\t\"\n+\t\"ld8 r22 = [r20], 16\t\t\t\\n\\t\"\n+\t\"ld8 r23 = [r21], 16\t\t\t\\n\\t\"\n+\t\";;\t\t\t\t\t\\n\\t\"\n+\t\"ld8 r24 = [r20], 16\t\t\t\\n\\t\"\n+\t\"ld8 r25 = [r21]\t\t\t\\n\\t\"\n+\t\"cmp.ne p6, p0 = r0, r29\t\t\\n\\t\"\n+\t\";;\t\t\t\t\t\\n\\t\"\n+\t\"ld8 r26 = [r20], 8\t\t\t\\n\\t\"\n+\t\"(p6) ldf.fill f4 = [r29]\t\t\\n\\t\"\n+\t\"cmp.ne p7, p0 = r0, r30\t\t\\n\\t\"\n+\t\";;\t\t\t\t\t\\n\\t\"\n+\t\"ld8 r27 = [r20], 8\t\t\t\\n\\t\"\n+\t\"(p7) ldf.fill f5 = [r30]\t\t\\n\\t\"\n+\t\"cmp.ne p6, p0 = r0, r22\t\t\\n\\t\"\n+\t\";;\t\t\t\t\t\\n\\t\"\n+\t\"ld8 r28 = [r20], 8\t\t\t\\n\\t\"\n+\t\"(p6) ldf.fill f16 = [r22]\t\t\\n\\t\"\n+\t\"cmp.ne p7, p0 = r0, r23\t\t\\n\\t\"\n+\t\";;\t\t\t\t\t\\n\\t\"\n+\t\"ld8 r29 = [r20], 8\t\t\t\\n\\t\"\n+\t\"(p7) ldf.fill f17 = [r23]\t\t\\n\\t\"\n+\t\"cmp.ne p6, p0 = r0, r24\t\t\\n\\t\"\n+\t\";;\t\t\t\t\t\\n\\t\"\n+\t\"ld8 r22 = [r20], 8\t\t\t\\n\\t\"\n+\t\"(p6) ldf.fill f18 = [r24]\t\t\\n\\t\"\n+\t\"cmp.ne p7, p0 = r0, r25\t\t\\n\\t\"\n+\t\";;\t\t\t\t\t\\n\\t\"\n+\t\"ld8 r23 = [r20], 8\t\t\t\\n\\t\"\n+\t\"(p7) ldf.fill f19 = [r25]\t\t\\n\\t\"\n+\t\"cmp.ne p6, p0 = r0, r26\t\t\\n\\t\"\n+\t\";;\t\t\t\t\t\\n\\t\"\n+\t\"ld8 r24 = [r20], 8\t\t\t\\n\\t\"\n+\t\"(p6) ldf.fill f20 = [r26]\t\t\\n\\t\"\n+\t\"cmp.ne p7, p0 = r0, r27\t\t\\n\\t\"\n+\t\";;\t\t\t\t\t\\n\\t\"\n+\t\"ld8 r25 = [r20], 8\t\t\t\\n\\t\"\n+\t\"(p7) ldf.fill f21 = [r27]\t\t\\n\\t\"\n+\t\"cmp.ne p6, p0 = r0, r28\t\t\\n\\t\"\n+\t\";;\t\t\t\t\t\\n\\t\"\n+\t\"ld8 r26 = [r20], 8\t\t\t\\n\\t\"\n+\t\"(p6) ldf.fill f22 = [r28]\t\t\\n\\t\"\n+\t\"cmp.ne p7, p0 = r0, r29\t\t\\n\\t\"\n+\t\";;\t\t\t\t\t\\n\\t\"\n+\t\"ld8 r28 = [r20], 8\t\t\t\\n\\t\"\n+\t\"(p7) ldf.fill f23 = [r29]\t\t\\n\\t\"\n+\t\"cmp.ne p6, p0 = r0, r22\t\t\\n\\t\"\n+\t\";;\t\t\t\t\t\\n\\t\"\n+\t\"ld8 r29 = [r20], 8\t\t\t\\n\\t\"\n+\t\"(p6) ldf.fill f24 = [r22]\t\t\\n\\t\"\n+\t\"cmp.ne p7, p0 = r0, r23\t\t\\n\\t\"\n+\t\";;\t\t\t\t\t\\n\\t\"\n+\t\"(p7) ldf.fill f25 = [r23]\t\t\\n\\t\"\n+\t\"cmp.ne p6, p0 = r0, r24\t\t\\n\\t\"\n+\t\"cmp.ne p7, p0 = r0, r25\t\t\\n\\t\"\n+\t\";;\t\t\t\t\t\\n\\t\"\n+\t\"(p6) ldf.fill f26 = [r24]\t\t\\n\\t\"\n+\t\"(p7) ldf.fill f27 = [r25]\t\t\\n\\t\"\n+\t\"cmp.ne p6, p0 = r0, r26\t\t\\n\\t\"\n+\t\";;\t\t\t\t\t\\n\\t\"\n+\t\"(p6) ldf.fill f28 = [r26]\t\t\\n\\t\"\n+\t\"cmp.ne p7, p0 = r0, r27\t\t\\n\\t\"\n+\t\"cmp.ne p6, p0 = r0, r28\t\t\\n\\t\"\n+\t\";;\t\t\t\t\t\\n\\t\"\n+\t\"(p7) ldf.fill f29 = [r27]\t\t\\n\\t\"\n+\t\"(p6) ldf.fill f30 = [r28]\t\t\\n\\t\"\n+\t\"cmp.ne p7, p0 = r0, r29\t\t\\n\\t\"\n+\t\";;\t\t\t\t\t\\n\\t\"\n+\t\"(p7) ldf.fill f31 = [r29]\t\t\\n\\t\"\n+\t\"add r20 = uc_rnat, %0\t\t\t\\n\\t\"\n+\t\"add r21 = uc_bsp, %0\t\t\t\\n\\t\"\n+\t\";;\t\t\t\t\t\\n\\t\"\n+\t/* Load the balance of the thread state from the context.  */\n+\t\"ld8 r22 = [r20], uc_psp - uc_rnat\t\\n\\t\"\n+\t\"ld8 r23 = [r21], uc_gp - uc_bsp\t\\n\\t\"\n+\t\";;\t\t\t\t\t\\n\\t\"\n+\t\"ld8 r24 = [r20], uc_pfs_loc - uc_psp\t\\n\\t\"\n+\t\"ld8 r1 = [r21], uc_rp - uc_gp\t\t\\n\\t\"\n+\t\";;\t\t\t\t\t\\n\\t\"\n+\t\"ld8 r25 = [r20], uc_unat_loc - uc_pfs_loc\\n\\t\"\n+\t\"ld8 r26 = [r21], uc_pr - uc_rp\t\t\\n\\t\"\n+\t\";;\t\t\t\t\t\\n\\t\"\n+\t\"ld8 r27 = [r20], uc_lc_loc - uc_unat_loc\\n\\t\"\n+\t\"ld8 r28 = [r21], uc_fpsr_loc - uc_pr\t\\n\\t\"\n+\t\";;\t\t\t\t\t\\n\\t\"\n+\t\"ld8 r29 = [r20], uc_eh_data - uc_lc_loc\\n\\t\"\n+\t\"ld8 r30 = [r21], uc_eh_data + 8 - uc_fpsr_loc\\n\\t\"\n+\t\";;\t\t\t\t\t\\n\\t\"\n+\t/* Load data for the exception handler.  */\n+\t\"ld8 r15 = [r20], 16\t\t\t\\n\\t\"\n+\t\"ld8 r16 = [r21], 16\t\t\t\\n\\t\"\n+\t\";;\t\t\t\t\t\\n\\t\"\n+\t\"ld8 r17 = [r20]\t\t\t\\n\\t\"\n+\t\"ld8 r18 = [r21]\t\t\t\\n\\t\"\n+\t\";;\t\t\t\t\t\\n\\t\"\n+\t/* Install the balance of the thread state loaded above.  */\n+\t\"cmp.ne p6, p0 = r0, r25\t\t\\n\\t\"\n+\t\"cmp.ne p7, p0 = r0, r27\t\t\\n\\t\"\n+\t\";;\t\t\t\t\t\\n\\t\"\n+\t\"(p6) ld8 r25 = [r25]\t\t\t\\n\\t\"\n+\t\"(p7) ld8 r27 = [r27]\t\t\t\\n\\t\"\n+\t\";;\t\t\t\t\t\\n\\t\"\n+\t\"(p7) mov.m ar.unat = r27\t\t\\n\\t\"\n+\t\"(p6) mov.i ar.pfs = r25\t\t\\n\\t\"\n+\t\"cmp.ne p9, p0 = r0, r29\t\t\\n\\t\"\n+\t\";;\t\t\t\t\t\\n\\t\"\n+\t\"(p9) ld8 r29 = [r29]\t\t\t\\n\\t\"\n+\t\"cmp.ne p6, p0 = r0, r30\t\t\\n\\t\"\n+\t\";;\t\t\t\t\t\\n\\t\"\n+\t\"(p6) ld8 r30 = [r30]\t\t\t\\n\\t\"\n+\t/* Don't clobber p6-p9, which are in use at present.  */\n+\t\"mov pr = r28, ~0x3c0\t\t\t\\n\\t\"\n+\t\"(p9) mov.i ar.lc = r29\t\t\t\\n\\t\"\n+\t\";;\t\t\t\t\t\\n\\t\"\n+\t\"mov.m r25 = ar.rsc\t\t\t\\n\\t\"\n+\t\"(p6) mov.i ar.fpsr = r30\t\t\\n\\t\"\n+\t\";;\t\t\t\t\t\\n\\t\"\n+\t\"and r25 = 0x1c, r25\t\t\t\\n\\t\"\n+\t\"mov b0 = r26\t\t\t\t\\n\\t\"\n+\t\";;\t\t\t\t\t\\n\\t\"\n+\t\"mov.m ar.rsc = r25\t\t\t\\n\\t\"\n+\t\";;\t\t\t\t\t\\n\\t\"\n+\t/* This must be done before setting AR.BSPSTORE, otherwise \n+\t   AR.BSP will be initialized with a random displacement\n+\t   below the value we want, based on the current number of\n+\t   dirty stacked registers.  */\n+\t\"loadrs\t\t\t\t\t\\n\\t\"\n+\t\"invala\t\t\t\t\t\\n\\t\"\n+\t\";;\t\t\t\t\t\\n\\t\"\n+\t\"mov.m ar.bspstore = r23\t\t\\n\\t\"\n+\t\";;\t\t\t\t\t\\n\\t\"\n+\t\"or r25 = 0x3, r25\t\t\t\\n\\t\"\n+\t\"mov.m ar.rnat = r22\t\t\t\\n\\t\"\n+\t\";;\t\t\t\t\t\\n\\t\"\n+\t\"mov.m ar.rsc = r25\t\t\t\\n\\t\"\n+\t\"mov sp = r24\t\t\t\t\\n\\t\"\n+\t\"br.ret.sptk.few b0\"\n+\t: : \"r\"(target), \"r\"(ireg_buf), \"r\"(ireg_nat), \"r\"(ireg_pr)\n+\t: \"r15\", \"r16\", \"r17\", \"r18\", \"r20\", \"r21\", \"r22\",\n+\t  \"r23\", \"r24\", \"r25\", \"r26\", \"r27\", \"r28\", \"r29\",\n+\t  \"r30\", \"r31\");\n+  /* NOTREACHED */\n+  while (1);\n+}\n+\n+static inline _Unwind_Ptr\n+uw_identify_context (struct _Unwind_Context *context)\n+{\n+  return _Unwind_GetIP (context);\n+}\n+\n+#include \"unwind.inc\"\n+#endif"}, {"sha": "a6b850df80a8af6d7c6deed5b1d635e925717dc9", "filename": "gcc/config/ia64/unwind-ia64.h", "status": "renamed", "additions": 9, "deletions": 14, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a1ee410cefc93b247bbcc9b8a153ba5af72be73/gcc%2Fconfig%2Fia64%2Funwind-ia64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a1ee410cefc93b247bbcc9b8a153ba5af72be73/gcc%2Fconfig%2Fia64%2Funwind-ia64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Funwind-ia64.h?ref=2a1ee410cefc93b247bbcc9b8a153ba5af72be73", "patch": "@@ -1,4 +1,4 @@\n-/* Copyright (C) 1999, 2000 Free Software Foundation, Inc.\n+/* Copyright (C) 1999, 2000, 2001 Free Software Foundation, Inc.\n    Contributed by Andrew MacLeod  <amacleod@cygnus.com>\n                   Andrew Haley  <aph@cygnus.com>\n \n@@ -19,18 +19,13 @@\n    the Free Software Foundation, 59 Temple Place - Suite 330,\n    Boston, MA 02111-1307, USA.  */\n \n-/* This structure represents a single unwind table entry.  We lie and say\n-   its the dwarf_fde structure to use the common object in frame.h */\n-\n-typedef struct dwarf_fde\n+struct unw_table_entry\n {\n-  long start_offset;\n-  long end_offset;\n-  long unwind_offset;\n-} unwind_table_entry;\n-  \n-/* Defining dwarf_fde allows us to use the common object registration.  */\n-typedef unwind_table_entry dwarf_fde;\n-typedef unwind_table_entry fde;\n+  unsigned long start_offset;\n+  unsigned long end_offset;\n+  unsigned long info_offset;\n+};\n \n-extern fde *__ia64_find_fde (void *, void **);\n+extern struct unw_table_entry *\n+_Unwind_FindTableEntry (void *pc, unsigned long *segment_base,\n+\t\t\tunsigned long *gp);", "previous_filename": "gcc/config/ia64/frame-ia64.h"}, {"sha": "9ec2af1a5ab82bf164dbf2c12e0a24f44dfbf959", "filename": "gcc/defaults.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a1ee410cefc93b247bbcc9b8a153ba5af72be73/gcc%2Fdefaults.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a1ee410cefc93b247bbcc9b8a153ba5af72be73/gcc%2Fdefaults.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdefaults.h?ref=2a1ee410cefc93b247bbcc9b8a153ba5af72be73", "patch": "@@ -318,5 +318,12 @@ do {\t\t\t\t\t\t\t\t\\\n #endif\n #endif\n \n+/* Select a format to encode pointers in exception handling data.  We\n+   prefer those that result in fewer dynamic relocations.  Assume no\n+   special support here and encode direct references.  */\n+#ifndef ASM_PREFERRED_EH_DATA_FORMAT\n+#define ASM_PREFERRED_EH_DATA_FORMAT(CODE,GLOBAL)  DW_EH_PE_absptr\n+#endif\n+\n #endif  /* GCC_DEFAULTS_H */\n "}, {"sha": "104879e4660256c8f6cbd06f654a0d909b2aab2d", "filename": "gcc/dwarf2asm.c", "status": "modified", "additions": 176, "deletions": 0, "changes": 176, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a1ee410cefc93b247bbcc9b8a153ba5af72be73/gcc%2Fdwarf2asm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a1ee410cefc93b247bbcc9b8a153ba5af72be73/gcc%2Fdwarf2asm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2asm.c?ref=2a1ee410cefc93b247bbcc9b8a153ba5af72be73", "patch": "@@ -22,9 +22,13 @@ Boston, MA 02111-1307, USA.  */\n #include \"config.h\"\n #include \"system.h\"\n #include \"flags.h\"\n+#include \"tree.h\"\n #include \"rtl.h\"\n #include \"output.h\"\n #include \"dwarf2asm.h\"\n+#include \"dwarf2.h\"\n+#include \"splay-tree.h\"\n+#include \"ggc.h\"\n #include \"tm_p.h\"\n \n \n@@ -647,3 +651,175 @@ dw2_asm_output_delta_sleb128 VPARAMS ((const char *lab1 ATTRIBUTE_UNUSED,\n \n   va_end (ap);\n }\n+\f\n+static rtx dw2_force_const_mem PARAMS ((rtx));\n+static int dw2_output_indirect_constant_1 PARAMS ((splay_tree_node, void *));\n+\n+static splay_tree indirect_pool;\n+\n+static rtx\n+dw2_force_const_mem (x)\n+     rtx x;\n+{\n+  splay_tree_node node;\n+  const char *const_sym;\n+\n+  if (! indirect_pool)\n+    indirect_pool = splay_tree_new (splay_tree_compare_pointers, NULL, NULL);\n+\n+  if (GET_CODE (x) != SYMBOL_REF)\n+    abort ();\n+  node = splay_tree_lookup (indirect_pool, (splay_tree_key) XSTR (x, 0));\n+  if (node)\n+    const_sym = (const char *) node->value;\n+  else\n+    {\n+      extern int const_labelno;\n+      char label[32];\n+      tree id;\n+\n+      ASM_GENERATE_INTERNAL_LABEL (label, \"LC\", const_labelno);\n+      ++const_labelno;\n+      const_sym = ggc_strdup (label);\n+\n+      id = maybe_get_identifier (XSTR (x, 0));\n+      if (id)\n+\tTREE_SYMBOL_REFERENCED (id) = 1;\n+\n+      splay_tree_insert (indirect_pool, (splay_tree_key) XSTR (x, 0),\n+\t\t\t (splay_tree_value) const_sym);\n+    }\n+\n+  return gen_rtx_SYMBOL_REF (Pmode, const_sym);\n+}\n+\n+static int\n+dw2_output_indirect_constant_1 (node, data)\n+     splay_tree_node node;\n+     void* data ATTRIBUTE_UNUSED;\n+{\n+  const char *label, *sym;\n+  rtx sym_ref;\n+\n+  label = (const char *) node->value;\n+  sym = (const char *) node->key;\n+  sym_ref = gen_rtx_SYMBOL_REF (Pmode, sym);\n+\n+  ASM_OUTPUT_LABEL (asm_out_file, label);\n+  assemble_integer (sym_ref, POINTER_SIZE / BITS_PER_UNIT, 1);\n+\n+  return 0;\n+}\n+\n+void\n+dw2_output_indirect_constants ()\n+{\n+  if (! indirect_pool)\n+    return;\n+\n+  /* Assume that the whole reason we're emitting these symbol references\n+     indirectly is that they contain dynamic relocations, and are thus\n+     read-write.  If there was no possibility of a dynamic relocation, we\n+     might as well have used a direct relocation.  */\n+  data_section ();\n+\n+  /* Everything we're emitting is a pointer.  Align appropriately.  */\n+  assemble_align (POINTER_SIZE);\n+\n+  splay_tree_foreach (indirect_pool, dw2_output_indirect_constant_1, NULL);\n+}\n+\n+void\n+dw2_asm_output_encoded_addr_rtx (encoding, addr)\n+     int encoding;\n+     rtx addr;\n+{\n+  int size;\n+\n+  switch (encoding & 0x07)\n+    {\n+    case DW_EH_PE_absptr:\n+      size = POINTER_SIZE / BITS_PER_UNIT;\n+      break;\n+    case DW_EH_PE_udata2:\n+      size = 2;\n+      break;\n+    case DW_EH_PE_udata4:\n+      size = 4;\n+      break;\n+    case DW_EH_PE_udata8:\n+      size = 8;\n+      break;\n+    default:\n+      abort ();\n+    }\n+\n+  /* NULL is _always_ represented as a plain zero.  */\n+  if (addr == const0_rtx)\n+    {\n+      assemble_integer (addr, size, 1);\n+      return;\n+    }\n+\n+ restart:\n+\n+  /* Allow the target first crack at emitting this.  Some of the\n+     special relocations require special directives instead of \n+     just \".4byte\" or whatever.  */\n+#ifdef ASM_MAYBE_OUTPUT_ENCODED_ADDR_RTX\n+  ASM_MAYBE_OUTPUT_ENCODED_ADDR_RTX(asm_out_file, encoding, size, addr, done);\n+#endif\n+\n+  /* Indirection is used to get dynamic relocations out of a read-only\n+     section.  */\n+  if (encoding & DW_EH_PE_indirect)\n+    {\n+      /* It is very tempting to use force_const_mem so that we share data\n+\t with the normal constant pool.  However, we've already emitted\n+\t the constant pool for this function.  Moreover, we'd like to share\n+\t these constants across the entire unit of translation, or better,\n+\t across the entire application (or DSO).  */\n+      addr = dw2_force_const_mem (addr);\n+      encoding &= ~DW_EH_PE_indirect;\n+      goto restart;\n+    }\n+\n+  switch (encoding & 0xF0)\n+    {\n+    case DW_EH_PE_absptr:\n+#ifdef UNALIGNED_INT_ASM_OP\n+      fputs (unaligned_integer_asm_op (size), asm_out_file);\n+      output_addr_const (asm_out_file, addr);\n+#else\n+      assemble_integer (addr, size, 1);\n+#endif\n+      break;\n+\n+    case DW_EH_PE_pcrel:\n+      if (GET_CODE (addr) != SYMBOL_REF)\n+\tabort ();\n+#ifdef ASM_OUTPUT_DWARF_PCREL\n+      ASM_OUTPUT_DWARF_PCREL (asm_out_file, size, XSTR (addr, 0));\n+#else\n+#ifdef UNALIGNED_INT_ASM_OP\n+      fputs (unaligned_integer_asm_op (size), asm_out_file);\n+      assemble_name (asm_out_file, XSTR (addr, 0));\n+      fputc ('-', asm_out_file);\n+      fputc ('.', asm_out_file);\n+#else\n+      abort ();\n+#endif\n+#endif\n+      break;\n+\n+    default:\n+      /* Other encodings should have been handled by \n+\t ASM_MAYBE_OUTPUT_ENCODED_ADDR_RTX.  */\n+      abort ();\n+    }\n+\n+#ifdef ASM_MAYBE_OUTPUT_ENCODED_ADDR_RTX\n+ done:\n+#endif\n+  fputc ('\\n', asm_out_file);\n+}"}, {"sha": "4b663c99bc07cae7c76b1b4a6e641b22c4a0e9cb", "filename": "gcc/dwarf2asm.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a1ee410cefc93b247bbcc9b8a153ba5af72be73/gcc%2Fdwarf2asm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a1ee410cefc93b247bbcc9b8a153ba5af72be73/gcc%2Fdwarf2asm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2asm.h?ref=2a1ee410cefc93b247bbcc9b8a153ba5af72be73", "patch": "@@ -48,6 +48,8 @@ extern void dw2_asm_output_addr_rtx\tPARAMS ((int, rtx,\n \t\t\t\t\t\t const char *, ...))\n      /* ATTRIBUTE_PRINTF_3 */;\n \n+extern void dw2_asm_output_encoded_addr_rtx PARAMS ((int, rtx));\n+\n extern void dw2_asm_output_nstring\tPARAMS ((const char *, size_t,\n \t\t\t\t\t\t const char *, ...))\n      /* ATTRIBUTE_PRINTF_3 */;\n@@ -70,3 +72,5 @@ extern void dw2_asm_output_delta_sleb128 PARAMS ((const char *, const char *,\n \n extern int size_of_uleb128\t\tPARAMS ((unsigned HOST_WIDE_INT));\n extern int size_of_sleb128\t\tPARAMS ((HOST_WIDE_INT));\n+\n+extern void dw2_output_indirect_constants PARAMS ((void));"}, {"sha": "db839323df84a40a41b069abb480dd2c65d1f13e", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 22, "deletions": 1, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a1ee410cefc93b247bbcc9b8a153ba5af72be73/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a1ee410cefc93b247bbcc9b8a153ba5af72be73/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=2a1ee410cefc93b247bbcc9b8a153ba5af72be73", "patch": "@@ -1904,14 +1904,35 @@ dwarf2out_begin_prologue ()\n   char label[MAX_ARTIFICIAL_LABEL_BYTES];\n   register dw_fde_ref fde;\n \n+  current_function_func_begin_label = 0;\n+\n+#ifdef IA64_UNWIND_INFO\n+  /* ??? current_function_func_begin_label is also used by except.c\n+     for call-site information.  We must emit this label if it might\n+     be used.  */\n+  if ((! flag_exceptions || USING_SJLJ_EXCEPTIONS)\n+      && ! dwarf2out_do_frame ())\n+    return;\n+#else\n+  if (! dwarf2out_do_frame ())\n+    return;\n+#endif\n+\n   ++current_funcdef_number;\n \n   function_section (current_function_decl);\n   ASM_GENERATE_INTERNAL_LABEL (label, FUNC_BEGIN_LABEL,\n \t\t\t       current_funcdef_number);\n-  ASM_OUTPUT_LABEL (asm_out_file, label);\n+  ASM_OUTPUT_DEBUG_LABEL (asm_out_file, FUNC_BEGIN_LABEL,\n+\t\t\t  current_funcdef_number);\n   current_function_func_begin_label = get_identifier (label);\n \n+#ifdef IA64_UNWIND_INFO\n+  /* We can elide the fde allocation if we're not emitting debug info.  */\n+  if (! dwarf2out_do_frame ())\n+    return;\n+#endif\n+\n   /* Expand the fde table if necessary.  */\n   if (fde_table_in_use == fde_table_allocated)\n     {"}, {"sha": "66ea787023869d8447ac437e87bfcfcc77e81ae8", "filename": "gcc/except.c", "status": "modified", "additions": 92, "deletions": 34, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a1ee410cefc93b247bbcc9b8a153ba5af72be73/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a1ee410cefc93b247bbcc9b8a153ba5af72be73/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=2a1ee410cefc93b247bbcc9b8a153ba5af72be73", "patch": "@@ -62,6 +62,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"output.h\"\n #include \"dwarf2asm.h\"\n #include \"dwarf2out.h\"\n+#include \"dwarf2.h\"\n #include \"toplev.h\"\n #include \"hashtab.h\"\n #include \"intl.h\"\n@@ -3366,24 +3367,6 @@ push_sleb128 (data_area, value)\n }\n \n \f\n-#define DW_EH_PE_absptr\t\t0x00\n-#define DW_EH_PE_omit\t\t0xff\n-\n-#define DW_EH_PE_uleb128\t0x01\n-#define DW_EH_PE_udata2\t\t0x02\n-#define DW_EH_PE_udata4\t\t0x03\n-#define DW_EH_PE_udata8\t\t0x04\n-#define DW_EH_PE_sleb128\t0x09\n-#define DW_EH_PE_sdata2\t\t0x0A\n-#define DW_EH_PE_sdata4\t\t0x0B\n-#define DW_EH_PE_sdata8\t\t0x0C\n-#define DW_EH_PE_signed\t\t0x08\n-\n-#define DW_EH_PE_pcrel\t\t0x10\n-#define DW_EH_PE_textrel\t0x20\n-#define DW_EH_PE_datarel\t0x30\n-#define DW_EH_PE_funcrel\t0x40\n-\n static const char *\n eh_data_format_name (format)\n      int format;\n@@ -3438,6 +3421,74 @@ eh_data_format_name (format)\n     case DW_EH_PE_sdata4 | DW_EH_PE_funcrel:\treturn \"funcrel sdata4\";\n     case DW_EH_PE_sdata8 | DW_EH_PE_funcrel:\treturn \"funcrel sdata8\";\n \n+    case DW_EH_PE_indirect | DW_EH_PE_uleb128 | DW_EH_PE_pcrel:\n+      return \"indirect pcrel uleb128\";\n+    case DW_EH_PE_indirect | DW_EH_PE_udata2 | DW_EH_PE_pcrel:\n+      return \"indirect pcrel udata2\";\n+    case DW_EH_PE_indirect | DW_EH_PE_udata4 | DW_EH_PE_pcrel:\n+      return \"indirect pcrel udata4\";\n+    case DW_EH_PE_indirect | DW_EH_PE_udata8 | DW_EH_PE_pcrel:\n+      return \"indirect pcrel udata8\";\n+    case DW_EH_PE_indirect | DW_EH_PE_sleb128 | DW_EH_PE_pcrel:\n+      return \"indirect pcrel sleb128\";\n+    case DW_EH_PE_indirect | DW_EH_PE_sdata2 | DW_EH_PE_pcrel:\n+      return \"indirect pcrel sdata2\";\n+    case DW_EH_PE_indirect | DW_EH_PE_sdata4 | DW_EH_PE_pcrel:\n+      return \"indirect pcrel sdata4\";\n+    case DW_EH_PE_indirect | DW_EH_PE_sdata8 | DW_EH_PE_pcrel:\n+      return \"indirect pcrel sdata8\";\n+\n+    case DW_EH_PE_indirect | DW_EH_PE_uleb128 | DW_EH_PE_textrel:\n+      return \"indirect textrel uleb128\";\n+    case DW_EH_PE_indirect | DW_EH_PE_udata2 | DW_EH_PE_textrel:\n+      return \"indirect textrel udata2\";\n+    case DW_EH_PE_indirect | DW_EH_PE_udata4 | DW_EH_PE_textrel:\n+      return \"indirect textrel udata4\";\n+    case DW_EH_PE_indirect | DW_EH_PE_udata8 | DW_EH_PE_textrel:\n+      return \"indirect textrel udata8\";\n+    case DW_EH_PE_indirect | DW_EH_PE_sleb128 | DW_EH_PE_textrel:\n+      return \"indirect textrel sleb128\";\n+    case DW_EH_PE_indirect | DW_EH_PE_sdata2 | DW_EH_PE_textrel:\n+      return \"indirect textrel sdata2\";\n+    case DW_EH_PE_indirect | DW_EH_PE_sdata4 | DW_EH_PE_textrel:\n+      return \"indirect textrel sdata4\";\n+    case DW_EH_PE_indirect | DW_EH_PE_sdata8 | DW_EH_PE_textrel:\n+      return \"indirect textrel sdata8\";\n+\n+    case DW_EH_PE_indirect | DW_EH_PE_uleb128 | DW_EH_PE_datarel:\n+      return \"indirect datarel uleb128\";\n+    case DW_EH_PE_indirect | DW_EH_PE_udata2 | DW_EH_PE_datarel:\n+      return \"indirect datarel udata2\";\n+    case DW_EH_PE_indirect | DW_EH_PE_udata4 | DW_EH_PE_datarel:\n+      return \"indirect datarel udata4\";\n+    case DW_EH_PE_indirect | DW_EH_PE_udata8 | DW_EH_PE_datarel:\n+      return \"indirect datarel udata8\";\n+    case DW_EH_PE_indirect | DW_EH_PE_sleb128 | DW_EH_PE_datarel:\n+      return \"indirect datarel sleb128\";\n+    case DW_EH_PE_indirect | DW_EH_PE_sdata2 | DW_EH_PE_datarel:\n+      return \"indirect datarel sdata2\";\n+    case DW_EH_PE_indirect | DW_EH_PE_sdata4 | DW_EH_PE_datarel:\n+      return \"indirect datarel sdata4\";\n+    case DW_EH_PE_indirect | DW_EH_PE_sdata8 | DW_EH_PE_datarel:\n+      return \"indirect datarel sdata8\";\n+\n+    case DW_EH_PE_indirect | DW_EH_PE_uleb128 | DW_EH_PE_funcrel:\n+      return \"indirect funcrel uleb128\";\n+    case DW_EH_PE_indirect | DW_EH_PE_udata2 | DW_EH_PE_funcrel:\n+      return \"indirect funcrel udata2\";\n+    case DW_EH_PE_indirect | DW_EH_PE_udata4 | DW_EH_PE_funcrel:\n+      return \"indirect funcrel udata4\";\n+    case DW_EH_PE_indirect | DW_EH_PE_udata8 | DW_EH_PE_funcrel:\n+      return \"indirect funcrel udata8\";\n+    case DW_EH_PE_indirect | DW_EH_PE_sleb128 | DW_EH_PE_funcrel:\n+      return \"indirect funcrel sleb128\";\n+    case DW_EH_PE_indirect | DW_EH_PE_sdata2 | DW_EH_PE_funcrel:\n+      return \"indirect funcrel sdata2\";\n+    case DW_EH_PE_indirect | DW_EH_PE_sdata4 | DW_EH_PE_funcrel:\n+      return \"indirect funcrel sdata4\";\n+    case DW_EH_PE_indirect | DW_EH_PE_sdata8 | DW_EH_PE_funcrel:\n+      return \"indirect funcrel sdata8\";\n+\n     default:\n       abort ();\n     }\n@@ -3551,7 +3602,7 @@ sjlj_output_call_site_table ()\n void\n output_function_exception_table ()\n {\n-  int format, i, n;\n+  int tt_format, cs_format, lp_format, i, n;\n #ifdef HAVE_AS_LEB128\n   char ttype_label[32];\n   char cs_after_size_label[32];\n@@ -3570,7 +3621,15 @@ output_function_exception_table ()\n \t\t    ? sjlj_funcdef_number\n \t\t    : current_funcdef_number);\n \n+#ifdef IA64_UNWIND_INFO\n+  fputs (\"\\t.personality\\t\", asm_out_file);\n+  output_addr_const (asm_out_file, eh_personality_libfunc);\n+  fputs (\"\\n\\t.handlerdata\\n\", asm_out_file);\n+  /* Note that varasm still thinks we're in the function's code section.\n+     The \".endp\" directive that will immediately follow will take us back.  */\n+#else\n   exception_section ();\n+#endif\n \n   have_tt_data = (VARRAY_ACTIVE_SIZE (cfun->eh->ttype_data) > 0\n \t\t  || VARRAY_ACTIVE_SIZE (cfun->eh->ehspec_data) > 0);\n@@ -3588,26 +3647,24 @@ output_function_exception_table ()\n      be most useful in moving the landing pads completely out of\n      line to another section, but it could also be used to minimize\n      the size of uleb128 landing pad offsets.  */\n-  format = DW_EH_PE_omit;\n-  dw2_asm_output_data (1, format, \"@LPStart format (%s)\",\n-\t\t       eh_data_format_name (format));\n+  lp_format = DW_EH_PE_omit;\n+  dw2_asm_output_data (1, lp_format, \"@LPStart format (%s)\",\n+\t\t       eh_data_format_name (lp_format));\n \n   /* @LPStart pointer would go here.  */\n \n   /* Indicate the format of the @TType entries.  */\n   if (! have_tt_data)\n-    format = DW_EH_PE_omit;\n+    tt_format = DW_EH_PE_omit;\n   else\n     {\n-      /* ??? Define a ASM_PREFERRED_DATA_FORMAT to say what \n-\t sort of dynamic-relocation-free reference to emit.  */\n-      format = 0;\n+      tt_format = ASM_PREFERRED_EH_DATA_FORMAT (/*code=*/0, /*global=*/1);\n #ifdef HAVE_AS_LEB128\n       ASM_GENERATE_INTERNAL_LABEL (ttype_label, \"LLSDATT\", funcdef_number);\n #endif\n     }\n-  dw2_asm_output_data (1, format, \"@TType format (%s)\",\n-\t\t       eh_data_format_name (format));\n+  dw2_asm_output_data (1, tt_format, \"@TType format (%s)\",\n+\t\t       eh_data_format_name (tt_format));\n \n #ifndef HAVE_AS_LEB128\n   if (USING_SJLJ_EXCEPTIONS)\n@@ -3659,12 +3716,12 @@ output_function_exception_table ()\n \n   /* Indicate the format of the call-site offsets.  */\n #ifdef HAVE_AS_LEB128\n-  format = DW_EH_PE_uleb128;\n+  cs_format = DW_EH_PE_uleb128;\n #else\n-  format = DW_EH_PE_udata4;\n+  cs_format = DW_EH_PE_udata4;\n #endif\n-  dw2_asm_output_data (1, format, \"call-site format (%s)\",\n-\t\t       eh_data_format_name (format));\n+  dw2_asm_output_data (1, cs_format, \"call-site format (%s)\",\n+\t\t       eh_data_format_name (cs_format));\n \n #ifdef HAVE_AS_LEB128\n   ASM_GENERATE_INTERNAL_LABEL (cs_after_size_label, \"LLSDACSB\",\n@@ -3706,8 +3763,9 @@ output_function_exception_table ()\n       else\n \ttype = lookup_type_for_runtime (type);\n \n-      /* ??? Handle ASM_PREFERRED_DATA_FORMAT.  */\n-      output_constant (type, GET_MODE_SIZE (ptr_mode));\n+      dw2_asm_output_encoded_addr_rtx (tt_format,\n+\t\t\t\t       expand_expr (type, NULL_RTX, VOIDmode,\n+\t\t\t\t\t\t    EXPAND_INITIALIZER));\n     }\n \n #ifdef HAVE_AS_LEB128"}, {"sha": "e0c8c2e6959a38a3798982a45d77a5eb23a53542", "filename": "gcc/except.h", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a1ee410cefc93b247bbcc9b8a153ba5af72be73/gcc%2Fexcept.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a1ee410cefc93b247bbcc9b8a153ba5af72be73/gcc%2Fexcept.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.h?ref=2a1ee410cefc93b247bbcc9b8a153ba5af72be73", "patch": "@@ -173,12 +173,12 @@ extern tree (*lang_eh_runtime_type) PARAMS ((tree));\n    mean that we can use call frame exceptions.  Detect that the target\n    has appropriate support.  */\n \n-#if !defined (EH_RETURN_DATA_REGNO)\t\t\\\n-    || !defined(EH_RETURN_STACKADJ_RTX)\t\t\\\n-    || ! (defined(EH_RETURN_HANDLER_RTX)\t\\\n-\t  || defined(HAVE_eh_return))\t\t\\\n-    || ! (defined(DWARF2_UNWIND_INFO)\t\t\\\n-\t  || defined(IA64_UNWIND_INFO))\n+#if ! (defined (EH_RETURN_DATA_REGNO)\t\t\t\\\n+       && (defined (IA64_UNWIND_INFO)\t\t\t\\\n+\t   || (defined (DWARF2_UNWIND_INFO)\t\t\\\n+\t       && defined (EH_RETURN_STACKADJ_RTX)\t\\\n+\t       && (defined (EH_RETURN_HANDLER_RTX)\t\\\n+\t\t   || defined (HAVE_eh_return)))))\n #define MUST_USE_SJLJ_EXCEPTIONS\t1\n #else\n #define MUST_USE_SJLJ_EXCEPTIONS\t0"}, {"sha": "64a4241b3786915127124b0c13ecf308cd6afddc", "filename": "gcc/final.c", "status": "modified", "additions": 3, "deletions": 10, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a1ee410cefc93b247bbcc9b8a153ba5af72be73/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a1ee410cefc93b247bbcc9b8a153ba5af72be73/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=2a1ee410cefc93b247bbcc9b8a153ba5af72be73", "patch": "@@ -1583,12 +1583,9 @@ final_start_function (first, file, optimize)\n     last_linenum = high_block_linenum = high_function_linenum\n       = NOTE_LINE_NUMBER (first);\n \n-#if defined (DWARF2_UNWIND_INFO) || defined (DWARF2_DEBUGGING_INFO)\n-  /* Output DWARF definition of the function.  */\n-  if (dwarf2out_do_frame ())\n-    dwarf2out_begin_prologue ();\n-  else\n-    current_function_func_begin_label = 0;\n+#if defined (DWARF2_UNWIND_INFO) || defined (IA64_UNWIND_INFO) \\\n+    || defined (DWARF2_DEBUGGING_INFO)\n+  dwarf2out_begin_prologue ();\n #endif\n \n   /* For SDB and XCOFF, the function beginning must be marked between\n@@ -1811,10 +1808,6 @@ final_end_function (first, file, optimize)\n \n   bb_func_label_num = -1;\t/* not in function, nuke label # */\n \n-#ifdef IA64_UNWIND_INFO\n-  output_function_exception_table ();\n-#endif\n-\n   /* If FUNCTION_EPILOGUE is not defined, then the function body\n      itself contains return instructions wherever needed.  */\n }"}, {"sha": "3b7597a4744da1451f83f771f7707cf10f6d45d7", "filename": "gcc/libgcc-std.ver", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a1ee410cefc93b247bbcc9b8a153ba5af72be73/gcc%2Flibgcc-std.ver", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a1ee410cefc93b247bbcc9b8a153ba5af72be73/gcc%2Flibgcc-std.ver", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flibgcc-std.ver?ref=2a1ee410cefc93b247bbcc9b8a153ba5af72be73", "patch": "@@ -116,6 +116,8 @@ GCC_3.0 {\n   _Unwind_GetIP\n   _Unwind_GetLanguageSpecificData\n   _Unwind_GetRegionStart\n+  _Unwind_GetTextRelBase\n+  _Unwind_GetDataRelBase\n   _Unwind_RaiseException\n   _Unwind_Resume\n   _Unwind_SetGR"}, {"sha": "1a1ad21238b62ba64df0de21c1cb6e7c24f0f019", "filename": "gcc/tm.texi", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a1ee410cefc93b247bbcc9b8a153ba5af72be73/gcc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a1ee410cefc93b247bbcc9b8a153ba5af72be73/gcc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftm.texi?ref=2a1ee410cefc93b247bbcc9b8a153ba5af72be73", "patch": "@@ -2553,6 +2553,33 @@ the @code{eh_return} instruction pattern should be used instead.\n If you want to support call frame exception handling, you must\n define either this macro or the @code{eh_return} instruction pattern.\n \n+@findex ASM_PREFERRED_EH_DATA_FORMAT\n+@item ASM_PREFERRED_EH_DATA_FORMAT(@var{CODE}, @var{GLOBAL})\n+This macro chooses the encoding of pointers embedded in the exception\n+handling sections.  If at all possible, this should be defined such\n+that the exception handling section will not require dynamic relocations,\n+and so may be read-only.\n+\n+@var{CODE} is 0 for data, 1 for code labels, 2 for function pointers.\n+@var{GLOBAL} is true if the symbol may be affected by dynamic relocations.\n+The macro should return a combination of the @code{DW_EH_PE_*} defines\n+as found in @file{dwarf2.h}.\n+\n+If this macro is not defined, pointers will not be encoded but \n+represented directly.\n+\n+@findex ASM_MAYBE_OUTPUT_ENCODED_ADDR_RTX\n+@item ASM_MAYBE_OUTPUT_ENCODED_ADDR_RTX(@var{FILE}, @var{ENCODING}, @var{SIZE}, @var{ADDR}, @var{DONE})\n+This macro allows the target to emit whatever special magic is required\n+to represent the encoding chosen by @code{ASM_PREFERRED_EH_DATA_FORMAT}.\n+Generic code takes care of pc-relative and indirect encodings; this must\n+be defined if the target uses text-relative or data-relative encodings.\n+\n+This is a C statement that branches to @var{DONE} if the format was\n+handled.  @var{ENCODING} is the format chosen, @var{SIZE} is the number\n+of bytes that the format occupies, @var{ADDR} is the @code{SYMBOL_REF}\n+to be emitted.\n+\n @findex SMALL_STACK\n @item SMALL_STACK\n Define this macro if the stack size for the target is very small.  This"}, {"sha": "b80e26b7fe22e30c9ab263ef4c57a0416cece826", "filename": "gcc/toplev.c", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a1ee410cefc93b247bbcc9b8a153ba5af72be73/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a1ee410cefc93b247bbcc9b8a153ba5af72be73/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=2a1ee410cefc93b247bbcc9b8a153ba5af72be73", "patch": "@@ -2404,6 +2404,8 @@ compile_file (name)\n \n   /* Output some stuff at end of file if nec.  */\n \n+  dw2_output_indirect_constants ();\n+\n   end_final (dump_base_name);\n \n   if (profile_arc_flag || flag_test_coverage || flag_branch_probabilities)\n@@ -3721,9 +3723,19 @@ rest_of_compilation (decl)\n     final_start_function (insns, asm_out_file, optimize);\n     final (insns, asm_out_file, optimize, 0);\n     final_end_function (insns, asm_out_file, optimize);\n+\n+#ifdef IA64_UNWIND_INFO\n+    /* ??? The IA-64 \".handlerdata\" directive must be issued before\n+       the \".endp\" directive that closes the procedure descriptor.  */\n+    output_function_exception_table ();\n+#endif\n+\n     assemble_end_function (decl, fnname);\n \n+#ifndef IA64_UNWIND_INFO\n+    /* Otherwise, it feels unclean to switch sections in the middle.  */\n     output_function_exception_table ();\n+#endif\n \n     if (! quiet_flag)\n       fflush (asm_out_file);"}, {"sha": "6eb163d904b94513dbad685427aa317668c28e3b", "filename": "gcc/unwind-dw2.c", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a1ee410cefc93b247bbcc9b8a153ba5af72be73/gcc%2Funwind-dw2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a1ee410cefc93b247bbcc9b8a153ba5af72be73/gcc%2Funwind-dw2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funwind-dw2.c?ref=2a1ee410cefc93b247bbcc9b8a153ba5af72be73", "patch": "@@ -314,6 +314,19 @@ _Unwind_GetRegionStart (struct _Unwind_Context *context)\n   return (_Unwind_Ptr) context->bases.func;\n }\n \n+#ifndef __ia64__\n+_Unwind_Ptr\n+_Unwind_GetDataRelBase (struct _Unwind_Context *context)\n+{\n+  return (_Unwind_Ptr) context->bases.dbase;\n+}\n+\n+_Unwind_Ptr\n+_Unwind_GetTextRelBase (struct _Unwind_Context *context)\n+{\n+  return (_Unwind_Ptr) context->bases.tbase;\n+}\n+#endif\n \f\n /* Extract any interesting information from the CIE for the translation\n    unit F belongs to.  Return a pointer to the byte after the augmentation,"}, {"sha": "9eda448b4328f0c527c6a2b0fc1ad75bc5526e78", "filename": "gcc/unwind-pe.h", "status": "added", "additions": 208, "deletions": 0, "changes": 208, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a1ee410cefc93b247bbcc9b8a153ba5af72be73/gcc%2Funwind-pe.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a1ee410cefc93b247bbcc9b8a153ba5af72be73/gcc%2Funwind-pe.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funwind-pe.h?ref=2a1ee410cefc93b247bbcc9b8a153ba5af72be73", "patch": "@@ -0,0 +1,208 @@\n+/* Exception handling and frame unwind runtime interface routines.\n+   Copyright (C) 2001 Free Software Foundation, Inc.\n+\n+   This file is part of GNU CC.\n+\n+   GNU CC is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 2, or (at your option)\n+   any later version.\n+\n+   GNU CC is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GNU CC; see the file COPYING.  If not, write to\n+   the Free Software Foundation, 59 Temple Place - Suite 330,\n+   Boston, MA 02111-1307, USA.  */\n+\n+/* @@@ Really this should be out of line, but this also causes link\n+   compatibility problems with the base ABI.  This is slightly better\n+   than duplicating code, however.  */\n+\n+/* Pointer encodings, from dwarf2.h.  */\n+#define DW_EH_PE_absptr         0x00\n+#define DW_EH_PE_omit           0xff\n+\n+#define DW_EH_PE_uleb128        0x01\n+#define DW_EH_PE_udata2         0x02\n+#define DW_EH_PE_udata4         0x03\n+#define DW_EH_PE_udata8         0x04\n+#define DW_EH_PE_sleb128        0x09\n+#define DW_EH_PE_sdata2         0x0A\n+#define DW_EH_PE_sdata4         0x0B\n+#define DW_EH_PE_sdata8         0x0C\n+#define DW_EH_PE_signed         0x08\n+\n+#define DW_EH_PE_pcrel          0x10\n+#define DW_EH_PE_textrel        0x20\n+#define DW_EH_PE_datarel        0x30\n+#define DW_EH_PE_funcrel        0x40\n+\n+#define DW_EH_PE_indirect\t0x80\n+\n+static unsigned int\n+size_of_encoded_value (unsigned char encoding)\n+{\n+  if (encoding == DW_EH_PE_omit)\n+    return 0;\n+\n+  switch (encoding & 0x07)\n+    {\n+    case DW_EH_PE_absptr:\n+      return sizeof (void *);\n+    case DW_EH_PE_udata2:\n+      return 2;\n+    case DW_EH_PE_udata4:\n+      return 4;\n+    case DW_EH_PE_udata8:\n+      return 8;\n+    }\n+  abort ();\n+}\n+\n+static _Unwind_Ptr\n+base_of_encoded_value (unsigned char encoding, _Unwind_Context *context)\n+{\n+  if (encoding == DW_EH_PE_omit)\n+    return 0;\n+\n+  switch (encoding & 0x70)\n+    {\n+    case DW_EH_PE_absptr:\n+    case DW_EH_PE_pcrel:\n+      return 0;\n+\n+    case DW_EH_PE_textrel:\n+      return _Unwind_GetTextRelBase (context);\n+    case DW_EH_PE_datarel:\n+      return _Unwind_GetDataRelBase (context);\n+    case DW_EH_PE_funcrel:\n+      return _Unwind_GetRegionStart (context);\n+    }\n+  abort ();\n+}\n+\n+static const unsigned char *\n+read_encoded_value_with_base (unsigned char encoding, _Unwind_Ptr base,\n+\t\t\t      const unsigned char *p, _Unwind_Ptr *val)\n+{\n+  union unaligned\n+    {\n+      void *ptr;\n+      unsigned u2 __attribute__ ((mode (HI)));\n+      unsigned u4 __attribute__ ((mode (SI)));\n+      unsigned u8 __attribute__ ((mode (DI)));\n+      signed s2 __attribute__ ((mode (HI)));\n+      signed s4 __attribute__ ((mode (SI)));\n+      signed s8 __attribute__ ((mode (DI)));\n+    } __attribute__((__packed__));\n+\n+  union unaligned *u = (union unaligned *) p;\n+  _Unwind_Ptr result;\n+\n+  switch (encoding & 0x0f)\n+    {\n+    case DW_EH_PE_absptr:\n+      result = (_Unwind_Ptr) u->ptr;\n+      p += sizeof (void *);\n+      break;\n+\n+    case DW_EH_PE_uleb128:\n+      {\n+\tunsigned int shift = 0;\n+\tunsigned char byte;\n+\n+\tresult = 0;\n+\tdo\n+\t  {\n+\t    byte = *p++;\n+\t    result |= (_Unwind_Ptr)(byte & 0x7f) << shift;\n+\t    shift += 7;\n+\t  }\n+\twhile (byte & 0x80);\n+      }\n+      break;\n+\n+    case DW_EH_PE_sleb128:\n+      {\n+\tunsigned int shift = 0;\n+\tunsigned char byte;\n+\n+\tresult = 0;\n+\tdo\n+\t  {\n+\t    byte = *p++;\n+\t    result |= (_Unwind_Ptr)(byte & 0x7f) << shift;\n+\t    shift += 7;\n+\t  }\n+\twhile (byte & 0x80);\n+\n+\tif (shift < 8 * sizeof(result) && (byte & 0x40) != 0)\n+\t  result |= -(1L << shift);\n+      }\n+      break;\n+\n+    case DW_EH_PE_udata2:\n+      result = u->u2;\n+      p += 2;\n+      break;\n+    case DW_EH_PE_udata4:\n+      result = u->u4;\n+      p += 4;\n+      break;\n+    case DW_EH_PE_udata8:\n+      result = u->u8;\n+      p += 8;\n+      break;\n+\n+    case DW_EH_PE_sdata2:\n+      result = u->s2;\n+      p += 2;\n+      break;\n+    case DW_EH_PE_sdata4:\n+      result = u->s4;\n+      p += 4;\n+      break;\n+    case DW_EH_PE_sdata8:\n+      result = u->s8;\n+      p += 8;\n+      break;\n+\n+    default:\n+      abort ();\n+    }\n+\n+  if (result != 0)\n+    {\n+      result += ((encoding & 0x70) == DW_EH_PE_pcrel ? (_Unwind_Ptr)u : base);\n+      if (encoding & DW_EH_PE_indirect)\n+\tresult = *(_Unwind_Ptr *)result;\n+    }\n+\n+  *val = result;\n+  return p;\n+}\n+\n+static inline const unsigned char *\n+read_encoded_value (_Unwind_Context *context, unsigned char encoding,\n+\t\t    const unsigned char *p, _Unwind_Ptr *val)\n+{\n+  return read_encoded_value_with_base (encoding, \n+\t\tbase_of_encoded_value (encoding, context),\n+\t\tp, val);\n+}\n+\n+static inline const unsigned char *\n+read_uleb128 (const unsigned char *p, _Unwind_Ptr *val)\n+{\n+  return read_encoded_value_with_base (DW_EH_PE_uleb128, 0, p, val);\n+}\n+\n+static inline const unsigned char *\n+read_sleb128 (const unsigned char *p, _Unwind_Ptr *val)\n+{\n+  return read_encoded_value_with_base (DW_EH_PE_sleb128, 0, p, val);\n+}"}, {"sha": "ce43365a314f168a305df9dc3037450d460819e1", "filename": "gcc/unwind.h", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a1ee410cefc93b247bbcc9b8a153ba5af72be73/gcc%2Funwind.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a1ee410cefc93b247bbcc9b8a153ba5af72be73/gcc%2Funwind.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funwind.h?ref=2a1ee410cefc93b247bbcc9b8a153ba5af72be73", "patch": "@@ -161,6 +161,31 @@ extern _Unwind_Reason_Code _Unwind_SjLj_ForcedUnwind\n      (struct _Unwind_Exception *, _Unwind_Stop_Fn, void *);\n extern void _Unwind_SjLj_Resume (struct _Unwind_Exception *);\n \n+/* @@@ The following provide access to the base addresses for text\n+   and data-relative addressing in the LDSA.  In order to stay link\n+   compatible with the standard ABI for IA-64, we inline these.  */\n+\n+#ifdef __ia64__\n+#include <stdlib.h>\n+\n+static inline _Unwind_Ptr\n+_Unwind_GetDataRelBase (struct _Unwind_Context *_C)\n+{\n+  /* The GP is stored in R1.  */\n+  return _Unwind_GetGR (_C, 1);\n+}\n+\n+static inline _Unwind_Ptr\n+_Unwind_GetTextRelBase (struct _Unwind_Context *_C)\n+{\n+  abort ();\n+  return 0;\n+}\n+#else\n+extern _Unwind_Ptr _Unwind_GetDataRelBase (struct _Unwind_Context *);\n+extern _Unwind_Ptr _Unwind_GetTextRelBase (struct _Unwind_Context *);\n+#endif\n+\n #ifdef __cplusplus\n }\n #endif"}]}