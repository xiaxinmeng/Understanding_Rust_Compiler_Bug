{"sha": "77560086aa85c75cba3bd874f1a11130bc76cfad", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Nzc1NjAwODZhYTg1Yzc1Y2JhM2JkODc0ZjFhMTExMzBiYzc2Y2ZhZA==", "commit": {"author": {"name": "Bernd Edlinger", "email": "bernd.edlinger@hotmail.de", "date": "2017-06-01T19:30:47Z"}, "committer": {"name": "Bernd Edlinger", "email": "edlinger@gcc.gnu.org", "date": "2017-06-01T19:30:47Z"}, "message": "i386.c (x86_64_ms_sysv_extra_clobbered_registers): Make static.\n\n2017-06-01  Bernd Edlinger  <bernd.edlinger@hotmail.de>\n\n        * config/i386/i386.c (x86_64_ms_sysv_extra_clobbered_registers): Make\n        static.\n        (xlogue_layout::get_stack_space_used, xlogue_layout::s_instances,\n        xlogue_layout::get_instance, logue_layout::xlogue_layout,\n        sp_valid_at, fp_valid_at, choose_basereg): Formatting.\n        (xlogue_layout::get_stub_rtx): Make static.\n        (xlogue_layout::get_stub_name): Avoid const-cast, make static.\n        (xlogue_layout::compute_stub_managed_regs): Rename to...\n        (xlogue_layout::count_stub_managed_regs): ...this.\n        (xlogue_layout::is_stub_managed_reg): New function.\n        (xlogue_layout::m_stub_names): Rename to...\n        (xlogue_layout::s_stub_names): ...this, make static.\n        (xlogue_layout::STUB_INDEX_OFFSET, xlogue_layout::MIN_REGS,\n        xlogue_layout::MAX_REGS, xlogue_layout::MAX_EXTRA_REGS,\n        xlogue_layout::VARIANT_COUNT, xlogue_layout::STUB_NAME_MAX_LEN,\n        xlogue_layout::s_stub_names): Instantiate statics.\n        (stub_managed_regs): Remove.\n        (ix86_save_reg): Use xlogue_layout::compute_stub_managed_regs.\n        (disable_call_ms2sysv_xlogues): Rename to...\n        (warn_once_call_ms2sysv_xlogues): ...this, and warn only once.\n        (ix86_initial_elimination_offset, ix86_expand_call): Fix call_ms2sysv\n        warning logic.\n        (ix86_static_chain): Make sure that ix86_static_chain_on_stack can't\n        change after reload_completed.\n        (ix86_can_use_return_insn_p): Use the ix86_frame data structure\n        directly.\n        (ix86_expand_prologue): Likewise.\n        (ix86_expand_epilogue): Likewise.\n        (ix86_expand_split_stack_prologue): Likewise.\n        (ix86_compute_frame_layout): Remove frame parameter ...\n        (TARGET_COMPUTE_FRAME_LAYOUT): ... and export it as a target hook.\n        (ix86_finalize_stack_realign_flags): Call ix86_compute_frame_layout\n        only if necessary.\n        (ix86_init_machine_status): Don't set use_fast_prologue_epilogue_nregs.\n        (ix86_frame): Move from here ...\n        * config/i386/i386.h (ix86_frame): ... to here.\n        (machine_function): Remove use_fast_prologue_epilogue_nregs, cache the\n        complete ix86_frame data structure instead.  Remove some_ld_name.\n\nFrom-SVN: r248798", "tree": {"sha": "7a144602d30e5377396e790ad963c46de705e50b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7a144602d30e5377396e790ad963c46de705e50b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/77560086aa85c75cba3bd874f1a11130bc76cfad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/77560086aa85c75cba3bd874f1a11130bc76cfad", "html_url": "https://github.com/Rust-GCC/gccrs/commit/77560086aa85c75cba3bd874f1a11130bc76cfad", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/77560086aa85c75cba3bd874f1a11130bc76cfad/comments", "author": {"login": "bernd-edlinger", "id": 17638929, "node_id": "MDQ6VXNlcjE3NjM4OTI5", "avatar_url": "https://avatars.githubusercontent.com/u/17638929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bernd-edlinger", "html_url": "https://github.com/bernd-edlinger", "followers_url": "https://api.github.com/users/bernd-edlinger/followers", "following_url": "https://api.github.com/users/bernd-edlinger/following{/other_user}", "gists_url": "https://api.github.com/users/bernd-edlinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/bernd-edlinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bernd-edlinger/subscriptions", "organizations_url": "https://api.github.com/users/bernd-edlinger/orgs", "repos_url": "https://api.github.com/users/bernd-edlinger/repos", "events_url": "https://api.github.com/users/bernd-edlinger/events{/privacy}", "received_events_url": "https://api.github.com/users/bernd-edlinger/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "2ded3754ad63a2eb375b34e2719303ec673cc72f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ded3754ad63a2eb375b34e2719303ec673cc72f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2ded3754ad63a2eb375b34e2719303ec673cc72f"}], "stats": {"total": 461, "additions": 271, "deletions": 190}, "files": [{"sha": "2947735b127a184cbf478a61d18d0ce6af3701df", "filename": "gcc/ChangeLog", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77560086aa85c75cba3bd874f1a11130bc76cfad/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77560086aa85c75cba3bd874f1a11130bc76cfad/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=77560086aa85c75cba3bd874f1a11130bc76cfad", "patch": "@@ -1,3 +1,44 @@\n+2017-06-01  Bernd Edlinger  <bernd.edlinger@hotmail.de>\n+\n+\t* config/i386/i386.c (x86_64_ms_sysv_extra_clobbered_registers): Make\n+\tstatic.\n+\t(xlogue_layout::get_stack_space_used, xlogue_layout::s_instances,\n+\txlogue_layout::get_instance, logue_layout::xlogue_layout,\n+\tsp_valid_at, fp_valid_at, choose_basereg): Formatting.\n+\t(xlogue_layout::get_stub_rtx): Make static.\n+\t(xlogue_layout::get_stub_name): Avoid const-cast, make static.\n+\t(xlogue_layout::compute_stub_managed_regs): Rename to...\n+\t(xlogue_layout::count_stub_managed_regs): ...this.\n+\t(xlogue_layout::is_stub_managed_reg): New function.\n+\t(xlogue_layout::m_stub_names): Rename to...\n+\t(xlogue_layout::s_stub_names): ...this, make static.\n+\t(xlogue_layout::STUB_INDEX_OFFSET, xlogue_layout::MIN_REGS,\n+\txlogue_layout::MAX_REGS, xlogue_layout::MAX_EXTRA_REGS,\n+\txlogue_layout::VARIANT_COUNT, xlogue_layout::STUB_NAME_MAX_LEN,\n+\txlogue_layout::s_stub_names): Instantiate statics.\n+\t(stub_managed_regs): Remove.\n+\t(ix86_save_reg): Use xlogue_layout::compute_stub_managed_regs.\n+\t(disable_call_ms2sysv_xlogues): Rename to...\n+\t(warn_once_call_ms2sysv_xlogues): ...this, and warn only once.\n+\t(ix86_initial_elimination_offset, ix86_expand_call): Fix call_ms2sysv\n+\twarning logic.\n+\t(ix86_static_chain): Make sure that ix86_static_chain_on_stack can't\n+\tchange after reload_completed.\n+\t(ix86_can_use_return_insn_p): Use the ix86_frame data structure\n+\tdirectly.\n+\t(ix86_expand_prologue): Likewise.\n+\t(ix86_expand_epilogue): Likewise.\n+\t(ix86_expand_split_stack_prologue): Likewise.\n+\t(ix86_compute_frame_layout): Remove frame parameter ...\n+\t(TARGET_COMPUTE_FRAME_LAYOUT): ... and export it as a target hook.\n+\t(ix86_finalize_stack_realign_flags): Call ix86_compute_frame_layout\n+\tonly if necessary.\n+\t(ix86_init_machine_status): Don't set use_fast_prologue_epilogue_nregs.\n+\t(ix86_frame): Move from here ...\n+\t* config/i386/i386.h (ix86_frame): ... to here.\n+\t(machine_function): Remove use_fast_prologue_epilogue_nregs, cache the\n+\tcomplete ix86_frame data structure instead.  Remove some_ld_name.\n+\n 2017-06-01  Pierre-Marie de Rodat  <derodat@adacore.com>\n \n \t* dwarf2out.c (dwarf2out_late_global_decl): Add locations for"}, {"sha": "94a84b3afd432538302bd916a0e270e2c4409c9c", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 160, "deletions": 181, "changes": 341, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77560086aa85c75cba3bd874f1a11130bc76cfad/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77560086aa85c75cba3bd874f1a11130bc76cfad/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=77560086aa85c75cba3bd874f1a11130bc76cfad", "patch": "@@ -2425,7 +2425,9 @@ static int const x86_64_int_return_registers[4] =\n \n /* Additional registers that are clobbered by SYSV calls.  */\n \n-unsigned const x86_64_ms_sysv_extra_clobbered_registers[12] =\n+#define NUM_X86_64_MS_CLOBBERED_REGS 12\n+static int const x86_64_ms_sysv_extra_clobbered_registers\n+\t\t [NUM_X86_64_MS_CLOBBERED_REGS] =\n {\n   SI_REG, DI_REG,\n   XMM6_REG, XMM7_REG,\n@@ -2472,25 +2474,26 @@ class xlogue_layout {\n     return m_regs[reg];\n   }\n \n-  const char *get_stub_name (enum xlogue_stub stub,\n-\t\t\t     unsigned n_extra_args) const;\n+  static const char *get_stub_name (enum xlogue_stub stub,\n+\t\t\t\t    unsigned n_extra_args);\n+\n   /* Returns an rtx for the stub's symbol based upon\n        1.) the specified stub (save, restore or restore_ret) and\n        2.) the value of cfun->machine->call_ms2sysv_extra_regs and\n        3.) rather or not stack alignment is being performed.  */\n-  rtx get_stub_rtx (enum xlogue_stub stub) const;\n+  static rtx get_stub_rtx (enum xlogue_stub stub);\n \n   /* Returns the amount of stack space (including padding) that the stub\n      needs to store registers based upon data in the machine_function.  */\n   HOST_WIDE_INT get_stack_space_used () const\n   {\n-    const struct machine_function &m = *cfun->machine;\n-    unsigned last_reg = m.call_ms2sysv_extra_regs + MIN_REGS - 1;\n+    const struct machine_function *m = cfun->machine;\n+    unsigned last_reg = m->call_ms2sysv_extra_regs + MIN_REGS - 1;\n \n-    gcc_assert (m.call_ms2sysv_extra_regs <= MAX_EXTRA_REGS);\n+    gcc_assert (m->call_ms2sysv_extra_regs <= MAX_EXTRA_REGS);\n     return m_regs[last_reg].offset\n-\t    + (m.call_ms2sysv_pad_out ? 8 : 0)\n-\t    + STUB_INDEX_OFFSET;\n+\t   + (m->call_ms2sysv_pad_out ? 8 : 0)\n+\t   + STUB_INDEX_OFFSET;\n   }\n \n   /* Returns the offset for the base pointer used by the stub.  */\n@@ -2500,7 +2503,8 @@ class xlogue_layout {\n   }\n \n   static const struct xlogue_layout &get_instance ();\n-  static unsigned compute_stub_managed_regs (HARD_REG_SET &stub_managed_regs);\n+  static unsigned count_stub_managed_regs ();\n+  static bool is_stub_managed_reg (unsigned regno, unsigned count);\n \n   static const HOST_WIDE_INT STUB_INDEX_OFFSET = 0x70;\n   static const unsigned MIN_REGS = NUM_X86_64_MS_CLOBBERED_REGS;\n@@ -2530,9 +2534,10 @@ class xlogue_layout {\n   struct reginfo m_regs[MAX_REGS];\n \n   /* Lazy-inited cache of symbol names for stubs.  */\n-  char m_stub_names[XLOGUE_STUB_COUNT][VARIANT_COUNT][STUB_NAME_MAX_LEN];\n+  static char s_stub_names[XLOGUE_STUB_COUNT][VARIANT_COUNT]\n+\t\t\t  [STUB_NAME_MAX_LEN];\n \n-  static const struct xlogue_layout GTY(()) s_instances[XLOGUE_SET_COUNT];\n+  static const xlogue_layout s_instances[XLOGUE_SET_COUNT];\n };\n \n const char * const xlogue_layout::STUB_BASE_NAMES[XLOGUE_STUB_COUNT] = {\n@@ -2572,9 +2577,20 @@ const unsigned xlogue_layout::REG_ORDER[xlogue_layout::MAX_REGS] = {\n     R15_REG,\t/* 0xe0\t\t0xe8\t\t0xd8\t\t0xe0\t*/\n };\n \n+/* Instantiate static const values.  */\n+const HOST_WIDE_INT xlogue_layout::STUB_INDEX_OFFSET;\n+const unsigned xlogue_layout::MIN_REGS;\n+const unsigned xlogue_layout::MAX_REGS;\n+const unsigned xlogue_layout::MAX_EXTRA_REGS;\n+const unsigned xlogue_layout::VARIANT_COUNT;\n+const unsigned xlogue_layout::STUB_NAME_MAX_LEN;\n+\n+/* Initialize xlogue_layout::s_stub_names to zero.  */\n+char xlogue_layout::s_stub_names[XLOGUE_STUB_COUNT][VARIANT_COUNT]\n+\t\t\t\t[STUB_NAME_MAX_LEN];\n+\n /* Instantiates all xlogue_layout instances.  */\n-const struct xlogue_layout GTY(())\n-xlogue_layout::s_instances[XLOGUE_SET_COUNT] = {\n+const xlogue_layout xlogue_layout::s_instances[XLOGUE_SET_COUNT] = {\n   xlogue_layout (0, false),\n   xlogue_layout (8, false),\n   xlogue_layout (0, true),\n@@ -2583,7 +2599,8 @@ xlogue_layout::s_instances[XLOGUE_SET_COUNT] = {\n \n /* Return an appropriate const instance of xlogue_layout based upon values\n    in cfun->machine and crtl.  */\n-const struct xlogue_layout &xlogue_layout::get_instance ()\n+const struct xlogue_layout &\n+xlogue_layout::get_instance ()\n {\n   enum xlogue_stub_sets stub_set;\n   bool aligned_plus_8 = cfun->machine->call_ms2sysv_pad_in;\n@@ -2600,50 +2617,54 @@ const struct xlogue_layout &xlogue_layout::get_instance ()\n   return s_instances[stub_set];\n }\n \n-/* Determine which clobbered registers can be saved by the stub and store\n-   them in stub_managed_regs.  Returns the count of registers the stub will\n-   save and restore.  */\n+/* Determine how many clobbered registers can be saved by the stub.\n+   Returns the count of registers the stub will save and restore.  */\n unsigned\n-xlogue_layout::compute_stub_managed_regs (HARD_REG_SET &stub_managed_regs)\n+xlogue_layout::count_stub_managed_regs ()\n {\n   bool hfp = frame_pointer_needed || stack_realign_fp;\n-\n   unsigned i, count;\n   unsigned regno;\n \n-  for (i = 0; i < NUM_X86_64_MS_CLOBBERED_REGS; ++i)\n-    {\n-      regno = x86_64_ms_sysv_extra_clobbered_registers[i];\n-      if (regno == BP_REG && hfp)\n-\tcontinue;\n-      if (!ix86_save_reg (regno, false, false))\n-\treturn 0;\n-    }\n-\n-  for (count = i = 0; i < MAX_REGS; ++i)\n+  for (count = i = MIN_REGS; i < MAX_REGS; ++i)\n     {\n       regno = REG_ORDER[i];\n       if (regno == BP_REG && hfp)\n \tcontinue;\n       if (!ix86_save_reg (regno, false, false))\n \tbreak;\n-      add_to_hard_reg_set (&stub_managed_regs, DImode, regno);\n       ++count;\n     }\n-    gcc_assert (count >= MIN_REGS && count <= MAX_REGS);\n-    return count;\n+  return count;\n+}\n+\n+/* Determine if register REGNO is a stub managed register given the\n+   total COUNT of stub managed registers.  */\n+bool\n+xlogue_layout::is_stub_managed_reg (unsigned regno, unsigned count)\n+{\n+  bool hfp = frame_pointer_needed || stack_realign_fp;\n+  unsigned i;\n+\n+  for (i = 0; i < count; ++i)\n+    {\n+      gcc_assert (i < MAX_REGS);\n+      if (REG_ORDER[i] == BP_REG && hfp)\n+\t++count;\n+      else if (REG_ORDER[i] == regno)\n+\treturn true;\n+    }\n+  return false;\n }\n \n /* Constructor for xlogue_layout.  */\n xlogue_layout::xlogue_layout (HOST_WIDE_INT stack_align_off_in, bool hfp)\n   : m_hfp (hfp) , m_nregs (hfp ? 17 : 18),\n     m_stack_align_off_in (stack_align_off_in)\n {\n-  memset (m_regs, 0, sizeof (m_regs));\n-  memset (m_stub_names, 0, sizeof (m_stub_names));\n-\n   HOST_WIDE_INT offset = stack_align_off_in;\n   unsigned i, j;\n+\n   for (i = j = 0; i < MAX_REGS; ++i)\n     {\n       unsigned regno = REG_ORDER[i];\n@@ -2662,29 +2683,30 @@ xlogue_layout::xlogue_layout (HOST_WIDE_INT stack_align_off_in, bool hfp)\n       m_regs[j].regno    = regno;\n       m_regs[j++].offset = offset - STUB_INDEX_OFFSET;\n     }\n-    gcc_assert (j == m_nregs);\n+  gcc_assert (j == m_nregs);\n }\n \n-const char *xlogue_layout::get_stub_name (enum xlogue_stub stub,\n-\t\t\t\t\t  unsigned n_extra_regs) const\n+const char *\n+xlogue_layout::get_stub_name (enum xlogue_stub stub,\n+\t\t\t      unsigned n_extra_regs)\n {\n-  xlogue_layout *writey_this = const_cast<xlogue_layout*>(this);\n-  char *name = writey_this->m_stub_names[stub][n_extra_regs];\n+  char *name = s_stub_names[stub][n_extra_regs];\n \n   /* Lazy init */\n   if (!*name)\n     {\n       int res = snprintf (name, STUB_NAME_MAX_LEN, \"__%s_%u\",\n \t\t\t  STUB_BASE_NAMES[stub], MIN_REGS + n_extra_regs);\n-      gcc_checking_assert (res <= (int)STUB_NAME_MAX_LEN);\n+      gcc_checking_assert (res < (int)STUB_NAME_MAX_LEN);\n     }\n \n   return name;\n }\n \n /* Return rtx of a symbol ref for the entry point (based upon\n    cfun->machine->call_ms2sysv_extra_regs) of the specified stub.  */\n-rtx xlogue_layout::get_stub_rtx (enum xlogue_stub stub) const\n+rtx\n+xlogue_layout::get_stub_rtx (enum xlogue_stub stub)\n {\n   const unsigned n_extra_regs = cfun->machine->call_ms2sysv_extra_regs;\n   gcc_checking_assert (n_extra_regs <= MAX_EXTRA_REGS);\n@@ -2703,73 +2725,6 @@ struct GTY(()) stack_local_entry {\n   struct stack_local_entry *next;\n };\n \n-/* Structure describing stack frame layout.\n-   Stack grows downward:\n-\n-   [arguments]\n-\t\t\t\t\t<- ARG_POINTER\n-   saved pc\n-\n-   saved static chain\t\t\tif ix86_static_chain_on_stack\n-\n-   saved frame pointer\t\t\tif frame_pointer_needed\n-\t\t\t\t\t<- HARD_FRAME_POINTER\n-   [saved regs]\n-\t\t\t\t\t<- reg_save_offset\n-   [padding0]\n-\t\t\t\t\t<- stack_realign_offset\n-   [saved SSE regs]\n-\tOR\n-   [stub-saved registers for ms x64 --> sysv clobbers\n-\t\t\t<- Start of out-of-line, stub-saved/restored regs\n-\t\t\t   (see libgcc/config/i386/(sav|res)ms64*.S)\n-     [XMM6-15]\n-     [RSI]\n-     [RDI]\n-     [?RBX]\t\tonly if RBX is clobbered\n-     [?RBP]\t\tonly if RBP and RBX are clobbered\n-     [?R12]\t\tonly if R12 and all previous regs are clobbered\n-     [?R13]\t\tonly if R13 and all previous regs are clobbered\n-     [?R14]\t\tonly if R14 and all previous regs are clobbered\n-     [?R15]\t\tonly if R15 and all previous regs are clobbered\n-\t\t\t<- end of stub-saved/restored regs\n-     [padding1]\n-   ]\n-\t\t\t\t\t<- outlined_save_offset\n-\t\t\t\t\t<- sse_regs_save_offset\n-   [padding2]\n-\t\t       |\t\t<- FRAME_POINTER\n-   [va_arg registers]  |\n-\t\t       |\n-   [frame]\t       |\n-\t\t       |\n-   [padding2]\t       | = to_allocate\n-\t\t\t\t\t<- STACK_POINTER\n-  */\n-struct ix86_frame\n-{\n-  int nsseregs;\n-  int nregs;\n-  int va_arg_size;\n-  int red_zone_size;\n-  int outgoing_arguments_size;\n-\n-  /* The offsets relative to ARG_POINTER.  */\n-  HOST_WIDE_INT frame_pointer_offset;\n-  HOST_WIDE_INT hard_frame_pointer_offset;\n-  HOST_WIDE_INT stack_pointer_offset;\n-  HOST_WIDE_INT hfp_save_offset;\n-  HOST_WIDE_INT reg_save_offset;\n-  HOST_WIDE_INT stack_realign_allocate_offset;\n-  HOST_WIDE_INT stack_realign_offset;\n-  HOST_WIDE_INT outlined_save_offset;\n-  HOST_WIDE_INT sse_reg_save_offset;\n-\n-  /* When save_regs_using_mov is set, emit prologue using\n-     move instead of push instructions.  */\n-  bool save_regs_using_mov;\n-};\n-\n /* Which cpu are we scheduling for.  */\n enum attr_cpu ix86_schedule;\n \n@@ -2861,7 +2816,7 @@ static unsigned int ix86_function_arg_boundary (machine_mode,\n \t\t\t\t\t\tconst_tree);\n static rtx ix86_static_chain (const_tree, bool);\n static int ix86_function_regparm (const_tree, const_tree);\n-static void ix86_compute_frame_layout (struct ix86_frame *);\n+static void ix86_compute_frame_layout (void);\n static bool ix86_expand_vector_init_one_nonzero (bool, machine_mode,\n \t\t\t\t\t\t rtx, rtx, int);\n static void ix86_add_new_builtins (HOST_WIDE_INT, HOST_WIDE_INT);\n@@ -12293,7 +12248,7 @@ ix86_can_use_return_insn_p (void)\n   if (crtl->args.pops_args && crtl->args.size >= 32768)\n     return 0;\n \n-  ix86_compute_frame_layout (&frame);\n+  frame = cfun->machine->frame;\n   return (frame.stack_pointer_offset == UNITS_PER_WORD\n \t  && (frame.nregs + frame.nsseregs) == 0);\n }\n@@ -12634,10 +12589,6 @@ ix86_hard_regno_scratch_ok (unsigned int regno)\n \t      && df_regs_ever_live_p (regno)));\n }\n \n-/* Registers who's save & restore will be managed by stubs called from\n-   pro/epilogue.  */\n-static HARD_REG_SET GTY(()) stub_managed_regs;\n-\n /* Return true if register class CL should be an additional allocno\n    class.  */\n \n@@ -12718,9 +12669,13 @@ ix86_save_reg (unsigned int regno, bool maybe_eh_return, bool ignore_outlined)\n \t}\n     }\n \n-  if (ignore_outlined && cfun->machine->call_ms2sysv\n-      && in_hard_reg_set_p (stub_managed_regs, DImode, regno))\n-    return false;\n+  if (ignore_outlined && cfun->machine->call_ms2sysv)\n+    {\n+      unsigned count = cfun->machine->call_ms2sysv_extra_regs\n+\t\t       + xlogue_layout::MIN_REGS;\n+      if (xlogue_layout::is_stub_managed_reg (regno, count))\n+\treturn false;\n+    }\n \n   if (crtl->drap_reg\n       && regno == REGNO (crtl->drap_reg)\n@@ -12787,8 +12742,7 @@ ix86_can_eliminate (const int from, const int to)\n HOST_WIDE_INT\n ix86_initial_elimination_offset (int from, int to)\n {\n-  struct ix86_frame frame;\n-  ix86_compute_frame_layout (&frame);\n+  struct ix86_frame frame = cfun->machine->frame;\n \n   if (from == ARG_POINTER_REGNUM && to == HARD_FRAME_POINTER_REGNUM)\n     return frame.hard_frame_pointer_offset;\n@@ -12818,13 +12772,16 @@ ix86_builtin_setjmp_frame_value (void)\n   return stack_realign_fp ? hard_frame_pointer_rtx : virtual_stack_vars_rtx;\n }\n \n-/* Disables out-of-lined msabi to sysv pro/epilogues and emits a warning if\n-   warn_once is null, or *warn_once is zero.  */\n-static void disable_call_ms2sysv_xlogues (const char *feature)\n+/* Emits a warning for unsupported msabi to sysv pro/epilogues.  */\n+static void warn_once_call_ms2sysv_xlogues (const char *feature)\n {\n-  cfun->machine->call_ms2sysv = false;\n-  warning (OPT_mcall_ms2sysv_xlogues, \"not currently compatible with %s.\",\n-\t   feature);\n+  static bool warned_once = false;\n+  if (!warned_once)\n+    {\n+      warning (0, \"-mcall-ms2sysv-xlogues is not compatible with %s\",\n+\t       feature);\n+      warned_once = true;\n+    }\n }\n \n /* When using -fsplit-stack, the allocation routines set a field in\n@@ -12836,54 +12793,48 @@ static void disable_call_ms2sysv_xlogues (const char *feature)\n /* Fill structure ix86_frame about frame of currently computed function.  */\n \n static void\n-ix86_compute_frame_layout (struct ix86_frame *frame)\n+ix86_compute_frame_layout (void)\n {\n+  struct ix86_frame *frame = &cfun->machine->frame;\n   struct machine_function *m = cfun->machine;\n   unsigned HOST_WIDE_INT stack_alignment_needed;\n   HOST_WIDE_INT offset;\n   unsigned HOST_WIDE_INT preferred_alignment;\n   HOST_WIDE_INT size = get_frame_size ();\n   HOST_WIDE_INT to_allocate;\n \n-  CLEAR_HARD_REG_SET (stub_managed_regs);\n-\n   /* m->call_ms2sysv is initially enabled in ix86_expand_call for all 64-bit\n    * ms_abi functions that call a sysv function.  We now need to prune away\n    * cases where it should be disabled.  */\n   if (TARGET_64BIT && m->call_ms2sysv)\n-  {\n-    gcc_assert (TARGET_64BIT_MS_ABI);\n-    gcc_assert (TARGET_CALL_MS2SYSV_XLOGUES);\n-    gcc_assert (!TARGET_SEH);\n-\n-    if (!TARGET_SSE)\n-      m->call_ms2sysv = false;\n-\n-    /* Don't break hot-patched functions.  */\n-    else if (ix86_function_ms_hook_prologue (current_function_decl))\n-      m->call_ms2sysv = false;\n-\n-    /* TODO: Cases not yet examined.  */\n-    else if (crtl->calls_eh_return)\n-      disable_call_ms2sysv_xlogues (\"__builtin_eh_return\");\n-\n-    else if (ix86_static_chain_on_stack)\n-      disable_call_ms2sysv_xlogues (\"static call chains\");\n+    {\n+      gcc_assert (TARGET_64BIT_MS_ABI);\n+      gcc_assert (TARGET_CALL_MS2SYSV_XLOGUES);\n+      gcc_assert (!TARGET_SEH);\n+      gcc_assert (TARGET_SSE);\n+      gcc_assert (!ix86_using_red_zone ());\n \n-    else if (ix86_using_red_zone ())\n-      disable_call_ms2sysv_xlogues (\"red zones\");\n+      if (crtl->calls_eh_return)\n+\t{\n+\t  gcc_assert (!reload_completed);\n+\t  m->call_ms2sysv = false;\n+\t  warn_once_call_ms2sysv_xlogues (\"__builtin_eh_return\");\n+\t}\n \n-    else if (flag_split_stack)\n-      disable_call_ms2sysv_xlogues (\"split stack\");\n+      else if (ix86_static_chain_on_stack)\n+\t{\n+\t  gcc_assert (!reload_completed);\n+\t  m->call_ms2sysv = false;\n+\t  warn_once_call_ms2sysv_xlogues (\"static call chains\");\n+\t}\n \n-    /* Finally, compute which registers the stub will manage.  */\n-    else\n-      {\n-\tunsigned count = xlogue_layout\n-\t\t\t ::compute_stub_managed_regs (stub_managed_regs);\n-\tm->call_ms2sysv_extra_regs = count - xlogue_layout::MIN_REGS;\n-      }\n-  }\n+      /* Finally, compute which registers the stub will manage.  */\n+      else\n+\t{\n+\t  unsigned count = xlogue_layout::count_stub_managed_regs ();\n+\t  m->call_ms2sysv_extra_regs = count - xlogue_layout::MIN_REGS;\n+\t}\n+    }\n \n   frame->nregs = ix86_nsaved_regs ();\n   frame->nsseregs = ix86_nsaved_sseregs ();\n@@ -12916,19 +12867,11 @@ ix86_compute_frame_layout (struct ix86_frame *frame)\n      in doing anything except PUSHs.  */\n   if (TARGET_SEH)\n     m->use_fast_prologue_epilogue = false;\n-\n-  /* During reload iteration the amount of registers saved can change.\n-     Recompute the value as needed.  Do not recompute when amount of registers\n-     didn't change as reload does multiple calls to the function and does not\n-     expect the decision to change within single iteration.  */\n-  else if (!optimize_bb_for_size_p (ENTRY_BLOCK_PTR_FOR_FN (cfun))\n-\t   && m->use_fast_prologue_epilogue_nregs != frame->nregs)\n+  else if (!optimize_bb_for_size_p (ENTRY_BLOCK_PTR_FOR_FN (cfun)))\n     {\n       int count = frame->nregs;\n       struct cgraph_node *node = cgraph_node::get (current_function_decl);\n \n-      m->use_fast_prologue_epilogue_nregs = count;\n-\n       /* The fast prologue uses move instead of push to save registers.  This\n          is significantly longer, but also executes faster as modern hardware\n          can execute the moves in parallel, but can't do that for push/pop.\n@@ -13145,7 +13088,8 @@ choose_baseaddr_len (unsigned int regno, HOST_WIDE_INT offset)\n \n /* Determine if the stack pointer is valid for accessing the cfa_offset.  */\n \n-static inline bool sp_valid_at (HOST_WIDE_INT cfa_offset)\n+static inline bool\n+sp_valid_at (HOST_WIDE_INT cfa_offset)\n {\n   const struct machine_frame_state &fs = cfun->machine->fs;\n   return fs.sp_valid && !(fs.sp_realigned\n@@ -13154,7 +13098,8 @@ static inline bool sp_valid_at (HOST_WIDE_INT cfa_offset)\n \n /* Determine if the frame pointer is valid for accessing the cfa_offset.  */\n \n-static inline bool fp_valid_at (HOST_WIDE_INT cfa_offset)\n+static inline bool\n+fp_valid_at (HOST_WIDE_INT cfa_offset)\n {\n   const struct machine_frame_state &fs = cfun->machine->fs;\n   return fs.fp_valid && !(fs.sp_valid && fs.sp_realigned\n@@ -13164,9 +13109,10 @@ static inline bool fp_valid_at (HOST_WIDE_INT cfa_offset)\n /* Choose a base register based upon alignment requested, speed and/or\n    size.  */\n \n-static void choose_basereg (HOST_WIDE_INT cfa_offset, rtx &base_reg,\n-\t\t\t    HOST_WIDE_INT &base_offset,\n-\t\t\t    unsigned int align_reqested, unsigned int *align)\n+static void\n+choose_basereg (HOST_WIDE_INT cfa_offset, rtx &base_reg,\n+\t\tHOST_WIDE_INT &base_offset,\n+\t\tunsigned int align_reqested, unsigned int *align)\n {\n   const struct machine_function *m = cfun->machine;\n   unsigned int hfp_align;\n@@ -14159,6 +14105,7 @@ ix86_finalize_stack_realign_flags (void)\n        < (crtl->is_leaf && !ix86_current_function_calls_tls_descriptor\n \t  ? crtl->max_used_stack_slot_alignment\n \t  : crtl->stack_alignment_needed));\n+  bool recompute_frame_layout_p = false;\n \n   if (crtl->stack_realign_finalized)\n     {\n@@ -14208,8 +14155,12 @@ ix86_finalize_stack_realign_flags (void)\n \t\t&& requires_stack_frame_p (insn, prologue_used,\n \t\t\t\t\t   set_up_by_prologue))\n \t      {\n+\t\tif (crtl->stack_realign_needed != stack_realign)\n+\t\t  recompute_frame_layout_p = true;\n \t\tcrtl->stack_realign_needed = stack_realign;\n \t\tcrtl->stack_realign_finalized = true;\n+\t\tif (recompute_frame_layout_p)\n+\t\t  ix86_compute_frame_layout ();\n \t\treturn;\n \t      }\n \t}\n@@ -14240,10 +14191,15 @@ ix86_finalize_stack_realign_flags (void)\n       df_scan_blocks ();\n       df_compute_regs_ever_live (true);\n       df_analyze ();\n+      recompute_frame_layout_p = true;\n     }\n \n+  if (crtl->stack_realign_needed != stack_realign)\n+    recompute_frame_layout_p = true;\n   crtl->stack_realign_needed = stack_realign;\n   crtl->stack_realign_finalized = true;\n+  if (recompute_frame_layout_p)\n+    ix86_compute_frame_layout ();\n }\n \n /* Delete SET_GOT right after entry block if it is allocated to reg.  */\n@@ -14372,7 +14328,7 @@ ix86_expand_prologue (void)\n   m->fs.sp_valid = true;\n   m->fs.sp_realigned = false;\n \n-  ix86_compute_frame_layout (&frame);\n+  frame = m->frame;\n \n   if (!TARGET_64BIT && ix86_function_ms_hook_prologue (current_function_decl))\n     {\n@@ -15212,7 +15168,7 @@ ix86_expand_epilogue (int style)\n   bool restore_stub_is_tail = false;\n \n   ix86_finalize_stack_realign_flags ();\n-  ix86_compute_frame_layout (&frame);\n+  frame = m->frame;\n \n   m->fs.sp_realigned = stack_realign_fp;\n   m->fs.sp_valid = stack_realign_fp\n@@ -15757,7 +15713,7 @@ ix86_expand_split_stack_prologue (void)\n   gcc_assert (flag_split_stack && reload_completed);\n \n   ix86_finalize_stack_realign_flags ();\n-  ix86_compute_frame_layout (&frame);\n+  frame = cfun->machine->frame;\n   allocate = frame.stack_pointer_offset - INCOMING_FRAME_SP_OFFSET;\n \n   /* This is the label we will branch to if we have enough stack\n@@ -29326,7 +29282,24 @@ ix86_expand_call (rtx retval, rtx fnaddr, rtx callarg1,\n \n       /* Set here, but it may get cleared later.  */\n       if (TARGET_CALL_MS2SYSV_XLOGUES)\n-\tcfun->machine->call_ms2sysv = true;\n+\t{\n+\t  if (!TARGET_SSE)\n+\t    ;\n+\n+\t  /* Don't break hot-patched functions.  */\n+\t  else if (ix86_function_ms_hook_prologue (current_function_decl))\n+\t    ;\n+\n+\t  /* TODO: Cases not yet examined.  */\n+\t  else if (flag_split_stack)\n+\t    warn_once_call_ms2sysv_xlogues (\"-fsplit-stack\");\n+\n+\t  else\n+\t    {\n+\t      gcc_assert (!reload_completed);\n+\t      cfun->machine->call_ms2sysv = true;\n+\t    }\n+\t}\n     }\n \n   if (vec_len > 1)\n@@ -29461,7 +29434,6 @@ ix86_init_machine_status (void)\n   struct machine_function *f;\n \n   f = ggc_cleared_alloc<machine_function> ();\n-  f->use_fast_prologue_epilogue_nregs = -1;\n   f->call_abi = ix86_abi;\n \n   return f;\n@@ -31521,8 +31493,12 @@ ix86_static_chain (const_tree fndecl_or_type, bool incoming_p)\n \t     same once we're executing the nested function.  */\n \t  if (incoming_p)\n \t    {\n-\t      if (fndecl == current_function_decl)\n-\t\tix86_static_chain_on_stack = true;\n+\t      if (fndecl == current_function_decl\n+\t\t  && !ix86_static_chain_on_stack)\n+\t\t{\n+\t\t  gcc_assert (!reload_completed);\n+\t\t  ix86_static_chain_on_stack = true;\n+\t\t}\n \t      return gen_frame_mem (SImode,\n \t\t\t\t    plus_constant (Pmode,\n \t\t\t\t\t\t   arg_pointer_rtx, -8));\n@@ -52833,6 +52809,9 @@ ix86_run_selftests (void)\n #undef TARGET_LEGITIMATE_CONSTANT_P\n #define TARGET_LEGITIMATE_CONSTANT_P ix86_legitimate_constant_p\n \n+#undef TARGET_COMPUTE_FRAME_LAYOUT\n+#define TARGET_COMPUTE_FRAME_LAYOUT ix86_compute_frame_layout\n+\n #undef TARGET_FRAME_POINTER_REQUIRED\n #define TARGET_FRAME_POINTER_REQUIRED ix86_frame_pointer_required\n "}, {"sha": "08243c16498240b6b7b003a2cbaf84a0df193ba7", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 70, "deletions": 9, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77560086aa85c75cba3bd874f1a11130bc76cfad/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77560086aa85c75cba3bd874f1a11130bc76cfad/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=77560086aa85c75cba3bd874f1a11130bc76cfad", "patch": "@@ -2163,10 +2163,6 @@ extern int const dbx_register_map[FIRST_PSEUDO_REGISTER];\n extern int const dbx64_register_map[FIRST_PSEUDO_REGISTER];\n extern int const svr4_dbx_register_map[FIRST_PSEUDO_REGISTER];\n \n-extern unsigned const x86_64_ms_sysv_extra_clobbered_registers[12];\n-#define NUM_X86_64_MS_CLOBBERED_REGS \\\n-  (ARRAY_SIZE (x86_64_ms_sysv_extra_clobbered_registers))\n-\n /* Before the prologue, RA is at 0(%esp).  */\n #define INCOMING_RETURN_ADDR_RTX \\\n   gen_rtx_MEM (Pmode, gen_rtx_REG (Pmode, STACK_POINTER_REGNUM))\n@@ -2448,9 +2444,76 @@ enum avx_u128_state\n \f\n #define FASTCALL_PREFIX '@'\n \f\n+#ifndef USED_FOR_TARGET\n+/* Structure describing stack frame layout.\n+   Stack grows downward:\n+\n+   [arguments]\n+\t\t\t\t\t<- ARG_POINTER\n+   saved pc\n+\n+   saved static chain\t\t\tif ix86_static_chain_on_stack\n+\n+   saved frame pointer\t\t\tif frame_pointer_needed\n+\t\t\t\t\t<- HARD_FRAME_POINTER\n+   [saved regs]\n+\t\t\t\t\t<- reg_save_offset\n+   [padding0]\n+\t\t\t\t\t<- stack_realign_offset\n+   [saved SSE regs]\n+\tOR\n+   [stub-saved registers for ms x64 --> sysv clobbers\n+\t\t\t<- Start of out-of-line, stub-saved/restored regs\n+\t\t\t   (see libgcc/config/i386/(sav|res)ms64*.S)\n+     [XMM6-15]\n+     [RSI]\n+     [RDI]\n+     [?RBX]\t\tonly if RBX is clobbered\n+     [?RBP]\t\tonly if RBP and RBX are clobbered\n+     [?R12]\t\tonly if R12 and all previous regs are clobbered\n+     [?R13]\t\tonly if R13 and all previous regs are clobbered\n+     [?R14]\t\tonly if R14 and all previous regs are clobbered\n+     [?R15]\t\tonly if R15 and all previous regs are clobbered\n+\t\t\t<- end of stub-saved/restored regs\n+     [padding1]\n+   ]\n+\t\t\t\t\t<- outlined_save_offset\n+\t\t\t\t\t<- sse_regs_save_offset\n+   [padding2]\n+\t\t       |\t\t<- FRAME_POINTER\n+   [va_arg registers]  |\n+\t\t       |\n+   [frame]\t       |\n+\t\t       |\n+   [padding2]\t       | = to_allocate\n+\t\t\t\t\t<- STACK_POINTER\n+  */\n+struct GTY(()) ix86_frame\n+{\n+  int nsseregs;\n+  int nregs;\n+  int va_arg_size;\n+  int red_zone_size;\n+  int outgoing_arguments_size;\n+\n+  /* The offsets relative to ARG_POINTER.  */\n+  HOST_WIDE_INT frame_pointer_offset;\n+  HOST_WIDE_INT hard_frame_pointer_offset;\n+  HOST_WIDE_INT stack_pointer_offset;\n+  HOST_WIDE_INT hfp_save_offset;\n+  HOST_WIDE_INT reg_save_offset;\n+  HOST_WIDE_INT stack_realign_allocate_offset;\n+  HOST_WIDE_INT stack_realign_offset;\n+  HOST_WIDE_INT outlined_save_offset;\n+  HOST_WIDE_INT sse_reg_save_offset;\n+\n+  /* When save_regs_using_mov is set, emit prologue using\n+     move instead of push instructions.  */\n+  bool save_regs_using_mov;\n+};\n+\n /* Machine specific frame tracking during prologue/epilogue generation.  */\n \n-#ifndef USED_FOR_TARGET\n struct GTY(()) machine_frame_state\n {\n   /* This pair tracks the currently active CFA as reg+offset.  When reg\n@@ -2515,14 +2578,12 @@ enum function_type\n \n struct GTY(()) machine_function {\n   struct stack_local_entry *stack_locals;\n-  const char *some_ld_name;\n   int varargs_gpr_size;\n   int varargs_fpr_size;\n   int optimize_mode_switching[MAX_386_ENTITIES];\n \n-  /* Number of saved registers USE_FAST_PROLOGUE_EPILOGUE\n-     has been computed for.  */\n-  int use_fast_prologue_epilogue_nregs;\n+  /* Cached initial frame layout for the current function.  */\n+  struct ix86_frame frame;\n \n   /* For -fsplit-stack support: A stack local which holds a pointer to\n      the stack arguments for a function with a variable number of"}]}