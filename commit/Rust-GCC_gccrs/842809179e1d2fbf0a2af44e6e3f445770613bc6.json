{"sha": "842809179e1d2fbf0a2af44e6e3f445770613bc6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODQyODA5MTc5ZTFkMmZiZjBhMmFmNDRlNmUzZjQ0NTc3MDYxM2JjNg==", "commit": {"author": {"name": "Michael Matz", "email": "matz@suse.de", "date": "2009-10-26T13:00:36Z"}, "committer": {"name": "Michael Matz", "email": "matz@gcc.gnu.org", "date": "2009-10-26T13:00:36Z"}, "message": "re PR tree-optimization/41783 (r151561 (PRE fix) regresses zeusmp)\n\n\tPR tree-optimization/41783\n\t* tree-ssa-alias.c (get_continuation_for_phi): Export, add a special\n\tcase for simple diamonds\n\t* tree-ssa-alias.h (get_continuation_for_phi): Declare.\n\t* tree-ssa-pre.c (translate_vuse_through_block): Add same_valid\n\targument, use alias oracle to skip some vdefs.\n\t(phi_translate_1): Change call to above, don't allocate new\n\tvalue ids if they can stay the same.\n\t(compute_avail): Allow vuse walking when looking up references.\n\ntestsuite/\n\t* gcc.dg/pr41783.c: New test.\n\t* gcc.dg/tree-ssa/ssa-pre-23.c: Adjust.\n\t* gcc.dg/tree-ssa/ssa-pre-24.c: Don't xfail anymore.\n\t* gcc.dg/tree-ssa/ssa-pre-27.c: New test.\n\nFrom-SVN: r153551", "tree": {"sha": "fbb6277956a1693b32bea61a71c9fbf0f2321aee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fbb6277956a1693b32bea61a71c9fbf0f2321aee"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/842809179e1d2fbf0a2af44e6e3f445770613bc6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/842809179e1d2fbf0a2af44e6e3f445770613bc6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/842809179e1d2fbf0a2af44e6e3f445770613bc6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/842809179e1d2fbf0a2af44e6e3f445770613bc6/comments", "author": {"login": "susematz", "id": 4117296, "node_id": "MDQ6VXNlcjQxMTcyOTY=", "avatar_url": "https://avatars.githubusercontent.com/u/4117296?v=4", "gravatar_id": "", "url": "https://api.github.com/users/susematz", "html_url": "https://github.com/susematz", "followers_url": "https://api.github.com/users/susematz/followers", "following_url": "https://api.github.com/users/susematz/following{/other_user}", "gists_url": "https://api.github.com/users/susematz/gists{/gist_id}", "starred_url": "https://api.github.com/users/susematz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/susematz/subscriptions", "organizations_url": "https://api.github.com/users/susematz/orgs", "repos_url": "https://api.github.com/users/susematz/repos", "events_url": "https://api.github.com/users/susematz/events{/privacy}", "received_events_url": "https://api.github.com/users/susematz/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "bd02b3a0c9223cecb7ec0367ecae6c76bbcd9b50", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd02b3a0c9223cecb7ec0367ecae6c76bbcd9b50", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bd02b3a0c9223cecb7ec0367ecae6c76bbcd9b50"}], "stats": {"total": 166, "additions": 129, "deletions": 37}, "files": [{"sha": "53a554ed6c9a8d072f6e53ef91824483d3932f9f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/842809179e1d2fbf0a2af44e6e3f445770613bc6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/842809179e1d2fbf0a2af44e6e3f445770613bc6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=842809179e1d2fbf0a2af44e6e3f445770613bc6", "patch": "@@ -1,3 +1,15 @@\n+2009-10-26  Michael Matz  <matz@suse.de>\n+\n+\tPR tree-optimization/41783\n+\t* tree-ssa-alias.c (get_continuation_for_phi): Export, add a special\n+\tcase for simple diamonds.\n+\t* tree-ssa-alias.h (get_continuation_for_phi): Declare.\n+\t* tree-ssa-pre.c (translate_vuse_through_block): Add same_valid\n+\targument, use alias oracle to skip some vdefs.\n+\t(phi_translate_1): Change call to above, don't allocate new\n+\tvalue ids if they can stay the same.\n+\t(compute_avail): Allow vuse walking when looking up references.\n+\n 2009-10-26  Richard Guenther  <rguenther@suse.de>\n \n \tPR tree-optimization/41826"}, {"sha": "0b33f9813a99261e4ee3480094cebf4d18803dc6", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/842809179e1d2fbf0a2af44e6e3f445770613bc6/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/842809179e1d2fbf0a2af44e6e3f445770613bc6/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=842809179e1d2fbf0a2af44e6e3f445770613bc6", "patch": "@@ -1,3 +1,11 @@\n+2009-10-26  Michael Matz  <matz@suse.de>\n+\n+\tPR tree-optimization/41783\n+\t* gcc.dg/pr41783.c: New test.\n+\t* gcc.dg/tree-ssa/ssa-pre-23.c: Adjust.\n+\t* gcc.dg/tree-ssa/ssa-pre-24.c: Don't xfail anymore.\n+\t* gcc.dg/tree-ssa/ssa-pre-27.c: New test.\n+\n 2009-10-26  Janus Weil  <janus@gcc.gnu.org>\n \n \tPR fortran/41714"}, {"sha": "cae066be6f485b3bb58d7d2454fff653183bff52", "filename": "gcc/testsuite/gcc.dg/pr41783.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/842809179e1d2fbf0a2af44e6e3f445770613bc6/gcc%2Ftestsuite%2Fgcc.dg%2Fpr41783.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/842809179e1d2fbf0a2af44e6e3f445770613bc6/gcc%2Ftestsuite%2Fgcc.dg%2Fpr41783.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr41783.c?ref=842809179e1d2fbf0a2af44e6e3f445770613bc6", "patch": "@@ -0,0 +1,20 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -fdump-tree-pre\" } */\n+int db[100];\n+int a_global_var, fact;\n+int main()\n+{\n+  int i,j=0;\n+  do\n+    {\n+      for (i=0; i<100; ++i)\n+        db[i] = i;\n+      fact = a_global_var * i;\n+    }\n+  while (j++ < 100);\n+}\n+/* We want to have exactly one load (not two) from a_global_var,\n+   and we want that load to be into a PRE temporary.  */\n+/* { dg-final { scan-tree-dump-times \"= a_global_var;\" 1 \"pre\" } } */\n+/* { dg-final { scan-tree-dump \"pretmp\\[^\\\\n\\]* = a_global_var;\" \"pre\" } } */\n+/* { dg-final { cleanup-tree-dump \"pre\" } } */"}, {"sha": "6aeb06af9ee8425cc0b95c92e181fded0085806e", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-pre-23.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/842809179e1d2fbf0a2af44e6e3f445770613bc6/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-pre-23.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/842809179e1d2fbf0a2af44e6e3f445770613bc6/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-pre-23.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-pre-23.c?ref=842809179e1d2fbf0a2af44e6e3f445770613bc6", "patch": "@@ -9,5 +9,5 @@ void foo(int n)\n     global.y += global.x*global.x;\n }\n \n-/* { dg-final { scan-tree-dump \"Eliminated: 2\" \"pre\" } } */\n+/* { dg-final { scan-tree-dump \"Eliminated: 3\" \"pre\" } } */\n /* { dg-final { cleanup-tree-dump \"pre\" } } */"}, {"sha": "f91f4af74df231bee913e8ac04824c18f11a92bb", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-pre-24.c", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/842809179e1d2fbf0a2af44e6e3f445770613bc6/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-pre-24.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/842809179e1d2fbf0a2af44e6e3f445770613bc6/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-pre-24.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-pre-24.c?ref=842809179e1d2fbf0a2af44e6e3f445770613bc6", "patch": "@@ -9,12 +9,7 @@ void foo(int *p, double *x, int n)\n }\n \n /* We should remove the unnecessary insertion of a phi-node and\n-   _not_ end up using the phi result for replacement *p.\n-   The issue here is that when PHI-translating the virtual operands\n-   we assign different value-numbers to the load.  Re-running VN\n-   after insertion or trying to be clever and doing this on the\n-   fly during PHI translation would solve this.  The next copyprop\n-   fixes this anyway.  */\n+   _not_ end up using the phi result for replacement *p.  */\n \n-/* { dg-final { scan-tree-dump-not \"= prephitmp\" \"pre\" { xfail *-*-* } } } */\n+/* { dg-final { scan-tree-dump-not \"= prephitmp\" \"pre\" } } */\n /* { dg-final { cleanup-tree-dump \"pre\" } } */"}, {"sha": "fbd047085daad0544a5ce7f28f0a6a10903c6846", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 22, "deletions": 3, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/842809179e1d2fbf0a2af44e6e3f445770613bc6/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/842809179e1d2fbf0a2af44e6e3f445770613bc6/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=842809179e1d2fbf0a2af44e6e3f445770613bc6", "patch": "@@ -1313,8 +1313,6 @@ stmt_may_clobber_ref_p (gimple stmt, tree ref)\n }\n \n \n-static tree get_continuation_for_phi (gimple, ao_ref *, bitmap *);\n-\n /* Walk the virtual use-def chain of VUSE until hitting the virtual operand\n    TARGET or a statement clobbering the memory reference REF in which\n    case false is returned.  The walk starts with VUSE, one argument of PHI.  */\n@@ -1358,7 +1356,7 @@ maybe_skip_until (gimple phi, tree target, ao_ref *ref,\n    clobber REF.  Returns NULL_TREE if no suitable virtual operand can\n    be found.  */\n \n-static tree\n+tree\n get_continuation_for_phi (gimple phi, ao_ref *ref, bitmap *visited)\n {\n   unsigned nargs = gimple_phi_num_args (phi);\n@@ -1375,6 +1373,7 @@ get_continuation_for_phi (gimple phi, ao_ref *ref, bitmap *visited)\n       tree arg1 = PHI_ARG_DEF (phi, 1);\n       gimple def0 = SSA_NAME_DEF_STMT (arg0);\n       gimple def1 = SSA_NAME_DEF_STMT (arg1);\n+      tree common_vuse;\n \n       if (arg0 == arg1)\n \treturn arg0;\n@@ -1393,6 +1392,26 @@ get_continuation_for_phi (gimple phi, ao_ref *ref, bitmap *visited)\n \t  if (maybe_skip_until (phi, arg1, ref, arg0, visited))\n \t    return arg1;\n \t}\n+      /* Special case of a diamond:\n+\t   MEM_1 = ...\n+\t   goto (cond) ? L1 : L2\n+\t   L1: store1 = ...    #MEM_2 = vuse(MEM_1)\n+\t       goto L3\n+\t   L2: store2 = ...    #MEM_3 = vuse(MEM_1)\n+\t   L3: MEM_4 = PHI<MEM_2, MEM_3>\n+\t We were called with the PHI at L3, MEM_2 and MEM_3 don't\n+\t dominate each other, but still we can easily skip this PHI node\n+\t if we recognize that the vuse MEM operand is the same for both,\n+\t and that we can skip both statements (they don't clobber us).\n+\t This is still linear.  Don't use maybe_skip_until, that might\n+\t potentially be slow.  */\n+      else if ((common_vuse = gimple_vuse (def0))\n+\t       && common_vuse == gimple_vuse (def1))\n+\t{\n+\t  if (!stmt_may_clobber_ref_p_1 (def0, ref)\n+\t      && !stmt_may_clobber_ref_p_1 (def1, ref))\n+\t    return common_vuse;\n+\t}\n     }\n \n   return NULL_TREE;"}, {"sha": "289fb86d04ca45d60d6d784a7082d255827da0bb", "filename": "gcc/tree-ssa-alias.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/842809179e1d2fbf0a2af44e6e3f445770613bc6/gcc%2Ftree-ssa-alias.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/842809179e1d2fbf0a2af44e6e3f445770613bc6/gcc%2Ftree-ssa-alias.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.h?ref=842809179e1d2fbf0a2af44e6e3f445770613bc6", "patch": "@@ -99,6 +99,7 @@ extern bool refs_output_dependent_p (tree, tree);\n extern bool ref_maybe_used_by_stmt_p (gimple, tree);\n extern bool stmt_may_clobber_ref_p (gimple, tree);\n extern bool stmt_may_clobber_ref_p_1 (gimple, ao_ref *);\n+extern tree get_continuation_for_phi (gimple, ao_ref *, bitmap *);\n extern void *walk_non_aliased_vuses (ao_ref *, tree,\n \t\t\t\t     void *(*)(ao_ref *, tree, void *),\n \t\t\t\t     void *(*)(ao_ref *, tree, void *), void *);"}, {"sha": "2ef6d76a40a6682641271246a11d519810e5e984", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 63, "deletions": 26, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/842809179e1d2fbf0a2af44e6e3f445770613bc6/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/842809179e1d2fbf0a2af44e6e3f445770613bc6/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=842809179e1d2fbf0a2af44e6e3f445770613bc6", "patch": "@@ -1243,43 +1243,74 @@ fully_constant_expression (pre_expr e)\n }\n \n /* Translate the VUSE backwards through phi nodes in PHIBLOCK, so that\n-   it has the value it would have in BLOCK.  */\n+   it has the value it would have in BLOCK.  Set *SAME_VALID to true\n+   in case the new vuse doesn't change the value id of the OPERANDS.  */\n \n static tree\n translate_vuse_through_block (VEC (vn_reference_op_s, heap) *operands,\n \t\t\t      alias_set_type set, tree type, tree vuse,\n \t\t\t      basic_block phiblock,\n-\t\t\t      basic_block block)\n+\t\t\t      basic_block block, bool *same_valid)\n {\n   gimple phi = SSA_NAME_DEF_STMT (vuse);\n   ao_ref ref;\n+  edge e = NULL;\n+  bool use_oracle;\n+\n+  *same_valid = true;\n \n   if (gimple_bb (phi) != phiblock)\n     return vuse;\n \n-  if (gimple_code (phi) == GIMPLE_PHI)\n-    {\n-      edge e = find_edge (block, phiblock);\n-      return PHI_ARG_DEF (phi, e->dest_idx);\n-    }\n-\n-  if (!ao_ref_init_from_vn_reference (&ref, set, type, operands))\n-    return NULL_TREE;\n+  use_oracle = ao_ref_init_from_vn_reference (&ref, set, type, operands);\n \n   /* Use the alias-oracle to find either the PHI node in this block,\n      the first VUSE used in this block that is equivalent to vuse or\n      the first VUSE which definition in this block kills the value.  */\n-  while (!stmt_may_clobber_ref_p_1 (phi, &ref))\n+  if (gimple_code (phi) == GIMPLE_PHI)\n+    e = find_edge (block, phiblock);\n+  else if (use_oracle)\n+    while (!stmt_may_clobber_ref_p_1 (phi, &ref))\n+      {\n+\tvuse = gimple_vuse (phi);\n+\tphi = SSA_NAME_DEF_STMT (vuse);\n+\tif (gimple_bb (phi) != phiblock)\n+\t  return vuse;\n+\tif (gimple_code (phi) == GIMPLE_PHI)\n+\t  {\n+\t    e = find_edge (block, phiblock);\n+\t    break;\n+\t  }\n+      }\n+  else\n+    return NULL_TREE;\n+\n+  if (e)\n     {\n-      vuse = gimple_vuse (phi);\n-      phi = SSA_NAME_DEF_STMT (vuse);\n-      if (gimple_bb (phi) != phiblock)\n-\treturn vuse;\n-      if (gimple_code (phi) == GIMPLE_PHI)\n+      if (use_oracle)\n \t{\n-\t  edge e = find_edge (block, phiblock);\n-\t  return PHI_ARG_DEF (phi, e->dest_idx);\n+\t  bitmap visited = NULL;\n+\t  /* Try to find a vuse that dominates this phi node by skipping\n+\t     non-clobbering statements.  */\n+\t  vuse = get_continuation_for_phi (phi, &ref, &visited);\n+\t  if (visited)\n+\t    BITMAP_FREE (visited);\n \t}\n+      else\n+\tvuse = NULL_TREE;\n+      if (!vuse)\n+\t{\n+\t  /* If we didn't find any, the value ID can't stay the same,\n+\t     but return the translated vuse.  */\n+\t  *same_valid = false;\n+\t  vuse = PHI_ARG_DEF (phi, e->dest_idx);\n+\t}\n+      /* ??? We would like to return vuse here as this is the canonical\n+         upmost vdef that this reference is associated with.  But during\n+\t insertion of the references into the hash tables we only ever\n+\t directly insert with their direct gimple_vuse, hence returning\n+\t something else would make us not find the other expression.  */\n+      return PHI_ARG_DEF (phi, e->dest_idx);\n     }\n \n   return NULL_TREE;\n@@ -1541,7 +1572,7 @@ phi_translate_1 (pre_expr expr, bitmap_set_t set1, bitmap_set_t set2,\n \ttree vuse = ref->vuse;\n \ttree newvuse = vuse;\n \tVEC (vn_reference_op_s, heap) *newoperands = NULL;\n-\tbool changed = false;\n+\tbool changed = false, same_valid = true;\n \tunsigned int i, j;\n \tvn_reference_op_t operand;\n \tvn_reference_t newref;\n@@ -1647,16 +1678,16 @@ phi_translate_1 (pre_expr expr, bitmap_set_t set1, bitmap_set_t set2,\n \t  {\n \t    newvuse = translate_vuse_through_block (newoperands,\n \t\t\t\t\t\t    ref->set, ref->type,\n-\t\t\t\t\t\t    vuse, phiblock, pred);\n+\t\t\t\t\t\t    vuse, phiblock, pred,\n+\t\t\t\t\t\t    &same_valid);\n \t    if (newvuse == NULL_TREE)\n \t      {\n \t\tVEC_free (vn_reference_op_s, heap, newoperands);\n \t\treturn NULL;\n \t      }\n \t  }\n-\tchanged |= newvuse != vuse;\n \n-\tif (changed)\n+\tif (changed || newvuse != vuse)\n \t  {\n \t    unsigned int new_val_id;\n \t    pre_expr constant;\n@@ -1690,9 +1721,15 @@ phi_translate_1 (pre_expr expr, bitmap_set_t set1, bitmap_set_t set2,\n \t      }\n \t    else\n \t      {\n-\t\tnew_val_id = get_next_value_id ();\n-\t\tVEC_safe_grow_cleared (bitmap_set_t, heap, value_expressions,\n-\t\t\t\t       get_max_value_id() + 1);\n+\t\tif (changed || !same_valid)\n+\t\t  {\n+\t\t    new_val_id = get_next_value_id ();\n+\t\t    VEC_safe_grow_cleared (bitmap_set_t, heap,\n+\t\t\t\t\t   value_expressions,\n+\t\t\t\t\t   get_max_value_id() + 1);\n+\t\t  }\n+\t\telse\n+\t\t  new_val_id = ref->value_id;\n \t\tnewref = vn_reference_insert_pieces (newvuse, ref->set,\n \t\t\t\t\t\t     ref->type,\n \t\t\t\t\t\t     newoperands,\n@@ -3914,7 +3951,7 @@ compute_avail (void)\n \n \t\t      vn_reference_lookup (gimple_assign_rhs1 (stmt),\n \t\t\t\t\t   gimple_vuse (stmt),\n-\t\t\t\t\t   false, &ref);\n+\t\t\t\t\t   true, &ref);\n \t\t      if (!ref)\n \t\t\tcontinue;\n "}]}