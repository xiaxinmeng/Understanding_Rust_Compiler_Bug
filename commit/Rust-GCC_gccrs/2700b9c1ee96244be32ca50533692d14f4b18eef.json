{"sha": "2700b9c1ee96244be32ca50533692d14f4b18eef", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjcwMGI5YzFlZTk2MjQ0YmUzMmNhNTA1MzM2OTJkMTRmNGIxOGVlZg==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2015-10-23T12:28:53Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2015-10-23T12:28:53Z"}, "message": "[multiple changes]\n\n2015-10-23  Arnaud Charlet  <charlet@adacore.com>\n\n\t* gnat1drv.adb (Adjust_Global_Switches): Adjust.\n\n2015-10-23  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* exp_dbug.ads, exp_dbug.adb (Get_External_Name): The special prefix for\n\tignored Ghost entities is now ___ghost_.\n\n2015-10-23  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* ghost.adb (Is_Subject_To_Ghost): Check the\n\toriginal node when searching for pragma Ghost to catch cases\n\twhere a source construct has been rewritten into something else.\n\n2015-10-23  Ed Schonberg  <schonberg@adacore.com>\n\n\t* einfo.ads, einfo.adb (Rewritten_For_C): New flag on functions\n\tthat return a constrained array type.  When generating C these\n\tfunctions are rewritten as procedures with an out parameter,\n\tand calls to such functions are rewritten accordingly.\n\t* exp_ch6.adb (Expand_N_Subprogram_Declaration): When\n\tModify_Tree_For_C is set and the function returns a constrained\n\tarray type, generate a procedure declaration with an additional\n\tout parameter. Mark original function as Rewritten_For_C.\n\tThe new declaration is inserted in tree immediately after\n\tcurrent declaration.\n\t(Expand_Subprogram_Body): If entity is marked Rewritten_For_C,\n\tgenerate body of corresponding procedure using declarations\n\tand statements for function body. Replace return statements\n\twith assignments to the out parameter, followed by a simple\n\treturn statement.\n\t(Rewrite_Function_Call_For_C): New procedure to replace a function\n\tcall that returns an array by a procedure call.\n\nFrom-SVN: r229241", "tree": {"sha": "0cf742fa5af1da89751bbbfb3ac260daceee4651", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0cf742fa5af1da89751bbbfb3ac260daceee4651"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2700b9c1ee96244be32ca50533692d14f4b18eef", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2700b9c1ee96244be32ca50533692d14f4b18eef", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2700b9c1ee96244be32ca50533692d14f4b18eef", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2700b9c1ee96244be32ca50533692d14f4b18eef/comments", "author": null, "committer": null, "parents": [{"sha": "774454ac020f8c6a583393405ff8409d0b2f40fd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/774454ac020f8c6a583393405ff8409d0b2f40fd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/774454ac020f8c6a583393405ff8409d0b2f40fd"}], "stats": {"total": 409, "additions": 384, "deletions": 25}, "files": [{"sha": "4851d5dbc41820fdb773ff50aef24a8d1df98b26", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2700b9c1ee96244be32ca50533692d14f4b18eef/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2700b9c1ee96244be32ca50533692d14f4b18eef/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=2700b9c1ee96244be32ca50533692d14f4b18eef", "patch": "@@ -1,3 +1,38 @@\n+2015-10-23  Arnaud Charlet  <charlet@adacore.com>\n+\n+\t* gnat1drv.adb (Adjust_Global_Switches): Adjust.\n+\n+2015-10-23  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* exp_dbug.ads, exp_dbug.adb (Get_External_Name): The special prefix for\n+\tignored Ghost entities is now ___ghost_.\n+\n+2015-10-23  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* ghost.adb (Is_Subject_To_Ghost): Check the\n+\toriginal node when searching for pragma Ghost to catch cases\n+\twhere a source construct has been rewritten into something else.\n+\n+2015-10-23  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* einfo.ads, einfo.adb (Rewritten_For_C): New flag on functions\n+\tthat return a constrained array type.  When generating C these\n+\tfunctions are rewritten as procedures with an out parameter,\n+\tand calls to such functions are rewritten accordingly.\n+\t* exp_ch6.adb (Expand_N_Subprogram_Declaration): When\n+\tModify_Tree_For_C is set and the function returns a constrained\n+\tarray type, generate a procedure declaration with an additional\n+\tout parameter. Mark original function as Rewritten_For_C.\n+\tThe new declaration is inserted in tree immediately after\n+\tcurrent declaration.\n+\t(Expand_Subprogram_Body): If entity is marked Rewritten_For_C,\n+\tgenerate body of corresponding procedure using declarations\n+\tand statements for function body. Replace return statements\n+\twith assignments to the out parameter, followed by a simple\n+\treturn statement.\n+\t(Rewrite_Function_Call_For_C): New procedure to replace a function\n+\tcall that returns an array by a procedure call.\n+\n 2015-10-23  Hristian Kirtchev  <kirtchev@adacore.com>\n \n \t* sem_util.adb (Denotes_Iterator): New routine."}, {"sha": "5cca0fa11c7951034ec859b1c20c677759a4c6ee", "filename": "gcc/ada/einfo.adb", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2700b9c1ee96244be32ca50533692d14f4b18eef/gcc%2Fada%2Feinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2700b9c1ee96244be32ca50533692d14f4b18eef/gcc%2Fada%2Feinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.adb?ref=2700b9c1ee96244be32ca50533692d14f4b18eef", "patch": "@@ -597,8 +597,8 @@ package body Einfo is\n    --    Is_Unimplemented                Flag284\n    --    Is_Volatile_Full_Access         Flag285\n    --    Needs_Typedef                   Flag286\n+   --    Rewritten_For_C                 Flag287\n \n-   --    (unused)                        Flag287\n    --    (unused)                        Flag288\n    --    (unused)                        Flag289\n    --    (unused)                        Flag300\n@@ -3042,6 +3042,12 @@ package body Einfo is\n       return Flag93 (Base_Type (Id));\n    end Reverse_Storage_Order;\n \n+   function Rewritten_For_C (Id : E) return B is\n+   begin\n+      pragma Assert (Ekind (Id) = E_Function);\n+      return Flag287 (Id);\n+   end Rewritten_For_C;\n+\n    function RM_Size (Id : E) return U is\n    begin\n       pragma Assert (Is_Type (Id));\n@@ -6046,6 +6052,12 @@ package body Einfo is\n       Set_Flag93 (Id, V);\n    end Set_Reverse_Storage_Order;\n \n+   procedure Set_Rewritten_For_C (Id : E; V : B := True) is\n+   begin\n+      pragma Assert (Ekind (Id) = E_Function);\n+      Set_Flag287 (Id, V);\n+   end Set_Rewritten_For_C;\n+\n    procedure Set_RM_Size (Id : E; V : U) is\n    begin\n       pragma Assert (Is_Type (Id));\n@@ -8964,6 +8976,7 @@ package body Einfo is\n       W (\"Returns_Limited_View\",            Flag134 (Id));\n       W (\"Reverse_Bit_Order\",               Flag164 (Id));\n       W (\"Reverse_Storage_Order\",           Flag93  (Id));\n+      W (\"Rewritten_For_C\",                 Flag287 (Id));\n       W (\"Sec_Stack_Needed_For_Return\",     Flag167 (Id));\n       W (\"Size_Depends_On_Discriminant\",    Flag177 (Id));\n       W (\"Size_Known_At_Compile_Time\",      Flag92  (Id));\n@@ -10246,6 +10259,9 @@ package body Einfo is\n    procedure Write_Field38_Name (Id : Entity_Id) is\n    begin\n       case Ekind (Id) is\n+         when E_Function | E_Procedure                     =>\n+            Write_Str (\"Class-wide preconditions\");\n+\n          when others                                       =>\n             Write_Str (\"Field38??\");\n       end case;\n@@ -10258,6 +10274,9 @@ package body Einfo is\n    procedure Write_Field39_Name (Id : Entity_Id) is\n    begin\n       case Ekind (Id) is\n+         when E_Function | E_Procedure                     =>\n+            Write_Str (\"Class-wide postcondition\");\n+\n          when others                                       =>\n             Write_Str (\"Field39??\");\n       end case;"}, {"sha": "b27405f2477fb9852395225841689cce70431e77", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2700b9c1ee96244be32ca50533692d14f4b18eef/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2700b9c1ee96244be32ca50533692d14f4b18eef/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=2700b9c1ee96244be32ca50533692d14f4b18eef", "patch": "@@ -3943,6 +3943,12 @@ package Einfo is\n --       the Bit_Order aspect must be set to the same value (either explicitly\n --       or as the target default value).\n \n+--    Rewritten_For_C (Flag287)\n+--       Defined on functions that return a constrained array type, when\n+--       Modify_Tree_For_C is set. indicates that a procedure with an extra\n+--       out parameter has been created for it, and calls must be rewritten as\n+--       calls to the new procedure.\n+\n --    RM_Size (Uint13)\n --       Defined in all type and subtype entities. Contains the value of\n --       type'Size as defined in the RM. See also the Esize field and\n@@ -5908,6 +5914,7 @@ package Einfo is\n    --    Return_Present                      (Flag54)\n    --    Returns_By_Ref                      (Flag90)\n    --    Returns_Limited_View                (Flag134)  (non-generic case only)\n+   --    Rewritten_For_C                     (Flag287)\n    --    Sec_Stack_Needed_For_Return         (Flag167)\n    --    SPARK_Pragma_Inherited              (Flag265)\n    --    Uses_Sec_Stack                      (Flag95)\n@@ -7078,6 +7085,7 @@ package Einfo is\n    function Returns_Limited_View                (Id : E) return B;\n    function Reverse_Bit_Order                   (Id : E) return B;\n    function Reverse_Storage_Order               (Id : E) return B;\n+   function Rewritten_For_C                     (Id : E) return B;\n    function RM_Size                             (Id : E) return U;\n    function Scalar_Range                        (Id : E) return N;\n    function Scale_Value                         (Id : E) return U;\n@@ -7743,6 +7751,7 @@ package Einfo is\n    procedure Set_Returns_Limited_View            (Id : E; V : B := True);\n    procedure Set_Reverse_Bit_Order               (Id : E; V : B := True);\n    procedure Set_Reverse_Storage_Order           (Id : E; V : B := True);\n+   procedure Set_Rewritten_For_C                 (Id : E; V : B := True);\n    procedure Set_RM_Size                         (Id : E; V : U);\n    procedure Set_Scalar_Range                    (Id : E; V : N);\n    procedure Set_Scale_Value                     (Id : E; V : U);\n@@ -8564,6 +8573,7 @@ package Einfo is\n    pragma Inline (Returns_Limited_View);\n    pragma Inline (Reverse_Bit_Order);\n    pragma Inline (Reverse_Storage_Order);\n+   pragma Inline (Rewritten_For_C);\n    pragma Inline (RM_Size);\n    pragma Inline (Scalar_Range);\n    pragma Inline (Scale_Value);\n@@ -9024,6 +9034,7 @@ package Einfo is\n    pragma Inline (Set_Returns_Limited_View);\n    pragma Inline (Set_Reverse_Bit_Order);\n    pragma Inline (Set_Reverse_Storage_Order);\n+   pragma Inline (Set_Rewritten_For_C);\n    pragma Inline (Set_RM_Size);\n    pragma Inline (Set_Scalar_Range);\n    pragma Inline (Set_Scale_Value);"}, {"sha": "ca0f33b4bf5275105ba803ee0fd16840e5a9735b", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 306, "deletions": 17, "changes": 323, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2700b9c1ee96244be32ca50533692d14f4b18eef/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2700b9c1ee96244be32ca50533692d14f4b18eef/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=2700b9c1ee96244be32ca50533692d14f4b18eef", "patch": "@@ -258,6 +258,10 @@ package body Exp_Ch6 is\n    --  Expand simple return from function. In the case where we are returning\n    --  from a function body this is called by Expand_N_Simple_Return_Statement.\n \n+   procedure Rewrite_Function_Call_For_C (N : Node_Id);\n+   --  When generating C code, replace a call to a function that returns an\n+   --  array into the generated procedure with an additional out parameter.\n+\n    procedure Set_Enclosing_Sec_Stack_Return (N : Node_Id);\n    --  N is a return statement for a function that returns its result on the\n    --  secondary stack. This sets the Sec_Stack_Needed_For_Return flag on the\n@@ -2507,6 +2511,18 @@ package body Exp_Ch6 is\n          end;\n       end if;\n \n+      --  When generating C code, transform a function call that returns a\n+      --  constrained array type into procedure form.\n+\n+      if Modify_Tree_For_C\n+        and then Nkind (Call_Node) = N_Function_Call\n+        and then Is_Entity_Name (Name (Call_Node))\n+        and then Rewritten_For_C (Entity (Name (Call_Node)))\n+      then\n+         Rewrite_Function_Call_For_C (Call_Node);\n+         return;\n+      end if;\n+\n       --  First step, compute extra actuals, corresponding to any Extra_Formals\n       --  present. Note that we do not access Extra_Formals directly, instead\n       --  we simply note the presence of the extra formals as we process the\n@@ -4940,21 +4956,23 @@ package body Exp_Ch6 is\n       Body_Id  : constant Entity_Id  := Defining_Entity (N);\n       HSS      : constant Node_Id    := Handled_Statement_Sequence (N);\n       Loc      : constant Source_Ptr := Sloc (N);\n-      Except_H : Node_Id;\n-      L        : List_Id;\n-      Spec_Id  : Entity_Id;\n \n-      procedure Add_Return (S : List_Id);\n-      --  Append a return statement to the statement sequence S if the last\n-      --  statement is not already a return or a goto statement. Note that\n-      --  the latter test is not critical, it does not matter if we add a few\n-      --  extra returns, since they get eliminated anyway later on.\n+      procedure Add_Return (Spec_Id : Entity_Id; Stmts : List_Id);\n+      --  Append a return statement to the statement sequence Stmts if the last\n+      --  statement is not already a return or a goto statement. Note that the\n+      --  latter test is not critical, it does not matter if we add a few extra\n+      --  returns, since they get eliminated anyway later on. Spec_Id denotes\n+      --  the corresponding spec of the subprogram body.\n+\n+      procedure Build_Procedure_Body_Form (Func_Id : Entity_Id);\n+      --  Create a procedure body which emulates the behavior of function\n+      --  Func_Id.\n \n       ----------------\n       -- Add_Return --\n       ----------------\n \n-      procedure Add_Return (S : List_Id) is\n+      procedure Add_Return (Spec_Id : Entity_Id; Stmts : List_Id) is\n          Last_Stmt : Node_Id;\n          Loc       : Source_Ptr;\n          Stmt      : Node_Id;\n@@ -4963,7 +4981,7 @@ package body Exp_Ch6 is\n          --  Get last statement, ignoring any Pop_xxx_Label nodes, which are\n          --  not relevant in this context since they are not executable.\n \n-         Last_Stmt := Last (S);\n+         Last_Stmt := Last (Stmts);\n          while Nkind (Last_Stmt) in N_Pop_xxx_Label loop\n             Prev (Last_Stmt);\n          end loop;\n@@ -4979,8 +4997,8 @@ package body Exp_Ch6 is\n             --  all the statements within the handler are made invisible\n             --  to the debugger.\n \n-            if Nkind (Parent (S)) = N_Exception_Handler\n-              and then not Comes_From_Source (Parent (S))\n+            if Nkind (Parent (Stmts)) = N_Exception_Handler\n+              and then not Comes_From_Source (Parent (Stmts))\n             then\n                Loc := Sloc (Last_Stmt);\n             elsif Present (End_Label (HSS)) then\n@@ -5005,7 +5023,7 @@ package body Exp_Ch6 is\n             --  added to it. A guard in Sem_Elab is needed to prevent that\n             --  spurious check, see Check_Elab_Call.\n \n-            Append_To (S, Stmt);\n+            Append_To (Stmts, Stmt);\n             Set_Analyzed (Stmt);\n \n             --  Call the _Postconditions procedure if the related subprogram\n@@ -5022,10 +5040,128 @@ package body Exp_Ch6 is\n          end if;\n       end Add_Return;\n \n+      -------------------------------\n+      -- Build_Procedure_Body_Form --\n+      -------------------------------\n+\n+      procedure Build_Procedure_Body_Form (Func_Id : Entity_Id) is\n+         Proc_Decl : constant Node_Id   :=\n+                       Next (Unit_Declaration_Node (Func_Id));\n+         --  It is assumed that the next node following the declaration of the\n+         --  corresponding subprogram spec is the declaration of the procedure\n+         --  form.\n+\n+         Proc_Id : constant Entity_Id := Defining_Entity (Proc_Decl);\n+\n+         procedure Replace_Returns (Param_Id : Entity_Id; Stmts : List_Id);\n+         --  Replace each return statement found in the list Stmts with an\n+         --  assignment of the return expression to parameter Param_Id.\n+\n+         ---------------------\n+         -- Replace_Returns --\n+         ---------------------\n+\n+         procedure Replace_Returns (Param_Id : Entity_Id; Stmts : List_Id) is\n+            Stmt : Node_Id;\n+\n+         begin\n+            Stmt := First (Stmts);\n+            while Present (Stmt) loop\n+               if Nkind (Stmt) = N_Block_Statement then\n+                  Replace_Returns (Param_Id, Statements (Stmt));\n+\n+               elsif Nkind (Stmt) = N_Case_Statement then\n+                  declare\n+                     Alt : Node_Id;\n+                  begin\n+                     Alt := First (Alternatives (Stmt));\n+                     while Present (Alt) loop\n+                        Replace_Returns (Param_Id, Statements (Alt));\n+                        Next (Alt);\n+                     end loop;\n+                  end;\n+\n+               elsif Nkind (Stmt) = N_If_Statement then\n+                  Replace_Returns (Param_Id, Then_Statements (Stmt));\n+                  Replace_Returns (Param_Id, Else_Statements (Stmt));\n+\n+                  declare\n+                     Part : Node_Id;\n+                  begin\n+                     Part := First (Elsif_Parts (Stmt));\n+                     while Present (Part) loop\n+                        Replace_Returns (Part, Then_Statements (Part));\n+                        Next (Part);\n+                     end loop;\n+                  end;\n+\n+               elsif Nkind (Stmt) = N_Loop_Statement then\n+                  Replace_Returns (Param_Id, Statements (Stmt));\n+\n+               elsif Nkind (Stmt) = N_Simple_Return_Statement then\n+\n+                  --  Generate:\n+                  --    Param := Expr;\n+                  --    return;\n+\n+                  Rewrite (Stmt,\n+                    Make_Assignment_Statement (Sloc (Stmt),\n+                      Name       => New_Occurrence_Of (Param_Id, Loc),\n+                      Expression => Relocate_Node (Expression (Stmt))));\n+\n+                  Insert_After (Stmt, Make_Simple_Return_Statement (Loc));\n+\n+                  --  Skip the added return\n+\n+                  Next (Stmt);\n+               end if;\n+\n+               Next (Stmt);\n+            end loop;\n+         end Replace_Returns;\n+\n+         --  Local variables\n+\n+         Stmts : List_Id;\n+\n+      --  Start of processing for Build_Procedure_Body_Form\n+\n+      begin\n+         --  This routine performs the following expansion:\n+\n+         --    function F (...) return Array_Typ is\n+         --    begin\n+         --       ...\n+         --       return Something;\n+         --    end F;\n+\n+         --    procedure P (..., Result : out Array_Typ) is\n+         --    begin\n+         --       ...\n+         --       Result := Something;\n+         --    end P;\n+\n+         Stmts := New_Copy_List (Statements (HSS));\n+         Replace_Returns (Last_Entity (Proc_Id), Stmts);\n+\n+         Insert_After_And_Analyze (N,\n+           Make_Subprogram_Body (Loc,\n+             Specification              =>\n+               Copy_Subprogram_Spec (Specification (Proc_Decl)),\n+             Declarations               => New_Copy_List (Declarations (N)),\n+             Handled_Statement_Sequence =>\n+               Make_Handled_Sequence_Of_Statements (Loc,\n+                 Statements => Stmts)));\n+      end Build_Procedure_Body_Form;\n+\n       --  Local varaibles\n \n       Save_Ghost_Mode : constant Ghost_Mode_Type := Ghost_Mode;\n \n+      Except_H : Node_Id;\n+      L        : List_Id;\n+      Spec_Id  : Entity_Id;\n+\n    --  Start of processing for Expand_N_Subprogram_Body\n \n    begin\n@@ -5221,12 +5357,12 @@ package body Exp_Ch6 is\n       --  the subprogram.\n \n       if Ekind_In (Spec_Id, E_Procedure, E_Generic_Procedure) then\n-         Add_Return (Statements (HSS));\n+         Add_Return (Spec_Id, Statements (HSS));\n \n          if Present (Exception_Handlers (HSS)) then\n             Except_H := First_Non_Pragma (Exception_Handlers (HSS));\n             while Present (Except_H) loop\n-               Add_Return (Statements (Except_H));\n+               Add_Return (Spec_Id, Statements (Except_H));\n                Next_Non_Pragma (Except_H);\n             end loop;\n          end if;\n@@ -5316,6 +5452,17 @@ package body Exp_Ch6 is\n          Unest_Bodies.Append ((Spec_Id, N));\n       end if;\n \n+      --  When generating C code, transform a function that returns a\n+      --  constrained array type into a procedure with an out parameter\n+      --  that carries the return value.\n+\n+      if Modify_Tree_For_C\n+        and then Ekind (Spec_Id) = E_Function\n+        and then Rewritten_For_C (Spec_Id)\n+      then\n+         Build_Procedure_Body_Form (Spec_Id);\n+      end if;\n+\n       Ghost_Mode := Save_Ghost_Mode;\n    end Expand_N_Subprogram_Body;\n \n@@ -5343,13 +5490,73 @@ package body Exp_Ch6 is\n    --  If the declaration is for a null procedure, emit null body\n \n    procedure Expand_N_Subprogram_Declaration (N : Node_Id) is\n-      Loc       : constant Source_Ptr := Sloc (N);\n-      Subp      : constant Entity_Id  := Defining_Entity (N);\n+      Loc  : constant Source_Ptr := Sloc (N);\n+      Subp : constant Entity_Id  := Defining_Entity (N);\n+\n+      procedure Build_Procedure_Form;\n+      --  Create a procedure declaration which emulates the behavior of\n+      --  function Subp.\n+\n+      --------------------------\n+      -- Build_Procedure_Form --\n+      --------------------------\n+\n+      procedure Build_Procedure_Form is\n+         Func_Formal  : Entity_Id;\n+         Proc_Formals : List_Id;\n+\n+      begin\n+         Proc_Formals := New_List;\n+\n+         --  Create a list of formal parameters with the same types as the\n+         --  function.\n+\n+         Func_Formal := First_Formal (Subp);\n+         while Present (Func_Formal) loop\n+            Append_To (Proc_Formals,\n+              Make_Parameter_Specification (Loc,\n+                Defining_Identifier =>\n+                  Make_Defining_Identifier (Loc, Chars (Func_Formal)),\n+                Parameter_Type      =>\n+                  New_Occurrence_Of (Etype (Func_Formal), Loc)));\n+\n+            Next_Formal (Func_Formal);\n+         end loop;\n+\n+         --  Add an extra out parameter to carry the function result\n+\n+         Append_To (Proc_Formals,\n+           Make_Parameter_Specification (Loc,\n+             Defining_Identifier => Make_Temporary (Loc, 'R'),\n+             Out_Present         => True,\n+             Parameter_Type      => New_Occurrence_Of (Etype (Subp), Loc)));\n+\n+         --  The new procedure declaration is inserted immediately after the\n+         --  function declaration. The processing in Build_Procedure_Body_Form\n+         --  relies on this order.\n+\n+         Insert_After_And_Analyze (N,\n+           Make_Subprogram_Declaration (Loc,\n+             Specification =>\n+               Make_Procedure_Specification (Loc,\n+                 Defining_Unit_Name       =>\n+                   Make_Defining_Identifier (Loc, Chars (Subp)),\n+                 Parameter_Specifications => Proc_Formals)));\n+\n+         --  Mark the function as having a procedure form\n+\n+         Set_Rewritten_For_C (Subp);\n+      end Build_Procedure_Form;\n+\n+      --  Local variables\n+\n       Scop      : constant Entity_Id  := Scope (Subp);\n       Prot_Bod  : Node_Id;\n       Prot_Decl : Node_Id;\n       Prot_Id   : Entity_Id;\n \n+   --  Start of processing for Expand_N_Subprogram_Declaration\n+\n    begin\n       --  In SPARK, subprogram declarations are only allowed in package\n       --  specifications.\n@@ -5451,6 +5658,18 @@ package body Exp_Ch6 is\n             Set_Is_Inlined (Subp, False);\n          end;\n       end if;\n+\n+      --  When generating C code, transform a function that returns a\n+      --  constrained array type into a procedure with an out parameter\n+      --  that carries the return value.\n+\n+      if Modify_Tree_For_C\n+        and then Nkind (Specification (N)) = N_Function_Specification\n+        and then Is_Array_Type (Etype (Subp))\n+        and then Is_Constrained (Etype (Subp))\n+      then\n+         Build_Procedure_Form;\n+      end if;\n    end Expand_N_Subprogram_Declaration;\n \n    --------------------------------\n@@ -9363,6 +9582,76 @@ package body Exp_Ch6 is\n       end if;\n    end Needs_Result_Accessibility_Level;\n \n+   ---------------------------------\n+   -- Rewrite_Function_Call_For_C --\n+   ---------------------------------\n+\n+   procedure Rewrite_Function_Call_For_C (N : Node_Id) is\n+      Func_Id   : constant Entity_Id  := Entity (Name (N));\n+      Func_Decl : constant Node_Id    := Unit_Declaration_Node (Func_Id);\n+      Par       : constant Node_Id    := Parent (N);\n+      Loc       : constant Source_Ptr := Sloc (Par);\n+      Proc_Id   : constant Entity_Id  := Defining_Entity (Next (Func_Decl));\n+      Actuals   : List_Id;\n+\n+   begin\n+      Actuals := Parameter_Associations (N);\n+\n+      --  If the function call is the expression of an assignment statement,\n+      --  transform the assignment into a procedure call. Generate:\n+\n+      --    LHS := Func_Call (...);\n+\n+      --    Proc_Call (..., LHS);\n+\n+      if Nkind (Par) = N_Assignment_Statement then\n+         Append_To (Actuals, (Name (Par)));\n+         Rewrite (Par,\n+           Make_Procedure_Call_Statement (Loc,\n+             Name                   => New_Occurrence_Of (Proc_Id, Loc),\n+             Parameter_Associations => Actuals));\n+         Analyze (Par);\n+\n+      --  Otherwise the context is an expression. Generate a temporary and a\n+      --  procedure call to obtain the function result. Generate:\n+\n+      --    ... Func_Call (...) ...\n+\n+      --    Temp : ...;\n+      --    Proc_Call (..., Temp);\n+      --    ... Temp ...\n+\n+      else\n+         declare\n+            Temp_Id : constant Entity_Id := Make_Temporary (Loc, 'T');\n+            Call    : Node_Id;\n+            Decl    : Node_Id;\n+\n+         begin\n+            --  Generate:\n+            --    Temp : ...;\n+\n+            Decl :=\n+              Make_Object_Declaration (Loc,\n+                Defining_Identifier => Temp_Id,\n+                Object_Definition   =>\n+                  New_Occurrence_Of (Etype (Func_Id), Loc));\n+\n+            --  Generate:\n+            --    Proc_Call (..., Temp);\n+\n+            Append_To (Actuals, New_Occurrence_Of (Temp_Id, Loc));\n+            Call :=\n+              Make_Procedure_Call_Statement (Loc,\n+                Name                   => New_Occurrence_Of (Proc_Id, Loc),\n+                Parameter_Associations => Actuals);\n+\n+            Insert_Actions (Par, New_List (Decl, Call));\n+            Rewrite (N, New_Occurrence_Of (Temp_Id, Loc));\n+         end;\n+      end if;\n+   end Rewrite_Function_Call_For_C;\n+\n    ------------------------------------\n    -- Set_Enclosing_Sec_Stack_Return --\n    ------------------------------------"}, {"sha": "37f3920370d86c74c5fc60db16b44f1f6aae25f2", "filename": "gcc/ada/exp_dbug.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2700b9c1ee96244be32ca50533692d14f4b18eef/gcc%2Fada%2Fexp_dbug.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2700b9c1ee96244be32ca50533692d14f4b18eef/gcc%2Fada%2Fexp_dbug.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_dbug.adb?ref=2700b9c1ee96244be32ca50533692d14f4b18eef", "patch": "@@ -785,7 +785,7 @@ package body Exp_Dbug is\n       if Is_Ignored_Ghost_Entity (E)\n         or else (Debug_Flag_Dot_5 and Is_Ghost_Entity (E))\n       then\n-         Add_Str_To_Name_Buffer (\"_ghost_\");\n+         Add_Str_To_Name_Buffer (\"___ghost_\");\n       end if;\n \n       --  Case of interface name being used"}, {"sha": "f8df41cb79459c1cc3a3579a120e21574e40aef7", "filename": "gcc/ada/exp_dbug.ads", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2700b9c1ee96244be32ca50533692d14f4b18eef/gcc%2Fada%2Fexp_dbug.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2700b9c1ee96244be32ca50533692d14f4b18eef/gcc%2Fada%2Fexp_dbug.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_dbug.ads?ref=2700b9c1ee96244be32ca50533692d14f4b18eef", "patch": "@@ -76,9 +76,9 @@ package Exp_Dbug is\n    --  qualification for such entities. In particular this means that direct\n    --  local variables of a procedure are not qualified.\n \n-   --  For ignored Ghost entities, the encoding adds a prefix \"_ghost_\" to aid\n-   --  the detection of leaks in the \"living\" space. Ignored Ghost entities and\n-   --  any code associated with them should be removed by the compiler in a\n+   --  For ignored Ghost entities, the encoding adds a prefix \"___ghost_\" to\n+   --  aid the detection of leaks in the \"living\" space. Ignored Ghost entities\n+   --  and any code associated with them should be removed by the compiler in a\n    --  post-processing pass. As a result, object files should not contain any\n    --  occurrences of this prefix.\n "}, {"sha": "f2ac16b5421b1287edafdbe1f1c1139a46fa1105", "filename": "gcc/ada/ghost.adb", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2700b9c1ee96244be32ca50533692d14f4b18eef/gcc%2Fada%2Fghost.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2700b9c1ee96244be32ca50533692d14f4b18eef/gcc%2Fada%2Fghost.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fghost.adb?ref=2700b9c1ee96244be32ca50533692d14f4b18eef", "patch": "@@ -801,9 +801,10 @@ package body Ghost is\n               Enables_Ghostness (First (Pragma_Argument_Associations (Decl)));\n \n          --  A source construct ends the region where pragma Ghost may appear,\n-         --  stop the traversal.\n+         --  stop the traversal. Check the original node as source constructs\n+         --  may be rewritten into something else by expansion.\n \n-         elsif Comes_From_Source (Decl) then\n+         elsif Comes_From_Source (Original_Node (Decl)) then\n             exit;\n          end if;\n "}, {"sha": "f62b2f3472d875fca5742b954335369a24a37546", "filename": "gcc/ada/gnat1drv.adb", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2700b9c1ee96244be32ca50533692d14f4b18eef/gcc%2Fada%2Fgnat1drv.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2700b9c1ee96244be32ca50533692d14f4b18eef/gcc%2Fada%2Fgnat1drv.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat1drv.adb?ref=2700b9c1ee96244be32ca50533692d14f4b18eef", "patch": "@@ -648,7 +648,7 @@ procedure Gnat1drv is\n          --  back end some day, it would not be true for this test, but it\n          --  would be non-GCC, so this is a bit troublesome ???\n \n-         Front_End_Inlining := AAMP_On_Target;\n+         Front_End_Inlining := AAMP_On_Target or Generate_C_Code;\n       end if;\n \n       --  Set back end inlining indication\n@@ -659,6 +659,10 @@ procedure Gnat1drv is\n \n         not AAMP_On_Target\n \n+        --  No back end inlining available on C generation\n+\n+        and then not Generate_C_Code\n+\n         --  No back end inlining in GNATprove mode, since it just confuses\n         --  the formal verification process.\n "}]}