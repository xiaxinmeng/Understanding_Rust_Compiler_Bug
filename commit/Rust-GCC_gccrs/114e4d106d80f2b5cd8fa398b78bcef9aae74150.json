{"sha": "114e4d106d80f2b5cd8fa398b78bcef9aae74150", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTE0ZTRkMTA2ZDgwZjJiNWNkOGZhMzk4Yjc4YmNlZjlhYWU3NDE1MA==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2007-02-02T04:06:23Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2007-02-02T04:06:23Z"}, "message": "trans-array.c (gfc_conv_expr_descriptor): We don't need to use a temporary array to pass a constant non-character array...\n\n\n\t* trans-array.c (gfc_conv_expr_descriptor): We don't need to use\n\ta temporary array to pass a constant non-character array constructor.\n\tGeneralize the descriptor generation code to handle scalarizer\n\t\"info\" without an array reference.\n\nFrom-SVN: r121491", "tree": {"sha": "d85dc905fa6fb5da2c6d13e3a99cfaffc5a9495b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d85dc905fa6fb5da2c6d13e3a99cfaffc5a9495b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/114e4d106d80f2b5cd8fa398b78bcef9aae74150", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/114e4d106d80f2b5cd8fa398b78bcef9aae74150", "html_url": "https://github.com/Rust-GCC/gccrs/commit/114e4d106d80f2b5cd8fa398b78bcef9aae74150", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/114e4d106d80f2b5cd8fa398b78bcef9aae74150/comments", "author": null, "committer": null, "parents": [{"sha": "d4f8b5672a9b7349426fc54e27f7ea67a1078081", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d4f8b5672a9b7349426fc54e27f7ea67a1078081", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d4f8b5672a9b7349426fc54e27f7ea67a1078081"}], "stats": {"total": 48, "additions": 39, "deletions": 9}, "files": [{"sha": "e8649c352341a852b15707ff94e6c4ad178ae053", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/114e4d106d80f2b5cd8fa398b78bcef9aae74150/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/114e4d106d80f2b5cd8fa398b78bcef9aae74150/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=114e4d106d80f2b5cd8fa398b78bcef9aae74150", "patch": "@@ -1,3 +1,10 @@\n+2007-02-01  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* trans-array.c (gfc_conv_expr_descriptor): We don't need to use\n+\ta temporary array to pass a constant non-character array constructor.\n+\tGeneralize the descriptor generation code to handle scalarizer\n+\t\"info\" without an array reference.\n+\n 2007-02-01  Roger Sayle  <roger@eyesopen.com>\n \n \t* dependency.c (gfc_check_dependency) <EXPR_ARRAY>: Implement"}, {"sha": "529d721795eb0633e7da3cd4a135e60c464f1bfe", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 32, "deletions": 9, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/114e4d106d80f2b5cd8fa398b78bcef9aae74150/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/114e4d106d80f2b5cd8fa398b78bcef9aae74150/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=114e4d106d80f2b5cd8fa398b78bcef9aae74150", "patch": "@@ -1,6 +1,6 @@\n /* Array translation routines\n-   Copyright (C) 2002, 2003, 2004, 2005, 2006 Free Software Foundation,\n-   Inc.\n+   Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007\n+   Free Software Foundation, Inc.\n    Contributed by Paul Brook <paul@nowt.org>\n    and Steven Bosscher <s.bosscher@student.tudelft.nl>\n \n@@ -4306,7 +4306,6 @@ gfc_conv_expr_descriptor (gfc_se * se, gfc_expr * expr, gfc_ss * ss)\n \n   gcc_assert (ss != gfc_ss_terminator);\n \n-  /* TODO: Pass constant array constructors without a temporary.  */\n   /* Special case things we know we can pass easily.  */\n   switch (expr->expr_type)\n     {\n@@ -4402,6 +4401,24 @@ gfc_conv_expr_descriptor (gfc_se * se, gfc_expr * expr, gfc_ss * ss)\n \t}\n       break;\n \n+    case EXPR_ARRAY:\n+      /* Constant array constructors don't need a temporary.  */\n+      if (ss->type == GFC_SS_CONSTRUCTOR\n+\t  && expr->ts.type != BT_CHARACTER\n+\t  && gfc_constant_array_constructor_p (expr->value.constructor))\n+\t{\n+\t  need_tmp = 0;\n+\t  info = &ss->data.info;\n+\t  secss = ss;\n+\t}\n+      else\n+\t{\n+\t  need_tmp = 1;\n+\t  secss = NULL;\n+\t  info = NULL;\n+\t}\n+      break;\n+\n     default:\n       /* Something complicated.  Copy it into a temporary.  */\n       need_tmp = 1;\n@@ -4553,7 +4570,7 @@ gfc_conv_expr_descriptor (gfc_se * se, gfc_expr * expr, gfc_ss * ss)\n \t limits will be the limits of the section.\n \t A function may decide to repack the array to speed up access, but\n \t we're not bothered about that here.  */\n-      int dim;\n+      int dim, ndim;\n       tree parm;\n       tree parmtype;\n       tree stride;\n@@ -4603,12 +4620,14 @@ gfc_conv_expr_descriptor (gfc_se * se, gfc_expr * expr, gfc_ss * ss)\n       else\n \tbase = NULL_TREE;\n \n-      for (n = 0; n < info->ref->u.ar.dimen; n++)\n+      ndim = info->ref ? info->ref->u.ar.dimen : info->dimen;\n+      for (n = 0; n < ndim; n++)\n \t{\n \t  stride = gfc_conv_array_stride (desc, n);\n \n \t  /* Work out the offset.  */\n-\t  if (info->ref->u.ar.dimen_type[n] == DIMEN_ELEMENT)\n+\t  if (info->ref\n+\t      && info->ref->u.ar.dimen_type[n] == DIMEN_ELEMENT)\n \t    {\n \t      gcc_assert (info->subscript[n]\n \t\t      && info->subscript[n]->type == GFC_SS_SCALAR);\n@@ -4630,14 +4649,16 @@ gfc_conv_expr_descriptor (gfc_se * se, gfc_expr * expr, gfc_ss * ss)\n \t  tmp = fold_build2 (MULT_EXPR, TREE_TYPE (tmp), tmp, stride);\n \t  offset = fold_build2 (PLUS_EXPR, TREE_TYPE (tmp), offset, tmp);\n \n-\t  if (info->ref->u.ar.dimen_type[n] == DIMEN_ELEMENT)\n+\t  if (info->ref\n+\t      && info->ref->u.ar.dimen_type[n] == DIMEN_ELEMENT)\n \t    {\n \t      /* For elemental dimensions, we only need the offset.  */\n \t      continue;\n \t    }\n \n \t  /* Vector subscripts need copying and are handled elsewhere.  */\n-\t  gcc_assert (info->ref->u.ar.dimen_type[n] == DIMEN_RANGE);\n+\t  if (info->ref)\n+\t    gcc_assert (info->ref->u.ar.dimen_type[n] == DIMEN_RANGE);\n \n \t  /* Set the new lower bound.  */\n \t  from = loop.from[dim];\n@@ -4646,7 +4667,9 @@ gfc_conv_expr_descriptor (gfc_se * se, gfc_expr * expr, gfc_ss * ss)\n \t  /* If we have an array section or are assigning to a pointer,\n \t     make sure that the lower bound is 1.  References to the full\n \t     array should otherwise keep the original bounds.  */\n-\t  if ((info->ref->u.ar.type != AR_FULL || se->direct_byref)\n+\t  if ((!info->ref\n+\t       || info->ref->u.ar.type != AR_FULL\n+\t       || se->direct_byref)\n \t      && !integer_onep (from))\n \t    {\n \t      tmp = fold_build2 (MINUS_EXPR, gfc_array_index_type,"}]}