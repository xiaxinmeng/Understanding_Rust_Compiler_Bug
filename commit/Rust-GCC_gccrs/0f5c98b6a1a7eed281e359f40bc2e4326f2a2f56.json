{"sha": "0f5c98b6a1a7eed281e359f40bc2e4326f2a2f56", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGY1Yzk4YjZhMWE3ZWVkMjgxZTM1OWY0MGJjMmU0MzI2ZjJhMmY1Ng==", "commit": {"author": {"name": "Iain Buclaw", "email": "ibuclaw@gdcproject.org", "date": "2020-08-25T09:44:48Z"}, "committer": {"name": "Iain Buclaw", "email": "ibuclaw@gdcproject.org", "date": "2020-08-26T08:03:55Z"}, "message": "d: Merge upstream dmd cb4a96fae\n\nFixes both a bug where compilation would hang, and an issue where recursive\ntemplate limits are hit too early.\n\nReviewed-on: https://github.com/dlang/dmd/pull/11621\n\ngcc/d/ChangeLog:\n\n\t* dmd/MERGE: Merge upstream dmd cb4a96fae", "tree": {"sha": "ca23bf0a387a66f74738551ff1d31cb323d7e8c9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ca23bf0a387a66f74738551ff1d31cb323d7e8c9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0f5c98b6a1a7eed281e359f40bc2e4326f2a2f56", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f5c98b6a1a7eed281e359f40bc2e4326f2a2f56", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0f5c98b6a1a7eed281e359f40bc2e4326f2a2f56", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f5c98b6a1a7eed281e359f40bc2e4326f2a2f56/comments", "author": {"login": "ibuclaw", "id": 397929, "node_id": "MDQ6VXNlcjM5NzkyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/397929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibuclaw", "html_url": "https://github.com/ibuclaw", "followers_url": "https://api.github.com/users/ibuclaw/followers", "following_url": "https://api.github.com/users/ibuclaw/following{/other_user}", "gists_url": "https://api.github.com/users/ibuclaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibuclaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibuclaw/subscriptions", "organizations_url": "https://api.github.com/users/ibuclaw/orgs", "repos_url": "https://api.github.com/users/ibuclaw/repos", "events_url": "https://api.github.com/users/ibuclaw/events{/privacy}", "received_events_url": "https://api.github.com/users/ibuclaw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ibuclaw", "id": 397929, "node_id": "MDQ6VXNlcjM5NzkyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/397929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibuclaw", "html_url": "https://github.com/ibuclaw", "followers_url": "https://api.github.com/users/ibuclaw/followers", "following_url": "https://api.github.com/users/ibuclaw/following{/other_user}", "gists_url": "https://api.github.com/users/ibuclaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibuclaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibuclaw/subscriptions", "organizations_url": "https://api.github.com/users/ibuclaw/orgs", "repos_url": "https://api.github.com/users/ibuclaw/repos", "events_url": "https://api.github.com/users/ibuclaw/events{/privacy}", "received_events_url": "https://api.github.com/users/ibuclaw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7421802276e737c2da297599121480833db92de9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7421802276e737c2da297599121480833db92de9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7421802276e737c2da297599121480833db92de9"}], "stats": {"total": 57, "additions": 42, "deletions": 15}, "files": [{"sha": "2dc2ef3d6223a5e302ebf43e5784343856cf7424", "filename": "gcc/d/dmd/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f5c98b6a1a7eed281e359f40bc2e4326f2a2f56/gcc%2Fd%2Fdmd%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f5c98b6a1a7eed281e359f40bc2e4326f2a2f56/gcc%2Fd%2Fdmd%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2FMERGE?ref=0f5c98b6a1a7eed281e359f40bc2e4326f2a2f56", "patch": "@@ -1,4 +1,4 @@\n-2cc25c2191928f865e1b711f30b6a4268d6a0d9a\n+cb4a96faecb6b521ac4749581bcfa39f61143db0\n \n The first line of this file holds the git revision number of the last\n merge done from the dlang/dmd repository."}, {"sha": "cefd3b037aa77f2281a32e6b1914d78820a498b3", "filename": "gcc/d/dmd/dmacro.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f5c98b6a1a7eed281e359f40bc2e4326f2a2f56/gcc%2Fd%2Fdmd%2Fdmacro.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f5c98b6a1a7eed281e359f40bc2e4326f2a2f56/gcc%2Fd%2Fdmd%2Fdmacro.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdmacro.c?ref=0f5c98b6a1a7eed281e359f40bc2e4326f2a2f56", "patch": "@@ -226,11 +226,10 @@ void Macro::expand(OutBuffer *buf, size_t start, size_t *pend,\n {\n     // limit recursive expansion\n     static int nest;\n-    static const int nestLimit = 1000;\n-    if (nest > nestLimit)\n+    if (nest > global.recursionLimit)\n     {\n-        error(Loc(), \"DDoc macro expansion limit exceeded; more than %d \"\n-            \"expansions.\", nestLimit);\n+        error(Loc(), \"DDoc macro expansion limit exceeded; more than %d expansions.\",\n+              global.recursionLimit);\n         return;\n     }\n     nest++;"}, {"sha": "a86daeee6336f88b2b7532298b05592d8c266d27", "filename": "gcc/d/dmd/dtemplate.c", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f5c98b6a1a7eed281e359f40bc2e4326f2a2f56/gcc%2Fd%2Fdmd%2Fdtemplate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f5c98b6a1a7eed281e359f40bc2e4326f2a2f56/gcc%2Fd%2Fdmd%2Fdtemplate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdtemplate.c?ref=0f5c98b6a1a7eed281e359f40bc2e4326f2a2f56", "patch": "@@ -4337,6 +4337,13 @@ MATCH deduceType(RootObject *o, Scope *sc, Type *tparam, TemplateParameters *par\n \n         void visit(ArrayLiteralExp *e)\n         {\n+            // https://issues.dlang.org/show_bug.cgi?id=20092\n+            if (e->elements && e->elements->length &&\n+                e->type->toBasetype()->nextOf()->ty == Tvoid)\n+            {\n+                result = deduceEmptyArrayElement();\n+                return;\n+            }\n             if ((!e->elements || !e->elements->length) &&\n                 e->type->toBasetype()->nextOf()->ty == Tvoid &&\n                 tparam->ty == Tarray)\n@@ -5932,10 +5939,10 @@ void TemplateInstance::tryExpandMembers(Scope *sc2)\n     static int nest;\n     // extracted to a function to allow windows SEH to work without destructors in the same function\n     //printf(\"%d\\n\", nest);\n-    if (++nest > 500)\n+    if (++nest > global.recursionLimit)\n     {\n         global.gag = 0;                 // ensure error message gets printed\n-        error(\"recursive expansion\");\n+        error(\"recursive expansion exceeded allowed nesting limit\");\n         fatal();\n     }\n \n@@ -5949,10 +5956,10 @@ void TemplateInstance::trySemantic3(Scope *sc2)\n     // extracted to a function to allow windows SEH to work without destructors in the same function\n     static int nest;\n     //printf(\"%d\\n\", nest);\n-    if (++nest > 300)\n+    if (++nest > global.recursionLimit)\n     {\n         global.gag = 0;            // ensure error message gets printed\n-        error(\"recursive expansion\");\n+        error(\"recursive expansion exceeded allowed nesting limit\");\n         fatal();\n     }\n     semantic3(sc2);\n@@ -6353,7 +6360,7 @@ void TemplateInstance::semantic(Scope *sc, Expressions *fargs)\n         while (ti && !ti->deferred && ti->tinst)\n         {\n             ti = ti->tinst;\n-            if (++nest > 500)\n+            if (++nest > global.recursionLimit)\n             {\n                 global.gag = 0;            // ensure error message gets printed\n                 error(\"recursive expansion\");\n@@ -8440,7 +8447,7 @@ void TemplateMixin::semantic(Scope *sc)\n \n     static int nest;\n     //printf(\"%d\\n\", nest);\n-    if (++nest > 500)\n+    if (++nest > global.recursionLimit)\n     {\n         global.gag = 0;                 // ensure error message gets printed\n         error(\"recursive expansion\");"}, {"sha": "d2519969a2ce48b299a4cdbf2323430f41dad19e", "filename": "gcc/d/dmd/expressionsem.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f5c98b6a1a7eed281e359f40bc2e4326f2a2f56/gcc%2Fd%2Fdmd%2Fexpressionsem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f5c98b6a1a7eed281e359f40bc2e4326f2a2f56/gcc%2Fd%2Fdmd%2Fexpressionsem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fexpressionsem.c?ref=0f5c98b6a1a7eed281e359f40bc2e4326f2a2f56", "patch": "@@ -2896,7 +2896,7 @@ class ExpressionSemanticVisitor : public Visitor\n             else\n             {\n                 static int nest;\n-                if (++nest > 500)\n+                if (++nest > global.recursionLimit)\n                 {\n                     exp->error(\"recursive evaluation of %s\", exp->toChars());\n                     --nest;"}, {"sha": "9d6e1ec37a90bff5d07c8e55d9f2cd110dc6a343", "filename": "gcc/d/dmd/globals.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f5c98b6a1a7eed281e359f40bc2e4326f2a2f56/gcc%2Fd%2Fdmd%2Fglobals.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f5c98b6a1a7eed281e359f40bc2e4326f2a2f56/gcc%2Fd%2Fdmd%2Fglobals.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fglobals.h?ref=0f5c98b6a1a7eed281e359f40bc2e4326f2a2f56", "patch": "@@ -244,6 +244,8 @@ struct Global\n     Array<class Identifier*>* versionids; // command line versions and predefined versions\n     Array<class Identifier*>* debugids;   // command line debug versions and predefined versions\n \n+    enum { recursionLimit = 500 }; // number of recursive template expansions before abort\n+\n     /* Start gagging. Return the current number of gagged errors\n      */\n     unsigned startGagging();"}, {"sha": "36471557dfcd6bbe586f25ab59cc492a63a4fa16", "filename": "gcc/d/dmd/mtype.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f5c98b6a1a7eed281e359f40bc2e4326f2a2f56/gcc%2Fd%2Fdmd%2Fmtype.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f5c98b6a1a7eed281e359f40bc2e4326f2a2f56/gcc%2Fd%2Fdmd%2Fmtype.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fmtype.c?ref=0f5c98b6a1a7eed281e359f40bc2e4326f2a2f56", "patch": "@@ -2189,7 +2189,7 @@ Expression *Type::noMember(Scope *sc, Expression *e, Identifier *ident, int flag\n \n     static int nest;      // https://issues.dlang.org/show_bug.cgi?id=17380\n \n-    if (++nest > 500)\n+    if (++nest > global.recursionLimit)\n     {\n       ::error(e->loc, \"cannot resolve identifier `%s`\", ident->toChars());\n       --nest;\n@@ -5536,7 +5536,7 @@ Type *TypeFunction::semantic(Loc loc, Scope *sc)\n \n     bool errors = false;\n \n-    if (inuse > 500)\n+    if (inuse > global.recursionLimit)\n     {\n         inuse = 0;\n         ::error(loc, \"recursive type\");"}, {"sha": "45d94df577d08cc29057c2923474aaf39daa3576", "filename": "gcc/d/dmd/optimize.c", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f5c98b6a1a7eed281e359f40bc2e4326f2a2f56/gcc%2Fd%2Fdmd%2Foptimize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f5c98b6a1a7eed281e359f40bc2e4326f2a2f56/gcc%2Fd%2Fdmd%2Foptimize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Foptimize.c?ref=0f5c98b6a1a7eed281e359f40bc2e4326f2a2f56", "patch": "@@ -19,6 +19,7 @@\n #include \"init.h\"\n #include \"enum.h\"\n #include \"ctfe.h\"\n+#include \"errors.h\"\n \n Expression *semantic(Expression *e, Scope *sc);\n \n@@ -1214,10 +1215,18 @@ Expression *Expression_optimize(Expression *e, int result, bool keepLvalue)\n     v.ret = e;\n \n     // Optimize the expression until it can no longer be simplified.\n-    while (ex != v.ret)\n+    size_t b = 0;\n+    while (1)\n     {\n+        if (b++ == global.recursionLimit)\n+        {\n+            e->error(\"infinite loop while optimizing expression\");\n+            fatal();\n+        }\n         ex = v.ret;\n         ex->accept(&v);\n+        if (ex == v.ret)\n+            break;\n     }\n     return ex;\n }"}, {"sha": "ff2be374bd2d781cc3646adf4876589e0927bc7f", "filename": "gcc/testsuite/gdc.test/compilable/ice20092.d", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f5c98b6a1a7eed281e359f40bc2e4326f2a2f56/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fice20092.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f5c98b6a1a7eed281e359f40bc2e4326f2a2f56/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fice20092.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fice20092.d?ref=0f5c98b6a1a7eed281e359f40bc2e4326f2a2f56", "patch": "@@ -0,0 +1,10 @@\n+void foo()\n+{\n+    (void[1]).init.front;\n+}\n+\n+void front(T)(T[] a)\n+{\n+    static assert(is(T == void));\n+}\n+"}]}