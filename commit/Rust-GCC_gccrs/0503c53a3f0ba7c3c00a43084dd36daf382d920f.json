{"sha": "0503c53a3f0ba7c3c00a43084dd36daf382d920f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDUwM2M1M2EzZjBiYTdjM2MwMGE0MzA4NGRkMzZkYWYzODJkOTIwZg==", "commit": {"author": {"name": "Robert Dewar", "email": "dewar@adacore.com", "date": "2008-03-26T07:40:27Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2008-03-26T07:40:27Z"}, "message": "itypes.adb (Create_Itype): Use new name Access_Subprogram_Kind\n\n2008-03-26  Robert Dewar  <dewar@adacore.com>\n\n\t* itypes.adb (Create_Itype): Use new name Access_Subprogram_Kind\n\n\t* sem_ch13.adb (Validate_Unchecked_Conversion): Give warning for\n\tunchecked conversion for different conventions only for subprogram\n\tpointers or on VMS.\n\nFrom-SVN: r133570", "tree": {"sha": "6faafe8d83c05e793eb5fa7da3963e62b8c4ec7c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6faafe8d83c05e793eb5fa7da3963e62b8c4ec7c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0503c53a3f0ba7c3c00a43084dd36daf382d920f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0503c53a3f0ba7c3c00a43084dd36daf382d920f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0503c53a3f0ba7c3c00a43084dd36daf382d920f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0503c53a3f0ba7c3c00a43084dd36daf382d920f/comments", "author": null, "committer": null, "parents": [{"sha": "f88ecba0bc8dca1af95ba6ff29de6c2c263c5b76", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f88ecba0bc8dca1af95ba6ff29de6c2c263c5b76", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f88ecba0bc8dca1af95ba6ff29de6c2c263c5b76"}], "stats": {"total": 300, "additions": 151, "deletions": 149}, "files": [{"sha": "cab817dfada76902de760c3916e63fe5b69aad75", "filename": "gcc/ada/itypes.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0503c53a3f0ba7c3c00a43084dd36daf382d920f/gcc%2Fada%2Fitypes.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0503c53a3f0ba7c3c00a43084dd36daf382d920f/gcc%2Fada%2Fitypes.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fitypes.adb?ref=0503c53a3f0ba7c3c00a43084dd36daf382d920f", "patch": "@@ -68,7 +68,7 @@ package body Itypes is\n          Set_Is_Frozen (Typ);\n       end if;\n \n-      if Ekind in Access_Subprogram_Type_Kind then\n+      if Ekind in Access_Subprogram_Kind then\n          Set_Can_Use_Internal_Rep (Typ, not Always_Compatible_Rep_On_Target);\n       end if;\n "}, {"sha": "c678d987808f25b17007e5e6a95484ce107a6b0a", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 150, "deletions": 148, "changes": 298, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0503c53a3f0ba7c3c00a43084dd36daf382d920f/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0503c53a3f0ba7c3c00a43084dd36daf382d920f/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=0503c53a3f0ba7c3c00a43084dd36daf382d920f", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2008, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -180,17 +180,16 @@ package body Sem_Ch13 is\n         and then Attribute_Name (N) = Name_Address\n       then\n          declare\n-            Nam : Node_Id := Prefix (N);\n+            P : Node_Id;\n+\n          begin\n-            while False\n-              or else Nkind (Nam) = N_Selected_Component\n-              or else Nkind (Nam) = N_Indexed_Component\n-            loop\n-               Nam := Prefix (Nam);\n+            P := Prefix (N);\n+            while Nkind_In (P, N_Selected_Component, N_Indexed_Component) loop\n+               P := Prefix (P);\n             end loop;\n \n-            if Is_Entity_Name (Nam) then\n-               return Entity (Nam);\n+            if Is_Entity_Name (P) then\n+               return Entity (P);\n             end if;\n          end;\n       end if;\n@@ -1392,6 +1391,9 @@ package body Sem_Ch13 is\n                Set_Has_Small_Clause (U_Ent);\n                Set_Has_Small_Clause (Implicit_Base);\n                Set_Has_Non_Standard_Rep (Implicit_Base);\n+\n+               --  Recompute RM_Size, but shouldn't this be done in Freeze???\n+\n                Set_Discrete_RM_Size (U_Ent);\n             end if;\n          end Small;\n@@ -1749,10 +1751,10 @@ package body Sem_Ch13 is\n          while Present (Decl) loop\n             DeclO := Original_Node (Decl);\n             if Comes_From_Source (DeclO)\n-              and then Nkind (DeclO) /= N_Pragma\n-              and then Nkind (DeclO) /= N_Use_Package_Clause\n-              and then Nkind (DeclO) /= N_Use_Type_Clause\n-              and then Nkind (DeclO) /= N_Implicit_Label_Declaration\n+              and not Nkind_In (DeclO, N_Pragma,\n+                                       N_Use_Package_Clause,\n+                                       N_Use_Type_Clause,\n+                                       N_Implicit_Label_Declaration)\n             then\n                Error_Msg_N\n                  (\"this declaration not allowed in machine code subprogram\",\n@@ -1769,9 +1771,9 @@ package body Sem_Ch13 is\n          while Present (Stmt) loop\n             StmtO := Original_Node (Stmt);\n             if Comes_From_Source (StmtO)\n-              and then Nkind (StmtO) /= N_Pragma\n-              and then Nkind (StmtO) /= N_Label\n-              and then Nkind (StmtO) /= N_Code_Statement\n+              and then not Nkind_In (StmtO, N_Pragma,\n+                                            N_Label,\n+                                            N_Code_Statement)\n             then\n                Error_Msg_N\n                  (\"this statement is not allowed in machine code subprogram\",\n@@ -2284,7 +2286,7 @@ package body Sem_Ch13 is\n \n             --  The only pragma of interest is Complete_Representation\n \n-            if Chars (CC) = Name_Complete_Representation then\n+            if Pragma_Name (CC) = Name_Complete_Representation then\n                CR_Pragma := CC;\n             end if;\n \n@@ -2346,21 +2348,19 @@ package body Sem_Ch13 is\n                   elsif Present (Component_Clause (Comp)) then\n \n                      --  Diagose duplicate rep clause, or check consistency\n-                     --  if this is inherited component. In a double fault,\n+                     --  if this is an inherited component. In a double fault,\n                      --  there may be a duplicate inconsistent clause for an\n                      --  inherited component.\n \n-                     if\n-                       Scope (Original_Record_Component (Comp)) = Rectype\n-                         or else Parent (Component_Clause (Comp)) = N\n+                     if Scope (Original_Record_Component (Comp)) = Rectype\n+                       or else Parent (Component_Clause (Comp)) = N\n                      then\n                         Error_Msg_Sloc := Sloc (Component_Clause (Comp));\n                         Error_Msg_N (\"component clause previously given#\", CC);\n \n                      else\n                         declare\n                            Rep1 : constant Node_Id := Component_Clause (Comp);\n-\n                         begin\n                            if Intval (Position (Rep1)) /=\n                                                    Intval (Position (CC))\n@@ -2371,7 +2371,6 @@ package body Sem_Ch13 is\n                            then\n                               Error_Msg_N (\"component clause inconsistent \"\n                                 & \"with representation of ancestor\", CC);\n-\n                            elsif Warn_On_Redundant_Constructs then\n                               Error_Msg_N (\"?redundant component clause \"\n                                 & \"for inherited component!\", CC);\n@@ -2467,30 +2466,30 @@ package body Sem_Ch13 is\n       end loop;\n \n       --  Now that we have processed all the component clauses, check for\n-      --  overlap. We have to leave this till last, since the components\n-      --  can appear in any arbitrary order in the representation clause.\n+      --  overlap. We have to leave this till last, since the components can\n+      --  appear in any arbitrary order in the representation clause.\n \n       --  We do not need this check if all specified ranges were monotonic,\n       --  as recorded by Overlap_Check_Required being False at this stage.\n \n-      --  This first section checks if there are any overlapping entries\n-      --  at all. It does this by sorting all entries and then seeing if\n-      --  there are any overlaps. If there are none, then that is decisive,\n-      --  but if there are overlaps, they may still be OK (they may result\n-      --  from fields in different variants).\n+      --  This first section checks if there are any overlapping entries at\n+      --  all. It does this by sorting all entries and then seeing if there are\n+      --  any overlaps. If there are none, then that is decisive, but if there\n+      --  are overlaps, they may still be OK (they may result from fields in\n+      --  different variants).\n \n       if Overlap_Check_Required then\n          Overlap_Check1 : declare\n \n             OC_Fbit : array (0 .. Ccount) of Uint;\n-            --  First-bit values for component clauses, the value is the\n-            --  offset of the first bit of the field from start of record.\n-            --  The zero entry is for use in sorting.\n+            --  First-bit values for component clauses, the value is the offset\n+            --  of the first bit of the field from start of record. The zero\n+            --  entry is for use in sorting.\n \n             OC_Lbit : array (0 .. Ccount) of Uint;\n-            --  Last-bit values for component clauses, the value is the\n-            --  offset of the last bit of the field from start of record.\n-            --  The zero entry is for use in sorting.\n+            --  Last-bit values for component clauses, the value is the offset\n+            --  of the last bit of the field from start of record. The zero\n+            --  entry is for use in sorting.\n \n             OC_Count : Natural := 0;\n             --  Count of entries in OC_Fbit and OC_Lbit\n@@ -2548,10 +2547,10 @@ package body Sem_Ch13 is\n          end Overlap_Check1;\n       end if;\n \n-      --  If Overlap_Check_Required is still True, then we have to do\n-      --  the full scale overlap check, since we have at least two fields\n-      --  that do overlap, and we need to know if that is OK since they\n-      --  are in the same variant, or whether we have a definite problem\n+      --  If Overlap_Check_Required is still True, then we have to do the full\n+      --  scale overlap check, since we have at least two fields that do\n+      --  overlap, and we need to know if that is OK since they are in\n+      --  different variant, or whether we have a definite problem.\n \n       if Overlap_Check_Required then\n          Overlap_Check2 : declare\n@@ -2569,7 +2568,7 @@ package body Sem_Ch13 is\n \n             --  Loop through all components in record. For each component check\n             --  for overlap with any of the preceding elements on the component\n-            --  list containing the component, and also, if the component is in\n+            --  list containing the component and also, if the component is in\n             --  a variant, check against components outside the case structure.\n             --  This latter test is repeated recursively up the variant tree.\n \n@@ -2597,16 +2596,16 @@ package body Sem_Ch13 is\n                Component_List_Loop : loop\n \n                   --  If derived type definition, go to full declaration\n-                  --  If at outer level, check discriminants if there are any\n+                  --  If at outer level, check discriminants if there are any.\n \n                   if Nkind (Clist) = N_Derived_Type_Definition then\n                      Clist := Parent (Clist);\n                   end if;\n \n                   --  Outer level of record definition, check discriminants\n \n-                  if Nkind (Clist) = N_Full_Type_Declaration\n-                    or else Nkind (Clist) = N_Private_Type_Declaration\n+                  if Nkind_In (Clist, N_Full_Type_Declaration,\n+                                      N_Private_Type_Declaration)\n                   then\n                      if Has_Discriminants (Defining_Identifier (Clist)) then\n                         C2_Ent :=\n@@ -2644,23 +2643,22 @@ package body Sem_Ch13 is\n                   --  be a variant, in which case its parent is a variant part,\n                   --  and the parent of the variant part is a component list\n                   --  whose components must all be checked against the current\n-                  --  component for overlap.\n+                  --  component for overlap).\n \n                   if Nkind (Parent (Clist)) = N_Variant then\n                      Clist := Parent (Parent (Parent (Clist)));\n \n                   --  Check for possible discriminant part in record, this is\n                   --  treated essentially as another level in the recursion.\n-                  --  For this case we have the parent of the component list\n-                  --  is the record definition, and its parent is the full\n-                  --  type declaration which contains the discriminant\n-                  --  specifications.\n+                  --  For this case the parent of the component list is the\n+                  --  record definition, and its parent is the full type\n+                  --  declaration containing the discriminant specifications.\n \n                   elsif Nkind (Parent (Clist)) = N_Record_Definition then\n                      Clist := Parent (Parent ((Clist)));\n \n                   --  If neither of these two cases, we are at the top of\n-                  --  the tree\n+                  --  the tree.\n \n                   else\n                      exit Component_List_Loop;\n@@ -2674,24 +2672,23 @@ package body Sem_Ch13 is\n          end Overlap_Check2;\n       end if;\n \n-      --  For records that have component clauses for all components, and\n-      --  whose size is less than or equal to 32, we need to know the size\n-      --  in the front end to activate possible packed array processing\n-      --  where the component type is a record.\n+      --  For records that have component clauses for all components, and whose\n+      --  size is less than or equal to 32, we need to know the size in the\n+      --  front end to activate possible packed array processing where the\n+      --  component type is a record.\n \n-      --  At this stage Hbit + 1 represents the first unused bit from all\n-      --  the component clauses processed, so if the component clauses are\n+      --  At this stage Hbit + 1 represents the first unused bit from all the\n+      --  component clauses processed, so if the component clauses are\n       --  complete, then this is the length of the record.\n \n-      --  For records longer than System.Storage_Unit, and for those where\n-      --  not all components have component clauses, the back end determines\n-      --  the length (it may for example be appopriate to round up the size\n-      --  to some convenient boundary, based on alignment considerations etc).\n+      --  For records longer than System.Storage_Unit, and for those where not\n+      --  all components have component clauses, the back end determines the\n+      --  length (it may for example be appopriate to round up the size\n+      --  to some convenient boundary, based on alignment considerations, etc).\n \n-      if Unknown_RM_Size (Rectype)\n-        and then Hbit + 1 <= 32\n-      then\n-         --  Nothing to do if at least one component with no component clause\n+      if Unknown_RM_Size (Rectype) and then Hbit + 1 <= 32 then\n+\n+         --  Nothing to do if at least one component has no component clause\n \n          Comp := First_Component_Or_Discriminant (Rectype);\n          while Present (Comp) loop\n@@ -2722,9 +2719,7 @@ package body Sem_Ch13 is\n \n       --  If no Complete_Representation pragma, warn if missing components\n \n-      elsif Warn_On_Unrepped_Components\n-        and then not Warnings_Off (Rectype)\n-      then\n+      elsif Warn_On_Unrepped_Components then\n          declare\n             Num_Repped_Components   : Nat := 0;\n             Num_Unrepped_Components : Nat := 0;\n@@ -2736,7 +2731,6 @@ package body Sem_Ch13 is\n             while Present (Comp) loop\n                if Present (Component_Clause (Comp)) then\n                   Num_Repped_Components := Num_Repped_Components + 1;\n-\n                else\n                   Num_Unrepped_Components := Num_Unrepped_Components + 1;\n                end if;\n@@ -2763,6 +2757,7 @@ package body Sem_Ch13 is\n                     and then (Is_Scalar_Type (Underlying_Type (Etype (Comp)))\n                                 or else Size_Known_At_Compile_Time\n                                              (Underlying_Type (Etype (Comp))))\n+                    and then not Has_Warnings_Off (Rectype)\n                   then\n                      Error_Msg_Sloc := Sloc (Comp);\n                      Error_Msg_NE\n@@ -2786,9 +2781,9 @@ package body Sem_Ch13 is\n       if Present (Component_Clause (C1_Ent))\n         and then Present (Component_Clause (C2_Ent))\n       then\n-         --  Exclude odd case where we have two tag fields in the same\n-         --  record, both at location zero. This seems a bit strange,\n-         --  but it seems to happen in some circumstances ???\n+         --  Exclude odd case where we have two tag fields in the same record,\n+         --  both at location zero. This seems a bit strange, but it seems to\n+         --  happen in some circumstances ???\n \n          if Chars (C1_Ent) = Name_uTag\n            and then Chars (C2_Ent) = Name_uTag\n@@ -2830,14 +2825,14 @@ package body Sem_Ch13 is\n       U_Ent : Entity_Id)\n    is\n       procedure Check_At_Constant_Address (Nod : Node_Id);\n-      --  Checks that the given node N represents a name whose 'Address\n-      --  is constant (in the same sense as OK_Constant_Address_Clause,\n-      --  i.e. the address value is the same at the point of declaration\n-      --  of U_Ent and at the time of elaboration of the address clause.\n+      --  Checks that the given node N represents a name whose 'Address is\n+      --  constant (in the same sense as OK_Constant_Address_Clause, i.e. the\n+      --  address value is the same at the point of declaration of U_Ent and at\n+      --  the time of elaboration of the address clause.\n \n       procedure Check_Expr_Constants (Nod : Node_Id);\n-      --  Checks that Nod meets the requirements for a constant address\n-      --  clause in the sense of the enclosing procedure.\n+      --  Checks that Nod meets the requirements for a constant address clause\n+      --  in the sense of the enclosing procedure.\n \n       procedure Check_List_Constants (Lst : List_Id);\n       --  Check that all elements of list Lst meet the requirements for a\n@@ -2937,11 +2932,11 @@ package body Sem_Ch13 is\n                   --  If the node is an object declaration without initial\n                   --  value, some code has been expanded, and the expression\n                   --  is not constant, even if the constituents might be\n-                  --  acceptable, as in  A'Address + offset.\n+                  --  acceptable, as in A'Address + offset.\n \n                   if Ekind (Ent) = E_Variable\n-                    and then Nkind (Declaration_Node (Ent))\n-                      = N_Object_Declaration\n+                    and then\n+                      Nkind (Declaration_Node (Ent)) = N_Object_Declaration\n                     and then\n                       No (Expression (Declaration_Node (Ent)))\n                   then\n@@ -2981,16 +2976,16 @@ package body Sem_Ch13 is\n                     or else\n                   Ekind (Ent) = E_In_Parameter\n                then\n-                  --  This is the case where we must have Ent defined\n-                  --  before U_Ent. Clearly if they are in different\n-                  --  units this requirement is met since the unit\n-                  --  containing Ent is already processed.\n+                  --  This is the case where we must have Ent defined before\n+                  --  U_Ent. Clearly if they are in different units this\n+                  --  requirement is met since the unit containing Ent is\n+                  --  already processed.\n \n                   if not In_Same_Source_Unit (Ent, U_Ent) then\n                      return;\n \n-                  --  Otherwise location of Ent must be before the\n-                  --  location of U_Ent, that's what prior defined means.\n+                  --  Otherwise location of Ent must be before the location\n+                  --  of U_Ent, that's what prior defined means.\n \n                   elsif Sloc (Ent) < Loc_U_Ent then\n                      return;\n@@ -3107,15 +3102,15 @@ package body Sem_Ch13 is\n             when N_Unchecked_Type_Conversion =>\n                Check_Expr_Constants (Expression (Nod));\n \n-               --  If this is a rewritten unchecked conversion, subtypes\n-               --  in this node are those created within the instance.\n-               --  To avoid order of elaboration issues, replace them\n-               --  with their base types. Note that address clauses can\n-               --  cause order of elaboration problems because they are\n-               --  elaborated by the back-end at the point of definition,\n-               --  and may mention entities declared in between (as long\n-               --  as everything is static). It is user-friendly to allow\n-               --  unchecked conversions in this context.\n+               --  If this is a rewritten unchecked conversion, subtypes in\n+               --  this node are those created within the instance. To avoid\n+               --  order of elaboration issues, replace them with their base\n+               --  types. Note that address clauses can cause order of\n+               --  elaboration problems because they are elaborated by the\n+               --  back-end at the point of definition, and may mention\n+               --  entities declared in between (as long as everything is\n+               --  static). It is user-friendly to allow unchecked conversions\n+               --  in this context.\n \n                if Nkind (Original_Node (Nod)) = N_Function_Call then\n                   Set_Etype (Expression (Nod),\n@@ -3275,7 +3270,7 @@ package body Sem_Ch13 is\n          if Siz < M then\n \n             --  Size is less than minimum size, but one possibility remains\n-            --  that we can manage with the new size if we bias the type\n+            --  that we can manage with the new size if we bias the type.\n \n             M := UI_From_Int (Minimum_Size (UT, Biased => True));\n \n@@ -3347,9 +3342,8 @@ package body Sem_Ch13 is\n       else\n          declare\n             Id    : constant Attribute_Id := Get_Attribute_Id (Chars (N));\n-\n          begin\n-            return Id = Attribute_Input\n+            return   Id = Attribute_Input\n               or else Id = Attribute_Output\n               or else Id = Attribute_Read\n               or else Id = Attribute_Write\n@@ -3397,7 +3391,7 @@ package body Sem_Ch13 is\n          --  we have short and long addresses, and it is possible for an access\n          --  type to have a short address size (and thus be less than the size\n          --  of System.Address itself). We simply skip the check for VMS, and\n-         --  leave the back end to do the check.\n+         --  leave it to the back end to do the check.\n \n       elsif Is_Access_Type (T) then\n          if OpenVMS_On_Target then\n@@ -3415,9 +3409,9 @@ package body Sem_Ch13 is\n \n       elsif Is_Discrete_Type (T) then\n \n-         --  The following loop is looking for the nearest compile time\n-         --  known bounds following the ancestor subtype chain. The idea\n-         --  is to find the most restrictive known bounds information.\n+         --  The following loop is looking for the nearest compile time known\n+         --  bounds following the ancestor subtype chain. The idea is to find\n+         --  the most restrictive known bounds information.\n \n          Ancest := T;\n          loop\n@@ -3453,17 +3447,17 @@ package body Sem_Ch13 is\n          end loop;\n \n       --  Fixed-point types. We can't simply use Expr_Value to get the\n-      --  Corresponding_Integer_Value values of the bounds, since these\n-      --  do not get set till the type is frozen, and this routine can\n-      --  be called before the type is frozen. Similarly the test for\n-      --  bounds being static needs to include the case where we have\n-      --  unanalyzed real literals for the same reason.\n+      --  Corresponding_Integer_Value values of the bounds, since these do not\n+      --  get set till the type is frozen, and this routine can be called\n+      --  before the type is frozen. Similarly the test for bounds being static\n+      --  needs to include the case where we have unanalyzed real literals for\n+      --  the same reason.\n \n       elsif Is_Fixed_Point_Type (T) then\n \n-         --  The following loop is looking for the nearest compile time\n-         --  known bounds following the ancestor subtype chain. The idea\n-         --  is to find the most restrictive known bounds information.\n+         --  The following loop is looking for the nearest compile time known\n+         --  bounds following the ancestor subtype chain. The idea is to find\n+         --  the most restrictive known bounds information.\n \n          Ancest := T;\n          loop\n@@ -3532,8 +3526,8 @@ package body Sem_Ch13 is\n       end if;\n \n       --  Signed case. Note that we consider types like range 1 .. -1 to be\n-      --  signed for the purpose of computing the size, since the bounds\n-      --  have to be accomodated in the base type.\n+      --  signed for the purpose of computing the size, since the bounds have\n+      --  to be accomodated in the base type.\n \n       if Lo < 0 or else Hi < 0 then\n          S := 1;\n@@ -3725,7 +3719,7 @@ package body Sem_Ch13 is\n          return True;\n       end if;\n \n-      --  Otherwise check for incompleted type\n+      --  Otherwise check for incomplete type\n \n       if Is_Incomplete_Or_Private_Type (T)\n         and then No (Underlying_Type (T))\n@@ -3827,23 +3821,22 @@ package body Sem_Ch13 is\n \n       if Is_Overloadable (T)\n         and then Nkind (N) = N_Pragma\n-        and then (Chars (N) = Name_Convention\n-                    or else\n-                  Chars (N) = Name_Import\n-                    or else\n-                  Chars (N) = Name_Export\n-                    or else\n-                  Chars (N) = Name_External\n-                    or else\n-                  Chars (N) = Name_Interface)\n       then\n-         null;\n-      else\n-         Record_Rep_Item (T, N);\n+         declare\n+            Pname : constant Name_Id := Pragma_Name (N);\n+         begin\n+            if Pname = Name_Convention or else\n+               Pname = Name_Import     or else\n+               Pname = Name_Export     or else\n+               Pname = Name_External   or else\n+               Pname = Name_Interface\n+            then\n+               return False;\n+            end if;\n+         end;\n       end if;\n \n-      --  Rep item was OK, not too late\n-\n+      Record_Rep_Item (T, N);\n       return False;\n    end Rep_Item_Too_Late;\n \n@@ -3919,8 +3912,8 @@ package body Sem_Ch13 is\n          return not Has_Non_Standard_Rep (T2);\n       end if;\n \n-      --  Here the two types both have non-standard representation, and we\n-      --  need to determine if they have the same non-standard representation\n+      --  Here the two types both have non-standard representation, and we need\n+      --  to determine if they have the same non-standard representation.\n \n       --  For arrays, we simply need to test if the component sizes are the\n       --  same. Pragma Pack is reflected in modified component sizes, so this\n@@ -4240,8 +4233,8 @@ package body Sem_Ch13 is\n \n       Target := Ancestor_Subtype (Etype (Act_Unit));\n \n-      --  If either type is generic, the instantiation happens within a\n-      --  generic unit, and there is nothing to check. The proper check\n+      --  If either type is generic, the instantiation happens within a generic\n+      --  unit, and there is nothing to check. The proper check\n       --  will happen when the enclosing generic is instantiated.\n \n       if Is_Generic_Type (Source) or else Is_Generic_Type (Target) then\n@@ -4271,8 +4264,17 @@ package body Sem_Ch13 is\n         and then Convention (Target) /= Convention (Source)\n         and then Warn_On_Unchecked_Conversion\n       then\n-         Error_Msg_N\n-           (\"?conversion between pointers with different conventions!\", N);\n+         --  Give warnings for subprogram pointers only on most targets. The\n+         --  exception is VMS, where data pointers can have different lengths\n+         --  depending on the pointer convention.\n+\n+         if Is_Access_Subprogram_Type (Target)\n+           or else Is_Access_Subprogram_Type (Source)\n+           or else OpenVMS_On_Target\n+         then\n+            Error_Msg_N\n+              (\"?conversion between pointers with different conventions!\", N);\n+         end if;\n       end if;\n \n       --  Warn if one of the operands is Ada.Calendar.Time. Do not emit a\n@@ -4305,10 +4307,10 @@ package body Sem_Ch13 is\n          end;\n       end if;\n \n-      --  Make entry in unchecked conversion table for later processing\n-      --  by Validate_Unchecked_Conversions, which will check sizes and\n-      --  alignments (using values set by the back-end where possible).\n-      --  This is only done if the appropriate warning is active\n+      --  Make entry in unchecked conversion table for later processing by\n+      --  Validate_Unchecked_Conversions, which will check sizes and alignments\n+      --  (using values set by the back-end where possible). This is only done\n+      --  if the appropriate warning is active.\n \n       if Warn_On_Unchecked_Conversion then\n          Unchecked_Conversions.Append\n@@ -4330,10 +4332,10 @@ package body Sem_Ch13 is\n          end if;\n       end if;\n \n-      --  If unchecked conversion to access type, and access type is\n-      --  declared in the same unit as the unchecked conversion, then\n-      --  set the No_Strict_Aliasing flag (no strict aliasing is\n-      --  implicit in this situation).\n+      --  If unchecked conversion to access type, and access type is declared\n+      --  in the same unit as the unchecked conversion, then set the\n+      --  No_Strict_Aliasing flag (no strict aliasing is implicit in this\n+      --  situation).\n \n       if Is_Access_Type (Target) and then\n         In_Same_Source_Unit (Target, N)\n@@ -4344,16 +4346,16 @@ package body Sem_Ch13 is\n       --  Generate N_Validate_Unchecked_Conversion node for back end in\n       --  case the back end needs to perform special validation checks.\n \n-      --  Shouldn't this be in exp_ch13, since the check only gets done\n+      --  Shouldn't this be in Exp_Ch13, since the check only gets done\n       --  if we have full expansion and the back end is called ???\n \n       Vnode :=\n         Make_Validate_Unchecked_Conversion (Sloc (N));\n       Set_Source_Type (Vnode, Source);\n       Set_Target_Type (Vnode, Target);\n \n-      --  If the unchecked conversion node is in a list, just insert before\n-      --  it. If not we have some strange case, not worth bothering about.\n+      --  If the unchecked conversion node is in a list, just insert before it.\n+      --  If not we have some strange case, not worth bothering about.\n \n       if Is_List_Member (N) then\n          Insert_After (N, Vnode);\n@@ -4378,11 +4380,11 @@ package body Sem_Ch13 is\n             Target_Siz    : Uint;\n \n          begin\n-            --  This validation check, which warns if we have unequal sizes\n-            --  for unchecked conversion, and thus potentially implementation\n+            --  This validation check, which warns if we have unequal sizes for\n+            --  unchecked conversion, and thus potentially implementation\n             --  dependent semantics, is one of the few occasions on which we\n-            --  use the official RM size instead of Esize. See description\n-            --  in Einfo \"Handling of Type'Size Values\" for details.\n+            --  use the official RM size instead of Esize. See description in\n+            --  Einfo \"Handling of Type'Size Values\" for details.\n \n             if Serious_Errors_Detected = 0\n               and then Known_Static_RM_Size (Source)"}]}