{"sha": "5aaa8fb40681ee66282d73dab8c8eccbf5ee0518", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWFhYThmYjQwNjgxZWU2NjI4MmQ3M2RhYjhjOGVjY2JmNWVlMDUxOA==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2017-07-21T00:27:51Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2017-07-21T00:27:51Z"}, "message": "Remove TYPE_METHODS.\n\n\tgcc/\n\tRemove TYPE_METHODS.\n\t* tree.h (TYPE_METHODS): Delete.\n\t* dwarf2out.c (gen_member_die): Member fns are on TYPE_FIELDS.\n\t* dbxout.c (dbxout_type_fields): Ignore FUNCTION_DECLs.\n\t(dbxout_type_methods): Scan TYPE_FIELDS.\n\t(dbxout_type): Don't check TYPE_METHODS here.\n\t* function.c (use_register_for_decl): Always ignore register for\n\tclass types when not optimizing.\n\t* ipa-devirt.c (odr_types_equivalent_p): Delete TYPE_METHODS scan.\n\t* tree.c (free_lang_data_in_type): Stitch out member functions and\n\ttemplates from TYPE_FIELDS.\n\t(build_distinct_type_copy, verify_type_variant,\n\tverify_type): Member fns are on TYPE_FIELDS.\n\t* tree-dump.c (dequeue_and_dump): No TYPE_METHODS.\n\t* tree-pretty-print.c (dump_generic_node): Likewise.\n\n\tgcc/cp/\n\tRemove TYPE_METHODS.\n\t* class.c (maybe_warn_about_overly_private_class,\n\tfinish_struct_methods, one_inheriting_sig, count_fields,\n\tadd_fields_to_record_type, check_field_decls, check_methods,\n\tclone_function_decl, set_method_tm_attributes,\n\tfinalize_literal_type_property, check_bases_and_members,\n\tcreate_vtable_ptr, determine_key_method,\n\tunreverse_member_declarations, finish_struct,\n\tadd_vcall_offset_vtbl_entries_1): Member fns are on TYPE_FIELDS.\n\t* decl.c (fixup_anonymous_aggr): Likewise.\n\t* decl2.c (reset_type_linkage_2): Likewise.\n\t* method.c (after_nsdmi_defaulted_late_checks,\n\tlazily_declare_fn): Likewise.\n\t* optimize.c (maybe_thunk_body, maybe_clone_body): Likewise.\n\t* pt.c (instantiate_class_template_1, tsubst_expr,\n\tdo_type_instantiation, instantiate_pending_templates): Likewise.\n\t* search.c (lookup_field_1): Likewise.\n\t* semantics.c (finish_member_declaration,\n\tfinish_omp_declare_simd_methods): Likewise.\n\n\tgcc/c-family/\n\tRemove TYPE_METHODS.\n\t* c-ada-spec.c (is_tagged_type, has_nontrivial_methods,\n\tdump_ada_template, print_ada_methods,\n\tprint_ada_declaration): Member fns are on TYPE_FIELDS.\n\n\tgcc/objc/\n\tRemove TYPE_METHODS.\n\t* objc-runtime-shared-support.c (build_ivar_list_initializer):\n\tDon't presume first item is a FIELD_DECL.\n\n\tgcc/testsuite/\n\t* g++.dg/ext/anon-struct6.C: Adjust diag.\n\t* g++.old-deja/g++.other/anon4.C: Adjust diag.\n\n\tlibcc1/\n\tRemove TYPE_METHODS.\n\t* libcp1plugin.cc (plugin_build_decl): Member fns are on TYPE_FIELDS.\n\nFrom-SVN: r250413", "tree": {"sha": "9eb091e90a6d0a753271dc34499ed1179b3527ca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9eb091e90a6d0a753271dc34499ed1179b3527ca"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5aaa8fb40681ee66282d73dab8c8eccbf5ee0518", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5aaa8fb40681ee66282d73dab8c8eccbf5ee0518", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5aaa8fb40681ee66282d73dab8c8eccbf5ee0518", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5aaa8fb40681ee66282d73dab8c8eccbf5ee0518/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "61612fa5daee514e736102d0bdfb5a4eec391430", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/61612fa5daee514e736102d0bdfb5a4eec391430", "html_url": "https://github.com/Rust-GCC/gccrs/commit/61612fa5daee514e736102d0bdfb5a4eec391430"}], "stats": {"total": 823, "additions": 360, "deletions": 463}, "files": [{"sha": "713788c77c692f5997819265ec268f690b8c225c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5aaa8fb40681ee66282d73dab8c8eccbf5ee0518/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5aaa8fb40681ee66282d73dab8c8eccbf5ee0518/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5aaa8fb40681ee66282d73dab8c8eccbf5ee0518", "patch": "@@ -1,3 +1,21 @@\n+2017-07-20  Nathan Sidwell  <nathan@acm.org>\n+\n+\tRemove TYPE_METHODS.\n+\t* tree.h (TYPE_METHODS): Delete.\n+\t* dwarf2out.c (gen_member_die): Member fns are on TYPE_FIELDS.\n+\t* dbxout.c (dbxout_type_fields): Ignore FUNCTION_DECLs.\n+\t(dbxout_type_methods): Scan TYPE_FIELDS.\n+\t(dbxout_type): Don't check TYPE_METHODS here.\n+\t* function.c (use_register_for_decl): Always ignore register for\n+\tclass types when not optimizing.\n+\t* ipa-devirt.c (odr_types_equivalent_p): Delete TYPE_METHODS scan.\n+\t* tree.c (free_lang_data_in_type): Stitch out member functions and\n+\ttemplates from TYPE_FIELDS.\n+\t(build_distinct_type_copy, verify_type_variant,\n+\tverify_type): Member fns are on TYPE_FIELDS.\n+\t* tree-dump.c (dequeue_and_dump): No TYPE_METHODS.\n+\t* tree-pretty-print.c (dump_generic_node): Likewise.\n+\n 2017-07-20  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR target/80846"}, {"sha": "bd00b252f09c3d9d7f6b270f64a658445b43cac9", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5aaa8fb40681ee66282d73dab8c8eccbf5ee0518/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5aaa8fb40681ee66282d73dab8c8eccbf5ee0518/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=5aaa8fb40681ee66282d73dab8c8eccbf5ee0518", "patch": "@@ -1,3 +1,10 @@\n+2017-07-20  Nathan Sidwell  <nathan@acm.org>\n+\n+\tRemove TYPE_METHODS.\n+\t* c-ada-spec.c (is_tagged_type, has_nontrivial_methods,\n+\tdump_ada_template, print_ada_methods,\n+\tprint_ada_declaration): Member fns are on TYPE_FIELDS.\n+\n 2017-07-18  Nathan Sidwell  <nathan@acm.org>\n \n \t* c-warn.c (warn_for_memset): Use TYPE_{MIN,MAX}_VALUE."}, {"sha": "d39501c7b914d539ec4c6f1b274b7b73c6d234c7", "filename": "gcc/c-family/c-ada-spec.c", "status": "modified", "additions": 46, "deletions": 66, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5aaa8fb40681ee66282d73dab8c8eccbf5ee0518/gcc%2Fc-family%2Fc-ada-spec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5aaa8fb40681ee66282d73dab8c8eccbf5ee0518/gcc%2Fc-family%2Fc-ada-spec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-ada-spec.c?ref=5aaa8fb40681ee66282d73dab8c8eccbf5ee0518", "patch": "@@ -1070,16 +1070,11 @@ has_static_fields (const_tree type)\n static bool\n is_tagged_type (const_tree type)\n {\n-  tree tmp;\n-\n   if (!type || !RECORD_OR_UNION_TYPE_P (type))\n     return false;\n \n-  /* TYPE_METHODS is only set on the main variant.  */\n-  type = TYPE_MAIN_VARIANT (type);\n-\n-  for (tmp = TYPE_METHODS (type); tmp; tmp = TREE_CHAIN (tmp))\n-    if (TREE_CODE (tmp) == FUNCTION_DECL && DECL_VINDEX (tmp))\n+  for (tree fld = TYPE_FIELDS (type); fld; fld = TREE_CHAIN (fld))\n+    if (TREE_CODE (fld) == FUNCTION_DECL && DECL_VINDEX (fld))\n       return true;\n \n   return false;\n@@ -1093,8 +1088,6 @@ is_tagged_type (const_tree type)\n static bool\n has_nontrivial_methods (tree type)\n {\n-  tree tmp;\n-\n   if (!type || !RECORD_OR_UNION_TYPE_P (type))\n     return false;\n \n@@ -1106,12 +1099,9 @@ has_nontrivial_methods (tree type)\n   if (!cpp_check (type, IS_TRIVIAL))\n     return true;\n \n-  /* TYPE_METHODS is only set on the main variant.  */\n-  type = TYPE_MAIN_VARIANT (type);\n-\n   /* If there are user-defined methods, they are deemed non-trivial.  */\n-  for (tmp = TYPE_METHODS (type); tmp; tmp = TREE_CHAIN (tmp))\n-    if (!DECL_ARTIFICIAL (tmp))\n+  for (tree fld = TYPE_FIELDS (type); fld; fld = DECL_CHAIN (fld))\n+    if (TREE_CODE (TREE_TYPE (fld)) == METHOD_TYPE && !DECL_ARTIFICIAL (fld))\n       return true;\n \n   return false;\n@@ -1896,7 +1886,7 @@ dump_ada_template (pretty_printer *buffer, tree t, int spc)\n       if (TREE_VEC_LENGTH (types) == 0)\n \tbreak;\n \n-      if (!RECORD_OR_UNION_TYPE_P (instance) || !TYPE_METHODS (instance))\n+      if (!RECORD_OR_UNION_TYPE_P (instance))\n \tbreak;\n \n       /* We are interested in concrete template instantiations only: skip\n@@ -2442,25 +2432,23 @@ dump_generic_ada_node (pretty_printer *buffer, tree node, tree type, int spc,\n static int\n print_ada_methods (pretty_printer *buffer, tree node, int spc)\n {\n-  tree t;\n-  int res;\n-\n   if (!has_nontrivial_methods (node))\n     return 0;\n \n   pp_semicolon (buffer);\n \n-  res = 1;\n-  for (t = TYPE_METHODS (node); t; t = TREE_CHAIN (t))\n-    {\n-      if (res)\n-\t{\n-\t  pp_newline (buffer);\n-\t  pp_newline (buffer);\n-\t}\n-\n-      res = print_ada_declaration (buffer, t, node, spc);\n-    }\n+  int res = 1;\n+  for (tree fld = TYPE_FIELDS (node); fld; fld = DECL_CHAIN (fld))\n+    if (TREE_CODE (TREE_TYPE (fld)) == METHOD_TYPE)\n+      {\n+\tif (res)\n+\t  {\n+\t    pp_newline (buffer);\n+\t    pp_newline (buffer);\n+\t  }\n+\t\n+\tres = print_ada_declaration (buffer, fld, node, spc);\n+      }\n \n   return 1;\n }\n@@ -2961,19 +2949,13 @@ print_ada_declaration (pretty_printer *buffer, tree t, tree type, int spc)\n \t  dump_generic_ada_node (buffer, ret_type, type, spc, false, true);\n \t}\n \n-      if (is_constructor\n-\t  && RECORD_OR_UNION_TYPE_P (type)\n-\t  && TYPE_METHODS (type))\n-\t{\n-\t  tree tmp;\n-\n-\t  for (tmp = TYPE_METHODS (type); tmp; tmp = TREE_CHAIN (tmp))\n-\t    if (cpp_check (tmp, IS_ABSTRACT))\n-\t      {\n-\t\tis_abstract_class = true;\n-\t\tbreak;\n-\t      }\n-\t}\n+      if (is_constructor && RECORD_OR_UNION_TYPE_P (type))\n+\tfor (tree fld = TYPE_FIELDS (type); fld; fld = DECL_CHAIN (fld))\n+\t  if (cpp_check (fld, IS_ABSTRACT))\n+\t    {\n+\t      is_abstract_class = true;\n+\t      break;\n+\t    }\n \n       if (is_abstract || is_abstract_class)\n \tpp_string (buffer, \" is abstract\");\n@@ -3028,35 +3010,33 @@ print_ada_declaration (pretty_printer *buffer, tree t, tree type, int spc)\n \n       pp_string (buffer, \" is \");\n \n-      /* Check whether we have an Ada interface compatible class.  */\n+      /* Check whether we have an Ada interface compatible class.\n+\t That is only have a vtable non-static data member and no\n+\t non-abstract methods.  */\n       if (cpp_check\n-\t  && RECORD_OR_UNION_TYPE_P (TREE_TYPE (t))\n-\t  && TYPE_METHODS (TREE_TYPE (t)))\n+\t  && RECORD_OR_UNION_TYPE_P (TREE_TYPE (t)))\n \t{\n-\t  int num_fields = 0;\n-\t  tree tmp;\n+\t  is_interface = -1;\n \n \t  /* Check that there are no fields other than the virtual table.  */\n-\t  for (tmp = TYPE_FIELDS (TREE_TYPE (t)); tmp; tmp = TREE_CHAIN (tmp))\n-\t    {\n-\t      if (TREE_CODE (tmp) == TYPE_DECL)\n-\t\tcontinue;\n-\t      num_fields++;\n-\t    }\n-\n-\t  if (num_fields == 1)\n-\t    is_interface = 1;\n-\n-\t  /* Also check that there are only pure virtual methods.  Since the\n-\t     class is empty, we can skip implicit constructors/destructors.  */\n-\t  for (tmp = TYPE_METHODS (TREE_TYPE (t)); tmp; tmp = TREE_CHAIN (tmp))\n+\t  for (tree fld = TYPE_FIELDS (TREE_TYPE (t));\n+\t       fld; fld = TREE_CHAIN (fld))\n \t    {\n-\t      if (DECL_ARTIFICIAL (tmp))\n-\t\tcontinue;\n-\t      if (cpp_check (tmp, IS_ABSTRACT))\n-\t\tis_abstract_record = 1;\n-\t      else\n-\t\tis_interface = 0;\n+\t      if (TREE_CODE (fld) == FIELD_DECL)\n+\t\t{\n+\t\t  if (is_interface < 0 && DECL_VIRTUAL_P (fld))\n+\t\t    is_interface = 1;\n+\t\t  else\n+\t\t    is_interface = 0;\n+\t\t}\n+\t      else if (TREE_CODE (TREE_TYPE (fld)) == METHOD_TYPE\n+\t\t       && !DECL_ARTIFICIAL (fld))\n+\t\t{\n+\t\t  if (cpp_check (fld, IS_ABSTRACT))\n+\t\t    is_abstract_record = 1;\n+\t\t  else\n+\t\t    is_interface = 0;\n+\t\t}\n \t    }\n \t}\n "}, {"sha": "234d0425839e1e9b3006d9cac4a9328b154a0b65", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5aaa8fb40681ee66282d73dab8c8eccbf5ee0518/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5aaa8fb40681ee66282d73dab8c8eccbf5ee0518/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=5aaa8fb40681ee66282d73dab8c8eccbf5ee0518", "patch": "@@ -1,3 +1,25 @@\n+2017-07-20  Nathan Sidwell  <nathan@acm.org>\n+\n+\tRemove TYPE_METHODS.\n+\t* class.c (maybe_warn_about_overly_private_class,\n+\tfinish_struct_methods, one_inheriting_sig, count_fields,\n+\tadd_fields_to_record_type, check_field_decls, check_methods,\n+\tclone_function_decl, set_method_tm_attributes,\n+\tfinalize_literal_type_property, check_bases_and_members,\n+\tcreate_vtable_ptr, determine_key_method,\n+\tunreverse_member_declarations, finish_struct,\n+\tadd_vcall_offset_vtbl_entries_1): Member fns are on TYPE_FIELDS.\n+\t* decl.c (fixup_anonymous_aggr): Likewise.\n+\t* decl2.c (reset_type_linkage_2): Likewise.\n+\t* method.c (after_nsdmi_defaulted_late_checks,\n+\tlazily_declare_fn): Likewise.\n+\t* optimize.c (maybe_thunk_body, maybe_clone_body): Likewise.\n+\t* pt.c (instantiate_class_template_1, tsubst_expr,\n+\tdo_type_instantiation, instantiate_pending_templates): Likewise.\n+\t* search.c (lookup_field_1): Likewise.\n+\t* semantics.c (finish_member_declaration,\n+\tfinish_omp_declare_simd_methods): Likewise.\n+\n 2017-07-19  Nathan Sidwell  <nathan@acm.org>\n \n \t* class.c (add_implicitly_declared_members): Use"}, {"sha": "eac664929f81dcabb3364d27621d1cff0af4472d", "filename": "gcc/cp/class.c", "status": "modified", "additions": 94, "deletions": 82, "changes": 176, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5aaa8fb40681ee66282d73dab8c8eccbf5ee0518/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5aaa8fb40681ee66282d73dab8c8eccbf5ee0518/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=5aaa8fb40681ee66282d73dab8c8eccbf5ee0518", "patch": "@@ -2149,7 +2149,6 @@ maybe_warn_about_overly_private_class (tree t)\n {\n   int has_member_fn = 0;\n   int has_nonprivate_method = 0;\n-  tree fn;\n \n   if (!warn_ctor_dtor_privacy\n       /* If the class has friends, those entities might create and\n@@ -2179,26 +2178,26 @@ maybe_warn_about_overly_private_class (tree t)\n      functions are private.  (Since there are no friends or\n      non-private statics, we can't ever call any of the private member\n      functions.)  */\n-  for (fn = TYPE_METHODS (t); fn; fn = DECL_CHAIN (fn))\n-    /* We're not interested in compiler-generated methods; they don't\n-       provide any way to call private members.  */\n-    if (!DECL_ARTIFICIAL (fn))\n+  for (tree fn = TYPE_FIELDS (t); fn; fn = DECL_CHAIN (fn))\n+    if (!DECL_DECLARES_FUNCTION_P (fn))\n+      /* Not a function.  */;\n+    else if (DECL_ARTIFICIAL (fn))\n+      /* We're not interested in compiler-generated methods; they don't\n+\t provide any way to call private members.  */;\n+    else if (!TREE_PRIVATE (fn))\n       {\n-\tif (!TREE_PRIVATE (fn))\n-\t  {\n-\t    if (DECL_STATIC_FUNCTION_P (fn))\n-\t      /* A non-private static member function is just like a\n-\t\t friend; it can create and invoke private member\n-\t\t functions, and be accessed without a class\n-\t\t instance.  */\n-\t      return;\n+\tif (DECL_STATIC_FUNCTION_P (fn))\n+\t  /* A non-private static member function is just like a\n+\t     friend; it can create and invoke private member\n+\t     functions, and be accessed without a class\n+\t     instance.  */\n+\t  return;\n \n-\t    has_nonprivate_method = 1;\n-\t    /* Keep searching for a static member function.  */\n-\t  }\n-\telse if (!DECL_CONSTRUCTOR_P (fn) && !DECL_DESTRUCTOR_P (fn))\n-\t  has_member_fn = 1;\n+\thas_nonprivate_method = 1;\n+\t/* Keep searching for a static member function.  */\n       }\n+    else if (!DECL_CONSTRUCTOR_P (fn) && !DECL_DESTRUCTOR_P (fn))\n+      has_member_fn = 1;\n \n   if (!has_nonprivate_method && has_member_fn)\n     {\n@@ -2228,14 +2227,14 @@ maybe_warn_about_overly_private_class (tree t)\n   /* Even if some of the member functions are non-private, the class\n      won't be useful for much if all the constructors or destructors\n      are private: such an object can never be created or destroyed.  */\n-  fn = CLASSTYPE_DESTRUCTOR (t);\n-  if (fn && TREE_PRIVATE (fn))\n-    {\n-      warning (OPT_Wctor_dtor_privacy,\n-\t       \"%q#T only defines a private destructor and has no friends\",\n-\t       t);\n-      return;\n-    }\n+  if (tree dtor = CLASSTYPE_DESTRUCTOR (t))\n+    if (TREE_PRIVATE (dtor))\n+      {\n+\twarning (OPT_Wctor_dtor_privacy,\n+\t\t \"%q#T only defines a private destructor and has no friends\",\n+\t\t t);\n+\treturn;\n+      }\n \n   /* Warn about classes that have private constructors and no friends.  */\n   if (TYPE_HAS_USER_CONSTRUCTOR (t)\n@@ -2373,7 +2372,6 @@ resort_type_method_vec (void* obj,\n static void\n finish_struct_methods (tree t)\n {\n-  tree fn_fields;\n   vec<tree, va_gc> *method_vec;\n   int slot, len;\n \n@@ -2384,16 +2382,17 @@ finish_struct_methods (tree t)\n   len = method_vec->length ();\n \n   /* Clear DECL_IN_AGGR_P for all functions.  */\n-  for (fn_fields = TYPE_METHODS (t); fn_fields;\n-       fn_fields = DECL_CHAIN (fn_fields))\n-    DECL_IN_AGGR_P (fn_fields) = 0;\n+  for (tree fn = TYPE_FIELDS (t); fn; fn = DECL_CHAIN (fn))\n+    if (DECL_DECLARES_FUNCTION_P (fn))\n+      DECL_IN_AGGR_P (fn) = false;\n \n   /* Issue warnings about private constructors and such.  If there are\n      no methods, then some public defaults are generated.  */\n   maybe_warn_about_overly_private_class (t);\n \n   /* The type conversion ops have to live at the front of the vec, so we\n      can't sort them.  */\n+  tree fn_fields;\n   for (slot = CLASSTYPE_FIRST_CONVERSION_SLOT;\n        method_vec->iterate (slot, &fn_fields);\n        ++slot)\n@@ -3305,6 +3304,8 @@ declare_virt_assop_and_dtor (tree t)\n static void\n one_inheriting_sig (tree t, tree ctor, tree *parms, int nparms)\n {\n+  gcc_assert (TYPE_MAIN_VARIANT (t) == t);\n+\n   /* We don't declare an inheriting ctor that would be a default,\n      copy or move ctor for derived or base.  */\n   if (nparms == 0)\n@@ -3322,11 +3323,11 @@ one_inheriting_sig (tree t, tree ctor, tree *parms, int nparms)\n     parmlist = tree_cons (NULL_TREE, parms[i], parmlist);\n   tree fn = implicitly_declare_fn (sfk_inheriting_constructor,\n \t\t\t\t   t, false, ctor, parmlist);\n-  gcc_assert (TYPE_MAIN_VARIANT (t) == t);\n+\n   if (add_method (t, fn, false))\n     {\n-      DECL_CHAIN (fn) = TYPE_METHODS (t);\n-      TYPE_METHODS (t) = fn;\n+      DECL_CHAIN (fn) = TYPE_FIELDS (t);\n+      TYPE_FIELDS (t) = fn;\n     }\n }\n \n@@ -3465,7 +3466,9 @@ count_fields (tree fields)\n   int n_fields = 0;\n   for (x = fields; x; x = DECL_CHAIN (x))\n     {\n-      if (TREE_CODE (x) == FIELD_DECL && ANON_AGGR_TYPE_P (TREE_TYPE (x)))\n+      if (DECL_DECLARES_FUNCTION_P (x))\n+\t/* Functions are dealt with separately.  */;\n+      else if (TREE_CODE (x) == FIELD_DECL && ANON_AGGR_TYPE_P (TREE_TYPE (x)))\n \tn_fields += count_fields (TYPE_FIELDS (TREE_TYPE (x)));\n       else\n \tn_fields += 1;\n@@ -3483,7 +3486,9 @@ add_fields_to_record_type (tree fields, struct sorted_fields_type *field_vec, in\n   tree x;\n   for (x = fields; x; x = DECL_CHAIN (x))\n     {\n-      if (TREE_CODE (x) == FIELD_DECL && ANON_AGGR_TYPE_P (TREE_TYPE (x)))\n+      if (DECL_DECLARES_FUNCTION_P (x))\n+\t/* Functions are handled separately.  */;\n+      else if (TREE_CODE (x) == FIELD_DECL && ANON_AGGR_TYPE_P (TREE_TYPE (x)))\n \tidx = add_fields_to_record_type (TYPE_FIELDS (TREE_TYPE (x)), field_vec, idx);\n       else\n \tfield_vec->elts[idx++] = x;\n@@ -3740,6 +3745,10 @@ check_field_decls (tree t, tree *access_decls,\n \t  || TREE_CODE (x) == TEMPLATE_DECL)\n \tcontinue;\n \n+      if (TREE_CODE (x) == FUNCTION_DECL)\n+\t/* FIXME: We should fold in the checking from check_methods.  */\n+\tcontinue;\n+\n       /* If we've gotten this far, it's a data member, possibly static,\n \t or an enumerator.  */\n       if (TREE_CODE (x) != CONST_DECL)\n@@ -4664,39 +4673,42 @@ build_base_fields (record_layout_info rli,\n     }\n }\n \n-/* Go through the TYPE_METHODS of T issuing any appropriate\n+/* Go through the TYPE_FIELDS of T issuing any appropriate\n    diagnostics, figuring out which methods override which other\n    methods, and so forth.  */\n \n static void\n check_methods (tree t)\n {\n-  tree x;\n+  for (tree x = TYPE_FIELDS (t); x; x = DECL_CHAIN (x))\n+    if (DECL_DECLARES_FUNCTION_P (x))\n+      {\n+\tcheck_for_override (x, t);\n+\n+\tif (DECL_PURE_VIRTUAL_P (x)\n+\t    && (TREE_CODE (x) != FUNCTION_DECL || ! DECL_VINDEX (x)))\n+\t  error (\"initializer specified for non-virtual method %q+D\", x);\n+\t/* The name of the field is the original field name\n+\t   Save this in auxiliary field for later overloading.  */\n+\tif (TREE_CODE (x) == FUNCTION_DECL && DECL_VINDEX (x))\n+\t  {\n+\t    TYPE_POLYMORPHIC_P (t) = 1;\n+\t    if (DECL_PURE_VIRTUAL_P (x))\n+\t      vec_safe_push (CLASSTYPE_PURE_VIRTUALS (t), x);\n+\t  }\n \n-  for (x = TYPE_METHODS (t); x; x = DECL_CHAIN (x))\n-    {\n-      check_for_override (x, t);\n-      if (DECL_PURE_VIRTUAL_P (x) && (TREE_CODE (x) != FUNCTION_DECL || ! DECL_VINDEX (x)))\n-\terror (\"initializer specified for non-virtual method %q+D\", x);\n-      /* The name of the field is the original field name\n-\t Save this in auxiliary field for later overloading.  */\n-      if (TREE_CODE (x) == FUNCTION_DECL && DECL_VINDEX (x))\n-\t{\n-\t  TYPE_POLYMORPHIC_P (t) = 1;\n-\t  if (DECL_PURE_VIRTUAL_P (x))\n-\t    vec_safe_push (CLASSTYPE_PURE_VIRTUALS (t), x);\n-\t}\n-      /* All user-provided destructors are non-trivial.\n-         Constructors and assignment ops are handled in\n-\t grok_special_member_properties.  */\n-      if (DECL_DESTRUCTOR_P (x) && user_provided_p (x))\n-\tTYPE_HAS_NONTRIVIAL_DESTRUCTOR (t) = 1;\n-      if (!DECL_VIRTUAL_P (x)\n-\t  && lookup_attribute (\"transaction_safe_dynamic\", DECL_ATTRIBUTES (x)))\n-\terror_at (DECL_SOURCE_LOCATION (x),\n-\t\t  \"%<transaction_safe_dynamic%> may only be specified for \"\n-\t\t  \"a virtual function\");\n-    }\n+\t/* All user-provided destructors are non-trivial.\n+\t   Constructors and assignment ops are handled in\n+\t   grok_special_member_properties.  */\n+\tif (DECL_DESTRUCTOR_P (x) && user_provided_p (x))\n+\t  TYPE_HAS_NONTRIVIAL_DESTRUCTOR (t) = 1;\n+\tif (!DECL_VIRTUAL_P (x)\n+\t    && lookup_attribute (\"transaction_safe_dynamic\",\n+\t\t\t\t DECL_ATTRIBUTES (x)))\n+\t  error_at (DECL_SOURCE_LOCATION (x),\n+\t\t    \"%<transaction_safe_dynamic%> may only be specified for \"\n+\t\t    \"a virtual function\");\n+      }\n }\n \n /* FN is a constructor or destructor.  Clone the declaration to create\n@@ -4902,7 +4914,7 @@ clone_function_decl (tree fn, bool update_methods)\n       /* For each destructor, we need three variants: an in-charge\n \t version, a not-in-charge version, and an in-charge deleting\n \t version.  We clone the deleting version first because that\n-\t means it will go second on the TYPE_METHODS list -- and that\n+\t means it will go second on the TYPE_FIELDS list -- and that\n \t corresponds to the correct layout order in the virtual\n \t function table.\n \n@@ -5174,11 +5186,10 @@ set_method_tm_attributes (tree t)\n \n   /* Any method that does not yet have a tm attribute inherits\n      the one from the class.  */\n-  for (fndecl = TYPE_METHODS (t); fndecl; fndecl = TREE_CHAIN (fndecl))\n-    {\n-      if (!find_tm_attribute (TYPE_ATTRIBUTES (TREE_TYPE (fndecl))))\n-\tapply_tm_attr (fndecl, class_tm_attr);\n-    }\n+  for (fndecl = TYPE_FIELDS (t); fndecl; fndecl = DECL_CHAIN (fndecl))\n+    if (DECL_DECLARES_FUNCTION_P (fndecl)\n+\t&& !find_tm_attribute (TYPE_ATTRIBUTES (TREE_TYPE (fndecl))))\n+      apply_tm_attr (fndecl, class_tm_attr);\n }\n \n /* Returns true if FN is a default constructor.  */\n@@ -5660,9 +5671,9 @@ finalize_literal_type_property (tree t)\n   /* C++14 DR 1684 removed this restriction.  */\n   if (cxx_dialect < cxx14\n       && !CLASSTYPE_LITERAL_P (t) && !LAMBDA_TYPE_P (t))\n-    for (fn = TYPE_METHODS (t); fn; fn = DECL_CHAIN (fn))\n-      if (DECL_DECLARED_CONSTEXPR_P (fn)\n-\t  && TREE_CODE (fn) != TEMPLATE_DECL\n+    for (fn = TYPE_FIELDS (t); fn; fn = DECL_CHAIN (fn))\n+      if (TREE_CODE (fn) == FUNCTION_DECL\n+\t  && DECL_DECLARED_CONSTEXPR_P (fn)\n \t  && DECL_NONSTATIC_MEMBER_FUNCTION_P (fn)\n \t  && !DECL_CONSTRUCTOR_P (fn))\n \t{\n@@ -5924,8 +5935,10 @@ check_bases_and_members (tree t)\n \n   /* Check defaulted declarations here so we have cant_have_const_ctor\n      and don't need to worry about clones.  */\n-  for (fn = TYPE_METHODS (t); fn; fn = DECL_CHAIN (fn))\n-    if (!DECL_ARTIFICIAL (fn) && DECL_DEFAULTED_IN_CLASS_P (fn))\n+  for (fn = TYPE_FIELDS (t); fn; fn = DECL_CHAIN (fn))\n+    if (DECL_DECLARES_FUNCTION_P (fn)\n+\t&& !DECL_ARTIFICIAL (fn)\n+\t&& DECL_DEFAULTED_IN_CLASS_P (fn))\n       {\n \tint copy = copy_fn_p (fn);\n \tif (copy > 0)\n@@ -5984,7 +5997,7 @@ create_vtable_ptr (tree t, tree* virtuals_p)\n   tree fn;\n \n   /* Collect the virtual functions declared in T.  */\n-  for (fn = TYPE_METHODS (t); fn; fn = DECL_CHAIN (fn))\n+  for (fn = TYPE_FIELDS (t); fn; fn = DECL_CHAIN (fn))\n     if (TREE_CODE (fn) == FUNCTION_DECL\n \t&& DECL_VINDEX (fn) && !DECL_MAYBE_IN_CHARGE_DESTRUCTOR_P (fn)\n \t&& TREE_CODE (DECL_VINDEX (fn)) != INTEGER_CST)\n@@ -6643,8 +6656,7 @@ determine_key_method (tree type)\n      inline at the point of class definition.  On some targets the\n      key function may not be inline; those targets should not call\n      this function until the end of the translation unit.  */\n-  for (method = TYPE_METHODS (type); method != NULL_TREE;\n-       method = DECL_CHAIN (method))\n+  for (method = TYPE_FIELDS (type); method; method = DECL_CHAIN (method))\n     if (TREE_CODE (method) == FUNCTION_DECL\n \t&& DECL_VINDEX (method) != NULL_TREE\n \t&& ! DECL_DECLARED_INLINE_P (method)\n@@ -7336,11 +7348,11 @@ unreverse_member_declarations (tree t)\n \n   /* The following lists are all in reverse order.  Put them in\n      declaration order now.  */\n-  TYPE_METHODS (t) = nreverse (TYPE_METHODS (t));\n   CLASSTYPE_DECL_LIST (t) = nreverse (CLASSTYPE_DECL_LIST (t));\n \n-  /* Actually, for the TYPE_FIELDS, only the non TYPE_DECLs are in\n-     reverse order, so we can't just use nreverse.  */\n+  /* For the TYPE_FIELDS, only the non TYPE_DECLs are in reverse\n+     order, so we can't just use nreverse.  Due to stat_hack\n+     chicanery in finish_member_declarations.  */\n   prev = NULL_TREE;\n   for (x = TYPE_FIELDS (t);\n        x && TREE_CODE (x) != TYPE_DECL;\n@@ -7350,6 +7362,7 @@ unreverse_member_declarations (tree t)\n       DECL_CHAIN (x) = prev;\n       prev = x;\n     }\n+\n   if (prev)\n     {\n       DECL_CHAIN (TYPE_FIELDS (t)) = x;\n@@ -7390,8 +7403,8 @@ finish_struct (tree t, tree attributes)\n \t CLASSTYPE_PURE_VIRTUALS contains the list of the inline friends\n \t (see CLASSTYPE_INLINE_FRIENDS) so we need to clear it.  */\n       CLASSTYPE_PURE_VIRTUALS (t) = NULL;\n-      for (x = TYPE_METHODS (t); x; x = DECL_CHAIN (x))\n-\tif (DECL_PURE_VIRTUAL_P (x))\n+      for (x = TYPE_FIELDS (t); x; x = DECL_CHAIN (x))\n+\tif (TREE_CODE (x) == FUNCTION_DECL && DECL_PURE_VIRTUAL_P (x))\n \t  vec_safe_push (CLASSTYPE_PURE_VIRTUALS (t), x);\n       complete_vars (t);\n       /* We need to add the target functions to the CLASSTYPE_METHOD_VEC if\n@@ -7416,7 +7429,6 @@ finish_struct (tree t, tree attributes)\n \t  TYPE_SIZE (x) = TYPE_SIZE (t);\n \t  TYPE_SIZE_UNIT (x) = TYPE_SIZE_UNIT (t);\n \t  TYPE_FIELDS (x) = TYPE_FIELDS (t);\n-\t  TYPE_METHODS (x) = TYPE_METHODS (t);\n \t}\n     }\n   else\n@@ -9922,7 +9934,7 @@ add_vcall_offset_vtbl_entries_1 (tree binfo, vtbl_init_data* vid)\n \n   /* The ABI requires that the methods be processed in declaration\n      order.  */\n-  for (orig_fn = TYPE_METHODS (BINFO_TYPE (binfo));\n+  for (orig_fn = TYPE_FIELDS (BINFO_TYPE (binfo));\n        orig_fn;\n        orig_fn = DECL_CHAIN (orig_fn))\n     if (TREE_CODE (orig_fn) == FUNCTION_DECL && DECL_VINDEX (orig_fn))"}, {"sha": "d98fab370d716001bc1d9b3a41a7e314df904c14", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 6, "deletions": 25, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5aaa8fb40681ee66282d73dab8c8eccbf5ee0518/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5aaa8fb40681ee66282d73dab8c8eccbf5ee0518/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=5aaa8fb40681ee66282d73dab8c8eccbf5ee0518", "patch": "@@ -4549,8 +4549,6 @@ push_throw_library_fn (tree name, tree type)\n void\n fixup_anonymous_aggr (tree t)\n {\n-  tree *q;\n-\n   /* Wipe out memory of synthesized methods.  */\n   TYPE_HAS_USER_CONSTRUCTOR (t) = 0;\n   TYPE_HAS_DEFAULT_CONSTRUCTOR (t) = 0;\n@@ -4559,29 +4557,12 @@ fixup_anonymous_aggr (tree t)\n   TYPE_HAS_COPY_ASSIGN (t) = 0;\n   TYPE_HAS_CONST_COPY_ASSIGN (t) = 0;\n \n-  /* Splice the implicitly generated functions out of the TYPE_METHODS\n-     list.  */\n-  q = &TYPE_METHODS (t);\n-  while (*q)\n-    {\n-      if (DECL_ARTIFICIAL (*q))\n-\t*q = TREE_CHAIN (*q);\n-      else\n-\tq = &DECL_CHAIN (*q);\n-    }\n-\n-  /* ISO C++ 9.5.3.  Anonymous unions may not have function members.  */\n-  if (TYPE_METHODS (t))\n-    {\n-      tree decl = TYPE_MAIN_DECL (t);\n-\n-      if (TREE_CODE (t) != UNION_TYPE)\n-\terror_at (DECL_SOURCE_LOCATION (decl), \n-\t\t  \"an anonymous struct cannot have function members\");\n-      else\n-\terror_at (DECL_SOURCE_LOCATION (decl),\n-\t\t  \"an anonymous union cannot have function members\");\n-    }\n+  /* Splice the implicitly generated functions out of TYPE_FIELDS.  */\n+  for (tree probe, *prev_p = &TYPE_FIELDS (t); (probe = *prev_p);)\n+    if (TREE_CODE (probe) == FUNCTION_DECL && DECL_ARTIFICIAL (probe))\n+      *prev_p = DECL_CHAIN (probe);\n+    else\n+      prev_p = &DECL_CHAIN (probe);\n \n   /* Anonymous aggregates cannot have fields with ctors, dtors or complex\n      assignment operators (because they cannot have these methods themselves)."}, {"sha": "2a52f8ca3e206fd74f927569c59a7c4fa2d518dc", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 10, "deletions": 19, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5aaa8fb40681ee66282d73dab8c8eccbf5ee0518/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5aaa8fb40681ee66282d73dab8c8eccbf5ee0518/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=5aaa8fb40681ee66282d73dab8c8eccbf5ee0518", "patch": "@@ -2592,6 +2592,7 @@ reset_decl_linkage (tree decl)\n   determine_visibility (decl);\n   tentative_decl_linkage (decl);\n }\n+\n static void\n reset_type_linkage_2 (tree type)\n {\n@@ -2615,18 +2616,14 @@ reset_type_linkage_2 (tree type)\n       for (tree m = TYPE_FIELDS (type); m; m = DECL_CHAIN (m))\n \t{\n \t  tree mem = STRIP_TEMPLATE (m);\n-\t  if (VAR_P (mem))\n+\t  if (TREE_CODE (mem) == VAR_DECL || TREE_CODE (mem) == FUNCTION_DECL)\n \t    reset_decl_linkage (mem);\n \t}\n-      for (tree m = TYPE_METHODS (type); m; m = DECL_CHAIN (m))\n-\t{\n-\t  tree mem = STRIP_TEMPLATE (m);\n-\t  reset_decl_linkage (mem);\n-\t}\n       binding_table_foreach (CLASSTYPE_NESTED_UTDS (type),\n \t\t\t     bt_reset_linkage_2, NULL);\n     }\n }\n+\n static void\n bt_reset_linkage_2 (binding_entry b, void */*data*/)\n {\n@@ -4997,19 +4994,13 @@ mark_used (tree decl, tsubst_flags_t complain)\n   if (TREE_CODE (decl) == FUNCTION_DECL\n       && DECL_DELETED_FN (decl))\n     {\n-      if (DECL_ARTIFICIAL (decl))\n-\t{\n-\t  if (DECL_OVERLOADED_OPERATOR_P (decl) == TYPE_EXPR\n-\t      && LAMBDA_TYPE_P (DECL_CONTEXT (decl)))\n-\t    {\n-\t      /* We mark a lambda conversion op as deleted if we can't\n-\t\t generate it properly; see maybe_add_lambda_conv_op.  */\n-\t      sorry (\"converting lambda which uses %<...%> to \"\n-\t\t     \"function pointer\");\n-\t      return false;\n-\t    }\n-\t}\n-      if (complain & tf_error)\n+      if (DECL_ARTIFICIAL (decl)\n+\t  && DECL_OVERLOADED_OPERATOR_P (decl) == TYPE_EXPR\n+\t  && LAMBDA_TYPE_P (DECL_CONTEXT (decl)))\n+\t/* We mark a lambda conversion op as deleted if we can't\n+\t   generate it properly; see maybe_add_lambda_conv_op.  */\n+\tsorry (\"converting lambda which uses %<...%> to function pointer\");\n+      else if (complain & tf_error)\n \t{\n \t  error (\"use of deleted function %qD\", decl);\n \t  if (!maybe_explain_implicit_delete (decl))"}, {"sha": "cca1b14691720fc6b3e64a79cb944bc982fd49d0", "filename": "gcc/cp/method.c", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5aaa8fb40681ee66282d73dab8c8eccbf5ee0518/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5aaa8fb40681ee66282d73dab8c8eccbf5ee0518/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=5aaa8fb40681ee66282d73dab8c8eccbf5ee0518", "patch": "@@ -2246,8 +2246,10 @@ after_nsdmi_defaulted_late_checks (tree t)\n     return;\n   if (t == error_mark_node)\n     return;\n-  for (tree fn = TYPE_METHODS (t); fn; fn = DECL_CHAIN (fn))\n-    if (!DECL_ARTIFICIAL (fn) && DECL_DEFAULTED_IN_CLASS_P (fn))\n+  for (tree fn = TYPE_FIELDS (t); fn; fn = DECL_CHAIN (fn))\n+    if (!DECL_ARTIFICIAL (fn)\n+\t&& DECL_DECLARES_FUNCTION_P (fn)\n+\t&& DECL_DEFAULTED_IN_CLASS_P (fn))\n       {\n \ttree fn_spec = TYPE_RAISES_EXCEPTIONS (TREE_TYPE (fn));\n \tif (UNEVALUATED_NOEXCEPT_SPEC_P (fn_spec))\n@@ -2379,20 +2381,25 @@ lazily_declare_fn (special_function_kind sfk, tree type)\n       || sfk == sfk_move_assignment\n       || sfk == sfk_copy_assignment)\n     check_for_override (fn, type);\n+\n   /* Add it to CLASSTYPE_METHOD_VEC.  */\n   bool added = add_method (type, fn, false);\n   gcc_assert (added);\n-  /* Add it to TYPE_METHODS.  */\n+\n+  /* Add it to TYPE_FIELDS.  */\n   if (sfk == sfk_destructor\n       && DECL_VIRTUAL_P (fn))\n     /* The ABI requires that a virtual destructor go at the end of the\n        vtable.  */\n-    TYPE_METHODS (type) = chainon (TYPE_METHODS (type), fn);\n+    TYPE_FIELDS (type) = chainon (TYPE_FIELDS (type), fn);\n   else\n     {\n-      DECL_CHAIN (fn) = TYPE_METHODS (type);\n-      TYPE_METHODS (type) = fn;\n+      DECL_CHAIN (fn) = TYPE_FIELDS (type);\n+      TYPE_FIELDS (type) = fn;\n     }\n+  /* Propagate TYPE_FIELDS.  */\n+  fixup_type_variants (type);\n+\n   maybe_add_class_template_decl_list (type, fn, /*friend_p=*/0);\n   if (DECL_MAYBE_IN_CHARGE_CONSTRUCTOR_P (fn)\n       || DECL_MAYBE_IN_CHARGE_DESTRUCTOR_P (fn))"}, {"sha": "a1c387092d4b49bfec4229f690eb0c9dae0da938", "filename": "gcc/cp/optimize.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5aaa8fb40681ee66282d73dab8c8eccbf5ee0518/gcc%2Fcp%2Foptimize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5aaa8fb40681ee66282d73dab8c8eccbf5ee0518/gcc%2Fcp%2Foptimize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Foptimize.c?ref=5aaa8fb40681ee66282d73dab8c8eccbf5ee0518", "patch": "@@ -326,7 +326,7 @@ maybe_thunk_body (tree fn, bool force)\n     }\n   args = XALLOCAVEC (tree, max_parms);\n \n-  /* We know that any clones immediately follow FN in TYPE_METHODS.  */\n+  /* We know that any clones immediately follow FN in TYPE_FIELDS.  */\n   FOR_EACH_CLONE (clone, fn)\n     {\n       tree clone_parm;\n@@ -447,7 +447,7 @@ maybe_clone_body (tree fn)\n   if (!tree_versionable_function_p (fn))\n     need_alias = true;\n \n-  /* We know that any clones immediately follow FN in the TYPE_METHODS\n+  /* We know that any clones immediately follow FN in the TYPE_FIELDS\n      list.  */\n   push_to_top_level ();\n   for (idx = 0; idx < 3; idx++)\n@@ -516,7 +516,7 @@ maybe_clone_body (tree fn)\n   /* Emit the DWARF1 abstract instance.  */\n   (*debug_hooks->deferred_inline_function) (fn);\n \n-  /* We know that any clones immediately follow FN in the TYPE_METHODS list. */\n+  /* We know that any clones immediately follow FN in the TYPE_FIELDS. */\n   for (idx = 0; idx < 3; idx++)\n     {\n       tree parm;"}, {"sha": "bb323534ec05e9691a46f74feb1a039b5740b1e6", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 39, "deletions": 51, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5aaa8fb40681ee66282d73dab8c8eccbf5ee0518/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5aaa8fb40681ee66282d73dab8c8eccbf5ee0518/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=5aaa8fb40681ee66282d73dab8c8eccbf5ee0518", "patch": "@@ -10551,7 +10551,6 @@ instantiate_class_template_1 (tree type)\n \t    }\n \t  else if (DECL_DECLARES_FUNCTION_P (t))\n \t    {\n-\t      /* Build new TYPE_METHODS.  */\n \t      tree r;\n \n \t      if (TREE_CODE (t) == TEMPLATE_DECL)\n@@ -16137,13 +16136,15 @@ tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl,\n \t     instantiated along with their containing function.  And this\n \t     way we don't have to deal with pushing out of one local class\n \t     to instantiate a member of another local class.  */\n-\t  tree fn;\n \t  /* Closures are handled by the LAMBDA_EXPR.  */\n \t  gcc_assert (!LAMBDA_TYPE_P (TREE_TYPE (t)));\n \t  complete_type (tmp);\n-\t  for (fn = TYPE_METHODS (tmp); fn; fn = DECL_CHAIN (fn))\n-\t    if (!DECL_ARTIFICIAL (fn))\n-\t      instantiate_decl (fn, /*defer_ok=*/false,\n+\t  for (tree fld = TYPE_FIELDS (tmp); fld; fld = DECL_CHAIN (fld))\n+\t    if ((VAR_P (fld)\n+\t\t || (TREE_CODE (fld) == FUNCTION_DECL\n+\t\t     && !DECL_ARTIFICIAL (fld)))\n+\t\t&& DECL_TEMPLATE_INSTANTIATION (fld))\n+\t      instantiate_decl (fld, /*defer_ok=*/false,\n \t\t\t\t/*expl_inst_class=*/false);\n \t}\n       break;\n@@ -22133,18 +22134,6 @@ bt_instantiate_type_proc (binding_entry entry, void *data)\n     do_type_instantiation (TYPE_MAIN_DECL (entry->type), storage, 0);\n }\n \n-/* Called from do_type_instantiation to instantiate a member\n-   (a member function or a static member variable) of an\n-   explicitly instantiated class template.  */\n-static void\n-instantiate_class_member (tree decl, int extern_p)\n-{\n-  mark_decl_instantiated (decl, extern_p);\n-  if (! extern_p)\n-    instantiate_decl (decl, /*defer_ok=*/true,\n-\t\t      /*expl_inst_class_mem_p=*/true);\n-}\n-\n /* Perform an explicit instantiation of template class T.  STORAGE, if\n    non-null, is the RID for extern, inline or static.  COMPLAIN is\n    nonzero if this is called from the parser, zero if called recursively,\n@@ -22254,12 +22243,9 @@ do_type_instantiation (tree t, tree storage, tsubst_flags_t complain)\n   if (nomem_p)\n     return;\n \n-  {\n-    tree tmp;\n-\n-    /* In contrast to implicit instantiation, where only the\n-       declarations, and not the definitions, of members are\n-       instantiated, we have here:\n+  /* In contrast to implicit instantiation, where only the\n+     declarations, and not the definitions, of members are\n+     instantiated, we have here:\n \n \t [temp.explicit]\n \n@@ -22268,27 +22254,28 @@ do_type_instantiation (tree t, tree storage, tsubst_flags_t complain)\n \t previously explicitly specialized in the translation unit\n \t containing the explicit instantiation.\n \n-       Of course, we can't instantiate member template classes, since\n-       we don't have any arguments for them.  Note that the standard\n-       is unclear on whether the instantiation of the members are\n-       *explicit* instantiations or not.  However, the most natural\n-       interpretation is that it should be an explicit instantiation.  */\n-\n-    if (! static_p)\n-      for (tmp = TYPE_METHODS (t); tmp; tmp = DECL_CHAIN (tmp))\n-\tif (TREE_CODE (tmp) == FUNCTION_DECL\n-\t    && DECL_TEMPLATE_INSTANTIATION (tmp)\n-\t    && user_provided_p (tmp))\n-\t  instantiate_class_member (tmp, extern_p);\n-\n-    for (tmp = TYPE_FIELDS (t); tmp; tmp = DECL_CHAIN (tmp))\n-      if (VAR_P (tmp) && DECL_TEMPLATE_INSTANTIATION (tmp))\n-\tinstantiate_class_member (tmp, extern_p);\n-\n-    if (CLASSTYPE_NESTED_UTDS (t))\n-      binding_table_foreach (CLASSTYPE_NESTED_UTDS (t),\n-\t\t\t     bt_instantiate_type_proc, &storage);\n-  }\n+     Of course, we can't instantiate member template classes, since we\n+     don't have any arguments for them.  Note that the standard is\n+     unclear on whether the instantiation of the members are\n+     *explicit* instantiations or not.  However, the most natural\n+     interpretation is that it should be an explicit\n+     instantiation.  */\n+  for (tree fld = TYPE_FIELDS (t); fld; fld = DECL_CHAIN (fld))\n+    if ((VAR_P (fld)\n+\t || (TREE_CODE (fld) == FUNCTION_DECL\n+\t     && !static_p\n+\t     && user_provided_p (fld)))\n+\t&& DECL_TEMPLATE_INSTANTIATION (fld))\n+      {\n+\tmark_decl_instantiated (fld, extern_p);\n+\tif (! extern_p)\n+\t  instantiate_decl (fld, /*defer_ok=*/true,\n+\t\t\t    /*expl_inst_class_mem_p=*/true);\n+      }\n+\n+  if (CLASSTYPE_NESTED_UTDS (t))\n+    binding_table_foreach (CLASSTYPE_NESTED_UTDS (t),\n+\t\t\t   bt_instantiate_type_proc, &storage);\n }\n \n /* Given a function DECL, which is a specialization of TMPL, modify\n@@ -23080,19 +23067,20 @@ instantiate_pending_templates (int retries)\n \n \t  if (TYPE_P (instantiation))\n \t    {\n-\t      tree fn;\n-\n \t      if (!COMPLETE_TYPE_P (instantiation))\n \t\t{\n \t\t  instantiate_class_template (instantiation);\n \t\t  if (CLASSTYPE_TEMPLATE_INSTANTIATION (instantiation))\n-\t\t    for (fn = TYPE_METHODS (instantiation);\n-\t\t\t fn;\n-\t\t\t fn = TREE_CHAIN (fn))\n-\t\t      if (! DECL_ARTIFICIAL (fn))\n-\t\t\tinstantiate_decl (fn,\n+\t\t    for (tree fld = TYPE_FIELDS (instantiation);\n+\t\t\t fld; fld = TREE_CHAIN (fld))\n+\t\t      if ((VAR_P (fld)\n+\t\t\t   || (TREE_CODE (fld) == FUNCTION_DECL\n+\t\t\t       && !DECL_ARTIFICIAL (fld)))\n+\t\t\t  && DECL_TEMPLATE_INSTANTIATION (fld))\n+\t\t\tinstantiate_decl (fld,\n \t\t\t\t\t  /*defer_ok=*/false,\n \t\t\t\t\t  /*expl_inst_class_mem_p=*/false);\n+\n \t\t  if (COMPLETE_TYPE_P (instantiation))\n \t\t    reconsider = 1;\n \t\t}"}, {"sha": "40caf70a0012971a5def9a5450685c398ed023c5", "filename": "gcc/cp/search.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5aaa8fb40681ee66282d73dab8c8eccbf5ee0518/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5aaa8fb40681ee66282d73dab8c8eccbf5ee0518/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=5aaa8fb40681ee66282d73dab8c8eccbf5ee0518", "patch": "@@ -444,6 +444,10 @@ lookup_field_1 (tree type, tree name, bool want_type)\n     {\n       tree decl = field;\n \n+      if (DECL_DECLARES_FUNCTION_P (decl))\n+\t/* Functions are kep separately, at the moment.  */\n+\tcontinue;\n+\n       if (GATHER_STATISTICS)\n \tn_fields_searched++;\n "}, {"sha": "ddb84f29080057f4d39f9bf4b3e36c6fbe275454", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5aaa8fb40681ee66282d73dab8c8eccbf5ee0518/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5aaa8fb40681ee66282d73dab8c8eccbf5ee0518/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=5aaa8fb40681ee66282d73dab8c8eccbf5ee0518", "patch": "@@ -3037,18 +3037,18 @@ finish_member_declaration (tree decl)\n   if (DECL_LANG_SPECIFIC (decl) && DECL_LANGUAGE (decl) == lang_c)\n     SET_DECL_LANGUAGE (decl, lang_cplusplus);\n \n-  /* Put functions on the TYPE_METHODS list and everything else on the\n-     TYPE_FIELDS list.  Note that these are built up in reverse order.\n-     We reverse them (to obtain declaration order) in finish_struct.  */\n+  /* Put the decl on the TYPE_FIELDS list.  Note that this is built up\n+     in reverse order.  We reverse it (to obtain declaration order) in\n+     finish_struct.  */\n   if (DECL_DECLARES_FUNCTION_P (decl))\n     {\n       /* We also need to add this function to the\n \t CLASSTYPE_METHOD_VEC.  */\n       if (add_method (current_class_type, decl, false))\n \t{\n \t  gcc_assert (TYPE_MAIN_VARIANT (current_class_type) == current_class_type);\n-\t  DECL_CHAIN (decl) = TYPE_METHODS (current_class_type);\n-\t  TYPE_METHODS (current_class_type) = decl;\n+\t  DECL_CHAIN (decl) = TYPE_FIELDS (current_class_type);\n+\t  TYPE_FIELDS (current_class_type) = decl;\n \n \t  maybe_add_class_template_decl_list (current_class_type, decl,\n \t\t\t\t\t      /*friend_p=*/0);\n@@ -5794,7 +5794,7 @@ finish_omp_declare_simd_methods (tree t)\n   if (processing_template_decl)\n     return;\n \n-  for (tree x = TYPE_METHODS (t); x; x = DECL_CHAIN (x))\n+  for (tree x = TYPE_FIELDS (t); x; x = DECL_CHAIN (x))\n     {\n       if (TREE_CODE (TREE_TYPE (x)) != METHOD_TYPE)\n \tcontinue;"}, {"sha": "b278c6da1d4405ee8dcc4c718bdc7884b29ebe15", "filename": "gcc/dbxout.c", "status": "modified", "additions": 13, "deletions": 30, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5aaa8fb40681ee66282d73dab8c8eccbf5ee0518/gcc%2Fdbxout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5aaa8fb40681ee66282d73dab8c8eccbf5ee0518/gcc%2Fdbxout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdbxout.c?ref=5aaa8fb40681ee66282d73dab8c8eccbf5ee0518", "patch": "@@ -1481,6 +1481,8 @@ dbxout_type_fields (tree type)\n       /* Omit here local type decls until we know how to support them.  */\n       if (TREE_CODE (tem) == TYPE_DECL\n \t  || TREE_CODE (tem) == TEMPLATE_DECL\n+\t  /* Member functions emitted after fields.  */\n+\t  || TREE_CODE (tem) == FUNCTION_DECL\n \t  /* Omit here the nameless fields that are used to skip bits.  */\n \t  || DECL_IGNORED_P (tem)\n \t  /* Omit fields whose position or size are variable or too large to\n@@ -1586,55 +1588,38 @@ dbxout_type_method_1 (tree decl)\n     }\n }\n \f\n-/* Subroutine of `dbxout_type'.  Output debug info about the methods defined\n-   in TYPE.  */\n+/* Subroutine of `dbxout_type'.  Output debug info about the member\n+   functions defined in TYPE.  */\n \n static void\n dbxout_type_methods (tree type)\n {\n-  /* C++: put out the method names and their parameter lists */\n-  tree methods = TYPE_METHODS (type);\n-  tree fndecl;\n-  tree last;\n-\n-  if (methods == NULL_TREE)\n-    return;\n-\n-  if (TREE_CODE (methods) != TREE_VEC)\n-    fndecl = methods;\n-  else if (TREE_VEC_ELT (methods, 0) != NULL_TREE)\n-    fndecl = TREE_VEC_ELT (methods, 0);\n-  else\n-    fndecl = TREE_VEC_ELT (methods, 1);\n-\n-  while (fndecl)\n+  for (tree fndecl = TYPE_FIELDS (type); fndecl;)\n     {\n       int need_prefix = 1;\n \n       /* Group together all the methods for the same operation.\n \t These differ in the types of the arguments.  */\n-      for (last = NULL_TREE;\n+      for (tree last = NULL_TREE;\n \t   fndecl && (last == NULL_TREE || DECL_NAME (fndecl) == DECL_NAME (last));\n \t   fndecl = DECL_CHAIN (fndecl))\n \t/* Output the name of the field (after overloading), as\n \t   well as the name of the field before overloading, along\n \t   with its parameter list */\n \t{\n-\t  /* Skip methods that aren't FUNCTION_DECLs.  (In C++, these\n-\t     include TEMPLATE_DECLs.)  The debugger doesn't know what\n-\t     to do with such entities anyhow.  */\n+\t  /* Skip non-functions.  */\n \t  if (TREE_CODE (fndecl) != FUNCTION_DECL)\n \t    continue;\n \n-\t  CONTIN;\n-\n-\t  last = fndecl;\n-\n \t  /* Also ignore abstract methods; those are only interesting to\n \t     the DWARF backends.  */\n \t  if (DECL_IGNORED_P (fndecl) || DECL_ABSTRACT_P (fndecl))\n \t    continue;\n \n+\t  CONTIN;\n+\n+\t  last = fndecl;\n+\n \t  /* Redundantly output the plain name, since that's what gdb\n \t     expects.  */\n \t  if (need_prefix)\n@@ -2209,10 +2194,8 @@ dbxout_type (tree type, int full)\n \n       /* Write out the field declarations.  */\n       dbxout_type_fields (type);\n-      if (use_gnu_debug_info_extensions && TYPE_METHODS (type) != NULL_TREE)\n-\t{\n-\t  dbxout_type_methods (type);\n-\t}\n+      if (use_gnu_debug_info_extensions)\n+\tdbxout_type_methods (type);\n \n       stabstr_C (';');\n "}, {"sha": "66103d76188608686dfcea729be916a7648460e1", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 8, "deletions": 20, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5aaa8fb40681ee66282d73dab8c8eccbf5ee0518/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5aaa8fb40681ee66282d73dab8c8eccbf5ee0518/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=5aaa8fb40681ee66282d73dab8c8eccbf5ee0518", "patch": "@@ -24032,7 +24032,8 @@ gen_member_die (tree type, dw_die_ref context_die)\n {\n   tree member;\n   tree binfo = TYPE_BINFO (type);\n-  dw_die_ref child;\n+\n+  gcc_assert (TYPE_MAIN_VARIANT (type) == type);\n \n   /* If this is not an incomplete type, output descriptions of each of its\n      members. Note that as we output the DIEs necessary to represent the\n@@ -24069,13 +24070,16 @@ gen_member_die (tree type, dw_die_ref context_die)\n \t   && (lang_hooks.decls.decl_dwarf_attribute (member, DW_AT_inline)\n \t       != -1));\n \n+      /* Ignore clones.  */\n+      if (DECL_ABSTRACT_ORIGIN (member))\n+\tcontinue;\n+\n       /* If we thought we were generating minimal debug info for TYPE\n \t and then changed our minds, some of the member declarations\n \t may have already been defined.  Don't define them again, but\n \t do put them in the right order.  */\n \n-      child = lookup_decl_die (member);\n-      if (child)\n+      if (dw_die_ref child = lookup_decl_die (member))\n \t{\n \t  /* Handle inline static data members, which only have in-class\n \t     declarations.  */\n@@ -24103,6 +24107,7 @@ gen_member_die (tree type, dw_die_ref context_die)\n \t\t  static_inline_p = false;\n \t\t}\n \t    }\n+\n \t  if (child->die_tag == DW_TAG_variable\n \t      && child->die_parent == comp_unit_die ()\n \t      && ref == NULL)\n@@ -24141,23 +24146,6 @@ gen_member_die (tree type, dw_die_ref context_die)\n \t  DECL_EXTERNAL (member) = old_extern;\n \t}\n     }\n-\n-  /* We do not keep type methods in type variants.  */\n-  gcc_assert (TYPE_MAIN_VARIANT (type) == type);\n-  /* Now output info about the function members (if any).  */\n-  if (TYPE_METHODS (type) != error_mark_node)\n-    for (member = TYPE_METHODS (type); member; member = DECL_CHAIN (member))\n-      {\n-\t/* Don't include clones in the member list.  */\n-\tif (DECL_ABSTRACT_ORIGIN (member))\n-\t  continue;\n-\n-\tchild = lookup_decl_die (member);\n-\tif (child)\n-\t  splice_child_die (context_die, child);\n-\telse\n-\t  gen_decl_die (member, NULL, NULL, context_die);\n-      }\n }\n \n /* Generate a DIE for a structure or union type.  If TYPE_DECL_SUPPRESS_DEBUG"}, {"sha": "986f43f07048649c0a48ad7f1deff088e789ff90", "filename": "gcc/function.c", "status": "modified", "additions": 5, "deletions": 14, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5aaa8fb40681ee66282d73dab8c8eccbf5ee0518/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5aaa8fb40681ee66282d73dab8c8eccbf5ee0518/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=5aaa8fb40681ee66282d73dab8c8eccbf5ee0518", "patch": "@@ -2218,20 +2218,11 @@ use_register_for_decl (const_tree decl)\n   if (!DECL_REGISTER (decl))\n     return false;\n \n-  switch (TREE_CODE (TREE_TYPE (decl)))\n-    {\n-    case RECORD_TYPE:\n-    case UNION_TYPE:\n-    case QUAL_UNION_TYPE:\n-      /* When not optimizing, disregard register keyword for variables with\n-\t types containing methods, otherwise the methods won't be callable\n-\t from the debugger.  */\n-      if (TYPE_METHODS (TYPE_MAIN_VARIANT (TREE_TYPE (decl))))\n-\treturn false;\n-      break;\n-    default:\n-      break;\n-    }\n+  /* When not optimizing, disregard register keyword for types that\n+     could have methods, otherwise the methods won't be callable from\n+     the debugger.  */\n+  if (RECORD_OR_UNION_TYPE_P (TREE_TYPE (decl)))\n+    return false;\n \n   return true;\n }"}, {"sha": "9781acd0766334a644a133c2f94b09b48fbe7f9d", "filename": "gcc/ipa-devirt.c", "status": "modified", "additions": 0, "deletions": 56, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5aaa8fb40681ee66282d73dab8c8eccbf5ee0518/gcc%2Fipa-devirt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5aaa8fb40681ee66282d73dab8c8eccbf5ee0518/gcc%2Fipa-devirt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-devirt.c?ref=5aaa8fb40681ee66282d73dab8c8eccbf5ee0518", "patch": "@@ -1602,62 +1602,6 @@ odr_types_equivalent_p (tree t1, tree t2, bool warn, bool *warned,\n \t\t\n \t\treturn false;\n \t      }\n-\t    if ((TYPE_MAIN_VARIANT (t1) == t1 || TYPE_MAIN_VARIANT (t2) == t2)\n-\t\t&& COMPLETE_TYPE_P (TYPE_MAIN_VARIANT (t1))\n-\t\t&& COMPLETE_TYPE_P (TYPE_MAIN_VARIANT (t2))\n-\t\t&& odr_type_p (TYPE_MAIN_VARIANT (t1))\n-\t\t&& odr_type_p (TYPE_MAIN_VARIANT (t2))\n-\t\t&& (TYPE_METHODS (TYPE_MAIN_VARIANT (t1))\n-\t\t    != TYPE_METHODS (TYPE_MAIN_VARIANT (t2))))\n-\t      {\n-\t\t/* Currently free_lang_data sets TYPE_METHODS to error_mark_node\n-\t\t   if it is non-NULL so this loop will never realy execute.  */\n-\t\tif (TYPE_METHODS (TYPE_MAIN_VARIANT (t1)) != error_mark_node\n-\t\t    && TYPE_METHODS (TYPE_MAIN_VARIANT (t2)) != error_mark_node)\n-\t\t  for (f1 = TYPE_METHODS (TYPE_MAIN_VARIANT (t1)),\n-\t\t       f2 = TYPE_METHODS (TYPE_MAIN_VARIANT (t2));\n-\t\t       f1 && f2 ; f1 = DECL_CHAIN (f1), f2 = DECL_CHAIN (f2))\n-\t\t    {\n-\t\t      if (DECL_ASSEMBLER_NAME (f1) != DECL_ASSEMBLER_NAME (f2))\n-\t\t\t{\n-\t\t\t  warn_odr (t1, t2, f1, f2, warn, warned,\n-\t\t\t\t    G_(\"a different method of same type \"\n-\t\t\t\t       \"is defined in another \"\n-\t\t\t\t       \"translation unit\"));\n-\t\t\t  return false;\n-\t\t\t}\n-\t\t      if (DECL_VIRTUAL_P (f1) != DECL_VIRTUAL_P (f2))\n-\t\t\t{\n-\t\t\t  warn_odr (t1, t2, f1, f2, warn, warned,\n-\t\t\t\t    G_(\"a definition that differs by virtual \"\n-\t\t\t\t       \"keyword in another translation unit\"));\n-\t\t\t  return false;\n-\t\t\t}\n-\t\t      if (DECL_VINDEX (f1) != DECL_VINDEX (f2))\n-\t\t\t{\n-\t\t\t  warn_odr (t1, t2, f1, f2, warn, warned,\n-\t\t\t\t    G_(\"virtual table layout differs \"\n-\t\t\t\t       \"in another translation unit\"));\n-\t\t\t  return false;\n-\t\t\t}\n-\t\t      if (odr_subtypes_equivalent_p (TREE_TYPE (f1),\n-\t\t\t\t\t\t     TREE_TYPE (f2), visited,\n-\t\t\t\t\t\t     loc1, loc2))\n-\t\t\t{\n-\t\t\t  warn_odr (t1, t2, f1, f2, warn, warned,\n-\t\t\t\t    G_(\"method with incompatible type is \"\n-\t\t\t\t       \"defined in another translation unit\"));\n-\t\t\t  return false;\n-\t\t\t}\n-\t\t    }\n-\t\tif ((f1 == NULL) != (f2 == NULL))\n-\t\t  {\n-\t\t    warn_odr (t1, t2, NULL, NULL, warn, warned,\n-\t\t\t      G_(\"a type with different number of methods \"\n-\t\t\t\t \"is defined in another translation unit\"));\n-\t\t    return false;\n-\t\t  }\n-\t      }\n \t  }\n \tbreak;\n       }"}, {"sha": "27bb0600626cafb3a209b02d6b5ebb62fea6357f", "filename": "gcc/objc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5aaa8fb40681ee66282d73dab8c8eccbf5ee0518/gcc%2Fobjc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5aaa8fb40681ee66282d73dab8c8eccbf5ee0518/gcc%2Fobjc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2FChangeLog?ref=5aaa8fb40681ee66282d73dab8c8eccbf5ee0518", "patch": "@@ -1,3 +1,9 @@\n+2017-07-20  Nathan Sidwell  <nathan@acm.org>\n+\n+\tRemove TYPE_METHODS.\n+\t* objc-runtime-shared-support.c (build_ivar_list_initializer):\n+\tDon't presume first item is a FIELD_DECL.\n+\n 2017-07-19  Nathan Sidwell  <nathan@acm.org>\n \n \t* objc-act.h (CLASS_NST_METHODS, CLASS_CLS_METHODS): Use"}, {"sha": "53303e47d201c9b5aca36bb44f644dfde19d192f", "filename": "gcc/objc/objc-runtime-shared-support.c", "status": "modified", "additions": 25, "deletions": 27, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5aaa8fb40681ee66282d73dab8c8eccbf5ee0518/gcc%2Fobjc%2Fobjc-runtime-shared-support.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5aaa8fb40681ee66282d73dab8c8eccbf5ee0518/gcc%2Fobjc%2Fobjc-runtime-shared-support.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-runtime-shared-support.c?ref=5aaa8fb40681ee66282d73dab8c8eccbf5ee0518", "patch": "@@ -528,34 +528,32 @@ build_ivar_list_initializer (tree type, tree field_decl)\n {\n   vec<constructor_elt, va_gc> *inits = NULL;\n \n-  do\n-    {\n-      vec<constructor_elt, va_gc> *ivar = NULL;\n-      tree id;\n-\n-      /* Set name.  */\n-      if (DECL_NAME (field_decl))\n-\tCONSTRUCTOR_APPEND_ELT (ivar, NULL_TREE,\n-\t\t\t\tadd_objc_string (DECL_NAME (field_decl),\n-\t\t\t\t\t\t meth_var_names));\n-      else\n-\t/* Unnamed bit-field ivar (yuck).  */\n-\tCONSTRUCTOR_APPEND_ELT (ivar, NULL_TREE, build_int_cst (NULL_TREE, 0));\n-\n-      /* Set type.  */\n-      id = add_objc_string (encode_field_decl (field_decl),\n-                            meth_var_types);\n-      CONSTRUCTOR_APPEND_ELT (ivar, NULL_TREE, id);\n-\n-      /* Set offset.  */\n-      CONSTRUCTOR_APPEND_ELT (ivar, NULL_TREE, byte_position (field_decl));\n-      CONSTRUCTOR_APPEND_ELT (inits, NULL_TREE,\n-\t\t\t      objc_build_constructor (type, ivar));\n-      do\n-\tfield_decl = DECL_CHAIN (field_decl);\n-      while (field_decl && TREE_CODE (field_decl) != FIELD_DECL);\n+  for (; field_decl; field_decl = DECL_CHAIN (field_decl))\n+    if (TREE_CODE (field_decl) == FIELD_DECL)\n+      {\n+\tvec<constructor_elt, va_gc> *ivar = NULL;\n+\ttree id;\n+\n+\t/* Set name.  */\n+\tif (DECL_NAME (field_decl))\n+\t  CONSTRUCTOR_APPEND_ELT (ivar, NULL_TREE,\n+\t\t\t\t  add_objc_string (DECL_NAME (field_decl),\n+\t\t\t\t\t\t   meth_var_names));\n+\telse\n+\t  /* Unnamed bit-field ivar (yuck).  */\n+\t  CONSTRUCTOR_APPEND_ELT (ivar, NULL_TREE,\n+\t\t\t\t  build_int_cst (NULL_TREE, 0));\n+\n+\t/* Set type.  */\n+\tid = add_objc_string (encode_field_decl (field_decl),\n+\t\t\t      meth_var_types);\n+\tCONSTRUCTOR_APPEND_ELT (ivar, NULL_TREE, id);\n+\n+\t/* Set offset.  */\n+\tCONSTRUCTOR_APPEND_ELT (ivar, NULL_TREE, byte_position (field_decl));\n+\tCONSTRUCTOR_APPEND_ELT (inits, NULL_TREE,\n+\t\t\t\tobjc_build_constructor (type, ivar));\n     }\n-  while (field_decl);\n \n   return objc_build_constructor (build_array_type (type, 0), inits);\n }"}, {"sha": "482b8dd2c9a12dacb3c19eb09973e4279ece1ebd", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5aaa8fb40681ee66282d73dab8c8eccbf5ee0518/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5aaa8fb40681ee66282d73dab8c8eccbf5ee0518/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=5aaa8fb40681ee66282d73dab8c8eccbf5ee0518", "patch": "@@ -1,3 +1,8 @@\n+2017-07-20  Nathan Sidwell  <nathan@acm.org>\n+\n+\t* g++.dg/ext/anon-struct6.C: Adjust diag.\n+\t* g++.old-deja/g++.other/anon4.C: Adjust diag.\n+\n 2017-07-20  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR target/80846"}, {"sha": "9b59085f67099fd77ba0f594056650690f4f1cd3", "filename": "gcc/testsuite/g++.dg/ext/anon-struct6.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5aaa8fb40681ee66282d73dab8c8eccbf5ee0518/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fanon-struct6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5aaa8fb40681ee66282d73dab8c8eccbf5ee0518/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fanon-struct6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fanon-struct6.C?ref=5aaa8fb40681ee66282d73dab8c8eccbf5ee0518", "patch": "@@ -3,8 +3,8 @@\n struct A\n {\n   struct\n-  {  // { dg-error \"anonymous struct cannot have function members\" }\n+  {\n     struct { static int i; }; // { dg-error \"prohibits anonymous structs|non-static data members|unnamed class\" }\n-    void foo() { i; }\n+    void foo() { i; } // { dg-error \"can only have non-static data\" }\n   }; // { dg-error \"prohibits anonymous structs\" }\n };"}, {"sha": "b6cb3006d713cf980b3d398a061b7dd41eeece26", "filename": "gcc/testsuite/g++.old-deja/g++.other/anon4.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5aaa8fb40681ee66282d73dab8c8eccbf5ee0518/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fanon4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5aaa8fb40681ee66282d73dab8c8eccbf5ee0518/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fanon4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fanon4.C?ref=5aaa8fb40681ee66282d73dab8c8eccbf5ee0518", "patch": "@@ -10,7 +10,7 @@\n struct A\n {\n   union\n-  {  // { dg-error \"\" } anon union cannot have member fns\n-    void bad();\n+  {\n+    void bad(); // { dg-error \"can only have non-static data\" }\n   };\n };"}, {"sha": "da36031da3090db925943b5c6357adb578f9b342", "filename": "gcc/tree-dump.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5aaa8fb40681ee66282d73dab8c8eccbf5ee0518/gcc%2Ftree-dump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5aaa8fb40681ee66282d73dab8c8eccbf5ee0518/gcc%2Ftree-dump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-dump.c?ref=5aaa8fb40681ee66282d73dab8c8eccbf5ee0518", "patch": "@@ -490,7 +490,6 @@ dequeue_and_dump (dump_info_p di)\n \tdump_string_field (di, \"tag\", \"union\");\n \n       dump_child (\"flds\", TYPE_FIELDS (t));\n-      dump_child (\"fncs\", TYPE_METHODS (t));\n       queue_and_dump_index (di, \"binf\", TYPE_BINFO (t),\n \t\t\t    DUMP_BINFO);\n       break;"}, {"sha": "4d8177c4a6240e80e78cdecc110bda1c7e2bd53f", "filename": "gcc/tree-pretty-print.c", "status": "modified", "additions": 2, "deletions": 15, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5aaa8fb40681ee66282d73dab8c8eccbf5ee0518/gcc%2Ftree-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5aaa8fb40681ee66282d73dab8c8eccbf5ee0518/gcc%2Ftree-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pretty-print.c?ref=5aaa8fb40681ee66282d73dab8c8eccbf5ee0518", "patch": "@@ -1860,22 +1860,9 @@ dump_generic_node (pretty_printer *pp, tree node, int spc, dump_flags_t flags,\n \tdump_decl_name (pp, node, flags);\n       else if (TYPE_NAME (TREE_TYPE (node)) != node)\n \t{\n-\t  if ((TREE_CODE (TREE_TYPE (node)) == RECORD_TYPE\n-\t       || TREE_CODE (TREE_TYPE (node)) == UNION_TYPE)\n-\t      && TYPE_METHODS (TREE_TYPE (node)))\n-\t    {\n-\t      /* The type is a c++ class: all structures have at least\n-\t\t 4 methods.  */\n-\t      pp_string (pp, \"class \");\n-\t      dump_generic_node (pp, TREE_TYPE (node), spc, flags, false);\n-\t    }\n-\t  else\n-\t    {\n-\t      pp_string (pp,\n-\t\t\t (TREE_CODE (TREE_TYPE (node)) == UNION_TYPE\n+\t  pp_string (pp, (TREE_CODE (TREE_TYPE (node)) == UNION_TYPE\n \t\t\t  ? \"union\" : \"struct \"));\n-\t      dump_generic_node (pp, TREE_TYPE (node), spc, flags, false);\n-\t    }\n+\t  dump_generic_node (pp, TREE_TYPE (node), spc, flags, false);\n \t}\n       else\n \tpp_string (pp, \"<anon>\");"}, {"sha": "b7de2840ac63c79d1be29ab136f4ae9162f4c158", "filename": "gcc/tree.c", "status": "modified", "additions": 15, "deletions": 32, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5aaa8fb40681ee66282d73dab8c8eccbf5ee0518/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5aaa8fb40681ee66282d73dab8c8eccbf5ee0518/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=5aaa8fb40681ee66282d73dab8c8eccbf5ee0518", "patch": "@@ -5217,13 +5217,15 @@ free_lang_data_in_type (tree type)\n       if (TYPE_VFIELD (type) && TREE_CODE (TYPE_VFIELD (type)) != FIELD_DECL)\n         TYPE_VFIELD (type) = NULL_TREE;\n \n-      /* Remove TYPE_METHODS list.  While it would be nice to keep it\n- \t to enable ODR warnings about different method lists, doing so\n-\t seems to impractically increase size of LTO data streamed.\n-\t Keep the information if TYPE_METHODS was non-NULL. This is used\n-\t by function.c and pretty printers.  */\n-      if (TYPE_METHODS (type))\n-        TYPE_METHODS (type) = error_mark_node;\n+      /* Splice out FUNCTION_DECLS and TEMPLATE_DECLS from\n+\t TYPE_FIELDS.  So LTO doesn't grow.  */\n+      for (tree probe, *prev= &TYPE_FIELDS (type); (probe = *prev); )\n+\tif (TREE_CODE (probe) == FUNCTION_DECL\n+\t    || TREE_CODE (probe) == TEMPLATE_DECL)\n+\t  *prev = probe;\n+\telse\n+\t  prev = &DECL_CHAIN (probe);\n+\n       if (TYPE_BINFO (type))\n \t{\n \t  free_lang_data_in_binfo (TYPE_BINFO (type));\n@@ -5418,9 +5420,10 @@ free_lang_data_in_decl (tree decl)\n \t At this point, it is not needed anymore.  */\n       DECL_SAVED_TREE (decl) = NULL_TREE;\n \n-      /* Clear the abstract origin if it refers to a method.  Otherwise\n-         dwarf2out.c will ICE as we clear TYPE_METHODS and thus the\n-\t origin will not be output correctly.  */\n+      /* Clear the abstract origin if it refers to a method.\n+         Otherwise dwarf2out.c will ICE as we splice functions out of\n+         TYPE_FIELDS and thus the origin will not be output\n+         correctly.  */\n       if (DECL_ABSTRACT_ORIGIN (decl)\n \t  && DECL_CONTEXT (DECL_ABSTRACT_ORIGIN (decl))\n \t  && RECORD_OR_UNION_TYPE_P\n@@ -6679,12 +6682,6 @@ build_distinct_type_copy (tree type MEM_STAT_DECL)\n   TYPE_MAIN_VARIANT (t) = t;\n   TYPE_NEXT_VARIANT (t) = 0;\n \n-  /* We do not record methods in type copies nor variants\n-     so we do not need to keep them up to date when new method\n-     is inserted.  */\n-  if (RECORD_OR_UNION_TYPE_P (t))\n-    TYPE_METHODS (t) = NULL_TREE;\n-\n   /* Note that it is now possible for TYPE_MIN_VALUE to be a value\n      whose TREE_TYPE is not t.  This can also happen in the Ada\n      frontend when using subtypes.  */\n@@ -13410,8 +13407,6 @@ verify_type_variant (const_tree t, tree tv)\n      - aggregates may have new TYPE_FIELDS list that list variants of\n        the main variant TYPE_FIELDS.\n      - vector types may differ by TYPE_VECTOR_OPAQUE\n-     - TYPE_METHODS is always NULL for variant types and maintained for\n-       main variant only.\n    */\n \n   /* Convenience macro for matching individual fields.  */\n@@ -13512,12 +13507,6 @@ verify_type_variant (const_tree t, tree tv)\n     }\n   if (TREE_CODE (t) == METHOD_TYPE)\n     verify_variant_match (TYPE_METHOD_BASETYPE);\n-  if (RECORD_OR_UNION_TYPE_P (t) && TYPE_METHODS (t))\n-    {\n-      error (\"type variant has TYPE_METHODS\");\n-      debug_tree (tv);\n-      return false;\n-    }\n   if (TREE_CODE (t) == OFFSET_TYPE)\n     verify_variant_match (TYPE_OFFSET_BASETYPE);\n   if (TREE_CODE (t) == ARRAY_TYPE)\n@@ -14020,14 +14009,6 @@ verify_type (const_tree t)\n   /* Check various uses of TYPE_MAXVAL.  */\n   if (RECORD_OR_UNION_TYPE_P (t))\n     {\n-      if (TYPE_METHODS (t) && TREE_CODE (TYPE_METHODS (t)) != FUNCTION_DECL\n-\t  && TREE_CODE (TYPE_METHODS (t)) != TEMPLATE_DECL\n-\t  && TYPE_METHODS (t) != error_mark_node)\n-\t{\n-\t  error (\"TYPE_METHODS is not FUNCTION_DECL, TEMPLATE_DECL nor error_mark_node\");\n-\t  debug_tree (TYPE_METHODS (t));\n-\t  error_found = true;\n-\t}\n     }\n   else if (TREE_CODE (t) == FUNCTION_TYPE || TREE_CODE (t) == METHOD_TYPE)\n     {\n@@ -14158,6 +14139,8 @@ verify_type (const_tree t)\n \t    ;\n \t  else if (TREE_CODE (fld) == USING_DECL)\n \t    ;\n+\t  else if (TREE_CODE (fld) == FUNCTION_DECL)\n+\t    ;\n \t  else\n \t    {\n \t      error (\"Wrong tree in TYPE_FIELDS list\");"}, {"sha": "819938c4458192cac026a907668789f0a088f188", "filename": "gcc/tree.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5aaa8fb40681ee66282d73dab8c8eccbf5ee0518/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5aaa8fb40681ee66282d73dab8c8eccbf5ee0518/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=5aaa8fb40681ee66282d73dab8c8eccbf5ee0518", "patch": "@@ -2122,8 +2122,6 @@ extern machine_mode element_mode (const_tree t);\n \n #define TYPE_MAX_VALUE(NODE) \\\n   (NUMERICAL_TYPE_CHECK (NODE)->type_non_common.maxval)\n-#define TYPE_METHODS(NODE)\t\t\t\t\\\n-  (RECORD_OR_UNION_CHECK (NODE)->type_non_common.maxval)\n #define TYPE_METHOD_BASETYPE(NODE)\t\t\t\\\n   (FUNC_OR_METHOD_CHECK (NODE)->type_non_common.maxval)\n #define TYPE_OFFSET_BASETYPE(NODE)\t\t\t\\"}, {"sha": "4d8f40c83123522fa8f6f54566438e19241a5ae9", "filename": "libcc1/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5aaa8fb40681ee66282d73dab8c8eccbf5ee0518/libcc1%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5aaa8fb40681ee66282d73dab8c8eccbf5ee0518/libcc1%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcc1%2FChangeLog?ref=5aaa8fb40681ee66282d73dab8c8eccbf5ee0518", "patch": "@@ -1,3 +1,8 @@\n+2017-07-20  Nathan Sidwell  <nathan@acm.org>\n+\n+\tRemove TYPE_METHODS.\n+\t* libcp1plugin.cc (plugin_build_decl): Member fns are on TYPE_FIELDS.\n+\n 2017-07-12  Nathan Sidwell  <nathan@acm.org>\n \n \t* libcp1plugin.cc (plugin_build_decl): Use"}, {"sha": "d7bf5a29d6d0019a3a87aeb6979814aebf6721d3", "filename": "libcc1/libcp1plugin.cc", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5aaa8fb40681ee66282d73dab8c8eccbf5ee0518/libcc1%2Flibcp1plugin.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5aaa8fb40681ee66282d73dab8c8eccbf5ee0518/libcc1%2Flibcp1plugin.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcc1%2Flibcp1plugin.cc?ref=5aaa8fb40681ee66282d73dab8c8eccbf5ee0518", "patch": "@@ -1556,7 +1556,7 @@ plugin_build_decl (cc1_plugin::connection *self,\n \n   if ((ctor || dtor)\n       /* Don't crash after a duplicate declaration of a cdtor.  */\n-      && TYPE_METHODS (current_class_type) == decl)\n+      && TYPE_FIELDS (current_class_type) == decl)\n     {\n       /* ctors and dtors clones are chained after DECL.\n \t However, we create the clones before TYPE_METHODS is\n@@ -1568,9 +1568,9 @@ plugin_build_decl (cc1_plugin::connection *self,\n       tree save = DECL_CHAIN (decl);\n       DECL_CHAIN (decl) = NULL_TREE;\n       clone_function_decl (decl, /*update_methods=*/true);\n-      gcc_assert (TYPE_METHODS (current_class_type) == decl);\n-      TYPE_METHODS (current_class_type)\n-\t= nreverse (TYPE_METHODS (current_class_type));\n+      gcc_assert (TYPE_FIELDS (current_class_type) == decl);\n+      TYPE_FIELDS (current_class_type)\n+\t= nreverse (TYPE_FIELDS (current_class_type));\n       DECL_CHAIN (decl) = save;\n     }\n "}]}