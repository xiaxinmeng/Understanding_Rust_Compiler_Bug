{"sha": "47c79d563b4e5d80a48f0c0c870c9025b9d095b4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDdjNzlkNTYzYjRlNWQ4MGE0OGYwYzBjODcwYzkwMjViOWQwOTViNA==", "commit": {"author": {"name": "Diego Novillo", "email": "dnovillo@google.com", "date": "2011-06-06T16:49:11Z"}, "committer": {"name": "Diego Novillo", "email": "dnovillo@gcc.gnu.org", "date": "2011-06-06T16:49:11Z"}, "message": "Makefile.in (lto-compress.o): Add dependency on LTO_STREAMER_H.\n\n\t* Makefile.in (lto-compress.o): Add dependency on LTO_STREAMER_H.\n\t(cgraph.o): Likewise.\n\t(cgraphunit.o): Likewise.\n\t* cgraphunit.c: Include lto-streamer.h\n\t(cgraph_finalize_compilation_unit): Call lto_streamer_hooks_init\n\tif LTO is enabled.\n\t* lto-streamer-in.c (unpack_value_fields): Call\n\tstreamer_hooks.unpack_value_fields if set.\n\t(lto_materialize_tree): For unhandled nodes, first try to\n\tcall lto_streamer_hooks.alloc_tree, if it exists.\n\t(lto_input_ts_decl_common_tree_pointers): Move reading of\n\tDECL_INITIAL to lto_streamer_read_tree.\n\t(lto_read_tree): Call lto_streamer_hooks.read_tree if set.\n\t(lto_streamer_read_tree): New.\n\t(lto_reader_init): Rename from lto_init_reader.\n\tMove initialization code to lto/lto.c.\n\t* lto-streamer-out.c (pack_value_fields): Call\n\tstreamer_hooks.pack_value_fields if set.\n\t(lto_output_tree_ref): For tree nodes that are not\n\tnormally indexable, call streamer_hooks.indexable_with_decls_p\n\tbefore giving up.\n\t(lto_output_ts_decl_common_tree_pointers): Move handling\n\tfor FUNCTION_DECL and TRANSLATION_UNIT_DECL to\n\tlto_streamer_write_tree.\n\t(lto_output_tree_header): Call streamer_hooks.is_streamable\n\tinstead of lto_is_streamable.\n\tCall lto_streamer_hooks.output_tree_header if set.\n\t(lto_write_tree): Call lto_streamer_hooks.write_tree if\n\tset.\n\t(lto_streamer_write_tree): New.\n\t(lto_output): Call lto_streamer_init directly.\n\t(lto_writer_init): Remove.\n\t* lto-streamer.c (streamer_hooks): New.\n\t(lto_streamer_cache_create): Call streamer_hooks.preload_common_nodes\n\tinstead of lto_preload_common_nodes.\n\t(lto_is_streamable): Move from lto-streamer.h\n\t(lto_streamer_hooks_init): New.\n\t(streamer_hooks): New.\n\t(streamer_hooks_init): New.\n\t* lto-streamer.h (struct output_block): Forward declare.\n\t(struct lto_input_block): Likewise.\n\t(struct data_in): Likewise.\n\t(struct bitpack_d): Likewise.\n\t(struct streamer_hooks): Declare.\n\t(streamer_hooks): Declare.\n\t(lto_streamer_hooks_init): Declare.\n\t(lto_streamer_write_tree): Declare.\n\t(lto_streamer_read_tree): Declare.\n\t(streamer_hooks_init): Declare.\n\t(lto_is_streamable): Move to lto-streamer.c\n\nlto/ChangeLog\n\n\t* lto.c (lto_init): New.\n\t(lto_main): Call it.\n\nFrom-SVN: r174709", "tree": {"sha": "833ac0df274e1c8def946237e10bd907c5de11ee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/833ac0df274e1c8def946237e10bd907c5de11ee"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/47c79d563b4e5d80a48f0c0c870c9025b9d095b4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/47c79d563b4e5d80a48f0c0c870c9025b9d095b4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/47c79d563b4e5d80a48f0c0c870c9025b9d095b4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/47c79d563b4e5d80a48f0c0c870c9025b9d095b4/comments", "author": {"login": "dnovillo", "id": 7295335, "node_id": "MDQ6VXNlcjcyOTUzMzU=", "avatar_url": "https://avatars.githubusercontent.com/u/7295335?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dnovillo", "html_url": "https://github.com/dnovillo", "followers_url": "https://api.github.com/users/dnovillo/followers", "following_url": "https://api.github.com/users/dnovillo/following{/other_user}", "gists_url": "https://api.github.com/users/dnovillo/gists{/gist_id}", "starred_url": "https://api.github.com/users/dnovillo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dnovillo/subscriptions", "organizations_url": "https://api.github.com/users/dnovillo/orgs", "repos_url": "https://api.github.com/users/dnovillo/repos", "events_url": "https://api.github.com/users/dnovillo/events{/privacy}", "received_events_url": "https://api.github.com/users/dnovillo/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7aca3d94becc5827df345447c94b128fd0c45cf8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7aca3d94becc5827df345447c94b128fd0c45cf8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7aca3d94becc5827df345447c94b128fd0c45cf8"}], "stats": {"total": 419, "additions": 334, "deletions": 85}, "files": [{"sha": "3166f93c28c7aedd99c37a713f381f4940505871", "filename": "gcc/ChangeLog", "status": "modified", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47c79d563b4e5d80a48f0c0c870c9025b9d095b4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47c79d563b4e5d80a48f0c0c870c9025b9d095b4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=47c79d563b4e5d80a48f0c0c870c9025b9d095b4", "patch": "@@ -1,3 +1,56 @@\n+2011-06-04  Diego Novillo  <dnovillo@google.com>\n+\n+\t* Makefile.in (lto-compress.o): Add dependency on LTO_STREAMER_H.\n+\t(cgraph.o): Likewise.\n+\t(cgraphunit.o): Likewise.\n+\t* cgraphunit.c: Include lto-streamer.h\n+\t(cgraph_finalize_compilation_unit): Call lto_streamer_hooks_init\n+\tif LTO is enabled.\n+\t* lto-streamer-in.c (unpack_value_fields): Call\n+\tstreamer_hooks.unpack_value_fields if set.\n+\t(lto_materialize_tree): For unhandled nodes, first try to\n+\tcall lto_streamer_hooks.alloc_tree, if it exists.\n+\t(lto_input_ts_decl_common_tree_pointers): Move reading of\n+\tDECL_INITIAL to lto_streamer_read_tree.\n+\t(lto_read_tree): Call lto_streamer_hooks.read_tree if set.\n+\t(lto_streamer_read_tree): New.\n+\t(lto_reader_init): Rename from lto_init_reader.\n+\tMove initialization code to lto/lto.c.\n+\t* lto-streamer-out.c (pack_value_fields): Call\n+\tstreamer_hooks.pack_value_fields if set.\n+\t(lto_output_tree_ref): For tree nodes that are not\n+\tnormally indexable, call streamer_hooks.indexable_with_decls_p\n+\tbefore giving up.\n+\t(lto_output_ts_decl_common_tree_pointers): Move handling\n+\tfor FUNCTION_DECL and TRANSLATION_UNIT_DECL to\n+\tlto_streamer_write_tree.\n+\t(lto_output_tree_header): Call streamer_hooks.is_streamable\n+\tinstead of lto_is_streamable.\n+\tCall lto_streamer_hooks.output_tree_header if set.\n+\t(lto_write_tree): Call lto_streamer_hooks.write_tree if\n+\tset.\n+\t(lto_streamer_write_tree): New.\n+\t(lto_output): Call lto_streamer_init directly.\n+\t(lto_writer_init): Remove.\n+\t* lto-streamer.c (streamer_hooks): New.\n+\t(lto_streamer_cache_create): Call streamer_hooks.preload_common_nodes\n+\tinstead of lto_preload_common_nodes.\n+\t(lto_is_streamable): Move from lto-streamer.h\n+\t(lto_streamer_hooks_init): New.\n+\t(streamer_hooks): New.\n+\t(streamer_hooks_init): New.\n+\t* lto-streamer.h (struct output_block): Forward declare.\n+\t(struct lto_input_block): Likewise.\n+\t(struct data_in): Likewise.\n+\t(struct bitpack_d): Likewise.\n+\t(struct streamer_hooks): Declare.\n+\t(streamer_hooks): Declare.\n+\t(lto_streamer_hooks_init): Declare.\n+\t(lto_streamer_write_tree): Declare.\n+\t(lto_streamer_read_tree): Declare.\n+\t(streamer_hooks_init): Declare.\n+\t(lto_is_streamable): Move to lto-streamer.c\n+\n 2011-06-06  Andreas Krebbel  <Andreas.Krebbel@de.ibm.com>\n \n \t* longlong.h (smul_ppmm): The resulting register pair contains the"}, {"sha": "496177cde633e8d1a4266ab979b5ce74dbc61b92", "filename": "gcc/Makefile.in", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47c79d563b4e5d80a48f0c0c870c9025b9d095b4/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47c79d563b4e5d80a48f0c0c870c9025b9d095b4/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=47c79d563b4e5d80a48f0c0c870c9025b9d095b4", "patch": "@@ -2348,7 +2348,7 @@ double-int.o: double-int.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n \n # lto-compress.o needs $(ZLIBINC) added to the include flags.\n lto-compress.o: lto-compress.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n-\t$(TREE_H) langhooks.h $(LTO_HEADER_H) $(LTO_SECTION_H) \\\n+\t$(TREE_H) langhooks.h $(LTO_STREAMER_H) $(LTO_SECTION_H) \\\n \tlto-compress.h $(DIAGNOSTIC_CORE_H) $(DIAGNOSTIC_CORE_H)\n \t$(COMPILER) -c $(ALL_COMPILERFLAGS) $(ALL_CPPFLAGS) $(ZLIBINC) $< $(OUTPUT_OPTION)\n \n@@ -3030,14 +3030,15 @@ cgraph.o : cgraph.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n    gt-cgraph.h output.h intl.h $(BASIC_BLOCK_H) debug.h $(HASHTAB_H) \\\n    $(TREE_INLINE_H) $(TREE_DUMP_H) $(TREE_FLOW_H) cif-code.def \\\n    value-prof.h $(EXCEPT_H) $(IPA_UTILS_H) $(DIAGNOSTIC_CORE_H) \\\n-   ipa-inline.h\n+   ipa-inline.h $(LTO_STREAMER_H)\n cgraphunit.o : cgraphunit.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(TREE_H) langhooks.h $(TREE_INLINE_H) toplev.h $(DIAGNOSTIC_CORE_H) $(FLAGS_H) $(GGC_H) \\\n    $(TARGET_H) $(CGRAPH_H) intl.h pointer-set.h $(FUNCTION_H) $(GIMPLE_H) \\\n    $(TREE_FLOW_H) $(TREE_PASS_H) debug.h $(DIAGNOSTIC_H) \\\n    $(FIBHEAP_H) output.h $(PARAMS_H) $(RTL_H) $(TIMEVAR_H) $(IPA_PROP_H) \\\n    gt-cgraphunit.h tree-iterator.h $(COVERAGE_H) $(TREE_DUMP_H) \\\n-   tree-pretty-print.h gimple-pretty-print.h ipa-inline.h $(IPA_UTILS_H)\n+   tree-pretty-print.h gimple-pretty-print.h ipa-inline.h $(IPA_UTILS_H) \\\n+   $(LTO_STREAMER_H)\n cgraphbuild.o : cgraphbuild.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(TREE_H) langhooks.h $(CGRAPH_H) intl.h pointer-set.h $(GIMPLE_H) \\\n    $(TREE_FLOW_H) $(TREE_PASS_H) $(IPA_UTILS_H) $(EXCEPT_H) \\"}, {"sha": "614b7858a3f9ab585ff5a71a7af9fb4118f691a6", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47c79d563b4e5d80a48f0c0c870c9025b9d095b4/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47c79d563b4e5d80a48f0c0c870c9025b9d095b4/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=47c79d563b4e5d80a48f0c0c870c9025b9d095b4", "patch": "@@ -140,6 +140,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"plugin.h\"\n #include \"ipa-inline.h\"\n #include \"ipa-utils.h\"\n+#include \"lto-streamer.h\"\n \n static void cgraph_expand_all_functions (void);\n static void cgraph_mark_functions_to_output (void);\n@@ -1092,6 +1093,10 @@ cgraph_finalize_compilation_unit (void)\n {\n   timevar_push (TV_CGRAPH);\n \n+  /* If LTO is enabled, initialize the streamer hooks needed by GIMPLE.  */\n+  if (flag_lto)\n+    lto_streamer_hooks_init ();\n+\n   /* If we're here there's no current function anymore.  Some frontends\n      are lazy in clearing these.  */\n   current_function_decl = NULL;"}, {"sha": "25ccb24a105764c61afe8454c6055903400eb233", "filename": "gcc/lto-streamer-in.c", "status": "modified", "additions": 34, "deletions": 14, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47c79d563b4e5d80a48f0c0c870c9025b9d095b4/gcc%2Flto-streamer-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47c79d563b4e5d80a48f0c0c870c9025b9d095b4/gcc%2Flto-streamer-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-in.c?ref=47c79d563b4e5d80a48f0c0c870c9025b9d095b4", "patch": "@@ -1841,6 +1841,9 @@ unpack_value_fields (struct bitpack_d *bp, tree expr)\n \n   if (CODE_CONTAINS_STRUCT (code, TS_TRANSLATION_UNIT_DECL))\n     unpack_ts_translation_unit_decl_value_fields (bp, expr);\n+\n+  if (streamer_hooks.unpack_value_fields)\n+    streamer_hooks.unpack_value_fields (bp, expr);\n }\n \n \n@@ -1892,8 +1895,15 @@ lto_materialize_tree (struct lto_input_block *ib, struct data_in *data_in,\n     }\n   else\n     {\n-      /* All other nodes can be materialized with a raw make_node call.  */\n-      result = make_node (code);\n+      /* For all other nodes, see if the streamer knows how to allocate\n+\t it.  */\n+      if (streamer_hooks.alloc_tree)\n+\tresult = streamer_hooks.alloc_tree (code, ib, data_in);\n+\n+      /* If the hook did not handle it, materialize the tree with a raw\n+\t make_node call.  */\n+      if (result == NULL_TREE)\n+\tresult = make_node (code);\n     }\n \n #ifdef LTO_STREAMER_DEBUG\n@@ -1988,12 +1998,8 @@ lto_input_ts_decl_common_tree_pointers (struct lto_input_block *ib,\n {\n   DECL_SIZE (expr) = lto_input_tree (ib, data_in);\n   DECL_SIZE_UNIT (expr) = lto_input_tree (ib, data_in);\n-\n-  if (TREE_CODE (expr) != FUNCTION_DECL\n-      && TREE_CODE (expr) != TRANSLATION_UNIT_DECL)\n-    DECL_INITIAL (expr) = lto_input_tree (ib, data_in);\n-\n   DECL_ATTRIBUTES (expr) = lto_input_tree (ib, data_in);\n+\n   /* Do not stream DECL_ABSTRACT_ORIGIN.  We cannot handle debug information\n      for early inlining so drop it on the floor instead of ICEing in\n      dwarf2out.c.  */\n@@ -2484,6 +2490,11 @@ lto_read_tree (struct lto_input_block *ib, struct data_in *data_in,\n   /* Read all the pointer fields in RESULT.  */\n   lto_input_tree_pointers (ib, data_in, result);\n \n+  /* Call back into the streaming module to read anything else it\n+     may need.  */\n+  if (streamer_hooks.read_tree)\n+    streamer_hooks.read_tree (ib, data_in, result);\n+\n   /* We should never try to instantiate an MD or NORMAL builtin here.  */\n   if (TREE_CODE (result) == FUNCTION_DECL)\n     gcc_assert (!lto_stream_as_builtin_p (result));\n@@ -2500,6 +2511,21 @@ lto_read_tree (struct lto_input_block *ib, struct data_in *data_in,\n }\n \n \n+/* LTO streamer hook for reading GIMPLE trees.  IB and DATA_IN are as in\n+   lto_read_tree.  EXPR is the tree was materialized by lto_read_tree and\n+   needs GIMPLE specific data to be filled in.  */\n+\n+void\n+lto_streamer_read_tree (struct lto_input_block *ib, struct data_in *data_in,\n+\t\t\ttree expr)\n+{\n+  if (DECL_P (expr)\n+      && TREE_CODE (expr) != FUNCTION_DECL\n+      && TREE_CODE (expr) != TRANSLATION_UNIT_DECL)\n+    DECL_INITIAL (expr) = lto_input_tree (ib, data_in);\n+}\n+\n+\n /* Read and INTEGER_CST node from input block IB using the per-file\n    context in DATA_IN.  */\n \n@@ -2581,17 +2607,11 @@ lto_input_tree (struct lto_input_block *ib, struct data_in *data_in)\n /* Initialization for the LTO reader.  */\n \n void\n-lto_init_reader (void)\n+lto_reader_init (void)\n {\n   lto_streamer_init ();\n-\n-  memset (&lto_stats, 0, sizeof (lto_stats));\n-  bitmap_obstack_initialize (NULL);\n-\n   file_name_hash_table = htab_create (37, hash_string_slot_node,\n \t\t\t\t      eq_string_slot_node, free);\n-\n-  gimple_register_cfg_hooks ();\n }\n \n "}, {"sha": "02ac9583aced8f02e9c77a050ba19f11ff79169d", "filename": "gcc/lto-streamer-out.c", "status": "modified", "additions": 71, "deletions": 36, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47c79d563b4e5d80a48f0c0c870c9025b9d095b4/gcc%2Flto-streamer-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47c79d563b4e5d80a48f0c0c870c9025b9d095b4/gcc%2Flto-streamer-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-out.c?ref=47c79d563b4e5d80a48f0c0c870c9025b9d095b4", "patch": "@@ -591,6 +591,9 @@ pack_value_fields (struct bitpack_d *bp, tree expr)\n \n   if (CODE_CONTAINS_STRUCT (code, TS_TRANSLATION_UNIT_DECL))\n     pack_ts_translation_unit_decl_value_fields (bp, expr);\n+\n+  if (streamer_hooks.pack_value_fields)\n+    streamer_hooks.pack_value_fields (bp, expr);\n }\n \n \n@@ -754,9 +757,22 @@ lto_output_tree_ref (struct output_block *ob, tree expr)\n       break;\n \n     default:\n-      /* No other node is indexable, so it should have been handled\n-\t by lto_output_tree.  */\n-      gcc_unreachable ();\n+      {\n+\t/* See if the streamer allows this node to be indexable\n+\t   like other global declarations.  */\n+\tif (streamer_hooks.indexable_with_decls_p\n+\t    && streamer_hooks.indexable_with_decls_p (expr))\n+\t  {\n+\t    output_record_start (ob, LTO_global_decl_ref);\n+\t    lto_output_var_decl_index (ob->decl_state, ob->main_stream, expr);\n+\t  }\n+\telse\n+\t  {\n+\t    /* No other node is indexable, so it should have been\n+\t      handled by lto_output_tree.  */\n+\t    gcc_unreachable ();\n+\t  }\n+      }\n     }\n }\n \n@@ -865,27 +881,11 @@ lto_output_ts_decl_common_tree_pointers (struct output_block *ob, tree expr,\n   lto_output_tree_or_ref (ob, DECL_SIZE (expr), ref_p);\n   lto_output_tree_or_ref (ob, DECL_SIZE_UNIT (expr), ref_p);\n \n-  if (TREE_CODE (expr) != FUNCTION_DECL\n-      && TREE_CODE (expr) != TRANSLATION_UNIT_DECL)\n-    {\n-      tree initial = DECL_INITIAL (expr);\n-      if (TREE_CODE (expr) == VAR_DECL\n-\t  && (TREE_STATIC (expr) || DECL_EXTERNAL (expr))\n-\t  && initial)\n-\t{\n-\t  lto_varpool_encoder_t varpool_encoder = ob->decl_state->varpool_node_encoder;\n-\t  struct varpool_node *vnode = varpool_get_node (expr);\n-\t  if (!vnode)\n-\t    initial = error_mark_node;\n-\t  else if (!lto_varpool_encoder_encode_initializer_p (varpool_encoder,\n-\t\t\t\t\t\t\t      vnode))\n-\t    initial = NULL;\n-\t}\n-    \n-      lto_output_tree_or_ref (ob, initial, ref_p);\n-    }\n+  /* Note, DECL_INITIAL is not handled here.  Since DECL_INITIAL needs\n+     special handling in LTO, it must be handled by streamer hooks.  */\n \n   lto_output_tree_or_ref (ob, DECL_ATTRIBUTES (expr), ref_p);\n+\n   /* Do not stream DECL_ABSTRACT_ORIGIN.  We cannot handle debug information\n      for early inlining so drop it on the floor instead of ICEing in\n      dwarf2out.c.  */\n@@ -1261,11 +1261,11 @@ lto_output_tree_header (struct output_block *ob, tree expr)\n   enum LTO_tags tag;\n   enum tree_code code;\n \n-  /* We should not see any non-GIMPLE tree nodes here.  */\n+  /* We should not see any tree nodes not handled by the streamer.  */\n   code = TREE_CODE (expr);\n-  if (!lto_is_streamable (expr))\n-    internal_error (\"tree code %qs is not supported in gimple streams\",\n-\t\t    tree_code_name[code]);\n+  if (!streamer_hooks.is_streamable (expr))\n+    internal_error (\"tree code %qs is not supported in %s streams\",\n+\t\t    tree_code_name[code], streamer_hooks.name);\n \n   /* The header of a tree node consists of its tag, the size of\n      the node, and any other information needed to instantiate\n@@ -1294,6 +1294,11 @@ lto_output_tree_header (struct output_block *ob, tree expr)\n     output_sleb128 (ob, TREE_VEC_LENGTH (expr));\n   else if (CODE_CONTAINS_STRUCT (code, TS_BINFO))\n     output_uleb128 (ob, BINFO_N_BASE_BINFOS (expr));\n+\n+  /* Allow the streamer to write any streamer-specific information\n+     needed to instantiate the node when reading.  */\n+  if (streamer_hooks.output_tree_header)\n+    streamer_hooks.output_tree_header (ob, expr);\n }\n \n \n@@ -1355,11 +1360,49 @@ lto_write_tree (struct output_block *ob, tree expr, bool ref_p)\n   /* Write all the pointer fields in EXPR.  */\n   lto_output_tree_pointers (ob, expr, ref_p);\n \n+  /* Call back into the streaming module to see if it needs to write\n+     anything that was not written by the common streamer.  */\n+  if (streamer_hooks.write_tree)\n+    streamer_hooks.write_tree (ob, expr, ref_p);\n+\n   /* Mark the end of EXPR.  */\n   output_zero (ob);\n }\n \n \n+/* GIMPLE hook for writing GIMPLE-specific parts of trees.  OB, EXPR\n+   and REF_P are as in lto_write_tree.  */\n+\n+void\n+lto_streamer_write_tree (struct output_block *ob, tree expr, bool ref_p)\n+{\n+  if (DECL_P (expr)\n+      && TREE_CODE (expr) != FUNCTION_DECL\n+      && TREE_CODE (expr) != TRANSLATION_UNIT_DECL)\n+    {\n+      /* Handle DECL_INITIAL for symbols.  */\n+      tree initial = DECL_INITIAL (expr);\n+      if (TREE_CODE (expr) == VAR_DECL\n+\t  && (TREE_STATIC (expr) || DECL_EXTERNAL (expr))\n+\t  && initial)\n+\t{\n+\t  lto_varpool_encoder_t varpool_encoder;\n+\t  struct varpool_node *vnode;\n+\n+\t  varpool_encoder = ob->decl_state->varpool_node_encoder;\n+\t  vnode = varpool_get_node (expr);\n+\t  if (!vnode)\n+\t    initial = error_mark_node;\n+\t  else if (!lto_varpool_encoder_encode_initializer_p (varpool_encoder,\n+\t\t\t\t\t\t\t      vnode))\n+\t    initial = NULL;\n+\t}\n+\n+      lto_output_tree_or_ref (ob, initial, ref_p);\n+    }\n+}\n+\n+\n /* Emit the integer constant CST to output block OB.  If REF_P is true,\n    CST's type will be emitted as a reference.  */\n \n@@ -2188,15 +2231,6 @@ copy_function (struct cgraph_node *node)\n }\n \n \n-/* Initialize the LTO writer.  */\n-\n-static void\n-lto_writer_init (void)\n-{\n-  lto_streamer_init ();\n-}\n-\n-\n /* Main entry point from the pass manager.  */\n \n static void\n@@ -2210,7 +2244,8 @@ lto_output (cgraph_node_set set, varpool_node_set vset)\n   int i, n_nodes;\n   lto_cgraph_encoder_t encoder = lto_get_out_decl_state ()->cgraph_node_encoder;\n \n-  lto_writer_init ();\n+  /* Initialize the streamer.  */\n+  lto_streamer_init ();\n \n   n_nodes = lto_cgraph_encoder_size (encoder);\n   /* Process only the functions with bodies.  */"}, {"sha": "0608b33a76bd610e81ba60f17aa020848ecb78a4", "filename": "gcc/lto-streamer.c", "status": "modified", "additions": 53, "deletions": 1, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47c79d563b4e5d80a48f0c0c870c9025b9d095b4/gcc%2Flto-streamer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47c79d563b4e5d80a48f0c0c870c9025b9d095b4/gcc%2Flto-streamer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer.c?ref=47c79d563b4e5d80a48f0c0c870c9025b9d095b4", "patch": "@@ -37,6 +37,9 @@ along with GCC; see the file COPYING3.  If not see\n /* Statistics gathered during LTO, WPA and LTRANS.  */\n struct lto_stats_d lto_stats;\n \n+/* Streamer hooks.  */\n+struct streamer_hooks streamer_hooks;\n+\n /* LTO uses bitmaps with different life-times.  So use a seperate\n    obstack for all LTO bitmaps.  */\n static bitmap_obstack lto_obstack;\n@@ -568,7 +571,7 @@ lto_streamer_cache_create (void)\n   /* Load all the well-known tree nodes that are always created by\n      the compiler on startup.  This prevents writing them out\n      unnecessarily.  */\n-  lto_preload_common_nodes (cache);\n+  streamer_hooks.preload_common_nodes (cache);\n \n   return cache;\n }\n@@ -713,3 +716,52 @@ lto_check_version (int major, int minor)\n \t\t major, minor,\n \t\t LTO_major_version, LTO_minor_version);\n }\n+\n+\n+/* Return true if EXPR is a tree node that can be written to disk.  */\n+static inline bool\n+lto_is_streamable (tree expr)\n+{\n+  enum tree_code code = TREE_CODE (expr);\n+\n+  /* Notice that we reject SSA_NAMEs as well.  We only emit the SSA\n+     name version in lto_output_tree_ref (see output_ssa_names).  */\n+  return !is_lang_specific (expr)\n+\t && code != SSA_NAME\n+\t && code != CALL_EXPR\n+\t && code != LANG_TYPE\n+\t && code != MODIFY_EXPR\n+\t && code != INIT_EXPR\n+\t && code != TARGET_EXPR\n+\t && code != BIND_EXPR\n+\t && code != WITH_CLEANUP_EXPR\n+\t && code != STATEMENT_LIST\n+\t && code != OMP_CLAUSE\n+\t && code != OPTIMIZATION_NODE\n+\t && (code == CASE_LABEL_EXPR\n+\t     || code == DECL_EXPR\n+\t     || TREE_CODE_CLASS (code) != tcc_statement);\n+}\n+\n+\n+/* Initialize all the streamer hooks used for streaming GIMPLE.  */\n+\n+void\n+lto_streamer_hooks_init (void)\n+{\n+  streamer_hooks_init ();\n+  streamer_hooks.name = \"gimple\";\n+  streamer_hooks.preload_common_nodes = lto_preload_common_nodes;\n+  streamer_hooks.is_streamable = lto_is_streamable;\n+  streamer_hooks.write_tree = lto_streamer_write_tree;\n+  streamer_hooks.read_tree = lto_streamer_read_tree;\n+}\n+\n+\n+/* Initialize the current set of streamer hooks.  */\n+\n+void\n+streamer_hooks_init (void)\n+{\n+  memset (&streamer_hooks, 0, sizeof (streamer_hooks));\n+}"}, {"sha": "157e5c0052e4ef235757c43ca37b2a6b97170b52", "filename": "gcc/lto-streamer.h", "status": "modified", "additions": 92, "deletions": 28, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47c79d563b4e5d80a48f0c0c870c9025b9d095b4/gcc%2Flto-streamer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47c79d563b4e5d80a48f0c0c870c9025b9d095b4/gcc%2Flto-streamer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer.h?ref=47c79d563b4e5d80a48f0c0c870c9025b9d095b4", "patch": "@@ -33,6 +33,12 @@ along with GCC; see the file COPYING3.  If not see\n #include \"alloc-pool.h\"\n #include \"gcov-io.h\"\n \n+/* Forward declarations to avoid including unnecessary headers.  */\n+struct output_block;\n+struct lto_input_block;\n+struct data_in;\n+struct bitpack_d;\n+\n /* Define when debugging the LTO streamer.  This causes the writer\n    to output the numeric value for the memory address of the tree node\n    being emitted.  When debugging a problem in the reader, check the\n@@ -741,6 +747,86 @@ struct data_in\n };\n \n \n+/* Streamer hooks.  These functions do additional processing as\n+   needed by the module.  There are two types of callbacks, those that\n+   replace the default behavior and those that supplement it.\n+\n+   Hooks marked [REQ] are required to be set.  Those marked [OPT] may\n+   be NULL, if the streamer does not need to implement them.  */\n+struct streamer_hooks {\n+  /* [REQ] A string identifying this streamer.  */\n+  const char *name;\n+\n+  /* [REQ] Called by lto_streamer_cache_create to instantiate a cache of\n+     well-known nodes.  These are tree nodes that are always\n+     instantiated by the compiler on startup.  Additionally, these\n+     nodes need to be shared.  This function should call\n+     lto_streamer_cache_append on every tree node that it wishes to\n+     preload in the streamer cache.  This way, the writer will only\n+     write out a reference to the tree and the reader will instantiate\n+     the tree out of this pre-populated cache.  */\n+  void (*preload_common_nodes) (struct lto_streamer_cache_d *);\n+\n+  /* [REQ] Return true if the given tree is supported by this streamer.  */\n+  bool (*is_streamable) (tree);\n+\n+  /* [OPT] Called by lto_write_tree after writing all the common parts of\n+     a tree.  If defined, the callback is in charge of writing all\n+     the fields that lto_write_tree did not write out.  Arguments\n+     are as in lto_write_tree.\n+\n+     The following tree fields are not handled by common code:\n+\n+\tDECL_ABSTRACT_ORIGIN\n+\tDECL_INITIAL\n+\tDECL_SAVED_TREE\n+\n+     Callbacks may choose to ignore or handle them.  If handled,\n+     the reader should read them in the exact same sequence written\n+     by the writer.  */\n+  void (*write_tree) (struct output_block *, tree, bool);\n+\n+  /* [OPT] Called by lto_read_tree after reading all the common parts of\n+     a tree.  If defined, the callback is in charge of reading all\n+     the fields that lto_read_tree did not read in.  Arguments\n+     are as in lto_read_tree.  */\n+  void (*read_tree) (struct lto_input_block *, struct data_in *, tree);\n+\n+  /* [OPT] Called by lto_output_tree_ref to determine if the given tree node\n+     should be emitted as a reference to the table of declarations\n+     (the same table that holds global declarations).  */\n+  bool (*indexable_with_decls_p) (tree);\n+\n+  /* [OPT] Called by pack_value_fields to store any non-pointer fields\n+     in the tree structure.  The arguments are as in pack_value_fields.  */\n+  void (*pack_value_fields) (struct bitpack_d *, tree);\n+\n+  /* [OPT] Called by unpack_value_fields to retrieve any non-pointer fields\n+     in the tree structure.  The arguments are as in unpack_value_fields.  */\n+  void (*unpack_value_fields) (struct bitpack_d *, tree);\n+\n+  /* [OPT] Called by lto_materialize_tree for tree nodes that it does not\n+     know how to allocate memory for.  If defined, this hook should\n+     return a new tree node of the given code.  The data_in and\n+     input_block arguments are passed in case the hook needs to\n+     read more data from the stream to allocate the node.\n+     If this hook returns NULL, then lto_materialize_tree will attempt\n+     to allocate the tree by calling make_node directly.  */\n+  tree (*alloc_tree) (enum tree_code, struct lto_input_block *,\n+                      struct data_in *);\n+\n+  /* [OPT] Called by lto_output_tree_header to write any streamer-specific\n+     information needed to allocate the tree.  This hook may assume\n+     that the basic header data (tree code, etc) has already been\n+     written.  It should only write any extra data needed to allocate\n+     the node (e.g., in the case of CALL_EXPR, this hook would write\n+     the number of arguments to the CALL_EXPR).  */\n+  void (*output_tree_header) (struct output_block *, tree);\n+};\n+\n+/* Streamer hooks.  */\n+extern struct streamer_hooks streamer_hooks;\n+\n /* In lto-section-in.c  */\n extern struct lto_input_block * lto_create_simple_input_block (\n \t\t\t       struct lto_file_decl_data *,\n@@ -851,17 +937,20 @@ extern intptr_t lto_orig_address_get (tree);\n extern void lto_orig_address_remove (tree);\n #endif\n extern void lto_check_version (int, int);\n-\n+extern void lto_streamer_hooks_init (void);\n+extern void lto_streamer_write_tree (struct output_block *, tree, bool);\n+extern void lto_streamer_read_tree (struct lto_input_block *,\n+\t\t\t\t     struct data_in *, tree);\n+extern void streamer_hooks_init (void);\n \n /* In lto-streamer-in.c */\n extern void lto_input_cgraph (struct lto_file_decl_data *, const char *);\n-extern void lto_init_reader (void);\n+extern void lto_reader_init (void);\n extern tree lto_input_tree (struct lto_input_block *, struct data_in *);\n extern void lto_input_function_body (struct lto_file_decl_data *, tree,\n \t\t\t\t     const char *);\n extern void lto_input_constructors_and_inits (struct lto_file_decl_data *,\n \t\t\t\t\t      const char *);\n-extern void lto_init_reader (void);\n extern struct data_in *lto_data_in_create (struct lto_file_decl_data *,\n \t\t\t\t    const char *, unsigned,\n \t\t\t\t    VEC(ld_plugin_symbol_resolution_t,heap) *);\n@@ -1063,31 +1152,6 @@ lto_stream_as_builtin_p (tree expr)\n \t      || DECL_BUILT_IN_CLASS (expr) == BUILT_IN_MD));\n }\n \n-/* Return true if EXPR is a tree node that can be written to disk.  */\n-static inline bool\n-lto_is_streamable (tree expr)\n-{\n-  enum tree_code code = TREE_CODE (expr);\n-\n-  /* Notice that we reject SSA_NAMEs as well.  We only emit the SSA\n-     name version in lto_output_tree_ref (see output_ssa_names).  */\n-  return !is_lang_specific (expr)\n-\t && code != SSA_NAME\n-\t && code != CALL_EXPR\n-\t && code != LANG_TYPE\n-\t && code != MODIFY_EXPR\n-\t && code != INIT_EXPR\n-\t && code != TARGET_EXPR\n-\t && code != BIND_EXPR\n-\t && code != WITH_CLEANUP_EXPR\n-\t && code != STATEMENT_LIST\n-\t && code != OMP_CLAUSE\n-\t && code != OPTIMIZATION_NODE\n-\t && (code == CASE_LABEL_EXPR\n-\t     || code == DECL_EXPR\n-\t     || TREE_CODE_CLASS (code) != tcc_statement);\n-}\n-\n DEFINE_DECL_STREAM_FUNCS (TYPE, type)\n DEFINE_DECL_STREAM_FUNCS (FIELD_DECL, field_decl)\n DEFINE_DECL_STREAM_FUNCS (FN_DECL, fn_decl)"}, {"sha": "e8393c1f523762f8e150b69500529edeaddbe2e0", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47c79d563b4e5d80a48f0c0c870c9025b9d095b4/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47c79d563b4e5d80a48f0c0c870c9025b9d095b4/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=47c79d563b4e5d80a48f0c0c870c9025b9d095b4", "patch": "@@ -1,3 +1,8 @@\n+2011-06-04  Diego Novillo  <dnovillo@google.com>\n+\n+\t* lto.c (lto_init): New.\n+\t(lto_main): Call it.\n+\n 2011-06-03  Diego Novillo  <dnovillo@google.com>\n \n \t* lto.c (get_resolution): Move from lto-streamer-in.c."}, {"sha": "74dfecdbc3e6028c0b5aa2bc0270cce8e31180f4", "filename": "gcc/lto/lto.c", "status": "modified", "additions": 17, "deletions": 3, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47c79d563b4e5d80a48f0c0c870c9025b9d095b4/gcc%2Flto%2Flto.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47c79d563b4e5d80a48f0c0c870c9025b9d095b4/gcc%2Flto%2Flto.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto.c?ref=47c79d563b4e5d80a48f0c0c870c9025b9d095b4", "patch": "@@ -2732,6 +2732,21 @@ lto_process_name (void)\n     setproctitle (\"lto1-ltrans\");\n }\n \n+\n+/* Initialize the LTO front end.  */\n+\n+static void\n+lto_init (void)\n+{\n+  lto_process_name ();\n+  lto_streamer_hooks_init ();\n+  lto_reader_init ();\n+  memset (&lto_stats, 0, sizeof (lto_stats));\n+  bitmap_obstack_initialize (NULL);\n+  gimple_register_cfg_hooks ();\n+}\n+\n+\n /* Main entry point for the GIMPLE front end.  This front end has\n    three main personalities:\n \n@@ -2755,9 +2770,8 @@ lto_process_name (void)\n void\n lto_main (void)\n {\n-  lto_process_name ();\n-\n-  lto_init_reader ();\n+  /* Initialize the LTO front end.  */\n+  lto_init ();\n \n   /* Read all the symbols and call graph from all the files in the\n      command line.  */"}]}