{"sha": "9b84e7a8365e61211975aceec67d086aceee0c58", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWI4NGU3YTgzNjVlNjEyMTE5NzVhY2VlYzY3ZDA4NmFjZWVlMGM1OA==", "commit": {"author": {"name": "Rong Xu", "email": "xur@google.com", "date": "2014-10-08T21:51:41Z"}, "committer": {"name": "Rong Xu", "email": "xur@gcc.gnu.org", "date": "2014-10-08T21:51:41Z"}, "message": "Add overlap functionality to gcov-tool.\n\n2014-10-08  Rong Xu  <xur@google.com>\n\n\t* gcc/gcov-tool.c (profile_overlap): New driver function\n        to compute profile overlap. \n\t(print_overlap_usage_message): New.\n\t(overlap_usage): New.\n\t(do_overlap): New.\n\t(print_usage): Add calls to overlap function.\n\t(main): Ditto.\n\t* libgcc/libgcov-util.c (read_gcda_file): Fix format.\n\t(find_match_gcov_info): Ditto.\n\t(calculate_2_entries): New.\n\t(compute_one_gcov): Ditto.\n\t(gcov_info_count_all_cold): Ditto.\n\t(gcov_info_count_all_zero): Ditto.\n\t(extract_file_basename): Ditto.\n\t(get_file_basename): Ditto.\n\t(set_flag): Ditto.\n\t(matched_gcov_info): Ditto.\n\t(calculate_overlap): Ditto.\n\t(gcov_profile_overlap): Ditto.\n\t* libgcc/libgcov-driver.c (compute_summary): Make\n        it avavilable for external calls.\n\t* gcc/doc/gcov-tool.texi: Add documentation.\n\nFrom-SVN: r216015", "tree": {"sha": "a5055f5dbc707735c59ee18b1ffc1a4a658b4ca5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a5055f5dbc707735c59ee18b1ffc1a4a658b4ca5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9b84e7a8365e61211975aceec67d086aceee0c58", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b84e7a8365e61211975aceec67d086aceee0c58", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9b84e7a8365e61211975aceec67d086aceee0c58", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b84e7a8365e61211975aceec67d086aceee0c58/comments", "author": {"login": "xur-llvm", "id": 59886942, "node_id": "MDQ6VXNlcjU5ODg2OTQy", "avatar_url": "https://avatars.githubusercontent.com/u/59886942?v=4", "gravatar_id": "", "url": "https://api.github.com/users/xur-llvm", "html_url": "https://github.com/xur-llvm", "followers_url": "https://api.github.com/users/xur-llvm/followers", "following_url": "https://api.github.com/users/xur-llvm/following{/other_user}", "gists_url": "https://api.github.com/users/xur-llvm/gists{/gist_id}", "starred_url": "https://api.github.com/users/xur-llvm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/xur-llvm/subscriptions", "organizations_url": "https://api.github.com/users/xur-llvm/orgs", "repos_url": "https://api.github.com/users/xur-llvm/repos", "events_url": "https://api.github.com/users/xur-llvm/events{/privacy}", "received_events_url": "https://api.github.com/users/xur-llvm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a41bb2c947782287f983daac7807f0e0e4ef4b65", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a41bb2c947782287f983daac7807f0e0e4ef4b65", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a41bb2c947782287f983daac7807f0e0e4ef4b65"}], "stats": {"total": 800, "additions": 758, "deletions": 42}, "files": [{"sha": "9491d8bbadbe522b3f692f1e87fa115964f34ead", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b84e7a8365e61211975aceec67d086aceee0c58/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b84e7a8365e61211975aceec67d086aceee0c58/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9b84e7a8365e61211975aceec67d086aceee0c58", "patch": "@@ -1,3 +1,14 @@\n+2014-10-08  Rong Xu  <xur@google.com>\n+\n+\t* gcov-tool.c (profile_overlap): New driver function\n+\tto compute profile overlap. \n+\t(print_overlap_usage_message): New.\n+\t(overlap_usage): New.\n+\t(do_overlap): New.\n+\t(print_usage): Add calls to overlap function.\n+\t(main): Ditto.\n+\t* doc/gcov-tool.texi: Add documentation.\n+\n 2014-10-08  Steve Ellcey  <sellcey@mips.com>\n \n \t* config/mips/mti-linux.h (DRIVER_SELF_SPECS): Change"}, {"sha": "3a6687289490aa09ad84bf1cae6629701f06049e", "filename": "gcc/doc/gcov-tool.texi", "status": "modified", "additions": 44, "deletions": 2, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b84e7a8365e61211975aceec67d086aceee0c58/gcc%2Fdoc%2Fgcov-tool.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b84e7a8365e61211975aceec67d086aceee0c58/gcc%2Fdoc%2Fgcov-tool.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fgcov-tool.texi?ref=9b84e7a8365e61211975aceec67d086aceee0c58", "patch": "@@ -103,8 +103,7 @@ in these kind of counters.\n @section Invoking @command{gcov-tool}\n \n @smallexample\n-gcov-tool @r{[}@var{global-options}@r{]} SUB_COMMAND\n-@r{[}@var{sub_command-options}@r{]} @var{profile_dir}\n+gcov-tool @r{[}@var{global-options}@r{]} SUB_COMMAND @r{[}@var{sub_command-options}@r{]} @var{profile_dir}\n @end smallexample\n \n @command{gcov-tool} accepts the following options:\n@@ -123,6 +122,15 @@ gcov-tool rewrite [rewrite-options] @var{directory}\n      [@option{-o}|@option{--output} @var{directory}]\n      [@option{-s}|@option{--scale} @var{float_or_simple-frac_value}]\n      [@option{-n}|@option{--normalize} @var{long_long_value}]\n+\n+gcov-tool overlap [overlap-options] @var{directory1} @var{directory2}\n+     [@option{-v}|@option{--verbose}]\n+     [@option{-h}|@option{--hotonly}]\n+     [@option{-f}|@option{--function}]\n+     [@option{-F}|@option{--fullname}]\n+     [@option{-o}|@option{--object}]\n+     [@option{-t}|@option{--hot_threshold}] @var{float}\n+\n @c man end\n @c man begin SEEALSO\n gpl(7), gfdl(7), fsf-funding(7), gcc(1), gcov(1) and the Info entry for\n@@ -182,8 +190,42 @@ or simple fraction value form, such 1, 2, 2/3, and 5/3.\n @itemx --normalize <long_long_value>\n Normalize the profile. The specified value is the max counter value\n in the new profile.\n+@end table\n+\n+@item overlap\n+Computer the overlap score between the two specified profile directories.\n+The overlap score is computed based on the arc profiles. It is defined as\n+the sum of min (p1_counter[i] / p1_sum_all, p2_counter[i] / p2_sum_all),\n+for all arc counter i, where p1_counter[i] and p2_counter[i] are two\n+matched counters and p1_sum_all and p2_sum_all are the sum of counter\n+values in profile 1 and profile 2, respectively.\n+\n+@table @gcctabopt\n+@item -v\n+@itemx --verbose\n+Set the verbose mode.\n+\n+@item -h\n+@itemx --hotonly\n+Only print info for hot objects/functions.\n \n+@item -f\n+@itemx --function\n+Print function level overlap score.\n+\n+@item -F\n+@itemx --fullname\n+Print full gcda filename.\n+\n+@item -o\n+@itemx --object\n+Print object level overlap score.\n+\n+@item -t @var{float}\n+@itemx --hot_threshold <float>\n+Set the threshold for hot counter value.\n @end table\n+\n @end table\n \n @c man end"}, {"sha": "db23bd7bc49322d73c15971f0bcfb6452e3e7c30", "filename": "gcc/gcov-tool.c", "status": "modified", "additions": 119, "deletions": 0, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b84e7a8365e61211975aceec67d086aceee0c58/gcc%2Fgcov-tool.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b84e7a8365e61211975aceec67d086aceee0c58/gcc%2Fgcov-tool.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcov-tool.c?ref=9b84e7a8365e61211975aceec67d086aceee0c58", "patch": "@@ -39,6 +39,7 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #include <getopt.h>\n \n extern int gcov_profile_merge (struct gcov_info*, struct gcov_info*, int, int);\n+extern int gcov_profile_overlap (struct gcov_info*, struct gcov_info*);\n extern int gcov_profile_normalize (struct gcov_info*, gcov_type);\n extern int gcov_profile_scale (struct gcov_info*, float, int, int);\n extern struct gcov_info* gcov_read_profile_dir (const char*, int);\n@@ -368,6 +369,121 @@ do_rewrite (int argc, char **argv)\n   return ret;\n }\n \n+/* Driver function to computer the overlap score b/w profile D1 and D2.\n+   Return 1 on error and 0 if OK.  */\n+\n+static int\n+profile_overlap (const char *d1, const char *d2)\n+{\n+  struct gcov_info *d1_profile;\n+  struct gcov_info *d2_profile;\n+\n+  d1_profile = gcov_read_profile_dir (d1, 0);\n+  if (!d1_profile)\n+    return 1;\n+\n+  if (d2)\n+    {\n+      d2_profile = gcov_read_profile_dir (d2, 0);\n+      if (!d2_profile)\n+        return 1;\n+\n+      return gcov_profile_overlap (d1_profile, d2_profile);\n+    }\n+\n+  return 1;\n+}\n+\n+/* Usage message for profile overlap.  */\n+\n+static void\n+print_overlap_usage_message (int error_p)\n+{\n+  FILE *file = error_p ? stderr : stdout;\n+\n+  fnotice (file, \"  overlap [options] <dir1> <dir2>       Compute the overlap of two profiles\\n\");\n+  fnotice (file, \"    -v, --verbose                       Verbose mode\\n\");\n+  fnotice (file, \"    -h, --hotonly                       Only print info for hot objects/functions\\n\");\n+  fnotice (file, \"    -f, --function                      Print function level info\\n\");\n+  fnotice (file, \"    -F, --fullname                      Print full filename\\n\");\n+  fnotice (file, \"    -o, --object                        Print object level info\\n\");\n+  fnotice (file, \"    -t <float>, --hot_threshold <float> Set the threshold for hotness\\n\");\n+\n+}\n+\n+static const struct option overlap_options[] =\n+{\n+  { \"verbose\",                no_argument,       NULL, 'v' },\n+  { \"function\",               no_argument,       NULL, 'f' },\n+  { \"fullname\",               no_argument,       NULL, 'F' },\n+  { \"object\",                 no_argument,       NULL, 'o' },\n+  { \"hotonly\",                no_argument,       NULL, 'h' },\n+  { \"hot_threshold\",          required_argument, NULL, 't' },\n+  { 0, 0, 0, 0 }\n+};\n+\n+/* Print overlap usage and exit.  */\n+\n+static void\n+overlap_usage (void)\n+{\n+  fnotice (stderr, \"Overlap subcomand usage:\");\n+  print_overlap_usage_message (true);\n+  exit (FATAL_EXIT_CODE);\n+}\n+\n+int overlap_func_level;\n+int overlap_obj_level;\n+int overlap_hot_only;\n+int overlap_use_fullname;\n+double overlap_hot_threshold = 0.005;\n+\n+/* Driver for profile overlap sub-command.  */\n+\n+static int\n+do_overlap (int argc, char **argv)\n+{\n+  int opt;\n+  int ret;\n+\n+  optind = 0;\n+  while ((opt = getopt_long (argc, argv, \"vfFoht:\", overlap_options, NULL)) != -1)\n+    {\n+      switch (opt)\n+        {\n+        case 'v':\n+          verbose = true;\n+          gcov_set_verbose ();\n+          break;\n+        case 'f':\n+          overlap_func_level = 1;\n+          break;\n+        case 'F':\n+          overlap_use_fullname = 1;\n+          break;\n+        case 'o':\n+          overlap_obj_level = 1;\n+          break;\n+        case 'h':\n+          overlap_hot_only = 1;\n+          break;\n+        case 't':\n+          overlap_hot_threshold = atof (optarg);\n+          break;\n+        default:\n+          overlap_usage ();\n+        }\n+    }\n+\n+  if (argc - optind == 2)\n+    ret = profile_overlap (argv[optind], argv[optind+1]);\n+  else\n+    overlap_usage ();\n+\n+  return ret;\n+}\n+\n+\n /* Print a usage message and exit.  If ERROR_P is nonzero, this is an error,\n    otherwise the output of --help.  */\n \n@@ -383,6 +499,7 @@ print_usage (int error_p)\n   fnotice (file, \"  -v, --version                         Print version number, then exit\\n\");\n   print_merge_usage_message (error_p);\n   print_rewrite_usage_message (error_p);\n+  print_overlap_usage_message (error_p);\n   fnotice (file, \"\\nFor bug reporting instructions, please see:\\n%s.\\n\",\n            bug_report_url);\n   exit (status);\n@@ -471,6 +588,8 @@ main (int argc, char **argv)\n     return do_merge (argc - optind, argv + optind);\n   else if (!strcmp (sub_command, \"rewrite\"))\n     return do_rewrite (argc - optind, argv + optind);\n+  else if (!strcmp (sub_command, \"overlap\"))\n+    return do_overlap (argc - optind, argv + optind);\n \n   print_usage (true);\n }"}, {"sha": "1d53defc95ec149df92eb7b91d71b2a75dd77a08", "filename": "libgcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b84e7a8365e61211975aceec67d086aceee0c58/libgcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b84e7a8365e61211975aceec67d086aceee0c58/libgcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2FChangeLog?ref=9b84e7a8365e61211975aceec67d086aceee0c58", "patch": "@@ -1,3 +1,20 @@\n+2014-10-08  Rong Xu  <xur@google.com>\n+\n+\t* libgcov-util.c (read_gcda_file): Fix format.\n+\t(find_match_gcov_info): Ditto.\n+\t(calculate_2_entries): New.\n+\t(compute_one_gcov): Ditto.\n+\t(gcov_info_count_all_cold): Ditto.\n+\t(gcov_info_count_all_zero): Ditto.\n+\t(extract_file_basename): Ditto.\n+\t(get_file_basename): Ditto.\n+\t(set_flag): Ditto.\n+\t(matched_gcov_info): Ditto.\n+\t(calculate_overlap): Ditto.\n+\t(gcov_profile_overlap): Ditto.\n+\t* libgcov-driver.c (compute_summary): Make\n+\tit avavilable for external calls.\n+\n 2014-10-06  Rong Xu  <xur@google.com>\n \n \t* Makefile.in: Ditto."}, {"sha": "2ff878f836c8323f10645e96602f98aa766ffed3", "filename": "libgcc/libgcov-driver.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b84e7a8365e61211975aceec67d086aceee0c58/libgcc%2Flibgcov-driver.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b84e7a8365e61211975aceec67d086aceee0c58/libgcc%2Flibgcov-driver.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Flibgcov-driver.c?ref=9b84e7a8365e61211975aceec67d086aceee0c58", "patch": "@@ -274,7 +274,10 @@ static struct gcov_summary_buffer *sum_buffer;\n    It computes and returns CRC32 and stored summary in THIS_PRG.\n    Also determines the longest filename length of the info files.  */\n \n-static gcov_unsigned_t\n+#if !IN_GCOV_TOOL\n+static\n+#endif\n+gcov_unsigned_t\n compute_summary (struct gcov_info *list, struct gcov_summary *this_prg,\n \t\t size_t *max_length)\n {"}, {"sha": "10771332b917e33f8c9e146b51ead76caf65ba23", "filename": "libgcc/libgcov-util.c", "status": "modified", "additions": 563, "deletions": 39, "changes": 602, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b84e7a8365e61211975aceec67d086aceee0c58/libgcc%2Flibgcov-util.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b84e7a8365e61211975aceec67d086aceee0c58/libgcc%2Flibgcov-util.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Flibgcov-util.c?ref=9b84e7a8365e61211975aceec67d086aceee0c58", "patch": "@@ -319,59 +319,59 @@ read_gcda_file (const char *filename)\n \n       tag = gcov_read_unsigned ();\n       if (!tag)\n-\tbreak;\n+        break;\n       length = gcov_read_unsigned ();\n       base = gcov_position ();\n       mask = GCOV_TAG_MASK (tag) >> 1;\n       for (tag_depth = 4; mask; mask >>= 8)\n-\t{\n-\t  if (((mask & 0xff) != 0xff))\n-\t    {\n-\t      warning (0, \"%s:tag `%x' is invalid\\n\", filename, tag);\n-\t      break;\n-\t    }\n-\t  tag_depth--;\n-\t}\n+        {\n+          if (((mask & 0xff) != 0xff))\n+            {\n+              warning (0, \"%s:tag `%x' is invalid\\n\", filename, tag);\n+              break;\n+            }\n+          tag_depth--;\n+        }\n       for (format = tag_table; format->name; format++)\n-\tif (format->tag == tag)\n-\t  goto found;\n+        if (format->tag == tag)\n+          goto found;\n       format = &tag_table[GCOV_TAG_IS_COUNTER (tag) ? 2 : 1];\n     found:;\n       if (tag)\n-\t{\n-\t  if (depth && depth < tag_depth)\n-\t    {\n-\t      if (!GCOV_TAG_IS_SUBTAG (tags[depth - 1], tag))\n-\t\twarning (0, \"%s:tag `%x' is incorrectly nested\\n\",\n-\t\t\tfilename, tag);\n-\t    }\n-\t  depth = tag_depth;\n-\t  tags[depth - 1] = tag;\n-\t}\n+        {\n+          if (depth && depth < tag_depth)\n+            {\n+              if (!GCOV_TAG_IS_SUBTAG (tags[depth - 1], tag))\n+                warning (0, \"%s:tag `%x' is incorrectly nested\\n\",\n+                         filename, tag);\n+            }\n+          depth = tag_depth;\n+          tags[depth - 1] = tag;\n+        }\n \n       if (format->proc)\n         {\n-\t  unsigned long actual_length;\n+          unsigned long actual_length;\n \n-\t  (*format->proc) (tag, length);\n+          (*format->proc) (tag, length);\n \n-\t  actual_length = gcov_position () - base;\n-\t  if (actual_length > length)\n-\t    warning (0, \"%s:record size mismatch %lu bytes overread\\n\",\n-\t\t    filename, actual_length - length);\n-\t  else if (length > actual_length)\n-\t    warning (0, \"%s:record size mismatch %lu bytes unread\\n\",\n-\t\t    filename, length - actual_length);\n-\t}\n+          actual_length = gcov_position () - base;\n+          if (actual_length > length)\n+            warning (0, \"%s:record size mismatch %lu bytes overread\\n\",\n+                     filename, actual_length - length);\n+          else if (length > actual_length)\n+            warning (0, \"%s:record size mismatch %lu bytes unread\\n\",\n+                     filename, length - actual_length);\n+       }\n \n       gcov_sync (base, length);\n       if ((error = gcov_is_error ()))\n-\t{\n-\t  warning (0, error < 0 ? \"%s:counter overflow at %lu\\n\" :\n-\t\t                  \"%s:read error at %lu\\n\", filename,\n-\t\t  (long unsigned) gcov_position ());\n-\t  break;\n-\t}\n+        {\n+          warning (0, error < 0 ? \"%s:counter overflow at %lu\\n\" :\n+                                  \"%s:read error at %lu\\n\", filename,\n+                   (long unsigned) gcov_position ());\n+          break;\n+        }\n     }\n \n   read_gcda_finalize (obj_info);\n@@ -577,7 +577,8 @@ gcov_merge (struct gcov_info *info1, struct gcov_info *info2, int w)\n    Return NULL if there is no match.  */\n \n static struct gcov_info *\n-find_match_gcov_info (struct gcov_info **array, int size, struct gcov_info *info)\n+find_match_gcov_info (struct gcov_info **array, int size,\n+\t\t      struct gcov_info *info)\n {\n   struct gcov_info *gi_ptr;\n   struct gcov_info *ret = NULL;\n@@ -872,7 +873,530 @@ gcov_profile_normalize (struct gcov_info *profile, gcov_type max_val)\n \n   scale_factor = (float)max_val / curr_max_val;\n   if (verbose)\n-    fnotice (stdout, \"max_val is %lld\\n\", (long long) curr_max_val);\n+    fnotice (stdout, \"max_val is %\"PRId64\"\\n\", curr_max_val);\n \n   return gcov_profile_scale (profile, scale_factor, 0, 0);\n }\n+\n+/* The following variables are defined in gcc/gcov-tool.c.  */\n+extern int overlap_func_level;\n+extern int overlap_obj_level;\n+extern int overlap_hot_only;\n+extern int overlap_use_fullname;\n+extern double overlap_hot_threshold;\n+\n+/* Compute the overlap score of two values. The score is defined as:\n+    min (V1/SUM_1, V2/SUM_2)  */\n+\n+static double\n+calculate_2_entries (const unsigned long v1, const unsigned long v2,\n+                     const double sum_1, const double sum_2)\n+{\n+  double val1 = (sum_1 == 0.0 ? 0.0 : v1/sum_1);\n+  double val2 = (sum_2 == 0.0 ? 0.0 : v2/sum_2);\n+\n+  if (val2 < val1)\n+    val1 = val2;\n+\n+  return val1;\n+}\n+\n+/*  Compute the overlap score between GCOV_INFO1 and GCOV_INFO2.\n+    SUM_1 is the sum_all for profile1 where GCOV_INFO1 belongs.\n+    SUM_2 is the sum_all for profile2 where GCOV_INFO2 belongs.\n+    This function also updates cumulative score CUM_1_RESULT and\n+    CUM_2_RESULT.  */\n+\n+static double\n+compute_one_gcov (const struct gcov_info *gcov_info1,\n+                  const struct gcov_info *gcov_info2,\n+                  const double sum_1, const double sum_2,\n+                  double *cum_1_result, double *cum_2_result)\n+{\n+  unsigned f_ix;\n+  double ret = 0;\n+  double cum_1 = 0, cum_2 = 0;\n+  const struct gcov_info *gcov_info = 0;\n+  double *cum_p;\n+  double sum;\n+\n+  gcc_assert (gcov_info1 || gcov_info2);\n+  if (!gcov_info1)\n+    {\n+      gcov_info = gcov_info2;\n+      cum_p = cum_2_result;\n+      sum = sum_2;\n+      *cum_1_result = 0;\n+    } else\n+  if (!gcov_info2)\n+    {\n+      gcov_info = gcov_info1;\n+      cum_p = cum_1_result;\n+      sum = sum_1;\n+      *cum_2_result = 0;\n+    }\n+\n+  if (gcov_info)\n+  {\n+    for (f_ix = 0; f_ix < gcov_info->n_functions; f_ix++)\n+      {\n+        unsigned t_ix;\n+        const struct gcov_fn_info *gfi_ptr = gcov_info->functions[f_ix];\n+        if (!gfi_ptr || gfi_ptr->key != gcov_info)\n+          continue;\n+        const struct gcov_ctr_info *ci_ptr = gfi_ptr->ctrs;\n+        for (t_ix = 0; t_ix < GCOV_COUNTERS_SUMMABLE; t_ix++)\n+          {\n+            unsigned c_num;\n+\n+            if (!gcov_info->merge[t_ix])\n+              continue;\n+\n+            for (c_num = 0; c_num < ci_ptr->num; c_num++)\n+              {\n+                cum_1 += ci_ptr->values[c_num] / sum;\n+              }\n+            ci_ptr++;\n+          }\n+      }\n+    *cum_p = cum_1;\n+    return 0.0;\n+  }\n+\n+  for (f_ix = 0; f_ix < gcov_info1->n_functions; f_ix++)\n+    {\n+      unsigned t_ix;\n+      double func_cum_1 = 0.0;\n+      double func_cum_2 = 0.0;\n+      double func_val = 0.0;\n+      int nonzero = 0;\n+      int hot = 0;\n+      const struct gcov_fn_info *gfi_ptr1 = gcov_info1->functions[f_ix];\n+      const struct gcov_fn_info *gfi_ptr2 = gcov_info2->functions[f_ix];\n+\n+      if (!gfi_ptr1 || gfi_ptr1->key != gcov_info1)\n+        continue;\n+      if (!gfi_ptr2 || gfi_ptr2->key != gcov_info2)\n+        continue;\n+\n+      const struct gcov_ctr_info *ci_ptr1 = gfi_ptr1->ctrs;\n+      const struct gcov_ctr_info *ci_ptr2 = gfi_ptr2->ctrs;\n+      for (t_ix = 0; t_ix < GCOV_COUNTERS_SUMMABLE; t_ix++)\n+        {\n+          unsigned c_num;\n+\n+          if (!gcov_info1->merge[t_ix])\n+            continue;\n+\n+          for (c_num = 0; c_num < ci_ptr1->num; c_num++)\n+            {\n+              if (ci_ptr1->values[c_num] | ci_ptr2->values[c_num])\n+                {\n+                  func_val += calculate_2_entries (ci_ptr1->values[c_num],\n+                                          ci_ptr2->values[c_num],\n+                                          sum_1, sum_2);\n+\n+                  func_cum_1 += ci_ptr1->values[c_num] / sum_1;\n+                  func_cum_2 += ci_ptr2->values[c_num] / sum_2;\n+                  nonzero = 1;\n+                  if (ci_ptr1->values[c_num] / sum_1 >= overlap_hot_threshold ||\n+                      ci_ptr2->values[c_num] / sum_2 >= overlap_hot_threshold)\n+                    hot = 1;\n+                }\n+            }\n+          ci_ptr1++;\n+          ci_ptr2++;\n+        }\n+      ret += func_val;\n+      cum_1 += func_cum_1;\n+      cum_2 += func_cum_2;\n+      if (overlap_func_level && nonzero && (!overlap_hot_only || hot))\n+        {\n+          printf(\"   \\tfunc_id=%10d \\toverlap =%6.5f%% (%5.5f%% %5.5f%%)\\n\",\n+                 gfi_ptr1->ident, func_val*100, func_cum_1*100, func_cum_2*100);\n+        }\n+    }\n+  *cum_1_result = cum_1;\n+  *cum_2_result = cum_2;\n+  return ret;\n+}\n+\n+/* Test if all counter values in this GCOV_INFO are cold.\n+   \"Cold\" is defined as the counter value being less than\n+   or equal to THRESHOLD.  */\n+\n+static bool\n+gcov_info_count_all_cold (const struct gcov_info *gcov_info,\n+                          gcov_type threshold)\n+{\n+  unsigned f_ix;\n+\n+  for (f_ix = 0; f_ix < gcov_info->n_functions; f_ix++)\n+    {\n+      unsigned t_ix;\n+      const struct gcov_fn_info *gfi_ptr = gcov_info->functions[f_ix];\n+\n+      if (!gfi_ptr || gfi_ptr->key != gcov_info)\n+        continue;\n+      const struct gcov_ctr_info *ci_ptr = gfi_ptr->ctrs;\n+      for (t_ix = 0; t_ix < GCOV_COUNTERS_SUMMABLE; t_ix++)\n+        {\n+          unsigned c_num;\n+\n+          if (!gcov_info->merge[t_ix])\n+            continue;\n+\n+          for (c_num = 0; c_num < ci_ptr->num; c_num++)\n+            {\n+              if (ci_ptr->values[c_num] > threshold)\n+                return false;\n+            }\n+          ci_ptr++;\n+        }\n+    }\n+\n+  return true;\n+}\n+\n+/* Test if all counter values in this GCOV_INFO are 0.  */\n+\n+static bool\n+gcov_info_count_all_zero (const struct gcov_info *gcov_info)\n+{\n+  return gcov_info_count_all_cold (gcov_info, 0);\n+}\n+\n+/* A pair of matched GCOV_INFO.\n+   The flag is a bitvector:\n+     b0: obj1's all counts are 0;\n+     b1: obj1's all counts are cold (but no 0);\n+     b2: obj1 is hot;\n+     b3: no obj1 to match obj2;\n+     b4: obj2's all counts are 0;\n+     b5: obj2's all counts are cold (but no 0);\n+     b6: obj2 is hot;\n+     b7: no obj2 to match obj1;\n+ */\n+struct overlap_t {\n+   const struct gcov_info *obj1;\n+   const struct gcov_info *obj2;\n+   char flag;\n+};\n+\n+#define FLAG_BOTH_ZERO(flag) ((flag & 0x1) && (flag & 0x10))\n+#define FLAG_BOTH_COLD(flag) ((flag & 0x2) && (flag & 0x20))\n+#define FLAG_ONE_HOT(flag) ((flag & 0x4) || (flag & 0x40))\n+\n+/* Cumlative overlap dscore for profile1 and profile2.  */\n+static double overlap_sum_1, overlap_sum_2;\n+\n+/* sum_all for profile1 and profile2.  */\n+static gcov_type p1_sum_all, p2_sum_all;\n+\n+/* run_max for profile1 and profile2.  */\n+static gcov_type p1_run_max, p2_run_max;\n+\n+/* The number of gcda files in the profiles.  */\n+static unsigned gcda_files[2];\n+\n+/* The number of unique gcda files in the profiles\n+   (not existing in the other profile).  */\n+static unsigned unique_gcda_files[2];\n+\n+/* The number of gcda files that all counter values are 0.  */\n+static unsigned zero_gcda_files[2];\n+\n+/* The number of gcda files that all counter values are cold (but not 0).  */\n+static unsigned cold_gcda_files[2];\n+\n+/* The number of gcda files that includes hot counter values.  */\n+static unsigned hot_gcda_files[2];\n+\n+/* The number of gcda files with hot count value in either profiles.  */\n+static unsigned both_hot_cnt;\n+\n+/* The number of gcda files with all counts cold (but not 0) in\n+   both profiles. */\n+static unsigned both_cold_cnt;\n+\n+/* The number of gcda files with all counts 0 in both profiles.  */\n+static unsigned both_zero_cnt;\n+\n+/* Extract the basename of the filename NAME.  */\n+\n+static char *\n+extract_file_basename (const char *name)\n+{\n+  char *str;\n+  int len = 0;\n+  char *path = xstrdup (name);\n+  char sep_str[2];\n+\n+  sep_str[0] = DIR_SEPARATOR;\n+  sep_str[1] = 0;\n+  str = strstr(path, sep_str);\n+  do{\n+      len = strlen(str) + 1;\n+      path = &path[strlen(path) - len + 2];\n+      str = strstr(path, sep_str);\n+  } while(str);\n+\n+  return path;\n+}\n+\n+/* Utility function to get the filename.  */\n+\n+static const char *\n+get_file_basename (const char *name)\n+{\n+  if (overlap_use_fullname)\n+    return name;\n+  return extract_file_basename (name);\n+}\n+\n+/* A utility function to set the flag for the gcda files.  */\n+\n+static void\n+set_flag (struct overlap_t *e)\n+{\n+  char flag = 0;\n+\n+  if (!e->obj1)\n+    {\n+      unique_gcda_files[1]++;\n+      flag = 0x8;\n+    }\n+  else\n+    {\n+      gcda_files[0]++;\n+      if (gcov_info_count_all_zero (e->obj1))\n+        {\n+          zero_gcda_files[0]++;\n+          flag = 0x1;\n+        }\n+      else\n+      if (gcov_info_count_all_cold (e->obj1, overlap_sum_1\n+\t\t\t      * overlap_hot_threshold))\n+        {\n+          cold_gcda_files[0]++;\n+          flag = 0x2;\n+        }\n+      else\n+        {\n+          hot_gcda_files[0]++;\n+          flag = 0x4;\n+        }\n+    }\n+\n+  if (!e->obj2)\n+    {\n+      unique_gcda_files[0]++;\n+      flag |= (0x8 << 4);\n+    }\n+  else\n+    {\n+      gcda_files[1]++;\n+      if (gcov_info_count_all_zero (e->obj2))\n+        {\n+          zero_gcda_files[1]++;\n+          flag |= (0x1 << 4);\n+        }\n+      else\n+      if (gcov_info_count_all_cold (e->obj2, overlap_sum_2\n+\t\t\t      * overlap_hot_threshold))\n+        {\n+          cold_gcda_files[1]++;\n+          flag |= (0x2 << 4);\n+        }\n+      else\n+        {\n+          hot_gcda_files[1]++;\n+          flag |= (0x4 << 4);\n+        }\n+    }\n+\n+  gcc_assert (flag);\n+  e->flag = flag;\n+}\n+\n+/* Test if INFO1 and INFO2 are from the matched source file.\n+   Return 1 if they match; return 0 otherwise.  */\n+\n+static int\n+matched_gcov_info (const struct gcov_info *info1, const struct gcov_info *info2)\n+{\n+  /* For FDO, we have to match the name. This can be expensive.\n+     Maybe we should use hash here.  */\n+  if (strcmp (info1->filename, info2->filename))\n+    return 0;\n+\n+  if (info1->n_functions != info2->n_functions)\n+    {\n+      fnotice (stderr, \"mismatched profiles in %s (%d functions\"\n+                       \" vs %d functions)\\n\",\n+                       info1->filename,\n+                       info1->n_functions,\n+                       info2->n_functions);\n+      return 0;\n+    }\n+  return 1;\n+}\n+\n+/* Defined in libgcov-driver.c.  */\n+extern gcov_unsigned_t compute_summary (struct gcov_info *,\n+                 struct gcov_summary *, size_t *);\n+\n+/* Compute the overlap score of two profiles with the head of GCOV_LIST1 and\n+   GCOV_LIST1. Return a number ranging from [0.0, 1.0], with 0.0 meaning no\n+   match and 1.0 meaning a perfect match.  */\n+\n+static double\n+calculate_overlap (struct gcov_info *gcov_list1,\n+                   struct gcov_info *gcov_list2)\n+{\n+  struct gcov_summary this_prg;\n+  unsigned list1_cnt = 0, list2_cnt= 0, all_cnt;\n+  unsigned int i, j;\n+  size_t max_length;\n+  const struct gcov_info *gi_ptr;\n+  struct overlap_t *all_infos;\n+\n+  compute_summary (gcov_list1, &this_prg, &max_length);\n+  overlap_sum_1 = (double) (this_prg.ctrs[0].sum_all);\n+  p1_sum_all = this_prg.ctrs[0].sum_all;\n+  p1_run_max = this_prg.ctrs[0].run_max;\n+  compute_summary (gcov_list2, &this_prg, &max_length);\n+  overlap_sum_2 = (double) (this_prg.ctrs[0].sum_all);\n+  p2_sum_all = this_prg.ctrs[0].sum_all;\n+  p2_run_max = this_prg.ctrs[0].run_max;\n+\n+  for (gi_ptr = gcov_list1; gi_ptr; gi_ptr = gi_ptr->next)\n+    list1_cnt++;\n+  for (gi_ptr = gcov_list2; gi_ptr; gi_ptr = gi_ptr->next)\n+    list2_cnt++;\n+  all_cnt = list1_cnt + list2_cnt;\n+  all_infos = (struct overlap_t *) xmalloc (sizeof (struct overlap_t)\n+               * all_cnt * 2);\n+  gcc_assert (all_infos);\n+\n+  i = 0;\n+  for (gi_ptr = gcov_list1; gi_ptr; gi_ptr = gi_ptr->next, i++)\n+    {\n+      all_infos[i].obj1 = gi_ptr;\n+      all_infos[i].obj2 = 0;\n+    }\n+\n+  for (gi_ptr = gcov_list2; gi_ptr; gi_ptr = gi_ptr->next, i++)\n+    {\n+      all_infos[i].obj1 = 0;\n+      all_infos[i].obj2 = gi_ptr;\n+    }\n+\n+  for (i = list1_cnt; i < all_cnt; i++)\n+    {\n+      if (all_infos[i].obj2 == 0)\n+        continue;\n+      for (j = 0; j < list1_cnt; j++)\n+        {\n+          if (all_infos[j].obj2 != 0)\n+            continue;\n+          if (matched_gcov_info (all_infos[i].obj2, all_infos[j].obj1))\n+            {\n+              all_infos[j].obj2 = all_infos[i].obj2;\n+              all_infos[i].obj2 = 0;\n+              break;\n+            }\n+        }\n+    }\n+\n+  for (i = 0; i < all_cnt; i++)\n+    if (all_infos[i].obj1 || all_infos[i].obj2)\n+      {\n+        set_flag (all_infos + i);\n+        if (FLAG_ONE_HOT (all_infos[i].flag))\n+            both_hot_cnt++;\n+        if (FLAG_BOTH_COLD(all_infos[i].flag))\n+            both_cold_cnt++;\n+        if (FLAG_BOTH_ZERO(all_infos[i].flag))\n+            both_zero_cnt++;\n+      }\n+\n+  double prg_val = 0;\n+  double sum_val = 0;\n+  double sum_cum_1 = 0;\n+  double sum_cum_2 = 0;\n+\n+  for (i = 0; i < all_cnt; i++)\n+    {\n+      double val;\n+      double cum_1, cum_2;\n+      const char *filename;\n+\n+      if (all_infos[i].obj1 == 0 && all_infos[i].obj2 == 0)\n+        continue;\n+      if (FLAG_BOTH_ZERO (all_infos[i].flag))\n+          continue;\n+\n+      if (all_infos[i].obj1)\n+        filename = get_file_basename (all_infos[i].obj1->filename);\n+      else\n+        filename = get_file_basename (all_infos[i].obj2->filename);\n+\n+      if (overlap_func_level)\n+        printf(\"\\n   processing %36s:\\n\", filename);\n+\n+      val = compute_one_gcov (all_infos[i].obj1, all_infos[i].obj2,\n+          overlap_sum_1, overlap_sum_2, &cum_1, &cum_2);\n+\n+      if (overlap_obj_level && (!overlap_hot_only || FLAG_ONE_HOT (all_infos[i].flag)))\n+        {\n+          printf(\"   obj=%36s  overlap = %6.2f%% (%5.2f%% %5.2f%%)\\n\",\n+                  filename, val*100, cum_1*100, cum_2*100);\n+          sum_val += val;\n+          sum_cum_1 += cum_1;\n+          sum_cum_2 += cum_2;\n+        }\n+\n+      prg_val += val;\n+\n+    }\n+\n+  if (overlap_obj_level)\n+    printf(\"   SUM:%36s  overlap = %6.2f%% (%5.2f%% %5.2f%%)\\n\",\n+           \"\", sum_val*100, sum_cum_1*100, sum_cum_2*100);\n+\n+  printf (\"  Statistics:\\n\"\n+          \"                    profile1_#     profile2_#       overlap_#\\n\");\n+  printf (\"    gcda files:  %12u\\t%12u\\t%12u\\n\", gcda_files[0], gcda_files[1],\n+                                          gcda_files[0]-unique_gcda_files[0]);\n+  printf (\"  unique files:  %12u\\t%12u\\n\", unique_gcda_files[0],\n+                                        unique_gcda_files[1]);\n+  printf (\"     hot files:  %12u\\t%12u\\t%12u\\n\", hot_gcda_files[0],\n+                                            hot_gcda_files[1], both_hot_cnt);\n+  printf (\"    cold files:  %12u\\t%12u\\t%12u\\n\", cold_gcda_files[0],\n+                                            cold_gcda_files[1], both_cold_cnt);\n+  printf (\"    zero files:  %12u\\t%12u\\t%12u\\n\", zero_gcda_files[0],\n+                                            zero_gcda_files[1], both_zero_cnt);\n+  printf (\"       sum_all:  %12\"PRId64\"\\t%12\"PRId64\"\\n\", p1_sum_all, p2_sum_all);\n+  printf (\"       run_max:  %12\"PRId64\"\\t%12\"PRId64\"\\n\", p1_run_max, p2_run_max);\n+\n+  return prg_val;\n+}\n+\n+/* Computer the overlap score of two lists of gcov_info objects PROFILE1 and PROFILE2.\n+   Return 0 on success: without mismatch. Reutrn 1 on error.  */\n+\n+int\n+gcov_profile_overlap (struct gcov_info *profile1, struct gcov_info *profile2)\n+{\n+  double result;\n+\n+  result = calculate_overlap (profile1, profile2);\n+\n+  if (result > 0)\n+    {\n+      printf(\"\\nProgram level overlap result is %3.2f%%\\n\\n\", result*100);\n+      return 0;\n+    }\n+  return 1;\n+}"}]}