{"sha": "9dc3f7de0d62dfaf42457c92ab5295a03aa1a72b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWRjM2Y3ZGUwZDYyZGZhZjQyNDU3YzkyYWI1Mjk1YTAzYWExYTcyYg==", "commit": {"author": {"name": "Ira Rosen", "email": "irar@il.ibm.com", "date": "2010-10-21T13:36:56Z"}, "committer": {"name": "Ira Rosen", "email": "irar@gcc.gnu.org", "date": "2010-10-21T13:36:56Z"}, "message": "re PR tree-optimization/46049 (ICE: in expand_widen_pattern_expr, at optabs.c:522 with -ftree-vectorize)\n\n\n\tPR tree-optimization/46049\n\tPR tree-optimization/46052\n\t* tree-vectorizer.h (enum stmt_vec_info_type): Add new value for\n\tshift.\n\t(vect_get_slp_defs): Add arguments.\n\t* tree-vect-loop.c (vect_create_epilog_for_reduction): Pass scalar\n\toperands to vect_get_slp_defs.\n\t(vectorizable_reduction): Fix comment, pass scalar operands to\n\tvect_get_slp_defs.\n\t* tree-vect-stmts.c (vect_get_vec_def_for_operand): Use operand's\n\ttype to determine number of units in the created vector.\n\t(vect_get_vec_defs): Pass scalar operands to vect_get_slp_defs.\n\t(vectorizable_conversion): Fix comment.\n\t(vectorizable_shift): New function.\n\t(vectorizable_operation): Move code that handles shifts to\n\tvectorizable_shift.\n\t(vectorizable_type_demotion): Fix comment, pass scalar operands to\n\tvect_get_slp_defs.\n\t(vectorizable_type_promotion, vectorizable_store): Likewise.\n\t(vectorizable_condition): Fix comment.\n\t(vect_analyze_stmt): Call vectorizable_shift.\n\t(vect_transform_stmt): Likewise.\n\t* tree-vect-slp.c (vect_get_constant_vectors): Add new argument.\n\tUse it as the operand to create vectors for, except reduction\n\tinitial definition and store.  Use operands type.\n\t(vect_get_slp_defs): Add new arguments.  Pass them to\n\tvect_get_constant_vectors.\n\nFrom-SVN: r165777", "tree": {"sha": "300d18c5421de122b062f8b293724c24ba1cf14b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/300d18c5421de122b062f8b293724c24ba1cf14b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9dc3f7de0d62dfaf42457c92ab5295a03aa1a72b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9dc3f7de0d62dfaf42457c92ab5295a03aa1a72b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9dc3f7de0d62dfaf42457c92ab5295a03aa1a72b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9dc3f7de0d62dfaf42457c92ab5295a03aa1a72b/comments", "author": {"login": "irar2", "id": 16818592, "node_id": "MDQ6VXNlcjE2ODE4NTky", "avatar_url": "https://avatars.githubusercontent.com/u/16818592?v=4", "gravatar_id": "", "url": "https://api.github.com/users/irar2", "html_url": "https://github.com/irar2", "followers_url": "https://api.github.com/users/irar2/followers", "following_url": "https://api.github.com/users/irar2/following{/other_user}", "gists_url": "https://api.github.com/users/irar2/gists{/gist_id}", "starred_url": "https://api.github.com/users/irar2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/irar2/subscriptions", "organizations_url": "https://api.github.com/users/irar2/orgs", "repos_url": "https://api.github.com/users/irar2/repos", "events_url": "https://api.github.com/users/irar2/events{/privacy}", "received_events_url": "https://api.github.com/users/irar2/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "027dbed8279f0312e8d01852728c5d8141ca5e33", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/027dbed8279f0312e8d01852728c5d8141ca5e33", "html_url": "https://github.com/Rust-GCC/gccrs/commit/027dbed8279f0312e8d01852728c5d8141ca5e33"}], "stats": {"total": 584, "additions": 453, "deletions": 131}, "files": [{"sha": "39d0b9b57840fd18d9694e7600a7c99f476d50f4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9dc3f7de0d62dfaf42457c92ab5295a03aa1a72b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9dc3f7de0d62dfaf42457c92ab5295a03aa1a72b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9dc3f7de0d62dfaf42457c92ab5295a03aa1a72b", "patch": "@@ -1,3 +1,33 @@\n+2010-10-21  Ira Rosen  <irar@il.ibm.com>\n+\n+\tPR tree-optimization/46049\n+\tPR tree-optimization/46052\n+\t* tree-vectorizer.h (enum stmt_vec_info_type): Add new value for\n+\tshift.\n+\t(vect_get_slp_defs): Add arguments.\n+\t* tree-vect-loop.c (vect_create_epilog_for_reduction): Pass scalar\n+\toperands to vect_get_slp_defs.\n+\t(vectorizable_reduction): Fix comment, pass scalar operands to\n+\tvect_get_slp_defs.\n+\t* tree-vect-stmts.c (vect_get_vec_def_for_operand): Use operand's\n+\ttype to determine number of units in the created vector.\n+\t(vect_get_vec_defs): Pass scalar operands to vect_get_slp_defs.\n+\t(vectorizable_conversion): Fix comment.\n+\t(vectorizable_shift): New function.\n+\t(vectorizable_operation): Move code that handles shifts to\n+\tvectorizable_shift.\n+\t(vectorizable_type_demotion): Fix comment, pass scalar operands to\n+\tvect_get_slp_defs.\n+\t(vectorizable_type_promotion, vectorizable_store): Likewise.\n+\t(vectorizable_condition): Fix comment.\n+\t(vect_analyze_stmt): Call vectorizable_shift.\n+\t(vect_transform_stmt): Likewise.\n+\t* tree-vect-slp.c (vect_get_constant_vectors): Add new argument.\n+\tUse it as the operand to create vectors for, except reduction\n+\tinitial definition and store.  Use operands type.\n+\t(vect_get_slp_defs): Add new arguments.  Pass them to\n+\t vect_get_constant_vectors.\n+\n 2010-10-21  Nathan Froyd  <froydnj@codesourcery.com>\n \n \t* basic-block.h (single_succ_edge): Use gcc_checking_assert."}, {"sha": "b4387d5f2ba70330729dffd3161e4481bfe08025", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9dc3f7de0d62dfaf42457c92ab5295a03aa1a72b/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9dc3f7de0d62dfaf42457c92ab5295a03aa1a72b/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=9dc3f7de0d62dfaf42457c92ab5295a03aa1a72b", "patch": "@@ -1,3 +1,10 @@\n+2010-10-21  Ira Rosen  <irar@il.ibm.com>\n+\n+\tPR tree-optimization/46049\n+\tPR tree-optimization/46052\n+\t* gcc.dg/vect/pr46052.c: New test.\n+\t* gcc.dg/vect/pr46049.c: New test.\n+\n 2010-10-21  Thomas Koenig  <tkoenig@gcc.gnu.org>\n \n \tPR fortran/46007"}, {"sha": "90020681ef2e0f29abb770f76f6f6a5f025e48d3", "filename": "gcc/testsuite/gcc.dg/vect/pr46049.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9dc3f7de0d62dfaf42457c92ab5295a03aa1a72b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr46049.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9dc3f7de0d62dfaf42457c92ab5295a03aa1a72b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr46049.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr46049.c?ref=9dc3f7de0d62dfaf42457c92ab5295a03aa1a72b", "patch": "@@ -0,0 +1,21 @@\n+/* { dg-do compile } */\n+\n+typedef __INT16_TYPE__ int16_t;\n+typedef __INT32_TYPE__ int32_t;\n+\n+static inline int32_t bar (int16_t x, int16_t y)\n+{\n+  return x * y;\n+}\n+\n+void foo (int16_t i, int16_t *p, int16_t x)\n+{\n+  while (i--)\n+    {\n+      *p = bar (*p, x) >> 15;\n+      p++;\n+      *p = bar (*p, x) >> 15;\n+      p++;\n+    }\n+}\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "c32a93d07d812a8a03fe0c5184035ce8b70d8375", "filename": "gcc/testsuite/gcc.dg/vect/pr46052.c", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9dc3f7de0d62dfaf42457c92ab5295a03aa1a72b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr46052.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9dc3f7de0d62dfaf42457c92ab5295a03aa1a72b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr46052.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr46052.c?ref=9dc3f7de0d62dfaf42457c92ab5295a03aa1a72b", "patch": "@@ -0,0 +1,33 @@\n+/* { dg-do compile } */\n+\n+int i;\n+int a[2];\n+\n+static inline char bar (void)\n+{\n+  return i ? i : 1;\n+}\n+\n+void foo (int n)\n+{\n+  while (n--)\n+    {\n+      a[0] ^= bar ();\n+      a[1] ^= bar ();\n+    }\n+}\n+\n+static inline char bar1 (void)\n+{\n+}\n+\n+void foo1 (int n)\n+{\n+  while (n--)\n+    {\n+      a[0] ^= bar1 ();\n+      a[1] ^= bar1 ();\n+    }\n+}\n+\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "4b1bd44305408ea4c7cbbdfbcb987db0f594aff4", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 18, "deletions": 10, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9dc3f7de0d62dfaf42457c92ab5295a03aa1a72b/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9dc3f7de0d62dfaf42457c92ab5295a03aa1a72b/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=9dc3f7de0d62dfaf42457c92ab5295a03aa1a72b", "patch": "@@ -3193,7 +3193,8 @@ vect_create_epilog_for_reduction (VEC (tree, heap) *vect_defs, gimple stmt,\n \n   /* Get the loop-entry arguments.  */\n   if (slp_node)\n-    vect_get_slp_defs (slp_node, &vec_initial_defs, NULL, reduc_index);\n+    vect_get_slp_defs (reduction_op, NULL_TREE, slp_node, &vec_initial_defs,\n+                       NULL, reduc_index);\n   else\n     {\n       vec_initial_defs = VEC_alloc (tree, heap, 1);\n@@ -3965,7 +3966,7 @@ vectorizable_reduction (gimple stmt, gimple_stmt_iterator *gsi,\n \n   gcc_assert (is_gimple_assign (stmt));\n \n-  /* Flatten RHS */\n+  /* Flatten RHS.  */\n   switch (get_gimple_rhs_class (gimple_assign_rhs_code (stmt)))\n     {\n     case GIMPLE_SINGLE_RHS:\n@@ -4332,22 +4333,29 @@ vectorizable_reduction (gimple stmt, gimple_stmt_iterator *gsi,\n       /* Handle uses.  */\n       if (j == 0)\n         {\n+          tree op0, op1 = NULL_TREE;\n+\n+          op0 = ops[!reduc_index];\n+          if (op_type == ternary_op)\n+            {\n+              if (reduc_index == 0)\n+                op1 = ops[2];\n+              else\n+                op1 = ops[1];\n+            }\n+\n           if (slp_node)\n-            vect_get_slp_defs (slp_node, &vec_oprnds0, &vec_oprnds1, -1);\n+            vect_get_slp_defs (op0, op1, slp_node, &vec_oprnds0, &vec_oprnds1,\n+                               -1);\n           else\n             {\n               loop_vec_def0 = vect_get_vec_def_for_operand (ops[!reduc_index],\n                                                             stmt, NULL);\n               VEC_quick_push (tree, vec_oprnds0, loop_vec_def0);\n               if (op_type == ternary_op)\n                {\n-                 if (reduc_index == 0)\n-                   loop_vec_def1 = vect_get_vec_def_for_operand (ops[2], stmt,\n-                                                                 NULL);\n-                 else\n-                   loop_vec_def1 = vect_get_vec_def_for_operand (ops[1], stmt,\n-                                                                 NULL);\n-\n+                 loop_vec_def1 = vect_get_vec_def_for_operand (op1, stmt,\n+                                                               NULL);\n                  VEC_quick_push (tree, vec_oprnds1, loop_vec_def1);\n                }\n             }"}, {"sha": "7a69db05ebb43834069bacd1ef0280625652ffa7", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 13, "deletions": 19, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9dc3f7de0d62dfaf42457c92ab5295a03aa1a72b/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9dc3f7de0d62dfaf42457c92ab5295a03aa1a72b/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=9dc3f7de0d62dfaf42457c92ab5295a03aa1a72b", "patch": "@@ -1817,7 +1817,8 @@ vect_update_slp_costs_according_to_vf (loop_vec_info loop_vinfo)\n    it is -1.  */\n \n static void\n-vect_get_constant_vectors (slp_tree slp_node, VEC(tree,heap) **vec_oprnds,\n+vect_get_constant_vectors (tree op, slp_tree slp_node,\n+                           VEC (tree, heap) **vec_oprnds,\n \t\t\t   unsigned int op_num, unsigned int number_of_vectors,\n                            int reduc_index)\n {\n@@ -1829,7 +1830,7 @@ vect_get_constant_vectors (slp_tree slp_node, VEC(tree,heap) **vec_oprnds,\n   tree t = NULL_TREE;\n   int j, number_of_places_left_in_vector;\n   tree vector_type;\n-  tree op, vop;\n+  tree vop;\n   int group_size = VEC_length (gimple, stmts);\n   unsigned int vec_num, i;\n   int number_of_copies = 1;\n@@ -1847,7 +1848,7 @@ vect_get_constant_vectors (slp_tree slp_node, VEC(tree,heap) **vec_oprnds,\n         }\n \n       op_num = reduc_index - 1;\n-      op = gimple_op (stmt, op_num + 1);\n+      op = gimple_op (stmt, reduc_index);\n       /* For additional copies (see the explanation of NUMBER_OF_COPIES below)\n          we need either neutral operands or the original operands.  See\n          get_initial_def_for_reduction() for details.  */\n@@ -1889,25 +1890,16 @@ vect_get_constant_vectors (slp_tree slp_node, VEC(tree,heap) **vec_oprnds,\n       op = gimple_assign_rhs1 (stmt);\n     }\n   else\n-    {\n-      is_store = false;\n-      op = gimple_op (stmt, op_num + 1);\n-    }\n+    is_store = false;\n+\n+  gcc_assert (op);\n \n   if (CONSTANT_CLASS_P (op))\n     constant_p = true;\n   else\n     constant_p = false;\n \n-  /* For POINTER_PLUS_EXPR we use the type of the constant/invariant itself.\n-     If OP is the first operand of POINTER_PLUS_EXPR, its type is the type of\n-     the statement, so it's OK to use OP's type for both first and second\n-     operands.  */\n-  if (code == POINTER_PLUS_EXPR)\n-    vector_type = get_vectype_for_scalar_type (TREE_TYPE (op));\n-  else\n-    vector_type = STMT_VINFO_VECTYPE (stmt_vinfo);\n-\n+  vector_type = get_vectype_for_scalar_type (TREE_TYPE (op));\n   gcc_assert (vector_type);\n   nunits = TYPE_VECTOR_SUBPARTS (vector_type);\n \n@@ -2043,7 +2035,8 @@ vect_get_slp_vect_defs (slp_tree slp_node, VEC (tree,heap) **vec_oprnds)\n    the right node. This is used when the second operand must remain scalar.  */\n \n void\n-vect_get_slp_defs (slp_tree slp_node, VEC (tree,heap) **vec_oprnds0,\n+vect_get_slp_defs (tree op0, tree op1, slp_tree slp_node,\n+                   VEC (tree,heap) **vec_oprnds0,\n                    VEC (tree,heap) **vec_oprnds1, int reduc_index)\n {\n   gimple first_stmt;\n@@ -2083,7 +2076,7 @@ vect_get_slp_defs (slp_tree slp_node, VEC (tree,heap) **vec_oprnds0,\n     vect_get_slp_vect_defs (SLP_TREE_LEFT (slp_node), vec_oprnds0);\n   else\n     /* Build vectors from scalar defs.  */\n-    vect_get_constant_vectors (slp_node, vec_oprnds0, 0, number_of_vects,\n+    vect_get_constant_vectors (op0, slp_node, vec_oprnds0, 0, number_of_vects,\n                                reduc_index);\n \n   if (STMT_VINFO_DATA_REF (vinfo_for_stmt (first_stmt)))\n@@ -2113,7 +2106,8 @@ vect_get_slp_defs (slp_tree slp_node, VEC (tree,heap) **vec_oprnds0,\n     vect_get_slp_vect_defs (SLP_TREE_RIGHT (slp_node), vec_oprnds1);\n   else\n     /* Build vectors from scalar defs.  */\n-    vect_get_constant_vectors (slp_node, vec_oprnds1, 1, number_of_vects, -1);\n+    vect_get_constant_vectors (op1, slp_node, vec_oprnds1, 1, number_of_vects,\n+                               -1);\n }\n \n "}, {"sha": "3617ec337a14a3edb95512526edc543d3ad47b23", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 329, "deletions": 101, "changes": 430, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9dc3f7de0d62dfaf42457c92ab5295a03aa1a72b/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9dc3f7de0d62dfaf42457c92ab5295a03aa1a72b/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=9dc3f7de0d62dfaf42457c92ab5295a03aa1a72b", "patch": "@@ -983,8 +983,7 @@ vect_get_vec_def_for_operand (tree op, gimple stmt, tree *scalar_def)\n   gimple def_stmt;\n   stmt_vec_info def_stmt_info = NULL;\n   stmt_vec_info stmt_vinfo = vinfo_for_stmt (stmt);\n-  tree vectype = STMT_VINFO_VECTYPE (stmt_vinfo);\n-  unsigned int nunits = TYPE_VECTOR_SUBPARTS (vectype);\n+  unsigned int nunits;\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_vinfo);\n   tree vec_inv;\n   tree vec_cst;\n@@ -1025,6 +1024,7 @@ vect_get_vec_def_for_operand (tree op, gimple stmt, tree *scalar_def)\n       {\n \tvector_type = get_vectype_for_scalar_type (TREE_TYPE (op));\n \tgcc_assert (vector_type);\n+\tnunits = TYPE_VECTOR_SUBPARTS (vector_type);\n \n \tif (scalar_def)\n \t  *scalar_def = op;\n@@ -1229,7 +1229,7 @@ vect_get_vec_defs (tree op0, tree op1, gimple stmt,\n \t\t   slp_tree slp_node)\n {\n   if (slp_node)\n-    vect_get_slp_defs (slp_node, vec_oprnds0, vec_oprnds1, -1);\n+    vect_get_slp_defs (op0, op1, slp_node, vec_oprnds0, vec_oprnds1, -1);\n   else\n     {\n       tree vec_oprnd;\n@@ -1882,7 +1882,7 @@ vectorizable_conversion (gimple stmt, gimple_stmt_iterator *gsi,\n \t      vec_oprnd1 = vect_get_vec_def_for_stmt_copy (dt[0], vec_oprnd0);\n \t    }\n \n-\t  /* Arguments are ready. Create the new vector stmt.  */\n+\t  /* Arguments are ready.  Create the new vector stmt.  */\n \t  new_stmt = gimple_build_assign_with_ops (code1, vec_dest, vec_oprnd0,\n \t\t\t\t\t\t   vec_oprnd1);\n \t  new_temp = make_ssa_name (vec_dest, new_stmt);\n@@ -2041,6 +2041,309 @@ vectorizable_assignment (gimple stmt, gimple_stmt_iterator *gsi,\n   return true;\n }\n \n+\n+/* Function vectorizable_shift.\n+\n+   Check if STMT performs a shift operation that can be vectorized.\n+   If VEC_STMT is also passed, vectorize the STMT: create a vectorized\n+   stmt to replace it, put it in VEC_STMT, and insert it at BSI.\n+   Return FALSE if not a vectorizable STMT, TRUE otherwise.  */\n+\n+static bool\n+vectorizable_shift (gimple stmt, gimple_stmt_iterator *gsi,\n+                    gimple *vec_stmt, slp_tree slp_node)\n+{\n+  tree vec_dest;\n+  tree scalar_dest;\n+  tree op0, op1 = NULL;\n+  tree vec_oprnd1 = NULL_TREE;\n+  stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n+  tree vectype;\n+  loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n+  enum tree_code code;\n+  enum machine_mode vec_mode;\n+  tree new_temp;\n+  optab optab;\n+  int icode;\n+  enum machine_mode optab_op2_mode;\n+  tree def;\n+  gimple def_stmt;\n+  enum vect_def_type dt[2] = {vect_unknown_def_type, vect_unknown_def_type};\n+  gimple new_stmt = NULL;\n+  stmt_vec_info prev_stmt_info;\n+  int nunits_in;\n+  int nunits_out;\n+  tree vectype_out;\n+  int ncopies;\n+  int j, i;\n+  VEC (tree, heap) *vec_oprnds0 = NULL, *vec_oprnds1 = NULL;\n+  tree vop0, vop1;\n+  unsigned int k;\n+  bool scalar_shift_arg = false;\n+  bb_vec_info bb_vinfo = STMT_VINFO_BB_VINFO (stmt_info);\n+  int vf;\n+\n+  if (!STMT_VINFO_RELEVANT_P (stmt_info) && !bb_vinfo)\n+    return false;\n+\n+  if (STMT_VINFO_DEF_TYPE (stmt_info) != vect_internal_def)\n+    return false;\n+\n+  /* Is STMT a vectorizable binary/unary operation?   */\n+  if (!is_gimple_assign (stmt))\n+    return false;\n+\n+  if (TREE_CODE (gimple_assign_lhs (stmt)) != SSA_NAME)\n+    return false;\n+\n+  code = gimple_assign_rhs_code (stmt);\n+\n+  if (!(code == LSHIFT_EXPR || code == RSHIFT_EXPR || code == LROTATE_EXPR\n+      || code == RROTATE_EXPR))\n+    return false;\n+\n+  scalar_dest = gimple_assign_lhs (stmt);\n+  vectype_out = STMT_VINFO_VECTYPE (stmt_info);\n+\n+  op0 = gimple_assign_rhs1 (stmt);\n+  if (!vect_is_simple_use_1 (op0, loop_vinfo, bb_vinfo,\n+                             &def_stmt, &def, &dt[0], &vectype))\n+    {\n+      if (vect_print_dump_info (REPORT_DETAILS))\n+        fprintf (vect_dump, \"use not simple.\");\n+      return false;\n+    }\n+  /* If op0 is an external or constant def use a vector type with\n+     the same size as the output vector type.  */\n+  if (!vectype)\n+    vectype = get_same_sized_vectype (TREE_TYPE (op0), vectype_out);\n+  if (vec_stmt)\n+    gcc_assert (vectype);\n+  if (!vectype)\n+    {\n+      if (vect_print_dump_info (REPORT_DETAILS))\n+        {\n+          fprintf (vect_dump, \"no vectype for scalar type \");\n+          print_generic_expr (vect_dump, TREE_TYPE (op0), TDF_SLIM);\n+        }\n+\n+      return false;\n+    }\n+\n+  nunits_out = TYPE_VECTOR_SUBPARTS (vectype_out);\n+  nunits_in = TYPE_VECTOR_SUBPARTS (vectype);\n+  if (nunits_out != nunits_in)\n+    return false;\n+\n+  op1 = gimple_assign_rhs2 (stmt);\n+  if (!vect_is_simple_use (op1, loop_vinfo, bb_vinfo, &def_stmt, &def, &dt[1]))\n+    {\n+      if (vect_print_dump_info (REPORT_DETAILS))\n+        fprintf (vect_dump, \"use not simple.\");\n+      return false;\n+    }\n+\n+  if (loop_vinfo)\n+    vf = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n+  else\n+    vf = 1;\n+\n+  /* Multiple types in SLP are handled by creating the appropriate number of\n+     vectorized stmts for each SLP node.  Hence, NCOPIES is always 1 in\n+     case of SLP.  */\n+  if (slp_node)\n+    ncopies = 1;\n+  else\n+    ncopies = LOOP_VINFO_VECT_FACTOR (loop_vinfo) / nunits_in;\n+\n+  gcc_assert (ncopies >= 1);\n+\n+  /* Determine whether the shift amount is a vector, or scalar.  If the\n+     shift/rotate amount is a vector, use the vector/vector shift optabs.  */\n+\n+  /* Vector shifted by vector.  */\n+  if (dt[1] == vect_internal_def)\n+    {\n+      optab = optab_for_tree_code (code, vectype, optab_vector);\n+      if (vect_print_dump_info (REPORT_DETAILS))\n+        fprintf (vect_dump, \"vector/vector shift/rotate found.\");\n+    }\n+  /* See if the machine has a vector shifted by scalar insn and if not\n+     then see if it has a vector shifted by vector insn.  */\n+  else if (dt[1] == vect_constant_def || dt[1] == vect_external_def)\n+    {\n+      optab = optab_for_tree_code (code, vectype, optab_scalar);\n+      if (optab\n+          && optab_handler (optab, TYPE_MODE (vectype)) != CODE_FOR_nothing)\n+        {\n+          scalar_shift_arg = true;\n+          if (vect_print_dump_info (REPORT_DETAILS))\n+            fprintf (vect_dump, \"vector/scalar shift/rotate found.\");\n+        }\n+      else\n+        {\n+          optab = optab_for_tree_code (code, vectype, optab_vector);\n+          if (optab\n+               && (optab_handler (optab, TYPE_MODE (vectype))\n+                      != CODE_FOR_nothing))\n+            {\n+              if (vect_print_dump_info (REPORT_DETAILS))\n+                fprintf (vect_dump, \"vector/vector shift/rotate found.\");\n+\n+              /* Unlike the other binary operators, shifts/rotates have\n+                 the rhs being int, instead of the same type as the lhs,\n+                 so make sure the scalar is the right type if we are\n+                 dealing with vectors of short/char.  */\n+              if (dt[1] == vect_constant_def)\n+                op1 = fold_convert (TREE_TYPE (vectype), op1);\n+            }\n+        }\n+    }\n+  else\n+    {\n+      if (vect_print_dump_info (REPORT_DETAILS))\n+        fprintf (vect_dump, \"operand mode requires invariant argument.\");\n+      return false;\n+    }\n+\n+  /* Supportable by target?  */\n+  if (!optab)\n+    {\n+      if (vect_print_dump_info (REPORT_DETAILS))\n+        fprintf (vect_dump, \"no optab.\");\n+      return false;\n+    }\n+  vec_mode = TYPE_MODE (vectype);\n+  icode = (int) optab_handler (optab, vec_mode);\n+  if (icode == CODE_FOR_nothing)\n+    {\n+      if (vect_print_dump_info (REPORT_DETAILS))\n+        fprintf (vect_dump, \"op not supported by target.\");\n+      /* Check only during analysis.  */\n+      if (GET_MODE_SIZE (vec_mode) != UNITS_PER_WORD\n+          || (vf < vect_min_worthwhile_factor (code)\n+              && !vec_stmt))\n+        return false;\n+      if (vect_print_dump_info (REPORT_DETAILS))\n+        fprintf (vect_dump, \"proceeding using word mode.\");\n+    }\n+\n+  /* Worthwhile without SIMD support?  Check only during analysis.  */\n+  if (!VECTOR_MODE_P (TYPE_MODE (vectype))\n+      && vf < vect_min_worthwhile_factor (code)\n+      && !vec_stmt)\n+    {\n+      if (vect_print_dump_info (REPORT_DETAILS))\n+        fprintf (vect_dump, \"not worthwhile without SIMD support.\");\n+      return false;\n+    }\n+\n+  if (!vec_stmt) /* transformation not required.  */\n+    {\n+      STMT_VINFO_TYPE (stmt_info) = shift_vec_info_type;\n+      if (vect_print_dump_info (REPORT_DETAILS))\n+        fprintf (vect_dump, \"=== vectorizable_shift ===\");\n+      vect_model_simple_cost (stmt_info, ncopies, dt, NULL);\n+      return true;\n+    }\n+\n+  /** Transform.  **/\n+\n+  if (vect_print_dump_info (REPORT_DETAILS))\n+    fprintf (vect_dump, \"transform binary/unary operation.\");\n+\n+  /* Handle def.  */\n+  vec_dest = vect_create_destination_var (scalar_dest, vectype);\n+\n+  /* Allocate VECs for vector operands.  In case of SLP, vector operands are\n+     created in the previous stages of the recursion, so no allocation is\n+     needed, except for the case of shift with scalar shift argument.  In that\n+     case we store the scalar operand in VEC_OPRNDS1 for every vector stmt to\n+     be created to vectorize the SLP group, i.e., SLP_NODE->VEC_STMTS_SIZE.\n+     In case of loop-based vectorization we allocate VECs of size 1.  We\n+     allocate VEC_OPRNDS1 only in case of binary operation.  */\n+  if (!slp_node)\n+    {\n+      vec_oprnds0 = VEC_alloc (tree, heap, 1);\n+      vec_oprnds1 = VEC_alloc (tree, heap, 1);\n+    }\n+  else if (scalar_shift_arg)\n+    vec_oprnds1 = VEC_alloc (tree, heap, slp_node->vec_stmts_size);\n+\n+  prev_stmt_info = NULL;\n+  for (j = 0; j < ncopies; j++)\n+    {\n+      /* Handle uses.  */\n+      if (j == 0)\n+        {\n+          if (scalar_shift_arg)\n+            {\n+              /* Vector shl and shr insn patterns can be defined with scalar\n+                 operand 2 (shift operand).  In this case, use constant or loop\n+                 invariant op1 directly, without extending it to vector mode\n+                 first.  */\n+              optab_op2_mode = insn_data[icode].operand[2].mode;\n+              if (!VECTOR_MODE_P (optab_op2_mode))\n+                {\n+                  if (vect_print_dump_info (REPORT_DETAILS))\n+                    fprintf (vect_dump, \"operand 1 using scalar mode.\");\n+                  vec_oprnd1 = op1;\n+                  VEC_quick_push (tree, vec_oprnds1, vec_oprnd1);\n+                  if (slp_node)\n+                    {\n+                      /* Store vec_oprnd1 for every vector stmt to be created\n+                         for SLP_NODE.  We check during the analysis that all\n+                         the shift arguments are the same.\n+                         TODO: Allow different constants for different vector\n+                         stmts generated for an SLP instance.  */\n+                      for (k = 0; k < slp_node->vec_stmts_size - 1; k++)\n+                        VEC_quick_push (tree, vec_oprnds1, vec_oprnd1);\n+                    }\n+                }\n+            }\n+\n+          /* vec_oprnd1 is available if operand 1 should be of a scalar-type\n+             (a special case for certain kind of vector shifts); otherwise,\n+             operand 1 should be of a vector type (the usual case).  */\n+          if (vec_oprnd1)\n+            vect_get_vec_defs (op0, NULL_TREE, stmt, &vec_oprnds0, NULL,\n+                               slp_node);\n+          else\n+            vect_get_vec_defs (op0, op1, stmt, &vec_oprnds0, &vec_oprnds1,\n+                               slp_node);\n+        }\n+      else\n+        vect_get_vec_defs_for_stmt_copy (dt, &vec_oprnds0, &vec_oprnds1);\n+\n+      /* Arguments are ready.  Create the new vector stmt.  */\n+      FOR_EACH_VEC_ELT (tree, vec_oprnds0, i, vop0)\n+        {\n+          vop1 = VEC_index (tree, vec_oprnds1, i);\n+          new_stmt = gimple_build_assign_with_ops (code, vec_dest, vop0, vop1);\n+          new_temp = make_ssa_name (vec_dest, new_stmt);\n+          gimple_assign_set_lhs (new_stmt, new_temp);\n+          vect_finish_stmt_generation (stmt, new_stmt, gsi);\n+          if (slp_node)\n+            VEC_quick_push (gimple, SLP_TREE_VEC_STMTS (slp_node), new_stmt);\n+        }\n+\n+      if (slp_node)\n+        continue;\n+\n+      if (j == 0)\n+        STMT_VINFO_VEC_STMT (stmt_info) = *vec_stmt = new_stmt;\n+      else\n+        STMT_VINFO_RELATED_STMT (prev_stmt_info) = new_stmt;\n+      prev_stmt_info = vinfo_for_stmt (new_stmt);\n+    }\n+\n+  VEC_free (tree, heap, vec_oprnds0);\n+  VEC_free (tree, heap, vec_oprnds1);\n+\n+  return true;\n+}\n+\n+\n /* Function vectorizable_operation.\n \n    Check if STMT performs a binary or unary operation that can be vectorized.\n@@ -2055,7 +2358,6 @@ vectorizable_operation (gimple stmt, gimple_stmt_iterator *gsi,\n   tree vec_dest;\n   tree scalar_dest;\n   tree op0, op1 = NULL;\n-  tree vec_oprnd1 = NULL_TREE;\n   stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n   tree vectype;\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n@@ -2065,7 +2367,6 @@ vectorizable_operation (gimple stmt, gimple_stmt_iterator *gsi,\n   int op_type;\n   optab optab;\n   int icode;\n-  enum machine_mode optab_op2_mode;\n   tree def;\n   gimple def_stmt;\n   enum vect_def_type dt[2] = {vect_unknown_def_type, vect_unknown_def_type};\n@@ -2078,8 +2379,6 @@ vectorizable_operation (gimple stmt, gimple_stmt_iterator *gsi,\n   int j, i;\n   VEC(tree,heap) *vec_oprnds0 = NULL, *vec_oprnds1 = NULL;\n   tree vop0, vop1;\n-  unsigned int k;\n-  bool scalar_shift_arg = false;\n   bb_vec_info bb_vinfo = STMT_VINFO_BB_VINFO (stmt_info);\n   int vf;\n \n@@ -2172,61 +2471,12 @@ vectorizable_operation (gimple stmt, gimple_stmt_iterator *gsi,\n \n   gcc_assert (ncopies >= 1);\n \n-  /* If this is a shift/rotate, determine whether the shift amount is a vector,\n-     or scalar.  If the shift/rotate amount is a vector, use the vector/vector\n-     shift optabs.  */\n+  /* Shifts are handled in vectorizable_shift ().  */\n   if (code == LSHIFT_EXPR || code == RSHIFT_EXPR || code == LROTATE_EXPR\n       || code == RROTATE_EXPR)\n-    {\n-      /* vector shifted by vector */\n-      if (dt[1] == vect_internal_def)\n-\t{\n-\t  optab = optab_for_tree_code (code, vectype, optab_vector);\n-\t  if (vect_print_dump_info (REPORT_DETAILS))\n-\t    fprintf (vect_dump, \"vector/vector shift/rotate found.\");\n-\t}\n+   return false;\n \n-      /* See if the machine has a vector shifted by scalar insn and if not\n-\t then see if it has a vector shifted by vector insn */\n-      else if (dt[1] == vect_constant_def || dt[1] == vect_external_def)\n-\t{\n-\t  optab = optab_for_tree_code (code, vectype, optab_scalar);\n-\t  if (optab\n-\t      && optab_handler (optab, TYPE_MODE (vectype)) != CODE_FOR_nothing)\n-\t    {\n-\t      scalar_shift_arg = true;\n-\t      if (vect_print_dump_info (REPORT_DETAILS))\n-\t\tfprintf (vect_dump, \"vector/scalar shift/rotate found.\");\n-\t    }\n-\t  else\n-\t    {\n-\t      optab = optab_for_tree_code (code, vectype, optab_vector);\n-\t      if (optab\n-\t\t  && (optab_handler (optab, TYPE_MODE (vectype))\n-\t\t      != CODE_FOR_nothing))\n-\t\t{\n-\t\t  if (vect_print_dump_info (REPORT_DETAILS))\n-\t\t    fprintf (vect_dump, \"vector/vector shift/rotate found.\");\n-\n-\t\t  /* Unlike the other binary operators, shifts/rotates have\n-\t\t     the rhs being int, instead of the same type as the lhs,\n-\t\t     so make sure the scalar is the right type if we are\n-\t\t     dealing with vectors of short/char.  */\n-\t\t  if (dt[1] == vect_constant_def)\n-\t\t    op1 = fold_convert (TREE_TYPE (vectype), op1);\n-\t\t}\n-\t    }\n-\t}\n-\n-      else\n-\t{\n-\t  if (vect_print_dump_info (REPORT_DETAILS))\n-\t    fprintf (vect_dump, \"operand mode requires invariant argument.\");\n-\t  return false;\n-\t}\n-    }\n-  else\n-    optab = optab_for_tree_code (code, vectype, optab_default);\n+ optab = optab_for_tree_code (code, vectype, optab_default);\n \n   /* Supportable by target?  */\n   if (!optab)\n@@ -2290,8 +2540,6 @@ vectorizable_operation (gimple stmt, gimple_stmt_iterator *gsi,\n       if (op_type == binary_op)\n         vec_oprnds1 = VEC_alloc (tree, heap, 1);\n     }\n-  else if (scalar_shift_arg)\n-    vec_oprnds1 = VEC_alloc (tree, heap, slp_node->vec_stmts_size);\n \n   /* In case the vectorization factor (VF) is bigger than the number\n      of elements that we can fit in a vectype (nunits), we have to generate\n@@ -2352,36 +2600,7 @@ vectorizable_operation (gimple stmt, gimple_stmt_iterator *gsi,\n       /* Handle uses.  */\n       if (j == 0)\n \t{\n-\t  if (op_type == binary_op && scalar_shift_arg)\n-\t    {\n-\t      /* Vector shl and shr insn patterns can be defined with scalar\n-\t\t operand 2 (shift operand).  In this case, use constant or loop\n-\t\t invariant op1 directly, without extending it to vector mode\n-\t\t first.  */\n-\t      optab_op2_mode = insn_data[icode].operand[2].mode;\n-\t      if (!VECTOR_MODE_P (optab_op2_mode))\n-\t\t{\n-\t\t  if (vect_print_dump_info (REPORT_DETAILS))\n-\t\t    fprintf (vect_dump, \"operand 1 using scalar mode.\");\n-\t\t  vec_oprnd1 = op1;\n-\t\t  VEC_quick_push (tree, vec_oprnds1, vec_oprnd1);\n-\t          if (slp_node)\n-\t            {\n-\t              /* Store vec_oprnd1 for every vector stmt to be created\n-\t                 for SLP_NODE.  We check during the analysis that all\n-                         the shift arguments are the same.\n-\t                 TODO: Allow different constants for different vector\n-\t                 stmts generated for an SLP instance.  */\n-\t              for (k = 0; k < slp_node->vec_stmts_size - 1; k++)\n-\t                VEC_quick_push (tree, vec_oprnds1, vec_oprnd1);\n-\t            }\n-\t\t}\n-\t    }\n-\n-          /* vec_oprnd1 is available if operand 1 should be of a scalar-type\n-             (a special case for certain kind of vector shifts); otherwise,\n-             operand 1 should be of a vector type (the usual case).  */\n-\t  if (op_type == binary_op && !vec_oprnd1)\n+\t  if (op_type == binary_op)\n \t    vect_get_vec_defs (op0, op1, stmt, &vec_oprnds0, &vec_oprnds1,\n \t\t\t       slp_node);\n \t  else\n@@ -2391,7 +2610,7 @@ vectorizable_operation (gimple stmt, gimple_stmt_iterator *gsi,\n       else\n \tvect_get_vec_defs_for_stmt_copy (dt, &vec_oprnds0, &vec_oprnds1);\n \n-      /* Arguments are ready. Create the new vector stmt.  */\n+      /* Arguments are ready.  Create the new vector stmt.  */\n       FOR_EACH_VEC_ELT (tree, vec_oprnds0, i, vop0)\n         {\n \t  vop1 = ((op_type == binary_op)\n@@ -2680,7 +2899,7 @@ vectorizable_type_demotion (gimple stmt, gimple_stmt_iterator *gsi,\n     {\n       /* Handle uses.  */\n       if (slp_node)\n-        vect_get_slp_defs (slp_node, &vec_oprnds0, NULL, -1);\n+        vect_get_slp_defs (op0, NULL_TREE, slp_node, &vec_oprnds0, NULL, -1);\n       else\n         {\n           VEC_free (tree, heap, vec_oprnds0);\n@@ -2690,7 +2909,7 @@ vectorizable_type_demotion (gimple stmt, gimple_stmt_iterator *gsi,\n                                     vect_pow2 (multi_step_cvt) - 1);\n         }\n \n-      /* Arguments are ready. Create the new vector stmts.  */\n+      /* Arguments are ready.  Create the new vector stmts.  */\n       tmp_vec_dsts = VEC_copy (tree, heap, vec_dsts);\n       vect_create_vectorized_demotion_stmts (&vec_oprnds0,\n                                              multi_step_cvt, stmt, tmp_vec_dsts,\n@@ -2991,7 +3210,8 @@ vectorizable_type_promotion (gimple stmt, gimple_stmt_iterator *gsi,\n       if (j == 0)\n         {\n           if (slp_node)\n-              vect_get_slp_defs (slp_node, &vec_oprnds0, &vec_oprnds1, -1);\n+              vect_get_slp_defs (op0, op1, slp_node, &vec_oprnds0,\n+                                 &vec_oprnds1, -1);\n           else\n             {\n               vec_oprnd0 = vect_get_vec_def_for_operand (op0, stmt, NULL);\n@@ -3014,7 +3234,7 @@ vectorizable_type_promotion (gimple stmt, gimple_stmt_iterator *gsi,\n             }\n         }\n \n-      /* Arguments are ready. Create the new vector stmts.  */\n+      /* Arguments are ready.  Create the new vector stmts.  */\n       tmp_vec_dsts = VEC_copy (tree, heap, vec_dsts);\n       vect_create_vectorized_promotion_stmts (&vec_oprnds0, &vec_oprnds1,\n                                               multi_step_cvt, stmt,\n@@ -3290,7 +3510,8 @@ vectorizable_store (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n           if (slp)\n             {\n \t      /* Get vectorized arguments for SLP_NODE.  */\n-              vect_get_slp_defs (slp_node, &vec_oprnds, NULL, -1);\n+              vect_get_slp_defs (NULL_TREE, NULL_TREE, slp_node, &vec_oprnds,\n+                                 NULL, -1);\n \n               vec_oprnd = VEC_index (tree, vec_oprnds, 0);\n             }\n@@ -3402,7 +3623,7 @@ vectorizable_store (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n \t      pi->misalign = DR_MISALIGNMENT (first_dr);\n \t    }\n \n-\t  /* Arguments are ready. Create the new vector stmt.  */\n+\t  /* Arguments are ready.  Create the new vector stmt.  */\n \t  new_stmt = gimple_build_assign (data_ref, vec_oprnd);\n \t  vect_finish_stmt_generation (stmt, new_stmt, gsi);\n \t  mark_symbols_for_renaming (new_stmt);\n@@ -4302,7 +4523,7 @@ vectorizable_condition (gimple stmt, gimple_stmt_iterator *gsi,\n \t\t\t\t\t\t\t    vec_else_clause);\n \t}\n \n-      /* Arguments are ready. Create the new vector stmt.  */\n+      /* Arguments are ready.  Create the new vector stmt.  */\n       vec_compare = build2 (TREE_CODE (cond_expr), vectype,\n \t\t\t    vec_cond_lhs, vec_cond_rhs);\n       vec_cond_expr = build3 (VEC_COND_EXPR, vectype,\n@@ -4431,6 +4652,7 @@ vect_analyze_stmt (gimple stmt, bool *need_to_vectorize, slp_tree node)\n       ok = (vectorizable_type_promotion (stmt, NULL, NULL, NULL)\n             || vectorizable_type_demotion (stmt, NULL, NULL, NULL)\n             || vectorizable_conversion (stmt, NULL, NULL, NULL)\n+            || vectorizable_shift (stmt, NULL, NULL, NULL)\n             || vectorizable_operation (stmt, NULL, NULL, NULL)\n             || vectorizable_assignment (stmt, NULL, NULL, NULL)\n             || vectorizable_load (stmt, NULL, NULL, NULL, NULL)\n@@ -4441,7 +4663,8 @@ vect_analyze_stmt (gimple stmt, bool *need_to_vectorize, slp_tree node)\n     else\n       {\n         if (bb_vinfo)\n-          ok = (vectorizable_operation (stmt, NULL, NULL, node)\n+          ok = (vectorizable_shift (stmt, NULL, NULL, NULL)\n+                || vectorizable_operation (stmt, NULL, NULL, node)\n                 || vectorizable_assignment (stmt, NULL, NULL, node)\n                 || vectorizable_load (stmt, NULL, NULL, node, NULL)\n                 || vectorizable_store (stmt, NULL, NULL, node));\n@@ -4543,6 +4766,11 @@ vect_transform_stmt (gimple stmt, gimple_stmt_iterator *gsi,\n       gcc_assert (done);\n       break;\n \n+    case shift_vec_info_type:\n+      done = vectorizable_shift (stmt, gsi, &vec_stmt, slp_node);\n+      gcc_assert (done);\n+      break;\n+\n     case op_vec_info_type:\n       done = vectorizable_operation (stmt, gsi, &vec_stmt, slp_node);\n       gcc_assert (done);"}, {"sha": "f2a5889ebad15f19016f285d48445a12fa982f8c", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9dc3f7de0d62dfaf42457c92ab5295a03aa1a72b/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9dc3f7de0d62dfaf42457c92ab5295a03aa1a72b/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=9dc3f7de0d62dfaf42457c92ab5295a03aa1a72b", "patch": "@@ -353,6 +353,7 @@ enum stmt_vec_info_type {\n   undef_vec_info_type = 0,\n   load_vec_info_type,\n   store_vec_info_type,\n+  shift_vec_info_type,\n   op_vec_info_type,\n   call_vec_info_type,\n   assignment_vec_info_type,\n@@ -884,7 +885,7 @@ extern void vect_update_slp_costs_according_to_vf (loop_vec_info);\n extern bool vect_analyze_slp (loop_vec_info, bb_vec_info);\n extern void vect_make_slp_decision (loop_vec_info);\n extern void vect_detect_hybrid_slp (loop_vec_info);\n-extern void vect_get_slp_defs (slp_tree, VEC (tree,heap) **,\n+extern void vect_get_slp_defs (tree, tree, slp_tree, VEC (tree,heap) **,\n                                VEC (tree,heap) **, int);\n extern LOC find_bb_location (basic_block);\n extern bb_vec_info vect_slp_analyze_bb (basic_block);"}]}