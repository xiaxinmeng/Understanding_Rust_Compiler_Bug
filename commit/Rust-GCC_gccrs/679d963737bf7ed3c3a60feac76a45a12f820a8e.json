{"sha": "679d963737bf7ed3c3a60feac76a45a12f820a8e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Njc5ZDk2MzczN2JmN2VkM2MzYTYwZmVhYzc2YTQ1YTEyZjgyMGE4ZQ==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2008-04-06T19:37:45Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2008-04-06T19:37:45Z"}, "message": "Index...\n\nIndex: gcc/fortran/trans-stmt.c\n===================================================================\n*** gcc/fortran/trans-stmt.c\t(revision 133728)\n--- gcc/fortran/trans-stmt.c\t(working copy)\n*************** gfc_trans_where_2 (gfc_code * code, tree\n*** 3540,3547 ****\n  \n  /* Translate a simple WHERE construct or statement without dependencies.\n     CBLOCK is the \"then\" clause of the WHERE statement, where CBLOCK->EXPR\n!    is the mask condition, and EBLOCK if non-NULL is the \"else\" clause.\n!    Currently both CBLOCK and EBLOCK are restricted to single assignments.  */\n  \n  static tree\n  gfc_trans_where_3 (gfc_code * cblock, gfc_code * eblock)\n--- 3540,3550 ----\n  \n  /* Translate a simple WHERE construct or statement without dependencies.\n     CBLOCK is the \"then\" clause of the WHERE statement, where CBLOCK->EXPR\n!    is the mask condition, and EBLOCK if non-NULL is the \"then\" clause of\n!    the ELSWHERE.  As required by 7.5.3.2, the WHERE and ELSEWHERE are\n!    executed with separate loops. It should be noted that the mask expression\n!    is evaluated for both loops.  Currently both CBLOCK and EBLOCK are\n!    restricted to single assignments.  */\n  \n  static tree\n  gfc_trans_where_3 (gfc_code * cblock, gfc_code * eblock)\n*************** gfc_trans_where_3 (gfc_code * cblock, gf\n*** 3561,3566 ****\n--- 3564,3570 ----\n    edst = eblock ? eblock->next->expr : NULL;\n    esrc = eblock ? eblock->next->expr2 : NULL;\n  \n+   /*---------------First do the WHERE part.----------------*/\n    gfc_start_block (&block);\n    gfc_init_loopinfo (&loop);\n  \n*************** gfc_trans_where_3 (gfc_code * cblock, gf\n*** 3584,3619 ****\n    gfc_add_ss_to_loop (&loop, tdss);\n    gfc_add_ss_to_loop (&loop, tsss);\n  \n-   if (eblock)\n-     {\n-       /* Handle the else clause.  */\n-       gfc_init_se (&edse, NULL);\n-       gfc_init_se (&esse, NULL);\n-       edss = gfc_walk_expr (edst);\n-       esss = gfc_walk_expr (esrc);\n-       if (esss == gfc_ss_terminator)\n- \t{\n- \t  esss = gfc_get_ss ();\n- \t  esss->next = gfc_ss_terminator;\n- \t  esss->type = GFC_SS_SCALAR;\n- \t  esss->expr = esrc;\n- \t}\n-       gfc_add_ss_to_loop (&loop, edss);\n-       gfc_add_ss_to_loop (&loop, esss);\n-     }\n- \n    gfc_conv_ss_startstride (&loop);\n    gfc_conv_loop_setup (&loop);\n  \n    gfc_mark_ss_chain_used (css, 1);\n    gfc_mark_ss_chain_used (tdss, 1);\n    gfc_mark_ss_chain_used (tsss, 1);\n!   if (eblock)\n!     {\n!       gfc_mark_ss_chain_used (edss, 1);\n!       gfc_mark_ss_chain_used (esss, 1);\n!     }\n! \n    gfc_start_scalarized_body (&loop, &body);\n  \n    gfc_copy_loopinfo_to_se (&cse, &loop);\n--- 3588,3600 ----\n    gfc_add_ss_to_loop (&loop, tdss);\n    gfc_add_ss_to_loop (&loop, tsss);\n  \n    gfc_conv_ss_startstride (&loop);\n    gfc_conv_loop_setup (&loop);\n  \n    gfc_mark_ss_chain_used (css, 1);\n    gfc_mark_ss_chain_used (tdss, 1);\n    gfc_mark_ss_chain_used (tsss, 1);\n!  \n    gfc_start_scalarized_body (&loop, &body);\n  \n    gfc_copy_loopinfo_to_se (&cse, &loop);\n*************** gfc_trans_where_3 (gfc_code * cblock, gf\n*** 3622,3637 ****\n    cse.ss = css;\n    tdse.ss = tdss;\n    tsse.ss = tsss;\n-   if (eblock)\n-     {\n-       gfc_copy_loopinfo_to_se (&edse, &loop);\n-       gfc_copy_loopinfo_to_se (&esse, &loop);\n-       edse.ss = edss;\n-       esse.ss = esss;\n-     }\n  \n    gfc_conv_expr (&cse, cond);\n!   gfc_add_block_to_block (&body, &cse.pre);\n    cexpr = cse.expr;\n  \n    gfc_conv_expr (&tsse, tsrc);\n--- 3603,3611 ----\n    cse.ss = css;\n    tdse.ss = tdss;\n    tsse.ss = tsss;\n  \n    gfc_conv_expr (&cse, cond);\n!   gfc_add_block_to_block (&block, &cse.pre);\n    cexpr = cse.expr;\n  \n    gfc_conv_expr (&tsse, tsrc);\n*************** gfc_trans_where_3 (gfc_code * cblock, gf\n*** 3643,3650 ****\n--- 3617,3678 ----\n    else\n      gfc_conv_expr (&tdse, tdst);\n  \n+   /* Make the assignment on condition 'cond'.  */\n+   tstmt = gfc_trans_scalar_assign (&tdse, &tsse, tdst->ts, false, false);  \n+   tmp = build3_v (COND_EXPR, cexpr, tstmt, build_empty_stmt ());\n+   gfc_add_expr_to_block (&body, tmp);\n+   gfc_add_block_to_block (&body, &cse.post);\n+ \n+   gfc_trans_scalarizing_loops (&loop, &body);\n+   gfc_add_block_to_block (&block, &loop.pre);\n+   gfc_add_block_to_block (&block, &loop.post);\n+   gfc_cleanup_loop (&loop);\n+ \n+ /*---------------Now do the ELSEWHERE.--------------*/\n    if (eblock)\n      {\n+       gfc_init_loopinfo (&loop);\n+  \n+       /* Handle the condition.  */\n+       gfc_init_se (&cse, NULL);\n+       css = gfc_walk_expr (cond);\n+       gfc_add_ss_to_loop (&loop, css);\n+ \n+       /* Handle the then-clause.  */\n+       gfc_init_se (&edse, NULL);\n+       gfc_init_se (&esse, NULL);\n+       edss = gfc_walk_expr (edst);\n+       esss = gfc_walk_expr (esrc);\n+       if (esss == gfc_ss_terminator)\n+ \t{\n+ \t  esss = gfc_get_ss ();\n+ \t  esss->next = gfc_ss_terminator;\n+ \t  esss->type = GFC_SS_SCALAR;\n+ \t  esss->expr = esrc;\n+ \t}\n+       gfc_add_ss_to_loop (&loop, edss);\n+       gfc_add_ss_to_loop (&loop, esss);\n+ \n+       gfc_conv_ss_startstride (&loop);\n+       gfc_conv_loop_setup (&loop);\n+ \n+       gfc_mark_ss_chain_used (css, 1);\n+       gfc_mark_ss_chain_used (edss, 1);\n+       gfc_mark_ss_chain_used (esss, 1);\n+ \n+       gfc_start_scalarized_body (&loop, &body);\n+ \n+       gfc_copy_loopinfo_to_se (&cse, &loop);\n+       gfc_copy_loopinfo_to_se (&edse, &loop);\n+       gfc_copy_loopinfo_to_se (&esse, &loop);\n+       cse.ss = css;\n+       edse.ss = edss;\n+       esse.ss = esss;\n+ \n+       gfc_conv_expr (&cse, cond);\n+       gfc_add_block_to_block (&body, &cse.pre);\n+       cexpr = cse.expr;\n+ \n        gfc_conv_expr (&esse, esrc);\n        if (edss != gfc_ss_terminator && loop.temp_ss != NULL)\n          {\n*************** gfc_trans_where_3 (gfc_code * cblock, gf\n*** 3653,3672 ****\n          }\n        else\n          gfc_conv_expr (&edse, edst);\n      }\n  \n-   tstmt = gfc_trans_scalar_assign (&tdse, &tsse, tdst->ts, false, false);\n-   estmt = eblock ? gfc_trans_scalar_assign (&edse, &esse, edst->ts, false, false)\n- \t\t : build_empty_stmt ();\n-   tmp = build3_v (COND_EXPR, cexpr, tstmt, estmt);\n-   gfc_add_expr_to_block (&body, tmp);\n-   gfc_add_block_to_block (&body, &cse.post);\n- \n-   gfc_trans_scalarizing_loops (&loop, &body);\n-   gfc_add_block_to_block (&block, &loop.pre);\n-   gfc_add_block_to_block (&block, &loop.post);\n-   gfc_cleanup_loop (&loop);\n- \n    return gfc_finish_block (&block);\n  }\n  \n--- 3681,3700 ----\n          }\n        else\n          gfc_conv_expr (&edse, edst);\n+  \n+       /* Make the assignment on condition 'NOT.cond'.  */\n+       estmt = gfc_trans_scalar_assign (&edse, &esse, edst->ts, false, false);\n+       cexpr = fold_build1 (TRUTH_NOT_EXPR, boolean_type_node, cexpr);\n+       tmp = build3_v (COND_EXPR, cexpr, estmt, build_empty_stmt ());\n+       gfc_add_expr_to_block (&body, tmp);\n+       gfc_add_block_to_block (&body, &cse.post);\n+ \n+       gfc_trans_scalarizing_loops (&loop, &body);\n+       gfc_add_block_to_block (&block, &loop.pre);\n+       gfc_add_block_to_block (&block, &loop.post);\n+       gfc_cleanup_loop (&loop);\n      }\n  \n    return gfc_finish_block (&block);\n  }\n  \n*************** gfc_trans_where (gfc_code * code)\n*** 3698,3708 ****\n  \t\t\t\t\tcblock->next->expr2, 0))\n  \t    return gfc_trans_where_3 (cblock, NULL);\n  \t}\n        else if (!eblock->expr\n  \t       && !eblock->block\n  \t       && eblock->next\n  \t       && eblock->next->op == EXEC_ASSIGN\n! \t       && !eblock->next->next)\n  \t{\n            /* A simple \"WHERE (cond) x1 = y1 ELSEWHERE x2 = y2 ENDWHERE\"\n  \t     block is dependence free if cond is not dependent on writes\n--- 3726,3739 ----\n  \t\t\t\t\tcblock->next->expr2, 0))\n  \t    return gfc_trans_where_3 (cblock, NULL);\n  \t}\n+       /* Since gfc_trans_where_3 evaluates the condition expression\n+ \t twice, do not use it if the condition is not a variable.  */\n        else if (!eblock->expr\n  \t       && !eblock->block\n  \t       && eblock->next\n  \t       && eblock->next->op == EXEC_ASSIGN\n! \t       && !eblock->next->next\n! \t       && cblock->expr->expr_type == EXPR_VARIABLE)\n  \t{\n            /* A simple \"WHERE (cond) x1 = y1 ELSEWHERE x2 = y2 ENDWHERE\"\n  \t     block is dependence free if cond is not dependent on writes\nIndex: gcc/testsuite/gfortran.dg/where_1.f90\n===================================================================\n*** gcc/testsuite/gfortran.dg/where_1.f90\t(revision 0)\n--- gcc/testsuite/gfortran.dg/where_1.f90\t(revision 0)\n***************\n*** 0 ****\n--- 1,61 ----\n+ ! { dg-do run }\n+ ! { dg-options \"-fdump-tree-original\" }\n+ ! Tests the fix for PR35759, in which the simple WHERE was logically\n+ ! wrong.  7.5.3.2 requires that the WHERE and ELSEWHERE are execute in\n+ ! separate loops, whereas gfortran was implementing them as a single\n+ ! loop with an 'if' and 'else'.  Since the condition expression is\n+ ! evaluated twice with the fix, the use of anything other than a\n+ ! variable or parameter array for the condition will trigger the more\n+ ! comprehensive implementation of WHERE.  This is checked by the\n+ ! check of the declaration of temp.15 in the 'original' code.\n+ !\n+ ! Contributed by Dick Hendrickson <dick.hendrickson@gmail.com>\n+ !\n+ program RG0023\n+ \n+   integer UDA1L(6)\n+   integer ::  UDA1R(6), expected(6) = (/2,0,5,0,3,0/)\n+   LOGICAL LDA(5)\n+   LOGICAL, parameter :: PDA(5) = (/ (i/2*2 .ne. I, i=1,5) /)\n+ \n+   UDA1L(1:6) = 0\n+   uda1r = (/1,2,3,4,5,6/)\n+   lda = pda\n+ \n+   WHERE (lda)                !          expected\n+     UDA1L(1:5) = UDA1R(2:6)  !  uda1l = 2,0,4,0,6,0\n+   ELSEWHERE\n+     UDA1L(2:6) = UDA1R(6:2:-1) !uda1l = 2,0,5,0,3,0\n+   ENDWHERE\n+ \n+   if (any (uda1l /= expected)) call abort ()\n+ \n+   uda1l = 0\n+ \n+   WHERE (pda)                !          expected\n+     UDA1L(1:5) = UDA1R(2:6)  !  uda1l = 2,0,4,0,6,0\n+   ELSEWHERE\n+     UDA1L(2:6) = UDA1R(6:2:-1) !uda1l = 2,0,5,0,3,0\n+   ENDWHERE\n+ \n+   if (any (uda1l /= expected)) call abort ()\n+  \n+   uda1l = 0\n+ \n+   WHERE (lfoo ())            !          expected\n+     UDA1L(1:5) = UDA1R(2:6)  !  uda1l = 2,0,4,0,6,0\n+   ELSEWHERE\n+     UDA1L(2:6) = UDA1R(6:2:-1) !uda1l = 2,0,5,0,3,0\n+   ENDWHERE\n+ \n+   if (any (uda1l /= expected)) call abort ()\n+  \n+ contains\n+ \n+   function lfoo () result (ltmp)\n+     logical ltmp(5)\n+     ltmp = lda\n+   end function lfoo\n+ END\n+ ! { dg-final { scan-tree-dump-times \"temp.18\\\\\\[5\\\\\\]\" 1 \"original\" } }\n+ ! { dg-final { cleanup-tree-dump \"original\" } }\n\nFrom-SVN: r133965", "tree": {"sha": "bee4083fe3c3fd26b9b0ecc1abca11cc1f045d16", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bee4083fe3c3fd26b9b0ecc1abca11cc1f045d16"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/679d963737bf7ed3c3a60feac76a45a12f820a8e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/679d963737bf7ed3c3a60feac76a45a12f820a8e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/679d963737bf7ed3c3a60feac76a45a12f820a8e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/679d963737bf7ed3c3a60feac76a45a12f820a8e/comments", "author": null, "committer": null, "parents": [{"sha": "9b8d1901f8b386d1b9cc6b1d77b4d45f228b14e0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b8d1901f8b386d1b9cc6b1d77b4d45f228b14e0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9b8d1901f8b386d1b9cc6b1d77b4d45f228b14e0"}], "stats": {"total": 87, "additions": 69, "deletions": 18}, "files": [{"sha": "12afa21286b5c13fff690f9e2bb88075d367759f", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/679d963737bf7ed3c3a60feac76a45a12f820a8e/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/679d963737bf7ed3c3a60feac76a45a12f820a8e/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=679d963737bf7ed3c3a60feac76a45a12f820a8e", "patch": "@@ -1,3 +1,11 @@\n+2008-04-06  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/35780\n+\t* expr.c (scalarize_intrinsic_call): Identify which argument is\n+\tan array and use that as the template.\n+\t(check_init_expr): Remove tests that first argument is an array\n+\tin the call to scalarize_intrinsic_call.\n+\n 2008-04-06  Tobias Schl\ufffdter  <tobi@gcc.gnu.org>\n \n \tPR fortran/35832"}, {"sha": "12e88a07420ad2b68aeb64c973508bac016fe926", "filename": "gcc/fortran/expr.c", "status": "modified", "additions": 30, "deletions": 18, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/679d963737bf7ed3c3a60feac76a45a12f820a8e/gcc%2Ffortran%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/679d963737bf7ed3c3a60feac76a45a12f820a8e/gcc%2Ffortran%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fexpr.c?ref=679d963737bf7ed3c3a60feac76a45a12f820a8e", "patch": "@@ -1702,17 +1702,34 @@ scalarize_intrinsic_call (gfc_expr *e)\n   gfc_actual_arglist *a, *b;\n   gfc_constructor *args[5], *ctor, *new_ctor;\n   gfc_expr *expr, *old;\n-  int n, i, rank[5];\n+  int n, i, rank[5], array_arg;\n \n   old = gfc_copy_expr (e);\n \n-/* Assume that the old expression carries the type information and\n-   that the first arg carries all the shape information.  */\n-  expr = gfc_copy_expr (old->value.function.actual->expr);\n+\n+  /* Find which, if any, arguments are arrays.  Assume that the old\n+     expression carries the type information and that the first arg\n+     that is an array expression carries all the shape information.*/\n+  n = array_arg = 0;\n+  a = old->value.function.actual;\n+  for (; a; a = a->next)\n+    {\n+      n++;\n+      if (a->expr->expr_type != EXPR_ARRAY)\n+\tcontinue;\n+      array_arg = n;\n+      expr = gfc_copy_expr (a->expr);\n+      break;\n+    }\n+\n+  if (!array_arg)\n+    goto cleanup;\n+\n   gfc_free_constructor (expr->value.constructor);\n   expr->value.constructor = NULL;\n \n   expr->ts = old->ts;\n+  expr->where = old->where;\n   expr->expr_type = EXPR_ARRAY;\n \n   /* Copy the array argument constructors into an array, with nulls\n@@ -1745,14 +1762,11 @@ scalarize_intrinsic_call (gfc_expr *e)\n       n++;\n     }\n \n-  for (i = 1; i < n; i++)\n-    if (rank[i] && rank[i] != rank[0])\n-      goto compliance;\n \n   /* Using the first argument as the master, step through the array\n      calling the function for each element and advancing the array\n      constructors together.  */\n-  ctor = args[0];\n+  ctor = args[array_arg - 1];\n   new_ctor = NULL;\n   for (; ctor; ctor = ctor->next)\n     {\n@@ -1786,17 +1800,18 @@ scalarize_intrinsic_call (gfc_expr *e)\n \t      b = b->next;\n \t    }\n \n-\t  /* Simplify the function calls.  */\n-\t  if (gfc_simplify_expr (new_ctor->expr, 0) == FAILURE)\n-\t    goto cleanup;\n+\t  /* Simplify the function calls.  If the simplification fails, the\n+\t     error will be flagged up down-stream or the library will deal\n+\t     with it.  */\n+\t  gfc_simplify_expr (new_ctor->expr, 0);\n \n \t  for (i = 0; i < n; i++)\n \t    if (args[i])\n \t      args[i] = args[i]->next;\n \n \t  for (i = 1; i < n; i++)\n-\t    if (rank[i] && ((args[i] != NULL && args[0] == NULL)\n-\t\t\t || (args[i] == NULL && args[0] != NULL)))\n+\t    if (rank[i] && ((args[i] != NULL && args[array_arg - 1] == NULL)\n+\t\t\t || (args[i] == NULL && args[array_arg - 1] != NULL)))\n \t      goto compliance;\n     }\n \n@@ -2187,11 +2202,8 @@ check_init_expr (gfc_expr *e)\n \t     array argument.  */\n \t  isym = gfc_find_function (e->symtree->n.sym->name);\n \t  if (isym && isym->elemental\n-\t      && e->value.function.actual->expr->expr_type == EXPR_ARRAY)\n-\t    {\n-\t\tif ((t = scalarize_intrinsic_call (e)) == SUCCESS)\n-\t\tbreak;\n-\t    }\n+\t\t&& (t = scalarize_intrinsic_call (e)) == SUCCESS)\n+\t    break;\n \t}\n \n       if (m == MATCH_YES)"}, {"sha": "b5b21556f043b235c707f6a5ba9bf12ec295434c", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/679d963737bf7ed3c3a60feac76a45a12f820a8e/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/679d963737bf7ed3c3a60feac76a45a12f820a8e/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=679d963737bf7ed3c3a60feac76a45a12f820a8e", "patch": "@@ -1,3 +1,8 @@\n+2008-04-06  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/35780\n+\t* gfortran.dg/simplify_argN_1.f90: New test.\n+\n 2008-04-06  Tobias Schl\ufffdter  <tobi@gcc.gnu.org>\n \n \tPR fortran/35832"}, {"sha": "933b1f32af7a1e1cad72e72d1f0878bced097185", "filename": "gcc/testsuite/gfortran.dg/simplify_argN_1.f90", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/679d963737bf7ed3c3a60feac76a45a12f820a8e/gcc%2Ftestsuite%2Fgfortran.dg%2Fsimplify_argN_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/679d963737bf7ed3c3a60feac76a45a12f820a8e/gcc%2Ftestsuite%2Fgfortran.dg%2Fsimplify_argN_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fsimplify_argN_1.f90?ref=679d963737bf7ed3c3a60feac76a45a12f820a8e", "patch": "@@ -0,0 +1,26 @@\n+! { dg-do run }\n+! Tests the fix for PR35780, in which the assignment for C was not\n+! scalarized in expr.c.\n+!\n+! Contributed by Dick Hendrickson <dick.hendrickson@gmail.com>\n+!\n+MODULE MODS\n+  integer, parameter :: N = 10\n+  INTEGER, PARAMETER, DIMENSION(N) ::  A = [(i, i = 1, N)]\n+  INTEGER, PARAMETER, DIMENSION(N) ::  B = [(i - 5, i = 1, N)]\n+  INTEGER, PARAMETER, DIMENSION(N)  :: C = ISHFTC(3, B, 5)   !ICE\n+  INTEGER, PARAMETER, DIMENSION(N)  :: D = ISHFTC(A, 3, 5)   !  OK\n+  INTEGER, PARAMETER, DIMENSION(N)  :: E = ISHFTC(A, B, 5)   !  OK\n+\n+END MODULE MODS\n+\n+  use mods\n+  integer, dimension(N) :: X = A\n+  integer, dimension(N) :: Y = B\n+\n+! Check the simplifed expressions against the library\n+  if (any (ISHFTC(3, Y, 5) /= C)) call abort ()\n+  if (any (ISHFTC(X, 3, 5) /= D)) call abort ()\n+  if (any (ISHFTC(X, Y, 5) /= E)) call abort ()\n+end\n+! { dg-final { cleanup-modules \"mods\" } }"}]}