{"sha": "b20996ff13afd304d44aafd0966501cc4bd10b97", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjIwOTk2ZmYxM2FmZDMwNGQ0NGFhZmQwOTY2NTAxY2M0YmQxMGI5Nw==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2009-10-07T09:01:16Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2009-10-07T09:01:16Z"}, "message": "lto-symtab.c (lto_cgraph_replace_node): Assert that inline clones has no address taken.\n\n\n\t* lto-symtab.c (lto_cgraph_replace_node): Assert that inline clones has\n\tno address taken.\n\t* cgraph.c (cgraph_mark_needed_node): Assert that inline clones are\n\tnever needed.\n\t(cgraph_clone_node): Clear externally_visible flag for clones.\n\t* cgraph.h (cgraph_only_called_directly_p,\n\tcgraph_can_remove_if_no_direct_calls_p): New predicates.\n\t* tree-pass.h (pass_ipa_whole_program_visibility): Declare.\n\t* ipa-cp.c (ipcp_cloning_candidate_p): Use new predicate.\n\t(ipcp_initialize_node_lattices, ipcp_estimate_growth,\n\tipcp_insert_stage): Likwise.\n\t* cgraphunit.c (cgraph_decide_is_function_needed): Do not compute\n\texternally_visible flag.\n\t(verify_cgraph_node): Verify that inline clones look right.\n\t(process_function_and_variable_attributes): Do not set\n\texternally_visible flags.\n\t(ipa_passes): Avoid executing small_ipa_passes at LTO stage; they've\n\tbeen already run.\n\t* lto-cgraph.c (lto_output_node): Assert that inline clones are not\n\tboundaries.\n\t* ipa-inline.c (cgraph_clone_inlined_nodes): Use new predicates;\n\tclear externally_visible when turning into inline clones\n\t(cgraph_mark_inline_edge): Use new predicates.\n\t(cgraph_estimate_growth): Likewise.\n\t(cgraph_decide_inlining): Likewise.\n\t* ipa.c (cgraph_postorder): Likewise.\n\t(cgraph_remove_unreachable_nodes): Likewise; sanity check\n\tthat inline clones are not needed.\n\t(cgraph_externally_visible_p): New predicate.\n\t(function_and_variable_visibility): Add whole_program parameter;\n\talways set externally_visible flag; handle COMDAT function\n\tprivatization.\n\t(local_function_and_variable_visibility): New function.\n\t(gate_whole_program_function_and_variable_visibility): New function.\n\t(whole_program_function_and_variable_visibility): New function.\n\t(pass_ipa_whole_program_visibility): New function.\n\t* passes.c  (init_optimization_passes): Add whole program visibility\n\tpass.\n\t(do_per_function_toporder, function_called_by_processed_nodes_p): Do\n\tnot care about needed/reachable flags.\n\t* varpool.c: Include flags.h\n\t(decide_is_variable_needed): When doing LTO assume whole-program mode.\n\t(varpool_finalize_decl): When we are in LTO read-back, all variables\n\tare analyzed.\n\t(varpool_analyze_pending_decls): Skip analyzis of analyzed vars.\n\n\t* lto/lto.c (read_cgraph_and_symbols): Mark functions neccesary only at\n\tltrans stage; explain why this is needed and should not.\n\nFrom-SVN: r152520", "tree": {"sha": "6ff88658df2366f15ab2403c0f6349c01d7b3ee5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6ff88658df2366f15ab2403c0f6349c01d7b3ee5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b20996ff13afd304d44aafd0966501cc4bd10b97", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b20996ff13afd304d44aafd0966501cc4bd10b97", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b20996ff13afd304d44aafd0966501cc4bd10b97", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b20996ff13afd304d44aafd0966501cc4bd10b97/comments", "author": null, "committer": null, "parents": [{"sha": "d2d9ce5edca697ebebf9c921a434b07777064796", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d2d9ce5edca697ebebf9c921a434b07777064796", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d2d9ce5edca697ebebf9c921a434b07777064796"}], "stats": {"total": 327, "additions": 269, "deletions": 58}, "files": [{"sha": "3a8ac5440a8dc079a1bd5a0b2d363af18b426bef", "filename": "gcc/ChangeLog", "status": "modified", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b20996ff13afd304d44aafd0966501cc4bd10b97/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b20996ff13afd304d44aafd0966501cc4bd10b97/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b20996ff13afd304d44aafd0966501cc4bd10b97", "patch": "@@ -1,3 +1,51 @@\n+2009-10-07  Jan Hubicka  <jh@suse.cz>\n+\n+\t* lto-symtab.c (lto_cgraph_replace_node): Assert that inline clones has\n+\tno address taken.\n+\t* cgraph.c (cgraph_mark_needed_node): Assert that inline clones are\n+\tnever needed.\n+\t(cgraph_clone_node): Clear externally_visible flag for clones.\n+\t* cgraph.h (cgraph_only_called_directly_p,\n+\tcgraph_can_remove_if_no_direct_calls_p): New predicates.\n+\t* tree-pass.h (pass_ipa_whole_program_visibility): Declare.\n+\t* ipa-cp.c (ipcp_cloning_candidate_p): Use new predicate.\n+\t(ipcp_initialize_node_lattices, ipcp_estimate_growth,\n+\tipcp_insert_stage): Likwise.\n+\t* cgraphunit.c (cgraph_decide_is_function_needed): Do not compute\n+\texternally_visible flag.\n+\t(verify_cgraph_node): Verify that inline clones look right.\n+\t(process_function_and_variable_attributes): Do not set\n+\texternally_visible flags.\n+\t(ipa_passes): Avoid executing small_ipa_passes at LTO stage; they've\n+\tbeen already run.\n+\t* lto-cgraph.c (lto_output_node): Assert that inline clones are not\n+\tboundaries.\n+\t* ipa-inline.c (cgraph_clone_inlined_nodes): Use new predicates;\n+\tclear externally_visible when turning into inline clones\n+\t(cgraph_mark_inline_edge): Use new predicates.\n+\t(cgraph_estimate_growth): Likewise.\n+\t(cgraph_decide_inlining): Likewise.\n+\t* ipa.c (cgraph_postorder): Likewise.\n+\t(cgraph_remove_unreachable_nodes): Likewise; sanity check\n+\tthat inline clones are not needed.\n+\t(cgraph_externally_visible_p): New predicate.\n+\t(function_and_variable_visibility): Add whole_program parameter;\n+\talways set externally_visible flag; handle COMDAT function\n+\tprivatization.\n+\t(local_function_and_variable_visibility): New function.\n+\t(gate_whole_program_function_and_variable_visibility): New function.\n+\t(whole_program_function_and_variable_visibility): New function.\n+\t(pass_ipa_whole_program_visibility): New function.\n+\t* passes.c  (init_optimization_passes): Add whole program visibility\n+\tpass.\n+\t(do_per_function_toporder, function_called_by_processed_nodes_p): Do\n+\tnot care about needed/reachable flags.\n+\t* varpool.c: Include flags.h\n+\t(decide_is_variable_needed): When doing LTO assume whole-program mode.\n+\t(varpool_finalize_decl): When we are in LTO read-back, all variables\n+\tare analyzed.\n+\t(varpool_analyze_pending_decls): Skip analyzis of analyzed vars.\n+\n 2009-10-07  Andreas Krebbel  <Andreas.Krebbel@de.ibm.com>\n \n \t* config/s390/tpf.h (TARGET_DEFAULT): Remove MASK_HARD_FLOAT and"}, {"sha": "bc8f1015e62f954c0bb3dc1c0f48336856d55e12", "filename": "gcc/cgraph.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b20996ff13afd304d44aafd0966501cc4bd10b97/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b20996ff13afd304d44aafd0966501cc4bd10b97/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=b20996ff13afd304d44aafd0966501cc4bd10b97", "patch": "@@ -1359,6 +1359,7 @@ void\n cgraph_mark_needed_node (struct cgraph_node *node)\n {\n   node->needed = 1;\n+  gcc_assert (!node->global.inlined_to);\n   cgraph_mark_reachable_node (node);\n }\n \n@@ -1682,6 +1683,7 @@ cgraph_clone_node (struct cgraph_node *n, gcov_type count, int freq,\n     }\n   new_node->analyzed = n->analyzed;\n   new_node->local = n->local;\n+  new_node->local.externally_visible = false;\n   new_node->global = n->global;\n   new_node->rtl = n->rtl;\n   new_node->count = count;"}, {"sha": "438cd1e6fae0f6ba7a6ef01244d67118072926ce", "filename": "gcc/cgraph.h", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b20996ff13afd304d44aafd0966501cc4bd10b97/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b20996ff13afd304d44aafd0966501cc4bd10b97/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=b20996ff13afd304d44aafd0966501cc4bd10b97", "patch": "@@ -658,6 +658,26 @@ struct GTY(()) constant_descriptor_tree {\n   hashval_t hash;\n };\n \n+/* Return true when function NODE is only called directly.\n+   i.e. it is not externally visible, address was not taken and\n+   it is not used in any other non-standard way.  */\n+\n+static inline bool\n+cgraph_only_called_directly_p (struct cgraph_node *node)\n+{\n+  return !node->needed && !node->local.externally_visible;\n+}\n+\n+/* Return true when function NODE can be removed from callgraph\n+   if all direct calls are eliminated.  */\n+\n+static inline bool\n+cgraph_can_remove_if_no_direct_calls_p (struct cgraph_node *node)\n+{\n+  return (!node->needed\n+  \t  && (DECL_COMDAT (node->decl) || !node->local.externally_visible));\n+}\n+\n /* Constant pool accessor function.  */\n htab_t constant_pool_htab (void);\n "}, {"sha": "9a97bef296252ee0a5ea42ef5777a59381be63a7", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 25, "deletions": 21, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b20996ff13afd304d44aafd0966501cc4bd10b97/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b20996ff13afd304d44aafd0966501cc4bd10b97/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=b20996ff13afd304d44aafd0966501cc4bd10b97", "patch": "@@ -316,13 +316,6 @@ cgraph_build_cdtor_fns (void)\n bool\n cgraph_decide_is_function_needed (struct cgraph_node *node, tree decl)\n {\n-  if (MAIN_NAME_P (DECL_NAME (decl))\n-      && TREE_PUBLIC (decl))\n-    {\n-      node->local.externally_visible = true;\n-      return true;\n-    }\n-\n   /* If the user told us it is used, then it must be so.  */\n   if (node->local.externally_visible)\n     return true;\n@@ -360,7 +353,9 @@ cgraph_decide_is_function_needed (struct cgraph_node *node, tree decl)\n \t|| (!optimize && !node->local.disregard_inline_limits\n \t    && !DECL_DECLARED_INLINE_P (decl)\n \t    && !node->origin))\n-      && !flag_whole_program)\n+       && !flag_whole_program\n+       && !flag_lto\n+       && !flag_whopr)\n       && !DECL_COMDAT (decl) && !DECL_EXTERNAL (decl))\n     return true;\n \n@@ -593,6 +588,21 @@ verify_cgraph_node (struct cgraph_node *node)\n       error (\"Execution count is negative\");\n       error_found = true;\n     }\n+  if (node->global.inlined_to && node->local.externally_visible)\n+    {\n+      error (\"Externally visible inline clone\");\n+      error_found = true;\n+    }\n+  if (node->global.inlined_to && node->address_taken)\n+    {\n+      error (\"Inline clone with address taken\");\n+      error_found = true;\n+    }\n+  if (node->global.inlined_to && node->needed)\n+    {\n+      error (\"Inline clone is needed\");\n+      error_found = true;\n+    }\n   for (e = node->callers; e; e = e->next_caller)\n     {\n       if (e->count < 0)\n@@ -864,12 +874,8 @@ process_function_and_variable_attributes (struct cgraph_node *first,\n \t    warning_at (DECL_SOURCE_LOCATION (node->decl), OPT_Wattributes,\n \t\t\t\"%<externally_visible%>\"\n \t\t\t\" attribute have effect only on public objects\");\n-\t  else\n-\t    {\n-\t      if (node->local.finalized)\n-\t\tcgraph_mark_needed_node (node);\n-\t      node->local.externally_visible = true;\n-\t    }\n+\t  else if (node->local.finalized)\n+\t     cgraph_mark_needed_node (node);\n \t}\n     }\n   for (vnode = varpool_nodes; vnode != first_var; vnode = vnode->next)\n@@ -887,12 +893,8 @@ process_function_and_variable_attributes (struct cgraph_node *first,\n \t    warning_at (DECL_SOURCE_LOCATION (vnode->decl), OPT_Wattributes,\n \t\t\t\"%<externally_visible%>\"\n \t\t\t\" attribute have effect only on public objects\");\n-\t  else\n-\t    {\n-\t      if (vnode->finalized)\n-\t\tvarpool_mark_needed_node (vnode);\n-\t      vnode->externally_visible = true;\n-\t    }\n+\t  else if (vnode->finalized)\n+\t    varpool_mark_needed_node (vnode);\n \t}\n     }\n }\n@@ -1355,7 +1357,9 @@ ipa_passes (void)\n   current_function_decl = NULL;\n   gimple_register_cfg_hooks ();\n   bitmap_obstack_initialize (NULL);\n-  execute_ipa_pass_list (all_small_ipa_passes);\n+\n+  if (!in_lto_p)\n+    execute_ipa_pass_list (all_small_ipa_passes);\n \n   /* If pass_all_early_optimizations was not scheduled, the state of\n      the cgraph will not be properly updated.  Update it now.  */"}, {"sha": "59a051915f6d1391e72bb644e2679616733121c2", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b20996ff13afd304d44aafd0966501cc4bd10b97/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b20996ff13afd304d44aafd0966501cc4bd10b97/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=b20996ff13afd304d44aafd0966501cc4bd10b97", "patch": "@@ -442,7 +442,7 @@ ipcp_cloning_candidate_p (struct cgraph_node *node)\n      FIXME: in future we should clone such functions when they are called with\n      different constants, but current ipcp implementation is not good on this.\n      */\n-  if (!node->needed || !node->analyzed)\n+  if (cgraph_only_called_directly_p (node) || !node->analyzed)\n     return false;\n \n   if (cgraph_function_body_availability (node) <= AVAIL_OVERWRITABLE)\n@@ -536,7 +536,7 @@ ipcp_initialize_node_lattices (struct cgraph_node *node)\n \n   if (ipa_is_called_with_var_arguments (info))\n     type = IPA_BOTTOM;\n-  else if (!node->needed)\n+  else if (cgraph_only_called_directly_p (node))\n     type = IPA_TOP;\n   /* When cloning is allowed, we can assume that externally visible functions\n      are not called.  We will compensate this by cloning later.  */\n@@ -954,7 +954,7 @@ ipcp_estimate_growth (struct cgraph_node *node)\n   struct cgraph_edge *cs;\n   int redirectable_node_callers = 0;\n   int removable_args = 0;\n-  bool need_original = node->needed;\n+  bool need_original = !cgraph_only_called_directly_p (node);\n   struct ipa_node_params *info;\n   int i, count;\n   int growth;\n@@ -1143,7 +1143,7 @@ ipcp_insert_stage (void)\n       for (cs = node->callers; cs != NULL; cs = cs->next_caller)\n \tif (cs->caller == node || ipcp_need_redirect_p (cs))\n \t  break;\n-      if (!cs && !node->needed)\n+      if (!cs && cgraph_only_called_directly_p (node))\n \tbitmap_set_bit (dead_nodes, node->uid);\n \n       info = IPA_NODE_REF (node);"}, {"sha": "18e440a60fe73467d32255fd676b32c5228b184f", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b20996ff13afd304d44aafd0966501cc4bd10b97/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b20996ff13afd304d44aafd0966501cc4bd10b97/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=b20996ff13afd304d44aafd0966501cc4bd10b97", "patch": "@@ -223,7 +223,7 @@ cgraph_clone_inlined_nodes (struct cgraph_edge *e, bool duplicate,\n       /* We may eliminate the need for out-of-line copy to be output.\n \t In that case just go ahead and re-use it.  */\n       if (!e->callee->callers->next_caller\n-\t  && !e->callee->needed\n+\t  && cgraph_can_remove_if_no_direct_calls_p (e->callee)\n \t  && !cgraph_new_nodes)\n \t{\n \t  gcc_assert (!e->callee->global.inlined_to);\n@@ -233,6 +233,7 @@ cgraph_clone_inlined_nodes (struct cgraph_edge *e, bool duplicate,\n \t      nfunctions_inlined++;\n \t    }\n \t  duplicate = false;\n+\t  e->callee->local.externally_visible = false;\n \t}\n       else\n \t{\n@@ -286,7 +287,7 @@ cgraph_mark_inline_edge (struct cgraph_edge *e, bool update_original,\n   e->callee->global.inlined = true;\n \n   if (e->callee->callers->next_caller\n-      || e->callee->needed)\n+      || !cgraph_can_remove_if_no_direct_calls_p (e->callee))\n     duplicate = true;\n   cgraph_clone_inlined_nodes (e, true, update_original);\n \n@@ -368,7 +369,8 @@ cgraph_estimate_growth (struct cgraph_node *node)\n      we decide to not inline for different reasons, but it is not big deal\n      as in that case we will keep the body around, but we will also avoid\n      some inlining.  */\n-  if (!node->needed && !DECL_EXTERNAL (node->decl) && !self_recursive)\n+  if (cgraph_only_called_directly_p (node)\n+      && !DECL_EXTERNAL (node->decl) && !self_recursive)\n     growth -= node->global.size;\n \n   node->global.estimated_growth = growth;\n@@ -1226,7 +1228,7 @@ cgraph_decide_inlining (void)\n \n \t  if (node->callers\n \t      && !node->callers->next_caller\n-\t      && !node->needed\n+\t      && cgraph_only_called_directly_p (node)\n \t      && node->local.inlinable\n \t      && node->callers->inline_failed\n \t      && node->callers->caller != node"}, {"sha": "50eade08cdd586e5ba37382f6cd21f34260b4796", "filename": "gcc/ipa.c", "status": "modified", "additions": 107, "deletions": 15, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b20996ff13afd304d44aafd0966501cc4bd10b97/gcc%2Fipa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b20996ff13afd304d44aafd0966501cc4bd10b97/gcc%2Fipa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa.c?ref=b20996ff13afd304d44aafd0966501cc4bd10b97", "patch": "@@ -52,7 +52,9 @@ cgraph_postorder (struct cgraph_node **order)\n   for (pass = 0; pass < 2; pass++)\n     for (node = cgraph_nodes; node; node = node->next)\n       if (!node->aux\n-\t  && (pass || (node->needed && !node->address_taken)))\n+\t  && (pass\n+\t      || (!cgraph_only_called_directly_p (node)\n+\t  \t  && !node->address_taken)))\n \t{\n \t  node2 = node;\n \t  if (!node->callers)\n@@ -132,11 +134,12 @@ cgraph_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n     gcc_assert (!node->aux);\n #endif\n   for (node = cgraph_nodes; node; node = node->next)\n-    if (node->needed && !node->global.inlined_to\n+    if (!cgraph_can_remove_if_no_direct_calls_p (node)\n \t&& ((!DECL_EXTERNAL (node->decl)) \n             || !node->analyzed\n             || before_inlining_p))\n       {\n+        gcc_assert (!node->global.inlined_to);\n \tnode->aux = first;\n \tfirst = node;\n       }\n@@ -248,6 +251,26 @@ cgraph_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n   return changed;\n }\n \n+static bool\n+cgraph_externally_visible_p (struct cgraph_node *node, bool whole_program)\n+{\n+  if (!DECL_COMDAT (node->decl)\n+      && (!TREE_PUBLIC (node->decl) || DECL_EXTERNAL (node->decl)))\n+    return false;\n+  if (!whole_program)\n+    return true;\n+  /* COMDAT functions must be shared only if they have address taken,\n+     otherwise we can produce our own private implementation with\n+     -fwhole-program.  */\n+  if (DECL_COMDAT (node->decl) && (node->address_taken || !node->analyzed))\n+    return true;\n+  if (MAIN_NAME_P (DECL_NAME (node->decl)))\n+    return true;\n+  if (lookup_attribute (\"externally_visible\", DECL_ATTRIBUTES (node->decl)))\n+    return true;\n+  return false;\n+}\n+\n /* Mark visibility of all functions.\n \n    A local function is one whose calls can occur only in the current\n@@ -260,38 +283,46 @@ cgraph_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n    via visibilities for the backend point of view.  */\n \n static unsigned int\n-function_and_variable_visibility (void)\n+function_and_variable_visibility (bool whole_program)\n {\n   struct cgraph_node *node;\n   struct varpool_node *vnode;\n \n   for (node = cgraph_nodes; node; node = node->next)\n     {\n-      if (node->reachable\n-\t  && (DECL_COMDAT (node->decl)\n-\t      || (!flag_whole_program\n-\t\t  && TREE_PUBLIC (node->decl) && !DECL_EXTERNAL (node->decl))))\n-\tnode->local.externally_visible = true;\n+      if (cgraph_externally_visible_p (node, whole_program))\n+        {\n+\t  gcc_assert (!node->global.inlined_to);\n+\t  node->local.externally_visible = true;\n+\t}\n+      else\n+\tnode->local.externally_visible = false;\n       if (!node->local.externally_visible && node->analyzed\n \t  && !DECL_EXTERNAL (node->decl))\n \t{\n-\t  gcc_assert (flag_whole_program || !TREE_PUBLIC (node->decl));\n+\t  gcc_assert (whole_program || !TREE_PUBLIC (node->decl));\n \t  TREE_PUBLIC (node->decl) = 0;\n+\t  DECL_COMDAT (node->decl) = 0;\n+\t  DECL_WEAK (node->decl) = 0;\n \t}\n-      node->local.local = (!node->needed\n+      node->local.local = (cgraph_only_called_directly_p (node)\n \t\t\t   && node->analyzed\n \t\t\t   && !DECL_EXTERNAL (node->decl)\n \t\t\t   && !node->local.externally_visible);\n     }\n   for (vnode = varpool_nodes_queue; vnode; vnode = vnode->next_needed)\n     {\n       if (vnode->needed\n-\t  && !flag_whole_program\n-\t  && (DECL_COMDAT (vnode->decl) || TREE_PUBLIC (vnode->decl)))\n-\tvnode->externally_visible = 1;\n+\t  && (DECL_COMDAT (vnode->decl) || TREE_PUBLIC (vnode->decl))\n+\t  && (!whole_program\n+\t      || lookup_attribute (\"externally_visible\",\n+\t\t\t\t   DECL_ATTRIBUTES (vnode->decl))))\n+\tvnode->externally_visible = true;\n+      else\n+        vnode->externally_visible = false;\n       if (!vnode->externally_visible)\n \t{\n-\t  gcc_assert (flag_whole_program || !TREE_PUBLIC (vnode->decl));\n+\t  gcc_assert (whole_program || !TREE_PUBLIC (vnode->decl));\n \t  TREE_PUBLIC (vnode->decl) = 0;\n \t}\n      gcc_assert (TREE_STATIC (vnode->decl));\n@@ -314,13 +345,22 @@ function_and_variable_visibility (void)\n   return 0;\n }\n \n+/* Local function pass handling visibilities.  This happens before LTO streaming\n+   so in particular -fwhole-program should be ignored at this level.  */\n+\n+static unsigned int\n+local_function_and_variable_visibility (void)\n+{\n+  return function_and_variable_visibility (flag_whole_program && !flag_lto && !flag_whopr);\n+}\n+\n struct simple_ipa_opt_pass pass_ipa_function_and_variable_visibility = \n {\n  {\n   SIMPLE_IPA_PASS,\n   \"visibility\",\t\t\t\t/* name */\n   NULL,\t\t\t\t\t/* gate */\n-  function_and_variable_visibility,\t/* execute */\n+  local_function_and_variable_visibility,/* execute */\n   NULL,\t\t\t\t\t/* sub */\n   NULL,\t\t\t\t\t/* next */\n   0,\t\t\t\t\t/* static_pass_number */\n@@ -333,6 +373,58 @@ struct simple_ipa_opt_pass pass_ipa_function_and_variable_visibility =\n  }\n };\n \n+/* Do not re-run on ltrans stage.  */\n+\n+static bool\n+gate_whole_program_function_and_variable_visibility (void)\n+{\n+  return !flag_ltrans;\n+}\n+\n+/* Bring functionss local at LTO time whith -fwhole-program.  */\n+\n+static unsigned int\n+whole_program_function_and_variable_visibility (void)\n+{\n+  struct cgraph_node *node;\n+  struct varpool_node *vnode;\n+\n+  function_and_variable_visibility (flag_whole_program);\n+\n+  for (node = cgraph_nodes; node; node = node->next)\n+    if (node->local.externally_visible)\n+      cgraph_mark_needed_node (node);\n+  for (vnode = varpool_nodes_queue; vnode; vnode = vnode->next_needed)\n+    if (vnode->externally_visible)\n+      varpool_mark_needed_node (vnode);\n+  return 0;\n+}\n+\n+struct ipa_opt_pass_d pass_ipa_whole_program_visibility =\n+{\n+ {\n+  IPA_PASS,\n+  \"whole-program\",\t\t\t/* name */\n+  gate_whole_program_function_and_variable_visibility,/* gate */\n+  whole_program_function_and_variable_visibility,/* execute */\n+  NULL,\t\t\t\t\t/* sub */\n+  NULL,\t\t\t\t\t/* next */\n+  0,\t\t\t\t\t/* static_pass_number */\n+  TV_CGRAPHOPT,\t\t\t\t/* tv_id */\n+  0,\t                                /* properties_required */\n+  0,\t\t\t\t\t/* properties_provided */\n+  0,\t\t\t\t\t/* properties_destroyed */\n+  0,\t\t\t\t\t/* todo_flags_start */\n+  TODO_dump_cgraph | TODO_remove_functions/* todo_flags_finish */\n+ },\n+ NULL,\t\t\t\t\t/* generate_summary */\n+ NULL,\t\t\t\t\t/* write_summary */\n+ NULL,\t\t\t\t\t/* read_summary */\n+ NULL,\t\t\t\t\t/* function_read_summary */\n+ 0,\t\t\t\t\t/* TODOs */\n+ NULL,\t\t\t\t\t/* function_transform */\n+ NULL,\t\t\t\t\t/* variable_transform */\n+};\n \n /* Hash a cgraph node set element.  */\n "}, {"sha": "fbf0df21c24ff4b714da294c8ed714741b44246a", "filename": "gcc/lto-cgraph.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b20996ff13afd304d44aafd0966501cc4bd10b97/gcc%2Flto-cgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b20996ff13afd304d44aafd0966501cc4bd10b97/gcc%2Flto-cgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-cgraph.c?ref=b20996ff13afd304d44aafd0966501cc4bd10b97", "patch": "@@ -227,6 +227,8 @@ lto_output_node (struct lto_simple_output_block *ob, struct cgraph_node *node,\n      local static nodes to prevent clashes with other local statics.  */\n   if (boundary_p)\n     {\n+      /* Inline clones can not be part of boundary.  */\n+      gcc_assert (!node->global.inlined_to);\n       local = 0;\n       externally_visible = 1;\n       inlinable = 0;"}, {"sha": "7d30448447aaaa2c5c6494c1a9d4038a790a8e15", "filename": "gcc/lto-symtab.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b20996ff13afd304d44aafd0966501cc4bd10b97/gcc%2Flto-symtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b20996ff13afd304d44aafd0966501cc4bd10b97/gcc%2Flto-symtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-symtab.c?ref=b20996ff13afd304d44aafd0966501cc4bd10b97", "patch": "@@ -388,7 +388,10 @@ lto_cgraph_replace_node (struct cgraph_node *old_node,\n   if (old_node->reachable)\n     cgraph_mark_reachable_node (new_node);\n   if (old_node->address_taken)\n-    cgraph_mark_address_taken_node (new_node);\n+    {\n+      gcc_assert (!new_node->global.inlined_to);\n+      cgraph_mark_address_taken_node (new_node);\n+    }\n \n   /* Redirect all incoming edges.  */\n   for (e = old_node->callers; e; e = next)"}, {"sha": "dae0367d5da56497e1181a8e43384b7ce09ab0d3", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b20996ff13afd304d44aafd0966501cc4bd10b97/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b20996ff13afd304d44aafd0966501cc4bd10b97/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=b20996ff13afd304d44aafd0966501cc4bd10b97", "patch": "@@ -1,3 +1,8 @@\n+2009-10-07  Jan Hubicka  <jh@suse.cz>\n+\n+\t* lto.c (read_cgraph_and_symbols): Mark functions neccesary only at\n+\tltrans stage; explain why this is needed and should not.\n+\n 2009-10-05  Richard Guenther  <rguenther@suse.de>\n \n \tPR lto/41552"}, {"sha": "ab4c208670d95acdf1639c5ec1b9e0ca34d83c75", "filename": "gcc/lto/lto.c", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b20996ff13afd304d44aafd0966501cc4bd10b97/gcc%2Flto%2Flto.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b20996ff13afd304d44aafd0966501cc4bd10b97/gcc%2Flto%2Flto.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto.c?ref=b20996ff13afd304d44aafd0966501cc4bd10b97", "patch": "@@ -1824,11 +1824,18 @@ read_cgraph_and_symbols (unsigned nfiles, const char **fnames)\n   /* Merge global decls.  */\n   lto_symtab_merge_decls ();\n \n-  /* Mark cgraph nodes needed in the merged cgraph.\n-     ???  Is this really necessary?  */\n-  for (node = cgraph_nodes; node; node = node->next)\n-    if (cgraph_decide_is_function_needed (node, node->decl))\n-      cgraph_mark_needed_node (node);\n+  /* Mark cgraph nodes needed in the merged cgraph\n+     This normally happens in whole-program pass, but for\n+     ltrans the pass was already run at WPA phase.\n+     \n+     FIXME:  This is not valid way to do so; nodes can be needed\n+     for non-obvious reasons.  We should stream the flags from WPA\n+     phase. */\n+  if (flag_ltrans)\n+    for (node = cgraph_nodes; node; node = node->next)\n+      if (!node->global.inlined_to\n+\t  && cgraph_decide_is_function_needed (node, node->decl))\n+        cgraph_mark_needed_node (node);\n \n   timevar_push (TV_IPA_LTO_DECL_IO);\n "}, {"sha": "60a850969c25c798e6bf397c36ac355ad73b5732", "filename": "gcc/passes.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b20996ff13afd304d44aafd0966501cc4bd10b97/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b20996ff13afd304d44aafd0966501cc4bd10b97/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=b20996ff13afd304d44aafd0966501cc4bd10b97", "patch": "@@ -759,6 +759,7 @@ init_optimization_passes (void)\n   *p = NULL;\n \n   p = &all_regular_ipa_passes;\n+  NEXT_PASS (pass_ipa_whole_program_visibility);\n   NEXT_PASS (pass_ipa_cp);\n   NEXT_PASS (pass_ipa_inline);\n   NEXT_PASS (pass_ipa_reference);\n@@ -1099,7 +1100,7 @@ do_per_function_toporder (void (*callback) (void *data), void *data)\n \t  /* Allow possibly removed nodes to be garbage collected.  */\n \t  order[i] = NULL;\n \t  node->process = 0;\n-\t  if (node->analyzed && (node->needed || node->reachable))\n+\t  if (node->analyzed)\n \t    {\n \t      push_cfun (DECL_STRUCT_FUNCTION (node->decl));\n \t      current_function_decl = node->decl;\n@@ -1783,7 +1784,7 @@ function_called_by_processed_nodes_p (void)\n     {\n       if (e->caller->decl == current_function_decl)\n         continue;\n-      if (!e->caller->analyzed || (!e->caller->needed && !e->caller->reachable))\n+      if (!e->caller->analyzed)\n         continue;\n       if (TREE_ASM_WRITTEN (e->caller->decl))\n         continue;"}, {"sha": "2cbe3e4b44878b83b8ad910c7fd5335d9d1f4463", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b20996ff13afd304d44aafd0966501cc4bd10b97/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b20996ff13afd304d44aafd0966501cc4bd10b97/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=b20996ff13afd304d44aafd0966501cc4bd10b97", "patch": "@@ -437,6 +437,7 @@ extern struct simple_ipa_opt_pass pass_ipa_early_inline;\n \n extern struct simple_ipa_opt_pass pass_early_local_passes;\n \n+extern struct ipa_opt_pass_d pass_ipa_whole_program_visibility;\n extern struct ipa_opt_pass_d pass_ipa_lto_gimple_out;\n extern struct simple_ipa_opt_pass pass_ipa_increase_alignment;\n extern struct simple_ipa_opt_pass pass_ipa_matrix_reorg;"}, {"sha": "f7b338ff44b0486e0a2a62846494122476c49399", "filename": "gcc/varpool.c", "status": "modified", "additions": 30, "deletions": 6, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b20996ff13afd304d44aafd0966501cc4bd10b97/gcc%2Fvarpool.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b20996ff13afd304d44aafd0966501cc4bd10b97/gcc%2Fvarpool.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarpool.c?ref=b20996ff13afd304d44aafd0966501cc4bd10b97", "patch": "@@ -35,6 +35,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"output.h\"\n #include \"gimple.h\"\n #include \"tree-flow.h\"\n+#include \"flags.h\"\n \n /*  This file contains basic routines manipulating variable pool.\n \n@@ -245,7 +246,11 @@ decide_is_variable_needed (struct varpool_node *node, tree decl)\n \n   /* Externally visible variables must be output.  The exception is\n      COMDAT variables that must be output only when they are needed.  */\n-  if (TREE_PUBLIC (decl) && !flag_whole_program && !DECL_COMDAT (decl)\n+  if (TREE_PUBLIC (decl)\n+      && !flag_whole_program\n+      && !flag_lto\n+      && !flag_whopr\n+      && !DECL_COMDAT (decl)\n       && !DECL_EXTERNAL (decl))\n     return true;\n \n@@ -279,6 +284,17 @@ varpool_finalize_decl (tree decl)\n {\n   struct varpool_node *node = varpool_node (decl);\n \n+  /* FIXME: We don't really stream varpool datastructure and instead rebuild it\n+     by varpool_finalize_decl.  This is not quite correct since this way we can't\n+     attach any info to varpool.  Eventually we will want to stream varpool nodes\n+     and the flags.\n+\n+     For the moment just prevent analysis of varpool nodes to happen again, so\n+     we will re-try to compute \"address_taken\" flag of varpool that breaks\n+     in presence of clones.  */\n+  if (in_lto_p)\n+    node->analyzed = true;\n+\n   /* The first declaration of a variable that comes through this function\n      decides whether it is global (in C, has external linkage)\n      or local (in C, has internal linkage).  So do nothing more\n@@ -333,17 +349,25 @@ varpool_analyze_pending_decls (void)\n   while (varpool_first_unanalyzed_node)\n     {\n       tree decl = varpool_first_unanalyzed_node->decl;\n+      bool analyzed = varpool_first_unanalyzed_node->analyzed;\n \n       varpool_first_unanalyzed_node->analyzed = true;\n \n       varpool_first_unanalyzed_node = varpool_first_unanalyzed_node->next_needed;\n \n-      /* Compute the alignment early so function body expanders are\n-\t already informed about increased alignment.  */\n-      align_variable (decl, 0);\n+      /* When reading back varpool at LTO time, we re-construct the queue in order\n+         to have \"needed\" list right by inserting all needed nodes into varpool.\n+\t We however don't want to re-analyze already analyzed nodes.  */\n+      if (!analyzed)\n+\t{\n+\t  gcc_assert (!in_lto_p);\n+          /* Compute the alignment early so function body expanders are\n+\t     already informed about increased alignment.  */\n+          align_variable (decl, 0);\n \n-      if (DECL_INITIAL (decl))\n-\trecord_references_in_initializer (decl);\n+          if (DECL_INITIAL (decl))\n+\t    record_references_in_initializer (decl);\n+\t}\n       changed = true;\n     }\n   timevar_pop (TV_CGRAPH);"}]}