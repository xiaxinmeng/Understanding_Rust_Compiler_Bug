{"sha": "2fe7404ad443eacbce92cc0a695bd31d9b263bbb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmZlNzQwNGFkNDQzZWFjYmNlOTJjYzBhNjk1YmQzMWQ5YjI2M2JiYg==", "commit": {"author": {"name": "Andreas Tobler", "email": "a.tobler@schweiz.ch", "date": "2004-09-02T21:14:45Z"}, "committer": {"name": "Andreas Tobler", "email": "andreast@gcc.gnu.org", "date": "2004-09-02T21:14:45Z"}, "message": "ffi_darwin.c: Add flag for longdouble return values.\n\n2004-09-02  Andreas Tobler  <a.tobler@schweiz.ch>\n\n\t* src/powerpc/ffi_darwin.c: Add flag for longdouble return values.\n\t(ffi_prep_args): Handle longdouble arguments.\n\t(ffi_prep_cif_machdep): Set flags for longdouble. Calculate space for\n\tlongdouble.\n\t(ffi_closure_helper_DARWIN): Add closure handling for longdouble.\n\t* src/powerpc/darwin.S (_ffi_call_DARWIN): Add handling of longdouble\n\tvalues.\n\t* src/powerpc/darwin_closure.S (_ffi_closure_ASM): Likewise.\n\t* src/types.c: Defined longdouble size and alignment for darwin.\n\nFrom-SVN: r86992", "tree": {"sha": "eec92a0c95c7e91b95c4b2c40388a3ca9fc89d8b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/eec92a0c95c7e91b95c4b2c40388a3ca9fc89d8b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2fe7404ad443eacbce92cc0a695bd31d9b263bbb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2fe7404ad443eacbce92cc0a695bd31d9b263bbb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2fe7404ad443eacbce92cc0a695bd31d9b263bbb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2fe7404ad443eacbce92cc0a695bd31d9b263bbb/comments", "author": null, "committer": null, "parents": [{"sha": "16070e459c4951497cb097aa106ea78398bb698b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16070e459c4951497cb097aa106ea78398bb698b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/16070e459c4951497cb097aa106ea78398bb698b"}], "stats": {"total": 142, "additions": 119, "deletions": 23}, "files": [{"sha": "90e1f173ac846630551f4c43b0728a7426d312b0", "filename": "libffi/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fe7404ad443eacbce92cc0a695bd31d9b263bbb/libffi%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fe7404ad443eacbce92cc0a695bd31d9b263bbb/libffi%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2FChangeLog?ref=2fe7404ad443eacbce92cc0a695bd31d9b263bbb", "patch": "@@ -1,3 +1,15 @@\n+2004-09-02  Andreas Tobler  <a.tobler@schweiz.ch>\n+\n+\t* src/powerpc/ffi_darwin.c: Add flag for longdouble return values.\n+\t(ffi_prep_args): Handle longdouble arguments.\n+\t(ffi_prep_cif_machdep): Set flags for longdouble. Calculate space for\n+\tlongdouble.\n+\t(ffi_closure_helper_DARWIN): Add closure handling for longdouble.\n+\t* src/powerpc/darwin.S (_ffi_call_DARWIN): Add handling of longdouble\n+\tvalues.\n+\t* src/powerpc/darwin_closure.S (_ffi_closure_ASM): Likewise.\n+\t* src/types.c: Defined longdouble size and alignment for darwin.\n+\n 2004-09-02  Andreas Tobler  <a.tobler@schweiz.ch>\n \n \t* src/powerpc/aix.S: Remove whitespaces."}, {"sha": "771238c5b7c57098e23cb787b13cbcd9c3d45e80", "filename": "libffi/src/powerpc/darwin.S", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fe7404ad443eacbce92cc0a695bd31d9b263bbb/libffi%2Fsrc%2Fpowerpc%2Fdarwin.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fe7404ad443eacbce92cc0a695bd31d9b263bbb/libffi%2Fsrc%2Fpowerpc%2Fdarwin.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fpowerpc%2Fdarwin.S?ref=2fe7404ad443eacbce92cc0a695bd31d9b263bbb", "patch": "@@ -1,5 +1,6 @@\n /* -----------------------------------------------------------------------\n    darwin.S - Copyright (c) 2000 John Hornkvist\n+\t      Copyright (c) 2004 Free Software Foundation, Inc.\n \n    PowerPC Assembly glue.\n \n@@ -142,12 +143,23 @@ L(done_return_value):\n \tblr\n \n L(fp_return_value):\n+\t/* Do we have long double to store?  */\n+\tbf\t31,L(fd_return_value)\n+\tstfd\tf1,0(r30)\n+\tstfd\tf2,8(r30)\n+\tb\tL(done_return_value)\n+\n+L(fd_return_value):\n+\t/* Do we have double to store?  */\n \tbf\t28,L(float_return_value)\n \tstfd\tf1,0(r30)\n \tb\tL(done_return_value)\n+\n L(float_return_value):\n+\t/* We only have a float to store.  */\n \tstfs\tf1,0(r30)\n \tb\tL(done_return_value)\n+\n LFE1:\n /* END(_ffi_call_DARWIN)  */\n \n@@ -218,6 +230,6 @@ LASFDE1:\n \t.align 2\n LEFDE1:\n .data\n-        .align 2\n+\t.align 2\n LLFB0$non_lazy_ptr:\n-        .long   LFB0\n+\t.long   LFB0"}, {"sha": "bf30c167feec94d3bb19ef85b89ee51bc0a96dd0", "filename": "libffi/src/powerpc/darwin_closure.S", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fe7404ad443eacbce92cc0a695bd31d9b263bbb/libffi%2Fsrc%2Fpowerpc%2Fdarwin_closure.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fe7404ad443eacbce92cc0a695bd31d9b263bbb/libffi%2Fsrc%2Fpowerpc%2Fdarwin_closure.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fpowerpc%2Fdarwin_closure.S?ref=2fe7404ad443eacbce92cc0a695bd31d9b263bbb", "patch": "@@ -1,5 +1,5 @@\n /* -----------------------------------------------------------------------\n-   darwin_closure.S - Copyright (c) 2002 2003 Free Software Foundation,\n+   darwin_closure.S - Copyright (c) 2002, 2003, 2004, Free Software Foundation,\n    Inc. based on ppc_closure.S\n \n    PowerPC Assembly glue.\n@@ -42,8 +42,8 @@ LCFI0:\n \t/* 24 Bytes (Linkage Area)\n \t   32 Bytes (outgoing parameter area, always reserved)\n \t   104 Bytes (13*8 from FPR)\n-\t   8 Bytes (result)\n-\t   168 Bytes  */\n+\t   16 Bytes (result)\n+\t   176 Bytes  */\n \n \tstwu\tr1,-176(r1)\t/* skip over caller save area\n \t\t\t\tkeep stack aligned to 16.  */\n@@ -150,9 +150,9 @@ Lret_type3:\n /* case FFI_TYPE_LONGDOUBLE  */\n Lret_type4:\n \tlfd\tf1,0(r5)\n+\tlfd\tf2,8(r5)\n \tb\tLfinish\n \tnop\n-\tnop\n \n /* case FFI_TYPE_UINT8  */\n Lret_type5:\n@@ -301,4 +301,4 @@ L_ffi_closure_helper_DARWIN$lazy_ptr:\n .data\n \t.align 2\n LLFB1$non_lazy_ptr:\n-        .long LFB1\n+\t.long LFB1"}, {"sha": "d758f8f3af4a613ea0c07c7385cb0b665cce7042", "filename": "libffi/src/powerpc/ffi_darwin.c", "status": "modified", "additions": 82, "deletions": 15, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fe7404ad443eacbce92cc0a695bd31d9b263bbb/libffi%2Fsrc%2Fpowerpc%2Fffi_darwin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fe7404ad443eacbce92cc0a695bd31d9b263bbb/libffi%2Fsrc%2Fpowerpc%2Fffi_darwin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fpowerpc%2Fffi_darwin.c?ref=2fe7404ad443eacbce92cc0a695bd31d9b263bbb", "patch": "@@ -38,6 +38,7 @@ enum {\n   FLAG_RETURNS_NOTHING  = 1 << (31-30), /* These go in cr7  */\n   FLAG_RETURNS_FP       = 1 << (31-29),\n   FLAG_RETURNS_64BITS   = 1 << (31-28),\n+  FLAG_RETURNS_128BITS  = 1 << (31-31),\n \n   FLAG_ARG_NEEDS_COPY   = 1 << (31- 7),\n   FLAG_FP_ARGUMENTS     = 1 << (31- 6), /* cr1.eq; specified by ABI  */\n@@ -86,7 +87,7 @@ void ffi_prep_args(extended_cif *ecif, unsigned *const stack)\n   const unsigned flags = ecif->cif->flags;\n \n   /* 'stacktop' points at the previous backchain pointer.  */\n-  unsigned *const stacktop = stack + (ecif->cif->bytes / sizeof(unsigned));\n+  unsigned *const stacktop = stack + (bytes / sizeof(unsigned));\n \n   /* 'fpr_base' points at the space for fpr1, and grows upwards as\n      we use FPR registers.  */\n@@ -95,7 +96,7 @@ void ffi_prep_args(extended_cif *ecif, unsigned *const stack)\n \n \n   /* 'next_arg' grows up as we put parameters in it.  */\n-  unsigned *next_arg = stack + 6; /* 6 reserved posistions.  */\n+  unsigned *next_arg = stack + 6; /* 6 reserved positions.  */\n \n   int i = ecif->cif->nargs;\n   double double_tmp;\n@@ -137,6 +138,7 @@ void ffi_prep_args(extended_cif *ecif, unsigned *const stack)\n \t  fparg_count++;\n \t  FFI_ASSERT(flags & FLAG_FP_ARGUMENTS);\n \t  break;\n+\n \tcase FFI_TYPE_DOUBLE:\n \t  double_tmp = *(double *)*p_argv;\n \t  if (fparg_count >= NUM_FPR_ARG_REGISTERS)\n@@ -148,6 +150,26 @@ void ffi_prep_args(extended_cif *ecif, unsigned *const stack)\n \t  FFI_ASSERT(flags & FLAG_FP_ARGUMENTS);\n \t  break;\n \n+#if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE\n+\n+\tcase FFI_TYPE_LONGDOUBLE:\n+\t  double_tmp = ((double *)*p_argv)[0];\n+\t  if (fparg_count >= NUM_FPR_ARG_REGISTERS)\n+\t    *(double *)next_arg = double_tmp;\n+\t  else\n+\t    *fpr_base++ = double_tmp;\n+\t  next_arg += 2;\n+\t  fparg_count++;\n+\t  double_tmp = ((double *)*p_argv)[1];\n+\t  if (fparg_count >= NUM_FPR_ARG_REGISTERS)\n+\t    *(double *)next_arg = double_tmp;\n+\t  else\n+\t    *fpr_base++ = double_tmp;\n+\t  next_arg += 2;\n+\t  fparg_count++;\n+\t  FFI_ASSERT(flags & FLAG_FP_ARGUMENTS);\n+\t  break;\n+#endif\n \tcase FFI_TYPE_UINT64:\n \tcase FFI_TYPE_SINT64:\n \t  *(long long *)next_arg = *(long long *)*p_argv;\n@@ -167,10 +189,6 @@ void ffi_prep_args(extended_cif *ecif, unsigned *const stack)\n \t  goto putgpr;\n \n \tcase FFI_TYPE_STRUCT:\n-\n-#if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE\n-\tcase FFI_TYPE_LONGDOUBLE:\n-#endif\n \t  dest_cpy = (char *) next_arg;\n \n \t  /* Structures that match the basic modes (QI 1 byte, HI 2 bytes,\n@@ -240,10 +258,14 @@ ffi_status ffi_prep_cif_machdep(ffi_cif *cif)\n        as the first argument.  */\n   switch (cif->rtype->type)\n     {\n+\n #if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE\n     case FFI_TYPE_LONGDOUBLE:\n+      flags |= FLAG_RETURNS_128BITS;\n+      flags |= FLAG_RETURNS_FP;\n+      break;\n #endif\n-      /* Fall through.  */\n+\n     case FFI_TYPE_DOUBLE:\n       flags |= FLAG_RETURNS_64BITS;\n       /* Fall through.  */\n@@ -272,9 +294,8 @@ ffi_status ffi_prep_cif_machdep(ffi_cif *cif)\n \n   /* The first NUM_GPR_ARG_REGISTERS words of integer arguments, and the\n      first NUM_FPR_ARG_REGISTERS fp arguments, go in registers; the rest\n-     goes on the stack.  Structures and long doubles (if not equivalent\n-     to double) are passed as a pointer to a copy of the structure.\n-     Stuff on the stack needs to keep proper alignment.  */\n+     goes on the stack.  Structures are passed as a pointer to a copy of\n+     the structure. Stuff on the stack needs to keep proper alignment.  */\n   for (ptr = cif->arg_types, i = cif->nargs; i > 0; i--, ptr++)\n     {\n       switch ((*ptr)->type)\n@@ -289,6 +310,19 @@ ffi_status ffi_prep_cif_machdep(ffi_cif *cif)\n \t    intarg_count++;\n \t  break;\n \n+#if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE\n+\n+\tcase FFI_TYPE_LONGDOUBLE:\n+\t  fparg_count += 2;\n+\t  /* If this FP arg is going on the stack, it must be\n+\t     8-byte-aligned.  */\n+\t  if (fparg_count > NUM_FPR_ARG_REGISTERS\n+\t      && intarg_count%2 != 0)\n+\t    intarg_count++;\n+\t  intarg_count +=2;\n+\t  break;\n+#endif\n+\n \tcase FFI_TYPE_UINT64:\n \tcase FFI_TYPE_SINT64:\n \t  /* 'long long' arguments are passed as two words, but\n@@ -302,9 +336,6 @@ ffi_status ffi_prep_cif_machdep(ffi_cif *cif)\n \t  break;\n \n \tcase FFI_TYPE_STRUCT:\n-#if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE\n-\tcase FFI_TYPE_LONGDOUBLE:\n-#endif\n \t  size_al = (*ptr)->size;\n \t  /* If the first member of the struct is a double, then align\n \t     the struct to double-word.\n@@ -409,8 +440,8 @@ static void flush_range(char *, int);\n    points to one of these.  */\n \n typedef struct aix_fd_struct {\n-    void *code_pointer;\n-    void *toc;\n+  void *code_pointer;\n+  void *toc;\n } aix_fd;\n \n /* here I'd like to add the stack frame layout we use in darwin_closure.S\n@@ -572,6 +603,13 @@ int ffi_closure_helper_DARWIN (ffi_closure* closure, void * rvalue,\n      pgr is the pointer to where r3-r10 are stored in ffi_closure_ASM\n      pfr is the pointer to where f1-f13 are stored in ffi_closure_ASM.  */\n \n+  typedef double ldbits[2];\n+\n+  union ldu\n+  {\n+    ldbits lb;\n+    long double ld;\n+  };\n \n   void **          avalue;\n   ffi_type **      arg_types;\n@@ -581,6 +619,7 @@ int ffi_closure_helper_DARWIN (ffi_closure* closure, void * rvalue,\n   ffi_cif *        cif;\n   double           temp;\n   unsigned         size_al;\n+  union ldu        temp_ld;\n \n   cif = closure->cif;\n   avalue = alloca(cif->nargs * sizeof(void *));\n@@ -689,6 +728,34 @@ int ffi_closure_helper_DARWIN (ffi_closure* closure, void * rvalue,\n \t  pgr += 2;\n \t  break;\n \n+#if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE\n+\n+\tcase FFI_TYPE_LONGDOUBLE:\n+\t  /* A long double value consumes four GPRs and two FPRs.\n+\t     There are 13 64bit floating point registers.  */\n+\t  if (nf < NUM_FPR_ARG_REGISTERS - 1)\n+\t    {\n+\t      avalue[i] = pfr;\n+\t      pfr += 2;\n+\t    }\n+\t  /* Here we have the situation where one part of the long double\n+\t     is stored in fpr13 and the other part is already on the stack.\n+\t     We use a union to pass the long double to avalue[i].  */\n+\t  else if (nf == NUM_FPR_ARG_REGISTERS - 1)\n+\t    {\n+\t      memcpy (&temp_ld.lb[0], pfr, sizeof(ldbits));\n+\t      memcpy (&temp_ld.lb[1], pgr + 2, sizeof(ldbits));\n+\t      avalue[i] = &temp_ld.ld;\n+\t    }\n+\t  else\n+\t    {\n+\t      avalue[i] = pgr;\n+\t    }\n+\t  nf += 2;\n+\t  ng += 4;\n+\t  pgr += 4;\n+\t  break;\n+#endif\n \tdefault:\n \t  FFI_ASSERT(0);\n \t}"}, {"sha": "09863c076b508bd664dbf5c2d33cbd567fd4042f", "filename": "libffi/src/types.c", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fe7404ad443eacbce92cc0a695bd31d9b263bbb/libffi%2Fsrc%2Ftypes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fe7404ad443eacbce92cc0a695bd31d9b263bbb/libffi%2Fsrc%2Ftypes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Ftypes.c?ref=2fe7404ad443eacbce92cc0a695bd31d9b263bbb", "patch": "@@ -80,11 +80,16 @@ FFI_INTEGRAL_TYPEDEF(double, 8, 4, FFI_TYPE_DOUBLE);\n #endif\n FFI_INTEGRAL_TYPEDEF(longdouble, 12, 4, FFI_TYPE_LONGDOUBLE);\n \n-#elif defined ARM || defined SH || defined POWERPC_AIX || defined POWERPC_DARWIN\n+#elif defined ARM || defined SH || defined POWERPC_AIX\n \n FFI_INTEGRAL_TYPEDEF(double, 8, 4, FFI_TYPE_DOUBLE);\n FFI_INTEGRAL_TYPEDEF(longdouble, 8, 4, FFI_TYPE_LONGDOUBLE);\n \n+#elif defined POWERPC_DARWIN\n+\n+FFI_INTEGRAL_TYPEDEF(double, 8, 4, FFI_TYPE_DOUBLE);\n+FFI_INTEGRAL_TYPEDEF(longdouble, 16, 16, FFI_TYPE_LONGDOUBLE);\n+\n #elif defined SPARC\n \n FFI_INTEGRAL_TYPEDEF(double, 8, 8, FFI_TYPE_DOUBLE);"}]}