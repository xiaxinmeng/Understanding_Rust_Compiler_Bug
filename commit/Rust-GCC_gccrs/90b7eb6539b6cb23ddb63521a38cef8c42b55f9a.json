{"sha": "90b7eb6539b6cb23ddb63521a38cef8c42b55f9a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTBiN2ViNjUzOWI2Y2IyM2RkYjYzNTIxYTM4Y2VmOGM0MmI1NWY5YQ==", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2020-02-13T15:55:10Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2020-02-15T15:55:25Z"}, "message": "libstdc++: Fold some ranges algo subroutines into their only caller\n\nThese subroutines have only a single call site, so it might be best and simplest\nto eliminate them before we convert the algos into function objects.\n\nlibstdc++-v3/ChangeLog:\n\n\t* include/bits/ranges_algo.h (ranges::__find_end): Fold into ...\n\t(ranges::find_end): ... here.\n\t(ranges::__lexicographical_compare): Fold into ...\n\t(ranges::lexicographical_compare): ... here.\n\t* include/bits/ranges_algobase.h (ranges::__equal): Fold into ...\n\t(ranges::equal): ... here.", "tree": {"sha": "604735ba46124a0e59f6ad83b334c6da1df458b6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/604735ba46124a0e59f6ad83b334c6da1df458b6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/90b7eb6539b6cb23ddb63521a38cef8c42b55f9a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/90b7eb6539b6cb23ddb63521a38cef8c42b55f9a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/90b7eb6539b6cb23ddb63521a38cef8c42b55f9a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/90b7eb6539b6cb23ddb63521a38cef8c42b55f9a/comments", "author": null, "committer": null, "parents": [{"sha": "acff02ef1f4bc951ab7b4e3fdc117e0646d5d8f5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/acff02ef1f4bc951ab7b4e3fdc117e0646d5d8f5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/acff02ef1f4bc951ab7b4e3fdc117e0646d5d8f5"}], "stats": {"total": 146, "additions": 64, "deletions": 82}, "files": [{"sha": "624c0c2f7c984f5baab93ce7487aa33a9556eebc", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90b7eb6539b6cb23ddb63521a38cef8c42b55f9a/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90b7eb6539b6cb23ddb63521a38cef8c42b55f9a/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=90b7eb6539b6cb23ddb63521a38cef8c42b55f9a", "patch": "@@ -1,3 +1,12 @@\n+2020-02-15  Patrick Palka  <ppalka@redhat.com>\n+\n+\t* include/bits/ranges_algo.h (ranges::__find_end): Fold into ...\n+\t(ranges::find_end): ... here.\n+\t(ranges::__lexicographical_compare): Fold into ...\n+\t(ranges::lexicographical_compare): ... here.\n+\t* include/bits/ranges_algobase.h (ranges::__equal): Fold into ...\n+\t(ranges::equal): ... here.\n+\n 2020-02-15  Jonathan Wakely  <jwakely@redhat.com>\n \n \t* include/bits/erase_if.h (__cpp_lib_erase_if): Define to 202002L."}, {"sha": "6b6f4defdf5ef991bf23c497b4dd665a5b8af431", "filename": "libstdc++-v3/include/bits/ranges_algo.h", "status": "modified", "additions": 42, "deletions": 62, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90b7eb6539b6cb23ddb63521a38cef8c42b55f9a/libstdc%2B%2B-v3%2Finclude%2Fbits%2Franges_algo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90b7eb6539b6cb23ddb63521a38cef8c42b55f9a/libstdc%2B%2B-v3%2Finclude%2Fbits%2Franges_algo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Franges_algo.h?ref=90b7eb6539b6cb23ddb63521a38cef8c42b55f9a", "patch": "@@ -513,40 +513,7 @@ namespace ranges\n \t\t\t      std::move(__pred), std::move(__proj));\n     }\n \n-  template<forward_iterator _Iter1, sentinel_for<_Iter1> _Sent1,\n-\t   forward_iterator _Iter2, sentinel_for<_Iter2> _Sent2,\n-\t   typename _Pred = ranges::equal_to,\n-\t   typename _Proj1 = identity, typename _Proj2 = identity>\n-    requires indirectly_comparable<_Iter1, _Iter2, _Pred, _Proj1, _Proj2>\n-    constexpr subrange<_Iter1>\n-    __find_end(_Iter1 __first1, _Sent1 __last1,\n-\t       _Iter2 __first2, _Sent2 __last2,\n-\t       _Pred __pred, _Proj1 __proj1, _Proj2 __proj2)\n-    {\n-      auto __i = ranges::next(__first1, __last1);\n-      if (__first2 == __last2)\n-\treturn {__i, __i};\n \n-      auto __result_begin = __i;\n-      auto __result_end = __i;\n-      for (;;)\n-\t{\n-\t  auto __new_range = ranges::search(__first1, __last1,\n-\t\t\t\t\t    __first2, __last2,\n-\t\t\t\t\t    __pred, __proj1, __proj2);\n-\t  auto __new_result_begin = ranges::begin(__new_range);\n-\t  auto __new_result_end = ranges::end(__new_range);\n-\t  if (__new_result_begin == __last1)\n-\t    return {__result_begin, __result_end};\n-\t  else\n-\t    {\n-\t      __result_begin = __new_result_begin;\n-\t      __result_end = __new_result_end;\n-\t      __first1 = __result_begin;\n-\t      ++__first1;\n-\t    }\n-\t}\n-    }\n \n   template<forward_iterator _Iter1, sentinel_for<_Iter1> _Sent1,\n \t   forward_iterator _Iter2, sentinel_for<_Iter2> _Sent2,\n@@ -578,9 +545,31 @@ namespace ranges\n \t    return {__result_first, __result_last};\n \t}\n       else\n-\treturn ranges::__find_end(__first1, __last1, __first2, __last2,\n-\t\t\t\t  std::move(__pred),\n-\t\t\t\t  std::move(__proj1), std::move(__proj2));\n+\t{\n+\t  auto __i = ranges::next(__first1, __last1);\n+\t  if (__first2 == __last2)\n+\t    return {__i, __i};\n+\n+\t  auto __result_begin = __i;\n+\t  auto __result_end = __i;\n+\t  for (;;)\n+\t    {\n+\t      auto __new_range = ranges::search(__first1, __last1,\n+\t\t\t\t\t\t__first2, __last2,\n+\t\t\t\t\t\t__pred, __proj1, __proj2);\n+\t      auto __new_result_begin = ranges::begin(__new_range);\n+\t      auto __new_result_end = ranges::end(__new_range);\n+\t      if (__new_result_begin == __last1)\n+\t\treturn {__result_begin, __result_end};\n+\t      else\n+\t\t{\n+\t\t  __result_begin = __new_result_begin;\n+\t\t  __result_end = __new_result_end;\n+\t\t  __first1 = __result_begin;\n+\t\t  ++__first1;\n+\t\t}\n+\t    }\n+\t}\n     }\n \n   template<forward_range _Range1, forward_range _Range2,\n@@ -2908,14 +2897,26 @@ namespace ranges\n \n   template<input_iterator _Iter1, sentinel_for<_Iter1> _Sent1,\n \t   input_iterator _Iter2, sentinel_for<_Iter2> _Sent2,\n-\t   typename _Proj1, typename _Proj2,\n+\t   typename _Proj1 = identity, typename _Proj2 = identity,\n \t   indirect_strict_weak_order<projected<_Iter1, _Proj1>,\n-\t\t\t\t      projected<_Iter2, _Proj2>> _Comp>\n+\t\t\t\t      projected<_Iter2, _Proj2>>\n+\t     _Comp = ranges::less>\n     constexpr bool\n-    __lexicographical_compare(_Iter1 __first1, _Sent1 __last1,\n-\t\t\t      _Iter2 __first2, _Sent2 __last2,\n-\t\t\t      _Comp __comp, _Proj1 __proj1, _Proj2 __proj2)\n+    lexicographical_compare(_Iter1 __first1, _Sent1 __last1,\n+\t\t\t    _Iter2 __first2, _Sent2 __last2,\n+\t\t\t    _Comp __comp = {},\n+\t\t\t    _Proj1 __proj1 = {}, _Proj2 __proj2 = {})\n     {\n+      if constexpr (__detail::__is_normal_iterator<_Iter1>\n+\t\t    || __detail::__is_normal_iterator<_Iter2>)\n+\treturn ranges::lexicographical_compare\n+\t\t (std::__niter_base(std::move(__first1)),\n+\t\t  std::__niter_base(std::move(__last1)),\n+\t\t  std::__niter_base(std::move(__first2)),\n+\t\t  std::__niter_base(std::move(__last2)),\n+\t\t  std::move(__comp),\n+\t\t  std::move(__proj1), std::move(__proj2));\n+\n       constexpr bool __sized_iters\n \t= (sized_sentinel_for<_Sent1, _Iter1>\n \t   && sized_sentinel_for<_Sent2, _Iter2>);\n@@ -2976,27 +2977,6 @@ namespace ranges\n       return __first1 == __last1 && __first2 != __last2;\n     }\n \n-  template<input_iterator _Iter1, sentinel_for<_Iter1> _Sent1,\n-\t   input_iterator _Iter2, sentinel_for<_Iter2> _Sent2,\n-\t   typename _Proj1 = identity, typename _Proj2 = identity,\n-\t   indirect_strict_weak_order<projected<_Iter1, _Proj1>,\n-\t\t\t\t      projected<_Iter2, _Proj2>>\n-\t     _Comp = ranges::less>\n-    constexpr bool\n-    lexicographical_compare(_Iter1 __first1, _Sent1 __last1,\n-\t\t\t    _Iter2 __first2, _Sent2 __last2,\n-\t\t\t    _Comp __comp = {},\n-\t\t\t    _Proj1 __proj1 = {}, _Proj2 __proj2 = {})\n-    {\n-      return (ranges::__lexicographical_compare\n-\t      (std::__niter_base(std::move(__first1)),\n-\t       std::__niter_base(std::move(__last1)),\n-\t       std::__niter_base(std::move(__first2)),\n-\t       std::__niter_base(std::move(__last2)),\n-\t       std::move(__comp),\n-\t       std::move(__proj1), std::move(__proj2)));\n-    }\n-\n   template<input_range _Range1, input_range _Range2, typename _Proj1 = identity,\n \t   typename _Proj2 = identity,\n \t   indirect_strict_weak_order<projected<iterator_t<_Range1>, _Proj1>,"}, {"sha": "813a5096ae00384fd7a1aed83ef8965f91a72f27", "filename": "libstdc++-v3/include/bits/ranges_algobase.h", "status": "modified", "additions": 13, "deletions": 20, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90b7eb6539b6cb23ddb63521a38cef8c42b55f9a/libstdc%2B%2B-v3%2Finclude%2Fbits%2Franges_algobase.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90b7eb6539b6cb23ddb63521a38cef8c42b55f9a/libstdc%2B%2B-v3%2Finclude%2Fbits%2Franges_algobase.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Franges_algobase.h?ref=90b7eb6539b6cb23ddb63521a38cef8c42b55f9a", "patch": "@@ -73,14 +73,24 @@ namespace ranges\n \n   template<input_iterator _Iter1, sentinel_for<_Iter1> _Sent1,\n \t   input_iterator _Iter2, sentinel_for<_Iter2> _Sent2,\n-\t   typename _Pred, typename _Proj1, typename _Proj2>\n+\t   typename _Pred = ranges::equal_to,\n+\t   typename _Proj1 = identity, typename _Proj2 = identity>\n     requires indirectly_comparable<_Iter1, _Iter2, _Pred, _Proj1, _Proj2>\n     constexpr bool\n-    __equal(_Iter1 __first1, _Sent1 __last1, _Iter2 __first2, _Sent2 __last2,\n-\t    _Pred __pred, _Proj1 __proj1, _Proj2 __proj2)\n+    equal(_Iter1 __first1, _Sent1 __last1, _Iter2 __first2, _Sent2 __last2,\n+\t  _Pred __pred = {}, _Proj1 __proj1 = {}, _Proj2 __proj2 = {})\n     {\n       // TODO: implement more specializations to at least have parity with\n       // std::equal.\n+      if constexpr (__detail::__is_normal_iterator<_Iter1>\n+\t\t    || __detail::__is_normal_iterator<_Iter2>)\n+\treturn ranges::equal(std::__niter_base(std::move(__first1)),\n+\t\t\t     std::__niter_base(std::move(__last1)),\n+\t\t\t     std::__niter_base(std::move(__first2)),\n+\t\t\t     std::__niter_base(std::move(__last2)),\n+\t\t\t     std::move(__pred),\n+\t\t\t     std::move(__proj1), std::move(__proj2));\n+\n       constexpr bool __sized_iters\n \t= (sized_sentinel_for<_Sent1, _Iter1>\n \t   && sized_sentinel_for<_Sent2, _Iter2>);\n@@ -129,23 +139,6 @@ namespace ranges\n \t}\n     }\n \n-  template<input_iterator _Iter1, sentinel_for<_Iter1> _Sent1,\n-\t   input_iterator _Iter2, sentinel_for<_Iter2> _Sent2,\n-\t   typename _Pred = ranges::equal_to,\n-\t   typename _Proj1 = identity, typename _Proj2 = identity>\n-    requires indirectly_comparable<_Iter1, _Iter2, _Pred, _Proj1, _Proj2>\n-    constexpr bool\n-    equal(_Iter1 __first1, _Sent1 __last1, _Iter2 __first2, _Sent2 __last2,\n-\t  _Pred __pred = {}, _Proj1 __proj1 = {}, _Proj2 __proj2 = {})\n-    {\n-      return ranges::__equal(std::__niter_base(std::move(__first1)),\n-\t\t\t     std::__niter_base(std::move(__last1)),\n-\t\t\t     std::__niter_base(std::move(__first2)),\n-\t\t\t     std::__niter_base(std::move(__last2)),\n-\t\t\t     std::move(__pred),\n-\t\t\t     std::move(__proj1), std::move(__proj2));\n-    }\n-\n   template<input_range _Range1, input_range _Range2,\n \t   typename _Pred = ranges::equal_to,\n \t   typename _Proj1 = identity, typename _Proj2 = identity>"}]}