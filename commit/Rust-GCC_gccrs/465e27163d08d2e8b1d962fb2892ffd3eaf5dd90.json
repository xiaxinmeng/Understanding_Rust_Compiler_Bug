{"sha": "465e27163d08d2e8b1d962fb2892ffd3eaf5dd90", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDY1ZTI3MTYzZDA4ZDJlOGIxZDk2MmZiMjg5MmZmZDNlYWY1ZGQ5MA==", "commit": {"author": {"name": "Geoff Keating", "email": "geoffk@cygnus.com", "date": "1999-08-01T16:14:58Z"}, "committer": {"name": "Geoffrey Keating", "email": "geoffk@gcc.gnu.org", "date": "1999-08-01T16:14:58Z"}, "message": "rs6000.c (num_insns_constant_wide): Correct for type promotion.\n\n\t* config/rs6000/rs6000.c (num_insns_constant_wide): Correct\n\tfor type promotion.\n\t(add_operand): Get test correct for 64-bit HOST_WIDE_INT.\n\t(non_add_cint_operand): Likewise.\n\t(logical_operand): Likewise.\n\t(non_logical_cint_operand): Likewise.\n\t(print_operand): Correct printf()s for 64-bit HOST_WIDE_INT.\n\t(print_operand_address): Correct printf() for 64-bit HOST_WIDE_INT.\n\t(rs6000_select_rtx_section): Suppress warning.\n\t(small_data_operand): Suppress warning.\n\t(rs6000_got_register): Suppress warning.\n\t* config/rs6000/rs6000.md (andsi3): HOST_WIDE_INT is a signed\n\ttype, so `J' is generally the wrong constraint for a SImode value;\n\tuse `L' instead.\n\t(andsi3_internal2): Likewise.\n\t(andsi3_internal3): Likewise.\n\t(iorsi3_internal1): Likewise.\n\t(xorsi3_internal1): Likewise.\n\t(movsi): Likewise.\n\t(movsf_softfloat): Likewise.\n\tvarious unnamed compare insns: Likewise.\n\t(movsi+2): Preserve sign bits of SImode constant.\n\t(floatsidf2_internal+1): Sign-extend SImode constant correctly.\n\t(movdf+1): Preserve high bits of DFmode constant.\n\t(movdi_32+1): Sign-extend properly.\n\tvarious unnamed compare insns: Sign-extend properly.\n\n\t* unroll.c (loop_iterations): Convert HOST_WIDE_INT to unsigned\n\tproperly for mode.\n\t* expmed.c (expand_mult_highpart): Convert HOST_WIDE_INT from unsigned\n\tproperly for mode.\n\t(expand_divmod): Likewise.\n\t* optabs.c (expand_fix): Keep HOST_WIDE_INT constants properly signed.\n\t(expand_binop): Sometimes there is work to do when changing\n\tthe mode of a CONST_INT.\n\nFrom-SVN: r28375", "tree": {"sha": "5aabdc2c0749cc2bdd4aee71e4a65c91d31a84ec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5aabdc2c0749cc2bdd4aee71e4a65c91d31a84ec"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/465e27163d08d2e8b1d962fb2892ffd3eaf5dd90", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/465e27163d08d2e8b1d962fb2892ffd3eaf5dd90", "html_url": "https://github.com/Rust-GCC/gccrs/commit/465e27163d08d2e8b1d962fb2892ffd3eaf5dd90", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/465e27163d08d2e8b1d962fb2892ffd3eaf5dd90/comments", "author": null, "committer": null, "parents": [{"sha": "3f1d071b7b4c15eb5f5eae95bcbab3e57e3a51c8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f1d071b7b4c15eb5f5eae95bcbab3e57e3a51c8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3f1d071b7b4c15eb5f5eae95bcbab3e57e3a51c8"}], "stats": {"total": 167, "additions": 111, "deletions": 56}, "files": [{"sha": "5be789acddead6dde2fadfe6992c598f6ec0cd17", "filename": "gcc/ChangeLog", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/465e27163d08d2e8b1d962fb2892ffd3eaf5dd90/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/465e27163d08d2e8b1d962fb2892ffd3eaf5dd90/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=465e27163d08d2e8b1d962fb2892ffd3eaf5dd90", "patch": "@@ -1,3 +1,41 @@\n+Sun Jul 25 19:32:58 1999  Geoff Keating  <geoffk@cygnus.com>\n+\n+\t* config/rs6000/rs6000.c (num_insns_constant_wide): Correct\n+\tfor type promotion.\n+\t(add_operand): Get test correct for 64-bit HOST_WIDE_INT.\n+\t(non_add_cint_operand): Likewise.\n+\t(logical_operand): Likewise.\n+\t(non_logical_cint_operand): Likewise.\n+\t(print_operand): Correct printf()s for 64-bit HOST_WIDE_INT.\n+\t(print_operand_address): Correct printf() for 64-bit HOST_WIDE_INT.\n+\t(rs6000_select_rtx_section): Suppress warning.\n+\t(small_data_operand): Suppress warning.\n+\t(rs6000_got_register): Suppress warning.\n+\t* config/rs6000/rs6000.md (andsi3): HOST_WIDE_INT is a signed\n+\ttype, so `J' is generally the wrong constraint for a SImode value;\n+\tuse `L' instead.\n+\t(andsi3_internal2): Likewise.\n+\t(andsi3_internal3): Likewise.\n+\t(iorsi3_internal1): Likewise.\n+\t(xorsi3_internal1): Likewise.\n+\t(movsi): Likewise.\n+\t(movsf_softfloat): Likewise.\n+\tvarious unnamed compare insns: Likewise.\n+\t(movsi+2): Preserve sign bits of SImode constant.\n+\t(floatsidf2_internal+1): Sign-extend SImode constant correctly.\n+\t(movdf+1): Preserve high bits of DFmode constant.\n+\t(movdi_32+1): Sign-extend properly.\n+\tvarious unnamed compare insns: Sign-extend properly.\n+\n+\t* unroll.c (loop_iterations): Convert HOST_WIDE_INT to unsigned\n+\tproperly for mode.\n+\t* expmed.c (expand_mult_highpart): Convert HOST_WIDE_INT from unsigned\n+\tproperly for mode.\n+\t(expand_divmod): Likewise.\n+\t* optabs.c (expand_fix): Keep HOST_WIDE_INT constants properly signed.\n+\t(expand_binop): Sometimes there is work to do when changing\n+\tthe mode of a CONST_INT.\n+\n Sun Aug  1 12:55:31 1999  Bernd Schmidt  <bernds@cygnus.co.uk>\n \n \t* stmt.c (emit_filename, emit_lineno, expr_stmts_for_value,"}, {"sha": "4028bd42c334f11495a2de3663ba50b3d9eb0e81", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 31, "deletions": 27, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/465e27163d08d2e8b1d962fb2892ffd3eaf5dd90/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/465e27163d08d2e8b1d962fb2892ffd3eaf5dd90/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=465e27163d08d2e8b1d962fb2892ffd3eaf5dd90", "patch": "@@ -666,16 +666,11 @@ num_insns_constant_wide (value)\n   if (((unsigned HOST_WIDE_INT)value + 0x8000) < 0x10000)\n     return 1;\n \n-#if HOST_BITS_PER_WIDE_INT == 32\n-  /* constant loadable with {cau|addis} */\n-  else if ((value & 0xffff) == 0)\n-    return 1;\n-\n-#else\n   /* constant loadable with {cau|addis} */\n-  else if ((value & 0xffff) == 0 && (value & ~0xffffffff) == 0)\n+  else if (CONST_OK_FOR_LETTER_P (value, 'L'))\n     return 1;\n \n+#if HOST_BITS_PER_WIDE_INT == 64\n   else if (TARGET_64BIT)\n     {\n       HOST_WIDE_INT low  = value & 0xffffffff;\n@@ -880,7 +875,7 @@ mem_or_easy_const_operand (op, mode)\n }\n \n /* Return 1 if the operand is either a non-special register or an item\n-   that can be used as the operand of an SI add insn.  */\n+   that can be used as the operand of a `mode' add insn.  */\n \n int\n add_operand (op, mode)\n@@ -889,7 +884,7 @@ add_operand (op, mode)\n {\n   return (reg_or_short_operand (op, mode)\n \t  || (GET_CODE (op) == CONST_INT\n-\t      && (INTVAL (op) & (~ (HOST_WIDE_INT) 0xffff0000)) == 0));\n+\t      && CONST_OK_FOR_LETTER_P (INTVAL(op), 'L')));\n }\n \n /* Return 1 if OP is a constant but not a valid add_operand.  */\n@@ -901,7 +896,7 @@ non_add_cint_operand (op, mode)\n {\n   return (GET_CODE (op) == CONST_INT\n \t  && (unsigned HOST_WIDE_INT) (INTVAL (op) + 0x8000) >= 0x10000\n-\t  && (INTVAL (op) & (~ (HOST_WIDE_INT) 0xffff0000)) != 0);\n+\t  && ! CONST_OK_FOR_LETTER_P (INTVAL(op), 'L'));\n }\n \n /* Return 1 if the operand is a non-special register or a constant that\n@@ -914,8 +909,10 @@ logical_operand (op, mode)\n {\n   return (gpc_reg_operand (op, mode)\n \t  || (GET_CODE (op) == CONST_INT\n-\t      && ((INTVAL (op) & (~ (HOST_WIDE_INT) 0xffff)) == 0\n-\t\t  || (INTVAL (op) & (~ (HOST_WIDE_INT) 0xffff0000)) == 0)));\n+\t      && ((INTVAL (op) & GET_MODE_MASK (mode)\n+\t\t   & (~ (HOST_WIDE_INT) 0xffff)) == 0\n+\t\t  || (INTVAL (op) & GET_MODE_MASK (mode)\n+\t\t      & (~ (HOST_WIDE_INT) 0xffff0000)) == 0)));\n }\n \n /* Return 1 if C is a constant that is not a logical operand (as\n@@ -924,11 +921,13 @@ logical_operand (op, mode)\n int\n non_logical_cint_operand (op, mode)\n      register rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+     enum machine_mode mode;\n {\n   return (GET_CODE (op) == CONST_INT\n-\t  && (INTVAL (op) & (~ (HOST_WIDE_INT) 0xffff)) != 0\n-\t  && (INTVAL (op) & (~ (HOST_WIDE_INT) 0xffff0000)) != 0);\n+\t  && (INTVAL (op) & GET_MODE_MASK (mode) &\n+\t      (~ (HOST_WIDE_INT) 0xffff)) != 0\n+\t  && (INTVAL (op) & GET_MODE_MASK (mode) &\n+\t      (~ (HOST_WIDE_INT) 0xffff0000)) != 0);\n }\n \n /* Return 1 if C is a constant that can be encoded in a 32-bit mask on the\n@@ -1198,7 +1197,7 @@ small_data_operand (op, mode)\n      enum machine_mode mode ATTRIBUTE_UNUSED;\n {\n #if TARGET_ELF\n-  rtx sym_ref, const_part;\n+  rtx sym_ref;\n \n   if (rs6000_sdata == SDATA_NONE || rs6000_sdata == SDATA_DATA)\n     return 0;\n@@ -2474,7 +2473,7 @@ ccr_bit (op, scc_p)\n \n struct rtx_def *\n rs6000_got_register (value)\n-     rtx value;\n+     rtx value ATTRIBUTE_UNUSED;\n {\n   /* The second flow pass currently (June 1999) can't update regs_ever_live\n      without disturbing other parts of the compiler, so update it here to\n@@ -2627,7 +2626,7 @@ print_operand (file, x, code)\n       if (! INT_P (x))\n \toutput_operand_lossage (\"invalid %%b value\");\n \n-      fprintf (file, \"%d\", INT_LOWPART (x) & 0xffff);\n+      fprintf (file, HOST_WIDE_INT_PRINT_DEC, INT_LOWPART (x) & 0xffff);\n       return;\n \n     case 'B':\n@@ -2713,7 +2712,7 @@ print_operand (file, x, code)\n       /* If constant, output low-order five bits.  Otherwise,\n \t write normally. */\n       if (INT_P (x))\n-\tfprintf (file, \"%d\", INT_LOWPART (x) & 31);\n+\tfprintf (file, HOST_WIDE_INT_PRINT_DEC, INT_LOWPART (x) & 31);\n       else\n \tprint_operand (file, x, 0);\n       return;\n@@ -2722,7 +2721,7 @@ print_operand (file, x, code)\n       /* If constant, output low-order six bits.  Otherwise,\n \t write normally. */\n       if (INT_P (x))\n-\tfprintf (file, \"%d\", INT_LOWPART (x) & 63);\n+\tfprintf (file, HOST_WIDE_INT_PRINT_DEC, INT_LOWPART (x) & 63);\n       else\n \tprint_operand (file, x, 0);\n       return;\n@@ -2759,7 +2758,7 @@ print_operand (file, x, code)\n       if (! INT_P (x))\n \toutput_operand_lossage (\"invalid %%k value\");\n \n-      fprintf (file, \"%d\", ~ INT_LOWPART (x));\n+      fprintf (file, HOST_WIDE_INT_PRINT_DEC, ~ INT_LOWPART (x));\n       return;\n \n     case 'L':\n@@ -2903,7 +2902,7 @@ print_operand (file, x, code)\n       if (! INT_P (x))\n \toutput_operand_lossage (\"invalid %%s value\");\n \n-      fprintf (file, \"%d\", (32 - INT_LOWPART (x)) & 31);\n+      fprintf (file, HOST_WIDE_INT_PRINT_DEC, (32 - INT_LOWPART (x)) & 31);\n       return;\n \n     case 'S':\n@@ -3006,7 +3005,8 @@ print_operand (file, x, code)\n       if (! INT_P (x))\n \toutput_operand_lossage (\"invalid %%u value\");\n \n-      fprintf (file, \"0x%x\", (INT_LOWPART (x) >> 16) & 0xffff);\n+      fprintf (file, HOST_WIDE_INT_PRINT_HEX, \n+\t       (INT_LOWPART (x) >> 16) & 0xffff);\n       return;\n \n     case 'v':\n@@ -3076,7 +3076,8 @@ print_operand (file, x, code)\n       /* If constant, low-order 16 bits of constant, signed.  Otherwise, write\n \t normally.  */\n       if (INT_P (x))\n-\tfprintf (file, \"%d\", ((INT_LOWPART (x) & 0xffff) ^ 0x8000) - 0x8000);\n+\tfprintf (file, HOST_WIDE_INT_PRINT_DEC, \n+\t\t ((INT_LOWPART (x) & 0xffff) ^ 0x8000) - 0x8000);\n       else\n \tprint_operand (file, x, 0);\n       return;\n@@ -3085,7 +3086,7 @@ print_operand (file, x, code)\n       /* If constant, low-order 16 bits of constant, unsigned.\n \t Otherwise, write normally.  */\n       if (INT_P (x))\n-\tfprintf (file, \"%d\", INT_LOWPART (x) & 0xffff);\n+\tfprintf (file, HOST_WIDE_INT_PRINT_DEC, INT_LOWPART (x) & 0xffff);\n       else\n \tprint_operand (file, x, 0);\n       return;\n@@ -3221,7 +3222,10 @@ print_operand_address (file, x)\n \t\t reg_names[ REGNO (XEXP (x, 1)) ]);\n     }\n   else if (GET_CODE (x) == PLUS && GET_CODE (XEXP (x, 1)) == CONST_INT)\n-    fprintf (file, \"%d(%s)\", INTVAL (XEXP (x, 1)), reg_names[ REGNO (XEXP (x, 0)) ]);\n+    {\n+      fprintf (file, HOST_WIDE_INT_PRINT_DEC, INTVAL (XEXP (x, 1)));\n+      fprintf (file, \"(%s)\", reg_names[ REGNO (XEXP (x, 0)) ]);\n+    }\n #if TARGET_ELF\n   else if (GET_CODE (x) == LO_SUM && GET_CODE (XEXP (x, 0)) == REG\n            && CONSTANT_P (XEXP (x, 1)))\n@@ -5649,7 +5653,7 @@ rs6000_longcall_ref (call_ref)\n \n void\n rs6000_select_rtx_section (mode, x)\n-     enum machine_mode mode;\n+     enum machine_mode mode ATTRIBUTE_UNUSED;\n      rtx x;\n {\n   if (ASM_OUTPUT_SPECIAL_POOL_ENTRY_P (x))"}, {"sha": "62de8656d5259e9d31671bfb2617b618de54f040", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 21, "deletions": 20, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/465e27163d08d2e8b1d962fb2892ffd3eaf5dd90/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/465e27163d08d2e8b1d962fb2892ffd3eaf5dd90/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=465e27163d08d2e8b1d962fb2892ffd3eaf5dd90", "patch": "@@ -1938,7 +1938,7 @@\n (define_insn \"andsi3\"\n   [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r,r,r,r\")\n \t(and:SI (match_operand:SI 1 \"gpc_reg_operand\" \"%r,r,r,r\")\n-\t\t(match_operand:SI 2 \"and_operand\" \"?r,T,K,J\")))\n+\t\t(match_operand:SI 2 \"and_operand\" \"?r,T,K,L\")))\n    (clobber (match_scratch:CC 3 \"=X,X,x,x\"))]\n   \"\"\n   \"@\n@@ -1955,7 +1955,7 @@\n (define_insn \"*andsi3_internal2\"\n   [(set (match_operand:CC 0 \"cc_reg_operand\" \"=x,x,x,x,?y,??y,??y,?y\")\n \t(compare:CC (and:SI (match_operand:SI 1 \"gpc_reg_operand\" \"%r,r,r,r,r,r,r,r\")\n-\t\t\t    (match_operand:SI 2 \"and_operand\" \"r,K,J,T,r,K,J,T\"))\n+\t\t\t    (match_operand:SI 2 \"and_operand\" \"r,K,L,T,r,K,L,T\"))\n \t\t    (const_int 0)))\n    (clobber (match_scratch:SI 3 \"=r,r,r,r,r,r,r,r\"))\n    (clobber (match_scratch:CC 4 \"=X,X,X,X,X,x,x,X\"))]\n@@ -1992,7 +1992,7 @@\n (define_insn \"*andsi3_internal3\"\n   [(set (match_operand:CC 3 \"cc_reg_operand\" \"=x,x,x,x,?y,??y,??y,?y\")\n \t(compare:CC (and:SI (match_operand:SI 1 \"gpc_reg_operand\" \"%r,r,r,r,r,r,r,r\")\n-\t\t\t    (match_operand:SI 2 \"and_operand\" \"r,K,J,T,r,K,J,T\"))\n+\t\t\t    (match_operand:SI 2 \"and_operand\" \"r,K,L,T,r,K,L,T\"))\n \t\t    (const_int 0)))\n    (set (match_operand:SI 0 \"gpc_reg_operand\" \"=r,r,r,r,r,r,r,r\")\n \t(and:SI (match_dup 1)\n@@ -2054,7 +2054,7 @@\n (define_insn \"*iorsi3_internal1\"\n   [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r,r,r\")\n \t(ior:SI (match_operand:SI 1 \"gpc_reg_operand\" \"%r,r,r\")\n-\t\t(match_operand:SI 2 \"logical_operand\" \"r,K,J\")))]\n+\t\t(match_operand:SI 2 \"logical_operand\" \"r,K,L\")))]\n   \"\"\n   \"@\n    or %0,%1,%2\n@@ -2161,7 +2161,7 @@\n (define_insn \"*xorsi3_internal1\"\n   [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r,r,r\")\n \t(xor:SI (match_operand:SI 1 \"gpc_reg_operand\" \"%r,r,r\")\n-\t\t(match_operand:SI 2 \"logical_operand\" \"r,K,J\")))]\n+\t\t(match_operand:SI 2 \"logical_operand\" \"r,K,L\")))]\n   \"\"\n   \"@\n    xor %0,%1,%2\n@@ -4226,7 +4226,7 @@\n \t\t  (match_dup 3)))]\n   \"\n {\n-  operands[6] = GEN_INT (0x80000000);\n+  operands[6] = GEN_INT (~ (HOST_WIDE_INT) 0x7fffffff);\n   operands[7] = gen_rtx_REG (DFmode, FPMEM_REGNUM);\n }\")\n \n@@ -6127,7 +6127,7 @@\n \t\t(match_dup 3)))]\n   \"\n {\n-  operands[2] = GEN_INT (INTVAL (operands[1]) & 0xffff0000);\n+  operands[2] = GEN_INT (INTVAL (operands[1]) & (~ (HOST_WIDE_INT) 0xffff));\n   operands[3] = GEN_INT (INTVAL (operands[1]) & 0xffff);\n }\")\n \n@@ -6383,7 +6383,7 @@\n   int endian = (WORDS_BIG_ENDIAN == 0);\n   operands[2] = operand_subword (operands[0], endian, 0, DFmode);\n   operands[3] = operand_subword (operands[0], 1 - endian, 0, DFmode);\n-  operands[4] = (INTVAL (operands[1]) & 0x80000000) ? constm1_rtx : const0_rtx;\n+  operands[4] = GEN_INT(INTVAL (operands[1]) >> 31 >> 1);\n }\")\n \n (define_split\n@@ -6740,13 +6740,14 @@\n    (set (match_dup 3) (match_dup 1))]\n   \"\n {\n+  HOST_WIDE_INT value = INTVAL (operands[1]);\n   operands[2] = gen_rtx_SUBREG (SImode, operands[0], WORDS_BIG_ENDIAN == 0);\n   operands[3] = gen_rtx_SUBREG (SImode, operands[0], WORDS_BIG_ENDIAN != 0);\n #if HOST_BITS_PER_WIDE_INT == 32\n-  operands[4] = (INTVAL (operands[1]) & 0x80000000) ? constm1_rtx : const0_rtx;\n+  operands[4] = (value & 0x80000000) ? constm1_rtx : const0_rtx;\n #else\n-  operands[4] = GEN_INT ((HOST_WIDE_INT) INTVAL (operands[1]) >> 32);\n-  operands[1] = GEN_INT (INTVAL (operands[1]) & 0xffffffff);\n+  operands[4] = GEN_INT (value >> 32);\n+  operands[1] = GEN_INT ((value & 0x7fffffff) - (value & 0x80000000));\n #endif\n }\")\n \n@@ -8893,9 +8894,9 @@\n      sign-extended to 16 bits.  Then see what constant could be XOR'ed\n      with C to get the sign-extended value.  */\n \n-  int c = INTVAL (operands[2]);\n-  int sextc = (c << 16) >> 16;\n-  int xorv = c ^ sextc;\n+  HOST_WIDE_INT c = INTVAL (operands[2]);\n+  HOST_WIDE_INT sextc = (c & 0x7fff) - (c & 0x8000);\n+  HOST_WIDE_INT xorv = c ^ sextc;\n \n   operands[4] = GEN_INT (xorv);\n   operands[5] = GEN_INT (sextc);\n@@ -9128,7 +9129,7 @@\n (define_insn \"\"\n   [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r,r,r,r,r\")\n \t(eq:SI (match_operand:SI 1 \"gpc_reg_operand\" \"%r,r,r,r,r\")\n-\t       (match_operand:SI 2 \"reg_or_cint_operand\" \"r,O,K,J,I\")))\n+\t       (match_operand:SI 2 \"reg_or_cint_operand\" \"r,O,K,L,I\")))\n    (clobber (match_scratch:SI 3 \"=r,&r,r,r,r\"))]\n   \"\"\n   \"@\n@@ -9157,7 +9158,7 @@\n   [(set (match_operand:CC 4 \"cc_reg_operand\" \"=x,x,x,x,x\")\n \t(compare:CC\n \t (eq:SI (match_operand:SI 1 \"gpc_reg_operand\" \"%r,r,r,r,r\")\n-\t\t(match_operand:SI 2 \"reg_or_cint_operand\" \"r,O,K,J,I\"))\n+\t\t(match_operand:SI 2 \"reg_or_cint_operand\" \"r,O,K,L,I\"))\n \t (const_int 0)))\n    (set (match_operand:SI 0 \"gpc_reg_operand\" \"=r,r,r,r,r\")\n \t(eq:SI (match_dup 1) (match_dup 2)))\n@@ -9209,7 +9210,7 @@\n (define_insn \"\"\n   [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r,r,r,r,r\")\n \t(plus:SI (eq:SI (match_operand:SI 1 \"gpc_reg_operand\" \"%r,r,r,r,r\")\n-\t\t\t(match_operand:SI 2 \"reg_or_cint_operand\" \"r,O,K,J,I\"))\n+\t\t\t(match_operand:SI 2 \"reg_or_cint_operand\" \"r,O,K,L,I\"))\n \t\t (match_operand:SI 3 \"gpc_reg_operand\" \"r,r,r,r,r\")))\n    (clobber (match_scratch:SI 4 \"=&r,&r,&r,&r,&r\"))]\n   \"\"\n@@ -9226,7 +9227,7 @@\n \t(compare:CC\n \t (plus:SI\n \t  (eq:SI (match_operand:SI 1 \"gpc_reg_operand\" \"%r,r,r,r,r\")\n-\t\t (match_operand:SI 2 \"reg_or_cint_operand\" \"r,O,K,J,I\"))\n+\t\t (match_operand:SI 2 \"reg_or_cint_operand\" \"r,O,K,L,I\"))\n \t  (match_operand:SI 3 \"gpc_reg_operand\" \"r,r,r,r,r\"))\n \t (const_int 0)))\n    (clobber (match_scratch:SI 4 \"=&r,&r,&r,&r,&r\"))]\n@@ -9245,7 +9246,7 @@\n \t(compare:CC\n \t (plus:SI\n \t  (eq:SI (match_operand:SI 1 \"gpc_reg_operand\" \"%r,r,r,r,r\")\n-\t\t (match_operand:SI 2 \"reg_or_cint_operand\" \"r,O,K,J,I\"))\n+\t\t (match_operand:SI 2 \"reg_or_cint_operand\" \"r,O,K,L,I\"))\n \t  (match_operand:SI 3 \"gpc_reg_operand\" \"r,r,r,r,r\"))\n \t (const_int 0)))\n    (set (match_operand:SI 0 \"gpc_reg_operand\" \"=r,r,r,r,r\")\n@@ -9264,7 +9265,7 @@\n (define_insn \"\"\n   [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r,r,r,r,r\")\n \t(neg:SI (eq:SI (match_operand:SI 1 \"gpc_reg_operand\" \"%r,r,r,r,r\")\n-\t\t       (match_operand:SI 2 \"reg_or_cint_operand\" \"r,O,K,J,I\"))))]\n+\t\t       (match_operand:SI 2 \"reg_or_cint_operand\" \"r,O,K,L,I\"))))]\n   \"\"\n   \"@\n    xor %0,%1,%2\\;{ai|addic} %0,%0,-1\\;{sfe|subfe} %0,%0,%0"}, {"sha": "1af328ec437256262047997690be95e006ad092f", "filename": "gcc/expmed.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/465e27163d08d2e8b1d962fb2892ffd3eaf5dd90/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/465e27163d08d2e8b1d962fb2892ffd3eaf5dd90/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=465e27163d08d2e8b1d962fb2892ffd3eaf5dd90", "patch": "@@ -2718,13 +2718,13 @@ expand_mult_highpart (mode, op0, cnst1, target, unsignedp, max_cost)\n   int size = GET_MODE_BITSIZE (mode);\n   rtx op1, wide_op1;\n \n-  /* We can't support modes wider than HOST_BITS_PER_INT.  */\n+  /* We can't support modes wider than HOST_BITS_PER_WIDE_INT.  */\n   if (size > HOST_BITS_PER_WIDE_INT)\n     abort ();\n \n-  op1 = GEN_INT (cnst1);\n+  op1 = GEN_INT (cnst1 | -(cnst1 & ((HOST_WIDE_INT) 1 << (size - 1))));\n \n-  if (GET_MODE_BITSIZE (wider_mode) <= HOST_BITS_PER_INT)\n+  if (GET_MODE_BITSIZE (wider_mode) <= HOST_BITS_PER_WIDE_INT)\n     wide_op1 = op1;\n   else\n     wide_op1\n@@ -3726,6 +3726,8 @@ expand_divmod (rem_flag, code, mode, op0, op1, target, unsignedp)\n \n \t    post_shift = floor_log2 (d & -d);\n \t    ml = invert_mod2n (d >> post_shift, size);\n+\t    /* Sign-extend ml for compute_mode.  */\n+\t    ml |= -(ml & (1 << (GET_MODE_BITSIZE (compute_mode)-1)));\n \t    t1 = expand_mult (compute_mode, op0, GEN_INT (ml), NULL_RTX,\n \t\t\t      unsignedp);\n \t    quotient = expand_shift (RSHIFT_EXPR, compute_mode, t1,"}, {"sha": "13dc4421ae661df7db9f2f17335cde4a0d7b454f", "filename": "gcc/md.texi", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/465e27163d08d2e8b1d962fb2892ffd3eaf5dd90/gcc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/465e27163d08d2e8b1d962fb2892ffd3eaf5dd90/gcc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmd.texi?ref=465e27163d08d2e8b1d962fb2892ffd3eaf5dd90", "patch": "@@ -1384,13 +1384,14 @@ Floating point register\n Signed 16 bit constant\n \n @item J\n-Constant whose low 16 bits are 0\n+Unsigned 16 bit constant shifted left 16 bits (use @samp{L} instead for \n+@code{SImode} constants)\n \n @item K\n-Constant whose high 16 bits are 0\n+Unsigned 16 bit constant\n \n @item L\n-Constant suitable as a mask operand\n+Signed 16 bit constant shifted left 16 bits\n \n @item M\n Constant larger than 31\n@@ -1418,6 +1419,9 @@ AIX TOC entry\n @item S\n Constant suitable as a 64-bit mask operand\n \n+@item T\n+Constant suitable as a 32-bit mask operand\n+\n @item U\n System V Release 4 small data area reference\n @end table"}, {"sha": "bad27764cfffe63cdd1f6da4b6121c7553a68b67", "filename": "gcc/optabs.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/465e27163d08d2e8b1d962fb2892ffd3eaf5dd90/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/465e27163d08d2e8b1d962fb2892ffd3eaf5dd90/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=465e27163d08d2e8b1d962fb2892ffd3eaf5dd90", "patch": "@@ -857,12 +857,12 @@ expand_binop (mode, binoptab, op0, op1, target, unsignedp, methods)\n       /* In case the insn wants input operands in modes different from\n \t the result, convert the operands.  */\n \n-      if (GET_MODE (op0) != VOIDmode\n+      if ((GET_MODE (op0) != VOIDmode || GET_CODE (op0) == CONST_INT)\n \t  && GET_MODE (op0) != mode0\n \t  && mode0 != VOIDmode)\n \txop0 = convert_to_mode (mode0, xop0, unsignedp);\n \n-      if (GET_MODE (xop1) != VOIDmode\n+      if ((GET_MODE (xop1) != VOIDmode || GET_CODE (xop1) == CONST_INT)\n \t  && GET_MODE (xop1) != mode1\n \t  && mode1 != VOIDmode)\n \txop1 = convert_to_mode (mode1, xop1, unsignedp);\n@@ -4231,7 +4231,7 @@ expand_fix (to, from, unsignedp)\n \t\t\t\t NULL_RTX, 0, OPTAB_LIB_WIDEN);\n \t  expand_fix (to, target, 0);\n \t  target = expand_binop (GET_MODE (to), xor_optab, to,\n-\t\t\t\t GEN_INT ((HOST_WIDE_INT) 1 << (bitsize - 1)),\n+\t\t\t\t GEN_INT ((HOST_WIDE_INT) -1 << (bitsize - 1)),\n \t\t\t\t to, 1, OPTAB_LIB_WIDEN);\n \n \t  if (target != to)"}, {"sha": "7ce3a38d6b3abf80793255e4975899f4d81d940d", "filename": "gcc/unroll.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/465e27163d08d2e8b1d962fb2892ffd3eaf5dd90/gcc%2Funroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/465e27163d08d2e8b1d962fb2892ffd3eaf5dd90/gcc%2Funroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funroll.c?ref=465e27163d08d2e8b1d962fb2892ffd3eaf5dd90", "patch": "@@ -3588,6 +3588,7 @@ loop_iterations (loop_start, loop_end, loop_info)\n   rtx comparison, comparison_value;\n   rtx iteration_var, initial_value, increment, final_value;\n   enum rtx_code comparison_code;\n+  enum machine_mode comparison_mode;\n   HOST_WIDE_INT abs_inc;\n   unsigned HOST_WIDE_INT abs_diff;\n   int off_by_one;\n@@ -3652,6 +3653,7 @@ loop_iterations (loop_start, loop_end, loop_info)\n      invariant register when it canonicalizes the comparison.  */\n \n   comparison_code = GET_CODE (comparison);\n+  comparison_mode = GET_MODE (comparison);\n   iteration_var = XEXP (comparison, 0);\n   comparison_value = XEXP (comparison, 1);\n \n@@ -3991,6 +3993,10 @@ loop_iterations (loop_start, loop_end, loop_info)\n   else\n     abort ();\n \n+  /* It may be that comparison_mode is smaller than a HOST_WIDE_INT,\n+     for instance on a 64-bit host when comparison_mode is SImode.  */\n+  abs_diff &= GET_MODE_MASK (comparison_mode);\n+\n   /* For NE tests, make sure that the iteration variable won't miss\n      the final value.  If abs_diff mod abs_incr is not zero, then the\n      iteration variable will overflow before the loop exits, and we"}]}