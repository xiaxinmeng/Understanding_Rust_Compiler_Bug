{"sha": "94990a843b6df9ff6010957d724dbb70bea94ceb", "node_id": "C_kwDOANBUbNoAKDk0OTkwYTg0M2I2ZGY5ZmY2MDEwOTU3ZDcyNGRiYjcwYmVhOTRjZWI", "commit": {"author": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2022-03-09T15:35:04Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2022-03-10T11:40:11Z"}, "message": "Refactor how we define simple intrinsics\n\nIntrinsics were hidden behind the GCC abstract. This removes it by keeping\nall of this logic within rust-intrinsic.cc so that we can make mappings of\nthe rustc name to GCC ones. We have a big comment from the mappings used\nover to LLVM builtins which we can use to help guide how we do this for\nGCC.", "tree": {"sha": "4a8668a80af92f29d659063b8e2f6ccb24ed4f13", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4a8668a80af92f29d659063b8e2f6ccb24ed4f13"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/94990a843b6df9ff6010957d724dbb70bea94ceb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/94990a843b6df9ff6010957d724dbb70bea94ceb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/94990a843b6df9ff6010957d724dbb70bea94ceb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/94990a843b6df9ff6010957d724dbb70bea94ceb/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a08ac0c27aed0c6d390d03656b708eb71381a5e9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a08ac0c27aed0c6d390d03656b708eb71381a5e9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a08ac0c27aed0c6d390d03656b708eb71381a5e9"}], "stats": {"total": 283, "additions": 143, "deletions": 140}, "files": [{"sha": "c57943cc379f03c6559b6b4c3b8ae9466e7b4349", "filename": "gcc/rust/backend/rust-compile-intrinsic.cc", "status": "modified", "additions": 143, "deletions": 54, "changes": 197, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94990a843b6df9ff6010957d724dbb70bea94ceb/gcc%2Frust%2Fbackend%2Frust-compile-intrinsic.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94990a843b6df9ff6010957d724dbb70bea94ceb/gcc%2Frust%2Fbackend%2Frust-compile-intrinsic.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-intrinsic.cc?ref=94990a843b6df9ff6010957d724dbb70bea94ceb", "patch": "@@ -15,13 +15,152 @@\n // <http://www.gnu.org/licenses/>.\n \n #include \"rust-compile-intrinsic.h\"\n+#include \"langhooks.h\"\n #include \"rust-compile-type.h\"\n #include \"rust-compile-fnparam.h\"\n #include \"rust-tree.h\"\n \n namespace Rust {\n namespace Compile {\n \n+// https://github.com/rust-lang/rust/blob/master/library/core/src/intrinsics.rs\n+// https://github.com/rust-lang/rust/blob/master/compiler/rustc_codegen_llvm/src/intrinsic.rs\n+// https://github.com/Rust-GCC/gccrs/issues/658\n+//\n+//   let llvm_name = match name {\n+//     sym::sqrtf32 => \"llvm.sqrt.f32\",\n+//     sym::sqrtf64 => \"llvm.sqrt.f64\",\n+//     sym::powif32 => \"llvm.powi.f32\",\n+//     sym::powif64 => \"llvm.powi.f64\",\n+//     sym::sinf32 => \"llvm.sin.f32\",\n+//     sym::sinf64 => \"llvm.sin.f64\",\n+//     sym::cosf32 => \"llvm.cos.f32\",\n+//     sym::cosf64 => \"llvm.cos.f64\",\n+//     sym::powf32 => \"llvm.pow.f32\",\n+//     sym::powf64 => \"llvm.pow.f64\",\n+//     sym::expf32 => \"llvm.exp.f32\",\n+//     sym::expf64 => \"llvm.exp.f64\",\n+//     sym::exp2f32 => \"llvm.exp2.f32\",\n+//     sym::exp2f64 => \"llvm.exp2.f64\",\n+//     sym::logf32 => \"llvm.log.f32\",\n+//     sym::logf64 => \"llvm.log.f64\",\n+//     sym::log10f32 => \"llvm.log10.f32\",\n+//     sym::log10f64 => \"llvm.log10.f64\",\n+//     sym::log2f32 => \"llvm.log2.f32\",\n+//     sym::log2f64 => \"llvm.log2.f64\",\n+//     sym::fmaf32 => \"llvm.fma.f32\",\n+//     sym::fmaf64 => \"llvm.fma.f64\",\n+//     sym::fabsf32 => \"llvm.fabs.f32\",\n+//     sym::fabsf64 => \"llvm.fabs.f64\",\n+//     sym::minnumf32 => \"llvm.minnum.f32\",\n+//     sym::minnumf64 => \"llvm.minnum.f64\",\n+//     sym::maxnumf32 => \"llvm.maxnum.f32\",\n+//     sym::maxnumf64 => \"llvm.maxnum.f64\",\n+//     sym::copysignf32 => \"llvm.copysign.f32\",\n+//     sym::copysignf64 => \"llvm.copysign.f64\",\n+//     sym::floorf32 => \"llvm.floor.f32\",\n+//     sym::floorf64 => \"llvm.floor.f64\",\n+//     sym::ceilf32 => \"llvm.ceil.f32\",\n+//     sym::ceilf64 => \"llvm.ceil.f64\",\n+//     sym::truncf32 => \"llvm.trunc.f32\",\n+//     sym::truncf64 => \"llvm.trunc.f64\",\n+//     sym::rintf32 => \"llvm.rint.f32\",\n+//     sym::rintf64 => \"llvm.rint.f64\",\n+//     sym::nearbyintf32 => \"llvm.nearbyint.f32\",\n+//     sym::nearbyintf64 => \"llvm.nearbyint.f64\",\n+//     sym::roundf32 => \"llvm.round.f32\",\n+//     sym::roundf64 => \"llvm.round.f64\",\n+//     _ => return None,\n+// };\n+// Some(cx.get_intrinsic(&llvm_name))\n+class SimpleIntrinsics\n+{\n+public:\n+  static SimpleIntrinsics &get ()\n+  {\n+    static SimpleIntrinsics instance;\n+    return instance;\n+  }\n+\n+  bool lookup_simple_builtin (const std::string &name, tree *builtin)\n+  {\n+    auto it = rust_intrinsic_to_gcc_builtin.find (name);\n+    if (it == rust_intrinsic_to_gcc_builtin.end ())\n+      return false;\n+\n+    return lookup_gcc_builtin (it->second, builtin);\n+  }\n+\n+private:\n+  static const int builtin_const = 1 << 0;\n+  static const int builtin_noreturn = 1 << 1;\n+  static const int builtin_novops = 1 << 2;\n+\n+  SimpleIntrinsics () { setup (); }\n+\n+  void setup ()\n+  {\n+    tree math_function_type_f32\n+      = build_function_type_list (float_type_node, float_type_node, NULL_TREE);\n+\n+    define_builtin (\"sinf32\", BUILT_IN_SINF, \"__builtin_sinf\", \"sinf\",\n+\t\t    math_function_type_f32, builtin_const);\n+\n+    define_builtin (\"sqrtf32\", BUILT_IN_SQRTF, \"__builtin_sqrtf\", \"sqrtf\",\n+\t\t    math_function_type_f32, builtin_const);\n+  }\n+\n+  // Define a builtin function.  BCODE is the builtin function code\n+  // defined by builtins.def.  NAME is the name of the builtin function.\n+  // LIBNAME is the name of the corresponding library function, and is\n+  // NULL if there isn't one.  FNTYPE is the type of the function.\n+  // CONST_P is true if the function has the const attribute.\n+  // NORETURN_P is true if the function has the noreturn attribute.\n+  void define_builtin (const std::string rust_name, built_in_function bcode,\n+\t\t       const char *name, const char *libname, tree fntype,\n+\t\t       int flags)\n+  {\n+    tree decl = add_builtin_function (name, fntype, bcode, BUILT_IN_NORMAL,\n+\t\t\t\t      libname, NULL_TREE);\n+    if ((flags & builtin_const) != 0)\n+      TREE_READONLY (decl) = 1;\n+    if ((flags & builtin_noreturn) != 0)\n+      TREE_THIS_VOLATILE (decl) = 1;\n+    if ((flags & builtin_novops) != 0)\n+      DECL_IS_NOVOPS (decl) = 1;\n+    set_builtin_decl (bcode, decl, true);\n+    this->builtin_functions_[name] = decl;\n+    if (libname != NULL)\n+      {\n+\tdecl = add_builtin_function (libname, fntype, bcode, BUILT_IN_NORMAL,\n+\t\t\t\t     NULL, NULL_TREE);\n+\tif ((flags & builtin_const) != 0)\n+\t  TREE_READONLY (decl) = 1;\n+\tif ((flags & builtin_noreturn) != 0)\n+\t  TREE_THIS_VOLATILE (decl) = 1;\n+\tif ((flags & builtin_novops) != 0)\n+\t  DECL_IS_NOVOPS (decl) = 1;\n+\tthis->builtin_functions_[libname] = decl;\n+      }\n+\n+    rust_intrinsic_to_gcc_builtin[rust_name] = name;\n+  }\n+\n+  bool lookup_gcc_builtin (const std::string &name, tree *builtin)\n+  {\n+    auto it = builtin_functions_.find (name);\n+    if (it == builtin_functions_.end ())\n+      return false;\n+\n+    *builtin = it->second;\n+    return true;\n+  }\n+\n+  // A mapping of the GCC built-ins exposed to GCC Rust.\n+  std::map<std::string, tree> builtin_functions_;\n+  std::map<std::string, std::string> rust_intrinsic_to_gcc_builtin;\n+};\n+\n static tree\n offset_intrinsic_handler (Context *ctx, TyTy::BaseType *fntype);\n \n@@ -36,60 +175,10 @@ Intrinsics::compile (TyTy::FnType *fntype)\n {\n   rust_assert (fntype->get_abi () == ABI::INTRINSIC);\n \n-  // https://github.com/rust-lang/rust/blob/master/library/core/src/intrinsics.rs\n-  // https://github.com/rust-lang/rust/blob/master/compiler/rustc_codegen_llvm/src/intrinsic.rs\n-  // https://github.com/Rust-GCC/gccrs/issues/658\n-\n-  //   let llvm_name = match name {\n-  //     sym::sqrtf32 => \"llvm.sqrt.f32\",\n-  //     sym::sqrtf64 => \"llvm.sqrt.f64\",\n-  //     sym::powif32 => \"llvm.powi.f32\",\n-  //     sym::powif64 => \"llvm.powi.f64\",\n-  //     sym::sinf32 => \"llvm.sin.f32\",\n-  //     sym::sinf64 => \"llvm.sin.f64\",\n-  //     sym::cosf32 => \"llvm.cos.f32\",\n-  //     sym::cosf64 => \"llvm.cos.f64\",\n-  //     sym::powf32 => \"llvm.pow.f32\",\n-  //     sym::powf64 => \"llvm.pow.f64\",\n-  //     sym::expf32 => \"llvm.exp.f32\",\n-  //     sym::expf64 => \"llvm.exp.f64\",\n-  //     sym::exp2f32 => \"llvm.exp2.f32\",\n-  //     sym::exp2f64 => \"llvm.exp2.f64\",\n-  //     sym::logf32 => \"llvm.log.f32\",\n-  //     sym::logf64 => \"llvm.log.f64\",\n-  //     sym::log10f32 => \"llvm.log10.f32\",\n-  //     sym::log10f64 => \"llvm.log10.f64\",\n-  //     sym::log2f32 => \"llvm.log2.f32\",\n-  //     sym::log2f64 => \"llvm.log2.f64\",\n-  //     sym::fmaf32 => \"llvm.fma.f32\",\n-  //     sym::fmaf64 => \"llvm.fma.f64\",\n-  //     sym::fabsf32 => \"llvm.fabs.f32\",\n-  //     sym::fabsf64 => \"llvm.fabs.f64\",\n-  //     sym::minnumf32 => \"llvm.minnum.f32\",\n-  //     sym::minnumf64 => \"llvm.minnum.f64\",\n-  //     sym::maxnumf32 => \"llvm.maxnum.f32\",\n-  //     sym::maxnumf64 => \"llvm.maxnum.f64\",\n-  //     sym::copysignf32 => \"llvm.copysign.f32\",\n-  //     sym::copysignf64 => \"llvm.copysign.f64\",\n-  //     sym::floorf32 => \"llvm.floor.f32\",\n-  //     sym::floorf64 => \"llvm.floor.f64\",\n-  //     sym::ceilf32 => \"llvm.ceil.f32\",\n-  //     sym::ceilf64 => \"llvm.ceil.f64\",\n-  //     sym::truncf32 => \"llvm.trunc.f32\",\n-  //     sym::truncf64 => \"llvm.trunc.f64\",\n-  //     sym::rintf32 => \"llvm.rint.f32\",\n-  //     sym::rintf64 => \"llvm.rint.f64\",\n-  //     sym::nearbyintf32 => \"llvm.nearbyint.f32\",\n-  //     sym::nearbyintf64 => \"llvm.nearbyint.f64\",\n-  //     sym::roundf32 => \"llvm.round.f32\",\n-  //     sym::roundf64 => \"llvm.round.f64\",\n-  //     _ => return None,\n-  // };\n-  // Some(cx.get_intrinsic(&llvm_name))\n-\n-  tree builtin = ctx->get_backend ()->lookup_builtin_by_rust_name (\n-    fntype->get_identifier ());\n-  if (builtin != nullptr)\n+  tree builtin = error_mark_node;\n+  SimpleIntrinsics &simple_intrinsics = SimpleIntrinsics::get ();\n+  if (simple_intrinsics.lookup_simple_builtin (fntype->get_identifier (),\n+\t\t\t\t\t       &builtin))\n     return builtin;\n \n   // is it an generic builtin?"}, {"sha": "6bfebe3d5c2fe413b9598a82f01dbe5943c83eac", "filename": "gcc/rust/rust-backend.h", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94990a843b6df9ff6010957d724dbb70bea94ceb/gcc%2Frust%2Frust-backend.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94990a843b6df9ff6010957d724dbb70bea94ceb/gcc%2Frust%2Frust-backend.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-backend.h?ref=94990a843b6df9ff6010957d724dbb70bea94ceb", "patch": "@@ -504,12 +504,6 @@ class Backend\n \t\t\t   const std::vector<Bvariable *> &param_vars)\n     = 0;\n \n-  // Look up a named built-in function in the current backend implementation.\n-  // Returns NULL if no built-in function by that name exists.\n-  virtual tree lookup_gcc_builtin (const std::string &) = 0;\n-\n-  virtual tree lookup_builtin_by_rust_name (const std::string &) = 0;\n-\n   // Utility.\n \n   // Write the definitions for all TYPE_DECLS, CONSTANT_DECLS,"}, {"sha": "6ea9ef3e44e03088abd33a58c9fcb6183b9c605d", "filename": "gcc/rust/rust-gcc.cc", "status": "modified", "additions": 0, "deletions": 80, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94990a843b6df9ff6010957d724dbb70bea94ceb/gcc%2Frust%2Frust-gcc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94990a843b6df9ff6010957d724dbb70bea94ceb/gcc%2Frust%2Frust-gcc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-gcc.cc?ref=94990a843b6df9ff6010957d724dbb70bea94ceb", "patch": "@@ -344,19 +344,6 @@ class Gcc_backend : public Backend\n   tree non_zero_size_type (tree);\n \n   tree convert_tree (tree, tree, Location);\n-\n-private:\n-  static const int builtin_const = 1 << 0;\n-  static const int builtin_noreturn = 1 << 1;\n-  static const int builtin_novops = 1 << 2;\n-\n-  void define_builtin (const std::string rust_name, built_in_function bcode,\n-\t\t       const char *name, const char *libname, tree fntype,\n-\t\t       int flags);\n-\n-  // A mapping of the GCC built-ins exposed to GCCRust.\n-  std::map<std::string, tree> builtin_functions_;\n-  std::map<std::string, std::string> rust_intrinsic_to_gcc_builtin;\n };\n \n // A helper function to create a GCC identifier from a C++ string.\n@@ -473,14 +460,6 @@ Gcc_backend::Gcc_backend ()\n   //       \t\tbuiltin_const);\n \n   // We provide some functions for the math library.\n-  tree math_function_type_f32\n-    = build_function_type_list (float_type_node, float_type_node, NULL_TREE);\n-\n-  this->define_builtin (\"sinf32\", BUILT_IN_SINF, \"__builtin_sinf\", \"sinf\",\n-\t\t\tmath_function_type_f32, builtin_const);\n-\n-  this->define_builtin (\"sqrtf32\", BUILT_IN_SQRTF, \"__builtin_sqrtf\", \"sqrtf\",\n-\t\t\tmath_function_type_f32, builtin_const);\n \n   // We use __builtin_return_address in the thunk we build for\n   // functions which call recover, and for runtime.getcallerpc.\n@@ -2661,27 +2640,6 @@ Gcc_backend::function_set_parameters (\n   return true;\n }\n \n-// Look up a named built-in function in the current backend implementation.\n-// Returns NULL if no built-in function by that name exists.\n-\n-tree\n-Gcc_backend::lookup_gcc_builtin (const std::string &name)\n-{\n-  if (this->builtin_functions_.count (name) != 0)\n-    return this->builtin_functions_[name];\n-  return NULL;\n-}\n-\n-tree\n-Gcc_backend::lookup_builtin_by_rust_name (const std::string &name)\n-{\n-  auto it = rust_intrinsic_to_gcc_builtin.find (name);\n-  if (it == rust_intrinsic_to_gcc_builtin.end ())\n-    return NULL;\n-\n-  return lookup_gcc_builtin (it->second);\n-}\n-\n // Write the definitions for all TYPE_DECLS, CONSTANT_DECLS,\n // FUNCTION_DECLS, and VARIABLE_DECLS declared globally, as well as\n // emit early debugging information.\n@@ -2763,44 +2721,6 @@ Gcc_backend::write_export_data (const char *bytes, unsigned int size)\n   rust_write_export_data (bytes, size);\n }\n \n-// Define a builtin function.  BCODE is the builtin function code\n-// defined by builtins.def.  NAME is the name of the builtin function.\n-// LIBNAME is the name of the corresponding library function, and is\n-// NULL if there isn't one.  FNTYPE is the type of the function.\n-// CONST_P is true if the function has the const attribute.\n-// NORETURN_P is true if the function has the noreturn attribute.\n-\n-void\n-Gcc_backend::define_builtin (const std::string rust_name,\n-\t\t\t     built_in_function bcode, const char *name,\n-\t\t\t     const char *libname, tree fntype, int flags)\n-{\n-  tree decl = add_builtin_function (name, fntype, bcode, BUILT_IN_NORMAL,\n-\t\t\t\t    libname, NULL_TREE);\n-  if ((flags & builtin_const) != 0)\n-    TREE_READONLY (decl) = 1;\n-  if ((flags & builtin_noreturn) != 0)\n-    TREE_THIS_VOLATILE (decl) = 1;\n-  if ((flags & builtin_novops) != 0)\n-    DECL_IS_NOVOPS (decl) = 1;\n-  set_builtin_decl (bcode, decl, true);\n-  this->builtin_functions_[name] = decl;\n-  if (libname != NULL)\n-    {\n-      decl = add_builtin_function (libname, fntype, bcode, BUILT_IN_NORMAL,\n-\t\t\t\t   NULL, NULL_TREE);\n-      if ((flags & builtin_const) != 0)\n-\tTREE_READONLY (decl) = 1;\n-      if ((flags & builtin_noreturn) != 0)\n-\tTREE_THIS_VOLATILE (decl) = 1;\n-      if ((flags & builtin_novops) != 0)\n-\tDECL_IS_NOVOPS (decl) = 1;\n-      this->builtin_functions_[libname] = decl;\n-    }\n-\n-  rust_intrinsic_to_gcc_builtin[rust_name] = name;\n-}\n-\n // Return the backend generator.\n \n Backend *"}]}