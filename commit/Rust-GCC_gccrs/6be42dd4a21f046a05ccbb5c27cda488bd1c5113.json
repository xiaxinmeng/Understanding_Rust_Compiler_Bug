{"sha": "6be42dd4a21f046a05ccbb5c27cda488bd1c5113", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmJlNDJkZDRhMjFmMDQ2YTA1Y2NiYjVjMjdjZGE0ODhiZDFjNTExMw==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2007-03-31T14:07:29Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2007-03-31T14:07:29Z"}, "message": "omp-low.c (splay-tree.h): Include.\n\n2007-03-31  Richard Guenther  <rguenther@suse.de>\n\n\t* omp-low.c (splay-tree.h): Include.\n\t(lookup_decl): Replace splay-tree usage by pointer-map.\n\t(maybe_lookup_decl): Likewise.\n\t(new_omp_context): Likewise.\n\t(delete_omp_context): Likewise.\n\t* gimplify.c (splay-tree.h): Include.\n\t* tree-inline.c (insert_decl_map): Replace splay-tree usage by\n\tpointer-map.\n\t(remap_ssa_name): Likewise.\n\t(remap_decl): Likewise.\n\t(remap_type_1): Likewise.\n\t(remap_type): Likewise.\n\t(copy_body_r): Likewise.\n\t(expand_call_inline): Likewise.\n\t(clone_body): Likewise.\n\t(copy_tree_r): Likewise.\n\t(remap_save_expr): Likewise.\n\t(unsave_r): Likewise.\n\t(unsave_expr_now): Likewise.\n\t(tree_function_versioning): Likewise.\n\t(build_duplicate_type): Likewise.\n\t* tree-inline.h (pointer-set.h): Include instead of splay-tree.h.\n\t(struct copy_body_data): Replace splay-tree by pointer-map.\n\t* Makefile.in (TREE_INLINE_H): Depend on pointer-map.h, not $(SPLAY_TREE_H).\n\t(gimplify.o): Depend on $(SPLAY_TREE_H).\n\t(omp-low.p): Likewise.\n\n\t* optimize.c (maybe_clone_body): Replace splay-tree usage by\n\tpointer-map.\n\nFrom-SVN: r123381", "tree": {"sha": "e35d13b4ee94edc9550a7d68aaf4c9f58eb9c1b3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e35d13b4ee94edc9550a7d68aaf4c9f58eb9c1b3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6be42dd4a21f046a05ccbb5c27cda488bd1c5113", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6be42dd4a21f046a05ccbb5c27cda488bd1c5113", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6be42dd4a21f046a05ccbb5c27cda488bd1c5113", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6be42dd4a21f046a05ccbb5c27cda488bd1c5113/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d393153e7fb5a4bc1ed79b72c5c6d6c6ccc195b6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d393153e7fb5a4bc1ed79b72c5c6d6c6ccc195b6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d393153e7fb5a4bc1ed79b72c5c6d6c6ccc195b6"}], "stats": {"total": 183, "additions": 103, "deletions": 80}, "files": [{"sha": "4d6609fe3e815c89c7bae11323fcd149c4467004", "filename": "gcc/ChangeLog", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6be42dd4a21f046a05ccbb5c27cda488bd1c5113/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6be42dd4a21f046a05ccbb5c27cda488bd1c5113/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6be42dd4a21f046a05ccbb5c27cda488bd1c5113", "patch": "@@ -1,3 +1,33 @@\n+2007-03-31  Richard Guenther  <rguenther@suse.de>\n+\n+\t* omp-low.c (splay-tree.h): Include.\n+\t(lookup_decl): Replace splay-tree usage by pointer-map.\n+\t(maybe_lookup_decl): Likewise.\n+\t(new_omp_context): Likewise.\n+\t(delete_omp_context): Likewise.\n+\t* gimplify.c (splay-tree.h): Include.\n+\t* tree-inline.c (insert_decl_map): Replace splay-tree usage by\n+\tpointer-map.\n+\t(remap_ssa_name): Likewise.\n+\t(remap_decl): Likewise.\n+\t(remap_type_1): Likewise.\n+\t(remap_type): Likewise.\n+\t(copy_body_r): Likewise.\n+\t(expand_call_inline): Likewise.\n+\t(clone_body): Likewise.\n+\t(copy_tree_r): Likewise.\n+\t(remap_save_expr): Likewise.\n+\t(unsave_r): Likewise.\n+\t(unsave_expr_now): Likewise.\n+\t(tree_function_versioning): Likewise.\n+\t(build_duplicate_type): Likewise.\n+\t* tree-inline.h (pointer-set.h): Include instead of splay-tree.h.\n+\t(struct copy_body_data): Replace splay-tree by pointer-map.\n+\t* Makefile.in (TREE_INLINE_H): Depend on pointer-map.h,\n+\tnot $(SPLAY_TREE_H).\n+\t(gimplify.o): Depend on $(SPLAY_TREE_H).\n+\t(omp-low.p): Likewise.\n+\n 2007-03-31  Anatoly Sokolov <aesok@post.ru>\n \n \t* config/avr/predicates.md (even_register_operand, "}, {"sha": "d1ce5d4ca55e64428c0b2d0df2150e2d54cdd48b", "filename": "gcc/Makefile.in", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6be42dd4a21f046a05ccbb5c27cda488bd1c5113/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6be42dd4a21f046a05ccbb5c27cda488bd1c5113/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=6be42dd4a21f046a05ccbb5c27cda488bd1c5113", "patch": "@@ -787,7 +787,7 @@ SCEV_H = tree-scalar-evolution.h $(GGC_H) tree-chrec.h $(PARAMS_H)\n LAMBDA_H = lambda.h $(TREE_H) vec.h $(GGC_H)\n TREE_DATA_REF_H = tree-data-ref.h $(LAMBDA_H) omega.h\n VARRAY_H = varray.h $(MACHMODE_H) $(SYSTEM_H) coretypes.h $(TM_H)\n-TREE_INLINE_H = tree-inline.h $(VARRAY_H) $(SPLAY_TREE_H)\n+TREE_INLINE_H = tree-inline.h $(VARRAY_H) pointer-set.h\n REAL_H = real.h $(MACHMODE_H)\n \n #\f\n@@ -2180,7 +2180,7 @@ gimplify.o : gimplify.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) \\\n    $(LANGHOOKS_DEF_H) $(TREE_FLOW_H) $(CGRAPH_H) $(TIMEVAR_H) $(TM_H) \\\n    coretypes.h except.h $(FLAGS_H) $(RTL_H) $(FUNCTION_H) $(EXPR_H) output.h \\\n    $(GGC_H) gt-gimplify.h $(HASHTAB_H) $(TARGET_H) toplev.h $(OPTABS_H) \\\n-   $(REAL_H)\n+   $(REAL_H) $(SPLAY_TREE_H)\n gimple-low.o : gimple-low.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) \\\n    $(DIAGNOSTIC_H) $(TREE_GIMPLE_H) $(TREE_INLINE_H) $(VARRAY_H) langhooks.h \\\n    $(LANGHOOKS_DEF_H) $(TREE_FLOW_H) $(TIMEVAR_H) $(TM_H) coretypes.h \\\n@@ -2189,7 +2189,7 @@ gimple-low.o : gimple-low.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) \\\n omp-low.o : omp-low.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n    $(RTL_H) $(TREE_GIMPLE_H) $(TREE_INLINE_H) langhooks.h $(DIAGNOSTIC_H) \\\n    $(TREE_FLOW_H) $(TIMEVAR_H) $(FLAGS_H) $(EXPR_H) toplev.h tree-pass.h \\\n-   $(GGC_H)\n+   $(GGC_H) $(SPLAY_TREE_H)\n tree-browser.o : tree-browser.c tree-browser.def $(CONFIG_H) $(SYSTEM_H) \\\n    $(TREE_H) $(TREE_INLINE_H) $(DIAGNOSTIC_H) $(HASHTAB_H) \\\n    $(TM_H) coretypes.h"}, {"sha": "49211160400b419eb6a052cde75fe4b46fa735fb", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6be42dd4a21f046a05ccbb5c27cda488bd1c5113/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6be42dd4a21f046a05ccbb5c27cda488bd1c5113/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=6be42dd4a21f046a05ccbb5c27cda488bd1c5113", "patch": "@@ -1,3 +1,8 @@\n+2007-03-31  Richard Guenther  <rguenther@suse.de>\n+\n+\t* optimize.c (maybe_clone_body): Replace splay-tree usage by\n+\tpointer-map.\n+\n 2007-03-31  Douglas Gregor  <doug.gregor@gmail.com>\n \n \tPR c++/31138"}, {"sha": "1b508251164e1cc123a43941837aa8a523dc1f83", "filename": "gcc/cp/optimize.c", "status": "modified", "additions": 8, "deletions": 19, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6be42dd4a21f046a05ccbb5c27cda488bd1c5113/gcc%2Fcp%2Foptimize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6be42dd4a21f046a05ccbb5c27cda488bd1c5113/gcc%2Fcp%2Foptimize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Foptimize.c?ref=6be42dd4a21f046a05ccbb5c27cda488bd1c5113", "patch": "@@ -99,7 +99,7 @@ maybe_clone_body (tree fn)\n       tree parm;\n       tree clone_parm;\n       int parmno;\n-      splay_tree decl_map;\n+      struct pointer_map_t *decl_map;\n \n       /* Update CLONE's source position information to match FN's.  */\n       DECL_SOURCE_LOCATION (clone) = DECL_SOURCE_LOCATION (fn);\n@@ -139,7 +139,7 @@ maybe_clone_body (tree fn)\n       start_preparsed_function (clone, NULL_TREE, SF_PRE_PARSED);\n \n       /* Remap the parameters.  */\n-      decl_map = splay_tree_new (splay_tree_compare_pointers, NULL, NULL);\n+      decl_map = pointer_map_create ();\n       for (parmno = 0,\n \t     parm = DECL_ARGUMENTS (fn),\n \t     clone_parm = DECL_ARGUMENTS (clone);\n@@ -152,9 +152,7 @@ maybe_clone_body (tree fn)\n \t    {\n \t      tree in_charge;\n \t      in_charge = in_charge_arg_for_name (DECL_NAME (clone));\n-\t      splay_tree_insert (decl_map,\n-\t\t\t\t (splay_tree_key) parm,\n-\t\t\t\t (splay_tree_value) in_charge);\n+\t      *pointer_map_insert (decl_map, parm) = in_charge;\n \t    }\n \t  else if (DECL_ARTIFICIAL (parm)\n \t\t   && DECL_NAME (parm) == vtt_parm_identifier)\n@@ -165,26 +163,18 @@ maybe_clone_body (tree fn)\n \t      if (DECL_HAS_VTT_PARM_P (clone))\n \t\t{\n \t\t  DECL_ABSTRACT_ORIGIN (clone_parm) = parm;\n-\t\t  splay_tree_insert (decl_map,\n-\t\t\t\t     (splay_tree_key) parm,\n-\t\t\t\t     (splay_tree_value) clone_parm);\n+\t\t  *pointer_map_insert (decl_map, parm) = clone_parm;\n \t\t  clone_parm = TREE_CHAIN (clone_parm);\n \t\t}\n \t      /* Otherwise, map the VTT parameter to `NULL'.  */\n \t      else\n-\t\t{\n-\t\t  splay_tree_insert (decl_map,\n-\t\t\t\t     (splay_tree_key) parm,\n-\t\t\t\t     (splay_tree_value) null_pointer_node);\n-\t\t}\n+\t\t*pointer_map_insert (decl_map, parm) = null_pointer_node;\n \t    }\n \t  /* Map other parameters to their equivalents in the cloned\n \t     function.  */\n \t  else\n \t    {\n-\t      splay_tree_insert (decl_map,\n-\t\t\t\t (splay_tree_key) parm,\n-\t\t\t\t (splay_tree_value) clone_parm);\n+\t      *pointer_map_insert (decl_map, parm) = clone_parm;\n \t      clone_parm = TREE_CHAIN (clone_parm);\n \t    }\n \t}\n@@ -193,14 +183,13 @@ maybe_clone_body (tree fn)\n \t{\n \t  parm = DECL_RESULT (fn);\n \t  clone_parm = DECL_RESULT (clone);\n-\t  splay_tree_insert (decl_map, (splay_tree_key) parm,\n-\t\t\t     (splay_tree_value) clone_parm);\n+\t  *pointer_map_insert (decl_map, parm) = clone_parm;\n \t}\n       /* Clone the body.  */\n       clone_body (clone, fn, decl_map);\n \n       /* Clean up.  */\n-      splay_tree_delete (decl_map);\n+      pointer_map_destroy (decl_map);\n \n       /* The clone can throw iff the original function can throw.  */\n       cp_function_chain->can_throw = !TREE_NOTHROW (fn);"}, {"sha": "8bedd86dad9d0347b5e9ebe0e76ef38df52469cd", "filename": "gcc/gimplify.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6be42dd4a21f046a05ccbb5c27cda488bd1c5113/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6be42dd4a21f046a05ccbb5c27cda488bd1c5113/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=6be42dd4a21f046a05ccbb5c27cda488bd1c5113", "patch": "@@ -49,6 +49,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"target.h\"\n #include \"optabs.h\"\n #include \"pointer-set.h\"\n+#include \"splay-tree.h\"\n \n \n enum gimplify_omp_var_data"}, {"sha": "f176f9e410215b60942770b52892b4f591ea7efa", "filename": "gcc/omp-low.c", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6be42dd4a21f046a05ccbb5c27cda488bd1c5113/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6be42dd4a21f046a05ccbb5c27cda488bd1c5113/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=6be42dd4a21f046a05ccbb5c27cda488bd1c5113", "patch": "@@ -41,6 +41,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"tree-pass.h\"\n #include \"ggc.h\"\n #include \"except.h\"\n+#include \"splay-tree.h\"\n \n \n /* Lowering of OpenMP parallel and workshare constructs proceeds in two \n@@ -441,17 +442,17 @@ is_reference (tree decl)\n static inline tree\n lookup_decl (tree var, omp_context *ctx)\n {\n-  splay_tree_node n;\n-  n = splay_tree_lookup (ctx->cb.decl_map, (splay_tree_key) var);\n-  return (tree) n->value;\n+  tree *n;\n+  n = (tree *) pointer_map_contains (ctx->cb.decl_map, var);\n+  return *n;\n }\n \n static inline tree\n maybe_lookup_decl (tree var, omp_context *ctx)\n {\n-  splay_tree_node n;\n-  n = splay_tree_lookup (ctx->cb.decl_map, (splay_tree_key) var);\n-  return n ? (tree) n->value : NULL_TREE;\n+  tree *n;\n+  n = (tree *) pointer_map_contains (ctx->cb.decl_map, var);\n+  return n ? *n : NULL_TREE;\n }\n \n static inline tree\n@@ -844,7 +845,7 @@ new_omp_context (tree stmt, omp_context *outer_ctx)\n       ctx->depth = 1;\n     }\n \n-  ctx->cb.decl_map = splay_tree_new (splay_tree_compare_pointers, 0, 0);\n+  ctx->cb.decl_map = pointer_map_create ();\n \n   return ctx;\n }\n@@ -857,7 +858,7 @@ delete_omp_context (splay_tree_value value)\n {\n   omp_context *ctx = (omp_context *) value;\n \n-  splay_tree_delete (ctx->cb.decl_map);\n+  pointer_map_destroy (ctx->cb.decl_map);\n \n   if (ctx->field_map)\n     splay_tree_delete (ctx->field_map);"}, {"sha": "25844a6701bb11fb57ceda1d3749723308e2de00", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 45, "deletions": 48, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6be42dd4a21f046a05ccbb5c27cda488bd1c5113/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6be42dd4a21f046a05ccbb5c27cda488bd1c5113/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=6be42dd4a21f046a05ccbb5c27cda488bd1c5113", "patch": "@@ -148,14 +148,12 @@ static tree copy_decl_maybe_to_var (tree, copy_body_data *);\n void\n insert_decl_map (copy_body_data *id, tree key, tree value)\n {\n-  splay_tree_insert (id->decl_map, (splay_tree_key) key,\n-\t\t     (splay_tree_value) value);\n+  *pointer_map_insert (id->decl_map, key) = value;\n \n   /* Always insert an identity map as well.  If we see this same new\n      node again, we won't want to duplicate it a second time.  */\n   if (key != value)\n-    splay_tree_insert (id->decl_map, (splay_tree_key) value,\n-\t\t       (splay_tree_value) value);\n+    *pointer_map_insert (id->decl_map, value) = value;\n }\n \n /* Construct new SSA name for old NAME. ID is the inline context.  */\n@@ -164,13 +162,13 @@ static tree\n remap_ssa_name (tree name, copy_body_data *id)\n {\n   tree new;\n-  splay_tree_node n;\n+  tree *n;\n \n   gcc_assert (TREE_CODE (name) == SSA_NAME);\n \n-  n = splay_tree_lookup (id->decl_map, (splay_tree_key) name);\n+  n = (tree *) pointer_map_contains (id->decl_map, name);\n   if (n)\n-    return (tree) n->value;\n+    return *n;\n \n   /* Do not set DEF_STMT yet as statement is not copied yet. We do that\n      in copy_bb.  */\n@@ -207,15 +205,15 @@ remap_ssa_name (tree name, copy_body_data *id)\n tree\n remap_decl (tree decl, copy_body_data *id)\n {\n-  splay_tree_node n;\n+  tree *n;\n   tree fn;\n \n   /* We only remap local variables in the current function.  */\n   fn = id->src_fn;\n \n   /* See if we have remapped this declaration.  */\n \n-  n = splay_tree_lookup (id->decl_map, (splay_tree_key) decl);\n+  n = (tree *) pointer_map_contains (id->decl_map, decl);\n \n   /* If we didn't already have an equivalent for this declaration,\n      create one now.  */\n@@ -268,22 +266,22 @@ remap_decl (tree decl, copy_body_data *id)\n       return t;\n     }\n \n-  return unshare_expr ((tree) n->value);\n+  return unshare_expr (*n);\n }\n \n static tree\n remap_type_1 (tree type, copy_body_data *id)\n {\n-  splay_tree_node node;\n+  tree *node;\n   tree new, t;\n \n   if (type == NULL)\n     return type;\n \n   /* See if we have remapped this type.  */\n-  node = splay_tree_lookup (id->decl_map, (splay_tree_key) type);\n+  node = (tree *) pointer_map_contains (id->decl_map, type);\n   if (node)\n-    return (tree) node->value;\n+    return *node;\n \n   /* The type only needs remapping if it's variably modified.  */\n   if (! variably_modified_type_p (type, id->src_fn))\n@@ -396,15 +394,15 @@ remap_type_1 (tree type, copy_body_data *id)\n tree\n remap_type (tree type, copy_body_data *id)\n {\n-  splay_tree_node node;\n+  tree *node;\n \n   if (type == NULL)\n     return type;\n \n   /* See if we have remapped this type.  */\n-  node = splay_tree_lookup (id->decl_map, (splay_tree_key) type);\n+  node = (tree *) pointer_map_contains (id->decl_map, type);\n   if (node)\n-    return (tree) node->value;\n+    return *node;\n \n   /* The type only needs remapping if it's variably modified.  */\n   if (! variably_modified_type_p (type, id->src_fn))\n@@ -650,12 +648,12 @@ copy_body_r (tree *tp, int *walk_subtrees, void *data)\n \t     and thus don't count as variable modification.  Avoid\n \t     keeping bogosities like 0 = 0.  */\n \t  tree decl = GIMPLE_STMT_OPERAND (*tp, 0), value;\n-\t  splay_tree_node n;\n+\t  tree *n;\n \n-\t  n = splay_tree_lookup (id->decl_map, (splay_tree_key) decl);\n+\t  n = (tree *) pointer_map_contains (id->decl_map, decl);\n \t  if (n)\n \t    {\n-\t      value = (tree) n->value;\n+\t      value = *n;\n \t      STRIP_TYPE_NOPS (value);\n \t      if (TREE_CONSTANT (value) || TREE_READONLY_DECL_P (value))\n \t\t{\n@@ -669,9 +667,9 @@ copy_body_r (tree *tp, int *walk_subtrees, void *data)\n \t  /* Get rid of *& from inline substitutions that can happen when a\n \t     pointer argument is an ADDR_EXPR.  */\n \t  tree decl = TREE_OPERAND (*tp, 0);\n-\t  splay_tree_node n;\n+\t  tree *n;\n \n-\t  n = splay_tree_lookup (id->decl_map, (splay_tree_key) decl);\n+\t  n = (tree *) pointer_map_contains (id->decl_map, decl);\n \t  if (n)\n \t    {\n \t      tree new;\n@@ -682,8 +680,8 @@ copy_body_r (tree *tp, int *walk_subtrees, void *data)\n \t\t build_fold_indirect_ref wouldn't strip the INDIRECT_REF,\n \t\t but we absolutely rely on that.  As fold_indirect_ref\n \t         does other useful transformations, try that first, though.  */\n-\t      tree type = TREE_TYPE (TREE_TYPE ((tree)n->value));\n-\t      new = unshare_expr ((tree)n->value);\n+\t      tree type = TREE_TYPE (TREE_TYPE (*n));\n+\t      new = unshare_expr (*n);\n \t      old = *tp;\n \t      *tp = fold_indirect_ref_1 (type, new);\n \t      if (! *tp)\n@@ -718,11 +716,11 @@ copy_body_r (tree *tp, int *walk_subtrees, void *data)\n \t  new_block = id->block;\n \t  if (TREE_BLOCK (*tp))\n \t    {\n-\t      splay_tree_node n;\n-\t      n = splay_tree_lookup (id->decl_map,\n-\t\t\t\t     (splay_tree_key) TREE_BLOCK (*tp));\n+\t      tree *n;\n+\t      n = (tree *) pointer_map_contains (id->decl_map,\n+\t\t\t\t\t\t TREE_BLOCK (*tp));\n \t      gcc_assert (n);\n-\t      new_block = (tree) n->value;\n+\t      new_block = *n;\n \t    }\n \t  TREE_BLOCK (*tp) = new_block;\n \t}\n@@ -2354,7 +2352,7 @@ expand_call_inline (basic_block bb, tree stmt, tree *tp, void *data)\n   tree t;\n   tree use_retvar;\n   tree fn;\n-  splay_tree st;\n+  struct pointer_map_t *st;\n   tree return_slot;\n   tree modify_dest;\n   location_t saved_location;\n@@ -2509,8 +2507,7 @@ expand_call_inline (basic_block bb, tree stmt, tree *tp, void *data)\n   /* Local declarations will be replaced by their equivalents in this\n      map.  */\n   st = id->decl_map;\n-  id->decl_map = splay_tree_new (splay_tree_compare_pointers,\n-\t\t\t\t NULL, NULL);\n+  id->decl_map = pointer_map_create ();\n \n   /* Record the function we are about to inline.  */\n   id->src_fn = fn;\n@@ -2576,7 +2573,7 @@ expand_call_inline (basic_block bb, tree stmt, tree *tp, void *data)\n     }\n \n   /* Clean up.  */\n-  splay_tree_delete (id->decl_map);\n+  pointer_map_destroy (id->decl_map);\n   id->decl_map = st;\n \n   /* If the inlined function returns a result that we care about,\n@@ -2870,7 +2867,7 @@ clone_body (tree clone, tree fn, void *arg_map)\n   id.src_fn = fn;\n   id.dst_fn = clone;\n   id.src_cfun = DECL_STRUCT_FUNCTION (fn);\n-  id.decl_map = (splay_tree)arg_map;\n+  id.decl_map = (struct pointer_map_t *)arg_map;\n \n   id.copy_decl = copy_decl_no_change;\n   id.transform_call_graph_edges = CB_CGE_DUPLICATE;\n@@ -2964,28 +2961,28 @@ copy_tree_r (tree *tp, int *walk_subtrees, void *data ATTRIBUTE_UNUSED)\n static void\n remap_save_expr (tree *tp, void *st_, int *walk_subtrees)\n {\n-  splay_tree st = (splay_tree) st_;\n-  splay_tree_node n;\n+  struct pointer_map_t *st = (struct pointer_map_t *) st_;\n+  tree *n;\n   tree t;\n \n   /* See if we already encountered this SAVE_EXPR.  */\n-  n = splay_tree_lookup (st, (splay_tree_key) *tp);\n+  n = (tree *) pointer_map_contains (st, *tp);\n \n   /* If we didn't already remap this SAVE_EXPR, do so now.  */\n   if (!n)\n     {\n       t = copy_node (*tp);\n \n       /* Remember this SAVE_EXPR.  */\n-      splay_tree_insert (st, (splay_tree_key) *tp, (splay_tree_value) t);\n+      *pointer_map_insert (st, *tp) = t;\n       /* Make sure we don't remap an already-remapped SAVE_EXPR.  */\n-      splay_tree_insert (st, (splay_tree_key) t, (splay_tree_value) t);\n+      *pointer_map_insert (st, t) = t;\n     }\n   else\n     {\n       /* We've already walked into this SAVE_EXPR; don't do it again.  */\n       *walk_subtrees = 0;\n-      t = (tree) n->value;\n+      t = *n;\n     }\n \n   /* Replace this SAVE_EXPR with the copy.  */\n@@ -3050,19 +3047,19 @@ static tree\n unsave_r (tree *tp, int *walk_subtrees, void *data)\n {\n   copy_body_data *id = (copy_body_data *) data;\n-  splay_tree st = id->decl_map;\n-  splay_tree_node n;\n+  struct pointer_map_t *st = id->decl_map;\n+  tree *n;\n \n   /* Only a local declaration (variable or label).  */\n   if ((TREE_CODE (*tp) == VAR_DECL && !TREE_STATIC (*tp))\n       || TREE_CODE (*tp) == LABEL_DECL)\n     {\n       /* Lookup the declaration.  */\n-      n = splay_tree_lookup (st, (splay_tree_key) *tp);\n+      n = (tree *) pointer_map_contains (st, *tp);\n \n       /* If it's there, remap it.  */\n       if (n)\n-\t*tp = (tree) n->value;\n+\t*tp = *n;\n     }\n \n   else if (TREE_CODE (*tp) == STATEMENT_LIST)\n@@ -3099,7 +3096,7 @@ unsave_expr_now (tree expr)\n   memset (&id, 0, sizeof (id));\n   id.src_fn = current_function_decl;\n   id.dst_fn = current_function_decl;\n-  id.decl_map = splay_tree_new (splay_tree_compare_pointers, NULL, NULL);\n+  id.decl_map = pointer_map_create ();\n \n   id.copy_decl = copy_decl_no_change;\n   id.transform_call_graph_edges = CB_CGE_DUPLICATE;\n@@ -3114,7 +3111,7 @@ unsave_expr_now (tree expr)\n   walk_tree (&expr, unsave_r, &id, NULL);\n \n   /* Clean up.  */\n-  splay_tree_delete (id.decl_map);\n+  pointer_map_destroy (id.decl_map);\n \n   return expr;\n }\n@@ -3373,7 +3370,7 @@ tree_function_versioning (tree old_decl, tree new_decl, varray_type tree_map,\n       id.statements_to_fold = pointer_set_create ();\n     }\n   \n-  id.decl_map = splay_tree_new (splay_tree_compare_pointers, NULL, NULL);\n+  id.decl_map = pointer_map_create ();\n   id.src_fn = old_decl;\n   id.dst_fn = new_decl;\n   id.src_node = old_version_node;\n@@ -3450,7 +3447,7 @@ tree_function_versioning (tree old_decl, tree new_decl, varray_type tree_map,\n   number_blocks (new_decl);\n \n   /* Clean up.  */\n-  splay_tree_delete (id.decl_map);\n+  pointer_map_destroy (id.decl_map);\n   if (!update_clones)\n     {\n       fold_marked_statements (0, id.statements_to_fold);\n@@ -3491,11 +3488,11 @@ build_duplicate_type (tree type)\n   id.src_fn = current_function_decl;\n   id.dst_fn = current_function_decl;\n   id.src_cfun = cfun;\n-  id.decl_map = splay_tree_new (splay_tree_compare_pointers, NULL, NULL);\n+  id.decl_map = pointer_map_create ();\n \n   type = remap_type_1 (type, &id);\n \n-  splay_tree_delete (id.decl_map);\n+  pointer_map_destroy (id.decl_map);\n \n   return type;\n }"}, {"sha": "e191105e049d47133535f15643d900c40c97318a", "filename": "gcc/tree-inline.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6be42dd4a21f046a05ccbb5c27cda488bd1c5113/gcc%2Ftree-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6be42dd4a21f046a05ccbb5c27cda488bd1c5113/gcc%2Ftree-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.h?ref=6be42dd4a21f046a05ccbb5c27cda488bd1c5113", "patch": "@@ -23,7 +23,7 @@ Boston, MA 02110-1301, USA.  */\n #define GCC_TREE_INLINE_H\n \n #include \"varray.h\"\n-#include \"splay-tree.h\"\n+#include \"pointer-set.h\"\n \n \n /* Data required for function body duplication.  */\n@@ -49,7 +49,7 @@ typedef struct copy_body_data\n   tree retvar;\n   /* The map from local declarations in the inlined function to\n      equivalents in the function into which it is being inlined.  */\n-  splay_tree decl_map;\n+  struct pointer_map_t *decl_map;\n \n   /* Create a new decl to replace DECL in the destination function.  */\n   tree (*copy_decl) (tree, struct copy_body_data *);"}]}