{"sha": "e560f22692e361d8618cb35958535b98480b58c0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTU2MGYyMjY5MmUzNjFkODYxOGNiMzU5NTg1MzViOTg0ODBiNThjMA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-11-16T12:15:18Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-11-16T12:15:18Z"}, "message": "(EXTRA_CONSTRAINT): New macro.\n\n(SECONDARY_{INPUT,OUTPUT}_RELOAD_CLASS): Disallow unaligned into float regs.\n\nFrom-SVN: r6108", "tree": {"sha": "eaf2d3a487d7480988666b36050d08655010f548", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/eaf2d3a487d7480988666b36050d08655010f548"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e560f22692e361d8618cb35958535b98480b58c0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e560f22692e361d8618cb35958535b98480b58c0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e560f22692e361d8618cb35958535b98480b58c0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e560f22692e361d8618cb35958535b98480b58c0/comments", "author": null, "committer": null, "parents": [{"sha": "e63a24c8a1ba7f92d1b1512d372575605e07daca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e63a24c8a1ba7f92d1b1512d372575605e07daca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e63a24c8a1ba7f92d1b1512d372575605e07daca"}], "stats": {"total": 22, "additions": 19, "deletions": 3}, "files": [{"sha": "54c41f1b4f363a65f131aaaa58fad38ba5b9c04a", "filename": "gcc/config/alpha/alpha.h", "status": "modified", "additions": 19, "deletions": 3, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e560f22692e361d8618cb35958535b98480b58c0/gcc%2Fconfig%2Falpha%2Falpha.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e560f22692e361d8618cb35958535b98480b58c0/gcc%2Fconfig%2Falpha%2Falpha.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.h?ref=e560f22692e361d8618cb35958535b98480b58c0", "patch": "@@ -501,6 +501,15 @@ enum reg_class { NO_REGS, GENERAL_REGS, FLOAT_REGS, ALL_REGS,\n \t\t   && zap_mask (CONST_DOUBLE_HIGH (VALUE)))\t\t\\\n    : 0)\n \n+/* Optional extra constraints for this machine.\n+\n+   For the Alpha, `Q' means that this is a memory operand but not a\n+   reference to an unaligned location.  */\n+\n+#define EXTRA_CONSTRAINT(OP, C)\t\t\t\t\\\n+  ((C) == 'Q' ? GET_CODE (OP) == MEM && GET_CODE (XEXP (OP, 0)) != AND \\\n+   : 0)\n+\n /* Given an rtx X being reloaded into a reg required to be\n    in class CLASS, return the class of reg to actually use.\n    In general this is just CLASS; but on some machines\n@@ -516,7 +525,8 @@ enum reg_class { NO_REGS, GENERAL_REGS, FLOAT_REGS, ALL_REGS,\n \n /* Loading and storing HImode or QImode values to and from memory\n    usually requires a scratch register.  The exceptions are loading\n-   QImode and HImode from an aligned address to a general register. */\n+   QImode and HImode from an aligned address to a general register. \n+   We also cannot load an unaligned address into an FP register.  */\n \n #define SECONDARY_INPUT_RELOAD_CLASS(CLASS,MODE,IN)\t\t\t\\\n (((GET_CODE (IN) == MEM \t\t\t\t\t\t\\\n@@ -529,7 +539,10 @@ enum reg_class { NO_REGS, GENERAL_REGS, FLOAT_REGS, ALL_REGS,\n        && ((MODE) == SImode || (MODE) == HImode || (MODE) == QImode))\t\\\n       || (((MODE) == QImode || (MODE) == HImode)\t\t\t\\\n \t  && unaligned_memory_operand (IN, MODE))))\t\t\t\\\n- ? GENERAL_REGS : NO_REGS)\n+ ? GENERAL_REGS\t\t\t\t\t\t\t\t\\\n+ : ((CLASS) == FLOAT_REGS && GET_CODE (IN) == MEM\t\t\t\\\n+    && GET_CODE (XEXP (IN, 0)) == AND) ? GENERAL_REGS\t\t\t\\\n+ : NO_REGS)\n \n #define SECONDARY_OUTPUT_RELOAD_CLASS(CLASS,MODE,OUT)\t\t\t\\\n (((GET_CODE (OUT) == MEM \t\t\t\t\t\t\\\n@@ -540,7 +553,10 @@ enum reg_class { NO_REGS, GENERAL_REGS, FLOAT_REGS, ALL_REGS,\n \t       && REGNO (SUBREG_REG (OUT)) >= FIRST_PSEUDO_REGISTER)))) \\\n   && (((MODE) == HImode || (MODE) == QImode\t\t\t\t\\\n        || ((MODE) == SImode && (CLASS) == FLOAT_REGS))))\t\t\\\n- ? GENERAL_REGS : NO_REGS)\n+ ? GENERAL_REGS\t\t\t\t\t\t\t\t\\\n+ : ((CLASS) == FLOAT_REGS && GET_CODE (OUT) == MEM\t\t\t\\\n+    && GET_CODE (XEXP (OUT, 0)) == AND) ? GENERAL_REGS\t\t\t\\\n+  : NO_REGS)\n \n /* If we are copying between general and FP registers, we need a memory\n    location.  */"}]}