{"sha": "1933ba0f5dc728f554beb675093126aaef7fbb5a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTkzM2JhMGY1ZGM3MjhmNTU0YmViNjc1MDkzMTI2YWFlZjdmYmI1YQ==", "commit": {"author": {"name": "Daniel Kraft", "email": "d@domob.eu", "date": "2008-11-30T20:36:10Z"}, "committer": {"name": "Daniel Kraft", "email": "domob@gcc.gnu.org", "date": "2008-11-30T20:36:10Z"}, "message": "re PR fortran/37779 (Missing RECURSIVE not detected)\n\n2008-11-30  Daniel Kraft  <d@domob.eu>\n\n\tPR fortran/37779\n\t* gfortran.h (struct gfc_entry_list): Fixed typo in comment.\n\t* resolve.c (is_illegal_recursion): New method.\n\t(resolve_procedure_expression): Use new is_illegal_recursion instead of\n\tdirect check and handle function symbols correctly.\n\t(resolve_actual_arglist): Removed useless recursion check.\n\t(resolve_function): Use is_illegal_recursion instead of direct check.\n\t(resolve_call): Ditto.\n\n2008-11-30  Daniel Kraft  <d@domob.eu>\n\n\tPR fortran/37779\n\t* gfortran.dg/recursive_check_1.f: Changed expected error message to\n\tthe more general new one.\n\t* gfortran.dg/recursive_check_2.f90: Ditto.\n\t* gfortran.dg/entry_18.f90: Ditto.\n\t* gfortran.dg/recursive_check_4.f03: Do \"the same\" check also for\n\tFUNCTIONS, as this is different in details from SUBROUTINES.\n\t* gfortran.dg/recursive_check_6.f03: New test.\n\nFrom-SVN: r142299", "tree": {"sha": "dd6e71838000e064f6aa7cc84b9cf68d917569ba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dd6e71838000e064f6aa7cc84b9cf68d917569ba"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1933ba0f5dc728f554beb675093126aaef7fbb5a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1933ba0f5dc728f554beb675093126aaef7fbb5a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1933ba0f5dc728f554beb675093126aaef7fbb5a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1933ba0f5dc728f554beb675093126aaef7fbb5a/comments", "author": {"login": "domob1812", "id": 4943644, "node_id": "MDQ6VXNlcjQ5NDM2NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4943644?v=4", "gravatar_id": "", "url": "https://api.github.com/users/domob1812", "html_url": "https://github.com/domob1812", "followers_url": "https://api.github.com/users/domob1812/followers", "following_url": "https://api.github.com/users/domob1812/following{/other_user}", "gists_url": "https://api.github.com/users/domob1812/gists{/gist_id}", "starred_url": "https://api.github.com/users/domob1812/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/domob1812/subscriptions", "organizations_url": "https://api.github.com/users/domob1812/orgs", "repos_url": "https://api.github.com/users/domob1812/repos", "events_url": "https://api.github.com/users/domob1812/events{/privacy}", "received_events_url": "https://api.github.com/users/domob1812/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "72b415c58668d3bd757fb8ec3be70302c339d544", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/72b415c58668d3bd757fb8ec3be70302c339d544", "html_url": "https://github.com/Rust-GCC/gccrs/commit/72b415c58668d3bd757fb8ec3be70302c339d544"}], "stats": {"total": 232, "additions": 182, "deletions": 50}, "files": [{"sha": "d000a1ac513d177dcd33b5b21d44a21bb4c3926e", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1933ba0f5dc728f554beb675093126aaef7fbb5a/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1933ba0f5dc728f554beb675093126aaef7fbb5a/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=1933ba0f5dc728f554beb675093126aaef7fbb5a", "patch": "@@ -1,3 +1,14 @@\n+2008-11-30  Daniel Kraft  <d@domob.eu>\n+\n+\tPR fortran/37779\n+\t* gfortran.h (struct gfc_entry_list): Fixed typo in comment.\n+\t* resolve.c (is_illegal_recursion): New method.\n+\t(resolve_procedure_expression): Use new is_illegal_recursion instead of\n+\tdirect check and handle function symbols correctly.\n+\t(resolve_actual_arglist): Removed useless recursion check.\n+\t(resolve_function): Use is_illegal_recursion instead of direct check.\n+\t(resolve_call): Ditto.\n+\n 2008-11-29  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* trans-array.c (gfc_conv_array_parameter): Guard union access."}, {"sha": "13701245446c3ee8755b7946036f6434c5b3b327", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1933ba0f5dc728f554beb675093126aaef7fbb5a/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1933ba0f5dc728f554beb675093126aaef7fbb5a/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=1933ba0f5dc728f554beb675093126aaef7fbb5a", "patch": "@@ -1157,7 +1157,7 @@ typedef struct gfc_entry_list\n   int id;\n   /* The LABEL_EXPR marking this entry point.  */\n   tree label;\n-  /* The nest item in the list.  */\n+  /* The next item in the list.  */\n   struct gfc_entry_list *next;\n }\n gfc_entry_list;"}, {"sha": "6ccbe12859ad89f0783675730e38b3ce2f0beef1", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 77, "deletions": 43, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1933ba0f5dc728f554beb675093126aaef7fbb5a/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1933ba0f5dc728f554beb675093126aaef7fbb5a/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=1933ba0f5dc728f554beb675093126aaef7fbb5a", "patch": "@@ -1073,6 +1073,58 @@ count_specific_procs (gfc_expr *e)\n }\n \n \n+/* See if a call to sym could possibly be a not allowed RECURSION because of\n+   a missing RECURIVE declaration.  This means that either sym is the current\n+   context itself, or sym is the parent of a contained procedure calling its\n+   non-RECURSIVE containing procedure.\n+   This also works if sym is an ENTRY.  */\n+\n+static bool\n+is_illegal_recursion (gfc_symbol* sym, gfc_namespace* context)\n+{\n+  gfc_symbol* proc_sym;\n+  gfc_symbol* context_proc;\n+\n+  gcc_assert (sym->attr.flavor == FL_PROCEDURE);\n+\n+  /* If we've got an ENTRY, find real procedure.  */\n+  if (sym->attr.entry && sym->ns->entries)\n+    proc_sym = sym->ns->entries->sym;\n+  else\n+    proc_sym = sym;\n+\n+  /* If sym is RECURSIVE, all is well of course.  */\n+  if (proc_sym->attr.recursive || gfc_option.flag_recursive)\n+    return false;\n+\n+  /* Find the context procdure's \"real\" symbol if it has entries.  */\n+  context_proc = (context->entries ? context->entries->sym\n+\t\t\t\t   : context->proc_name);\n+  if (!context_proc)\n+    return true;\n+\n+  /* A call from sym's body to itself is recursion, of course.  */\n+  if (context_proc == proc_sym)\n+    return true;\n+\n+  /* The same is true if context is a contained procedure and sym the\n+     containing one.  */\n+  if (context_proc->attr.contained)\n+    {\n+      gfc_symbol* parent_proc;\n+\n+      gcc_assert (context->parent);\n+      parent_proc = (context->parent->entries ? context->parent->entries->sym\n+\t\t\t\t\t      : context->parent->proc_name);\n+\n+      if (parent_proc == proc_sym)\n+\treturn true;\n+    }\n+\n+  return false;\n+}\n+\n+\n /* Resolve a procedure expression, like passing it to a called procedure or as\n    RHS for a procedure pointer assignment.  */\n \n@@ -1081,16 +1133,18 @@ resolve_procedure_expression (gfc_expr* expr)\n {\n   gfc_symbol* sym;\n \n-  if (expr->ts.type != BT_PROCEDURE || expr->expr_type != EXPR_VARIABLE)\n+  if (expr->expr_type != EXPR_VARIABLE)\n     return SUCCESS;\n   gcc_assert (expr->symtree);\n+\n   sym = expr->symtree->n.sym;\n-  gcc_assert (sym->attr.flavor == FL_PROCEDURE);\n+  if (sym->attr.flavor != FL_PROCEDURE\n+      || (sym->attr.function && sym->result == sym))\n+    return SUCCESS;\n \n   /* A non-RECURSIVE procedure that is used as procedure expression within its\n      own body is in danger of being called recursively.  */\n-  if (!sym->attr.recursive && sym == gfc_current_ns->proc_name\n-      && !gfc_option.flag_recursive)\n+  if (is_illegal_recursion (sym, gfc_current_ns))\n     gfc_warning (\"Non-RECURSIVE procedure '%s' at %L is possibly calling\"\n \t\t \" itself recursively.  Declare it RECURSIVE or use\"\n \t\t \" -frecursive\", sym->name, &expr->where);\n@@ -1203,15 +1257,6 @@ resolve_actual_arglist (gfc_actual_arglist *arg, procedure_type ptype,\n \t  /* Just in case a specific was found for the expression.  */\n \t  sym = e->symtree->n.sym;\n \n-\t  if (sym->attr.entry && sym->ns->entries\n-\t\t&& sym->ns == gfc_current_ns\n-\t\t&& !sym->ns->entries->sym->attr.recursive)\n-\t    {\n-\t      gfc_error (\"Reference to ENTRY '%s' at %L is recursive, but\"\n-\t\t\t \" procedure '%s' is not declared as RECURSIVE\",\n-\t\t\t sym->name, &e->where, sym->ns->entries->sym->name);\n-\t    }\n-\n \t  /* If the symbol is the function that names the current (or\n \t     parent) scope, then we really have a variable reference.  */\n \n@@ -2455,22 +2500,19 @@ resolve_function (gfc_expr *expr)\n    * call themselves.  */\n   if (expr->value.function.esym && !expr->value.function.esym->attr.recursive)\n     {\n-      gfc_symbol *esym, *proc;\n+      gfc_symbol *esym;\n       esym = expr->value.function.esym;\n-      proc = gfc_current_ns->proc_name;\n-      if (esym == proc)\n-      {\n-\tgfc_error (\"Function '%s' at %L cannot call itself, as it is not \"\n-\t\t   \"RECURSIVE\", name, &expr->where);\n-\tt = FAILURE;\n-      }\n \n-      if (esym->attr.entry && esym->ns->entries && proc->ns->entries\n-\t  && esym->ns->entries->sym == proc->ns->entries->sym)\n+      if (is_illegal_recursion (esym, gfc_current_ns))\n       {\n-\tgfc_error (\"Call to ENTRY '%s' at %L is recursive, but function \"\n-\t\t   \"'%s' is not declared as RECURSIVE\",\n-\t\t   esym->name, &expr->where, esym->ns->entries->sym->name);\n+\tif (esym->attr.entry && esym->ns->entries)\n+\t  gfc_error (\"ENTRY '%s' at %L cannot be called recursively, as\"\n+\t\t     \" function '%s' is not RECURSIVE\",\n+\t\t     esym->name, &expr->where, esym->ns->entries->sym->name);\n+\telse\n+\t  gfc_error (\"Function '%s' at %L cannot be called recursively, as it\"\n+\t\t     \" is not RECURSIVE\", esym->name, &expr->where);\n+\n \tt = FAILURE;\n       }\n     }\n@@ -2920,25 +2962,17 @@ resolve_call (gfc_code *c)\n \n   /* Subroutines without the RECURSIVE attribution are not allowed to\n    * call themselves.  */\n-  if (csym && !csym->attr.recursive)\n+  if (csym && is_illegal_recursion (csym, gfc_current_ns))\n     {\n-      gfc_symbol *proc;\n-      proc = gfc_current_ns->proc_name;\n-      if (csym == proc)\n-      {\n-\tgfc_error (\"SUBROUTINE '%s' at %L cannot call itself, as it is not \"\n-\t\t   \"RECURSIVE\", csym->name, &c->loc);\n-\tt = FAILURE;\n-      }\n-\n-      if (csym->attr.entry && csym->ns->entries && proc->ns->entries\n-\t  && csym->ns->entries->sym == proc->ns->entries->sym)\n-      {\n-\tgfc_error (\"Call to ENTRY '%s' at %L is recursive, but subroutine \"\n-\t\t   \"'%s' is not declared as RECURSIVE\",\n+      if (csym->attr.entry && csym->ns->entries)\n+\tgfc_error (\"ENTRY '%s' at %L cannot be called recursively, as\"\n+\t\t   \" subroutine '%s' is not RECURSIVE\",\n \t\t   csym->name, &c->loc, csym->ns->entries->sym->name);\n-\tt = FAILURE;\n-      }\n+      else\n+\tgfc_error (\"SUBROUTINE '%s' at %L cannot be called recursively, as it\"\n+\t\t   \" is not RECURSIVE\", csym->name, &c->loc);\n+\n+      t = FAILURE;\n     }\n \n   /* Switch off assumed size checking and do this again for certain kinds"}, {"sha": "f6ee64bf384ab1602724ecb9d79eee5b786ac997", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1933ba0f5dc728f554beb675093126aaef7fbb5a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1933ba0f5dc728f554beb675093126aaef7fbb5a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=1933ba0f5dc728f554beb675093126aaef7fbb5a", "patch": "@@ -1,3 +1,14 @@\n+2008-11-30  Daniel Kraft  <d@domob.eu>\n+\n+\tPR fortran/37779\n+\t* gfortran.dg/recursive_check_1.f: Changed expected error message to\n+\tthe more general new one.\n+\t* gfortran.dg/recursive_check_2.f90: Ditto.\n+\t* gfortran.dg/entry_18.f90: Ditto.\n+\t* gfortran.dg/recursive_check_4.f03: Do \"the same\" check also for\n+\tFUNCTIONS, as this is different in details from SUBROUTINES.\n+\t* gfortran.dg/recursive_check_6.f03: New test.\n+\n 2008-11-30  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* g++.dg/opt/reload3.C: New test."}, {"sha": "0cfe842137e1c7a99abe02ea4e7c6e92b53b715c", "filename": "gcc/testsuite/gfortran.dg/entry_18.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1933ba0f5dc728f554beb675093126aaef7fbb5a/gcc%2Ftestsuite%2Fgfortran.dg%2Fentry_18.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1933ba0f5dc728f554beb675093126aaef7fbb5a/gcc%2Ftestsuite%2Fgfortran.dg%2Fentry_18.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fentry_18.f90?ref=1933ba0f5dc728f554beb675093126aaef7fbb5a", "patch": "@@ -27,7 +27,7 @@ real function g(x)\n        end function\n    end interface\n    real :: x, y\n-   call mysub( glocalb ) ! { dg-error \"is recursive\" }\n+   call mysub( glocalb ) ! { dg-warning \"Non-RECURSIVE\" }\n    return\n entry glocalb( x, y )\n    y = x"}, {"sha": "7c292af085989748a6db8bcc0067b30c32a8684b", "filename": "gcc/testsuite/gfortran.dg/recursive_check_1.f", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1933ba0f5dc728f554beb675093126aaef7fbb5a/gcc%2Ftestsuite%2Fgfortran.dg%2Frecursive_check_1.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1933ba0f5dc728f554beb675093126aaef7fbb5a/gcc%2Ftestsuite%2Fgfortran.dg%2Frecursive_check_1.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Frecursive_check_1.f?ref=1933ba0f5dc728f554beb675093126aaef7fbb5a", "patch": "@@ -1,25 +1,25 @@\n ! { dg-do compile }\n ! PR fortran/26551\n       SUBROUTINE SUB()\n-      CALL SUB() ! { dg-error \"cannot call itself, as it is not RECURSIVE\" }\n+      CALL SUB() ! { dg-error \"is not RECURSIVE\" }\n       END SUBROUTINE\n \n       FUNCTION FUNC() RESULT (FOO)\n       INTEGER FOO\n-      FOO = FUNC() ! { dg-error \"cannot call itself, as it is not RECURSIVE\" }\n+      FOO = FUNC() ! { dg-error \"is not RECURSIVE\" }\n       END FUNCTION\n \n       SUBROUTINE SUB2()\n       ENTRY ENT2()\n-      CALL ENT2() ! { dg-error \"is not declared as RECURSIVE\" }\n+      CALL ENT2() ! { dg-error \"is not RECURSIVE\" }\n       END SUBROUTINE\n \n       function func2()\n       integer func2\n       func2 = 42\n       return\n       entry c() result (foo)\n-      foo = b() ! { dg-error \"is not declared as RECURSIVE\" }\n+      foo = b() ! { dg-error \"is not RECURSIVE\" }\n       return\n       entry b() result (bar)\n       bar = 12"}, {"sha": "15608eea155dd049e86c63b8e2489f8d271d1b54", "filename": "gcc/testsuite/gfortran.dg/recursive_check_2.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1933ba0f5dc728f554beb675093126aaef7fbb5a/gcc%2Ftestsuite%2Fgfortran.dg%2Frecursive_check_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1933ba0f5dc728f554beb675093126aaef7fbb5a/gcc%2Ftestsuite%2Fgfortran.dg%2Frecursive_check_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Frecursive_check_2.f90?ref=1933ba0f5dc728f554beb675093126aaef7fbb5a", "patch": "@@ -12,6 +12,6 @@ function func2()\n    return\n  contains\n    function barbar ()\n-     barbar = b () ! { dg-error \"is not declared as RECURSIVE\" }\n+     barbar = b () ! { dg-error \"is not RECURSIVE\" }\n    end function barbar\n  end function"}, {"sha": "d33e53555ca192fca8ecf4c0edeb5e113335a728", "filename": "gcc/testsuite/gfortran.dg/recursive_check_4.f03", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1933ba0f5dc728f554beb675093126aaef7fbb5a/gcc%2Ftestsuite%2Fgfortran.dg%2Frecursive_check_4.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1933ba0f5dc728f554beb675093126aaef7fbb5a/gcc%2Ftestsuite%2Fgfortran.dg%2Frecursive_check_4.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Frecursive_check_4.f03?ref=1933ba0f5dc728f554beb675093126aaef7fbb5a", "patch": "@@ -16,6 +16,16 @@ SUBROUTINE test ()\n     procptr => test ! { dg-warning \"Non-RECURSIVE\" }\n   END SUBROUTINE test\n \n+  INTEGER FUNCTION test2 () RESULT (x)\n+    IMPLICIT NONE\n+    PROCEDURE(test2), POINTER :: procptr\n+\n+    CALL bar (test2) ! { dg-warning \"Non-RECURSIVE\" }\n+    procptr => test2 ! { dg-warning \"Non-RECURSIVE\" }\n+\n+    x = 1812\n+  END FUNCTION test2\n+\n   INTEGER FUNCTION func ()\n     ! Using a result variable is ok of course!\n     func = 42 ! { dg-bogus \"Non-RECURSIVE\" }"}, {"sha": "478539e6a4980ea63b5b7af9fab51d4f000e9a79", "filename": "gcc/testsuite/gfortran.dg/recursive_check_6.f03", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1933ba0f5dc728f554beb675093126aaef7fbb5a/gcc%2Ftestsuite%2Fgfortran.dg%2Frecursive_check_6.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1933ba0f5dc728f554beb675093126aaef7fbb5a/gcc%2Ftestsuite%2Fgfortran.dg%2Frecursive_check_6.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Frecursive_check_6.f03?ref=1933ba0f5dc728f554beb675093126aaef7fbb5a", "patch": "@@ -0,0 +1,66 @@\n+! { dg-do compile }\n+\n+! PR fortran/37779\n+! Check that a call to a procedure's containing procedure counts as recursive\n+! and is rejected if the containing procedure is not RECURSIVE.\n+\n+MODULE m\n+  IMPLICIT NONE\n+\n+CONTAINS\n+\n+  SUBROUTINE test_sub ()\n+    CALL bar ()\n+  CONTAINS\n+    SUBROUTINE bar ()\n+      IMPLICIT NONE\n+      PROCEDURE(test_sub), POINTER :: procptr\n+\n+      CALL test_sub () ! { dg-error \"not RECURSIVE\" }\n+      procptr => test_sub ! { dg-warning \"Non-RECURSIVE\" }\n+      CALL foobar (test_sub) ! { dg-warning \"Non-RECURSIVE\" }\n+    END SUBROUTINE bar\n+  END SUBROUTINE test_sub\n+\n+  INTEGER FUNCTION test_func () RESULT (x)\n+    x = bar ()\n+  CONTAINS\n+    INTEGER FUNCTION bar ()\n+      IMPLICIT NONE\n+      PROCEDURE(test_func), POINTER :: procptr\n+\n+      bar = test_func () ! { dg-error \"not RECURSIVE\" }\n+      procptr => test_func ! { dg-warning \"Non-RECURSIVE\" }\n+      CALL foobar (test_func) ! { dg-warning \"Non-RECURSIVE\" }\n+    END FUNCTION bar\n+  END FUNCTION test_func\n+\n+  SUBROUTINE sub_entries ()\n+  ENTRY sub_entry_1 ()\n+  ENTRY sub_entry_2 ()\n+    CALL bar ()\n+  CONTAINS\n+    SUBROUTINE bar ()\n+      CALL sub_entry_1 () ! { dg-error \"is not RECURSIVE\" }\n+    END SUBROUTINE bar\n+  END SUBROUTINE sub_entries\n+\n+  INTEGER FUNCTION func_entries () RESULT (x)\n+  ENTRY func_entry_1 () RESULT (x)\n+  ENTRY func_entry_2 () RESULT (x)\n+    x = bar ()\n+  CONTAINS\n+    INTEGER FUNCTION bar ()\n+      bar = func_entry_1 () ! { dg-error \"is not RECURSIVE\" }\n+    END FUNCTION bar\n+  END FUNCTION func_entries\n+\n+  SUBROUTINE main ()\n+    CALL test_sub ()\n+    CALL sub_entries ()\n+    PRINT *, test_func (), func_entries ()\n+  END SUBROUTINE main\n+\n+END MODULE m\n+\n+! { dg-final { cleanup-modules \"m\" } }"}]}