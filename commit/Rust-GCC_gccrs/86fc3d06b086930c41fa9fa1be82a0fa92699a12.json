{"sha": "86fc3d06b086930c41fa9fa1be82a0fa92699a12", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODZmYzNkMDZiMDg2OTMwYzQxZmE5ZmExYmU4MmEwZmE5MjY5OWExMg==", "commit": {"author": {"name": "Ulrich Weigand", "email": "uweigand@de.ibm.com", "date": "2011-11-08T17:36:45Z"}, "committer": {"name": "Ulrich Weigand", "email": "uweigand@gcc.gnu.org", "date": "2011-11-08T17:36:45Z"}, "message": "tm.texi.in (MODE_CODE_BASE_REG_CLASS): Add address space argument.\n\n\t* doc/tm.texi.in (MODE_CODE_BASE_REG_CLASS): Add address space\n\targument.\n\t(REGNO_MODE_CODE_OK_FOR_BASE_P): Likewise.\n\t* doc/tm.texi: Regenerate.\n\n\t* config/cris/cris.h (MODE_CODE_BASE_REG_CLASS): Add address\n\tspace argument.\n\t(REGNO_MODE_CODE_OK_FOR_BASE_P): Likewise.\n\t* config/bfin/bfin.h (MODE_CODE_BASE_REG_CLASS): Likewise.\n\t(REGNO_MODE_CODE_OK_FOR_BASE_P): Likewise.\n\t* config/avr/avr.h (MODE_CODE_BASE_REG_CLASS): Add address space\n\targument.\n\t(REGNO_MODE_CODE_OK_FOR_BASE_P): Ditto.\n\t* config/avr/avr-protos.h (avr_mode_code_base_reg_class): Ditto.\n\t(avr_regno_mode_code_ok_for_base_p): Ditto.\n\t* config/avr/avr.c (avr_mode_code_base_reg_class): Ditto.\n\t(avr_regno_mode_code_ok_for_base_p): Ditto.\n\t(avr_reg_ok_for_addr_p): Pass AS down to\n\tavr_regno_mode_code_ok_for_base_p.\n\n\t* addresses.h (base_reg_class): Add address space argument.\n\tPass to MODE_CODE_BASE_REG_CLASS.\n\t(ok_for_base_p_1): Add address space argument.  Pass to\n\tREGNO_MODE_CODE_OK_FOR_BASE_P.\n\t(regno_ok_for_base_p): Add address space argument.  Pass to\n\tok_for_base_p_1.\n\n\t* regrename.c (scan_rtx_address): Add address space argument.\n\tPass address space to regno_ok_for_base_p and base_reg_class.\n\tUpdate recursive calls.\n\t(scan_rtx): Pass address space to scan_rtx_address.\n\t(build_def_use): Likewise.\n\t* regcprop.c (replace_oldest_value_addr): Add address space\n\targument.  Pass to regno_ok_for_base_p and base_reg_class.\n\tUpdate recursive calls.\n\t(replace_oldest_value_mem): Pass address space to\n\treplace_oldest_value_addr.\n\t(copyprop_hardreg_forward_1): Likewise.\n\n\t* reload.c (find_reloads_address_1): Add address space argument.\n\tPass address space to base_reg_class and regno_ok_for_base_p.\n\tUpdate recursive calls.\n\t(find_reloads_address): Pass address space to base_reg_class,\n\tregno_ok_for_base_p, and find_reloads_address_1.\n\t(find_reloads): Pass address space to base_reg_class.\n\t(find_reloads_subreg_address): Likewise.\n\n\t* ira-costs.c (record_reg_classes): Update calls to base_reg_class.\n\t(ok_for_base_p_nonstrict): Add address space argument.  Pass to\n\tok_for_base_p_1.\n\t(record_address_regs): Add address space argument.  Pass to\n\tbase_reg_class and ok_for_base_p_nonstrict.  Update recursive calls.\n\t(record_operand_costs): Pass address space to record_address_regs.\n\t(scan_one_insn): Likewise.\n\n\t* caller-save.c (init_caller_save): Update call to base_reg_class.\n\t* ira-conflicts.c (ira_build_conflicts): Likewise.\n\t* reload1.c (maybe_fix_stack_asms): Likewise.\n\nCo-Authored-By: Georg-Johann Lay <avr@gjlay.de>\n\nFrom-SVN: r181175", "tree": {"sha": "5b3bd690f671fa467debff5f892ff7160b620e20", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5b3bd690f671fa467debff5f892ff7160b620e20"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/86fc3d06b086930c41fa9fa1be82a0fa92699a12", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/86fc3d06b086930c41fa9fa1be82a0fa92699a12", "html_url": "https://github.com/Rust-GCC/gccrs/commit/86fc3d06b086930c41fa9fa1be82a0fa92699a12", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/86fc3d06b086930c41fa9fa1be82a0fa92699a12/comments", "author": null, "committer": null, "parents": [{"sha": "ca8dc274736dce2046bb557f7b5c5a5d0193fb3c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca8dc274736dce2046bb557f7b5c5a5d0193fb3c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ca8dc274736dce2046bb557f7b5c5a5d0193fb3c"}], "stats": {"total": 449, "additions": 274, "deletions": 175}, "files": [{"sha": "bd056b6cf8342321d54eb63bde1b04b840c22b31", "filename": "gcc/ChangeLog", "status": "modified", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86fc3d06b086930c41fa9fa1be82a0fa92699a12/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86fc3d06b086930c41fa9fa1be82a0fa92699a12/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=86fc3d06b086930c41fa9fa1be82a0fa92699a12", "patch": "@@ -1,3 +1,65 @@\n+2011-11-08  Ulrich Weigand  <Ulrich.Weigand@de.ibm.com>\n+\t    Georg-Johann Lay  <avr@gjlay.de>\n+\n+\t* doc/tm.texi.in (MODE_CODE_BASE_REG_CLASS): Add address space\n+\targument.\n+\t(REGNO_MODE_CODE_OK_FOR_BASE_P): Likewise.\n+\t* doc/tm.texi: Regenerate.\n+\n+\t* config/cris/cris.h (MODE_CODE_BASE_REG_CLASS): Add address\n+\tspace argument.\n+\t(REGNO_MODE_CODE_OK_FOR_BASE_P): Likewise.\n+\t* config/bfin/bfin.h (MODE_CODE_BASE_REG_CLASS): Likewise.\n+\t(REGNO_MODE_CODE_OK_FOR_BASE_P): Likewise.\n+\t* config/avr/avr.h (MODE_CODE_BASE_REG_CLASS): Add address space\n+\targument.\n+\t(REGNO_MODE_CODE_OK_FOR_BASE_P): Ditto.\n+\t* config/avr/avr-protos.h (avr_mode_code_base_reg_class): Ditto.\n+\t(avr_regno_mode_code_ok_for_base_p): Ditto.\n+\t* config/avr/avr.c (avr_mode_code_base_reg_class): Ditto.\n+\t(avr_regno_mode_code_ok_for_base_p): Ditto.\n+\t(avr_reg_ok_for_addr_p): Pass AS down to\n+\tavr_regno_mode_code_ok_for_base_p.\n+\n+\t* addresses.h (base_reg_class): Add address space argument.\n+\tPass to MODE_CODE_BASE_REG_CLASS.\n+\t(ok_for_base_p_1): Add address space argument.  Pass to\n+\tREGNO_MODE_CODE_OK_FOR_BASE_P.\n+\t(regno_ok_for_base_p): Add address space argument.  Pass to\n+\tok_for_base_p_1.\n+\n+\t* regrename.c (scan_rtx_address): Add address space argument.\n+\tPass address space to regno_ok_for_base_p and base_reg_class.\n+\tUpdate recursive calls.\n+\t(scan_rtx): Pass address space to scan_rtx_address.\n+\t(build_def_use): Likewise.\n+\t* regcprop.c (replace_oldest_value_addr): Add address space\n+\targument.  Pass to regno_ok_for_base_p and base_reg_class.\n+\tUpdate recursive calls.\n+\t(replace_oldest_value_mem): Pass address space to\n+\treplace_oldest_value_addr.\n+\t(copyprop_hardreg_forward_1): Likewise.\n+\n+\t* reload.c (find_reloads_address_1): Add address space argument.\n+\tPass address space to base_reg_class and regno_ok_for_base_p.\n+\tUpdate recursive calls.\n+\t(find_reloads_address): Pass address space to base_reg_class,\n+\tregno_ok_for_base_p, and find_reloads_address_1.\n+\t(find_reloads): Pass address space to base_reg_class.\n+\t(find_reloads_subreg_address): Likewise.\n+\n+\t* ira-costs.c (record_reg_classes): Update calls to base_reg_class.\n+\t(ok_for_base_p_nonstrict): Add address space argument.  Pass to\n+\tok_for_base_p_1.\n+\t(record_address_regs): Add address space argument.  Pass to\n+\tbase_reg_class and ok_for_base_p_nonstrict.  Update recursive calls.\n+\t(record_operand_costs): Pass address space to record_address_regs.\n+\t(scan_one_insn): Likewise.\n+\n+\t* caller-save.c (init_caller_save): Update call to base_reg_class.\n+\t* ira-conflicts.c (ira_build_conflicts): Likewise.\n+\t* reload1.c (maybe_fix_stack_asms): Likewise.\n+\n 2011-11-08  Michael Matz  <matz@suse.de>\n \n \t* gengtype.c (write_field_root): Avoid out-of-scope access of newv."}, {"sha": "235b43862ae9562294af466d90f719f49dd64846", "filename": "gcc/addresses.h", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86fc3d06b086930c41fa9fa1be82a0fa92699a12/gcc%2Faddresses.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86fc3d06b086930c41fa9fa1be82a0fa92699a12/gcc%2Faddresses.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Faddresses.h?ref=86fc3d06b086930c41fa9fa1be82a0fa92699a12", "patch": "@@ -23,11 +23,12 @@ along with GCC; see the file COPYING3.  If not see\n \n static inline enum reg_class\n base_reg_class (enum machine_mode mode ATTRIBUTE_UNUSED,\n+\t\taddr_space_t as ATTRIBUTE_UNUSED,\n \t\tenum rtx_code outer_code ATTRIBUTE_UNUSED,\n \t\tenum rtx_code index_code ATTRIBUTE_UNUSED)\n {\n #ifdef MODE_CODE_BASE_REG_CLASS\n-  return MODE_CODE_BASE_REG_CLASS (mode, outer_code, index_code);\n+  return MODE_CODE_BASE_REG_CLASS (mode, as, outer_code, index_code);\n #else\n #ifdef MODE_BASE_REG_REG_CLASS\n   if (index_code == REG)\n@@ -49,11 +50,13 @@ base_reg_class (enum machine_mode mode ATTRIBUTE_UNUSED,\n static inline bool\n ok_for_base_p_1 (unsigned regno ATTRIBUTE_UNUSED,\n \t\t enum machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t addr_space_t as ATTRIBUTE_UNUSED,\n \t\t enum rtx_code outer_code ATTRIBUTE_UNUSED,\n \t\t enum rtx_code index_code ATTRIBUTE_UNUSED)\n {\n #ifdef REGNO_MODE_CODE_OK_FOR_BASE_P\n-  return REGNO_MODE_CODE_OK_FOR_BASE_P (regno, mode, outer_code, index_code);\n+  return REGNO_MODE_CODE_OK_FOR_BASE_P (regno, mode, as,\n+\t\t\t\t\touter_code, index_code);\n #else\n #ifdef REGNO_MODE_OK_FOR_REG_BASE_P\n   if (index_code == REG)\n@@ -71,11 +74,11 @@ ok_for_base_p_1 (unsigned regno ATTRIBUTE_UNUSED,\n    complete.  Arguments as for the called function.  */\n \n static inline bool\n-regno_ok_for_base_p (unsigned regno, enum machine_mode mode,\n+regno_ok_for_base_p (unsigned regno, enum machine_mode mode, addr_space_t as,\n \t\t     enum rtx_code outer_code, enum rtx_code index_code)\n {\n   if (regno >= FIRST_PSEUDO_REGISTER && reg_renumber[regno] >= 0)\n     regno = reg_renumber[regno];\n \n-  return ok_for_base_p_1 (regno, mode, outer_code, index_code);\n+  return ok_for_base_p_1 (regno, mode, as, outer_code, index_code);\n }"}, {"sha": "39bccc4fc8e65b2d8531cf0e50c219f63d54ae8c", "filename": "gcc/caller-save.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86fc3d06b086930c41fa9fa1be82a0fa92699a12/gcc%2Fcaller-save.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86fc3d06b086930c41fa9fa1be82a0fa92699a12/gcc%2Fcaller-save.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcaller-save.c?ref=86fc3d06b086930c41fa9fa1be82a0fa92699a12", "patch": "@@ -231,7 +231,8 @@ init_caller_save (void)\n   for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n     if (TEST_HARD_REG_BIT\n \t(reg_class_contents\n-\t [(int) base_reg_class (regno_save_mode[i][1], PLUS, CONST_INT)], i))\n+\t [(int) base_reg_class (regno_save_mode[i][1], ADDR_SPACE_GENERIC,\n+\t\t\t\tPLUS, CONST_INT)], i))\n       break;\n \n   gcc_assert (i < FIRST_PSEUDO_REGISTER);"}, {"sha": "d3518335a00c3d205a615eef963b89837adadec2", "filename": "gcc/config/avr/avr-protos.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86fc3d06b086930c41fa9fa1be82a0fa92699a12/gcc%2Fconfig%2Favr%2Favr-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86fc3d06b086930c41fa9fa1be82a0fa92699a12/gcc%2Fconfig%2Favr%2Favr-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr-protos.h?ref=86fc3d06b086930c41fa9fa1be82a0fa92699a12", "patch": "@@ -117,8 +117,8 @@ extern int avr_simplify_comparison_p (enum machine_mode mode,\n extern RTX_CODE avr_normalize_condition (RTX_CODE condition);\n extern void out_shift_with_cnt (const char *templ, rtx insn,\n \t\t\t\trtx operands[], int *len, int t_len);\n-extern reg_class_t avr_mode_code_base_reg_class (enum machine_mode, RTX_CODE, RTX_CODE);\n-extern bool avr_regno_mode_code_ok_for_base_p (int, enum machine_mode, RTX_CODE, RTX_CODE);\n+extern reg_class_t avr_mode_code_base_reg_class (enum machine_mode, addr_space_t, RTX_CODE, RTX_CODE);\n+extern bool avr_regno_mode_code_ok_for_base_p (int, enum machine_mode, addr_space_t, RTX_CODE, RTX_CODE);\n extern rtx avr_incoming_return_addr_rtx (void);\n extern rtx avr_legitimize_reload_address (rtx*, enum machine_mode, int, int, int, int, rtx (*)(rtx,int));\n #endif /* RTX_CODE */"}, {"sha": "65d43b8ca074a6d62d156e0c77ad85067b8259ff", "filename": "gcc/config/avr/avr.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86fc3d06b086930c41fa9fa1be82a0fa92699a12/gcc%2Fconfig%2Favr%2Favr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86fc3d06b086930c41fa9fa1be82a0fa92699a12/gcc%2Fconfig%2Favr%2Favr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.c?ref=86fc3d06b086930c41fa9fa1be82a0fa92699a12", "patch": "@@ -1281,12 +1281,12 @@ avr_cannot_modify_jumps_p (void)\n /* Helper function for `avr_legitimate_address_p'.  */\n \n static inline bool\n-avr_reg_ok_for_addr_p (rtx reg, addr_space_t as ATTRIBUTE_UNUSED,\n+avr_reg_ok_for_addr_p (rtx reg, addr_space_t as,\n                        RTX_CODE outer_code, bool strict)\n {\n   return (REG_P (reg)\n-          && (avr_regno_mode_code_ok_for_base_p (REGNO (reg),\n-                                                 QImode, outer_code, UNKNOWN)\n+          && (avr_regno_mode_code_ok_for_base_p (REGNO (reg), QImode,\n+                                                 as, outer_code, UNKNOWN)\n               || (!strict\n                   && REGNO (reg) >= FIRST_PSEUDO_REGISTER)));\n }\n@@ -8049,6 +8049,7 @@ avr_hard_regno_mode_ok (int regno, enum machine_mode mode)\n \n reg_class_t\n avr_mode_code_base_reg_class (enum machine_mode mode ATTRIBUTE_UNUSED,\n+                              addr_space_t as ATTRIBUTE_UNUSED,\n                               RTX_CODE outer_code,\n                               RTX_CODE index_code ATTRIBUTE_UNUSED)\n {\n@@ -8064,6 +8065,7 @@ avr_mode_code_base_reg_class (enum machine_mode mode ATTRIBUTE_UNUSED,\n bool\n avr_regno_mode_code_ok_for_base_p (int regno,\n                                    enum machine_mode mode ATTRIBUTE_UNUSED,\n+                                   addr_space_t as ATTRIBUTE_UNUSED,\n                                    RTX_CODE outer_code,\n                                    RTX_CODE index_code ATTRIBUTE_UNUSED)\n {"}, {"sha": "7a3bc738e92c7bdb1483247b3abe4058982be2a9", "filename": "gcc/config/avr/avr.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86fc3d06b086930c41fa9fa1be82a0fa92699a12/gcc%2Fconfig%2Favr%2Favr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86fc3d06b086930c41fa9fa1be82a0fa92699a12/gcc%2Fconfig%2Favr%2Favr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.h?ref=86fc3d06b086930c41fa9fa1be82a0fa92699a12", "patch": "@@ -308,13 +308,13 @@ enum reg_class {\n \n #define REGNO_REG_CLASS(R) avr_regno_reg_class(R)\n \n-#define MODE_CODE_BASE_REG_CLASS(mode, outer_code, index_code) \\\n-  avr_mode_code_base_reg_class (mode, outer_code, index_code)\n+#define MODE_CODE_BASE_REG_CLASS(mode, as, outer_code, index_code)   \\\n+  avr_mode_code_base_reg_class (mode, as, outer_code, index_code)\n \n #define INDEX_REG_CLASS NO_REGS\n \n-#define REGNO_MODE_CODE_OK_FOR_BASE_P(num, mode, outer_code, index_code) \\\n-  avr_regno_mode_code_ok_for_base_p (num, mode, outer_code, index_code)\n+#define REGNO_MODE_CODE_OK_FOR_BASE_P(num, mode, as, outer_code, index_code) \\\n+  avr_regno_mode_code_ok_for_base_p (num, mode, as, outer_code, index_code)\n \n #define REGNO_OK_FOR_INDEX_P(NUM) 0\n "}, {"sha": "a16feca370b2acada309034a15a4d6f20e8f1bd5", "filename": "gcc/config/bfin/bfin.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86fc3d06b086930c41fa9fa1be82a0fa92699a12/gcc%2Fconfig%2Fbfin%2Fbfin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86fc3d06b086930c41fa9fa1be82a0fa92699a12/gcc%2Fconfig%2Fbfin%2Fbfin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbfin%2Fbfin.h?ref=86fc3d06b086930c41fa9fa1be82a0fa92699a12", "patch": "@@ -612,7 +612,7 @@ enum reg_class\n    || (OUTER) == POST_DEC || (OUTER) == PRE_DEC\t\t     \\\n    || (OUTER) == MEM || (OUTER) == ADDRESS)\n \n-#define MODE_CODE_BASE_REG_CLASS(MODE, OUTER, INDEX)\t\t\t\\\n+#define MODE_CODE_BASE_REG_CLASS(MODE, AS, OUTER, INDEX)\t\\\n   ((MODE) == HImode && IREG_POSSIBLE_P (OUTER) ? IPREGS : PREGS)\n \n #define INDEX_REG_CLASS         PREGS\n@@ -627,10 +627,10 @@ enum reg_class\n    || REGNO_OK_FOR_BASE_STRICT_P (X, MODE, OUTER, INDEX))\n \n #ifdef REG_OK_STRICT\n-#define REGNO_MODE_CODE_OK_FOR_BASE_P(X, MODE, OUTER, INDEX) \\\n+#define REGNO_MODE_CODE_OK_FOR_BASE_P(X, MODE, AS, OUTER, INDEX) \\\n   REGNO_OK_FOR_BASE_STRICT_P (X, MODE, OUTER, INDEX)\n #else\n-#define REGNO_MODE_CODE_OK_FOR_BASE_P(X, MODE, OUTER, INDEX) \\\n+#define REGNO_MODE_CODE_OK_FOR_BASE_P(X, MODE, AS, OUTER, INDEX) \\\n   REGNO_OK_FOR_BASE_NONSTRICT_P (X, MODE, OUTER, INDEX)\n #endif\n "}, {"sha": "5a6ebda2e48fab6185457279e3a6cfa0b3fb27a6", "filename": "gcc/config/cris/cris.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86fc3d06b086930c41fa9fa1be82a0fa92699a12/gcc%2Fconfig%2Fcris%2Fcris.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86fc3d06b086930c41fa9fa1be82a0fa92699a12/gcc%2Fconfig%2Fcris%2Fcris.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Fcris.h?ref=86fc3d06b086930c41fa9fa1be82a0fa92699a12", "patch": "@@ -545,7 +545,7 @@ enum reg_class\n \n #define BASE_REG_CLASS GENERAL_REGS\n \n-#define MODE_CODE_BASE_REG_CLASS(MODE, OCODE, ICODE)\t\\\n+#define MODE_CODE_BASE_REG_CLASS(MODE, AS, OCODE, ICODE)\t\\\n   ((OCODE) != POST_INC ? BASE_REG_CLASS : GENNONACR_REGS)\n \n #define INDEX_REG_CLASS GENERAL_REGS\n@@ -560,7 +560,7 @@ enum reg_class\n \n /* REGNO_OK_FOR_BASE_P seems to be obsolete wrt. this one, but not yet\n    documented as such.  */\n-#define REGNO_MODE_CODE_OK_FOR_BASE_P(REGNO, MODE, OCODE, ICODE)\t\\\n+#define REGNO_MODE_CODE_OK_FOR_BASE_P(REGNO, MODE, AS, OCODE, ICODE)\t\\\n  (REGNO_OK_FOR_BASE_P (REGNO)\t\t\t\t\t\t\\\n   && ((OCODE) != POST_INC\t\t\t\t\t\t\\\n       || !((REGNO) == CRIS_ACR_REGNUM\t\t\t\t\t\\"}, {"sha": "10fd876fd09d11578371f3dd22c452b81be6f3d9", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86fc3d06b086930c41fa9fa1be82a0fa92699a12/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86fc3d06b086930c41fa9fa1be82a0fa92699a12/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=86fc3d06b086930c41fa9fa1be82a0fa92699a12", "patch": "@@ -2435,12 +2435,13 @@ register address.  You should define this macro if base plus index\n addresses have different requirements than other base register uses.\n @end defmac\n \n-@defmac MODE_CODE_BASE_REG_CLASS (@var{mode}, @var{outer_code}, @var{index_code})\n+@defmac MODE_CODE_BASE_REG_CLASS (@var{mode}, @var{address_space}, @var{outer_code}, @var{index_code})\n A C expression whose value is the register class to which a valid\n-base register must belong.  @var{outer_code} and @var{index_code} define the\n-context in which the base register occurs.  @var{outer_code} is the code of\n-the immediately enclosing expression (@code{MEM} for the top level of an\n-address, @code{ADDRESS} for something that occurs in an\n+base register for a memory reference in mode @var{mode} to address\n+space @var{address_space} must belong.  @var{outer_code} and @var{index_code}\n+define the context in which the base register occurs.  @var{outer_code} is\n+the code of the immediately enclosing expression (@code{MEM} for the top level\n+of an address, @code{ADDRESS} for something that occurs in an\n @code{address_operand}).  @var{index_code} is the code of the corresponding\n index expression if @var{outer_code} is @code{PLUS}; @code{SCRATCH} otherwise.\n @end defmac\n@@ -2480,8 +2481,11 @@ Use of this macro is deprecated; please use the more general\n @code{REGNO_MODE_CODE_OK_FOR_BASE_P}.\n @end defmac\n \n-@defmac REGNO_MODE_CODE_OK_FOR_BASE_P (@var{num}, @var{mode}, @var{outer_code}, @var{index_code})\n-A C expression that is just like @code{REGNO_MODE_OK_FOR_BASE_P}, except\n+@defmac REGNO_MODE_CODE_OK_FOR_BASE_P (@var{num}, @var{mode}, @var{address_space}, @var{outer_code}, @var{index_code})\n+A C expression which is nonzero if register number @var{num} is\n+suitable for use as a base register in operand addresses, accessing\n+memory in mode @var{mode} in address space @var{address_space}.\n+This is similar to @code{REGNO_MODE_OK_FOR_BASE_P}, except\n that that expression may examine the context in which the register\n appears in the memory reference.  @var{outer_code} is the code of the\n immediately enclosing expression (@code{MEM} if at the top level of the"}, {"sha": "cebeb1fa7776f939607dd2fd7b29e465a10b68c4", "filename": "gcc/doc/tm.texi.in", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86fc3d06b086930c41fa9fa1be82a0fa92699a12/gcc%2Fdoc%2Ftm.texi.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86fc3d06b086930c41fa9fa1be82a0fa92699a12/gcc%2Fdoc%2Ftm.texi.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi.in?ref=86fc3d06b086930c41fa9fa1be82a0fa92699a12", "patch": "@@ -2423,12 +2423,13 @@ register address.  You should define this macro if base plus index\n addresses have different requirements than other base register uses.\n @end defmac\n \n-@defmac MODE_CODE_BASE_REG_CLASS (@var{mode}, @var{outer_code}, @var{index_code})\n+@defmac MODE_CODE_BASE_REG_CLASS (@var{mode}, @var{address_space}, @var{outer_code}, @var{index_code})\n A C expression whose value is the register class to which a valid\n-base register must belong.  @var{outer_code} and @var{index_code} define the\n-context in which the base register occurs.  @var{outer_code} is the code of\n-the immediately enclosing expression (@code{MEM} for the top level of an\n-address, @code{ADDRESS} for something that occurs in an\n+base register for a memory reference in mode @var{mode} to address\n+space @var{address_space} must belong.  @var{outer_code} and @var{index_code}\n+define the context in which the base register occurs.  @var{outer_code} is\n+the code of the immediately enclosing expression (@code{MEM} for the top level\n+of an address, @code{ADDRESS} for something that occurs in an\n @code{address_operand}).  @var{index_code} is the code of the corresponding\n index expression if @var{outer_code} is @code{PLUS}; @code{SCRATCH} otherwise.\n @end defmac\n@@ -2468,8 +2469,11 @@ Use of this macro is deprecated; please use the more general\n @code{REGNO_MODE_CODE_OK_FOR_BASE_P}.\n @end defmac\n \n-@defmac REGNO_MODE_CODE_OK_FOR_BASE_P (@var{num}, @var{mode}, @var{outer_code}, @var{index_code})\n-A C expression that is just like @code{REGNO_MODE_OK_FOR_BASE_P}, except\n+@defmac REGNO_MODE_CODE_OK_FOR_BASE_P (@var{num}, @var{mode}, @var{address_space}, @var{outer_code}, @var{index_code})\n+A C expression which is nonzero if register number @var{num} is\n+suitable for use as a base register in operand addresses, accessing\n+memory in mode @var{mode} in address space @var{address_space}.\n+This is similar to @code{REGNO_MODE_OK_FOR_BASE_P}, except\n that that expression may examine the context in which the register\n appears in the memory reference.  @var{outer_code} is the code of the\n immediately enclosing expression (@code{MEM} if at the top level of the"}, {"sha": "225a3ab17f2652f94d4af0499bae5928d6140c84", "filename": "gcc/ira-conflicts.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86fc3d06b086930c41fa9fa1be82a0fa92699a12/gcc%2Fira-conflicts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86fc3d06b086930c41fa9fa1be82a0fa92699a12/gcc%2Fira-conflicts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-conflicts.c?ref=86fc3d06b086930c41fa9fa1be82a0fa92699a12", "patch": "@@ -845,6 +845,7 @@ ira_debug_conflicts (bool reg_p)\n void\n ira_build_conflicts (void)\n {\n+  enum reg_class base;\n   ira_allocno_t a;\n   ira_allocno_iterator ai;\n   HARD_REG_SET temp_hard_reg_set;\n@@ -874,13 +875,12 @@ ira_build_conflicts (void)\n \t  ira_free (conflicts);\n \t}\n     }\n-  if (! targetm.class_likely_spilled_p (base_reg_class (VOIDmode, ADDRESS,\n-\t\t\t\t\t\t\tSCRATCH)))\n+  base = base_reg_class (VOIDmode, ADDR_SPACE_GENERIC, ADDRESS, SCRATCH);\n+  if (! targetm.class_likely_spilled_p (base))\n     CLEAR_HARD_REG_SET (temp_hard_reg_set);\n   else\n     {\n-      COPY_HARD_REG_SET (temp_hard_reg_set,\n-\t\t\t reg_class_contents[base_reg_class (VOIDmode, ADDRESS, SCRATCH)]);\n+      COPY_HARD_REG_SET (temp_hard_reg_set, reg_class_contents[base]);\n       AND_COMPL_HARD_REG_SET (temp_hard_reg_set, ira_no_alloc_regs);\n       AND_HARD_REG_SET (temp_hard_reg_set, call_used_reg_set);\n     }"}, {"sha": "4fa12a2ae19fc86e108ca28e2891bfb79c071043", "filename": "gcc/ira-costs.c", "status": "modified", "additions": 48, "deletions": 41, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86fc3d06b086930c41fa9fa1be82a0fa92699a12/gcc%2Fira-costs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86fc3d06b086930c41fa9fa1be82a0fa92699a12/gcc%2Fira-costs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-costs.c?ref=86fc3d06b086930c41fa9fa1be82a0fa92699a12", "patch": "@@ -637,7 +637,8 @@ record_reg_classes (int n_alts, int n_ops, rtx *ops,\n \t\t     base of an address, i.e. BASE_REG_CLASS.  */\n \t\t  classes[i]\n \t\t    = ira_reg_class_subunion[classes[i]]\n-\t\t      [base_reg_class (VOIDmode, ADDRESS, SCRATCH)];\n+\t\t      [base_reg_class (VOIDmode, ADDR_SPACE_GENERIC,\n+\t\t\t\t       ADDRESS, SCRATCH)];\n \t\t  break;\n \n \t\tcase 'm':  case 'o':  case 'V':\n@@ -752,7 +753,8 @@ record_reg_classes (int n_alts, int n_ops, rtx *ops,\n \t\t\t i.e. BASE_REG_CLASS.  */\n \t\t      classes[i]\n \t\t\t= ira_reg_class_subunion[classes[i]]\n-\t\t\t  [base_reg_class (VOIDmode, ADDRESS, SCRATCH)];\n+\t\t\t  [base_reg_class (VOIDmode, ADDR_SPACE_GENERIC,\n+\t\t\t\t\t   ADDRESS, SCRATCH)];\n \t\t    }\n #endif\n \t\t  break;\n@@ -996,14 +998,14 @@ ok_for_index_p_nonstrict (rtx reg)\n    pseudo-registers should count as OK.  Arguments as for\n    regno_ok_for_base_p.  */\n static inline bool\n-ok_for_base_p_nonstrict (rtx reg, enum machine_mode mode,\n+ok_for_base_p_nonstrict (rtx reg, enum machine_mode mode, addr_space_t as,\n \t\t\t enum rtx_code outer_code, enum rtx_code index_code)\n {\n   unsigned regno = REGNO (reg);\n \n   if (regno >= FIRST_PSEUDO_REGISTER)\n     return true;\n-  return ok_for_base_p_1 (regno, mode, outer_code, index_code);\n+  return ok_for_base_p_1 (regno, mode, as, outer_code, index_code);\n }\n \n /* Record the pseudo registers we must reload into hard registers in a\n@@ -1012,24 +1014,24 @@ ok_for_base_p_nonstrict (rtx reg, enum machine_mode mode,\n    If CONTEXT is 0, we are looking at the base part of an address,\n    otherwise we are looking at the index part.\n \n-   MODE is the mode of the memory reference; OUTER_CODE and INDEX_CODE\n-   give the context that the rtx appears in.  These three arguments\n-   are passed down to base_reg_class.\n+   MODE and AS are the mode and address space of the memory reference;\n+   OUTER_CODE and INDEX_CODE give the context that the rtx appears in.\n+   These four arguments are passed down to base_reg_class.\n \n    SCALE is twice the amount to multiply the cost by (it is twice so\n    we can represent half-cost adjustments).  */\n static void\n-record_address_regs (enum machine_mode mode, rtx x, int context,\n-\t\t     enum rtx_code outer_code, enum rtx_code index_code,\n-\t\t     int scale)\n+record_address_regs (enum machine_mode mode, addr_space_t as, rtx x,\n+\t\t     int context, enum rtx_code outer_code,\n+\t\t     enum rtx_code index_code, int scale)\n {\n   enum rtx_code code = GET_CODE (x);\n   enum reg_class rclass;\n \n   if (context == 1)\n     rclass = INDEX_REG_CLASS;\n   else\n-    rclass = base_reg_class (mode, outer_code, index_code);\n+    rclass = base_reg_class (mode, as, outer_code, index_code);\n \n   switch (code)\n     {\n@@ -1068,67 +1070,68 @@ record_address_regs (enum machine_mode mode, rtx x, int context,\n \t/* If this machine only allows one register per address, it\n \t   must be in the first operand.  */\n \tif (MAX_REGS_PER_ADDRESS == 1)\n-\t  record_address_regs (mode, arg0, 0, PLUS, code1, scale);\n+\t  record_address_regs (mode, as, arg0, 0, PLUS, code1, scale);\n \n \t/* If index and base registers are the same on this machine,\n \t   just record registers in any non-constant operands.  We\n \t   assume here, as well as in the tests below, that all\n \t   addresses are in canonical form.  */\n-\telse if (INDEX_REG_CLASS == base_reg_class (VOIDmode, PLUS, SCRATCH))\n+\telse if (INDEX_REG_CLASS\n+\t\t == base_reg_class (VOIDmode, as, PLUS, SCRATCH))\n \t  {\n-\t    record_address_regs (mode, arg0, context, PLUS, code1, scale);\n+\t    record_address_regs (mode, as, arg0, context, PLUS, code1, scale);\n \t    if (! CONSTANT_P (arg1))\n-\t      record_address_regs (mode, arg1, context, PLUS, code0, scale);\n+\t      record_address_regs (mode, as, arg1, context, PLUS, code0, scale);\n \t  }\n \n \t/* If the second operand is a constant integer, it doesn't\n \t   change what class the first operand must be.  */\n \telse if (code1 == CONST_INT || code1 == CONST_DOUBLE)\n-\t  record_address_regs (mode, arg0, context, PLUS, code1, scale);\n+\t  record_address_regs (mode, as, arg0, context, PLUS, code1, scale);\n \t/* If the second operand is a symbolic constant, the first\n \t   operand must be an index register.  */\n \telse if (code1 == SYMBOL_REF || code1 == CONST || code1 == LABEL_REF)\n-\t  record_address_regs (mode, arg0, 1, PLUS, code1, scale);\n+\t  record_address_regs (mode, as, arg0, 1, PLUS, code1, scale);\n \t/* If both operands are registers but one is already a hard\n \t   register of index or reg-base class, give the other the\n \t   class that the hard register is not.  */\n \telse if (code0 == REG && code1 == REG\n \t\t && REGNO (arg0) < FIRST_PSEUDO_REGISTER\n-\t\t && (ok_for_base_p_nonstrict (arg0, mode, PLUS, REG)\n+\t\t && (ok_for_base_p_nonstrict (arg0, mode, as, PLUS, REG)\n \t\t     || ok_for_index_p_nonstrict (arg0)))\n-\t  record_address_regs (mode, arg1,\n-\t\t\t       ok_for_base_p_nonstrict (arg0, mode, PLUS, REG)\n-\t\t\t       ? 1 : 0,\n+\t  record_address_regs (mode, as, arg1,\n+\t\t\t       ok_for_base_p_nonstrict (arg0, mode, as,\n+\t\t\t\t\t\t\tPLUS, REG) ? 1 : 0,\n \t\t\t       PLUS, REG, scale);\n \telse if (code0 == REG && code1 == REG\n \t\t && REGNO (arg1) < FIRST_PSEUDO_REGISTER\n-\t\t && (ok_for_base_p_nonstrict (arg1, mode, PLUS, REG)\n+\t\t && (ok_for_base_p_nonstrict (arg1, mode, as, PLUS, REG)\n \t\t     || ok_for_index_p_nonstrict (arg1)))\n-\t  record_address_regs (mode, arg0,\n-\t\t\t       ok_for_base_p_nonstrict (arg1, mode, PLUS, REG)\n-\t\t\t       ? 1 : 0,\n+\t  record_address_regs (mode, as, arg0,\n+\t\t\t       ok_for_base_p_nonstrict (arg1, mode, as,\n+\t\t\t\t\t\t\tPLUS, REG) ? 1 : 0,\n \t\t\t       PLUS, REG, scale);\n \t/* If one operand is known to be a pointer, it must be the\n \t   base with the other operand the index.  Likewise if the\n \t   other operand is a MULT.  */\n \telse if ((code0 == REG && REG_POINTER (arg0)) || code1 == MULT)\n \t  {\n-\t    record_address_regs (mode, arg0, 0, PLUS, code1, scale);\n-\t    record_address_regs (mode, arg1, 1, PLUS, code0, scale);\n+\t    record_address_regs (mode, as, arg0, 0, PLUS, code1, scale);\n+\t    record_address_regs (mode, as, arg1, 1, PLUS, code0, scale);\n \t  }\n \telse if ((code1 == REG && REG_POINTER (arg1)) || code0 == MULT)\n \t  {\n-\t    record_address_regs (mode, arg0, 1, PLUS, code1, scale);\n-\t    record_address_regs (mode, arg1, 0, PLUS, code0, scale);\n+\t    record_address_regs (mode, as, arg0, 1, PLUS, code1, scale);\n+\t    record_address_regs (mode, as, arg1, 0, PLUS, code0, scale);\n \t  }\n \t/* Otherwise, count equal chances that each might be a base or\n \t   index register.  This case should be rare.  */\n \telse\n \t  {\n-\t    record_address_regs (mode, arg0, 0, PLUS, code1, scale / 2);\n-\t    record_address_regs (mode, arg0, 1, PLUS, code1, scale / 2);\n-\t    record_address_regs (mode, arg1, 0, PLUS, code0, scale / 2);\n-\t    record_address_regs (mode, arg1, 1, PLUS, code0, scale / 2);\n+\t    record_address_regs (mode, as, arg0, 0, PLUS, code1, scale / 2);\n+\t    record_address_regs (mode, as, arg0, 1, PLUS, code1, scale / 2);\n+\t    record_address_regs (mode, as, arg1, 0, PLUS, code0, scale / 2);\n+\t    record_address_regs (mode, as, arg1, 1, PLUS, code0, scale / 2);\n \t  }\n       }\n       break;\n@@ -1138,10 +1141,10 @@ record_address_regs (enum machine_mode mode, rtx x, int context,\n \t up in the wrong place.  */\n     case POST_MODIFY:\n     case PRE_MODIFY:\n-      record_address_regs (mode, XEXP (x, 0), 0, code,\n+      record_address_regs (mode, as, XEXP (x, 0), 0, code,\n \t\t\t   GET_CODE (XEXP (XEXP (x, 1), 1)), 2 * scale);\n       if (REG_P (XEXP (XEXP (x, 1), 1)))\n-\trecord_address_regs (mode, XEXP (XEXP (x, 1), 1), 1, code, REG,\n+\trecord_address_regs (mode, as, XEXP (XEXP (x, 1), 1), 1, code, REG,\n \t\t\t     2 * scale);\n       break;\n \n@@ -1152,7 +1155,7 @@ record_address_regs (enum machine_mode mode, rtx x, int context,\n       /* Double the importance of an allocno that is incremented or\n \t decremented, since it would take two extra insns if it ends\n \t up in the wrong place.  */\n-      record_address_regs (mode, XEXP (x, 0), 0, code, SCRATCH, 2 * scale);\n+      record_address_regs (mode, as, XEXP (x, 0), 0, code, SCRATCH, 2 * scale);\n       break;\n \n     case REG:\n@@ -1200,7 +1203,7 @@ record_address_regs (enum machine_mode mode, rtx x, int context,\n \tint i;\n \tfor (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n \t  if (fmt[i] == 'e')\n-\t    record_address_regs (mode, XEXP (x, i), context, code, SCRATCH,\n+\t    record_address_regs (mode, as, XEXP (x, i), context, code, SCRATCH,\n \t\t\t\t scale);\n       }\n     }\n@@ -1236,13 +1239,15 @@ record_operand_costs (rtx insn, enum reg_class *pref)\n \n       if (MEM_P (recog_data.operand[i]))\n \trecord_address_regs (GET_MODE (recog_data.operand[i]),\n+\t\t\t     MEM_ADDR_SPACE (recog_data.operand[i]),\n \t\t\t     XEXP (recog_data.operand[i], 0),\n \t\t\t     0, MEM, SCRATCH, frequency * 2);\n       else if (constraints[i][0] == 'p'\n \t       || EXTRA_ADDRESS_CONSTRAINT (constraints[i][0],\n \t\t\t\t\t    constraints[i]))\n-\trecord_address_regs (VOIDmode, recog_data.operand[i], 0, ADDRESS,\n-\t\t\t     SCRATCH, frequency * 2);\n+\trecord_address_regs (VOIDmode, ADDR_SPACE_GENERIC,\n+\t\t\t     recog_data.operand[i], 0, ADDRESS, SCRATCH,\n+\t\t\t     frequency * 2);\n     }\n   \n   /* Check for commutative in a separate loop so everything will have\n@@ -1316,8 +1321,10 @@ scan_one_insn (rtx insn)\n \n       COSTS (costs, num)->mem_cost\n \t-= ira_memory_move_cost[GET_MODE (reg)][cl][1] * frequency;\n-      record_address_regs (GET_MODE (SET_SRC (set)), XEXP (SET_SRC (set), 0),\n-\t\t\t   0, MEM, SCRATCH, frequency * 2);\n+      record_address_regs (GET_MODE (SET_SRC (set)),\n+\t\t\t   MEM_ADDR_SPACE (SET_SRC (set)),\n+\t\t\t   XEXP (SET_SRC (set), 0), 0, MEM, SCRATCH,\n+\t\t\t   frequency * 2);\n       counted_mem = true;\n     }\n "}, {"sha": "17cec759905bb6eff848850586c4e877e1282da7", "filename": "gcc/recog.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86fc3d06b086930c41fa9fa1be82a0fa92699a12/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86fc3d06b086930c41fa9fa1be82a0fa92699a12/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=86fc3d06b086930c41fa9fa1be82a0fa92699a12", "patch": "@@ -2281,7 +2281,8 @@ preprocess_constraints (void)\n \t\tcase 'p':\n \t\t  op_alt[j].is_address = 1;\n \t\t  op_alt[j].cl = reg_class_subunion[(int) op_alt[j].cl]\n-\t\t      [(int) base_reg_class (VOIDmode, ADDRESS, SCRATCH)];\n+\t\t      [(int) base_reg_class (VOIDmode, ADDR_SPACE_GENERIC,\n+\t\t\t\t\t     ADDRESS, SCRATCH)];\n \t\t  break;\n \n \t\tcase 'g':\n@@ -2302,8 +2303,8 @@ preprocess_constraints (void)\n \t\t      op_alt[j].cl\n \t\t\t= (reg_class_subunion\n \t\t\t   [(int) op_alt[j].cl]\n-\t\t\t   [(int) base_reg_class (VOIDmode, ADDRESS,\n-\t\t\t\t\t\t  SCRATCH)]);\n+\t\t\t   [(int) base_reg_class (VOIDmode, ADDR_SPACE_GENERIC,\n+\t\t\t\t\t\t  ADDRESS, SCRATCH)]);\n \t\t      break;\n \t\t    }\n "}, {"sha": "ceb46355359eaaa818c28e70902ab986d5aa7144", "filename": "gcc/regcprop.c", "status": "modified", "additions": 19, "deletions": 17, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86fc3d06b086930c41fa9fa1be82a0fa92699a12/gcc%2Fregcprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86fc3d06b086930c41fa9fa1be82a0fa92699a12/gcc%2Fregcprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregcprop.c?ref=86fc3d06b086930c41fa9fa1be82a0fa92699a12", "patch": "@@ -98,7 +98,7 @@ static rtx find_oldest_value_reg (enum reg_class, rtx, struct value_data *);\n static bool replace_oldest_value_reg (rtx *, enum reg_class, rtx,\n \t\t\t\t      struct value_data *);\n static bool replace_oldest_value_addr (rtx *, enum reg_class,\n-\t\t\t\t       enum machine_mode, rtx,\n+\t\t\t\t       enum machine_mode, addr_space_t, rtx,\n \t\t\t\t       struct value_data *);\n static bool replace_oldest_value_mem (rtx, rtx, struct value_data *);\n static bool copyprop_hardreg_forward_1 (basic_block, struct value_data *);\n@@ -515,8 +515,8 @@ replace_oldest_value_reg (rtx *loc, enum reg_class cl, rtx insn,\n \n static bool\n replace_oldest_value_addr (rtx *loc, enum reg_class cl,\n-\t\t\t   enum machine_mode mode, rtx insn,\n-\t\t\t   struct value_data *vd)\n+\t\t\t   enum machine_mode mode, addr_space_t as,\n+\t\t\t   rtx insn, struct value_data *vd)\n {\n   rtx x = *loc;\n   RTX_CODE code = GET_CODE (x);\n@@ -585,15 +585,15 @@ replace_oldest_value_addr (rtx *loc, enum reg_class cl,\n \t    unsigned regno0 = REGNO (op0), regno1 = REGNO (op1);\n \n \t    if (REGNO_OK_FOR_INDEX_P (regno1)\n-\t\t&& regno_ok_for_base_p (regno0, mode, PLUS, REG))\n+\t\t&& regno_ok_for_base_p (regno0, mode, as, PLUS, REG))\n \t      index_op = 1;\n \t    else if (REGNO_OK_FOR_INDEX_P (regno0)\n-\t\t     && regno_ok_for_base_p (regno1, mode, PLUS, REG))\n+\t\t     && regno_ok_for_base_p (regno1, mode, as, PLUS, REG))\n \t      index_op = 0;\n-\t    else if (regno_ok_for_base_p (regno0, mode, PLUS, REG)\n+\t    else if (regno_ok_for_base_p (regno0, mode, as, PLUS, REG)\n \t\t     || REGNO_OK_FOR_INDEX_P (regno1))\n \t      index_op = 1;\n-\t    else if (regno_ok_for_base_p (regno1, mode, PLUS, REG))\n+\t    else if (regno_ok_for_base_p (regno1, mode, as, PLUS, REG))\n \t      index_op = 0;\n \t    else\n \t      index_op = 1;\n@@ -616,13 +616,13 @@ replace_oldest_value_addr (rtx *loc, enum reg_class cl,\n \t  }\n \n \tif (locI)\n-\t  changed |= replace_oldest_value_addr (locI, INDEX_REG_CLASS, mode,\n-\t\t\t\t\t\tinsn, vd);\n+\t  changed |= replace_oldest_value_addr (locI, INDEX_REG_CLASS,\n+\t\t\t\t\t\tmode, as, insn, vd);\n \tif (locB)\n \t  changed |= replace_oldest_value_addr (locB,\n-\t\t\t\t\t\tbase_reg_class (mode, PLUS,\n+\t\t\t\t\t\tbase_reg_class (mode, as, PLUS,\n \t\t\t\t\t\t\t\tindex_code),\n-\t\t\t\t\t\tmode, insn, vd);\n+\t\t\t\t\t\tmode, as, insn, vd);\n \treturn changed;\n       }\n \n@@ -648,12 +648,12 @@ replace_oldest_value_addr (rtx *loc, enum reg_class cl,\n   for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n     {\n       if (fmt[i] == 'e')\n-\tchanged |= replace_oldest_value_addr (&XEXP (x, i), cl, mode,\n+\tchanged |= replace_oldest_value_addr (&XEXP (x, i), cl, mode, as,\n \t\t\t\t\t      insn, vd);\n       else if (fmt[i] == 'E')\n \tfor (j = XVECLEN (x, i) - 1; j >= 0; j--)\n \t  changed |= replace_oldest_value_addr (&XVECEXP (x, i, j), cl,\n-\t\t\t\t\t\tmode, insn, vd);\n+\t\t\t\t\t\tmode, as, insn, vd);\n     }\n \n   return changed;\n@@ -669,10 +669,11 @@ replace_oldest_value_mem (rtx x, rtx insn, struct value_data *vd)\n   if (DEBUG_INSN_P (insn))\n     cl = ALL_REGS;\n   else\n-    cl = base_reg_class (GET_MODE (x), MEM, SCRATCH);\n+    cl = base_reg_class (GET_MODE (x), MEM_ADDR_SPACE (x), MEM, SCRATCH);\n \n   return replace_oldest_value_addr (&XEXP (x, 0), cl,\n-\t\t\t\t    GET_MODE (x), insn, vd);\n+\t\t\t\t    GET_MODE (x), MEM_ADDR_SPACE (x),\n+\t\t\t\t    insn, vd);\n }\n \n /* Apply all queued updates for DEBUG_INSNs that change some reg to\n@@ -751,7 +752,7 @@ copyprop_hardreg_forward_1 (basic_block bb, struct value_data *vd)\n \t      if (!VAR_LOC_UNKNOWN_P (loc))\n \t\treplace_oldest_value_addr (&INSN_VAR_LOCATION_LOC (insn),\n \t\t\t\t\t   ALL_REGS, GET_MODE (loc),\n-\t\t\t\t\t   insn, vd);\n+\t\t\t\t\t   ADDR_SPACE_GENERIC, insn, vd);\n \t    }\n \n \t  if (insn == BB_END (bb))\n@@ -913,7 +914,8 @@ copyprop_hardreg_forward_1 (basic_block bb, struct value_data *vd)\n \t\treplaced[i]\n \t\t  = replace_oldest_value_addr (recog_data.operand_loc[i],\n \t\t\t\t\t       recog_op_alt[i][alt].cl,\n-\t\t\t\t\t       VOIDmode, insn, vd);\n+\t\t\t\t\t       VOIDmode, ADDR_SPACE_GENERIC,\n+\t\t\t\t\t       insn, vd);\n \t      else if (REG_P (recog_data.operand[i]))\n \t\treplaced[i]\n \t\t  = replace_oldest_value_reg (recog_data.operand_loc[i],"}, {"sha": "de39e9052e702e5a2beaef43ce4d520f85ae31e9", "filename": "gcc/regrename.c", "status": "modified", "additions": 20, "deletions": 15, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86fc3d06b086930c41fa9fa1be82a0fa92699a12/gcc%2Fregrename.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86fc3d06b086930c41fa9fa1be82a0fa92699a12/gcc%2Fregrename.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregrename.c?ref=86fc3d06b086930c41fa9fa1be82a0fa92699a12", "patch": "@@ -1182,7 +1182,8 @@ scan_rtx_reg (rtx insn, rtx *loc, enum reg_class cl, enum scan_actions action,\n \n static void\n scan_rtx_address (rtx insn, rtx *loc, enum reg_class cl,\n-\t\t  enum scan_actions action, enum machine_mode mode)\n+\t\t  enum scan_actions action, enum machine_mode mode,\n+\t\t  addr_space_t as)\n {\n   rtx x = *loc;\n   RTX_CODE code = GET_CODE (x);\n@@ -1250,15 +1251,15 @@ scan_rtx_address (rtx insn, rtx *loc, enum reg_class cl,\n \t    unsigned regno0 = REGNO (op0), regno1 = REGNO (op1);\n \n \t    if (REGNO_OK_FOR_INDEX_P (regno1)\n-\t\t&& regno_ok_for_base_p (regno0, mode, PLUS, REG))\n+\t\t&& regno_ok_for_base_p (regno0, mode, as, PLUS, REG))\n \t      index_op = 1;\n \t    else if (REGNO_OK_FOR_INDEX_P (regno0)\n-\t\t     && regno_ok_for_base_p (regno1, mode, PLUS, REG))\n+\t\t     && regno_ok_for_base_p (regno1, mode, as, PLUS, REG))\n \t      index_op = 0;\n-\t    else if (regno_ok_for_base_p (regno0, mode, PLUS, REG)\n+\t    else if (regno_ok_for_base_p (regno0, mode, as, PLUS, REG)\n \t\t     || REGNO_OK_FOR_INDEX_P (regno1))\n \t      index_op = 1;\n-\t    else if (regno_ok_for_base_p (regno1, mode, PLUS, REG))\n+\t    else if (regno_ok_for_base_p (regno1, mode, as, PLUS, REG))\n \t      index_op = 0;\n \t    else\n \t      index_op = 1;\n@@ -1281,10 +1282,11 @@ scan_rtx_address (rtx insn, rtx *loc, enum reg_class cl,\n \t  }\n \n \tif (locI)\n-\t  scan_rtx_address (insn, locI, INDEX_REG_CLASS, action, mode);\n+\t  scan_rtx_address (insn, locI, INDEX_REG_CLASS, action, mode, as);\n \tif (locB)\n-\t  scan_rtx_address (insn, locB, base_reg_class (mode, PLUS, index_code),\n-\t\t\t    action, mode);\n+\t  scan_rtx_address (insn, locB,\n+\t\t\t    base_reg_class (mode, as, PLUS, index_code),\n+\t\t\t    action, mode, as);\n \n \treturn;\n       }\n@@ -1304,8 +1306,9 @@ scan_rtx_address (rtx insn, rtx *loc, enum reg_class cl,\n \n     case MEM:\n       scan_rtx_address (insn, &XEXP (x, 0),\n-\t\t\tbase_reg_class (GET_MODE (x), MEM, SCRATCH), action,\n-\t\t\tGET_MODE (x));\n+\t\t\tbase_reg_class (GET_MODE (x), MEM_ADDR_SPACE (x),\n+\t\t\t\t\tMEM, SCRATCH),\n+\t\t\taction, GET_MODE (x), MEM_ADDR_SPACE (x));\n       return;\n \n     case REG:\n@@ -1320,10 +1323,10 @@ scan_rtx_address (rtx insn, rtx *loc, enum reg_class cl,\n   for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n     {\n       if (fmt[i] == 'e')\n-\tscan_rtx_address (insn, &XEXP (x, i), cl, action, mode);\n+\tscan_rtx_address (insn, &XEXP (x, i), cl, action, mode, as);\n       else if (fmt[i] == 'E')\n \tfor (j = XVECLEN (x, i) - 1; j >= 0; j--)\n-\t  scan_rtx_address (insn, &XVECEXP (x, i, j), cl, action, mode);\n+\t  scan_rtx_address (insn, &XVECEXP (x, i, j), cl, action, mode, as);\n     }\n }\n \n@@ -1356,8 +1359,9 @@ scan_rtx (rtx insn, rtx *loc, enum reg_class cl, enum scan_actions action,\n \n     case MEM:\n       scan_rtx_address (insn, &XEXP (x, 0),\n-\t\t\tbase_reg_class (GET_MODE (x), MEM, SCRATCH), action,\n-\t\t\tGET_MODE (x));\n+\t\t\tbase_reg_class (GET_MODE (x), MEM_ADDR_SPACE (x),\n+\t\t\t\t\tMEM, SCRATCH),\n+\t\t\taction, GET_MODE (x), MEM_ADDR_SPACE (x));\n       return;\n \n     case SET:\n@@ -1697,7 +1701,8 @@ build_def_use (basic_block bb)\n \t      if (insn_info)\n \t\tcur_operand = i == opn ? insn_info->op_info + i : NULL;\n \t      if (recog_op_alt[opn][alt].is_address)\n-\t\tscan_rtx_address (insn, loc, cl, mark_read, VOIDmode);\n+\t\tscan_rtx_address (insn, loc, cl, mark_read,\n+\t\t\t\t  VOIDmode, ADDR_SPACE_GENERIC);\n \t      else\n \t\tscan_rtx (insn, loc, cl, mark_read, type);\n \t    }"}, {"sha": "896e8de9ff78a7ab1c7885cd37bcc440cc48c84f", "filename": "gcc/reload.c", "status": "modified", "additions": 66, "deletions": 60, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86fc3d06b086930c41fa9fa1be82a0fa92699a12/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86fc3d06b086930c41fa9fa1be82a0fa92699a12/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=86fc3d06b086930c41fa9fa1be82a0fa92699a12", "patch": "@@ -277,7 +277,7 @@ static int find_reloads_address (enum machine_mode, rtx *, rtx, rtx *,\n static rtx subst_reg_equivs (rtx, rtx);\n static rtx subst_indexed_address (rtx);\n static void update_auto_inc_notes (rtx, int, int);\n-static int find_reloads_address_1 (enum machine_mode, rtx, int,\n+static int find_reloads_address_1 (enum machine_mode, addr_space_t, rtx, int,\n \t\t\t\t   enum rtx_code, enum rtx_code, rtx *,\n \t\t\t\t   int, enum reload_type,int, rtx);\n static void find_reloads_address_part (rtx, rtx *, enum reg_class,\n@@ -3239,8 +3239,9 @@ find_reloads (rtx insn, int replace, int ind_levels, int live_known,\n \t      case 'p':\n \t\t/* All necessary reloads for an address_operand\n \t\t   were handled in find_reloads_address.  */\n-\t\tthis_alternative[i] = base_reg_class (VOIDmode, ADDRESS,\n-\t\t\t\t\t\t      SCRATCH);\n+\t\tthis_alternative[i]\n+\t\t  = base_reg_class (VOIDmode, ADDR_SPACE_GENERIC,\n+\t\t\t\t    ADDRESS, SCRATCH);\n \t\twin = 1;\n \t\tbadop = 0;\n \t\tbreak;\n@@ -3445,9 +3446,9 @@ find_reloads (rtx insn, int replace, int ind_levels, int live_known,\n \n \t\t\t/* If we didn't already win, we can reload\n \t\t\t   the address into a base register.  */\n-\t\t\tthis_alternative[i] = base_reg_class (VOIDmode,\n-\t\t\t\t\t\t\t      ADDRESS,\n-\t\t\t\t\t\t\t      SCRATCH);\n+\t\t\tthis_alternative[i]\n+\t\t\t  = base_reg_class (VOIDmode, ADDR_SPACE_GENERIC,\n+\t\t\t\t\t    ADDRESS, SCRATCH);\n \t\t\tbadop = 0;\n \t\t\tbreak;\n \t\t      }\n@@ -3977,18 +3978,16 @@ find_reloads (rtx insn, int replace, int ind_levels, int live_known,\n \t    /* If the address to be reloaded is a VOIDmode constant,\n \t       use the default address mode as mode of the reload register,\n \t       as would have been done by find_reloads_address.  */\n+\t    addr_space_t as = MEM_ADDR_SPACE (recog_data.operand[i]);\n \t    enum machine_mode address_mode;\n \t    address_mode = GET_MODE (XEXP (recog_data.operand[i], 0));\n \t    if (address_mode == VOIDmode)\n-\t      {\n-\t\taddr_space_t as = MEM_ADDR_SPACE (recog_data.operand[i]);\n-\t\taddress_mode = targetm.addr_space.address_mode (as);\n-\t      }\n+\t      address_mode = targetm.addr_space.address_mode (as);\n \n \t    operand_reloadnum[i]\n \t      = push_reload (XEXP (recog_data.operand[i], 0), NULL_RTX,\n \t\t\t     &XEXP (recog_data.operand[i], 0), (rtx*) 0,\n-\t\t\t     base_reg_class (VOIDmode, MEM, SCRATCH),\n+\t\t\t     base_reg_class (VOIDmode, as, MEM, SCRATCH),\n \t\t\t     address_mode,\n \t\t\t     VOIDmode, 0, 0, i, RELOAD_FOR_INPUT);\n \t    rld[operand_reloadnum[i]].inc\n@@ -4885,7 +4884,7 @@ find_reloads_address (enum machine_mode mode, rtx *memrefloc, rtx ad,\n       if (reg_equiv_constant (regno) != 0)\n \t{\n \t  find_reloads_address_part (reg_equiv_constant (regno), loc,\n-\t\t\t\t     base_reg_class (mode, MEM, SCRATCH),\n+\t\t\t\t     base_reg_class (mode, as, MEM, SCRATCH),\n \t\t\t\t     GET_MODE (ad), opnum, type, ind_levels);\n \t  return 1;\n \t}\n@@ -4948,12 +4947,13 @@ find_reloads_address (enum machine_mode mode, rtx *memrefloc, rtx ad,\n \t subject of a CLOBBER in this insn.  */\n \n       else if (regno < FIRST_PSEUDO_REGISTER\n-\t       && regno_ok_for_base_p (regno, mode, MEM, SCRATCH)\n+\t       && regno_ok_for_base_p (regno, mode, as, MEM, SCRATCH)\n \t       && ! regno_clobbered_p (regno, this_insn, mode, 0))\n \treturn 0;\n \n       /* If we do not have one of the cases above, we must do the reload.  */\n-      push_reload (ad, NULL_RTX, loc, (rtx*) 0, base_reg_class (mode, MEM, SCRATCH),\n+      push_reload (ad, NULL_RTX, loc, (rtx*) 0,\n+\t\t   base_reg_class (mode, as, MEM, SCRATCH),\n \t\t   GET_MODE (ad), VOIDmode, 0, 0, opnum, type);\n       return 1;\n     }\n@@ -5054,7 +5054,7 @@ find_reloads_address (enum machine_mode mode, rtx *memrefloc, rtx ad,\n \t  /* Must use TEM here, not AD, since it is the one that will\n \t     have any subexpressions reloaded, if needed.  */\n \t  push_reload (tem, NULL_RTX, loc, (rtx*) 0,\n-\t\t       base_reg_class (mode, MEM, SCRATCH), GET_MODE (tem),\n+\t\t       base_reg_class (mode, as, MEM, SCRATCH), GET_MODE (tem),\n \t\t       VOIDmode, 0,\n \t\t       0, opnum, type);\n \t  return ! removed_and;\n@@ -5072,7 +5072,7 @@ find_reloads_address (enum machine_mode mode, rtx *memrefloc, rtx ad,\n \t   && REG_P (XEXP (ad, 0))\n \t   && REGNO (XEXP (ad, 0)) < FIRST_PSEUDO_REGISTER\n \t   && CONST_INT_P (XEXP (ad, 1))\n-\t   && (regno_ok_for_base_p (REGNO (XEXP (ad, 0)), mode, PLUS,\n+\t   && (regno_ok_for_base_p (REGNO (XEXP (ad, 0)), mode, as, PLUS,\n \t\t\t\t    CONST_INT)\n \t       /* Similarly, if we were to reload the base register and the\n \t\t  mem+offset address is still invalid, then we want to reload\n@@ -5091,7 +5091,7 @@ find_reloads_address (enum machine_mode mode, rtx *memrefloc, rtx ad,\n \t}\n \n       if (double_reg_address_ok\n-\t  && regno_ok_for_base_p (REGNO (XEXP (ad, 0)), mode,\n+\t  && regno_ok_for_base_p (REGNO (XEXP (ad, 0)), mode, as,\n \t\t\t\t  PLUS, CONST_INT))\n \t{\n \t  /* Unshare the sum as well.  */\n@@ -5110,7 +5110,7 @@ find_reloads_address (enum machine_mode mode, rtx *memrefloc, rtx ad,\n \t     reload the sum into a base reg.\n \t     That will at least work.  */\n \t  find_reloads_address_part (ad, loc,\n-\t\t\t\t     base_reg_class (mode, MEM, SCRATCH),\n+\t\t\t\t     base_reg_class (mode, as, MEM, SCRATCH),\n \t\t\t\t     GET_MODE (ad), opnum, type, ind_levels);\n \t}\n       return ! removed_and;\n@@ -5162,7 +5162,7 @@ find_reloads_address (enum machine_mode mode, rtx *memrefloc, rtx ad,\n \n       addend = XEXP (XEXP (ad, 0), 1 - op_index);\n \n-      if ((regno_ok_for_base_p (REGNO (operand), mode, inner_code,\n+      if ((regno_ok_for_base_p (REGNO (operand), mode, as, inner_code,\n \t\t\t\tGET_CODE (addend))\n \t   || operand == frame_pointer_rtx\n #if !HARD_FRAME_POINTER_IS_FRAME_POINTER\n@@ -5191,11 +5191,11 @@ find_reloads_address (enum machine_mode mode, rtx *memrefloc, rtx ad,\n \t\t\t\t op_index == 0 ? addend : offset_reg);\n \t  *loc = ad;\n \n-\t  cls = base_reg_class (mode, MEM, GET_CODE (addend));\n+\t  cls = base_reg_class (mode, as, MEM, GET_CODE (addend));\n \t  find_reloads_address_part (XEXP (ad, op_index),\n \t\t\t\t     &XEXP (ad, op_index), cls,\n \t\t\t\t     GET_MODE (ad), opnum, type, ind_levels);\n-\t  find_reloads_address_1 (mode,\n+\t  find_reloads_address_1 (mode, as,\n \t\t\t\t  XEXP (ad, 1 - op_index), 1, GET_CODE (ad),\n \t\t\t\t  GET_CODE (XEXP (ad, op_index)),\n \t\t\t\t  &XEXP (ad, 1 - op_index), opnum,\n@@ -5248,13 +5248,14 @@ find_reloads_address (enum machine_mode mode, rtx *memrefloc, rtx ad,\n \t    loc = &XEXP (*loc, 0);\n \t}\n \n-      find_reloads_address_part (ad, loc, base_reg_class (mode, MEM, SCRATCH),\n+      find_reloads_address_part (ad, loc,\n+\t\t\t\t base_reg_class (mode, as, MEM, SCRATCH),\n \t\t\t\t address_mode, opnum, type, ind_levels);\n       return ! removed_and;\n     }\n \n-  return find_reloads_address_1 (mode, ad, 0, MEM, SCRATCH, loc, opnum, type,\n-\t\t\t\t ind_levels, insn);\n+  return find_reloads_address_1 (mode, as, ad, 0, MEM, SCRATCH, loc,\n+\t\t\t\t opnum, type, ind_levels, insn);\n }\n \f\n /* Find all pseudo regs appearing in AD\n@@ -5487,14 +5488,15 @@ update_auto_inc_notes (rtx insn ATTRIBUTE_UNUSED, int regno ATTRIBUTE_UNUSED,\n    handles those cases gracefully.  */\n \n static int\n-find_reloads_address_1 (enum machine_mode mode, rtx x, int context,\n+find_reloads_address_1 (enum machine_mode mode, addr_space_t as,\n+\t\t\trtx x, int context,\n \t\t\tenum rtx_code outer_code, enum rtx_code index_code,\n \t\t\trtx *loc, int opnum, enum reload_type type,\n \t\t\tint ind_levels, rtx insn)\n {\n-#define REG_OK_FOR_CONTEXT(CONTEXT, REGNO, MODE, OUTER, INDEX)\t\t\\\n+#define REG_OK_FOR_CONTEXT(CONTEXT, REGNO, MODE, AS, OUTER, INDEX)\t\\\n   ((CONTEXT) == 0\t\t\t\t\t\t\t\\\n-   ? regno_ok_for_base_p (REGNO, MODE, OUTER, INDEX)\t\t\t\\\n+   ? regno_ok_for_base_p (REGNO, MODE, AS, OUTER, INDEX)\t\t\\\n    : REGNO_OK_FOR_INDEX_P (REGNO))\n \n   enum reg_class context_reg_class;\n@@ -5503,7 +5505,7 @@ find_reloads_address_1 (enum machine_mode mode, rtx x, int context,\n   if (context == 1)\n     context_reg_class = INDEX_REG_CLASS;\n   else\n-    context_reg_class = base_reg_class (mode, outer_code, index_code);\n+    context_reg_class = base_reg_class (mode, as, outer_code, index_code);\n \n   switch (code)\n     {\n@@ -5560,88 +5562,88 @@ find_reloads_address_1 (enum machine_mode mode, rtx x, int context,\n \tif (code0 == MULT || code0 == SIGN_EXTEND || code0 == TRUNCATE\n \t    || code0 == ZERO_EXTEND || code1 == MEM)\n \t  {\n-\t    find_reloads_address_1 (mode, orig_op0, 1, PLUS, SCRATCH,\n+\t    find_reloads_address_1 (mode, as, orig_op0, 1, PLUS, SCRATCH,\n \t\t\t\t    &XEXP (x, 0), opnum, type, ind_levels,\n \t\t\t\t    insn);\n-\t    find_reloads_address_1 (mode, orig_op1, 0, PLUS, code0,\n+\t    find_reloads_address_1 (mode, as, orig_op1, 0, PLUS, code0,\n \t\t\t\t    &XEXP (x, 1), opnum, type, ind_levels,\n \t\t\t\t    insn);\n \t  }\n \n \telse if (code1 == MULT || code1 == SIGN_EXTEND || code1 == TRUNCATE\n \t\t || code1 == ZERO_EXTEND || code0 == MEM)\n \t  {\n-\t    find_reloads_address_1 (mode, orig_op0, 0, PLUS, code1,\n+\t    find_reloads_address_1 (mode, as, orig_op0, 0, PLUS, code1,\n \t\t\t\t    &XEXP (x, 0), opnum, type, ind_levels,\n \t\t\t\t    insn);\n-\t    find_reloads_address_1 (mode, orig_op1, 1, PLUS, SCRATCH,\n+\t    find_reloads_address_1 (mode, as, orig_op1, 1, PLUS, SCRATCH,\n \t\t\t\t    &XEXP (x, 1), opnum, type, ind_levels,\n \t\t\t\t    insn);\n \t  }\n \n \telse if (code0 == CONST_INT || code0 == CONST\n \t\t || code0 == SYMBOL_REF || code0 == LABEL_REF)\n-\t  find_reloads_address_1 (mode, orig_op1, 0, PLUS, code0,\n+\t  find_reloads_address_1 (mode, as, orig_op1, 0, PLUS, code0,\n \t\t\t\t  &XEXP (x, 1), opnum, type, ind_levels,\n \t\t\t\t  insn);\n \n \telse if (code1 == CONST_INT || code1 == CONST\n \t\t || code1 == SYMBOL_REF || code1 == LABEL_REF)\n-\t  find_reloads_address_1 (mode, orig_op0, 0, PLUS, code1,\n+\t  find_reloads_address_1 (mode, as, orig_op0, 0, PLUS, code1,\n \t\t\t\t  &XEXP (x, 0), opnum, type, ind_levels,\n \t\t\t\t  insn);\n \n \telse if (code0 == REG && code1 == REG)\n \t  {\n \t    if (REGNO_OK_FOR_INDEX_P (REGNO (op1))\n-\t\t&& regno_ok_for_base_p (REGNO (op0), mode, PLUS, REG))\n+\t\t&& regno_ok_for_base_p (REGNO (op0), mode, as, PLUS, REG))\n \t      return 0;\n \t    else if (REGNO_OK_FOR_INDEX_P (REGNO (op0))\n-\t\t     && regno_ok_for_base_p (REGNO (op1), mode, PLUS, REG))\n+\t\t     && regno_ok_for_base_p (REGNO (op1), mode, as, PLUS, REG))\n \t      return 0;\n-\t    else if (regno_ok_for_base_p (REGNO (op0), mode, PLUS, REG))\n-\t      find_reloads_address_1 (mode, orig_op1, 1, PLUS, SCRATCH,\n+\t    else if (regno_ok_for_base_p (REGNO (op0), mode, as, PLUS, REG))\n+\t      find_reloads_address_1 (mode, as, orig_op1, 1, PLUS, SCRATCH,\n \t\t\t\t      &XEXP (x, 1), opnum, type, ind_levels,\n \t\t\t\t      insn);\n \t    else if (REGNO_OK_FOR_INDEX_P (REGNO (op1)))\n-\t      find_reloads_address_1 (mode, orig_op0, 0, PLUS, REG,\n+\t      find_reloads_address_1 (mode, as, orig_op0, 0, PLUS, REG,\n \t\t\t\t      &XEXP (x, 0), opnum, type, ind_levels,\n \t\t\t\t      insn);\n-\t    else if (regno_ok_for_base_p (REGNO (op1), mode, PLUS, REG))\n-\t      find_reloads_address_1 (mode, orig_op0, 1, PLUS, SCRATCH,\n+\t    else if (regno_ok_for_base_p (REGNO (op1), mode, as, PLUS, REG))\n+\t      find_reloads_address_1 (mode, as, orig_op0, 1, PLUS, SCRATCH,\n \t\t\t\t      &XEXP (x, 0), opnum, type, ind_levels,\n \t\t\t\t      insn);\n \t    else if (REGNO_OK_FOR_INDEX_P (REGNO (op0)))\n-\t      find_reloads_address_1 (mode, orig_op1, 0, PLUS, REG,\n+\t      find_reloads_address_1 (mode, as, orig_op1, 0, PLUS, REG,\n \t\t\t\t      &XEXP (x, 1), opnum, type, ind_levels,\n \t\t\t\t      insn);\n \t    else\n \t      {\n-\t\tfind_reloads_address_1 (mode, orig_op0, 0, PLUS, REG,\n+\t\tfind_reloads_address_1 (mode, as, orig_op0, 0, PLUS, REG,\n \t\t\t\t\t&XEXP (x, 0), opnum, type, ind_levels,\n \t\t\t\t\tinsn);\n-\t\tfind_reloads_address_1 (mode, orig_op1, 1, PLUS, SCRATCH,\n+\t\tfind_reloads_address_1 (mode, as, orig_op1, 1, PLUS, SCRATCH,\n \t\t\t\t\t&XEXP (x, 1), opnum, type, ind_levels,\n \t\t\t\t\tinsn);\n \t      }\n \t  }\n \n \telse if (code0 == REG)\n \t  {\n-\t    find_reloads_address_1 (mode, orig_op0, 1, PLUS, SCRATCH,\n+\t    find_reloads_address_1 (mode, as, orig_op0, 1, PLUS, SCRATCH,\n \t\t\t\t    &XEXP (x, 0), opnum, type, ind_levels,\n \t\t\t\t    insn);\n-\t    find_reloads_address_1 (mode, orig_op1, 0, PLUS, REG,\n+\t    find_reloads_address_1 (mode, as, orig_op1, 0, PLUS, REG,\n \t\t\t\t    &XEXP (x, 1), opnum, type, ind_levels,\n \t\t\t\t    insn);\n \t  }\n \n \telse if (code1 == REG)\n \t  {\n-\t    find_reloads_address_1 (mode, orig_op1, 1, PLUS, SCRATCH,\n+\t    find_reloads_address_1 (mode, as, orig_op1, 1, PLUS, SCRATCH,\n \t\t\t\t    &XEXP (x, 1), opnum, type, ind_levels,\n \t\t\t\t    insn);\n-\t    find_reloads_address_1 (mode, orig_op0, 0, PLUS, REG,\n+\t    find_reloads_address_1 (mode, as, orig_op0, 0, PLUS, REG,\n \t\t\t\t    &XEXP (x, 0), opnum, type, ind_levels,\n \t\t\t\t    insn);\n \t  }\n@@ -5683,7 +5685,7 @@ find_reloads_address_1 (enum machine_mode mode, rtx x, int context,\n \tif ((REG_P (XEXP (op1, 1))\n \t     && !REGNO_OK_FOR_INDEX_P (REGNO (XEXP (op1, 1))))\n \t    || GET_CODE (XEXP (op1, 1)) == PLUS)\n-\t  find_reloads_address_1 (mode, XEXP (op1, 1), 1, code, SCRATCH,\n+\t  find_reloads_address_1 (mode, as, XEXP (op1, 1), 1, code, SCRATCH,\n \t\t\t\t  &XEXP (op1, 1), opnum, RELOAD_OTHER,\n \t\t\t\t  ind_levels, insn);\n \n@@ -5725,8 +5727,8 @@ find_reloads_address_1 (enum machine_mode mode, rtx x, int context,\n \t\t   register.  */\n \t\treloadnum = push_reload (tem, tem, &XEXP (x, 0),\n \t\t\t\t\t &XEXP (op1, 0),\n-\t\t\t\t\t base_reg_class (mode, code,\n-\t\t\t\t\t\t\t index_code),\n+\t\t\t\t\t base_reg_class (mode, as,\n+\t\t\t\t\t\t\t code, index_code),\n \t\t\t\t\t GET_MODE (x), GET_MODE (x), 0,\n \t\t\t\t\t 0, opnum, RELOAD_OTHER);\n \n@@ -5739,11 +5741,12 @@ find_reloads_address_1 (enum machine_mode mode, rtx x, int context,\n \t  regno = reg_renumber[regno];\n \n \t/* We require a base register here...  */\n-\tif (!regno_ok_for_base_p (regno, GET_MODE (x), code, index_code))\n+\tif (!regno_ok_for_base_p (regno, GET_MODE (x), as, code, index_code))\n \t  {\n \t    reloadnum = push_reload (XEXP (op1, 0), XEXP (x, 0),\n \t\t\t\t     &XEXP (op1, 0), &XEXP (x, 0),\n-\t\t\t\t     base_reg_class (mode, code, index_code),\n+\t\t\t\t     base_reg_class (mode, as,\n+\t\t\t\t\t\t     code, index_code),\n \t\t\t\t     GET_MODE (x), GET_MODE (x), 0, 0,\n \t\t\t\t     opnum, RELOAD_OTHER);\n \n@@ -5809,7 +5812,7 @@ find_reloads_address_1 (enum machine_mode mode, rtx x, int context,\n \t  if (reg_renumber[regno] >= 0)\n \t    regno = reg_renumber[regno];\n \t  if (regno >= FIRST_PSEUDO_REGISTER\n-\t      || !REG_OK_FOR_CONTEXT (context, regno, mode, code,\n+\t      || !REG_OK_FOR_CONTEXT (context, regno, mode, as, code,\n \t\t\t\t      index_code))\n \t    {\n \t      int reloadnum;\n@@ -5878,7 +5881,7 @@ find_reloads_address_1 (enum machine_mode mode, rtx x, int context,\n \t reloaded.  Targets that are better off reloading just either part\n \t (or perhaps even a different part of an outer expression), should\n \t define LEGITIMIZE_RELOAD_ADDRESS.  */\n-      find_reloads_address_1 (GET_MODE (XEXP (x, 0)), XEXP (x, 0),\n+      find_reloads_address_1 (GET_MODE (XEXP (x, 0)), as, XEXP (x, 0),\n \t\t\t      context, code, SCRATCH, &XEXP (x, 0), opnum,\n \t\t\t      type, ind_levels, insn);\n       push_reload (x, NULL_RTX, loc, (rtx*) 0,\n@@ -5949,7 +5952,7 @@ find_reloads_address_1 (enum machine_mode mode, rtx x, int context,\n \t  regno = reg_renumber[regno];\n \n \tif (regno >= FIRST_PSEUDO_REGISTER\n-\t    || !REG_OK_FOR_CONTEXT (context, regno, mode, outer_code,\n+\t    || !REG_OK_FOR_CONTEXT (context, regno, mode, as, outer_code,\n \t\t\t\t    index_code))\n \t  {\n \t    push_reload (x, NULL_RTX, loc, (rtx*) 0,\n@@ -5982,7 +5985,7 @@ find_reloads_address_1 (enum machine_mode mode, rtx x, int context,\n \t    {\n \t      int regno ATTRIBUTE_UNUSED = subreg_regno (x);\n \n-\t      if (!REG_OK_FOR_CONTEXT (context, regno, mode, outer_code,\n+\t      if (!REG_OK_FOR_CONTEXT (context, regno, mode, as, outer_code,\n \t\t\t\t       index_code))\n \t\t{\n \t\t  push_reload (x, NULL_RTX, loc, (rtx*) 0,\n@@ -6023,8 +6026,9 @@ find_reloads_address_1 (enum machine_mode mode, rtx x, int context,\n \tif (fmt[i] == 'e')\n \t  /* Pass SCRATCH for INDEX_CODE, since CODE can never be a PLUS once\n \t     we get here.  */\n-\t  find_reloads_address_1 (mode, XEXP (x, i), context, code, SCRATCH,\n-\t\t\t\t  &XEXP (x, i), opnum, type, ind_levels, insn);\n+\t  find_reloads_address_1 (mode, as, XEXP (x, i), context,\n+\t\t\t\t  code, SCRATCH, &XEXP (x, i),\n+\t\t\t\t  opnum, type, ind_levels, insn);\n       }\n   }\n \n@@ -6201,7 +6205,9 @@ find_reloads_subreg_address (rtx x, int force_replace, int opnum,\n \t\t\t MEM_ADDR_SPACE (reg_equiv_mem (regno))))\n \t\t{\n \t\t  push_reload (XEXP (tem, 0), NULL_RTX, &XEXP (tem, 0), (rtx*) 0,\n-\t\t\t       base_reg_class (GET_MODE (tem), MEM, SCRATCH),\n+\t\t\t       base_reg_class (GET_MODE (tem),\n+\t\t\t\t\t       MEM_ADDR_SPACE (tem),\n+\t\t\t\t\t       MEM, SCRATCH),\n \t\t\t       GET_MODE (XEXP (tem, 0)), VOIDmode, 0, 0,\n \t\t\t       opnum, type);\n \t\t  reloaded = 1;"}, {"sha": "2f783a2940f540be76fc27d30f36cdcd63c5cf90", "filename": "gcc/reload1.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86fc3d06b086930c41fa9fa1be82a0fa92699a12/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86fc3d06b086930c41fa9fa1be82a0fa92699a12/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=86fc3d06b086930c41fa9fa1be82a0fa92699a12", "patch": "@@ -1422,7 +1422,8 @@ maybe_fix_stack_asms (void)\n \n \t\tcase 'p':\n \t\t  cls = (int) reg_class_subunion[cls]\n-\t\t      [(int) base_reg_class (VOIDmode, ADDRESS, SCRATCH)];\n+\t\t      [(int) base_reg_class (VOIDmode, ADDR_SPACE_GENERIC,\n+\t\t\t\t\t     ADDRESS, SCRATCH)];\n \t\t  break;\n \n \t\tcase 'g':\n@@ -1433,7 +1434,8 @@ maybe_fix_stack_asms (void)\n \t\tdefault:\n \t\t  if (EXTRA_ADDRESS_CONSTRAINT (c, p))\n \t\t    cls = (int) reg_class_subunion[cls]\n-\t\t      [(int) base_reg_class (VOIDmode, ADDRESS, SCRATCH)];\n+\t\t      [(int) base_reg_class (VOIDmode, ADDR_SPACE_GENERIC,\n+\t\t\t\t\t     ADDRESS, SCRATCH)];\n \t\t  else\n \t\t    cls = (int) reg_class_subunion[cls]\n \t\t      [(int) REG_CLASS_FROM_CONSTRAINT (c, p)];"}]}