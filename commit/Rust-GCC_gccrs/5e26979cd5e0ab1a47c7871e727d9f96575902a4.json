{"sha": "5e26979cd5e0ab1a47c7871e727d9f96575902a4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWUyNjk3OWNkNWUwYWIxYTQ3Yzc4NzFlNzI3ZDlmOTY1NzU5MDJhNA==", "commit": {"author": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1997-07-14T20:19:23Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1997-07-14T20:19:23Z"}, "message": "calls.c (emit_library_call): Use right index into argvec array when iterating over arguments which need to...\n\n        * calls.c (emit_library_call): Use right index into argvec array\n        when iterating over arguments which need to be pushed on the stack.\n        (emit_library_call_value): Likewise.\n\nFrom-SVN: r14444", "tree": {"sha": "66e6a31f665ceb5f1070506656e3a7ec8aaf264d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/66e6a31f665ceb5f1070506656e3a7ec8aaf264d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5e26979cd5e0ab1a47c7871e727d9f96575902a4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e26979cd5e0ab1a47c7871e727d9f96575902a4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5e26979cd5e0ab1a47c7871e727d9f96575902a4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e26979cd5e0ab1a47c7871e727d9f96575902a4/comments", "author": null, "committer": null, "parents": [{"sha": "467bea2773469b63b454f795e071650e8642f152", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/467bea2773469b63b454f795e071650e8642f152", "html_url": "https://github.com/Rust-GCC/gccrs/commit/467bea2773469b63b454f795e071650e8642f152"}], "stats": {"total": 44, "additions": 26, "deletions": 18}, "files": [{"sha": "52d5cd7684eabda47cce2e16d5e1b91cd5de738b", "filename": "gcc/calls.c", "status": "modified", "additions": 26, "deletions": 18, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e26979cd5e0ab1a47c7871e727d9f96575902a4/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e26979cd5e0ab1a47c7871e727d9f96575902a4/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=5e26979cd5e0ab1a47c7871e727d9f96575902a4", "patch": "@@ -2552,6 +2552,8 @@ emit_library_call VPROTO((rtx orgfun, int no_queue, enum machine_mode outmode,\n \t  \n   /* Push the args that need to be pushed.  */\n \n+  /* ARGNUM indexes the ARGVEC array in the order in which the arguments\n+     are to be pushed.  */\n   for (count = 0; count < nargs; count++, argnum += inc)\n     {\n       register enum machine_mode mode = argvec[argnum].mode;\n@@ -2569,11 +2571,11 @@ emit_library_call VPROTO((rtx orgfun, int no_queue, enum machine_mode outmode,\n #ifdef ARGS_GROW_DOWNWARD\n \t  /* stack_slot is negative, but we want to index stack_usage_map\n \t     with positive values.  */\n-\t  upper_bound = -argvec[count].offset.constant + 1;\n-\t  lower_bound = upper_bound - argvec[count].size.constant;\n+\t  upper_bound = -argvec[argnum].offset.constant + 1;\n+\t  lower_bound = upper_bound - argvec[argnum].size.constant;\n #else\n-\t  lower_bound = argvec[count].offset.constant;\n-\t  upper_bound = lower_bound + argvec[count].size.constant;\n+\t  lower_bound = argvec[argnum].offset.constant;\n+\t  upper_bound = lower_bound + argvec[argnum].size.constant;\n #endif\n \n \t  for (i = lower_bound; i < upper_bound; i++)\n@@ -2590,18 +2592,18 @@ emit_library_call VPROTO((rtx orgfun, int no_queue, enum machine_mode outmode,\n \t    {\n \t      /* We need to make a save area.  See what mode we can make it.  */\n \t      enum machine_mode save_mode\n-\t\t= mode_for_size (argvec[count].size.constant * BITS_PER_UNIT,\n+\t\t= mode_for_size (argvec[argnum].size.constant * BITS_PER_UNIT,\n \t\t\t\t MODE_INT, 1);\n \t      rtx stack_area\n \t\t= gen_rtx (MEM, save_mode,\n \t\t\t   memory_address (save_mode, plus_constant (argblock,\n-\t\t\t\t\t   argvec[count].offset.constant)));\n-\t      argvec[count].save_area = gen_reg_rtx (save_mode);\n-\t      emit_move_insn (argvec[count].save_area, stack_area);\n+\t\t\t\t\t   argvec[argnum].offset.constant)));\n+\t      argvec[argnum].save_area = gen_reg_rtx (save_mode);\n+\t      emit_move_insn (argvec[argnum].save_area, stack_area);\n \t    }\n #endif\n \t  emit_push_insn (val, mode, NULL_TREE, NULL_RTX, 0, partial, reg, 0,\n-\t\t\t  argblock, GEN_INT (argvec[count].offset.constant));\n+\t\t\t  argblock, GEN_INT (argvec[argnum].offset.constant));\n \n #ifdef ACCUMULATE_OUTGOING_ARGS\n \t  /* Now mark the segment we just used.  */\n@@ -2633,6 +2635,8 @@ emit_library_call VPROTO((rtx orgfun, int no_queue, enum machine_mode outmode,\n \n   /* Now load any reg parms into their regs.  */\n \n+  /* ARGNUM indexes the ARGVEC array in the order in which the arguments\n+     are to be pushed.  */\n   for (count = 0; count < nargs; count++, argnum += inc)\n     {\n       register enum machine_mode mode = argvec[argnum].mode;\n@@ -3117,6 +3121,8 @@ emit_library_call_value VPROTO((rtx orgfun, rtx value, int no_queue,\n \t  \n   /* Push the args that need to be pushed.  */\n \n+  /* ARGNUM indexes the ARGVEC array in the order in which the arguments\n+     are to be pushed.  */\n   for (count = 0; count < nargs; count++, argnum += inc)\n     {\n       register enum machine_mode mode = argvec[argnum].mode;\n@@ -3134,11 +3140,11 @@ emit_library_call_value VPROTO((rtx orgfun, rtx value, int no_queue,\n #ifdef ARGS_GROW_DOWNWARD\n \t  /* stack_slot is negative, but we want to index stack_usage_map\n \t     with positive values.  */\n-\t  upper_bound = -argvec[count].offset.constant + 1;\n-\t  lower_bound = upper_bound - argvec[count].size.constant;\n+\t  upper_bound = -argvec[argnum].offset.constant + 1;\n+\t  lower_bound = upper_bound - argvec[argnum].size.constant;\n #else\n-\t  lower_bound = argvec[count].offset.constant;\n-\t  upper_bound = lower_bound + argvec[count].size.constant;\n+\t  lower_bound = argvec[argnum].offset.constant;\n+\t  upper_bound = lower_bound + argvec[argnum].size.constant;\n #endif\n \n \t  for (i = lower_bound; i < upper_bound; i++)\n@@ -3155,18 +3161,18 @@ emit_library_call_value VPROTO((rtx orgfun, rtx value, int no_queue,\n \t    {\n \t      /* We need to make a save area.  See what mode we can make it.  */\n \t      enum machine_mode save_mode\n-\t\t= mode_for_size (argvec[count].size.constant * BITS_PER_UNIT,\n+\t\t= mode_for_size (argvec[argnum].size.constant * BITS_PER_UNIT,\n \t\t\t\t MODE_INT, 1);\n \t      rtx stack_area\n \t\t= gen_rtx (MEM, save_mode,\n \t\t\t   memory_address (save_mode, plus_constant (argblock,\n-\t\t\t\t\t   argvec[count].offset.constant)));\n-\t      argvec[count].save_area = gen_reg_rtx (save_mode);\n-\t      emit_move_insn (argvec[count].save_area, stack_area);\n+\t\t\t\t\t   argvec[argnum].offset.constant)));\n+\t      argvec[argnum].save_area = gen_reg_rtx (save_mode);\n+\t      emit_move_insn (argvec[argnum].save_area, stack_area);\n \t    }\n #endif\n \t  emit_push_insn (val, mode, NULL_TREE, NULL_RTX, 0, partial, reg, 0,\n-\t\t\t  argblock, GEN_INT (argvec[count].offset.constant));\n+\t\t\t  argblock, GEN_INT (argvec[argnum].offset.constant));\n \n #ifdef ACCUMULATE_OUTGOING_ARGS\n \t  /* Now mark the segment we just used.  */\n@@ -3198,6 +3204,8 @@ emit_library_call_value VPROTO((rtx orgfun, rtx value, int no_queue,\n \n   /* Now load any reg parms into their regs.  */\n \n+  /* ARGNUM indexes the ARGVEC array in the order in which the arguments\n+     are to be pushed.  */\n   for (count = 0; count < nargs; count++, argnum += inc)\n     {\n       register enum machine_mode mode = argvec[argnum].mode;"}]}