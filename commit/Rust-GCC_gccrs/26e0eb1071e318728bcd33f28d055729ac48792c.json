{"sha": "26e0eb1071e318728bcd33f28d055729ac48792c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjZlMGViMTA3MWUzMTg3MjhiY2QzM2YyOGQwNTU3MjlhYzQ4NzkyYw==", "commit": {"author": {"name": "Iain Sandoe", "email": "iain@sandoe.co.uk", "date": "2021-03-11T14:22:37Z"}, "committer": {"name": "Iain Sandoe", "email": "iain@sandoe.co.uk", "date": "2021-03-15T15:50:25Z"}, "message": "coroutines : Handle for await expressions in for stmts [PR98480].\n\nThe handling of await expressions in the init, condition and iteration\nexpressions of for loops had been omitted.  Fixed thus.\n\ngcc/cp/ChangeLog:\n\n\tPR c++/98480\n\t* coroutines.cc (replace_continue): Rewrite continue into\n\t'goto label'.\n\t(await_statement_walker): Handle await expressions in the\n\tinitializer, condition and iteration expressions of for\n\tloops.\n\ngcc/testsuite/ChangeLog:\n\n\tPR c++/98480\n\t* g++.dg/coroutines/pr98480.C: New test.\n\t* g++.dg/coroutines/torture/co-await-24-for-init.C: New test.\n\t* g++.dg/coroutines/torture/co-await-25-for-condition.C: New test.\n\t* g++.dg/coroutines/torture/co-await-26-for-iteration-expr.C: New test.", "tree": {"sha": "e3154d2e79be26b4f6ae9768360e42d99ae51b50", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e3154d2e79be26b4f6ae9768360e42d99ae51b50"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/26e0eb1071e318728bcd33f28d055729ac48792c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/26e0eb1071e318728bcd33f28d055729ac48792c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/26e0eb1071e318728bcd33f28d055729ac48792c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/26e0eb1071e318728bcd33f28d055729ac48792c/comments", "author": {"login": "iains", "id": 4039407, "node_id": "MDQ6VXNlcjQwMzk0MDc=", "avatar_url": "https://avatars.githubusercontent.com/u/4039407?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iains", "html_url": "https://github.com/iains", "followers_url": "https://api.github.com/users/iains/followers", "following_url": "https://api.github.com/users/iains/following{/other_user}", "gists_url": "https://api.github.com/users/iains/gists{/gist_id}", "starred_url": "https://api.github.com/users/iains/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iains/subscriptions", "organizations_url": "https://api.github.com/users/iains/orgs", "repos_url": "https://api.github.com/users/iains/repos", "events_url": "https://api.github.com/users/iains/events{/privacy}", "received_events_url": "https://api.github.com/users/iains/received_events", "type": "User", "site_admin": false}, "committer": {"login": "iains", "id": 4039407, "node_id": "MDQ6VXNlcjQwMzk0MDc=", "avatar_url": "https://avatars.githubusercontent.com/u/4039407?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iains", "html_url": "https://github.com/iains", "followers_url": "https://api.github.com/users/iains/followers", "following_url": "https://api.github.com/users/iains/following{/other_user}", "gists_url": "https://api.github.com/users/iains/gists{/gist_id}", "starred_url": "https://api.github.com/users/iains/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iains/subscriptions", "organizations_url": "https://api.github.com/users/iains/orgs", "repos_url": "https://api.github.com/users/iains/repos", "events_url": "https://api.github.com/users/iains/events{/privacy}", "received_events_url": "https://api.github.com/users/iains/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ed8198461735f9b5b3c2cbe50f9913690ce4b4ca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ed8198461735f9b5b3c2cbe50f9913690ce4b4ca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ed8198461735f9b5b3c2cbe50f9913690ce4b4ca"}], "stats": {"total": 428, "additions": 428, "deletions": 0}, "files": [{"sha": "438538a0b4fc26f84d68ce33f6d9bd6acc2e8058", "filename": "gcc/cp/coroutines.cc", "status": "modified", "additions": 126, "deletions": 0, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26e0eb1071e318728bcd33f28d055729ac48792c/gcc%2Fcp%2Fcoroutines.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26e0eb1071e318728bcd33f28d055729ac48792c/gcc%2Fcp%2Fcoroutines.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcoroutines.cc?ref=26e0eb1071e318728bcd33f28d055729ac48792c", "patch": "@@ -3431,6 +3431,50 @@ coro_build_add_if_not_cond_break (tree cond)\n   finish_if_stmt (if_stmt);\n }\n \n+/* Tree walk callback to replace continue statements with goto label.  */\n+static tree\n+replace_continue (tree *stmt, int *do_subtree, void *d)\n+{\n+  tree expr = *stmt;\n+  if (TREE_CODE (expr) == CLEANUP_POINT_EXPR)\n+    expr = TREE_OPERAND (expr, 0);\n+  if (CONVERT_EXPR_P (expr) && VOID_TYPE_P (expr))\n+    expr = TREE_OPERAND (expr, 0);\n+  STRIP_NOPS (expr);\n+  if (!STATEMENT_CLASS_P (expr))\n+    return NULL_TREE;\n+\n+  switch (TREE_CODE (expr))\n+    {\n+      /* Unless it's a special case, just walk the subtrees as usual.  */\n+      default: return NULL_TREE;\n+\n+      case CONTINUE_STMT:\n+\t{\n+\t  tree *label = (tree *)d;\n+\t  location_t loc = EXPR_LOCATION (expr);\n+\t  /* re-write a continue to goto label.  */\n+\t  *stmt = build_stmt (loc, GOTO_EXPR, *label);\n+\t  *do_subtree = 0;\n+\t  return NULL_TREE;\n+\t}\n+\n+      /* Statements that do not require recursion.  */\n+      case DECL_EXPR:\n+      case BREAK_STMT:\n+      case GOTO_EXPR:\n+      case LABEL_EXPR:\n+      case CASE_LABEL_EXPR:\n+      case ASM_EXPR:\n+      /* These must break recursion.  */\n+      case FOR_STMT:\n+      case WHILE_STMT:\n+      case DO_STMT:\n+\t*do_subtree = 0;\n+\treturn NULL_TREE;\n+    }\n+}\n+\n /* Tree walk callback to analyze, register and pre-process statements that\n    contain await expressions.  */\n \n@@ -3534,6 +3578,88 @@ await_statement_walker (tree *stmt, int *do_subtree, void *d)\n \t    return res;\n \t  }\n \t  break;\n+\tcase FOR_STMT:\n+\t  {\n+\t    /* for loops only need special treatment if the condition or the\n+\t       iteration expression contain a co_await.  */\n+\t    tree for_stmt = *stmt;\n+\t    /* Sanity check.  */\n+\t    if ((res = cp_walk_tree (&FOR_INIT_STMT (for_stmt),\n+\t\tanalyze_expression_awaits, d, &visited)))\n+\t      return res;\n+\t    gcc_checking_assert (!awpts->saw_awaits);\n+\n+\t    if ((res = cp_walk_tree (&FOR_COND (for_stmt),\n+\t\tanalyze_expression_awaits, d, &visited)))\n+\t      return res;\n+\t    bool for_cond_await = awpts->saw_awaits != 0;\n+\t    unsigned save_awaits = awpts->saw_awaits;\n+\n+\t    if ((res = cp_walk_tree (&FOR_EXPR (for_stmt),\n+\t\tanalyze_expression_awaits, d, &visited)))\n+\t      return res;\n+\t    bool for_expr_await = awpts->saw_awaits > save_awaits;\n+\n+\t    /* If the condition has an await, then we will need to rewrite the\n+\t       loop as\n+\t       for (init expression;true;iteration expression) {\n+\t\t  condition = await expression;\n+\t\t  if (condition)\n+\t\t    break;\n+\t\t  ...\n+\t\t}\n+\t    */\n+\t    if (for_cond_await)\n+\t      {\n+\t\ttree insert_list = push_stmt_list ();\n+\t\t/* This will be expanded when the revised body is handled.  */\n+\t\tcoro_build_add_if_not_cond_break (FOR_COND (for_stmt));\n+\t\t/* .. add the original for body.  */\n+\t\tadd_stmt (FOR_BODY (for_stmt));\n+\t\t/* To make the new for body.  */\n+\t\tFOR_BODY (for_stmt) = pop_stmt_list (insert_list);\n+\t\tFOR_COND (for_stmt) = boolean_true_node;\n+\t      }\n+\t    /* If the iteration expression has an await, it's a bit more\n+\t       tricky.\n+\t       for (init expression;condition;) {\n+\t\t ...\n+\t\t iteration_expr_label:\n+\t\t   iteration expression with await;\n+\t       }\n+\t       but, then we will need to re-write any continue statements into\n+\t       'goto iteration_expr_label:'.\n+\t    */\n+\t    if (for_expr_await)\n+\t      {\n+\t\tlocation_t sloc = EXPR_LOCATION (FOR_EXPR (for_stmt));\n+\t\ttree insert_list = push_stmt_list ();\n+\t\t/* The original for body.  */\n+\t\tadd_stmt (FOR_BODY (for_stmt));\n+\t\tchar *buf = xasprintf (\"for.iter.expr.%u\", awpts->cond_number++);\n+\t\ttree it_expr_label\n+\t\t  = create_named_label_with_ctx (sloc, buf, NULL_TREE);\n+\t\tfree (buf);\n+\t\tadd_stmt (build_stmt (sloc, LABEL_EXPR, it_expr_label));\n+\t\tadd_stmt (FOR_EXPR (for_stmt));\n+\t\tFOR_EXPR (for_stmt) = NULL_TREE;\n+\t\tFOR_BODY (for_stmt) = pop_stmt_list (insert_list);\n+\t\t/* rewrite continue statements to goto label.  */\n+\t\thash_set<tree> visited_continue;\n+\t\tif ((res = cp_walk_tree (&FOR_BODY (for_stmt),\n+\t\t     replace_continue, &it_expr_label, &visited_continue)))\n+\t\t  return res;\n+\t      }\n+\n+\t    /* So now walk the body statement (list), if there were no await\n+\t       expressions, then this handles the original body - and either\n+\t       way we will have finished with this statement.  */\n+\t    res = cp_walk_tree (&FOR_BODY (for_stmt),\n+\t\t\t\tawait_statement_walker, d, NULL);\n+\t    *do_subtree = 0; /* Done subtrees.  */\n+\t    return res;\n+\t  }\n+\t  break;\n \tcase WHILE_STMT:\n \t  {\n \t    /* We turn 'while (cond with awaits) stmt' into"}, {"sha": "2d872613dac19b0ee56ff07fe5c6cb91a30823f8", "filename": "gcc/testsuite/g++.dg/coroutines/pr98480.C", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26e0eb1071e318728bcd33f28d055729ac48792c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fpr98480.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26e0eb1071e318728bcd33f28d055729ac48792c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fpr98480.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fpr98480.C?ref=26e0eb1071e318728bcd33f28d055729ac48792c", "patch": "@@ -0,0 +1,20 @@\n+#include <coroutine>\n+\n+struct future {\n+  struct promise_type {\n+    void return_value(int) {}\n+    auto initial_suspend() { return std::suspend_never{}; }\n+    auto final_suspend() noexcept { return std::suspend_never{}; }\n+    void unhandled_exception() {}\n+    future get_return_object() { return {}; }\n+  };\n+  bool await_ready() { return true; }\n+  void await_suspend(std::coroutine_handle<>) {}\n+  int await_resume() { return 0; }\n+};\n+\n+future co_foo() {\n+  for( int i = 0; i < co_await future{}; ++i );\n+  // ICE -------------^\n+  co_return 0;\n+}"}, {"sha": "1bf2f6d912deb5c1ff75a5844f5c27b634c16b46", "filename": "gcc/testsuite/g++.dg/coroutines/torture/co-await-24-for-init.C", "status": "added", "additions": 101, "deletions": 0, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26e0eb1071e318728bcd33f28d055729ac48792c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fco-await-24-for-init.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26e0eb1071e318728bcd33f28d055729ac48792c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fco-await-24-for-init.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fco-await-24-for-init.C?ref=26e0eb1071e318728bcd33f28d055729ac48792c", "patch": "@@ -0,0 +1,101 @@\n+// { dg-do run }\n+\n+// Test co-await in while condition.\n+\n+#include \"../coro.h\"\n+\n+// boiler-plate for tests of codegen\n+#include \"../coro1-ret-int-yield-int.h\"\n+\n+/* An awaiter that suspends always and returns an int as the\n+   await_resume output.  */\n+struct IntAwaiter {\n+  int v;\n+  IntAwaiter (int _v) : v(_v) {}\n+  bool await_ready () { return false; }\n+  void await_suspend (coro::coroutine_handle<>) {}\n+  int await_resume () { return v; }\n+};\n+\n+struct coro1\n+coro_a (bool t)\n+{\n+  int accum = 0;\n+  for (int x = co_await IntAwaiter (3); x < 10; x++)\n+    accum += x;\n+\n+  co_return accum;\n+}\n+\n+struct coro1\n+coro_b (bool t)\n+{\n+  int accum = 0;\n+  int x;\n+  for (x = co_await IntAwaiter (3); x < 10; x++)\n+    accum += x;\n+\n+  co_return accum;\n+}\n+\n+struct coro1\n+coro_c (bool t)\n+{\n+  int accum = 0;\n+  int x = 3;\n+  for (co_await IntAwaiter (3); x < 10; x++)\n+    accum += x;\n+\n+  co_return accum;\n+}\n+\n+void\n+check_a_coro (struct coro1& x)\n+{\n+  if (x.handle.done())\n+    {\n+      PRINT (\"check_a_coro: apparently done when we shouldn't be...\");\n+      abort ();\n+    }\n+\n+  PRINT (\"check_a_coro: resume initial suspend\");\n+  x.handle.resume();\n+\n+  // will be false - so no yield expected.\n+  PRINT (\"check_a_coro: resume for init\");\n+  x.handle.resume();\n+\n+  int y = x.handle.promise().get_value();\n+  if ( y != 42 )\n+    {\n+      PRINTF (\"check_a_coro: apparently wrong value : %d\\n\", y);\n+      abort ();\n+    }\n+\n+  if (!x.handle.done())\n+    {\n+      PRINT (\"check_a_coro: apparently not done...\");\n+      abort ();\n+    }\n+}\n+\n+int main ()\n+{\n+  {\n+    struct coro1 x = coro_a (false);\n+    check_a_coro (x);\n+  }\n+\n+  {\n+    struct coro1 x = coro_b (false);\n+    check_a_coro (x);\n+  }\n+\n+  {\n+    struct coro1 x = coro_c (false);\n+    check_a_coro (x);\n+  }\n+\n+  PRINT (\"main: done\");\n+  return 0;\n+}"}, {"sha": "2208e3415746d6944f988e63d4e4829995a63f87", "filename": "gcc/testsuite/g++.dg/coroutines/torture/co-await-25-for-condition.C", "status": "added", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26e0eb1071e318728bcd33f28d055729ac48792c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fco-await-25-for-condition.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26e0eb1071e318728bcd33f28d055729ac48792c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fco-await-25-for-condition.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fco-await-25-for-condition.C?ref=26e0eb1071e318728bcd33f28d055729ac48792c", "patch": "@@ -0,0 +1,94 @@\n+// { dg-do run }\n+\n+// Test co-await in while condition.\n+\n+#include \"../coro.h\"\n+\n+// boiler-plate for tests of codegen\n+#include \"../coro1-ret-int-yield-int.h\"\n+\n+/* An awaiter that suspends always and returns an int as the\n+   await_resume output.  */\n+struct IntAwaiter {\n+  int v;\n+  IntAwaiter (int _v) : v(_v) {}\n+  bool await_ready () { return false; }\n+  void await_suspend (coro::coroutine_handle<>) {}\n+  int await_resume () { return v; }\n+};\n+\n+struct coro1\n+coro_a (bool t)\n+{\n+  int accum = 0;\n+  for (int x = 3; x < co_await IntAwaiter (10); x++)\n+    accum += x;\n+\n+  co_return accum;\n+}\n+\n+/* An awaiter that suspends always and returns an int as the\n+   await_resume output.  */\n+struct TenAwaiter {\n+  int v;\n+  TenAwaiter (int _v) : v(_v) {}\n+  bool await_ready () { return false; }\n+  void await_suspend (coro::coroutine_handle<>) {}\n+  bool await_resume () { return v < 10; }\n+};\n+\n+struct coro1\n+coro_b (bool t)\n+{\n+  int accum = 0;\n+  for (int x = 3; co_await TenAwaiter (x); x++)\n+    accum += x;\n+\n+  co_return accum;\n+}\n+\n+void\n+check_a_coro (struct coro1& x)\n+{\n+  if (x.handle.done())\n+    {\n+      PRINT (\"check_a_coro: apparently done when we shouldn't be...\");\n+      abort ();\n+    }\n+\n+  PRINT (\"check_a_coro: resume initial suspend\");\n+  x.handle.resume();\n+\n+  // will be false - so no yield expected.\n+  PRINT (\"check_a_coro: resume loops\");\n+  while (!x.handle.done())\n+    x.handle.resume();\n+\n+  int y = x.handle.promise().get_value();\n+  if ( y != 42 )\n+    {\n+      PRINTF (\"check_a_coro: apparently wrong value : %d\\n\", y);\n+      abort ();\n+    }\n+\n+  if (!x.handle.done())\n+    {\n+      PRINT (\"check_a_coro: apparently not done...\");\n+      abort ();\n+    }\n+}\n+\n+int main ()\n+{\n+  {\n+    struct coro1 x = coro_a (false);\n+    check_a_coro (x);\n+  }\n+  {\n+    struct coro1 x = coro_b (false);\n+    check_a_coro (x);\n+  }\n+\n+  PRINT (\"main: returning\");\n+  return 0;\n+}"}, {"sha": "f361fb5ecea240f4eff1f8cd54b300f49d5f0ba8", "filename": "gcc/testsuite/g++.dg/coroutines/torture/co-await-26-for-iteration-expr.C", "status": "added", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26e0eb1071e318728bcd33f28d055729ac48792c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fco-await-26-for-iteration-expr.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26e0eb1071e318728bcd33f28d055729ac48792c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fco-await-26-for-iteration-expr.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fco-await-26-for-iteration-expr.C?ref=26e0eb1071e318728bcd33f28d055729ac48792c", "patch": "@@ -0,0 +1,87 @@\n+// { dg-do run }\n+\n+// Test co-await in while condition.\n+\n+#include \"../coro.h\"\n+\n+// boiler-plate for tests of codegen\n+#include \"../coro1-ret-int-yield-int.h\"\n+\n+/* An awaiter that suspends always and returns an int as the\n+   await_resume output.  */\n+struct IntAwaiter {\n+  int v;\n+  IntAwaiter (int _v) : v(_v) {}\n+  bool await_ready () { return false; }\n+  void await_suspend (coro::coroutine_handle<>) {}\n+  int await_resume () { return v; }\n+};\n+\n+coro1\n+coro_a (bool t)\n+{\n+  int accum = 0;\n+  for (int x = 3; x < 10; x += co_await IntAwaiter (1))\n+    accum += x;\n+\n+  co_return accum;\n+}\n+\n+coro1\n+coro_b (bool t)\n+{\n+  int accum = 0;\n+  for (int x = 3; x < 10; x += co_await IntAwaiter (1))\n+    {\n+       if (x & 1)\n+         continue;\n+       accum += x;\n+    }\n+\n+  co_return accum;\n+}\n+\n+void check_a_coro (coro1& x, int expected_answer)\n+{\n+  if (x.handle.done())\n+    {\n+      PRINT (\"check_a_coro: apparently done when we shouldn't be...\");\n+      abort ();\n+    }\n+\n+  PRINT (\"check_a_coro: resume initial suspend\");\n+  x.handle.resume();\n+\n+  // will be false - so no yield expected.\n+  PRINT (\"check_a_coro: resume for init\");\n+  while (!x.handle.done())\n+    x.handle.resume();\n+\n+  int y = x.handle.promise().get_value();\n+  if ( y != expected_answer )\n+    {\n+      PRINTF (\"check_a_coro: apparently wrong value : %d\\n\", y);\n+      abort ();\n+    }\n+\n+  if (!x.handle.done())\n+    {\n+      PRINT (\"check_a_coro: apparently not done...\");\n+      abort ();\n+    }\n+}\n+\n+int main ()\n+{\n+  {\n+    coro1 x = coro_a (false);\n+    check_a_coro (x, 42);\n+  }\n+  {\n+    coro1 x = coro_b (false);\n+    check_a_coro (x, 18);\n+  }\n+  \n+  PRINT (\"main: done\");\n+  return 0;\n+}"}]}