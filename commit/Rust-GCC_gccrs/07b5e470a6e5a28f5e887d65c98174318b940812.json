{"sha": "07b5e470a6e5a28f5e887d65c98174318b940812", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDdiNWU0NzBhNmU1YTI4ZjVlODg3ZDY1Yzk4MTc0MzE4Yjk0MDgxMg==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@cygnus.com", "date": "2000-10-26T00:01:46Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2000-10-26T00:01:46Z"}, "message": "lex.c (java_new_lexer): Initialize new fields.\n\n\t* lex.c (java_new_lexer): Initialize new fields.  Work around\n\tbroken iconv() implementations.\n\t(java_read_char): Swap bytes if required.  Use fallback decoder if\n\trequired.\n\t(byteswap_init, need_byteswap): New globals.\n\t(java_destroy_lexer): Only close iconv handle if it is in use.\n\t* lex.h (java_lexer): New fields read_anything, byte_swap,\n\tuse_fallback.\n\tMade out_buffer unsigned.\n\nFrom-SVN: r37063", "tree": {"sha": "76ca02ecce99066ffcf0c9dd82a4c07d5eff2edc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/76ca02ecce99066ffcf0c9dd82a4c07d5eff2edc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/07b5e470a6e5a28f5e887d65c98174318b940812", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/07b5e470a6e5a28f5e887d65c98174318b940812", "html_url": "https://github.com/Rust-GCC/gccrs/commit/07b5e470a6e5a28f5e887d65c98174318b940812", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/07b5e470a6e5a28f5e887d65c98174318b940812/comments", "author": null, "committer": null, "parents": [{"sha": "081b49f1443d4bf4f1ab3718db439719c9f33e8d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/081b49f1443d4bf4f1ab3718db439719c9f33e8d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/081b49f1443d4bf4f1ab3718db439719c9f33e8d"}], "stats": {"total": 379, "additions": 244, "deletions": 135}, "files": [{"sha": "53408cf3977e842ef850d870be7cfaf3c965c7db", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07b5e470a6e5a28f5e887d65c98174318b940812/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07b5e470a6e5a28f5e887d65c98174318b940812/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=07b5e470a6e5a28f5e887d65c98174318b940812", "patch": "@@ -1,3 +1,15 @@\n+2000-10-24  Tom Tromey  <tromey@cygnus.com>\n+\n+\t* lex.c (java_new_lexer): Initialize new fields.  Work around\n+\tbroken iconv() implementations.\n+\t(java_read_char): Swap bytes if required.  Use fallback decoder if\n+\trequired.\n+\t(byteswap_init, need_byteswap): New globals.\n+\t(java_destroy_lexer): Only close iconv handle if it is in use.\n+\t* lex.h (java_lexer): New fields read_anything, byte_swap,\n+\tuse_fallback.\n+\tMade out_buffer unsigned.\n+\n 2000-10-24  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n \n \t* parse.y (register_incomplete_type): Include JDEP_FIELD as a case"}, {"sha": "b26499b314bd9355da21b090e65a76ed0c38537a", "filename": "gcc/java/lex.c", "status": "modified", "additions": 221, "deletions": 134, "changes": 355, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07b5e470a6e5a28f5e887d65c98174318b940812/gcc%2Fjava%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07b5e470a6e5a28f5e887d65c98174318b940812/gcc%2Fjava%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Flex.c?ref=07b5e470a6e5a28f5e887d65c98174318b940812", "patch": "@@ -59,6 +59,15 @@ static void java_unget_unicode PARAMS ((void));\n static unicode_t java_sneak_unicode PARAMS ((void));\n java_lexer *java_new_lexer PARAMS ((FILE *, const char *));\n \n+/* This is nonzero if we have initialized `need_byteswap'.  */\n+static int byteswap_init = 0;\n+\n+/* Some versions of iconv() (e.g., glibc 2.1.3) will return UCS-2 in\n+   big-endian order -- not native endian order.  We handle this by\n+   doing a conversion once at startup and seeing what happens.  This\n+   flag holds the results of this determination.  */\n+static int need_byteswap = 0;\n+\n void\n java_init_lex (finput, encoding)\n      FILE *finput;\n@@ -208,19 +217,66 @@ java_new_lexer (finput, encoding)\n \n #ifdef HAVE_ICONV\n   lex->handle = iconv_open (\"UCS-2\", encoding);\n-  if (lex->handle == (iconv_t) -1)\n+  if (lex->handle != (iconv_t) -1)\n     {\n-      /* FIXME: we should give a nice error based on errno here.  */\n-      enc_error = 1;\n+      lex->first = -1;\n+      lex->last = -1;\n+      lex->out_first = -1;\n+      lex->out_last = -1;\n+      lex->read_anything = 0;\n+      lex->use_fallback = 0;\n+\n+      /* Work around broken iconv() implementations by doing checking at\n+\t runtime.  We assume that if the UTF-8 => UCS-2 encoder is broken,\n+\t then all UCS-2 encoders will be broken.  Perhaps not a valid\n+\t assumption.  */\n+      if (! byteswap_init)\n+\t{\n+\t  iconv_t handle;\n+\n+\t  byteswap_init = 1;\n+\n+\t  handle = iconv_open (\"UCS-2\", \"UTF-8\");\n+\t  if (handle != (iconv_t) -1)\n+\t    {\n+\t      unicode_t result;\n+\t      unsigned char in[3];\n+\t      char *inp, *outp;\n+\t      size_t inc, outc, r;\n+\n+\t      /* This is the UTF-8 encoding of \\ufeff.  */\n+\t      in[0] = 0xef;\n+\t      in[1] = 0xbb;\n+\t      in[2] = 0xbf;\n+\n+\t      inp = in;\n+\t      inc = 3;\n+\t      outp = (char *) &result;\n+\t      outc = 2;\n+\n+\t      r = iconv (handle, (const char **) &inp, &inc, &outp, &outc);\n+\t      /* Conversion must be complete for us to use the result.  */\n+\t      if (r != (size_t) -1 && inc == 0 && outc == 0)\n+\t\tneed_byteswap = (result != 0xfeff);\n+\t    }\n+\t}\n+\n+      lex->byte_swap = need_byteswap;\n     }\n-  lex->first = -1;\n-  lex->last = -1;\n-  lex->out_first = -1;\n-  lex->out_last = -1;\n-#else /* HAVE_ICONV */\n-  if (strcmp (encoding, DEFAULT_ENCODING))\n-    enc_error = 1;\n+  else\n #endif /* HAVE_ICONV */\n+    {\n+      /* If iconv failed, use the internal decoder if the default\n+\t encoding was requested.  This code is used on platforms where\n+\t iconv() exists but is insufficient for our needs.  For\n+\t instance, on Solaris 2.5 iconv() cannot handle UTF-8 or UCS-2.  */\n+      if (strcmp (encoding, DEFAULT_ENCODING))\n+\tenc_error = 1;\n+#ifdef HAVE_ICONV\n+      else\n+\tlex->use_fallback = 1;\n+#endif /* HAVE_ICONV */\n+    }\n \n   if (enc_error)\n     fatal (\"unknown encoding: `%s'\", encoding);\n@@ -233,7 +289,8 @@ java_destroy_lexer (lex)\n      java_lexer *lex;\n {\n #ifdef HAVE_ICONV\n-  iconv_close (lex->handle);\n+  if (! lex->use_fallback)\n+    iconv_close (lex->handle);\n #endif\n   free (lex);\n }\n@@ -250,140 +307,170 @@ java_read_char (lex)\n     }\n \n #ifdef HAVE_ICONV\n-  {\n-    size_t ir, inbytesleft, in_save, out_count, out_save;\n-    char *inp, *outp;\n-    unicode_t result;\n+  if (! lex->use_fallback)\n+    {\n+      size_t ir, inbytesleft, in_save, out_count, out_save;\n+      char *inp, *outp;\n+      unicode_t result;\n \n-    /* If there is data which has already been converted, use it.  */\n-    if (lex->out_first == -1 || lex->out_first >= lex->out_last)\n-      {\n-\tlex->out_first = 0;\n-\tlex->out_last = 0;\n+      /* If there is data which has already been converted, use it.  */\n+      if (lex->out_first == -1 || lex->out_first >= lex->out_last)\n+\t{\n+\t  lex->out_first = 0;\n+\t  lex->out_last = 0;\n \n-\twhile (1)\n-\t  {\n-\t    /* See if we need to read more data.  If FIRST == 0 then\n-\t       the previous conversion attempt ended in the middle of\n-\t       a character at the end of the buffer.  Otherwise we\n-\t       only have to read if the buffer is empty.  */\n-\t    if (lex->first == 0 || lex->first >= lex->last)\n-\t      {\n-\t\tint r;\n-\n-\t\tif (lex->first >= lex->last)\n-\t\t  {\n-\t\t    lex->first = 0;\n-\t\t    lex->last = 0;\n-\t\t  }\n-\t\tif (feof (lex->finput))\n+\t  while (1)\n+\t    {\n+\t      /* See if we need to read more data.  If FIRST == 0 then\n+\t\t the previous conversion attempt ended in the middle of\n+\t\t a character at the end of the buffer.  Otherwise we\n+\t\t only have to read if the buffer is empty.  */\n+\t      if (lex->first == 0 || lex->first >= lex->last)\n+\t\t{\n+\t\t  int r;\n+\n+\t\t  if (lex->first >= lex->last)\n+\t\t    {\n+\t\t      lex->first = 0;\n+\t\t      lex->last = 0;\n+\t\t    }\n+\t\t  if (feof (lex->finput))\n+\t\t    return UEOF;\n+\t\t  r = fread (&lex->buffer[lex->last], 1,\n+\t\t\t     sizeof (lex->buffer) - lex->last,\n+\t\t\t     lex->finput);\n+\t\t  lex->last += r;\n+\t\t}\n+\n+\t      inbytesleft = lex->last - lex->first;\n+\t      out_count = sizeof (lex->out_buffer) - lex->out_last;\n+\n+\t      if (inbytesleft == 0)\n+\t\t{\n+\t\t  /* We've tried to read and there is nothing left.  */\n \t\t  return UEOF;\n-\t\tr = fread (&lex->buffer[lex->last], 1,\n-\t\t\t   sizeof (lex->buffer) - lex->last,\n-\t\t\t   lex->finput);\n-\t\tlex->last += r;\n-\t      }\n+\t\t}\n \n-\t    inbytesleft = lex->last - lex->first;\n-\t    out_count = sizeof (lex->out_buffer) - lex->out_last;\n+\t      in_save = inbytesleft;\n+\t      out_save = out_count;\n+\t      inp = &lex->buffer[lex->first];\n+\t      outp = &lex->out_buffer[lex->out_last];\n+\t      ir = iconv (lex->handle, (const char **) &inp, &inbytesleft,\n+\t\t\t  &outp, &out_count);\n \n-\t    if (inbytesleft == 0)\n-\t      {\n-\t\t/* We've tried to read and there is nothing left.  */\n-\t\treturn UEOF;\n-\t      }\n+\t      /* If we haven't read any bytes, then look to see if we\n+\t\t have read a BOM.  */\n+\t      if (! lex->read_anything && out_save - out_count >= 2)\n+\t\t{\n+\t\t  unicode_t uc = * (unicode_t *) &lex->out_buffer[0];\n+\t\t  if (uc == 0xfeff)\n+\t\t    {\n+\t\t      lex->byte_swap = 0;\n+\t\t      lex->out_first += 2;\n+\t\t    }\n+\t\t  else if (uc == 0xfffe)\n+\t\t    {\n+\t\t      lex->byte_swap = 1;\n+\t\t      lex->out_first += 2;\n+\t\t    }\n+\t\t  lex->read_anything = 1;\n+\t\t}\n \n-\t    in_save = inbytesleft;\n-\t    out_save = out_count;\n-\t    inp = &lex->buffer[lex->first];\n-\t    outp = &lex->out_buffer[lex->out_last];\n-\t    ir = iconv (lex->handle, (const char **) &inp, &inbytesleft,\n-\t\t\t&outp, &out_count);\n-\t    lex->first += in_save - inbytesleft;\n-\t    lex->out_last += out_save - out_count;\n-\n-\t    /* If we converted anything at all, move along.  */\n-\t    if (out_count != out_save)\n-\t      break;\n+\t      if (lex->byte_swap)\n+\t\t{\n+\t\t  unsigned int i;\n+\t\t  for (i = 0; i < out_save - out_count; i += 2)\n+\t\t    {\n+\t\t      char t = lex->out_buffer[lex->out_last + i];\n+\t\t      lex->out_buffer[lex->out_last + i]\n+\t\t\t= lex->out_buffer[lex->out_last + i + 1];\n+\t\t      lex->out_buffer[lex->out_last + i + 1] = t;\n+\t\t    }\n+\t\t}\n \n-\t    if (ir == (size_t) -1)\n-\t      {\n-\t\tif (errno == EINVAL)\n-\t\t  {\n-\t\t    /* This is ok.  This means that the end of our buffer\n-\t\t       is in the middle of a character sequence.  We just\n-\t\t       move the valid part of the buffer to the beginning\n-\t\t       to force a read.  */\n-\t\t    /* We use bcopy() because it should work for\n-\t\t       overlapping strings.  Use memmove() instead... */\n-\t\t    bcopy (&lex->buffer[lex->first], &lex->buffer[0],\n-\t\t\t   lex->last - lex->first);\n-\t\t    lex->last -= lex->first;\n-\t\t    lex->first = 0;\n-\t\t  }\n-\t\telse\n-\t\t  {\n-\t\t    /* A more serious error.  */\n-\t\t    java_lex_error (\"unrecognized character in input stream\",\n-\t\t\t\t    0);\n-\t\t    return UEOF;\n-\t\t  }\n-\t      }\n-\t  }\n-      }\n+\t      lex->first += in_save - inbytesleft;\n+\t      lex->out_last += out_save - out_count;\n \n-    if (lex->out_first == -1 || lex->out_first >= lex->out_last)\n-      {\n-\t/* Don't have any data.  */\n-\treturn UEOF;\n-      }\n+\t      /* If we converted anything at all, move along.  */\n+\t      if (out_count != out_save)\n+\t\tbreak;\n \n-    /* Success.  We assume that UCS-2 is big-endian.  This appears to\n-       be an ok assumption.  */\n-    result = ((((unsigned char) lex->out_buffer[lex->out_first]) << 8)\n-\t      | (unsigned char) lex->out_buffer[lex->out_first + 1]);\n-    lex->out_first += 2;\n-    return result;\n-  }\n-#else /* HAVE_ICONV */\n-  {\n-    int c, c1, c2;\n-    c = getc (lex->finput);\n-\n-    if (c < 128)\n-      return (unicode_t)c;\n-    if (c == EOF)\n-      return UEOF;\n-    else\n-      {\n-\tif ((c & 0xe0) == 0xc0)\n-\t  {\n-\t    c1 = getc (lex->finput);\n-\t    if ((c1 & 0xc0) == 0x80)\n-\t      return (unicode_t)(((c &0x1f) << 6) + (c1 & 0x3f));\n-\t    c = c1;\n-\t  }\n-\telse if ((c & 0xf0) == 0xe0)\n-\t  {\n-\t    c1 = getc (lex->finput);\n-\t    if ((c1 & 0xc0) == 0x80)\n-\t      {\n-\t\tc2 = getc (lex->finput);\n-\t\tif ((c2 & 0xc0) == 0x80)\n-\t\t  return (unicode_t)(((c & 0xf) << 12) + \n-\t\t\t\t     (( c1 & 0x3f) << 6) + (c2 & 0x3f));\n-\t\telse\n-\t\t  c = c2;\n-\t      }\n-\t    else\n-\t      c = c1;\n-\t  }\n+\t      if (ir == (size_t) -1)\n+\t\t{\n+\t\t  if (errno == EINVAL)\n+\t\t    {\n+\t\t      /* This is ok.  This means that the end of our buffer\n+\t\t\t is in the middle of a character sequence.  We just\n+\t\t\t move the valid part of the buffer to the beginning\n+\t\t\t to force a read.  */\n+\t\t      /* We use bcopy() because it should work for\n+\t\t\t overlapping strings.  Use memmove() instead... */\n+\t\t      bcopy (&lex->buffer[lex->first], &lex->buffer[0],\n+\t\t\t     lex->last - lex->first);\n+\t\t      lex->last -= lex->first;\n+\t\t      lex->first = 0;\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      /* A more serious error.  */\n+\t\t      java_lex_error (\"unrecognized character in input stream\",\n+\t\t\t\t      0);\n+\t\t      return UEOF;\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n \n-\t/* We simply don't support invalid characters.  */\n-\tjava_lex_error (\"malformed UTF-8 character\", 0);\n-      }\n-  }\n+      if (lex->out_first == -1 || lex->out_first >= lex->out_last)\n+\t{\n+\t  /* Don't have any data.  */\n+\t  return UEOF;\n+\t}\n+\n+      /* Success.  */\n+      result = * ((unicode_t *) &lex->out_buffer[lex->out_first]);\n+      lex->out_first += 2;\n+      return result;\n+    }\n+  else\n #endif /* HAVE_ICONV */\n+    {\n+      int c, c1, c2;\n+      c = getc (lex->finput);\n+\n+      if (c < 128)\n+\treturn (unicode_t)c;\n+      if (c == EOF)\n+\treturn UEOF;\n+      else\n+\t{\n+\t  if ((c & 0xe0) == 0xc0)\n+\t    {\n+\t      c1 = getc (lex->finput);\n+\t      if ((c1 & 0xc0) == 0x80)\n+\t\treturn (unicode_t)(((c &0x1f) << 6) + (c1 & 0x3f));\n+\t      c = c1;\n+\t    }\n+\t  else if ((c & 0xf0) == 0xe0)\n+\t    {\n+\t      c1 = getc (lex->finput);\n+\t      if ((c1 & 0xc0) == 0x80)\n+\t\t{\n+\t\t  c2 = getc (lex->finput);\n+\t\t  if ((c2 & 0xc0) == 0x80)\n+\t\t    return (unicode_t)(((c & 0xf) << 12) + \n+\t\t\t\t       (( c1 & 0x3f) << 6) + (c2 & 0x3f));\n+\t\t  else\n+\t\t    c = c2;\n+\t\t}\n+\t      else\n+\t\tc = c1;\n+\t    }\n+\n+\t  /* We simply don't support invalid characters.  */\n+\t  java_lex_error (\"malformed UTF-8 character\", 0);\n+\t}\n+    }\n \n   /* We only get here on error.  */\n   return UEOF;"}, {"sha": "ae9eebb68e550904c9d3171bb1946d48f2fcc0ea", "filename": "gcc/java/lex.h", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07b5e470a6e5a28f5e887d65c98174318b940812/gcc%2Fjava%2Flex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07b5e470a6e5a28f5e887d65c98174318b940812/gcc%2Fjava%2Flex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Flex.h?ref=07b5e470a6e5a28f5e887d65c98174318b940812", "patch": "@@ -115,6 +115,16 @@ typedef struct java_lexer\n   unicode_t unget_value;\n \n #ifdef HAVE_ICONV\n+  /* Nonzero if we've read any bytes.  We only recognize the\n+     byte-order-marker (BOM) as the first word.  */\n+  int read_anything : 1;\n+\n+  /* Nonzero if we have to byte swap.  */\n+  int byte_swap : 1;\n+\n+  /* Nonzero if we're using the fallback decoder.  */\n+  int use_fallback : 1;\n+\n   /* The handle for the iconv converter we're using.  */\n   iconv_t handle;\n \n@@ -132,7 +142,7 @@ typedef struct java_lexer\n   /* This is a buffer of characters already converted by iconv.  We\n      use `char' here because we're assuming that iconv() converts to\n      big-endian UCS-2, and then we convert it ourselves.  */\n-  char out_buffer[1024];\n+  unsigned char out_buffer[1024];\n \n   /* Index of first valid output character.  -1 if no valid\n      characters.  */"}]}