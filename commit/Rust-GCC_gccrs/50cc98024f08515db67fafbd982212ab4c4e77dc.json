{"sha": "50cc98024f08515db67fafbd982212ab4c4e77dc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTBjYzk4MDI0ZjA4NTE1ZGI2N2ZhZmJkOTgyMjEyYWI0YzRlNzdkYw==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2006-02-03T19:28:09Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2006-02-03T19:28:09Z"}, "message": "tree-ssa-loop-ivopts.c (enum use_type): Remove USE_OUTER.\n\n\t* tree-ssa-loop-ivopts.c (enum use_type): Remove USE_OUTER.\n\t(dump_use, add_derived_ivs_candidates, determine_use_iv_cost,\n\trewrite_use): Do not handle USE_OUTER.\n\t(find_interesting_uses_outer_or_nonlin, find_interesting_uses_outer,\n\tadd_iv_outer_candidates, may_replace_final_value,\n\tdetermine_use_iv_cost_outer, rewrite_use_outer): Removed.\n\t(find_interesting_uses_op): Functionality of\n\tfind_interesting_uses_outer_or_nonlin moved here.\n\t(find_interesting_uses_outside): Use find_interesting_uses_op.\n\nFrom-SVN: r110556", "tree": {"sha": "191a635a6a69dc1f49f8c273d639a619dbbcb61f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/191a635a6a69dc1f49f8c273d639a619dbbcb61f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/50cc98024f08515db67fafbd982212ab4c4e77dc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/50cc98024f08515db67fafbd982212ab4c4e77dc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/50cc98024f08515db67fafbd982212ab4c4e77dc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/50cc98024f08515db67fafbd982212ab4c4e77dc/comments", "author": null, "committer": null, "parents": [{"sha": "23027b7a6a396e248c641809213d8f5aea2b05f9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/23027b7a6a396e248c641809213d8f5aea2b05f9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/23027b7a6a396e248c641809213d8f5aea2b05f9"}], "stats": {"total": 243, "additions": 18, "deletions": 225}, "files": [{"sha": "331a5abbbac1d14e7a929355dbeaf4ad4b78d0ff", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50cc98024f08515db67fafbd982212ab4c4e77dc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50cc98024f08515db67fafbd982212ab4c4e77dc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=50cc98024f08515db67fafbd982212ab4c4e77dc", "patch": "@@ -1,10 +1,22 @@\n+2006-02-03  Zdenek Dvorak <dvorakz@suse.cz>\n+\n+\t* tree-ssa-loop-ivopts.c (enum use_type): Remove USE_OUTER.\n+\t(dump_use, add_derived_ivs_candidates, determine_use_iv_cost,\n+\trewrite_use): Do not handle USE_OUTER.\n+\t(find_interesting_uses_outer_or_nonlin, find_interesting_uses_outer,\n+\tadd_iv_outer_candidates, may_replace_final_value,\n+\tdetermine_use_iv_cost_outer, rewrite_use_outer): Removed.\n+\t(find_interesting_uses_op): Functionality of\n+\tfind_interesting_uses_outer_or_nonlin moved here.\n+\t(find_interesting_uses_outside): Use find_interesting_uses_op.\n+\n 2006-02-03  Alan Modra  <amodra@bigpond.net.au>\n \n \tPR target/25960\n \t* config/rs6000/darwin-ldouble.c (__gcc_qadd): Preserve -0.0 result.\n \n 2006-02-03  Andreas Krebbel  <krebbel1@de.ibm.com>\n-            Ulrich Weigand  <uweigand@de.ibm.com>\n+\t    Ulrich Weigand  <uweigand@de.ibm.com>\n \n \tPR target/25864\n \t* config/s390/2084.md (\"x_fsimptf\", \"x_fmultf\", \"x_fdivtf\","}, {"sha": "2d05e5f7098542a5aa92ec85cc0fd425cb17d2b5", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 5, "deletions": 224, "changes": 229, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50cc98024f08515db67fafbd982212ab4c4e77dc/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50cc98024f08515db67fafbd982212ab4c4e77dc/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=50cc98024f08515db67fafbd982212ab4c4e77dc", "patch": "@@ -131,7 +131,6 @@ struct loop_data\n enum use_type\n {\n   USE_NONLINEAR_EXPR,\t/* Use in a nonlinear expression.  */\n-  USE_OUTER,\t\t/* The induction variable is used outside the loop.  */\n   USE_ADDRESS,\t\t/* Use in an address.  */\n   USE_COMPARE\t\t/* Use is a compare.  */\n };\n@@ -431,10 +430,6 @@ dump_use (FILE *file, struct iv_use *use)\n       fprintf (file, \"  generic\\n\");\n       break;\n \n-    case USE_OUTER:\n-      fprintf (file, \"  outside\\n\");\n-      break;\n-\n     case USE_ADDRESS:\n       fprintf (file, \"  address\\n\");\n       break;\n@@ -1207,12 +1202,10 @@ record_invariant (struct ivopts_data *data, tree op, bool nonlinear_use)\n   bitmap_set_bit (data->relevant, SSA_NAME_VERSION (op));\n }\n \n-/* Checks whether the use OP is interesting and if so, records it\n-   as TYPE.  */\n+/* Checks whether the use OP is interesting and if so, records it.  */\n \n static struct iv_use *\n-find_interesting_uses_outer_or_nonlin (struct ivopts_data *data, tree op,\n-\t\t\t\t       enum use_type type)\n+find_interesting_uses_op (struct ivopts_data *data, tree op)\n {\n   struct iv *iv;\n   struct iv *civ;\n@@ -1230,11 +1223,7 @@ find_interesting_uses_outer_or_nonlin (struct ivopts_data *data, tree op,\n     {\n       use = iv_use (data, iv->use_id);\n \n-      gcc_assert (use->type == USE_NONLINEAR_EXPR\n-\t\t  || use->type == USE_OUTER);\n-\n-      if (type == USE_NONLINEAR_EXPR)\n-\tuse->type = USE_NONLINEAR_EXPR;\n+      gcc_assert (use->type == USE_NONLINEAR_EXPR);\n       return use;\n     }\n \n@@ -1252,29 +1241,12 @@ find_interesting_uses_outer_or_nonlin (struct ivopts_data *data, tree op,\n   gcc_assert (TREE_CODE (stmt) == PHI_NODE\n \t      || TREE_CODE (stmt) == MODIFY_EXPR);\n \n-  use = record_use (data, NULL, civ, stmt, type);\n+  use = record_use (data, NULL, civ, stmt, USE_NONLINEAR_EXPR);\n   iv->use_id = use->id;\n \n   return use;\n }\n \n-/* Checks whether the use OP is interesting and if so, records it.  */\n-\n-static struct iv_use *\n-find_interesting_uses_op (struct ivopts_data *data, tree op)\n-{\n-  return find_interesting_uses_outer_or_nonlin (data, op, USE_NONLINEAR_EXPR);\n-}\n-\n-/* Records a definition of induction variable OP that is used outside of the\n-   loop.  */\n-\n-static struct iv_use *\n-find_interesting_uses_outer (struct ivopts_data *data, tree op)\n-{\n-  return find_interesting_uses_outer_or_nonlin (data, op, USE_OUTER);\n-}\n-\n /* Checks whether the condition *COND_P in STMT is interesting\n    and if so, records it.  */\n \n@@ -1720,7 +1692,7 @@ find_interesting_uses_outside (struct ivopts_data *data, edge exit)\n   for (phi = phi_nodes (exit->dest); phi; phi = PHI_CHAIN (phi))\n     {\n       def = PHI_ARG_DEF_FROM_EDGE (phi, exit);\n-      find_interesting_uses_outer (data, def);\n+      find_interesting_uses_op (data, def);\n     }\n }\n \n@@ -2208,23 +2180,6 @@ add_iv_value_candidates (struct ivopts_data *data,\n     add_candidate (data, base, iv->step, false, use);\n }\n \n-/* Possibly adds pseudocandidate for replacing the final value of USE by\n-   a direct computation.  */\n-\n-static void\n-add_iv_outer_candidates (struct ivopts_data *data, struct iv_use *use)\n-{\n-  struct tree_niter_desc *niter;\n-\n-  /* We must know where we exit the loop and how many times does it roll.  */\n-  niter = niter_for_single_dom_exit (data);\n-  if (!niter\n-      || !zero_p (niter->may_be_zero))\n-    return;\n-\n-  add_candidate_1 (data, NULL, NULL, false, IP_NORMAL, use, NULL_TREE);\n-}\n-\n /* Adds candidates based on the uses.  */\n \n static void\n@@ -2248,14 +2203,6 @@ add_derived_ivs_candidates (struct ivopts_data *data)\n \t  add_iv_value_candidates (data, use->iv, use);\n \t  break;\n \n-\tcase USE_OUTER:\n-\t  add_iv_value_candidates (data, use->iv, use);\n-\n-\t  /* Additionally, add the pseudocandidate for the possibility to\n-\t     replace the final value by a direct computation.  */\n-\t  add_iv_outer_candidates (data, use);\n-\t  break;\n-\n \tdefault:\n \t  gcc_unreachable ();\n \t}\n@@ -4112,95 +4059,6 @@ determine_use_iv_cost_condition (struct ivopts_data *data,\n   return cost != INFTY;\n }\n \n-/* Checks whether it is possible to replace the final value of USE by\n-   a direct computation.  If so, the formula is stored to *VALUE.  */\n-\n-static bool\n-may_replace_final_value (struct ivopts_data *data, struct iv_use *use,\n-\t\t\t tree *value)\n-{\n-  struct loop *loop = data->current_loop;\n-  edge exit;\n-  struct tree_niter_desc *niter;\n-\n-  exit = single_dom_exit (loop);\n-  if (!exit)\n-    return false;\n-\n-  gcc_assert (dominated_by_p (CDI_DOMINATORS, exit->src,\n-\t\t\t      bb_for_stmt (use->stmt)));\n-\n-  niter = niter_for_single_dom_exit (data);\n-  if (!niter\n-      || !zero_p (niter->may_be_zero))\n-    return false;\n-\n-  *value = iv_value (use->iv, niter->niter);\n-\n-  return true;\n-}\n-\n-/* Determines cost of replacing final value of USE using CAND.  */\n-\n-static bool\n-determine_use_iv_cost_outer (struct ivopts_data *data,\n-\t\t\t     struct iv_use *use, struct iv_cand *cand)\n-{\n-  bitmap depends_on;\n-  unsigned cost;\n-  edge exit;\n-  tree value = NULL_TREE;\n-  struct loop *loop = data->current_loop;\n-\n-  /* The simple case first -- if we need to express value of the preserved\n-     original biv, the cost is 0.  This also prevents us from counting the\n-     cost of increment twice -- once at this use and once in the cost of\n-     the candidate.  */\n-  if (cand->pos == IP_ORIGINAL\n-      && cand->incremented_at == use->stmt)\n-    {\n-      set_use_iv_cost (data, use, cand, 0, NULL, NULL_TREE);\n-      return true;\n-    }\n-\n-  if (!cand->iv)\n-    {\n-      if (!may_replace_final_value (data, use, &value))\n-\t{\n-\t  set_use_iv_cost (data, use, cand, INFTY, NULL, NULL_TREE);\n-\t  return false;\n-\t}\n-\n-      depends_on = NULL;\n-      cost = force_var_cost (data, value, &depends_on);\n-\n-      cost /= AVG_LOOP_NITER (loop);\n-\n-      set_use_iv_cost (data, use, cand, cost, depends_on, value);\n-      return cost != INFTY;\n-    }\n-\n-  exit = single_dom_exit (loop);\n-  if (exit)\n-    {\n-      /* If there is just a single exit, we may use value of the candidate\n-\t after we take it to determine the value of use.  */\n-      cost = get_computation_cost_at (data, use, cand, false, &depends_on,\n-\t\t\t\t      last_stmt (exit->src));\n-      if (cost != INFTY)\n-\tcost /= AVG_LOOP_NITER (loop);\n-    }\n-  else\n-    {\n-      /* Otherwise we just need to compute the iv.  */\n-      cost = get_computation_cost (data, use, cand, false, &depends_on);\n-    }\n-\t\t\t\t   \n-  set_use_iv_cost (data, use, cand, cost, depends_on, NULL_TREE);\n-\n-  return cost != INFTY;\n-}\n-\n /* Determines cost of basing replacement of USE on CAND.  Returns false\n    if USE cannot be based on CAND.  */\n \n@@ -4213,9 +4071,6 @@ determine_use_iv_cost (struct ivopts_data *data,\n     case USE_NONLINEAR_EXPR:\n       return determine_use_iv_cost_generic (data, use, cand);\n \n-    case USE_OUTER:\n-      return determine_use_iv_cost_outer (data, use, cand);\n-\n     case USE_ADDRESS:\n       return determine_use_iv_cost_address (data, use, cand);\n \n@@ -5725,76 +5580,6 @@ compute_phi_arg_on_exit (edge exit, tree stmts, tree op)\n     }\n }\n \n-/* Rewrites the final value of USE (that is only needed outside of the loop)\n-   using candidate CAND.  */\n-\n-static void\n-rewrite_use_outer (struct ivopts_data *data,\n-\t\t   struct iv_use *use, struct iv_cand *cand)\n-{\n-  edge exit;\n-  tree value, op, stmts, tgt;\n-  tree phi;\n-\n-  switch (TREE_CODE (use->stmt))\n-    {\n-    case PHI_NODE:\n-      tgt = PHI_RESULT (use->stmt);\n-      break;\n-    case MODIFY_EXPR:\n-      tgt = TREE_OPERAND (use->stmt, 0);\n-      break;\n-    default:\n-      gcc_unreachable ();\n-    }\n-\n-  exit = single_dom_exit (data->current_loop);\n-\n-  if (exit)\n-    {\n-      if (!cand->iv)\n-\t{\n-\t  struct cost_pair *cp = get_use_iv_cost (data, use, cand);\n-\t  value = unshare_expr (cp->value);\n-\t}\n-      else\n-\tvalue = get_computation_at (data->current_loop,\n-\t\t\t\t    use, cand, last_stmt (exit->src));\n-\n-      op = force_gimple_operand (value, &stmts, true, SSA_NAME_VAR (tgt));\n-\t  \n-      /* If we will preserve the iv anyway and we would need to perform\n-\t some computation to replace the final value, do nothing.  */\n-      if (stmts && name_info (data, tgt)->preserve_biv)\n-\treturn;\n-\n-      for (phi = phi_nodes (exit->dest); phi; phi = PHI_CHAIN (phi))\n-\t{\n-\t  use_operand_p use_p = PHI_ARG_DEF_PTR_FROM_EDGE (phi, exit);\n-\n-\t  if (USE_FROM_PTR (use_p) == tgt)\n-\t    SET_USE (use_p, op);\n-\t}\n-\n-      if (stmts)\n-\tcompute_phi_arg_on_exit (exit, stmts, op);\n-\n-      /* Enable removal of the statement.  We cannot remove it directly,\n-\t since we may still need the aliasing information attached to the\n-\t ssa name defined by it.  */\n-      name_info (data, tgt)->iv->have_use_for = false;\n-      return;\n-    }\n-\n-  /* If the variable is going to be preserved anyway, there is nothing to\n-     do.  */\n-  if (name_info (data, tgt)->preserve_biv)\n-    return;\n-\n-  /* Otherwise we just need to compute the iv.  */\n-  rewrite_use_nonlinear_expr (data, use, cand);\n-}\n-\n /* Rewrites USE using candidate CAND.  */\n \n static void\n@@ -5807,10 +5592,6 @@ rewrite_use (struct ivopts_data *data,\n \trewrite_use_nonlinear_expr (data, use, cand);\n \tbreak;\n \n-      case USE_OUTER:\n-\trewrite_use_outer (data, use, cand);\n-\tbreak;\n-\n       case USE_ADDRESS:\n \trewrite_use_address (data, use, cand);\n \tbreak;"}]}