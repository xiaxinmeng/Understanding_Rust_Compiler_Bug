{"sha": "b9bd6f743843a53de1396c43d1e308e51d40c5c4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjliZDZmNzQzODQzYTUzZGUxMzk2YzQzZDFlMzA4ZTUxZDQwYzVjNA==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@redhat.com", "date": "2011-10-17T10:00:07Z"}, "committer": {"name": "Dodji Seketeli", "email": "dodji@gcc.gnu.org", "date": "2011-10-17T10:00:07Z"}, "message": "Reduce memory waste due to non-power-of-2 allocs\n\nThis patch basically arranges for the allocation size of line_map\nbuffers to be as close as possible to a power of two.  This\n*significantly* decreases peak memory consumption as (macro) maps are\nnumerous and stay live during all the compilation.\n\nThe patch adds a new ggc_round_alloc_size interface to the ggc\nallocator.  In each of the two main allocator implementations ('page'\nand 'zone') the function has been extracted from the main allocation\nfunction code and returns the actual size of the allocated memory\nregion, thus giving a chance to the caller to maximize the amount of\nmemory it actually uses from the allocated memory region.  In the\n'none' allocator implementation (that uses xmalloc) the\nggc_round_alloc_size just returns the requested allocation size.\n\nCo-Authored-By: Dodji Seketeli <dodji@redhat.com>\n\nFrom-SVN: r180086", "tree": {"sha": "0b0e309c095d0459230339edc0343cafe8f0c4c8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0b0e309c095d0459230339edc0343cafe8f0c4c8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b9bd6f743843a53de1396c43d1e308e51d40c5c4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b9bd6f743843a53de1396c43d1e308e51d40c5c4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b9bd6f743843a53de1396c43d1e308e51d40c5c4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b9bd6f743843a53de1396c43d1e308e51d40c5c4/comments", "author": null, "committer": null, "parents": [{"sha": "64a1a422dba4b0c09ad38310e32a223f2e16ed9d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/64a1a422dba4b0c09ad38310e32a223f2e16ed9d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/64a1a422dba4b0c09ad38310e32a223f2e16ed9d"}], "stats": {"total": 163, "additions": 138, "deletions": 25}, "files": [{"sha": "557916c82bcfbc6104f68e092f885a14602babd6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9bd6f743843a53de1396c43d1e308e51d40c5c4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9bd6f743843a53de1396c43d1e308e51d40c5c4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b9bd6f743843a53de1396c43d1e308e51d40c5c4", "patch": "@@ -1,3 +1,19 @@\n+2011-10-15  Tom Tromey  <tromey@redhat.com>\n+\t    Dodji Seketeli  <dodji@redhat.com>\n+\n+\t* ggc.h (ggc_round_alloc_size): Declare new public entry point.\n+\t* ggc-none.c (ggc_round_alloc_size): New public stub function.\n+\t* ggc-page.c (ggc_alloced_size_order_for_request): New static\n+\tfunction.  Factorized from ggc_internal_alloc_stat.\n+\t(ggc_round_alloc_size): New public function.  Uses\n+\tggc_alloced_size_order_for_request.\n+\t(ggc_internal_alloc_stat): Use ggc_alloced_size_order_for_request.\n+\t* ggc-zone.c (ggc_round_alloc_size): New public function extracted\n+\tfrom ggc_internal_alloc_zone_stat.\n+\t(ggc_internal_alloc_zone_stat): Use ggc_round_alloc_size.\n+\t* toplev.c (general_init): Initialize\n+\tline_table->alloced_size_for_request.\n+\n 2011-10-15  Tom Tromey  <tromey@redhat.com>\n \t    Dodji Seketeli  <dodji@redhat.com>\n "}, {"sha": "e57d61787dfd5ee99c22777451d66715e3e765fb", "filename": "gcc/ggc-none.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9bd6f743843a53de1396c43d1e308e51d40c5c4/gcc%2Fggc-none.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9bd6f743843a53de1396c43d1e308e51d40c5c4/gcc%2Fggc-none.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-none.c?ref=b9bd6f743843a53de1396c43d1e308e51d40c5c4", "patch": "@@ -39,6 +39,15 @@ ggc_alloc_typed_stat (enum gt_types_enum ARG_UNUSED (gte), size_t size\n   return xmalloc (size);\n }\n \n+/* For a given size of memory requested for allocation, return the\n+   actual size that is going to be allocated.  */\n+\n+size_t\n+ggc_round_alloc_size (size_t requested_size)\n+{\n+  return requested_size;\n+}\n+\n void *\n ggc_internal_alloc_stat (size_t size MEM_STAT_DECL)\n {"}, {"sha": "beee851dd7f133022452c3750be0295f3792be29", "filename": "gcc/ggc-page.c", "status": "modified", "additions": 42, "deletions": 11, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9bd6f743843a53de1396c43d1e308e51d40c5c4/gcc%2Fggc-page.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9bd6f743843a53de1396c43d1e308e51d40c5c4/gcc%2Fggc-page.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-page.c?ref=b9bd6f743843a53de1396c43d1e308e51d40c5c4", "patch": "@@ -1054,6 +1054,47 @@ static unsigned char size_lookup[NUM_SIZE_LOOKUP] =\n   9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9\n };\n \n+/* For a given size of memory requested for allocation, return the\n+   actual size that is going to be allocated, as well as the size\n+   order.  */\n+\n+static void\n+ggc_round_alloc_size_1 (size_t requested_size,\n+\t\t\tsize_t *size_order,\n+\t\t\tsize_t *alloced_size)\n+{\n+  size_t order, object_size;\n+\n+  if (requested_size < NUM_SIZE_LOOKUP)\n+    {\n+      order = size_lookup[requested_size];\n+      object_size = OBJECT_SIZE (order);\n+    }\n+  else\n+    {\n+      order = 10;\n+      while (requested_size > (object_size = OBJECT_SIZE (order)))\n+        order++;\n+    }\n+\n+  if (size_order)\n+    *size_order = order;\n+  if (alloced_size)\n+    *alloced_size = object_size;\n+}\n+\n+/* For a given size of memory requested for allocation, return the\n+   actual size that is going to be allocated.  */\n+\n+size_t\n+ggc_round_alloc_size (size_t requested_size)\n+{\n+  size_t size = 0;\n+  \n+  ggc_round_alloc_size_1 (requested_size, NULL, &size);\n+  return size;\n+}\n+\n /* Typed allocation function.  Does nothing special in this collector.  */\n \n void *\n@@ -1072,17 +1113,7 @@ ggc_internal_alloc_stat (size_t size MEM_STAT_DECL)\n   struct page_entry *entry;\n   void *result;\n \n-  if (size < NUM_SIZE_LOOKUP)\n-    {\n-      order = size_lookup[size];\n-      object_size = OBJECT_SIZE (order);\n-    }\n-  else\n-    {\n-      order = 10;\n-      while (size > (object_size = OBJECT_SIZE (order)))\n-\torder++;\n-    }\n+  ggc_round_alloc_size_1 (size, &order, &object_size);\n \n   /* If there are non-full pages for this size allocation, they are at\n      the head of the list.  */"}, {"sha": "79c8c03296674df0b9937143c4400bd16a1a9b79", "filename": "gcc/ggc-zone.c", "status": "modified", "additions": 19, "deletions": 8, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9bd6f743843a53de1396c43d1e308e51d40c5c4/gcc%2Fggc-zone.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9bd6f743843a53de1396c43d1e308e51d40c5c4/gcc%2Fggc-zone.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-zone.c?ref=b9bd6f743843a53de1396c43d1e308e51d40c5c4", "patch": "@@ -1073,6 +1073,24 @@ free_chunk (char *ptr, size_t size, struct alloc_zone *zone)\n     fprintf (G.debug_file, \"Deallocating object, chunk=%p\\n\", (void *)chunk);\n }\n \n+/* For a given size of memory requested for allocation, return the\n+   actual size that is going to be allocated.  */\n+\n+size_t\n+ggc_round_alloc_size (size_t requested_size)\n+{\n+  size_t size;\n+\n+  /* Make sure that zero-sized allocations get a unique and freeable\n+     pointer.  */\n+  if (requested_size == 0)\n+    size = MAX_ALIGNMENT;\n+  else\n+    size = (requested_size + MAX_ALIGNMENT - 1) & -MAX_ALIGNMENT;\n+\n+  return size;\n+}\n+\n /* Allocate a chunk of memory of at least ORIG_SIZE bytes, in ZONE.  */\n \n void *\n@@ -1084,14 +1102,7 @@ ggc_internal_alloc_zone_stat (size_t orig_size, struct alloc_zone *zone\n   struct small_page_entry *entry;\n   struct alloc_chunk *chunk, **pp;\n   void *result;\n-  size_t size = orig_size;\n-\n-  /* Make sure that zero-sized allocations get a unique and freeable\n-     pointer.  */\n-  if (size == 0)\n-    size = MAX_ALIGNMENT;\n-  else\n-    size = (size + MAX_ALIGNMENT - 1) & -MAX_ALIGNMENT;\n+  size_t size = ggc_alloced_size_for_request (orig_size);\n \n   /* Try to allocate the object from several different sources.  Each\n      of these cases is responsible for setting RESULT and SIZE to"}, {"sha": "704237cc045d448661f2ed811f0a7f49b5dfe9b5", "filename": "gcc/ggc.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9bd6f743843a53de1396c43d1e308e51d40c5c4/gcc%2Fggc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9bd6f743843a53de1396c43d1e308e51d40c5c4/gcc%2Fggc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc.h?ref=b9bd6f743843a53de1396c43d1e308e51d40c5c4", "patch": "@@ -145,6 +145,8 @@ extern void gt_pch_save (FILE *f);\n /* The internal primitive.  */\n extern void *ggc_internal_alloc_stat (size_t MEM_STAT_DECL);\n \n+extern size_t ggc_round_alloc_size (size_t requested_size);\n+\n #define ggc_internal_alloc(s) ggc_internal_alloc_stat (s MEM_STAT_INFO)\n \n /* Allocate an object of the specified type and size.  */"}, {"sha": "86eed5d63a81904e885380b545090081a65db5f7", "filename": "gcc/toplev.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9bd6f743843a53de1396c43d1e308e51d40c5c4/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9bd6f743843a53de1396c43d1e308e51d40c5c4/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=b9bd6f743843a53de1396c43d1e308e51d40c5c4", "patch": "@@ -1216,6 +1216,7 @@ general_init (const char *argv0)\n   line_table = ggc_alloc_line_maps ();\n   linemap_init (line_table);\n   line_table->reallocator = realloc_for_line_map;\n+  line_table->round_alloc_size = ggc_round_alloc_size;\n   init_ttree ();\n \n   /* Initialize register usage now so switches may override.  */"}, {"sha": "375072003affde1cfe46936c4e93b7e375666a78", "filename": "libcpp/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9bd6f743843a53de1396c43d1e308e51d40c5c4/libcpp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9bd6f743843a53de1396c43d1e308e51d40c5c4/libcpp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2FChangeLog?ref=b9bd6f743843a53de1396c43d1e308e51d40c5c4", "patch": "@@ -1,3 +1,11 @@\n+2011-10-15  Tom Tromey  <tromey@redhat.com>\n+\t    Dodji Seketeli  <dodji@redhat.com>\n+\n+\t* include/line-map.h (struct line_maps::alloced_size_for_request):\n+\tNew member.\n+\t* line-map.c (new_linemap): Use set->alloced_size_for_request to\n+\tget the actual allocated size of line maps.\n+\n 2011-10-15  Tom Tromey  <tromey@redhat.com>\n \t    Dodji Seketeli  <dodji@redhat.com>\n "}, {"sha": "1e2a148e17bcf86a074a044cdbad8b0fbc0b490a", "filename": "libcpp/include/line-map.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9bd6f743843a53de1396c43d1e308e51d40c5c4/libcpp%2Finclude%2Fline-map.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9bd6f743843a53de1396c43d1e308e51d40c5c4/libcpp%2Finclude%2Fline-map.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Finclude%2Fline-map.h?ref=b9bd6f743843a53de1396c43d1e308e51d40c5c4", "patch": "@@ -53,6 +53,10 @@ typedef unsigned int source_location;\n /* Memory allocation function typedef.  Works like xrealloc.  */\n typedef void *(*line_map_realloc) (void *, size_t);\n \n+/* Memory allocator function that returns the actual allocated size,\n+   for a given requested allocation.  */\n+typedef size_t (*line_map_round_alloc_size_func) (size_t);\n+\n /* An ordinary line map encodes physical source locations. Those\n    physical source locations are called \"spelling locations\".\n    \n@@ -281,6 +285,10 @@ struct GTY(()) line_maps {\n   /* If non-null, the allocator to use when resizing 'maps'.  If null,\n      xrealloc is used.  */\n   line_map_realloc reallocator;\n+\n+  /* The allocators' function used to know the actual size it\n+     allocated, for a certain allocation size requested.  */\n+  line_map_round_alloc_size_func round_alloc_size;\n };\n \n /* Returns the pointer to the memory region where information about"}, {"sha": "87b8bfe8a0f63e742e3687d5500bf268383f2e70", "filename": "libcpp/line-map.c", "status": "modified", "additions": 33, "deletions": 6, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9bd6f743843a53de1396c43d1e308e51d40c5c4/libcpp%2Fline-map.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9bd6f743843a53de1396c43d1e308e51d40c5c4/libcpp%2Fline-map.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Fline-map.c?ref=b9bd6f743843a53de1396c43d1e308e51d40c5c4", "patch": "@@ -92,16 +92,43 @@ new_linemap (struct line_maps *set,\n   if (LINEMAPS_USED (set, macro_map_p) == LINEMAPS_ALLOCATED (set, macro_map_p))\n     {\n       /* We ran out of allocated line maps. Let's allocate more.  */\n+      unsigned alloc_size;\n \n       line_map_realloc reallocator\n \t= set->reallocator ? set->reallocator : xrealloc;\n+      line_map_round_alloc_size_func round_alloc_size =\n+\tset->round_alloc_size;\n+\n+      /* We are going to execute some dance to try to reduce the\n+\t overhead of the memory allocator, in case we are using the\n+\t ggc-page.c one.\n+\t \n+\t The actual size of memory we are going to get back from the\n+\t allocator is the smallest power of 2 that is greater than the\n+\t size we requested.  So let's consider that size then.  */\n+\n+      alloc_size =\n+\t(2 * LINEMAPS_ALLOCATED (set, macro_map_p) +  256)\n+\t* sizeof (struct line_map);\n+\n+      /* Get the actual size of memory that is going to be allocated\n+\t by the allocator.  */\n+      alloc_size = round_alloc_size (alloc_size);\n+\n+      /* Now alloc_size contains the exact memory size we would get if\n+\t we have asked for the initial alloc_size amount of memory.\n+\t Let's get back to the number of macro map that amounts\n+\t to.  */\n       LINEMAPS_ALLOCATED (set, macro_map_p) =\n-\t2 * LINEMAPS_ALLOCATED (set, macro_map_p) + 256;\n-      LINEMAPS_MAPS (set, macro_map_p)\n-\t= (struct line_map *) (*reallocator) (LINEMAPS_MAPS (set, macro_map_p),\n-\t\t\t\t\t      LINEMAPS_ALLOCATED (set,\n-\t\t\t\t\t\t\t\t  macro_map_p)\n-\t\t\t\t\t      * sizeof (struct line_map));\n+\talloc_size / (sizeof (struct line_map));\n+\n+      /* And now let's really do the re-allocation.  */\n+      LINEMAPS_MAPS (set, macro_map_p) =\n+\t(struct line_map *) (*reallocator)\n+\t(LINEMAPS_MAPS (set, macro_map_p),\n+\t (LINEMAPS_ALLOCATED (set, macro_map_p)\n+\t  * sizeof (struct line_map)));\n+\n       result =\n \t&LINEMAPS_MAPS (set, macro_map_p)[LINEMAPS_USED (set, macro_map_p)];\n       memset (result, 0,"}]}