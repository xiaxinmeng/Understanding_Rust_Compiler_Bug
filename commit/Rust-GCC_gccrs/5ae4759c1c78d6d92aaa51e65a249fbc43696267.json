{"sha": "5ae4759c1c78d6d92aaa51e65a249fbc43696267", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWFlNDc1OWMxYzc4ZDZkOTJhYWE1MWU2NWEyNDlmYmM0MzY5NjI2Nw==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "1997-03-20T19:02:29Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "1997-03-20T19:02:29Z"}, "message": "Patches from wilson; consider fp constants if -mrelocatable to be hard\n\nFrom-SVN: r13754", "tree": {"sha": "2e3be5e4e0ab32907f5cfb992d0b6ef06173c7b6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2e3be5e4e0ab32907f5cfb992d0b6ef06173c7b6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5ae4759c1c78d6d92aaa51e65a249fbc43696267", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5ae4759c1c78d6d92aaa51e65a249fbc43696267", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5ae4759c1c78d6d92aaa51e65a249fbc43696267", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5ae4759c1c78d6d92aaa51e65a249fbc43696267/comments", "author": null, "committer": null, "parents": [{"sha": "09ece7b5287a98e6952e05afe5652575dd755a05", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/09ece7b5287a98e6952e05afe5652575dd755a05", "html_url": "https://github.com/Rust-GCC/gccrs/commit/09ece7b5287a98e6952e05afe5652575dd755a05"}], "stats": {"total": 108, "additions": 67, "deletions": 41}, "files": [{"sha": "bf1f76c9d525ddddc2a532cd0ce323af068be0e4", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 6, "deletions": 16, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ae4759c1c78d6d92aaa51e65a249fbc43696267/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ae4759c1c78d6d92aaa51e65a249fbc43696267/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=5ae4759c1c78d6d92aaa51e65a249fbc43696267", "patch": "@@ -675,6 +675,12 @@ easy_fp_constant (op, mode)\n   if (flag_pic && (DEFAULT_ABI == ABI_V4 || DEFAULT_ABI == ABI_SOLARIS))\n     return 0;\n \n+#ifdef TARGET_RELOCATABLE\n+  /* Similarly if we are using -mrelocatable, consider all constants to be hard */\n+  if (TARGET_RELOCATABLE)\n+    return 0;\n+#endif\n+\n   if (mode == DFmode)\n     {\n       long k[2];\n@@ -744,22 +750,6 @@ offsettable_addr_operand (op, mode)\n \t\t\t\tmode, op);\n }\n \n-/* Return 1 if the operand is either a floating-point register, a pseudo\n-   register, or memory.  */\n-\n-int\n-fp_reg_or_mem_operand (op, mode)\n-     register rtx op;\n-     enum machine_mode mode;\n-{\n-  return (memory_operand (op, mode)\n-\t  || volatile_mem_operand (op, mode)\n-\t  || (register_operand (op, mode)\n-\t      && (GET_CODE (op) != REG\n-\t\t  || REGNO (op) >= FIRST_PSEUDO_REGISTER\n-\t\t  || FP_REGNO_P (REGNO (op)))));\n-}\n-\n /* Return 1 if the operand is either an easy FP constant (see above) or\n    memory.  */\n "}, {"sha": "eac6df393aeae1ceb714bd9999bf4786c53a6ef5", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ae4759c1c78d6d92aaa51e65a249fbc43696267/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ae4759c1c78d6d92aaa51e65a249fbc43696267/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=5ae4759c1c78d6d92aaa51e65a249fbc43696267", "patch": "@@ -3000,7 +3000,6 @@ do {\t\t\t\t\t\t\t\t\t\\\n   {\"lwa_operand\", {SUBREG, MEM, REG}},\t\t\t\t\\\n   {\"volatile_mem_operand\", {MEM}},\t\t\t\t\\\n   {\"offsettable_addr_operand\", {REG, SUBREG, PLUS}},\t\t\\\n-  {\"fp_reg_or_mem_operand\", {SUBREG, MEM, REG}},\t\t\\\n   {\"mem_or_easy_const_operand\", {SUBREG, MEM, CONST_DOUBLE}},\t\\\n   {\"add_operand\", {SUBREG, REG, CONST_INT}},\t\t\t\\\n   {\"non_add_cint_operand\", {CONST_INT}},\t\t\t\\\n@@ -3060,7 +3059,6 @@ extern int num_insns_constant ();\n extern int easy_fp_constant ();\n extern int volatile_mem_operand ();\n extern int offsettable_addr_operand ();\n-extern int fp_reg_or_mem_operand ();\n extern int mem_or_easy_const_operand ();\n extern int add_operand ();\n extern int non_add_cint_operand ();"}, {"sha": "cdd419f656f3d104909572615b3bde5de2f03c5b", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 61, "deletions": 23, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ae4759c1c78d6d92aaa51e65a249fbc43696267/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ae4759c1c78d6d92aaa51e65a249fbc43696267/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=5ae4759c1c78d6d92aaa51e65a249fbc43696267", "patch": "@@ -5455,7 +5455,11 @@\n (define_split\n   [(set (match_operand:SF 0 \"gpc_reg_operand\" \"\")\n \t(match_operand:SF 1 \"const_double_operand\" \"\"))]\n-  \"TARGET_32BIT && reload_completed && num_insns_constant (operands[1], SFmode) <= 1 && REGNO (operands[0]) <= 31\"\n+  \"TARGET_32BIT && reload_completed && num_insns_constant (operands[1], SFmode) <= 1\n+   && ((GET_CODE (operands[0]) == REG && REGNO (operands[0]) <= 31)\n+       || (GET_CODE (operands[0]) == SUBREG\n+\t   && GET_CODE (SUBREG_REG (operands[0])) == REG\n+\t   && REGNO (SUBREG_REG (operands[0])) <= 31))\"\n   [(set (match_dup 2) (match_dup 3))]\n   \"\n {\n@@ -5465,14 +5469,18 @@\n   REAL_VALUE_FROM_CONST_DOUBLE (rv, operands[1]);\n   REAL_VALUE_TO_TARGET_SINGLE (rv, l);\n \n-  operands[2] = gen_rtx (SUBREG, SImode, operands[0], 0);\n+  operands[2] = operand_subword (operands[0], 0, 0, SFmode);\n   operands[3] = GEN_INT(l);\n }\")\n \n (define_split\n   [(set (match_operand:SF 0 \"gpc_reg_operand\" \"\")\n \t(match_operand:SF 1 \"const_double_operand\" \"\"))]\n-  \"TARGET_32BIT && reload_completed && num_insns_constant (operands[1], SFmode) == 2 && REGNO (operands[0]) <= 31\"\n+  \"TARGET_32BIT && reload_completed && num_insns_constant (operands[1], SFmode) == 2\n+   && ((GET_CODE (operands[0]) == REG && REGNO (operands[0]) <= 31)\n+       || (GET_CODE (operands[0]) == SUBREG\n+\t   && GET_CODE (SUBREG_REG (operands[0])) == REG\n+\t   && REGNO (SUBREG_REG (operands[0])) <= 31))\"\n   [(set (match_dup 2) (match_dup 3))\n    (set (match_dup 2) (ior:SI (match_dup 2) (match_dup 4)))]\n   \"\n@@ -5483,13 +5491,13 @@\n   REAL_VALUE_FROM_CONST_DOUBLE (rv, operands[1]);\n   REAL_VALUE_TO_TARGET_SINGLE (rv, l);\n \n-  operands[2] = gen_rtx (SUBREG, SImode, operands[0], 0);\n+  operands[2] = operand_subword (operands[0], 0, 0, SFmode);\n   operands[3] = GEN_INT(l & 0xffff0000);\n   operands[4] = GEN_INT(l & 0x0000ffff);\n }\")\n \n (define_insn \"*movsf_hardfloat\"\n-  [(set (match_operand:SF 0 \"fp_reg_or_mem_operand\" \"=f,f,m,!r,!r\")\n+  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=f,f,m,!r,!r\")\n \t(match_operand:SF 1 \"input_operand\" \"f,m,f,G,Fn\"))]\n   \"(gpc_reg_operand (operands[0], SFmode)\n    || gpc_reg_operand (operands[1], SFmode)) && TARGET_HARD_FLOAT\"\n@@ -5559,28 +5567,38 @@\n (define_split\n   [(set (match_operand:DF 0 \"gpc_reg_operand\" \"\")\n \t(match_operand:DF 1 \"const_int_operand\" \"\"))]\n-  \"TARGET_32BIT && reload_completed && num_insns_constant (operands[1], DFmode) <= 1 && REGNO (operands[0]) <= 31\"\n+  \"TARGET_32BIT && reload_completed && num_insns_constant (operands[1], DFmode) <= 1\n+   && ((GET_CODE (operands[0]) == REG && REGNO (operands[0]) <= 31)\n+       || (GET_CODE (operands[0]) == SUBREG\n+\t   && GET_CODE (SUBREG_REG (operands[0])) == REG\n+\t   && REGNO (SUBREG_REG (operands[0])) <= 31))\"\n   [(set (match_dup 2) (match_dup 4))\n    (set (match_dup 3) (match_dup 1))]\n   \"\n {\n-  operands[2] = gen_rtx (SUBREG, SImode, operands[0], WORDS_BIG_ENDIAN == 0);\n-  operands[3] = gen_rtx (SUBREG, SImode, operands[0], WORDS_BIG_ENDIAN != 0);\n+  int endian = (WORDS_BIG_ENDIAN == 0);\n+  operands[2] = operand_subword (operands[0], endian, 0, DFmode);\n+  operands[3] = operand_subword (operands[0], 1 - endian, 0, DFmode);\n   operands[4] = (INTVAL (operands[1]) & 0x80000000) ? constm1_rtx : const0_rtx;\n }\")\n \n (define_split\n   [(set (match_operand:DF 0 \"gpc_reg_operand\" \"\")\n \t(match_operand:DF 1 \"const_int_operand\" \"\"))]\n-  \"TARGET_32BIT && reload_completed && num_insns_constant (operands[1], DFmode) >= 2 && REGNO (operands[0]) <= 31\"\n+  \"TARGET_32BIT && reload_completed && num_insns_constant (operands[1], DFmode) >= 2\n+   && ((GET_CODE (operands[0]) == REG && REGNO (operands[0]) <= 31)\n+       || (GET_CODE (operands[0]) == SUBREG\n+\t   && GET_CODE (SUBREG_REG (operands[0])) == REG\n+\t   && REGNO (SUBREG_REG (operands[0])) <= 31))\"\n   [(set (match_dup 3) (match_dup 5))\n    (set (match_dup 2) (match_dup 4))\n    (set (match_dup 3) (ior:SI (match_dup 3) (match_dup 6)))]\n   \"\n {\n   HOST_WIDE_INT value = INTVAL (operands[1]);\n-  operands[2] = gen_rtx (SUBREG, SImode, operands[0], WORDS_BIG_ENDIAN == 0);\n-  operands[3] = gen_rtx (SUBREG, SImode, operands[0], WORDS_BIG_ENDIAN != 0);\n+  int endian = (WORDS_BIG_ENDIAN == 0);\n+  operands[2] = operand_subword (operands[0], endian, 0, DFmode);\n+  operands[3] = operand_subword (operands[0], 1 - endian, 0, DFmode);\n   operands[4] = (value & 0x80000000) ? constm1_rtx : const0_rtx;\n   operands[5] = GEN_INT (value & 0xffff0000);\n   operands[6] = GEN_INT (value & 0x0000ffff);\n@@ -5589,13 +5607,18 @@\n (define_split\n   [(set (match_operand:DF 0 \"gpc_reg_operand\" \"\")\n \t(match_operand:DF 1 \"const_double_operand\" \"\"))]\n-  \"TARGET_32BIT && reload_completed && num_insns_constant (operands[1], DFmode) <= 2 && REGNO (operands[0]) <= 31\"\n+  \"TARGET_32BIT && reload_completed && num_insns_constant (operands[1], DFmode) <= 2\n+   && ((GET_CODE (operands[0]) == REG && REGNO (operands[0]) <= 31)\n+       || (GET_CODE (operands[0]) == SUBREG\n+\t   && GET_CODE (SUBREG_REG (operands[0])) == REG\n+\t   && REGNO (SUBREG_REG (operands[0])) <= 31))\"\n   [(set (match_dup 2) (match_dup 4))\n    (set (match_dup 3) (match_dup 5))]\n   \"\n {\n-  operands[2] = gen_rtx (SUBREG, SImode, operands[0], WORDS_BIG_ENDIAN == 0);\n-  operands[3] = gen_rtx (SUBREG, SImode, operands[0], WORDS_BIG_ENDIAN != 0);\n+  int endian = (WORDS_BIG_ENDIAN == 0);\n+  operands[2] = operand_subword (operands[0], endian, 0, DFmode);\n+  operands[3] = operand_subword (operands[0], 1 - endian, 0, DFmode);\n \n #ifdef HOST_WORDS_BIG_ENDIAN\n   operands[4] = GEN_INT (CONST_DOUBLE_LOW  (operands[1]));\n@@ -5609,16 +5632,21 @@\n (define_split\n   [(set (match_operand:DF 0 \"gpc_reg_operand\" \"\")\n \t(match_operand:DF 1 \"const_double_operand\" \"\"))]\n-  \"TARGET_32BIT && reload_completed && num_insns_constant (operands[1], DFmode) == 3 && REGNO (operands[0]) <= 31\"\n+  \"TARGET_32BIT && reload_completed && num_insns_constant (operands[1], DFmode) == 3\n+   && ((GET_CODE (operands[0]) == REG && REGNO (operands[0]) <= 31)\n+       || (GET_CODE (operands[0]) == SUBREG\n+\t   && GET_CODE (SUBREG_REG (operands[0])) == REG\n+\t   && REGNO (SUBREG_REG (operands[0])) <= 31))\"\n   [(set (match_dup 2) (match_dup 4))\n    (set (match_dup 3) (match_dup 5))\n    (set (match_dup 2) (ior:SI (match_dup 2) (match_dup 6)))]\n   \"\n {\n   HOST_WIDE_INT high;\n   HOST_WIDE_INT low;\n-  rtx high_reg = gen_rtx (SUBREG, SImode, operands[0], WORDS_BIG_ENDIAN == 0);\n-  rtx low_reg  = gen_rtx (SUBREG, SImode, operands[0], WORDS_BIG_ENDIAN != 0);\n+  int endian = (WORDS_BIG_ENDIAN == 0);\n+  rtx high_reg = operand_subword (operands[0], endian, 0, DFmode);\n+  rtx low_reg  = operand_subword (operands[0], 1 - endian, 0, DFmode);\n \n #ifdef HOST_WORDS_BIG_ENDIAN\n   high = CONST_DOUBLE_LOW  (operands[1]);\n@@ -5650,7 +5678,11 @@\n (define_split\n   [(set (match_operand:DF 0 \"gpc_reg_operand\" \"\")\n \t(match_operand:DF 1 \"const_double_operand\" \"\"))]\n-  \"TARGET_32BIT && reload_completed && num_insns_constant (operands[1], DFmode) >= 4 && REGNO (operands[0]) <= 31\"\n+  \"TARGET_32BIT && reload_completed && num_insns_constant (operands[1], DFmode) >= 4\n+   && ((GET_CODE (operands[0]) == REG && REGNO (operands[0]) <= 31)\n+       || (GET_CODE (operands[0]) == SUBREG\n+\t   && GET_CODE (SUBREG_REG (operands[0])) == REG\n+\t   && REGNO (SUBREG_REG (operands[0])) <= 31))\"\n   [(set (match_dup 2) (match_dup 4))\n    (set (match_dup 3) (match_dup 5))\n    (set (match_dup 2) (ior:SI (match_dup 2) (match_dup 6)))\n@@ -5659,9 +5691,10 @@\n {\n   HOST_WIDE_INT high = CONST_DOUBLE_HIGH (operands[1]);\n   HOST_WIDE_INT low  = CONST_DOUBLE_LOW  (operands[1]);\n+  int endian = (WORDS_BIG_ENDIAN == 0);\n \n-  operands[2] = gen_rtx (SUBREG, SImode, operands[0], WORDS_BIG_ENDIAN == 0);\n-  operands[3] = gen_rtx (SUBREG, SImode, operands[0], WORDS_BIG_ENDIAN != 0);\n+  operands[2] = operand_subword (operands[0], endian, 0, DFmode);\n+  operands[3] = operand_subword (operands[0], 1 - endian, 0, DFmode);\n   operands[4] = GEN_INT (high & 0xffff0000);\n   operands[5] = GEN_INT (low  & 0xffff0000);\n   operands[6] = GEN_INT (high & 0x0000ffff);\n@@ -5671,9 +5704,14 @@\n (define_split\n   [(set (match_operand:DF 0 \"gpc_reg_operand\" \"\")\n \t(match_operand:DF 1 \"easy_fp_constant\" \"\"))]\n-  \"TARGET_64BIT && reload_completed && REGNO (operands[0]) <= 31\"\n-  [(set (subreg:DI (match_dup 0) 0) (subreg:DI (match_dup 1) 0))]\n-  \"\")\n+  \"TARGET_64BIT && reload_completed\n+   && ((GET_CODE (operands[0]) == REG && REGNO (operands[0]) <= 31)\n+       || (GET_CODE (operands[0]) == SUBREG\n+\t   && GET_CODE (SUBREG_REG (operands[0])) == REG\n+\t   && REGNO (SUBREG_REG (operands[0])) <= 31))\"\n+  [(set (match_dup 2) (subreg:DI (match_dup 1) 0))]\n+  \"\n+{ operands[2] = gen_lowpart (DImode, operands[0]); }\")\n \n ;; Don't have reload use general registers to load a constant.  First,\n ;; it might not work if the output operand has is the equivalent of"}]}