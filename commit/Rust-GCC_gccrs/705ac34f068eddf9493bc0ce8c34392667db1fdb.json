{"sha": "705ac34f068eddf9493bc0ce8c34392667db1fdb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzA1YWMzNGYwNjhlZGRmOTQ5M2JjMGNlOGMzNDM5MjY2N2RiMWZkYg==", "commit": {"author": {"name": "Jeffrey A Law", "email": "law@cygnus.com", "date": "1999-12-02T00:21:59Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1999-12-02T00:21:59Z"}, "message": "mn10300.c (REG_SAVE_BYTES): Allocate space for AM33 registers.\n\n        * mn10300.c (REG_SAVE_BYTES): Allocate space for AM33 registers.\n        (asm_file_start): Emit .am33 into assembly file when compiling for\n        the AM33.\n        (print_operand_address): Handle POST_INC addresses.\n        (can_use_return_insn, initial_offset): Check AM33 registers too.\n        (expand_prologue): Check & save AM33 registers too.\n        (expand_epilogue): Similarly.\n        wise.\n        (REG_CLASS_CONTENTS, REGNO_REG_CLASS): Likewise.\n        (INDEX_REG_CLASS, REG_CLASS_FROM_LETTER): Likewise.\n        (REGNO_OK_FOR_INDEX_P, PREFERRED_RELOAD_CLASS): Likewise.\n        (PREFERRED_OUTPUT_RELOAD_CLASS, LIMIT_RELOAD_CLASS): Likewise.\n        (REGISTER_MOVE_COST, REGISTER_NAMES): Likewise.\n        (HAVE_POST_INCREMENT): Define.\n        (GO_IF_LEGITIMATE_ADDRESS): Allow POST_INC addresses for the AM33.\n        (GO_IF_MODE_DEPENDENT_ADDRESS): POST_INC is a mode dependent address.\n        * mn10300.md (movqi, movhi, addsi, subsi): Add AM33 variants.\n        (mulsi, andsi, iorsi, xorsi, notsi): Likewise.\n        (ashiftsi, lshiftrtsi, ashiftrtsi): Likewise.\n        (zero_extend to SI from QI/HI): Likewise.\n        (sign_extend to SI from QI/HI): Likewise.\n        (mulsidi3, umulsidi3): New patterns for the AM33.\n        (tstsi with zero extension from QI/HI): Add AM33 variants.\n        (movsi, movsf, movdi, movdf): Generate efficient code for the AM33 too.\n        (return_internal_regs, store_movm): Handle new AM33 registers.\n        * t-mn10300 (MULTILIB_OPTIONS, MULTILIB_DIRNAMES): Define.\n        (LIBGCC, INSTALL_LIBGCC): Likewise.\n        * invoke.texi: Document new flags.\n\nFrom-SVN: r30748", "tree": {"sha": "e49cefcce7d7b3499134e5d15d195e9867f43066", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e49cefcce7d7b3499134e5d15d195e9867f43066"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/705ac34f068eddf9493bc0ce8c34392667db1fdb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/705ac34f068eddf9493bc0ce8c34392667db1fdb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/705ac34f068eddf9493bc0ce8c34392667db1fdb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/705ac34f068eddf9493bc0ce8c34392667db1fdb/comments", "author": null, "committer": null, "parents": [{"sha": "d525dfdf293509387773497c46f672495ec2af7c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d525dfdf293509387773497c46f672495ec2af7c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d525dfdf293509387773497c46f672495ec2af7c"}], "stats": {"total": 727, "additions": 701, "deletions": 26}, "files": [{"sha": "18c69171a1cde9bf79bcf9104d56c6fdef7d0f31", "filename": "gcc/ChangeLog", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/705ac34f068eddf9493bc0ce8c34392667db1fdb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/705ac34f068eddf9493bc0ce8c34392667db1fdb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=705ac34f068eddf9493bc0ce8c34392667db1fdb", "patch": "@@ -1,3 +1,42 @@\n+Wed Dec  1 16:51:22 1999  Jeffrey A Law  (law@cygnus.com)\n+\n+\t* mn10300.c (REG_SAVE_BYTES): Allocate space for AM33 registers.\n+\t(asm_file_start): Emit .am33 into assembly file when compiling for\n+\tthe AM33.\n+\t(print_operand_address): Handle POST_INC addresses.\n+\t(can_use_return_insn, initial_offset): Check AM33 registers too.\n+\t(expand_prologue): Check & save AM33 registers too.\n+\t(expand_epilogue): Similarly.\n+\t(secondary_reload_class): Handle AM33 specific secondary reloads.\n+\t(output_tst): Emit efficient code for the AM33 too.\n+\t* mn10300.h (CPP_SPEC, TARGET_AM33): Define.\n+\t(TARGET_SWITCHES): Add -mam33 switch.\n+\t(FIRST_PSEUDO_REGISTER): Handle new AM33 registers.\n+\t(FIXED_REGISTERS, CALL_USED_REGISTERS): Likewise.\n+\t(REG_ALLOC_ORDER, CONDITIONAL_REGISTER_USAGE): Likewise.\n+\t(HARD_REGNO_MODE_OK, MODES_TIEABLE_P): Likewise.\n+\t(enum reg_class, REG_CLASS_NAMES): Likewise.\n+\t(REG_CLASS_CONTENTS, REGNO_REG_CLASS): Likewise.\n+\t(INDEX_REG_CLASS, REG_CLASS_FROM_LETTER): Likewise.\n+\t(REGNO_OK_FOR_INDEX_P, PREFERRED_RELOAD_CLASS): Likewise.\n+\t(PREFERRED_OUTPUT_RELOAD_CLASS, LIMIT_RELOAD_CLASS): Likewise.\n+\t(REGISTER_MOVE_COST, REGISTER_NAMES): Likewise.\n+\t(HAVE_POST_INCREMENT): Define.\n+\t(GO_IF_LEGITIMATE_ADDRESS): Allow POST_INC addresses for the AM33.\n+\t(GO_IF_MODE_DEPENDENT_ADDRESS): POST_INC is a mode dependent address.\n+\t* mn10300.md (movqi, movhi, addsi, subsi): Add AM33 variants.\n+\t(mulsi, andsi, iorsi, xorsi, notsi): Likewise.\n+\t(ashiftsi, lshiftrtsi, ashiftrtsi): Likewise.\n+\t(zero_extend to SI from QI/HI): Likewise.\n+\t(sign_extend to SI from QI/HI): Likewise.\n+\t(mulsidi3, umulsidi3): New patterns for the AM33.\n+\t(tstsi with zero extension from QI/HI): Add AM33 variants.\n+\t(movsi, movsf, movdi, movdf): Generate efficient code for the AM33 too.\n+\t(return_internal_regs, store_movm): Handle new AM33 registers.\n+\t* t-mn10300 (MULTILIB_OPTIONS, MULTILIB_DIRNAMES): Define.\n+\t(LIBGCC, INSTALL_LIBGCC): Likewise.\n+\t* invoke.texi: Document new flags.\n+\n Fri Nov 26 10:59:12 CET 1999  Jan Hubicka  <hubicka@freesoft.cz>\n \n \t* i386.md (addsi3_cc): Add \"binary_operator_ok\" to the condition."}, {"sha": "2c325bf17bed12717bc5941a8c354bf0ca613889", "filename": "gcc/config/mn10300/mn10300.c", "status": "modified", "additions": 52, "deletions": 2, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/705ac34f068eddf9493bc0ce8c34392667db1fdb/gcc%2Fconfig%2Fmn10300%2Fmn10300.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/705ac34f068eddf9493bc0ce8c34392667db1fdb/gcc%2Fconfig%2Fmn10300%2Fmn10300.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300.c?ref=705ac34f068eddf9493bc0ce8c34392667db1fdb", "patch": "@@ -42,8 +42,10 @@ Boston, MA 02111-1307, USA.  */\n    speed standpoint, so we want to optimize this sooner or later.  */\n #define REG_SAVE_BYTES (4 * regs_ever_live[2] \\\n \t\t\t+ 4 * regs_ever_live[3] \\\n-\t\t\t+ 4 * regs_ever_live[6] \\\n-\t\t\t+ 4 * regs_ever_live[7])\n+\t\t        + 4 * regs_ever_live[6] \\\n+\t\t\t+ 4 * regs_ever_live[7] \\\n+\t\t\t+ 16 * (regs_ever_live[14] || regs_ever_live[15] \\\n+\t\t\t\t|| regs_ever_live[16] || regs_ever_live[17]))\n \n void\n asm_file_start (file)\n@@ -54,6 +56,9 @@ asm_file_start (file)\n     fprintf (file, \"# -O%d\\n\", optimize);\n   else\n     fprintf (file, \"\\n\\n\");\n+\n+  if (TARGET_AM33)\n+    fprintf (file, \"\\t.am33\\n\");\n   output_file_directive (file, main_input_filename);\n }\n \f\n@@ -312,6 +317,10 @@ print_operand_address (file, addr)\n {\n   switch (GET_CODE (addr))\n     {\n+    case POST_INC:\n+      print_operand_address (file, XEXP (addr, 0));\n+      fputc ('+', file);\n+      break;\n     case REG:\n       if (addr == stack_pointer_rtx)\n \tprint_operand_address (file, gen_rtx_PLUS (SImode,\n@@ -360,6 +369,10 @@ can_use_return_insn ()\n \t  && !regs_ever_live[3]\n \t  && !regs_ever_live[6]\n \t  && !regs_ever_live[7]\n+\t  && !regs_ever_live[14]\n+\t  && !regs_ever_live[15]\n+\t  && !regs_ever_live[16]\n+\t  && !regs_ever_live[17]\n \t  && !frame_pointer_needed);\n }\n \n@@ -388,6 +401,8 @@ expand_prologue ()\n      single two byte instruction.  */\n   if (regs_ever_live[2] || regs_ever_live[3]\n       || regs_ever_live[6] || regs_ever_live[7]\n+      || regs_ever_live[14] || regs_ever_live[15]\n+      || regs_ever_live[16] || regs_ever_live[17]\n       || frame_pointer_needed)\n     emit_insn (gen_store_movm ());\n \n@@ -432,6 +447,8 @@ expand_epilogue ()\n       size = 0;\n     }\n   else if ((regs_ever_live[2] || regs_ever_live[3]\n+\t    || regs_ever_live[14] || regs_ever_live[15]\n+\t    || regs_ever_live[16] || regs_ever_live[17]\n \t    || regs_ever_live[6] || regs_ever_live[7])\n \t   && size + REG_SAVE_BYTES > 255)\n     {\n@@ -448,6 +465,8 @@ expand_epilogue ()\n      stack requirements and is faster.  */\n   if (regs_ever_live[2] || regs_ever_live[3]\n       || regs_ever_live[6] || regs_ever_live[7]\n+      || regs_ever_live[14] || regs_ever_live[15]\n+      || regs_ever_live[16] || regs_ever_live[17]\n       || frame_pointer_needed)\n     emit_jump_insn (gen_return_internal_regs (GEN_INT (size + REG_SAVE_BYTES)));\n   else\n@@ -554,6 +573,8 @@ secondary_reload_class (class, mode, in)\n       && (mode == QImode || mode == HImode)\n       && (class == ADDRESS_REGS || class == SP_REGS))\n     {\n+      if (TARGET_AM33)\n+\treturn DATA_OR_EXTENDED_REGS;\n       return DATA_REGS;\n     }\n \n@@ -562,6 +583,9 @@ secondary_reload_class (class, mode, in)\n   if (class != SP_REGS\n       && class != ADDRESS_REGS\n       && class != SP_OR_ADDRESS_REGS\n+      && class != SP_OR_EXTENDED_REGS\n+      && class != ADDRESS_OR_EXTENDED_REGS\n+      && class != SP_OR_ADDRESS_OR_EXTENDED_REGS\n       && (in == stack_pointer_rtx\n \t  || (GET_CODE (in) == PLUS\n \t      && (XEXP (in, 0) == stack_pointer_rtx\n@@ -572,6 +596,8 @@ secondary_reload_class (class, mode, in)\n       && (XEXP (in, 0) == stack_pointer_rtx\n \t  || XEXP (in, 1) == stack_pointer_rtx))\n     {\n+      if (TARGET_AM33)\n+\treturn DATA_OR_EXTENDED_REGS;\n       return DATA_REGS;\n     }\n  \n@@ -589,6 +615,8 @@ initial_offset (from, to)\n     {\n       if (regs_ever_live[2] || regs_ever_live[3]\n \t  || regs_ever_live[6] || regs_ever_live[7]\n+\t  || regs_ever_live[14] || regs_ever_live[15]\n+\t  || regs_ever_live[16] || regs_ever_live[17]\n \t  || frame_pointer_needed)\n \treturn REG_SAVE_BYTES;\n       else\n@@ -602,6 +630,8 @@ initial_offset (from, to)\n     {\n       if (regs_ever_live[2] || regs_ever_live[3]\n \t  || regs_ever_live[6] || regs_ever_live[7]\n+\t  || regs_ever_live[14] || regs_ever_live[15]\n+\t  || regs_ever_live[16] || regs_ever_live[17]\n \t  || frame_pointer_needed)\n \treturn (get_frame_size () + REG_SAVE_BYTES\n \t\t+ (current_function_outgoing_args_size\n@@ -855,6 +885,26 @@ output_tst (operand, insn)\n \t  && !reg_set_between_p (SET_DEST (set), temp, insn)\n \t  && (REGNO_REG_CLASS (REGNO (SET_DEST (set)))\n \t      == REGNO_REG_CLASS (REGNO (operand)))\n+\t  && REGNO_REG_CLASS (REGNO (SET_DEST (set))) != EXTENDED_REGS\n+\t  && REGNO (SET_DEST (set)) != REGNO (operand)\n+\t  && (!past_call \n+\t      || !call_used_regs[REGNO (SET_DEST (set))]))\n+\t{\n+\t  rtx xoperands[2];\n+\t  xoperands[0] = operand;\n+\t  xoperands[1] = SET_DEST (set);\n+\n+\t  output_asm_insn (\"cmp %1,%0\", xoperands);\n+\t  return \"\";\n+\t}\n+\n+      if (REGNO_REG_CLASS (REGNO (operand)) == EXTENDED_REGS\n+\t  && REG_P (SET_DEST (set))\n+\t  && SET_SRC (set) == CONST0_RTX (GET_MODE (SET_DEST (set)))\n+\t  && !reg_set_between_p (SET_DEST (set), temp, insn)\n+\t  && (REGNO_REG_CLASS (REGNO (SET_DEST (set)))\n+\t      != REGNO_REG_CLASS (REGNO (operand)))\n+\t  && REGNO_REG_CLASS (REGNO (SET_DEST (set))) == EXTENDED_REGS\n \t  && REGNO (SET_DEST (set)) != REGNO (operand)\n \t  && (!past_call \n \t      || !call_used_regs[REGNO (SET_DEST (set))]))"}, {"sha": "8e77acc42b11b726e582cb8cada185477e8bcab3", "filename": "gcc/config/mn10300/mn10300.h", "status": "modified", "additions": 71, "deletions": 22, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/705ac34f068eddf9493bc0ce8c34392667db1fdb/gcc%2Fconfig%2Fmn10300%2Fmn10300.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/705ac34f068eddf9493bc0ce8c34392667db1fdb/gcc%2Fconfig%2Fmn10300%2Fmn10300.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300.h?ref=705ac34f068eddf9493bc0ce8c34392667db1fdb", "patch": "@@ -32,6 +32,8 @@ Boston, MA 02111-1307, USA.  */\n \n #define CPP_PREDEFINES \"-D__mn10300__ -D__MN10300__\"\n \n+#define CPP_SPEC \"%{mam33:-D__AM33__}\"\n+\n /* Run-time compilation parameters selecting different hardware subsets.  */\n \n extern int target_flags;\n@@ -46,9 +48,16 @@ extern int target_flags;\n \n /* Generate code to work around mul/mulq bugs on the mn10300.  */\n #define TARGET_MULT_BUG\t\t\t(target_flags & 0x1)\n+\n+/* Generate code for the AM33 processor.  */\n+#define TARGET_AM33\t\t\t(target_flags & 0x2)\n+\n #define TARGET_SWITCHES  \\\n   {{ \"mult-bug\",\t0x1,  \"Work around hardware multiply bug\"},\t\\\n    { \"no-mult-bug\", \t-0x1, \"Do not work around hardware multiply bug\"},\\\n+   { \"am33\", \t\t0x2},\t\\\n+   { \"am33\", \t\t-(0x1)},\\\n+   { \"no-am33\", \t-0x2},\t\\\n    { \"\", TARGET_DEFAULT, NULL}}\n \n #ifndef TARGET_DEFAULT\n@@ -134,13 +143,13 @@ extern int target_flags;\n    All registers that the compiler knows about must be given numbers,\n    even those that are not normally considered general registers.  */\n \n-#define FIRST_PSEUDO_REGISTER 10\n+#define FIRST_PSEUDO_REGISTER 18\n \n /* 1 for registers that have pervasive standard uses\n    and are not available for the register allocator.  */\n \n #define FIXED_REGISTERS \\\n-  { 0, 0, 0, 0, 0, 0, 0, 0, 1, 1}\n+  { 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0}\n \n /* 1 for registers not available across function calls.\n    These must include the FIXED_REGISTERS and also any\n@@ -151,10 +160,19 @@ extern int target_flags;\n    like.  */\n \n #define CALL_USED_REGISTERS \\\n-  { 1, 1, 0, 0, 1, 1, 0, 0, 1, 1}\n+  { 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0}\n \n #define REG_ALLOC_ORDER \\\n-  { 0, 1, 4, 5, 2, 3, 6, 7, 8, 9}\n+  { 0, 1, 4, 5, 2, 3, 6, 7, 10, 11, 12, 13, 14, 15, 16, 17, 8, 9}\n+\n+#define CONDITIONAL_REGISTER_USAGE \\\n+{\t\t\t\t\t\t\\\n+  if (!TARGET_AM33)\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      for (i = 10; i < 18; i++) \t\t\\\n+\tfixed_regs[i] = call_used_regs[i] = 1; \t\\\n+    }\t\t\t\t\t\t\\\n+}\n \n /* Return number of consecutive hard regs needed starting at reg REGNO\n    to hold something of mode MODE.\n@@ -169,7 +187,9 @@ extern int target_flags;\n    MODE.  */\n \n #define HARD_REGNO_MODE_OK(REGNO, MODE) \\\n- (REGNO_REG_CLASS (REGNO) == DATA_REGS \t\t\t\\\n+ ((REGNO_REG_CLASS (REGNO) == DATA_REGS \\\n+   || (TARGET_AM33 && REGNO_REG_CLASS (REGNO) == ADDRESS_REGS) \\\n+   || REGNO_REG_CLASS (REGNO) == EXTENDED_REGS) \\\n   ? ((REGNO) & 1) == 0 || GET_MODE_SIZE (MODE) <= 4\t\\\n   : ((REGNO) & 1) == 0 || GET_MODE_SIZE (MODE) == 4)\n \n@@ -178,7 +198,9 @@ extern int target_flags;\n    If HARD_REGNO_MODE_OK could produce different values for MODE1 and MODE2,\n    for any hard reg, then this must be 0 for correct output.  */\n #define MODES_TIEABLE_P(MODE1, MODE2) \\\n-  (MODE1 == MODE2 || (GET_MODE_SIZE (MODE1) <= 4 && GET_MODE_SIZE (MODE2) <= 4))\n+  (TARGET_AM33  \\\n+   || MODE1 == MODE2 \\\n+   || (GET_MODE_SIZE (MODE1) <= 4 && GET_MODE_SIZE (MODE2) <= 4))\n \n /* 4 data, and effectively 3 address registers is small as far as I'm\n    concerned.  */\n@@ -207,6 +229,8 @@ extern int target_flags;\n enum reg_class {\n   NO_REGS, DATA_REGS, ADDRESS_REGS, SP_REGS,\n   DATA_OR_ADDRESS_REGS, SP_OR_ADDRESS_REGS, \n+  EXTENDED_REGS, DATA_OR_EXTENDED_REGS, ADDRESS_OR_EXTENDED_REGS,\n+  SP_OR_EXTENDED_REGS, SP_OR_ADDRESS_OR_EXTENDED_REGS, \n   GENERAL_REGS, ALL_REGS, LIM_REG_CLASSES\n };\n \n@@ -217,6 +241,9 @@ enum reg_class {\n #define REG_CLASS_NAMES \\\n { \"NO_REGS\", \"DATA_REGS\", \"ADDRESS_REGS\", \\\n   \"SP_REGS\", \"DATA_OR_ADDRESS_REGS\", \"SP_OR_ADDRESS_REGS\", \\\n+  \"EXTENDED_REGS\", \\\n+  \"DATA_OR_EXTENDED_REGS\", \"ADDRESS_OR_EXTENDED_REGS\", \\\n+  \"SP_OR_EXTENDED_REGS\", \"SP_OR_ADDRESS_OR_EXTENDED_REGS\", \\\n   \"GENERAL_REGS\", \"ALL_REGS\", \"LIM_REGS\" }\n \n /* Define which registers fit in which classes.\n@@ -225,13 +252,18 @@ enum reg_class {\n \n #define REG_CLASS_CONTENTS  \t\t\t\\\n {      0,\t\t/* No regs      */\t\\\n-   0x00f,\t\t/* DATA_REGS */\t\t\\\n-   0x1f0,\t\t/* ADDRESS_REGS */\t\\\n-   0x200,\t\t/* SP_REGS */\t\t\\\n-   0x1ff,\t\t/* DATA_OR_ADDRESS_REGS */\\\n-   0x1f0,\t\t/* SP_OR_ADDRESS_REGS */\\\n-   0x1ff,\t\t/* GENERAL_REGS */    \t\\\n-   0x3ff,\t\t/* ALL_REGS \t*/\t\\\n+   0x0000f,\t\t/* DATA_REGS */\t\t\\\n+   0x001f0,\t\t/* ADDRESS_REGS */\t\\\n+   0x00200,\t\t/* SP_REGS */\t\t\\\n+   0x001ff,\t\t/* DATA_OR_ADDRESS_REGS */\\\n+   0x003f0,\t\t/* SP_OR_ADDRESS_REGS */\\\n+   0x2fc00,\t\t/* EXTENDED_REGS */\t\\\n+   0x2fc0f,\t\t/* DATA_OR_EXTENDED_REGS */\t\\\n+   0x2fdf0,\t\t/* ADDRESS_OR_EXTENDED_REGS */\t\\\n+   0x2fe00,\t\t/* SP_OR_EXTENDED_REGS */\t\\\n+   0x2fff0,\t\t/* SP_OR_ADDRESS_OR_EXTENDED_REGS */\t\\\n+   0x2fdff,\t\t/* GENERAL_REGS */    \t\\\n+   0x2ffff,\t\t/* ALL_REGS \t*/\t\\\n }\n \n /* The same information, inverted:\n@@ -242,17 +274,19 @@ enum reg_class {\n #define REGNO_REG_CLASS(REGNO) \\\n   ((REGNO) < 4 ? DATA_REGS : \\\n    (REGNO) < 9 ? ADDRESS_REGS : \\\n-    (REGNO) == 9 ? SP_REGS : 0)\n+    (REGNO) == 9 ? SP_REGS : \\\n+     (REGNO) < 18 ? EXTENDED_REGS : 0)\n \n /* The class value for index registers, and the one for base regs.  */\n-#define INDEX_REG_CLASS DATA_REGS\n+#define INDEX_REG_CLASS DATA_OR_EXTENDED_REGS\n #define BASE_REG_CLASS  SP_OR_ADDRESS_REGS\n \n /* Get reg_class from a letter such as appears in the machine description.  */\n \n #define REG_CLASS_FROM_LETTER(C) \\\n   ((C) == 'd' ? DATA_REGS : \\\n    (C) == 'a' ? ADDRESS_REGS : \\\n+   (C) == 'x' ? EXTENDED_REGS : \\\n    (C) == 'y' ? SP_REGS : NO_REGS)\n \n /* Macros to check register numbers against specific register classes.  */\n@@ -273,6 +307,8 @@ enum reg_class {\n \n #define REGNO_OK_FOR_INDEX_P(regno) \\\n   (((regno) >= 0 && regno < 4)\t\\\n+   || ((regno) >= 10 && regno < 18)\t\\\n+   || (reg_renumber[regno] >= 10 && reg_renumber[regno] < 18) \\\n    || (reg_renumber[regno] >= 0 && reg_renumber[regno] < 4))\n \n \n@@ -282,13 +318,15 @@ enum reg_class {\n    in some cases it is preferable to use a more restrictive class.  */\n \n #define PREFERRED_RELOAD_CLASS(X,CLASS) \\\n-  (X == stack_pointer_rtx && CLASS != SP_REGS ? ADDRESS_REGS : CLASS)\n+  (X == stack_pointer_rtx && CLASS != SP_REGS \\\n+   ? ADDRESS_OR_EXTENDED_REGS : CLASS)\n \n #define PREFERRED_OUTPUT_RELOAD_CLASS(X,CLASS) \\\n-  (X == stack_pointer_rtx && CLASS != SP_REGS ? ADDRESS_REGS : CLASS)\n+  (X == stack_pointer_rtx && CLASS != SP_REGS \\\n+   ? ADDRESS_OR_EXTENDED_REGS : CLASS)\n \n #define LIMIT_RELOAD_CLASS(MODE, CLASS) \\\n-  ((MODE == QImode || MODE == HImode) ? DATA_REGS : CLASS)\n+  (!TARGET_AM33 && (MODE == QImode || MODE == HImode) ? DATA_REGS : CLASS)\n \n #define SECONDARY_RELOAD_CLASS(CLASS,MODE,IN) \\\n   secondary_reload_class(CLASS,MODE,IN)\n@@ -645,6 +683,8 @@ extern struct rtx_def *mn10300_va_arg();\n #endif\n \n \f\n+#define HAVE_POST_INCREMENT (TARGET_AM33)\n+\n /* GO_IF_LEGITIMATE_ADDRESS recognizes an RTL expression\n    that is a valid memory address for an instruction.\n    The MODE argument is the machine mode for the MEM expression\n@@ -678,6 +718,11 @@ extern struct rtx_def *mn10300_va_arg();\n     goto ADDR;\t\t\t\t\t\t\\\n   if (RTX_OK_FOR_BASE_P (X))\t\t\t\t\\\n     goto ADDR;\t\t\t\t\t\t\\\n+  if (TARGET_AM33\t\t\t\t\t\\\n+      && GET_CODE (X) == POST_INC\t\t\t\\\n+      && RTX_OK_FOR_BASE_P (XEXP (X, 0))\t\t\\\n+      && (MODE == SImode || MODE == SFmode || MODE == HImode))\\\n+    goto ADDR;\t\t\t\t\t\t\\\n   if (GET_CODE (X) == PLUS)\t\t\t\t\\\n     {\t\t\t\t\t\t\t\\\n       rtx base = 0, index = 0;\t\t\t\t\\\n@@ -719,7 +764,9 @@ extern struct rtx_def *legitimize_address ();\n /* Go to LABEL if ADDR (a legitimate address expression)\n    has an effect that depends on the machine mode it is used for.  */\n \n-#define GO_IF_MODE_DEPENDENT_ADDRESS(ADDR,LABEL)  {}\n+#define GO_IF_MODE_DEPENDENT_ADDRESS(ADDR,LABEL)        \\\n+  if (GET_CODE (ADDR) == POST_INC) \\\n+    goto LABEL\n \n /* Nonzero if the constant value X is a legitimate general operand.\n    It is given that X satisfies CONSTANT_P or is a CONST_DOUBLE.  */\n@@ -772,8 +819,9 @@ extern struct rtx_def *legitimize_address ();\n   case CONST_DOUBLE:\t\t\t\t\t\t\t\\\n     return 8;\n \n-\n-#define REGISTER_MOVE_COST(CLASS1, CLASS2)  (CLASS1 != CLASS2 ? 4 : 2)\n+#define REGISTER_MOVE_COST(CLASS1, CLASS2) \\\n+  ((CLASS1 == CLASS2 && (CLASS1 == ADDRESS_REGS || CLASS1 == DATA_REGS)) ? 2 :\\\n+   CLASS1 == CLASS2 && CLASS1 == EXTENDED_REGS ? 6 : 4)\n \n /* A crude cut at RTX_COSTS for the MN10300.  */\n \n@@ -923,7 +971,8 @@ do { char dstr[30];\t\t\t\t\t\\\n    This sequence is indexed by compiler's hard-register-number (see above).  */\n \n #define REGISTER_NAMES \\\n-{ \"d0\", \"d1\", \"d2\", \"d3\", \"a0\", \"a1\", \"a2\", \"a3\", \"ap\", \"sp\" }\n+{ \"d0\", \"d1\", \"d2\", \"d3\", \"a0\", \"a1\", \"a2\", \"a3\", \"ap\", \"sp\", \\\n+  \"r0\", \"r1\", \"r2\", \"r3\", \"r4\", \"r5\", \"r6\", \"r7\" }\n \n /* Print an instruction operand X on file FILE.\n    look in mn10300.c for details */"}, {"sha": "27fdb6810dda9f39fa7eb1afac6a4b04a2d24e39", "filename": "gcc/config/mn10300/mn10300.md", "status": "modified", "additions": 523, "deletions": 2, "changes": 525, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/705ac34f068eddf9493bc0ce8c34392667db1fdb/gcc%2Fconfig%2Fmn10300%2Fmn10300.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/705ac34f068eddf9493bc0ce8c34392667db1fdb/gcc%2Fconfig%2Fmn10300%2Fmn10300.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300.md?ref=705ac34f068eddf9493bc0ce8c34392667db1fdb", "patch": "@@ -55,6 +55,52 @@\n     operands[1] = copy_to_mode_reg (QImode, operand1);\n }\")\n \n+(define_insn \"\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=dx,a,dx,a,dx,a,dx,a,dxa,m\")\n+\t(match_operand:QI 1 \"general_operand\" \"0,0,I,I,a,dx,dxi,ia,m,dxa\"))]\n+  \"TARGET_AM33\n+   && (register_operand (operands[0], QImode)\n+       || register_operand (operands[1], QImode))\"\n+  \"*\n+{\n+  switch (which_alternative)\n+    {\n+    case 0:\n+    case 1:\n+      return \\\"nop\\\";\n+    case 2:\n+      return \\\"clr %0\\\";\n+    case 3:\n+    case 4:\n+    case 5:\n+    case 6:\n+    case 7:\n+      if (GET_CODE (operands[1]) == CONST_DOUBLE)\n+\t{\n+\t  rtx xoperands[2];\n+\t  xoperands[0] = operands[0];\n+\t  xoperands[1] = GEN_INT (CONST_DOUBLE_LOW (operands[1]));\n+\t  output_asm_insn (\\\"mov %1,%0\\\", xoperands);\n+\t  return \\\"\\\";\n+\t}\n+\n+      if (REGNO_REG_CLASS (true_regnum (operands[0])) == EXTENDED_REGS\n+\t  && GET_CODE (operands[1]) == CONST_INT)\n+\t{\n+\t  HOST_WIDE_INT val = INTVAL (operands[1]);\n+\n+\t  if (((val & 0x80) && ! (val & 0xffffff00))\n+\t      || ((val & 0x800000) && ! (val & 0xff000000)))\n+\t    return \\\"movu %1,%0\\\";\n+\t}\n+      return \\\"mov %1,%0\\\";\n+    case 8:\n+    case 9:\n+      return \\\"movbu %1,%0\\\";\n+    }\n+}\"\n+  [(set_attr \"cc\" \"none,none,clobber,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit\")])\n+\n (define_insn \"\"\n   [(set (match_operand:QI 0 \"general_operand\" \"=dx,*a,dx,*a,dx,*a,dx,*a,dx,m\")\n \t(match_operand:QI 1 \"general_operand\" \"0,0,I,I,a,dx,dxi,ia,m,dx\"))]\n@@ -105,6 +151,52 @@\n     operands[1] = copy_to_mode_reg (HImode, operand1);\n }\")\n \n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=dx,a,dx,a,dx,a,dx,a,dxa,m\")\n+\t(match_operand:HI 1 \"general_operand\" \"0,0,I,I,a,dx,dxi,ia,m,dxa\"))]\n+  \"TARGET_AM33\n+   && (register_operand (operands[0], HImode)\n+       || register_operand (operands[1], HImode))\"\n+  \"*\n+{\n+  switch (which_alternative)\n+    {\n+    case 0:\n+    case 1:\n+      return \\\"nop\\\";\n+    case 2:\n+      return \\\"clr %0\\\";\n+    case 3:\n+    case 4:\n+    case 5:\n+    case 6:\n+    case 7:\n+      if (GET_CODE (operands[1]) == CONST_DOUBLE)\n+\t{\n+\t  rtx xoperands[2];\n+\t  xoperands[0] = operands[0];\n+\t  xoperands[1] = GEN_INT (CONST_DOUBLE_LOW (operands[1]));\n+\t  output_asm_insn (\\\"mov %1,%0\\\", xoperands);\n+\t  return \\\"\\\";\n+\t}\n+\n+      if (REGNO_REG_CLASS (true_regnum (operands[0])) == EXTENDED_REGS\n+\t  && GET_CODE (operands[1]) == CONST_INT)\n+\t{\n+\t  HOST_WIDE_INT val = INTVAL (operands[1]);\n+\n+\t  if (((val & 0x80) && ! (val & 0xffffff00))\n+\t      || ((val & 0x800000) && ! (val & 0xff000000)))\n+\t    return \\\"movu %1,%0\\\";\n+\t}\n+      return \\\"mov %1,%0\\\";\n+    case 8:\n+    case 9:\n+      return \\\"movhu %1,%0\\\";\n+    }\n+}\"\n+  [(set_attr \"cc\" \"none,none,clobber,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit,none_0hit\")])\n+\n (define_insn \"\"\n   [(set (match_operand:HI 0 \"general_operand\" \"=dx,*a,dx,*a,dx,*a,dx,*a,dx,m\")\n \t(match_operand:HI 1 \"general_operand\" \"0,0,I,I,a,dx,dxi,ia,m,dx\"))]\n@@ -229,6 +321,16 @@\n \t  output_asm_insn (\\\"mov %1,%0\\\", xoperands);\n \t  return \\\"\\\";\n \t}\n+\n+      if (REGNO_REG_CLASS (true_regnum (operands[0])) == EXTENDED_REGS\n+\t  && GET_CODE (operands[1]) == CONST_INT)\n+\t{\n+\t  HOST_WIDE_INT val = INTVAL (operands[1]);\n+\n+\t  if (((val & 0x80) && ! (val & 0xffffff00))\n+\t      || ((val & 0x800000) && ! (val & 0xff000000)))\n+\t    return \\\"movu %1,%0\\\";\n+\t}\n       return \\\"mov %1,%0\\\";\n     }\n }\"\n@@ -263,6 +365,15 @@\n     case 3:\n     case 4:\n     case 5:\n+      if (REGNO_REG_CLASS (true_regnum (operands[0])) == EXTENDED_REGS\n+\t  && GET_CODE (operands[1]) == CONST_INT)\n+\t{\n+\t  HOST_WIDE_INT val = INTVAL (operands[1]);\n+\n+\t  if (((val & 0x80) && ! (val & 0xffffff00))\n+\t      || ((val & 0x800000) && ! (val & 0xff000000)))\n+\t    return \\\"movu %1,%0\\\";\n+\t}\n       return \\\"mov %1,%0\\\";\n     }\n }\"\n@@ -376,6 +487,11 @@\n \t\telse\n \t\t  output_asm_insn (\\\"mov %L1,%L0\\\", operands);\n \t      }\n+\t    else if ((REGNO_REG_CLASS (true_regnum (operands[0]))\n+\t\t      == EXTENDED_REGS)\n+\t\t     && (((val[0] & 0x80) && ! (val[0] & 0xffffff00))\n+\t\t\t || ((val[0] & 0x800000) && ! (val[0] & 0xff000000))))\n+\t      output_asm_insn (\\\"movu %1,%0\\\", operands);\n \t    else\n \t      output_asm_insn (\\\"mov %L1,%L0\\\", operands);\n \n@@ -392,6 +508,11 @@\n \t\t      || GET_CODE (operands[1]) == CONST_DOUBLE)\n \t\t     && val[0] == val[1])\n \t      output_asm_insn (\\\"mov %L0,%H0\\\", operands);\n+\t    else if ((REGNO_REG_CLASS (true_regnum (operands[0]))\n+\t\t      == EXTENDED_REGS)\n+\t\t     && (((val[1] & 0x80) && ! (val[1] & 0xffffff00))\n+\t\t\t || ((val[1] & 0x800000) && ! (val[1] & 0xff000000))))\n+\t      output_asm_insn (\\\"movu %1,%0\\\", operands);\n \t    else\n \t      output_asm_insn (\\\"mov %H1,%H0\\\", operands);\n \t    return \\\"\\\";\n@@ -508,6 +629,11 @@\n \t\telse\n \t\t  output_asm_insn (\\\"mov %L1,%L0\\\", operands);\n \t      }\n+\t    else if ((REGNO_REG_CLASS (true_regnum (operands[0]))\n+\t\t      == EXTENDED_REGS)\n+\t\t     && (((val[0] & 0x80) && ! (val[0] & 0xffffff00))\n+\t\t\t || ((val[0] & 0x800000) && ! (val[0] & 0xff000000))))\n+\t      output_asm_insn (\\\"movu %1,%0\\\", operands);\n \t    else\n \t      output_asm_insn (\\\"mov %L1,%L0\\\", operands);\n \n@@ -524,6 +650,11 @@\n \t\t      || GET_CODE (operands[1]) == CONST_DOUBLE)\n \t\t     && val[0] == val[1])\n \t      output_asm_insn (\\\"mov %L0,%H0\\\", operands);\n+\t    else if ((REGNO_REG_CLASS (true_regnum (operands[0]))\n+\t\t      == EXTENDED_REGS)\n+\t\t     && (((val[1] & 0x80) && ! (val[1] & 0xffffff00))\n+\t\t\t || ((val[1] & 0x800000) && ! (val[1] & 0xff000000))))\n+\t      output_asm_insn (\\\"movu %1,%0\\\", operands);\n \t    else\n \t      output_asm_insn (\\\"mov %H1,%H0\\\", operands);\n \t    return \\\"\\\";\n@@ -546,19 +677,30 @@\n   \"* return output_tst (operands[0], insn);\"\n   [(set_attr \"cc\" \"set_znv\")])\n \n+(define_insn \"\"\n+  [(set (cc0) (zero_extend:SI (match_operand:QI 0 \"memory_operand\" \"dx,!a\")))]\n+  \"TARGET_AM33\"\n+  \"* return output_tst (operands[0], insn);\"\n+  [(set_attr \"cc\" \"set_znv\")])\n+\n (define_insn \"\"\n   [(set (cc0) (zero_extend:SI (match_operand:QI 0 \"memory_operand\" \"dx\")))]\n   \"\"\n   \"* return output_tst (operands[0], insn);\"\n   [(set_attr \"cc\" \"set_znv\")])\n \n+(define_insn \"\"\n+  [(set (cc0) (zero_extend:SI (match_operand:HI 0 \"memory_operand\" \"dx,!a\")))]\n+  \"TARGET_AM33\"\n+  \"* return output_tst (operands[0], insn);\"\n+  [(set_attr \"cc\" \"set_znv\")])\n+\n (define_insn \"\"\n   [(set (cc0) (zero_extend:SI (match_operand:HI 0 \"memory_operand\" \"dx\")))]\n   \"\"\n   \"* return output_tst (operands[0], insn);\"\n   [(set_attr \"cc\" \"set_znv\")])\n \n-\n (define_insn \"cmpsi\"\n   [(set (cc0)\n \t(compare (match_operand:SI 0 \"register_operand\" \"!*d*a*x,dax\")\n@@ -593,6 +735,82 @@\n    }\n }\")\n \n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=dx,ax,ax,dax,xy,!dax\")\n+\t(plus:SI (match_operand:SI 1 \"register_operand\" \"%0,0,0,0,0,dax\")\n+\t\t (match_operand:SI 2 \"nonmemory_operand\" \"J,J,L,daxi,i,dax\")))]\n+  \"TARGET_AM33\"\n+  \"*\n+{\n+  switch (which_alternative)\n+    {\n+    case 0:\n+    case 1:\n+      return \\\"inc %0\\\";\n+    case 2:\n+      return \\\"inc4 %0\\\";\n+    case 3:\n+    case 4:\n+      return \\\"add %2,%0\\\";\n+    case 5:\n+      {\n+\tenum reg_class src1_class, src2_class, dst_class;\n+\n+\tsrc1_class = REGNO_REG_CLASS (true_regnum (operands[1]));\n+\tsrc2_class = REGNO_REG_CLASS (true_regnum (operands[2]));\n+\tdst_class = REGNO_REG_CLASS (true_regnum (operands[0]));\n+\t\n+\t/* I'm not sure if this can happen or not.  Might as well be prepared\n+\t  and generate the best possible code if it does happen.  */\n+\tif (true_regnum (operands[0]) == true_regnum (operands[1]))\n+\t  return \\\"add %2,%0\\\";\n+\tif (true_regnum (operands[0]) == true_regnum (operands[2]))\n+\t  return \\\"add %1,%0\\\";\n+\n+\t/* Catch cases where no extended register was used.  These should be\n+\t   handled just like the mn10300.  */\n+\tif (src1_class != EXTENDED_REGS\n+\t    && src2_class != EXTENDED_REGS\n+\t    && dst_class != EXTENDED_REGS)\n+\t  {\n+\t    /* We have to copy one of the sources into the destination, then\n+\t       add the other source to the destination.\n+\n+\t       Carefully select which source to copy to the destination; a naive\n+\t       implementation will waste a byte when the source classes are \n+\t       different and the destination is an address register.  Selecting\n+\t       the lowest cost register copy will optimize this sequence.  */\n+\t    if (REGNO_REG_CLASS (true_regnum (operands[1]))\n+\t\t== REGNO_REG_CLASS (true_regnum (operands[0])))\n+\t      return \\\"mov %1,%0\\;add %2,%0\\\";\n+\t    return \\\"mov %2,%0\\;add %1,%0\\\";\n+\t  }\n+\n+\t/* At least one register is an extended register.  */\n+\n+\t/* The three operand add instruction on the am33 is a win iff the\n+\t   output register is an extended register, or if both source\n+\t   registers are extended registers.  */\n+\tif (dst_class == EXTENDED_REGS\n+\t    || src1_class == src2_class)\n+\t  return \\\"add %2,%1,%0\\\";\n+\n+      /* It is better to copy one of the sources to the destination, then\n+\t perform a 2 address add.  The destination in this case must be\n+\t an address or data register and one of the sources must be an\n+\t extended register and the remaining source must not be an extended\n+\t register.\n+\n+\t The best code for this case is to copy the extended reg to the\n+\t destination, then emit a two address add.  */\n+      if (src1_class == EXTENDED_REGS)\n+\treturn \\\"mov %1,%0\\;add %2,%0\\\";\n+      return \\\"mov %2,%0\\;add %1,%0\\\";\n+      }\n+    }\n+}\"\n+  [(set_attr \"cc\" \"set_zn,none_0hit,none_0hit,set_zn,none_0hit,set_zn\")])\n+\n (define_insn \"\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=dx,ax,ax,dax,xy,!dax\")\n \t(plus:SI (match_operand:SI 1 \"register_operand\" \"%0,0,0,0,0,dax\")\n@@ -644,6 +862,36 @@\n   \"\"\n   \"\")\n \n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=dax,!dax\")\n+\t(minus:SI (match_operand:SI 1 \"register_operand\" \"0,dax\")\n+\t\t  (match_operand:SI 2 \"nonmemory_operand\" \"daxi,dax\")))]\n+  \"TARGET_AM33\"\n+  \"*\n+{\n+  if (true_regnum (operands[0]) == true_regnum (operands[1]))\n+    return \\\"sub %2,%0\\\";\n+  else\n+    {\n+      enum reg_class src1_class, src2_class, dst_class;\n+\n+      src1_class = REGNO_REG_CLASS (true_regnum (operands[1]));\n+      src2_class = REGNO_REG_CLASS (true_regnum (operands[2]));\n+      dst_class = REGNO_REG_CLASS (true_regnum (operands[0]));\n+\n+      /* If no extended registers are used, then the best way to handle\n+\t this is to copy the first source operand into the destination\n+\t and emit a two address subtraction.  */\n+      if (src1_class != EXTENDED_REGS\n+\t  && src2_class != EXTENDED_REGS\n+\t  && dst_class != EXTENDED_REGS\n+\t  && true_regnum (operands[0]) != true_regnum (operands[2]))\n+\treturn \\\"mov %1,%0\\;sub %2,%0\\\";\n+      return \\\"sub %2,%1,%0\\\";\n+    }\n+}\"\n+  [(set_attr \"cc\" \"set_zn\")])\n+\n (define_insn \"\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=dax\")\n \t(minus:SI (match_operand:SI 1 \"register_operand\" \"0\")\n@@ -670,13 +918,43 @@\n ;; MULTIPLY INSTRUCTIONS\n ;; ----------------------------------------------------------------------\n \n+(define_insn \"mulsidi3\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=dax\")\n+        (mult:DI (sign_extend:DI (match_operand:SI 1 \"register_operand\" \"dax\"))\n+                 (sign_extend:DI (match_operand:SI 2 \"register_operand\" \"dax\"))))]\n+  \"TARGET_AM33\"\n+  \"mul %1,%2,%H0,%L0\"\n+  [(set_attr \"cc\" \"set_zn\")])\n+\n+(define_insn \"umulsidi3\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=dax\")\n+        (mult:DI (zero_extend:DI (match_operand:SI 1 \"register_operand\" \"dax\"))\n+                 (zero_extend:DI (match_operand:SI 2 \"register_operand\" \"dax\"))))]\n+  \"TARGET_AM33\"\n+  \"mulu %1,%2,%H0,%L0\"\n+  [(set_attr \"cc\" \"set_zn\")])\n+\n (define_expand \"mulsi3\"\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n \t(mult:SI (match_operand:SI 1 \"register_operand\" \"\")\n \t\t (match_operand:SI 2 \"register_operand\" \"\")))]\n   \"\"\n   \"\")\n \n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=dx,!dax\")\n+\t(mult:SI (match_operand:SI 1 \"register_operand\" \"%0,0\")\n+\t\t (match_operand:SI 2 \"nonmemory_operand\" \"dx,daxi\")))]\n+  \"TARGET_AM33\"\n+  \"*\n+{\n+  if (TARGET_MULT_BUG)\n+    return \\\"nop\\;nop\\;mul %2,%0\\\";\n+  else\n+    return \\\"mul %2,%0\\\";\n+}\"\n+  [(set_attr \"cc\" \"set_zn\")])\n+  \n (define_insn \"\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=dx\")\n \t(mult:SI (match_operand:SI 1 \"register_operand\" \"%0\")\n@@ -737,6 +1015,51 @@\n   \"\"\n   \"\")\n \n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=dx,dx,!dax\")\n+\t(and:SI (match_operand:SI 1 \"register_operand\" \"%0,0,dax\")\n+\t\t(match_operand:SI 2 \"nonmemory_operand\" \"N,dxi,dax\")))]\n+  \"TARGET_AM33\"\n+  \"*\n+{\n+  if (GET_CODE (operands[2]) == CONST_INT && INTVAL (operands[2]) == 0xff)\n+    return \\\"extbu %0\\\";\n+  if (GET_CODE (operands[2]) == CONST_INT && INTVAL (operands[2]) == 0xffff)\n+    return \\\"exthu %0\\\";\n+  if (GET_CODE (operands[2]) == CONST_INT && INTVAL (operands[2]) == 0x7fffffff)\n+    return \\\"add %0,%0\\;lsr 1,%0\\\";\n+  if (GET_CODE (operands[2]) == CONST_INT && INTVAL (operands[2]) == 0x3fffffff)\n+    return \\\"asl2 %0\\;lsr 2,%0\\\";\n+  if (GET_CODE (operands[2]) == CONST_INT && INTVAL (operands[2]) == 0x1fffffff)\n+    return \\\"add %0,%0\\;asl2 %0\\;lsr 3,%0\\\";\n+  if (GET_CODE (operands[2]) == CONST_INT && INTVAL (operands[2]) == 0x0fffffff)\n+    return \\\"asl2 %0\\;asl2 %0\\;lsr 4,%0\\\";\n+  if (GET_CODE (operands[2]) == CONST_INT && INTVAL (operands[2]) == 0xfffffffe)\n+    return \\\"lsr 1,%0\\;add %0,%0\\\";\n+  if (GET_CODE (operands[2]) == CONST_INT && INTVAL (operands[2]) == 0xfffffffc)\n+    return \\\"lsr 2,%0\\;asl2 %0\\\";\n+  if (GET_CODE (operands[2]) == CONST_INT && INTVAL (operands[2]) == 0xfffffff8)\n+    return \\\"lsr 3,%0\\;add %0,%0\\;asl2 %0\\\";\n+  if (GET_CODE (operands[2]) == CONST_INT && INTVAL (operands[2]) == 0xfffffff0)\n+    return \\\"lsr 4,%0\\;asl2 %0\\;asl2 %0\\\";\n+  if (REG_P (operands[2]) && REG_P (operands[1])\n+      && true_regnum (operands[0]) != true_regnum (operands[1])\n+      && true_regnum (operands[0]) != true_regnum (operands[2])\n+      && REGNO_REG_CLASS (true_regnum (operands[0])) == DATA_REGS\n+      && REGNO_REG_CLASS (true_regnum (operands[1])) == DATA_REGS\n+      && REGNO_REG_CLASS (true_regnum (operands[2])) == DATA_REGS)\n+    return \\\"mov %1,%0\\;and %2,%0\\\";\n+  if (REG_P (operands[2]) && REG_P (operands[1])\n+      && true_regnum (operands[0]) != true_regnum (operands[1])\n+      && true_regnum (operands[0]) != true_regnum (operands[2]))\n+    return \\\"and %1,%2,%0\\\";\n+  if (REG_P (operands[2]) && REG_P (operands[0])\n+      && true_regnum (operands[2]) == true_regnum (operands[0]))\n+    return \\\"and %1,%0\\\";\n+  return \\\"and %2,%0\\\";\n+}\"\n+  [(set_attr \"cc\" \"none_0hit,set_znv,set_znv\")])\n+\n (define_insn \"\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=dx,dx\")\n \t(and:SI (match_operand:SI 1 \"register_operand\" \"%0,0\")\n@@ -779,6 +1102,31 @@\n   \"\"\n   \"\")\n \n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=dx,!dax\")\n+\t(ior:SI (match_operand:SI 1 \"register_operand\" \"%0,dax\")\n+\t\t(match_operand:SI 2 \"nonmemory_operand\" \"dxi,dax\")))]\n+  \"TARGET_AM33\"\n+  \"*\n+{\n+  if (REG_P (operands[2]) && REG_P (operands[1])\n+      && true_regnum (operands[0]) != true_regnum (operands[1])\n+      && true_regnum (operands[0]) != true_regnum (operands[2])\n+      && REGNO_REG_CLASS (true_regnum (operands[0])) == DATA_REGS\n+      && REGNO_REG_CLASS (true_regnum (operands[1])) == DATA_REGS\n+      && REGNO_REG_CLASS (true_regnum (operands[2])) == DATA_REGS)\n+    return \\\"mov %1,%0\\;or %2,%0\\\";\n+  if (REG_P (operands[2]) && REG_P (operands[1])\n+      && true_regnum (operands[0]) != true_regnum (operands[1])\n+      && true_regnum (operands[0]) != true_regnum (operands[2]))\n+    return \\\"or %1,%2,%0\\\";\n+  if (REG_P (operands[2]) && REG_P (operands[0])\n+      && true_regnum (operands[2]) == true_regnum (operands[0]))\n+    return \\\"or %1,%0\\\";\n+  return \\\"or %2,%0\\\";\n+}\"\n+  [(set_attr \"cc\" \"set_znv\")])\n+\n (define_insn \"\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=dx\")\n \t(ior:SI (match_operand:SI 1 \"register_operand\" \"%0\")\n@@ -798,6 +1146,31 @@\n   \"\"\n   \"\")\n \n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=dx,!dax\")\n+\t(xor:SI (match_operand:SI 1 \"register_operand\" \"%0,dax\")\n+\t\t(match_operand:SI 2 \"nonmemory_operand\" \"dxi,dax\")))]\n+  \"TARGET_AM33\"\n+  \"*\n+{\n+  if (REG_P (operands[2]) && REG_P (operands[1])\n+      && true_regnum (operands[0]) != true_regnum (operands[1])\n+      && true_regnum (operands[0]) != true_regnum (operands[2])\n+      && REGNO_REG_CLASS (true_regnum (operands[0])) == DATA_REGS\n+      && REGNO_REG_CLASS (true_regnum (operands[1])) == DATA_REGS\n+      && REGNO_REG_CLASS (true_regnum (operands[2])) == DATA_REGS)\n+    return \\\"mov %1,%0\\;xor %2,%0\\\";\n+  if (REG_P (operands[2]) && REG_P (operands[1])\n+      && true_regnum (operands[0]) != true_regnum (operands[1])\n+      && true_regnum (operands[0]) != true_regnum (operands[2]))\n+    return \\\"xor %1,%2,%0\\\";\n+  if (REG_P (operands[2]) && REG_P (operands[0])\n+      && true_regnum (operands[2]) == true_regnum (operands[0]))\n+    return \\\"xor %1,%0\\\";\n+  return \\\"xor %2,%0\\\";\n+}\"\n+  [(set_attr \"cc\" \"set_znv\")])\n+\n (define_insn \"\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=dx\")\n \t(xor:SI (match_operand:SI 1 \"register_operand\" \"%0\")\n@@ -815,7 +1188,14 @@\n \t(not:SI (match_operand:SI 1 \"register_operand\" \"\")))]\n   \"\"\n   \"\")\n- \n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=dx,!dax\")\n+\t(not:SI (match_operand:SI 1 \"register_operand\" \"0,0\")))]\n+  \"TARGET_AM33\"\n+  \"not %0\"\n+  [(set_attr \"cc\" \"set_znv\")])\n+\n (define_insn \"\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=dx\")\n \t(not:SI (match_operand:SI 1 \"register_operand\" \"0\")))]\n@@ -1214,6 +1594,20 @@\n   \"\"\n   \"\")\n \n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=dx,dx,dx,!dax,!dax,!dax\")\n+\t(zero_extend:SI\n+\t (match_operand:QI 1 \"general_operand\" \"0,dax,m,0,dax,m\")))]\n+  \"TARGET_AM33\"\n+  \"@\n+  extbu %0\n+  mov %1,%0\\;extbu %0\n+  movbu %1,%0\n+  extbu %0\n+  mov %1,%0\\;extbu %0\n+  movbu %1,%0\"\n+  [(set_attr \"cc\" \"none_0hit\")])\n+\n (define_insn \"\"\n   [(set (match_operand:SI 0 \"general_operand\" \"=dx,dx,dx\")\n \t(zero_extend:SI\n@@ -1232,6 +1626,20 @@\n   \"\"\n   \"\")\n \n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=dx,dx,dx,!dax,!dax,!dax\")\n+\t(zero_extend:SI\n+\t (match_operand:HI 1 \"general_operand\" \"0,dax,m,0,dax,m\")))]\n+  \"TARGET_AM33\"\n+  \"@\n+  exthu %0\n+  mov %1,%0\\;exthu %0\n+  movhu %1,%0\n+  exthu %0\n+  mov %1,%0\\;exthu %0\n+  movhu %1,%0\"\n+  [(set_attr \"cc\" \"none_0hit\")])\n+\n (define_insn \"\"\n   [(set (match_operand:SI 0 \"general_operand\" \"=dx,dx,dx\")\n \t(zero_extend:SI\n@@ -1252,6 +1660,18 @@\n   \"\"\n   \"\")\n \n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=dx,dx,!dax,!dax\")\n+\t(sign_extend:SI\n+\t (match_operand:QI 1 \"general_operand\" \"0,dx,0,dax\")))]\n+  \"TARGET_AM33\"\n+  \"@\n+  extb %0\n+  mov %1,%0\\;extb %0\n+  extb %0\n+  mov %1,%0\\;extb %0\"\n+  [(set_attr \"cc\" \"none_0hit\")])\n+\n (define_insn \"\"\n   [(set (match_operand:SI 0 \"general_operand\" \"=dx,dx\")\n \t(sign_extend:SI\n@@ -1269,6 +1689,18 @@\n   \"\"\n   \"\")\n \n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=dx,dx,!dax,!dax\")\n+\t(sign_extend:SI\n+\t (match_operand:HI 1 \"general_operand\" \"0,dax,0,dax\")))]\n+  \"TARGET_AM33\"\n+  \"@\n+  exth %0\n+  mov %1,%0\\;exth %0\n+  exth %0\n+  mov %1,%0\\;exth %0\"\n+  [(set_attr \"cc\" \"none_0hit\")])\n+\n (define_insn \"\"\n   [(set (match_operand:SI 0 \"general_operand\" \"=dx,dx\")\n \t(sign_extend:SI\n@@ -1291,6 +1723,39 @@\n   \"\"\n   \"\")\n \n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=dax,dx,!dax\")\n+\t(ashift:SI\n+\t (match_operand:SI 1 \"register_operand\" \"0,0,dax\")\n+\t (match_operand:QI 2 \"nonmemory_operand\" \"J,dxi,dax\")))]\n+  \"TARGET_AM33\"\n+  \"*\n+{\n+  if (GET_CODE (operands[2]) == CONST_INT && INTVAL (operands[2]) == 1)\n+    return \\\"add %0,%0\\\";\n+\n+  if (GET_CODE (operands[2]) == CONST_INT && INTVAL (operands[2]) == 2)\n+    return \\\"asl2 %0\\\";\n+\n+  if (GET_CODE (operands[2]) == CONST_INT && INTVAL (operands[2]) == 3\n+      && REGNO_REG_CLASS (true_regnum (operands[0])) == DATA_REGS)\n+    return \\\"asl2 %0\\;add %0,%0\\\";\n+\n+  if (GET_CODE (operands[2]) == CONST_INT && INTVAL (operands[2]) == 4\n+      && REGNO_REG_CLASS (true_regnum (operands[0])) == DATA_REGS)\n+    return \\\"asl2 %0\\;asl2 %0\\\";\n+\n+  if (true_regnum (operands[1]) == true_regnum (operands[0]))\n+    return \\\"asl %S2,%0\\\";\n+\n+  if (REGNO_REG_CLASS (true_regnum (operands[0])) == DATA_REGS\n+      && REGNO_REG_CLASS (true_regnum (operands[1])) == DATA_REGS\n+      && true_regnum (operands[0]) != true_regnum (operands[2]))\n+    return \\\"mov %1,%0\\;asl %S2,%0\\\";\n+  return \\\"asl %2,%1,%0\\\";\n+}\"\n+  [(set_attr \"cc\" \"set_zn\")])\n+\n (define_insn \"\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=dax,dx,dx,dx,dx\")\n \t(ashift:SI\n@@ -1313,6 +1778,25 @@\n   \"\"\n   \"\")\n \n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=dx,!dax\")\n+\t(lshiftrt:SI\n+\t (match_operand:SI 1 \"register_operand\" \"0,dax\")\n+\t (match_operand:QI 2 \"nonmemory_operand\" \"dxi,dax\")))]\n+  \"TARGET_AM33\"\n+  \"*\n+{\n+  if (true_regnum (operands[1]) == true_regnum (operands[0]))\n+    return \\\"lsr %S2,%0\\\";\n+\n+  if (REGNO_REG_CLASS (true_regnum (operands[0])) == DATA_REGS\n+      && REGNO_REG_CLASS (true_regnum (operands[1])) == DATA_REGS\n+      && true_regnum (operands[0]) != true_regnum (operands[2]))\n+    return \\\"mov %1,%0\\;lsr %S2,%0\\\";\n+  return \\\"lsr %2,%1,%0\\\";\n+}\"\n+  [(set_attr \"cc\" \"set_zn\")])\n+\n (define_insn \"\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=dx\")\n \t(lshiftrt:SI\n@@ -1330,6 +1814,25 @@\n   \"\"\n   \"\")\n \n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=dx,!dax\")\n+\t(ashiftrt:SI\n+\t (match_operand:SI 1 \"register_operand\" \"0,dax\")\n+\t (match_operand:QI 2 \"nonmemory_operand\" \"dxi,dax\")))]\n+  \"TARGET_AM33\"\n+  \"*\n+{\n+  if (true_regnum (operands[1]) == true_regnum (operands[0]))\n+    return \\\"asr %S2,%0\\\";\n+\n+  if (REGNO_REG_CLASS (true_regnum (operands[0])) == DATA_REGS\n+      && REGNO_REG_CLASS (true_regnum (operands[1])) == DATA_REGS\n+      && true_regnum (operands[0]) != true_regnum (operands[2]))\n+    return \\\"mov %1,%0\\;asr %S2,%0\\\";\n+  return \\\"asr %2,%1,%0\\\";\n+}\"\n+  [(set_attr \"cc\" \"set_zn\")])\n+\n (define_insn \"\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=dx\")\n \t(ashiftrt:SI\n@@ -1495,6 +1998,7 @@\n {\n   int i, need_comma;\n   int d2, d3, a2, a3;\n+  int exreg1;\n \n   need_comma = 0;\n   fputs (\\\"\\\\tret [\\\", asm_out_file);\n@@ -1524,6 +2028,14 @@\n       fputs (\\\"a3\\\", asm_out_file);\n       need_comma = 1;\n     }\n+  if (regs_ever_live[14] || regs_ever_live[15]\n+      || regs_ever_live[16] || regs_ever_live[17])\n+    {\n+      if (need_comma)\n+\tfputc (',', asm_out_file); \n+      fputs (\\\"exreg1\\\", asm_out_file);\n+      need_comma = 1;\n+    }\n   fprintf (asm_out_file, \\\"],%d\\\\n\\\", INTVAL (operands[0]));\n   return \\\"\\\";\n }\"\n@@ -1536,6 +2048,7 @@\n {\n   int i, need_comma;\n   int d2, d3, a2, a3;\n+  int exreg1;\n \n   need_comma = 0;\n   fputs (\\\"\\\\tmovm [\\\", asm_out_file);\n@@ -1565,6 +2078,14 @@\n       fputs (\\\"a3\\\", asm_out_file);\n       need_comma = 1;\n     }\n+  if (regs_ever_live[14] || regs_ever_live[15]\n+      || regs_ever_live[16] || regs_ever_live[17])\n+    {\n+      if (need_comma)\n+\tfputc (',', asm_out_file); \n+      fputs (\\\"exreg1\\\", asm_out_file);\n+      need_comma = 1;\n+    }\n   fputs (\\\"],(sp)\\\\n\\\", asm_out_file);\n   return \\\"\\\";\n }\""}, {"sha": "0e3f74bb58aaff38161ffff39d4e644b1fc399f1", "filename": "gcc/config/mn10300/t-mn10300", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/705ac34f068eddf9493bc0ce8c34392667db1fdb/gcc%2Fconfig%2Fmn10300%2Ft-mn10300", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/705ac34f068eddf9493bc0ce8c34392667db1fdb/gcc%2Fconfig%2Fmn10300%2Ft-mn10300", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Ft-mn10300?ref=705ac34f068eddf9493bc0ce8c34392667db1fdb", "patch": "@@ -18,3 +18,9 @@ fp-bit.c: $(srcdir)/config/fp-bit.c\n \techo '#define FLOAT_BIT_ORDER_MISMATCH' >>fp-bit.c\n \techo '#endif' \t\t>> fp-bit.c\n \tcat $(srcdir)/config/fp-bit.c >> fp-bit.c\n+\n+MULTILIB_OPTIONS = mam33\n+MULTILIB_DIRNAMES = am33 \n+\n+LIBGCC = stmp-multilib\n+INSTALL_LIBGCC = install-multilib"}, {"sha": "8213cf4d6b4f5e9310320d3da1e01fb762108902", "filename": "gcc/invoke.texi", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/705ac34f068eddf9493bc0ce8c34392667db1fdb/gcc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/705ac34f068eddf9493bc0ce8c34392667db1fdb/gcc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finvoke.texi?ref=705ac34f068eddf9493bc0ce8c34392667db1fdb", "patch": "@@ -291,6 +291,8 @@ in the following sections.\n @emph{MN10300 Options}\n -mmult-bug\n -mno-mult-bug\n+-mam33\n+-mno-am33\n -mrelax\n \n @emph{M32R/D Options}\n@@ -4641,6 +4643,14 @@ processors.  This is the default.\n Do not generate code to avoid bugs in the multiply instructions for the\n MN10300 processors.\n \n+@table @code\n+@item -mam33\n+Generate code which uses features specific to the AM33 processor.\n+\n+@item -mno-am33\n+Do not generate code which uses features specific to the AM33 processor.  This\n+is the default.\n+\n @item -mrelax\n Indicate to the linker that it should perform a relaxation optimization pass\n to shorten branches, calls and absolute memory addresses.  This option only"}]}