{"sha": "6a15d30b22f278b793baeebec6f02facc5baa278", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmExNWQzMGIyMmYyNzhiNzkzYmFlZWJlYzZmMDJmYWNjNWJhYTI3OA==", "commit": {"author": {"name": "Andrew John Hughes", "email": "gnu_andrew@member.fsf.org", "date": "2005-04-22T05:45:02Z"}, "committer": {"name": "Michael Koch", "email": "mkoch@gcc.gnu.org", "date": "2005-04-22T05:45:02Z"}, "message": "Naming.java: Added class documentation.\n\n2005-04-22  Andrew John Hughes  <gnu_andrew@member.fsf.org>\n\n\t* java/rmi/Naming.java:\n\tAdded class documentation.\n\t(lookup(String)): Call parseURL and getName.\n\t(bind(String,java.rmi.Remote)): Likewise.\n\t(unbind(String)): Likewise.\n\t(rebind(String, java.rmi.Remote)): Likewise.\n\t(list(String)): Call parseURL.\n\t(parseURL(String)): New method to handle parsing and defaults.\n\t(getName(java.net.URL)): New method to handle finding the service name.\n\nFrom-SVN: r98542", "tree": {"sha": "041544df41c1070fa6d0451c9aedad72a0802b69", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/041544df41c1070fa6d0451c9aedad72a0802b69"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6a15d30b22f278b793baeebec6f02facc5baa278", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a15d30b22f278b793baeebec6f02facc5baa278", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6a15d30b22f278b793baeebec6f02facc5baa278", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a15d30b22f278b793baeebec6f02facc5baa278/comments", "author": {"login": "gnu-andrew", "id": 962817, "node_id": "MDQ6VXNlcjk2MjgxNw==", "avatar_url": "https://avatars.githubusercontent.com/u/962817?v=4", "gravatar_id": "", "url": "https://api.github.com/users/gnu-andrew", "html_url": "https://github.com/gnu-andrew", "followers_url": "https://api.github.com/users/gnu-andrew/followers", "following_url": "https://api.github.com/users/gnu-andrew/following{/other_user}", "gists_url": "https://api.github.com/users/gnu-andrew/gists{/gist_id}", "starred_url": "https://api.github.com/users/gnu-andrew/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/gnu-andrew/subscriptions", "organizations_url": "https://api.github.com/users/gnu-andrew/orgs", "repos_url": "https://api.github.com/users/gnu-andrew/repos", "events_url": "https://api.github.com/users/gnu-andrew/events{/privacy}", "received_events_url": "https://api.github.com/users/gnu-andrew/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "36a0d3d264f73b5f7b5a7a6793804b7c06a529cd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/36a0d3d264f73b5f7b5a7a6793804b7c06a529cd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/36a0d3d264f73b5f7b5a7a6793804b7c06a529cd"}], "stats": {"total": 146, "additions": 110, "deletions": 36}, "files": [{"sha": "230fa670a0efe300a0a5edd6d226410742eebfc9", "filename": "libjava/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a15d30b22f278b793baeebec6f02facc5baa278/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a15d30b22f278b793baeebec6f02facc5baa278/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=6a15d30b22f278b793baeebec6f02facc5baa278", "patch": "@@ -1,3 +1,15 @@\n+2005-04-22  Andrew John Hughes  <gnu_andrew@member.fsf.org>\n+\n+\t* java/rmi/Naming.java:\n+\tAdded class documentation.\n+\t(lookup(String)): Call parseURL and getName.\n+\t(bind(String,java.rmi.Remote)): Likewise.\n+\t(unbind(String)): Likewise.\n+\t(rebind(String, java.rmi.Remote)): Likewise.\n+\t(list(String)): Call parseURL.\n+\t(parseURL(String)): New method to handle parsing and defaults.\n+\t(getName(java.net.URL)): New method to handle finding the service name.\n+\n 2005-04-21  Tom Tromey  <tromey@redhat.com>\n \n \t* java/lang/natClass.cc (initializeClass): Link class."}, {"sha": "dbf687b9983b759eb308ded2fbd029ec3fa67ffe", "filename": "libjava/java/rmi/Naming.java", "status": "modified", "additions": 98, "deletions": 36, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a15d30b22f278b793baeebec6f02facc5baa278/libjava%2Fjava%2Frmi%2FNaming.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a15d30b22f278b793baeebec6f02facc5baa278/libjava%2Fjava%2Frmi%2FNaming.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Frmi%2FNaming.java?ref=6a15d30b22f278b793baeebec6f02facc5baa278", "patch": "@@ -39,11 +39,45 @@\n package java.rmi;\n \n import java.net.MalformedURLException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n import java.net.URL;\n import java.rmi.registry.LocateRegistry;\n import java.rmi.registry.Registry;\n \n+/**\n+ * <p>\n+ * The <code>Naming</code> class handles interactions with RMI registries.\n+ * Each method takes a URL in <code>String</code> form, which points to\n+ * the RMI registry.  The scheme of the URL is irrelevant.  The relevant\n+ * part is:\n+ * </p>\n+ * <p>\n+ * <code>//host:port/name</code>\n+ * </p>\n+ * <p>\n+ * which tells the method how to locate and access the registry.  The host\n+ * and port are both optional, and default to `localhost' and the standard\n+ * RMI registry port (1099) respectively.  The name is simply a string\n+ * used to refer to a particular service hosted by the registry.  The\n+ * registry does not attempt to interpret this further.\n+ * </p>\n+ * <p>\n+ * RMI services are registered using one of these names, and the same name\n+ * is later used by the client to lookup the service and access its methods. \n+ * Registries can be shared by multiple services, or a service can create\n+ * its own registry using <code>createRegistry()</code>.\n+ * </p>\n+ *\n+ * @author Original author unknown.\n+ * @author Ingo Proetel (proetel@aicas.com)\n+ * @author Guilhem Lavaux (guilhem@kaffe.org)\n+ * @author Jeroen Frijters (jeroen@frijters.net)\n+ * @author Andrew John Hughes (gnu_andrew@member.fsf.org)\n+ * @since 1.1\n+ */\n public final class Naming {\n+\n   /**\n    * This class isn't intended to be instantiated.\n    */\n@@ -66,17 +100,9 @@ private Naming() {}\n  * @throws RemoteException\n  */\n public static Remote lookup(String name) throws NotBoundException, MalformedURLException, RemoteException {\n-\t// hack to accept \"rmi://host:port/service\" strings\n-\tif(name.startsWith(\"rmi:\")){ name = name.substring(4); }\n-\tURL u = new URL(\"http:\" + name);\n-\tString filename = u.getFile();\n-\n-\t// If the filename begins with a slash we must cut it for\n-\t// name resolution.\n-\tif (filename.charAt(0) == '/')\n-\t\treturn (getRegistry(u).lookup(filename.substring(1)));\n-\telse\n-\t\treturn (getRegistry(u).lookup(filename));\n+        URL u = parseURL(name);\n+\tString serviceName = getName(u);\n+\treturn (getRegistry(u).lookup(serviceName));\n }\n \n /**\n@@ -88,14 +114,9 @@ public static Remote lookup(String name) throws NotBoundException, MalformedURLE\n  * @throws RemoteException\n  */\n public static void bind(String name, Remote obj) throws AlreadyBoundException, MalformedURLException, RemoteException {\n-\tURL u = new URL(\"http:\" + name);\n-\tString filename = u.getFile();\n-\t// If the filename begins with a slash we must cut it for\n-\t// name resolution.\n-\tif (filename.charAt(0) == '/')\n-\t\tgetRegistry(u).bind(filename.substring(1), obj);\n-\telse\n-\t\tgetRegistry(u).bind(filename, obj);\n+        URL u = parseURL(name);\n+\tString serviceName = getName(u);\n+\tgetRegistry(u).bind(serviceName, obj);\n }\n \n /**\n@@ -106,14 +127,9 @@ public static void bind(String name, Remote obj) throws AlreadyBoundException, M\n  * @throws MalformedURLException\n  */\n public static void unbind(String name) throws RemoteException, NotBoundException, MalformedURLException {\n-\tURL u = new URL(\"http:\" + name);\n-\tString filename = u.getFile();\n-\t// If the filename begins with a slash we must cut it for\n-\t// name resolution.\n-\tif (filename.charAt(0) == '/')\n-\t\tgetRegistry(u).unbind(filename.substring(1));\n-\telse\n-\t\tgetRegistry(u).unbind(filename);\n+        URL u = parseURL(name);\n+\tString serviceName = getName(u);\n+\tgetRegistry(u).unbind(serviceName);\n }\n \n /**\n@@ -125,14 +141,9 @@ public static void unbind(String name) throws RemoteException, NotBoundException\n  * @throws MalformedURLException\n  */\n public static void rebind(String name, Remote obj) throws RemoteException, MalformedURLException {\n-\tURL u = new URL(\"http:\" + name);\n-\tString filename = u.getFile();\n-\t// If the filename begins with a slash we must cut it for\n-\t// name resolution.\n-\tif (filename.charAt(0) == '/')\n-\t\tgetRegistry(u).rebind(filename.substring(1), obj);\n-\telse\n-\t\tgetRegistry(u).rebind(filename, obj);\n+        URL u = parseURL(name);\n+\tString serviceName = getName(u);\n+\tgetRegistry(u).rebind(serviceName, obj);\n }\n \n /**\n@@ -143,7 +154,7 @@ public static void rebind(String name, Remote obj) throws RemoteException, Malfo\n  * @throws MalformedURLException\n  */\n public static String[] list(String name) throws RemoteException, MalformedURLException {\n-\treturn (getRegistry(new URL(\"http:\" + name)).list());\n+\treturn (getRegistry(parseURL(name)).list());\n }\n \n private static Registry getRegistry(URL u) throws RemoteException {\n@@ -155,4 +166,55 @@ private static Registry getRegistry(URL u) throws RemoteException {\n \t}\n }\n \n+  /**\n+   * Parses the supplied URL and converts it to use the HTTP\n+   * protocol.  From an RMI perspective, the scheme is irrelevant\n+   * and we want to be able to create a URL for which a handler is\n+   * available.\n+   *\n+   * @param name the URL in String form.\n+   * @throws MalformedURLException if the URL is invalid.\n+   */\n+  private static URL parseURL(String name)\n+    throws MalformedURLException\n+  {\n+    try\n+      {\n+\tURI uri = new URI(name);\n+\tString host = uri.getHost();\n+\tint port = uri.getPort();\n+\tString query = uri.getQuery();\n+\tString path = uri.getPath();\n+\treturn new URL(\"http\", \n+\t\t       (host == null ? \"localhost\" : host),\n+\t\t       (port == -1 ? 1099 : port),\n+\t\t       uri.getPath() + (query == null ? \"\" : query));\n+      }\n+    catch (URISyntaxException e)\n+      {\n+\tthrow new MalformedURLException(\"The URL syntax was invalid: \" + \n+\t\t\t\t\te.getMessage());\n+      }\n+  }\n+\n+  /**\n+   * Checks that the URL contains a name, and removes any leading\n+   * slashes.\n+   *\n+   * @param url the URL to check.\n+   * @throws MalformedURLException if no name is specified.\n+   */ \n+  private static String getName(URL url)\n+    throws MalformedURLException\n+  {\n+    String filename = url.getFile();\n+    if (filename.length() == 0)\n+      throw new MalformedURLException(\"No path specified: \" + url);\n+    // If the filename begins with a slash we must cut it for\n+    // name resolution.\n+    if (filename.charAt(0) == '/')\n+      return filename.substring(1);\n+    return filename;\n+  }\n+\n }"}]}