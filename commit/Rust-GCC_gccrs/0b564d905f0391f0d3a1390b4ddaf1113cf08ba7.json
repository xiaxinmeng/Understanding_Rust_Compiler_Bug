{"sha": "0b564d905f0391f0d3a1390b4ddaf1113cf08ba7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGI1NjRkOTA1ZjAzOTFmMGQzYTEzOTBiNGRkYWYxMTEzY2YwOGJhNw==", "commit": {"author": {"name": "Loren J. Rittle", "email": "ljrittle@acm.org", "date": "2002-10-18T20:52:57Z"}, "committer": {"name": "Loren J. Rittle", "email": "ljrittle@gcc.gnu.org", "date": "2002-10-18T20:52:57Z"}, "message": "howto.html (GLIBCPP_FORCE_NEW): Document new environment variable which replaces all uses of __USE_MALLOC macro.\n\n\t* docs/html/23_containers/howto.html (GLIBCPP_FORCE_NEW): Document\n\tnew environment variable which replaces all uses of __USE_MALLOC\n\tmacro.\n\t* docs/html/ext/howto.html (GLIBCPP_FORCE_NEW): Likewise.\n\t(__mem_interface): Remove all references to old internal typedef.\n\t* include/backward/alloc.h (__USE_MALLOC): Remove it and all\n\tguarded code.\n\t* include/bits/c++config (__USE_MALLOC): Update related error\n\tmessage and comment.\n\t* include/bits/stl_alloc.h (__USE_MALLOC): Remove it and all\n\tguarded code.  Update all related comments.\n\t(__mem_interface): Unconditionally replace it with __new_alloc.\n\tHowever, leave the typedef around in case anyone used it.\n\t(__default_alloc_template<>::_S_force_new): New class static.\n\t(__default_alloc_template<>::allocate, deallocate): Add\n\trun-time controlled feature similar to what __USE_MALLOC code\n\tpath had provided.\n\t* src/stl-inst.cc (__USE_MALLOC): Remove it and all\n\tguarded code.\n\t* testsuite/21_strings/capacity.cc: Remove reference to __USE_MALLOC.\n\tAdd documentation on GLIBCPP_FORCE_NEW environment variable.\n\t* testsuite/ext/allocators.cc: Likewise.\n\nFrom-SVN: r58286", "tree": {"sha": "fd560f0dd8ccc32c36cc47afebca8f9282b607d8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fd560f0dd8ccc32c36cc47afebca8f9282b607d8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0b564d905f0391f0d3a1390b4ddaf1113cf08ba7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b564d905f0391f0d3a1390b4ddaf1113cf08ba7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0b564d905f0391f0d3a1390b4ddaf1113cf08ba7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b564d905f0391f0d3a1390b4ddaf1113cf08ba7/comments", "author": null, "committer": null, "parents": [{"sha": "d3f76a7098de5787727396cfd7dd908e855fd709", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d3f76a7098de5787727396cfd7dd908e855fd709", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d3f76a7098de5787727396cfd7dd908e855fd709"}], "stats": {"total": 261, "additions": 121, "deletions": 140}, "files": [{"sha": "4876e73d696e7f411dd011c97ec0c3acbfa19062", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b564d905f0391f0d3a1390b4ddaf1113cf08ba7/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b564d905f0391f0d3a1390b4ddaf1113cf08ba7/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=0b564d905f0391f0d3a1390b4ddaf1113cf08ba7", "patch": "@@ -1,3 +1,30 @@\n+2002-10-18  Loren J. Rittle  <ljrittle@acm.org>\n+\t    Brad Spencer  <spencer@infointeractive.com> (provided alternate\n+\t\t\t\t\t\t         patch and improvements)\n+\n+\t* docs/html/23_containers/howto.html (GLIBCPP_FORCE_NEW): Document\n+\tnew environment variable which replaces all uses of __USE_MALLOC\n+\tmacro.\n+\t* docs/html/ext/howto.html (GLIBCPP_FORCE_NEW): Likewise.\n+\t(__mem_interface): Remove all references to old internal typedef.\n+\t* include/backward/alloc.h (__USE_MALLOC): Remove it and all\n+\tguarded code.\n+\t* include/bits/c++config (__USE_MALLOC): Update related error\n+\tmessage and comment.\n+\t* include/bits/stl_alloc.h (__USE_MALLOC): Remove it and all\n+\tguarded code.  Update all related comments.\n+\t(__mem_interface): Unconditionally replace it with __new_alloc.\n+\tHowever, leave the typedef around in case anyone used it.\n+\t(__default_alloc_template<>::_S_force_new): New class static.\n+\t(__default_alloc_template<>::allocate, deallocate): Add\n+\trun-time controlled feature similar to what __USE_MALLOC code\n+\tpath had provided.\n+\t* src/stl-inst.cc (__USE_MALLOC): Remove it and all\n+\tguarded code.\n+\t* testsuite/21_strings/capacity.cc: Remove reference to __USE_MALLOC.\n+\tAdd documentation on GLIBCPP_FORCE_NEW environment variable.\n+\t* testsuite/ext/allocators.cc: Likewise.\n+\n 2002-10-18  Phil Edwards  <pme@gcc.gnu.org>\n \n \t* configure.in:  Use target, not target_alias, when matching triplet"}, {"sha": "008017a882757880a7dbd2c49ff263c3f6e659a0", "filename": "libstdc++-v3/docs/html/23_containers/howto.html", "status": "modified", "additions": 4, "deletions": 34, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b564d905f0391f0d3a1390b4ddaf1113cf08ba7/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2F23_containers%2Fhowto.html", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b564d905f0391f0d3a1390b4ddaf1113cf08ba7/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2F23_containers%2Fhowto.html", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2F23_containers%2Fhowto.html?ref=0b564d905f0391f0d3a1390b4ddaf1113cf08ba7", "patch": "@@ -251,41 +251,11 @@ <h2><a name=\"3\">Containers and multithreading</a></h2>\n       solution would probably be more trouble than it's worth.\n    </p>\n    <p>The STL implementation is currently configured to use the\n-      high-speed caching memory allocator.  If you absolutely think\n-      you must change this on a global basis for your platform to better\n-      support multi-threading, then please consult all commentary in\n-      include/bits/stl_alloc.h and the allocators link below.\n+      high-speed caching memory allocator.  Some people like to\n+      test and/or normally run threaded programs with a different\n+      default.  For all details about how to globally override this\n+      at application run-time see <a href=\"../ext/howto.html#3\">here</a>.\n    </p> \n-   <blockquote>\n-      <p>(Explicit warning since so many people get confused while\n-      attempting this:)\n-      </p>\n-      <p><strong>Adding -D__USE_MALLOC on the command\n-      line is almost certainly a bad idea.</strong>  Memory efficiency is\n-      almost guaranteed to suffer as a result; this is\n-      <a href=\"http://gcc.gnu.org/ml/libstdc++/2001-05/msg00136.html\">why\n-      we disabled it for 3.0 in the first place</a>.\n-      </p>\n-      <p>Related to threading or otherwise, the current recommendation is\n-      that users not add any macro defines on the command line to remove or\n-      otherwise disable features of libstdc++-v3.  There is\n-      no condition under which it will help you without causing other\n-      issues to perhaps raise up (possible linkage/ABI problems).  In\n-      particular, __USE_MALLOC should only be added to a libstdc++-v3\n-      configuration file, include/bits/c++config (where such user\n-      action is cautioned against), and the entire library should be\n-      rebuilt.  If you do not, then you might be violating the\n-      one-definition rule of C/C++ and you might cause yourself untold\n-      problems.\n-      </p>\n-   </blockquote>\n-   <p>If you find any platform where gcc reports a\n-      threading model other than single, and where libstdc++-v3 builds\n-      a buggy container allocator when used with threads unless you\n-      define __USE_MALLOC, we want to hear about it ASAP.  In the\n-      past, correctness was the main reason people were led to believe\n-      that they should define __USE_MALLOC when using threads.\n-   </p>\n    <p>There is a better way (not standardized yet):  It is possible to\n       force the malloc-based allocator on a per-case-basis for some\n       application code.  The library team generally believes that this"}, {"sha": "007335b6569300111c5d1628413253f5e6ce99be", "filename": "libstdc++-v3/docs/html/ext/howto.html", "status": "modified", "additions": 21, "deletions": 16, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b564d905f0391f0d3a1390b4ddaf1113cf08ba7/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2Fext%2Fhowto.html", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b564d905f0391f0d3a1390b4ddaf1113cf08ba7/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2Fext%2Fhowto.html", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2Fext%2Fhowto.html?ref=0b564d905f0391f0d3a1390b4ddaf1113cf08ba7", "patch": "@@ -280,19 +280,16 @@ <h3>Available allocators in namespace std</h3>\n          same as <code>allocator&lt;T&gt;</code>.\n      </li>\n    </ul>\n-   <p>An internal typedef, <code> __mem_interface </code>, is defined to be\n-      <code>__new_alloc</code> by default.\n-   </p>\n    <p>Normally,\n       <code> __default_alloc_template&lt;bool thr, int inst&gt; </code>\n       is also available.  This is the high-speed pool, called the default\n       node allocator.  The reusable memory is shared among identical\n       instantiations of\n-      this type.  It calls through <code>__mem_interface</code> to obtain\n+      this type.  It calls through <code>__new_alloc</code> to obtain\n       new memory when its lists run out.  If a client container requests a\n       block larger than a certain threshold size, then the pool is bypassed,\n       and the allocate/deallocate request is passed to\n-      <code>__mem_interface</code> directly.\n+      <code>__new_alloc</code> directly.\n    </p>\n    <p>Its <code>inst</code> parameter is described below.  The\n       <code>thr</code> boolean determines whether the pool should be\n@@ -313,17 +310,25 @@ <h3>Available allocators in namespace std</h3>\n    </p>\n    <h3>A cannon to swat a fly:<code>  __USE_MALLOC</code></h3>\n    <p>If you've already read <a href=\"../23_containers/howto.html#3\">this\n-      advice</a> and decided to define this macro, then the situation changes\n-      thusly:\n-   </p>\n-   <ol>\n-     <li><code>__mem_interface</code>, and</li>\n-     <li><code>__alloc</code>, and</li>\n-     <li><code>__single_client_alloc</code> are all typedef'd to\n-         <code>__malloc_alloc_template</code>.</li>\n-     <li><code>__default_alloc_template</code> is no longer available.\n-         At all.  Anywhere.</li>\n-   </ol>\n+      advice</a> but still think you remember how to use this macro from\n+      SGI STL days.  We have removed it in gcc 3.3.  See next section\n+      for the new way to get the same effect.\n+   </p>\n+   <h3>Globally disabling memory caching:<code>  GLIBCPP_FORCE_NEW</code></h3>\n+   <p>Starting with gcc 3.3, if you want to globally disable memory\n+      caching within the library for the default allocator (i.e.\n+      the one you get for all library objects when you do not specify\n+      which one to use), merely set GLIBCPP_FORCE_NEW (at this time,\n+      with any value) into your environment before running the\n+      program.  You will obtain a similar effect without having to\n+      recompile your entire program and the entire library (the new\n+      operator in gcc is a light wrapper around malloc).  If your\n+      program crashes with GLIBCPP_FORCE_NEW in the environment,\n+      it likely means that you linked against objects built against\n+      the older library.  Code to support this extension is fully\n+      compatible with 3.2 code if GLIBCPP_FORCE_NEW is not in the\n+      environment.\n+   </p>\n    <h3>Writing your own allocators</h3>\n    <p>Depending on your application (a specific program, a generic library,\n       etc), allocator classes tend to be one of two styles:  &quot;SGI&quot;"}, {"sha": "9482e4cfebad287bc793c34e6a81366a21b081af", "filename": "libstdc++-v3/include/backward/alloc.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b564d905f0391f0d3a1390b4ddaf1113cf08ba7/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Falloc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b564d905f0391f0d3a1390b4ddaf1113cf08ba7/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Falloc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbackward%2Falloc.h?ref=0b564d905f0391f0d3a1390b4ddaf1113cf08ba7", "patch": "@@ -53,10 +53,6 @@ using std::__debug_alloc;\n using std::__alloc; \n using std::__single_client_alloc; \n using std::allocator;\n-#ifdef __USE_MALLOC\n-using std::malloc_alloc; \n-#else\n using std::__default_alloc_template; \n-#endif\n \n #endif "}, {"sha": "05f2f5a0bfcba094e53a129013043cb7ead93794", "filename": "libstdc++-v3/include/bits/c++config", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b564d905f0391f0d3a1390b4ddaf1113cf08ba7/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fc%2B%2Bconfig", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b564d905f0391f0d3a1390b4ddaf1113cf08ba7/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fc%2B%2Bconfig", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fc%2B%2Bconfig?ref=0b564d905f0391f0d3a1390b4ddaf1113cf08ba7", "patch": "@@ -74,13 +74,8 @@\n // so, please report any possible issues to libstdc++@gcc.gnu.org .\n // Do not define __USE_MALLOC on the command line.  Enforce it here:\n #ifdef __USE_MALLOC\n-#error __USE_MALLOC should only be defined within \\\n-libstdc++-v3/include/bits/c++config before full recompilation of the library.\n+#error __USE_MALLOC should never be defined.  Read the release notes.\n #endif\n-// Define __USE_MALLOC after this point in the file in order to aid debugging\n-// or globally change allocation policy.  This breaks the ABI, thus\n-// completely recompile the library.  A patch to better support\n-// changing the global allocator policy would be probably be accepted.\n \n // The remainder of the prewritten config is mostly automatic; all the\n // user hooks are listed above."}, {"sha": "fceed498df6cafd08a0b8878756ed95b55965451", "filename": "libstdc++-v3/include/bits/stl_alloc.h", "status": "modified", "additions": 67, "deletions": 74, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b564d905f0391f0d3a1390b4ddaf1113cf08ba7/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_alloc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b564d905f0391f0d3a1390b4ddaf1113cf08ba7/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_alloc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_alloc.h?ref=0b564d905f0391f0d3a1390b4ddaf1113cf08ba7", "patch": "@@ -89,6 +89,8 @@\n #include <bits/functexcept.h>   // For __throw_bad_alloc\n #include <bits/stl_threads.h>\n \n+#include <bits/atomicity.h>\n+\n namespace std\n {\n   /**\n@@ -210,14 +212,8 @@ namespace std\n     }\n #endif\n \n-\n-  // Determines the underlying allocator choice for the node allocator.\n-#ifdef __USE_MALLOC\n-  typedef __malloc_alloc_template<0>  __mem_interface;\n-#else\n+  // Should not be referenced within the library anymore.\n   typedef __new_alloc                 __mem_interface;\n-#endif\n-\n \n   /**\n    *  @if maint\n@@ -307,23 +303,16 @@ namespace std\n     };\n \n \n-#ifdef __USE_MALLOC\n-\n-  typedef __mem_interface __alloc;\n-  typedef __mem_interface __single_client_alloc;\n-\n-#else\n-\n-\n   /**\n    *  @if maint\n-   *  Default node allocator.  \"SGI\" style.  Uses __mem_interface for its\n-   *  underlying requests (and makes as few requests as possible).\n-   *  **** Currently __mem_interface is always __new_alloc, never __malloc*.\n+   *  Default node allocator.  \"SGI\" style.  Uses various allocators to\n+   *  fulfill underlying requests (and makes as few requests as possible\n+   *  when in default high-speed pool mode).\n    *\n    *  Important implementation properties:\n+   *  0. If globally mandated, then allocate objects from __new_alloc\n    *  1. If the clients request an object of size > _MAX_BYTES, the resulting\n-   *     object will be obtained directly from the underlying __mem_interface.\n+   *     object will be obtained directly from __new_alloc\n    *  2. In all other cases, we allocate an object of size exactly\n    *     _S_round_up(requested_size).  Thus the client has enough size\n    *     information that we can return the object to the proper free list\n@@ -394,54 +383,69 @@ namespace std\n       } __attribute__ ((__unused__));\n       friend struct _Lock;\n \n+      static _Atomic_word _S_force_new;\n+\n     public:\n       // __n must be > 0\n       static void*\n       allocate(size_t __n)\n       {\n-        void* __ret = 0;\n-\n-        if (__n > (size_t) _MAX_BYTES)\n-          __ret = __mem_interface::allocate(__n);\n-        else\n-          {\n-            _Obj* volatile* __my_free_list = _S_free_list\n-                                             + _S_freelist_index(__n);\n-            // Acquire the lock here with a constructor call.  This\n-            // ensures that it is released in exit or during stack\n-            // unwinding.\n-            _Lock __lock_instance;\n-            _Obj* __restrict__ __result = *__my_free_list;\n-            if (__result == 0)\n-              __ret = _S_refill(_S_round_up(__n));\n-            else\n-              {\n-                *__my_free_list = __result -> _M_free_list_link;\n-                __ret = __result;\n-              }\n-          }\n-        return __ret;\n-      };\n+\tvoid* __ret = 0;\n+\n+\t// If there is a race through here, assume answer from getenv\n+\t// will resolve in same direction.  Inspired by techniques\n+\t// to efficiently support threading found in basic_string.h.\n+\tif (_S_force_new == 0)\n+\t  {\n+\t    if (getenv(\"GLIBCPP_FORCE_NEW\"))\n+\t      __atomic_add(&_S_force_new, 1);\n+\t    else\n+\t      __atomic_add(&_S_force_new, -1);\n+\t    // Trust but verify...\n+\t    assert (_S_force_new != 0);\n+\t  }\n+\n+\tif ((__n > (size_t) _MAX_BYTES) || (_S_force_new > 0))\n+\t  __ret = __new_alloc::allocate(__n);\n+\telse\n+\t  {\n+\t    _Obj* volatile* __my_free_list = _S_free_list\n+\t      + _S_freelist_index(__n);\n+\t    // Acquire the lock here with a constructor call.  This\n+\t    // ensures that it is released in exit or during stack\n+\t    // unwinding.\n+\t    _Lock __lock_instance;\n+\t    _Obj* __restrict__ __result = *__my_free_list;\n+\t    if (__result == 0)\n+\t      __ret = _S_refill(_S_round_up(__n));\n+\t    else\n+\t      {\n+\t\t*__my_free_list = __result -> _M_free_list_link;\n+\t\t__ret = __result;\n+\t      }\n+\t  }\n+\treturn __ret;\n+      }\n \n       // __p may not be 0\n       static void\n       deallocate(void* __p, size_t __n)\n       {\n-        if (__n > (size_t) _MAX_BYTES)\n-          __mem_interface::deallocate(__p, __n);\n-        else\n-          {\n-            _Obj* volatile*  __my_free_list = _S_free_list\n-              + _S_freelist_index(__n);\n-            _Obj* __q = (_Obj*)__p;\n-\n-            // Acquire the lock here with a constructor call.  This\n-            // ensures that it is released in exit or during stack\n-            // unwinding.\n-            _Lock __lock_instance;\n-            __q -> _M_free_list_link = *__my_free_list;\n-            *__my_free_list = __q;\n-          }\n+\tif ((__n > (size_t) _MAX_BYTES) || (_S_force_new > 0))\n+\t  __new_alloc::deallocate(__p, __n);\n+\telse\n+\t  {\n+\t    _Obj* volatile*  __my_free_list = _S_free_list\n+\t      + _S_freelist_index(__n);\n+\t    _Obj* __q = (_Obj*)__p;\n+\n+\t    // Acquire the lock here with a constructor call.  This\n+\t    // ensures that it is released in exit or during stack\n+\t    // unwinding.\n+\t    _Lock __lock_instance;\n+\t    __q -> _M_free_list_link = *__my_free_list;\n+\t    *__my_free_list = __q;\n+\t  }\n       }\n \n #ifdef _GLIBCPP_DEPRECATED\n@@ -450,6 +454,8 @@ namespace std\n #endif\n     };\n \n+  template<bool __threads, int __inst> _Atomic_word\n+  __default_alloc_template<__threads, __inst>::_S_force_new = 0;\n \n   template<bool __threads, int __inst>\n     inline bool\n@@ -465,8 +471,8 @@ namespace std\n \n \n   // We allocate memory in large chunks in order to avoid fragmenting the\n-  // malloc heap (or whatever __mem_interface is using) too much.  We assume\n-  // that __size is properly aligned.  We hold the allocation lock.\n+  // heap too much.  We assume that __size is properly aligned.  We hold\n+  // the allocation lock.\n   template<bool __threads, int __inst>\n     char*\n     __default_alloc_template<__threads, __inst>::\n@@ -503,7 +509,7 @@ namespace std\n               ((_Obj*)_S_start_free) -> _M_free_list_link = *__my_free_list;\n               *__my_free_list = (_Obj*)_S_start_free;\n             }\n-          _S_start_free = (char*) __mem_interface::allocate(__bytes_to_get);\n+          _S_start_free = (char*) __new_alloc::allocate(__bytes_to_get);\n           if (0 == _S_start_free)\n             {\n               size_t __i;\n@@ -528,7 +534,7 @@ namespace std\n                     }\n                 }\n               _S_end_free = 0;        // In case of exception.\n-              _S_start_free = (char*)__mem_interface::allocate(__bytes_to_get);\n+              _S_start_free = (char*)__new_alloc::allocate(__bytes_to_get);\n               // This should either throw an exception or remedy the situation.\n               // Thus we assume it succeeded.\n             }\n@@ -618,7 +624,6 @@ namespace std\n \n   typedef __default_alloc_template<true,0>    __alloc;\n   typedef __default_alloc_template<false,0>   __single_client_alloc;\n-#endif /* ! __USE_MALLOC */\n \n \n   /**\n@@ -628,10 +633,6 @@ namespace std\n    *  of stl_alloc.h.)\n    *\n    *  The underlying allocator behaves as follows.\n-   *  - if __USE_MALLOC then\n-   *    - thread safety depends on malloc and is entirely out of our hands\n-   *    - __malloc_alloc_template is used for memory requests\n-   *  - else (the default)\n    *    - __default_alloc_template is used via two typedefs\n    *    - \"__single_client_alloc\" typedef does no locking for threads\n    *    - \"__alloc\" typedef is threadsafe via the locks\n@@ -908,7 +909,6 @@ namespace std\n       typedef __allocator<_Tp, __malloc_alloc_template<__inst> > allocator_type;\n     };\n \n-#ifndef __USE_MALLOC\n   template<typename _Tp, bool __threads, int __inst>\n     struct _Alloc_traits<_Tp, __default_alloc_template<__threads, __inst> >\n     {\n@@ -918,7 +918,6 @@ namespace std\n       typedef __allocator<_Tp, __default_alloc_template<__threads, __inst> >\n       allocator_type;\n     };\n-#endif\n \n   template<typename _Tp, typename _Alloc>\n     struct _Alloc_traits<_Tp, __debug_alloc<_Alloc> >\n@@ -941,7 +940,6 @@ namespace std\n       typedef __allocator<_Tp, __malloc_alloc_template<__inst> > allocator_type;\n     };\n \n-#ifndef __USE_MALLOC\n   template<typename _Tp, typename _Tp1, bool __thr, int __inst>\n     struct _Alloc_traits<_Tp, __allocator<_Tp1, __default_alloc_template<__thr, __inst> > >\n     {\n@@ -951,7 +949,6 @@ namespace std\n       typedef __allocator<_Tp, __default_alloc_template<__thr,__inst> >\n       allocator_type;\n     };\n-#endif\n \n   template<typename _Tp, typename _Tp1, typename _Alloc>\n     struct _Alloc_traits<_Tp, __allocator<_Tp1, __debug_alloc<_Alloc> > >\n@@ -967,11 +964,7 @@ namespace std\n   // NB: This syntax is a GNU extension.\n   extern template class allocator<char>;\n   extern template class allocator<wchar_t>;\n-#ifdef __USE_MALLOC\n-  extern template class __malloc_alloc_template<0>;\n-#else\n   extern template class __default_alloc_template<true,0>;\n-#endif\n } // namespace std\n \n #endif"}, {"sha": "d80a718671847786b779475205ae5e7eb0571f04", "filename": "libstdc++-v3/src/stl-inst.cc", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b564d905f0391f0d3a1390b4ddaf1113cf08ba7/libstdc%2B%2B-v3%2Fsrc%2Fstl-inst.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b564d905f0391f0d3a1390b4ddaf1113cf08ba7/libstdc%2B%2B-v3%2Fsrc%2Fstl-inst.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fstl-inst.cc?ref=0b564d905f0391f0d3a1390b4ddaf1113cf08ba7", "patch": "@@ -39,9 +39,5 @@ namespace std\n   template class allocator<char>;\n   template class allocator<wchar_t>;\n \n-#ifdef __USE_MALLOC\n-  template class __malloc_alloc_template<0>;\n-#else\n   template class __default_alloc_template<true, 0>;\n-#endif\n } // namespace std"}, {"sha": "99a5b655f588d424874b68b107dea7f9a7943653", "filename": "libstdc++-v3/testsuite/21_strings/capacity.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b564d905f0391f0d3a1390b4ddaf1113cf08ba7/libstdc%2B%2B-v3%2Ftestsuite%2F21_strings%2Fcapacity.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b564d905f0391f0d3a1390b4ddaf1113cf08ba7/libstdc%2B%2B-v3%2Ftestsuite%2F21_strings%2Fcapacity.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F21_strings%2Fcapacity.cc?ref=0b564d905f0391f0d3a1390b4ddaf1113cf08ba7", "patch": "@@ -209,7 +209,7 @@ void test01()\n   sz02 = str011.length();\n   VERIFY( sz02 > sz01 );\n     \n-  // trickster allocator (__USE_MALLOC, luke) issues involved with these:\n+  // trickster allocator issues involved with these:\n   std::string str3 = \"8-chars_8-chars_\";\n   const char* p3 = str3.c_str();\n   std::string str4 = str3 + \"7-chars\";"}, {"sha": "58152145e7e8483ab35308f291b18f2dc911e6fe", "filename": "libstdc++-v3/testsuite/ext/allocators.cc", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b564d905f0391f0d3a1390b4ddaf1113cf08ba7/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fallocators.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b564d905f0391f0d3a1390b4ddaf1113cf08ba7/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fallocators.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fext%2Fallocators.cc?ref=0b564d905f0391f0d3a1390b4ddaf1113cf08ba7", "patch": "@@ -20,7 +20,6 @@\n \n // 20.4.1.1 allocator members\n \n-#undef __USE_MALLOC\n #include <memory>\n #include <cstdlib>\n #include <testsuite_hooks.h>"}]}