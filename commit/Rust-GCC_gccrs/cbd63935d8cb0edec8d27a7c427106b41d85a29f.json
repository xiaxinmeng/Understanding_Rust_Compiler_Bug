{"sha": "cbd63935d8cb0edec8d27a7c427106b41d85a29f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2JkNjM5MzVkOGNiMGVkZWM4ZDI3YTdjNDI3MTA2YjQxZDg1YTI5Zg==", "commit": {"author": {"name": "Kriang Lerdsuwanakij", "email": "lerdsuwa@users.sourceforge.net", "date": "2003-08-01T15:06:02Z"}, "committer": {"name": "Kriang Lerdsuwanakij", "email": "lerdsuwa@gcc.gnu.org", "date": "2003-08-01T15:06:02Z"}, "message": "PR c++/8442, c++/8806\n\n\tPR c++/8442, c++/8806\n\t* decl.c (qualify_lookup): Accept TEMPLATE_DECL if types are\n\tpreferred.\n\t(check_elaborated_type_specifier): Add allow_template_p\n\tparameter.  Check tag mismatch and class template.\n\t(xref_tag): Add template_header_p parameter.  Add assertion\n\tthat name is an IDENTIFIER_NODE.  Remove implicit typename\n\twarning.  Simplify lookup process if globalize is true.\n\t(cxx_init_decl_processing): Adjust call to xref_tag.\n\t(xref_tag_from_type): Likewise.\n\t* decl2.c (handle_class_head): Likewise.\n\t* parser.c (cp_parser_elaborated_type_specifier,\n\tcp_parser_class_head): Likewise.\n\t* rtti.c (init_rtti_processing, build_dynamic_cast1,\n\ttinfo_base_init, emit_support_tinfos): Likewise.\n\t* class.c (is_base_of_enclosing_class): Remove.\n\t* pt.c (convert_template_argument): Don't accept RECORD_TYPE as\n\ttemplate template argument.\n\t* cp-tree.h (xref_tag): Adjust declaration.\n\t(is_base_of_enclosing_class): Remove.\n\t* NEWS: Document template template argument change.\n\n\t* g++.dg/template/elab1.C: Likewise.\n\t* g++.dg/template/type2.C: Likewise.\n\t* g++.dg/template/ttp3.C: Adjust expected error message.\n\t* g++.old-deja/g++.law/visibility13.C: Likewise.\n\t* g++.old-deja/g++.niklas/t135.C: Likewise.\n\t* g++.old-deja/g++.pt/ttp41.C: Likewise.\n\t* g++.old-deja/g++.pt/ttp43.C: Use qualified name for template\n\ttemplate argument.\n\t* g++.old-deja/g++.pt/ttp44.C: Likewise.\n\nFrom-SVN: r70048", "tree": {"sha": "cfa3a63f72156106d2f13838ea20b64ffacdbb1f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cfa3a63f72156106d2f13838ea20b64ffacdbb1f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cbd63935d8cb0edec8d27a7c427106b41d85a29f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cbd63935d8cb0edec8d27a7c427106b41d85a29f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cbd63935d8cb0edec8d27a7c427106b41d85a29f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cbd63935d8cb0edec8d27a7c427106b41d85a29f/comments", "author": null, "committer": null, "parents": [{"sha": "ee3071efe506d022e4cad7d81354724c01e0f932", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ee3071efe506d022e4cad7d81354724c01e0f932", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ee3071efe506d022e4cad7d81354724c01e0f932"}], "stats": {"total": 381, "additions": 210, "deletions": 171}, "files": [{"sha": "c50f99f6fb3c2fceab644c7899484f2ecee0f20c", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbd63935d8cb0edec8d27a7c427106b41d85a29f/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbd63935d8cb0edec8d27a7c427106b41d85a29f/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=cbd63935d8cb0edec8d27a7c427106b41d85a29f", "patch": "@@ -1,3 +1,27 @@\n+2003-08-01  Kriang Lerdsuwanakij  <lerdsuwa@users.sourceforge.net>\n+\n+\tPR c++/8442, c++/8806\n+\t* decl.c (qualify_lookup): Accept TEMPLATE_DECL if types are\n+\tpreferred.\n+\t(check_elaborated_type_specifier): Add allow_template_p\n+\tparameter.  Check tag mismatch and class template.\n+\t(xref_tag): Add template_header_p parameter.  Add assertion\n+\tthat name is an IDENTIFIER_NODE.  Remove implicit typename\n+\twarning.  Simplify lookup process if globalize is true.\n+\t(cxx_init_decl_processing): Adjust call to xref_tag.\n+\t(xref_tag_from_type): Likewise.\n+\t* decl2.c (handle_class_head): Likewise.\n+\t* parser.c (cp_parser_elaborated_type_specifier,\n+\tcp_parser_class_head): Likewise.\n+\t* rtti.c (init_rtti_processing, build_dynamic_cast1,\n+\ttinfo_base_init, emit_support_tinfos): Likewise.\n+\t* class.c (is_base_of_enclosing_class): Remove.\n+\t* pt.c (convert_template_argument): Don't accept RECORD_TYPE as\n+\ttemplate template argument.\n+\t* cp-tree.h (xref_tag): Adjust declaration.\n+\t(is_base_of_enclosing_class): Remove.\n+\t* NEWS: Document template template argument change.\n+\n 2003-08-01  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* parser.c (cp_parser_init_declarator,"}, {"sha": "00a50e4cd82a8880f2862f3882322280d1ba7eb0", "filename": "gcc/cp/NEWS", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbd63935d8cb0edec8d27a7c427106b41d85a29f/gcc%2Fcp%2FNEWS", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbd63935d8cb0edec8d27a7c427106b41d85a29f/gcc%2Fcp%2FNEWS", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FNEWS?ref=cbd63935d8cb0edec8d27a7c427106b41d85a29f", "patch": "@@ -76,6 +76,19 @@ removed.\n * Covariant returns are implemented for all but varadic functions that\n   require an adjustment.\n \n+* Inside the scope of a template class, the name of the class itself\n+  is no longer a valid template template argument.  Instead, you now have\n+  to qualify the name by its scope.  For example:\n+\n+    template <template <class> class TT> class X {};\n+    template <class T> class Y {\n+      X<Y> x; // Invalid.\n+    };\n+\n+  The valid code for the above example is:\n+\n+      X< ::Y> x; // Valid.  Note that `<:' is a digraph and means `['.\n+\n *** Changes in GCC 3.3:\n \n * The \"new X = 3\" extension has been removed; you must now use \"new X(3)\"."}, {"sha": "4ff41fbe49ae6c79ca37dba1fbaadb95aa605808", "filename": "gcc/cp/class.c", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbd63935d8cb0edec8d27a7c427106b41d85a29f/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbd63935d8cb0edec8d27a7c427106b41d85a29f/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=cbd63935d8cb0edec8d27a7c427106b41d85a29f", "patch": "@@ -6333,21 +6333,6 @@ get_enclosing_class (tree type)\n   return NULL_TREE;\n }\n \n-/* Return 1 if TYPE or one of its enclosing classes is derived from BASE.  */\n-\n-int\n-is_base_of_enclosing_class (tree base, tree type)\n-{\n-  while (type)\n-    {\n-      if (lookup_base (type, base, ba_any, NULL))\n-\treturn 1;\n-\n-      type = get_enclosing_class (type);\n-    }\n-  return 0;\n-}\n-\n /* Note that NAME was looked up while the current class was being\n    defined and that the result of that lookup was DECL.  */\n "}, {"sha": "cfb765af753147404b15b2e418e606ee9a2caeac", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbd63935d8cb0edec8d27a7c427106b41d85a29f/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbd63935d8cb0edec8d27a7c427106b41d85a29f/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=cbd63935d8cb0edec8d27a7c427106b41d85a29f", "patch": "@@ -3603,7 +3603,6 @@ extern int same_signature_p\t\t\t(tree, tree);\n extern void warn_hidden\t\t\t\t(tree);\n extern void maybe_add_class_template_decl_list\t(tree, tree, int);\n extern tree get_enclosing_class\t\t\t(tree);\n-int is_base_of_enclosing_class\t\t\t(tree, tree);\n extern void unreverse_member_declarations       (tree);\n extern void invalidate_class_lookup_cache       (void);\n extern void maybe_note_name_used_in_class       (tree, tree);\n@@ -3731,7 +3730,7 @@ extern tree get_scope_of_declarator             (tree);\n extern void grok_special_member_properties\t(tree);\n extern int grok_ctor_properties\t\t\t(tree, tree);\n extern void grok_op_properties\t\t\t(tree, int);\n-extern tree xref_tag\t\t\t\t(enum tag_types, tree, tree, bool);\n+extern tree xref_tag\t\t\t\t(enum tag_types, tree, tree, bool, bool);\n extern tree xref_tag_from_type\t\t\t(tree, tree, int);\n extern void xref_basetypes\t\t\t(tree, tree);\n extern tree start_enum\t\t\t\t(tree);"}, {"sha": "95984c9be06ea8abcbba1e2e115269dcf63708cf", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 102, "deletions": 110, "changes": 212, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbd63935d8cb0edec8d27a7c427106b41d85a29f/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbd63935d8cb0edec8d27a7c427106b41d85a29f/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=cbd63935d8cb0edec8d27a7c427106b41d85a29f", "patch": "@@ -5753,7 +5753,8 @@ qualify_lookup (tree val, int flags)\n     return val;\n   if ((flags & LOOKUP_PREFER_NAMESPACES) && TREE_CODE (val) == NAMESPACE_DECL)\n     return val;\n-  if ((flags & LOOKUP_PREFER_TYPES) && TREE_CODE (val) == TYPE_DECL)\n+  if ((flags & LOOKUP_PREFER_TYPES)\n+      && (TREE_CODE (val) == TYPE_DECL || TREE_CODE (val) == TEMPLATE_DECL))\n     return val;\n   if (flags & (LOOKUP_PREFER_NAMESPACES | LOOKUP_PREFER_TYPES))\n     return NULL_TREE;\n@@ -6339,7 +6340,7 @@ cxx_init_decl_processing (void)\n     push_namespace (std_identifier);\n     bad_alloc_type_node \n       = xref_tag (class_type, get_identifier (\"bad_alloc\"), \n-\t\t  /*attributes=*/NULL_TREE, 1);\n+\t\t  /*attributes=*/NULL_TREE, true, false);\n     pop_namespace ();\n     ptr_ftype_sizetype \n       = build_function_type (ptr_type_node,\n@@ -12553,15 +12554,15 @@ tag_name (enum tag_types code)\n /* Name lookup in an elaborated-type-specifier (after the keyword\n    indicated by TAG_CODE) has found TYPE.  If the\n    elaborated-type-specifier is invalid, issue a diagnostic and return\n-   error_mark_node; otherwise, return TYPE itself.  */\n+   error_mark_node; otherwise, return TYPE itself.  \n+   If ALLOW_TEMPLATE_P is true, TYPE may be a class template.  */\n \n static tree\n check_elaborated_type_specifier (enum tag_types tag_code,\n-\t\t\t\t tree type)\n+\t\t\t\t tree type,\n+\t\t\t\t bool allow_template_p)\n {\n-  tree t;\n-\n-  t = follow_tag_typedef (type);\n+  tree t = follow_tag_typedef (type);\n \n   /* [dcl.type.elab] If the identifier resolves to a typedef-name or a\n      template type-parameter, the elaborated-type-specifier is\n@@ -12578,30 +12579,67 @@ check_elaborated_type_specifier (enum tag_types tag_code,\n \t     type, tag_name (tag_code));\n       t = error_mark_node;\n     }\n+  else if (TREE_CODE (type) != RECORD_TYPE\n+\t   && TREE_CODE (type) != UNION_TYPE\n+\t   && tag_code != enum_type)\n+    {\n+      error (\"`%T' referred to as `%s'\", type, tag_name (tag_code));\n+      t = error_mark_node;\n+    }\n+  else if (TREE_CODE (type) != ENUMERAL_TYPE\n+\t   && tag_code == enum_type)\n+    {\n+      error (\"`%T' referred to as enum\", type);\n+      t = error_mark_node;\n+    }\n+  else if (!allow_template_p\n+\t   && TREE_CODE (type) == RECORD_TYPE\n+\t   && CLASSTYPE_IS_TEMPLATE (type))\n+    {\n+      /* If a class template appears as elaborated type specifier\n+\t without a template header such as:\n+\n+\t   template <class T> class C {};\n+\t   void f(class C);\t\t// No template header here\n+\n+\t then the required template argument is missing.  */\n+\n+      error (\"template argument required for `%s %T'\",\n+\t     tag_name (tag_code),\n+\t     DECL_NAME (CLASSTYPE_TI_TEMPLATE (type)));\n+      t = error_mark_node;\n+    }\n \n   return t;\n }\n \n-/* Get the struct, enum or union (CODE says which) with tag NAME.\n+/* Get the struct, enum or union (TAG_CODE says which) with tag NAME.\n    Define the tag as a forward-reference if it is not defined.\n \n-   C++: If a class derivation is given, process it here, and report\n-   an error if multiple derivation declarations are not identical.\n+   If a declaration is given, process it here, and report an error if\n+   multiple declarations are not identical.  ATTRIBUTE is the attribute\n+   appeared in this declaration.\n \n-   If this is a definition, come in through xref_tag and only look in\n+   GLOBALIZE is false when this is also a definition.  Only look in\n    the current frame for the name (since C++ allows new names in any\n-   scope.)  */\n+   scope.)\n+\n+   TEMPLATE_HEADER_P is true when this declaration is preceded by\n+   a set of template parameters.  */\n \n tree\n xref_tag (enum tag_types tag_code, tree name, tree attributes, \n-\t  bool globalize)\n+\t  bool globalize, bool template_header_p)\n {\n   enum tree_code code;\n-  register tree ref, t;\n+  register tree t;\n   struct cp_binding_level *b = current_binding_level;\n   tree context = NULL_TREE;\n \n   timevar_push (TV_NAME_LOOKUP);\n+\n+  my_friendly_assert (TREE_CODE (name) == IDENTIFIER_NODE, 0);\n+\n   switch (tag_code)\n     {\n     case record_type:\n@@ -12618,93 +12656,50 @@ xref_tag (enum tag_types tag_code, tree name, tree attributes,\n       abort ();\n     }\n \n-  /* If a cross reference is requested, look up the type\n-     already defined for this tag and return it.  */\n-  if (TYPE_P (name))\n-    {\n-      t = name;\n-      name = TYPE_IDENTIFIER (t);\n-    }\n-  else\n-    t = IDENTIFIER_TYPE_VALUE (name);\n-\n-  /* Warn about 'friend struct Inherited;' doing the wrong thing.  */\n-  if (t && globalize && TREE_CODE (t) == TYPENAME_TYPE)\n-    {\n-      static int explained;\n-      tree shadowed;\n-\n-      warning (\"`%s %T' declares a new type at namespace scope\",\n-\t\t  tag_name (tag_code), name);\n-      if (!explained++)\n-\twarning (\"  names from dependent base classes are not visible to unqualified name lookup - to refer to the inherited type, say `%s %T::%T'\",\n-\t\t    tag_name (tag_code),\n-\t\t    constructor_name (current_class_type),\n-\t\t    TYPE_IDENTIFIER (t));\n-\n-      /* We need to remove the class scope binding for the\n-         TYPENAME_TYPE as otherwise poplevel_class gets confused.  */\n-      for (shadowed = b->class_shadowed;\n-\t   shadowed;\n-\t   shadowed = TREE_CHAIN (shadowed))\n-\tif (TREE_TYPE (shadowed) == TYPE_NAME (t))\n-\t  {\n-\t    TREE_PURPOSE (shadowed) = NULL_TREE;\n-\t    break;\n-\t  }\n-    }\n-\n-  if (t && TREE_CODE (t) != code && TREE_CODE (t) != TEMPLATE_TYPE_PARM\n-      && TREE_CODE (t) != BOUND_TEMPLATE_TEMPLATE_PARM)\n-    t = NULL_TREE;\n-\n   if (! globalize)\n     {\n       /* If we know we are defining this tag, only look it up in\n \t this scope and don't try to find it as a type.  */\n-      ref = lookup_tag (code, name, b, 1);\n+      t = lookup_tag (code, name, b, 1);\n     }\n   else\n     {\n-      if (t)\n-\t{\n-\t  ref = check_elaborated_type_specifier (tag_code, t);\n-\t  if (ref == error_mark_node)\n-\t    POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, error_mark_node);\n-\t}\n-      else\n-\tref = lookup_tag (code, name, b, 0);\n+      tree decl = lookup_name (name, 1);\n+\n+      if (decl && DECL_CLASS_TEMPLATE_P (decl))\n+\tdecl = DECL_TEMPLATE_RESULT (decl);\n \n-      if (! ref)\n+      if (decl && TREE_CODE (decl) == TYPE_DECL)\n \t{\n-\t  /* Try finding it as a type declaration.  If that wins,\n-\t     use it.  */\n-\t  ref = lookup_name (name, 1);\n+\t  /* Two cases we need to consider when deciding if a class\n+\t     template is allowed as an elaborated type specifier:\n+\t     1. It is a self reference to its own class.\n+\t     2. It comes with a template header.\n \n-\t  if (ref != NULL_TREE\n-\t      && processing_template_decl\n-\t      && DECL_CLASS_TEMPLATE_P (ref)\n-\t      && template_class_depth (current_class_type) == 0)\n-\t    /* Since GLOBALIZE is true, we're declaring a global\n-\t       template, so we want this type.  */\n-\t    ref = DECL_TEMPLATE_RESULT (ref);\n+\t     For example:\n \n-\t  if (ref && TREE_CODE (ref) == TYPE_DECL)\n-\t    {\n-\t      ref = check_elaborated_type_specifier (tag_code, \n-\t\t\t\t\t\t     TREE_TYPE (ref));\n-\t      if (ref == error_mark_node)\n-\t\tPOP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, error_mark_node);\n-\t      if (ref && TREE_CODE (ref) != code)\n-\t\tref = NULL_TREE;\n-\t    }\n-\t  else\n-\t    ref = NULL_TREE;\n+\t       template <class T> class C {\n+\t\t class C *c1;\t\t// DECL_SELF_REFERENCE_P is true\n+\t \t class D;\n+\t       };\n+\t       template <class U> class C; // template_header_p is true\n+\t       template <class T> class C<T>::D {\n+\t\t class C *c2;\t\t// DECL_SELF_REFERENCE_P is true\n+\t       };  */\n+\n+\t  t = check_elaborated_type_specifier (tag_code, \n+\t\t\t\t\t       TREE_TYPE (decl),\n+\t\t\t\t\t       template_header_p\n+\t\t\t\t\t       | DECL_SELF_REFERENCE_P (decl));\n+\t  if (t == error_mark_node)\n+\t    POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, error_mark_node);\n \t}\n+      else\n+\tt = NULL_TREE;\n \n-      if (ref && current_class_type\n+      if (t && current_class_type\n \t  && template_class_depth (current_class_type)\n-\t  && PROCESSING_REAL_TEMPLATE_DECL_P ())\n+\t  && template_header_p)\n \t{\n \t  /* Since GLOBALIZE is nonzero, we are not looking at a\n \t     definition of this tag.  Since, in addition, we are currently\n@@ -12742,12 +12737,12 @@ xref_tag (enum tag_types tag_code, tree name, tree attributes,\n \t      accomplish this by making sure that the new type we\n \t      create to represent this declaration has the right\n \t      TYPE_CONTEXT.  */\n-\t  context = TYPE_CONTEXT (ref);\n-\t  ref = NULL_TREE;\n+\t  context = TYPE_CONTEXT (t);\n+\t  t = NULL_TREE;\n \t}\n     }\n \n-  if (! ref)\n+  if (! t)\n     {\n       /* If no such tag is yet defined, create a forward-reference node\n \t and record it as the \"definition\".\n@@ -12757,44 +12752,41 @@ xref_tag (enum tag_types tag_code, tree name, tree attributes,\n \t{\n \t  error (\"use of enum `%#D' without previous declaration\", name);\n \n-\t  ref = make_node (ENUMERAL_TYPE);\n+\t  t = make_node (ENUMERAL_TYPE);\n \n \t  /* Give the type a default layout like unsigned int\n \t     to avoid crashing if it does not get defined.  */\n-\t  TYPE_MODE (ref) = TYPE_MODE (unsigned_type_node);\n-\t  TYPE_ALIGN (ref) = TYPE_ALIGN (unsigned_type_node);\n-\t  TYPE_USER_ALIGN (ref) = 0;\n-\t  TREE_UNSIGNED (ref) = 1;\n-\t  TYPE_PRECISION (ref) = TYPE_PRECISION (unsigned_type_node);\n-\t  TYPE_MIN_VALUE (ref) = TYPE_MIN_VALUE (unsigned_type_node);\n-\t  TYPE_MAX_VALUE (ref) = TYPE_MAX_VALUE (unsigned_type_node);\n+\t  TYPE_MODE (t) = TYPE_MODE (unsigned_type_node);\n+\t  TYPE_ALIGN (t) = TYPE_ALIGN (unsigned_type_node);\n+\t  TYPE_USER_ALIGN (t) = 0;\n+\t  TREE_UNSIGNED (t) = 1;\n+\t  TYPE_PRECISION (t) = TYPE_PRECISION (unsigned_type_node);\n+\t  TYPE_MIN_VALUE (t) = TYPE_MIN_VALUE (unsigned_type_node);\n+\t  TYPE_MAX_VALUE (t) = TYPE_MAX_VALUE (unsigned_type_node);\n \n \t  /* Enable us to recognize when a type is created in class context.\n \t     To do nested classes correctly, this should probably be cleared\n \t     out when we leave this classes scope.  Currently this in only\n \t     done in `start_enum'.  */\n \n-\t  pushtag (name, ref, globalize);\n+\t  pushtag (name, t, globalize);\n \t}\n       else\n \t{\n-\t  struct cp_binding_level *old_b = class_binding_level;\n-\n-\t  ref = make_aggr_type (code);\n-\t  TYPE_CONTEXT (ref) = context;\n-\t  pushtag (name, ref, globalize);\n-\t  class_binding_level = old_b;\n+\t  t = make_aggr_type (code);\n+\t  TYPE_CONTEXT (t) = context;\n+\t  pushtag (name, t, globalize);\n \t}\n     }\n   else\n     {\n-      if (!globalize && processing_template_decl && IS_AGGR_TYPE (ref))\n-\tredeclare_class_template (ref, current_template_parms);\n+      if (!globalize && processing_template_decl && IS_AGGR_TYPE (t))\n+\tredeclare_class_template (t, current_template_parms);\n     }\n \n-  TYPE_ATTRIBUTES (ref) = attributes;\n+  TYPE_ATTRIBUTES (t) = attributes;\n \n-  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, ref);\n+  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, t);\n }\n \n tree\n@@ -12810,7 +12802,7 @@ xref_tag_from_type (tree old, tree id, int globalize)\n   if (id == NULL_TREE)\n     id = TYPE_IDENTIFIER (old);\n \n-  return xref_tag (tag_kind, id, /*attributes=*/NULL_TREE, globalize);\n+  return xref_tag (tag_kind, id, /*attributes=*/NULL_TREE, globalize, false);\n }\n \n /* REF is a type (named NAME), for which we have just seen some"}, {"sha": "6f0686069e13d5db7a18cf127ab47d1fea3c1bcd", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbd63935d8cb0edec8d27a7c427106b41d85a29f/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbd63935d8cb0edec8d27a7c427106b41d85a29f/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=cbd63935d8cb0edec8d27a7c427106b41d85a29f", "patch": "@@ -4278,7 +4278,7 @@ handle_class_head (enum tag_types tag_kind, tree scope, tree id,\n   \n   if (!decl)\n     {\n-      decl = xref_tag (tag_kind, id, attributes, false);\n+      decl = xref_tag (tag_kind, id, attributes, false, false);\n       if (decl == error_mark_node)\n \treturn error_mark_node;\n       decl = TYPE_MAIN_DECL (decl);"}, {"sha": "fce69ca6fe68aef17eb255ef22c991cfa5f0fd95", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbd63935d8cb0edec8d27a7c427106b41d85a29f/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbd63935d8cb0edec8d27a7c427106b41d85a29f/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=cbd63935d8cb0edec8d27a7c427106b41d85a29f", "patch": "@@ -8553,7 +8553,8 @@ cp_parser_elaborated_type_specifier (cp_parser* parser,\n \t\t\t   (is_friend \n \t\t\t    || !is_declaration\n \t\t\t    || cp_lexer_next_token_is_not (parser->lexer, \n-\t\t\t\t\t\t\t   CPP_SEMICOLON)));\n+\t\t\t\t\t\t\t   CPP_SEMICOLON)),\n+\t\t\t   parser->num_template_parameter_lists);\n \t}\n     }\n   if (tag_type != enum_type)\n@@ -11380,7 +11381,8 @@ cp_parser_class_head (cp_parser* parser,\n       /* If the class was unnamed, create a dummy name.  */\n       if (!id)\n \tid = make_anon_name ();\n-      type = xref_tag (class_key, id, attributes, /*globalize=*/0);\n+      type = xref_tag (class_key, id, attributes, /*globalize=*/false,\n+\t\t       parser->num_template_parameter_lists);\n     }\n   else\n     {"}, {"sha": "d2e6bf33f81a0126b6cddb81f543ebc0ff4c4198", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 4, "deletions": 22, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbd63935d8cb0edec8d27a7c427106b41d85a29f/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbd63935d8cb0edec8d27a7c427106b41d85a29f/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=cbd63935d8cb0edec8d27a7c427106b41d85a29f", "patch": "@@ -3431,33 +3431,15 @@ convert_template_argument (tree parm,\n   requires_type = (TREE_CODE (parm) == TYPE_DECL\n \t\t   || requires_tmpl_type);\n \n-  if (TREE_CODE (arg) != RECORD_TYPE)\n-    is_tmpl_type = ((TREE_CODE (arg) == TEMPLATE_DECL\n-\t\t     && TREE_CODE (DECL_TEMPLATE_RESULT (arg)) == TYPE_DECL)\n-\t\t    || TREE_CODE (arg) == TEMPLATE_TEMPLATE_PARM\n-\t\t    || TREE_CODE (arg) == UNBOUND_CLASS_TEMPLATE);\n-  else if (CLASSTYPE_TEMPLATE_INFO (arg) && !CLASSTYPE_USE_TEMPLATE (arg)\n-\t   && PRIMARY_TEMPLATE_P (CLASSTYPE_TI_TEMPLATE (arg)))\n-    {\n-      if (is_base_of_enclosing_class (arg, current_class_type))\n-\t/* This is a template name used within the scope of the\n-\t   template. It could be the template, or it could be the\n-\t   instantiation. Choose whichever makes sense.  */\n-\tis_tmpl_type = requires_tmpl_type;\n-      else\n-\tis_tmpl_type = 1;\n-    }\n-  else\n-    /* It is a non-template class, or a specialization of a template\n-       class, or a non-template member of a template class.  */\n-    is_tmpl_type = 0;\n+  is_tmpl_type = ((TREE_CODE (arg) == TEMPLATE_DECL\n+\t\t   && TREE_CODE (DECL_TEMPLATE_RESULT (arg)) == TYPE_DECL)\n+\t\t  || TREE_CODE (arg) == TEMPLATE_TEMPLATE_PARM\n+\t\t  || TREE_CODE (arg) == UNBOUND_CLASS_TEMPLATE);\n   \n   if (is_tmpl_type\n       && (TREE_CODE (arg) == TEMPLATE_TEMPLATE_PARM\n \t  || TREE_CODE (arg) == UNBOUND_CLASS_TEMPLATE))\n     arg = TYPE_STUB_DECL (arg);\n-  else if (is_tmpl_type && TREE_CODE (arg) == RECORD_TYPE)\n-    arg = CLASSTYPE_TI_TEMPLATE (arg);\n \n   is_type = TYPE_P (arg) || is_tmpl_type;\n "}, {"sha": "5e3437fba74a062ffb9150419ed687402ce07bda", "filename": "gcc/cp/rtti.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbd63935d8cb0edec8d27a7c427106b41d85a29f/gcc%2Fcp%2Frtti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbd63935d8cb0edec8d27a7c427106b41d85a29f/gcc%2Fcp%2Frtti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frtti.c?ref=cbd63935d8cb0edec8d27a7c427106b41d85a29f", "patch": "@@ -120,7 +120,7 @@ init_rtti_processing (void)\n   push_namespace (std_identifier);\n   type_info_type_node \n     = xref_tag (class_type, get_identifier (\"type_info\"),\n-\t\t/*attributes=*/NULL_TREE, 1);\n+\t\t/*attributes=*/NULL_TREE, true, false);\n   pop_namespace ();\n   const_type_info_type = build_qualified_type (type_info_type_node, \n \t\t\t\t\t       TYPE_QUAL_CONST);\n@@ -639,7 +639,7 @@ build_dynamic_cast_1 (tree type, tree expr)\n \t      tinfo_ptr = xref_tag (class_type,\n \t\t\t\t    get_identifier (\"__class_type_info\"),\n \t\t\t\t    /*attributes=*/NULL_TREE,\n-\t\t\t\t    1);\n+\t\t\t\t    true, false);\n \t      \n \t      tinfo_ptr = build_pointer_type\n \t\t(build_qualified_type\n@@ -774,7 +774,7 @@ tinfo_base_init (tree desc, tree target)\n   \n       push_nested_namespace (abi_node);\n       real_type = xref_tag (class_type, TINFO_REAL_NAME (desc),\n-\t\t\t    /*attributes=*/NULL_TREE, 1);\n+\t\t\t    /*attributes=*/NULL_TREE, true, false);\n       pop_nested_namespace (abi_node);\n   \n       if (!COMPLETE_TYPE_P (real_type))\n@@ -1371,7 +1371,7 @@ emit_support_tinfos (void)\n   bltn_type = xref_tag (class_type,\n \t\t\tget_identifier (\"__fundamental_type_info\"), \n \t\t\t/*attributes=*/NULL_TREE,\n-\t\t\t1);\n+\t\t\ttrue, false);\n   pop_nested_namespace (abi_node);\n   if (!COMPLETE_TYPE_P (bltn_type))\n     return;"}, {"sha": "8b96d845f0e8606931d31cf627bc1e2a08dfae84", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbd63935d8cb0edec8d27a7c427106b41d85a29f/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbd63935d8cb0edec8d27a7c427106b41d85a29f/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=cbd63935d8cb0edec8d27a7c427106b41d85a29f", "patch": "@@ -1,3 +1,16 @@\n+2003-08-01  Kriang Lerdsuwanakij  <lerdsuwa@users.sourceforge.net>\n+\n+\tPR c++/8442, c++/8806\n+\t* g++.dg/template/elab1.C: New test.\n+\t* g++.dg/template/type2.C: Likewise.\n+\t* g++.dg/template/ttp3.C: Adjust expected error message.\n+\t* g++.old-deja/g++.law/visibility13.C: Likewise.\n+\t* g++.old-deja/g++.niklas/t135.C: Likewise.\n+\t* g++.old-deja/g++.pt/ttp41.C: Likewise.\n+\t* g++.old-deja/g++.pt/ttp43.C: Use qualified name for template\n+\ttemplate argument.\n+\t* g++.old-deja/g++.pt/ttp44.C: Likewise.\n+\n 2003-08-01  Nathan Sidwell  <nathan@codesourcery.com>\n \n \tPR c++/11295"}, {"sha": "778150f06dc92ca32600417b7c4392e3da45dc46", "filename": "gcc/testsuite/g++.dg/template/elab1.C", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbd63935d8cb0edec8d27a7c427106b41d85a29f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Felab1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbd63935d8cb0edec8d27a7c427106b41d85a29f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Felab1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Felab1.C?ref=cbd63935d8cb0edec8d27a7c427106b41d85a29f", "patch": "@@ -0,0 +1,13 @@\n+// Copyright (C) 2003 Free Software Foundation\n+// Contributed by Kriang Lerdsuwanakij <lerdsuwa@users.sourceforge.net>\n+// { dg-do compile }\n+\n+// Elaborate type specifier of class template\n+\n+template <class T> class A {\n+  class B;\n+};\n+\n+template <class T> class A<T>::B {\n+  friend class A;\n+};"}, {"sha": "cc3128cfc95b32aa7d80cc8b8d1d40ea4eda2dc6", "filename": "gcc/testsuite/g++.dg/template/ttp3.C", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbd63935d8cb0edec8d27a7c427106b41d85a29f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fttp3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbd63935d8cb0edec8d27a7c427106b41d85a29f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fttp3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fttp3.C?ref=cbd63935d8cb0edec8d27a7c427106b41d85a29f", "patch": "@@ -14,13 +14,13 @@ class OUTER {\n   template <class T>\n   class List { };\n   \n-  vector<class List> data; // { dg-error \"type/value mismatch|expected a type|ISO C\" \"\" }\n+  vector<class List> data; // { dg-error \"invalid|required|ISO C\" \"\" }\n };\n \n template <class T>\n-class List { };\t\t\t// { dg-bogus \"previous declaration\" \"\" { xfail *-*-* } }\n+class List { };\n \n // This next line should just do a lookup of 'class List', and then\n // get a type/value mismatch. Instead we try and push 'class List'\n // into the global namespace and get a redeclaration error.\n-vector<class List > data;\t// { dg-bogus \"`struct List' redeclared|type/value mismatch\" \"\" { xfail *-*-* } }\n+vector<class List > data;\t// { dg-error \"invalid|required|expected\" \"\" }"}, {"sha": "509c4820d6be380fce69ee433b97c6307b5b26a6", "filename": "gcc/testsuite/g++.dg/template/type2.C", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbd63935d8cb0edec8d27a7c427106b41d85a29f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ftype2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbd63935d8cb0edec8d27a7c427106b41d85a29f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ftype2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ftype2.C?ref=cbd63935d8cb0edec8d27a7c427106b41d85a29f", "patch": "@@ -0,0 +1,16 @@\n+// { dg-do compile }\n+// Origin: Juan Carlos Arevalo-Baeza <jcab@JCABs-Rumblings.com>\n+\n+// PR c++/8442\n+// Type template parameter incorrectly treated as template template\n+// parameter.\n+\n+template <typename T> struct A {};\n+\n+template <typename T> struct B\n+{\n+  template <typename U> struct C {};\n+  template <typename U> A<C<U> > foo(U);\n+};\n+\n+B<void> b;"}, {"sha": "025b0b1ef54035a8a814a0dc27fc6c95fe44fa46", "filename": "gcc/testsuite/g++.old-deja/g++.law/visibility13.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbd63935d8cb0edec8d27a7c427106b41d85a29f/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.law%2Fvisibility13.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbd63935d8cb0edec8d27a7c427106b41d85a29f/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.law%2Fvisibility13.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.law%2Fvisibility13.C?ref=cbd63935d8cb0edec8d27a7c427106b41d85a29f", "patch": "@@ -65,7 +65,7 @@ void Array<Type>::init(const Type *array, int sz)\n //     ---------------   Array_RC.h  &&  Array_RC.cc   ----------------\n \n template <class Type>\n-class Array_RC : public Array<Type> {// { dg-error \"\" } previous declaration.*\n+class Array_RC : public Array<Type> {\n public:\n     Array_RC(const Type *ar, int sz);\n     Type& operator[](int ix);"}, {"sha": "566b0ca1ba3cf1d851d996ad9af2f75cf141112f", "filename": "gcc/testsuite/g++.old-deja/g++.niklas/t135.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbd63935d8cb0edec8d27a7c427106b41d85a29f/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.niklas%2Ft135.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbd63935d8cb0edec8d27a7c427106b41d85a29f/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.niklas%2Ft135.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.niklas%2Ft135.C?ref=cbd63935d8cb0edec8d27a7c427106b41d85a29f", "patch": "@@ -1,7 +1,7 @@\n-// { dg-do assemble }\n+// { dg-do compile }\n // GROUPS niklas pt friend\n template <class T> class C1\n-{ // { dg-error \"\" }\n+{\n public:\n \tvoid diddle_C2 ();\n };"}, {"sha": "b260961e813949d9a2f0af448186b5b9e2279837", "filename": "gcc/testsuite/g++.old-deja/g++.pt/ttp41.C", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbd63935d8cb0edec8d27a7c427106b41d85a29f/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fttp41.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbd63935d8cb0edec8d27a7c427106b41d85a29f/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fttp41.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fttp41.C?ref=cbd63935d8cb0edec8d27a7c427106b41d85a29f", "patch": "@@ -1,4 +1,4 @@\n-// { dg-do run  }\n+// { dg-do compile }\n template<template<class> class D,class E> class C\n {\n \tpublic:\n@@ -13,8 +13,8 @@ template<class T> class D\n \n template<class T> int D<T>::f()\n {\n-\tC<D,D> c;\n-\treturn c.g();\n+\tC<D,D> c;\t// { dg-error \"\" }\n+\treturn c.g();\t// { dg-error \"\" }\n }\n \n int main()"}, {"sha": "e1bc4cee6521224a6166e1a67c3b02c624cc5093", "filename": "gcc/testsuite/g++.old-deja/g++.pt/ttp43.C", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbd63935d8cb0edec8d27a7c427106b41d85a29f/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fttp43.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbd63935d8cb0edec8d27a7c427106b41d85a29f/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fttp43.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fttp43.C?ref=cbd63935d8cb0edec8d27a7c427106b41d85a29f", "patch": "@@ -20,11 +20,11 @@ struct Lit {\n \n template < class T >\n struct Id {\n-  Add < T, Id, Lit > operator+(const T& t) const {\n-    return Add < T, Id, Lit >(*this, Lit<T>(t));\n+  Add < T, ::Id, Lit > operator+(const T& t) const {\n+    return Add < T, ::Id, Lit >(*this, Lit<T>(t));\n   }\n \n-  Mul < T, Id, Lit > operator*(const T& t) const {\n-    return Mul < T, Id, Lit >(*this, Lit<T>(t));\n+  Mul < T, ::Id, Lit > operator*(const T& t) const {\n+    return Mul < T, ::Id, Lit >(*this, Lit<T>(t));\n   }\n };"}, {"sha": "08eb3077f024b96cf2142d3bfbda8a0f7e8490b3", "filename": "gcc/testsuite/g++.old-deja/g++.pt/ttp44.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbd63935d8cb0edec8d27a7c427106b41d85a29f/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fttp44.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbd63935d8cb0edec8d27a7c427106b41d85a29f/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fttp44.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fttp44.C?ref=cbd63935d8cb0edec8d27a7c427106b41d85a29f", "patch": "@@ -9,8 +9,8 @@ public:\n template < class T >\n struct Id {\n   template < template < class > class E >\n-  Add < T, Id, E > operator+(const E<T>& e) const {\n-    return Add < T, Id, E >(*this, e);\n+  Add < T, ::Id, E > operator+(const E<T>& e) const {\n+    return Add < T, ::Id, E >(*this, e);\n   }\n };\n "}]}