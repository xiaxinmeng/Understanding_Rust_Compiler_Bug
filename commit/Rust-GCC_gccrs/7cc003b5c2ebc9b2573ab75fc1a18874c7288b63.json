{"sha": "7cc003b5c2ebc9b2573ab75fc1a18874c7288b63", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2NjMDAzYjVjMmViYzliMjU3M2FiNzVmYzFhMTg4NzRjNzI4OGI2Mw==", "commit": {"author": {"name": "Richard Sandiford", "email": "rdsandiford@googlemail.com", "date": "2008-11-16T20:31:13Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2008-11-16T20:31:13Z"}, "message": "re PR target/38052 (genautomata segfaults when -O2 is enabled)\n\ngcc/\n\tPR target/38052\n\t* config/mips/mips.c (mips_cfun_call_saved_reg_p)\n\t(mips_cfun_might_clobber_call_saved_reg_p): New functions,\n\tsplit out from...\n\t(mips_save_reg_p): ...here.  Always consult TARGET_CALL_SAVED_GP\n\trather than call_really_used_regs when handling $gp.\n\nFrom-SVN: r141926", "tree": {"sha": "bdc35ba9036ef04b4c9475e0971bd8161b85eaf8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bdc35ba9036ef04b4c9475e0971bd8161b85eaf8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7cc003b5c2ebc9b2573ab75fc1a18874c7288b63", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7cc003b5c2ebc9b2573ab75fc1a18874c7288b63", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7cc003b5c2ebc9b2573ab75fc1a18874c7288b63", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7cc003b5c2ebc9b2573ab75fc1a18874c7288b63/comments", "author": {"login": "rsandifo", "id": 4235983, "node_id": "MDQ6VXNlcjQyMzU5ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/4235983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo", "html_url": "https://github.com/rsandifo", "followers_url": "https://api.github.com/users/rsandifo/followers", "following_url": "https://api.github.com/users/rsandifo/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo/orgs", "repos_url": "https://api.github.com/users/rsandifo/repos", "events_url": "https://api.github.com/users/rsandifo/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8d9d9172904ef71ad7edc1f3ee3bb725dc294948", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d9d9172904ef71ad7edc1f3ee3bb725dc294948", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8d9d9172904ef71ad7edc1f3ee3bb725dc294948"}], "stats": {"total": 102, "additions": 74, "deletions": 28}, "files": [{"sha": "ec60104c1f705efcd3ccd4f12dc65d727448e441", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cc003b5c2ebc9b2573ab75fc1a18874c7288b63/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cc003b5c2ebc9b2573ab75fc1a18874c7288b63/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7cc003b5c2ebc9b2573ab75fc1a18874c7288b63", "patch": "@@ -1,3 +1,12 @@\n+2008-11-16  Richard Sandiford  <rdsandiford@googlemail.com>\n+\n+\tPR target/38052\n+\t* config/mips/mips.c (mips_cfun_call_saved_reg_p)\n+\t(mips_cfun_might_clobber_call_saved_reg_p): New functions,\n+\tsplit out from...\n+\t(mips_save_reg_p): ...here.  Always consult TARGET_CALL_SAVED_GP\n+\trather than call_really_used_regs when handling $gp.\n+\n 2008-11-16  Richard Sandiford  <rdsandiford@googlemail.com>\n \n \tPR target/38052"}, {"sha": "5953e1a680cd9c5f58a1326107fe36c2bed92cfa", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 65, "deletions": 28, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cc003b5c2ebc9b2573ab75fc1a18874c7288b63/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cc003b5c2ebc9b2573ab75fc1a18874c7288b63/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=7cc003b5c2ebc9b2573ab75fc1a18874c7288b63", "patch": "@@ -8433,48 +8433,85 @@ mips_global_pointer (void)\n   return GLOBAL_POINTER_REGNUM;\n }\n \n-/* Return true if the current function must save register REGNO.  */\n+/* Return true if the current function should treat register REGNO\n+   as call-saved.  */\n \n static bool\n-mips_save_reg_p (unsigned int regno)\n+mips_cfun_call_saved_reg_p (unsigned int regno)\n+{\n+  /* call_insns preserve $28 unless they explicitly say otherwise,\n+     so call_really_used_regs[] treats $28 as call-saved.  However,\n+     we want the ABI property rather than the default call_insn\n+     property here.  */\n+  return (regno == GLOBAL_POINTER_REGNUM\n+\t  ? TARGET_CALL_SAVED_GP\n+\t  : !call_really_used_regs[regno]);\n+}\n+\n+/* Return true if the function body might clobber register REGNO.\n+   We know that REGNO is call-saved.  */\n+\n+static bool\n+mips_cfun_might_clobber_call_saved_reg_p (unsigned int regno)\n {\n-  /* We need to save $gp if TARGET_CALL_SAVED_GP and if we have not\n-     chosen a call-clobbered substitute.  */\n-  if (TARGET_CALL_SAVED_GP\n-      && regno == GLOBAL_POINTER_REGNUM\n-      && cfun->machine->global_pointer == regno)\n+  /* Some functions should be treated as clobbering all call-saved\n+     registers.  */\n+  if (crtl->saves_all_registers)\n     return true;\n \n-  /* Check call-saved registers.  */\n-  if ((crtl->saves_all_registers || df_regs_ever_live_p (regno))\n-      && !call_really_used_regs[regno])\n+  /* DF handles cases where a register is explicitly referenced in\n+     the rtl.  Incoming values are passed in call-clobbered registers,\n+     so we can assume that any live call-saved register is set within\n+     the function.  */\n+  if (df_regs_ever_live_p (regno))\n     return true;\n \n-  /* Save both registers in an FPR pair if either one is used.  This is\n-     needed for the case when MIN_FPRS_PER_FMT == 1, which allows the odd\n-     register to be used without the even register.  */\n-  if (FP_REG_P (regno)\n-      && MAX_FPRS_PER_FMT == 2\n-      && df_regs_ever_live_p (regno + 1)\n-      && !call_really_used_regs[regno + 1])\n+  /* Check for registers that are clobbered by FUNCTION_PROFILER.\n+     These clobbers are not explicit in the rtl.  */\n+  if (crtl->profile && MIPS_SAVE_REG_FOR_PROFILING_P (regno))\n     return true;\n \n-  /* We need to save the old frame pointer before setting up a new one.  */\n+  /* If we're using a call-saved global pointer, the function's\n+     prologue will need to set it up.  */\n+  if (cfun->machine->global_pointer == regno)\n+    return true;\n+\n+  /* The function's prologue will need to set the frame pointer if\n+     frame_pointer_needed.  */\n   if (regno == HARD_FRAME_POINTER_REGNUM && frame_pointer_needed)\n     return true;\n \n-  /* Check for registers that must be saved for FUNCTION_PROFILER.  */\n-  if (crtl->profile && MIPS_SAVE_REG_FOR_PROFILING_P (regno))\n+  /* If a MIPS16 function returns a value in FPRs, its epilogue\n+     will need to call an external libgcc routine.  This yet-to-be\n+     generated call_insn will clobber $31.  */\n+  if (regno == GP_REG_FIRST + 31 && mips16_cfun_returns_in_fpr_p ())\n     return true;\n \n-  /* We need to save the incoming return address if it is ever clobbered\n-     within the function, if __builtin_eh_return is being used to set a\n-     different return address, or if a stub is being used to return a\n-     value in FPRs.  */\n-  if (regno == GP_REG_FIRST + 31\n-      && (df_regs_ever_live_p (regno)\n-\t  || crtl->calls_eh_return\n-\t  || mips16_cfun_returns_in_fpr_p ()))\n+  return false;\n+}\n+\n+/* Return true if the current function must save register REGNO.  */\n+\n+static bool\n+mips_save_reg_p (unsigned int regno)\n+{\n+  if (mips_cfun_call_saved_reg_p (regno))\n+    {\n+      if (mips_cfun_might_clobber_call_saved_reg_p (regno))\n+\treturn true;\n+\n+      /* Save both registers in an FPR pair if either one is used.  This is\n+\t needed for the case when MIN_FPRS_PER_FMT == 1, which allows the odd\n+\t register to be used without the even register.  */\n+      if (FP_REG_P (regno)\n+\t  && MAX_FPRS_PER_FMT == 2\n+\t  && mips_cfun_might_clobber_call_saved_reg_p (regno + 1))\n+\treturn true;\n+    }\n+\n+  /* We need to save the incoming return address if __builtin_eh_return\n+     is being used to set a different return address.  */\n+  if (regno == GP_REG_FIRST + 31 && crtl->calls_eh_return)\n     return true;\n \n   return false;"}]}