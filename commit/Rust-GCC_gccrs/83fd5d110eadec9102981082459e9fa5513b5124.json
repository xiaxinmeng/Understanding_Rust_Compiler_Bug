{"sha": "83fd5d110eadec9102981082459e9fa5513b5124", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODNmZDVkMTEwZWFkZWM5MTAyOTgxMDgyNDU5ZTlmYTU1MTNiNTEyNA==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2013-10-14T12:06:38Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2013-10-14T12:06:38Z"}, "message": "gimple.c (gimple_canonical_types, [...]): Move to lto/lto.c\n\n2013-10-14  Richard Biener  <rguenther@suse.de>\n\n\t* gimple.c (gimple_canonical_types, canonical_type_hash_cache,\n\titerative_hash_canonical_type, gimple_canonical_type_hash,\n\tgimple_canonical_types_compatible_p, gimple_canonical_type_eq,\n\tgimple_register_canonical_type, print_gimple_types_stats,\n\tfree_gimple_type_tables): Move to lto/lto.c\n\t(gt-gimple.h): Do not include.\n\t* gimple.h (gimple_register_canonical_type,\n\tprint_gimple_types_stats, free_gimple_type_tables): Remove.\n\t* Makefile.in (GTFILES): Remove gimple.c.\n\n\tlto/\n\t* lto-lang.c (lto_init): Do not re-init canonical types here.\n\t(lto_register_canonical_types): Move to ...\n\t* lto.c (lto_register_canonical_types): ... here.\n\t(gimple_canonical_types, canonical_type_hash_cache,\n\titerative_hash_canonical_type, gimple_canonical_type_hash,\n\tgimple_canonical_types_compatible_p, gimple_canonical_type_eq,\n\tgimple_register_canonical_type): Add canonical type merging machinery\n\tmoved from gimple.c.\n\t(read_cgraph_and_symbols): Init and free canonical type tables\n\there.\n\t(print_lto_report_1): Report canonical type table stats here.\n\nFrom-SVN: r203521", "tree": {"sha": "5851ead175606fe8c897bc8ed1b707d4f2d9d845", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5851ead175606fe8c897bc8ed1b707d4f2d9d845"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/83fd5d110eadec9102981082459e9fa5513b5124", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/83fd5d110eadec9102981082459e9fa5513b5124", "html_url": "https://github.com/Rust-GCC/gccrs/commit/83fd5d110eadec9102981082459e9fa5513b5124", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/83fd5d110eadec9102981082459e9fa5513b5124/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a6dbd0f72b75340ceb96ea55ec18c01b6bee4ef2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a6dbd0f72b75340ceb96ea55ec18c01b6bee4ef2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a6dbd0f72b75340ceb96ea55ec18c01b6bee4ef2"}], "stats": {"total": 977, "additions": 481, "deletions": 496}, "files": [{"sha": "0a03d3ccb8112fd695d990b4ddb38919c75478fc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83fd5d110eadec9102981082459e9fa5513b5124/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83fd5d110eadec9102981082459e9fa5513b5124/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=83fd5d110eadec9102981082459e9fa5513b5124", "patch": "@@ -1,3 +1,15 @@\n+2013-10-14  Richard Biener  <rguenther@suse.de>\n+\n+\t* gimple.c (gimple_canonical_types, canonical_type_hash_cache,\n+\titerative_hash_canonical_type, gimple_canonical_type_hash,\n+\tgimple_canonical_types_compatible_p, gimple_canonical_type_eq,\n+\tgimple_register_canonical_type, print_gimple_types_stats,\n+\tfree_gimple_type_tables): Move to lto/lto.c\n+\t(gt-gimple.h): Do not include.\n+\t* gimple.h (gimple_register_canonical_type,\n+\tprint_gimple_types_stats, free_gimple_type_tables): Remove.\n+\t* Makefile.in (GTFILES): Remove gimple.c.\n+\n 2013-10-14  Travis Snoozy  <quandary@remstate.com>\n \n \tPR target/58716"}, {"sha": "24c8fed8a64b09a42bace583dc40a3329c27d68e", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83fd5d110eadec9102981082459e9fa5513b5124/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83fd5d110eadec9102981082459e9fa5513b5124/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=83fd5d110eadec9102981082459e9fa5513b5124", "patch": "@@ -2240,7 +2240,7 @@ GTFILES = $(CPP_ID_DATA_H) $(srcdir)/input.h $(srcdir)/coretypes.h \\\n   $(srcdir)/reg-stack.c $(srcdir)/cfgrtl.c \\\n   $(srcdir)/sdbout.c $(srcdir)/stor-layout.c \\\n   $(srcdir)/stringpool.c $(srcdir)/tree.c $(srcdir)/varasm.c \\\n-  $(srcdir)/gimple.h $(srcdir)/gimple.c \\\n+  $(srcdir)/gimple.h \\\n   $(srcdir)/tree-mudflap.c $(srcdir)/gimple-ssa.h \\\n   $(srcdir)/tree-ssanames.c $(srcdir)/tree-eh.c $(srcdir)/tree-ssa-address.c \\\n   $(srcdir)/tree-cfg.c \\"}, {"sha": "a12dd67a118eaa994eab7a1791e6331f61bdb03e", "filename": "gcc/gimple.c", "status": "modified", "additions": 0, "deletions": 459, "changes": 459, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83fd5d110eadec9102981082459e9fa5513b5124/gcc%2Fgimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83fd5d110eadec9102981082459e9fa5513b5124/gcc%2Fgimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.c?ref=83fd5d110eadec9102981082459e9fa5513b5124", "patch": "@@ -37,11 +37,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"demangle.h\"\n #include \"langhooks.h\"\n \n-/* Global canonical type table.  */\n-static GTY((if_marked (\"ggc_marked_p\"), param_is (union tree_node)))\n-  htab_t gimple_canonical_types;\n-static GTY((if_marked (\"tree_int_map_marked_p\"), param_is (struct tree_int_map)))\n-  htab_t canonical_type_hash_cache;\n \n /* All the tuples have their operand vector (if present) at the very bottom\n    of the structure.  Therefore, the offset required to find the\n@@ -3099,458 +3094,6 @@ gimple_compare_field_offset (tree f1, tree f2)\n   return false;\n }\n \n-/* Returning a hash value for gimple type TYPE combined with VAL.\n-\n-   The hash value returned is equal for types considered compatible\n-   by gimple_canonical_types_compatible_p.  */\n-\n-static hashval_t\n-iterative_hash_canonical_type (tree type, hashval_t val)\n-{\n-  hashval_t v;\n-  void **slot;\n-  struct tree_int_map *mp, m;\n-\n-  m.base.from = type;\n-  if ((slot = htab_find_slot (canonical_type_hash_cache, &m, NO_INSERT)))\n-    return iterative_hash_hashval_t (((struct tree_int_map *) *slot)->to, val);\n-\n-  /* Combine a few common features of types so that types are grouped into\n-     smaller sets; when searching for existing matching types to merge,\n-     only existing types having the same features as the new type will be\n-     checked.  */\n-  v = iterative_hash_hashval_t (TREE_CODE (type), 0);\n-  v = iterative_hash_hashval_t (TREE_ADDRESSABLE (type), v);\n-  v = iterative_hash_hashval_t (TYPE_ALIGN (type), v);\n-  v = iterative_hash_hashval_t (TYPE_MODE (type), v);\n-\n-  /* Incorporate common features of numerical types.  */\n-  if (INTEGRAL_TYPE_P (type)\n-      || SCALAR_FLOAT_TYPE_P (type)\n-      || FIXED_POINT_TYPE_P (type)\n-      || TREE_CODE (type) == OFFSET_TYPE\n-      || POINTER_TYPE_P (type))\n-    {\n-      v = iterative_hash_hashval_t (TYPE_PRECISION (type), v);\n-      v = iterative_hash_hashval_t (TYPE_UNSIGNED (type), v);\n-    }\n-\n-  if (VECTOR_TYPE_P (type))\n-    {\n-      v = iterative_hash_hashval_t (TYPE_VECTOR_SUBPARTS (type), v);\n-      v = iterative_hash_hashval_t (TYPE_UNSIGNED (type), v);\n-    }\n-\n-  if (TREE_CODE (type) == COMPLEX_TYPE)\n-    v = iterative_hash_hashval_t (TYPE_UNSIGNED (type), v);\n-\n-  /* For pointer and reference types, fold in information about the type\n-     pointed to but do not recurse to the pointed-to type.  */\n-  if (POINTER_TYPE_P (type))\n-    {\n-      v = iterative_hash_hashval_t (TYPE_REF_CAN_ALIAS_ALL (type), v);\n-      v = iterative_hash_hashval_t (TYPE_ADDR_SPACE (TREE_TYPE (type)), v);\n-      v = iterative_hash_hashval_t (TYPE_RESTRICT (type), v);\n-      v = iterative_hash_hashval_t (TREE_CODE (TREE_TYPE (type)), v);\n-    }\n-\n-  /* For integer types hash only the string flag.  */\n-  if (TREE_CODE (type) == INTEGER_TYPE)\n-    v = iterative_hash_hashval_t (TYPE_STRING_FLAG (type), v);\n-\n-  /* For array types hash the domain bounds and the string flag.  */\n-  if (TREE_CODE (type) == ARRAY_TYPE && TYPE_DOMAIN (type))\n-    {\n-      v = iterative_hash_hashval_t (TYPE_STRING_FLAG (type), v);\n-      /* OMP lowering can introduce error_mark_node in place of\n-\t random local decls in types.  */\n-      if (TYPE_MIN_VALUE (TYPE_DOMAIN (type)) != error_mark_node)\n-\tv = iterative_hash_expr (TYPE_MIN_VALUE (TYPE_DOMAIN (type)), v);\n-      if (TYPE_MAX_VALUE (TYPE_DOMAIN (type)) != error_mark_node)\n-\tv = iterative_hash_expr (TYPE_MAX_VALUE (TYPE_DOMAIN (type)), v);\n-    }\n-\n-  /* Recurse for aggregates with a single element type.  */\n-  if (TREE_CODE (type) == ARRAY_TYPE\n-      || TREE_CODE (type) == COMPLEX_TYPE\n-      || TREE_CODE (type) == VECTOR_TYPE)\n-    v = iterative_hash_canonical_type (TREE_TYPE (type), v);\n-\n-  /* Incorporate function return and argument types.  */\n-  if (TREE_CODE (type) == FUNCTION_TYPE || TREE_CODE (type) == METHOD_TYPE)\n-    {\n-      unsigned na;\n-      tree p;\n-\n-      /* For method types also incorporate their parent class.  */\n-      if (TREE_CODE (type) == METHOD_TYPE)\n-\tv = iterative_hash_canonical_type (TYPE_METHOD_BASETYPE (type), v);\n-\n-      v = iterative_hash_canonical_type (TREE_TYPE (type), v);\n-\n-      for (p = TYPE_ARG_TYPES (type), na = 0; p; p = TREE_CHAIN (p))\n-\t{\n-\t  v = iterative_hash_canonical_type (TREE_VALUE (p), v);\n-\t  na++;\n-\t}\n-\n-      v = iterative_hash_hashval_t (na, v);\n-    }\n-\n-  if (RECORD_OR_UNION_TYPE_P (type))\n-    {\n-      unsigned nf;\n-      tree f;\n-\n-      for (f = TYPE_FIELDS (type), nf = 0; f; f = TREE_CHAIN (f))\n-\tif (TREE_CODE (f) == FIELD_DECL)\n-\t  {\n-\t    v = iterative_hash_canonical_type (TREE_TYPE (f), v);\n-\t    nf++;\n-\t  }\n-\n-      v = iterative_hash_hashval_t (nf, v);\n-    }\n-\n-  /* Cache the just computed hash value.  */\n-  mp = ggc_alloc_cleared_tree_int_map ();\n-  mp->base.from = type;\n-  mp->to = v;\n-  /* As we recurse the hashtable may expand between looking up the\n-     cached value (and not finding one) and here, so we have to\n-     re-lookup the slot.  */\n-  slot = htab_find_slot (canonical_type_hash_cache, &m, INSERT);\n-  *slot = (void *) mp;\n-\n-  return iterative_hash_hashval_t (v, val);\n-}\n-\n-static hashval_t\n-gimple_canonical_type_hash (const void *p)\n-{\n-  if (canonical_type_hash_cache == NULL)\n-    canonical_type_hash_cache = htab_create_ggc (512, tree_int_map_hash,\n-\t\t\t\t\t\t tree_int_map_eq, NULL);\n-\n-  return iterative_hash_canonical_type (CONST_CAST_TREE ((const_tree) p), 0);\n-}\n-\n-\n-\n-\n-/* The TYPE_CANONICAL merging machinery.  It should closely resemble\n-   the middle-end types_compatible_p function.  It needs to avoid\n-   claiming types are different for types that should be treated\n-   the same with respect to TBAA.  Canonical types are also used\n-   for IL consistency checks via the useless_type_conversion_p\n-   predicate which does not handle all type kinds itself but falls\n-   back to pointer-comparison of TYPE_CANONICAL for aggregates\n-   for example.  */\n-\n-/* Return true iff T1 and T2 are structurally identical for what\n-   TBAA is concerned.  */\n-\n-static bool\n-gimple_canonical_types_compatible_p (tree t1, tree t2)\n-{\n-  /* Before starting to set up the SCC machinery handle simple cases.  */\n-\n-  /* Check first for the obvious case of pointer identity.  */\n-  if (t1 == t2)\n-    return true;\n-\n-  /* Check that we have two types to compare.  */\n-  if (t1 == NULL_TREE || t2 == NULL_TREE)\n-    return false;\n-\n-  /* If the types have been previously registered and found equal\n-     they still are.  */\n-  if (TYPE_CANONICAL (t1)\n-      && TYPE_CANONICAL (t1) == TYPE_CANONICAL (t2))\n-    return true;\n-\n-  /* Can't be the same type if the types don't have the same code.  */\n-  if (TREE_CODE (t1) != TREE_CODE (t2))\n-    return false;\n-\n-  if (TREE_ADDRESSABLE (t1) != TREE_ADDRESSABLE (t2))\n-    return false;\n-\n-  /* Qualifiers do not matter for canonical type comparison purposes.  */\n-\n-  /* Void types and nullptr types are always the same.  */\n-  if (TREE_CODE (t1) == VOID_TYPE\n-      || TREE_CODE (t1) == NULLPTR_TYPE)\n-    return true;\n-\n-  /* Can't be the same type if they have different alignment, or mode.  */\n-  if (TYPE_ALIGN (t1) != TYPE_ALIGN (t2)\n-      || TYPE_MODE (t1) != TYPE_MODE (t2))\n-    return false;\n-\n-  /* Non-aggregate types can be handled cheaply.  */\n-  if (INTEGRAL_TYPE_P (t1)\n-      || SCALAR_FLOAT_TYPE_P (t1)\n-      || FIXED_POINT_TYPE_P (t1)\n-      || TREE_CODE (t1) == VECTOR_TYPE\n-      || TREE_CODE (t1) == COMPLEX_TYPE\n-      || TREE_CODE (t1) == OFFSET_TYPE\n-      || POINTER_TYPE_P (t1))\n-    {\n-      /* Can't be the same type if they have different sign or precision.  */\n-      if (TYPE_PRECISION (t1) != TYPE_PRECISION (t2)\n-\t  || TYPE_UNSIGNED (t1) != TYPE_UNSIGNED (t2))\n-\treturn false;\n-\n-      if (TREE_CODE (t1) == INTEGER_TYPE\n-\t  && TYPE_STRING_FLAG (t1) != TYPE_STRING_FLAG (t2))\n-\treturn false;\n-\n-      /* For canonical type comparisons we do not want to build SCCs\n-\t so we cannot compare pointed-to types.  But we can, for now,\n-\t require the same pointed-to type kind and match what\n-\t useless_type_conversion_p would do.  */\n-      if (POINTER_TYPE_P (t1))\n-\t{\n-\t  /* If the two pointers have different ref-all attributes,\n-\t     they can't be the same type.  */\n-\t  if (TYPE_REF_CAN_ALIAS_ALL (t1) != TYPE_REF_CAN_ALIAS_ALL (t2))\n-\t    return false;\n-\n-\t  if (TYPE_ADDR_SPACE (TREE_TYPE (t1))\n-\t      != TYPE_ADDR_SPACE (TREE_TYPE (t2)))\n-\t    return false;\n-\n-\t  if (TYPE_RESTRICT (t1) != TYPE_RESTRICT (t2))\n-\t    return false;\n-\n-\t  if (TREE_CODE (TREE_TYPE (t1)) != TREE_CODE (TREE_TYPE (t2)))\n-\t    return false;\n-\t}\n-\n-      /* Tail-recurse to components.  */\n-      if (TREE_CODE (t1) == VECTOR_TYPE\n-\t  || TREE_CODE (t1) == COMPLEX_TYPE)\n-\treturn gimple_canonical_types_compatible_p (TREE_TYPE (t1),\n-\t\t\t\t\t\t    TREE_TYPE (t2));\n-\n-      return true;\n-    }\n-\n-  /* Do type-specific comparisons.  */\n-  switch (TREE_CODE (t1))\n-    {\n-    case ARRAY_TYPE:\n-      /* Array types are the same if the element types are the same and\n-\t the number of elements are the same.  */\n-      if (!gimple_canonical_types_compatible_p (TREE_TYPE (t1), TREE_TYPE (t2))\n-\t  || TYPE_STRING_FLAG (t1) != TYPE_STRING_FLAG (t2)\n-\t  || TYPE_NONALIASED_COMPONENT (t1) != TYPE_NONALIASED_COMPONENT (t2))\n-\treturn false;\n-      else\n-\t{\n-\t  tree i1 = TYPE_DOMAIN (t1);\n-\t  tree i2 = TYPE_DOMAIN (t2);\n-\n-\t  /* For an incomplete external array, the type domain can be\n- \t     NULL_TREE.  Check this condition also.  */\n-\t  if (i1 == NULL_TREE && i2 == NULL_TREE)\n-\t    return true;\n-\t  else if (i1 == NULL_TREE || i2 == NULL_TREE)\n-\t    return false;\n-\t  else\n-\t    {\n-\t      tree min1 = TYPE_MIN_VALUE (i1);\n-\t      tree min2 = TYPE_MIN_VALUE (i2);\n-\t      tree max1 = TYPE_MAX_VALUE (i1);\n-\t      tree max2 = TYPE_MAX_VALUE (i2);\n-\n-\t      /* The minimum/maximum values have to be the same.  */\n-\t      if ((min1 == min2\n-\t\t   || (min1 && min2\n-\t\t       && ((TREE_CODE (min1) == PLACEHOLDER_EXPR\n-\t\t\t    && TREE_CODE (min2) == PLACEHOLDER_EXPR)\n-\t\t           || operand_equal_p (min1, min2, 0))))\n-\t\t  && (max1 == max2\n-\t\t      || (max1 && max2\n-\t\t\t  && ((TREE_CODE (max1) == PLACEHOLDER_EXPR\n-\t\t\t       && TREE_CODE (max2) == PLACEHOLDER_EXPR)\n-\t\t\t      || operand_equal_p (max1, max2, 0)))))\n-\t\treturn true;\n-\t      else\n-\t\treturn false;\n-\t    }\n-\t}\n-\n-    case METHOD_TYPE:\n-    case FUNCTION_TYPE:\n-      /* Function types are the same if the return type and arguments types\n-\t are the same.  */\n-      if (!gimple_canonical_types_compatible_p (TREE_TYPE (t1), TREE_TYPE (t2)))\n-\treturn false;\n-\n-      if (!comp_type_attributes (t1, t2))\n-\treturn false;\n-\n-      if (TYPE_ARG_TYPES (t1) == TYPE_ARG_TYPES (t2))\n-\treturn true;\n-      else\n-\t{\n-\t  tree parms1, parms2;\n-\n-\t  for (parms1 = TYPE_ARG_TYPES (t1), parms2 = TYPE_ARG_TYPES (t2);\n-\t       parms1 && parms2;\n-\t       parms1 = TREE_CHAIN (parms1), parms2 = TREE_CHAIN (parms2))\n-\t    {\n-\t      if (!gimple_canonical_types_compatible_p\n-\t\t     (TREE_VALUE (parms1), TREE_VALUE (parms2)))\n-\t\treturn false;\n-\t    }\n-\n-\t  if (parms1 || parms2)\n-\t    return false;\n-\n-\t  return true;\n-\t}\n-\n-    case RECORD_TYPE:\n-    case UNION_TYPE:\n-    case QUAL_UNION_TYPE:\n-      {\n-\ttree f1, f2;\n-\n-\t/* For aggregate types, all the fields must be the same.  */\n-\tfor (f1 = TYPE_FIELDS (t1), f2 = TYPE_FIELDS (t2);\n-\t     f1 || f2;\n-\t     f1 = TREE_CHAIN (f1), f2 = TREE_CHAIN (f2))\n-\t  {\n-\t    /* Skip non-fields.  */\n-\t    while (f1 && TREE_CODE (f1) != FIELD_DECL)\n-\t      f1 = TREE_CHAIN (f1);\n-\t    while (f2 && TREE_CODE (f2) != FIELD_DECL)\n-\t      f2 = TREE_CHAIN (f2);\n-\t    if (!f1 || !f2)\n-\t      break;\n-\t    /* The fields must have the same name, offset and type.  */\n-\t    if (DECL_NONADDRESSABLE_P (f1) != DECL_NONADDRESSABLE_P (f2)\n-\t\t|| !gimple_compare_field_offset (f1, f2)\n-\t\t|| !gimple_canonical_types_compatible_p\n-\t\t      (TREE_TYPE (f1), TREE_TYPE (f2)))\n-\t      return false;\n-\t  }\n-\n-\t/* If one aggregate has more fields than the other, they\n-\t   are not the same.  */\n-\tif (f1 || f2)\n-\t  return false;\n-\n-\treturn true;\n-      }\n-\n-    default:\n-      gcc_unreachable ();\n-    }\n-}\n-\n-\n-/* Returns nonzero if P1 and P2 are equal.  */\n-\n-static int\n-gimple_canonical_type_eq (const void *p1, const void *p2)\n-{\n-  const_tree t1 = (const_tree) p1;\n-  const_tree t2 = (const_tree) p2;\n-  return gimple_canonical_types_compatible_p (CONST_CAST_TREE (t1),\n-\t\t\t\t\t      CONST_CAST_TREE (t2));\n-}\n-\n-/* Register type T in the global type table gimple_types.\n-   If another type T', compatible with T, already existed in\n-   gimple_types then return T', otherwise return T.  This is used by\n-   LTO to merge identical types read from different TUs.\n-\n-   ???  This merging does not exactly match how the tree.c middle-end\n-   functions will assign TYPE_CANONICAL when new types are created\n-   during optimization (which at least happens for pointer and array\n-   types).  */\n-\n-tree\n-gimple_register_canonical_type (tree t)\n-{\n-  void **slot;\n-\n-  gcc_assert (TYPE_P (t));\n-\n-  if (TYPE_CANONICAL (t))\n-    return TYPE_CANONICAL (t);\n-\n-  if (gimple_canonical_types == NULL)\n-    gimple_canonical_types = htab_create_ggc (16381, gimple_canonical_type_hash,\n-\t\t\t\t\t      gimple_canonical_type_eq, 0);\n-\n-  slot = htab_find_slot (gimple_canonical_types, t, INSERT);\n-  if (*slot\n-      && *(tree *)slot != t)\n-    {\n-      tree new_type = (tree) *((tree *) slot);\n-\n-      TYPE_CANONICAL (t) = new_type;\n-      t = new_type;\n-    }\n-  else\n-    {\n-      TYPE_CANONICAL (t) = t;\n-      *slot = (void *) t;\n-    }\n-\n-  return t;\n-}\n-\n-\n-/* Show statistics on references to the global type table gimple_types.  */\n-\n-void\n-print_gimple_types_stats (const char *pfx)\n-{\n-  if (gimple_canonical_types)\n-    fprintf (stderr, \"[%s] GIMPLE canonical type table: size %ld, \"\n-\t     \"%ld elements, %ld searches, %ld collisions (ratio: %f)\\n\", pfx,\n-\t     (long) htab_size (gimple_canonical_types),\n-\t     (long) htab_elements (gimple_canonical_types),\n-\t     (long) gimple_canonical_types->searches,\n-\t     (long) gimple_canonical_types->collisions,\n-\t     htab_collisions (gimple_canonical_types));\n-  else\n-    fprintf (stderr, \"[%s] GIMPLE canonical type table is empty\\n\", pfx);\n-  if (canonical_type_hash_cache)\n-    fprintf (stderr, \"[%s] GIMPLE canonical type hash table: size %ld, \"\n-\t     \"%ld elements, %ld searches, %ld collisions (ratio: %f)\\n\", pfx,\n-\t     (long) htab_size (canonical_type_hash_cache),\n-\t     (long) htab_elements (canonical_type_hash_cache),\n-\t     (long) canonical_type_hash_cache->searches,\n-\t     (long) canonical_type_hash_cache->collisions,\n-\t     htab_collisions (canonical_type_hash_cache));\n-  else\n-    fprintf (stderr, \"[%s] GIMPLE canonical type hash table is empty\\n\", pfx);\n-}\n-\n-/* Free the gimple type hashtables used for LTO type merging.  */\n-\n-void\n-free_gimple_type_tables (void)\n-{\n-  if (gimple_canonical_types)\n-    {\n-      htab_delete (gimple_canonical_types);\n-      gimple_canonical_types = NULL;\n-    }\n-  if (canonical_type_hash_cache)\n-    {\n-      htab_delete (canonical_type_hash_cache);\n-      canonical_type_hash_cache = NULL;\n-    }\n-}\n-\n \n /* Return a type the same as TYPE except unsigned or\n    signed according to UNSIGNEDP.  */\n@@ -4520,5 +4063,3 @@ nonfreeing_call_p (gimple call)\n \n   return false;\n }\n-\n-#include \"gt-gimple.h\""}, {"sha": "c0c19ce995a9c29a2a398a650aa6ddecca4f2fa6", "filename": "gcc/gimple.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83fd5d110eadec9102981082459e9fa5513b5124/gcc%2Fgimple.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83fd5d110eadec9102981082459e9fa5513b5124/gcc%2Fgimple.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.h?ref=83fd5d110eadec9102981082459e9fa5513b5124", "patch": "@@ -891,9 +891,6 @@ extern bool is_gimple_builtin_call (gimple stmt);\n \n extern void recalculate_side_effects (tree);\n extern bool gimple_compare_field_offset (tree, tree);\n-extern tree gimple_register_canonical_type (tree);\n-extern void print_gimple_types_stats (const char *);\n-extern void free_gimple_type_tables (void);\n extern tree gimple_unsigned_type (tree);\n extern tree gimple_signed_type (tree);\n extern alias_set_type gimple_get_alias_set (tree);"}, {"sha": "58474af57ca6243950ebd1008c4854e628c28f6f", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83fd5d110eadec9102981082459e9fa5513b5124/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83fd5d110eadec9102981082459e9fa5513b5124/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=83fd5d110eadec9102981082459e9fa5513b5124", "patch": "@@ -1,3 +1,17 @@\n+2013-10-14  Richard Biener  <rguenther@suse.de>\n+\n+\t* lto-lang.c (lto_init): Do not re-init canonical types here.\n+\t(lto_register_canonical_types): Move to ...\n+\t* lto.c (lto_register_canonical_types): ... here.\n+\t(gimple_canonical_types, canonical_type_hash_cache,\n+\titerative_hash_canonical_type, gimple_canonical_type_hash,\n+\tgimple_canonical_types_compatible_p, gimple_canonical_type_eq,\n+\tgimple_register_canonical_type): Add canonical type merging machinery\n+\tmoved from gimple.c.\n+\t(read_cgraph_and_symbols): Init and free canonical type tables\n+\there.\n+\t(print_lto_report_1): Report canonical type table stats here.\n+\n 2013-10-11  Jakub Jelinek  <jakub@redhat.com>\n \n \t* lto-lang.c (DEF_FUNCTION_TYPE_8): Define."}, {"sha": "0fa0fc9a4380337d6f0c8acfffe025a4172e0e3f", "filename": "gcc/lto/lto-lang.c", "status": "modified", "additions": 0, "deletions": 31, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83fd5d110eadec9102981082459e9fa5513b5124/gcc%2Flto%2Flto-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83fd5d110eadec9102981082459e9fa5513b5124/gcc%2Flto%2Flto-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto-lang.c?ref=83fd5d110eadec9102981082459e9fa5513b5124", "patch": "@@ -1134,31 +1134,11 @@ lto_build_c_type_nodes (void)\n   pid_type_node = integer_type_node;\n }\n \n-/* Re-compute TYPE_CANONICAL for NODE and related types.  */\n-\n-static void\n-lto_register_canonical_types (tree node)\n-{\n-  if (!node\n-      || !TYPE_P (node))\n-    return;\n-\n-  TYPE_CANONICAL (node) = NULL_TREE;\n-  TYPE_CANONICAL (node) = gimple_register_canonical_type (node);\n-\n-  if (POINTER_TYPE_P (node)\n-      || TREE_CODE (node) == COMPLEX_TYPE\n-      || TREE_CODE (node) == ARRAY_TYPE)\n-    lto_register_canonical_types (TREE_TYPE (node));\n-}\n-\n /* Perform LTO-specific initialization.  */\n \n static bool\n lto_init (void)\n {\n-  unsigned i;\n-\n   /* We need to generate LTO if running in WPA mode.  */\n   flag_generate_lto = flag_wpa;\n \n@@ -1226,17 +1206,6 @@ lto_init (void)\n   NAME_TYPE (boolean_type_node, \"bool\");\n #undef NAME_TYPE\n \n-  /* Register the common node types with the canonical type machinery so\n-     we properly share alias-sets across languages and TUs.  Do not\n-     expose the common nodes as type merge target - those that should be\n-     are already exposed so by pre-loading the LTO streamer caches.  */\n-  for (i = 0; i < itk_none; ++i)\n-    lto_register_canonical_types (integer_types[i]);\n-  /* The sizetypes are not used to access data so we do not need to\n-     do anything about them.  */\n-  for (i = 0; i < TI_MAX; ++i)\n-    lto_register_canonical_types (global_trees[i]);\n-\n   /* Initialize LTO-specific data structures.  */\n   vec_alloc (lto_global_var_decls, 256);\n   in_lto_p = true;"}, {"sha": "f01b37521fd46fb658f83db45734784ae14dd91e", "filename": "gcc/lto/lto.c", "status": "modified", "additions": 454, "deletions": 2, "changes": 456, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83fd5d110eadec9102981082459e9fa5513b5124/gcc%2Flto%2Flto.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83fd5d110eadec9102981082459e9fa5513b5124/gcc%2Flto%2Flto.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto.c?ref=83fd5d110eadec9102981082459e9fa5513b5124", "patch": "@@ -254,6 +254,427 @@ lto_read_in_decl_state (struct data_in *data_in, const uint32_t *data,\n }\n \n \n+/* Global canonical type table.  */\n+static GTY((if_marked (\"ggc_marked_p\"), param_is (union tree_node)))\n+  htab_t gimple_canonical_types;\n+static GTY((if_marked (\"tree_int_map_marked_p\"), param_is (struct tree_int_map)))\n+  htab_t canonical_type_hash_cache;\n+\n+/* Returning a hash value for gimple type TYPE combined with VAL.\n+\n+   The hash value returned is equal for types considered compatible\n+   by gimple_canonical_types_compatible_p.  */\n+\n+static hashval_t\n+iterative_hash_canonical_type (tree type, hashval_t val)\n+{\n+  hashval_t v;\n+  void **slot;\n+  struct tree_int_map *mp, m;\n+\n+  m.base.from = type;\n+  if ((slot = htab_find_slot (canonical_type_hash_cache, &m, NO_INSERT)))\n+    return iterative_hash_hashval_t (((struct tree_int_map *) *slot)->to, val);\n+\n+  /* Combine a few common features of types so that types are grouped into\n+     smaller sets; when searching for existing matching types to merge,\n+     only existing types having the same features as the new type will be\n+     checked.  */\n+  v = iterative_hash_hashval_t (TREE_CODE (type), 0);\n+  v = iterative_hash_hashval_t (TREE_ADDRESSABLE (type), v);\n+  v = iterative_hash_hashval_t (TYPE_ALIGN (type), v);\n+  v = iterative_hash_hashval_t (TYPE_MODE (type), v);\n+\n+  /* Incorporate common features of numerical types.  */\n+  if (INTEGRAL_TYPE_P (type)\n+      || SCALAR_FLOAT_TYPE_P (type)\n+      || FIXED_POINT_TYPE_P (type)\n+      || TREE_CODE (type) == OFFSET_TYPE\n+      || POINTER_TYPE_P (type))\n+    {\n+      v = iterative_hash_hashval_t (TYPE_PRECISION (type), v);\n+      v = iterative_hash_hashval_t (TYPE_UNSIGNED (type), v);\n+    }\n+\n+  if (VECTOR_TYPE_P (type))\n+    {\n+      v = iterative_hash_hashval_t (TYPE_VECTOR_SUBPARTS (type), v);\n+      v = iterative_hash_hashval_t (TYPE_UNSIGNED (type), v);\n+    }\n+\n+  if (TREE_CODE (type) == COMPLEX_TYPE)\n+    v = iterative_hash_hashval_t (TYPE_UNSIGNED (type), v);\n+\n+  /* For pointer and reference types, fold in information about the type\n+     pointed to but do not recurse to the pointed-to type.  */\n+  if (POINTER_TYPE_P (type))\n+    {\n+      v = iterative_hash_hashval_t (TYPE_REF_CAN_ALIAS_ALL (type), v);\n+      v = iterative_hash_hashval_t (TYPE_ADDR_SPACE (TREE_TYPE (type)), v);\n+      v = iterative_hash_hashval_t (TYPE_RESTRICT (type), v);\n+      v = iterative_hash_hashval_t (TREE_CODE (TREE_TYPE (type)), v);\n+    }\n+\n+  /* For integer types hash only the string flag.  */\n+  if (TREE_CODE (type) == INTEGER_TYPE)\n+    v = iterative_hash_hashval_t (TYPE_STRING_FLAG (type), v);\n+\n+  /* For array types hash the domain bounds and the string flag.  */\n+  if (TREE_CODE (type) == ARRAY_TYPE && TYPE_DOMAIN (type))\n+    {\n+      v = iterative_hash_hashval_t (TYPE_STRING_FLAG (type), v);\n+      /* OMP lowering can introduce error_mark_node in place of\n+\t random local decls in types.  */\n+      if (TYPE_MIN_VALUE (TYPE_DOMAIN (type)) != error_mark_node)\n+\tv = iterative_hash_expr (TYPE_MIN_VALUE (TYPE_DOMAIN (type)), v);\n+      if (TYPE_MAX_VALUE (TYPE_DOMAIN (type)) != error_mark_node)\n+\tv = iterative_hash_expr (TYPE_MAX_VALUE (TYPE_DOMAIN (type)), v);\n+    }\n+\n+  /* Recurse for aggregates with a single element type.  */\n+  if (TREE_CODE (type) == ARRAY_TYPE\n+      || TREE_CODE (type) == COMPLEX_TYPE\n+      || TREE_CODE (type) == VECTOR_TYPE)\n+    v = iterative_hash_canonical_type (TREE_TYPE (type), v);\n+\n+  /* Incorporate function return and argument types.  */\n+  if (TREE_CODE (type) == FUNCTION_TYPE || TREE_CODE (type) == METHOD_TYPE)\n+    {\n+      unsigned na;\n+      tree p;\n+\n+      /* For method types also incorporate their parent class.  */\n+      if (TREE_CODE (type) == METHOD_TYPE)\n+\tv = iterative_hash_canonical_type (TYPE_METHOD_BASETYPE (type), v);\n+\n+      v = iterative_hash_canonical_type (TREE_TYPE (type), v);\n+\n+      for (p = TYPE_ARG_TYPES (type), na = 0; p; p = TREE_CHAIN (p))\n+\t{\n+\t  v = iterative_hash_canonical_type (TREE_VALUE (p), v);\n+\t  na++;\n+\t}\n+\n+      v = iterative_hash_hashval_t (na, v);\n+    }\n+\n+  if (RECORD_OR_UNION_TYPE_P (type))\n+    {\n+      unsigned nf;\n+      tree f;\n+\n+      for (f = TYPE_FIELDS (type), nf = 0; f; f = TREE_CHAIN (f))\n+\tif (TREE_CODE (f) == FIELD_DECL)\n+\t  {\n+\t    v = iterative_hash_canonical_type (TREE_TYPE (f), v);\n+\t    nf++;\n+\t  }\n+\n+      v = iterative_hash_hashval_t (nf, v);\n+    }\n+\n+  /* Cache the just computed hash value.  */\n+  mp = ggc_alloc_cleared_tree_int_map ();\n+  mp->base.from = type;\n+  mp->to = v;\n+  /* As we recurse the hashtable may expand between looking up the\n+     cached value (and not finding one) and here, so we have to\n+     re-lookup the slot.  */\n+  slot = htab_find_slot (canonical_type_hash_cache, &m, INSERT);\n+  *slot = (void *) mp;\n+\n+  return iterative_hash_hashval_t (v, val);\n+}\n+\n+static hashval_t\n+gimple_canonical_type_hash (const void *p)\n+{\n+  return iterative_hash_canonical_type (CONST_CAST_TREE ((const_tree) p), 0);\n+}\n+\n+\n+/* The TYPE_CANONICAL merging machinery.  It should closely resemble\n+   the middle-end types_compatible_p function.  It needs to avoid\n+   claiming types are different for types that should be treated\n+   the same with respect to TBAA.  Canonical types are also used\n+   for IL consistency checks via the useless_type_conversion_p\n+   predicate which does not handle all type kinds itself but falls\n+   back to pointer-comparison of TYPE_CANONICAL for aggregates\n+   for example.  */\n+\n+/* Return true iff T1 and T2 are structurally identical for what\n+   TBAA is concerned.  */\n+\n+static bool\n+gimple_canonical_types_compatible_p (tree t1, tree t2)\n+{\n+  /* Before starting to set up the SCC machinery handle simple cases.  */\n+\n+  /* Check first for the obvious case of pointer identity.  */\n+  if (t1 == t2)\n+    return true;\n+\n+  /* Check that we have two types to compare.  */\n+  if (t1 == NULL_TREE || t2 == NULL_TREE)\n+    return false;\n+\n+  /* If the types have been previously registered and found equal\n+     they still are.  */\n+  if (TYPE_CANONICAL (t1)\n+      && TYPE_CANONICAL (t1) == TYPE_CANONICAL (t2))\n+    return true;\n+\n+  /* Can't be the same type if the types don't have the same code.  */\n+  if (TREE_CODE (t1) != TREE_CODE (t2))\n+    return false;\n+\n+  if (TREE_ADDRESSABLE (t1) != TREE_ADDRESSABLE (t2))\n+    return false;\n+\n+  /* Qualifiers do not matter for canonical type comparison purposes.  */\n+\n+  /* Void types and nullptr types are always the same.  */\n+  if (TREE_CODE (t1) == VOID_TYPE\n+      || TREE_CODE (t1) == NULLPTR_TYPE)\n+    return true;\n+\n+  /* Can't be the same type if they have different alignment, or mode.  */\n+  if (TYPE_ALIGN (t1) != TYPE_ALIGN (t2)\n+      || TYPE_MODE (t1) != TYPE_MODE (t2))\n+    return false;\n+\n+  /* Non-aggregate types can be handled cheaply.  */\n+  if (INTEGRAL_TYPE_P (t1)\n+      || SCALAR_FLOAT_TYPE_P (t1)\n+      || FIXED_POINT_TYPE_P (t1)\n+      || TREE_CODE (t1) == VECTOR_TYPE\n+      || TREE_CODE (t1) == COMPLEX_TYPE\n+      || TREE_CODE (t1) == OFFSET_TYPE\n+      || POINTER_TYPE_P (t1))\n+    {\n+      /* Can't be the same type if they have different sign or precision.  */\n+      if (TYPE_PRECISION (t1) != TYPE_PRECISION (t2)\n+\t  || TYPE_UNSIGNED (t1) != TYPE_UNSIGNED (t2))\n+\treturn false;\n+\n+      if (TREE_CODE (t1) == INTEGER_TYPE\n+\t  && TYPE_STRING_FLAG (t1) != TYPE_STRING_FLAG (t2))\n+\treturn false;\n+\n+      /* For canonical type comparisons we do not want to build SCCs\n+\t so we cannot compare pointed-to types.  But we can, for now,\n+\t require the same pointed-to type kind and match what\n+\t useless_type_conversion_p would do.  */\n+      if (POINTER_TYPE_P (t1))\n+\t{\n+\t  /* If the two pointers have different ref-all attributes,\n+\t     they can't be the same type.  */\n+\t  if (TYPE_REF_CAN_ALIAS_ALL (t1) != TYPE_REF_CAN_ALIAS_ALL (t2))\n+\t    return false;\n+\n+\t  if (TYPE_ADDR_SPACE (TREE_TYPE (t1))\n+\t      != TYPE_ADDR_SPACE (TREE_TYPE (t2)))\n+\t    return false;\n+\n+\t  if (TYPE_RESTRICT (t1) != TYPE_RESTRICT (t2))\n+\t    return false;\n+\n+\t  if (TREE_CODE (TREE_TYPE (t1)) != TREE_CODE (TREE_TYPE (t2)))\n+\t    return false;\n+\t}\n+\n+      /* Tail-recurse to components.  */\n+      if (TREE_CODE (t1) == VECTOR_TYPE\n+\t  || TREE_CODE (t1) == COMPLEX_TYPE)\n+\treturn gimple_canonical_types_compatible_p (TREE_TYPE (t1),\n+\t\t\t\t\t\t    TREE_TYPE (t2));\n+\n+      return true;\n+    }\n+\n+  /* Do type-specific comparisons.  */\n+  switch (TREE_CODE (t1))\n+    {\n+    case ARRAY_TYPE:\n+      /* Array types are the same if the element types are the same and\n+\t the number of elements are the same.  */\n+      if (!gimple_canonical_types_compatible_p (TREE_TYPE (t1), TREE_TYPE (t2))\n+\t  || TYPE_STRING_FLAG (t1) != TYPE_STRING_FLAG (t2)\n+\t  || TYPE_NONALIASED_COMPONENT (t1) != TYPE_NONALIASED_COMPONENT (t2))\n+\treturn false;\n+      else\n+\t{\n+\t  tree i1 = TYPE_DOMAIN (t1);\n+\t  tree i2 = TYPE_DOMAIN (t2);\n+\n+\t  /* For an incomplete external array, the type domain can be\n+ \t     NULL_TREE.  Check this condition also.  */\n+\t  if (i1 == NULL_TREE && i2 == NULL_TREE)\n+\t    return true;\n+\t  else if (i1 == NULL_TREE || i2 == NULL_TREE)\n+\t    return false;\n+\t  else\n+\t    {\n+\t      tree min1 = TYPE_MIN_VALUE (i1);\n+\t      tree min2 = TYPE_MIN_VALUE (i2);\n+\t      tree max1 = TYPE_MAX_VALUE (i1);\n+\t      tree max2 = TYPE_MAX_VALUE (i2);\n+\n+\t      /* The minimum/maximum values have to be the same.  */\n+\t      if ((min1 == min2\n+\t\t   || (min1 && min2\n+\t\t       && ((TREE_CODE (min1) == PLACEHOLDER_EXPR\n+\t\t\t    && TREE_CODE (min2) == PLACEHOLDER_EXPR)\n+\t\t           || operand_equal_p (min1, min2, 0))))\n+\t\t  && (max1 == max2\n+\t\t      || (max1 && max2\n+\t\t\t  && ((TREE_CODE (max1) == PLACEHOLDER_EXPR\n+\t\t\t       && TREE_CODE (max2) == PLACEHOLDER_EXPR)\n+\t\t\t      || operand_equal_p (max1, max2, 0)))))\n+\t\treturn true;\n+\t      else\n+\t\treturn false;\n+\t    }\n+\t}\n+\n+    case METHOD_TYPE:\n+    case FUNCTION_TYPE:\n+      /* Function types are the same if the return type and arguments types\n+\t are the same.  */\n+      if (!gimple_canonical_types_compatible_p (TREE_TYPE (t1), TREE_TYPE (t2)))\n+\treturn false;\n+\n+      if (!comp_type_attributes (t1, t2))\n+\treturn false;\n+\n+      if (TYPE_ARG_TYPES (t1) == TYPE_ARG_TYPES (t2))\n+\treturn true;\n+      else\n+\t{\n+\t  tree parms1, parms2;\n+\n+\t  for (parms1 = TYPE_ARG_TYPES (t1), parms2 = TYPE_ARG_TYPES (t2);\n+\t       parms1 && parms2;\n+\t       parms1 = TREE_CHAIN (parms1), parms2 = TREE_CHAIN (parms2))\n+\t    {\n+\t      if (!gimple_canonical_types_compatible_p\n+\t\t     (TREE_VALUE (parms1), TREE_VALUE (parms2)))\n+\t\treturn false;\n+\t    }\n+\n+\t  if (parms1 || parms2)\n+\t    return false;\n+\n+\t  return true;\n+\t}\n+\n+    case RECORD_TYPE:\n+    case UNION_TYPE:\n+    case QUAL_UNION_TYPE:\n+      {\n+\ttree f1, f2;\n+\n+\t/* For aggregate types, all the fields must be the same.  */\n+\tfor (f1 = TYPE_FIELDS (t1), f2 = TYPE_FIELDS (t2);\n+\t     f1 || f2;\n+\t     f1 = TREE_CHAIN (f1), f2 = TREE_CHAIN (f2))\n+\t  {\n+\t    /* Skip non-fields.  */\n+\t    while (f1 && TREE_CODE (f1) != FIELD_DECL)\n+\t      f1 = TREE_CHAIN (f1);\n+\t    while (f2 && TREE_CODE (f2) != FIELD_DECL)\n+\t      f2 = TREE_CHAIN (f2);\n+\t    if (!f1 || !f2)\n+\t      break;\n+\t    /* The fields must have the same name, offset and type.  */\n+\t    if (DECL_NONADDRESSABLE_P (f1) != DECL_NONADDRESSABLE_P (f2)\n+\t\t|| !gimple_compare_field_offset (f1, f2)\n+\t\t|| !gimple_canonical_types_compatible_p\n+\t\t      (TREE_TYPE (f1), TREE_TYPE (f2)))\n+\t      return false;\n+\t  }\n+\n+\t/* If one aggregate has more fields than the other, they\n+\t   are not the same.  */\n+\tif (f1 || f2)\n+\t  return false;\n+\n+\treturn true;\n+      }\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+\n+\n+/* Returns nonzero if P1 and P2 are equal.  */\n+\n+static int\n+gimple_canonical_type_eq (const void *p1, const void *p2)\n+{\n+  const_tree t1 = (const_tree) p1;\n+  const_tree t2 = (const_tree) p2;\n+  return gimple_canonical_types_compatible_p (CONST_CAST_TREE (t1),\n+\t\t\t\t\t      CONST_CAST_TREE (t2));\n+}\n+\n+/* Register type T in the global type table gimple_types.\n+   If another type T', compatible with T, already existed in\n+   gimple_types then return T', otherwise return T.  This is used by\n+   LTO to merge identical types read from different TUs.\n+\n+   ???  This merging does not exactly match how the tree.c middle-end\n+   functions will assign TYPE_CANONICAL when new types are created\n+   during optimization (which at least happens for pointer and array\n+   types).  */\n+\n+static tree\n+gimple_register_canonical_type (tree t)\n+{\n+  void **slot;\n+\n+  gcc_assert (TYPE_P (t));\n+\n+  if (TYPE_CANONICAL (t))\n+    return TYPE_CANONICAL (t);\n+\n+  slot = htab_find_slot (gimple_canonical_types, t, INSERT);\n+  if (*slot\n+      && *(tree *)slot != t)\n+    {\n+      tree new_type = (tree) *((tree *) slot);\n+\n+      TYPE_CANONICAL (t) = new_type;\n+      t = new_type;\n+    }\n+  else\n+    {\n+      TYPE_CANONICAL (t) = t;\n+      *slot = (void *) t;\n+    }\n+\n+  return t;\n+}\n+\n+/* Re-compute TYPE_CANONICAL for NODE and related types.  */\n+\n+static void\n+lto_register_canonical_types (tree node)\n+{\n+  if (!node\n+      || !TYPE_P (node))\n+    return;\n+\n+  TYPE_CANONICAL (node) = NULL_TREE;\n+  TYPE_CANONICAL (node) = gimple_register_canonical_type (node);\n+\n+  if (POINTER_TYPE_P (node)\n+      || TREE_CODE (node) == COMPLEX_TYPE\n+      || TREE_CODE (node) == ARRAY_TYPE)\n+    lto_register_canonical_types (TREE_TYPE (node));\n+}\n+\n \n /* ???  Old hashing and merging code follows, we keep it for statistics\n    purposes for now.  */\n@@ -3398,13 +3819,28 @@ read_cgraph_and_symbols (unsigned nfiles, const char **fnames)\n     }\n   cgraph_state = CGRAPH_LTO_STREAMING;\n \n+  canonical_type_hash_cache = htab_create_ggc (512, tree_int_map_hash,\n+\t\t\t\t\t       tree_int_map_eq, NULL);\n+  gimple_canonical_types = htab_create_ggc (16381, gimple_canonical_type_hash,\n+\t\t\t\t\t    gimple_canonical_type_eq, 0);\n   type_hash_cache = htab_create_ggc (512, tree_int_map_hash,\n \t\t\t\t     tree_int_map_eq, NULL);\n   type_pair_cache = XCNEWVEC (struct type_pair_d, GIMPLE_TYPE_PAIR_SIZE);\n   gimple_types = htab_create_ggc (16381, gimple_type_hash, gimple_type_eq, 0);\n   gcc_obstack_init (&tree_scc_hash_obstack);\n   tree_scc_hash.create (4096);\n \n+  /* Register the common node types with the canonical type machinery so\n+     we properly share alias-sets across languages and TUs.  Do not\n+     expose the common nodes as type merge target - those that should be\n+     are already exposed so by pre-loading the LTO streamer caches.  */\n+  for (i = 0; i < itk_none; ++i)\n+    lto_register_canonical_types (integer_types[i]);\n+  /* The sizetypes are not used to access data so we do not need to\n+     do anything about them.  */\n+  for (i = 0; i < TI_MAX; ++i)\n+    lto_register_canonical_types (global_trees[i]);\n+\n   if (!quiet_flag)\n     fprintf (stderr, \"Reading object files:\");\n \n@@ -3459,7 +3895,10 @@ read_cgraph_and_symbols (unsigned nfiles, const char **fnames)\n   type_pair_cache = NULL;\n   tree_scc_hash.dispose ();\n   obstack_free (&tree_scc_hash_obstack, NULL);\n-  free_gimple_type_tables ();\n+  htab_delete (gimple_canonical_types);\n+  gimple_canonical_types = NULL;\n+  htab_delete (canonical_type_hash_cache);\n+  canonical_type_hash_cache = NULL;\n   ggc_collect ();\n \n   /* Set the hooks so that all of the ipa passes can read in their data.  */\n@@ -3663,9 +4102,22 @@ print_lto_report_1 (void)\n \t       pfx, num_not_merged_types, num_not_merged_types_in_same_scc,\n \t       num_not_merged_types_trees,\n \t       num_not_merged_types_in_same_scc_trees);\n+      fprintf (stderr, \"[%s] GIMPLE canonical type table: size %ld, \"\n+\t       \"%ld elements, %ld searches, %ld collisions (ratio: %f)\\n\", pfx,\n+\t       (long) htab_size (gimple_canonical_types),\n+\t       (long) htab_elements (gimple_canonical_types),\n+\t       (long) gimple_canonical_types->searches,\n+\t       (long) gimple_canonical_types->collisions,\n+\t       htab_collisions (gimple_canonical_types));\n+      fprintf (stderr, \"[%s] GIMPLE canonical type hash table: size %ld, \"\n+\t       \"%ld elements, %ld searches, %ld collisions (ratio: %f)\\n\", pfx,\n+\t       (long) htab_size (canonical_type_hash_cache),\n+\t       (long) htab_elements (canonical_type_hash_cache),\n+\t       (long) canonical_type_hash_cache->searches,\n+\t       (long) canonical_type_hash_cache->collisions,\n+\t       htab_collisions (canonical_type_hash_cache));\n     }\n \n-  print_gimple_types_stats (pfx);\n   print_lto_report (pfx);\n }\n "}]}