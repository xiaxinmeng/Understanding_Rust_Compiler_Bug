{"sha": "3b8dffe701e9a1f6641f3ff1f08899614ce38ae0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2I4ZGZmZTcwMWU5YTFmNjY0MWYzZmYxZjA4ODk5NjE0Y2UzOGFlMA==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "iant@google.com", "date": "2011-06-14T05:53:10Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2011-06-14T05:53:10Z"}, "message": "Change builtin make to runtime call at lowering time.\n\nUse kindNoPointers as 6g does.\n\n\t* Make-lang.in (go/expressions.o): Depend on $(GO_RUNTIME_H).\n\nFrom-SVN: r175008", "tree": {"sha": "075a60d271b289fa96fb47546b7be74d188590e1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/075a60d271b289fa96fb47546b7be74d188590e1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3b8dffe701e9a1f6641f3ff1f08899614ce38ae0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3b8dffe701e9a1f6641f3ff1f08899614ce38ae0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3b8dffe701e9a1f6641f3ff1f08899614ce38ae0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3b8dffe701e9a1f6641f3ff1f08899614ce38ae0/comments", "author": null, "committer": null, "parents": [{"sha": "8365a060e613196d31719832af2a4cb2b9886a30", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8365a060e613196d31719832af2a4cb2b9886a30", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8365a060e613196d31719832af2a4cb2b9886a30"}], "stats": {"total": 956, "additions": 318, "deletions": 638}, "files": [{"sha": "a5e56b14f689f2d7f791db22ed8d8af072c37b99", "filename": "gcc/go/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b8dffe701e9a1f6641f3ff1f08899614ce38ae0/gcc%2Fgo%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b8dffe701e9a1f6641f3ff1f08899614ce38ae0/gcc%2Fgo%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2FChangeLog?ref=3b8dffe701e9a1f6641f3ff1f08899614ce38ae0", "patch": "@@ -1,3 +1,7 @@\n+2011-06-13  Ian Lance Taylor  <iant@google.com>\n+\n+\t* Make-lang.in (go/expressions.o): Depend on $(GO_RUNTIME_H).\n+\n 2011-06-10  Ian Lance Taylor  <iant@google.com>\n \n \t* go-gcc.cc: Include \"toplev.h\"."}, {"sha": "51760bf510710da13de0710101467a680283b7b4", "filename": "gcc/go/Make-lang.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b8dffe701e9a1f6641f3ff1f08899614ce38ae0/gcc%2Fgo%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b8dffe701e9a1f6641f3ff1f08899614ce38ae0/gcc%2Fgo%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2FMake-lang.in?ref=3b8dffe701e9a1f6641f3ff1f08899614ce38ae0", "patch": "@@ -255,7 +255,7 @@ go/expressions.o: go/gofrontend/expressions.cc $(GO_SYSTEM_H) $(TOPLEV_H) \\\n \tintl.h $(TREE_H) $(GIMPLE_H) tree-iterator.h convert.h $(REAL_H) \\\n \trealmpfr.h $(GO_C_H) $(GO_GOGO_H) $(GO_TYPES_H) \\\n \tgo/gofrontend/export.h $(GO_IMPORT_H) $(GO_STATEMENTS_H) $(GO_LEX_H) \\\n-\tgo/gofrontend/backend.h $(GO_EXPRESSIONS_H)\n+\t$(GO_RUNTIME_H) go/gofrontend/backend.h $(GO_EXPRESSIONS_H)\n go/go.o: go/gofrontend/go.cc $(GO_SYSTEM_H) $(GO_C_H) $(GO_LEX_H) \\\n \t$(GO_PARSE_H) go/gofrontend/backend.h $(GO_GOGO_H)\n go/go-dump.o: go/gofrontend/go-dump.cc $(GO_SYSTEM_H) $(GO_C_H) \\"}, {"sha": "bd437c4ce4c8828a72323bcb0eab6d96cc3a9b2b", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 220, "deletions": 132, "changes": 352, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b8dffe701e9a1f6641f3ff1f08899614ce38ae0/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b8dffe701e9a1f6641f3ff1f08899614ce38ae0/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=3b8dffe701e9a1f6641f3ff1f08899614ce38ae0", "patch": "@@ -33,6 +33,7 @@ extern \"C\"\n #include \"import.h\"\n #include \"statements.h\"\n #include \"lex.h\"\n+#include \"runtime.h\"\n #include \"backend.h\"\n #include \"expressions.h\"\n \n@@ -3592,7 +3593,7 @@ class Unsafe_type_conversion_expression : public Expression\n \n   void\n   do_determine_type(const Type_context*)\n-  { }\n+  { this->expr_->determine_type_no_context(); }\n \n   Expression*\n   do_copy()\n@@ -6739,6 +6740,12 @@ class Builtin_call_expression : public Call_expression\n   static Type*\n   complex_type(Type*);\n \n+  Expression*\n+  lower_make();\n+\n+  bool\n+  check_int_value(Expression*);\n+\n   // A pointer back to the general IR structure.  This avoids a global\n   // variable, or passing it around everywhere.\n   Gogo* gogo_;\n@@ -6859,6 +6866,9 @@ Find_call_expression::expression(Expression** pexpr)\n Expression*\n Builtin_call_expression::do_lower(Gogo* gogo, Named_object* function, int)\n {\n+  if (this->classification() == EXPRESSION_ERROR)\n+    return this;\n+\n   if (this->is_varargs() && this->code_ != BUILTIN_APPEND)\n     {\n       this->report_error(_(\"invalid use of %<...%> with builtin function\"));\n@@ -6885,36 +6895,7 @@ Builtin_call_expression::do_lower(Gogo* gogo, Named_object* function, int)\n \t}\n     }\n   else if (this->code_ == BUILTIN_MAKE)\n-    {\n-      const Expression_list* args = this->args();\n-      if (args == NULL || args->size() < 1)\n-\tthis->report_error(_(\"not enough arguments\"));\n-      else\n-\t{\n-\t  Expression* arg = args->front();\n-\t  if (!arg->is_type_expression())\n-\t    {\n-\t      error_at(arg->location(), \"expected type\");\n-\t      this->set_is_error();\n-\t    }\n-\t  else\n-\t    {\n-\t      Expression_list* newargs;\n-\t      if (args->size() == 1)\n-\t\tnewargs = NULL;\n-\t      else\n-\t\t{\n-\t\t  newargs = new Expression_list();\n-\t\t  Expression_list::const_iterator p = args->begin();\n-\t\t  ++p;\n-\t\t  for (; p != args->end(); ++p)\n-\t\t    newargs->push_back(*p);\n-\t\t}\n-\t      return Expression::make_make(arg->type(), newargs,\n-\t\t\t\t\t   this->location());\n-\t    }\n-\t}\n-    }\n+    return this->lower_make();\n   else if (this->is_constant())\n     {\n       // We can only lower len and cap if there are no function calls\n@@ -6999,6 +6980,170 @@ Builtin_call_expression::do_lower(Gogo* gogo, Named_object* function, int)\n   return this;\n }\n \n+// Lower a make expression.\n+\n+Expression*\n+Builtin_call_expression::lower_make()\n+{\n+  source_location loc = this->location();\n+\n+  const Expression_list* args = this->args();\n+  if (args == NULL || args->size() < 1)\n+    {\n+      this->report_error(_(\"not enough arguments\"));\n+      return Expression::make_error(this->location());\n+    }\n+\n+  Expression_list::const_iterator parg = args->begin();\n+\n+  Expression* first_arg = *parg;\n+  if (!first_arg->is_type_expression())\n+    {\n+      error_at(first_arg->location(), \"expected type\");\n+      this->set_is_error();\n+      return Expression::make_error(this->location());\n+    }\n+  Type* type = first_arg->type();\n+\n+  bool is_slice = false;\n+  bool is_map = false;\n+  bool is_chan = false;\n+  if (type->is_open_array_type())\n+    is_slice = true;\n+  else if (type->map_type() != NULL)\n+    is_map = true;\n+  else if (type->channel_type() != NULL)\n+    is_chan = true;\n+  else\n+    {\n+      this->report_error(_(\"invalid type for make function\"));\n+      return Expression::make_error(this->location());\n+    }\n+\n+  ++parg;\n+  Expression* len_arg;\n+  if (parg == args->end())\n+    {\n+      if (is_slice)\n+\t{\n+\t  this->report_error(_(\"length required when allocating a slice\"));\n+\t  return Expression::make_error(this->location());\n+\t}\n+\n+      mpz_t zval;\n+      mpz_init_set_ui(zval, 0);\n+      len_arg = Expression::make_integer(&zval, NULL, loc);\n+      mpz_clear(zval);\n+    }\n+  else\n+    {\n+      len_arg = *parg;\n+      if (!this->check_int_value(len_arg))\n+\t{\n+\t  this->report_error(_(\"bad size for make\"));\n+\t  return Expression::make_error(this->location());\n+\t}\n+      ++parg;\n+    }\n+\n+  Expression* cap_arg = NULL;\n+  if (is_slice && parg != args->end())\n+    {\n+      cap_arg = *parg;\n+      if (!this->check_int_value(cap_arg))\n+\t{\n+\t  this->report_error(_(\"bad capacity when making slice\"));\n+\t  return Expression::make_error(this->location());\n+\t}\n+      ++parg;\n+    }\n+\n+  if (parg != args->end())\n+    {\n+      this->report_error(_(\"too many arguments to make\"));\n+      return Expression::make_error(this->location());\n+    }\n+\n+  source_location type_loc = first_arg->location();\n+  Expression* type_arg;\n+  if (is_slice || is_chan)\n+    type_arg = Expression::make_type_descriptor(type, type_loc);\n+  else if (is_map)\n+    type_arg = Expression::make_map_descriptor(type->map_type(), type_loc);\n+  else\n+    go_unreachable();\n+\n+  Expression* call;\n+  if (is_slice)\n+    {\n+      if (cap_arg == NULL)\n+\tcall = Runtime::make_call(Runtime::MAKESLICE1, loc, 2, type_arg,\n+\t\t\t\t  len_arg);\n+      else\n+\tcall = Runtime::make_call(Runtime::MAKESLICE2, loc, 3, type_arg,\n+\t\t\t\t  len_arg, cap_arg);\n+    }\n+  else if (is_map)\n+    call = Runtime::make_call(Runtime::MAKEMAP, loc, 2, type_arg, len_arg);\n+  else if (is_chan)\n+    call = Runtime::make_call(Runtime::MAKECHAN, loc, 2, type_arg, len_arg);\n+  else\n+    go_unreachable();\n+\n+  return Expression::make_unsafe_cast(type, call, loc);\n+}\n+\n+// Return whether an expression has an integer value.  Report an error\n+// if not.  This is used when handling calls to the predeclared make\n+// function.\n+\n+bool\n+Builtin_call_expression::check_int_value(Expression* e)\n+{\n+  if (e->type()->integer_type() != NULL)\n+    return true;\n+\n+  // Check for a floating point constant with integer value.\n+  mpfr_t fval;\n+  mpfr_init(fval);\n+\n+  Type* dummy;\n+  if (e->float_constant_value(fval, &dummy) && mpfr_integer_p(fval))\n+    {\n+      mpz_t ival;\n+      mpz_init(ival);\n+\n+      bool ok = false;\n+\n+      mpfr_clear_overflow();\n+      mpfr_clear_erangeflag();\n+      mpfr_get_z(ival, fval, GMP_RNDN);\n+      if (!mpfr_overflow_p()\n+\t  && !mpfr_erangeflag_p()\n+\t  && mpz_sgn(ival) >= 0)\n+\t{\n+\t  Named_type* ntype = Type::lookup_integer_type(\"int\");\n+\t  Integer_type* inttype = ntype->integer_type();\n+\t  mpz_t max;\n+\t  mpz_init_set_ui(max, 1);\n+\t  mpz_mul_2exp(max, max, inttype->bits() - 1);\n+\t  ok = mpz_cmp(ival, max) < 0;\n+\t  mpz_clear(max);\n+\t}\n+      mpz_clear(ival);\n+\n+      if (ok)\n+\t{\n+\t  mpfr_clear(fval);\n+\t  return true;\n+\t}\n+    }\n+\n+  mpfr_clear(fval);\n+\n+  return false;\n+}\n+\n // Return the type of the real or imag functions, given the type of\n // the argument.  We need to map complex to float, complex64 to\n // float32, and complex128 to float64, so it has to be done by name.\n@@ -10684,107 +10829,6 @@ Expression::make_allocation(Type* type, source_location location)\n   return new Allocation_expression(type, location);\n }\n \n-// Implement the builtin function make.\n-\n-class Make_expression : public Expression\n-{\n- public:\n-  Make_expression(Type* type, Expression_list* args, source_location location)\n-    : Expression(EXPRESSION_MAKE, location),\n-      type_(type), args_(args)\n-  { }\n-\n- protected:\n-  int\n-  do_traverse(Traverse* traverse);\n-\n-  Type*\n-  do_type()\n-  { return this->type_; }\n-\n-  void\n-  do_determine_type(const Type_context*);\n-\n-  void\n-  do_check_types(Gogo*);\n-\n-  Expression*\n-  do_copy()\n-  {\n-    return new Make_expression(this->type_, this->args_->copy(),\n-\t\t\t       this->location());\n-  }\n-\n-  tree\n-  do_get_tree(Translate_context*);\n-\n- private:\n-  // The type we are making.\n-  Type* type_;\n-  // The arguments to pass to the make routine.\n-  Expression_list* args_;\n-};\n-\n-// Traversal.\n-\n-int\n-Make_expression::do_traverse(Traverse* traverse)\n-{\n-  if (this->args_ != NULL\n-      && this->args_->traverse(traverse) == TRAVERSE_EXIT)\n-    return TRAVERSE_EXIT;\n-  if (Type::traverse(this->type_, traverse) == TRAVERSE_EXIT)\n-    return TRAVERSE_EXIT;\n-  return TRAVERSE_CONTINUE;\n-}\n-\n-// Set types of arguments.\n-\n-void\n-Make_expression::do_determine_type(const Type_context*)\n-{\n-  if (this->args_ != NULL)\n-    {\n-      Type_context context(Type::lookup_integer_type(\"int\"), false);\n-      for (Expression_list::const_iterator pe = this->args_->begin();\n-\t   pe != this->args_->end();\n-\t   ++pe)\n-\t(*pe)->determine_type(&context);\n-    }\n-}\n-\n-// Check types for a make expression.\n-\n-void\n-Make_expression::do_check_types(Gogo*)\n-{\n-  if (this->type_->channel_type() == NULL\n-      && this->type_->map_type() == NULL\n-      && (this->type_->array_type() == NULL\n-\t  || this->type_->array_type()->length() != NULL))\n-    this->report_error(_(\"invalid type for make function\"));\n-  else if (!this->type_->check_make_expression(this->args_, this->location()))\n-    this->set_is_error();\n-}\n-\n-// Return a tree for a make expression.\n-\n-tree\n-Make_expression::do_get_tree(Translate_context* context)\n-{\n-  return this->type_->make_expression_tree(context, this->args_,\n-\t\t\t\t\t   this->location());\n-}\n-\n-// Make a make expression.\n-\n-Expression*\n-Expression::make_make(Type* type, Expression_list* args,\n-\t\t      source_location location)\n-{\n-  return new Make_expression(type, args, location);\n-}\n-\n // Construct a struct.\n \n class Struct_construction_expression : public Expression\n@@ -12771,6 +12815,50 @@ Expression::make_struct_field_offset(Struct_type* type,\n   return new Struct_field_offset_expression(type, field);\n }\n \n+// An expression which evaluates to a pointer to the map descriptor of\n+// a map type.\n+\n+class Map_descriptor_expression : public Expression\n+{\n+ public:\n+  Map_descriptor_expression(Map_type* type, source_location location)\n+    : Expression(EXPRESSION_MAP_DESCRIPTOR, location),\n+      type_(type)\n+  { }\n+\n+ protected:\n+  Type*\n+  do_type()\n+  { return Type::make_pointer_type(Map_type::make_map_descriptor_type()); }\n+\n+  void\n+  do_determine_type(const Type_context*)\n+  { }\n+\n+  Expression*\n+  do_copy()\n+  { return this; }\n+\n+  tree\n+  do_get_tree(Translate_context* context)\n+  {\n+    return this->type_->map_descriptor_pointer(context->gogo(),\n+\t\t\t\t\t       this->location());\n+  }\n+\n+ private:\n+  // The type for which this is the descriptor.\n+  Map_type* type_;\n+};\n+\n+// Make a map descriptor expression.\n+\n+Expression*\n+Expression::make_map_descriptor(Map_type* type, source_location location)\n+{\n+  return new Map_descriptor_expression(type, location);\n+}\n+\n // An expression which evaluates to the address of an unnamed label.\n \n class Label_addr_expression : public Expression"}, {"sha": "271b1bbbe36e0a41679b5863eb62a807737580dd", "filename": "gcc/go/gofrontend/expressions.h", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b8dffe701e9a1f6641f3ff1f08899614ce38ae0/gcc%2Fgo%2Fgofrontend%2Fexpressions.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b8dffe701e9a1f6641f3ff1f08899614ce38ae0/gcc%2Fgo%2Fgofrontend%2Fexpressions.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.h?ref=3b8dffe701e9a1f6641f3ff1f08899614ce38ae0", "patch": "@@ -78,7 +78,6 @@ class Expression\n     EXPRESSION_FIELD_REFERENCE,\n     EXPRESSION_INTERFACE_FIELD_REFERENCE,\n     EXPRESSION_ALLOCATION,\n-    EXPRESSION_MAKE,\n     EXPRESSION_TYPE_GUARD,\n     EXPRESSION_CONVERSION,\n     EXPRESSION_UNSAFE_CONVERSION,\n@@ -92,6 +91,7 @@ class Expression\n     EXPRESSION_TYPE_DESCRIPTOR,\n     EXPRESSION_TYPE_INFO,\n     EXPRESSION_STRUCT_FIELD_OFFSET,\n+    EXPRESSION_MAP_DESCRIPTOR,\n     EXPRESSION_LABEL_ADDR\n   };\n \n@@ -236,10 +236,6 @@ class Expression\n   static Expression*\n   make_allocation(Type*, source_location);\n \n-  // Make a call to the builtin function make.\n-  static Expression*\n-  make_make(Type*, Expression_list*, source_location);\n-\n   // Make a type guard expression.\n   static Expression*\n   make_type_guard(Expression*, Type*, source_location);\n@@ -276,8 +272,8 @@ class Expression\n   static Receive_expression*\n   make_receive(Expression* channel, source_location);\n \n-  // Make an expression which evaluates to the type descriptor of a\n-  // type.\n+  // Make an expression which evaluates to the address of the type\n+  // descriptor for TYPE.\n   static Expression*\n   make_type_descriptor(Type* type, source_location);\n \n@@ -304,6 +300,11 @@ class Expression\n   static Expression*\n   make_struct_field_offset(Struct_type*, const Struct_field*);\n \n+  // Make an expression which evaluates to the address of the map\n+  // descriptor for TYPE.\n+  static Expression*\n+  make_map_descriptor(Map_type* type, source_location);\n+\n   // Make an expression which evaluates to the address of an unnamed\n   // label.\n   static Expression*"}, {"sha": "2ecfbf5b15508e07f79a57b45b8be2b7dc9261fa", "filename": "gcc/go/gofrontend/runtime.cc", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b8dffe701e9a1f6641f3ff1f08899614ce38ae0/gcc%2Fgo%2Fgofrontend%2Fruntime.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b8dffe701e9a1f6641f3ff1f08899614ce38ae0/gcc%2Fgo%2Fgofrontend%2Fruntime.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fruntime.cc?ref=3b8dffe701e9a1f6641f3ff1f08899614ce38ae0", "patch": "@@ -64,6 +64,8 @@ enum Runtime_function_type\n   RFT_FUNC_PTR,\n   // Pointer to Go type descriptor.\n   RFT_TYPE,\n+  // Pointer to map descriptor.\n+  RFT_MAPDESCRIPTOR,\n \n   NUMBER_OF_RUNTIME_FUNCTION_TYPES\n };\n@@ -175,6 +177,10 @@ runtime_function_type(Runtime_function_type bft)\n \tcase RFT_TYPE:\n \t  t = Type::make_type_descriptor_ptr_type();\n \t  break;\n+\n+\tcase RFT_MAPDESCRIPTOR:\n+\t  t = Type::make_pointer_type(Map_type::make_map_descriptor_type());\n+\t  break;\n \t}\n \n       runtime_function_types[bft] = t;\n@@ -225,6 +231,11 @@ convert_to_runtime_function_type(Runtime_function_type bft, Expression* e,\n     case RFT_TYPE:\n       go_assert(e->type() == Type::make_type_descriptor_ptr_type());\n       return e;\n+\n+    case RFT_MAPDESCRIPTOR:\n+      go_assert(e->type()->points_to()\n+\t\t== Map_type::make_map_descriptor_type());\n+      return e;\n     }\n }\n "}, {"sha": "219ccb8bd9021c734bb0e9f30f14727323e48386", "filename": "gcc/go/gofrontend/runtime.def", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b8dffe701e9a1f6641f3ff1f08899614ce38ae0/gcc%2Fgo%2Fgofrontend%2Fruntime.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b8dffe701e9a1f6641f3ff1f08899614ce38ae0/gcc%2Fgo%2Fgofrontend%2Fruntime.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fruntime.def?ref=3b8dffe701e9a1f6641f3ff1f08899614ce38ae0", "patch": "@@ -65,8 +65,14 @@ DEF_GO_RUNTIME(STRING_TO_INT_ARRAY, \"__go_string_to_int_array\",\n \t       P1(STRING), R1(SLICE))\n \n \n+// Make a slice.\n+DEF_GO_RUNTIME(MAKESLICE1, \"__go_make_slice1\", P2(TYPE, UINTPTR), R1(SLICE))\n+DEF_GO_RUNTIME(MAKESLICE2, \"__go_make_slice2\", P3(TYPE, UINTPTR, UINTPTR),\n+\t       R1(SLICE))\n+\n+\n // Make a map.\n-DEF_GO_RUNTIME(NEW_MAP, \"__go_new_map\", P2(TYPE, UINTPTR), R1(MAP))\n+DEF_GO_RUNTIME(MAKEMAP, \"__go_new_map\", P2(MAPDESCRIPTOR, UINTPTR), R1(MAP))\n \n // Build a map from a composite literal.\n DEF_GO_RUNTIME(CONSTRUCT_MAP, \"__go_construct_map\",\n@@ -103,7 +109,7 @@ DEF_GO_RUNTIME(MAPITERNEXT, \"runtime.mapiternext\", P1(MAPITER), R0())\n \n \n // Make a channel.\n-DEF_GO_RUNTIME(NEW_CHANNEL, \"__go_new_channel\", P2(UINTPTR, UINTPTR), R1(CHAN))\n+DEF_GO_RUNTIME(MAKECHAN, \"__go_new_channel\", P2(TYPE, UINTPTR), R1(CHAN))\n \n // Get the length of a channel (the number of unread values).\n DEF_GO_RUNTIME(CHAN_LEN, \"__go_chan_len\", P1(CHAN), R1(INT))"}, {"sha": "4b2ceeb4560aedd5b2398f2b63d51b9e919538d0", "filename": "gcc/go/gofrontend/types.cc", "status": "modified", "additions": 2, "deletions": 393, "changes": 395, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b8dffe701e9a1f6641f3ff1f08899614ce38ae0/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b8dffe701e9a1f6641f3ff1f08899614ce38ae0/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.cc?ref=3b8dffe701e9a1f6641f3ff1f08899614ce38ae0", "patch": "@@ -768,68 +768,6 @@ Type::hash_string(const std::string& s, unsigned int h)\n   return h;\n }\n \n-// Default check for the expression passed to make.  Any type which\n-// may be used with make implements its own version of this.\n-\n-bool\n-Type::do_check_make_expression(Expression_list*, source_location)\n-{\n-  go_unreachable();\n-}\n-\n-// Return whether an expression has an integer value.  Report an error\n-// if not.  This is used when handling calls to the predeclared make\n-// function.\n-\n-bool\n-Type::check_int_value(Expression* e, const char* errmsg,\n-\t\t      source_location location)\n-{\n-  if (e->type()->integer_type() != NULL)\n-    return true;\n-\n-  // Check for a floating point constant with integer value.\n-  mpfr_t fval;\n-  mpfr_init(fval);\n-\n-  Type* dummy;\n-  if (e->float_constant_value(fval, &dummy) && mpfr_integer_p(fval))\n-    {\n-      mpz_t ival;\n-      mpz_init(ival);\n-\n-      bool ok = false;\n-\n-      mpfr_clear_overflow();\n-      mpfr_clear_erangeflag();\n-      mpfr_get_z(ival, fval, GMP_RNDN);\n-      if (!mpfr_overflow_p()\n-\t  && !mpfr_erangeflag_p()\n-\t  && mpz_sgn(ival) >= 0)\n-\t{\n-\t  Named_type* ntype = Type::lookup_integer_type(\"int\");\n-\t  Integer_type* inttype = ntype->integer_type();\n-\t  mpz_t max;\n-\t  mpz_init_set_ui(max, 1);\n-\t  mpz_mul_2exp(max, max, inttype->bits() - 1);\n-\t  ok = mpz_cmp(ival, max) < 0;\n-\t  mpz_clear(max);\n-\t}\n-      mpz_clear(ival);\n-\n-      if (ok)\n-\t{\n-\t  mpfr_clear(fval);\n-\t  return true;\n-\t}\n-    }\n-\n-  mpfr_clear(fval);\n-\n-  error_at(location, \"%s\", errmsg);\n-  return false;\n-}\n-\n // A hash table mapping unnamed types to the backend representation of\n // those types.\n \n@@ -912,16 +850,6 @@ Type::get_btype_without_hash(Gogo* gogo)\n   return this->btype_;\n }\n \n-// Any type which supports the builtin make function must implement\n-// this.\n-\n-tree\n-Type::do_make_expression_tree(Translate_context*, Expression_list*,\n-\t\t\t      source_location)\n-{\n-  go_unreachable();\n-}\n-\n // Return a pointer to the type descriptor for this type.\n \n tree\n@@ -1366,6 +1294,8 @@ Type::type_descriptor_constructor(Gogo* gogo, int runtime_type_kind,\n   Expression_list* vals = new Expression_list();\n   vals->reserve(9);\n \n+  if (!this->has_pointer())\n+    runtime_type_kind |= RUNTIME_TYPE_KIND_NO_POINTERS;\n   Struct_field_list::const_iterator p = fields->begin();\n   go_assert(p->field_name() == \"Kind\");\n   mpz_t iv;\n@@ -4341,43 +4271,6 @@ Array_type::do_hash_for_method(Gogo* gogo) const\n   return this->element_type_->hash_for_method(gogo) + 1;\n }\n \n-// See if the expression passed to make is suitable.  The first\n-// argument is required, and gives the length.  An optional second\n-// argument is permitted for the capacity.\n-\n-bool\n-Array_type::do_check_make_expression(Expression_list* args,\n-\t\t\t\t     source_location location)\n-{\n-  go_assert(this->length_ == NULL);\n-  if (args == NULL || args->empty())\n-    {\n-      error_at(location, \"length required when allocating a slice\");\n-      return false;\n-    }\n-  else if (args->size() > 2)\n-    {\n-      error_at(location, \"too many expressions passed to make\");\n-      return false;\n-    }\n-  else\n-    {\n-      if (!Type::check_int_value(args->front(),\n-\t\t\t\t _(\"bad length when making slice\"), location))\n-\treturn false;\n-\n-      if (args->size() > 1)\n-\t{\n-\t  if (!Type::check_int_value(args->back(),\n-\t\t\t\t     _(\"bad capacity when making slice\"),\n-\t\t\t\t     location))\n-\t    return false;\n-\t}\n-\n-      return true;\n-    }\n-}\n-\n // Get a tree for the length of a fixed array.  The length may be\n // computed using a function call, so we must only evaluate it once.\n \n@@ -4491,129 +4384,6 @@ Array_type::get_backend_length(Gogo* gogo)\n   return tree_to_expr(this->get_length_tree(gogo));\n }\n \n-// Handle the builtin make function for a slice.\n-\n-tree\n-Array_type::do_make_expression_tree(Translate_context* context,\n-\t\t\t\t    Expression_list* args,\n-\t\t\t\t    source_location location)\n-{\n-  go_assert(this->length_ == NULL);\n-\n-  Gogo* gogo = context->gogo();\n-  tree type_tree = type_to_tree(this->get_backend(gogo));\n-  if (type_tree == error_mark_node)\n-    return error_mark_node;\n-\n-  tree values_field = TYPE_FIELDS(type_tree);\n-  go_assert(strcmp(IDENTIFIER_POINTER(DECL_NAME(values_field)),\n-\t\t    \"__values\") == 0);\n-\n-  tree count_field = DECL_CHAIN(values_field);\n-  go_assert(strcmp(IDENTIFIER_POINTER(DECL_NAME(count_field)),\n-\t\t    \"__count\") == 0);\n-\n-  tree element_type_tree = type_to_tree(this->element_type_->get_backend(gogo));\n-  if (element_type_tree == error_mark_node)\n-    return error_mark_node;\n-  tree element_size_tree = TYPE_SIZE_UNIT(element_type_tree);\n-\n-  // The first argument is the number of elements, the optional second\n-  // argument is the capacity.\n-  go_assert(args != NULL && args->size() >= 1 && args->size() <= 2);\n-\n-  tree length_tree = args->front()->get_tree(context);\n-  if (length_tree == error_mark_node)\n-    return error_mark_node;\n-  if (!DECL_P(length_tree))\n-    length_tree = save_expr(length_tree);\n-  if (!INTEGRAL_TYPE_P(TREE_TYPE(length_tree)))\n-    length_tree = convert_to_integer(TREE_TYPE(count_field), length_tree);\n-\n-  tree bad_index = Expression::check_bounds(length_tree,\n-\t\t\t\t\t    TREE_TYPE(count_field),\n-\t\t\t\t\t    NULL_TREE, location);\n-\n-  length_tree = fold_convert_loc(location, TREE_TYPE(count_field), length_tree);\n-  tree capacity_tree;\n-  if (args->size() == 1)\n-    capacity_tree = length_tree;\n-  else\n-    {\n-      capacity_tree = args->back()->get_tree(context);\n-      if (capacity_tree == error_mark_node)\n-\treturn error_mark_node;\n-      if (!DECL_P(capacity_tree))\n-\tcapacity_tree = save_expr(capacity_tree);\n-      if (!INTEGRAL_TYPE_P(TREE_TYPE(capacity_tree)))\n-\tcapacity_tree = convert_to_integer(TREE_TYPE(count_field),\n-\t\t\t\t\t   capacity_tree);\n-\n-      bad_index = Expression::check_bounds(capacity_tree,\n-\t\t\t\t\t   TREE_TYPE(count_field),\n-\t\t\t\t\t   bad_index, location);\n-\n-      tree chktype = (((TYPE_SIZE(TREE_TYPE(capacity_tree))\n-\t\t\t> TYPE_SIZE(TREE_TYPE(length_tree)))\n-\t\t       || ((TYPE_SIZE(TREE_TYPE(capacity_tree))\n-\t\t\t    == TYPE_SIZE(TREE_TYPE(length_tree)))\n-\t\t\t   && TYPE_UNSIGNED(TREE_TYPE(capacity_tree))))\n-\t\t      ? TREE_TYPE(capacity_tree)\n-\t\t      : TREE_TYPE(length_tree));\n-      tree chk = fold_build2_loc(location, LT_EXPR, boolean_type_node,\n-\t\t\t\t fold_convert_loc(location, chktype,\n-\t\t\t\t\t\t  capacity_tree),\n-\t\t\t\t fold_convert_loc(location, chktype,\n-\t\t\t\t\t\t  length_tree));\n-      if (bad_index == NULL_TREE)\n-\tbad_index = chk;\n-      else\n-\tbad_index = fold_build2_loc(location, TRUTH_OR_EXPR, boolean_type_node,\n-\t\t\t\t    bad_index, chk);\n-\n-      capacity_tree = fold_convert_loc(location, TREE_TYPE(count_field),\n-\t\t\t\t       capacity_tree);\n-    }\n-\n-  tree size_tree = fold_build2_loc(location, MULT_EXPR, sizetype,\n-\t\t\t\t   element_size_tree,\n-\t\t\t\t   fold_convert_loc(location, sizetype,\n-\t\t\t\t\t\t    capacity_tree));\n-\n-  tree chk = fold_build2_loc(location, TRUTH_AND_EXPR, boolean_type_node,\n-\t\t\t     fold_build2_loc(location, GT_EXPR,\n-\t\t\t\t\t     boolean_type_node,\n-\t\t\t\t\t     fold_convert_loc(location,\n-\t\t\t\t\t\t\t      sizetype,\n-\t\t\t\t\t\t\t      capacity_tree),\n-\t\t\t\t\t     size_zero_node),\n-\t\t\t     fold_build2_loc(location, LT_EXPR,\n-\t\t\t\t\t     boolean_type_node,\n-\t\t\t\t\t     size_tree, element_size_tree));\n-  if (bad_index == NULL_TREE)\n-    bad_index = chk;\n-  else\n-    bad_index = fold_build2_loc(location, TRUTH_OR_EXPR, boolean_type_node,\n-\t\t\t\tbad_index, chk);\n-\n-  tree space = context->gogo()->allocate_memory(this->element_type_,\n-\t\t\t\t\t\tsize_tree, location);\n-\n-  space = fold_convert(TREE_TYPE(values_field), space);\n-\n-  if (bad_index != NULL_TREE && bad_index != boolean_false_node)\n-    {\n-      tree crash = Gogo::runtime_error(RUNTIME_ERROR_MAKE_SLICE_OUT_OF_BOUNDS,\n-\t\t\t\t       location);\n-      space = build2(COMPOUND_EXPR, TREE_TYPE(space),\n-\t\t     build3(COND_EXPR, void_type_node,\n-\t\t\t    bad_index, crash, NULL_TREE),\n-\t\t     space);\n-    }\n-\n-  return gogo->slice_constructor(type_tree, space, length_tree, capacity_tree);\n-}\n-\n // Return a tree for a pointer to the values in ARRAY.\n \n tree\n@@ -4962,28 +4732,6 @@ Map_type::do_hash_for_method(Gogo* gogo) const\n \t  + 2);\n }\n \n-// Check that a call to the builtin make function is valid.  For a map\n-// the optional argument is the number of spaces to preallocate for\n-// values.\n-\n-bool\n-Map_type::do_check_make_expression(Expression_list* args,\n-\t\t\t\t   source_location location)\n-{\n-  if (args != NULL && !args->empty())\n-    {\n-      if (!Type::check_int_value(args->front(), _(\"bad size when making map\"),\n-\t\t\t\t location))\n-\treturn false;\n-      else if (args->size() > 1)\n-\t{\n-\t  error_at(location, \"too many arguments when making map\");\n-\t  return false;\n-\t}\n-    }\n-  return true;\n-}\n-\n // Get the backend representation for a map type.  A map type is\n // represented as a pointer to a struct.  The struct is __go_map in\n // libgo/map.h.\n@@ -5024,62 +4772,6 @@ Map_type::do_get_backend(Gogo* gogo)\n   return backend_map_type;\n }\n \n-// Return an expression for a newly allocated map.\n-\n-tree\n-Map_type::do_make_expression_tree(Translate_context* context,\n-\t\t\t\t  Expression_list* args,\n-\t\t\t\t  source_location location)\n-{\n-  tree bad_index = NULL_TREE;\n-\n-  tree expr_tree;\n-  if (args == NULL || args->empty())\n-    expr_tree = size_zero_node;\n-  else\n-    {\n-      expr_tree = args->front()->get_tree(context);\n-      if (expr_tree == error_mark_node)\n-\treturn error_mark_node;\n-      if (!DECL_P(expr_tree))\n-\texpr_tree = save_expr(expr_tree);\n-      if (!INTEGRAL_TYPE_P(TREE_TYPE(expr_tree)))\n-\texpr_tree = convert_to_integer(sizetype, expr_tree);\n-      bad_index = Expression::check_bounds(expr_tree, sizetype, bad_index,\n-\t\t\t\t\t   location);\n-    }\n-\n-  Gogo* gogo = context->gogo();\n-  tree map_type = type_to_tree(this->get_backend(gogo));\n-\n-  static tree new_map_fndecl;\n-  tree ret = Gogo::call_builtin(&new_map_fndecl,\n-\t\t\t\tlocation,\n-\t\t\t\t\"__go_new_map\",\n-\t\t\t\t2,\n-\t\t\t\tmap_type,\n-\t\t\t\tTREE_TYPE(TYPE_FIELDS(TREE_TYPE(map_type))),\n-\t\t\t\tthis->map_descriptor_pointer(gogo, location),\n-\t\t\t\tsizetype,\n-\t\t\t\texpr_tree);\n-  if (ret == error_mark_node)\n-    return error_mark_node;\n-  // This can panic if the capacity is out of range.\n-  TREE_NOTHROW(new_map_fndecl) = 0;\n-\n-  if (bad_index == NULL_TREE)\n-    return ret;\n-  else\n-    {\n-      tree crash = Gogo::runtime_error(RUNTIME_ERROR_MAKE_MAP_OUT_OF_BOUNDS,\n-\t\t\t\t       location);\n-      return build2(COMPOUND_EXPR, TREE_TYPE(ret),\n-\t\t    build3(COND_EXPR, void_type_node,\n-\t\t\t   bad_index, crash, NULL_TREE),\n-\t\t    ret);\n-    }\n-}\n-\n // The type of a map type descriptor.\n \n Type*\n@@ -5343,29 +5035,6 @@ Channel_type::is_identical(const Channel_type* t,\n \t  && this->may_receive_ == t->may_receive_);\n }\n \n-// Check whether the parameters for a call to the builtin function\n-// make are OK for a channel.  A channel can take an optional single\n-// parameter which is the buffer size.\n-\n-bool\n-Channel_type::do_check_make_expression(Expression_list* args,\n-\t\t\t\t      source_location location)\n-{\n-  if (args != NULL && !args->empty())\n-    {\n-      if (!Type::check_int_value(args->front(),\n-\t\t\t\t _(\"bad buffer size when making channel\"),\n-\t\t\t\t location))\n-\treturn false;\n-      else if (args->size() > 1)\n-\t{\n-\t  error_at(location, \"too many arguments when making channel\");\n-\t  return false;\n-\t}\n-    }\n-  return true;\n-}\n-\n // Return the tree for a channel type.  A channel is a pointer to a\n // __go_channel struct.  The __go_channel struct is defined in\n // libgo/runtime/channel.h.\n@@ -5384,66 +5053,6 @@ Channel_type::do_get_backend(Gogo* gogo)\n   return backend_channel_type;\n }\n \n-// Handle the builtin function make for a channel.\n-\n-tree\n-Channel_type::do_make_expression_tree(Translate_context* context,\n-\t\t\t\t      Expression_list* args,\n-\t\t\t\t      source_location location)\n-{\n-  Gogo* gogo = context->gogo();\n-  tree channel_type = type_to_tree(this->get_backend(gogo));\n-\n-  Type* ptdt = Type::make_type_descriptor_ptr_type();\n-  tree element_type_descriptor =\n-    this->element_type_->type_descriptor_pointer(gogo, location);\n-\n-  tree bad_index = NULL_TREE;\n-\n-  tree expr_tree;\n-  if (args == NULL || args->empty())\n-    expr_tree = size_zero_node;\n-  else\n-    {\n-      expr_tree = args->front()->get_tree(context);\n-      if (expr_tree == error_mark_node)\n-\treturn error_mark_node;\n-      if (!DECL_P(expr_tree))\n-\texpr_tree = save_expr(expr_tree);\n-      if (!INTEGRAL_TYPE_P(TREE_TYPE(expr_tree)))\n-\texpr_tree = convert_to_integer(sizetype, expr_tree);\n-      bad_index = Expression::check_bounds(expr_tree, sizetype, bad_index,\n-\t\t\t\t\t   location);\n-    }\n-\n-  static tree new_channel_fndecl;\n-  tree ret = Gogo::call_builtin(&new_channel_fndecl,\n-\t\t\t\tlocation,\n-\t\t\t\t\"__go_new_channel\",\n-\t\t\t\t2,\n-\t\t\t\tchannel_type,\n-\t\t\t\ttype_to_tree(ptdt->get_backend(gogo)),\n-\t\t\t\telement_type_descriptor,\n-\t\t\t\tsizetype,\n-\t\t\t\texpr_tree);\n-  if (ret == error_mark_node)\n-    return error_mark_node;\n-  // This can panic if the capacity is out of range.\n-  TREE_NOTHROW(new_channel_fndecl) = 0;\n-\n-  if (bad_index == NULL_TREE)\n-    return ret;\n-  else\n-    {\n-      tree crash = Gogo::runtime_error(RUNTIME_ERROR_MAKE_CHAN_OUT_OF_BOUNDS,\n-\t\t\t\t       location);\n-      return build2(COMPOUND_EXPR, TREE_TYPE(ret),\n-\t\t    build3(COND_EXPR, void_type_node,\n-\t\t\t   bad_index, crash, NULL_TREE),\n-\t\t    ret);\n-    }\n-}\n-\n // Build a type descriptor for a channel type.\n \n Type*"}, {"sha": "9947a2ca749f4d98bc8ffac26881ce8bfc91de34", "filename": "gcc/go/gofrontend/types.h", "status": "modified", "additions": 2, "deletions": 63, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b8dffe701e9a1f6641f3ff1f08899614ce38ae0/gcc%2Fgo%2Fgofrontend%2Ftypes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b8dffe701e9a1f6641f3ff1f08899614ce38ae0/gcc%2Fgo%2Fgofrontend%2Ftypes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.h?ref=3b8dffe701e9a1f6641f3ff1f08899614ce38ae0", "patch": "@@ -78,6 +78,8 @@ static const int RUNTIME_TYPE_KIND_STRING = 24;\n static const int RUNTIME_TYPE_KIND_STRUCT = 25;\n static const int RUNTIME_TYPE_KIND_UNSAFE_POINTER = 26;\n \n+static const int RUNTIME_TYPE_KIND_NO_POINTERS = (1 << 7);\n+\n // To build the complete list of methods for a named type we need to\n // gather all methods from anonymous fields.  Those methods may\n // require an arbitrary set of indirections and field offsets.  There\n@@ -811,13 +813,6 @@ class Type\n   is_unexported_field_or_method(Gogo*, const Type*, const std::string&,\n \t\t\t\tstd::vector<const Named_type*>*);\n \n-  // This type was passed to the builtin function make.  ARGS are the\n-  // arguments passed to make after the type; this may be NULL if\n-  // there were none.  Issue any required errors.\n-  bool\n-  check_make_expression(Expression_list* args, source_location location)\n-  { return this->do_check_make_expression(args, location); }\n-\n   // Convert the builtin named types.\n   static void\n   convert_builtin_named_types(Gogo*);\n@@ -826,12 +821,6 @@ class Type\n   Btype*\n   get_backend(Gogo*);\n \n-  // Return a tree for a make expression applied to this type.\n-  tree\n-  make_expression_tree(Translate_context* context, Expression_list* args,\n-\t\t       source_location location)\n-  { return this->do_make_expression_tree(context, args, location); }\n-\n   // Build a type descriptor entry for this type.  Return a pointer to\n   // it.  The location is the location which causes us to need the\n   // entry.\n@@ -878,16 +867,9 @@ class Type\n   virtual unsigned int\n   do_hash_for_method(Gogo*) const;\n \n-  virtual bool\n-  do_check_make_expression(Expression_list* args, source_location);\n-\n   virtual Btype*\n   do_get_backend(Gogo*) = 0;\n \n-  virtual tree\n-  do_make_expression_tree(Translate_context*, Expression_list*,\n-\t\t\t  source_location);\n-\n   virtual Expression*\n   do_type_descriptor(Gogo*, Named_type* name) = 0;\n \n@@ -901,10 +883,6 @@ class Type\n   virtual void\n   do_export(Export*) const;\n \n-  // Return whether an expression is an integer.\n-  static bool\n-  check_int_value(Expression*, const char*, source_location);\n-\n   // Return whether a method expects a pointer as the receiver.\n   static bool\n   method_expects_pointer(const Named_object*);\n@@ -2083,16 +2061,9 @@ class Array_type : public Type\n   unsigned int\n   do_hash_for_method(Gogo*) const;\n \n-  bool\n-  do_check_make_expression(Expression_list*, source_location);\n-\n   Btype*\n   do_get_backend(Gogo*);\n \n-  tree\n-  do_make_expression_tree(Translate_context*, Expression_list*,\n-\t\t\t  source_location);\n-\n   Expression*\n   do_type_descriptor(Gogo*, Named_type*);\n \n@@ -2180,16 +2151,9 @@ class Map_type : public Type\n   unsigned int\n   do_hash_for_method(Gogo*) const;\n \n-  bool\n-  do_check_make_expression(Expression_list*, source_location);\n-\n   Btype*\n   do_get_backend(Gogo*);\n \n-  tree\n-  do_make_expression_tree(Translate_context*, Expression_list*,\n-\t\t\t  source_location);\n-\n   Expression*\n   do_type_descriptor(Gogo*, Named_type*);\n \n@@ -2269,16 +2233,9 @@ class Channel_type : public Type\n   unsigned int\n   do_hash_for_method(Gogo*) const;\n \n-  bool\n-  do_check_make_expression(Expression_list*, source_location);\n-\n   Btype*\n   do_get_backend(Gogo*);\n \n-  tree\n-  do_make_expression_tree(Translate_context*, Expression_list*,\n-\t\t\t  source_location);\n-\n   Expression*\n   do_type_descriptor(Gogo*, Named_type*);\n \n@@ -2611,18 +2568,9 @@ class Named_type : public Type\n   unsigned int\n   do_hash_for_method(Gogo*) const;\n \n-  bool\n-  do_check_make_expression(Expression_list* args, source_location location)\n-  { return this->type_->check_make_expression(args, location); }\n-\n   Btype*\n   do_get_backend(Gogo*);\n \n-  tree\n-  do_make_expression_tree(Translate_context* context, Expression_list* args,\n-\t\t\t  source_location location)\n-  { return this->type_->make_expression_tree(context, args, location); }\n-\n   Expression*\n   do_type_descriptor(Gogo*, Named_type*);\n \n@@ -2751,18 +2699,9 @@ class Forward_declaration_type : public Type\n   do_hash_for_method(Gogo* gogo) const\n   { return this->real_type()->hash_for_method(gogo); }\n \n-  bool\n-  do_check_make_expression(Expression_list* args, source_location location)\n-  { return this->base()->check_make_expression(args, location); }\n-\n   Btype*\n   do_get_backend(Gogo* gogo);\n \n-  tree\n-  do_make_expression_tree(Translate_context* context, Expression_list* args,\n-\t\t\t  source_location location)\n-  { return this->base()->make_expression_tree(context, args, location); }\n-\n   Expression*\n   do_type_descriptor(Gogo*, Named_type*);\n "}, {"sha": "761a11ad265f5d4c370d9544d962901a3c81c743", "filename": "libgo/Makefile.am", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b8dffe701e9a1f6641f3ff1f08899614ce38ae0/libgo%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b8dffe701e9a1f6641f3ff1f08899614ce38ae0/libgo%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.am?ref=3b8dffe701e9a1f6641f3ff1f08899614ce38ae0", "patch": "@@ -381,6 +381,7 @@ runtime_files = \\\n \truntime/go-interface-eface-compare.c \\\n \truntime/go-interface-val-compare.c \\\n \truntime/go-lock-os-thread.c \\\n+\truntime/go-make-slice.c \\\n \truntime/go-map-delete.c \\\n \truntime/go-map-index.c \\\n \truntime/go-map-len.c \\"}, {"sha": "8637ec41b7d72cc8240e380fa393178ac6c399c7", "filename": "libgo/Makefile.in", "status": "modified", "additions": 40, "deletions": 31, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b8dffe701e9a1f6641f3ff1f08899614ce38ae0/libgo%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b8dffe701e9a1f6641f3ff1f08899614ce38ae0/libgo%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.in?ref=3b8dffe701e9a1f6641f3ff1f08899614ce38ae0", "patch": "@@ -184,18 +184,18 @@ am__libgo_la_SOURCES_DIST = runtime/go-append.c runtime/go-assert.c \\\n \truntime/go-interface-compare.c \\\n \truntime/go-interface-eface-compare.c \\\n \truntime/go-interface-val-compare.c runtime/go-lock-os-thread.c \\\n-\truntime/go-map-delete.c runtime/go-map-index.c \\\n-\truntime/go-map-len.c runtime/go-map-range.c \\\n-\truntime/go-nanotime.c runtime/go-new-channel.c \\\n-\truntime/go-new-map.c runtime/go-new.c runtime/go-note.c \\\n-\truntime/go-panic.c runtime/go-panic-defer.c runtime/go-print.c \\\n-\truntime/go-rec-big.c runtime/go-rec-nb-big.c \\\n-\truntime/go-rec-nb-small.c runtime/go-rec-small.c \\\n-\truntime/go-recover.c runtime/go-reflect.c \\\n-\truntime/go-reflect-call.c runtime/go-reflect-chan.c \\\n-\truntime/go-reflect-map.c runtime/go-rune.c \\\n-\truntime/go-runtime-error.c runtime/go-sched.c \\\n-\truntime/go-select.c runtime/go-semacquire.c \\\n+\truntime/go-make-slice.c runtime/go-map-delete.c \\\n+\truntime/go-map-index.c runtime/go-map-len.c \\\n+\truntime/go-map-range.c runtime/go-nanotime.c \\\n+\truntime/go-new-channel.c runtime/go-new-map.c runtime/go-new.c \\\n+\truntime/go-note.c runtime/go-panic.c runtime/go-panic-defer.c \\\n+\truntime/go-print.c runtime/go-rec-big.c \\\n+\truntime/go-rec-nb-big.c runtime/go-rec-nb-small.c \\\n+\truntime/go-rec-small.c runtime/go-recover.c \\\n+\truntime/go-reflect.c runtime/go-reflect-call.c \\\n+\truntime/go-reflect-chan.c runtime/go-reflect-map.c \\\n+\truntime/go-rune.c runtime/go-runtime-error.c \\\n+\truntime/go-sched.c runtime/go-select.c runtime/go-semacquire.c \\\n \truntime/go-send-big.c runtime/go-send-nb-big.c \\\n \truntime/go-send-nb-small.c runtime/go-send-small.c \\\n \truntime/go-setenv.c runtime/go-signal.c runtime/go-strcmp.c \\\n@@ -227,25 +227,25 @@ am__objects_3 = go-append.lo go-assert.lo go-assert-interface.lo \\\n \tgo-gomaxprocs.lo go-int-array-to-string.lo go-int-to-string.lo \\\n \tgo-interface-compare.lo go-interface-eface-compare.lo \\\n \tgo-interface-val-compare.lo go-lock-os-thread.lo \\\n-\tgo-map-delete.lo go-map-index.lo go-map-len.lo go-map-range.lo \\\n-\tgo-nanotime.lo go-new-channel.lo go-new-map.lo go-new.lo \\\n-\tgo-note.lo go-panic.lo go-panic-defer.lo go-print.lo \\\n-\tgo-rec-big.lo go-rec-nb-big.lo go-rec-nb-small.lo \\\n-\tgo-rec-small.lo go-recover.lo go-reflect.lo go-reflect-call.lo \\\n-\tgo-reflect-chan.lo go-reflect-map.lo go-rune.lo \\\n-\tgo-runtime-error.lo go-sched.lo go-select.lo go-semacquire.lo \\\n-\tgo-send-big.lo go-send-nb-big.lo go-send-nb-small.lo \\\n-\tgo-send-small.lo go-setenv.lo go-signal.lo go-strcmp.lo \\\n-\tgo-string-to-byte-array.lo go-string-to-int-array.lo \\\n-\tgo-strplus.lo go-strslice.lo go-trampoline.lo go-type-eface.lo \\\n-\tgo-type-error.lo go-type-identity.lo go-type-interface.lo \\\n-\tgo-type-string.lo go-typedesc-equal.lo go-typestring.lo \\\n-\tgo-unreflect.lo go-unsafe-new.lo go-unsafe-newarray.lo \\\n-\tgo-unsafe-pointer.lo go-unwind.lo cpuprof.lo mcache.lo \\\n-\tmcentral.lo $(am__objects_1) mfinal.lo mfixalloc.lo mgc0.lo \\\n-\tmheap.lo msize.lo proc.lo thread.lo $(am__objects_2) chan.lo \\\n-\tiface.lo malloc.lo map.lo mprof.lo reflect.lo sigqueue.lo \\\n-\tstring.lo\n+\tgo-make-slice.lo go-map-delete.lo go-map-index.lo \\\n+\tgo-map-len.lo go-map-range.lo go-nanotime.lo go-new-channel.lo \\\n+\tgo-new-map.lo go-new.lo go-note.lo go-panic.lo \\\n+\tgo-panic-defer.lo go-print.lo go-rec-big.lo go-rec-nb-big.lo \\\n+\tgo-rec-nb-small.lo go-rec-small.lo go-recover.lo go-reflect.lo \\\n+\tgo-reflect-call.lo go-reflect-chan.lo go-reflect-map.lo \\\n+\tgo-rune.lo go-runtime-error.lo go-sched.lo go-select.lo \\\n+\tgo-semacquire.lo go-send-big.lo go-send-nb-big.lo \\\n+\tgo-send-nb-small.lo go-send-small.lo go-setenv.lo go-signal.lo \\\n+\tgo-strcmp.lo go-string-to-byte-array.lo \\\n+\tgo-string-to-int-array.lo go-strplus.lo go-strslice.lo \\\n+\tgo-trampoline.lo go-type-eface.lo go-type-error.lo \\\n+\tgo-type-identity.lo go-type-interface.lo go-type-string.lo \\\n+\tgo-typedesc-equal.lo go-typestring.lo go-unreflect.lo \\\n+\tgo-unsafe-new.lo go-unsafe-newarray.lo go-unsafe-pointer.lo \\\n+\tgo-unwind.lo cpuprof.lo mcache.lo mcentral.lo $(am__objects_1) \\\n+\tmfinal.lo mfixalloc.lo mgc0.lo mheap.lo msize.lo proc.lo \\\n+\tthread.lo $(am__objects_2) chan.lo iface.lo malloc.lo map.lo \\\n+\tmprof.lo reflect.lo sigqueue.lo string.lo\n am_libgo_la_OBJECTS = $(am__objects_3)\n libgo_la_OBJECTS = $(am_libgo_la_OBJECTS)\n libgo_la_LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \\\n@@ -800,6 +800,7 @@ runtime_files = \\\n \truntime/go-interface-eface-compare.c \\\n \truntime/go-interface-val-compare.c \\\n \truntime/go-lock-os-thread.c \\\n+\truntime/go-make-slice.c \\\n \truntime/go-map-delete.c \\\n \truntime/go-map-index.c \\\n \truntime/go-map-len.c \\\n@@ -2309,6 +2310,7 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-interface-val-compare.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-lock-os-thread.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-main.Po@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-make-slice.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-map-delete.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-map-index.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-map-len.Plo@am__quote@\n@@ -2610,6 +2612,13 @@ go-lock-os-thread.lo: runtime/go-lock-os-thread.c\n @AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n @am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o go-lock-os-thread.lo `test -f 'runtime/go-lock-os-thread.c' || echo '$(srcdir)/'`runtime/go-lock-os-thread.c\n \n+go-make-slice.lo: runtime/go-make-slice.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT go-make-slice.lo -MD -MP -MF $(DEPDIR)/go-make-slice.Tpo -c -o go-make-slice.lo `test -f 'runtime/go-make-slice.c' || echo '$(srcdir)/'`runtime/go-make-slice.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/go-make-slice.Tpo $(DEPDIR)/go-make-slice.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='runtime/go-make-slice.c' object='go-make-slice.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o go-make-slice.lo `test -f 'runtime/go-make-slice.c' || echo '$(srcdir)/'`runtime/go-make-slice.c\n+\n go-map-delete.lo: runtime/go-map-delete.c\n @am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT go-map-delete.lo -MD -MP -MF $(DEPDIR)/go-map-delete.Tpo -c -o go-map-delete.lo `test -f 'runtime/go-map-delete.c' || echo '$(srcdir)/'`runtime/go-map-delete.c\n @am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/go-map-delete.Tpo $(DEPDIR)/go-map-delete.Plo"}, {"sha": "0c6f39185de6a2a8edf1954e67170e415092b069", "filename": "libgo/runtime/go-new-channel.c", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b8dffe701e9a1f6641f3ff1f08899614ce38ae0/libgo%2Fruntime%2Fgo-new-channel.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b8dffe701e9a1f6641f3ff1f08899614ce38ae0/libgo%2Fruntime%2Fgo-new-channel.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-new-channel.c?ref=3b8dffe701e9a1f6641f3ff1f08899614ce38ae0", "patch": "@@ -13,17 +13,26 @@\n #include \"channel.h\"\n \n struct __go_channel*\n-__go_new_channel (const struct __go_type_descriptor *element_type,\n+__go_new_channel (const struct __go_type_descriptor *channel_type,\n \t\t  uintptr_t entries)\n {\n+  const struct __go_channel_type *ctd;\n+  const struct __go_type_descriptor *element_type;\n   uintptr_t element_size;\n+  int ientries;\n   struct __go_channel* ret;\n   size_t alloc_size;\n   int i;\n \n+  __go_assert (channel_type->__code == GO_CHAN);\n+  ctd = (const struct __go_channel_type *) channel_type;\n+  element_type = ctd->__element_type;\n+\n   element_size = element_type->__size;\n \n-  if ((uintptr_t) (int) entries != entries\n+  ientries = (int) entries;\n+  if (ientries < 0\n+      || (uintptr_t) ientries != entries\n       || entries > (uintptr_t) -1 / element_size)\n     __go_panic_msg (\"chan size out of range\");\n "}, {"sha": "05ac8a1a40c95517cfb515b686a4042fa6775671", "filename": "libgo/runtime/go-new-map.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b8dffe701e9a1f6641f3ff1f08899614ce38ae0/libgo%2Fruntime%2Fgo-new-map.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b8dffe701e9a1f6641f3ff1f08899614ce38ae0/libgo%2Fruntime%2Fgo-new-map.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-new-map.c?ref=3b8dffe701e9a1f6641f3ff1f08899614ce38ae0", "patch": "@@ -106,9 +106,11 @@ __go_map_next_prime (uintptr_t n)\n struct __go_map *\n __go_new_map (const struct __go_map_descriptor *descriptor, uintptr_t entries)\n {\n+  int ientries;\n   struct __go_map *ret;\n \n-  if ((uintptr_t) (int) entries != entries)\n+  ientries = (int) entries;\n+  if (ientries < 0 || (uintptr_t) ientries != entries)\n     __go_panic_msg (\"map size out of range\");\n \n   if (entries == 0)"}, {"sha": "27177e2fc7387ca312fe6a1517120ea8beafffb6", "filename": "libgo/runtime/go-reflect-call.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b8dffe701e9a1f6641f3ff1f08899614ce38ae0/libgo%2Fruntime%2Fgo-reflect-call.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b8dffe701e9a1f6641f3ff1f08899614ce38ae0/libgo%2Fruntime%2Fgo-reflect-call.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-reflect-call.c?ref=3b8dffe701e9a1f6641f3ff1f08899614ce38ae0", "patch": "@@ -161,7 +161,7 @@ go_complex_to_ffi (ffi_type *float_type)\n static ffi_type *\n go_type_to_ffi (const struct __go_type_descriptor *descriptor)\n {\n-  switch (descriptor->__code)\n+  switch (descriptor->__code & GO_CODE_MASK)\n     {\n     case GO_BOOL:\n       if (sizeof (_Bool) == 1)"}, {"sha": "61e360212f0dfb216e2091846a62cdeeaa351676", "filename": "libgo/runtime/go-reflect-chan.c", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b8dffe701e9a1f6641f3ff1f08899614ce38ae0/libgo%2Fruntime%2Fgo-reflect-chan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b8dffe701e9a1f6641f3ff1f08899614ce38ae0/libgo%2Fruntime%2Fgo-reflect-chan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-reflect-chan.c?ref=3b8dffe701e9a1f6641f3ff1f08899614ce38ae0", "patch": "@@ -26,9 +26,6 @@ makechan (const struct __go_type_descriptor *typ, uint32_t size)\n   struct __go_channel *channel;\n   void *ret;\n \n-  __go_assert (typ->__code == GO_CHAN);\n-  typ = ((const struct __go_channel_type *) typ)->__element_type;\n-\n   channel = __go_new_channel (typ, size);\n \n   ret = __go_alloc (sizeof (void *));"}, {"sha": "af7d5e8968f01eaed5e9db8818c94a2a5bd57788", "filename": "libgo/runtime/go-reflect.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b8dffe701e9a1f6641f3ff1f08899614ce38ae0/libgo%2Fruntime%2Fgo-reflect.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b8dffe701e9a1f6641f3ff1f08899614ce38ae0/libgo%2Fruntime%2Fgo-reflect.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-reflect.c?ref=3b8dffe701e9a1f6641f3ff1f08899614ce38ae0", "patch": "@@ -57,7 +57,7 @@ extern const struct __go_type_descriptor ptr_struct_descriptor\n const struct __go_type_descriptor *\n get_descriptor (int code)\n {\n-  switch (code)\n+  switch (code & GO_CODE_MASK)\n     {\n     case GO_BOOL:\n       return &ptr_bool_descriptor;"}, {"sha": "6e2193982d65a90bb096a646f332b7349e2fc051", "filename": "libgo/runtime/go-type.h", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b8dffe701e9a1f6641f3ff1f08899614ce38ae0/libgo%2Fruntime%2Fgo-type.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b8dffe701e9a1f6641f3ff1f08899614ce38ae0/libgo%2Fruntime%2Fgo-type.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-type.h?ref=3b8dffe701e9a1f6641f3ff1f08899614ce38ae0", "patch": "@@ -53,13 +53,17 @@\n #define GO_STRUCT 25\n #define GO_UNSAFE_POINTER 26\n \n+#define GO_NO_POINTERS (1 << 7)\n+\n+#define GO_CODE_MASK 0x7f\n+\n /* For each Go type the compiler constructs one of these structures.\n    This is used for type reflectin, interfaces, maps, and reference\n    counting.  */\n \n struct __go_type_descriptor\n {\n-  /* The type code for this type, a value in enum __go_type_codes.\n+  /* The type code for this type, one of the type kind values above.\n      This is used by unsafe.Reflect and unsafe.Typeof to determine the\n      type descriptor to return for this type itself.  It is also used\n      by reflect.toType when mapping to a reflect Type structure.  */"}]}