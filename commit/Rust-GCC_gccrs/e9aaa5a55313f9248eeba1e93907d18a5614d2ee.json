{"sha": "e9aaa5a55313f9248eeba1e93907d18a5614d2ee", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTlhYWE1YTU1MzEzZjkyNDhlZWJhMWU5MzkwN2QxOGE1NjE0ZDJlZQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-03-14T11:18:52Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-03-14T11:18:52Z"}, "message": "(fold, associate): If -ffast-math, associate FP mults.\n\n(fold, case RDIV_EXPR): Split case; ignore division by 1.\nIf -ffast-math, convert to multply by reciprocal.\n(fold, case *_DIV_EXPR): Simplify A/C1/C2.\n\nFrom-SVN: r6780", "tree": {"sha": "3e385c029e541846ca154d3500d1b98cb73b0c57", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3e385c029e541846ca154d3500d1b98cb73b0c57"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e9aaa5a55313f9248eeba1e93907d18a5614d2ee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e9aaa5a55313f9248eeba1e93907d18a5614d2ee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e9aaa5a55313f9248eeba1e93907d18a5614d2ee", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e9aaa5a55313f9248eeba1e93907d18a5614d2ee/comments", "author": null, "committer": null, "parents": [{"sha": "d0cb4c65915dde950c0602a79640f061a77522fa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d0cb4c65915dde950c0602a79640f061a77522fa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d0cb4c65915dde950c0602a79640f061a77522fa"}], "stats": {"total": 81, "additions": 70, "deletions": 11}, "files": [{"sha": "8195163d8b14384ac38989c52b7ff65d6d45bd2c", "filename": "gcc/fold-const.c", "status": "modified", "additions": 70, "deletions": 11, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9aaa5a55313f9248eeba1e93907d18a5614d2ee/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9aaa5a55313f9248eeba1e93907d18a5614d2ee/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=e9aaa5a55313f9248eeba1e93907d18a5614d2ee", "patch": "@@ -3666,9 +3666,13 @@ fold (expr)\n     associate:\n       /* In most languages, can't associate operations on floats\n \t through parentheses.  Rather than remember where the parentheses\n-\t were, we don't associate floats at all.  It shouldn't matter much.  */\n-      if (FLOAT_TYPE_P (type))\n+\t were, we don't associate floats at all.  It shouldn't matter much.\n+\t However, associating multiplications is only very slightly\n+\t inaccurate, so do that if -ffast-math is specified.  */\n+      if (FLOAT_TYPE_P (type)\n+\t  && ! (flag_fast_math && code == MULT_EXPR))\n \tgoto binary;\n+\n       /* The varsign == -1 cases happen only for addition and subtraction.\n \t It says that the arg that was split was really CON minus VAR.\n \t The rest of the code applies to all associative operations.  */\n@@ -3958,17 +3962,80 @@ fold (expr)\n \t}\n       goto binary;\n \n+    case RDIV_EXPR:\n+      /* In most cases, do nothing with a divide by zero.  */\n+#if !defined (REAL_IS_NOT_DOUBLE) || defined (REAL_ARITHMETIC)\n+#ifndef REAL_INFINITY\n+      if (TREE_CODE (arg1) == REAL_CST && real_zerop (arg1))\n+\treturn t;\n+#endif\n+#endif /* not REAL_IS_NOT_DOUBLE, or REAL_ARITHMETIC */\n+\n+      /* In IEEE floating point, x/1 is not equivalent to x for snans.\n+\t However, ANSI says we can drop signals, so we can do this anyway.  */\n+      if (real_onep (arg1))\n+\treturn non_lvalue (convert (type, arg0));\n+\n+      /* If ARG1 is a constant, we can convert this to a multiply by the\n+\t reciprocal.  This does not have the same rounding properties,\n+\t so only do this if -ffast-math.  We can actually always safely\n+\t do it if ARG1 is a power of two, but it's hard to tell if it is\n+\t or not in a portable manner.  */\n+      if (TREE_CODE (arg1) == REAL_CST && flag_fast_math\n+\t  && 0 != (tem = const_binop (code, build_real (type, dconst1),\n+\t\t\t\t      arg1, 0)))\n+\treturn fold (build (MULT_EXPR, type, arg0, tem));\n+\n+      goto binary;\n+\n     case TRUNC_DIV_EXPR:\n     case ROUND_DIV_EXPR:\n     case FLOOR_DIV_EXPR:\n     case CEIL_DIV_EXPR:\n     case EXACT_DIV_EXPR:\n-    case RDIV_EXPR:\n       if (integer_onep (arg1))\n \treturn non_lvalue (convert (type, arg0));\n       if (integer_zerop (arg1))\n \treturn t;\n \n+      /* If we have ((a / C1) / C2) where both division are the same type, tr\n+\t to simplify.  First see if C1 * C2 overflows or not.  */\n+      if (TREE_CODE (arg0) == code && TREE_CODE (arg1) == INTEGER_CST\n+\t  && TREE_CODE (TREE_OPERAND (arg0, 1)) == INTEGER_CST)\n+\t{\n+\t  tem = const_binop (MULT_EXPR, TREE_OPERAND (arg0, 1), arg1, 0);\n+\n+\t  /* If it overflows, the result is +/- 1 or zero, depending on\n+\t     the signs of the two constants and the division operation.  */\n+\t  if (TREE_OVERFLOW (tem))\n+\t    {\n+\t      switch (code)\n+\t\t{\n+\t\tcase EXACT_DIV_EXPR:\n+\t\tcase TRUNC_DIV_EXPR:\n+\t\t  tem = integer_zero_node;\n+\t\t  break;\n+\t\tcase FLOOR_DIV_EXPR:\n+\t\t  /* -1 if signs disagree, else 0.  */\n+\t\t  tem = (((tree_int_cst_sgn (TREE_OPERAND (arg0, 1)) < 0)\n+\t\t\t  != (tree_int_cst_sgn (arg1) < 0))\n+\t\t\t ? build_int_2 (-1, -1) : integer_zero_node);\n+\t\t  break;\n+\t\tcase CEIL_DIV_EXPR:\n+\t\t  /* 1 if signs agree, else 0.  */\n+\t\t  tem = (((tree_int_cst_sgn (TREE_OPERAND (arg0, 1)) < 0)\n+\t\t\t  == (tree_int_cst_sgn (arg1) < 0))\n+\t\t\t ? integer_one_node : integer_zero_node);\n+\t\t  break;\n+\t\t}\n+\n+\t      return omit_one_operand (type, tem, TREE_OPERAND (arg0, 0));\n+\t    }\n+\t  else\n+\t    /* If no overflow, divide by C1*C2.  */\n+\t    return fold (build (code, type, TREE_OPERAND (arg0, 0), tem));\n+\t}\n+\n       /* Look for ((a * C1) / C3) or (((a * C1) + C2) / C3),\n \t where C1 % C3 == 0 or C3 % C1 == 0.  We can simplify these\n \t expressions, which often appear in the offsets or sizes of\n@@ -4044,14 +4111,6 @@ fold (expr)\n \t    }\n \t}\n \n-#if !defined (REAL_IS_NOT_DOUBLE) || defined (REAL_ARITHMETIC)\n-#ifndef REAL_INFINITY\n-      if (TREE_CODE (arg1) == REAL_CST\n-\t  && real_zerop (arg1))\n-\treturn t;\n-#endif\n-#endif /* not REAL_IS_NOT_DOUBLE, or REAL_ARITHMETIC */\n-\n       goto binary;\n \n     case CEIL_MOD_EXPR:"}]}