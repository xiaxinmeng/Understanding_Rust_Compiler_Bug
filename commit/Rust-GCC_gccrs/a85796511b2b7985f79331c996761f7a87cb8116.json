{"sha": "a85796511b2b7985f79331c996761f7a87cb8116", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTg1Nzk2NTExYjJiNzk4NWY3OTMzMWM5OTY3NjFmN2E4N2NiODExNg==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2019-09-09T17:59:41Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2019-09-09T17:59:41Z"}, "message": "Remove hard_reg_set_equal_p\n\nUse \"x == y\" instead of \"hard_reg_set_equal_p (x, y)\".\n\n2019-09-09  Richard Sandiford  <richard.sandiford@arm.com>\n\ngcc/\n\t* hard-reg-set.h (HARD_REG_SET::operator==): New function.\n\t(HARD_REG_SET::operator!=): Likewise.\n\t(hard_reg_set_equal_p): Delete.\n\t* cfgcleanup.c (old_insns_match_p): Use == instead of\n\thard_reg_set_equal_p and != instead of !hard_reg_set_equal_p.\n\t* ira-color.c (allocno_hard_regs_hasher::equal): Likewise.\n\t(add_allocno_hard_regs_to_forest): Likewise.\n\t(setup_allocno_available_regs_num): Likewise.\n\t* ira.c (setup_pressure_classes): Likewise.\n\t(setup_allocno_and_important_classes): Likewise.\n\t(setup_reg_class_relations): Likewise.\n\t* lra-lives.c (process_bb_lives): Likewise.\n\t* reg-stack.c (change_stack, convert_regs_1): Likewise.\n\nFrom-SVN: r275534", "tree": {"sha": "4a203b9ce5ea6c1edbe21037576b86fa2d0b1107", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4a203b9ce5ea6c1edbe21037576b86fa2d0b1107"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a85796511b2b7985f79331c996761f7a87cb8116", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a85796511b2b7985f79331c996761f7a87cb8116", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a85796511b2b7985f79331c996761f7a87cb8116", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a85796511b2b7985f79331c996761f7a87cb8116/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "4897c5aaa7a5db4c1ece28ef66acb3d5e41787b3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4897c5aaa7a5db4c1ece28ef66acb3d5e41787b3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4897c5aaa7a5db4c1ece28ef66acb3d5e41787b3"}], "stats": {"total": 88, "additions": 48, "deletions": 40}, "files": [{"sha": "8c791dd71318ae2715ad01164d46b8fbb6187f42", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a85796511b2b7985f79331c996761f7a87cb8116/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a85796511b2b7985f79331c996761f7a87cb8116/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a85796511b2b7985f79331c996761f7a87cb8116", "patch": "@@ -1,3 +1,19 @@\n+2019-09-09  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* hard-reg-set.h (HARD_REG_SET::operator==): New function.\n+\t(HARD_REG_SET::operator!=): Likewise.\n+\t(hard_reg_set_equal_p): Delete.\n+\t* cfgcleanup.c (old_insns_match_p): Use == instead of\n+\thard_reg_set_equal_p and != instead of !hard_reg_set_equal_p.\n+\t* ira-color.c (allocno_hard_regs_hasher::equal): Likewise.\n+\t(add_allocno_hard_regs_to_forest): Likewise.\n+\t(setup_allocno_available_regs_num): Likewise.\n+\t* ira.c (setup_pressure_classes): Likewise.\n+\t(setup_allocno_and_important_classes): Likewise.\n+\t(setup_reg_class_relations): Likewise.\n+\t* lra-lives.c (process_bb_lives): Likewise.\n+\t* reg-stack.c (change_stack, convert_regs_1): Likewise.\n+\n 2019-09-09  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* hard-reg-set.h (IOR_COMPL_HARD_REG_SET): Delete."}, {"sha": "baa380959642eae8805d9c73e4cdb4d7de81d76f", "filename": "gcc/cfgcleanup.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a85796511b2b7985f79331c996761f7a87cb8116/gcc%2Fcfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a85796511b2b7985f79331c996761f7a87cb8116/gcc%2Fcfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgcleanup.c?ref=a85796511b2b7985f79331c996761f7a87cb8116", "patch": "@@ -1231,7 +1231,7 @@ old_insns_match_p (int mode ATTRIBUTE_UNUSED, rtx_insn *i1, rtx_insn *i2)\n       get_call_reg_set_usage (i1, &i1_used, call_used_reg_set);\n       get_call_reg_set_usage (i2, &i2_used, call_used_reg_set);\n \n-      if (!hard_reg_set_equal_p (i1_used, i2_used))\n+      if (i1_used != i2_used)\n         return dir_none;\n     }\n \n@@ -1265,7 +1265,7 @@ old_insns_match_p (int mode ATTRIBUTE_UNUSED, rtx_insn *i1, rtx_insn *i2)\n \tif (REG_NOTE_KIND (note) == REG_DEAD && STACK_REG_P (XEXP (note, 0)))\n \t  SET_HARD_REG_BIT (i2_regset, REGNO (XEXP (note, 0)));\n \n-      if (!hard_reg_set_equal_p (i1_regset, i2_regset))\n+      if (i1_regset != i2_regset)\n \treturn dir_none;\n     }\n #endif"}, {"sha": "e59779dddd288b62acb7a52be8707c343a2be3dd", "filename": "gcc/hard-reg-set.h", "status": "modified", "additions": 15, "deletions": 16, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a85796511b2b7985f79331c996761f7a87cb8116/gcc%2Fhard-reg-set.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a85796511b2b7985f79331c996761f7a87cb8116/gcc%2Fhard-reg-set.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhard-reg-set.h?ref=a85796511b2b7985f79331c996761f7a87cb8116", "patch": "@@ -96,6 +96,21 @@ struct HARD_REG_SET\n     return *this;\n   }\n \n+  bool\n+  operator== (const HARD_REG_SET &other) const\n+  {\n+    HARD_REG_ELT_TYPE bad = 0;\n+    for (unsigned int i = 0; i < ARRAY_SIZE (elts); ++i)\n+      bad |= (elts[i] ^ other.elts[i]);\n+    return bad == 0;\n+  }\n+\n+  bool\n+  operator!= (const HARD_REG_SET &other) const\n+  {\n+    return !operator== (other);\n+  }\n+\n   HARD_REG_ELT_TYPE elts[HARD_REG_SET_LONGS];\n };\n typedef const HARD_REG_SET &const_hard_reg_set;\n@@ -129,7 +144,6 @@ struct hard_reg_set_container\n    Also define:\n \n    hard_reg_set_subset_p (X, Y), which returns true if X is a subset of Y.\n-   hard_reg_set_equal_p (X, Y), which returns true if X and Y are equal.\n    hard_reg_set_intersect_p (X, Y), which returns true if X and Y intersect.\n    hard_reg_set_empty_p (X), which returns true if X is empty.  */\n \n@@ -153,12 +167,6 @@ hard_reg_set_subset_p (const_hard_reg_set x, const_hard_reg_set y)\n   return (x & ~y) == HARD_CONST (0);\n }\n \n-static inline bool\n-hard_reg_set_equal_p (const_hard_reg_set x, const_hard_reg_set y)\n-{\n-  return x == y;\n-}\n-\n static inline bool\n hard_reg_set_intersect_p (const_hard_reg_set x, const_hard_reg_set y)\n {\n@@ -217,15 +225,6 @@ hard_reg_set_subset_p (const_hard_reg_set x, const_hard_reg_set y)\n   return bad == 0;\n }\n \n-static inline bool\n-hard_reg_set_equal_p (const_hard_reg_set x, const_hard_reg_set y)\n-{\n-  HARD_REG_ELT_TYPE bad = 0;\n-  for (unsigned int i = 0; i < ARRAY_SIZE (x.elts); ++i)\n-    bad |= (x.elts[i] ^ y.elts[i]);\n-  return bad == 0;\n-}\n-\n static inline bool\n hard_reg_set_intersect_p (const_hard_reg_set x, const_hard_reg_set y)\n {"}, {"sha": "eee9e0b7b4881fc3190e9ae54b5df94d3941db66", "filename": "gcc/ira-color.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a85796511b2b7985f79331c996761f7a87cb8116/gcc%2Fira-color.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a85796511b2b7985f79331c996761f7a87cb8116/gcc%2Fira-color.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-color.c?ref=a85796511b2b7985f79331c996761f7a87cb8116", "patch": "@@ -218,7 +218,7 @@ inline bool\n allocno_hard_regs_hasher::equal (const allocno_hard_regs *hv1,\n \t\t\t\t const allocno_hard_regs *hv2)\n {\n-  return hard_reg_set_equal_p (hv1->set, hv2->set);\n+  return hv1->set == hv2->set;\n }\n \n /* Hash table of unique allocno hard registers.  */\n@@ -371,7 +371,7 @@ add_allocno_hard_regs_to_forest (allocno_hard_regs_node_t *roots,\n   start = hard_regs_node_vec.length ();\n   for (node = *roots; node != NULL; node = node->next)\n     {\n-      if (hard_reg_set_equal_p (hv->set, node->hard_regs->set))\n+      if (hv->set == node->hard_regs->set)\n \treturn;\n       if (hard_reg_set_subset_p (hv->set, node->hard_regs->set))\n \t{\n@@ -2688,8 +2688,7 @@ setup_allocno_available_regs_num (ira_allocno_t a)\n      reg_class_names[aclass], ira_class_hard_regs_num[aclass], n);\n   print_hard_reg_set (ira_dump_file, data->profitable_hard_regs, false);\n   fprintf (ira_dump_file, \", %snode: \",\n-\t   hard_reg_set_equal_p (data->profitable_hard_regs,\n-\t\t\t\t data->hard_regs_node->hard_regs->set)\n+\t   data->profitable_hard_regs == data->hard_regs_node->hard_regs->set\n \t   ? \"\" : \"^\");\n   print_hard_reg_set (ira_dump_file,\n \t\t      data->hard_regs_node->hard_regs->set, false);"}, {"sha": "029d690cb4c9e83394723b4f5079eb3e4ce29c2f", "filename": "gcc/ira.c", "status": "modified", "additions": 8, "deletions": 13, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a85796511b2b7985f79331c996761f7a87cb8116/gcc%2Fira.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a85796511b2b7985f79331c996761f7a87cb8116/gcc%2Fira.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.c?ref=a85796511b2b7985f79331c996761f7a87cb8116", "patch": "@@ -841,20 +841,18 @@ setup_pressure_classes (void)\n \t      temp_hard_regset2 = (reg_class_contents[cl2]\n \t\t\t\t   & ~no_unit_alloc_regs);\n \t      if (hard_reg_set_subset_p (temp_hard_regset, temp_hard_regset2)\n-\t\t  && (! hard_reg_set_equal_p (temp_hard_regset,\n-\t\t\t\t\t      temp_hard_regset2)\n+\t\t  && (temp_hard_regset != temp_hard_regset2\n \t\t      || cl2 == (int) GENERAL_REGS))\n \t\t{\n \t\t  pressure_classes[curr++] = (enum reg_class) cl2;\n \t\t  insert_p = false;\n \t\t  continue;\n \t\t}\n \t      if (hard_reg_set_subset_p (temp_hard_regset2, temp_hard_regset)\n-\t\t  && (! hard_reg_set_equal_p (temp_hard_regset2,\n-\t\t\t\t\t      temp_hard_regset)\n+\t\t  && (temp_hard_regset2 != temp_hard_regset\n \t\t      || cl == (int) GENERAL_REGS))\n \t\tcontinue;\n-\t      if (hard_reg_set_equal_p (temp_hard_regset2, temp_hard_regset))\n+\t      if (temp_hard_regset2 == temp_hard_regset)\n \t\tinsert_p = false;\n \t      pressure_classes[curr++] = (enum reg_class) cl2;\n \t    }\n@@ -999,8 +997,7 @@ setup_allocno_and_important_classes (void)\n \t{\n \t  cl = classes[j];\n \t  temp_hard_regset2 = reg_class_contents[cl] & ~no_unit_alloc_regs;\n-\t  if (hard_reg_set_equal_p (temp_hard_regset,\n-\t\t\t\t    temp_hard_regset2))\n+\t  if (temp_hard_regset == temp_hard_regset2)\n \t    break;\n \t}\n       if (j >= n || targetm.additional_allocno_class_p (i))\n@@ -1273,7 +1270,7 @@ setup_reg_class_relations (void)\n \t\t\t     the same, prefer GENERAL_REGS or the\n \t\t\t     smallest class for debugging\n \t\t\t     purposes.  */\n-\t\t\t  || (hard_reg_set_equal_p (temp_hard_regset, temp_set2)\n+\t\t\t  || (temp_hard_regset == temp_set2\n \t\t\t      && (cl3 == GENERAL_REGS\n \t\t\t\t  || ((ira_reg_class_intersect[cl1][cl2]\n \t\t\t\t       != GENERAL_REGS)\n@@ -1290,7 +1287,7 @@ setup_reg_class_relations (void)\n \t\t  if (! hard_reg_set_subset_p (temp_hard_regset, temp_set2)\n \t\t      /* Ignore unavailable hard registers and prefer\n \t\t\t smallest class for debugging purposes.  */\n-\t\t      || (hard_reg_set_equal_p (temp_hard_regset, temp_set2)\n+\t\t      || (temp_hard_regset == temp_set2\n \t\t\t  && hard_reg_set_subset_p\n \t\t\t     (reg_class_contents[cl3],\n \t\t\t      reg_class_contents\n@@ -1309,8 +1306,7 @@ setup_reg_class_relations (void)\n \t \t  if (ira_reg_class_subunion[cl1][cl2] == NO_REGS\n \t\t      || (hard_reg_set_subset_p (temp_set2, temp_hard_regset)\n \t\t\t  \n-\t\t\t  && (! hard_reg_set_equal_p (temp_set2,\n-\t\t\t\t\t\t      temp_hard_regset)\n+\t\t\t  && (temp_set2 != temp_hard_regset\n \t\t\t      || cl3 == GENERAL_REGS\n \t\t\t      /* If the allocatable hard register sets are the\n \t\t\t\t same, prefer GENERAL_REGS or the smallest\n@@ -1333,8 +1329,7 @@ setup_reg_class_relations (void)\n \t \t  if (ira_reg_class_superunion[cl1][cl2] == NO_REGS\n \t\t      || (hard_reg_set_subset_p (temp_hard_regset, temp_set2)\n \n-\t\t\t  && (! hard_reg_set_equal_p (temp_set2,\n-\t\t\t\t\t\t      temp_hard_regset)\n+\t\t\t  && (temp_set2 != temp_hard_regset\n \t\t\t      || cl3 == GENERAL_REGS\n \t\t\t      /* If the allocatable hard register sets are the\n \t\t\t\t same, prefer GENERAL_REGS or the smallest"}, {"sha": "0bdba3910ab87f3db1bac4b1d906365a3c7b9711", "filename": "gcc/lra-lives.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a85796511b2b7985f79331c996761f7a87cb8116/gcc%2Flra-lives.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a85796511b2b7985f79331c996761f7a87cb8116/gcc%2Flra-lives.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-lives.c?ref=a85796511b2b7985f79331c996761f7a87cb8116", "patch": "@@ -936,8 +936,8 @@ process_bb_lives (basic_block bb, int &curr_point, bool dead_insn_p)\n \t\t\t\t      call_used_reg_set);\n \n \t      bool flush = (! hard_reg_set_empty_p (last_call_used_reg_set)\n-\t\t\t    && ( ! hard_reg_set_equal_p (last_call_used_reg_set,\n-\t\t\t\t\t\t       this_call_used_reg_set)))\n+\t\t\t    && (last_call_used_reg_set\n+\t\t\t\t!= this_call_used_reg_set))\n \t\t\t   || (last_call_insn && ! calls_have_same_clobbers_p\n \t\t\t\t\t\t     (call_insn,\n \t\t\t\t\t\t      last_call_insn));"}, {"sha": "6edcc6f6101c145e8dfb78c7066735d51e80d511", "filename": "gcc/reg-stack.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a85796511b2b7985f79331c996761f7a87cb8116/gcc%2Freg-stack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a85796511b2b7985f79331c996761f7a87cb8116/gcc%2Freg-stack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freg-stack.c?ref=a85796511b2b7985f79331c996761f7a87cb8116", "patch": "@@ -2643,7 +2643,7 @@ change_stack (rtx_insn *insn, stack_ptr old, stack_ptr new_stack,\n       /* By now, the only difference should be the order of the stack,\n \t not their depth or liveliness.  */\n \n-      gcc_assert (hard_reg_set_equal_p (old->reg_set, new_stack->reg_set));\n+      gcc_assert (old->reg_set == new_stack->reg_set);\n       gcc_assert (old->top == new_stack->top);\n \n       /* If the stack is not empty (new_stack->top != -1), loop here emitting\n@@ -3158,8 +3158,7 @@ convert_regs_1 (basic_block block)\n      asms, we zapped the instruction itself, but that didn't produce the\n      same pattern of register kills as before.  */\n \n-  gcc_assert (hard_reg_set_equal_p (regstack.reg_set, bi->out_reg_set)\n-\t      || any_malformed_asm);\n+  gcc_assert (regstack.reg_set == bi->out_reg_set || any_malformed_asm);\n   bi->stack_out = regstack;\n   bi->done = true;\n "}]}