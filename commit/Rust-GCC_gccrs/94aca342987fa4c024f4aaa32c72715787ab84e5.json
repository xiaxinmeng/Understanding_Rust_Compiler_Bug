{"sha": "94aca342987fa4c024f4aaa32c72715787ab84e5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTRhY2EzNDI5ODdmYTRjMDI0ZjRhYWEzMmM3MjcxNTc4N2FiODRlNQ==", "commit": {"author": {"name": "Zack Weinberg", "email": "zackw@panix.com", "date": "2001-08-12T01:56:10Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2001-08-12T01:56:10Z"}, "message": "toplev.c (set_float_handler): Make static.\n\n\t* toplev.c (set_float_handler): Make static.\n\t* toplev.h: Don't prototype set_float_handler.\n\n\t* simplify-rtx.c: Don't include setjmp.h.\n\t(simplify_unary_real, simplify_binary_real, simplify_binary_is2orm1):\n\tNew functions.\n\t(simplify_unary_operation, simplify_binary_operation): Use them,\n\tvia do_float_handler.\n\n\t* fold-const.c: Don't include setjmp.h.\n\t(exact_real_inverse_1): New function.\n\t(exact_real_inverse): Use it, via do_float_handler.\n\n\t* varasm.c: Don't include setjmp.h.\n\t(assemble_real_1): New function.\n\t(assemble_real): Use it, via do_float_handler.\n\tCall internal_error if we get a trap here.\n\n\t* c-parse.in, cse.c, cselib.c, ch/lex.c, config/i386/i386.c,\n\tconfig/pj/pj.c, config/s390/s390.c: Don't include setjmp.h.\n\n\t* java/lex.h: Don't include setjmp.h.  Don't define\n\tSET_FLOAT_HANDLER or prototype set_float_handler.\n\nFrom-SVN: r44815", "tree": {"sha": "7e0d274b9d7e3a3888aa3d22cd6cba4854e43f24", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7e0d274b9d7e3a3888aa3d22cd6cba4854e43f24"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/94aca342987fa4c024f4aaa32c72715787ab84e5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/94aca342987fa4c024f4aaa32c72715787ab84e5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/94aca342987fa4c024f4aaa32c72715787ab84e5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/94aca342987fa4c024f4aaa32c72715787ab84e5/comments", "author": {"login": "zackw", "id": 325899, "node_id": "MDQ6VXNlcjMyNTg5OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/325899?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zackw", "html_url": "https://github.com/zackw", "followers_url": "https://api.github.com/users/zackw/followers", "following_url": "https://api.github.com/users/zackw/following{/other_user}", "gists_url": "https://api.github.com/users/zackw/gists{/gist_id}", "starred_url": "https://api.github.com/users/zackw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zackw/subscriptions", "organizations_url": "https://api.github.com/users/zackw/orgs", "repos_url": "https://api.github.com/users/zackw/repos", "events_url": "https://api.github.com/users/zackw/events{/privacy}", "received_events_url": "https://api.github.com/users/zackw/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "31cdd4996b4223793a65643fcbf69163c3623258", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/31cdd4996b4223793a65643fcbf69163c3623258", "html_url": "https://github.com/Rust-GCC/gccrs/commit/31cdd4996b4223793a65643fcbf69163c3623258"}], "stats": {"total": 538, "additions": 314, "deletions": 224}, "files": [{"sha": "880b27b0df78dccdb75866e56a200f605524cac7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94aca342987fa4c024f4aaa32c72715787ab84e5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94aca342987fa4c024f4aaa32c72715787ab84e5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=94aca342987fa4c024f4aaa32c72715787ab84e5", "patch": "@@ -1,3 +1,26 @@\n+2001-08-11  Zack Weinberg  <zackw@panix.com>\n+\n+\t* toplev.c (set_float_handler): Make static.\n+\t* toplev.h: Don't prototype set_float_handler.\n+\n+\t* simplify-rtx.c: Don't include setjmp.h.\n+\t(simplify_unary_real, simplify_binary_real, simplify_binary_is2orm1):\n+\tNew functions.\n+\t(simplify_unary_operation, simplify_binary_operation): Use them,\n+\tvia do_float_handler.\n+\n+\t* fold-const.c: Don't include setjmp.h.\n+\t(exact_real_inverse_1): New function.\n+\t(exact_real_inverse): Use it, via do_float_handler.\n+\n+\t* varasm.c: Don't include setjmp.h.\n+\t(assemble_real_1): New function.\n+\t(assemble_real): Use it, via do_float_handler.\n+\tCall internal_error if we get a trap here.\n+\n+\t* c-parse.in, cse.c, cselib.c, config/i386/i386.c,\n+\tconfig/pj/pj.c, config/s390/s390.c: Don't include setjmp.h.\n+\n 2001-08-11  Zack Weinberg  <zackw@panix.com>\n \n \t* defaults.h: Define PREFERRED_STACK_BOUNDARY to"}, {"sha": "67c603faf2a24af11bc7109272da443472b2d0b2", "filename": "gcc/c-parse.in", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94aca342987fa4c024f4aaa32c72715787ab84e5/gcc%2Fc-parse.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94aca342987fa4c024f4aaa32c72715787ab84e5/gcc%2Fc-parse.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parse.in?ref=94aca342987fa4c024f4aaa32c72715787ab84e5", "patch": "@@ -38,7 +38,6 @@ end ifc\n %{\n #include \"config.h\"\n #include \"system.h\"\n-#include <setjmp.h>\n #include \"tree.h\"\n #include \"input.h\"\n #include \"cpplib.h\""}, {"sha": "31d6d4963a0a9a5ed017c473453b13db4fd67abb", "filename": "gcc/ch/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94aca342987fa4c024f4aaa32c72715787ab84e5/gcc%2Fch%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94aca342987fa4c024f4aaa32c72715787ab84e5/gcc%2Fch%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2FChangeLog?ref=94aca342987fa4c024f4aaa32c72715787ab84e5", "patch": "@@ -1,3 +1,7 @@\n+2001-08-11  Zack Weinberg  <zackw@panix.com>\n+\n+\t* lex.c: Don't include setjmp.h.\n+\n 2001-08-09  Richard Henderson  <rth@redhat.com>\n \n \t* grant.c (chill_finish_compile): Use target hooks instead of"}, {"sha": "8b05f52ec29f6e125f1b04e69f671ee9ef2dfb55", "filename": "gcc/ch/lex.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94aca342987fa4c024f4aaa32c72715787ab84e5/gcc%2Fch%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94aca342987fa4c024f4aaa32c72715787ab84e5/gcc%2Fch%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fch%2Flex.c?ref=94aca342987fa4c024f4aaa32c72715787ab84e5", "patch": "@@ -21,7 +21,6 @@ Boston, MA 02111-1307, USA.  */\n \f\n #include \"config.h\"\n #include \"system.h\"\n-#include <setjmp.h>\n #include <sys/stat.h>\n \n #include \"tree.h\""}, {"sha": "a557d05def8d528caadabf27d5683d1886e70410", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94aca342987fa4c024f4aaa32c72715787ab84e5/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94aca342987fa4c024f4aaa32c72715787ab84e5/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=94aca342987fa4c024f4aaa32c72715787ab84e5", "patch": "@@ -20,7 +20,6 @@ the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n #include \"config.h\"\n-#include <setjmp.h>\n #include \"system.h\"\n #include \"rtl.h\"\n #include \"tree.h\""}, {"sha": "b867179a3fe3c6da7cd84280c0b4c9ad816541f2", "filename": "gcc/config/pj/pj.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94aca342987fa4c024f4aaa32c72715787ab84e5/gcc%2Fconfig%2Fpj%2Fpj.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94aca342987fa4c024f4aaa32c72715787ab84e5/gcc%2Fconfig%2Fpj%2Fpj.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpj%2Fpj.c?ref=94aca342987fa4c024f4aaa32c72715787ab84e5", "patch": "@@ -78,7 +78,6 @@ Boston, MA 02111-1307, USA.  */\n    order, so nothing more needs to be done.  */\n \n \n-#include <setjmp.h>\n #include \"config.h\"\n #include \"system.h\"\n #include \"rtl.h\""}, {"sha": "e07c64c85ae2953e138eea65b0ac4a5c198d84f5", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94aca342987fa4c024f4aaa32c72715787ab84e5/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94aca342987fa4c024f4aaa32c72715787ab84e5/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=94aca342987fa4c024f4aaa32c72715787ab84e5", "patch": "@@ -21,7 +21,6 @@ the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n #include \"config.h\"\n-#include <setjmp.h>\n #include \"system.h\"\n #include \"rtl.h\"\n #include \"tree.h\""}, {"sha": "256b28f6c498b3a0324c2f7adaef9afd7d5a6776", "filename": "gcc/cse.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94aca342987fa4c024f4aaa32c72715787ab84e5/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94aca342987fa4c024f4aaa32c72715787ab84e5/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=94aca342987fa4c024f4aaa32c72715787ab84e5", "patch": "@@ -22,7 +22,6 @@ Boston, MA 02111-1307, USA.  */\n #include \"config.h\"\n /* stdio.h must precede rtl.h for FFS.  */\n #include \"system.h\"\n-#include <setjmp.h>\n \n #include \"rtl.h\"\n #include \"tm_p.h\""}, {"sha": "002c2f5a2db7f1d55e410aa1bbd02bcd04ad944e", "filename": "gcc/cselib.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94aca342987fa4c024f4aaa32c72715787ab84e5/gcc%2Fcselib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94aca342987fa4c024f4aaa32c72715787ab84e5/gcc%2Fcselib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcselib.c?ref=94aca342987fa4c024f4aaa32c72715787ab84e5", "patch": "@@ -21,7 +21,6 @@ Boston, MA 02111-1307, USA.  */\n \n #include \"config.h\"\n #include \"system.h\"\n-#include <setjmp.h>\n \n #include \"rtl.h\"\n #include \"tm_p.h\""}, {"sha": "00af527c380ae6f8600f9ff8a05540a87103ee80", "filename": "gcc/fold-const.c", "status": "modified", "additions": 61, "deletions": 38, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94aca342987fa4c024f4aaa32c72715787ab84e5/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94aca342987fa4c024f4aaa32c72715787ab84e5/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=94aca342987fa4c024f4aaa32c72715787ab84e5", "patch": "@@ -44,7 +44,6 @@ Boston, MA 02111-1307, USA.  */\n \n #include \"config.h\"\n #include \"system.h\"\n-#include <setjmp.h>\n #include \"flags.h\"\n #include \"tree.h\"\n #include \"rtl.h\"\n@@ -59,6 +58,9 @@ static void encode\t\tPARAMS ((HOST_WIDE_INT *,\n static void decode\t\tPARAMS ((HOST_WIDE_INT *,\n \t\t\t\t\t unsigned HOST_WIDE_INT *,\n \t\t\t\t\t HOST_WIDE_INT *));\n+#ifndef REAL_ARITHMETIC\n+static void exact_real_inverse_1 PARAMS ((PTR));\n+#endif\n static tree negate_expr\t\tPARAMS ((tree));\n static tree split_tree\t\tPARAMS ((tree, enum tree_code, tree *, tree *,\n \t\t\t\t\t int));\n@@ -956,51 +958,41 @@ target_negative (x)\n \n /* Try to change R into its exact multiplicative inverse in machine mode\n    MODE.  Return nonzero function value if successful.  */\n+struct exact_real_inverse_args\n+{\n+  REAL_VALUE_TYPE *r;\n+  enum machine_mode mode;\n+  int success;\n+};\n \n-int\n-exact_real_inverse (mode, r)\n-     enum machine_mode mode;\n-     REAL_VALUE_TYPE *r;\n+static void\n+exact_real_inverse_1 (p)\n+     PTR p;\n {\n-  jmp_buf float_error;\n+  struct exact_real_inverse_args *args =\n+    (struct exact_real_inverse_args *) p;\n+\n+  enum machine_mode mode = args->mode;\n+  REAL_VALUE_TYPE *r = args->r;\n+\n   union\n-    {\n-      double d;\n-      unsigned short i[4];\n-    }x, t, y;\n+  {\n+    double d;\n+    unsigned short i[4];\n+  }\n+  x, t, y;\n #ifdef CHECK_FLOAT_VALUE\n   int i;\n #endif\n \n-  /* Usually disable if bounds checks are not reliable.  */\n-  if ((HOST_FLOAT_FORMAT != TARGET_FLOAT_FORMAT) && !flag_pretend_float)\n-    return 0;\n-\n   /* Set array index to the less significant bits in the unions, depending\n-     on the endian-ness of the host doubles.\n-     Disable if insufficient information on the data structure.  */\n-#if HOST_FLOAT_FORMAT == UNKNOWN_FLOAT_FORMAT\n-  return 0;\n+     on the endian-ness of the host doubles.  */\n+#if HOST_FLOAT_FORMAT == VAX_FLOAT_FORMAT \\\n+ || HOST_FLOAT_FORMAT == IBM_FLOAT_FORMAT\n+# define K 2\n #else\n-#if HOST_FLOAT_FORMAT == VAX_FLOAT_FORMAT\n-#define K 2\n-#else\n-#if HOST_FLOAT_FORMAT == IBM_FLOAT_FORMAT\n-#define K 2\n-#else\n-#define K (2 * HOST_FLOAT_WORDS_BIG_ENDIAN)\n-#endif\n+# define K (2 * HOST_FLOAT_WORDS_BIG_ENDIAN)\n #endif\n-#endif\n-\n-  if (setjmp (float_error))\n-    {\n-      /* Don't do the optimization if there was an arithmetic error.  */\n-fail:\n-      set_float_handler (NULL);\n-      return 0;\n-    }\n-  set_float_handler (float_error);\n \n   /* Domain check the argument.  */\n   x.d = *r;\n@@ -1040,9 +1032,40 @@ exact_real_inverse (mode, r)\n #endif\n \n   /* Output the reciprocal and return success flag.  */\n-  set_float_handler (NULL);\n   *r = y.d;\n-  return 1;\n+  args->success = 1;\n+  return;\n+\n+ fail:\n+  args->success = 0;\n+  return;\n+\n+#undef K\n+}\n+\n+\n+int\n+exact_real_inverse (mode, r)\n+     enum machine_mode mode;\n+     REAL_VALUE_TYPE *r;\n+{\n+  struct exact_real_inverse_args args;\n+\n+  /* Disable if insufficient information on the data structure.  */\n+#if HOST_FLOAT_FORMAT == UNKNOWN_FLOAT_FORMAT\n+  return 0;\n+#endif\n+\n+  /* Usually disable if bounds checks are not reliable.  */\n+  if ((HOST_FLOAT_FORMAT != TARGET_FLOAT_FORMAT) && !flag_pretend_float)\n+    return 0;\n+\n+  args.mode = mode;\n+  args.r = r;\n+\n+  if (do_float_handler (exact_real_inverse_1, (PTR) &args))\n+    return args.success;\n+  return 0;\n }\n \n /* Convert C99 hexadecimal floating point string constant S.  Return"}, {"sha": "0356cb7a2af06399aba0545cfa3b9b7f2a8a7e47", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94aca342987fa4c024f4aaa32c72715787ab84e5/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94aca342987fa4c024f4aaa32c72715787ab84e5/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=94aca342987fa4c024f4aaa32c72715787ab84e5", "patch": "@@ -1,3 +1,8 @@\n+2001-08-11  Zack Weinberg  <zackw@panix.com>\n+\n+\t* lex.h: Don't include setjmp.h.  Don't define\n+\tSET_FLOAT_HANDLER or prototype set_float_handler.\n+\n 2001-08-09  Richard Henderson  <rth@redhat.com>\n \n \t* Make-lang.in (class.o): Depend on TARGET_H."}, {"sha": "ef9e6e4017456c1a94d96559e1c597fb00948855", "filename": "gcc/java/lex.h", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94aca342987fa4c024f4aaa32c72715787ab84e5/gcc%2Fjava%2Flex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94aca342987fa4c024f4aaa32c72715787ab84e5/gcc%2Fjava%2Flex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Flex.h?ref=94aca342987fa4c024f4aaa32c72715787ab84e5", "patch": "@@ -26,8 +26,6 @@ The Free Software Foundation is independent of Sun Microsystems, Inc.  */\n #ifndef GCC_JAVA_LEX_H\n #define GCC_JAVA_LEX_H\n \n-#include <setjmp.h>\t\t/* set_float_handler argument uses it */\n-\n /* Extern global variables declarations  */\n extern FILE *finput;\n extern int   lineno;\n@@ -172,7 +170,6 @@ extern void java_destroy_lexer PARAMS ((java_lexer *));\n \n #define DCONST0 0\n #define REAL_VALUE_TYPE int\n-#define SET_FLOAT_HANDLER(H)\n #define GET_IDENTIFIER(S) xstrdup ((S))\n #define REAL_VALUE_ATOF(LIT,MODE) 0\n #define REAL_VALUE_ISINF(VALUE)   0\n@@ -192,8 +189,6 @@ extern void java_destroy_lexer PARAMS ((java_lexer *));\n \n #else\n \n-extern void set_float_handler PARAMS ((jmp_buf));\n-#define SET_FLOAT_HANDLER(H) set_float_handler ((H))\n #define DCONST0 dconst0\n #define GET_IDENTIFIER(S) get_identifier ((S))\n #define SET_REAL_VALUE_ATOF(TARGET,SOURCE) (TARGET) = (SOURCE)"}, {"sha": "08adde25963bb99abcb106bd621524a1e2ee8d39", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 187, "deletions": 144, "changes": 331, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94aca342987fa4c024f4aaa32c72715787ab84e5/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94aca342987fa4c024f4aaa32c72715787ab84e5/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=94aca342987fa4c024f4aaa32c72715787ab84e5", "patch": "@@ -22,7 +22,6 @@ Boston, MA 02111-1307, USA.  */\n \n #include \"config.h\"\n #include \"system.h\"\n-#include <setjmp.h>\n \n #include \"rtl.h\"\n #include \"tm_p.h\"\n@@ -99,6 +98,12 @@ Boston, MA 02111-1307, USA.  */\n static rtx simplify_plus_minus\t\tPARAMS ((enum rtx_code,\n \t\t\t\t\t\t enum machine_mode, rtx, rtx));\n static void check_fold_consts\t\tPARAMS ((PTR));\n+#if ! defined (REAL_IS_NOT_DOUBLE) || defined (REAL_ARITHMETIC)\n+static void simplify_unary_real\t\tPARAMS ((PTR));\n+static void simplify_binary_real\tPARAMS ((PTR));\n+#endif\n+static void simplify_binary_is2orm1\tPARAMS ((PTR));\n+\n \f\n /* Make a binary operation by properly ordering the operands and \n    seeing if the expression folds.  */\n@@ -324,10 +329,70 @@ simplify_replace_rtx (x, old, new)\n   return x;\n }\n \f\n+#if ! defined (REAL_IS_NOT_DOUBLE) || defined (REAL_ARITHMETIC)\n+/* Subroutine of simplify_unary_operation, called via do_float_handler.\n+   Handles simplification of unary ops on floating point values.  */\n+struct simplify_unary_real_args\n+{\n+  rtx operand;\n+  rtx result;\n+  enum machine_mode mode;\n+  enum rtx_code code;\n+  bool want_integer;\n+};\n+#define REAL_VALUE_ABS(d_) \\\n+   (REAL_VALUE_NEGATIVE (d_) ? REAL_VALUE_NEGATE (d_) : (d_))\n+\n+static void\n+simplify_unary_real (p)\n+     PTR p;\n+{\n+  REAL_VALUE_TYPE d;\n+\n+  struct simplify_unary_real_args *args =\n+    (struct simplify_unary_real_args *) p;\n+\n+  REAL_VALUE_FROM_CONST_DOUBLE (d, args->operand);\n+\n+  if (args->want_integer)\n+    {\n+      HOST_WIDE_INT i;\n+\n+      switch (args->code)\n+\t{\n+\tcase FIX:\t\ti = REAL_VALUE_FIX (d);\t\t  break;\n+\tcase UNSIGNED_FIX:\ti = REAL_VALUE_UNSIGNED_FIX (d);  break;\n+\tdefault:\n+\t  abort ();\n+\t}\n+      args->result = GEN_INT (trunc_int_for_mode (i, args->mode));\n+    }\n+  else\n+    {\n+      switch (args->code)\n+\t{\n+\tcase SQRT:\n+\t  /* We don't attempt to optimize this.  */\n+\t  args->result = 0;\n+\t  return;\n+\n+\tcase ABS:\t      d = REAL_VALUE_ABS (d);\t\t\tbreak;\n+\tcase NEG:\t      d = REAL_VALUE_NEGATE (d);\t\tbreak;\n+\tcase FLOAT_TRUNCATE:  d = real_value_truncate (args->mode, d);  break;\n+\tcase FLOAT_EXTEND:    /* All this does is change the mode.  */  break;\n+\tcase FIX:\t      d = REAL_VALUE_RNDZINT (d);\t\tbreak;\n+\tcase UNSIGNED_FIX:    d = REAL_VALUE_UNSIGNED_RNDZINT (d);\tbreak;\n+\tdefault:\n+\t  abort ();\n+\t}\n+      args->result = CONST_DOUBLE_FROM_REAL_VALUE (d, args->mode);\n+    }\n+}\n+#endif\n+\n /* Try to simplify a unary operation CODE whose output mode is to be\n    MODE with input operand OP whose mode was originally OP_MODE.\n    Return zero if no simplification can be made.  */\n-\n rtx\n simplify_unary_operation (code, mode, op, op_mode)\n      enum rtx_code code;\n@@ -586,94 +651,33 @@ simplify_unary_operation (code, mode, op, op_mode)\n   else if (GET_CODE (trueop) == CONST_DOUBLE\n \t   && GET_MODE_CLASS (mode) == MODE_FLOAT)\n     {\n-      REAL_VALUE_TYPE d;\n-      jmp_buf handler;\n-      rtx x;\n-\n-      if (setjmp (handler))\n-\t/* There used to be a warning here, but that is inadvisable.\n-\t   People may want to cause traps, and the natural way\n-\t   to do it should not get a warning.  */\n-\treturn 0;\n-\n-      set_float_handler (handler);\n-\n-      REAL_VALUE_FROM_CONST_DOUBLE (d, trueop);\n-\n-      switch (code)\n-\t{\n-\tcase NEG:\n-\t  d = REAL_VALUE_NEGATE (d);\n-\t  break;\n+      struct simplify_unary_real_args args;\n+      args.operand = trueop;\n+      args.mode = mode;\n+      args.code = code;\n+      args.want_integer = false;\n \n-\tcase ABS:\n-\t  if (REAL_VALUE_NEGATIVE (d))\n-\t    d = REAL_VALUE_NEGATE (d);\n-\t  break;\n-\n-\tcase FLOAT_TRUNCATE:\n-\t  d = real_value_truncate (mode, d);\n-\t  break;\n+      if (do_float_handler (simplify_unary_real, (PTR) &args))\n+\treturn args.result;\n \n-\tcase FLOAT_EXTEND:\n-\t  /* All this does is change the mode.  */\n-\t  break;\n-\n-\tcase FIX:\n-\t  d = REAL_VALUE_RNDZINT (d);\n-\t  break;\n-\n-\tcase UNSIGNED_FIX:\n-\t  d = REAL_VALUE_UNSIGNED_RNDZINT (d);\n-\t  break;\n-\n-\tcase SQRT:\n-\t  return 0;\n-\n-\tdefault:\n-\t  abort ();\n-\t}\n-\n-      x = CONST_DOUBLE_FROM_REAL_VALUE (d, mode);\n-      set_float_handler (NULL);\n-      return x;\n+      return 0;\n     }\n \n   else if (GET_CODE (trueop) == CONST_DOUBLE\n \t   && GET_MODE_CLASS (GET_MODE (trueop)) == MODE_FLOAT\n \t   && GET_MODE_CLASS (mode) == MODE_INT\n \t   && width <= HOST_BITS_PER_WIDE_INT && width > 0)\n     {\n-      REAL_VALUE_TYPE d;\n-      jmp_buf handler;\n-      HOST_WIDE_INT val;\n-\n-      if (setjmp (handler))\n-\treturn 0;\n-\n-      set_float_handler (handler);\n-\n-      REAL_VALUE_FROM_CONST_DOUBLE (d, trueop);\n-\n-      switch (code)\n-\t{\n-\tcase FIX:\n-\t  val = REAL_VALUE_FIX (d);\n-\t  break;\n-\n-\tcase UNSIGNED_FIX:\n-\t  val = REAL_VALUE_UNSIGNED_FIX (d);\n-\t  break;\n-\n-\tdefault:\n-\t  abort ();\n-\t}\n+      struct simplify_unary_real_args args;\n+      args.operand = trueop;\n+      args.mode = mode;\n+      args.code = code;\n+      args.want_integer = true;\n \n-      set_float_handler (NULL);\n+      if (do_float_handler (simplify_unary_real, (PTR) &args))\n+\treturn args.result;\n \n-      val = trunc_int_for_mode (val, mode);\n-\n-      return GEN_INT (val);\n+      return 0;\n     }\n #endif\n   /* This was formerly used only for non-IEEE float.\n@@ -749,12 +753,101 @@ simplify_unary_operation (code, mode, op, op_mode)\n     }\n }\n \f\n+#if ! defined (REAL_IS_NOT_DOUBLE) || defined (REAL_ARITHMETIC)\n+/* Subroutine of simplify_binary_operation, called via do_float_handler.\n+   Handles simplification of binary ops on floating point values.  */\n+struct simplify_binary_real_args\n+{\n+  rtx trueop0, trueop1;\n+  rtx result;\n+  enum rtx_code code;\n+  enum machine_mode mode;\n+};\n+\n+static void\n+simplify_binary_real (p)\n+     PTR p;\n+{\n+  REAL_VALUE_TYPE f0, f1, value;\n+  struct simplify_binary_real_args *args =\n+    (struct simplify_binary_real_args *) p;\n+\n+  REAL_VALUE_FROM_CONST_DOUBLE (f0, args->trueop0);\n+  REAL_VALUE_FROM_CONST_DOUBLE (f1, args->trueop1);\n+  f0 = real_value_truncate (args->mode, f0);\n+  f1 = real_value_truncate (args->mode, f1);\n+\n+#ifdef REAL_ARITHMETIC\n+#ifndef REAL_INFINITY\n+  if (args->code == DIV && REAL_VALUES_EQUAL (f1, dconst0))\n+    {\n+      args->result = 0;\n+      return;\n+    }\n+#endif\n+  REAL_ARITHMETIC (value, rtx_to_tree_code (args->code), f0, f1);\n+#else\n+  switch (args->code)\n+    {\n+    case PLUS:\n+      value = f0 + f1;\n+      break;\n+    case MINUS:\n+      value = f0 - f1;\n+      break;\n+    case MULT:\n+      value = f0 * f1;\n+      break;\n+    case DIV:\n+#ifndef REAL_INFINITY\n+      if (f1 == 0)\n+\treturn 0;\n+#endif\n+      value = f0 / f1;\n+      break;\n+    case SMIN:\n+      value = MIN (f0, f1);\n+      break;\n+    case SMAX:\n+      value = MAX (f0, f1);\n+      break;\n+    default:\n+      abort ();\n+    }\n+#endif\n+\n+  value = real_value_truncate (args->mode, value);\n+  args->result = CONST_DOUBLE_FROM_REAL_VALUE (value, args->mode);\n+}\n+#endif\n+\n+/* Another subroutine called via do_float_handler.  This one tests\n+   the floating point value given against 2. and -1.  */\n+struct simplify_binary_is2orm1_args\n+{\n+  rtx value;\n+  bool is_2;\n+  bool is_m1;\n+};\n+\n+static void\n+simplify_binary_is2orm1 (p)\n+     PTR p;\n+{\n+  REAL_VALUE_TYPE d;\n+  struct simplify_binary_is2orm1_args *args =\n+    (struct simplify_binary_is2orm1_args *) p;\n+\n+  REAL_VALUE_FROM_CONST_DOUBLE (d, args->value);\n+  args->is_2 = REAL_VALUES_EQUAL (d, dconst2);\n+  args->is_m1 = REAL_VALUES_EQUAL (d, dconstm1);\n+}\n+\n /* Simplify a binary operation CODE with result mode MODE, operating on OP0\n    and OP1.  Return 0 if no simplification is possible.\n \n    Don't use this for relational operations such as EQ or LT.\n    Use simplify_relational_operation instead.  */\n-\n rtx\n simplify_binary_operation (code, mode, op0, op1)\n      enum rtx_code code;\n@@ -790,58 +883,15 @@ simplify_binary_operation (code, mode, op0, op1)\n       && GET_CODE (trueop1) == CONST_DOUBLE\n       && mode == GET_MODE (op0) && mode == GET_MODE (op1))\n     {\n-      REAL_VALUE_TYPE f0, f1, value;\n-      jmp_buf handler;\n-\n-      if (setjmp (handler))\n-\treturn 0;\n-\n-      set_float_handler (handler);\n-\n-      REAL_VALUE_FROM_CONST_DOUBLE (f0, trueop0);\n-      REAL_VALUE_FROM_CONST_DOUBLE (f1, trueop1);\n-      f0 = real_value_truncate (mode, f0);\n-      f1 = real_value_truncate (mode, f1);\n-\n-#ifdef REAL_ARITHMETIC\n-#ifndef REAL_INFINITY\n-      if (code == DIV && REAL_VALUES_EQUAL (f1, dconst0))\n-\treturn 0;\n-#endif\n-      REAL_ARITHMETIC (value, rtx_to_tree_code (code), f0, f1);\n-#else\n-      switch (code)\n-\t{\n-\tcase PLUS:\n-\t  value = f0 + f1;\n-\t  break;\n-\tcase MINUS:\n-\t  value = f0 - f1;\n-\t  break;\n-\tcase MULT:\n-\t  value = f0 * f1;\n-\t  break;\n-\tcase DIV:\n-#ifndef REAL_INFINITY\n-\t  if (f1 == 0)\n-\t    return 0;\n-#endif\n-\t  value = f0 / f1;\n-\t  break;\n-\tcase SMIN:\n-\t  value = MIN (f0, f1);\n-\t  break;\n-\tcase SMAX:\n-\t  value = MAX (f0, f1);\n-\t  break;\n-\tdefault:\n-\t  abort ();\n-\t}\n-#endif\n-\n-      value = real_value_truncate (mode, value);\n-      set_float_handler (NULL);\n-      return CONST_DOUBLE_FROM_REAL_VALUE (value, mode);\n+      struct simplify_binary_real_args args;\n+      args.trueop0 = trueop0;\n+      args.trueop1 = trueop1;\n+      args.mode = mode;\n+      args.code = code;\n+\n+      if (do_float_handler (simplify_binary_real, (PTR) &args))\n+\treturn args.result;\n+      return 0;\n     }\n #endif  /* not REAL_IS_NOT_DOUBLE, or REAL_ARITHMETIC */\n \n@@ -1263,24 +1313,17 @@ simplify_binary_operation (code, mode, op0, op1)\n \t  if (GET_CODE (trueop1) == CONST_DOUBLE\n \t      && GET_MODE_CLASS (GET_MODE (trueop1)) == MODE_FLOAT)\n \t    {\n-\t      REAL_VALUE_TYPE d;\n-\t      jmp_buf handler;\n-\t      int op1is2, op1ism1;\n+\t      struct simplify_binary_is2orm1_args args;\n \n-\t      if (setjmp (handler))\n+\t      args.value = trueop1;\n+\t      if (! do_float_handler (simplify_binary_is2orm1, (PTR) &args))\n \t\treturn 0;\n \n-\t      set_float_handler (handler);\n-\t      REAL_VALUE_FROM_CONST_DOUBLE (d, trueop1);\n-\t      op1is2 = REAL_VALUES_EQUAL (d, dconst2);\n-\t      op1ism1 = REAL_VALUES_EQUAL (d, dconstm1);\n-\t      set_float_handler (NULL);\n-\n \t      /* x*2 is x+x and x*(-1) is -x */\n-\t      if (op1is2 && GET_MODE (op0) == mode)\n+\t      if (args.is_2 && GET_MODE (op0) == mode)\n \t\treturn gen_rtx_PLUS (mode, op0, copy_rtx (op0));\n \n-\t      else if (op1ism1 && GET_MODE (op0) == mode)\n+\t      else if (args.is_m1 && GET_MODE (op0) == mode)\n \t\treturn gen_rtx_NEG (mode, op0);\n \t    }\n \t  break;"}, {"sha": "576462647049689f8ed9c41477bc9adb981f57be", "filename": "gcc/toplev.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94aca342987fa4c024f4aaa32c72715787ab84e5/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94aca342987fa4c024f4aaa32c72715787ab84e5/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=94aca342987fa4c024f4aaa32c72715787ab84e5", "patch": "@@ -161,6 +161,7 @@ static const char *decl_name PARAMS ((tree, int));\n \n static void float_signal PARAMS ((int)) ATTRIBUTE_NORETURN;\n static void crash_signal PARAMS ((int)) ATTRIBUTE_NORETURN;\n+static void set_float_handler PARAMS ((jmp_buf));\n static void compile_file PARAMS ((const char *));\n static void display_help PARAMS ((void));\n static void display_target_options PARAMS ((void));\n@@ -1679,7 +1680,7 @@ float_signal (signo)\n /* Specify where to longjmp to when a floating arithmetic error happens.\n    If HANDLER is 0, it means don't handle the errors any more.  */\n \n-void\n+static void\n set_float_handler (handler)\n      jmp_buf handler;\n {"}, {"sha": "bc9b1608c625832194224995a7a4f829db24e2f2", "filename": "gcc/toplev.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94aca342987fa4c024f4aaa32c72715787ab84e5/gcc%2Ftoplev.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94aca342987fa4c024f4aaa32c72715787ab84e5/gcc%2Ftoplev.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.h?ref=94aca342987fa4c024f4aaa32c72715787ab84e5", "patch": "@@ -102,9 +102,6 @@ extern void error_for_asm\t\tPARAMS ((struct rtx_def *,\n extern void warning_for_asm\t\tPARAMS ((struct rtx_def *,\n \t\t\t\t\t\t const char *, ...))\n \t\t\t\t\t       ATTRIBUTE_PRINTF_2;\n-#if defined (_JBLEN) || defined (setjmp)\n-extern void set_float_handler PARAMS ((jmp_buf));\n-#endif\n extern int do_float_handler PARAMS ((void (*) (PTR), PTR));\n \n #ifdef BUFSIZ"}, {"sha": "5f2810aca4de55f7e6cdd2bc2267a302eac6ffa9", "filename": "gcc/varasm.c", "status": "modified", "additions": 32, "deletions": 26, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94aca342987fa4c024f4aaa32c72715787ab84e5/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94aca342987fa4c024f4aaa32c72715787ab84e5/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=94aca342987fa4c024f4aaa32c72715787ab84e5", "patch": "@@ -29,7 +29,6 @@ Boston, MA 02111-1307, USA.  */\n \n #include \"config.h\"\n #include \"system.h\"\n-#include <setjmp.h>\n #include \"rtl.h\"\n #include \"tree.h\"\n #include \"flags.h\"\n@@ -138,6 +137,7 @@ tree last_assemble_variable_decl;\n \n static const char *strip_reg_name\tPARAMS ((const char *));\n static int contains_pointers_p\t\tPARAMS ((tree));\n+static void assemble_real_1\t\tPARAMS ((PTR));\n static void decode_addr_const\t\tPARAMS ((tree, struct addr_const *));\n static int const_hash\t\t\tPARAMS ((tree));\n static int compare_constant\t\tPARAMS ((tree,\n@@ -1798,68 +1798,74 @@ assemble_integer (x, size, force)\n }\n \f\n /* Assemble the floating-point constant D into an object of size MODE.  */\n-\n-void\n-assemble_real (d, mode)\n-     REAL_VALUE_TYPE d;\n-     enum machine_mode mode;\n+struct assemble_real_args\n {\n-  jmp_buf output_constant_handler;\n-\n-  if (setjmp (output_constant_handler))\n-    {\n-      error (\"floating point trap outputting a constant\");\n-#ifdef REAL_IS_NOT_DOUBLE\n-      memset ((char *) &d, 0, sizeof d);\n-      d = dconst0;\n-#else\n-      d = 0;\n-#endif\n-    }\n+  REAL_VALUE_TYPE *d;\n+  enum machine_mode mode;\n+};\n \n-  set_float_handler (output_constant_handler);\n+static void\n+assemble_real_1 (p)\n+     PTR p;\n+{\n+  struct assemble_real_args *args = (struct assemble_real_args *) p;\n+  REAL_VALUE_TYPE *d = args->d;\n+  enum machine_mode mode = args->mode;\n \n   switch (mode)\n     {\n #ifdef ASM_OUTPUT_BYTE_FLOAT\n     case QFmode:\n-      ASM_OUTPUT_BYTE_FLOAT (asm_out_file, d);\n+      ASM_OUTPUT_BYTE_FLOAT (asm_out_file, *d);\n       break;\n #endif\n #ifdef ASM_OUTPUT_SHORT_FLOAT\n     case HFmode:\n-      ASM_OUTPUT_SHORT_FLOAT (asm_out_file, d);\n+      ASM_OUTPUT_SHORT_FLOAT (asm_out_file, *d);\n       break;\n #endif\n #ifdef ASM_OUTPUT_THREE_QUARTER_FLOAT\n     case TQFmode:\n-      ASM_OUTPUT_THREE_QUARTER_FLOAT (asm_out_file, d);\n+      ASM_OUTPUT_THREE_QUARTER_FLOAT (asm_out_file, *d);\n       break;\n #endif\n #ifdef ASM_OUTPUT_FLOAT\n     case SFmode:\n-      ASM_OUTPUT_FLOAT (asm_out_file, d);\n+      ASM_OUTPUT_FLOAT (asm_out_file, *d);\n       break;\n #endif\n \n #ifdef ASM_OUTPUT_DOUBLE\n     case DFmode:\n-      ASM_OUTPUT_DOUBLE (asm_out_file, d);\n+      ASM_OUTPUT_DOUBLE (asm_out_file, *d);\n       break;\n #endif\n \n #ifdef ASM_OUTPUT_LONG_DOUBLE\n     case XFmode:\n     case TFmode:\n-      ASM_OUTPUT_LONG_DOUBLE (asm_out_file, d);\n+      ASM_OUTPUT_LONG_DOUBLE (asm_out_file, *d);\n       break;\n #endif\n \n     default:\n       abort ();\n     }\n+}\n+\n+void\n+assemble_real (d, mode)\n+     REAL_VALUE_TYPE d;\n+     enum machine_mode mode;\n+{\n+  struct assemble_real_args args;\n+  args.d = &d;\n+  args.mode = mode;\n+\n+  if (do_float_handler (assemble_real_1, (PTR) &args))\n+    return;\n \n-  set_float_handler (NULL);\n+  internal_error (\"floating point trap outputting a constant\");\n }\n \f\n /* Here we combine duplicate floating constants to make"}]}