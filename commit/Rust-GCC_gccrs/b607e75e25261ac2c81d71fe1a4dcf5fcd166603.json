{"sha": "b607e75e25261ac2c81d71fe1a4dcf5fcd166603", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjYwN2U3NWUyNTI2MWFjMmM4MWQ3MWZlMWE0ZGNmNWZjZDE2NjYwMw==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2017-02-23T07:49:06Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2017-02-23T07:49:06Z"}, "message": "re PR middle-end/79665 (gcc's signed (x*x)/200 is slower than clang's)\n\n\tPR middle-end/79665\n\t* internal-fn.c (get_range_pos_neg): Moved to ...\n\t* tree.c (get_range_pos_neg): ... here.  No longer static.\n\t* tree.h (get_range_pos_neg): New prototype.\n\t* expr.c (expand_expr_real_2) <case TRUNC_DIV_EXPR>: If both arguments\n\tare known to be in between 0 and signed maximum inclusive, try to\n\texpand both unsigned and signed divmod and use the cheaper one from\n\tthose.\n\nFrom-SVN: r245676", "tree": {"sha": "c83ce2682d44020d9ccc173ce01b86a17929c8a2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c83ce2682d44020d9ccc173ce01b86a17929c8a2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b607e75e25261ac2c81d71fe1a4dcf5fcd166603", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b607e75e25261ac2c81d71fe1a4dcf5fcd166603", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b607e75e25261ac2c81d71fe1a4dcf5fcd166603", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b607e75e25261ac2c81d71fe1a4dcf5fcd166603/comments", "author": null, "committer": null, "parents": [{"sha": "18eb304e5f35d745dcb1a9bb41a2879a364f59fe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/18eb304e5f35d745dcb1a9bb41a2879a364f59fe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/18eb304e5f35d745dcb1a9bb41a2879a364f59fe"}], "stats": {"total": 204, "additions": 123, "deletions": 81}, "files": [{"sha": "50566cc86853aeaaf74e526b4a2d15c09e67016a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b607e75e25261ac2c81d71fe1a4dcf5fcd166603/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b607e75e25261ac2c81d71fe1a4dcf5fcd166603/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b607e75e25261ac2c81d71fe1a4dcf5fcd166603", "patch": "@@ -1,4 +1,15 @@\n-2017-02-22 Jeff Law  <law@redhat.com>\n+2017-02-23  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR middle-end/79665\n+\t* internal-fn.c (get_range_pos_neg): Moved to ...\n+\t* tree.c (get_range_pos_neg): ... here.  No longer static.\n+\t* tree.h (get_range_pos_neg): New prototype.\n+\t* expr.c (expand_expr_real_2) <case TRUNC_DIV_EXPR>: If both arguments\n+\tare known to be in between 0 and signed maximum inclusive, try to\n+\texpand both unsigned and signed divmod and use the cheaper one from\n+\tthose.\n+\n+2017-02-22  Jeff Law  <law@redhat.com>\n \n \tPR tree-optimization/79578\n \t* tree-ssa-dse.c (clear_bytes_written_by): Use operand_equal_p"}, {"sha": "34bbf3d7b47f5fdae0871c104a49b4f10773b7ee", "filename": "gcc/expr.c", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b607e75e25261ac2c81d71fe1a4dcf5fcd166603/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b607e75e25261ac2c81d71fe1a4dcf5fcd166603/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=b607e75e25261ac2c81d71fe1a4dcf5fcd166603", "patch": "@@ -8809,6 +8809,34 @@ expand_expr_real_2 (sepops ops, rtx target, machine_mode tmode,\n \t where some terms of the dividend have coeffs divisible by it.  */\n       expand_operands (treeop0, treeop1,\n \t\t       subtarget, &op0, &op1, EXPAND_NORMAL);\n+      if (SCALAR_INT_MODE_P (mode)\n+\t  && optimize >= 2\n+\t  && get_range_pos_neg (treeop0) == 1\n+\t  && get_range_pos_neg (treeop1) == 1)\n+\t{\n+\t  /* If both arguments are known to be positive when interpreted\n+\t     as signed, we can expand it as both signed and unsigned\n+\t     division or modulo.  Choose the cheaper sequence in that case.  */\n+\t  bool speed_p = optimize_insn_for_speed_p ();\n+\t  do_pending_stack_adjust ();\n+\t  start_sequence ();\n+\t  rtx uns_ret = expand_divmod (0, code, mode, op0, op1, target, 1);\n+\t  rtx_insn *uns_insns = get_insns ();\n+\t  end_sequence ();\n+\t  start_sequence ();\n+\t  rtx sgn_ret = expand_divmod (0, code, mode, op0, op1, target, 0);\n+\t  rtx_insn *sgn_insns = get_insns ();\n+\t  end_sequence ();\n+\t  unsigned uns_cost = seq_cost (uns_insns, speed_p);\n+\t  unsigned sgn_cost = seq_cost (sgn_insns, speed_p);\n+\t  if (uns_cost < sgn_cost || (uns_cost == sgn_cost && unsignedp))\n+\t    {\n+\t      emit_insn (uns_insns);\n+\t      return uns_ret;\n+\t    }\n+\t  emit_insn (sgn_insns);\n+\t  return sgn_ret;\n+\t}\n       return expand_divmod (0, code, mode, op0, op1, target, unsignedp);\n \n     case RDIV_EXPR:"}, {"sha": "ffe291d62cf5936af2acc81e0c2efd7103966198", "filename": "gcc/internal-fn.c", "status": "modified", "additions": 0, "deletions": 80, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b607e75e25261ac2c81d71fe1a4dcf5fcd166603/gcc%2Finternal-fn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b607e75e25261ac2c81d71fe1a4dcf5fcd166603/gcc%2Finternal-fn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.c?ref=b607e75e25261ac2c81d71fe1a4dcf5fcd166603", "patch": "@@ -413,86 +413,6 @@ expand_FALLTHROUGH (internal_fn, gcall *call)\n \t    \"invalid use of attribute %<fallthrough%>\");\n }\n \n-/* Helper function for expand_addsub_overflow.  Return 1\n-   if ARG interpreted as signed in its precision is known to be always\n-   positive or 2 if ARG is known to be always negative, or 3 if ARG may\n-   be positive or negative.  */\n-\n-static int\n-get_range_pos_neg (tree arg)\n-{\n-  if (arg == error_mark_node)\n-    return 3;\n-\n-  int prec = TYPE_PRECISION (TREE_TYPE (arg));\n-  int cnt = 0;\n-  if (TREE_CODE (arg) == INTEGER_CST)\n-    {\n-      wide_int w = wi::sext (arg, prec);\n-      if (wi::neg_p (w))\n-\treturn 2;\n-      else\n-\treturn 1;\n-    }\n-  while (CONVERT_EXPR_P (arg)\n-\t && INTEGRAL_TYPE_P (TREE_TYPE (TREE_OPERAND (arg, 0)))\n-\t && TYPE_PRECISION (TREE_TYPE (TREE_OPERAND (arg, 0))) <= prec)\n-    {\n-      arg = TREE_OPERAND (arg, 0);\n-      /* Narrower value zero extended into wider type\n-\t will always result in positive values.  */\n-      if (TYPE_UNSIGNED (TREE_TYPE (arg))\n-\t  && TYPE_PRECISION (TREE_TYPE (arg)) < prec)\n-\treturn 1;\n-      prec = TYPE_PRECISION (TREE_TYPE (arg));\n-      if (++cnt > 30)\n-\treturn 3;\n-    }\n-\n-  if (TREE_CODE (arg) != SSA_NAME)\n-    return 3;\n-  wide_int arg_min, arg_max;\n-  while (get_range_info (arg, &arg_min, &arg_max) != VR_RANGE)\n-    {\n-      gimple *g = SSA_NAME_DEF_STMT (arg);\n-      if (is_gimple_assign (g)\n-\t  && CONVERT_EXPR_CODE_P (gimple_assign_rhs_code (g)))\n-\t{\n-\t  tree t = gimple_assign_rhs1 (g);\n-\t  if (INTEGRAL_TYPE_P (TREE_TYPE (t))\n-\t      && TYPE_PRECISION (TREE_TYPE (t)) <= prec)\n-\t    {\n-\t      if (TYPE_UNSIGNED (TREE_TYPE (t))\n-\t\t  && TYPE_PRECISION (TREE_TYPE (t)) < prec)\n-\t\treturn 1;\n-\t      prec = TYPE_PRECISION (TREE_TYPE (t));\n-\t      arg = t;\n-\t      if (++cnt > 30)\n-\t\treturn 3;\n-\t      continue;\n-\t    }\n-\t}\n-      return 3;\n-    }\n-  if (TYPE_UNSIGNED (TREE_TYPE (arg)))\n-    {\n-      /* For unsigned values, the \"positive\" range comes\n-\t below the \"negative\" range.  */\n-      if (!wi::neg_p (wi::sext (arg_max, prec), SIGNED))\n-\treturn 1;\n-      if (wi::neg_p (wi::sext (arg_min, prec), SIGNED))\n-\treturn 2;\n-    }\n-  else\n-    {\n-      if (!wi::neg_p (wi::sext (arg_min, prec), SIGNED))\n-\treturn 1;\n-      if (wi::neg_p (wi::sext (arg_max, prec), SIGNED))\n-\treturn 2;\n-    }\n-  return 3;\n-}\n-\n /* Return minimum precision needed to represent all values\n    of ARG in SIGNed integral type.  */\n "}, {"sha": "42c8a2ddd8a50106e87c92bf160431d8ea66cedc", "filename": "gcc/tree.c", "status": "modified", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b607e75e25261ac2c81d71fe1a4dcf5fcd166603/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b607e75e25261ac2c81d71fe1a4dcf5fcd166603/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=b607e75e25261ac2c81d71fe1a4dcf5fcd166603", "patch": "@@ -14205,6 +14205,88 @@ verify_type (const_tree t)\n }\n \n \n+/* Return 1 if ARG interpreted as signed in its precision is known to be\n+   always positive or 2 if ARG is known to be always negative, or 3 if\n+   ARG may be positive or negative.  */\n+\n+int\n+get_range_pos_neg (tree arg)\n+{\n+  if (arg == error_mark_node)\n+    return 3;\n+\n+  int prec = TYPE_PRECISION (TREE_TYPE (arg));\n+  int cnt = 0;\n+  if (TREE_CODE (arg) == INTEGER_CST)\n+    {\n+      wide_int w = wi::sext (arg, prec);\n+      if (wi::neg_p (w))\n+\treturn 2;\n+      else\n+\treturn 1;\n+    }\n+  while (CONVERT_EXPR_P (arg)\n+\t && INTEGRAL_TYPE_P (TREE_TYPE (TREE_OPERAND (arg, 0)))\n+\t && TYPE_PRECISION (TREE_TYPE (TREE_OPERAND (arg, 0))) <= prec)\n+    {\n+      arg = TREE_OPERAND (arg, 0);\n+      /* Narrower value zero extended into wider type\n+\t will always result in positive values.  */\n+      if (TYPE_UNSIGNED (TREE_TYPE (arg))\n+\t  && TYPE_PRECISION (TREE_TYPE (arg)) < prec)\n+\treturn 1;\n+      prec = TYPE_PRECISION (TREE_TYPE (arg));\n+      if (++cnt > 30)\n+\treturn 3;\n+    }\n+\n+  if (TREE_CODE (arg) != SSA_NAME)\n+    return 3;\n+  wide_int arg_min, arg_max;\n+  while (get_range_info (arg, &arg_min, &arg_max) != VR_RANGE)\n+    {\n+      gimple *g = SSA_NAME_DEF_STMT (arg);\n+      if (is_gimple_assign (g)\n+\t  && CONVERT_EXPR_CODE_P (gimple_assign_rhs_code (g)))\n+\t{\n+\t  tree t = gimple_assign_rhs1 (g);\n+\t  if (INTEGRAL_TYPE_P (TREE_TYPE (t))\n+\t      && TYPE_PRECISION (TREE_TYPE (t)) <= prec)\n+\t    {\n+\t      if (TYPE_UNSIGNED (TREE_TYPE (t))\n+\t\t  && TYPE_PRECISION (TREE_TYPE (t)) < prec)\n+\t\treturn 1;\n+\t      prec = TYPE_PRECISION (TREE_TYPE (t));\n+\t      arg = t;\n+\t      if (++cnt > 30)\n+\t\treturn 3;\n+\t      continue;\n+\t    }\n+\t}\n+      return 3;\n+    }\n+  if (TYPE_UNSIGNED (TREE_TYPE (arg)))\n+    {\n+      /* For unsigned values, the \"positive\" range comes\n+\t below the \"negative\" range.  */\n+      if (!wi::neg_p (wi::sext (arg_max, prec), SIGNED))\n+\treturn 1;\n+      if (wi::neg_p (wi::sext (arg_min, prec), SIGNED))\n+\treturn 2;\n+    }\n+  else\n+    {\n+      if (!wi::neg_p (wi::sext (arg_min, prec), SIGNED))\n+\treturn 1;\n+      if (wi::neg_p (wi::sext (arg_max, prec), SIGNED))\n+\treturn 2;\n+    }\n+  return 3;\n+}\n+\n+\n+\n+\n /* Return true if ARG is marked with the nonnull attribute in the\n    current function signature.  */\n "}, {"sha": "aa137e4132bb5c5ca3f397a51b475307c7ab91b6", "filename": "gcc/tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b607e75e25261ac2c81d71fe1a4dcf5fcd166603/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b607e75e25261ac2c81d71fe1a4dcf5fcd166603/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=b607e75e25261ac2c81d71fe1a4dcf5fcd166603", "patch": "@@ -4876,6 +4876,7 @@ extern bool gimple_canonical_types_compatible_p (const_tree, const_tree,\n \t\t\t\t\t\t bool trust_type_canonical = true);\n extern bool type_with_interoperable_signedness (const_tree);\n extern bitmap get_nonnull_args (const_tree);\n+extern int get_range_pos_neg (tree);\n \n /* Return simplified tree code of type that is used for canonical type\n    merging.  */"}]}