{"sha": "2a5195d96565c6886fe9a686ecd4cbb2fa5c0e0b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmE1MTk1ZDk2NTY1YzY4ODZmZTlhNjg2ZWNkNGNiYjJmYTVjMGUwYg==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "iant@google.com", "date": "2013-01-01T16:13:20Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2013-01-01T16:13:20Z"}, "message": "re PR other/55536 (libbacktrace abort in backtrace_alloc at mmap.c:99 running btest)\n\n\tPR other/55536\n\t* mmap.c (backtrace_alloc): Don't call sync functions if not\n\tthreaded.\n\t(backtrace_free): Likewise.\n\nFrom-SVN: r194768", "tree": {"sha": "0ea7c16439b042c659c442ddc5377a98e78a3747", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0ea7c16439b042c659c442ddc5377a98e78a3747"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2a5195d96565c6886fe9a686ecd4cbb2fa5c0e0b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a5195d96565c6886fe9a686ecd4cbb2fa5c0e0b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2a5195d96565c6886fe9a686ecd4cbb2fa5c0e0b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a5195d96565c6886fe9a686ecd4cbb2fa5c0e0b/comments", "author": null, "committer": null, "parents": [{"sha": "459a58e1202a88680bbd0311224bcc895964832f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/459a58e1202a88680bbd0311224bcc895964832f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/459a58e1202a88680bbd0311224bcc895964832f"}], "stats": {"total": 32, "additions": 28, "deletions": 4}, "files": [{"sha": "39802c3110940a3025eb8107ad1794fb55e4f5b4", "filename": "libbacktrace/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a5195d96565c6886fe9a686ecd4cbb2fa5c0e0b/libbacktrace%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a5195d96565c6886fe9a686ecd4cbb2fa5c0e0b/libbacktrace%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2FChangeLog?ref=2a5195d96565c6886fe9a686ecd4cbb2fa5c0e0b", "patch": "@@ -1,3 +1,10 @@\n+2013-01-01  Ian Lance Taylor  <iant@google.com>\n+\n+\tPR other/55536\n+\t* mmap.c (backtrace_alloc): Don't call sync functions if not\n+\tthreaded.\n+\t(backtrace_free): Likewise.\n+\n 2012-12-12  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>\n \n \t* mmapio.c: Define MAP_FAILED if not defined.\n@@ -26,6 +33,7 @@\n \n \tPR other/55312\n \t* configure.ac: Only add -Werror if building a target library.\n+\t* configure: Rebuild.\n \n 2012-11-12  Ian Lance Taylor  <iant@google.com>\n \t    Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>"}, {"sha": "a6c730ecd23f46bb65c3a2da6b2d431df2f2c84d", "filename": "libbacktrace/mmap.c", "status": "modified", "additions": 20, "deletions": 4, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a5195d96565c6886fe9a686ecd4cbb2fa5c0e0b/libbacktrace%2Fmmap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a5195d96565c6886fe9a686ecd4cbb2fa5c0e0b/libbacktrace%2Fmmap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2Fmmap.c?ref=2a5195d96565c6886fe9a686ecd4cbb2fa5c0e0b", "patch": "@@ -84,6 +84,7 @@ backtrace_alloc (struct backtrace_state *state,\n \t\t void *data)\n {\n   void *ret;\n+  int locked;\n   struct backtrace_freelist_struct **pp;\n   size_t pagesize;\n   size_t asksize;\n@@ -96,7 +97,12 @@ backtrace_alloc (struct backtrace_state *state,\n      using mmap.  __sync_lock_test_and_set returns the old state of\n      the lock, so we have acquired it if it returns 0.  */\n \n-  if (!__sync_lock_test_and_set (&state->lock_alloc, 1))\n+  if (!state->threaded)\n+    locked = 1;\n+  else\n+    locked = __sync_lock_test_and_set (&state->lock_alloc, 1) == 0;\n+\n+  if (locked)\n     {\n       for (pp = &state->freelist; *pp != NULL; pp = &(*pp)->next)\n \t{\n@@ -120,7 +126,8 @@ backtrace_alloc (struct backtrace_state *state,\n \t    }\n \t}\n \n-      __sync_lock_release (&state->lock_alloc);\n+      if (state->threaded)\n+\t__sync_lock_release (&state->lock_alloc);\n     }\n \n   if (ret == NULL)\n@@ -154,15 +161,24 @@ backtrace_free (struct backtrace_state *state, void *addr, size_t size,\n \t\tbacktrace_error_callback error_callback ATTRIBUTE_UNUSED,\n \t\tvoid *data ATTRIBUTE_UNUSED)\n {\n+  int locked;\n+\n   /* If we can acquire the lock, add the new space to the free list.\n      If we can't acquire the lock, just leak the memory.\n      __sync_lock_test_and_set returns the old state of the lock, so we\n      have acquired it if it returns 0.  */\n-  if (!__sync_lock_test_and_set (&state->lock_alloc, 1))\n+\n+  if (!state->threaded)\n+    locked = 1;\n+  else\n+    locked = __sync_lock_test_and_set (&state->lock_alloc, 1) == 0;\n+\n+  if (locked)\n     {\n       backtrace_free_locked (state, addr, size);\n \n-      __sync_lock_release (&state->lock_alloc);\n+      if (state->threaded)\n+\t__sync_lock_release (&state->lock_alloc);\n     }\n }\n "}]}