{"sha": "3c491cab150587a6349ca9680b5bf2cc055a8137", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2M0OTFjYWIxNTA1ODdhNjM0OWNhOTY4MGI1YmYyY2MwNTVhODEzNw==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@codesourcery.com", "date": "2006-03-05T05:58:50Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2006-03-05T05:58:50Z"}, "message": "regclass.c (reg_scan_update): Remove.\n\n\t* regclass.c (reg_scan_update): Remove.\n\t(reg_scan_mark_refs): Remove the last argument.\n\t* rtl.h: Remove the prototype for reg_scan_update.\n\nFrom-SVN: r111729", "tree": {"sha": "bc710a30da5d58d25c6f160e5eba55970fe6712d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bc710a30da5d58d25c6f160e5eba55970fe6712d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3c491cab150587a6349ca9680b5bf2cc055a8137", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c491cab150587a6349ca9680b5bf2cc055a8137", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3c491cab150587a6349ca9680b5bf2cc055a8137", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c491cab150587a6349ca9680b5bf2cc055a8137/comments", "author": null, "committer": null, "parents": [{"sha": "76ddc688ca28edd4340c6e83d3bf0546474b8bb0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/76ddc688ca28edd4340c6e83d3bf0546474b8bb0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/76ddc688ca28edd4340c6e83d3bf0546474b8bb0"}], "stats": {"total": 79, "additions": 23, "deletions": 56}, "files": [{"sha": "5491d5b28613e53e91919f4b34f2cea987ab60e8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c491cab150587a6349ca9680b5bf2cc055a8137/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c491cab150587a6349ca9680b5bf2cc055a8137/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3c491cab150587a6349ca9680b5bf2cc055a8137", "patch": "@@ -1,3 +1,9 @@\n+2006-03-05  Kazu Hirata  <kazu@codesourcery.com>\n+\n+\t* regclass.c (reg_scan_update): Remove.\n+\t(reg_scan_mark_refs): Remove the last argument.\n+\t* rtl.h: Remove the prototype for reg_scan_update.\n+\n 2006-03-04  Kazu Hirata  <kazu@codesourcery.com>\n \n \t* builtins.c, c-pragma.h, c-typeck.c, cgraph.c, cgraphunit.c,"}, {"sha": "0b9fd321f215ebcd85468e4c74fb201d1dafe91a", "filename": "gcc/regclass.c", "status": "modified", "additions": 17, "deletions": 55, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c491cab150587a6349ca9680b5bf2cc055a8137/gcc%2Fregclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c491cab150587a6349ca9680b5bf2cc055a8137/gcc%2Fregclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregclass.c?ref=3c491cab150587a6349ca9680b5bf2cc055a8137", "patch": "@@ -856,7 +856,7 @@ static void record_address_regs (rtx, enum reg_class, int);\n #ifdef FORBIDDEN_INC_DEC_CLASSES\n static int auto_inc_dec_reg_p (rtx, enum machine_mode);\n #endif\n-static void reg_scan_mark_refs (rtx, rtx, int, unsigned int);\n+static void reg_scan_mark_refs (rtx, rtx, int);\n \n /* Return the reg_class in which pseudo reg number REGNO is best allocated.\n    This function is sometimes called before the info has been computed.\n@@ -2277,50 +2277,22 @@ reg_scan (rtx f, unsigned int nregs)\n \tif (GET_CODE (pat) == PARALLEL\n \t    && XVECLEN (pat, 0) > max_parallel)\n \t  max_parallel = XVECLEN (pat, 0);\n-\treg_scan_mark_refs (pat, insn, 0, 0);\n+\treg_scan_mark_refs (pat, insn, 0);\n \n \tif (REG_NOTES (insn))\n-\t  reg_scan_mark_refs (REG_NOTES (insn), insn, 1, 0);\n+\t  reg_scan_mark_refs (REG_NOTES (insn), insn, 1);\n       }\n \n   max_parallel += max_set_parallel;\n \n   timevar_pop (TV_REG_SCAN);\n }\n \n-/* Update 'regscan' information by looking at the insns\n-   from FIRST to LAST.  Some new REGs have been created,\n-   and any REG with number greater than OLD_MAX_REGNO is\n-   such a REG.  We only update information for those.  */\n-\n-void\n-reg_scan_update (rtx first, rtx last, unsigned int old_max_regno)\n-{\n-  rtx insn;\n-\n-  allocate_reg_info (max_reg_num (), FALSE, FALSE);\n-\n-  for (insn = first; insn != last; insn = NEXT_INSN (insn))\n-    if (INSN_P (insn))\n-      {\n-\trtx pat = PATTERN (insn);\n-\tif (GET_CODE (pat) == PARALLEL\n-\t    && XVECLEN (pat, 0) > max_parallel)\n-\t  max_parallel = XVECLEN (pat, 0);\n-\treg_scan_mark_refs (pat, insn, 0, old_max_regno);\n-\n-\tif (REG_NOTES (insn))\n-\t  reg_scan_mark_refs (REG_NOTES (insn), insn, 1, old_max_regno);\n-      }\n-}\n-\n /* X is the expression to scan.  INSN is the insn it appears in.\n-   NOTE_FLAG is nonzero if X is from INSN's notes rather than its body.\n-   We should only record information for REGs with numbers\n-   greater than or equal to MIN_REGNO.  */\n+   NOTE_FLAG is nonzero if X is from INSN's notes rather than its body.  */\n \n static void\n-reg_scan_mark_refs (rtx x, rtx insn, int note_flag, unsigned int min_regno)\n+reg_scan_mark_refs (rtx x, rtx insn, int note_flag)\n {\n   enum rtx_code code;\n   rtx dest;\n@@ -2347,43 +2319,35 @@ reg_scan_mark_refs (rtx x, rtx insn, int note_flag, unsigned int min_regno)\n       {\n \tunsigned int regno = REGNO (x);\n \n-\tif (regno >= min_regno)\n-\t  {\n-\t    if (!note_flag)\n-\t      REGNO_LAST_UID (regno) = INSN_UID (insn);\n-\t    if (REGNO_FIRST_UID (regno) == 0)\n-\t      REGNO_FIRST_UID (regno) = INSN_UID (insn);\n-\t    /* If we are called by reg_scan_update() (indicated by min_regno\n-\t       being set), we also need to update the reference count.  */\n-\t    if (min_regno)\n-\t      REG_N_REFS (regno)++;\n-\t  }\n+\tif (!note_flag)\n+\t  REGNO_LAST_UID (regno) = INSN_UID (insn);\n+\tif (REGNO_FIRST_UID (regno) == 0)\n+\t  REGNO_FIRST_UID (regno) = INSN_UID (insn);\n       }\n       break;\n \n     case EXPR_LIST:\n       if (XEXP (x, 0))\n-\treg_scan_mark_refs (XEXP (x, 0), insn, note_flag, min_regno);\n+\treg_scan_mark_refs (XEXP (x, 0), insn, note_flag);\n       if (XEXP (x, 1))\n-\treg_scan_mark_refs (XEXP (x, 1), insn, note_flag, min_regno);\n+\treg_scan_mark_refs (XEXP (x, 1), insn, note_flag);\n       break;\n \n     case INSN_LIST:\n       if (XEXP (x, 1))\n-\treg_scan_mark_refs (XEXP (x, 1), insn, note_flag, min_regno);\n+\treg_scan_mark_refs (XEXP (x, 1), insn, note_flag);\n       break;\n \n     case CLOBBER:\n       {\n \trtx reg = XEXP (x, 0);\n-\tif (REG_P (reg)\n-\t    && REGNO (reg) >= min_regno)\n+\tif (REG_P (reg))\n \t  {\n \t    REG_N_SETS (REGNO (reg))++;\n \t    REG_N_REFS (REGNO (reg))++;\n \t  }\n \telse if (MEM_P (reg))\n-\t  reg_scan_mark_refs (XEXP (reg, 0), insn, note_flag, min_regno);\n+\t  reg_scan_mark_refs (XEXP (reg, 0), insn, note_flag);\n       }\n       break;\n \n@@ -2400,8 +2364,7 @@ reg_scan_mark_refs (rtx x, rtx insn, int note_flag, unsigned int min_regno)\n       if (GET_CODE (dest) == PARALLEL)\n \tmax_set_parallel = MAX (max_set_parallel, XVECLEN (dest, 0) - 1);\n \n-      if (REG_P (dest)\n-\t  && REGNO (dest) >= min_regno)\n+      if (REG_P (dest))\n \t{\n \t  REG_N_SETS (REGNO (dest))++;\n \t  REG_N_REFS (REGNO (dest))++;\n@@ -2421,7 +2384,6 @@ reg_scan_mark_refs (rtx x, rtx insn, int note_flag, unsigned int min_regno)\n \n       if (REG_P (SET_DEST (x))\n \t  && REGNO (SET_DEST (x)) >= FIRST_PSEUDO_REGISTER\n-\t  && REGNO (SET_DEST (x)) >= min_regno\n \t  /* If the destination pseudo is set more than once, then other\n \t     sets might not be to a pointer value (consider access to a\n \t     union in two threads of control in the presence of global\n@@ -2482,12 +2444,12 @@ reg_scan_mark_refs (rtx x, rtx insn, int note_flag, unsigned int min_regno)\n \tfor (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n \t  {\n \t    if (fmt[i] == 'e')\n-\t      reg_scan_mark_refs (XEXP (x, i), insn, note_flag, min_regno);\n+\t      reg_scan_mark_refs (XEXP (x, i), insn, note_flag);\n \t    else if (fmt[i] == 'E' && XVEC (x, i) != 0)\n \t      {\n \t\tint j;\n \t\tfor (j = XVECLEN (x, i) - 1; j >= 0; j--)\n-\t\t  reg_scan_mark_refs (XVECEXP (x, i, j), insn, note_flag, min_regno);\n+\t\t  reg_scan_mark_refs (XVECEXP (x, i, j), insn, note_flag);\n \t      }\n \t  }\n       }"}, {"sha": "3d182f5291706a8a963344824baf2bf4e204daa9", "filename": "gcc/rtl.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c491cab150587a6349ca9680b5bf2cc055a8137/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c491cab150587a6349ca9680b5bf2cc055a8137/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=3c491cab150587a6349ca9680b5bf2cc055a8137", "patch": "@@ -2168,7 +2168,6 @@ extern void init_reg_sets (void);\n extern void regclass_init (void);\n extern void regclass (rtx, int);\n extern void reg_scan (rtx, unsigned int);\n-extern void reg_scan_update (rtx, rtx, unsigned int);\n extern void fix_register (const char *, int, int);\n extern void init_subregs_of_mode (void);\n extern void record_subregs_of_mode (rtx);"}]}