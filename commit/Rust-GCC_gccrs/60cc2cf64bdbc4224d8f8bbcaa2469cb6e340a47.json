{"sha": "60cc2cf64bdbc4224d8f8bbcaa2469cb6e340a47", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjBjYzJjZjY0YmRiYzQyMjRkOGY4YmJjYWEyNDY5Y2I2ZTM0MGE0Nw==", "commit": {"author": {"name": "Philip Herron", "email": "phil@nebuloninc.com", "date": "2020-05-16T18:10:01Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2020-11-28T19:11:55Z"}, "message": "WIP more type inferencing code for LetStmt\n\nAddresses: #12", "tree": {"sha": "90c3298f99765cd64bc67519aa55e8612f03f6dd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/90c3298f99765cd64bc67519aa55e8612f03f6dd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/60cc2cf64bdbc4224d8f8bbcaa2469cb6e340a47", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/60cc2cf64bdbc4224d8f8bbcaa2469cb6e340a47", "html_url": "https://github.com/Rust-GCC/gccrs/commit/60cc2cf64bdbc4224d8f8bbcaa2469cb6e340a47", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/60cc2cf64bdbc4224d8f8bbcaa2469cb6e340a47/comments", "author": null, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e62655562feb013d4f0e8c0823e27acb3a62101a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e62655562feb013d4f0e8c0823e27acb3a62101a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e62655562feb013d4f0e8c0823e27acb3a62101a"}], "stats": {"total": 154, "additions": 126, "deletions": 28}, "files": [{"sha": "182ea2ee13c97133ce3bacc3491a60cfc81a34a6", "filename": "gcc/rust/analysis/rust-resolution.cc", "status": "modified", "additions": 125, "deletions": 28, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60cc2cf64bdbc4224d8f8bbcaa2469cb6e340a47/gcc%2Frust%2Fanalysis%2Frust-resolution.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60cc2cf64bdbc4224d8f8bbcaa2469cb6e340a47/gcc%2Frust%2Fanalysis%2Frust-resolution.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fanalysis%2Frust-resolution.cc?ref=60cc2cf64bdbc4224d8f8bbcaa2469cb6e340a47", "patch": "@@ -4,8 +4,11 @@\n namespace Rust {\n namespace Analysis {\n \n-TypeResolution::TypeResolution (AST::Crate &crate) : scope (), crate (crate)\n+TypeResolution::TypeResolution (AST::Crate &crate) : crate (crate)\n {\n+  typeScope.Push ();\n+  scope.Push ();\n+\n   // push all builtin types\n   // base is parse_path_ident_segment based up on segments\n   /*  scope.Insert (\"u8\",\n@@ -14,7 +17,11 @@ TypeResolution::TypeResolution (AST::Crate &crate) : scope (), crate (crate)\n \t\t\t\t\tNULL, Location ()));*/\n }\n \n-TypeResolution::~TypeResolution () {}\n+TypeResolution::~TypeResolution ()\n+{\n+  typeScope.Pop ();\n+  scope.Pop ();\n+}\n \n bool\n TypeResolution::ResolveNamesAndTypes (AST::Crate &crate)\n@@ -26,22 +33,23 @@ TypeResolution::ResolveNamesAndTypes (AST::Crate &crate)\n bool\n TypeResolution::go ()\n {\n-  scope.Push ();\n   for (auto &item : crate.items)\n-    {\n-      item->accept_vis (*this);\n-    }\n-  scope.Pop ();\n+    item->accept_vis (*this);\n+\n   return true;\n }\n \n void\n TypeResolution::visit (AST::Token &tok)\n-{}\n+{\n+  printf (\"TOKEN: %s\\n\", tok.as_string ().c_str ());\n+}\n \n void\n TypeResolution::visit (AST::DelimTokenTree &delim_tok_tree)\n-{}\n+{\n+  printf (\"DelimTokenTree: %s\\n\", delim_tok_tree.as_string ().c_str ());\n+}\n \n void\n TypeResolution::visit (AST::AttrInputMetaItemContainer &input)\n@@ -68,22 +76,33 @@ TypeResolution::visit (AST::MacroInvocationSemi &macro)\n // rust-path.h\n void\n TypeResolution::visit (AST::PathInExpression &path)\n-{}\n+{\n+  printf (\"PathInExpression: %s\\n\", path.as_string ().c_str ());\n+}\n+\n void\n TypeResolution::visit (AST::TypePathSegment &segment)\n {}\n void\n TypeResolution::visit (AST::TypePathSegmentGeneric &segment)\n {}\n+\n void\n TypeResolution::visit (AST::TypePathSegmentFunction &segment)\n {}\n+\n void\n TypeResolution::visit (AST::TypePath &path)\n-{}\n+{\n+  printf (\"TypePath: %s\\n\", path.as_string ().c_str ());\n+}\n+\n void\n TypeResolution::visit (AST::QualifiedPathInExpression &path)\n-{}\n+{\n+  printf (\"QualifiedPathInExpression: %s\\n\", path.as_string ().c_str ());\n+}\n+\n void\n TypeResolution::visit (AST::QualifiedPathInType &path)\n {}\n@@ -92,19 +111,69 @@ TypeResolution::visit (AST::QualifiedPathInType &path)\n void\n TypeResolution::visit (AST::LiteralExpr &expr)\n {\n-  printf (\"LiteralExpr: %s\\n\", expr.as_string ().c_str ());\n-  // figure out what this type is and push it onto the\n+  std::string type;\n+  switch (expr.literal.get_lit_type ())\n+    {\n+    case AST::Literal::CHAR:\n+      type = \"char\";\n+      break;\n+\n+    case AST::Literal::STRING:\n+    case AST::Literal::RAW_STRING:\n+      type = \"str\";\n+      break;\n+\n+    case AST::Literal::BOOL:\n+      type = \"bool\";\n+      break;\n+\n+    case AST::Literal::BYTE:\n+      type = \"u8\";\n+      break;\n+\n+      // FIXME these are not always going to be the case\n+      // eg: suffix on the value can change the type\n+    case AST::Literal::FLOAT:\n+      type = \"f32\";\n+      break;\n+\n+    case AST::Literal::INT:\n+      type = \"i32\";\n+      break;\n+\n+    case AST::Literal::BYTE_STRING:\n+    case AST::Literal::RAW_BYTE_STRING:\n+      // FIXME\n+      break;\n+    }\n+\n+  if (type.empty ())\n+    {\n+      rust_error_at (expr.locus, \"unknown literal: %s\",\n+\t\t     expr.literal.as_string ().c_str ());\n+      return;\n+    }\n+\n+  AST::Type *val = NULL;\n+  bool ok = typeScope.Lookup (type, &val);\n+  if (ok)\n+    typeBuffer.push_back (val);\n+  else\n+    rust_error_at (expr.locus, \"unknown literal type: %s\", type.c_str ());\n }\n \n void\n TypeResolution::visit (AST::AttrInputLiteral &attr_input)\n {}\n+\n void\n TypeResolution::visit (AST::MetaItemLitExpr &meta_item)\n {}\n+\n void\n TypeResolution::visit (AST::MetaItemPathLit &meta_item)\n {}\n+\n void\n TypeResolution::visit (AST::BorrowExpr &expr)\n {}\n@@ -117,24 +186,39 @@ TypeResolution::visit (AST::ErrorPropagationExpr &expr)\n void\n TypeResolution::visit (AST::NegationExpr &expr)\n {}\n+\n void\n TypeResolution::visit (AST::ArithmeticOrLogicalExpr &expr)\n-{}\n+{\n+  printf (\"ArithmeticOrLogicalExpr: %s\\n\", expr.as_string ().c_str ());\n+}\n+\n void\n TypeResolution::visit (AST::ComparisonExpr &expr)\n {}\n+\n void\n TypeResolution::visit (AST::LazyBooleanExpr &expr)\n-{}\n+{\n+  printf (\"LazyBooleanExpr: %s\\n\", expr.as_string ().c_str ());\n+}\n+\n void\n TypeResolution::visit (AST::TypeCastExpr &expr)\n {}\n+\n void\n TypeResolution::visit (AST::AssignmentExpr &expr)\n-{}\n+{\n+  printf (\"AssignmentExpr: %s\\n\", expr.as_string ().c_str ());\n+}\n+\n void\n TypeResolution::visit (AST::CompoundAssignmentExpr &expr)\n-{}\n+{\n+  printf (\"CompoundAssignmentExpr: %s\\n\", expr.as_string ().c_str ());\n+}\n+\n void\n TypeResolution::visit (AST::GroupedExpr &expr)\n {}\n@@ -391,9 +475,13 @@ TypeResolution::visit (AST::Enum &enum_item)\n void\n TypeResolution::visit (AST::Union &union_item)\n {}\n+\n void\n TypeResolution::visit (AST::ConstantItem &const_item)\n-{}\n+{\n+  printf (\"ConstantItem: %s\\n\", const_item.as_string ().c_str ());\n+}\n+\n void\n TypeResolution::visit (AST::StaticItem &static_item)\n {}\n@@ -546,11 +634,7 @@ void\n TypeResolution::visit (AST::LetStmt &stmt)\n {\n   AST::Type *inferedType = NULL;\n-  if (stmt.has_type ())\n-    {\n-      inferedType = stmt.type.get ();\n-    }\n-  else if (stmt.has_init_expr ())\n+  if (stmt.has_init_expr ())\n     {\n       stmt.init_expr->accept_vis (*this);\n \n@@ -565,13 +649,26 @@ TypeResolution::visit (AST::LetStmt &stmt)\n       inferedType = typeBuffer.back ();\n       typeBuffer.pop_back ();\n     }\n-  else\n+\n+  if (stmt.has_type () && stmt.has_init_expr ())\n     {\n-      rust_error_at (stmt.locus, \"unable to determine type for declaration\");\n-      return;\n+      auto declaredTyped = stmt.type.get ();\n+      // TODO compare this type to the inferred type to ensure they match\n     }\n+  else if (stmt.has_type () && !stmt.has_init_expr ())\n+    {\n+      inferedType = stmt.type.get ();\n+    }\n+\n+  // TODO check we know what the type is in the scope requires the builtins to\n+  // be defined at the constructor\n \n-  // TODO check we know what the type is\n+  // ensure the decl has the type set for compilation later on\n+  if (!stmt.has_type ())\n+    {\n+      // FIXME\n+      // stmt.type = inferedType;\n+    }\n \n   // get all the names part of this declaration and add the types to the scope\n   stmt.variables_pattern->accept_vis (*this);"}, {"sha": "8a16b0df9e9ae1bdd0e440575c7c68b7ff0c8543", "filename": "gcc/rust/analysis/rust-resolution.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60cc2cf64bdbc4224d8f8bbcaa2469cb6e340a47/gcc%2Frust%2Fanalysis%2Frust-resolution.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60cc2cf64bdbc4224d8f8bbcaa2469cb6e340a47/gcc%2Frust%2Fanalysis%2Frust-resolution.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fanalysis%2Frust-resolution.h?ref=60cc2cf64bdbc4224d8f8bbcaa2469cb6e340a47", "patch": "@@ -226,6 +226,7 @@ class TypeResolution : public AST::ASTVisitor\n   bool go ();\n \n   Scope scope;\n+  Scope typeScope;\n   AST::Crate &crate;\n \n   std::vector<AST::IdentifierPattern> letPatternBuffer;"}]}