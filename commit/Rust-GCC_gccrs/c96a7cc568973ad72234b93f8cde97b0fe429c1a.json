{"sha": "c96a7cc568973ad72234b93f8cde97b0fe429c1a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yzk2YTdjYzU2ODk3M2FkNzIyMzRiOTNmOGNkZTk3YjBmZTQyOWMxYQ==", "commit": {"author": {"name": "Maxim Kuvyrkov", "email": "mkuvyrkov@ispras.ru", "date": "2006-03-27T22:38:06Z"}, "committer": {"name": "Maxim Kuvyrkov", "email": "mkuvyrkov@gcc.gnu.org", "date": "2006-03-27T22:38:06Z"}, "message": "haifa-sched.c (Copyright): Update date.\n\n2006-03-27  Maxim Kuvyrkov  <mkuvyrkov@ispras.ru>\n\n\t* haifa-sched.c (Copyright): Update date.\n\t(try_ready): Change condition to restore non-speculative pattern\n\tof the instruction.\n\t(process_insn_depend_be_in_spec): Code to keep probability of the\n\tspeculative dependence non-decreasing.\n\nFrom-SVN: r112427", "tree": {"sha": "af864aba7422d8aa5ae261e54d5c4f727cb21f0a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/af864aba7422d8aa5ae261e54d5c4f727cb21f0a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c96a7cc568973ad72234b93f8cde97b0fe429c1a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c96a7cc568973ad72234b93f8cde97b0fe429c1a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c96a7cc568973ad72234b93f8cde97b0fe429c1a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c96a7cc568973ad72234b93f8cde97b0fe429c1a/comments", "author": null, "committer": null, "parents": [{"sha": "25b773bef1dd535308732e51f38dd521dced4080", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/25b773bef1dd535308732e51f38dd521dced4080", "html_url": "https://github.com/Rust-GCC/gccrs/commit/25b773bef1dd535308732e51f38dd521dced4080"}], "stats": {"total": 56, "additions": 43, "deletions": 13}, "files": [{"sha": "d0f69615d96f031ce77082095a0e0bb4137fd74b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c96a7cc568973ad72234b93f8cde97b0fe429c1a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c96a7cc568973ad72234b93f8cde97b0fe429c1a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c96a7cc568973ad72234b93f8cde97b0fe429c1a", "patch": "@@ -1,3 +1,11 @@\n+2006-03-27  Maxim Kuvyrkov  <mkuvyrkov@ispras.ru>\n+\n+\t* haifa-sched.c (Copyright): Update date.\n+\t(try_ready): Change condition to restore non-speculative pattern\n+\tof the instruction.\n+\t(process_insn_depend_be_in_spec): Code to keep probability of the\n+\tspeculative dependence non-decreasing.\n+\n 2006-03-27  Bernd Schmidt  <bernd.schmidt@analog.com>\n \n \t* regrename.c (replace_oldest_value_addr): Initialize a variable to"}, {"sha": "f81344d0d2e92337c22e2e2a732efc7623147a3e", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 35, "deletions": 13, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c96a7cc568973ad72234b93f8cde97b0fe429c1a/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c96a7cc568973ad72234b93f8cde97b0fe429c1a/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=c96a7cc568973ad72234b93f8cde97b0fe429c1a", "patch": "@@ -1,6 +1,7 @@\n /* Instruction scheduling pass.\n    Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n-   1999, 2000, 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.\n+   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006\n+   Free Software Foundation, Inc.\n    Contributed by Michael Tiemann (tiemann@cygnus.com) Enhanced by,\n    and currently maintained by, Jim Wilson (wilson@cygnus.com)\n \n@@ -3055,16 +3056,6 @@ try_ready (rtx next)\n \t      || !RECOVERY_BLOCK (next)\n \t      || RECOVERY_BLOCK (next) == EXIT_BLOCK_PTR);\n   \n-  if (*ts == 0 && ORIG_PAT (next) && !RECOVERY_BLOCK (next))\n-    /* We should change pattern of every previously speculative \n-       instruction - and we determine if NEXT was speculative by using\n-       ORIG_PAT field.  Except one case - simple checks have ORIG_PAT\n-       pat too, hence we also check for the RECOVERY_BLOCK.  */\n-    {\n-      change_pattern (next, ORIG_PAT (next));\n-      ORIG_PAT (next) = 0;\n-    }\n-\n   if (*ts & HARD_DEP)\n     {\n       /* We can't assert (QUEUE_INDEX (next) == QUEUE_NOWHERE) here because\n@@ -3075,6 +3066,15 @@ try_ready (rtx next)\n       change_queue_index (next, QUEUE_NOWHERE);\n       return -1;\n     }\n+  else if (!(*ts & BEGIN_SPEC) && ORIG_PAT (next) && !RECOVERY_BLOCK (next))\n+    /* We should change pattern of every previously speculative \n+       instruction - and we determine if NEXT was speculative by using\n+       ORIG_PAT field.  Except one case - simple checks have ORIG_PAT\n+       pat too, hence we also check for the RECOVERY_BLOCK.  */\n+    {\n+      change_pattern (next, ORIG_PAT (next));\n+      ORIG_PAT (next) = 0;\n+    }\n \n   if (sched_verbose >= 2)\n     {\t      \n@@ -3312,8 +3312,30 @@ process_insn_depend_be_in_spec (rtx link, rtx twin, ds_t fs)\n \n       ds = DEP_STATUS (link);\n \n-      if (fs && (ds & DEP_TYPES) == DEP_TRUE)\n-\tds = (ds & ~BEGIN_SPEC) | fs;\n+      if (/* If we want to create speculative dep.  */\n+\t  fs\n+\t  /* And we can do that because this is a true dep.  */\n+\t  && (ds & DEP_TYPES) == DEP_TRUE)\n+\t{\n+\t  gcc_assert (!(ds & BE_IN_SPEC));\n+\n+\t  if (/* If this dep can be overcomed with 'begin speculation'.  */\n+\t      ds & BEGIN_SPEC)\n+\t    /* Then we have a choice: keep the dep 'begin speculative'\n+\t       or transform it into 'be in speculative'.  */\n+\t    {\n+\t      if (/* In try_ready we assert that if insn once became ready\n+\t\t     it can be removed from the ready (or queue) list only\n+\t\t     due to backend decision.  Hence we can't let the\n+\t\t     probability of the speculative dep to decrease.  */\n+\t\t  dep_weak (ds) <= dep_weak (fs))\n+\t\t/* Transform it to be in speculative.  */\n+\t\tds = (ds & ~BEGIN_SPEC) | fs;\n+\t    }\n+\t  else\n+\t    /* Mark the dep as 'be in speculative'.  */\n+\t    ds |= fs;\n+\t}\n \n       add_back_forw_dep (consumer, twin, REG_NOTE_KIND (link), ds);\n     }"}]}