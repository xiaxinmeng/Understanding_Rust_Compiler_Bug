{"sha": "4003e470a7ff8d8cfc94d28f193033fd53cbd1cf", "node_id": "C_kwDOANBUbNoAKDQwMDNlNDcwYTdmZjhkOGNmYzk0ZDI4ZjE5MzAzM2ZkNTNjYmQxY2Y", "commit": {"author": {"name": "Roger Sayle", "email": "roger@nextmovesoftware.com", "date": "2022-12-28T19:30:17Z"}, "committer": {"name": "Roger Sayle", "email": "roger@nextmovesoftware.com", "date": "2022-12-28T19:30:17Z"}, "message": "Provide zero_extend versions/variants of several patterns on x86.\n\nThe middle-end doesn't have a preferred canonical form for expressing\nzero-extension, sometimes using an AND, sometimes pairs of SHIFTs,\nand sometimes using zero_extend.  Pending changes to RTL simplification\nwill/may alter some of these representations, so a few additional\npatterns are required to recognize these alternate representations\nand avoid any testsuite regressions.\n\nAs an example, *popcountsi2_zext is currently represented as:\n  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n        (and:DI\n          (subreg:DI\n            (popcount:SI\n              (match_operand:SI 1 \"nonimmediate_operand\" \"rm\")) 0)\n          (const_int 63)))\n   (clobber (reg:CC FLAGS_REG))]\n\nthis patch adds an alternate/equivalent pattern that matches:\n  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n       (zero_extend:DI\n         (popcount:SI (match_operand:SI 1 \"nonimmediate_operand\" \"rm\"))))\n   (clobber (reg:CC FLAGS_REG))]\n\nAnother example is *popcounthi2 which is currently represented as:\n  [(set (match_operand:SI 0 \"register_operand\")\n        (popcount:SI\n          (zero_extend:SI (match_operand:HI 1 \"nonimmediate_operand\"))))\n   (clobber (reg:CC FLAGS_REG))]\n\nthis patch adds an alternate/equivalent pattern that matches:\n  [(set (match_operand:SI 0 \"register_operand\")\n        (zero_extend:SI\n          (popcount:HI (match_operand:HI 1 \"nonimmediate_operand\"))))\n   (clobber (reg:CC FLAGS_REG))]\n\nThe contents of the machine description definitions remain the same.\nit's just the expected RTL is slightly different but equivalent.\nProviding both forms makes the backend more robust to middle-end\nchanges [and possibly catches some missed optimizations].\n\n2022-12-28  Roger Sayle  <roger@nextmovesoftware.com>\n\ngcc/ChangeLog\n\t* config/i386/i386.md (*clzsi2_lzcnt_zext_2): define_insn_and_split\n\tto match ZERO_EXTEND form of *clzsi2_lzcnt_zext.\n\t(*clzsi2_lzcnt_zext_2_falsedep): Likewise, new define_insn to match\n\tZERO_EXTEND form of *clzsi2_lzcnt_zext_falsedep.\n\t(*bmi2_bzhi_zero_extendsidi_5): Likewise, new define_insn to match\n\tZERO_EXTEND form of *bmi2_bzhi_zero_extendsidi.\n\t(*popcountsi2_zext_2): Likewise, new define_insn_and_split to match\n\tZERO_EXTEND form of *popcountsi2_zext.\n\t(*popcountsi2_zext_2_falsedep): Likewise, new define_insn to match\n\tZERO_EXTEND form of *popcountsi2_zext_falsedep.\n\t(*popcounthi2_2): Likewise, new define_insn_and_split to match\n\tZERO_EXTEND form of *popcounthi2.\n\t(define_peephole2): ZERO_EXTEND variant of HImode popcount&1 using\n\tparity flag peephole2.", "tree": {"sha": "6334bfd3f80afb22540c55d533c9c930a28dddf9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6334bfd3f80afb22540c55d533c9c930a28dddf9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4003e470a7ff8d8cfc94d28f193033fd53cbd1cf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4003e470a7ff8d8cfc94d28f193033fd53cbd1cf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4003e470a7ff8d8cfc94d28f193033fd53cbd1cf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4003e470a7ff8d8cfc94d28f193033fd53cbd1cf/comments", "author": {"login": "rogersayle", "id": 13512313, "node_id": "MDQ6VXNlcjEzNTEyMzEz", "avatar_url": "https://avatars.githubusercontent.com/u/13512313?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rogersayle", "html_url": "https://github.com/rogersayle", "followers_url": "https://api.github.com/users/rogersayle/followers", "following_url": "https://api.github.com/users/rogersayle/following{/other_user}", "gists_url": "https://api.github.com/users/rogersayle/gists{/gist_id}", "starred_url": "https://api.github.com/users/rogersayle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rogersayle/subscriptions", "organizations_url": "https://api.github.com/users/rogersayle/orgs", "repos_url": "https://api.github.com/users/rogersayle/repos", "events_url": "https://api.github.com/users/rogersayle/events{/privacy}", "received_events_url": "https://api.github.com/users/rogersayle/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rogersayle", "id": 13512313, "node_id": "MDQ6VXNlcjEzNTEyMzEz", "avatar_url": "https://avatars.githubusercontent.com/u/13512313?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rogersayle", "html_url": "https://github.com/rogersayle", "followers_url": "https://api.github.com/users/rogersayle/followers", "following_url": "https://api.github.com/users/rogersayle/following{/other_user}", "gists_url": "https://api.github.com/users/rogersayle/gists{/gist_id}", "starred_url": "https://api.github.com/users/rogersayle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rogersayle/subscriptions", "organizations_url": "https://api.github.com/users/rogersayle/orgs", "repos_url": "https://api.github.com/users/rogersayle/repos", "events_url": "https://api.github.com/users/rogersayle/events{/privacy}", "received_events_url": "https://api.github.com/users/rogersayle/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "38b649ec16c965733aab9efa6bf61faae3485d92", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/38b649ec16c965733aab9efa6bf61faae3485d92", "html_url": "https://github.com/Rust-GCC/gccrs/commit/38b649ec16c965733aab9efa6bf61faae3485d92"}], "stats": {"total": 151, "additions": 151, "deletions": 0}, "files": [{"sha": "ca40c4fee17a4700692ff753edc0d7e4536cb605", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 151, "deletions": 0, "changes": 151, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4003e470a7ff8d8cfc94d28f193033fd53cbd1cf/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4003e470a7ff8d8cfc94d28f193033fd53cbd1cf/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=4003e470a7ff8d8cfc94d28f193033fd53cbd1cf", "patch": "@@ -17419,6 +17419,42 @@\n    (set_attr \"type\" \"bitmanip\")\n    (set_attr \"mode\" \"SI\")])\n \n+(define_insn_and_split \"*clzsi2_lzcnt_zext_2\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(zero_extend:DI\n+\t  (clz:SI (match_operand:SI 1 \"nonimmediate_operand\" \"rm\"))))\n+   (clobber (reg:CC FLAGS_REG))]\n+  \"TARGET_LZCNT && TARGET_64BIT\"\n+  \"lzcnt{l}\\t{%1, %k0|%k0, %1}\"\n+  \"&& TARGET_AVOID_FALSE_DEP_FOR_BMI && epilogue_completed\n+   && optimize_function_for_speed_p (cfun)\n+   && !reg_mentioned_p (operands[0], operands[1])\"\n+  [(parallel\n+    [(set (match_dup 0)\n+\t  (zero_extend:DI (clz:SI (match_dup 1))))\n+     (unspec [(match_dup 0)] UNSPEC_INSN_FALSE_DEP)\n+     (clobber (reg:CC FLAGS_REG))])]\n+  \"ix86_expand_clear (operands[0]);\"\n+  [(set_attr \"prefix_rep\" \"1\")\n+   (set_attr \"type\" \"bitmanip\")\n+   (set_attr \"mode\" \"SI\")])\n+\n+; False dependency happens when destination is only updated by tzcnt,\n+; lzcnt or popcnt.  There is no false dependency when destination is\n+; also used in source.\n+(define_insn \"*clzsi2_lzcnt_zext_2_falsedep\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(zero_extend:DI\n+\t  (clz:SI (match_operand:SWI48 1 \"nonimmediate_operand\" \"rm\"))))\n+   (unspec [(match_operand:DI 2 \"register_operand\" \"0\")]\n+\t   UNSPEC_INSN_FALSE_DEP)\n+   (clobber (reg:CC FLAGS_REG))]\n+  \"TARGET_LZCNT\"\n+  \"lzcnt{l}\\t{%1, %k0|%k0, %1}\"\n+  [(set_attr \"prefix_rep\" \"1\")\n+   (set_attr \"type\" \"bitmanip\")\n+   (set_attr \"mode\" \"SI\")])\n+\n (define_int_iterator LT_ZCNT\n \t[(UNSPEC_TZCNT \"TARGET_BMI\")\n \t (UNSPEC_LZCNT \"TARGET_LZCNT\")])\n@@ -17737,6 +17773,22 @@\n    (set_attr \"prefix\" \"vex\")\n    (set_attr \"mode\" \"DI\")])\n \n+(define_insn \"*bmi2_bzhi_zero_extendsidi_5\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(and:DI\n+\t  (zero_extend:DI\n+\t    (plus:SI\n+\t      (ashift:SI (const_int 1)\n+\t\t\t (match_operand:QI 2 \"register_operand\" \"r\"))\n+\t      (const_int -1)))\n+\t  (match_operand:DI 1 \"nonimmediate_operand\" \"rm\")))\n+   (clobber (reg:CC FLAGS_REG))]\n+  \"TARGET_64BIT && TARGET_BMI2\"\n+  \"bzhi\\t{%q2, %q1, %q0|%q0, %q1, %q2}\"\n+  [(set_attr \"type\" \"bitmanip\")\n+   (set_attr \"prefix\" \"vex\")\n+   (set_attr \"mode\" \"DI\")])\n+\n (define_insn \"bmi2_pdep_<mode>3\"\n   [(set (match_operand:SWI48 0 \"register_operand\" \"=r\")\n         (unspec:SWI48 [(match_operand:SWI48 1 \"register_operand\" \"r\")\n@@ -17999,6 +18051,54 @@\n    (set_attr \"type\" \"bitmanip\")\n    (set_attr \"mode\" \"SI\")])\n \n+(define_insn_and_split \"*popcountsi2_zext_2\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(zero_extend:DI\n+\t  (popcount:SI (match_operand:SI 1 \"nonimmediate_operand\" \"rm\"))))\n+   (clobber (reg:CC FLAGS_REG))]\n+  \"TARGET_POPCNT && TARGET_64BIT\"\n+{\n+#if TARGET_MACHO\n+  return \"popcnt\\t{%1, %k0|%k0, %1}\";\n+#else\n+  return \"popcnt{l}\\t{%1, %k0|%k0, %1}\";\n+#endif\n+}\n+  \"&& TARGET_AVOID_FALSE_DEP_FOR_BMI && epilogue_completed\n+   && optimize_function_for_speed_p (cfun)\n+   && !reg_mentioned_p (operands[0], operands[1])\"\n+  [(parallel\n+    [(set (match_dup 0)\n+\t  (zero_extend:DI (popcount:SI (match_dup 1))))\n+     (unspec [(match_dup 0)] UNSPEC_INSN_FALSE_DEP)\n+     (clobber (reg:CC FLAGS_REG))])]\n+  \"ix86_expand_clear (operands[0]);\"\n+  [(set_attr \"prefix_rep\" \"1\")\n+   (set_attr \"type\" \"bitmanip\")\n+   (set_attr \"mode\" \"SI\")])\n+\n+; False dependency happens when destination is only updated by tzcnt,\n+; lzcnt or popcnt.  There is no false dependency when destination is\n+; also used in source.\n+(define_insn \"*popcountsi2_zext_2_falsedep\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(zero_extend:DI\n+\t  (popcount:SI (match_operand:SI 1 \"nonimmediate_operand\" \"rm\"))))\n+   (unspec [(match_operand:DI 2 \"register_operand\" \"0\")]\n+\t   UNSPEC_INSN_FALSE_DEP)\n+   (clobber (reg:CC FLAGS_REG))]\n+  \"TARGET_POPCNT && TARGET_64BIT\"\n+{\n+#if TARGET_MACHO\n+  return \"popcnt\\t{%1, %k0|%k0, %1}\";\n+#else\n+  return \"popcnt{l}\\t{%1, %k0|%k0, %1}\";\n+#endif\n+}\n+  [(set_attr \"prefix_rep\" \"1\")\n+   (set_attr \"type\" \"bitmanip\")\n+   (set_attr \"mode\" \"SI\")])\n+\n (define_insn_and_split \"*popcounthi2_1\"\n   [(set (match_operand:SI 0 \"register_operand\")\n \t(popcount:SI\n@@ -18017,6 +18117,24 @@\n   DONE;\n })\n \n+(define_insn_and_split \"*popcounthi2_2\"\n+  [(set (match_operand:SI 0 \"register_operand\")\n+\t(zero_extend:SI\n+\t  (popcount:HI (match_operand:HI 1 \"nonimmediate_operand\"))))\n+   (clobber (reg:CC FLAGS_REG))]\n+  \"TARGET_POPCNT\n+   && ix86_pre_reload_split ()\"\n+  \"#\"\n+  \"&& 1\"\n+  [(const_int 0)]\n+{\n+  rtx tmp = gen_reg_rtx (HImode);\n+\n+  emit_insn (gen_popcounthi2 (tmp, operands[1]));\n+  emit_insn (gen_zero_extendhisi2 (operands[0], tmp));\n+  DONE;\n+})\n+\n (define_insn \"popcounthi2\"\n   [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n \t(popcount:HI\n@@ -18336,6 +18454,39 @@\n   PUT_CODE (operands[5], GET_CODE (operands[5]) == EQ ? UNORDERED : ORDERED);\n })\n \n+;; Eliminate HImode popcount&1 using parity flag (variant 2)\n+(define_peephole2\n+  [(match_scratch:HI 0 \"Q\")\n+   (parallel [(set (match_operand:HI 1 \"register_operand\")\n+\t\t   (popcount:HI\n+\t\t    (match_operand:HI 2 \"nonimmediate_operand\")))\n+\t      (clobber (reg:CC FLAGS_REG))])\n+   (set (reg:CCZ FLAGS_REG)\n+        (compare:CCZ (and:QI (match_operand:QI 3 \"register_operand\")\n+\t\t\t     (const_int 1))\n+\t\t     (const_int 0)))\n+   (set (pc) (if_then_else (match_operator 4 \"bt_comparison_operator\"\n+\t\t\t    [(reg:CCZ FLAGS_REG)\n+\t\t\t     (const_int 0)])\n+\t\t\t   (label_ref (match_operand 5))\n+\t\t\t   (pc)))]\n+  \"REGNO (operands[1]) == REGNO (operands[3])\n+   && peep2_reg_dead_p (2, operands[1])\n+   && peep2_reg_dead_p (2, operands[3])\n+   && peep2_regno_dead_p (3, FLAGS_REG)\"\n+  [(set (match_dup 0) (match_dup 2))\n+   (parallel [(set (reg:CC FLAGS_REG)\n+\t\t   (unspec:CC [(match_dup 0)] UNSPEC_PARITY))\n+\t      (clobber (match_dup 0))])\n+   (set (pc) (if_then_else (match_op_dup 4 [(reg:CC FLAGS_REG)\n+\t\t\t\t\t    (const_int 0)])\n+\t\t\t   (label_ref (match_dup 5))\n+\t\t\t   (pc)))]\n+{\n+  operands[4] = shallow_copy_rtx (operands[4]);\n+  PUT_CODE (operands[4], GET_CODE (operands[4]) == EQ ? UNORDERED : ORDERED);\n+})\n+\n \f\n ;; Thread-local storage patterns for ELF.\n ;;"}]}