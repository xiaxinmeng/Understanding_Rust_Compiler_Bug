{"sha": "5ec6aff2dd65faa0176b9cb4a32e2ebf707aa4da", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWVjNmFmZjJkZDY1ZmFhMDE3NmI5Y2I0YTMyZTJlYmY3MDdhYTRkYQ==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@linux.vnet.ibm.com", "date": "2013-05-04T05:38:47Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "2013-05-04T05:38:47Z"}, "message": "re PR target/57150 (GCC when targeting power7 spills long double using VSX instructions.)\n\n[gcc]\n2013-05-03  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\n\tPR target/57150\n\t* config/rs6000/rs6000.h (HARD_REGNO_CALLER_SAVE_MODE): Use DFmode\n\tto save TFmode registers and DImode to save TImode registers for\n\tcaller save operations.\n\t(HARD_REGNO_CALL_PART_CLOBBERED): TFmode and TDmode do not need to\n\tmark being partially clobbered since they only use the first\n\tdouble word.\n\n\t* config/rs6000/rs6000.c (rs6000_init_hard_regno_mode_ok): TFmode\n\tand TDmode only use the upper 64-bits of each VSX register.\n\n[gcc/testsuite]\n2013-05-03  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\n\tPR target/57150\n\t* gcc.target/powerpc/pr57150.c: New file.\n\nFrom-SVN: r198593", "tree": {"sha": "33ebf64e84aca3b4d16f51cc4c5b88e76ed4106f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/33ebf64e84aca3b4d16f51cc4c5b88e76ed4106f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5ec6aff2dd65faa0176b9cb4a32e2ebf707aa4da", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5ec6aff2dd65faa0176b9cb4a32e2ebf707aa4da", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5ec6aff2dd65faa0176b9cb4a32e2ebf707aa4da", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5ec6aff2dd65faa0176b9cb4a32e2ebf707aa4da/comments", "author": null, "committer": null, "parents": [{"sha": "2cefad900d3f9b8d4434fb4253e16f72836c2e4a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2cefad900d3f9b8d4434fb4253e16f72836c2e4a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2cefad900d3f9b8d4434fb4253e16f72836c2e4a"}], "stats": {"total": 67, "additions": 61, "deletions": 6}, "files": [{"sha": "e91ea0027bbbc95e5bec374744a2f521cf03a888", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ec6aff2dd65faa0176b9cb4a32e2ebf707aa4da/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ec6aff2dd65faa0176b9cb4a32e2ebf707aa4da/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5ec6aff2dd65faa0176b9cb4a32e2ebf707aa4da", "patch": "@@ -1,3 +1,16 @@\n+2013-05-03  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\tPR target/57150\n+\t* config/rs6000/rs6000.h (HARD_REGNO_CALLER_SAVE_MODE): Use DFmode\n+\tto save TFmode registers and DImode to save TImode registers for\n+\tcaller save operations.\n+\t(HARD_REGNO_CALL_PART_CLOBBERED): TFmode and TDmode do not need to\n+\tmark being partially clobbered since they only use the first\n+\tdouble word.\n+\n+\t* config/rs6000/rs6000.c (rs6000_init_hard_regno_mode_ok): TFmode\n+\tand TDmode only use the upper 64-bits of each VSX register.\n+\n 2013-05-03  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>\n \n \t* gimple-ssa-strength-reduction.c (slsr_process_phi): Disable."}, {"sha": "4f7fc70d566eb9f3053f3bb00b5b818546fc9022", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ec6aff2dd65faa0176b9cb4a32e2ebf707aa4da/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ec6aff2dd65faa0176b9cb4a32e2ebf707aa4da/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=5ec6aff2dd65faa0176b9cb4a32e2ebf707aa4da", "patch": "@@ -2335,8 +2335,16 @@ rs6000_init_hard_regno_mode_ok (bool global_init_p)\n \treg_size = UNITS_PER_WORD;\n \n       for (m = 0; m < NUM_MACHINE_MODES; ++m)\n-\trs6000_class_max_nregs[m][c]\n-\t  = (GET_MODE_SIZE (m) + reg_size - 1) / reg_size;\n+\t{\n+\t  int reg_size2 = reg_size;\n+\n+\t  /* TFmode/TDmode always takes 2 registers, even in VSX.  */\n+\t  if (m == TDmode || m == TFmode)\n+\t    reg_size2 = UNITS_PER_FP_WORD;\n+\n+\t  rs6000_class_max_nregs[m][c]\n+\t    = (GET_MODE_SIZE (m) + reg_size2 - 1) / reg_size2;\n+\t}\n     }\n \n   if (TARGET_E500_DOUBLE)"}, {"sha": "6549347b9b7eec4416a7430e80e0ed7ce7229926", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ec6aff2dd65faa0176b9cb4a32e2ebf707aa4da/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ec6aff2dd65faa0176b9cb4a32e2ebf707aa4da/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=5ec6aff2dd65faa0176b9cb4a32e2ebf707aa4da", "patch": "@@ -1071,20 +1071,26 @@ extern unsigned rs6000_pointer_size;\n #define HARD_REGNO_NREGS(REGNO, MODE) rs6000_hard_regno_nregs[(MODE)][(REGNO)]\n \n /* When setting up caller-save slots (MODE == VOIDmode) ensure we allocate\n-   enough space to account for vectors in FP regs. */\n+   enough space to account for vectors in FP regs.  However, TFmode/TDmode\n+   should not use VSX instructions to do a caller save. */\n #define HARD_REGNO_CALLER_SAVE_MODE(REGNO, NREGS, MODE)\t\t\t\\\n   (TARGET_VSX\t\t\t\t\t\t\t\t\\\n    && ((MODE) == VOIDmode || ALTIVEC_OR_VSX_VECTOR_MODE (MODE))\t\t\\\n-   && FP_REGNO_P (REGNO)\t\t\t\t\\\n-   ? V2DFmode\t\t\t\t\t\t\\\n+   && FP_REGNO_P (REGNO)\t\t\t\t\t\t\\\n+   ? V2DFmode\t\t\t\t\t\t\t\t\\\n+   : ((MODE) == TFmode && FP_REGNO_P (REGNO))\t\t\t\t\\\n+   ? DFmode\t\t\t\t\t\t\t\t\\\n+   : ((MODE) == TDmode && FP_REGNO_P (REGNO))\t\t\t\t\\\n+   ? DImode\t\t\t\t\t\t\t\t\\\n    : choose_hard_reg_mode ((REGNO), (NREGS), false))\n \n #define HARD_REGNO_CALL_PART_CLOBBERED(REGNO, MODE)\t\t\t\\\n   (((TARGET_32BIT && TARGET_POWERPC64\t\t\t\t\t\\\n      && (GET_MODE_SIZE (MODE) > 4)\t\t\t\t\t\\\n      && INT_REGNO_P (REGNO)) ? 1 : 0)\t\t\t\t\t\\\n    || (TARGET_VSX && FP_REGNO_P (REGNO)\t\t\t\t\t\\\n-       && GET_MODE_SIZE (MODE) > 8))\n+       && GET_MODE_SIZE (MODE) > 8 && ((MODE) != TDmode) \t\t\\\n+       && ((MODE) != TFmode)))\n \n #define VSX_VECTOR_MODE(MODE)\t\t\\\n \t ((MODE) == V4SFmode\t\t\\"}, {"sha": "731ccd07c7d2a8815d1400e1b62485d66f15989a", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ec6aff2dd65faa0176b9cb4a32e2ebf707aa4da/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ec6aff2dd65faa0176b9cb4a32e2ebf707aa4da/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=5ec6aff2dd65faa0176b9cb4a32e2ebf707aa4da", "patch": "@@ -1,3 +1,8 @@\n+2013-05-03  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\tPR target/57150\n+\t* gcc.target/powerpc/pr57150.c: New file.\n+\n 2013-05-03  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>\n \n \t* gcc.dg/tree-ssa/slsr-32.c: Skip test for now."}, {"sha": "119bc4c52feeb17b637dfcfb1eed622ec09cb413", "filename": "gcc/testsuite/gcc.target/powerpc/pr57150.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ec6aff2dd65faa0176b9cb4a32e2ebf707aa4da/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr57150.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ec6aff2dd65faa0176b9cb4a32e2ebf707aa4da/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr57150.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr57150.c?ref=5ec6aff2dd65faa0176b9cb4a32e2ebf707aa4da", "patch": "@@ -0,0 +1,23 @@\n+/* { dg-do compile { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"\" { powerpc*-*-darwin* } { \"*\" } { \"\" } } */\n+/* { dg-require-effective-target powerpc_vsx_ok } */\n+/* { dg-options \"-O3 -mcpu=power7 -fcaller-saves\" } */\n+/* { dg-final { scan-assembler-not \"lxvd2x\" } } */\n+/* { dg-final { scan-assembler-not \"lxvw4x\" } } */\n+/* { dg-final { scan-assembler-not \"lvx\" } } */\n+/* { dg-final { scan-assembler-not \"stxvd2x\" } } */\n+/* { dg-final { scan-assembler-not \"stxvw4x\" } } */\n+/* { dg-final { scan-assembler-not \"stvx\" } } */\n+\n+/* Insure caller save on long double does not use VSX instructions.  */\n+\n+extern long double modify (long double);\n+\n+void\n+sum (long double *ptr, long double value, unsigned long n)\n+{\n+  unsigned long i;\n+\n+  for (i = 0; i < n; i++)\n+    ptr[i] += modify (value);\n+}"}]}