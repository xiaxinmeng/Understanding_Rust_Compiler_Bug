{"sha": "e6d7d61861c8fa7207570abb6fc23c5a2921e4da", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTZkN2Q2MTg2MWM4ZmE3MjA3NTcwYWJiNmZjMjNjNWEyOTIxZTRkYQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2017-06-10T00:40:50Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2017-06-10T00:40:50Z"}, "message": "Missing bits from N4268, constant evaluation for all non-type args.\n\n\t* call.c (build_converted_constant_expr): Rename from\n\tbuild_integral_nontype_arg_conv, handle all types.\n\t* pt.c (convert_nontype_argument): In C++17 call it for all types.\n\tMove NOP stripping inside pointer case, don't strip ADDR_EXPR.\n\t* cvt.c (strip_fnptr_conv): Also strip conversions to the same type.\n\nFrom-SVN: r249089", "tree": {"sha": "8d20815456dbc2d945ec18a4963a28ba3b75f5e9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8d20815456dbc2d945ec18a4963a28ba3b75f5e9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e6d7d61861c8fa7207570abb6fc23c5a2921e4da", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e6d7d61861c8fa7207570abb6fc23c5a2921e4da", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e6d7d61861c8fa7207570abb6fc23c5a2921e4da", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e6d7d61861c8fa7207570abb6fc23c5a2921e4da/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8b8b203a26bdac3dede77e76d06e4e7084f79acc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b8b203a26bdac3dede77e76d06e4e7084f79acc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8b8b203a26bdac3dede77e76d06e4e7084f79acc"}], "stats": {"total": 266, "additions": 166, "deletions": 100}, "files": [{"sha": "14eaa98332741c93d26c7fc50d64cd6d90381e04", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6d7d61861c8fa7207570abb6fc23c5a2921e4da/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6d7d61861c8fa7207570abb6fc23c5a2921e4da/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=e6d7d61861c8fa7207570abb6fc23c5a2921e4da", "patch": "@@ -1,5 +1,12 @@\n 2017-06-09  Jason Merrill  <jason@redhat.com>\n \n+\tMissing bits from N4268, constant evaluation for all non-type args.\n+\t* call.c (build_converted_constant_expr): Rename from\n+\tbuild_integral_nontype_arg_conv, handle all types.\n+\t* pt.c (convert_nontype_argument): In C++17 call it for all types.\n+\tMove NOP stripping inside pointer case, don't strip ADDR_EXPR.\n+\t* cvt.c (strip_fnptr_conv): Also strip conversions to the same type.\n+\n \tOverhaul pointer-to-member conversion and template argument handling.\n \t* call.c (standard_conversion): Avoid creating ck_pmem when the\n \tclass type is the same."}, {"sha": "ef9968340c6ea42e4d901f46c96c49dfbc6ecc05", "filename": "gcc/cp/call.c", "status": "modified", "additions": 81, "deletions": 32, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6d7d61861c8fa7207570abb6fc23c5a2921e4da/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6d7d61861c8fa7207570abb6fc23c5a2921e4da/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=e6d7d61861c8fa7207570abb6fc23c5a2921e4da", "patch": "@@ -4005,15 +4005,16 @@ build_user_type_conversion (tree totype, tree expr, int flags,\n \n /* Subroutine of convert_nontype_argument.\n \n-   EXPR is an argument for a template non-type parameter of integral or\n-   enumeration type.  Do any necessary conversions (that are permitted for\n-   non-type arguments) to convert it to the parameter type.\n+   EXPR is an expression used in a context that requires a converted\n+   constant-expression, such as a template non-type parameter.  Do any\n+   necessary conversions (that are permitted for converted\n+   constant-expressions) to convert it to the desired type.\n \n    If conversion is successful, returns the converted expression;\n    otherwise, returns error_mark_node.  */\n \n tree\n-build_integral_nontype_arg_conv (tree type, tree expr, tsubst_flags_t complain)\n+build_converted_constant_expr (tree type, tree expr, tsubst_flags_t complain)\n {\n   conversion *conv;\n   void *p;\n@@ -4023,45 +4024,93 @@ build_integral_nontype_arg_conv (tree type, tree expr, tsubst_flags_t complain)\n   if (error_operand_p (expr))\n     return error_mark_node;\n \n-  gcc_assert (INTEGRAL_OR_ENUMERATION_TYPE_P (type));\n-\n   /* Get the high-water mark for the CONVERSION_OBSTACK.  */\n   p = conversion_obstack_alloc (0);\n \n   conv = implicit_conversion (type, TREE_TYPE (expr), expr,\n \t\t\t      /*c_cast_p=*/false,\n \t\t\t      LOOKUP_IMPLICIT, complain);\n \n-  /* for a non-type template-parameter of integral or\n-     enumeration type, integral promotions (4.5) and integral\n-     conversions (4.7) are applied.  */\n-  /* It should be sufficient to check the outermost conversion step, since\n-     there are no qualification conversions to integer type.  */\n-  if (conv)\n-    switch (conv->kind)\n-      {\n-\t/* A conversion function is OK.  If it isn't constexpr, we'll\n-\t   complain later that the argument isn't constant.  */\n-      case ck_user:\n-\t/* The lvalue-to-rvalue conversion is OK.  */\n-      case ck_rvalue:\n-      case ck_identity:\n-\tbreak;\n+  /* A converted constant expression of type T is an expression, implicitly\n+     converted to type T, where the converted expression is a constant\n+     expression and the implicit conversion sequence contains only\n+\n+       * user-defined conversions,\n+       * lvalue-to-rvalue conversions (7.1),\n+       * array-to-pointer conversions (7.2),\n+       * function-to-pointer conversions (7.3),\n+       * qualification conversions (7.5),\n+       * integral promotions (7.6),\n+       * integral conversions (7.8) other than narrowing conversions (11.6.4),\n+       * null pointer conversions (7.11) from std::nullptr_t,\n+       * null member pointer conversions (7.12) from std::nullptr_t, and\n+       * function pointer conversions (7.13),\n+\n+     and where the reference binding (if any) binds directly.  */\n+\n+  for (conversion *c = conv;\n+       conv && c->kind != ck_identity;\n+       c = next_conversion (c))\n+    {\n+      switch (c->kind)\n+\t{\n+\t  /* A conversion function is OK.  If it isn't constexpr, we'll\n+\t     complain later that the argument isn't constant.  */\n+\tcase ck_user:\n+\t  /* The lvalue-to-rvalue conversion is OK.  */\n+\tcase ck_rvalue:\n+\t  /* Array-to-pointer and function-to-pointer.  */\n+\tcase ck_lvalue:\n+\t  /* Function pointer conversions.  */\n+\tcase ck_fnptr:\n+\t  /* Qualification conversions.  */\n+\tcase ck_qual:\n+\t  break;\n \n-      case ck_std:\n-\tt = next_conversion (conv)->type;\n-\tif (INTEGRAL_OR_ENUMERATION_TYPE_P (t))\n+\tcase ck_ref_bind:\n+\t  if (c->need_temporary_p)\n+\t    {\n+\t      if (complain & tf_error)\n+\t\terror_at (loc, \"initializing %qH with %qI in converted \"\n+\t\t\t  \"constant expression does not bind directly\",\n+\t\t\t  type, next_conversion (c)->type);\n+\t      conv = NULL;\n+\t    }\n \t  break;\n \n-\tif (complain & tf_error)\n-\t  error_at (loc, \"conversion from %qH to %qI not considered for \"\n-\t\t    \"non-type template argument\", t, type);\n-\t/* fall through.  */\n+\tcase ck_base:\n+\tcase ck_pmem:\n+\tcase ck_ptr:\n+\tcase ck_std:\n+\t  t = next_conversion (c)->type;\n+\t  if (INTEGRAL_OR_ENUMERATION_TYPE_P (t)\n+\t      && INTEGRAL_OR_ENUMERATION_TYPE_P (type))\n+\t    /* Integral promotion or conversion.  */\n+\t    break;\n+\t  if (NULLPTR_TYPE_P (t))\n+\t    /* Conversion from nullptr to pointer or pointer-to-member.  */\n+\t    break;\n \n-      default:\n-\tconv = NULL;\n-\tbreak;\n-      }\n+\t  if (complain & tf_error)\n+\t    error_at (loc, \"conversion from %qH to %qI in a \"\n+\t\t      \"converted constant expression\", t, type);\n+\t  /* fall through.  */\n+\n+\tdefault:\n+\t  conv = NULL;\n+\t  break;\n+\t}\n+    }\n+\n+  /* Avoid confusing convert_nontype_argument by introducing\n+     a redundant conversion to the same reference type.  */\n+  if (conv && conv->kind == ck_ref_bind\n+      && REFERENCE_REF_P (expr))\n+    {\n+      tree ref = TREE_OPERAND (expr, 0);\n+      if (same_type_p (type, TREE_TYPE (ref)))\n+\treturn ref;\n+    }\n \n   if (conv)\n     expr = convert_like (conv, expr, complain);"}, {"sha": "6d4d93702f8d5db203fdaf13716d97e0aaaca65e", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6d7d61861c8fa7207570abb6fc23c5a2921e4da/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6d7d61861c8fa7207570abb6fc23c5a2921e4da/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=e6d7d61861c8fa7207570abb6fc23c5a2921e4da", "patch": "@@ -5907,7 +5907,7 @@ extern bool reference_related_p\t\t\t(tree, tree);\n extern int remaining_arguments\t\t\t(tree);\n extern tree perform_implicit_conversion\t\t(tree, tree, tsubst_flags_t);\n extern tree perform_implicit_conversion_flags\t(tree, tree, tsubst_flags_t, int);\n-extern tree build_integral_nontype_arg_conv\t(tree, tree, tsubst_flags_t);\n+extern tree build_converted_constant_expr\t(tree, tree, tsubst_flags_t);\n extern tree perform_direct_initialization_if_possible (tree, tree, bool,\n                                                        tsubst_flags_t);\n extern tree in_charge_arg_for_name\t\t(tree);"}, {"sha": "631ff49673f0d659c704343ec6f1285641f3d338", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6d7d61861c8fa7207570abb6fc23c5a2921e4da/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6d7d61861c8fa7207570abb6fc23c5a2921e4da/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=e6d7d61861c8fa7207570abb6fc23c5a2921e4da", "patch": "@@ -2020,16 +2020,19 @@ fnptr_conv_p (tree to, tree from)\n \t  || can_convert_tx_safety (t, f));\n }\n \n-/* Return FN with any NOP_EXPRs that represent function pointer\n-   conversions stripped.  */\n+/* Return FN with any NOP_EXPRs stripped that represent function pointer\n+   conversions or conversions to the same type.  */\n \n tree\n strip_fnptr_conv (tree fn)\n {\n   while (TREE_CODE (fn) == NOP_EXPR)\n     {\n       tree op = TREE_OPERAND (fn, 0);\n-      if (fnptr_conv_p (TREE_TYPE (fn), TREE_TYPE (op)))\n+      tree ft = TREE_TYPE (fn);\n+      tree ot = TREE_TYPE (op);\n+      if (same_type_p (ft, ot)\n+\t  || fnptr_conv_p (ft, ot))\n \tfn = op;\n       else\n \tbreak;"}, {"sha": "4d4484f919bb363c32f197c39739939e21e7e1d7", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 46, "deletions": 51, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6d7d61861c8fa7207570abb6fc23c5a2921e4da/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6d7d61861c8fa7207570abb6fc23c5a2921e4da/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=e6d7d61861c8fa7207570abb6fc23c5a2921e4da", "patch": "@@ -6430,6 +6430,8 @@ static tree\n convert_nontype_argument (tree type, tree expr, tsubst_flags_t complain)\n {\n   tree expr_type;\n+  location_t loc = EXPR_LOC_OR_LOC (expr, input_location);\n+  tree orig_expr = expr;\n \n   /* Detect immediately string literals as invalid non-type argument.\n      This special-case is not needed for correctness (we would easily\n@@ -6503,18 +6505,17 @@ convert_nontype_argument (tree type, tree expr, tsubst_flags_t complain)\n \t   argument for a parameter of pointer to member type, we just want\n \t   to leave it in that form rather than lower it to a\n \t   CONSTRUCTOR.  */;\n-      else if (INTEGRAL_OR_ENUMERATION_TYPE_P (type))\n-\t/* Constant value checking is done later with type conversion.  */;\n-      else if (cxx_dialect >= cxx1z)\n+      else if (INTEGRAL_OR_ENUMERATION_TYPE_P (type)\n+\t       || cxx_dialect >= cxx1z)\n \t{\n-\t  if (TREE_CODE (type) != REFERENCE_TYPE)\n-\t    expr = maybe_constant_value (expr);\n-\t  else if (REFERENCE_REF_P (expr))\n-\t    {\n-\t      expr = TREE_OPERAND (expr, 0);\n-\t      expr = maybe_constant_value (expr);\n-\t      expr = convert_from_reference (expr);\n-\t    }\n+\t  /* C++17: A template-argument for a non-type template-parameter shall\n+\t     be a converted constant expression (8.20) of the type of the\n+\t     template-parameter.  */\n+\t  expr = build_converted_constant_expr (type, expr, complain);\n+\t  if (expr == error_mark_node)\n+\t    return error_mark_node;\n+\t  expr = maybe_constant_value (expr);\n+\t  expr = convert_from_reference (expr);\n \t}\n       else if (TYPE_PTR_OR_PTRMEM_P (type))\n \t{\n@@ -6558,37 +6559,20 @@ convert_nontype_argument (tree type, tree expr, tsubst_flags_t complain)\n \t}\n     }\n \n-  /* We could also generate a NOP_EXPR(ADDR_EXPR()) when the\n-     parameter is a pointer to object, through decay and\n-     qualification conversion. Let's strip everything.  */\n-  else if (TREE_CODE (expr) == NOP_EXPR && TYPE_PTROBV_P (type))\n-    {\n-      tree probe = expr;\n-      STRIP_NOPS (probe);\n-      if (TREE_CODE (probe) == ADDR_EXPR\n-\t  && TYPE_PTR_P (TREE_TYPE (probe)))\n-\t{\n-\t  /* Skip the ADDR_EXPR only if it is part of the decay for\n-\t     an array. Otherwise, it is part of the original argument\n-\t     in the source code.  */\n-\t  if (TREE_CODE (TREE_TYPE (TREE_OPERAND (probe, 0))) == ARRAY_TYPE)\n-\t    probe = TREE_OPERAND (probe, 0);\n-\t  expr = probe;\n-\t  expr_type = TREE_TYPE (expr);\n-\t}\n-    }\n-\n   /* [temp.arg.nontype]/5, bullet 1\n \n      For a non-type template-parameter of integral or enumeration type,\n      integral promotions (_conv.prom_) and integral conversions\n      (_conv.integral_) are applied.  */\n   if (INTEGRAL_OR_ENUMERATION_TYPE_P (type))\n     {\n-      tree t = build_integral_nontype_arg_conv (type, expr, complain);\n-      t = maybe_constant_value (t);\n-      if (t != error_mark_node)\n-\texpr = t;\n+      if (cxx_dialect < cxx11)\n+\t{\n+\t  tree t = build_converted_constant_expr (type, expr, complain);\n+\t  t = maybe_constant_value (t);\n+\t  if (t != error_mark_node)\n+\t    expr = t;\n+\t}\n \n       if (!same_type_ignoring_top_level_qualifiers_p (type, TREE_TYPE (expr)))\n \treturn error_mark_node;\n@@ -6606,8 +6590,7 @@ convert_nontype_argument (tree type, tree expr, tsubst_flags_t complain)\n \t\treturn NULL_TREE;\n \t      expr = cxx_constant_value (expr);\n \t      if (errorcount > errs || warningcount + werrorcount > warns)\n-\t\tinform (EXPR_LOC_OR_LOC (expr, input_location),\n-\t\t\t\"in template argument for type %qT \", type);\n+\t\tinform (loc, \"in template argument for type %qT \", type);\n \t      if (expr == error_mark_node)\n \t\treturn NULL_TREE;\n \t      /* else cxx_constant_value complained but gave us\n@@ -6629,6 +6612,23 @@ convert_nontype_argument (tree type, tree expr, tsubst_flags_t complain)\n      conversion (_conv.array_) are applied.  */\n   else if (TYPE_PTROBV_P (type))\n     {\n+      tree decayed = expr;\n+\n+      /* Look through any NOP_EXPRs around an ADDR_EXPR, whether they come from\n+\t decay_conversion or an explicit cast.  If it's a problematic cast,\n+\t we'll complain about it below.  */\n+      if (TREE_CODE (expr) == NOP_EXPR)\n+\t{\n+\t  tree probe = expr;\n+\t  STRIP_NOPS (probe);\n+\t  if (TREE_CODE (probe) == ADDR_EXPR\n+\t      && TYPE_PTR_P (TREE_TYPE (probe)))\n+\t    {\n+\t      expr = probe;\n+\t      expr_type = TREE_TYPE (expr);\n+\t    }\n+\t}\n+\n       /* [temp.arg.nontype]/1  (TC1 version, DR 49):\n \n \t A template-argument for a non-type, non-template template-parameter\n@@ -6648,23 +6648,22 @@ convert_nontype_argument (tree type, tree expr, tsubst_flags_t complain)\n \t;\n       else if (cxx_dialect >= cxx11 && integer_zerop (expr))\n \t/* Null pointer values are OK in C++11.  */;\n-      else if (TREE_CODE (expr) != ADDR_EXPR\n-\t       && TREE_CODE (expr_type) != ARRAY_TYPE)\n+      else if (TREE_CODE (expr) != ADDR_EXPR)\n \t{\n \t  if (VAR_P (expr))\n \t    {\n \t      if (complain & tf_error)\n \t\terror (\"%qD is not a valid template argument \"\n \t\t       \"because %qD is a variable, not the address of \"\n-\t\t       \"a variable\", expr, expr);\n+\t\t       \"a variable\", orig_expr, expr);\n \t      return NULL_TREE;\n \t    }\n \t  if (POINTER_TYPE_P (expr_type))\n \t    {\n \t      if (complain & tf_error)\n \t\terror (\"%qE is not a valid template argument for %qT \"\n \t\t       \"because it is not the address of a variable\",\n-\t\t       expr, type);\n+\t\t       orig_expr, type);\n \t      return NULL_TREE;\n \t    }\n \t  /* Other values, like integer constants, might be valid\n@@ -6673,31 +6672,29 @@ convert_nontype_argument (tree type, tree expr, tsubst_flags_t complain)\n \t}\n       else\n \t{\n-\t  tree decl;\n+\t  tree decl = TREE_OPERAND (expr, 0);\n \n-\t  decl = ((TREE_CODE (expr) == ADDR_EXPR)\n-\t\t  ? TREE_OPERAND (expr, 0) : expr);\n \t  if (!VAR_P (decl))\n \t    {\n \t      if (complain & tf_error)\n \t\terror (\"%qE is not a valid template argument of type %qT \"\n-\t\t       \"because %qE is not a variable\", expr, type, decl);\n+\t\t       \"because %qE is not a variable\", orig_expr, type, decl);\n \t      return NULL_TREE;\n \t    }\n \t  else if (cxx_dialect < cxx11 && !DECL_EXTERNAL_LINKAGE_P (decl))\n \t    {\n \t      if (complain & tf_error)\n \t\terror (\"%qE is not a valid template argument of type %qT \"\n \t\t       \"because %qD does not have external linkage\",\n-\t\t       expr, type, decl);\n+\t\t       orig_expr, type, decl);\n \t      return NULL_TREE;\n \t    }\n \t  else if ((cxx_dialect >= cxx11 && cxx_dialect < cxx1z)\n \t\t   && decl_linkage (decl) == lk_none)\n \t    {\n \t      if (complain & tf_error)\n \t\terror (\"%qE is not a valid template argument of type %qT \"\n-\t\t       \"because %qD has no linkage\", expr, type, decl);\n+\t\t       \"because %qD has no linkage\", orig_expr, type, decl);\n \t      return NULL_TREE;\n \t    }\n \t  /* C++17: For a non-type template-parameter of reference or pointer\n@@ -6734,9 +6731,7 @@ convert_nontype_argument (tree type, tree expr, tsubst_flags_t complain)\n \t    }\n \t}\n \n-      expr = decay_conversion (expr, complain);\n-      if (expr == error_mark_node)\n-\treturn error_mark_node;\n+      expr = decayed;\n \n       expr = perform_qualification_conversions (type, expr);\n       if (expr == error_mark_node)\n@@ -23858,7 +23853,7 @@ value_dependent_expression_p (tree expression)\n \t      {\n \t\ttree t = TREE_OPERAND (expression, i);\n \n-\t\t/* In some cases, some of the operands may be missing.l\n+\t\t/* In some cases, some of the operands may be missing.\n \t\t   (For example, in the case of PREDECREMENT_EXPR, the\n \t\t   amount to increment by may be missing.)  That doesn't\n \t\t   make the expression dependent.  */"}, {"sha": "98bb502249af49d97f879d5749e27d11110899e0", "filename": "gcc/testsuite/g++.dg/cpp0x/constexpr-targ.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6d7d61861c8fa7207570abb6fc23c5a2921e4da/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-targ.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6d7d61861c8fa7207570abb6fc23c5a2921e4da/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-targ.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-targ.C?ref=e6d7d61861c8fa7207570abb6fc23c5a2921e4da", "patch": "@@ -10,4 +10,4 @@ struct B\n { };\n \n constexpr A a { };\n-B<a> b;\t\t\t\t// { dg-error \"template argument|invalid type\" }\n+B<a> b;\t\t\t // { dg-error \"template argument|converted constant\" }"}, {"sha": "8d9726999003514faed477005c6eba87447674fc", "filename": "gcc/testsuite/g++.dg/template/crash106.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6d7d61861c8fa7207570abb6fc23c5a2921e4da/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fcrash106.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6d7d61861c8fa7207570abb6fc23c5a2921e4da/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fcrash106.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fcrash106.C?ref=e6d7d61861c8fa7207570abb6fc23c5a2921e4da", "patch": "@@ -11,4 +11,4 @@ template<T N = 0, void (A::*)() = &A::foo<N> > struct B {}; // { dg-error \"type|\n \n B<> b; // { dg-message \"non-type\" }\n \n-// { dg-prune-output \"could not convert\" }\n+// { dg-prune-output \"(could not convert|no matches)\" }"}, {"sha": "b3099d931c2ede5bb525e92719622ede565b7207", "filename": "gcc/testsuite/g++.dg/template/crash84.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6d7d61861c8fa7207570abb6fc23c5a2921e4da/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fcrash84.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6d7d61861c8fa7207570abb6fc23c5a2921e4da/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fcrash84.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fcrash84.C?ref=e6d7d61861c8fa7207570abb6fc23c5a2921e4da", "patch": "@@ -14,7 +14,7 @@ void\n foo ()\n {\n   a<int> a1; // OK\n-  a<int>::b<a,int> b1; // { dg-error \"template argument\" }\n+  a<int>::b<a,int> b1; // { dg-error \"template argument|converted constant\" }\n }\n \n // { dg-prune-output \"invalid type in declaration\" }"}, {"sha": "af81edbfd80a09da42a76679065830c6c8ec9c55", "filename": "gcc/testsuite/g++.dg/template/crash87.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6d7d61861c8fa7207570abb6fc23c5a2921e4da/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fcrash87.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6d7d61861c8fa7207570abb6fc23c5a2921e4da/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fcrash87.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fcrash87.C?ref=e6d7d61861c8fa7207570abb6fc23c5a2921e4da", "patch": "@@ -17,7 +17,7 @@ template <bool name>\n class BUG2 : BUG\n {\n public:\n- typedef BUG1_5<name> ptr; // { dg-error \"could not convert template argument\" }\n+ typedef BUG1_5<name> ptr; // { dg-error \"convert\" }\n };\n \n int main()"}, {"sha": "8fffbf85317ad8bbf6c9d97895745136a3d938d3", "filename": "gcc/testsuite/g++.dg/template/dependent-args1.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6d7d61861c8fa7207570abb6fc23c5a2921e4da/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fdependent-args1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6d7d61861c8fa7207570abb6fc23c5a2921e4da/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fdependent-args1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fdependent-args1.C?ref=e6d7d61861c8fa7207570abb6fc23c5a2921e4da", "patch": "@@ -10,4 +10,4 @@ template<int N, void (A::*)() = &A::foo<N> > struct B {};\n \n B<int> b; // { dg-error \"type/value mismatch|expected a constant|invalid type\" }\n \n-// { dg-prune-output \"could not convert\" }\n+// { dg-prune-output \"(could not convert|no match)\" }"}, {"sha": "f22551b0f1adfb7c037a33bce181dead8b93a8e9", "filename": "gcc/testsuite/g++.dg/template/nontype-array1.C", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6d7d61861c8fa7207570abb6fc23c5a2921e4da/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fnontype-array1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6d7d61861c8fa7207570abb6fc23c5a2921e4da/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fnontype-array1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fnontype-array1.C?ref=e6d7d61861c8fa7207570abb6fc23c5a2921e4da", "patch": "@@ -10,17 +10,31 @@ constexpr char const s3[] = \"hi\";  // OK since C++11\n \n constexpr char const * f() { return s3; }\n \n+using fn_p = char const * (*)();\n+template <fn_p> struct A { };\n+constexpr fn_p f2() { return f; }\n+\n+struct B\n+{\n+  constexpr B() { }\n+  constexpr operator const char *() { return s3; }\n+};\n+\n int main()\n {\n   Message<s1> m1;  // OK (all versions)\n   Message<s2> m2;  // OK for clang since C++14, for gcc since C++17\n   Message<s3> m3;  // OK for clang/gcc since C++11\n \n+  A<f2()> a1; // { dg-error \"\" \"\" { target c++14_down } }\n+\n   static char const s4[] = \"hi\";\n   static constexpr char const s5[] = \"hi\";  // OK since C++11\n   Message<s4> m4;  // { dg-error \"no linkage\" \"\" { target c++14_down } }\n   Message<s5> m5;  // { dg-error \"no linkage\" \"\" { target c++14_down } }\n   Message<f()> m6; // { dg-error \"\" \"\" { target c++14_down } }\n+  Message<B{}> m7; // { dg-error \"\" \"\" { target c++14_down } }\n+\n \n   char const s8[] = \"hi\";\n   Message<s8> m8;  // { dg-error \"\" }"}, {"sha": "3250109aa4a66387153b80a3c1549c6e523f9774", "filename": "gcc/testsuite/g++.dg/template/nontype13.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6d7d61861c8fa7207570abb6fc23c5a2921e4da/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fnontype13.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6d7d61861c8fa7207570abb6fc23c5a2921e4da/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fnontype13.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fnontype13.C?ref=e6d7d61861c8fa7207570abb6fc23c5a2921e4da", "patch": "@@ -11,7 +11,7 @@ struct Dummy\n   template<bool B>\n   void tester()\n   {\n-    bar<evil>()(); // { dg-error \"constant|template\" }\n+    bar<evil>()(); // { dg-error \"constant|template|convert\" }\n   }\n   template<bool B>\n   struct bar"}, {"sha": "508f9090240269d362c27d853d3cfaf4f5aefd9e", "filename": "gcc/testsuite/g++.dg/template/nontype21.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6d7d61861c8fa7207570abb6fc23c5a2921e4da/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fnontype21.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6d7d61861c8fa7207570abb6fc23c5a2921e4da/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fnontype21.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fnontype21.C?ref=e6d7d61861c8fa7207570abb6fc23c5a2921e4da", "patch": "@@ -4,4 +4,4 @@ template<char const * const x> class Something { };\n \n extern char const xyz;\n \n-class SomethingElse:public Something<xyz> { }; // { dg-error \"xyz. is a variable\" }\n+class SomethingElse:public Something<xyz> { }; // { dg-error \"\" }"}, {"sha": "588ce1cc23a79c025a4a006776de92546c3fe2ad", "filename": "gcc/testsuite/g++.dg/template/nontype26.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6d7d61861c8fa7207570abb6fc23c5a2921e4da/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fnontype26.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6d7d61861c8fa7207570abb6fc23c5a2921e4da/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fnontype26.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fnontype26.C?ref=e6d7d61861c8fa7207570abb6fc23c5a2921e4da", "patch": "@@ -7,7 +7,7 @@ template<int& i> void doit() {\n template<const int& i> class X {\n public:\n     void foo() {\n-      doit<i>();  // { dg-error \"cv-qualification|no matching\" }\n+      doit<i>();  // { dg-error \"qualifi|template arg|no matching\" }\n     }\n };\n "}, {"sha": "e17ed84c739fa103b657c9aece3b562f58def084", "filename": "gcc/testsuite/g++.dg/template/ptrmem20.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6d7d61861c8fa7207570abb6fc23c5a2921e4da/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fptrmem20.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6d7d61861c8fa7207570abb6fc23c5a2921e4da/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fptrmem20.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fptrmem20.C?ref=e6d7d61861c8fa7207570abb6fc23c5a2921e4da", "patch": "@@ -12,5 +12,5 @@ template<void (A::*)()> void bar(); // { dg-message \"note\" }\n \n void baz()\n {\n-  bar<&B::foo>();  // { dg-error \"not a valid template argument|no match\" }\n+  bar<&B::foo>();  // { dg-error \"template argument|no match\" }\n }"}, {"sha": "b759b7077d53a61170c781182d07409f7a7b59e2", "filename": "gcc/testsuite/g++.dg/template/ptrmem8.C", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6d7d61861c8fa7207570abb6fc23c5a2921e4da/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fptrmem8.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6d7d61861c8fa7207570abb6fc23c5a2921e4da/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fptrmem8.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fptrmem8.C?ref=e6d7d61861c8fa7207570abb6fc23c5a2921e4da", "patch": "@@ -15,10 +15,8 @@ template <int (D::*fun)() const> int Get(); // { dg-message \"note\" }\n \n int main () \n {\n-  Get<&B::I>();   // { dg-error \"not a valid template argument\" \"not valid\" }\n+  Get<&B::I>();   // { dg-error \"template argument|converted constant\" \"not valid\" }\n   // { dg-error \"no match\" \"no match\" { target *-*-* } .-1 }\n-  // { dg-message \"note\" \"note\" { target *-*-* } .-2 }\n-  Get<&D::I>();   // { dg-error \"not a valid template argument\" \"not valid\" }\n+  Get<&D::I>();   // { dg-error \"template argument|converted constant\" \"not valid\" }\n   // { dg-error \"no match\" \"no match\" { target *-*-* } .-1 }\n-  // { dg-message \"note\" \"note\" { target *-*-* } .-2 }\n }"}]}