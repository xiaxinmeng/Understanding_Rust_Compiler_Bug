{"sha": "8cf35364643df8970fcf402fdb28d91791035052", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGNmMzUzNjQ2NDNkZjg5NzBmY2Y0MDJmZGIyOGQ5MTc5MTAzNTA1Mg==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@redhat.com", "date": "2002-09-23T17:56:33Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2002-09-23T17:56:33Z"}, "message": "re PR libgcj/6576 (java.util.ResourceBundle.getResource ignores locale)\n\n\tFix for PR libgcj/6576:\n\t* java/util/ResourceBundle.java (tryBundle): Cache `null' if we\n\tdidn't find a given bundle.\n\t(getBundle): Don't require base bundle.\n\t(setParent): Removed old comment.\n\t(tryLocalBundle): Try components even if preceding components were\n\tempty.\n\nFrom-SVN: r57442", "tree": {"sha": "d3b62264406cd1f7ed67426981f9c8dc908b0614", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d3b62264406cd1f7ed67426981f9c8dc908b0614"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8cf35364643df8970fcf402fdb28d91791035052", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8cf35364643df8970fcf402fdb28d91791035052", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8cf35364643df8970fcf402fdb28d91791035052", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8cf35364643df8970fcf402fdb28d91791035052/comments", "author": null, "committer": null, "parents": [{"sha": "97d48e5ad4061b9240a2a9ded1448a39a4587843", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/97d48e5ad4061b9240a2a9ded1448a39a4587843", "html_url": "https://github.com/Rust-GCC/gccrs/commit/97d48e5ad4061b9240a2a9ded1448a39a4587843"}], "stats": {"total": 218, "additions": 135, "deletions": 83}, "files": [{"sha": "7d56136011067aded7026e24a2ea983be3761e2f", "filename": "libjava/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cf35364643df8970fcf402fdb28d91791035052/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cf35364643df8970fcf402fdb28d91791035052/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=8cf35364643df8970fcf402fdb28d91791035052", "patch": "@@ -1,3 +1,13 @@\n+2002-09-22  Tom Tromey  <tromey@redhat.com>\n+\n+\tFix for PR libgcj/6576:\n+\t* java/util/ResourceBundle.java (tryBundle): Cache `null' if we\n+\tdidn't find a given bundle.\n+\t(getBundle): Don't require base bundle.\n+\t(setParent): Removed old comment.\n+\t(tryLocalBundle): Try components even if preceding components were\n+\tempty.\n+\n 2002-09-22  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* Makefile.am (all-multi): Fix multilib parallel build."}, {"sha": "bfb6b3063374c6bb142554cdacd7f993795dcd5f", "filename": "libjava/java/util/ResourceBundle.java", "status": "modified", "additions": 125, "deletions": 83, "changes": 208, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cf35364643df8970fcf402fdb28d91791035052/libjava%2Fjava%2Futil%2FResourceBundle.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cf35364643df8970fcf402fdb28d91791035052/libjava%2Fjava%2Futil%2FResourceBundle.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FResourceBundle.java?ref=8cf35364643df8970fcf402fdb28d91791035052", "patch": "@@ -65,7 +65,7 @@\n baseName_<i>def. language</i>\n baseName</pre>\n  *\n- * <p>A bundle is backed up by less specific bundles (omiting variant, country\n+ * <p>A bundle is backed up by less specific bundles (omitting variant, country\n  * or language). But it is not backed up by the default language locale.\n  *\n  * <p>If you provide a bundle for a given locale, say\n@@ -239,7 +239,6 @@ public Locale getLocale()\n    */\n   protected void setParent(ResourceBundle parent)\n   {\n-    // Shall we ignore the old parent?\n     this.parent = parent;\n   }\n \n@@ -362,42 +361,59 @@ public static final ResourceBundle getBundle(String baseName,\n         cache = new HashMap();\n         resourceBundleCache.put(classLoader, cache);\n       }\n-    else\n+    else if (cache.containsKey(name))\n       {\n-        Reference ref = (Reference) cache.get(name);\n-        if (ref != null)\n-          {\n-            ResourceBundle rb = (ResourceBundle) ref.get();\n-            if (rb != null)\n-              // rb should already have the right parent, except if\n-              // something very strange happened.\n-              return rb;\n-          }\n+\tReference ref = (Reference) cache.get(name);\n+\tResourceBundle result = null;\n+\t// If REF is null, that means that we added a `null' value to\n+\t// the hash map.  That means we failed to find the bundle\n+\t// previously, and we cached that fact.  The JDK does this, so\n+\t// it must be ok.\n+\tif (ref == null)\n+\t  throw new MissingResourceException(\"Bundle \" + baseName\n+\t\t\t\t\t     + \" not found\",\n+\t\t\t\t\t     baseName, \"\");\n+\telse\n+\t  {\n+\t    ResourceBundle rb = (ResourceBundle) ref.get();\n+\t    if (rb != null)\n+\t      {\n+\t\t// RB should already have the right parent, except if\n+\t\t// something very strange happened.\n+\t\treturn rb;\n+\t      }\n+\t    // If RB is null, then we previously found it but it was\n+\t    // collected.  So we try again.\n+\t  }\n       }\n \n+    // It is ok if this returns null.  We aren't required to have the\n+    // base bundle.\n     ResourceBundle baseBundle = tryBundle(baseName, emptyLocale,\n                                           classLoader, null, cache);\n-    if (baseBundle == null)\n-      // JDK says, that if one provides a bundle base_en_UK, one\n-      // must also provide the bundles base_en and base.\n-      // This implies that if there is no bundle for base, there\n-      // is no bundle at all.\n-      throw new MissingResourceException(\"Bundle \" + baseName + \" not found\",\n-                                         baseName, \"\");\n \n-    // Now use the default locale.\n+    // Now use our locale, followed by the default locale.  We only\n+    // need to try the default locale if our locale is different, and\n+    // if our locale failed to yield a result other than the base\n+    // bundle.\n     ResourceBundle bundle = tryLocalBundle(baseName, locale,\n                                            classLoader, baseBundle, cache);\n     if (bundle == baseBundle && !locale.equals(Locale.getDefault()))\n-      bundle = tryLocalBundle(baseName, Locale.getDefault(),\n-                              classLoader, baseBundle, cache);\n+      {\n+\tbundle = tryLocalBundle(baseName, Locale.getDefault(),\n+\t\t\t\tclassLoader, baseBundle, cache);\n+\t// We need to record that the argument locale maps to the\n+\t// bundle we just found.  If we didn't find a bundle, record\n+\t// that instead.\n+\tif (bundle == null)\n+\t  cache.put(name, null);\n+\telse\n+\t  cache.put(name, new SoftReference(bundle));\n+      }\n \n-    // Check whether baseName_locale has been loaded; if not, map the\n-    // \"baseName\" bundle to \"baseName_locale\" to avoid retrying to load\n-    // baseName_locale.\n-    Reference ref = (Reference) cache.get(name);\n-    if (ref == null)\n-      cache.put(name, new SoftReference(bundle));\n+    if (bundle == null)\n+      throw new MissingResourceException(\"Bundle \" + baseName + \" not found\",\n+\t\t\t\t\t baseName, \"\");\n \n     return bundle;\n   }\n@@ -440,15 +456,28 @@ private static final ResourceBundle tryBundle(String localizedName,\n                                                 HashMap cache)\n   {\n     // First look into the cache.\n-    // XXX We should remove cleared references from the cache.\n-    Reference ref = (Reference) cache.get(localizedName);\n-    if (ref != null)\n+    if (cache.containsKey(localizedName))\n       {\n-        ResourceBundle rb = (ResourceBundle) ref.get();\n-        if (rb != null)\n-          // rb should already have the right parent, except if\n-          // something very strange happened.\n-          return rb;\n+\tReference ref = (Reference) cache.get(localizedName);\n+\tResourceBundle result = null;\n+\t// If REF is null, that means that we added a `null' value to\n+\t// the hash map.  That means we failed to find the bundle\n+\t// previously, and we cached that fact.  The JDK does this, so\n+\t// it must be ok.\n+\tif (ref == null)\n+\t  return null;\n+\telse\n+\t  {\n+\t    ResourceBundle rb = (ResourceBundle) ref.get();\n+\t    if (rb != null)\n+\t      {\n+\t\t// RB should already have the right parent, except if\n+\t\t// something very strange happened.\n+\t\treturn rb;\n+\t      }\n+\t    // If RB is null, then we previously found it but it was\n+\t    // collected.  So we try again.\n+\t  }\n       }\n \n     // foundBundle holds exact matches for the localizedName resource\n@@ -470,76 +499,89 @@ private static final ResourceBundle tryBundle(String localizedName,\n         // ignore them all\n       }\n     if (foundBundle == null)\n-      try\n-        {\n-          InputStream is;\n-          final String resourceName\n-            = localizedName.replace('.', '/') + \".properties\";\n-          if (classloader == null)\n-            is = ClassLoader.getSystemResourceAsStream(resourceName);\n-          else\n-            is = classloader.getResourceAsStream(resourceName);\n-          if (is != null)\n-            {\n-              foundBundle = new PropertyResourceBundle(is);\n-              foundBundle.parent = bundle;\n-              foundBundle.locale = locale;\n-            }\n-        }\n-      catch (IOException ex)\n-        {\n-        }\n+      {\n+\ttry\n+\t  {\n+\t    InputStream is;\n+\t    final String resourceName\n+\t      = localizedName.replace('.', '/') + \".properties\";\n+\t    if (classloader == null)\n+\t      is = ClassLoader.getSystemResourceAsStream(resourceName);\n+\t    else\n+\t      is = classloader.getResourceAsStream(resourceName);\n+\t    if (is != null)\n+\t      {\n+\t\tfoundBundle = new PropertyResourceBundle(is);\n+\t\tfoundBundle.parent = bundle;\n+\t\tfoundBundle.locale = locale;\n+\t      }\n+\t  }\n+\tcatch (IOException ex)\n+\t  {\n+\t  }\n+      }\n \n-    if (foundBundle != null)\n+    // Put the result into the hash table.  If we didn't find anything\n+    // here, we record our parent bundle.  If we record `null' that means\n+    // nothing, not even the base, was found.\n+    if (foundBundle == null)\n+      foundBundle = bundle;\n+    if (foundBundle == null)\n+      cache.put(localizedName, null);\n+    else\n       cache.put(localizedName, new SoftReference(foundBundle));\n-\n-    return foundBundle != null ? foundBundle : bundle;\n+    return foundBundle;\n   }\n \n   /**\n    * Tries to load a the bundle for a given locale, also loads the backup\n    * locales with the same language.\n    *\n    * @param name the name\n-   * @param locale the locale, that must be used exactly\n+   * @param locale the locale\n    * @param classloader the classloader\n    * @param bundle the backup (parent) bundle\n    * @return the resource bundle if it was loaded, otherwise the backup\n    */\n   private static final ResourceBundle tryLocalBundle(String baseName,\n-                                                     Locale locale,\n+\t\t\t\t\t\t     Locale locale,\n                                                      ClassLoader classloader,\n                                                      ResourceBundle bundle,\n                                                      HashMap cache)\n   {\n     final String language = locale.getLanguage();\n+    final String country = locale.getCountry();\n+    final String variant = locale.getVariant();\n+\n     StringBuffer sb = new StringBuffer(60);\n+    sb.append(baseName);\n+    sb.append('_');\n \n     if (language.length() > 0)\n       {\n-        final String country = locale.getCountry();\n-        sb.append(baseName).append('_').append(language);\n-        String name = sb.toString();\n-\n-        if (country.length() != 0)\n-          {\n-            bundle = tryBundle(name, new Locale(language),\n-                               classloader, bundle, cache);\n-            sb.append('_').append(country);\n-            name = sb.toString();\n-\n-            final String variant = locale.getVariant();\n-\n-            if (variant.length() != 0)\n-              {\n-                bundle = tryBundle(name, new Locale(language, country),\n-                                   classloader, bundle, cache);\n-                sb.append('_').append(variant);\n-                name = sb.toString();\n-              }\n-          }\n-        bundle = tryBundle(name, locale, classloader, bundle, cache);\n+\tsb.append(language);\n+\tbundle = tryBundle(sb.toString(), new Locale(language),\n+\t\t\t   classloader, bundle, cache);\n+      }\n+    // If LANGUAGE was empty, we still need to try the other\n+    // components, and the `_' is required.\n+    sb.append('_');\n+\n+    if (country.length() > 0)\n+      {\n+\tsb.append(country);\n+\tbundle = tryBundle(sb.toString(), new Locale(language, country),\n+\t\t\t   classloader, bundle, cache);\n+      }\n+    sb.append('_');\n+\n+    if (variant.length() > 0)\n+      {\n+\tsb.append(variant);\n+\tbundle = tryBundle(sb.toString(), locale,\n+\t\t\t   classloader, bundle, cache);\n       }\n+\n     return bundle;\n   }\n-} // class ResourceBundle\n+}"}]}