{"sha": "1f414ac48f4a946930e35c5003b5f020ad8168c4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWY0MTRhYzQ4ZjRhOTQ2OTMwZTM1YzUwMDNiNWYwMjBhZDgxNjhjNA==", "commit": {"author": {"name": "Bruce Korb", "email": "korbb@gcc.gnu.org", "date": "1999-03-03T07:41:52Z"}, "committer": {"name": "Bruce Korb", "email": "korbb@gcc.gnu.org", "date": "1999-03-03T07:41:52Z"}, "message": "Merge from fixincl-branch\n\nFrom-SVN: r25558", "tree": {"sha": "479ea57b8451b885c972eec0fba1e784cb5fca7c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/479ea57b8451b885c972eec0fba1e784cb5fca7c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1f414ac48f4a946930e35c5003b5f020ad8168c4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f414ac48f4a946930e35c5003b5f020ad8168c4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1f414ac48f4a946930e35c5003b5f020ad8168c4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f414ac48f4a946930e35c5003b5f020ad8168c4/comments", "author": null, "committer": null, "parents": [{"sha": "9a9f6326f2f7d333567dbe114edd245672eff566", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a9f6326f2f7d333567dbe114edd245672eff566", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9a9f6326f2f7d333567dbe114edd245672eff566"}], "stats": {"total": 2402, "additions": 1406, "deletions": 996}, "files": [{"sha": "c1aa9c22f5ea0b54653d7a6f01e4524aaf7a97a7", "filename": "gcc/fixinc/Makefile.in", "status": "modified", "additions": 29, "deletions": 16, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f414ac48f4a946930e35c5003b5f020ad8168c4/gcc%2Ffixinc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f414ac48f4a946930e35c5003b5f020ad8168c4/gcc%2Ffixinc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffixinc%2FMakefile.in?ref=1f414ac48f4a946930e35c5003b5f020ad8168c4", "patch": "@@ -1,5 +1,5 @@\n-# Makefile for GNU C++ compiler.\n-#   Copyright (C) 1987, 88, 90-5, 1998 Free Software Foundation, Inc.\n+# Makefile for GNU compilers.\n+#   Copyright (C) 1998, 1999 Free Software Foundation, Inc.\n \n #This file is part of GNU CC.\n \n@@ -22,6 +22,7 @@\n # Its purpose is to build the any-platforms fixinc.sh script.\n \n CFLAGS = -g\n+FIXINC_DEFS = @fixinc_defs@\n \n CC = @CC@\n SHELL = /bin/sh\n@@ -39,11 +40,11 @@ default : gen\n \n # Specify the directories to be searched for header files.\n # Both . and srcdir are used, in that order.\n-INCLUDES = -I. -I.. -I$(srcdir) -I$(srcdir)/.. -I$(srcdir)/../config\n+INCLUDES = -I. -I.. -I$(srcdir) -I$(srcdir)/.. -I$(srcdir)/../config -I$(srcdir)/../../include\n \n # Always use -I$(srcdir)/config when compiling.\n .c.o:\n-\t$(CC) -c $(CFLAGS) $(CPPFLAGS) $(INCLUDES) $<\n+\t$(CC) -c $(CFLAGS) $(FIXINC_DEFS) $(CPPFLAGS) $(INCLUDES) $<\n \n # The only suffixes we want for implicit rules are .c and .o.\n .SUFFIXES:\n@@ -55,12 +56,11 @@ INCLUDES = -I. -I.. -I$(srcdir) -I$(srcdir)/.. -I$(srcdir)/../config\n ##\n ##  Makefile for constructing the \"best\" include fixer we can\n ##\n-##  $Id: Makefile.in,v 1.2 1998/12/16 21:18:54 law Exp $\n-##\n ## # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #\n \n OBJ = fixincl.o server.o regex.o\n HDR = server.h regex.h\n+LIBERTY = ../../libiberty/libiberty.a\n \n SH_TARGET  = inclhack.sh fixincl.sh\n BIN_TARGET = fixincl\n@@ -75,13 +75,13 @@ gen : $(SH_TARGET) fixincl.x\n $(OBJ): $(HDR)\n \n fixincl: $(OBJ)\n-\t@echo $(CC) -o $@ $(OBJ) $(LIB) ; \\\n-\tif $(CC) -o $@ $(OBJ) $(LIB) ; then : ; else \\\n+\t@echo $(CC) -o $@ $(OBJ) $(LIBERTY) $(LIB) ; \\\n+\tif $(CC) -o $@ $(OBJ) $(LIBERTY) $(LIB) ; then : ; else \\\n \trm -f $@ ; (echo \"#! /bin/sh\" ; echo exit 1 ) > $@ ; \\\n \tchmod 777 $@ ; fi\n \n regex.o: regex.c\n-\t-$(CC) $(CFLAGS) -DSTDC_HEADERS=1 -c regex.c\n+\t-$(CC) $(CFLAGS) $(FIXINC_DEFS) -DSTDC_HEADERS=1 -c $(srcdir)/regex.c\n \n fixincl.o : fixincl.x fixincl.c\n server.o : server.c server.h\n@@ -92,21 +92,28 @@ fixincl.x: fixincl.tpl inclhack.def\n \t\tautogen -T $(srcdir)/fixincl.tpl -b fixincl \\\n \t\t\t$(srcdir)/inclhack.def ; \\\n \telse echo You need to install autogen ; \\\n-\t\t$(CP) $(srcdir)/$@ . ; fi\n+\t\tif [ `pwd` != `cd $(srcdir) ; pwd` ] ; then \\\n+\t\t\t$(CP) $(srcdir)/$@ . ; \\\n+\t\telse touch $@ ; fi ; fi\n \n inclhack.sh: inclhack.def inclhack.tpl hackshell.tpl\n \t@if ( autogen --help > /dev/null 2>&1 ) ; then \\\n \t\techo autogen inclhack.def ; \\\n-\t\tautogen inclhack.def ; \\\n+\t\tautogen -L$(srcdir) $(srcdir)/inclhack.def ; \\\n \telse echo You need to install autogen ; \\\n-\t\t$(CP) $(srcdir)/$@ . ; fi\n+\t\tif [ `pwd` != `cd $(srcdir) ; pwd` ] ; then \\\n+\t\t\t$(CP) $(srcdir)/$@ . ; \\\n+\t\telse touch $@ ; fi ; fi\n \n fixincl.sh: inclhack.def inclhack.tpl\n \t@if ( autogen --help > /dev/null 2>&1 ) ; then \\\n \t\techo autogen -DPROGRAM=1 -b fixincl inclhack.def ; \\\n-\t\tautogen -DPROGRAM=1 -b fixincl inclhack.def ; touch $@ ; \\\n+\t\tautogen -DPROGRAM=1 -b fixincl -L$(srcdir) \\\n+\t\t\t$(srcdir)/inclhack.def ; touch $@ ; \\\n \telse echo You need to install autogen ; \\\n-\t\t$(CP) $(srcdir)/$@ . ; fi\n+\t\tif [ `pwd` != `cd $(srcdir) ; pwd` ] ; then \\\n+\t\t\t$(CP) $(srcdir)/$@ . ; \\\n+\t\telse touch $@ ; fi ; fi\n \n clean:\n \trm -f *.o $(TARGETS) fixincl.x\n@@ -120,13 +127,19 @@ install: $(TARGETS)\n \t@rm -f ../fixinc.sh ; \\\n \tif ( ./fixincl -v > /dev/null 2>&1 ) ; then \\\n \t\techo cp fixincl.sh ../fixinc.sh ; \\\n-\t\tcp fixincl.sh ../fixinc.sh ; \\\n+\t\tif [ -f ./fixincl.sh ] ; \\\n+\t\tthen cp fixincl.sh ../fixinc.sh ; \\\n+\t\telse cp $(srcdir)/fixincl.sh ../fixinc.sh ; fi ; \\\n \t\tchmod 555 ../fixinc.sh ; \\\n \t\trm -f ../fixincl ; \\\n \t\techo cp fixincl .. ; \\\n \t\tcp fixincl .. ; \\\n \t\tchmod 555 ../fixincl ; \\\n \telse \\\n+\t\techo Could not install binary fixincludes.  ; \\\n+\t\techo Installing shell script instead. ; \\\n \t\techo cp inclhack.sh ../fixinc.sh ; \\\n-\t\tcp inclhack.sh ../fixinc.sh ; \\\n+\t\tif [ -f ./inclhack.sh ] ; \\\n+\t\tthen cp inclhack.sh ../fixinc.sh ; \\\n+\t\telse cp $(srcdir)/inclhack.sh ../fixinc.sh ; fi ; \\\n \tfi"}, {"sha": "951fb857c04d33764da4f355e301d62673776ecf", "filename": "gcc/fixinc/fixincl.c", "status": "modified", "additions": 691, "deletions": 488, "changes": 1179, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f414ac48f4a946930e35c5003b5f020ad8168c4/gcc%2Ffixinc%2Ffixincl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f414ac48f4a946930e35c5003b5f020ad8168c4/gcc%2Ffixinc%2Ffixincl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffixinc%2Ffixincl.c?ref=1f414ac48f4a946930e35c5003b5f020ad8168c4", "patch": "@@ -1,219 +1,291 @@\n-/*\n- * $Id: fixincl.c,v 1.2 1998/12/16 21:19:03 law Exp $\n- *\n- * Install modified versions of certain ANSI-incompatible system header\n- * files which are fixed to work correctly with ANSI C and placed in a\n- * directory that GNU C will search.\n- *\n- * See README-fixinc for more information.\n- *\n- *  fixincl is free software.\n- *  \n- *  You may redistribute it and/or modify it under the terms of the\n- *  GNU General Public License, as published by the Free Software\n- *  Foundation; either version 2, or (at your option) any later version.\n- *  \n- *  fixincl is distributed in the hope that it will be useful,\n- *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n- *  See the GNU General Public License for more details.\n- *  \n- *  You should have received a copy of the GNU General Public License\n- *  along with fixincl.  See the file \"COPYING\".  If not,\n- *  write to:  The Free Software Foundation, Inc.,\n- *             59 Temple Place - Suite 330,\n- *             Boston,  MA  02111-1307, USA.\n- */\n \n+/* Install modified versions of certain ANSI-incompatible system header\n+   files which are fixed to work correctly with ANSI C and placed in a\n+   directory that GNU C will search.\n+\n+   Copyright (C) 1997, 1998, 1999 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+#ifdef FIXINC_BROKEN\n+/* The fixincl program is known to not run properly on this particular\n+   system.  Instead of producing a probably broken executable, we force\n+   a compilation error and let the mkfixinc.sh script install the\n+   inclhack.sh shell script instead.  */\n+# include \"The fixincl program does not work properly on this system!\"\n+#endif\n+\n+#include \"config.h\"\n+\n+#include <sys/types.h>\n #include <sys/param.h>\n #include <sys/stat.h>\n-#include <sys/types.h>\n+#ifdef HAVE_SYS_WAIT_H\n #include <sys/wait.h>\n+#endif\n #include <signal.h>\n #include <stdio.h>\n+#ifdef HAVE_UNISTD_H\n #include <unistd.h>\n+#endif\n #include <stdlib.h>\n #include <errno.h>\n #include <string.h>\n+#ifdef HAVE_FCNTL_H\n #include <fcntl.h>\n+#endif\n #include <ctype.h>\n \n #include \"regex.h\"\n #include \"server.h\"\n \n+static const char program_id[] = \"fixincl version 1.0\";\n+\n+#define MINIMUM_MAXIMUM_LINES   128\n+\n+/* If this particular system's header files define the macro `MAXPATHLEN',\n+   we happily take advantage of it; otherwise we use a value which ought\n+   to be large enough.  */\n+#ifndef MAXPATHLEN\n+# define MAXPATHLEN     4096\n+#endif\n+#define NAME_TABLE_SIZE (MINIMUM_MAXIMUM_LINES * MAXPATHLEN)\n+\n+char *file_name_buf;\n+\n #define tSCC static const char\n #define tCC  const char\n #define tSC  static char\n \n-typedef int tSuccess;\n+typedef int t_success;\n+\n+#define FAILURE         (-1)\n+#define SUCCESS           0\n+#define PROBLEM           1\n \n-#define FAILURE  ((tSuccess)-1)\n-#define SUCCESS  ((tSuccess) 0)\n-#define PROBLEM  ((tSuccess) 1)\n+#define SUCCEEDED(p)    ((p) == SUCCESS)\n+#define SUCCESSFUL(p)   SUCCEEDED (p)\n+#define FAILED(p)       ((p) < SUCCESS)\n+#define HADGLITCH(p)    ((p) > SUCCESS)\n \n-#define SUCCEEDED( p )     ((p) == SUCCESS)\n-#define SUCCESSFUL( p )    SUCCEEDED( p )\n-#define FAILED( p )        ((p) <  SUCCESS)\n-#define HADGLITCH( p )     ((p) >  SUCCESS)\n+#define NUL             '\\0'\n \n-#define NUL '\\0'\n+/*  Test Descriptor\n \n+    Each fix may have associated tests that determine\n+    whether the fix needs to be applied or not.\n+    Each test has a type (from the te_test_type enumeration);\n+    associated test text; and, if the test is TT_EGREP or\n+    the negated form TT_NEGREP, a pointer to the compiled\n+    version of the text string.\n+\n+    */\n typedef enum\n-  {\n-    TT_TEST, TT_EGREP, TT_NEGREP\n-  }\n-teTestType;\n+{\n+  TT_TEST, TT_EGREP, TT_NEGREP\n+} te_test_type;\n \n typedef struct test_desc tTestDesc;\n \n struct test_desc\n-  {\n-    teTestType type;\n-    const char *pzTest;\n-    regex_t *pTestRegex;\n-  };\n+{\n+  te_test_type type;\n+  const char *pz_test_text;\n+  regex_t *p_test_regex;\n+};\n \n typedef struct patch_desc tPatchDesc;\n \n+/*  Fix Descriptor\n+\n+    Everything you ever wanted to know about how to apply\n+    a particular fix (which files, how to qualify them,\n+    how to actually make the fix, etc...)\n+\n+    */\n #define FD_MACH_ONLY      0x0000\n #define FD_MACH_IFNOT     0x0001\n #define FD_SKIP_TEST      0x8000\n \n typedef struct fix_desc tFixDesc;\n struct fix_desc\n-  {\n-    const char*   pzFixName;     /* Name of the fix */\n-    const char*   pzFileList;    /* List of files it applies to */\n-    const char**  papzMachs;     /* List of machine/os-es it applies to */\n-    regex_t*      pListRegex;\n-    int           testCt;\n-    int           fdFlags;\n-    tTestDesc*    pTestDesc;\n-    const char**  papzPatchArgs;\n-  };\n-\n-char *pzDestDir   = (char *) NULL;\n-char *pzSrcDir    = (char *) NULL;\n-char *pzMachine   = (char *) NULL;\n-\n-pid_t chainHead = (pid_t) - 1;\n-\n-const char zInclQuote[] = \"^[ \\t]*#[ \\t]*include[ \\t]*\\\"[^/]\";\n-regex_t inclQuoteRegex;\n-\n-char zFileNameBuf[0x8000];\n-\n-char *loadFile (const char *pzFile);\n-void process (char *data, const char *dir, const char *file);\n-void runCompiles (void);\n+{\n+  const char*   fix_name;       /* Name of the fix */\n+  const char*   file_list;      /* List of files it applies to */\n+  const char**  papz_machs;     /* List of machine/os-es it applies to */\n+  regex_t*      unused;\n+  int           test_ct;\n+  int           fd_flags;\n+  tTestDesc*    p_test_desc;\n+  const char**  patch_args;\n+};\n+\n+/*  Working environment strings.  Essentially, invocation 'options'.  */\n+char *pz_dest_dir = NULL;\n+char *pz_src_dir = NULL;\n+char *pz_machine = NULL;\n+\n+pid_t process_chain_head = (pid_t) -1;\n+\n+const char incl_quote_pat[] = \"^[ \\t]*#[ \\t]*include[ \\t]*\\\"[^/]\";\n+regex_t incl_quote_re;\n+\n+char *load_file (const char *pzFile);\n+void process (char *data, const char *file);\n+void run_compiles (void);\n \n #include \"fixincl.x\"\n \n-\n+/* * * * * * * * * * * * * * * * * * *\n+ *\n+ *  MAIN ROUTINE\n+ */\n int\n main (argc, argv)\n      int argc;\n      char **argv;\n {\n-  static const char zGnuLib[] =\n-  \"This file is part of the GNU C Library\";\n-  static const char zVarNotFound[] =\n-      \"fixincl ERROR:  %s environment variable not defined\\n\";\n+  static const char gnu_lib_mark[] =\n+    \"This file is part of the GNU C Library\";\n+  static const char var_not_found[] =\n+    \"fixincl ERROR:  %s environment variable not defined\\n\";\n \n #ifndef NO_BOGOSITY_LIMITS\n-# define BOGUS_LIMIT 256\n-  size_t loopCt;\n+# define BOGUS_LIMIT    MINIMUM_MAXIMUM_LINES\n+  size_t loop_ct;\n #endif\n \n-  char *apzNames[BOGUS_LIMIT];\n-  size_t fileNameCt;\n+  char *apz_names[BOGUS_LIMIT];\n+  size_t file_name_ct;\n \n-  if (argc != 1)\n+  /* Before anything else, ensure we can allocate our file name buffer. */\n+  file_name_buf = (char *) malloc (NAME_TABLE_SIZE);\n+  if (file_name_buf == (char *) NULL)\n     {\n-      if (argc != 2)\n-        {\n-          fputs (\"fixincl ERROR:  too many command line arguments\\n\", stderr);\n-          exit (EXIT_FAILURE);\n-        }\n+      fprintf (stderr, \"fixincl cannot allocate 0x%08X bytes\\n\",\n+               NAME_TABLE_SIZE);\n+      exit (EXIT_FAILURE);\n+    }\n \n+  switch (argc)\n+    {\n+    case 1:\n+      break;\n+\n+    case 2:\n       if (strcmp (argv[1], \"-v\") == 0)\n         {\n-          fputs (\"$Id: fixincl.c,v 1.2 1998/12/16 21:19:03 law Exp $\\n\", stderr);\n-          exit (EXIT_SUCCESS);\n+          static const char zFmt[] = \"echo '%s'\";\n+\n+          /* The 'version' option is really used to test that:\n+               1.  The program loads correctly (no missing libraries)\n+               2.  we can correctly run our server shell process\n+               3.  that we can compile all the regular expressions.\n+           */\n+          run_compiles ();\n+          sprintf (file_name_buf, zFmt, program_id);\n+          fputs (file_name_buf + 5, stdout);\n+          exit (strcmp (run_shell (file_name_buf), program_id));\n         }\n-\n       freopen (argv[1], \"r\", stdin);\n+      break;\n+\n+    default:\n+      fputs (\"fixincl ERROR:  too many command line arguments\\n\", stderr);\n+      exit (EXIT_FAILURE);\n     }\n \n   {\n-    static const char zVar[] = \"TARGET_MACHINE\";\n-    pzMachine = getenv( zVar );\n-    if (pzMachine == (char *)NULL)\n+    static const char var[] = \"TARGET_MACHINE\";\n+    pz_machine = getenv (var);\n+    if (pz_machine == (char *) NULL)\n       {\n-        fprintf( stderr, zVarNotFound, zVar );\n+        fprintf (stderr, var_not_found, var);\n         exit (EXIT_FAILURE);\n       }\n   }\n \n   {\n-    static const char zVar[] = \"DESTDIR\";\n-    pzDestDir = getenv( zVar );\n-    if (pzDestDir == (char *)NULL)\n+    static const char var[] = \"DESTDIR\";\n+    pz_dest_dir = getenv (var);\n+    if (pz_dest_dir == (char *) NULL)\n       {\n-        fprintf( stderr, zVarNotFound, zVar );\n+        fprintf (stderr, var_not_found, var);\n         exit (EXIT_FAILURE);\n       }\n   }\n \n   {\n-    static const char zVar[] = \"SRCDIR\";\n-    pzSrcDir = getenv( zVar );\n-    if (pzSrcDir == (char *)NULL)\n+    static const char var[] = \"SRCDIR\";\n+    pz_src_dir = getenv (var);\n+    if (pz_src_dir == (char *) NULL)\n       {\n-        fprintf( stderr, zVarNotFound, zVar );\n+        fprintf (stderr, var_not_found, var);\n         exit (EXIT_FAILURE);\n       }\n   }\n \n-  runCompiles ();\n+  /*  Compile all the regular expressions now.\n+      That way, it is done only once for the whole run.\n+      */\n+  run_compiles ();\n \n-  signal ( SIGQUIT, SIG_IGN );\n-  signal ( SIGIOT,  SIG_IGN );\n-  signal ( SIGPIPE, SIG_IGN );\n-  signal ( SIGALRM, SIG_IGN );\n-  signal ( SIGTERM, SIG_IGN );\n-  signal ( SIGCHLD, SIG_IGN );\n+  signal (SIGQUIT, SIG_IGN);\n+  signal (SIGIOT,  SIG_IGN);\n+  signal (SIGPIPE, SIG_IGN);\n+  signal (SIGALRM, SIG_IGN);\n+  signal (SIGTERM, SIG_IGN);\n \n #ifndef NO_BOGOSITY_LIMITS\n+  /*  Some systems only allow so many calls to fork(2).\n+      This is inadequate for this program.  Consequently,\n+      we must let a grandfather process spawn children\n+      that then spawn all the processes that do the real work.\n+      */\n   for (;;)\n     {\n-      char *pzBuf;\n+      char *pz_buf;\n       pid_t child;\n \n-      /*\n-       *  Only the parent process can read from stdin without\n-       *  confusing the world.  (How does the child tell the\n-       *  parent to skip forward?  Pipes and files behave differently.)\n-       */\n-      for (fileNameCt = 0, pzBuf = zFileNameBuf;\n-           (fileNameCt < BOGUS_LIMIT)\n-           && (pzBuf\n-               < (zFileNameBuf + sizeof (zFileNameBuf) - MAXPATHLEN));\n-        )\n+      /* Only the parent process can read from stdin without confusing\n+         the world. (How does the child tell the parent to skip\n+         forward?  Pipes and files behave differently.)  */\n+      file_name_ct = 0;\n+      pz_buf = file_name_buf;\n+      while (  (file_name_ct < BOGUS_LIMIT)\n+            && (pz_buf < (file_name_buf + NAME_TABLE_SIZE - MAXPATHLEN)))\n         {\n-\n-          if (fgets (pzBuf, MAXPATHLEN, stdin) == (char *) NULL)\n+          if (fgets (pz_buf, MAXPATHLEN, stdin) == (char *) NULL)\n             break;\n-          while (isspace (*pzBuf))\n-            pzBuf++;\n-          apzNames[fileNameCt++] = pzBuf;\n-          pzBuf += strlen (pzBuf);\n-          while (isspace (pzBuf[-1]))\n-            pzBuf--;\n-          *pzBuf++ = '\\0';\n+          while (isspace (*pz_buf))\n+            pz_buf++;\n+          if ((*pz_buf == '\\0') || (*pz_buf == '#'))\n+            continue;\n+          apz_names[file_name_ct++] = pz_buf;\n+          pz_buf += strlen (pz_buf);\n+          while (isspace (pz_buf[-1]))\n+            pz_buf--;\n+          *pz_buf++ = '\\0';\n         }\n \n-      if (fileNameCt == 0)\n+      /*  IF we did not get any files this time thru\n+          THEN we must be done.  */\n+      if (file_name_ct == 0)\n         return EXIT_SUCCESS;\n \n       child = fork ();\n@@ -226,88 +298,111 @@ main (argc, argv)\n                    errno, strerror (errno));\n           exit (EXIT_FAILURE);\n         }\n+#ifdef DEBUG\n+      fprintf (stderr, \"Waiting for %d to complete %d files\\n\",\n+               child, file_name_ct);\n+#endif\n+      {\n+        int status;\n+        pid_t dead_kid = wait (&status);\n \n-      waitpid (child, (int *) NULL, 0);\n+        if (dead_kid != child)\n+          fprintf (stderr, \"fixincl woke up from a strange child %d (not %d)\\n\",\n+                   dead_kid, child);\n+#ifdef DEBUG\n+        else\n+          fprintf (stderr, \"child finished %d files %s\\n\", file_name_ct,\n+                   status ? strerror (status & 0xFF) : \"ok\");\n+#endif\n+      }\n     }\n #else\n #error \"NON-BOGUS LIMITS NOT SUPPORTED?!?!\"\n #endif\n \n-  /*\n-   *  For every file specified in stdandard in\n-   *  (except as throttled for bogus reasons)...\n-   */\n-  for (loopCt = 0; loopCt < fileNameCt; loopCt++)\n+#ifdef DEBUG\n+  fprintf (stderr, \"Child start  --  processing %d files\\n\",\n+           file_name_ct);\n+#endif\n+\n+  /*  For every file specified in stdandard in\n+      (except as throttled for bogus reasons)...\n+      */\n+  for (loop_ct = 0; loop_ct < file_name_ct; loop_ct++)\n     {\n-      char *pzData;\n-      char *pzFile = apzNames[loopCt];\n+      char *pz_data;\n+      char *pz_file_name = apz_names[loop_ct];\n \n-      if (access (pzFile, R_OK) != 0)\n+      if (access (pz_file_name, R_OK) != 0)\n         {\n           int erno = errno;\n           fprintf (stderr, \"Cannot access %s from %s\\n\\terror %d (%s)\\n\",\n-                   pzFile, getcwd ((char *) NULL, MAXPATHLEN),\n+                   pz_file_name, getcwd ((char *) NULL, MAXPATHLEN),\n                    erno, strerror (erno));\n         }\n-      else if (pzData = loadFile (pzFile),\n-               (pzData != (char *) NULL))\n+      else if (pz_data = load_file (pz_file_name), (pz_data != (char *) NULL))\n         {\n-\n-          if (strstr (pzData, zGnuLib) == (char *) NULL)\n-            process (pzData, pzDestDir, pzFile);\n-\n-          free ((void *) pzData);\n+          if (strstr (pz_data, gnu_lib_mark) == (char *) NULL)\n+            process (pz_data, pz_file_name);\n+          free ((void *) pz_data);\n         }\n     }\n \n   return EXIT_SUCCESS;\n }\n \n \n+/* * * * * * * * * * * * *\n+ \n+   load_file loads all the contents of a file into malloc-ed memory.\n+   Its argument is the name of the file to read in; the returned\n+   result is the NUL terminated contents of the file.  The file\n+   is presumed to be an ASCII text file containing no NULs.  */\n char *\n-loadFile (pzFile)\n-     const char *pzFile;\n+load_file (pz_file_name)\n+     const char *pz_file_name;\n {\n-  char *pzDta;\n-  size_t fileSize;\n+  char *pz_data;\n+  size_t file_size;\n \n   {\n     struct stat stbf;\n-    if (stat (pzFile, &stbf) != 0)\n+    \n+    if (stat (pz_file_name, &stbf) != 0)\n       {\n         fprintf (stderr, \"error %d (%s) stat-ing %s\\n\",\n-                 errno, strerror (errno), pzFile);\n+                 errno, strerror (errno), pz_file_name);\n         return (char *) NULL;\n       }\n-    fileSize = stbf.st_size;\n+    file_size = stbf.st_size;\n   }\n-  if (fileSize == 0)\n+  if (file_size == 0)\n     return (char *) NULL;\n \n-  pzDta = (char *) malloc ((fileSize + 16) & ~0x00F);\n-  if (pzDta == (char *) NULL)\n+  pz_data = (char *) malloc ((file_size + 16) & ~0x00F);\n+  if (pz_data == (char *) NULL)\n     {\n       fprintf (stderr, \"error:  could not malloc %d bytes\\n\",\n-               fileSize);\n+               file_size);\n       exit (EXIT_FAILURE);\n     }\n \n   {\n-    FILE *fp = fopen (pzFile, \"r\");\n-    size_t sizeLeft = fileSize;\n-    char *readPtr = pzDta;\n+    FILE *fp = fopen (pz_file_name, \"r\");\n+    size_t size_left = file_size;\n+    char *read_ptr = pz_data;\n \n     if (fp == (FILE *) NULL)\n       {\n         fprintf (stderr, \"error %d (%s) opening %s\\n\", errno,\n-                 strerror (errno), pzFile);\n-        free ((void *) pzDta);\n+                 strerror (errno), pz_file_name);\n+        free ((void *) pz_data);\n         return (char *) NULL;\n       }\n \n     do\n       {\n-        size_t sizeRead = fread ((void *) readPtr, 1, sizeLeft, fp);\n+        size_t sizeRead = fread ((void *) read_ptr, 1, size_left, fp);\n \n         if (sizeRead == 0)\n           {\n@@ -317,518 +412,626 @@ loadFile (pzFile)\n             if (ferror (fp))\n               {\n                 fprintf (stderr, \"error %d (%s) reading %s\\n\", errno,\n-                         strerror (errno), pzFile);\n-                free ((void *) pzDta);\n+                         strerror (errno), pz_file_name);\n+                free ((void *) pz_data);\n                 fclose (fp);\n                 return (char *) NULL;\n               }\n           }\n \n-        readPtr += sizeRead;\n-        sizeLeft -= sizeRead;\n+        read_ptr += sizeRead;\n+        size_left -= sizeRead;\n       }\n-    while (sizeLeft != 0);\n+    while (size_left != 0);\n \n-    *readPtr = '\\0';\n+    *read_ptr = '\\0';\n     fclose (fp);\n-    return pzDta;\n   }\n+  return pz_data;\n }\n \n \n+/* * * * * * * * * * * * *\n+ \n+   run_compiles   run all the regexp compiles for all the fixes once.\n+ */\n void\n-runCompiles ()\n+run_compiles ()\n {\n-  tSCC zBadComp[] = \"fixincl ERROR:  cannot compile %s regex for %s\\n\"\n+  tSCC z_bad_comp[] = \"fixincl ERROR:  cannot compile %s regex for %s\\n\"\n     \"\\texpr = `%s'\\n\" \"\\terror %s\\n\";\n-  tFixDesc *pFD = fixDescList;\n-  int fixCt = FIX_COUNT;\n-  tTestDesc *pTD;\n-  int tstCt;\n-  int reCt = REGEX_COUNT;\n-  const char *pzErr;\n-  regex_t *pRegex = (regex_t *) malloc (REGEX_COUNT * sizeof (regex_t));\n-\n-  if (pRegex == (regex_t *) NULL)\n+  tFixDesc *p_fixd = fixDescList;\n+  int fix_ct = FIX_COUNT;\n+  tTestDesc *p_test;\n+  int test_ct;\n+  int re_ct = REGEX_COUNT;\n+  const char *pz_err;\n+  regex_t *p_re = (regex_t *) malloc (REGEX_COUNT * sizeof (regex_t));\n+\n+  if (p_re == (regex_t *) NULL)\n     {\n       fprintf (stderr, \"fixincl ERROR:  cannot allocate %d bytes for regex\\n\",\n                REGEX_COUNT * sizeof (regex_t));\n       exit (EXIT_FAILURE);\n     }\n \n+  /*  The patterns we search for are all egrep patterns.\n+      In the shell version of this program, we invoke egrep\n+      with the supplied pattern.  Here, we will run\n+      re_compile_pattern, but it must be using the same rules.  */\n+\n   re_set_syntax (RE_SYNTAX_EGREP);\n-  pzErr = re_compile_pattern (zInclQuote, strlen (zInclQuote),\n-                              &inclQuoteRegex);\n-  if (pzErr != (char *) NULL)\n+  pz_err = re_compile_pattern (incl_quote_pat, sizeof (incl_quote_pat)-1,\n+                              &incl_quote_re);\n+  if (pz_err != (char *) NULL)\n     {\n-      fprintf (stderr, zBadComp, \"quoted include\", \"runCompiles\",\n-               zInclQuote, pzErr);\n+      fprintf (stderr, z_bad_comp, \"quoted include\", \"run_compiles\",\n+               incl_quote_pat, pz_err);\n       exit (EXIT_FAILURE);\n     }\n \n-  /*\n-   *  FOR every fixup, ...\n-   */\n+  /* FOR every fixup, ...  */\n   do\n     {\n-      pTD = pFD->pTestDesc;\n-      tstCt = pFD->testCt;\n-\n-      if (pFD->papzMachs != (const char**)NULL) {\n-        const char** papzMachs = pFD->papzMachs;\n-        char*        pz = zFileNameBuf;\n-        char*        pzSep = \"\";\n-        tCC*         pzIfTrue;\n-        tCC*         pzIfFalse;\n-        tSCC         zSkip[] = \"skip\";\n-        tSCC         zRun[]  = \"run\";\n-\n-        sprintf( pz, \"case %s in\\n\", pzMachine );\n-        pz += strlen( pz );\n-\n-        if (pFD->fdFlags & FD_MACH_IFNOT) {\n-          pzIfTrue  = zSkip;\n-          pzIfFalse = zRun;\n-        } else {\n-          pzIfTrue  = zRun;\n-          pzIfFalse = zSkip;\n-        }\n+      p_test = p_fixd->p_test_desc;\n+      test_ct = p_fixd->test_ct;\n \n-        for (;;) {\n-          const char* pzMach = *(papzMachs++);\n-          if (pzMach == (const char*)NULL)\n-            break;\n-          sprintf( pz, \"%s  %s\", pzSep, pzMach );\n-          pz += strlen( pz );\n-          pzSep = \" | \\\\\\n\";\n-        }\n-        sprintf( pz, \" )\\n    echo %s ;;\\n  * )\\n    echo %s ;;\\nesac\",\n-                 pzIfTrue, pzIfFalse );\n-        pz = runShell( zFileNameBuf );\n-        if (*pz == 's') {\n-          pFD->fdFlags |= FD_SKIP_TEST;\n-          continue;\n+      /*  IF the machine type pointer is not NULL (we are not in test mode)\n+             AND this test is for or not done on particular machines\n+          THEN ...   */\n+\n+      if (  (pz_machine != NULL)\n+         && (p_fixd->papz_machs != (const char**) NULL) )\n+        {\n+          const char **papz_machs = p_fixd->papz_machs;\n+          char *pz = file_name_buf;\n+          char *pz_sep = \"\";\n+          tCC *pz_if_true;\n+          tCC *pz_if_false;\n+          tSCC skip[] = \"skip\";\n+          tSCC run[] = \"run\";\n+\n+          /*  Construct a shell script that looks like this:\n+\n+              case our-cpu-platform-os in\n+              tests-cpu-platform-os-pattern )\n+                  echo run ;;\n+              * )\n+                  echo skip ;;\n+              esac\n+\n+              where 'run' and 'skip' may be reversed, depending on\n+              the sense of the test.  */\n+\n+          sprintf (pz, \"case %s in\\n\", pz_machine);\n+          pz += strlen (pz);\n+\n+          if (p_fixd->fd_flags & FD_MACH_IFNOT)\n+            {\n+              pz_if_true  = skip;\n+              pz_if_false = run;\n+            }\n+          else\n+            {\n+              pz_if_true  = run;\n+              pz_if_false = skip;\n+            }\n+\n+          /*  FOR any additional machine names to test for,\n+              insert the \" | \\\\\\n\" glue and the machine pattern.  */\n+\n+          for (;;)\n+            {\n+              const char* pz_mach = *(papz_machs++);\n+\n+              if (pz_mach == (const char*) NULL)\n+                break;\n+              sprintf (pz, \"%s  %s\", pz_sep, pz_mach);\n+              pz += strlen (pz);\n+              pz_sep = \" | \\\\\\n\";\n+            }\n+          sprintf (pz, \" )\\n    echo %s ;;\\n  * )\\n    echo %s ;;\\nesac\",\n+                   pz_if_true, pz_if_false);\n+\n+          /*  Run the script.\n+              The result will start either with 's' or 'r'.  */\n+\n+          pz = run_shell (file_name_buf);\n+          if (*pz == 's')\n+            {\n+              p_fixd->fd_flags |= FD_SKIP_TEST;\n+              continue;\n+            }\n         }\n-      }\n \n-      /*\n-       *  FOR every test for the fixup, ...\n-       */\n-      while (--tstCt >= 0)\n+      /* FOR every test for the fixup, ...  */\n+\n+      while (--test_ct >= 0)\n         {\n-          switch (pTD->type)\n+          switch (p_test->type)\n             {\n             case TT_EGREP:\n             case TT_NEGREP:\n-              if (--reCt < 0)\n+              /*  You might consider putting the following under #ifdef.\n+                  The number of re's used is computed by autogen.\n+                  So, it is static and known at compile time.  */\n+\n+              if (--re_ct < 0)\n                 {\n                   fputs (\"out of RE's\\n\", stderr);\n                   exit (EXIT_FAILURE);\n                 }\n \n-              pTD->pTestRegex = pRegex++;\n-              pzErr = re_compile_pattern (pTD->pzTest,\n-                                          strlen (pTD->pzTest),\n-                                          pTD->pTestRegex);\n-              if (pzErr != (char *) NULL)\n+              p_test->p_test_regex = p_re++;\n+              pz_err = re_compile_pattern (p_test->pz_test_text,\n+                                          strlen (p_test->pz_test_text),\n+                                          p_test->p_test_regex);\n+              if (pz_err != (char *) NULL)\n                 {\n-                  fprintf (stderr, zBadComp, \"select test\", pFD->pzFixName,\n-                           pTD->pzTest, pzErr);\n+                  fprintf (stderr, z_bad_comp, \"select test\", p_fixd->fix_name,\n+                           p_test->pz_test_text, pz_err);\n                   exit (EXIT_FAILURE);\n                 }\n             }\n-          pTD++;\n+          p_test++;\n         }\n     }\n-  while (pFD++, --fixCt > 0);\n+  while (p_fixd++, --fix_ct > 0);\n }\n \n \n+/* * * * * * * * * * * * *\n+ \n+   create_file  Create the output modified file.\n+   Input:    the name of the file to create\n+   Returns:  a file pointer to the new, open file  */\n+\n+#define S_IRALL\t(S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)\n+\n FILE *\n-createFile (pzFile)\n-     const char *pzFile;\n+create_file (pz_file_name)\n+     const char *pz_file_name;\n {\n   int fd;\n   FILE *pf;\n   char fname[MAXPATHLEN];\n \n-  sprintf (fname, \"%s/%s\", pzDestDir, pzFile);\n-  unlink (fname);\n+  sprintf (fname, \"%s/%s\", pz_dest_dir, pz_file_name);\n \n-  fd = open (fname, O_WRONLY | O_CREAT);\n+  fd = open (fname, O_WRONLY | O_CREAT | O_TRUNC, S_IRALL);\n \n+  /*  We may need to create the directories needed... */\n   if ((fd < 0) && (errno == ENOENT))\n     {\n-      char *pzDir = strchr (fname + 1, '/');\n+      char *pz_dir = strchr (fname + 1, '/');\n       struct stat stbf;\n \n-      while (pzDir != (char *) NULL)\n+      while (pz_dir != (char *) NULL)\n         {\n-          *pzDir = NUL;\n+          *pz_dir = NUL;\n           if (stat (fname, &stbf) < 0)\n             {\n               mkdir (fname, S_IFDIR | S_IRWXU | S_IRGRP | S_IXGRP\n                      | S_IROTH | S_IXOTH);\n             }\n \n-          *pzDir = '/';\n-          pzDir = strchr (pzDir + 1, '/');\n+          *pz_dir = '/';\n+          pz_dir = strchr (pz_dir + 1, '/');\n         }\n-      fd = open (fname, O_WRONLY | O_CREAT);\n+\n+      /*  Now, lets try the open again... */\n+      fd = open (fname, O_WRONLY | O_CREAT | O_TRUNC, S_IRALL);\n     }\n   if (fd < 0)\n     {\n       fprintf (stderr, \"Error %d (%s) creating %s\\n\",\n                errno, strerror (errno), fname);\n       exit (EXIT_FAILURE);\n     }\n-  fprintf (stderr, \"Fixed:  %s\\n\", pzFile);\n+  fprintf (stderr, \"Fixed:  %s\\n\", pz_file_name);\n   pf = fdopen (fd, \"w\");\n \n #ifdef LATER\n   {\n-    static const char zHdr[] =\n-    \"/*\\n\"\n-    \" *  DO NOT EDIT THIS FILE.\\n\"\n-    \" *\\n\"\n-    \" *  It has been auto-edited by fixincludes from /usr/include/%s\\n\"\n-    \" *  This had to be done to correct non-standard usages in the\\n\"\n-    \" *  original, manufacturer supplied header file.\\n\"\n-    \" */\\n\\n\";\n-\n-    fprintf (pf, zHdr, pzFile);\n+    static const char hdr[] =\n+    \"/*  DO NOT EDIT THIS FILE.\\n\\n\"\n+    \"    It has been auto-edited by fixincludes from /usr/include/%s\\n\"\n+    \"    This had to be done to correct non-standard usages in the\\n\"\n+    \"    original, manufacturer supplied header file.  */\\n\\n\";\n+\n+    fprintf (pf, hdr, pz_file_name);\n   }\n #endif\n   return pf;\n }\n \n-tSuccess\n-testTest (pTest, pzFile)\n-     tTestDesc *pTest;\n-     char*      pzFile;\n-{\n-  char *pzRes;\n-  tSuccess res = FAILURE;\n \n-  static char zCmdBuf[4096];\n-  tSCC zCmdFmt[] = \"file=%s\\nif ( test %s ) > /dev/null 2>&1\\n\"\n-  \"then echo TRUE\\n\" \"else echo FALSE\\n\" \"fi\";\n+/* * * * * * * * * * * * *\n \n-  sprintf (zCmdBuf, zCmdFmt, pzFile, pTest->pzTest);\n-  pzRes = runShell (zCmdBuf);\n-  if (*pzRes == 'T')\n+  test_test   make sure a shell-style test expression passes.\n+  Input:  a pointer to the descriptor of the test to run and\n+          the name of the file that we might want to fix\n+  Result: SUCCESS or FAILURE, depending on the result of the\n+          shell script we run.  */\n+\n+t_success\n+test_test (p_test, pz_file_name)\n+     tTestDesc *p_test;\n+     char*      pz_file_name;\n+{\n+  char *pz_res;\n+  t_success res = FAILURE;\n+\n+  static char cmd_buf[4096];\n+  tSCC cmd_fmt[] =\n+    \"file=%s\\n\"\n+    \"if ( test %s ) > /dev/null 2>&1\\n\"\n+    \"then echo TRUE\\n\"\n+    \"else echo FALSE\\n\"\n+    \"fi\";\n+\n+  sprintf (cmd_buf, cmd_fmt, pz_file_name, p_test->pz_test_text);\n+  pz_res = run_shell (cmd_buf);\n+  if (*pz_res == 'T')\n     res = SUCCESS;\n-  free ((void *) pzRes);\n+  free ((void *) pz_res);\n   return res;\n }\n \n \n-tSuccess\n-egrepTest (pzDta, pTest)\n-     char *pzDta;\n-     tTestDesc *pTest;\n+/* * * * * * * * * * * * *\n+ \n+  egrep_test   make sure an egrep expression is found in the file text.\n+  Input:  a pointer to the descriptor of the test to run and\n+          the pointer to the contents of the file under suspicion\n+  Result: SUCCESS if the pattern is found, FAILURE otherwise\n+\n+  The caller may choose 'FAILURE' as 'SUCCESS' if the sense of the test\n+  is inverted.  */\n+\n+t_success\n+egrep_test (pz_data, p_test)\n+     char *pz_data;\n+     tTestDesc *p_test;\n {\n   regmatch_t match;\n+\n #ifndef NO_BOGOSITY\n-  if (pTest->pTestRegex == 0)\n-    fprintf (stderr, \"fixincl ERROR RE not compiled:  `%s'\\n\", pTest->pzTest);\n+  if (p_test->p_test_regex == 0)\n+    fprintf (stderr, \"fixincl ERROR RE not compiled:  `%s'\\n\",\n+             p_test->pz_test_text);\n #endif\n-  if (regexec (pTest->pTestRegex, pzDta, 1, &match, 0) == 0)\n+  if (regexec (p_test->p_test_regex, pz_data, 1, &match, 0) == 0)\n     return SUCCESS;\n   return FAILURE;\n }\n \n \n+/* * * * * * * * * * * * *\n+ *\n+   extract_quoted_files\n+  \n+   The syntax, `#include \"file.h\"' specifies that the compiler is to\n+   search the local directory of the current file before the include\n+   list.  Consequently, if we have modified a header and stored it in\n+   another directory, any files that are included by that modified\n+   file in that fashion must also be copied into this new directory.\n+   This routine finds those flavors of #include and for each one found\n+   emits a triple of:\n+  \n+    1.  source directory of the original file\n+    2.  the relative path file name of the #includ-ed file\n+    3.  the full destination path for this file\n+\n+   Input:  the text of the file, the file name and a pointer to the\n+           match list where the match information was stored.\n+   Result: internally nothing.  The results are written to stdout\n+           for interpretation by the invoking shell  */\n \n void\n-extractQuotedFiles (pzDta, pzFile, pMatch)\n-     char *pzDta;\n-     const char *pzFile;\n-     regmatch_t *pMatch;\n+extract_quoted_files (pz_data, pz_file_name, p_re_match)\n+     char *pz_data;\n+     const char *pz_file_name;\n+     regmatch_t *p_re_match;\n {\n-  char *pzDirEnd = strrchr (pzFile, '/');\n-  char *pzInclQuot = pzDta;\n+  char *pz_dir_end = strrchr (pz_file_name, '/');\n+  char *pz_incl_quot = pz_data;\n \n-  fprintf (stderr, \"Quoted includes in %s\\n\", pzFile);\n+  fprintf (stderr, \"Quoted includes in %s\\n\", pz_file_name);\n \n-  /*\n-   *  Set \"pzFile\" to point to the containing subdirectory of the source\n-   *  If there is none, then it is in our current direcory, \".\".\n-   */\n-  if (pzDirEnd == (char *) NULL)\n-    pzFile = \".\";\n+  /*  Set \"pz_file_name\" to point to the containing subdirectory of the source\n+      If there is none, then it is in our current direcory, \".\".   */\n+\n+  if (pz_dir_end == (char *) NULL)\n+    pz_file_name = \".\";\n   else\n-    *pzDirEnd = '\\0';\n+    *pz_dir_end = '\\0';\n \n   for (;;)\n     {\n-      pzInclQuot += pMatch->rm_so;\n-\n-      /*\n-       *  Skip forward to the included file name\n-       */\n-      while (isspace (*pzInclQuot))\n-        pzInclQuot++;\n-      while (isspace (*++pzInclQuot));\n-      pzInclQuot += sizeof (\"include\") - 1;\n-      while (*pzInclQuot++ != '\"');\n-\n-      /*\n-       *  Print the source directory and the subdirectory of the file\n-       *  in question.\n-       */\n-      printf (\"%s  %s/\", pzSrcDir, pzFile);\n-      pzDirEnd = pzInclQuot;\n-\n-      /*\n-       *  Append to the directory the relative path of the desired file\n-       */\n-      while (*pzInclQuot != '\"')\n-        putc (*pzInclQuot++, stdout);\n-\n-      /*\n-       *  Now print the destination directory appended with the relative\n-       *  path of the desired file\n-       */\n-      printf (\"  %s/%s/\", pzDestDir, pzFile);\n-      while (*pzDirEnd != '\"')\n-        putc (*pzDirEnd++, stdout);\n-\n-      /*\n-       *  End of entry\n-       */\n+      pz_incl_quot += p_re_match->rm_so;\n+\n+      /*  Skip forward to the included file name */\n+      while (isspace (*pz_incl_quot))\n+        pz_incl_quot++;\n+      while (isspace (*++pz_incl_quot))\n+        ;\n+      pz_incl_quot += sizeof (\"include\") - 1;\n+      while (*pz_incl_quot++ != '\"')\n+        ;\n+\n+      /* Print the source directory and the subdirectory of the file\n+         in question.  */\n+      printf (\"%s  %s/\", pz_src_dir, pz_file_name);\n+      pz_dir_end = pz_incl_quot;\n+\n+      /* Append to the directory the relative path of the desired file */\n+      while (*pz_incl_quot != '\"')\n+        putc (*pz_incl_quot++, stdout);\n+\n+      /* Now print the destination directory appended with the\n+         relative path of the desired file */\n+      printf (\"  %s/%s/\", pz_dest_dir, pz_file_name);\n+      while (*pz_dir_end != '\"')\n+        putc (*pz_dir_end++, stdout);\n+\n+      /* End of entry */\n       putc ('\\n', stdout);\n \n-      /*\n-       *  Find the next entry\n-       */\n-      if (regexec (&inclQuoteRegex, pzInclQuot, 1, pMatch, 0) != 0)\n+      /* Find the next entry */\n+      if (regexec (&incl_quote_re, pz_incl_quot, 1, p_re_match, 0) != 0)\n         break;\n     }\n }\n \n \n-/*\n- *  Process the potential fixes for a particular include file\n- */\n+/* * * * * * * * * * * * *\n+\n+   Process the potential fixes for a particular include file.\n+   Input:  the original text of the file and the file's name\n+   Result: none.  A new file may or may not be created.  */\n+\n void\n-process (pzDta, pzDir, pzFile)\n-     char *pzDta;\n-     const char *pzDir;\n-     const char *pzFile;\n+process (pz_data, pz_file_name)\n+     char *pz_data;\n+     const char *pz_file_name;\n {\n-  static char zEnvFile[1024] =\n-    {\"file=\"};\n-  tFixDesc *pFD = fixDescList;\n-  int todoCt = FIX_COUNT;\n-  tFdPair fdp =\n-    {-1, -1};\n+  static char env_current_file[1024] = { \"file=\" };\n+  tFixDesc *p_fixd = fixDescList;\n+  int todo_ct = FIX_COUNT;\n+  t_fd_pair fdp = { -1, -1 };\n \n-  /*\n-   *  IF this is the first time through,\n-   *  THEN put the 'file' environment variable into the environment.\n-   *       This is used by some of the subject shell scripts and tests.\n-   */\n-  if (zEnvFile[5] == NUL)\n-    putenv (zEnvFile);\n+  /*  IF this is the first time through,\n+      THEN put the 'file' environment variable into the environment.\n+           This is used by some of the subject shell scripts and tests.   */\n \n-  /*\n-   *  Ghastly as it is, this actually updates the value of the variable:\n-   *\n-   *    putenv(3C)             C Library Functions             putenv(3C)\n-   *\n-   *    DESCRIPTION\n-   *         putenv() makes the value of the  environment  variable  name\n-   *         equal  to value by altering an existing variable or creating\n-   *         a new one.  In either case, the string pointed to by  string\n-   *         becomes part of the environment, so altering the string will\n-   *         change the environment.  string points to a  string  of  the\n-   *         form  ``name=value.''  The space used by string is no longer\n-   *         used once a new string-defining name is passed to putenv().\n-   */\n-  strcpy (zEnvFile + 5, pzFile);\n-  chainHead = NOPROCESS;\n+  if (env_current_file[5] == NUL)\n+    putenv (env_current_file);\n \n   /*\n-   *  For every fix in our fix list, ...\n+     Ghastly as it is, this actually updates the value of the variable:\n+   \n+       putenv(3C)             C Library Functions             putenv(3C)\n+   \n+       DESCRIPTION\n+            putenv() makes the value of the  environment  variable  name\n+            equal  to value by altering an existing variable or creating\n+            a new one.  In either case, the string pointed to by  string\n+            becomes part of the environment, so altering the string will\n+            change the environment.  string points to a  string  of  the\n+            form  ``name=value.''  The space used by string is no longer\n+            used once a new string-defining name is passed to putenv().\n    */\n-  for (; todoCt > 0; pFD++, todoCt--)\n+  strcpy (env_current_file + 5, pz_file_name);\n+  process_chain_head = NOPROCESS;\n+\n+  /* For every fix in our fix list, ...  */\n+  for (; todo_ct > 0; p_fixd++, todo_ct--)\n     {\n-      tTestDesc *pTD;\n-      int tstCt;\n-      tSuccess egrepRes;\n+      tTestDesc *p_test;\n+      int test_ct;\n \n-      if (pFD->fdFlags & FD_SKIP_TEST)\n+      if (p_fixd->fd_flags & FD_SKIP_TEST)\n         continue;\n \n-      /*\n-       *  IF there is a file name restriction,\n-       *  THEN ensure the current file name matches one in the pattern\n-       */\n-      if (pFD->pzFileList != (char *) NULL)\n+      /*  IF there is a file name restriction,\n+          THEN ensure the current file name matches one in the pattern  */\n+\n+      if (p_fixd->file_list != (char *) NULL)\n         {\n-          const char *pzFil = pzFile;\n-          const char *pzScn = pFD->pzFileList;\n-          size_t nmLen;\n+          const char *pz_fname = pz_file_name;\n+          const char *pz_scan = p_fixd->file_list;\n+          size_t name_len;\n \n-          while ((pzFil[0] == '.') && (pzFil[1] == '/'))\n-            pzFil += 2;\n-          nmLen = strlen (pzFil);\n+          while ((pz_fname[0] == '.') && (pz_fname[1] == '/'))\n+            pz_fname += 2;\n+          name_len = strlen (pz_fname);\n \n           for (;;)\n             {\n-              pzScn = strstr (pzScn + 1, pzFil);\n-              if (pzScn == (char *) NULL)\n-                goto nextFix;\n+              pz_scan = strstr (pz_scan + 1, pz_fname);\n+              /*  IF we can't match the string at all,\n+                  THEN bail  */\n+              if (pz_scan == (char *) NULL)\n+                goto next_fix;\n \n-              if ((pzScn[-1] == '|') && (pzScn[nmLen] == '|'))\n+              /*  IF the match is surrounded by the '|' markers,\n+                  THEN we found a full match -- time to run the tests  */\n+\n+              if ((pz_scan[-1] == '|') && (pz_scan[name_len] == '|'))\n                 break;\n             }\n         }\n \n-      egrepRes = PROBLEM;\n+      /*  FOR each test, see if it fails.\n+          IF it does fail, then we go on to the next test */\n \n-      /*\n-       *  IF there are no tests\n-       *  THEN we always run the fixup\n-       */\n-      for (pTD = pFD->pTestDesc, tstCt = pFD->testCt;\n-           tstCt-- > 0;\n-           pTD++)\n+      for (p_test = p_fixd->p_test_desc, test_ct = p_fixd->test_ct;\n+           test_ct-- > 0;\n+           p_test++)\n         {\n-          switch (pTD->type)\n+#ifdef DEBUG\n+          static const char z_test_fail[] =\n+            \"%16s test %2d failed for %s\\n\";\n+#endif\n+          switch (p_test->type)\n             {\n             case TT_TEST:\n-              /*\n-               *  IF *any* of the shell tests fail,\n-               *  THEN do not process the fix.\n-               */\n-              if (!SUCCESSFUL (testTest (pTD, pzFile)))\n-                goto nextFix;\n+              if (!SUCCESSFUL (test_test (p_test, pz_file_name)))\n+                {\n+#ifdef DEBUG\n+                  fprintf (stderr, z_test_fail, p_fixd->fix_name,\n+                           p_fixd->test_ct - test_ct, pz_file_name);\n+#endif\n+                  goto next_fix;\n+                }\n               break;\n \n             case TT_EGREP:\n-              /*\n-               *  IF       we have not had a successful egrep test\n-               *    *AND*  this test does not pass,\n-               *  THEN mark the egrep test as failing.  It starts\n-               *       out as a \"PROBLEM\", meaning that if we do not\n-               *       encounter any egrep tests, then we will let it pass.\n-               */\n-              if ((!SUCCESSFUL (egrepRes))\n-                  && (!SUCCESSFUL (egrepTest (pzDta, pTD))))\n-\n-                egrepRes = FAILURE;\n-\n+              if (!SUCCESSFUL (egrep_test (pz_data, p_test)))\n+                {\n+#ifdef DEBUG\n+                  fprintf (stderr, z_test_fail, p_fixd->fix_name,\n+                           p_fixd->test_ct - test_ct, pz_file_name);\n+#endif\n+                  goto next_fix;\n+                }\n               break;\n \n             case TT_NEGREP:\n-              /*\n-               *  IF *any* of the negative egrep tests fail,\n-               *  THEN do not process the fix.\n-               */\n-              if (SUCCESSFUL (egrepTest (pzDta, pTD)))\n-                goto nextFix;\n+              if (SUCCESSFUL (egrep_test (pz_data, p_test)))\n+                {\n+#ifdef DEBUG\n+                  fprintf (stderr, z_test_fail, p_fixd->fix_name,\n+                           p_fixd->test_ct - test_ct, pz_file_name);\n+#endif\n+                  goto next_fix;\n+                }\n               break;\n             }\n         }\n \n-      /*\n-       *  IF there were no egrep tests *OR* at least one passed, ...\n-       */\n-      if (!FAILED (egrepRes))\n-        {\n-          fprintf (stderr, \"Applying %-32s to %s\\n\",\n-                   pFD->pzFixName, pzFile);\n+      fprintf (stderr, \"Applying %-32s to %s\\n\",\n+               p_fixd->fix_name, pz_file_name);\n+\n+      /*  IF we do not have a read pointer,\n+          THEN this is the first fix for the current file.\n+          Open the source file.  That will be used as stdin for\n+          the first fix.  Any subsequent fixes will use the\n+          stdout descriptor of the previous fix as its stdin.  */\n \n-          if (fdp.readFd == -1)\n+      if (fdp.read_fd == -1)\n+        {\n+          fdp.read_fd = open (pz_file_name, O_RDONLY);\n+          if (fdp.read_fd < 0)\n             {\n-              fdp.readFd = open (pzFile, O_RDONLY);\n-              if (fdp.readFd < 0)\n-                {\n-                  fprintf (stderr, \"Error %d (%s) opening %s\\n\", errno,\n-                           strerror (errno), pzFile);\n-                  exit (EXIT_FAILURE);\n-                }\n+              fprintf (stderr, \"Error %d (%s) opening %s\\n\", errno,\n+                       strerror (errno), pz_file_name);\n+              exit (EXIT_FAILURE);\n             }\n+        }\n \n-          for (;;)\n-            {\n-              int newFd = chainOpen (fdp.readFd,\n-                                     (tpChar *) pFD->papzPatchArgs,\n-                                     (chainHead == -1)\n-                                     ? &chainHead : (pid_t *) NULL);\n-              if (newFd != -1)\n-                {\n-                  fdp.readFd = newFd;\n-                  break;\n-                }\n+      /*  This loop should only cycle for 1/2 of one loop.\n+          \"chain_open\" starts a process that uses \"fdp.read_fd\" as\n+          its stdin and returns the new fd this process will use\n+          for stdout.  */\n \n-              fprintf (stderr, \"Error %d (%s) starting filter process \"\n-                       \"for %s\\n\", errno, strerror (errno),\n-                       pFD->pzFixName);\n+      for (;;)\n+        {\n+          static int failCt = 0;\n+          int fd = chain_open (fdp.read_fd,\n+                               (t_pchar *) p_fixd->patch_args,\n+                               (process_chain_head == -1)\n+                               ? &process_chain_head : (pid_t *) NULL);\n \n-              if (errno != EAGAIN)\n-                exit (EXIT_FAILURE);\n-              sleep (1);\n+          if (fd != -1)\n+            {\n+              fdp.read_fd = fd;\n+              break;\n             }\n+\n+          fprintf (stderr, \"Error %d (%s) starting filter process \"\n+                   \"for %s\\n\", errno, strerror (errno),\n+                   p_fixd->fix_name);\n+\n+          if ((errno != EAGAIN) || (++failCt > 10))\n+            exit (EXIT_FAILURE);\n+          sleep (1);\n         }\n \n-    nextFix:;\n+    next_fix:\n+      ;\n     }\n \n-  /*\n-   *  IF after all the tests we did not start any patch programs,\n-   *  THEN quit now.\n-   */\n-  if (fdp.readFd < 0)\n+  /*  IF after all the tests we did not start any patch programs,\n+      THEN quit now.   */\n+\n+  if (fdp.read_fd < 0)\n     return;\n \n+  /*  OK.  We have work to do.  Read back in the output\n+      of the filtering chain.  Compare each byte as we read it with\n+      the contents of the original file.  As soon as we find any\n+      difference, we will create the output file, write out all\n+      the matched text and then copy any remaining data from the\n+      output of the filter chain.\n+      */\n   {\n-    FILE *inFp = fdopen (fdp.readFd, \"r\");\n-    FILE *oFp = (FILE *) NULL;\n-    char *pzCmp = pzDta;\n+    FILE *in_fp = fdopen (fdp.read_fd, \"r\");\n+    FILE *out_fp = (FILE *) NULL;\n+    char *pz_cmp = pz_data;\n \n     for (;;)\n       {\n         int ch;\n \n-        ch = getc (inFp);\n+        ch = getc (in_fp);\n         if (ch == EOF)\n           break;\n \n-        if (oFp != (FILE *) NULL)\n-          putc (ch, oFp);\n+        /*  IF we are emitting the output\n+            THEN emit this character, too.\n+            */\n+        if (out_fp != (FILE *) NULL)\n+          putc (ch, out_fp);\n \n-        else if (ch != *pzCmp)\n+        /*  ELSE if this character does not match the original,\n+            THEN now is the time to start the output.\n+            */\n+        else if (ch != *pz_cmp)\n           {\n-            oFp = createFile (pzFile);\n-            if (pzCmp != pzDta)\n+            out_fp = create_file (pz_file_name);\n+\n+            /*  IF there are matched data, write it all now. */\n+            if (pz_cmp != pz_data)\n               {\n-                char c = *pzCmp;\n-                *pzCmp = NUL;\n-                fputs (pzDta, oFp);\n-                *pzCmp = c;\n+                char c = *pz_cmp;\n+                \n+                *pz_cmp = NUL;\n+                fputs (pz_data, out_fp);\n+                *pz_cmp = c;\n               }\n-            putc (ch, oFp);\n \n+            /*  Emit the current unmatching character */\n+            putc (ch, out_fp);\n           }\n         else\n-          pzCmp++;\n+          /*  ELSE the character matches.  Advance the compare ptr */\n+          pz_cmp++;\n       }\n \n-    if (oFp != (FILE *) NULL)\n+    /*  IF we created the output file, ... */\n+    if (out_fp != (FILE *) NULL)\n       {\n         regmatch_t match;\n \n-        fchmod (fileno (oFp), S_IRUSR | S_IRGRP | S_IROTH);\n-        fclose (oFp);\n-        if (regexec (&inclQuoteRegex, pzDta, 1, &match, 0) == 0)\n-          extractQuotedFiles (pzDta, pzFile, &match);\n+        /* Close the file and see if we have to worry about\n+\t   `#include \"file.h\"' constructs.  */\n+        fclose (out_fp);\n+        if (regexec (&incl_quote_re, pz_data, 1, &match, 0) == 0)\n+          extract_quoted_files (pz_data, pz_file_name, &match);\n       }\n-\n-    fclose (inFp);\n+    fclose (in_fp);\n   }\n-\n-  close (fdp.readFd);\n+  close (fdp.read_fd);  /* probably redundant, but I'm paranoid */\n }"}, {"sha": "1c9ab1413a2230caf20b408f7f150cec1e3b7783", "filename": "gcc/fixinc/fixincl.sh", "status": "modified", "additions": 17, "deletions": 18, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f414ac48f4a946930e35c5003b5f020ad8168c4/gcc%2Ffixinc%2Ffixincl.sh", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f414ac48f4a946930e35c5003b5f020ad8168c4/gcc%2Ffixinc%2Ffixincl.sh", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffixinc%2Ffixincl.sh?ref=1f414ac48f4a946930e35c5003b5f020ad8168c4", "patch": "@@ -2,15 +2,15 @@\n #\n # DO NOT EDIT THIS FILE   (fixincl.sh)\n # \n-# It has been autogen-ed  Friday October 16, 1998 at 07:29:49 AM PDT\n+# It has been autogen-ed  Wednesday January 27, 1999 at 09:03:56 AM PST\n # From the definitions    inclhack.def\n # and the template file   inclhack.tpl\n #\n # Install modified versions of certain ANSI-incompatible system header\n # files which are fixed to work correctly with ANSI C and placed in a\n # directory that GNU C will search.\n #\n-# This script contains 104 fixup scripts.\n+# This script contains 105 fixup scripts.\n #\n # See README-fixinc for more information.\n #\n@@ -127,10 +127,7 @@ for INPUT in ${INPUTLIST} ; do\n \n cd ${ORIGDIR}\n \n-cd ${INPUT} || {\n-  echo 'fixincludes:  input dir `'$INPUT\"' is an invalid directory\"\n-  exit 1\n-}\n+cd ${INPUT} || continue\n \n #\n # # # # # # # # # # # # # # # # # # # # #\n@@ -344,18 +341,20 @@ while [ $# != 0 ]; do\n     #\n     cd ${INPUT}\n     cd $1\n-    if [ -r $2 ] && [ ! -r $3 ]; then\n-      cp $2 $3 >/dev/null 2>&1 || echo \"Can't copy $2\" >&2\n-      chmod +w $3 2>/dev/null\n-      chmod a+r $3 2>/dev/null\n-      echo Copied $2\n-      for include in `egrep '^[ \t]*#[ \t]*include[ \t]*\"[^/]' $3 |\n+    if [ -f $2 ] ; then\n+      if [ -r $2 ] && [ ! -r $3 ]; then\n+        cp $2 $3 >/dev/null 2>&1 || echo \"Can't copy $2\" >&2\n+        chmod +w $3 2>/dev/null\n+        chmod a+r $3 2>/dev/null\n+        echo Copied $2\n+        for include in `egrep '^[ \t]*#[ \t]*include[ \t]*\"[^/]' $3 |\n              sed -e 's/^[ \t]*#[ \t]*include[ \t]*\"\\([^\"]*\\)\".*$/\\1/'`\n-      do\n-\tdir=`echo $2 | sed -e s'|/[^/]*$||'`\n-\tdir2=`echo $3 | sed -e s'|/[^/]*$||'`\n-\tnewreq=\"$newreq $1 $dir/$include $dir2/$include\"\n-      done\n+        do\n+\t  dir=`echo $2 | sed -e s'|/[^/]*$||'`\n+\t  dir2=`echo $3 | sed -e s'|/[^/]*$||'`\n+\t  newreq=\"$newreq $1 $dir/$include $dir2/$include\"\n+        done\n+      fi\n     fi\n     shift; shift; shift\n   done\n@@ -384,6 +383,6 @@ done\n \n cd $ORIGDIR\n rm -f include/assert.h\n-cp ${EGCS_SRCDIR}/assert.h include/assert.h\n+cp ${srcdir}/assert.h include/assert.h || exit 1\n chmod a+r include/assert.h\n "}, {"sha": "cd4174219ef48abd6d9cb49c8849109337d2c772", "filename": "gcc/fixinc/fixincl.x", "status": "modified", "additions": 65, "deletions": 26, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f414ac48f4a946930e35c5003b5f020ad8168c4/gcc%2Ffixinc%2Ffixincl.x", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f414ac48f4a946930e35c5003b5f020ad8168c4/gcc%2Ffixinc%2Ffixincl.x", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffixinc%2Ffixincl.x?ref=1f414ac48f4a946930e35c5003b5f020ad8168c4", "patch": "@@ -1,15 +1,15 @@\n /*\n  * DO NOT EDIT THIS FILE   (fixincl.x)\n  * \n- * It has been autogen-ed  Friday October 16, 1998 at 07:29:50 AM PDT\n+ * It has been autogen-ed  Tuesday January  5, 1999 at 09:20:37 AM PST\n  * From the definitions    inclhack.def\n  * and the template file   fixincl.tpl\n  *\n  * Install modified versions of certain ANSI-incompatible system header\n  * files which are fixed to work correctly with ANSI C and placed in a\n  * directory that GNU C will search.\n  *\n- * This script contains 104 fixup scripts.\n+ * This script contains 105 fixup scripts.\n  *\n  * See README-fixinc for more information.\n  *\n@@ -3005,7 +3005,41 @@ const char* apzUltrix_Ansi_CompatPatch[] = { \"sed\",\n \n /* * * * * * * * * * * * * * * * * * * * * * * * * *\n  *\n- *  Description  84 - Ultrix_Atof_Param fix\n+ *  Description  84 - Ultrix_Fix_Fixproto fix\n+ */\n+tSCC zUltrix_Fix_FixprotoName[] =\n+     \"Ultrix_Fix_Fixproto\";\n+/*\n+ *  File name selection pattern\n+ */\n+tSCC zUltrix_Fix_FixprotoList[] =\n+        \"|\" \"sys/utsname.h\" \"|\";\n+/*\n+ *  Machine/OS name selection pattern\n+ */\n+#define apzUltrix_Fix_FixprotoMachs (const char**)NULL\n+\n+/*\n+ *  content selection pattern\n+ */\n+tSCC zUltrix_Fix_FixprotoSelect0[] =\n+       \"ULTRIX\";\n+\n+#define    ULTRIX_FIX_FIXPROTO_TEST_CT  1\n+tTestDesc aUltrix_Fix_FixprotoTests[] = {\n+    { TT_EGREP,  zUltrix_Fix_FixprotoSelect0, (regex_t*)NULL } };\n+\n+/*\n+ *  Fix Command Arguments for Ultrix_Fix_Fixproto\n+ */\n+const char* apzUltrix_Fix_FixprotoPatch[] = { \"sed\",\n+    \"-e\" \"/^[ \\t]*extern[ \\t]*int[ \\t]*uname();$/i\\\\\\n\"\n+       \"struct utsname;\\n\",\n+    (char*)NULL };\n+\n+/* * * * * * * * * * * * * * * * * * * * * * * * * *\n+ *\n+ *  Description  85 - Ultrix_Atof_Param fix\n  */\n tSCC zUltrix_Atof_ParamName[] =\n      \"Ultrix_Atof_Param\";\n@@ -3034,7 +3068,7 @@ const char* apzUltrix_Atof_ParamPatch[] = { \"sed\",\n \n /* * * * * * * * * * * * * * * * * * * * * * * * * *\n  *\n- *  Description  85 - Ultrix_Const fix\n+ *  Description  86 - Ultrix_Const fix\n  */\n tSCC zUltrix_ConstName[] =\n      \"Ultrix_Const\";\n@@ -3067,7 +3101,7 @@ const char* apzUltrix_ConstPatch[] = { \"sed\",\n \n /* * * * * * * * * * * * * * * * * * * * * * * * * *\n  *\n- *  Description  86 - Ultrix_Ifdef fix\n+ *  Description  87 - Ultrix_Ifdef fix\n  */\n tSCC zUltrix_IfdefName[] =\n      \"Ultrix_Ifdef\";\n@@ -3100,7 +3134,7 @@ const char* apzUltrix_IfdefPatch[] = { \"sed\",\n \n /* * * * * * * * * * * * * * * * * * * * * * * * * *\n  *\n- *  Description  87 - Ultrix_Nested_Cmnt fix\n+ *  Description  88 - Ultrix_Nested_Cmnt fix\n  */\n tSCC zUltrix_Nested_CmntName[] =\n      \"Ultrix_Nested_Cmnt\";\n@@ -3125,7 +3159,7 @@ const char* apzUltrix_Nested_CmntPatch[] = { \"sed\",\n \n /* * * * * * * * * * * * * * * * * * * * * * * * * *\n  *\n- *  Description  88 - Ultrix_Static fix\n+ *  Description  89 - Ultrix_Static fix\n  */\n tSCC zUltrix_StaticName[] =\n      \"Ultrix_Static\";\n@@ -3160,7 +3194,7 @@ const char* apzUltrix_StaticPatch[] = { \"sed\",\n \n /* * * * * * * * * * * * * * * * * * * * * * * * * *\n  *\n- *  Description  89 - Undefine_Null fix\n+ *  Description  90 - Undefine_Null fix\n  */\n tSCC zUndefine_NullName[] =\n      \"Undefine_Null\";\n@@ -3200,7 +3234,7 @@ const char* apzUndefine_NullPatch[] = { \"sed\",\n \n /* * * * * * * * * * * * * * * * * * * * * * * * * *\n  *\n- *  Description  90 - Va_I960_Macro fix\n+ *  Description  91 - Va_I960_Macro fix\n  */\n tSCC zVa_I960_MacroName[] =\n      \"Va_I960_Macro\";\n@@ -3236,7 +3270,7 @@ const char* apzVa_I960_MacroPatch[] = { \"sed\",\n \n /* * * * * * * * * * * * * * * * * * * * * * * * * *\n  *\n- *  Description  91 - Void_Null fix\n+ *  Description  92 - Void_Null fix\n  */\n tSCC zVoid_NullName[] =\n      \"Void_Null\";\n@@ -3279,7 +3313,7 @@ const char* apzVoid_NullPatch[] = { \"sed\",\n \n /* * * * * * * * * * * * * * * * * * * * * * * * * *\n  *\n- *  Description  92 - Vxworks_Gcc_Problem fix\n+ *  Description  93 - Vxworks_Gcc_Problem fix\n  */\n tSCC zVxworks_Gcc_ProblemName[] =\n      \"Vxworks_Gcc_Problem\";\n@@ -3327,7 +3361,7 @@ const char* apzVxworks_Gcc_ProblemPatch[] = { \"sed\",\n \n /* * * * * * * * * * * * * * * * * * * * * * * * * *\n  *\n- *  Description  93 - Vxworks_Needs_Vxtypes fix\n+ *  Description  94 - Vxworks_Needs_Vxtypes fix\n  */\n tSCC zVxworks_Needs_VxtypesName[] =\n      \"Vxworks_Needs_Vxtypes\";\n@@ -3360,7 +3394,7 @@ const char* apzVxworks_Needs_VxtypesPatch[] = { \"sed\",\n \n /* * * * * * * * * * * * * * * * * * * * * * * * * *\n  *\n- *  Description  94 - Vxworks_Needs_Vxworks fix\n+ *  Description  95 - Vxworks_Needs_Vxworks fix\n  */\n tSCC zVxworks_Needs_VxworksName[] =\n      \"Vxworks_Needs_Vxworks\";\n@@ -3407,7 +3441,7 @@ const char* apzVxworks_Needs_VxworksPatch[] = { \"sed\",\n \n /* * * * * * * * * * * * * * * * * * * * * * * * * *\n  *\n- *  Description  95 - Vxworks_Time fix\n+ *  Description  96 - Vxworks_Time fix\n  */\n tSCC zVxworks_TimeName[] =\n      \"Vxworks_Time\";\n@@ -3456,7 +3490,7 @@ const char* apzVxworks_TimePatch[] = { \"sed\",\n \n /* * * * * * * * * * * * * * * * * * * * * * * * * *\n  *\n- *  Description  96 - X11_Class fix\n+ *  Description  97 - X11_Class fix\n  */\n tSCC zX11_ClassName[] =\n      \"X11_Class\";\n@@ -3494,7 +3528,7 @@ const char* apzX11_ClassPatch[] = { \"sed\",\n \n /* * * * * * * * * * * * * * * * * * * * * * * * * *\n  *\n- *  Description  97 - X11_Class_Usage fix\n+ *  Description  98 - X11_Class_Usage fix\n  */\n tSCC zX11_Class_UsageName[] =\n      \"X11_Class_Usage\";\n@@ -3527,7 +3561,7 @@ const char* apzX11_Class_UsagePatch[] = { \"sed\",\n \n /* * * * * * * * * * * * * * * * * * * * * * * * * *\n  *\n- *  Description  98 - X11_New fix\n+ *  Description  99 - X11_New fix\n  */\n tSCC zX11_NewName[] =\n      \"X11_New\";\n@@ -3566,7 +3600,7 @@ const char* apzX11_NewPatch[] = { \"sed\",\n \n /* * * * * * * * * * * * * * * * * * * * * * * * * *\n  *\n- *  Description  99 - X11_Sprintf fix\n+ *  Description 100 - X11_Sprintf fix\n  */\n tSCC zX11_SprintfName[] =\n      \"X11_Sprintf\";\n@@ -3593,7 +3627,7 @@ const char* apzX11_SprintfPatch[] = { \"sed\",\n \n /* * * * * * * * * * * * * * * * * * * * * * * * * *\n  *\n- *  Description 100 - Zzz_Ki_Iface fix\n+ *  Description 101 - Zzz_Ki_Iface fix\n  */\n tSCC zZzz_Ki_IfaceName[] =\n      \"Zzz_Ki_Iface\";\n@@ -3628,7 +3662,7 @@ const char* apzZzz_Ki_IfacePatch[] = { \"sh\", \"-c\",\n \n /* * * * * * * * * * * * * * * * * * * * * * * * * *\n  *\n- *  Description 101 - Zzz_Ki fix\n+ *  Description 102 - Zzz_Ki fix\n  */\n tSCC zZzz_KiName[] =\n      \"Zzz_Ki\";\n@@ -3663,7 +3697,7 @@ const char* apzZzz_KiPatch[] = { \"sh\", \"-c\",\n \n /* * * * * * * * * * * * * * * * * * * * * * * * * *\n  *\n- *  Description 102 - Zzz_Ki_Calls fix\n+ *  Description 103 - Zzz_Ki_Calls fix\n  */\n tSCC zZzz_Ki_CallsName[] =\n      \"Zzz_Ki_Calls\";\n@@ -3698,7 +3732,7 @@ const char* apzZzz_Ki_CallsPatch[] = { \"sh\", \"-c\",\n \n /* * * * * * * * * * * * * * * * * * * * * * * * * *\n  *\n- *  Description 103 - Zzz_Ki_Defs fix\n+ *  Description 104 - Zzz_Ki_Defs fix\n  */\n tSCC zZzz_Ki_DefsName[] =\n      \"Zzz_Ki_Defs\";\n@@ -3733,7 +3767,7 @@ const char* apzZzz_Ki_DefsPatch[] = { \"sh\", \"-c\",\n \n /* * * * * * * * * * * * * * * * * * * * * * * * * *\n  *\n- *  Description 104 - Zzz_Time fix\n+ *  Description 105 - Zzz_Time fix\n  */\n tSCC zZzz_TimeName[] =\n      \"Zzz_Time\";\n@@ -3770,9 +3804,9 @@ const char* apzZzz_TimePatch[] = { \"sh\", \"-c\",\n  *\n  *  List of all fixes\n  */\n-#define  REGEX_COUNT  75\n-#define  FIX_COUNT    104\n-tFixDesc fixDescList[ 104 ] = {\n+#define  REGEX_COUNT  76\n+#define  FIX_COUNT    105\n+tFixDesc fixDescList[ 105 ] = {\n   {  zAix_SyswaitName,    zAix_SyswaitList,\n      apzAix_SyswaitMachs, (regex_t*)NULL,\n      AIX_SYSWAIT_TEST_CT, FD_MACH_ONLY,\n@@ -4188,6 +4222,11 @@ tFixDesc fixDescList[ 104 ] = {\n      ULTRIX_ANSI_COMPAT_TEST_CT, FD_MACH_ONLY,\n      aUltrix_Ansi_CompatTests,   apzUltrix_Ansi_CompatPatch },\n \n+  {  zUltrix_Fix_FixprotoName,    zUltrix_Fix_FixprotoList,\n+     apzUltrix_Fix_FixprotoMachs, (regex_t*)NULL,\n+     ULTRIX_FIX_FIXPROTO_TEST_CT, FD_MACH_ONLY,\n+     aUltrix_Fix_FixprotoTests,   apzUltrix_Fix_FixprotoPatch },\n+\n   {  zUltrix_Atof_ParamName,    zUltrix_Atof_ParamList,\n      apzUltrix_Atof_ParamMachs, (regex_t*)NULL,\n      ULTRIX_ATOF_PARAM_TEST_CT, FD_MACH_ONLY,"}, {"sha": "2dd5698ce9b3e250de102b12fece56c2981ec7df", "filename": "gcc/fixinc/hackshell.tpl", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f414ac48f4a946930e35c5003b5f020ad8168c4/gcc%2Ffixinc%2Fhackshell.tpl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f414ac48f4a946930e35c5003b5f020ad8168c4/gcc%2Ffixinc%2Fhackshell.tpl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffixinc%2Fhackshell.tpl?ref=1f414ac48f4a946930e35c5003b5f020ad8168c4", "patch": "@@ -1,6 +1,5 @@\n [= autogen template include =]\n [=\n-# $Id: hackshell.tpl,v 1.2 1998/12/16 21:19:08 law Exp $\n #\n #  This file contanes the shell template replacement for the\n #  fixincl program.  It is the repetitive guts of the fixincludes logic."}, {"sha": "09957254c520e57dcaeb310145fa8b35a32a0091", "filename": "gcc/fixinc/inclhack.def", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f414ac48f4a946930e35c5003b5f020ad8168c4/gcc%2Ffixinc%2Finclhack.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f414ac48f4a946930e35c5003b5f020ad8168c4/gcc%2Ffixinc%2Finclhack.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffixinc%2Finclhack.def?ref=1f414ac48f4a946930e35c5003b5f020ad8168c4", "patch": "@@ -1,4 +1,4 @@\n-/* -*- Mode: C -*-  $Id: inclhack.def,v 1.2 1998/12/16 21:19:09 law Exp $  */\n+/* -*- Mode: C -*-  */\n \n autogen definitions inclhack;\n \n@@ -2006,6 +2006,19 @@ fix = {\n };\n \n \n+/*\n+ * Ultrix V4.[35] puts the declaration of uname before the definition\n+ * of struct utsname, so the prototype (added by fixproto) causes havoc.\n+ */\n+fix = {\n+    hackname = ultrix_fix_fixproto;\n+    files    = sys/utsname.h;\n+    select   = ULTRIX;\n+    sed      = \"/^[ \\t]*extern[ \\t]*int[ \\t]*uname();$/i\\\\\\n\"\n+               \"struct utsname;\\n\";\n+};\n+\n+\n /*\n  *  parameter to atof not const on DECstation Ultrix V4.0 and NEWS-OS 4.2R.\n  *  also get rid of bogus inline definitions in HP-UX 8.0"}, {"sha": "f56e9a5f7840976e56e2ac0ed81243f24612d730", "filename": "gcc/fixinc/inclhack.sh", "status": "modified", "additions": 61, "deletions": 39, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f414ac48f4a946930e35c5003b5f020ad8168c4/gcc%2Ffixinc%2Finclhack.sh", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f414ac48f4a946930e35c5003b5f020ad8168c4/gcc%2Ffixinc%2Finclhack.sh", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffixinc%2Finclhack.sh?ref=1f414ac48f4a946930e35c5003b5f020ad8168c4", "patch": "@@ -2,15 +2,15 @@\n #\n # DO NOT EDIT THIS FILE   (inclhack.sh)\n # \n-# It has been autogen-ed  Friday October 16, 1998 at 07:29:49 AM PDT\n+# It has been autogen-ed  Wednesday January 27, 1999 at 09:03:36 AM PST\n # From the definitions    inclhack.def\n # and the template file   inclhack.tpl\n #\n # Install modified versions of certain ANSI-incompatible system header\n # files which are fixed to work correctly with ANSI C and placed in a\n # directory that GNU C will search.\n #\n-# This script contains 104 fixup scripts.\n+# This script contains 105 fixup scripts.\n #\n # See README-fixinc for more information.\n #\n@@ -125,10 +125,7 @@ for INPUT in ${INPUTLIST} ; do\n \n cd ${ORIGDIR}\n \n-cd ${INPUT} || {\n-  echo 'fixincludes:  input dir `'$INPUT\"' is an invalid directory\"\n-  exit 1\n-}\n+cd ${INPUT} || continue\n \n #\n # # # # # # # # # # # # # # # # # # # # #\n@@ -2464,7 +2461,30 @@ extern unsigned int\\\n \n \n     #\n-    # Fix  84:  Ultrix_Atof_Param\n+    # Fix  84:  Ultrix_Fix_Fixproto\n+    #\n+    case \"$file\" in ./sys/utsname.h )\n+    if ( test -n \"`egrep 'ULTRIX' $file`\"\n+       ) > /dev/null 2>&1 ; then\n+    fixlist=\"${fixlist}\n+      ultrix_fix_fixproto\"\n+    if [ ! -r ${DESTDIR}/$file ]\n+    then infile=$file\n+    else infile=${DESTDIR}/$file ; fi \n+\n+    sed -e '/^[ \t]*extern[ \t]*int[ \t]*uname();$/i\\\n+struct utsname;\n+' \\\n+          < $infile > ${DESTDIR}/$file.\n+    \n+    mv -f ${DESTDIR}/$file. ${DESTDIR}/$file\n+    fi # end of selection 'if'\n+    ;; # case end for file name test\n+    esac\n+\n+\n+    #\n+    # Fix  85:  Ultrix_Atof_Param\n     #\n     case \"$file\" in ./math.h )\n     fixlist=\"${fixlist}\n@@ -2486,7 +2506,7 @@ extern unsigned int\\\n \n \n     #\n-    # Fix  85:  Ultrix_Const\n+    # Fix  86:  Ultrix_Const\n     #\n     case \"$file\" in ./stdio.h )\n     fixlist=\"${fixlist}\n@@ -2512,7 +2532,7 @@ extern unsigned int\\\n \n \n     #\n-    # Fix  86:  Ultrix_Ifdef\n+    # Fix  87:  Ultrix_Ifdef\n     #\n     case \"$file\" in ./sys/file.h )\n     if ( test -n \"`egrep '#ifdef KERNEL' $file`\"\n@@ -2533,7 +2553,7 @@ extern unsigned int\\\n \n \n     #\n-    # Fix  87:  Ultrix_Nested_Cmnt\n+    # Fix  88:  Ultrix_Nested_Cmnt\n     #\n     case \"$file\" in ./rpc/svc.h )\n     fixlist=\"${fixlist}\n@@ -2551,7 +2571,7 @@ extern unsigned int\\\n \n \n     #\n-    # Fix  88:  Ultrix_Static\n+    # Fix  89:  Ultrix_Static\n     #\n     case \"$file\" in ./machine/cpu.h )\n     if ( test -n \"`egrep '#include \\\"r[34]_cpu' $file`\"\n@@ -2574,7 +2594,7 @@ extern unsigned int\\\n \n \n     #\n-    # Fix  89:  Undefine_Null\n+    # Fix  90:  Undefine_Null\n     #\n     if ( test -n \"`egrep '^#[ \t]*define[ \t]*[ \t]NULL[ \t]' $file`\" -a \\\n               -z \"`egrep '#[ \t]*(ifn|un)def[ \t]*[ \t]NULL($|[ \t])' $file`\"\n@@ -2595,7 +2615,7 @@ extern unsigned int\\\n \n \n     #\n-    # Fix  90:  Va_I960_Macro\n+    # Fix  91:  Va_I960_Macro\n     #\n     case \"$file\" in ./arch/i960/archI960.h )\n     if ( test -n \"`egrep '__(vsiz|vali|vpad|alignof__)' $file`\"\n@@ -2619,7 +2639,7 @@ extern unsigned int\\\n \n \n     #\n-    # Fix  91:  Void_Null\n+    # Fix  92:  Void_Null\n     #\n     case \"$file\" in ./curses.h | \\\n \t./dbm.h | \\\n@@ -2650,7 +2670,7 @@ extern unsigned int\\\n \n \n     #\n-    # Fix  92:  Vxworks_Gcc_Problem\n+    # Fix  93:  Vxworks_Gcc_Problem\n     #\n     case \"$file\" in ./types/vxTypesBase.h )\n     if ( test -n \"`egrep '__GNUC_TYPEOF_FEATURE_BROKEN_USE_DEFAULT_UNTIL_FIXED__' $file`\"\n@@ -2692,7 +2712,7 @@ extern unsigned int\\\n \n \n     #\n-    # Fix  93:  Vxworks_Needs_Vxtypes\n+    # Fix  94:  Vxworks_Needs_Vxtypes\n     #\n     case \"$file\" in ./time.h )\n     if ( test -n \"`egrep 'uint_t[ \t][ \t]*_clocks_per_sec' $file`\"\n@@ -2713,7 +2733,7 @@ extern unsigned int\\\n \n \n     #\n-    # Fix  94:  Vxworks_Needs_Vxworks\n+    # Fix  95:  Vxworks_Needs_Vxworks\n     #\n     case \"$file\" in ./sys/stat.h )\n     if ( test -n \"`egrep '#[ \t]define[ \t][ \t]*__INCstath' $file`\" -a \\\n@@ -2739,7 +2759,7 @@ extern unsigned int\\\n \n \n     #\n-    # Fix  95:  Vxworks_Time\n+    # Fix  96:  Vxworks_Time\n     #\n     case \"$file\" in ./time.h )\n     if ( test -n \"`egrep 'VOIDFUNCPTR' $file`\" -a \\\n@@ -2771,7 +2791,7 @@ typedef void (*__gcc_VOIDFUNCPTR) ();\\\n \n \n     #\n-    # Fix  96:  X11_Class\n+    # Fix  97:  X11_Class\n     #\n     case \"$file\" in ./X11/ShellP.h )\n     if ( test -z \"`egrep '__cplusplus' $file`\"\n@@ -2799,7 +2819,7 @@ typedef void (*__gcc_VOIDFUNCPTR) ();\\\n \n \n     #\n-    # Fix  97:  X11_Class_Usage\n+    # Fix  98:  X11_Class_Usage\n     #\n     case \"$file\" in ./Xm/BaseClassI.h )\n     if ( test -z \"`egrep '__cplusplus' $file`\"\n@@ -2820,7 +2840,7 @@ typedef void (*__gcc_VOIDFUNCPTR) ();\\\n \n \n     #\n-    # Fix  98:  X11_New\n+    # Fix  99:  X11_New\n     #\n     case \"$file\" in ./Xm/Traversal.h )\n     if ( test -z \"`egrep '__cplusplus' $file`\"\n@@ -2849,7 +2869,7 @@ typedef void (*__gcc_VOIDFUNCPTR) ();\\\n \n \n     #\n-    # Fix  99:  X11_Sprintf\n+    # Fix 100:  X11_Sprintf\n     #\n     case \"$file\" in ./X11*/Xmu.h )\n     fixlist=\"${fixlist}\n@@ -2869,7 +2889,7 @@ extern char *\tsprintf();\\\n \n \n     #\n-    # Fix 100:  Zzz_Ki_Iface\n+    # Fix 101:  Zzz_Ki_Iface\n     #\n     case \"$file\" in ./sys/ki_iface.h )\n     if ( test -n \"`egrep 'These definitions are for HP Internal developers' $file`\"\n@@ -2896,7 +2916,7 @@ cat > /dev/null ) < $infile > ${DESTDIR}/$file.\n \n \n     #\n-    # Fix 101:  Zzz_Ki\n+    # Fix 102:  Zzz_Ki\n     #\n     case \"$file\" in ./sys/ki.h )\n     if ( test -n \"`egrep '11.00 HP-UX LP64' $file`\"\n@@ -2923,7 +2943,7 @@ cat > /dev/null ) < $infile > ${DESTDIR}/$file.\n \n \n     #\n-    # Fix 102:  Zzz_Ki_Calls\n+    # Fix 103:  Zzz_Ki_Calls\n     #\n     case \"$file\" in ./sys/ki_calls.h )\n     if ( test -n \"`egrep 'KI_MAX_PROCS is an arbitrary number' $file`\"\n@@ -2950,7 +2970,7 @@ cat > /dev/null ) < $infile > ${DESTDIR}/$file.\n \n \n     #\n-    # Fix 103:  Zzz_Ki_Defs\n+    # Fix 104:  Zzz_Ki_Defs\n     #\n     case \"$file\" in ./sys/ki_defs.h )\n     if ( test -n \"`egrep 'Kernel Instrumentation Definitions' $file`\"\n@@ -2977,7 +2997,7 @@ cat > /dev/null ) < $infile > ${DESTDIR}/$file.\n \n \n     #\n-    # Fix 104:  Zzz_Time\n+    # Fix 105:  Zzz_Time\n     #\n     case \"$file\" in ./sys/time.h )\n     if ( test -n \"`egrep 'For CASPEC, look in' $file`\"\n@@ -3041,18 +3061,20 @@ while [ $# != 0 ]; do\n     #\n     cd ${INPUT}\n     cd $1\n-    if [ -r $2 ] && [ ! -r $3 ]; then\n-      cp $2 $3 >/dev/null 2>&1 || echo \"Can't copy $2\" >&2\n-      chmod +w $3 2>/dev/null\n-      chmod a+r $3 2>/dev/null\n-      echo Copied $2\n-      for include in `egrep '^[ \t]*#[ \t]*include[ \t]*\"[^/]' $3 |\n+    if [ -f $2 ] ; then\n+      if [ -r $2 ] && [ ! -r $3 ]; then\n+        cp $2 $3 >/dev/null 2>&1 || echo \"Can't copy $2\" >&2\n+        chmod +w $3 2>/dev/null\n+        chmod a+r $3 2>/dev/null\n+        echo Copied $2\n+        for include in `egrep '^[ \t]*#[ \t]*include[ \t]*\"[^/]' $3 |\n              sed -e 's/^[ \t]*#[ \t]*include[ \t]*\"\\([^\"]*\\)\".*$/\\1/'`\n-      do\n-\tdir=`echo $2 | sed -e s'|/[^/]*$||'`\n-\tdir2=`echo $3 | sed -e s'|/[^/]*$||'`\n-\tnewreq=\"$newreq $1 $dir/$include $dir2/$include\"\n-      done\n+        do\n+\t  dir=`echo $2 | sed -e s'|/[^/]*$||'`\n+\t  dir2=`echo $3 | sed -e s'|/[^/]*$||'`\n+\t  newreq=\"$newreq $1 $dir/$include $dir2/$include\"\n+        done\n+      fi\n     fi\n     shift; shift; shift\n   done\n@@ -3081,6 +3103,6 @@ done\n \n cd $ORIGDIR\n rm -f include/assert.h\n-cp ${EGCS_SRCDIR}/assert.h include/assert.h\n+cp ${srcdir}/assert.h include/assert.h || exit 1\n chmod a+r include/assert.h\n "}, {"sha": "06b49aeabe95d87c7d1f100e5720ca2c8f6a6344", "filename": "gcc/fixinc/inclhack.tpl", "status": "modified", "additions": 15, "deletions": 17, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f414ac48f4a946930e35c5003b5f020ad8168c4/gcc%2Ffixinc%2Finclhack.tpl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f414ac48f4a946930e35c5003b5f020ad8168c4/gcc%2Ffixinc%2Finclhack.tpl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffixinc%2Finclhack.tpl?ref=1f414ac48f4a946930e35c5003b5f020ad8168c4", "patch": "@@ -1,7 +1,6 @@\n [= autogen template -*- Mode: ksh -*-\n sh\n #\n-#  $Id: inclhack.tpl,v 1.2 1998/12/16 21:19:11 law Exp $\n #\n =]\n #!/bin/sh\n@@ -116,10 +115,7 @@ for INPUT in ${INPUTLIST} ; do\n \n cd ${ORIGDIR}\n \n-cd ${INPUT} || {\n-  echo 'fixincludes:  input dir `'$INPUT\"' is an invalid directory\"\n-  exit 1\n-}\n+cd ${INPUT} || continue\n \n #\n # # # # # # # # # # # # # # # # # # # # #\n@@ -342,18 +338,20 @@ while [ $# != 0 ]; do\n     #\n     cd ${INPUT}\n     cd $1\n-    if [ -r $2 ] && [ ! -r $3 ]; then\n-      cp $2 $3 >/dev/null 2>&1 || echo \"Can't copy $2\" >&2\n-      chmod +w $3 2>/dev/null\n-      chmod a+r $3 2>/dev/null\n-      echo Copied $2\n-      for include in `egrep '^[ \t]*#[ \t]*include[ \t]*\"[^/]' $3 |\n+    if [ -f $2 ] ; then\n+      if [ -r $2 ] && [ ! -r $3 ]; then\n+        cp $2 $3 >/dev/null 2>&1 || echo \"Can't copy $2\" >&2\n+        chmod +w $3 2>/dev/null\n+        chmod a+r $3 2>/dev/null\n+        echo Copied $2\n+        for include in `egrep '^[ \t]*#[ \t]*include[ \t]*\"[^/]' $3 |\n              sed -e 's/^[ \t]*#[ \t]*include[ \t]*\"\\([^\"]*\\)\".*$/\\1/'`\n-      do\n-\tdir=`echo $2 | sed -e s'|/[^/]*$||'`\n-\tdir2=`echo $3 | sed -e s'|/[^/]*$||'`\n-\tnewreq=\"$newreq $1 $dir/$include $dir2/$include\"\n-      done\n+        do\n+\t  dir=`echo $2 | sed -e s'|/[^/]*$||'`\n+\t  dir2=`echo $3 | sed -e s'|/[^/]*$||'`\n+\t  newreq=\"$newreq $1 $dir/$include $dir2/$include\"\n+        done\n+      fi\n     fi\n     shift; shift; shift\n   done\n@@ -382,7 +380,7 @@ done\n \n cd $ORIGDIR\n rm -f include/assert.h\n-cp ${EGCS_SRCDIR}/assert.h include/assert.h\n+cp ${srcdir}/assert.h include/assert.h || exit 1\n chmod a+r include/assert.h\n [=\n "}, {"sha": "38d7d8e5b077fcf8468a901741c668f40122ee6d", "filename": "gcc/fixinc/mkfixinc.sh", "status": "modified", "additions": 36, "deletions": 8, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f414ac48f4a946930e35c5003b5f020ad8168c4/gcc%2Ffixinc%2Fmkfixinc.sh", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f414ac48f4a946930e35c5003b5f020ad8168c4/gcc%2Ffixinc%2Fmkfixinc.sh", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffixinc%2Fmkfixinc.sh?ref=1f414ac48f4a946930e35c5003b5f020ad8168c4", "patch": "@@ -7,8 +7,10 @@ then\n \texit 1\n fi\n \n-echo constructing fixinc.sh for $machine\n-fixincludes=\"../fixinc.sh\"\n+target=../fixinc.sh\n+\n+echo constructing ${target} for $machine\n+fixincludes=\"${target}\"\n \n case $machine in\n \t*-*-gnu*)\n@@ -103,21 +105,47 @@ case $machine in\n \t\t;;\n esac\n \n+#  IF there is no include fixing,\n+#  THEN create a no-op fixer and exit\n+#\n if test -z \"$fixincludes\"\n then\n-    cat > ../fixinc.sh  <<-\t_EOF_\n+    cat > ${target}  <<-\t_EOF_\n \t#! /bin/sh\n \texit 0\n \t_EOF_\n     exit 0\n fi\n \n-if test -f \"$fixincludes\"\n+#  IF the fixer is supplied in our source directory,\n+#  THEN copy that into place\n+#\n+if test -f ${srcdir}/\"${fixincludes}\"\n then\n-    echo copying $fixincludes to ../fixinc.sh\n-    cp $fixincludes ../fixinc.sh\n+    echo copying ${srcdir}/$fixincludes to ${target}\n+    cp ${srcdir}/$fixincludes ${target}\n     exit 0\n fi\n \n-echo $MAKE install\n-$MAKE install || cp inclhack.sh ..\n+#  OK.  We gotta make the thing.\n+#\n+echo $MAKE SHELL=\\\"$SHELL\\\" install\n+\n+#  make and install either the binary or the default script\n+#\n+$MAKE SHELL=\"$SHELL\" install && exit 0\n+\n+#  Where is our inclhack script?  That is the backup\n+#  in case we are unable to make a working binary.\n+#\n+if test -f ./inclhack.sh\n+then\n+    INCLHACK=./inclhack.sh\n+else\n+    INCLHACK=${srcdir}/inclhack.sh\n+fi\n+\n+echo Could not install binary fixincludes.\n+echo Installing shell script instead.\n+\n+cp ${INCLHACK} ${target}"}, {"sha": "ef52ba41dc8bd2a55300213abdd2f26b4ae5419f", "filename": "gcc/fixinc/procopen.c", "status": "added", "additions": 260, "deletions": 0, "changes": 260, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f414ac48f4a946930e35c5003b5f020ad8168c4/gcc%2Ffixinc%2Fprocopen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f414ac48f4a946930e35c5003b5f020ad8168c4/gcc%2Ffixinc%2Fprocopen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffixinc%2Fprocopen.c?ref=1f414ac48f4a946930e35c5003b5f020ad8168c4", "patch": "@@ -0,0 +1,260 @@\n+\n+/*\n+ *  server.c  Set up and handle communications with a server process.\n+ *\n+ *  Server Handling copyright 1992-1999 The Free Software Foundation\n+ *\n+ *  Server Handling is free software.\n+ *  You may redistribute it and/or modify it under the terms of the\n+ *  GNU General Public License, as published by the Free Software\n+ *  Foundation; either version 2, or (at your option) any later version.\n+ *\n+ *  Server Handling is distributed in the hope that it will be useful,\n+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ *  GNU General Public License for more details.\n+ *\n+ *  You should have received a copy of the GNU General Public License\n+ *  along with Server Handling.  See the file \"COPYING\".  If not,\n+ *  write to:  The Free Software Foundation, Inc.,\n+ *             59 Temple Place - Suite 330,\n+ *             Boston,  MA  02111-1307, USA.\n+ *\n+ * As a special exception, The Free Software Foundation gives\n+ * permission for additional uses of the text contained in his release\n+ * of ServerHandler.\n+ *\n+ * The exception is that, if you link the ServerHandler library with other\n+ * files to produce an executable, this does not by itself cause the\n+ * resulting executable to be covered by the GNU General Public License.\n+ * Your use of that executable is in no way restricted on account of\n+ * linking the ServerHandler library code into it.\n+ *\n+ * This exception does not however invalidate any other reasons why\n+ * the executable file might be covered by the GNU General Public License.\n+ *\n+ * This exception applies only to the code released by The Free\n+ * Software Foundation under the name ServerHandler.  If you copy code\n+ * from other sources under the General Public License into a copy of\n+ * ServerHandler, as the General Public License permits, the exception\n+ * does not apply to the code that you add in this way.  To avoid\n+ * misleading anyone as to the status of such modified files, you must\n+ * delete this exception notice from them.\n+ *\n+ * If you write modifications of your own for ServerHandler, it is your\n+ * choice whether to permit this exception to apply to your modifications.\n+ * If you do not wish that, delete this exception notice.\n+ */\n+#include \"config.h\"\n+\n+#include <sys/types.h>\n+#ifdef HAVE_FCNTL_H\n+#include <fcntl.h>\n+#endif\n+#include <errno.h>\n+#include <signal.h>\n+#include <stdlib.h>\n+#include <string.h>\n+#include <ctype.h>\n+#include <sys/param.h>\n+\n+#include \"server.h\"\n+\n+/* If this particular system's header files define the macro `MAXPATHLEN',\n+   we happily take advantage of it; otherwise we use a value which ought\n+   to be large enough.  */\n+#ifndef MAXPATHLEN\n+# define MAXPATHLEN     4096\n+#endif\n+\n+#ifndef STDIN_FILENO\n+# define STDIN_FILENO\t0\n+#endif\n+#ifndef STDOUT_FILENO\n+# define STDOUT_FILENO\t1\n+#endif\n+\n+#ifdef DEBUG\n+#define STATIC\n+#else\n+#define STATIC static\n+#endif\n+#ifndef tSCC\n+#define tSCC static const char\n+#endif\n+#ifndef NUL\n+#define NUL '\\0'\n+#endif\n+\n+STATIC t_pchar def_args[] =\n+{ (char *) NULL, (char *) NULL };\n+\n+/*\n+ *  chain_open\n+ *\n+ *  Given an FD for an inferior process to use as stdin,\n+ *  start that process and return a NEW FD that that process\n+ *  will use for its stdout.  Requires the argument vector\n+ *  for the new process and, optionally, a pointer to a place\n+ *  to store the child's process id.\n+ */\n+int\n+chain_open (stdin_fd, pp_args, p_child)\n+     int stdin_fd;\n+     t_pchar *pp_args;\n+     pid_t *p_child;\n+{\n+  t_fd_pair stdout_pair = {-1, -1};\n+  pid_t ch_id;\n+  char *pz_cmd;\n+\n+  /*\n+   *  Create a pipe it will be the child process' stdout,\n+   *  and the parent will read from it.\n+   */\n+  if (pipe ((int *) &stdout_pair) < 0)\n+    {\n+      if (p_child != (pid_t *) NULL)\n+        *p_child = NOPROCESS;\n+      return -1;\n+    }\n+\n+  /*\n+   *  If we did not get an arg list, use the default\n+   */\n+  if (pp_args == (t_pchar *) NULL)\n+    pp_args = def_args;\n+\n+  /*\n+   *  If the arg list does not have a program,\n+   *  assume the \"SHELL\" from the environment, or, failing\n+   *  that, then sh.  Set argv[0] to whatever we decided on.\n+   */\n+  if (pz_cmd = *pp_args,\n+      (pz_cmd == (char *) NULL) || (*pz_cmd == '\\0'))\n+    {\n+\n+      pz_cmd = getenv (\"SHELL\");\n+      if (pz_cmd == (char *) NULL)\n+        pz_cmd = \"sh\";\n+    }\n+\n+#ifdef DEBUG_PRINT\n+  printf (\"START:  %s\\n\", pz_cmd);\n+  {\n+    int idx = 0;\n+    \n+    while (pp_args[++idx] != (char *) NULL)\n+      printf (\"  ARG %2d:  %s\\n\", idx, pp_args[idx]);\n+  }\n+#endif\n+\n+  /*\n+   *  Call fork() and see which process we become\n+   */\n+  ch_id = fork ();\n+  switch (ch_id)\n+    {\n+    case NOPROCESS:             /* parent - error in call */\n+      close (stdout_pair.read_fd);\n+      close (stdout_pair.write_fd);\n+      if (p_child != (pid_t *) NULL)\n+        *p_child = NOPROCESS;\n+      return -1;\n+\n+    default:                    /* parent - return opposite FD's */\n+      if (p_child != (pid_t *) NULL)\n+        *p_child = ch_id;\n+#ifdef DEBUG_PRINT\n+      printf (\"for pid %d:  stdin from %d, stdout to %d\\n\"\n+              \"for parent:  read from %d\\n\",\n+              ch_id, stdin_fd, stdout_pair.write_fd, stdout_pair.read_fd);\n+#endif\n+      close (stdin_fd);\n+      close (stdout_pair.write_fd);\n+      return stdout_pair.read_fd;\n+\n+    case NULLPROCESS:           /* child - continue processing */\n+      break;\n+    }\n+\n+  /*\n+   *  Close the pipe end handed back to the parent process\n+   */\n+  close (stdout_pair.read_fd);\n+\n+  /*\n+   *  Close our current stdin and stdout\n+   */\n+  close (STDIN_FILENO);\n+  close (STDOUT_FILENO);\n+\n+  /*\n+   *  Make the fd passed in the stdin, and the write end of\n+   *  the new pipe become the stdout.\n+   */\n+  fcntl (stdout_pair.write_fd, F_DUPFD, STDOUT_FILENO);\n+  fcntl (stdin_fd, F_DUPFD, STDIN_FILENO);\n+\n+  if (*pp_args == (char *) NULL)\n+    *pp_args = pz_cmd;\n+\n+  execvp (pz_cmd, pp_args);\n+  fprintf (stderr, \"Error %d:  Could not execvp( '%s', ... ):  %s\\n\",\n+           errno, pz_cmd, strerror (errno));\n+  exit (EXIT_PANIC);\n+}\n+\n+\n+/*\n+ *  proc2_open\n+ *\n+ *  Given a pointer to an argument vector, start a process and\n+ *  place its stdin and stdout file descriptors into an fd pair\n+ *  structure.  The \"write_fd\" connects to the inferior process\n+ *  stdin, and the \"read_fd\" connects to its stdout.  The calling\n+ *  process should write to \"write_fd\" and read from \"read_fd\".\n+ *  The return value is the process id of the created process.\n+ */\n+pid_t\n+proc2_open (p_pair, pp_args)\n+     t_fd_pair *p_pair;\n+     t_pchar *pp_args;\n+{\n+  pid_t ch_id;\n+\n+  /*  Create a bi-directional pipe.  Writes on 0 arrive on 1 and vice\n+     versa, so the parent and child processes will read and write to\n+     opposite FD's.  */\n+  if (pipe ((int *) p_pair) < 0)\n+    return NOPROCESS;\n+\n+  p_pair->read_fd = chain_open (p_pair->read_fd, pp_args, &ch_id);\n+  if (ch_id == NOPROCESS)\n+    close (p_pair->write_fd);\n+\n+  return ch_id;\n+}\n+\n+\n+/*\n+ *  proc2_fopen\n+ *\n+ *  Identical to \"proc2_open()\", except that the \"fd\"'s are\n+ *  \"fdopen(3)\"-ed into file pointers instead.\n+ */\n+pid_t\n+proc2_fopen (pf_pair, pp_args)\n+     t_pf_pair *pf_pair;\n+     t_pchar *pp_args;\n+{\n+  t_fd_pair fd_pair;\n+  pid_t ch_id = proc2_open (&fd_pair, pp_args);\n+\n+  if (ch_id == NOPROCESS)\n+    return ch_id;\n+\n+  pf_pair->pf_read = fdopen (fd_pair.read_fd, \"r\");\n+  pf_pair->pf_write = fdopen (fd_pair.write_fd, \"w\");\n+  return ch_id;\n+}"}, {"sha": "97cbcc1cfcd371bae49e3180f01dda0933e7ddab", "filename": "gcc/fixinc/regex.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f414ac48f4a946930e35c5003b5f020ad8168c4/gcc%2Ffixinc%2Fregex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f414ac48f4a946930e35c5003b5f020ad8168c4/gcc%2Ffixinc%2Fregex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffixinc%2Fregex.c?ref=1f414ac48f4a946930e35c5003b5f020ad8168c4", "patch": "@@ -25,8 +25,6 @@\n   #pragma alloca\n #endif\n \n-/* $Id: regex.c,v 1.3 1999/01/11 13:34:23 law Exp $ */\n-\n #define _GNU_SOURCE\n \n /* We need this for `regex.h', and perhaps for the Emacs include files.  */"}, {"sha": "a34ca646fe93257161a0dcd1b14bf3813d184442", "filename": "gcc/fixinc/regex.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f414ac48f4a946930e35c5003b5f020ad8168c4/gcc%2Ffixinc%2Fregex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f414ac48f4a946930e35c5003b5f020ad8168c4/gcc%2Ffixinc%2Fregex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffixinc%2Fregex.h?ref=1f414ac48f4a946930e35c5003b5f020ad8168c4", "patch": "@@ -18,8 +18,6 @@\n    Foundation, 59 Temple Place - Suite 330,\n    Boston, MA 02111-1307, USA.  */\n \n-/* $Id: regex.h,v 1.3 1999/01/11 13:34:25 law Exp $ */\n-\n #ifndef __REGEXP_LIBRARY_H__\n #define __REGEXP_LIBRARY_H__\n "}, {"sha": "a80be74f700cbb11e3420b8277a2e620bb69d89d", "filename": "gcc/fixinc/server.c", "status": "modified", "additions": 182, "deletions": 342, "changes": 524, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f414ac48f4a946930e35c5003b5f020ad8168c4/gcc%2Ffixinc%2Fserver.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f414ac48f4a946930e35c5003b5f020ad8168c4/gcc%2Ffixinc%2Fserver.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffixinc%2Fserver.c?ref=1f414ac48f4a946930e35c5003b5f020ad8168c4", "patch": "@@ -1,8 +1,8 @@\n \n /*\n- *  $Id: server.c,v 1.2 1998/12/16 21:19:16 law Exp $\n+ *  server.c  Set up and handle communications with a server process.\n  *\n- *  Server Handling copyright 1992-1998 Bruce Korb\n+ *  Server Handling copyright 1992-1999 The Free Software Foundation\n  *\n  *  Server Handling is free software.\n  *  You may redistribute it and/or modify it under the terms of the\n@@ -20,8 +20,9 @@\n  *             59 Temple Place - Suite 330,\n  *             Boston,  MA  02111-1307, USA.\n  *\n- * As a special exception, Bruce Korb gives permission for additional\n- * uses of the text contained in his release of ServerHandler.\n+ * As a special exception, The Free Software Foundation gives\n+ * permission for additional uses of the text contained in his release\n+ * of ServerHandler.\n  *\n  * The exception is that, if you link the ServerHandler library with other\n  * files to produce an executable, this does not by itself cause the\n@@ -32,19 +33,24 @@\n  * This exception does not however invalidate any other reasons why\n  * the executable file might be covered by the GNU General Public License.\n  *\n- * This exception applies only to the code released by Bruce Korb under\n- * the name ServerHandler.  If you copy code from other sources under the\n- * General Public License into a copy of ServerHandler, as the General Public\n- * License permits, the exception does not apply to the code that you add\n- * in this way.  To avoid misleading anyone as to the status of such\n- * modified files, you must delete this exception notice from them.\n+ * This exception applies only to the code released by The Free\n+ * Software Foundation under the name ServerHandler.  If you copy code\n+ * from other sources under the General Public License into a copy of\n+ * ServerHandler, as the General Public License permits, the exception\n+ * does not apply to the code that you add in this way.  To avoid\n+ * misleading anyone as to the status of such modified files, you must\n+ * delete this exception notice from them.\n  *\n  * If you write modifications of your own for ServerHandler, it is your\n  * choice whether to permit this exception to apply to your modifications.\n  * If you do not wish that, delete this exception notice.\n  */\n+#include \"config.h\"\n \n+#include <sys/types.h>\n+#ifdef HAVE_FCNTL_H\n #include <fcntl.h>\n+#endif\n #include <errno.h>\n #include <signal.h>\n #include <stdlib.h>\n@@ -54,6 +60,20 @@\n \n #include \"server.h\"\n \n+/* If this particular system's header files define the macro `MAXPATHLEN',\n+   we happily take advantage of it; otherwise we use a value which ought\n+   to be large enough.  */\n+#ifndef MAXPATHLEN\n+# define MAXPATHLEN     4096\n+#endif\n+\n+#ifndef STDIN_FILENO\n+# define STDIN_FILENO\t0\n+#endif\n+#ifndef STDOUT_FILENO\n+# define STDOUT_FILENO\t1\n+#endif\n+\n #ifdef DEBUG\n #define STATIC\n #else\n@@ -66,398 +86,218 @@\n #define NUL '\\0'\n #endif\n \n-STATIC bool readPipeTimeout;\n+STATIC bool read_pipe_timeout;\n \n-STATIC tpChar defArgs[] =\n-{(char *) NULL, \"-p\", (char *) NULL};\n-STATIC tpfPair serverPair =\n-{(FILE *) NULL, (FILE *) NULL};\n-STATIC pid_t serverId = NULLPROCESS;\n+STATIC t_pchar def_args[] =\n+{ (char *) NULL, (char *) NULL };\n+STATIC t_pf_pair server_pair =\n+{ (FILE *) NULL, (FILE *) NULL };\n+STATIC pid_t server_id = NULLPROCESS;\n /*\n  *  Arbitrary text that should not be found in the shell output.\n  *  It must be a single line and appear verbatim at the start of\n  *  the terminating output line.\n  */\n-tSCC zDone[] = \"ShElL-OuTpUt-HaS-bEeN-cOmPlEtEd\";\n-STATIC tpChar pCurDir = (char *) NULL;\n-\n-/*\n- *  chainOpen\n- *\n- *  Given an FD for an inferior process to use as stdin,\n- *  start that process and return a NEW FD that that process\n- *  will use for its stdout.  Requires the argument vector\n- *  for the new process and, optionally, a pointer to a place\n- *  to store the child's process id.\n- */\n-int\n-chainOpen (stdinFd, ppArgs, pChild)\n-     int stdinFd;\n-     tpChar *ppArgs;\n-     pid_t *pChild;\n-{\n-  tFdPair stdoutPair =\n-  {-1, -1};\n-  pid_t chId;\n-  char *pzCmd;\n-\n-  /*\n-   *  Create a pipe it will be the child process' stdout,\n-   *  and the parent will read from it.\n-   */\n-  if ((pipe ((int *) &stdoutPair) < 0))\n-    {\n-      if (pChild != (pid_t *) NULL)\n-\t*pChild = NOPROCESS;\n-      return -1;\n-    }\n-\n-  /*\n-   *  If we did not get an arg list, use the default\n-   */\n-  if (ppArgs == (tpChar *) NULL)\n-    ppArgs = defArgs;\n-\n-  /*\n-   *  If the arg list does not have a program,\n-   *  assume the \"SHELL\" from the environment, or, failing\n-   *  that, then sh.  Set argv[0] to whatever we decided on.\n-   */\n-  if (pzCmd = *ppArgs,\n-      (pzCmd == (char *) NULL) || (*pzCmd == '\\0'))\n-    {\n-\n-      pzCmd = getenv (\"SHELL\");\n-      if (pzCmd == (char *) NULL)\n-\tpzCmd = \"sh\";\n-    }\n-#ifdef DEBUG_PRINT\n-  printf (\"START:  %s\\n\", pzCmd);\n-  {\n-    int idx = 0;\n-    while (ppArgs[++idx] != (char *) NULL)\n-      printf (\"  ARG %2d:  %s\\n\", idx, ppArgs[idx]);\n-  }\n-#endif\n-  /*\n-   *  Call fork() and see which process we become\n-   */\n-  chId = fork ();\n-  switch (chId)\n-    {\n-    case NOPROCESS:\t\t/* parent - error in call */\n-      close (stdoutPair.readFd);\n-      close (stdoutPair.writeFd);\n-      if (pChild != (pid_t *) NULL)\n-\t*pChild = NOPROCESS;\n-      return -1;\n-\n-    default:\t\t\t/* parent - return opposite FD's */\n-      if (pChild != (pid_t *) NULL)\n-\t*pChild = chId;\n-#ifdef DEBUG_PRINT\n-      printf (\"for pid %d:  stdin from %d, stdout to %d\\n\"\n-\t      \"for parent:  read from %d\\n\",\n-\t      chId, stdinFd, stdoutPair.writeFd, stdoutPair.readFd);\n-#endif\n-      close (stdinFd);\n-      close (stdoutPair.writeFd);\n-      return stdoutPair.readFd;\n-\n-    case NULLPROCESS:\t\t/* child - continue processing */\n-      break;\n-    }\n-\n-  /*\n-   *  Close the pipe end handed back to the parent process\n-   */\n-  close (stdoutPair.readFd);\n-\n-  /*\n-   *  Close our current stdin and stdout\n-   */\n-  close (STDIN_FILENO);\n-  close (STDOUT_FILENO);\n-\n-  /*\n-   *  Make the fd passed in the stdin, and the write end of\n-   *  the new pipe become the stdout.\n-   */\n-  fcntl (stdoutPair.writeFd, F_DUPFD, STDOUT_FILENO);\n-  fcntl (stdinFd, F_DUPFD, STDIN_FILENO);\n-\n-  if (*ppArgs == (char *) NULL)\n-    *ppArgs = pzCmd;\n-\n-  execvp (pzCmd, ppArgs);\n-  fprintf (stderr, \"Error %d:  Could not execvp( '%s', ... ):  %s\\n\",\n-\t   errno, pzCmd, strerror (errno));\n-  exit (EXIT_PANIC);\n-}\n-\n-\n-/*\n- *  p2open\n- *\n- *  Given a pointer to an argument vector, start a process and\n- *  place its stdin and stdout file descriptors into an fd pair\n- *  structure.  The \"writeFd\" connects to the inferior process\n- *  stdin, and the \"readFd\" connects to its stdout.  The calling\n- *  process should write to \"writeFd\" and read from \"readFd\".\n- *  The return value is the process id of the created process.\n- */\n-pid_t\n-p2open (pPair, ppArgs)\n-     tFdPair *pPair;\n-     tpChar *ppArgs;\n-{\n-  pid_t chId;\n-\n-  /*\n-   *  Create a bi-directional pipe.  Writes on 0 arrive on 1\n-   *  and vice versa, so the parent and child processes will\n-   *  read and write to opposite FD's.\n-   */\n-  if (pipe ((int *) pPair) < 0)\n-    return NOPROCESS;\n-\n-  pPair->readFd = chainOpen (pPair->readFd, ppArgs, &chId);\n-  if (chId == NOPROCESS)\n-    close (pPair->writeFd);\n-\n-  return chId;\n-}\n-\n+tSCC z_done[] = \"ShElL-OuTpUt-HaS-bEeN-cOmPlEtEd\";\n+STATIC t_pchar p_cur_dir = (char *) NULL;\n \n /*\n- *  p2fopen\n- *\n- *  Identical to \"p2open()\", except that the \"fd\"'s are \"fdopen(3)\"-ed\n- *  into file pointers instead.\n- */\n-pid_t\n-p2fopen (pfPair, ppArgs)\n-     tpfPair *pfPair;\n-     tpChar *ppArgs;\n-{\n-  tFdPair fdPair;\n-  pid_t chId = p2open (&fdPair, ppArgs);\n-\n-  if (chId == NOPROCESS)\n-    return chId;\n-\n-  pfPair->pfRead = fdopen (fdPair.readFd, \"r\");\n-  pfPair->pfWrite = fdopen (fdPair.writeFd, \"w\");\n-  return chId;\n-}\n-\n-\n-/*\n- *  loadData\n+ *  load_data\n  *\n  *  Read data from a file pointer (a pipe to a process in this context)\n  *  until we either get EOF or we get a marker line back.\n  *  The read data are stored in a malloc-ed string that is truncated\n  *  to size at the end.  Input is assumed to be an ASCII string.\n  */\n-STATIC char *\n-loadData (fp)\n+static char *\n+load_data (fp)\n      FILE *fp;\n {\n-  char *pzText;\n-  size_t textSize;\n-  char *pzScan;\n-  char zLine[1024];\n+  char *pz_text;\n+  size_t text_size;\n+  char *pz_scan;\n+  char z_line[1024];\n \n-  textSize = sizeof (zLine) * 2;\n-  pzScan = \\\n-    pzText = malloc (textSize);\n+  text_size = sizeof (z_line) * 2;\n+  pz_scan = pz_text = malloc (text_size);\n \n-  if (pzText == (char *) NULL)\n-    return pzText;\n+  if (pz_text == (char *) NULL)\n+    return (char *) NULL;\n \n   for (;;)\n     {\n-      size_t usedCt;\n+      size_t used_ct;\n \n       alarm (10);\n-      readPipeTimeout = BOOL_FALSE;\n-      if (fgets (zLine, sizeof (zLine), fp) == (char *) NULL)\n-\tbreak;\n-\n-      if (strncmp (zLine, zDone, sizeof (zDone) - 1) == 0)\n-\tbreak;\n-\n-      strcpy (pzScan, zLine);\n-      pzScan += strlen (zLine);\n-      usedCt = (size_t) (pzScan - pzText);\n-\n-      if (textSize - usedCt < sizeof (zLine))\n-\t{\n-\n-\t  size_t off = (size_t) (pzScan - pzText);\n-\t  void *p;\n-\t  textSize += 4096;\n-\t  p = realloc ((void *) pzText, textSize);\n-\t  if (p == (void *) NULL)\n-\t    {\n-\t      fprintf (stderr, \"Failed to get 0x%08X bytes\\n\", textSize);\n-\t      free ((void *) pzText);\n-\t      return (char *) NULL;\n-\t    }\n-\n-\t  pzText = (char *) p;\n-\t  pzScan = pzText + off;\n-\t}\n+      read_pipe_timeout = BOOL_FALSE;\n+      if (fgets (z_line, sizeof (z_line), fp) == (char *) NULL)\n+        break;\n+\n+      if (strncmp (z_line, z_done, sizeof (z_done) - 1) == 0)\n+        break;\n+\n+      strcpy (pz_scan, z_line);\n+      pz_scan += strlen (z_line);\n+      used_ct = (size_t) (pz_scan - pz_text);\n+\n+      if (text_size - used_ct < sizeof (z_line))\n+        {\n+          size_t off = (size_t) (pz_scan - pz_text);\n+          void *p;\n+\t  \n+          text_size += 4096;\n+          p = realloc ((void *) pz_text, text_size);\n+          if (p == (void *) NULL)\n+            {\n+              fprintf (stderr, \"Failed to get 0x%08X bytes\\n\", text_size);\n+              free ((void *) pz_text);\n+              return (char *) NULL;\n+            }\n+          pz_text = (char *) p;\n+          pz_scan = pz_text + off;\n+        }\n     }\n \n   alarm (0);\n-  if (readPipeTimeout)\n+  if (read_pipe_timeout)\n     {\n-      free ((void *) pzText);\n+      free ((void *) pz_text);\n       return (char *) NULL;\n     }\n \n-  while ((pzScan > pzText) && isspace (pzScan[-1]))\n-    pzScan--;\n-  *pzScan = NUL;\n-  return realloc ((void *) pzText, strlen (pzText) + 1);\n+  while ((pz_scan > pz_text) && isspace (pz_scan[-1]))\n+    pz_scan--;\n+  *pz_scan = NUL;\n+  return realloc ((void *) pz_text, strlen (pz_text) + 1);\n }\n \n \n /*\n- *  SHELL SERVER PROCESS CODE\n+ *  close_server\n+ *\n+ *  Make certain the server process is dead, close the \n+ *  pipes to it and from it, finally NULL out the file pointers\n  */\n-\n-#ifdef DONT_HAVE_SIGSEND\n-typedef enum\n+static void\n+close_server ()\n {\n-  P_ALL, P_PID, P_GID, P_UID, P_PGID, P_SID, P_CID\n+  kill ((pid_t) server_id, SIGKILL);\n+  server_id = NULLPROCESS;\n+  fclose (server_pair.pf_read);\n+  fclose (server_pair.pf_write);\n+  server_pair.pf_read = server_pair.pf_write = (FILE *) NULL;\n }\n-idtype_t;\n-typedef long id_t;\n-\n-STATIC int\n-sigsend (idtype, id, sig)\n-     idtype_t idtype;\n-     id_t id;\n-     int sig;\n-{\n-  switch (idtype)\n-    {\n-    case P_PID:\n-      kill ((pid_t) id, sig);\n-      break;\n-\n-    case P_ALL:\n-    case P_GID:\n-    case P_UID:\n-    case P_PGID:\n-    case P_SID:\n-    case P_CID:\n-      errno = EINVAL;\n-      return -1;\n-      /*NOTREACHED */\n-    }\n-\n-  return 0;\n-}\n-#endif /* HAVE_SIGSEND */\n-\n \n-STATIC void\n-closeServer ()\n-{\n-  kill( (pid_t) serverId, SIGKILL);\n-  serverId = NULLPROCESS;\n-  fclose (serverPair.pfRead);\n-  fclose (serverPair.pfWrite);\n-  serverPair.pfRead = serverPair.pfWrite = (FILE *) NULL;\n-}\n-\n-\n-struct sigaction savePipeAction;\n-struct sigaction saveAlrmAction;\n-struct sigaction currentAction;\n-\n-STATIC void\n-sigHandler (signo)\n+/*\n+ *  sig_handler really only handles the timeout and pipe signals.\n+ *  This ensures that we do not wait forever on a request\n+ *  to our server, and also that if the server dies, we do not\n+ *  die from a sigpipe problem.\n+ */\n+static void\n+sig_handler (signo)\n      int signo;\n {\n-  closeServer ();\n-  readPipeTimeout = BOOL_TRUE;\n+  close_server ();\n+  read_pipe_timeout = BOOL_TRUE;\n }\n \n \n-STATIC void\n-serverSetup ()\n+/*\n+ *  server_setup  Establish the signal handler for PIPE and ALARM.\n+ *  Also establishes the current directory to give to the\n+ *  server process at the start of every server command.\n+ */\n+static void\n+server_setup ()\n {\n-#ifndef SA_SIGINFO\n-#  define SA_SIGINFO 0\n-#else\n-  currentAction.sa_sigaction =\n-#endif\n-  currentAction.sa_handler   = sigHandler;\n-  currentAction.sa_flags     = SA_SIGINFO;\n-  sigemptyset( &currentAction.sa_mask );\n+  static int atexit_done = 0;\n+  \n+  if (atexit_done++ == 0)\n+    atexit (&close_server);\n \n-  sigaction( SIGPIPE, &currentAction, &savePipeAction );\n-  sigaction( SIGALRM, &currentAction, &saveAlrmAction );\n-  atexit( &closeServer );\n+  signal (SIGPIPE, sig_handler);\n+  signal (SIGALRM, sig_handler);\n \n-  fputs (\"trap : INT\\n\", serverPair.pfWrite);\n-  fflush (serverPair.pfWrite);\n-  pCurDir = getcwd ((char *) NULL, MAXPATHLEN + 1);\n+  fputs (\"trap : 1\\n\", server_pair.pf_write);\n+  fflush (server_pair.pf_write);\n+  p_cur_dir = getcwd ((char *) NULL, MAXPATHLEN + 1);\n }\n \n \n+/*\n+ *  run_shell\n+ *\n+ *  Run a shell command on the server.  The command string\n+ *  passed in is wrapped inside the sequence:\n+ *\n+ *     cd <original directory>\n+ *     <command string>\n+ *     echo\n+ *     echo <end-of-command-marker>\n+ *\n+ *  This ensures that all commands start at a known place in\n+ *  the directory structure, that any incomplete output lines\n+ *  are completed and that our special marker sequence appears on\n+ *  a line by itself.  We have chosen a marker that is\n+ *  excessively unlikely to be reproduced in normal output:\n+ *\n+ *     \"ShElL-OuTpUt-HaS-bEeN-cOmPlEtEd\"\n+ */\n char *\n-runShell (pzCmd)\n-     const char *pzCmd;\n+run_shell (pz_cmd)\n+     const char *pz_cmd;\n {\n-  tSCC zNil[] = \"\";\n+  /*  IF the shell server process is not running yet,\n+      THEN try to start it.  */\n+  if (server_id == NULLPROCESS)\n+    {\n+      server_id = proc2_fopen (&server_pair, def_args);\n+      if (server_id > 0)\n+        server_setup ();\n+    }\n \n-  /*\n-   *  IF the shell server process is not running yet,\n-   *  THEN try to start it.\n-   */\n-  if (serverId == NULLPROCESS)\n+  /*  IF it is still not running, THEN return the nil string.  */\n+  if (server_id <= 0)\n     {\n-      serverId = p2fopen (&serverPair, defArgs);\n-      if (serverId > 0)\n-\tserverSetup ();\n+      char *pz = (char *) malloc (1);\n+      \n+      if (pz != (char *) NULL)\n+        *pz = '\\0';\n+      return pz;\n     }\n \n-  /*\n-   *  IF it is still not running,\n-   *  THEN return the nil string.\n-   */\n-  if (serverId <= 0)\n-    return (char *) zNil;\n+  /*  Make sure the process will pay attention to us, send the\n+     supplied command, and then have it output a special marker that\n+     we can find.  */\n+  fprintf (server_pair.pf_write, \"\\\\cd %s\\n%s\\n\\necho\\necho %s\\n\",\n+           p_cur_dir, pz_cmd, z_done);\n+  fflush (server_pair.pf_write);\n \n-  /*\n-   *  Make sure the process will pay attention to us,\n-   *  send the supplied command, and then\n-   *  have it output a special marker that we can find.\n-   */\n-  fprintf (serverPair.pfWrite, \"\\\\cd %s\\n%s\\n\\necho\\necho %s\\n\",\n-\t   pCurDir, pzCmd, zDone);\n-  fflush (serverPair.pfWrite);\n-  if (serverId == NULLPROCESS)\n-    return (char *) NULL;\n+  /*  IF the server died and we received a SIGPIPE,\n+      THEN return an empty string.  */\n+  if (server_id == NULLPROCESS)\n+    {\n+      char *pz = (char *) malloc (1);\n+      \n+      if (pz != (char *) NULL)\n+        *pz = '\\0';\n+      return pz;\n+    }\n \n-  /*\n-   *  Now try to read back all the data.  If we fail due to either\n-   *  a sigpipe or sigalrm (timeout), we will return the nil string.\n-   */\n+  /*  Now try to read back all the data.  If we fail due to either a\n+     sigpipe or sigalrm (timeout), we will return the nil string.  */\n   {\n-    char *pz = loadData (serverPair.pfRead);\n+    char *pz = load_data (server_pair.pf_read);\n+    \n     if (pz == (char *) NULL)\n       {\n-\tfprintf (stderr, \"CLOSING SHELL SERVER - command failure:\\n\\t%s\\n\",\n-\t\t pzCmd);\n-\tcloseServer ();\n-\tpz = (char *) zNil;\n+        fprintf (stderr, \"CLOSING SHELL SERVER - command failure:\\n\\t%s\\n\",\n+                 pz_cmd);\n+        close_server ();\n+        pz = (char *) malloc (1);\n+        if (pz != (char *) NULL)\n+          *pz = '\\0';\n       }\n     return pz;\n   }"}, {"sha": "0c2a0bf6093d245bd974a10c4443955eda148680", "filename": "gcc/fixinc/server.h", "status": "modified", "additions": 36, "deletions": 36, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f414ac48f4a946930e35c5003b5f020ad8168c4/gcc%2Ffixinc%2Fserver.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f414ac48f4a946930e35c5003b5f020ad8168c4/gcc%2Ffixinc%2Fserver.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffixinc%2Fserver.h?ref=1f414ac48f4a946930e35c5003b5f020ad8168c4", "patch": "@@ -1,8 +1,8 @@\n \n /*\n- *  $Id: server.h,v 1.2 1998/12/16 21:19:17 law Exp $\n+ *  server.c  Set up and handle communications with a server process.\n  *\n- *  Server Handling copyright 1992-1998 Bruce Korb\n+ *  Server Handling copyright 1992-1999 The Free Software Foundation\n  *\n  *  Server Handling is free software.\n  *  You may redistribute it and/or modify it under the terms of the\n@@ -20,8 +20,9 @@\n  *             59 Temple Place - Suite 330,\n  *             Boston,  MA  02111-1307, USA.\n  *\n- * As a special exception, Bruce Korb gives permission for additional\n- * uses of the text contained in his release of ServerHandler.\n+ * As a special exception, The Free Software Foundation gives\n+ * permission for additional uses of the text contained in his release\n+ * of ServerHandler.\n  *\n  * The exception is that, if you link the ServerHandler library with other\n  * files to produce an executable, this does not by itself cause the\n@@ -32,12 +33,13 @@\n  * This exception does not however invalidate any other reasons why\n  * the executable file might be covered by the GNU General Public License.\n  *\n- * This exception applies only to the code released by Bruce Korb under\n- * the name ServerHandler.  If you copy code from other sources under the\n- * General Public License into a copy of ServerHandler, as the General Public\n- * License permits, the exception does not apply to the code that you add\n- * in this way.  To avoid misleading anyone as to the status of such\n- * modified files, you must delete this exception notice from them.\n+ * This exception applies only to the code released by The Free\n+ * Software Foundation under the name ServerHandler.  If you copy code\n+ * from other sources under the General Public License into a copy of\n+ * ServerHandler, as the General Public License permits, the exception\n+ * does not apply to the code that you add in this way.  To avoid\n+ * misleading anyone as to the status of such modified files, you must\n+ * delete this exception notice from them.\n  *\n  * If you write modifications of your own for ServerHandler, it is your\n  * choice whether to permit this exception to apply to your modifications.\n@@ -48,47 +50,45 @@\n #define FIXINC_SERVER_H\n \n #include <stdio.h>\n+#ifdef HAVE_UNISTD_H\n #include <unistd.h>\n+#endif\n \n /*\n  *  Dual pipe opening of a child process\n  */\n \n typedef struct\n-  {\n-    int readFd;\n-    int writeFd;\n-  }\n-tFdPair;\n+{\n+  int read_fd;\n+  int write_fd;\n+} t_fd_pair;\n \n typedef struct\n-  {\n-    FILE *pfRead;\t\t/* parent read fp  */\n-    FILE *pfWrite;\t\t/* parent write fp */\n-  }\n-tpfPair;\n+{\n+  FILE *pf_read;\t\t/* parent read fp  */\n+  FILE *pf_write;\t\t/* parent write fp */\n+} t_pf_pair;\n \n-typedef char *tpChar;\n+typedef char *t_pchar;\n \n-#define NOPROCESS   ((pid_t)-1)\n-#define NULLPROCESS ((pid_t)0)\n+#define NOPROCESS\t((pid_t) -1)\n+#define NULLPROCESS\t((pid_t)0)\n \n-#define EXIT_PANIC   99\n+#define EXIT_PANIC\t99\n \n typedef enum\n-  {\n-    BOOL_FALSE, BOOL_TRUE\n-  }\n-bool;\n+{\n+  BOOL_FALSE, BOOL_TRUE\n+} bool;\n \n-#define _P_(p) ()\n+#define _P_(p)\t()\n \n-char *runShell _P_ ((const char *pzCmd));\n-pid_t p2fopen _P_ ((tpfPair * pfPair, tpChar * ppArgs));\n-pid_t p2open _P_ ((tFdPair * pPair, tpChar * ppArgs));\n-int\n-chainOpen _P_ ((int stdinFd,\n-\t\ttpChar * ppArgs,\n-\t\tpid_t * pChild));\n+char *run_shell   _P_ (( const char *pzCmd));\n+pid_t proc2_fopen _P_ (( t_pf_pair * p_pair, t_pchar * pp_args));\n+pid_t proc2_open  _P_ (( t_fd_pair * p_pair, t_pchar * pp_args));\n+int chain_open    _P_ (( int in_fd,\n+                         t_pchar * pp_args,\n+                         pid_t * p_child));\n \n #endif /* FIXINC_SERVER_H */"}]}