{"sha": "d642571f32e52d00e0a287c6238dd5d9faeea82d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDY0MjU3MWYzMmU1MmQwMGUwYTI4N2M2MjM4ZGQ1ZDlmYWVlYTgyZA==", "commit": {"author": {"name": "Michael Koch", "email": "konqueror@gmx.de", "date": "2004-07-09T15:22:19Z"}, "committer": {"name": "Michael Koch", "email": "mkoch@gcc.gnu.org", "date": "2004-07-09T15:22:19Z"}, "message": "DeflaterOutputStream.java, [...]: Reformatted.\n\n2004-07-09  Michael Koch  <konqueror@gmx.de>\n\n\t* java/util/zip/DeflaterOutputStream.java,\n\tjava/util/zip/GZIPInputStream.java,\n\tjava/util/zip/GZIPOutputStream.java,\n\tjava/util/zip/InflaterInputStream.java:\n\tReformatted. Added javadocs. Reordered all stuff.\n\tRenamed variables to be more clear.\n\nFrom-SVN: r84380", "tree": {"sha": "da8856033bd84b9270468089c3a2f34c2c565b0a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/da8856033bd84b9270468089c3a2f34c2c565b0a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d642571f32e52d00e0a287c6238dd5d9faeea82d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d642571f32e52d00e0a287c6238dd5d9faeea82d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d642571f32e52d00e0a287c6238dd5d9faeea82d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d642571f32e52d00e0a287c6238dd5d9faeea82d/comments", "author": null, "committer": null, "parents": [{"sha": "fbc40a17c9aeaa3342d4122c45356fec7faa14e3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fbc40a17c9aeaa3342d4122c45356fec7faa14e3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fbc40a17c9aeaa3342d4122c45356fec7faa14e3"}], "stats": {"total": 337, "additions": 207, "deletions": 130}, "files": [{"sha": "d78d2734db7d30ba6598cca9d440d33d8448d0e3", "filename": "libjava/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d642571f32e52d00e0a287c6238dd5d9faeea82d/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d642571f32e52d00e0a287c6238dd5d9faeea82d/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=d642571f32e52d00e0a287c6238dd5d9faeea82d", "patch": "@@ -1,3 +1,12 @@\n+2004-07-09  Michael Koch  <konqueror@gmx.de>\n+\n+\t* java/util/zip/DeflaterOutputStream.java,\n+\tjava/util/zip/GZIPInputStream.java,\n+\tjava/util/zip/GZIPOutputStream.java,\n+\tjava/util/zip/InflaterInputStream.java:\n+\tReformatted. Added javadocs. Reordered all stuff.\n+\tRenamed variables to be more clear.\n+\n 2004-07-09  Michael Koch  <konqueror@gmx.de>\n \n \t* javax/imageio/IIOException.java,"}, {"sha": "7ae7d193acdc83b8fa7ae6f9a9f7131a2a84cba7", "filename": "libjava/java/util/zip/DeflaterOutputStream.java", "status": "modified", "additions": 45, "deletions": 27, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d642571f32e52d00e0a287c6238dd5d9faeea82d/libjava%2Fjava%2Futil%2Fzip%2FDeflaterOutputStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d642571f32e52d00e0a287c6238dd5d9faeea82d/libjava%2Fjava%2Futil%2Fzip%2FDeflaterOutputStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2Fzip%2FDeflaterOutputStream.java?ref=d642571f32e52d00e0a287c6238dd5d9faeea82d", "patch": "@@ -60,18 +60,23 @@\n  */\n public class DeflaterOutputStream extends FilterOutputStream\n {\n-  public void close () throws IOException\n-  {\n-    finish ();\n-    out.close();\n-  }\n+  /** \n+   * This buffer is used temporarily to retrieve the bytes from the\n+   * deflater and write them to the underlying output stream.  \n+   */\n+  protected byte[] buf;\n \n+  /** \n+   * The deflater which is used to deflate the stream.\n+   */\n+  protected Deflater def;\n+  \n   /**\n    * Deflates everything in the def's input buffers.  This will call\n    * <code>def.deflate()</code> until all bytes from the input buffers\n    * are processed.\n    */\n-  protected void deflate () throws IOException\n+  protected void deflate() throws IOException\n   {\n     do\n       {\n@@ -87,9 +92,9 @@ protected void deflate () throws IOException\n    * default buffer size.\n    * @param out the output stream where deflated output should be written.\n    */\n-  public DeflaterOutputStream (OutputStream out)\n+  public DeflaterOutputStream(OutputStream out)\n   {\n-    this (out, new Deflater (), 512);\n+    this(out, new Deflater(), 512);\n   }\n \n   /** \n@@ -98,9 +103,9 @@ public DeflaterOutputStream (OutputStream out)\n    * @param out the output stream where deflated output should be written.\n    * @param defl the underlying deflater.\n    */\n-  public DeflaterOutputStream (OutputStream out, Deflater defl)\n+  public DeflaterOutputStream(OutputStream out, Deflater defl)\n   {\n-    this (out, defl, 512);\n+    this(out, defl, 512);\n   }\n \n   /** \n@@ -113,7 +118,7 @@ public DeflaterOutputStream (OutputStream out, Deflater defl)\n    */\n   public DeflaterOutputStream(OutputStream out, Deflater defl, int bufsize)\n   {\n-    super (out);\n+    super(out);\n     if (bufsize <= 0)\n       throw new IllegalArgumentException(\"bufsize <= 0\");\n     buf = new byte[bufsize];\n@@ -125,52 +130,65 @@ public DeflaterOutputStream(OutputStream out, Deflater defl, int bufsize)\n    * was the only way to ensure that all bytes are flushed in Sun's\n    * JDK.  \n    */\n-  public void finish () throws IOException\n+  public void finish() throws IOException\n   {\n     inbufWrite();\n     def.finish();\n-    while (! def.finished ())\n+    while (! def.finished())\n       {\n \tint len = def.deflate(buf, 0, buf.length);\n \tif (len > 0)\n \t  out.write(buf, 0, len);\n       }\n   }\n \n-  public void write (int bval) throws IOException\n+  /**\n+   * Calls finish() and closes the stream. \n+   */\n+  public void close() throws IOException\n+  {\n+    finish();\n+    out.close();\n+  }\n+\n+  /**\n+   * Writes a single byte to the compressed output stream.\n+   * @param bval the byte value.\n+   */\n+  public void write(int bval) throws IOException\n   {\n     if (inbuf == null)\n       inbuf = new byte[128];\n     else if (inbufLength == inbuf.length)\n-      inbufWrite ();\n+      inbufWrite();\n     inbuf[inbufLength++] = (byte) bval;\n   }\n \n-  public void write (byte[] buf, int off, int len) throws IOException\n+  /**\n+   * Writes a len bytes from an array to the compressed stream.\n+   * @param buf the byte array.\n+   * @param off the offset into the byte array where to start.\n+   * @param len the number of bytes to write.\n+   */\n+  public void write(byte[] buf, int off, int len) throws IOException\n   {\n-    inbufWrite ();\n-    def.setInput (buf, off, len);\n-    deflate ();\n+    inbufWrite();\n+    def.setInput(buf, off, len);\n+    deflate();\n   }\n \n-  private void inbufWrite () throws IOException\n+  private void inbufWrite() throws IOException\n   {\n     if (inbufLength > 0)\n       {\n \tint size = inbufLength;\n \tinbufLength = 0;\n-\twrite (inbuf, 0, size);\n+\twrite(inbuf, 0, size);\n       }\n   }\n \n   // Used, if needed, for write(int).\n   private byte[] inbuf;\n   // Used length of inbuf.\n   private int inbufLength;\n-\n-  // The retrieval buffer.\n-  protected byte[] buf;\n-\n-  // Deflater used to compress data.\n-  protected Deflater def;\n }"}, {"sha": "ec4613f153c2be1bdc967634ea8650d8873e9127", "filename": "libjava/java/util/zip/GZIPInputStream.java", "status": "modified", "additions": 37, "deletions": 14, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d642571f32e52d00e0a287c6238dd5d9faeea82d/libjava%2Fjava%2Futil%2Fzip%2FGZIPInputStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d642571f32e52d00e0a287c6238dd5d9faeea82d/libjava%2Fjava%2Futil%2Fzip%2FGZIPInputStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2Fzip%2FGZIPInputStream.java?ref=d642571f32e52d00e0a287c6238dd5d9faeea82d", "patch": "@@ -56,6 +56,43 @@\n    */\n   public static final int GZIP_MAGIC = 0x8b1f;\n \n+  static final int Z_DEFLATED = 8;\n+\n+  /**\n+   * The mask for bit 1 of the flag byte.\n+   */\n+  static final int HEAD_CRC = 0x02;\n+\n+  /**\n+   * The mask for bit 2 of the flag byte.\n+   */\n+  static final int EXTRA_FIELD = 0x04;\n+\n+  /**\n+   * The mask for bit 3 of the flag byte.\n+   */\n+  static final int ORIG_NAME = 0x08;\n+\n+  /**\n+   * The mask for bit 4 of the flag byte.\n+   */\n+  static final int COMMENT = 0x10;\n+\n+  /**\n+   * The mask for all reserved bits of the flag byte.\n+   */\n+  static final int RESERVED = 0xe0;\n+  \n+  /**\n+   * The CRC-32 checksum value for uncompressed data.\n+   */\n+  protected CRC32 crc; \n+\n+  /**\n+   * Indicates whether or not the end of the stream has been reached.\n+   */  \n+  protected boolean eos;\n+\n   /**\n    * Creates a GZIPInputStream with the default buffer size.\n    *\n@@ -210,18 +247,4 @@ private final int read4(byte[] buf, int offset) throws IOException\n     return (((buf[offset + 3] & 0xFF) << 24) + ((buf[offset + 2] & 0xFF) << 16)\n \t    + ((buf[offset + 1] & 0xFF) << 8) + (buf[offset] & 0xFF));\n   }\n-\n-  // Checksum used by this input stream.\n-  protected CRC32 crc;\n-\n-  // Indicates whether end-of-stream has been reached.\n-  protected boolean eos;\n-\n-  // Some constants from zlib.\n-  static final int Z_DEFLATED = 8;\n-  static final int HEAD_CRC    = 0x02;\n-  static final int EXTRA_FIELD = 0x04;\n-  static final int ORIG_NAME   = 0x08;\n-  static final int COMMENT     = 0x10;\n-  static final int RESERVED    = 0xe0;\n }"}, {"sha": "70339a022d02bc540b76ab4cb26e2649565b9e1d", "filename": "libjava/java/util/zip/GZIPOutputStream.java", "status": "modified", "additions": 63, "deletions": 43, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d642571f32e52d00e0a287c6238dd5d9faeea82d/libjava%2Fjava%2Futil%2Fzip%2FGZIPOutputStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d642571f32e52d00e0a287c6238dd5d9faeea82d/libjava%2Fjava%2Futil%2Fzip%2FGZIPOutputStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2Fzip%2FGZIPOutputStream.java?ref=d642571f32e52d00e0a287c6238dd5d9faeea82d", "patch": "@@ -41,8 +41,12 @@\n import java.io.OutputStream;\n \n /**\n+ * This filter stream is used to compress a stream into a \"GZIP\" stream. \n+ * The \"GZIP\" format is described in RFC 1952.\n+ *\n+ * @author John Leuner\n  * @author Tom Tromey\n- * @date May 17, 1999\n+ * @since JDK 1.1\n  */\n \n /* Written using on-line Java Platform 1.2 API Specification\n@@ -52,75 +56,91 @@\n \n public class GZIPOutputStream extends DeflaterOutputStream\n {\n-  public void close () throws IOException\n-  {\n-    finish ();\n-    out.close ();\n-  }\n-\n-  public void finish () throws IOException\n-  {\n-    super.finish();\n-    put4 ((int) crc.getValue());\n-    put4 (def.getTotalIn());\n-  }\n+  /**\n+   * CRC-32 value for uncompressed data\n+   */\n+  protected CRC32 crc;\n \n-  public GZIPOutputStream (OutputStream out) throws IOException\n+  /**\n+   * Creates a GZIPOutputStream with the default buffer size\n+   *\n+   * @param out The stream to read data (to be compressed) from \n+   * \n+   */\n+  public GZIPOutputStream(OutputStream out) throws IOException\n   {\n-    this (out, 512);\n+    this(out, 512);\n   }\n \n-  public GZIPOutputStream (OutputStream out, int readsize) throws IOException\n+  /**\n+   * Creates a GZIPOutputStream with the specified buffer size\n+   *\n+   * @param out The stream to read compressed data from \n+   * @param size Size of the buffer to use \n+   */\n+  public GZIPOutputStream(OutputStream out, int size) throws IOException\n   {\n-    super (out, new Deflater (Deflater.DEFAULT_COMPRESSION, true), readsize);\n-\n-    put2 (GZIPInputStream.GZIP_MAGIC);\n-    out.write (GZIPInputStream.Z_DEFLATED);\n+    super(out, new Deflater(Deflater.DEFAULT_COMPRESSION, true), size);\n+    crc = new CRC32();\n+    put2(GZIPInputStream.GZIP_MAGIC);\n+    out.write(GZIPInputStream.Z_DEFLATED);\n     // No flags for now.\n-    out.write (0);\n+    out.write(0);\n     // No time either.\n-    put2 (0);\n-    put2 (0);\n+    put2(0);\n+    put2(0);\n     // No xflags either.\n-    out.write (0);\n+    out.write(0);\n     // FIXME: unknown OS.\n-    out.write (255);\n-\n-    crc = new CRC32 ();\n+    out.write(255);\n   }\n \n-  public synchronized void write (int bval) throws IOException\n+  public synchronized void write(int bval) throws IOException\n   {\n-    super.write (bval);\n-    crc.update (bval);\n+    super.write(bval);\n+    crc.update(bval);\n   }\n \n-  public synchronized void write (byte[] buf) throws IOException\n+  public synchronized void write(byte[] buf) throws IOException\n   {\n-    write (buf, 0, buf.length);\n+    write(buf, 0, buf.length);\n   }\n \n-  public synchronized void write (byte[] buf, int off, int len)\n+  public synchronized void write(byte[] buf, int off, int len)\n     throws IOException\n   {\n     super.write(buf, off, len);\n     crc.update(buf, off, len);\n   }\n \n-  private final void put2 (int i) throws IOException\n+  /**\n+   * Writes remaining compressed output data to the output stream\n+   * and closes it.\n+   */\n+  public void close() throws IOException\n   {\n-    out.write (i);\n-    out.write (i >> 8);\n+    finish();\n+    out.close();\n   }\n \n-  private final void put4 (int i) throws IOException\n+  public void finish() throws IOException\n   {\n-    out.write (i);\n-    out.write (i >> 8);\n-    out.write (i >> 16);\n-    out.write (i >> 24);\n+    super.finish();\n+    put4((int) crc.getValue());\n+    put4(def.getTotalIn());\n   }\n \n-  // Checksum used by this stream.\n-  protected CRC32 crc;\n+  private final void put2(int i) throws IOException\n+  {\n+    out.write(i);\n+    out.write(i >> 8);\n+  }\n+\n+  private final void put4 (int i) throws IOException\n+  {\n+    out.write(i);\n+    out.write(i >> 8);\n+    out.write(i >> 16);\n+    out.write(i >> 24);\n+  }\n }"}, {"sha": "60442e474afabf3e19be5b8f0f5f1ecf61d4e938", "filename": "libjava/java/util/zip/InflaterInputStream.java", "status": "modified", "additions": 53, "deletions": 46, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d642571f32e52d00e0a287c6238dd5d9faeea82d/libjava%2Fjava%2Futil%2Fzip%2FInflaterInputStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d642571f32e52d00e0a287c6238dd5d9faeea82d/libjava%2Fjava%2Futil%2Fzip%2FInflaterInputStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2Fzip%2FInflaterInputStream.java?ref=d642571f32e52d00e0a287c6238dd5d9faeea82d", "patch": "@@ -70,12 +70,6 @@ public class InflaterInputStream extends FilterInputStream\n    */\n   protected int len;\n \n-  protected void fill () throws IOException\n-  {\n-    len = in.read(buf, 0, buf.length);\n-    if (len != -1)\n-      inf.setInput(buf, 0, len);\n-  }\n \n   /**\n    * Create an InflaterInputStream with the default decompresseor\n@@ -85,7 +79,7 @@ protected void fill () throws IOException\n    */\n   public InflaterInputStream(InputStream in) \n   {\n-    this (in, new Inflater (), 512);\n+    this(in, new Inflater(), 512);\n   }\n \n   /**\n@@ -97,7 +91,7 @@ public InflaterInputStream(InputStream in)\n    */\n   public InflaterInputStream(InputStream in, Inflater inf) \n   {\n-    this (in, inf, 512);\n+    this(in, inf, 512);\n   }\n \n   /**\n@@ -113,25 +107,51 @@ public InflaterInputStream(InputStream in, Inflater inf, int size)\n     super(in);\n \n     if (in == null)\n-      throw new NullPointerException (\"in may not be null\");\n+      throw new NullPointerException(\"in may not be null\");\n     if (inf == null)\n-      throw new NullPointerException (\"inf may not be null\");\n+      throw new NullPointerException(\"inf may not be null\");\n     if (size < 0)\n-      throw new IllegalArgumentException (\"size may not be negative\");\n+      throw new IllegalArgumentException(\"size may not be negative\");\n     \n     this.inf = inf;\n     this.buf = new byte [size];\n   }\n \n-  public int read () throws IOException\n+  /**\n+   * Returns 0 once the end of the stream (EOF) has been reached.\n+   * Otherwise returns 1.\n+   */\n+  public int available() throws IOException\n+  {\n+    // According to the JDK 1.2 docs, this should only ever return 0\n+    // or 1 and should not be relied upon by Java programs.\n+    if (inf == null)\n+      throw new IOException(\"stream closed\");\n+    return inf.finished() ? 0 : 1;\n+  }\n+\n+  /**\n+   * Closes the input stream\n+   */\n+  public synchronized void close() throws IOException\n   {\n-    byte[] buf = new byte[1];\n-    int r = read (buf, 0, 1);\n-    if (r != -1)\n-      r = buf[0] & 0xff;\n-    return r;\n+    inf = null;\n+    super.close();\n   }\n \n+  /**\n+   * Fills the buffer with more data to decompress.\n+   */\n+  protected void fill() throws IOException\n+  {\n+    if (in == null)\n+      throw new ZipException (\"InflaterInputStream is closed\");\n+    \n+    len = in.read(buf, 0, buf.length);\n+\n+    if (len != -1)\n+      inf.setInput(buf, 0, len);\n+  }\n \n   /**\n    * Decompresses data into the byte array\n@@ -143,7 +163,7 @@ public int read () throws IOException\n   public int read(byte[] b, int off, int len) throws IOException\n   {\n     if (inf == null)\n-      throw new IOException (\"stream closed\");\n+      throw new IOException(\"stream closed\");\n     if (len == 0)\n       return 0;\n     if (inf.finished())\n@@ -153,7 +173,7 @@ public int read(byte[] b, int off, int len) throws IOException\n     while (count == 0)\n       {\n \tif (inf.needsInput())\n-\t  fill ();\n+\t  fill();\n \t\n \ttry\n \t  {\n@@ -166,7 +186,7 @@ public int read(byte[] b, int off, int len) throws IOException\n \t\t    return -1;\n \t\t  }\n \t\tif (inf.needsDictionary())\n-\t\t  throw new ZipException (\"Inflater needs Dictionary\");\n+\t\t  throw new ZipException(\"Inflater needs Dictionary\");\n \t      }\n \t  } \n \tcatch (DataFormatException dfe) \n@@ -177,21 +197,6 @@ public int read(byte[] b, int off, int len) throws IOException\n     return count;\n   }\n \n-  public void close () throws IOException\n-  {\n-    inf = null;\n-    super.close ();\n-  }\n-\n-  public int available () throws IOException\n-  {\n-    // According to the JDK 1.2 docs, this should only ever return 0\n-    // or 1 and should not be relied upon by Java programs.\n-    if (inf == null)\n-      throw new IOException (\"stream closed\");\n-    return inf.finished () ? 0 : 1;\n-  }\n-\n   /**\n    * Skip specified number of bytes of uncompressed data\n    *\n@@ -200,25 +205,27 @@ public int available () throws IOException\n   public long skip(long n) throws IOException\n   {\n     if (inf == null)\n-      throw new IOException (\"stream closed\");\n+      throw new IOException(\"stream closed\");\n+    if (n < 0)\n+      throw new IllegalArgumentException();\n \n     if (n == 0)\n       return 0;\n \n-    int min = (int) Math.min(n, 1024);\n-    byte[] buf = new byte[min];\n+    int buflen = (int) Math.min(n, 1024);\n+    byte[] tmpbuf = new byte[buflen];\n \n-    long s = 0;\n-    while (n > 0)\n+    long skipped = 0L;\n+    while (n > 0L)\n       {\n-\tint r = read (buf, 0, min);\n-\tif (r == -1)\n+\tint numread = read(tmpbuf, 0, buflen);\n+\tif (numread == -1)\n \t  break;\n-\tn -= r;\n-\ts += r;\n-\tmin = (int) Math.min(n, 1024);\n+\tn -= numread;\n+\tskipped += numread;\n+\tbuflen = (int) Math.min(n, 1024);\n       }\n \n-    return s;\n+    return skipped;\n  }\n }"}]}