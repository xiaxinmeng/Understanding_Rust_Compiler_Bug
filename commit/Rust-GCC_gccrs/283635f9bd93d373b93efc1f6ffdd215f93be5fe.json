{"sha": "283635f9bd93d373b93efc1f6ffdd215f93be5fe", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjgzNjM1ZjliZDkzZDM3M2I5M2VmYzFmNmZmZGQyMTVmOTNiZTVmZQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2016-06-16T19:03:05Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2016-06-16T19:03:05Z"}, "message": "gimplify.c (gimplify_scan_omp_clauses): Handle COMPONENT_REFs with base of reference to struct.\n\n\t* gimplify.c (gimplify_scan_omp_clauses): Handle COMPONENT_REFs\n\twith base of reference to struct.\n\n\t* parser.c (cp_parser_omp_var_list_no_open): Call\n\tconvert_from_reference before cp_parser_postfix_dot_deref_expression.\n\t* semantics.c (finish_omp_clauses): Don't ICE when\n\tprocessing_template_decl when checking for bitfields and unions.\n\tLook through REFERENCE_REF_P as base of COMPONENT_REF.\n\n\t* testsuite/libgomp.c++/target-20.C: New test.\n\nFrom-SVN: r237538", "tree": {"sha": "5e58a24aa0c773a550f62bd0edd6c36e5155b9cc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5e58a24aa0c773a550f62bd0edd6c36e5155b9cc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/283635f9bd93d373b93efc1f6ffdd215f93be5fe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/283635f9bd93d373b93efc1f6ffdd215f93be5fe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/283635f9bd93d373b93efc1f6ffdd215f93be5fe", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/283635f9bd93d373b93efc1f6ffdd215f93be5fe/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "4389cf2551f89c0e060479396786f74aae14d3b2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4389cf2551f89c0e060479396786f74aae14d3b2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4389cf2551f89c0e060479396786f74aae14d3b2"}], "stats": {"total": 163, "additions": 154, "deletions": 9}, "files": [{"sha": "20e4ecdb4e046f352d669f3bd026d19141eabdd8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/283635f9bd93d373b93efc1f6ffdd215f93be5fe/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/283635f9bd93d373b93efc1f6ffdd215f93be5fe/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=283635f9bd93d373b93efc1f6ffdd215f93be5fe", "patch": "@@ -1,3 +1,8 @@\n+2016-06-16  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* gimplify.c (gimplify_scan_omp_clauses): Handle COMPONENT_REFs\n+\twith base of reference to struct.\n+\n 2016-06-16  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* doc/invoke.texi (x86 Options): Document -m80387 and -mhard-float."}, {"sha": "5ad3354d69ca80ed4479ec693dacbf6fba8f2584", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/283635f9bd93d373b93efc1f6ffdd215f93be5fe/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/283635f9bd93d373b93efc1f6ffdd215f93be5fe/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=283635f9bd93d373b93efc1f6ffdd215f93be5fe", "patch": "@@ -1,3 +1,11 @@\n+2016-06-16  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* parser.c (cp_parser_omp_var_list_no_open): Call\n+\tconvert_from_reference before cp_parser_postfix_dot_deref_expression.\n+\t* semantics.c (finish_omp_clauses): Don't ICE when\n+\tprocessing_template_decl when checking for bitfields and unions.\n+\tLook through REFERENCE_REF_P as base of COMPONENT_REF.\n+\n 2016-06-15  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \t* decl.c (wrapup_globals_for_namespace): Use DECL_SOURCE_LOCATION and"}, {"sha": "0846f0c04ea1f5c1ccdaa460eb4e27a0077d242a", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/283635f9bd93d373b93efc1f6ffdd215f93be5fe/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/283635f9bd93d373b93efc1f6ffdd215f93be5fe/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=283635f9bd93d373b93efc1f6ffdd215f93be5fe", "patch": "@@ -30001,6 +30001,7 @@ cp_parser_omp_var_list_no_open (cp_parser *parser, enum omp_clause_code kind,\n \t\t    = cp_lexer_peek_token (parser->lexer)->location;\n \t\t  cp_id_kind idk = CP_ID_KIND_NONE;\n \t\t  cp_lexer_consume_token (parser->lexer);\n+\t\t  decl = convert_from_reference (decl);\n \t\t  decl\n \t\t    = cp_parser_postfix_dot_deref_expression (parser, CPP_DOT,\n \t\t\t\t\t\t\t      decl, false,"}, {"sha": "4cc5d2316fb5e7f1a53d21c4f08cd2276dc751d7", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/283635f9bd93d373b93efc1f6ffdd215f93be5fe/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/283635f9bd93d373b93efc1f6ffdd215f93be5fe/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=283635f9bd93d373b93efc1f6ffdd215f93be5fe", "patch": "@@ -6664,7 +6664,8 @@ finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t    {\n \t      if (type_dependent_expression_p (t))\n \t\tbreak;\n-\t      if (DECL_BIT_FIELD (TREE_OPERAND (t, 1)))\n+\t      if (TREE_CODE (TREE_OPERAND (t, 1)) == FIELD_DECL\n+\t\t  && DECL_BIT_FIELD (TREE_OPERAND (t, 1)))\n \t\t{\n \t\t  error_at (OMP_CLAUSE_LOCATION (c),\n \t\t\t    \"bit-field %qE in %qs clause\",\n@@ -6680,8 +6681,9 @@ finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t\t}\n \t      while (TREE_CODE (t) == COMPONENT_REF)\n \t\t{\n-\t\t  if (TREE_CODE (TREE_TYPE (TREE_OPERAND (t, 0)))\n-\t\t      == UNION_TYPE)\n+\t\t  if (TREE_TYPE (TREE_OPERAND (t, 0))\n+\t\t      && (TREE_CODE (TREE_TYPE (TREE_OPERAND (t, 0)))\n+\t\t\t  == UNION_TYPE))\n \t\t    {\n \t\t      error_at (OMP_CLAUSE_LOCATION (c),\n \t\t\t\t\"%qE is a member of a union\", t);\n@@ -6692,6 +6694,8 @@ finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t\t}\n \t      if (remove)\n \t\tbreak;\n+\t      if (REFERENCE_REF_P (t))\n+\t\tt = TREE_OPERAND (t, 0);\n \t      if (VAR_P (t) || TREE_CODE (t) == PARM_DECL)\n \t\t{\n \t\t  if (bitmap_bit_p (&map_field_head, DECL_UID (t)))"}, {"sha": "47c4d253e41ddb49d21d7c19c7f2b9201866bf9e", "filename": "gcc/gimplify.c", "status": "modified", "additions": 49, "deletions": 6, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/283635f9bd93d373b93efc1f6ffdd215f93be5fe/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/283635f9bd93d373b93efc1f6ffdd215f93be5fe/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=283635f9bd93d373b93efc1f6ffdd215f93be5fe", "patch": "@@ -6983,6 +6983,11 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n \t\t{\n \t\t  while (TREE_CODE (decl) == COMPONENT_REF)\n \t\t    decl = TREE_OPERAND (decl, 0);\n+\t\t  if (TREE_CODE (decl) == INDIRECT_REF\n+\t\t      && DECL_P (TREE_OPERAND (decl, 0))\n+\t\t      && (TREE_CODE (TREE_TYPE (TREE_OPERAND (decl, 0)))\n+\t\t\t  == REFERENCE_TYPE))\n+\t\t    decl = TREE_OPERAND (decl, 0);\n \t\t}\n \t      if (gimplify_expr (pd, pre_p, NULL, is_gimple_lvalue, fb_lvalue)\n \t\t  == GS_ERROR)\n@@ -6998,9 +7003,11 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n \t\t      break;\n \t\t    }\n \n-\t\t  if (TYPE_SIZE_UNIT (TREE_TYPE (decl)) == NULL\n-\t\t      || (TREE_CODE (TYPE_SIZE_UNIT (TREE_TYPE (decl)))\n-\t\t\t  != INTEGER_CST))\n+\t\t  tree stype = TREE_TYPE (decl);\n+\t\t  if (TREE_CODE (stype) == REFERENCE_TYPE)\n+\t\t    stype = TREE_TYPE (stype);\n+\t\t  if (TYPE_SIZE_UNIT (stype) == NULL\n+\t\t      || TREE_CODE (TYPE_SIZE_UNIT (stype)) != INTEGER_CST)\n \t\t    {\n \t\t      error_at (OMP_CLAUSE_LOCATION (c),\n \t\t\t\t\"mapping field %qE of variable length \"\n@@ -7040,6 +7047,14 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n \t\t  base = get_inner_reference (base, &bitsize, &bitpos, &offset,\n \t\t\t\t\t      &mode, &unsignedp, &reversep,\n \t\t\t\t\t      &volatilep, false);\n+\t\t  tree orig_base = base;\n+\t\t  if ((TREE_CODE (base) == INDIRECT_REF\n+\t\t       || (TREE_CODE (base) == MEM_REF\n+\t\t\t   && integer_zerop (TREE_OPERAND (base, 1))))\n+\t\t      && DECL_P (TREE_OPERAND (base, 0))\n+\t\t      && (TREE_CODE (TREE_TYPE (TREE_OPERAND (base, 0)))\n+\t\t\t  == REFERENCE_TYPE))\n+\t\t    base = TREE_OPERAND (base, 0);\n \t\t  gcc_assert (base == decl\n \t\t\t      && (offset == NULL_TREE\n \t\t\t\t  || TREE_CODE (offset) == INTEGER_CST));\n@@ -7053,7 +7068,10 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n \t\t      tree l = build_omp_clause (OMP_CLAUSE_LOCATION (c),\n \t\t\t\t\t\t OMP_CLAUSE_MAP);\n \t\t      OMP_CLAUSE_SET_MAP_KIND (l, GOMP_MAP_STRUCT);\n-\t\t      OMP_CLAUSE_DECL (l) = decl;\n+\t\t      if (orig_base != base)\n+\t\t\tOMP_CLAUSE_DECL (l) = unshare_expr (orig_base);\n+\t\t      else\n+\t\t\tOMP_CLAUSE_DECL (l) = decl;\n \t\t      OMP_CLAUSE_SIZE (l) = size_int (1);\n \t\t      if (struct_map_to_clause == NULL)\n \t\t\tstruct_map_to_clause = new hash_map<tree, tree>;\n@@ -7095,6 +7113,18 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n \t\t\t  *list_p = l;\n \t\t\t  list_p = &OMP_CLAUSE_CHAIN (l);\n \t\t\t}\n+\t\t      if (orig_base != base && code == OMP_TARGET)\n+\t\t\t{\n+\t\t\t  tree c2 = build_omp_clause (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\t\t\t      OMP_CLAUSE_MAP);\n+\t\t\t  enum gomp_map_kind mkind\n+\t\t\t    = GOMP_MAP_FIRSTPRIVATE_REFERENCE;\n+\t\t\t  OMP_CLAUSE_SET_MAP_KIND (c2, mkind);\n+\t\t\t  OMP_CLAUSE_DECL (c2) = decl;\n+\t\t\t  OMP_CLAUSE_SIZE (c2) = size_zero_node;\n+\t\t\t  OMP_CLAUSE_CHAIN (c2) = OMP_CLAUSE_CHAIN (l);\n+\t\t\t  OMP_CLAUSE_CHAIN (l) = c2;\n+\t\t\t}\n \t\t      flags = GOVD_MAP | GOVD_EXPLICIT;\n \t\t      if (GOMP_MAP_ALWAYS_P (OMP_CLAUSE_MAP_KIND (c)) || ptr)\n \t\t\tflags |= GOVD_SEEN;\n@@ -7113,8 +7143,12 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n \t\t\to1 = 0;\n \t\t      if (bitpos)\n \t\t\to1 = o1 + bitpos / BITS_PER_UNIT;\n-\t\t      for (sc = &OMP_CLAUSE_CHAIN (*osc);\n-\t\t\t   *sc != c; sc = &OMP_CLAUSE_CHAIN (*sc))\n+\t\t      sc = &OMP_CLAUSE_CHAIN (*osc);\n+\t\t      if (*sc != c\n+\t\t\t  && (OMP_CLAUSE_MAP_KIND (*sc)\n+\t\t\t      == GOMP_MAP_FIRSTPRIVATE_REFERENCE)) \n+\t\t\tsc = &OMP_CLAUSE_CHAIN (*sc);\n+\t\t      for (; *sc != c; sc = &OMP_CLAUSE_CHAIN (*sc))\n \t\t\tif (ptr && sc == prev_list_p)\n \t\t\t  break;\n \t\t\telse if (TREE_CODE (OMP_CLAUSE_DECL (*sc))\n@@ -7150,6 +7184,15 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n \t\t\t\t\t\t\t&mode, &unsignedp,\n \t\t\t\t\t\t\t&reversep, &volatilep,\n \t\t\t\t\t\t\tfalse);\n+\t\t\t    if ((TREE_CODE (base) == INDIRECT_REF\n+\t\t\t\t || (TREE_CODE (base) == MEM_REF\n+\t\t\t\t     && integer_zerop (TREE_OPERAND (base,\n+\t\t\t\t\t\t\t\t     1))))\n+\t\t\t\t&& DECL_P (TREE_OPERAND (base, 0))\n+\t\t\t\t&& (TREE_CODE (TREE_TYPE (TREE_OPERAND (base,\n+\t\t\t\t\t\t\t\t\t0)))\n+\t\t\t\t    == REFERENCE_TYPE))\n+\t\t\t      base = TREE_OPERAND (base, 0);\n \t\t\t    if (base != decl)\n \t\t\t      break;\n \t\t\t    if (scp)"}, {"sha": "586657bb1309979733db94860afcfea71634dd85", "filename": "libgomp/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/283635f9bd93d373b93efc1f6ffdd215f93be5fe/libgomp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/283635f9bd93d373b93efc1f6ffdd215f93be5fe/libgomp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2FChangeLog?ref=283635f9bd93d373b93efc1f6ffdd215f93be5fe", "patch": "@@ -1,3 +1,7 @@\n+2016-06-16  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* testsuite/libgomp.c++/target-20.C: New test.\n+\n 2016-06-10  Thomas Schwinge  <thomas@codesourcery.com>\n \t    Cesar Philippidis  <cesar@codesourcery.com>\n "}, {"sha": "a722ec00c59b125da380c950871d928518af965d", "filename": "libgomp/testsuite/libgomp.c++/target-20.C", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/283635f9bd93d373b93efc1f6ffdd215f93be5fe/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftarget-20.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/283635f9bd93d373b93efc1f6ffdd215f93be5fe/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftarget-20.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftarget-20.C?ref=283635f9bd93d373b93efc1f6ffdd215f93be5fe", "patch": "@@ -0,0 +1,80 @@\n+extern \"C\" void abort ();\n+struct S { int a, b, c, d; };\n+\n+void\n+foo (S &s)\n+{\n+  int err;\n+  #pragma omp target map (s.b, s.d) map (from: err)\n+  {\n+    err = s.b != 21 || s.d != 24;\n+    s.b++; s.d++;\n+  }\n+  if (err || s.b != 22 || s.d != 25)\n+    abort ();\n+  #pragma omp target data map (s.b, s.d)\n+  {\n+    #pragma omp target map (alloc: s.b, s.d) map (from: err)\n+    {\n+      err = s.b != 22 || s.d != 25;\n+      s.b++; s.d++;\n+    }\n+  }\n+  if (err || s.b != 23 || s.d != 26)\n+    abort ();\n+  #pragma omp target data map (s)\n+  {\n+    #pragma omp target map (alloc: s.b, s.d) map (from: err)\n+    {\n+      err = s.b != 23 || s.d != 26;\n+      s.b++; s.d++;\n+    }\n+  }\n+  if (err || s.b != 24 || s.d != 27)\n+    abort ();\n+}\n+\n+template <typename T, typename U>\n+void\n+bar (S &s, T &t, U u)\n+{\n+  int err;\n+  #pragma omp target map (s.b, s.d, t.b, t.d, u.b, u.d) map (from: err)\n+  {\n+    err = s.b != 21 || s.d != 24 || t.b != 73 || t.d != 82 || u.b != 31 || u.d != 37;\n+    s.b++; s.d++; t.b++; t.d++; u.b++; u.d++;\n+  }\n+  if (err || s.b != 22 || s.d != 25 || t.b != 74 || t.d != 83 || u.b != 32 || u.d != 38)\n+    abort ();\n+  #pragma omp target data map (s.b, s.d, t.b, t.d, u.b, u.d)\n+  {\n+    #pragma omp target map (alloc: s.b, s.d, t.b, t.d, u.b, u.d) map (from: err)\n+    {\n+      err = s.b != 22 || s.d != 25 || t.b != 74 || t.d != 83 || u.b != 32 || u.d != 38;\n+      s.b++; s.d++; t.b++; t.d++; u.b++; u.d++;\n+    }\n+  }\n+  if (err || s.b != 23 || s.d != 26 || t.b != 75 || t.d != 84 || u.b != 33 || u.d != 39)\n+    abort ();\n+  #pragma omp target data map (s, t, u)\n+  {\n+    #pragma omp target map (alloc: s.b, s.d, t.b, t.d, u.b, u.d) map (from: err)\n+    {\n+      err = s.b != 23 || s.d != 26 || t.b != 75 || t.d != 84 || u.b != 33 || u.d != 39;\n+      s.b++; s.d++; t.b++; t.d++; u.b++; u.d++;\n+    }\n+  }\n+  if (err || s.b != 24 || s.d != 27 || t.b != 76 || t.d != 85 || u.b != 34 || u.d != 40)\n+    abort ();\n+}\n+\n+int\n+main ()\n+{\n+  S s = { 1, 21, 2, 24 };\n+  foo (s);\n+  S s2 = { 3, 21, 4, 24 };\n+  S t = { 5, 73, 6, 82 };\n+  S u = { 7, 31, 8, 37 };\n+  bar <S, S &> (s2, t, u);\n+}"}]}