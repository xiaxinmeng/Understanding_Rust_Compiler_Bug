{"sha": "dde1da7265dd4e09df0b6d426f8297d19b890cb3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGRlMWRhNzI2NWRkNGUwOWRmMGI2ZDQyNmY4Mjk3ZDE5Yjg5MGNiMw==", "commit": {"author": {"name": "Alexandre Petit-Bianco", "email": "apbianco@cygnus.com", "date": "2000-03-14T07:51:42Z"}, "committer": {"name": "Alexandre Petit-Bianco", "email": "apbianco@gcc.gnu.org", "date": "2000-03-14T07:51:42Z"}, "message": "parse.y (resolve_package): Set `next' once a type name has been progressively discovered.\n\n2000-03-13  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n\n\t* parse.y (resolve_package): Set `next' once a type name has been\n\tprogressively discovered.\n\t(resolve_qualified_expression_name): Propagate resolution only if\n\tthere are remaining qualifiers. Take into account `q' might have\n\tbeen cleared after re-qualification.\n\t* parse.y (patch_method_invocation): New local `resolved'.\n  \tSection dealing with qualified expression rewritten to use\n \tresolve_field_access.\n\nFrom-SVN: r32520", "tree": {"sha": "a6db90f19fb051b2ab1011fb4c34917227b6b8d9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a6db90f19fb051b2ab1011fb4c34917227b6b8d9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dde1da7265dd4e09df0b6d426f8297d19b890cb3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dde1da7265dd4e09df0b6d426f8297d19b890cb3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dde1da7265dd4e09df0b6d426f8297d19b890cb3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dde1da7265dd4e09df0b6d426f8297d19b890cb3/comments", "author": null, "committer": null, "parents": [{"sha": "168d3732aa67159489982b879ce29147ed94a4ac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/168d3732aa67159489982b879ce29147ed94a4ac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/168d3732aa67159489982b879ce29147ed94a4ac"}], "stats": {"total": 223, "additions": 67, "deletions": 156}, "files": [{"sha": "60624972d0f839bc50d77acf813f177656459c7d", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dde1da7265dd4e09df0b6d426f8297d19b890cb3/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dde1da7265dd4e09df0b6d426f8297d19b890cb3/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=dde1da7265dd4e09df0b6d426f8297d19b890cb3", "patch": "@@ -1,3 +1,14 @@\n+2000-03-13  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n+\n+\t* parse.y (resolve_package): Set `next' once a type name has been\n+\tprogressively discovered.\n+\t(resolve_qualified_expression_name): Propagate resolution only if\n+\tthere are remaining qualifiers. Take into account `q' might have\n+\tbeen cleared after re-qualification.\n+\t* parse.y (patch_method_invocation): New local `resolved'.\n+  \tSection dealing with qualified expression rewritten to use\n+ \tresolve_field_access.\n+\n Mon Mar 13 12:21:13 2000  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n \n \t* parse.h (PUSH_CPC): Fixed indentation."}, {"sha": "bb08b44f520be29f392bb474bef51e20646bb53d", "filename": "gcc/java/parse.c", "status": "modified", "additions": 28, "deletions": 78, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dde1da7265dd4e09df0b6d426f8297d19b890cb3/gcc%2Fjava%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dde1da7265dd4e09df0b6d426f8297d19b890cb3/gcc%2Fjava%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.c?ref=dde1da7265dd4e09df0b6d426f8297d19b890cb3", "patch": "@@ -9261,6 +9261,7 @@ resolve_package (pkg, next)\n \tif ((type_name = resolve_no_layout (acc, NULL_TREE)))\n \t  {\n \t    type_name = acc;\n+\t    *next = TREE_CHAIN (current);\n \t    break;\n \t  }\n       }\n@@ -11364,15 +11365,17 @@ resolve_qualified_expression_name (wfl, found_decl, where_found, type_found)\n \t      *type_found = type = TREE_TYPE (decl);\n \t      layout_class (type);\n \t      from_type = 1;\n-\t      /* Should be a list, really. FIXME */\n-\t      /* Fix them all the way down */\n \n-\t      list = TREE_CHAIN (q);\n-\t      while (list)\n+\t      /* Fix them all the way down, if any are left. */\n+\t      if (q)\n \t\t{\n-\t\t  RESOLVE_EXPRESSION_NAME_P (QUAL_WFL (list)) = 1;\n-\t\t  RESOLVE_PACKAGE_NAME_P (QUAL_WFL (list)) = 0;\n-\t\t  list = TREE_CHAIN (list);\n+\t\t  list = TREE_CHAIN (q);\n+\t\t  while (list)\n+\t\t    {\n+\t\t      RESOLVE_EXPRESSION_NAME_P (QUAL_WFL (list)) = 1;\n+\t\t      RESOLVE_PACKAGE_NAME_P (QUAL_WFL (list)) = 0;\n+\t\t      list = TREE_CHAIN (list);\n+\t\t    }\n \t\t}\n \t    }\n \t  else\n@@ -11585,6 +11588,10 @@ resolve_qualified_expression_name (wfl, found_decl, where_found, type_found)\n \t      return 1;\n \t    }\n \t}\n+      /* `q' might have changed due to a after package resolution\n+         re-qualification */\n+      if (!q)\n+\tbreak;\n     }\n   *found_decl = decl;\n   return 0;\n@@ -11762,7 +11769,7 @@ patch_method_invocation (patch, primary, where, is_static, ret_decl)\n   /* Resolution of qualified name, excluding constructors */\n   if (QUALIFIED_P (name) && !CALL_CONSTRUCTOR_P (patch))\n     {\n-      tree class_decl, identifier, identifier_wfl;\n+      tree identifier, identifier_wfl, type, resolved;\n       /* Extract the last IDENTIFIER of the qualified\n \t expression. This is a wfl and we will use it's location\n \t data during error report. */\n@@ -11772,45 +11779,20 @@ patch_method_invocation (patch, primary, where, is_static, ret_decl)\n       /* Given the context, IDENTIFIER is syntactically qualified\n \t as a MethodName. We need to qualify what's before */\n       qualify_ambiguous_name (wfl);\n+      resolved = resolve_field_access (wfl, NULL, NULL);\n \n-      /* Package resolution */\n-      if (RESOLVE_PACKAGE_NAME_P (wfl))\n-\t{\n-\t  tree next, decl, name = resolve_package (wfl, &next);\n-\t  \n-\t  if (!name)\n-\t    {\n-\t      tree remainder;\n-\t      breakdown_qualified (&remainder, NULL, EXPR_WFL_NODE (wfl));\n-\t      parse_error_context\n-\t\t(wfl, \"Can't search method `%s' in package `%s'\",\n-\t\t IDENTIFIER_POINTER (identifier),\n-\t\t IDENTIFIER_POINTER (remainder));\n-\t      PATCH_METHOD_RETURN_ERROR ();\n-\t    }\n-\t  RESOLVE_PACKAGE_NAME_P (wfl) = 0;\n-\t  if ((decl = resolve_no_layout (name, QUAL_WFL (next))))\n-\t    {\n-\t      QUAL_RESOLUTION (EXPR_WFL_QUALIFICATION (wfl)) = decl;\n-\t      RESOLVE_EXPRESSION_NAME_P (wfl) = 0;\n-\t      RESOLVE_TYPE_NAME_P (wfl) = 1;\n-\t    }\n-\t  else\n-\t    {\n-\t      RESOLVE_EXPRESSION_NAME_P (wfl) = 1;\n-\t      RESOLVE_TYPE_NAME_P (wfl) = 0;\n-\t    }\n-\t}\n+      if (resolved == error_mark_node)\n+\tPATCH_METHOD_RETURN_ERROR ();\n+\n+      type = GET_SKIP_TYPE (resolved);\n+      resolve_and_layout (type, NULL_TREE);\n+      list = lookup_method_invoke (0, identifier_wfl, type, identifier, args);\n+      args = nreverse (args);\n \n       /* We're resolving a call from a type */\n-      if (RESOLVE_TYPE_NAME_P (wfl))\n+      if (TREE_CODE (resolved) == TYPE_DECL)\n \t{\n-\t  tree decl = QUAL_RESOLUTION (EXPR_WFL_QUALIFICATION (wfl));\n-\t  tree name = DECL_NAME (decl);\n-\t  tree type;\n-\n-\t  class_decl = resolve_and_layout (name, wfl);\n-\t  if (CLASS_INTERFACE (decl))\n+\t  if (CLASS_INTERFACE (resolved))\n \t    {\n \t      parse_error_context\n \t\t(identifier_wfl,\n@@ -11819,10 +11801,6 @@ patch_method_invocation (patch, primary, where, is_static, ret_decl)\n \t\t IDENTIFIER_POINTER (name));\n \t      PATCH_METHOD_RETURN_ERROR ();\n \t    }\n-\t  /* Look the method up in the type selector. The method ought\n-             to be static. */\n-\t  type = TREE_TYPE (class_decl);\n-\t  list = lookup_method_invoke (0, wfl, type, identifier, args);\n \t  if (list && !METHOD_STATIC (list))\n \t    {\n \t      char *fct_name = xstrdup (lang_printable_name (list, 0));\n@@ -11834,38 +11812,10 @@ patch_method_invocation (patch, primary, where, is_static, ret_decl)\n \t      free (fct_name);\n \t      PATCH_METHOD_RETURN_ERROR ();\n \t    }\n-\t  args = nreverse (args);\n \t}\n-      /* We're resolving an expression name */\n       else\n-\t{\n-\t  tree field, type;\n-\t  \n-\t  /* 1- Find the field to which the call applies */\n-\t  field = resolve_field_access (wfl, NULL, &type);\n-\t  if (field == error_mark_node)\n-\t    PATCH_METHOD_RETURN_ERROR ();\n-\t  /* field is used in lieu of a primary. It alows us not to\n-\t   report errors on erroneous use of `this' in\n-\t   constructors. */\n-\t  primary = field;\t\n-\t  \n-\t  /* 2- Do the layout of the class where the last field\n-\t     was found, so we can search it. */\n-\t  class_decl = resolve_and_layout (type, NULL_TREE);\n-\t  if (class_decl != NULL_TREE)\n-\t  type = TREE_TYPE (class_decl);\n-\n-\t  /* 3- Retrieve a filtered list of method matches, Refine\n-\t     if necessary. In any cases, point out errors.  */\n-\t  list = lookup_method_invoke (0, identifier_wfl, type, \n-\t\t\t\t       identifier, args);\n-\n-\t  /* 4- Add the field as an argument */\n-\t  args = nreverse (args);\n-\t  this_arg = field;\n-\t}\n-\n+\tthis_arg = primary = resolved;\n+      \n       /* IDENTIFIER_WFL will be used to report any problem further */\n       wfl = identifier_wfl;\n     }\n@@ -12385,7 +12335,7 @@ find_applicable_accessible_methods_list (lc, class, name, arglist)\n     }\n \n   /* Search interfaces */\n-  if (CLASS_INTERFACE (TYPE_NAME (class)) \n+  if (CLASS_INTERFACE (TYPE_NAME (class))\n       || CLASS_ABSTRACT (TYPE_NAME (class)))\n     {\n       static tree searched_interfaces = NULL_TREE;"}, {"sha": "4ef7752c3cf6e33f140942e7459c0d275910be0a", "filename": "gcc/java/parse.y", "status": "modified", "additions": 28, "deletions": 78, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dde1da7265dd4e09df0b6d426f8297d19b890cb3/gcc%2Fjava%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dde1da7265dd4e09df0b6d426f8297d19b890cb3/gcc%2Fjava%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.y?ref=dde1da7265dd4e09df0b6d426f8297d19b890cb3", "patch": "@@ -6563,6 +6563,7 @@ resolve_package (pkg, next)\n \tif ((type_name = resolve_no_layout (acc, NULL_TREE)))\n \t  {\n \t    type_name = acc;\n+\t    *next = TREE_CHAIN (current);\n \t    break;\n \t  }\n       }\n@@ -8666,15 +8667,17 @@ resolve_qualified_expression_name (wfl, found_decl, where_found, type_found)\n \t      *type_found = type = TREE_TYPE (decl);\n \t      layout_class (type);\n \t      from_type = 1;\n-\t      /* Should be a list, really. FIXME */\n-\t      /* Fix them all the way down */\n \n-\t      list = TREE_CHAIN (q);\n-\t      while (list)\n+\t      /* Fix them all the way down, if any are left. */\n+\t      if (q)\n \t\t{\n-\t\t  RESOLVE_EXPRESSION_NAME_P (QUAL_WFL (list)) = 1;\n-\t\t  RESOLVE_PACKAGE_NAME_P (QUAL_WFL (list)) = 0;\n-\t\t  list = TREE_CHAIN (list);\n+\t\t  list = TREE_CHAIN (q);\n+\t\t  while (list)\n+\t\t    {\n+\t\t      RESOLVE_EXPRESSION_NAME_P (QUAL_WFL (list)) = 1;\n+\t\t      RESOLVE_PACKAGE_NAME_P (QUAL_WFL (list)) = 0;\n+\t\t      list = TREE_CHAIN (list);\n+\t\t    }\n \t\t}\n \t    }\n \t  else\n@@ -8887,6 +8890,10 @@ resolve_qualified_expression_name (wfl, found_decl, where_found, type_found)\n \t      return 1;\n \t    }\n \t}\n+      /* `q' might have changed due to a after package resolution\n+         re-qualification */\n+      if (!q)\n+\tbreak;\n     }\n   *found_decl = decl;\n   return 0;\n@@ -9064,7 +9071,7 @@ patch_method_invocation (patch, primary, where, is_static, ret_decl)\n   /* Resolution of qualified name, excluding constructors */\n   if (QUALIFIED_P (name) && !CALL_CONSTRUCTOR_P (patch))\n     {\n-      tree class_decl, identifier, identifier_wfl;\n+      tree identifier, identifier_wfl, type, resolved;\n       /* Extract the last IDENTIFIER of the qualified\n \t expression. This is a wfl and we will use it's location\n \t data during error report. */\n@@ -9074,45 +9081,20 @@ patch_method_invocation (patch, primary, where, is_static, ret_decl)\n       /* Given the context, IDENTIFIER is syntactically qualified\n \t as a MethodName. We need to qualify what's before */\n       qualify_ambiguous_name (wfl);\n+      resolved = resolve_field_access (wfl, NULL, NULL);\n \n-      /* Package resolution */\n-      if (RESOLVE_PACKAGE_NAME_P (wfl))\n-\t{\n-\t  tree next, decl, name = resolve_package (wfl, &next);\n-\t  \n-\t  if (!name)\n-\t    {\n-\t      tree remainder;\n-\t      breakdown_qualified (&remainder, NULL, EXPR_WFL_NODE (wfl));\n-\t      parse_error_context\n-\t\t(wfl, \"Can't search method `%s' in package `%s'\",\n-\t\t IDENTIFIER_POINTER (identifier),\n-\t\t IDENTIFIER_POINTER (remainder));\n-\t      PATCH_METHOD_RETURN_ERROR ();\n-\t    }\n-\t  RESOLVE_PACKAGE_NAME_P (wfl) = 0;\n-\t  if ((decl = resolve_no_layout (name, QUAL_WFL (next))))\n-\t    {\n-\t      QUAL_RESOLUTION (EXPR_WFL_QUALIFICATION (wfl)) = decl;\n-\t      RESOLVE_EXPRESSION_NAME_P (wfl) = 0;\n-\t      RESOLVE_TYPE_NAME_P (wfl) = 1;\n-\t    }\n-\t  else\n-\t    {\n-\t      RESOLVE_EXPRESSION_NAME_P (wfl) = 1;\n-\t      RESOLVE_TYPE_NAME_P (wfl) = 0;\n-\t    }\n-\t}\n+      if (resolved == error_mark_node)\n+\tPATCH_METHOD_RETURN_ERROR ();\n+\n+      type = GET_SKIP_TYPE (resolved);\n+      resolve_and_layout (type, NULL_TREE);\n+      list = lookup_method_invoke (0, identifier_wfl, type, identifier, args);\n+      args = nreverse (args);\n \n       /* We're resolving a call from a type */\n-      if (RESOLVE_TYPE_NAME_P (wfl))\n+      if (TREE_CODE (resolved) == TYPE_DECL)\n \t{\n-\t  tree decl = QUAL_RESOLUTION (EXPR_WFL_QUALIFICATION (wfl));\n-\t  tree name = DECL_NAME (decl);\n-\t  tree type;\n-\n-\t  class_decl = resolve_and_layout (name, wfl);\n-\t  if (CLASS_INTERFACE (decl))\n+\t  if (CLASS_INTERFACE (resolved))\n \t    {\n \t      parse_error_context\n \t\t(identifier_wfl,\n@@ -9121,10 +9103,6 @@ patch_method_invocation (patch, primary, where, is_static, ret_decl)\n \t\t IDENTIFIER_POINTER (name));\n \t      PATCH_METHOD_RETURN_ERROR ();\n \t    }\n-\t  /* Look the method up in the type selector. The method ought\n-             to be static. */\n-\t  type = TREE_TYPE (class_decl);\n-\t  list = lookup_method_invoke (0, wfl, type, identifier, args);\n \t  if (list && !METHOD_STATIC (list))\n \t    {\n \t      char *fct_name = xstrdup (lang_printable_name (list, 0));\n@@ -9136,38 +9114,10 @@ patch_method_invocation (patch, primary, where, is_static, ret_decl)\n \t      free (fct_name);\n \t      PATCH_METHOD_RETURN_ERROR ();\n \t    }\n-\t  args = nreverse (args);\n \t}\n-      /* We're resolving an expression name */\n       else\n-\t{\n-\t  tree field, type;\n-\t  \n-\t  /* 1- Find the field to which the call applies */\n-\t  field = resolve_field_access (wfl, NULL, &type);\n-\t  if (field == error_mark_node)\n-\t    PATCH_METHOD_RETURN_ERROR ();\n-\t  /* field is used in lieu of a primary. It alows us not to\n-\t   report errors on erroneous use of `this' in\n-\t   constructors. */\n-\t  primary = field;\t\n-\t  \n-\t  /* 2- Do the layout of the class where the last field\n-\t     was found, so we can search it. */\n-\t  class_decl = resolve_and_layout (type, NULL_TREE);\n-\t  if (class_decl != NULL_TREE)\n-\t  type = TREE_TYPE (class_decl);\n-\n-\t  /* 3- Retrieve a filtered list of method matches, Refine\n-\t     if necessary. In any cases, point out errors.  */\n-\t  list = lookup_method_invoke (0, identifier_wfl, type, \n-\t\t\t\t       identifier, args);\n-\n-\t  /* 4- Add the field as an argument */\n-\t  args = nreverse (args);\n-\t  this_arg = field;\n-\t}\n-\n+\tthis_arg = primary = resolved;\n+      \n       /* IDENTIFIER_WFL will be used to report any problem further */\n       wfl = identifier_wfl;\n     }\n@@ -9687,7 +9637,7 @@ find_applicable_accessible_methods_list (lc, class, name, arglist)\n     }\n \n   /* Search interfaces */\n-  if (CLASS_INTERFACE (TYPE_NAME (class)) \n+  if (CLASS_INTERFACE (TYPE_NAME (class))\n       || CLASS_ABSTRACT (TYPE_NAME (class)))\n     {\n       static tree searched_interfaces = NULL_TREE;"}]}