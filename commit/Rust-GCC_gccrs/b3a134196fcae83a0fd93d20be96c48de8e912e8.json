{"sha": "b3a134196fcae83a0fd93d20be96c48de8e912e8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjNhMTM0MTk2ZmNhZTgzYTBmZDkzZDIwYmU5NmM0OGRlOGU5MTJlOA==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "iant@google.com", "date": "2007-07-10T17:23:11Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2007-07-10T17:23:11Z"}, "message": "Replace no_new_pseudos in backends.\n\n\t* rtl.h (can_create_pseudo_p): Define.\n\t* config/darwin.c (machopic_indirect_data_reference): Use\n\tcan_create_pseudo_p () instead of no_new_pseudos.\n\t(machopic_indirect_data_reference): Likewise.\n\t(machopic_legitimize_pic_address): Likewise.\n\t* config/alpha/alpha.c (alpha_legitimize_address): Likewise.\n\t(alpha_emit_set_const_1): Likewise.\n\t(alpha_emit_set_const): Likewise.\n\t(alpha_emit_conditional_move): Likewise.\n\t(alpha_split_conditional_move): Likewise.\n\t* config/alpha/alpha.md (various splitters): Likewise.\n\t(movti): Likewise.\n\t* config/arm/arm.c (legitimize_pic_address): Likewise.\n\t(arm_load_pic_register): Likewise.\n\t* config/arm/arm.md (addsi3, subsi3, andsi3, iorsi3): Likewise.\n\t(movdi, movsi, movhi, movqi, movsf, movdf): Likewise.\n\t* config/bfin/bfin.c (legitimize_pic_address): Likewise.\n\t* config/cris/cris.c (cris_expand_pic_call_address): Likewise.\n\t* config/cris/cris.md (movsi): Likewise.\n\t* config/frv/frv.md (symGOT2reg_hilo): Likewise.\n\t(symGOTOFF2reg_hilo): Likewise.\n\t(symGPREL2reg, symGPREL2reg_hilo): Likewise.\n\t* config/h8300/h8300.md (insv, extzv): Likewise.\n\t* config/i386/i386.c (ix86_expand_move): Likewise.\n\t(ix86_expand_vector_move): Likewise.\n\t(ix86_prepare_fp_compare_args): Likewise.\n\t(ix86_expand_carry_flag_compare): Likewise.\n\t* config/i386/i386.md (tls_dynamic_gnu2_32): Likewise.\n\t(tls_dynamic_gnu2_combine_32): Likewise.\n\t(tls_dynamic_gnu2_64, tls_dynamic_gnu2_combine_64): Likewise.\n\t* config/ia64/ia64.c (ia64_expand_move): Likewise.\n\t(ia64_expand_movxf_movrf): Likewise.\n\t* config/m32c/m32c.c (m32c_prepare_move): Likewise.\n\t(m32c_split_move): Likewise.\n\t(m32c_expand_insv): Likewise.\n\t* config/m68k/m68k.md (movsi): Likewise.\n\t* config/mips/mips.c (mips_force_temporary): Likewise.\n\t(mips_split_symbol): Likewise.\n\t(mips_move_integer): Likewise.\n\t(mips_legitimize_const_move): Likewise.\n\t* config/mn10300/mn10300.md (movsi): Likewise.\n\t* config/pa/pa.c (emit_move_sequence): Likewise.\n\t* config/rs6000/rs6000.c (rs6000_emit_move): Likewise.\n\t(rs6000_got_register): Likewise.\n\t(create_TOC_reference): Likewise.\n\t(rs6000_machopic_legitimize_pic_address): Likewise.\n\t* config/rs6000/rs6000.md (add<mode>3): Likewise.\n\t(various splitters): Likewise.\n\t(iorsi3, xorsi3, iordi3, xordi3): Likewise.\n\t(movsi_got): Likewise.\n\t* config/s390/s390.c (emit_symbolic_move): Likewise.\n\t* config/s390/s390.md (movhi, movqi): Likewise.\n\t(load_multiple, store_multiple): Likewise.\n\t* config/score/score.c (score_force_temporary): Likewise.\n\t* config/sh/sh.c (prepare_move_operands): Likewise.\n\t(prepare_cbranch_operands): Likewise.\n\t(emit_fpu_switch): Likewise.\n\t(fpscr_set_from_mem): Likewise.\n\t* config/sh/sh.md (movdicc, movsicc, movsicc_umin): Likewise.\n\t(adddi3, subsi3): Likewise.\n\t(various splitters): Likewise.\n\t(divsi_inv_fp_combine): Likewise.\n\t(symGOT_load, symGOTOFF2reg, symDTPOFF2reg): Likewise.\n\t(seq, slt, sle, sgt, sge, sgtu, sltu, sleu, sgeu): Likewise.\n\t(sne): Likewise.\n\t* config/sh/predicates.md (xor_operand): Likewise.\n\t* config/sparc/sparc.c (legitimize_tls_address): Likewise.\n\t* config/sparc/sparc.md (movsi_pic_label_ref): Likewise.\n\t(movdi_pic_label_ref): Likewise.\n\t* config/spu/spu.c (spu_split_immediate): Likewise.\n\t* config/alpha/alpha.md (various splitters): Remove test\n\t!no_new_pseudos || reload_completed.\n\t* config/ia64/ia64.c (ia64_output_mi_thunk): Don't set\n\tno_new_pseudos.\n\t* config/m68k/m68k.c (m68k_output_mi_thunk): Likewise.\n\t* config/mips/mips.c (mips_output_mi_thunk): Likewise.\n\t* config/rs6000/rs6000.c (rs6000_output_mi_thunk): Likewise.\n\t* config/score/score.c (th_output_mi_thunk): Likewise.\n\t* config/sh/sh.c (sh_output_mi_thunk): Likewise.\n\t* config/sparc/sparc.c (sparc_output_mi_thunk): Likewise.\n\nFrom-SVN: r126517", "tree": {"sha": "31100e2e7608a79ac2a8e5d86ab237f0dd42b6fe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/31100e2e7608a79ac2a8e5d86ab237f0dd42b6fe"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b3a134196fcae83a0fd93d20be96c48de8e912e8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b3a134196fcae83a0fd93d20be96c48de8e912e8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b3a134196fcae83a0fd93d20be96c48de8e912e8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b3a134196fcae83a0fd93d20be96c48de8e912e8/comments", "author": null, "committer": null, "parents": [{"sha": "b2a95bc9b3f3454fc6bd49e6c5824b03f6fbec2b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b2a95bc9b3f3454fc6bd49e6c5824b03f6fbec2b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b2a95bc9b3f3454fc6bd49e6c5824b03f6fbec2b"}], "stats": {"total": 504, "additions": 310, "deletions": 194}, "files": [{"sha": "712de85e6dbf5cbaed1345f5613fd0c1501d6e49", "filename": "gcc/ChangeLog", "status": "modified", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3a134196fcae83a0fd93d20be96c48de8e912e8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3a134196fcae83a0fd93d20be96c48de8e912e8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b3a134196fcae83a0fd93d20be96c48de8e912e8", "patch": "@@ -1,3 +1,87 @@\n+2007-07-10  Ian Lance Taylor  <iant@google.com>\n+\n+\tReplace no_new_pseudos in backends.\n+\t* rtl.h (can_create_pseudo_p): Define.\n+\t* config/darwin.c (machopic_indirect_data_reference): Use\n+\tcan_create_pseudo_p () instead of no_new_pseudos.\n+\t(machopic_indirect_data_reference): Likewise.\n+\t(machopic_legitimize_pic_address): Likewise.\n+\t* config/alpha/alpha.c (alpha_legitimize_address): Likewise.\n+\t(alpha_emit_set_const_1): Likewise.\n+\t(alpha_emit_set_const): Likewise.\n+\t(alpha_emit_conditional_move): Likewise.\n+\t(alpha_split_conditional_move): Likewise.\n+\t* config/alpha/alpha.md (various splitters): Likewise.\n+\t(movti): Likewise.\n+\t* config/arm/arm.c (legitimize_pic_address): Likewise.\n+\t(arm_load_pic_register): Likewise.\n+\t* config/arm/arm.md (addsi3, subsi3, andsi3, iorsi3): Likewise.\n+\t(movdi, movsi, movhi, movqi, movsf, movdf): Likewise.\n+\t* config/bfin/bfin.c (legitimize_pic_address): Likewise.\n+\t* config/cris/cris.c (cris_expand_pic_call_address): Likewise.\n+\t* config/cris/cris.md (movsi): Likewise.\n+\t* config/frv/frv.md (symGOT2reg_hilo): Likewise.\n+\t(symGOTOFF2reg_hilo): Likewise.\n+\t(symGPREL2reg, symGPREL2reg_hilo): Likewise.\n+\t* config/h8300/h8300.md (insv, extzv): Likewise.\n+\t* config/i386/i386.c (ix86_expand_move): Likewise.\n+\t(ix86_expand_vector_move): Likewise.\n+\t(ix86_prepare_fp_compare_args): Likewise.\n+\t(ix86_expand_carry_flag_compare): Likewise.\n+\t* config/i386/i386.md (tls_dynamic_gnu2_32): Likewise.\n+\t(tls_dynamic_gnu2_combine_32): Likewise.\n+\t(tls_dynamic_gnu2_64, tls_dynamic_gnu2_combine_64): Likewise.\n+\t* config/ia64/ia64.c (ia64_expand_move): Likewise.\n+\t(ia64_expand_movxf_movrf): Likewise.\n+\t* config/m32c/m32c.c (m32c_prepare_move): Likewise.\n+\t(m32c_split_move): Likewise.\n+\t(m32c_expand_insv): Likewise.\n+\t* config/m68k/m68k.md (movsi): Likewise.\n+\t* config/mips/mips.c (mips_force_temporary): Likewise.\n+\t(mips_split_symbol): Likewise.\n+\t(mips_move_integer): Likewise.\n+\t(mips_legitimize_const_move): Likewise.\n+\t* config/mn10300/mn10300.md (movsi): Likewise.\n+\t* config/pa/pa.c (emit_move_sequence): Likewise.\n+\t* config/rs6000/rs6000.c (rs6000_emit_move): Likewise.\n+\t(rs6000_got_register): Likewise.\n+\t(create_TOC_reference): Likewise.\n+\t(rs6000_machopic_legitimize_pic_address): Likewise.\n+\t* config/rs6000/rs6000.md (add<mode>3): Likewise.\n+\t(various splitters): Likewise.\n+\t(iorsi3, xorsi3, iordi3, xordi3): Likewise.\n+\t(movsi_got): Likewise.\n+\t* config/s390/s390.c (emit_symbolic_move): Likewise.\n+\t* config/s390/s390.md (movhi, movqi): Likewise.\n+\t(load_multiple, store_multiple): Likewise.\n+\t* config/score/score.c (score_force_temporary): Likewise.\n+\t* config/sh/sh.c (prepare_move_operands): Likewise.\n+\t(prepare_cbranch_operands): Likewise.\n+\t(emit_fpu_switch): Likewise.\n+\t(fpscr_set_from_mem): Likewise.\n+\t* config/sh/sh.md (movdicc, movsicc, movsicc_umin): Likewise.\n+\t(adddi3, subsi3): Likewise.\n+\t(various splitters): Likewise.\n+\t(divsi_inv_fp_combine): Likewise.\n+\t(symGOT_load, symGOTOFF2reg, symDTPOFF2reg): Likewise.\n+\t(seq, slt, sle, sgt, sge, sgtu, sltu, sleu, sgeu): Likewise.\n+\t(sne): Likewise.\n+\t* config/sh/predicates.md (xor_operand): Likewise.\n+\t* config/sparc/sparc.c (legitimize_tls_address): Likewise.\n+\t* config/sparc/sparc.md (movsi_pic_label_ref): Likewise.\n+\t(movdi_pic_label_ref): Likewise.\n+\t* config/spu/spu.c (spu_split_immediate): Likewise.\n+\t* config/alpha/alpha.md (various splitters): Remove test\n+\t!no_new_pseudos || reload_completed.\n+\t* config/ia64/ia64.c (ia64_output_mi_thunk): Don't set\n+\tno_new_pseudos.\n+\t* config/m68k/m68k.c (m68k_output_mi_thunk): Likewise.\n+\t* config/mips/mips.c (mips_output_mi_thunk): Likewise.\n+\t* config/rs6000/rs6000.c (rs6000_output_mi_thunk): Likewise.\n+\t* config/score/score.c (th_output_mi_thunk): Likewise.\n+\t* config/sh/sh.c (sh_output_mi_thunk): Likewise.\n+\t* config/sparc/sparc.c (sparc_output_mi_thunk): Likewise.\n+\n 2007-07-10  Kaz Kojima  <kkojima@gcc.gnu.org>\n \n \tPR rtl-optimization/32664"}, {"sha": "c50055f33df15b48e1c0d9cabf9bdb3e4d89587e", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3a134196fcae83a0fd93d20be96c48de8e912e8/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3a134196fcae83a0fd93d20be96c48de8e912e8/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=b3a134196fcae83a0fd93d20be96c48de8e912e8", "patch": "@@ -933,7 +933,7 @@ alpha_legitimize_address (rtx x, rtx scratch,\n      part of the CONST_INT.  Then load FOO plus any high-order part of the\n      CONST_INT into a register.  Our address is (plus reg low-part-const).\n      This is done to reduce the number of GOT entries.  */\n-  if (!no_new_pseudos\n+  if (can_create_pseudo_p ()\n       && GET_CODE (x) == CONST\n       && GET_CODE (XEXP (x, 0)) == PLUS\n       && GET_CODE (XEXP (XEXP (x, 0), 1)) == CONST_INT)\n@@ -946,7 +946,7 @@ alpha_legitimize_address (rtx x, rtx scratch,\n   /* If we have a (plus reg const), emit the load as in (2), then add\n      the two registers, and finally generate (plus reg low-part-const) as\n      our address.  */\n-  if (!no_new_pseudos\n+  if (can_create_pseudo_p ()\n       && GET_CODE (x) == PLUS\n       && GET_CODE (XEXP (x, 0)) == REG\n       && GET_CODE (XEXP (x, 1)) == CONST\n@@ -1069,7 +1069,7 @@ alpha_legitimize_address (rtx x, rtx scratch,\n \t    return x;\n \t  else\n \t    {\n-\t      if (!no_new_pseudos)\n+\t      if (can_create_pseudo_p ())\n \t        scratch = gen_reg_rtx (Pmode);\n \t      emit_insn (gen_rtx_SET (VOIDmode, scratch,\n \t\t\t\t      gen_rtx_HIGH (Pmode, x)));\n@@ -1091,11 +1091,11 @@ alpha_legitimize_address (rtx x, rtx scratch,\n \n     if (addend)\n       x = expand_simple_binop (Pmode, PLUS, x, GEN_INT (addend),\n-\t\t\t       (no_new_pseudos ? scratch : NULL_RTX),\n+\t\t\t       (!can_create_pseudo_p () ? scratch : NULL_RTX),\n \t\t\t       1, OPTAB_LIB_WIDEN);\n     if (high)\n       x = expand_simple_binop (Pmode, PLUS, x, GEN_INT (high),\n-\t\t\t       (no_new_pseudos ? scratch : NULL_RTX),\n+\t\t\t       (!can_create_pseudo_p () ? scratch : NULL_RTX),\n \t\t\t       1, OPTAB_LIB_WIDEN);\n \n     return plus_constant (x, low);\n@@ -1644,7 +1644,7 @@ alpha_emit_set_const_1 (rtx target, enum machine_mode mode,\n   int i, bits;\n   /* Use a pseudo if highly optimizing and still generating RTL.  */\n   rtx subtarget\n-    = (flag_expensive_optimizations && !no_new_pseudos ? 0 : target);\n+    = (flag_expensive_optimizations && can_create_pseudo_p () ? 0 : target);\n   rtx temp, insn;\n \n   /* If this is a sign-extended 32-bit constant, we can do this in at most\n@@ -1688,7 +1688,7 @@ alpha_emit_set_const_1 (rtx target, enum machine_mode mode,\n \t{\n \t  if (no_output)\n \t    return pc_rtx;\n-\t  if (no_new_pseudos)\n+\t  if (!can_create_pseudo_p ())\n \t    {\n \t      emit_insn (gen_rtx_SET (VOIDmode, target, GEN_INT (high << 16)));\n \t      temp = target;\n@@ -1727,7 +1727,7 @@ alpha_emit_set_const_1 (rtx target, enum machine_mode mode,\n      we can't make pseudos, we can't do anything since the expand_binop\n      and expand_unop calls will widen and try to make pseudos.  */\n \n-  if (n == 1 || (mode == SImode && no_new_pseudos))\n+  if (n == 1 || (mode == SImode && !can_create_pseudo_p ()))\n     return 0;\n \n   /* Next, see if we can load a related constant and then shift and possibly\n@@ -1895,7 +1895,7 @@ alpha_emit_set_const (rtx target, enum machine_mode mode,\n \n   /* If we can't make any pseudos, TARGET is an SImode hard register, we\n      can't load this constant in one insn, do this in DImode.  */\n-  if (no_new_pseudos && mode == SImode\n+  if (!can_create_pseudo_p () && mode == SImode\n       && GET_CODE (target) == REG && REGNO (target) < FIRST_PSEUDO_REGISTER)\n     {\n       result = alpha_emit_set_const_1 (target, mode, c, 1, no_output);\n@@ -2700,7 +2700,7 @@ alpha_emit_conditional_move (rtx cmp, enum machine_mode mode)\n      conditional move.  Make sure we emit only comparisons we have;\n      swap or reverse as necessary.  */\n \n-  if (no_new_pseudos)\n+  if (!can_create_pseudo_p ())\n     return NULL_RTX;\n \n   switch (code)\n@@ -2777,7 +2777,7 @@ alpha_split_conditional_move (enum rtx_code code, rtx dest, rtx cond,\n   if (mode != DImode)\n     {\n       target = gen_lowpart (DImode, dest);\n-      if (! no_new_pseudos)\n+      if (can_create_pseudo_p ())\n         subtarget = gen_reg_rtx (DImode);\n       else\n \tsubtarget = target;"}, {"sha": "55caeb9be9a1fc5e7907262dc78ddffaec0caf30", "filename": "gcc/config/alpha/alpha.md", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3a134196fcae83a0fd93d20be96c48de8e912e8/gcc%2Fconfig%2Falpha%2Falpha.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3a134196fcae83a0fd93d20be96c48de8e912e8/gcc%2Fconfig%2Falpha%2Falpha.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.md?ref=b3a134196fcae83a0fd93d20be96c48de8e912e8", "patch": "@@ -506,7 +506,7 @@\n   operands[4] = GEN_INT (low);\n   if (satisfies_constraint_L (rest_rtx))\n     operands[3] = rest_rtx;\n-  else if (! no_new_pseudos)\n+  else if (can_create_pseudo_p ())\n     {\n       operands[3] = gen_reg_rtx (DImode);\n       emit_move_insn (operands[3], operands[2]);\n@@ -4370,14 +4370,14 @@\n    (clobber (match_scratch:DI 5 \"=r\"))]\n   \"\"\n   \"#\"\n-  \"! no_new_pseudos || reload_completed\"\n+  \"\"\n   [(set (match_dup 5)\n \t(match_op_dup:DI 1 [(match_dup 2) (const_int 0)]))\n    (set (match_dup 0)\n \t(plus:DI (mult:DI (match_dup 5) (match_dup 3))\n \t\t (match_dup 4)))]\n {\n-  if (! no_new_pseudos)\n+  if (can_create_pseudo_p ())\n     operands[5] = gen_reg_rtx (DImode);\n   else if (reg_overlap_mentioned_p (operands[5], operands[4]))\n     operands[5] = operands[0];\n@@ -4395,14 +4395,14 @@\n    (clobber (match_scratch:SI 5 \"=r\"))]\n   \"\"\n   \"#\"\n-  \"! no_new_pseudos || reload_completed\"\n+  \"\"\n   [(set (match_dup 5)\n \t(match_op_dup:SI 1 [(match_dup 2) (const_int 0)]))\n    (set (match_dup 0)\n \t(plus:SI (mult:SI (match_dup 5) (match_dup 3))\n \t\t (match_dup 4)))]\n {\n-  if (! no_new_pseudos)\n+  if (can_create_pseudo_p ())\n     operands[5] = gen_reg_rtx (DImode);\n   else if (reg_overlap_mentioned_p (operands[5], operands[4]))\n     operands[5] = operands[0];\n@@ -4421,14 +4421,14 @@\n    (clobber (match_scratch:SI 5 \"=r\"))]\n   \"\"\n   \"#\"\n-  \"! no_new_pseudos || reload_completed\"\n+  \"\"\n   [(set (match_dup 5)\n \t(match_op_dup:SI 1 [(match_dup 2) (const_int 0)]))\n    (set (match_dup 0)\n \t(sign_extend:DI (plus:SI (mult:SI (match_dup 5) (match_dup 3))\n \t\t\t\t (match_dup 4))))]\n {\n-  if (! no_new_pseudos)\n+  if (can_create_pseudo_p ())\n     operands[5] = gen_reg_rtx (DImode);\n   else if (reg_overlap_mentioned_p (operands[5], operands[4]))\n     operands[5] = operands[0];\n@@ -4446,14 +4446,14 @@\n    (clobber (match_scratch:DI 5 \"=r\"))]\n   \"\"\n   \"#\"\n-  \"! no_new_pseudos || reload_completed\"\n+  \"\"\n   [(set (match_dup 5)\n \t(match_op_dup:DI 1 [(match_dup 2) (const_int 0)]))\n    (set (match_dup 0)\n \t(minus:DI (mult:DI (match_dup 5) (match_dup 3))\n \t\t  (match_dup 4)))]\n {\n-  if (! no_new_pseudos)\n+  if (can_create_pseudo_p ())\n     operands[5] = gen_reg_rtx (DImode);\n   else if (reg_overlap_mentioned_p (operands[5], operands[4]))\n     operands[5] = operands[0];\n@@ -4471,14 +4471,14 @@\n    (clobber (match_scratch:SI 5 \"=r\"))]\n   \"\"\n   \"#\"\n-  \"! no_new_pseudos || reload_completed\"\n+  \"\"\n   [(set (match_dup 5)\n \t(match_op_dup:SI 1 [(match_dup 2) (const_int 0)]))\n    (set (match_dup 0)\n \t(minus:SI (mult:SI (match_dup 5) (match_dup 3))\n \t\t (match_dup 4)))]\n {\n-  if (! no_new_pseudos)\n+  if (can_create_pseudo_p ())\n     operands[5] = gen_reg_rtx (DImode);\n   else if (reg_overlap_mentioned_p (operands[5], operands[4]))\n     operands[5] = operands[0];\n@@ -4497,14 +4497,14 @@\n    (clobber (match_scratch:SI 5 \"=r\"))]\n   \"\"\n   \"#\"\n-  \"! no_new_pseudos || reload_completed\"\n+  \"\"\n   [(set (match_dup 5)\n \t(match_op_dup:SI 1 [(match_dup 2) (const_int 0)]))\n    (set (match_dup 0)\n \t(sign_extend:DI (minus:SI (mult:SI (match_dup 5) (match_dup 3))\n \t\t\t\t  (match_dup 4))))]\n {\n-  if (! no_new_pseudos)\n+  if (can_create_pseudo_p ())\n     operands[5] = gen_reg_rtx (DImode);\n   else if (reg_overlap_mentioned_p (operands[5], operands[4]))\n     operands[5] = operands[0];\n@@ -5760,7 +5760,7 @@\n     {\n       rtx in[2], out[2], target;\n \n-      gcc_assert (!no_new_pseudos);\n+      gcc_assert (can_create_pseudo_p ());\n \n       split_double (operands[1], &in[0], &in[1]);\n "}, {"sha": "6e9937102277b4b6c771a01e9dce2fa564e7d112", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3a134196fcae83a0fd93d20be96c48de8e912e8/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3a134196fcae83a0fd93d20be96c48de8e912e8/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=b3a134196fcae83a0fd93d20be96c48de8e912e8", "patch": "@@ -3387,7 +3387,7 @@ require_pic_register (void)\n      start the real expansion process.  */\n   if (!current_function_uses_pic_offset_table)\n     {\n-      gcc_assert (!no_new_pseudos);\n+      gcc_assert (can_create_pseudo_p ());\n       if (arm_pic_register != INVALID_REGNUM)\n \t{\n \t  cfun->machine->pic_reg = gen_rtx_REG (Pmode, arm_pic_register);\n@@ -3439,7 +3439,7 @@ legitimize_pic_address (rtx orig, enum machine_mode mode, rtx reg)\n \n       if (reg == 0)\n \t{\n-\t  gcc_assert (!no_new_pseudos);\n+\t  gcc_assert (can_create_pseudo_p ());\n \t  reg = gen_reg_rtx (Pmode);\n \n \t  subregs = 1;\n@@ -3503,7 +3503,7 @@ legitimize_pic_address (rtx orig, enum machine_mode mode, rtx reg)\n \n       if (reg == 0)\n \t{\n-\t  gcc_assert (!no_new_pseudos);\n+\t  gcc_assert (can_create_pseudo_p ());\n \t  reg = gen_reg_rtx (Pmode);\n \t}\n \n@@ -3519,7 +3519,7 @@ legitimize_pic_address (rtx orig, enum machine_mode mode, rtx reg)\n \t     test the index for the appropriate mode.  */\n \t  if (!arm_legitimate_index_p (mode, offset, SET, 0))\n \t    {\n-\t      gcc_assert (!no_new_pseudos);\n+\t      gcc_assert (can_create_pseudo_p ());\n \t      offset = force_reg (Pmode, offset);\n \t    }\n \n@@ -3673,7 +3673,7 @@ arm_load_pic_register (unsigned long saved_regs ATTRIBUTE_UNUSED)\n \t    }\n \t  else\n \t    {\n-\t      gcc_assert (!no_new_pseudos);\n+\t      gcc_assert (can_create_pseudo_p ());\n \t      pic_tmp = gen_reg_rtx (Pmode);\n \t    }\n "}, {"sha": "3a90b0a110c9d167c8a3f52518658221277002b0", "filename": "gcc/config/arm/arm.md", "status": "modified", "additions": 19, "deletions": 16, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3a134196fcae83a0fd93d20be96c48de8e912e8/gcc%2Fconfig%2Farm%2Farm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3a134196fcae83a0fd93d20be96c48de8e912e8/gcc%2Fconfig%2Farm%2Farm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.md?ref=b3a134196fcae83a0fd93d20be96c48de8e912e8", "patch": "@@ -490,7 +490,7 @@\n     {\n       arm_split_constant (PLUS, SImode, NULL_RTX,\n \t                  INTVAL (operands[2]), operands[0], operands[1],\n-\t\t\t  optimize && !no_new_pseudos);\n+\t\t\t  optimize && can_create_pseudo_p ());\n       DONE;\n     }\n   \"\n@@ -967,7 +967,7 @@\n         {\n           arm_split_constant (MINUS, SImode, NULL_RTX,\n \t                      INTVAL (operands[1]), operands[0],\n-\t  \t\t      operands[2], optimize && !no_new_pseudos);\n+\t  \t\t      operands[2], optimize && can_create_pseudo_p ());\n           DONE;\n \t}\n       else /* TARGET_THUMB1 */\n@@ -1737,7 +1737,7 @@\n         {\n           arm_split_constant (AND, SImode, NULL_RTX,\n \t                      INTVAL (operands[2]), operands[0],\n-\t\t\t      operands[1], optimize && !no_new_pseudos);\n+\t\t\t      operands[1], optimize && can_create_pseudo_p ());\n \n           DONE;\n         }\n@@ -2398,7 +2398,7 @@\n         {\n           arm_split_constant (IOR, SImode, NULL_RTX,\n \t                      INTVAL (operands[2]), operands[0], operands[1],\n-\t\t\t      optimize && !no_new_pseudos);\n+\t\t\t      optimize && can_create_pseudo_p ());\n           DONE;\n \t}\n       else /* TARGET_THUMB1 */\n@@ -4473,7 +4473,7 @@\n \t(match_operand:DI 1 \"general_operand\" \"\"))]\n   \"TARGET_EITHER\"\n   \"\n-  if (!no_new_pseudos)\n+  if (can_create_pseudo_p ())\n     {\n       if (GET_CODE (operands[0]) != REG)\n \toperands[1] = force_reg (DImode, operands[1]);\n@@ -4661,13 +4661,13 @@\n         {\n            arm_split_constant (SET, SImode, NULL_RTX,\n \t                       INTVAL (operands[1]), operands[0], NULL_RTX,\n-\t\t\t       optimize && !no_new_pseudos);\n+\t\t\t       optimize && can_create_pseudo_p ());\n           DONE;\n         }\n     }\n   else /* TARGET_THUMB1...  */\n     {\n-      if (!no_new_pseudos)\n+      if (can_create_pseudo_p ())\n         {\n           if (GET_CODE (operands[0]) != REG)\n \t    operands[1] = force_reg (SImode, operands[1]);\n@@ -4690,7 +4690,8 @@\n       gcc_assert (GET_CODE (tmp) == SYMBOL_REF);\n       gcc_assert (SYMBOL_REF_TLS_MODEL (tmp) != 0);\n \n-      tmp = legitimize_tls_address (tmp, no_new_pseudos ? operands[0] : 0);\n+      tmp = legitimize_tls_address (tmp,\n+\t\t\t\t    !can_create_pseudo_p () ? operands[0] : 0);\n       if (addend)\n         {\n           tmp = gen_rtx_PLUS (SImode, tmp, addend);\n@@ -4703,7 +4704,9 @@\n \t       || symbol_mentioned_p (operands[1])\n \t       || label_mentioned_p (operands[1])))\n       operands[1] = legitimize_pic_address (operands[1], SImode,\n-\t\t\t\t\t    (no_new_pseudos ? operands[0] : 0));\n+\t\t\t\t\t    (!can_create_pseudo_p ()\n+\t\t\t\t\t     ? operands[0]\n+\t\t\t\t\t     : 0));\n   \"\n )\n \n@@ -5086,7 +5089,7 @@\n   \"\n   if (TARGET_ARM)\n     {\n-      if (!no_new_pseudos)\n+      if (can_create_pseudo_p ())\n         {\n           if (GET_CODE (operands[0]) == MEM)\n \t    {\n@@ -5130,7 +5133,7 @@\n \t      emit_insn (gen_movsi (reg, GEN_INT (val)));\n \t      operands[1] = gen_lowpart (HImode, reg);\n \t    }\n-\t  else if (arm_arch4 && optimize && !no_new_pseudos\n+\t  else if (arm_arch4 && optimize && can_create_pseudo_p ()\n \t\t   && GET_CODE (operands[1]) == MEM)\n \t    {\n \t      rtx reg = gen_reg_rtx (SImode);\n@@ -5193,7 +5196,7 @@\n   else if (TARGET_THUMB2)\n     {\n       /* Thumb-2 can do everything except mem=mem and mem=const easily.  */\n-      if (!no_new_pseudos)\n+      if (can_create_pseudo_p ())\n \t{\n \t  if (GET_CODE (operands[0]) != REG)\n \t    operands[1] = force_reg (HImode, operands[1]);\n@@ -5210,7 +5213,7 @@\n     }\n   else /* TARGET_THUMB1 */\n     {\n-      if (!no_new_pseudos)\n+      if (can_create_pseudo_p ())\n         {\n \t  if (GET_CODE (operands[1]) == CONST_INT)\n \t    {\n@@ -5440,7 +5443,7 @@\n   \"\n   /* Everything except mem = const or mem = mem can be done easily */\n \n-  if (!no_new_pseudos)\n+  if (can_create_pseudo_p ())\n     {\n       if (GET_CODE (operands[1]) == CONST_INT)\n \t{\n@@ -5548,7 +5551,7 @@\n     }\n   else /* TARGET_THUMB1 */\n     {\n-      if (!no_new_pseudos)\n+      if (can_create_pseudo_p ())\n         {\n            if (GET_CODE (operands[0]) != REG)\n \t     operands[1] = force_reg (SFmode, operands[1]);\n@@ -5624,7 +5627,7 @@\n     }\n   else /* TARGET_THUMB */\n     {\n-      if (!no_new_pseudos)\n+      if (can_create_pseudo_p ())\n         {\n           if (GET_CODE (operands[0]) != REG)\n \t    operands[1] = force_reg (DFmode, operands[1]);"}, {"sha": "3d24357aa724b3c9263b927580a1b990c58a6241", "filename": "gcc/config/bfin/bfin.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3a134196fcae83a0fd93d20be96c48de8e912e8/gcc%2Fconfig%2Fbfin%2Fbfin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3a134196fcae83a0fd93d20be96c48de8e912e8/gcc%2Fconfig%2Fbfin%2Fbfin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbfin%2Fbfin.c?ref=b3a134196fcae83a0fd93d20be96c48de8e912e8", "patch": "@@ -181,7 +181,7 @@ legitimize_pic_address (rtx orig, rtx reg, rtx picreg)\n \n       if (reg == 0)\n \t{\n-\t  gcc_assert (!no_new_pseudos);\n+\t  gcc_assert (can_create_pseudo_p ());\n \t  reg = gen_reg_rtx (Pmode);\n \t}\n \n@@ -209,7 +209,7 @@ legitimize_pic_address (rtx orig, rtx reg, rtx picreg)\n \n       if (reg == 0)\n \t{\n-\t  gcc_assert (!no_new_pseudos);\n+\t  gcc_assert (can_create_pseudo_p ());\n \t  reg = gen_reg_rtx (Pmode);\n \t}\n "}, {"sha": "36537c54274ed3292b180cdb28c4b2d3e1d08bf2", "filename": "gcc/config/cris/cris.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3a134196fcae83a0fd93d20be96c48de8e912e8/gcc%2Fconfig%2Fcris%2Fcris.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3a134196fcae83a0fd93d20be96c48de8e912e8/gcc%2Fconfig%2Fcris%2Fcris.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Fcris.c?ref=b3a134196fcae83a0fd93d20be96c48de8e912e8", "patch": "@@ -3181,7 +3181,7 @@ cris_expand_pic_call_address (rtx *opp)\n     {\n       enum cris_pic_symbol_type t = cris_pic_symbol_type_of (op);\n \n-      CRIS_ASSERT (!no_new_pseudos);\n+      CRIS_ASSERT (can_create_pseudo_p ());\n \n       /* For local symbols (non-PLT), just get the plain symbol\n \t reference into a register.  For symbols that can be PLT, make\n@@ -3196,7 +3196,7 @@ cris_expand_pic_call_address (rtx *opp)\n \t\t \"move.d (const (unspec [sym] CRIS_UNSPEC_PLT)),rM\"\n \t\t \"add.d rPIC,rM,rO\", \"jsr rO\".  */\n \t      rtx tem, rm, ro;\n-\t      gcc_assert (! no_new_pseudos);\n+\t      gcc_assert (can_create_pseudo_p ());\n \t      current_function_uses_pic_offset_table = 1;\n \t      tem = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, op), CRIS_UNSPEC_PLT);\n \t      rm = gen_reg_rtx (Pmode);\n@@ -3222,7 +3222,7 @@ cris_expand_pic_call_address (rtx *opp)\n \t\t access of the PLTGOT isn't constant).  */\n \t      rtx tem, mem, rm, ro;\n \n-\t      gcc_assert (! no_new_pseudos);\n+\t      gcc_assert (can_create_pseudo_p ());\n \t      current_function_uses_pic_offset_table = 1;\n \t      tem = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, op),\n \t\t\t\t    CRIS_UNSPEC_PLTGOTREAD);"}, {"sha": "98a09f10bdc02c97dcf3dcd29e4e969a5630ba75", "filename": "gcc/config/cris/cris.md", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3a134196fcae83a0fd93d20be96c48de8e912e8/gcc%2Fconfig%2Fcris%2Fcris.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3a134196fcae83a0fd93d20be96c48de8e912e8/gcc%2Fconfig%2Fcris%2Fcris.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Fcris.md?ref=b3a134196fcae83a0fd93d20be96c48de8e912e8", "patch": "@@ -789,7 +789,7 @@\n   if (MEM_P (operands[0])\n       && ! REG_S_P (operands[1])\n       && operands[1] != const0_rtx\n-      && ! no_new_pseudos)\n+      && may_create_pseudo__p ())\n     operands[1] = force_reg (SImode, operands[1]);\n \n   /* If we're generating PIC and have an incoming symbol, validize it to a\n@@ -810,7 +810,7 @@\n \t  {\n \t    /* We must have a register as destination for what we're about to\n \t       do, and for the patterns we generate.  */\n-\t    CRIS_ASSERT (!no_new_pseudos);\n+\t    CRIS_ASSERT (can_create_pseudo_p ());\n \t    operands[1] = force_reg (SImode, operands[1]);\n \t  }\n \telse\n@@ -829,7 +829,7 @@\n \t\t  ? operands[1] : get_related_value (operands[1]);\n \t\tHOST_WIDE_INT offs = get_integer_term (operands[1]);\n \n-\t\tgcc_assert (! no_new_pseudos);\n+\t\tgcc_assert (can_create_pseudo_p ());\n \t\ttem = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, sym),\n \t\t\t\t      CRIS_UNSPEC_GOTREL);\n \t\tif (offs != 0)\n@@ -848,7 +848,7 @@\n \t\t   \"add.d rPIC,rM,rO\", \"move.d [rO],rN\" with\n \t\t   the memory access marked as read-only.  */\n \t\trtx tem, mem, rm, ro, rn = operands[0];\n-\t\tgcc_assert (! no_new_pseudos);\n+\t\tgcc_assert (can_create_pseudo_p ());\n \t\ttem = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, operands[1]),\n \t\t\t\t      CRIS_UNSPEC_GOTREAD);\n \t\trm = gen_reg_rtx (Pmode);\n@@ -879,7 +879,7 @@\n \t\trtx sym = get_related_value (operands[1]);\n \t\tHOST_WIDE_INT offs = get_integer_term (operands[1]);\n \n-\t\tgcc_assert (! no_new_pseudos\n+\t\tgcc_assert (can_create_pseudo_p ()\n \t\t\t    && t == cris_got_symbol_needing_fixup\n \t\t\t    && sym != NULL_RTX && offs != 0);\n "}, {"sha": "9d703da70a1e824ce7066ed14f5476454389ee91", "filename": "gcc/config/darwin.c", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3a134196fcae83a0fd93d20be96c48de8e912e8/gcc%2Fconfig%2Fdarwin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3a134196fcae83a0fd93d20be96c48de8e912e8/gcc%2Fconfig%2Fdarwin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdarwin.c?ref=b3a134196fcae83a0fd93d20be96c48de8e912e8", "patch": "@@ -516,7 +516,7 @@ machopic_indirect_data_reference (rtx orig, rtx reg)\n \t{\n #if defined (TARGET_TOC)\n \t  /* Create a new register for CSE opportunities.  */\n-\t  rtx hi_reg = (no_new_pseudos ? reg : gen_reg_rtx (Pmode));\n+\t  rtx hi_reg = (!can_create_pseudo_p () ? reg : gen_reg_rtx (Pmode));\n  \t  emit_insn (gen_macho_high (hi_reg, orig));\n  \t  emit_insn (gen_macho_low (reg, hi_reg, orig));\n #else\n@@ -533,7 +533,9 @@ machopic_indirect_data_reference (rtx orig, rtx reg)\n #endif\n \n #if defined (TARGET_TOC) /* i.e., PowerPC */\n-\t  rtx hi_sum_reg = (no_new_pseudos ? reg : gen_reg_rtx (Pmode));\n+\t  rtx hi_sum_reg = (!can_create_pseudo_p ()\n+\t\t\t    ? reg\n+\t\t\t    : gen_reg_rtx (Pmode));\n \n \t  gcc_assert (reg);\n \n@@ -705,7 +707,9 @@ machopic_legitimize_pic_address (rtx orig, enum machine_mode mode, rtx reg)\n \t\t  || GET_CODE (XEXP (orig, 0)) == LABEL_REF))\n \t    {\n #if defined (TARGET_TOC)\t/* ppc  */\n-\t      rtx temp_reg = (no_new_pseudos) ? reg : gen_reg_rtx (Pmode);\n+\t      rtx temp_reg = (!can_create_pseudo_p ()\n+\t\t\t      ? reg :\n+\t\t\t      gen_reg_rtx (Pmode));\n \t      rtx asym = XEXP (orig, 0);\n \t      rtx mem;\n \n@@ -728,7 +732,9 @@ machopic_legitimize_pic_address (rtx orig, enum machine_mode mode, rtx reg)\n #if defined (TARGET_TOC) /* i.e., PowerPC */\n \t      /* Generating a new reg may expose opportunities for\n \t\t common subexpression elimination.  */\n-              rtx hi_sum_reg = no_new_pseudos ? reg : gen_reg_rtx (Pmode);\n+              rtx hi_sum_reg = (!can_create_pseudo_p ()\n+\t\t\t\t? reg\n+\t\t\t\t: gen_reg_rtx (Pmode));\n \t      rtx mem;\n \t      rtx insn;\n \t      rtx sum;"}, {"sha": "25460023325e73369982c9f2cc8b100627ed69c5", "filename": "gcc/config/frv/frv.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3a134196fcae83a0fd93d20be96c48de8e912e8/gcc%2Fconfig%2Ffrv%2Ffrv.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3a134196fcae83a0fd93d20be96c48de8e912e8/gcc%2Fconfig%2Ffrv%2Ffrv.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv.md?ref=b3a134196fcae83a0fd93d20be96c48de8e912e8", "patch": "@@ -7874,7 +7874,7 @@\n   \"\"\n   \"\n {\n-  if (no_new_pseudos)\n+  if (!can_create_pseudo_p ())\n     operands[6] = operands[5] = operands[0];\n   else\n     {\n@@ -7902,7 +7902,7 @@\n   \"\"\n   \"\n {\n-  if (no_new_pseudos)\n+  if (!can_create_pseudo_p ())\n     operands[6] = operands[5] = operands[0];\n   else\n     {\n@@ -7950,7 +7950,7 @@\n {\n   rtx insn;\n \n-  if (no_new_pseudos)\n+  if (!can_create_pseudo_p ())\n     operands[4] = operands[0];\n   else\n     operands[4] = gen_reg_rtx (SImode);\n@@ -7976,7 +7976,7 @@\n {\n   rtx insn;\n \n-  if (no_new_pseudos)\n+  if (!can_create_pseudo_p ())\n     {\n       emit_insn (gen_symGOT2reg (operands[0], operands[1], operands[2],\n \t\t\t\t GEN_INT (R_FRV_GOT12)));"}, {"sha": "68fa54d2bdee0af2df76960fee35cdf3b3cbb6f9", "filename": "gcc/config/h8300/h8300.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3a134196fcae83a0fd93d20be96c48de8e912e8/gcc%2Fconfig%2Fh8300%2Fh8300.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3a134196fcae83a0fd93d20be96c48de8e912e8/gcc%2Fconfig%2Fh8300%2Fh8300.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.md?ref=b3a134196fcae83a0fd93d20be96c48de8e912e8", "patch": "@@ -3251,7 +3251,7 @@\n \t    }\n           if (! bit_memory_operand (operands[0], GET_MODE (operands[0])))\n \t    {\n-\t      if (no_new_pseudos)\n+\t      if (!can_create_pseudo_p ())\n \t\tFAIL;\n \t      operands[0] =\n \t        replace_equiv_address (operands[0],\n@@ -3263,7 +3263,7 @@\n \t    FAIL;\n \t  if (! register_operand (operands[3], QImode))\n \t    {\n-\t      if (no_new_pseudos)\n+\t      if (!can_create_pseudo_p ())\n \t\tFAIL;\n \t      operands[3] = force_reg (QImode, operands[3]);\n \t    }\n@@ -3323,15 +3323,15 @@\n \t\t  == MODE_INT))\n \t    operands[0] = SUBREG_REG (operands[0]);\n \n-\t  if (no_new_pseudos)\n+\t  if (!can_create_pseudo_p ())\n \t    temp = gen_lowpart (QImode, operands[0]);\n \t  else\n \t    temp = gen_reg_rtx (QImode);\n \t  if (! temp)\n \t    FAIL;\n           if (! bit_memory_operand (operands[1], QImode))\n \t    {\n-\t      if (no_new_pseudos)\n+\t      if (!can_create_pseudo_p ())\n \t\tFAIL;\n \t      operands[1] =\n \t        replace_equiv_address (operands[1],"}, {"sha": "713b79d19c3990a38f56964c99cf404d23c8c663", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3a134196fcae83a0fd93d20be96c48de8e912e8/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3a134196fcae83a0fd93d20be96c48de8e912e8/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=b3a134196fcae83a0fd93d20be96c48de8e912e8", "patch": "@@ -9799,7 +9799,7 @@ ix86_expand_move (enum machine_mode mode, rtx operands[])\n \t    op1 = force_reg (Pmode, op1);\n \t  else if (!TARGET_64BIT || !x86_64_movabs_operand (op1, Pmode))\n \t    {\n-\t      rtx reg = no_new_pseudos ? op0 : NULL_RTX;\n+\t      rtx reg = !can_create_pseudo_p () ? op0 : NULL_RTX;\n \t      op1 = legitimize_pic_address (op1, reg);\n \t      if (op0 == op1)\n \t\treturn;\n@@ -9874,7 +9874,7 @@ ix86_expand_vector_move (enum machine_mode mode, rtx operands[])\n      are moved via xmm registers, and moving them to stack can result in\n      unaligned memory access.  Use ix86_expand_vector_move_misalign()\n      if memory operand is not aligned correctly.  */\n-  if (!no_new_pseudos\n+  if (can_create_pseudo_p ()\n       && (mode == TImode) && !TARGET_64BIT\n       && ((MEM_P (op0) && (MEM_ALIGN (op0) < align))\n \t  || (MEM_P (op1) && (MEM_ALIGN (op1) < align))))\n@@ -9898,7 +9898,7 @@ ix86_expand_vector_move (enum machine_mode mode, rtx operands[])\n     }\n \n   /* Make operand1 a register if it isn't already.  */\n-  if (!no_new_pseudos\n+  if (can_create_pseudo_p ()\n       && !register_operand (op0, mode)\n       && !register_operand (op1, mode))\n     {\n@@ -11325,7 +11325,7 @@ ix86_prepare_fp_compare_args (enum rtx_code code, rtx *pop0, rtx *pop1)\n   /* Try to rearrange the comparison to make it cheaper.  */\n   if (ix86_fp_comparison_cost (code)\n       > ix86_fp_comparison_cost (swap_condition (code))\n-      && (REG_P (op1) || !no_new_pseudos))\n+      && (REG_P (op1) || can_create_pseudo_p ()))\n     {\n       rtx tmp;\n       tmp = op0, op0 = op1, op1 = tmp;\n@@ -12055,7 +12055,7 @@ ix86_expand_carry_flag_compare (enum rtx_code code, rtx op0, rtx op1, rtx *pop)\n   /* Swapping operands may cause constant to appear as first operand.  */\n   if (!nonimmediate_operand (op0, VOIDmode))\n     {\n-      if (no_new_pseudos)\n+      if (!can_create_pseudo_p ())\n \treturn false;\n       op0 = force_reg (mode, op0);\n     }"}, {"sha": "e258447c39ec7cf48e13439e58ed784e74f3a3b5", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3a134196fcae83a0fd93d20be96c48de8e912e8/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3a134196fcae83a0fd93d20be96c48de8e912e8/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=b3a134196fcae83a0fd93d20be96c48de8e912e8", "patch": "@@ -15316,7 +15316,7 @@\n      (clobber (reg:CC FLAGS_REG))])]\n   \"!TARGET_64BIT && TARGET_GNU2_TLS\"\n {\n-  operands[3] = no_new_pseudos ? operands[0] : gen_reg_rtx (Pmode);\n+  operands[3] = !can_create_pseudo_p () ? operands[0] : gen_reg_rtx (Pmode);\n   ix86_tls_descriptor_calls_expanded_in_cfun = true;\n })\n \n@@ -15365,7 +15365,7 @@\n   \"\"\n   [(set (match_dup 0) (match_dup 5))]\n {\n-  operands[5] = no_new_pseudos ? operands[0] : gen_reg_rtx (Pmode);\n+  operands[5] = !can_create_pseudo_p () ? operands[0] : gen_reg_rtx (Pmode);\n   emit_insn (gen_tls_dynamic_gnu2_32 (operands[5], operands[1], operands[2]));\n })\n \n@@ -15380,7 +15380,7 @@\n      (clobber (reg:CC FLAGS_REG))])]\n   \"TARGET_64BIT && TARGET_GNU2_TLS\"\n {\n-  operands[2] = no_new_pseudos ? operands[0] : gen_reg_rtx (Pmode);\n+  operands[2] = !can_create_pseudo_p () ? operands[0] : gen_reg_rtx (Pmode);\n   ix86_tls_descriptor_calls_expanded_in_cfun = true;\n })\n \n@@ -15424,7 +15424,7 @@\n   \"\"\n   [(set (match_dup 0) (match_dup 4))]\n {\n-  operands[4] = no_new_pseudos ? operands[0] : gen_reg_rtx (Pmode);\n+  operands[4] = !can_create_pseudo_p () ? operands[0] : gen_reg_rtx (Pmode);\n   emit_insn (gen_tls_dynamic_gnu2_64 (operands[4], operands[1]));\n })\n "}, {"sha": "9a5bcd95ea9cc9d8eb3fb731ee0587b85fbe7294", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3a134196fcae83a0fd93d20be96c48de8e912e8/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3a134196fcae83a0fd93d20be96c48de8e912e8/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=b3a134196fcae83a0fd93d20be96c48de8e912e8", "patch": "@@ -1028,7 +1028,7 @@ ia64_expand_move (rtx op0, rtx op1)\n \n       if (addend)\n \t{\n-\t  rtx subtarget = no_new_pseudos ? op0 : gen_reg_rtx (mode);\n+\t  rtx subtarget = !can_create_pseudo_p () ? op0 : gen_reg_rtx (mode);\n \n \t  emit_insn (gen_rtx_SET (VOIDmode, subtarget, op1));\n \n@@ -1342,7 +1342,7 @@ ia64_expand_movxf_movrf (enum machine_mode mode, rtx operands[])\n \n       /* We're hoping to transform everything that deals with XFmode\n \t quantities and GR registers early in the compiler.  */\n-      gcc_assert (!no_new_pseudos);\n+      gcc_assert (can_create_pseudo_p ());\n \n       /* Struct to register can just use TImode instead.  */\n       if ((GET_CODE (operands[1]) == SUBREG\n@@ -1392,7 +1392,7 @@ ia64_expand_movxf_movrf (enum machine_mode mode, rtx operands[])\n     {\n       /* We're hoping to transform everything that deals with XFmode\n \t quantities and GR registers early in the compiler.  */\n-      gcc_assert (!no_new_pseudos);\n+      gcc_assert (can_create_pseudo_p ());\n \n       /* Op0 can't be a GR_REG here, as that case is handled above.\n \t If op0 is a register, then we spill op1, so that we now have a\n@@ -9455,7 +9455,6 @@ ia64_output_mi_thunk (FILE *file, tree thunk ATTRIBUTE_UNUSED,\n \n   reload_completed = 1;\n   epilogue_completed = 1;\n-  no_new_pseudos = 1;\n \n   /* Set things up as ia64_expand_prologue might.  */\n   last_scratch_gr_reg = 15;\n@@ -9580,7 +9579,6 @@ ia64_output_mi_thunk (FILE *file, tree thunk ATTRIBUTE_UNUSED,\n \n   reload_completed = 0;\n   epilogue_completed = 0;\n-  no_new_pseudos = 0;\n }\n \n /* Worker function for TARGET_STRUCT_VALUE_RTX.  */"}, {"sha": "d2a52be9710eb09cb1395ed76a117cefc3405c2c", "filename": "gcc/config/m32c/m32c.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3a134196fcae83a0fd93d20be96c48de8e912e8/gcc%2Fconfig%2Fm32c%2Fm32c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3a134196fcae83a0fd93d20be96c48de8e912e8/gcc%2Fconfig%2Fm32c%2Fm32c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32c%2Fm32c.c?ref=b3a134196fcae83a0fd93d20be96c48de8e912e8", "patch": "@@ -3155,7 +3155,7 @@ m32c_prepare_move (rtx * operands, enum machine_mode mode)\n       emit_insn (gen_rtx_SET (Pmode, dest_reg, dest_mod));\n       operands[0] = gen_rtx_MEM (mode, dest_reg);\n     }\n-  if (!no_new_pseudos && MEM_P (operands[0]) && MEM_P (operands[1]))\n+  if (can_create_pseudo_p () && MEM_P (operands[0]) && MEM_P (operands[1]))\n     operands[1] = copy_to_mode_reg (mode, operands[1]);\n   return 0;\n }\n@@ -3220,7 +3220,7 @@ m32c_split_move (rtx * operands, enum machine_mode mode, int split_all)\n \n   /* Before splitting mem-mem moves, force one operand into a\n      register.  */\n-  if (!no_new_pseudos && MEM_P (operands[0]) && MEM_P (operands[1]))\n+  if (can_create_pseudo_p () && MEM_P (operands[0]) && MEM_P (operands[1]))\n     {\n #if DEBUG0\n       fprintf (stderr, \"force_reg...\\n\");\n@@ -3235,7 +3235,8 @@ m32c_split_move (rtx * operands, enum machine_mode mode, int split_all)\n   parts = 2;\n \n #if DEBUG_SPLIT\n-  fprintf (stderr, \"\\nsplit_move %d all=%d\\n\", no_new_pseudos, split_all);\n+  fprintf (stderr, \"\\nsplit_move %d all=%d\\n\", !can_create_pseudo_p (),\n+\t   split_all);\n   debug_rtx (operands[0]);\n   debug_rtx (operands[1]);\n #endif\n@@ -3774,7 +3775,7 @@ m32c_expand_insv (rtx *operands)\n \top0 = sub;\n     }\n \n-  if (no_new_pseudos\n+  if (!can_create_pseudo_p ()\n       || (GET_CODE (op0) == MEM && MEM_VOLATILE_P (op0)))\n     src0 = op0;\n   else"}, {"sha": "73479856305d8323698b07e4d1ac1927e7e7d63f", "filename": "gcc/config/m68k/m68k.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3a134196fcae83a0fd93d20be96c48de8e912e8/gcc%2Fconfig%2Fm68k%2Fm68k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3a134196fcae83a0fd93d20be96c48de8e912e8/gcc%2Fconfig%2Fm68k%2Fm68k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.c?ref=b3a134196fcae83a0fd93d20be96c48de8e912e8", "patch": "@@ -4129,7 +4129,6 @@ m68k_output_mi_thunk (FILE *file, tree thunk ATTRIBUTE_UNUSED,\n   rtx this_slot, offset, addr, mem, insn;\n \n   /* Pretend to be a post-reload pass while generating rtl.  */\n-  no_new_pseudos = 1;\n   reload_completed = 1;\n \n   /* The \"this\" pointer is stored at 4(%sp).  */\n@@ -4203,7 +4202,6 @@ m68k_output_mi_thunk (FILE *file, tree thunk ATTRIBUTE_UNUSED,\n \n   /* Clean up the vars set above.  */\n   reload_completed = 0;\n-  no_new_pseudos = 0;\n \n   /* Restore the original PIC register.  */\n   if (flag_pic)"}, {"sha": "56c7bf4a7c22dd71c68a3a988ba1cb97e0666f1d", "filename": "gcc/config/m68k/m68k.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3a134196fcae83a0fd93d20be96c48de8e912e8/gcc%2Fconfig%2Fm68k%2Fm68k.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3a134196fcae83a0fd93d20be96c48de8e912e8/gcc%2Fconfig%2Fm68k%2Fm68k.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.md?ref=b3a134196fcae83a0fd93d20be96c48de8e912e8", "patch": "@@ -665,7 +665,7 @@\n       if (GET_CODE (base) == SYMBOL_REF\n \t  && !offset_within_block_p (base, INTVAL (offset)))\n \t{\n-\t  tmp = no_new_pseudos ? operands[0] : gen_reg_rtx (SImode);\n+\t  tmp = !can_create_pseudo_p () ? operands[0] : gen_reg_rtx (SImode);\n \t  emit_move_insn (tmp, base);\n \t  emit_insn (gen_addsi3 (operands[0], tmp, offset));\n \t  DONE;"}, {"sha": "c1cf631d8e3391a86f86bd759ba41bde2c29591c", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3a134196fcae83a0fd93d20be96c48de8e912e8/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3a134196fcae83a0fd93d20be96c48de8e912e8/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=b3a134196fcae83a0fd93d20be96c48de8e912e8", "patch": "@@ -2097,7 +2097,7 @@ mips_legitimate_address_p (enum machine_mode mode, rtx x, int strict)\n static rtx\n mips_force_temporary (rtx dest, rtx value)\n {\n-  if (!no_new_pseudos)\n+  if (can_create_pseudo_p ())\n     return force_reg (Pmode, value);\n   else\n     {\n@@ -2117,7 +2117,7 @@ mips_split_symbol (rtx temp, rtx addr)\n \n   if (!TARGET_MIPS16)\n     high = mips_force_temporary (temp, gen_rtx_HIGH (Pmode, copy_rtx (addr)));\n-  else if (no_new_pseudos)\n+  else if (!can_create_pseudo_p ())\n     {\n       emit_insn (gen_load_const_gp (copy_rtx (temp)));\n       high = temp;\n@@ -2468,7 +2468,7 @@ mips_move_integer (rtx dest, rtx temp, unsigned HOST_WIDE_INT value)\n   x = GEN_INT (codes[0].value);\n   for (i = 1; i < cost; i++)\n     {\n-      if (no_new_pseudos)\n+      if (!can_create_pseudo_p ())\n \t{\n \t  emit_insn (gen_rtx_SET (VOIDmode, temp, x));\n \t  x = temp;\n@@ -2517,7 +2517,7 @@ mips_legitimize_const_move (enum machine_mode mode, rtx dest, rtx src)\n   split_const (src, &base, &offset);\n   if (!TARGET_MIPS16\n       && offset != const0_rtx\n-      && (!no_new_pseudos || SMALL_INT (offset)))\n+      && (can_create_pseudo_p () || SMALL_INT (offset)))\n     {\n       base = mips_force_temporary (dest, base);\n       emit_move_insn (dest, mips_add_offset (0, base, INTVAL (offset)));\n@@ -7957,7 +7957,6 @@ mips_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,\n   rtx this, temp1, temp2, insn, fnaddr;\n \n   /* Pretend to be a post-reload pass while generating rtl.  */\n-  no_new_pseudos = 1;\n   reload_completed = 1;\n \n   /* Mark the end of the (empty) prologue.  */\n@@ -8067,7 +8066,6 @@ mips_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,\n   /* Clean up the vars set above.  Note that final_end_function resets\n      the global pointer for us.  */\n   reload_completed = 0;\n-  no_new_pseudos = 0;\n }\n \f\n /* Returns nonzero if X contains a SYMBOL_REF.  */"}, {"sha": "7bd6dc0f40cbcdd44af9b3807249f2f80924e413", "filename": "gcc/config/mn10300/mn10300.md", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3a134196fcae83a0fd93d20be96c48de8e912e8/gcc%2Fconfig%2Fmn10300%2Fmn10300.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3a134196fcae83a0fd93d20be96c48de8e912e8/gcc%2Fconfig%2Fmn10300%2Fmn10300.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300.md?ref=b3a134196fcae83a0fd93d20be96c48de8e912e8", "patch": "@@ -307,21 +307,24 @@\n \t    operands[1] = force_reg (Pmode, operands[1]);\n \t  else\n \t    {\n-\t      temp = no_new_pseudos ? operands[0] : gen_reg_rtx (Pmode);\n+\t      temp = (!can_create_pseudo_p ()\n+\t\t      ? operands[0]\n+\t\t      : gen_reg_rtx (Pmode));\n \t      operands[1] = legitimize_pic_address (operands[1], temp);\n \t    }\n \t}\n       else if (GET_CODE (operands[1]) == CONST\n \t       && GET_CODE (XEXP (operands[1], 0)) == PLUS\n \t       && SYMBOLIC_CONST_P (XEXP (XEXP (operands[1], 0), 0)))\n \t{\n-\t  temp = no_new_pseudos ? operands[0] : gen_reg_rtx (Pmode);\n+\t  temp = !can_create_pseudo_p () ? operands[0] : gen_reg_rtx (Pmode);\n \t  temp = legitimize_pic_address (XEXP (XEXP (operands[1], 0), 0),\n \t\t\t\t\t temp);\n \t  operands[1] = expand_binop (SImode, add_optab, temp,\n \t\t\t\t      XEXP (XEXP (operands[1], 0), 1),\n-\t\t\t\t      no_new_pseudos ? temp\n-\t\t\t\t      : gen_reg_rtx (Pmode),\n+\t\t\t\t      (!can_create_pseudo_p ()\n+\t\t\t\t       ? temp\n+\t\t\t\t       : gen_reg_rtx (Pmode)),\n \t\t\t\t      0, OPTAB_LIB_WIDEN);\n \t}\n     }"}, {"sha": "4948174af93ec0a4dcaaf61dba04c2a33d16bedf", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3a134196fcae83a0fd93d20be96c48de8e912e8/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3a134196fcae83a0fd93d20be96c48de8e912e8/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=b3a134196fcae83a0fd93d20be96c48de8e912e8", "patch": "@@ -1377,8 +1377,7 @@ emit_move_sequence (rtx *operands, enum machine_mode mode, rtx scratch_reg)\n      addresses from the destination operand.  */\n   if (GET_CODE (operand0) == MEM && IS_INDEX_ADDR_P (XEXP (operand0, 0)))\n     {\n-      /* This is only safe up to the beginning of life analysis.  */\n-      gcc_assert (!no_new_pseudos);\n+      gcc_assert (can_create_pseudo_p ());\n \n       tem = copy_to_mode_reg (Pmode, XEXP (operand0, 0));\n       operand0 = replace_equiv_address (operand0, tem);"}, {"sha": "b32f36bf7e23ee2c0ae27d5f082129e9c2a83e48", "filename": "gcc/config/pa/pa.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3a134196fcae83a0fd93d20be96c48de8e912e8/gcc%2Fconfig%2Fpa%2Fpa.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3a134196fcae83a0fd93d20be96c48de8e912e8/gcc%2Fconfig%2Fpa%2Fpa.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.md?ref=b3a134196fcae83a0fd93d20be96c48de8e912e8", "patch": "@@ -4434,7 +4434,7 @@\n   /* Except for zero, we don't support loading a CONST_INT directly\n      to a hard floating-point register since a scratch register is\n      needed for the operation.  While the operation could be handled\n-     before no_new_pseudos is true, the simplest solution is to fail.  */\n+     before register allocation, the simplest solution is to fail.  */\n   if (TARGET_64BIT\n       && GET_CODE (operands[1]) == CONST_INT\n       && operands[1] != CONST0_RTX (DImode)"}, {"sha": "722a5a6c342dcd355de651fa34eea8cd0c7efd81", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3a134196fcae83a0fd93d20be96c48de8e912e8/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3a134196fcae83a0fd93d20be96c48de8e912e8/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=b3a134196fcae83a0fd93d20be96c48de8e912e8", "patch": "@@ -4060,7 +4060,7 @@ rs6000_emit_set_const (rtx dest, enum machine_mode mode,\n       return dest;\n \n     case SImode:\n-      result = no_new_pseudos ? dest : gen_reg_rtx (SImode);\n+      result = !can_create_pseudo_p () ? dest : gen_reg_rtx (SImode);\n \n       emit_insn (gen_rtx_SET (VOIDmode, copy_rtx (result),\n \t\t\t      GEN_INT (INTVAL (source)\n@@ -4279,7 +4279,7 @@ rs6000_emit_move (rtx dest, rtx source, enum machine_mode mode)\n       return;\n     }\n \n-  if (!no_new_pseudos && GET_CODE (operands[0]) == MEM\n+  if (can_create_pseudo_p () && GET_CODE (operands[0]) == MEM\n       && !gpc_reg_operand (operands[1], mode))\n     operands[1] = force_reg (mode, operands[1]);\n \n@@ -4302,7 +4302,7 @@ rs6000_emit_move (rtx dest, rtx source, enum machine_mode mode)\n       if (FP_REGNO_P (regnum) || regnum >= FIRST_PSEUDO_REGISTER)\n \t{\n \t  rtx newreg;\n-\t  newreg = (no_new_pseudos ? copy_rtx (operands[1])\n+\t  newreg = (!can_create_pseudo_p () ? copy_rtx (operands[1])\n \t\t    : gen_reg_rtx (mode));\n \t  emit_insn (gen_aux_truncdfsf2 (newreg, operands[1]));\n \t  operands[1] = newreg;\n@@ -4429,7 +4429,9 @@ rs6000_emit_move (rtx dest, rtx source, enum machine_mode mode)\n \t  && GET_CODE (operands[1]) != HIGH\n \t  && GET_CODE (operands[1]) != CONST_INT)\n \t{\n-\t  rtx target = (no_new_pseudos ? operands[0] : gen_reg_rtx (mode));\n+\t  rtx target = (!can_create_pseudo_p ()\n+\t\t\t? operands[0]\n+\t\t\t: gen_reg_rtx (mode));\n \n \t  /* If this is a function address on -mcall-aixdesc,\n \t     convert it to the address of the descriptor.  */\n@@ -10489,7 +10491,8 @@ rs6000_got_register (rtx value ATTRIBUTE_UNUSED)\n   /* The second flow pass currently (June 1999) can't update\n      regs_ever_live without disturbing other parts of the compiler, so\n      update it here to make the prolog/epilogue code happy.  */\n-  if (no_new_pseudos && ! df_regs_ever_live_p (RS6000_PIC_OFFSET_TABLE_REGNUM))\n+  if (!can_create_pseudo_p ()\n+      && !df_regs_ever_live_p (RS6000_PIC_OFFSET_TABLE_REGNUM))\n     df_set_regs_ever_live (RS6000_PIC_OFFSET_TABLE_REGNUM, true);\n \n   current_function_uses_pic_offset_table = 1;\n@@ -14201,7 +14204,7 @@ uses_TOC (void)\n rtx\n create_TOC_reference (rtx symbol)\n {\n-  if (no_new_pseudos)\n+  if (!can_create_pseudo_p ())\n     df_set_regs_ever_live (TOC_REGISTER, true);\n   return gen_rtx_PLUS (Pmode,\n \t   gen_rtx_REG (Pmode, TOC_REGISTER),\n@@ -16148,7 +16151,6 @@ rs6000_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,\n \n   reload_completed = 1;\n   epilogue_completed = 1;\n-  no_new_pseudos = 1;\n \n   /* Mark the end of the (empty) prologue.  */\n   emit_note (NOTE_INSN_PROLOGUE_END);\n@@ -16236,7 +16238,6 @@ rs6000_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,\n \n   reload_completed = 0;\n   epilogue_completed = 0;\n-  no_new_pseudos = 0;\n }\n \f\n /* A quick summary of the various types of 'constant-pool tables'\n@@ -19437,7 +19438,7 @@ rs6000_machopic_legitimize_pic_address (rtx orig, enum machine_mode mode,\n \n       /* Use a different reg for the intermediate value, as\n \t it will be marked UNCHANGING.  */\n-      reg_temp = no_new_pseudos ? reg : gen_reg_rtx (Pmode);\n+      reg_temp = !can_create_pseudo_p () ? reg : gen_reg_rtx (Pmode);\n       base = rs6000_machopic_legitimize_pic_address (XEXP (XEXP (orig, 0), 0),\n \t\t\t\t\t\t     Pmode, reg_temp);\n       offset ="}, {"sha": "1157c4e2ee349a12704896f24d29eb555abadade", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 18, "deletions": 11, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3a134196fcae83a0fd93d20be96c48de8e912e8/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3a134196fcae83a0fd93d20be96c48de8e912e8/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=b3a134196fcae83a0fd93d20be96c48de8e912e8", "patch": "@@ -1468,7 +1468,8 @@\n   else if (GET_CODE (operands[2]) == CONST_INT\n \t   && ! add_operand (operands[2], <MODE>mode))\n     {\n-      rtx tmp = ((no_new_pseudos || rtx_equal_p (operands[0], operands[1]))\n+      rtx tmp = ((!can_create_pseudo_p ()\n+\t\t  || rtx_equal_p (operands[0], operands[1]))\n \t\t ? operands[0] : gen_reg_rtx (<MODE>mode));\n \n       HOST_WIDE_INT val = INTVAL (operands[2]);\n@@ -1591,7 +1592,7 @@\n   operands[4] = GEN_INT (low);\n   if (<MODE>mode == SImode || satisfies_constraint_L (GEN_INT (rest)))\n     operands[3] = GEN_INT (rest);\n-  else if (! no_new_pseudos)\n+  else if (can_create_pseudo_p ())\n     {\n       operands[3] = gen_reg_rtx (DImode);\n       emit_move_insn (operands[3], operands[2]);\n@@ -2988,7 +2989,8 @@\n       && ! logical_operand (operands[2], SImode))\n     {\n       HOST_WIDE_INT value = INTVAL (operands[2]);\n-      rtx tmp = ((no_new_pseudos || rtx_equal_p (operands[0], operands[1]))\n+      rtx tmp = ((!can_create_pseudo_p ()\n+\t\t  || rtx_equal_p (operands[0], operands[1]))\n \t\t ? operands[0] : gen_reg_rtx (SImode));\n \n       emit_insn (gen_iorsi3 (tmp, operands[1],\n@@ -3009,7 +3011,8 @@\n       && ! logical_operand (operands[2], SImode))\n     {\n       HOST_WIDE_INT value = INTVAL (operands[2]);\n-      rtx tmp = ((no_new_pseudos || rtx_equal_p (operands[0], operands[1]))\n+      rtx tmp = ((!can_create_pseudo_p ()\n+\t\t  || rtx_equal_p (operands[0], operands[1]))\n \t\t ? operands[0] : gen_reg_rtx (SImode));\n \n       emit_insn (gen_xorsi3 (tmp, operands[1],\n@@ -5797,7 +5800,7 @@\n    (clobber (match_operand:SI 6 \"gpc_reg_operand\" \"=&r\"))]\n   \"! TARGET_POWERPC64 && TARGET_HARD_FLOAT && TARGET_FPRS\"\n   \"#\"\n-  \"&& (!no_new_pseudos || offsettable_nonstrict_memref_p (operands[4]))\"\n+  \"&& (can_create_pseudo_p () || offsettable_nonstrict_memref_p (operands[4]))\"\n   [(pc)]\n   \"\n {\n@@ -5867,7 +5870,7 @@\n    (clobber (match_operand:DF 5 \"gpc_reg_operand\" \"=&f\"))]\n   \"! TARGET_POWERPC64 && TARGET_HARD_FLOAT && TARGET_FPRS\"\n   \"#\"\n-  \"&& (!no_new_pseudos || offsettable_nonstrict_memref_p (operands[4]))\"\n+  \"&& (can_create_pseudo_p () || offsettable_nonstrict_memref_p (operands[4]))\"\n   [(pc)]\n   \"\n {\n@@ -5933,7 +5936,7 @@\n    (clobber (match_operand:DI 3 \"memory_operand\" \"=o\"))]\n   \"(TARGET_POWER2 || TARGET_POWERPC) && TARGET_HARD_FLOAT && TARGET_FPRS\"\n   \"#\"\n-  \"&& (!no_new_pseudos || offsettable_nonstrict_memref_p (operands[3]))\"\n+  \"&& (can_create_pseudo_p () || offsettable_nonstrict_memref_p (operands[3]))\"\n   [(pc)]\n   \"\n {\n@@ -7649,7 +7652,8 @@\n   if (non_logical_cint_operand (operands[2], DImode))\n     {\n       HOST_WIDE_INT value;\n-      rtx tmp = ((no_new_pseudos || rtx_equal_p (operands[0], operands[1]))\n+      rtx tmp = ((!can_create_pseudo_p ()\n+\t\t  || rtx_equal_p (operands[0], operands[1]))\n \t\t ? operands[0] : gen_reg_rtx (DImode));\n \n       if (GET_CODE (operands[2]) == CONST_INT)\n@@ -7682,7 +7686,8 @@\n   if (non_logical_cint_operand (operands[2], DImode))\n     {\n       HOST_WIDE_INT value;\n-      rtx tmp = ((no_new_pseudos || rtx_equal_p (operands[0], operands[1]))\n+      rtx tmp = ((!can_create_pseudo_p ()\n+\t\t  || rtx_equal_p (operands[0], operands[1]))\n \t\t ? operands[0] : gen_reg_rtx (DImode));\n \n       if (GET_CODE (operands[2]) == CONST_INT)\n@@ -7960,7 +7965,9 @@\n       value = INTVAL (offset);\n       if (value != 0)\n \t{\n-\t  rtx tmp = (no_new_pseudos ? operands[0] : gen_reg_rtx (Pmode));\n+\t  rtx tmp = (!can_create_pseudo_p ()\n+\t\t     ? operands[0]\n+\t\t     : gen_reg_rtx (Pmode));\n \t  emit_insn (gen_movsi_got (tmp, operands[1]));\n \t  emit_insn (gen_addsi3 (operands[0], tmp, offset));\n \t  DONE;\n@@ -8771,7 +8778,7 @@\n   \"!TARGET_IEEEQUAD\n    && TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_LONG_DOUBLE_128\"\n   \"#\"\n-  \"&& (!no_new_pseudos || offsettable_nonstrict_memref_p (operands[5]))\"\n+  \"&& (can_create_pseudo_p () || offsettable_nonstrict_memref_p (operands[5]))\"\n   [(pc)]\n {\n   rtx lowword;"}, {"sha": "1af654fdf21b41a69d97145608dd4e6c2145ae68", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3a134196fcae83a0fd93d20be96c48de8e912e8/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3a134196fcae83a0fd93d20be96c48de8e912e8/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=b3a134196fcae83a0fd93d20be96c48de8e912e8", "patch": "@@ -3383,7 +3383,7 @@ legitimize_tls_address (rtx addr, rtx reg)\n void\n emit_symbolic_move (rtx *operands)\n {\n-  rtx temp = no_new_pseudos ? operands[0] : gen_reg_rtx (Pmode);\n+  rtx temp = !can_create_pseudo_p () ? operands[0] : gen_reg_rtx (Pmode);\n \n   if (GET_CODE (operands[0]) == MEM)\n     operands[1] = force_reg (Pmode, operands[1]);"}, {"sha": "12298898436c84ab9be1095484f36fa467e6ce03", "filename": "gcc/config/s390/s390.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3a134196fcae83a0fd93d20be96c48de8e912e8/gcc%2Fconfig%2Fs390%2Fs390.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3a134196fcae83a0fd93d20be96c48de8e912e8/gcc%2Fconfig%2Fs390%2Fs390.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.md?ref=b3a134196fcae83a0fd93d20be96c48de8e912e8", "patch": "@@ -1394,7 +1394,7 @@\n {\n   /* Make it explicit that loading a register from memory\n      always sign-extends (at least) to SImode.  */\n-  if (optimize && !no_new_pseudos\n+  if (optimize && can_create_pseudo_p ()\n       && register_operand (operands[0], VOIDmode)\n       && GET_CODE (operands[1]) == MEM)\n     {\n@@ -1441,7 +1441,7 @@\n {\n   /* On z/Architecture, zero-extending from memory to register\n      is just as fast as a QImode load.  */\n-  if (TARGET_ZARCH && optimize && !no_new_pseudos\n+  if (TARGET_ZARCH && optimize && can_create_pseudo_p ()\n       && register_operand (operands[0], VOIDmode)\n       && GET_CODE (operands[1]) == MEM)\n     {\n@@ -1887,7 +1887,7 @@\n     FAIL;\n \n   operands[3] = gen_rtx_PARALLEL (VOIDmode, rtvec_alloc (count));\n-  if (no_new_pseudos)\n+  if (!can_create_pseudo_p ())\n     {\n       if (GET_CODE (XEXP (operands[1], 0)) == REG)\n \t{\n@@ -1977,7 +1977,7 @@\n \n   operands[3] = gen_rtx_PARALLEL (VOIDmode, rtvec_alloc (count));\n \n-  if (no_new_pseudos)\n+  if (!can_create_pseudo_p ())\n     {\n       if (GET_CODE (XEXP (operands[0], 0)) == REG)\n \t{"}, {"sha": "aa3e2d007ee169d903d98937f8908b8c50f08c50", "filename": "gcc/config/score/score.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3a134196fcae83a0fd93d20be96c48de8e912e8/gcc%2Fconfig%2Fscore%2Fscore.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3a134196fcae83a0fd93d20be96c48de8e912e8/gcc%2Fconfig%2Fscore%2Fscore.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fscore%2Fscore.c?ref=b3a134196fcae83a0fd93d20be96c48de8e912e8", "patch": "@@ -181,7 +181,6 @@ th_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,\n   rtx this, temp1, temp2, insn, fnaddr;\n \n   /* Pretend to be a post-reload pass while generating rtl.  */\n-  no_new_pseudos = 1;\n   reload_completed = 1;\n \n   /* We need two temporary registers in some cases.  */\n@@ -240,7 +239,6 @@ th_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,\n   /* Clean up the vars set above.  Note that final_end_function resets\n      the global pointer for us.  */\n   reload_completed = 0;\n-  no_new_pseudos = 0;\n }\n \n /* Implement TARGET_STRICT_ARGUMENT_NAMING.  */\n@@ -812,7 +810,7 @@ score_address_p (enum machine_mode mode, rtx x, int strict)\n static rtx\n score_force_temporary (rtx dest, rtx value)\n {\n-  if (!no_new_pseudos)\n+  if (can_create_pseudo_p ())\n     return force_reg (Pmode, value);\n   else\n     {"}, {"sha": "b0802bfcf009533daf1aa7c4c865e65ba841f22b", "filename": "gcc/config/sh/predicates.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3a134196fcae83a0fd93d20be96c48de8e912e8/gcc%2Fconfig%2Fsh%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3a134196fcae83a0fd93d20be96c48de8e912e8/gcc%2Fconfig%2Fsh%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fpredicates.md?ref=b3a134196fcae83a0fd93d20be96c48de8e912e8", "patch": "@@ -782,7 +782,7 @@\n   if (GET_CODE (op) == CONST_INT)\n     return (TARGET_SHMEDIA\n \t    ? (satisfies_constraint_I06 (op)\n-\t       || (no_new_pseudos && INTVAL (op) == 0xff))\n+\t       || (!can_create_pseudo_p () && INTVAL (op) == 0xff))\n \t    : satisfies_constraint_K08 (op));\n   if (TARGET_SHMEDIA\n       && mode != DImode && GET_CODE (op) == SUBREG"}, {"sha": "a7347eefccb70771aa9b4bf37420a7adc797a96a", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 18, "deletions": 16, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3a134196fcae83a0fd93d20be96c48de8e912e8/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3a134196fcae83a0fd93d20be96c48de8e912e8/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=b3a134196fcae83a0fd93d20be96c48de8e912e8", "patch": "@@ -1192,21 +1192,24 @@ prepare_move_operands (rtx operands[], enum machine_mode mode)\n \t    /* It's ok.  */;\n \t  else\n \t    {\n-\t      temp = no_new_pseudos ? operands[0] : gen_reg_rtx (Pmode);\n+\t      temp = (!can_create_pseudo_p ()\n+\t\t      ? operands[0]\n+\t\t      : gen_reg_rtx (Pmode));\n \t      operands[1] = legitimize_pic_address (operands[1], mode, temp);\n \t    }\n \t}\n       else if (GET_CODE (operands[1]) == CONST\n \t       && GET_CODE (XEXP (operands[1], 0)) == PLUS\n \t       && SYMBOLIC_CONST_P (XEXP (XEXP (operands[1], 0), 0)))\n \t{\n-\t  temp = no_new_pseudos ? operands[0] : gen_reg_rtx (Pmode);\n+\t  temp = !can_create_pseudo_p () ? operands[0] : gen_reg_rtx (Pmode);\n \t  temp = legitimize_pic_address (XEXP (XEXP (operands[1], 0), 0),\n \t\t\t\t\t mode, temp);\n \t  operands[1] = expand_binop (mode, add_optab, temp,\n \t\t\t\t      XEXP (XEXP (operands[1], 0), 1),\n-\t\t\t\t      no_new_pseudos ? temp\n-\t\t\t\t      : gen_reg_rtx (Pmode),\n+\t\t\t\t      (!can_create_pseudo_p ()\n+\t\t\t\t       ? temp\n+\t\t\t\t       : gen_reg_rtx (Pmode)),\n \t\t\t\t      0, OPTAB_LIB_WIDEN);\n \t}\n     }\n@@ -1298,7 +1301,7 @@ prepare_move_operands (rtx operands[], enum machine_mode mode)\n \t\t  if (flag_schedule_insns)\n \t\t    emit_insn (gen_blockage ());\n \t\t}\n-\t      tga_op1 = no_new_pseudos ? op0 : gen_reg_rtx (Pmode);\n+\t      tga_op1 = !can_create_pseudo_p () ? op0 : gen_reg_rtx (Pmode);\n \t      tmp = gen_sym2GOTTPOFF (op1);\n \t      emit_insn (gen_tls_initial_exec (tga_op1, tmp));\n \t      op1 = tga_op1;\n@@ -1389,7 +1392,7 @@ prepare_cbranch_operands (rtx *operands, enum machine_mode mode,\n \t}\n     }\n   op1 = operands[1];\n-  if (!no_new_pseudos)\n+  if (can_create_pseudo_p ())\n     operands[1] = force_reg (mode, op1);\n   /* When we are handling DImode comparisons, we want to keep constants so\n      that we can optimize the component comparisons; however, memory loads\n@@ -1412,7 +1415,7 @@ prepare_cbranch_operands (rtx *operands, enum machine_mode mode,\n \t  emit_move_insn (scratch, operands[2]);\n \t  operands[2] = scratch;\n \t}\n-      else if (!no_new_pseudos)\n+      else if (can_create_pseudo_p ())\n \toperands[2] = force_reg (mode, operands[2]);\n     }\n   return comparison;\n@@ -8323,7 +8326,7 @@ emit_fpu_switch (rtx scratch, int index)\n     }\n \n   src = DECL_RTL (fpscr_values);\n-  if (no_new_pseudos)\n+  if (!can_create_pseudo_p ())\n     {\n       emit_move_insn (scratch, XEXP (src, 0));\n       if (index != 0)\n@@ -8492,7 +8495,7 @@ fpscr_set_from_mem (int mode, HARD_REG_SET regs_live)\n   enum attr_fp_mode norm_mode = ACTUAL_NORMAL_MODE (FP_MODE);\n   rtx addr_reg;\n \n-  addr_reg = no_new_pseudos ? get_free_reg (regs_live) : NULL_RTX;\n+  addr_reg = !can_create_pseudo_p () ? get_free_reg (regs_live) : NULL_RTX;\n   emit_fpu_switch (addr_reg, fp_mode == norm_mode);\n }\n \n@@ -10130,7 +10133,6 @@ sh_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,\n \n   reload_completed = 1;\n   epilogue_completed = 1;\n-  no_new_pseudos = 1;\n   current_function_uses_only_leaf_regs = 1;\n \n   emit_note (NOTE_INSN_PROLOGUE_END);\n@@ -10355,7 +10357,6 @@ sh_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,\n \n   reload_completed = 0;\n   epilogue_completed = 0;\n-  no_new_pseudos = 0;\n }\n \n rtx\n@@ -10432,11 +10433,12 @@ sh_get_pr_initial_val (void)\n \n   /* If we haven't finished rtl generation, there might be a nonlocal label\n      that we haven't seen yet.\n-     ??? get_hard_reg_initial_val fails if it is called while no_new_pseudos\n-     is set, unless it has been called before for the same register.  And even\n-     then, we end in trouble if we didn't use the register in the same\n-     basic block before.  So call get_hard_reg_initial_val now and wrap it\n-     in an unspec if we might need to replace it.  */\n+     ??? get_hard_reg_initial_val fails if it is called after register\n+     allocation has started, unless it has been called before for the\n+     same register.  And even then, we end in trouble if we didn't use\n+     the register in the same basic block before.  So call\n+     get_hard_reg_initial_val now and wrap it in an unspec if we might\n+     need to replace it.  */\n   /* ??? We also must do this for TARGET_SH1 in general, because otherwise\n      combine can put the pseudo returned by get_hard_reg_initial_val into\n      instructions that need a general purpose registers, which will fail to"}, {"sha": "9ff122ff142855ec886ff62d42731ac32fba2beb", "filename": "gcc/config/sh/sh.md", "status": "modified", "additions": 56, "deletions": 41, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3a134196fcae83a0fd93d20be96c48de8e912e8/gcc%2Fconfig%2Fsh%2Fsh.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3a134196fcae83a0fd93d20be96c48de8e912e8/gcc%2Fconfig%2Fsh%2Fsh.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.md?ref=b3a134196fcae83a0fd93d20be96c48de8e912e8", "patch": "@@ -985,7 +985,7 @@\n     {\n       rtx tmp;\n \n-      if (no_new_pseudos)\n+      if (!can_create_pseudo_p ())\n \tFAIL;\n \n       tmp = gen_reg_rtx (DImode);\n@@ -1205,7 +1205,7 @@\n \t\t   (match_operand:SI 3 \"register_operand\" \"0\"))\n \t\t (match_operand:SI 4 \"arith_reg_or_0_operand\" \"r\")))\n    (clobber (match_scratch:SI 5 \"=&r\"))]\n-  \"TARGET_SHMEDIA && no_new_pseudos\"\n+  \"TARGET_SHMEDIA && !can_create_pseudo_p ()\"\n   \"#\"\n   \"TARGET_SHMEDIA && reload_completed\"\n   [(pc)]\n@@ -1289,7 +1289,7 @@\n     {\n       rtx tmp;\n \n-      if (no_new_pseudos)\n+      if (!can_create_pseudo_p ())\n \tFAIL;\n \n       tmp = gen_reg_rtx (SImode);\n@@ -1398,7 +1398,7 @@\n {\n   if (TARGET_SH1)\n     {\n-      if (no_new_pseudos && ! arith_reg_operand (operands[2], DImode))\n+      if (!can_create_pseudo_p () && ! arith_reg_operand (operands[2], DImode))\n         FAIL;\n       operands[2] = force_reg (DImode, operands[2]);\n       emit_insn (gen_adddi3_compact (operands[0], operands[1], operands[2]));\n@@ -1693,7 +1693,8 @@\n     }\n   if (TARGET_SHMEDIA)\n     {\n-      if (no_new_pseudos && ! arith_reg_or_0_operand (operands[1], SImode))\n+      if (!can_create_pseudo_p ()\n+\t  && ! arith_reg_or_0_operand (operands[1], SImode))\n \tFAIL;\n       if (operands[1] != const0_rtx && GET_CODE (operands[1]) != SUBREG)\n \toperands[1] = force_reg (SImode, operands[1]);\n@@ -2357,7 +2358,7 @@ norm32: r25\n    (clobber (match_operand:DI 8 \"register_operand\" \"=r\"))]\n   \"TARGET_SHMEDIA\"\n   \"#\"\n-  \"&& no_new_pseudos\"\n+  \"&& !can_create_pseudo_p ()\"\n   [(pc)]\n   \"\n {\n@@ -2401,7 +2402,7 @@ norm32: r25\n    (clobber (match_operand:DI 4 \"register_operand\" \"=r\"))]\n   \"TARGET_SHMEDIA\"\n   \"#\"\n-  \"&& no_new_pseudos\"\n+  \"&& !can_create_pseudo_p ()\"\n   [(pc)]\n   \"\n {\n@@ -2445,7 +2446,7 @@ norm32: r25\n    (clobber (match_operand:DI 13 \"register_operand\" \"=r\"))]\n   \"TARGET_SHMEDIA\"\n   \"#\"\n-  \"&& no_new_pseudos\"\n+  \"&& !can_create_pseudo_p ()\"\n   [(pc)]\n   \"\n {\n@@ -2512,7 +2513,7 @@ norm32: r25\n    && (TARGET_DIVIDE_INV_MINLAT\n        || TARGET_DIVIDE_INV20U || TARGET_DIVIDE_INV20L)\"\n   \"#\"\n-  \"&& no_new_pseudos\"\n+  \"&& !can_create_pseudo_p ()\"\n   [(pc)]\n   \"\n {\n@@ -2679,7 +2680,7 @@ label:\n    (clobber (match_operand:DF 9 \"fp_arith_reg_operand\" \"\"))\n    (clobber (match_operand:DF 10 \"fp_arith_reg_operand\" \"\"))\n    (clobber (match_operand:DF 11 \"fp_arith_reg_operand\" \"\"))]\n-  \"TARGET_SHMEDIA_FPU && TARGET_DIVIDE_INV_FP && no_new_pseudos\"\n+  \"TARGET_SHMEDIA_FPU && TARGET_DIVIDE_INV_FP && !can_create_pseudo_p ()\"\n   \"#\"\n   \"&& 1\"\n   [(set (match_dup 9) (float:DF (match_dup 1)))\n@@ -8689,8 +8690,8 @@ label:\n {\n   rtx insn, mem;\n \n-  operands[2] = no_new_pseudos ? operands[0] : gen_reg_rtx (Pmode);\n-  operands[3] = no_new_pseudos ? operands[0] : gen_reg_rtx (Pmode);\n+  operands[2] = !can_create_pseudo_p () ? operands[0] : gen_reg_rtx (Pmode);\n+  operands[3] = !can_create_pseudo_p () ? operands[0] : gen_reg_rtx (Pmode);\n \n   if (TARGET_SHMEDIA)\n     {\n@@ -8789,7 +8790,9 @@ label:\n   \"\n {\n   rtx gotoffsym, insn;\n-  rtx t = no_new_pseudos ? operands[0] : gen_reg_rtx (GET_MODE (operands[0]));\n+  rtx t = (!can_create_pseudo_p ()\n+\t   ? operands[0]\n+\t   : gen_reg_rtx (GET_MODE (operands[0]));\n \n   gotoffsym = gen_sym2GOTOFF (operands[1]);\n   PUT_MODE (gotoffsym, Pmode);\n@@ -8909,7 +8912,9 @@ mov.l\\\\t1f,r4\\\\n\\\\\n   \"\n {\n   rtx dtpoffsym, insn;\n-  rtx t = no_new_pseudos ? operands[0] : gen_reg_rtx (GET_MODE (operands[0]));\n+  rtx t = (!can_create_pseudo_p ()\n+\t   ? operands[0]\n+\t   : gen_reg_rtx (GET_MODE (operands[0]));\n \n   dtpoffsym = gen_sym2DTPOFF (operands[1]);\n   PUT_MODE (dtpoffsym, Pmode);\n@@ -9495,8 +9500,9 @@ mov.l\\\\t1f,r0\\\\n\\\\\n \n       reg = operands[0];\n       if (GET_MODE (operands[0]) != SImode)\n-\treg = no_new_pseudos ? gen_rtx_SUBREG (SImode, operands[0], 0)\n-\t\t\t     : gen_reg_rtx (SImode);\n+\treg = (!can_create_pseudo_p ()\n+\t       ? gen_rtx_SUBREG (SImode, operands[0], 0)\n+\t       : gen_reg_rtx (SImode));\n \n       switch (GET_MODE (sh_compare_op0))\n \t{\n@@ -9559,8 +9565,9 @@ mov.l\\\\t1f,r0\\\\n\\\\\n \n       reg = operands[0];\n       if (GET_MODE (operands[0]) != SImode)\n-\treg = no_new_pseudos ? gen_rtx_SUBREG (SImode, operands[0], 0)\n-\t\t\t     : gen_reg_rtx (SImode);\n+\treg = (!can_create_pseudo_p ()\n+\t       ? gen_rtx_SUBREG (SImode, operands[0], 0)\n+\t       : gen_reg_rtx (SImode));\n \n       switch (GET_MODE (sh_compare_op0))\n \t{\n@@ -9622,14 +9629,15 @@ mov.l\\\\t1f,r0\\\\n\\\\\n \n       reg = operands[0];\n       if (GET_MODE (operands[0]) != SImode)\n-\treg = no_new_pseudos ? gen_rtx_SUBREG (SImode, operands[0], 0)\n-\t\t\t     : gen_reg_rtx (SImode);\n+\treg = (!can_create_pseudo_p ()\n+\t       ? gen_rtx_SUBREG (SImode, operands[0], 0)\n+\t       : gen_reg_rtx (SImode));\n \n       switch (GET_MODE (sh_compare_op0))\n \t{\n \tcase SImode:\n \t  {\n-\t    tmp = no_new_pseudos ? reg : gen_reg_rtx (SImode);\n+\t    tmp = !can_create_pseudo_p () ? reg : gen_reg_rtx (SImode);\n \n \t    emit_insn (gen_cmpgtsi_media (tmp,\n \t\t\t\t\t  sh_compare_op0, sh_compare_op1));\n@@ -9639,7 +9647,7 @@ mov.l\\\\t1f,r0\\\\n\\\\\n \n \tcase DImode:\n \t  {\n-\t    tmp = no_new_pseudos ? reg : gen_reg_rtx (SImode);\n+\t    tmp = !can_create_pseudo_p () ? reg : gen_reg_rtx (SImode);\n \n \t    emit_insn (gen_cmpgtdi_media (tmp,\n \t\t\t\t\t  sh_compare_op0, sh_compare_op1));\n@@ -9689,8 +9697,9 @@ mov.l\\\\t1f,r0\\\\n\\\\\n \n       reg = operands[0];\n       if (GET_MODE (operands[0]) != SImode)\n-\treg = no_new_pseudos ? gen_rtx_SUBREG (SImode, operands[0], 0)\n-\t\t\t     : gen_reg_rtx (SImode);\n+\treg = (!can_create_pseudo_p () ?\n+\t       gen_rtx_SUBREG (SImode, operands[0], 0)\n+\t       : gen_reg_rtx (SImode));\n       sh_compare_op0 = force_reg (GET_MODE (sh_compare_op0), sh_compare_op0);\n       if (sh_compare_op1 != const0_rtx)\n \tsh_compare_op1 = force_reg (GET_MODE (sh_compare_op1) == VOIDmode\n@@ -9753,8 +9762,9 @@ mov.l\\\\t1f,r0\\\\n\\\\\n \tmode = GET_MODE (sh_compare_op1);\n       reg = operands[0];\n       if (GET_MODE (operands[0]) != SImode)\n-\treg = no_new_pseudos ? gen_rtx_SUBREG (SImode, operands[0], 0)\n-\t\t\t     : gen_reg_rtx (SImode);\n+\treg = (!can_create_pseudo_p ()\n+\t       ? gen_rtx_SUBREG (SImode, operands[0], 0)\n+\t       : gen_reg_rtx (SImode));\n       sh_compare_op0 = force_reg (mode, sh_compare_op0);\n       if (sh_compare_op1 != const0_rtx)\n \tsh_compare_op1 = force_reg (mode, sh_compare_op1);\n@@ -9763,7 +9773,7 @@ mov.l\\\\t1f,r0\\\\n\\\\\n \t{\n \tcase SImode:\n \t  {\n-\t    rtx tmp = no_new_pseudos ? reg : gen_reg_rtx (SImode);\n+\t    rtx tmp = !can_create_pseudo_p () ? reg : gen_reg_rtx (SImode);\n \n \t    emit_insn (gen_cmpgtsi_media (tmp,\n \t\t\t\t\t  sh_compare_op1, sh_compare_op0));\n@@ -9773,7 +9783,7 @@ mov.l\\\\t1f,r0\\\\n\\\\\n \n \tcase DImode:\n \t  {\n-\t    rtx tmp = no_new_pseudos ? reg : gen_reg_rtx (SImode);\n+\t    rtx tmp = !can_create_pseudo_p () ? reg : gen_reg_rtx (SImode);\n \n \t    emit_insn (gen_cmpgtdi_media (tmp,\n \t\t\t\t\t  sh_compare_op1, sh_compare_op0));\n@@ -9837,8 +9847,9 @@ mov.l\\\\t1f,r0\\\\n\\\\\n \n       reg = operands[0];\n       if (GET_MODE (operands[0]) == DImode)\n-\treg = no_new_pseudos ? gen_rtx_SUBREG (SImode, operands[0], 0)\n-\t\t\t     : gen_reg_rtx (SImode);\n+\treg = (!can_create_pseudo_p ()\n+\t       ? gen_rtx_SUBREG (SImode, operands[0], 0)\n+\t       : gen_reg_rtx (SImode));\n       sh_compare_op0 = force_reg (GET_MODE (sh_compare_op0), sh_compare_op0);\n       if (sh_compare_op1 != const0_rtx)\n \tsh_compare_op1 = force_reg (GET_MODE (sh_compare_op1) == VOIDmode\n@@ -9870,8 +9881,9 @@ mov.l\\\\t1f,r0\\\\n\\\\\n \n       reg = operands[0];\n       if (GET_MODE (operands[0]) == DImode)\n-\treg = no_new_pseudos ? gen_rtx_SUBREG (SImode, operands[0], 0)\n-\t\t\t     : gen_reg_rtx (SImode);\n+\treg = (!can_create_pseudo_p ()\n+\t       ? gen_rtx_SUBREG (SImode, operands[0], 0)\n+\t       : gen_reg_rtx (SImode));\n       sh_compare_op0 = force_reg (GET_MODE (sh_compare_op0), sh_compare_op0);\n       if (sh_compare_op1 != const0_rtx)\n \tsh_compare_op1 = force_reg (GET_MODE (sh_compare_op1) == VOIDmode\n@@ -9903,16 +9915,17 @@ mov.l\\\\t1f,r0\\\\n\\\\\n \n       reg = operands[0];\n       if (GET_MODE (operands[0]) != SImode)\n-\treg = no_new_pseudos ? gen_rtx_SUBREG (SImode, operands[0], 0)\n-\t\t\t     : gen_reg_rtx (SImode);\n+\treg = (!can_create_pseudo_p ()\n+\t       ? gen_rtx_SUBREG (SImode, operands[0], 0)\n+\t       : gen_reg_rtx (SImode));\n       sh_compare_op0 = force_reg (GET_MODE (sh_compare_op0), sh_compare_op0);\n       if (sh_compare_op1 != const0_rtx)\n \tsh_compare_op1 = force_reg (GET_MODE (sh_compare_op1) == VOIDmode\n \t\t\t\t    ? GET_MODE (sh_compare_op0)\n \t\t\t\t    : GET_MODE (sh_compare_op1),\n \t\t\t\t    sh_compare_op1);\n \n-      tmp = no_new_pseudos ? reg : gen_reg_rtx (SImode);\n+      tmp = !can_create_pseudo_p () ? reg : gen_reg_rtx (SImode);\n \n       emit_insn (gen_cmpgtudi_media (tmp, sh_compare_op0, sh_compare_op1));\n       emit_insn (gen_cmpeqdi_media (reg, tmp, const0_rtx));\n@@ -9938,16 +9951,17 @@ mov.l\\\\t1f,r0\\\\n\\\\\n \n       reg = operands[0];\n       if (GET_MODE (operands[0]) != SImode)\n-\treg = no_new_pseudos ? gen_rtx_SUBREG (SImode, operands[0], 0)\n-\t\t\t     : gen_reg_rtx (SImode);\n+\treg = (!can_create_pseudo_p ()\n+\t       ? gen_rtx_SUBREG (SImode, operands[0], 0)\n+\t       : gen_reg_rtx (SImode));\n       sh_compare_op0 = force_reg (GET_MODE (sh_compare_op0), sh_compare_op0);\n       if (sh_compare_op1 != const0_rtx)\n \tsh_compare_op1 = force_reg (GET_MODE (sh_compare_op1) == VOIDmode\n \t\t\t\t    ? GET_MODE (sh_compare_op0)\n \t\t\t\t    : GET_MODE (sh_compare_op1),\n \t\t\t\t    sh_compare_op1);\n \n-      tmp = no_new_pseudos ? operands[0] : gen_reg_rtx (SImode);\n+      tmp = !can_create_pseudo_p () ? operands[0] : gen_reg_rtx (SImode);\n \n       emit_insn (gen_cmpgtudi_media (tmp, sh_compare_op1, sh_compare_op0));\n       emit_insn (gen_cmpeqdi_media (reg, tmp, const0_rtx));\n@@ -9987,8 +10001,9 @@ mov.l\\\\t1f,r0\\\\n\\\\\n \n       reg = operands[0];\n       if (GET_MODE (operands[0]) != SImode)\n-\treg = no_new_pseudos ? gen_rtx_SUBREG (SImode, operands[0], 0)\n-\t\t\t     : gen_reg_rtx (SImode);\n+\treg = (!can_create_pseudo_p ()\n+\t       ? gen_rtx_SUBREG (SImode, operands[0], 0)\n+\t       : gen_reg_rtx (SImode));\n       if (! TARGET_SHMEDIA_FPU\n \t  && GET_MODE (sh_compare_op0) != DImode\n \t  && GET_MODE (sh_compare_op0) != SImode)\n@@ -10001,7 +10016,7 @@ mov.l\\\\t1f,r0\\\\n\\\\\n \t\t\t\t    : GET_MODE (sh_compare_op1),\n \t\t\t\t    sh_compare_op1);\n \n-      tmp = no_new_pseudos ? reg : gen_reg_rtx (SImode);\n+      tmp = !can_create_pseudo_p () ? reg : gen_reg_rtx (SImode);\n \n       emit_insn (gen_seq (tmp));\n       emit_insn (gen_cmpeqdi_media (reg, tmp, const0_rtx));"}, {"sha": "ef2ba7c8219e13e1f97c57852ea582516007fbe2", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3a134196fcae83a0fd93d20be96c48de8e912e8/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3a134196fcae83a0fd93d20be96c48de8e912e8/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=b3a134196fcae83a0fd93d20be96c48de8e912e8", "patch": "@@ -3088,7 +3088,7 @@ legitimize_tls_address (rtx addr)\n {\n   rtx temp1, temp2, temp3, ret, o0, got, insn;\n \n-  gcc_assert (! no_new_pseudos);\n+  gcc_assert (can_create_pseudo_p ());\n \n   if (GET_CODE (addr) == SYMBOL_REF)\n     switch (SYMBOL_REF_TLS_MODEL (addr))\n@@ -8598,7 +8598,6 @@ sparc_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,\n \n   reload_completed = 1;\n   epilogue_completed = 1;\n-  no_new_pseudos = 1;\n \n   emit_note (NOTE_INSN_PROLOGUE_END);\n \n@@ -8784,7 +8783,6 @@ sparc_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,\n \n   reload_completed = 0;\n   epilogue_completed = 0;\n-  no_new_pseudos = 0;\n }\n \n /* Return true if sparc_output_mi_thunk would be able to output the"}, {"sha": "0177970644c6629e07aa6dda6ea795ddc0463230", "filename": "gcc/config/sparc/sparc.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3a134196fcae83a0fd93d20be96c48de8e912e8/gcc%2Fconfig%2Fsparc%2Fsparc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3a134196fcae83a0fd93d20be96c48de8e912e8/gcc%2Fconfig%2Fsparc%2Fsparc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.md?ref=b3a134196fcae83a0fd93d20be96c48de8e912e8", "patch": "@@ -1845,7 +1845,7 @@\n {\n   current_function_uses_pic_offset_table = 1;\n   operands[2] = gen_rtx_SYMBOL_REF (Pmode, \"_GLOBAL_OFFSET_TABLE_\");\n-  if (no_new_pseudos)\n+  if (!can_create_pseudo_p ())\n     {\n       operands[3] = operands[0];\n       operands[4] = operands[0];\n@@ -1994,7 +1994,7 @@\n {\n   current_function_uses_pic_offset_table = 1;\n   operands[2] = gen_rtx_SYMBOL_REF (Pmode, \"_GLOBAL_OFFSET_TABLE_\");\n-  if (no_new_pseudos)\n+  if (!can_create_pseudo_p ())\n     {\n       operands[3] = operands[0];\n       operands[4] = operands[0];"}, {"sha": "3b7baafc4aab18b888570618fd614c4ba0718ab8", "filename": "gcc/config/spu/spu.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3a134196fcae83a0fd93d20be96c48de8e912e8/gcc%2Fconfig%2Fspu%2Fspu.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3a134196fcae83a0fd93d20be96c48de8e912e8/gcc%2Fconfig%2Fspu%2Fspu.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fspu.c?ref=b3a134196fcae83a0fd93d20be96c48de8e912e8", "patch": "@@ -1420,7 +1420,7 @@ spu_split_immediate (rtx * ops)\n \trtx to, hi, lo;\n \tint i;\n \tconstant_to_array (mode, ops[1], arrhi);\n-\tto = no_new_pseudos ? ops[0] : gen_reg_rtx (mode);\n+\tto = !can_create_pseudo_p () ? ops[0] : gen_reg_rtx (mode);\n \tfor (i = 0; i < 16; i += 4)\n \t  {\n \t    arrlo[i + 2] = arrhi[i + 2];"}, {"sha": "689efa52f37afa2983317b13eb8a6dd31b623804", "filename": "gcc/rtl.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3a134196fcae83a0fd93d20be96c48de8e912e8/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3a134196fcae83a0fd93d20be96c48de8e912e8/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=b3a134196fcae83a0fd93d20be96c48de8e912e8", "patch": "@@ -1958,6 +1958,11 @@ extern int epilogue_completed;\n \n extern int reload_in_progress;\n \n+/* This macro indicates whether you may create a new\n+   pseudo-register.  */\n+\n+#define can_create_pseudo_p() (!reload_in_progress && !reload_completed)\n+\n #ifdef STACK_REGS\n /* Nonzero after end of regstack pass.\n    Set to 1 or 0 by reg-stack.c.  */"}]}