{"sha": "6ef4215401ab8001886973790886dfd75446c037", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmVmNDIxNTQwMWFiODAwMTg4Njk3Mzc5MDg4NmRmZDc1NDQ2YzAzNw==", "commit": {"author": {"name": "Tobias Schl\u00fcter", "email": "tobias.schlueter@physik.uni-muenchen.de", "date": "2004-06-15T21:50:50Z"}, "committer": {"name": "Tobias Schl\u00fcter", "email": "tobi@gcc.gnu.org", "date": "2004-06-15T21:50:50Z"}, "message": "re PR fortran/15962 (constant expression not recognized as such)\n\nfortran/\nPR fortran/15962\n* match.c (match_case_selector): Call gfc_match_init_expr\ninstead of gfc_match_expr.\n* resolve.c (validate_case_label_expr): No need to check for\nconstant, since it wouldn't have been matched with the fix to\nmatch.c.\ntestsuite/\nPR fortran/15962\n* gfortran.fortran-torture/execute/select_1.f90: New test.\n\nFrom-SVN: r83202", "tree": {"sha": "91cec34fb614da23cba18dd77a187546799cb659", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/91cec34fb614da23cba18dd77a187546799cb659"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6ef4215401ab8001886973790886dfd75446c037", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6ef4215401ab8001886973790886dfd75446c037", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6ef4215401ab8001886973790886dfd75446c037", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6ef4215401ab8001886973790886dfd75446c037/comments", "author": {"login": "TobiSchluter", "id": 11887541, "node_id": "MDQ6VXNlcjExODg3NTQx", "avatar_url": "https://avatars.githubusercontent.com/u/11887541?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TobiSchluter", "html_url": "https://github.com/TobiSchluter", "followers_url": "https://api.github.com/users/TobiSchluter/followers", "following_url": "https://api.github.com/users/TobiSchluter/following{/other_user}", "gists_url": "https://api.github.com/users/TobiSchluter/gists{/gist_id}", "starred_url": "https://api.github.com/users/TobiSchluter/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TobiSchluter/subscriptions", "organizations_url": "https://api.github.com/users/TobiSchluter/orgs", "repos_url": "https://api.github.com/users/TobiSchluter/repos", "events_url": "https://api.github.com/users/TobiSchluter/events{/privacy}", "received_events_url": "https://api.github.com/users/TobiSchluter/received_events", "type": "User", "site_admin": false}, "committer": {"login": "TobiSchluter", "id": 11887541, "node_id": "MDQ6VXNlcjExODg3NTQx", "avatar_url": "https://avatars.githubusercontent.com/u/11887541?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TobiSchluter", "html_url": "https://github.com/TobiSchluter", "followers_url": "https://api.github.com/users/TobiSchluter/followers", "following_url": "https://api.github.com/users/TobiSchluter/following{/other_user}", "gists_url": "https://api.github.com/users/TobiSchluter/gists{/gist_id}", "starred_url": "https://api.github.com/users/TobiSchluter/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TobiSchluter/subscriptions", "organizations_url": "https://api.github.com/users/TobiSchluter/orgs", "repos_url": "https://api.github.com/users/TobiSchluter/repos", "events_url": "https://api.github.com/users/TobiSchluter/events{/privacy}", "received_events_url": "https://api.github.com/users/TobiSchluter/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0173bb6f2d715c4c3839c17e26a38bd522e07fa4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0173bb6f2d715c4c3839c17e26a38bd522e07fa4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0173bb6f2d715c4c3839c17e26a38bd522e07fa4"}], "stats": {"total": 176, "additions": 36, "deletions": 140}, "files": [{"sha": "ef5d72bac394b3cfb50c47707ff0cbe433bc0db9", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ef4215401ab8001886973790886dfd75446c037/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ef4215401ab8001886973790886dfd75446c037/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=6ef4215401ab8001886973790886dfd75446c037", "patch": "@@ -1,3 +1,12 @@\n+2004-06-15  Tobias Schlueter  <tobias.schlueter@physik.uni-muenchen.de>\n+\n+\tPR fortran/15962\n+\t* match.c (match_case_selector): Call gfc_match_init_expr\n+\tinstead of gfc_match_expr.\n+\t* resolve.c (validate_case_label_expr): No need to check for\n+\tconstant, since it wouldn't have been matched with the fix to\n+\tmatch.c.\n+\n 2004-06-14  Tobias Schlueter  <tobias.schlueter@physik.uni-muenchen.de>\n \n \tPR fortran/15211"}, {"sha": "bc2379db49c21461e9e617d87fac6754706c5599", "filename": "gcc/fortran/match.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ef4215401ab8001886973790886dfd75446c037/gcc%2Ffortran%2Fmatch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ef4215401ab8001886973790886dfd75446c037/gcc%2Ffortran%2Fmatch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.c?ref=6ef4215401ab8001886973790886dfd75446c037", "patch": "@@ -3102,7 +3102,7 @@ match_case_selector (gfc_case ** cp)\n \n   if (gfc_match_char (':') == MATCH_YES)\n     {\n-      m = gfc_match_expr (&c->high);\n+      m = gfc_match_init_expr (&c->high);\n       if (m == MATCH_NO)\n \tgoto need_expr;\n       if (m == MATCH_ERROR)\n@@ -3111,7 +3111,7 @@ match_case_selector (gfc_case ** cp)\n \n   else\n     {\n-      m = gfc_match_expr (&c->low);\n+      m = gfc_match_init_expr (&c->low);\n       if (m == MATCH_ERROR)\n \tgoto cleanup;\n       if (m == MATCH_NO)\n@@ -3123,7 +3123,7 @@ match_case_selector (gfc_case ** cp)\n \tc->high = c->low;\n       else\n \t{\n-\t  m = gfc_match_expr (&c->high);\n+\t  m = gfc_match_init_expr (&c->high);\n \t  if (m == MATCH_ERROR)\n \t    goto cleanup;\n \t  /* MATCH_NO is fine.  It's OK if nothing is there!  */\n@@ -3134,7 +3134,7 @@ match_case_selector (gfc_case ** cp)\n   return MATCH_YES;\n \n need_expr:\n-  gfc_error (\"Expected expression in CASE at %C\");\n+  gfc_error (\"Expected initialization expression in CASE at %C\");\n \n cleanup:\n   free_case (c);"}, {"sha": "b19721f1432e187dcc82f24127de6192e1a7a492", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ef4215401ab8001886973790886dfd75446c037/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ef4215401ab8001886973790886dfd75446c037/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=6ef4215401ab8001886973790886dfd75446c037", "patch": "@@ -2586,13 +2586,6 @@ validate_case_label_expr (gfc_expr * e, gfc_expr * case_expr)\n \n   if (e == NULL) return SUCCESS;\n \n-  if (e->expr_type != EXPR_CONSTANT)\n-    {\n-      gfc_error (\"Expression in CASE statement at %L must be a constant\",\n-\t\t &e->where);\n-      return FAILURE;\n-    }\n-\n   if (e->ts.type != case_ts.type)\n     {\n       gfc_error (\"Expression in CASE statement at %L must be of type %s\","}, {"sha": "2d74fb607519ec1fb81ec8c2dc840657566dc937", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ef4215401ab8001886973790886dfd75446c037/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ef4215401ab8001886973790886dfd75446c037/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=6ef4215401ab8001886973790886dfd75446c037", "patch": "@@ -1,3 +1,8 @@\n+2004-06-15  Tobias Schlueter  <tobias.schlueter@physik.uni-muenchen.de>\n+\n+\tPR fortran/15962\n+\t* gfortran.fortran-torture/execute/select_1.f90: New test.\n+\n 2004-06-15  Paul Brook  <paul@codesourcery.com>\n \n \t* gcc.dg/arm-mmx-1.c: Use asm to clobber registers."}, {"sha": "b6ed5befedfa548dbf6192fa54cd29813effa044", "filename": "gcc/testsuite/gfortran.fortran-torture/execute/select_1.f90", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ef4215401ab8001886973790886dfd75446c037/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fexecute%2Fselect_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ef4215401ab8001886973790886dfd75446c037/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fexecute%2Fselect_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fexecute%2Fselect_1.f90?ref=6ef4215401ab8001886973790886dfd75446c037", "patch": "@@ -0,0 +1,17 @@\n+! from PR 15962, we used to require constant expressions instead of\n+! initialization expressions in case-statements\n+function x(k)\n+integer :: k\n+integer :: x\n+integer, parameter :: i(2) = (/1,2/)\n+\n+select case(k)\n+case (1:size(i))\n+    x = i(k)\n+case default\n+    x = 0\n+end select\n+end function\n+\n+if (x(2).NE.2 .OR. x(11).NE.0) call abort()\n+end"}, {"sha": "61ff48575616cc37f3dd236a2690b14fa06e4982", "filename": "gcc/testsuite/lib/f-torture.exp", "status": "modified", "additions": 1, "deletions": 129, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ef4215401ab8001886973790886dfd75446c037/gcc%2Ftestsuite%2Flib%2Ff-torture.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ef4215401ab8001886973790886dfd75446c037/gcc%2Ftestsuite%2Flib%2Ff-torture.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Ff-torture.exp?ref=6ef4215401ab8001886973790886dfd75446c037", "patch": "@@ -124,135 +124,7 @@ proc f-torture-compile { src option } {\n #\n # f-torture-execute -- utility to compile and execute a testcase\n #\n-# SRC is the full pathname of the testcase.\n-#\n-# If the testcase has an associated .x file, we source that to run the\n-# test instead.  We use .x so that we don't lengthen the existing filename\n-# to more than 14 chars.\n-#\n-proc f-torture-execute { src } {\n-    global tmpdir tool srcdir output compiler_conditional_xfail_data\n-\n-    # Check for alternate driver.\n-    if [file exists [file rootname $src].x] {\n-\tverbose \"Using alternate driver [file rootname [file tail $src]].x\" 2\n-\tset done_p 0\n-\tcatch \"set done_p \\[source [file rootname $src].x\\]\"\n-\tif { $done_p } {\n-\t    return\n-\t}\n-    }\n-   \n-    # Look for a loop within the source code - if we don't find one,\n-    # don't pass -funroll[-all]-loops.\n-    global torture_with_loops torture_without_loops\n-    if [expr [search_for_re $src \"do *\\[0-9\\]\"]+[search_for_re $src \"end *do\"]] then {\n-\tset option_list $torture_with_loops\n-    } else {\n-\tset option_list $torture_without_loops\n-    }\n-\n-    set executable $tmpdir/[file tail [file rootname $src].x]\n-\n-    regsub \"^$srcdir/?\" $src \"\" testcase\n-    # If we couldn't rip $srcdir out of `src' then just do the best we can.\n-    # The point is to reduce the unnecessary noise in the logs.  Don't strip\n-    # out too much because different testcases with the same name can confuse\n-    # `test-tool'.\n-    if [string match \"/*\" $testcase] {\n-\tset testcase \"[file tail [file dirname $src]]/[file tail $src]\"\n-    }\n-\n-    foreach option $option_list {\n-\t# torture_{compile,execute}_xfail are set by the .x script\n-\t# (if present)\n-\tif [info exists torture_compile_xfail] {\n-\t    setup_xfail $torture_compile_xfail\n-\t}\n-\n-\t# torture_execute_before_{compile,execute} can be set by the .x script\n-\t# (if present)\n-\tif [info exists torture_eval_before_compile] {\n-            set ignore_me [eval $torture_eval_before_compile]\n-\t}\n-\n-\tremote_file build delete $executable\n-\tverbose \"Testing $testcase, $option\" 1\n-\n-\tset options \"\"\n-\tlappend options \"additional_flags=-w $option\"\n-\tset comp_output [g77_target_compile \"$src\" \"$executable\" executable $options];\n-\n-\t# Set a few common compiler messages.\n-\tset fatal_signal \"*77*: Internal compiler error: program*got fatal signal\"\n-\t\n-\tif [string match \"$fatal_signal 6\" $comp_output] then {\n-\t    g77_fail $testcase \"Got Signal 6, $option\"\n-\t    remote_file build delete $executable\n-\t    continue\n-\t}\n-\t\n-\tif [string match \"$fatal_signal 11\" $comp_output] then {\n-\t    g77_fail $testcase \"Got Signal 11, $option\"\n-\t    remote_file build delete $executable\n-\t    continue\n-\t}\n-\t\n-\t# We shouldn't get these because of -w, but just in case.\n-\tif [string match \"*77*:*warning:*\" $comp_output] then {\n-\t    warning \"$testcase: (with warnings) $option\"\n-\t    send_log \"$comp_output\\n\"\n-\t    unresolved \"$testcase, $option\"\n-\t    remote_file build delete $executable\n-\t    continue\n-\t}\n-\t\n-\tset comp_output [prune_warnings $comp_output]\n-\t\n-\tset unsupported_message [g77_check_unsupported_p $comp_output]\n-\n-\tif { $unsupported_message != \"\" } {\n-\t    unsupported \"$testcase: $unsupported_message\"\n-\t    continue\n-\t} elseif ![file exists $executable] {\n-\t    if ![is3way] {\n-\t\tfail \"$testcase compilation, $option\"\n-\t\tuntested \"$testcase execution, $option\"\n-\t\tcontinue\n-\t    } else {\n-\t\t# FIXME: since we can't test for the existance of a remote\n-\t\t# file without short of doing an remote file list, we assume\n-\t\t# that since we got no output, it must have compiled.\n-\t\tpass \"$testcase compilation, $option\"\t\t\n-\t    }\n-\t} else {\n-\t    pass \"$testcase compilation, $option\"\n-\t}\n-\n-\t# See if this source file uses \"long long\" types, if it does, and\n-\t# no_long_long is set, skip execution of the test.\n-\tif [target_info exists no_long_long] then {\n-\t    if [expr [search_for_re $src \"integer\\*8\"]] then {\n-\t\tuntested \"$testcase execution, $option\"\n-\t\tcontinue\n-\t    }\n-\t}\n-\n-\tif [info exists torture_execute_xfail] {\n-\t    setup_xfail $torture_execute_xfail\n-\t}\n-\n-\tif [info exists torture_eval_before_execute] {\n-            set ignore_me [eval $torture_eval_before_execute]\n-\t}\n-\n-\tset result [g77_load \"$executable\" \"\" \"\"]\n-\tset status [lindex $result 0];\n-\tset output [lindex $result 1];\n-        if { $status == \"pass\" } {\n-\t    remote_file build delete $executable\n-        }\n-\t$status \"$testcase execution, $option\"\n+# SRC is the full pathname of the\n     }\n }\n "}]}