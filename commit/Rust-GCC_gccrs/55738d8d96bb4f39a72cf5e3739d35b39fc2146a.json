{"sha": "55738d8d96bb4f39a72cf5e3739d35b39fc2146a", "node_id": "C_kwDOANBUbNoAKDU1NzM4ZDhkOTZiYjRmMzlhNzJjZjVlMzczOWQzNWIzOWZjMjE0NmE", "commit": {"author": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2022-09-20T22:19:30Z"}, "committer": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2022-09-22T18:48:29Z"}, "message": "Convert CFN_CTZ builtins to range-ops.\n\n\t* gimple-range-fold.cc (range_of_builtin_int_call): Remove case\n\tfor CFN_CTZ.\n\t* gimple-range-op.cc (class cfn_ctz): New.\n\t(gimple_range_op_handler::maybe_builtin_call): Set arguments.", "tree": {"sha": "e97fd4141f4d1876f2a450a1d391512f870624d3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e97fd4141f4d1876f2a450a1d391512f870624d3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/55738d8d96bb4f39a72cf5e3739d35b39fc2146a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/55738d8d96bb4f39a72cf5e3739d35b39fc2146a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/55738d8d96bb4f39a72cf5e3739d35b39fc2146a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/55738d8d96bb4f39a72cf5e3739d35b39fc2146a/comments", "author": null, "committer": null, "parents": [{"sha": "ae1669a98656cca594fcd2fef6bd2cd7308a361f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ae1669a98656cca594fcd2fef6bd2cd7308a361f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ae1669a98656cca594fcd2fef6bd2cd7308a361f"}], "stats": {"total": 140, "additions": 80, "deletions": 60}, "files": [{"sha": "96a138a7a022c23852e601e8d5e9a3ddcbeb95ac", "filename": "gcc/gimple-range-fold.cc", "status": "modified", "additions": 1, "deletions": 60, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55738d8d96bb4f39a72cf5e3739d35b39fc2146a/gcc%2Fgimple-range-fold.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55738d8d96bb4f39a72cf5e3739d35b39fc2146a/gcc%2Fgimple-range-fold.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-fold.cc?ref=55738d8d96bb4f39a72cf5e3739d35b39fc2146a", "patch": "@@ -917,7 +917,7 @@ fold_using_range::range_of_builtin_int_call (irange &r, gcall *call,\n \n   tree type = gimple_range_type (call);\n   tree arg;\n-  int mini, maxi, zerov = 0, prec;\n+  int prec;\n   scalar_int_mode mode;\n \n   switch (func)\n@@ -926,65 +926,6 @@ fold_using_range::range_of_builtin_int_call (irange &r, gcall *call,\n       r.set (build_zero_cst (type), build_one_cst (type));\n       return true;\n \n-    CASE_CFN_CTZ:\n-      // __builtin_ctz* return [0, prec-1], except for when the\n-      // argument is 0, but that is undefined behavior.\n-      //\n-      // For __builtin_ctz* consider argument of 0 always undefined\n-      // behavior, for internal fns depending on CTZ_DEFINED_VALUE_AT_ZERO.\n-      arg = gimple_call_arg (call, 0);\n-      prec = TYPE_PRECISION (TREE_TYPE (arg));\n-      mini = 0;\n-      maxi = prec - 1;\n-      mode = SCALAR_INT_TYPE_MODE (TREE_TYPE (arg));\n-      if (gimple_call_internal_p (call))\n-\t{\n-\t  if (optab_handler (ctz_optab, mode) != CODE_FOR_nothing\n-\t      && CTZ_DEFINED_VALUE_AT_ZERO (mode, zerov) == 2)\n-\t    {\n-\t      // Handle only the two common values.\n-\t      if (zerov == -1)\n-\t\tmini = -1;\n-\t      else if (zerov == prec)\n-\t\tmaxi = prec;\n-\t      else\n-\t\t// Magic value to give up, unless we can prove arg is non-zero.\n-\t\tmini = -2;\n-\t    }\n-\t}\n-      src.get_operand (r, arg);\n-      if (!r.undefined_p ())\n-\t{\n-\t  // If arg is non-zero, then use [0, prec - 1].\n-\t  if (!range_includes_zero_p (&r))\n-\t    {\n-\t      mini = 0;\n-\t      maxi = prec - 1;\n-\t    }\n-\t  // If some high bits are known to be zero, we can decrease\n-\t  // the maximum.\n-\t  wide_int max = r.upper_bound ();\n-\t  if (max == 0)\n-\t    {\n-\t      // Argument is [0, 0].  If CTZ_DEFINED_VALUE_AT_ZERO\n-\t      // is 2 with value -1 or prec, return [-1, -1] or [prec, prec].\n-\t      // Otherwise ignore the range.\n-\t      if (mini == -1)\n-\t\tmaxi = -1;\n-\t      else if (maxi == prec)\n-\t\tmini = prec;\n-\t    }\n-\t  // If value at zero is prec and 0 is in the range, we can't lower\n-\t  // the upper bound.  We could create two separate ranges though,\n-\t  // [0,floor_log2(max)][prec,prec] though.\n-\t  else if (maxi != prec)\n-\t    maxi = wi::floor_log2 (max);\n-\t}\n-      if (mini == -2)\n-\tbreak;\n-      r.set (build_int_cst (type, mini), build_int_cst (type, maxi));\n-      return true;\n-\n     CASE_CFN_CLRSB:\n       arg = gimple_call_arg (call, 0);\n       prec = TYPE_PRECISION (TREE_TYPE (arg));"}, {"sha": "801c2bb235e23051d61bbb74ccffa5108760fd3e", "filename": "gcc/gimple-range-op.cc", "status": "modified", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55738d8d96bb4f39a72cf5e3739d35b39fc2146a/gcc%2Fgimple-range-op.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55738d8d96bb4f39a72cf5e3739d35b39fc2146a/gcc%2Fgimple-range-op.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-op.cc?ref=55738d8d96bb4f39a72cf5e3739d35b39fc2146a", "patch": "@@ -489,6 +489,76 @@ cfn_clz::fold_range (irange &r, tree type, const irange &lh,\n   return true;\n }\n \n+// Implement range operator for CFN_BUILT_IN_CTZ\n+class cfn_ctz : public range_operator\n+{\n+public:\n+  cfn_ctz (bool internal) { m_gimple_call_internal_p = internal; }\n+  using range_operator::fold_range;\n+  virtual bool fold_range (irange &r, tree type, const irange &lh,\n+\t\t\t   const irange &, relation_kind) const;\n+private:\n+  bool m_gimple_call_internal_p;\n+} op_cfn_ctz (false), op_cfn_ctz_internal (true);\n+\n+bool\n+cfn_ctz::fold_range (irange &r, tree type, const irange &lh,\n+\t\t     const irange &, relation_kind) const\n+{\n+  if (lh.undefined_p ())\n+    return false;\n+  int prec = TYPE_PRECISION (lh.type ());\n+  int mini = 0;\n+  int maxi = prec - 1;\n+  int zerov = 0;\n+  scalar_int_mode mode = SCALAR_INT_TYPE_MODE (lh.type ());\n+\n+  if (m_gimple_call_internal_p)\n+    {\n+      if (optab_handler (ctz_optab, mode) != CODE_FOR_nothing\n+\t  && CTZ_DEFINED_VALUE_AT_ZERO (mode, zerov) == 2)\n+\t{\n+\t  // Handle only the two common values.\n+\t  if (zerov == -1)\n+\t    mini = -1;\n+\t  else if (zerov == prec)\n+\t    maxi = prec;\n+\t  else\n+\t    // Magic value to give up, unless we can prove arg is non-zero.\n+\t    mini = -2;\n+\t}\n+    }\n+  // If arg is non-zero, then use [0, prec - 1].\n+  if (!range_includes_zero_p (&lh))\n+    {\n+      mini = 0;\n+      maxi = prec - 1;\n+    }\n+  // If some high bits are known to be zero, we can decrease\n+  // the maximum.\n+  wide_int max = lh.upper_bound ();\n+  if (max == 0)\n+    {\n+      // Argument is [0, 0].  If CTZ_DEFINED_VALUE_AT_ZERO\n+      // is 2 with value -1 or prec, return [-1, -1] or [prec, prec].\n+      // Otherwise ignore the range.\n+      if (mini == -1)\n+\tmaxi = -1;\n+      else if (maxi == prec)\n+\tmini = prec;\n+    }\n+  // If value at zero is prec and 0 is in the range, we can't lower\n+  // the upper bound.  We could create two separate ranges though,\n+  // [0,floor_log2(max)][prec,prec] though.\n+  else if (maxi != prec)\n+    maxi = wi::floor_log2 (max);\n+\n+  if (mini == -2)\n+    return false;\n+  r.set (build_int_cst (type, mini), build_int_cst (type, maxi));\n+  return true;\n+}\n+\n // Set up a gimple_range_op_handler for any built in function which can be\n // supported via range-ops.\n \n@@ -553,6 +623,15 @@ gimple_range_op_handler::maybe_builtin_call ()\n \tm_int = &op_cfn_clz;\n       break;\n \n+    CASE_CFN_CTZ:\n+      m_op1 = gimple_call_arg (call, 0);\n+      m_valid = true;\n+      if (gimple_call_internal_p (call))\n+\tm_int = &op_cfn_ctz_internal;\n+      else\n+\tm_int = &op_cfn_ctz;\n+      break;\n+\n     default:\n       break;\n     }"}]}