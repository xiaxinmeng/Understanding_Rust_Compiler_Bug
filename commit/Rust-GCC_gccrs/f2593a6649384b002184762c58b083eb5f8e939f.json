{"sha": "f2593a6649384b002184762c58b083eb5f8e939f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjI1OTNhNjY0OTM4NGIwMDIxODQ3NjJjNThiMDgzZWI1ZjhlOTM5Zg==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2003-08-04T23:42:48Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2003-08-04T23:42:48Z"}, "message": "fold-const.c (fold <PLUS_EXPR>): Transform x+x into x*2.0.\n\n\n\t* fold-const.c (fold <PLUS_EXPR>): Transform x+x into x*2.0.\n\tOptimize x*c+x and x+x*c into x*(c+1) and x*c1+x*c2 into x*(c1+c2)\n\tfor floating point expressions with -ffast-math.\n\t(fold <MULT_EXPR>): Don't transform x*2.0 into x+x.\n\t* expmed.c (expand_mult): Wrap long line.  Expand x*2.0 as x+x.\n\n\t* gcc.dg/20030804-1.c: New test case.\n\nFrom-SVN: r70158", "tree": {"sha": "9617a20782252283684d9c8639c9ad8e7fbf7873", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9617a20782252283684d9c8639c9ad8e7fbf7873"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f2593a6649384b002184762c58b083eb5f8e939f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f2593a6649384b002184762c58b083eb5f8e939f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f2593a6649384b002184762c58b083eb5f8e939f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f2593a6649384b002184762c58b083eb5f8e939f/comments", "author": null, "committer": null, "parents": [{"sha": "29019803327d246f686bcc22d9d95b0e3cdc244d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/29019803327d246f686bcc22d9d95b0e3cdc244d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/29019803327d246f686bcc22d9d95b0e3cdc244d"}], "stats": {"total": 191, "additions": 175, "deletions": 16}, "files": [{"sha": "daf0bec3424e173396bbcf0d962b31839bcc515e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2593a6649384b002184762c58b083eb5f8e939f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2593a6649384b002184762c58b083eb5f8e939f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f2593a6649384b002184762c58b083eb5f8e939f", "patch": "@@ -1,3 +1,11 @@\n+2003-08-04  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* fold-const.c (fold <PLUS_EXPR>): Transform x+x into x*2.0.\n+\tOptimize x*c+x and x+x*c into x*(c+1) and x*c1+x*c2 into x*(c1+c2)\n+\tfor floating point expressions with -ffast-math.\n+\t(fold <MULT_EXPR>): Don't transform x*2.0 into x+x.\n+\t* expmed.c (expand_mult): Wrap long line.  Expand x*2.0 as x+x.\n+\n 2003-08-04  Roger Sayle  <roger@eyesopen.com>\n \n \t* c-common.c (flag_noniso_default_format_attributes): Delete."}, {"sha": "89ecd0c198255e2bcff851e9a0085686593670fc", "filename": "gcc/expmed.c", "status": "modified", "additions": 24, "deletions": 1, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2593a6649384b002184762c58b083eb5f8e939f/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2593a6649384b002184762c58b083eb5f8e939f/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=f2593a6649384b002184762c58b083eb5f8e939f", "patch": "@@ -2300,7 +2300,8 @@ synth_mult (struct algorithm *alg_out, unsigned HOST_WIDE_INT t,\n    you should swap the two operands if OP0 would be constant.  */\n \n rtx\n-expand_mult (enum machine_mode mode, rtx op0, rtx op1, rtx target, int unsignedp)\n+expand_mult (enum machine_mode mode, rtx op0, rtx op1, rtx target,\n+\t     int unsignedp)\n {\n   rtx const_op1 = op1;\n \n@@ -2514,6 +2515,28 @@ expand_mult (enum machine_mode mode, rtx op0, rtx op1, rtx target, int unsignedp\n \t}\n     }\n \n+  if (GET_CODE (op0) == CONST_DOUBLE)\n+    {\n+      rtx temp = op0;\n+      op0 = op1;\n+      op1 = temp;\n+    }\n+\n+  /* Expand x*2.0 as x+x.  */\n+  if (GET_CODE (op1) == CONST_DOUBLE\n+      && GET_MODE_CLASS (mode) == MODE_FLOAT)\n+    {\n+      REAL_VALUE_TYPE d;\n+      REAL_VALUE_FROM_CONST_DOUBLE (d, op1);\n+\n+      if (REAL_VALUES_EQUAL (d, dconst2))\n+\t{\n+\t  op0 = force_reg (GET_MODE (op0), op0);\n+\t  return expand_binop (mode, add_optab, op0, op0,\n+\t\t\t       target, unsignedp, OPTAB_LIB_WIDEN);\n+\t}\n+    }\n+\n   /* This used to use umul_optab if unsigned, but for non-widening multiply\n      there is no difference between signed and unsigned.  */\n   op0 = expand_binop (mode,"}, {"sha": "4dd606f68bf569248b39a711486dfa0faa8638fa", "filename": "gcc/fold-const.c", "status": "modified", "additions": 64, "deletions": 15, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2593a6649384b002184762c58b083eb5f8e939f/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2593a6649384b002184762c58b083eb5f8e939f/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=f2593a6649384b002184762c58b083eb5f8e939f", "patch": "@@ -5659,14 +5659,72 @@ fold (tree expr)\n \t\t\t\t    same));\n \t    }\n \t}\n+      else\n+\t{\n+\t  /* See if ARG1 is zero and X + ARG1 reduces to X.  */\n+\t  if (fold_real_zero_addition_p (TREE_TYPE (arg0), arg1, 0))\n+\t    return non_lvalue (convert (type, arg0));\n \n-      /* See if ARG1 is zero and X + ARG1 reduces to X.  */\n-      else if (fold_real_zero_addition_p (TREE_TYPE (arg0), arg1, 0))\n-\treturn non_lvalue (convert (type, arg0));\n+\t  /* Likewise if the operands are reversed.  */\n+\t  if (fold_real_zero_addition_p (TREE_TYPE (arg1), arg0, 0))\n+\t    return non_lvalue (convert (type, arg1));\n \n-      /* Likewise if the operands are reversed.  */\n-      else if (fold_real_zero_addition_p (TREE_TYPE (arg1), arg0, 0))\n-\treturn non_lvalue (convert (type, arg1));\n+\t  /* Convert x+x into x*2.0.  */\n+\t  if (operand_equal_p (arg0, arg1, 0))\n+\t    return fold (build (MULT_EXPR, type, arg0,\n+\t\t\t\tbuild_real (type, dconst2)));\n+\n+\t  /* Convert x*c+x into x*(c+1).  */\n+\t  if (flag_unsafe_math_optimizations\n+\t      && TREE_CODE (arg0) == MULT_EXPR\n+\t      && TREE_CODE (TREE_OPERAND (arg0, 1)) == REAL_CST\n+\t      && ! TREE_CONSTANT_OVERFLOW (TREE_OPERAND (arg0, 1))\n+\t      && operand_equal_p (TREE_OPERAND (arg0, 0), arg1, 0))\n+\t    {\n+\t      REAL_VALUE_TYPE c;\n+\n+\t      c = TREE_REAL_CST (TREE_OPERAND (arg0, 1));\n+\t      real_arithmetic (&c, PLUS_EXPR, &c, &dconst1);\n+\t      return fold (build (MULT_EXPR, type, arg1,\n+\t\t\t\t  build_real (type, c)));\n+\t    }\n+\n+\t  /* Convert x+x*c into x*(c+1).  */\n+\t  if (flag_unsafe_math_optimizations\n+\t      && TREE_CODE (arg1) == MULT_EXPR\n+\t      && TREE_CODE (TREE_OPERAND (arg1, 1)) == REAL_CST\n+\t      && ! TREE_CONSTANT_OVERFLOW (TREE_OPERAND (arg1, 1))\n+\t      && operand_equal_p (TREE_OPERAND (arg1, 0), arg0, 0))\n+\t    {\n+\t      REAL_VALUE_TYPE c;\n+\n+\t      c = TREE_REAL_CST (TREE_OPERAND (arg1, 1));\n+\t      real_arithmetic (&c, PLUS_EXPR, &c, &dconst1);\n+\t      return fold (build (MULT_EXPR, type, arg0,\n+\t\t\t\t  build_real (type, c)));\n+\t    }\n+\n+\t  /* Convert x*c1+x*c2 into x*(c1+c2).  */\n+\t  if (flag_unsafe_math_optimizations\n+\t      && TREE_CODE (arg0) == MULT_EXPR\n+\t      && TREE_CODE (arg1) == MULT_EXPR\n+\t      && TREE_CODE (TREE_OPERAND (arg0, 1)) == REAL_CST\n+\t      && ! TREE_CONSTANT_OVERFLOW (TREE_OPERAND (arg0, 1))\n+\t      && TREE_CODE (TREE_OPERAND (arg1, 1)) == REAL_CST\n+\t      && ! TREE_CONSTANT_OVERFLOW (TREE_OPERAND (arg1, 1))\n+\t      && operand_equal_p (TREE_OPERAND (arg0, 0),\n+\t\t\t\t  TREE_OPERAND (arg1, 0), 0))\n+\t    {\n+\t      REAL_VALUE_TYPE c1, c2;\n+\n+\t      c1 = TREE_REAL_CST (TREE_OPERAND (arg0, 1));\n+\t      c2 = TREE_REAL_CST (TREE_OPERAND (arg1, 1));\n+\t      real_arithmetic (&c1, PLUS_EXPR, &c1, &c2);\n+\t      return fold (build (MULT_EXPR, type,\n+\t\t\t\t  TREE_OPERAND (arg0, 0),\n+\t\t\t\t  build_real (type, c1)));\n+\t    }\n+\t}\n \n      bit_rotate:\n       /* (A << C1) + (A >> C2) if A is unsigned and C1+C2 is the size of A\n@@ -5954,15 +6012,6 @@ fold (tree expr)\n \t      && real_minus_onep (arg1))\n \t    return fold (build1 (NEGATE_EXPR, type, arg0));\n \n-\t  /* x*2 is x+x */\n-\t  if (! wins && real_twop (arg1)\n-\t      && (*lang_hooks.decls.global_bindings_p) () == 0\n-\t      && ! CONTAINS_PLACEHOLDER_P (arg0))\n-\t    {\n-\t      tree arg = save_expr (arg0);\n-\t      return fold (build (PLUS_EXPR, type, arg, arg));\n-\t    }\n-\n \t  if (flag_unsafe_math_optimizations)\n \t    {\n \t      enum built_in_function fcode0 = builtin_mathfn_code (arg0);"}, {"sha": "ba19bc89283a4f04ab185fe94c2fda447fbc6d78", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2593a6649384b002184762c58b083eb5f8e939f/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2593a6649384b002184762c58b083eb5f8e939f/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=f2593a6649384b002184762c58b083eb5f8e939f", "patch": "@@ -1,3 +1,7 @@\n+2003-08-04  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* gcc.dg/20030804-1.c: New test case.\n+\n 2003-08-04  Alexandre Oliva  <aoliva@redhat.com>\n \n \t* gcc.dg/cpp/separate-1.c: New test."}, {"sha": "cbc66474a5e56dfd56bae2185273336b1c3a058a", "filename": "gcc/testsuite/gcc.dg/20030804-1.c", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2593a6649384b002184762c58b083eb5f8e939f/gcc%2Ftestsuite%2Fgcc.dg%2F20030804-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2593a6649384b002184762c58b083eb5f8e939f/gcc%2Ftestsuite%2Fgcc.dg%2F20030804-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2F20030804-1.c?ref=f2593a6649384b002184762c58b083eb5f8e939f", "patch": "@@ -0,0 +1,75 @@\n+/* Copyright (C) 2003 Free Software Foundation.\n+\n+   Check that constant folding of mathematical expressions doesn't\n+   break anything.\n+\n+   Written by Roger Sayle, 3rd August 2003.  */\n+\n+/* { dg-do link } */\n+/* { dg-options \"-O2 -ffast-math\" } */\n+\n+extern void link_error(void);\n+\n+void test(double x)\n+{\n+  if (x+x != 2.0*x)\n+    link_error ();\n+  if (x+x != x*2.0)\n+    link_error ();\n+\n+  if (x+x+x != 3.0*x)\n+    link_error ();\n+  if (x+x+x != x*3.0)\n+    link_error ();\n+\n+  if ((x+x)+x != 3.0*x)\n+    link_error ();\n+  if ((x+x)+x != x*3.0)\n+    link_error ();\n+\n+  if (x+(x+x) != 3.0*x)\n+    link_error ();\n+  if (x+(x+x) != x*3.0)\n+    link_error ();\n+\n+  if (x+4.0*x != 5.0*x)\n+    link_error ();\n+  if (x+4.0*x != x*5.0)\n+    link_error ();\n+  if (x+x*4.0 != 5.0*x)\n+    link_error ();\n+  if (x+x*4.0 != x*5.0)\n+    link_error ();\n+  if (4.0*x+x != 5.0*x)\n+    link_error ();\n+  if (4.0*x+x != x*5.0)\n+    link_error ();\n+  if (x*4.0+x != 5.0*x)\n+    link_error ();\n+  if (x*4.0+x != x*5.0)\n+    link_error ();\n+\n+  if (3.0*x + 5.0*x != 8.0*x)\n+    link_error ();\n+  if (3.0*x + 5.0*x != x*8.0)\n+    link_error ();\n+  if (x*3.0 + 5.0*x != 8.0*x)\n+    link_error ();\n+  if (x*3.0 + 5.0*x != x*8.0)\n+    link_error ();\n+  if (3.0*x + x*5.0 != 8.0*x)\n+    link_error ();\n+  if (3.0*x + x*5.0 != x*8.0)\n+    link_error ();\n+  if (x*3.0 + x*5.0 != 8.0*x)\n+    link_error ();\n+  if (x*3.0 + x*5.0 != x*8.0)\n+    link_error ();\n+}\n+\n+int main()\n+{\n+  test(2.0);\n+  return 0;\n+}\n+"}]}