{"sha": "9283471ba0d8b605a5ddf8cbd2814d81d4dd8550", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTI4MzQ3MWJhMGQ4YjYwNWE1ZGRmOGNiZDI4MTRkODFkNGRkODU1MA==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "iant@golang.org", "date": "2017-09-20T21:09:37Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2017-09-20T21:09:37Z"}, "message": "re PR sanitizer/77631 (no symbols in backtrace shown by ASan when debug info is split)\n\n\tPR sanitizer/77631\n\tSupport for external debug info.\n\t* elf.c: Include <errno.h>, <sys/stat.h>, <unistd.h>.\n\t(S_ISLNK): Define if not defined.\n\t(xstrnlen): Define if strnlen is not available.\n\t(b_elf_note): Define type.\n\t(NT_GNU_BUILD_ID): Define macro.\n\t(elf_crc32, elf_crc32_file): New static functions.\n\t(elf_is_symlink, elf_readlink): New static functions.\n\t(elf_open_debugfile_by_buildid): New static function.\n\t(elf_try_debugfile): New static function.\n\t(elf_find_debugfile_by_debuglink): New static function.\n\t(elf_open_debugfile_by_debuglink): New static function.\n\t(elf_add): Add filename and debuginfo parameters.  Adjust all\n\tcallers.  Look for external debug info notes, and try to fetch\n\tdebug info from external file.\n\t(struct phdr_data): Add exe_filename field.\n\t(phdr_callback): Pass filename to elf_add.\n\t(backtrace_initialize): Add filename parameter.\n\t* internal.h (backtrace_initialize): Add filename parameter.\n\t* fileline.c (fileline_initialize): Pass filename to\n\tbacktrace_initialize.\n\t* pecoff.c (fileline_initialize): Add unused filename parameter.\n\t* unknown.c (fileline_initialize): Likewise.\n\t* xcoff.c (fileline_initialize): Likewise.\n\t* configure.ac: Check for objcopy --add-gnu-debuglink.\n\t* Makefile.am (dtest): New test target.\n\t* configure, Makefile.in: Rebuild.\n\nCo-Authored-By: Denis Khalikov <d.khalikov@partner.samsung.com>\n\nFrom-SVN: r253032", "tree": {"sha": "e52a88d0b1f5cfcb40440155b8e658b582180f36", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e52a88d0b1f5cfcb40440155b8e658b582180f36"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9283471ba0d8b605a5ddf8cbd2814d81d4dd8550", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9283471ba0d8b605a5ddf8cbd2814d81d4dd8550", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9283471ba0d8b605a5ddf8cbd2814d81d4dd8550", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9283471ba0d8b605a5ddf8cbd2814d81d4dd8550/comments", "author": {"login": "ianlancetaylor", "id": 3194333, "node_id": "MDQ6VXNlcjMxOTQzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/3194333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ianlancetaylor", "html_url": "https://github.com/ianlancetaylor", "followers_url": "https://api.github.com/users/ianlancetaylor/followers", "following_url": "https://api.github.com/users/ianlancetaylor/following{/other_user}", "gists_url": "https://api.github.com/users/ianlancetaylor/gists{/gist_id}", "starred_url": "https://api.github.com/users/ianlancetaylor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ianlancetaylor/subscriptions", "organizations_url": "https://api.github.com/users/ianlancetaylor/orgs", "repos_url": "https://api.github.com/users/ianlancetaylor/repos", "events_url": "https://api.github.com/users/ianlancetaylor/events{/privacy}", "received_events_url": "https://api.github.com/users/ianlancetaylor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "2ffb574542b10b14841c2807047e7396e3a63f37", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ffb574542b10b14841c2807047e7396e3a63f37", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2ffb574542b10b14841c2807047e7396e3a63f37"}], "stats": {"total": 724, "additions": 705, "deletions": 19}, "files": [{"sha": "731716f0be71ffb3faf80529d3af84b94e98a69d", "filename": "libbacktrace/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9283471ba0d8b605a5ddf8cbd2814d81d4dd8550/libbacktrace%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9283471ba0d8b605a5ddf8cbd2814d81d4dd8550/libbacktrace%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2FChangeLog?ref=9283471ba0d8b605a5ddf8cbd2814d81d4dd8550", "patch": "@@ -1,3 +1,35 @@\n+2017-09-20  Ian Lance Taylor  <iant@golang.org>\n+\t    Denis Khalikov  <d.khalikov@partner.samsung.com>\n+\n+\tPR sanitizer/77631\n+\tSupport for external debug info.\n+\t* elf.c: Include <errno.h>, <sys/stat.h>, <unistd.h>.\n+\t(S_ISLNK): Define if not defined.\n+\t(xstrnlen): Define if strnlen is not available.\n+\t(b_elf_note): Define type.\n+\t(NT_GNU_BUILD_ID): Define macro.\n+\t(elf_crc32, elf_crc32_file): New static functions.\n+\t(elf_is_symlink, elf_readlink): New static functions.\n+\t(elf_open_debugfile_by_buildid): New static function.\n+\t(elf_try_debugfile): New static function.\n+\t(elf_find_debugfile_by_debuglink): New static function.\n+\t(elf_open_debugfile_by_debuglink): New static function.\n+\t(elf_add): Add filename and debuginfo parameters.  Adjust all\n+\tcallers.  Look for external debug info notes, and try to fetch\n+\tdebug info from external file.\n+\t(struct phdr_data): Add exe_filename field.\n+\t(phdr_callback): Pass filename to elf_add.\n+\t(backtrace_initialize): Add filename parameter.\n+\t* internal.h (backtrace_initialize): Add filename parameter.\n+\t* fileline.c (fileline_initialize): Pass filename to\n+\tbacktrace_initialize.\n+\t* pecoff.c (fileline_initialize): Add unused filename parameter.\n+\t* unknown.c (fileline_initialize): Likewise.\n+\t* xcoff.c (fileline_initialize): Likewise.\n+\t* configure.ac: Check for objcopy --add-gnu-debuglink.\n+\t* Makefile.am (dtest): New test target.\n+\t* configure, Makefile.in: Rebuild.\n+\n 2017-09-12  Steve Ellcey  <sellcey@cavium.com>\n \n \tPR other/81096"}, {"sha": "64b888beee4c0616ae66ee3d66c497e83db152e3", "filename": "libbacktrace/Makefile.am", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9283471ba0d8b605a5ddf8cbd2814d81d4dd8550/libbacktrace%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9283471ba0d8b605a5ddf8cbd2814d81d4dd8550/libbacktrace%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2FMakefile.am?ref=9283471ba0d8b605a5ddf8cbd2814d81d4dd8550", "patch": "@@ -122,6 +122,16 @@ ttest_LDADD = libbacktrace.la\n \n endif HAVE_PTHREAD\n \n+if HAVE_OBJCOPY_DEBUGLINK\n+\n+TESTS += dtest\n+\n+dtest: btest\n+\t$(OBJCOPY) --only-keep-debug btest btest.debug\n+\t$(OBJCOPY) --strip-debug --add-gnu-debuglink=btest.debug btest dtest\n+\n+endif HAVE_OBJCOPY_DEBUGLINK\n+\n endif NATIVE\n \n # We can't use automake's automatic dependency tracking, because it"}, {"sha": "66ab5bfeb4e75d0b91553549c6338cccb7c50771", "filename": "libbacktrace/Makefile.in", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9283471ba0d8b605a5ddf8cbd2814d81d4dd8550/libbacktrace%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9283471ba0d8b605a5ddf8cbd2814d81d4dd8550/libbacktrace%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2FMakefile.in?ref=9283471ba0d8b605a5ddf8cbd2814d81d4dd8550", "patch": "@@ -86,6 +86,7 @@ target_triplet = @target@\n check_PROGRAMS = $(am__EXEEXT_1) $(am__EXEEXT_2)\n @NATIVE_TRUE@am__append_1 = btest stest edtest\n @HAVE_PTHREAD_TRUE@@NATIVE_TRUE@am__append_2 = ttest\n+@HAVE_OBJCOPY_DEBUGLINK_TRUE@@NATIVE_TRUE@am__append_3 = dtest\n subdir = .\n DIST_COMMON = README ChangeLog $(srcdir)/Makefile.in \\\n \t$(srcdir)/Makefile.am $(top_srcdir)/configure \\\n@@ -217,6 +218,7 @@ MAKEINFO = @MAKEINFO@\n MKDIR_P = @MKDIR_P@\n NM = @NM@\n NMEDIT = @NMEDIT@\n+OBJCOPY = @OBJCOPY@\n OBJDUMP = @OBJDUMP@\n OBJEXT = @OBJEXT@\n OTOOL = @OTOOL@\n@@ -343,7 +345,7 @@ libbacktrace_la_LIBADD = \\\n \t$(ALLOC_FILE)\n \n libbacktrace_la_DEPENDENCIES = $(libbacktrace_la_LIBADD)\n-TESTS = $(check_PROGRAMS)\n+TESTS = $(check_PROGRAMS) $(am__append_3)\n @NATIVE_TRUE@btest_SOURCES = btest.c testlib.c\n @NATIVE_TRUE@btest_CFLAGS = $(AM_CFLAGS) -g -O\n @NATIVE_TRUE@btest_LDADD = libbacktrace.la\n@@ -799,6 +801,10 @@ uninstall-am:\n @NATIVE_TRUE@\tcat $(srcdir)/edtest2.c > tmp-edtest2_build.c\n @NATIVE_TRUE@\t$(SHELL) $(srcdir)/../move-if-change tmp-edtest2_build.c edtest2_build.c\n @NATIVE_TRUE@\techo timestamp > $@\n+\n+@HAVE_OBJCOPY_DEBUGLINK_TRUE@@NATIVE_TRUE@dtest: btest\n+@HAVE_OBJCOPY_DEBUGLINK_TRUE@@NATIVE_TRUE@\t$(OBJCOPY) --only-keep-debug btest btest.debug\n+@HAVE_OBJCOPY_DEBUGLINK_TRUE@@NATIVE_TRUE@\t$(OBJCOPY) --strip-debug --add-gnu-debuglink=btest.debug btest dtest\n alloc.lo: config.h backtrace.h internal.h\n backtrace.lo: config.h backtrace.h internal.h\n btest.lo: (INCDIR)/filenames.h backtrace.h backtrace-supported.h"}, {"sha": "3ef933110c07f6d634d2fb8ca59e7e44b663f016", "filename": "libbacktrace/configure", "status": "modified", "additions": 75, "deletions": 3, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9283471ba0d8b605a5ddf8cbd2814d81d4dd8550/libbacktrace%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9283471ba0d8b605a5ddf8cbd2814d81d4dd8550/libbacktrace%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2Fconfigure?ref=9283471ba0d8b605a5ddf8cbd2814d81d4dd8550", "patch": "@@ -604,6 +604,9 @@ LTLIBOBJS\n LIBOBJS\n NATIVE_FALSE\n NATIVE_TRUE\n+HAVE_OBJCOPY_DEBUGLINK_FALSE\n+HAVE_OBJCOPY_DEBUGLINK_TRUE\n+OBJCOPY\n HAVE_PTHREAD_FALSE\n HAVE_PTHREAD_TRUE\n PTHREAD_CFLAGS\n@@ -746,7 +749,8 @@ CFLAGS\n LDFLAGS\n LIBS\n CPPFLAGS\n-CPP'\n+CPP\n+OBJCOPY'\n \n \n # Initialize some variables set by options.\n@@ -1396,6 +1400,7 @@ Some influential environment variables:\n   CPPFLAGS    C/C++/Objective C preprocessor flags, e.g. -I<include dir> if\n               you have headers in a nonstandard directory <include dir>\n   CPP         C preprocessor\n+  OBJCOPY     location of objcopy\n \n Use these variables to override the choices made by `configure' or to help\n it to find libraries and programs with nonstandard names/locations.\n@@ -11136,7 +11141,7 @@ else\n   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2\n   lt_status=$lt_dlunknown\n   cat > conftest.$ac_ext <<_LT_EOF\n-#line 11139 \"configure\"\n+#line 11144 \"configure\"\n #include \"confdefs.h\"\n \n #if HAVE_DLFCN_H\n@@ -11242,7 +11247,7 @@ else\n   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2\n   lt_status=$lt_dlunknown\n   cat > conftest.$ac_ext <<_LT_EOF\n-#line 11245 \"configure\"\n+#line 11250 \"configure\"\n #include \"confdefs.h\"\n \n #if HAVE_DLFCN_H\n@@ -12761,6 +12766,69 @@ else\n fi\n \n \n+\n+# Extract the first word of \"objcopy\", so it can be a program name with args.\n+set dummy objcopy; ac_word=$2\n+{ $as_echo \"$as_me:${as_lineno-$LINENO}: checking for $ac_word\" >&5\n+$as_echo_n \"checking for $ac_word... \" >&6; }\n+if test \"${ac_cv_prog_OBJCOPY+set}\" = set; then :\n+  $as_echo_n \"(cached) \" >&6\n+else\n+  if test -n \"$OBJCOPY\"; then\n+  ac_cv_prog_OBJCOPY=\"$OBJCOPY\" # Let the user override the test.\n+else\n+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR\n+for as_dir in $PATH\n+do\n+  IFS=$as_save_IFS\n+  test -z \"$as_dir\" && as_dir=.\n+    for ac_exec_ext in '' $ac_executable_extensions; do\n+  if { test -f \"$as_dir/$ac_word$ac_exec_ext\" && $as_test_x \"$as_dir/$ac_word$ac_exec_ext\"; }; then\n+    ac_cv_prog_OBJCOPY=\"objcopy\"\n+    $as_echo \"$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext\" >&5\n+    break 2\n+  fi\n+done\n+  done\n+IFS=$as_save_IFS\n+\n+fi\n+fi\n+OBJCOPY=$ac_cv_prog_OBJCOPY\n+if test -n \"$OBJCOPY\"; then\n+  { $as_echo \"$as_me:${as_lineno-$LINENO}: result: $OBJCOPY\" >&5\n+$as_echo \"$OBJCOPY\" >&6; }\n+else\n+  { $as_echo \"$as_me:${as_lineno-$LINENO}: result: no\" >&5\n+$as_echo \"no\" >&6; }\n+fi\n+\n+\n+{ $as_echo \"$as_me:${as_lineno-$LINENO}: checking whether objcopy supports debuglink\" >&5\n+$as_echo_n \"checking whether objcopy supports debuglink... \" >&6; }\n+if test \"${libbacktrace_cv_objcopy_debuglink+set}\" = set; then :\n+  $as_echo_n \"(cached) \" >&6\n+else\n+  if test -n \"${with_target_subdir}\"; then\n+  libbacktrace_cv_objcopy_debuglink=no\n+elif ${OBJCOPY} --add-gnu-debuglink=x /bin/ls /tmp/ls$$; then\n+  rm -f /tmp/ls$$\n+  libbacktrace_cv_objcopy_debuglink=yes\n+else\n+  libbacktrace_cv_objcopy_debuglink=no\n+fi\n+fi\n+{ $as_echo \"$as_me:${as_lineno-$LINENO}: result: $libbacktrace_cv_objcopy_debuglink\" >&5\n+$as_echo \"$libbacktrace_cv_objcopy_debuglink\" >&6; }\n+ if test \"$libbacktrace_cv_objcopy_debuglink\" = yes; then\n+  HAVE_OBJCOPY_DEBUGLINK_TRUE=\n+  HAVE_OBJCOPY_DEBUGLINK_FALSE='#'\n+else\n+  HAVE_OBJCOPY_DEBUGLINK_TRUE='#'\n+  HAVE_OBJCOPY_DEBUGLINK_FALSE=\n+fi\n+\n+\n { $as_echo \"$as_me:${as_lineno-$LINENO}: checking whether tests can run\" >&5\n $as_echo_n \"checking whether tests can run... \" >&6; }\n if test \"${libbacktrace_cv_sys_native+set}\" = set; then :\n@@ -12927,6 +12995,10 @@ if test -z \"${HAVE_PTHREAD_TRUE}\" && test -z \"${HAVE_PTHREAD_FALSE}\"; then\n   as_fn_error \"conditional \\\"HAVE_PTHREAD\\\" was never defined.\n Usually this means the macro was only invoked conditionally.\" \"$LINENO\" 5\n fi\n+if test -z \"${HAVE_OBJCOPY_DEBUGLINK_TRUE}\" && test -z \"${HAVE_OBJCOPY_DEBUGLINK_FALSE}\"; then\n+  as_fn_error \"conditional \\\"HAVE_OBJCOPY_DEBUGLINK\\\" was never defined.\n+Usually this means the macro was only invoked conditionally.\" \"$LINENO\" 5\n+fi\n if test -z \"${NATIVE_TRUE}\" && test -z \"${NATIVE_FALSE}\"; then\n   as_fn_error \"conditional \\\"NATIVE\\\" was never defined.\n Usually this means the macro was only invoked conditionally.\" \"$LINENO\" 5"}, {"sha": "97e6e960829405ec62b58f2555111818103cfffa", "filename": "libbacktrace/configure.ac", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9283471ba0d8b605a5ddf8cbd2814d81d4dd8550/libbacktrace%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9283471ba0d8b605a5ddf8cbd2814d81d4dd8550/libbacktrace%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2Fconfigure.ac?ref=9283471ba0d8b605a5ddf8cbd2814d81d4dd8550", "patch": "@@ -404,6 +404,20 @@ AC_SUBST(PTHREAD_CFLAGS)\n \n AM_CONDITIONAL(HAVE_PTHREAD, test \"$libgo_cv_lib_pthread\" = yes)\n \n+AC_ARG_VAR(OBJCOPY, [location of objcopy])\n+AC_CHECK_PROG(OBJCOPY, objcopy, objcopy,)\n+AC_CACHE_CHECK([whether objcopy supports debuglink],\n+[libbacktrace_cv_objcopy_debuglink],\n+[if test -n \"${with_target_subdir}\"; then\n+  libbacktrace_cv_objcopy_debuglink=no\n+elif ${OBJCOPY} --add-gnu-debuglink=x /bin/ls /tmp/ls$$; then\n+  rm -f /tmp/ls$$\n+  libbacktrace_cv_objcopy_debuglink=yes\n+else\n+  libbacktrace_cv_objcopy_debuglink=no\n+fi])\n+AM_CONDITIONAL(HAVE_OBJCOPY_DEBUGLINK, test \"$libbacktrace_cv_objcopy_debuglink\" = yes)\n+\n AC_CACHE_CHECK([whether tests can run],\n   [libbacktrace_cv_sys_native],\n   [AC_RUN_IFELSE([AC_LANG_PROGRAM([], [return 0;])],"}, {"sha": "530d4a2e2f4beab81b128d0e5ed1af2c5ec4f15c", "filename": "libbacktrace/elf.c", "status": "modified", "additions": 558, "deletions": 10, "changes": 568, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9283471ba0d8b605a5ddf8cbd2814d81d4dd8550/libbacktrace%2Felf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9283471ba0d8b605a5ddf8cbd2814d81d4dd8550/libbacktrace%2Felf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2Felf.c?ref=9283471ba0d8b605a5ddf8cbd2814d81d4dd8550", "patch": "@@ -32,9 +32,12 @@ POSSIBILITY OF SUCH DAMAGE.  */\n \n #include \"config.h\"\n \n+#include <errno.h>\n #include <stdlib.h>\n #include <string.h>\n #include <sys/types.h>\n+#include <sys/stat.h>\n+#include <unistd.h>\n \n #ifdef HAVE_DL_ITERATE_PHDR\n #include <link.h>\n@@ -43,6 +46,35 @@ POSSIBILITY OF SUCH DAMAGE.  */\n #include \"backtrace.h\"\n #include \"internal.h\"\n \n+#ifndef S_ISLNK\n+ #ifndef S_IFLNK\n+  #define S_IFLNK 0120000\n+ #endif\n+ #ifndef S_IFMT\n+  #define S_IFMT 0170000\n+ #endif\n+ #define S_ISLNK(m) (((m) & S_IFMT) == S_IFLNK)\n+#endif\n+\n+#if !defined(HAVE_DECL_STRNLEN) || !HAVE_DECL_STRNLEN\n+\n+/* If strnlen is not declared, provide our own version.  */\n+\n+static size_t\n+xstrnlen (const char *s, size_t maxlen)\n+{\n+  size_t i;\n+\n+  for (i = 0; i < maxlen; ++i)\n+    if (s[i] == '\\0')\n+      break;\n+  return i;\n+}\n+\n+#define strnlen xstrnlen\n+\n+#endif\n+\n #ifndef HAVE_DL_ITERATE_PHDR\n \n /* Dummy version of dl_iterate_phdr for systems that don't have it.  */\n@@ -105,6 +137,7 @@ dl_iterate_phdr (int (*callback) (struct dl_phdr_info *,\n #undef SHT_DYNSYM\n #undef STT_OBJECT\n #undef STT_FUNC\n+#undef NT_GNU_BUILD_ID\n \n /* Basic types.  */\n \n@@ -224,6 +257,16 @@ typedef struct\n #define STT_OBJECT 1\n #define STT_FUNC 2\n \n+typedef struct\n+{\n+  uint32_t namesz;\n+  uint32_t descsz;\n+  uint32_t type;\n+  char name[1];\n+} b_elf_note;\n+\n+#define NT_GNU_BUILD_ID 3\n+\n /* An index of ELF sections we care about.  */\n \n enum debug_section\n@@ -283,6 +326,102 @@ struct elf_syminfo_data\n   size_t count;\n };\n \n+/* Compute the CRC-32 of BUF/LEN.  This uses the CRC used for\n+   .gnu_debuglink files.  */\n+\n+static uint32_t\n+elf_crc32 (uint32_t crc, const unsigned char *buf, size_t len)\n+{\n+  static const uint32_t crc32_table[256] =\n+    {\n+      0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419,\n+      0x706af48f, 0xe963a535, 0x9e6495a3, 0x0edb8832, 0x79dcb8a4,\n+      0xe0d5e91e, 0x97d2d988, 0x09b64c2b, 0x7eb17cbd, 0xe7b82d07,\n+      0x90bf1d91, 0x1db71064, 0x6ab020f2, 0xf3b97148, 0x84be41de,\n+      0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7, 0x136c9856,\n+      0x646ba8c0, 0xfd62f97a, 0x8a65c9ec, 0x14015c4f, 0x63066cd9,\n+      0xfa0f3d63, 0x8d080df5, 0x3b6e20c8, 0x4c69105e, 0xd56041e4,\n+      0xa2677172, 0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b,\n+      0x35b5a8fa, 0x42b2986c, 0xdbbbc9d6, 0xacbcf940, 0x32d86ce3,\n+      0x45df5c75, 0xdcd60dcf, 0xabd13d59, 0x26d930ac, 0x51de003a,\n+      0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423, 0xcfba9599,\n+      0xb8bda50f, 0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924,\n+      0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d, 0x76dc4190,\n+      0x01db7106, 0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f,\n+      0x9fbfe4a5, 0xe8b8d433, 0x7807c9a2, 0x0f00f934, 0x9609a88e,\n+      0xe10e9818, 0x7f6a0dbb, 0x086d3d2d, 0x91646c97, 0xe6635c01,\n+      0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e, 0x6c0695ed,\n+      0x1b01a57b, 0x8208f4c1, 0xf50fc457, 0x65b0d9c6, 0x12b7e950,\n+      0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3,\n+      0xfbd44c65, 0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2,\n+      0x4adfa541, 0x3dd895d7, 0xa4d1c46d, 0xd3d6f4fb, 0x4369e96a,\n+      0x346ed9fc, 0xad678846, 0xda60b8d0, 0x44042d73, 0x33031de5,\n+      0xaa0a4c5f, 0xdd0d7cc9, 0x5005713c, 0x270241aa, 0xbe0b1010,\n+      0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f,\n+      0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17,\n+      0x2eb40d81, 0xb7bd5c3b, 0xc0ba6cad, 0xedb88320, 0x9abfb3b6,\n+      0x03b6e20c, 0x74b1d29a, 0xead54739, 0x9dd277af, 0x04db2615,\n+      0x73dc1683, 0xe3630b12, 0x94643b84, 0x0d6d6a3e, 0x7a6a5aa8,\n+      0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1, 0xf00f9344,\n+      0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb,\n+      0x196c3671, 0x6e6b06e7, 0xfed41b76, 0x89d32be0, 0x10da7a5a,\n+      0x67dd4acc, 0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5,\n+      0xd6d6a3e8, 0xa1d1937e, 0x38d8c2c4, 0x4fdff252, 0xd1bb67f1,\n+      0xa6bc5767, 0x3fb506dd, 0x48b2364b, 0xd80d2bda, 0xaf0a1b4c,\n+      0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55, 0x316e8eef,\n+      0x4669be79, 0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236,\n+      0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f, 0xc5ba3bbe,\n+      0xb2bd0b28, 0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31,\n+      0x2cd99e8b, 0x5bdeae1d, 0x9b64c2b0, 0xec63f226, 0x756aa39c,\n+      0x026d930a, 0x9c0906a9, 0xeb0e363f, 0x72076785, 0x05005713,\n+      0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38, 0x92d28e9b,\n+      0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21, 0x86d3d2d4, 0xf1d4e242,\n+      0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1,\n+      0x18b74777, 0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c,\n+      0x8f659eff, 0xf862ae69, 0x616bffd3, 0x166ccf45, 0xa00ae278,\n+      0xd70dd2ee, 0x4e048354, 0x3903b3c2, 0xa7672661, 0xd06016f7,\n+      0x4969474d, 0x3e6e77db, 0xaed16a4a, 0xd9d65adc, 0x40df0b66,\n+      0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9,\n+      0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605,\n+      0xcdd70693, 0x54de5729, 0x23d967bf, 0xb3667a2e, 0xc4614ab8,\n+      0x5d681b02, 0x2a6f2b94, 0xb40bbe37, 0xc30c8ea1, 0x5a05df1b,\n+      0x2d02ef8d\n+    };\n+  const unsigned char *end;\n+\n+  crc = ~crc;\n+  for (end = buf + len; buf < end; ++ buf)\n+    crc = crc32_table[(crc ^ *buf) & 0xff] ^ (crc >> 8);\n+  return ~crc;\n+}\n+\n+/* Return the CRC-32 of the entire file open at DESCRIPTOR.  */\n+\n+static uint32_t\n+elf_crc32_file (struct backtrace_state *state, int descriptor,\n+\t\tbacktrace_error_callback error_callback, void *data)\n+{\n+  struct stat st;\n+  struct backtrace_view file_view;\n+  uint32_t ret;\n+\n+  if (fstat (descriptor, &st) < 0)\n+    {\n+      error_callback (data, \"fstat\", errno);\n+      return 0;\n+    }\n+\n+  if (!backtrace_get_view (state, descriptor, 0, st.st_size, error_callback,\n+\t\t\t   data, &file_view))\n+    return 0;\n+\n+  ret = elf_crc32 (0, (const unsigned char *) file_view.data, st.st_size);\n+\n+  backtrace_release_view (state, &file_view, error_callback, data);\n+\n+  return ret;\n+}\n+\n /* A dummy callback function used when we can't find any debug info.  */\n \n static int\n@@ -510,16 +649,304 @@ elf_syminfo (struct backtrace_state *state, uintptr_t addr,\n     callback (data, addr, sym->name, sym->address, sym->size);\n }\n \n+/* Return whether FILENAME is a symlink.  */\n+\n+static int\n+elf_is_symlink (const char *filename)\n+{\n+  struct stat st;\n+\n+  if (lstat (filename, &st) < 0)\n+    return 0;\n+  return S_ISLNK (st.st_mode);\n+}\n+\n+/* Return the results of reading the symlink FILENAME in a buffer\n+   allocated by backtrace_alloc.  Return the length of the buffer in\n+   *LEN.  */\n+\n+static char *\n+elf_readlink (struct backtrace_state *state, const char *filename,\n+\t      backtrace_error_callback error_callback, void *data,\n+\t      size_t *plen)\n+{\n+  size_t len;\n+  char *buf;\n+\n+  len = 128;\n+  while (1)\n+    {\n+      ssize_t rl;\n+\n+      buf = backtrace_alloc (state, len, error_callback, data);\n+      if (buf == NULL)\n+\treturn NULL;\n+      rl = readlink (filename, buf, len);\n+      if (rl < 0)\n+\t{\n+\t  backtrace_free (state, buf, len, error_callback, data);\n+\t  return NULL;\n+\t}\n+      if ((size_t) rl < len - 1)\n+\t{\n+\t  buf[rl] = '\\0';\n+\t  *plen = len;\n+\t  return buf;\n+\t}\n+      backtrace_free (state, buf, len, error_callback, data);\n+      len *= 2;\n+    }\n+}\n+\n+/* Open a separate debug info file, using the build ID to find it.\n+   Returns an open file descriptor, or -1.\n+\n+   The GDB manual says that the only place gdb looks for a debug file\n+   when the build ID is known is in /usr/lib/debug/.build-id.  */\n+\n+static int\n+elf_open_debugfile_by_buildid (struct backtrace_state *state,\n+\t\t\t       const char *buildid_data, size_t buildid_size,\n+\t\t\t       backtrace_error_callback error_callback,\n+\t\t\t       void *data)\n+{\n+  const char * const prefix = \"/usr/lib/debug/.build-id/\";\n+  const size_t prefix_len = strlen (prefix);\n+  const char * const suffix = \".debug\";\n+  const size_t suffix_len = strlen (suffix);\n+  size_t len;\n+  char *bd_filename;\n+  char *t;\n+  size_t i;\n+  int ret;\n+  int does_not_exist;\n+\n+  len = prefix_len + buildid_size * 2 + suffix_len + 2;\n+  bd_filename = backtrace_alloc (state, len, error_callback, data);\n+  if (bd_filename == NULL)\n+    return -1;\n+\n+  t = bd_filename;\n+  memcpy (t, prefix, prefix_len);\n+  t += prefix_len;\n+  for (i = 0; i < buildid_size; i++)\n+    {\n+      unsigned char b;\n+      unsigned char nib;\n+\n+      b = (unsigned char) buildid_data[i];\n+      nib = (b & 0xf0) >> 4;\n+      *t++ = nib < 10 ? '0' + nib : 'a' + nib - 10;\n+      nib = b & 0x0f;\n+      *t++ = nib < 10 ? '0' + nib : 'a' + nib - 10;\n+      if (i == 0)\n+\t*t++ = '/';\n+    }\n+  memcpy (t, suffix, suffix_len);\n+  t[suffix_len] = '\\0';\n+\n+  ret = backtrace_open (bd_filename, error_callback, data, &does_not_exist);\n+\n+  backtrace_free (state, bd_filename, len, error_callback, data);\n+\n+  /* gdb checks that the debuginfo file has the same build ID note.\n+     That seems kind of pointless to me--why would it have the right\n+     name but not the right build ID?--so skipping the check.  */\n+\n+  return ret;\n+}\n+\n+/* Try to open a file whose name is PREFIX (length PREFIX_LEN)\n+   concatenated with PREFIX2 (length PREFIX2_LEN) concatenated with\n+   DEBUGLINK_NAME.  Returns an open file descriptor, or -1.  */\n+\n+static int\n+elf_try_debugfile (struct backtrace_state *state, const char *prefix,\n+\t\t   size_t prefix_len, const char *prefix2, size_t prefix2_len,\n+\t\t   const char *debuglink_name,\n+\t\t   backtrace_error_callback error_callback, void *data)\n+{\n+  size_t debuglink_len;\n+  size_t try_len;\n+  char *try;\n+  int does_not_exist;\n+  int ret;\n+\n+  debuglink_len = strlen (debuglink_name);\n+  try_len = prefix_len + prefix2_len + debuglink_len + 1;\n+  try = backtrace_alloc (state, try_len, error_callback, data);\n+  if (try == NULL)\n+    return -1;\n+\n+  memcpy (try, prefix, prefix_len);\n+  memcpy (try + prefix_len, prefix2, prefix2_len);\n+  memcpy (try + prefix_len + prefix2_len, debuglink_name, debuglink_len);\n+  try[prefix_len + prefix2_len + debuglink_len] = '\\0';\n+\n+  ret = backtrace_open (try, error_callback, data, &does_not_exist);\n+\n+  backtrace_free (state, try, try_len, error_callback, data);\n+\n+  return ret;\n+}\n+\n+/* Find a separate debug info file, using the debuglink section data\n+   to find it.  Returns an open file descriptor, or -1.  */\n+\n+static int\n+elf_find_debugfile_by_debuglink (struct backtrace_state *state,\n+\t\t\t\t const char *filename,\n+\t\t\t\t const char *debuglink_name,\n+\t\t\t\t backtrace_error_callback error_callback,\n+\t\t\t\t void *data)\n+{\n+  int ret;\n+  char *alc;\n+  size_t alc_len;\n+  const char *slash;\n+  int ddescriptor;\n+  const char *prefix;\n+  size_t prefix_len;\n+\n+  /* Resolve symlinks in FILENAME.  Since FILENAME is fairly likely to\n+     be /proc/self/exe, symlinks are common.  We don't try to resolve\n+     the whole path name, just the base name.  */\n+  ret = -1;\n+  alc = NULL;\n+  alc_len = 0;\n+  while (elf_is_symlink (filename))\n+    {\n+      char *new_buf;\n+      size_t new_len;\n+\n+      new_buf = elf_readlink (state, filename, error_callback, data, &new_len);\n+      if (new_buf == NULL)\n+\tbreak;\n+\n+      if (new_buf[0] == '/')\n+\tfilename = new_buf;\n+      else\n+\t{\n+\t  slash = strrchr (filename, '/');\n+\t  if (slash == NULL)\n+\t    filename = new_buf;\n+\t  else\n+\t    {\n+\t      size_t clen;\n+\t      char *c;\n+\n+\t      slash++;\n+\t      clen = slash - filename + strlen (new_buf) + 1;\n+\t      c = backtrace_alloc (state, clen, error_callback, data);\n+\t      if (c == NULL)\n+\t\tgoto done;\n+\n+\t      memcpy (c, filename, slash - filename);\n+\t      memcpy (c + (slash - filename), new_buf, strlen (new_buf));\n+\t      c[slash - filename + strlen (new_buf)] = '\\0';\n+\t      backtrace_free (state, new_buf, new_len, error_callback, data);\n+\t      filename = c;\n+\t      new_buf = c;\n+\t      new_len = clen;\n+\t    }\n+\t}\n+\n+      if (alc != NULL)\n+\tbacktrace_free (state, alc, alc_len, error_callback, data);\n+      alc = new_buf;\n+      alc_len = new_len;\n+    }\n+\n+  /* Look for DEBUGLINK_NAME in the same directory as FILENAME.  */\n+\n+  slash = strrchr (filename, '/');\n+  if (slash == NULL)\n+    {\n+      prefix = \"\";\n+      prefix_len = 0;\n+    }\n+  else\n+    {\n+      slash++;\n+      prefix = filename;\n+      prefix_len = slash - filename;\n+    }\n+\n+  ddescriptor = elf_try_debugfile (state, prefix, prefix_len, \"\", 0,\n+\t\t\t\t   debuglink_name, error_callback, data);\n+  if (ddescriptor >= 0)\n+    {\n+      ret = ddescriptor;\n+      goto done;\n+    }\n+\n+  /* Look for DEBUGLINK_NAME in a .debug subdirectory of FILENAME.  */\n+\n+  ddescriptor = elf_try_debugfile (state, prefix, prefix_len, \".debug/\",\n+\t\t\t\t   strlen (\".debug/\"), debuglink_name,\n+\t\t\t\t   error_callback, data);\n+  if (ddescriptor >= 0)\n+    {\n+      ret = ddescriptor;\n+      goto done;\n+    }\n+\n+  /* Look for DEBUGLINK_NAME in /usr/lib/debug.  */\n+\n+  ddescriptor = elf_try_debugfile (state, \"/usr/lib/debug/\",\n+\t\t\t\t   strlen (\"/usr/lib/debug/\"), prefix,\n+\t\t\t\t   prefix_len, debuglink_name,\n+\t\t\t\t   error_callback, data);\n+  if (ddescriptor >= 0)\n+    ret = ddescriptor;\n+\n+ done:\n+  if (alc != NULL && alc_len > 0)\n+    backtrace_free (state, alc, alc_len, error_callback, data);\n+  return ret;\n+}\n+\n+/* Open a separate debug info file, using the debuglink section data\n+   to find it.  Returns an open file descriptor, or -1.  */\n+\n+static int\n+elf_open_debugfile_by_debuglink (struct backtrace_state *state,\n+\t\t\t\t const char *filename,\n+\t\t\t\t const char *debuglink_name,\n+\t\t\t\t uint32_t debuglink_crc,\n+\t\t\t\t backtrace_error_callback error_callback,\n+\t\t\t\t void *data)\n+{\n+  int ddescriptor;\n+  uint32_t got_crc;\n+\n+  ddescriptor = elf_find_debugfile_by_debuglink (state, filename,\n+\t\t\t\t\t\t debuglink_name,\n+\t\t\t\t\t\t error_callback, data);\n+  if (ddescriptor < 0)\n+    return -1;\n+\n+  got_crc = elf_crc32_file (state, ddescriptor, error_callback, data);\n+  if (got_crc != debuglink_crc)\n+    {\n+      backtrace_close (ddescriptor, error_callback, data);\n+      return -1;\n+    }\n+\n+  return ddescriptor;\n+}\n+\n /* Add the backtrace data for one ELF file.  Returns 1 on success,\n    0 on failure (in both cases descriptor is closed) or -1 if exe\n    is non-zero and the ELF file is ET_DYN, which tells the caller that\n    elf_add will need to be called on the descriptor again after\n    base_address is determined.  */\n \n static int\n-elf_add (struct backtrace_state *state, int descriptor, uintptr_t base_address,\n-\t backtrace_error_callback error_callback, void *data,\n-\t fileline *fileline_fn, int *found_sym, int *found_dwarf, int exe)\n+elf_add (struct backtrace_state *state, const char *filename, int descriptor,\n+\t uintptr_t base_address, backtrace_error_callback error_callback,\n+\t void *data, fileline *fileline_fn, int *found_sym, int *found_dwarf,\n+\t int exe, int debuginfo)\n {\n   struct backtrace_view ehdr_view;\n   b_elf_ehdr ehdr;\n@@ -543,6 +970,14 @@ elf_add (struct backtrace_state *state, int descriptor, uintptr_t base_address,\n   int symtab_view_valid;\n   struct backtrace_view strtab_view;\n   int strtab_view_valid;\n+  struct backtrace_view buildid_view;\n+  int buildid_view_valid;\n+  const char *buildid_data;\n+  uint32_t buildid_size;\n+  struct backtrace_view debuglink_view;\n+  int debuglink_view_valid;\n+  const char *debuglink_name;\n+  uint32_t debuglink_crc;\n   off_t min_offset;\n   off_t max_offset;\n   struct backtrace_view debug_view;\n@@ -555,6 +990,12 @@ elf_add (struct backtrace_state *state, int descriptor, uintptr_t base_address,\n   names_view_valid = 0;\n   symtab_view_valid = 0;\n   strtab_view_valid = 0;\n+  buildid_view_valid = 0;\n+  buildid_data = NULL;\n+  buildid_size = 0;\n+  debuglink_view_valid = 0;\n+  debuglink_name = NULL;\n+  debuglink_crc = 0;\n   debug_view_valid = 0;\n \n   if (!backtrace_get_view (state, descriptor, 0, sizeof ehdr, error_callback,\n@@ -707,11 +1148,61 @@ elf_add (struct backtrace_state *state, int descriptor, uintptr_t base_address,\n \t      break;\n \t    }\n \t}\n+\n+      /* Read the build ID if present.  This could check for any\n+\t SHT_NOTE section with the right note name and type, but gdb\n+\t looks for a specific section name.  */\n+      if (!debuginfo\n+\t  && !buildid_view_valid\n+\t  && strcmp (name, \".note.gnu.build-id\") == 0)\n+\t{\n+\t  const b_elf_note *note;\n+\n+\t  if (!backtrace_get_view (state, descriptor, shdr->sh_offset,\n+\t\t\t\t   shdr->sh_size, error_callback, data,\n+\t\t\t\t   &buildid_view))\n+\t    goto fail;\n+\n+\t  buildid_view_valid = 1;\n+\t  note = (const b_elf_note *) buildid_view.data;\n+\t  if (note->type == NT_GNU_BUILD_ID\n+\t      && note->namesz == 4\n+\t      && strncmp (note->name, \"GNU\", 4) == 0\n+\t      && shdr->sh_size < 12 + ((note->namesz + 3) & ~ 3) + note->descsz)\n+\t    {\n+\t      buildid_data = &note->name[0] + ((note->namesz + 3) & ~ 3);\n+\t      buildid_size = note->descsz;\n+\t    }\n+\t}\n+\n+      /* Read the debuglink file if present.  */\n+      if (!debuginfo\n+\t  && !debuglink_view_valid\n+\t  && strcmp (name, \".gnu_debuglink\") == 0)\n+\t{\n+\t  const char *debuglink_data;\n+\t  size_t crc_offset;\n+\n+\t  if (!backtrace_get_view (state, descriptor, shdr->sh_offset,\n+\t\t\t\t   shdr->sh_size, error_callback, data,\n+\t\t\t\t   &debuglink_view))\n+\t    goto fail;\n+\n+\t  debuglink_view_valid = 1;\n+\t  debuglink_data = (const char *) debuglink_view.data;\n+\t  crc_offset = strnlen (debuglink_data, shdr->sh_size);\n+\t  crc_offset = (crc_offset + 3) & ~3;\n+\t  if (crc_offset + 4 <= shdr->sh_size)\n+\t    {\n+\t      debuglink_name = debuglink_data;\n+\t      debuglink_crc = *(const uint32_t*)(debuglink_data + crc_offset);\n+\t    }\n+\t}\n     }\n \n   if (symtab_shndx == 0)\n     symtab_shndx = dynsym_shndx;\n-  if (symtab_shndx != 0)\n+  if (symtab_shndx != 0 && !debuginfo)\n     {\n       const b_elf_shdr *symtab_shdr;\n       unsigned int strtab_shndx;\n@@ -757,6 +1248,7 @@ elf_add (struct backtrace_state *state, int descriptor, uintptr_t base_address,\n       /* We no longer need the symbol table, but we hold on to the\n \t string table permanently.  */\n       backtrace_release_view (state, &symtab_view, error_callback, data);\n+      symtab_view_valid = 0;\n \n       *found_sym = 1;\n \n@@ -770,6 +1262,53 @@ elf_add (struct backtrace_state *state, int descriptor, uintptr_t base_address,\n   backtrace_release_view (state, &names_view, error_callback, data);\n   names_view_valid = 0;\n \n+  /* If the debug info is in a separate file, read that one instead.  */\n+\n+  if (buildid_data != NULL)\n+    {\n+      int d;\n+\n+      d = elf_open_debugfile_by_buildid (state, buildid_data, buildid_size,\n+\t\t\t\t\t error_callback, data);\n+      if (d >= 0)\n+\t{\n+\t  backtrace_release_view (state, &buildid_view, error_callback, data);\n+\t  if (debuglink_view_valid)\n+\t    backtrace_release_view (state, &debuglink_view, error_callback,\n+\t\t\t\t    data);\n+\t  return elf_add (state, NULL, d, base_address, error_callback, data,\n+\t\t\t  fileline_fn, found_sym, found_dwarf, 0, 1);\n+\t}\n+    }\n+\n+  if (buildid_view_valid)\n+    {\n+      backtrace_release_view (state, &buildid_view, error_callback, data);\n+      buildid_view_valid = 0;\n+    }\n+\n+  if (debuglink_name != NULL)\n+    {\n+      int d;\n+\n+      d = elf_open_debugfile_by_debuglink (state, filename, debuglink_name,\n+\t\t\t\t\t   debuglink_crc, error_callback,\n+\t\t\t\t\t   data);\n+      if (d >= 0)\n+\t{\n+\t  backtrace_release_view (state, &debuglink_view, error_callback,\n+\t\t\t\t  data);\n+\t  return elf_add (state, NULL, d, base_address, error_callback, data,\n+\t\t\t  fileline_fn, found_sym, found_dwarf, 0, 1);\n+\t}\n+    }\n+\n+  if (debuglink_view_valid)\n+    {\n+      backtrace_release_view (state, &debuglink_view, error_callback, data);\n+      debuglink_view_valid = 0;\n+    }\n+\n   /* Read all the debug sections in a single view, since they are\n      probably adjacent in the file.  We never release this view.  */\n \n@@ -842,6 +1381,10 @@ elf_add (struct backtrace_state *state, int descriptor, uintptr_t base_address,\n     backtrace_release_view (state, &symtab_view, error_callback, data);\n   if (strtab_view_valid)\n     backtrace_release_view (state, &strtab_view, error_callback, data);\n+  if (debuglink_view_valid)\n+    backtrace_release_view (state, &debuglink_view, error_callback, data);\n+  if (buildid_view_valid)\n+    backtrace_release_view (state, &buildid_view, error_callback, data);\n   if (debug_view_valid)\n     backtrace_release_view (state, &debug_view, error_callback, data);\n   if (descriptor != -1)\n@@ -859,6 +1402,7 @@ struct phdr_data\n   fileline *fileline_fn;\n   int *found_sym;\n   int *found_dwarf;\n+  const char *exe_filename;\n   int exe_descriptor;\n };\n \n@@ -873,6 +1417,7 @@ phdr_callback (struct dl_phdr_info *info, size_t size ATTRIBUTE_UNUSED,\n \t       void *pdata)\n {\n   struct phdr_data *pd = (struct phdr_data *) pdata;\n+  const char *filename;\n   int descriptor;\n   int does_not_exist;\n   fileline elf_fileline_fn;\n@@ -885,6 +1430,7 @@ phdr_callback (struct dl_phdr_info *info, size_t size ATTRIBUTE_UNUSED,\n     {\n       if (pd->exe_descriptor == -1)\n \treturn 0;\n+      filename = pd->exe_filename;\n       descriptor = pd->exe_descriptor;\n       pd->exe_descriptor = -1;\n     }\n@@ -896,14 +1442,16 @@ phdr_callback (struct dl_phdr_info *info, size_t size ATTRIBUTE_UNUSED,\n \t  pd->exe_descriptor = -1;\n \t}\n \n+      filename = info->dlpi_name;\n       descriptor = backtrace_open (info->dlpi_name, pd->error_callback,\n \t\t\t\t   pd->data, &does_not_exist);\n       if (descriptor < 0)\n \treturn 0;\n     }\n \n-  if (elf_add (pd->state, descriptor, info->dlpi_addr, pd->error_callback,\n-\t       pd->data, &elf_fileline_fn, pd->found_sym, &found_dwarf, 0))\n+  if (elf_add (pd->state, filename, descriptor, info->dlpi_addr,\n+\t       pd->error_callback, pd->data, &elf_fileline_fn, pd->found_sym,\n+\t       &found_dwarf, 0, 0))\n     {\n       if (found_dwarf)\n \t{\n@@ -920,8 +1468,8 @@ phdr_callback (struct dl_phdr_info *info, size_t size ATTRIBUTE_UNUSED,\n    sections.  */\n \n int\n-backtrace_initialize (struct backtrace_state *state, int descriptor,\n-\t\t      backtrace_error_callback error_callback,\n+backtrace_initialize (struct backtrace_state *state, const char *filename,\n+\t\t      int descriptor, backtrace_error_callback error_callback,\n \t\t      void *data, fileline *fileline_fn)\n {\n   int ret;\n@@ -930,8 +1478,8 @@ backtrace_initialize (struct backtrace_state *state, int descriptor,\n   fileline elf_fileline_fn = elf_nodebug;\n   struct phdr_data pd;\n \n-  ret = elf_add (state, descriptor, 0, error_callback, data, &elf_fileline_fn,\n-\t\t &found_sym, &found_dwarf, 1);\n+  ret = elf_add (state, filename, descriptor, 0, error_callback, data,\n+\t\t &elf_fileline_fn, &found_sym, &found_dwarf, 1, 0);\n   if (!ret)\n     return 0;\n "}, {"sha": "babbe537330bba5b3a1fd3f8a133b1f62c0f4e4c", "filename": "libbacktrace/fileline.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9283471ba0d8b605a5ddf8cbd2814d81d4dd8550/libbacktrace%2Ffileline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9283471ba0d8b605a5ddf8cbd2814d81d4dd8550/libbacktrace%2Ffileline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2Ffileline.c?ref=9283471ba0d8b605a5ddf8cbd2814d81d4dd8550", "patch": "@@ -58,6 +58,7 @@ fileline_initialize (struct backtrace_state *state,\n   int pass;\n   int called_error_callback;\n   int descriptor;\n+  const char *filename;\n   char buf[64];\n \n   if (!state->threaded)\n@@ -84,7 +85,6 @@ fileline_initialize (struct backtrace_state *state,\n   called_error_callback = 0;\n   for (pass = 0; pass < 5; ++pass)\n     {\n-      const char *filename;\n       int does_not_exist;\n \n       switch (pass)\n@@ -140,8 +140,8 @@ fileline_initialize (struct backtrace_state *state,\n \n   if (!failed)\n     {\n-      if (!backtrace_initialize (state, descriptor, error_callback, data,\n-\t\t\t\t &fileline_fn))\n+      if (!backtrace_initialize (state, filename, descriptor, error_callback,\n+\t\t\t\t data, &fileline_fn))\n \tfailed = 1;\n     }\n "}, {"sha": "f52d1f94029ac4a20677a30f39cf66851bd522bb", "filename": "libbacktrace/internal.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9283471ba0d8b605a5ddf8cbd2814d81d4dd8550/libbacktrace%2Finternal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9283471ba0d8b605a5ddf8cbd2814d81d4dd8550/libbacktrace%2Finternal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2Finternal.h?ref=9283471ba0d8b605a5ddf8cbd2814d81d4dd8550", "patch": "@@ -268,6 +268,7 @@ extern int backtrace_vector_release (struct backtrace_state *state,\n    appropriate one.  */\n \n extern int backtrace_initialize (struct backtrace_state *state,\n+\t\t\t\t const char *filename,\n \t\t\t\t int descriptor,\n \t\t\t\t backtrace_error_callback error_callback,\n \t\t\t\t void *data,"}, {"sha": "2204dd043431f3e29d0a085aebd52b097fe451c0", "filename": "libbacktrace/pecoff.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9283471ba0d8b605a5ddf8cbd2814d81d4dd8550/libbacktrace%2Fpecoff.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9283471ba0d8b605a5ddf8cbd2814d81d4dd8550/libbacktrace%2Fpecoff.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2Fpecoff.c?ref=9283471ba0d8b605a5ddf8cbd2814d81d4dd8550", "patch": "@@ -890,7 +890,8 @@ coff_add (struct backtrace_state *state, int descriptor,\n    sections.  */\n \n int\n-backtrace_initialize (struct backtrace_state *state, int descriptor,\n+backtrace_initialize (struct backtrace_state *state,\n+\t\t      const char *filename ATTRIBUTE_UNUSED, int descriptor,\n \t\t      backtrace_error_callback error_callback,\n \t\t      void *data, fileline *fileline_fn)\n {"}, {"sha": "5df6d15f5545a8c3ed41b14d5de0da9ac8d77d72", "filename": "libbacktrace/unknown.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9283471ba0d8b605a5ddf8cbd2814d81d4dd8550/libbacktrace%2Funknown.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9283471ba0d8b605a5ddf8cbd2814d81d4dd8550/libbacktrace%2Funknown.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2Funknown.c?ref=9283471ba0d8b605a5ddf8cbd2814d81d4dd8550", "patch": "@@ -54,6 +54,7 @@ unknown_fileline (struct backtrace_state *state ATTRIBUTE_UNUSED,\n \n int\n backtrace_initialize (struct backtrace_state *state ATTRIBUTE_UNUSED,\n+\t\t      const char *filename ATTRIBUTE_UNUSED,\n \t\t      int descriptor ATTRIBUTE_UNUSED,\n \t\t      backtrace_error_callback error_callback ATTRIBUTE_UNUSED,\n \t\t      void *data ATTRIBUTE_UNUSED, fileline *fileline_fn)"}, {"sha": "f75239164ba4a4d56ebdb203c17fcf976914ad0b", "filename": "libbacktrace/xcoff.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9283471ba0d8b605a5ddf8cbd2814d81d4dd8550/libbacktrace%2Fxcoff.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9283471ba0d8b605a5ddf8cbd2814d81d4dd8550/libbacktrace%2Fxcoff.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libbacktrace%2Fxcoff.c?ref=9283471ba0d8b605a5ddf8cbd2814d81d4dd8550", "patch": "@@ -1434,7 +1434,8 @@ xcoff_add_shared_libs (struct backtrace_state *state,\n    Returns 1 on success, 0 on failure.  */\n \n int\n-backtrace_initialize (struct backtrace_state *state, int descriptor,\n+backtrace_initialize (struct backtrace_state *state,\n+\t\t      const char *filename ATTRIBUTE_UNUSED, int descriptor,\n \t\t      backtrace_error_callback error_callback,\n \t\t      void *data, fileline *fileline_fn)\n {"}]}