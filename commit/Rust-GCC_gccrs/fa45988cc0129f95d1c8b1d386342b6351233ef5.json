{"sha": "fa45988cc0129f95d1c8b1d386342b6351233ef5", "node_id": "C_kwDOANBUbNoAKGZhNDU5ODhjYzAxMjlmOTVkMWM4YjFkMzg2MzQyYjYzNTEyMzNlZjU", "commit": {"author": {"name": "Justin Squirek", "email": "squirek@adacore.com", "date": "2021-12-15T14:27:23Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2022-05-13T08:04:27Z"}, "message": "[Ada] Spurious access error in function returning type with access discriminant\n\nThis patch fixes an issue in the compiler whereby incorrect\naccessibility checks were generated in functions returning types with\nunconstrained access discriminants when the value supplied for the\ndiscriminant is a formal parameter.\n\nMore specifically, accessibility checks for return statements featuring\na result type having access discriminants were incorrectly being\nperformed against the level of the function declaration instead of the\nlevel of the master of the call.\n\ngcc/ada/\n\n\t* sem_ch6.adb (Check_Return_Construct_Accessibility): Modify\n\tgeneration of run-time accessibility checks to account for cases\n\twhere Extra_Accessibility_Of_Result should be used versus the\n\tlevel of the enclosing subprogram. Use original node to avoid\n\tchecking against expanded code. Disable check generation for\n\ttagged type case.\n\t(Is_Formal_Of_Current_Function): Added to encompass a predicate\n\tused within Check_Return_Construct_Accessibility to test if an\n\tassociated expression is related to a relevant formal.\n\t* sem_util.adb, sem_util.ads (Enclosing_Subprogram): Modified to\n\taccept Node_Or_Entity_Id.\n\t(Innermost_Master_Scope_Depth): Calculate level based on the\n\tsubprogram of a return statement instead of the one returned by\n\tCurrent_Subprogram.\n\t(Needs_Result_Accessibility_Level): Remove\n\tDisable_Coextension_Cases constant, and disable the tagged type\n\tcase for performance reasons.", "tree": {"sha": "20fd5f9324b5f2372e9bd5baba9a57daa41d0214", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/20fd5f9324b5f2372e9bd5baba9a57daa41d0214"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fa45988cc0129f95d1c8b1d386342b6351233ef5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa45988cc0129f95d1c8b1d386342b6351233ef5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fa45988cc0129f95d1c8b1d386342b6351233ef5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa45988cc0129f95d1c8b1d386342b6351233ef5/comments", "author": {"login": "AdaDoom3", "id": 3445599, "node_id": "MDQ6VXNlcjM0NDU1OTk=", "avatar_url": "https://avatars.githubusercontent.com/u/3445599?v=4", "gravatar_id": "", "url": "https://api.github.com/users/AdaDoom3", "html_url": "https://github.com/AdaDoom3", "followers_url": "https://api.github.com/users/AdaDoom3/followers", "following_url": "https://api.github.com/users/AdaDoom3/following{/other_user}", "gists_url": "https://api.github.com/users/AdaDoom3/gists{/gist_id}", "starred_url": "https://api.github.com/users/AdaDoom3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/AdaDoom3/subscriptions", "organizations_url": "https://api.github.com/users/AdaDoom3/orgs", "repos_url": "https://api.github.com/users/AdaDoom3/repos", "events_url": "https://api.github.com/users/AdaDoom3/events{/privacy}", "received_events_url": "https://api.github.com/users/AdaDoom3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "74ce1d5a6cbcf81e21b4c0eeee372df46c275df0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/74ce1d5a6cbcf81e21b4c0eeee372df46c275df0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/74ce1d5a6cbcf81e21b4c0eeee372df46c275df0"}], "stats": {"total": 128, "additions": 94, "deletions": 34}, "files": [{"sha": "17e7d26253483588b2c8115bbb6e78b2972116bc", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 57, "deletions": 12, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa45988cc0129f95d1c8b1d386342b6351233ef5/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa45988cc0129f95d1c8b1d386342b6351233ef5/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=fa45988cc0129f95d1c8b1d386342b6351233ef5", "patch": "@@ -777,6 +777,12 @@ package body Sem_Ch6 is\n          function First_Selector (Assoc : Node_Id) return Node_Id;\n          --  Obtain the first selector or choice from a given association\n \n+         function Is_Formal_Of_Current_Function\n+           (Assoc_Expr : Entity_Id) return Boolean;\n+         --  Predicate to test if a given expression associated with a\n+         --  discriminant is a formal parameter to the function in which the\n+         --  return construct we checking applies to.\n+\n          --------------------\n          -- First_Selector --\n          --------------------\n@@ -794,6 +800,19 @@ package body Sem_Ch6 is\n             end if;\n          end First_Selector;\n \n+         -----------------------------------\n+         -- Is_Formal_Of_Current_Function --\n+         -----------------------------------\n+\n+         function Is_Formal_Of_Current_Function\n+           (Assoc_Expr : Entity_Id) return Boolean is\n+         begin\n+            return Is_Entity_Name (Assoc_Expr)\n+                     and then Enclosing_Subprogram\n+                                (Entity (Assoc_Expr)) = Scope_Id\n+                     and then Is_Formal (Entity (Assoc_Expr));\n+         end Is_Formal_Of_Current_Function;\n+\n          --  Local declarations\n \n          Assoc : Node_Id := Empty;\n@@ -869,7 +888,10 @@ package body Sem_Ch6 is\n          --  with all anonymous access discriminants, then generate a\n          --  dynamic check or static error when relevant.\n \n-         Unqual := Unqualify (Original_Node (Return_Con));\n+         --  Note the repeated use of Original_Node to avoid checking\n+         --  expanded code.\n+\n+         Unqual := Original_Node (Unqualify (Original_Node (Return_Con)));\n \n          --  Get the corresponding declaration based on the return object's\n          --  identifier.\n@@ -1052,8 +1074,6 @@ package body Sem_Ch6 is\n                if Nkind (Assoc) = N_Component_Association\n                  and then Box_Present (Assoc)\n                then\n-                  Assoc_Present := False;\n-\n                   if Nkind (First_Selector (Assoc)) = N_Others_Choice then\n                      Unseen_Disc_Count := 0;\n                   end if;\n@@ -1178,24 +1198,49 @@ package body Sem_Ch6 is\n             if Present (Assoc_Expr)\n               and then Present (Disc)\n               and then Ekind (Etype (Disc)) = E_Anonymous_Access_Type\n+\n+              --  We disable the check when we have a tagged return type and\n+              --  the associated expression for the discriminant is a formal\n+              --  parameter since the check would require us to compare the\n+              --  accessibility level of Assoc_Expr to the level of the\n+              --  Extra_Accessibility_Of_Result of the function - which is\n+              --  currently disabled for functions with tagged return types.\n+              --  This may change in the future ???\n+\n+              --  See Needs_Result_Accessibility_Level for details.\n+\n+              and then not\n+                (No (Extra_Accessibility_Of_Result (Scope_Id))\n+                  and then Is_Formal_Of_Current_Function (Assoc_Expr)\n+                  and then Is_Tagged_Type (Etype (Scope_Id)))\n             then\n                --  Generate a dynamic check based on the extra accessibility of\n-               --  the result or the scope.\n+               --  the result or the scope of the current function.\n \n                Check_Cond :=\n                  Make_Op_Gt (Loc,\n                    Left_Opnd  => Accessibility_Level\n                                    (Expr              => Assoc_Expr,\n                                     Level             => Dynamic_Level,\n                                     In_Return_Context => True),\n-                   Right_Opnd => (if Present\n-                                       (Extra_Accessibility_Of_Result\n-                                         (Scope_Id))\n-                                  then\n-                                     Extra_Accessibility_Of_Result (Scope_Id)\n-                                  else\n-                                     Make_Integer_Literal\n-                                       (Loc, Scope_Depth (Scope (Scope_Id)))));\n+                   Right_Opnd =>\n+                     (if Present (Extra_Accessibility_Of_Result (Scope_Id))\n+\n+                        --  When Assoc_Expr is a formal we have to look at the\n+                        --  extra accessibility-level formal associated with\n+                        --  the result.\n+\n+                        and then Is_Formal_Of_Current_Function (Assoc_Expr)\n+                      then\n+                         New_Occurrence_Of\n+                           (Extra_Accessibility_Of_Result (Scope_Id), Loc)\n+\n+                      --  Otherwise, we compare the level of Assoc_Expr to the\n+                      --  scope of the current function.\n+\n+                      else\n+                         Make_Integer_Literal\n+                           (Loc, Scope_Depth (Scope (Scope_Id)))));\n \n                Insert_Before_And_Analyze (Return_Stmt,\n                  Make_Raise_Program_Error (Loc,"}, {"sha": "e2a4963241364b20065eb2e3b70c583ad6ff3b00", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 35, "deletions": 20, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa45988cc0129f95d1c8b1d386342b6351233ef5/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa45988cc0129f95d1c8b1d386342b6351233ef5/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=fa45988cc0129f95d1c8b1d386342b6351233ef5", "patch": "@@ -327,9 +327,8 @@ package body Sem_Util is\n \n             elsif Nkind (Node_Par) in N_Extended_Return_Statement\n                                     | N_Simple_Return_Statement\n-              and then Ekind (Current_Scope) = E_Function\n             then\n-               return Scope_Depth (Current_Scope);\n+               return Scope_Depth (Enclosing_Subprogram (Node_Par));\n \n             --  Statements are counted as masters\n \n@@ -8356,10 +8355,29 @@ package body Sem_Util is\n    -- Enclosing_Subprogram --\n    --------------------------\n \n-   function Enclosing_Subprogram (E : Entity_Id) return Entity_Id is\n-      Dyn_Scop : constant Entity_Id := Enclosing_Dynamic_Scope (E);\n+   function Enclosing_Subprogram (N : Node_Or_Entity_Id) return Entity_Id is\n+      Dyn_Scop  : Entity_Id;\n+      Encl_Scop : Entity_Id;\n \n    begin\n+      --  Obtain the enclosing scope when N is a Node_Id - taking care to\n+      --  handle the case when the enclosing scope is already a subprogram.\n+\n+      if Nkind (N) not in N_Entity then\n+         Encl_Scop := Find_Enclosing_Scope (N);\n+\n+         if No (Encl_Scop) then\n+            return Empty;\n+         elsif Ekind (Encl_Scop) in Subprogram_Kind then\n+            return Encl_Scop;\n+         end if;\n+\n+         return Enclosing_Subprogram (Encl_Scop);\n+      end if;\n+\n+      --  When N is already an Entity_Id proceed\n+\n+      Dyn_Scop := Enclosing_Dynamic_Scope (N);\n       if Dyn_Scop = Standard_Standard then\n          return Empty;\n \n@@ -23091,8 +23109,8 @@ package body Sem_Util is\n          if not Is_Limited_Type (Comp_Typ) then\n             return False;\n \n-            --  Only limited types can have access discriminants with\n-            --  defaults.\n+         --  Only limited types can have access discriminants with\n+         --  defaults.\n \n          elsif Has_Unconstrained_Access_Discriminants (Comp_Typ) then\n             return True;\n@@ -23122,16 +23140,18 @@ package body Sem_Util is\n          return False;\n       end Has_Unconstrained_Access_Discriminant_Component;\n \n-      Disable_Coextension_Cases : constant Boolean := True;\n-      --  Flag used to temporarily disable a \"True\" result for types with\n-      --  access discriminants and related coextension cases.\n+      Disable_Tagged_Cases : constant Boolean := True;\n+      --  Flag used to temporarily disable a \"True\" result for tagged types.\n+      --  See comments further below for details.\n \n    --  Start of processing for Needs_Result_Accessibility_Level\n \n    begin\n-      --  False if completion unavailable (how does this happen???)\n+      --  False if completion unavailable, which can happen when we are\n+      --  analyzing an abstract subprogram or if the subprogram has\n+      --  delayed freezing.\n \n-      if not Present (Func_Typ) then\n+      if No (Func_Typ) then\n          return False;\n \n       --  False if not a function, also handle enum-lit renames case\n@@ -23164,14 +23184,6 @@ package body Sem_Util is\n       elsif Ekind (Func_Typ) = E_Anonymous_Access_Type then\n          return True;\n \n-      --  The following cases are related to coextensions and do not fully\n-      --  cover everything mentioned in RM 3.10.2 (12) ???\n-\n-      --  Temporarily disabled ???\n-\n-      elsif Disable_Coextension_Cases then\n-         return False;\n-\n       --  In the case of, say, a null tagged record result type, the need for\n       --  this extra parameter might not be obvious so this function returns\n       --  True for all tagged types for compatibility reasons.\n@@ -23188,8 +23200,11 @@ package body Sem_Util is\n       --  solve these issues by introducing wrappers, but that is not the\n       --  approach that was chosen.\n \n+      --  Note: Despite the reasoning noted above, the extra accessibility\n+      --  parameter for tagged types is disabled for performance reasons.\n+\n       elsif Is_Tagged_Type (Func_Typ) then\n-         return True;\n+         return not Disable_Tagged_Cases;\n \n       elsif Has_Unconstrained_Access_Discriminants (Func_Typ) then\n          return True;"}, {"sha": "e5e1d01c905142ae5fabe0721aac93a0ec75160e", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa45988cc0129f95d1c8b1d386342b6351233ef5/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa45988cc0129f95d1c8b1d386342b6351233ef5/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=fa45988cc0129f95d1c8b1d386342b6351233ef5", "patch": "@@ -824,9 +824,9 @@ package Sem_Util is\n    --  Returns the entity of the package or subprogram enclosing E, if any.\n    --  Returns Empty if no enclosing package or subprogram.\n \n-   function Enclosing_Subprogram (E : Entity_Id) return Entity_Id;\n+   function Enclosing_Subprogram (N : Node_Or_Entity_Id) return Entity_Id;\n    --  Utility function to return the Ada entity of the subprogram enclosing\n-   --  the entity E, if any. Returns Empty if no enclosing subprogram.\n+   --  N, if any. Returns Empty if no enclosing subprogram.\n \n    function End_Keyword_Location (N : Node_Id) return Source_Ptr;\n    --  Given block statement, entry body, package body, package declaration,"}]}