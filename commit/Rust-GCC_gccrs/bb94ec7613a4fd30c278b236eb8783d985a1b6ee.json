{"sha": "bb94ec7613a4fd30c278b236eb8783d985a1b6ee", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmI5NGVjNzYxM2E0ZmQzMGMyNzhiMjM2ZWI4NzgzZDk4NWExYjZlZQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2018-01-03T21:42:20Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2018-01-03T21:42:20Z"}, "message": "poly_int: GET_MODE_PRECISION\n\nThis patch changes GET_MODE_PRECISION from an unsigned short\nto a poly_uint16.\n\n2018-01-03  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* machmode.h (mode_precision): Change from unsigned short to\n\tpoly_uint16_pod.\n\t(mode_to_precision): Return a poly_uint16 rather than an unsigned\n\tshort.\n\t(GET_MODE_PRECISION): Return a constant if ONLY_FIXED_SIZE_MODES,\n\tor if measurement_type is not polynomial.\n\t(HWI_COMPUTABLE_MODE_P): Turn into a function.  Optimize the case\n\tin which the mode is already known to be a scalar_int_mode.\n\t* genmodes.c (emit_mode_precision): Change the type of mode_precision\n\tfrom unsigned short to poly_uint16_pod.  Use ZERO_COEFFS for the\n\tinitializer.\n\t* lto-streamer-in.c (lto_input_mode_table): Use bp_unpack_poly_value\n\tfor GET_MODE_PRECISION.\n\t* lto-streamer-out.c (lto_write_mode_table): Use bp_pack_poly_value\n\tfor GET_MODE_PRECISION.\n\t* combine.c (update_rsp_from_reg_equal): Treat GET_MODE_PRECISION\n\tas polynomial.\n\t(try_combine, find_split_point, combine_simplify_rtx): Likewise.\n\t(expand_field_assignment, make_extraction): Likewise.\n\t(make_compound_operation_int, record_dead_and_set_regs_1): Likewise.\n\t(get_last_value): Likewise.\n\t* convert.c (convert_to_integer_1): Likewise.\n\t* cse.c (cse_insn): Likewise.\n\t* expr.c (expand_expr_real_1): Likewise.\n\t* lra-constraints.c (simplify_operand_subreg): Likewise.\n\t* optabs-query.c (can_atomic_load_p): Likewise.\n\t* optabs.c (expand_atomic_load): Likewise.\n\t(expand_atomic_store): Likewise.\n\t* ree.c (combine_reaching_defs): Likewise.\n\t* rtl.h (partial_subreg_p, paradoxical_subreg_p): Likewise.\n\t* rtlanal.c (nonzero_bits1, lsb_bitfield_op_p): Likewise.\n\t* tree.h (type_has_mode_precision_p): Likewise.\n\t* ubsan.c (instrument_si_overflow): Likewise.\n\ngcc/ada/\n\t* gcc-interface/misc.c (enumerate_modes): Treat GET_MODE_PRECISION\n\tas polynomial.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r256198", "tree": {"sha": "4107ec912099af2ee77d6199890da00ee700d935", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4107ec912099af2ee77d6199890da00ee700d935"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bb94ec7613a4fd30c278b236eb8783d985a1b6ee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bb94ec7613a4fd30c278b236eb8783d985a1b6ee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bb94ec7613a4fd30c278b236eb8783d985a1b6ee", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bb94ec7613a4fd30c278b236eb8783d985a1b6ee/comments", "author": null, "committer": null, "parents": [{"sha": "928686b1c6d0a8b791ec08b2588a5fb8118d191c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/928686b1c6d0a8b791ec08b2588a5fb8118d191c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/928686b1c6d0a8b791ec08b2588a5fb8118d191c"}], "stats": {"total": 251, "additions": 180, "deletions": 71}, "files": [{"sha": "bc000bceed60e32a21b37987b899aaf73e4c6696", "filename": "gcc/ChangeLog", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb94ec7613a4fd30c278b236eb8783d985a1b6ee/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb94ec7613a4fd30c278b236eb8783d985a1b6ee/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bb94ec7613a4fd30c278b236eb8783d985a1b6ee", "patch": "@@ -1,3 +1,41 @@\n+2018-01-03  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* machmode.h (mode_precision): Change from unsigned short to\n+\tpoly_uint16_pod.\n+\t(mode_to_precision): Return a poly_uint16 rather than an unsigned\n+\tshort.\n+\t(GET_MODE_PRECISION): Return a constant if ONLY_FIXED_SIZE_MODES,\n+\tor if measurement_type is not polynomial.\n+\t(HWI_COMPUTABLE_MODE_P): Turn into a function.  Optimize the case\n+\tin which the mode is already known to be a scalar_int_mode.\n+\t* genmodes.c (emit_mode_precision): Change the type of mode_precision\n+\tfrom unsigned short to poly_uint16_pod.  Use ZERO_COEFFS for the\n+\tinitializer.\n+\t* lto-streamer-in.c (lto_input_mode_table): Use bp_unpack_poly_value\n+\tfor GET_MODE_PRECISION.\n+\t* lto-streamer-out.c (lto_write_mode_table): Use bp_pack_poly_value\n+\tfor GET_MODE_PRECISION.\n+\t* combine.c (update_rsp_from_reg_equal): Treat GET_MODE_PRECISION\n+\tas polynomial.\n+\t(try_combine, find_split_point, combine_simplify_rtx): Likewise.\n+\t(expand_field_assignment, make_extraction): Likewise.\n+\t(make_compound_operation_int, record_dead_and_set_regs_1): Likewise.\n+\t(get_last_value): Likewise.\n+\t* convert.c (convert_to_integer_1): Likewise.\n+\t* cse.c (cse_insn): Likewise.\n+\t* expr.c (expand_expr_real_1): Likewise.\n+\t* lra-constraints.c (simplify_operand_subreg): Likewise.\n+\t* optabs-query.c (can_atomic_load_p): Likewise.\n+\t* optabs.c (expand_atomic_load): Likewise.\n+\t(expand_atomic_store): Likewise.\n+\t* ree.c (combine_reaching_defs): Likewise.\n+\t* rtl.h (partial_subreg_p, paradoxical_subreg_p): Likewise.\n+\t* rtlanal.c (nonzero_bits1, lsb_bitfield_op_p): Likewise.\n+\t* tree.h (type_has_mode_precision_p): Likewise.\n+\t* ubsan.c (instrument_si_overflow): Likewise.\n+\n 2018-01-03  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "dd4d515fabc1a793d84ced35e88d7a1cd9f81838", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb94ec7613a4fd30c278b236eb8783d985a1b6ee/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb94ec7613a4fd30c278b236eb8783d985a1b6ee/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=bb94ec7613a4fd30c278b236eb8783d985a1b6ee", "patch": "@@ -1,3 +1,10 @@\n+2018-01-03  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* gcc-interface/misc.c (enumerate_modes): Treat GET_MODE_PRECISION\n+\tas polynomial.\n+\n 2018-01-03  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "e74c3923dbe54c000f498b4344fae282593db0f7", "filename": "gcc/ada/gcc-interface/misc.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb94ec7613a4fd30c278b236eb8783d985a1b6ee/gcc%2Fada%2Fgcc-interface%2Fmisc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb94ec7613a4fd30c278b236eb8783d985a1b6ee/gcc%2Fada%2Fgcc-interface%2Fmisc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fmisc.c?ref=bb94ec7613a4fd30c278b236eb8783d985a1b6ee", "patch": "@@ -1301,11 +1301,13 @@ enumerate_modes (void (*f) (const char *, int, int, int, int, int, int, int))\n \t  }\n \n       /* If no predefined C types were found, register the mode itself.  */\n-      int nunits;\n-      if (!skip_p && GET_MODE_NUNITS (i).is_constant (&nunits))\n+      int nunits, precision;\n+      if (!skip_p\n+\t  && GET_MODE_NUNITS (i).is_constant (&nunits)\n+\t  && GET_MODE_PRECISION (i).is_constant (&precision))\n \tf (GET_MODE_NAME (i), digs, complex_p,\n \t   vector_p ? nunits : 0, float_rep,\n-\t   GET_MODE_PRECISION (i), GET_MODE_BITSIZE (i),\n+\t   precision, GET_MODE_BITSIZE (i),\n \t   GET_MODE_ALIGNMENT (i));\n     }\n }"}, {"sha": "fa6947a98e45f67cc8034890b4f2c041942081d7", "filename": "gcc/combine.c", "status": "modified", "additions": 42, "deletions": 35, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb94ec7613a4fd30c278b236eb8783d985a1b6ee/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb94ec7613a4fd30c278b236eb8783d985a1b6ee/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=bb94ec7613a4fd30c278b236eb8783d985a1b6ee", "patch": "@@ -1706,7 +1706,7 @@ update_rsp_from_reg_equal (reg_stat_type *rsp, rtx_insn *insn, const_rtx set,\n   if (rsp->sign_bit_copies != 1)\n     {\n       num = num_sign_bit_copies (SET_SRC (set), GET_MODE (x));\n-      if (reg_equal && num != GET_MODE_PRECISION (GET_MODE (x)))\n+      if (reg_equal && maybe_ne (num, GET_MODE_PRECISION (GET_MODE (x))))\n \t{\n \t  unsigned int numeq = num_sign_bit_copies (reg_equal, GET_MODE (x));\n \t  if (num == 0 || numeq > num)\n@@ -3962,16 +3962,20 @@ try_combine (rtx_insn *i3, rtx_insn *i2, rtx_insn *i1, rtx_insn *i0,\n \t   && ! (temp_expr = SET_DEST (XVECEXP (newpat, 0, 1)),\n \t\t (REG_P (temp_expr)\n \t\t  && reg_stat[REGNO (temp_expr)].nonzero_bits != 0\n-\t\t  && GET_MODE_PRECISION (GET_MODE (temp_expr)) < BITS_PER_WORD\n-\t\t  && GET_MODE_PRECISION (GET_MODE (temp_expr)) < HOST_BITS_PER_INT\n+\t\t  && known_lt (GET_MODE_PRECISION (GET_MODE (temp_expr)),\n+\t\t\t       BITS_PER_WORD)\n+\t\t  && known_lt (GET_MODE_PRECISION (GET_MODE (temp_expr)),\n+\t\t\t       HOST_BITS_PER_INT)\n \t\t  && (reg_stat[REGNO (temp_expr)].nonzero_bits\n \t\t      != GET_MODE_MASK (word_mode))))\n \t   && ! (GET_CODE (SET_DEST (XVECEXP (newpat, 0, 1))) == SUBREG\n \t\t && (temp_expr = SUBREG_REG (SET_DEST (XVECEXP (newpat, 0, 1))),\n \t\t     (REG_P (temp_expr)\n \t\t      && reg_stat[REGNO (temp_expr)].nonzero_bits != 0\n-\t\t      && GET_MODE_PRECISION (GET_MODE (temp_expr)) < BITS_PER_WORD\n-\t\t      && GET_MODE_PRECISION (GET_MODE (temp_expr)) < HOST_BITS_PER_INT\n+\t\t      && known_lt (GET_MODE_PRECISION (GET_MODE (temp_expr)),\n+\t\t\t\t   BITS_PER_WORD)\n+\t\t      && known_lt (GET_MODE_PRECISION (GET_MODE (temp_expr)),\n+\t\t\t\t   HOST_BITS_PER_INT)\n \t\t      && (reg_stat[REGNO (temp_expr)].nonzero_bits\n \t\t\t  != GET_MODE_MASK (word_mode)))))\n \t   && ! reg_overlap_mentioned_p (SET_DEST (XVECEXP (newpat, 0, 1)),\n@@ -5140,8 +5144,9 @@ find_split_point (rtx *loc, rtx_insn *insn, bool set_src)\n \t  break;\n \t}\n \n-      if (len && pos >= 0\n-\t  && pos + len <= GET_MODE_PRECISION (GET_MODE (inner))\n+      if (len\n+\t  && known_subrange_p (pos, len,\n+\t\t\t       0, GET_MODE_PRECISION (GET_MODE (inner)))\n \t  && is_a <scalar_int_mode> (GET_MODE (SET_SRC (x)), &mode))\n \t{\n \t  /* For unsigned, we have a choice of a shift followed by an\n@@ -6007,8 +6012,9 @@ combine_simplify_rtx (rtx x, machine_mode op0_mode, int in_dest,\n \t       && (UINTVAL (XEXP (XEXP (XEXP (x, 0), 0), 1))\n \t\t   == (HOST_WIDE_INT_1U << (i + 1)) - 1))\n \t      || (GET_CODE (XEXP (XEXP (x, 0), 0)) == ZERO_EXTEND\n-\t\t  && (GET_MODE_PRECISION (GET_MODE (XEXP (XEXP (XEXP (x, 0), 0), 0)))\n-\t\t      == (unsigned int) i + 1))))\n+\t\t  && known_eq ((GET_MODE_PRECISION\n+\t\t\t\t(GET_MODE (XEXP (XEXP (XEXP (x, 0), 0), 0)))),\n+\t\t\t       (unsigned int) i + 1))))\n \treturn simplify_shift_const\n \t  (NULL_RTX, ASHIFTRT, int_mode,\n \t   simplify_shift_const (NULL_RTX, ASHIFT, int_mode,\n@@ -7346,7 +7352,7 @@ expand_field_assignment (const_rtx x)\n {\n   rtx inner;\n   rtx pos;\t\t\t/* Always counts from low bit.  */\n-  int len;\n+  int len, inner_len;\n   rtx mask, cleared, masked;\n   scalar_int_mode compute_mode;\n \n@@ -7356,42 +7362,41 @@ expand_field_assignment (const_rtx x)\n       if (GET_CODE (SET_DEST (x)) == STRICT_LOW_PART\n \t  && GET_CODE (XEXP (SET_DEST (x), 0)) == SUBREG)\n \t{\n+\t  rtx x0 = XEXP (SET_DEST (x), 0);\n+\t  if (!GET_MODE_PRECISION (GET_MODE (x0)).is_constant (&len))\n+\t    break;\n \t  inner = SUBREG_REG (XEXP (SET_DEST (x), 0));\n-\t  len = GET_MODE_PRECISION (GET_MODE (XEXP (SET_DEST (x), 0)));\n \t  pos = gen_int_mode (subreg_lsb (XEXP (SET_DEST (x), 0)),\n \t\t\t      MAX_MODE_INT);\n \t}\n       else if (GET_CODE (SET_DEST (x)) == ZERO_EXTRACT\n \t       && CONST_INT_P (XEXP (SET_DEST (x), 1)))\n \t{\n \t  inner = XEXP (SET_DEST (x), 0);\n+\t  if (!GET_MODE_PRECISION (GET_MODE (inner)).is_constant (&inner_len))\n+\t    break;\n+\n \t  len = INTVAL (XEXP (SET_DEST (x), 1));\n \t  pos = XEXP (SET_DEST (x), 2);\n \n \t  /* A constant position should stay within the width of INNER.  */\n-\t  if (CONST_INT_P (pos)\n-\t      && INTVAL (pos) + len > GET_MODE_PRECISION (GET_MODE (inner)))\n+\t  if (CONST_INT_P (pos) && INTVAL (pos) + len > inner_len)\n \t    break;\n \n \t  if (BITS_BIG_ENDIAN)\n \t    {\n \t      if (CONST_INT_P (pos))\n-\t\tpos = GEN_INT (GET_MODE_PRECISION (GET_MODE (inner)) - len\n-\t\t\t       - INTVAL (pos));\n+\t\tpos = GEN_INT (inner_len - len - INTVAL (pos));\n \t      else if (GET_CODE (pos) == MINUS\n \t\t       && CONST_INT_P (XEXP (pos, 1))\n-\t\t       && (INTVAL (XEXP (pos, 1))\n-\t\t\t   == GET_MODE_PRECISION (GET_MODE (inner)) - len))\n+\t\t       && INTVAL (XEXP (pos, 1)) == inner_len - len)\n \t\t/* If position is ADJUST - X, new position is X.  */\n \t\tpos = XEXP (pos, 0);\n \t      else\n-\t\t{\n-\t\t  HOST_WIDE_INT prec = GET_MODE_PRECISION (GET_MODE (inner));\n-\t\t  pos = simplify_gen_binary (MINUS, GET_MODE (pos),\n-\t\t\t\t\t     gen_int_mode (prec - len,\n-\t\t\t\t\t\t\t   GET_MODE (pos)),\n-\t\t\t\t\t     pos);\n-\t\t}\n+\t\tpos = simplify_gen_binary (MINUS, GET_MODE (pos),\n+\t\t\t\t\t   gen_int_mode (inner_len - len,\n+\t\t\t\t\t\t\t GET_MODE (pos)),\n+\t\t\t\t\t   pos);\n \t    }\n \t}\n \n@@ -7511,7 +7516,7 @@ make_extraction (machine_mode mode, rtx inner, HOST_WIDE_INT pos,\n \t     bits outside of is_mode, don't look through\n \t     non-paradoxical SUBREGs.  See PR82192.  */\n \t  || (pos_rtx == NULL_RTX\n-\t      && pos + len <= GET_MODE_PRECISION (is_mode))))\n+\t      && known_le (pos + len, GET_MODE_PRECISION (is_mode)))))\n     {\n       /* If going from (subreg:SI (mem:QI ...)) to (mem:QI ...),\n \t consider just the QI as the memory to extract from.\n@@ -7542,7 +7547,7 @@ make_extraction (machine_mode mode, rtx inner, HOST_WIDE_INT pos,\n \t      bits outside of is_mode, don't look through\n \t      TRUNCATE.  See PR82192.  */\n \t   && pos_rtx == NULL_RTX\n-\t   && pos + len <= GET_MODE_PRECISION (is_mode))\n+\t   && known_le (pos + len, GET_MODE_PRECISION (is_mode)))\n     inner = XEXP (inner, 0);\n \n   inner_mode = GET_MODE (inner);\n@@ -7589,11 +7594,12 @@ make_extraction (machine_mode mode, rtx inner, HOST_WIDE_INT pos,\n \n       if (MEM_P (inner))\n \t{\n-\t  HOST_WIDE_INT offset;\n+\t  poly_int64 offset;\n \n \t  /* POS counts from lsb, but make OFFSET count in memory order.  */\n \t  if (BYTES_BIG_ENDIAN)\n-\t    offset = (GET_MODE_PRECISION (is_mode) - len - pos) / BITS_PER_UNIT;\n+\t    offset = bits_to_bytes_round_down (GET_MODE_PRECISION (is_mode)\n+\t\t\t\t\t       - len - pos);\n \t  else\n \t    offset = pos / BITS_PER_UNIT;\n \n@@ -7685,7 +7691,7 @@ make_extraction (machine_mode mode, rtx inner, HOST_WIDE_INT pos,\n      other cases, we would only be going outside our object in cases when\n      an original shift would have been undefined.  */\n   if (MEM_P (inner)\n-      && ((pos_rtx == 0 && pos + len > GET_MODE_PRECISION (is_mode))\n+      && ((pos_rtx == 0 && maybe_gt (pos + len, GET_MODE_PRECISION (is_mode)))\n \t  || (pos_rtx != 0 && len != 1)))\n     return 0;\n \n@@ -8164,8 +8170,10 @@ make_compound_operation_int (scalar_int_mode mode, rtx *x_ptr,\n \n \t  sub = XEXP (XEXP (x, 0), 0);\n \t  machine_mode sub_mode = GET_MODE (sub);\n+\t  int sub_width;\n \t  if ((REG_P (sub) || MEM_P (sub))\n-\t      && GET_MODE_PRECISION (sub_mode) < mode_width)\n+\t      && GET_MODE_PRECISION (sub_mode).is_constant (&sub_width)\n+\t      && sub_width < mode_width)\n \t    {\n \t      unsigned HOST_WIDE_INT mode_mask = GET_MODE_MASK (sub_mode);\n \t      unsigned HOST_WIDE_INT mask;\n@@ -8175,8 +8183,7 @@ make_compound_operation_int (scalar_int_mode mode, rtx *x_ptr,\n \t      if ((mask & mode_mask) == mode_mask)\n \t\t{\n \t\t  new_rtx = make_compound_operation (sub, next_code);\n-\t\t  new_rtx = make_extraction (mode, new_rtx, 0, 0,\n-\t\t\t\t\t     GET_MODE_PRECISION (sub_mode),\n+\t\t  new_rtx = make_extraction (mode, new_rtx, 0, 0, sub_width,\n \t\t\t\t\t     1, 0, in_code == COMPARE);\n \t\t}\n \t    }\n@@ -13248,7 +13255,7 @@ record_dead_and_set_regs_1 (rtx dest, const_rtx setter, void *data)\n       else if (GET_CODE (setter) == SET\n \t       && GET_CODE (SET_DEST (setter)) == SUBREG\n \t       && SUBREG_REG (SET_DEST (setter)) == dest\n-\t       && GET_MODE_PRECISION (GET_MODE (dest)) <= BITS_PER_WORD\n+\t       && known_le (GET_MODE_PRECISION (GET_MODE (dest)), BITS_PER_WORD)\n \t       && subreg_lowpart_p (SET_DEST (setter)))\n \trecord_value_for_reg (dest, record_dead_insn,\n \t\t\t      gen_lowpart (GET_MODE (dest),\n@@ -13650,8 +13657,8 @@ get_last_value (const_rtx x)\n \n   /* If fewer bits were set than what we are asked for now, we cannot use\n      the value.  */\n-  if (GET_MODE_PRECISION (rsp->last_set_mode)\n-      < GET_MODE_PRECISION (GET_MODE (x)))\n+  if (maybe_lt (GET_MODE_PRECISION (rsp->last_set_mode),\n+\t\tGET_MODE_PRECISION (GET_MODE (x))))\n     return 0;\n \n   /* If the value has all its registers valid, return it.  */"}, {"sha": "4b92cc58a5947a9dc7829e993afd3ab8e24d39f8", "filename": "gcc/convert.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb94ec7613a4fd30c278b236eb8783d985a1b6ee/gcc%2Fconvert.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb94ec7613a4fd30c278b236eb8783d985a1b6ee/gcc%2Fconvert.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconvert.c?ref=bb94ec7613a4fd30c278b236eb8783d985a1b6ee", "patch": "@@ -737,7 +737,7 @@ convert_to_integer_1 (tree type, tree expr, bool dofold)\n \t type corresponding to its mode, then do a nop conversion\n \t to TYPE.  */\n       else if (TREE_CODE (type) == ENUMERAL_TYPE\n-\t       || outprec != GET_MODE_PRECISION (TYPE_MODE (type)))\n+\t       || maybe_ne (outprec, GET_MODE_PRECISION (TYPE_MODE (type))))\n \t{\n \t  expr = convert (lang_hooks.types.type_for_mode\n \t\t\t  (TYPE_MODE (type), TYPE_UNSIGNED (type)), expr);"}, {"sha": "2101eeb8244d1fc88ebaa3d77973e2ad2bfa4349", "filename": "gcc/cse.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb94ec7613a4fd30c278b236eb8783d985a1b6ee/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb94ec7613a4fd30c278b236eb8783d985a1b6ee/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=bb94ec7613a4fd30c278b236eb8783d985a1b6ee", "patch": "@@ -5231,8 +5231,9 @@ cse_insn (rtx_insn *insn)\n \t      && CONST_INT_P (XEXP (SET_DEST (sets[i].rtl), 1))\n \t      && CONST_INT_P (XEXP (SET_DEST (sets[i].rtl), 2))\n \t      && REG_P (XEXP (SET_DEST (sets[i].rtl), 0))\n-\t      && (GET_MODE_PRECISION (GET_MODE (SET_DEST (sets[i].rtl)))\n-\t\t  >= INTVAL (XEXP (SET_DEST (sets[i].rtl), 1)))\n+\t      && (known_ge\n+\t\t  (GET_MODE_PRECISION (GET_MODE (SET_DEST (sets[i].rtl))),\n+\t\t   INTVAL (XEXP (SET_DEST (sets[i].rtl), 1))))\n \t      && ((unsigned) INTVAL (XEXP (SET_DEST (sets[i].rtl), 1))\n \t\t  + (unsigned) INTVAL (XEXP (SET_DEST (sets[i].rtl), 2))\n \t\t  <= HOST_BITS_PER_WIDE_INT))"}, {"sha": "5c1a111bac2d231a87b210ad85e3726483348e7e", "filename": "gcc/expr.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb94ec7613a4fd30c278b236eb8783d985a1b6ee/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb94ec7613a4fd30c278b236eb8783d985a1b6ee/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=bb94ec7613a4fd30c278b236eb8783d985a1b6ee", "patch": "@@ -11053,9 +11053,10 @@ expand_expr_real_1 (tree exp, rtx target, machine_mode tmode,\n \t;\n       /* If neither mode is BLKmode, and both modes are the same size\n \t then we can use gen_lowpart.  */\n-      else if (mode != BLKmode && GET_MODE (op0) != BLKmode\n-\t       && (GET_MODE_PRECISION (mode)\n-\t\t   == GET_MODE_PRECISION (GET_MODE (op0)))\n+      else if (mode != BLKmode\n+\t       && GET_MODE (op0) != BLKmode\n+\t       && known_eq (GET_MODE_PRECISION (mode),\n+\t\t\t    GET_MODE_PRECISION (GET_MODE (op0)))\n \t       && !COMPLEX_MODE_P (GET_MODE (op0)))\n \t{\n \t  if (GET_CODE (op0) == SUBREG)"}, {"sha": "62302704f64f99948b7b6ded3e9e0f5b849411c6", "filename": "gcc/genmodes.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb94ec7613a4fd30c278b236eb8783d985a1b6ee/gcc%2Fgenmodes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb94ec7613a4fd30c278b236eb8783d985a1b6ee/gcc%2Fgenmodes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenmodes.c?ref=bb94ec7613a4fd30c278b236eb8783d985a1b6ee", "patch": "@@ -1358,13 +1358,14 @@ emit_mode_precision (void)\n   int c;\n   struct mode_data *m;\n \n-  print_decl (\"unsigned short\", \"mode_precision\", \"NUM_MACHINE_MODES\");\n+  print_decl (\"poly_uint16_pod\", \"mode_precision\", \"NUM_MACHINE_MODES\");\n \n   for_all_modes (c, m)\n     if (m->precision != (unsigned int)-1)\n-      tagged_printf (\"%u\", m->precision, m->name);\n+      tagged_printf (\"{ %u\" ZERO_COEFFS \" }\", m->precision, m->name);\n     else\n-      tagged_printf (\"%u*BITS_PER_UNIT\", m->bytesize, m->name);\n+      tagged_printf (\"{ %u * BITS_PER_UNIT\" ZERO_COEFFS \" }\",\n+\t\t     m->bytesize, m->name);\n \n   print_closer ();\n }"}, {"sha": "8eeff0166e28719db090c9141fcc23e188ca6052", "filename": "gcc/lra-constraints.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb94ec7613a4fd30c278b236eb8783d985a1b6ee/gcc%2Flra-constraints.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb94ec7613a4fd30c278b236eb8783d985a1b6ee/gcc%2Flra-constraints.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-constraints.c?ref=bb94ec7613a4fd30c278b236eb8783d985a1b6ee", "patch": "@@ -1555,7 +1555,8 @@ simplify_operand_subreg (int nop, machine_mode reg_mode)\n \t     missing important data from memory when the inner is wider than\n \t     outer.  This rule only applies to modes that are no wider than\n \t     a word.  */\n-\t  if (!(GET_MODE_PRECISION (mode) != GET_MODE_PRECISION (innermode)\n+\t  if (!(maybe_ne (GET_MODE_PRECISION (mode),\n+\t\t\t  GET_MODE_PRECISION (innermode))\n \t\t&& GET_MODE_SIZE (mode) <= UNITS_PER_WORD\n \t\t&& GET_MODE_SIZE (innermode) <= UNITS_PER_WORD\n \t\t&& WORD_REGISTER_OPERATIONS)"}, {"sha": "afca7f421a388f33a0d38942a1dc51ff5f7c2733", "filename": "gcc/lto-streamer-in.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb94ec7613a4fd30c278b236eb8783d985a1b6ee/gcc%2Flto-streamer-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb94ec7613a4fd30c278b236eb8783d985a1b6ee/gcc%2Flto-streamer-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-in.c?ref=bb94ec7613a4fd30c278b236eb8783d985a1b6ee", "patch": "@@ -1618,7 +1618,7 @@ lto_input_mode_table (struct lto_file_decl_data *file_data)\n       enum mode_class mclass\n \t= bp_unpack_enum (&bp, mode_class, MAX_MODE_CLASS);\n       unsigned int size = bp_unpack_value (&bp, 8);\n-      unsigned int prec = bp_unpack_value (&bp, 16);\n+      poly_uint16 prec = bp_unpack_poly_value (&bp, 16);\n       machine_mode inner = (machine_mode) bp_unpack_value (&bp, 8);\n       poly_uint16 nunits = bp_unpack_poly_value (&bp, 16);\n       unsigned int ibit = 0, fbit = 0;\n@@ -1652,7 +1652,7 @@ lto_input_mode_table (struct lto_file_decl_data *file_data)\n \t\t  : mr = GET_MODE_WIDER_MODE (mr).else_void ())\n \t  if (GET_MODE_CLASS (mr) != mclass\n \t      || GET_MODE_SIZE (mr) != size\n-\t      || GET_MODE_PRECISION (mr) != prec\n+\t      || maybe_ne (GET_MODE_PRECISION (mr), prec)\n \t      || (inner == m\n \t\t  ? GET_MODE_INNER (mr) != mr\n \t\t  : GET_MODE_INNER (mr) != table[(int) inner])"}, {"sha": "86ac8112fd2a5fe8d83eda5cde92bd9368cfd77b", "filename": "gcc/lto-streamer-out.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb94ec7613a4fd30c278b236eb8783d985a1b6ee/gcc%2Flto-streamer-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb94ec7613a4fd30c278b236eb8783d985a1b6ee/gcc%2Flto-streamer-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-out.c?ref=bb94ec7613a4fd30c278b236eb8783d985a1b6ee", "patch": "@@ -2811,7 +2811,7 @@ lto_write_mode_table (void)\n \t  bp_pack_value (&bp, m, 8);\n \t  bp_pack_enum (&bp, mode_class, MAX_MODE_CLASS, GET_MODE_CLASS (m));\n \t  bp_pack_value (&bp, GET_MODE_SIZE (m), 8);\n-\t  bp_pack_value (&bp, GET_MODE_PRECISION (m), 16);\n+\t  bp_pack_poly_value (&bp, GET_MODE_PRECISION (m), 16);\n \t  bp_pack_value (&bp, GET_MODE_INNER (m), 8);\n \t  bp_pack_poly_value (&bp, GET_MODE_NUNITS (m), 16);\n \t  switch (GET_MODE_CLASS (m))"}, {"sha": "99ffbb7833d36ca0b0976e4de8ddde492df3c57d", "filename": "gcc/machmode.h", "status": "modified", "additions": 42, "deletions": 6, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb94ec7613a4fd30c278b236eb8783d985a1b6ee/gcc%2Fmachmode.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb94ec7613a4fd30c278b236eb8783d985a1b6ee/gcc%2Fmachmode.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmachmode.h?ref=bb94ec7613a4fd30c278b236eb8783d985a1b6ee", "patch": "@@ -23,7 +23,7 @@ along with GCC; see the file COPYING3.  If not see\n typedef opt_mode<machine_mode> opt_machine_mode;\n \n extern CONST_MODE_SIZE unsigned short mode_size[NUM_MACHINE_MODES];\n-extern const unsigned short mode_precision[NUM_MACHINE_MODES];\n+extern const poly_uint16_pod mode_precision[NUM_MACHINE_MODES];\n extern const unsigned char mode_inner[NUM_MACHINE_MODES];\n extern const poly_uint16_pod mode_nunits[NUM_MACHINE_MODES];\n extern CONST_MODE_UNIT_SIZE unsigned char mode_unit_size[NUM_MACHINE_MODES];\n@@ -535,7 +535,7 @@ mode_to_bits (machine_mode mode)\n \n /* Return the base GET_MODE_PRECISION value for MODE.  */\n \n-ALWAYS_INLINE unsigned short\n+ALWAYS_INLINE poly_uint16\n mode_to_precision (machine_mode mode)\n {\n   return mode_precision[mode];\n@@ -604,7 +604,30 @@ mode_to_nunits (machine_mode mode)\n \n /* Get the number of value bits of an object of mode MODE.  */\n \n-#define GET_MODE_PRECISION(MODE) (mode_to_precision (MODE))\n+#if ONLY_FIXED_SIZE_MODES\n+#define GET_MODE_PRECISION(MODE) \\\n+  ((unsigned short) mode_to_precision (MODE).coeffs[0])\n+#else\n+ALWAYS_INLINE poly_uint16\n+GET_MODE_PRECISION (machine_mode mode)\n+{\n+  return mode_to_precision (mode);\n+}\n+\n+template<typename T>\n+ALWAYS_INLINE typename if_poly<typename T::measurement_type>::type\n+GET_MODE_PRECISION (const T &mode)\n+{\n+  return mode_to_precision (mode);\n+}\n+\n+template<typename T>\n+ALWAYS_INLINE typename if_nonpoly<typename T::measurement_type>::type\n+GET_MODE_PRECISION (const T &mode)\n+{\n+  return mode_to_precision (mode).coeffs[0];\n+}\n+#endif\n \n /* Get the number of integral bits of an object of mode MODE.  */\n extern CONST_MODE_IBIT unsigned char mode_ibit[NUM_MACHINE_MODES];\n@@ -863,9 +886,22 @@ extern void init_adjust_machine_modes (void);\n   (targetm.truly_noop_truncation (GET_MODE_PRECISION (MODE1), \\\n \t\t\t\t  GET_MODE_PRECISION (MODE2)))\n \n-#define HWI_COMPUTABLE_MODE_P(MODE) \\\n-  (SCALAR_INT_MODE_P (MODE) \\\n-   && GET_MODE_PRECISION (MODE) <= HOST_BITS_PER_WIDE_INT)\n+/* Return true if MODE is a scalar integer mode that fits in a\n+   HOST_WIDE_INT.  */\n+\n+inline bool\n+HWI_COMPUTABLE_MODE_P (machine_mode mode)\n+{\n+  machine_mode mme = mode;\n+  return (SCALAR_INT_MODE_P (mme)\n+\t  && mode_to_precision (mme).coeffs[0] <= HOST_BITS_PER_WIDE_INT);\n+}\n+\n+inline bool\n+HWI_COMPUTABLE_MODE_P (scalar_int_mode mode)\n+{\n+  return GET_MODE_PRECISION (mode) <= HOST_BITS_PER_WIDE_INT;\n+}\n \n struct int_n_data_t {\n   /* These parts are initailized by genmodes output */"}, {"sha": "f823b98f8b57f5213d66908436c7d2ded02cd0f0", "filename": "gcc/optabs-query.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb94ec7613a4fd30c278b236eb8783d985a1b6ee/gcc%2Foptabs-query.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb94ec7613a4fd30c278b236eb8783d985a1b6ee/gcc%2Foptabs-query.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs-query.c?ref=bb94ec7613a4fd30c278b236eb8783d985a1b6ee", "patch": "@@ -653,7 +653,7 @@ can_atomic_load_p (machine_mode mode)\n   /* If the size of the object is greater than word size on this target,\n      then we assume that a load will not be atomic.  Also see\n      expand_atomic_load.  */\n-  return GET_MODE_PRECISION (mode) <= BITS_PER_WORD;\n+  return known_le (GET_MODE_PRECISION (mode), BITS_PER_WORD);\n }\n \n /* Determine whether \"1 << x\" is relatively cheap in word_mode.  */"}, {"sha": "6fe0d76c716cce7394fba9109b31f3dd7fed63a3", "filename": "gcc/optabs.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb94ec7613a4fd30c278b236eb8783d985a1b6ee/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb94ec7613a4fd30c278b236eb8783d985a1b6ee/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=bb94ec7613a4fd30c278b236eb8783d985a1b6ee", "patch": "@@ -6498,7 +6498,7 @@ expand_atomic_load (rtx target, rtx mem, enum memmodel model)\n      emulate a load with a compare-and-swap operation, but the store that\n      doing this could result in would be incorrect if this is a volatile\n      atomic load or targetting read-only-mapped memory.  */\n-  if (GET_MODE_PRECISION (mode) > BITS_PER_WORD)\n+  if (maybe_gt (GET_MODE_PRECISION (mode), BITS_PER_WORD))\n     /* If there is no atomic load, leave the library call.  */\n     return NULL_RTX;\n \n@@ -6572,7 +6572,7 @@ expand_atomic_store (rtx mem, rtx val, enum memmodel model, bool use_release)\n \n   /* If the size of the object is greater than word size on this target,\n      a default store will not be atomic.  */\n-  if (GET_MODE_PRECISION (mode) > BITS_PER_WORD)\n+  if (maybe_gt (GET_MODE_PRECISION (mode), BITS_PER_WORD))\n     {\n       /* If loads are atomic or we are called to provide a __sync builtin,\n \t we can try a atomic_exchange and throw away the result.  Otherwise,"}, {"sha": "aa0132bd01c7fe5d82b17a2934d18c0735beca0a", "filename": "gcc/ree.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb94ec7613a4fd30c278b236eb8783d985a1b6ee/gcc%2Free.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb94ec7613a4fd30c278b236eb8783d985a1b6ee/gcc%2Free.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Free.c?ref=bb94ec7613a4fd30c278b236eb8783d985a1b6ee", "patch": "@@ -861,9 +861,9 @@ combine_reaching_defs (ext_cand *cand, const_rtx set_pat, ext_state *state)\n \t as destination register will not affect its reaching uses, which may\n \t read its value in a larger mode because DEF_INSN implicitly sets it\n \t in word mode.  */\n-      const unsigned int prec\n+      poly_int64 prec\n \t= GET_MODE_PRECISION (GET_MODE (SET_DEST (*dest_sub_rtx)));\n-      if (WORD_REGISTER_OPERATIONS && prec < BITS_PER_WORD)\n+      if (WORD_REGISTER_OPERATIONS && known_lt (prec, BITS_PER_WORD))\n \t{\n \t  struct df_link *uses = get_uses (def_insn, src_reg);\n \t  if (!uses)"}, {"sha": "224dc966332af816a4e7cfd490e2e2bcd6a73064", "filename": "gcc/rtl.h", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb94ec7613a4fd30c278b236eb8783d985a1b6ee/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb94ec7613a4fd30c278b236eb8783d985a1b6ee/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=bb94ec7613a4fd30c278b236eb8783d985a1b6ee", "patch": "@@ -3106,7 +3106,12 @@ extern poly_uint64 subreg_size_lowpart_offset (poly_uint64, poly_uint64);\n inline bool\n partial_subreg_p (machine_mode outermode, machine_mode innermode)\n {\n-  return GET_MODE_PRECISION (outermode) < GET_MODE_PRECISION (innermode);\n+  /* Modes involved in a subreg must be ordered.  In particular, we must\n+     always know at compile time whether the subreg is paradoxical.  */\n+  poly_int64 outer_prec = GET_MODE_PRECISION (outermode);\n+  poly_int64 inner_prec = GET_MODE_PRECISION (innermode);\n+  gcc_checking_assert (ordered_p (outer_prec, inner_prec));\n+  return maybe_lt (outer_prec, inner_prec);\n }\n \n /* Likewise return true if X is a subreg that is smaller than the inner\n@@ -3127,7 +3132,12 @@ partial_subreg_p (const_rtx x)\n inline bool\n paradoxical_subreg_p (machine_mode outermode, machine_mode innermode)\n {\n-  return GET_MODE_PRECISION (outermode) > GET_MODE_PRECISION (innermode);\n+  /* Modes involved in a subreg must be ordered.  In particular, we must\n+     always know at compile time whether the subreg is paradoxical.  */\n+  poly_int64 outer_prec = GET_MODE_PRECISION (outermode);\n+  poly_int64 inner_prec = GET_MODE_PRECISION (innermode);\n+  gcc_checking_assert (ordered_p (outer_prec, inner_prec));\n+  return maybe_gt (outer_prec, inner_prec);\n }\n \n /* Return true if X is a paradoxical subreg, false otherwise.  */"}, {"sha": "54b14d8ab3d21c0aa66f34ce8cdef8618e6fbde0", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb94ec7613a4fd30c278b236eb8783d985a1b6ee/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb94ec7613a4fd30c278b236eb8783d985a1b6ee/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=bb94ec7613a4fd30c278b236eb8783d985a1b6ee", "patch": "@@ -4431,6 +4431,7 @@ nonzero_bits1 (const_rtx x, scalar_int_mode mode, const_rtx known_x,\n   unsigned HOST_WIDE_INT inner_nz;\n   enum rtx_code code;\n   machine_mode inner_mode;\n+  unsigned int inner_width;\n   scalar_int_mode xmode;\n \n   unsigned int mode_width = GET_MODE_PRECISION (mode);\n@@ -4735,8 +4736,9 @@ nonzero_bits1 (const_rtx x, scalar_int_mode mode, const_rtx known_x,\n \t machines, we can compute this from which bits of the inner\n \t object might be nonzero.  */\n       inner_mode = GET_MODE (SUBREG_REG (x));\n-      if (GET_MODE_PRECISION (inner_mode) <= BITS_PER_WORD\n-\t  && GET_MODE_PRECISION (inner_mode) <= HOST_BITS_PER_WIDE_INT)\n+      if (GET_MODE_PRECISION (inner_mode).is_constant (&inner_width)\n+\t  && inner_width <= BITS_PER_WORD\n+\t  && inner_width <= HOST_BITS_PER_WIDE_INT)\n \t{\n \t  nonzero &= cached_nonzero_bits (SUBREG_REG (x), mode,\n \t\t\t\t\t  known_x, known_mode, known_ret);\n@@ -4752,8 +4754,9 @@ nonzero_bits1 (const_rtx x, scalar_int_mode mode, const_rtx known_x,\n \t\t   ? val_signbit_known_set_p (inner_mode, nonzero)\n \t\t   : extend_op != ZERO_EXTEND)\n \t       || (!MEM_P (SUBREG_REG (x)) && !REG_P (SUBREG_REG (x))))\n-\t      && xmode_width > GET_MODE_PRECISION (inner_mode))\n-\t    nonzero |= (GET_MODE_MASK (xmode) & ~GET_MODE_MASK (inner_mode));\n+\t      && xmode_width > inner_width)\n+\t    nonzero\n+\t      |= (GET_MODE_MASK (GET_MODE (x)) & ~GET_MODE_MASK (inner_mode));\n \t}\n       break;\n \n@@ -6078,8 +6081,9 @@ lsb_bitfield_op_p (rtx x)\n       machine_mode mode = GET_MODE (XEXP (x, 0));\n       HOST_WIDE_INT len = INTVAL (XEXP (x, 1));\n       HOST_WIDE_INT pos = INTVAL (XEXP (x, 2));\n+      poly_int64 remaining_bits = GET_MODE_PRECISION (mode) - len;\n \n-      return (pos == (BITS_BIG_ENDIAN ? GET_MODE_PRECISION (mode) - len : 0));\n+      return known_eq (pos, BITS_BIG_ENDIAN ? remaining_bits : 0);\n     }\n   return false;\n }"}, {"sha": "316dcfda0fa4c3305ecaa4ed4166516df5b8e966", "filename": "gcc/tree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb94ec7613a4fd30c278b236eb8783d985a1b6ee/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb94ec7613a4fd30c278b236eb8783d985a1b6ee/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=bb94ec7613a4fd30c278b236eb8783d985a1b6ee", "patch": "@@ -5805,7 +5805,7 @@ extern const builtin_structptr_type builtin_structptr_types[6];\n inline bool\n type_has_mode_precision_p (const_tree t)\n {\n-  return TYPE_PRECISION (t) == GET_MODE_PRECISION (TYPE_MODE (t));\n+  return known_eq (TYPE_PRECISION (t), GET_MODE_PRECISION (TYPE_MODE (t)));\n }\n \n #endif  /* GCC_TREE_H  */"}, {"sha": "722f5702612887d56a477b43248fc049835d14b1", "filename": "gcc/ubsan.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb94ec7613a4fd30c278b236eb8783d985a1b6ee/gcc%2Fubsan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb94ec7613a4fd30c278b236eb8783d985a1b6ee/gcc%2Fubsan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fubsan.c?ref=bb94ec7613a4fd30c278b236eb8783d985a1b6ee", "patch": "@@ -1579,7 +1579,8 @@ instrument_si_overflow (gimple_stmt_iterator gsi)\n      Also punt on bit-fields.  */\n   if (!INTEGRAL_TYPE_P (lhsinner)\n       || TYPE_OVERFLOW_WRAPS (lhsinner)\n-      || GET_MODE_BITSIZE (TYPE_MODE (lhsinner)) != TYPE_PRECISION (lhsinner))\n+      || maybe_ne (GET_MODE_BITSIZE (TYPE_MODE (lhsinner)),\n+\t\t   TYPE_PRECISION (lhsinner)))\n     return;\n \n   switch (code)"}]}