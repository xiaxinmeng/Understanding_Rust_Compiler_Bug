{"sha": "effbcc6a9eef8c52570e8fe076a89594225657ae", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWZmYmNjNmE5ZWVmOGM1MjU3MGU4ZmUwNzZhODk1OTQyMjU2NTdhZQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1997-04-20T16:19:20Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1997-04-20T16:19:20Z"}, "message": "({move,clear}_by_pieces_1, expand_assignment): Ensure we have unshared rtx before changing flags.\n\n({move,clear}_by_pieces_1, expand_assignment): Ensure we have unshared rtx\nbefore changing flags.\n(store_{constructor,field}): Likewise.\n(expand_expr, case COMPONENT_REF): Likewise.\n(store_expr): Check if TEMP and TARGET are same with rtx_equal_p.\n\nFrom-SVN: r13936", "tree": {"sha": "5d5c6ee7eee792c9b96f16c971f33e64faee365e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5d5c6ee7eee792c9b96f16c971f33e64faee365e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/effbcc6a9eef8c52570e8fe076a89594225657ae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/effbcc6a9eef8c52570e8fe076a89594225657ae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/effbcc6a9eef8c52570e8fe076a89594225657ae", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/effbcc6a9eef8c52570e8fe076a89594225657ae/comments", "author": null, "committer": null, "parents": [{"sha": "64cd4fdb75eb951d68fa343842e5000c7afe684c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/64cd4fdb75eb951d68fa343842e5000c7afe684c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/64cd4fdb75eb951d68fa343842e5000c7afe684c"}], "stats": {"total": 37, "additions": 22, "deletions": 15}, "files": [{"sha": "505ea7cab205d57cf892e62444360f4efec58133", "filename": "gcc/expr.c", "status": "modified", "additions": 22, "deletions": 15, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/effbcc6a9eef8c52570e8fe076a89594225657ae/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/effbcc6a9eef8c52570e8fe076a89594225657ae/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=effbcc6a9eef8c52570e8fe076a89594225657ae", "patch": "@@ -1526,14 +1526,17 @@ move_by_pieces_1 (genfun, mode, data)\n \n       to1 = (data->autinc_to\n \t     ? gen_rtx (MEM, mode, data->to_addr)\n-\t     : change_address (data->to, mode,\n-\t\t\t       plus_constant (data->to_addr, data->offset)));\n+\t     : copy_rtx (change_address (data->to, mode,\n+\t\t\t\t\t plus_constant (data->to_addr,\n+\t\t\t\t\t\t\tdata->offset))));\n       MEM_IN_STRUCT_P (to1) = data->to_struct;\n+\n       from1 =\n \t(data->autinc_from\n \t ? gen_rtx (MEM, mode, data->from_addr)\n-\t : change_address (data->from, mode,\n-\t\t\t   plus_constant (data->from_addr, data->offset)));\n+\t : copy_rtx (change_address (data->from, mode,\n+\t\t\t\t     plus_constant (data->from_addr,\n+\t\t\t\t\t\t    data->offset))));\n       MEM_IN_STRUCT_P (from1) = data->from_struct;\n \n #ifdef HAVE_PRE_DECREMENT\n@@ -2036,8 +2039,9 @@ clear_by_pieces_1 (genfun, mode, data)\n \n       to1 = (data->autinc_to\n \t     ? gen_rtx (MEM, mode, data->to_addr)\n-\t     : change_address (data->to, mode,\n-\t\t\t       plus_constant (data->to_addr, data->offset)));\n+\t     : copy_rtx (change_address (data->to, mode,\n+\t\t\t\t\t plus_constant (data->to_addr,\n+\t\t\t\t\t\t\tdata->offset))));\n       MEM_IN_STRUCT_P (to1) = data->to_struct;\n \n #ifdef HAVE_PRE_DECREMENT\n@@ -2827,7 +2831,8 @@ expand_assignment (to, from, want_value, suggest_reg)\n \t\t structure we are storing into, and hence may be shared.\n \t\t We must make a new MEM before setting the volatile bit.  */\n \t      if (offset == 0)\n-\t\tto_rtx = change_address (to_rtx, VOIDmode, XEXP (to_rtx, 0));\n+\t\tto_rtx = copy_rtx (to_rtx);\n+\n \t      MEM_VOLATILE_P (to_rtx) = 1;\n \t    }\n #if 0  /* This was turned off because, when a field is volatile\n@@ -3194,7 +3199,7 @@ store_expr (exp, target, want_value)\n       if (!(target && GET_CODE (target) == REG\n \t    && REGNO (target) < FIRST_PSEUDO_REGISTER)\n \t  && !(GET_CODE (target) == MEM && MEM_VOLATILE_P (target))\n-\t  && temp != target\n+\t  && ! rtx_equal_p (temp, target)\n \t  && (CONSTANT_P (temp) || want_value))\n \tdont_return_target = 1;\n     }\n@@ -3212,7 +3217,7 @@ store_expr (exp, target, want_value)\n   /* If value was not generated in the target, store it there.\n      Convert the value to TARGET's type first if nec.  */\n \n-  if (temp != target && TREE_CODE (exp) != ERROR_MARK)\n+  if (! rtx_equal_p (temp, target) && TREE_CODE (exp) != ERROR_MARK)\n     {\n       target = protect_from_queue (target, 1);\n       if (GET_MODE (temp) != GET_MODE (target)\n@@ -3582,8 +3587,8 @@ store_constructor (exp, target, cleared)\n \t  if (TREE_READONLY (field))\n \t    {\n \t      if (GET_CODE (to_rtx) == MEM)\n-\t\tto_rtx = change_address (to_rtx, GET_MODE (to_rtx),\n-\t\t\t\t\t XEXP (to_rtx, 0));\n+\t\tto_rtx = copy_rtx (to_rtx);\n+\n \t      RTX_UNCHANGING_P (to_rtx) = 1;\n \t    }\n \n@@ -4146,8 +4151,10 @@ store_field (target, bitsize, bitpos, mode, exp, value_mode,\n \n       /* Now build a reference to just the desired component.  */\n \n-      to_rtx = change_address (target, mode,\n-\t\t\t       plus_constant (addr, (bitpos / BITS_PER_UNIT)));\n+      to_rtx = copy_rtx (change_address (target, mode,\n+\t\t\t\t\t plus_constant (addr,\n+\t\t\t\t\t\t\t(bitpos\n+\t\t\t\t\t\t\t / BITS_PER_UNIT))));\n       MEM_IN_STRUCT_P (to_rtx) = 1;\n \n       return store_expr (exp, to_rtx, value_mode != VOIDmode);\n@@ -5278,8 +5285,8 @@ expand_expr (exp, target, tmode, modifier)\n \t  if (TREE_READONLY (exp))\n \t    {\n \t      if (GET_CODE (target) == MEM)\n-\t\ttarget = change_address (target, GET_MODE (target),\n-\t\t\t\t\t XEXP (target, 0));\n+\t\ttarget = copy_rtx (target);\n+\n \t      RTX_UNCHANGING_P (target) = 1;\n \t    }\n "}]}