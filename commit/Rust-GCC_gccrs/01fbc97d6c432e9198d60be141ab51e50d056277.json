{"sha": "01fbc97d6c432e9198d60be141ab51e50d056277", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDFmYmM5N2Q2YzQzMmU5MTk4ZDYwYmUxNDFhYjUxZTUwZDA1NjI3Nw==", "commit": {"author": {"name": "Stephane Carrez", "email": "Stephane.Carrez@worldnet.fr", "date": "2000-07-17T10:16:18Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2000-07-17T10:16:18Z"}, "message": "flow.c (libcall_dead_p): Use single_set to verify the insn has only one set and get for analysis.\n\n\t* flow.c (libcall_dead_p): Use single_set to verify the insn\n\thas only one set and get for analysis.\n\t(propagate_one_insn): Don't pass the PATTERN of the insn.\n\nFrom-SVN: r35091", "tree": {"sha": "4278129a94b054f344c4d42adf6c7eb2d64dd16e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4278129a94b054f344c4d42adf6c7eb2d64dd16e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/01fbc97d6c432e9198d60be141ab51e50d056277", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/01fbc97d6c432e9198d60be141ab51e50d056277", "html_url": "https://github.com/Rust-GCC/gccrs/commit/01fbc97d6c432e9198d60be141ab51e50d056277", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/01fbc97d6c432e9198d60be141ab51e50d056277/comments", "author": null, "committer": null, "parents": [{"sha": "bf4ddb3165e53bdf21c00d46f2cb5dc3309dc49b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bf4ddb3165e53bdf21c00d46f2cb5dc3309dc49b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bf4ddb3165e53bdf21c00d46f2cb5dc3309dc49b"}], "stats": {"total": 31, "additions": 18, "deletions": 13}, "files": [{"sha": "e460c9e92b68e9e7f3fc272c2918a8d682aa1f22", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01fbc97d6c432e9198d60be141ab51e50d056277/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01fbc97d6c432e9198d60be141ab51e50d056277/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=01fbc97d6c432e9198d60be141ab51e50d056277", "patch": "@@ -1,3 +1,9 @@\n+2000-07-17  Stephane Carrez  <Stephane.Carrez@worldnet.fr>\n+\n+\t* flow.c (libcall_dead_p): Use single_set to verify the insn\n+\thas only one set and get for analysis.\n+\t(propagate_one_insn): Don't pass the PATTERN of the insn.\n+\n 2000-07-17  Mark Klein <mklein@dis.com>\n \n          * pa.c (emit_hpdiv_const): Update to match new pattern for udivsi3."}, {"sha": "2dc2b173089eb1b48144a8ade75da797e4c16d3a", "filename": "gcc/flow.c", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01fbc97d6c432e9198d60be141ab51e50d056277/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01fbc97d6c432e9198d60be141ab51e50d056277/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=01fbc97d6c432e9198d60be141ab51e50d056277", "patch": "@@ -354,7 +354,7 @@ static rtx propagate_block_delete_libcall PARAMS ((basic_block, rtx, rtx));\n static int insn_dead_p\t\t\tPARAMS ((struct propagate_block_info *,\n \t\t\t\t\t\t rtx, int, rtx));\n static int libcall_dead_p\t\tPARAMS ((struct propagate_block_info *,\n-\t\t\t\t\t\t rtx, rtx, rtx));\n+\t\t\t\t\t\t rtx, rtx));\n static void mark_set_regs\t\tPARAMS ((struct propagate_block_info *,\n \t\t\t\t\t\t rtx, rtx));\n static void mark_set_1\t\t\tPARAMS ((struct propagate_block_info *,\n@@ -3417,8 +3417,7 @@ propagate_one_insn (pbi, insn)\n       insn_is_dead = insn_dead_p (pbi, PATTERN (insn), 0,\n \t\t\t\t  REG_NOTES (insn));\n       libcall_is_dead = (insn_is_dead && note != 0\n-\t\t\t && libcall_dead_p (pbi, PATTERN (insn),\n-\t\t\t\t\t    note, insn));\n+\t\t\t && libcall_dead_p (pbi, note, insn));\n     }\n \n   /* We almost certainly don't want to delete prologue or epilogue\n@@ -4000,30 +3999,30 @@ insn_dead_p (pbi, x, call_ok, notes)\n   return 0;\n }\n \n-/* If X is the pattern of the last insn in a libcall, and assuming X is dead,\n+/* If INSN is the last insn in a libcall, and assuming INSN is dead,\n    return 1 if the entire library call is dead.\n-   This is true if X copies a register (hard or pseudo)\n-   and if the hard return  reg of the call insn is dead.\n-   (The caller should have tested the destination of X already for death.)\n+   This is true if INSN copies a register (hard or pseudo)\n+   and if the hard return reg of the call insn is dead.\n+   (The caller should have tested the destination of the SET inside\n+   INSN already for death.)\n \n    If this insn doesn't just copy a register, then we don't\n    have an ordinary libcall.  In that case, cse could not have\n    managed to substitute the source for the dest later on,\n    so we can assume the libcall is dead.\n \n-   NEEDED is the bit vector of pseudoregs live before this insn.\n-   NOTE is the REG_RETVAL note of the insn.  INSN is the insn itself.  */\n+   PBI is the block info giving pseudoregs live before this insn.\n+   NOTE is the REG_RETVAL note of the insn.  */\n \n static int\n-libcall_dead_p (pbi, x, note, insn)\n+libcall_dead_p (pbi, note, insn)\n      struct propagate_block_info *pbi;\n-     rtx x;\n      rtx note;\n      rtx insn;\n {\n-  register RTX_CODE code = GET_CODE (x);\n+  rtx x = single_set (insn);\n \n-  if (code == SET)\n+  if (x)\n     {\n       register rtx r = SET_SRC (x);\n       if (GET_CODE (r) == REG)"}]}