{"sha": "5d5396d52277be5e2c82249f889a78d909f29084", "node_id": "C_kwDOANBUbNoAKDVkNTM5NmQ1MjI3N2JlNWUyYzgyMjQ5Zjg4OWE3OGQ5MDlmMjkwODQ", "commit": {"author": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2022-02-24T16:02:50Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2022-02-24T16:02:50Z"}, "message": "Refactor operator overloading code into cc file", "tree": {"sha": "7bd41cb281f4b437185efbc1b82822864f9ed30e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7bd41cb281f4b437185efbc1b82822864f9ed30e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5d5396d52277be5e2c82249f889a78d909f29084", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d5396d52277be5e2c82249f889a78d909f29084", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5d5396d52277be5e2c82249f889a78d909f29084", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d5396d52277be5e2c82249f889a78d909f29084/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3b3079eba5f9faa5fe6623314a367b44070f9c19", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3b3079eba5f9faa5fe6623314a367b44070f9c19", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3b3079eba5f9faa5fe6623314a367b44070f9c19"}], "stats": {"total": 372, "additions": 187, "deletions": 185}, "files": [{"sha": "2703d91755c4673b3d68de28a13e6bdd1d91deba", "filename": "gcc/rust/typecheck/rust-hir-type-check-expr.cc", "status": "modified", "additions": 186, "deletions": 0, "changes": 186, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d5396d52277be5e2c82249f889a78d909f29084/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d5396d52277be5e2c82249f889a78d909f29084/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.cc?ref=5d5396d52277be5e2c82249f889a78d909f29084", "patch": "@@ -286,5 +286,191 @@ TypeCheckExpr::visit (HIR::ArrayIndexExpr &expr)\n   infered = array_type->get_element_type ()->clone ();\n }\n \n+bool\n+TypeCheckExpr::resolve_operator_overload (\n+  Analysis::RustLangItem::ItemType lang_item_type, HIR::OperatorExpr &expr,\n+  TyTy::BaseType *lhs, TyTy::BaseType *rhs)\n+{\n+  // look up lang item for arithmetic type\n+  std::string associated_item_name\n+    = Analysis::RustLangItem::ToString (lang_item_type);\n+  DefId respective_lang_item_id = UNKNOWN_DEFID;\n+  bool lang_item_defined\n+    = mappings->lookup_lang_item (lang_item_type, &respective_lang_item_id);\n+\n+  // probe for the lang-item\n+  if (!lang_item_defined)\n+    return false;\n+\n+  auto segment = HIR::PathIdentSegment (associated_item_name);\n+  auto candidate\n+    = MethodResolver::Probe (lhs, HIR::PathIdentSegment (associated_item_name));\n+\n+  bool have_implementation_for_lang_item = !candidate.is_error ();\n+  if (!have_implementation_for_lang_item)\n+    return false;\n+\n+  // Get the adjusted self\n+  Adjuster adj (lhs);\n+  TyTy::BaseType *adjusted_self = adj.adjust_type (candidate.adjustments);\n+\n+  // is this the case we are recursive\n+  // handle the case where we are within the impl block for this lang_item\n+  // otherwise we end up with a recursive operator overload such as the i32\n+  // operator overload trait\n+  TypeCheckContextItem &fn_context = context->peek_context ();\n+  if (fn_context.get_type () == TypeCheckContextItem::ItemType::IMPL_ITEM)\n+    {\n+      auto &impl_item = fn_context.get_impl_item ();\n+      HIR::ImplBlock *parent = impl_item.first;\n+      HIR::Function *fn = impl_item.second;\n+\n+      if (parent->has_trait_ref ()\n+\t  && fn->get_function_name ().compare (associated_item_name) == 0)\n+\t{\n+\t  TraitReference *trait_reference\n+\t    = TraitResolver::Lookup (*parent->get_trait_ref ().get ());\n+\t  if (!trait_reference->is_error ())\n+\t    {\n+\t      TyTy::BaseType *lookup = nullptr;\n+\t      bool ok = context->lookup_type (fn->get_mappings ().get_hirid (),\n+\t\t\t\t\t      &lookup);\n+\t      rust_assert (ok);\n+\t      rust_assert (lookup->get_kind () == TyTy::TypeKind::FNDEF);\n+\n+\t      TyTy::FnType *fntype = static_cast<TyTy::FnType *> (lookup);\n+\t      rust_assert (fntype->is_method ());\n+\n+\t      bool is_lang_item_impl\n+\t\t= trait_reference->get_mappings ().get_defid ()\n+\t\t  == respective_lang_item_id;\n+\t      bool self_is_lang_item_self\n+\t\t= fntype->get_self_type ()->is_equal (*adjusted_self);\n+\t      bool recursive_operator_overload\n+\t\t= is_lang_item_impl && self_is_lang_item_self;\n+\n+\t      if (recursive_operator_overload)\n+\t\treturn false;\n+\t    }\n+\t}\n+    }\n+\n+  // store the adjustments for code-generation to know what to do\n+  context->insert_autoderef_mappings (expr.get_mappings ().get_hirid (),\n+\t\t\t\t      std::move (candidate.adjustments));\n+\n+  // now its just like a method-call-expr\n+  context->insert_receiver (expr.get_mappings ().get_hirid (), lhs);\n+\n+  PathProbeCandidate &resolved_candidate = candidate.candidate;\n+  TyTy::BaseType *lookup_tyty = candidate.candidate.ty;\n+  NodeId resolved_node_id\n+    = resolved_candidate.is_impl_candidate ()\n+\t? resolved_candidate.item.impl.impl_item->get_impl_mappings ()\n+\t    .get_nodeid ()\n+\t: resolved_candidate.item.trait.item_ref->get_mappings ().get_nodeid ();\n+\n+  rust_assert (lookup_tyty->get_kind () == TyTy::TypeKind::FNDEF);\n+  TyTy::BaseType *lookup = lookup_tyty;\n+  TyTy::FnType *fn = static_cast<TyTy::FnType *> (lookup);\n+  rust_assert (fn->is_method ());\n+\n+  auto root = lhs->get_root ();\n+  bool receiver_is_type_param = root->get_kind () == TyTy::TypeKind::PARAM;\n+  if (root->get_kind () == TyTy::TypeKind::ADT)\n+    {\n+      const TyTy::ADTType *adt = static_cast<const TyTy::ADTType *> (root);\n+      if (adt->has_substitutions () && fn->needs_substitution ())\n+\t{\n+\t  // consider the case where we have:\n+\t  //\n+\t  // struct Foo<X,Y>(X,Y);\n+\t  //\n+\t  // impl<T> Foo<T, i32> {\n+\t  //   fn test<X>(self, a:X) -> (T,X) { (self.0, a) }\n+\t  // }\n+\t  //\n+\t  // In this case we end up with an fn type of:\n+\t  //\n+\t  // fn <T,X> test(self:Foo<T,i32>, a:X) -> (T,X)\n+\t  //\n+\t  // This means the instance or self we are calling this method for\n+\t  // will be substituted such that we can get the inherited type\n+\t  // arguments but then need to use the turbo fish if available or\n+\t  // infer the remaining arguments. Luckily rust does not allow for\n+\t  // default types GenericParams on impl blocks since these must\n+\t  // always be at the end of the list\n+\n+\t  auto s = fn->get_self_type ()->get_root ();\n+\t  rust_assert (s->can_eq (adt, false));\n+\t  rust_assert (s->get_kind () == TyTy::TypeKind::ADT);\n+\t  const TyTy::ADTType *self_adt\n+\t    = static_cast<const TyTy::ADTType *> (s);\n+\n+\t  // we need to grab the Self substitutions as the inherit type\n+\t  // parameters for this\n+\t  if (self_adt->needs_substitution ())\n+\t    {\n+\t      rust_assert (adt->was_substituted ());\n+\n+\t      TyTy::SubstitutionArgumentMappings used_args_in_prev_segment\n+\t\t= GetUsedSubstArgs::From (adt);\n+\n+\t      TyTy::SubstitutionArgumentMappings inherit_type_args\n+\t\t= self_adt->solve_mappings_from_receiver_for_self (\n+\t\t  used_args_in_prev_segment);\n+\n+\t      // there may or may not be inherited type arguments\n+\t      if (!inherit_type_args.is_error ())\n+\t\t{\n+\t\t  // need to apply the inherited type arguments to the\n+\t\t  // function\n+\t\t  lookup = fn->handle_substitions (inherit_type_args);\n+\t\t}\n+\t    }\n+\t}\n+    }\n+\n+  // handle generics\n+  if (!receiver_is_type_param)\n+    {\n+      if (lookup->needs_generic_substitutions ())\n+\t{\n+\t  lookup = SubstMapper::InferSubst (lookup, expr.get_locus ());\n+\t}\n+    }\n+\n+  // type check the arguments if required\n+  TyTy::FnType *type = static_cast<TyTy::FnType *> (lookup);\n+  rust_assert (type->num_params () > 0);\n+  auto fnparam = type->param_at (0);\n+  fnparam.second->unify (adjusted_self); // typecheck the self\n+  if (rhs == nullptr)\n+    {\n+      rust_assert (type->num_params () == 1);\n+    }\n+  else\n+    {\n+      rust_assert (type->num_params () == 2);\n+      auto fnparam = type->param_at (1);\n+      fnparam.second->unify (rhs); // typecheck the rhs\n+    }\n+\n+  // get the return type\n+  TyTy::BaseType *function_ret_tyty = type->get_return_type ()->clone ();\n+\n+  // store the expected fntype\n+  context->insert_operator_overload (expr.get_mappings ().get_hirid (), type);\n+\n+  // set up the resolved name on the path\n+  resolver->insert_resolved_name (expr.get_mappings ().get_nodeid (),\n+\t\t\t\t  resolved_node_id);\n+\n+  // return the result of the function back\n+  infered = function_ret_tyty;\n+\n+  return true;\n+}\n+\n } // namespace Resolver\n } // namespace Rust"}, {"sha": "e22252864710b7cef3e5686d01caa28c934e50bb", "filename": "gcc/rust/typecheck/rust-hir-type-check-expr.h", "status": "modified", "additions": 1, "deletions": 185, "changes": 186, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d5396d52277be5e2c82249f889a78d909f29084/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d5396d52277be5e2c82249f889a78d909f29084/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h?ref=5d5396d52277be5e2c82249f889a78d909f29084", "patch": "@@ -1240,191 +1240,7 @@ class TypeCheckExpr : public TypeCheckBase\n   bool\n   resolve_operator_overload (Analysis::RustLangItem::ItemType lang_item_type,\n \t\t\t     HIR::OperatorExpr &expr, TyTy::BaseType *lhs,\n-\t\t\t     TyTy::BaseType *rhs)\n-  {\n-    // look up lang item for arithmetic type\n-    std::string associated_item_name\n-      = Analysis::RustLangItem::ToString (lang_item_type);\n-    DefId respective_lang_item_id = UNKNOWN_DEFID;\n-    bool lang_item_defined\n-      = mappings->lookup_lang_item (lang_item_type, &respective_lang_item_id);\n-\n-    // probe for the lang-item\n-    if (!lang_item_defined)\n-      return false;\n-\n-    auto segment = HIR::PathIdentSegment (associated_item_name);\n-    auto candidate\n-      = MethodResolver::Probe (lhs,\n-\t\t\t       HIR::PathIdentSegment (associated_item_name));\n-\n-    bool have_implementation_for_lang_item = !candidate.is_error ();\n-    if (!have_implementation_for_lang_item)\n-      return false;\n-\n-    // Get the adjusted self\n-    Adjuster adj (lhs);\n-    TyTy::BaseType *adjusted_self = adj.adjust_type (candidate.adjustments);\n-\n-    // is this the case we are recursive\n-    // handle the case where we are within the impl block for this lang_item\n-    // otherwise we end up with a recursive operator overload such as the i32\n-    // operator overload trait\n-    TypeCheckContextItem &fn_context = context->peek_context ();\n-    if (fn_context.get_type () == TypeCheckContextItem::ItemType::IMPL_ITEM)\n-      {\n-\tauto &impl_item = fn_context.get_impl_item ();\n-\tHIR::ImplBlock *parent = impl_item.first;\n-\tHIR::Function *fn = impl_item.second;\n-\n-\tif (parent->has_trait_ref ()\n-\t    && fn->get_function_name ().compare (associated_item_name) == 0)\n-\t  {\n-\t    TraitReference *trait_reference\n-\t      = TraitResolver::Lookup (*parent->get_trait_ref ().get ());\n-\t    if (!trait_reference->is_error ())\n-\t      {\n-\t\tTyTy::BaseType *lookup = nullptr;\n-\t\tbool ok\n-\t\t  = context->lookup_type (fn->get_mappings ().get_hirid (),\n-\t\t\t\t\t  &lookup);\n-\t\trust_assert (ok);\n-\t\trust_assert (lookup->get_kind () == TyTy::TypeKind::FNDEF);\n-\n-\t\tTyTy::FnType *fntype = static_cast<TyTy::FnType *> (lookup);\n-\t\trust_assert (fntype->is_method ());\n-\n-\t\tbool is_lang_item_impl\n-\t\t  = trait_reference->get_mappings ().get_defid ()\n-\t\t    == respective_lang_item_id;\n-\t\tbool self_is_lang_item_self\n-\t\t  = fntype->get_self_type ()->is_equal (*adjusted_self);\n-\t\tbool recursive_operator_overload\n-\t\t  = is_lang_item_impl && self_is_lang_item_self;\n-\n-\t\tif (recursive_operator_overload)\n-\t\t  return false;\n-\t      }\n-\t  }\n-      }\n-\n-    // store the adjustments for code-generation to know what to do\n-    context->insert_autoderef_mappings (expr.get_mappings ().get_hirid (),\n-\t\t\t\t\tstd::move (candidate.adjustments));\n-\n-    // now its just like a method-call-expr\n-    context->insert_receiver (expr.get_mappings ().get_hirid (), lhs);\n-\n-    PathProbeCandidate &resolved_candidate = candidate.candidate;\n-    TyTy::BaseType *lookup_tyty = candidate.candidate.ty;\n-    NodeId resolved_node_id\n-      = resolved_candidate.is_impl_candidate ()\n-\t  ? resolved_candidate.item.impl.impl_item->get_impl_mappings ()\n-\t      .get_nodeid ()\n-\t  : resolved_candidate.item.trait.item_ref->get_mappings ()\n-\t      .get_nodeid ();\n-\n-    rust_assert (lookup_tyty->get_kind () == TyTy::TypeKind::FNDEF);\n-    TyTy::BaseType *lookup = lookup_tyty;\n-    TyTy::FnType *fn = static_cast<TyTy::FnType *> (lookup);\n-    rust_assert (fn->is_method ());\n-\n-    auto root = lhs->get_root ();\n-    bool receiver_is_type_param = root->get_kind () == TyTy::TypeKind::PARAM;\n-    if (root->get_kind () == TyTy::TypeKind::ADT)\n-      {\n-\tconst TyTy::ADTType *adt = static_cast<const TyTy::ADTType *> (root);\n-\tif (adt->has_substitutions () && fn->needs_substitution ())\n-\t  {\n-\t    // consider the case where we have:\n-\t    //\n-\t    // struct Foo<X,Y>(X,Y);\n-\t    //\n-\t    // impl<T> Foo<T, i32> {\n-\t    //   fn test<X>(self, a:X) -> (T,X) { (self.0, a) }\n-\t    // }\n-\t    //\n-\t    // In this case we end up with an fn type of:\n-\t    //\n-\t    // fn <T,X> test(self:Foo<T,i32>, a:X) -> (T,X)\n-\t    //\n-\t    // This means the instance or self we are calling this method for\n-\t    // will be substituted such that we can get the inherited type\n-\t    // arguments but then need to use the turbo fish if available or\n-\t    // infer the remaining arguments. Luckily rust does not allow for\n-\t    // default types GenericParams on impl blocks since these must\n-\t    // always be at the end of the list\n-\n-\t    auto s = fn->get_self_type ()->get_root ();\n-\t    rust_assert (s->can_eq (adt, false));\n-\t    rust_assert (s->get_kind () == TyTy::TypeKind::ADT);\n-\t    const TyTy::ADTType *self_adt\n-\t      = static_cast<const TyTy::ADTType *> (s);\n-\n-\t    // we need to grab the Self substitutions as the inherit type\n-\t    // parameters for this\n-\t    if (self_adt->needs_substitution ())\n-\t      {\n-\t\trust_assert (adt->was_substituted ());\n-\n-\t\tTyTy::SubstitutionArgumentMappings used_args_in_prev_segment\n-\t\t  = GetUsedSubstArgs::From (adt);\n-\n-\t\tTyTy::SubstitutionArgumentMappings inherit_type_args\n-\t\t  = self_adt->solve_mappings_from_receiver_for_self (\n-\t\t    used_args_in_prev_segment);\n-\n-\t\t// there may or may not be inherited type arguments\n-\t\tif (!inherit_type_args.is_error ())\n-\t\t  {\n-\t\t    // need to apply the inherited type arguments to the\n-\t\t    // function\n-\t\t    lookup = fn->handle_substitions (inherit_type_args);\n-\t\t  }\n-\t      }\n-\t  }\n-      }\n-\n-    // handle generics\n-    if (!receiver_is_type_param)\n-      {\n-\tif (lookup->needs_generic_substitutions ())\n-\t  {\n-\t    lookup = SubstMapper::InferSubst (lookup, expr.get_locus ());\n-\t  }\n-      }\n-\n-    // type check the arguments if required\n-    TyTy::FnType *type = static_cast<TyTy::FnType *> (lookup);\n-    rust_assert (type->num_params () > 0);\n-    auto fnparam = type->param_at (0);\n-    fnparam.second->unify (adjusted_self); // typecheck the self\n-    if (rhs == nullptr)\n-      {\n-\trust_assert (type->num_params () == 1);\n-      }\n-    else\n-      {\n-\trust_assert (type->num_params () == 2);\n-\tauto fnparam = type->param_at (1);\n-\tfnparam.second->unify (rhs); // typecheck the rhs\n-      }\n-\n-    // get the return type\n-    TyTy::BaseType *function_ret_tyty = type->get_return_type ()->clone ();\n-\n-    // store the expected fntype\n-    context->insert_operator_overload (expr.get_mappings ().get_hirid (), type);\n-\n-    // set up the resolved name on the path\n-    resolver->insert_resolved_name (expr.get_mappings ().get_nodeid (),\n-\t\t\t\t    resolved_node_id);\n-\n-    // return the result of the function back\n-    infered = function_ret_tyty;\n-\n-    return true;\n-  }\n+\t\t\t     TyTy::BaseType *rhs);\n \n private:\n   TypeCheckExpr (bool inside_loop)"}]}