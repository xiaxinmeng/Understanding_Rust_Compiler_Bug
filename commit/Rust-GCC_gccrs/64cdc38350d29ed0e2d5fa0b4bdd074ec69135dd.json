{"sha": "64cdc38350d29ed0e2d5fa0b4bdd074ec69135dd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjRjZGMzODM1MGQyOWVkMGUyZDVmYTBiNGJkZDA3NGVjNjkxMzVkZA==", "commit": {"author": {"name": "Matthew Hiller", "email": "hiller@gcc.gnu.org", "date": "2002-04-24T22:18:25Z"}, "committer": {"name": "Matthew Hiller", "email": "hiller@gcc.gnu.org", "date": "2002-04-24T22:18:25Z"}, "message": "cpplex.c: Remove conditional #undef of MULTIBYTE_CHARS.\n\n2002-04-24  Matt Hiller  <hiller@redhat.com>\n\n\t* cpplex.c: Remove conditional #undef of MULTIBYTE_CHARS.\n\t* c-lex.c: Ditto.\n\n\t* cpplex.c (skip_line_comment): Process comment one multibyte\n\tcharacter at a time rather than one char at a time, if\n\tappropriate.\n\t(parse_string): Process string one multibyte character at a time\n\trather than one char at a time, if appropriate.\n\t* c-lex.c (lex_string): Lex and copy multibyte strings\n\tappropriately.\n\t* cpplib.h (cppchar_t): Change to unsigned.\n\nFrom-SVN: r52737", "tree": {"sha": "c295949959dc8ecb1998758d055af141fb272257", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c295949959dc8ecb1998758d055af141fb272257"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/64cdc38350d29ed0e2d5fa0b4bdd074ec69135dd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/64cdc38350d29ed0e2d5fa0b4bdd074ec69135dd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/64cdc38350d29ed0e2d5fa0b4bdd074ec69135dd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/64cdc38350d29ed0e2d5fa0b4bdd074ec69135dd/comments", "author": null, "committer": null, "parents": [{"sha": "67f0a6bf0132909f392c07fa5eab27b3e8c6e483", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/67f0a6bf0132909f392c07fa5eab27b3e8c6e483", "html_url": "https://github.com/Rust-GCC/gccrs/commit/67f0a6bf0132909f392c07fa5eab27b3e8c6e483"}], "stats": {"total": 98, "additions": 76, "deletions": 22}, "files": [{"sha": "f2f8c8c7317daf626a8bfbe2b418fa64833969e2", "filename": "gcc/c-lex.c", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64cdc38350d29ed0e2d5fa0b4bdd074ec69135dd/gcc%2Fc-lex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64cdc38350d29ed0e2d5fa0b4bdd074ec69135dd/gcc%2Fc-lex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-lex.c?ref=64cdc38350d29ed0e2d5fa0b4bdd074ec69135dd", "patch": "@@ -40,13 +40,6 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"splay-tree.h\"\n #include \"debug.h\"\n \n-/* MULTIBYTE_CHARS support only works for native compilers.\n-   ??? Ideally what we want is to model widechar support after\n-   the current floating point support.  */\n-#ifdef CROSS_COMPILE\n-#undef MULTIBYTE_CHARS\n-#endif\n-\n #ifdef MULTIBYTE_CHARS\n #include \"mbchar.h\"\n #include <locale.h>\n@@ -1282,8 +1275,8 @@ lex_string (str, len, wide)\n \t  c = cpp_parse_escape (parse_in, &p, limit, mask);\n \t}\n \t\n-      /* Add this single character into the buffer either as a wchar_t\n-\t or as a single byte.  */\n+      /* Add this single character into the buffer either as a wchar_t,\n+\t a multibyte sequence, or as a single byte.  */\n       if (wide)\n \t{\n \t  unsigned charwidth = TYPE_PRECISION (char_type_node);\n@@ -1304,6 +1297,16 @@ lex_string (str, len, wide)\n \t    }\n \t  q += WCHAR_BYTES;\n \t}\n+#ifdef MULTIBYTE_CHARS\n+      else if (char_len > 1)\n+\t{\n+\t  /* We're dealing with a multibyte character. */\n+\t  for ( ; char_len >0; --char_len)\n+\t    {\n+\t      *q++ = *(p - char_len);\n+\t    }\n+\t}\n+#endif\n       else\n \t{\n \t  *q++ = c;"}, {"sha": "6a44b86d15f944b115c903ff4a49516daece6c75", "filename": "gcc/cpplex.c", "status": "modified", "additions": 61, "deletions": 10, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64cdc38350d29ed0e2d5fa0b4bdd074ec69135dd/gcc%2Fcpplex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64cdc38350d29ed0e2d5fa0b4bdd074ec69135dd/gcc%2Fcpplex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplex.c?ref=64cdc38350d29ed0e2d5fa0b4bdd074ec69135dd", "patch": "@@ -25,13 +25,6 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n #include \"cpplib.h\"\n #include \"cpphash.h\"\n \n-/* MULTIBYTE_CHARS support only works for native compilers.\n-   ??? Ideally what we want is to model widechar support after\n-   the current floating point support.  */\n-#ifdef CROSS_COMPILE\n-#undef MULTIBYTE_CHARS\n-#endif\n-\n #ifdef MULTIBYTE_CHARS\n #include \"mbchar.h\"\n #include <locale.h>\n@@ -312,14 +305,39 @@ skip_line_comment (pfile)\n   cpp_buffer *buffer = pfile->buffer;\n   unsigned int orig_line = pfile->line;\n   cppchar_t c;\n+#ifdef MULTIBYTE_CHARS\n+  wchar_t wc;\n+  int char_len;\n+#endif\n \n   pfile->state.lexing_comment = 1;\n+#ifdef MULTIBYTE_CHARS\n+  /* Reset multibyte conversion state.  */\n+  (void) local_mbtowc (NULL, NULL, 0);\n+#endif\n   do\n     {\n       if (buffer->cur == buffer->rlimit)\n \tgoto at_eof;\n \n+#ifdef MULTIBYTE_CHARS\n+      char_len = local_mbtowc (&wc, (const char *) buffer->cur,\n+\t\t\t       buffer->rlimit - buffer->cur);\n+      if (char_len == -1)\n+\t{\n+\t  cpp_error (pfile, DL_WARNING,\n+\t\t     \"ignoring invalid multibyte character\");\n+\t  char_len = 1;\n+\t  c = *buffer->cur++;\n+\t}\n+      else\n+\t{\n+\t  buffer->cur += char_len;\n+\t  c = wc;\n+\t}\n+#else\n       c = *buffer->cur++;\n+#endif\n       if (c == '?' || c == '\\\\')\n \tc = skip_escaped_newlines (pfile);\n     }\n@@ -617,10 +635,18 @@ parse_string (pfile, token, terminator)\n   unsigned char *dest, *limit;\n   cppchar_t c;\n   bool warned_nulls = false;\n+#ifdef MULTIBYTE_CHARS\n+  wchar_t wc;\n+  int char_len;\n+#endif\n \n   dest = BUFF_FRONT (pfile->u_buff);\n   limit = BUFF_LIMIT (pfile->u_buff);\n \n+#ifdef MULTIBYTE_CHARS\n+  /* Reset multibyte conversion state.  */\n+  (void) local_mbtowc (NULL, NULL, 0);\n+#endif\n   for (;;)\n     {\n       /* We need room for another char, possibly the terminating NUL.  */\n@@ -632,8 +658,26 @@ parse_string (pfile, token, terminator)\n \t  limit = BUFF_LIMIT (pfile->u_buff);\n \t}\n \n-      /* Handle trigraphs, escaped newlines etc.  */\n+#ifdef MULTIBYTE_CHARS\n+      char_len = local_mbtowc (&wc, (const char *) buffer->cur,\n+\t\t\t       buffer->rlimit - buffer->cur);\n+      if (char_len == -1)\n+\t{\n+\t  cpp_error (pfile, DL_WARNING,\n+\t\t       \"ignoring invalid multibyte character\");\n+\t  char_len = 1;\n+\t  c = *buffer->cur++;\n+\t}\n+      else\n+\t{\n+\t  buffer->cur += char_len;\n+\t  c = wc;\n+\t}\n+#else\n       c = *buffer->cur++;\n+#endif\n+\n+      /* Handle trigraphs, escaped newlines etc.  */\n       if (c == '?' || c == '\\\\')\n \tc = skip_escaped_newlines (pfile);\n \n@@ -666,8 +710,15 @@ parse_string (pfile, token, terminator)\n \t\t\t \"null character(s) preserved in literal\");\n \t    }\n \t}\n-\n-      *dest++ = c;\n+#ifdef MULTIBYTE_CHARS\n+      if (char_len > 1)\n+\t{\n+\t  for ( ; char_len > 0; --char_len)\n+\t    *dest++ = (*buffer->cur - char_len);\n+\t}\n+      else\n+#endif\n+\t*dest++ = c;\n     }\n \n   *dest = '\\0';"}, {"sha": "765d65a3869485788bb36e452aa052e6f6892f18", "filename": "gcc/cpplib.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64cdc38350d29ed0e2d5fa0b4bdd074ec69135dd/gcc%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64cdc38350d29ed0e2d5fa0b4bdd074ec69135dd/gcc%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.h?ref=64cdc38350d29ed0e2d5fa0b4bdd074ec69135dd", "patch": "@@ -187,9 +187,9 @@ struct cpp_token\n   } val;\n };\n \n-/* A standalone character.  We may want to make it unsigned for the\n-   same reason we use unsigned char - to avoid signedness issues.  */\n-typedef int cppchar_t;\n+/* A standalone character.  It is unsigned for the same reason we use\n+   unsigned char - to avoid signedness issues.  */\n+typedef unsigned int cppchar_t;\n \n /* Values for opts.dump_macros.\n   dump_only means inhibit output of the preprocessed text"}]}