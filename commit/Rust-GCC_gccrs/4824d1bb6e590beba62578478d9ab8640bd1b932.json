{"sha": "4824d1bb6e590beba62578478d9ab8640bd1b932", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDgyNGQxYmI2ZTU5MGJlYmE2MjU3ODQ3OGQ5YWI4NjQwYmQxYjkzMg==", "commit": {"author": {"name": "Bryce McKinlay", "email": "bryce@albatross.co.nz", "date": "2000-04-19T10:10:39Z"}, "committer": {"name": "Bryce McKinlay", "email": "bryce@gcc.gnu.org", "date": "2000-04-19T10:10:39Z"}, "message": "boehm.cc: (_Jv_MarkObj...\n\n2000-04-19  Bryce McKinlay  <bryce@albatross.co.nz>\n\n\t* boehm.cc: (_Jv_MarkObj, _Jv_MarkArray): Cast pointers for\n\tMAYBE_MARK to ptr_t, for compatibility with new GC version.\n\nFrom-SVN: r33252", "tree": {"sha": "6207e12415c07148e02e7bd5a4d4bdbb62b4c21a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6207e12415c07148e02e7bd5a4d4bdbb62b4c21a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4824d1bb6e590beba62578478d9ab8640bd1b932", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4824d1bb6e590beba62578478d9ab8640bd1b932", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4824d1bb6e590beba62578478d9ab8640bd1b932", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4824d1bb6e590beba62578478d9ab8640bd1b932/comments", "author": null, "committer": null, "parents": [{"sha": "93002327db5e5f466de60dc3f8c876cf9a56e183", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/93002327db5e5f466de60dc3f8c876cf9a56e183", "html_url": "https://github.com/Rust-GCC/gccrs/commit/93002327db5e5f466de60dc3f8c876cf9a56e183"}], "stats": {"total": 117, "additions": 61, "deletions": 56}, "files": [{"sha": "a4dfbd26dba49e2291347cf27ef75e25a1a9c054", "filename": "libjava/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4824d1bb6e590beba62578478d9ab8640bd1b932/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4824d1bb6e590beba62578478d9ab8640bd1b932/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=4824d1bb6e590beba62578478d9ab8640bd1b932", "patch": "@@ -1,3 +1,8 @@\n+2000-04-19  Bryce McKinlay  <bryce@albatross.co.nz>\n+\n+\t* boehm.cc: (_Jv_MarkObj, _Jv_MarkArray): Cast pointers for\n+\tMAYBE_MARK to ptr_t, for compatibility with new GC version.\n+\n 2000-04-16  Bryce McKinlay  <bryce@albatross.co.nz>\n \n \t* java/io/natFileDescriptorPosix.cc (open): Use mode 0666. Fix for PR"}, {"sha": "6450df75d580a92e13f570243fb988fe22370f1f", "filename": "libjava/boehm.cc", "status": "modified", "additions": 56, "deletions": 56, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4824d1bb6e590beba62578478d9ab8640bd1b932/libjava%2Fboehm.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4824d1bb6e590beba62578478d9ab8640bd1b932/libjava%2Fboehm.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fboehm.cc?ref=4824d1bb6e590beba62578478d9ab8640bd1b932", "patch": "@@ -92,11 +92,11 @@ _Jv_MarkObj (void *addr, void *msp, void *msl, void * /*env*/)\n   jclass klass = dt->clas;\n \n   // Every object has a sync_info pointer.\n-  word w = (word) obj->sync_info;\n-  MAYBE_MARK (w, mark_stack_ptr, mark_stack_limit, obj, o1label);\n+  ptr_t p = (ptr_t) obj->sync_info;\n+  MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, obj, o1label);\n   // Mark the object's class.\n-  w = (word) klass;\n-  MAYBE_MARK (w, mark_stack_ptr, mark_stack_limit, obj, o2label);\n+  p = (ptr_t) klass;\n+  MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, obj, o2label);\n \n   if (klass == &ClassClass)\n     {\n@@ -106,36 +106,36 @@ _Jv_MarkObj (void *addr, void *msp, void *msl, void * /*env*/)\n       // The next field should probably not be marked, since this is\n       // only used in the class hash table.  Marking this field\n       // basically prohibits class unloading. --Kresten\n-      w = (word) c->next;\n-      MAYBE_MARK (w, mark_stack_ptr, mark_stack_limit, c, c2label);\n+      p = (ptr_t) c->next;\n+      MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, c, c2label);\n #endif\n \n-      w = (word) c->name;\n-      MAYBE_MARK (w, mark_stack_ptr, mark_stack_limit, c, c3label);\n-      w = (word) c->superclass;\n-      MAYBE_MARK (w, mark_stack_ptr, mark_stack_limit, c, c4label);\n+      p = (ptr_t) c->name;\n+      MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, c, c3label);\n+      p = (ptr_t) c->superclass;\n+      MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, c, c4label);\n       for (int i = 0; i < c->constants.size; ++i)\n \t{\n \t  /* FIXME: We could make this more precise by using the tags -KKT */\n-\t  w = (word) c->constants.data[i].p;\n-\t  MAYBE_MARK (w, mark_stack_ptr, mark_stack_limit, c, c5label);\n+\t  p = (ptr_t) c->constants.data[i].p;\n+\t  MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, c, c5label);\n \t}\n \n #ifdef INTERPRETER\n       if (_Jv_IsInterpretedClass (c))\n \t{\n-\t  w = (word) c->constants.tags;\n-\t  MAYBE_MARK (w, mark_stack_ptr, mark_stack_limit, c, c5alabel);\n-\t  w = (word) c->constants.data;\n-\t  MAYBE_MARK (w, mark_stack_ptr, mark_stack_limit, c, c5blabel);\n+\t  p = (ptr_t) c->constants.tags;\n+\t  MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, c, c5alabel);\n+\t  p = (ptr_t) c->constants.data;\n+\t  MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, c, c5blabel);\n \t}\n #endif\n \n       // If the class is an array, then the methods field holds a\n       // pointer to the element class.  If the class is primitive,\n       // then the methods field holds a pointer to the array class.\n-      w = (word) c->methods;\n-      MAYBE_MARK (w, mark_stack_ptr, mark_stack_limit, c, c6label);\n+      p = (ptr_t) c->methods;\n+      MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, c, c6label);\n \n \n       if (! c->isArray() && ! c->isPrimitive())\n@@ -144,11 +144,11 @@ _Jv_MarkObj (void *addr, void *msp, void *msl, void * /*env*/)\n \t  // points to a methods structure.\n \t  for (int i = 0; i < c->method_count; ++i)\n \t    {\n-\t      w = (word) c->methods[i].name;\n-\t      MAYBE_MARK (w, mark_stack_ptr, mark_stack_limit, c,\n+\t      p = (ptr_t) c->methods[i].name;\n+\t      MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, c,\n \t\t\t     cm1label);\n-\t      w = (word) c->methods[i].signature;\n-\t      MAYBE_MARK (w, mark_stack_ptr, mark_stack_limit, c,\n+\t      p = (ptr_t) c->methods[i].signature;\n+\t      MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, c,\n \t\t\t     cm2label);\n \n \t      // FIXME: `ncode' entry?\n@@ -158,34 +158,34 @@ _Jv_MarkObj (void *addr, void *msp, void *msl, void * /*env*/)\n \t      // trampoline here, so we'll mark it. \n \t      if (_Jv_IsInterpretedClass (c))\n \t\t  {\n-\t\t      w = (word) c->methods[i].ncode;\n-\t\t      MAYBE_MARK (w, mark_stack_ptr, mark_stack_limit, c,\n+\t\t      p = (ptr_t) c->methods[i].ncode;\n+\t\t      MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, c,\n \t\t\t\t  cm3label);\n \t\t  }\n #endif\n \t    }\n \t}\n \n       // Mark all the fields.\n-      w = (word) c->fields;\n-      MAYBE_MARK (w, mark_stack_ptr, mark_stack_limit, c, c8label);\n+      p = (ptr_t) c->fields;\n+      MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, c, c8label);\n       for (int i = 0; i < c->field_count; ++i)\n \t{\n \t  _Jv_Field* field = &c->fields[i];\n \n #ifndef COMPACT_FIELDS\n-\t  w = (word) field->name;\n-\t  MAYBE_MARK (w, mark_stack_ptr, mark_stack_limit, c, c8alabel);\n+\t  p = (ptr_t) field->name;\n+\t  MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, c, c8alabel);\n #endif\n-\t  w = (word) field->type;\n-\t  MAYBE_MARK (w, mark_stack_ptr, mark_stack_limit, c, c8blabel);\n+\t  p = (ptr_t) field->type;\n+\t  MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, c, c8blabel);\n \n \t  // For the interpreter, we also need to mark the memory\n \t  // containing static members\n \t  if (field->flags & 0x0008)\n \t    {\n-\t      w = (word) field->u.addr;\n-\t      MAYBE_MARK (w, mark_stack_ptr, mark_stack_limit, c, c8clabel);\n+\t      p = (ptr_t) field->u.addr;\n+\t      MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, c, c8clabel);\n \n \t      // also, if the static member is a reference,\n \t      // mark also the value pointed to.  We check for isResolved\n@@ -194,42 +194,42 @@ _Jv_MarkObj (void *addr, void *msp, void *msl, void * /*env*/)\n \t      if (JvFieldIsRef (field) && field->isResolved()) \n \t\t{\n \t\t  jobject val = *(jobject*) field->u.addr;\n-\t\t  w = (word) val;\n-\t\t  MAYBE_MARK (w, mark_stack_ptr, mark_stack_limit,\n+\t\t  p = (ptr_t) val;\n+\t\t  MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit,\n \t\t\t      c, c8elabel);\n \t\t}\n \t    }\n \t}\n \n-      w = (word) c->vtable;\n-      MAYBE_MARK (w, mark_stack_ptr, mark_stack_limit, c, c9label);\n-      w = (word) c->interfaces;\n-      MAYBE_MARK (w, mark_stack_ptr, mark_stack_limit, c, cAlabel);\n+      p = (ptr_t) c->vtable;\n+      MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, c, c9label);\n+      p = (ptr_t) c->interfaces;\n+      MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, c, cAlabel);\n       for (int i = 0; i < c->interface_count; ++i)\n \t{\n-\t  w = (word) c->interfaces[i];\n-\t  MAYBE_MARK (w, mark_stack_ptr, mark_stack_limit, c, cClabel);\n+\t  p = (ptr_t) c->interfaces[i];\n+\t  MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, c, cClabel);\n \t}\n-      w = (word) c->loader;\n-      MAYBE_MARK (w, mark_stack_ptr, mark_stack_limit, c, cBlabel);\n+      p = (ptr_t) c->loader;\n+      MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, c, cBlabel);\n \n #ifdef INTERPRETER\n       if (_Jv_IsInterpretedClass (c))\n \t{\n \t  _Jv_InterpClass* ic = (_Jv_InterpClass*)c;\n \n-\t  w = (word) ic->interpreted_methods;\n-\t  MAYBE_MARK (w, mark_stack_ptr, mark_stack_limit, ic, cElabel);\n+\t  p = (ptr_t) ic->interpreted_methods;\n+\t  MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, ic, cElabel);\n \n \t  for (int i = 0; i < c->method_count; i++)\n \t    {\n-\t      w = (word) ic->interpreted_methods[i];\n-\t      MAYBE_MARK (w, mark_stack_ptr, mark_stack_limit, ic, \\\n+\t      p = (ptr_t) ic->interpreted_methods[i];\n+\t      MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, ic, \\\n \t\t\t  cFlabel);\n \t    }\n \n-\t  w = (word) ic->field_initializers;\n-\t  MAYBE_MARK (w, mark_stack_ptr, mark_stack_limit, ic, cGlabel);\n+\t  p = (ptr_t) ic->field_initializers;\n+\t  MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, ic, cGlabel);\n \t  \n \t}\n #endif\n@@ -255,8 +255,8 @@ _Jv_MarkObj (void *addr, void *msp, void *msl, void * /*env*/)\n \t      if (JvFieldIsRef (field))\n \t\t{\n \t\t  jobject val = JvGetObjectField (obj, field);\n-\t\t  w = (word) val;\n-\t\t  MAYBE_MARK (w, mark_stack_ptr, mark_stack_limit,\n+\t\t  p = (ptr_t) val;\n+\t\t  MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit,\n \t\t\t      obj, elabel);\n \t\t}\n \t      field = field->getNextField ();\n@@ -286,17 +286,17 @@ _Jv_MarkArray (void *addr, void *msp, void *msl, void * /*env*/)\n   jclass klass = dt->clas;\n \n   // Every object has a sync_info pointer.\n-  word w = (word) array->sync_info;\n-  MAYBE_MARK (w, mark_stack_ptr, mark_stack_limit, array, e1label);\n+  ptr_t p = (ptr_t) array->sync_info;\n+  MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, array, e1label);\n   // Mark the object's class.\n-  w = (word) klass;\n-  MAYBE_MARK (w, mark_stack_ptr, mark_stack_limit, obj, o2label);\n+  p = (ptr_t) klass;\n+  MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, obj, o2label);\n \n   for (int i = 0; i < JvGetArrayLength (array); ++i)\n     {\n       jobject obj = elements (array)[i];\n-      w = (word) obj;\n-      MAYBE_MARK (w, mark_stack_ptr, mark_stack_limit, array, e2label);\n+      p = (ptr_t) obj;\n+      MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, array, e2label);\n     }\n \n   return mark_stack_ptr;"}]}