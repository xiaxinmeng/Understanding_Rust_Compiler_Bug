{"sha": "8f2a734fc8d6d5ae168a2279462dcdc573f5ea71", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGYyYTczNGZjOGQ2ZDVhZTE2OGEyMjc5NDYyZGNkYzU3M2Y1ZWE3MQ==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2004-07-23T08:53:36Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2004-07-23T08:53:36Z"}, "message": "cp:\t* search.c (lookup_conversion_operator): Avoid two loops.\n\n\t(add_conversions): Remove.\n\t(check_hidden_convs, split_conversions,\n\tlookup_conversions_r):\tNew.\n\t(lookup_conversions): Use lookup_conversions_r.\ntestsuite:\n\t* g++.dg/lookup/conv-[1234].C: New.\n\nFrom-SVN: r85075", "tree": {"sha": "90ccc3e9f4403f27ebca7a0b2148a0a48e41d6b7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/90ccc3e9f4403f27ebca7a0b2148a0a48e41d6b7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8f2a734fc8d6d5ae168a2279462dcdc573f5ea71", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8f2a734fc8d6d5ae168a2279462dcdc573f5ea71", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8f2a734fc8d6d5ae168a2279462dcdc573f5ea71", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8f2a734fc8d6d5ae168a2279462dcdc573f5ea71/comments", "author": null, "committer": null, "parents": [{"sha": "c29cac0b6b728eee7083adec60479b09937d64be", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c29cac0b6b728eee7083adec60479b09937d64be", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c29cac0b6b728eee7083adec60479b09937d64be"}], "stats": {"total": 517, "additions": 434, "deletions": 83}, "files": [{"sha": "0d65baeaaded2d8b7373ba00165d6087f5bad0fd", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f2a734fc8d6d5ae168a2279462dcdc573f5ea71/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f2a734fc8d6d5ae168a2279462dcdc573f5ea71/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=8f2a734fc8d6d5ae168a2279462dcdc573f5ea71", "patch": "@@ -1,3 +1,11 @@\n+2004-07-23  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* search.c (lookup_conversion_operator): Avoid two loops.\n+\t(add_conversions): Remove.\n+\t(check_hidden_convs, split_conversions,\n+\tlookup_conversions_r):\tNew.\n+\t(lookup_conversions): Use lookup_conversions_r.\n+\n 2004-07-22  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* pt.c (get_template_base): Check type is completable."}, {"sha": "7841d1e5cecb81213a7a13030e76375c28a5e641", "filename": "gcc/cp/search.c", "status": "modified", "additions": 317, "deletions": 83, "changes": 400, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f2a734fc8d6d5ae168a2279462dcdc573f5ea71/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f2a734fc8d6d5ae168a2279462dcdc573f5ea71/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=8f2a734fc8d6d5ae168a2279462dcdc573f5ea71", "patch": "@@ -51,7 +51,10 @@ static base_kind lookup_base_r (tree, tree, base_access, bool, tree *);\n static int dynamic_cast_base_recurse (tree, tree, bool, tree *);\n static tree dfs_debug_unmarkedp (tree, int, void *);\n static tree dfs_debug_mark (tree, void *);\n-static tree add_conversions (tree, void *);\n+static int check_hidden_convs (tree, int, int, tree, tree, tree);\n+static tree split_conversions (tree, tree, tree, tree);\n+static int lookup_conversions_r (tree, int, int,\n+\t\t\t\t tree, tree, tree, tree, tree *, tree *);\n static int look_for_overrides_r (tree, tree);\n static tree bfs_walk (tree, tree (*) (tree, void *),\n \t\t      tree (*) (tree, int, void *), void *);\n@@ -1298,47 +1301,35 @@ lookup_fnfields (tree xbasetype, tree name, int protect)\n static int\n lookup_conversion_operator (tree class_type, tree type)\n {\n-  int pass;\n-  int i;\n-  tree fn;\n-  VEC(tree) *methods;\n+  int tpl_slot = -1;\n \n-  methods = CLASSTYPE_METHOD_VEC (class_type);\n-\n-  for (pass = 0; pass < 2; ++pass)\n-    for (i = CLASSTYPE_FIRST_CONVERSION_SLOT; \n-\t VEC_iterate (tree, methods, i, fn); ++i)\n-      {\n-\t/* All the conversion operators come near the beginning of the\n-\t   class.  Therefore, if FN is not a conversion operator, there\n-\t   is no matching conversion operator in CLASS_TYPE.  */\n-\tfn = OVL_CURRENT (fn);\n-\tif (!DECL_CONV_FN_P (fn))\n-\t  break;\n-\t\n-\tif (pass == 0)\n-\t  {\n-\t    /* On the first pass we only consider exact matches.  If\n-\t       the types match, this slot is the one where the right\n-\t       conversion operators can be found.  */\n-\t    if (TREE_CODE (fn) != TEMPLATE_DECL\n-\t\t&& same_type_p (DECL_CONV_FN_TYPE (fn), type))\n-\t      return i;\n-\t  }\n-\telse\n-\t  {\n-\t    /* On the second pass we look for template conversion\n-\t       operators.  It may be possible to instantiate the\n-\t       template to get the type desired.  All of the template\n-\t       conversion operators share a slot.  By looking for\n-\t       templates second we ensure that specializations are\n-\t       preferred over templates.  */\n-\t    if (TREE_CODE (fn) == TEMPLATE_DECL)\n-\t      return i;\n-\t  }\n-      }\n+  if (TYPE_HAS_CONVERSION (class_type))\n+    {\n+      int i;\n+      tree fn;\n+      VEC(tree) *methods = CLASSTYPE_METHOD_VEC (class_type);\n+      \n+      for (i = CLASSTYPE_FIRST_CONVERSION_SLOT;\n+\t   VEC_iterate (tree, methods, i, fn); ++i)\n+\t{\n+\t  /* All the conversion operators come near the beginning of\n+\t     the class.  Therefore, if FN is not a conversion\n+\t     operator, there is no matching conversion operator in\n+\t     CLASS_TYPE.  */\n+\t  fn = OVL_CURRENT (fn);\n+\t  if (!DECL_CONV_FN_P (fn))\n+\t    break;\n+\t  \n+\t  if (TREE_CODE (fn) == TEMPLATE_DECL)\n+\t    /* All the templated conversion functions are on the same\n+\t       slot, so remember it.  */\n+\t    tpl_slot = i;\n+\t  else if (same_type_p (DECL_CONV_FN_TYPE (fn), type))\n+\t    return i;\n+\t}\n+    }\n \n-  return -1;\n+  return tpl_slot;\n }\n \n /* TYPE is a class type. Return the index of the fields within\n@@ -2043,78 +2034,321 @@ reinit_search_statistics (void)\n #endif /* GATHER_STATISTICS */\n }\n \n+/* Helper for lookup_conversions_r.  TO_TYPE is the type converted to\n+   by a conversion op in base BINFO.  VIRTUAL_DEPTH is non-zero if\n+   BINFO is morally virtual, and VIRTUALNESS is non-zero if virtual\n+   bases have been encountered already in the tree walk.  PARENT_CONVS\n+   is the list of lists of conversion functions that could hide CONV\n+   and OTHER_CONVS is the list of lists of conversion functions that\n+   could hide or be hidden by CONV, should virtualness be involved in\n+   the hierarchy.  Merely checking the conversion op's name is not\n+   enough because two conversion operators to the same type can have\n+   different names.  Return non-zero if we are visible.  */\n+\n+static int\n+check_hidden_convs (tree binfo, int virtual_depth, int virtualness,\n+\t\t    tree to_type, tree parent_convs, tree other_convs)\n+{\n+  tree level, probe;\n+\n+  /* See if we are hidden by a parent conversion.  */\n+  for (level = parent_convs; level; level = TREE_CHAIN (level))\n+    for (probe = TREE_VALUE (level); probe; probe = TREE_CHAIN (probe))\n+      if (same_type_p (to_type, TREE_TYPE (probe)))\n+\treturn 0;\n+\n+  if (virtual_depth || virtualness)\n+    {\n+     /* In a virtual hierarchy, we could be hidden, or could hide a\n+        conversion function on the other_convs list.  */\n+      for (level = other_convs; level; level = TREE_CHAIN (level))\n+\t{\n+\t  int we_hide_them;\n+\t  int they_hide_us;\n+\t  tree *prev, other;\n+\t  \n+\t  if (!(virtual_depth || TREE_STATIC (level)))\n+\t    /* Neither is morally virtual, so cannot hide each other. */\n+\t    continue;\n+\t  \n+\t  if (!TREE_VALUE (level))\n+\t    /* They evaporated away already.  */\n+\t    continue;\n+\n+\t  they_hide_us = (virtual_depth\n+\t\t\t  && original_binfo (binfo, TREE_PURPOSE (level)));\n+\t  we_hide_them = (!they_hide_us && TREE_STATIC (level)\n+\t\t\t  && original_binfo (TREE_PURPOSE (level), binfo));\n+\n+\t  if (!(we_hide_them || they_hide_us))\n+\t    /* Neither is within the other, so no hiding can occur.  */\n+\t    continue;\n+\t  \n+\t  for (prev = &TREE_VALUE (level), other = *prev; other;)\n+\t    {\n+\t      if (same_type_p (to_type, TREE_TYPE (other)))\n+\t\t{\n+\t\t  if (they_hide_us)\n+\t\t    /* We are hidden. */\n+\t\t    return 0;\n+\n+\t\t  if (we_hide_them)\n+\t\t    {\n+\t\t      /* We hide the other one.  */\n+\t\t      other = TREE_CHAIN (other);\n+\t\t      *prev = other;\n+\t\t      continue;\n+\t\t    }\n+\t\t}\n+\t      prev = &TREE_CHAIN (other);\n+\t      other = *prev;\n+\t    }\n+\t}\n+    }\n+  return 1;\n+}\n+\n+/* Helper for lookup_conversions_r.  PARENT_CONVS is a list of lists\n+   of conversion functions, the first slot will be for the current\n+   binfo, if MY_CONVS is non-NULL.  CHILD_CONVS is the list of lists\n+   of conversion functions from childen of the current binfo,\n+   concatenated with conversions from elsewhere in the heirarchy --\n+   that list begins with OTHER_CONVS.  Return a single list of lists\n+   containing only conversions from the current binfo and its\n+   children.  */\n+\n static tree\n-add_conversions (tree binfo, void *data)\n+split_conversions (tree my_convs, tree parent_convs,\n+\t\t   tree child_convs, tree other_convs)\n {\n-  size_t i;\n-  VEC(tree) *method_vec = CLASSTYPE_METHOD_VEC (BINFO_TYPE (binfo));\n-  tree *conversions = (tree *) data;\n-  tree tmp;\n+  tree t;\n+  tree prev;\n+  \n+  /* Remove the original other_convs portion from child_convs.  */\n+  for (prev = NULL, t = child_convs;\n+       t != other_convs; prev = t, t = TREE_CHAIN (t))\n+    continue;\n+  \n+  if (prev)\n+    TREE_CHAIN (prev) = NULL_TREE;\n+  else\n+    child_convs = NULL_TREE;\n \n-  /* Some builtin types have no method vector, not even an empty one.  */\n-  if (!method_vec)\n-    return NULL_TREE;\n+  /* Attach the child convs to any we had at this level.  */\n+  if (my_convs)\n+    {\n+      my_convs = parent_convs;\n+      TREE_CHAIN (my_convs) = child_convs;\n+    }\n+  else\n+    my_convs = child_convs;\n+  \n+  return my_convs;\n+}\n+\n+/* Worker for lookup_conversions.  Lookup conversion functions in\n+   BINFO and its children.  VIRTUAL_DEPTH is non-zero, if BINFO is in\n+   a morally virtual base, and VIRTUALNESS is non-zero, if we've\n+   encountered virtual bases already in the tree walk.  PARENT_CONVS &\n+   PARENT_TPL_CONVS are lists of list of conversions within parent\n+   binfos.  OTHER_CONVS and OTHER_TPL_CONVS are conversions found\n+   elsewhere in the tree.  Return the conversions found within this\n+   portion of the graph in CONVS and TPL_CONVS.  Return non-zero is we\n+   encountered virtualness.  We keep template and non-template\n+   conversions separate, to avoid unnecessary type comparisons.\n+\n+   The located conversion functions are held in lists of lists.  The\n+   TREE_VALUE of the outer list is the list of conversion functions\n+   found in a particular binfo.  The TREE_PURPOSE of both the outer\n+   and inner lists is the binfo at which those conversions were\n+   found.  TREE_STATIC is set for those lists within of morally\n+   virtual binfos.  The TREE_VALUE of the inner list is the conversion\n+   function or overload itself.  The TREE_TYPE of each inner list node\n+   is the converted-to type.  */\n+\n+static int\n+lookup_conversions_r (tree binfo,\n+\t\t      int virtual_depth, int virtualness,\n+\t\t      tree parent_convs, tree parent_tpl_convs,\n+\t\t      tree other_convs, tree other_tpl_convs,\n+\t\t      tree *convs, tree *tpl_convs)\n+{\n+  int my_virtualness = 0;\n+  tree my_convs = NULL_TREE;\n+  tree my_tpl_convs = NULL_TREE;\n+  tree child_convs = NULL_TREE;\n+  tree child_tpl_convs = NULL_TREE;\n+  unsigned i;\n+  tree base_binfo;\n+  VEC(tree) *method_vec = CLASSTYPE_METHOD_VEC (BINFO_TYPE (binfo));\n+  tree conv;\n \n+  /* If we have no conversion operators, then don't look.  */\n+  if (!TYPE_HAS_CONVERSION (BINFO_TYPE (binfo)))\n+    {\n+      *convs = *tpl_convs = NULL_TREE;\n+      \n+      return 0;\n+    }\n+  \n+  if (BINFO_VIRTUAL_P (binfo))\n+    virtual_depth++;\n+  \n+  /* First, locate the unhidden ones at this level.  */\n   for (i = CLASSTYPE_FIRST_CONVERSION_SLOT; \n-       VEC_iterate (tree, method_vec, i, tmp);\n+       VEC_iterate (tree, method_vec, i, conv);\n        ++i)\n     {\n-      tree name;\n+      tree cur = OVL_CURRENT (conv);\n \n-      if (!DECL_CONV_FN_P (OVL_CURRENT (tmp)))\n+      if (!DECL_CONV_FN_P (cur))\n \tbreak;\n \n-      name = DECL_NAME (OVL_CURRENT (tmp));\n-\n-      /* Make sure we don't already have this conversion.  */\n-      if (! IDENTIFIER_MARKED (name))\n+      if (TREE_CODE (cur) == TEMPLATE_DECL)\n \t{\n-\t  tree t;\n+\t  /* Only template conversions can be overloaded, and we must\n+\t     flatten them out and check each one individually.  */\n+\t  tree tpls;\n \n-\t  /* Make sure that we do not already have a conversion\n-\t     operator for this type.  Merely checking the NAME is not\n-\t     enough because two conversion operators to the same type\n-\t     may not have the same NAME.  */\n-\t  for (t = *conversions; t; t = TREE_CHAIN (t))\n+\t  for (tpls = conv; tpls; tpls = OVL_NEXT (tpls))\n \t    {\n-\t      tree fn;\n-\t      for (fn = TREE_VALUE (t); fn; fn = OVL_NEXT (fn))\n-\t\tif (same_type_p (TREE_TYPE (name),\n-\t\t\t\t DECL_CONV_FN_TYPE (OVL_CURRENT (fn))))\n-\t\t  break;\n-\t      if (fn)\n-\t\tbreak;\n+\t      tree tpl = OVL_CURRENT (tpls);\n+\t      tree type = DECL_CONV_FN_TYPE (tpl);\n+\t      \n+\t      if (check_hidden_convs (binfo, virtual_depth, virtualness,\n+\t\t\t\t      type, parent_tpl_convs, other_tpl_convs))\n+\t\t{\n+\t\t  my_tpl_convs = tree_cons (binfo, tpl, my_tpl_convs);\n+\t\t  TREE_TYPE (my_tpl_convs) = type;\n+\t\t  if (virtual_depth)\n+\t\t    {\n+\t\t      TREE_STATIC (my_tpl_convs) = 1;\n+\t\t      my_virtualness = 1;\n+\t\t    }\n+\t\t}\n \t    }\n-\t  if (!t)\n+\t}\n+      else\n+\t{\n+\t  tree name = DECL_NAME (cur);\n+\n+\t  if (!IDENTIFIER_MARKED (name))\n \t    {\n-\t      *conversions = tree_cons (binfo, tmp, *conversions);\n-\t      IDENTIFIER_MARKED (name) = 1;\n+\t      tree type = DECL_CONV_FN_TYPE (cur);\n+\t      \n+\t      if (check_hidden_convs (binfo, virtual_depth, virtualness,\n+\t\t\t\t      type, parent_convs, other_convs))\n+\t\t{\n+\t\t  my_convs = tree_cons (binfo, conv, my_convs);\n+\t\t  TREE_TYPE (my_convs) = type;\n+\t\t  if (virtual_depth)\n+\t\t    {\n+\t\t      TREE_STATIC (my_convs) = 1;\n+\t\t      my_virtualness = 1;\n+\t\t    }\n+\t\t  IDENTIFIER_MARKED (name) = 1;\n+\t\t}\n \t    }\n \t}\n     }\n-  return NULL_TREE;\n+\n+  if (my_convs)\n+    {\n+      parent_convs = tree_cons (binfo, my_convs, parent_convs);\n+      if (virtual_depth)\n+\tTREE_STATIC (parent_convs) = 1;\n+    }\n+  \n+  if (my_tpl_convs)\n+    {\n+      parent_tpl_convs = tree_cons (binfo, my_tpl_convs, parent_tpl_convs);\n+      if (virtual_depth)\n+\tTREE_STATIC (parent_convs) = 1;\n+    }\n+\n+  child_convs = other_convs;\n+  child_tpl_convs = other_tpl_convs;\n+  \n+  /* Now iterate over each base, looking for more conversions.  */\n+  for (i = 0; BINFO_BASE_ITERATE (binfo, i, base_binfo); i++)\n+    {\n+      tree base_convs, base_tpl_convs;\n+      unsigned base_virtualness;\n+\n+      base_virtualness = lookup_conversions_r (base_binfo,\n+\t\t\t\t\t       virtual_depth, virtualness,\n+\t\t\t\t\t       parent_convs, parent_tpl_convs,\n+\t\t\t\t\t       child_convs, child_tpl_convs,\n+\t\t\t\t\t       &base_convs, &base_tpl_convs);\n+      if (base_virtualness)\n+\tmy_virtualness = virtualness = 1;\n+      child_convs = chainon (base_convs, child_convs);\n+      child_tpl_convs = chainon (base_tpl_convs, child_tpl_convs);\n+    }\n+\n+  /* Unmark the conversions found at this level  */\n+  for (conv = my_convs; conv; conv = TREE_CHAIN (conv))\n+    IDENTIFIER_MARKED (DECL_NAME (OVL_CURRENT (TREE_VALUE (conv)))) = 0;\n+\n+  *convs = split_conversions (my_convs, parent_convs,\n+\t\t\t      child_convs, other_convs);\n+  *tpl_convs = split_conversions (my_tpl_convs, parent_tpl_convs,\n+\t\t\t\t  child_tpl_convs, other_tpl_convs);\n+  \n+  return my_virtualness;\n }\n \n /* Return a TREE_LIST containing all the non-hidden user-defined\n    conversion functions for TYPE (and its base-classes).  The\n-   TREE_VALUE of each node is a FUNCTION_DECL or an OVERLOAD\n-   containing the conversion functions.  The TREE_PURPOSE is the BINFO\n-   from which the conversion functions in this node were selected.  */\n+   TREE_VALUE of each node is the FUNCTION_DECL of the conversion\n+   function.  The TREE_PURPOSE is the BINFO from which the conversion\n+   functions in this node were selected.  This function is effectively\n+   performing a set of member lookups as lookup_fnfield does, but\n+   using the type being converted to as the unique key, rather than the\n+   field name.  */\n \n tree\n lookup_conversions (tree type)\n {\n-  tree t;\n-  tree conversions = NULL_TREE;\n-\n+  tree convs, tpl_convs;\n+  tree list = NULL_TREE;\n+  \n   complete_type (type);\n-  if (TYPE_BINFO (type))\n-    bfs_walk (TYPE_BINFO (type), add_conversions, 0, &conversions);\n+  if (!TYPE_BINFO (type))\n+    return NULL_TREE;\n+  \n+  lookup_conversions_r (TYPE_BINFO (type), 0, 0,\n+\t\t\tNULL_TREE, NULL_TREE, NULL_TREE, NULL_TREE,\n+\t\t\t&convs, &tpl_convs);\n+  \n+  /* Flatten the list-of-lists */\n+  for (; convs; convs = TREE_CHAIN (convs))\n+    {\n+      tree probe, next;\n+\n+      for (probe = TREE_VALUE (convs); probe; probe = next)\n+\t{\n+\t  next = TREE_CHAIN (probe);\n+\n+\t  TREE_CHAIN (probe) = list;\n+\t  list = probe;\n+\t}\n+    }\n+  \n+  for (; tpl_convs; tpl_convs = TREE_CHAIN (tpl_convs))\n+    {\n+      tree probe, next;\n \n-  for (t = conversions; t; t = TREE_CHAIN (t))\n-    IDENTIFIER_MARKED (DECL_NAME (OVL_CURRENT (TREE_VALUE (t)))) = 0;\n+      for (probe = TREE_VALUE (tpl_convs); probe; probe = next)\n+\t{\n+\t  next = TREE_CHAIN (probe);\n \n-  return conversions;\n+\t  TREE_CHAIN (probe) = list;\n+\t  list = probe;\n+\t}\n+    }\n+  \n+  return list;\n }\n \n struct overlap_info "}, {"sha": "fbbfe3766090d858338f77ca15c3fd71107de6b9", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f2a734fc8d6d5ae168a2279462dcdc573f5ea71/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f2a734fc8d6d5ae168a2279462dcdc573f5ea71/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=8f2a734fc8d6d5ae168a2279462dcdc573f5ea71", "patch": "@@ -1,3 +1,7 @@\n+2004-07-23  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* g++.dg/lookup/conv-[1234].C: New.\n+\n 2004-07-22  Mark Mitchell  <mark@codesourcery.com>\n \n \t* g++.dg/parse/attr2.C: Simplify."}, {"sha": "6a595f71997549e529c15860e23cd8fe8c97fe9d", "filename": "gcc/testsuite/g++.dg/lookup/conv-1.C", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f2a734fc8d6d5ae168a2279462dcdc573f5ea71/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fconv-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f2a734fc8d6d5ae168a2279462dcdc573f5ea71/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fconv-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fconv-1.C?ref=8f2a734fc8d6d5ae168a2279462dcdc573f5ea71", "patch": "@@ -0,0 +1,26 @@\n+// { dg-do compile }\n+\n+// Copyright (C) 2004 Free Software Foundation, Inc.\n+// Contributed by Nathan Sidwell 21 Jul 2004 <nathan@codesourcery.com>\n+\n+// Failed to spot ambiguous conversion\n+\n+struct A1 \n+{\n+  operator int () const; // { dg-error \"A1::operator\" \"\" }\n+};\n+\n+struct A2\n+{\n+  operator int () const; // { dg-error \"A2::operator\" \"\" }\n+};\n+\n+struct B : A1, A2 \n+{\n+};\n+\n+int Foo (B const &b)\n+{\n+  return b; // { dg-error \"ambiguous\" \"\" }\n+}\n+"}, {"sha": "6a087e18394f049dce4c55baf79775665c591f87", "filename": "gcc/testsuite/g++.dg/lookup/conv-2.C", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f2a734fc8d6d5ae168a2279462dcdc573f5ea71/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fconv-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f2a734fc8d6d5ae168a2279462dcdc573f5ea71/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fconv-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fconv-2.C?ref=8f2a734fc8d6d5ae168a2279462dcdc573f5ea71", "patch": "@@ -0,0 +1,22 @@\n+// { dg-do compile }\n+\n+// Copyright (C) 2004 Free Software Foundation, Inc.\n+// Contributed by Nathan Sidwell 21 Jul 2004 <nathan@codesourcery.com>\n+\n+// { dg-final { scan-assembler \"_ZNK2A1cviEv\" } }\n+\n+struct A1 \n+{\n+  operator int () const; // this one\n+};\n+\n+struct A2 : A1\n+{\n+  template<typename T> operator T () const;\n+};\n+\n+int Foo (A2 const &b)\n+{\n+  return b;\n+}\n+"}, {"sha": "14b1446a2bd9a3c52259049fd8c35a1cd0430120", "filename": "gcc/testsuite/g++.dg/lookup/conv-3.C", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f2a734fc8d6d5ae168a2279462dcdc573f5ea71/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fconv-3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f2a734fc8d6d5ae168a2279462dcdc573f5ea71/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fconv-3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fconv-3.C?ref=8f2a734fc8d6d5ae168a2279462dcdc573f5ea71", "patch": "@@ -0,0 +1,22 @@\n+// { dg-do compile }\n+\n+// Copyright (C) 2004 Free Software Foundation, Inc.\n+// Contributed by Nathan Sidwell 21 Jul 2004 <nathan@codesourcery.com>\n+\n+// { dg-final { scan-assembler \"_ZNK2A1IiEcviEv\" } }\n+\n+template <typename T> struct A1 \n+{\n+  operator T () const;  // this one\n+};\n+\n+struct A2 : A1<int>\n+{\n+  template<typename T> operator T () const;\n+};\n+\n+int Foo (A2 const &b)\n+{\n+  return b;\n+}\n+"}, {"sha": "cd85b2ad336c85eafcaad0a451ee237114e814fe", "filename": "gcc/testsuite/g++.dg/lookup/conv-4.C", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f2a734fc8d6d5ae168a2279462dcdc573f5ea71/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fconv-4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f2a734fc8d6d5ae168a2279462dcdc573f5ea71/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fconv-4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fconv-4.C?ref=8f2a734fc8d6d5ae168a2279462dcdc573f5ea71", "patch": "@@ -0,0 +1,35 @@\n+// { dg-do compile }\n+\n+// Copyright (C) 2004 Free Software Foundation, Inc.\n+// Contributed by Nathan Sidwell 21 Jul 2004 <nathan@codesourcery.com>\n+\n+// { dg-final { scan-assembler \"_ZNK1AcviEv\" } }\n+// { dg-final { scan-assembler-not \"_ZNK1VcviEv\" } }\n+\n+struct V \n+{\n+  operator int () const;\n+};\n+\n+struct A : virtual V\n+{\n+  operator int () const; // this one\n+};\n+\n+struct B1 : A, virtual V\n+{\n+};\n+\n+struct B2 : virtual V, A\n+{\n+};\n+\n+\n+int Foo (B1 const &b)\n+{\n+  return b;\n+}\n+int Foo (B2 const &b)\n+{\n+  return b;\n+}"}]}