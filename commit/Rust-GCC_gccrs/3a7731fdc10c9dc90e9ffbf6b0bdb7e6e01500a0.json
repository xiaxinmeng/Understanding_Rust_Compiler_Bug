{"sha": "3a7731fdc10c9dc90e9ffbf6b0bdb7e6e01500a0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2E3NzMxZmRjMTBjOWRjOTBlOWZmYmY2YjBiZGI3ZTZlMDE1MDBhMA==", "commit": {"author": {"name": "Philip Blundell", "email": "philb@gnu.org", "date": "2002-02-19T18:08:10Z"}, "committer": {"name": "Phil Blundell", "email": "pb@gcc.gnu.org", "date": "2002-02-19T18:08:10Z"}, "message": "arm.c (use_return_insn): Don't reject interrupt functions.\n\n2002-02-19  Philip Blundell  <philb@gnu.org>\n\n\t* config/arm/arm.c (use_return_insn): Don't reject interrupt\n\tfunctions.\n\t(arm_compute_save_reg_mask): Save LR for interrupt functions too.\n\t(output_return_instruction): Allow interrupt functions to return with\n\tldmfd sp!, {... pc}^.  Use LDR to restore any single register.\n\t(arm_expand_prologue): Subtract 4 before stacking LR in an\n\tinterrupt function.\n\nFrom-SVN: r49872", "tree": {"sha": "34542f3e288b24b6a0ddc08064ddb3c4f319174d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/34542f3e288b24b6a0ddc08064ddb3c4f319174d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3a7731fdc10c9dc90e9ffbf6b0bdb7e6e01500a0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a7731fdc10c9dc90e9ffbf6b0bdb7e6e01500a0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3a7731fdc10c9dc90e9ffbf6b0bdb7e6e01500a0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a7731fdc10c9dc90e9ffbf6b0bdb7e6e01500a0/comments", "author": {"login": "philb", "id": 227468, "node_id": "MDQ6VXNlcjIyNzQ2OA==", "avatar_url": "https://avatars.githubusercontent.com/u/227468?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philb", "html_url": "https://github.com/philb", "followers_url": "https://api.github.com/users/philb/followers", "following_url": "https://api.github.com/users/philb/following{/other_user}", "gists_url": "https://api.github.com/users/philb/gists{/gist_id}", "starred_url": "https://api.github.com/users/philb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philb/subscriptions", "organizations_url": "https://api.github.com/users/philb/orgs", "repos_url": "https://api.github.com/users/philb/repos", "events_url": "https://api.github.com/users/philb/events{/privacy}", "received_events_url": "https://api.github.com/users/philb/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "14f583b8c3465efa654af1233e9c63365cd41cc9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/14f583b8c3465efa654af1233e9c63365cd41cc9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/14f583b8c3465efa654af1233e9c63365cd41cc9"}], "stats": {"total": 90, "additions": 56, "deletions": 34}, "files": [{"sha": "5a61e82f9db573c39e7ab311fe2f4d9dae529332", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a7731fdc10c9dc90e9ffbf6b0bdb7e6e01500a0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a7731fdc10c9dc90e9ffbf6b0bdb7e6e01500a0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3a7731fdc10c9dc90e9ffbf6b0bdb7e6e01500a0", "patch": "@@ -1,3 +1,13 @@\n+2002-02-19  Philip Blundell  <philb@gnu.org>\n+\n+\t* config/arm/arm.c (use_return_insn): Don't reject interrupt\n+\tfunctions.\n+\t(arm_compute_save_reg_mask): Save LR for interrupt functions too.\n+\t(output_return_instruction): Allow interrupt functions to return with\n+\tldmfd sp!, {... pc}^.  Use LDR to restore any single register.\n+\t(arm_expand_prologue): Subtract 4 before stacking LR in an\n+\tinterrupt function.\n+\n 2002-02-19  Philip Blundell  <pb@nexus.co.uk>\n \n \t* config/arm/arm.c (arm_encode_call_attribute): Operate on any"}, {"sha": "4a0e8519ef64215a05c918d1578d2ae6e9e58484", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 46, "deletions": 34, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a7731fdc10c9dc90e9ffbf6b0bdb7e6e01500a0/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a7731fdc10c9dc90e9ffbf6b0bdb7e6e01500a0/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=3a7731fdc10c9dc90e9ffbf6b0bdb7e6e01500a0", "patch": "@@ -899,9 +899,9 @@ use_return_insn (iscond)\n       \n   func_type = arm_current_func_type ();\n \n-  /* Naked functions, volatile functiond and interrupt\n-     functions all need special consideration.  */\n-  if (func_type & (ARM_FT_INTERRUPT | ARM_FT_VOLATILE | ARM_FT_NAKED))\n+  /* Naked functions and volatile functions need special\n+     consideration.  */\n+  if (func_type & (ARM_FT_VOLATILE | ARM_FT_NAKED))\n     return 0;\n   \n   /* As do variadic functions.  */\n@@ -7142,11 +7142,10 @@ arm_compute_save_reg_mask ()\n      now and then popping it back into the PC.  This incurs extra memory\n      accesses though, so we only do it when optimising for size, and only\n      if we know that we will not need a fancy return sequence.  */\n-  if (! IS_INTERRUPT (func_type)\n-      && (regs_ever_live [LR_REGNUM]\n+  if (regs_ever_live [LR_REGNUM]\n \t  || (save_reg_mask\n \t      && optimize_size\n-\t      && ARM_FUNC_TYPE (func_type) == ARM_FT_NORMAL)))\n+\t      && ARM_FUNC_TYPE (func_type) == ARM_FT_NORMAL))\n     save_reg_mask |= 1 << LR_REGNUM;\n \n   if (cfun->machine->lr_save_eliminated)\n@@ -7212,7 +7211,6 @@ output_return_instruction (operand, really_return, reverse)\n \t (eg interworking, or ISR) then we can load the return address \n \t directly into the PC.  Otherwise we must load it into LR.  */\n       if (really_return\n-\t  && ! IS_INTERRUPT (func_type)\n \t  && ! TARGET_INTERWORK)\n \treturn_reg = reg_names[PC_REGNUM];\n       else\n@@ -7229,14 +7227,23 @@ output_return_instruction (operand, really_return, reverse)\n \t    live_regs_mask |=   (1 << SP_REGNUM);\n \t  }\n \n-      /* On some ARM architectures it is faster to use LDR rather than LDM to\n-\t load a single register.  On other architectures, the cost is the same.\n-\t In 26 bit mode we have to use LDM in order to be able to restore the \n-\t CPSR.  */\n-      if ((live_regs_mask  == (1 << LR_REGNUM))\n-\t  && (! really_return || TARGET_APCS_32))\n+      /* On some ARM architectures it is faster to use LDR rather than\n+\t LDM to load a single register.  On other architectures, the\n+\t cost is the same.  In 26 bit mode, or for exception handlers,\n+\t we have to use LDM to load the PC so that the CPSR is also\n+\t restored.  */\n+      for (reg = 0; reg <= LAST_ARM_REGNUM; reg++)\n \t{\n-\t  sprintf (instr, \"ldr%s\\t%%|%s, [%%|sp], #4\", conditional, return_reg);\n+\t  if (live_regs_mask == (unsigned int)(1 << reg))\n+\t    break;\n+\t}\n+      if (reg <= LAST_ARM_REGNUM\n+\t  && (reg != LR_REGNUM\n+\t      || ! really_return \n+\t      || (TARGET_APCS_32 && ! IS_INTERRUPT (func_type))))\n+\t{\n+\t  sprintf (instr, \"ldr%s\\t%%|%s, [%%|sp], #4\", conditional, \n+\t\t   (reg == LR_REGNUM) ? return_reg : reg_names[reg]);\n \t}\n       else\n \t{\n@@ -7281,34 +7288,26 @@ output_return_instruction (operand, really_return, reverse)\n \n \t      memcpy (p, \"%|\", 2);\n \t      memcpy (p + 2, return_reg, l);\n-\t      strcpy (p + 2 + l, (TARGET_APCS_32 || !really_return) ? \"}\" : \"}^\");\n+\t      strcpy (p + 2 + l, ((TARGET_APCS_32 \n+\t\t\t\t   && !IS_INTERRUPT (func_type)) \n+\t\t\t\t  || !really_return) \n+\t\t      ? \"}\" : \"}^\");\n \t    }\n \t  else\n \t    strcpy (p, \"}\");\n \t}\n \n       output_asm_insn (instr, & operand);\n \n-      if (really_return)\n+      /* See if we need to generate an extra instruction to\n+\t perform the actual function return.  */\n+      if (really_return\n+\t  && func_type != ARM_FT_INTERWORKED\n+\t  && (live_regs_mask & (1 << LR_REGNUM)) != 0)\n \t{\n-\t  /* See if we need to generate an extra instruction to\n-\t     perform the actual function return.  */\n-\t  switch ((int) ARM_FUNC_TYPE (func_type))\n-\t    {\n-\t    case ARM_FT_ISR:\n-\t    case ARM_FT_FIQ:\n-\t    case ARM_FT_EXCEPTION:\n-\t    case ARM_FT_INTERWORKED:\n-\t      /* A separate return instruction is always needed.  */\n-\t      break;\n-\n-\t    default:\n-\t      /* The return may have already been handled\n-\t\t by loading the LR into the PC.  */\n-\t      if ((live_regs_mask & (1 << LR_REGNUM)) != 0)\n-\t\treally_return = 0;\n-\t      break;\n-\t    }\n+\t  /* The return has already been handled\n+\t     by loading the LR into the PC.  */\n+\t  really_return = 0;\n \t}\n     }\n   \n@@ -8245,6 +8244,19 @@ arm_expand_prologue ()\n       RTX_FRAME_RELATED_P (insn) = 1;\n     }\n \n+  /* If this is an interrupt service routine, and the link register is\n+     going to be pushed, subtracting four now will mean that the\n+     function return can be done with a single instruction.  */\n+  if ((func_type == ARM_FT_ISR || func_type == ARM_FT_FIQ)\n+      && (live_regs_mask & (1 << LR_REGNUM)) != 0)\n+    {\n+      emit_insn (gen_rtx_SET (SImode, \n+\t\t\t      gen_rtx_REG (SImode, LR_REGNUM),\n+\t\t\t      gen_rtx_PLUS (SImode,\n+\t\t\t\t    gen_rtx_REG (SImode, LR_REGNUM),\n+\t\t\t\t    GEN_INT (-4))));\n+    }\n+\n   if (live_regs_mask)\n     {\n       insn = emit_multi_reg_push (live_regs_mask);"}]}