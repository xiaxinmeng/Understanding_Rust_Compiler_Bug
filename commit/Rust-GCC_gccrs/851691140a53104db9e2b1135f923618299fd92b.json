{"sha": "851691140a53104db9e2b1135f923618299fd92b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODUxNjkxMTQwYTUzMTA0ZGI5ZTJiMTEzNWY5MjM2MTgyOTlmZDkyYg==", "commit": {"author": {"name": "Paolo Bonzini", "email": "bonzini@gnu.org", "date": "2009-02-06T07:33:05Z"}, "committer": {"name": "Paolo Bonzini", "email": "bonzini@gcc.gnu.org", "date": "2009-02-06T07:33:05Z"}, "message": "re PR target/35659 (Miscompiled code with -O2 (but not with -O2 -funroll-loops) on ia64)\n\n2009-02-06  Paolo Bonzini  <bonzini@gnu.org>\n\n\tPR tree-optimization/35659\n\t* tree-ssa-sccvn.c (vn_constant_eq, vn_reference_eq, vn_nary_op_eq\n\tvn_phi_eq): Shortcut if hashcode does not match.\n\t(vn_reference_op_compute_hash): Do not call iterative_hash_expr for\n\tNULL operands.\n\t* tree-ssa-pre.c (pre_expr_hash): Look at hashcode if available,\n\tand avoid iterative_hash_expr.\n\t(FOR_EACH_VALUE_ID_IN_SET): New.\n\t(value_id_compare): Remove.\n\t(sorted_array_from_bitmap_set): Use FOR_EACH_VALUE_ID_IN_SET to\n\tsort expressions by value id.\n\nFrom-SVN: r143980", "tree": {"sha": "0a8d158aa9cc33fc558acdf02d5f054a85411376", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0a8d158aa9cc33fc558acdf02d5f054a85411376"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/851691140a53104db9e2b1135f923618299fd92b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/851691140a53104db9e2b1135f923618299fd92b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/851691140a53104db9e2b1135f923618299fd92b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/851691140a53104db9e2b1135f923618299fd92b/comments", "author": {"login": "bonzini", "id": 42082, "node_id": "MDQ6VXNlcjQyMDgy", "avatar_url": "https://avatars.githubusercontent.com/u/42082?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bonzini", "html_url": "https://github.com/bonzini", "followers_url": "https://api.github.com/users/bonzini/followers", "following_url": "https://api.github.com/users/bonzini/following{/other_user}", "gists_url": "https://api.github.com/users/bonzini/gists{/gist_id}", "starred_url": "https://api.github.com/users/bonzini/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bonzini/subscriptions", "organizations_url": "https://api.github.com/users/bonzini/orgs", "repos_url": "https://api.github.com/users/bonzini/repos", "events_url": "https://api.github.com/users/bonzini/events{/privacy}", "received_events_url": "https://api.github.com/users/bonzini/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "fe960d925789ffd66c24c3b2debf9c240d80eb24", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe960d925789ffd66c24c3b2debf9c240d80eb24", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fe960d925789ffd66c24c3b2debf9c240d80eb24"}], "stats": {"total": 85, "additions": 60, "deletions": 25}, "files": [{"sha": "8a7a3187c4f3e63a86dcda4180246158a6dc79c1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/851691140a53104db9e2b1135f923618299fd92b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/851691140a53104db9e2b1135f923618299fd92b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=851691140a53104db9e2b1135f923618299fd92b", "patch": "@@ -1,3 +1,17 @@\n+2009-02-06  Paolo Bonzini  <bonzini@gnu.org>\n+\n+\tPR tree-optimization/35659\n+\t* tree-ssa-sccvn.c (vn_constant_eq, vn_reference_eq, vn_nary_op_eq\n+\tvn_phi_eq): Shortcut if hashcode does not match.\n+\t(vn_reference_op_compute_hash): Do not call iterative_hash_expr for\n+\tNULL operands.\n+\t* tree-ssa-pre.c (pre_expr_hash): Look at hashcode if available,\n+\tand avoid iterative_hash_expr.\n+\t(FOR_EACH_VALUE_ID_IN_SET): New.\n+\t(value_id_compare): Remove.\n+\t(sorted_array_from_bitmap_set): Use FOR_EACH_VALUE_ID_IN_SET to\n+\tsort expressions by value id.\n+\n 2009-02-05  Kaz Kojima  <kkojima@gcc.gnu.org>\n \n \tPR target/38991"}, {"sha": "32c557cc0fb77543548f193ba463f3112280e26a", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 26, "deletions": 22, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/851691140a53104db9e2b1135f923618299fd92b/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/851691140a53104db9e2b1135f923618299fd92b/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=851691140a53104db9e2b1135f923618299fd92b", "patch": "@@ -216,11 +216,11 @@ pre_expr_hash (const void *p1)\n     case CONSTANT:\n       return vn_hash_constant_with_type (PRE_EXPR_CONSTANT (e));\n     case NAME:\n-      return iterative_hash_expr (PRE_EXPR_NAME (e), 0);\n+      return iterative_hash_hashval_t (SSA_NAME_VERSION (PRE_EXPR_NAME (e)), 0);\n     case NARY:\n-      return vn_nary_op_compute_hash (PRE_EXPR_NARY (e));\n+      return PRE_EXPR_NARY (e)->hashcode;\n     case REFERENCE:\n-      return vn_reference_compute_hash (PRE_EXPR_REFERENCE (e));\n+      return PRE_EXPR_REFERENCE (e)->hashcode;\n     default:\n       abort ();\n     }\n@@ -337,6 +337,9 @@ typedef struct bitmap_set\n #define FOR_EACH_EXPR_ID_IN_SET(set, id, bi)\t\t\\\n   EXECUTE_IF_SET_IN_BITMAP((set)->expressions, 0, (id), (bi))\n \n+#define FOR_EACH_VALUE_ID_IN_SET(set, id, bi)\t\t\\\n+  EXECUTE_IF_SET_IN_BITMAP((set)->values, 0, (id), (bi))\n+\n /* Mapping from value id to expressions with that value_id.  */\n DEF_VEC_P (bitmap_set_t);\n DEF_VEC_ALLOC_P (bitmap_set_t, heap);\n@@ -672,33 +675,34 @@ bitmap_set_free (bitmap_set_t set)\n }\n \n \n-/* A comparison function for use in qsort to top sort a bitmap set.  Simply\n-   subtracts value ids, since they are created with leaves before\n-   their parent users (IE topological order).  */\n-\n-static int\n-value_id_compare (const void *pa, const void *pb)\n-{\n-  const unsigned int vha = get_expr_value_id (*((const pre_expr *)pa));\n-  const unsigned int vhb = get_expr_value_id (*((const pre_expr *)pb));\n-\n-  return vha - vhb;\n-}\n-\n /* Generate an topological-ordered array of bitmap set SET.  */\n \n static VEC(pre_expr, heap) *\n sorted_array_from_bitmap_set (bitmap_set_t set)\n {\n-  unsigned int i;\n-  bitmap_iterator bi;\n+  unsigned int i, j;\n+  bitmap_iterator bi, bj;\n   VEC(pre_expr, heap) *result = NULL;\n \n-  FOR_EACH_EXPR_ID_IN_SET (set, i, bi)\n-    VEC_safe_push (pre_expr, heap, result, expression_for_id (i));\n+  FOR_EACH_VALUE_ID_IN_SET (set, i, bi)\n+    {\n+      /* The number of expressions having a given value is usually\n+\t relatively small.  Thus, rather than making a vector of all\n+\t the expressions and sorting it by value-id, we walk the values\n+\t and check in the reverse mapping that tells us what expressions\n+\t have a given value, to filter those in our set.  As a result,\n+\t the expressions are inserted in value-id order, which means\n+\t topological order.\n \n-  qsort (VEC_address (pre_expr, result), VEC_length (pre_expr, result),\n-\t sizeof (pre_expr), value_id_compare);\n+\t If this is somehow a significant lose for some cases, we can\n+\t choose which set to walk based on the set size.  */\n+      bitmap_set_t exprset = VEC_index (bitmap_set_t, value_expressions, i);\n+      FOR_EACH_EXPR_ID_IN_SET (exprset, j, bj)\n+\t{\n+\t  if (bitmap_bit_p (set->expressions, j))\n+\t    VEC_safe_push (pre_expr, heap, result, expression_for_id (j));\n+        }\n+    }\n \n   return result;\n }"}, {"sha": "5f4d1c599d1278ccfed5ba0758d2526485c0c9e0", "filename": "gcc/tree-ssa-sccvn.c", "status": "modified", "additions": 20, "deletions": 3, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/851691140a53104db9e2b1135f923618299fd92b/gcc%2Ftree-ssa-sccvn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/851691140a53104db9e2b1135f923618299fd92b/gcc%2Ftree-ssa-sccvn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sccvn.c?ref=851691140a53104db9e2b1135f923618299fd92b", "patch": "@@ -316,6 +316,9 @@ vn_constant_eq (const void *p1, const void *p2)\n   const struct vn_constant_s *vc1 = (const struct vn_constant_s *) p1;\n   const struct vn_constant_s *vc2 = (const struct vn_constant_s *) p2;\n \n+  if (vc1->hashcode != vc2->hashcode)\n+    return false;\n+\n   return vn_constant_eq_with_type (vc1->constant, vc2->constant);\n }\n \n@@ -386,6 +389,7 @@ vn_reference_op_eq (const void *p1, const void *p2)\n {\n   const_vn_reference_op_t const vro1 = (const_vn_reference_op_t) p1;\n   const_vn_reference_op_t const vro2 = (const_vn_reference_op_t) p2;\n+\n   return vro1->opcode == vro2->opcode\n     && types_compatible_p (vro1->type, vro2->type)\n     && expressions_equal_p (vro1->op0, vro2->op0)\n@@ -398,9 +402,14 @@ vn_reference_op_eq (const void *p1, const void *p2)\n static hashval_t\n vn_reference_op_compute_hash (const vn_reference_op_t vro1)\n {\n-  return iterative_hash_expr (vro1->op0, vro1->opcode)\n-    + iterative_hash_expr (vro1->op1, vro1->opcode)\n-    + iterative_hash_expr (vro1->op2, vro1->opcode);\n+  hashval_t result = 0;\n+  if (vro1->op0)\n+    result += iterative_hash_expr (vro1->op0, vro1->opcode);\n+  if (vro1->op1)\n+    result += iterative_hash_expr (vro1->op1, vro1->opcode);\n+  if (vro1->op2)\n+    result += iterative_hash_expr (vro1->op2, vro1->opcode);\n+  return result;\n }\n \n /* Return the hashcode for a given reference operation P1.  */\n@@ -442,6 +451,8 @@ vn_reference_eq (const void *p1, const void *p2)\n \n   const_vn_reference_t const vr1 = (const_vn_reference_t) p1;\n   const_vn_reference_t const vr2 = (const_vn_reference_t) p2;\n+  if (vr1->hashcode != vr2->hashcode)\n+    return false;\n \n   if (vr1->vuses == vr2->vuses\n       && vr1->operands == vr2->operands)\n@@ -1183,6 +1194,9 @@ vn_nary_op_eq (const void *p1, const void *p2)\n   const_vn_nary_op_t const vno2 = (const_vn_nary_op_t) p2;\n   unsigned i;\n \n+  if (vno1->hashcode != vno2->hashcode)\n+    return false;\n+\n   if (vno1->opcode != vno2->opcode\n       || !types_compatible_p (vno1->type, vno2->type))\n     return false;\n@@ -1449,6 +1463,9 @@ vn_phi_eq (const void *p1, const void *p2)\n   const_vn_phi_t const vp1 = (const_vn_phi_t) p1;\n   const_vn_phi_t const vp2 = (const_vn_phi_t) p2;\n \n+  if (vp1->hashcode != vp2->hashcode)\n+    return false;\n+\n   if (vp1->block == vp2->block)\n     {\n       int i;"}]}