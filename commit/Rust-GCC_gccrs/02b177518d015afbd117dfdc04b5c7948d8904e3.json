{"sha": "02b177518d015afbd117dfdc04b5c7948d8904e3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDJiMTc3NTE4ZDAxNWFmYmQxMTdkZmRjMDRiNWM3OTQ4ZDg5MDRlMw==", "commit": {"author": {"name": "Janne Blomqvist", "email": "jb@gcc.gnu.org", "date": "2011-02-05T16:22:04Z"}, "committer": {"name": "Janne Blomqvist", "email": "jb@gcc.gnu.org", "date": "2011-02-05T16:22:04Z"}, "message": "PR 47571 Fix HPUX bootstrap regression, cleanup\n\nFrom-SVN: r169852", "tree": {"sha": "8f4de5377ee7b6e94eba0353814a02bb30e8f523", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8f4de5377ee7b6e94eba0353814a02bb30e8f523"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/02b177518d015afbd117dfdc04b5c7948d8904e3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/02b177518d015afbd117dfdc04b5c7948d8904e3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/02b177518d015afbd117dfdc04b5c7948d8904e3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/02b177518d015afbd117dfdc04b5c7948d8904e3/comments", "author": null, "committer": null, "parents": [{"sha": "beea27550eb8be53affa33bdd8a32714b7166c60", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/beea27550eb8be53affa33bdd8a32714b7166c60", "html_url": "https://github.com/Rust-GCC/gccrs/commit/beea27550eb8be53affa33bdd8a32714b7166c60"}], "stats": {"total": 160, "additions": 98, "deletions": 62}, "files": [{"sha": "fbeb87da55cc0002f10ae42c0f58c9439b028ca0", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02b177518d015afbd117dfdc04b5c7948d8904e3/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02b177518d015afbd117dfdc04b5c7948d8904e3/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=02b177518d015afbd117dfdc04b5c7948d8904e3", "patch": "@@ -1,3 +1,17 @@\n+2011-02-05  Janne Blomqvist  <jb@gcc.gnu.org>\n+\n+\tPR libfortran/47571\n+\t* intrinsics/time_1.h (GF_CLOCK_MONOTONIC): Move to system_clock.c.\n+\t(weak_gettime): Likewise.\n+\t(gf_gettime): Change API, move weak_gettime() usage to\n+\tsystem_clock.c\n+\t* intrinsics/system_clock.c (GTHREAD_USE_WEAK): Define.\n+\t(gf_gettime_mono): New function.\n+\t(system_clock_4): Use gf_gettime_mono().\n+\t(system_clock_8): Likewise.\n+\t* intrinsics/date_and_time.c (date_and_time): Update gf_gettime()\n+\tusage.\n+\n 2011-02-02  Janne Blomqvist  <jb@gcc.gnu.org>\n \n \tPR libfortran/47571"}, {"sha": "c58d11437b3e192a636a231952d254f15a1abb25", "filename": "libgfortran/intrinsics/date_and_time.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02b177518d015afbd117dfdc04b5c7948d8904e3/libgfortran%2Fintrinsics%2Fdate_and_time.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02b177518d015afbd117dfdc04b5c7948d8904e3/libgfortran%2Fintrinsics%2Fdate_and_time.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fintrinsics%2Fdate_and_time.c?ref=02b177518d015afbd117dfdc04b5c7948d8904e3", "patch": "@@ -162,11 +162,11 @@ date_and_time (char *__date, char *__time, char *__zone,\n   struct tm local_time;\n   struct tm UTC_time;\n \n-  long nanosecs;\n+  long usecs;\n \n-  if (!gf_gettime(GF_CLOCK_REALTIME, &lt, &nanosecs))\n+  if (!gf_gettime (&lt, &usecs))\n     {\n-      values[7] = nanosecs / 1000000;\n+      values[7] = usecs / 1000;\n \n       localtime_r (&lt, &local_time);\n       gmtime_r (&lt, &UTC_time);"}, {"sha": "3a44dd9666b9b7b4769b88277dbe3b7d3a97a057", "filename": "libgfortran/intrinsics/system_clock.c", "status": "modified", "additions": 71, "deletions": 2, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02b177518d015afbd117dfdc04b5c7948d8904e3/libgfortran%2Fintrinsics%2Fsystem_clock.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02b177518d015afbd117dfdc04b5c7948d8904e3/libgfortran%2Fintrinsics%2Fsystem_clock.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fintrinsics%2Fsystem_clock.c?ref=02b177518d015afbd117dfdc04b5c7948d8904e3", "patch": "@@ -29,6 +29,75 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n \n #include \"time_1.h\"\n \n+#ifdef HAVE_CLOCK_GETTIME\n+/* POSIX states that CLOCK_REALTIME must be present if clock_gettime\n+   is available, others are optional.  */\n+#ifdef CLOCK_MONOTONIC\n+#define GF_CLOCK_MONOTONIC CLOCK_MONOTONIC\n+#else\n+#define GF_CLOCK_MONOTONIC CLOCK_REALTIME\n+#endif\n+\n+/* Weakref trickery for clock_gettime().  On Glibc, clock_gettime()\n+   requires us to link in librt, which also pulls in libpthread.  In\n+   order to avoid this by default, only call clock_gettime() through a\n+   weak reference. \n+\n+   Some targets don't support weak undefined references; on these\n+   GTHREAD_USE_WEAK is 0. So we need to define it to 1 on other\n+   targets.  */\n+#ifndef GTHREAD_USE_WEAK\n+#define GTHREAD_USE_WEAK 1\n+#endif\n+\n+#if SUPPORTS_WEAK && GTHREAD_USE_WEAK\n+static int weak_gettime (clockid_t, struct timespec *) \n+  __attribute__((__weakref__(\"clock_gettime\")));\n+#else\n+static inline int weak_gettime (clockid_t clk_id, struct timespec *res)\n+{\n+  return clock_gettime (clk_id, res);\n+}\n+#endif\n+#endif\n+\n+\n+/* High resolution monotonic clock, falling back to the realtime clock\n+   if the target does not support such a clock.\n+\n+   Arguments:\n+   secs     - OUTPUT, seconds\n+   nanosecs - OUTPUT, nanoseconds\n+\n+   If the target supports a monotonic clock, the OUTPUT arguments\n+   represent a monotonically incrementing clock starting from some\n+   unspecified time in the past.\n+\n+   If a monotonic clock is not available, falls back to the realtime\n+   clock which is not monotonic.\n+\n+   Return value: 0 for success, -1 for error. In case of error, errno\n+   is set.\n+*/\n+static inline int\n+gf_gettime_mono (time_t * secs, long * nanosecs)\n+{\n+  int err;\n+#ifdef HAVE_CLOCK_GETTIME\n+  if (weak_gettime)\n+    {\n+      struct timespec ts;\n+      err = weak_gettime (GF_CLOCK_MONOTONIC, &ts);\n+      *secs = ts.tv_sec;\n+      *nanosecs = ts.tv_nsec;\n+      return err;\n+    }\n+#endif\n+  err = gf_gettime (secs, nanosecs);\n+  *nanosecs *= 1000;\n+  return err;\n+}\n+\n extern void system_clock_4 (GFC_INTEGER_4 *, GFC_INTEGER_4 *, GFC_INTEGER_4 *);\n export_proto(system_clock_4);\n \n@@ -56,7 +125,7 @@ system_clock_4(GFC_INTEGER_4 *count, GFC_INTEGER_4 *count_rate,\n   if (sizeof (secs) < sizeof (GFC_INTEGER_4))\n     internal_error (NULL, \"secs too small\");\n \n-  if (gf_gettime (GF_CLOCK_MONOTONIC, &secs, &nanosecs) == 0)\n+  if (gf_gettime_mono (&secs, &nanosecs) == 0)\n     {\n       GFC_UINTEGER_4 ucnt = (GFC_UINTEGER_4) secs * TCK;\n       ucnt += (nanosecs + 500000000 / TCK) / (1000000000 / TCK);\n@@ -103,7 +172,7 @@ system_clock_8 (GFC_INTEGER_8 *count, GFC_INTEGER_8 *count_rate,\n   if (sizeof (secs) < sizeof (GFC_INTEGER_4))\n     internal_error (NULL, \"secs too small\");\n \n-  if (gf_gettime (GF_CLOCK_MONOTONIC, &secs, &nanosecs) == 0)\n+  if (gf_gettime_mono (&secs, &nanosecs) == 0)\n     {\n       GFC_UINTEGER_8 ucnt = (GFC_UINTEGER_8) secs * TCK;\n       ucnt += (nanosecs + 500000000 / TCK) / (1000000000 / TCK);"}, {"sha": "073595a1442e40a70cdd8ed96980f83b19a216bc", "filename": "libgfortran/intrinsics/time_1.h", "status": "modified", "additions": 10, "deletions": 57, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02b177518d015afbd117dfdc04b5c7948d8904e3/libgfortran%2Fintrinsics%2Ftime_1.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02b177518d015afbd117dfdc04b5c7948d8904e3/libgfortran%2Fintrinsics%2Ftime_1.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fintrinsics%2Ftime_1.h?ref=02b177518d015afbd117dfdc04b5c7948d8904e3", "patch": "@@ -175,87 +175,40 @@ gf_cputime (long *user_sec, long *user_usec, long *system_sec, long *system_usec\n #endif\n \n \n-/* POSIX states that CLOCK_REALTIME must be present if clock_gettime\n-   is available, others are optional.  */\n-#ifdef CLOCK_REALTIME\n-#define GF_CLOCK_REALTIME CLOCK_REALTIME\n-#else\n-#define GF_CLOCK_REALTIME 0\n-#endif\n-\n-#ifdef CLOCK_MONOTONIC\n-#define GF_CLOCK_MONOTONIC CLOCK_MONOTONIC\n-#else\n-#define GF_CLOCK_MONOTONIC GF_CLOCK_REALTIME\n-#endif\n-\n-/* Weakref trickery for clock_gettime().  On Glibc, clock_gettime()\n-   requires us to link in librt, which also pulls in libpthread.  In\n-   order to avoid this by default, only call clock_gettime() through a\n-   weak reference.  */\n-#ifdef HAVE_CLOCK_GETTIME\n-#ifdef SUPPORTS_WEAK\n-static int weak_gettime (clockid_t, struct timespec *) \n-  __attribute__((__weakref__(\"clock_gettime\")));\n-#else\n-static inline int weak_gettime (clockid_t clk_id, struct timespec *res)\n-{\n-  return clock_gettime (clk_id, res);\n-}\n-#endif\n-#endif\n+/* Realtime clock with microsecond resolution, falling back to less\n+   precise functions if the target does not support gettimeofday().\n \n-/* Arguments:\n-   clock_id - INPUT, must be either GF_CLOCK_REALTIME or GF_CLOCK_MONOTONIC\n+   Arguments:\n    secs     - OUTPUT, seconds\n-   nanosecs - OUTPUT, OPTIONAL, nanoseconds\n+   usecs    - OUTPUT, microseconds\n \n-   If clock_id equals GF_CLOCK_REALTIME, the OUTPUT arguments shall be\n-   the number of seconds and nanoseconds since the Epoch. If clock_id\n-   equals GF_CLOCK_MONOTONIC, and if the target supports it, the\n-   OUTPUT arguments represent a monotonically incrementing clock\n-   starting from some unspecified time in the past.\n+   The OUTPUT arguments shall represent the number of seconds and\n+   nanoseconds since the Epoch.\n \n    Return value: 0 for success, -1 for error. In case of error, errno\n    is set.\n */\n static inline int\n-gf_gettime (int clock_id __attribute__((unused)), time_t * secs, \n-            long * nanosecs)\n+gf_gettime (time_t * secs, long * usecs)\n {\n-#ifdef HAVE_CLOCK_GETTIME\n-  if (weak_gettime)\n-    {\n-      struct timespec ts;\n-      int err;\n-      err = weak_gettime (clock_id, &ts);\n-      *secs = ts.tv_sec;\n-      if (nanosecs)\n-\t*nanosecs = ts.tv_nsec;\n-      return err;\n-    }\n-#endif\n #ifdef HAVE_GETTIMEOFDAY\n   struct timeval tv;\n   int err;\n   err = gettimeofday (&tv, NULL);\n   *secs = tv.tv_sec;\n-  if (nanosecs)\n-    *nanosecs = tv.tv_usec * 1000;\n+  *usecs = tv.tv_usec;\n   return err;\n #elif HAVE_TIME\n   time_t t, t2;\n   t = time (&t2);\n   *secs = t2;\n-  if (nanosecs)\n-    *nanosecs = 0;\n+  *usecs = 0;\n   if (t == ((time_t)-1))\n     return -1;\n   return 0;\n #else\n   *secs = 0;\n-  if (nanosecs)\n-    *nanosecs = 0;\n+  *usecs = 0;\n   errno = ENOSYS;\n   return -1;\n #endif"}]}