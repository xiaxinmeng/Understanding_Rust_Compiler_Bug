{"sha": "370df3ce7c4e01db1a62b2c639aa2391073cf498", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzcwZGYzY2U3YzRlMDFkYjFhNjJiMmM2MzlhYTIzOTEwNzNjZjQ5OA==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2017-11-09T16:36:07Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2017-11-09T16:36:07Z"}, "message": "bb-reorder.c (max_entry_frequency): Remove.\n\n\t* bb-reorder.c (max_entry_frequency): Remove.\n\t(find_traces, rotate_loop, mark_bb_visited, connect_better_edge_p,\n\tconnect_traces, push_to_next_round_p): Remove prototypes.\n\t(find_traces_1_round): Use counts only.\n\t(push_to_next_round_p): Likewise.\n\t(find_traces): Likewise.\n\t(rotate_loop): Likewise.\n\t(find_traces_1_round): Likewise.\n\t(connect_traces): Likewise.\n\t(edge_order): Likewise.\n\nFrom-SVN: r254602", "tree": {"sha": "182d7f541ae076655bfae5da90dde687c296870d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/182d7f541ae076655bfae5da90dde687c296870d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/370df3ce7c4e01db1a62b2c639aa2391073cf498", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/370df3ce7c4e01db1a62b2c639aa2391073cf498", "html_url": "https://github.com/Rust-GCC/gccrs/commit/370df3ce7c4e01db1a62b2c639aa2391073cf498", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/370df3ce7c4e01db1a62b2c639aa2391073cf498/comments", "author": null, "committer": null, "parents": [{"sha": "9f28fe39be68ca484d025ff49f783f050a0a2360", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9f28fe39be68ca484d025ff49f783f050a0a2360", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9f28fe39be68ca484d025ff49f783f050a0a2360"}], "stats": {"total": 97, "additions": 38, "deletions": 59}, "files": [{"sha": "6a58579d64ec2342350a1c753db87af97e7c8cd2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/370df3ce7c4e01db1a62b2c639aa2391073cf498/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/370df3ce7c4e01db1a62b2c639aa2391073cf498/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=370df3ce7c4e01db1a62b2c639aa2391073cf498", "patch": "@@ -1,3 +1,16 @@\n+2017-11-09  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* bb-reorder.c (max_entry_frequency): Remove.\n+\t(find_traces, rotate_loop, mark_bb_visited, connect_better_edge_p,\n+\tconnect_traces, push_to_next_round_p): Remove prototypes.\n+\t(find_traces_1_round): Use counts only.\n+\t(push_to_next_round_p): Likewise.\n+\t(find_traces): Likewise.\n+\t(rotate_loop): Likewise.\n+\t(find_traces_1_round): Likewise.\n+\t(connect_traces): Likewise.\n+\t(edge_order): Likewise.\n+\n 2017-11-09  Thomas Preud'homme  <thomas.preudhomme@arm.com>\n \n \t* config/arm/arm.c (output_return_instruction): Add comments to"}, {"sha": "ce20100c188acae596ef20b927a8f788ffd01a80", "filename": "gcc/bb-reorder.c", "status": "modified", "additions": 25, "deletions": 59, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/370df3ce7c4e01db1a62b2c639aa2391073cf498/gcc%2Fbb-reorder.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/370df3ce7c4e01db1a62b2c639aa2391073cf498/gcc%2Fbb-reorder.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbb-reorder.c?ref=370df3ce7c4e01db1a62b2c639aa2391073cf498", "patch": "@@ -197,24 +197,16 @@ struct trace\n };\n \n /* Maximum frequency and count of one of the entry blocks.  */\n-static int max_entry_frequency;\n static profile_count max_entry_count;\n \n /* Local function prototypes.  */\n-static void find_traces (int *, struct trace *);\n-static basic_block rotate_loop (edge, struct trace *, int);\n-static void mark_bb_visited (basic_block, int);\n-static void find_traces_1_round (int, int, gcov_type, struct trace *, int *,\n+static void find_traces_1_round (int, profile_count, struct trace *, int *,\n \t\t\t\t int, bb_heap_t **, int);\n static basic_block copy_bb (basic_block, edge, basic_block, int);\n static long bb_to_key (basic_block);\n static bool better_edge_p (const_basic_block, const_edge, profile_probability,\n \t\t\t   int, profile_probability, int, const_edge);\n-static bool connect_better_edge_p (const_edge, bool, int, const_edge,\n-\t\t\t\t   struct trace *);\n-static void connect_traces (int, struct trace *);\n static bool copy_bb_p (const_basic_block, int);\n-static bool push_to_next_round_p (const_basic_block, int, int, int, gcov_type);\n \f\n /* Return the trace number in which BB was visited.  */\n \n@@ -249,15 +241,14 @@ mark_bb_visited (basic_block bb, int trace)\n \n static bool\n push_to_next_round_p (const_basic_block bb, int round, int number_of_rounds,\n-\t\t      int exec_th, gcov_type count_th)\n+\t\t      profile_count count_th)\n {\n   bool there_exists_another_round;\n   bool block_not_hot_enough;\n \n   there_exists_another_round = round < number_of_rounds - 1;\n \n-  block_not_hot_enough = (bb->count.to_frequency (cfun) < exec_th\n-\t\t\t  || bb->count.ipa () < count_th\n+  block_not_hot_enough = (bb->count < count_th\n \t\t\t  || probably_never_executed_bb_p (cfun, bb));\n \n   if (there_exists_another_round\n@@ -287,33 +278,26 @@ find_traces (int *n_traces, struct trace *traces)\n   number_of_rounds = N_ROUNDS - 1;\n \n   /* Insert entry points of function into heap.  */\n-  max_entry_frequency = 0;\n   max_entry_count = profile_count::zero ();\n   FOR_EACH_EDGE (e, ei, ENTRY_BLOCK_PTR_FOR_FN (cfun)->succs)\n     {\n       bbd[e->dest->index].heap = heap;\n       bbd[e->dest->index].node = heap->insert (bb_to_key (e->dest), e->dest);\n-      if (e->dest->count.to_frequency (cfun) > max_entry_frequency)\n-\tmax_entry_frequency = e->dest->count.to_frequency (cfun);\n-      if (e->dest->count.ipa_p () && e->dest->count > max_entry_count)\n+      if (e->dest->count > max_entry_count)\n \tmax_entry_count = e->dest->count;\n     }\n \n   /* Find the traces.  */\n   for (i = 0; i < number_of_rounds; i++)\n     {\n-      gcov_type count_threshold;\n+      profile_count count_threshold;\n \n       if (dump_file)\n \tfprintf (dump_file, \"STC - round %d\\n\", i + 1);\n \n-      if (max_entry_count < INT_MAX / 1000)\n-\tcount_threshold = max_entry_count.to_gcov_type () * exec_threshold[i] / 1000;\n-      else\n-\tcount_threshold = max_entry_count.to_gcov_type () / 1000 * exec_threshold[i];\n+      count_threshold = max_entry_count.apply_scale (exec_threshold[i], 1000);\n \n       find_traces_1_round (REG_BR_PROB_BASE * branch_threshold[i] / 1000,\n-\t\t\t   max_entry_frequency * exec_threshold[i] / 1000,\n \t\t\t   count_threshold, traces, n_traces, i, &heap,\n \t\t\t   number_of_rounds);\n     }\n@@ -349,7 +333,6 @@ rotate_loop (edge back_edge, struct trace *trace, int trace_n)\n   /* Information about the best end (end after rotation) of the loop.  */\n   basic_block best_bb = NULL;\n   edge best_edge = NULL;\n-  int best_freq = -1;\n   profile_count best_count = profile_count::uninitialized ();\n   /* The best edge is preferred when its destination is not visited yet\n      or is a start block of some trace.  */\n@@ -375,12 +358,9 @@ rotate_loop (edge back_edge, struct trace *trace, int trace_n)\n \t\t  || bbd[e->dest->index].start_of_trace >= 0)\n \t\t{\n \t\t  /* The current edge E is also preferred.  */\n-\t\t  int freq = EDGE_FREQUENCY (e);\n-\t\t  if (freq > best_freq || e->count () > best_count)\n+\t\t  if (e->count () > best_count)\n \t\t    {\n-\t\t      best_freq = freq;\n-\t\t      if (e->count ().initialized_p ())\n-\t\t        best_count = e->count ();\n+\t\t      best_count = e->count ();\n \t\t      best_edge = e;\n \t\t      best_bb = bb;\n \t\t    }\n@@ -393,17 +373,14 @@ rotate_loop (edge back_edge, struct trace *trace, int trace_n)\n \t\t{\n \t\t  /* The current edge E is preferred.  */\n \t\t  is_preferred = true;\n-\t\t  best_freq = EDGE_FREQUENCY (e);\n \t\t  best_count = e->count ();\n \t\t  best_edge = e;\n \t\t  best_bb = bb;\n \t\t}\n \t      else\n \t\t{\n-\t\t  int freq = EDGE_FREQUENCY (e);\n-\t\t  if (!best_edge || freq > best_freq || e->count () > best_count)\n+\t\t  if (!best_edge || e->count () > best_count)\n \t\t    {\n-\t\t      best_freq = freq;\n \t\t      best_count = e->count ();\n \t\t      best_edge = e;\n \t\t      best_bb = bb;\n@@ -464,7 +441,7 @@ rotate_loop (edge back_edge, struct trace *trace, int trace_n)\n    *HEAP and store starting points for the next round into new *HEAP.  */\n \n static void\n-find_traces_1_round (int branch_th, int exec_th, gcov_type count_th,\n+find_traces_1_round (int branch_th, profile_count count_th,\n \t\t     struct trace *traces, int *n_traces, int round,\n \t\t     bb_heap_t **heap, int number_of_rounds)\n {\n@@ -494,7 +471,7 @@ find_traces_1_round (int branch_th, int exec_th, gcov_type count_th,\n \t round.  When optimizing for size, do not push to next round.  */\n \n       if (!for_size\n-\t  && push_to_next_round_p (bb, round, number_of_rounds, exec_th,\n+\t  && push_to_next_round_p (bb, round, number_of_rounds,\n \t\t\t\t   count_th))\n \t{\n \t  int key = bb_to_key (bb);\n@@ -574,8 +551,7 @@ find_traces_1_round (int branch_th, int exec_th, gcov_type count_th,\n \t      if (!(e->flags & EDGE_CAN_FALLTHRU) || (e->flags & EDGE_COMPLEX)\n \t\t  || !prob.initialized_p ()\n \t\t  || ((prob.to_reg_br_prob_base () < branch_th\n-\t\t       || EDGE_FREQUENCY (e) < exec_th\n-\t\t      || e->count ().ipa () < count_th) && (!for_size)))\n+\t\t      || e->count () < count_th) && (!for_size)))\n \t\tcontinue;\n \n \t      if (better_edge_p (bb, e, prob, freq, best_prob, best_freq,\n@@ -666,14 +642,12 @@ find_traces_1_round (int branch_th, int exec_th, gcov_type count_th,\n \t\t  bb_heap_t *which_heap = *heap;\n \n \t\t  prob = e->probability;\n-\t\t  freq = EDGE_FREQUENCY (e);\n \n \t\t  if (!(e->flags & EDGE_CAN_FALLTHRU)\n \t\t      || (e->flags & EDGE_COMPLEX)\n \t\t      || !prob.initialized_p ()\n \t\t      || prob.to_reg_br_prob_base () < branch_th\n-\t\t      || freq < exec_th\n-\t\t      || e->count ().ipa () < count_th)\n+\t\t      || e->count () < count_th)\n \t\t    {\n \t\t      /* When partitioning hot/cold basic blocks, make sure\n \t\t\t the cold blocks (and only the cold blocks) all get\n@@ -682,7 +656,7 @@ find_traces_1_round (int branch_th, int exec_th, gcov_type count_th,\n \n \t\t      if (!for_size && push_to_next_round_p (e->dest, round,\n \t\t\t\t\t\t\t     number_of_rounds,\n-\t\t\t\t\t\t\t     exec_th, count_th))\n+\t\t\t\t\t\t\t     count_th))\n \t\t\twhich_heap = new_heap;\n \t\t    }\n \n@@ -707,8 +681,8 @@ find_traces_1_round (int branch_th, int exec_th, gcov_type count_th,\n \t\t  /* We do nothing with one basic block loops.  */\n \t\t  if (best_edge->dest != bb)\n \t\t    {\n-\t\t      if (EDGE_FREQUENCY (best_edge)\n-\t\t\t  > 4 * best_edge->dest->count.to_frequency (cfun) / 5)\n+\t\t      if (best_edge->count ()\n+\t\t\t  > best_edge->dest->count.apply_scale (4, 5))\n \t\t\t{\n \t\t\t  /* The loop has at least 4 iterations.  If the loop\n \t\t\t     header is not the first block of the function\n@@ -759,9 +733,8 @@ find_traces_1_round (int branch_th, int exec_th, gcov_type count_th,\n \t\t    C\n \n \t\t  where\n-\t\t  EDGE_FREQUENCY (AB) + EDGE_FREQUENCY (BC)\n-\t\t    >= EDGE_FREQUENCY (AC).\n-\t\t  (i.e. 2 * B->frequency >= EDGE_FREQUENCY (AC) )\n+\t\t  AB->count () + BC->count () >= AC->count ().\n+\t\t  (i.e. 2 * B->count >= AC->count )\n \t\t  Best ordering is then A B C.\n \n \t\t  When optimizing for size, A B C is always the best order.\n@@ -785,8 +758,8 @@ find_traces_1_round (int branch_th, int exec_th, gcov_type count_th,\n \t\t\t    & EDGE_CAN_FALLTHRU)\n \t\t\t&& !(single_succ_edge (e->dest)->flags & EDGE_COMPLEX)\n \t\t\t&& single_succ (e->dest) == best_edge->dest\n-\t\t\t&& (2 * e->dest->count.to_frequency (cfun)\n-\t\t\t    >= EDGE_FREQUENCY (best_edge) || for_size))\n+\t\t\t&& (e->dest->count.apply_scale (2, 1)\n+\t\t\t    >= best_edge->count () || for_size))\n \t\t      {\n \t\t\tbest_edge = e;\n \t\t\tif (dump_file)\n@@ -1086,15 +1059,10 @@ connect_traces (int n_traces, struct trace *traces)\n   int last_trace;\n   int current_pass;\n   int current_partition;\n-  int freq_threshold;\n-  gcov_type count_threshold;\n+  profile_count count_threshold;\n   bool for_size = optimize_function_for_size_p (cfun);\n \n-  freq_threshold = max_entry_frequency * DUPLICATION_THRESHOLD / 1000;\n-  if (max_entry_count.to_gcov_type () < INT_MAX / 1000)\n-    count_threshold = max_entry_count.to_gcov_type () * DUPLICATION_THRESHOLD / 1000;\n-  else\n-    count_threshold = max_entry_count.to_gcov_type () / 1000 * DUPLICATION_THRESHOLD;\n+  count_threshold = max_entry_count.apply_scale (DUPLICATION_THRESHOLD, 1000);\n \n   connected = XCNEWVEC (bool, n_traces);\n   last_trace = -1;\n@@ -1291,8 +1259,7 @@ connect_traces (int n_traces, struct trace *traces)\n \t\t\t\t&& bbd[di].start_of_trace >= 0\n \t\t\t\t&& !connected[bbd[di].start_of_trace]\n \t\t\t\t&& BB_PARTITION (e2->dest) == current_partition\n-\t\t\t\t&& EDGE_FREQUENCY (e2) >= freq_threshold\n-\t\t\t\t&& e2->count ().ipa () >= count_threshold\n+\t\t\t\t&& e2->count () >= count_threshold\n \t\t\t\t&& (!best2\n \t\t\t\t    || e2->probability > best2->probability\n \t\t\t\t    || (e2->probability == best2->probability\n@@ -1317,9 +1284,8 @@ connect_traces (int n_traces, struct trace *traces)\n \t\t  && BB_PARTITION (best->src) == BB_PARTITION (best->dest)\n \t\t  && copy_bb_p (best->dest,\n \t\t\t\toptimize_edge_for_speed_p (best)\n-\t\t\t\t&& EDGE_FREQUENCY (best) >= freq_threshold\n \t\t\t\t&& (!best->count ().initialized_p ()\n-\t\t\t\t    || best->count ().ipa () >= count_threshold)))\n+\t\t\t\t    || best->count () >= count_threshold)))\n \t\t{\n \t\t  basic_block new_bb;\n \n@@ -2312,7 +2278,7 @@ reorder_basic_blocks_software_trace_cache (void)\n static bool\n edge_order (edge e1, edge e2)\n {\n-  return EDGE_FREQUENCY (e1) > EDGE_FREQUENCY (e2);\n+  return e1->count () > e2->count ();\n }\n \n /* Reorder basic blocks using the \"simple\" algorithm.  This tries to"}]}