{"sha": "258bfae2f7ab7b1c369fe3343a1132f16396072b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjU4YmZhZTJmN2FiN2IxYzM2OWZlMzM0M2ExMTMyZjE2Mzk2MDcyYg==", "commit": {"author": {"name": "Franz Sirl", "email": "Franz.Sirl-kernel@lauterbach.com", "date": "2001-05-02T20:30:19Z"}, "committer": {"name": "Franz Sirl", "email": "sirl@gcc.gnu.org", "date": "2001-05-02T20:30:19Z"}, "message": "rs6000.c (rs6000_legitimate_address): Allow any stack offsets if not REG_OK_STRICT.\n\n        2000-05-01  Franz Sirl  <Franz.Sirl-kernel@lauterbach.com>\n\n        * config/rs6000/rs6000.c (rs6000_legitimate_address): Allow any stack\n        offsets if not REG_OK_STRICT.\n\n        * config/rs6000/rs6000.h (REG_OK_STRICT_FLAG): New macro.\n        (INT_REG_OK_FOR_INDEX_P): Likewise.\n        (INT_REG_OK_FOR_BASE_P): Likewise.\n        (REG_OK_FOR_INDEX_P): Use INT_REG_OK_FOR_INDEX_P.\n        (REG_OK_FOR_BASE_P): Use INT_REG_OK_FOR_BASE_P.\n        (LEGITIMATE_OFFSET_ADDRESS_P): Use INT_REG_OK_FOR_INDEX_P and\n        INT_REG_OK_FOR_BASE_P instead of REG_OK_FOR_INDEX_P and\n        REG_OK_FOR_BASE_P. Take an additional parameter.\n        (LEGITIMATE_INDEXED_ADDRESS_P): Likeewise.\n        (LEGITIMATE_INDIRECT_ADDRESS_P): Likewise.\n        (LEGITIMATE_LO_SUM_ADDRESS_P): Likewise.\n        (GO_IF_LEGITIMATE_ADDRESS): Move code into new function\n        rs6000_legitimate_address() and use it.\n        * config/rs6000/rs6000.c: Update all callers.\n        (rs6000_legitimate_address): New function.\n\nFrom-SVN: r41772", "tree": {"sha": "dc28da252f441098a54788a3e9014a940e14515a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dc28da252f441098a54788a3e9014a940e14515a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/258bfae2f7ab7b1c369fe3343a1132f16396072b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/258bfae2f7ab7b1c369fe3343a1132f16396072b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/258bfae2f7ab7b1c369fe3343a1132f16396072b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/258bfae2f7ab7b1c369fe3343a1132f16396072b/comments", "author": {"login": "jinkama-san", "id": 1462162, "node_id": "MDQ6VXNlcjE0NjIxNjI=", "avatar_url": "https://avatars.githubusercontent.com/u/1462162?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jinkama-san", "html_url": "https://github.com/jinkama-san", "followers_url": "https://api.github.com/users/jinkama-san/followers", "following_url": "https://api.github.com/users/jinkama-san/following{/other_user}", "gists_url": "https://api.github.com/users/jinkama-san/gists{/gist_id}", "starred_url": "https://api.github.com/users/jinkama-san/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jinkama-san/subscriptions", "organizations_url": "https://api.github.com/users/jinkama-san/orgs", "repos_url": "https://api.github.com/users/jinkama-san/repos", "events_url": "https://api.github.com/users/jinkama-san/events{/privacy}", "received_events_url": "https://api.github.com/users/jinkama-san/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d34c5b8062a04951df36f69493cb9084e7645ccc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d34c5b8062a04951df36f69493cb9084e7645ccc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d34c5b8062a04951df36f69493cb9084e7645ccc"}], "stats": {"total": 217, "additions": 138, "deletions": 79}, "files": [{"sha": "83ca906c43d1820d94c8bf3f7f2a5108468c770e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/258bfae2f7ab7b1c369fe3343a1132f16396072b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/258bfae2f7ab7b1c369fe3343a1132f16396072b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=258bfae2f7ab7b1c369fe3343a1132f16396072b", "patch": "@@ -1,3 +1,24 @@\n+2000-05-01  Franz Sirl  <Franz.Sirl-kernel@lauterbach.com>\n+\n+\t* config/rs6000/rs6000.c (rs6000_legitimate_address): Allow any stack\n+\toffsets if not REG_OK_STRICT.\n+\n+\t* config/rs6000/rs6000.h (REG_OK_STRICT_FLAG): New macro.\n+\t(INT_REG_OK_FOR_INDEX_P): Likewise.\n+\t(INT_REG_OK_FOR_BASE_P): Likewise.\n+\t(REG_OK_FOR_INDEX_P): Use INT_REG_OK_FOR_INDEX_P.\n+\t(REG_OK_FOR_BASE_P): Use INT_REG_OK_FOR_BASE_P.\n+\t(LEGITIMATE_OFFSET_ADDRESS_P): Use INT_REG_OK_FOR_INDEX_P and\n+        INT_REG_OK_FOR_BASE_P instead of REG_OK_FOR_INDEX_P and\n+\tREG_OK_FOR_BASE_P. Take an additional parameter.\n+\t(LEGITIMATE_INDEXED_ADDRESS_P): Likeewise.\n+\t(LEGITIMATE_INDIRECT_ADDRESS_P): Likewise.\n+\t(LEGITIMATE_LO_SUM_ADDRESS_P): Likewise.\n+\t(GO_IF_LEGITIMATE_ADDRESS): Move code into new function\n+\trs6000_legitimate_address() and use it.\n+\t* config/rs6000/rs6000.c: Update all callers.\n+\t(rs6000_legitimate_address): New function.\n+\n 2001-05-02  David Edelsohn  <edelsohn@gnu.org>\n \n \t* config/rs6000/rs6000.c (rs6000_emit_move): Merge"}, {"sha": "7e95c0bd7b6a01cef765bc5eef0bb6f07bdbb0a7", "filename": "gcc/config/rs6000/rs6000-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/258bfae2f7ab7b1c369fe3343a1132f16396072b/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/258bfae2f7ab7b1c369fe3343a1132f16396072b/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h?ref=258bfae2f7ab7b1c369fe3343a1132f16396072b", "patch": "@@ -107,6 +107,7 @@ extern struct rtx_def *create_TOC_reference PARAMS ((rtx));\n extern void rs6000_emit_eh_toc_restore PARAMS ((rtx));\n extern void rs6000_emit_move PARAMS ((rtx, rtx, enum machine_mode));\n extern rtx rs6000_legitimize_address PARAMS ((rtx, rtx, enum machine_mode));\n+extern int rs6000_legitimate_address PARAMS ((enum machine_mode, rtx, int));\n extern void rs6000_select_rtx_section PARAMS ((enum machine_mode, rtx));\n \n extern rtx rs6000_return_addr PARAMS ((int, rtx));"}, {"sha": "4a22802a593be0bacf50acd3fb06f68fdc676042", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 61, "deletions": 9, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/258bfae2f7ab7b1c369fe3343a1132f16396072b/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/258bfae2f7ab7b1c369fe3343a1132f16396072b/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=258bfae2f7ab7b1c369fe3343a1132f16396072b", "patch": "@@ -1550,6 +1550,58 @@ rs6000_legitimize_address (x, oldx, mode)\n   else\n     return NULL_RTX;\n }\n+\n+/* GO_IF_LEGITIMATE_ADDRESS recognizes an RTL expression\n+   that is a valid memory address for an instruction.\n+   The MODE argument is the machine mode for the MEM expression\n+   that wants to use this address.\n+\n+   On the RS/6000, there are four valid address: a SYMBOL_REF that\n+   refers to a constant pool entry of an address (or the sum of it\n+   plus a constant), a short (16-bit signed) constant plus a register,\n+   the sum of two registers, or a register indirect, possibly with an\n+   auto-increment.  For DFmode and DImode with an constant plus register,\n+   we must ensure that both words are addressable or PowerPC64 with offset\n+   word aligned.\n+\n+   For modes spanning multiple registers (DFmode in 32-bit GPRs,\n+   32-bit DImode, TImode), indexed addressing cannot be used because\n+   adjacent memory cells are accessed by adding word-sized offsets\n+   during assembly output.  */\n+int\n+rs6000_legitimate_address (mode, x, reg_ok_strict)\n+    enum machine_mode mode;\n+    rtx x;\n+    int reg_ok_strict;\n+{\n+  if (LEGITIMATE_INDIRECT_ADDRESS_P (x, reg_ok_strict))\n+    return 1;\n+  if ((GET_CODE (x) == PRE_INC || GET_CODE (x) == PRE_DEC)\n+      && TARGET_UPDATE\n+      && LEGITIMATE_INDIRECT_ADDRESS_P (XEXP (x, 0), reg_ok_strict))\n+    return 1;\n+  if (LEGITIMATE_SMALL_DATA_P (mode, x))\n+    return 1;\n+  if (LEGITIMATE_CONSTANT_POOL_ADDRESS_P (x))\n+    return 1;\n+  /* If not REG_OK_STRICT (before reload) let pass any stack offset.  */\n+  if (! reg_ok_strict\n+      && GET_CODE (x) == PLUS\n+      && GET_CODE (XEXP (x, 0)) == REG\n+      && XEXP (x, 0) == virtual_stack_vars_rtx\n+      && GET_CODE (XEXP (x, 1)) == CONST_INT)\n+    return 1;\n+  if (LEGITIMATE_OFFSET_ADDRESS_P (mode, x, reg_ok_strict))\n+    return 1;\n+  if (mode != TImode\n+      && (TARGET_HARD_FLOAT || TARGET_POWERPC64 || mode != DFmode)\n+      && (TARGET_POWERPC64 || mode != DImode)\n+      && LEGITIMATE_INDEXED_ADDRESS_P (x, reg_ok_strict))\n+    return 1;\n+  if (LEGITIMATE_LO_SUM_ADDRESS_P (mode, x, reg_ok_strict))\n+    return 1;\n+  return 0;\n+}\n \f\n /* Emit a move from SOURCE to DEST in mode MODE.  */\n void\n@@ -3098,14 +3150,14 @@ lmw_operation (op, mode)\n       || count != 32 - (int) dest_regno)\n     return 0;\n \n-  if (LEGITIMATE_INDIRECT_ADDRESS_P (src_addr))\n+  if (LEGITIMATE_INDIRECT_ADDRESS_P (src_addr, 0))\n     {\n       offset = 0;\n       base_regno = REGNO (src_addr);\n       if (base_regno == 0)\n \treturn 0;\n     }\n-  else if (LEGITIMATE_OFFSET_ADDRESS_P (SImode, src_addr))\n+  else if (LEGITIMATE_OFFSET_ADDRESS_P (SImode, src_addr, 0))\n     {\n       offset = INTVAL (XEXP (src_addr, 1));\n       base_regno = REGNO (XEXP (src_addr, 0));\n@@ -3128,12 +3180,12 @@ lmw_operation (op, mode)\n \t  || GET_MODE (SET_SRC (elt)) != SImode)\n \treturn 0;\n       newaddr = XEXP (SET_SRC (elt), 0);\n-      if (LEGITIMATE_INDIRECT_ADDRESS_P (newaddr))\n+      if (LEGITIMATE_INDIRECT_ADDRESS_P (newaddr, 0))\n \t{\n \t  newoffset = 0;\n \t  addr_reg = newaddr;\n \t}\n-      else if (LEGITIMATE_OFFSET_ADDRESS_P (SImode, newaddr))\n+      else if (LEGITIMATE_OFFSET_ADDRESS_P (SImode, newaddr, 0))\n \t{\n \t  addr_reg = XEXP (newaddr, 0);\n \t  newoffset = INTVAL (XEXP (newaddr, 1));\n@@ -3176,14 +3228,14 @@ stmw_operation (op, mode)\n       || count != 32 - (int) src_regno)\n     return 0;\n \n-  if (LEGITIMATE_INDIRECT_ADDRESS_P (dest_addr))\n+  if (LEGITIMATE_INDIRECT_ADDRESS_P (dest_addr, 0))\n     {\n       offset = 0;\n       base_regno = REGNO (dest_addr);\n       if (base_regno == 0)\n \treturn 0;\n     }\n-  else if (LEGITIMATE_OFFSET_ADDRESS_P (SImode, dest_addr))\n+  else if (LEGITIMATE_OFFSET_ADDRESS_P (SImode, dest_addr, 0))\n     {\n       offset = INTVAL (XEXP (dest_addr, 1));\n       base_regno = REGNO (XEXP (dest_addr, 0));\n@@ -3206,12 +3258,12 @@ stmw_operation (op, mode)\n \t  || GET_MODE (SET_DEST (elt)) != SImode)\n \treturn 0;\n       newaddr = XEXP (SET_DEST (elt), 0);\n-      if (LEGITIMATE_INDIRECT_ADDRESS_P (newaddr))\n+      if (LEGITIMATE_INDIRECT_ADDRESS_P (newaddr, 0))\n \t{\n \t  newoffset = 0;\n \t  addr_reg = newaddr;\n \t}\n-      else if (LEGITIMATE_OFFSET_ADDRESS_P (SImode, newaddr))\n+      else if (LEGITIMATE_OFFSET_ADDRESS_P (SImode, newaddr, 0))\n \t{\n \t  addr_reg = XEXP (newaddr, 0);\n \t  newoffset = INTVAL (XEXP (newaddr, 1));\n@@ -4270,7 +4322,7 @@ print_operand (file, x, code)\n \n     case 'X':\n       if (GET_CODE (x) == MEM\n-\t  && LEGITIMATE_INDEXED_ADDRESS_P (XEXP (x, 0)))\n+\t  && LEGITIMATE_INDEXED_ADDRESS_P (XEXP (x, 0), 0))\n \tputc ('x', file);\n       return;\n "}, {"sha": "694bc039b9d424ea7cd2113b6088f3163f2f805f", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 55, "deletions": 70, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/258bfae2f7ab7b1c369fe3343a1132f16396072b/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/258bfae2f7ab7b1c369fe3343a1132f16396072b/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=258bfae2f7ab7b1c369fe3343a1132f16396072b", "patch": "@@ -1789,26 +1789,28 @@ typedef struct rs6000_args\n    After reload, it makes no difference, since pseudo regs have\n    been eliminated by then.  */\n \n-#ifndef REG_OK_STRICT\n+#ifdef REG_OK_STRICT\n+# define REG_OK_STRICT_FLAG 1\n+#else\n+# define REG_OK_STRICT_FLAG 0\n+#endif\n \n /* Nonzero if X is a hard reg that can be used as an index\n-   or if it is a pseudo reg.  */\n-#define REG_OK_FOR_INDEX_P(X)\t\t\t\\\n-  (REGNO (X) <= 31 || REGNO (X) == 67 || REGNO (X) >= FIRST_PSEUDO_REGISTER)\n+   or if it is a pseudo reg in the non-strict case.  */\n+#define INT_REG_OK_FOR_INDEX_P(X, STRICT)\t\t\t\\\n+  ((! (STRICT)\t\t\t\t\t\t\t\\\n+    && (REGNO (X) <= 31\t\t\t\t\t\t\\\n+\t|| REGNO (X) == ARG_POINTER_REGNUM\t\t\t\\\n+\t|| REGNO (X) >= FIRST_PSEUDO_REGISTER))\t\t\t\\\n+   || ((STRICT) && REGNO_OK_FOR_INDEX_P (REGNO (X))))\n \n /* Nonzero if X is a hard reg that can be used as a base reg\n-   or if it is a pseudo reg.  */\n-#define REG_OK_FOR_BASE_P(X)\t\t\t\t\t \\\n-  (REGNO (X) > 0 && REG_OK_FOR_INDEX_P (X))\n-\n-#else\n-\n-/* Nonzero if X is a hard reg that can be used as an index.  */\n-#define REG_OK_FOR_INDEX_P(X) REGNO_OK_FOR_INDEX_P (REGNO (X))\n-/* Nonzero if X is a hard reg that can be used as a base reg.  */\n-#define REG_OK_FOR_BASE_P(X) REGNO_OK_FOR_BASE_P (REGNO (X))\n+   or if it is a pseudo reg in the non-strict case.  */\n+#define INT_REG_OK_FOR_BASE_P(X, STRICT)\t\t\t\\\n+  (REGNO (X) > 0 && INT_REG_OK_FOR_INDEX_P (X, (STRICT)))\n \n-#endif\n+#define REG_OK_FOR_INDEX_P(X) INT_REG_OK_FOR_INDEX_P (X, REG_OK_STRICT_FLAG)\n+#define REG_OK_FOR_BASE_P(X)  INT_REG_OK_FOR_BASE_P (X, REG_OK_STRICT_FLAG)\n \f\n /* GO_IF_LEGITIMATE_ADDRESS recognizes an RTL expression\n    that is a valid memory address for an instruction.\n@@ -1845,68 +1847,51 @@ typedef struct rs6000_args\n    && (GET_CODE (X) == SYMBOL_REF || GET_CODE (X) == CONST)\t\t\\\n    && small_data_operand (X, MODE))\n \n-#define LEGITIMATE_ADDRESS_INTEGER_P(X,OFFSET)\t\t\t\t\\\n+#define LEGITIMATE_ADDRESS_INTEGER_P(X, OFFSET)\t\t\t\t\\\n  (GET_CODE (X) == CONST_INT\t\t\t\t\t\t\\\n   && (unsigned HOST_WIDE_INT) (INTVAL (X) + (OFFSET) + 0x8000) < 0x10000)\n \n-#define LEGITIMATE_OFFSET_ADDRESS_P(MODE,X)\t\t\\\n- (GET_CODE (X) == PLUS\t\t\t\t\t\\\n-  && GET_CODE (XEXP (X, 0)) == REG\t\t\t\\\n-  && REG_OK_FOR_BASE_P (XEXP (X, 0))\t\t\t\\\n-  && LEGITIMATE_ADDRESS_INTEGER_P (XEXP (X, 1), 0)\t\\\n-  && (((MODE) != DFmode && (MODE) != DImode)\t\t\\\n-      || (TARGET_32BIT\t\t\t\t\t\\\n-\t  ? LEGITIMATE_ADDRESS_INTEGER_P (XEXP (X, 1), 4) \\\n-\t  : ! (INTVAL (XEXP (X, 1)) & 3)))\t\t\\\n-  && ((MODE) != TImode\t\t\t\t\t\\\n-      || (TARGET_32BIT\t\t\t\t\t\\\n-\t  ? LEGITIMATE_ADDRESS_INTEGER_P (XEXP (X, 1), 12) \\\n-\t  : (LEGITIMATE_ADDRESS_INTEGER_P (XEXP (X, 1), 8) \\\n+#define LEGITIMATE_OFFSET_ADDRESS_P(MODE, X, STRICT)\t\t\\\n+ (GET_CODE (X) == PLUS\t\t\t\t\t\t\\\n+  && GET_CODE (XEXP (X, 0)) == REG\t\t\t\t\\\n+  && INT_REG_OK_FOR_BASE_P (XEXP (X, 0), (STRICT))\t\t\\\n+  && LEGITIMATE_ADDRESS_INTEGER_P (XEXP (X, 1), 0)\t\t\\\n+  && (((MODE) != DFmode && (MODE) != DImode)\t\t\t\\\n+      || (TARGET_32BIT\t\t\t\t\t\t\\\n+\t  ? LEGITIMATE_ADDRESS_INTEGER_P (XEXP (X, 1), 4) \t\\\n+\t  : ! (INTVAL (XEXP (X, 1)) & 3)))\t\t\t\\\n+  && ((MODE) != TImode\t\t\t\t\t\t\\\n+      || (TARGET_32BIT\t\t\t\t\t\t\\\n+\t  ? LEGITIMATE_ADDRESS_INTEGER_P (XEXP (X, 1), 12) \t\\\n+\t  : (LEGITIMATE_ADDRESS_INTEGER_P (XEXP (X, 1), 8) \t\\\n \t     && ! (INTVAL (XEXP (X, 1)) & 3)))))\n \n-#define LEGITIMATE_INDEXED_ADDRESS_P(X)\t\t\\\n- (GET_CODE (X) == PLUS\t\t\t\t\\\n-  && GET_CODE (XEXP (X, 0)) == REG\t\t\\\n-  && GET_CODE (XEXP (X, 1)) == REG\t\t\\\n-  && ((REG_OK_FOR_BASE_P (XEXP (X, 0))\t\t\\\n-       && REG_OK_FOR_INDEX_P (XEXP (X, 1)))\t\\\n-      || (REG_OK_FOR_BASE_P (XEXP (X, 1))\t\\\n-\t  && REG_OK_FOR_INDEX_P (XEXP (X, 0)))))\n-\n-#define LEGITIMATE_INDIRECT_ADDRESS_P(X)\t\\\n-  (GET_CODE (X) == REG && REG_OK_FOR_BASE_P (X))\n-\n-#define LEGITIMATE_LO_SUM_ADDRESS_P(MODE, X)\t\t\\\n-  (TARGET_ELF\t\t\t\t\t\t\\\n-   && ! flag_pic && ! TARGET_TOC\t\t\t\\\n-   && (MODE) != DImode\t\t\t\t\t\\\n-   && (MODE) != TImode\t\t\t\t\t\\\n-   && (TARGET_HARD_FLOAT || (MODE) != DFmode)\t\t\\\n-   && GET_CODE (X) == LO_SUM\t\t\t\t\\\n-   && GET_CODE (XEXP (X, 0)) == REG\t\t\t\\\n-   && REG_OK_FOR_BASE_P (XEXP (X, 0))\t\t\t\\\n+#define LEGITIMATE_INDEXED_ADDRESS_P(X, STRICT)\t\t\t\\\n+ (GET_CODE (X) == PLUS\t\t\t\t\t\t\\\n+  && GET_CODE (XEXP (X, 0)) == REG\t\t\t\t\\\n+  && GET_CODE (XEXP (X, 1)) == REG\t\t\t\t\\\n+  && ((INT_REG_OK_FOR_BASE_P (XEXP (X, 0), (STRICT))\t\t\\\n+       && INT_REG_OK_FOR_INDEX_P (XEXP (X, 1), (STRICT)))\t\\\n+      || (INT_REG_OK_FOR_BASE_P (XEXP (X, 1), (STRICT))\t\t\\\n+\t  && INT_REG_OK_FOR_INDEX_P (XEXP (X, 0), (STRICT)))))\n+\n+#define LEGITIMATE_INDIRECT_ADDRESS_P(X, STRICT)\t\t\\\n+  (GET_CODE (X) == REG && INT_REG_OK_FOR_BASE_P (X, (STRICT)))\n+\n+#define LEGITIMATE_LO_SUM_ADDRESS_P(MODE, X, STRICT)\t\t\\\n+  (TARGET_ELF\t\t\t\t\t\t\t\\\n+   && ! flag_pic && ! TARGET_TOC\t\t\t\t\\\n+   && (MODE) != DImode\t\t\t\t\t\t\\\n+   && (MODE) != TImode\t\t\t\t\t\t\\\n+   && (TARGET_HARD_FLOAT || (MODE) != DFmode)\t\t\t\\\n+   && GET_CODE (X) == LO_SUM\t\t\t\t\t\\\n+   && GET_CODE (XEXP (X, 0)) == REG\t\t\t\t\\\n+   && INT_REG_OK_FOR_BASE_P (XEXP (X, 0), (STRICT))\t\t\\\n    && CONSTANT_P (XEXP (X, 1)))\n \n-#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR)\t\t\\\n-{ if (LEGITIMATE_INDIRECT_ADDRESS_P (X))\t\t\\\n-    goto ADDR;\t\t\t\t\t\t\\\n-  if ((GET_CODE (X) == PRE_INC || GET_CODE (X) == PRE_DEC) \\\n-      && TARGET_UPDATE\t\t\t\t\t\\\n-      && LEGITIMATE_INDIRECT_ADDRESS_P (XEXP (X, 0)))\t\\\n-    goto ADDR;\t\t\t\t\t\t\\\n-  if (LEGITIMATE_SMALL_DATA_P (MODE, X))\t\t\\\n-    goto ADDR;\t\t\t\t\t\t\\\n-  if (LEGITIMATE_CONSTANT_POOL_ADDRESS_P (X))\t\t\\\n-    goto ADDR;\t\t\t\t\t\t\\\n-  if (LEGITIMATE_OFFSET_ADDRESS_P (MODE, X))\t\t\\\n-    goto ADDR;\t\t\t\t\t\t\\\n-  if ((MODE) != TImode\t\t\t\t\t\\\n-      && (TARGET_HARD_FLOAT || TARGET_POWERPC64 || (MODE) != DFmode) \\\n-      && (TARGET_POWERPC64 || (MODE) != DImode)\t\t\\\n-      && LEGITIMATE_INDEXED_ADDRESS_P (X))\t\t\\\n-    goto ADDR;\t\t\t\t\t\t\\\n-  if (LEGITIMATE_LO_SUM_ADDRESS_P (MODE, X))\t\t\\\n-    goto ADDR;\t\t\t\t\t\t\\\n+#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR)\t\t\t\\\n+{ if (rs6000_legitimate_address (MODE, X, REG_OK_STRICT_FLAG))\t\\\n+    goto ADDR;\t\t\t\t\t\t\t\\\n }\n \f\n /* Try machine-dependent ways of modifying an illegitimate address"}]}