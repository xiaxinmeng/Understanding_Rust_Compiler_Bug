{"sha": "3cfd446903f49d549cc5f1a3ea07497834ece1b1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2NmZDQ0NjkwM2Y0OWQ1NDljYzVmMWEzZWEwNzQ5NzgzNGVjZTFiMQ==", "commit": {"author": {"name": "Bill Schmidt", "email": "wschmidt@linux.ibm.com", "date": "2012-08-01T14:00:35Z"}, "committer": {"name": "William Schmidt", "email": "wschmidt@gcc.gnu.org", "date": "2012-08-01T14:00:35Z"}, "message": "gimple-ssa-strength-reduction.c (struct slsr_cand_d): Change base_name to base_expr.\n\n2012-08-01  Bill Schmidt  <wschmidt@linux.ibm.com>\n\n\t* gimple-ssa-strength-reduction.c (struct slsr_cand_d): Change\n\tbase_name to base_expr.\n\t(struct cand_chain_d): Likewise.\n\t(base_cand_hash): Likewise.\n\t(base_cand_eq): Likewise.\n\t(record_potential_basis): Likewise.\n\t(alloc_cand_and_find_basis): Likewise.\n\t(create_mul_ssa_cand): Likewise.\n\t(create_mul_imm_cand): Likewise.\n\t(create_add_ssa_cand): Likewise.\n\t(create_add_imm_cand): Likewise.\n\t(slsr_process_cast): Likewise.\n\t(slsr_process_copy): Likewise.\n\t(dump_candidate): Likewise.\n\t(base_cand_dump_callback): Likewise.\n\t(unconditional_cands_with_known_stride_p): Likewise.\n\t(cand_increment): Likewise.\n\nFrom-SVN: r190038", "tree": {"sha": "48a51892eb9b02843f2560ab7a4943f9af7c8d7a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/48a51892eb9b02843f2560ab7a4943f9af7c8d7a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3cfd446903f49d549cc5f1a3ea07497834ece1b1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3cfd446903f49d549cc5f1a3ea07497834ece1b1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3cfd446903f49d549cc5f1a3ea07497834ece1b1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3cfd446903f49d549cc5f1a3ea07497834ece1b1/comments", "author": null, "committer": null, "parents": [{"sha": "2749c8f6b3afbaae1e0d18c47ee5eb0b07ee9bb4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2749c8f6b3afbaae1e0d18c47ee5eb0b07ee9bb4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2749c8f6b3afbaae1e0d18c47ee5eb0b07ee9bb4"}], "stats": {"total": 97, "additions": 59, "deletions": 38}, "files": [{"sha": "f7790107b64451cab4d0a2137dbcdfd1a4afa208", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3cfd446903f49d549cc5f1a3ea07497834ece1b1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3cfd446903f49d549cc5f1a3ea07497834ece1b1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3cfd446903f49d549cc5f1a3ea07497834ece1b1", "patch": "@@ -1,3 +1,23 @@\n+2012-08-01  Bill Schmidt  <wschmidt@linux.ibm.com>\n+\n+\t* gimple-ssa-strength-reduction.c (struct slsr_cand_d): Change\n+\tbase_name to base_expr.\n+\t(struct cand_chain_d): Likewise.\n+\t(base_cand_hash): Likewise.\n+\t(base_cand_eq): Likewise.\n+\t(record_potential_basis): Likewise.\n+\t(alloc_cand_and_find_basis): Likewise.\n+\t(create_mul_ssa_cand): Likewise.\n+\t(create_mul_imm_cand): Likewise.\n+\t(create_add_ssa_cand): Likewise.\n+\t(create_add_imm_cand): Likewise.\n+\t(slsr_process_cast): Likewise.\n+\t(slsr_process_copy): Likewise.\n+\t(dump_candidate): Likewise.\n+\t(base_cand_dump_callback): Likewise.\n+\t(unconditional_cands_with_known_stride_p): Likewise.\n+\t(cand_increment): Likewise.\n+\n 2012-08-01  Bill Schmidt  <wschmidt@linux.ibm.com>\n \n \tPR tree-optimization/46556"}, {"sha": "e6793a5e3390dc833e887b258cc380ad52ad47fa", "filename": "gcc/gimple-ssa-strength-reduction.c", "status": "modified", "additions": 39, "deletions": 38, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3cfd446903f49d549cc5f1a3ea07497834ece1b1/gcc%2Fgimple-ssa-strength-reduction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3cfd446903f49d549cc5f1a3ea07497834ece1b1/gcc%2Fgimple-ssa-strength-reduction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-strength-reduction.c?ref=3cfd446903f49d549cc5f1a3ea07497834ece1b1", "patch": "@@ -166,16 +166,16 @@ struct slsr_cand_d\n   /* The candidate statement S1.  */\n   gimple cand_stmt;\n \n-  /* The base SSA name B.  */\n-  tree base_name;\n+  /* The base expression B:  often an SSA name, but not always.  */\n+  tree base_expr;\n \n   /* The stride S.  */\n   tree stride;\n \n   /* The index constant i.  */\n   double_int index;\n \n-  /* The type of the candidate.  This is normally the type of base_name,\n+  /* The type of the candidate.  This is normally the type of base_expr,\n      but casts may have occurred when combining feeding instructions.\n      A candidate can only be a basis for candidates of the same final type.\n      (For CAND_REFs, this is the type to be used for operand 1 of the\n@@ -216,12 +216,13 @@ typedef struct slsr_cand_d slsr_cand, *slsr_cand_t;\n typedef const struct slsr_cand_d *const_slsr_cand_t;\n \n /* Pointers to candidates are chained together as part of a mapping\n-   from SSA names to the candidates that use them as a base name.  */\n+   from base expressions to the candidates that use them.  */\n \n struct cand_chain_d\n {\n-  /* SSA name that serves as a base name for the chain of candidates.  */\n-  tree base_name;\n+  /* Base expression for the chain of candidates:  often, but not\n+     always, an SSA name.  */\n+  tree base_expr;\n \n   /* Pointer to a candidate.  */\n   slsr_cand_t cand;\n@@ -253,7 +254,7 @@ static struct pointer_map_t *stmt_cand_map;\n /* Obstack for candidates.  */\n static struct obstack cand_obstack;\n \n-/* Hash table embodying a mapping from base names to chains of candidates.  */\n+/* Hash table embodying a mapping from base exprs to chains of candidates.  */\n static htab_t base_cand_map;\n \n /* Obstack for candidate chains.  */\n@@ -272,7 +273,7 @@ lookup_cand (cand_idx idx)\n static hashval_t\n base_cand_hash (const void *p)\n {\n-  tree base_expr = ((const_cand_chain_t) p)->base_name;\n+  tree base_expr = ((const_cand_chain_t) p)->base_expr;\n   return iterative_hash_expr (base_expr, 0);\n }\n \n@@ -291,10 +292,10 @@ base_cand_eq (const void *p1, const void *p2)\n {\n   const_cand_chain_t const chain1 = (const_cand_chain_t) p1;\n   const_cand_chain_t const chain2 = (const_cand_chain_t) p2;\n-  return operand_equal_p (chain1->base_name, chain2->base_name, 0);\n+  return operand_equal_p (chain1->base_expr, chain2->base_expr, 0);\n }\n \f\n-/* Use the base name from candidate C to look for possible candidates\n+/* Use the base expr from candidate C to look for possible candidates\n    that can serve as a basis for C.  Each potential basis must also\n    appear in a block that dominates the candidate statement and have\n    the same stride and type.  If more than one possible basis exists,\n@@ -308,7 +309,7 @@ find_basis_for_candidate (slsr_cand_t c)\n   cand_chain_t chain;\n   slsr_cand_t basis = NULL;\n \n-  mapping_key.base_name = c->base_name;\n+  mapping_key.base_expr = c->base_expr;\n   chain = (cand_chain_t) htab_find (base_cand_map, &mapping_key);\n \n   for (; chain; chain = chain->next)\n@@ -337,8 +338,8 @@ find_basis_for_candidate (slsr_cand_t c)\n   return 0;\n }\n \n-/* Record a mapping from the base name of C to C itself, indicating that\n-   C may potentially serve as a basis using that base name.  */\n+/* Record a mapping from the base expression of C to C itself, indicating that\n+   C may potentially serve as a basis using that base expression.  */\n \n static void\n record_potential_basis (slsr_cand_t c)\n@@ -347,7 +348,7 @@ record_potential_basis (slsr_cand_t c)\n   void **slot;\n \n   node = (cand_chain_t) obstack_alloc (&chain_obstack, sizeof (cand_chain));\n-  node->base_name = c->base_name;\n+  node->base_expr = c->base_expr;\n   node->cand = c;\n   node->next = NULL;\n   slot = htab_find_slot (base_cand_map, node, INSERT);\n@@ -373,7 +374,7 @@ alloc_cand_and_find_basis (enum cand_kind kind, gimple gs, tree base,\n   slsr_cand_t c = (slsr_cand_t) obstack_alloc (&cand_obstack,\n \t\t\t\t\t       sizeof (slsr_cand));\n   c->cand_stmt = gs;\n-  c->base_name = base;\n+  c->base_expr = base;\n   c->stride = stride;\n   c->index = index;\n   c->cand_type = ctype;\n@@ -617,7 +618,7 @@ create_mul_ssa_cand (gimple gs, tree base_in, tree stride_in, bool speed)\n \t     X = Y * Z\n \t     ================\n \t     X = (B + i') * Z  */\n-\t  base = base_cand->base_name;\n+\t  base = base_cand->base_expr;\n \t  index = base_cand->index;\n \t  stride = stride_in;\n \t  ctype = base_cand->cand_type;\n@@ -632,7 +633,7 @@ create_mul_ssa_cand (gimple gs, tree base_in, tree stride_in, bool speed)\n \t     X = Y * Z\n \t     ============================\n \t     X = B + ((i' * S) * Z)  */\n-\t  base = base_cand->base_name;\n+\t  base = base_cand->base_expr;\n \t  index = double_int_mul (base_cand->index,\n \t\t\t\t  tree_to_double_int (base_cand->stride));\n \t  stride = stride_in;\n@@ -688,7 +689,7 @@ create_mul_imm_cand (gimple gs, tree base_in, tree stride_in, bool speed)\n \t     X = Y * c\n \t     ============================\n \t     X = (B + i') * (S * c)  */\n-\t  base = base_cand->base_name;\n+\t  base = base_cand->base_expr;\n \t  index = base_cand->index;\n \t  temp = double_int_mul (tree_to_double_int (base_cand->stride),\n \t\t\t\t tree_to_double_int (stride_in));\n@@ -705,7 +706,7 @@ create_mul_imm_cand (gimple gs, tree base_in, tree stride_in, bool speed)\n \t     X = Y * c\n \t     ===========================\n \t     X = (B + i') * c  */\n-\t  base = base_cand->base_name;\n+\t  base = base_cand->base_expr;\n \t  index = base_cand->index;\n \t  stride = stride_in;\n \t  ctype = base_cand->cand_type;\n@@ -721,7 +722,7 @@ create_mul_imm_cand (gimple gs, tree base_in, tree stride_in, bool speed)\n \t     X = Y * c\n \t     ===========================\n \t     X = (B + S) * c  */\n-\t  base = base_cand->base_name;\n+\t  base = base_cand->base_expr;\n \t  index = tree_to_double_int (base_cand->stride);\n \t  stride = stride_in;\n \t  ctype = base_cand->cand_type;\n@@ -772,14 +773,14 @@ slsr_process_mul (gimple gs, tree rhs1, tree rhs2, bool speed)\n   if (TREE_CODE (rhs2) == SSA_NAME)\n     {\n       /* Record an interpretation of this statement in the candidate table\n-\t assuming RHS1 is the base name and RHS2 is the stride.  */\n+\t assuming RHS1 is the base expression and RHS2 is the stride.  */\n       c = create_mul_ssa_cand (gs, rhs1, rhs2, speed);\n \n       /* Add the first interpretation to the statement-candidate mapping.  */\n       add_cand_for_stmt (gs, c);\n \n       /* Record another interpretation of this statement assuming RHS1\n-\t is the stride and RHS2 is the base name.  */\n+\t is the stride and RHS2 is the base expression.  */\n       c2 = create_mul_ssa_cand (gs, rhs2, rhs1, speed);\n       c->next_interp = c2->cand_num;\n     }\n@@ -826,7 +827,7 @@ create_add_ssa_cand (gimple gs, tree base_in, tree addend_in,\n \t  index = tree_to_double_int (addend_cand->stride);\n \t  if (subtract_p)\n \t    index = double_int_neg (index);\n-\t  stride = addend_cand->base_name;\n+\t  stride = addend_cand->base_expr;\n \t  ctype = TREE_TYPE (SSA_NAME_VAR (base_in));\n \t  if (has_single_use (addend_in))\n \t    savings = (addend_cand->dead_savings\n@@ -850,7 +851,7 @@ create_add_ssa_cand (gimple gs, tree base_in, tree addend_in,\n \t     X = Y +/- Z\n \t     ============================\n \t     X = B + (+/-1 * Z)  */\n-\t  base = base_cand->base_name;\n+\t  base = base_cand->base_expr;\n \t  index = subtract_p ? double_int_minus_one : double_int_one;\n \t  stride = addend_in;\n \t  ctype = base_cand->cand_type;\n@@ -875,7 +876,7 @@ create_add_ssa_cand (gimple gs, tree base_in, tree addend_in,\n \t\t  base = base_in;\n \t\t  index = tree_to_double_int (subtrahend_cand->stride);\n \t\t  index = double_int_neg (index);\n-\t\t  stride = subtrahend_cand->base_name;\n+\t\t  stride = subtrahend_cand->base_expr;\n \t\t  ctype = TREE_TYPE (SSA_NAME_VAR (base_in));\n \t\t  if (has_single_use (addend_in))\n \t\t    savings = (subtrahend_cand->dead_savings \n@@ -944,7 +945,7 @@ create_add_imm_cand (gimple gs, tree base_in, double_int index_in, bool speed)\n \t     ============================\n \t     X = (B + (i'+ k)) * S  */\n \t  kind = base_cand->kind;\n-\t  base = base_cand->base_name;\n+\t  base = base_cand->base_expr;\n \t  index = double_int_add (base_cand->index, multiple);\n \t  stride = base_cand->stride;\n \t  ctype = base_cand->cand_type;\n@@ -986,7 +987,7 @@ slsr_process_add (gimple gs, tree rhs1, tree rhs2, bool speed)\n \n   if (TREE_CODE (rhs2) == SSA_NAME)\n     {\n-      /* First record an interpretation assuming RHS1 is the base name\n+      /* First record an interpretation assuming RHS1 is the base expression\n \t and RHS2 is the stride.  But it doesn't make sense for the\n \t stride to be a pointer, so don't record a candidate in that case.  */\n       if (!POINTER_TYPE_P (TREE_TYPE (SSA_NAME_VAR (rhs2))))\n@@ -1004,7 +1005,7 @@ slsr_process_add (gimple gs, tree rhs1, tree rhs2, bool speed)\n \treturn;\n \n       /* Otherwise, record another interpretation assuming RHS2 is the\n-\t base name and RHS1 is the stride, again provided that the\n+\t base expression and RHS1 is the stride, again provided that the\n \t stride is not a pointer.  */\n       if (!POINTER_TYPE_P (TREE_TYPE (SSA_NAME_VAR (rhs1))))\n \t{\n@@ -1139,7 +1140,7 @@ slsr_process_cast (gimple gs, tree rhs1, bool speed)\n \t\t       + stmt_cost (base_cand->cand_stmt, speed));\n \n \t  c = alloc_cand_and_find_basis (base_cand->kind, gs,\n-\t\t\t\t\t base_cand->base_name,\n+\t\t\t\t\t base_cand->base_expr,\n \t\t\t\t\t base_cand->index, base_cand->stride,\n \t\t\t\t\t ctype, savings);\n \t  if (base_cand->next_interp)\n@@ -1196,7 +1197,7 @@ slsr_process_copy (gimple gs, tree rhs1, bool speed)\n \t\t       + stmt_cost (base_cand->cand_stmt, speed));\n \n \t  c = alloc_cand_and_find_basis (base_cand->kind, gs,\n-\t\t\t\t\t base_cand->base_name,\n+\t\t\t\t\t base_cand->base_expr,\n \t\t\t\t\t base_cand->index, base_cand->stride,\n \t\t\t\t\t base_cand->cand_type, savings);\n \t  if (base_cand->next_interp)\n@@ -1324,7 +1325,7 @@ dump_candidate (slsr_cand_t c)\n     {\n     case CAND_MULT:\n       fputs (\"     MULT : (\", dump_file);\n-      print_generic_expr (dump_file, c->base_name, 0);\n+      print_generic_expr (dump_file, c->base_expr, 0);\n       fputs (\" + \", dump_file);\n       dump_double_int (dump_file, c->index, false);\n       fputs (\") * \", dump_file);\n@@ -1333,7 +1334,7 @@ dump_candidate (slsr_cand_t c)\n       break;\n     case CAND_ADD:\n       fputs (\"     ADD  : \", dump_file);\n-      print_generic_expr (dump_file, c->base_name, 0);\n+      print_generic_expr (dump_file, c->base_expr, 0);\n       fputs (\" + (\", dump_file);\n       dump_double_int (dump_file, c->index, false);\n       fputs (\" * \", dump_file);\n@@ -1342,7 +1343,7 @@ dump_candidate (slsr_cand_t c)\n       break;\n     case CAND_REF:\n       fputs (\"     REF  : \", dump_file);\n-      print_generic_expr (dump_file, c->base_name, 0);\n+      print_generic_expr (dump_file, c->base_expr, 0);\n       fputs (\" + (\", dump_file);\n       print_generic_expr (dump_file, c->stride, 0);\n       fputs (\") + \", dump_file);\n@@ -1387,7 +1388,7 @@ base_cand_dump_callback (void **slot, void *ignored ATTRIBUTE_UNUSED)\n   const_cand_chain_t chain = *((const_cand_chain_t *) slot);\n   cand_chain_t p;\n \n-  print_generic_expr (dump_file, chain->base_name, 0);\n+  print_generic_expr (dump_file, chain->base_expr, 0);\n   fprintf (dump_file, \" -> %d\", chain->cand->cand_num);\n \n   for (p = chain->next; p; p = p->next)\n@@ -1447,8 +1448,8 @@ unconditional_cands_with_known_stride_p (slsr_cand_t root)\n static void\n replace_ref (tree *expr, slsr_cand_t c)\n {\n-  tree add_expr = fold_build2 (POINTER_PLUS_EXPR, TREE_TYPE (c->base_name),\n-\t\t\t       c->base_name, c->stride);\n+  tree add_expr = fold_build2 (POINTER_PLUS_EXPR, TREE_TYPE (c->base_expr),\n+\t\t\t       c->base_expr, c->stride);\n   tree mem_ref = fold_build2 (MEM_REF, TREE_TYPE (*expr), add_expr,\n \t\t\t      double_int_to_tree (c->cand_type, c->index));\n   \n@@ -1503,7 +1504,7 @@ cand_increment (slsr_cand_t c)\n     return c->index;\n \n   basis = lookup_cand (c->basis);\n-  gcc_assert (operand_equal_p (c->base_name, basis->base_name, 0));\n+  gcc_assert (operand_equal_p (c->base_expr, basis->base_expr, 0));\n   return double_int_sub (c->index, basis->index);\n }\n \n@@ -1698,7 +1699,7 @@ execute_strength_reduction (void)\n   /* Create the obstack where candidate chains will reside.  */\n   gcc_obstack_init (&chain_obstack);\n \n-  /* Allocate the mapping from base names to candidate chains.  */\n+  /* Allocate the mapping from base expressions to candidate chains.  */\n   base_cand_map = htab_create (500, base_cand_hash,\n \t\t\t       base_cand_eq, base_cand_free);\n "}]}