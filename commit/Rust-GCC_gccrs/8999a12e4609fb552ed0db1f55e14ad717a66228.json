{"sha": "8999a12e4609fb552ed0db1f55e14ad717a66228", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODk5OWExMmU0NjA5ZmI1NTJlZDBkYjFmNTVlMTRhZDcxN2E2NjIyOA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-01-10T16:40:26Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-01-10T16:40:26Z"}, "message": "(make_extraction): Don't use POS < 0 as a flag that POS_RTX is to be used; instead use POS_RTX unless it is nonzero.\n\n(make_extraction): Don't use POS < 0 as a flag that POS_RTX is to be\nused; instead use POS_RTX unless it is nonzero.  If POS_RTX is a\nconstant, set POS and clear POS_RTX.\n(make_compound_operation, make_field_assignment): Pass 0 for POS\ninstead of -1 when POS_RTX is nonzero.\n\nFrom-SVN: r3178", "tree": {"sha": "4d04cdad5e541cf9027dcfef4f21711060d2d3cd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4d04cdad5e541cf9027dcfef4f21711060d2d3cd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8999a12e4609fb552ed0db1f55e14ad717a66228", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8999a12e4609fb552ed0db1f55e14ad717a66228", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8999a12e4609fb552ed0db1f55e14ad717a66228", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8999a12e4609fb552ed0db1f55e14ad717a66228/comments", "author": null, "committer": null, "parents": [{"sha": "08fb99fa7d30a78679d5239824d72d9db55a8b9b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/08fb99fa7d30a78679d5239824d72d9db55a8b9b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/08fb99fa7d30a78679d5239824d72d9db55a8b9b"}], "stats": {"total": 43, "additions": 25, "deletions": 18}, "files": [{"sha": "84fbf095596085064c612893c2e81783b2a8a5e2", "filename": "gcc/combine.c", "status": "modified", "additions": 25, "deletions": 18, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8999a12e4609fb552ed0db1f55e14ad717a66228/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8999a12e4609fb552ed0db1f55e14ad717a66228/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=8999a12e4609fb552ed0db1f55e14ad717a66228", "patch": "@@ -4542,9 +4542,9 @@ expand_field_assignment (x)\n   return x;\n }\n \f\n-/* Return an RTX for a reference to LEN bits of INNER.  POS is the starting\n-   bit position (counted from the LSB) if >= 0; otherwise POS_RTX represents\n-   the starting bit position.\n+/* Return an RTX for a reference to LEN bits of INNER.  If POS_RTX is nonzero,\n+   it is an RTX that represents a variable starting position; otherwise,\n+   POS is the (constant) starting bit position (counted from the LSB).\n \n    INNER may be a USE.  This will occur when we started with a bitfield\n    that went outside the boundary of the object in memory, which is\n@@ -4588,6 +4588,7 @@ make_extraction (mode, inner, pos, pos_rtx, len,\n   enum machine_mode tmode = mode_for_size (len, MODE_INT, 1);\n   int spans_byte = 0;\n   rtx new = 0;\n+  rtx orig_pos_rtx = pos_rtx;\n \n   /* Get some information about INNER and get the innermost object.  */\n   if (GET_CODE (inner) == USE)\n@@ -4610,7 +4611,7 @@ make_extraction (mode, inner, pos, pos_rtx, len,\n   inner_mode = GET_MODE (inner);\n \n   if (pos_rtx && GET_CODE (pos_rtx) == CONST_INT)\n-    pos = INTVAL (pos_rtx);\n+    pos = INTVAL (pos_rtx), pos_rtx = 0;\n \n   /* See if this can be done without an extraction.  We never can if the\n      width of the field is not the same as that of some integer mode. For\n@@ -4627,12 +4628,12 @@ make_extraction (mode, inner, pos, pos_rtx, len,\n \n   if (tmode != BLKmode\n       && ! (spans_byte && inner_mode != tmode)\n-      && ((pos == 0 && GET_CODE (inner) != MEM\n+      && ((pos_rtx == 0 && pos == 0 && GET_CODE (inner) != MEM\n \t   && (! in_dest\n \t       || (GET_CODE (inner) == REG\n \t\t   && (movstrict_optab->handlers[(int) tmode].insn_code\n \t\t       != CODE_FOR_nothing))))\n-\t  || (GET_CODE (inner) == MEM && pos >= 0\n+\t  || (GET_CODE (inner) == MEM && pos_rtx == 0\n \t      && (pos\n \t\t  % (STRICT_ALIGNMENT ? GET_MODE_ALIGNMENT (tmode)\n \t\t     : BITS_PER_UNIT)) == 0\n@@ -4696,7 +4697,8 @@ make_extraction (mode, inner, pos, pos_rtx, len,\n   /* Unless this is a COMPARE or we have a funny memory reference,\n      don't do anything with zero-extending field extracts starting at\n      the low-order bit since they are simple AND operations.  */\n-  if (pos == 0 && ! in_dest && ! in_compare && ! spans_byte && unsignedp)\n+  if (pos_rtx == 0 && pos == 0 && ! in_dest\n+      && ! in_compare && ! spans_byte && unsignedp)\n     return 0;\n \n   /* Get the mode to use should INNER be a MEM, the mode for the position,\n@@ -4749,7 +4751,7 @@ make_extraction (mode, inner, pos, pos_rtx, len,\n #if BITS_BIG_ENDIAN\n   /* If position is constant, compute new position.  Otherwise, build\n      subtraction.  */\n-  if (pos >= 0)\n+  if (pos_rtx == 0)\n     pos = (MAX (GET_MODE_BITSIZE (is_mode), GET_MODE_BITSIZE (wanted_mem_mode))\n \t   - len - pos);\n   else\n@@ -4792,7 +4794,7 @@ make_extraction (mode, inner, pos, pos_rtx, len,\n #endif\n \n       /* If this is a constant position, we can move to the desired byte.  */\n-      if (pos >= 0)\n+      if (pos_rtx == 0)\n \t{\n \t  offset += pos / BITS_PER_UNIT;\n \t  pos %= GET_MODE_BITSIZE (wanted_mem_mode);\n@@ -4818,15 +4820,20 @@ make_extraction (mode, inner, pos, pos_rtx, len,\n \n   /* Adjust mode of POS_RTX, if needed.  If we want a wider mode, we\n      have to zero extend.  Otherwise, we can just use a SUBREG.  */\n-  if (pos < 0\n+  if (pos_rtx != 0\n       && GET_MODE_SIZE (pos_mode) > GET_MODE_SIZE (GET_MODE (pos_rtx)))\n     pos_rtx = gen_rtx_combine (ZERO_EXTEND, pos_mode, pos_rtx);\n-  else if (pos < 0\n+  else if (pos_rtx != 0\n \t   && GET_MODE_SIZE (pos_mode) < GET_MODE_SIZE (GET_MODE (pos_rtx)))\n     pos_rtx = gen_lowpart_for_combine (pos_mode, pos_rtx);\n \n-  /* Make POS_RTX unless we already have it and it is correct.  */\n-  if (pos_rtx == 0 || (pos >= 0 && INTVAL (pos_rtx) != pos))\n+  /* Make POS_RTX unless we already have it and it is correct.  If we don't\n+     have a POS_RTX but we do have an ORIG_POS_RTX, the latter must\n+     be a CONST_INT. */\n+  if (pos_rtx == 0 && orig_pos_rtx != 0 && INTVAL (orig_pos_rtx) == pos)\n+    pos_rtx = orig_pos_rtx;\n+\n+  else if (pos_rtx == 0)\n     pos_rtx = GEN_INT (pos);\n \n   /* Make the required operation.  See if we can use existing rtx.  */\n@@ -4905,7 +4912,7 @@ make_compound_operation (x, in_code)\n \t is a logical right shift, make an extraction.  */\n       if (GET_CODE (XEXP (x, 0)) == LSHIFTRT\n \t  && (i = exact_log2 (INTVAL (XEXP (x, 1)) + 1)) >= 0)\n-\tnew = make_extraction (mode, XEXP (XEXP (x, 0), 0), -1,\n+\tnew = make_extraction (mode, XEXP (XEXP (x, 0), 0), 0,\n \t\t\t       XEXP (XEXP (x, 0), 1), i, 1,\n \t\t\t       0, in_code == COMPARE);\n \n@@ -4915,7 +4922,7 @@ make_compound_operation (x, in_code)\n \t       && GET_CODE (SUBREG_REG (XEXP (x, 0))) == LSHIFTRT\n \t       && (i = exact_log2 (INTVAL (XEXP (x, 1)) + 1)) >= 0)\n \tnew = make_extraction (GET_MODE (SUBREG_REG (XEXP (x, 0))),\n-\t\t\t       XEXP (SUBREG_REG (XEXP (x, 0)), 0), -1,\n+\t\t\t       XEXP (SUBREG_REG (XEXP (x, 0)), 0), 0,\n \t\t\t       XEXP (SUBREG_REG (XEXP (x, 0)), 1), i, 1,\n \t\t\t       0, in_code == COMPARE);\n \n@@ -5425,7 +5432,7 @@ make_field_assignment (x)\n \t  || rtx_equal_p (dest, get_last_value (XEXP (src, 1)))\n \t  || rtx_equal_p (get_last_value (dest), XEXP (src, 1))))\n     {\n-      assign = make_extraction (VOIDmode, dest, -1, XEXP (XEXP (src, 0), 1),\n+      assign = make_extraction (VOIDmode, dest, 0, XEXP (XEXP (src, 0), 1),\n \t\t\t\t1, 1, 1, 0);\n       return gen_rtx (SET, VOIDmode, assign, const0_rtx);\n     }\n@@ -5440,7 +5447,7 @@ make_field_assignment (x)\n \t       || rtx_equal_p (dest, get_last_value (XEXP (src, 1)))\n \t       || rtx_equal_p (get_last_value (dest), XEXP (src, 1))))\n     {\n-      assign = make_extraction (VOIDmode, dest, -1,\n+      assign = make_extraction (VOIDmode, dest, 0,\n \t\t\t\tXEXP (SUBREG_REG (XEXP (src, 0)), 1),\n \t\t\t\t1, 1, 1, 0);\n       return gen_rtx (SET, VOIDmode, assign, const0_rtx);\n@@ -5454,7 +5461,7 @@ make_field_assignment (x)\n \t       || rtx_equal_p (dest, get_last_value (XEXP (src, 1)))\n \t       || rtx_equal_p (get_last_value (dest), XEXP (src, 1))))\n     {\n-      assign = make_extraction (VOIDmode, dest, -1, XEXP (XEXP (src, 0), 1),\n+      assign = make_extraction (VOIDmode, dest, 0, XEXP (XEXP (src, 0), 1),\n \t\t\t\t1, 1, 1, 0);\n       return gen_rtx (SET, VOIDmode, assign, const1_rtx);\n     }"}]}