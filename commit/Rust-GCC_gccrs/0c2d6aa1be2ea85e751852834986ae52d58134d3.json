{"sha": "0c2d6aa1be2ea85e751852834986ae52d58134d3", "node_id": "C_kwDOANBUbNoAKDBjMmQ2YWExYmUyZWE4NWU3NTE4NTI4MzQ5ODZhZTUyZDU4MTM0ZDM", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2022-08-26T07:56:19Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2022-08-26T07:56:19Z"}, "message": "fortran: Expand ieee_arithmetic module's ieee_value inline [PR106579]\n\nThe following patch expands IEEE_VALUE function inline in the FE.\n\n2022-08-26  Jakub Jelinek  <jakub@redhat.com>\n\n\tPR fortran/106579\n\t* trans-intrinsic.cc: Include realmpfr.h.\n\t(conv_intrinsic_ieee_value): New function.\n\t(gfc_conv_ieee_arithmetic_function): Handle ieee_value.", "tree": {"sha": "774022592c75730d5704577f03e17274a0f60859", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/774022592c75730d5704577f03e17274a0f60859"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0c2d6aa1be2ea85e751852834986ae52d58134d3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c2d6aa1be2ea85e751852834986ae52d58134d3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0c2d6aa1be2ea85e751852834986ae52d58134d3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c2d6aa1be2ea85e751852834986ae52d58134d3/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "db630423a97ec6690a8eb0e5c3cb186c91e3740d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/db630423a97ec6690a8eb0e5c3cb186c91e3740d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/db630423a97ec6690a8eb0e5c3cb186c91e3740d"}], "stats": {"total": 119, "additions": 119, "deletions": 0}, "files": [{"sha": "ec116fff26e42e2a041f49aade0ab47d636c0b9f", "filename": "gcc/fortran/trans-intrinsic.cc", "status": "modified", "additions": 119, "deletions": 0, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c2d6aa1be2ea85e751852834986ae52d58134d3/gcc%2Ffortran%2Ftrans-intrinsic.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c2d6aa1be2ea85e751852834986ae52d58134d3/gcc%2Ffortran%2Ftrans-intrinsic.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.cc?ref=0c2d6aa1be2ea85e751852834986ae52d58134d3", "patch": "@@ -41,6 +41,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"trans-array.h\"\n #include \"dependency.h\"\t/* For CAF array alias analysis.  */\n #include \"attribs.h\"\n+#include \"realmpfr.h\"\n \n /* Only for gfc_trans_assign and gfc_trans_pointer_assign.  */\n \n@@ -10090,6 +10091,122 @@ conv_intrinsic_ieee_class (gfc_se *se, gfc_expr *expr)\n }\n \n \n+/* Generate code for IEEE_VALUE.  */\n+\n+static void\n+conv_intrinsic_ieee_value (gfc_se *se, gfc_expr *expr)\n+{\n+  tree args[2], arg, ret, tmp;\n+  stmtblock_t body;\n+\n+  /* Convert args, evaluate the second one only once.  */\n+  conv_ieee_function_args (se, expr, args, 2);\n+  arg = gfc_evaluate_now (args[1], &se->pre);\n+\n+  tree type = TREE_TYPE (arg);\n+  /* Perform a quick sanity check that the second argument's type is\n+     IEEE_CLASS_TYPE derived type defined in\n+     libgfortran/ieee/ieee_arithmetic.F90\n+     Primarily check that it is a derived type with a single\n+     member in it.  */\n+  gcc_assert (TREE_CODE (type) == RECORD_TYPE);\n+  tree field = NULL_TREE;\n+  for (tree f = TYPE_FIELDS (type); f != NULL_TREE; f = DECL_CHAIN (f))\n+    if (TREE_CODE (f) == FIELD_DECL)\n+      {\n+\tgcc_assert (field == NULL_TREE);\n+\tfield = f;\n+      }\n+  gcc_assert (field);\n+  arg = fold_build3_loc (input_location, COMPONENT_REF, TREE_TYPE (field),\n+\t\t\t arg, field, NULL_TREE);\n+  arg = gfc_evaluate_now (arg, &se->pre);\n+\n+  type = gfc_typenode_for_spec (&expr->ts);\n+  gcc_assert (TREE_CODE (type) == REAL_TYPE);\n+  ret = gfc_create_var (type, NULL);\n+\n+  gfc_init_block (&body);\n+\n+  tree end_label = gfc_build_label_decl (NULL_TREE);\n+  for (int c = IEEE_SIGNALING_NAN; c <= IEEE_POSITIVE_INF; ++c)\n+    {\n+      tree label = gfc_build_label_decl (NULL_TREE);\n+      tree low = build_int_cst (TREE_TYPE (arg), c);\n+      tmp = build_case_label (low, low, label);\n+      gfc_add_expr_to_block (&body, tmp);\n+\n+      REAL_VALUE_TYPE real;\n+      int k;\n+      switch (c)\n+\t{\n+\tcase IEEE_SIGNALING_NAN:\n+\t  real_nan (&real, \"\", 0, TYPE_MODE (type));\n+\t  break;\n+\tcase IEEE_QUIET_NAN:\n+\t  real_nan (&real, \"\", 1, TYPE_MODE (type));\n+\t  break;\n+\tcase IEEE_NEGATIVE_INF:\n+\t  real_inf (&real);\n+\t  real = real_value_negate (&real);\n+\t  break;\n+\tcase IEEE_NEGATIVE_NORMAL:\n+\t  real_from_integer (&real, TYPE_MODE (type), -42, SIGNED);\n+\t  break;\n+\tcase IEEE_NEGATIVE_DENORMAL:\n+\t  k = gfc_validate_kind (BT_REAL, expr->ts.kind, false);\n+\t  real_from_mpfr (&real, gfc_real_kinds[k].tiny,\n+\t\t\t  type, GFC_RND_MODE);\n+\t  real_arithmetic (&real, RDIV_EXPR, &real, &dconst2);\n+\t  real = real_value_negate (&real);\n+\t  break;\n+\tcase IEEE_NEGATIVE_ZERO:\n+\t  real_from_integer (&real, TYPE_MODE (type), 0, SIGNED);\n+\t  real = real_value_negate (&real);\n+\t  break;\n+\tcase IEEE_POSITIVE_ZERO:\n+\t  /* Make this also the default: label.  The other possibility\n+\t     would be to add a separate default: label followed by\n+\t     __builtin_unreachable ().  */\n+\t  label = gfc_build_label_decl (NULL_TREE);\n+\t  tmp = build_case_label (NULL_TREE, NULL_TREE, label);\n+\t  gfc_add_expr_to_block (&body, tmp);\n+\t  real_from_integer (&real, TYPE_MODE (type), 0, SIGNED);\n+\t  break;\n+\tcase IEEE_POSITIVE_DENORMAL:\n+\t  k = gfc_validate_kind (BT_REAL, expr->ts.kind, false);\n+\t  real_from_mpfr (&real, gfc_real_kinds[k].tiny,\n+\t\t\t  type, GFC_RND_MODE);\n+\t  real_arithmetic (&real, RDIV_EXPR, &real, &dconst2);\n+\t  break;\n+\tcase IEEE_POSITIVE_NORMAL:\n+\t  real_from_integer (&real, TYPE_MODE (type), 42, SIGNED);\n+\t  break;\n+\tcase IEEE_POSITIVE_INF:\n+\t  real_inf (&real);\n+\t  break;\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+\n+      tree val = build_real (type, real);\n+      gfc_add_modify (&body, ret, val);\n+\n+      tmp = build1_v (GOTO_EXPR, end_label);\n+      gfc_add_expr_to_block (&body, tmp);\n+    }\n+\n+  tmp = gfc_finish_block (&body);\n+  tmp = fold_build2_loc (input_location, SWITCH_EXPR, NULL_TREE, arg, tmp);\n+  gfc_add_expr_to_block (&se->pre, tmp);\n+\n+  tmp = build1_v (LABEL_EXPR, end_label);\n+  gfc_add_expr_to_block (&se->pre, tmp);\n+\n+  se->expr = ret;\n+}\n+\n+\n /* Generate code for an intrinsic function from the IEEE_ARITHMETIC\n    module.  */\n \n@@ -10122,6 +10239,8 @@ gfc_conv_ieee_arithmetic_function (gfc_se * se, gfc_expr * expr)\n     conv_intrinsic_ieee_logb_rint (se, expr, BUILT_IN_RINT);\n   else if (startswith (name, \"ieee_class_\") && ISDIGIT (name[11]))\n     conv_intrinsic_ieee_class (se, expr);\n+  else if (startswith (name, \"ieee_value_\") && ISDIGIT (name[11]))\n+    conv_intrinsic_ieee_value (se, expr);\n   else\n     /* It is not among the functions we translate directly.  We return\n        false, so a library function call is emitted.  */"}]}