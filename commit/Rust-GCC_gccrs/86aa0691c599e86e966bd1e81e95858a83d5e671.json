{"sha": "86aa0691c599e86e966bd1e81e95858a83d5e671", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODZhYTA2OTFjNTk5ZTg2ZTk2NmJkMWU4MWU5NTg1OGE4M2Q1ZTY3MQ==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2018-01-03T18:22:28Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2018-01-03T18:22:28Z"}, "message": "re PR middle-end/83654 (-fstack-clash-protection probes below the stack pointer for VLA with constant size)\n\n\tPR middle-end/83654\n\t* explow.c (anti_adjust_stack_and_probe_stack_clash): Test a\n\tnon-constant residual for zero at runtime and avoid probing in\n\tthat case.  Reorganize code for trailing problem to mirror handling\n\tof the residual.\n\n\tPR middle-end/83654\n\t* gcc.target/i386/stack-check-18.c: New test.\n\t* gcc.target/i386/stack-check-19.c: New test.\n\nFrom-SVN: r256182", "tree": {"sha": "d956d13e907210786986b283e145f3e97ada7538", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d956d13e907210786986b283e145f3e97ada7538"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/86aa0691c599e86e966bd1e81e95858a83d5e671", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/86aa0691c599e86e966bd1e81e95858a83d5e671", "html_url": "https://github.com/Rust-GCC/gccrs/commit/86aa0691c599e86e966bd1e81e95858a83d5e671", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/86aa0691c599e86e966bd1e81e95858a83d5e671/comments", "author": null, "committer": null, "parents": [{"sha": "e95e79b628438a978b14c9a0740e0bb8072477e0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e95e79b628438a978b14c9a0740e0bb8072477e0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e95e79b628438a978b14c9a0740e0bb8072477e0"}], "stats": {"total": 108, "additions": 91, "deletions": 17}, "files": [{"sha": "f570eb4e606ae3300b49cf621a1bca6ce0fec351", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86aa0691c599e86e966bd1e81e95858a83d5e671/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86aa0691c599e86e966bd1e81e95858a83d5e671/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=86aa0691c599e86e966bd1e81e95858a83d5e671", "patch": "@@ -1,3 +1,11 @@\n+2017-01-03  Jeff Law  <law@redhat.com>\n+\n+\tPR middle-end/83654\n+\t* explow.c (anti_adjust_stack_and_probe_stack_clash): Test a\n+\tnon-constant residual for zero at runtime and avoid probing in\n+\tthat case.  Reorganize code for trailing problem to mirror handling\n+\tof the residual.\n+\n 2018-01-03  Prathamesh Kulkarni  <prathamesh.kulkarni@linaro.org>\n \n \tPR tree-optimization/83501"}, {"sha": "042e71904ec897f6f8c6964119d4318dfe51bcc4", "filename": "gcc/explow.c", "status": "modified", "additions": 25, "deletions": 17, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86aa0691c599e86e966bd1e81e95858a83d5e671/gcc%2Fexplow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86aa0691c599e86e966bd1e81e95858a83d5e671/gcc%2Fexplow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexplow.c?ref=86aa0691c599e86e966bd1e81e95858a83d5e671", "patch": "@@ -1997,11 +1997,27 @@ anti_adjust_stack_and_probe_stack_clash (rtx size)\n \n   if (residual != CONST0_RTX (Pmode))\n     {\n+      rtx label = NULL_RTX;\n+      /* RESIDUAL could be zero at runtime and in that case *sp could\n+\t hold live data.  Furthermore, we do not want to probe into the\n+\t red zone.\n+\n+\t Go ahead and just guard the probe at *sp on RESIDUAL != 0 at\n+\t runtime if RESIDUAL is not a compile time constant.  */\n+      if (!CONST_INT_P (residual))\n+\t{\n+\t  label = gen_label_rtx ();\n+\t  emit_cmp_and_jump_insns (residual, CONST0_RTX (GET_MODE (residual)),\n+\t\t\t\t   EQ, NULL_RTX, Pmode, 1, label);\n+\t}\n+\n       rtx x = force_reg (Pmode, plus_constant (Pmode, residual,\n \t\t\t\t\t       -GET_MODE_SIZE (word_mode)));\n       anti_adjust_stack (residual);\n       emit_stack_probe (gen_rtx_PLUS (Pmode, stack_pointer_rtx, x));\n       emit_insn (gen_blockage ());\n+      if (!CONST_INT_P (residual))\n+\temit_label (label);\n     }\n \n   /* Some targets make optimistic assumptions in their prologues about\n@@ -2014,28 +2030,20 @@ anti_adjust_stack_and_probe_stack_clash (rtx size)\n \t live data.  Furthermore, we don't want to probe into the red\n \t zone.\n \n-\t Go ahead and just guard a probe at *sp on SIZE != 0 at runtime\n+\t Go ahead and just guard the probe at *sp on SIZE != 0 at runtime\n \t if SIZE is not a compile time constant.  */\n-\n-      /* Ideally we would just probe at *sp.  However, if SIZE is not\n-\t a compile-time constant, but is zero at runtime, then *sp\n-\t might hold live data.  So probe at *sp if we know that\n-\t an allocation was made, otherwise probe into the red zone\n-\t which is obviously undesirable.  */\n-      if (CONST_INT_P (size))\n-\t{\n-\t  emit_stack_probe (stack_pointer_rtx);\n-\t  emit_insn (gen_blockage ());\n-\t}\n-      else\n+      rtx label = NULL_RTX;\n+      if (!CONST_INT_P (size))\n \t{\n-\t  rtx label = gen_label_rtx ();\n+\t  label = gen_label_rtx ();\n \t  emit_cmp_and_jump_insns (size, CONST0_RTX (GET_MODE (size)),\n \t\t\t\t   EQ, NULL_RTX, Pmode, 1, label);\n-\t  emit_stack_probe (stack_pointer_rtx);\n-\t  emit_insn (gen_blockage ());\n-\t  emit_label (label);\n \t}\n+\n+      emit_stack_probe (stack_pointer_rtx);\n+      emit_insn (gen_blockage ());\n+      if (!CONST_INT_P (size))\n+\temit_label (label);\n     }\n }\n "}, {"sha": "7777ee5e478440d91a295596734186b7b214ea0a", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86aa0691c599e86e966bd1e81e95858a83d5e671/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86aa0691c599e86e966bd1e81e95858a83d5e671/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=86aa0691c599e86e966bd1e81e95858a83d5e671", "patch": "@@ -1,3 +1,9 @@\n+2018-01-03  Jeff Law  <law@redhat.com>\n+\n+\tPR middle-end/83654\n+\t* gcc.target/i386/stack-check-18.c: New test.\n+\t* gcc.target/i386/stack-check-19.c: New test.\n+\n 2018-01-03  Martin Sebor  <msebor@redhat.com>\n \n \tPR tree-optimization/83501"}, {"sha": "6dbff4402da1288a1c3185d4367c471c79c2905b", "filename": "gcc/testsuite/gcc.target/i386/stack-check-18.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86aa0691c599e86e966bd1e81e95858a83d5e671/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fstack-check-18.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86aa0691c599e86e966bd1e81e95858a83d5e671/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fstack-check-18.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fstack-check-18.c?ref=86aa0691c599e86e966bd1e81e95858a83d5e671", "patch": "@@ -0,0 +1,23 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fstack-clash-protection -mtune=generic -fdump-rtl-expand\" } */\n+/* { dg-require-effective-target supports_stack_clash_protection } */\n+\n+int f1 (char *);\n+\n+int\n+f2 (void)\n+{\n+  const int size = 4096;\n+  char buffer[size];\n+  return f1 (buffer);\n+}\n+\n+/* So we want to verify that at expand time that we probed the main\n+   VLA allocation as well as the residuals.  Then we want to verify\n+   there was only one probe in the final assembly (implying the\n+   residual probe was optimized away).  */\n+/* { dg-final { scan-rtl-dump-times \"allocation and probing in loop\" 1 \"expand\" } } */\n+/* { dg-final { scan-rtl-dump-times \"allocation and probing residuals\" 1 \"expand\" } } */\n+\n+/* { dg-final { scan-assembler-times \"or\\[ql\\]\" 1 } } */\n+"}, {"sha": "b92c126d57f72ad147a72aff23fb6de8bd2fc8b9", "filename": "gcc/testsuite/gcc.target/i386/stack-check-19.c", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86aa0691c599e86e966bd1e81e95858a83d5e671/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fstack-check-19.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86aa0691c599e86e966bd1e81e95858a83d5e671/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fstack-check-19.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fstack-check-19.c?ref=86aa0691c599e86e966bd1e81e95858a83d5e671", "patch": "@@ -0,0 +1,29 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fstack-clash-protection -mtune=generic -fdump-rtl-expand\" } */\n+/* { dg-require-effective-target supports_stack_clash_protection } */\n+\n+int f1 (char *);\n+\n+int\n+f2 (const int size)\n+{\n+  char buffer[size];\n+  return f1 (buffer);\n+}\n+\n+/* So we want to verify that at expand time that we probed the main\n+   VLA allocation as well as the residuals.  Then we want to verify\n+   there are two probes in the final assembly code.  */\n+/* { dg-final { scan-rtl-dump-times \"allocation and probing in loop\" 1 \"expand\" } } */\n+/* { dg-final { scan-rtl-dump-times \"allocation and probing residuals\" 1 \"expand\" } } */\n+/* { dg-final { scan-assembler-times \"or\\[ql\\]\" 2 } } */\n+\n+/* We also want to verify (indirectly) that the residual probe is\n+   guarded.  We do that by checking the number of conditional\n+   branches.  There should be 3.  One that bypasses the probe loop, one\n+   in the probe loop and one that bypasses the residual probe.\n+\n+   These will all be equality tests.  */\n+/* { dg-final { scan-assembler-times \"(\\?:je|jne)\" 3 } } */\n+\n+"}]}