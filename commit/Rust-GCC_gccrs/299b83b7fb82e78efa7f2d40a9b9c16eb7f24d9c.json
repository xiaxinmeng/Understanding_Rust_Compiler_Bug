{"sha": "299b83b7fb82e78efa7f2d40a9b9c16eb7f24d9c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mjk5YjgzYjdmYjgyZTc4ZWZhN2YyZDQwYTliOWMxNmViN2YyNGQ5Yw==", "commit": {"author": {"name": "Kaveh R. Ghazi", "email": "ghazi@caip.rutgers.edu", "date": "2000-03-09T03:39:09Z"}, "committer": {"name": "Kaveh Ghazi", "email": "ghazi@gcc.gnu.org", "date": "2000-03-09T03:39:09Z"}, "message": "libgcc2.h: New file.\n\n\t* libgcc2.h: New file.\n\t* libgcc2.c: Move macros, typedefs and prototypes to libgcc2.h.\n\nFrom-SVN: r32440", "tree": {"sha": "5bb7b2df6145b5734256df854a9b244881ffa158", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5bb7b2df6145b5734256df854a9b244881ffa158"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/299b83b7fb82e78efa7f2d40a9b9c16eb7f24d9c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/299b83b7fb82e78efa7f2d40a9b9c16eb7f24d9c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/299b83b7fb82e78efa7f2d40a9b9c16eb7f24d9c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/299b83b7fb82e78efa7f2d40a9b9c16eb7f24d9c/comments", "author": null, "committer": null, "parents": [{"sha": "c65ebc55cab8f22f366038c7536b30c37d71837f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c65ebc55cab8f22f366038c7536b30c37d71837f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c65ebc55cab8f22f366038c7536b30c37d71837f"}], "stats": {"total": 499, "additions": 300, "deletions": 199}, "files": [{"sha": "0470a0b5714939ade0f7779240281c7a0d58ec92", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/299b83b7fb82e78efa7f2d40a9b9c16eb7f24d9c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/299b83b7fb82e78efa7f2d40a9b9c16eb7f24d9c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=299b83b7fb82e78efa7f2d40a9b9c16eb7f24d9c", "patch": "@@ -1,3 +1,8 @@\n+2000-03-08  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n+\n+\t* libgcc2.h: New file.\n+\t* libgcc2.c: Move macros, typedefs and prototypes to libgcc2.h.\n+\n Wed Mar  8 16:19:42 2000  Jim Wilson  <wilson@cygnus.com>\n \n \t* configure.in (ia64*-*-elf*, ia64*-*-linux*): New."}, {"sha": "e2a852c185afc89c394b972fd796273a1efae91f", "filename": "gcc/libgcc2.c", "status": "modified", "additions": 3, "deletions": 199, "changes": 202, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/299b83b7fb82e78efa7f2d40a9b9c16eb7f24d9c/gcc%2Flibgcc2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/299b83b7fb82e78efa7f2d40a9b9c16eb7f24d9c/gcc%2Flibgcc2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flibgcc2.c?ref=299b83b7fb82e78efa7f2d40a9b9c16eb7f24d9c", "patch": "@@ -49,182 +49,7 @@ Boston, MA 02111-1307, USA.  */\n #define inhibit_libc\n #endif\n \n-/* Permit the tm.h file to select the endianness to use just for this\n-   file.  This is used when the endianness is determined when the\n-   compiler is run.  */\n-\n-#ifndef LIBGCC2_WORDS_BIG_ENDIAN\n-#define LIBGCC2_WORDS_BIG_ENDIAN WORDS_BIG_ENDIAN\n-#endif\n-\n-#ifndef LIBGCC2_LONG_DOUBLE_TYPE_SIZE\n-#define LIBGCC2_LONG_DOUBLE_TYPE_SIZE LONG_DOUBLE_TYPE_SIZE\n-#endif\n-\n-/* In the first part of this file, we are interfacing to calls generated\n-   by the compiler itself.  These calls pass values into these routines\n-   which have very specific modes (rather than very specific types), and\n-   these compiler-generated calls also expect any return values to have\n-   very specific modes (rather than very specific types).  Thus, we need\n-   to avoid using regular C language type names in this part of the file\n-   because the sizes for those types can be configured to be anything.\n-   Instead we use the following special type names.  */\n-\n-typedef\t\t int QItype\t__attribute__ ((mode (QI)));\n-typedef unsigned int UQItype\t__attribute__ ((mode (QI)));\n-typedef\t\t int HItype\t__attribute__ ((mode (HI)));\n-typedef unsigned int UHItype\t__attribute__ ((mode (HI)));\n-#if UNITS_PER_WORD > 1\n-/* These typedefs are usually forbidden on dsp's with UNITS_PER_WORD 1 */\n-typedef \t int SItype\t__attribute__ ((mode (SI)));\n-typedef unsigned int USItype\t__attribute__ ((mode (SI)));\n-#if UNITS_PER_WORD > 2\n-/* These typedefs are usually forbidden on archs with UNITS_PER_WORD 2 */\n-typedef\t\t int DItype\t__attribute__ ((mode (DI)));\n-typedef unsigned int UDItype\t__attribute__ ((mode (DI)));\n-#endif\n-#endif\n-\n-#if BITS_PER_UNIT == 8\n-\n-typedef \tfloat SFtype\t__attribute__ ((mode (SF)));\n-typedef\t\tfloat DFtype\t__attribute__ ((mode (DF)));\n-\n-#if LIBGCC2_LONG_DOUBLE_TYPE_SIZE == 96\n-typedef\t\tfloat XFtype\t__attribute__ ((mode (XF)));\n-#endif\n-#if LIBGCC2_LONG_DOUBLE_TYPE_SIZE == 128\n-typedef\t\tfloat TFtype\t__attribute__ ((mode (TF)));\n-#endif\n-\n-#else /* BITS_PER_UNIT != 8 */\n-\n-/* On dsp's there are usually qf/hf/tqf modes used instead of the above.\n-   For now we don't support them in libgcc2.c.  */\n-\n-#undef L_fixdfdi\n-#undef L_fixsfdi\n-#undef L_fixtfdi\n-#undef L_fixunsdfdi\n-#undef L_fixunsdfsi\n-#undef L_fixunssfdi\n-#undef L_fixunssfsi\n-#undef L_fixunstfdi\n-#undef L_fixunsxfdi\n-#undef L_fixunsxfsi\n-#undef L_fixxfdi\n-#undef L_floatdidf\n-#undef L_floatdisf\n-#undef L_floatditf\n-#undef L_floatdixf\n-\n-#endif /* BITS_PER_UNIT != 8 */\n-\n-typedef int word_type __attribute__ ((mode (__word__)));\n-\n-/* Make sure that we don't accidentally use any normal C language built-in\n-   type names in the first part of this file.  Instead we want to use *only*\n-   the type names defined above.  The following macro definitions insure\n-   that if we *do* accidentally use some normal C language built-in type name,\n-   we will get a syntax error.  */\n-\n-#define char bogus_type\n-#define short bogus_type\n-#define int bogus_type\n-#define long bogus_type\n-#define unsigned bogus_type\n-#define float bogus_type\n-#define double bogus_type\n-\n-#if UNITS_PER_WORD > 2\n-#define W_TYPE_SIZE (4 * BITS_PER_UNIT)\n-#define Wtype\tSItype\n-#define UWtype\tUSItype\n-#define HWtype\tSItype\n-#define UHWtype\tUSItype\n-#define DWtype\tDItype\n-#define UDWtype\tUDItype\n-#define __NW(a,b)\t__ ## a ## si ## b\n-#define __NDW(a,b)\t__ ## a ## di ## b\n-#elif UNITS_PER_WORD > 1\n-#define W_TYPE_SIZE (2 * BITS_PER_UNIT)\n-#define Wtype\tHItype\n-#define UWtype\tUHItype\n-#define HWtype\tHItype\n-#define UHWtype\tUHItype\n-#define DWtype\tSItype\n-#define UDWtype\tUSItype\n-#define __NW(a,b)\t__ ## a ## hi ## b\n-#define __NDW(a,b)\t__ ## a ## si ## b\n-#else\n-#define W_TYPE_SIZE BITS_PER_UNIT\n-#define Wtype\tQItype\n-#define UWtype  UQItype\n-#define HWtype\tQItype\n-#define UHWtype\tUQItype\n-#define DWtype\tHItype\n-#define UDWtype\tUHItype\n-#define __NW(a,b)\t__ ## a ## qi ## b\n-#define __NDW(a,b)\t__ ## a ## hi ## b\n-#endif\n-\n-#define __muldi3\t__NDW(mul,3)\n-#define __divdi3\t__NDW(div,3)\n-#define __udivdi3\t__NDW(udiv,3)\n-#define __moddi3\t__NDW(mod,3)\n-#define __umoddi3\t__NDW(umod,3)\n-#define __negdi2\t__NDW(neg,2)\n-#define __lshrdi3\t__NDW(lshr,3)\n-#define __ashldi3\t__NDW(ashl,3)\n-#define __ashrdi3\t__NDW(ashr,3)\n-#define __ffsdi2\t__NDW(ffs,2)\n-#define __cmpdi2\t__NDW(cmp,2)\n-#define __ucmpdi2\t__NDW(ucmp,2)\n-#define __udivmoddi4\t__NDW(udivmod,4)\n-#define __fixunstfdi\t__NDW(fixunstf,)\n-#define __fixtfdi\t__NDW(fixtf,)\n-#define __fixunsxfdi\t__NDW(fixunsxf,)\n-#define __fixxfdi\t__NDW(fixxf,)\n-#define __fixunsdfdi\t__NDW(fixunsdf,)\n-#define __fixdfdi\t__NDW(fixdf,)\n-#define __fixunssfdi\t__NDW(fixunssf,)\n-#define __fixsfdi\t__NDW(fixsf,)\n-#define __floatdixf\t__NDW(float,xf)\n-#define __floatditf\t__NDW(float,tf)\n-#define __floatdidf\t__NDW(float,df)\n-#define __floatdisf\t__NDW(float,sf)\n-#define __fixunsxfsi\t__NW(fixunsxf,)\n-#define __fixunstfsi\t__NW(fixunstf,)\n-#define __fixunsdfsi\t__NW(fixunsdf,)\n-#define __fixunssfsi\t__NW(fixunssf,)\n-\n-/* DWstructs are pairs of Wtype values in the order determined by\n-   LIBGCC2_WORDS_BIG_ENDIAN.  */\n-\n-#if LIBGCC2_WORDS_BIG_ENDIAN\n-  struct DWstruct {Wtype high, low;};\n-#else\n-  struct DWstruct {Wtype low, high;};\n-#endif\n-\n-/* We need this union to unpack/pack DImode values, since we don't have\n-   any arithmetic yet.  Incoming DImode parameters are stored into the\n-   `ll' field, and the unpacked result is read from the struct `s'.  */\n-\n-typedef union\n-{\n-  struct DWstruct s;\n-  DWtype ll;\n-} DWunion;\n-\n-#if (defined (L_udivmoddi4) || defined (L_muldi3) || defined (L_udiv_w_sdiv)\\\n-     || defined (L_divdi3) || defined (L_udivdi3) \\\n-     || defined (L_moddi3) || defined (L_umoddi3))\n-\n-#include \"longlong.h\"\n-\n-#endif /* udiv or mul */\n-\n+#include \"libgcc2.h\"\n \f\n #if defined (L_negdi2) || defined (L_divdi3) || defined (L_moddi3)\n #if defined (L_divdi3) || defined (L_moddi3)\n@@ -871,8 +696,6 @@ __fixunstfdi (TFtype a)\n #endif\n \n #if defined(L_fixtfdi) && (LIBGCC2_LONG_DOUBLE_TYPE_SIZE == 128)\n-extern DWtype __fixunstfdi (TFtype a);\n-\n DWtype\n __fixtfdi (TFtype a)\n {\n@@ -915,8 +738,6 @@ __fixunsxfdi (XFtype a)\n #endif\n \n #if defined(L_fixxfdi) && (LIBGCC2_LONG_DOUBLE_TYPE_SIZE == 96)\n-extern DWtype __fixunsxfdi (XFtype a);\n-\n DWtype\n __fixxfdi (XFtype a)\n {\n@@ -959,8 +780,6 @@ __fixunsdfdi (DFtype a)\n #endif\n \n #ifdef L_fixdfdi\n-extern DWtype __fixunsdfdi (DFtype a);\n-\n DWtype\n __fixdfdi (DFtype a)\n {\n@@ -1007,8 +826,6 @@ __fixunssfdi (SFtype original_a)\n #endif\n \n #ifdef L_fixsfdi\n-extern DWtype __fixunssfdi (SFtype a);\n-\n DWtype\n __fixsfdi (SFtype a)\n {\n@@ -1239,7 +1056,7 @@ __fixunssfsi (SFtype a)\n    positive if S1 is greater, 0 if S1 and S2 are equal.  */\n \n int\n-__gcc_bcmp (unsigned char *s1, unsigned char *s2, size_t size)\n+__gcc_bcmp (const unsigned char *s1, const unsigned char *s2, size_t size)\n {\n   while (size > 0)\n     {\n@@ -1470,7 +1287,7 @@ asm (\"___builtin_saveregs:\");\n   asm (\"\t.end __builtin_saveregs\");\n #else /* not __mips__, etc.  */\n \n-void *\n+void * __attribute__ ((__noreturn__))\n __builtin_saveregs (void)\n {\n   abort ();\n@@ -1487,9 +1304,6 @@ __builtin_saveregs (void)\n #undef NULL /* Avoid errors if stdio.h and our stddef.h mismatch.  */\n #include <stdio.h>\n /* This is used by the `assert' macro.  */\n-extern void __eprintf (const char *, const char *, unsigned int, const char *)\n-  __attribute__ ((__noreturn__));\n-\n void\n __eprintf (const char *string, const char *expression,\n \t   unsigned int line, const char *filename)\n@@ -3166,8 +2980,6 @@ atexit (func_ptr func)\n \n /* Shared exception handling support routines.  */\n \n-extern void __default_terminate (void) __attribute__ ((__noreturn__));\n-\n void\n __default_terminate (void)\n {\n@@ -3210,8 +3022,6 @@ __empty (void)\n \n /* Allocate and return a new EH context structure. */\n \n-extern void __throw (void);\n-\n #if __GTHREADS\n static void *\n new_eh_context (void)\n@@ -3410,8 +3220,6 @@ __get_dynamic_handler_chain (void)\n    dynamic handler chain, and use longjmp to transfer back to the associated\n    handler.  */\n \n-extern void __sjthrow (void) __attribute__ ((__noreturn__));\n-\n void\n __sjthrow (void)\n {\n@@ -3485,8 +3293,6 @@ __sjthrow (void)\n    then throw.  This is used to skip the first handler, and transfer\n    control to the next handler in the dynamic handler stack.  */\n \n-extern void __sjpopnthrow (void) __attribute__ ((__noreturn__));\n-\n void\n __sjpopnthrow (void)\n {\n@@ -4153,8 +3959,6 @@ __rethrow (void *index)\n \n #define MESSAGE \"pure virtual method called\\n\"\n \n-extern void __terminate (void) __attribute__ ((__noreturn__));\n-\n void\n __pure_virtual (void)\n {"}, {"sha": "ca5b541b9723639d91525c12118c6dcd308cde6b", "filename": "gcc/libgcc2.h", "status": "added", "additions": 292, "deletions": 0, "changes": 292, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/299b83b7fb82e78efa7f2d40a9b9c16eb7f24d9c/gcc%2Flibgcc2.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/299b83b7fb82e78efa7f2d40a9b9c16eb7f24d9c/gcc%2Flibgcc2.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flibgcc2.h?ref=299b83b7fb82e78efa7f2d40a9b9c16eb7f24d9c", "patch": "@@ -0,0 +1,292 @@\n+/* Header file for libgcc2.c.  */\n+/* Copyright (C) 2000\n+   Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+/* As a special exception, if you link this library with other files,\n+   some of which are compiled with GCC, to produce an executable,\n+   this library does not by itself cause the resulting executable\n+   to be covered by the GNU General Public License.\n+   This exception does not however invalidate any other reasons why\n+   the executable file might be covered by the GNU General Public License.  */\n+\n+#ifndef __LIBGCC2_H__\n+#define __LIBGCC2_H__\n+\n+extern int __gcc_bcmp (const unsigned char *, const unsigned char *, size_t);\n+extern void *__builtin_saveregs (void);\n+extern void __dummy (void);\n+extern void __clear_cache (char *, char *);\n+extern void __pure_virtual (void) __attribute__ ((__noreturn__));\n+extern void __terminate (void) __attribute__ ((__noreturn__));\n+extern void __default_terminate (void) __attribute__ ((__noreturn__));\n+extern void *__throw_type_match (void *, void *, void *);\n+extern void __empty (void);\n+extern void *__get_eh_context (void);\n+extern void **__get_eh_info (void);\n+extern void ***__get_dynamic_handler_chain (void);\n+extern int __eh_rtime_match (void *);\n+extern void __unwinding_cleanup (void);\n+extern void __rethrow (void *);\n+extern void __throw (void);\n+extern void __sjthrow (void) __attribute__ ((__noreturn__));\n+extern void __sjpopnthrow (void) __attribute__ ((__noreturn__));\n+extern void __eprintf (const char *, const char *, unsigned int, const char *)\n+  __attribute__ ((__noreturn__));\n+\n+struct bb;\n+extern void __bb_exit_func (void);\n+extern void __bb_init_func (struct bb *);\n+extern void __bb_fork_func (void);\n+extern void __bb_trace_func (void);\n+extern void __bb_trace_ret (void);\n+extern void __bb_init_trace_func (struct bb *, unsigned long);\n+\n+struct exception_descriptor;\n+extern short int __get_eh_table_language (struct exception_descriptor *);\n+extern short int __get_eh_table_version (struct exception_descriptor *);\n+\n+/* Permit the tm.h file to select the endianness to use just for this\n+   file.  This is used when the endianness is determined when the\n+   compiler is run.  */\n+\n+#ifndef LIBGCC2_WORDS_BIG_ENDIAN\n+#define LIBGCC2_WORDS_BIG_ENDIAN WORDS_BIG_ENDIAN\n+#endif\n+\n+#ifndef LIBGCC2_LONG_DOUBLE_TYPE_SIZE\n+#define LIBGCC2_LONG_DOUBLE_TYPE_SIZE LONG_DOUBLE_TYPE_SIZE\n+#endif\n+\n+/* In the first part of this file, we are interfacing to calls generated\n+   by the compiler itself.  These calls pass values into these routines\n+   which have very specific modes (rather than very specific types), and\n+   these compiler-generated calls also expect any return values to have\n+   very specific modes (rather than very specific types).  Thus, we need\n+   to avoid using regular C language type names in this part of the file\n+   because the sizes for those types can be configured to be anything.\n+   Instead we use the following special type names.  */\n+\n+typedef\t\t int QItype\t__attribute__ ((mode (QI)));\n+typedef unsigned int UQItype\t__attribute__ ((mode (QI)));\n+typedef\t\t int HItype\t__attribute__ ((mode (HI)));\n+typedef unsigned int UHItype\t__attribute__ ((mode (HI)));\n+#if UNITS_PER_WORD > 1\n+/* These typedefs are usually forbidden on dsp's with UNITS_PER_WORD 1 */\n+typedef \t int SItype\t__attribute__ ((mode (SI)));\n+typedef unsigned int USItype\t__attribute__ ((mode (SI)));\n+#if UNITS_PER_WORD > 2\n+/* These typedefs are usually forbidden on archs with UNITS_PER_WORD 2 */\n+typedef\t\t int DItype\t__attribute__ ((mode (DI)));\n+typedef unsigned int UDItype\t__attribute__ ((mode (DI)));\n+#endif\n+#endif\n+\n+#if BITS_PER_UNIT == 8\n+\n+typedef \tfloat SFtype\t__attribute__ ((mode (SF)));\n+typedef\t\tfloat DFtype\t__attribute__ ((mode (DF)));\n+\n+#if LIBGCC2_LONG_DOUBLE_TYPE_SIZE == 96\n+typedef\t\tfloat XFtype\t__attribute__ ((mode (XF)));\n+#endif\n+#if LIBGCC2_LONG_DOUBLE_TYPE_SIZE == 128\n+typedef\t\tfloat TFtype\t__attribute__ ((mode (TF)));\n+#endif\n+\n+#else /* BITS_PER_UNIT != 8 */\n+\n+/* On dsp's there are usually qf/hf/tqf modes used instead of the above.\n+   For now we don't support them in libgcc2.c.  */\n+\n+#undef L_fixdfdi\n+#undef L_fixsfdi\n+#undef L_fixtfdi\n+#undef L_fixunsdfdi\n+#undef L_fixunsdfsi\n+#undef L_fixunssfdi\n+#undef L_fixunssfsi\n+#undef L_fixunstfdi\n+#undef L_fixunsxfdi\n+#undef L_fixunsxfsi\n+#undef L_fixxfdi\n+#undef L_floatdidf\n+#undef L_floatdisf\n+#undef L_floatditf\n+#undef L_floatdixf\n+\n+#endif /* BITS_PER_UNIT != 8 */\n+\n+typedef int word_type __attribute__ ((mode (__word__)));\n+\n+/* Make sure that we don't accidentally use any normal C language built-in\n+   type names in the first part of this file.  Instead we want to use *only*\n+   the type names defined above.  The following macro definitions insure\n+   that if we *do* accidentally use some normal C language built-in type name,\n+   we will get a syntax error.  */\n+\n+#define char bogus_type\n+#define short bogus_type\n+#define int bogus_type\n+#define long bogus_type\n+#define unsigned bogus_type\n+#define float bogus_type\n+#define double bogus_type\n+\n+#if UNITS_PER_WORD > 2\n+#define W_TYPE_SIZE (4 * BITS_PER_UNIT)\n+#define Wtype\tSItype\n+#define UWtype\tUSItype\n+#define HWtype\tSItype\n+#define UHWtype\tUSItype\n+#define DWtype\tDItype\n+#define UDWtype\tUDItype\n+#define __NW(a,b)\t__ ## a ## si ## b\n+#define __NDW(a,b)\t__ ## a ## di ## b\n+#elif UNITS_PER_WORD > 1\n+#define W_TYPE_SIZE (2 * BITS_PER_UNIT)\n+#define Wtype\tHItype\n+#define UWtype\tUHItype\n+#define HWtype\tHItype\n+#define UHWtype\tUHItype\n+#define DWtype\tSItype\n+#define UDWtype\tUSItype\n+#define __NW(a,b)\t__ ## a ## hi ## b\n+#define __NDW(a,b)\t__ ## a ## si ## b\n+#else\n+#define W_TYPE_SIZE BITS_PER_UNIT\n+#define Wtype\tQItype\n+#define UWtype  UQItype\n+#define HWtype\tQItype\n+#define UHWtype\tUQItype\n+#define DWtype\tHItype\n+#define UDWtype\tUHItype\n+#define __NW(a,b)\t__ ## a ## qi ## b\n+#define __NDW(a,b)\t__ ## a ## hi ## b\n+#endif\n+\n+#define __muldi3\t__NDW(mul,3)\n+#define __divdi3\t__NDW(div,3)\n+#define __udivdi3\t__NDW(udiv,3)\n+#define __moddi3\t__NDW(mod,3)\n+#define __umoddi3\t__NDW(umod,3)\n+#define __negdi2\t__NDW(neg,2)\n+#define __lshrdi3\t__NDW(lshr,3)\n+#define __ashldi3\t__NDW(ashl,3)\n+#define __ashrdi3\t__NDW(ashr,3)\n+#define __ffsdi2\t__NDW(ffs,2)\n+#define __cmpdi2\t__NDW(cmp,2)\n+#define __ucmpdi2\t__NDW(ucmp,2)\n+#define __udivmoddi4\t__NDW(udivmod,4)\n+#define __fixunstfdi\t__NDW(fixunstf,)\n+#define __fixtfdi\t__NDW(fixtf,)\n+#define __fixunsxfdi\t__NDW(fixunsxf,)\n+#define __fixxfdi\t__NDW(fixxf,)\n+#define __fixunsdfdi\t__NDW(fixunsdf,)\n+#define __fixdfdi\t__NDW(fixdf,)\n+#define __fixunssfdi\t__NDW(fixunssf,)\n+#define __fixsfdi\t__NDW(fixsf,)\n+#define __floatdixf\t__NDW(float,xf)\n+#define __floatditf\t__NDW(float,tf)\n+#define __floatdidf\t__NDW(float,df)\n+#define __floatdisf\t__NDW(float,sf)\n+#define __fixunsxfsi\t__NW(fixunsxf,)\n+#define __fixunstfsi\t__NW(fixunstf,)\n+#define __fixunsdfsi\t__NW(fixunsdf,)\n+#define __fixunssfsi\t__NW(fixunssf,)\n+\n+/* DWstructs are pairs of Wtype values in the order determined by\n+   LIBGCC2_WORDS_BIG_ENDIAN.  */\n+\n+#if LIBGCC2_WORDS_BIG_ENDIAN\n+  struct DWstruct {Wtype high, low;};\n+#else\n+  struct DWstruct {Wtype low, high;};\n+#endif\n+\n+/* We need this union to unpack/pack DImode values, since we don't have\n+   any arithmetic yet.  Incoming DImode parameters are stored into the\n+   `ll' field, and the unpacked result is read from the struct `s'.  */\n+\n+typedef union\n+{\n+  struct DWstruct s;\n+  DWtype ll;\n+} DWunion;\n+\n+#if (defined (L_udivmoddi4) || defined (L_muldi3) || defined (L_udiv_w_sdiv)\\\n+     || defined (L_divdi3) || defined (L_udivdi3) \\\n+     || defined (L_moddi3) || defined (L_umoddi3))\n+\n+#include \"longlong.h\"\n+\n+#endif /* udiv or mul */\n+\n+extern DWtype __muldi3 (DWtype, DWtype);\n+extern DWtype __divdi3 (DWtype, DWtype);\n+extern UDWtype __udivdi3 (UDWtype, UDWtype);\n+extern UDWtype __umoddi3 (UDWtype, UDWtype);\n+extern DWtype __moddi3 (DWtype, DWtype);\n+/* __udivmoddi4 is static inline when building other libgcc2 portions.  */\n+#if (!defined (L_udivdi3) && !defined (L_divdi3) && \\\n+     !defined (L_umoddi3) && !defined (L_moddi3))\n+extern UDWtype __udivmoddi4 (UDWtype, UDWtype, UDWtype *);\n+#endif\n+\n+/* __negdi2 is static inline when building other libgcc2 portions.  */\n+#if !defined(L_divdi3) && !defined(L_moddi3)\n+extern DWtype __negdi2 (DWtype);\n+#endif\n+\n+extern DWtype __lshrdi3 (DWtype, word_type);\n+extern DWtype __ashldi3 (DWtype, word_type);\n+extern DWtype __ashrdi3 (DWtype, word_type);\n+extern DWtype __ffsdi2 (DWtype);\n+\n+/* __udiv_w_sdiv is static inline when building other libgcc2 portions.  */\n+#if (!defined(L_udivdi3) && !defined(L_divdi3) && \\\n+     !defined(L_umoddi3) && !defined(L_moddi3))\n+extern UWtype __udiv_w_sdiv (UWtype *, UWtype, UWtype, UWtype);\n+#endif\n+\n+extern word_type __cmpdi2 (DWtype, DWtype);\n+extern word_type __ucmpdi2 (DWtype, DWtype);\n+extern DFtype __floatdidf (DWtype);\n+extern SFtype __floatdisf (DWtype);\n+extern UWtype __fixunsdfsi (DFtype);\n+extern UWtype __fixunssfsi (SFtype);\n+extern DWtype __fixunsdfdi (DFtype);\n+extern DWtype __fixdfdi (DFtype);\n+extern DWtype __fixunssfdi (SFtype);\n+extern DWtype __fixsfdi (SFtype);\n+\n+#if LIBGCC2_LONG_DOUBLE_TYPE_SIZE == 96\n+extern DWtype __fixxfdi (XFtype);\n+extern DWtype __fixunsxfdi (XFtype);\n+extern XFtype __floatdixf (DWtype);\n+extern UWtype __fixunsxfsi (XFtype);\n+#endif\n+\n+#if LIBGCC2_LONG_DOUBLE_TYPE_SIZE == 128\n+extern DWtype __fixunstfdi (TFtype);\n+extern DWtype __fixtfdi (TFtype);\n+extern TFtype __floatditf (DWtype);\n+#endif\n+\n+#endif /* __LIBGCC2_H__ */"}]}