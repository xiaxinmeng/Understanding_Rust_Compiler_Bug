{"sha": "939d7216dca76eac6675e54f10154ad5d2898cfa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTM5ZDcyMTZkY2E3NmVhYzY2NzVlNTRmMTAxNTRhZDVkMjg5OGNmYQ==", "commit": {"author": {"name": "Per Bothner", "email": "bothner@gcc.gnu.org", "date": "1999-02-21T15:42:27Z"}, "committer": {"name": "Per Bothner", "email": "bothner@gcc.gnu.org", "date": "1999-02-21T15:42:27Z"}, "message": "decl.c (build_result_decl):  New method.\n\nd\n\t* decl.c (build_result_decl), java-tree.h:  New method.\n\t(complete_start_java_method):  Handle synchronized methods.\n\tDon't build DECL_RESULT here.  (Ordering dependency problem.)\n\t(start_java_method):  Call build_result_decl here instead  ...\n\t* parse.y (java_complete_expand_method):  ... and here.\n\t(expand_start_java_method): Don't call complete_start_java_method here.\n\t(java_complete_expand_method):  Call it here instead.\n\t* parse.h (BUILD_MONITOR_ENTER, BUILD_MONITOR_EXIT):  Moved to ..\n\t* java-tree.h:  ... here.\n\t* expr.c (force_evaluation_order):  Fix typo, don't handle ARRAY_REF.\n\t* parse.y (java_complete_lhs):  Don't call force_evaluation_order\n\tfor ARRAY_REF - it doesn't work when array bounds are checked.\n\t(patch_array_ref):  Handle it here instead.\n\nFrom-SVN: r25346", "tree": {"sha": "bc94f54b074dc8162b8ed7adee22a07f1784413d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bc94f54b074dc8162b8ed7adee22a07f1784413d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/939d7216dca76eac6675e54f10154ad5d2898cfa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/939d7216dca76eac6675e54f10154ad5d2898cfa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/939d7216dca76eac6675e54f10154ad5d2898cfa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/939d7216dca76eac6675e54f10154ad5d2898cfa/comments", "author": null, "committer": null, "parents": [{"sha": "2d5a51939f53e104020ac07784f5f2087aa06275", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2d5a51939f53e104020ac07784f5f2087aa06275", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2d5a51939f53e104020ac07784f5f2087aa06275"}], "stats": {"total": 186, "additions": 128, "deletions": 58}, "files": [{"sha": "14b8ece1367dff126ab956c25ef80538a76d9ed0", "filename": "gcc/java/decl.c", "status": "modified", "additions": 29, "deletions": 5, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/939d7216dca76eac6675e54f10154ad5d2898cfa/gcc%2Fjava%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/939d7216dca76eac6675e54f10154ad5d2898cfa/gcc%2Fjava%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fdecl.c?ref=939d7216dca76eac6675e54f10154ad5d2898cfa", "patch": "@@ -1465,17 +1465,22 @@ give_name_to_locals (jcf)\n     }\n }\n \n-void\n-complete_start_java_method (fndecl)\n+tree\n+build_result_decl (fndecl)\n   tree fndecl;\n {\n   tree restype = TREE_TYPE (TREE_TYPE (fndecl));\n   /* To be compatible with C_PROMOTING_INTEGER_TYPE_P in cc1/cc1plus. */\n   if (INTEGRAL_TYPE_P (restype)\n       && TYPE_PRECISION (restype) < TYPE_PRECISION (integer_type_node))\n     restype = integer_type_node;\n-  DECL_RESULT (fndecl) = build_decl (RESULT_DECL, NULL_TREE, restype);\n+  return (DECL_RESULT (fndecl) = build_decl (RESULT_DECL, NULL_TREE, restype));\n+}\n \n+void\n+complete_start_java_method (fndecl)\n+  tree fndecl;\n+{\n   if (! flag_emit_class_files)\n     {\n       /* Initialize the RTL code for the function.  */\n@@ -1509,9 +1514,27 @@ complete_start_java_method (fndecl)\n       expand_expr_stmt (init);\n     }\n \n-  if (METHOD_SYNCHRONIZED (fndecl))\n+  if (METHOD_SYNCHRONIZED (fndecl) && ! flag_emit_class_files\n+      && DECL_FUNCTION_BODY (fndecl) != NULL_TREE)\n     {\n-      /* FIXME: surround the function body by a try/finally set.  */\n+      /* Warp function body with a monitorenter plus monitorexit cleanup. */\n+      tree function_body = DECL_FUNCTION_BODY (fndecl);\n+      tree body = BLOCK_EXPR_BODY (function_body);\n+      tree enter, exit, lock;\n+      if (METHOD_STATIC (fndecl))\n+\tlock = build_class_ref (DECL_CONTEXT (fndecl));\n+      else\n+\tlock = DECL_ARGUMENTS (fndecl);\n+      BUILD_MONITOR_ENTER (enter, lock);\n+      BUILD_MONITOR_EXIT (exit, lock);\n+      lock = build (WITH_CLEANUP_EXPR, void_type_node,\n+\t\t    enter,  NULL_TREE, exit);\n+      TREE_SIDE_EFFECTS (lock) = 1;\n+      lock = build (COMPOUND_EXPR, TREE_TYPE (body), lock, body);\n+      TREE_SIDE_EFFECTS (lock) = 1;\n+      lock = build1 (CLEANUP_POINT_EXPR, TREE_TYPE (body), lock);\n+      TREE_SIDE_EFFECTS (lock) = 1;\n+      BLOCK_EXPR_BODY (function_body) = lock;\n     }\n \n   /* Push local variables. Function compiled from source code are\n@@ -1578,6 +1601,7 @@ start_java_method (fndecl)\n   while (i < DECL_MAX_LOCALS(fndecl))\n     type_map[i++] = NULL_TREE;\n \n+  build_result_decl (fndecl);\n   complete_start_java_method (fndecl);\n }\n "}, {"sha": "7e2e26cbd69d086a6c658ddc446a64e34766add4", "filename": "gcc/java/expr.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/939d7216dca76eac6675e54f10154ad5d2898cfa/gcc%2Fjava%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/939d7216dca76eac6675e54f10154ad5d2898cfa/gcc%2Fjava%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fexpr.c?ref=939d7216dca76eac6675e54f10154ad5d2898cfa", "patch": "@@ -2492,8 +2492,7 @@ force_evaluation_order (node)\n {\n   if (flag_syntax_only)\n     return node;\n-  if (TREE_CODE_CLASS (TREE_CODE (node)) == '2'\n-      && TREE_CODE (node) == ARRAY_REF)\n+  if (TREE_CODE_CLASS (TREE_CODE (node)) == '2')\n     {\n       if (TREE_SIDE_EFFECTS (TREE_OPERAND (node, 1)))\n \tTREE_OPERAND (node, 0) = save_expr (TREE_OPERAND (node, 0));"}, {"sha": "28cba1c7104b22c14dff82548926a1c2b96a809e", "filename": "gcc/java/java-tree.h", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/939d7216dca76eac6675e54f10154ad5d2898cfa/gcc%2Fjava%2Fjava-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/939d7216dca76eac6675e54f10154ad5d2898cfa/gcc%2Fjava%2Fjava-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjava-tree.h?ref=939d7216dca76eac6675e54f10154ad5d2898cfa", "patch": "@@ -552,6 +552,7 @@ extern int get_access_flags_from_decl PROTO ((tree));\n extern int interface_of_p PROTO ((tree, tree));\n extern int inherits_from_p PROTO ((tree, tree));\n extern void complete_start_java_method PROTO ((tree));\n+extern tree build_result_decl PROTO ((tree));\n extern void emit_handlers PROTO (());\n extern void init_outgoing_cpool PROTO (());\n extern void make_class_data PROTO ((tree));\n@@ -861,6 +862,24 @@ extern tree *type_map;\n #define BLOCK_EXPR_DECLS(NODE)  BLOCK_VARS(NODE)\n #define BLOCK_EXPR_BODY(NODE)   BLOCK_SUBBLOCKS(NODE)\n \n+#define BUILD_MONITOR_ENTER(WHERE, ARG)\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\\\n+    (WHERE) = build (CALL_EXPR, int_type_node,\t\t\t\\\n+\t\t     build_address_of (soft_monitorenter_node),\t\\\n+\t\t     build_tree_list (NULL_TREE, (ARG)), \t\\\n+\t\t     NULL_TREE);\t\t\t\t\\\n+    TREE_SIDE_EFFECTS (WHERE) = 1;\t\t\t\t\\\n+  }\n+\n+#define BUILD_MONITOR_EXIT(WHERE, ARG)\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\\\n+    (WHERE) = build (CALL_EXPR, int_type_node,\t\t\t\\\n+\t\t     build_address_of (soft_monitorexit_node),\t\\\n+\t\t     build_tree_list (NULL_TREE, (ARG)),\t\\\n+\t\t     NULL_TREE);\t\t\t\t\\\n+    TREE_SIDE_EFFECTS (WHERE) = 1;\t\t\t\t\\\n+  }\n+\n /* Non zero if TYPE is an unchecked exception */\n #define IS_UNCHECKED_EXCEPTION_P(TYPE)\t\t\t\t\\\n   (inherits_from_p ((TYPE), runtime_exception_type_node)\t\\"}, {"sha": "13744dfcfc99f41a76f50c4a8bfe4b57c0096310", "filename": "gcc/java/parse.c", "status": "modified", "additions": 65, "deletions": 30, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/939d7216dca76eac6675e54f10154ad5d2898cfa/gcc%2Fjava%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/939d7216dca76eac6675e54f10154ad5d2898cfa/gcc%2Fjava%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.c?ref=939d7216dca76eac6675e54f10154ad5d2898cfa", "patch": "@@ -8066,7 +8066,6 @@ expand_start_java_method (fndecl)\n   *ptr = NULL_TREE;\n   pushdecl_force_head (DECL_ARGUMENTS (fndecl));\n   lineno = DECL_SOURCE_LINE_FIRST (fndecl);\n-  complete_start_java_method (fndecl); \n }\n \n /* Terminate a function and expand its body.  */\n@@ -8333,6 +8332,7 @@ java_complete_expand_method (mdecl)\n       tree fbody = DECL_FUNCTION_BODY (mdecl);\n       tree block_body = BLOCK_EXPR_BODY (fbody);\n       expand_start_java_method (mdecl);\n+      build_result_decl (mdecl);\n \n       current_this \n \t= (!METHOD_STATIC (mdecl) ? \n@@ -8355,6 +8355,8 @@ java_complete_expand_method (mdecl)\n \t  && TREE_CODE (TREE_TYPE (TREE_TYPE (mdecl))) != VOID_TYPE)\n \tmissing_return_error (current_function_decl);\n \n+      complete_start_java_method (mdecl); \n+\n       /* Don't go any further if we've found error(s) during the\n          expansion */\n       if (!java_error_count)\n@@ -9052,15 +9054,18 @@ resolve_qualified_expression_name (wfl, found_decl, where_found, type_found)\n \t\t  return 1;\n \t\t}\n \t      \n-\t      if (!(field_decl = \n-\t\t    lookup_field_wrapper (type, EXPR_WFL_NODE (qual_wfl))))\n+\t      field_decl = lookup_field_wrapper (type,\n+\t\t\t\t\t\t EXPR_WFL_NODE (qual_wfl));\n+\t      if (field_decl == NULL_TREE)\n \t\t{\n \t\t  parse_error_context \n \t\t    (qual_wfl, \"No variable `%s' defined in class `%s'\",\n \t\t     IDENTIFIER_POINTER (EXPR_WFL_NODE (qual_wfl)), \n \t\t     IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (type))));\n \t\t  return 1;\n \t\t}\n+\t      if (field_decl == error_mark_node)\n+\t\treturn 1;\n \n \t      /* Layout the type of field_decl, since we may need\n                  it. Don't do primitive types or loaded classes. The\n@@ -10178,7 +10183,8 @@ java_complete_lhs (node)\n \t  /* Now do the actual complete, without deep recursion for\n              long blocks. */\n \t  ptr = &BLOCK_EXPR_BODY (node);\n-\t  while (TREE_CODE (*ptr) == COMPOUND_EXPR)\n+\t  while (TREE_CODE (*ptr) == COMPOUND_EXPR\n+\t\t && TREE_OPERAND (*ptr, 1) != empty_stmt_node)\n \t    {\n \t      tree cur = java_complete_tree (TREE_OPERAND (*ptr, 0));\n \t      tree *next = &TREE_OPERAND (*ptr, 1);\n@@ -10198,8 +10204,7 @@ java_complete_lhs (node)\n \t\t\tbreak;\n \t\t    }\n \t\t  if (TREE_CODE (wfl_op2) != CASE_EXPR\n-\t\t      && TREE_CODE (wfl_op2) != DEFAULT_EXPR\n-\t\t      && wfl_op2 != empty_stmt_node)\n+\t\t      && TREE_CODE (wfl_op2) != DEFAULT_EXPR)\n \t\t    unreachable_stmt_error (*ptr);\n \t\t}\n \t      ptr = next;\n@@ -10389,26 +10394,30 @@ java_complete_lhs (node)\n       wfl_op2 = TREE_OPERAND (node, 1);\n       TREE_OPERAND (node, 0) = nn = \n \tjava_complete_tree (TREE_OPERAND (node, 0));\n-      if (! CAN_COMPLETE_NORMALLY (nn) && TREE_CODE (nn) != ERROR_MARK\n-\t  && wfl_op2 != empty_stmt_node)\n-\t{\n-\t  /* An unreachable condition in a do-while statement\n-\t     is *not* (technically) an unreachable statement. */\n-\t  nn = wfl_op2;\n-\t  if (TREE_CODE (nn) == EXPR_WITH_FILE_LOCATION)\n-\t    nn = EXPR_WFL_NODE (nn);\n-\t  if (TREE_CODE (nn) != EXIT_EXPR)\n+      if (wfl_op2 == empty_stmt_node)\n+\tCAN_COMPLETE_NORMALLY (node) = CAN_COMPLETE_NORMALLY (nn);\n+      else\n+\t{\n+\t  if (! CAN_COMPLETE_NORMALLY (nn) && TREE_CODE (nn) != ERROR_MARK)\n \t    {\n-\t      SET_WFL_OPERATOR (wfl_operator, node, wfl_op2);\n-\t      parse_error_context (wfl_operator, \"Unreachable statement\");\n+\t      /* An unreachable condition in a do-while statement\n+\t\t is *not* (technically) an unreachable statement. */\n+\t      nn = wfl_op2;\n+\t      if (TREE_CODE (nn) == EXPR_WITH_FILE_LOCATION)\n+\t\tnn = EXPR_WFL_NODE (nn);\n+\t      if (TREE_CODE (nn) != EXIT_EXPR)\n+\t\t{\n+\t\t  SET_WFL_OPERATOR (wfl_operator, node, wfl_op2);\n+\t\t  parse_error_context (wfl_operator, \"Unreachable statement\");\n+\t\t}\n \t    }\n+\t  TREE_OPERAND (node, 1) = java_complete_tree (TREE_OPERAND (node, 1));\n+\t  if (TREE_OPERAND (node, 1) == error_mark_node)\n+\t    return error_mark_node;\n+\t  CAN_COMPLETE_NORMALLY (node)\n+\t    = CAN_COMPLETE_NORMALLY (TREE_OPERAND (node, 1));\n \t}\n-      TREE_OPERAND (node, 1) = java_complete_tree (TREE_OPERAND (node, 1));\n-      if (TREE_OPERAND (node, 1) == error_mark_node)\n-\treturn error_mark_node;\n       TREE_TYPE (node) = TREE_TYPE (TREE_OPERAND (node, 1));\n-      CAN_COMPLETE_NORMALLY (node)\n-\t= CAN_COMPLETE_NORMALLY (TREE_OPERAND (node, 1));\n       break;\n \n     case RETURN_EXPR:\n@@ -10420,6 +10429,8 @@ java_complete_lhs (node)\n \t  || TREE_CODE (EXPR_WFL_NODE (node)) == IDENTIFIER_NODE)\n \t{\n \t  node = resolve_expression_name (node, NULL);\n+\t  if (node == error_mark_node)\n+\t    return node;\n \t  CAN_COMPLETE_NORMALLY (node) = 1;\n \t}\n       else\n@@ -10430,9 +10441,9 @@ java_complete_lhs (node)\n \t  body = java_complete_tree (EXPR_WFL_NODE (node));\n \t  lineno = save_lineno;\n \t  EXPR_WFL_NODE (node) = body;\n-\t  TREE_SIDE_EFFECTS (node) = 1;\n+\t  TREE_SIDE_EFFECTS (node) = TREE_SIDE_EFFECTS (body);\n \t  CAN_COMPLETE_NORMALLY (node) = CAN_COMPLETE_NORMALLY (body);\n-\t  if (EXPR_WFL_NODE (node) == error_mark_node)\n+\t  if (body == error_mark_node)\n \t    {\n \t      /* Its important for the evaluation of assignment that\n \t\t this mark on the TREE_TYPE is propagated. */\n@@ -10494,7 +10505,7 @@ java_complete_lhs (node)\n \t      tree_cons (wfl, decl, \n \t\t\t DECL_CONSTRUCTOR_CALLS (current_function_decl));\n \t  CAN_COMPLETE_NORMALLY (node) = 1;\n-\t  return node;\n+\t  return force_evaluation_order (node);\n \t}\n \n     case MODIFY_EXPR:\n@@ -10603,7 +10614,7 @@ java_complete_lhs (node)\n \t  if (TREE_OPERAND (node, 1) == error_mark_node)\n \t    return error_mark_node;\n \t}\n-      return patch_binop (node, wfl_op1, wfl_op2);\n+      return force_evaluation_order (patch_binop (node, wfl_op1, wfl_op2));\n \n     case INSTANCEOF_EXPR:\n       wfl_op1 = TREE_OPERAND (node, 0);\n@@ -11573,6 +11584,8 @@ patch_binop (node, wfl_op1, wfl_op2)\n \t{\n \t  tree mod = build_java_binop (TRUNC_MOD_EXPR, prom_type, op1, op2);\n \t  COMPOUND_ASSIGN_P (mod) = COMPOUND_ASSIGN_P (node);\n+\t  TREE_SIDE_EFFECTS (mod)\n+\t    = TREE_SIDE_EFFECTS (op1) | TREE_SIDE_EFFECTS (op2);\n \t  return mod;\n \t}\n       break;\n@@ -11659,6 +11672,8 @@ patch_binop (node, wfl_op1, wfl_op2)\n \t  to_return = convert (prom_type, node);\n \t  /* Copy the original value of the COMPOUND_ASSIGN_P flag */\n \t  COMPOUND_ASSIGN_P (to_return) = COMPOUND_ASSIGN_P (node);\n+\t  TREE_SIDE_EFFECTS (to_return)\n+\t    = TREE_SIDE_EFFECTS (op1) | TREE_SIDE_EFFECTS (op2);\n \t  return to_return;\n \t}\n       break;\n@@ -11693,6 +11708,7 @@ patch_binop (node, wfl_op1, wfl_op2)\n \t  else if (flag_emit_class_files)\n \t    {\n \t      TREE_OPERAND (node, 1) = op2_type;\n+\t      TREE_SIDE_EFFECTS (node) = TREE_SIDE_EFFECTS (op1);\n \t      return node;\n \t    }\n \t  /* Otherwise we have to invoke instance of to figure it out */\n@@ -11706,7 +11722,7 @@ patch_binop (node, wfl_op1, wfl_op2)\n \t\t\tbuild_tree_list (NULL_TREE,\n \t\t\t\t\t build_class_ref (op2_type))),\n \t\t       NULL_TREE);\n-\t      TREE_SIDE_EFFECTS (call) = 1;\n+\t      TREE_SIDE_EFFECTS (call) = TREE_SIDE_EFFECTS (op1);\n \t      return call;\n \t    }\n \t}\n@@ -11843,6 +11859,8 @@ patch_binop (node, wfl_op1, wfl_op2)\n   TREE_OPERAND (node, 0) = op1;\n   TREE_OPERAND (node, 1) = op2;\n   TREE_TYPE (node) = prom_type;\n+  TREE_SIDE_EFFECTS (node) = TREE_SIDE_EFFECTS (op1) | TREE_SIDE_EFFECTS (op2);\n+  \n   return fold (node);\n }\n \n@@ -11962,6 +11980,8 @@ build_string_concatenation (op1, op2)\n      tree op1, op2;\n {\n   tree result;\n+  int side_effects = TREE_SIDE_EFFECTS (op1) | TREE_SIDE_EFFECTS (op2);\n+\n   \n   /* Try to do some static optimization */\n   if ((result = string_constant_concatenation (op1, op2)))\n@@ -12014,7 +12034,8 @@ build_string_concatenation (op1, op2)\n \n   /* Mark the last node holding a crafted StringBuffer */\n   IS_CRAFTED_STRING_BUFFER_P (op1) = 1;\n-  \n+\n+  TREE_SIDE_EFFECTS (op1) = side_effects;\n   return op1;\n }\n \n@@ -12264,7 +12285,11 @@ patch_unaryop (node, wfl_op)\n \t  error_found = 1;\n \t}\n       else\n-\treturn fold (value);\n+\t{\n+\t  value = fold (value);\n+\t  TREE_SIDE_EFFECTS (value) = TREE_SIDE_EFFECTS (op);\n+\t  return value;\n+\t}\n       break;\n     }\n   \n@@ -12276,6 +12301,7 @@ patch_unaryop (node, wfl_op)\n      CONVERT_EXPR, {POST,PRE}{INCR,DECR}EMENT_EXPR. */\n   TREE_OPERAND (node, 0) = fold (op);\n   TREE_TYPE (node) = prom_type;\n+  TREE_SIDE_EFFECTS (node) = TREE_SIDE_EFFECTS (op);\n   return fold (node);\n }\n \n@@ -12464,7 +12490,16 @@ patch_array_ref (node)\n       TREE_OPERAND (node, 1) = index;\n     }\n   else\n-    node = build_java_arrayaccess (array, array_type, index);\n+    {\n+      /* The save_expr is for correct evaluation order.  It would be cleaner\n+\t to use force_evaluation_order (see comment there), but that is\n+\t difficult when we also have to deal with bounds checking. */\n+      if (TREE_SIDE_EFFECTS (index))\n+\tarray = save_expr (array);\n+      node = build_java_arrayaccess (array, array_type, index);\n+      if (TREE_SIDE_EFFECTS (index))\n+\tnode = build (COMPOUND_EXPR, array_type, array, node);\n+    }\n   TREE_TYPE (node) = array_type;\n   return node;\n }"}, {"sha": "fa6b338ebd6d704c984793df5b3b14b417b2d883", "filename": "gcc/java/parse.h", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/939d7216dca76eac6675e54f10154ad5d2898cfa/gcc%2Fjava%2Fparse.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/939d7216dca76eac6675e54f10154ad5d2898cfa/gcc%2Fjava%2Fparse.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.h?ref=939d7216dca76eac6675e54f10154ad5d2898cfa", "patch": "@@ -509,24 +509,6 @@ static jdeplist *reverse_jdep_list ();\n \t\t\t(ARG ? build_tree_list (NULL, (ARG)) : NULL_TREE))\n \n /* For exception handling, build diverse function calls */\n-#define BUILD_MONITOR_ENTER(WHERE, ARG)\t\t\t\t\\\n-  {\t\t\t\t\t\t\t\t\\\n-    (WHERE) = build (CALL_EXPR, int_type_node,\t\t\t\\\n-\t\t     build_address_of (soft_monitorenter_node),\t\\\n-\t\t     build_tree_list (NULL_TREE, (ARG)), \t\\\n-\t\t     NULL_TREE);\t\t\t\t\\\n-    TREE_SIDE_EFFECTS (WHERE) = 1;\t\t\t\t\\\n-  }\n-\n-#define BUILD_MONITOR_EXIT(WHERE, ARG)\t\t\t\t\\\n-  {\t\t\t\t\t\t\t\t\\\n-    (WHERE) = build (CALL_EXPR, int_type_node,\t\t\t\\\n-\t\t     build_address_of (soft_monitorexit_node),\t\\\n-\t\t     build_tree_list (NULL_TREE, (ARG)),\t\\\n-\t\t     NULL_TREE);\t\t\t\t\\\n-    TREE_SIDE_EFFECTS (WHERE) = 1;\t\t\t\t\\\n-  }\n-\n #define BUILD_ASSIGN_EXCEPTION_INFO(WHERE, TO)\t\t\\\n   {\t\t\t\t\t\t\t\\\n     (WHERE) = build (MODIFY_EXPR, void_type_node, (TO),\t\\"}, {"sha": "8964e450fdab284c9c17eeff701f1c34c997abdb", "filename": "gcc/java/parse.y", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/939d7216dca76eac6675e54f10154ad5d2898cfa/gcc%2Fjava%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/939d7216dca76eac6675e54f10154ad5d2898cfa/gcc%2Fjava%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.y?ref=939d7216dca76eac6675e54f10154ad5d2898cfa", "patch": "@@ -5464,7 +5464,6 @@ expand_start_java_method (fndecl)\n   *ptr = NULL_TREE;\n   pushdecl_force_head (DECL_ARGUMENTS (fndecl));\n   lineno = DECL_SOURCE_LINE_FIRST (fndecl);\n-  complete_start_java_method (fndecl); \n }\n \n /* Terminate a function and expand its body.  */\n@@ -5731,6 +5730,7 @@ java_complete_expand_method (mdecl)\n       tree fbody = DECL_FUNCTION_BODY (mdecl);\n       tree block_body = BLOCK_EXPR_BODY (fbody);\n       expand_start_java_method (mdecl);\n+      build_result_decl (mdecl);\n \n       current_this \n \t= (!METHOD_STATIC (mdecl) ? \n@@ -5753,6 +5753,8 @@ java_complete_expand_method (mdecl)\n \t  && TREE_CODE (TREE_TYPE (TREE_TYPE (mdecl))) != VOID_TYPE)\n \tmissing_return_error (current_function_decl);\n \n+      complete_start_java_method (mdecl); \n+\n       /* Don't go any further if we've found error(s) during the\n          expansion */\n       if (!java_error_count)\n@@ -8053,7 +8055,7 @@ java_complete_lhs (node)\n \treturn error_mark_node;\n       if (!flag_emit_class_files)\n \tTREE_OPERAND (node, 1) = save_expr (TREE_OPERAND (node, 1));\n-      return force_evaluation_order (patch_array_ref (node));\n+      return patch_array_ref (node);\n \n     case RECORD_TYPE:\n       return node;;\n@@ -9886,7 +9888,16 @@ patch_array_ref (node)\n       TREE_OPERAND (node, 1) = index;\n     }\n   else\n-    node = build_java_arrayaccess (array, array_type, index);\n+    {\n+      /* The save_expr is for correct evaluation order.  It would be cleaner\n+\t to use force_evaluation_order (see comment there), but that is\n+\t difficult when we also have to deal with bounds checking. */\n+      if (TREE_SIDE_EFFECTS (index))\n+\tarray = save_expr (array);\n+      node = build_java_arrayaccess (array, array_type, index);\n+      if (TREE_SIDE_EFFECTS (index))\n+\tnode = build (COMPOUND_EXPR, array_type, array, node);\n+    }\n   TREE_TYPE (node) = array_type;\n   return node;\n }"}]}