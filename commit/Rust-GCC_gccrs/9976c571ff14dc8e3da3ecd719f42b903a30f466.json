{"sha": "9976c571ff14dc8e3da3ecd719f42b903a30f466", "node_id": "C_kwDOANBUbNoAKDk5NzZjNTcxZmYxNGRjOGUzZGEzZWNkNzE5ZjQyYjkwM2EzMGY0NjY", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2022-06-29T13:39:05Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-06-29T13:39:05Z"}, "message": "Merge #1338\n\n1338: gccrs const folding port: continue porting potential_constant_expression_1() r=philberty a=abbasfaisal\n\nCard: [Link](https://github.com/Rust-GCC/gccrs/projects/16#card-82300805).\r\n\r\nTarget function: [Link](https://github.com/Rust-GCC/gccrs/blob/master/gcc/cp/constexpr.cc#L8350)\r\n\r\nFollowing functions are ported in this changeset:\r\n - [maybe_constexpr_fn](https://github.com/Rust-GCC/gccrs/blob/master/gcc/cp/constexpr.cc#L5495)\r\n - [get_nth_callarg](https://github.com/Rust-GCC/gccrs/blob/master/gcc/cp/constexpr.cc#L1333)\r\n - [var_in_maybe_constexpr_fn](https://github.com/Rust-GCC/gccrs/blob/master/gcc/cp/constexpr.cc#L5507)\r\n - [array_type_nelts_top](https://github.com/Rust-GCC/gccrs/blob/master/gcc/cp/tree.cc#L3055)\r\n - [builtin_valid_in_constant_expr_p](https://github.com/Rust-GCC/gccrs/blob/master/gcc/cp/tree.cc#L445)\r\n - [decl_maybe_constant_var_p](https://github.com/Rust-GCC/gccrs/blob/master/gcc/cp/decl2.cc#L4623)\r\n - [cp_type_quals](https://github.com/Rust-GCC/gccrs/blob/master/gcc/cp/typeck.cc#L10946)\n\nCo-authored-by: Faisal Abbas <90.abbasfaisal@gmail.com>", "tree": {"sha": "96b3ba272723dfc1074c8f513abd2fddd0910999", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/96b3ba272723dfc1074c8f513abd2fddd0910999"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9976c571ff14dc8e3da3ecd719f42b903a30f466", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJivFX5CRBK7hj4Ov3rIwAA1hEIAF8VpwftqwGDv8fL+TGwnzKr\nOljO9tzJ237JVFnzR2+QQhy/7lbvPtCUMwwNVJHSNGbs8ph/64FO7BnJ1qBpS2LL\nmZDIFbaUFOT1luchkUJJlIw3qeTmwbDf2yX0vDJ45611wA1EPlSTrqg2WZxfKV3I\nLygxGxI2i+FGAzyO4Cw4aC8mLCuKAd70/x13S4c3fzTDCwyWcDtkDJaDO+wBGZwi\n0BUZPMRcwUKbvhUBI4EECD6jXh8QBjwNDLfry0lT0fHd5j2+WzvK6THZp7wDc+xd\n+p+LAtabePvjrc7BtaT1DgPhTwmoNIqsMzyyETC9V79xizDh7b16D3R204TwQjw=\n=Lq12\n-----END PGP SIGNATURE-----\n", "payload": "tree 96b3ba272723dfc1074c8f513abd2fddd0910999\nparent c88cc0aa644836c361ce5d8ff5225a9c12333dea\nparent 2a7a0589f62ab9157d9f862ec2fd7d680c53c5f3\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1656509945 +0000\ncommitter GitHub <noreply@github.com> 1656509945 +0000\n\nMerge #1338\n\n1338: gccrs const folding port: continue porting potential_constant_expression_1() r=philberty a=abbasfaisal\n\nCard: [Link](https://github.com/Rust-GCC/gccrs/projects/16#card-82300805).\r\n\r\nTarget function: [Link](https://github.com/Rust-GCC/gccrs/blob/master/gcc/cp/constexpr.cc#L8350)\r\n\r\nFollowing functions are ported in this changeset:\r\n - [maybe_constexpr_fn](https://github.com/Rust-GCC/gccrs/blob/master/gcc/cp/constexpr.cc#L5495)\r\n - [get_nth_callarg](https://github.com/Rust-GCC/gccrs/blob/master/gcc/cp/constexpr.cc#L1333)\r\n - [var_in_maybe_constexpr_fn](https://github.com/Rust-GCC/gccrs/blob/master/gcc/cp/constexpr.cc#L5507)\r\n - [array_type_nelts_top](https://github.com/Rust-GCC/gccrs/blob/master/gcc/cp/tree.cc#L3055)\r\n - [builtin_valid_in_constant_expr_p](https://github.com/Rust-GCC/gccrs/blob/master/gcc/cp/tree.cc#L445)\r\n - [decl_maybe_constant_var_p](https://github.com/Rust-GCC/gccrs/blob/master/gcc/cp/decl2.cc#L4623)\r\n - [cp_type_quals](https://github.com/Rust-GCC/gccrs/blob/master/gcc/cp/typeck.cc#L10946)\n\nCo-authored-by: Faisal Abbas <90.abbasfaisal@gmail.com>\n"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9976c571ff14dc8e3da3ecd719f42b903a30f466", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9976c571ff14dc8e3da3ecd719f42b903a30f466", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9976c571ff14dc8e3da3ecd719f42b903a30f466/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c88cc0aa644836c361ce5d8ff5225a9c12333dea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c88cc0aa644836c361ce5d8ff5225a9c12333dea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c88cc0aa644836c361ce5d8ff5225a9c12333dea"}, {"sha": "2a7a0589f62ab9157d9f862ec2fd7d680c53c5f3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a7a0589f62ab9157d9f862ec2fd7d680c53c5f3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2a7a0589f62ab9157d9f862ec2fd7d680c53c5f3"}], "stats": {"total": 226, "additions": 219, "deletions": 7}, "files": [{"sha": "53c6ef6a6681c4fc0f50d81961962cea7255f32e", "filename": "gcc/rust/backend/rust-constexpr.cc", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9976c571ff14dc8e3da3ecd719f42b903a30f466/gcc%2Frust%2Fbackend%2Frust-constexpr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9976c571ff14dc8e3da3ecd719f42b903a30f466/gcc%2Frust%2Fbackend%2Frust-constexpr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-constexpr.cc?ref=9976c571ff14dc8e3da3ecd719f42b903a30f466", "patch": "@@ -397,5 +397,45 @@ get_function_named_in_call (tree t)\n   return fun;\n }\n \n+// forked from gcc/cp/constexpr.cc maybe_constexpr_fn\n+\n+/* True if a function might be declared constexpr  */\n+\n+bool\n+maybe_constexpr_fn (tree t)\n+{\n+  return (DECL_DECLARED_CONSTEXPR_P (t));\n+}\n+\n+// forked from gcc/cp/constexpr.cc get_nth_callarg\n+\n+/* We have an expression tree T that represents a call, either CALL_EXPR.\n+  Return the Nth argument.  */\n+\n+inline tree\n+get_nth_callarg (tree t, int n)\n+{\n+  switch (TREE_CODE (t))\n+    {\n+    case CALL_EXPR:\n+      return CALL_EXPR_ARG (t, n);\n+\n+    default:\n+      gcc_unreachable ();\n+      return NULL;\n+    }\n+}\n+\n+// forked from gcc/cp/constexpr.cc var_in_maybe_constexpr_fn\n+\n+/* True if T was declared in a function that might be constexpr: either a\n+   function that was declared constexpr.  */\n+\n+bool\n+var_in_maybe_constexpr_fn (tree t)\n+{\n+  return (DECL_FUNCTION_SCOPE_P (t) && maybe_constexpr_fn (DECL_CONTEXT (t)));\n+}\n+\n } // namespace Compile\n } // namespace Rust"}, {"sha": "3d71e19fe82c0fff1000d103401b50bbf77405a3", "filename": "gcc/rust/backend/rust-tree.cc", "status": "modified", "additions": 109, "deletions": 2, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9976c571ff14dc8e3da3ecd719f42b903a30f466/gcc%2Frust%2Fbackend%2Frust-tree.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9976c571ff14dc8e3da3ecd719f42b903a30f466/gcc%2Frust%2Fbackend%2Frust-tree.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-tree.cc?ref=9976c571ff14dc8e3da3ecd719f42b903a30f466", "patch": "@@ -766,7 +766,7 @@ rs_walk_subtrees (tree *tp, int *walk_subtrees_p, walk_tree_fn func, void *data,\n    locations.  */\n \n location_t\n-cp_expr_location (const_tree t_)\n+rs_expr_location (const_tree t_)\n {\n   tree t = CONST_CAST_TREE (t_);\n   if (t == NULL_TREE)\n@@ -775,7 +775,7 @@ cp_expr_location (const_tree t_)\n   return EXPR_LOCATION (t);\n }\n \n-// forked from gcc/cp/class.cc\n+// forked from gcc/cp/class.cc is_really_empty_class\n \n /* Returns true if TYPE contains no actual data, just various\n    possible combinations of empty classes.  If IGNORE_VPTR is true,\n@@ -848,4 +848,111 @@ array_type_nelts_top (tree type)\n \t\t\t  array_type_nelts (type), size_one_node);\n }\n \n+// forked from gcc/cp/tree.cc builtin_valid_in_constant_expr_p\n+\n+/* Test whether DECL is a builtin that may appear in a\n+   constant-expression. */\n+\n+bool\n+builtin_valid_in_constant_expr_p (const_tree decl)\n+{\n+  STRIP_ANY_LOCATION_WRAPPER (decl);\n+  if (TREE_CODE (decl) != FUNCTION_DECL)\n+    /* Not a function.  */\n+    return false;\n+  if (DECL_BUILT_IN_CLASS (decl) != BUILT_IN_NORMAL)\n+    {\n+      if (fndecl_built_in_p (decl, BUILT_IN_FRONTEND))\n+\tswitch (DECL_FE_FUNCTION_CODE (decl))\n+\t  {\n+\t  case RS_BUILT_IN_IS_CONSTANT_EVALUATED:\n+\t  case RS_BUILT_IN_SOURCE_LOCATION:\n+\t  case RS_BUILT_IN_IS_CORRESPONDING_MEMBER:\n+\t  case RS_BUILT_IN_IS_POINTER_INTERCONVERTIBLE_WITH_CLASS:\n+\t    return true;\n+\t  default:\n+\t    break;\n+\t  }\n+      /* Not a built-in.  */\n+      return false;\n+    }\n+  switch (DECL_FUNCTION_CODE (decl))\n+    {\n+      /* These always have constant results like the corresponding\n+\t macros/symbol.  */\n+    case BUILT_IN_FILE:\n+    case BUILT_IN_FUNCTION:\n+    case BUILT_IN_LINE:\n+\n+      /* The following built-ins are valid in constant expressions\n+\t when their arguments are.  */\n+    case BUILT_IN_ADD_OVERFLOW_P:\n+    case BUILT_IN_SUB_OVERFLOW_P:\n+    case BUILT_IN_MUL_OVERFLOW_P:\n+\n+      /* These have constant results even if their operands are\n+\t non-constant.  */\n+    case BUILT_IN_CONSTANT_P:\n+    case BUILT_IN_ATOMIC_ALWAYS_LOCK_FREE:\n+      return true;\n+    default:\n+      return false;\n+    }\n+}\n+\n+// forked from gcc/cp/decl2.cc decl_maybe_constant_var_p\n+\n+/* Returns true if DECL could be a symbolic constant variable, depending on\n+   its initializer.  */\n+\n+bool\n+decl_maybe_constant_var_p (tree decl)\n+{\n+  tree type = TREE_TYPE (decl);\n+  if (!VAR_P (decl))\n+    return false;\n+  if (DECL_DECLARED_CONSTEXPR_P (decl))\n+    return true;\n+  if (DECL_HAS_VALUE_EXPR_P (decl))\n+    /* A proxy isn't constant.  */\n+    return false;\n+  if (TYPE_REF_P (type))\n+    /* References can be constant.  */;\n+  else if (RS_TYPE_CONST_NON_VOLATILE_P (type)\n+\t   && INTEGRAL_OR_ENUMERATION_TYPE_P (type))\n+    /* And const integers.  */;\n+  else\n+    return false;\n+\n+  if (DECL_INITIAL (decl) && !DECL_INITIALIZED_BY_CONSTANT_EXPRESSION_P (decl))\n+    /* We know the initializer, and it isn't constant.  */\n+    return false;\n+  else\n+    return true;\n+}\n+\n+// forked from gcc/cp/typeck.cc cp_type_quals\n+\n+/* Returns the type qualifiers for this type, including the qualifiers on the\n+   elements for an array type.  */\n+\n+int\n+rs_type_quals (const_tree type)\n+{\n+  int quals;\n+  /* This CONST_CAST is okay because strip_array_types returns its\n+     argument unmodified and we assign it to a const_tree.  */\n+  type = strip_array_types (CONST_CAST_TREE (type));\n+  if (type == error_mark_node\n+      /* Quals on a FUNCTION_TYPE are memfn quals.  */\n+      || TREE_CODE (type) == FUNCTION_TYPE)\n+    return TYPE_UNQUALIFIED;\n+  quals = TYPE_QUALS (type);\n+  /* METHOD and REFERENCE_TYPEs should never have quals.  */\n+  gcc_assert (\n+    (TREE_CODE (type) != METHOD_TYPE && !TYPE_REF_P (type))\n+    || ((quals & (TYPE_QUAL_CONST | TYPE_QUAL_VOLATILE)) == TYPE_UNQUALIFIED));\n+  return quals;\n+}\n+\n } // namespace Rust"}, {"sha": "a667cbfc8ad5dc66856810515aaea3f6e96c6b7e", "filename": "gcc/rust/backend/rust-tree.h", "status": "modified", "additions": 70, "deletions": 5, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9976c571ff14dc8e3da3ecd719f42b903a30f466/gcc%2Frust%2Fbackend%2Frust-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9976c571ff14dc8e3da3ecd719f42b903a30f466/gcc%2Frust%2Fbackend%2Frust-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-tree.h?ref=9976c571ff14dc8e3da3ecd719f42b903a30f466", "patch": "@@ -149,6 +149,13 @@\n /* Nonzero if this class is \"empty\" in the sense of the C++ ABI.  */\n #define CLASSTYPE_EMPTY_P(NODE) (LANG_TYPE_CLASS_CHECK (NODE)->empty_p)\n \n+/* True if DECL is declared 'constexpr'.  */\n+#define DECL_DECLARED_CONSTEXPR_P(DECL)                                        \\\n+  DECL_LANG_FLAG_8 (VAR_OR_FUNCTION_DECL_CHECK (DECL))\n+\n+#define VAR_OR_FUNCTION_DECL_CHECK(NODE)                                       \\\n+  TREE_CHECK2 (NODE, VAR_DECL, FUNCTION_DECL)\n+\n // Below macros are copied from gcc/c-family/c-common.h\n \n /* In a FIELD_DECL, nonzero if the decl was originally a bitfield.  */\n@@ -162,6 +169,39 @@\n #define DECL_UNNAMED_BIT_FIELD(NODE)                                           \\\n   (DECL_C_BIT_FIELD (NODE) && !DECL_NAME (NODE))\n \n+/* 1 iff NODE is function-local.  */\n+#define DECL_FUNCTION_SCOPE_P(NODE)                                            \\\n+  (DECL_CONTEXT (NODE) && TREE_CODE (DECL_CONTEXT (NODE)) == FUNCTION_DECL)\n+\n+/* Nonzero if this type is const-qualified, but not\n+   volatile-qualified.  Other qualifiers are ignored.  This macro is\n+   used to test whether or not it is OK to bind an rvalue to a\n+   reference.  */\n+#define RS_TYPE_CONST_NON_VOLATILE_P(NODE)                                     \\\n+  ((rs_type_quals (NODE) & (TYPE_QUAL_CONST | TYPE_QUAL_VOLATILE))             \\\n+   == TYPE_QUAL_CONST)\n+\n+/* [basic.fundamental]\n+\n+   Types  bool, char, wchar_t, and the signed and unsigned integer types\n+   are collectively called integral types.\n+\n+   Note that INTEGRAL_TYPE_P, as defined in tree.h, allows enumeration\n+   types as well, which is incorrect in C++.  Keep these checks in\n+   ascending code order.  */\n+#define RS_INTEGRAL_TYPE_P(TYPE)                                               \\\n+  (TREE_CODE (TYPE) == BOOLEAN_TYPE || TREE_CODE (TYPE) == INTEGER_TYPE)\n+\n+/* Returns true if TYPE is an integral or enumeration name.  Keep\n+   these checks in ascending code order.  */\n+#define INTEGRAL_OR_ENUMERATION_TYPE_P(TYPE)                                   \\\n+  (TREE_CODE (TYPE) == ENUMERAL_TYPE || RS_INTEGRAL_TYPE_P (TYPE))\n+\n+/* Nonzero for a VAR_DECL that was initialized with a\n+   constant-expression.  */\n+#define DECL_INITIALIZED_BY_CONSTANT_EXPRESSION_P(NODE)                        \\\n+  (TREE_LANG_FLAG_2 (VAR_DECL_CHECK (NODE)))\n+\n // Above macros are copied from gcc/c-family/c-common.h\n \n // forked from gcc/cp/cp-tree.h treee_pair_s\n@@ -324,6 +364,17 @@ enum impl_conv_void\n   ICV_THIRD_IN_FOR    /* for increment expression */\n };\n \n+/* BUILT_IN_FRONTEND function codes.  */\n+enum rs_built_in_function\n+{\n+  RS_BUILT_IN_IS_CONSTANT_EVALUATED,\n+  RS_BUILT_IN_INTEGER_PACK,\n+  RS_BUILT_IN_IS_CORRESPONDING_MEMBER,\n+  RS_BUILT_IN_IS_POINTER_INTERCONVERTIBLE_WITH_CLASS,\n+  RS_BUILT_IN_SOURCE_LOCATION,\n+  RS_BUILT_IN_LAST\n+};\n+\n extern tree\n convert_to_void (tree expr, impl_conv_void implicit);\n \n@@ -405,13 +456,27 @@ pointer_offset_expression (tree base_tree, tree index_tree, location_t locus);\n    but not all node kinds do (e.g. constants, and references to\n    params, locals, etc), so we stash a copy here.  */\n \n-extern location_t cp_expr_location (const_tree);\n+extern location_t rs_expr_location (const_tree);\n \n extern int\n is_empty_class (tree type);\n \n extern tree array_type_nelts_top (tree);\n \n+extern bool\n+is_really_empty_class (tree, bool);\n+\n+extern bool builtin_valid_in_constant_expr_p (const_tree);\n+\n+extern bool maybe_constexpr_fn (tree);\n+\n+extern bool var_in_maybe_constexpr_fn (tree);\n+\n+extern int\n+rs_type_quals (const_tree type);\n+\n+extern bool decl_maybe_constant_var_p (tree);\n+\n extern tree\n rs_walk_subtrees (tree *, int *, walk_tree_fn, void *, hash_set<tree> *);\n #define rs_walk_tree(tp, func, data, pset)                                     \\\n@@ -422,9 +487,9 @@ rs_walk_subtrees (tree *, int *, walk_tree_fn, void *, hash_set<tree> *);\n // forked from gcc/cp/cp-tree.h cp_expr_loc_or_loc\n \n inline location_t\n-cp_expr_loc_or_loc (const_tree t, location_t or_loc)\n+rs_expr_loc_or_loc (const_tree t, location_t or_loc)\n {\n-  location_t loc = cp_expr_location (t);\n+  location_t loc = rs_expr_location (t);\n   if (loc == UNKNOWN_LOCATION)\n     loc = or_loc;\n   return loc;\n@@ -433,9 +498,9 @@ cp_expr_loc_or_loc (const_tree t, location_t or_loc)\n // forked from gcc/cp/cp-tree.h cp_expr_loc_or_input_loc\n \n inline location_t\n-cp_expr_loc_or_input_loc (const_tree t)\n+rs_expr_loc_or_input_loc (const_tree t)\n {\n-  return cp_expr_loc_or_loc (t, input_location);\n+  return rs_expr_loc_or_loc (t, input_location);\n }\n \n } // namespace Rust"}]}