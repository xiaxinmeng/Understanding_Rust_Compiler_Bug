{"sha": "540d86108f31f56f513f542b910b909dd4d6df09", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTQwZDg2MTA4ZjMxZjU2ZjUxM2Y1NDJiOTEwYjkwOWRkNGQ2ZGYwOQ==", "commit": {"author": {"name": "Ed Schonberg", "email": "schonberg@adacore.com", "date": "2014-07-29T13:35:32Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-07-29T13:35:32Z"}, "message": "sem_ch6.adb: Move Build_Body_To_Inline...\n\n2014-07-29  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch6.adb: Move Build_Body_To_Inline,\n\tCheck_And_Buid_Body_To_Inline, and Cannot_Inline to package Inline.\n\t* exp_ch6.adb: Mode Expand_Inlined_Body to package Inline.\n\t* inline.ads, inline.adb: Package now contains subprograms that\n\timplement front-end inlining.  No functional changes, no test\n\tneeded.\n\nFrom-SVN: r213179", "tree": {"sha": "3f20dff54909490d5c668092ef81769c5348cbc6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3f20dff54909490d5c668092ef81769c5348cbc6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/540d86108f31f56f513f542b910b909dd4d6df09", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/540d86108f31f56f513f542b910b909dd4d6df09", "html_url": "https://github.com/Rust-GCC/gccrs/commit/540d86108f31f56f513f542b910b909dd4d6df09", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/540d86108f31f56f513f542b910b909dd4d6df09/comments", "author": {"login": "Edschonberg", "id": 6352375, "node_id": "MDQ6VXNlcjYzNTIzNzU=", "avatar_url": "https://avatars.githubusercontent.com/u/6352375?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Edschonberg", "html_url": "https://github.com/Edschonberg", "followers_url": "https://api.github.com/users/Edschonberg/followers", "following_url": "https://api.github.com/users/Edschonberg/following{/other_user}", "gists_url": "https://api.github.com/users/Edschonberg/gists{/gist_id}", "starred_url": "https://api.github.com/users/Edschonberg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Edschonberg/subscriptions", "organizations_url": "https://api.github.com/users/Edschonberg/orgs", "repos_url": "https://api.github.com/users/Edschonberg/repos", "events_url": "https://api.github.com/users/Edschonberg/events{/privacy}", "received_events_url": "https://api.github.com/users/Edschonberg/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b973629e6111e77faa512754a4e4738a0c75ee83", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b973629e6111e77faa512754a4e4738a0c75ee83", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b973629e6111e77faa512754a4e4738a0c75ee83"}], "stats": {"total": 6150, "additions": 3086, "deletions": 3064}, "files": [{"sha": "835e8346a0ecd70d380241aba22e6bcd7e56e72d", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/540d86108f31f56f513f542b910b909dd4d6df09/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/540d86108f31f56f513f542b910b909dd4d6df09/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=540d86108f31f56f513f542b910b909dd4d6df09", "patch": "@@ -1,3 +1,12 @@\n+2014-07-29  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch6.adb: Move Build_Body_To_Inline,\n+\tCheck_And_Buid_Body_To_Inline, and Cannot_Inline to package Inline.\n+\t* exp_ch6.adb: Mode Expand_Inlined_Body to package Inline.\n+\t* inline.ads, inline.adb: Package now contains subprograms that\n+\timplement front-end inlining.  No functional changes, no test\n+\tneeded.\n+\n 2014-07-29  Robert Dewar  <dewar@adacore.com>\n \n \t* exp_dbug.adb, g-expect.adb, sem_elab.adb: Minor typo fix."}, {"sha": "c69136d4315293cae065243654598a1e88e19a32", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 0, "deletions": 1148, "changes": 1148, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/540d86108f31f56f513f542b910b909dd4d6df09/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/540d86108f31f56f513f542b910b909dd4d6df09/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=540d86108f31f56f513f542b910b909dd4d6df09", "patch": "@@ -61,7 +61,6 @@ with Sem;      use Sem;\n with Sem_Aux;  use Sem_Aux;\n with Sem_Ch6;  use Sem_Ch6;\n with Sem_Ch8;  use Sem_Ch8;\n-with Sem_Ch12; use Sem_Ch12;\n with Sem_Ch13; use Sem_Ch13;\n with Sem_Dim;  use Sem_Dim;\n with Sem_Disp; use Sem_Disp;\n@@ -83,10 +82,6 @@ with Validsw;  use Validsw;\n \n package body Exp_Ch6 is\n \n-   Inlined_Calls : Elist_Id := No_Elist;\n-   Backend_Calls : Elist_Id := No_Elist;\n-   --  List of frontend inlined calls and inline calls passed to the backend\n-\n    -----------------------\n    -- Local Subprograms --\n    -----------------------\n@@ -205,19 +200,6 @@ package body Exp_Ch6 is\n    --  call into a temporary which retrieves the returned object from the\n    --  secondary stack using 'reference.\n \n-   procedure Expand_Inlined_Call\n-    (N         : Node_Id;\n-     Subp      : Entity_Id;\n-     Orig_Subp : Entity_Id);\n-   --  If called subprogram can be inlined by the front-end, retrieve the\n-   --  analyzed body, replace formals with actuals and expand call in place.\n-   --  Generate thunks for actuals that are expressions, and insert the\n-   --  corresponding constant declarations before the call. If the original\n-   --  call is to a derived operation, the return type is the one of the\n-   --  derived operation, but the body is that of the original, so return\n-   --  expressions in the body must be converted to the desired type (which\n-   --  is simply not noted in the tree without inline expansion).\n-\n    procedure Expand_Non_Function_Return (N : Node_Id);\n    --  Called by Expand_N_Simple_Return_Statement in case we're returning from\n    --  a procedure body, entry body, accept statement, or extended return\n@@ -4266,1136 +4248,6 @@ package body Exp_Ch6 is\n       end if;\n    end Expand_Ctrl_Function_Call;\n \n-   -------------------------\n-   -- Expand_Inlined_Call --\n-   -------------------------\n-\n-   procedure Expand_Inlined_Call\n-    (N         : Node_Id;\n-     Subp      : Entity_Id;\n-     Orig_Subp : Entity_Id)\n-   is\n-      Loc       : constant Source_Ptr := Sloc (N);\n-      Is_Predef : constant Boolean :=\n-                   Is_Predefined_File_Name\n-                     (Unit_File_Name (Get_Source_Unit (Subp)));\n-      Orig_Bod  : constant Node_Id :=\n-                    Body_To_Inline (Unit_Declaration_Node (Subp));\n-\n-      Blk      : Node_Id;\n-      Decl     : Node_Id;\n-      Decls    : constant List_Id := New_List;\n-      Exit_Lab : Entity_Id := Empty;\n-      F        : Entity_Id;\n-      A        : Node_Id;\n-      Lab_Decl : Node_Id;\n-      Lab_Id   : Node_Id;\n-      New_A    : Node_Id;\n-      Num_Ret  : Int := 0;\n-      Ret_Type : Entity_Id;\n-\n-      Targ : Node_Id;\n-      --  The target of the call. If context is an assignment statement then\n-      --  this is the left-hand side of the assignment, else it is a temporary\n-      --  to which the return value is assigned prior to rewriting the call.\n-\n-      Targ1 : Node_Id;\n-      --  A separate target used when the return type is unconstrained\n-\n-      Temp     : Entity_Id;\n-      Temp_Typ : Entity_Id;\n-\n-      Return_Object : Entity_Id := Empty;\n-      --  Entity in declaration in an extended_return_statement\n-\n-      Is_Unc      : Boolean;\n-      Is_Unc_Decl : Boolean;\n-      --  If the type returned by the function is unconstrained and the call\n-      --  can be inlined, special processing is required.\n-\n-      procedure Make_Exit_Label;\n-      --  Build declaration for exit label to be used in Return statements,\n-      --  sets Exit_Lab (the label node) and Lab_Decl (corresponding implicit\n-      --  declaration). Does nothing if Exit_Lab already set.\n-\n-      function Process_Formals (N : Node_Id) return Traverse_Result;\n-      --  Replace occurrence of a formal with the corresponding actual, or the\n-      --  thunk generated for it. Replace a return statement with an assignment\n-      --  to the target of the call, with appropriate conversions if needed.\n-\n-      function Process_Sloc (Nod : Node_Id) return Traverse_Result;\n-      --  If the call being expanded is that of an internal subprogram, set the\n-      --  sloc of the generated block to that of the call itself, so that the\n-      --  expansion is skipped by the \"next\" command in gdb.\n-      --  Same processing for a subprogram in a predefined file, e.g.\n-      --  Ada.Tags. If Debug_Generated_Code is true, suppress this change to\n-      --  simplify our own development.\n-\n-      procedure Reset_Dispatching_Calls (N : Node_Id);\n-      --  In subtree N search for occurrences of dispatching calls that use the\n-      --  Ada 2005 Object.Operation notation and the object is a formal of the\n-      --  inlined subprogram. Reset the entity associated with Operation in all\n-      --  the found occurrences.\n-\n-      procedure Rewrite_Function_Call (N : Node_Id; Blk : Node_Id);\n-      --  If the function body is a single expression, replace call with\n-      --  expression, else insert block appropriately.\n-\n-      procedure Rewrite_Procedure_Call (N : Node_Id; Blk : Node_Id);\n-      --  If procedure body has no local variables, inline body without\n-      --  creating block, otherwise rewrite call with block.\n-\n-      function Formal_Is_Used_Once (Formal : Entity_Id) return Boolean;\n-      --  Determine whether a formal parameter is used only once in Orig_Bod\n-\n-      ---------------------\n-      -- Make_Exit_Label --\n-      ---------------------\n-\n-      procedure Make_Exit_Label is\n-         Lab_Ent : Entity_Id;\n-      begin\n-         if No (Exit_Lab) then\n-            Lab_Ent := Make_Temporary (Loc, 'L');\n-            Lab_Id  := New_Occurrence_Of (Lab_Ent, Loc);\n-            Exit_Lab := Make_Label (Loc, Lab_Id);\n-            Lab_Decl :=\n-              Make_Implicit_Label_Declaration (Loc,\n-                Defining_Identifier  => Lab_Ent,\n-                Label_Construct      => Exit_Lab);\n-         end if;\n-      end Make_Exit_Label;\n-\n-      ---------------------\n-      -- Process_Formals --\n-      ---------------------\n-\n-      function Process_Formals (N : Node_Id) return Traverse_Result is\n-         A   : Entity_Id;\n-         E   : Entity_Id;\n-         Ret : Node_Id;\n-\n-      begin\n-         if Is_Entity_Name (N) and then Present (Entity (N)) then\n-            E := Entity (N);\n-\n-            if Is_Formal (E) and then Scope (E) = Subp then\n-               A := Renamed_Object (E);\n-\n-               --  Rewrite the occurrence of the formal into an occurrence of\n-               --  the actual. Also establish visibility on the proper view of\n-               --  the actual's subtype for the body's context (if the actual's\n-               --  subtype is private at the call point but its full view is\n-               --  visible to the body, then the inlined tree here must be\n-               --  analyzed with the full view).\n-\n-               if Is_Entity_Name (A) then\n-                  Rewrite (N, New_Occurrence_Of (Entity (A), Loc));\n-                  Check_Private_View (N);\n-\n-               elsif Nkind (A) = N_Defining_Identifier then\n-                  Rewrite (N, New_Occurrence_Of (A, Loc));\n-                  Check_Private_View (N);\n-\n-               --  Numeric literal\n-\n-               else\n-                  Rewrite (N, New_Copy (A));\n-               end if;\n-            end if;\n-\n-            return Skip;\n-\n-         elsif Is_Entity_Name (N)\n-           and then Present (Return_Object)\n-           and then Chars (N) = Chars (Return_Object)\n-         then\n-            --  Occurrence within an extended return statement. The return\n-            --  object is local to the body been inlined, and thus the generic\n-            --  copy is not analyzed yet, so we match by name, and replace it\n-            --  with target of call.\n-\n-            if Nkind (Targ) = N_Defining_Identifier then\n-               Rewrite (N, New_Occurrence_Of (Targ, Loc));\n-            else\n-               Rewrite (N, New_Copy_Tree (Targ));\n-            end if;\n-\n-            return Skip;\n-\n-         elsif Nkind (N) = N_Simple_Return_Statement then\n-            if No (Expression (N)) then\n-               Make_Exit_Label;\n-               Rewrite (N,\n-                 Make_Goto_Statement (Loc, Name => New_Copy (Lab_Id)));\n-\n-            else\n-               if Nkind (Parent (N)) = N_Handled_Sequence_Of_Statements\n-                 and then Nkind (Parent (Parent (N))) = N_Subprogram_Body\n-               then\n-                  --  Function body is a single expression. No need for\n-                  --  exit label.\n-\n-                  null;\n-\n-               else\n-                  Num_Ret := Num_Ret + 1;\n-                  Make_Exit_Label;\n-               end if;\n-\n-               --  Because of the presence of private types, the views of the\n-               --  expression and the context may be different, so place an\n-               --  unchecked conversion to the context type to avoid spurious\n-               --  errors, e.g. when the expression is a numeric literal and\n-               --  the context is private. If the expression is an aggregate,\n-               --  use a qualified expression, because an aggregate is not a\n-               --  legal argument of a conversion. Ditto for numeric literals,\n-               --  which must be resolved to a specific type.\n-\n-               if Nkind_In (Expression (N), N_Aggregate,\n-                                            N_Null,\n-                                            N_Real_Literal,\n-                                            N_Integer_Literal)\n-               then\n-                  Ret :=\n-                    Make_Qualified_Expression (Sloc (N),\n-                      Subtype_Mark => New_Occurrence_Of (Ret_Type, Sloc (N)),\n-                      Expression => Relocate_Node (Expression (N)));\n-               else\n-                  Ret :=\n-                    Unchecked_Convert_To\n-                      (Ret_Type, Relocate_Node (Expression (N)));\n-               end if;\n-\n-               if Nkind (Targ) = N_Defining_Identifier then\n-                  Rewrite (N,\n-                    Make_Assignment_Statement (Loc,\n-                      Name       => New_Occurrence_Of (Targ, Loc),\n-                      Expression => Ret));\n-               else\n-                  Rewrite (N,\n-                    Make_Assignment_Statement (Loc,\n-                      Name       => New_Copy (Targ),\n-                      Expression => Ret));\n-               end if;\n-\n-               Set_Assignment_OK (Name (N));\n-\n-               if Present (Exit_Lab) then\n-                  Insert_After (N,\n-                    Make_Goto_Statement (Loc, Name => New_Copy (Lab_Id)));\n-               end if;\n-            end if;\n-\n-            return OK;\n-\n-         --  An extended return becomes a block whose first statement is the\n-         --  assignment of the initial expression of the return object to the\n-         --  target of the call itself.\n-\n-         elsif Nkind (N) = N_Extended_Return_Statement then\n-            declare\n-               Return_Decl : constant Entity_Id :=\n-                               First (Return_Object_Declarations (N));\n-               Assign      : Node_Id;\n-\n-            begin\n-               Return_Object := Defining_Identifier (Return_Decl);\n-\n-               if Present (Expression (Return_Decl)) then\n-                  if Nkind (Targ) = N_Defining_Identifier then\n-                     Assign :=\n-                       Make_Assignment_Statement (Loc,\n-                         Name       => New_Occurrence_Of (Targ, Loc),\n-                         Expression => Expression (Return_Decl));\n-                  else\n-                     Assign :=\n-                       Make_Assignment_Statement (Loc,\n-                         Name       => New_Copy (Targ),\n-                         Expression => Expression (Return_Decl));\n-                  end if;\n-\n-                  Set_Assignment_OK (Name (Assign));\n-\n-                  if No (Handled_Statement_Sequence (N)) then\n-                     Set_Handled_Statement_Sequence (N,\n-                       Make_Handled_Sequence_Of_Statements (Loc,\n-                         Statements => New_List));\n-                  end if;\n-\n-                  Prepend (Assign,\n-                    Statements (Handled_Statement_Sequence (N)));\n-               end if;\n-\n-               Rewrite (N,\n-                 Make_Block_Statement (Loc,\n-                    Handled_Statement_Sequence =>\n-                      Handled_Statement_Sequence (N)));\n-\n-               return OK;\n-            end;\n-\n-         --  Remove pragma Unreferenced since it may refer to formals that\n-         --  are not visible in the inlined body, and in any case we will\n-         --  not be posting warnings on the inlined body so it is unneeded.\n-\n-         elsif Nkind (N) = N_Pragma\n-           and then Pragma_Name (N) = Name_Unreferenced\n-         then\n-            Rewrite (N, Make_Null_Statement (Sloc (N)));\n-            return OK;\n-\n-         else\n-            return OK;\n-         end if;\n-      end Process_Formals;\n-\n-      procedure Replace_Formals is new Traverse_Proc (Process_Formals);\n-\n-      ------------------\n-      -- Process_Sloc --\n-      ------------------\n-\n-      function Process_Sloc (Nod : Node_Id) return Traverse_Result is\n-      begin\n-         if not Debug_Generated_Code then\n-            Set_Sloc (Nod, Sloc (N));\n-            Set_Comes_From_Source (Nod, False);\n-         end if;\n-\n-         return OK;\n-      end Process_Sloc;\n-\n-      procedure Reset_Slocs is new Traverse_Proc (Process_Sloc);\n-\n-      ------------------------------\n-      --  Reset_Dispatching_Calls --\n-      ------------------------------\n-\n-      procedure Reset_Dispatching_Calls (N : Node_Id) is\n-\n-         function Do_Reset (N : Node_Id) return Traverse_Result;\n-         --  Comment required ???\n-\n-         --------------\n-         -- Do_Reset --\n-         --------------\n-\n-         function Do_Reset (N : Node_Id) return Traverse_Result is\n-         begin\n-            if Nkind (N) = N_Procedure_Call_Statement\n-              and then Nkind (Name (N)) = N_Selected_Component\n-              and then Nkind (Prefix (Name (N))) = N_Identifier\n-              and then Is_Formal (Entity (Prefix (Name (N))))\n-              and then Is_Dispatching_Operation\n-                         (Entity (Selector_Name (Name (N))))\n-            then\n-               Set_Entity (Selector_Name (Name (N)), Empty);\n-            end if;\n-\n-            return OK;\n-         end Do_Reset;\n-\n-         function Do_Reset_Calls is new Traverse_Func (Do_Reset);\n-\n-         --  Local variables\n-\n-         Dummy : constant Traverse_Result := Do_Reset_Calls (N);\n-         pragma Unreferenced (Dummy);\n-\n-         --  Start of processing for Reset_Dispatching_Calls\n-\n-      begin\n-         null;\n-      end Reset_Dispatching_Calls;\n-\n-      ---------------------------\n-      -- Rewrite_Function_Call --\n-      ---------------------------\n-\n-      procedure Rewrite_Function_Call (N : Node_Id; Blk : Node_Id) is\n-         HSS : constant Node_Id := Handled_Statement_Sequence (Blk);\n-         Fst : constant Node_Id := First (Statements (HSS));\n-\n-      begin\n-         --  Optimize simple case: function body is a single return statement,\n-         --  which has been expanded into an assignment.\n-\n-         if Is_Empty_List (Declarations (Blk))\n-           and then Nkind (Fst) = N_Assignment_Statement\n-           and then No (Next (Fst))\n-         then\n-            --  The function call may have been rewritten as the temporary\n-            --  that holds the result of the call, in which case remove the\n-            --  now useless declaration.\n-\n-            if Nkind (N) = N_Identifier\n-              and then Nkind (Parent (Entity (N))) = N_Object_Declaration\n-            then\n-               Rewrite (Parent (Entity (N)), Make_Null_Statement (Loc));\n-            end if;\n-\n-            Rewrite (N, Expression (Fst));\n-\n-         elsif Nkind (N) = N_Identifier\n-           and then Nkind (Parent (Entity (N))) = N_Object_Declaration\n-         then\n-            --  The block assigns the result of the call to the temporary\n-\n-            Insert_After (Parent (Entity (N)), Blk);\n-\n-         --  If the context is an assignment, and the left-hand side is free of\n-         --  side-effects, the replacement is also safe.\n-         --  Can this be generalized further???\n-\n-         elsif Nkind (Parent (N)) = N_Assignment_Statement\n-           and then\n-            (Is_Entity_Name (Name (Parent (N)))\n-              or else\n-                (Nkind (Name (Parent (N))) = N_Explicit_Dereference\n-                  and then Is_Entity_Name (Prefix (Name (Parent (N)))))\n-\n-              or else\n-                (Nkind (Name (Parent (N))) = N_Selected_Component\n-                  and then Is_Entity_Name (Prefix (Name (Parent (N))))))\n-         then\n-            --  Replace assignment with the block\n-\n-            declare\n-               Original_Assignment : constant Node_Id := Parent (N);\n-\n-            begin\n-               --  Preserve the original assignment node to keep the complete\n-               --  assignment subtree consistent enough for Analyze_Assignment\n-               --  to proceed (specifically, the original Lhs node must still\n-               --  have an assignment statement as its parent).\n-\n-               --  We cannot rely on Original_Node to go back from the block\n-               --  node to the assignment node, because the assignment might\n-               --  already be a rewrite substitution.\n-\n-               Discard_Node (Relocate_Node (Original_Assignment));\n-               Rewrite (Original_Assignment, Blk);\n-            end;\n-\n-         elsif Nkind (Parent (N)) = N_Object_Declaration then\n-\n-            --  A call to a function which returns an unconstrained type\n-            --  found in the expression initializing an object-declaration is\n-            --  expanded into a procedure call which must be added after the\n-            --  object declaration.\n-\n-            if Is_Unc_Decl and then Debug_Flag_Dot_K then\n-               Insert_Action_After (Parent (N), Blk);\n-            else\n-               Set_Expression (Parent (N), Empty);\n-               Insert_After (Parent (N), Blk);\n-            end if;\n-\n-         elsif Is_Unc and then not Debug_Flag_Dot_K then\n-            Insert_Before (Parent (N), Blk);\n-         end if;\n-      end Rewrite_Function_Call;\n-\n-      ----------------------------\n-      -- Rewrite_Procedure_Call --\n-      ----------------------------\n-\n-      procedure Rewrite_Procedure_Call (N : Node_Id; Blk : Node_Id) is\n-         HSS  : constant Node_Id := Handled_Statement_Sequence (Blk);\n-\n-      begin\n-         --  If there is a transient scope for N, this will be the scope of the\n-         --  actions for N, and the statements in Blk need to be within this\n-         --  scope. For example, they need to have visibility on the constant\n-         --  declarations created for the formals.\n-\n-         --  If N needs no transient scope, and if there are no declarations in\n-         --  the inlined body, we can do a little optimization and insert the\n-         --  statements for the body directly after N, and rewrite N to a\n-         --  null statement, instead of rewriting N into a full-blown block\n-         --  statement.\n-\n-         if not Scope_Is_Transient\n-           and then Is_Empty_List (Declarations (Blk))\n-         then\n-            Insert_List_After (N, Statements (HSS));\n-            Rewrite (N, Make_Null_Statement (Loc));\n-         else\n-            Rewrite (N, Blk);\n-         end if;\n-      end Rewrite_Procedure_Call;\n-\n-      -------------------------\n-      -- Formal_Is_Used_Once --\n-      -------------------------\n-\n-      function Formal_Is_Used_Once (Formal : Entity_Id) return Boolean is\n-         Use_Counter : Int := 0;\n-\n-         function Count_Uses (N : Node_Id) return Traverse_Result;\n-         --  Traverse the tree and count the uses of the formal parameter.\n-         --  In this case, for optimization purposes, we do not need to\n-         --  continue the traversal once more than one use is encountered.\n-\n-         ----------------\n-         -- Count_Uses --\n-         ----------------\n-\n-         function Count_Uses (N : Node_Id) return Traverse_Result is\n-         begin\n-            --  The original node is an identifier\n-\n-            if Nkind (N) = N_Identifier\n-              and then Present (Entity (N))\n-\n-               --  Original node's entity points to the one in the copied body\n-\n-              and then Nkind (Entity (N)) = N_Identifier\n-              and then Present (Entity (Entity (N)))\n-\n-               --  The entity of the copied node is the formal parameter\n-\n-              and then Entity (Entity (N)) = Formal\n-            then\n-               Use_Counter := Use_Counter + 1;\n-\n-               if Use_Counter > 1 then\n-\n-                  --  Denote more than one use and abandon the traversal\n-\n-                  Use_Counter := 2;\n-                  return Abandon;\n-\n-               end if;\n-            end if;\n-\n-            return OK;\n-         end Count_Uses;\n-\n-         procedure Count_Formal_Uses is new Traverse_Proc (Count_Uses);\n-\n-      --  Start of processing for Formal_Is_Used_Once\n-\n-      begin\n-         Count_Formal_Uses (Orig_Bod);\n-         return Use_Counter = 1;\n-      end Formal_Is_Used_Once;\n-\n-   --  Start of processing for Expand_Inlined_Call\n-\n-   begin\n-      --  Initializations for old/new semantics\n-\n-      if not Debug_Flag_Dot_K then\n-         Is_Unc      := Is_Array_Type (Etype (Subp))\n-                          and then not Is_Constrained (Etype (Subp));\n-         Is_Unc_Decl := False;\n-      else\n-         Is_Unc      := Returns_Unconstrained_Type (Subp)\n-                          and then Optimization_Level > 0;\n-         Is_Unc_Decl := Nkind (Parent (N)) = N_Object_Declaration\n-                          and then Is_Unc;\n-      end if;\n-\n-      --  Check for an illegal attempt to inline a recursive procedure. If the\n-      --  subprogram has parameters this is detected when trying to supply a\n-      --  binding for parameters that already have one. For parameterless\n-      --  subprograms this must be done explicitly.\n-\n-      if In_Open_Scopes (Subp) then\n-         Error_Msg_N (\"call to recursive subprogram cannot be inlined??\", N);\n-         Set_Is_Inlined (Subp, False);\n-         return;\n-\n-      --  Skip inlining if this is not a true inlining since the attribute\n-      --  Body_To_Inline is also set for renamings (see sinfo.ads)\n-\n-      elsif Nkind (Orig_Bod) in N_Entity then\n-         return;\n-\n-      --  Skip inlining if the function returns an unconstrained type using\n-      --  an extended return statement since this part of the new inlining\n-      --  model which is not yet supported by the current implementation. ???\n-\n-      elsif Is_Unc\n-        and then\n-          Nkind (First (Statements (Handled_Statement_Sequence (Orig_Bod))))\n-            = N_Extended_Return_Statement\n-        and then not Debug_Flag_Dot_K\n-      then\n-         return;\n-      end if;\n-\n-      if Nkind (Orig_Bod) = N_Defining_Identifier\n-        or else Nkind (Orig_Bod) = N_Defining_Operator_Symbol\n-      then\n-         --  Subprogram is renaming_as_body. Calls occurring after the renaming\n-         --  can be replaced with calls to the renamed entity directly, because\n-         --  the subprograms are subtype conformant. If the renamed subprogram\n-         --  is an inherited operation, we must redo the expansion because\n-         --  implicit conversions may be needed. Similarly, if the renamed\n-         --  entity is inlined, expand the call for further optimizations.\n-\n-         Set_Name (N, New_Occurrence_Of (Orig_Bod, Loc));\n-\n-         if Present (Alias (Orig_Bod)) or else Is_Inlined (Orig_Bod) then\n-            Expand_Call (N);\n-         end if;\n-\n-         return;\n-      end if;\n-\n-      --  Register the call in the list of inlined calls\n-\n-      if Inlined_Calls = No_Elist then\n-         Inlined_Calls := New_Elmt_List;\n-      end if;\n-\n-      Append_Elmt (N, To => Inlined_Calls);\n-\n-      --  Use generic machinery to copy body of inlined subprogram, as if it\n-      --  were an instantiation, resetting source locations appropriately, so\n-      --  that nested inlined calls appear in the main unit.\n-\n-      Save_Env (Subp, Empty);\n-      Set_Copied_Sloc_For_Inlined_Body (N, Defining_Entity (Orig_Bod));\n-\n-      --  Old semantics\n-\n-      if not Debug_Flag_Dot_K then\n-         declare\n-            Bod : Node_Id;\n-\n-         begin\n-            Bod := Copy_Generic_Node (Orig_Bod, Empty, Instantiating => True);\n-            Blk :=\n-              Make_Block_Statement (Loc,\n-                Declarations => Declarations (Bod),\n-                Handled_Statement_Sequence =>\n-                  Handled_Statement_Sequence (Bod));\n-\n-            if No (Declarations (Bod)) then\n-               Set_Declarations (Blk, New_List);\n-            end if;\n-\n-            --  For the unconstrained case, capture the name of the local\n-            --  variable that holds the result. This must be the first\n-            --  declaration in the block, because its bounds cannot depend\n-            --  on local variables. Otherwise there is no way to declare the\n-            --  result outside of the block. Needless to say, in general the\n-            --  bounds will depend on the actuals in the call.\n-\n-            --  If the context is an assignment statement, as is the case\n-            --  for the expansion of an extended return, the left-hand side\n-            --  provides bounds even if the return type is unconstrained.\n-\n-            if Is_Unc then\n-               declare\n-                  First_Decl : Node_Id;\n-\n-               begin\n-                  First_Decl := First (Declarations (Blk));\n-\n-                  if Nkind (First_Decl) /= N_Object_Declaration then\n-                     return;\n-                  end if;\n-\n-                  if Nkind (Parent (N)) /= N_Assignment_Statement then\n-                     Targ1 := Defining_Identifier (First_Decl);\n-                  else\n-                     Targ1 := Name (Parent (N));\n-                  end if;\n-               end;\n-            end if;\n-         end;\n-\n-      --  New semantics\n-\n-      else\n-         declare\n-            Bod : Node_Id;\n-\n-         begin\n-            --  General case\n-\n-            if not Is_Unc then\n-               Bod :=\n-                 Copy_Generic_Node (Orig_Bod, Empty, Instantiating => True);\n-               Blk :=\n-                 Make_Block_Statement (Loc,\n-                                       Declarations => Declarations (Bod),\n-                                       Handled_Statement_Sequence =>\n-                                         Handled_Statement_Sequence (Bod));\n-\n-            --  Inline a call to a function that returns an unconstrained type.\n-            --  The semantic analyzer checked that frontend-inlined functions\n-            --  returning unconstrained types have no declarations and have\n-            --  a single extended return statement. As part of its processing\n-            --  the function was split in two subprograms: a procedure P and\n-            --  a function F that has a block with a call to procedure P (see\n-            --  Split_Unconstrained_Function).\n-\n-            else\n-               pragma Assert\n-                 (Nkind\n-                   (First\n-                     (Statements (Handled_Statement_Sequence (Orig_Bod))))\n-                  = N_Block_Statement);\n-\n-               declare\n-                  Blk_Stmt    : constant Node_Id :=\n-                    First\n-                      (Statements\n-                        (Handled_Statement_Sequence (Orig_Bod)));\n-                  First_Stmt  : constant Node_Id :=\n-                    First\n-                      (Statements\n-                        (Handled_Statement_Sequence (Blk_Stmt)));\n-                  Second_Stmt : constant Node_Id := Next (First_Stmt);\n-\n-               begin\n-                  pragma Assert\n-                    (Nkind (First_Stmt) = N_Procedure_Call_Statement\n-                      and then Nkind (Second_Stmt) = N_Simple_Return_Statement\n-                      and then No (Next (Second_Stmt)));\n-\n-                  Bod :=\n-                    Copy_Generic_Node\n-                      (First\n-                        (Statements (Handled_Statement_Sequence (Orig_Bod))),\n-                       Empty, Instantiating => True);\n-                  Blk := Bod;\n-\n-                  --  Capture the name of the local variable that holds the\n-                  --  result. This must be the first declaration in the block,\n-                  --  because its bounds cannot depend on local variables.\n-                  --  Otherwise there is no way to declare the result outside\n-                  --  of the block. Needless to say, in general the bounds will\n-                  --  depend on the actuals in the call.\n-\n-                  if Nkind (Parent (N)) /= N_Assignment_Statement then\n-                     Targ1 := Defining_Identifier (First (Declarations (Blk)));\n-\n-                  --  If the context is an assignment statement, as is the case\n-                  --  for the expansion of an extended return, the left-hand\n-                  --  side provides bounds even if the return type is\n-                  --  unconstrained.\n-\n-                  else\n-                     Targ1 := Name (Parent (N));\n-                  end if;\n-               end;\n-            end if;\n-\n-            if No (Declarations (Bod)) then\n-               Set_Declarations (Blk, New_List);\n-            end if;\n-         end;\n-      end if;\n-\n-      --  If this is a derived function, establish the proper return type\n-\n-      if Present (Orig_Subp) and then Orig_Subp /= Subp then\n-         Ret_Type := Etype (Orig_Subp);\n-      else\n-         Ret_Type := Etype (Subp);\n-      end if;\n-\n-      --  Create temporaries for the actuals that are expressions, or that are\n-      --  scalars and require copying to preserve semantics.\n-\n-      F := First_Formal (Subp);\n-      A := First_Actual (N);\n-      while Present (F) loop\n-         if Present (Renamed_Object (F)) then\n-            Error_Msg_N (\"cannot inline call to recursive subprogram\", N);\n-            return;\n-         end if;\n-\n-         --  Reset Last_Assignment for any parameters of mode out or in out, to\n-         --  prevent spurious warnings about overwriting for assignments to the\n-         --  formal in the inlined code.\n-\n-         if Is_Entity_Name (A) and then Ekind (F) /= E_In_Parameter then\n-            Set_Last_Assignment (Entity (A), Empty);\n-         end if;\n-\n-         --  If the argument may be a controlling argument in a call within\n-         --  the inlined body, we must preserve its classwide nature to insure\n-         --  that dynamic dispatching take place subsequently. If the formal\n-         --  has a constraint it must be preserved to retain the semantics of\n-         --  the body.\n-\n-         if Is_Class_Wide_Type (Etype (F))\n-           or else (Is_Access_Type (Etype (F))\n-                     and then Is_Class_Wide_Type (Designated_Type (Etype (F))))\n-         then\n-            Temp_Typ := Etype (F);\n-\n-         elsif Base_Type (Etype (F)) = Base_Type (Etype (A))\n-           and then Etype (F) /= Base_Type (Etype (F))\n-         then\n-            Temp_Typ := Etype (F);\n-         else\n-            Temp_Typ := Etype (A);\n-         end if;\n-\n-         --  If the actual is a simple name or a literal, no need to\n-         --  create a temporary, object can be used directly.\n-\n-         --  If the actual is a literal and the formal has its address taken,\n-         --  we cannot pass the literal itself as an argument, so its value\n-         --  must be captured in a temporary.\n-\n-         if (Is_Entity_Name (A)\n-              and then\n-               (not Is_Scalar_Type (Etype (A))\n-                 or else Ekind (Entity (A)) = E_Enumeration_Literal))\n-\n-         --  When the actual is an identifier and the corresponding formal is\n-         --  used only once in the original body, the formal can be substituted\n-         --  directly with the actual parameter.\n-\n-           or else (Nkind (A) = N_Identifier\n-             and then Formal_Is_Used_Once (F))\n-\n-           or else\n-             (Nkind_In (A, N_Real_Literal,\n-                           N_Integer_Literal,\n-                           N_Character_Literal)\n-               and then not Address_Taken (F))\n-         then\n-            if Etype (F) /= Etype (A) then\n-               Set_Renamed_Object\n-                 (F, Unchecked_Convert_To (Etype (F), Relocate_Node (A)));\n-            else\n-               Set_Renamed_Object (F, A);\n-            end if;\n-\n-         else\n-            Temp := Make_Temporary (Loc, 'C');\n-\n-            --  If the actual for an in/in-out parameter is a view conversion,\n-            --  make it into an unchecked conversion, given that an untagged\n-            --  type conversion is not a proper object for a renaming.\n-\n-            --  In-out conversions that involve real conversions have already\n-            --  been transformed in Expand_Actuals.\n-\n-            if Nkind (A) = N_Type_Conversion\n-              and then Ekind (F) /= E_In_Parameter\n-            then\n-               New_A :=\n-                 Make_Unchecked_Type_Conversion (Loc,\n-                   Subtype_Mark => New_Occurrence_Of (Etype (F), Loc),\n-                   Expression   => Relocate_Node (Expression (A)));\n-\n-            elsif Etype (F) /= Etype (A) then\n-               New_A := Unchecked_Convert_To (Etype (F), Relocate_Node (A));\n-               Temp_Typ := Etype (F);\n-\n-            else\n-               New_A := Relocate_Node (A);\n-            end if;\n-\n-            Set_Sloc (New_A, Sloc (N));\n-\n-            --  If the actual has a by-reference type, it cannot be copied,\n-            --  so its value is captured in a renaming declaration. Otherwise\n-            --  declare a local constant initialized with the actual.\n-\n-            --  We also use a renaming declaration for expressions of an array\n-            --  type that is not bit-packed, both for efficiency reasons and to\n-            --  respect the semantics of the call: in most cases the original\n-            --  call will pass the parameter by reference, and thus the inlined\n-            --  code will have the same semantics.\n-\n-            if Ekind (F) = E_In_Parameter\n-              and then not Is_By_Reference_Type (Etype (A))\n-              and then\n-                (not Is_Array_Type (Etype (A))\n-                  or else not Is_Object_Reference (A)\n-                  or else Is_Bit_Packed_Array (Etype (A)))\n-            then\n-               Decl :=\n-                 Make_Object_Declaration (Loc,\n-                   Defining_Identifier => Temp,\n-                   Constant_Present    => True,\n-                   Object_Definition   => New_Occurrence_Of (Temp_Typ, Loc),\n-                   Expression          => New_A);\n-            else\n-               Decl :=\n-                 Make_Object_Renaming_Declaration (Loc,\n-                   Defining_Identifier => Temp,\n-                   Subtype_Mark        => New_Occurrence_Of (Temp_Typ, Loc),\n-                   Name                => New_A);\n-            end if;\n-\n-            Append (Decl, Decls);\n-            Set_Renamed_Object (F, Temp);\n-         end if;\n-\n-         Next_Formal (F);\n-         Next_Actual (A);\n-      end loop;\n-\n-      --  Establish target of function call. If context is not assignment or\n-      --  declaration, create a temporary as a target. The declaration for the\n-      --  temporary may be subsequently optimized away if the body is a single\n-      --  expression, or if the left-hand side of the assignment is simple\n-      --  enough, i.e. an entity or an explicit dereference of one.\n-\n-      if Ekind (Subp) = E_Function then\n-         if Nkind (Parent (N)) = N_Assignment_Statement\n-           and then Is_Entity_Name (Name (Parent (N)))\n-         then\n-            Targ := Name (Parent (N));\n-\n-         elsif Nkind (Parent (N)) = N_Assignment_Statement\n-           and then Nkind (Name (Parent (N))) = N_Explicit_Dereference\n-           and then Is_Entity_Name (Prefix (Name (Parent (N))))\n-         then\n-            Targ := Name (Parent (N));\n-\n-         elsif Nkind (Parent (N)) = N_Assignment_Statement\n-           and then Nkind (Name (Parent (N))) = N_Selected_Component\n-           and then Is_Entity_Name (Prefix (Name (Parent (N))))\n-         then\n-            Targ := New_Copy_Tree (Name (Parent (N)));\n-\n-         elsif Nkind (Parent (N)) = N_Object_Declaration\n-           and then Is_Limited_Type (Etype (Subp))\n-         then\n-            Targ := Defining_Identifier (Parent (N));\n-\n-         --  New semantics: In an object declaration avoid an extra copy\n-         --  of the result of a call to an inlined function that returns\n-         --  an unconstrained type\n-\n-         elsif Debug_Flag_Dot_K\n-           and then Nkind (Parent (N)) = N_Object_Declaration\n-           and then Is_Unc\n-         then\n-            Targ := Defining_Identifier (Parent (N));\n-\n-         else\n-            --  Replace call with temporary and create its declaration\n-\n-            Temp := Make_Temporary (Loc, 'C');\n-            Set_Is_Internal (Temp);\n-\n-            --  For the unconstrained case, the generated temporary has the\n-            --  same constrained declaration as the result variable. It may\n-            --  eventually be possible to remove that temporary and use the\n-            --  result variable directly.\n-\n-            if Is_Unc\n-              and then Nkind (Parent (N)) /= N_Assignment_Statement\n-            then\n-               Decl :=\n-                 Make_Object_Declaration (Loc,\n-                   Defining_Identifier => Temp,\n-                   Object_Definition   =>\n-                     New_Copy_Tree (Object_Definition (Parent (Targ1))));\n-\n-               Replace_Formals (Decl);\n-\n-            else\n-               Decl :=\n-                 Make_Object_Declaration (Loc,\n-                   Defining_Identifier => Temp,\n-                   Object_Definition   => New_Occurrence_Of (Ret_Type, Loc));\n-\n-               Set_Etype (Temp, Ret_Type);\n-            end if;\n-\n-            Set_No_Initialization (Decl);\n-            Append (Decl, Decls);\n-            Rewrite (N, New_Occurrence_Of (Temp, Loc));\n-            Targ := Temp;\n-         end if;\n-      end if;\n-\n-      Insert_Actions (N, Decls);\n-\n-      if Is_Unc_Decl then\n-\n-         --  Special management for inlining a call to a function that returns\n-         --  an unconstrained type and initializes an object declaration: we\n-         --  avoid generating undesired extra calls and goto statements.\n-\n-         --     Given:\n-         --                 function Func (...) return ...\n-         --                 begin\n-         --                    declare\n-         --                       Result : String (1 .. 4);\n-         --                    begin\n-         --                       Proc (Result, ...);\n-         --                       return Result;\n-         --                    end;\n-         --                 end F;\n-\n-         --                 Result : String := Func (...);\n-\n-         --     Replace this object declaration by:\n-\n-         --                 Result : String (1 .. 4);\n-         --                 Proc (Result, ...);\n-\n-         Remove_Homonym (Targ);\n-\n-         Decl :=\n-           Make_Object_Declaration\n-             (Loc,\n-              Defining_Identifier => Targ,\n-              Object_Definition   =>\n-                New_Copy_Tree (Object_Definition (Parent (Targ1))));\n-         Replace_Formals (Decl);\n-         Rewrite (Parent (N), Decl);\n-         Analyze (Parent (N));\n-\n-         --  Avoid spurious warnings since we know that this declaration is\n-         --  referenced by the procedure call.\n-\n-         Set_Never_Set_In_Source (Targ, False);\n-\n-         --  Remove the local declaration of the extended return stmt from the\n-         --  inlined code\n-\n-         Remove (Parent (Targ1));\n-\n-         --  Update the reference to the result (since we have rewriten the\n-         --  object declaration)\n-\n-         declare\n-            Blk_Call_Stmt : Node_Id;\n-\n-         begin\n-            --  Capture the call to the procedure\n-\n-            Blk_Call_Stmt :=\n-              First (Statements (Handled_Statement_Sequence (Blk)));\n-            pragma Assert\n-              (Nkind (Blk_Call_Stmt) = N_Procedure_Call_Statement);\n-\n-            Remove (First (Parameter_Associations (Blk_Call_Stmt)));\n-            Prepend_To (Parameter_Associations (Blk_Call_Stmt),\n-              New_Occurrence_Of (Targ, Loc));\n-         end;\n-\n-         --  Remove the return statement\n-\n-         pragma Assert\n-           (Nkind (Last (Statements (Handled_Statement_Sequence (Blk)))) =\n-                                                   N_Simple_Return_Statement);\n-\n-         Remove (Last (Statements (Handled_Statement_Sequence (Blk))));\n-      end if;\n-\n-      --  Traverse the tree and replace formals with actuals or their thunks.\n-      --  Attach block to tree before analysis and rewriting.\n-\n-      Replace_Formals (Blk);\n-      Set_Parent (Blk, N);\n-\n-      if not Comes_From_Source (Subp) or else Is_Predef then\n-         Reset_Slocs (Blk);\n-      end if;\n-\n-      if Is_Unc_Decl then\n-\n-         --  No action needed since return statement has been already removed\n-\n-         null;\n-\n-      elsif Present (Exit_Lab) then\n-\n-         --  If the body was a single expression, the single return statement\n-         --  and the corresponding label are useless.\n-\n-         if Num_Ret = 1\n-           and then\n-             Nkind (Last (Statements (Handled_Statement_Sequence (Blk)))) =\n-                                                            N_Goto_Statement\n-         then\n-            Remove (Last (Statements (Handled_Statement_Sequence (Blk))));\n-         else\n-            Append (Lab_Decl, (Declarations (Blk)));\n-            Append (Exit_Lab, Statements (Handled_Statement_Sequence (Blk)));\n-         end if;\n-      end if;\n-\n-      --  Analyze Blk with In_Inlined_Body set, to avoid spurious errors\n-      --  on conflicting private views that Gigi would ignore. If this is a\n-      --  predefined unit, analyze with checks off, as is done in the non-\n-      --  inlined run-time units.\n-\n-      declare\n-         I_Flag : constant Boolean := In_Inlined_Body;\n-\n-      begin\n-         In_Inlined_Body := True;\n-\n-         if Is_Predef then\n-            declare\n-               Style : constant Boolean := Style_Check;\n-\n-            begin\n-               Style_Check := False;\n-\n-               --  Search for dispatching calls that use the Object.Operation\n-               --  notation using an Object that is a parameter of the inlined\n-               --  function. We reset the decoration of Operation to force\n-               --  the reanalysis of the inlined dispatching call because\n-               --  the actual object has been inlined.\n-\n-               Reset_Dispatching_Calls (Blk);\n-\n-               Analyze (Blk, Suppress => All_Checks);\n-               Style_Check := Style;\n-            end;\n-\n-         else\n-            Analyze (Blk);\n-         end if;\n-\n-         In_Inlined_Body := I_Flag;\n-      end;\n-\n-      if Ekind (Subp) = E_Procedure then\n-         Rewrite_Procedure_Call (N, Blk);\n-\n-      else\n-         Rewrite_Function_Call (N, Blk);\n-\n-         if Is_Unc_Decl then\n-            null;\n-\n-         --  For the unconstrained case, the replacement of the call has been\n-         --  made prior to the complete analysis of the generated declarations.\n-         --  Propagate the proper type now.\n-\n-         elsif Is_Unc then\n-            if Nkind (N) = N_Identifier then\n-               Set_Etype (N, Etype (Entity (N)));\n-            else\n-               Set_Etype (N, Etype (Targ1));\n-            end if;\n-         end if;\n-      end if;\n-\n-      Restore_Env;\n-\n-      --  Cleanup mapping between formals and actuals for other expansions\n-\n-      F := First_Formal (Subp);\n-      while Present (F) loop\n-         Set_Renamed_Object (F, Empty);\n-         Next_Formal (F);\n-      end loop;\n-   end Expand_Inlined_Call;\n-\n    ----------------------------------------\n    -- Expand_N_Extended_Return_Statement --\n    ----------------------------------------"}, {"sha": "9d244bbf27f852cc721235e80013ab622aafaaac", "filename": "gcc/ada/inline.adb", "status": "modified", "additions": 2998, "deletions": 128, "changes": 3126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/540d86108f31f56f513f542b910b909dd4d6df09/gcc%2Fada%2Finline.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/540d86108f31f56f513f542b910b909dd4d6df09/gcc%2Fada%2Finline.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Finline.adb?ref=540d86108f31f56f513f542b910b909dd4d6df09"}, {"sha": "e6bab07fe86e8f8dcd9dc40fea31eeddcd5cad5a", "filename": "gcc/ada/inline.ads", "status": "modified", "additions": 78, "deletions": 3, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/540d86108f31f56f513f542b910b909dd4d6df09/gcc%2Fada%2Finline.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/540d86108f31f56f513f542b910b909dd4d6df09/gcc%2Fada%2Finline.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Finline.ads?ref=540d86108f31f56f513f542b910b909dd4d6df09", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2013, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -23,7 +23,7 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n---  This module handles two kinds of inlining activity:\n+--  This module handles three kinds of inlining activity:\n \n --  a) Instantiation of generic bodies. This is done unconditionally, after\n --  analysis and expansion of the main unit.\n@@ -35,6 +35,13 @@\n --  of them uses a workpile algorithm, but they are called independently from\n --  Frontend, and thus are not mutually recursive.\n \n+--  Front-end inlining for subprograms marked Inline_Always. This is primarily\n+--  an expansion activity that is performed for performance reasons, and when\n+--  the target does not use the gcc backend.  Inline_Always can also be used\n+--  in the context of GNATprove, to perform source transformations to simplify\n+--  proof obligations. The machinery used in both cases is similar, but there\n+--  are fewer restrictions on the source of subprograms in the latter case.\n+\n with Alloc;\n with Opt;    use Opt;\n with Sem;    use Sem;\n@@ -122,7 +129,11 @@ package Inline is\n      Table_Increment      => Alloc.Pending_Instantiations_Increment,\n      Table_Name           => \"Pending_Descriptor\");\n \n-   -----------------\n+   Inlined_Calls : Elist_Id := No_Elist;\n+   Backend_Calls : Elist_Id := No_Elist;\n+   --  List of frontend inlined calls and inline calls passed to the backend\n+\n+-----------------\n    -- Subprograms --\n    -----------------\n \n@@ -147,12 +158,76 @@ package Inline is\n    --  At end of compilation, analyze the bodies of all units that contain\n    --  inlined subprograms that are actually called.\n \n+   procedure Build_Body_To_Inline (N : Node_Id; Subp : Entity_Id);\n+   --  If a subprogram has pragma Inline and inlining is active, use generic\n+   --  machinery to build an unexpanded body for the subprogram. This body is\n+   --  subsequently used for inline expansions at call sites. If subprogram can\n+   --  be inlined (depending on size and nature of local declarations) this\n+   --  function returns true. Otherwise subprogram body is treated normally.\n+   --  If proper warnings are enabled and the subprogram contains a construct\n+   --  that cannot be inlined, the offending construct is flagged accordingly.\n+\n+   procedure Cannot_Inline\n+      (Msg        : String;\n+      N          : Node_Id;\n+      Subp       : Entity_Id;\n+      Is_Serious : Boolean := False);\n+   --  This procedure is called if the node N, an instance of a call to\n+   --  subprogram Subp, cannot be inlined. Msg is the message to be issued,\n+   --  which ends with ? (it does not end with ?p?, this routine takes care of\n+   --  the need to change ? to ?p?). Temporarily the behavior of this routine\n+   --  depends on the value of -gnatd.k:\n+   --\n+   --    * If -gnatd.k is not set (ie. old inlining model) then if Subp has\n+   --      a pragma Always_Inlined, then an error message is issued (by\n+   --      removing the last character of Msg). If Subp is not Always_Inlined,\n+   --      then a warning is issued if the flag Ineffective_Inline_Warnings\n+   --      is set, adding ?p to the msg, and if not, the call has no effect.\n+   --\n+   --    * If -gnatd.k is set (ie. new inlining model) then:\n+   --      - If Is_Serious is true, then an error is reported (by removing the\n+   --        last character of Msg);\n+   --\n+   --      - otherwise:\n+   --\n+   --        * Compiling without optimizations if Subp has a pragma\n+   --          Always_Inlined, then an error message is issued; if Subp is\n+   --          not Always_Inlined, then a warning is issued if the flag\n+   --          Ineffective_Inline_Warnings is set (adding p?), and if not,\n+   --          the call has no effect.\n+   --\n+   --        * Compiling with optimizations then a warning is issued if the\n+   --          flag Ineffective_Inline_Warnings is set (adding p?); otherwise\n+   --          no effect since inlining may be performed by the backend.\n+\n+   procedure Check_And_Build_Body_To_Inline\n+     (N       : Node_Id;\n+      Spec_Id : Entity_Id;\n+      Body_Id : Entity_Id);\n+   --  Spec_Id and Body_Id are the entities of the specification and body of\n+   --  the subprogram body N. If N can be inlined by the frontend (supported\n+   --  cases documented in Check_Body_To_Inline) then build the body-to-inline\n+   --  associated with N and attach it to the declaration node of Spec_Id.\n+\n    procedure Check_Body_For_Inlining (N : Node_Id; P : Entity_Id);\n    --  If front-end inlining is enabled and a package declaration contains\n    --  inlined subprograms, load and compile the package body to collect the\n    --  bodies of these subprograms, so they are available to inline calls.\n    --  N is the compilation unit for the package.\n \n+   procedure Expand_Inlined_Call\n+    (N         : Node_Id;\n+     Subp      : Entity_Id;\n+     Orig_Subp : Entity_Id);\n+   --  If called subprogram can be inlined by the front-end, retrieve the\n+   --  analyzed body, replace formals with actuals and expand call in place.\n+   --  Generate thunks for actuals that are expressions, and insert the\n+   --  corresponding constant declarations before the call. If the original\n+   --  call is to a derived operation, the return type is the one of the\n+   --  derived operation, but the body is that of the original, so return\n+   --  expressions in the body must be converted to the desired type (which\n+   --  is simply not noted in the tree without inline expansion).\n+\n    procedure Remove_Dead_Instance (N : Node_Id);\n    --  If an instantiation appears in unreachable code, delete the pending\n    --  body instance."}, {"sha": "b452124be587c322099faeaf071db3931002e6fe", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 1, "deletions": 1752, "changes": 1753, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/540d86108f31f56f513f542b910b909dd4d6df09/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/540d86108f31f56f513f542b910b909dd4d6df09/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=540d86108f31f56f513f542b910b909dd4d6df09", "patch": "@@ -40,6 +40,7 @@ with Exp_Tss;  use Exp_Tss;\n with Exp_Util; use Exp_Util;\n with Fname;    use Fname;\n with Freeze;   use Freeze;\n+with Inline;   use Inline;\n with Itypes;   use Itypes;\n with Lib.Xref; use Lib.Xref;\n with Layout;   use Layout;\n@@ -127,27 +128,9 @@ package body Sem_Ch6 is\n    --  Analyze a generic subprogram body. N is the body to be analyzed, and\n    --  Gen_Id is the defining entity Id for the corresponding spec.\n \n-   procedure Build_Body_To_Inline (N : Node_Id; Subp : Entity_Id);\n-   --  If a subprogram has pragma Inline and inlining is active, use generic\n-   --  machinery to build an unexpanded body for the subprogram. This body is\n-   --  subsequently used for inline expansions at call sites. If subprogram can\n-   --  be inlined (depending on size and nature of local declarations) this\n-   --  function returns true. Otherwise subprogram body is treated normally.\n-   --  If proper warnings are enabled and the subprogram contains a construct\n-   --  that cannot be inlined, the offending construct is flagged accordingly.\n-\n    function Can_Override_Operator (Subp : Entity_Id) return Boolean;\n    --  Returns true if Subp can override a predefined operator.\n \n-   procedure Check_And_Build_Body_To_Inline\n-     (N       : Node_Id;\n-      Spec_Id : Entity_Id;\n-      Body_Id : Entity_Id);\n-   --  Spec_Id and Body_Id are the entities of the specification and body of\n-   --  the subprogram body N. If N can be inlined by the frontend (supported\n-   --  cases documented in Check_Body_To_Inline) then build the body-to-inline\n-   --  associated with N and attach it to the declaration node of Spec_Id.\n-\n    procedure Check_Conformance\n      (New_Id                   : Entity_Id;\n       Old_Id                   : Entity_Id;\n@@ -4213,1740 +4196,6 @@ package body Sem_Ch6 is\n       return Designator;\n    end Analyze_Subprogram_Specification;\n \n-   --------------------------\n-   -- Build_Body_To_Inline --\n-   --------------------------\n-\n-   procedure Build_Body_To_Inline (N : Node_Id; Subp : Entity_Id) is\n-      Decl            : constant Node_Id := Unit_Declaration_Node (Subp);\n-      Original_Body   : Node_Id;\n-      Body_To_Analyze : Node_Id;\n-      Max_Size        : constant := 10;\n-      Stat_Count      : Integer := 0;\n-\n-      function Has_Excluded_Declaration (Decls : List_Id) return Boolean;\n-      --  Check for declarations that make inlining not worthwhile\n-\n-      function Has_Excluded_Statement   (Stats : List_Id) return Boolean;\n-      --  Check for statements that make inlining not worthwhile: any tasking\n-      --  statement, nested at any level. Keep track of total number of\n-      --  elementary statements, as a measure of acceptable size.\n-\n-      function Has_Pending_Instantiation return Boolean;\n-      --  If some enclosing body contains instantiations that appear before the\n-      --  corresponding generic body, the enclosing body has a freeze node so\n-      --  that it can be elaborated after the generic itself. This might\n-      --  conflict with subsequent inlinings, so that it is unsafe to try to\n-      --  inline in such a case.\n-\n-      function Has_Single_Return return Boolean;\n-      --  In general we cannot inline functions that return unconstrained type.\n-      --  However, we can handle such functions if all return statements return\n-      --  a local variable that is the only declaration in the body of the\n-      --  function. In that case the call can be replaced by that local\n-      --  variable as is done for other inlined calls.\n-\n-      procedure Remove_Pragmas;\n-      --  A pragma Unreferenced or pragma Unmodified that mentions a formal\n-      --  parameter has no meaning when the body is inlined and the formals\n-      --  are rewritten. Remove it from body to inline. The analysis of the\n-      --  non-inlined body will handle the pragma properly.\n-\n-      function Uses_Secondary_Stack (Bod : Node_Id) return Boolean;\n-      --  If the body of the subprogram includes a call that returns an\n-      --  unconstrained type, the secondary stack is involved, and it\n-      --  is not worth inlining.\n-\n-      ------------------------------\n-      -- Has_Excluded_Declaration --\n-      ------------------------------\n-\n-      function Has_Excluded_Declaration (Decls : List_Id) return Boolean is\n-         D : Node_Id;\n-\n-         function Is_Unchecked_Conversion (D : Node_Id) return Boolean;\n-         --  Nested subprograms make a given body ineligible for inlining, but\n-         --  we make an exception for instantiations of unchecked conversion.\n-         --  The body has not been analyzed yet, so check the name, and verify\n-         --  that the visible entity with that name is the predefined unit.\n-\n-         -----------------------------\n-         -- Is_Unchecked_Conversion --\n-         -----------------------------\n-\n-         function Is_Unchecked_Conversion (D : Node_Id) return Boolean is\n-            Id   : constant Node_Id := Name (D);\n-            Conv : Entity_Id;\n-\n-         begin\n-            if Nkind (Id) = N_Identifier\n-              and then Chars (Id) = Name_Unchecked_Conversion\n-            then\n-               Conv := Current_Entity (Id);\n-\n-            elsif Nkind_In (Id, N_Selected_Component, N_Expanded_Name)\n-              and then Chars (Selector_Name (Id)) = Name_Unchecked_Conversion\n-            then\n-               Conv := Current_Entity (Selector_Name (Id));\n-            else\n-               return False;\n-            end if;\n-\n-            return Present (Conv)\n-              and then Is_Predefined_File_Name\n-                         (Unit_File_Name (Get_Source_Unit (Conv)))\n-              and then Is_Intrinsic_Subprogram (Conv);\n-         end Is_Unchecked_Conversion;\n-\n-      --  Start of processing for Has_Excluded_Declaration\n-\n-      begin\n-         D := First (Decls);\n-         while Present (D) loop\n-            if (Nkind (D) = N_Function_Instantiation\n-                  and then not Is_Unchecked_Conversion (D))\n-              or else Nkind_In (D, N_Protected_Type_Declaration,\n-                                   N_Package_Declaration,\n-                                   N_Package_Instantiation,\n-                                   N_Subprogram_Body,\n-                                   N_Procedure_Instantiation,\n-                                   N_Task_Type_Declaration)\n-            then\n-               Cannot_Inline\n-                 (\"cannot inline & (non-allowed declaration)?\", D, Subp);\n-               return True;\n-            end if;\n-\n-            Next (D);\n-         end loop;\n-\n-         return False;\n-      end Has_Excluded_Declaration;\n-\n-      ----------------------------\n-      -- Has_Excluded_Statement --\n-      ----------------------------\n-\n-      function Has_Excluded_Statement (Stats : List_Id) return Boolean is\n-         S : Node_Id;\n-         E : Node_Id;\n-\n-      begin\n-         S := First (Stats);\n-         while Present (S) loop\n-            Stat_Count := Stat_Count + 1;\n-\n-            if Nkind_In (S, N_Abort_Statement,\n-                            N_Asynchronous_Select,\n-                            N_Conditional_Entry_Call,\n-                            N_Delay_Relative_Statement,\n-                            N_Delay_Until_Statement,\n-                            N_Selective_Accept,\n-                            N_Timed_Entry_Call)\n-            then\n-               Cannot_Inline\n-                 (\"cannot inline & (non-allowed statement)?\", S, Subp);\n-               return True;\n-\n-            elsif Nkind (S) = N_Block_Statement then\n-               if Present (Declarations (S))\n-                 and then Has_Excluded_Declaration (Declarations (S))\n-               then\n-                  return True;\n-\n-               elsif Present (Handled_Statement_Sequence (S))\n-                  and then\n-                    (Present\n-                      (Exception_Handlers (Handled_Statement_Sequence (S)))\n-                     or else\n-                       Has_Excluded_Statement\n-                         (Statements (Handled_Statement_Sequence (S))))\n-               then\n-                  return True;\n-               end if;\n-\n-            elsif Nkind (S) = N_Case_Statement then\n-               E := First (Alternatives (S));\n-               while Present (E) loop\n-                  if Has_Excluded_Statement (Statements (E)) then\n-                     return True;\n-                  end if;\n-\n-                  Next (E);\n-               end loop;\n-\n-            elsif Nkind (S) = N_If_Statement then\n-               if Has_Excluded_Statement (Then_Statements (S)) then\n-                  return True;\n-               end if;\n-\n-               if Present (Elsif_Parts (S)) then\n-                  E := First (Elsif_Parts (S));\n-                  while Present (E) loop\n-                     if Has_Excluded_Statement (Then_Statements (E)) then\n-                        return True;\n-                     end if;\n-\n-                     Next (E);\n-                  end loop;\n-               end if;\n-\n-               if Present (Else_Statements (S))\n-                 and then Has_Excluded_Statement (Else_Statements (S))\n-               then\n-                  return True;\n-               end if;\n-\n-            elsif Nkind (S) = N_Loop_Statement\n-              and then Has_Excluded_Statement (Statements (S))\n-            then\n-               return True;\n-\n-            elsif Nkind (S) = N_Extended_Return_Statement then\n-               if Has_Excluded_Statement\n-                  (Statements (Handled_Statement_Sequence (S)))\n-                 or else Present\n-                   (Exception_Handlers (Handled_Statement_Sequence (S)))\n-               then\n-                  return True;\n-               end if;\n-            end if;\n-\n-            Next (S);\n-         end loop;\n-\n-         return False;\n-      end Has_Excluded_Statement;\n-\n-      -------------------------------\n-      -- Has_Pending_Instantiation --\n-      -------------------------------\n-\n-      function Has_Pending_Instantiation return Boolean is\n-         S : Entity_Id;\n-\n-      begin\n-         S := Current_Scope;\n-         while Present (S) loop\n-            if Is_Compilation_Unit (S)\n-              or else Is_Child_Unit (S)\n-            then\n-               return False;\n-\n-            elsif Ekind (S) = E_Package\n-              and then Has_Forward_Instantiation (S)\n-            then\n-               return True;\n-            end if;\n-\n-            S := Scope (S);\n-         end loop;\n-\n-         return False;\n-      end Has_Pending_Instantiation;\n-\n-      ------------------------\n-      --  Has_Single_Return --\n-      ------------------------\n-\n-      function Has_Single_Return return Boolean is\n-         Return_Statement : Node_Id := Empty;\n-\n-         function Check_Return (N : Node_Id) return Traverse_Result;\n-\n-         ------------------\n-         -- Check_Return --\n-         ------------------\n-\n-         function Check_Return (N : Node_Id) return Traverse_Result is\n-         begin\n-            if Nkind (N) = N_Simple_Return_Statement then\n-               if Present (Expression (N))\n-                 and then Is_Entity_Name (Expression (N))\n-               then\n-                  if No (Return_Statement) then\n-                     Return_Statement := N;\n-                     return OK;\n-\n-                  elsif Chars (Expression (N)) =\n-                        Chars (Expression (Return_Statement))\n-                  then\n-                     return OK;\n-\n-                  else\n-                     return Abandon;\n-                  end if;\n-\n-               --  A return statement within an extended return is a noop\n-               --  after inlining.\n-\n-               elsif No (Expression (N))\n-                 and then Nkind (Parent (Parent (N))) =\n-                                         N_Extended_Return_Statement\n-               then\n-                  return OK;\n-\n-               else\n-                  --  Expression has wrong form\n-\n-                  return Abandon;\n-               end if;\n-\n-            --  We can only inline a build-in-place function if\n-            --  it has a single extended return.\n-\n-            elsif Nkind (N) = N_Extended_Return_Statement then\n-               if No (Return_Statement) then\n-                  Return_Statement := N;\n-                  return OK;\n-\n-               else\n-                  return Abandon;\n-               end if;\n-\n-            else\n-               return OK;\n-            end if;\n-         end Check_Return;\n-\n-         function Check_All_Returns is new Traverse_Func (Check_Return);\n-\n-      --  Start of processing for Has_Single_Return\n-\n-      begin\n-         if Check_All_Returns (N) /= OK then\n-            return False;\n-\n-         elsif Nkind (Return_Statement) = N_Extended_Return_Statement then\n-            return True;\n-\n-         else\n-            return Present (Declarations (N))\n-              and then Present (First (Declarations (N)))\n-              and then Chars (Expression (Return_Statement)) =\n-                       Chars (Defining_Identifier (First (Declarations (N))));\n-         end if;\n-      end Has_Single_Return;\n-\n-      --------------------\n-      -- Remove_Pragmas --\n-      --------------------\n-\n-      procedure Remove_Pragmas is\n-         Decl : Node_Id;\n-         Nxt  : Node_Id;\n-\n-      begin\n-         Decl := First (Declarations (Body_To_Analyze));\n-         while Present (Decl) loop\n-            Nxt := Next (Decl);\n-\n-            if Nkind (Decl) = N_Pragma\n-              and then Nam_In (Pragma_Name (Decl), Name_Unreferenced,\n-                                                   Name_Unmodified)\n-            then\n-               Remove (Decl);\n-            end if;\n-\n-            Decl := Nxt;\n-         end loop;\n-      end Remove_Pragmas;\n-\n-      --------------------------\n-      -- Uses_Secondary_Stack --\n-      --------------------------\n-\n-      function Uses_Secondary_Stack (Bod : Node_Id) return Boolean is\n-         function Check_Call (N : Node_Id) return Traverse_Result;\n-         --  Look for function calls that return an unconstrained type\n-\n-         ----------------\n-         -- Check_Call --\n-         ----------------\n-\n-         function Check_Call (N : Node_Id) return Traverse_Result is\n-         begin\n-            if Nkind (N) = N_Function_Call\n-              and then Is_Entity_Name (Name (N))\n-              and then Is_Composite_Type (Etype (Entity (Name (N))))\n-              and then not Is_Constrained (Etype (Entity (Name (N))))\n-            then\n-               Cannot_Inline\n-                 (\"cannot inline & (call returns unconstrained type)?\",\n-                  N, Subp);\n-               return Abandon;\n-            else\n-               return OK;\n-            end if;\n-         end Check_Call;\n-\n-         function Check_Calls is new Traverse_Func (Check_Call);\n-\n-      begin\n-         return Check_Calls (Bod) = Abandon;\n-      end Uses_Secondary_Stack;\n-\n-   --  Start of processing for Build_Body_To_Inline\n-\n-   begin\n-      --  Return immediately if done already\n-\n-      if Nkind (Decl) = N_Subprogram_Declaration\n-        and then Present (Body_To_Inline (Decl))\n-      then\n-         return;\n-\n-      --  Functions that return unconstrained composite types require\n-      --  secondary stack handling, and cannot currently be inlined, unless\n-      --  all return statements return a local variable that is the first\n-      --  local declaration in the body.\n-\n-      elsif Ekind (Subp) = E_Function\n-        and then not Is_Scalar_Type (Etype (Subp))\n-        and then not Is_Access_Type (Etype (Subp))\n-        and then not Is_Constrained (Etype (Subp))\n-      then\n-         if not Has_Single_Return then\n-            Cannot_Inline\n-              (\"cannot inline & (unconstrained return type)?\", N, Subp);\n-            return;\n-         end if;\n-\n-      --  Ditto for functions that return controlled types, where controlled\n-      --  actions interfere in complex ways with inlining.\n-\n-      elsif Ekind (Subp) = E_Function\n-        and then Needs_Finalization (Etype (Subp))\n-      then\n-         Cannot_Inline\n-           (\"cannot inline & (controlled return type)?\", N, Subp);\n-         return;\n-      end if;\n-\n-      if Present (Declarations (N))\n-        and then Has_Excluded_Declaration (Declarations (N))\n-      then\n-         return;\n-      end if;\n-\n-      if Present (Handled_Statement_Sequence (N)) then\n-         if Present (Exception_Handlers (Handled_Statement_Sequence (N))) then\n-            Cannot_Inline\n-              (\"cannot inline& (exception handler)?\",\n-               First (Exception_Handlers (Handled_Statement_Sequence (N))),\n-               Subp);\n-            return;\n-         elsif\n-           Has_Excluded_Statement\n-             (Statements (Handled_Statement_Sequence (N)))\n-         then\n-            return;\n-         end if;\n-      end if;\n-\n-      --  We do not inline a subprogram  that is too large, unless it is\n-      --  marked Inline_Always. This pragma does not suppress the other\n-      --  checks on inlining (forbidden declarations, handlers, etc).\n-\n-      if Stat_Count > Max_Size\n-        and then not Has_Pragma_Inline_Always (Subp)\n-      then\n-         Cannot_Inline (\"cannot inline& (body too large)?\", N, Subp);\n-         return;\n-      end if;\n-\n-      if Has_Pending_Instantiation then\n-         Cannot_Inline\n-           (\"cannot inline& (forward instance within enclosing body)?\",\n-             N, Subp);\n-         return;\n-      end if;\n-\n-      --  Within an instance, the body to inline must be treated as a nested\n-      --  generic, so that the proper global references are preserved.\n-\n-      --  Note that we do not do this at the library level, because it is not\n-      --  needed, and furthermore this causes trouble if front end inlining\n-      --  is activated (-gnatN).\n-\n-      if In_Instance and then Scope (Current_Scope) /= Standard_Standard then\n-         Save_Env (Scope (Current_Scope), Scope (Current_Scope));\n-         Original_Body := Copy_Generic_Node (N, Empty, True);\n-      else\n-         Original_Body := Copy_Separate_Tree (N);\n-      end if;\n-\n-      --  We need to capture references to the formals in order to substitute\n-      --  the actuals at the point of inlining, i.e. instantiation. To treat\n-      --  the formals as globals to the body to inline, we nest it within\n-      --  a dummy parameterless subprogram, declared within the real one.\n-      --  To avoid generating an internal name (which is never public, and\n-      --  which affects serial numbers of other generated names), we use\n-      --  an internal symbol that cannot conflict with user declarations.\n-\n-      Set_Parameter_Specifications (Specification (Original_Body), No_List);\n-      Set_Defining_Unit_Name\n-        (Specification (Original_Body),\n-          Make_Defining_Identifier (Sloc (N), Name_uParent));\n-      Set_Corresponding_Spec (Original_Body, Empty);\n-\n-      Body_To_Analyze := Copy_Generic_Node (Original_Body, Empty, False);\n-\n-      --  Set return type of function, which is also global and does not need\n-      --  to be resolved.\n-\n-      if Ekind (Subp) = E_Function then\n-         Set_Result_Definition (Specification (Body_To_Analyze),\n-           New_Occurrence_Of (Etype (Subp), Sloc (N)));\n-      end if;\n-\n-      if No (Declarations (N)) then\n-         Set_Declarations (N, New_List (Body_To_Analyze));\n-      else\n-         Append (Body_To_Analyze, Declarations (N));\n-      end if;\n-\n-      Expander_Mode_Save_And_Set (False);\n-      Remove_Pragmas;\n-\n-      Analyze (Body_To_Analyze);\n-      Push_Scope (Defining_Entity (Body_To_Analyze));\n-      Save_Global_References (Original_Body);\n-      End_Scope;\n-      Remove (Body_To_Analyze);\n-\n-      Expander_Mode_Restore;\n-\n-      --  Restore environment if previously saved\n-\n-      if In_Instance and then Scope (Current_Scope) /= Standard_Standard then\n-         Restore_Env;\n-      end if;\n-\n-      --  If secondary stk used there is no point in inlining. We have\n-      --  already issued the warning in this case, so nothing to do.\n-\n-      if Uses_Secondary_Stack (Body_To_Analyze) then\n-         return;\n-      end if;\n-\n-      Set_Body_To_Inline (Decl, Original_Body);\n-      Set_Ekind (Defining_Entity (Original_Body), Ekind (Subp));\n-      Set_Is_Inlined (Subp);\n-   end Build_Body_To_Inline;\n-\n-   -------------------\n-   -- Cannot_Inline --\n-   -------------------\n-\n-   procedure Cannot_Inline\n-     (Msg        : String;\n-      N          : Node_Id;\n-      Subp       : Entity_Id;\n-      Is_Serious : Boolean := False)\n-   is\n-   begin\n-      pragma Assert (Msg (Msg'Last) = '?');\n-\n-      --  Old semantics\n-\n-      if not Debug_Flag_Dot_K then\n-\n-         --  Do not emit warning if this is a predefined unit which is not\n-         --  the main unit. With validity checks enabled, some predefined\n-         --  subprograms may contain nested subprograms and become ineligible\n-         --  for inlining.\n-\n-         if Is_Predefined_File_Name (Unit_File_Name (Get_Source_Unit (Subp)))\n-           and then not In_Extended_Main_Source_Unit (Subp)\n-         then\n-            null;\n-\n-         elsif Has_Pragma_Inline_Always (Subp) then\n-\n-            --  Remove last character (question mark) to make this into an\n-            --  error, because the Inline_Always pragma cannot be obeyed.\n-\n-            Error_Msg_NE (Msg (Msg'First .. Msg'Last - 1), N, Subp);\n-\n-         elsif Ineffective_Inline_Warnings then\n-            Error_Msg_NE (Msg & \"p?\", N, Subp);\n-         end if;\n-\n-         return;\n-\n-      --  New semantics\n-\n-      elsif Is_Serious then\n-\n-         --  Remove last character (question mark) to make this into an error.\n-\n-         Error_Msg_NE (Msg (Msg'First .. Msg'Last - 1), N, Subp);\n-\n-      elsif Optimization_Level = 0 then\n-\n-         --  Do not emit warning if this is a predefined unit which is not\n-         --  the main unit. This behavior is currently provided for backward\n-         --  compatibility but it will be removed when we enforce the\n-         --  strictness of the new rules.\n-\n-         if Is_Predefined_File_Name (Unit_File_Name (Get_Source_Unit (Subp)))\n-           and then not In_Extended_Main_Source_Unit (Subp)\n-         then\n-            null;\n-\n-         elsif Has_Pragma_Inline_Always (Subp) then\n-\n-            --  Emit a warning if this is a call to a runtime subprogram\n-            --  which is located inside a generic. Previously this call\n-            --  was silently skipped.\n-\n-            if Is_Generic_Instance (Subp) then\n-               declare\n-                  Gen_P : constant Entity_Id := Generic_Parent (Parent (Subp));\n-               begin\n-                  if Is_Predefined_File_Name\n-                    (Unit_File_Name (Get_Source_Unit (Gen_P)))\n-                  then\n-                     Set_Is_Inlined (Subp, False);\n-                     Error_Msg_NE (Msg & \"p?\", N, Subp);\n-                     return;\n-                  end if;\n-               end;\n-            end if;\n-\n-            --  Remove last character (question mark) to make this into an\n-            --  error, because the Inline_Always pragma cannot be obeyed.\n-\n-            Error_Msg_NE (Msg (Msg'First .. Msg'Last - 1), N, Subp);\n-\n-         else pragma Assert (Front_End_Inlining);\n-            Set_Is_Inlined (Subp, False);\n-\n-            --  When inlining cannot take place we must issue an error.\n-            --  For backward compatibility we still report a warning.\n-\n-            if Ineffective_Inline_Warnings then\n-               Error_Msg_NE (Msg & \"p?\", N, Subp);\n-            end if;\n-         end if;\n-\n-      --  Compiling with optimizations enabled it is too early to report\n-      --  problems since the backend may still perform inlining. In order\n-      --  to report unhandled inlinings the program must be compiled with\n-      --  -Winline and the error is reported by the backend.\n-\n-      else\n-         null;\n-      end if;\n-   end Cannot_Inline;\n-\n-   ------------------------------------\n-   -- Check_And_Build_Body_To_Inline --\n-   ------------------------------------\n-\n-   procedure Check_And_Build_Body_To_Inline\n-     (N       : Node_Id;\n-      Spec_Id : Entity_Id;\n-      Body_Id : Entity_Id)\n-   is\n-      procedure Build_Body_To_Inline (N : Node_Id; Spec_Id : Entity_Id);\n-      --  Use generic machinery to build an unexpanded body for the subprogram.\n-      --  This body is subsequently used for inline expansions at call sites.\n-\n-      function Can_Split_Unconstrained_Function (N : Node_Id) return Boolean;\n-      --  Return true if we generate code for the function body N, the function\n-      --  body N has no local declarations and its unique statement is a single\n-      --  extended return statement with a handled statements sequence.\n-\n-      function Check_Body_To_Inline\n-        (N    : Node_Id;\n-         Subp : Entity_Id) return Boolean;\n-      --  N is the N_Subprogram_Body of Subp. Return true if Subp can be\n-      --  inlined by the frontend. These are the rules:\n-      --    * At -O0 use fe inlining when inline_always is specified except if\n-      --      the function returns a controlled type.\n-      --    * At other optimization levels use the fe inlining for both inline\n-      --      and inline_always in the following cases:\n-      --       - function returning a known at compile time constant\n-      --       - function returning a call to an intrinsic function\n-      --       - function returning an unconstrained type (see Can_Split\n-      --         Unconstrained_Function).\n-      --       - function returning a call to a frontend-inlined function\n-      --      Use the back-end mechanism otherwise\n-      --\n-      --  In addition, in the following cases the function cannot be inlined by\n-      --  the frontend:\n-      --    - functions that uses the secondary stack\n-      --    - functions that have declarations of:\n-      --         - Concurrent types\n-      --         - Packages\n-      --         - Instantiations\n-      --         - Subprograms\n-      --    - functions that have some of the following statements:\n-      --         - abort\n-      --         - asynchronous-select\n-      --         - conditional-entry-call\n-      --         - delay-relative\n-      --         - delay-until\n-      --         - selective-accept\n-      --         - timed-entry-call\n-      --    - functions that have exception handlers\n-      --    - functions that have some enclosing body containing instantiations\n-      --      that appear before the corresponding generic body.\n-\n-      procedure Generate_Body_To_Inline\n-        (N              : Node_Id;\n-         Body_To_Inline : out Node_Id);\n-      --  Generate a parameterless duplicate of subprogram body N. Occurrences\n-      --  of pragmas referencing the formals are removed since they have no\n-      --  meaning when the body is inlined and the formals are rewritten (the\n-      --  analysis of the non-inlined body will handle these pragmas properly).\n-      --  A new internal name is associated with Body_To_Inline.\n-\n-      procedure Split_Unconstrained_Function\n-        (N       : Node_Id;\n-         Spec_Id : Entity_Id);\n-      --  N is an inlined function body that returns an unconstrained type and\n-      --  has a single extended return statement. Split N in two subprograms:\n-      --  a procedure P' and a function F'. The formals of P' duplicate the\n-      --  formals of N plus an extra formal which is used return a value;\n-      --  its body is composed by the declarations and list of statements\n-      --  of the extended return statement of N.\n-\n-      --------------------------\n-      -- Build_Body_To_Inline --\n-      --------------------------\n-\n-      procedure Build_Body_To_Inline (N : Node_Id; Spec_Id : Entity_Id) is\n-         Decl            : constant Node_Id := Unit_Declaration_Node (Spec_Id);\n-         Original_Body   : Node_Id;\n-         Body_To_Analyze : Node_Id;\n-\n-      begin\n-         pragma Assert (Current_Scope = Spec_Id);\n-\n-         --  Within an instance, the body to inline must be treated as a nested\n-         --  generic, so that the proper global references are preserved. We\n-         --  do not do this at the library level, because it is not needed, and\n-         --  furthermore this causes trouble if front end inlining is activated\n-         --  (-gnatN).\n-\n-         if In_Instance\n-           and then Scope (Current_Scope) /= Standard_Standard\n-         then\n-            Save_Env (Scope (Current_Scope), Scope (Current_Scope));\n-         end if;\n-\n-         --  We need to capture references to the formals in order\n-         --  to substitute the actuals at the point of inlining, i.e.\n-         --  instantiation. To treat the formals as globals to the body to\n-         --  inline, we nest it within a dummy parameterless subprogram,\n-         --  declared within the real one.\n-\n-         Generate_Body_To_Inline (N, Original_Body);\n-         Body_To_Analyze := Copy_Generic_Node (Original_Body, Empty, False);\n-\n-         --  Set return type of function, which is also global and does not\n-         --  need to be resolved.\n-\n-         if Ekind (Spec_Id) = E_Function then\n-            Set_Result_Definition (Specification (Body_To_Analyze),\n-              New_Occurrence_Of (Etype (Spec_Id), Sloc (N)));\n-         end if;\n-\n-         if No (Declarations (N)) then\n-            Set_Declarations (N, New_List (Body_To_Analyze));\n-         else\n-            Append_To (Declarations (N), Body_To_Analyze);\n-         end if;\n-\n-         Preanalyze (Body_To_Analyze);\n-\n-         Push_Scope (Defining_Entity (Body_To_Analyze));\n-         Save_Global_References (Original_Body);\n-         End_Scope;\n-         Remove (Body_To_Analyze);\n-\n-         --  Restore environment if previously saved\n-\n-         if In_Instance\n-           and then Scope (Current_Scope) /= Standard_Standard\n-         then\n-            Restore_Env;\n-         end if;\n-\n-         pragma Assert (No (Body_To_Inline (Decl)));\n-         Set_Body_To_Inline (Decl, Original_Body);\n-         Set_Ekind (Defining_Entity (Original_Body), Ekind (Spec_Id));\n-      end Build_Body_To_Inline;\n-\n-      --------------------------\n-      -- Check_Body_To_Inline --\n-      --------------------------\n-\n-      function Check_Body_To_Inline\n-        (N    : Node_Id;\n-         Subp : Entity_Id) return Boolean\n-      is\n-         Max_Size   : constant := 10;\n-         Stat_Count : Integer := 0;\n-\n-         function Has_Excluded_Declaration (Decls : List_Id) return Boolean;\n-         --  Check for declarations that make inlining not worthwhile\n-\n-         function Has_Excluded_Statement   (Stats : List_Id) return Boolean;\n-         --  Check for statements that make inlining not worthwhile: any\n-         --  tasking statement, nested at any level. Keep track of total\n-         --  number of elementary statements, as a measure of acceptable size.\n-\n-         function Has_Pending_Instantiation return Boolean;\n-         --  Return True if some enclosing body contains instantiations that\n-         --  appear before the corresponding generic body.\n-\n-         function Returns_Compile_Time_Constant (N : Node_Id) return Boolean;\n-         --  Return True if all the return statements of the function body N\n-         --  are simple return statements and return a compile time constant\n-\n-         function Returns_Intrinsic_Function_Call (N : Node_Id) return Boolean;\n-         --  Return True if all the return statements of the function body N\n-         --  are simple return statements and return an intrinsic function call\n-\n-         function Uses_Secondary_Stack (N : Node_Id) return Boolean;\n-         --  If the body of the subprogram includes a call that returns an\n-         --  unconstrained type, the secondary stack is involved, and it\n-         --  is not worth inlining.\n-\n-         ------------------------------\n-         -- Has_Excluded_Declaration --\n-         ------------------------------\n-\n-         function Has_Excluded_Declaration (Decls : List_Id) return Boolean is\n-            D : Node_Id;\n-\n-            function Is_Unchecked_Conversion (D : Node_Id) return Boolean;\n-            --  Nested subprograms make a given body ineligible for inlining,\n-            --  but we make an exception for instantiations of unchecked\n-            --  conversion. The body has not been analyzed yet, so check the\n-            --  name, and verify that the visible entity with that name is the\n-            --  predefined unit.\n-\n-            -----------------------------\n-            -- Is_Unchecked_Conversion --\n-            -----------------------------\n-\n-            function Is_Unchecked_Conversion (D : Node_Id) return Boolean is\n-               Id   : constant Node_Id := Name (D);\n-               Conv : Entity_Id;\n-\n-            begin\n-               if Nkind (Id) = N_Identifier\n-                 and then Chars (Id) = Name_Unchecked_Conversion\n-               then\n-                  Conv := Current_Entity (Id);\n-\n-               elsif Nkind_In (Id, N_Selected_Component, N_Expanded_Name)\n-                 and then\n-                   Chars (Selector_Name (Id)) = Name_Unchecked_Conversion\n-               then\n-                  Conv := Current_Entity (Selector_Name (Id));\n-               else\n-                  return False;\n-               end if;\n-\n-               return Present (Conv)\n-                 and then Is_Predefined_File_Name\n-                            (Unit_File_Name (Get_Source_Unit (Conv)))\n-                 and then Is_Intrinsic_Subprogram (Conv);\n-            end Is_Unchecked_Conversion;\n-\n-         --  Start of processing for Has_Excluded_Declaration\n-\n-         begin\n-            D := First (Decls);\n-            while Present (D) loop\n-               if (Nkind (D) = N_Function_Instantiation\n-                   and then not Is_Unchecked_Conversion (D))\n-                 or else Nkind_In (D, N_Protected_Type_Declaration,\n-                                   N_Package_Declaration,\n-                                   N_Package_Instantiation,\n-                                   N_Subprogram_Body,\n-                                   N_Procedure_Instantiation,\n-                                   N_Task_Type_Declaration)\n-               then\n-                  Cannot_Inline\n-                    (\"cannot inline & (non-allowed declaration)?\", D, Subp);\n-\n-                  return True;\n-               end if;\n-\n-               Next (D);\n-            end loop;\n-\n-            return False;\n-         end Has_Excluded_Declaration;\n-\n-         ----------------------------\n-         -- Has_Excluded_Statement --\n-         ----------------------------\n-\n-         function Has_Excluded_Statement (Stats : List_Id) return Boolean is\n-            S : Node_Id;\n-            E : Node_Id;\n-\n-         begin\n-            S := First (Stats);\n-            while Present (S) loop\n-               Stat_Count := Stat_Count + 1;\n-\n-               if Nkind_In (S, N_Abort_Statement,\n-                            N_Asynchronous_Select,\n-                            N_Conditional_Entry_Call,\n-                            N_Delay_Relative_Statement,\n-                            N_Delay_Until_Statement,\n-                            N_Selective_Accept,\n-                            N_Timed_Entry_Call)\n-               then\n-                  Cannot_Inline\n-                    (\"cannot inline & (non-allowed statement)?\", S, Subp);\n-                  return True;\n-\n-               elsif Nkind (S) = N_Block_Statement then\n-                  if Present (Declarations (S))\n-                    and then Has_Excluded_Declaration (Declarations (S))\n-                  then\n-                     return True;\n-\n-                  elsif Present (Handled_Statement_Sequence (S)) then\n-                     if Present\n-                       (Exception_Handlers (Handled_Statement_Sequence (S)))\n-                     then\n-                        Cannot_Inline\n-                          (\"cannot inline& (exception handler)?\",\n-                           First (Exception_Handlers\n-                             (Handled_Statement_Sequence (S))),\n-                           Subp);\n-                        return True;\n-\n-                     elsif Has_Excluded_Statement\n-                       (Statements (Handled_Statement_Sequence (S)))\n-                     then\n-                        return True;\n-                     end if;\n-                  end if;\n-\n-               elsif Nkind (S) = N_Case_Statement then\n-                  E := First (Alternatives (S));\n-                  while Present (E) loop\n-                     if Has_Excluded_Statement (Statements (E)) then\n-                        return True;\n-                     end if;\n-\n-                     Next (E);\n-                  end loop;\n-\n-               elsif Nkind (S) = N_If_Statement then\n-                  if Has_Excluded_Statement (Then_Statements (S)) then\n-                     return True;\n-                  end if;\n-\n-                  if Present (Elsif_Parts (S)) then\n-                     E := First (Elsif_Parts (S));\n-                     while Present (E) loop\n-                        if Has_Excluded_Statement (Then_Statements (E)) then\n-                           return True;\n-                        end if;\n-                        Next (E);\n-                     end loop;\n-                  end if;\n-\n-                  if Present (Else_Statements (S))\n-                    and then Has_Excluded_Statement (Else_Statements (S))\n-                  then\n-                     return True;\n-                  end if;\n-\n-               elsif Nkind (S) = N_Loop_Statement\n-                 and then Has_Excluded_Statement (Statements (S))\n-               then\n-                  return True;\n-\n-               elsif Nkind (S) = N_Extended_Return_Statement then\n-                  if Present (Handled_Statement_Sequence (S))\n-                    and then\n-                      Has_Excluded_Statement\n-                        (Statements (Handled_Statement_Sequence (S)))\n-                  then\n-                     return True;\n-\n-                  elsif Present (Handled_Statement_Sequence (S))\n-                    and then\n-                      Present (Exception_Handlers\n-                               (Handled_Statement_Sequence (S)))\n-                  then\n-                     Cannot_Inline\n-                       (\"cannot inline& (exception handler)?\",\n-                        First (Exception_Handlers\n-                          (Handled_Statement_Sequence (S))),\n-                        Subp);\n-                     return True;\n-                  end if;\n-               end if;\n-\n-               Next (S);\n-            end loop;\n-\n-            return False;\n-         end Has_Excluded_Statement;\n-\n-         -------------------------------\n-         -- Has_Pending_Instantiation --\n-         -------------------------------\n-\n-         function Has_Pending_Instantiation return Boolean is\n-            S : Entity_Id;\n-\n-         begin\n-            S := Current_Scope;\n-            while Present (S) loop\n-               if Is_Compilation_Unit (S)\n-                 or else Is_Child_Unit (S)\n-               then\n-                  return False;\n-\n-               elsif Ekind (S) = E_Package\n-                 and then Has_Forward_Instantiation (S)\n-               then\n-                  return True;\n-               end if;\n-\n-               S := Scope (S);\n-            end loop;\n-\n-            return False;\n-         end Has_Pending_Instantiation;\n-\n-         ------------------------------------\n-         --  Returns_Compile_Time_Constant --\n-         ------------------------------------\n-\n-         function Returns_Compile_Time_Constant (N : Node_Id) return Boolean is\n-\n-            function Check_Return (N : Node_Id) return Traverse_Result;\n-\n-            ------------------\n-            -- Check_Return --\n-            ------------------\n-\n-            function Check_Return (N : Node_Id) return Traverse_Result is\n-            begin\n-               if Nkind (N) = N_Extended_Return_Statement then\n-                  return Abandon;\n-\n-               elsif Nkind (N) = N_Simple_Return_Statement then\n-                  if Present (Expression (N)) then\n-                     declare\n-                        Orig_Expr : constant Node_Id :=\n-                          Original_Node (Expression (N));\n-\n-                     begin\n-                        if Nkind_In (Orig_Expr, N_Integer_Literal,\n-                                     N_Real_Literal,\n-                                     N_Character_Literal)\n-                        then\n-                           return OK;\n-\n-                        elsif Is_Entity_Name (Orig_Expr)\n-                          and then Ekind (Entity (Orig_Expr)) = E_Constant\n-                          and then Is_OK_Static_Expression (Orig_Expr)\n-                        then\n-                           return OK;\n-                        else\n-                           return Abandon;\n-                        end if;\n-                     end;\n-\n-                  --  Expression has wrong form\n-\n-                  else\n-                     return Abandon;\n-                  end if;\n-\n-               --  Continue analyzing statements\n-\n-               else\n-                  return OK;\n-               end if;\n-            end Check_Return;\n-\n-            function Check_All_Returns is new Traverse_Func (Check_Return);\n-\n-            --  Start of processing for Returns_Compile_Time_Constant\n-\n-         begin\n-            return Check_All_Returns (N) = OK;\n-         end Returns_Compile_Time_Constant;\n-\n-         --------------------------------------\n-         --  Returns_Intrinsic_Function_Call --\n-         --------------------------------------\n-\n-         function Returns_Intrinsic_Function_Call\n-           (N : Node_Id) return Boolean\n-         is\n-            function Check_Return (N : Node_Id) return Traverse_Result;\n-\n-            ------------------\n-            -- Check_Return --\n-            ------------------\n-\n-            function Check_Return (N : Node_Id) return Traverse_Result is\n-            begin\n-               if Nkind (N) = N_Extended_Return_Statement then\n-                  return Abandon;\n-\n-               elsif Nkind (N) = N_Simple_Return_Statement then\n-                  if Present (Expression (N)) then\n-                     declare\n-                        Orig_Expr : constant Node_Id :=\n-                                      Original_Node (Expression (N));\n-\n-                     begin\n-                        if Nkind (Orig_Expr) in N_Op\n-                          and then Is_Intrinsic_Subprogram (Entity (Orig_Expr))\n-                        then\n-                           return OK;\n-\n-                        elsif Nkind (Orig_Expr) in N_Has_Entity\n-                          and then Present (Entity (Orig_Expr))\n-                          and then Ekind (Entity (Orig_Expr)) = E_Function\n-                          and then Is_Inlined (Entity (Orig_Expr))\n-                        then\n-                           return OK;\n-\n-                        elsif Nkind (Orig_Expr) in N_Has_Entity\n-                          and then Present (Entity (Orig_Expr))\n-                          and then Is_Intrinsic_Subprogram (Entity (Orig_Expr))\n-                        then\n-                           return OK;\n-\n-                        else\n-                           return Abandon;\n-                        end if;\n-                     end;\n-\n-                  --  Expression has wrong form\n-\n-                  else\n-                     return Abandon;\n-                  end if;\n-\n-               --  Continue analyzing statements\n-\n-               else\n-                  return OK;\n-               end if;\n-            end Check_Return;\n-\n-            function Check_All_Returns is new Traverse_Func (Check_Return);\n-\n-         --  Start of processing for Returns_Intrinsic_Function_Call\n-\n-         begin\n-            return Check_All_Returns (N) = OK;\n-         end Returns_Intrinsic_Function_Call;\n-\n-         --------------------------\n-         -- Uses_Secondary_Stack --\n-         --------------------------\n-\n-         function Uses_Secondary_Stack (N : Node_Id) return Boolean is\n-\n-            function Check_Call (N : Node_Id) return Traverse_Result;\n-            --  Look for function calls that return an unconstrained type\n-\n-            ----------------\n-            -- Check_Call --\n-            ----------------\n-\n-            function Check_Call (N : Node_Id) return Traverse_Result is\n-            begin\n-               if Nkind (N) = N_Function_Call\n-                 and then Is_Entity_Name (Name (N))\n-                 and then Is_Composite_Type (Etype (Entity (Name (N))))\n-                 and then not Is_Constrained (Etype (Entity (Name (N))))\n-               then\n-                  Cannot_Inline\n-                    (\"cannot inline & (call returns unconstrained type)?\",\n-                     N, Subp);\n-\n-                  return Abandon;\n-               else\n-                  return OK;\n-               end if;\n-            end Check_Call;\n-\n-            function Check_Calls is new Traverse_Func (Check_Call);\n-\n-         --  Start of processing for Uses_Secondary_Stack\n-\n-         begin\n-            return Check_Calls (N) = Abandon;\n-         end Uses_Secondary_Stack;\n-\n-         --  Local variables\n-\n-         Decl       : constant Node_Id := Unit_Declaration_Node (Spec_Id);\n-         May_Inline : constant Boolean :=\n-                        Has_Pragma_Inline_Always (Spec_Id)\n-                          or else (Has_Pragma_Inline (Spec_Id)\n-                                    and then ((Optimization_Level > 0\n-                                                and then Ekind (Spec_Id)\n-                                                             = E_Function)\n-                                               or else Front_End_Inlining));\n-         Body_To_Analyze : Node_Id;\n-\n-      --  Start of processing for Check_Body_To_Inline\n-\n-      begin\n-         --  No action needed in stubs since the attribute Body_To_Inline\n-         --  is not available\n-\n-         if Nkind (Decl) = N_Subprogram_Body_Stub then\n-            return False;\n-\n-         --  Cannot build the body to inline if the attribute is already set.\n-         --  This attribute may have been set if this is a subprogram renaming\n-         --  declarations (see Freeze.Build_Renamed_Body).\n-\n-         elsif Present (Body_To_Inline (Decl)) then\n-            return False;\n-\n-         --  No action needed if the subprogram does not fulfill the minimum\n-         --  conditions to be inlined by the frontend\n-\n-         elsif not May_Inline then\n-            return False;\n-         end if;\n-\n-         --  Check excluded declarations\n-\n-         if Present (Declarations (N))\n-           and then Has_Excluded_Declaration (Declarations (N))\n-         then\n-            return False;\n-         end if;\n-\n-         --  Check excluded statements\n-\n-         if Present (Handled_Statement_Sequence (N)) then\n-            if Present\n-                 (Exception_Handlers (Handled_Statement_Sequence (N)))\n-            then\n-               Cannot_Inline\n-                 (\"cannot inline& (exception handler)?\",\n-                  First\n-                    (Exception_Handlers (Handled_Statement_Sequence (N))),\n-                  Subp);\n-\n-               return False;\n-\n-            elsif Has_Excluded_Statement\n-              (Statements (Handled_Statement_Sequence (N)))\n-            then\n-               return False;\n-            end if;\n-         end if;\n-\n-         --  For backward compatibility, compiling under -gnatN we do not\n-         --  inline a subprogram that is too large, unless it is marked\n-         --  Inline_Always. This pragma does not suppress the other checks\n-         --  on inlining (forbidden declarations, handlers, etc).\n-\n-         if Front_End_Inlining\n-           and then not Has_Pragma_Inline_Always (Subp)\n-           and then Stat_Count > Max_Size\n-         then\n-            Cannot_Inline (\"cannot inline& (body too large)?\", N, Subp);\n-            return False;\n-         end if;\n-\n-         --  If some enclosing body contains instantiations that appear before\n-         --  the corresponding generic body, the enclosing body has a freeze\n-         --  node so that it can be elaborated after the generic itself. This\n-         --  might conflict with subsequent inlinings, so that it is unsafe to\n-         --  try to inline in such a case.\n-\n-         if Has_Pending_Instantiation then\n-            Cannot_Inline\n-              (\"cannot inline& (forward instance within enclosing body)?\",\n-               N, Subp);\n-\n-            return False;\n-         end if;\n-\n-         --  Generate and preanalyze the body to inline (needed to perform\n-         --  the rest of the checks)\n-\n-         Generate_Body_To_Inline (N, Body_To_Analyze);\n-\n-         if Ekind (Subp) = E_Function then\n-            Set_Result_Definition (Specification (Body_To_Analyze),\n-              New_Occurrence_Of (Etype (Subp), Sloc (N)));\n-         end if;\n-\n-         --  Nest the body to analyze within the real one\n-\n-         if No (Declarations (N)) then\n-            Set_Declarations (N, New_List (Body_To_Analyze));\n-         else\n-            Append_To (Declarations (N), Body_To_Analyze);\n-         end if;\n-\n-         Preanalyze (Body_To_Analyze);\n-         Remove (Body_To_Analyze);\n-\n-         --  Keep separate checks needed when compiling without optimizations\n-\n-         if Optimization_Level = 0\n-\n-           --  AAMP and VM targets have no support for inlining in the backend\n-           --  and hence we use frontend inlining at all optimization levels.\n-\n-           or else AAMP_On_Target\n-           or else VM_Target /= No_VM\n-         then\n-            --  Cannot inline functions whose body has a call that returns an\n-            --  unconstrained type since the secondary stack is involved, and\n-            --  it is not worth inlining.\n-\n-            if Uses_Secondary_Stack (Body_To_Analyze) then\n-               return False;\n-\n-            --  Cannot inline functions that return controlled types since\n-            --  controlled actions interfere in complex ways with inlining.\n-\n-            elsif Ekind (Subp) = E_Function\n-              and then Needs_Finalization (Etype (Subp))\n-            then\n-               Cannot_Inline\n-                 (\"cannot inline & (controlled return type)?\", N, Subp);\n-               return False;\n-\n-            elsif Returns_Unconstrained_Type (Subp) then\n-               Cannot_Inline\n-                 (\"cannot inline & (unconstrained return type)?\", N, Subp);\n-               return False;\n-            end if;\n-\n-         --  Compiling with optimizations enabled\n-\n-         else\n-            --  Procedures are never frontend inlined in this case\n-\n-            if Ekind (Subp) /= E_Function then\n-               return False;\n-\n-            --  Functions returning unconstrained types are tested\n-            --  separately (see Can_Split_Unconstrained_Function).\n-\n-            elsif Returns_Unconstrained_Type (Subp) then\n-               null;\n-\n-            --  Check supported cases\n-\n-            elsif not Returns_Compile_Time_Constant (Body_To_Analyze)\n-              and then Convention (Subp) /= Convention_Intrinsic\n-              and then not Returns_Intrinsic_Function_Call (Body_To_Analyze)\n-            then\n-               return False;\n-            end if;\n-         end if;\n-\n-         return True;\n-      end Check_Body_To_Inline;\n-\n-      --------------------------------------\n-      -- Can_Split_Unconstrained_Function --\n-      --------------------------------------\n-\n-      function Can_Split_Unconstrained_Function (N : Node_Id) return Boolean\n-      is\n-         Ret_Node : constant Node_Id :=\n-                      First (Statements (Handled_Statement_Sequence (N)));\n-         D : Node_Id;\n-\n-      begin\n-         --  No user defined declarations allowed in the function except inside\n-         --  the unique return statement; implicit labels are the only allowed\n-         --  declarations.\n-\n-         if not Is_Empty_List (Declarations (N)) then\n-            D := First (Declarations (N));\n-            while Present (D) loop\n-               if Nkind (D) /= N_Implicit_Label_Declaration then\n-                  return False;\n-               end if;\n-\n-               Next (D);\n-            end loop;\n-         end if;\n-\n-         --  We only split the inlined function when we are generating the code\n-         --  of its body; otherwise we leave duplicated split subprograms in\n-         --  the tree which (if referenced) generate wrong references at link\n-         --  time.\n-\n-         return In_Extended_Main_Code_Unit (N)\n-           and then Present (Ret_Node)\n-           and then Nkind (Ret_Node) = N_Extended_Return_Statement\n-           and then No (Next (Ret_Node))\n-           and then Present (Handled_Statement_Sequence (Ret_Node));\n-      end Can_Split_Unconstrained_Function;\n-\n-      -----------------------------\n-      -- Generate_Body_To_Inline --\n-      -----------------------------\n-\n-      procedure Generate_Body_To_Inline\n-        (N              : Node_Id;\n-         Body_To_Inline : out Node_Id)\n-      is\n-         procedure Remove_Pragmas (N : Node_Id);\n-         --  Remove occurrences of pragmas that may reference the formals of\n-         --  N. The analysis of the non-inlined body will handle these pragmas\n-         --  properly.\n-\n-         --------------------\n-         -- Remove_Pragmas --\n-         --------------------\n-\n-         procedure Remove_Pragmas (N : Node_Id) is\n-            Decl : Node_Id;\n-            Nxt  : Node_Id;\n-\n-         begin\n-            Decl := First (Declarations (N));\n-            while Present (Decl) loop\n-               Nxt := Next (Decl);\n-\n-               if Nkind (Decl) = N_Pragma\n-                 and then Nam_In (Pragma_Name (Decl), Name_Unreferenced,\n-                                                      Name_Unmodified)\n-               then\n-                  Remove (Decl);\n-               end if;\n-\n-               Decl := Nxt;\n-            end loop;\n-         end Remove_Pragmas;\n-\n-      --  Start of processing for Generate_Body_To_Inline\n-\n-      begin\n-         --  Within an instance, the body to inline must be treated as a nested\n-         --  generic, so that the proper global references are preserved.\n-\n-         --  Note that we do not do this at the library level, because it\n-         --  is not needed, and furthermore this causes trouble if front\n-         --  end inlining is activated (-gnatN).\n-\n-         if In_Instance\n-           and then Scope (Current_Scope) /= Standard_Standard\n-         then\n-            Body_To_Inline := Copy_Generic_Node (N, Empty, True);\n-         else\n-            Body_To_Inline := Copy_Separate_Tree (N);\n-         end if;\n-\n-         --  A pragma Unreferenced or pragma Unmodified that mentions a formal\n-         --  parameter has no meaning when the body is inlined and the formals\n-         --  are rewritten. Remove it from body to inline. The analysis of the\n-         --  non-inlined body will handle the pragma properly.\n-\n-         Remove_Pragmas (Body_To_Inline);\n-\n-         --  We need to capture references to the formals in order\n-         --  to substitute the actuals at the point of inlining, i.e.\n-         --  instantiation. To treat the formals as globals to the body to\n-         --  inline, we nest it within a dummy parameterless subprogram,\n-         --  declared within the real one.\n-\n-         Set_Parameter_Specifications\n-           (Specification (Body_To_Inline), No_List);\n-\n-         --  A new internal name is associated with Body_To_Inline to avoid\n-         --  conflicts when the non-inlined body N is analyzed.\n-\n-         Set_Defining_Unit_Name (Specification (Body_To_Inline),\n-            Make_Defining_Identifier (Sloc (N), New_Internal_Name ('P')));\n-         Set_Corresponding_Spec (Body_To_Inline, Empty);\n-      end Generate_Body_To_Inline;\n-\n-      ----------------------------------\n-      -- Split_Unconstrained_Function --\n-      ----------------------------------\n-\n-      procedure Split_Unconstrained_Function\n-        (N        : Node_Id;\n-         Spec_Id  : Entity_Id)\n-      is\n-         Loc      : constant Source_Ptr := Sloc (N);\n-         Ret_Node : constant Node_Id :=\n-                      First (Statements (Handled_Statement_Sequence (N)));\n-         Ret_Obj  : constant Node_Id :=\n-                      First (Return_Object_Declarations (Ret_Node));\n-\n-         procedure Build_Procedure\n-           (Proc_Id   : out Entity_Id;\n-            Decl_List : out List_Id);\n-         --  Build a procedure containing the statements found in the extended\n-         --  return statement of the unconstrained function body N.\n-\n-         procedure Build_Procedure\n-           (Proc_Id   : out Entity_Id;\n-            Decl_List : out List_Id)\n-         is\n-            Formal      : Entity_Id;\n-            Formal_List : constant List_Id := New_List;\n-            Proc_Spec   : Node_Id;\n-            Proc_Body   : Node_Id;\n-            Subp_Name   : constant Name_Id := New_Internal_Name ('F');\n-            Body_Decl_List : List_Id := No_List;\n-            Param_Type  : Node_Id;\n-\n-         begin\n-            if Nkind (Object_Definition (Ret_Obj)) = N_Identifier then\n-               Param_Type := New_Copy (Object_Definition (Ret_Obj));\n-            else\n-               Param_Type :=\n-                 New_Copy (Subtype_Mark (Object_Definition (Ret_Obj)));\n-            end if;\n-\n-            Append_To (Formal_List,\n-              Make_Parameter_Specification (Loc,\n-                Defining_Identifier =>\n-                  Make_Defining_Identifier (Loc,\n-                    Chars => Chars (Defining_Identifier (Ret_Obj))),\n-                In_Present  => False,\n-                Out_Present => True,\n-                Null_Exclusion_Present => False,\n-                Parameter_Type => Param_Type));\n-\n-            Formal := First_Formal (Spec_Id);\n-            while Present (Formal) loop\n-               Append_To (Formal_List,\n-                 Make_Parameter_Specification (Loc,\n-                   Defining_Identifier =>\n-                     Make_Defining_Identifier (Sloc (Formal),\n-                       Chars => Chars (Formal)),\n-                   In_Present  => In_Present (Parent (Formal)),\n-                   Out_Present => Out_Present (Parent (Formal)),\n-                   Null_Exclusion_Present =>\n-                     Null_Exclusion_Present (Parent (Formal)),\n-                   Parameter_Type =>\n-                     New_Occurrence_Of (Etype (Formal), Loc),\n-                   Expression =>\n-                     Copy_Separate_Tree (Expression (Parent (Formal)))));\n-\n-               Next_Formal (Formal);\n-            end loop;\n-\n-            Proc_Id :=\n-              Make_Defining_Identifier (Loc, Chars => Subp_Name);\n-\n-            Proc_Spec :=\n-              Make_Procedure_Specification (Loc,\n-                Defining_Unit_Name => Proc_Id,\n-                Parameter_Specifications => Formal_List);\n-\n-            Decl_List := New_List;\n-\n-            Append_To (Decl_List,\n-              Make_Subprogram_Declaration (Loc, Proc_Spec));\n-\n-            --  Can_Convert_Unconstrained_Function checked that the function\n-            --  has no local declarations except implicit label declarations.\n-            --  Copy these declarations to the built procedure.\n-\n-            if Present (Declarations (N)) then\n-               Body_Decl_List := New_List;\n-\n-               declare\n-                  D     : Node_Id;\n-                  New_D : Node_Id;\n-\n-               begin\n-                  D := First (Declarations (N));\n-                  while Present (D) loop\n-                     pragma Assert (Nkind (D) = N_Implicit_Label_Declaration);\n-\n-                     New_D :=\n-                       Make_Implicit_Label_Declaration (Loc,\n-                         Make_Defining_Identifier (Loc,\n-                           Chars => Chars (Defining_Identifier (D))),\n-                         Label_Construct => Empty);\n-                     Append_To (Body_Decl_List, New_D);\n-\n-                     Next (D);\n-                  end loop;\n-               end;\n-            end if;\n-\n-            pragma Assert (Present (Handled_Statement_Sequence (Ret_Node)));\n-\n-            Proc_Body :=\n-              Make_Subprogram_Body (Loc,\n-                Specification => Copy_Separate_Tree (Proc_Spec),\n-                Declarations  => Body_Decl_List,\n-                Handled_Statement_Sequence =>\n-                  Copy_Separate_Tree (Handled_Statement_Sequence (Ret_Node)));\n-\n-            Set_Defining_Unit_Name (Specification (Proc_Body),\n-               Make_Defining_Identifier (Loc, Subp_Name));\n-\n-            Append_To (Decl_List, Proc_Body);\n-         end Build_Procedure;\n-\n-         --  Local variables\n-\n-         New_Obj   : constant Node_Id := Copy_Separate_Tree (Ret_Obj);\n-         Blk_Stmt  : Node_Id;\n-         Proc_Id   : Entity_Id;\n-         Proc_Call : Node_Id;\n-\n-      --  Start of processing for Split_Unconstrained_Function\n-\n-      begin\n-         --  Build the associated procedure, analyze it and insert it before\n-         --  the function body N\n-\n-         declare\n-            Scope     : constant Entity_Id := Current_Scope;\n-            Decl_List : List_Id;\n-         begin\n-            Pop_Scope;\n-            Build_Procedure (Proc_Id, Decl_List);\n-            Insert_Actions (N, Decl_List);\n-            Push_Scope (Scope);\n-         end;\n-\n-         --  Build the call to the generated procedure\n-\n-         declare\n-            Actual_List : constant List_Id := New_List;\n-            Formal      : Entity_Id;\n-\n-         begin\n-            Append_To (Actual_List,\n-              New_Occurrence_Of (Defining_Identifier (New_Obj), Loc));\n-\n-            Formal := First_Formal (Spec_Id);\n-            while Present (Formal) loop\n-               Append_To (Actual_List, New_Occurrence_Of (Formal, Loc));\n-\n-               --  Avoid spurious warning on unreferenced formals\n-\n-               Set_Referenced (Formal);\n-               Next_Formal (Formal);\n-            end loop;\n-\n-            Proc_Call :=\n-              Make_Procedure_Call_Statement (Loc,\n-                Name => New_Occurrence_Of (Proc_Id, Loc),\n-                Parameter_Associations => Actual_List);\n-         end;\n-\n-         --  Generate\n-\n-         --    declare\n-         --       New_Obj : ...\n-         --    begin\n-         --       main_1__F1b (New_Obj, ...);\n-         --       return Obj;\n-         --    end B10b;\n-\n-         Blk_Stmt :=\n-           Make_Block_Statement (Loc,\n-             Declarations => New_List (New_Obj),\n-             Handled_Statement_Sequence =>\n-               Make_Handled_Sequence_Of_Statements (Loc,\n-                 Statements => New_List (\n-\n-                   Proc_Call,\n-\n-                   Make_Simple_Return_Statement (Loc,\n-                     Expression =>\n-                       New_Occurrence_Of\n-                         (Defining_Identifier (New_Obj), Loc)))));\n-\n-         Rewrite (Ret_Node, Blk_Stmt);\n-      end Split_Unconstrained_Function;\n-\n-   --  Start of processing for Check_And_Build_Body_To_Inline\n-\n-   begin\n-      --  Do not inline any subprogram that contains nested subprograms, since\n-      --  the backend inlining circuit seems to generate uninitialized\n-      --  references in this case. We know this happens in the case of front\n-      --  end ZCX support, but it also appears it can happen in other cases as\n-      --  well. The backend often rejects attempts to inline in the case of\n-      --  nested procedures anyway, so little if anything is lost by this.\n-      --  Note that this is test is for the benefit of the back-end. There is\n-      --  a separate test for front-end inlining that also rejects nested\n-      --  subprograms.\n-\n-      --  Do not do this test if errors have been detected, because in some\n-      --  error cases, this code blows up, and we don't need it anyway if\n-      --  there have been errors, since we won't get to the linker anyway.\n-\n-      if Comes_From_Source (Body_Id)\n-        and then (Has_Pragma_Inline_Always (Spec_Id)\n-                    or else Optimization_Level > 0)\n-        and then Serious_Errors_Detected = 0\n-      then\n-         declare\n-            P_Ent : Node_Id;\n-\n-         begin\n-            P_Ent := Body_Id;\n-            loop\n-               P_Ent := Scope (P_Ent);\n-               exit when No (P_Ent) or else P_Ent = Standard_Standard;\n-\n-               if Is_Subprogram (P_Ent) then\n-                  Set_Is_Inlined (P_Ent, False);\n-\n-                  if Comes_From_Source (P_Ent)\n-                    and then Has_Pragma_Inline (P_Ent)\n-                  then\n-                     Cannot_Inline\n-                       (\"cannot inline& (nested subprogram)?\", N, P_Ent,\n-                        Is_Serious => True);\n-                  end if;\n-               end if;\n-            end loop;\n-         end;\n-      end if;\n-\n-      --  Build the body to inline only if really needed\n-\n-      if Check_Body_To_Inline (N, Spec_Id)\n-        and then Serious_Errors_Detected = 0\n-      then\n-         if Returns_Unconstrained_Type (Spec_Id) then\n-            if Can_Split_Unconstrained_Function (N) then\n-               Split_Unconstrained_Function (N, Spec_Id);\n-               Build_Body_To_Inline (N, Spec_Id);\n-               Set_Is_Inlined (Spec_Id);\n-            end if;\n-         else\n-            Build_Body_To_Inline (N, Spec_Id);\n-            Set_Is_Inlined (Spec_Id);\n-         end if;\n-      end if;\n-   end Check_And_Build_Body_To_Inline;\n-\n    -----------------------\n    -- Check_Conformance --\n    -----------------------"}, {"sha": "5a29d378dc88b6169fbbdb3fc103476ad2608b74", "filename": "gcc/ada/sem_ch6.ads", "status": "modified", "additions": 0, "deletions": 33, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/540d86108f31f56f513f542b910b909dd4d6df09/gcc%2Fada%2Fsem_ch6.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/540d86108f31f56f513f542b910b909dd4d6df09/gcc%2Fada%2Fsem_ch6.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.ads?ref=540d86108f31f56f513f542b910b909dd4d6df09", "patch": "@@ -68,39 +68,6 @@ package Sem_Ch6 is\n    --  and body declarations. Returns the defining entity for the\n    --  specification N.\n \n-   procedure Cannot_Inline\n-     (Msg        : String;\n-      N          : Node_Id;\n-      Subp       : Entity_Id;\n-      Is_Serious : Boolean := False);\n-   --  This procedure is called if the node N, an instance of a call to\n-   --  subprogram Subp, cannot be inlined. Msg is the message to be issued,\n-   --  which ends with ? (it does not end with ?p?, this routine takes care of\n-   --  the need to change ? to ?p?). Temporarily the behavior of this routine\n-   --  depends on the value of -gnatd.k:\n-   --\n-   --    * If -gnatd.k is not set (ie. old inlining model) then if Subp has\n-   --      a pragma Always_Inlined, then an error message is issued (by\n-   --      removing the last character of Msg). If Subp is not Always_Inlined,\n-   --      then a warning is issued if the flag Ineffective_Inline_Warnings\n-   --      is set, adding ?p to the msg, and if not, the call has no effect.\n-   --\n-   --    * If -gnatd.k is set (ie. new inlining model) then:\n-   --      - If Is_Serious is true, then an error is reported (by removing the\n-   --        last character of Msg);\n-   --\n-   --      - otherwise:\n-   --\n-   --        * Compiling without optimizations if Subp has a pragma\n-   --          Always_Inlined, then an error message is issued; if Subp is\n-   --          not Always_Inlined, then a warning is issued if the flag\n-   --          Ineffective_Inline_Warnings is set (adding p?), and if not,\n-   --          the call has no effect.\n-   --\n-   --        * Compiling with optimizations then a warning is issued if the\n-   --          flag Ineffective_Inline_Warnings is set (adding p?); otherwise\n-   --          no effect since inlining may be performed by the backend.\n-\n    procedure Check_Conventions (Typ : Entity_Id);\n    --  Ada 2005 (AI-430): Check that the conventions of all inherited and\n    --  overridden dispatching operations of type Typ are consistent with their"}]}