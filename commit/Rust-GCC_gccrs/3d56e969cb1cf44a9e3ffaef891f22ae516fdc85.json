{"sha": "3d56e969cb1cf44a9e3ffaef891f22ae516fdc85", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2Q1NmU5NjljYjFjZjQ0YTllM2ZmYWVmODkxZjIyYWU1MTZmZGM4NQ==", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2020-11-09T23:12:49Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2020-11-09T23:12:49Z"}, "message": "c++: Use two levels of caching in satisfy_atom\n\nThis improves the effectiveness of caching in satisfy_atom by querying\nthe cache again after we've instantiated the atom's parameter mapping.\n\nBefore instantiating its mapping, the identity of an (atom,args) pair\nwithin the satisfaction cache is determined by idiosyncratic things like\nthe level and index of each template parameter used in targets of the\nparameter mapping.  For example, the associated constraints of foo in\n\n  template <class T> concept range = range_v<T>;\n  template <class U, class V> void foo () requires range<U> && range<V>;\n\nare range_v<T> (with mapping T -> U) /\\ range_v<T> (with mapping T -> V).\nIf during satisfaction the template arguments supplied for U and V are\nthe same, then the satisfaction value of these two atoms will be the\nsame (despite their uninstantiated parameter mappings being different).\n\nBut sat_cache doesn't see this because it compares the uninstantiated\nparameter mapping and the supplied template arguments of sat_entry's\nindependently.  So satisy_atom on this latter atom will end up fully\nevaluating it instead of reusing the satisfaction value of the former.\n\nBut there is a point when the two atoms do look the same to sat_cache,\nand that's after instantiating their parameter mappings.  By querying\nthe cache again at this point, we can avoid substituting the same\ninstantiated parameter mapping into the same expression a second time\naround.\n\nWith this patch, compile time and memory usage for the cmcstl2 test\ntest/algorithm/set_symmetric_diference4.cpp drops from 11s/1.4GB to\n8.5s/1.2GB with an --enable-checking=release compiler.\n\ngcc/cp/ChangeLog:\n\n\t* cp-tree.h (ATOMIC_CONSTR_MAP_INSTANTIATED_P): Define this flag\n\tfor ATOMIC_CONSTRs.\n\t* constraint.cc (sat_hasher::hash): Use hash_atomic_constraint\n\tif the flag is set, otherwise keep using a pointer hash.\n\t(sat_hasher::equal): Return false if the flag's setting differs\n\ton two atoms.  Call atomic_constraints_identical_p if the flag\n\tis set, otherwise keep using a pointer equality test.\n\t(satisfy_atom): After instantiating the parameter mapping, form\n\tanother ATOMIC_CONSTR using the instantiated mapping and query\n\tthe cache again.  Cache the satisfaction value of both atoms.\n\t(diagnose_atomic_constraint): Simplify now that the supplied\n\tatom has an instantiated mapping.", "tree": {"sha": "d3fcc282366b897abdfca513dd6e7b08bff3841a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d3fcc282366b897abdfca513dd6e7b08bff3841a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3d56e969cb1cf44a9e3ffaef891f22ae516fdc85", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3d56e969cb1cf44a9e3ffaef891f22ae516fdc85", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3d56e969cb1cf44a9e3ffaef891f22ae516fdc85", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3d56e969cb1cf44a9e3ffaef891f22ae516fdc85/comments", "author": null, "committer": null, "parents": [{"sha": "2096ebd393a5a25921c85de1209b38c715924e22", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2096ebd393a5a25921c85de1209b38c715924e22", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2096ebd393a5a25921c85de1209b38c715924e22"}], "stats": {"total": 64, "additions": 50, "deletions": 14}, "files": [{"sha": "9dd5d892ce9ecd7da8e87854d9b9f7117a75e7cb", "filename": "gcc/cp/constraint.cc", "status": "modified", "additions": 43, "deletions": 14, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d56e969cb1cf44a9e3ffaef891f22ae516fdc85/gcc%2Fcp%2Fconstraint.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d56e969cb1cf44a9e3ffaef891f22ae516fdc85/gcc%2Fcp%2Fconstraint.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstraint.cc?ref=3d56e969cb1cf44a9e3ffaef891f22ae516fdc85", "patch": "@@ -2310,17 +2310,37 @@ struct sat_hasher : ggc_ptr_hash<sat_entry>\n {\n   static hashval_t hash (sat_entry *e)\n   {\n-    /* Since normalize_atom caches the ATOMIC_CONSTRs it returns,\n-       we can assume pointer-based identity for fast hashing and\n-       comparison.  Even if this assumption is violated, that's\n-       okay, we'll just get a cache miss.  */\n+    if (ATOMIC_CONSTR_MAP_INSTANTIATED_P (e->constr))\n+      {\n+\t/* Atoms with instantiated mappings are built during satisfaction.\n+\t   They live only inside the sat_cache, and we build one to query\n+\t   the cache with each time we instantiate a mapping.  */\n+\tgcc_assert (!e->args);\n+\treturn hash_atomic_constraint (e->constr);\n+      }\n+\n+    /* Atoms with uninstantiated mappings are built during normalization.\n+       Since normalize_atom caches the atoms it returns, we can assume\n+       pointer-based identity for fast hashing and comparison.  Even if this\n+       assumption is violated, that's okay, we'll just get a cache miss.  */\n     hashval_t value = htab_hash_pointer (e->constr);\n+\n     return iterative_hash_template_arg (e->args, value);\n   }\n \n   static bool equal (sat_entry *e1, sat_entry *e2)\n   {\n-    /* As in sat_hasher::hash.  */\n+    if (ATOMIC_CONSTR_MAP_INSTANTIATED_P (e1->constr)\n+\t!= ATOMIC_CONSTR_MAP_INSTANTIATED_P (e2->constr))\n+      return false;\n+\n+    /* See sat_hasher::hash.  */\n+    if (ATOMIC_CONSTR_MAP_INSTANTIATED_P (e1->constr))\n+      {\n+\tgcc_assert (!e1->args && !e2->args);\n+\treturn atomic_constraints_identical_p (e1->constr, e2->constr);\n+      }\n+\n     if (e1->constr != e2->constr)\n       return false;\n     return template_args_equal (e1->args, e2->args);\n@@ -2614,6 +2634,18 @@ satisfy_atom (tree t, tree args, subst_info info)\n       return cache.save (boolean_false_node);\n     }\n \n+  /* Now build a new atom using the instantiated mapping.  We use\n+     this atom as a second key to the satisfaction cache, and we\n+     also pass it to diagnose_atomic_constraint so that diagnostics\n+     which refer to the atom display the instantiated mapping.  */\n+  t = copy_node (t);\n+  ATOMIC_CONSTR_MAP (t) = map;\n+  gcc_assert (!ATOMIC_CONSTR_MAP_INSTANTIATED_P (t));\n+  ATOMIC_CONSTR_MAP_INSTANTIATED_P (t) = true;\n+  satisfaction_cache inst_cache (t, /*args=*/NULL_TREE, info.complain);\n+  if (tree r = inst_cache.get ())\n+    return cache.save (r);\n+\n   /* Rebuild the argument vector from the parameter mapping.  */\n   args = get_mapped_args (map);\n \n@@ -2626,19 +2658,19 @@ satisfy_atom (tree t, tree args, subst_info info)\n \t is not satisfied. Replay the substitution.  */\n       if (info.noisy ())\n \ttsubst_expr (expr, args, info.complain, info.in_decl, false);\n-      return cache.save (boolean_false_node);\n+      return cache.save (inst_cache.save (boolean_false_node));\n     }\n \n   /* [17.4.1.2] ... lvalue-to-rvalue conversion is performed as necessary,\n      and EXPR shall be a constant expression of type bool.  */\n   result = force_rvalue (result, info.complain);\n   if (result == error_mark_node)\n-    return cache.save (error_mark_node);\n+    return cache.save (inst_cache.save (error_mark_node));\n   if (!same_type_p (TREE_TYPE (result), boolean_type_node))\n     {\n       if (info.noisy ())\n \tdiagnose_atomic_constraint (t, map, result, info);\n-      return cache.save (error_mark_node);\n+      return cache.save (inst_cache.save (error_mark_node));\n     }\n \n   /* Compute the value of the constraint.  */\n@@ -2655,7 +2687,7 @@ satisfy_atom (tree t, tree args, subst_info info)\n   if (result == boolean_false_node && info.noisy ())\n     diagnose_atomic_constraint (t, map, result, info);\n \n-  return cache.save (result);\n+  return cache.save (inst_cache.save (result));\n }\n \n /* Determine if the normalized constraint T is satisfied.\n@@ -3495,14 +3527,11 @@ diagnose_atomic_constraint (tree t, tree map, tree result, subst_info info)\n       diagnose_requires_expr (expr, map, info.in_decl);\n       break;\n     default:\n-      tree a = copy_node (t);\n-      ATOMIC_CONSTR_MAP (a) = map;\n       if (!same_type_p (TREE_TYPE (result), boolean_type_node))\n \terror_at (loc, \"constraint %qE has type %qT, not %<bool%>\",\n-\t\t  a, TREE_TYPE (result));\n+\t\t  t, TREE_TYPE (result));\n       else\n-\tinform (loc, \"the expression %qE evaluated to %<false%>\", a);\n-      ggc_free (a);\n+\tinform (loc, \"the expression %qE evaluated to %<false%>\", t);\n     }\n }\n "}, {"sha": "b98d47a702f590e65586900bc361a2434f5bfcce", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d56e969cb1cf44a9e3ffaef891f22ae516fdc85/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d56e969cb1cf44a9e3ffaef891f22ae516fdc85/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=3d56e969cb1cf44a9e3ffaef891f22ae516fdc85", "patch": "@@ -438,6 +438,7 @@ extern GTY(()) tree cp_global_trees[CPTI_MAX];\n       REINTERPRET_CAST_P (in NOP_EXPR)\n       ALIGNOF_EXPR_STD_P (in ALIGNOF_EXPR)\n       OVL_DEDUP_P (in OVERLOAD)\n+      ATOMIC_CONSTR_MAP_INSTANTIATED_P (in ATOMIC_CONSTR)\n    1: IDENTIFIER_KIND_BIT_1 (in IDENTIFIER_NODE)\n       TI_PENDING_TEMPLATE_FLAG.\n       TEMPLATE_PARMS_FOR_INLINE.\n@@ -1597,6 +1598,12 @@ check_constraint_info (tree t)\n #define ATOMIC_CONSTR_MAP(NODE) \\\n   TREE_OPERAND (TREE_CHECK (NODE, ATOMIC_CONSTR), 0)\n \n+/* Whether the parameter mapping of this atomic constraint\n+   is already instantiated with concrete template arguments.\n+   Used only in satisfy_atom and in the satisfaction cache.  */\n+#define ATOMIC_CONSTR_MAP_INSTANTIATED_P(NODE) \\\n+  TREE_LANG_FLAG_0 (ATOMIC_CONSTR_CHECK (NODE))\n+\n /* The expression of an atomic constraint. */\n #define ATOMIC_CONSTR_EXPR(NODE) \\\n   CONSTR_EXPR (ATOMIC_CONSTR_CHECK (NODE))"}]}