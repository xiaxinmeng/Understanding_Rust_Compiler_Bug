{"sha": "862088aa6349851465388eb0c691a79325c5eb7a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODYyMDg4YWE2MzQ5ODUxNDY1Mzg4ZWIwYzY5MWE3OTMyNWM1ZWI3YQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2017-07-02T08:43:11Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-07-02T08:43:11Z"}, "message": "PR 80769: Incorrect strlen optimisation\n\nIn this testcase, we (correctly) record after:\n\n  strcpy (p1, \"abcde\");\n  char *p2 = strchr (p1, '\\0');\n  strcpy (p2, q);\n\nthat the length of p1 and p2 can be calculated by converting the\nsecond strcpy to:\n\n  tmp = stpcpy (p2, q)\n\nand then doing tmp - p1 for p1 and tmp - p2 for p2.  This is delayed\nuntil we know whether we actually need it.  Then:\n\n  char *p3 = strchr (p2, '\\0');\n\nforces us to calculate the length of p2 in this way.  At this point\nwe had three related strinfos:\n\n  p1: delayed length, calculated from tmp = stpcpy (p2, q)\n  p2: known length, tmp - p2\n  p3: known length, 0\n\nAfter:\n\n  memcpy (p3, \"x\", 2);\n\nwe use adjust_related_strinfos to add 1 to each length.  However,\nthat didn't do anything for delayed lengths because:\n\n\t  else if (si->stmt != NULL)\n\t    /* Delayed length computation is unaffected.  */\n\t    ;\n\nSo after the memcpy we had:\n\n  p1: delayed length, calculated from tmp = stpcpy (p2, q)\n  p2: known length, tmp - p2 + 1\n  p3: known length, 1\n\nwhere the length of p1 was no longer correct.\n\n2017-05-16  Richard Sandiford  <richard.sandiford@linaro.org>\n\ngcc/\n\tPR tree-optimization/80769\n\t* tree-ssa-strlen.c (strinfo): Document that \"stmt\" is also used\n\tfor malloc and calloc.  Document the new invariant that all related\n\tstrinfos have delayed lengths or none do.\n\t(verify_related_strinfos): Move earlier in file.\n\t(set_endptr_and_length): New function, split out from...\n\t(get_string_length): ...here.  Also set the lengths of related\n\tstrinfos.\n\t(zero_length_string): Assert that chainsi has known (rather than\n\tdelayed) lengths.\n\t(adjust_related_strinfos): Likewise.\n\ngcc/testsuite/\n\tPR tree-optimization/80769\n\t* gcc.dg/strlenopt-31.c: New test.\n\t* gcc.dg/strlenopt-31g.c: Likewise.\n\nFrom-SVN: r249879", "tree": {"sha": "02f950441793502431fd772aaf45367a717dfcf8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/02f950441793502431fd772aaf45367a717dfcf8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/862088aa6349851465388eb0c691a79325c5eb7a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/862088aa6349851465388eb0c691a79325c5eb7a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/862088aa6349851465388eb0c691a79325c5eb7a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/862088aa6349851465388eb0c691a79325c5eb7a/comments", "author": null, "committer": null, "parents": [{"sha": "c34d09274e72031d768e18d3f2365a1532357879", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c34d09274e72031d768e18d3f2365a1532357879", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c34d09274e72031d768e18d3f2365a1532357879"}], "stats": {"total": 176, "additions": 125, "deletions": 51}, "files": [{"sha": "67019a53d4f40b1b933047c724ecb35abe5c6787", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/862088aa6349851465388eb0c691a79325c5eb7a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/862088aa6349851465388eb0c691a79325c5eb7a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=862088aa6349851465388eb0c691a79325c5eb7a", "patch": "@@ -1,3 +1,17 @@\n+2017-07-02  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\tPR tree-optimization/80769\n+\t* tree-ssa-strlen.c (strinfo): Document that \"stmt\" is also used\n+\tfor malloc and calloc.  Document the new invariant that all related\n+\tstrinfos have delayed lengths or none do.\n+\t(verify_related_strinfos): Move earlier in file.\n+\t(set_endptr_and_length): New function, split out from...\n+\t(get_string_length): ...here.  Also set the lengths of related\n+\tstrinfos.\n+\t(zero_length_string): Assert that chainsi has known (rather than\n+\tdelayed) lengths.\n+\t(adjust_related_strinfos): Likewise.\n+\n 2017-07-02  Richard Sandiford  <richard.sandiford@linaro.org>\n \n \tPR tree-optimization/81136"}, {"sha": "e4c6af6558b009c5f0b05cc17f1babaf6aa3f412", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/862088aa6349851465388eb0c691a79325c5eb7a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/862088aa6349851465388eb0c691a79325c5eb7a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=862088aa6349851465388eb0c691a79325c5eb7a", "patch": "@@ -1,3 +1,9 @@\n+2017-07-02  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\tPR tree-optimization/80769\n+\t* gcc.dg/strlenopt-31.c: New test.\n+\t* gcc.dg/strlenopt-31g.c: Likewise.\n+\n 2017-07-02  Richard Sandiford  <richard.sandiford@linaro.org>\n \n \tPR tree-optimization/81136"}, {"sha": "bdd46ba0000fde537c09df45a505b23358fd60bd", "filename": "gcc/testsuite/gcc.dg/strlenopt-31.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/862088aa6349851465388eb0c691a79325c5eb7a/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-31.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/862088aa6349851465388eb0c691a79325c5eb7a/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-31.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-31.c?ref=862088aa6349851465388eb0c691a79325c5eb7a", "patch": "@@ -0,0 +1,25 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2\" } */\n+\n+#include \"strlenopt.h\"\n+\n+__attribute__((noinline, noclone)) int\n+bar (char *p1, const char *q)\n+{\n+  strcpy (p1, \"abcde\");\n+  char *p2 = strchr (p1, '\\0');\n+  strcpy (p2, q);\n+  char *p3 = strchr (p2, '\\0');\n+  memcpy (p3, \"x\", 2);\n+  return strlen (p1);\n+}\n+\n+int\n+main (void)\n+{\n+  char buffer[10];\n+  int res = bar (buffer, \"foo\");\n+  if (strcmp (buffer, \"abcdefoox\") != 0 || res != 9)\n+    abort ();\n+  return 0;\n+}"}, {"sha": "45cc29c1024b71822d8b25df793e8dd151ae5ca3", "filename": "gcc/testsuite/gcc.dg/strlenopt-31g.c", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/862088aa6349851465388eb0c691a79325c5eb7a/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-31g.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/862088aa6349851465388eb0c691a79325c5eb7a/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-31g.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-31g.c?ref=862088aa6349851465388eb0c691a79325c5eb7a", "patch": "@@ -0,0 +1,9 @@\n+/* { dg-do run { target *-*-linux* *-*-gnu* } } */\n+/* { dg-options \"-O2 -fdump-tree-strlen\" } */\n+\n+#define USE_GNU\n+#include \"strlenopt-31.c\"\n+\n+/* { dg-final { scan-tree-dump-times \"stpcpy \\\\(\" 1 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-times \"memcpy \\\\(\" 2 \"strlen\" } } */\n+/* { dg-final { scan-tree-dump-not \"strlen \\\\(\" \"strlen\" } } */"}, {"sha": "f46e64dee9a9f2fbb50c74ea06f56e79caa85247", "filename": "gcc/tree-ssa-strlen.c", "status": "modified", "additions": 71, "deletions": 51, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/862088aa6349851465388eb0c691a79325c5eb7a/gcc%2Ftree-ssa-strlen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/862088aa6349851465388eb0c691a79325c5eb7a/gcc%2Ftree-ssa-strlen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-strlen.c?ref=862088aa6349851465388eb0c691a79325c5eb7a", "patch": "@@ -61,7 +61,13 @@ struct strinfo\n   tree length;\n   /* Any of the corresponding pointers for querying alias oracle.  */\n   tree ptr;\n-  /* Statement for delayed length computation.  */\n+  /* This is used for two things:\n+\n+     - To record the statement that should be used for delayed length\n+       computations.  We maintain the invariant that all related strinfos\n+       have delayed lengths or none do.\n+\n+     - To record the malloc or calloc call that produced this result.  */\n   gimple *stmt;\n   /* Pointer to '\\0' if known, if NULL, it can be computed as\n      ptr + length.  */\n@@ -451,6 +457,45 @@ set_strinfo (int idx, strinfo *si)\n   (*stridx_to_strinfo)[idx] = si;\n }\n \n+/* Return the first strinfo in the related strinfo chain\n+   if all strinfos in between belong to the chain, otherwise NULL.  */\n+\n+static strinfo *\n+verify_related_strinfos (strinfo *origsi)\n+{\n+  strinfo *si = origsi, *psi;\n+\n+  if (origsi->first == 0)\n+    return NULL;\n+  for (; si->prev; si = psi)\n+    {\n+      if (si->first != origsi->first)\n+\treturn NULL;\n+      psi = get_strinfo (si->prev);\n+      if (psi == NULL)\n+\treturn NULL;\n+      if (psi->next != si->idx)\n+\treturn NULL;\n+    }\n+  if (si->idx != si->first)\n+    return NULL;\n+  return si;\n+}\n+\n+/* Set SI's endptr to ENDPTR and compute its length based on SI->ptr.\n+   Use LOC for folding.  */\n+\n+static void\n+set_endptr_and_length (location_t loc, strinfo *si, tree endptr)\n+{\n+  si->endptr = endptr;\n+  si->stmt = NULL;\n+  tree start_as_size = fold_convert_loc (loc, size_type_node, si->ptr);\n+  tree end_as_size = fold_convert_loc (loc, size_type_node, endptr);\n+  si->length = fold_build2_loc (loc, MINUS_EXPR, size_type_node,\n+\t\t\t\tend_as_size, start_as_size);\n+}\n+\n /* Return string length, or NULL if it can't be computed.  */\n \n static tree\n@@ -546,12 +591,12 @@ get_string_length (strinfo *si)\n \tcase BUILT_IN_STPCPY_CHK_CHKP:\n \t  gcc_assert (lhs != NULL_TREE);\n \t  loc = gimple_location (stmt);\n-\t  si->endptr = lhs;\n-\t  si->stmt = NULL;\n-\t  lhs = fold_convert_loc (loc, size_type_node, lhs);\n-\t  si->length = fold_convert_loc (loc, size_type_node, si->ptr);\n-\t  si->length = fold_build2_loc (loc, MINUS_EXPR, size_type_node,\n-\t\t\t\t\tlhs, si->length);\n+\t  set_endptr_and_length (loc, si, lhs);\n+\t  for (strinfo *chainsi = verify_related_strinfos (si);\n+\t       chainsi != NULL;\n+\t       chainsi = get_next_strinfo (chainsi))\n+\t    if (chainsi->length == NULL)\n+\t      set_endptr_and_length (loc, chainsi, lhs);\n \t  break;\n \tcase BUILT_IN_MALLOC:\n \t  break;\n@@ -620,32 +665,6 @@ unshare_strinfo (strinfo *si)\n   return nsi;\n }\n \n-/* Return first strinfo in the related strinfo chain\n-   if all strinfos in between belong to the chain, otherwise\n-   NULL.  */\n-\n-static strinfo *\n-verify_related_strinfos (strinfo *origsi)\n-{\n-  strinfo *si = origsi, *psi;\n-\n-  if (origsi->first == 0)\n-    return NULL;\n-  for (; si->prev; si = psi)\n-    {\n-      if (si->first != origsi->first)\n-\treturn NULL;\n-      psi = get_strinfo (si->prev);\n-      if (psi == NULL)\n-\treturn NULL;\n-      if (psi->next != si->idx)\n-\treturn NULL;\n-    }\n-  if (si->idx != si->first)\n-    return NULL;\n-  return si;\n-}\n-\n /* Attempt to create a new strinfo for BASESI + OFF, or find existing\n    strinfo if there is any.  Return it's idx, or 0 if no strinfo has\n    been created.  */\n@@ -749,7 +768,8 @@ zero_length_string (tree ptr, strinfo *chainsi)\n \t{\n \t  do\n \t    {\n-\t      gcc_assert (si->length || si->stmt);\n+\t      /* We shouldn't mix delayed and non-delayed lengths.  */\n+\t      gcc_assert (si->length);\n \t      if (si->endptr == NULL_TREE)\n \t\t{\n \t\t  si = unshare_strinfo (si);\n@@ -770,12 +790,17 @@ zero_length_string (tree ptr, strinfo *chainsi)\n \t      return chainsi;\n \t    }\n \t}\n-      else if (chainsi->first || chainsi->prev || chainsi->next)\n+      else\n \t{\n-\t  chainsi = unshare_strinfo (chainsi);\n-\t  chainsi->first = 0;\n-\t  chainsi->prev = 0;\n-\t  chainsi->next = 0;\n+\t  /* We shouldn't mix delayed and non-delayed lengths.  */\n+\t  gcc_assert (chainsi->length);\n+\t  if (chainsi->first || chainsi->prev || chainsi->next)\n+\t    {\n+\t      chainsi = unshare_strinfo (chainsi);\n+\t      chainsi->first = 0;\n+\t      chainsi->prev = 0;\n+\t      chainsi->next = 0;\n+\t    }\n \t}\n     }\n   idx = new_stridx (ptr);\n@@ -820,18 +845,13 @@ adjust_related_strinfos (location_t loc, strinfo *origsi, tree adj)\n \t  tree tem;\n \n \t  si = unshare_strinfo (si);\n-\t  if (si->length)\n-\t    {\n-\t      tem = fold_convert_loc (loc, TREE_TYPE (si->length), adj);\n-\t      si->length = fold_build2_loc (loc, PLUS_EXPR,\n-\t\t\t\t\t    TREE_TYPE (si->length), si->length,\n-\t\t\t\t\t    tem);\n-\t    }\n-\t  else if (si->stmt != NULL)\n-\t    /* Delayed length computation is unaffected.  */\n-\t    ;\n-\t  else\n-\t    gcc_unreachable ();\n+\t  /* We shouldn't see delayed lengths here; the caller must have\n+\t     calculated the old length in order to calculate the\n+\t     adjustment.  */\n+\t  gcc_assert (si->length);\n+\t  tem = fold_convert_loc (loc, TREE_TYPE (si->length), adj);\n+\t  si->length = fold_build2_loc (loc, PLUS_EXPR, TREE_TYPE (si->length),\n+\t\t\t\t\tsi->length, tem);\n \n \t  si->endptr = NULL_TREE;\n \t  si->dont_invalidate = true;"}]}