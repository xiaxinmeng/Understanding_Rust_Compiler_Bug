{"sha": "59026e796378b6fa8ebf34d4c85fc9dcdc2e9d4c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTkwMjZlNzk2Mzc4YjZmYThlYmYzNGQ0Yzg1ZmM5ZGNkYzJlOWQ0Yw==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "1999-09-17T23:14:49Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1999-09-17T23:14:49Z"}, "message": "cp-tree.def (CLEANUP_STMT): Fix spelling in dumps.\n\n\t* cp-tree.def (CLEANUP_STMT): Fix spelling in dumps.\n\t(TRY_BLOCK): Likewise.\n\t(HANDLER): Likewise.\n\t(START_CATCH_STMT): New tree node.\n\t(SCOPE_STMT): Likewise.\n\t* cp-tree.h (SCOPE_BEGIN_P): New macro.\n\t(SCOPE_NULLIFIED_P): Likewise.\n\t(struct lang_decl_flags): Add pending_inline_p.  Adjust dummy.\n\t(struct lang_decl): Add saved_language_function.\n\t(DECL_PENDING_INLINE_INFO): Adjust documentation.\n\t(DECL_PENDING_INLINE_P): New macro.\n\t(TYPE_TI_ARGS): Fix typo in comment.\n\t(DECL_SAVED_TREE): Add to documentation.\n\t(DECL_SAVED_FUNCTION_DATA): New macro.\n\t(START_CATCH_TYPE): Likewise.\n\t(SCOPE_END_P): New macro.\n\t(declare_parm_level): Don't declare.\n\t* decl.c (mark_lang_function): New function, split out from\n\tmark_cp_function_context.\n\t(save_function_data): New function.\n\t(declare_parm_level): Remove.\n\t(finish_function): Use save_function_data to squirrel away\n\timportant stuff for later use.\n\t(mark_cp_function_context): Use mark_function_data.\n\t(lang_mark_tree): Likewise.\n\t* lex.c (begin_definition_of_inclass_inline): Set\n\tDECL_PENDING_INLINE_P.\n\t(store_pending_inline): Clear it.\n\t* pt.c (tsubst_decl): Likewise.\n\nFrom-SVN: r29488", "tree": {"sha": "f87e9cb0945e8ed2bbeff1f18cc090e059fa5130", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f87e9cb0945e8ed2bbeff1f18cc090e059fa5130"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/59026e796378b6fa8ebf34d4c85fc9dcdc2e9d4c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/59026e796378b6fa8ebf34d4c85fc9dcdc2e9d4c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/59026e796378b6fa8ebf34d4c85fc9dcdc2e9d4c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/59026e796378b6fa8ebf34d4c85fc9dcdc2e9d4c/comments", "author": null, "committer": null, "parents": [{"sha": "e6fd097efca2e3f76d3fe51c55cd124998b7fd42", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e6fd097efca2e3f76d3fe51c55cd124998b7fd42", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e6fd097efca2e3f76d3fe51c55cd124998b7fd42"}], "stats": {"total": 169, "additions": 143, "deletions": 26}, "files": [{"sha": "65e1b82668065511862d61e431a5e07639000918", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59026e796378b6fa8ebf34d4c85fc9dcdc2e9d4c/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59026e796378b6fa8ebf34d4c85fc9dcdc2e9d4c/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=59026e796378b6fa8ebf34d4c85fc9dcdc2e9d4c", "patch": "@@ -1,3 +1,35 @@\n+1999-09-17  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* cp-tree.def (CLEANUP_STMT): Fix spelling in dumps.\n+\t(TRY_BLOCK): Likewise.\n+\t(HANDLER): Likewise.\n+\t(START_CATCH_STMT): New tree node.\n+\t(SCOPE_STMT): Likewise.\n+\t* cp-tree.h (SCOPE_BEGIN_P): New macro.\n+\t(SCOPE_NULLIFIED_P): Likewise.\n+\t(struct lang_decl_flags): Add pending_inline_p.  Adjust dummy.\n+\t(struct lang_decl): Add saved_language_function.\n+\t(DECL_PENDING_INLINE_INFO): Adjust documentation.\n+\t(DECL_PENDING_INLINE_P): New macro.\n+\t(TYPE_TI_ARGS): Fix typo in comment.\n+\t(DECL_SAVED_TREE): Add to documentation.\n+\t(DECL_SAVED_FUNCTION_DATA): New macro.\n+\t(START_CATCH_TYPE): Likewise.\n+\t(SCOPE_END_P): New macro.\n+\t(declare_parm_level): Don't declare.\n+\t* decl.c (mark_lang_function): New function, split out from\n+\tmark_cp_function_context.\n+\t(save_function_data): New function.\n+\t(declare_parm_level): Remove.\n+\t(finish_function): Use save_function_data to squirrel away\n+\timportant stuff for later use.\n+\t(mark_cp_function_context): Use mark_function_data.\n+\t(lang_mark_tree): Likewise.\n+\t* lex.c (begin_definition_of_inclass_inline): Set\n+\tDECL_PENDING_INLINE_P.\n+\t(store_pending_inline): Clear it.\n+\t* pt.c (tsubst_decl): Likewise.\n+\n 1999-09-17  Nathan Sidwell  <nathan@acm.org>\n \n \t* call.c (perform_implicit_conversion): Deal with error_mark_node."}, {"sha": "c96ee36283a63a6da7d81a4331df40b6caf21799", "filename": "gcc/cp/cp-tree.def", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59026e796378b6fa8ebf34d4c85fc9dcdc2e9d4c/gcc%2Fcp%2Fcp-tree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59026e796378b6fa8ebf34d4c85fc9dcdc2e9d4c/gcc%2Fcp%2Fcp-tree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.def?ref=59026e796378b6fa8ebf34d4c85fc9dcdc2e9d4c", "patch": "@@ -238,12 +238,22 @@ DEFTREECODE (SUBOBJECT, \"subobject\", 'e', 1)\n /* A CLEANUP_STMT marks the point at which a declaration is fully\n    constructed.  If, after this point, the CLEANUP_DECL goes out of\n    scope, the CLEANUP_EXPR must be run.  */\n-DEFTREECODE (CLEANUP_STMT, \"cleanup\", 'e', 2)\n+DEFTREECODE (CLEANUP_STMT, \"cleanup_stmt\", 'e', 2)\n+/* A START_CATCH_STMT marks the beginning of a catch handler for the\n+   the START_CATCH_TYPE.  If this is CATCH_ALL_TYPE, then the handler\n+   catches all types.  */\n+DEFTREECODE (START_CATCH_STMT, \"start_catch_stmt\", 'e', 0)\n+/* A SCOPE_STMT marks the beginning or end of a scope.  If\n+   SCOPE_BEGIN_P holds, then this is the start of a scope.  If\n+   SCOPE_END_P holds, then this is the end of a scope.  If\n+   SCOPE_NULLIFIED_P holds then there turned out to be no variables in\n+   this scope.  */\n+DEFTREECODE (SCOPE_STMT, \"scope_stmt\", 'e', 0)\n DEFTREECODE (CTOR_INITIALIZER, \"ctor_initializer\", 'e', 2)\n DEFTREECODE (CASE_LABEL, \"case_label\", 'e', 2)\n DEFTREECODE (RETURN_INIT, \"return_init\", 'e', 2)\n-DEFTREECODE (TRY_BLOCK, \"try_stmt\", 'e', 2)\n-DEFTREECODE (HANDLER, \"catch_stmt\", 'e', 2)\n+DEFTREECODE (TRY_BLOCK, \"try_block\", 'e', 2)\n+DEFTREECODE (HANDLER, \"handler\", 'e', 2)\n \n /* A STMT_EXPR represents a statement-expression.  The\n    STMT_EXPR_STMT is the statement given by the expression.  */"}, {"sha": "57a7ad516220b307c957cabdd09620faaac83259", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 36, "deletions": 10, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59026e796378b6fa8ebf34d4c85fc9dcdc2e9d4c/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59026e796378b6fa8ebf34d4c85fc9dcdc2e9d4c/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=59026e796378b6fa8ebf34d4c85fc9dcdc2e9d4c", "patch": "@@ -40,6 +40,7 @@ Boston, MA 02111-1307, USA.  */\n       ICS_USER_FLAG (in _CONV)\n       CLEANUP_P (in TRY_BLOCK)\n       AGGR_INIT_VIA_CTOR_P (in AGGR_INIT_EXPR)\n+      SCOPE_BEGIN_P (in SCOPE_STMT)\n    1: IDENTIFIER_VIRTUAL_P.\n       TI_PENDING_TEMPLATE_FLAG.\n       TEMPLATE_PARMS_FOR_INLINE.\n@@ -64,6 +65,7 @@ Boston, MA 02111-1307, USA.  */\n       (TREE_REFERENCE_EXPR) (in NON_LVALUE_EXPR) (commented-out).\n       ICS_BAD_FLAG (in _CONV)\n       FN_TRY_BLOCK_P (in TRY_BLOCK)\n+      SCOPE_NULLIFIED_P (in SCOPE_STMT)\n    4: BINFO_NEW_VTABLE_MARKED.\n       TREE_HAS_CONSTRUCTOR (in INDIRECT_REF, SAVE_EXPR, CONSTRUCTOR,\n           or FIELD_DECL).\n@@ -1505,7 +1507,8 @@ struct lang_decl_flags\n \n   unsigned bitfield : 1;\n   unsigned defined_in_class : 1;\n-  unsigned dummy : 6;\n+  unsigned pending_inline_p : 1;\n+  unsigned dummy : 5;\n \n   tree access;\n   tree context;\n@@ -1533,6 +1536,7 @@ struct lang_decl\n   {\n     tree sorted_fields;\n     struct pending_inline *pending_inline_info;\n+    struct language_function *saved_language_function;\n   } u;\n };\n \n@@ -1717,10 +1721,16 @@ struct lang_decl\n /* Points back to the decl which caused this lang_decl to be allocated.  */\n #define DECL_MAIN_VARIANT(NODE) (DECL_LANG_SPECIFIC(NODE)->main_decl_variant)\n \n-/* For a FUNCTION_DECL: if this function was declared inline inside of\n-   a class declaration, this is where the text for the function is\n-   squirreled away.  */\n-#define DECL_PENDING_INLINE_INFO(NODE) (DECL_LANG_SPECIFIC(NODE)->u.pending_inline_info)\n+/* In a FUNCTION_DECL, this is nonzero if this function was defined in\n+   the class definition.  We have saved away the text of the function,\n+   but have not yet processed it.  */\n+#define DECL_PENDING_INLINE_P(NODE) \\\n+  (DECL_LANG_SPECIFIC (NODE)->decl_flags.pending_inline_p)\n+   \n+/* If DECL_PENDING_INLINE_P holds, this is the saved text of the\n+   function.  */\n+#define DECL_PENDING_INLINE_INFO(NODE) \\\n+  (DECL_LANG_SPECIFIC(NODE)->u.pending_inline_info)\n \n /* For a TYPE_DECL: if this function has many fields, we'll sort them\n    and put them into a TREE_VEC. */\n@@ -1804,7 +1814,7 @@ struct lang_decl\n #define TYPE_TI_TEMPLATE(NODE)\t\t\t\\\n   (TI_TEMPLATE (TYPE_TEMPLATE_INFO (NODE)))\n \n-/* Like DECL_TI_ARGS, , but for an ENUMERAL_, RECORD_, or UNION_TYPE.  */\n+/* Like DECL_TI_ARGS, but for an ENUMERAL_, RECORD_, or UNION_TYPE.  */\n #define TYPE_TI_ARGS(NODE)\t\t\t\\\n   (TI_ARGS (TYPE_TEMPLATE_INFO (NODE)))\n \n@@ -1815,11 +1825,16 @@ struct lang_decl\n    the class definition is complete.  */\n #define TEMPLATE_PARMS_FOR_INLINE(NODE) TREE_LANG_FLAG_1 (NODE)\n \n-/* In a template FUNCTION_DECL, the tree structure that will be\n-   substituted into to obtain instantiations.  */\n+/* In a FUNCTION_DECL, the saved representation of the body of the\n+   entire function.  Usually a COMPOUND_STMT, but this may also be a\n+   RETURN_INIT, CTOR_INITIALIZER, or TRY_BLOCK.  */\n #define DECL_SAVED_TREE(NODE) \\\n   (DECL_LANG_SPECIFIC ((NODE))->saved_tree)\n \n+/* In a FUNCTION_DECL, the saved language-specific per-function data.  */\n+#define DECL_SAVED_FUNCTION_DATA(NODE) \\\n+  (DECL_LANG_SPECIFIC ((NODE))->u.saved_language_function)\n+\n #define COMPOUND_STMT_NO_SCOPE(NODE)\tTREE_LANG_FLAG_0 (NODE)\n #define NEW_EXPR_USE_GLOBAL(NODE)\tTREE_LANG_FLAG_0 (NODE)\n #define DELETE_EXPR_USE_GLOBAL(NODE)\tTREE_LANG_FLAG_0 (NODE)\n@@ -2446,8 +2461,21 @@ extern int flag_new_for_scope;\n #define SUBOBJECT_CLEANUP(NODE) TREE_OPERAND (NODE, 0)\n #define CLEANUP_DECL(NODE)      TREE_OPERAND (NODE, 0)\n #define CLEANUP_EXPR(NODE)      TREE_OPERAND (NODE, 1)\n+#define START_CATCH_TYPE(NODE)  TREE_TYPE (NODE)\n #define LABEL_STMT_LABEL(NODE)  TREE_OPERAND (NODE, 0)\n \n+/* Nonzero if this SCOPE_STMT is for the beginning of a scope.  */\n+#define SCOPE_BEGIN_P(NODE) \\\n+  (TREE_LANG_FLAG_0 ((NODE))) \n+\n+/* Nonzero if this SCOPE_STMT is for the end of a scope.  */\n+#define SCOPE_END_P(NODE) \\\n+  (!SCOPE_BEGIN_P ((NODE)))\n+\n+/* Nonzero for a SCOPE_STMT if there were no variables in this scope.  */\n+#define SCOPE_NULLIFIED_P(NODE) \\\n+  (TREE_LANG_FLAG_3 ((NODE)))\n+\n /* Nonzero for an ASM_STMT if the assembly statement is volatile.  */\n #define ASM_VOLATILE_P(NODE)\t\t\t\\\n   (ASM_CV_QUAL ((NODE)) != NULL_TREE)\n@@ -3106,14 +3134,12 @@ extern int toplevel_bindings_p\t\t\tPROTO((void));\n extern int namespace_bindings_p\t\t\tPROTO((void));\n extern void keep_next_level\t\t\tPROTO((int));\n extern int kept_level_p\t\t\t\tPROTO((void));\n-extern void declare_parm_level\t\t\tPROTO((void));\n extern void declare_pseudo_global_level\t\tPROTO((void));\n extern int pseudo_global_level_p\t\tPROTO((void));\n extern void set_class_shadows\t\t\tPROTO((tree));\n extern void pushlevel\t\t\t\tPROTO((int));\n extern void note_level_for_for\t\t\tPROTO((void));\n extern void pushlevel_temporary\t\t\tPROTO((int));\n-extern tree poplevel\t\t\t\tPROTO((int, int, int));\n extern void resume_level\t\t\tPROTO((struct binding_level *));\n extern void delete_block\t\t\tPROTO((tree));\n extern void insert_block\t\t\tPROTO((tree));"}, {"sha": "b888eb074a864bf6bb73b1e1ed3fe334ee973256", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 59, "deletions": 13, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59026e796378b6fa8ebf34d4c85fc9dcdc2e9d4c/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59026e796378b6fa8ebf34d4c85fc9dcdc2e9d4c/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=59026e796378b6fa8ebf34d4c85fc9dcdc2e9d4c", "patch": "@@ -175,6 +175,8 @@ static void pop_cp_function_context PROTO((struct function *));\n static void mark_binding_level PROTO((void *));\n static void mark_cp_function_context PROTO((struct function *));\n static void mark_saved_scope PROTO((void *));\n+static void mark_lang_function PROTO((struct language_function *));\n+static void save_function_data PROTO((tree));\n static void check_function_type PROTO((tree));\n static void destroy_local_static PROTO((tree));\n static void destroy_local_var PROTO((tree));\n@@ -787,14 +789,6 @@ kept_level_p ()\n \t      && !current_binding_level->tag_transparent));\n }\n \n-/* Identify this binding level as a level of parameters.  */\n-\n-void\n-declare_parm_level ()\n-{\n-  current_binding_level->parm_flag = 1;\n-}\n-\n void\n declare_pseudo_global_level ()\n {\n@@ -13245,6 +13239,43 @@ store_return_init (decl)\n }\n \n \f\n+/* We have finished doing semantic analysis on DECL, but have not yet\n+   generated RTL for its body.  Save away our current state, so that\n+   when we want to generate RTL later we know what to do.  */\n+\n+static void\n+save_function_data (decl)\n+     tree decl;\n+{\n+  struct language_function *f;\n+\n+  /* Save the language-specific per-function data so that we can\n+     get it back when we really expand this function.  */\n+  my_friendly_assert (!DECL_PENDING_INLINE_P (decl),\n+\t\t      19990908);\n+      \n+  /* Make a copy.  */\n+  f = ((struct language_function *) \n+       xmalloc (sizeof (struct language_function)));\n+  bcopy ((char *) cp_function_chain, (char *) f,\n+\t sizeof (struct language_function));\n+  DECL_SAVED_FUNCTION_DATA (decl) = f;\n+\n+  /* Clear out the bits we don't need.  */\n+  f->x_base_init_list = NULL_TREE;\n+  f->x_member_init_list = NULL_TREE;\n+  f->x_last_tree = NULL_TREE;\n+  f->x_last_expr_type = NULL_TREE;\n+  f->x_last_dtor_insn = NULL_RTX;\n+  f->x_last_parm_cleanup_insn = NULL_RTX;\n+  f->x_result_rtx = NULL_RTX;\n+  f->x_named_label_uses = NULL;\n+  f->bindings = NULL;\n+\n+  /* When we get back here again, we will be expanding.  */\n+  f->x_expanding_p = 1;\n+}\n+\n /* Finish up a function declaration and compile that function\n    all the way to assembler language output.  The free the storage\n    for the function definition.\n@@ -13725,6 +13756,10 @@ finish_function (lineno, flags)\n   /* Undo the call to push_momentary in start_function.  */\n   pop_momentary ();\n \n+  /* Save away current state, if appropriate.  */\n+  if (!expanding_p && !processing_template_decl)\n+    save_function_data (fndecl);\n+\n   if (expand_p)\n     {\n       int returns_null;\n@@ -14294,12 +14329,12 @@ pop_cp_function_context (f)\n   f->language = 0;\n }\n \n-void\n-mark_cp_function_context (f)\n-     struct function *f;\n-{\n-  struct language_function *p = f->language;\n+/* Mark P for GC.  */\n \n+static void\n+mark_lang_function (p)\n+     struct language_function *p;\n+{\n   if (!p)\n     return;\n \n@@ -14321,6 +14356,14 @@ mark_cp_function_context (f)\n   mark_binding_level (&p->bindings);\n }\n \n+/* Mark the language-specific data in F for GC.  */\n+\n+void\n+mark_cp_function_context (f)\n+     struct function *f;\n+{\n+  mark_lang_function (f->language);\n+}\n \n int\n in_function_p ()\n@@ -14388,6 +14431,9 @@ lang_mark_tree (t)\n \t      ggc_mark_tree (ld->saved_tree);\n \t      if (TREE_CODE (t) == TYPE_DECL)\n \t\tggc_mark_tree (ld->u.sorted_fields);\n+\t      else if (TREE_CODE (t) == FUNCTION_DECL\n+\t\t       && !DECL_PENDING_INLINE_P (t))\n+\t\tmark_lang_function (DECL_SAVED_FUNCTION_DATA (t));\n \t    }\n \t}\n     }"}, {"sha": "e714dffaca7cdb4e2ef892017a75637f5e5b63fe", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59026e796378b6fa8ebf34d4c85fc9dcdc2e9d4c/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59026e796378b6fa8ebf34d4c85fc9dcdc2e9d4c/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=59026e796378b6fa8ebf34d4c85fc9dcdc2e9d4c", "patch": "@@ -1288,6 +1288,7 @@ begin_definition_of_inclass_inline (pi)\n   /* Pass back a handle to the rest of the inline functions, so that they\n      can be processed later.  */\n   DECL_PENDING_INLINE_INFO (pi->fndecl) = 0;\n+  DECL_PENDING_INLINE_P (pi->fndecl) = 0;\n   interface_unknown = pi->interface == 1;\n   interface_only  = pi->interface == 0;\n }\n@@ -1510,6 +1511,7 @@ store_pending_inline (decl, t)\n {\n   t->fndecl = decl;\n   DECL_PENDING_INLINE_INFO (decl) = t;\n+  DECL_PENDING_INLINE_P (decl) = 1;\n \n   /* Because we use obstacks, we must process these in precise order.  */\n   t->next = pending_inlines;"}, {"sha": "76524229b27e3c83339795f5d3e6bedd52e68fec", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59026e796378b6fa8ebf34d4c85fc9dcdc2e9d4c/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59026e796378b6fa8ebf34d4c85fc9dcdc2e9d4c/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=59026e796378b6fa8ebf34d4c85fc9dcdc2e9d4c", "patch": "@@ -5874,6 +5874,7 @@ tsubst_decl (t, args, type, in_decl)\n \tDECL_DEFER_OUTPUT (r) = 0;\n \tTREE_CHAIN (r) = NULL_TREE;\n \tDECL_PENDING_INLINE_INFO (r) = 0;\n+\tDECL_PENDING_INLINE_P (r) = 0;\n \tTREE_USED (r) = 0;\n \n \t/* Set up the DECL_TEMPLATE_INFO for R and compute its mangled"}]}