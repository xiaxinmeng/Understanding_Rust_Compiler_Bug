{"sha": "0a1bb917fc6358da39f7b7fa9a56e20b64c80f20", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGExYmI5MTdmYzYzNThkYTM5ZjdiN2ZhOWE1NmUyMGI2NGM4MGYyMA==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernds@redhat.com", "date": "2000-12-27T12:55:16Z"}, "committer": {"name": "Bernd Schmidt", "email": "bernds@gcc.gnu.org", "date": "2000-12-27T12:55:16Z"}, "message": "Avoid unnecessary dependencies on COND_EXEC insns.\n\nFrom-SVN: r38496", "tree": {"sha": "491ebf13a22c01f2a9f262e6afef161013b98273", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/491ebf13a22c01f2a9f262e6afef161013b98273"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0a1bb917fc6358da39f7b7fa9a56e20b64c80f20", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0a1bb917fc6358da39f7b7fa9a56e20b64c80f20", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0a1bb917fc6358da39f7b7fa9a56e20b64c80f20", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0a1bb917fc6358da39f7b7fa9a56e20b64c80f20/comments", "author": null, "committer": null, "parents": [{"sha": "6cbadf36b260041a608d34e6f839aef9403d68c1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6cbadf36b260041a608d34e6f839aef9403d68c1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6cbadf36b260041a608d34e6f839aef9403d68c1"}], "stats": {"total": 115, "additions": 99, "deletions": 16}, "files": [{"sha": "9be4297c4bb8e2a30e7fd6a0962a8f15c1e7c525", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a1bb917fc6358da39f7b7fa9a56e20b64c80f20/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a1bb917fc6358da39f7b7fa9a56e20b64c80f20/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0a1bb917fc6358da39f7b7fa9a56e20b64c80f20", "patch": "@@ -1,3 +1,11 @@\n+2000-12-27  Bernd Schmidt  <bernds@redhat.com>\n+\n+\t* sched-deps.c (get_condition, conditions_mutex_p): New functions.\n+\t(add_dependence): Use them to avoid adding unnecessary dependencies\n+\tbetween conditionally executed insns.\n+\t(sched_analyze_1, sched_analyze_2, sched_analyze_insn): Don't free\n+\tdependency lists if current insn is a COND_EXEC.\n+ \n 2000-12-27  Geoffrey Keating  <geoffk@redhat.com>\n \n \t* config/rs6000/rs6000.md (define_attr \"length\"): Correct"}, {"sha": "8d1e2f7ad2cf1139d377e2301d1119b2826c5c55", "filename": "gcc/sched-deps.c", "status": "modified", "additions": 91, "deletions": 16, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a1bb917fc6358da39f7b7fa9a56e20b64c80f20/gcc%2Fsched-deps.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a1bb917fc6358da39f7b7fa9a56e20b64c80f20/gcc%2Fsched-deps.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-deps.c?ref=0a1bb917fc6358da39f7b7fa9a56e20b64c80f20", "patch": "@@ -82,6 +82,9 @@ static void sched_analyze_1 PARAMS ((struct deps *, rtx, rtx));\n static void sched_analyze_2 PARAMS ((struct deps *, rtx, rtx));\n static void sched_analyze_insn PARAMS ((struct deps *, rtx, rtx, rtx));\n static rtx group_leader PARAMS ((rtx));\n+\n+static rtx get_condition PARAMS ((rtx));\n+static int conditions_mutex_p PARAMS ((rtx, rtx));\n \f\n /* Return the INSN_LIST containing INSN in LIST, or NULL\n    if LIST does not contain INSN.  */\n@@ -119,6 +122,53 @@ find_insn_mem_list (insn, x, list, list1)\n   return 0;\n }\n \f\n+/* Find the condition under which INSN is executed.  */\n+\n+static rtx\n+get_condition (insn)\n+     rtx insn;\n+{\n+  rtx pat = PATTERN (insn);\n+  rtx cond;\n+\n+  if (pat == 0)\n+    return 0;\n+  if (GET_CODE (pat) == COND_EXEC)\n+    return COND_EXEC_TEST (pat);\n+  if (GET_CODE (insn) != JUMP_INSN)\n+    return 0;\n+  if (GET_CODE (pat) != SET || SET_SRC (pat) != pc_rtx)\n+    return 0;\n+  if (GET_CODE (SET_DEST (pat)) != IF_THEN_ELSE)\n+    return 0;\n+  pat = SET_DEST (pat);\n+  cond = XEXP (pat, 0);\n+  if (GET_CODE (XEXP (cond, 1)) == LABEL_REF\n+      && XEXP (cond, 2) == pc_rtx)\n+    return cond;\n+  else if (GET_CODE (XEXP (cond, 2)) == LABEL_REF\n+\t   && XEXP (cond, 1) == pc_rtx)\n+    return gen_rtx_fmt_ee (reverse_condition (GET_CODE (cond)), GET_MODE (cond),\n+\t\t\t   XEXP (cond, 0), XEXP (cond, 1));\n+  else\n+    return 0;\n+}\n+\n+/* Return nonzero if conditions COND1 and COND2 can never be both true.  */\n+\n+static int\n+conditions_mutex_p (cond1, cond2)\n+     rtx cond1, cond2;\n+{\n+  if (GET_RTX_CLASS (GET_CODE (cond1)) == '<'\n+      && GET_RTX_CLASS (GET_CODE (cond2)) == '<'\n+      && GET_CODE (cond1) == reverse_condition (GET_CODE (cond2))\n+      && XEXP (cond1, 0) == XEXP (cond2, 0)\n+      && XEXP (cond1, 1) == XEXP (cond2, 1))\n+    return 1;\n+  return 0;\n+}\n+\f\n /* Add ELEM wrapped in an INSN_LIST with reg note kind DEP_TYPE to the\n    LOG_LINKS of INSN, if not already there.  DEP_TYPE indicates the type\n    of dependence that this link represents.  */\n@@ -132,6 +182,7 @@ add_dependence (insn, elem, dep_type)\n   rtx link, next;\n   int present_p;\n   enum reg_note present_dep_type;\n+  rtx cond1, cond2;\n \n   /* Don't depend an insn on itself.  */\n   if (insn == elem)\n@@ -143,6 +194,16 @@ add_dependence (insn, elem, dep_type)\n   if (GET_CODE (elem) == NOTE)\n     return;\n \n+  /* flow.c doesn't handle conditional lifetimes entirely correctly;\n+     calls mess up the conditional lifetimes.  */\n+  if (GET_CODE (insn) != CALL_INSN && GET_CODE (elem) != CALL_INSN)\n+    {\n+      cond1 = get_condition (insn);\n+      cond2 = get_condition (elem);\n+      if (cond1 && cond2 && conditions_mutex_p (cond1, cond2))\n+\treturn;\n+    }\n+\n   /* If elem is part of a sequence that must be scheduled together, then\n      make the dependence point to the last insn of the sequence.\n      When HAVE_cc0, it is possible for NOTEs to exist between users and\n@@ -524,7 +585,8 @@ sched_analyze_1 (deps, x, insn)\n \t\t pending clobber.  */\n \t      if (code == SET)\n \t\t{\n-\t\t  free_INSN_LIST_list (&deps->reg_last_uses[r]);\n+\t\t  if (GET_CODE (PATTERN (insn)) != COND_EXEC)\n+\t\t    free_INSN_LIST_list (&deps->reg_last_uses[r]);\n \t\t  for (u = deps->reg_last_clobbers[r]; u; u = XEXP (u, 1))\n \t\t    add_dependence (insn, XEXP (u, 0), REG_DEP_OUTPUT);\n \t\t  SET_REGNO_REG_SET (reg_pending_sets, r);\n@@ -550,7 +612,8 @@ sched_analyze_1 (deps, x, insn)\n \n \t  if (code == SET)\n \t    {\n-\t      free_INSN_LIST_list (&deps->reg_last_uses[regno]);\n+\t      if (GET_CODE (PATTERN (insn)) != COND_EXEC)\n+\t\tfree_INSN_LIST_list (&deps->reg_last_uses[regno]);\n \t      for (u = deps->reg_last_clobbers[regno]; u; u = XEXP (u, 1))\n \t\tadd_dependence (insn, XEXP (u, 0), REG_DEP_OUTPUT);\n \t      SET_REGNO_REG_SET (reg_pending_sets, regno);\n@@ -791,7 +854,8 @@ sched_analyze_2 (deps, x, insn)\n \t      {\n \t\tfor (u = deps->reg_last_uses[i]; u; u = XEXP (u, 1))\n \t\t  add_dependence (insn, XEXP (u, 0), REG_DEP_ANTI);\n-\t\tfree_INSN_LIST_list (&deps->reg_last_uses[i]);\n+\t\tif (GET_CODE (PATTERN (insn)) != COND_EXEC)\n+\t\t  free_INSN_LIST_list (&deps->reg_last_uses[i]);\n \n \t\tfor (u = deps->reg_last_sets[i]; u; u = XEXP (u, 1))\n \t\t  add_dependence (insn, XEXP (u, 0), 0);\n@@ -997,7 +1061,8 @@ sched_analyze_insn (deps, x, insn, loop_notes)\n \t      rtx u;\n \t      for (u = deps->reg_last_uses[i]; u; u = XEXP (u, 1))\n \t\tadd_dependence (insn, XEXP (u, 0), REG_DEP_ANTI);\n-\t      free_INSN_LIST_list (&deps->reg_last_uses[i]);\n+\t      if (GET_CODE (PATTERN (insn)) != COND_EXEC)\n+\t\tfree_INSN_LIST_list (&deps->reg_last_uses[i]);\n \n \t      for (u = deps->reg_last_sets[i]; u; u = XEXP (u, 1))\n \t\tadd_dependence (insn, XEXP (u, 0), 0);\n@@ -1017,27 +1082,37 @@ sched_analyze_insn (deps, x, insn, loop_notes)\n      subsequent sets will be output dependent on it.  */\n   EXECUTE_IF_SET_IN_REG_SET\n     (reg_pending_sets, 0, i,\n-     {\n-       free_INSN_LIST_list (&deps->reg_last_sets[i]);\n-       free_INSN_LIST_list (&deps->reg_last_clobbers[i]);\n-       deps->reg_last_sets[i] = alloc_INSN_LIST (insn, NULL_RTX);\n-     });\n+    {\n+      if (GET_CODE (PATTERN (insn)) != COND_EXEC)\n+\t{\n+\t  free_INSN_LIST_list (&deps->reg_last_sets[i]);\n+\t  free_INSN_LIST_list (&deps->reg_last_clobbers[i]);\n+\t  deps->reg_last_sets[i] = 0;\n+\t}\n+      deps->reg_last_sets[i]\n+\t= alloc_INSN_LIST (insn, deps->reg_last_sets[i]);\n+    });\n   EXECUTE_IF_SET_IN_REG_SET\n     (reg_pending_clobbers, 0, i,\n-     {\n-       deps->reg_last_clobbers[i]\n-\t = alloc_INSN_LIST (insn, deps->reg_last_clobbers[i]);\n-     });\n+    {\n+      deps->reg_last_clobbers[i]\n+\t= alloc_INSN_LIST (insn, deps->reg_last_clobbers[i]);\n+    });\n   CLEAR_REG_SET (reg_pending_sets);\n   CLEAR_REG_SET (reg_pending_clobbers);\n \n   if (reg_pending_sets_all)\n     {\n       for (i = 0; i < maxreg; i++)\n \t{\n-\t  free_INSN_LIST_list (&deps->reg_last_sets[i]);\n-\t  free_INSN_LIST_list (&deps->reg_last_clobbers[i]);\n-\t  deps->reg_last_sets[i] = alloc_INSN_LIST (insn, NULL_RTX);\n+\t  if (GET_CODE (PATTERN (insn)) != COND_EXEC)\n+\t    {\n+\t      free_INSN_LIST_list (&deps->reg_last_sets[i]);\n+\t      free_INSN_LIST_list (&deps->reg_last_clobbers[i]);\n+\t      deps->reg_last_sets[i] = 0;\n+\t    }\n+\t  deps->reg_last_sets[i]\n+\t    = alloc_INSN_LIST (insn, deps->reg_last_sets[i]);\n \t}\n \n       reg_pending_sets_all = 0;"}]}