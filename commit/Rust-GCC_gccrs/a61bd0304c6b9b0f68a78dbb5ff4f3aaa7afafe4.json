{"sha": "a61bd0304c6b9b0f68a78dbb5ff4f3aaa7afafe4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTYxYmQwMzA0YzZiOWIwZjY4YTc4ZGJiNWZmNGYzYWFhN2FmYWZlNA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2011-09-15T12:15:43Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2011-09-15T12:15:43Z"}, "message": "ipa-inline-analysis.c (add_condition): Add conditions parameter; simplify obviously true clauses.\n\n\t* ipa-inline-analysis.c (add_condition): Add conditions parameter;\n\tsimplify obviously true clauses.\n\t(and_predicates, or_predicates): Add conditions parameter.\n\t(inline_duplication_hoook): Update.\n\t(mark_modified): New function.\n\t(unmodified_parm): New function.\n\t(eliminated_by_inlining_prob, (set_cond_stmt_execution_predicate,\n\tset_switch_stmt_execution_predicate, will_be_nonconstant_predicate):\n\tUse unmodified_parm.\n\t(estimate_function_body_sizes): Update.\n\t(remap_predicate): Update.\n\nFrom-SVN: r178881", "tree": {"sha": "c376038af4bc9d199b58b228906c4ffe40f2fcac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c376038af4bc9d199b58b228906c4ffe40f2fcac"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a61bd0304c6b9b0f68a78dbb5ff4f3aaa7afafe4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a61bd0304c6b9b0f68a78dbb5ff4f3aaa7afafe4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a61bd0304c6b9b0f68a78dbb5ff4f3aaa7afafe4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a61bd0304c6b9b0f68a78dbb5ff4f3aaa7afafe4/comments", "author": null, "committer": null, "parents": [{"sha": "e0521991e43afe844ccb206889b54f96890cd86f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e0521991e43afe844ccb206889b54f96890cd86f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e0521991e43afe844ccb206889b54f96890cd86f"}], "stats": {"total": 167, "additions": 126, "deletions": 41}, "files": [{"sha": "d0b662bceff64042019574edb078ad53bf6bebcc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a61bd0304c6b9b0f68a78dbb5ff4f3aaa7afafe4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a61bd0304c6b9b0f68a78dbb5ff4f3aaa7afafe4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a61bd0304c6b9b0f68a78dbb5ff4f3aaa7afafe4", "patch": "@@ -1,3 +1,17 @@\n+2011-09-15  Jan Hubicka  <jh@suse.cz>\n+\n+\t* ipa-inline-analysis.c (add_condition): Add conditions parameter;\n+\tsimplify obviously true clauses.\n+\t(and_predicates, or_predicates): Add conditions parameter.\n+\t(inline_duplication_hoook): Update.\n+\t(mark_modified): New function.\n+\t(unmodified_parm): New function.\n+\t(eliminated_by_inlining_prob, (set_cond_stmt_execution_predicate,\n+\tset_switch_stmt_execution_predicate, will_be_nonconstant_predicate):\n+\tUse unmodified_parm.\n+\t(estimate_function_body_sizes): Update.\n+\t(remap_predicate): Update.\n+\n 2011-09-15  Ira Rosen  <ira.rosen@linaro.org>\n \n \t* tree-vect-data-refs.c (vect_analyze_data_ref_dependence): Allow"}, {"sha": "6bc96c7788e5a46b40616ed76180c4812e5abef9", "filename": "gcc/ipa-inline-analysis.c", "status": "modified", "additions": 112, "deletions": 41, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a61bd0304c6b9b0f68a78dbb5ff4f3aaa7afafe4/gcc%2Fipa-inline-analysis.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a61bd0304c6b9b0f68a78dbb5ff4f3aaa7afafe4/gcc%2Fipa-inline-analysis.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-analysis.c?ref=a61bd0304c6b9b0f68a78dbb5ff4f3aaa7afafe4", "patch": "@@ -232,11 +232,12 @@ add_condition (struct inline_summary *summary, int operand_num,\n /* Add clause CLAUSE into the predicate P.  */\n \n static inline void\n-add_clause (struct predicate *p, clause_t clause)\n+add_clause (conditions conditions, struct predicate *p, clause_t clause)\n {\n   int i;\n   int i2;\n   int insert_here = -1;\n+  int c1, c2;\n \n   /* True clause.  */\n   if (!clause)\n@@ -281,6 +282,28 @@ add_clause (struct predicate *p, clause_t clause)\n       if ((p->clause[i] & clause) != clause)\n \ti2++;\n     }\n+\n+  /* Look for clauses that are obviously true.  I.e.\n+     op0 == 5 || op0 != 5.  */\n+  for (c1 = predicate_first_dynamic_condition; c1 < NUM_CONDITIONS; c1++)\n+    for (c2 = c1 + 1; c2 <= NUM_CONDITIONS; c2++)\n+      if ((clause & (1 << c1))\n+\t  && (clause & (1 << c2)))\n+\t{\n+\t  condition *cc1 = VEC_index (condition,\n+\t\t\t\t      conditions,\n+\t\t\t\t      c1 - predicate_first_dynamic_condition);\n+\t  condition *cc2 = VEC_index (condition,\n+\t\t\t\t      conditions,\n+\t\t\t\t      c2 - predicate_first_dynamic_condition);\n+\t  if (cc1->operand_num == cc2->operand_num\n+\t      && cc1->val == cc2->val\n+\t      && cc1->code == invert_tree_comparison (cc2->code,\n+\t\t\t\t\t\t      HONOR_NANS (TYPE_MODE (TREE_TYPE (cc1->val)))))\n+\t    return;\n+\t}\n+\t\n+\n   /* We run out of variants.  Be conservative in positive direction.  */\n   if (i2 == MAX_CLAUSES)\n     return;\n@@ -298,7 +321,8 @@ add_clause (struct predicate *p, clause_t clause)\n /* Return P & P2.  */\n \n static struct predicate\n-and_predicates (struct predicate *p, struct predicate *p2)\n+and_predicates (conditions conditions,\n+\t\tstruct predicate *p, struct predicate *p2)\n {\n   struct predicate out = *p;\n   int i;\n@@ -319,7 +343,7 @@ and_predicates (struct predicate *p, struct predicate *p2)\n   for (; p2->clause[i]; i++)\n     {\n       gcc_checking_assert (i < MAX_CLAUSES);\n-      add_clause (&out, p2->clause[i]);\n+      add_clause (conditions, &out, p2->clause[i]);\n     }\n   return out;\n }\n@@ -346,7 +370,7 @@ predicates_equal_p (struct predicate *p, struct predicate *p2)\n /* Return P | P2.  */\n \n static struct predicate\n-or_predicates (struct predicate *p, struct predicate *p2)\n+or_predicates (conditions conditions, struct predicate *p, struct predicate *p2)\n {\n   struct predicate out = true_predicate ();\n   int i,j;\n@@ -364,7 +388,7 @@ or_predicates (struct predicate *p, struct predicate *p2)\n     for (j = 0; p2->clause[j]; j++)\n       {\n         gcc_checking_assert (i < MAX_CLAUSES && j < MAX_CLAUSES);\n-        add_clause (&out, p->clause[i] | p2->clause[j]);\n+        add_clause (conditions, &out, p->clause[i] | p2->clause[j]);\n       }\n   return out;\n }\n@@ -753,7 +777,7 @@ inline_node_duplication_hook (struct cgraph_node *src, struct cgraph_node *dst,\n \t\tbreak;\n \t      }\n \t    else\n-\t      add_clause (&new_predicate,\n+\t      add_clause (info->conds, &new_predicate,\n \t\t\t  possible_truths & e->predicate.clause[j]);\n \t  if (false_predicate_p (&new_predicate))\n \t    {\n@@ -781,7 +805,7 @@ inline_node_duplication_hook (struct cgraph_node *src, struct cgraph_node *dst,\n \t\tbreak;\n \t      }\n \t    else\n-\t      add_clause (&new_predicate,\n+\t      add_clause (info->conds, &new_predicate,\n \t\t\t  possible_truths & es->predicate->clause[j]);\n \t  if (false_predicate_p (&new_predicate)\n \t      && !false_predicate_p (es->predicate))\n@@ -812,7 +836,7 @@ inline_node_duplication_hook (struct cgraph_node *src, struct cgraph_node *dst,\n \t\tbreak;\n \t      }\n \t    else\n-\t      add_clause (&new_predicate,\n+\t      add_clause (info->conds, &new_predicate,\n \t\t\t  possible_truths & es->predicate->clause[j]);\n \t  if (false_predicate_p (&new_predicate)\n \t      && !false_predicate_p (es->predicate))\n@@ -1047,6 +1071,50 @@ initialize_inline_failed (struct cgraph_edge *e)\n     e->inline_failed = CIF_FUNCTION_NOT_CONSIDERED;\n }\n \n+/* Callback of walk_aliased_vdefs.  Flags that it has been invoked to the\n+   boolean variable pointed to by DATA.  */\n+\n+static bool\n+mark_modified (ao_ref *ao ATTRIBUTE_UNUSED, tree vdef ATTRIBUTE_UNUSED,\n+\t\t     void *data)\n+{\n+  bool *b = (bool *) data;\n+  *b = true;\n+  return true;\n+}\n+\n+/* If OP reffers to value of function parameter, return \n+   the corresponding parameter.  */\n+\n+static tree\n+unmodified_parm (gimple stmt, tree op)\n+{\n+  /* SSA_NAME referring to parm default def?  */\n+  if (TREE_CODE (op) == SSA_NAME\n+      && SSA_NAME_IS_DEFAULT_DEF (op)\n+      && TREE_CODE (SSA_NAME_VAR (op)) == PARM_DECL)\n+    return SSA_NAME_VAR (op);\n+  /* Non-SSA parm reference?  */\n+  if (TREE_CODE (op) == PARM_DECL)\n+    {\n+      bool modified = false;\n+\n+      ao_ref refd;\n+      ao_ref_init (&refd, op);\n+      walk_aliased_vdefs (&refd, gimple_vuse (stmt), mark_modified, &modified,\n+\t\t\t  NULL);\n+      if (!modified)\n+\treturn op;\n+    }\n+  /* Assignment from a parameter?  */\n+  if (TREE_CODE (op) == SSA_NAME\n+      && !SSA_NAME_IS_DEFAULT_DEF (op)\n+      && gimple_assign_single_p (SSA_NAME_DEF_STMT (op)))\n+    return unmodified_parm (SSA_NAME_DEF_STMT (op),\n+\t\t\t    gimple_assign_rhs1 (SSA_NAME_DEF_STMT (op)));\n+  return NULL;\n+}\n+\n /* See if statement might disappear after inlining.\n    0 - means not eliminated\n    1 - half of statements goes away\n@@ -1058,6 +1126,10 @@ static int\n eliminated_by_inlining_prob (gimple stmt)\n {\n   enum gimple_code code = gimple_code (stmt);\n+\n+  if (!optimize)\n+    return 0;\n+\n   switch (code)\n     {\n       case GIMPLE_RETURN:\n@@ -1090,11 +1162,7 @@ eliminated_by_inlining_prob (gimple stmt)\n \t\t   || TREE_CODE (inner_rhs) == MEM_REF)\n \t      inner_rhs = TREE_OPERAND (inner_rhs, 0);\n \n-\n-\t    if (TREE_CODE (inner_rhs) == PARM_DECL\n-\t        || (TREE_CODE (inner_rhs) == SSA_NAME\n-\t\t    && SSA_NAME_IS_DEFAULT_DEF (inner_rhs)\n-\t\t    && TREE_CODE (SSA_NAME_VAR (inner_rhs)) == PARM_DECL))\n+\t    if (unmodified_parm (stmt, inner_rhs))\n \t      rhs_free = true;\n \t    if (rhs_free && is_gimple_reg (lhs))\n \t      lhs_free = true;\n@@ -1136,6 +1204,7 @@ set_cond_stmt_execution_predicate (struct ipa_node_params *info,\n   edge_iterator ei;\n   gimple set_stmt;\n   tree op2;\n+  tree parm;\n \n   last = last_stmt (bb);\n   if (!last\n@@ -1147,11 +1216,10 @@ set_cond_stmt_execution_predicate (struct ipa_node_params *info,\n   /* TODO: handle conditionals like\n      var = op0 < 4;\n      if (var != 0).  */\n-  if (TREE_CODE (op) != SSA_NAME)\n-    return;\n-  if (SSA_NAME_IS_DEFAULT_DEF (op))\n+  parm = unmodified_parm (last, op);\n+  if (parm)\n     {\n-      index = ipa_get_param_decl_index (info, SSA_NAME_VAR (op));\n+      index = ipa_get_param_decl_index (info, parm);\n       if (index == -1)\n \treturn;\n       code = gimple_cond_code (last);\n@@ -1170,6 +1238,8 @@ set_cond_stmt_execution_predicate (struct ipa_node_params *info,\n \t}\n     }\n \n+  if (TREE_CODE (op) != SSA_NAME)\n+    return;\n   /* Special case\n      if (builtin_constant_p (op))\n        constant_code\n@@ -1185,11 +1255,10 @@ set_cond_stmt_execution_predicate (struct ipa_node_params *info,\n       || gimple_call_num_args (set_stmt) != 1)\n     return;\n   op2 = gimple_call_arg (set_stmt, 0);\n-  if (TREE_CODE (op2) != SSA_NAME)\n+  parm = unmodified_parm (set_stmt, op2);\n+  if (!parm)\n     return;\n-  if (!SSA_NAME_IS_DEFAULT_DEF (op2))\n-    return;\n-  index = ipa_get_param_decl_index (info, SSA_NAME_VAR (op2));\n+  index = ipa_get_param_decl_index (info, parm);\n   if (index == -1)\n     return;\n   if (gimple_cond_code (last) != NE_EXPR\n@@ -1223,16 +1292,17 @@ set_switch_stmt_execution_predicate (struct ipa_node_params *info,\n   edge_iterator ei;\n   size_t n;\n   size_t case_idx;\n+  tree parm;\n \n   last = last_stmt (bb);\n   if (!last\n       || gimple_code (last) != GIMPLE_SWITCH)\n     return;\n   op = gimple_switch_index (last);\n-  if (TREE_CODE (op) != SSA_NAME\n-      || !SSA_NAME_IS_DEFAULT_DEF (op))\n+  parm = unmodified_parm (last, op);\n+  if (!parm)\n     return;\n-  index = ipa_get_param_decl_index (info, SSA_NAME_VAR (op));\n+  index = ipa_get_param_decl_index (info, parm);\n   if (index == -1)\n     return;\n \n@@ -1270,10 +1340,10 @@ set_switch_stmt_execution_predicate (struct ipa_node_params *info,\n \t  p2 = add_condition (summary, index,\n \t\t\t      LE_EXPR,\n \t\t\t      max);\n-\t  p = and_predicates (&p1, &p2);\n+\t  p = and_predicates (summary->conds, &p1, &p2);\n \t}\n       *(struct predicate *)e->aux\n-\t= or_predicates (&p, (struct predicate *)e->aux);\n+\t= or_predicates (summary->conds, &p, (struct predicate *)e->aux);\n     }\n }\n \n@@ -1317,9 +1387,9 @@ compute_bb_predicates (struct cgraph_node *node,\n \t\t{\n \t\t  struct predicate this_bb_predicate = *(struct predicate *)e->src->aux;\n \t\t  if (e->aux)\n-\t\t    this_bb_predicate = and_predicates (&this_bb_predicate,\n+\t\t    this_bb_predicate = and_predicates (summary->conds, &this_bb_predicate,\n \t\t\t\t\t\t\t(struct predicate *)e->aux);\n-\t\t  p = or_predicates (&p, &this_bb_predicate);\n+\t\t  p = or_predicates (summary->conds, &p, &this_bb_predicate);\n \t\t  if (true_predicate_p (&p))\n \t\t    break;\n \t\t}\n@@ -1385,12 +1455,12 @@ will_be_nonconstant_predicate (struct ipa_node_params *info,\n      adding conditionals.  */\n   FOR_EACH_SSA_TREE_OPERAND (use, stmt, iter, SSA_OP_USE)\n     {\n-      if (TREE_CODE (use) != SSA_NAME)\n-\treturn p;\n+      tree parm = unmodified_parm (stmt, use);\n       /* For arguments we can build a condition.  */\n-      if (SSA_NAME_IS_DEFAULT_DEF (use)\n-\t  && ipa_get_param_decl_index (info, SSA_NAME_VAR (use)) >= 0)\n+      if (parm && ipa_get_param_decl_index (info, parm) >= 0)\n \tcontinue;\n+      if (TREE_CODE (use) != SSA_NAME)\n+\treturn p;\n       /* If we know when operand is constant,\n \t we still can say something useful.  */\n       if (!true_predicate_p (VEC_index (predicate_t, nonconstant_names,\n@@ -1401,15 +1471,15 @@ will_be_nonconstant_predicate (struct ipa_node_params *info,\n   op_non_const = false_predicate ();\n   FOR_EACH_SSA_TREE_OPERAND (use, stmt, iter, SSA_OP_USE)\n     {\n-      if (SSA_NAME_IS_DEFAULT_DEF (use)\n-\t  && ipa_get_param_decl_index (info, SSA_NAME_VAR (use)) >= 0)\n+      tree parm = unmodified_parm (stmt, use);\n+      if (parm && ipa_get_param_decl_index (info, parm) >= 0)\n \tp = add_condition (summary,\n-\t\t\t   ipa_get_param_decl_index (info, SSA_NAME_VAR (use)),\n+\t\t\t   ipa_get_param_decl_index (info, parm),\n \t\t\t   IS_NOT_CONSTANT, NULL);\n       else\n \tp = *VEC_index (predicate_t, nonconstant_names,\n \t\t\tSSA_NAME_VERSION (use));\n-      op_non_const = or_predicates (&p, &op_non_const);\n+      op_non_const = or_predicates (summary->conds, &p, &op_non_const);\n     }\n   if (gimple_code (stmt) == GIMPLE_ASSIGN\n       && TREE_CODE (gimple_assign_lhs (stmt)) == SSA_NAME)\n@@ -1563,7 +1633,7 @@ estimate_function_body_sizes (struct cgraph_node *node, bool early)\n \t\tfprintf (dump_file, \"\\t\\twill eliminated by inlining\\n\");\n \n \t      if (parms_info)\n-\t\tp = and_predicates (&bb_predicate, &will_be_nonconstant);\n+\t\tp = and_predicates (info->conds, &bb_predicate, &will_be_nonconstant);\n \t      else\n \t\tp = true_predicate ();\n \n@@ -1575,7 +1645,7 @@ estimate_function_body_sizes (struct cgraph_node *node, bool early)\n \t\t  if (prob)\n \t\t    {\n \t\t      struct predicate ip = not_inlined_predicate ();\n-\t\t      ip = and_predicates (&ip, &p);\n+\t\t      ip = and_predicates (info->conds, &ip, &p);\n \t\t      account_size_time (info, this_size * prob,\n \t\t\t\t\t this_time * prob, &ip);\n \t\t    }\n@@ -1901,11 +1971,12 @@ remap_predicate (struct inline_summary *info, struct inline_summary *callee_info\n \t\tcond_predicate.clause[0] = 1 << cond;\n \t\tcond_predicate.clause[1] = 0;\n \t      }\n-\t    clause_predicate = or_predicates (&clause_predicate, &cond_predicate);\n+\t    clause_predicate = or_predicates (info->conds, &clause_predicate,\n+\t\t\t\t\t      &cond_predicate);\n \t  }\n-      out = and_predicates (&out, &clause_predicate);\n+      out = and_predicates (info->conds, &out, &clause_predicate);\n     }\n-  return and_predicates (&out, toplev_predicate);\n+  return and_predicates (info->conds, &out, toplev_predicate);\n }\n \n "}]}