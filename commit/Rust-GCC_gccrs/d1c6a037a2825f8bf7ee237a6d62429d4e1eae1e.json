{"sha": "d1c6a037a2825f8bf7ee237a6d62429d4e1eae1e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDFjNmEwMzdhMjgyNWY4YmY3ZWUyMzdhNmQ2MjQyOWQ0ZTFlYWUxZQ==", "commit": {"author": {"name": "Bruce Korb", "email": "korbb@gcc.gnu.org", "date": "1999-04-26T10:38:38Z"}, "committer": {"name": "Bruce Korb", "email": "korbb@gcc.gnu.org", "date": "1999-04-26T10:38:38Z"}, "message": "properly handle child processes\n\nFrom-SVN: r26644", "tree": {"sha": "dae5e4203a1d87e4b29e6270b11212b8bd172720", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dae5e4203a1d87e4b29e6270b11212b8bd172720"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d1c6a037a2825f8bf7ee237a6d62429d4e1eae1e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d1c6a037a2825f8bf7ee237a6d62429d4e1eae1e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d1c6a037a2825f8bf7ee237a6d62429d4e1eae1e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d1c6a037a2825f8bf7ee237a6d62429d4e1eae1e/comments", "author": null, "committer": null, "parents": [{"sha": "039d4bceccafe860c779abb4dd40bd52a28ca4d5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/039d4bceccafe860c779abb4dd40bd52a28ca4d5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/039d4bceccafe860c779abb4dd40bd52a28ca4d5"}], "stats": {"total": 290, "additions": 185, "deletions": 105}, "files": [{"sha": "c8c54366aa34229bdac189cebf59384a00c26e41", "filename": "gcc/fixinc/fixincl.c", "status": "modified", "additions": 175, "deletions": 98, "changes": 273, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1c6a037a2825f8bf7ee237a6d62429d4e1eae1e/gcc%2Ffixinc%2Ffixincl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1c6a037a2825f8bf7ee237a6d62429d4e1eae1e/gcc%2Ffixinc%2Ffixincl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffixinc%2Ffixincl.c?ref=d1c6a037a2825f8bf7ee237a6d62429d4e1eae1e", "patch": "@@ -147,9 +147,11 @@ pid_t process_chain_head = (pid_t) -1;\n const char incl_quote_pat[] = \"^[ \\t]*#[ \\t]*include[ \\t]*\\\"[^/]\";\n regex_t incl_quote_re;\n \n-char *load_file (const char *pzFile);\n-void process (char *data, const char *file);\n-void run_compiles (void);\n+char *load_file (const char *);\n+void process (char *, const char *);\n+void run_compiles ();\n+void wait_for_pid( pid_t, int );\n+void initialize ();\n \n #include \"fixincl.x\"\n \n@@ -164,8 +166,6 @@ main (argc, argv)\n {\n   static const char gnu_lib_mark[] =\n     \"This file is part of the GNU C Library\";\n-  static const char var_not_found[] =\n-    \"fixincl ERROR:  %s environment variable not defined\\n\";\n \n #ifndef NO_BOGOSITY_LIMITS\n # define BOGUS_LIMIT    MINIMUM_MAXIMUM_LINES\n@@ -212,6 +212,113 @@ main (argc, argv)\n       exit (EXIT_FAILURE);\n     }\n \n+  initialize ();\n+\n+#ifndef NO_BOGOSITY_LIMITS\n+  /*  Some systems only allow so many calls to fork(2).\n+      This is inadequate for this program.  Consequently,\n+      we must let a grandfather process spawn children\n+      that then spawn all the processes that do the real work.\n+      */\n+  for (;;)\n+    {\n+      file_name_ct = 0;\n+\n+      {\n+        char *pz_buf = file_name_buf;\n+\n+        /* Only the parent process can read from stdin without confusing\n+           the world. (How does the child tell the parent to skip\n+           forward?  Pipes and files behave differently.)  */\n+\n+        while (  (file_name_ct < BOGUS_LIMIT)\n+              && (pz_buf < (file_name_buf + NAME_TABLE_SIZE - MAXPATHLEN)))\n+          {\n+            if (fgets (pz_buf, MAXPATHLEN, stdin) == (char *) NULL)\n+              break;\n+            while (isspace (*pz_buf))\n+              pz_buf++;\n+            if ((*pz_buf == '\\0') || (*pz_buf == '#'))\n+              continue;\n+            apz_names[file_name_ct++] = pz_buf;\n+            pz_buf += strlen (pz_buf);\n+            while (isspace (pz_buf[-1]))\n+              pz_buf--;\n+            *pz_buf++ = '\\0';\n+          }\n+      }\n+\n+      /*  IF we did not get any files this time thru\n+          THEN we must be done.  */\n+      if (file_name_ct == 0)\n+        return EXIT_SUCCESS;\n+\n+      {\n+        pid_t child = fork ();\n+        if (child == NULLPROCESS)\n+          break;\n+\n+        if (child == NOPROCESS)\n+          {\n+            fprintf (stderr, \"Error %d (%s) forking in main\\n\",\n+                     errno, strerror (errno));\n+            exit (EXIT_FAILURE);\n+          }\n+\n+        wait_for_pid( child, file_name_ct );\n+      }\n+    }\n+#else\n+#error \"NON-BOGUS LIMITS NOT SUPPORTED?!?!\"\n+#endif\n+\n+  /*\n+     Here we are the child of the grandparent process.  The parent\n+     of all the little fixup processes.  We ignore the deaths of\n+     our children.  */\n+\n+  signal (SIGCLD,  SIG_IGN);\n+\n+#ifdef DEBUG\n+  fprintf (stderr, \"Child start  --  processing %d files\\n\",\n+           file_name_ct);\n+#endif\n+\n+  /*  For every file specified in stdandard in\n+      (except as throttled for bogus reasons)...\n+      */\n+  for (loop_ct = 0; loop_ct < file_name_ct; loop_ct++)\n+    {\n+      char *pz_data;\n+      char *pz_file_name = apz_names[loop_ct];\n+\n+      if (access (pz_file_name, R_OK) != 0)\n+        {\n+          int erno = errno;\n+          fprintf (stderr, \"Cannot access %s from %s\\n\\terror %d (%s)\\n\",\n+                   pz_file_name, getcwd ((char *) NULL, MAXPATHLEN),\n+                   erno, strerror (erno));\n+        }\n+      else if (pz_data = load_file (pz_file_name), (pz_data != (char *) NULL))\n+        {\n+          if (strstr (pz_data, gnu_lib_mark) == (char *) NULL)\n+            process (pz_data, pz_file_name);\n+          free ((void *) pz_data);\n+        }\n+    }\n+\n+  return EXIT_SUCCESS;\n+}\n+\n+\n+/* * * * * * * * * * * * */\n+\n+void\n+initialize()\n+{\n+  static const char var_not_found[] =\n+    \"fixincl ERROR:  %s environment variable not defined\\n\";\n+\n   {\n     static const char var[] = \"TARGET_MACHINE\";\n     pz_machine = getenv (var);\n@@ -264,110 +371,74 @@ main (argc, argv)\n   signal (SIGALRM, SIG_IGN);\n   signal (SIGTERM, SIG_IGN);\n \n-#ifndef NO_BOGOSITY_LIMITS\n-  /*  Some systems only allow so many calls to fork(2).\n-      This is inadequate for this program.  Consequently,\n-      we must let a grandfather process spawn children\n-      that then spawn all the processes that do the real work.\n-      */\n-  for (;;)\n-    {\n-      char *pz_buf;\n-      pid_t child;\n-\n-      /* Only the parent process can read from stdin without confusing\n-         the world. (How does the child tell the parent to skip\n-         forward?  Pipes and files behave differently.)  */\n-      file_name_ct = 0;\n-      pz_buf = file_name_buf;\n-      while (  (file_name_ct < BOGUS_LIMIT)\n-            && (pz_buf < (file_name_buf + NAME_TABLE_SIZE - MAXPATHLEN)))\n-        {\n-          if (fgets (pz_buf, MAXPATHLEN, stdin) == (char *) NULL)\n-            break;\n-          while (isspace (*pz_buf))\n-            pz_buf++;\n-          if ((*pz_buf == '\\0') || (*pz_buf == '#'))\n-            continue;\n-          apz_names[file_name_ct++] = pz_buf;\n-          pz_buf += strlen (pz_buf);\n-          while (isspace (pz_buf[-1]))\n-            pz_buf--;\n-          *pz_buf++ = '\\0';\n-        }\n-\n-      /*  IF we did not get any files this time thru\n-          THEN we must be done.  */\n-      if (file_name_ct == 0)\n-        return EXIT_SUCCESS;\n-\n-      child = fork ();\n-      if (child == NULLPROCESS)\n-        break;\n+  /*\n+     Make sure that if we opened a server process, we close it now.\n+     This is the grandparent process.  We don't need the server anymore\n+     and our children should make their own.  */\n \n-      if (child == NOPROCESS)\n-        {\n-          fprintf (stderr, \"Error %d (%s) forking in main\\n\",\n-                   errno, strerror (errno));\n-          exit (EXIT_FAILURE);\n-        }\n-#ifndef DEBUG\n-      {\n-        int status;\n-        (void)wait (&status);\n-      }\n-#else\n-      fprintf (stderr, \"Waiting for %d to complete %d files\\n\",\n-               child, file_name_ct);\n+  close_server ();\n+  (void)wait ( (int*)NULL );\n+}\n \n-      {\n-        int status;\n-        pid_t dead_kid = wait (&status);\n+/* * * * * * * * * * * * *\n+ \n+   wait_for_pid  -  Keep calling `wait(2)' until it returns\n+   the process id we are looking for.  Not every system has\n+   `waitpid(2)'.  We also ensure that the children exit with success. */\n \n-        if (dead_kid != child)\n-          fprintf (stderr, \"fixincl woke up from a strange child %d (not %d)\\n\",\n-                   dead_kid, child);\n-        else\n-          fprintf (stderr, \"child finished %d files %s\\n\", file_name_ct,\n-                   status ? strerror (status & 0xFF) : \"ok\");\n-      }\n-#endif\n-    }\n-#else\n-#error \"NON-BOGUS LIMITS NOT SUPPORTED?!?!\"\n+void\n+wait_for_pid( pid_t child, int file_name_ct )\n+{\n+#ifdef DEBUG\n+  fprintf (stderr, \"Waiting for %d to complete %d files\\n\",\n+           child, file_name_ct);\n #endif\n \n-  signal (SIGCLD,  SIG_IGN);\n+  for (;;) {\n+    int status;\n+    pid_t dead_kid = wait (&status);\n \n+    if (dead_kid == child)\n+      {\n+        if (! WIFEXITED( status ))\n+          {\n+            fprintf (stderr, \"child process %d is hung on signal %d\\n\",\n+                     child, WSTOPSIG( status ));\n+            exit (EXIT_FAILURE);\n+          }\n+        if (WEXITSTATUS( status ) != 0)\n+          {\n+            fprintf (stderr, \"child process %d exited with status %d\\n\",\n+                     child, WEXITSTATUS( status ));\n+            exit (EXIT_FAILURE);\n+          }\n #ifdef DEBUG\n-  fprintf (stderr, \"Child start  --  processing %d files\\n\",\n-           file_name_ct);\n+        fprintf (stderr, \"child finished %d files %s\\n\", file_name_ct,\n+                 status ? strerror (status & 0xFF) : \"ok\");\n #endif\n+        break; /* normal child completion */\n+      }\n \n-  /*  For every file specified in stdandard in\n-      (except as throttled for bogus reasons)...\n-      */\n-  for (loop_ct = 0; loop_ct < file_name_ct; loop_ct++)\n-    {\n-      char *pz_data;\n-      char *pz_file_name = apz_names[loop_ct];\n+    /*\n+       IF there is an error, THEN see if it is retryable.\n+       If it is not retryable, then break out of this loop.  */\n+    if (dead_kid == NOPROCESS)\n+      {\n+        switch (errno) {\n+        case EINTR:\n+        case EAGAIN:\n+          break;\n \n-      if (access (pz_file_name, R_OK) != 0)\n-        {\n-          int erno = errno;\n-          fprintf (stderr, \"Cannot access %s from %s\\n\\terror %d (%s)\\n\",\n-                   pz_file_name, getcwd ((char *) NULL, MAXPATHLEN),\n-                   erno, strerror (erno));\n-        }\n-      else if (pz_data = load_file (pz_file_name), (pz_data != (char *) NULL))\n-        {\n-          if (strstr (pz_data, gnu_lib_mark) == (char *) NULL)\n-            process (pz_data, pz_file_name);\n-          free ((void *) pz_data);\n-        }\n-    }\n+        default:\n+          fprintf (stderr, \"Error %d (%s) waiting for %d to finish\\n\",\n+                   errno, strerror( errno ), child );\n+          /* FALLTHROUGH */\n \n-  return EXIT_SUCCESS;\n+        case ECHILD: /* no children to wait for?? */\n+          return;\n+        }\n+      }\n+  } done_waiting:;\n }\n \n \n@@ -476,6 +547,12 @@ run_compiles ()\n       exit (EXIT_FAILURE);\n     }\n \n+  /*  Make sure re_compile_pattern does not stumble across invalid\n+      data */\n+\n+  memset ( (void*)p_re, '\\0', REGEX_COUNT * sizeof (regex_t) );\n+  memset ( (void*)&incl_quote_re, '\\0', sizeof (regex_t) );\n+\n   /*  The patterns we search for are all egrep patterns.\n       In the shell version of this program, we invoke egrep\n       with the supplied pattern.  Here, we will run"}, {"sha": "51f86b50e195f71aeecde3ed17a034cf5a2978a2", "filename": "gcc/fixinc/server.c", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1c6a037a2825f8bf7ee237a6d62429d4e1eae1e/gcc%2Ffixinc%2Fserver.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1c6a037a2825f8bf7ee237a6d62429d4e1eae1e/gcc%2Ffixinc%2Fserver.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffixinc%2Fserver.c?ref=d1c6a037a2825f8bf7ee237a6d62429d4e1eae1e", "patch": "@@ -178,14 +178,17 @@ load_data (fp)\n  *  Make certain the server process is dead, close the \n  *  pipes to it and from it, finally NULL out the file pointers\n  */\n-static void\n+void\n close_server ()\n {\n-  kill ((pid_t) server_id, SIGKILL);\n-  server_id = NULLPROCESS;\n-  fclose (server_pair.pf_read);\n-  fclose (server_pair.pf_write);\n-  server_pair.pf_read = server_pair.pf_write = (FILE *) NULL;\n+  if (server_id != NULLPROCESS)\n+    {\n+      kill ((pid_t) server_id, SIGKILL);\n+      server_id = NULLPROCESS;\n+      fclose (server_pair.pf_read);\n+      fclose (server_pair.pf_write);\n+      server_pair.pf_read = server_pair.pf_write = (FILE *) NULL;\n+    }\n }\n \n /*"}, {"sha": "f270f36df369c8b2e22900e55889e377ec5e233a", "filename": "gcc/fixinc/server.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1c6a037a2825f8bf7ee237a6d62429d4e1eae1e/gcc%2Ffixinc%2Fserver.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1c6a037a2825f8bf7ee237a6d62429d4e1eae1e/gcc%2Ffixinc%2Fserver.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffixinc%2Fserver.h?ref=d1c6a037a2825f8bf7ee237a6d62429d4e1eae1e", "patch": "@@ -90,5 +90,5 @@ pid_t proc2_open  _P_ (( t_fd_pair * p_pair, t_pchar * pp_args));\n int chain_open    _P_ (( int in_fd,\n                          t_pchar * pp_args,\n                          pid_t * p_child));\n-\n+void close_server _P_ (( void ));\n #endif /* FIXINC_SERVER_H */"}]}