{"sha": "22505ad8f35c50ee96e5a642ea54e2de39ea2e52", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjI1MDVhZDhmMzVjNTBlZTk2ZTVhNjQyZWE1NGUyZGUzOWVhMmU1Mg==", "commit": {"author": {"name": "J\"orn Rennecke", "email": "amylaar@cygnus.co.uk", "date": "1999-02-12T13:12:48Z"}, "committer": {"name": "Joern Rennecke", "email": "amylaar@gcc.gnu.org", "date": "1999-02-12T13:12:48Z"}, "message": "reload.c (find_reloads_subreg_address): New function, broken out of find_reloads_toplev.\n\n\t* reload.c (find_reloads_subreg_address): New function, broken out of\n\tfind_reloads_toplev.\n\t(find_reloads_toplev, find_reloads_address_1): Use it.\n\nFrom-SVN: r25169", "tree": {"sha": "02c3aac08df3b1e319d10d40d7b59f1d88a58761", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/02c3aac08df3b1e319d10d40d7b59f1d88a58761"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/22505ad8f35c50ee96e5a642ea54e2de39ea2e52", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/22505ad8f35c50ee96e5a642ea54e2de39ea2e52", "html_url": "https://github.com/Rust-GCC/gccrs/commit/22505ad8f35c50ee96e5a642ea54e2de39ea2e52", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/22505ad8f35c50ee96e5a642ea54e2de39ea2e52/comments", "author": null, "committer": null, "parents": [{"sha": "01d5caad02c5c9b8dd14c7ca607d314aa8aca48f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/01d5caad02c5c9b8dd14c7ca607d314aa8aca48f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/01d5caad02c5c9b8dd14c7ca607d314aa8aca48f"}], "stats": {"total": 119, "additions": 91, "deletions": 28}, "files": [{"sha": "b88e8f84b9c570873e4476f66b4910c7ef44296e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22505ad8f35c50ee96e5a642ea54e2de39ea2e52/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22505ad8f35c50ee96e5a642ea54e2de39ea2e52/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=22505ad8f35c50ee96e5a642ea54e2de39ea2e52", "patch": "@@ -1,3 +1,9 @@\n+Fri Feb 12 21:09:51 1999  J\"orn Rennecke <amylaar@cygnus.co.uk>\n+\n+\t* reload.c (find_reloads_subreg_address): New function, broken out of\n+\tfind_reloads_toplev.\n+\t(find_reloads_toplev, find_reloads_address_1): Use it.\n+\n Fri Feb 12 13:20:52 1999  Jeffrey A Law  (law@cygnus.com)\n \n \t* h8300.md (zero_extendhisi2 H8/300 variant): Correctly handle"}, {"sha": "19c7efeacec5c23a8994c4f6e5bff0c381d84568", "filename": "gcc/reload.c", "status": "modified", "additions": 85, "deletions": 28, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22505ad8f35c50ee96e5a642ea54e2de39ea2e52/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22505ad8f35c50ee96e5a642ea54e2de39ea2e52/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=22505ad8f35c50ee96e5a642ea54e2de39ea2e52", "patch": "@@ -338,6 +338,8 @@ static int find_reloads_address_1 PROTO((enum machine_mode, rtx, int, rtx *,\n static void find_reloads_address_part PROTO((rtx, rtx *, enum reg_class,\n \t\t\t\t\t     enum machine_mode, int,\n \t\t\t\t\t     enum reload_type, int));\n+static rtx find_reloads_subreg_address PROTO((rtx, int, int, enum reload_type,\n+\t\t\t\t\t      int, rtx));\n static int find_inc_amount\tPROTO((rtx, rtx));\n static int loc_mentioned_in_p\tPROTO((rtx *, rtx));\n \f\n@@ -4483,34 +4485,8 @@ find_reloads_toplev (x, opnum, type, ind_levels, is_set_dest, insn)\n \t\t\t\t\t\t      XEXP (reg_equiv_mem[regno], 0))\n \t\t\t   || ! offsettable_memref_p (reg_equiv_mem[regno])\n \t\t\t   || num_not_at_initial_offset))))\n-\t{\n-\t  int offset = SUBREG_WORD (x) * UNITS_PER_WORD;\n-\t  /* We must rerun eliminate_regs, in case the elimination\n-\t     offsets have changed.  */\n-\t  rtx addr = XEXP (eliminate_regs (reg_equiv_memory_loc[regno], 0,\n-\t\t\t\t\t   NULL_RTX),\n-\t\t\t   0);\n-\t  if (BYTES_BIG_ENDIAN)\n-\t    {\n-\t      int size;\n-\t      size = GET_MODE_SIZE (GET_MODE (SUBREG_REG (x)));\n-\t      offset += MIN (size, UNITS_PER_WORD);\n-\t      size = GET_MODE_SIZE (GET_MODE (x));\n-\t      offset -= MIN (size, UNITS_PER_WORD);\n-\t    }\n-\t  addr = plus_constant (addr, offset);\n-\t  x = gen_rtx_MEM (GET_MODE (x), addr);\n-\t  RTX_UNCHANGING_P (x) = RTX_UNCHANGING_P (regno_reg_rtx[regno]);\n-\t  find_reloads_address (GET_MODE (x), &x,\n-\t\t\t\tXEXP (x, 0),\n-\t\t\t\t&XEXP (x, 0), opnum, type, ind_levels, insn);\n-\t  /* If this is not a toplevel operand, find_reloads doesn't see this\n-\t     substitution.  We have to emit a USE of the pseudo so that\n-\t     delete_output_reload can see it.  */\n-\t  if (replace_reloads && recog_operand[opnum] != x)\n-\t    emit_insn_before (gen_rtx_USE (VOIDmode, SUBREG_REG (x)), insn);\n-\t}\n-\n+\tx = find_reloads_subreg_address (x, 1, opnum, type, ind_levels,\n+\t\t\t\t\t insn);\n     }\n \n   for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n@@ -5519,6 +5495,8 @@ find_reloads_address_1 (mode, x, context, loc, opnum, type, ind_levels, insn)\n \t      if (CLASS_MAX_NREGS (class, GET_MODE (SUBREG_REG (x)))\n \t\t  > reg_class_size[class])\n \t\t{\n+\t\t  x = find_reloads_subreg_address (x, 0, opnum, type,\n+\t\t\t\t\t\t   ind_levels, insn);\n \t\t  push_reload (x, NULL_RTX, loc, NULL_PTR, class,\n \t\t\t       GET_MODE (x), VOIDmode, 0, 0, opnum, type);\n \t\t  return 1;\n@@ -5615,6 +5593,85 @@ find_reloads_address_part (x, loc, class, mode, opnum, type, ind_levels)\n \t       mode, VOIDmode, 0, 0, opnum, type);\n }\n \f\n+/* X, a subreg of a pseudo, is a part of an address that needs to be\n+   reloaded.\n+\n+   If the pseudo is equivalent to a memory location that cannot be directly\n+   addressed, make the necessary address reloads.\n+\n+   If address reloads have been necessary, or if the address is changed\n+   by register elimination, return the rtx of the memory location;\n+   otherwise, return X.\n+\n+   If FORCE_REPLACE is nonzero, unconditionally replace the subreg with the\n+   memory location.\n+\n+   OPNUM and TYPE identify the purpose of the reload.\n+\n+   IND_LEVELS says how many levels of indirect addressing are\n+   supported at this point in the address.\n+\n+   INSN, if nonzero, is the insn in which we do the reload.  It is used\n+   to determine where to put USEs for pseudos that we have to replace with\n+   stack slots.  */\n+\n+static rtx\n+find_reloads_subreg_address (x, force_replace, opnum, type,\n+\t\t\t     ind_levels, insn)\n+     rtx x;\n+     int force_replace;\n+     int opnum;\n+     enum reload_type type;\n+     int ind_levels;\n+     rtx insn;\n+{\n+  int regno = REGNO (SUBREG_REG (x));\n+\n+  if (reg_equiv_memory_loc[regno])\n+    {\n+      /* If the address is not directly addressable, or if the address is not\n+\t offsettable, then it must be replaced.  */\n+      if (! force_replace\n+\t  && (reg_equiv_address[regno]\n+\t      || ! offsettable_memref_p (reg_equiv_mem[regno])))\n+\tforce_replace = 1;\n+\n+      if (force_replace || num_not_at_initial_offset)\n+\t{\n+\t  rtx tem = make_memloc (SUBREG_REG (x), regno);\n+\n+\t  /* If the address changes because of register elimination, then\n+\t      it must be replaced.  */\n+\t  if (force_replace\n+\t      || ! rtx_equal_p (tem, reg_equiv_mem[regno]))\n+\t    {\n+\t      int offset = SUBREG_WORD (x) * UNITS_PER_WORD;\n+\n+\t      if (BYTES_BIG_ENDIAN)\n+\t\t{\n+\t\t  int size;\n+\n+\t\t  size = GET_MODE_SIZE (GET_MODE (SUBREG_REG (x)));\n+\t\t  offset += MIN (size, UNITS_PER_WORD);\n+\t\t  size = GET_MODE_SIZE (GET_MODE (x));\n+\t\t  offset -= MIN (size, UNITS_PER_WORD);\n+\t\t}\n+\t      XEXP (tem, 0) = plus_constant (XEXP (tem, 0), offset);\n+\t      PUT_MODE (tem, GET_MODE (x));\n+\t      x = tem;\n+\t      find_reloads_address (GET_MODE (x), &x, XEXP (x, 0), &XEXP (x, 0),\n+\t\t\t\t    opnum, ADDR_TYPE (type), ind_levels, insn);\n+\t      /* If this is not a toplevel operand, find_reloads doesn't see\n+\t\t this substitution.  We have to emit a USE of the pseudo so\n+\t\t that delete_output_reload can see it.  */\n+\t      if (replace_reloads && recog_operand[opnum] != x)\n+\t\temit_insn_before (gen_rtx_USE (VOIDmode, SUBREG_REG (x)), insn);\n+\t    }\n+\t}\n+    }\n+  return x;\n+}\n+\f\n /* Substitute into the current INSN the registers into which we have reloaded\n    the things that need reloading.  The array `replacements'\n    says contains the locations of all pointers that must be changed"}]}