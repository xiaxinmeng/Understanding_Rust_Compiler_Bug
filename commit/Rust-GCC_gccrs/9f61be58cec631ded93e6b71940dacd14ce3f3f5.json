{"sha": "9f61be58cec631ded93e6b71940dacd14ce3f3f5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWY2MWJlNThjZWM2MzFkZWQ5M2U2YjcxOTQwZGFjZDE0Y2UzZjNmNQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2018-01-03T07:19:14Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2018-01-03T07:19:14Z"}, "message": "poly_int: memrefs_conflict_p\n\nThe xsize and ysize arguments to memrefs_conflict_p are encode such\nthat:\n\n- 0 means the size is unknown\n- >0 means the size is known\n- <0 means that the negative of the size is a worst-case size after\n  alignment\n\nIn other words, the sign effectively encodes a boolean; it isn't\nmeant to be taken literally.  With poly_ints these correspond to:\n\n- must_eq (..., 0)\n- may_gt (..., 0)\n- may_lt (..., 0)\n\nrespectively.\n\n2018-01-03  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* alias.c (addr_side_effect_eval): Take the size as a poly_int64\n\trather than an int.  Use plus_constant.\n\t(memrefs_conflict_p): Take the sizes as poly_int64s rather than ints.\n\tTake the offset \"c\" as a poly_int64 rather than a HOST_WIDE_INT.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r256163", "tree": {"sha": "e646df49504aa965484c5c5900d2ccaa02140ec0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e646df49504aa965484c5c5900d2ccaa02140ec0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9f61be58cec631ded93e6b71940dacd14ce3f3f5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9f61be58cec631ded93e6b71940dacd14ce3f3f5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9f61be58cec631ded93e6b71940dacd14ce3f3f5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9f61be58cec631ded93e6b71940dacd14ce3f3f5/comments", "author": null, "committer": null, "parents": [{"sha": "5c8e61cfa26622b1aa1058e61ba68acfdc038dfa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5c8e61cfa26622b1aa1058e61ba68acfdc038dfa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5c8e61cfa26622b1aa1058e61ba68acfdc038dfa"}], "stats": {"total": 77, "additions": 43, "deletions": 34}, "files": [{"sha": "31092fbf2ae05aca8c2e73c0c67c892940cfc92b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f61be58cec631ded93e6b71940dacd14ce3f3f5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f61be58cec631ded93e6b71940dacd14ce3f3f5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9f61be58cec631ded93e6b71940dacd14ce3f3f5", "patch": "@@ -1,3 +1,12 @@\n+2018-01-03  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* alias.c (addr_side_effect_eval): Take the size as a poly_int64\n+\trather than an int.  Use plus_constant.\n+\t(memrefs_conflict_p): Take the sizes as poly_int64s rather than ints.\n+\tTake the offset \"c\" as a poly_int64 rather than a HOST_WIDE_INT.\n+\n 2018-01-03  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "7f3e4d25c539789afd60a52eddbc02ff916c1ba9", "filename": "gcc/alias.c", "status": "modified", "additions": 34, "deletions": 34, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f61be58cec631ded93e6b71940dacd14ce3f3f5/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f61be58cec631ded93e6b71940dacd14ce3f3f5/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=9f61be58cec631ded93e6b71940dacd14ce3f3f5", "patch": "@@ -148,7 +148,6 @@ struct GTY(()) alias_set_entry {\n };\n \n static int rtx_equal_for_memref_p (const_rtx, const_rtx);\n-static int memrefs_conflict_p (int, rtx, int, rtx, HOST_WIDE_INT);\n static void record_set (rtx, const_rtx, void *);\n static int base_alias_check (rtx, rtx, rtx, rtx, machine_mode,\n \t\t\t     machine_mode);\n@@ -2297,9 +2296,9 @@ get_addr (rtx x)\n     is not modified by the memory reference then ADDR is returned.  */\n \n static rtx\n-addr_side_effect_eval (rtx addr, int size, int n_refs)\n+addr_side_effect_eval (rtx addr, poly_int64 size, int n_refs)\n {\n-  int offset = 0;\n+  poly_int64 offset = 0;\n \n   switch (GET_CODE (addr))\n     {\n@@ -2320,11 +2319,7 @@ addr_side_effect_eval (rtx addr, int size, int n_refs)\n       return addr;\n     }\n \n-  if (offset)\n-    addr = gen_rtx_PLUS (GET_MODE (addr), XEXP (addr, 0),\n-\t\t\t gen_int_mode (offset, GET_MODE (addr)));\n-  else\n-    addr = XEXP (addr, 0);\n+  addr = plus_constant (GET_MODE (addr), XEXP (addr, 0), offset);\n   addr = canon_rtx (addr);\n \n   return addr;\n@@ -2374,7 +2369,8 @@ offset_overlap_p (poly_int64 c, poly_int64 xsize, poly_int64 ysize)\n    If that is fixed the TBAA hack for union type-punning can be removed.  */\n \n static int\n-memrefs_conflict_p (int xsize, rtx x, int ysize, rtx y, HOST_WIDE_INT c)\n+memrefs_conflict_p (poly_int64 xsize, rtx x, poly_int64 ysize, rtx y,\n+\t\t    poly_int64 c)\n {\n   if (GET_CODE (x) == VALUE)\n     {\n@@ -2419,13 +2415,13 @@ memrefs_conflict_p (int xsize, rtx x, int ysize, rtx y, HOST_WIDE_INT c)\n   else if (GET_CODE (x) == LO_SUM)\n     x = XEXP (x, 1);\n   else\n-    x = addr_side_effect_eval (x, abs (xsize), 0);\n+    x = addr_side_effect_eval (x, maybe_lt (xsize, 0) ? -xsize : xsize, 0);\n   if (GET_CODE (y) == HIGH)\n     y = XEXP (y, 0);\n   else if (GET_CODE (y) == LO_SUM)\n     y = XEXP (y, 1);\n   else\n-    y = addr_side_effect_eval (y, abs (ysize), 0);\n+    y = addr_side_effect_eval (y, maybe_lt (ysize, 0) ? -ysize : ysize, 0);\n \n   if (GET_CODE (x) == SYMBOL_REF && GET_CODE (y) == SYMBOL_REF)\n     {\n@@ -2438,7 +2434,7 @@ memrefs_conflict_p (int xsize, rtx x, int ysize, rtx y, HOST_WIDE_INT c)\n \t through alignment adjustments (i.e., that have negative\n \t sizes), because we can't know how far they are from each\n \t other.  */\n-      if (xsize < 0 || ysize < 0)\n+      if (maybe_lt (xsize, 0) || maybe_lt (ysize, 0))\n \treturn -1;\n       /* If decls are different or we know by offsets that there is no overlap,\n \t we win.  */\n@@ -2469,6 +2465,7 @@ memrefs_conflict_p (int xsize, rtx x, int ysize, rtx y, HOST_WIDE_INT c)\n       else if (x1 == y)\n \treturn memrefs_conflict_p (xsize, x0, ysize, const0_rtx, c);\n \n+      poly_int64 cx1, cy1;\n       if (GET_CODE (y) == PLUS)\n \t{\n \t  /* The fact that Y is canonicalized means that this\n@@ -2485,22 +2482,21 @@ memrefs_conflict_p (int xsize, rtx x, int ysize, rtx y, HOST_WIDE_INT c)\n \t    return memrefs_conflict_p (xsize, x0, ysize, y0, c);\n \t  if (rtx_equal_for_memref_p (x0, y0))\n \t    return memrefs_conflict_p (xsize, x1, ysize, y1, c);\n-\t  if (CONST_INT_P (x1))\n+\t  if (poly_int_rtx_p (x1, &cx1))\n \t    {\n-\t      if (CONST_INT_P (y1))\n+\t      if (poly_int_rtx_p (y1, &cy1))\n \t\treturn memrefs_conflict_p (xsize, x0, ysize, y0,\n-\t\t\t\t\t   c - INTVAL (x1) + INTVAL (y1));\n+\t\t\t\t\t   c - cx1 + cy1);\n \t      else\n-\t\treturn memrefs_conflict_p (xsize, x0, ysize, y,\n-\t\t\t\t\t   c - INTVAL (x1));\n+\t\treturn memrefs_conflict_p (xsize, x0, ysize, y, c - cx1);\n \t    }\n-\t  else if (CONST_INT_P (y1))\n-\t    return memrefs_conflict_p (xsize, x, ysize, y0, c + INTVAL (y1));\n+\t  else if (poly_int_rtx_p (y1, &cy1))\n+\t    return memrefs_conflict_p (xsize, x, ysize, y0, c + cy1);\n \n \t  return -1;\n \t}\n-      else if (CONST_INT_P (x1))\n-\treturn memrefs_conflict_p (xsize, x0, ysize, y, c - INTVAL (x1));\n+      else if (poly_int_rtx_p (x1, &cx1))\n+\treturn memrefs_conflict_p (xsize, x0, ysize, y, c - cx1);\n     }\n   else if (GET_CODE (y) == PLUS)\n     {\n@@ -2514,8 +2510,9 @@ memrefs_conflict_p (int xsize, rtx x, int ysize, rtx y, HOST_WIDE_INT c)\n       if (x == y1)\n \treturn memrefs_conflict_p (xsize, const0_rtx, ysize, y0, c);\n \n-      if (CONST_INT_P (y1))\n-\treturn memrefs_conflict_p (xsize, x, ysize, y0, c + INTVAL (y1));\n+      poly_int64 cy1;\n+      if (poly_int_rtx_p (y1, &cy1))\n+\treturn memrefs_conflict_p (xsize, x, ysize, y0, c + cy1);\n       else\n \treturn -1;\n     }\n@@ -2539,11 +2536,11 @@ memrefs_conflict_p (int xsize, rtx x, int ysize, rtx y, HOST_WIDE_INT c)\n \t    return offset_overlap_p (c, xsize, ysize);\n \n \t  /* Can't properly adjust our sizes.  */\n-\t  if (!CONST_INT_P (x1))\n+\t  if (!CONST_INT_P (x1)\n+\t      || !can_div_trunc_p (xsize, INTVAL (x1), &xsize)\n+\t      || !can_div_trunc_p (ysize, INTVAL (x1), &ysize)\n+\t      || !can_div_trunc_p (c, INTVAL (x1), &c))\n \t    return -1;\n-\t  xsize /= INTVAL (x1);\n-\t  ysize /= INTVAL (x1);\n-\t  c /= INTVAL (x1);\n \t  return memrefs_conflict_p (xsize, x0, ysize, y0, c);\n \t}\n \n@@ -2564,9 +2561,9 @@ memrefs_conflict_p (int xsize, rtx x, int ysize, rtx y, HOST_WIDE_INT c)\n       unsigned HOST_WIDE_INT uc = sc;\n       if (sc < 0 && pow2_or_zerop (-uc))\n \t{\n-\t  if (xsize > 0)\n+\t  if (maybe_gt (xsize, 0))\n \t    xsize = -xsize;\n-\t  if (xsize)\n+\t  if (maybe_ne (xsize, 0))\n \t    xsize += sc + 1;\n \t  c -= sc + 1;\n \t  return memrefs_conflict_p (xsize, canon_rtx (XEXP (x, 0)),\n@@ -2579,9 +2576,9 @@ memrefs_conflict_p (int xsize, rtx x, int ysize, rtx y, HOST_WIDE_INT c)\n       unsigned HOST_WIDE_INT uc = sc;\n       if (sc < 0 && pow2_or_zerop (-uc))\n \t{\n-\t  if (ysize > 0)\n+\t  if (maybe_gt (ysize, 0))\n \t    ysize = -ysize;\n-\t  if (ysize)\n+\t  if (maybe_ne (ysize, 0))\n \t    ysize += sc + 1;\n \t  c += sc + 1;\n \t  return memrefs_conflict_p (xsize, x,\n@@ -2591,9 +2588,10 @@ memrefs_conflict_p (int xsize, rtx x, int ysize, rtx y, HOST_WIDE_INT c)\n \n   if (CONSTANT_P (x))\n     {\n-      if (CONST_INT_P (x) && CONST_INT_P (y))\n+      poly_int64 cx, cy;\n+      if (poly_int_rtx_p (x, &cx) && poly_int_rtx_p (y, &cy))\n \t{\n-\t  c += (INTVAL (y) - INTVAL (x));\n+\t  c += cy - cx;\n \t  return offset_overlap_p (c, xsize, ysize);\n \t}\n \n@@ -2615,7 +2613,9 @@ memrefs_conflict_p (int xsize, rtx x, int ysize, rtx y, HOST_WIDE_INT c)\n \t sizes), because we can't know how far they are from each\n \t other.  */\n       if (CONSTANT_P (y))\n-\treturn (xsize < 0 || ysize < 0 || offset_overlap_p (c, xsize, ysize));\n+\treturn (maybe_lt (xsize, 0)\n+\t\t|| maybe_lt (ysize, 0)\n+\t\t|| offset_overlap_p (c, xsize, ysize));\n \n       return -1;\n     }"}]}