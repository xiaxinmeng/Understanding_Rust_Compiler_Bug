{"sha": "86ac05753c9d7fcf27375fe17e70cda5333ab50e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODZhYzA1NzUzYzlkN2ZjZjI3Mzc1ZmUxN2U3MGNkYTUzMzNhYjUwZQ==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2003-02-15T18:03:22Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2003-02-15T18:03:22Z"}, "message": "search.c: ANSIfy function declarations and definitions.\n\n\t* search.c: ANSIfy function declarations and definitions.\n\t* cp-tree.h (lookup_field, lookup_member): Last parameter is a bool.\n\t* call.c (build_method_call, resolve_scoped_fn_name,\n\tbuild_java_interface_fn_ref): Adjust lookup_field, lookup_member\n\tcalls.\n\t* class.c (handle_using_decl): Likewise.\n\t* decl.c (make_typename_type, make_unmound_class_template,\n\tstart_decl, compute_array_index_type): Likewise.\n\t* decl2.c (build_expr_from_tree, build_call_from_tree): Likewise.\n\t* init.c (expand_member_init, build_member_call): Likewise.\n\t* pt.c (tsubst_copy, tsubst_copy_and_build, do_decl_instantiation,\n\tresolve_typename_type): Likewise.\n\t* typeck.c (lookup_destructor, finish_class_member_access_exprm\n\tbuild_prememfunc_access_expr): Likewise.\n\nFrom-SVN: r62939", "tree": {"sha": "ece5620dc1576e0716969553f06d65c2797fa96f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ece5620dc1576e0716969553f06d65c2797fa96f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/86ac05753c9d7fcf27375fe17e70cda5333ab50e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/86ac05753c9d7fcf27375fe17e70cda5333ab50e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/86ac05753c9d7fcf27375fe17e70cda5333ab50e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/86ac05753c9d7fcf27375fe17e70cda5333ab50e/comments", "author": null, "committer": null, "parents": [{"sha": "6ff741aa6c830df0ec7adbd3c4ccf79845b0853a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6ff741aa6c830df0ec7adbd3c4ccf79845b0853a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6ff741aa6c830df0ec7adbd3c4ccf79845b0853a"}], "stats": {"total": 475, "additions": 177, "deletions": 298}, "files": [{"sha": "2ddc227941e34c90bc9c10a7a5e5c7afb01b5309", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86ac05753c9d7fcf27375fe17e70cda5333ab50e/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86ac05753c9d7fcf27375fe17e70cda5333ab50e/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=86ac05753c9d7fcf27375fe17e70cda5333ab50e", "patch": "@@ -1,3 +1,20 @@\n+2003-02-14  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* search.c: ANSIfy function declarations and definitions.\n+\t* cp-tree.h (lookup_field, lookup_member): Last parameter is a bool.\n+\t* call.c (build_method_call, resolve_scoped_fn_name,\n+\tbuild_java_interface_fn_ref): Adjust lookup_field, lookup_member\n+\tcalls.\n+\t* class.c (handle_using_decl): Likewise.\n+\t* decl.c (make_typename_type, make_unmound_class_template,\n+\tstart_decl, compute_array_index_type): Likewise.\n+\t* decl2.c (build_expr_from_tree, build_call_from_tree): Likewise.\n+\t* init.c (expand_member_init, build_member_call): Likewise.\n+\t* pt.c (tsubst_copy, tsubst_copy_and_build, do_decl_instantiation,\n+\tresolve_typename_type): Likewise.\n+\t* typeck.c (lookup_destructor, finish_class_member_access_exprm\n+\tbuild_prememfunc_access_expr): Likewise.\n+\n 2003-02-13  Gabriel Dos Reis <gdr@integrable-solutions.net>\n \n \t* decl2.c: Include \"timevar.h\"."}, {"sha": "0aa2d5360a5c5c2724d0dbd89c6a232217498901", "filename": "gcc/cp/call.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86ac05753c9d7fcf27375fe17e70cda5333ab50e/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86ac05753c9d7fcf27375fe17e70cda5333ab50e/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=86ac05753c9d7fcf27375fe17e70cda5333ab50e", "patch": "@@ -524,7 +524,7 @@ build_method_call (tree instance, tree name, tree parms,\n   if (has_template_args)\n     fn = lookup_fnfields (object_type, name, /*protect=*/2);\n   else\n-    fn = lookup_member (object_type, name, /*protect=*/2, /*want_type=*/0);\n+    fn = lookup_member (object_type, name, /*protect=*/2, /*want_type=*/false);\n   \n   if (fn && TREE_CODE (fn) == TREE_LIST && !BASELINK_P (fn))\n     {\n@@ -2623,7 +2623,7 @@ resolve_scoped_fn_name (tree scope, tree name)\n       if (BASELINK_P (name))\n \tfn = name;\n       else\n-\tfn = lookup_member (scope, name, /*protect=*/1, /*prefer_type=*/0);\n+\tfn = lookup_member (scope, name, /*protect=*/1, /*want_type=*/false);\n       if (fn && current_class_type)\n \tfn = (adjust_result_of_qualified_name_lookup \n \t      (fn, scope, current_class_type));\n@@ -4529,7 +4529,7 @@ build_java_interface_fn_ref (tree fn, tree instance)\n \n   /* Get the java.lang.Class pointer for the interface being called.  */\n   iface = DECL_CONTEXT (fn);\n-  iface_ref = lookup_field (iface, get_identifier (\"class$\"), 0, 0);\n+  iface_ref = lookup_field (iface, get_identifier (\"class$\"), 0, false);\n   if (!iface_ref || TREE_CODE (iface_ref) != VAR_DECL\n       || DECL_CONTEXT (iface_ref) != iface)\n     {"}, {"sha": "04130a06323ee24760de7014ec0b87ba1a5d99da", "filename": "gcc/cp/class.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86ac05753c9d7fcf27375fe17e70cda5333ab50e/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86ac05753c9d7fcf27375fe17e70cda5333ab50e/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=86ac05753c9d7fcf27375fe17e70cda5333ab50e", "patch": "@@ -1122,7 +1122,7 @@ handle_using_decl (tree using_decl, tree t)\n       return;\n     }\n \n-  fdecl = lookup_member (binfo, name, 0, 0);\n+  fdecl = lookup_member (binfo, name, 0, false);\n   \n   if (!fdecl)\n     {"}, {"sha": "a0c41341901a2912fb80b3a28262d9be1a2401e8", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86ac05753c9d7fcf27375fe17e70cda5333ab50e/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86ac05753c9d7fcf27375fe17e70cda5333ab50e/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=86ac05753c9d7fcf27375fe17e70cda5333ab50e", "patch": "@@ -4121,10 +4121,10 @@ extern int types_overlap_p\t\t\t(tree, tree);\n extern tree get_vbase\t\t\t\t(tree, tree);\n extern tree get_dynamic_cast_base_type          (tree, tree);\n extern int accessible_p                         (tree, tree);\n-extern tree lookup_field\t\t\t(tree, tree, int, int);\n+extern tree lookup_field\t\t\t(tree, tree, int, bool);\n extern int lookup_fnfields_1                    (tree, tree);\n extern tree lookup_fnfields\t\t\t(tree, tree, int);\n-extern tree lookup_member\t\t\t(tree, tree, int, int);\n+extern tree lookup_member\t\t\t(tree, tree, int, bool);\n extern int look_for_overrides\t\t\t(tree, tree);\n extern void get_pure_virtuals\t\t        (tree);\n extern void get_vbase_types\t\t\t(tree);"}, {"sha": "fc9051bce94d9fef13761fee1753c7aea69bc75b", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86ac05753c9d7fcf27375fe17e70cda5333ab50e/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86ac05753c9d7fcf27375fe17e70cda5333ab50e/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=86ac05753c9d7fcf27375fe17e70cda5333ab50e", "patch": "@@ -5560,7 +5560,7 @@ make_typename_type (tree context, tree name, tsubst_flags_t complain)\n \t{\n \t  tree tmpl = NULL_TREE;\n \t  if (IS_AGGR_TYPE (context))\n-\t    tmpl = lookup_field (context, name, 0, 0);\n+\t    tmpl = lookup_field (context, name, 0, false);\n \t  if (!tmpl || !DECL_CLASS_TEMPLATE_P (tmpl))\n \t    {\n \t      if (complain & tf_error)\n@@ -5594,7 +5594,7 @@ make_typename_type (tree context, tree name, tsubst_flags_t complain)\n \t      return error_mark_node;\n \t    }\n \n-\t  t = lookup_field (context, name, 0, 1);\n+\t  t = lookup_field (context, name, 0, true);\n \t  if (t)\n \t    {\n \t      if (TREE_CODE (t) != TYPE_DECL)\n@@ -5657,7 +5657,7 @@ make_unbound_class_template (tree context, tree name, tsubst_flags_t complain)\n       tree tmpl = NULL_TREE;\n \n       if (IS_AGGR_TYPE (context))\n-\ttmpl = lookup_field (context, name, 0, 0);\n+\ttmpl = lookup_field (context, name, 0, false);\n \n       if (!tmpl || !DECL_CLASS_TEMPLATE_P (tmpl))\n \t{\n@@ -7099,7 +7099,7 @@ start_decl (tree declarator,\n \n       if (TREE_CODE (decl) == VAR_DECL)\n \t{\n-\t  tree field = lookup_field (context, DECL_NAME (decl), 0, 0);\n+\t  tree field = lookup_field (context, DECL_NAME (decl), 0, false);\n \t  if (field == NULL_TREE || TREE_CODE (field) != VAR_DECL)\n \t    error (\"`%#D' is not a static member of `%#T'\", decl, context);\n \t  else\n@@ -9378,7 +9378,7 @@ compute_array_index_type (tree name, tree size)\n \t  && TREE_OPERAND (size, 0) == current_class_type)\n \t{\n \t  tree t = lookup_field (current_class_type,\n-\t\t\t\t TREE_OPERAND (size, 1), 0, 0);\n+\t\t\t\t TREE_OPERAND (size, 1), 0, false);\n \t  if (t)\n \t    size = t;\n \t}"}, {"sha": "ae174034c083650cca7fab85c8e0f067a4988c88", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86ac05753c9d7fcf27375fe17e70cda5333ab50e/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86ac05753c9d7fcf27375fe17e70cda5333ab50e/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=86ac05753c9d7fcf27375fe17e70cda5333ab50e", "patch": "@@ -1,6 +1,6 @@\n /* Process declarations and variables for C++ compiler.\n    Copyright (C) 1988, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n-   1999, 2000, 2001, 2002 Free Software Foundation, Inc.\n+   1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.\n    Hacked by Michael Tiemann (tiemann@cygnus.com)\n \n This file is part of GCC.\n@@ -3087,7 +3087,7 @@ build_expr_from_tree (t)\n               && !LOOKUP_EXPR_GLOBAL (name)\n               && TREE_CODE ((id = TREE_OPERAND (name, 0))) == IDENTIFIER_NODE\n               && (!current_class_type\n-                  || !lookup_member (current_class_type, id, 0, 0)))\n+                  || !lookup_member (current_class_type, id, 0, false)))\n             {\n               /* Do Koenig lookup if there are no class members.  */\n               name = do_identifier (id, args);\n@@ -3325,7 +3325,7 @@ build_call_from_tree (tree fn, tree args, bool disallow_virtual)\n \t      && DECL_FUNCTION_MEMBER_P (f))))\n     {\n       f = lookup_member (current_class_type, DECL_NAME (f), \n-\t\t\t /*protect=*/1, /*want_type=*/0);\n+\t\t\t /*protect=*/1, /*want_type=*/false);\n       if (f)\n \tfn = f;\n     }"}, {"sha": "bb387ce1b0134c877a79c6be792a0d031688734b", "filename": "gcc/cp/init.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86ac05753c9d7fcf27375fe17e70cda5333ab50e/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86ac05753c9d7fcf27375fe17e70cda5333ab50e/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=86ac05753c9d7fcf27375fe17e70cda5333ab50e", "patch": "@@ -1026,7 +1026,7 @@ expand_member_init (tree name, tree init)\n   else\n     {\n       if (TREE_CODE (name) == IDENTIFIER_NODE)\n-\tfield = lookup_field (current_class_type, name, 1, 0);\n+\tfield = lookup_field (current_class_type, name, 1, false);\n       else\n \tfield = name;\n \n@@ -1490,7 +1490,7 @@ build_member_call (type, name, parmlist)\n   if (constructor_name_p (method_name, type))\n     return build_functional_cast (type, parmlist);\n   if (TREE_CODE (name) == IDENTIFIER_NODE\n-      && ((t = lookup_field (TYPE_BINFO (type), name, 1, 0))))\n+      && ((t = lookup_field (TYPE_BINFO (type), name, 1, false))))\n     {\n       if (t == error_mark_node)\n \treturn error_mark_node;"}, {"sha": "d04ec2356a9b2b786b272e9d0ccf553b9fb93dc9", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86ac05753c9d7fcf27375fe17e70cda5333ab50e/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86ac05753c9d7fcf27375fe17e70cda5333ab50e/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=86ac05753c9d7fcf27375fe17e70cda5333ab50e", "patch": "@@ -7176,7 +7176,7 @@ tsubst_copy (t, args, complain, in_decl)\n \t  ctx = tsubst_aggr_type (DECL_CONTEXT (t), args, complain, in_decl,\n \t\t\t\t  /*entering_scope=*/1);\n \t  if (ctx != DECL_CONTEXT (t))\n-\t    return lookup_field (ctx, DECL_NAME (t), 0, 0);\n+\t    return lookup_field (ctx, DECL_NAME (t), 0, false);\n \t}\n       return t;\n \n@@ -8166,7 +8166,7 @@ tsubst_copy_and_build (t, args, complain, in_decl)\n \t\t&& (TREE_CODE ((id = TREE_OPERAND (name, 0)))\n \t\t    == IDENTIFIER_NODE)\n \t\t&& (!current_class_type\n-\t\t    || !lookup_member (current_class_type, id, 0, 0)))\n+\t\t    || !lookup_member (current_class_type, id, 0, false)))\n \t      {\n \t\t/* Do Koenig lookup if there are no class members.  */\n \t\tname = do_identifier (id, copy_args);\n@@ -10235,7 +10235,7 @@ do_decl_instantiation (tree decl, tree storage)\n \t VAR_DECLs so we do the lookup here.  Probably, grokdeclarator\n \t should handle VAR_DECLs as it currently handles\n \t FUNCTION_DECLs.  */\n-      result = lookup_field (DECL_CONTEXT (decl), DECL_NAME (decl), 0, 0);\n+      result = lookup_field (DECL_CONTEXT (decl), DECL_NAME (decl), 0, false);\n       if (!result || TREE_CODE (result) != VAR_DECL)\n \t{\n \t  error (\"no matching template for `%D' found\", decl);\n@@ -11546,7 +11546,7 @@ resolve_typename_type (tree type, bool only_current_p)\n      longer be considered a dependent type.  */\n   push_scope (scope);\n   /* Look up the declaration.  */\n-  decl = lookup_member (scope, name, /*protect=*/0, /*want_type=*/1);\n+  decl = lookup_member (scope, name, /*protect=*/0, /*want_type=*/true);\n   /* Obtain the set of qualifiers applied to the TYPE.  */\n   quals = cp_type_quals (type);\n   /* For a TYPENAME_TYPE like \"typename X::template Y<T>\", we want to"}, {"sha": "a87ba5f602982f8e4bf8de4e582b51e2b1f0d55a", "filename": "gcc/cp/search.c", "status": "modified", "additions": 135, "deletions": 273, "changes": 408, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86ac05753c9d7fcf27375fe17e70cda5333ab50e/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86ac05753c9d7fcf27375fe17e70cda5333ab50e/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=86ac05753c9d7fcf27375fe17e70cda5333ab50e", "patch": "@@ -1,7 +1,7 @@\n /* Breadth-first and depth-first routines for\n    searching multiple-inheritance lattice for GNU C++.\n    Copyright (C) 1987, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n-   1999, 2000, 2002 Free Software Foundation, Inc.\n+   1999, 2000, 2002, 2003 Free Software Foundation, Inc.\n    Contributed by Michael Tiemann (tiemann@cygnus.com)\n \n This file is part of GCC.\n@@ -81,59 +81,55 @@ struct vbase_info\n   tree inits;\n };\n \n-static tree lookup_field_1 PARAMS ((tree, tree));\n-static int is_subobject_of_p PARAMS ((tree, tree, tree));\n-static int is_subobject_of_p_1 PARAMS ((tree, tree, tree));\n-static tree dfs_check_overlap PARAMS ((tree, void *));\n-static tree dfs_no_overlap_yet PARAMS ((tree, void *));\n-static base_kind lookup_base_r\n-\tPARAMS ((tree, tree, base_access, int, int, int, tree *));\n-static int dynamic_cast_base_recurse PARAMS ((tree, tree, int, tree *));\n-static tree marked_pushdecls_p PARAMS ((tree, void *));\n-static tree unmarked_pushdecls_p PARAMS ((tree, void *));\n-static tree dfs_debug_unmarkedp PARAMS ((tree, void *));\n-static tree dfs_debug_mark PARAMS ((tree, void *));\n-static tree dfs_get_vbase_types PARAMS ((tree, void *));\n-static tree dfs_push_type_decls PARAMS ((tree, void *));\n-static tree dfs_push_decls PARAMS ((tree, void *));\n-static tree dfs_unuse_fields PARAMS ((tree, void *));\n-static tree add_conversions PARAMS ((tree, void *));\n-static int look_for_overrides_r PARAMS ((tree, tree));\n-static struct search_level *push_search_level\n-\tPARAMS ((struct stack_level *, struct obstack *));\n-static struct search_level *pop_search_level\n-\tPARAMS ((struct stack_level *));\n-static tree bfs_walk\n-\tPARAMS ((tree, tree (*) (tree, void *), tree (*) (tree, void *),\n-\t       void *));\n-static tree lookup_field_queue_p PARAMS ((tree, void *));\n-static int shared_member_p PARAMS ((tree));\n-static tree lookup_field_r PARAMS ((tree, void *));\n-static tree canonical_binfo PARAMS ((tree));\n-static tree shared_marked_p PARAMS ((tree, void *));\n-static tree shared_unmarked_p PARAMS ((tree, void *));\n-static int  dependent_base_p PARAMS ((tree));\n-static tree dfs_accessible_queue_p PARAMS ((tree, void *));\n-static tree dfs_accessible_p PARAMS ((tree, void *));\n-static tree dfs_access_in_type PARAMS ((tree, void *));\n-static access_kind access_in_type PARAMS ((tree, tree));\n-static tree dfs_canonical_queue PARAMS ((tree, void *));\n-static tree dfs_assert_unmarked_p PARAMS ((tree, void *));\n-static void assert_canonical_unmarked PARAMS ((tree));\n-static int protected_accessible_p PARAMS ((tree, tree, tree));\n-static int friend_accessible_p PARAMS ((tree, tree, tree));\n-static void setup_class_bindings PARAMS ((tree, int));\n-static int template_self_reference_p PARAMS ((tree, tree));\n-static tree dfs_find_vbase_instance PARAMS ((tree, void *));\n-static tree dfs_get_pure_virtuals PARAMS ((tree, void *));\n-static tree dfs_build_inheritance_graph_order PARAMS ((tree, void *));\n+static tree lookup_field_1 (tree, tree);\n+static int is_subobject_of_p (tree, tree, tree);\n+static int is_subobject_of_p_1 (tree, tree, tree);\n+static tree dfs_check_overlap (tree, void *);\n+static tree dfs_no_overlap_yet (tree, void *);\n+static base_kind lookup_base_r (tree, tree, base_access,\n+\t\t\t\tbool, bool, bool, tree *);\n+static int dynamic_cast_base_recurse (tree, tree, bool, tree *);\n+static tree marked_pushdecls_p (tree, void *);\n+static tree unmarked_pushdecls_p (tree, void *);\n+static tree dfs_debug_unmarkedp (tree, void *);\n+static tree dfs_debug_mark (tree, void *);\n+static tree dfs_get_vbase_types (tree, void *);\n+static tree dfs_push_type_decls (tree, void *);\n+static tree dfs_push_decls (tree, void *);\n+static tree dfs_unuse_fields (tree, void *);\n+static tree add_conversions (tree, void *);\n+static int look_for_overrides_r (tree, tree);\n+static struct search_level *push_search_level (struct stack_level *,\n+\t\t\t\t\t       struct obstack *);\n+static struct search_level *pop_search_level (struct stack_level *);\n+static tree bfs_walk (tree, tree (*) (tree, void *),\n+\t\t      tree (*) (tree, void *), void *);\n+static tree lookup_field_queue_p (tree, void *);\n+static int shared_member_p (tree);\n+static tree lookup_field_r (tree, void *);\n+static tree canonical_binfo (tree);\n+static tree shared_marked_p (tree, void *);\n+static tree shared_unmarked_p (tree, void *);\n+static int  dependent_base_p (tree);\n+static tree dfs_accessible_queue_p (tree, void *);\n+static tree dfs_accessible_p (tree, void *);\n+static tree dfs_access_in_type (tree, void *);\n+static access_kind access_in_type (tree, tree);\n+static tree dfs_canonical_queue (tree, void *);\n+static tree dfs_assert_unmarked_p (tree, void *);\n+static void assert_canonical_unmarked (tree);\n+static int protected_accessible_p (tree, tree, tree);\n+static int friend_accessible_p (tree, tree, tree);\n+static void setup_class_bindings (tree, int);\n+static int template_self_reference_p (tree, tree);\n+static tree dfs_find_vbase_instance (tree, void *);\n+static tree dfs_get_pure_virtuals (tree, void *);\n+static tree dfs_build_inheritance_graph_order (tree, void *);\n \n /* Allocate a level of searching.  */\n \n static struct search_level *\n-push_search_level (stack, obstack)\n-     struct stack_level *stack;\n-     struct obstack *obstack;\n+push_search_level (struct stack_level *stack, struct obstack *obstack)\n {\n   struct search_level tem;\n \n@@ -144,8 +140,7 @@ push_search_level (stack, obstack)\n /* Discard a level of search allocation.  */\n \n static struct search_level *\n-pop_search_level (obstack)\n-     struct stack_level *obstack;\n+pop_search_level (struct stack_level *obstack)\n {\n   register struct search_level *stack = pop_stack_level (obstack);\n \n@@ -180,14 +175,11 @@ static int n_contexts_saved;\n    Otherwise BINFO's bases are searched.  */\n \n static base_kind\n-lookup_base_r (binfo, base, access, within_current_scope,\n-\t       is_non_public, is_virtual, binfo_ptr)\n-     tree binfo, base;\n-     base_access access;\n-     int within_current_scope;\n-     int is_non_public;\t\t/* inside a non-public part */\n-     int is_virtual;\t\t/* inside a virtual part */\n-     tree *binfo_ptr;\n+lookup_base_r (tree binfo, tree base, base_access access,\n+\t       bool within_current_scope,\n+\t       bool is_non_public,\t\t/* inside a non-public part */\n+\t       bool is_virtual,\t\t\t/* inside a virtual part */\n+\t       tree *binfo_ptr)\n {\n   int i;\n   tree bases;\n@@ -307,10 +299,7 @@ lookup_base_r (binfo, base, access, within_current_scope,\n    NULL_TREE is returned.  */\n \n tree\n-lookup_base (t, base, access, kind_ptr)\n-     tree t, base;\n-     base_access access;\n-     base_kind *kind_ptr;\n+lookup_base (tree t, tree base, base_access access, base_kind *kind_ptr)\n {\n   tree binfo = NULL;\t\t/* The binfo we've found so far.  */\n   tree t_binfo = NULL;\n@@ -372,19 +361,16 @@ lookup_base (t, base, access, kind_ptr)\n /* Worker function for get_dynamic_cast_base_type.  */\n \n static int\n-dynamic_cast_base_recurse (subtype, binfo, via_virtual, offset_ptr)\n-     tree subtype;\n-     tree binfo;\n-     int via_virtual;\n-     tree *offset_ptr;\n+dynamic_cast_base_recurse (tree subtype, tree binfo, bool is_via_virtual,\n+\t\t\t   tree *offset_ptr)\n {\n   tree binfos;\n   int i, n_baselinks;\n   int worst = -2;\n   \n   if (BINFO_TYPE (binfo) == subtype)\n     {\n-      if (via_virtual)\n+      if (is_via_virtual)\n         return -1;\n       else\n         {\n@@ -404,7 +390,7 @@ dynamic_cast_base_recurse (subtype, binfo, via_virtual, offset_ptr)\n         continue;\n       rval = dynamic_cast_base_recurse\n              (subtype, base_binfo,\n-              via_virtual || TREE_VIA_VIRTUAL (base_binfo), offset_ptr);\n+              is_via_virtual || TREE_VIA_VIRTUAL (base_binfo), offset_ptr);\n       if (worst == -2)\n         worst = rval;\n       else if (rval >= 0)\n@@ -429,13 +415,11 @@ dynamic_cast_base_recurse (subtype, binfo, via_virtual, offset_ptr)\n    BOFF == -3, SUBTYPE occurs as multiple public non-virtual bases.  */\n \n tree\n-get_dynamic_cast_base_type (subtype, target)\n-     tree subtype;\n-     tree target;\n+get_dynamic_cast_base_type (tree subtype, tree target)\n {\n   tree offset = NULL_TREE;\n   int boff = dynamic_cast_base_recurse (subtype, TYPE_BINFO (target),\n-                                        0, &offset);\n+                                        false, &offset);\n   \n   if (!boff)\n     return offset;\n@@ -454,8 +438,7 @@ get_dynamic_cast_base_type (subtype, target)\n    level, this is reasonable.)  */\n \n static tree\n-lookup_field_1 (type, name)\n-     tree type, name;\n+lookup_field_1 (tree type, tree name)\n {\n   register tree field;\n \n@@ -601,8 +584,7 @@ at_class_scope_p ()\n /* Return the scope of DECL, as appropriate when doing name-lookup.  */\n \n tree\n-context_for_name_lookup (decl)\n-     tree decl;\n+context_for_name_lookup (tree decl)\n {\n   /* [class.union]\n      \n@@ -624,8 +606,7 @@ context_for_name_lookup (decl)\n    otherwise.  */\n \n static tree\n-canonical_binfo (binfo)\n-     tree binfo;\n+canonical_binfo (tree binfo)\n {\n   return (TREE_VIA_VIRTUAL (binfo)\n \t  ? TYPE_BINFO (BINFO_TYPE (binfo)) : binfo);\n@@ -635,19 +616,15 @@ canonical_binfo (binfo)\n    canonical versions of virtual bases.  */\n \n static tree\n-dfs_canonical_queue (binfo, data)\n-     tree binfo;\n-     void *data ATTRIBUTE_UNUSED;\n+dfs_canonical_queue (tree binfo, void *data ATTRIBUTE_UNUSED)\n {\n   return canonical_binfo (binfo);\n }\n \n /* Called via dfs_walk from assert_canonical_unmarked.  */\n \n static tree\n-dfs_assert_unmarked_p (binfo, data)\n-     tree binfo;\n-     void *data ATTRIBUTE_UNUSED;\n+dfs_assert_unmarked_p (tree binfo, void *data ATTRIBUTE_UNUSED)\n {\n   my_friendly_assert (!BINFO_MARKED (binfo), 0);\n   return NULL_TREE;\n@@ -657,8 +634,7 @@ dfs_assert_unmarked_p (binfo, data)\n    versions of virtual bases) are unmarked.  */\n \n static void\n-assert_canonical_unmarked (binfo)\n-     tree binfo;\n+assert_canonical_unmarked (tree binfo)\n {\n   dfs_walk (binfo, dfs_assert_unmarked_p, dfs_canonical_queue, 0);\n }\n@@ -667,9 +643,7 @@ assert_canonical_unmarked (binfo)\n    Otherwise, return NULL_TREE.  */\n \n static tree\n-shared_marked_p (binfo, data)\n-     tree binfo;\n-     void *data;\n+shared_marked_p (tree binfo, void *data)\n {\n   binfo = canonical_binfo (binfo);\n   return markedp (binfo, data);\n@@ -679,9 +653,7 @@ shared_marked_p (binfo, data)\n    Otherwise, return NULL_TREE.  */\n \n static tree\n-shared_unmarked_p (binfo, data)\n-     tree binfo;\n-     void *data;\n+shared_unmarked_p (tree binfo, void *data)\n {\n   binfo = canonical_binfo (binfo);\n   return unmarkedp (binfo, data);\n@@ -703,9 +675,7 @@ shared_unmarked_p (binfo, data)\n    DATA (which is really a DECL) in BINFO.  */\n \n static tree\n-dfs_access_in_type (binfo, data)\n-     tree binfo;\n-     void *data;\n+dfs_access_in_type (tree binfo, void *data)\n {\n   tree decl = (tree) data;\n   tree type = BINFO_TYPE (binfo);\n@@ -798,9 +768,7 @@ dfs_access_in_type (binfo, data)\n /* Return the access to DECL in TYPE.  */\n \n static access_kind\n-access_in_type (type, decl)\n-     tree type;\n-     tree decl;\n+access_in_type (tree type, tree decl)\n {\n   tree binfo = TYPE_BINFO (type);\n \n@@ -825,9 +793,7 @@ access_in_type (type, decl)\n /* Called from dfs_accessible_p via dfs_walk.  */\n \n static tree\n-dfs_accessible_queue_p (binfo, data)\n-     tree binfo;\n-     void *data ATTRIBUTE_UNUSED;\n+dfs_accessible_queue_p (tree binfo, void *data ATTRIBUTE_UNUSED)\n {\n   if (BINFO_MARKED (binfo))\n     return NULL_TREE;\n@@ -845,9 +811,7 @@ dfs_accessible_queue_p (binfo, data)\n /* Called from dfs_accessible_p via dfs_walk.  */\n \n static tree\n-dfs_accessible_p (binfo, data)\n-     tree binfo;\n-     void *data;\n+dfs_accessible_p (tree binfo, void *data)\n {\n   int protected_ok = data != 0;\n   access_kind access;\n@@ -867,10 +831,7 @@ dfs_accessible_p (binfo, data)\n    indiated by BINFO in the context of DERIVED.  */\n \n static int\n-protected_accessible_p (decl, derived, binfo)\n-     tree decl;\n-     tree derived;\n-     tree binfo;\n+protected_accessible_p (tree decl, tree derived, tree binfo)\n {\n   access_kind access;\n \n@@ -930,10 +891,7 @@ protected_accessible_p (decl, derived, binfo)\n    to access DECL through the object indicated by BINFO.  */\n \n static int\n-friend_accessible_p (scope, decl, binfo)\n-     tree scope;\n-     tree decl;\n-     tree binfo;\n+friend_accessible_p (tree scope, tree decl, tree binfo)\n {\n   tree befriending_classes;\n   tree t;\n@@ -986,10 +944,7 @@ friend_accessible_p (scope, decl, binfo)\n    at the most derived class along the path indicated by BINFO.  */\n \n int \n-accessible_p (type, decl)\n-     tree type;\n-     tree decl;\n-     \n+accessible_p (tree type, tree decl)\n {\n   tree binfo;\n   tree t;\n@@ -1069,8 +1024,7 @@ accessible_p (type, decl)\n    for documentation of the parameters.  */\n \n static int\n-is_subobject_of_p_1 (parent, binfo, most_derived)\n-     tree parent, binfo, most_derived;\n+is_subobject_of_p_1 (tree parent, tree binfo, tree most_derived)\n {\n   tree binfos;\n   int i, n_baselinks;\n@@ -1155,9 +1109,7 @@ struct lookup_field_info {\n    lookup_field via breadth_first_search.  */\n \n static tree\n-lookup_field_queue_p (binfo, data)\n-     tree binfo;\n-     void *data;\n+lookup_field_queue_p (tree binfo, void *data)\n {\n   struct lookup_field_info *lfi = (struct lookup_field_info *) data;\n \n@@ -1184,9 +1136,7 @@ lookup_field_queue_p (binfo, data)\n    Returns nonzero if DECL is such a declaration in a class TYPE.  */\n \n static int\n-template_self_reference_p (type, decl)\n-     tree type;\n-     tree decl;\n+template_self_reference_p (tree type, tree decl)\n {\n   return  (CLASSTYPE_USE_TEMPLATE (type)\n \t   && PRIMARY_TEMPLATE_P (CLASSTYPE_TI_TEMPLATE (type))\n@@ -1207,8 +1157,7 @@ template_self_reference_p (type, decl)\n    This function checks that T contains no nonstatic members.  */\n \n static int\n-shared_member_p (t)\n-     tree t;\n+shared_member_p (tree t)\n {\n   if (TREE_CODE (t) == VAR_DECL || TREE_CODE (t) == TYPE_DECL \\\n       || TREE_CODE (t) == CONST_DECL)\n@@ -1232,9 +1181,7 @@ shared_member_p (t)\n    lookup_field via breadth_first_search.  */\n \n static tree\n-lookup_field_r (binfo, data)\n-     tree binfo;\n-     void *data;\n+lookup_field_r (tree binfo, void *data)\n {\n   struct lookup_field_info *lfi = (struct lookup_field_info *) data;\n   tree type = BINFO_TYPE (binfo);\n@@ -1408,9 +1355,7 @@ build_baselink (tree binfo, tree access_binfo, tree functions, tree optype)\n    If nothing can be found return NULL_TREE and do not issue an error.  */\n \n tree\n-lookup_member (xbasetype, name, protect, want_type)\n-     register tree xbasetype, name;\n-     int protect, want_type;\n+lookup_member (tree xbasetype, tree name, int protect, bool want_type)\n {\n   tree rval, rval_binfo = NULL_TREE;\n   tree type = NULL_TREE, basetype_path = NULL_TREE;\n@@ -1513,9 +1458,7 @@ lookup_member (xbasetype, name, protect, want_type)\n    return NULL_TREE.  */\n \n tree\n-lookup_field (xbasetype, name, protect, want_type)\n-     register tree xbasetype, name;\n-     int protect, want_type;\n+lookup_field (tree xbasetype, tree name, int protect, bool want_type)\n {\n   tree rval = lookup_member (xbasetype, name, protect, want_type);\n   \n@@ -1530,11 +1473,9 @@ lookup_field (xbasetype, name, protect, want_type)\n    return NULL_TREE.  */\n \n tree\n-lookup_fnfields (xbasetype, name, protect)\n-     register tree xbasetype, name;\n-     int protect;\n+lookup_fnfields (tree xbasetype, tree name, int protect)\n {\n-  tree rval = lookup_member (xbasetype, name, protect, /*want_type=*/0);\n+  tree rval = lookup_member (xbasetype, name, protect, /*want_type=*/false);\n \n   /* Ignore non-functions.  */\n   if (rval && !BASELINK_P (rval))\n@@ -1547,8 +1488,7 @@ lookup_fnfields (xbasetype, name, protect)\n    the method vector with name NAME, or -1 is no such field exists.  */\n \n int\n-lookup_fnfields_1 (type, name)\n-     tree type, name;\n+lookup_fnfields_1 (tree type, tree name)\n {\n   tree method_vec = (CLASS_TYPE_P (type)\n \t\t     ? CLASSTYPE_METHOD_VEC (type)\n@@ -1692,11 +1632,8 @@ adjust_result_of_qualified_name_lookup (tree decl,\n    called.  */\n \n static tree\n-bfs_walk (binfo, fn, qfn, data)\n-     tree binfo;\n-     tree (*fn) PARAMS ((tree, void *));\n-     tree (*qfn) PARAMS ((tree, void *));\n-     void *data;\n+bfs_walk (tree binfo, tree (*fn) (tree, void *),\n+\t  tree (*qfn) (tree, void *), void *data)\n {\n   size_t head;\n   size_t tail;\n@@ -1755,12 +1692,9 @@ bfs_walk (binfo, fn, qfn, data)\n    in postorder.  */\n \n tree\n-dfs_walk_real (binfo, prefn, postfn, qfn, data)\n-     tree binfo;\n-     tree (*prefn) PARAMS ((tree, void *));\n-     tree (*postfn) PARAMS ((tree, void *));\n-     tree (*qfn) PARAMS ((tree, void *));\n-     void *data;\n+dfs_walk_real (tree binfo, \n+\t       tree (*prefn) (tree, void *), tree (*postfn) (tree, void *),\n+\t       tree (*qfn) (tree, void *), void *data)\n {\n   int i;\n   int n_baselinks;\n@@ -1804,11 +1738,8 @@ dfs_walk_real (binfo, prefn, postfn, qfn, data)\n    performed.  */\n \n tree\n-dfs_walk (binfo, fn, qfn, data)\n-     tree binfo;\n-     tree (*fn) PARAMS ((tree, void *));\n-     tree (*qfn) PARAMS ((tree, void *));\n-     void *data;\n+dfs_walk (tree binfo, tree (*fn) (tree, void *),\n+\t  tree (*qfn) (tree, void *), void *data)\n {\n   return dfs_walk_real (binfo, 0, fn, qfn, data);\n }\n@@ -1817,8 +1748,7 @@ dfs_walk (binfo, fn, qfn, data)\n    BASEFN. Issue diagnostic, and return zero, if unacceptable.  */\n \n int\n-check_final_overrider (overrider, basefn)\n-     tree overrider, basefn;\n+check_final_overrider (tree overrider, tree basefn)\n {\n   tree over_type = TREE_TYPE (overrider);\n   tree base_type = TREE_TYPE (basefn);\n@@ -1926,8 +1856,7 @@ check_final_overrider (overrider, basefn)\n    overridden.  */\n \n int\n-look_for_overrides (type, fndecl)\n-     tree type, fndecl;\n+look_for_overrides (tree type, tree fndecl)\n {\n   tree binfo = TYPE_BINFO (type);\n   tree basebinfos = BINFO_BASETYPES (binfo);\n@@ -1949,8 +1878,7 @@ look_for_overrides (type, fndecl)\n    FNDECL.  */\n \n tree\n-look_for_overrides_here (type, fndecl)\n-     tree type, fndecl;\n+look_for_overrides_here (tree type, tree fndecl)\n {\n   int ix;\n \n@@ -1988,8 +1916,7 @@ look_for_overrides_here (type, fndecl)\n    TYPE itself and its bases.  */\n \n static int\n-look_for_overrides_r (type, fndecl)\n-     tree type, fndecl;\n+look_for_overrides_r (tree type, tree fndecl)\n {\n   tree fn = look_for_overrides_here (type, fndecl);\n   if (fn)\n@@ -2025,9 +1952,7 @@ look_for_overrides_r (type, fndecl)\n    once.  */\n \n tree\n-dfs_unmarked_real_bases_queue_p (binfo, data)\n-     tree binfo;\n-     void *data;\n+dfs_unmarked_real_bases_queue_p (tree binfo, void *data)\n {\n   if (TREE_VIA_VIRTUAL (binfo))\n     {\n@@ -2044,9 +1969,7 @@ dfs_unmarked_real_bases_queue_p (binfo, data)\n    that are marked, rather than unmarked.  */\n \n tree\n-dfs_marked_real_bases_queue_p (binfo, data)\n-     tree binfo;\n-     void *data;\n+dfs_marked_real_bases_queue_p (tree binfo, void *data)\n {\n   if (TREE_VIA_VIRTUAL (binfo))\n     {\n@@ -2063,9 +1986,7 @@ dfs_marked_real_bases_queue_p (binfo, data)\n    bases).  */\n \n tree\n-dfs_skip_vbases (binfo, data)\n-     tree binfo;\n-     void *data ATTRIBUTE_UNUSED;\n+dfs_skip_vbases (tree binfo, void *data ATTRIBUTE_UNUSED)\n {\n   if (TREE_VIA_VIRTUAL (binfo))\n     return NULL_TREE;\n@@ -2076,9 +1997,7 @@ dfs_skip_vbases (binfo, data)\n /* Called via dfs_walk from dfs_get_pure_virtuals.  */\n \n static tree\n-dfs_get_pure_virtuals (binfo, data)\n-     tree binfo;\n-     void *data;\n+dfs_get_pure_virtuals (tree binfo, void *data)\n {\n   tree type = (tree) data;\n \n@@ -2106,8 +2025,7 @@ dfs_get_pure_virtuals (binfo, data)\n /* Set CLASSTYPE_PURE_VIRTUALS for TYPE.  */\n \n void\n-get_pure_virtuals (type)\n-     tree type;\n+get_pure_virtuals (tree type)\n {\n   tree vbases;\n \n@@ -2148,51 +2066,39 @@ get_pure_virtuals (type)\n /* DEPTH-FIRST SEARCH ROUTINES.  */\n \n tree \n-markedp (binfo, data) \n-     tree binfo;\n-     void *data ATTRIBUTE_UNUSED;\n-{ \n+markedp (tree binfo, void *data ATTRIBUTE_UNUSED)\n+{\n   return BINFO_MARKED (binfo) ? binfo : NULL_TREE; \n }\n \n tree\n-unmarkedp (binfo, data) \n-     tree binfo;\n-     void *data ATTRIBUTE_UNUSED;\n+unmarkedp (tree binfo, void *data ATTRIBUTE_UNUSED)\n {\n   return !BINFO_MARKED (binfo) ? binfo : NULL_TREE;\n }\n \n tree\n-marked_vtable_pathp (binfo, data) \n-     tree binfo;\n-     void *data ATTRIBUTE_UNUSED;\n+marked_vtable_pathp (tree binfo, void *data ATTRIBUTE_UNUSED)\n { \n   return BINFO_VTABLE_PATH_MARKED (binfo) ? binfo : NULL_TREE; \n }\n \n tree\n-unmarked_vtable_pathp (binfo, data) \n-     tree binfo;\n-     void *data ATTRIBUTE_UNUSED;\n+unmarked_vtable_pathp (tree binfo, void *data ATTRIBUTE_UNUSED)\n { \n   return !BINFO_VTABLE_PATH_MARKED (binfo) ? binfo : NULL_TREE; \n }\n \n static tree\n-marked_pushdecls_p (binfo, data) \n-     tree binfo;\n-     void *data ATTRIBUTE_UNUSED;\n+marked_pushdecls_p (tree binfo, void *data ATTRIBUTE_UNUSED)\n {\n   return (CLASS_TYPE_P (BINFO_TYPE (binfo))\n \t  && !dependent_base_p (binfo)\n \t  && BINFO_PUSHDECLS_MARKED (binfo)) ? binfo : NULL_TREE; \n }\n \n static tree\n-unmarked_pushdecls_p (binfo, data) \n-     tree binfo;\n-     void *data ATTRIBUTE_UNUSED;\n+unmarked_pushdecls_p (tree binfo, void *data ATTRIBUTE_UNUSED)\n { \n   return (CLASS_TYPE_P (BINFO_TYPE (binfo))\n \t  && !dependent_base_p (binfo)\n@@ -2204,9 +2110,7 @@ unmarked_pushdecls_p (binfo, data)\n    a predicate function (above).  */\n \n tree\n-dfs_unmark (binfo, data) \n-     tree binfo;\n-     void *data ATTRIBUTE_UNUSED;\n+dfs_unmark (tree binfo, void *data ATTRIBUTE_UNUSED)\n { \n   CLEAR_BINFO_MARKED (binfo); \n   return NULL_TREE;\n@@ -2217,9 +2121,7 @@ dfs_unmark (binfo, data)\n    Ordering is very important, so don't change it.  */\n \n static tree\n-dfs_get_vbase_types (binfo, data)\n-     tree binfo;\n-     void *data;\n+dfs_get_vbase_types (tree binfo, void *data)\n {\n   tree type = (tree) data;\n \n@@ -2236,9 +2138,7 @@ dfs_get_vbase_types (binfo, data)\n    inheritance graph order list of BINFOs.  */\n \n static tree\n-dfs_build_inheritance_graph_order (binfo, data)\n-     tree binfo;\n-     void *data;\n+dfs_build_inheritance_graph_order (tree binfo, void *data)\n {\n   tree *last_binfo = (tree *) data;\n \n@@ -2252,8 +2152,7 @@ dfs_build_inheritance_graph_order (binfo, data)\n /* Set CLASSTYPE_VBASECLASSES for TYPE.  */\n \n void\n-get_vbase_types (type)\n-     tree type;\n+get_vbase_types (tree type)\n {\n   tree last_binfo;\n \n@@ -2276,9 +2175,7 @@ get_vbase_types (type)\n /* Called from find_vbase_instance via dfs_walk.  */\n \n static tree\n-dfs_find_vbase_instance (binfo, data)\n-     tree binfo;\n-     void *data;\n+dfs_find_vbase_instance (tree binfo, void *data)\n {\n   tree base = TREE_VALUE ((tree) data);\n \n@@ -2293,9 +2190,7 @@ dfs_find_vbase_instance (binfo, data)\n    hierarchy dominated by TYPE.  */\n \n tree\n-find_vbase_instance (base, type)\n-     tree base;\n-     tree type;\n+find_vbase_instance (tree base, tree type)\n {\n   tree instance;\n \n@@ -2318,8 +2213,7 @@ find_vbase_instance (base, type)\n    linker.  */\n \n void\n-maybe_suppress_debug_info (t)\n-     tree t;\n+maybe_suppress_debug_info (tree t)\n {\n   /* We can't do the usual TYPE_DECL_SUPPRESS_DEBUG thing with DWARF, which\n      does not support name references between translation units.  It supports\n@@ -2361,9 +2255,7 @@ maybe_suppress_debug_info (t)\n    information anyway.  */\n \n static tree\n-dfs_debug_mark (binfo, data)\n-     tree binfo;\n-     void *data ATTRIBUTE_UNUSED;\n+dfs_debug_mark (tree binfo, void *data ATTRIBUTE_UNUSED)\n {\n   tree t = BINFO_TYPE (binfo);\n \n@@ -2376,9 +2268,7 @@ dfs_debug_mark (binfo, data)\n    info for this base class.  */\n \n static tree \n-dfs_debug_unmarkedp (binfo, data) \n-     tree binfo;\n-     void *data ATTRIBUTE_UNUSED;\n+dfs_debug_unmarkedp (tree binfo, void *data ATTRIBUTE_UNUSED)\n { \n   return (!CLASSTYPE_DEBUG_REQUESTED (BINFO_TYPE (binfo)) \n \t  ? binfo : NULL_TREE);\n@@ -2392,8 +2282,7 @@ dfs_debug_unmarkedp (binfo, data)\n    the vtables themselves, were optimized away.  */\n \n void\n-note_debug_info_needed (type)\n-     tree type;\n+note_debug_info_needed (tree type)\n {\n   if (TYPE_DECL_SUPPRESS_DEBUG (TYPE_NAME (type)))\n     {\n@@ -2410,8 +2299,7 @@ note_debug_info_needed (type)\n    because it (or one of the intermediate bases) depends on template parms.  */\n \n static int\n-dependent_base_p (binfo)\n-     tree binfo;\n+dependent_base_p (tree binfo)\n {\n   for (; binfo; binfo = BINFO_INHERITANCE_CHAIN (binfo))\n     {\n@@ -2424,9 +2312,7 @@ dependent_base_p (binfo)\n }\n \n static void\n-setup_class_bindings (name, type_binding_p)\n-     tree name;\n-     int type_binding_p;\n+setup_class_bindings (tree name, int type_binding_p)\n {\n   tree type_binding = NULL_TREE;\n   tree value_binding;\n@@ -2440,8 +2326,7 @@ setup_class_bindings (name, type_binding_p)\n   if (type_binding_p)\n     {\n       type_binding = lookup_member (current_class_type, name,\n-\t\t\t\t    /*protect=*/2,\n-\t\t\t\t    /*want_type=*/1);\n+\t\t\t\t    /*protect=*/2, /*want_type=*/true);\n       if (TREE_CODE (type_binding) == TREE_LIST \n \t  && TREE_TYPE (type_binding) == error_mark_node)\n \t/* NAME is ambiguous.  */\n@@ -2452,8 +2337,7 @@ setup_class_bindings (name, type_binding_p)\n \n   /* Now, do the value binding.  */\n   value_binding = lookup_member (current_class_type, name,\n-\t\t\t\t /*protect=*/2,\n-\t\t\t\t /*want_type=*/0);\n+\t\t\t\t /*protect=*/2, /*want_type=*/false);\n \n   if (type_binding_p\n       && (TREE_CODE (value_binding) == TYPE_DECL\n@@ -2485,9 +2369,7 @@ setup_class_bindings (name, type_binding_p)\n    are TYPE_DECLS.  */\n \n static tree\n-dfs_push_type_decls (binfo, data)\n-     tree binfo;\n-     void *data ATTRIBUTE_UNUSED;\n+dfs_push_type_decls (tree binfo, void *data ATTRIBUTE_UNUSED)\n {\n   tree type;\n   tree fields;\n@@ -2510,9 +2392,7 @@ dfs_push_type_decls (binfo, data)\n    are not TYPE_DECLS.  */\n \n static tree\n-dfs_push_decls (binfo, data)\n-     tree binfo;\n-     void *data;\n+dfs_push_decls (tree binfo, void *data)\n {\n   tree type;\n   tree method_vec;\n@@ -2566,8 +2446,7 @@ dfs_push_decls (binfo, data)\n    message.  */\n \n void\n-push_class_decls (type)\n-     tree type;\n+push_class_decls (tree type)\n {\n   search_stack = push_search_level (search_stack, &search_obstack);\n \n@@ -2581,9 +2460,7 @@ push_class_decls (type)\n /* Here's a subroutine we need because C lacks lambdas.  */\n \n static tree\n-dfs_unuse_fields (binfo, data)\n-     tree binfo;\n-     void *data ATTRIBUTE_UNUSED;\n+dfs_unuse_fields (tree binfo, void *data ATTRIBUTE_UNUSED)\n {\n   tree type = TREE_TYPE (binfo);\n   tree fields;\n@@ -2603,8 +2480,7 @@ dfs_unuse_fields (binfo, data)\n }\n \n void\n-unuse_fields (type)\n-     tree type;\n+unuse_fields (tree type)\n {\n   dfs_walk (TYPE_BINFO (type), dfs_unuse_fields, unmarkedp, 0);\n }\n@@ -2652,9 +2528,7 @@ reinit_search_statistics ()\n }\n \n static tree\n-add_conversions (binfo, data)\n-     tree binfo;\n-     void *data;\n+add_conversions (tree binfo, void *data)\n {\n   int i;\n   tree method_vec = CLASSTYPE_METHOD_VEC (BINFO_TYPE (binfo));\n@@ -2691,8 +2565,7 @@ add_conversions (binfo, data)\n    from which the conversion functions in this node were selected.  */\n \n tree\n-lookup_conversions (type)\n-     tree type;\n+lookup_conversions (tree type)\n {\n   tree t;\n   tree conversions = NULL_TREE;\n@@ -2716,9 +2589,7 @@ struct overlap_info\n    at offset 0 in COMPARE_TYPE, and set found_overlap if so.  */\n \n static tree\n-dfs_check_overlap (empty_binfo, data)\n-     tree empty_binfo;\n-     void *data;\n+dfs_check_overlap (tree empty_binfo, void *data)\n {\n   struct overlap_info *oi = (struct overlap_info *) data;\n   tree binfo;\n@@ -2741,9 +2612,7 @@ dfs_check_overlap (empty_binfo, data)\n /* Trivial function to stop base traversal when we find something.  */\n \n static tree\n-dfs_no_overlap_yet (binfo, data)\n-     tree binfo;\n-     void *data;\n+dfs_no_overlap_yet (tree binfo, void *data)\n {\n   struct overlap_info *oi = (struct overlap_info *) data;\n   return !oi->found_overlap ? binfo : NULL_TREE;\n@@ -2753,8 +2622,7 @@ dfs_no_overlap_yet (binfo, data)\n    offset 0 in NEXT_TYPE.  Used in laying out empty base class subobjects.  */\n \n int\n-types_overlap_p (empty_type, next_type)\n-     tree empty_type, next_type;\n+types_overlap_p (tree empty_type, tree next_type)\n {\n   struct overlap_info oi;\n \n@@ -2773,8 +2641,7 @@ types_overlap_p (empty_type, next_type)\n    FIXME: This does not work with the new ABI.  */\n \n tree\n-binfo_for_vtable (var)\n-     tree var;\n+binfo_for_vtable (tree var)\n {\n   tree main_binfo = TYPE_BINFO (DECL_CONTEXT (var));\n   tree binfos = TYPE_BINFO_BASETYPES (BINFO_TYPE (main_binfo));\n@@ -2800,8 +2667,7 @@ binfo_for_vtable (var)\n    from BINFO, or NULL if binfo is not via virtual.  */\n \n tree\n-binfo_from_vbase (binfo)\n-     tree binfo;\n+binfo_from_vbase (tree binfo)\n {\n   for (; binfo; binfo = BINFO_INHERITANCE_CHAIN (binfo))\n     {\n@@ -2816,9 +2682,7 @@ binfo_from_vbase (binfo)\n    via virtual.  */\n \n tree\n-binfo_via_virtual (binfo, limit)\n-     tree binfo;\n-     tree limit;\n+binfo_via_virtual (tree binfo, tree limit)\n {\n   for (; binfo && (!limit || !same_type_p (BINFO_TYPE (binfo), limit));\n        binfo = BINFO_INHERITANCE_CHAIN (binfo))\n@@ -2833,9 +2697,7 @@ binfo_via_virtual (binfo, limit)\n    C from the CLASSTYPE_VBASECLASSES list.  */\n \n tree\n-binfo_for_vbase (basetype, classtype)\n-     tree basetype;\n-     tree classtype;\n+binfo_for_vbase (tree basetype, tree classtype)\n {\n   tree binfo;\n "}, {"sha": "7c6cb57e9a9fae72389556e54ce6d9b84dcb2557", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86ac05753c9d7fcf27375fe17e70cda5333ab50e/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86ac05753c9d7fcf27375fe17e70cda5333ab50e/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=86ac05753c9d7fcf27375fe17e70cda5333ab50e", "patch": "@@ -1,6 +1,6 @@\n /* Build expressions with type checking for C++ compiler.\n    Copyright (C) 1987, 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n-   1999, 2000, 2001, 2002 Free Software Foundation, Inc.\n+   1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.\n    Hacked by Michael Tiemann (tiemann@cygnus.com)\n \n This file is part of GCC.\n@@ -2101,7 +2101,7 @@ lookup_destructor (tree object, tree scope, tree dtor_name)\n     return build (PSEUDO_DTOR_EXPR, void_type_node, object, scope,\n \t\t  dtor_type);\n   return lookup_member (object_type, complete_dtor_identifier,\n-\t\t\t/*protect=*/1, /*want_type=*/0);\n+\t\t\t/*protect=*/1, /*want_type=*/false);\n }\n \n /* This function is called by the parser to process a class member\n@@ -2205,7 +2205,7 @@ finish_class_member_access_expr (tree object, tree name)\n \t    {\n \t      /* Look up the member.  */\n \t      member = lookup_member (access_path, name, /*protect=*/1, \n-\t\t\t\t      /*want_type=*/0);\n+\t\t\t\t      /*want_type=*/false);\n \t      if (member == NULL_TREE)\n \t\t{\n \t\t  error (\"'%D' has no member named '%E'\", object_type, name);\n@@ -2221,7 +2221,7 @@ finish_class_member_access_expr (tree object, tree name)\n \t{\n \t  /* An unqualified name.  */\n \t  member = lookup_member (object_type, name, /*protect=*/1, \n-\t\t\t\t  /*want_type=*/0);\n+\t\t\t\t  /*want_type=*/false);\n \t  if (member == NULL_TREE)\n \t    {\n \t      error (\"'%D' has no member named '%E'\", object_type, name);\n@@ -2285,7 +2285,7 @@ build_ptrmemfunc_access_expr (tree ptrmem, tree member_name)\n   ptrmem_type = TREE_TYPE (ptrmem);\n   my_friendly_assert (TYPE_PTRMEMFUNC_P (ptrmem_type), 20020804);\n   member = lookup_member (ptrmem_type, member_name, /*protect=*/0,\n-\t\t\t  /*want_type=*/0);\n+\t\t\t  /*want_type=*/false);\n   member_type = cp_build_qualified_type (TREE_TYPE (member),\n \t\t\t\t\t cp_type_quals (ptrmem_type));\n   return fold (build (COMPONENT_REF, member_type, ptrmem, member));"}]}