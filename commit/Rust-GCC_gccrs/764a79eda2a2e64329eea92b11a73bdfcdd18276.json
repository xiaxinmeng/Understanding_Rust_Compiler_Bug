{"sha": "764a79eda2a2e64329eea92b11a73bdfcdd18276", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzY0YTc5ZWRhMmEyZTY0MzI5ZWVhOTJiMTFhNzNiZGZjZGQxODI3Ng==", "commit": {"author": {"name": "Rafael Avila de Espindola", "email": "espindola@google.com", "date": "2008-04-01T09:11:11Z"}, "committer": {"name": "Rafael Espindola", "email": "espindola@gcc.gnu.org", "date": "2008-04-01T09:11:11Z"}, "message": "tree-vrp.c (extract_code_and_val_from_cond_with_ops): New.\n\n2008-04-01  Rafael Espindola  <espindola@google.com>\n\n\t* tree-vrp.c (extract_code_and_val_from_cond_with_ops): New.\n\t(extract_code_and_val_from_cond): Use\n\textract_code_and_val_from_cond_with_ops.\n\nFrom-SVN: r133789", "tree": {"sha": "95d601b262764fbd4e2ba253cab0e01d219b198b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/95d601b262764fbd4e2ba253cab0e01d219b198b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/764a79eda2a2e64329eea92b11a73bdfcdd18276", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/764a79eda2a2e64329eea92b11a73bdfcdd18276", "html_url": "https://github.com/Rust-GCC/gccrs/commit/764a79eda2a2e64329eea92b11a73bdfcdd18276", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/764a79eda2a2e64329eea92b11a73bdfcdd18276/comments", "author": null, "committer": null, "parents": [{"sha": "113c63b8e38e53eab839df80ed2794b5e8da7bea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/113c63b8e38e53eab839df80ed2794b5e8da7bea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/113c63b8e38e53eab839df80ed2794b5e8da7bea"}], "stats": {"total": 126, "additions": 75, "deletions": 51}, "files": [{"sha": "f5ccc97d06300a1bbf834d17aeeea0b473a63602", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/764a79eda2a2e64329eea92b11a73bdfcdd18276/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/764a79eda2a2e64329eea92b11a73bdfcdd18276/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=764a79eda2a2e64329eea92b11a73bdfcdd18276", "patch": "@@ -1,3 +1,9 @@\n+2008-04-01  Rafael Espindola  <espindola@google.com>\n+\n+\t* tree-vrp.c (extract_code_and_val_from_cond_with_ops): New.\n+\t(extract_code_and_val_from_cond): Use\n+\textract_code_and_val_from_cond_with_ops.\n+\n 2008-04-01  Jan Hubicka  <jh@suse.cz>\n \n \t* function.c (free_after_compilation): Free epilogue_delay_list."}, {"sha": "8c4fa1fde6b3bafeb892d116cd63682e78a3435f", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 69, "deletions": 51, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/764a79eda2a2e64329eea92b11a73bdfcdd18276/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/764a79eda2a2e64329eea92b11a73bdfcdd18276/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=764a79eda2a2e64329eea92b11a73bdfcdd18276", "patch": "@@ -3623,6 +3623,67 @@ register_new_assert_for (tree name, tree expr,\n   bitmap_set_bit (need_assert_for, SSA_NAME_VERSION (name));\n }\n \n+/* Helper function for extract_code_and_val_from_cond */\n+\n+static bool\n+extract_code_and_val_from_cond_with_ops (tree name, enum tree_code cond_code,\n+\t\t\t\t\t tree cond_op0, tree cond_op1,\n+\t\t\t\t\t bool invert, enum tree_code *code_p,\n+\t\t\t\t\t tree *val_p)\n+{\n+  enum tree_code comp_code;\n+  tree val;\n+\n+  /* Otherwise, we have a comparison of the form NAME COMP VAL\n+     or VAL COMP NAME.  */\n+  if (name == cond_op1)\n+    {\n+      /* If the predicate is of the form VAL COMP NAME, flip\n+\t COMP around because we need to register NAME as the\n+\t first operand in the predicate.  */\n+      comp_code = swap_tree_comparison (cond_code);\n+      val = cond_op0;\n+    }\n+  else\n+    {\n+      /* The comparison is of the form NAME COMP VAL, so the\n+\t comparison code remains unchanged.  */\n+      comp_code = cond_code;\n+      val = cond_op1;\n+    }\n+\n+  /* Invert the comparison code as necessary.  */\n+  if (invert)\n+    comp_code = invert_tree_comparison (comp_code, 0);\n+\n+  /* VRP does not handle float types.  */\n+  if (SCALAR_FLOAT_TYPE_P (TREE_TYPE (val)))\n+    return false;\n+\n+  /* Do not register always-false predicates.\n+     FIXME:  this works around a limitation in fold() when dealing with\n+     enumerations.  Given 'enum { N1, N2 } x;', fold will not\n+     fold 'if (x > N2)' to 'if (0)'.  */\n+  if ((comp_code == GT_EXPR || comp_code == LT_EXPR)\n+      && INTEGRAL_TYPE_P (TREE_TYPE (val)))\n+    {\n+      tree min = TYPE_MIN_VALUE (TREE_TYPE (val));\n+      tree max = TYPE_MAX_VALUE (TREE_TYPE (val));\n+\n+      if (comp_code == GT_EXPR\n+\t  && (!max\n+\t      || compare_values (val, max) == 0))\n+\treturn false;\n+\n+      if (comp_code == LT_EXPR\n+\t  && (!min\n+\t      || compare_values (val, min) == 0))\n+\treturn false;\n+    }\n+  *code_p = comp_code;\n+  *val_p = val;\n+  return true;\n+}\n /* COND is a predicate which uses NAME.  Extract a suitable test code\n    and value and store them into *CODE_P and *VAL_P so the predicate\n    is normalized to NAME *CODE_P *VAL_P.\n@@ -3646,59 +3707,16 @@ extract_code_and_val_from_cond (tree name, tree cond, bool invert,\n \t NAME == false accordingly.  */\n       comp_code = EQ_EXPR;\n       val = invert ? boolean_false_node : boolean_true_node;\n+      *code_p = comp_code;\n+      *val_p = val;\n+      return true;\n     }\n   else\n-    {\n-      /* Otherwise, we have a comparison of the form NAME COMP VAL\n-         or VAL COMP NAME.  */\n-      if (name == TREE_OPERAND (cond, 1))\n-        {\n-\t  /* If the predicate is of the form VAL COMP NAME, flip\n-\t     COMP around because we need to register NAME as the\n-\t     first operand in the predicate.  */\n-\t  comp_code = swap_tree_comparison (TREE_CODE (cond));\n-\t  val = TREE_OPERAND (cond, 0);\n-\t}\n-      else\n-\t{\n-\t  /* The comparison is of the form NAME COMP VAL, so the\n-\t     comparison code remains unchanged.  */\n-\t  comp_code = TREE_CODE (cond);\n-\t  val = TREE_OPERAND (cond, 1);\n-\t}\n-\n-      /* Invert the comparison code as necessary.  */\n-      if (invert)\n-\tcomp_code = invert_tree_comparison (comp_code, 0);\n-\n-      /* VRP does not handle float types.  */\n-      if (SCALAR_FLOAT_TYPE_P (TREE_TYPE (val)))\n-\treturn false;\n-\n-      /* Do not register always-false predicates.\n-\t FIXME:  this works around a limitation in fold() when dealing with\n-\t enumerations.  Given 'enum { N1, N2 } x;', fold will not\n-\t fold 'if (x > N2)' to 'if (0)'.  */\n-      if ((comp_code == GT_EXPR || comp_code == LT_EXPR)\n-\t  && INTEGRAL_TYPE_P (TREE_TYPE (val)))\n-\t{\n-\t  tree min = TYPE_MIN_VALUE (TREE_TYPE (val));\n-\t  tree max = TYPE_MAX_VALUE (TREE_TYPE (val));\n-\n-\t  if (comp_code == GT_EXPR\n-\t      && (!max\n-\t          || compare_values (val, max) == 0))\n-\t    return false;\n-\n-\t  if (comp_code == LT_EXPR\n-\t      && (!min\n-\t          || compare_values (val, min) == 0))\n-\t    return false;\n-\t}\n-    }\n-  *code_p = comp_code;\n-  *val_p = val;\n-  return true;\n+    return extract_code_and_val_from_cond_with_ops (name, TREE_CODE (cond),\n+\t\t\t\t\t\t    TREE_OPERAND (cond, 0),\n+\t\t\t\t\t\t    TREE_OPERAND (cond, 1),\n+\t\t\t\t\t\t    invert,\n+\t\t\t\t\t\t    code_p, val_p);\n }\n \n /* Try to register an edge assertion for SSA name NAME on edge E for"}]}