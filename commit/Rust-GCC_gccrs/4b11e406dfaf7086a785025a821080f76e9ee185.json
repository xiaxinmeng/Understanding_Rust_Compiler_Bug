{"sha": "4b11e406dfaf7086a785025a821080f76e9ee185", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGIxMWU0MDZkZmFmNzA4NmE3ODUwMjVhODIxMDgwZjc2ZTllZTE4NQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "rdsandiford@googlemail.com", "date": "2012-08-26T19:31:15Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2012-08-26T19:31:15Z"}, "message": "mips.h (AVOID_CCMODE_COPIES): Update rationale for definition.\n\ngcc/\n\t* config/mips/mips.h (AVOID_CCMODE_COPIES): Update rationale for\n\tdefinition.\n\t* config/mips/mips.c (machine_function): Add next_fcc.\n\t(mips_output_move): Remove handling of fcc moves.\n\t(mips_allocate_fcc): New function.\n\t(mips_emit_compare, mips_expand_vcondv2sf): Use it.\n\t(mips_hard_regno_mode_ok_p): Restrict CCmode to ST registers.\n\tRemove special case for CCmode reloads.\n\t(mips_expand_builtin_compare_1): Use mips_allocate_fcc and treat\n\tthe result a fixed operand.\n\t* config/mips/mips.md (move_type): Remove lui_movf.\n\t(type, length): Remove references to it.\n\t(movcc, reload_incc, reload_outcc): Delete.\n\nFrom-SVN: r190703", "tree": {"sha": "8dc01bb166b7d6fc97b22df20c170f7ac24bde66", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8dc01bb166b7d6fc97b22df20c170f7ac24bde66"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4b11e406dfaf7086a785025a821080f76e9ee185", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b11e406dfaf7086a785025a821080f76e9ee185", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4b11e406dfaf7086a785025a821080f76e9ee185", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b11e406dfaf7086a785025a821080f76e9ee185/comments", "author": {"login": "rsandifo", "id": 4235983, "node_id": "MDQ6VXNlcjQyMzU5ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/4235983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo", "html_url": "https://github.com/rsandifo", "followers_url": "https://api.github.com/users/rsandifo/followers", "following_url": "https://api.github.com/users/rsandifo/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo/orgs", "repos_url": "https://api.github.com/users/rsandifo/repos", "events_url": "https://api.github.com/users/rsandifo/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7fc242e09f75ff3ec1f14376642e4ffa1a6972da", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7fc242e09f75ff3ec1f14376642e4ffa1a6972da", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7fc242e09f75ff3ec1f14376642e4ffa1a6972da"}], "stats": {"total": 166, "additions": 86, "deletions": 80}, "files": [{"sha": "8c1174e33aa7dd88eafb1a17728823da7bfb5b25", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b11e406dfaf7086a785025a821080f76e9ee185/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b11e406dfaf7086a785025a821080f76e9ee185/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4b11e406dfaf7086a785025a821080f76e9ee185", "patch": "@@ -1,3 +1,19 @@\n+2012-08-26  Richard Sandiford  <rdsandiford@googlemail.com>\n+\n+\t* config/mips/mips.h (AVOID_CCMODE_COPIES): Update rationale for\n+\tdefinition.\n+\t* config/mips/mips.c (machine_function): Add next_fcc.\n+\t(mips_output_move): Remove handling of fcc moves.\n+\t(mips_allocate_fcc): New function.\n+\t(mips_emit_compare, mips_expand_vcondv2sf): Use it.\n+\t(mips_hard_regno_mode_ok_p): Restrict CCmode to ST registers.\n+\tRemove special case for CCmode reloads.\n+\t(mips_expand_builtin_compare_1): Use mips_allocate_fcc and treat\n+\tthe result a fixed operand.\n+\t* config/mips/mips.md (move_type): Remove lui_movf.\n+\t(type, length): Remove references to it.\n+\t(movcc, reload_incc, reload_outcc): Delete.\n+\n 2012-08-26  Richard Sandiford  <rdsandiford@googlemail.com>\n \n \t* config/mips/mips.c (mips_has_long_branch_p): New function,"}, {"sha": "64e98c3fb916d8c6244710a6ea5ec2f9958bb5d7", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 67, "deletions": 19, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b11e406dfaf7086a785025a821080f76e9ee185/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b11e406dfaf7086a785025a821080f76e9ee185/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=4b11e406dfaf7086a785025a821080f76e9ee185", "patch": "@@ -321,6 +321,10 @@ struct GTY(())  mips_frame_info {\n };\n \n struct GTY(())  machine_function {\n+  /* The next floating-point condition-code register to allocate\n+     for ISA_HAS_8CC targets, relative to ST_REG_FIRST.  */\n+  unsigned int next_fcc;\n+\n   /* The register returned by mips16_gp_pseudo_reg; see there for details.  */\n   rtx mips16_gp_pseudo_rtx;\n \n@@ -4284,9 +4288,6 @@ mips_output_move (rtx dest, rtx src)\n \t      retval[4] = COPNUM_AS_CHAR_FROM_REGNUM (REGNO (src));\n \t      return dbl_p ? retval : retval + 1;\n \t    }\n-\n-\t  if (ST_REG_P (REGNO (src)) && ISA_HAS_8CC)\n-\t    return \"lui\\t%0,0x3f80\\n\\tmovf\\t%0,%.,%1\";\n \t}\n \n       if (src_code == MEM)\n@@ -4527,6 +4528,63 @@ mips_reversed_fp_cond (enum rtx_code *code)\n     }\n }\n \n+/* Allocate a floating-point condition-code register of mode MODE.\n+\n+   These condition code registers are used for certain kinds\n+   of compound operation, such as compare and branches, vconds,\n+   and built-in functions.  At expand time, their use is entirely\n+   controlled by MIPS-specific code and is entirely internal\n+   to these compound operations.\n+\n+   We could (and did in the past) expose condition-code values\n+   as pseudo registers and leave the register allocator to pick\n+   appropriate registers.  The problem is that it is not practically\n+   possible for the rtl optimizers to guarantee that no spills will\n+   be needed, even when AVOID_CCMODE_COPIES is defined.  We would\n+   therefore need spill and reload sequences to handle the worst case.\n+\n+   Although such sequences do exist, they are very expensive and are\n+   not something we'd want to use.  This is especially true of CCV2 and\n+   CCV4, where all the shuffling would greatly outweigh whatever benefit\n+   the vectorization itself provides.\n+\n+   The main benefit of having more than one condition-code register\n+   is to allow the pipelining of operations, especially those involving\n+   comparisons and conditional moves.  We don't really expect the\n+   registers to be live for long periods, and certainly never want\n+   them to be live across calls.\n+\n+   Also, there should be no penalty attached to using all the available\n+   registers.  They are simply bits in the same underlying FPU control\n+   register.\n+\n+   We therefore expose the hardware registers from the outset and use\n+   a simple round-robin allocation scheme.  */\n+\n+static rtx\n+mips_allocate_fcc (enum machine_mode mode)\n+{\n+  unsigned int regno, count;\n+\n+  gcc_assert (TARGET_HARD_FLOAT && ISA_HAS_8CC);\n+\n+  if (mode == CCmode)\n+    count = 1;\n+  else if (mode == CCV2mode)\n+    count = 2;\n+  else if (mode == CCV4mode)\n+    count = 4;\n+  else\n+    gcc_unreachable ();\n+\n+  cfun->machine->next_fcc += -cfun->machine->next_fcc & (count - 1);\n+  if (cfun->machine->next_fcc > ST_REG_LAST - ST_REG_FIRST)\n+    cfun->machine->next_fcc = 0;\n+  regno = ST_REG_FIRST + cfun->machine->next_fcc;\n+  cfun->machine->next_fcc += count;\n+  return gen_rtx_REG (mode, regno);\n+}\n+\n /* Convert a comparison into something that can be used in a branch or\n    conditional move.  On entry, *OP0 and *OP1 are the values being\n    compared and *CODE is the code used to compare them.\n@@ -4590,7 +4648,7 @@ mips_emit_compare (enum rtx_code *code, rtx *op0, rtx *op1, bool need_eq_ne_p)\n       cmp_code = *code;\n       *code = mips_reversed_fp_cond (&cmp_code) ? EQ : NE;\n       *op0 = (ISA_HAS_8CC\n-\t      ? gen_reg_rtx (CCmode)\n+\t      ? mips_allocate_fcc (CCmode)\n \t      : gen_rtx_REG (CCmode, FPSW_REGNUM));\n       *op1 = const0_rtx;\n       mips_emit_binary (cmp_code, *op0, cmp_op0, cmp_op1);\n@@ -4657,7 +4715,7 @@ mips_expand_vcondv2sf (rtx dest, rtx true_src, rtx false_src,\n   bool reversed_p;\n \n   reversed_p = mips_reversed_fp_cond (&cond);\n-  cmp_result = gen_reg_rtx (CCV2mode);\n+  cmp_result = mips_allocate_fcc (CCV2mode);\n   emit_insn (gen_scc_ps (cmp_result,\n \t\t\t gen_rtx_fmt_ee (cond, VOIDmode, cmp_op0, cmp_op1)));\n   if (reversed_p)\n@@ -11098,14 +11156,7 @@ mips_hard_regno_mode_ok_p (unsigned int regno, enum machine_mode mode)\n \t    && (regno - ST_REG_FIRST) % 4 == 0);\n \n   if (mode == CCmode)\n-    {\n-      if (!ISA_HAS_8CC)\n-\treturn regno == FPSW_REGNUM;\n-\n-      return (ST_REG_P (regno)\n-\t      || GP_REG_P (regno)\n-\t      || FP_REG_P (regno));\n-    }\n+    return ISA_HAS_8CC ? ST_REG_P (regno) : regno == FPSW_REGNUM;\n \n   size = GET_MODE_SIZE (mode);\n   mclass = GET_MODE_CLASS (mode);\n@@ -11117,10 +11168,6 @@ mips_hard_regno_mode_ok_p (unsigned int regno, enum machine_mode mode)\n       && (((regno - FP_REG_FIRST) % MAX_FPRS_PER_FMT) == 0\n \t  || (MIN_FPRS_PER_FMT == 1 && size <= UNITS_PER_FPREG)))\n     {\n-      /* Allow TFmode for CCmode reloads.  */\n-      if (mode == TFmode && ISA_HAS_8CC)\n-\treturn true;\n-\n       /* Allow 64-bit vector modes for Loongson-2E/2F.  */\n       if (TARGET_LOONGSON_VECTORS\n \t  && (mode == V2SImode\n@@ -13738,15 +13785,16 @@ mips_expand_builtin_compare_1 (enum insn_code icode,\n \t\t\t       tree exp, int nargs)\n {\n   struct expand_operand ops[MAX_RECOG_OPERANDS];\n+  rtx output;\n   int opno, argno;\n \n   /* The instruction should have a target operand, an operand for each\n      argument, and an operand for COND.  */\n   gcc_assert (nargs + 2 == insn_data[(int) icode].n_generator_args);\n \n+  output = mips_allocate_fcc (insn_data[(int) icode].operand[0].mode);\n   opno = 0;\n-  create_output_operand (&ops[opno++], NULL_RTX,\n-\t\t\t insn_data[(int) icode].operand[0].mode);\n+  create_fixed_operand (&ops[opno++], output);\n   for (argno = 0; argno < nargs; argno++)\n     mips_prepare_builtin_arg (&ops[opno++], exp, argno);\n   create_integer_operand (&ops[opno++], (int) cond);"}, {"sha": "caad3c36db85de70b2ecda4b4af709a6384ca4aa", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b11e406dfaf7086a785025a821080f76e9ee185/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b11e406dfaf7086a785025a821080f76e9ee185/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=4b11e406dfaf7086a785025a821080f76e9ee185", "patch": "@@ -2395,12 +2395,8 @@ typedef struct mips_args {\n #define FUNCTION_MODE SImode\n \n \f\n-\n-/* Define if copies to/from condition code registers should be avoided.\n-\n-   This is needed for the MIPS because reload_outcc is not complete;\n-   it needs to handle cases where the source is a general or another\n-   condition code register.  */\n+/* We allocate $fcc registers by hand and can't cope with moves of\n+   CCmode registers to and from pseudos (or memory).  */\n #define AVOID_CCMODE_COPIES\n \n /* A C expression for the cost of a branch instruction.  A value of"}, {"sha": "86d2c55c55d77a7117a3255396f91c80c8cb3909", "filename": "gcc/config/mips/mips.md", "status": "modified", "additions": 1, "deletions": 55, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b11e406dfaf7086a785025a821080f76e9ee185/gcc%2Fconfig%2Fmips%2Fmips.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b11e406dfaf7086a785025a821080f76e9ee185/gcc%2Fconfig%2Fmips%2Fmips.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.md?ref=4b11e406dfaf7086a785025a821080f76e9ee185", "patch": "@@ -198,7 +198,6 @@\n ;; loadpool\tmove a constant into a MIPS16 register by loading it\n ;;\t\tfrom the pool\n ;; shift_shift\ta shift left followed by a shift right\n-;; lui_movf\tan LUI followed by a MOVF (for d<-z CC moves)\n ;;\n ;; This attribute is used to determine the instruction's length and\n ;; scheduling type.  For doubleword moves, the attribute always describes\n@@ -207,7 +206,7 @@\n (define_attr \"move_type\"\n   \"unknown,load,fpload,store,fpstore,mtc,mfc,mtlo,mflo,move,fmove,\n    const,constN,signext,ext_ins,logical,arith,sll0,andi,loadpool,\n-   shift_shift,lui_movf\"\n+   shift_shift\"\n   (const_string \"unknown\"))\n \n (define_attr \"alu_type\" \"unknown,add,sub,not,nor,and,or,xor\"\n@@ -390,8 +389,6 @@\n \t (eq_attr \"move_type\" \"move\") (const_string \"move\")\n \t (eq_attr \"move_type\" \"const\") (const_string \"const\")\n \t (eq_attr \"sync_mem\" \"!none\") (const_string \"syncloop\")]\n-\t;; We classify \"lui_movf\" as \"unknown\" rather than \"multi\"\n-\t;; because we don't split it.  FIXME: we should split instead.\n \t(const_string \"unknown\")))\n \n ;; Mode for conversion types (fcvt)\n@@ -578,10 +575,6 @@\n \t  (eq_attr \"move_type\" \"loadpool\")\n \t  (const_int 8)\n \n-\t  ;; LUI_MOVFs are decomposed into two separate instructions.\n-\t  (eq_attr \"move_type\" \"lui_movf\")\n-\t  (const_int 8)\n-\n \t  ;; SHIFT_SHIFTs are decomposed into two separate instructions.\n \t  ;; They are extended instructions on MIPS16 targets.\n \t  (eq_attr \"move_type\" \"shift_shift\")\n@@ -4436,53 +4429,6 @@\n   operands[2] = GEN_INT (val - 0xff);\n })\n \n-;; This insn handles moving CCmode values.  It's really just a\n-;; slightly simplified copy of movsi_internal2, with additional cases\n-;; to move a condition register to a general register and to move\n-;; between the general registers and the floating point registers.\n-\n-(define_insn \"movcc\"\n-  [(set (match_operand:CC 0 \"nonimmediate_operand\" \"=d,*d,*d,*m,*d,*f,*f,*f,*m\")\n-\t(match_operand:CC 1 \"general_operand\" \"z,*d,*m,*d,*f,*d,*f,*m,*f\"))]\n-  \"ISA_HAS_8CC && TARGET_HARD_FLOAT\"\n-  { return mips_output_move (operands[0], operands[1]); }\n-  [(set_attr \"move_type\" \"lui_movf,move,load,store,mfc,mtc,fmove,fpload,fpstore\")\n-   (set_attr \"mode\" \"SI\")])\n-\n-;; Reload condition code registers.  reload_incc and reload_outcc\n-;; both handle moves from arbitrary operands into condition code\n-;; registers.  reload_incc handles the more common case in which\n-;; a source operand is constrained to be in a condition-code\n-;; register, but has not been allocated to one.\n-;;\n-;; Sometimes, such as in movcc, we have a CCmode destination whose\n-;; constraints do not include 'z'.  reload_outcc handles the case\n-;; when such an operand is allocated to a condition-code register.\n-;;\n-;; Note that reloads from a condition code register to some\n-;; other location can be done using ordinary moves.  Moving\n-;; into a GPR takes a single movcc, moving elsewhere takes\n-;; two.  We can leave these cases to the generic reload code.\n-(define_expand \"reload_incc\"\n-  [(set (match_operand:CC 0 \"fcc_reload_operand\" \"=z\")\n-\t(match_operand:CC 1 \"general_operand\" \"\"))\n-   (clobber (match_operand:TF 2 \"register_operand\" \"=&f\"))]\n-  \"ISA_HAS_8CC && TARGET_HARD_FLOAT\"\n-{\n-  mips_expand_fcc_reload (operands[0], operands[1], operands[2]);\n-  DONE;\n-})\n-\n-(define_expand \"reload_outcc\"\n-  [(set (match_operand:CC 0 \"fcc_reload_operand\" \"=z\")\n-\t(match_operand:CC 1 \"register_operand\" \"\"))\n-   (clobber (match_operand:TF 2 \"register_operand\" \"=&f\"))]\n-  \"ISA_HAS_8CC && TARGET_HARD_FLOAT\"\n-{\n-  mips_expand_fcc_reload (operands[0], operands[1], operands[2]);\n-  DONE;\n-})\n-\n ;; MIPS4 supports loading and storing a floating point register from\n ;; the sum of two general registers.  We use two versions for each of\n ;; these four instructions: one where the two general registers are"}]}