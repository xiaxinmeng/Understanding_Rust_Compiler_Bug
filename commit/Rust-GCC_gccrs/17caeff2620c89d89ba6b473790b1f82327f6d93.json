{"sha": "17caeff2620c89d89ba6b473790b1f82327f6d93", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTdjYWVmZjI2MjBjODlkODliYTZiNDczNzkwYjFmODIzMjdmNmQ5Mw==", "commit": {"author": {"name": "Joseph Myers", "email": "joseph@codesourcery.com", "date": "2007-01-23T19:38:33Z"}, "committer": {"name": "Joseph Myers", "email": "jsm28@gcc.gnu.org", "date": "2007-01-23T19:38:33Z"}, "message": "rs6000-c.c (rs6000_cpu_cpp_builtins): Define _SOFT_DOUBLE if doubles use software floating-point.\n\ngcc:\n\t* config/rs6000/rs6000-c.c (rs6000_cpu_cpp_builtins): Define\n\t_SOFT_DOUBLE if doubles use software floating-point.\n\t* config/rs6000/libgcc-ppc-glibc.ver: Export additional long\n\tdouble functions if _SOFT_DOUBLE, not _SOFT_FLOAT.\n\t* config/rs6000/darwin-ldouble.c: Also compile functions for\n\thard-float without FPRs.  Use fmsub function for all __NO_FPRS__\n\tcases.  Compile extra functions if _SOFT_DOUBLE, not _SOFT_FLOAT.\n\t* config/rs6000/linuxspe.h (SUBSUBTARGET_OVERRIDE_OPTIONS): Remove\n\tcommented-out long double override.\n\t(CPP_LONGDOUBLE_DEFAULT_SPEC): Likewise.\n\t* config/rs6000/eabispe.h: Likewise.\n\t* config/rs6000/rs6000.c (rs6000_override_options): Don't override\n\tlong double for non-SPE.\n\t(rs6000_handle_option): Likewise.\n\t(invalid_e500_subreg): Disallow more subregs involding DImode,\n\tDFmode, TImode or TFmode.\n\t(rs6000_legitimate_offset_address_p): Check TFmode offsets for\n\tE500 double.\n\t(legitimate_lo_sum_address_p): Also check for TFmode for E500\n\tdouble.\n\t(rs6000_legitimize_address): Also handle TFmode for E500 double.\n\t(rs6000_legitimize_reload_address): Also handle TFmode for E500\n\tdouble.\n\t(rs6000_legitimate_address): Also check for TFmode for E500\n\tdouble.\n\t(rs6000_emit_move): Use DFmode subregs of TFmode for E500 double.\n\t(spe_build_register_parallel): Handle TFmode and TCmode.\n\t(rs6000_spe_function_arg): Handle TFmode and TCmode for E500\n\tdouble.\n\t(function_arg): Handle TFmode and TCmode for E500 double.\n\t(rs6000_init_libfuncs): Initialize extra libfuncs for soft double\n\tin general.\n\t(print_operand): Handle TFmode and TImode for %y.\n\t(rs6000_generate_compare): Handle TFmode comparisons for E500\n\tdouble.\n\t(spe_func_has_64bit_regs_p): Check for TFmode for E500 double.\n\t(rs6000_function_value): Handle TFmode and TCmode for E500 double.\n\t(rs6000_libcall_value): Handle TFmode and TCmode for E500 double.\n\t* config/rs6000/rs6000.h (CANNOT_CHANGE_MODE_CLASS): Check for\n\tTFmode for E500 double.\n\t* config/rs6000/rs6000.md (FP): Allow TF for E500 double.\n\t(floatsidf2): Enable for E500 double.\n\t(movtf_softfloat): Use rs6000_nonimmediate_operand.\n\t(extenddftf2): Change to extenddftf2_fprs.\n\t(extenddftf2): Call gen_spe_extenddftf2 or gen_extenddftf2_fprs\n\tdepending on TARGET_E500_DOUBLE.\n\t(extendsftf2): Enable for E500 double.\n\t(trunctfdf2): Enable for E500 double.\n\t(trunctfsf2): Change to trunctfsf2_fprs.\n\t(trunctfsf2): Call gen_spe_trunctfsf2 or gen_trunctfsf2_fprs\n\tdepending on TARGET_E500_DOUBLE.\n\t(floatsitf2): Enable for E500 double.\n\t(fix_trunctfsi2): Change to fix_trunctfsi2_fprs.\n\t(fix_trunctfsi2): Call gen_spe_fix_trunctfsi2 or\n\tgen_fix_trunctfsi2_fprs depending on TARGET_E500_DOUBLE.\n\t(negtf2): Change to negtf2_internal.\n\t(negtf2): New expander.\n\t(abstf2): Enable for E500 double.  Call gen_spe_abstf2_tst,\n\tgen_spe_abstf2_cmp or gen_abstf2_internal depending on\n\tTARGET_E500_DOUBLE and flag_unsafe_math_optimizations.\n\t(movdi_internal32): Use rs6000_nonimmediate_operand.\n\t(unnamed splitter): Likewise.\n\t* config/rs6000/spe.md (CMPTFEQ_GPR, TSTTFEQ_GPR, CMPTFGT_GPR,\n\tTSTTFGT_GPR, CMPTFLT_GPR, TSTTFLT_GPR): New unspecs.\n\t(SPE64TF, DITI): New mode macros.\n\t(frob_df_di): Change to frob_<SPE64:mode>_<DITI:mode>; allow more\n\tmodes.\n\t(frob_tf_ti): New.\n\t(frob_<mode>_di_2): New.\n\t(frob_tf_di_8_2): New.\n\t(frob_di_df): Change to frob_di_<mode>; allow more modes.\n\t(frob_ti_tf): New.\n\t(frob_di_df_2): Change to frob_<DITI:mode>_<SPE64:mode>_2; allow\n\tmore modes.\n\t(frob_ti_<mode>_8_2): New.\n\t(frob_ti_tf_2): New.\n\t(mov_si<mode>_e500_subreg0, mov_si<mode>_e500_subreg0_2,\n\tmov_si<mode>_e500_subreg4, mov_si<mode>_e500_subreg4_2): Allow\n\tTFmode.\n\t(mov_sitf_e500_subreg8, mov_sitf_e500_subreg8_2,\n\tmov_sitf_e500_subreg12, mov_sitf_e500_subreg12_2): New.\n\t(spe_trunctfdf2_internal1, spe_trunctfsf2, spe_extenddftf2,\n\tspe_fix_trunctfsi2, spe_fix_trunctfsi2_internal,\n\tspe_negtf2_internal, spe_abstf2_cmp, spe_abstf2_tst): New.\n\t(cmptfeq_gpr, tsttfeq_gpr, cmptfgt_gpr, tsttfgt_gpr, cmptflt_gpr,\n\ttsttflt_gp): New.\n\nlibgcc:\n\t* config/rs6000/t-ldbl128: Always use -mlong-double-128.\n\nFrom-SVN: r121085", "tree": {"sha": "77969358c67c7847cfce02257d673e18e43d6378", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/77969358c67c7847cfce02257d673e18e43d6378"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/17caeff2620c89d89ba6b473790b1f82327f6d93", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/17caeff2620c89d89ba6b473790b1f82327f6d93", "html_url": "https://github.com/Rust-GCC/gccrs/commit/17caeff2620c89d89ba6b473790b1f82327f6d93", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/17caeff2620c89d89ba6b473790b1f82327f6d93/comments", "author": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dc5696215db3d21f19addc6faa866790e962a7cd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc5696215db3d21f19addc6faa866790e962a7cd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dc5696215db3d21f19addc6faa866790e962a7cd"}], "stats": {"total": 716, "additions": 619, "deletions": 97}, "files": [{"sha": "abd821fa2aea7a168dcf02430c45ec5098e64aff", "filename": "gcc/ChangeLog", "status": "modified", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17caeff2620c89d89ba6b473790b1f82327f6d93/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17caeff2620c89d89ba6b473790b1f82327f6d93/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=17caeff2620c89d89ba6b473790b1f82327f6d93", "patch": "@@ -1,3 +1,92 @@\n+2007-01-23  Joseph Myers  <joseph@codesourcery.com>\n+\n+\t* config/rs6000/rs6000-c.c (rs6000_cpu_cpp_builtins): Define\n+\t_SOFT_DOUBLE if doubles use software floating-point.\n+\t* config/rs6000/libgcc-ppc-glibc.ver: Export additional long\n+\tdouble functions if _SOFT_DOUBLE, not _SOFT_FLOAT.\n+\t* config/rs6000/darwin-ldouble.c: Also compile functions for\n+\thard-float without FPRs.  Use fmsub function for all __NO_FPRS__\n+\tcases.  Compile extra functions if _SOFT_DOUBLE, not _SOFT_FLOAT.\n+\t* config/rs6000/linuxspe.h (SUBSUBTARGET_OVERRIDE_OPTIONS): Remove\n+\tcommented-out long double override.\n+\t(CPP_LONGDOUBLE_DEFAULT_SPEC): Likewise.\n+\t* config/rs6000/eabispe.h: Likewise.\n+\t* config/rs6000/rs6000.c (rs6000_override_options): Don't override\n+\tlong double for non-SPE.\n+\t(rs6000_handle_option): Likewise.\n+\t(invalid_e500_subreg): Disallow more subregs involding DImode,\n+\tDFmode, TImode or TFmode.\n+\t(rs6000_legitimate_offset_address_p): Check TFmode offsets for\n+\tE500 double.\n+\t(legitimate_lo_sum_address_p): Also check for TFmode for E500\n+\tdouble.\n+\t(rs6000_legitimize_address): Also handle TFmode for E500 double.\n+\t(rs6000_legitimize_reload_address): Also handle TFmode for E500\n+\tdouble.\n+\t(rs6000_legitimate_address): Also check for TFmode for E500\n+\tdouble.\n+\t(rs6000_emit_move): Use DFmode subregs of TFmode for E500 double.\n+\t(spe_build_register_parallel): Handle TFmode and TCmode.\n+\t(rs6000_spe_function_arg): Handle TFmode and TCmode for E500\n+\tdouble.\n+\t(function_arg): Handle TFmode and TCmode for E500 double.\n+\t(rs6000_init_libfuncs): Initialize extra libfuncs for soft double\n+\tin general.\n+\t(print_operand): Handle TFmode and TImode for %y.\n+\t(rs6000_generate_compare): Handle TFmode comparisons for E500\n+\tdouble.\n+\t(spe_func_has_64bit_regs_p): Check for TFmode for E500 double.\n+\t(rs6000_function_value): Handle TFmode and TCmode for E500 double.\n+\t(rs6000_libcall_value): Handle TFmode and TCmode for E500 double.\n+\t* config/rs6000/rs6000.h (CANNOT_CHANGE_MODE_CLASS): Check for\n+\tTFmode for E500 double.\n+\t* config/rs6000/rs6000.md (FP): Allow TF for E500 double.\n+\t(floatsidf2): Enable for E500 double.\n+\t(movtf_softfloat): Use rs6000_nonimmediate_operand.\n+\t(extenddftf2): Change to extenddftf2_fprs.\n+\t(extenddftf2): Call gen_spe_extenddftf2 or gen_extenddftf2_fprs\n+\tdepending on TARGET_E500_DOUBLE.\n+\t(extendsftf2): Enable for E500 double.\n+\t(trunctfdf2): Enable for E500 double.\n+\t(trunctfsf2): Change to trunctfsf2_fprs.\n+\t(trunctfsf2): Call gen_spe_trunctfsf2 or gen_trunctfsf2_fprs\n+\tdepending on TARGET_E500_DOUBLE.\n+\t(floatsitf2): Enable for E500 double.\n+\t(fix_trunctfsi2): Change to fix_trunctfsi2_fprs.\n+\t(fix_trunctfsi2): Call gen_spe_fix_trunctfsi2 or\n+\tgen_fix_trunctfsi2_fprs depending on TARGET_E500_DOUBLE.\n+\t(negtf2): Change to negtf2_internal.\n+\t(negtf2): New expander.\n+\t(abstf2): Enable for E500 double.  Call gen_spe_abstf2_tst,\n+\tgen_spe_abstf2_cmp or gen_abstf2_internal depending on\n+\tTARGET_E500_DOUBLE and flag_unsafe_math_optimizations.\n+\t(movdi_internal32): Use rs6000_nonimmediate_operand.\n+\t(unnamed splitter): Likewise.\n+\t* config/rs6000/spe.md (CMPTFEQ_GPR, TSTTFEQ_GPR, CMPTFGT_GPR,\n+\tTSTTFGT_GPR, CMPTFLT_GPR, TSTTFLT_GPR): New unspecs.\n+\t(SPE64TF, DITI): New mode macros.\n+\t(frob_df_di): Change to frob_<SPE64:mode>_<DITI:mode>; allow more\n+\tmodes.\n+\t(frob_tf_ti): New.\n+\t(frob_<mode>_di_2): New.\n+\t(frob_tf_di_8_2): New.\n+\t(frob_di_df): Change to frob_di_<mode>; allow more modes.\n+\t(frob_ti_tf): New.\n+\t(frob_di_df_2): Change to frob_<DITI:mode>_<SPE64:mode>_2; allow\n+\tmore modes.\n+\t(frob_ti_<mode>_8_2): New.\n+\t(frob_ti_tf_2): New.\n+\t(mov_si<mode>_e500_subreg0, mov_si<mode>_e500_subreg0_2,\n+\tmov_si<mode>_e500_subreg4, mov_si<mode>_e500_subreg4_2): Allow\n+\tTFmode.\n+\t(mov_sitf_e500_subreg8, mov_sitf_e500_subreg8_2,\n+\tmov_sitf_e500_subreg12, mov_sitf_e500_subreg12_2): New.\n+\t(spe_trunctfdf2_internal1, spe_trunctfsf2, spe_extenddftf2,\n+\tspe_fix_trunctfsi2, spe_fix_trunctfsi2_internal,\n+\tspe_negtf2_internal, spe_abstf2_cmp, spe_abstf2_tst): New.\n+\t(cmptfeq_gpr, tsttfeq_gpr, cmptfgt_gpr, tsttfgt_gpr, cmptflt_gpr,\n+\ttsttflt_gp): New.\n+\n 2007-01-23  Ian Lance Taylor  <iant@google.com>\n \n \t* Makefile.in (OBJS-common): Reformat, alphabetize, but put"}, {"sha": "7405448706a4e7b026ca23dd5562abe7af5cdd15", "filename": "gcc/config/rs6000/darwin-ldouble.c", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17caeff2620c89d89ba6b473790b1f82327f6d93/gcc%2Fconfig%2Frs6000%2Fdarwin-ldouble.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17caeff2620c89d89ba6b473790b1f82327f6d93/gcc%2Fconfig%2Frs6000%2Fdarwin-ldouble.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fdarwin-ldouble.c?ref=17caeff2620c89d89ba6b473790b1f82327f6d93", "patch": "@@ -1,5 +1,5 @@\n /* 128-bit long double support routines for Darwin.\n-   Copyright (C) 1993, 2003, 2004, 2005, 2006\n+   Copyright (C) 1993, 2003, 2004, 2005, 2006, 2007\n    Free Software Foundation, Inc.\n \n This file is part of GCC.\n@@ -49,8 +49,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n \n    This code currently assumes big-endian.  */\n \n-#if ((!defined (__NO_FPRS__) || defined (_SOFT_FLOAT)) \\\n-     && !defined (__LITTLE_ENDIAN__) \\\n+#if (!defined (__LITTLE_ENDIAN__) \\\n      && (defined (__MACH__) || defined (__powerpc__) || defined (_AIX)))\n \n #define fabs(x) __builtin_fabs(x)\n@@ -145,7 +144,7 @@ __gcc_qsub (double a, double b, double c, double d)\n   return __gcc_qadd (a, b, -c, -d);\n }\n \n-#ifdef _SOFT_FLOAT\n+#ifdef __NO_FPRS__\n static double fmsub (double, double, double);\n #endif\n \n@@ -164,7 +163,7 @@ __gcc_qmul (double a, double b, double c, double d)\n   /* Sum terms of two highest orders. */\n   \n   /* Use fused multiply-add to get low part of a * c.  */\n-#ifndef _SOFT_FLOAT\n+#ifndef __NO_FPRS__\n   asm (\"fmsub %0,%1,%2,%3\" : \"=f\"(tau) : \"f\"(a), \"f\"(c), \"f\"(t));\n #else\n   tau = fmsub (a, c, t);\n@@ -201,7 +200,7 @@ __gcc_qdiv (double a, double b, double c, double d)\n \t\t\t   numerically necessary.  */\n   \n   /* Use fused multiply-add to get low part of c * t.\t */\n-#ifndef _SOFT_FLOAT\n+#ifndef __NO_FPRS__\n   asm (\"fmsub %0,%1,%2,%3\" : \"=f\"(sigma) : \"f\"(c), \"f\"(t), \"f\"(s));\n #else\n   sigma = fmsub (c, t, s);\n@@ -219,7 +218,7 @@ __gcc_qdiv (double a, double b, double c, double d)\n   return z.ldval;\n }\n \n-#if defined (_SOFT_FLOAT) && defined (__LONG_DOUBLE_128__)\n+#if defined (_SOFT_DOUBLE) && defined (__LONG_DOUBLE_128__)\n \n long double __gcc_qneg (double, double);\n int __gcc_qeq (double, double, double, double);\n@@ -362,6 +361,10 @@ __gcc_utoq (unsigned int a)\n   return __gcc_dtoq ((double) a);\n }\n \n+#endif\n+\n+#ifdef __NO_FPRS__\n+\n #include \"config/soft-fp/soft-fp.h\"\n #include \"config/soft-fp/double.h\"\n #include \"config/soft-fp/quad.h\""}, {"sha": "40669dd94b83cf3925a67b94731d590e6df4a25b", "filename": "gcc/config/rs6000/eabispe.h", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17caeff2620c89d89ba6b473790b1f82327f6d93/gcc%2Fconfig%2Frs6000%2Feabispe.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17caeff2620c89d89ba6b473790b1f82327f6d93/gcc%2Fconfig%2Frs6000%2Feabispe.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Feabispe.h?ref=17caeff2620c89d89ba6b473790b1f82327f6d93", "patch": "@@ -1,6 +1,7 @@\n /* Core target definitions for GNU compiler\n    for PowerPC embedded targeted systems with SPE support.\n-   Copyright (C) 2002, 2003, 2004, 2005 Free Software Foundation, Inc.\n+   Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007\n+   Free Software Foundation, Inc.\n    Contributed by Aldy Hernandez (aldyh@redhat.com).\n \n    This file is part of GCC.\n@@ -35,9 +36,6 @@\n     rs6000_spe_abi = 1; \\\n   if (!rs6000_explicit_options.float_gprs) \\\n     rs6000_float_gprs = 1; \\\n-  /* See note below.  */ \\\n-  /*if (!rs6000_explicit_options.long_double)*/ \\\n-  /*  rs6000_long_double_type_size = 128;*/ \\\n   if (!rs6000_explicit_options.spe) \\\n     rs6000_spe = 1; \\\n   if (!rs6000_explicit_options.isel) \\\n@@ -52,8 +50,7 @@\n    specifications, until I properly fix the emulation.\n \n    Enable these later.\n-#undef CPP_LONGDOUBLE_DEFAULT_SPEC\n-#define CPP_LONGDOUBLE_DEFAULT_SPEC \"-D__LONG_DOUBLE_128__=1\"\n+#define RS6000_DEFAULT_LONG_DOUBLE_SIZE (TARGET_SPE ? 128 : 64)\n */\n \n #undef  ASM_DEFAULT_SPEC"}, {"sha": "d065c13bca422a3eb6c4a9446d6550392c37edb4", "filename": "gcc/config/rs6000/libgcc-ppc-glibc.ver", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17caeff2620c89d89ba6b473790b1f82327f6d93/gcc%2Fconfig%2Frs6000%2Flibgcc-ppc-glibc.ver", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17caeff2620c89d89ba6b473790b1f82327f6d93/gcc%2Fconfig%2Frs6000%2Flibgcc-ppc-glibc.ver", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Flibgcc-ppc-glibc.ver?ref=17caeff2620c89d89ba6b473790b1f82327f6d93", "patch": "@@ -31,7 +31,7 @@ GCC_4.2.0 {\n   __gcc_qmul\n   __gcc_qdiv\n \n-%ifdef _SOFT_FLOAT\n+%ifdef _SOFT_DOUBLE\n   __gcc_qneg\n   __gcc_qeq\n   __gcc_qne"}, {"sha": "8dc2dc90e12779535aaf38ade681ae49edad2d72", "filename": "gcc/config/rs6000/linuxspe.h", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17caeff2620c89d89ba6b473790b1f82327f6d93/gcc%2Fconfig%2Frs6000%2Flinuxspe.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17caeff2620c89d89ba6b473790b1f82327f6d93/gcc%2Fconfig%2Frs6000%2Flinuxspe.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Flinuxspe.h?ref=17caeff2620c89d89ba6b473790b1f82327f6d93", "patch": "@@ -35,26 +35,12 @@\n     rs6000_spe_abi = 1; \\\n   if (!rs6000_explicit_options.float_gprs) \\\n     rs6000_float_gprs = 1; \\\n-  /* See note below.  */ \\\n-  /*if (!rs6000_explicit_options.long_double)*/ \\\n-  /*  rs6000_long_double_type_size = 128;*/ \\\n   if (!rs6000_explicit_options.spe) \\\n     rs6000_spe = 1; \\\n   if (!rs6000_explicit_options.isel) \\\n     rs6000_isel = 1; \\\n   if (target_flags & MASK_64BIT) \\\n     error (\"-m64 not supported in this configuration\")\n \n-/* The e500 ABI says that either long doubles are 128 bits, or if\n-   implemented in any other size, the compiler/linker should error out.\n-   We have no emulation libraries for 128 bit long doubles, and I hate\n-   the dozens of failures on the regression suite.  So I'm breaking ABI\n-   specifications, until I properly fix the emulation.\n-\n-   Enable these later.\n-#undef CPP_LONGDOUBLE_DEFAULT_SPEC\n-#define CPP_LONGDOUBLE_DEFAULT_SPEC \"-D__LONG_DOUBLE_128__=1\"\n-*/\n-\n #undef  ASM_DEFAULT_SPEC\n #define\tASM_DEFAULT_SPEC \"-mppc -mspe -me500\""}, {"sha": "55c9b7c66b211d473ae7ffc42a94973da6000bd5", "filename": "gcc/config/rs6000/rs6000-c.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17caeff2620c89d89ba6b473790b1f82327f6d93/gcc%2Fconfig%2Frs6000%2Frs6000-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17caeff2620c89d89ba6b473790b1f82327f6d93/gcc%2Fconfig%2Frs6000%2Frs6000-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-c.c?ref=17caeff2620c89d89ba6b473790b1f82327f6d93", "patch": "@@ -1,5 +1,5 @@\n /* Subroutines for the C front end on the POWER and PowerPC architectures.\n-   Copyright (C) 2002, 2003, 2004, 2005\n+   Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007\n    Free Software Foundation, Inc.\n \n    Contributed by Zack Weinberg <zack@codesourcery.com>\n@@ -124,6 +124,8 @@ rs6000_cpu_cpp_builtins (cpp_reader *pfile)\n     builtin_define (\"__SPE__\");\n   if (TARGET_SOFT_FLOAT)\n     builtin_define (\"_SOFT_FLOAT\");\n+  if (!(TARGET_HARD_FLOAT && (TARGET_FPRS || TARGET_E500_DOUBLE)))\n+    builtin_define (\"_SOFT_DOUBLE\");\n   /* Used by lwarx/stwcx. errata work-around.  */\n   if (rs6000_cpu == PROCESSOR_PPC405)\n     builtin_define (\"__PPC405__\");"}, {"sha": "f72fde34ffc0a05a527e34997a17f7223d2a0b32", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 88, "deletions": 31, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17caeff2620c89d89ba6b473790b1f82327f6d93/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17caeff2620c89d89ba6b473790b1f82327f6d93/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=17caeff2620c89d89ba6b473790b1f82327f6d93", "patch": "@@ -1464,8 +1464,6 @@ rs6000_override_options (const char *default_cpu)\n \trs6000_float_gprs = 0;\n       if (!rs6000_explicit_options.isel)\n \trs6000_isel = 0;\n-      if (!rs6000_explicit_options.long_double)\n-\trs6000_long_double_type_size = RS6000_DEFAULT_LONG_DOUBLE_SIZE;\n     }\n \n   /* Detect invalid option combinations with E500.  */\n@@ -1892,9 +1890,6 @@ rs6000_handle_option (size_t code, const char *arg, int value)\n     case OPT_mspe_:\n       rs6000_explicit_options.spe = true;\n       rs6000_parse_yes_no_option (\"spe\", arg, &(rs6000_spe));\n-      /* No SPE means 64-bit long doubles, even if an E500.  */\n-      if (!rs6000_spe)\n-\trs6000_long_double_type_size = 64;\n       break;\n \n     case OPT_mdebug_:\n@@ -2718,18 +2713,22 @@ invalid_e500_subreg (rtx op, enum machine_mode mode)\n {\n   if (TARGET_E500_DOUBLE)\n     {\n-      /* Reject (subreg:SI (reg:DF)).  */\n+      /* Reject (subreg:SI (reg:DF)); likewise with subreg:DI or\n+\t subreg:TI and reg:TF.  */\n       if (GET_CODE (op) == SUBREG\n-\t  && mode == SImode\n+\t  && (mode == SImode || mode == DImode || mode == TImode)\n \t  && REG_P (SUBREG_REG (op))\n-\t  && GET_MODE (SUBREG_REG (op)) == DFmode)\n+\t  && (GET_MODE (SUBREG_REG (op)) == DFmode\n+\t      || GET_MODE (SUBREG_REG (op)) == TFmode))\n \treturn true;\n \n-      /* Reject (subreg:DF (reg:DI)).  */\n+      /* Reject (subreg:DF (reg:DI)); likewise with subreg:TF and\n+\t reg:TI.  */\n       if (GET_CODE (op) == SUBREG\n-\t  && mode == DFmode\n+\t  && (mode == DFmode || mode == TFmode)\n \t  && REG_P (SUBREG_REG (op))\n-\t  && GET_MODE (SUBREG_REG (op)) == DImode)\n+\t  && (GET_MODE (SUBREG_REG (op)) == DImode\n+\t      || GET_MODE (SUBREG_REG (op)) == TImode))\n \treturn true;\n     }\n \n@@ -2989,6 +2988,10 @@ rs6000_legitimate_offset_address_p (enum machine_mode mode, rtx x, int strict)\n       break;\n \n     case TFmode:\n+      if (TARGET_E500_DOUBLE)\n+\treturn (SPE_CONST_OFFSET_OK (offset)\n+\t\t&& SPE_CONST_OFFSET_OK (offset + 8));\n+\n     case TImode:\n       if (mode == TFmode || !TARGET_POWERPC64)\n \textra = 12;\n@@ -3067,7 +3070,8 @@ legitimate_lo_sum_address_p (enum machine_mode mode, rtx x, int strict)\n   if (!INT_REG_OK_FOR_BASE_P (XEXP (x, 0), strict))\n     return false;\n   /* Restrict addressing for DI because of our SUBREG hackery.  */\n-  if (TARGET_E500_DOUBLE && (mode == DFmode || mode == DImode))\n+  if (TARGET_E500_DOUBLE && (mode == DFmode || mode == TFmode\n+\t\t\t     || mode == DImode))\n     return false;\n   x = XEXP (x, 1);\n \n@@ -3165,7 +3169,7 @@ rs6000_legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED,\n       return reg;\n     }\n   else if (SPE_VECTOR_MODE (mode)\n-\t   || (TARGET_E500_DOUBLE && (mode == DFmode\n+\t   || (TARGET_E500_DOUBLE && (mode == DFmode || mode == TFmode\n \t\t\t\t      || mode == DImode)))\n     {\n       if (mode == DImode)\n@@ -3570,7 +3574,7 @@ rs6000_legitimize_reload_address (rtx x, enum machine_mode mode,\n       && REG_MODE_OK_FOR_BASE_P (XEXP (x, 0), mode)\n       && GET_CODE (XEXP (x, 1)) == CONST_INT\n       && !SPE_VECTOR_MODE (mode)\n-      && !(TARGET_E500_DOUBLE && (mode == DFmode\n+      && !(TARGET_E500_DOUBLE && (mode == DFmode || mode == TFmode\n \t\t\t\t  || mode == DImode))\n       && !ALTIVEC_VECTOR_MODE (mode))\n     {\n@@ -3707,7 +3711,8 @@ rs6000_legitimate_address (enum machine_mode mode, rtx x, int reg_ok_strict)\n       && !SPE_VECTOR_MODE (mode)\n       && mode != TFmode\n       /* Restrict addressing for DI because of our SUBREG hackery.  */\n-      && !(TARGET_E500_DOUBLE && (mode == DFmode || mode == DImode))\n+      && !(TARGET_E500_DOUBLE && (mode == DFmode || mode == TFmode\n+\t\t\t\t  || mode == DImode))\n       && TARGET_UPDATE\n       && legitimate_indirect_address_p (XEXP (x, 0), reg_ok_strict))\n     return 1;\n@@ -4222,14 +4227,15 @@ rs6000_emit_move (rtx dest, rtx source, enum machine_mode mode)\n     {\n       /* DImode is used, not DFmode, because simplify_gen_subreg doesn't\n \t know how to get a DFmode SUBREG of a TFmode.  */\n-      rs6000_emit_move (simplify_gen_subreg (DImode, operands[0], mode, 0),\n-\t\t\tsimplify_gen_subreg (DImode, operands[1], mode, 0),\n-\t\t\tDImode);\n-      rs6000_emit_move (simplify_gen_subreg (DImode, operands[0], mode,\n-\t\t\t\t\t     GET_MODE_SIZE (DImode)),\n-\t\t\tsimplify_gen_subreg (DImode, operands[1], mode,\n-\t\t\t\t\t     GET_MODE_SIZE (DImode)),\n-\t\t\tDImode);\n+      enum machine_mode imode = (TARGET_E500_DOUBLE ? DFmode : DImode);\n+      rs6000_emit_move (simplify_gen_subreg (imode, operands[0], mode, 0),\n+\t\t\tsimplify_gen_subreg (imode, operands[1], mode, 0),\n+\t\t\timode);\n+      rs6000_emit_move (simplify_gen_subreg (imode, operands[0], mode,\n+\t\t\t\t\t     GET_MODE_SIZE (imode)),\n+\t\t\tsimplify_gen_subreg (imode, operands[1], mode,\n+\t\t\t\t\t     GET_MODE_SIZE (imode)),\n+\t\t\timode);\n       return;\n     }\n \n@@ -5019,7 +5025,7 @@ function_arg_advance (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n static rtx\n spe_build_register_parallel (enum machine_mode mode, int gregno)\n {\n-  rtx r1, r3;\n+  rtx r1, r3, r5, r7;\n \n   switch (mode)\n     {\n@@ -5029,12 +5035,24 @@ spe_build_register_parallel (enum machine_mode mode, int gregno)\n       return gen_rtx_PARALLEL (mode, gen_rtvec (1, r1));\n \n     case DCmode:\n+    case TFmode:\n       r1 = gen_rtx_REG (DImode, gregno);\n       r1 = gen_rtx_EXPR_LIST (VOIDmode, r1, const0_rtx);\n       r3 = gen_rtx_REG (DImode, gregno + 2);\n       r3 = gen_rtx_EXPR_LIST (VOIDmode, r3, GEN_INT (8));\n       return gen_rtx_PARALLEL (mode, gen_rtvec (2, r1, r3));\n \n+    case TCmode:\n+      r1 = gen_rtx_REG (DImode, gregno);\n+      r1 = gen_rtx_EXPR_LIST (VOIDmode, r1, const0_rtx);\n+      r3 = gen_rtx_REG (DImode, gregno + 2);\n+      r3 = gen_rtx_EXPR_LIST (VOIDmode, r3, GEN_INT (8));\n+      r5 = gen_rtx_REG (DImode, gregno + 4);\n+      r5 = gen_rtx_EXPR_LIST (VOIDmode, r5, GEN_INT (16));\n+      r7 = gen_rtx_REG (DImode, gregno + 6);\n+      r7 = gen_rtx_EXPR_LIST (VOIDmode, r7, GEN_INT (24));\n+      return gen_rtx_PARALLEL (mode, gen_rtvec (4, r1, r3, r5, r7));\n+\n     default:\n       gcc_unreachable ();\n     }\n@@ -5049,7 +5067,8 @@ rs6000_spe_function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n \n   /* On E500 v2, double arithmetic is done on the full 64-bit GPR, but\n      are passed and returned in a pair of GPRs for ABI compatibility.  */\n-  if (TARGET_E500_DOUBLE && (mode == DFmode || mode == DCmode))\n+  if (TARGET_E500_DOUBLE && (mode == DFmode || mode == DCmode\n+\t\t\t     || mode == TFmode || mode == TCmode))\n     {\n       int n_words = rs6000_arg_size (mode, type);\n \n@@ -5467,7 +5486,9 @@ function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n   else if (TARGET_SPE_ABI && TARGET_SPE\n \t   && (SPE_VECTOR_MODE (mode)\n \t       || (TARGET_E500_DOUBLE && (mode == DFmode\n-\t\t\t\t\t  || mode == DCmode))))\n+\t\t\t\t\t  || mode == DCmode\n+\t\t\t\t\t  || mode == TFmode\n+\t\t\t\t\t  || mode == TCmode))))\n     return rs6000_spe_function_arg (cum, mode, type);\n \n   else if (abi == ABI_V4)\n@@ -9420,7 +9441,7 @@ rs6000_init_libfuncs (void)\n \tset_optab_libfunc (smul_optab, TFmode, \"__gcc_qmul\");\n \tset_optab_libfunc (sdiv_optab, TFmode, \"__gcc_qdiv\");\n \n-\tif (TARGET_SOFT_FLOAT)\n+\tif (!(TARGET_HARD_FLOAT && (TARGET_FPRS || TARGET_E500_DOUBLE)))\n \t  {\n \t    set_optab_libfunc (neg_optab, TFmode, \"__gcc_qneg\");\n \t    set_optab_libfunc (eq_optab, TFmode, \"__gcc_qeq\");\n@@ -11034,7 +11055,9 @@ print_operand (FILE *file, rtx x, int code)\n \n \t/* Ugly hack because %y is overloaded.  */\n \tif ((TARGET_SPE || TARGET_E500_DOUBLE)\n-\t    && GET_MODE_SIZE (GET_MODE (x)) == 8)\n+\t    && (GET_MODE_SIZE (GET_MODE (x)) == 8\n+\t\t|| GET_MODE (x) == TFmode\n+\t\t|| GET_MODE (x) == TImode))\n \t  {\n \t    /* Handle [reg].  */\n \t    if (GET_CODE (tmp) == REG)\n@@ -11366,6 +11389,14 @@ rs6000_generate_compare (enum rtx_code code)\n \t\t\t\t   rs6000_compare_op1);\n \t      break;\n \n+\t    case TFmode:\n+\t      cmp = flag_unsafe_math_optimizations\n+\t\t? gen_tsttfeq_gpr (compare_result, rs6000_compare_op0,\n+\t\t\t\t   rs6000_compare_op1)\n+\t\t: gen_cmptfeq_gpr (compare_result, rs6000_compare_op0,\n+\t\t\t\t   rs6000_compare_op1);\n+\t      break;\n+\n \t    default:\n \t      gcc_unreachable ();\n \t    }\n@@ -11390,6 +11421,14 @@ rs6000_generate_compare (enum rtx_code code)\n \t\t\t\t   rs6000_compare_op1);\n \t      break;\n \n+\t    case TFmode:\n+\t      cmp = flag_unsafe_math_optimizations\n+\t\t? gen_tsttfgt_gpr (compare_result, rs6000_compare_op0,\n+\t\t\t\t   rs6000_compare_op1)\n+\t\t: gen_cmptfgt_gpr (compare_result, rs6000_compare_op0,\n+\t\t\t\t   rs6000_compare_op1);\n+\t      break;\n+\n \t    default:\n \t      gcc_unreachable ();\n \t    }\n@@ -11414,6 +11453,14 @@ rs6000_generate_compare (enum rtx_code code)\n \t\t\t\t   rs6000_compare_op1);\n \t      break;\n \n+\t    case TFmode:\n+\t      cmp = flag_unsafe_math_optimizations\n+\t\t? gen_tsttflt_gpr (compare_result, rs6000_compare_op0,\n+\t\t\t\t   rs6000_compare_op1)\n+\t\t: gen_cmptflt_gpr (compare_result, rs6000_compare_op0,\n+\t\t\t\t   rs6000_compare_op1);\n+\t      break;\n+\n \t    default:\n \t      gcc_unreachable ();\n \t    }\n@@ -11457,6 +11504,14 @@ rs6000_generate_compare (enum rtx_code code)\n \t\t\t\t   rs6000_compare_op1);\n \t      break;\n \n+\t    case TFmode:\n+\t      cmp = flag_unsafe_math_optimizations\n+\t\t? gen_tsttfeq_gpr (compare_result2, rs6000_compare_op0,\n+\t\t\t\t   rs6000_compare_op1)\n+\t\t: gen_cmptfeq_gpr (compare_result2, rs6000_compare_op0,\n+\t\t\t\t   rs6000_compare_op1);\n+\t      break;\n+\n \t    default:\n \t      gcc_unreachable ();\n \t    }\n@@ -13504,7 +13559,7 @@ spe_func_has_64bit_regs_p (void)\n \n \t      if (SPE_VECTOR_MODE (mode))\n \t\treturn true;\n-\t      if (TARGET_E500_DOUBLE && mode == DFmode)\n+\t      if (TARGET_E500_DOUBLE && (mode == DFmode || mode == TFmode))\n \t\treturn true;\n \t    }\n \t}\n@@ -20274,7 +20329,8 @@ rs6000_function_value (tree valtype, tree func ATTRIBUTE_UNUSED)\n \t   && ALTIVEC_VECTOR_MODE (mode))\n     regno = ALTIVEC_ARG_RETURN;\n   else if (TARGET_E500_DOUBLE && TARGET_HARD_FLOAT\n-\t   && (mode == DFmode || mode == DCmode))\n+\t   && (mode == DFmode || mode == DCmode\n+\t       || mode == TFmode || mode == TCmode))\n     return spe_build_register_parallel (mode, GP_ARG_RETURN);\n   else\n     regno = GP_ARG_RETURN;\n@@ -20314,7 +20370,8 @@ rs6000_libcall_value (enum machine_mode mode)\n   else if (COMPLEX_MODE_P (mode) && targetm.calls.split_complex_arg)\n     return rs6000_complex_function_value (mode);\n   else if (TARGET_E500_DOUBLE && TARGET_HARD_FLOAT\n-\t   && (mode == DFmode || mode == DCmode))\n+\t   && (mode == DFmode || mode == DCmode\n+\t       || mode == TFmode || mode == TCmode))\n     return spe_build_register_parallel (mode, GP_ARG_RETURN);\n   else\n     regno = GP_ARG_RETURN;"}, {"sha": "decaf8fae8fa1818892db450b0401d7ad925839c", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17caeff2620c89d89ba6b473790b1f82327f6d93/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17caeff2620c89d89ba6b473790b1f82327f6d93/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=17caeff2620c89d89ba6b473790b1f82327f6d93", "patch": "@@ -1160,6 +1160,7 @@ enum reg_class\n       && reg_classes_intersect_p (FLOAT_REGS, CLASS))\t\t\t\\\n    : (((TARGET_E500_DOUBLE\t\t\t\t\t\t\\\n \t&& ((((TO) == DFmode) + ((FROM) == DFmode)) == 1\t\t\\\n+\t    || (((TO) == TFmode) + ((FROM) == TFmode)) == 1\t\t\\\n \t    || (((TO) == DImode) + ((FROM) == DImode)) == 1))\t\t\\\n        || (TARGET_SPE\t\t\t\t\t\t\t\\\n \t   && (SPE_VECTOR_MODE (FROM) + SPE_VECTOR_MODE (TO)) == 1))\t\\"}, {"sha": "ce774b187b2583d2d0a5110f163d62a5eba89108", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 87, "deletions": 14, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17caeff2620c89d89ba6b473790b1f82327f6d93/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17caeff2620c89d89ba6b473790b1f82327f6d93/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=17caeff2620c89d89ba6b473790b1f82327f6d93", "patch": "@@ -176,7 +176,9 @@\n (define_mode_macro FP [(SF \"TARGET_HARD_FLOAT\")\n   (DF \"TARGET_HARD_FLOAT && (TARGET_FPRS || TARGET_E500_DOUBLE)\")\n   (TF \"!TARGET_IEEEQUAD\n-   && TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_LONG_DOUBLE_128\")])\n+   && TARGET_HARD_FLOAT\n+   && (TARGET_FPRS || TARGET_E500_DOUBLE)\n+   && TARGET_LONG_DOUBLE_128\")])\n \n ; Various instructions that come in SI and DI forms.\n ; A generic w/d attribute, for things like cmpw/cmpd.\n@@ -5730,7 +5732,7 @@\n \t      (clobber (match_dup 4))\n \t      (clobber (match_dup 5))\n \t      (clobber (match_dup 6))])]\n-  \"TARGET_HARD_FLOAT && TARGET_FPRS\"\n+  \"TARGET_HARD_FLOAT && (TARGET_FPRS || TARGET_E500_DOUBLE)\"\n   \"\n {\n   if (TARGET_E500_DOUBLE)\n@@ -8538,7 +8540,7 @@\n   [(set_attr \"length\" \"8,8,8,20,20,16\")])\n \n (define_insn_and_split \"*movtf_softfloat\"\n-  [(set (match_operand:TF 0 \"nonimmediate_operand\" \"=r,Y,r\")\n+  [(set (match_operand:TF 0 \"rs6000_nonimmediate_operand\" \"=r,Y,r\")\n \t(match_operand:TF 1 \"input_operand\"         \"YGHF,r,r\"))]\n   \"!TARGET_IEEEQUAD\n    && (TARGET_SOFT_FLOAT || !TARGET_FPRS) && TARGET_LONG_DOUBLE_128\n@@ -8551,6 +8553,21 @@\n   [(set_attr \"length\" \"20,20,16\")])\n \n (define_expand \"extenddftf2\"\n+  [(set (match_operand:TF 0 \"nonimmediate_operand\" \"\")\n+\t(float_extend:TF (match_operand:DF 1 \"input_operand\" \"\")))]\n+  \"!TARGET_IEEEQUAD\n+   && TARGET_HARD_FLOAT\n+   && (TARGET_FPRS || TARGET_E500_DOUBLE)\n+   && TARGET_LONG_DOUBLE_128\"\n+{\n+  if (TARGET_E500_DOUBLE)\n+    emit_insn (gen_spe_extenddftf2 (operands[0], operands[1]));\n+  else\n+    emit_insn (gen_extenddftf2_fprs (operands[0], operands[1]));\n+  DONE;\n+})\n+\n+(define_expand \"extenddftf2_fprs\"\n   [(parallel [(set (match_operand:TF 0 \"nonimmediate_operand\" \"\")\n \t\t   (float_extend:TF (match_operand:DF 1 \"input_operand\" \"\")))\n \t      (use (match_dup 2))])]\n@@ -8586,7 +8603,9 @@\n   [(set (match_operand:TF 0 \"nonimmediate_operand\" \"\")\n \t(float_extend:TF (match_operand:SF 1 \"gpc_reg_operand\" \"\")))]\n   \"!TARGET_IEEEQUAD\n-   && TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_LONG_DOUBLE_128\"\n+   && TARGET_HARD_FLOAT\n+   && (TARGET_FPRS || TARGET_E500_DOUBLE)\n+   && TARGET_LONG_DOUBLE_128\"\n {\n   rtx tmp = gen_reg_rtx (DFmode);\n   emit_insn (gen_extendsfdf2 (tmp, operands[1]));\n@@ -8598,7 +8617,9 @@\n   [(set (match_operand:DF 0 \"gpc_reg_operand\" \"\")\n \t(float_truncate:DF (match_operand:TF 1 \"gpc_reg_operand\" \"\")))]\n   \"!TARGET_IEEEQUAD\n-   && TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_LONG_DOUBLE_128\"\n+   && TARGET_HARD_FLOAT\n+   && (TARGET_FPRS || TARGET_E500_DOUBLE)\n+   && TARGET_LONG_DOUBLE_128\"\n   \"\")\n \n (define_insn_and_split \"trunctfdf2_internal1\"\n@@ -8625,7 +8646,22 @@\n   \"fadd %0,%1,%L1\"\n   [(set_attr \"type\" \"fp\")])\n \n-(define_insn_and_split \"trunctfsf2\"\n+(define_expand \"trunctfsf2\"\n+  [(set (match_operand:SF 0 \"gpc_reg_operand\" \"\")\n+\t(float_truncate:SF (match_operand:TF 1 \"gpc_reg_operand\" \"\")))]\n+  \"!TARGET_IEEEQUAD\n+   && TARGET_HARD_FLOAT\n+   && (TARGET_FPRS || TARGET_E500_DOUBLE)\n+   && TARGET_LONG_DOUBLE_128\"\n+{\n+  if (TARGET_E500_DOUBLE)\n+    emit_insn (gen_spe_trunctfsf2 (operands[0], operands[1]));\n+  else\n+    emit_insn (gen_trunctfsf2_fprs (operands[0], operands[1]));\n+  DONE;\n+})\n+\n+(define_insn_and_split \"trunctfsf2_fprs\"\n   [(set (match_operand:SF 0 \"gpc_reg_operand\" \"=f\")\n \t(float_truncate:SF (match_operand:TF 1 \"gpc_reg_operand\" \"f\")))\n    (clobber (match_scratch:DF 2 \"=f\"))]\n@@ -8643,7 +8679,9 @@\n   [(set (match_operand:TF 0 \"gpc_reg_operand\" \"\")\n         (float:TF (match_operand:SI 1 \"gpc_reg_operand\" \"\")))]\n   \"!TARGET_IEEEQUAD\n-   && TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_LONG_DOUBLE_128\"\n+   && TARGET_HARD_FLOAT\n+   && (TARGET_FPRS || TARGET_E500_DOUBLE)\n+   && TARGET_LONG_DOUBLE_128\"\n {\n   rtx tmp = gen_reg_rtx (DFmode);\n   expand_float (tmp, operands[1], false);\n@@ -8664,6 +8702,22 @@\n    (set_attr \"length\" \"20\")])\n \n (define_expand \"fix_trunctfsi2\"\n+  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"\")\n+\t(fix:SI (match_operand:TF 1 \"gpc_reg_operand\" \"\")))]\n+  \"!TARGET_IEEEQUAD\n+   && (TARGET_POWER2 || TARGET_POWERPC)\n+   && TARGET_HARD_FLOAT\n+   && (TARGET_FPRS || TARGET_E500_DOUBLE)\n+   && TARGET_LONG_DOUBLE_128\"\n+{\n+  if (TARGET_E500_DOUBLE)\n+    emit_insn (gen_spe_fix_trunctfsi2 (operands[0], operands[1]));\n+  else\n+    emit_insn (gen_fix_trunctfsi2_fprs (operands[0], operands[1]));\n+  DONE;\n+})\n+\n+(define_expand \"fix_trunctfsi2_fprs\"\n   [(parallel [(set (match_operand:SI 0 \"gpc_reg_operand\" \"\")\n \t\t   (fix:SI (match_operand:TF 1 \"gpc_reg_operand\" \"\")))\n \t      (clobber (match_dup 2))\n@@ -8705,7 +8759,16 @@\n   DONE;\n })\n \n-(define_insn \"negtf2\"\n+(define_expand \"negtf2\"\n+  [(set (match_operand:TF 0 \"gpc_reg_operand\" \"\")\n+\t(neg:TF (match_operand:TF 1 \"gpc_reg_operand\" \"\")))]\n+  \"!TARGET_IEEEQUAD\n+   && TARGET_HARD_FLOAT\n+   && (TARGET_FPRS || TARGET_E500_DOUBLE)\n+   && TARGET_LONG_DOUBLE_128\"\n+  \"\")\n+\n+(define_insn \"negtf2_internal\"\n   [(set (match_operand:TF 0 \"gpc_reg_operand\" \"=f\")\n \t(neg:TF (match_operand:TF 1 \"gpc_reg_operand\" \"f\")))]\n   \"!TARGET_IEEEQUAD\n@@ -8721,14 +8784,24 @@\n    (set_attr \"length\" \"8\")])\n \n (define_expand \"abstf2\"\n-  [(set (match_operand:TF 0 \"gpc_reg_operand\" \"=f\")\n-\t(abs:TF (match_operand:TF 1 \"gpc_reg_operand\" \"f\")))]\n+  [(set (match_operand:TF 0 \"gpc_reg_operand\" \"\")\n+\t(abs:TF (match_operand:TF 1 \"gpc_reg_operand\" \"\")))]\n   \"!TARGET_IEEEQUAD\n-   && TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_LONG_DOUBLE_128\"\n+   && TARGET_HARD_FLOAT\n+   && (TARGET_FPRS || TARGET_E500_DOUBLE)\n+   && TARGET_LONG_DOUBLE_128\"\n   \"\n {\n   rtx label = gen_label_rtx ();\n-  emit_insn (gen_abstf2_internal (operands[0], operands[1], label));\n+  if (TARGET_E500_DOUBLE)\n+    {\n+      if (flag_unsafe_math_optimizations)\n+\temit_insn (gen_spe_abstf2_tst (operands[0], operands[1], label));\n+      else\n+\temit_insn (gen_spe_abstf2_cmp (operands[0], operands[1], label));\n+    }\n+  else\n+    emit_insn (gen_abstf2_internal (operands[0], operands[1], label));\n   emit_label (label);\n   DONE;\n }\")\n@@ -8761,7 +8834,7 @@\n ; List r->r after r->\"o<>\", otherwise reload will try to reload a\n ; non-offsettable address by using r->r which won't make progress.\n (define_insn \"*movdi_internal32\"\n-  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=o<>,r,r,*f,*f,m,r\")\n+  [(set (match_operand:DI 0 \"rs6000_nonimmediate_operand\" \"=o<>,r,r,*f,*f,m,r\")\n \t(match_operand:DI 1 \"input_operand\" \"r,r,m,f,m,f,IJKnGHF\"))]\n   \"! TARGET_POWERPC64\n    && (gpc_reg_operand (operands[0], DImode)\n@@ -8798,7 +8871,7 @@\n }\")\n \n (define_split\n-  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"\")\n+  [(set (match_operand:DI 0 \"rs6000_nonimmediate_operand\" \"\")\n         (match_operand:DI 1 \"input_operand\" \"\"))]\n   \"reload_completed && !TARGET_POWERPC64\n    && gpr_or_gpr_p (operands[0], operands[1])\""}, {"sha": "d39bcad84d997b374c0c537b43e8ee739043f17a", "filename": "gcc/config/rs6000/spe.md", "status": "modified", "additions": 333, "deletions": 19, "changes": 352, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17caeff2620c89d89ba6b473790b1f82327f6d93/gcc%2Fconfig%2Frs6000%2Fspe.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17caeff2620c89d89ba6b473790b1f82327f6d93/gcc%2Fconfig%2Frs6000%2Fspe.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fspe.md?ref=17caeff2620c89d89ba6b473790b1f82327f6d93", "patch": "@@ -1,5 +1,6 @@\n ;; e500 SPE description\n-;; Copyright (C) 2002, 2003, 2004, 2005 Free Software Foundation, Inc.\n+;; Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007\n+;; Free Software Foundation, Inc.\n ;; Contributed by Aldy Hernandez (aldy@quesejoda.com)\n \n ;; This file is part of GCC.\n@@ -29,12 +30,24 @@\n    (TSTDFGT_GPR\t\t1009)\n    (CMPDFLT_GPR\t\t1010)\n    (TSTDFLT_GPR\t\t1011)\n-   (E500_CR_IOR_COMPARE 1012)\n+   (CMPTFEQ_GPR\t\t1012)\n+   (TSTTFEQ_GPR\t\t1013)\n+   (CMPTFGT_GPR\t\t1014)\n+   (TSTTFGT_GPR\t\t1015)\n+   (CMPTFLT_GPR\t\t1016)\n+   (TSTTFLT_GPR\t\t1017)\n+   (E500_CR_IOR_COMPARE 1018)\n    ])\n \n ;; Modes using a 64-bit register.\n (define_mode_macro SPE64 [DF V4HI V2SF V1DI V2SI])\n \n+;; Likewise, but allow TFmode (two registers) as well.\n+(define_mode_macro SPE64TF [DF V4HI V2SF V1DI V2SI TF])\n+\n+;; DImode and TImode.\n+(define_mode_macro DITI [DI TI])\n+\n (define_insn \"*negsf2_gpr\"\n   [(set (match_operand:SF 0 \"gpc_reg_operand\" \"=r\")\n         (neg:SF (match_operand:SF 1 \"gpc_reg_operand\" \"r\")))]\n@@ -2198,25 +2211,57 @@\n ;; Double-precision floating point instructions.\n \n ;; FIXME: Add o=r option.\n-(define_insn \"*frob_df_di\"\n-  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=r,r\")\n-        (subreg:DF (match_operand:DI 1 \"input_operand\" \"r,m\") 0))]\n+(define_insn \"*frob_<SPE64:mode>_<DITI:mode>\"\n+  [(set (match_operand:SPE64 0 \"nonimmediate_operand\" \"=r,r\")\n+        (subreg:SPE64 (match_operand:DITI 1 \"input_operand\" \"r,m\") 0))]\n+  \"(TARGET_E500_DOUBLE && <SPE64:MODE>mode == DFmode)\n+   || (TARGET_SPE && <SPE64:MODE>mode != DFmode)\"\n+  \"@\n+   evmergelo %0,%1,%L1\n+   evldd%X1 %0,%y1\")\n+\n+(define_insn \"*frob_tf_ti\"\n+  [(set (match_operand:TF 0 \"gpc_reg_operand\" \"=r\")\n+        (subreg:TF (match_operand:TI 1 \"gpc_reg_operand\" \"r\") 0))]\n   \"TARGET_E500_DOUBLE\"\n+  \"evmergelo %0,%1,%L1\\;evmergelo %L0,%Y1,%Z1\")\n+\n+(define_insn \"*frob_<mode>_di_2\"\n+  [(set (subreg:DI (match_operand:SPE64TF 0 \"nonimmediate_operand\" \"+&r,r\") 0)\n+        (match_operand:DI 1 \"input_operand\" \"r,m\"))]\n+  \"(TARGET_E500_DOUBLE && (<MODE>mode == DFmode || <MODE>mode == TFmode))\n+   || (TARGET_SPE && <MODE>mode != DFmode && <MODE>mode != TFmode)\"\n   \"@\n    evmergelo %0,%1,%L1\n    evldd%X1 %0,%y1\")\n \n-(define_insn \"*frob_di_df\"\n-  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=&r\")\n-        (subreg:DI (match_operand:DF 1 \"input_operand\" \"r\") 0))]\n+(define_insn \"*frob_tf_di_8_2\"\n+  [(set (subreg:DI (match_operand:TF 0 \"nonimmediate_operand\" \"+&r,r\") 8)\n+        (match_operand:DI 1 \"input_operand\" \"r,m\"))]\n   \"TARGET_E500_DOUBLE\"\n+  \"@\n+   evmergelo %L0,%1,%L1\n+   evldd%X1 %L0,%y1\")\n+\n+(define_insn \"*frob_di_<mode>\"\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=&r\")\n+        (subreg:DI (match_operand:SPE64TF 1 \"input_operand\" \"r\") 0))]\n+  \"(TARGET_E500_DOUBLE && (<MODE>mode == DFmode || <MODE>mode == TFmode))\n+   || (TARGET_SPE && <MODE>mode != DFmode && <MODE>mode != TFmode)\"\n   \"evmergehi %0,%1,%1\\;mr %L0,%1\"\n   [(set_attr \"length\" \"8\")])\n \n-(define_insn \"*frob_di_df_2\"\n-  [(set (subreg:DF (match_operand:DI 0 \"register_operand\" \"=&r,r\") 0)\n-\t(match_operand:DF 1 \"input_operand\" \"r,m\"))]\n+(define_insn \"*frob_ti_tf\"\n+  [(set (match_operand:TI 0 \"nonimmediate_operand\" \"=&r\")\n+        (subreg:TI (match_operand:TF 1 \"input_operand\" \"r\") 0))]\n   \"TARGET_E500_DOUBLE\"\n+  \"evmergehi %0,%1,%1\\;mr %L0,%1\\;evmergehi %Y0,%L1,%L1\\;mr %Z0,%L1\")\n+\n+(define_insn \"*frob_<DITI:mode>_<SPE64:mode>_2\"\n+  [(set (subreg:SPE64 (match_operand:DITI 0 \"register_operand\" \"+&r,r\") 0)\n+\t(match_operand:SPE64 1 \"input_operand\" \"r,m\"))]\n+  \"(TARGET_E500_DOUBLE && <SPE64:MODE>mode == DFmode)\n+   || (TARGET_SPE && <SPE64:MODE>mode != DFmode)\"\n   \"*\n {\n   switch (which_alternative)\n@@ -2244,10 +2289,43 @@\n }\"\n   [(set_attr \"length\" \"8,8\")])\n \n+; As the above, but TImode at offset 8.\n+(define_insn \"*frob_ti_<mode>_8_2\"\n+  [(set (subreg:SPE64 (match_operand:TI 0 \"register_operand\" \"+&r,r\") 8)\n+\t(match_operand:SPE64 1 \"input_operand\" \"r,m\"))]\n+  \"(TARGET_E500_DOUBLE && <MODE>mode == DFmode)\n+   || (TARGET_SPE && <MODE>mode != DFmode)\"\n+  \"*\n+{\n+  switch (which_alternative)\n+    {\n+    default: \n+      gcc_unreachable ();\n+    case 0:\n+      return \\\"evmergehi %Y0,%1,%1\\;mr %Z0,%1\\\";\n+    case 1:\n+      if (!offsettable_nonstrict_memref_p (operands[1]))\n+\treturn \\\"evldd%X1 %Z0,%y1\\;evmergehi %Y0,%Z0,%Z0\\\";\n+      if (refers_to_regno_p (REGNO (operands[0]), REGNO (operands[0]) + 1,\n+\t\t\t     operands[1], 0))\n+\treturn \\\"{l|lwz} %Z0,%L1\\;{l|lwz} %Y0,%1\\\";\n+      else\n+        return \\\"{l%U1%X1|lwz%U1%X1} %Y0,%1\\;{l|lwz} %Z0,%L1\\\";\n+    }\n+}\"\n+  [(set_attr \"length\" \"8,8\")])\n+\n+(define_insn \"*frob_ti_tf_2\"\n+  [(set (subreg:TF (match_operand:TI 0 \"gpc_reg_operand\" \"=&r\") 0)\n+\t(match_operand:TF 1 \"gpc_reg_operand\" \"r\"))]\n+  \"TARGET_E500_DOUBLE\"\n+  \"evmergehi %0,%1,%1\\;mr %L0,%1\\;evmergehi %Y0,%L1,%L1\\;mr %Z0,%L1\")\n+\n (define_insn \"*mov_si<mode>_e500_subreg0\"\n-  [(set (subreg:SI (match_operand:SPE64 0 \"register_operand\" \"+r,&r\") 0)\n+  [(set (subreg:SI (match_operand:SPE64TF 0 \"register_operand\" \"+r,&r\") 0)\n \t(match_operand:SI 1 \"input_operand\" \"r,m\"))]\n-  \"(TARGET_E500_DOUBLE && <MODE>mode == DFmode) || (TARGET_SPE && <MODE>mode != DFmode)\"\n+  \"(TARGET_E500_DOUBLE && (<MODE>mode == DFmode || <MODE>mode == TFmode))\n+   || (TARGET_SPE && <MODE>mode != DFmode && <MODE>mode != TFmode)\"\n   \"@\n    evmergelo %0,%1,%0\n    evmergelohi %0,%0,%0\\;{l%U1%X1|lwz%U1%X1} %0,%1\\;evmergelohi %0,%0,%0\")\n@@ -2256,28 +2334,63 @@\n ;; the offset.\n (define_insn \"*mov_si<mode>_e500_subreg0_2\"\n   [(set (match_operand:SI 0 \"rs6000_nonimmediate_operand\" \"+r,m\")\n-\t(subreg:SI (match_operand:SPE64 1 \"register_operand\" \"+r,&r\") 0))]\n-  \"(TARGET_E500_DOUBLE && <MODE>mode == DFmode) || (TARGET_SPE && <MODE>mode != DFmode)\"\n+\t(subreg:SI (match_operand:SPE64TF 1 \"register_operand\" \"+r,&r\") 0))]\n+  \"(TARGET_E500_DOUBLE && (<MODE>mode == DFmode || <MODE>mode == TFmode))\n+   || (TARGET_SPE && <MODE>mode != DFmode && <MODE>mode != TFmode)\"\n   \"@\n    evmergehi %0,%0,%1\n    evmergelohi %1,%1,%1\\;{st%U0%X0|stw%U0%X0} %1,%0\")\n \n (define_insn \"*mov_si<mode>_e500_subreg4\"\n-  [(set (subreg:SI (match_operand:SPE64 0 \"register_operand\" \"+r,r\") 4)\n+  [(set (subreg:SI (match_operand:SPE64TF 0 \"register_operand\" \"+r,r\") 4)\n \t(match_operand:SI 1 \"input_operand\" \"r,m\"))]\n-  \"(TARGET_E500_DOUBLE && <MODE>mode == DFmode) || (TARGET_SPE && <MODE>mode != DFmode)\"\n+  \"(TARGET_E500_DOUBLE && (<MODE>mode == DFmode || <MODE>mode == TFmode))\n+   || (TARGET_SPE && <MODE>mode != DFmode && <MODE>mode != TFmode)\"\n   \"@\n    mr %0,%1\n    {l%U1%X1|lwz%U1%X1} %0,%1\")\n \n (define_insn \"*mov_si<mode>_e500_subreg4_2\"\n   [(set (match_operand:SI 0 \"rs6000_nonimmediate_operand\" \"+r,m\")\n-\t(subreg:SI (match_operand:SPE64 1 \"register_operand\" \"r,r\") 4))]\n-  \"(TARGET_E500_DOUBLE && <MODE>mode == DFmode) || (TARGET_SPE && <MODE>mode != DFmode)\"\n+\t(subreg:SI (match_operand:SPE64TF 1 \"register_operand\" \"r,r\") 4))]\n+  \"(TARGET_E500_DOUBLE && (<MODE>mode == DFmode || <MODE>mode == TFmode))\n+   || (TARGET_SPE && <MODE>mode != DFmode && <MODE>mode != TFmode)\"\n   \"@\n    mr %0,%1\n    {st%U0%X0|stw%U0%X0} %1,%0\")\n \n+(define_insn \"*mov_sitf_e500_subreg8\"\n+  [(set (subreg:SI (match_operand:TF 0 \"register_operand\" \"+r,&r\") 8)\n+\t(match_operand:SI 1 \"input_operand\" \"r,m\"))]\n+  \"TARGET_E500_DOUBLE\"\n+  \"@\n+   evmergelo %L0,%1,%L0\n+   evmergelohi %L0,%L0,%L0\\;{l%U1%X1|lwz%U1%X1} %L0,%1\\;evmergelohi %L0,%L0,%L0\")\n+\n+(define_insn \"*mov_sitf_e500_subreg8_2\"\n+  [(set (match_operand:SI 0 \"rs6000_nonimmediate_operand\" \"+r,m\")\n+\t(subreg:SI (match_operand:TF 1 \"register_operand\" \"+r,&r\") 8))]\n+  \"TARGET_E500_DOUBLE\"\n+  \"@\n+   evmergehi %0,%0,%L1\n+   evmergelohi %L1,%L1,%L1\\;{st%U0%X0|stw%U0%X0} %L1,%0\")\n+\n+(define_insn \"*mov_sitf_e500_subreg12\"\n+  [(set (subreg:SI (match_operand:TF 0 \"register_operand\" \"+r,r\") 12)\n+\t(match_operand:SI 1 \"input_operand\" \"r,m\"))]\n+  \"TARGET_E500_DOUBLE\"\n+  \"@\n+   mr %L0,%1\n+   {l%U1%X1|lwz%U1%X1} %L0,%1\")\n+\n+(define_insn \"*mov_sitf_e500_subreg12_2\"\n+  [(set (match_operand:SI 0 \"rs6000_nonimmediate_operand\" \"+r,m\")\n+\t(subreg:SI (match_operand:TF 1 \"register_operand\" \"r,r\") 12))]\n+  \"TARGET_E500_DOUBLE\"\n+  \"@\n+   mr %0,%L1\n+   {st%U0%X0|stw%U0%X0} %L1,%0\")\n+\n ;; FIXME: Allow r=CONST0.\n (define_insn \"*movdf_e500_double\"\n   [(set (match_operand:DF 0 \"rs6000_nonimmediate_operand\" \"=r,r,m\")\n@@ -2354,6 +2467,133 @@\n   \"TARGET_HARD_FLOAT && TARGET_E500_DOUBLE\"\n   \"efddiv %0,%1,%2\")\n \n+;; Double-precision floating point instructions for IBM long double.\n+\n+(define_insn_and_split \"spe_trunctfdf2_internal1\"\n+  [(set (match_operand:DF 0 \"gpc_reg_operand\" \"=r,?r\")\n+\t(float_truncate:DF (match_operand:TF 1 \"gpc_reg_operand\" \"0,r\")))]\n+  \"!TARGET_IEEEQUAD\n+   && TARGET_HARD_FLOAT && TARGET_E500_DOUBLE && TARGET_LONG_DOUBLE_128\"\n+  \"@\n+   #\n+   evor %0,%1,%1\"\n+  \"&& reload_completed && REGNO (operands[0]) == REGNO (operands[1])\"\n+  [(const_int 0)]\n+{\n+  emit_note (NOTE_INSN_DELETED);\n+  DONE;\n+})\n+\n+(define_insn_and_split \"spe_trunctfsf2\"\n+  [(set (match_operand:SF 0 \"gpc_reg_operand\" \"=r\")\n+\t(float_truncate:SF (match_operand:TF 1 \"gpc_reg_operand\" \"r\")))\n+   (clobber (match_scratch:DF 2 \"=r\"))]\n+  \"!TARGET_IEEEQUAD\n+   && TARGET_HARD_FLOAT && TARGET_E500_DOUBLE && TARGET_LONG_DOUBLE_128\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(set (match_dup 2)\n+\t(float_truncate:DF (match_dup 1)))\n+   (set (match_dup 0)\n+\t(float_truncate:SF (match_dup 2)))]\n+  \"\")\n+\n+(define_insn \"spe_extenddftf2\"\n+  [(set (match_operand:TF 0 \"rs6000_nonimmediate_operand\" \"=r,?r,r,o\")\n+\t(float_extend:TF (match_operand:DF 1 \"input_operand\" \"0,r,m,r\")))\n+   (clobber (match_scratch:DF 2 \"=X,X,X,&r\"))]\n+  \"!TARGET_IEEEQUAD\n+   && TARGET_HARD_FLOAT && TARGET_E500_DOUBLE && TARGET_LONG_DOUBLE_128\"\n+  \"@\n+   evxor %L0,%L0,%L0\n+   evor %0,%1,%1\\;evxor %L0,%L0,%L0\n+   evldd%X1 %0,%y1\\;evxor %L0,%L0,%L0\n+   evstdd%X0 %1,%y0\\;evxor %2,%2,%2\\;evstdd %2,%Y0\")\n+\n+(define_expand \"spe_fix_trunctfsi2\"\n+  [(parallel [(set (match_operand:SI 0 \"gpc_reg_operand\" \"\")\n+\t\t   (fix:SI (match_operand:TF 1 \"gpc_reg_operand\" \"\")))\n+\t      (clobber (match_dup 2))\n+\t      (clobber (match_dup 3))\n+\t      (clobber (match_dup 4))])]\n+  \"!TARGET_IEEEQUAD\n+   && TARGET_HARD_FLOAT && TARGET_E500_DOUBLE && TARGET_LONG_DOUBLE_128\"\n+{\n+  operands[2] = gen_reg_rtx (DFmode);\n+  operands[3] = gen_reg_rtx (SImode);\n+  operands[4] = gen_reg_rtx (SImode);\n+})\n+\n+; Like fix_trunc_helper, add with rounding towards 0.\n+(define_insn \"spe_fix_trunctfsi2_internal\"\n+  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r\")\n+        (fix:SI (match_operand:TF 1 \"gpc_reg_operand\" \"r\")))\n+   (clobber (match_operand:DF 2 \"gpc_reg_operand\" \"=r\"))\n+   (clobber (match_operand:SI 3 \"gpc_reg_operand\" \"=&r\"))\n+   (clobber (match_operand:SI 4 \"gpc_reg_operand\" \"=&r\"))]\n+  \"!TARGET_IEEEQUAD\n+   && TARGET_HARD_FLOAT && TARGET_E500_DOUBLE && TARGET_LONG_DOUBLE_128\"\n+  \"mfspefscr %3\\;rlwinm %4,%3,0,0,29\\;ori %4,%4,1\\;efdadd %2,%1,%L1\\;mtspefscr %3\\;efdctsiz %0, %2\")\n+\n+(define_insn \"spe_negtf2_internal\"\n+  [(set (match_operand:TF 0 \"gpc_reg_operand\" \"=r\")\n+\t(neg:TF (match_operand:TF 1 \"gpc_reg_operand\" \"r\")))]\n+  \"!TARGET_IEEEQUAD\n+   && TARGET_HARD_FLOAT && TARGET_E500_DOUBLE && TARGET_LONG_DOUBLE_128\"\n+  \"*\n+{\n+  if (REGNO (operands[0]) == REGNO (operands[1]) + 1)\n+    return \\\"efdneg %L0,%L1\\;efdneg %0,%1\\\";\n+  else\n+    return \\\"efdneg %0,%1\\;efdneg %L0,%L1\\\";\n+}\")\n+\n+(define_expand \"spe_abstf2_cmp\"\n+  [(set (match_operand:TF 0 \"gpc_reg_operand\" \"=f\")\n+\t(match_operand:TF 1 \"gpc_reg_operand\" \"f\"))\n+   (set (match_dup 3) (match_dup 5))\n+   (set (match_dup 5) (abs:DF (match_dup 5)))\n+   (set (match_dup 4) (unspec:CCFP [(compare:CCFP (match_dup 3)\n+                                                  (match_dup 5))] CMPDFEQ_GPR))\n+   (set (pc) (if_then_else (eq (match_dup 4) (const_int 0))\n+\t\t\t   (label_ref (match_operand 2 \"\" \"\"))\n+\t\t\t   (pc)))\n+   (set (match_dup 6) (neg:DF (match_dup 6)))]\n+  \"!TARGET_IEEEQUAD\n+   && TARGET_HARD_FLOAT && TARGET_E500_DOUBLE && TARGET_LONG_DOUBLE_128\"\n+  \"\n+{\n+  const int hi_word = FLOAT_WORDS_BIG_ENDIAN ? 0 : GET_MODE_SIZE (DFmode);\n+  const int lo_word = FLOAT_WORDS_BIG_ENDIAN ? GET_MODE_SIZE (DFmode) : 0;\n+  operands[3] = gen_reg_rtx (DFmode);\n+  operands[4] = gen_reg_rtx (CCFPmode);\n+  operands[5] = simplify_gen_subreg (DFmode, operands[0], TFmode, hi_word);\n+  operands[6] = simplify_gen_subreg (DFmode, operands[0], TFmode, lo_word);\n+}\")\n+\n+(define_expand \"spe_abstf2_tst\"\n+  [(set (match_operand:TF 0 \"gpc_reg_operand\" \"=f\")\n+\t(match_operand:TF 1 \"gpc_reg_operand\" \"f\"))\n+   (set (match_dup 3) (match_dup 5))\n+   (set (match_dup 5) (abs:DF (match_dup 5)))\n+   (set (match_dup 4) (unspec:CCFP [(compare:CCFP (match_dup 3)\n+                                                  (match_dup 5))] TSTDFEQ_GPR))\n+   (set (pc) (if_then_else (eq (match_dup 4) (const_int 0))\n+\t\t\t   (label_ref (match_operand 2 \"\" \"\"))\n+\t\t\t   (pc)))\n+   (set (match_dup 6) (neg:DF (match_dup 6)))]\n+  \"!TARGET_IEEEQUAD\n+   && TARGET_HARD_FLOAT && TARGET_E500_DOUBLE && TARGET_LONG_DOUBLE_128\"\n+  \"\n+{\n+  const int hi_word = FLOAT_WORDS_BIG_ENDIAN ? 0 : GET_MODE_SIZE (DFmode);\n+  const int lo_word = FLOAT_WORDS_BIG_ENDIAN ? GET_MODE_SIZE (DFmode) : 0;\n+  operands[3] = gen_reg_rtx (DFmode);\n+  operands[4] = gen_reg_rtx (CCFPmode);\n+  operands[5] = simplify_gen_subreg (DFmode, operands[0], TFmode, hi_word);\n+  operands[6] = simplify_gen_subreg (DFmode, operands[0], TFmode, lo_word);\n+}\")\n+\n ;; Vector move instructions.\n \n (define_expand \"movv2si\"\n@@ -2803,6 +3043,80 @@\n   \"efdtstlt %0,%1,%2\"\n   [(set_attr \"type\" \"veccmpsimple\")])\n \n+;; Same thing, but for IBM long double.\n+\n+(define_insn \"cmptfeq_gpr\"\n+  [(set (match_operand:CCFP 0 \"cc_reg_operand\" \"=y\")\n+\t(unspec:CCFP\n+\t [(compare:CCFP (match_operand:TF 1 \"gpc_reg_operand\" \"r\")\n+\t\t\t(match_operand:TF 2 \"gpc_reg_operand\" \"r\"))]\n+\t CMPTFEQ_GPR))]\n+  \"!TARGET_IEEEQUAD\n+   && TARGET_HARD_FLOAT && TARGET_E500_DOUBLE && TARGET_LONG_DOUBLE_128\n+   && !flag_unsafe_math_optimizations\"\n+  \"efdcmpeq %0,%1,%2\\;bng %0,$+8\\;efdcmpeq %0,%L1,%L2\"\n+  [(set_attr \"type\" \"veccmp\")])\n+\n+(define_insn \"tsttfeq_gpr\"\n+  [(set (match_operand:CCFP 0 \"cc_reg_operand\" \"=y\")\n+\t(unspec:CCFP\n+\t [(compare:CCFP (match_operand:TF 1 \"gpc_reg_operand\" \"r\")\n+\t\t\t(match_operand:TF 2 \"gpc_reg_operand\" \"r\"))]\n+\t TSTTFEQ_GPR))]\n+  \"!TARGET_IEEEQUAD\n+   && TARGET_HARD_FLOAT && TARGET_E500_DOUBLE && TARGET_LONG_DOUBLE_128\n+   && flag_unsafe_math_optimizations\"\n+  \"efdtsteq %0,%1,%2\\;bng %0,$+8\\;efdtsteq %0,%L1,%L2\"\n+  [(set_attr \"type\" \"veccmpsimple\")])\n+\n+(define_insn \"cmptfgt_gpr\"\n+  [(set (match_operand:CCFP 0 \"cc_reg_operand\" \"=y\")\n+\t(unspec:CCFP\n+\t [(compare:CCFP (match_operand:TF 1 \"gpc_reg_operand\" \"r\")\n+\t\t\t(match_operand:TF 2 \"gpc_reg_operand\" \"r\"))]\n+\t CMPTFGT_GPR))]\n+  \"!TARGET_IEEEQUAD\n+   && TARGET_HARD_FLOAT && TARGET_E500_DOUBLE && TARGET_LONG_DOUBLE_128\n+   && !flag_unsafe_math_optimizations\"\n+  \"efdcmpgt %0,%1,%2\\;bgt %0,$+16\\;efdcmpeq %0,%1,%2\\;bng %0,$+8\\;efdcmpgt %0,%L1,%L2\"\n+  [(set_attr \"type\" \"veccmp\")])\n+\n+(define_insn \"tsttfgt_gpr\"\n+  [(set (match_operand:CCFP 0 \"cc_reg_operand\" \"=y\")\n+\t(unspec:CCFP\n+\t [(compare:CCFP (match_operand:TF 1 \"gpc_reg_operand\" \"r\")\n+\t\t\t(match_operand:TF 2 \"gpc_reg_operand\" \"r\"))]\n+\t TSTTFGT_GPR))]\n+  \"!TARGET_IEEEQUAD\n+   && TARGET_HARD_FLOAT && TARGET_E500_DOUBLE && TARGET_LONG_DOUBLE_128\n+   && flag_unsafe_math_optimizations\"\n+  \"efdtstgt %0,%1,%2\\;bgt %0,$+16\\;efdtsteq %0,%1,%2\\;bng %0,$+8\\;efdtstgt %0,%L1,%L2\"\n+  [(set_attr \"type\" \"veccmpsimple\")])\n+\n+(define_insn \"cmptflt_gpr\"\n+  [(set (match_operand:CCFP 0 \"cc_reg_operand\" \"=y\")\n+\t(unspec:CCFP\n+\t [(compare:CCFP (match_operand:TF 1 \"gpc_reg_operand\" \"r\")\n+\t\t\t(match_operand:TF 2 \"gpc_reg_operand\" \"r\"))]\n+\t CMPTFLT_GPR))]\n+  \"!TARGET_IEEEQUAD\n+   && TARGET_HARD_FLOAT && TARGET_E500_DOUBLE && TARGET_LONG_DOUBLE_128\n+   && !flag_unsafe_math_optimizations\"\n+  \"efdcmplt %0,%1,%2\\;bgt %0,$+16\\;efdcmpeq %0,%1,%2\\;bng %0,$+8\\;efdcmplt %0,%L1,%L2\"\n+  [(set_attr \"type\" \"veccmp\")])\n+\n+(define_insn \"tsttflt_gpr\"\n+  [(set (match_operand:CCFP 0 \"cc_reg_operand\" \"=y\")\n+\t(unspec:CCFP\n+\t [(compare:CCFP (match_operand:TF 1 \"gpc_reg_operand\" \"r\")\n+\t\t\t(match_operand:TF 2 \"gpc_reg_operand\" \"r\"))]\n+\t TSTTFLT_GPR))]\n+  \"!TARGET_IEEEQUAD\n+   && TARGET_HARD_FLOAT && TARGET_E500_DOUBLE && TARGET_LONG_DOUBLE_128\n+   && flag_unsafe_math_optimizations\"\n+  \"efdtstlt %0,%1,%2\\;bgt %0,$+16\\;efdtsteq %0,%1,%2\\;bng %0,$+8\\;efdtstlt %0,%L1,%L2\"\n+  [(set_attr \"type\" \"veccmpsimple\")])\n+\n ;; Like cceq_ior_compare, but compare the GT bits.\n (define_insn \"e500_cr_ior_compare\"\n   [(set (match_operand:CCFP 0 \"cc_reg_operand\" \"=y\")"}, {"sha": "21d32f01e8ad064b18576e6da273139e0043c594", "filename": "libgcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17caeff2620c89d89ba6b473790b1f82327f6d93/libgcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17caeff2620c89d89ba6b473790b1f82327f6d93/libgcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2FChangeLog?ref=17caeff2620c89d89ba6b473790b1f82327f6d93", "patch": "@@ -1,3 +1,7 @@\n+2007-01-23  Joseph Myers  <joseph@codesourcery.com>\n+\n+\t* config/rs6000/t-ldbl128: Always use -mlong-double-128.\n+\n 2007-01-21  Andrew Pinski  <pinskia@gmail.com>\n \n \tPR target/30519"}, {"sha": "bdd62f3cdee6e21c1a55226b036417910b26b702", "filename": "libgcc/config/rs6000/t-ldbl128", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17caeff2620c89d89ba6b473790b1f82327f6d93/libgcc%2Fconfig%2Frs6000%2Ft-ldbl128", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17caeff2620c89d89ba6b473790b1f82327f6d93/libgcc%2Fconfig%2Frs6000%2Ft-ldbl128", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Frs6000%2Ft-ldbl128?ref=17caeff2620c89d89ba6b473790b1f82327f6d93", "patch": "@@ -1,7 +1,3 @@\n SHLIB_MAPFILES += $(gcc_srcdir)/config/rs6000/libgcc-ppc-glibc.ver\n \n-# Use -mlong-double-128 only when not compiling nof libgcc.\n-predefined-macros := $(shell true | $(CC) $(CFLAGS) -x c -dD -E -)\n-ifeq ($(findstring _SOFT_FLOAT,$(predefined-macros)),)\n HOST_LIBGCC2_CFLAGS += -mlong-double-128\n-endif"}]}