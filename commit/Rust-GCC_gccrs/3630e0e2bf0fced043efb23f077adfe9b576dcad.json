{"sha": "3630e0e2bf0fced043efb23f077adfe9b576dcad", "node_id": "C_kwDOANBUbNoAKDM2MzBlMGUyYmYwZmNlZDA0M2VmYjIzZjA3N2FkZmU5YjU3NmRjYWQ", "commit": {"author": {"name": "Arthur Cohen", "email": "arthur.cohen@embecosm.com", "date": "2023-01-11T14:29:22Z"}, "committer": {"name": "Arthur Cohen", "email": "arthur.cohen@embecosm.com", "date": "2023-01-30T12:47:35Z"}, "message": "macro: Allow builtin `MacroInvocation`s within the AST\n\ngcc/rust/ChangeLog:\n\n\t* ast/rust-macro.h (enum class): Add `BuiltinMacro` enum class.\n\t* expand/rust-attribute-visitor.cc (AttrVisitor::visit): Mention\n\tswitching on `macro.kind` once builtin macro invocations are properly\n\thandled.\n\t* parse/rust-parse-impl.h (Parser::parse_macro_invocation): Switch to new MacroInvocation\n\tAPI.\n\t(Parser::parse_type): Likewise.\n\t(Parser::parse_type_no_bounds): Likewise.", "tree": {"sha": "5a00a51378b46a951775a4b1f9aaed22c95e3582", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5a00a51378b46a951775a4b1f9aaed22c95e3582"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3630e0e2bf0fced043efb23f077adfe9b576dcad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3630e0e2bf0fced043efb23f077adfe9b576dcad", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3630e0e2bf0fced043efb23f077adfe9b576dcad", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3630e0e2bf0fced043efb23f077adfe9b576dcad/comments", "author": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "committer": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d12a38da686e39952e083821f1d77116f3ed91af", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d12a38da686e39952e083821f1d77116f3ed91af", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d12a38da686e39952e083821f1d77116f3ed91af"}], "stats": {"total": 182, "additions": 126, "deletions": 56}, "files": [{"sha": "48e4524c590c68b93c1dad76fe40cbabafcdfdf0", "filename": "gcc/rust/ast/rust-macro.h", "status": "modified", "additions": 92, "deletions": 18, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3630e0e2bf0fced043efb23f077adfe9b576dcad/gcc%2Frust%2Fast%2Frust-macro.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3630e0e2bf0fced043efb23f077adfe9b576dcad/gcc%2Frust%2Fast%2Frust-macro.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-macro.h?ref=3630e0e2bf0fced043efb23f077adfe9b576dcad", "patch": "@@ -578,8 +578,30 @@ class MacroRulesDefinition : public VisItem\n   }\n };\n \n+/**\n+ * All builtin macros possible\n+ */\n+enum class BuiltinMacro\n+{\n+  Assert,\n+  File,\n+  Line,\n+  Column,\n+  IncludeBytes,\n+  IncludeStr,\n+  CompileError,\n+  Concat,\n+  Env,\n+  Cfg,\n+  Include\n+};\n+\n /* AST node of a macro invocation, which is replaced by the macro result at\n- * compile time */\n+ * compile time. This is technically a sum-type/tagged-union, which represents\n+ * both classic macro invocations and builtin macro invocations. Regular macro\n+ * invocations are expanded lazily, but builtin macro invocations need to be\n+ * expanded eagerly, hence the differentiation.\n+ */\n class MacroInvocation : public TypeNoBounds,\n \t\t\tpublic Pattern,\n \t\t\tpublic Item,\n@@ -589,26 +611,47 @@ class MacroInvocation : public TypeNoBounds,\n \t\t\tpublic ExternalItem,\n \t\t\tpublic ExprWithoutBlock\n {\n-  std::vector<Attribute> outer_attrs;\n-  MacroInvocData invoc_data;\n-  Location locus;\n-\n-  // Important for when we actually expand the macro\n-  bool is_semi_coloned;\n-\n-  NodeId node_id;\n-\n public:\n+  enum class InvocKind\n+  {\n+    Regular,\n+    Builtin,\n+  };\n+\n   std::string as_string () const override;\n \n-  MacroInvocation (MacroInvocData invoc_data,\n-\t\t   std::vector<Attribute> outer_attrs, Location locus,\n-\t\t   bool is_semi_coloned = false)\n-    : outer_attrs (std::move (outer_attrs)),\n-      invoc_data (std::move (invoc_data)), locus (locus),\n-      is_semi_coloned (is_semi_coloned),\n-      node_id (Analysis::Mappings::get ()->get_next_node_id ())\n-  {}\n+  /**\n+   * The default constructor you should use. Whenever we parse a macro call, we\n+   * cannot possibly know whether or not this call refers to a builtin macro or\n+   * a regular macro. With name resolution and scopes and nested macro calls,\n+   * this is literally impossible. Hence, always start by creating a `Regular`\n+   * MacroInvocation which will then (maybe!) become a `Builtin` macro\n+   * invocation in the expander.\n+   */\n+  static std::unique_ptr<MacroInvocation>\n+  Regular (MacroInvocData invoc_data, std::vector<Attribute> outer_attrs,\n+\t   Location locus, bool is_semi_coloned = false)\n+  {\n+    return std::unique_ptr<MacroInvocation> (\n+      new MacroInvocation (InvocKind::Regular, Optional<BuiltinMacro>::none (),\n+\t\t\t   invoc_data, outer_attrs, locus, is_semi_coloned));\n+  }\n+\n+  /**\n+   * Create a builtin macro invocation. This can only be done after macro\n+   * name-resolution and within the macro expander, so unless you're modifying\n+   * these visitors, you probably do not want to use this function.\n+   */\n+  static std::unique_ptr<MacroInvocation>\n+  Builtin (BuiltinMacro kind, MacroInvocData invoc_data,\n+\t   std::vector<Attribute> outer_attrs, Location locus,\n+\t   bool is_semi_coloned = false)\n+  {\n+    return std::unique_ptr<MacroInvocation> (\n+      new MacroInvocation (InvocKind::Builtin,\n+\t\t\t   Optional<BuiltinMacro>::some (kind), invoc_data,\n+\t\t\t   outer_attrs, locus, is_semi_coloned));\n+  }\n \n   Location get_locus () const override final { return locus; }\n \n@@ -642,6 +685,37 @@ class MacroInvocation : public TypeNoBounds,\n \n   bool has_semicolon () const { return is_semi_coloned; }\n \n+  InvocKind get_kind () const { return kind; }\n+  Optional<BuiltinMacro> get_builtin_kind () const { return builtin_kind; }\n+\n+private:\n+  /* Full constructor */\n+  MacroInvocation (InvocKind kind, Optional<BuiltinMacro> builtin_kind,\n+\t\t   MacroInvocData invoc_data,\n+\t\t   std::vector<Attribute> outer_attrs, Location locus,\n+\t\t   bool is_semi_coloned)\n+    : outer_attrs (std::move (outer_attrs)), locus (locus),\n+      node_id (Analysis::Mappings::get ()->get_next_node_id ()),\n+      invoc_data (std::move (invoc_data)), is_semi_coloned (is_semi_coloned),\n+      kind (kind), builtin_kind (builtin_kind)\n+  {}\n+\n+  std::vector<Attribute> outer_attrs;\n+  Location locus;\n+  NodeId node_id;\n+\n+  /* The data given to the macro invocation */\n+  MacroInvocData invoc_data;\n+\n+  /* Important for when we actually expand the macro */\n+  bool is_semi_coloned;\n+\n+  /* Is this a builtin macro or a regular macro */\n+  InvocKind kind;\n+\n+  /* If it is a builtin macro, which one */\n+  Optional<BuiltinMacro> builtin_kind = Optional<BuiltinMacro>::none ();\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */"}, {"sha": "82580740901ffcaffca9726a79c21abbfdff7ce0", "filename": "gcc/rust/expand/rust-attribute-visitor.cc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3630e0e2bf0fced043efb23f077adfe9b576dcad/gcc%2Frust%2Fexpand%2Frust-attribute-visitor.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3630e0e2bf0fced043efb23f077adfe9b576dcad/gcc%2Frust%2Fexpand%2Frust-attribute-visitor.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-attribute-visitor.cc?ref=3630e0e2bf0fced043efb23f077adfe9b576dcad", "patch": "@@ -389,6 +389,8 @@ AttrVisitor::visit (AST::ConstGenericParam &)\n void\n AttrVisitor::visit (AST::MacroInvocation &macro_invoc)\n {\n+  // FIXME: Probably need to check macro_invoc.kind\n+\n   // initial strip test based on outer attrs\n   expander.expand_cfg_attrs (macro_invoc.get_outer_attrs ());\n   if (expander.fails_cfg_with_expand (macro_invoc.get_outer_attrs ()))"}, {"sha": "7e4e7947e0291083cd6c97f8052f1549ebe3e871", "filename": "gcc/rust/parse/rust-parse-impl.h", "status": "modified", "additions": 32, "deletions": 38, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3630e0e2bf0fced043efb23f077adfe9b576dcad/gcc%2Frust%2Fparse%2Frust-parse-impl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3630e0e2bf0fced043efb23f077adfe9b576dcad/gcc%2Frust%2Fparse%2Frust-parse-impl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fparse%2Frust-parse-impl.h?ref=3630e0e2bf0fced043efb23f077adfe9b576dcad", "patch": "@@ -1752,10 +1752,9 @@ Parser<ManagedTokenSource>::parse_macro_invocation_semi (\n \t    {\n \t      // as this is the end, allow recovery (probably) - may change\n \n-\t      return std::unique_ptr<AST::MacroInvocation> (\n-\t\tnew AST::MacroInvocation (std::move (invoc_data),\n-\t\t\t\t\t  std::move (outer_attrs), macro_locus,\n-\t\t\t\t\t  true));\n+\t      return AST::MacroInvocation::Regular (std::move (invoc_data),\n+\t\t\t\t\t\t    std::move (outer_attrs),\n+\t\t\t\t\t\t    macro_locus, true);\n \t    }\n \t}\n \n@@ -1764,9 +1763,9 @@ Parser<ManagedTokenSource>::parse_macro_invocation_semi (\n \t\t  t->get_token_description (),\n \t\t  lexer.peek_token ()->get_token_description ());\n \n-      return std::unique_ptr<AST::MacroInvocation> (\n-\tnew AST::MacroInvocation (std::move (invoc_data),\n-\t\t\t\t  std::move (outer_attrs), macro_locus, true));\n+      return AST::MacroInvocation::Regular (std::move (invoc_data),\n+\t\t\t\t\t    std::move (outer_attrs),\n+\t\t\t\t\t    macro_locus, true);\n     }\n   else\n     {\n@@ -1814,10 +1813,9 @@ Parser<ManagedTokenSource>::parse_macro_invocation (AST::AttrVec outer_attrs)\n \n   Location macro_locus = macro_path.get_locus ();\n \n-  return std::unique_ptr<AST::MacroInvocation> (\n-    new AST::MacroInvocation (AST::MacroInvocData (std::move (macro_path),\n-\t\t\t\t\t\t   std::move (delim_tok_tree)),\n-\t\t\t      std::move (outer_attrs), macro_locus));\n+  return AST::MacroInvocation::Regular (\n+    AST::MacroInvocData (std::move (macro_path), std::move (delim_tok_tree)),\n+    std::move (outer_attrs), macro_locus);\n }\n \n // Parses a macro rule definition - does not parse semicolons.\n@@ -9308,11 +9306,10 @@ Parser<ManagedTokenSource>::parse_type (bool save_errors)\n \n \t      AST::DelimTokenTree tok_tree = parse_delim_token_tree ();\n \n-\t      return std::unique_ptr<AST::MacroInvocation> (\n-\t\tnew AST::MacroInvocation (\n-\t\t  AST::MacroInvocData (std::move (macro_path),\n-\t\t\t\t       std::move (tok_tree)),\n-\t\t  {}, locus));\n+\t      return AST::MacroInvocation::Regular (\n+\t\tAST::MacroInvocData (std::move (macro_path),\n+\t\t\t\t     std::move (tok_tree)),\n+\t\t{}, locus);\n \t    }\n \t    case PLUS: {\n \t      // type param bounds\n@@ -10146,11 +10143,10 @@ Parser<ManagedTokenSource>::parse_type_no_bounds ()\n \n \t      AST::DelimTokenTree tok_tree = parse_delim_token_tree ();\n \n-\t      return std::unique_ptr<AST::MacroInvocation> (\n-\t\tnew AST::MacroInvocation (\n-\t\t  AST::MacroInvocData (std::move (macro_path),\n-\t\t\t\t       std::move (tok_tree)),\n-\t\t  {}, locus));\n+\t      return AST::MacroInvocation::Regular (\n+\t\tAST::MacroInvocData (std::move (macro_path),\n+\t\t\t\t     std::move (tok_tree)),\n+\t\t{}, locus);\n \t    }\n \t  default:\n \t    // assume that this is a type path and not an error\n@@ -12010,18 +12006,17 @@ Parser<ManagedTokenSource>::parse_path_based_stmt_or_expr (\n \t      {\n \t\tlexer.skip_token ();\n \n-\t\tstd::unique_ptr<AST::MacroInvocation> stmt (\n-\t\t  new AST::MacroInvocation (std::move (invoc_data),\n-\t\t\t\t\t    std::move (outer_attrs),\n-\t\t\t\t\t    stmt_or_expr_loc, true));\n+\t\tauto stmt\n+\t\t  = AST::MacroInvocation::Regular (std::move (invoc_data),\n+\t\t\t\t\t\t   std::move (outer_attrs),\n+\t\t\t\t\t\t   stmt_or_expr_loc, true);\n \t\treturn ExprOrStmt (std::move (stmt));\n \t      }\n \n \t    // otherwise, create macro invocation\n-\t    std::unique_ptr<AST::MacroInvocation> expr (\n-\t      new AST::MacroInvocation (std::move (invoc_data),\n-\t\t\t\t\tstd::move (outer_attrs),\n-\t\t\t\t\tstmt_or_expr_loc, false));\n+\t    auto expr = AST::MacroInvocation::Regular (std::move (invoc_data),\n+\t\t\t\t\t\t       std::move (outer_attrs),\n+\t\t\t\t\t\t       stmt_or_expr_loc, false);\n \t    return ExprOrStmt (std::move (expr));\n \t  }\n \telse\n@@ -12330,17 +12325,16 @@ Parser<ManagedTokenSource>::parse_macro_invocation_maybe_semi (\n \t{\n \t  lexer.skip_token ();\n \n-\t  std::unique_ptr<AST::MacroInvocation> stmt (\n-\t    new AST::MacroInvocation (std::move (invoc_data),\n-\t\t\t\t      std::move (outer_attrs), macro_locus,\n-\t\t\t\t      true));\n+\t  auto stmt = AST::MacroInvocation::Regular (std::move (invoc_data),\n+\t\t\t\t\t\t     std::move (outer_attrs),\n+\t\t\t\t\t\t     macro_locus, true);\n \t  return ExprOrStmt (std::move (stmt));\n \t}\n \n       // otherwise, create macro invocation\n-      std::unique_ptr<AST::MacroInvocation> expr (\n-\tnew AST::MacroInvocation (std::move (invoc_data),\n-\t\t\t\t  std::move (outer_attrs), macro_locus));\n+      auto expr\n+\t= AST::MacroInvocation::Regular (std::move (invoc_data),\n+\t\t\t\t\t std::move (outer_attrs), macro_locus);\n       return ExprOrStmt (std::move (expr));\n     }\n   else\n@@ -14546,9 +14540,9 @@ Parser<ManagedTokenSource>::parse_macro_invocation_partial (\n \n   Location macro_locus = converted_path.get_locus ();\n \n-  return std::unique_ptr<AST::MacroInvocation> (new AST::MacroInvocation (\n+  return AST::MacroInvocation::Regular (\n     AST::MacroInvocData (std::move (converted_path), std::move (tok_tree)),\n-    std::move (outer_attrs), macro_locus, restrictions.expr_can_be_stmt));\n+    std::move (outer_attrs), macro_locus, restrictions.expr_can_be_stmt);\n }\n \n /* Parses a struct expr struct with a path in expression already parsed (but"}]}