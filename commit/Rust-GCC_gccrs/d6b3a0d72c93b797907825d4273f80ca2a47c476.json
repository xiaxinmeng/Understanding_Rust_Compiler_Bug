{"sha": "d6b3a0d72c93b797907825d4273f80ca2a47c476", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDZiM2EwZDcyYzkzYjc5NzkwNzgyNWQ0MjczZjgwY2EyYTQ3YzQ3Ng==", "commit": {"author": {"name": "Mikael Morin", "email": "mikael@gcc.gnu.org", "date": "2011-11-03T23:34:53Z"}, "committer": {"name": "Mikael Morin", "email": "mikael@gcc.gnu.org", "date": "2011-11-03T23:34:53Z"}, "message": "trans-array.c (get_array_ref_dim, [...]): Rename the former to the latter and loop over the parents.\n\n\t* trans-array.c (get_array_ref_dim, get_scalarizer_dim_for_array_dim): \n\tRename the former to the latter and loop over the parents.\n\t(innermost_ss): New function.\n\t(get_array_ref_dim_for_loop_dim): New function.\n\t(gfc_trans_create_temp_array): Use get_scalarizer_dim_for_array_dim.\n\t(set_loop_bounds): Use get_array_dim_for_loop_dim).\n\nFrom-SVN: r180894", "tree": {"sha": "07f69e1fa33fd33afdc525918b96ff935d464520", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/07f69e1fa33fd33afdc525918b96ff935d464520"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d6b3a0d72c93b797907825d4273f80ca2a47c476", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d6b3a0d72c93b797907825d4273f80ca2a47c476", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d6b3a0d72c93b797907825d4273f80ca2a47c476", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d6b3a0d72c93b797907825d4273f80ca2a47c476/comments", "author": null, "committer": null, "parents": [{"sha": "4d6a0e363750d2e9289ca6297db798eac74e41bb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d6a0e363750d2e9289ca6297db798eac74e41bb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4d6a0e363750d2e9289ca6297db798eac74e41bb"}], "stats": {"total": 71, "additions": 57, "deletions": 14}, "files": [{"sha": "e802754b18c8d50f1a9f68551e2bb2463f8eb452", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6b3a0d72c93b797907825d4273f80ca2a47c476/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6b3a0d72c93b797907825d4273f80ca2a47c476/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=d6b3a0d72c93b797907825d4273f80ca2a47c476", "patch": "@@ -1,3 +1,12 @@\n+2011-11-03  Mikael Morin  <mikael@gcc.gnu.org>\n+\n+\t* trans-array.c (get_array_ref_dim, get_scalarizer_dim_for_array_dim): \n+\tRename the former to the latter and loop over the parents.\n+\t(innermost_ss): New function.\n+\t(get_array_ref_dim_for_loop_dim): New function.\n+\t(gfc_trans_create_temp_array): Use get_scalarizer_dim_for_array_dim.\n+\t(set_loop_bounds): Use get_array_dim_for_loop_dim).\n+\n 2011-11-03  Mikael Morin  <mikael@gcc.gnu.org>\n \n \t* trans.h (struct gfc_ss): New field nested_ss."}, {"sha": "d918fa820093edb19f100364faafd4f4839083e8", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 48, "deletions": 14, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6b3a0d72c93b797907825d4273f80ca2a47c476/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6b3a0d72c93b797907825d4273f80ca2a47c476/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=d6b3a0d72c93b797907825d4273f80ca2a47c476", "patch": "@@ -868,28 +868,62 @@ gfc_trans_allocate_array_storage (stmtblock_t * pre, stmtblock_t * post,\n }\n \n \n-/* Get the array reference dimension corresponding to the given loop dimension.\n-   It is different from the true array dimension given by the dim array in\n-   the case of a partial array reference\n-   It is different from the loop dimension in the case of a transposed array.\n-   */\n+/* Get the scalarizer array dimension corresponding to actual array dimension\n+   given by ARRAY_DIM.\n+\n+   For example, if SS represents the array ref a(1,:,:,1), it is a\n+   bidimensional scalarizer array, and the result would be 0 for ARRAY_DIM=1,\n+   and 1 for ARRAY_DIM=2.\n+   If SS represents transpose(a(:,1,1,:)), it is again a bidimensional\n+   scalarizer array, and the result would be 1 for ARRAY_DIM=0 and 0 for\n+   ARRAY_DIM=3.\n+   If SS represents sum(a(:,:,:,1), dim=1), it is a 2+1-dimensional scalarizer\n+   array.  If called on the inner ss, the result would be respectively 0,1,2 for\n+   ARRAY_DIM=0,1,2.  If called on the outer ss, the result would be 0,1\n+   for ARRAY_DIM=1,2.  */\n \n static int\n-get_array_ref_dim (gfc_ss *ss, int loop_dim)\n+get_scalarizer_dim_for_array_dim (gfc_ss *ss, int array_dim)\n {\n-  int n, array_dim, array_ref_dim;\n+  int array_ref_dim;\n+  int n;\n \n   array_ref_dim = 0;\n-  array_dim = ss->dim[loop_dim];\n \n-  for (n = 0; n < ss->dimen; n++)\n-    if (ss->dim[n] < array_dim)\n-      array_ref_dim++;\n+  for (; ss; ss = ss->parent)\n+    for (n = 0; n < ss->dimen; n++)\n+      if (ss->dim[n] < array_dim)\n+\tarray_ref_dim++;\n \n   return array_ref_dim;\n }\n \n \n+static gfc_ss *\n+innermost_ss (gfc_ss *ss)\n+{\n+  while (ss->nested_ss != NULL)\n+    ss = ss->nested_ss;\n+\n+  return ss;\n+}\n+\n+\n+\n+/* Get the array reference dimension corresponding to the given loop dimension.\n+   It is different from the true array dimension given by the dim array in\n+   the case of a partial array reference (i.e. a(:,:,1,:) for example)\n+   It is different from the loop dimension in the case of a transposed array.\n+   */\n+\n+static int\n+get_array_ref_dim_for_loop_dim (gfc_ss *ss, int loop_dim)\n+{\n+  return get_scalarizer_dim_for_array_dim (innermost_ss (ss),\n+\t\t\t\t\t   ss->dim[loop_dim]);\n+}\n+\n+\n /* Generate code to create and initialize the descriptor for a temporary\n    array.  This is used for both temporaries needed by the scalarizer, and\n    functions returning arrays.  Adjusts the loop variables to be\n@@ -959,7 +993,7 @@ gfc_trans_create_temp_array (stmtblock_t * pre, stmtblock_t * post, gfc_ss * ss,\n \t to the n'th dimension of the array. We need to reconstruct loop infos\n \t in the right order before using it to set the descriptor\n \t bounds.  */\n-      tmp_dim = get_array_ref_dim (ss, n);\n+      tmp_dim = get_scalarizer_dim_for_array_dim (ss, dim);\n       from[tmp_dim] = loop->from[n];\n       to[tmp_dim] = loop->to[n];\n \n@@ -1011,7 +1045,7 @@ gfc_trans_create_temp_array (stmtblock_t * pre, stmtblock_t * post, gfc_ss * ss,\n     {\n       for (n = 0; n < loop->dimen; n++)\n \t{\n-\t  dim = ss->dim[n];\n+\t  dim = get_scalarizer_dim_for_array_dim (ss, ss->dim[n]);\n \n \t  /* For a callee allocated array express the loop bounds in terms\n \t     of the descriptor fields.  */\n@@ -4126,7 +4160,7 @@ set_loop_bounds (gfc_loopinfo *loop)\n \t  && INTEGER_CST_P (info->stride[dim]))\n \t{\n \t  loop->from[n] = info->start[dim];\n-\t  mpz_set (i, cshape[get_array_ref_dim (loopspec[n], n)]);\n+\t  mpz_set (i, cshape[get_array_ref_dim_for_loop_dim (loopspec[n], n)]);\n \t  mpz_sub_ui (i, i, 1);\n \t  /* To = from + (size - 1) * stride.  */\n \t  tmp = gfc_conv_mpz_to_tree (i, gfc_index_integer_kind);"}]}