{"sha": "20bbd3cd53a80ddafa56a5d21337aae0c24f94ca", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjBiYmQzY2Q1M2E4MGRkYWZhNTZhNWQyMTMzN2FhZTBjMjRmOTRjYQ==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@cygnus.com", "date": "1999-11-01T23:15:51Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "1999-11-01T23:15:51Z"}, "message": "Merged GC 5.0alpha4 with local changes, plus:\n\n\t* Makefile.in: Rebuilt.\n\t* Makefile.am (gctest_LDADD): Added THREADLIB.\n\t(TESTS): New macro.\n\t* configure: Rebuilt.\n\t* configure.in (INCLUDES): New subst.\n\nFrom-SVN: r30332", "tree": {"sha": "9c24ba1ebabff472b9caddbff07ef957dbf2c24c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9c24ba1ebabff472b9caddbff07ef957dbf2c24c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/20bbd3cd53a80ddafa56a5d21337aae0c24f94ca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/20bbd3cd53a80ddafa56a5d21337aae0c24f94ca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/20bbd3cd53a80ddafa56a5d21337aae0c24f94ca", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/20bbd3cd53a80ddafa56a5d21337aae0c24f94ca/comments", "author": null, "committer": null, "parents": [{"sha": "c05ddfa745d68f6d9db1a7d0992650a41986d376", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c05ddfa745d68f6d9db1a7d0992650a41986d376", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c05ddfa745d68f6d9db1a7d0992650a41986d376"}], "stats": {"total": 5668, "additions": 3741, "deletions": 1927}, "files": [{"sha": "225a1ed49984565b34ca067bd0ff50ec508adae1", "filename": "boehm-gc/BCC_MAKEFILE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20bbd3cd53a80ddafa56a5d21337aae0c24f94ca/boehm-gc%2FBCC_MAKEFILE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20bbd3cd53a80ddafa56a5d21337aae0c24f94ca/boehm-gc%2FBCC_MAKEFILE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2FBCC_MAKEFILE?ref=20bbd3cd53a80ddafa56a5d21337aae0c24f94ca", "patch": "@@ -39,7 +39,7 @@ OBJS= $(XXXOBJS:XXX=)\n \r\n all: gctest.exe cord\\de.exe test_cpp.exe\r\n \r\n-$(OBJS) test.obj: gc_priv.h gc_hdrs.h gc.h config.h MAKEFILE\r\n+$(OBJS) test.obj: gc_priv.h gc_hdrs.h gc.h gcconfig.h MAKEFILE\r\n \r\n gc.lib: $(OBJS)\r\n     -del gc.lib\r"}, {"sha": "b4e4175176c26330c00d53530f5af6321102de42", "filename": "boehm-gc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20bbd3cd53a80ddafa56a5d21337aae0c24f94ca/boehm-gc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20bbd3cd53a80ddafa56a5d21337aae0c24f94ca/boehm-gc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2FChangeLog?ref=20bbd3cd53a80ddafa56a5d21337aae0c24f94ca", "patch": "@@ -1,3 +1,11 @@\n+1999-11-01  Tom Tromey  <tromey@cygnus.com>\n+\n+\t* Makefile.in: Rebuilt.\n+\t* Makefile.am (gctest_LDADD): Added THREADLIB.\n+\t(TESTS): New macro.\n+\t* configure: Rebuilt.\n+\t* configure.in (INCLUDES): New subst.\n+\n 1999-09-29  Steve Chamberlain  <sac@pobox.com>\n \n \t* config.h: Added picoJava target."}, {"sha": "54a06ce38815a7706030cc7c309d88e434fea9b2", "filename": "boehm-gc/EMX_MAKEFILE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20bbd3cd53a80ddafa56a5d21337aae0c24f94ca/boehm-gc%2FEMX_MAKEFILE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20bbd3cd53a80ddafa56a5d21337aae0c24f94ca/boehm-gc%2FEMX_MAKEFILE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2FEMX_MAKEFILE?ref=20bbd3cd53a80ddafa56a5d21337aae0c24f94ca", "patch": "@@ -72,7 +72,7 @@ SPECIALCFLAGS =\n all: gc.a gctest.exe\n \n $(OBJS) test.o: $(srcdir)/gc_priv.h $(srcdir)/gc_hdrs.h $(srcdir)/gc.h \\\n-    $(srcdir)/config.h $(srcdir)/gc_typed.h\n+    $(srcdir)/gcconfig.h $(srcdir)/gc_typed.h\n # The dependency on Makefile is needed.  Changing\n # options such as -DSILENT affects the size of GC_arrays,\n # invalidating all .o files that rely on gc_priv.h"}, {"sha": "cc12cd15d988c8665caf0c358fc18cb84ecd9a76", "filename": "boehm-gc/MacOS.c", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20bbd3cd53a80ddafa56a5d21337aae0c24f94ca/boehm-gc%2FMacOS.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20bbd3cd53a80ddafa56a5d21337aae0c24f94ca/boehm-gc%2FMacOS.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2FMacOS.c?ref=20bbd3cd53a80ddafa56a5d21337aae0c24f94ca", "patch": "@@ -135,3 +135,20 @@ void GC_MacFreeTemporaryMemory()\n #       endif\n     }\n }\n+\n+#if __option(far_data)\n+\n+  void* GC_MacGetDataEnd()\n+  {\n+\tCodeZeroHandle code0 = (CodeZeroHandle)GetResource('CODE', 0);\n+\tif (code0) {\n+\t\tlong aboveA5Size = (**code0).aboveA5;\n+\t\tReleaseResource((Handle)code0);\n+\t\treturn (LMGetCurrentA5() + aboveA5Size);\n+\t}\n+\tfprintf(stderr, \"Couldn't load the jump table.\");\n+\texit(-1);\n+\treturn 0;\n+  }\n+\n+#endif /* __option(far_data) */"}, {"sha": "6ab97ff2612c2a2135e8c10ef1b4d4452235324d", "filename": "boehm-gc/Makefile.am", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20bbd3cd53a80ddafa56a5d21337aae0c24f94ca/boehm-gc%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20bbd3cd53a80ddafa56a5d21337aae0c24f94ca/boehm-gc%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2FMakefile.am?ref=20bbd3cd53a80ddafa56a5d21337aae0c24f94ca", "patch": "@@ -46,8 +46,9 @@ AM_CFLAGS = @BOEHM_GC_CFLAGS@\n \n check_PROGRAMS = gctest\n gctest_SOURCES = test.c\n-gctest_LDADD = ./libgcjgc.la\n+gctest_LDADD = ./libgcjgc.la $(THREADLIB)\n \n+TESTS = gctest\n \n ## FIXME: relies on internal code generated by automake.\n all_objs = @addobjs@ $(libgcjgc_la_OBJECTS)"}, {"sha": "54f77db9f6689d0f7e97e8dcaacef133d0b61faf", "filename": "boehm-gc/Makefile.dj", "status": "modified", "additions": 242, "deletions": 102, "changes": 344, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20bbd3cd53a80ddafa56a5d21337aae0c24f94ca/boehm-gc%2FMakefile.dj", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20bbd3cd53a80ddafa56a5d21337aae0c24f94ca/boehm-gc%2FMakefile.dj", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2FMakefile.dj?ref=20bbd3cd53a80ddafa56a5d21337aae0c24f94ca", "patch": "@@ -7,15 +7,23 @@\n #      \t and runs some tests of collector and cords.  Does not add cords or\n #\t c++ interface to gc.a\n # cord/de$(EXE_SUFFIX) - builds dumb editor based on cords.\n-CC=gcc\n-CXX=gcc -x c++\n-CXXLD=gxx\n-RM=rm -f\n-MV=mv\n+ABI_FLAG=\n+CC=gcc $(ABI_FLAG)\n+CXX=gxx $(ABI_FLAG)\n+AS=gcc -c -x assembler-with-cpp $(ABI_FLAG)\n+#  The above doesn't work with gas, which doesn't run cpp.\n+#  Define AS as `gcc -c -x assembler-with-cpp' instead.\n+#  Under Irix 6, you will have to specify the ABI (-o32, -n32, or -64)\n+#  if you use something other than the default ABI on your machine.\n+\n+# special defines for DJGPP\n+CXXLD=gxx $(ABI_FLAG)\n EXE_SUFFIX=.exe\n-RANLIB=ranlib\n \n-CFLAGS= -O -DNO_SIGNALS -DALL_INTERIOR_POINTERS -DSILENT -DATOMIC_UNCOLLECTABLE\n+CFLAGS= -O -DATOMIC_UNCOLLECTABLE -DNO_SIGNALS -DALL_INTERIOR_POINTERS -DNO_EXECUTE_PERMISSION -DSILENT\n+\n+# For dynamic library builds, it may be necessary to add flags to generate\n+# PIC code, e.g. -fPIC on Linux.\n \n # Setjmp_test may yield overly optimistic results when compiled\n # without optimization.\n@@ -29,8 +37,12 @@ CFLAGS= -O -DNO_SIGNALS -DALL_INTERIOR_POINTERS -DSILENT -DATOMIC_UNCOLLECTABLE\n # -DSOLARIS_THREADS enables support for Solaris (thr_) threads.\n #   (Clients should also define SOLARIS_THREADS and then include\n #   gc.h before performing thr_ or dl* or GC_ operations.)\n-#   This is broken on nonSPARC machines.\n+#   Must also define -D_REENTRANT.\n+# -D_SOLARIS_PTHREADS enables support for Solaris pthreads.\n+#   Define SOLARIS_THREADS as well.\n # -DIRIX_THREADS enables support for Irix pthreads.  See README.irix.\n+# -DLINUX_THREADS enables support for Xavier Leroy's Linux threads.\n+#   see README.linux.  -D_REENTRANT may also be required.\n # -DALL_INTERIOR_POINTERS allows all pointers to the interior\n #   of objects to be recognized.  (See gc_priv.h for consequences.)\n # -DSMALL_CONFIG tries to tune the collector for small heap sizes,\n@@ -78,9 +90,34 @@ CFLAGS= -O -DNO_SIGNALS -DALL_INTERIOR_POINTERS -DSILENT -DATOMIC_UNCOLLECTABLE\n #   in a sepearte postpass, and hence their memory won't be reclaimed.\n #   Not recommended unless you are implementing a language that specifies\n #   these semantics.\n+# -DFINALIZE_ON_DEMAND causes finalizers to be run only in response\n+#   to explicit GC_invoke_finalizers() calls.\n # -DATOMIC_UNCOLLECTABLE includes code for GC_malloc_atomic_uncollectable.\n #   This is useful if either the vendor malloc implementation is poor,\n #   or if REDIRECT_MALLOC is used.\n+# -DHBLKSIZE=ddd, where ddd is a power of 2 between 512 and 16384, explicitly\n+#   sets the heap block size.  Each heap block is devoted to a single size and\n+#   kind of object.  For the incremental collector it makes sense to match\n+#   the most likely page size.  Otherwise large values result in more\n+#   fragmentation, but generally better performance for large heaps.\n+# -DUSE_MMAP use MMAP instead of sbrk to get new memory.\n+#   Works for Solaris and Irix.\n+# -DMMAP_STACKS (for Solaris threads) Use mmap from /dev/zero rather than\n+#   GC_scratch_alloc() to get stack memory.\n+# -DPRINT_BLACK_LIST Whenever a black list entry is added, i.e. whenever\n+#   the garbage collector detects a value that looks almost, but not quite,\n+#   like a pointer, print both the address containing the value, and the\n+#   value of the near-bogus-pointer.  Can be used to identifiy regions of\n+#   memory that are likely to contribute misidentified pointers.\n+# -DOLD_BLOCK_ALLOC Use the old, possibly faster, large block\n+#   allocation strategy.  The new strategy tries harder to minimize\n+#   fragmentation, sometimes at the expense of spending more time in the\n+#   large block allocator and/or collecting more frequently.\n+#   If you expect the allocator to promtly use an explicitly expanded\n+#   heap, this is highly recommended.\n+#\n+\n+\n \n LIBGC_CFLAGS= -O -DNO_SIGNALS -DSILENT \\\n     -DREDIRECT_MALLOC=GC_malloc_uncollectable \\\n@@ -98,26 +135,27 @@ RANLIB= ranlib\n srcdir = .\n VPATH = $(srcdir)\n \n-OBJS= alloc.o reclaim.o allchblk.o misc.o mach_dep.o os_dep.o mark_rts.o headers.o mark.o obj_map.o blacklst.o finalize.o new_hblk.o dbg_mlc.o malloc.o stubborn.o checksums.o solaris_threads.o irix_threads.o typd_mlc.o ptr_chck.o mallocx.o\n+OBJS= alloc.o reclaim.o allchblk.o misc.o mach_dep.o os_dep.o mark_rts.o headers.o mark.o obj_map.o blacklst.o finalize.o new_hblk.o dbg_mlc.o malloc.o stubborn.o checksums.o solaris_threads.o irix_threads.o linux_threads.o typd_mlc.o ptr_chck.o mallocx.o solaris_pthreads.o\n \n-CSRCS= reclaim.c allchblk.c misc.c alloc.c mach_dep.c os_dep.c mark_rts.c headers.c mark.c obj_map.c pcr_interface.c blacklst.c finalize.c new_hblk.c real_malloc.c dyn_load.c dbg_mlc.c malloc.c stubborn.c checksums.c solaris_threads.c irix_threads.c typd_mlc.c ptr_chck.c mallocx.c\n+CSRCS= reclaim.c allchblk.c misc.c alloc.c mach_dep.c os_dep.c mark_rts.c headers.c mark.c obj_map.c pcr_interface.c blacklst.c finalize.c new_hblk.c real_malloc.c dyn_load.c dbg_mlc.c malloc.c stubborn.c checksums.c solaris_threads.c irix_threads.c linux_threads.c typd_mlc.c ptr_chck.c mallocx.c solaris_pthreads.c\n \n CORD_SRCS=  cord/cordbscs.c cord/cordxtra.c cord/cordprnt.c cord/de.c cord/cordtest.c cord/cord.h cord/ec.h cord/private/cord_pos.h cord/de_win.c cord/de_win.h cord/de_cmds.h cord/de_win.ICO cord/de_win.RC cord/SCOPTIONS.amiga cord/SMakefile.amiga\n \n CORD_OBJS=  cord/cordbscs.o cord/cordxtra.o cord/cordprnt.o\n \n SRCS= $(CSRCS) mips_sgi_mach_dep.s rs6000_mach_dep.s alpha_mach_dep.s \\\n     sparc_mach_dep.s gc.h gc_typed.h gc_hdrs.h gc_priv.h gc_private.h \\\n-    config.h gc_mark.h include/gc_inl.h include/gc_inline.h gc.man \\\n+    gcconfig.h gc_mark.h include/gc_inl.h include/gc_inline.h gc.man \\\n     threadlibs.c if_mach.c if_not_there.c gc_cpp.cc gc_cpp.h weakpointer.h \\\n     gcc_support.c mips_ultrix_mach_dep.s include/gc_alloc.h gc_alloc.h \\\n-    $(CORD_SRCS)\n+    include/new_gc_alloc.h include/javaxfc.h sparc_sunos4_mach_dep.s \\\n+    solaris_threads.h $(CORD_SRCS)\n \n OTHER_FILES= Makefile PCR-Makefile OS2_MAKEFILE NT_MAKEFILE BCC_MAKEFILE \\\n            README test.c test_cpp.cc setjmp_t.c SMakefile.amiga \\\n            SCoptions.amiga README.amiga README.win32 cord/README \\\n            cord/gc.h include/gc.h include/gc_typed.h include/cord.h \\\n-           include/ec.h include/private/cord_pos.h include/private/config.h \\\n+           include/ec.h include/private/cord_pos.h include/private/gcconfig.h \\\n            include/private/gc_hdrs.h include/private/gc_priv.h \\\n \t   include/gc_cpp.h README.rs6000 \\\n            include/weakpointer.h README.QUICK callprocs pc_excludes \\\n@@ -126,12 +164,14 @@ OTHER_FILES= Makefile PCR-Makefile OS2_MAKEFILE NT_MAKEFILE BCC_MAKEFILE \\\n            include/gc_cpp.h Mac_files/datastart.c Mac_files/dataend.c \\\n            Mac_files/MacOS_config.h Mac_files/MacOS_Test_config.h \\\n            add_gc_prefix.c README.solaris2 README.sgi README.hp README.uts \\\n-\t   win32_threads.c NT_THREADS_MAKEFILE gc.mak README.dj Makefile.dj\n+\t   win32_threads.c NT_THREADS_MAKEFILE gc.mak README.dj Makefile.dj \\\n+\t   README.alpha README.linux version.h Makefile.DLLs \\\n+\t   WCC_MAKEFILE\n \n CORD_INCLUDE_FILES= $(srcdir)/gc.h $(srcdir)/cord/cord.h $(srcdir)/cord/ec.h \\\n            $(srcdir)/cord/private/cord_pos.h\n \n-UTILS= if_mach$(EXE_SUFFIX) if_not_there$(EXE_SUFFIX) threadlibs$(EXE_SUFFIX)\n+UTILS= if_mach$(EXE_SUFFIX) if_not_there$(EXE_SUFFIX)\n \n # Libraries needed for curses applications.  Only needed for de.\n CURSES= -lcurses -ltermlib\n@@ -149,12 +189,12 @@ SPECIALCFLAGS =\n \n all: gc.a gctest$(EXE_SUFFIX)\n \n-pcr: PCR-Makefile gc_private.h gc_hdrs.h gc.h config.h mach_dep.o $(SRCS)\n+pcr: PCR-Makefile gc_private.h gc_hdrs.h gc.h gcconfig.h mach_dep.o $(SRCS)\n \tmake -f PCR-Makefile depend\n \tmake -f PCR-Makefile\n \n $(OBJS) test.o dyn_load.o dyn_load_sunos53.o: $(srcdir)/gc_priv.h $(srcdir)/gc_hdrs.h $(srcdir)/gc.h \\\n-    $(srcdir)/config.h $(srcdir)/gc_typed.h Makefile\n+    $(srcdir)/gcconfig.h $(srcdir)/gc_typed.h Makefile\n # The dependency on Makefile is needed.  Changing\n # options such as -DSILENT affects the size of GC_arrays,\n # invalidating all .o files that rely on gc_priv.h\n@@ -163,128 +203,160 @@ mark.o typd_mlc.o finalize.o: $(srcdir)/gc_mark.h\n \n base_lib gc.a: $(OBJS) dyn_load.o $(UTILS)\n \techo > base_lib\n-\t$(RM) on_sparc_sunos5\n-\t./if_mach SPARC SUNOS5 touch on_sparc_sunos5\n+\trm -f on_sparc_sunos5_1\n+\t./if_mach SPARC SUNOS5 touch on_sparc_sunos5_1\n \t./if_mach SPARC SUNOS5 $(AR) rus gc.a $(OBJS) dyn_load.o\n-\t./if_not_there on_sparc_sunos5 $(AR) ru gc.a $(OBJS) dyn_load.o\n-\t-./if_not_there on_sparc_sunos5 $(RANLIB) gc.a\n+\t./if_not_there on_sparc_sunos5_1 $(AR) ru gc.a $(OBJS) dyn_load.o\n+\t-./if_not_there on_sparc_sunos5_1 $(RANLIB) gc.a\n #\tignore ranlib failure; that usually means it doesn't exist, and isn't needed\n \n-libgc.a: \n-\tmake CFLAGS=\"$(LIBGC_CFLAGS)\" clean gc.a gcc_support.o\n-\t$(MV) gc.a libgc.a\n-\t-$(RM) on_sparc_sunos5\n-\t./if_mach SPARC SUNOS5 touch on_sparc_sunos5\n-\t./if_mach SPARC SUNOS5 $(AR) rus libgc.a gcc_support.o\n-\t./if_not_there on_sparc_sunos5 $(AR) ru libgc.a gcc_support.o\n-\t-./if_not_there on_sparc_sunos5 $(RANLIB) libgc.a\n-\n cords: $(CORD_OBJS) cord/cordtest$(EXE_SUFFIX) $(UTILS)\n-\t-$(RM) on_sparc_sunos5\n-\t./if_mach SPARC SUNOS5 touch on_sparc_sunos5\n+\trm -f on_sparc_sunos5_3\n+\t./if_mach SPARC SUNOS5 touch on_sparc_sunos5_3\n \t./if_mach SPARC SUNOS5 $(AR) rus gc.a $(CORD_OBJS)\n-\t./if_not_there on_sparc_sunos5 $(AR) ru gc.a $(CORD_OBJS)\n-\t-./if_not_there on_sparc_sunos5 $(RANLIB) gc.a\n+\t./if_not_there on_sparc_sunos5_3 $(AR) ru gc.a $(CORD_OBJS)\n+\t-./if_not_there on_sparc_sunos5_3 $(RANLIB) gc.a\n \n gc_cpp.o: $(srcdir)/gc_cpp.cc $(srcdir)/gc_cpp.h $(srcdir)/gc.h Makefile\n \t$(CXX) -c $(CXXFLAGS) $(srcdir)/gc_cpp.cc\n \n-test_cpp: $(srcdir)/test_cpp.cc $(srcdir)/gc_cpp.h gc_cpp.o $(srcdir)/gc.h \\\n+test_cpp$(EXE_SUFFIX): $(srcdir)/test_cpp.cc $(srcdir)/gc_cpp.h gc_cpp.o $(srcdir)/gc.h \\\n base_lib $(UTILS)\n-\t-$(RM) test_cpp test_cpp$(EXE_SUFFIX)\n+\trm -f test_cpp test_cpp$(EXE_SUFFIX)\n \t./if_mach HP_PA \"\" $(CXX) $(CXXFLAGS) -o test_cpp $(srcdir)/test_cpp.cc gc_cpp.o gc.a -ldld\n-\t./if_not_there test_cpp$(EXE_SUFFIX) $(CXXLD) $(CXXFLAGS) -o test_cpp $(srcdir)/test_cpp.cc gc_cpp.o gc.a\n-\t$(RM) test_cpp\n-\n-c++: gc_cpp.o $(srcdir)/gc_cpp.h test_cpp\n-\t-$(RM) on_sparc_sunos5\n-\t$(AR) ru gc.a gc_cpp.o\n-\t$(RANLIB) gc.a\n+\t./if_not_there test_cpp$(EXE_SUFFIX) $(CXXLD) $(CXXFLAGS) -o test_cpp$(EXE_SUFFIX) $(srcdir)/test_cpp.cc gc_cpp.o gc.a\n+\trm -f test_cpp\n+\n+c++: gc_cpp.o $(srcdir)/gc_cpp.h test_cpp$(EXE_SUFFIX)\n+\trm -f on_sparc_sunos5_4\n+\t./if_mach SPARC SUNOS5 touch on_sparc_sunos5_4\n+\t./if_mach SPARC SUNOS5 $(AR) rus gc.a gc_cpp.o\n+\t./if_not_there on_sparc_sunos5_4 $(AR) ru gc.a gc_cpp.o\n+\t-./if_not_there on_sparc_sunos5_4 $(RANLIB) gc.a\n \t./test_cpp$(EXE_SUFFIX) 1\n \techo > c++\n \n dyn_load_sunos53.o: dyn_load.c\n \t$(CC) $(CFLAGS) -DSUNOS53_SHARED_LIB -c $(srcdir)/dyn_load.c -o $@\n \n-mach_dep.o: $(srcdir)/mach_dep.c\n-\t-$(RM) mach_dep.o\n-\t$(CC) -c $(SPECIALCFLAGS) $(srcdir)/mach_dep.c\n-\n-mark_rts.o: $(srcdir)/mark_rts.c\n-\t-$(RM) mark_rts.o\n-\t$(CC) -c $(CFLAGS) $(srcdir)/mark_rts.c\n+# SunOS5 shared library version of the collector\n+sunos5gc.so: $(OBJS) dyn_load_sunos53.o\n+\t$(CC) -G -o sunos5gc.so $(OBJS) dyn_load_sunos53.o -ldl\n+\tln sunos5gc.so libgc.so\n+\n+# Alpha/OSF shared library version of the collector\n+libalphagc.so: $(OBJS)\n+\tld -shared -o libalphagc.so $(OBJS) dyn_load.o -lc\n+\tln libalphagc.so libgc.so\n+\n+# IRIX shared library version of the collector\n+libirixgc.so: $(OBJS) dyn_load.o\n+\tld -shared $(ABI_FLAG) -o libirixgc.so $(OBJS) dyn_load.o -lc\n+\tln libirixgc.so libgc.so\n+\n+# Linux shared library version of the collector\n+liblinuxgc.so: $(OBJS) dyn_load.o\n+\tgcc -shared -o liblinuxgc.so $(OBJS) dyn_load.o -lo\n+\tln liblinuxgc.so libgc.so\n+\n+mach_dep.o: $(srcdir)/mach_dep.c $(srcdir)/mips_sgi_mach_dep.s $(srcdir)/mips_ultrix_mach_dep.s $(srcdir)/rs6000_mach_dep.s $(UTILS)\n+\trm -f mach_dep.o\n+\t./if_mach MIPS IRIX5 $(AS) -o mach_dep.o $(srcdir)/mips_sgi_mach_dep.s\n+\t./if_mach MIPS RISCOS $(AS) -o mach_dep.o $(srcdir)/mips_ultrix_mach_dep.s\n+\t./if_mach MIPS ULTRIX $(AS) -o mach_dep.o $(srcdir)/mips_ultrix_mach_dep.s\n+\t./if_mach RS6000 \"\" $(AS) -o mach_dep.o $(srcdir)/rs6000_mach_dep.s\n+\t./if_mach ALPHA \"\" $(AS) -o mach_dep.o $(srcdir)/alpha_mach_dep.s\n+\t./if_mach SPARC SUNOS5 $(AS) -o mach_dep.o $(srcdir)/sparc_mach_dep.s\n+\t./if_mach SPARC SUNOS4 $(AS) -o mach_dep.o $(srcdir)/sparc_sunos4_mach_dep.s\n+\t./if_not_there mach_dep.o $(CC) -c $(SPECIALCFLAGS) $(srcdir)/mach_dep.c\n+\n+mark_rts.o: $(srcdir)/mark_rts.c if_mach if_not_there $(UTILS)\n+\trm -f mark_rts.o\n+\t-./if_mach ALPHA OSF1 $(CC) -c $(CFLAGS) -Wo,-notail $(srcdir)/mark_rts.c\n+\t./if_not_there mark_rts.o $(CC) -c $(CFLAGS) $(srcdir)/mark_rts.c\n+#\tWork-around for DEC optimizer tail recursion elimination bug.\n+#  The ALPHA-specific line should be removed if gcc is used.\n+\n+alloc.o: version.h\n \n cord/cordbscs.o: $(srcdir)/cord/cordbscs.c $(CORD_INCLUDE_FILES)\n-\t$(CC) $(CFLAGS) -c $(srcdir)/cord/cordbscs.c\n-\t$(MV) cordbscs.o cord/cordbscs.o\n+\t$(CC) $(CFLAGS) -c -I$(srcdir) $(srcdir)/cord/cordbscs.c\n+\tmv cordbscs.o cord/cordbscs.o\n #  not all compilers understand -o filename\n \n cord/cordxtra.o: $(srcdir)/cord/cordxtra.c $(CORD_INCLUDE_FILES)\n-\t$(CC) $(CFLAGS) -c $(srcdir)/cord/cordxtra.c\n-\t$(MV) cordxtra.o cord/cordxtra.o\n+\t$(CC) $(CFLAGS) -c -I$(srcdir) $(srcdir)/cord/cordxtra.c\n+\tmv cordxtra.o cord/cordxtra.o\n \n cord/cordprnt.o: $(srcdir)/cord/cordprnt.c $(CORD_INCLUDE_FILES)\n-\t$(CC) $(CFLAGS) -c $(srcdir)/cord/cordprnt.c\n-\t$(MV) cordprnt.o cord/cordprnt.o\n-\n-cord/cordtest$(EXE_SUFFIX): $(srcdir)/cord/cordtest.c $(CORD_OBJS) gc.a $(UTILS)\n-\t-$(RM) cord/cordtest$(EXE_SUFFIX)\n-\t$(CC) $(CFLAGS) -o cordtest $(srcdir)/cord/cordtest.c\\\n-\t\t $(CORD_OBJS) gc.a\n-\t./if_not_there cord/cordtest$(EXE_SUFFIX) \\\n-\t\t$(MV) cordtest$(EXE_SUFFIX) cord/cordtest$(EXE_SUFFIX)\n-\n-cord/de$(EXE_SUFFIX): $(srcdir)/cord/de.c cord/cordbscs.o cord/cordxtra.o gc.a\n-\t-$(RM) cord/de$(EXE_SUFFIX)\n-\t./if_mach SPARC DRSNX $(CC) $(CFLAGS) -o cord/de $(srcdir)/cord/de.c\\\n-cord/cordbscs.o cord/cordxtra.o gc.a $(CURSES) -lucb\n-\t./if_mach HP_PA \"\" $(CC) $(CFLAGS) -o cord/de $(srcdir)/cord/de.c\\\n-cord/cordbscs.o cord/cordxtra.o gc.a $(CURSES) -ldld\n-\t./if_mach RS6000 \"\" $(CC) $(CFLAGS) -o cord/de $(srcdir)/cord/de.c\\\n-cord/cordbscs.o cord/cordxtra.o gc.a -lcurses\n-\t./if_mach I386 LINUX $(CC) $(CFLAGS) -o cord/de $(srcdir)/cord/de.c\\\n-cord/cordbscs.o cord/cordxtra.o gc.a -lcurses\n-\t./if_not_there cord/de $(CC) $(CFLAGS) -o cord/de $(srcdir)/cord/de.c\\\n-cord/cordbscs.o cord/cordxtra.o gc.a $(CURSES)\n-\t./if_not_there cord/de$(EXE_SUFFIX) \\\n-\t\t$(MV) de$(EXE_SUFFIX) cord/de$(EXE_SUFFIX)\n-\n-if_mach$(EXE_SUFFIX): $(srcdir)/if_mach.c $(srcdir)/config.h\n+\t$(CC) $(CFLAGS) -c -I$(srcdir) $(srcdir)/cord/cordprnt.c\n+\tmv cordprnt.o cord/cordprnt.o\n+\n+cord/cordtest$(EXE_SUFFIX): $(srcdir)/cord/cordtest.c $(CORD_OBJS) gc.a $(UTILS) /tmp\n+\trm -f cord/cordtest$(EXE_SUFFIX)\n+\t./if_mach SPARC DRSNX $(CC) $(CFLAGS) -o cord/cordtest$(EXE_SUFFIX) $(srcdir)/cord/cordtest.c $(CORD_OBJS) gc.a -lucb\n+\t./if_mach HP_PA \"\" $(CC) $(CFLAGS) -o cord/cordtest$(EXE_SUFFIX) $(srcdir)/cord/cordtest.c $(CORD_OBJS) gc.a -ldld\n+\t./if_not_there cord/cordtest$(EXE_SUFFIX) $(CC) $(CFLAGS) -o cord/cordtest $(srcdir)/cord/cordtest.c $(CORD_OBJS) gc.a\n+\trm -f cord/cordtest cordtest\n+\t-mv cordtest$(EXE_SUFFIX) cord/\n+\n+/tmp: $(UTILS)\n+\t./if_not_there /tmp mkdir /tmp\n+\n+cord/de$(EXE_SUFFIX): $(srcdir)/cord/de.c cord/cordbscs.o cord/cordxtra.o gc.a $(UTILS)\n+\trm -f cord/de cord/de$(EXE_SUFFIX)\n+\t./if_mach SPARC DRSNX $(CC) $(CFLAGS) -o cord/de $(srcdir)/cord/de.c cord/cordbscs.o cord/cordxtra.o gc.a $(CURSES) -lucb `./threadlibs`\n+\t./if_mach HP_PA \"\" $(CC) $(CFLAGS) -o cord/de $(srcdir)/cord/de.c cord/cordbscs.o cord/cordxtra.o gc.a $(CURSES) -ldld\n+\t./if_mach RS6000 \"\" $(CC) $(CFLAGS) -o cord/de $(srcdir)/cord/de.c cord/cordbscs.o cord/cordxtra.o gc.a -lcurses\n+\t./if_mach I386 LINUX $(CC) $(CFLAGS) -o cord/de $(srcdir)/cord/de.c cord/cordbscs.o cord/cordxtra.o gc.a -lcurses `./threadlibs`\n+\t./if_mach ALPHA LINUX $(CC) $(CFLAGS) -o cord/de $(srcdir)/cord/de.c cord/cordbscs.o cord/cordxtra.o gc.a -lcurses\n+\t./if_not_there cord/de$(EXE_SUFFIX) $(CC) $(CFLAGS) -o cord/de$(EXE_SUFFIX) $(srcdir)/cord/de.c cord/cordbscs.o cord/cordxtra.o gc.a $(CURSES)\n+\n+if_mach$(EXE_SUFFIX): $(srcdir)/if_mach.c $(srcdir)/gcconfig.h\n+\trm -f if_mach if_mach$(EXE_SUFFIX)\n \t$(CC) $(CFLAGS) -o if_mach $(srcdir)/if_mach.c\n-\t-$(RM) if_mach\n+\trm -f if_mach\n \n-threadlibs$(EXE_SUFFIX): $(srcdir)/threadlibs.c $(srcdir)/config.h Makefile\n+threadlibs$(EXE_SUFFIX): $(srcdir)/threadlibs.c $(srcdir)/gcconfig.h Makefile\n+\trm -f threadlibs threadlibs$(EXE_SUFFIX)\n \t$(CC) $(CFLAGS) -o threadlibs $(srcdir)/threadlibs.c\n-\t-$(RM) threadlibs\n+\trm -f threadlibs\n \n if_not_there$(EXE_SUFFIX): $(srcdir)/if_not_there.c\n+\trm -f if_not_there if_not_there$(EXE_SUFFIX)\n \t$(CC) $(CFLAGS) -o if_not_there $(srcdir)/if_not_there.c\n-\t-$(RM) if_not_there\n-\n-clean:\n-\t-$(RM) gc.a *.o\n-\t-$(RM) *.o\n-\t-$(RM) gctest gctest_dyn_link test_cpp \\\n-\t      setjmp_test  mon.out gmon.out a.out core if_not_there if_mach \\\n-\t      $(CORD_OBJS) cordtest cord/cordtest de cord/de\n-\t-$(RM) gctest$(EXE_SUFFIX) gctest_dyn_link$(EXE_SUFFIX) test_cpp$(EXE_SUFFIX) \\\n-\t      setjmp_test$(EXE_SUFFIX) if_not_there$(EXE_SUFFIX) if_mach$(EXE_SUFFIX) \\\n-\t      cord/cordtest$(EXE_SUFFIX)\n-\t-$(RM) *~\n-\n-gctest$(EXE_SUFFIX): test.o gc.a\n-\t-$(RM) gctest$(EXE_SUFFIX)\n-\t$(CC) $(CFLAGS) -o gctest test.o gc.a\n-\t$(RM) gctest\n+\trm -f if_not_there\n+\n+# Clean removes *.o several times,\n+# because as the first one doesn't seem to get them all!\n+clean: \n+\trm -f gc.a *.o\n+\trm -f *.o\n+\trm -f *.o\n+\trm -f cord/*.o\n+\trm -f gctest gctest_dyn_link test_cpp\n+\trm -f setjmp_test  mon.out gmon.out a.out core if_not_there if_mach\n+\trm -f threadlibs $(CORD_OBJS) cordtest cord/cordtest de cord/de\n+\trm -f gctest$(EXE_SUFFIX) gctest_dyn_link$(EXE_SUFFIX) test_cpp$(EXE_SUFFIX)\n+\trm -f setjmp_test$(EXE_SUFFIX) if_not_there$(EXE_SUFFIX) if_mach$(EXE_SUFFIX)\n+\trm -f threadlibs$(EXE_SUFFIX) cord/cordtest$(EXE_SUFFIX)\n+\t-rm -f *~\n+\n+gctest$(EXE_SUFFIX): test.o gc.a if_mach$(EXE_SUFFIX) if_not_there$(EXE_SUFFIX)\n+\trm -f gctest gctest$(EXE_SUFFIX)\n+\t./if_mach SPARC DRSNX $(CC) $(CFLAGS) -o gctest  test.o gc.a -lucb\n+\t./if_mach HP_PA \"\" $(CC) $(CFLAGS) -o gctest  test.o gc.a -ldld\n+\t./if_not_there gctest$(EXE_SUFFIX) $(CC) $(CFLAGS) -o gctest$(EXE_SUFFIX) test.o gc.a\n+\trm -f gctest\n \n # If an optimized setjmp_test generates a segmentation fault,\n # odds are your compiler is broken.  Gctest may still work.\n # Try compiling setjmp_t.c unoptimized.\n setjmp_test$(EXE_SUFFIX): $(srcdir)/setjmp_t.c $(srcdir)/gc.h \\\n \t\tif_mach$(EXE_SUFFIX) if_not_there$(EXE_SUFFIX)\n-\t-$(RM) setjmp_test$(EXE_SUFFIX)\n+\trm -f setjmp_test$(EXE_SUFFIX)\n \t$(CC) $(CFLAGS) -o setjmp_test $(srcdir)/setjmp_t.c\n-\t$(RM) setjmp_test\n+\trm -f setjmp_test\n \n test:  KandRtest cord/cordtest$(EXE_SUFFIX)\n \t./cord/cordtest$(EXE_SUFFIX)\n@@ -294,3 +366,71 @@ KandRtest: setjmp_test$(EXE_SUFFIX) gctest$(EXE_SUFFIX)\n \t./setjmp_test$(EXE_SUFFIX)\n \t./gctest$(EXE_SUFFIX)\n \n+add_gc_prefix$(EXE_SUFFIX): add_gc_prefix.c\n+\t$(CC) -o add_gc_prefix$(EXE_SUFFIX) $(srcdir)/add_gc_prefix.c\n+\trm -f add_gc_prefix\n+\n+gc.tar: $(SRCS) $(OTHER_FILES) add_gc_prefix\n+\t./add_gc_prefix$(EXE_SUFFIX) $(SRCS) $(OTHER_FILES) > /tmp/gc.tar-files\n+\t(cd $(srcdir)/.. ; tar cvfh - `cat /tmp/gc.tar-files`) > gc.tar\n+\n+pc_gc.tar: $(SRCS) $(OTHER_FILES)\n+\ttar cvfX pc_gc.tar pc_excludes $(SRCS) $(OTHER_FILES)\n+\n+floppy: pc_gc.tar\n+\t-mmd a:/cord\n+\t-mmd a:/cord/private\n+\t-mmd a:/include\n+\t-mmd a:/include/private\n+\tmkdir /tmp/pc_gc\n+\tcat pc_gc.tar | (cd /tmp/pc_gc; tar xvf -)\n+\t-mcopy -tmn /tmp/pc_gc/* a:\n+\t-mcopy -tmn /tmp/pc_gc/cord/* a:/cord\n+\t-mcopy -mn /tmp/pc_gc/cord/de_win.ICO a:/cord\n+\t-mcopy -tmn /tmp/pc_gc/cord/private/* a:/cord/private\n+\t-mcopy -tmn /tmp/pc_gc/include/* a:/include\n+\t-mcopy -tmn /tmp/pc_gc/include/private/* a:/include/private\n+\trm -r /tmp/pc_gc\n+\n+gc.tar.Z: gc.tar\n+\tcompress gc.tar\n+\n+gc.tar.gz: gc.tar\n+\tgzip gc.tar\n+\n+lint: $(CSRCS) test.c\n+\tlint -DLINT $(CSRCS) test.c | egrep -v \"possible pointer alignment problem|abort|exit|sbrk|mprotect|syscall\"\n+\n+# BTL: added to test shared library version of collector.\n+# Currently works only under SunOS5.  Requires GC_INIT call from statically\n+# loaded client code.\n+ABSDIR = `pwd`\n+gctest_dyn_link: test.o libgc.so\n+\t$(CC) -L$(ABSDIR) -R$(ABSDIR) -o gctest_dyn_link test.o -lgc -ldl -lthread\n+\n+gctest_irix_dyn_link: test.o libirixgc.so\n+\t$(CC) -L$(ABSDIR) -o gctest_irix_dyn_link test.o -lirixgc\n+\n+test_dll.o: test.c libgc_globals.h\n+\t$(CC) $(CFLAGS) -DGC_USE_DLL -c test.c -o test_dll.o\n+\n+test_dll: test_dll.o libgc_dll.a libgc.dll\n+\t$(CC) test_dll.o -L$(ABSDIR) -lgc_dll -o test_dll\n+\n+SYM_PREFIX-libgc=GC\n+\n+# Uncomment the following line to build a GNU win32 DLL\n+# include Makefile.DLLs\n+\n+reserved_namespace: $(SRCS)\n+\tfor file in $(SRCS) test.c test_cpp.cc; do \\\n+\t\tsed s/GC_/_GC_/g < $$file > tmp; \\\n+\t\tcp tmp $$file; \\\n+\t\tdone\n+\n+user_namespace: $(SRCS)\n+\tfor file in $(SRCS) test.c test_cpp.cc; do \\\n+\t\tsed s/_GC_/GC_/g < $$file > tmp; \\\n+\t\tcp tmp $$file; \\\n+\t\tdone\n+"}, {"sha": "3e5b4a6aee593ef2d7d593cba06a05f594d32e68", "filename": "boehm-gc/Makefile.in", "status": "modified", "additions": 35, "deletions": 6, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20bbd3cd53a80ddafa56a5d21337aae0c24f94ca/boehm-gc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20bbd3cd53a80ddafa56a5d21337aae0c24f94ca/boehm-gc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2FMakefile.in?ref=20bbd3cd53a80ddafa56a5d21337aae0c24f94ca", "patch": "@@ -84,6 +84,7 @@ NM = @NM@\n OBJDUMP = @OBJDUMP@\n PACKAGE = @PACKAGE@\n RANLIB = @RANLIB@\n+THREADLIB = @THREADLIB@\n VERSION = @VERSION@\n addobjs = @addobjs@\n boehm_gc_basedir = @boehm_gc_basedir@\n@@ -131,7 +132,9 @@ AM_CFLAGS = @BOEHM_GC_CFLAGS@\n \n check_PROGRAMS = gctest\n gctest_SOURCES = test.c\n-gctest_LDADD = ./libgcjgc.la\n+gctest_LDADD = ./libgcjgc.la $(THREADLIB)\n+\n+TESTS = gctest\n \n all_objs = @addobjs@ $(libgcjgc_la_OBJECTS)\n \n@@ -400,11 +403,37 @@ distdir: $(DISTFILES)\n \t    || cp -p $$d/$$file $(distdir)/$$file || :; \\\n \t  fi; \\\n \tdone\n+check-TESTS: $(TESTS)\n+\t@failed=0; all=0; \\\n+\tsrcdir=$(srcdir); export srcdir; \\\n+\tfor tst in $(TESTS); do \\\n+\t  if test -f $$tst; then dir=.; \\\n+\t  else dir=\"$(srcdir)\"; fi; \\\n+\t  if $(TESTS_ENVIRONMENT) $$dir/$$tst; then \\\n+\t    all=`expr $$all + 1`; \\\n+\t    echo \"PASS: $$tst\"; \\\n+\t  elif test $$? -ne 77; then \\\n+\t    all=`expr $$all + 1`; \\\n+\t    failed=`expr $$failed + 1`; \\\n+\t    echo \"FAIL: $$tst\"; \\\n+\t  fi; \\\n+\tdone; \\\n+\tif test \"$$failed\" -eq 0; then \\\n+\t  banner=\"All $$all tests passed\"; \\\n+\telse \\\n+\t  banner=\"$$failed of $$all tests failed\"; \\\n+\tfi; \\\n+\tdashes=`echo \"$$banner\" | sed s/./=/g`; \\\n+\techo \"$$dashes\"; \\\n+\techo \"$$banner\"; \\\n+\techo \"$$dashes\"; \\\n+\ttest \"$$failed\" -eq 0\n info-am:\n info: info-am\n dvi-am:\n dvi: dvi-am\n check-am: $(check_PROGRAMS)\n+\t$(MAKE) $(AM_MAKEFLAGS) check-TESTS\n check: check-am\n installcheck-am:\n installcheck: installcheck-am\n@@ -477,11 +506,11 @@ maintainer-clean-compile mostlyclean-libtool distclean-libtool \\\n clean-libtool maintainer-clean-libtool mostlyclean-checkPROGRAMS \\\n distclean-checkPROGRAMS clean-checkPROGRAMS \\\n maintainer-clean-checkPROGRAMS tags mostlyclean-tags distclean-tags \\\n-clean-tags maintainer-clean-tags distdir info-am info dvi-am dvi check \\\n-check-am installcheck-am installcheck install-info-am install-info \\\n-install-exec-am install-exec install-data-am install-data install-am \\\n-install uninstall-am uninstall all-redirect all-am all installdirs \\\n-mostlyclean-generic distclean-generic clean-generic \\\n+clean-tags maintainer-clean-tags distdir check-TESTS info-am info \\\n+dvi-am dvi check check-am installcheck-am installcheck install-info-am \\\n+install-info install-exec-am install-exec install-data-am install-data \\\n+install-am install uninstall-am uninstall all-redirect all-am all \\\n+installdirs mostlyclean-generic distclean-generic clean-generic \\\n maintainer-clean-generic clean mostlyclean distclean maintainer-clean\n \n $(all_objs) : config.h gc_priv.h gc_hdrs.h gc.h gc_mark.h"}, {"sha": "1eae36725569152a535fc8574f34eb276269dd82", "filename": "boehm-gc/PCR-Makefile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20bbd3cd53a80ddafa56a5d21337aae0c24f94ca/boehm-gc%2FPCR-Makefile", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20bbd3cd53a80ddafa56a5d21337aae0c24f94ca/boehm-gc%2FPCR-Makefile", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2FPCR-Makefile?ref=20bbd3cd53a80ddafa56a5d21337aae0c24f94ca", "patch": "@@ -59,7 +59,7 @@ mach_dep.o: mach_dep.c mips_mach_dep.s rs6000_mach_dep.s if_mach if_not_there\n \t./if_mach SPARC SUNOS5 as -o mach_dep.o sparc_mach_dep.s\n \t./if_not_there mach_dep.o $(CC) -c $(SPECIALCFLAGS) mach_dep.c\n \n-if_mach: if_mach.c config.h\n+if_mach: if_mach.c gcconfig.h\n \t$(CC) $(CFLAGS) -o if_mach if_mach.c\n \n if_not_there: if_not_there.c"}, {"sha": "4461e303102ea566c64b0a39787ea7643f0c7abe", "filename": "boehm-gc/README", "status": "modified", "additions": 173, "deletions": 17, "changes": 190, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20bbd3cd53a80ddafa56a5d21337aae0c24f94ca/boehm-gc%2FREADME", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20bbd3cd53a80ddafa56a5d21337aae0c24f94ca/boehm-gc%2FREADME", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2FREADME?ref=20bbd3cd53a80ddafa56a5d21337aae0c24f94ca", "patch": "@@ -1,6 +1,7 @@\n Copyright 1988, 1989 Hans-J. Boehm, Alan J. Demers\n Copyright (c) 1991-1996 by Xerox Corporation.  All rights reserved.\n-Copyright (c) 1996-1998 by Silicon Graphics.  All rights reserved.\n+Copyright (c) 1996-1999 by Silicon Graphics.  All rights reserved.\n+Copyright (c) 1999 by Hewlett-Packard Company. All rights reserved.\n \n   [ This version of the collector modified by Cygnus Solutions.\n     See the file ChangeLog for details ]\n@@ -14,18 +15,25 @@ Permission to modify the code and to distribute modified code is granted,\n provided the above notices are retained, and a notice that the code was\n modified is included with the above copyright notice.\n \n-This is version 4.13alpha2 of a conservative garbage collector for C and C++.\n+This is version 5.0alpha4 of a conservative garbage collector for C and C++.\n \n You might find a more recent version of this at\n \n-http://reality.sgi.com/boehm/gc.html\n+http://www.hpl.hp.com/personal/Hans_Boehm/gc\n \n HISTORY -\n \n   Early versions of this collector were developed as a part of research\n projects supported in part by the National Science Foundation\n and the Defense Advance Research Projects Agency.\n-Much of the code was rewritten by Hans-J. Boehm at Xerox PARC.\n+Much of the code was rewritten by Hans-J. Boehm (boehm@acm.org) at Xerox PARC\n+and at SGI.\n+\n+Some other contributors:  \n+\n+More recent contributors are mentioned in the modification history at the\n+end of this file.  My apologies for any omissions.\n+\n The SPARC specific code was contributed by Mark Weiser\n (weiser@parc.xerox.com).  The Encore Multimax modifications were supplied by\n Kevin Kenny (kenny@m.cs.uiuc.edu).  The adaptation to the RT is largely due\n@@ -36,8 +44,8 @@ Robert Brazile (brazile@diamond.bbn.com) originally supplied the ULTRIX code.\n Al Dosser (dosser@src.dec.com) and Regis Cridlig (Regis.Cridlig@cl.cam.ac.uk)\n subsequently provided updates and information on variation between ULTRIX\n systems.  Parag Patel (parag@netcom.com) supplied the A/UX code.\n-Jesper Peterson(jep@mtiame.mtia.oz.au) and\n-Michel Schinz supplied the Amiga port.\n+Jesper Peterson(jep@mtiame.mtia.oz.au), Michel Schinz, and\n+Martin Tauchmann (martintauchmann@bigfoot.com) supplied the Amiga port.\n Thomas Funke (thf@zelator.in-berlin.de(?)) and\n Brian D.Carlstrom (bdc@clark.lcs.mit.edu) supplied the NeXT ports.\n Douglas Steel (doug@wg.icl.co.uk) provided ICL DRS6000 code.\n@@ -62,8 +70,7 @@ made it into the released version of the collector, yet.)\n (Blame for misinstallation of these modifications goes to the first author,\n however.)\n \n-Credits for some more recent modifications are given in the modification\n-history at the end of this file.\n+OVERVIEW\n \n     This is intended to be a general purpose, garbage collecting storage\n allocator.  The algorithms used are described in:\n@@ -92,7 +99,7 @@ of the ACM SIGPLAN '96 Conference on Programming Language Design and\n Implementation.\n \n (Both are also available from\n-http://reality.sgi.com/employees/boehm_mti/papers/, among other places.)\n+http://reality.sgi.com/boehm/papers/, among other places.)\n \n   Unlike the collector described in the second reference, this collector\n operates either with the mutator stopped during the entire collection\n@@ -259,7 +266,7 @@ or win16 is hard.\n   For machines not already mentioned, or for nonstandard compilers, the\n following are likely to require change:\n \n-1.  The parameters in config.h.\n+1.  The parameters in gcconfig.h.\n       The parameters that will usually require adjustment are\n    STACKBOTTOM,  ALIGNMENT and DATASTART.  Setjmp_test\n    prints its guesses of the first two.\n@@ -276,7 +283,7 @@ following are likely to require change:\n    On some machines, it is difficult to obtain such a value that is\n    valid across a variety of MMUs, OS releases, etc.  A number of\n    alternatives exist for using the collector in spite of this.  See the\n-   discussion in config.h immediately preceding the various\n+   discussion in gcconfig.h immediately preceding the various\n    definitions of STACKBOTTOM.\n    \n 2.  mach_dep.c.\n@@ -313,7 +320,7 @@ following are likely to require change:\n     in gc_priv.h will need to be suitably redefined.\n       The incremental collector requires page dirty information, which\n     is acquired through routines defined in os_dep.c.  Unless directed\n-    otherwise by config.h, these are implemented as stubs that simply\n+    otherwise by gcconfig.h, these are implemented as stubs that simply\n     treat all pages as dirty.  (This of course makes the incremental\n     collector much less useful.)\n \n@@ -325,7 +332,7 @@ following are likely to require change:\n \n   For a different version of UN*X or different machines using the\n Motorola 68000, Vax, SPARC, 80386, NS 32000, PC/RT, or MIPS architecture,\n-it should frequently suffice to change definitions in config.h.\n+it should frequently suffice to change definitions in gcconfig.h.\n \n \n THE C INTERFACE TO THE ALLOCATOR\n@@ -609,7 +616,7 @@ reclaimed.  Exclusive-or'ing forward and backward links in a list\n doesn't cut it.\n   Some C optimizers may lose the last undisguised pointer to a memory\n object as a consequence of clever optimizations.  This has almost\n-never been observed in practice.  Send mail to boehm@mti.sgi.com\n+never been observed in practice.  Send mail to boehm@acm.org\n for suggestions on how to fix your compiler.\n   This is not a real-time collector.  In the standard configuration,\n percentage of time required for collection should be constant across\n@@ -618,7 +625,7 @@ heap sizes.  But collection pauses will increase for larger heaps.\n per MB of accessible memory that needs to be scanned.  Your mileage\n may vary.)  The incremental/generational collection facility helps,\n but is portable only if \"stubborn\" allocation is used.\n-  Please address bug reports to boehm@mti.sgi.com.  If you are\n+  Please address bug reports to boehm@acm.org.  If you are\n contemplating a major addition, you might also send mail to ask whether\n it's already been done (or whether we tried and discarded it).\n \n@@ -1371,9 +1378,156 @@ Since alpha1:\n  - USE_MMAP had some serious bugs.  This caused the collector to fail\n    consistently on Solaris with -DSMALL_CONFIG.\n  - Added Linux threads support, thanks largely to Fergus Henderson.\n+Since alpha2:\n+ - Fixed more Linux threads problems.\n+ - Changed default GC_free_space_divisor to 3 with new large block allocation.\n+   (Thanks to Matthew Flatt for some measurements that suggest the old\n+   value sometimes favors space too much over time.)\n+ - More CYGWIN32 fixes.\n+ - Integrated Tyson-Dowd's Linux-M68K port.\n+ - Minor HP PA and DEC UNIX fixes from Fergus Henderson.\n+ - Integrated Christoffe Raffali's Linux-SPARC changes.\n+ - Allowed for one more GC fixup iteration after a full GC in incremental\n+   mode.  Some quick measurements suggested that this significantly\n+   reduces pause times even with smaller GC_RATE values.\n+ - Moved some more GC data structures into GC_arrays.  This decreases\n+   pause times and GC overhead, but makes debugging slightly less convenient.\n+ - Fixed namespace pollution problem (\"excl_table\").\n+ - Made GC_incremental a constant for -DSMALL_CONFIG, hopefully shrinking\n+   that slightly.\n+ - Added some win32 threads fixes.\n+ - Integrated Ivan Demakov and David Stes' Watcom fixes.\n+ - Various other minor fixes contributed by many people.\n+ - Renamed config.h to gcconfig.h, since config.h tends to be used for\n+   many other things.\n+ - Integrated Matthew Flatt's support for 68K MacOS \"far globals\".\n+ - Fixed up some of the dynamic library Makefile targets for consistency\n+   across platforms.\n+ - Fixed a USE_MMAP typo that caused out-of-memory handling to fail\n+   on Solaris.\n+ - Added code to test.c to test thread creation a bit more.\n+ - Integrated GC_win32_free_heap, as suggested by Ivan Demakov.\n+ - Fixed Solaris 2.7 stack base finding problem.  (This may actually\n+   have been done in an earlier alpha release.)\n+Since alpha3:\n+ - Fixed MSWIN32 recognition test, which interfered with cygwin.\n+ - Removed unnecessary gc_watcom.asm from distribution.  Removed\n+   some obsolete README.win32 text.\n+ - Added Alpha Linux incremental GC support.  (Thanks to Philipp Tomsich\n+   for code for retrieving the fault address in a signal handler.)\n+   Changed Linux signal handler context argument to be a pointer.\n+ - Took care of some new warnings generated by the 7.3 SGI compiler.\n+ - Integrated Phillip Musumeci's FreeBSD/ELF fixes.\n+ - -DIRIX_THREADS was broken with the -o32 ABI (typo in gc_priv.h>\n+\n+Since 4.13:\n+ - Fixed GC_print_source_ptr to not use a prototype.\n+ - generalized CYGWIN test.\n+ - gc::new did the wrong thing with PointerFreeGC placement.\n+   (Thanks to Rauli Ruohonen.)\n+ - In the ALL_INTERIOR_POINTERS (default) case, some callee-save register\n+   values could fail to be scanned if the register was saved and\n+   reused in a GC frame.  This showed up in verbose mode with gctest\n+   compiled with an unreleased SGI compiler.  I vaguely recall an old\n+   bug report that may have been related.  The bug was probably quite old.\n+   (The problem was that the stack scanning could be deferred until\n+   after the relevant frame was overwritten, and the new save location\n+   might be outside the scanned area.  Fixed by more eager stack scanning.)\n+ - PRINT_BLACK_LIST had some problems.  A few source addresses were garbage.\n+ - Replaced Makefile.dj and added -I flags to cord make targets.\n+   (Thanks to Gary Leavens.)\n+ - GC_try_to_collect was broken with the nonincremental collector.\n+ - gc_cleanup destructors could pass the wrong address to\n+   GC_register_finalizer_ignore_self in the presence of multiple\n+   inheritance.  (Thanks to Darrell Schiebel.)\n+ - Changed PowerPC Linux stack finding code.\n+\n+Since 4.14alpha1\n+ - -DSMALL_CONFIG did not work reliably with large (> 4K) pages.\n+   Recycling the mark stack during expansion could result in a size\n+   zero heap segment, which confused things.  (This was probably also an\n+   issue with the normal config and huge pages.)\n+ - Did more work to make sure that callee-save registers were scanned\n+   completely, even with the setjmp-based code.  Added USE_GENERIC_PUSH_REGS\n+   macro to facilitate testing on machines I have access to.\n+ - Added code to explicitly push register contents for win32 threads.\n+   This seems to be necessary.  (Thanks to Pierre de Rop.)\n+\n+Since 4.14alpha2\n+ - changed STACKBOTTOM for DJGPP (Thanks to Salvador Eduardo Tropea).\n+ \n+Since 4.14\n+ - Reworked large block allocator.  Now uses multiple doubly linked free\n+   lists to approximate best fit.\n+ - Changed heap expansion heuristic.  Entirely free blocks are no longer\n+   counted towards the heap size.  This seems to have a major impact on\n+   heap size stability; the old version could expand the heap way too\n+   much in the presence of large block fragmentation.\n+ - added -DGC_ASSERTIONS and some simple assertions inside the collector.\n+   This is mainlyt for collector debugging.\n+ - added -DUSE_MUNMAP to allow the heap to shrink.  Suupported on only\n+   a few UNIX-like platforms for now.\n+ - added GC_dump_regions() for debugging of fragmentation issues.\n+ - Changed PowerPC pointer alignment under Linux to 4.  (This needs\n+   checking by someone who has one.  The suggestions came to me via a\n+   rather circuitous path.)\n+ - Changed the Linux/Alpha port to walk the data segment backwards until\n+   it encounters a SIGSEGV.  The old way to find the start of the data\n+   segment broke with a recent release.\n+ - cordxtra.c needed to call GC_REGISTER_FINALIZER instead of\n+   GC_register_finalizer, so that it would continue to work with GC_DEBUG.\n+ - allochblk sometimes cleared the wrong block for debugging purposes\n+   when it dropped blacklisted blocks.  This could result in spurious\n+   error reports with GC_DEBUG.\n+ - added MACOS X Server support.  (Thanks to Andrew Stone.)\n+ - Changed the Solaris threads code to ignore stack limits > 8 MB with\n+   a warning.  Empirically, it is not safe to access arbitrary pages\n+   in such large stacks.  And the dirty bit implementation does not\n+   guarantee that none of them will be accessed.\n+ - Integrated Martin Tauchmann's Amiga changes.\n+ - Integrated James Dominy's OpenBSD/SPARC port.\n+\n+Since 5.0alpha1\n+ - Fixed bugs introduced in alpha1 (OpenBSD & large block initialization).\n+ - Added -DKEEP_BACK_PTRS and backptr.h interface.  (The implementation\n+   idea came from Al Demers.)\n+\n+Since 5.0alpha2\n+ - Added some highly incomplete code to support a copied young generation.\n+   Comments on nursery.h are appreciated.\n+ - Changed -DFIND_LEAK, -DJAVA_FINALIZATION, and -DFINALIZE_ON_DEMAND,\n+   so the same effect could be obtained with a runtime switch.   This is\n+   a step towards standardizing on a single dynamic GC library.\n+ - Significantly changed the way leak detection is handled, as a consequence\n+   of the above.\n+\n+Since 5.0 alpha3\n+ - Added protection fault handling patch for Linux/M68K from Fergus\n+   Henderson and Roman Hodek.\n+ - Removed the tests for SGI_SOURCE in new_gc_alloc.h.  This was causing that\n+   interface to fail on nonSGI platforms.\n+ - Changed the Linux stack finding code to use /proc, after chnging it\n+   to use HEURISTIC1.  (Thanks to David Mossberger for pointing out the\n+   /proc hook.)\n+ - Added HP/UX incremental GC support and HP/UX 11 thread support.\n+ - Added basic Linux/IA64 support.\n+ - Integrated Anthony Green's PicoJava support.\n+ - Integrated Scott Ananian's StrongARM/NetBSD support.\n+ - Fixed some fairly serious performance bugs in the incremental\n+   collector.  These have probably been there essentially forever.\n+   (Mark bits were sometimes set before scanning dirty pages.\n+   The reclaim phase unnecessarily dirtied full small object pages.)\n+ - Changed the reclaim phase to ignore nearly full pages to avoid\n+   touching them.\n+ - Limited GC_black_list_spacing to roughly the heap growth increment.\n+ - Changed full collection triggering heuristic to decrease full GC\n+   frequency by default, but to explicitly trigger full GCs during\n+   heap growth.  This doesn't always improve things, but on average it's\n+   probably a win.\n+ - GC_debug_free(0, ...) failed.  Thanks to Fergus Henderson for the\n+   bug report and fix.\n \n To do:\n- - I have a backlog of unintegrated contributed platform-specific changes.\n  - Very large root set sizes (> 16 MB or so) could cause the collector\n    to abort with an unexpected mark stack overflow.  (Thanks again to\n    Peter Chubb.)  NOT YET FIXED.  Workaround is to increase the initial\n@@ -1386,4 +1540,6 @@ To do:\n    be possible to conditionally intercept mmap and use GC_exclude_static_roots.\n    The real fix is to walk rld data structures, which looks possible.\n  - Integrate MIT and DEC pthreads ports.\n- \n+ - Incremental collector should handle large objects better.  Currently,\n+   it looks like the whole object is treated as dirty if any part of it\n+   is."}, {"sha": "04f468251a1e5f4b94181f9e6ad085b96e8ff442", "filename": "boehm-gc/README.Mac", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20bbd3cd53a80ddafa56a5d21337aae0c24f94ca/boehm-gc%2FREADME.Mac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20bbd3cd53a80ddafa56a5d21337aae0c24f94ca/boehm-gc%2FREADME.Mac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2FREADME.Mac?ref=20bbd3cd53a80ddafa56a5d21337aae0c24f94ca", "patch": "@@ -320,7 +320,7 @@ Very few. Just one tiny in the GC, not strictly needed.\n    alloc dummy_to_fool_the_compiler_into_doing_things_it_currently_cant_handle;\n   ------------\n \n-- config.h\n+- config.h [now gcconfig.h]\n   __MWERKS__ does not have to mean MACOS. You can use Codewarrior to\n   build a Win32 or BeOS library and soon a Rhapsody library. You may\n   have to change that #if..."}, {"sha": "ddebf82ca50b7cb3b9b4baa31f4f5d37d887418d", "filename": "boehm-gc/README.QUICK", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20bbd3cd53a80ddafa56a5d21337aae0c24f94ca/boehm-gc%2FREADME.QUICK", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20bbd3cd53a80ddafa56a5d21337aae0c24f94ca/boehm-gc%2FREADME.QUICK", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2FREADME.QUICK?ref=20bbd3cd53a80ddafa56a5d21337aae0c24f94ca", "patch": "@@ -1,5 +1,7 @@\n Copyright 1988, 1989 Hans-J. Boehm, Alan J. Demers\n-Copyright (c) 1991-1994 by Xerox Corporation.  All rights reserved.\n+Copyright (c) 1991-1995 by Xerox Corporation.  All rights reserved.\n+Copyright (c) 1996-1999 by Silicon Graphics.  All rights reserved.\n+Copyright (c) 1999 by Hewlett-Packard. All rights reserved.\n \n THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED\n OR IMPLIED.  ANY USE IS AT YOUR OWN RISK."}, {"sha": "213a13e3fef62f21a551119826908bacdceb2e8a", "filename": "boehm-gc/README.alpha", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20bbd3cd53a80ddafa56a5d21337aae0c24f94ca/boehm-gc%2FREADME.alpha", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20bbd3cd53a80ddafa56a5d21337aae0c24f94ca/boehm-gc%2FREADME.alpha", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2FREADME.alpha?ref=20bbd3cd53a80ddafa56a5d21337aae0c24f94ca", "patch": "@@ -5,6 +5,13 @@ Incremental gc not yet supported under Linux because signal handler\n for SIGSEGV can't get a hold of fault address.  Dynamic library support\n is also missing from Linux/alpha, probably for no good reason.\n \n+Currently there is no thread support in the standard distribution.  There\n+exists a separate port to DEC Unix pthreads.  It should be possible to\n+port the X86 Linux threads support to Alpha without much trouble.\n+\n+If you get asssembler errors, be sure to read the first few lines of the\n+Makefile.\n+\n From Philippe Queinnec:\n \n System: DEC/Alpha OSF1 v3.2, vendor cc"}, {"sha": "47b15884354e558f5d8423d4c3212d84b8464788", "filename": "boehm-gc/README.amiga", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20bbd3cd53a80ddafa56a5d21337aae0c24f94ca/boehm-gc%2FREADME.amiga", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20bbd3cd53a80ddafa56a5d21337aae0c24f94ca/boehm-gc%2FREADME.amiga", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2FREADME.amiga?ref=20bbd3cd53a80ddafa56a5d21337aae0c24f94ca", "patch": "@@ -1,4 +1,51 @@\n+===========================================================================\n+\t\t\t   Martin Tauchmann's notes\t\t(1-Apr-99)\n+===========================================================================\n+\n+Works now, also with the GNU-C compiler V2.7.2.1. <ftp://ftp.unina.it/pub/amiga/geekgadgets/amiga/m68k/snapshots/971125/amiga-bin/>\n+Modify the `Makefile`\n+CC=cc $(ABI_FLAG)\n+to\n+CC=gcc $(ABI_FLAG)\n+\n+TECHNICAL NOTES\n+\n+- `GC_get_stack_base()`, `GC_register_data_segments()` works now with every\n+   C compiler; also Workbench.\n+\n+- Removed AMIGA_SKIP_SEG, but the Code-Segment must not be scanned by GC.\n+\n+\n+PROBLEMS\n+- When the Linker, does`t merge all Code-Segments to an single one. LD of GCC\n+  do it always.\n+\n+- With ixemul.library V47.3, when an GC program launched from another program\n+  (example: `Make` or `if_mach M68K AMIGA gctest`), `GC_register_data_segments()`\n+  found the Segment-List of the caller program.\n+  Can be fixed, if the run-time initialization code (for C programs, usually *crt0*)\n+  support `__data` and `__bss`.\n+\n+- PowerPC Amiga currently not supported.\n+\n+- Dynamic libraries (dyn_load.c) not supported.\n+\n+\n+TESTED WITH SOFTWARE\n+\n+`Optimized Oberon 2 C` (oo2c) <http://cognac.informatik.uni-kl.de/download/index.html>\n+\n+\n+TESTED WITH HARDWARE\n+\n+MC68030\n+\n+\n+CONTACT\n \n+Please, contact me at <martintauchmann@bigfoot.com>, when you change the\n+Amiga port. <http://martintauchmann.home.pages.de>\n+ \n ===========================================================================\n \t\t\t   Michel Schinz's notes\n ==========================================================================="}, {"sha": "072ba5386ac9895e01b8086c5acb921f9ebb03bb", "filename": "boehm-gc/README.hp", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20bbd3cd53a80ddafa56a5d21337aae0c24f94ca/boehm-gc%2FREADME.hp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20bbd3cd53a80ddafa56a5d21337aae0c24f94ca/boehm-gc%2FREADME.hp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2FREADME.hp?ref=20bbd3cd53a80ddafa56a5d21337aae0c24f94ca", "patch": "@@ -1,9 +1,16 @@\n Dynamic loading support requires that executables be linked with -ldld.\n The alternative is to build the collector without defining DYNAMIC_LOADING\n-in config.h and ensuring that all garbage collectable objects are\n+in gcconfig.h and ensuring that all garbage collectable objects are\n accessible without considering statically allocated variables in dynamic\n libraries.\n \n The collector should compile with either plain cc or cc -Ae.  CC -Aa\n fails to define _HPUX_SOURCE and thus will not configure the collector\n correctly.\n+\n+Incremental collection support was reccently added, and should now work.\n+\n+Thread support for HP/UX 11 Pthreads was also recently added.  It is still\n+flakey in this release.  (It has only been tested on a uniprocessor.  Even\n+there some fraction of thread creation calls fail with a not-yet-understood\n+error return from sem_wait.)"}, {"sha": "b4f136afb5cfbac7d99b5c4162f2962dc7e4a4bf", "filename": "boehm-gc/README.linux", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20bbd3cd53a80ddafa56a5d21337aae0c24f94ca/boehm-gc%2FREADME.linux", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20bbd3cd53a80ddafa56a5d21337aae0c24f94ca/boehm-gc%2FREADME.linux", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2FREADME.linux?ref=20bbd3cd53a80ddafa56a5d21337aae0c24f94ca", "patch": "@@ -1,7 +1,11 @@\n-See README.alpha for Linux on DEC AXP info.  This file applies to\n-Linux/Intel.\n+See README.alpha for Linux on DEC AXP info.\n \n-Incremental GC is supported.\n+This file applies mostly to Linux/Intel IA32.  Ports to Linux on an M68K\n+and PowerPC are also integrated.  They should behave similarly, except that\n+the PowerPC port lacks incremental GC support, and it is unknown to what\n+extent the Linux threads code is functional.\n+\n+Incremental GC is supported on Intel IA32 and M68K.\n \n Dynamic libraries are supported on an ELF system.  A static executable\n should be linked with the gcc option \"-Wl,-defsym,_DYNAMIC=0\".\n@@ -37,3 +41,10 @@ To use threads, you need to abide by the following requirements:\n    probably be an inconsistent state when a thread calling the loader is\n    is stopped for GC.  (It's possible that this is fixable in the\n    same way it is handled for SOLARIS_THREADS, with GC_dlopen.)\n+\n+5) The combination of LINUX_THREADS, REDIRECT_MALLOC, and incremental\n+   collection fails in seemingly random places.  This hasn't been tracked\n+   down yet, but is perhaps not completely astonishing.  The thread package\n+   uses malloc, and thus can presumably get SIGSEGVs while inside the\n+   package.  There is no real guarantee that signals are handled properly\n+   at that point."}, {"sha": "f5630b20a3290a25903980435838bd935878372a", "filename": "boehm-gc/README.rs6000", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20bbd3cd53a80ddafa56a5d21337aae0c24f94ca/boehm-gc%2FREADME.rs6000", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20bbd3cd53a80ddafa56a5d21337aae0c24f94ca/boehm-gc%2FREADME.rs6000", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2FREADME.rs6000?ref=20bbd3cd53a80ddafa56a5d21337aae0c24f94ca", "patch": "@@ -4,3 +4,6 @@ startup.  The supplied value sometimes causes failure under AIX 4.1, though\n it appears to work under 3.X.  HEURISTIC2 seems to work under 4.1, but\n involves a substantial performance penalty, and will fail if there is\n no limit on stack size.\n+\n+There is no thread support.  (I assume recent versions of AIX provide\n+pthreads?  I no longer have access to a machine ...)"}, {"sha": "e67124b55442f15e9979f164d2cff5c13af351a0", "filename": "boehm-gc/README.sgi", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20bbd3cd53a80ddafa56a5d21337aae0c24f94ca/boehm-gc%2FREADME.sgi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20bbd3cd53a80ddafa56a5d21337aae0c24f94ca/boehm-gc%2FREADME.sgi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2FREADME.sgi?ref=20bbd3cd53a80ddafa56a5d21337aae0c24f94ca", "patch": "@@ -35,3 +35,7 @@ The garbage collector uses signals to stop threads.)\n initiated.  Applications with many such threads may not exhibit acceptable\n performance with the collector.  (Increasing the heap size may help.)\n \n+6) The collector should not be compiled with -DREDIRECT_MALLOC.  This\n+confuses some library calls made by the pthreads implementation, which\n+expect the standard malloc.\n+"}, {"sha": "e5935131c770116f8742e5f90ad30db6b19fd204", "filename": "boehm-gc/README.solaris2", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20bbd3cd53a80ddafa56a5d21337aae0c24f94ca/boehm-gc%2FREADME.solaris2", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20bbd3cd53a80ddafa56a5d21337aae0c24f94ca/boehm-gc%2FREADME.solaris2", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2FREADME.solaris2?ref=20bbd3cd53a80ddafa56a5d21337aae0c24f94ca", "patch": "@@ -1,7 +1,7 @@\n The collector supports both incremental collection and threads under\n Solaris 2.  The incremental collector normally retrieves page dirty information\n through the appropriate /proc calls.  But it can also be configured\n-(by defining MPROTECT_VDB instead of PROC_VDB in config.h) to use mprotect\n+(by defining MPROTECT_VDB instead of PROC_VDB in gcconfig.h) to use mprotect\n and signals.  This may result in shorter pause times, but it is no longer\n safe to issue arbitrary system calls that write to the heap.\n \n@@ -14,7 +14,7 @@ and sbrk() only when you know  that malloc() definitely will not be used by\n any library routine.\"  This doesn't make a lot of sense to me, since there\n seems to be no documentation as to which routines can transitively call malloc.\n Nonetheless, under Solaris2, the collector now (since 4.12) allocates\n-memory using mmap by default.  (It defines USE_MMAP in config.h.)\n+memory using mmap by default.  (It defines USE_MMAP in gcconfig.h.)\n You may want to reverse this decisions if you use -DREDIRECT_MALLOC=...\n \n "}, {"sha": "d78816b555d5dfb73f62b5d7c1382c44c29f08b6", "filename": "boehm-gc/README.win32", "status": "modified", "additions": 33, "deletions": 47, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20bbd3cd53a80ddafa56a5d21337aae0c24f94ca/boehm-gc%2FREADME.win32", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20bbd3cd53a80ddafa56a5d21337aae0c24f94ca/boehm-gc%2FREADME.win32", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2FREADME.win32?ref=20bbd3cd53a80ddafa56a5d21337aae0c24f94ca", "patch": "@@ -23,7 +23,11 @@ the two systems, and under different versions of win32s.)\n The collector test program \"gctest\" is linked as a GUI application,\n but does not open any windows.  Its output appears in the file\n \"gc.log\".  It may be started from the file manager.  The hour glass\n-cursor will appear as long as it's running.\n+cursor will appear as long as it's running.  If it is started from the\n+command line, it will usually run in the background.  Wait a few\n+minutes (a few seconds on a modern machine) before you check the output.\n+You should see either a failure indication or a \"Collector appears to\n+work\" message.\n \n The cord test program has not been ported (but should port\n easily).  A toy editor (cord/de.exe) based on cords (heavyweight\n@@ -46,7 +50,7 @@ the line \"include Makefile.DLLs\".  The latter should be necessary only\n if you want to package the collector as a DLL.  The GNU-win32 port is\n believed to work only for b18, not b19, probably dues to linker changes\n in b19.  This is probably fixable with a different definition of\n-DATASTART and DATAEND in config.h.\n+DATASTART and DATAEND in gcconfig.h.\n \n For Borland tools, use BCC_MAKEFILE.  Note that\n Borland's compiler defaults to 1 byte alignment in structures (-a1),\n@@ -56,7 +60,7 @@ LEAST 4 BYTE ALIGNMENT.  Thus the BORLAND DEFAULT MUST\n BE OVERRIDDEN.  (In my opinion, it should usually be anyway.\n I expect that -a1 introduces major performance penalties on a\n 486 or Pentium.)  Note that this changes structure layouts.  (As a last\n-resort, config.h can be changed to allow 1 byte alignment.  But\n+resort, gcconfig.h can be changed to allow 1 byte alignment.  But\n this has significant negative performance implications.)\n The Makefile is set up to assume Borland 4.5.  If you have another\n version, change the line near the top.  By default, it does not\n@@ -97,67 +101,49 @@ test with VC++ from the command line, use\n nmake /F \".\\gc.mak\" CFG=\"gctest - Win32 Release\"\n \n This requires that the subdirectory gctest\\Release exist.\n+The test program and DLL will reside in the Release directory.\n \n This version relies on the collector residing in a dll.\n \n This version currently supports incremental collection only if it is\n enabled before any additional threads are created.\n-It is known to not be completely solid.  At a minimum it can deadlock\n-if a thread starts in the middle of an allocation.  There may be\n-other problems.  If you need solid support for win32 threads, you\n-check with Geodesic Systems.  I haven't tried it, but they claim\n-to support it.\n+Version 4.13 attempts to fix some of the earlier problems, but there\n+may be other issues.  If you need solid support for win32 threads, you\n+might check with Geodesic Systems.  Their collector must be licensed,\n+but they have invested far more time in win32-specific issues.\n \n Hans\n \n Ivan V. Demakov's README for the Watcom port:\n \n-[ He points out in a later message that there may be a problem compiling\n-  under Windows-3.11 for Windows NT. ]\n+The collector has been compiled with Watcom C 10.6 and 11.0.\n+It runs under win32, win32s, and even under msdos with dos4gw\n+dos-extender. It should also run under OS/2, though this isn't\n+tested. Under win32 the collector can be built either as dll\n+or as static library.\n \n-Watcom C/C++ 10.5, 10.6, 11.0 tested.\n+Note that all compilations were done under Windows 95 or NT.\n+For unknown reason compiling under Windows 3.11 for NT (one\n+attempt has been made) leads to broken executables.\n \n-The collector runs on WIN32 and DOS4GW dos-extender with both\n-stack and register based calling conventions (options -5r and -5s).\n-Incremental collection not supported.\n+Incremental collection is not supported.\n \n-OS/2 not tested, but should work (only some #ifdef's added for OS/2 port).\n+cord is not ported.\n \n-cord not ported. Watcom C fails to compile it, from first attempt.\n-Since I don't use it, I don't try to fix it.\n+Before compiling you may need to edit WCC_MAKEFILE to set target\n+platform, library type (dynamic or static), calling conventions, and\n+optimization options.\n \n-cpp_test succeeds, but not compiled automaticaly with WCC_MAKEFILE.\n+To compile the collector and testing programs use the command:\n+    wmake -f WCC_MAKEFILE\n \n+All programs using gc should be compiled with 4-byte alignment.\n+For further explanations on this see comments about Borland.\n \n-My changes:\n+If gc compiled as dll, the macro ``GC_DLL'' should be defined before\n+including \"gc.h\" (for example, with -DGC_DLL compiler option). It's\n+important, otherwise resulting programs will not run.\n \n-      * config.h      Added definitions for Watcom C/C++.\n-                      Undefined MPROTECT_VDB for Watcom C/C++ MSWIN32,\n-                      I don't have idea why it not work.\n-\n-      * gc.h          Explicitly declared GC_noop. This prevents\n-                      program crash, compiled with -5r option.\n-\n-      * gc_priv.h     Changed declaration for GC_push_one to make\n-                      compiler happy.\n-                      Added GC_dos4gw_get_mem declaration and\n-                      GET_MEM uses it in DOS4GW environment.\n-\n-      * os_dep.c      Added __WATCOMC__ and DOS4GW #ifdef's.\n-                      Added GC_dos4gw_get_mem.\n-\n-      * mach_dep.c    For Watcom used setjmp method of marking registers.\n-\n-      * WCC_MAKEFILE  New file. Makefile for Watcom C/C++.\n-\n-      * gc_watcom.asm New file. Some functions for DOS4GW.\n-                      This functions may (probably) be done in C,\n-                      but I can't figure out how do this for all\n-                      possible options of compiler.\n-\n-      * README.watcom This file.\n-\n-\n-  Ivan Demakov (email: dem@tgrad.nsk.su)\n+Ivan Demakov (email: ivan@tgrad.nsk.su)\n \n "}, {"sha": "e9602c08cdc86b0ab3e899fb9244fd2a675ec6d0", "filename": "boehm-gc/SMakefile.amiga", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20bbd3cd53a80ddafa56a5d21337aae0c24f94ca/boehm-gc%2FSMakefile.amiga", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20bbd3cd53a80ddafa56a5d21337aae0c24f94ca/boehm-gc%2FSMakefile.amiga", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2FSMakefile.amiga?ref=20bbd3cd53a80ddafa56a5d21337aae0c24f94ca", "patch": "@@ -1,6 +1,6 @@\n OBJS= alloc.o reclaim.o allchblk.o misc.o mach_dep.o os_dep.o mark_rts.o headers.o mark.o obj_map.o blacklst.o finalize.o new_hblk.o real_malloc.o dyn_load.o dbg_mlc.o malloc.o stubborn.o checksums.o typd_mlc.o ptr_chck.o\n \n-INC=  gc_private.h gc_hdrs.h gc.h config.h\n+INC=  gc_private.h gc_hdrs.h gc.h gcconfig.h\n \n all: gctest setjmp_t\n "}, {"sha": "087ff6a31d89fd5155882d5e38d16e1779723fcd", "filename": "boehm-gc/WCC_MAKEFILE", "status": "modified", "additions": 126, "deletions": 53, "changes": 179, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20bbd3cd53a80ddafa56a5d21337aae0c24f94ca/boehm-gc%2FWCC_MAKEFILE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20bbd3cd53a80ddafa56a5d21337aae0c24f94ca/boehm-gc%2FWCC_MAKEFILE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2FWCC_MAKEFILE?ref=20bbd3cd53a80ddafa56a5d21337aae0c24f94ca", "patch": "@@ -1,104 +1,178 @@\n-# Makefile for Watcom C/C++ 10.5, 10.6, 11.0 on NT, OS2 and DOS4GW .\n-# May work with Watcom 10.0 .\n-#\n+# Makefile for Watcom C/C++ 10.5, 10.6, 11.0 on NT, OS2 and DOS4GW.\n+# May work with Watcom 10.0.\n \n-#\n-# Uncoment one of line for cross compiling\n+# Uncoment one of the lines below for cross compilation.\n+SYSTEM=MSWIN32\n #SYSTEM=DOS4GW\n-#SYSTEM=MSWIN32\n #SYSTEM=OS2\n \n-!ifndef SYSTEM\n+# The collector can be built either as dynamic or as static library.\n+# Select the library type you need.\n+#MAKE_AS_DLL=1\n+MAKE_AS_LIB=1\n \n-!ifdef __MSDOS__\n-SYSTEM=DOS4GW\n-!endif\n+# Select calling conventions.\n+# Possible choices are r and s.\n+CALLING=s\n \n-!ifdef __NT__\n-SYSTEM=MSWIN32\n-!endif\n+# Select target CPU.\n+# Possible choices are 3, 4, 5, and 6.\n+# The last choice available only since version 11.0.\n+CPU=5\n \n-!ifdef __OS2__\n-SYSTEM=OS2\n-!endif\n+# Set optimization options.\n+# Watcom before 11.0 does not support option \"-oh\".\n+OPTIM=-oneatx -s\n+#OPTIM=-ohneatx -s\n \n-D_SYSTEM=\n+DEFS=-DALL_INTERIOR_POINTERS -DSILENT -DNO_SIGNALS #-DSMALL_CONFIG #-DGC_DEBUG\n \n-!else\n \n-D_SYSTEM=-D$(SYSTEM)\n+#####\n \n+!ifndef SYSTEM\n+!ifdef __MSDOS__\n+SYSTEM=DOS4GW\n+!else ifdef __NT__\n+SYSTEM=MSWIN32\n+!else ifdef __OS2__\n+SYSTEM=OS2\n+!else\n+SYSTEM=Unknown\n+!endif\n !endif\n \n !define $(SYSTEM)\n \n+!ifdef DOS4GW\n+SYSFLAG=-DDOS4GW -bt=dos\n+!else ifdef MSWIN32\n+SYSFLAG=-DMSWIN32 -bt=nt\n+!else ifdef OS2\n+SYSFLAG=-DOS2 -bt=os2\n+!else\n+!error undefined or unsupported target platform: $(SYSTEM)\n+!endif\n+!ifdef MAKE_AS_DLL\n+DLLFLAG=-bd -DGC_DLL\n+TEST_DLLFLAG=-DGC_DLL\n+!else ifdef MAKE_AS_LIB\n+DLLFLAG=\n+TEST_DLLFLAG=\n+!else\n+!error Either MAKE_AS_LIB or MAKE_AS_DLL should be defined\n+!endif\n \n CC=wcc386\n CXX=wpp386\n-AS=wasm\n-\n-\n-# Watcom before 11.0 not support option -oh\n-# Remove it if you get error\n-OPTIM=-oneatxh -s\n \n-CALLING=-5s\n-\n-DEFS=-DALL_INTERIOR_POINTERS -DSILENT #-DSMALL_CONFIG #-DGC_DEBUG\n-\n-# ! -DUSE_GENERIC required !\n-CFLAGS=$(OPTIM) -zp4 $(CALLING) -zc -DUSE_GENERIC $(D_SYSTEM) $(DEFS)\n+# -DUSE_GENERIC is required !\n+CFLAGS=-$(CPU)$(CALLING) $(OPTIM) -zp4 -zc $(SYSFLAG) $(DLLFLAG) -DGC_BUILD -DUSE_GENERIC $(DEFS)\n CXXFLAGS= $(CFLAGS)\n-ASFLAGS=$(CALLING)\n+TEST_CFLAGS=-$(CPU)$(CALLING) $(OPTIM) -zp4 -zc $(SYSFLAG) $(TEST_DLLFLAG) $(DEFS)\n+TEST_CXXFLAGS= $(TEST_CFLAGS)\n \n OBJS= alloc.obj reclaim.obj allchblk.obj misc.obj &\n       mach_dep.obj os_dep.obj mark_rts.obj headers.obj mark.obj &\n       obj_map.obj blacklst.obj finalize.obj new_hblk.obj &\n       dbg_mlc.obj malloc.obj stubborn.obj dyn_load.obj &\n-      typd_mlc.obj ptr_chck.obj gc_cpp.obj mallocx.obj\n+      typd_mlc.obj ptr_chck.obj mallocx.obj\n \n+all: gc.lib gctest.exe test_cpp.exe\n \n-all: gc.lib gctest.exe\n+!ifdef MAKE_AS_DLL\n \n-# this file required for DOS4GW only\n-gc_watcom.obj: gc_watcom.asm WCC_MAKEFILE\n-      $(AS) $(ASFLAGS) gc_watcom.asm\n+gc.lib: gc.dll gc_cpp.obj\n+        *wlib -b -c -n -p=512 $@ +gc.dll +gc_cpp.obj\n \n+gc.dll: $(OBJS) .AUTODEPEND\n+        @%create $*.lnk\n !ifdef DOS4GW\n-gc.lib: $(OBJS) gc_watcom.obj\n-      @%create $*.lb1\n-      @for %i in ($(OBJS)) do @%append $*.lb1 +'%i'\n-      @@%append $*.lb1 +'gc_watcom.obj'\n-      *wlib -b -c -n -p=512 $@ @$*.lb1\n+        @%append $*.lnk sys os2v2_dll\n+!else ifdef MSWIN32\n+        @%append $*.lnk sys nt_dll\n+!else ifdef OS2\n+        @%append $*.lnk sys os2v2_dll\n+!endif\n+        @%append $*.lnk name $*\n+        @for %i in ($(OBJS)) do @%append $*.lnk file '%i'\n+!ifeq CALLING s\n+      @%append $*.lnk export GC_is_marked\n+      @%append $*.lnk export GC_incr_words_allocd\n+      @%append $*.lnk export GC_incr_mem_freed\n+      @%append $*.lnk export GC_generic_malloc_words_small\n+!else\n+      @%append $*.lnk export GC_is_marked_\n+      @%append $*.lnk export GC_incr_words_allocd_\n+      @%append $*.lnk export GC_incr_mem_freed_\n+      @%append $*.lnk export GC_generic_malloc_words_small_\n+!endif\n+        *wlink @$*.lnk\n !else\n-gc.lib: $(OBJS)\n+gc.lib: $(OBJS) gc_cpp.obj\n         @%create $*.lb1\n         @for %i in ($(OBJS)) do @%append $*.lb1 +'%i'\n+      @%append $*.lb1 +'gc_cpp.obj'\n         *wlib -b -c -n -p=512 $@ @$*.lb1\n-!endif\n \n+!endif\n \n-test.obj: test.c\n-        $(CC) $(CFLAGS) $*.c\n \n gctest.exe: test.obj gc.lib\n         %create $*.lnk\n !ifdef DOS4GW\n         @%append $*.lnk sys dos4g\n-!endif\n-!ifdef MSWIN32\n+!else ifdef MSWIN32\n         @%append $*.lnk sys nt\n-!endif\n-!ifdef OS2\n+!else ifdef OS2\n         @%append $*.lnk sys os2v2\n !endif\n         @%append $*.lnk op case\n         @%append $*.lnk op stack=256K\n         @%append $*.lnk name $*\n         @%append $*.lnk file test.obj\n         @%append $*.lnk library gc.lib\n+!ifdef MAKE_AS_DLL\n+!ifeq CALLING s\n+      @%append $*.lnk import GC_is_marked gc\n+!else\n+      @%append $*.lnk import GC_is_marked_ gc\n+!endif\n+!endif\n+        *wlink @$*.lnk\n+test_cpp.exe: test_cpp.obj gc.lib\n+        %create $*.lnk\n+!ifdef DOS4GW\n+        @%append $*.lnk sys dos4g\n+!else ifdef MSWIN32\n+        @%append $*.lnk sys nt\n+!else ifdef OS2\n+        @%append $*.lnk sys os2v2\n+!endif\n+        @%append $*.lnk op case\n+        @%append $*.lnk op stack=256K\n+        @%append $*.lnk name $*\n+        @%append $*.lnk file test_cpp.obj\n+        @%append $*.lnk library gc.lib\n+!ifdef MAKE_AS_DLL\n+!ifeq CALLING s\n+      @%append $*.lnk import GC_incr_words_allocd gc\n+      @%append $*.lnk import GC_incr_mem_freed gc\n+      @%append $*.lnk import GC_generic_malloc_words_small gc\n+!else\n+      @%append $*.lnk import GC_incr_words_allocd_ gc\n+      @%append $*.lnk import GC_incr_mem_freed_ gc\n+      @%append $*.lnk import GC_generic_malloc_words_small_ gc\n+!endif\n+!endif\n         *wlink @$*.lnk\n \n+gc_cpp.obj: gc_cpp.cc .AUTODEPEND\n+        $(CXX) $(TEST_CXXFLAGS) -iinclude $*.cc\n+test.obj: test.c .AUTODEPEND\n+        $(CC) $(TEST_CFLAGS) $*.c\n+test_cpp.obj: test_cpp.cc .AUTODEPEND\n+        $(CXX) $(TEST_CXXFLAGS) -iinclude $*.cc\n \n \n .c.obj: .AUTODEPEND\n@@ -107,9 +181,6 @@ gctest.exe: test.obj gc.lib\n .cc.obj: .AUTODEPEND\n         $(CXX) $(CXXFLAGS) $*.cc\n \n-.cpp.obj: .AUTODEPEND\n-        $(CXX) $(CXXFLAGS) $*.cpp\n-\n clean : .SYMBOLIC\n     @if exist *.obj del *.obj\n     @if exist *.map del *.map\n@@ -121,3 +192,5 @@ clean : .SYMBOLIC\n     @if exist *.lst del *.lst\n     @if exist *.exe del *.exe\n     @if exist *.log del *.log\n+    @if exist *.lib del *.lib\n+    @if exist *.dll del *.dll"}, {"sha": "0c758ff8b791ed75af31a63bd5690515cc542f3a", "filename": "boehm-gc/aclocal.m4", "status": "modified", "additions": 71, "deletions": 269, "changes": 340, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20bbd3cd53a80ddafa56a5d21337aae0c24f94ca/boehm-gc%2Faclocal.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20bbd3cd53a80ddafa56a5d21337aae0c24f94ca/boehm-gc%2Faclocal.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Faclocal.m4?ref=20bbd3cd53a80ddafa56a5d21337aae0c24f94ca", "patch": "@@ -294,7 +294,7 @@ else\n fi])\n \n \n-# serial 35 AC_PROG_LIBTOOL\n+# serial 40 AC_PROG_LIBTOOL\n AC_DEFUN(AC_PROG_LIBTOOL,\n [AC_REQUIRE([AC_LIBTOOL_SETUP])dnl\n \n@@ -303,8 +303,9 @@ AC_CACHE_SAVE\n \n # Actually configure libtool.  ac_aux_dir is where install-sh is found.\n CC=\"$CC\" CFLAGS=\"$CFLAGS\" CPPFLAGS=\"$CPPFLAGS\" \\\n-LD=\"$LD\" NM=\"$NM\" RANLIB=\"$RANLIB\" LN_S=\"$LN_S\" \\\n-DLLTOOL=\"$DLLTOOL\" AS=\"$AS\" \\\n+LD=\"$LD\" LDFLAGS=\"$LDFLAGS\" LIBS=\"$LIBS\" \\\n+LN_S=\"$LN_S\" NM=\"$NM\" RANLIB=\"$RANLIB\" \\\n+DLLTOOL=\"$DLLTOOL\" AS=\"$AS\" OBJDUMP=\"$OBJDUMP\" \\\n ${CONFIG_SHELL-/bin/sh} $ac_aux_dir/ltconfig --no-reexec \\\n $libtool_flags --no-verify $ac_aux_dir/ltmain.sh $host \\\n || AC_MSG_ERROR([libtool configure failed])\n@@ -335,8 +336,6 @@ AC_REQUIRE([AC_PROG_RANLIB])dnl\n AC_REQUIRE([AC_PROG_CC])dnl\n AC_REQUIRE([AC_PROG_LD])dnl\n AC_REQUIRE([AC_PROG_NM])dnl\n-AC_REQUIRE([AC_SYS_NM_PARSE])dnl\n-AC_REQUIRE([AC_SYS_SYMBOL_UNDERSCORE])dnl\n AC_REQUIRE([AC_PROG_LN_S])dnl\n dnl\n \n@@ -345,10 +344,16 @@ libtool_flags=\"--cache-file=$cache_file\"\n test \"$enable_shared\" = no && libtool_flags=\"$libtool_flags --disable-shared\"\n test \"$enable_static\" = no && libtool_flags=\"$libtool_flags --disable-static\"\n test \"$enable_fast_install\" = no && libtool_flags=\"$libtool_flags --disable-fast-install\"\n-test \"$lt_dlopen\" = yes && libtool_flags=\"$libtool_flags --enable-dlopen\"\n-test \"$silent\" = yes && libtool_flags=\"$libtool_flags --silent\"\n test \"$ac_cv_prog_gcc\" = yes && libtool_flags=\"$libtool_flags --with-gcc\"\n test \"$ac_cv_prog_gnu_ld\" = yes && libtool_flags=\"$libtool_flags --with-gnu-ld\"\n+ifdef([AC_PROVIDE_AC_LIBTOOL_DLOPEN],\n+[libtool_flags=\"$libtool_flags --enable-dlopen\"])\n+ifdef([AC_PROVIDE_AC_LIBTOOL_WIN32_DLL],\n+[libtool_flags=\"$libtool_flags --enable-win32-dll\"])\n+AC_ARG_ENABLE(libtool-lock,\n+  [  --disable-libtool-lock  avoid locking (might break parallel builds)])\n+test \"x$enable_libtool_lock\" = xno && libtool_flags=\"$libtool_flags --disable-lock\"\n+test x\"$silent\" = xyes && libtool_flags=\"$libtool_flags --silent\"\n \n # Some flags need to be propagated to the compiler or linker for good\n # libtool support.\n@@ -384,33 +389,28 @@ case \"$host\" in\n   fi\n   ;;\n \n-*-*-cygwin*)\n-  AC_SYS_LIBTOOL_CYGWIN\n+ifdef([AC_PROVIDE_AC_LIBTOOL_WIN32_DLL],\n+[*-*-cygwin* | *-*-mingw*)\n+  AC_CHECK_TOOL(DLLTOOL, dlltool, false)\n+  AC_CHECK_TOOL(AS, as, false)\n+  AC_CHECK_TOOL(OBJDUMP, objdump, false)\n   ;;\n-\n+])\n esac\n-\n-# enable the --disable-libtool-lock switch\n-\n-AC_ARG_ENABLE(libtool-lock,\n-[  --disable-libtool-lock  force libtool not to do file locking],\n-need_locks=$enableval,\n-need_locks=yes)\n-\n-if test x\"$need_locks\" = xno; then\n-  libtool_flags=\"$libtool_flags --disable-lock\"\n-fi\n ])\n \n-# AC_LIBTOOL_DLOPEN - check for dlopen support\n-AC_DEFUN(AC_LIBTOOL_DLOPEN, [lt_dlopen=yes])\n+# AC_LIBTOOL_DLOPEN - enable checks for dlopen support\n+AC_DEFUN(AC_LIBTOOL_DLOPEN, [AC_BEFORE([$0],[AC_LIBTOOL_SETUP])])\n+\n+# AC_LIBTOOL_WIN32_DLL - declare package support for building win32 dll's\n+AC_DEFUN(AC_LIBTOOL_WIN32_DLL, [AC_BEFORE([$0], [AC_LIBTOOL_SETUP])])\n \n # AC_ENABLE_SHARED - implement the --enable-shared flag\n # Usage: AC_ENABLE_SHARED[(DEFAULT)]\n #   Where DEFAULT is either `yes' or `no'.  If omitted, it defaults to\n #   `yes'.\n-AC_DEFUN(AC_ENABLE_SHARED,\n-[define([AC_ENABLE_SHARED_DEFAULT], ifelse($1, no, no, yes))dnl\n+AC_DEFUN(AC_ENABLE_SHARED, [dnl\n+define([AC_ENABLE_SHARED_DEFAULT], ifelse($1, no, no, yes))dnl\n AC_ARG_ENABLE(shared,\n changequote(<<, >>)dnl\n <<  --enable-shared[=PKGS]  build shared libraries [default=>>AC_ENABLE_SHARED_DEFAULT],\n@@ -435,15 +435,15 @@ enable_shared=AC_ENABLE_SHARED_DEFAULT)dnl\n ])\n \n # AC_DISABLE_SHARED - set the default shared flag to --disable-shared\n-AC_DEFUN(AC_DISABLE_SHARED,\n-[AC_ENABLE_SHARED(no)])\n+AC_DEFUN(AC_DISABLE_SHARED, [AC_BEFORE([$0],[AC_LIBTOOL_SETUP])dnl\n+AC_ENABLE_SHARED(no)])\n \n # AC_ENABLE_STATIC - implement the --enable-static flag\n # Usage: AC_ENABLE_STATIC[(DEFAULT)]\n #   Where DEFAULT is either `yes' or `no'.  If omitted, it defaults to\n #   `yes'.\n-AC_DEFUN(AC_ENABLE_STATIC,\n-[define([AC_ENABLE_STATIC_DEFAULT], ifelse($1, no, no, yes))dnl\n+AC_DEFUN(AC_ENABLE_STATIC, [dnl\n+define([AC_ENABLE_STATIC_DEFAULT], ifelse($1, no, no, yes))dnl\n AC_ARG_ENABLE(static,\n changequote(<<, >>)dnl\n <<  --enable-static[=PKGS]  build static libraries [default=>>AC_ENABLE_STATIC_DEFAULT],\n@@ -468,16 +468,16 @@ enable_static=AC_ENABLE_STATIC_DEFAULT)dnl\n ])\n \n # AC_DISABLE_STATIC - set the default static flag to --disable-static\n-AC_DEFUN(AC_DISABLE_STATIC,\n-[AC_ENABLE_STATIC(no)])\n+AC_DEFUN(AC_DISABLE_STATIC, [AC_BEFORE([$0],[AC_LIBTOOL_SETUP])dnl\n+AC_ENABLE_STATIC(no)])\n \n \n # AC_ENABLE_FAST_INSTALL - implement the --enable-fast-install flag\n # Usage: AC_ENABLE_FAST_INSTALL[(DEFAULT)]\n #   Where DEFAULT is either `yes' or `no'.  If omitted, it defaults to\n #   `yes'.\n-AC_DEFUN(AC_ENABLE_FAST_INSTALL,\n-[define([AC_ENABLE_FAST_INSTALL_DEFAULT], ifelse($1, no, no, yes))dnl\n+AC_DEFUN(AC_ENABLE_FAST_INSTALL, [dnl\n+define([AC_ENABLE_FAST_INSTALL_DEFAULT], ifelse($1, no, no, yes))dnl\n AC_ARG_ENABLE(fast-install,\n changequote(<<, >>)dnl\n <<  --enable-fast-install[=PKGS]  optimize for fast installation [default=>>AC_ENABLE_FAST_INSTALL_DEFAULT],\n@@ -502,9 +502,8 @@ enable_fast_install=AC_ENABLE_FAST_INSTALL_DEFAULT)dnl\n ])\n \n # AC_ENABLE_FAST_INSTALL - set the default to --disable-fast-install\n-AC_DEFUN(AC_DISABLE_FAST_INSTALL,\n-[AC_ENABLE_FAST_INSTALL(no)])\n-\n+AC_DEFUN(AC_DISABLE_FAST_INSTALL, [AC_BEFORE([$0],[AC_LIBTOOL_SETUP])dnl\n+AC_ENABLE_FAST_INSTALL(no)])\n \n # AC_PROG_LD - find the path to the GNU or non-GNU linker\n AC_DEFUN(AC_PROG_LD,\n@@ -522,7 +521,7 @@ if test \"$ac_cv_prog_gcc\" = yes; then\n   case \"$ac_prog\" in\n     # Accept absolute paths.\n changequote(,)dnl\n-    /* | [A-Za-z]:[\\\\/]*)\n+    [\\\\/]* | [A-Za-z]:[\\\\/]*)\n       re_direlt='/[^/][^/]*/\\.\\./'\n changequote([,])dnl\n       # Canonicalize the path of ld\n@@ -548,10 +547,10 @@ else\n fi\n AC_CACHE_VAL(ac_cv_path_LD,\n [if test -z \"$LD\"; then\n-  IFS=\"${IFS= \t}\"; ac_save_ifs=\"$IFS\"; IFS=\"${IFS}:\"\n+  IFS=\"${IFS= \t}\"; ac_save_ifs=\"$IFS\"; IFS=\"${IFS}${PATH_SEPARATOR-:}\"\n   for ac_dir in $PATH; do\n     test -z \"$ac_dir\" && ac_dir=.\n-    if test -f \"$ac_dir/$ac_prog\"; then\n+    if test -f \"$ac_dir/$ac_prog\" || test -f \"$ac_dir/$ac_prog$ac_exeext\"; then\n       ac_cv_path_LD=\"$ac_dir/$ac_prog\"\n       # Check to see if the program is GNU ld.  I'd rather use --version,\n       # but apparently some GNU ld's only accept -v.\n@@ -596,10 +595,10 @@ AC_CACHE_VAL(ac_cv_path_NM,\n   # Let the user override the test.\n   ac_cv_path_NM=\"$NM\"\n else\n-  IFS=\"${IFS= \t}\"; ac_save_ifs=\"$IFS\"; IFS=\"${IFS}:\"\n+  IFS=\"${IFS= \t}\"; ac_save_ifs=\"$IFS\"; IFS=\"${IFS}${PATH_SEPARATOR-:}\"\n   for ac_dir in $PATH /usr/ccs/bin /usr/ucb /bin; do\n     test -z \"$ac_dir\" && ac_dir=.\n-    if test -f $ac_dir/nm; then\n+    if test -f $ac_dir/nm || test -f $ac_dir/nm$ac_exeext ; then\n       # Check to see if the nm accepts a BSD-compat flag.\n       # Adding the `sed 1q' prevents false positives on HP-UX, which says:\n       #   nm: unknown option \"B\" ignored\n@@ -623,227 +622,22 @@ AC_MSG_RESULT([$NM])\n AC_SUBST(NM)\n ])\n \n-# AC_SYS_NM_PARSE - Check for command to grab the raw symbol name followed\n-# by C symbol name from nm.\n-AC_DEFUN(AC_SYS_NM_PARSE,\n+# AC_CHECK_LIBM - check for math library\n+AC_DEFUN(AC_CHECK_LIBM,\n [AC_REQUIRE([AC_CANONICAL_HOST])dnl\n-AC_REQUIRE([AC_PROG_NM])dnl\n-# Check for command to grab the raw symbol name followed by C symbol from nm.\n-AC_MSG_CHECKING([command to parse $NM output])\n-AC_CACHE_VAL(ac_cv_sys_global_symbol_pipe,\n-[# These are sane defaults that work on at least a few old systems.\n-# {They come from Ultrix.  What could be older than Ultrix?!! ;)}\n-\n-changequote(,)dnl\n-# Character class describing NM global symbol codes.\n-ac_symcode='[BCDEGRST]'\n-\n-# Regexp to match symbols that can be accessed directly from C.\n-ac_sympat='\\([_A-Za-z][_A-Za-z0-9]*\\)'\n-\n-# Transform the above into a raw symbol and a C symbol.\n-ac_symxfrm='\\1 \\2\\3 \\3'\n-\n-# Transform an extracted symbol line into a proper C declaration\n-ac_global_symbol_to_cdecl=\"sed -n -e 's/^. .* \\(.*\\)$/extern char \\1;/p'\"\n-\n-# Define system-specific variables.\n-case \"$host_os\" in\n-aix*)\n-  ac_symcode='[BCDT]'\n-  ;;\n-cygwin* | mingw*)\n-  ac_symcode='[ABCDGISTW]'\n-  ;;\n-hpux*)\n-  ac_global_symbol_to_cdecl=\"sed -n -e 's/^T .* \\(.*\\)$/extern char \\1();/p' -e 's/^. .* \\(.*\\)$/extern char \\1;/p'\"\n+LIBM=\n+case \"$host\" in\n+*-*-beos* | *-*-cygwin*)\n+  # These system don't have libm\n   ;;\n-irix*)\n-  ac_symcode='[BCDEGRST]'\n+*-ncr-sysv4.3*)\n+  AC_CHECK_LIB(mw, _mwvalidcheckl, LIBM=\"-lmw\")\n+  AC_CHECK_LIB(m, main, LIBM=\"$LIBM -lm\")\n   ;;\n-solaris*)\n-  ac_symcode='[BDT]'\n+*)\n+  AC_CHECK_LIB(m, main, LIBM=\"-lm\")\n   ;;\n esac\n-\n-# If we're using GNU nm, then use its standard symbol codes.\n-if $NM -V 2>&1 | egrep '(GNU|with BFD)' > /dev/null; then\n-  ac_symcode='[ABCDGISTW]'\n-fi\n-changequote([,])dnl\n-\n-# Try without a prefix undercore, then with it.\n-for ac_symprfx in \"\" \"_\"; do\n-\n-  ac_cv_sys_global_symbol_pipe=\"sed -n -e 's/^.*[ \t]\\($ac_symcode\\)[ \t][ \t]*\\($ac_symprfx\\)$ac_sympat$/$ac_symxfrm/p'\"\n-\n-  # Check to see that the pipe works correctly.\n-  ac_pipe_works=no\n-  rm -f conftest.$ac_ext\n-  cat > conftest.$ac_ext <<EOF\n-#ifdef __cplusplus\n-extern \"C\" {\n-#endif\n-char nm_test_var;\n-void nm_test_func(){}\n-#ifdef __cplusplus\n-}\n-#endif\n-int main(){nm_test_var='a';nm_test_func;return 0;}\n-EOF\n-\n-  if AC_TRY_EVAL(ac_compile); then\n-    # Now try to grab the symbols.\n-    ac_nlist=conftest.nm\n-  \n-    if AC_TRY_EVAL(NM conftest.$ac_objext \\| $ac_cv_sys_global_symbol_pipe \\> $ac_nlist) && test -s \"$ac_nlist\"; then\n-\n-      # Try sorting and uniquifying the output.\n-      if sort \"$ac_nlist\" | uniq > \"$ac_nlist\"T; then\n-\tmv -f \"$ac_nlist\"T \"$ac_nlist\"\n-      else\n-\trm -f \"$ac_nlist\"T\n-      fi\n-\n-      # Make sure that we snagged all the symbols we need.\n-      if egrep ' nm_test_var$' \"$ac_nlist\" >/dev/null; then\n-\tif egrep ' nm_test_func$' \"$ac_nlist\" >/dev/null; then\n-\t  cat <<EOF > conftest.c\n-#ifdef __cplusplus\n-extern \"C\" {\n-#endif\n-\n-EOF\n-\t  # Now generate the symbol file.\n-\t  eval \"$ac_global_symbol_to_cdecl\"' < \"$ac_nlist\" >> conftest.c'\n-\n-\t  cat <<EOF >> conftest.c\n-#if defined (__STDC__) && __STDC__\n-# define lt_ptr_t void *\n-#else\n-# define lt_ptr_t char *\n-# define const\n-#endif\n-\n-/* The mapping between symbol names and symbols. */\n-const struct {\n-  const char *name;\n-  lt_ptr_t address;\n-}\n-changequote(,)dnl\n-lt_preloaded_symbols[] =\n-changequote([,])dnl\n-{\n-EOF\n-\tsed 's/^. \\(.*\\) \\(.*\\)$/  {\"\\2\", (lt_ptr_t) \\&\\2},/' < \"$ac_nlist\" >> conftest.c\n-\tcat <<\\EOF >> conftest.c\n-  {0, (lt_ptr_t) 0}\n-};\n-\n-#ifdef __cplusplus\n-}\n-#endif\n-EOF\n-\t  # Now try linking the two files.\n-\t  mv conftest.$ac_objext conftestm.$ac_objext\n-\t  ac_save_LIBS=\"$LIBS\"\n-\t  ac_save_CFLAGS=\"$CFLAGS\"\n-\t  LIBS=\"conftestm.$ac_objext\"\n-\t  CFLAGS=\"$CFLAGS$no_builtin_flag\"\n-\t  if AC_TRY_EVAL(ac_link) && test -s conftest; then\n-\t    ac_pipe_works=yes\n-\t  else\n-\t    echo \"configure: failed program was:\" >&AC_FD_CC\n-\t    cat conftest.c >&AC_FD_CC\n-\t  fi\n-\t  LIBS=\"$ac_save_LIBS\"\n-\t  CFLAGS=\"$ac_save_CFLAGS\"\n-\telse\n-\t  echo \"cannot find nm_test_func in $ac_nlist\" >&AC_FD_CC\n-\tfi\n-      else\n-\techo \"cannot find nm_test_var in $ac_nlist\" >&AC_FD_CC\n-      fi\n-    else\n-      echo \"cannot run $ac_cv_sys_global_symbol_pipe\" >&AC_FD_CC\n-    fi\n-  else\n-    echo \"$progname: failed program was:\" >&AC_FD_CC\n-    cat conftest.c >&AC_FD_CC\n-  fi\n-  rm -rf conftest*\n-\n-  # Do not use the global_symbol_pipe unless it works.\n-  if test \"$ac_pipe_works\" = yes; then\n-    if test x\"$ac_symprfx\" = x\"_\"; then\n-      ac_cv_sys_symbol_underscore=yes\n-    else\n-      ac_cv_sys_symbol_underscore=no\n-    fi\n-    break\n-  else\n-    ac_cv_sys_global_symbol_pipe=\n-  fi\n-done\n-])\n-\n-ac_result=yes\n-if test -z \"$ac_cv_sys_global_symbol_pipe\"; then\n-   ac_result=no\n-fi\n-AC_MSG_RESULT($ac_result)\n-])\n-\n-# AC_SYS_LIBTOOL_CYGWIN - find tools needed on cygwin\n-AC_DEFUN(AC_SYS_LIBTOOL_CYGWIN,\n-[AC_CHECK_TOOL(DLLTOOL, dlltool, false)\n-AC_CHECK_TOOL(AS, as, false)\n-])\n-\n-# AC_SYS_SYMBOL_UNDERSCORE - does the compiler prefix global symbols\n-#                            with an underscore?\n-AC_DEFUN(AC_SYS_SYMBOL_UNDERSCORE,\n-[AC_REQUIRE([AC_PROG_NM])dnl\n-AC_REQUIRE([AC_SYS_NM_PARSE])dnl\n-AC_MSG_CHECKING([for _ prefix in compiled symbols])\n-AC_CACHE_VAL(ac_cv_sys_symbol_underscore,\n-[ac_cv_sys_symbol_underscore=no\n-cat > conftest.$ac_ext <<EOF\n-void nm_test_func(){}\n-int main(){nm_test_func;return 0;}\n-EOF\n-if AC_TRY_EVAL(ac_compile); then\n-  # Now try to grab the symbols.\n-  ac_nlist=conftest.nm\n-  if AC_TRY_EVAL(NM conftest.$ac_objext \\| $ac_cv_sys_global_symbol_pipe \\> $ac_nlist) && test -s \"$ac_nlist\"; then\n-    # See whether the symbols have a leading underscore.\n-    if egrep '^. _nm_test_func' \"$ac_nlist\" >/dev/null; then\n-      ac_cv_sys_symbol_underscore=yes\n-    else\n-      if egrep '^. nm_test_func ' \"$ac_nlist\" >/dev/null; then\n-\t:\n-      else\n-\techo \"configure: cannot find nm_test_func in $ac_nlist\" >&AC_FD_CC\n-      fi\n-    fi\n-  else\n-    echo \"configure: cannot run $ac_cv_sys_global_symbol_pipe\" >&AC_FD_CC\n-  fi\n-else\n-  echo \"configure: failed program was:\" >&AC_FD_CC\n-  cat conftest.c >&AC_FD_CC\n-fi\n-rm -rf conftest*\n-])\n-AC_MSG_RESULT($ac_cv_sys_symbol_underscore)\n-USE_SYMBOL_UNDERSCORE=${ac_cv_sys_symbol_underscore=no}\n-AC_SUBST(USE_SYMBOL_UNDERSCORE)dnl\n-])\n-\n-# AC_CHECK_LIBM - check for math library\n-AC_DEFUN(AC_CHECK_LIBM, [\n-AC_CHECK_LIB(mw, _mwvalidcheckl)\n-AC_CHECK_LIB(m, cos)\n ])\n \n # AC_LIBLTDL_CONVENIENCE[(dir)] - sets LIBLTDL to the link flags for\n@@ -854,13 +648,14 @@ AC_CHECK_LIB(m, cos)\n # '${top_builddir}/' (note the single quotes!) if your package is not\n # flat, and, if you're not using automake, define top_builddir as\n # appropriate in the Makefiles.\n-AC_DEFUN(AC_LIBLTDL_CONVENIENCE, [\n+AC_DEFUN(AC_LIBLTDL_CONVENIENCE, [AC_BEFORE([$0],[AC_LIBTOOL_SETUP])dnl\n   case \"$enable_ltdl_convenience\" in\n   no) AC_MSG_ERROR([this package needs a convenience libltdl]) ;;\n   \"\") enable_ltdl_convenience=yes\n       ac_configure_args=\"$ac_configure_args --enable-ltdl-convenience\" ;;\n   esac\n   LIBLTDL=ifelse($#,1,$1,['${top_builddir}/libltdl'])/libltdlc.la\n+  INCLTDL=ifelse($#,1,-I$1,['-I${top_builddir}/libltdl'])\n ])\n \n # AC_LIBLTDL_INSTALLABLE[(dir)] - sets LIBLTDL to the link flags for\n@@ -872,16 +667,23 @@ AC_DEFUN(AC_LIBLTDL_CONVENIENCE, [\n # flat, and, if you're not using automake, define top_builddir as\n # appropriate in the Makefiles.\n # In the future, this macro may have to be called after AC_PROG_LIBTOOL.\n-AC_DEFUN(AC_LIBLTDL_INSTALLABLE, [\n-  AC_CHECK_LIB(ltdl, main, LIBLTDL=\"-lltdl\", [\n-    case \"$enable_ltdl_install\" in\n-    no) AC_MSG_WARN([libltdl not installed, but installation disabled]) ;;\n-    \"\") enable_ltdl_install=yes\n-        ac_configure_args=\"$ac_configure_args --enable-ltdl-install\" ;;\n-    esac\n+AC_DEFUN(AC_LIBLTDL_INSTALLABLE, [AC_BEFORE([$0],[AC_LIBTOOL_SETUP])dnl\n+  AC_CHECK_LIB(ltdl, main,\n+  [test x\"$enable_ltdl_install\" != xyes && enable_ltdl_install=no],\n+  [if test x\"$enable_ltdl_install\" = xno; then\n+     AC_MSG_WARN([libltdl not installed, but installation disabled])\n+   else\n+     enable_ltdl_install=yes\n+   fi\n   ])\n-  if test x\"$enable_ltdl_install\" != x\"no\"; then\n+  if test x\"$enable_ltdl_install\" = x\"yes\"; then\n+    ac_configure_args=\"$ac_configure_args --enable-ltdl-install\"\n     LIBLTDL=ifelse($#,1,$1,['${top_builddir}/libltdl'])/libltdl.la\n+    INCLTDL=ifelse($#,1,-I$1,['-I${top_builddir}/libltdl'])\n+  else\n+    ac_configure_args=\"$ac_configure_args --enable-ltdl-install=no\"\n+    LIBLTDL=\"-lltdl\"\n+    INCLTDL=\n   fi\n ])\n \n@@ -893,7 +695,7 @@ AC_DEFUN(AM_DISABLE_SHARED, [indir([AC_DISABLE_SHARED], $@)])dnl\n AC_DEFUN(AM_DISABLE_STATIC, [indir([AC_DISABLE_STATIC], $@)])dnl\n AC_DEFUN(AM_PROG_LD, [indir([AC_PROG_LD])])dnl\n AC_DEFUN(AM_PROG_NM, [indir([AC_PROG_NM])])dnl\n-AC_DEFUN(AM_SYS_NM_PARSE, [indir([AC_SYS_NM_PARSE])])dnl\n-AC_DEFUN(AM_SYS_SYMBOL_UNDERSCORE, [indir([AC_SYS_SYMBOL_UNDERSCORE])])dnl\n-AC_DEFUN(AM_SYS_LIBTOOL_CYGWIN, [indir([AC_SYS_LIBTOOL_CYGWIN])])dnl\n+\n+dnl This is just to silence aclocal about the macro not being used\n+ifelse([AC_DISABLE_FAST_INSTALL])dnl\n "}, {"sha": "189b94214a7376ff4f89110723199d92b7b2a0a4", "filename": "boehm-gc/allchblk.c", "status": "modified", "additions": 489, "deletions": 170, "changes": 659, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20bbd3cd53a80ddafa56a5d21337aae0c24f94ca/boehm-gc%2Fallchblk.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20bbd3cd53a80ddafa56a5d21337aae0c24f94ca/boehm-gc%2Fallchblk.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fallchblk.c?ref=20bbd3cd53a80ddafa56a5d21337aae0c24f94ca", "patch": "@@ -1,7 +1,8 @@\n /* \n  * Copyright 1988, 1989 Hans-J. Boehm, Alan J. Demers\n  * Copyright (c) 1991-1994 by Xerox Corporation.  All rights reserved.\n- * Copyright (c) 1998 by Silicon Graphics.  All rights reserved.\n+ * Copyright (c) 1998-1999 by Silicon Graphics.  All rights reserved.\n+ * Copyright (c) 1999 by Hewlett-Packard Company. All rights reserved.\n  *\n  * THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED\n  * OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.\n@@ -12,7 +13,6 @@\n  * provided the above notices are retained, and a notice that the code was\n  * modified is included with the above copyright notice.\n  */\n-/* Boehm, August 9, 1995 5:08 pm PDT */\n \n #define DEBUG\n #undef DEBUG\n@@ -21,39 +21,68 @@\n \n \n /*\n- * allocate/free routines for heap blocks\n- * Note that everything called from outside the garbage collector\n- * should be prepared to abort at any point as the result of a signal.\n+ * Free heap blocks are kept on one of several free lists,\n+ * depending on the size of the block.  Each free list is doubly linked.\n+ * Adjacent free blocks are coalesced.\n  */\n \n-/*\n- * Free heap blocks are kept on a list sorted by address.\n- * The hb_hdr.hbh_sz field of a free heap block contains the length\n- * (in bytes) of the entire block.\n- * Neighbors are coalesced.\n- */\n  \n # define MAX_BLACK_LIST_ALLOC (2*HBLKSIZE)\n \t\t/* largest block we will allocate starting on a black   */\n \t\t/* listed block.  Must be >= HBLKSIZE.\t\t\t*/\n \n-struct hblk * GC_hblkfreelist = 0;\n \n-struct hblk *GC_savhbp = (struct hblk *)0;  /* heap block preceding next */\n-\t\t\t\t\t /* block to be examined by   */\n-\t\t\t\t\t /* GC_allochblk.                */\n+# define UNIQUE_THRESHOLD 32\n+\t/* Sizes up to this many HBLKs each have their own free list    */\n+# define HUGE_THRESHOLD 256\n+\t/* Sizes of at least this many heap blocks are mapped to a\t*/\n+\t/* single free list.\t\t\t\t\t\t*/\n+# define FL_COMPRESSION 8\n+\t/* In between sizes map this many distinct sizes to a single\t*/\n+\t/* bin.\t\t\t\t\t\t\t\t*/\n+\n+# define N_HBLK_FLS (HUGE_THRESHOLD - UNIQUE_THRESHOLD)/FL_COMPRESSION \\\n+\t\t\t\t + UNIQUE_THRESHOLD\n+\n+struct hblk * GC_hblkfreelist[N_HBLK_FLS+1] = { 0 };\n+\n+/* Map a number of blocks to the appropriate large block free list index. */\n+int GC_hblk_fl_from_blocks(blocks_needed)\n+word blocks_needed;\n+{\n+    if (blocks_needed <= UNIQUE_THRESHOLD) return blocks_needed;\n+    if (blocks_needed >= HUGE_THRESHOLD) return N_HBLK_FLS;\n+    return (blocks_needed - UNIQUE_THRESHOLD)/FL_COMPRESSION\n+\t\t\t\t\t+ UNIQUE_THRESHOLD;\n+    \n+}\n+\n+# define HBLK_IS_FREE(hdr) ((hdr) -> hb_map == GC_invalid_map)\n+# define PHDR(hhdr) HDR(hhdr -> hb_prev)\n+# define NHDR(hhdr) HDR(hhdr -> hb_next)\n+\n+# ifdef USE_MUNMAP\n+#   define IS_MAPPED(hhdr) (((hhdr) -> hb_flags & WAS_UNMAPPED) == 0)\n+# else  /* !USE_MMAP */\n+#   define IS_MAPPED(hhdr) 1\n+# endif /* USE_MUNMAP */\n \n # if !defined(NO_DEBUGGING)\n void GC_print_hblkfreelist()\n {\n-    struct hblk * h = GC_hblkfreelist;\n+    struct hblk * h;\n     word total_free = 0;\n-    hdr * hhdr = HDR(h);\n+    hdr * hhdr;\n     word sz;\n+    int i;\n     \n-    while (h != 0) {\n+    for (i = 0; i <= N_HBLK_FLS; ++i) {\n+      h = GC_hblkfreelist[i];\n+      if (0 != h) GC_printf1(\"Free list %ld:\\n\", (unsigned long)i);\n+      while (h != 0) {\n+        hhdr = HDR(h);\n         sz = hhdr -> hb_sz;\n-    \tGC_printf2(\"0x%lx size %lu \", (unsigned long)h, (unsigned long)sz);\n+    \tGC_printf2(\"\\t0x%lx size %lu \", (unsigned long)h, (unsigned long)sz);\n     \ttotal_free += sz;\n         if (GC_is_black_listed(h, HBLKSIZE) != 0) {\n              GC_printf0(\"start black listed\\n\");\n@@ -63,11 +92,90 @@ void GC_print_hblkfreelist()\n              GC_printf0(\"not black listed\\n\");\n         }\n         h = hhdr -> hb_next;\n-        hhdr = HDR(h);\n+      }\n+    }\n+    if (total_free != GC_large_free_bytes) {\n+\tGC_printf1(\"GC_large_free_bytes = %lu (INCONSISTENT!!)\\n\",\n+\t\t   (unsigned long) GC_large_free_bytes);\n     }\n     GC_printf1(\"Total of %lu bytes on free list\\n\", (unsigned long)total_free);\n }\n \n+/* Return the free list index on which the block described by the header */\n+/* appears, or -1 if it appears nowhere.\t\t\t\t */\n+int free_list_index_of(wanted)\n+hdr * wanted;\n+{\n+    struct hblk * h;\n+    hdr * hhdr;\n+    int i;\n+    \n+    for (i = 0; i <= N_HBLK_FLS; ++i) {\n+      h = GC_hblkfreelist[i];\n+      while (h != 0) {\n+        hhdr = HDR(h);\n+\tif (hhdr == wanted) return i;\n+        h = hhdr -> hb_next;\n+      }\n+    }\n+    return -1;\n+}\n+\n+void GC_dump_regions()\n+{\n+    unsigned i;\n+    ptr_t start, end;\n+    ptr_t p;\n+    size_t bytes;\n+    hdr *hhdr;\n+    for (i = 0; i < GC_n_heap_sects; ++i) {\n+\tstart = GC_heap_sects[i].hs_start;\n+\tbytes = GC_heap_sects[i].hs_bytes;\n+\tend = start + bytes;\n+\t/* Merge in contiguous sections.\t*/\n+\t  while (i+1 < GC_n_heap_sects && GC_heap_sects[i+1].hs_start == end) {\n+\t    ++i;\n+\t    end = GC_heap_sects[i].hs_start + GC_heap_sects[i].hs_bytes;\n+\t  }\n+\tGC_printf2(\"***Section from 0x%lx to 0x%lx\\n\", start, end);\n+\tfor (p = start; p < end;) {\n+\t    hhdr = HDR(p);\n+\t    GC_printf1(\"\\t0x%lx \", (unsigned long)p);\n+\t    if (IS_FORWARDING_ADDR_OR_NIL(hhdr)) {\n+\t\tGC_printf1(\"Missing header!!\\n\", hhdr);\n+\t\tp += HBLKSIZE;\n+\t\tcontinue;\n+\t    }\n+\t    if (HBLK_IS_FREE(hhdr)) {\n+                int correct_index = GC_hblk_fl_from_blocks(\n+\t\t\t\t\tdivHBLKSZ(hhdr -> hb_sz));\n+\t        int actual_index;\n+\t\t\n+\t\tGC_printf1(\"\\tfree block of size 0x%lx bytes\",\n+\t\t\t   (unsigned long)(hhdr -> hb_sz));\n+\t \tif (IS_MAPPED(hhdr)) {\n+\t\t    GC_printf0(\"\\n\");\n+\t\t} else {\n+\t\t    GC_printf0(\"(unmapped)\\n\");\n+\t\t}\n+\t\tactual_index = free_list_index_of(hhdr);\n+\t\tif (-1 == actual_index) {\n+\t\t    GC_printf1(\"\\t\\tBlock not on free list %ld!!\\n\",\n+\t\t\t\tcorrect_index);\n+\t\t} else if (correct_index != actual_index) {\n+\t\t    GC_printf2(\"\\t\\tBlock on list %ld, should be on %ld!!\\n\",\n+\t\t\t       actual_index, correct_index);\n+\t\t}\n+\t\tp += hhdr -> hb_sz;\n+\t    } else {\n+\t\tGC_printf1(\"\\tused for blocks of size 0x%lx bytes\\n\",\n+\t\t\t   (unsigned long)WORDS_TO_BYTES(hhdr -> hb_sz));\n+\t\tp += HBLKSIZE * OBJ_SZ_TO_BLOCKS(hhdr -> hb_sz);\n+\t    }\n+\t}\n+    }\n+}\n+\n # endif /* NO_DEBUGGING */\n \n /* Initialize hdr for a block containing the indicated size and \t*/\n@@ -100,18 +208,265 @@ unsigned char flags;\n     return(TRUE);\n }\n \n-#ifdef EXACT_FIRST\n-#   define LAST_TRIP 2\n-#else\n-#   define LAST_TRIP 1\n-#endif\n+#define FL_UNKNOWN -1\n+/*\n+ * Remove hhdr from the appropriate free list.\n+ * We assume it is on the nth free list, or on the size\n+ * appropriate free list if n is FL_UNKNOWN.\n+ */\n+void GC_remove_from_fl(hhdr, n)\n+hdr * hhdr;\n+int n;\n+{\n+    GC_ASSERT(((hhdr -> hb_sz) & (HBLKSIZE-1)) == 0);\n+    if (hhdr -> hb_prev == 0) {\n+        int index;\n+\tif (FL_UNKNOWN == n) {\n+            index = GC_hblk_fl_from_blocks(divHBLKSZ(hhdr -> hb_sz));\n+\t} else {\n+\t    index = n;\n+\t}\n+\tGC_ASSERT(HDR(GC_hblkfreelist[index]) == hhdr);\n+\tGC_hblkfreelist[index] = hhdr -> hb_next;\n+    } else {\n+\tPHDR(hhdr) -> hb_next = hhdr -> hb_next;\n+    }\n+    if (0 != hhdr -> hb_next) {\n+\tGC_ASSERT(!IS_FORWARDING_ADDR_OR_NIL(NHDR(hhdr)));\n+\tNHDR(hhdr) -> hb_prev = hhdr -> hb_prev;\n+    }\n+}\n+\n+/*\n+ * Return a pointer to the free block ending just before h, if any.\n+ */\n+struct hblk * GC_free_block_ending_at(h)\n+struct hblk *h;\n+{\n+    struct hblk * p = h - 1;\n+    hdr * phdr = HDR(p);\n+\n+    while (0 != phdr && IS_FORWARDING_ADDR_OR_NIL(phdr)) {\n+\tp = FORWARDED_ADDR(p,phdr);\n+\tphdr = HDR(p);\n+    }\n+    if (0 != phdr && HBLK_IS_FREE(phdr)) return p;\n+    p = GC_prev_block(h - 1);\n+    if (0 != p) {\n+      phdr = HDR(p);\n+      if (HBLK_IS_FREE(phdr) && (ptr_t)p + phdr -> hb_sz == (ptr_t)h) {\n+\treturn p;\n+      }\n+    }\n+    return 0;\n+}\n+\n+/*\n+ * Add hhdr to the appropriate free list.\n+ * We maintain individual free lists sorted by address.\n+ */\n+void GC_add_to_fl(h, hhdr)\n+struct hblk *h;\n+hdr * hhdr;\n+{\n+    int index = GC_hblk_fl_from_blocks(divHBLKSZ(hhdr -> hb_sz));\n+    struct hblk *second = GC_hblkfreelist[index];\n+#   ifdef GC_ASSERTIONS\n+      struct hblk *next = (struct hblk *)((word)h + hhdr -> hb_sz);\n+      hdr * nexthdr = HDR(next);\n+      struct hblk *prev = GC_free_block_ending_at(h);\n+      hdr * prevhdr = HDR(prev);\n+      GC_ASSERT(nexthdr == 0 || !HBLK_IS_FREE(nexthdr) || !IS_MAPPED(nexthdr));\n+      GC_ASSERT(prev == 0 || !HBLK_IS_FREE(prevhdr) || !IS_MAPPED(prevhdr));\n+#   endif\n+    GC_ASSERT(((hhdr -> hb_sz) & (HBLKSIZE-1)) == 0);\n+    GC_hblkfreelist[index] = h;\n+    hhdr -> hb_next = second;\n+    hhdr -> hb_prev = 0;\n+    if (0 != second) HDR(second) -> hb_prev = h;\n+    GC_invalidate_map(hhdr);\n+}\n+\n+#ifdef USE_MUNMAP\n+\n+/* Unmap blocks that haven't been recently touched.  This is the only way */\n+/* way blocks are ever unmapped.\t\t\t\t\t  */\n+void GC_unmap_old(void)\n+{\n+    struct hblk * h;\n+    hdr * hhdr;\n+    word sz;\n+    unsigned short last_rec, threshold;\n+    int i;\n+#   define UNMAP_THRESHOLD 6\n+    \n+    for (i = 0; i <= N_HBLK_FLS; ++i) {\n+      for (h = GC_hblkfreelist[i]; 0 != h; h = hhdr -> hb_next) {\n+        hhdr = HDR(h);\n+\tif (!IS_MAPPED(hhdr)) continue;\n+\tthreshold = (unsigned short)(GC_gc_no - UNMAP_THRESHOLD);\n+\tlast_rec = hhdr -> hb_last_reclaimed;\n+\tif (last_rec > GC_gc_no\n+\t    || last_rec < threshold && threshold < GC_gc_no\n+\t\t\t\t       /* not recently wrapped */) {\n+          sz = hhdr -> hb_sz;\n+\t  GC_unmap((ptr_t)h, sz);\n+\t  hhdr -> hb_flags |= WAS_UNMAPPED;\n+    \t}\n+      }\n+    }  \n+}\n+\n+/* Merge all unmapped blocks that are adjacent to other free\t\t*/\n+/* blocks.  This may involve remapping, since all blocks are either\t*/\n+/* fully mapped or fully unmapped.\t\t\t\t\t*/\n+void GC_merge_unmapped(void)\n+{\n+    struct hblk * h, *next;\n+    hdr * hhdr, *nexthdr;\n+    word size, nextsize;\n+    int i;\n+    \n+    for (i = 0; i <= N_HBLK_FLS; ++i) {\n+      h = GC_hblkfreelist[i];\n+      while (h != 0) {\n+\thhdr = HDR(h);\n+\tsize = hhdr->hb_sz;\n+\tnext = (struct hblk *)((word)h + size);\n+\tnexthdr = HDR(next);\n+\t/* Coalesce with successor, if possible */\n+\t  if (0 != nexthdr && HBLK_IS_FREE(nexthdr)) {\n+\t    nextsize = nexthdr -> hb_sz;\n+\t    if (IS_MAPPED(hhdr)) {\n+\t      GC_ASSERT(!IS_MAPPED(nexthdr));\n+\t      /* make both consistent, so that we can merge */\n+\t        if (size > nextsize) {\n+\t\t  GC_remap((ptr_t)next, nextsize);\n+\t\t} else {\n+\t\t  GC_unmap((ptr_t)h, size);\n+\t\t  hhdr -> hb_flags |= WAS_UNMAPPED;\n+\t\t}\n+\t    } else if (IS_MAPPED(nexthdr)) {\n+\t      GC_ASSERT(!IS_MAPPED(hhdr));\n+\t      if (size > nextsize) {\n+\t\tGC_unmap((ptr_t)next, nextsize);\n+\t      } else {\n+\t\tGC_remap((ptr_t)h, size);\n+\t\thhdr -> hb_flags &= ~WAS_UNMAPPED;\n+\t      }\n+\t    } else {\n+\t      /* Unmap any gap in the middle */\n+\t\tGC_unmap_gap((ptr_t)h, size, (ptr_t)next, nexthdr -> hb_sz);\n+\t    }\n+\t    /* If they are both unmapped, we merge, but leave unmapped. */\n+\t    GC_remove_from_fl(hhdr, i);\n+\t    GC_remove_from_fl(nexthdr, FL_UNKNOWN);\n+\t    hhdr -> hb_sz += nexthdr -> hb_sz; \n+\t    GC_remove_header(next);\n+\t    GC_add_to_fl(h, hhdr); \n+\t    /* Start over at beginning of list */\n+\t    h = GC_hblkfreelist[i];\n+\t  } else /* not mergable with successor */ {\n+\t    h = hhdr -> hb_next;\n+\t  }\n+      } /* while (h != 0) ... */\n+    } /* for ... */\n+}\n+\n+#endif /* USE_MUNMAP */\n+\n+/*\n+ * Return a pointer to a block starting at h of length bytes.\n+ * Memory for the block is mapped.\n+ * Remove the block from its free list, and return the remainder (if any)\n+ * to its appropriate free list.\n+ * May fail by returning 0.\n+ * The header for the returned block must be set up by the caller.\n+ * If the return value is not 0, then hhdr is the header for it.\n+ */\n+struct hblk * GC_get_first_part(h, hhdr, bytes, index)\n+struct hblk *h;\n+hdr * hhdr;\n+word bytes;\n+int index;\n+{\n+    word total_size = hhdr -> hb_sz;\n+    struct hblk * rest;\n+    hdr * rest_hdr;\n+\n+    GC_ASSERT((total_size & (HBLKSIZE-1)) == 0);\n+    GC_remove_from_fl(hhdr, index);\n+    if (total_size == bytes) return h;\n+    rest = (struct hblk *)((word)h + bytes);\n+    if (!GC_install_header(rest)) return(0);\n+    rest_hdr = HDR(rest);\n+    rest_hdr -> hb_sz = total_size - bytes;\n+    rest_hdr -> hb_flags = 0;\n+#   ifdef GC_ASSERTIONS\n+      // Mark h not free, to avoid assertion about adjacent free blocks.\n+        hhdr -> hb_map = 0;\n+#   endif\n+    GC_add_to_fl(rest, rest_hdr);\n+    return h;\n+}\n+\n+/*\n+ * H is a free block.  N points at an address inside it.\n+ * A new header for n has already been set up.  Fix up h's header\n+ * to reflect the fact that it is being split, move it to the\n+ * appropriate free list.\n+ * N replaces h in the original free list.\n+ *\n+ * Nhdr is not completely filled in, since it is about to allocated.\n+ * It may in fact end up on the wrong free list for its size.\n+ * (Hence adding it to a free list is silly.  But this path is hopefully\n+ * rare enough that it doesn't matter.  The code is cleaner this way.)\n+ */\n+void GC_split_block(h, hhdr, n, nhdr, index)\n+struct hblk *h;\n+hdr * hhdr;\n+struct hblk *n;\n+hdr * nhdr;\n+int index;\t/* Index of free list */\n+{\n+    word total_size = hhdr -> hb_sz;\n+    word h_size = (word)n - (word)h;\n+    struct hblk *prev = hhdr -> hb_prev;\n+    struct hblk *next = hhdr -> hb_next;\n+\n+    /* Replace h with n on its freelist */\n+      nhdr -> hb_prev = prev;\n+      nhdr -> hb_next = next;\n+      nhdr -> hb_sz = total_size - h_size;\n+      nhdr -> hb_flags = 0;\n+      if (0 != prev) {\n+\tHDR(prev) -> hb_next = n;\n+      } else {\n+        GC_hblkfreelist[index] = n;\n+      }\n+      if (0 != next) {\n+\tHDR(next) -> hb_prev = n;\n+      }\n+#     ifdef GC_ASSERTIONS\n+\tnhdr -> hb_map = 0;\t/* Don't fail test for consecutive\t*/\n+\t\t\t\t/* free blocks in GC_add_to_fl.\t\t*/\n+#     endif\n+#   ifdef USE_MUNMAP\n+      hhdr -> hb_last_reclaimed = GC_gc_no;\n+#   endif\n+    hhdr -> hb_sz = h_size;\n+    GC_add_to_fl(h, hhdr);\n+    GC_invalidate_map(nhdr);\n+}\n \t\n+struct hblk * GC_allochblk_nth();\n+\n /*\n  * Allocate (and return pointer to) a heap block\n- *   for objects of size sz words.\n+ *   for objects of size sz words, searching the nth free list.\n  *\n  * NOTE: We set obj_map field in header correctly.\n- *       Caller is resposnsible for building an object freelist in block.\n+ *       Caller is responsible for building an object freelist in block.\n  *\n  * We clear the block if it is destined for large objects, and if\n  * kind requires that newly allocated objects be cleared.\n@@ -122,44 +477,42 @@ word sz;\n int kind;\n unsigned char flags;  /* IGNORE_OFF_PAGE or 0 */\n {\n-    register struct hblk *thishbp;\n-    register hdr * thishdr;\t\t/* Header corr. to thishbp */\n+    int start_list = GC_hblk_fl_from_blocks(OBJ_SZ_TO_BLOCKS(sz));\n+    int i;\n+    for (i = start_list; i <= N_HBLK_FLS; ++i) {\n+\tstruct hblk * result = GC_allochblk_nth(sz, kind, flags, i);\n+\tif (0 != result) return result;\n+    }\n+    return 0;\n+}\n+/*\n+ * The same, but with search restricted to nth free list.\n+ */\n+struct hblk *\n+GC_allochblk_nth(sz, kind, flags, n)\n+word sz;\n+int kind;\n+unsigned char flags;  /* IGNORE_OFF_PAGE or 0 */\n+int n;\n+{\n     register struct hblk *hbp;\n     register hdr * hhdr;\t\t/* Header corr. to hbp */\n-    struct hblk *prevhbp;\n-    register hdr * phdr;\t\t/* Header corr. to prevhbp */\n+    register struct hblk *thishbp;\n+    register hdr * thishdr;\t\t/* Header corr. to hbp */\n     signed_word size_needed;    /* number of bytes in requested objects */\n     signed_word size_avail;\t/* bytes available in this block\t*/\n-    int trip_count = 0;\n \n     size_needed = HBLKSIZE * OBJ_SZ_TO_BLOCKS(sz);\n \n     /* search for a big enough block in free list */\n-\thbp = GC_savhbp;\n+\thbp = GC_hblkfreelist[n];\n \thhdr = HDR(hbp);\n-\tfor(;;) {\n-\n-\t    prevhbp = hbp;\n-\t    phdr = hhdr;\n-\t    hbp = (prevhbp == 0? GC_hblkfreelist : phdr->hb_next);\n-\t    hhdr = HDR(hbp);\n-\n-\t    if( prevhbp == GC_savhbp) {\n-\t\tif (trip_count == LAST_TRIP) return(0);\n-\t\t++trip_count;\n-\t    }\n-\n-\t    if( hbp == 0 ) continue;\n-\n+\tfor(; 0 != hbp; hbp = hhdr -> hb_next, hhdr = HDR(hbp)) {\n \t    size_avail = hhdr->hb_sz;\n-#\t    ifdef EXACT_FIRST\n-\t\tif (trip_count <= 1 && size_avail != size_needed) continue;\n-#\t    endif\n \t    if (size_avail < size_needed) continue;\n #\t    ifdef PRESERVE_LAST\n \t\tif (size_avail != size_needed\n-\t\t    && !GC_incremental\n-\t\t    && GC_in_last_heap_sect(hbp) && GC_should_collect()) {\n+\t\t    && !GC_incremental && GC_should_collect()) {\n \t\t    continue;\n \t\t} \n #\t    endif\n@@ -170,13 +523,14 @@ unsigned char flags;  /* IGNORE_OFF_PAGE or 0 */\n \t      signed_word next_size;\n \t      \n \t      thishbp = hhdr -> hb_next;\n-\t      if (thishbp == 0) thishbp = GC_hblkfreelist; \n-\t      thishdr = HDR(thishbp);\n-\t      next_size = (signed_word)(thishdr -> hb_sz);\n-\t      if (next_size < size_avail\n+\t      if (thishbp != 0) {\n+\t        thishdr = HDR(thishbp);\n+\t        next_size = (signed_word)(thishdr -> hb_sz);\n+\t        if (next_size < size_avail\n \t          && next_size >= size_needed\n \t          && !GC_is_black_listed(thishbp, (word)size_needed)) {\n \t          continue;\n+\t        }\n \t      }\n \t    }\n \t    if ( !IS_UNCOLLECTABLE(kind) &&\n@@ -198,32 +552,32 @@ unsigned char flags;  /* IGNORE_OFF_PAGE or 0 */\n \t      thishbp = lasthbp;\n \t      if (size_avail >= size_needed) {\n \t        if (thishbp != hbp && GC_install_header(thishbp)) {\n+\t\t  /* Make sure it's mapped before we mangle it. */\n+#\t\t    ifdef USE_MUNMAP\n+\t\t      if (!IS_MAPPED(hhdr)) {\n+\t\t        GC_remap((ptr_t)hbp, size_avail);\n+\t\t        hhdr -> hb_flags &= ~WAS_UNMAPPED;\n+\t\t      }\n+#\t\t    endif\n \t          /* Split the block at thishbp */\n \t              thishdr = HDR(thishbp);\n-\t              /* GC_invalidate_map not needed, since we will\t*/\n-\t              /* allocate this block.\t\t\t\t*/\n-\t\t      thishdr -> hb_next = hhdr -> hb_next;\n-\t\t      thishdr -> hb_sz = size_avail;\n-\t\t      hhdr -> hb_sz = (ptr_t)thishbp - (ptr_t)hbp;\n-\t\t      hhdr -> hb_next = thishbp;\n+\t\t      GC_split_block(hbp, hhdr, thishbp, thishdr, n);\n \t\t  /* Advance to thishbp */\n-\t\t      prevhbp = hbp;\n-\t\t      phdr = hhdr;\n \t\t      hbp = thishbp;\n \t\t      hhdr = thishdr;\n+\t\t      /* We must now allocate thishbp, since it may\t*/\n+\t\t      /* be on the wrong free list.\t\t\t*/\n \t\t}\n \t      } else if (size_needed > (signed_word)BL_LIMIT\n \t                 && orig_avail - size_needed\n \t\t\t    > (signed_word)BL_LIMIT) {\n \t        /* Punt, since anything else risks unreasonable heap growth. */\n \t        WARN(\"Needed to allocate blacklisted block at 0x%lx\\n\",\n \t\t     (word)hbp);\n-\t        thishbp = hbp;\n \t        size_avail = orig_avail;\n-\t      } else if (size_avail == 0\n-\t      \t\t && size_needed == HBLKSIZE\n-\t      \t\t && prevhbp != 0) {\n-#\t\tifndef FIND_LEAK\n+\t      } else if (size_avail == 0 && size_needed == HBLKSIZE\n+\t\t\t && IS_MAPPED(hhdr)) {\n+\t\tif (!GC_find_leak) {\n \t      \t  static unsigned count = 0;\n \t      \t  \n \t      \t  /* The block is completely blacklisted.  We need \t*/\n@@ -235,11 +589,14 @@ unsigned char flags;  /* IGNORE_OFF_PAGE or 0 */\n \t            /* Allocate and drop the block in small chunks, to\t*/\n \t            /* maximize the chance that we will recover some\t*/\n \t            /* later.\t\t\t\t\t\t*/\n-\t              struct hblk * limit = hbp + (hhdr->hb_sz/HBLKSIZE);\n+\t\t      word total_size = hhdr -> hb_sz;\n+\t              struct hblk * limit = hbp + divHBLKSZ(total_size);\n \t              struct hblk * h;\n+\t\t      struct hblk * prev = hhdr -> hb_prev;\n \t              \n-\t\t      GC_words_wasted += hhdr->hb_sz;\n-\t              phdr -> hb_next = hhdr -> hb_next;\n+\t\t      GC_words_wasted += total_size;\n+\t\t      GC_large_free_bytes -= total_size;\n+\t\t      GC_remove_from_fl(hhdr, n);\n \t              for (h = hbp; h < limit; h++) {\n \t                if (h == hbp || GC_install_header(h)) {\n \t                  hhdr = HDR(h);\n@@ -248,69 +605,53 @@ unsigned char flags;  /* IGNORE_OFF_PAGE or 0 */\n \t              \t\t  BYTES_TO_WORDS(HBLKSIZE - HDR_BYTES),\n \t              \t\t  PTRFREE, 0); /* Cant fail */\n \t              \t  if (GC_debugging_started) {\n-\t              \t    BZERO(hbp + HDR_BYTES, HBLKSIZE - HDR_BYTES);\n+\t              \t    BZERO(h + HDR_BYTES, HBLKSIZE - HDR_BYTES);\n \t              \t  }\n \t                }\n \t              }\n \t            /* Restore hbp to point at free block */\n-\t              if (GC_savhbp == hbp) GC_savhbp = prevhbp;\n-\t              hbp = prevhbp;\n-\t              hhdr = phdr;\n-\t              if (hbp == GC_savhbp) --trip_count;\n+\t\t      hbp = prev;\n+\t\t      if (0 == hbp) {\n+\t\t\treturn GC_allochblk_nth(sz, kind, flags, n);\n+\t\t      }\n+\t   \t      hhdr = HDR(hbp);\n \t          }\n-#\t\tendif\n+\t\t}\n \t      }\n \t    }\n \t    if( size_avail >= size_needed ) {\n-\t\t/* found a big enough block       */\n-\t\t/* let thishbp --> the block      */\n-\t\t/* set prevhbp, hbp to bracket it */\n-\t\t    thishbp = hbp;\n-\t\t    thishdr = hhdr;\n-\t\t    if( size_avail == size_needed ) {\n-\t\t\thbp = hhdr->hb_next;\n-\t\t\thhdr = HDR(hbp);\n-\t\t    } else {\n-\t\t\thbp = (struct hblk *)\n-\t\t\t    (((word)thishbp) + size_needed);\n-\t\t\tif (!GC_install_header(hbp)) {\n-\t\t\t    hbp = thishbp;\n-\t\t\t    continue;\n-\t\t\t}\n-\t\t\thhdr = HDR(hbp);\n-\t\t\tGC_invalidate_map(hhdr);\n-\t\t\thhdr->hb_next = thishdr->hb_next;\n-\t\t\thhdr->hb_sz = size_avail - size_needed;\n-\t\t    }\n-\t\t/* remove *thishbp from hblk freelist */\n-\t\t    if( prevhbp == 0 ) {\n-\t\t\tGC_hblkfreelist = hbp;\n-\t\t    } else {\n-\t\t\tphdr->hb_next = hbp;\n-\t\t    }\n-\t\t/* save current list search position */\n-\t\t    GC_savhbp = hbp;\n+#\t\tifdef USE_MUNMAP\n+\t\t  if (!IS_MAPPED(hhdr)) {\n+\t\t    GC_remap((ptr_t)hbp, size_avail);\n+\t\t    hhdr -> hb_flags &= ~WAS_UNMAPPED;\n+\t\t  }\n+#\t        endif\n+\t\t/* hbp may be on the wrong freelist; the parameter n\t*/\n+\t\t/* is important.\t\t\t\t\t*/\n+\t\thbp = GC_get_first_part(hbp, hhdr, size_needed, n);\n \t\tbreak;\n \t    }\n \t}\n+\n+    if (0 == hbp) return 0;\n \t\n     /* Notify virtual dirty bit implementation that we are about to write. */\n-    \tGC_write_hint(thishbp);\n+    \tGC_write_hint(hbp);\n     \n     /* Add it to map of valid blocks */\n-    \tif (!GC_install_counts(thishbp, (word)size_needed)) return(0);\n+    \tif (!GC_install_counts(hbp, (word)size_needed)) return(0);\n     \t/* This leaks memory under very rare conditions. */\n     \t\t\n     /* Set up header */\n-        if (!setup_header(thishdr, sz, kind, flags)) {\n-            GC_remove_counts(thishbp, (word)size_needed);\n+        if (!setup_header(hhdr, sz, kind, flags)) {\n+            GC_remove_counts(hbp, (word)size_needed);\n             return(0); /* ditto */\n         }\n         \n     /* Clear block if necessary */\n \tif (GC_debugging_started\n \t    || sz > MAXOBJSZ && GC_obj_kinds[kind].ok_init) {\n-\t    BZERO(thishbp + HDR_BYTES,  size_needed - HDR_BYTES);\n+\t    BZERO(hbp + HDR_BYTES,  size_needed - HDR_BYTES);\n \t}\n \n     /* We just successfully allocated a block.  Restart count of\t*/\n@@ -320,8 +661,11 @@ unsigned char flags;  /* IGNORE_OFF_PAGE or 0 */\n \t\n \tGC_fail_count = 0;\n     }\n+\n+    GC_large_free_bytes -= size_needed;\n     \n-    return( thishbp );\n+    GC_ASSERT(IS_MAPPED(hhdr));\n+    return( hbp );\n }\n  \n struct hblk * GC_freehblk_ptr = 0;  /* Search position hint for GC_freehblk */\n@@ -334,75 +678,50 @@ struct hblk * GC_freehblk_ptr = 0;  /* Search position hint for GC_freehblk */\n  * All mark words are assumed to be cleared.\n  */\n void\n-GC_freehblk(p)\n-register struct hblk *p;\n+GC_freehblk(hbp)\n+struct hblk *hbp;\n {\n-register hdr *phdr;\t/* Header corresponding to p */\n-register struct hblk *hbp, *prevhbp;\n-register hdr *hhdr, *prevhdr;\n-register signed_word size;\n+struct hblk *next, *prev;\n+hdr *hhdr, *prevhdr, *nexthdr;\n+signed_word size;\n \n-    /* GC_savhbp may become invalid due to coalescing.  Clear it. */\n-\tGC_savhbp = (struct hblk *)0;\n \n-    phdr = HDR(p);\n-    size = phdr->hb_sz;\n-    size = HBLKSIZE * OBJ_SZ_TO_BLOCKS(size);\n-    GC_remove_counts(p, (word)size);\n-    phdr->hb_sz = size;\n-    GC_invalidate_map(phdr);\n-    prevhbp = 0;\n-    \n-    /* The following optimization was suggested by David Detlefs.\t*/\n-    /* Note that the header cannot be NIL, since there cannot be an\t*/\n-    /* intervening  call to GC_freehblk without resetting\t\t*/\n-    /* GC_freehblk_ptr.\t\t\t\t\t\t\t*/\n-    if (GC_freehblk_ptr != 0 &&\n-    \tHDR(GC_freehblk_ptr)->hb_map == GC_invalid_map &&\n-    \t(ptr_t)GC_freehblk_ptr < (ptr_t)p) {\n-      hbp = GC_freehblk_ptr;\n-    } else {\n-      hbp = GC_hblkfreelist;\n-    };\n     hhdr = HDR(hbp);\n-\n-    while( (hbp != 0) && (hbp < p) ) {\n-\tprevhbp = hbp;\n-\tprevhdr = hhdr;\n-\thbp = hhdr->hb_next;\n-\thhdr = HDR(hbp);\n-    }\n-    GC_freehblk_ptr = prevhbp;\n+    size = hhdr->hb_sz;\n+    size = HBLKSIZE * OBJ_SZ_TO_BLOCKS(size);\n+    GC_remove_counts(hbp, (word)size);\n+    hhdr->hb_sz = size;\n     \n     /* Check for duplicate deallocation in the easy case */\n-      if (hbp != 0 && (ptr_t)p + size > (ptr_t)hbp\n-        || prevhbp != 0 && (ptr_t)prevhbp + prevhdr->hb_sz > (ptr_t)p) {\n+      if (HBLK_IS_FREE(hhdr)) {\n         GC_printf1(\"Duplicate large block deallocation of 0x%lx\\n\",\n-        \t   (unsigned long) p);\n-        GC_printf2(\"Surrounding free blocks are 0x%lx and 0x%lx\\n\",\n-           \t   (unsigned long) prevhbp, (unsigned long) hbp);\n+        \t   (unsigned long) hbp);\n       }\n \n+    GC_ASSERT(IS_MAPPED(hhdr));\n+    GC_invalidate_map(hhdr);\n+    next = (struct hblk *)((word)hbp + size);\n+    nexthdr = HDR(next);\n+    prev = GC_free_block_ending_at(hbp);\n     /* Coalesce with successor, if possible */\n-      if( (((word)p)+size) == ((word)hbp) ) {\n-\tphdr->hb_next = hhdr->hb_next;\n-\tphdr->hb_sz += hhdr->hb_sz;\n-\tGC_remove_header(hbp);\n-      } else {\n-\tphdr->hb_next = hbp;\n+      if(0 != nexthdr && HBLK_IS_FREE(nexthdr) && IS_MAPPED(nexthdr)) {\n+\tGC_remove_from_fl(nexthdr, FL_UNKNOWN);\n+\thhdr -> hb_sz += nexthdr -> hb_sz; \n+\tGC_remove_header(next);\n+      }\n+    /* Coalesce with predecessor, if possible. */\n+      if (0 != prev) {\n+\tprevhdr = HDR(prev);\n+\tif (IS_MAPPED(prevhdr)) {\n+\t  GC_remove_from_fl(prevhdr, FL_UNKNOWN);\n+\t  prevhdr -> hb_sz += hhdr -> hb_sz;\n+\t  GC_remove_header(hbp);\n+\t  hbp = prev;\n+\t  hhdr = prevhdr;\n+\t}\n       }\n \n-    \n-    if( prevhbp == 0 ) {\n-\tGC_hblkfreelist = p;\n-    } else if( (((word)prevhbp) + prevhdr->hb_sz)\n-      \t       == ((word)p) ) {\n-      /* Coalesce with predecessor */\n-\tprevhdr->hb_next = phdr->hb_next;\n-\tprevhdr->hb_sz += phdr->hb_sz;\n-\tGC_remove_header(p);\n-    } else {\n-\tprevhdr->hb_next = p;\n-    }\n+    GC_large_free_bytes += size;\n+    GC_add_to_fl(hbp, hhdr);    \n }\n "}, {"sha": "3d0ddf05b36112bf6b81f65ed55b65441bda6c3c", "filename": "boehm-gc/alloc.c", "status": "modified", "additions": 134, "deletions": 78, "changes": 212, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20bbd3cd53a80ddafa56a5d21337aae0c24f94ca/boehm-gc%2Falloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20bbd3cd53a80ddafa56a5d21337aae0c24f94ca/boehm-gc%2Falloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Falloc.c?ref=20bbd3cd53a80ddafa56a5d21337aae0c24f94ca", "patch": "@@ -1,6 +1,8 @@\n /*\n  * Copyright 1988, 1989 Hans-J. Boehm, Alan J. Demers\n- * Copyright (c) 1991-1994 by Xerox Corporation.  All rights reserved.\n+ * Copyright (c) 1991-1996 by Xerox Corporation.  All rights reserved.\n+ * Copyright (c) 1998 by Silicon Graphics.  All rights reserved.\n+ * Copyright (c) 1999 by Hewlett-Packard Company. All rights reserved.\n  *\n  * THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED\n  * OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.\n@@ -12,7 +14,6 @@\n  * modified is included with the above copyright notice.\n  *\n  */\n-/* Boehm, February 16, 1996 2:26 pm PST */\n \n \n # include \"gc_priv.h\"\n@@ -58,15 +59,25 @@ word GC_non_gc_bytes = 0;  /* Number of bytes not intended to be collected */\n \n word GC_gc_no = 0;\n \n-int GC_incremental = 0;    /* By default, stop the world.\t*/\n+#ifndef SMALL_CONFIG\n+  int GC_incremental = 0;    /* By default, stop the world.\t*/\n+#endif\n+\n+int GC_full_freq = 19;\t   /* Every 20th collection is a full\t*/\n+\t\t\t   /* collection, whether we need it \t*/\n+\t\t\t   /* or not.\t\t\t        */\n+\n+GC_bool GC_need_full_gc = FALSE;\n+\t\t\t   /* Need full GC do to heap growth.\t*/\n \n-int GC_full_freq = 4;\t   /* Every 5th collection is a full\t*/\n-\t\t\t   /* collection.\t\t\t*/\n+#define USED_HEAP_SIZE (GC_heapsize - GC_large_free_bytes)\n+\n+word GC_used_heap_size_after_full = 0;\n \n char * GC_copyright[] =\n {\"Copyright 1988,1989 Hans-J. Boehm and Alan J. Demers \",\n \"Copyright (c) 1991-1995 by Xerox Corporation.  All rights reserved. \",\n-\"Copyright (c) 1996-1997 by Silicon Graphics.  All rights reserved. \",\n+\"Copyright (c) 1996-1998 by Silicon Graphics.  All rights reserved. \",\n \"THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY\",\n \" EXPRESSED OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.\",\n \"See source code for details.\" };\n@@ -80,16 +91,24 @@ extern signed_word GC_mem_found;  /* Number of reclaimed longwords\t*/\n \n GC_bool GC_dont_expand = 0;\n \n-word GC_free_space_divisor = 4;\n+word GC_free_space_divisor = 3;\n \n extern GC_bool GC_collection_in_progress();\n+\t\t/* Collection is in progress, or was abandoned.\t*/\n \n int GC_never_stop_func GC_PROTO((void)) { return(0); }\n \n-CLOCK_TYPE GC_start_time;\n+CLOCK_TYPE GC_start_time;  \t/* Time at which we stopped world.\t*/\n+\t\t\t\t/* used only in GC_timeout_stop_func.\t*/\n \n-int GC_timeout_stop_func GC_PROTO((void))\n-{\n+int GC_n_attempts = 0;\t\t/* Number of attempts at finishing\t*/\n+\t\t\t\t/* collection within TIME_LIMIT\t\t*/\n+\n+#ifdef SMALL_CONFIG\n+#   define GC_timeout_stop_func GC_never_stop_func\n+#else\n+  int GC_timeout_stop_func GC_PROTO((void))\n+  {\n     CLOCK_TYPE current_time;\n     static unsigned count = 0;\n     unsigned long time_diff;\n@@ -101,13 +120,15 @@ int GC_timeout_stop_func GC_PROTO((void))\n     if (time_diff >= TIME_LIMIT) {\n #   \tifdef PRINTSTATS\n \t    GC_printf0(\"Abandoning stopped marking after \");\n-\t    GC_printf1(\"%lu msecs\\n\", (unsigned long)time_diff);\n+\t    GC_printf1(\"%lu msecs\", (unsigned long)time_diff);\n+\t    GC_printf1(\"(attempt %d)\\n\", (unsigned long) GC_n_attempts);\n #\tendif\n     \treturn(1);\n     }\n #endif\n     return(0);\n-}\n+  }\n+#endif /* !SMALL_CONFIG */\n \n /* Return the minimum number of words that must be allocated between\t*/\n /* collections to amortize the collection cost.\t\t\t\t*/\n@@ -120,18 +141,22 @@ static word min_words_allocd()\n         int dummy;\n         register signed_word stack_size = (ptr_t)(&dummy) - GC_stackbottom;\n #   endif\n-    register word total_root_size;  /* includes double stack size,\t*/\n+    word total_root_size;  \t    /* includes double stack size,\t*/\n     \t\t\t\t    /* since the stack is expensive\t*/\n     \t\t\t\t    /* to scan.\t\t\t\t*/\n+    word scan_size;\t\t/* Estimate of memory to be scanned \t*/\n+\t\t\t\t/* during normal GC.\t\t\t*/\n     \n     if (stack_size < 0) stack_size = -stack_size;\n     total_root_size = 2 * stack_size + GC_root_size;\n+    scan_size = BYTES_TO_WORDS(GC_heapsize - GC_large_free_bytes\n+\t\t\t       + (GC_large_free_bytes >> 2)\n+\t\t\t\t   /* use a bit more of large empty heap */\n+\t\t\t       + total_root_size);\n     if (GC_incremental) {\n-        return(BYTES_TO_WORDS(GC_heapsize + total_root_size)\n-               / (2 * GC_free_space_divisor));\n+        return scan_size / (2 * GC_free_space_divisor);\n     } else {\n-        return(BYTES_TO_WORDS(GC_heapsize + total_root_size)\n-               / GC_free_space_divisor);\n+        return scan_size / GC_free_space_divisor;\n     }\n }\n \n@@ -196,13 +221,16 @@ GC_bool GC_should_collect()\n     return(GC_adj_words_allocd() >= min_words_allocd());\n }\n \n+\n void GC_notify_full_gc()\n {\n     if (GC_start_call_back != (void (*)())0) {\n \t(*GC_start_call_back)();\n     }\n }\n \n+GC_bool GC_is_full_gc = FALSE;\n+\n /* \n  * Initiate a garbage collection if appropriate.\n  * Choose judiciously\n@@ -212,13 +240,14 @@ void GC_notify_full_gc()\n void GC_maybe_gc()\n {\n     static int n_partial_gcs = 0;\n+\n     if (GC_should_collect()) {\n         if (!GC_incremental) {\n \t    GC_notify_full_gc();\n             GC_gcollect_inner();\n             n_partial_gcs = 0;\n             return;\n-        } else if (n_partial_gcs >= GC_full_freq) {\n+        } else if (GC_need_full_gc || n_partial_gcs >= GC_full_freq) {\n #   \t    ifdef PRINTSTATS\n \t      GC_printf2(\n \t        \"***>Full mark for collection %lu after %ld allocd bytes\\n\",\n@@ -230,6 +259,7 @@ void GC_maybe_gc()\n \t    GC_clear_marks();\n             n_partial_gcs = 0;\n \t    GC_notify_full_gc();\n+ \t    GC_is_full_gc = TRUE;\n         } else {\n             n_partial_gcs++;\n         }\n@@ -244,7 +274,12 @@ void GC_maybe_gc()\n                 GC_save_callers(GC_last_stack);\n #           endif\n             GC_finish_collection();\n-        }\n+        } else {\n+\t    if (!GC_is_full_gc) {\n+\t\t/* Count this as the first attempt */\n+\t        GC_n_attempts++;\n+\t    }\n+\t}\n     }\n }\n \n@@ -256,7 +291,7 @@ void GC_maybe_gc()\n GC_bool GC_try_to_collect_inner(stop_func)\n GC_stop_func stop_func;\n {\n-    if (GC_collection_in_progress()) {\n+    if (GC_incremental && GC_collection_in_progress()) {\n #   ifdef PRINTSTATS\n \tGC_printf0(\n \t    \"GC_try_to_collect_inner: finishing collection in progress\\n\");\n@@ -287,6 +322,7 @@ GC_stop_func stop_func;\n #   ifdef SAVE_CALL_CHAIN\n         GC_save_callers(GC_last_stack);\n #   endif\n+    GC_is_full_gc = TRUE;\n     if (!GC_stopped_mark(stop_func)) {\n       if (!GC_incremental) {\n     \t/* We're partially done and have no way to complete or use \t*/\n@@ -306,32 +342,48 @@ GC_stop_func stop_func;\n \n /*\n  * Perform n units of garbage collection work.  A unit is intended to touch\n- * roughly a GC_RATE pages.  Every once in a while, we do more than that.\n+ * roughly GC_RATE pages.  Every once in a while, we do more than that.\n+ * This needa to be a fairly large number with our current incremental\n+ * GC strategy, since otherwise we allocate too much during GC, and the\n+ * cleanup gets expensive.\n  */\n-# define GC_RATE 8\n+# define GC_RATE 10 \n+# define MAX_PRIOR_ATTEMPTS 1\n+ \t/* Maximum number of prior attempts at world stop marking\t*/\n+ \t/* A value of 1 means that we finish the seconf time, no matter */\n+ \t/* how long it takes.  Doesn't count the initial root scan\t*/\n+ \t/* for a full GC.\t\t\t\t\t\t*/\n \n int GC_deficit = 0;\t/* The number of extra calls to GC_mark_some\t*/\n \t\t\t/* that we have made.\t\t\t\t*/\n-\t\t\t/* Negative values are equivalent to 0.\t\t*/\n \n void GC_collect_a_little_inner(n)\n int n;\n {\n     register int i;\n     \n-    if (GC_collection_in_progress()) {\n+    if (GC_incremental && GC_collection_in_progress()) {\n     \tfor (i = GC_deficit; i < GC_RATE*n; i++) {\n-    \t    if (GC_mark_some()) {\n+    \t    if (GC_mark_some((ptr_t)0)) {\n     \t        /* Need to finish a collection */\n #     \t\tifdef SAVE_CALL_CHAIN\n         \t    GC_save_callers(GC_last_stack);\n #     \t\tendif\n-\t\t(void) GC_stopped_mark(GC_never_stop_func);\n+\t\tif (GC_n_attempts < MAX_PRIOR_ATTEMPTS) {\n+\t\t  GET_TIME(GC_start_time);\n+\t\t  if (!GC_stopped_mark(GC_timeout_stop_func)) {\n+\t\t    GC_n_attempts++;\n+\t\t    break;\n+\t\t  }\n+\t\t} else {\n+\t\t  (void)GC_stopped_mark(GC_never_stop_func);\n+\t\t}\n     \t        GC_finish_collection();\n     \t        break;\n     \t    }\n     \t}\n     \tif (GC_deficit > 0) GC_deficit -= GC_RATE*n;\n+\tif (GC_deficit < 0) GC_deficit = 0;\n     } else {\n         GC_maybe_gc();\n     }\n@@ -354,15 +406,14 @@ int GC_collect_a_little GC_PROTO(())\n /*\n  * Assumes lock is held, signals are disabled.\n  * We stop the world.\n- * If final is TRUE, then we finish the collection, no matter how long\n- * it takes.\n- * Otherwise we may fail and return FALSE if this takes too long.\n+ * If stop_func() ever returns TRUE, we may fail and return FALSE.\n  * Increment GC_gc_no if we succeed.\n  */\n GC_bool GC_stopped_mark(stop_func)\n GC_stop_func stop_func;\n {\n     register int i;\n+    int dummy;\n #   ifdef PRINTSTATS\n \tCLOCK_TYPE start_time, current_time;\n #   endif\n@@ -393,7 +444,7 @@ GC_stop_func stop_func;\n \t            START_WORLD();\n \t            return(FALSE);\n \t    }\n-\t    if (GC_mark_some()) break;\n+\t    if (GC_mark_some((ptr_t)(&dummy))) break;\n \t}\n \t\n     GC_gc_no++;\n@@ -439,7 +490,7 @@ void GC_finish_collection()\n #   ifdef GATHERSTATS\n         GC_mem_found = 0;\n #   endif\n-#   ifdef FIND_LEAK\n+    if (GC_find_leak) {\n       /* Mark all objects on the free list.  All objects should be */\n       /* marked when we're done.\t\t\t\t   */\n \t{\n@@ -462,25 +513,26 @@ void GC_finish_collection()\n \t    }\n \t  }\n \t}\n-      /* Check that everything is marked */\n \tGC_start_reclaim(TRUE);\n-#   else\n+\t  /* The above just checks; it doesn't really reclaim anything. */\n+    }\n+\n+    GC_finalize();\n+#   ifdef STUBBORN_ALLOC\n+      GC_clean_changing_list();\n+#   endif\n \n-      GC_finalize();\n-#     ifdef STUBBORN_ALLOC\n-        GC_clean_changing_list();\n-#     endif\n-\n-#     ifdef PRINTTIMES\n-\tGET_TIME(finalize_time);\n-#     endif\n-\n-      /* Clear free list mark bits, in case they got accidentally marked   */\n-      /* Note: HBLKPTR(p) == pointer to head of block containing *p        */\n-      /* Also subtract memory remaining from GC_mem_found count.           */\n-      /* Note that composite objects on free list are cleared.             */\n-      /* Thus accidentally marking a free list is not a problem;  only     */\n-      /* objects on the list itself will be marked, and that's fixed here. */\n+#   ifdef PRINTTIMES\n+      GET_TIME(finalize_time);\n+#   endif\n+\n+    /* Clear free list mark bits, in case they got accidentally marked   */\n+    /* Note: HBLKPTR(p) == pointer to head of block containing *p        */\n+    /* (or GC_find_leak is set and they were intentionally marked.)\t */\n+    /* Also subtract memory remaining from GC_mem_found count.           */\n+    /* Note that composite objects on free list are cleared.             */\n+    /* Thus accidentally marking a free list is not a problem;  only     */\n+    /* objects on the list itself will be marked, and that's fixed here. */\n       {\n \tregister word size;\t\t/* current object size\t\t*/\n \tregister ptr_t p;\t/* pointer to current object\t*/\n@@ -506,33 +558,47 @@ void GC_finish_collection()\n       }\n \n \n-#     ifdef PRINTSTATS\n+#   ifdef PRINTSTATS\n \tGC_printf1(\"Bytes recovered before sweep - f.l. count = %ld\\n\",\n \t          (long)WORDS_TO_BYTES(GC_mem_found));\n-#     endif\n-\n+#   endif\n     /* Reconstruct free lists to contain everything not marked */\n-      GC_start_reclaim(FALSE);\n-    \n-#   endif /* !FIND_LEAK */\n+        GC_start_reclaim(FALSE);\n+        if (GC_is_full_gc)  {\n+\t    GC_used_heap_size_after_full = USED_HEAP_SIZE;\n+\t    GC_need_full_gc = FALSE;\n+\t} else {\n+\t    GC_need_full_gc =\n+\t\t BYTES_TO_WORDS(USED_HEAP_SIZE - GC_used_heap_size_after_full)\n+\t\t > min_words_allocd();\n+\t}\n \n #   ifdef PRINTSTATS\n \tGC_printf2(\n-\t\t  \"Immediately reclaimed %ld bytes in heap of size %lu bytes\\n\",\n+\t\t  \"Immediately reclaimed %ld bytes in heap of size %lu bytes\",\n \t          (long)WORDS_TO_BYTES(GC_mem_found),\n \t          (unsigned long)GC_heapsize);\n-\tGC_printf2(\"%lu (atomic) + %lu (composite) collectable bytes in use\\n\",\n-\t           (unsigned long)WORDS_TO_BYTES(GC_atomic_in_use),\n-\t           (unsigned long)WORDS_TO_BYTES(GC_composite_in_use));\n+#\tifdef USE_MUNMAP\n+\t  GC_printf1(\"(%lu unmapped)\", GC_unmapped_bytes);\n+#\tendif\n+\tGC_printf2(\n+\t\t\"\\n%lu (atomic) + %lu (composite) collectable bytes in use\\n\",\n+\t        (unsigned long)WORDS_TO_BYTES(GC_atomic_in_use),\n+\t        (unsigned long)WORDS_TO_BYTES(GC_composite_in_use));\n #   endif\n \n+      GC_n_attempts = 0;\n+      GC_is_full_gc = FALSE;\n     /* Reset or increment counters for next cycle */\n       GC_words_allocd_before_gc += GC_words_allocd;\n       GC_non_gc_bytes_at_gc = GC_non_gc_bytes;\n       GC_words_allocd = 0;\n       GC_words_wasted = 0;\n       GC_mem_freed = 0;\n       \n+#   ifdef USE_MUNMAP\n+      GC_unmap_old();\n+#   endif\n #   ifdef PRINTTIMES\n \tGET_TIME(done_time);\n \tGC_printf2(\"Finalize + initiate sweep took %lu + %lu msecs\\n\",\n@@ -576,14 +642,15 @@ void GC_gcollect GC_PROTO(())\n word GC_n_heap_sects = 0;\t/* Number of sections currently in heap. */\n \n /*\n- * Use the chunk of memory starting at p of syze bytes as part of the heap.\n+ * Use the chunk of memory starting at p of size bytes as part of the heap.\n  * Assumes p is HBLKSIZE aligned, and bytes is a multiple of HBLKSIZE.\n  */\n void GC_add_to_heap(p, bytes)\n struct hblk *p;\n word bytes;\n {\n     word words;\n+    hdr * phdr;\n     \n     if (GC_n_heap_sects >= MAX_HEAP_SECTS) {\n     \tABORT(\"Too many heap sections: Increase MAXHINCR or MAX_HEAP_SECTS\");\n@@ -598,7 +665,10 @@ word bytes;\n     GC_heap_sects[GC_n_heap_sects].hs_bytes = bytes;\n     GC_n_heap_sects++;\n     words = BYTES_TO_WORDS(bytes - HDR_BYTES);\n-    HDR(p) -> hb_sz = words;\n+    phdr = HDR(p);\n+    phdr -> hb_sz = words;\n+    phdr -> hb_map = (char *)1;   /* A value != GC_invalid_map\t*/\n+    phdr -> hb_flags = 0;\n     GC_freehblk(p);\n     GC_heapsize += bytes;\n     if ((ptr_t)p <= GC_least_plausible_heap_addr\n@@ -614,21 +684,6 @@ word bytes;\n     }\n }\n \n-#ifdef PRESERVE_LAST\n-GC_bool GC_in_last_heap_sect(p)\n-ptr_t p;\n-{\n-    struct HeapSect * last_heap_sect = &(GC_heap_sects[GC_n_heap_sects-1]);\n-    ptr_t start = last_heap_sect -> hs_start;\n-    ptr_t end;\n-\n-    if (p < start) return FALSE;\n-    end = start + last_heap_sect -> hs_bytes;\n-    if (p >= end) return FALSE;\n-    return TRUE;\n-}\n-#endif\n-\n # if !defined(NO_DEBUGGING)\n void GC_print_heap_sects()\n {\n@@ -772,7 +827,6 @@ GC_bool GC_collect_or_expand(needed_blocks, ignore_off_page)\n word needed_blocks;\n GC_bool ignore_off_page;\n {\n-    \n     if (!GC_incremental && !GC_dont_gc && GC_should_collect()) {\n       GC_notify_full_gc();\n       GC_gcollect_inner();\n@@ -805,9 +859,11 @@ GC_bool ignore_off_page;\n \t    WARN(\"Out of Memory!  Returning NIL!\\n\", 0);\n \t    return(FALSE);\n \t}\n-      } else if (GC_fail_count) {\n+      } else {\n #\t  ifdef PRINTSTATS\n-\t    GC_printf0(\"Memory available again ...\\n\");\n+            if (GC_fail_count) {\n+\t      GC_printf0(\"Memory available again ...\\n\");\n+\t    }\n #\t  endif\n       }\n     }"}, {"sha": "e5a3a26a8cfa4ba716577ccc00f85cd3e3571b99", "filename": "boehm-gc/blacklst.c", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20bbd3cd53a80ddafa56a5d21337aae0c24f94ca/boehm-gc%2Fblacklst.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20bbd3cd53a80ddafa56a5d21337aae0c24f94ca/boehm-gc%2Fblacklst.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fblacklst.c?ref=20bbd3cd53a80ddafa56a5d21337aae0c24f94ca", "patch": "@@ -63,11 +63,16 @@ ptr_t p;\n void (*GC_print_heap_obj)(/* char * s, ptr_t p */) =\n \t\t\t\tGC_default_print_heap_obj_proc;\n \n-void GC_print_source_ptr(ptr_t p)\n+void GC_print_source_ptr(p)\n+ptr_t p;\n {\n     ptr_t base = GC_base(p);\n     if (0 == base) {\n-\tGC_err_printf0(\"in root set\");\n+\tif (0 == p) {\n+\t    GC_err_printf0(\"in register\");\n+\t} else {\n+\t    GC_err_printf0(\"in root set\");\n+\t}\n     } else {\n \tGC_err_printf0(\"in object at \");\n \t(*GC_print_heap_obj)(base);\n@@ -140,6 +145,13 @@ void GC_promote_black_lists()\n     if (GC_black_list_spacing < 3 * HBLKSIZE) {\n     \tGC_black_list_spacing = 3 * HBLKSIZE;\n     }\n+    if (GC_black_list_spacing > MAXHINCR * HBLKSIZE) {\n+\tGC_black_list_spacing = MAXHINCR * HBLKSIZE;\n+\t/* Makes it easier to allocate really huge blocks, which otherwise */\n+\t/* may have problems with nonuniform blacklist distributions.\t   */\n+\t/* This way we should always succeed immediately after growing the */ \n+\t/* heap.\t\t\t\t\t\t\t   */\n+    }\n }\n \n void GC_unpromote_black_lists()"}, {"sha": "f378f3c436797edb326fd5128973d5e087a048ce", "filename": "boehm-gc/configure", "status": "modified", "additions": 81, "deletions": 436, "changes": 517, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20bbd3cd53a80ddafa56a5d21337aae0c24f94ca/boehm-gc%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20bbd3cd53a80ddafa56a5d21337aae0c24f94ca/boehm-gc%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fconfigure?ref=20bbd3cd53a80ddafa56a5d21337aae0c24f94ca", "patch": "@@ -25,7 +25,7 @@ ac_help=\"$ac_help\n ac_help=\"$ac_help\n   --with-gnu-ld           assume the C compiler uses GNU ld [default=no]\"\n ac_help=\"$ac_help\n-  --disable-libtool-lock  force libtool not to do file locking\"\n+  --disable-libtool-lock  avoid locking (might break parallel builds)\"\n ac_help=\"$ac_help\n   --with-target-subdir=SUBDIR\n                           configuring with a cross compiler\"\n@@ -57,7 +57,6 @@ program_suffix=NONE\n program_transform_name=s,x,x,\n silent=\n site=\n-sitefile=\n srcdir=\n target=NONE\n verbose=\n@@ -172,7 +171,6 @@ Configuration:\n   --help                  print this message\n   --no-create             do not create output files\n   --quiet, --silent       do not print \\`checking...' messages\n-  --site-file=FILE        use FILE as the site file\n   --version               print the version of autoconf that created configure\n Directory and file names:\n   --prefix=PREFIX         install architecture-independent files in PREFIX\n@@ -343,11 +341,6 @@ EOF\n   -site=* | --site=* | --sit=*)\n     site=\"$ac_optarg\" ;;\n \n-  -site-file | --site-file | --site-fil | --site-fi | --site-f)\n-    ac_prev=sitefile ;;\n-  -site-file=* | --site-file=* | --site-fil=* | --site-fi=* | --site-f=*)\n-    sitefile=\"$ac_optarg\" ;;\n-\n   -srcdir | --srcdir | --srcdi | --srcd | --src | --sr)\n     ac_prev=srcdir ;;\n   -srcdir=* | --srcdir=* | --srcdi=* | --srcd=* | --src=* | --sr=*)\n@@ -513,16 +506,12 @@ fi\n srcdir=`echo \"${srcdir}\" | sed 's%\\([^/]\\)/*$%\\1%'`\n \n # Prefer explicitly selected file to automatically selected ones.\n-if test -z \"$sitefile\"; then\n-  if test -z \"$CONFIG_SITE\"; then\n-    if test \"x$prefix\" != xNONE; then\n-      CONFIG_SITE=\"$prefix/share/config.site $prefix/etc/config.site\"\n-    else\n-      CONFIG_SITE=\"$ac_default_prefix/share/config.site $ac_default_prefix/etc/config.site\"\n-    fi\n+if test -z \"$CONFIG_SITE\"; then\n+  if test \"x$prefix\" != xNONE; then\n+    CONFIG_SITE=\"$prefix/share/config.site $prefix/etc/config.site\"\n+  else\n+    CONFIG_SITE=\"$ac_default_prefix/share/config.site $ac_default_prefix/etc/config.site\"\n   fi\n-else\n-  CONFIG_SITE=\"$sitefile\"\n fi\n for ac_site_file in $CONFIG_SITE; do\n   if test -r \"$ac_site_file\"; then\n@@ -610,7 +599,7 @@ else { echo \"configure: error: can not run $ac_config_sub\" 1>&2; exit 1; }\n fi\n \n echo $ac_n \"checking host system type\"\"... $ac_c\" 1>&6\n-echo \"configure:614: checking host system type\" >&5\n+echo \"configure:603: checking host system type\" >&5\n \n host_alias=$host\n case \"$host_alias\" in\n@@ -631,7 +620,7 @@ host_os=`echo $host | sed 's/^\\([^-]*\\)-\\([^-]*\\)-\\(.*\\)$/\\3/'`\n echo \"$ac_t\"\"$host\" 1>&6\n \n echo $ac_n \"checking target system type\"\"... $ac_c\" 1>&6\n-echo \"configure:635: checking target system type\" >&5\n+echo \"configure:624: checking target system type\" >&5\n \n target_alias=$target\n case \"$target_alias\" in\n@@ -649,7 +638,7 @@ target_os=`echo $target | sed 's/^\\([^-]*\\)-\\([^-]*\\)-\\(.*\\)$/\\3/'`\n echo \"$ac_t\"\"$target\" 1>&6\n \n echo $ac_n \"checking build system type\"\"... $ac_c\" 1>&6\n-echo \"configure:653: checking build system type\" >&5\n+echo \"configure:642: checking build system type\" >&5\n \n build_alias=$build\n case \"$build_alias\" in\n@@ -684,7 +673,7 @@ test \"$host_alias\" != \"$target_alias\" &&\n # SVR4 /usr/ucb/install, which tries to use the nonexistent group \"staff\"\n # ./install, which can be erroneously created by make from ./install.sh.\n echo $ac_n \"checking for a BSD compatible install\"\"... $ac_c\" 1>&6\n-echo \"configure:688: checking for a BSD compatible install\" >&5\n+echo \"configure:677: checking for a BSD compatible install\" >&5\n if test -z \"$INSTALL\"; then\n if eval \"test \\\"`echo '$''{'ac_cv_path_install'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n@@ -737,7 +726,7 @@ test -z \"$INSTALL_SCRIPT\" && INSTALL_SCRIPT='${INSTALL_PROGRAM}'\n test -z \"$INSTALL_DATA\" && INSTALL_DATA='${INSTALL} -m 644'\n \n echo $ac_n \"checking whether build environment is sane\"\"... $ac_c\" 1>&6\n-echo \"configure:741: checking whether build environment is sane\" >&5\n+echo \"configure:730: checking whether build environment is sane\" >&5\n # Just in case\n sleep 1\n echo timestamp > conftestfile\n@@ -794,7 +783,7 @@ test \"$program_suffix\" != NONE &&\n test \"$program_transform_name\" = \"\" && program_transform_name=\"s,x,x,\"\n \n echo $ac_n \"checking whether ${MAKE-make} sets \\${MAKE}\"\"... $ac_c\" 1>&6\n-echo \"configure:798: checking whether ${MAKE-make} sets \\${MAKE}\" >&5\n+echo \"configure:787: checking whether ${MAKE-make} sets \\${MAKE}\" >&5\n set dummy ${MAKE-make}; ac_make=`echo \"$2\" | sed 'y%./+-%__p_%'`\n if eval \"test \\\"`echo '$''{'ac_cv_prog_make_${ac_make}_set'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n@@ -827,12 +816,12 @@ else\n fi\n \n echo $ac_n \"checking for Cygwin environment\"\"... $ac_c\" 1>&6\n-echo \"configure:831: checking for Cygwin environment\" >&5\n+echo \"configure:820: checking for Cygwin environment\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_cygwin'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 836 \"configure\"\n+#line 825 \"configure\"\n #include \"confdefs.h\"\n \n int main() {\n@@ -843,7 +832,7 @@ int main() {\n return __CYGWIN__;\n ; return 0; }\n EOF\n-if { (eval echo configure:847: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n+if { (eval echo configure:836: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n   rm -rf conftest*\n   ac_cv_cygwin=yes\n else\n@@ -860,19 +849,19 @@ echo \"$ac_t\"\"$ac_cv_cygwin\" 1>&6\n CYGWIN=\n test \"$ac_cv_cygwin\" = yes && CYGWIN=yes\n echo $ac_n \"checking for mingw32 environment\"\"... $ac_c\" 1>&6\n-echo \"configure:864: checking for mingw32 environment\" >&5\n+echo \"configure:853: checking for mingw32 environment\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_mingw32'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 869 \"configure\"\n+#line 858 \"configure\"\n #include \"confdefs.h\"\n \n int main() {\n return __MINGW32__;\n ; return 0; }\n EOF\n-if { (eval echo configure:876: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n+if { (eval echo configure:865: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n   rm -rf conftest*\n   ac_cv_mingw32=yes\n else\n@@ -920,7 +909,7 @@ else { echo \"configure: error: can not run $ac_config_sub\" 1>&2; exit 1; }\n fi\n \n echo $ac_n \"checking host system type\"\"... $ac_c\" 1>&6\n-echo \"configure:924: checking host system type\" >&5\n+echo \"configure:913: checking host system type\" >&5\n \n host_alias=$host\n case \"$host_alias\" in\n@@ -954,7 +943,7 @@ fi\n \n missing_dir=`cd $ac_aux_dir && pwd`\n echo $ac_n \"checking for working aclocal\"\"... $ac_c\" 1>&6\n-echo \"configure:958: checking for working aclocal\" >&5\n+echo \"configure:947: checking for working aclocal\" >&5\n # Run test in a subshell; some versions of sh will print an error if\n # an executable is not found, even if stderr is redirected.\n # Redirect stdin to placate older versions of autoconf.  Sigh.\n@@ -967,7 +956,7 @@ else\n fi\n \n echo $ac_n \"checking for working autoconf\"\"... $ac_c\" 1>&6\n-echo \"configure:971: checking for working autoconf\" >&5\n+echo \"configure:960: checking for working autoconf\" >&5\n # Run test in a subshell; some versions of sh will print an error if\n # an executable is not found, even if stderr is redirected.\n # Redirect stdin to placate older versions of autoconf.  Sigh.\n@@ -980,7 +969,7 @@ else\n fi\n \n echo $ac_n \"checking for working automake\"\"... $ac_c\" 1>&6\n-echo \"configure:984: checking for working automake\" >&5\n+echo \"configure:973: checking for working automake\" >&5\n # Run test in a subshell; some versions of sh will print an error if\n # an executable is not found, even if stderr is redirected.\n # Redirect stdin to placate older versions of autoconf.  Sigh.\n@@ -993,7 +982,7 @@ else\n fi\n \n echo $ac_n \"checking for working autoheader\"\"... $ac_c\" 1>&6\n-echo \"configure:997: checking for working autoheader\" >&5\n+echo \"configure:986: checking for working autoheader\" >&5\n # Run test in a subshell; some versions of sh will print an error if\n # an executable is not found, even if stderr is redirected.\n # Redirect stdin to placate older versions of autoconf.  Sigh.\n@@ -1006,7 +995,7 @@ else\n fi\n \n echo $ac_n \"checking for working makeinfo\"\"... $ac_c\" 1>&6\n-echo \"configure:1010: checking for working makeinfo\" >&5\n+echo \"configure:999: checking for working makeinfo\" >&5\n # Run test in a subshell; some versions of sh will print an error if\n # an executable is not found, even if stderr is redirected.\n # Redirect stdin to placate older versions of autoconf.  Sigh.\n@@ -1032,7 +1021,7 @@ fi\n # Extract the first word of \"gcc\", so it can be a program name with args.\n set dummy gcc; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:1036: checking for $ac_word\" >&5\n+echo \"configure:1025: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_CC'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -1062,7 +1051,7 @@ if test -z \"$CC\"; then\n   # Extract the first word of \"cc\", so it can be a program name with args.\n set dummy cc; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:1066: checking for $ac_word\" >&5\n+echo \"configure:1055: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_CC'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -1111,7 +1100,7 @@ fi\n fi\n \n echo $ac_n \"checking whether we are using GNU C\"\"... $ac_c\" 1>&6\n-echo \"configure:1115: checking whether we are using GNU C\" >&5\n+echo \"configure:1104: checking whether we are using GNU C\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_gcc'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -1120,7 +1109,7 @@ else\n   yes;\n #endif\n EOF\n-if { ac_try='${CC-cc} -E conftest.c'; { (eval echo configure:1124: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }; } | egrep yes >/dev/null 2>&1; then\n+if { ac_try='${CC-cc} -E conftest.c'; { (eval echo configure:1113: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }; } | egrep yes >/dev/null 2>&1; then\n   ac_cv_prog_gcc=yes\n else\n   ac_cv_prog_gcc=no\n@@ -1135,7 +1124,7 @@ if test $ac_cv_prog_gcc = yes; then\n   ac_save_CFLAGS=\"$CFLAGS\"\n   CFLAGS=\n   echo $ac_n \"checking whether ${CC-cc} accepts -g\"\"... $ac_c\" 1>&6\n-echo \"configure:1139: checking whether ${CC-cc} accepts -g\" >&5\n+echo \"configure:1128: checking whether ${CC-cc} accepts -g\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_cc_g'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -1172,7 +1161,7 @@ do\n # Extract the first word of \"$ac_prog\", so it can be a program name with args.\n set dummy $ac_prog; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:1176: checking for $ac_word\" >&5\n+echo \"configure:1165: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_CXX'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -1205,7 +1194,7 @@ test -n \"$CXX\" || CXX=\"gcc\"\n test -z \"$CXX\" && { echo \"configure: error: no acceptable c++ found in \\$PATH\" 1>&2; exit 1; }\n \n echo $ac_n \"checking whether we are using GNU C++\"\"... $ac_c\" 1>&6\n-echo \"configure:1209: checking whether we are using GNU C++\" >&5\n+echo \"configure:1198: checking whether we are using GNU C++\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_gxx'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -1214,7 +1203,7 @@ else\n   yes;\n #endif\n EOF\n-if { ac_try='${CXX-g++} -E conftest.C'; { (eval echo configure:1218: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }; } | egrep yes >/dev/null 2>&1; then\n+if { ac_try='${CXX-g++} -E conftest.C'; { (eval echo configure:1207: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }; } | egrep yes >/dev/null 2>&1; then\n   ac_cv_prog_gxx=yes\n else\n   ac_cv_prog_gxx=no\n@@ -1229,7 +1218,7 @@ if test $ac_cv_prog_gxx = yes; then\n   ac_save_CXXFLAGS=\"$CXXFLAGS\"\n   CXXFLAGS=\n   echo $ac_n \"checking whether ${CXX-g++} accepts -g\"\"... $ac_c\" 1>&6\n-echo \"configure:1233: checking whether ${CXX-g++} accepts -g\" >&5\n+echo \"configure:1222: checking whether ${CXX-g++} accepts -g\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_cxx_g'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -1262,7 +1251,7 @@ fi\n # NEWLIB_CONFIGURE, which doesn't work because that means that it will\n # be run before AC_CANONICAL_HOST.\n echo $ac_n \"checking build system type\"\"... $ac_c\" 1>&6\n-echo \"configure:1266: checking build system type\" >&5\n+echo \"configure:1255: checking build system type\" >&5\n \n build_alias=$build\n case \"$build_alias\" in\n@@ -1283,7 +1272,7 @@ echo \"$ac_t\"\"$build\" 1>&6\n # Extract the first word of \"${ac_tool_prefix}as\", so it can be a program name with args.\n set dummy ${ac_tool_prefix}as; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:1287: checking for $ac_word\" >&5\n+echo \"configure:1276: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_AS'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -1315,7 +1304,7 @@ fi\n # Extract the first word of \"${ac_tool_prefix}ar\", so it can be a program name with args.\n set dummy ${ac_tool_prefix}ar; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:1319: checking for $ac_word\" >&5\n+echo \"configure:1308: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_AR'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -1347,7 +1336,7 @@ fi\n # Extract the first word of \"${ac_tool_prefix}ranlib\", so it can be a program name with args.\n set dummy ${ac_tool_prefix}ranlib; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:1351: checking for $ac_word\" >&5\n+echo \"configure:1340: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_RANLIB'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -1379,7 +1368,7 @@ if test -n \"$ac_tool_prefix\"; then\n   # Extract the first word of \"ranlib\", so it can be a program name with args.\n set dummy ranlib; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:1383: checking for $ac_word\" >&5\n+echo \"configure:1372: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_RANLIB'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -1424,7 +1413,7 @@ fi\n # SVR4 /usr/ucb/install, which tries to use the nonexistent group \"staff\"\n # ./install, which can be erroneously created by make from ./install.sh.\n echo $ac_n \"checking for a BSD compatible install\"\"... $ac_c\" 1>&6\n-echo \"configure:1428: checking for a BSD compatible install\" >&5\n+echo \"configure:1417: checking for a BSD compatible install\" >&5\n if test -z \"$INSTALL\"; then\n if eval \"test \\\"`echo '$''{'ac_cv_path_install'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n@@ -1478,7 +1467,7 @@ test -z \"$INSTALL_DATA\" && INSTALL_DATA='${INSTALL} -m 644'\n \n \n echo $ac_n \"checking whether to enable maintainer-specific portions of Makefiles\"\"... $ac_c\" 1>&6\n-echo \"configure:1482: checking whether to enable maintainer-specific portions of Makefiles\" >&5\n+echo \"configure:1471: checking whether to enable maintainer-specific portions of Makefiles\" >&5\n     # Check whether --enable-maintainer-mode or --disable-maintainer-mode was given.\n if test \"${enable_maintainer_mode+set}\" = set; then\n   enableval=\"$enable_maintainer_mode\"\n@@ -1512,7 +1501,7 @@ if false; then\n   \n \n echo $ac_n \"checking for executable suffix\"\"... $ac_c\" 1>&6\n-echo \"configure:1516: checking for executable suffix\" >&5\n+echo \"configure:1505: checking for executable suffix\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_exeext'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -1522,7 +1511,7 @@ else\n   rm -f conftest*\n   echo 'int main () { return 0; }' > conftest.$ac_ext\n   ac_cv_exeext=\n-  if { (eval echo configure:1526: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; }; then\n+  if { (eval echo configure:1515: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; }; then\n     for file in conftest.*; do\n       case $file in\n       *.c | *.o | *.obj | *.ilk | *.pdb) ;;\n@@ -1636,7 +1625,7 @@ fi\n # Extract the first word of \"ranlib\", so it can be a program name with args.\n set dummy ranlib; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:1640: checking for $ac_word\" >&5\n+echo \"configure:1629: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_RANLIB'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -1675,11 +1664,11 @@ ac_prog=ld\n if test \"$ac_cv_prog_gcc\" = yes; then\n   # Check if gcc -print-prog-name=ld gives a path.\n   echo $ac_n \"checking for ld used by GCC\"\"... $ac_c\" 1>&6\n-echo \"configure:1679: checking for ld used by GCC\" >&5\n+echo \"configure:1668: checking for ld used by GCC\" >&5\n   ac_prog=`($CC -print-prog-name=ld) 2>&5`\n   case \"$ac_prog\" in\n     # Accept absolute paths.\n-    /* | [A-Za-z]:[\\\\/]*)\n+    [\\\\/]* | [A-Za-z]:[\\\\/]*)\n       re_direlt='/[^/][^/]*/\\.\\./'\n       # Canonicalize the path of ld\n       ac_prog=`echo $ac_prog| sed 's%\\\\\\\\%/%g'`\n@@ -1699,19 +1688,19 @@ echo \"configure:1679: checking for ld used by GCC\" >&5\n   esac\n elif test \"$with_gnu_ld\" = yes; then\n   echo $ac_n \"checking for GNU ld\"\"... $ac_c\" 1>&6\n-echo \"configure:1703: checking for GNU ld\" >&5\n+echo \"configure:1692: checking for GNU ld\" >&5\n else\n   echo $ac_n \"checking for non-GNU ld\"\"... $ac_c\" 1>&6\n-echo \"configure:1706: checking for non-GNU ld\" >&5\n+echo \"configure:1695: checking for non-GNU ld\" >&5\n fi\n if eval \"test \\\"`echo '$''{'ac_cv_path_LD'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   if test -z \"$LD\"; then\n-  IFS=\"${IFS= \t}\"; ac_save_ifs=\"$IFS\"; IFS=\"${IFS}:\"\n+  IFS=\"${IFS= \t}\"; ac_save_ifs=\"$IFS\"; IFS=\"${IFS}${PATH_SEPARATOR-:}\"\n   for ac_dir in $PATH; do\n     test -z \"$ac_dir\" && ac_dir=.\n-    if test -f \"$ac_dir/$ac_prog\"; then\n+    if test -f \"$ac_dir/$ac_prog\" || test -f \"$ac_dir/$ac_prog$ac_exeext\"; then\n       ac_cv_path_LD=\"$ac_dir/$ac_prog\"\n       # Check to see if the program is GNU ld.  I'd rather use --version,\n       # but apparently some GNU ld's only accept -v.\n@@ -1738,7 +1727,7 @@ fi\n test -z \"$LD\" && { echo \"configure: error: no acceptable ld found in \\$PATH\" 1>&2; exit 1; }\n \n echo $ac_n \"checking if the linker ($LD) is GNU ld\"\"... $ac_c\" 1>&6\n-echo \"configure:1742: checking if the linker ($LD) is GNU ld\" >&5\n+echo \"configure:1731: checking if the linker ($LD) is GNU ld\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_gnu_ld'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -1754,18 +1743,18 @@ echo \"$ac_t\"\"$ac_cv_prog_gnu_ld\" 1>&6\n \n \n echo $ac_n \"checking for BSD-compatible nm\"\"... $ac_c\" 1>&6\n-echo \"configure:1758: checking for BSD-compatible nm\" >&5\n+echo \"configure:1747: checking for BSD-compatible nm\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_path_NM'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   if test -n \"$NM\"; then\n   # Let the user override the test.\n   ac_cv_path_NM=\"$NM\"\n else\n-  IFS=\"${IFS= \t}\"; ac_save_ifs=\"$IFS\"; IFS=\"${IFS}:\"\n+  IFS=\"${IFS= \t}\"; ac_save_ifs=\"$IFS\"; IFS=\"${IFS}${PATH_SEPARATOR-:}\"\n   for ac_dir in $PATH /usr/ccs/bin /usr/ucb /bin; do\n     test -z \"$ac_dir\" && ac_dir=.\n-    if test -f $ac_dir/nm; then\n+    if test -f $ac_dir/nm || test -f $ac_dir/nm$ac_exeext ; then\n       # Check to see if the nm accepts a BSD-compat flag.\n       # Adding the `sed 1q' prevents false positives on HP-UX, which says:\n       #   nm: unknown option \"B\" ignored\n@@ -1790,212 +1779,8 @@ NM=\"$ac_cv_path_NM\"\n echo \"$ac_t\"\"$NM\" 1>&6\n \n \n-# Check for command to grab the raw symbol name followed by C symbol from nm.\n-echo $ac_n \"checking command to parse $NM output\"\"... $ac_c\" 1>&6\n-echo \"configure:1796: checking command to parse $NM output\" >&5\n-if eval \"test \\\"`echo '$''{'ac_cv_sys_global_symbol_pipe'+set}'`\\\" = set\"; then\n-  echo $ac_n \"(cached) $ac_c\" 1>&6\n-else\n-  # These are sane defaults that work on at least a few old systems.\n-# {They come from Ultrix.  What could be older than Ultrix?!! ;)}\n-\n-# Character class describing NM global symbol codes.\n-ac_symcode='[BCDEGRST]'\n-\n-# Regexp to match symbols that can be accessed directly from C.\n-ac_sympat='\\([_A-Za-z][_A-Za-z0-9]*\\)'\n-\n-# Transform the above into a raw symbol and a C symbol.\n-ac_symxfrm='\\1 \\2\\3 \\3'\n-\n-# Transform an extracted symbol line into a proper C declaration\n-ac_global_symbol_to_cdecl=\"sed -n -e 's/^. .* \\(.*\\)$/extern char \\1;/p'\"\n-\n-# Define system-specific variables.\n-case \"$host_os\" in\n-aix*)\n-  ac_symcode='[BCDT]'\n-  ;;\n-cygwin* | mingw*)\n-  ac_symcode='[ABCDGISTW]'\n-  ;;\n-hpux*)\n-  ac_global_symbol_to_cdecl=\"sed -n -e 's/^T .* \\(.*\\)$/extern char \\1();/p' -e 's/^. .* \\(.*\\)$/extern char \\1;/p'\"\n-  ;;\n-irix*)\n-  ac_symcode='[BCDEGRST]'\n-  ;;\n-solaris*)\n-  ac_symcode='[BDT]'\n-  ;;\n-esac\n-\n-# If we're using GNU nm, then use its standard symbol codes.\n-if $NM -V 2>&1 | egrep '(GNU|with BFD)' > /dev/null; then\n-  ac_symcode='[ABCDGISTW]'\n-fi\n-\n-# Try without a prefix undercore, then with it.\n-for ac_symprfx in \"\" \"_\"; do\n-\n-  ac_cv_sys_global_symbol_pipe=\"sed -n -e 's/^.* \t\\($ac_symcode\\) \t \t*\\($ac_symprfx\\)$ac_sympat$/$ac_symxfrm/p'\"\n-\n-  # Check to see that the pipe works correctly.\n-  ac_pipe_works=no\n-  rm -f conftest.$ac_ext\n-  cat > conftest.$ac_ext <<EOF\n-#ifdef __cplusplus\n-extern \"C\" {\n-#endif\n-char nm_test_var;\n-void nm_test_func(){}\n-#ifdef __cplusplus\n-}\n-#endif\n-int main(){nm_test_var='a';nm_test_func;return 0;}\n-EOF\n-\n-  if { (eval echo configure:1859: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n-    # Now try to grab the symbols.\n-    ac_nlist=conftest.nm\n-  \n-    if { (eval echo configure:1863: \\\"$NM conftest.$ac_objext \\| $ac_cv_sys_global_symbol_pipe \\> $ac_nlist\\\") 1>&5; (eval $NM conftest.$ac_objext \\| $ac_cv_sys_global_symbol_pipe \\> $ac_nlist) 2>&5; } && test -s \"$ac_nlist\"; then\n-\n-      # Try sorting and uniquifying the output.\n-      if sort \"$ac_nlist\" | uniq > \"$ac_nlist\"T; then\n-\tmv -f \"$ac_nlist\"T \"$ac_nlist\"\n-      else\n-\trm -f \"$ac_nlist\"T\n-      fi\n-\n-      # Make sure that we snagged all the symbols we need.\n-      if egrep ' nm_test_var$' \"$ac_nlist\" >/dev/null; then\n-\tif egrep ' nm_test_func$' \"$ac_nlist\" >/dev/null; then\n-\t  cat <<EOF > conftest.c\n-#ifdef __cplusplus\n-extern \"C\" {\n-#endif\n-\n-EOF\n-\t  # Now generate the symbol file.\n-\t  eval \"$ac_global_symbol_to_cdecl\"' < \"$ac_nlist\" >> conftest.c'\n-\n-\t  cat <<EOF >> conftest.c\n-#if defined (__STDC__) && __STDC__\n-# define lt_ptr_t void *\n-#else\n-# define lt_ptr_t char *\n-# define const\n-#endif\n-\n-/* The mapping between symbol names and symbols. */\n-const struct {\n-  const char *name;\n-  lt_ptr_t address;\n-}\n-lt_preloaded_symbols[] =\n-{\n-EOF\n-\tsed 's/^. \\(.*\\) \\(.*\\)$/  {\"\\2\", (lt_ptr_t) \\&\\2},/' < \"$ac_nlist\" >> conftest.c\n-\tcat <<\\EOF >> conftest.c\n-  {0, (lt_ptr_t) 0}\n-};\n-\n-#ifdef __cplusplus\n-}\n-#endif\n-EOF\n-\t  # Now try linking the two files.\n-\t  mv conftest.$ac_objext conftestm.$ac_objext\n-\t  ac_save_LIBS=\"$LIBS\"\n-\t  ac_save_CFLAGS=\"$CFLAGS\"\n-\t  LIBS=\"conftestm.$ac_objext\"\n-\t  CFLAGS=\"$CFLAGS$no_builtin_flag\"\n-\t  if { (eval echo configure:1915: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then\n-\t    ac_pipe_works=yes\n-\t  else\n-\t    echo \"configure: failed program was:\" >&5\n-\t    cat conftest.c >&5\n-\t  fi\n-\t  LIBS=\"$ac_save_LIBS\"\n-\t  CFLAGS=\"$ac_save_CFLAGS\"\n-\telse\n-\t  echo \"cannot find nm_test_func in $ac_nlist\" >&5\n-\tfi\n-      else\n-\techo \"cannot find nm_test_var in $ac_nlist\" >&5\n-      fi\n-    else\n-      echo \"cannot run $ac_cv_sys_global_symbol_pipe\" >&5\n-    fi\n-  else\n-    echo \"$progname: failed program was:\" >&5\n-    cat conftest.c >&5\n-  fi\n-  rm -rf conftest*\n-\n-  # Do not use the global_symbol_pipe unless it works.\n-  if test \"$ac_pipe_works\" = yes; then\n-    if test x\"$ac_symprfx\" = x\"_\"; then\n-      ac_cv_sys_symbol_underscore=yes\n-    else\n-      ac_cv_sys_symbol_underscore=no\n-    fi\n-    break\n-  else\n-    ac_cv_sys_global_symbol_pipe=\n-  fi\n-done\n-\n-fi\n-\n-\n-ac_result=yes\n-if test -z \"$ac_cv_sys_global_symbol_pipe\"; then\n-   ac_result=no\n-fi\n-echo \"$ac_t\"\"$ac_result\" 1>&6\n-\n-echo $ac_n \"checking for _ prefix in compiled symbols\"\"... $ac_c\" 1>&6\n-echo \"configure:1961: checking for _ prefix in compiled symbols\" >&5\n-if eval \"test \\\"`echo '$''{'ac_cv_sys_symbol_underscore'+set}'`\\\" = set\"; then\n-  echo $ac_n \"(cached) $ac_c\" 1>&6\n-else\n-  ac_cv_sys_symbol_underscore=no\n-cat > conftest.$ac_ext <<EOF\n-void nm_test_func(){}\n-int main(){nm_test_func;return 0;}\n-EOF\n-if { (eval echo configure:1970: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n-  # Now try to grab the symbols.\n-  ac_nlist=conftest.nm\n-  if { (eval echo configure:1973: \\\"$NM conftest.$ac_objext \\| $ac_cv_sys_global_symbol_pipe \\> $ac_nlist\\\") 1>&5; (eval $NM conftest.$ac_objext \\| $ac_cv_sys_global_symbol_pipe \\> $ac_nlist) 2>&5; } && test -s \"$ac_nlist\"; then\n-    # See whether the symbols have a leading underscore.\n-    if egrep '^. _nm_test_func' \"$ac_nlist\" >/dev/null; then\n-      ac_cv_sys_symbol_underscore=yes\n-    else\n-      if egrep '^. nm_test_func ' \"$ac_nlist\" >/dev/null; then\n-\t:\n-      else\n-\techo \"configure: cannot find nm_test_func in $ac_nlist\" >&5\n-      fi\n-    fi\n-  else\n-    echo \"configure: cannot run $ac_cv_sys_global_symbol_pipe\" >&5\n-  fi\n-else\n-  echo \"configure: failed program was:\" >&5\n-  cat conftest.c >&5\n-fi\n-rm -rf conftest*\n-\n-fi\n-\n-echo \"$ac_t\"\"$ac_cv_sys_symbol_underscore\" 1>&6\n-USE_SYMBOL_UNDERSCORE=${ac_cv_sys_symbol_underscore=no}\n-\n echo $ac_n \"checking whether ln -s works\"\"... $ac_c\" 1>&6\n-echo \"configure:1999: checking whether ln -s works\" >&5\n+echo \"configure:1784: checking whether ln -s works\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_LN_S'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -2021,18 +1806,26 @@ libtool_flags=\"--cache-file=$cache_file\"\n test \"$enable_shared\" = no && libtool_flags=\"$libtool_flags --disable-shared\"\n test \"$enable_static\" = no && libtool_flags=\"$libtool_flags --disable-static\"\n test \"$enable_fast_install\" = no && libtool_flags=\"$libtool_flags --disable-fast-install\"\n-test \"$lt_dlopen\" = yes && libtool_flags=\"$libtool_flags --enable-dlopen\"\n-test \"$silent\" = yes && libtool_flags=\"$libtool_flags --silent\"\n test \"$ac_cv_prog_gcc\" = yes && libtool_flags=\"$libtool_flags --with-gcc\"\n test \"$ac_cv_prog_gnu_ld\" = yes && libtool_flags=\"$libtool_flags --with-gnu-ld\"\n \n+\n+# Check whether --enable-libtool-lock or --disable-libtool-lock was given.\n+if test \"${enable_libtool_lock+set}\" = set; then\n+  enableval=\"$enable_libtool_lock\"\n+  :\n+fi\n+\n+test \"x$enable_libtool_lock\" = xno && libtool_flags=\"$libtool_flags --disable-lock\"\n+test x\"$silent\" = xyes && libtool_flags=\"$libtool_flags --silent\"\n+\n # Some flags need to be propagated to the compiler or linker for good\n # libtool support.\n case \"$host\" in\n *-*-irix6*)\n   # Find out which ABI we are using.\n-  echo '#line 2035 \"configure\"' > conftest.$ac_ext\n-  if { (eval echo configure:2036: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n+  echo '#line 1828 \"configure\"' > conftest.$ac_ext\n+  if { (eval echo configure:1829: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n     case \"`/usr/bin/file conftest.o`\" in\n     *32-bit*)\n       LD=\"${LD-ld} -32\"\n@@ -2053,19 +1846,19 @@ case \"$host\" in\n   SAVE_CFLAGS=\"$CFLAGS\"\n   CFLAGS=\"$CFLAGS -belf\"\n   echo $ac_n \"checking whether the C compiler needs -belf\"\"... $ac_c\" 1>&6\n-echo \"configure:2057: checking whether the C compiler needs -belf\" >&5\n+echo \"configure:1850: checking whether the C compiler needs -belf\" >&5\n if eval \"test \\\"`echo '$''{'lt_cv_cc_needs_belf'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 2062 \"configure\"\n+#line 1855 \"configure\"\n #include \"confdefs.h\"\n \n int main() {\n \n ; return 0; }\n EOF\n-if { (eval echo configure:2069: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+if { (eval echo configure:1862: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n   rm -rf conftest*\n   lt_cv_cc_needs_belf=yes\n else\n@@ -2084,161 +1877,9 @@ echo \"$ac_t\"\"$lt_cv_cc_needs_belf\" 1>&6\n   fi\n   ;;\n \n-*-*-cygwin*)\n-  # Extract the first word of \"${ac_tool_prefix}dlltool\", so it can be a program name with args.\n-set dummy ${ac_tool_prefix}dlltool; ac_word=$2\n-echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:2092: checking for $ac_word\" >&5\n-if eval \"test \\\"`echo '$''{'ac_cv_prog_DLLTOOL'+set}'`\\\" = set\"; then\n-  echo $ac_n \"(cached) $ac_c\" 1>&6\n-else\n-  if test -n \"$DLLTOOL\"; then\n-  ac_cv_prog_DLLTOOL=\"$DLLTOOL\" # Let the user override the test.\n-else\n-  IFS=\"${IFS= \t}\"; ac_save_ifs=\"$IFS\"; IFS=\":\"\n-  ac_dummy=\"$PATH\"\n-  for ac_dir in $ac_dummy; do\n-    test -z \"$ac_dir\" && ac_dir=.\n-    if test -f $ac_dir/$ac_word; then\n-      ac_cv_prog_DLLTOOL=\"${ac_tool_prefix}dlltool\"\n-      break\n-    fi\n-  done\n-  IFS=\"$ac_save_ifs\"\n-fi\n-fi\n-DLLTOOL=\"$ac_cv_prog_DLLTOOL\"\n-if test -n \"$DLLTOOL\"; then\n-  echo \"$ac_t\"\"$DLLTOOL\" 1>&6\n-else\n-  echo \"$ac_t\"\"no\" 1>&6\n-fi\n-\n-\n-if test -z \"$ac_cv_prog_DLLTOOL\"; then\n-if test -n \"$ac_tool_prefix\"; then\n-  # Extract the first word of \"dlltool\", so it can be a program name with args.\n-set dummy dlltool; ac_word=$2\n-echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:2124: checking for $ac_word\" >&5\n-if eval \"test \\\"`echo '$''{'ac_cv_prog_DLLTOOL'+set}'`\\\" = set\"; then\n-  echo $ac_n \"(cached) $ac_c\" 1>&6\n-else\n-  if test -n \"$DLLTOOL\"; then\n-  ac_cv_prog_DLLTOOL=\"$DLLTOOL\" # Let the user override the test.\n-else\n-  IFS=\"${IFS= \t}\"; ac_save_ifs=\"$IFS\"; IFS=\":\"\n-  ac_dummy=\"$PATH\"\n-  for ac_dir in $ac_dummy; do\n-    test -z \"$ac_dir\" && ac_dir=.\n-    if test -f $ac_dir/$ac_word; then\n-      ac_cv_prog_DLLTOOL=\"dlltool\"\n-      break\n-    fi\n-  done\n-  IFS=\"$ac_save_ifs\"\n-  test -z \"$ac_cv_prog_DLLTOOL\" && ac_cv_prog_DLLTOOL=\"false\"\n-fi\n-fi\n-DLLTOOL=\"$ac_cv_prog_DLLTOOL\"\n-if test -n \"$DLLTOOL\"; then\n-  echo \"$ac_t\"\"$DLLTOOL\" 1>&6\n-else\n-  echo \"$ac_t\"\"no\" 1>&6\n-fi\n-\n-else\n-  DLLTOOL=\"false\"\n-fi\n-fi\n-\n-# Extract the first word of \"${ac_tool_prefix}as\", so it can be a program name with args.\n-set dummy ${ac_tool_prefix}as; ac_word=$2\n-echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:2159: checking for $ac_word\" >&5\n-if eval \"test \\\"`echo '$''{'ac_cv_prog_AS'+set}'`\\\" = set\"; then\n-  echo $ac_n \"(cached) $ac_c\" 1>&6\n-else\n-  if test -n \"$AS\"; then\n-  ac_cv_prog_AS=\"$AS\" # Let the user override the test.\n-else\n-  IFS=\"${IFS= \t}\"; ac_save_ifs=\"$IFS\"; IFS=\":\"\n-  ac_dummy=\"$PATH\"\n-  for ac_dir in $ac_dummy; do\n-    test -z \"$ac_dir\" && ac_dir=.\n-    if test -f $ac_dir/$ac_word; then\n-      ac_cv_prog_AS=\"${ac_tool_prefix}as\"\n-      break\n-    fi\n-  done\n-  IFS=\"$ac_save_ifs\"\n-fi\n-fi\n-AS=\"$ac_cv_prog_AS\"\n-if test -n \"$AS\"; then\n-  echo \"$ac_t\"\"$AS\" 1>&6\n-else\n-  echo \"$ac_t\"\"no\" 1>&6\n-fi\n-\n-\n-if test -z \"$ac_cv_prog_AS\"; then\n-if test -n \"$ac_tool_prefix\"; then\n-  # Extract the first word of \"as\", so it can be a program name with args.\n-set dummy as; ac_word=$2\n-echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:2191: checking for $ac_word\" >&5\n-if eval \"test \\\"`echo '$''{'ac_cv_prog_AS'+set}'`\\\" = set\"; then\n-  echo $ac_n \"(cached) $ac_c\" 1>&6\n-else\n-  if test -n \"$AS\"; then\n-  ac_cv_prog_AS=\"$AS\" # Let the user override the test.\n-else\n-  IFS=\"${IFS= \t}\"; ac_save_ifs=\"$IFS\"; IFS=\":\"\n-  ac_dummy=\"$PATH\"\n-  for ac_dir in $ac_dummy; do\n-    test -z \"$ac_dir\" && ac_dir=.\n-    if test -f $ac_dir/$ac_word; then\n-      ac_cv_prog_AS=\"as\"\n-      break\n-    fi\n-  done\n-  IFS=\"$ac_save_ifs\"\n-  test -z \"$ac_cv_prog_AS\" && ac_cv_prog_AS=\"false\"\n-fi\n-fi\n-AS=\"$ac_cv_prog_AS\"\n-if test -n \"$AS\"; then\n-  echo \"$ac_t\"\"$AS\" 1>&6\n-else\n-  echo \"$ac_t\"\"no\" 1>&6\n-fi\n-\n-else\n-  AS=\"false\"\n-fi\n-fi\n-\n-\n-  ;;\n \n esac\n \n-# enable the --disable-libtool-lock switch\n-\n-# Check whether --enable-libtool-lock or --disable-libtool-lock was given.\n-if test \"${enable_libtool_lock+set}\" = set; then\n-  enableval=\"$enable_libtool_lock\"\n-  need_locks=$enableval\n-else\n-  need_locks=yes\n-fi\n-\n-\n-if test x\"$need_locks\" = xno; then\n-  libtool_flags=\"$libtool_flags --disable-lock\"\n-fi\n-\n \n # Save cache, so that ltconfig can load it\n cat > confcache <<\\EOF\n@@ -2291,8 +1932,9 @@ rm -f confcache\n \n # Actually configure libtool.  ac_aux_dir is where install-sh is found.\n CC=\"$CC\" CFLAGS=\"$CFLAGS\" CPPFLAGS=\"$CPPFLAGS\" \\\n-LD=\"$LD\" NM=\"$NM\" RANLIB=\"$RANLIB\" LN_S=\"$LN_S\" \\\n-DLLTOOL=\"$DLLTOOL\" AS=\"$AS\" \\\n+LD=\"$LD\" LDFLAGS=\"$LDFLAGS\" LIBS=\"$LIBS\" \\\n+LN_S=\"$LN_S\" NM=\"$NM\" RANLIB=\"$RANLIB\" \\\n+DLLTOOL=\"$DLLTOOL\" AS=\"$AS\" OBJDUMP=\"$OBJDUMP\" \\\n ${CONFIG_SHELL-/bin/sh} $ac_aux_dir/ltconfig --no-reexec \\\n $libtool_flags --no-verify $ac_aux_dir/ltmain.sh $host \\\n || { echo \"configure: error: libtool configure failed\" 1>&2; exit 1; }\n@@ -2332,7 +1974,7 @@ fi\n \n \n echo $ac_n \"checking whether to enable maintainer-specific portions of Makefiles\"\"... $ac_c\" 1>&6\n-echo \"configure:2336: checking whether to enable maintainer-specific portions of Makefiles\" >&5\n+echo \"configure:1978: checking whether to enable maintainer-specific portions of Makefiles\" >&5\n     # Check whether --enable-maintainer-mode or --disable-maintainer-mode was given.\n if test \"${enable_maintainer_mode+set}\" = set; then\n   enableval=\"$enable_maintainer_mode\"\n@@ -2361,7 +2003,7 @@ if test \"x\" = \"y\"; then\n    \n \n echo $ac_n \"checking for executable suffix\"\"... $ac_c\" 1>&6\n-echo \"configure:2365: checking for executable suffix\" >&5\n+echo \"configure:2007: checking for executable suffix\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_exeext'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -2371,7 +2013,7 @@ else\n   rm -f conftest*\n   echo 'int main () { return 0; }' > conftest.$ac_ext\n   ac_cv_exeext=\n-  if { (eval echo configure:2375: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; }; then\n+  if { (eval echo configure:2017: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; }; then\n     for file in conftest.*; do\n       case $file in\n       *.c | *.o | *.obj | *.ilk | *.pdb) ;;\n@@ -2394,7 +2036,7 @@ ac_exeext=$EXEEXT\n fi\n \n echo $ac_n \"checking for threads package to use\"\"... $ac_c\" 1>&6\n-echo \"configure:2398: checking for threads package to use\" >&5\n+echo \"configure:2040: checking for threads package to use\" >&5\n # Check whether --enable-threads or --disable-threads was given.\n if test \"${enable_threads+set}\" = set; then\n   enableval=\"$enable_threads\"\n@@ -2434,6 +2076,7 @@ if test \"$THREADS\" = yes; then\n fi\n \n INCLUDES=\n+THREADLIB=\n case \"$THREADS\" in\n  no | none | single)\n     THREADS=none\n@@ -2468,13 +2111,15 @@ EOF\n \n \t;;\n     esac\n+    THREADLIB=-lpthread\n     ;;\n  qt)\n     cat >> confdefs.h <<\\EOF\n #define QUICK_THREADS 1\n EOF\n \n     INCLUDES=\"-I${boehm_gc_basedir}/../qthreads\"\n+    THREADLIB=../qthreads/libgcjcoop.la\n     ;;\n  decosf1 | irix | mach | os2 | solaris | win32 | dce | vxworks)\n     { echo \"configure: error: thread package $THREADS not yet supported\" 1>&2; exit 1; }\n@@ -2485,6 +2130,7 @@ EOF\n esac\n echo \"$ac_t\"\"$THREADS\" 1>&6\n \n+\n # Check whether --enable-java-gc or --disable-java-gc was given.\n if test \"${enable_java_gc+set}\" = set; then\n   enableval=\"$enable_java_gc\"\n@@ -2822,10 +2468,9 @@ s%@EXEEXT@%$EXEEXT%g\n s%@BOEHM_GC_CFLAGS@%$BOEHM_GC_CFLAGS%g\n s%@LD@%$LD%g\n s%@NM@%$NM%g\n-s%@USE_SYMBOL_UNDERSCORE@%$USE_SYMBOL_UNDERSCORE%g\n s%@LN_S@%$LN_S%g\n-s%@DLLTOOL@%$DLLTOOL%g\n s%@LIBTOOL@%$LIBTOOL%g\n+s%@THREADLIB@%$THREADLIB%g\n s%@target_all@%$target_all%g\n s%@INCLUDES@%$INCLUDES%g\n s%@CXXINCLUDES@%$CXXINCLUDES%g"}, {"sha": "29725423b2a697a59016b72231deab195044be59", "filename": "boehm-gc/configure.in", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20bbd3cd53a80ddafa56a5d21337aae0c24f94ca/boehm-gc%2Fconfigure.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20bbd3cd53a80ddafa56a5d21337aae0c24f94ca/boehm-gc%2Fconfigure.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fconfigure.in?ref=20bbd3cd53a80ddafa56a5d21337aae0c24f94ca", "patch": "@@ -62,6 +62,7 @@ if test \"$THREADS\" = yes; then\n fi\n \n INCLUDES=\n+THREADLIB=\n case \"$THREADS\" in\n  no | none | single)\n     THREADS=none\n@@ -81,10 +82,12 @@ case \"$THREADS\" in\n \tAC_DEFINE(IRIX_THREADS)\n \t;;\n     esac\n+    THREADLIB=-lpthread\n     ;;\n  qt)\n     AC_DEFINE(QUICK_THREADS)\n     INCLUDES=\"-I${boehm_gc_basedir}/../qthreads\"\n+    THREADLIB=../qthreads/libgcjcoop.la\n     ;;\n  decosf1 | irix | mach | os2 | solaris | win32 | dce | vxworks)\n     AC_MSG_ERROR(thread package $THREADS not yet supported)\n@@ -94,6 +97,7 @@ case \"$THREADS\" in\n     ;;\n esac\n AC_MSG_RESULT($THREADS)\n+AC_SUBST(THREADLIB)\n \n AC_ARG_ENABLE(java-gc,\n changequote(<<,>>)dnl"}, {"sha": "cf6514b28367c4531003c95290bf9d8c59784dcd", "filename": "boehm-gc/dbg_mlc.c", "status": "modified", "additions": 180, "deletions": 43, "changes": 223, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20bbd3cd53a80ddafa56a5d21337aae0c24f94ca/boehm-gc%2Fdbg_mlc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20bbd3cd53a80ddafa56a5d21337aae0c24f94ca/boehm-gc%2Fdbg_mlc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fdbg_mlc.c?ref=20bbd3cd53a80ddafa56a5d21337aae0c24f94ca", "patch": "@@ -12,8 +12,16 @@\n  * provided the above notices are retained, and a notice that the code was\n  * modified is included with the above copyright notice.\n  */\n-/* Boehm, October 9, 1995 1:16 pm PDT */\n+# define I_HIDE_POINTERS\n # include \"gc_priv.h\"\n+# ifdef KEEP_BACK_PTRS\n+#   include \"backptr.h\"\n+# endif\n+\n+void GC_default_print_heap_obj_proc();\n+GC_API void GC_register_finalizer_no_order\n+    \tGC_PROTO((GC_PTR obj, GC_finalization_proc fn, GC_PTR cd,\n+\t\t  GC_finalization_proc *ofn, GC_PTR *ocd));\n \n /* Do we want to and know how to save the call stack at the time of\t*/\n /* an allocation?  How much space do we want to use in each object?\t*/\n@@ -26,6 +34,14 @@\n \n /* Object header */\n typedef struct {\n+#   ifdef KEEP_BACK_PTRS\n+\tptr_t oh_back_ptr;\n+#\tdefine MARKED_FOR_FINALIZATION (ptr_t)(-1)\n+\t    /* Object was marked because it is finalizable. */\n+#\tifdef ALIGN_DOUBLE\n+\t  word oh_dummy;\n+#\tendif\n+#   endif\n     char * oh_string;\t\t/* object descriptor string\t*/\n     word oh_int;\t\t/* object descriptor integers\t*/\n #   ifdef NEED_CALLINFO\n@@ -80,15 +96,133 @@ ptr_t p;\n     return(FALSE);\n }\n \n-/* Return start of object that might have debugging info.  */\n-ptr_t GC_debug_object_start(p)\n-ptr_t p;\n-{\n-    register word * result = (word *)((oh *)p + 1);\n-    if (! GC_has_debug_info(p))\n-        return(p);\n-    return((ptr_t)result);\n-}\n+#ifdef KEEP_BACK_PTRS\n+  /* Store back pointer to source in dest, if that appears to be possible. */\n+  /* This is not completely safe, since we may mistakenly conclude that\t   */\n+  /* dest has a debugging wrapper.  But the error probability is very\t   */\n+  /* small, and this shouldn't be used in production code.\t\t   */\n+  /* We assume that dest is the real base pointer.  Source will usually    */\n+  /* be a pointer to the interior of an object.\t\t\t\t   */\n+  void GC_store_back_pointer(ptr_t source, ptr_t dest)\n+  {\n+    if (GC_has_debug_info(dest)) {\n+      ((oh *)dest) -> oh_back_ptr = (ptr_t)HIDE_POINTER(source);\n+    }\n+  }\n+\n+  void GC_marked_for_finalization(ptr_t dest) {\n+    GC_store_back_pointer(MARKED_FOR_FINALIZATION, dest);\n+  }\n+\n+  /* Store information about the object referencing dest in *base_p\t*/\n+  /* and *offset_p.\t\t\t\t\t\t\t*/\n+  /*   source is root ==> *base_p = 0, *offset_p = address\t\t*/\n+  /*   source is heap object ==> *base_p != 0, *offset_p = offset \t*/\n+  /*   Returns 1 on success, 0 if source couldn't be determined.\t*/\n+  /* Dest can be any address within a heap object.\t\t\t*/\n+  GC_ref_kind GC_get_back_ptr_info(void *dest, void **base_p, size_t *offset_p)\n+  {\n+    oh * hdr = (oh *)GC_base(dest);\n+    ptr_t bp;\n+    ptr_t bp_base;\n+    if (!GC_has_debug_info((ptr_t) hdr)) return GC_NO_SPACE;\n+    bp = hdr -> oh_back_ptr;\n+    if (MARKED_FOR_FINALIZATION == bp) return GC_FINALIZER_REFD;\n+    if (0 == bp) return GC_UNREFERENCED;\n+    bp = REVEAL_POINTER(bp);\n+    bp_base = GC_base(bp);\n+    if (0 == bp_base) {\n+      *base_p = bp;\n+      *offset_p = 0;\n+      return GC_REFD_FROM_ROOT;\n+    } else {\n+      if (GC_has_debug_info(bp_base)) bp_base += sizeof(oh);\n+      *base_p = bp_base;\n+      *offset_p = bp - bp_base;\n+      return GC_REFD_FROM_HEAP;\n+    }\n+  }\n+\n+  /* Generate a random heap address.\t\t*/\n+  /* The resulting address is in the heap, but\t*/\n+  /* not necessarily inside a valid object.\t*/\n+  void *GC_generate_random_heap_address(void)\n+  {\n+    int i;\n+    int heap_offset = random() % GC_heapsize;\n+    for (i = 0; i < GC_n_heap_sects; ++ i) {\n+\tint size = GC_heap_sects[i].hs_bytes;\n+\tif (heap_offset < size) {\n+\t    return GC_heap_sects[i].hs_start + heap_offset;\n+\t} else {\n+\t    heap_offset -= size;\n+\t}\n+    }\n+    ABORT(\"GC_generate_random_heap_address: size inconsistency\");\n+    /*NOTREACHED*/\n+    return 0;\n+  }\n+\n+  /* Generate a random address inside a valid marked heap object. */\n+  void *GC_generate_random_valid_address(void)\n+  {\n+    ptr_t result;\n+    ptr_t base;\n+    for (;;) {\n+\tresult = GC_generate_random_heap_address();\n+  \tbase = GC_base(result);\n+\tif (0 == base) continue;\n+\tif (!GC_is_marked(base)) continue;\n+\treturn result;\n+    }\n+  }\n+\n+  /* Force a garbage collection and generate a backtrace from a\t*/\n+  /* random heap address.\t\t\t\t\t*/\n+  void GC_generate_random_backtrace(void)\n+  {\n+    void * current;\n+    int i;\n+    void * base;\n+    size_t offset;\n+    GC_ref_kind source;\n+    GC_gcollect();\n+    current = GC_generate_random_valid_address();\n+    GC_printf1(\"Chose address 0x%lx in object\\n\", (unsigned long)current);\n+    GC_print_heap_obj(GC_base(current));\n+    GC_err_printf0(\"\\n\");\n+    for (i = 0; ; ++i) {\n+      source = GC_get_back_ptr_info(current, &base, &offset);\n+      if (GC_UNREFERENCED == source) {\n+\tGC_err_printf0(\"Reference could not be found\\n\");\n+  \tgoto out;\n+      }\n+      if (GC_NO_SPACE == source) {\n+\tGC_err_printf0(\"No debug info in object: Can't find reference\\n\");\n+\tgoto out;\n+      }\n+      GC_err_printf1(\"Reachable via %d levels of pointers from \",\n+\t\t (unsigned long)i);\n+      switch(source) {\n+\tcase GC_REFD_FROM_ROOT:\n+\t  GC_err_printf1(\"root at 0x%lx\\n\", (unsigned long)base);\n+\t  goto out;\n+\tcase GC_FINALIZER_REFD:\n+\t  GC_err_printf0(\"list of finalizable objects\\n\");\n+\t  goto out;\n+\tcase GC_REFD_FROM_HEAP:\n+\t  GC_err_printf1(\"offset %ld in object:\\n\", (unsigned long)offset);\n+\t  /* Take GC_base(base) to get real base, i.e. header. */\n+\t  GC_print_heap_obj(GC_base(base));\n+\t  GC_err_printf0(\"\\n\");\n+\t  break;\n+      }\n+      current = base;\n+    }\n+    out:;\n+  }\n+    \n+#endif /* KEEP_BACK_PTRS */\n \n /* Store debugging info into p.  Return displaced pointer. */\n /* Assumes we don't hold allocation lock.\t\t   */\n@@ -105,6 +239,9 @@ word integer;\n     /* But that's expensive.  And this way things should only appear\t*/\n     /* inconsistent while we're in the handler.\t\t\t\t*/\n     LOCK();\n+#   ifdef KEEP_BACK_PTRS\n+      ((oh *)p) -> oh_back_ptr = 0;\n+#   endif\n     ((oh *)p) -> oh_string = string;\n     ((oh *)p) -> oh_int = integer;\n     ((oh *)p) -> oh_sz = sz;\n@@ -115,7 +252,7 @@ word integer;\n     return((ptr_t)result);\n }\n \n-/* Check the object with debugging info at p \t\t*/\n+/* Check the object with debugging info at ohdr\t\t*/\n /* return NIL if it's OK.  Else return clobbered\t*/\n /* address.\t\t\t\t\t\t*/\n ptr_t GC_check_annotated_obj(ohdr)\n@@ -144,7 +281,7 @@ ptr_t p;\n {\n     register oh * ohdr = (oh *)GC_base(p);\n     \n-    GC_err_printf1(\"0x%lx (\", (unsigned long)ohdr + sizeof(oh));\n+    GC_err_printf1(\"0x%lx (\", ((unsigned long)ohdr + sizeof(oh)));\n     GC_err_puts(ohdr -> oh_string);\n     GC_err_printf2(\":%ld, sz=%ld)\\n\", (unsigned long)(ohdr -> oh_int),\n         \t\t\t      (unsigned long)(ohdr -> oh_sz));\n@@ -171,7 +308,7 @@ ptr_t p, clobbered_addr;\n     if (clobbered_addr <= (ptr_t)(&(ohdr -> oh_sz))\n         || ohdr -> oh_string == 0) {\n         GC_err_printf1(\"<smashed>, appr. sz = %ld)\\n\",\n-        \t       GC_size((ptr_t)ohdr) - DEBUG_BYTES);\n+        \t       (GC_size((ptr_t)ohdr) - DEBUG_BYTES));\n     } else {\n         if (ohdr -> oh_string[0] == '\\0') {\n             GC_err_puts(\"EMPTY(smashed?)\");\n@@ -206,10 +343,10 @@ void GC_start_debugging()\n }\n \n # ifdef GC_ADD_CALLER\n-#   define EXTRA_ARGS word ra, char * s, int i\n+#   define EXTRA_ARGS word ra, CONST char * s, int i\n #   define OPT_RA ra,\n # else\n-#   define EXTRA_ARGS char * s, int i\n+#   define EXTRA_ARGS CONST char * s, int i\n #   define OPT_RA\n # endif\n \n@@ -423,13 +560,15 @@ GC_PTR p;\n     GC_PTR p;\n # endif\n {\n-    register GC_PTR base = GC_base(p);\n+    register GC_PTR base;\n     register ptr_t clobbered;\n     \n+    if (0 == p) return;\n+    base = GC_base(p);\n     if (base == 0) {\n         GC_err_printf1(\"Attempt to free invalid pointer %lx\\n\",\n         \t       (unsigned long)p);\n-        if (p != 0) ABORT(\"free(invalid pointer)\");\n+        ABORT(\"free(invalid pointer)\");\n     }\n     if ((ptr_t)p - (ptr_t)base != sizeof(oh)) {\n         GC_err_printf1(\n@@ -442,31 +581,29 @@ GC_PTR p;\n             GC_err_printf0(\n                   \"GC_debug_free: found previously deallocated (?) object at \");\n         } else {\n-            GC_err_printf0(\"GC_debug_free: found smashed object at \");\n+            GC_err_printf0(\"GC_debug_free: found smashed location at \");\n         }\n         GC_print_smashed_obj(p, clobbered);\n       }\n       /* Invalidate size */\n       ((oh *)base) -> oh_sz = GC_size(base);\n     }\n-#   ifdef FIND_LEAK\n+    if (GC_find_leak) {\n         GC_free(base);\n-#   else\n-\t{\n-\t    register hdr * hhdr = HDR(p);\n-\t    GC_bool uncollectable = FALSE;\n+    } else {\n+\tregister hdr * hhdr = HDR(p);\n+\tGC_bool uncollectable = FALSE;\n \n-\t    if (hhdr ->  hb_obj_kind == UNCOLLECTABLE) {\n-\t\tuncollectable = TRUE;\n-\t    }\n-#\t    ifdef ATOMIC_UNCOLLECTABLE\n-\t\tif (hhdr ->  hb_obj_kind == AUNCOLLECTABLE) {\n-\t\t    uncollectable = TRUE;\n-\t\t}\n-#\t    endif\n-\t    if (uncollectable) GC_free(base);\n+        if (hhdr ->  hb_obj_kind == UNCOLLECTABLE) {\n+\t    uncollectable = TRUE;\n \t}\n-#   endif\n+#\tifdef ATOMIC_UNCOLLECTABLE\n+\t    if (hhdr ->  hb_obj_kind == AUNCOLLECTABLE) {\n+\t\t    uncollectable = TRUE;\n+\t    }\n+#\tendif\n+\tif (uncollectable) GC_free(base);\n+    } /* !GC_find_leak */\n }\n \n # ifdef __STDC__\n@@ -525,7 +662,7 @@ GC_PTR p;\n     }\n     clobbered = GC_check_annotated_obj((oh *)base);\n     if (clobbered != 0) {\n-        GC_err_printf0(\"GC_debug_realloc: found smashed object at \");\n+        GC_err_printf0(\"GC_debug_realloc: found smashed location at \");\n         GC_print_smashed_obj(p, clobbered);\n     }\n     old_sz = ((oh *)base) -> oh_sz;\n@@ -562,7 +699,7 @@ word dummy;\n \t        \n \t        if (clobbered != 0) {\n \t            GC_err_printf0(\n-\t                \"GC_check_heap_block: found smashed object at \");\n+\t                \"GC_check_heap_block: found smashed location at \");\n         \t    GC_print_smashed_obj((ptr_t)p, clobbered);\n \t        }\n \t    }\n@@ -643,12 +780,12 @@ struct closure {\n }\n \n # ifdef __STDC__\n-    void GC_debug_register_finalizer_ignore_self\n+    void GC_debug_register_finalizer_no_order\n     \t\t\t\t    (GC_PTR obj, GC_finalization_proc fn,\n     \t\t\t\t     GC_PTR cd, GC_finalization_proc *ofn,\n \t\t\t\t     GC_PTR *ocd)\n # else\n-    void GC_debug_register_finalizer_ignore_self\n+    void GC_debug_register_finalizer_no_order\n     \t\t\t\t    (obj, fn, cd, ofn, ocd)\n     GC_PTR obj;\n     GC_finalization_proc fn;\n@@ -660,15 +797,15 @@ struct closure {\n     ptr_t base = GC_base(obj);\n     if (0 == base || (ptr_t)obj - base != sizeof(oh)) {\n         GC_err_printf1(\n-\t    \"GC_register_finalizer_ignore_self called with non-base-pointer 0x%lx\\n\",\n-\t    obj);\n+\t  \"GC_register_finalizer_no_order called with non-base-pointer 0x%lx\\n\",\n+\t  obj);\n     }\n-    GC_register_finalizer_ignore_self(base, GC_debug_invoke_finalizer,\n-    \t\t\t  \t      GC_make_closure(fn,cd), ofn, ocd);\n-}\n+    GC_register_finalizer_no_order(base, GC_debug_invoke_finalizer,\n+     \t\t\t  \t      GC_make_closure(fn,cd), ofn, ocd);\n+ }\n \n # ifdef __STDC__\n-    void GC_debug_register_finalizer_no_order\n+    void GC_debug_register_finalizer_ignore_self\n     \t\t\t\t    (GC_PTR obj, GC_finalization_proc fn,\n     \t\t\t\t     GC_PTR cd, GC_finalization_proc *ofn,\n \t\t\t\t     GC_PTR *ocd)"}, {"sha": "b9de4c11db4dbc00501b3ace2454faf5d1aede38", "filename": "boehm-gc/dyn_load.c", "status": "modified", "additions": 18, "deletions": 9, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20bbd3cd53a80ddafa56a5d21337aae0c24f94ca/boehm-gc%2Fdyn_load.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20bbd3cd53a80ddafa56a5d21337aae0c24f94ca/boehm-gc%2Fdyn_load.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fdyn_load.c?ref=20bbd3cd53a80ddafa56a5d21337aae0c24f94ca", "patch": "@@ -47,7 +47,7 @@\n #if (defined(DYNAMIC_LOADING) || defined(MSWIN32)) && !defined(PCR)\n #if !defined(SUNOS4) && !defined(SUNOS5DL) && !defined(IRIX5) && \\\n     !defined(MSWIN32) && !(defined(ALPHA) && defined(OSF1)) && \\\n-    !defined(HP_PA) && (!defined(LINUX) && !defined(__ELF__)) && \\\n+    !defined(HPUX) && !(defined(LINUX) && defined(__ELF__)) && \\\n     !defined(RS6000) && !defined(SCO_ELF)\n  --> We only know how to find data segments of dynamic libraries for the\n  --> above.  Additional SVR4 variants might not be too\n@@ -284,11 +284,9 @@ void GC_register_dynamic_libraries()\n static struct link_map *\n GC_FirstDLOpenedLinkMap()\n {\n-#ifdef __GNUC__\n-  /* On some Linux systems, `_DYNAMIC' will not be defined when a\n-     static link is done.  */\n-# pragma weak _DYNAMIC\n-#endif\n+#   ifdef __GNUC__\n+#     pragma weak _DYNAMIC\n+#   endif\n     extern ElfW(Dyn) _DYNAMIC[];\n     ElfW(Dyn) *dp;\n     struct r_debug *r;\n@@ -356,6 +354,8 @@ void GC_register_dynamic_libraries()\n #include <errno.h>\n \n extern void * GC_roots_present();\n+\t/* The type is a lie, since the real type doesn't make sense here, */\n+\t/* and we only test for NULL.\t\t\t\t\t   */\n \n extern ptr_t GC_scratch_last_end_ptr; /* End of GC_scratch_alloc arena\t*/\n \n@@ -382,6 +382,8 @@ void GC_register_dynamic_libraries()\n \n     if (fd < 0) {\n       sprintf(buf, \"/proc/%d\", getpid());\n+\t/* The above generates a lint complaint, since pid_t varies.\t*/\n+\t/* It's unclear how to improve this.\t\t\t\t*/\n       fd = open(buf, O_RDONLY);\n       if (fd < 0) {\n     \tABORT(\"/proc open failed\");\n@@ -394,7 +396,8 @@ void GC_register_dynamic_libraries()\n     if (needed_sz >= current_sz) {\n         current_sz = needed_sz * 2 + 1;\n         \t\t/* Expansion, plus room for 0 record */\n-        addr_map = (prmap_t *)GC_scratch_alloc(current_sz * sizeof(prmap_t));\n+        addr_map = (prmap_t *)GC_scratch_alloc((word)\n+\t\t\t\t\t\t(current_sz * sizeof(prmap_t)));\n     }\n     if (ioctl(fd, PIOCMAP, addr_map) < 0) {\n         GC_err_printf4(\"fd = %d, errno = %d, needed_sz = %d, addr_map = 0x%X\\n\",\n@@ -656,7 +659,7 @@ void GC_register_dynamic_libraries()\n }\n #endif\n \n-#if defined(HP_PA)\n+#if defined(HPUX)\n \n #include <errno.h>\n #include <dl.h>\n@@ -679,6 +682,11 @@ void GC_register_dynamic_libraries()\n \n       /* Check if this is the end of the list or if some error occured */\n         if (status != 0) {\n+#\t ifdef HPUX_THREADS\n+\t   /* I've seen errno values of 0.  The man page is not clear\t*/\n+\t   /* as to whether errno should get set on a -1 return.\t*/\n+\t   break;\n+#\t else\n           if (errno == EINVAL) {\n               break; /* Moved past end of shared library list --> finished */\n           } else {\n@@ -689,6 +697,7 @@ void GC_register_dynamic_libraries()\n \t      }\n               ABORT(\"shl_get failed\");\n           }\n+#\t endif\n         }\n \n #     ifdef VERBOSE\n@@ -711,7 +720,7 @@ void GC_register_dynamic_libraries()\n         index++;\n     }\n }\n-#endif /* HP_PA */\n+#endif /* HPUX */\n \n #ifdef RS6000\n #pragma alloca"}, {"sha": "2ee927fe432fed5da4fc11d2504d494c5d875109", "filename": "boehm-gc/finalize.c", "status": "modified", "additions": 50, "deletions": 26, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20bbd3cd53a80ddafa56a5d21337aae0c24f94ca/boehm-gc%2Ffinalize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20bbd3cd53a80ddafa56a5d21337aae0c24f94ca/boehm-gc%2Ffinalize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Ffinalize.c?ref=20bbd3cd53a80ddafa56a5d21337aae0c24f94ca", "patch": "@@ -1,6 +1,7 @@\n /*\n  * Copyright 1988, 1989 Hans-J. Boehm, Alan J. Demers\n  * Copyright (c) 1991-1996 by Xerox Corporation.  All rights reserved.\n+ * Copyright (c) 1996-1999 by Silicon Graphics.  All rights reserved.\n \n  * THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED\n  * OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.\n@@ -16,6 +17,18 @@\n # include \"gc_priv.h\"\n # include \"gc_mark.h\"\n \n+# ifdef FINALIZE_ON_DEMAND\n+    int GC_finalize_on_demand = 1;\n+# else\n+    int GC_finalize_on_demand = 0;\n+# endif\n+\n+# ifdef JAVA_FINALIZATION\n+    int GC_java_finalization = 1;\n+# else\n+    int GC_java_finalization = 0;\n+# endif\n+\n /* Type of mark procedure used for marking from finalizable object.\t*/\n /* This procedure normally does not mark the object, only its\t\t*/\n /* descendents.\t\t\t\t\t\t\t\t*/\n@@ -249,7 +262,7 @@ signed_word * log_size_ptr;\n \n /* Possible finalization_marker procedures.  Note that mark stack\t*/\n /* overflow is handled by the caller, and is not a disaster.\t\t*/\n-void GC_normal_finalize_mark_proc(p)\n+GC_API void GC_normal_finalize_mark_proc(p)\n ptr_t p;\n {\n     hdr * hhdr = HDR(p);\n@@ -261,7 +274,7 @@ ptr_t p;\n /* This only pays very partial attention to the mark descriptor.\t*/\n /* It does the right thing for normal and atomic objects, and treats\t*/\n /* most others as normal.\t\t\t\t\t\t*/\n-void GC_ignore_self_finalize_mark_proc(p)\n+GC_API void GC_ignore_self_finalize_mark_proc(p)\n ptr_t p;\n {\n     hdr * hhdr = HDR(p);\n@@ -278,13 +291,13 @@ ptr_t p;\n     for (q = p; q <= scan_limit; q += ALIGNMENT) {\n     \tr = *(ptr_t *)q;\n     \tif (r < p || r > target_limit) {\n-    \t    GC_PUSH_ONE_HEAP((word)r);\n+    \t    GC_PUSH_ONE_HEAP((word)r, q);\n     \t}\n     }\n }\n \n /*ARGSUSED*/\n-void GC_null_finalize_mark_proc(p)\n+GC_API void GC_null_finalize_mark_proc(p)\n ptr_t p;\n {\n }\n@@ -295,7 +308,11 @@ ptr_t p;\n /* in the nonthreads case, we try to avoid disabling signals,\t*/\n /* since it can be expensive.  Threads packages typically\t*/\n /* make it cheaper.\t\t\t\t\t\t*/\n-void GC_register_finalizer_inner(obj, fn, cd, ofn, ocd, mp)\n+/* The last parameter is a procedure that determines\t\t*/\n+/* marking for finalization ordering.  Any objects marked\t*/\n+/* by that procedure will be guaranteed to not have been\t*/\n+/* finalized when this finalizer is invoked.\t\t\t*/\n+GC_API void GC_register_finalizer_inner(obj, fn, cd, ofn, ocd, mp)\n GC_PTR obj;\n GC_finalization_proc fn;\n GC_PTR cd;\n@@ -505,6 +522,7 @@ void GC_finalize()\n       for (curr_fo = fo_head[i]; curr_fo != 0; curr_fo = fo_next(curr_fo)) {\n         real_ptr = (ptr_t)REVEAL_POINTER(curr_fo -> fo_hidden_base);\n         if (!GC_is_marked(real_ptr)) {\n+\t    GC_MARKED_FOR_FINALIZATION(real_ptr);\n             GC_MARK_FO(real_ptr, curr_fo -> fo_mark_proc);\n             if (GC_is_marked(real_ptr)) {\n                 WARN(\"Finalization cycle involving %lx\\n\", real_ptr);\n@@ -521,9 +539,9 @@ void GC_finalize()\n       while (curr_fo != 0) {\n         real_ptr = (ptr_t)REVEAL_POINTER(curr_fo -> fo_hidden_base);\n         if (!GC_is_marked(real_ptr)) {\n-#         ifndef JAVA_FINALIZATION\n-            GC_set_mark_bit(real_ptr);\n-#         endif\n+\t    if (!GC_java_finalization) {\n+              GC_set_mark_bit(real_ptr);\n+\t    }\n             /* Delete from hash table */\n               next_fo = fo_next(curr_fo);\n               if (prev_fo == 0) {\n@@ -555,20 +573,20 @@ void GC_finalize()\n       }\n     }\n \n-# ifdef JAVA_FINALIZATION\n-  /* make sure we mark everything reachable from objects finalized\n-     using the no_order mark_proc */\n-    for (curr_fo = GC_finalize_now; \n-\t curr_fo != NULL; curr_fo = fo_next(curr_fo)) {\n-\treal_ptr = (ptr_t)curr_fo -> fo_hidden_base;\n-\tif (!GC_is_marked(real_ptr)) {\n-\t    if (curr_fo -> fo_mark_proc == GC_null_finalize_mark_proc) {\n-\t        GC_MARK_FO(real_ptr, GC_normal_finalize_mark_proc);\n-\t    }\n-\t    GC_set_mark_bit(real_ptr);\n-\t}\n-    }\n-# endif\n+  if (GC_java_finalization) {\n+    /* make sure we mark everything reachable from objects finalized\n+       using the no_order mark_proc */\n+      for (curr_fo = GC_finalize_now; \n+  \t curr_fo != NULL; curr_fo = fo_next(curr_fo)) {\n+  \treal_ptr = (ptr_t)curr_fo -> fo_hidden_base;\n+  \tif (!GC_is_marked(real_ptr)) {\n+  \t    if (curr_fo -> fo_mark_proc == GC_null_finalize_mark_proc) {\n+  \t        GC_MARK_FO(real_ptr, GC_normal_finalize_mark_proc);\n+  \t    }\n+  \t    GC_set_mark_bit(real_ptr);\n+  \t}\n+      }\n+  }\n \n   /* Remove dangling disappearing links. */\n     for (i = 0; i < dl_size; i++) {\n@@ -594,7 +612,7 @@ void GC_finalize()\n     }\n }\n \n-#ifdef JAVA_FINALIZATION\n+#ifndef JAVA_FINALIZATION_NOT_NEEDED\n \n /* Enqueue all remaining finalizers to be run - Assumes lock is\n  * held, and signals are disabled */\n@@ -648,10 +666,16 @@ void GC_enqueue_all_finalizers()\n  * which can make the runtime guarantee that all finalizers are run.\n  * Unfortunately, the Java standard implies we have to keep running\n  * finalizers until there are no more left, a potential infinite loop.\n- * YUCK.  * This routine is externally callable, so is called without \n- * the allocation lock \n+ * YUCK.\n+ * Note that this is even more dangerous than the usual Java\n+ * finalizers, in that objects reachable from static variables\n+ * may have been finalized when these finalizers are run.\n+ * Finalizers run at this point must be prepared to deal with a\n+ * mostly broken world.\n+ * This routine is externally callable, so is called without \n+ * the allocation lock. \n  */\n-void GC_finalize_all()\n+GC_API void GC_finalize_all()\n {\n     DCL_LOCK_STATE;\n "}, {"sha": "535ff63ac0316ee392ecbfe226a553aba2fddadf", "filename": "boehm-gc/gc.h", "status": "modified", "additions": 80, "deletions": 12, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20bbd3cd53a80ddafa56a5d21337aae0c24f94ca/boehm-gc%2Fgc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20bbd3cd53a80ddafa56a5d21337aae0c24f94ca/boehm-gc%2Fgc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fgc.h?ref=20bbd3cd53a80ddafa56a5d21337aae0c24f94ca", "patch": "@@ -36,11 +36,19 @@\n #endif\n \n #if defined(_MSC_VER) && defined(_DLL)\n-#ifdef GC_BUILD\n-#define GC_API __declspec(dllexport)\n-#else\n-#define GC_API __declspec(dllimport)\n+# ifdef GC_BUILD\n+#   define GC_API __declspec(dllexport)\n+# else\n+#   define GC_API __declspec(dllimport)\n+# endif\n #endif\n+\n+#if defined(__WATCOMC__) && defined(GC_DLL)\n+# ifdef GC_BUILD\n+#   define GC_API extern __declspec(dllexport)\n+# else\n+#   define GC_API extern __declspec(dllimport)\n+# endif\n #endif\n \n #ifndef GC_API\n@@ -50,9 +58,11 @@\n # if defined(__STDC__) || defined(__cplusplus)\n #   define GC_PROTO(args) args\n     typedef void * GC_PTR;\n+#   define GC_CONST const\n # else\n #   define GC_PROTO(args) ()\n     typedef char * GC_PTR;\n+#   define GC_CONST\n #  endif\n \n # ifdef __cplusplus\n@@ -88,11 +98,31 @@ GC_API GC_PTR (*GC_oom_fn) GC_PROTO((size_t bytes_requested));\n \t\t\t/* pointer to a previously allocated heap \t*/\n \t\t\t/* object.\t\t\t\t\t*/\n \n+GC_API int GC_find_leak;\n+\t\t\t/* Do not actually garbage collect, but simply\t*/\n+\t\t\t/* report inaccessible memory that was not\t*/\n+\t\t\t/* deallocated with GC_free.  Initial value\t*/\n+\t\t\t/* is determined by FIND_LEAK macro.\t\t*/\n+\n GC_API int GC_quiet;\t/* Disable statistics output.  Only matters if\t*/\n \t\t\t/* collector has been compiled with statistics\t*/\n \t\t\t/* enabled.  This involves a performance cost,\t*/\n \t\t\t/* and is thus not the default.\t\t\t*/\n \n+GC_API int GC_finalize_on_demand;\n+\t\t\t/* If nonzero, finalizers will only be run in \t*/\n+\t\t\t/* response to an eplit GC_invoke_finalizers\t*/\n+\t\t\t/* call.  The default is determined by whether\t*/\n+\t\t\t/* the FINALIZE_ON_DEMAND macro is defined\t*/\n+\t\t\t/* when the collector is built.\t\t\t*/\n+\n+GC_API int GC_java_finalization;\n+\t\t\t/* Mark objects reachable from finalizable \t*/\n+\t\t\t/* objects in a separate postpass.  This makes\t*/\n+\t\t\t/* it a bit safer to use non-topologically-\t*/\n+\t\t\t/* ordered finalization.  Default value is\t*/\n+\t\t\t/* determined by JAVA_FINALIZATION macro.\t*/\n+\n GC_API int GC_dont_gc;\t/* Dont collect unless explicitly requested, e.g. */\n \t\t\t/* because it's not safe.\t\t\t  */\n \n@@ -103,6 +133,12 @@ GC_API int GC_dont_expand;\n GC_API int GC_full_freq;    /* Number of partial collections between\t*/\n \t\t\t    /* full collections.  Matters only if\t*/\n \t\t\t    /* GC_incremental is set.\t\t\t*/\n+\t\t\t    /* Full collections are also triggered if\t*/\n+\t\t\t    /* the collector detects a substantial\t*/\n+\t\t\t    /* increase in the number of in-use heap\t*/\n+\t\t\t    /* blocks.  Values in the tens are now\t*/\n+\t\t\t    /* perfectly reasonable, unlike for\t\t*/\n+\t\t\t    /* earlier GC versions.\t\t\t*/\n \t\t\t\n GC_API GC_word GC_non_gc_bytes;\n \t\t\t/* Bytes not considered candidates for collection. */\n@@ -126,7 +162,19 @@ GC_API GC_word GC_max_retries;\n \t\t\t/* reporting out of memory after heap\t\t*/\n \t\t\t/* expansion fails.  Initially 0.\t\t*/\n \t\t\t\n-\t\t\t\n+\n+GC_API char *GC_stackbottom;\t/* Cool end of user stack.\t\t*/\n+\t\t\t\t/* May be set in the client prior to\t*/\n+\t\t\t\t/* calling any GC_ routines.  This\t*/\n+\t\t\t\t/* avoids some overhead, and \t\t*/\n+\t\t\t\t/* potentially some signals that can \t*/\n+\t\t\t\t/* confuse debuggers.  Otherwise the\t*/\n+\t\t\t\t/* collector attempts to set it \t*/\n+\t\t\t\t/* automatically.\t\t\t*/\n+\t\t\t\t/* For multithreaded code, this is the\t*/\n+\t\t\t\t/* cold end of the stack for the\t*/\n+\t\t\t\t/* primordial thread.\t\t\t*/\n+\t\t\t\t\n /* Public procedures */\n /*\n  * general purpose allocation routines, with roughly malloc calling conv.\n@@ -193,8 +241,8 @@ GC_API size_t GC_size GC_PROTO((GC_PTR object_addr));\n /* If the argument is stubborn, the result will have changes enabled.\t*/\n /* It is an error to have changes enabled for the original object.\t*/\n /* Follows ANSI comventions for NULL old_object.\t\t\t*/\n-GC_API GC_PTR GC_realloc GC_PROTO((GC_PTR old_object,\n-\t\t\t\t   size_t new_size_in_bytes));\n+GC_API GC_PTR GC_realloc\n+\tGC_PROTO((GC_PTR old_object, size_t new_size_in_bytes));\n \t\t\t\t   \n /* Explicitly increase the heap size.\t*/\n /* Returns 0 on failure, 1 on success.  */\n@@ -248,6 +296,7 @@ GC_API void GC_gcollect GC_PROTO((void));\n /* than normal pause times for incremental collection.  However,\t*/\n /* aborted collections do no useful work; the next collection needs\t*/\n /* to start from the beginning.\t\t\t\t\t\t*/\n+/* Return 0 if the collection was aborted, 1 if it succeeded.\t\t*/\n typedef int (* GC_stop_func) GC_PROTO((void));\n GC_API int GC_try_to_collect GC_PROTO((GC_stop_func stop_func));\n \n@@ -256,6 +305,9 @@ GC_API int GC_try_to_collect GC_PROTO((GC_stop_func stop_func));\n /* Includes some pages that were allocated but never written.\t\t*/\n GC_API size_t GC_get_heap_size GC_PROTO((void));\n \n+/* Return a lower bound on the number of free bytes in the heap.\t*/\n+GC_API size_t GC_get_free_bytes GC_PROTO((void));\n+\n /* Return the number of bytes allocated since the last collection.\t*/\n GC_API size_t GC_get_bytes_since_gc GC_PROTO((void));\n \n@@ -300,10 +352,11 @@ GC_API GC_PTR GC_malloc_atomic_ignore_off_page GC_PROTO((size_t lb));\n \n #ifdef GC_ADD_CALLER\n #  define GC_EXTRAS GC_RETURN_ADDR, __FILE__, __LINE__\n-#  define GC_EXTRA_PARAMS GC_word ra, char * descr_string, int descr_int\n+#  define GC_EXTRA_PARAMS GC_word ra, GC_CONST char * descr_string,\n+\t\t          int descr_int\n #else\n #  define GC_EXTRAS __FILE__, __LINE__\n-#  define GC_EXTRA_PARAMS char * descr_string, int descr_int\n+#  define GC_EXTRA_PARAMS GC_CONST char * descr_string, int descr_int\n #endif\n \n /* Debugging (annotated) allocation.  GC_gcollect will check \t\t*/\n@@ -502,7 +555,7 @@ GC_API int GC_invoke_finalizers GC_PROTO((void));\n \t/* be finalized.  Return the number of finalizers\t*/\n \t/* that were run.  Normally this is also called\t\t*/\n \t/* implicitly during some allocations.\tIf\t\t*/\n-\t/* FINALIZE_ON_DEMAND is defined, it must be called\t*/\n+\t/* GC-finalize_on_demand is nonzero, it must be called\t*/\n \t/* explicitly.\t\t\t\t\t\t*/\n \n /* GC_set_warn_proc can be used to redirect or filter warning messages.\t*/\n@@ -617,6 +670,10 @@ GC_API void (*GC_is_valid_displacement_print_proc)\n GC_API void (*GC_is_visible_print_proc)\n \tGC_PROTO((GC_PTR p));\n \n+#if defined(_SOLARIS_PTHREADS) && !defined(SOLARIS_THREADS)\n+#   define SOLARIS_THREADS\n+#endif\n+\n #ifdef SOLARIS_THREADS\n /* We need to intercept calls to many of the threads primitives, so \t*/\n /* that we can locate thread stacks and stop the world.\t\t\t*/\n@@ -656,7 +713,7 @@ GC_API void (*GC_is_visible_print_proc)\n # endif /* SOLARIS_THREADS */\n \n \n-#if defined(IRIX_THREADS) || defined(LINUX_THREADS)\n+#if defined(IRIX_THREADS) || defined(LINUX_THREADS) || defined(HPUX_THREADS)\n /* We treat these similarly. */\n # include <pthread.h>\n # include <signal.h>\n@@ -673,10 +730,14 @@ GC_API void (*GC_is_visible_print_proc)\n \n #endif /* IRIX_THREADS || LINUX_THREADS */\n \n-#if defined(THREADS) && !defined(SRC_M3)\n+# if defined(PCR) || defined(SOLARIS_THREADS) || defined(WIN32_THREADS) || \\\n+\tdefined(IRIX_THREADS) || defined(LINUX_THREADS) || \\\n+\tdefined(IRIX_JDK_THREADS) || defined(HPUX_THREADS)\n+   \t/* Any flavor of threads except SRC_M3.\t*/\n /* This returns a list of objects, linked through their first\t\t*/\n /* word.  Its use can greatly reduce lock contention problems, since\t*/\n /* the allocation lock can be acquired and released many fewer times.\t*/\n+/* lb must be large enough to hold the pointer field.\t\t\t*/\n GC_PTR GC_malloc_many(size_t lb);\n #define GC_NEXT(p) (*(GC_PTR *)(p)) \t/* Retrieve the next element\t*/\n \t\t\t\t\t/* in returned list.\t\t*/\n@@ -704,6 +765,13 @@ extern void GC_thr_init();\t/* Needed for Solaris/X86\t*/\n # endif\n #endif\n \n+#if (defined(_MSDOS) || defined(_MSC_VER)) && (_M_IX86 >= 300) \\\n+     || defined(_WIN32)\n+  /* win32S may not free all resources on process exit.  */\n+  /* This explicitly deallocates the heap.\t\t */\n+    GC_API void GC_win32_free_heap ();\n+#endif\n+\n #ifdef __cplusplus\n     }  /* end of extern \"C\" */\n #endif"}, {"sha": "0fd22b70d6033132fee18c6936202d6b2bcc151c", "filename": "boehm-gc/gc.mak", "status": "modified", "additions": 46, "deletions": 46, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20bbd3cd53a80ddafa56a5d21337aae0c24f94ca/boehm-gc%2Fgc.mak", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20bbd3cd53a80ddafa56a5d21337aae0c24f94ca/boehm-gc%2Fgc.mak", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fgc.mak?ref=20bbd3cd53a80ddafa56a5d21337aae0c24f94ca", "patch": "@@ -5,7 +5,7 @@\n # TARGTYPE \"Win32 (x86) Dynamic-Link Library\" 0x0102\n \n !IF \"$(CFG)\" == \"\"\n-CFG=cord - Win32 Debug\n+CFG=gctest - Win32 Release\n !MESSAGE No configuration specified.  Defaulting to cord - Win32 Debug.\n !ENDIF \n \n@@ -768,7 +768,7 @@ SOURCE=.\\reclaim.c\n !IF  \"$(CFG)\" == \"gc - Win32 Release\"\n \n DEP_CPP_RECLA=\\\n-\t\".\\config.h\"\\\n+\t\".\\gcconfig.h\"\\\n \t\".\\gc.h\"\\\n \t\".\\gc_hdrs.h\"\\\n \t\".\\gc_priv.h\"\\\n@@ -788,7 +788,7 @@ NODEP_CPP_RECLA=\\\n !ELSEIF  \"$(CFG)\" == \"gc - Win32 Debug\"\n \n DEP_CPP_RECLA=\\\n-\t\".\\config.h\"\\\n+\t\".\\gcconfig.h\"\\\n \t\".\\gc.h\"\\\n \t\".\\gc_hdrs.h\"\\\n \t\".\\gc_priv.h\"\\\n@@ -816,7 +816,7 @@ SOURCE=.\\os_dep.c\n !IF  \"$(CFG)\" == \"gc - Win32 Release\"\n \n DEP_CPP_OS_DE=\\\n-\t\".\\config.h\"\\\n+\t\".\\gcconfig.h\"\\\n \t\".\\gc.h\"\\\n \t\".\\gc_hdrs.h\"\\\n \t\".\\gc_priv.h\"\\\n@@ -840,7 +840,7 @@ NODEP_CPP_OS_DE=\\\n !ELSEIF  \"$(CFG)\" == \"gc - Win32 Debug\"\n \n DEP_CPP_OS_DE=\\\n-\t\".\\config.h\"\\\n+\t\".\\gcconfig.h\"\\\n \t\".\\gc.h\"\\\n \t\".\\gc_hdrs.h\"\\\n \t\".\\gc_priv.h\"\\\n@@ -872,7 +872,7 @@ SOURCE=.\\misc.c\n !IF  \"$(CFG)\" == \"gc - Win32 Release\"\n \n DEP_CPP_MISC_=\\\n-\t\".\\config.h\"\\\n+\t\".\\gcconfig.h\"\\\n \t\".\\gc.h\"\\\n \t\".\\gc_hdrs.h\"\\\n \t\".\\gc_priv.h\"\\\n@@ -893,7 +893,7 @@ NODEP_CPP_MISC_=\\\n !ELSEIF  \"$(CFG)\" == \"gc - Win32 Debug\"\n \n DEP_CPP_MISC_=\\\n-\t\".\\config.h\"\\\n+\t\".\\gcconfig.h\"\\\n \t\".\\gc.h\"\\\n \t\".\\gc_hdrs.h\"\\\n \t\".\\gc_priv.h\"\\\n@@ -922,7 +922,7 @@ SOURCE=.\\mark_rts.c\n !IF  \"$(CFG)\" == \"gc - Win32 Release\"\n \n DEP_CPP_MARK_=\\\n-\t\".\\config.h\"\\\n+\t\".\\gcconfig.h\"\\\n \t\".\\gc.h\"\\\n \t\".\\gc_hdrs.h\"\\\n \t\".\\gc_priv.h\"\\\n@@ -942,7 +942,7 @@ NODEP_CPP_MARK_=\\\n !ELSEIF  \"$(CFG)\" == \"gc - Win32 Debug\"\n \n DEP_CPP_MARK_=\\\n-\t\".\\config.h\"\\\n+\t\".\\gcconfig.h\"\\\n \t\".\\gc.h\"\\\n \t\".\\gc_hdrs.h\"\\\n \t\".\\gc_priv.h\"\\\n@@ -970,7 +970,7 @@ SOURCE=.\\mach_dep.c\n !IF  \"$(CFG)\" == \"gc - Win32 Release\"\n \n DEP_CPP_MACH_=\\\n-\t\".\\config.h\"\\\n+\t\".\\gcconfig.h\"\\\n \t\".\\gc.h\"\\\n \t\".\\gc_hdrs.h\"\\\n \t\".\\gc_priv.h\"\\\n@@ -990,7 +990,7 @@ NODEP_CPP_MACH_=\\\n !ELSEIF  \"$(CFG)\" == \"gc - Win32 Debug\"\n \n DEP_CPP_MACH_=\\\n-\t\".\\config.h\"\\\n+\t\".\\gcconfig.h\"\\\n \t\".\\gc.h\"\\\n \t\".\\gc_hdrs.h\"\\\n \t\".\\gc_priv.h\"\\\n@@ -1018,7 +1018,7 @@ SOURCE=.\\headers.c\n !IF  \"$(CFG)\" == \"gc - Win32 Release\"\n \n DEP_CPP_HEADE=\\\n-\t\".\\config.h\"\\\n+\t\".\\gcconfig.h\"\\\n \t\".\\gc.h\"\\\n \t\".\\gc_hdrs.h\"\\\n \t\".\\gc_priv.h\"\\\n@@ -1038,7 +1038,7 @@ NODEP_CPP_HEADE=\\\n !ELSEIF  \"$(CFG)\" == \"gc - Win32 Debug\"\n \n DEP_CPP_HEADE=\\\n-\t\".\\config.h\"\\\n+\t\".\\gcconfig.h\"\\\n \t\".\\gc.h\"\\\n \t\".\\gc_hdrs.h\"\\\n \t\".\\gc_priv.h\"\\\n@@ -1066,7 +1066,7 @@ SOURCE=.\\alloc.c\n !IF  \"$(CFG)\" == \"gc - Win32 Release\"\n \n DEP_CPP_ALLOC=\\\n-\t\".\\config.h\"\\\n+\t\".\\gcconfig.h\"\\\n \t\".\\gc.h\"\\\n \t\".\\gc_hdrs.h\"\\\n \t\".\\gc_priv.h\"\\\n@@ -1086,7 +1086,7 @@ NODEP_CPP_ALLOC=\\\n !ELSEIF  \"$(CFG)\" == \"gc - Win32 Debug\"\n \n DEP_CPP_ALLOC=\\\n-\t\".\\config.h\"\\\n+\t\".\\gcconfig.h\"\\\n \t\".\\gc.h\"\\\n \t\".\\gc_hdrs.h\"\\\n \t\".\\gc_priv.h\"\\\n@@ -1114,7 +1114,7 @@ SOURCE=.\\allchblk.c\n !IF  \"$(CFG)\" == \"gc - Win32 Release\"\n \n DEP_CPP_ALLCH=\\\n-\t\".\\config.h\"\\\n+\t\".\\gcconfig.h\"\\\n \t\".\\gc.h\"\\\n \t\".\\gc_hdrs.h\"\\\n \t\".\\gc_priv.h\"\\\n@@ -1134,7 +1134,7 @@ NODEP_CPP_ALLCH=\\\n !ELSEIF  \"$(CFG)\" == \"gc - Win32 Debug\"\n \n DEP_CPP_ALLCH=\\\n-\t\".\\config.h\"\\\n+\t\".\\gcconfig.h\"\\\n \t\".\\gc.h\"\\\n \t\".\\gc_hdrs.h\"\\\n \t\".\\gc_priv.h\"\\\n@@ -1162,7 +1162,7 @@ SOURCE=.\\stubborn.c\n !IF  \"$(CFG)\" == \"gc - Win32 Release\"\n \n DEP_CPP_STUBB=\\\n-\t\".\\config.h\"\\\n+\t\".\\gcconfig.h\"\\\n \t\".\\gc.h\"\\\n \t\".\\gc_hdrs.h\"\\\n \t\".\\gc_priv.h\"\\\n@@ -1182,7 +1182,7 @@ NODEP_CPP_STUBB=\\\n !ELSEIF  \"$(CFG)\" == \"gc - Win32 Debug\"\n \n DEP_CPP_STUBB=\\\n-\t\".\\config.h\"\\\n+\t\".\\gcconfig.h\"\\\n \t\".\\gc.h\"\\\n \t\".\\gc_hdrs.h\"\\\n \t\".\\gc_priv.h\"\\\n@@ -1210,7 +1210,7 @@ SOURCE=.\\obj_map.c\n !IF  \"$(CFG)\" == \"gc - Win32 Release\"\n \n DEP_CPP_OBJ_M=\\\n-\t\".\\config.h\"\\\n+\t\".\\gcconfig.h\"\\\n \t\".\\gc.h\"\\\n \t\".\\gc_hdrs.h\"\\\n \t\".\\gc_priv.h\"\\\n@@ -1230,7 +1230,7 @@ NODEP_CPP_OBJ_M=\\\n !ELSEIF  \"$(CFG)\" == \"gc - Win32 Debug\"\n \n DEP_CPP_OBJ_M=\\\n-\t\".\\config.h\"\\\n+\t\".\\gcconfig.h\"\\\n \t\".\\gc.h\"\\\n \t\".\\gc_hdrs.h\"\\\n \t\".\\gc_priv.h\"\\\n@@ -1258,7 +1258,7 @@ SOURCE=.\\new_hblk.c\n !IF  \"$(CFG)\" == \"gc - Win32 Release\"\n \n DEP_CPP_NEW_H=\\\n-\t\".\\config.h\"\\\n+\t\".\\gcconfig.h\"\\\n \t\".\\gc.h\"\\\n \t\".\\gc_hdrs.h\"\\\n \t\".\\gc_priv.h\"\\\n@@ -1278,7 +1278,7 @@ NODEP_CPP_NEW_H=\\\n !ELSEIF  \"$(CFG)\" == \"gc - Win32 Debug\"\n \n DEP_CPP_NEW_H=\\\n-\t\".\\config.h\"\\\n+\t\".\\gcconfig.h\"\\\n \t\".\\gc.h\"\\\n \t\".\\gc_hdrs.h\"\\\n \t\".\\gc_priv.h\"\\\n@@ -1306,7 +1306,7 @@ SOURCE=.\\mark.c\n !IF  \"$(CFG)\" == \"gc - Win32 Release\"\n \n DEP_CPP_MARK_C=\\\n-\t\".\\config.h\"\\\n+\t\".\\gcconfig.h\"\\\n \t\".\\gc.h\"\\\n \t\".\\gc_hdrs.h\"\\\n \t\".\\gc_mark.h\"\\\n@@ -1327,7 +1327,7 @@ NODEP_CPP_MARK_C=\\\n !ELSEIF  \"$(CFG)\" == \"gc - Win32 Debug\"\n \n DEP_CPP_MARK_C=\\\n-\t\".\\config.h\"\\\n+\t\".\\gcconfig.h\"\\\n \t\".\\gc.h\"\\\n \t\".\\gc_hdrs.h\"\\\n \t\".\\gc_mark.h\"\\\n@@ -1356,7 +1356,7 @@ SOURCE=.\\malloc.c\n !IF  \"$(CFG)\" == \"gc - Win32 Release\"\n \n DEP_CPP_MALLO=\\\n-\t\".\\config.h\"\\\n+\t\".\\gcconfig.h\"\\\n \t\".\\gc.h\"\\\n \t\".\\gc_hdrs.h\"\\\n \t\".\\gc_priv.h\"\\\n@@ -1376,7 +1376,7 @@ NODEP_CPP_MALLO=\\\n !ELSEIF  \"$(CFG)\" == \"gc - Win32 Debug\"\n \n DEP_CPP_MALLO=\\\n-\t\".\\config.h\"\\\n+\t\".\\gcconfig.h\"\\\n \t\".\\gc.h\"\\\n \t\".\\gc_hdrs.h\"\\\n \t\".\\gc_priv.h\"\\\n@@ -1404,7 +1404,7 @@ SOURCE=.\\mallocx.c\n !IF  \"$(CFG)\" == \"gc - Win32 Release\"\n \n DEP_CPP_MALLX=\\\n-\t\".\\config.h\"\\\n+\t\".\\gcconfig.h\"\\\n \t\".\\gc.h\"\\\n \t\".\\gc_hdrs.h\"\\\n \t\".\\gc_priv.h\"\\\n@@ -1424,7 +1424,7 @@ NODEP_CPP_MALLX=\\\n !ELSEIF  \"$(CFG)\" == \"gc - Win32 Debug\"\n \n DEP_CPP_MALLX=\\\n-\t\".\\config.h\"\\\n+\t\".\\gcconfig.h\"\\\n \t\".\\gc.h\"\\\n \t\".\\gc_hdrs.h\"\\\n \t\".\\gc_priv.h\"\\\n@@ -1452,7 +1452,7 @@ SOURCE=.\\finalize.c\n !IF  \"$(CFG)\" == \"gc - Win32 Release\"\n \n DEP_CPP_FINAL=\\\n-\t\".\\config.h\"\\\n+\t\".\\gcconfig.h\"\\\n \t\".\\gc.h\"\\\n \t\".\\gc_hdrs.h\"\\\n \t\".\\gc_mark.h\"\\\n@@ -1473,7 +1473,7 @@ NODEP_CPP_FINAL=\\\n !ELSEIF  \"$(CFG)\" == \"gc - Win32 Debug\"\n \n DEP_CPP_FINAL=\\\n-\t\".\\config.h\"\\\n+\t\".\\gcconfig.h\"\\\n \t\".\\gc.h\"\\\n \t\".\\gc_hdrs.h\"\\\n \t\".\\gc_mark.h\"\\\n@@ -1502,7 +1502,7 @@ SOURCE=.\\dbg_mlc.c\n !IF  \"$(CFG)\" == \"gc - Win32 Release\"\n \n DEP_CPP_DBG_M=\\\n-\t\".\\config.h\"\\\n+\t\".\\gcconfig.h\"\\\n \t\".\\gc.h\"\\\n \t\".\\gc_hdrs.h\"\\\n \t\".\\gc_priv.h\"\\\n@@ -1522,7 +1522,7 @@ NODEP_CPP_DBG_M=\\\n !ELSEIF  \"$(CFG)\" == \"gc - Win32 Debug\"\n \n DEP_CPP_DBG_M=\\\n-\t\".\\config.h\"\\\n+\t\".\\gcconfig.h\"\\\n \t\".\\gc.h\"\\\n \t\".\\gc_hdrs.h\"\\\n \t\".\\gc_priv.h\"\\\n@@ -1550,7 +1550,7 @@ SOURCE=.\\blacklst.c\n !IF  \"$(CFG)\" == \"gc - Win32 Release\"\n \n DEP_CPP_BLACK=\\\n-\t\".\\config.h\"\\\n+\t\".\\gcconfig.h\"\\\n \t\".\\gc.h\"\\\n \t\".\\gc_hdrs.h\"\\\n \t\".\\gc_priv.h\"\\\n@@ -1570,7 +1570,7 @@ NODEP_CPP_BLACK=\\\n !ELSEIF  \"$(CFG)\" == \"gc - Win32 Debug\"\n \n DEP_CPP_BLACK=\\\n-\t\".\\config.h\"\\\n+\t\".\\gcconfig.h\"\\\n \t\".\\gc.h\"\\\n \t\".\\gc_hdrs.h\"\\\n \t\".\\gc_priv.h\"\\\n@@ -1598,7 +1598,7 @@ SOURCE=.\\typd_mlc.c\n !IF  \"$(CFG)\" == \"gc - Win32 Release\"\n \n DEP_CPP_TYPD_=\\\n-\t\".\\config.h\"\\\n+\t\".\\gcconfig.h\"\\\n \t\".\\gc.h\"\\\n \t\".\\gc_hdrs.h\"\\\n \t\".\\gc_mark.h\"\\\n@@ -1620,7 +1620,7 @@ NODEP_CPP_TYPD_=\\\n !ELSEIF  \"$(CFG)\" == \"gc - Win32 Debug\"\n \n DEP_CPP_TYPD_=\\\n-\t\".\\config.h\"\\\n+\t\".\\gcconfig.h\"\\\n \t\".\\gc.h\"\\\n \t\".\\gc_hdrs.h\"\\\n \t\".\\gc_mark.h\"\\\n@@ -1650,7 +1650,7 @@ SOURCE=.\\ptr_chck.c\n !IF  \"$(CFG)\" == \"gc - Win32 Release\"\n \n DEP_CPP_PTR_C=\\\n-\t\".\\config.h\"\\\n+\t\".\\gcconfig.h\"\\\n \t\".\\gc.h\"\\\n \t\".\\gc_hdrs.h\"\\\n \t\".\\gc_mark.h\"\\\n@@ -1671,7 +1671,7 @@ NODEP_CPP_PTR_C=\\\n !ELSEIF  \"$(CFG)\" == \"gc - Win32 Debug\"\n \n DEP_CPP_PTR_C=\\\n-\t\".\\config.h\"\\\n+\t\".\\gcconfig.h\"\\\n \t\".\\gc.h\"\\\n \t\".\\gc_hdrs.h\"\\\n \t\".\\gc_mark.h\"\\\n@@ -1700,7 +1700,7 @@ SOURCE=.\\dyn_load.c\n !IF  \"$(CFG)\" == \"gc - Win32 Release\"\n \n DEP_CPP_DYN_L=\\\n-\t\".\\config.h\"\\\n+\t\".\\gcconfig.h\"\\\n \t\".\\gc.h\"\\\n \t\".\\gc_hdrs.h\"\\\n \t\".\\gc_priv.h\"\\\n@@ -1723,7 +1723,7 @@ NODEP_CPP_DYN_L=\\\n !ELSEIF  \"$(CFG)\" == \"gc - Win32 Debug\"\n \n DEP_CPP_DYN_L=\\\n-\t\".\\config.h\"\\\n+\t\".\\gcconfig.h\"\\\n \t\".\\gc.h\"\\\n \t\".\\gc_hdrs.h\"\\\n \t\".\\gc_priv.h\"\\\n@@ -1754,7 +1754,7 @@ SOURCE=.\\win32_threads.c\n !IF  \"$(CFG)\" == \"gc - Win32 Release\"\n \n DEP_CPP_WIN32=\\\n-\t\".\\config.h\"\\\n+\t\".\\gcconfig.h\"\\\n \t\".\\gc.h\"\\\n \t\".\\gc_hdrs.h\"\\\n \t\".\\gc_priv.h\"\\\n@@ -1774,7 +1774,7 @@ NODEP_CPP_WIN32=\\\n !ELSEIF  \"$(CFG)\" == \"gc - Win32 Debug\"\n \n DEP_CPP_WIN32=\\\n-\t\".\\config.h\"\\\n+\t\".\\gcconfig.h\"\\\n \t\".\\gc.h\"\\\n \t\".\\gc_hdrs.h\"\\\n \t\".\\gc_priv.h\"\\\n@@ -1802,7 +1802,7 @@ SOURCE=.\\checksums.c\n !IF  \"$(CFG)\" == \"gc - Win32 Release\"\n \n DEP_CPP_CHECK=\\\n-\t\".\\config.h\"\\\n+\t\".\\gcconfig.h\"\\\n \t\".\\gc.h\"\\\n \t\".\\gc_hdrs.h\"\\\n \t\".\\gc_priv.h\"\\\n@@ -1822,7 +1822,7 @@ NODEP_CPP_CHECK=\\\n !ELSEIF  \"$(CFG)\" == \"gc - Win32 Debug\"\n \n DEP_CPP_CHECK=\\\n-\t\".\\config.h\"\\\n+\t\".\\gcconfig.h\"\\\n \t\".\\gc.h\"\\\n \t\".\\gc_hdrs.h\"\\\n \t\".\\gc_priv.h\"\\\n@@ -1878,7 +1878,7 @@ NODEP_CPP_CHECK=\\\n \n SOURCE=.\\test.c\n DEP_CPP_TEST_=\\\n-\t\".\\config.h\"\\\n+\t\".\\gcconfig.h\"\\\n \t\".\\gc.h\"\\\n \t\".\\gc_hdrs.h\"\\\n \t\".\\gc_priv.h\"\\"}, {"sha": "1f1d54aff95608531e53fb5f30bf5d1a1da18130", "filename": "boehm-gc/gc_alloc.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20bbd3cd53a80ddafa56a5d21337aae0c24f94ca/boehm-gc%2Fgc_alloc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20bbd3cd53a80ddafa56a5d21337aae0c24f94ca/boehm-gc%2Fgc_alloc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fgc_alloc.h?ref=20bbd3cd53a80ddafa56a5d21337aae0c24f94ca", "patch": "@@ -13,7 +13,7 @@\n \n //\n // This is a C++ header file that is intended to replace the SGI STL\n-// alloc.h.\n+// alloc.h.  This assumes SGI STL version < 3.0.\n //\n // This assumes the collector has been compiled with -DATOMIC_UNCOLLECTABLE\n // and -DALL_INTERIOR_POINTERS.  We also recommend"}, {"sha": "547c56f96a17c2df980fbc4d04fb123dd7a09920", "filename": "boehm-gc/gc_cpp.cc", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20bbd3cd53a80ddafa56a5d21337aae0c24f94ca/boehm-gc%2Fgc_cpp.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20bbd3cd53a80ddafa56a5d21337aae0c24f94ca/boehm-gc%2Fgc_cpp.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fgc_cpp.cc?ref=20bbd3cd53a80ddafa56a5d21337aae0c24f94ca", "patch": "@@ -32,6 +32,20 @@ void* operator new( size_t size ) {\n void operator delete( void* obj ) {\n     GC_FREE( obj );}\n   \n+#ifdef _MSC_VER\n+// This new operator is used by VC++ in case of Debug builds !\n+void* operator new( size_t size,\n+                    int ,//nBlockUse,\n+                    const char * szFileName,\n+                    int nLine\n+                    ) {\n+# ifndef GC_DEBUG\n+    return GC_malloc_uncollectable( size );\n+# else\n+    return GC_debug_malloc_uncollectable(size, szFileName, nLine);\n+# endif\n+}\n+#endif\n \n #ifdef OPERATOR_NEW_ARRAY\n "}, {"sha": "ad7df5d71faf94e0231e8bed5688fd236a255990", "filename": "boehm-gc/gc_cpp.h", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20bbd3cd53a80ddafa56a5d21337aae0c24f94ca/boehm-gc%2Fgc_cpp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20bbd3cd53a80ddafa56a5d21337aae0c24f94ca/boehm-gc%2Fgc_cpp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fgc_cpp.h?ref=20bbd3cd53a80ddafa56a5d21337aae0c24f94ca", "patch": "@@ -133,7 +133,8 @@ uses explicit invocation.\n #endif\n \n #if ! defined( OPERATOR_NEW_ARRAY ) \\\n-    && (__BORLANDC__ >= 0x450 || (__GNUC__ >= 2 && __GNUC_MINOR__ >= 6))\n+    && (__BORLANDC__ >= 0x450 || (__GNUC__ >= 2 && __GNUC_MINOR__ >= 6) \\\n+        || __WATCOMC__ >= 1050)\n #   define OPERATOR_NEW_ARRAY\n #endif\n \n@@ -212,6 +213,8 @@ inline void* gc::operator new( size_t size ) {\n inline void* gc::operator new( size_t size, GCPlacement gcp ) {\n     if (gcp == GC) \n         return GC_MALLOC( size );\n+    else if (gcp == PointerFreeGC)\n+\treturn GC_MALLOC_ATOMIC( size );\n     else\n         return GC_MALLOC_UNCOLLECTABLE( size );}\n \n@@ -234,7 +237,7 @@ inline void gc::operator delete[]( void* obj ) {\n \n \n inline gc_cleanup::~gc_cleanup() {\n-    GC_REGISTER_FINALIZER_IGNORE_SELF( this, 0, 0, 0, 0 );}\n+    GC_REGISTER_FINALIZER_IGNORE_SELF( GC_base(this), 0, 0, 0, 0 );}\n \n inline void gc_cleanup::cleanup( void* obj, void* displ ) {\n     ((gc_cleanup*) ((char*) obj + (ptrdiff_t) displ))->~gc_cleanup();}"}, {"sha": "60dc2ad37d6d4df5abca307d2786ffad7fafc52a", "filename": "boehm-gc/gc_hdrs.h", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20bbd3cd53a80ddafa56a5d21337aae0c24f94ca/boehm-gc%2Fgc_hdrs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20bbd3cd53a80ddafa56a5d21337aae0c24f94ca/boehm-gc%2Fgc_hdrs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fgc_hdrs.h?ref=20bbd3cd53a80ddafa56a5d21337aae0c24f94ca", "patch": "@@ -49,14 +49,16 @@ typedef struct bi {\n     hdr * index[BOTTOM_SZ];\n \t/*\n  \t * The bottom level index contains one of three kinds of values:\n-\t * 0 means we're not responsible for this block.\n+\t * 0 means we're not responsible for this block,\n+\t *   or this is a block other than the first one in a free block.\n \t * 1 < (long)X <= MAX_JUMP means the block starts at least\n \t *        X * HBLKSIZE bytes before the current address.\n \t * A valid pointer points to a hdr structure. (The above can't be\n \t * valid pointers due to the GET_MEM return convention.)\n \t */\n     struct bi * asc_link;\t/* All indices are linked in\t*/\n-    \t\t\t\t/* ascending order.\t\t*/\n+    \t\t\t\t/* ascending order...\t\t*/\n+    struct bi * desc_link;\t/* ... and in descending order.\t*/\n     word key;\t\t\t/* high order address bits.\t*/\n # ifdef HASH_TL\n     struct bi * hash_link;\t/* Hash chain link.\t\t*/"}, {"sha": "4628323f990dc49c0e0956c1069ffed77da7f3ea", "filename": "boehm-gc/gc_mark.h", "status": "modified", "additions": 23, "deletions": 10, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20bbd3cd53a80ddafa56a5d21337aae0c24f94ca/boehm-gc%2Fgc_mark.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20bbd3cd53a80ddafa56a5d21337aae0c24f94ca/boehm-gc%2Fgc_mark.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fgc_mark.h?ref=20bbd3cd53a80ddafa56a5d21337aae0c24f94ca", "patch": "@@ -38,12 +38,17 @@\n /* subset of the places the conservative marker would.  It must be safe\t*/\n /* to invoke the normal mark procedure instead.\t\t\t\t*/\n # define PROC_BYTES 100\n-typedef struct ms_entry * (*mark_proc)(/* word * addr, mark_stack_ptr,\n-\t\t\t\t\t  mark_stack_limit, env */);\n+/* The real declarations of the following are in gc_priv.h, so that\t*/\n+/* we can avoid scanning the following table.\t\t\t\t*/\n+/*\n+typedef struct ms_entry * (*mark_proc)(   word * addr, mark_stack_ptr,\n+\t\t\t\t\t  mark_stack_limit, env   );\n \t\t\t\t\t  \n # define LOG_MAX_MARK_PROCS 6\n # define MAX_MARK_PROCS (1 << LOG_MAX_MARK_PROCS)\n extern mark_proc GC_mark_procs[MAX_MARK_PROCS];\n+*/\n+\n extern word GC_n_mark_procs;\n \n /* Object descriptors on mark stack or in objects.  Low order two\t*/\n@@ -166,25 +171,33 @@ mse * GC_signal_mark_stack_overflow();\n \t      /* Mark bit is already set */ \\\n \t      goto exit_label; \\\n         } \\\n+        GC_STORE_BACK_PTR((ptr_t)source, (ptr_t)HBLKPTR(current) \\\n+\t\t\t\t      + WORDS_TO_BYTES(displ)); \\\n         *mark_word_addr = mark_word | mark_bit; \\\n     } \\\n     PUSH_OBJ(((word *)(HBLKPTR(current)) + displ), hhdr, \\\n     \t     mark_stack_top, mark_stack_limit) \\\n   exit_label: ; \\\n }\n \n+#ifdef PRINT_BLACK_LIST\n+#   define PUSH_ONE_CHECKED(p, ip, source) \\\n+\tGC_push_one_checked(p, ip, (ptr_t)(source))\n+#else\n+#   define PUSH_ONE_CHECKED(p, ip, source) \\\n+\tGC_push_one_checked(p, ip)\n+#endif\n \n /*\n  * Push a single value onto mark stack. Mark from the object pointed to by p.\n- * GC_push_one is normally called by GC_push_regs, and thus must be defined.\n  * P is considered valid even if it is an interior pointer.\n  * Previously marked objects are not pushed.  Hence we make progress even\n  * if the mark stack overflows.\n  */\n-# define GC_PUSH_ONE_STACK(p) \\\n+# define GC_PUSH_ONE_STACK(p, source) \\\n     if ((ptr_t)(p) >= GC_least_plausible_heap_addr \t\\\n \t && (ptr_t)(p) < GC_greatest_plausible_heap_addr) {\t\\\n-\t GC_push_one_checked(p,TRUE);\t\\\n+\t PUSH_ONE_CHECKED(p, TRUE, source);\t\\\n     }\n \n /*\n@@ -196,10 +209,10 @@ mse * GC_signal_mark_stack_overflow();\n # else\n #   define AIP FALSE\n # endif\n-# define GC_PUSH_ONE_HEAP(p) \\\n+# define GC_PUSH_ONE_HEAP(p,source) \\\n     if ((ptr_t)(p) >= GC_least_plausible_heap_addr \t\\\n \t && (ptr_t)(p) < GC_greatest_plausible_heap_addr) {\t\\\n-\t GC_push_one_checked(p,AIP);\t\\\n+\t PUSH_ONE_CHECKED(p,AIP,source);\t\\\n     }\n \n /*\n@@ -213,7 +226,7 @@ mse * GC_signal_mark_stack_overflow();\n     while (!GC_mark_stack_empty()) GC_mark_from_mark_stack(); \\\n     if (GC_mark_state != MS_NONE) { \\\n         GC_set_mark_bit(real_ptr); \\\n-        while (!GC_mark_some()); \\\n+        while (!GC_mark_some((ptr_t)0)); \\\n     } \\\n }\n \n@@ -233,8 +246,8 @@ typedef int mark_state_t;\t/* Current state of marking, as follows:*/\n \t\t\t\t\n \t\t\t\t/* Invariant I: all roots and marked\t*/\n \t\t\t\t/* objects p are either dirty, or point */\n-\t\t\t\t/* objects q that are either marked or\t*/\n-\t\t\t\t/* a pointer to q appears in a range\t*/\n+\t\t\t\t/* to objects q that are either marked \t*/\n+\t\t\t\t/* or a pointer to q appears in a range\t*/\n \t\t\t\t/* on the mark stack.\t\t\t*/\n \n # define MS_NONE 0\t\t/* No marking in progress. I holds.\t*/"}, {"sha": "8dd496f31e1f4cc983f01b351aa6d2a688b8565f", "filename": "boehm-gc/gc_priv.h", "status": "modified", "additions": 293, "deletions": 88, "changes": 381, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20bbd3cd53a80ddafa56a5d21337aae0c24f94ca/boehm-gc%2Fgc_priv.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20bbd3cd53a80ddafa56a5d21337aae0c24f94ca/boehm-gc%2Fgc_priv.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fgc_priv.h?ref=20bbd3cd53a80ddafa56a5d21337aae0c24f94ca", "patch": "@@ -1,6 +1,9 @@\n /* \n  * Copyright 1988, 1989 Hans-J. Boehm, Alan J. Demers\n  * Copyright (c) 1991-1994 by Xerox Corporation.  All rights reserved.\n+ * Copyright (c) 1996-1999 by Silicon Graphics.  All rights reserved.\n+ * Copyright (c) 1999 by Hewlett-Packard Company. All rights reserved.\n+ *\n  *\n  * THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED\n  * OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.\n@@ -42,7 +45,7 @@ typedef GC_word word;\n typedef GC_signed_word signed_word;\n \n # ifndef CONFIG_H\n-#   include \"config.h\"\n+#   include \"gcconfig.h\"\n # endif\n \n # ifndef HEADERS_H\n@@ -64,16 +67,16 @@ typedef char * ptr_t;\t/* A generic pointer to which we can add\t*/\n #       include <stddef.h>\n #   endif\n #   define VOLATILE volatile\n-#   define CONST const\n #else\n #   ifdef MSWIN32\n #   \tinclude <stdlib.h>\n #   endif\n #   define VOLATILE\n-#   define CONST\n #endif\n \n-#ifdef AMIGA\n+#define CONST GC_CONST\n+\n+#if 0 /* was once defined for AMIGA */\n #   define GC_FAR __far\n #else\n #   define GC_FAR\n@@ -336,6 +339,9 @@ void GC_print_callers (/* struct callinfo info[NFRAMES] */);\n /* space is assumed to be cleared.\t\t\t\t*/\n /* In the case os USE_MMAP, the argument must also be a \t*/\n /* physical page size.\t\t\t\t\t\t*/\n+/* GET_MEM is currently not assumed to retrieve 0 filled space, */\n+/* though we should perhaps take advantage of the case in which */\n+/* does.\t\t\t\t\t\t\t*/\n # ifdef PCR\n     char * real_malloc();\n #   define GET_MEM(bytes) HBLKPTR(real_malloc((size_t)bytes + GC_page_size) \\\n@@ -347,7 +353,7 @@ void GC_print_callers (/* struct callinfo info[NFRAMES] */);\n \t\t\t\t    + GC_page_size) \\\n                                     + GC_page_size-1)\n #   else\n-#     if defined(AMIGA) || defined(NEXT) || defined(DOS4GW)\n+#     if defined(AMIGA) || defined(NEXT) || defined(MACOSX) || defined(DOS4GW)\n #       define GET_MEM(bytes) HBLKPTR((size_t) \\\n \t\t\t\t      calloc(1, (size_t)bytes + GC_page_size) \\\n                                       + GC_page_size-1)\n@@ -433,7 +439,7 @@ void GC_print_callers (/* struct callinfo info[NFRAMES] */);\n #  endif\n #  ifdef LINUX_THREADS\n #    include <pthread.h>\n-#    ifdef __i386__\n+#    if defined(I386)\n        inline static int GC_test_and_set(volatile unsigned int *addr) {\n \t  int oldval;\n \t  /* Note: the \"xchg\" instruction does not need a \"lock\" prefix */\n@@ -442,55 +448,58 @@ void GC_print_callers (/* struct callinfo info[NFRAMES] */);\n \t\t: \"0\"(1), \"m\"(*(addr)));\n \t  return oldval;\n        }\n-       inline static void GC_clear(volatile unsigned int *addr) {\n-          *(addr) = 0;\n-       }\n-#    elif defined(__alpha__)\n+#    else\n+#     if defined(POWERPC)\n        inline static int GC_test_and_set(volatile unsigned int *addr) {\n-        long oldval, temp;\n+        int oldval;\n+        int temp = 1; // locked value\n \n         __asm__ __volatile__(\n-              \"1:\\tldl_l %0,%3\\n\"\n-              \"\\tbne %0,2f\\n\"\n-              \"\\tor $31,1,%1\\n\"\n-              \"\\tstl_c %1,%2\\n\"\n-              \"\\tbeq %1,1b\\n\"\n-              \"2:\\tmb\\n\"\n-              : \"=&r\"(oldval), \"=&r\"(temp), \"=m\"(*(addr))\n-              : \"m\"(*(addr))\n+               \"1:\\tlwarx %0,0,%3\\n\"   // load and reserve\n+               \"\\tcmpwi %0, 0\\n\"       // if load is\n+               \"\\tbne 2f\\n\"            //   non-zero, return already set\n+               \"\\tstwcx. %2,0,%1\\n\"    // else store conditional\n+               \"\\tbne- 1b\\n\"           // retry if lost reservation\n+               \"2:\\t\\n\"                // oldval is zero if we set\n+              : \"=&r\"(oldval), \"=p\"(addr)\n+              : \"r\"(temp), \"1\"(addr)\n               : \"memory\");\n         return (int)oldval;\n        }\n-       inline static void GC_clear(volatile unsigned int *addr) {\n-          __asm__ __volatile__(\"mb\": : :\"memory\");\n-          *(addr) = 0;\n-       }\n-#    elif defined(__powerpc__)\n-       inline static int GC_test_and_set(volatile unsigned int *addr) {\n-\t int ret, oldval=0, newval=1;\n-  \n-\t __asm__ __volatile__(\"sync\" : : : \"memory\");\n-\t __asm__ __volatile__(\n-\t\t\t      \"0:    lwarx %0,0,%1 ;\"\n-\t\t\t      \"      xor. %0,%3,%0;\"\n-\t\t\t      \"      bne 1f;\"\n-\t\t\t      \"      stwcx. %2,0,%1;\"\n-\t\t\t      \"      bne- 0b;\"\n-\t\t\t      \"1:    \"\n-\t\t\t      : \"=&r\"(ret)\n-\t\t\t      : \"r\"(addr), \"r\"(newval), \"r\"(oldval)\n-\t\t\t      : \"cr0\", \"memory\");\n-\t __asm__ __volatile__(\"sync\" : : : \"memory\");\n-\t return ret == 0;\n-       }\n-       inline static void GC_clear(volatile unsigned int *addr) {\n-          __asm__ __volatile__(\"sync\": : :\"memory\");\n-          *(addr) = 0;\n-       }\n-\n-#    else\n-       -- > Need implementation of GC_test_and_set()\n+#     else\n+#      ifdef ALPHA\n+         inline static int GC_test_and_set(volatile unsigned int *\n+addr)\n+         {\n+           unsigned long oldvalue;\n+           unsigned long temp;\n+\n+           __asm__ __volatile__(\n+                                \"1:     ldl_l %0,%1\\n\"\n+                                \"       and %0,%3,%2\\n\"\n+                                \"       bne %2,2f\\n\"\n+                                \"       xor %0,%3,%0\\n\"\n+                                \"       stl_c %0,%1\\n\"\n+                                \"       beq %0,3f\\n\"\n+                                \"       mb\\n\"\n+                                \"2:\\n\"\n+                                \".section .text2,\\\"ax\\\"\\n\"\n+                                \"3:     br 1b\\n\"\n+                                \".previous\"\n+                                :\"=&r\" (temp), \"=m\" (*addr), \"=&r\"\n+(oldvalue)\n+                                :\"Ir\" (1), \"m\" (*addr));\n+\n+           return oldvalue;\n+         }\n+#      else\n+         -- > Need implementation of GC_test_and_set()\n+#      endif\n+#     endif\n #    endif\n+     inline static void GC_clear(volatile unsigned int *addr) {\n+          *(addr) = 0;\n+     }\n \n      extern volatile unsigned int GC_allocate_lock;\n \t/* This is not a mutex because mutexes that obey the (optional)     */\n@@ -504,31 +513,41 @@ void GC_print_callers (/* struct callinfo info[NFRAMES] */);\n #    define NO_THREAD (pthread_t)(-1)\n #    define UNSET_LOCK_HOLDER() GC_lock_holder = NO_THREAD\n #    define I_HOLD_LOCK() (pthread_equal(GC_lock_holder, pthread_self()))\n-#    ifdef UNDEFINED\n-#    \tdefine LOCK() pthread_mutex_lock(&GC_allocate_ml)\n-#    \tdefine UNLOCK() pthread_mutex_unlock(&GC_allocate_ml)\n-#    else\n-#\tdefine LOCK() \\\n+#    define LOCK() \\\n \t\t{ if (GC_test_and_set(&GC_allocate_lock)) GC_lock(); }\n-#\tdefine UNLOCK() \\\n+#    define UNLOCK() \\\n \t\tGC_clear(&GC_allocate_lock)\n-#    endif\n      extern GC_bool GC_collecting;\n #    define ENTER_GC() \\\n \t\t{ \\\n \t\t    GC_collecting = 1; \\\n \t\t}\n #    define EXIT_GC() GC_collecting = 0;\n #  endif /* LINUX_THREADS */\n-#  if defined(IRIX_THREADS) || defined(IRIX_JDK_THREADS)\n+#  if defined(HPUX_THREADS)\n+#    include <pthread.h>\n+     extern pthread_mutex_t GC_allocate_ml;\n+#    define LOCK() pthread_mutex_lock(&GC_allocate_ml)\n+#    define UNLOCK() pthread_mutex_unlock(&GC_allocate_ml)\n+#  endif\n+#  if defined(IRIX_THREADS) || defined(IRIX_JDK_THREADS) \n+     /* This may also eventually be appropriate for HPUX_THREADS */\n #    include <pthread.h>\n-#    include <mutex.h>\n+#    ifndef HPUX_THREADS\n+\t/* This probably should never be included, but I can't test\t*/\n+\t/* on Irix anymore.\t\t\t\t\t\t*/\n+#       include <mutex.h>\n+#    endif\n \n-#    if __mips < 3 || !(defined (_ABIN32) || defined(_ABI64)) \\\n+#    ifndef HPUX_THREADS\n+#      if __mips < 3 || !(defined (_ABIN32) || defined(_ABI64)) \\\n \t|| !defined(_COMPILER_VERSION) || _COMPILER_VERSION < 700\n #        define GC_test_and_set(addr, v) test_and_set(addr,v)\n-#    else\n+#      else\n #\t define GC_test_and_set(addr, v) __test_and_set(addr,v)\n+#      endif\n+#    else\n+       /* I couldn't find a way to do this inline on HP/UX\t*/\n #    endif\n      extern unsigned long GC_allocate_lock;\n \t/* This is not a mutex because mutexes that obey the (optional) \t*/\n@@ -542,23 +561,25 @@ void GC_print_callers (/* struct callinfo info[NFRAMES] */);\n #    define NO_THREAD (pthread_t)(-1)\n #    define UNSET_LOCK_HOLDER() GC_lock_holder = NO_THREAD\n #    define I_HOLD_LOCK() (pthread_equal(GC_lock_holder, pthread_self()))\n-#    ifdef UNDEFINED\n-#    \tdefine LOCK() pthread_mutex_lock(&GC_allocate_ml)\n-#    \tdefine UNLOCK() pthread_mutex_unlock(&GC_allocate_ml)\n+#    ifdef HPUX_THREADS\n+#      define LOCK() { if (!GC_test_and_clear(&GC_allocate_lock)) GC_lock(); }\n+       /* The following is INCORRECT, since the memory model is too weak. */\n+#      define UNLOCK() { GC_noop1(&GC_allocate_lock); \\\n+\t\t\t*(volatile unsigned long *)(&GC_allocate_lock) = 1; }\n #    else\n-#\tdefine LOCK() { if (GC_test_and_set(&GC_allocate_lock, 1)) GC_lock(); }\n-#       if __mips >= 3 && (defined (_ABIN32) || defined(_ABI64)) \\\n+#      define LOCK() { if (GC_test_and_set(&GC_allocate_lock, 1)) GC_lock(); }\n+#      if __mips >= 3 && (defined (_ABIN32) || defined(_ABI64)) \\\n \t   && defined(_COMPILER_VERSION) && _COMPILER_VERSION >= 700\n #\t    define UNLOCK() __lock_release(&GC_allocate_lock)\n-#\telse\n+#      else\n \t    /* The function call in the following should prevent the\t*/\n \t    /* compiler from moving assignments to below the UNLOCK.\t*/\n \t    /* This is probably not necessary for ucode or gcc 2.8.\t*/\n \t    /* It may be necessary for Ragnarok and future gcc\t\t*/\n \t    /* versions.\t\t\t\t\t\t*/\n #           define UNLOCK() { GC_noop1(&GC_allocate_lock); \\\n \t\t\t*(volatile unsigned long *)(&GC_allocate_lock) = 0; }\n-#\tendif\n+#      endif\n #    endif\n      extern GC_bool GC_collecting;\n #    define ENTER_GC() \\\n@@ -653,7 +674,7 @@ void GC_print_callers (/* struct callinfo info[NFRAMES] */);\n # else\n #   if defined(SOLARIS_THREADS) || defined(WIN32_THREADS) \\\n \t|| defined(IRIX_THREADS) || defined(LINUX_THREADS) \\\n-\t|| defined(IRIX_JDK_THREADS)\n+\t|| defined(IRIX_JDK_THREADS) || defined(HPUX_THREADS)\n       void GC_stop_world();\n       void GC_start_world();\n #     define STOP_WORLD() GC_stop_world()\n@@ -869,6 +890,7 @@ struct hblkhdr {\n     struct hblk * hb_next; \t/* Link field for hblk free list\t */\n     \t\t\t\t/* and for lists of chunks waiting to be */\n     \t\t\t\t/* reclaimed.\t\t\t\t */\n+    struct hblk * hb_prev;\t/* Backwards link for free list.\t*/\n     word hb_descr;   \t\t/* object descriptor for marking.  See\t*/\n     \t\t\t\t/* mark.h.\t\t\t\t*/\n     char* hb_map;\t/* A pointer to a pointer validity map of the block. */\n@@ -883,14 +905,28 @@ struct hblkhdr {\n #\tdefine IGNORE_OFF_PAGE\t1\t/* Ignore pointers that do not\t*/\n \t\t\t\t\t/* point to the first page of \t*/\n \t\t\t\t\t/* this object.\t\t\t*/\n+#\tdefine WAS_UNMAPPED 2\t/* This is a free block, which has\t*/\n+\t\t\t\t/* been unmapped from the address \t*/\n+\t\t\t\t/* space.\t\t\t\t*/\n+\t\t\t\t/* GC_remap must be invoked on it\t*/\n+\t\t\t\t/* before it can be reallocated.\t*/\n+\t\t\t\t/* Only set with USE_MUNMAP.\t\t*/\n     unsigned short hb_last_reclaimed;\n     \t\t\t\t/* Value of GC_gc_no when block was\t*/\n     \t\t\t\t/* last allocated or swept. May wrap.   */\n+\t\t\t\t/* For a free block, this is maintained */\n+\t\t\t\t/* unly for USE_MUNMAP, and indicates\t*/\n+\t\t\t\t/* when the header was allocated, or\t*/\n+\t\t\t\t/* when the size of the block last\t*/\n+\t\t\t\t/* changed.\t\t\t\t*/\n     word hb_marks[MARK_BITS_SZ];\n \t\t\t    /* Bit i in the array refers to the             */\n \t\t\t    /* object starting at the ith word (header      */\n \t\t\t    /* INCLUDED) in the heap block.                 */\n \t\t\t    /* The lsb of word 0 is numbered 0.\t\t    */\n+\t\t\t    /* Unused bits are invalid, and are \t    */\n+\t\t\t    /* occasionally set, e.g for uncollectable\t    */\n+\t\t\t    /* objects.\t\t\t\t\t    */\n };\n \n /*  heap block body */\n@@ -922,7 +958,69 @@ struct hblk {\n /* Object free list link */\n # define obj_link(p) (*(ptr_t *)(p))\n \n-/*  lists of all heap blocks and free lists\t*/\n+/* The type of mark procedures.  This really belongs in gc_mark.h.\t*/\n+/* But we put it here, so that we can avoid scanning the mark proc\t*/\n+/* table.\t\t\t\t\t\t\t\t*/\n+typedef struct ms_entry * (*mark_proc)(/* word * addr, mark_stack_ptr,\n+\t\t\t\t\t  mark_stack_limit, env */);\n+# define LOG_MAX_MARK_PROCS 6\n+# define MAX_MARK_PROCS (1 << LOG_MAX_MARK_PROCS)\n+\n+/* Root sets.  Logically private to mark_rts.c.  But we don't want the\t*/\n+/* tables scanned, so we put them here.\t\t\t\t\t*/\n+/* MAX_ROOT_SETS is the maximum number of ranges that can be \t*/\n+/* registered as static roots. \t\t\t\t\t*/\n+# ifdef LARGE_CONFIG\n+#   define MAX_ROOT_SETS 4096\n+# else\n+#   ifdef PCR\n+#     define MAX_ROOT_SETS 1024\n+#   else\n+#     ifdef MSWIN32\n+#\tdefine MAX_ROOT_SETS 512\n+\t    /* Under NT, we add only written pages, which can result \t*/\n+\t    /* in many small root sets.\t\t\t\t\t*/\n+#     else\n+#       define MAX_ROOT_SETS 64\n+#     endif\n+#   endif\n+# endif\n+\n+# define MAX_EXCLUSIONS (MAX_ROOT_SETS/4)\n+/* Maximum number of segments that can be excluded from root sets.\t*/\n+\n+/*\n+ * Data structure for excluded static roots.\n+ */\n+struct exclusion {\n+    ptr_t e_start;\n+    ptr_t e_end;\n+};\n+\n+/* Data structure for list of root sets.\t\t\t\t*/\n+/* We keep a hash table, so that we can filter out duplicate additions.\t*/\n+/* Under Win32, we need to do a better job of filtering overlaps, so\t*/\n+/* we resort to sequential search, and pay the price.\t\t\t*/\n+struct roots {\n+\tptr_t r_start;\n+\tptr_t r_end;\n+#\tifndef MSWIN32\n+\t  struct roots * r_next;\n+#\tendif\n+\tGC_bool r_tmp;\n+\t  \t/* Delete before registering new dynamic libraries */\n+};\n+\n+#ifndef MSWIN32\n+    /* Size of hash table index to roots.\t*/\n+#   define LOG_RT_SIZE 6\n+#   define RT_SIZE (1 << LOG_RT_SIZE) /* Power of 2, may be != MAX_ROOT_SETS */\n+#endif\n+\n+/* Lists of all heap blocks and free lists\t*/\n+/* as well as other random data structures\t*/\n+/* that should not be scanned by the\t\t*/\n+/* collector.\t\t\t\t\t*/\n /* These are grouped together in a struct\t*/\n /* so that they can be easily skipped by the\t*/\n /* GC_mark routine.\t\t\t\t*/\n@@ -943,6 +1041,9 @@ struct _GC_arrays {\n   word _max_heapsize;\n   ptr_t _last_heap_addr;\n   ptr_t _prev_heap_addr;\n+  word _large_free_bytes;\n+\t/* Total bytes contained in blocks on large object free */\n+\t/* list.\t\t\t\t\t\t*/\n   word _words_allocd_before_gc;\n \t\t/* Number of words allocated before this\t*/\n \t\t/* collection cycle.\t\t\t\t*/\n@@ -962,7 +1063,10 @@ struct _GC_arrays {\n   word _mem_freed;\n   \t/* Number of explicitly deallocated words of memory\t*/\n   \t/* since last collection.\t\t\t\t*/\n-  \t\n+  mark_proc _mark_procs[MAX_MARK_PROCS];\n+  \t/* Table of user-defined mark procedures.  There is\t*/\n+\t/* a small number of these, which can be referenced\t*/\n+\t/* by DS_PROC mark descriptors.  See gc_mark.h.\t\t*/\n   ptr_t _objfreelist[MAXOBJSZ+1];\n \t\t\t  /* free list for objects */\n   ptr_t _aobjfreelist[MAXOBJSZ+1];\n@@ -986,6 +1090,9 @@ struct _GC_arrays {\n    \t\t/* Number of words in accessible atomic\t\t*/\n \t\t/* objects.\t\t\t\t\t*/\n # endif\n+# ifdef USE_MUNMAP\n+    word _unmapped_bytes;\n+# endif\n # ifdef MERGE_SIZES\n     unsigned _size_map[WORDS_TO_BYTES(MAXOBJSZ+1)];\n     \t/* Number of words to allocate for a given allocation request in */\n@@ -1003,7 +1110,7 @@ struct _GC_arrays {\n     \t\t       /* to an object at\t\t\t\t*/\n     \t\t       /* block_start+i&~3 - WORDS_TO_BYTES(j).\t\t*/\n     \t\t       /* (If ALL_INTERIOR_POINTERS is defined, then\t*/\n-    \t\t       /* instead ((short *)(hbh_map[sz])[i] is j if\t*/\n+    \t\t       /* instead ((short *)(hb_map[sz])[i] is j if\t*/\n     \t\t       /* block_start+WORDS_TO_BYTES(i) is in the\t*/\n     \t\t       /* interior of an object starting at\t\t*/\n     \t\t       /* block_start+WORDS_TO_BYTES(i-j)).\t\t*/\n@@ -1044,17 +1151,24 @@ struct _GC_arrays {\n \t\t\t\t/* GC_modws_valid_offsets[i%sizeof(word)] */\n #   endif\n # ifdef STUBBORN_ALLOC\n-      page_hash_table _changed_pages;\n+    page_hash_table _changed_pages;\n         /* Stubborn object pages that were changes since last call to\t*/\n \t/* GC_read_changed.\t\t\t\t\t\t*/\n-      page_hash_table _prev_changed_pages;\n+    page_hash_table _prev_changed_pages;\n         /* Stubborn object pages that were changes before last call to\t*/\n \t/* GC_read_changed.\t\t\t\t\t\t*/\n # endif\n # if defined(PROC_VDB) || defined(MPROTECT_VDB)\n-      page_hash_table _grungy_pages; /* Pages that were dirty at last \t   */\n+    page_hash_table _grungy_pages; /* Pages that were dirty at last \t   */\n \t\t\t\t     /* GC_read_dirty.\t\t\t   */\n # endif\n+# ifdef MPROTECT_VDB\n+    VOLATILE page_hash_table _dirty_pages;\t\n+\t\t\t/* Pages dirtied since last GC_read_dirty. */\n+# endif\n+# ifdef PROC_VDB\n+    page_hash_table _written_pages;\t/* Pages ever dirtied\t*/\n+# endif\n # ifdef LARGE_CONFIG\n #   if CPP_WORDSZ > 32\n #     define MAX_HEAP_SECTS 4096 \t/* overflows at roughly 64 GB\t   */\n@@ -1071,6 +1185,11 @@ struct _GC_arrays {\n     ptr_t _heap_bases[MAX_HEAP_SECTS];\n     \t\t/* Start address of memory regions obtained from kernel. */\n # endif\n+  struct roots _static_roots[MAX_ROOT_SETS];\n+# ifndef MSWIN32\n+    struct roots * _root_index[RT_SIZE];\n+# endif\n+  struct exclusion _excl_table[MAX_EXCLUSIONS];\n   /* Block header index; see gc_headers.h */\n   bottom_index * _all_nils;\n   bottom_index * _top_index [TOP_SZ];\n@@ -1104,22 +1223,36 @@ GC_API GC_FAR struct _GC_arrays GC_arrays;\n # define GC_prev_heap_addr GC_arrays._prev_heap_addr\n # define GC_words_allocd GC_arrays._words_allocd\n # define GC_words_wasted GC_arrays._words_wasted\n+# define GC_large_free_bytes GC_arrays._large_free_bytes\n # define GC_words_finalized GC_arrays._words_finalized\n # define GC_non_gc_bytes_at_gc GC_arrays._non_gc_bytes_at_gc\n # define GC_mem_freed GC_arrays._mem_freed\n+# define GC_mark_procs GC_arrays._mark_procs\n # define GC_heapsize GC_arrays._heapsize\n # define GC_max_heapsize GC_arrays._max_heapsize\n # define GC_words_allocd_before_gc GC_arrays._words_allocd_before_gc\n # define GC_heap_sects GC_arrays._heap_sects\n # define GC_last_stack GC_arrays._last_stack\n+# ifdef USE_MUNMAP\n+#   define GC_unmapped_bytes GC_arrays._unmapped_bytes\n+# endif\n # ifdef MSWIN32\n #   define GC_heap_bases GC_arrays._heap_bases\n # endif\n+# define GC_static_roots GC_arrays._static_roots\n+# define GC_root_index GC_arrays._root_index\n+# define GC_excl_table GC_arrays._excl_table\n # define GC_all_nils GC_arrays._all_nils\n # define GC_top_index GC_arrays._top_index\n # if defined(PROC_VDB) || defined(MPROTECT_VDB)\n #   define GC_grungy_pages GC_arrays._grungy_pages\n # endif\n+# ifdef MPROTECT_VDB\n+#   define GC_dirty_pages GC_arrays._dirty_pages\n+# endif\n+# ifdef PROC_VDB\n+#   define GC_written_pages GC_arrays._written_pages\n+# endif\n # ifdef GATHERSTATS\n #   define GC_composite_in_use GC_arrays._composite_in_use\n #   define GC_atomic_in_use GC_arrays._atomic_in_use\n@@ -1131,11 +1264,9 @@ GC_API GC_FAR struct _GC_arrays GC_arrays;\n # define beginGC_arrays ((ptr_t)(&GC_arrays))\n # define endGC_arrays (((ptr_t)(&GC_arrays)) + (sizeof GC_arrays))\n \n-GC_API word GC_fo_entries;\n-\n+/* Object kinds: */\n # define MAXOBJKINDS 16\n \n-/* Object kinds: */\n extern struct obj_kind {\n    ptr_t *ok_freelist;\t/* Array of free listheaders for this kind of object */\n    \t\t\t/* Point either to GC_arrays or to storage allocated */\n@@ -1149,8 +1280,14 @@ extern struct obj_kind {\n    \t\t\t/* Add object size in bytes to descriptor \t*/\n    \t\t\t/* template to obtain descriptor.  Otherwise\t*/\n    \t\t\t/* template is used as is.\t\t\t*/\n-   GC_bool ok_init;     /* Clear objects before putting them on the free list. */\n+   GC_bool ok_init;   /* Clear objects before putting them on the free list. */\n } GC_obj_kinds[MAXOBJKINDS];\n+\n+# define endGC_obj_kinds (((ptr_t)(&GC_obj_kinds)) + (sizeof GC_obj_kinds))\n+\n+# define end_gc_area ((ptr_t)endGC_arrays == (ptr_t)(&GC_obj_kinds) ? \\\n+\t\t\tendGC_obj_kinds : endGC_arrays)\n+\n /* Predefined kinds: */\n # define PTRFREE 0\n # define NORMAL  1\n@@ -1166,6 +1303,8 @@ extern struct obj_kind {\n \n extern int GC_n_kinds;\n \n+GC_API word GC_fo_entries;\n+\n extern word GC_n_heap_sects;\t/* Number of separately added heap\t*/\n \t\t\t\t/* sections.\t\t\t\t*/\n \n@@ -1189,7 +1328,7 @@ extern char * GC_invalid_map;\n \t\t\t/* Pointer to the nowhere valid hblk map */\n \t\t\t/* Blocks pointing to this map are free. */\n \n-extern struct hblk * GC_hblkfreelist;\n+extern struct hblk * GC_hblkfreelist[];\n \t\t\t\t/* List of completely empty heap blocks\t*/\n \t\t\t\t/* Linked through hb_next field of \t*/\n \t\t\t\t/* header structure associated with\t*/\n@@ -1200,17 +1339,19 @@ extern GC_bool GC_is_initialized;\t/* GC_init() has been run.\t*/\n extern GC_bool GC_objects_are_marked;\t/* There are marked objects in  */\n \t\t\t\t\t/* the heap.\t\t\t*/\n \n-extern GC_bool GC_incremental; /* Using incremental/generational collection. */\n+#ifndef SMALL_CONFIG\n+  extern GC_bool GC_incremental;\n+\t\t\t/* Using incremental/generational collection. */\n+#else\n+# define GC_incremental TRUE\n+\t\t\t/* Hopefully allow optimizer to remove some code. */\n+#endif\n \n extern GC_bool GC_dirty_maintained;\n \t\t\t\t/* Dirty bits are being maintained, \t*/\n \t\t\t\t/* either for incremental collection,\t*/\n \t\t\t\t/* or to limit the root set.\t\t*/\n \n-# ifndef PCR\n-    extern ptr_t GC_stackbottom;\t/* Cool end of user stack\t*/\n-# endif\n-\n extern word GC_root_size;\t/* Total size of registered root sections */\n \n extern GC_bool GC_debugging_started;\t/* GC_debug_malloc has been called. */ \n@@ -1262,7 +1403,12 @@ GC_bool GC_should_collect();\n void GC_apply_to_all_blocks(/*fn, client_data*/);\n \t\t\t/* Invoke fn(hbp, client_data) for each \t*/\n \t\t\t/* allocated heap block.\t\t\t*/\n-struct hblk * GC_next_block(/* struct hblk * h */);\n+struct hblk * GC_next_used_block(/* struct hblk * h */);\n+\t\t\t/* Return first in-use block >= h\t*/\n+struct hblk * GC_prev_block(/* struct hblk * h */);\n+\t\t\t/* Return last block <= h.  Returned block\t*/\n+\t\t\t/* is managed by GC, but may or may not be in\t*/\n+\t\t\t/* use.\t\t\t\t\t\t*/\n void GC_mark_init();\n void GC_clear_marks();\t/* Clear mark bits for all heap objects. */\n void GC_invalidate_mark_state();\t/* Tell the marker that\tmarked \t   */\n@@ -1274,7 +1420,8 @@ void GC_mark_from_mark_stack(); /* Mark from everything on the mark stack. */\n \t\t\t\t/* Return after about one pages worth of   */\n \t\t\t\t/* work.\t\t\t\t   */\n GC_bool GC_mark_stack_empty();\n-GC_bool GC_mark_some();\t/* Perform about one pages worth of marking\t*/\n+GC_bool GC_mark_some(/* cold_gc_frame */);\n+\t\t\t/* Perform about one pages worth of marking\t*/\n \t\t\t/* work of whatever kind is needed.  Returns\t*/\n \t\t\t/* quickly if no collection is in progress.\t*/\n \t\t\t/* Return TRUE if mark phase finished.\t\t*/\n@@ -1296,7 +1443,31 @@ void GC_push_dirty(/*b,t*/);      /* Push all possibly changed\t \t*/\n \t\t\t\t/* on the third arg.\t\t\t*/\n void GC_push_all_stack(/*b,t*/);    /* As above, but consider\t\t*/\n \t\t\t\t    /*  interior pointers as valid  \t*/\n-void GC_push_roots(/* GC_bool all */); /* Push all or dirty roots.\t*/\n+void GC_push_all_eager(/*b,t*/);    /* Same as GC_push_all_stack, but   */\n+\t\t\t\t    /* ensures that stack is scanned\t*/\n+\t\t\t\t    /* immediately, not just scheduled  */\n+\t\t\t\t    /* for scanning.\t\t\t*/\n+#ifndef THREADS\n+  void GC_push_all_stack_partially_eager(/* bottom, top, cold_gc_frame */);\n+\t\t\t/* Similar to GC_push_all_eager, but only the\t*/\n+\t\t\t/* part hotter than cold_gc_frame is scanned\t*/\n+\t\t\t/* immediately.  Needed to endure that callee-\t*/\n+\t\t\t/* save registers are not missed.\t\t*/\n+#else\n+  /* In the threads case, we push part of the current thread stack\t*/\n+  /* with GC_push_all_eager when we push the registers.  This gets the  */\n+  /* callee-save registers that may disappear.  The remainder of the\t*/\n+  /* stacks are scheduled for scanning in *GC_push_other_roots, which\t*/\n+  /* is thread-package-specific.\t\t\t\t\t*/\n+#endif\n+void GC_push_current_stack(/* ptr_t cold_gc_frame */);\n+\t\t\t/* Push enough of the current stack eagerly to\t*/\n+\t\t\t/* ensure that callee-save registers saved in\t*/\n+\t\t\t/* GC frames are scanned.\t\t\t*/\n+\t\t\t/* In the non-threads case, schedule entire\t*/\n+\t\t\t/* stack for scanning.\t\t\t\t*/\n+void GC_push_roots(/* GC_bool all, ptr_t cold_gc_frame */);\n+\t\t\t/* Push all or dirty roots.\t*/\n extern void (*GC_push_other_roots)();\n \t\t\t/* Push system or application specific roots\t*/\n \t\t\t/* onto the mark stack.  In some environments\t*/\n@@ -1310,8 +1481,14 @@ extern void (*GC_start_call_back)(/* void */);\n \t\t\t/* lock held.\t\t\t\t\t*/\n \t\t\t/* 0 by default.\t\t\t\t*/\n void GC_push_regs();\t/* Push register contents onto mark stack.\t*/\n+\t\t\t/* If NURSERY is defined, the default push\t*/\n+\t\t\t/* action can be overridden with GC_push_proc\t*/\n void GC_remark();\t/* Mark from all marked objects.  Used\t*/\n \t\t \t/* only if we had to drop something.\t*/\n+\n+# ifdef NURSERY\n+    extern void (*GC_push_proc)(ptr_t);\n+# endif\n # if defined(MSWIN32)\n   void __cdecl GC_push_one();\n # else\n@@ -1461,7 +1638,7 @@ GC_bool GC_collect_or_expand(/* needed_blocks */);\n \t\t\t\t/* blocks available.  Should be called\t*/\n \t\t\t\t/* until the blocks are available or\t*/\n \t\t\t\t/* until it fails by returning FALSE.\t*/\n-void GC_init();\t\t\t/* Initialize collector.\t\t*/\n+GC_API void GC_init();\t\t/* Initialize collector.\t\t*/\n void GC_collect_a_little_inner(/* int n */);\n \t\t\t\t/* Do n units worth of garbage \t\t*/\n \t\t\t\t/* collection work, if appropriate.\t*/\n@@ -1538,6 +1715,15 @@ extern void (*GC_print_heap_obj)(/* ptr_t p */);\n \t\t\t/* detailed description of the object \t\t*/\n \t\t\t/* referred to by p.\t\t\t\t*/\n \t\t\t\n+/* Memory unmapping: */\n+#ifdef USE_MUNMAP\n+  void GC_unmap_old(void);\n+  void GC_merge_unmapped(void);\n+  void GC_unmap(ptr_t start, word bytes);\n+  void GC_remap(ptr_t start, word bytes);\n+  void GC_unmap_gap(ptr_t start1, word bytes1, ptr_t start2, word bytes2);\n+#endif\n+\n /* Virtual dirty bit implementation:\t\t*/\n /* Each implementation exports the following:\t*/\n void GC_read_dirty();\t/* Retrieve dirty bits.\t*/\n@@ -1553,7 +1739,7 @@ void GC_write_hint(/* struct hblk * h  */);\n void GC_dirty_init();\n \n /* Slow/general mark bit manipulation: */\n-GC_bool GC_is_marked();\n+GC_API GC_bool GC_is_marked();\n void GC_clear_mark_bit();\n void GC_set_mark_bit();\n \n@@ -1570,6 +1756,16 @@ void GC_print_heap_sects();\n void GC_print_static_roots();\n void GC_dump();\n \n+#ifdef KEEP_BACK_PTRS\n+   void GC_store_back_pointer(ptr_t source, ptr_t dest);\n+   void GC_marked_for_finalization(ptr_t dest);\n+#  define GC_STORE_BACK_PTR(source, dest) GC_store_back_pointer(source, dest)\n+#  define GC_MARKED_FOR_FINALIZATION(dest) GC_marked_for_finalization(dest)\n+#else\n+#  define GC_STORE_BACK_PTR(source, dest) \n+#  define GC_MARKED_FOR_FINALIZATION(dest)\n+#endif\n+\n /* Make arguments appear live to compiler */\n # ifdef __WATCOMC__\n   void GC_noop(void*, ...);\n@@ -1620,4 +1816,13 @@ void GC_err_puts(/* char *s */);\n \t\t\t/* newlines, don't ...\t\t\t\t*/\n \n \n+#   ifdef GC_ASSERTIONS\n+#\tdefine GC_ASSERT(expr) if(!(expr)) {\\\n+\t\tGC_err_printf2(\"Assertion failure: %s:%ld\\n\", \\\n+\t\t\t\t__FILE__, (unsigned long)__LINE__); \\\n+\t\tABORT(\"assertion failure\"); }\n+#   else \n+#\tdefine GC_ASSERT(expr)\n+#   endif\n+\n # endif /* GC_PRIVATE_H */"}, {"sha": "9564a6a53590ecacb33099d4deca22c4532d7770", "filename": "boehm-gc/headers.c", "status": "modified", "additions": 73, "deletions": 18, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20bbd3cd53a80ddafa56a5d21337aae0c24f94ca/boehm-gc%2Fheaders.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20bbd3cd53a80ddafa56a5d21337aae0c24f94ca/boehm-gc%2Fheaders.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fheaders.c?ref=20bbd3cd53a80ddafa56a5d21337aae0c24f94ca", "patch": "@@ -25,6 +25,12 @@\n # include \"gc_priv.h\"\n \n bottom_index * GC_all_bottom_indices = 0;\n+\t\t\t\t/* Pointer to first (lowest addr) */\n+\t\t\t\t/* bottom_index.\t\t  */\n+\n+bottom_index * GC_all_bottom_indices_end = 0;\n+\t\t\t\t/* Pointer to last (highest addr) */\n+\t\t\t\t/* bottom_index.\t\t  */\n  \n /* Non-macro version of header location routine */\n hdr * GC_find_header(h)\n@@ -53,7 +59,6 @@ ptr_t GC_scratch_alloc(bytes)\n register word bytes;\n {\n     register ptr_t result = scratch_free_ptr;\n-    register word bytes_needed = bytes;\n \n #   ifdef ALIGN_DOUBLE\n #\tdefine GRANULARITY (2 * sizeof(word))\n@@ -90,7 +95,7 @@ register word bytes;\n \t    bytes_to_get = bytes;\n #\t    ifdef USE_MMAP\n \t\tbytes_to_get += GC_page_size - 1;\n-\t\tbytes_to_get &= (GC_page_size - 1);\n+\t\tbytes_to_get &= ~(GC_page_size - 1);\n #\t    endif\n             return((ptr_t)GET_MEM(bytes_to_get));\n         }\n@@ -126,7 +131,7 @@ hdr * hhdr;\n  \n void GC_init_headers()\n {\n-    register int i;\n+    register unsigned i;\n     \n     GC_all_nils = (bottom_index *)GC_scratch_alloc((word)sizeof(bottom_index));\n     BZERO(GC_all_nils, sizeof(bottom_index));\n@@ -138,16 +143,17 @@ void GC_init_headers()\n /* Make sure that there is a bottom level index block for address addr  */\n /* Return FALSE on failure.\t\t\t\t\t\t*/\n static GC_bool get_index(addr)\n-register word addr;\n+word addr;\n {\n-    register word hi =\n-    \t\t(word)(addr) >> (LOG_BOTTOM_SZ + LOG_HBLKSIZE);\n-    register bottom_index * r;\n-    register bottom_index * p;\n-    register bottom_index ** prev;\n+    word hi = (word)(addr) >> (LOG_BOTTOM_SZ + LOG_HBLKSIZE);\n+    bottom_index * r;\n+    bottom_index * p;\n+    bottom_index ** prev;\n+    bottom_index *pi;\n+    \n #   ifdef HASH_TL\n-      register unsigned i = TL_HASH(hi);\n-      register bottom_index * old;\n+      unsigned i = TL_HASH(hi);\n+      bottom_index * old;\n       \n       old = p = GC_top_index[i];\n       while(p != GC_all_nils) {\n@@ -165,11 +171,21 @@ register word addr;\n       if (r == 0) return(FALSE);\n       GC_top_index[hi] = r;\n       BZERO(r, sizeof (bottom_index));\n-# endif\n+#   endif\n     r -> key = hi;\n     /* Add it to the list of bottom indices */\n-      prev = &GC_all_bottom_indices;\n-      while ((p = *prev) != 0 && p -> key < hi) prev = &(p -> asc_link);\n+      prev = &GC_all_bottom_indices;  \t/* pointer to p */\n+      pi = 0;\t\t\t\t/* bottom_index preceding p */\n+      while ((p = *prev) != 0 && p -> key < hi) {\n+\tpi = p;\n+\tprev = &(p -> asc_link);\n+      }\n+      r -> desc_link = pi;\n+      if (0 == p) {\n+\tGC_all_bottom_indices_end = r;\n+      } else {\n+\tp -> desc_link = r;\n+      }\n       r -> asc_link = p;\n       *prev = r;\n     return(TRUE);\n@@ -186,6 +202,9 @@ register struct hblk * h;\n     if (!get_index((word) h)) return(FALSE);\n     result = alloc_hdr();\n     SET_HDR(h, result);\n+#   ifdef USE_MUNMAP\n+\tresult -> hb_last_reclaimed = GC_gc_no;\n+#   endif\n     return(result != 0);\n }\n \n@@ -262,7 +281,7 @@ word client_data;\n \n /* Get the next valid block whose address is at least h\t*/\n /* Return 0 if there is none.\t\t\t\t*/\n-struct hblk * GC_next_block(h)\n+struct hblk * GC_next_used_block(h)\n struct hblk * h;\n {\n     register bottom_index * bi;\n@@ -277,15 +296,16 @@ struct hblk * h;\n     }\n     while(bi != 0) {\n         while (j < BOTTOM_SZ) {\n-            if (IS_FORWARDING_ADDR_OR_NIL(bi -> index[j])) {\n+\t    hdr * hhdr = bi -> index[j];\n+            if (IS_FORWARDING_ADDR_OR_NIL(hhdr)) {\n                 j++;\n             } else {\n-                if (bi->index[j]->hb_map != GC_invalid_map) {\n+                if (hhdr->hb_map != GC_invalid_map) {\n                     return((struct hblk *)\n                   \t      (((bi -> key << LOG_BOTTOM_SZ) + j)\n                   \t       << LOG_HBLKSIZE));\n                 } else {\n-                    j += divHBLKSZ(bi->index[j] -> hb_sz);\n+                    j += divHBLKSZ(hhdr -> hb_sz);\n                 }\n             }\n         }\n@@ -294,3 +314,38 @@ struct hblk * h;\n     }\n     return(0);\n }\n+\n+/* Get the last (highest address) block whose address is \t*/\n+/* at most h.  Return 0 if there is none.\t\t\t*/\n+/* Unlike the above, this may return a free block.\t\t*/\n+struct hblk * GC_prev_block(h)\n+struct hblk * h;\n+{\n+    register bottom_index * bi;\n+    register signed_word j = ((word)h >> LOG_HBLKSIZE) & (BOTTOM_SZ-1);\n+    \n+    GET_BI(h, bi);\n+    if (bi == GC_all_nils) {\n+        register word hi = (word)h >> (LOG_BOTTOM_SZ + LOG_HBLKSIZE);\n+        bi = GC_all_bottom_indices_end;\n+        while (bi != 0 && bi -> key > hi) bi = bi -> desc_link;\n+        j = BOTTOM_SZ - 1;\n+    }\n+    while(bi != 0) {\n+        while (j >= 0) {\n+\t    hdr * hhdr = bi -> index[j];\n+\t    if (0 == hhdr) {\n+\t\t--j;\n+            } else if (IS_FORWARDING_ADDR_OR_NIL(hhdr)) {\n+                j -= (signed_word)hhdr;\n+            } else {\n+                return((struct hblk *)\n+                          (((bi -> key << LOG_BOTTOM_SZ) + j)\n+                  \t       << LOG_HBLKSIZE));\n+            }\n+        }\n+        j = BOTTOM_SZ - 1;\n+        bi = bi -> desc_link;\n+    }\n+    return(0);\n+}"}, {"sha": "af013637bf2c611d6827659b5869b5d16d9e4c19", "filename": "boehm-gc/if_mach.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20bbd3cd53a80ddafa56a5d21337aae0c24f94ca/boehm-gc%2Fif_mach.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20bbd3cd53a80ddafa56a5d21337aae0c24f94ca/boehm-gc%2Fif_mach.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fif_mach.c?ref=20bbd3cd53a80ddafa56a5d21337aae0c24f94ca", "patch": "@@ -1,6 +1,6 @@\n-/* Conditionally execute a command based on machine and OS from config.h */\n-/* Boehm, November 21, 1994 1:40 pm PST */\n-# include \"config.h\"\n+/* Conditionally execute a command based on machine and OS from gcconfig.h */\n+\n+# include \"gcconfig.h\"\n # include <stdio.h>\n \n int main(argc, argv, envp)"}, {"sha": "a93795f1c785131352045a4f8ab0ea8591d11a77", "filename": "boehm-gc/if_not_there.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20bbd3cd53a80ddafa56a5d21337aae0c24f94ca/boehm-gc%2Fif_not_there.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20bbd3cd53a80ddafa56a5d21337aae0c24f94ca/boehm-gc%2Fif_not_there.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fif_not_there.c?ref=20bbd3cd53a80ddafa56a5d21337aae0c24f94ca", "patch": "@@ -1,6 +1,6 @@\n /* Conditionally execute a command based if the file argv[1] doesn't exist */\n /* Except for execvp, we stick to ANSI C.\t\t\t\t   */\n-# include \"config.h\"\n+# include \"gcconfig.h\"\n # include <stdio.h>\n \n int main(argc, argv, envp)"}, {"sha": "5efca2110343942b2adf44a736b25cb0af4067ae", "filename": "boehm-gc/irix_threads.c", "status": "modified", "additions": 50, "deletions": 16, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20bbd3cd53a80ddafa56a5d21337aae0c24f94ca/boehm-gc%2Firix_threads.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20bbd3cd53a80ddafa56a5d21337aae0c24f94ca/boehm-gc%2Firix_threads.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Firix_threads.c?ref=20bbd3cd53a80ddafa56a5d21337aae0c24f94ca", "patch": "@@ -25,6 +25,7 @@\n \n # include \"gc_priv.h\"\n # include <pthread.h>\n+# include <semaphore.h>\n # include <time.h>\n # include <errno.h>\n # include <unistd.h>\n@@ -411,6 +412,7 @@ void GC_thr_init()\n     GC_thread t;\n     struct sigaction act;\n \n+    if (GC_thr_initialized) return;\n     GC_thr_initialized = TRUE;\n     GC_min_stack_sz = HBLKSIZE;\n     GC_page_sz = sysconf(_SC_PAGESIZE);\n@@ -445,9 +447,14 @@ int GC_pthread_sigmask(int how, const sigset_t *set, sigset_t *oset)\n struct start_info {\n     void *(*start_routine)(void *);\n     void *arg;\n+    word flags;\n+    ptr_t stack;\n+    size_t stack_size;\n+    sem_t registered;   \t/* 1 ==> in our thread table, but \t*/\n+\t\t\t\t/* parent hasn't yet noticed.\t\t*/\n };\n \n-void GC_thread_exit_proc(void *dummy)\n+void GC_thread_exit_proc(void *arg)\n {\n     GC_thread me;\n \n@@ -472,6 +479,9 @@ int GC_pthread_join(pthread_t thread, void **retval)\n     /* cant have been recycled by pthreads.\t\t\t\t*/\n     UNLOCK();\n     result = pthread_join(thread, retval);\n+    /* Some versions of the Irix pthreads library can erroneously \t*/\n+    /* return EINTR when the call succeeds.\t\t\t\t*/\n+\tif (EINTR == result) result = 0;\n     LOCK();\n     /* Here the pthread thread id may have been recycled. */\n     GC_delete_gc_thread(thread, thread_gc_id);\n@@ -484,12 +494,34 @@ void * GC_start_routine(void * arg)\n     struct start_info * si = arg;\n     void * result;\n     GC_thread me;\n-\n+    pthread_t my_pthread;\n+    void *(*start)(void *);\n+    void *start_arg;\n+\n+    my_pthread = pthread_self();\n+    /* If a GC occurs before the thread is registered, that GC will\t*/\n+    /* ignore this thread.  That's fine, since it will block trying to  */\n+    /* acquire the allocation lock, and won't yet hold interesting \t*/\n+    /* pointers.\t\t\t\t\t\t\t*/\n     LOCK();\n-    me = GC_lookup_thread(pthread_self());\n+    /* We register the thread here instead of in the parent, so that\t*/\n+    /* we don't need to hold the allocation lock during pthread_create. */\n+    /* Holding the allocation lock there would make REDIRECT_MALLOC\t*/\n+    /* impossible.  It probably still doesn't work, but we're a little  */\n+    /* closer ...\t\t\t\t\t\t\t*/\n+    /* This unfortunately means that we have to be careful the parent\t*/\n+    /* doesn't try to do a pthread_join before we're registered.\t*/\n+    me = GC_new_thread(my_pthread);\n+    me -> flags = si -> flags;\n+    me -> stack = si -> stack;\n+    me -> stack_size = si -> stack_size;\n+    me -> stack_ptr = (ptr_t)si -> stack + si -> stack_size - sizeof(word);\n     UNLOCK();\n+    start = si -> start_routine;\n+    start_arg = si -> arg;\n+    sem_post(&(si -> registered));\n     pthread_cleanup_push(GC_thread_exit_proc, 0);\n-    result = (*(si -> start_routine))(si -> arg);\n+    result = (*start)(start_arg);\n     me -> status = result;\n     me -> flags |= FINISHED;\n     pthread_cleanup_pop(1);\n@@ -506,15 +538,17 @@ GC_pthread_create(pthread_t *new_thread,\n {\n     int result;\n     GC_thread t;\n-    pthread_t my_new_thread;\n     void * stack;\n     size_t stacksize;\n     pthread_attr_t new_attr;\n     int detachstate;\n     word my_flags = 0;\n     struct start_info * si = GC_malloc(sizeof(struct start_info)); \n+\t/* This is otherwise saved only in an area mmapped by the thread */\n+\t/* library, which isn't visible to the collector.\t\t */\n \n     if (0 == si) return(ENOMEM);\n+    sem_init(&(si -> registered), 0, 0);\n     si -> start_routine = start_routine;\n     si -> arg = arg;\n     LOCK();\n@@ -540,20 +574,20 @@ GC_pthread_create(pthread_t *new_thread,\n     \tmy_flags |= CLIENT_OWNS_STACK;\n     }\n     if (PTHREAD_CREATE_DETACHED == detachstate) my_flags |= DETACHED;\n-    result = pthread_create(&my_new_thread, &new_attr, GC_start_routine, si);\n-    /* No GC can start until the thread is registered, since we hold\t*/\n-    /* the allocation lock.\t\t\t\t\t\t*/\n-    if (0 == result) {\n-        t = GC_new_thread(my_new_thread);\n-        t -> flags = my_flags;\n-        t -> stack = stack;\n-        t -> stack_size = stacksize;\n-\tt -> stack_ptr = (ptr_t)stack + stacksize - sizeof(word);\n-        if (0 != new_thread) *new_thread = my_new_thread;\n-    } else if (!(my_flags & CLIENT_OWNS_STACK)) {\n+    si -> flags = my_flags;\n+    si -> stack = stack;\n+    si -> stack_size = stacksize;\n+    result = pthread_create(new_thread, &new_attr, GC_start_routine, si);\n+    if (0 == new_thread && !(my_flags & CLIENT_OWNS_STACK)) {\n       \tGC_stack_free(stack, stacksize);\n     }        \n     UNLOCK();  \n+    /* Wait until child has been added to the thread table.\t\t*/\n+    /* This also ensures that we hold onto si until the child is done\t*/\n+    /* with it.  Thus it doesn't matter whether it is otherwise\t\t*/\n+    /* visible to the collector.\t\t\t\t\t*/\n+        if (0 != sem_wait(&(si -> registered))) ABORT(\"sem_wait failed\");\n+        sem_destroy(&(si -> registered));\n     /* pthread_attr_destroy(&new_attr); */\n     return(result);\n }"}, {"sha": "8287dce647b1413250261ef06bbe4479a9446618", "filename": "boehm-gc/linux_threads.c", "status": "modified", "additions": 47, "deletions": 29, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20bbd3cd53a80ddafa56a5d21337aae0c24f94ca/boehm-gc%2Flinux_threads.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20bbd3cd53a80ddafa56a5d21337aae0c24f94ca/boehm-gc%2Flinux_threads.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Flinux_threads.c?ref=20bbd3cd53a80ddafa56a5d21337aae0c24f94ca", "patch": "@@ -28,9 +28,13 @@\n  * there too.\n  */\n \n-# if defined(LINUX_THREADS)\n+/* #define DEBUG_THREADS 1 */\n \n+/* ANSI C requires that a compilation unit contains something */\n # include \"gc_priv.h\"\n+\n+# if defined(LINUX_THREADS)\n+\n # include <pthread.h>\n # include <time.h>\n # include <errno.h>\n@@ -114,17 +118,12 @@ GC_linux_thread_top_of_stack() relies on implementation details of\n LinuxThreads, namely that thread stacks are allocated on 2M boundaries\n and grow to no more than 2M.\n To make sure that we're using LinuxThreads and not some other thread\n-package, we generate a dummy reference to `__pthread_initial_thread_bos',\n+package, we generate a dummy reference to `pthread_kill_other_threads_np'\n+(was `__pthread_initial_thread_bos' but that disappeared),\n which is a symbol defined in LinuxThreads, but (hopefully) not in other\n thread packages.\n */\n-#if 0\n-/* Note: on Caldera OpenLinux, this symbols is `local' in the\n-   libpthread.so (but not in libpthread.a).  We don't really need\n-   this, so we just comment it out.  */\n-extern char * __pthread_initial_thread_bos;\n-char **dummy_var_to_force_linux_threads = &__pthread_initial_thread_bos;\n-#endif\n+void (*dummy_var_to_force_linux_threads)() = pthread_kill_other_threads_np;\n \n #define LINUX_THREADS_STACK_SIZE  (2 * 1024 * 1024)\n \n@@ -424,6 +423,7 @@ void GC_thr_init()\n     GC_thread t;\n     struct sigaction act;\n \n+    if (GC_thr_initialized) return;\n     GC_thr_initialized = TRUE;\n \n     if (sem_init(&GC_suspend_ack_sem, 0, 0) != 0)\n@@ -446,7 +446,7 @@ void GC_thr_init()\n \n     /* Add the initial thread, so we can stop it.\t*/\n       t = GC_new_thread(pthread_self());\n-      t -> stack_ptr = (ptr_t)(&t);\n+      t -> stack_ptr = 0;\n       t -> flags = DETACHED | MAIN_THREAD;\n }\n \n@@ -465,11 +465,16 @@ int GC_pthread_sigmask(int how, const sigset_t *set, sigset_t *oset)\n struct start_info {\n     void *(*start_routine)(void *);\n     void *arg;\n+    word flags;\n+    sem_t registered;   \t/* 1 ==> in our thread table, but \t*/\n+\t\t\t\t/* parent hasn't yet noticed.\t\t*/\n };\n \n-void GC_thread_exit_proc(void *dummy)\n+\n+void GC_thread_exit_proc(void *arg)\n {\n     GC_thread me;\n+    struct start_info * si = arg;\n \n     LOCK();\n     me = GC_lookup_thread(pthread_self());\n@@ -504,26 +509,37 @@ void * GC_start_routine(void * arg)\n     struct start_info * si = arg;\n     void * result;\n     GC_thread me;\n+    pthread_t my_pthread;\n+    void *(*start)(void *);\n+    void *start_arg;\n \n+    my_pthread = pthread_self();\n     LOCK();\n-    me = GC_lookup_thread(pthread_self());\n+    me = GC_new_thread(my_pthread);\n+    me -> flags = si -> flags;\n+    me -> stack_ptr = 0;\n+    me -> stack_end = 0;\n     UNLOCK();\n-    pthread_cleanup_push(GC_thread_exit_proc, 0);\n+    start = si -> start_routine;\n+    start_arg = si -> arg;\n+    sem_post(&(si -> registered));\n+    pthread_cleanup_push(GC_thread_exit_proc, si);\n #   ifdef DEBUG_THREADS\n-        GC_printf1(\"Starting thread 0x%x\\n\", pthread_self());\n+        GC_printf1(\"Starting thread 0x%lx\\n\", pthread_self());\n         GC_printf1(\"pid = %ld\\n\", (long) getpid());\n         GC_printf1(\"sp = 0x%lx\\n\", (long) &arg);\n+\tGC_printf1(\"start_routine = 0x%lx\\n\", start);\n #   endif\n-    result = (*(si -> start_routine))(si -> arg);\n+    result = (*start)(start_arg);\n #if DEBUG_THREADS\n         GC_printf1(\"Finishing thread 0x%x\\n\", pthread_self());\n #endif\n     me -> status = result;\n     me -> flags |= FINISHED;\n     pthread_cleanup_pop(1);\n-\t/* This involves acquiring the lock, ensuring that we can't exit */\n-\t/* while a collection that thinks we're alive is trying to stop  */\n-\t/* us.\t\t\t\t\t\t\t\t */\n+    /* Cleanup acquires lock, ensuring that we can't exit\t\t*/\n+    /* while a collection that thinks we're alive is trying to stop     */\n+    /* us.\t\t\t\t\t\t\t\t*/\n     return(result);\n }\n \n@@ -541,8 +557,11 @@ GC_pthread_create(pthread_t *new_thread,\n     int detachstate;\n     word my_flags = 0;\n     struct start_info * si = GC_malloc(sizeof(struct start_info)); \n+\t/* This is otherwise saved only in an area mmapped by the thread */\n+\t/* library, which isn't visible to the collector.\t\t */\n \n     if (0 == si) return(ENOMEM);\n+    sem_init(&(si -> registered), 0, 0);\n     si -> start_routine = start_routine;\n     si -> arg = arg;\n     LOCK();\n@@ -555,17 +574,16 @@ GC_pthread_create(pthread_t *new_thread,\n     }\n     pthread_attr_getdetachstate(&new_attr, &detachstate);\n     if (PTHREAD_CREATE_DETACHED == detachstate) my_flags |= DETACHED;\n-    result = pthread_create(&my_new_thread, &new_attr, GC_start_routine, si);\n-    /* No GC can start until the thread is registered, since we hold\t*/\n-    /* the allocation lock.\t\t\t\t\t\t*/\n-    if (0 == result) {\n-        t = GC_new_thread(my_new_thread);\n-        t -> flags = my_flags;\n-\tt -> stack_ptr = 0;\n-\tt -> stack_end = 0;\n-        if (0 != new_thread) *new_thread = my_new_thread;\n-    }\n-    UNLOCK();  \n+    si -> flags = my_flags;\n+    UNLOCK();\n+    result = pthread_create(new_thread, &new_attr, GC_start_routine, si);\n+    /* Wait until child has been added to the thread table.\t\t*/\n+    /* This also ensures that we hold onto si until the child is done\t*/\n+    /* with it.  Thus it doesn't matter whether it is otherwise\t\t*/\n+    /* visible to the collector.\t\t\t\t\t*/\n+        if (0 != sem_wait(&(si -> registered))) ABORT(\"sem_wait failed\");\n+        sem_destroy(&(si -> registered));\n+    /* pthread_attr_destroy(&new_attr); */\n     /* pthread_attr_destroy(&new_attr); */\n     return(result);\n }"}, {"sha": "52f863467619385913d786b8daff604d4fe3700a", "filename": "boehm-gc/mach_dep.c", "status": "modified", "additions": 95, "deletions": 32, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20bbd3cd53a80ddafa56a5d21337aae0c24f94ca/boehm-gc%2Fmach_dep.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20bbd3cd53a80ddafa56a5d21337aae0c24f94ca/boehm-gc%2Fmach_dep.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fmach_dep.c?ref=20bbd3cd53a80ddafa56a5d21337aae0c24f94ca", "patch": "@@ -20,7 +20,11 @@\n #   define _longjmp(b,v) longjmp(b,v)\n # endif\n # ifdef AMIGA\n-#   include <dos.h>\n+#   ifndef __GNUC__\n+#     include <dos/dos.h>\n+#   else\n+#     include <machine/reg.h>\n+#   endif\n # endif\n \n #if defined(__MWERKS__) && !defined(POWERPC)\n@@ -58,12 +62,19 @@ asm static void PushMacRegisters()\n \n #endif /* __MWERKS__ */\n \n+# if defined(SPARC) || defined(IA64)\n+    /* Value returned from register flushing routine; either sp (SPARC) */\n+    /* or ar.bsp (IA64)\t\t\t\t\t\t\t*/\n+    word GC_save_regs_ret_val;\n+# endif\n+\n /* Routine to mark from registers that are preserved by the C compiler. */\n /* This must be ported to every new architecture.  There is a generic   */\n /* version at the end, that is likely, but not guaranteed to work       */\n /* on your architecture.  Run the test_setjmp program to see whether    */\n /* there is any chance it will work.                                    */\n \n+#ifndef USE_GENERIC_PUSH_REGS\n void GC_push_regs()\n {\n #       ifdef RT\n@@ -125,9 +136,28 @@ void GC_push_regs()\n \t  asm(\"addq.w &0x4,%sp\");\t/* put stack back where it was\t*/\n #       endif /* M68K HP */\n \n-#       ifdef AMIGA\n-\t/*  AMIGA - could be replaced by generic code \t\t\t*/\n-\t  /* a0, a1, d0 and d1 are caller save */\n+#\tif defined(M68K) && defined(AMIGA)\n+ \t /*  AMIGA - could be replaced by generic code \t\t\t*/\n+ \t /* a0, a1, d0 and d1 are caller save */\n+\n+#        ifdef __GNUC__\n+\t  asm(\"subq.w &0x4,%sp\");\t/* allocate word on top of stack */\n+\n+\t  asm(\"mov.l %a2,(%sp)\"); asm(\"jsr _GC_push_one\");\n+\t  asm(\"mov.l %a3,(%sp)\"); asm(\"jsr _GC_push_one\");\n+\t  asm(\"mov.l %a4,(%sp)\"); asm(\"jsr _GC_push_one\");\n+\t  asm(\"mov.l %a5,(%sp)\"); asm(\"jsr _GC_push_one\");\n+\t  asm(\"mov.l %a6,(%sp)\"); asm(\"jsr _GC_push_one\");\n+\t  /* Skip frame pointer and stack pointer */\n+\t  asm(\"mov.l %d2,(%sp)\"); asm(\"jsr _GC_push_one\");\n+\t  asm(\"mov.l %d3,(%sp)\"); asm(\"jsr _GC_push_one\");\n+\t  asm(\"mov.l %d4,(%sp)\"); asm(\"jsr _GC_push_one\");\n+\t  asm(\"mov.l %d5,(%sp)\"); asm(\"jsr _GC_push_one\");\n+\t  asm(\"mov.l %d6,(%sp)\"); asm(\"jsr _GC_push_one\");\n+\t  asm(\"mov.l %d7,(%sp)\"); asm(\"jsr _GC_push_one\");\n+\n+\t  asm(\"addq.w &0x4,%sp\");\t/* put stack back where it was\t*/\n+#        else /* !__GNUC__ */\n \t  GC_push_one(getreg(REG_A2));\n \t  GC_push_one(getreg(REG_A3));\n \t  GC_push_one(getreg(REG_A4));\n@@ -140,7 +170,8 @@ void GC_push_regs()\n \t  GC_push_one(getreg(REG_D5));\n \t  GC_push_one(getreg(REG_D6));\n \t  GC_push_one(getreg(REG_D7));\n-#       endif\n+#\t endif /* !__GNUC__ */\n+#       endif /* AMIGA */\n \n #\tif defined(M68K) && defined(MACOS)\n #\tif defined(THINK_C)\n@@ -169,8 +200,10 @@ void GC_push_regs()\n #   endif\t/* MACOS */\n \n #       if defined(I386) &&!defined(OS2) &&!defined(SVR4) &&!defined(MSWIN32) \\\n-\t&& !defined(SCO) && !defined(SCO_ELF) && !(defined(LINUX) \\\n-\t&& defined(__ELF__)) && !defined(DOS4GW) && !defined(FREEBSD)\n+\t&& !defined(SCO) && !defined(SCO_ELF) \\\n+ \t&& !(defined(LINUX)       && defined(__ELF__)) \\\n+\t&& !(defined(__FreeBSD__) && defined(__ELF__)) \\\n+\t&& !defined(DOS4GW)\n \t/* I386 code, generic code does not appear to work */\n \t/* It does appear to work under OS2, and asms dont */\n \t/* This is used for some 38g UNIX variants and for CYGWIN32 */\n@@ -183,8 +216,11 @@ void GC_push_regs()\n \t  asm(\"pushl %ebx\");  asm(\"call _GC_push_one\"); asm(\"addl $4,%esp\");\n #       endif\n \n-#\tif defined(I386) && (defined(LINUX) || defined(FREEBSD)) && defined(__ELF__)\n-\t/* This is modified for Linux/FreeBSD with ELF (Note: _ELF_ only) */\n+#\tif ( defined(I386) && defined(LINUX) && defined(__ELF__) ) \\\n+\t|| ( defined(I386) && defined(__FreeBSD__) && defined(__ELF__) )\n+\n+\t/* This is modified for Linux with ELF (Note: _ELF_ only) */\n+\t/* This section handles FreeBSD with ELF. */\n \t  asm(\"pushl %eax\");  asm(\"call GC_push_one\"); asm(\"addl $4,%esp\");\n \t  asm(\"pushl %ecx\");  asm(\"call GC_push_one\"); asm(\"addl $4,%esp\");\n \t  asm(\"pushl %edx\");  asm(\"call GC_push_one\"); asm(\"addl $4,%esp\");\n@@ -238,12 +274,12 @@ void GC_push_regs()\n \t  asm (\"movd r7, tos\"); asm (\"bsr ?_GC_push_one\"); asm (\"adjspb $-4\");\n #       endif\n \n-#       ifdef SPARC\n+#       if defined(SPARC) || defined(IA64)\n \t  {\n \t      word GC_save_regs_in_stack();\n \t      \n \t      /* generic code will not work */\n-\t      (void)GC_save_regs_in_stack();\n+\t      GC_save_regs_ret_val = GC_save_regs_in_stack();\n \t  }\n #       endif\n \n@@ -303,8 +339,32 @@ void GC_push_regs()\n #        endif /* !__GNUC__ */\n #       endif /* M68K/SYSV */\n \n+#     if defined(PJ)\n+\t{\n+\t    register int * sp asm (\"optop\");\n+\t    extern int *__libc_stack_end;\n \n-#     if defined(HP_PA) || defined(M88K) || defined(POWERPC) || (defined(I386) && (defined(OS2) || defined(USE_GENERIC))) || defined(UTS4)\n+\t    GC_push_all_stack (sp, __libc_stack_end);\n+        }\n+#     endif\n+\n+      /* other machines... */\n+#       if !(defined M68K) && !(defined VAX) && !(defined RT) \n+#\tif !(defined SPARC) && !(defined I386) && !(defined NS32K)\n+#\tif !defined(POWERPC) && !defined(UTS4) && !defined(IA64)\n+#       if !defined(PJ)\n+\t    --> bad news <--\n+#\tendif\n+#       endif\n+#       endif\n+#       endif\n+}\n+#endif /* !USE_GENERIC_PUSH_REGS */\n+\n+#if defined(USE_GENERIC_PUSH_REGS)\n+void GC_generic_push_regs(cold_gc_frame)\n+ptr_t cold_gc_frame;\n+{\n \t/* Generic code                          */\n \t/* The idea is due to Parag Patel at HP. */\n \t/* We're not sure whether he would like  */\n@@ -324,28 +384,10 @@ void GC_push_regs()\n #\t    else\n \t        (void) _setjmp(regs);\n #\t    endif\n-\t    GC_push_all_stack((ptr_t)regs, lim);\n+\t    GC_push_current_stack(cold_gc_frame);\n \t}\n-#     endif\n-#     if defined(PJ)\n-\t{\n-\t    register int * sp asm (\"optop\");\n-\t    extern int *__libc_stack_end;\n-\n-\t    GC_push_all_stack (sp, __libc_stack_end);\n-        }\n-#     endif\n-      /* other machines... */\n-#       if !(defined M68K) && !(defined VAX) && !(defined RT) \n-#\tif !(defined SPARC) && !(defined I386) && !(defined NS32K)\n-#\tif !defined(HP_PA) && !defined(M88K) && !defined(POWERPC)\n-#\tif !defined(UTS4) && !defined(PJ)\n-\t    --> bad news <--\n-# \tendif\n-#       endif\n-#       endif\n-#       endif\n }\n+#endif /* USE_GENERIC_PUSH_REGS */\n \n /* On register window machines, we need a way to force registers into \t*/\n /* the stack.\tReturn sp.\t\t\t\t\t\t*/\n@@ -372,6 +414,27 @@ void GC_push_regs()\n #   endif\n # endif\n \n+/* On IA64, we also need to flush register windows.  But they end\t*/\n+/* up on the other side of the stack segment.\t\t\t\t*/\n+/* Returns the backing store pointer for the register stack.\t\t*/\n+# ifdef IA64\n+\tasm(\"        .text\");\n+\tasm(\"        .psr abi64\");\n+\tasm(\"        .psr lsb\");\n+\tasm(\"        .lsb\");\n+\tasm(\"\");\n+\tasm(\"        .text\");\n+\tasm(\"        .align 16\");\n+\tasm(\"        .global GC_save_regs_in_stack\");\n+\tasm(\"        .proc GC_save_regs_in_stack\");\n+\tasm(\"GC_save_regs_in_stack:\");\n+\tasm(\"        .body\");\n+\tasm(\"        flushrs\");\n+\tasm(\"        ;;\");\n+\tasm(\"        mov r8=ar.bsp\");\n+\tasm(\"        br.ret.sptk.few rp\");\n+\tasm(\"        .endp GC_save_regs_in_stack\");\n+# endif\n \n /* GC_clear_stack_inner(arg, limit) clears stack area up to limit and\t*/\n /* returns arg.  Stack clearing is crucial on SPARC, so we supply\t*/"}, {"sha": "66e62d29694ff31f9625d546dc2b142016967001", "filename": "boehm-gc/malloc.c", "status": "modified", "additions": 19, "deletions": 2, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20bbd3cd53a80ddafa56a5d21337aae0c24f94ca/boehm-gc%2Fmalloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20bbd3cd53a80ddafa56a5d21337aae0c24f94ca/boehm-gc%2Fmalloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fmalloc.c?ref=20bbd3cd53a80ddafa56a5d21337aae0c24f94ca", "patch": "@@ -93,8 +93,16 @@ register ptr_t *opp;\n           if(GC_incremental && !GC_dont_gc)\n \t\tGC_collect_a_little_inner((int)n_blocks);\n \tlw = ROUNDED_UP_WORDS(lb);\n-\twhile ((h = GC_allochblk(lw, k, 0)) == 0\n-\t\t&& GC_collect_or_expand(n_blocks, FALSE));\n+        h = GC_allochblk(lw, k, 0);\n+#       ifdef USE_MUNMAP\n+\t  if (0 == h) {\n+\t    GC_merge_unmapped();\n+\t    h = GC_allochblk(lw, k, 0);\n+\t  }\n+#\tendif\n+\twhile (0 == h && GC_collect_or_expand(n_blocks, FALSE)) {\n+\t  h = GC_allochblk(lw, k, 0);\n+\t}\n \tif (h == 0) {\n \t    op = 0;\n \t} else {\n@@ -220,6 +228,9 @@ DCL_LOCK_STATE;\n       /*\n        * Thread initialisation can call malloc before\n        * we're ready for it.\n+       * It's not clear that this is enough to help matters.\n+       * The thread implementation may well call malloc at other\n+       * inopportune times.\n        */\n       if (!GC_is_initialized) return sbrk(lb);\n #   endif /* I386 && SOLARIS_THREADS */\n@@ -375,6 +386,12 @@ int obj_kind;\n     \t/* Required by ANSI.  It's not my fault ...\t*/\n     h = HBLKPTR(p);\n     hhdr = HDR(h);\n+#   if defined(REDIRECT_MALLOC) && \\\n+\t(defined(SOLARIS_THREADS) || defined(LINUX_THREADS))\n+\t/* We have to redirect malloc calls during initialization.\t*/\n+\t/* Don't try to deallocate that memory.\t\t\t\t*/\n+\tif (0 == hhdr) return;\n+#   endif\n     knd = hhdr -> hb_obj_kind;\n     sz = hhdr -> hb_sz;\n     ok = &GC_obj_kinds[knd];"}, {"sha": "8c07fa9884617b043490fc63392e3ded2c014333", "filename": "boehm-gc/mallocx.c", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20bbd3cd53a80ddafa56a5d21337aae0c24f94ca/boehm-gc%2Fmallocx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20bbd3cd53a80ddafa56a5d21337aae0c24f94ca/boehm-gc%2Fmallocx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fmallocx.c?ref=20bbd3cd53a80ddafa56a5d21337aae0c24f94ca", "patch": "@@ -57,8 +57,16 @@ register int k;\n     if(GC_incremental && !GC_dont_gc)\n         GC_collect_a_little_inner((int)n_blocks);\n     lw = ROUNDED_UP_WORDS(lb);\n-    while ((h = GC_allochblk(lw, k, IGNORE_OFF_PAGE)) == 0\n-           && GC_collect_or_expand(n_blocks, TRUE));\n+    h = GC_allochblk(lw, k, IGNORE_OFF_PAGE);\n+#   ifdef USE_MUNMAP\n+      if (0 == h) {\n+        GC_merge_unmapped();\n+        h = GC_allochblk(lw, k, IGNORE_OFF_PAGE);\n+      }\n+#   endif\n+    while (0 == h && GC_collect_or_expand(n_blocks, TRUE)) {\n+      h = GC_allochblk(lw, k, IGNORE_OFF_PAGE);\n+    }\n     if (h == 0) {\n         op = 0;\n     } else {\n@@ -130,7 +138,7 @@ void GC_incr_mem_freed(size_t n)\n      ptr_t GC_generic_malloc_words_small(size_t lw, int k)\n #else \n      ptr_t GC_generic_malloc_words_small(lw, k)\n-     register size_t lw;\n+     register word lw;\n      register int k;\n #endif\n {\n@@ -148,7 +156,7 @@ DCL_LOCK_STATE;\n             GC_init_inner();\n         }\n \tif (kind -> ok_reclaim_list != 0 || GC_alloc_reclaim_list(kind)) {\n-\t    op = GC_clear_stack(GC_allocobj(lw, k));\n+\t    op = GC_clear_stack(GC_allocobj((word)lw, k));\n \t}\n \tif (op == 0) {\n \t    UNLOCK();"}, {"sha": "ef0e0c088e01957096d6727ad0720bddffd8d144", "filename": "boehm-gc/mark.c", "status": "modified", "additions": 125, "deletions": 41, "changes": 166, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20bbd3cd53a80ddafa56a5d21337aae0c24f94ca/boehm-gc%2Fmark.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20bbd3cd53a80ddafa56a5d21337aae0c24f94ca/boehm-gc%2Fmark.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fmark.c?ref=20bbd3cd53a80ddafa56a5d21337aae0c24f94ca", "patch": "@@ -21,7 +21,11 @@\n \n /* We put this here to minimize the risk of inlining. */\n /*VARARGS*/\n-void GC_noop() {}\n+#ifdef __WATCOMC__\n+  void GC_noop(void *p, ...) {}\n+#else\n+  void GC_noop() {}\n+#endif\n \n /* Single argument version, robust against whole program analysis. */\n void GC_noop1(x)\n@@ -32,7 +36,8 @@ word x;\n     sink = x;\n }\n \n-mark_proc GC_mark_procs[MAX_MARK_PROCS] = {0};\n+/* mark_proc GC_mark_procs[MAX_MARK_PROCS] = {0} -- declared in gc_priv.h */\n+\n word GC_n_mark_procs = 0;\n \n /* Initialize GC_obj_kinds properly and standard free lists properly.  \t*/\n@@ -82,6 +87,10 @@ struct obj_kind GC_obj_kinds[MAXOBJKINDS] = {\n #   define INITIAL_MARK_STACK_SIZE (1*HBLKSIZE)\n \t\t/* INITIAL_MARK_STACK_SIZE * sizeof(mse) should be a \t*/\n \t\t/* multiple of HBLKSIZE.\t\t\t\t*/\n+\t\t/* The incremental collector actually likes a larger\t*/\n+\t\t/* size, since it want to push all marked dirty objs\t*/\n+\t\t/* before marking anything new.  Currently we let it\t*/\n+\t\t/* grow dynamically.\t\t\t\t\t*/\n # endif\n \n /*\n@@ -108,6 +117,9 @@ GC_bool GC_mark_stack_too_small = FALSE;\n GC_bool GC_objects_are_marked = FALSE;\t/* Are there collectable marked\t*/\n \t\t\t\t\t/* objects in the heap?\t\t*/\n \n+/* Is a collection in progress?  Note that this can return true in the\t*/\n+/* nonincremental case, if a collection has been abandoned and the\t*/\n+/* mark state is now MS_INVALID.\t\t\t\t\t*/\n GC_bool GC_collection_in_progress()\n {\n     return(GC_mark_state != MS_NONE);\n@@ -233,15 +245,25 @@ static void alloc_mark_stack();\n /* Perform a small amount of marking.\t\t\t*/\n /* We try to touch roughly a page of memory.\t\t*/\n /* Return TRUE if we just finished a mark phase.\t*/\n-GC_bool GC_mark_some()\n+/* Cold_gc_frame is an address inside a GC frame that\t*/\n+/* remains valid until all marking is complete.\t\t*/\n+/* A zero value indicates that it's OK to miss some\t*/\n+/* register values.\t\t\t\t\t*/\n+GC_bool GC_mark_some(cold_gc_frame)\n+ptr_t cold_gc_frame;\n {\n     switch(GC_mark_state) {\n     \tcase MS_NONE:\n     \t    return(FALSE);\n     \t    \n     \tcase MS_PUSH_RESCUERS:\n     \t    if (GC_mark_stack_top\n-    \t        >= GC_mark_stack + INITIAL_MARK_STACK_SIZE/4) {\n+    \t        >= GC_mark_stack + GC_mark_stack_size\n+\t\t   - INITIAL_MARK_STACK_SIZE/2) {\n+\t\t/* Go ahead and mark, even though that might cause us to */\n+\t\t/* see more marked dirty objects later on.  Avoid this\t */\n+\t\t/* in the future.\t\t\t\t\t */\n+\t\tGC_mark_stack_too_small = TRUE;\n     \t        GC_mark_from_mark_stack();\n     \t        return(FALSE);\n     \t    } else {\n@@ -251,7 +273,7 @@ GC_bool GC_mark_some()\n \t\t\tGC_printf1(\"Marked from %lu dirty pages\\n\",\n \t\t\t\t   (unsigned long)GC_n_rescuing_pages);\n #\t\t    endif\n-    \t    \t    GC_push_roots(FALSE);\n+    \t    \t    GC_push_roots(FALSE, cold_gc_frame);\n     \t    \t    GC_objects_are_marked = TRUE;\n     \t    \t    if (GC_mark_state != MS_INVALID) {\n     \t    \t        GC_mark_state = MS_ROOTS_PUSHED;\n@@ -268,7 +290,7 @@ GC_bool GC_mark_some()\n     \t    } else {\n     \t        scan_ptr = GC_push_next_marked_uncollectable(scan_ptr);\n     \t        if (scan_ptr == 0) {\n-    \t    \t    GC_push_roots(TRUE);\n+    \t    \t    GC_push_roots(TRUE, cold_gc_frame);\n     \t    \t    GC_objects_are_marked = TRUE;\n     \t    \t    if (GC_mark_state != MS_INVALID) {\n     \t    \t        GC_mark_state = MS_ROOTS_PUSHED;\n@@ -299,14 +321,17 @@ GC_bool GC_mark_some()\n     \t        GC_mark_from_mark_stack();\n     \t        return(FALSE);\n     \t    }\n-    \t    if (scan_ptr == 0\n-    \t        && (GC_mark_state == MS_INVALID || GC_mark_stack_too_small)) {\n-    \t        alloc_mark_stack(2*GC_mark_stack_size);\n+    \t    if (scan_ptr == 0 && GC_mark_state == MS_INVALID) {\n+\t\t/* About to start a heap scan for marked objects. */\n+\t\t/* Mark stack is empty.  OK to reallocate.\t  */\n+\t\tif (GC_mark_stack_too_small) {\n+    \t            alloc_mark_stack(2*GC_mark_stack_size);\n+\t\t}\n \t\tGC_mark_state = MS_PARTIALLY_INVALID;\n     \t    }\n     \t    scan_ptr = GC_push_next_marked(scan_ptr);\n     \t    if (scan_ptr == 0 && GC_mark_state == MS_PARTIALLY_INVALID) {\n-    \t    \tGC_push_roots(TRUE);\n+    \t    \tGC_push_roots(TRUE, cold_gc_frame);\n     \t    \tGC_objects_are_marked = TRUE;\n     \t    \tif (GC_mark_state != MS_INVALID) {\n     \t    \t    GC_mark_state = MS_ROOTS_PUSHED;\n@@ -388,6 +413,7 @@ mse * GC_signal_mark_stack_overflow(msp)\n mse * msp;\n {\n     GC_mark_state = MS_INVALID;\n+    GC_mark_stack_too_small = TRUE;\n #   ifdef PRINTSTATS\n \tGC_printf1(\"Mark stack overflow; current size = %lu entries\\n\",\n \t    \t    GC_mark_stack_size);\n@@ -507,13 +533,15 @@ word n;\n     if (GC_mark_stack_size != 0) {\n         if (new_stack != 0) {\n           word displ = (word)GC_mark_stack & (GC_page_size - 1);\n-          word size = GC_mark_stack_size * sizeof(struct ms_entry);\n+          signed_word size = GC_mark_stack_size * sizeof(struct ms_entry);\n           \n           /* Recycle old space */\n \t      if (0 != displ) displ = GC_page_size - displ;\n \t      size = (size - displ) & ~(GC_page_size - 1);\n-\t      GC_add_to_heap((struct hblk *)\n-\t      \t\t\t((word)GC_mark_stack + displ), size);\n+\t      if (size > 0) {\n+\t        GC_add_to_heap((struct hblk *)\n+\t      \t\t\t((word)GC_mark_stack + displ), (word)size);\n+\t      }\n           GC_mark_stack = new_stack;\n           GC_mark_stack_size = n;\n #\t  ifdef PRINTSTATS\n@@ -655,7 +683,13 @@ int all;\n # endif\n word p;\n {\n-    GC_PUSH_ONE_STACK(p);\n+#   ifdef NURSERY\n+      if (0 != GC_push_proc) {\n+\tGC_push_proc(p);\n+\treturn;\n+      }\n+#   endif\n+    GC_PUSH_ONE_STACK(p, 0);\n }\n \n # ifdef __STDC__\n@@ -665,7 +699,7 @@ word p;\n # endif\n \n /* As above, but argument passed preliminary test. */\n-# ifdef PRINT_BLACK_LIST\n+# if defined(PRINT_BLACK_LIST) || defined(KEEP_BACK_PTRS)\n     void GC_push_one_checked(p, interior_ptrs, source)\n     ptr_t source;\n # else\n@@ -694,13 +728,18 @@ register GC_bool interior_ptrs;\n         displ = HBLKDISPL(p);\n         map_entry = MAP_ENTRY((hhdr -> hb_map), displ);\n         if (map_entry == OBJ_INVALID) {\n-          if (interior_ptrs) {\n-            r = BASE(p);\n-\t    displ = BYTES_TO_WORDS(HBLKDISPL(r));\n-\t    if (r == 0) hhdr = 0;\n-          } else {\n-            hhdr = 0;\n-          }\n+#\t  ifndef ALL_INTERIOR_POINTERS\n+            if (interior_ptrs) {\n+              r = BASE(p);\n+\t      displ = BYTES_TO_WORDS(HBLKDISPL(r));\n+\t      if (r == 0) hhdr = 0;\n+            } else {\n+              hhdr = 0;\n+            }\n+#\t  else\n+\t    /* map already reflects interior pointers */\n+\t    hhdr = 0;\n+#\t  endif\n         } else {\n           displ = BYTES_TO_WORDS(displ);\n           displ -= map_entry;\n@@ -723,6 +762,7 @@ register GC_bool interior_ptrs;\n     } else {\n \tif (!mark_bit_from_hdr(hhdr, displ)) {\n \t    set_mark_bit_from_hdr(hhdr, displ);\n+ \t    GC_STORE_BACK_PTR(source, (ptr_t)r);\n \t    PUSH_OBJ((word *)r, hhdr, GC_mark_stack_top,\n \t             &(GC_mark_stack[GC_mark_stack_size]));\n \t}\n@@ -776,17 +816,13 @@ void GC_print_trace(word gc_no, GC_bool lock)\n \n /*\n  * A version of GC_push_all that treats all interior pointers as valid\n+ * and scans the entire region immediately, in case the contents\n+ * change.\n  */\n-void GC_push_all_stack(bottom, top)\n+void GC_push_all_eager(bottom, top)\n ptr_t bottom;\n ptr_t top;\n {\n-# ifdef ALL_INTERIOR_POINTERS\n-    GC_push_all(bottom, top);\n-#   ifdef TRACE_BUF\n-        GC_add_trace_entry(\"GC_push_all_stack\", bottom, top);\n-#   endif\n-# else\n     word * b = (word *)(((long) bottom + ALIGNMENT-1) & ~(ALIGNMENT-1));\n     word * t = (word *)(((long) top) & ~(ALIGNMENT-1));\n     register word *p;\n@@ -803,10 +839,58 @@ ptr_t top;\n       lim = t - 1 /* longword */;\n       for (p = b; p <= lim; p = (word *)(((char *)p) + ALIGNMENT)) {\n \tq = *p;\n-\tGC_PUSH_ONE_STACK(q);\n+\tGC_PUSH_ONE_STACK(q, p);\n       }\n #   undef GC_greatest_plausible_heap_addr\n #   undef GC_least_plausible_heap_addr\n+}\n+\n+#ifndef THREADS\n+/*\n+ * A version of GC_push_all that treats all interior pointers as valid\n+ * and scans part of the area immediately, to make sure that saved\n+ * register values are not lost.\n+ * Cold_gc_frame delimits the stack section that must be scanned\n+ * eagerly.  A zero value indicates that no eager scanning is needed.\n+ */\n+void GC_push_all_stack_partially_eager(bottom, top, cold_gc_frame)\n+ptr_t bottom;\n+ptr_t top;\n+ptr_t cold_gc_frame;\n+{\n+# ifdef ALL_INTERIOR_POINTERS\n+#   define EAGER_BYTES 1024\n+    /* Push the hot end of the stack eagerly, so that register values   */\n+    /* saved inside GC frames are marked before they disappear.\t\t*/\n+    /* The rest of the marking can be deferred until later.\t\t*/\n+    if (0 == cold_gc_frame) {\n+\tGC_push_all_stack(bottom, top);\n+\treturn;\n+    }\n+#   ifdef STACK_GROWS_DOWN\n+\tGC_push_all_eager(bottom, cold_gc_frame);\n+\tGC_push_all(cold_gc_frame - sizeof(ptr_t), top);\n+#   else /* STACK_GROWS_UP */\n+\tGC_push_all_eager(cold_gc_frame, top);\n+\tGC_push_all(bottom, cold_gc_frame + sizeof(ptr_t));\n+#   endif /* STACK_GROWS_UP */\n+# else\n+    GC_push_all_eager(bottom, top);\n+# endif\n+# ifdef TRACE_BUF\n+      GC_add_trace_entry(\"GC_push_all_stack\", bottom, top);\n+# endif\n+}\n+#endif /* !THREADS */\n+\n+void GC_push_all_stack(bottom, top)\n+ptr_t bottom;\n+ptr_t top;\n+{\n+# ifdef ALL_INTERIOR_POINTERS\n+    GC_push_all(bottom, top);\n+# else\n+    GC_push_all_eager(bottom, top);\n # endif\n }\n \n@@ -838,7 +922,7 @@ register hdr * hhdr;\n \t    while(mark_word != 0) {\n \t      if (mark_word & 1) {\n \t          q = p[i];\n-\t          GC_PUSH_ONE_HEAP(q);\n+\t          GC_PUSH_ONE_HEAP(q, p + i);\n \t      }\n \t      i++;\n \t      mark_word >>= 1;\n@@ -879,9 +963,9 @@ register hdr * hhdr;\n \t    while(mark_word != 0) {\n \t      if (mark_word & 1) {\n \t          q = p[i];\n-\t          GC_PUSH_ONE_HEAP(q);\n+\t          GC_PUSH_ONE_HEAP(q, p + i);\n \t          q = p[i+1];\n-\t          GC_PUSH_ONE_HEAP(q);\n+\t          GC_PUSH_ONE_HEAP(q, p + i);\n \t      }\n \t      i += 2;\n \t      mark_word >>= 2;\n@@ -921,13 +1005,13 @@ register hdr * hhdr;\n \t    while(mark_word != 0) {\n \t      if (mark_word & 1) {\n \t          q = p[i];\n-\t          GC_PUSH_ONE_HEAP(q);\n+\t          GC_PUSH_ONE_HEAP(q, p + i);\n \t          q = p[i+1];\n-\t          GC_PUSH_ONE_HEAP(q);\n+\t          GC_PUSH_ONE_HEAP(q, p + i + 1);\n \t          q = p[i+2];\n-\t          GC_PUSH_ONE_HEAP(q);\n+\t          GC_PUSH_ONE_HEAP(q, p + i + 2);\n \t          q = p[i+3];\n-\t          GC_PUSH_ONE_HEAP(q);\n+\t          GC_PUSH_ONE_HEAP(q, p + i + 3);\n \t      }\n \t      i += 4;\n \t      mark_word >>= 4;\n@@ -1037,7 +1121,7 @@ struct hblk *h;\n {\n     register hdr * hhdr;\n     \n-    h = GC_next_block(h);\n+    h = GC_next_used_block(h);\n     if (h == 0) return(0);\n     hhdr = HDR(h);\n     GC_push_marked(h, hhdr);\n@@ -1049,11 +1133,11 @@ struct hblk *h;\n struct hblk * GC_push_next_marked_dirty(h)\n struct hblk *h;\n {\n-    register hdr * hhdr = HDR(h);\n+    register hdr * hhdr;\n     \n     if (!GC_dirty_maintained) { ABORT(\"dirty bits not set up\"); }\n     for (;;) {\n-        h = GC_next_block(h);\n+        h = GC_next_used_block(h);\n         if (h == 0) return(0);\n         hhdr = HDR(h);\n #\tifdef STUBBORN_ALLOC\n@@ -1082,7 +1166,7 @@ struct hblk *h;\n     register hdr * hhdr = HDR(h);\n     \n     for (;;) {\n-        h = GC_next_block(h);\n+        h = GC_next_used_block(h);\n         if (h == 0) return(0);\n         hhdr = HDR(h);\n \tif (hhdr -> hb_obj_kind == UNCOLLECTABLE) break;"}, {"sha": "0e84f2732fc414039d73154fac36269550c98ba3", "filename": "boehm-gc/mark_rts.c", "status": "modified", "additions": 138, "deletions": 87, "changes": 225, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20bbd3cd53a80ddafa56a5d21337aae0c24f94ca/boehm-gc%2Fmark_rts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20bbd3cd53a80ddafa56a5d21337aae0c24f94ca/boehm-gc%2Fmark_rts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fmark_rts.c?ref=20bbd3cd53a80ddafa56a5d21337aae0c24f94ca", "patch": "@@ -15,46 +15,27 @@\n # include <stdio.h>\n # include \"gc_priv.h\"\n \n-/* MAX_ROOT_SETS is the maximum number of ranges that can be \t*/\n-/* registered as static roots. \t\t\t\t\t*/\n-# ifdef LARGE_CONFIG\n-#   define MAX_ROOT_SETS 4096\n-# else\n-#   ifdef PCR\n-#     define MAX_ROOT_SETS 1024\n-#   else\n-#     ifdef MSWIN32\n-#\tdefine MAX_ROOT_SETS 512\n-\t    /* Under NT, we add only written pages, which can result \t*/\n-\t    /* in many small root sets.\t\t\t\t\t*/\n-#     else\n-#       define MAX_ROOT_SETS 64\n-#     endif\n-#   endif\n-# endif\n-\n-# define MAX_EXCLUSIONS (MAX_ROOT_SETS/4)\n-/* Maximum number of segments that can be excluded from root sets.\t*/\n-\n /* Data structure for list of root sets.\t\t\t\t*/\n /* We keep a hash table, so that we can filter out duplicate additions.\t*/\n /* Under Win32, we need to do a better job of filtering overlaps, so\t*/\n /* we resort to sequential search, and pay the price.\t\t\t*/\n+/* This is really declared in gc_priv.h:\n struct roots {\n \tptr_t r_start;\n \tptr_t r_end;\n-#\tifndef MSWIN32\n+ #\tifndef MSWIN32\n \t  struct roots * r_next;\n-#\tendif\n+ #\tendif\n \tGC_bool r_tmp;\n-\t  \t/* Delete before registering new dynamic libraries */\n+\t  \t-- Delete before registering new dynamic libraries\n };\n \n-static struct roots static_roots[MAX_ROOT_SETS];\n+struct roots GC_static_roots[MAX_ROOT_SETS];\n+*/\n \n static int n_root_sets = 0;\n \n-\t/* static_roots[0..n_root_sets) contains the valid root sets. */\n+\t/* GC_static_roots[0..n_root_sets) contains the valid root sets. */\n \n # if !defined(NO_DEBUGGING)\n /* For debugging:\t*/\n@@ -65,14 +46,14 @@ void GC_print_static_roots()\n     \n     for (i = 0; i < n_root_sets; i++) {\n         GC_printf2(\"From 0x%lx to 0x%lx \",\n-        \t   (unsigned long) static_roots[i].r_start,\n-        \t   (unsigned long) static_roots[i].r_end);\n-        if (static_roots[i].r_tmp) {\n+        \t   (unsigned long) GC_static_roots[i].r_start,\n+        \t   (unsigned long) GC_static_roots[i].r_end);\n+        if (GC_static_roots[i].r_tmp) {\n             GC_printf0(\" (temporary)\\n\");\n         } else {\n             GC_printf0(\"\\n\");\n         }\n-        total += static_roots[i].r_end - static_roots[i].r_start;\n+        total += GC_static_roots[i].r_end - GC_static_roots[i].r_start;\n     }\n     GC_printf1(\"Total size: %ld\\n\", (unsigned long) total);\n     if (GC_root_size != total) {\n@@ -92,11 +73,11 @@ ptr_t p;\n     register int i;\n     \n     \n-    if (p >= static_roots[last_root_set].r_start\n-        && p < static_roots[last_root_set].r_end) return(TRUE);\n+    if (p >= GC_static_roots[last_root_set].r_start\n+        && p < GC_static_roots[last_root_set].r_end) return(TRUE);\n     for (i = 0; i < n_root_sets; i++) {\n-    \tif (p >= static_roots[i].r_start\n-            && p < static_roots[i].r_end) {\n+    \tif (p >= GC_static_roots[i].r_start\n+            && p < GC_static_roots[i].r_end) {\n             last_root_set = i;\n             return(TRUE);\n         }\n@@ -105,12 +86,15 @@ ptr_t p;\n }\n \n #ifndef MSWIN32\n+/* \n #   define LOG_RT_SIZE 6\n-#   define RT_SIZE (1 << LOG_RT_SIZE)  /* Power of 2, may be != MAX_ROOT_SETS */\n+#   define RT_SIZE (1 << LOG_RT_SIZE)  -- Power of 2, may be != MAX_ROOT_SETS\n \n-    static struct roots * root_index[RT_SIZE];\n-\t/* Hash table header.  Used only to check whether a range is \t*/\n-\t/* already present.\t\t\t\t\t\t*/\n+    struct roots * GC_root_index[RT_SIZE];\n+\t-- Hash table header.  Used only to check whether a range is\n+\t-- already present.\n+\t-- really defined in gc_priv.h\n+*/\n \n static int rt_hash(addr)\n char * addr;\n@@ -134,7 +118,7 @@ struct roots * GC_roots_present(b)\n char *b;\n {\n     register int h = rt_hash(b);\n-    register struct roots *p = root_index[h];\n+    register struct roots *p = GC_root_index[h];\n     \n     while (p != 0) {\n         if (p -> r_start == (ptr_t)b) return(p);\n@@ -149,8 +133,8 @@ struct roots *p;\n {\n     register int h = rt_hash(p -> r_start);\n     \n-    p -> r_next = root_index[h];\n-    root_index[h] = p;\n+    p -> r_next = GC_root_index[h];\n+    GC_root_index[h] = p;\n }\n \n # else /* MSWIN32 */\n@@ -200,7 +184,7 @@ GC_bool tmp;\n         register int i;\n         \n         for (i = 0; i < n_root_sets; i++) {\n-            old = static_roots + i;\n+            old = GC_static_roots + i;\n             if ((ptr_t)b <= old -> r_end && (ptr_t)e >= old -> r_start) {\n                 if ((ptr_t)b < old -> r_start) {\n                     old -> r_start = (ptr_t)b;\n@@ -219,7 +203,7 @@ GC_bool tmp;\n             struct roots *other;\n             \n             for (i++; i < n_root_sets; i++) {\n-              other = static_roots + i;\n+              other = GC_static_roots + i;\n               b = (char *)(other -> r_start);\n               e = (char *)(other -> r_end);\n               if ((ptr_t)b <= old -> r_end && (ptr_t)e >= old -> r_start) {\n@@ -234,8 +218,8 @@ GC_bool tmp;\n                 old -> r_tmp &= other -> r_tmp;\n                 /* Delete this entry. */\n                   GC_root_size -= (other -> r_end - other -> r_start);\n-                  other -> r_start = static_roots[n_root_sets-1].r_start;\n-                  other -> r_end = static_roots[n_root_sets-1].r_end;\n+                  other -> r_start = GC_static_roots[n_root_sets-1].r_start;\n+                  other -> r_end = GC_static_roots[n_root_sets-1].r_end;\n                                   n_root_sets--;\n               }\n             }\n@@ -255,13 +239,13 @@ GC_bool tmp;\n     if (n_root_sets == MAX_ROOT_SETS) {\n         ABORT(\"Too many root sets\\n\");\n     }\n-    static_roots[n_root_sets].r_start = (ptr_t)b;\n-    static_roots[n_root_sets].r_end = (ptr_t)e;\n-    static_roots[n_root_sets].r_tmp = tmp;\n+    GC_static_roots[n_root_sets].r_start = (ptr_t)b;\n+    GC_static_roots[n_root_sets].r_end = (ptr_t)e;\n+    GC_static_roots[n_root_sets].r_tmp = tmp;\n #   ifndef MSWIN32\n-      static_roots[n_root_sets].r_next = 0;\n+      GC_static_roots[n_root_sets].r_next = 0;\n #   endif\n-    add_roots_to_index(static_roots + n_root_sets);\n+    add_roots_to_index(GC_static_roots + n_root_sets);\n     GC_root_size += (ptr_t)e - (ptr_t)b;\n     n_root_sets++;\n }\n@@ -278,7 +262,7 @@ void GC_clear_roots GC_PROTO((void))\n     {\n     \tregister int i;\n     \t\n-    \tfor (i = 0; i < RT_SIZE; i++) root_index[i] = 0;\n+    \tfor (i = 0; i < RT_SIZE; i++) GC_root_index[i] = 0;\n     }\n #   endif\n     UNLOCK();\n@@ -291,11 +275,12 @@ void GC_remove_tmp_roots()\n     register int i;\n     \n     for (i = 0; i < n_root_sets; ) {\n-    \tif (static_roots[i].r_tmp) {\n-    \t    GC_root_size -= (static_roots[i].r_end - static_roots[i].r_start);\n-    \t    static_roots[i].r_start = static_roots[n_root_sets-1].r_start;\n-    \t    static_roots[i].r_end = static_roots[n_root_sets-1].r_end;\n-    \t    static_roots[i].r_tmp = static_roots[n_root_sets-1].r_tmp;\n+    \tif (GC_static_roots[i].r_tmp) {\n+    \t    GC_root_size -=\n+\t\t(GC_static_roots[i].r_end - GC_static_roots[i].r_start);\n+    \t    GC_static_roots[i].r_start = GC_static_roots[n_root_sets-1].r_start;\n+    \t    GC_static_roots[i].r_end = GC_static_roots[n_root_sets-1].r_end;\n+    \t    GC_static_roots[i].r_tmp = GC_static_roots[n_root_sets-1].r_tmp;\n     \t    n_root_sets--;\n     \t} else {\n     \t    i++;\n@@ -305,8 +290,9 @@ void GC_remove_tmp_roots()\n     {\n     \tregister int i;\n     \t\n-    \tfor (i = 0; i < RT_SIZE; i++) root_index[i] = 0;\n-    \tfor (i = 0; i < n_root_sets; i++) add_roots_to_index(static_roots + i);\n+    \tfor (i = 0; i < RT_SIZE; i++) GC_root_index[i] = 0;\n+    \tfor (i = 0; i < n_root_sets; i++)\n+\t\tadd_roots_to_index(GC_static_roots + i);\n     }\n #   endif\n     \n@@ -321,16 +307,19 @@ ptr_t GC_approx_sp()\n \n /*\n  * Data structure for excluded static roots.\n- */\n+ * Real declaration is in gc_priv.h.\n+\n struct exclusion {\n     ptr_t e_start;\n     ptr_t e_end;\n };\n \n-struct exclusion excl_table[MAX_EXCLUSIONS];\n-\t\t\t\t\t/* Array of exclusions, ascending */\n-\t\t\t\t\t/* address order.\t\t  */\n-size_t excl_table_entries = 0;\t\t/* Number of entries in use.\t  */\n+struct exclusion GC_excl_table[MAX_EXCLUSIONS];\n+\t\t\t\t\t-- Array of exclusions, ascending\n+\t\t\t\t\t-- address order.\n+*/\n+\n+size_t GC_excl_table_entries = 0;\t/* Number of entries in use.\t  */\n \n /* Return the first exclusion range that includes an address >= start_addr */\n /* Assumes the exclusion table contains at least one entry (namely the\t   */\n@@ -339,20 +328,20 @@ struct exclusion * GC_next_exclusion(start_addr)\n ptr_t start_addr;\n {\n     size_t low = 0;\n-    size_t high = excl_table_entries - 1;\n+    size_t high = GC_excl_table_entries - 1;\n     size_t mid;\n \n     while (high > low) {\n \tmid = (low + high) >> 1;\n \t/* low <= mid < high\t*/\n-\tif ((word) excl_table[mid].e_end <= (word) start_addr) {\n+\tif ((word) GC_excl_table[mid].e_end <= (word) start_addr) {\n \t    low = mid + 1;\n \t} else {\n \t    high = mid;\n \t}\n     }\n-    if ((word) excl_table[low].e_end <= (word) start_addr) return 0;\n-    return excl_table + low;\n+    if ((word) GC_excl_table[low].e_end <= (word) start_addr) return 0;\n+    return GC_excl_table + low;\n }\n \n void GC_exclude_static_roots(start, finish)\n@@ -362,7 +351,7 @@ GC_PTR finish;\n     struct exclusion * next;\n     size_t next_index, i;\n \n-    if (0 == excl_table_entries) {\n+    if (0 == GC_excl_table_entries) {\n \tnext = 0;\n     } else {\n \tnext = GC_next_exclusion(start);\n@@ -377,17 +366,17 @@ GC_PTR finish;\n           next -> e_start = (ptr_t)start;\n \t  return;\n       }\n-      next_index = next - excl_table;\n-      for (i = excl_table_entries; i > next_index; --i) {\n-\texcl_table[i] = excl_table[i-1];\n+      next_index = next - GC_excl_table;\n+      for (i = GC_excl_table_entries; i > next_index; --i) {\n+\tGC_excl_table[i] = GC_excl_table[i-1];\n       }\n     } else {\n-      next_index = excl_table_entries;\n+      next_index = GC_excl_table_entries;\n     }\n-    if (excl_table_entries == MAX_EXCLUSIONS) ABORT(\"Too many exclusions\");\n-    excl_table[next_index].e_start = (ptr_t)start;\n-    excl_table[next_index].e_end = (ptr_t)finish;\n-    ++excl_table_entries;\n+    if (GC_excl_table_entries == MAX_EXCLUSIONS) ABORT(\"Too many exclusions\");\n+    GC_excl_table[next_index].e_start = (ptr_t)start;\n+    GC_excl_table[next_index].e_end = (ptr_t)finish;\n+    ++GC_excl_table_entries;\n }\n \n /* Invoke push_conditional on ranges that are not excluded. */\n@@ -410,22 +399,85 @@ int all;\n     }\n }\n \n+/*\n+ * In the absence of threads, push the stack contents.\n+ * In the presence of threads, push enough of the current stack\n+ * to ensure that callee-save registers saved in collector frames have been\n+ * seen.\n+ */\n+void GC_push_current_stack(cold_gc_frame)\n+ptr_t cold_gc_frame;\n+{\n+#   if defined(THREADS)\n+\tif (0 == cold_gc_frame) return;\n+#       ifdef STACK_GROWS_DOWN\n+    \t  GC_push_all_eager(GC_approx_sp(), cold_gc_frame);\n+#\t  ifdef IA64\n+\t    --> fix this\n+#\t  endif\n+#       else\n+\t  GC_push_all_eager( cold_gc_frame, GC_approx_sp() );\n+#       endif\n+#   else\n+#   \tifdef STACK_GROWS_DOWN\n+    \t    GC_push_all_stack_partially_eager( GC_approx_sp(), GC_stackbottom,\n+\t\t\t\t\t       cold_gc_frame );\n+#\t    ifdef IA64\n+\t      /* We also need to push the register stack backing store. */\n+\t      /* This should really be done in the same way as the\t*/\n+\t      /* regular stack.  For now we fudge it a bit.\t\t*/\n+\t      /* Note that the backing store grows up, so we can't use\t*/\n+\t      /* GC_push_all_stack_partially_eager.\t\t\t*/\n+\t      {\n+\t\textern word GC_save_regs_ret_val;\n+\t\t\t/* Previously set to backing store pointer.\t*/\n+\t\tptr_t bsp = (ptr_t) GC_save_regs_ret_val;\n+\t        ptr_t cold_gc_bs_pointer;\n+#\t\tifdef ALL_INTERIOR_POINTERS\n+\t          cold_gc_bs_pointer = bsp - 2048;\n+\t\t  if (cold_gc_bs_pointer < BACKING_STORE_BASE) {\n+\t\t    cold_gc_bs_pointer = BACKING_STORE_BASE;\n+\t\t  }\n+\t\t  GC_push_all(BACKING_STORE_BASE, cold_gc_bs_pointer);\n+#\t\telse\n+\t\t  cold_gc_bs_pointer = BACKING_STORE_BASE;\n+#\t\tendif\n+\t\tGC_push_all_eager(cold_gc_bs_pointer, bsp);\n+\t\t/* All values should be sufficiently aligned that we\t*/\n+\t\t/* dont have to worry about the boundary.\t\t*/\n+\t      }\n+#\t    endif\n+#       else\n+\t    GC_push_all_stack_partially_eager( GC_stackbottom, GC_approx_sp(),\n+\t\t\t\t\t       cold_gc_frame );\n+#       endif\n+#   endif /* !THREADS */\n+}\n+\n /*\n  * Call the mark routines (GC_tl_push for a single pointer, GC_push_conditional\n  * on groups of pointers) on every top level accessible pointer.\n  * If all is FALSE, arrange to push only possibly altered values.\n+ * Cold_gc_frame is an address inside a GC frame that\n+ * remains valid until all marking is complete.\n+ * A zero value indicates that it's OK to miss some\n+ * register values.\n  */\n-\n-void GC_push_roots(all)\n+void GC_push_roots(all, cold_gc_frame)\n GC_bool all;\n+ptr_t cold_gc_frame;\n {\n     register int i;\n \n     /*\n      * push registers - i.e., call GC_push_one(r) for each\n      * register contents r.\n      */\n+#   ifdef USE_GENERIC_PUSH_REGS\n+\tGC_generic_push_regs(cold_gc_frame);\n+#   else\n         GC_push_regs(); /* usually defined in machine_dep.c */\n+#   endif\n         \n     /*\n      * Next push static data.  This must happen early on, since it's\n@@ -440,20 +492,19 @@ GC_bool all;\n      /* Mark everything in static data areas                             */\n        for (i = 0; i < n_root_sets; i++) {\n          GC_push_conditional_with_exclusions(\n-\t\t\t     static_roots[i].r_start,\n-\t\t\t     static_roots[i].r_end, all);\n+\t\t\t     GC_static_roots[i].r_start,\n+\t\t\t     GC_static_roots[i].r_end, all);\n        }\n \n     /*\n      * Now traverse stacks.\n      */\n-#   ifndef THREADS\n-        /* Mark everything on the stack.           */\n-#   \t  ifdef STACK_GROWS_DOWN\n-\t    GC_push_all_stack( GC_approx_sp(), GC_stackbottom );\n-#\t  else\n-\t    GC_push_all_stack( GC_stackbottom, GC_approx_sp() );\n-#\t  endif\n+#   if !defined(USE_GENERIC_PUSH_REGS)\n+\tGC_push_current_stack(cold_gc_frame);\n+\t/* IN the threads case, this only pushes collector frames.      */\n+\t/* In the USE_GENERIC_PUSH_REGS case, this is done inside\t*/\n+\t/* GC_push_regs, so that we catch callee-save registers saved\t*/\n+\t/* inside the GC_push_regs frame.\t\t\t\t*/\n #   endif\n     if (GC_push_other_roots != 0) (*GC_push_other_roots)();\n     \t/* In the threads case, this also pushes thread stacks.\t*/"}, {"sha": "348d08aa3b1b20a451ffd2c3675228b46425d40e", "filename": "boehm-gc/misc.c", "status": "modified", "additions": 43, "deletions": 17, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20bbd3cd53a80ddafa56a5d21337aae0c24f94ca/boehm-gc%2Fmisc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20bbd3cd53a80ddafa56a5d21337aae0c24f94ca/boehm-gc%2Fmisc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fmisc.c?ref=20bbd3cd53a80ddafa56a5d21337aae0c24f94ca", "patch": "@@ -42,17 +42,19 @@\n #          ifdef WIN32_THREADS\n \t      GC_API CRITICAL_SECTION GC_allocate_ml;\n #          else\n-#             if defined(IRIX_THREADS) || defined(LINUX_THREADS)\n-#\t\tifdef UNDEFINED\n-\t\t    pthread_mutex_t GC_allocate_ml = PTHREAD_MUTEX_INITIALIZER;\n-#\t\tendif\n+#             if defined(IRIX_THREADS) || defined(LINUX_THREADS) \\\n+\t\t || defined(IRIX_JDK_THREADS)\n \t        pthread_t GC_lock_holder = NO_THREAD;\n #\t      else\n-#               if defined(QUICK_THREADS)\n-                    /* Nothing.  */\n-#               else\n-\t            --> declare allocator lock here\n-#               endif\n+#\t        if defined(HPUX_THREADS)\n+\t\t  pthread_mutex_t GC_allocate_ml = PTHREAD_MUTEX_INITIALIZER;\n+#\t\telse \n+#                 if defined(QUICK_THREADS)\n+\t\t\t\t/* Nothing */\n+#                 else\n+\t          --> declare allocator lock here\n+#                 endif\n+#\t\tendif\n #\t      endif\n #\t   endif\n #\tendif\n@@ -80,6 +82,12 @@ GC_bool GC_dont_gc = 0;\n \n GC_bool GC_quiet = 0;\n \n+#ifdef FIND_LEAK\n+  int GC_find_leak = 1;\n+#else\n+  int GC_find_leak = 0;\n+#endif\n+\n /*ARGSUSED*/\n GC_PTR GC_default_oom_fn GC_PROTO((size_t bytes_requested))\n {\n@@ -392,6 +400,11 @@ size_t GC_get_heap_size GC_PROTO(())\n     return ((size_t) GC_heapsize);\n }\n \n+size_t GC_get_free_bytes GC_PROTO(())\n+{\n+    return ((size_t) GC_large_free_bytes);\n+}\n+\n size_t GC_get_bytes_since_gc GC_PROTO(())\n {\n     return ((size_t) WORDS_TO_BYTES(GC_words_allocd));\n@@ -429,27 +442,34 @@ void GC_init_inner()\n     \n     if (GC_is_initialized) return;\n     GC_setpagesize();\n-    GC_exclude_static_roots(beginGC_arrays, endGC_arrays);\n+    GC_exclude_static_roots(beginGC_arrays, end_gc_area);\n+#   ifdef PRINTSTATS\n+\tif ((ptr_t)endGC_arrays != (ptr_t)(&GC_obj_kinds)) {\n+\t    GC_printf0(\"Reordering linker, didn't exclude obj_kinds\\n\");\n+\t}\n+#   endif\n #   ifdef MSWIN32\n  \tGC_init_win32();\n #   endif\n #   if defined(LINUX) && defined(POWERPC)\n \tGC_init_linuxppc();\n #   endif\n-#   if defined(LINUX) && defined(ALPHA)\n-      GC_init_linuxalpha();\n+#   if defined(LINUX) && \\\n+\t(defined(POWERPC) || defined(ALPHA) || defined(SPARC) || defined(IA64))\n+\tGC_init_linux_data_start();\n #   endif\n #   ifdef SOLARIS_THREADS\n \tGC_thr_init();\n \t/* We need dirty bits in order to find live stack sections.\t*/\n         GC_dirty_init();\n #   endif\n-#   if defined(IRIX_THREADS) || defined(LINUX_THREADS)\n-\tGC_thr_init();\n+#   if defined(IRIX_THREADS) || defined(LINUX_THREADS) \\\n+       || defined(IRIX_JDK_THREADS) || defined(HPUX_THREADS)\n+        GC_thr_init();\n #   endif\n #   if !defined(THREADS) || defined(SOLARIS_THREADS) || defined(WIN32_THREADS) \\\n        || defined(IRIX_THREADS) || defined(LINUX_THREADS) \\\n-       || defined (QUICK_THREADS)\n+       || defined(HPUX_THREADS) || defined(QUICK_THREADS)\n       if (GC_stackbottom == 0) {\n \t  GC_stackbottom = GC_get_stack_base();\n       }\n@@ -564,9 +584,10 @@ void GC_init_inner()\n \n void GC_enable_incremental GC_PROTO(())\n {\n+# if !defined(SMALL_CONFIG)\n+  if (!GC_find_leak) {\n     DCL_LOCK_STATE;\n     \n-# ifndef FIND_LEAK\n     DISABLE_SIGNALS();\n     LOCK();\n     if (GC_incremental) goto out;\n@@ -602,6 +623,7 @@ void GC_enable_incremental GC_PROTO(())\n out:\n     UNLOCK();\n     ENABLE_SIGNALS();\n+  }\n # endif\n }\n \n@@ -781,7 +803,7 @@ char * msg;\n void GC_print_callers (info)\n struct callinfo info[NFRAMES];\n {\n-    register int i,j;\n+    register int i;\n     \n #   if NFRAMES == 1\n       GC_err_printf0(\"\\tCaller at allocation:\\n\");\n@@ -791,13 +813,17 @@ struct callinfo info[NFRAMES];\n     for (i = 0; i < NFRAMES; i++) {\n      \tif (info[i].ci_pc == 0) break;\n #\tif NARGS > 0\n+\t{\n+\t  int j;\n+\n      \t  GC_err_printf0(\"\\t\\targs: \");\n      \t  for (j = 0; j < NARGS; j++) {\n      \t    if (j != 0) GC_err_printf0(\", \");\n      \t    GC_err_printf2(\"%d (0x%X)\", ~(info[i].ci_arg[j]),\n      \t    \t\t\t\t~(info[i].ci_arg[j]));\n      \t  }\n \t  GC_err_printf0(\"\\n\");\n+\t}\n # \tendif\n      \tGC_err_printf1(\"\\t\\t##PC##= 0x%X\\n\", info[i].ci_pc);\n     }"}, {"sha": "744b1e0898be254ccbdb8c0963195ff9ca44ec8a", "filename": "boehm-gc/os_dep.c", "status": "modified", "additions": 440, "deletions": 134, "changes": 574, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20bbd3cd53a80ddafa56a5d21337aae0c24f94ca/boehm-gc%2Fos_dep.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20bbd3cd53a80ddafa56a5d21337aae0c24f94ca/boehm-gc%2Fos_dep.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fos_dep.c?ref=20bbd3cd53a80ddafa56a5d21337aae0c24f94ca", "patch": "@@ -1,6 +1,8 @@\n /*\n+ * Copyright 1988, 1989 Hans-J. Boehm, Alan J. Demers\n  * Copyright (c) 1991-1995 by Xerox Corporation.  All rights reserved.\n- * Copyright (c) 1996-1997 by Silicon Graphics.  All rights reserved.\n+ * Copyright (c) 1996-1999 by Silicon Graphics.  All rights reserved.\n+ * Copyright (c) 1999 by Hewlett-Packard Company.  All rights reserved.\n  *\n  * THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED\n  * OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.\n@@ -30,8 +32,12 @@\n       /* prototypes, so we have to include the top-level sigcontext.h to    */\n       /* make sure the former gets defined to be the latter if appropriate. */\n #     include <features.h>\n-#     if 2 <= __GLIBC__ && 0 == __GLIBC_MINOR__\n-#       include <sigcontext.h>\n+#     if 2 <= __GLIBC__\n+#       if 2 == __GLIBC__ && 0 == __GLIBC_MINOR__\n+\t  /* glibc 2.1 no longer has sigcontext.h.  But signal.h\t*/\n+\t  /* has the right declaration for glibc 2.1.\t\t\t*/\n+#         include <sigcontext.h>\n+#       endif /* 0 == __GLIBC_MINOR__ */\n #     else /* not 2 <= __GLIBC__ */\n         /* libc5 doesn't have <sigcontext.h>: go directly with the kernel   */\n         /* one.  Check LINUX_VERSION_CODE to see which we should reference. */\n@@ -50,13 +56,13 @@\n # include <signal.h>\n \n /* Blatantly OS dependent routines, except for those that are related \t*/\n-/* dynamic loading.\t\t\t\t\t\t\t*/\n+/* to dynamic loading.\t\t\t\t\t\t\t*/\n \n # if !defined(THREADS) && !defined(STACKBOTTOM) && defined(HEURISTIC2)\n #   define NEED_FIND_LIMIT\n # endif\n \n-# if defined(IRIX_THREADS)\n+# if defined(IRIX_THREADS) || defined(HPUX_THREADS)\n #   define NEED_FIND_LIMIT\n # endif\n \n@@ -68,7 +74,8 @@\n #   define NEED_FIND_LIMIT\n # endif\n \n-# if defined(LINUX) && (defined(POWERPC) || defined(ALPHA))\n+# if defined(LINUX) && \\\n+     (defined(POWERPC) || defined(SPARC) || defined(ALPHA) || defined(IA64))\n #   define NEED_FIND_LIMIT\n # endif\n \n@@ -135,92 +142,21 @@\n # define OPT_PROT_EXEC 0\n #endif\n \n-#if defined(LINUX) && defined(POWERPC)\n+#if defined(LINUX) && (defined(POWERPC) || defined(SPARC) || defined(ALPHA) \\\n+    \t\t       || defined(IA64))\n+  /* The I386 case can be handled without a search.  The Alpha case\t*/\n+  /* used to be handled differently as well, but the rules changed\t*/\n+  /* for recent Linux versions.  This seems to be the easiest way to\t*/\n+  /* cover all versions.\t\t\t\t\t\t*/\n   ptr_t GC_data_start;\n \n-  void GC_init_linuxppc()\n-  {\n-    extern ptr_t GC_find_limit();\n-    extern char **_environ;\n-\t/* This may need to be environ, without the underscore, for\t*/\n-\t/* some versions.\t\t\t\t\t\t*/\n-    GC_data_start = GC_find_limit((ptr_t)&_environ, FALSE);\n-  }\n-#endif\n+  extern char * GC_copyright[];  /* Any data symbol would do. */\n \n-#if defined(LINUX) && defined(ALPHA)\n-  ptr_t GC_data_start;\n-\n-  void GC_init_linuxalpha()\n+  void GC_init_linux_data_start()\n   {\n-# ifdef USE_PROC\n-    FILE *fp = fopen(\"/proc/self/maps\", \"r\");\n-\n-    if (fp) {\n-      extern void *_etext;\n-      ptr_t stacktop = 0, stackbottom = 0;\n-      ptr_t textstart = 0, textend = 0;\n-      ptr_t datastart = 0, dataend = 0;\n-      ptr_t bssstart = 0, bssend = 0;\n-\n-      while (!feof(fp)) {\n-        ptr_t start, end, offset;\n-        unsigned short major, minor;\n-        char r, w, x, p;\n-        unsigned int inode;\n-\n-        int n = fscanf(fp, \"%lx-%lx %c%c%c%c %lx %hx:%hx %d\",\n-          &start, &end, &r, &w, &x, &p, &offset, &major, &minor, &inode);\n-        if (n < 10) break;\n-\n-        /*\n-         * If local variable lies within segment, it is stack.\n-         * Else if segment lies below _end and is executable,\n-         * it is text.  Otherwise, if segment start lies between\n-         * _etext and _end and segment is writable and is mapped\n-         * to the executable image it is data, otherwise bss.\n-         */\n-         if (start < (ptr_t)&fp && end > (ptr_t)&fp && w == 'w') {\n-           stacktop = start;\n-           stackbottom = end;\n-         } else if (start < (ptr_t)&_end && w == '-' && x == 'x') {\n-           textstart = start;\n-           textend = end;\n-         } else if (start >= (ptr_t)&_etext &&\n-                      start < (ptr_t)&_end && w == 'w') {\n-           if (inode > 0) {\n-             datastart = start;\n-             dataend = end;\n-           } else {\n-             bssstart = start;\n-             bssend = end;\n-           }\n-         }\n-\n-         //printf(\"%016lx-%016lx %c%c%c%c %016lx %02hx:%02hx %d\\n\",\n-         //      start, end, r, w, x, p, offset, major, minor, inode);\n-\n-         while (fgetc(fp) != '\\n') ;\n-       }\n-       fclose(fp);\n-\n-       //fprintf(stderr, \"text:  %lx-%lx\\n\", textstart, textend);\n-       //fprintf(stderr, \"data:  %lx-%lx\\n\", datastart, dataend);\n-       //fprintf(stderr, \"bss:   %lx-%lx\\n\", bssstart, bssend);\n-       //fprintf(stderr, \"stack: %lx-%lx\\n\", stacktop, stackbottom);\n+    extern ptr_t GC_find_limit();\n \n-       GC_data_start = datastart;\n-     } else {\n-# endif\n-       extern ptr_t GC_find_limit();\n-       extern int _edata;\n-       /* This may need to be environ, without the underscore, for */\n-       /* some versions.  */\n-       GC_data_start = GC_find_limit((ptr_t)&_edata, FALSE);\n-# ifdef USE_PROC\n-     }\n-# endif\n-     //fprintf(stderr, \"GC_data_start = %p\\n\", GC_data_start);\n+    GC_data_start = GC_find_limit((ptr_t)GC_copyright, FALSE);\n   }\n #endif\n \n@@ -455,7 +391,8 @@ word GC_page_size;\n   }\n \n # else\n-#   if defined(MPROTECT_VDB) || defined(PROC_VDB) || defined(USE_MMAP)\n+#   if defined(MPROTECT_VDB) || defined(PROC_VDB) || defined(USE_MMAP) \\\n+       || defined(USE_MUNMAP)\n \tvoid GC_setpagesize()\n \t{\n \t    GC_page_size = GETPAGESIZE();\n@@ -532,6 +469,24 @@ ptr_t GC_get_stack_base()\n \n # ifdef AMIGA\n \n+ptr_t GC_get_stack_base()\n+{\n+    struct Process *proc = (struct Process*)SysBase->ThisTask;\n+ \n+    /* Reference: Amiga Guru Book Pages: 42,567,574 */\n+    if (proc->pr_Task.tc_Node.ln_Type==NT_PROCESS\n+        && proc->pr_CLI != NULL) {\n+\t/* first ULONG is StackSize */\n+\t/*longPtr = proc->pr_ReturnAddr;\n+\tsize = longPtr[0];*/\n+\n+\treturn (char *)proc->pr_ReturnAddr + sizeof(ULONG);\n+    } else {\n+\treturn (char *)proc->pr_Task.tc_SPUpper;\n+    }\n+}\n+\n+#if 0 /* old version */\n ptr_t GC_get_stack_base()\n {\n     extern struct WBStartup *_WBenchMsg;\n@@ -556,10 +511,9 @@ ptr_t GC_get_stack_base()\n     }\n     return (ptr_t)(__base + GC_max(size, __stack));\n }\n+#endif /* 0 */\n \n-# else\n-\n-\n+# else /* !AMIGA, !OS2, ... */\n \n # ifdef NEED_FIND_LIMIT\n   /* Some tools to implement HEURISTIC2\t*/\n@@ -579,17 +533,19 @@ ptr_t GC_get_stack_base()\n \ttypedef void (*handler)();\n #   endif\n \n-#   if defined(SUNOS5SIGS) || defined(IRIX5)\n+#   if defined(SUNOS5SIGS) || defined(IRIX5) || defined(OSF1)\n \tstatic struct sigaction old_segv_act;\n-\tstatic struct sigaction old_bus_act;\n+#\tif defined(_sigargs) || defined(HPUX) /* !Irix6.x */\n+\t    static struct sigaction old_bus_act;\n+#\tendif\n #   else\n         static handler old_segv_handler, old_bus_handler;\n #   endif\n     \n     void GC_setup_temporary_fault_handler()\n     {\n # ifndef ECOS\n-#\tif defined(SUNOS5SIGS) || defined(IRIX5)\n+#\tif defined(SUNOS5SIGS) || defined(IRIX5) || defined(OSF1)\n \t  struct sigaction\tact;\n \n \t  act.sa_handler\t= GC_fault_handler;\n@@ -608,10 +564,11 @@ ptr_t GC_get_stack_base()\n \t        (void) sigaction(SIGSEGV, &act, 0);\n #\t  else\n \t        (void) sigaction(SIGSEGV, &act, &old_segv_act);\n-#\t\tifdef _sigargs\t/* Irix 5.x, not 6.x */\n-\t\t    /* Under 5.x, we may get SIGBUS.\t\t\t*/\n-\t\t    /* Pthreads doesn't exist under 5.x, so we don't\t*/\n-\t\t    /* have to worry in the threads case.\t\t*/\n+#\t\tif defined(IRIX5) && defined(_sigargs) /* Irix 5.x, not 6.x */ \\\n+\t\t   || defined(HPUX)\n+\t\t    /* Under Irix 5.x or HP/UX, we may get SIGBUS.\t*/\n+\t\t    /* Pthreads doesn't exist under Irix 5.x, so we\t*/\n+\t\t    /* don't have to worry in the threads case.\t\t*/\n \t\t    (void) sigaction(SIGBUS, &act, &old_bus_act);\n #\t\tendif\n #\t  endif\t/* IRIX_THREADS */\n@@ -627,9 +584,10 @@ ptr_t GC_get_stack_base()\n     void GC_reset_fault_handler()\n     {\n # ifndef ECOS\n-#       if defined(SUNOS5SIGS) || defined(IRIX5)\n+#       if defined(SUNOS5SIGS) || defined(IRIX5) || defined(OSF1)\n \t  (void) sigaction(SIGSEGV, &old_segv_act, 0);\n-#\t  ifdef _sigargs\t/* Irix 5.x, not 6.x */\n+#\t  if defined(IRIX5) && defined(_sigargs) /* Irix 5.x, not 6.x */ \\\n+\t     || defined(HPUX)\n \t      (void) sigaction(SIGBUS, &old_bus_act, 0);\n #\t  endif\n #       else\n@@ -679,8 +637,43 @@ ptr_t GC_get_stack_base()\n     }\n # endif\n \n-\n # ifndef ECOS\n+\n+#ifdef LINUX_STACKBOTTOM\n+\n+# define STAT_SKIP 27   /* Number of fields preceding startstack\t*/\n+\t\t\t/* field in /proc/<pid>/stat\t\t\t*/\n+\n+  ptr_t GC_linux_stack_base(void)\n+  {\n+    char buf[50];\n+    FILE *f;\n+    char c;\n+    word result = 0;\n+    int i;\n+\n+    sprintf(buf, \"/proc/%d/stat\", getpid());\n+    f = fopen(buf, \"r\");\n+    if (NULL == f) ABORT(\"Couldn't open /proc/<pid>/stat\");\n+    c = getc(f);\n+    /* Skip the required number of fields.  This number is hopefully\t*/\n+    /* constant across all Linux implementations.\t\t\t*/\n+      for (i = 0; i < STAT_SKIP; ++i) {\n+\twhile (isspace(c)) c = getc(f);\n+\twhile (!isspace(c)) c = getc(f);\n+      }\n+    while (isspace(c)) c = getc(f);\n+    while (isdigit(c)) {\n+      result *= 10;\n+      result += c - '0';\n+      c = getc(f);\n+    }\n+    if (result < 0x10000000) ABORT(\"Absurd stack bottom value\");\n+    return (ptr_t)result;\n+  }\n+\n+#endif /* LINUX_STACKBOTTOM */\n+\n ptr_t GC_get_stack_base()\n {\n     word dummy;\n@@ -705,6 +698,9 @@ ptr_t GC_get_stack_base()\n \t\t\t      & ~STACKBOTTOM_ALIGNMENT_M1);\n #\t   endif\n #\tendif /* HEURISTIC1 */\n+#\tifdef LINUX_STACKBOTTOM\n+\t   result = GC_linux_stack_base();\n+#\tendif\n #\tifdef HEURISTIC2\n #\t    ifdef STACK_GROWS_DOWN\n \t\tresult = GC_find_limit((ptr_t)(&dummy), TRUE);\n@@ -725,6 +721,9 @@ ptr_t GC_get_stack_base()\n #\t    endif\n \n #\tendif /* HEURISTIC2 */\n+#\tifdef STACK_GROWS_DOWN\n+\t    if (result == 0) result = (ptr_t)(signed_word)(-sizeof(ptr_t));\n+#\tendif\n     \treturn(result);\n #   endif /* STACKBOTTOM */\n #   endif /* STACKBASE */\n@@ -954,6 +953,72 @@ void GC_register_data_segments()\n # else\n # ifdef AMIGA\n \n+   void GC_register_data_segments()\n+   {\n+     struct Process\t*proc;\n+     struct CommandLineInterface *cli;\n+     BPTR myseglist;\n+     ULONG *data;\n+ \n+     int\tnum;\n+\n+\n+#    ifdef __GNUC__\n+        ULONG dataSegSize;\n+        GC_bool found_segment = FALSE;\n+\textern char __data_size[];\n+\n+\tdataSegSize=__data_size+8;\n+\t/* Can`t find the Location of __data_size, because\n+           it`s possible that is it, inside the segment. */\n+\n+#     endif\n+\n+\tproc= (struct Process*)SysBase->ThisTask;\n+\n+\t/* Reference: Amiga Guru Book Pages: 538ff,565,573\n+\t\t     and XOper.asm */\n+\tif (proc->pr_Task.tc_Node.ln_Type==NT_PROCESS) {\n+\t  if (proc->pr_CLI == NULL) {\n+\t    myseglist = proc->pr_SegList;\n+\t  } else {\n+\t    /* ProcLoaded\t'Loaded as a command: '*/\n+\t    cli = BADDR(proc->pr_CLI);\n+\t    myseglist = cli->cli_Module;\n+\t  }\n+\t} else {\n+\t  ABORT(\"Not a Process.\");\n+ \t}\n+\n+\tif (myseglist == NULL) {\n+\t    ABORT(\"Arrrgh.. can't find segments, aborting\");\n+ \t}\n+\n+\t/* xoper hunks Shell Process */\n+\n+\tnum=0;\n+        for (data = (ULONG *)BADDR(myseglist); data != NULL;\n+             data = (ULONG *)BADDR(data[0])) {\n+\t  if (((ULONG) GC_register_data_segments < (ULONG) &data[1]) ||\n+\t      ((ULONG) GC_register_data_segments > (ULONG) &data[1] + data[-1])) {\n+#             ifdef __GNUC__\n+\t\tif (dataSegSize == data[-1]) {\n+\t\t  found_segment = TRUE;\n+\t\t}\n+# \t      endif\n+\t      GC_add_roots_inner((char *)&data[1],\n+\t\t\t\t ((char *)&data[1]) + data[-1], FALSE);\n+          }\n+          ++num;\n+        } /* for */\n+# \tifdef __GNUC__\n+\t   if (!found_segment) {\n+\t     ABORT(\"Can`t find correct Segments.\\nSolution: Use an newer version of ixemul.library\");\n+\t   }\n+# \tendif\n+  }\n+\n+#if 0 /* old version */\n   void GC_register_data_segments()\n   {\n     extern struct WBStartup *_WBenchMsg;\n@@ -995,6 +1060,7 @@ void GC_register_data_segments()\n          }\n     }\n   }\n+#endif /* old version */\n \n \n # else\n@@ -1035,7 +1101,8 @@ int * etext_addr;\n \n void GC_register_data_segments()\n {\n-#   if !defined(PCR) && !defined(SRC_M3) && !defined(NEXT) && !defined(MACOS)\n+#   if !defined(PCR) && !defined(SRC_M3) && !defined(NEXT) && !defined(MACOS) \\\n+       && !defined(MACOSX)\n #     if defined(REDIRECT_MALLOC) && defined(SOLARIS_THREADS)\n \t/* As of Solaris 2.3, the Solaris threads implementation\t*/\n \t/* allocates the data structure for the initial thread with\t*/\n@@ -1049,7 +1116,7 @@ void GC_register_data_segments()\n \tGC_add_roots_inner(DATASTART, (char *)(DATAEND), FALSE);\n #     endif\n #   endif\n-#   if !defined(PCR) && defined(NEXT)\n+#   if !defined(PCR) && (defined(NEXT) || defined(MACOSX))\n       GC_add_roots_inner(DATASTART, (char *) get_end(), FALSE);\n #   endif\n #   if defined(MACOS)\n@@ -1063,9 +1130,19 @@ void GC_register_data_segments()\n #     if defined(__MWERKS__)\n #       if !__POWERPC__\n \t  extern void* GC_MacGetDataStart(void);\n+\t  /* MATTHEW: Function to handle Far Globals (CW Pro 3) */\n+#         if __option(far_data)\n+\t  extern void* GC_MacGetDataEnd(void);\n+#         endif\n \t  /* globals begin above stack and end at a5. */\n \t  GC_add_roots_inner((ptr_t)GC_MacGetDataStart(),\n           \t\t     (ptr_t)LMGetCurrentA5(), FALSE);\n+\t  /* MATTHEW: Handle Far Globals */          \t\t     \n+#         if __option(far_data)\n+      /* Far globals follow he QD globals: */\n+\t  GC_add_roots_inner((ptr_t)LMGetCurrentA5(),\n+          \t\t     (ptr_t)GC_MacGetDataEnd(), FALSE);\n+#         endif\n #       else\n \t  extern char __data_start__[], __data_end__[];\n \t  GC_add_roots_inner((ptr_t)&__data_start__,\n@@ -1132,7 +1209,15 @@ word bytes;\n #else  /* Not RS6000 */\n \n #if defined(USE_MMAP)\n-/* Tested only under IRIX5 */\n+/* Tested only under IRIX5 and Solaris 2 */\n+\n+#ifdef USE_MMAP_FIXED\n+#   define GC_MMAP_FLAGS MAP_FIXED | MAP_PRIVATE\n+\t/* Seems to yield better performance on Solaris 2, but can\t*/\n+\t/* be unreliable if something is already mapped at the address.\t*/\n+#else\n+#   define GC_MMAP_FLAGS MAP_PRIVATE\n+#endif\n \n ptr_t GC_unix_get_mem(bytes)\n word bytes;\n@@ -1148,7 +1233,7 @@ word bytes;\n     }\n     if (bytes & (GC_page_size -1)) ABORT(\"Bad GET_MEM arg\");\n     result = mmap(last_addr, bytes, PROT_READ | PROT_WRITE | OPT_PROT_EXEC,\n-\t\t  MAP_PRIVATE | MAP_FIXED, fd, 0/* offset */);\n+\t\t  GC_MMAP_FLAGS, fd, 0/* offset */);\n     if (result == MAP_FAILED) return(0);\n     last_addr = (ptr_t)result + bytes + GC_page_size - 1;\n     last_addr = (ptr_t)((word)last_addr & ~(GC_page_size - 1));\n@@ -1232,8 +1317,108 @@ word bytes;\n     return(result);\t\t\t  \n }\n \n+void GC_win32_free_heap ()\n+{\n+    if (GC_win32s) {\n+ \twhile (GC_n_heap_bases > 0) {\n+ \t    GlobalFree (GC_heap_bases[--GC_n_heap_bases]);\n+ \t    GC_heap_bases[GC_n_heap_bases] = 0;\n+ \t}\n+    }\n+}\n+\n+\n # endif\n \n+#ifdef USE_MUNMAP\n+\n+/* For now, this only works on some Unix-like systems.  If you \t*/\n+/* have something else, don't define USE_MUNMAP.\t\t*/\n+/* We assume ANSI C to support this feature.\t\t\t*/\n+#include <unistd.h>\n+#include <sys/mman.h>\n+#include <sys/stat.h>\n+#include <sys/types.h>\n+#include <fcntl.h>\n+\n+/* Compute a page aligned starting address for the unmap \t*/\n+/* operation on a block of size bytes starting at start.\t*/\n+/* Return 0 if the block is too small to make this feasible.\t*/\n+ptr_t GC_unmap_start(ptr_t start, word bytes)\n+{\n+    ptr_t result = start;\n+    /* Round start to next page boundary.       */\n+        result += GC_page_size - 1;\n+        result = (ptr_t)((word)result & ~(GC_page_size - 1));\n+    if (result + GC_page_size > start + bytes) return 0;\n+    return result;\n+}\n+\n+/* Compute end address for an unmap operation on the indicated\t*/\n+/* block.\t\t\t\t\t\t\t*/\n+ptr_t GC_unmap_end(ptr_t start, word bytes)\n+{\n+    ptr_t end_addr = start + bytes;\n+    end_addr = (ptr_t)((word)end_addr & ~(GC_page_size - 1));\n+    return end_addr;\n+}\n+\n+/* We assume that GC_remap is called on exactly the same range\t*/\n+/* as a previous call to GC_unmap.  It is safe to consistently\t*/\n+/* round the endpoints in both places.\t\t\t\t*/\n+void GC_unmap(ptr_t start, word bytes)\n+{\n+    ptr_t start_addr = GC_unmap_start(start, bytes);\n+    ptr_t end_addr = GC_unmap_end(start, bytes);\n+    word len = end_addr - start_addr;\n+    if (0 == start_addr) return;\n+    if (munmap(start_addr, len) != 0) ABORT(\"munmap failed\");\n+    GC_unmapped_bytes += len;\n+}\n+\n+\n+void GC_remap(ptr_t start, word bytes)\n+{\n+    static int zero_descr = -1;\n+    ptr_t start_addr = GC_unmap_start(start, bytes);\n+    ptr_t end_addr = GC_unmap_end(start, bytes);\n+    word len = end_addr - start_addr;\n+    ptr_t result;\n+\n+    if (-1 == zero_descr) zero_descr = open(\"/dev/zero\", O_RDWR);\n+    if (0 == start_addr) return;\n+    result = mmap(start_addr, len, PROT_READ | PROT_WRITE | OPT_PROT_EXEC,\n+\t          MAP_FIXED | MAP_PRIVATE, zero_descr, 0);\n+    if (result != start_addr) {\n+\tABORT(\"mmap remapping failed\");\n+    }\n+    GC_unmapped_bytes -= len;\n+}\n+\n+/* Two adjacent blocks have already been unmapped and are about to\t*/\n+/* be merged.  Unmap the whole block.  This typically requires\t\t*/\n+/* that we unmap a small section in the middle that was not previously\t*/\n+/* unmapped due to alignment constraints.\t\t\t\t*/\n+void GC_unmap_gap(ptr_t start1, word bytes1, ptr_t start2, word bytes2)\n+{\n+    ptr_t start1_addr = GC_unmap_start(start1, bytes1);\n+    ptr_t end1_addr = GC_unmap_end(start1, bytes1);\n+    ptr_t start2_addr = GC_unmap_start(start2, bytes2);\n+    ptr_t end2_addr = GC_unmap_end(start2, bytes2);\n+    ptr_t start_addr = end1_addr;\n+    ptr_t end_addr = start2_addr;\n+    word len;\n+    GC_ASSERT(start1 + bytes1 == start2);\n+    if (0 == start1_addr) start_addr = GC_unmap_start(start1, bytes1 + bytes2);\n+    if (0 == start2_addr) end_addr = GC_unmap_end(start1, bytes1 + bytes2);\n+    if (0 == start_addr) return;\n+    len = end_addr - start_addr;\n+    if (len != 0 && munmap(start_addr, len) != 0) ABORT(\"munmap failed\");\n+    GC_unmapped_bytes += len;\n+}\n+\n+#endif /* USE_MUNMAP */\n+\n /* Routine for pushing any additional roots.  In THREADS \t*/\n /* environment, this is also responsible for marking from \t*/\n /* thread stacks.  In the SRC_M3 case, it also handles\t\t*/\n@@ -1351,6 +1536,7 @@ void GC_default_push_other_roots()\n \n # if defined(SOLARIS_THREADS) || defined(WIN32_THREADS) \\\n      || defined(IRIX_THREADS) || defined(LINUX_THREADS) \\\n+     || defined(IRIX_JDK_THREADS) || defined(HPUX_THREADS) \\\n      || defined(QUICK_THREADS)\n \n extern void GC_push_all_stacks();\n@@ -1478,12 +1664,12 @@ struct hblk *h;\n #   include <sys/syscall.h>\n \n #   define PROTECT(addr, len) \\\n-    \t  if (mprotect((caddr_t)(addr), (int)(len), \\\n+    \t  if (mprotect((caddr_t)(addr), (size_t)(len), \\\n     \t      \t       PROT_READ | OPT_PROT_EXEC) < 0) { \\\n     \t    ABORT(\"mprotect failed\"); \\\n     \t  }\n #   define UNPROTECT(addr, len) \\\n-    \t  if (mprotect((caddr_t)(addr), (int)(len), \\\n+    \t  if (mprotect((caddr_t)(addr), (size_t)(len), \\\n     \t  \t       PROT_WRITE | PROT_READ | OPT_PROT_EXEC ) < 0) { \\\n     \t    ABORT(\"un-mprotect failed\"); \\\n     \t  }\n@@ -1508,14 +1694,15 @@ struct hblk *h;\n \t  \n # endif\n \n-VOLATILE page_hash_table GC_dirty_pages;\n-\t\t\t\t/* Pages dirtied since last GC_read_dirty. */\n-\n #if defined(SUNOS4) || defined(FREEBSD)\n     typedef void (* SIG_PF)();\n #endif\n #if defined(SUNOS5SIGS) || defined(OSF1) || defined(LINUX)\n+# ifdef __STDC__\n     typedef void (* SIG_PF)(int);\n+# else\n+    typedef void (* SIG_PF)();\n+# endif\n #endif\n #if defined(MSWIN32)\n     typedef LPTOP_LEVEL_EXCEPTION_FILTER SIG_PF;\n@@ -1527,15 +1714,46 @@ VOLATILE page_hash_table GC_dirty_pages;\n     typedef void (* REAL_SIG_PF)(int, int, struct sigcontext *);\n #endif\n #if defined(SUNOS5SIGS)\n-    typedef void (* REAL_SIG_PF)(int, struct siginfo *, void *);\n+# ifdef HPUX\n+#   define SIGINFO __siginfo\n+# else\n+#   define SIGINFO siginfo\n+# endif\n+# ifdef __STDC__\n+    typedef void (* REAL_SIG_PF)(int, struct SIGINFO *, void *);\n+# else\n+    typedef void (* REAL_SIG_PF)();\n+# endif\n #endif\n #if defined(LINUX)\n #   include <linux/version.h>\n-#   if (LINUX_VERSION_CODE >= 0x20100)\n-      typedef void (* REAL_SIG_PF)(int, struct sigcontext);\n+#   if (LINUX_VERSION_CODE >= 0x20100) && !defined(M68K) || defined(ALPHA) || defined(IA64)\n+      typedef struct sigcontext s_c;\n+#   else\n+      typedef struct sigcontext_struct s_c;\n+#   endif\n+#   if defined(ALPHA) || defined(M68K)\n+      typedef void (* REAL_SIG_PF)(int, int, s_c *);\n #   else\n-      typedef void (* REAL_SIG_PF)(int, struct sigcontext_struct);\n+#     if defined(IA64)\n+        typedef void (* REAL_SIG_PF)(int, siginfo_t *, s_c *);\n+#     else\n+        typedef void (* REAL_SIG_PF)(int, s_c);\n+#     endif\n #   endif\n+#   ifdef ALPHA\n+    /* Retrieve fault address from sigcontext structure by decoding\t*/\n+    /* instruction.\t\t\t\t\t\t\t*/\n+    char * get_fault_addr(s_c *sc) {\n+        unsigned instr;\n+\tword faultaddr;\n+\n+\tinstr = *((unsigned *)(sc->sc_pc));\n+\tfaultaddr = sc->sc_regs[(instr >> 16) & 0x1f];\n+\tfaultaddr += (word) (((int)instr << 16) >> 16);\n+\treturn (char *)faultaddr;\n+    }\n+#   endif /* !ALPHA */\n # endif\n \n SIG_PF GC_old_bus_handler;\n@@ -1570,21 +1788,41 @@ SIG_PF GC_old_segv_handler;\t/* Also old MSWIN32 ACCESS_VIOLATION filter */\n #   endif\n # endif\n # if defined(LINUX)\n-#   if (LINUX_VERSION_CODE >= 0x20100)\n-      void GC_write_fault_handler(int sig, struct sigcontext sc)\n+#   if defined(ALPHA) || defined(M68K)\n+      void GC_write_fault_handler(int sig, int code, s_c * sc)\n #   else\n-      void GC_write_fault_handler(int sig, struct sigcontext_struct sc)\n+#     if defined(IA64)\n+        void GC_write_fault_handler(int sig, siginfo_t * si, s_c * scp)\n+#     else\n+        void GC_write_fault_handler(int sig, s_c sc)\n+#     endif\n #   endif\n #   define SIG_OK (sig == SIGSEGV)\n #   define CODE_OK TRUE\n-\t/* Empirically c.trapno == 14, but is that useful?      */\n-\t/* We assume Intel architecture, so alignment\t\t*/\n-\t/* faults are not possible.\t\t\t\t*/\n+\t/* Empirically c.trapno == 14, on IA32, but is that useful?     */\n+\t/* Should probably consider alignment issues on other \t\t*/\n+\t/* architectures.\t\t\t\t\t\t*/\n # endif\n # if defined(SUNOS5SIGS)\n-    void GC_write_fault_handler(int sig, struct siginfo *scp, void * context)\n-#   define SIG_OK (sig == SIGSEGV)\n-#   define CODE_OK (scp -> si_code == SEGV_ACCERR)\n+#  ifdef __STDC__\n+    void GC_write_fault_handler(int sig, struct SIGINFO *scp, void * context)\n+#  else\n+    void GC_write_fault_handler(sig, scp, context)\n+    int sig;\n+    struct SIGINFO *scp;\n+    void * context;\n+#  endif\n+#   ifdef HPUX\n+#     define SIG_OK (sig == SIGSEGV || sig == SIGBUS)\n+#     define CODE_OK (scp -> si_code == SEGV_ACCERR) \\\n+\t\t     || (scp -> si_code == BUS_ADRERR) \\\n+\t\t     || (scp -> si_code == BUS_UNKNOWN) \\\n+\t\t     || (scp -> si_code == SEGV_UNKNOWN) \\\n+\t\t     || (scp -> si_code == BUS_OBJERR)\n+#   else\n+#     define SIG_OK (sig == SIGSEGV)\n+#     define CODE_OK (scp -> si_code == SEGV_ACCERR)\n+#   endif\n # endif\n # if defined(MSWIN32)\n     LONG WINAPI GC_write_fault_handler(struct _EXCEPTION_POINTERS *exc_info)\n@@ -1608,7 +1846,45 @@ SIG_PF GC_old_segv_handler;\t/* Also old MSWIN32 ACCESS_VIOLATION filter */\n #     ifdef I386\n \tchar * addr = (char *) (sc.cr2);\n #     else\n-        char * addr = /* As of 1.3.90 there seemed to be no way to do this. */;\n+#\tif defined(M68K)\n+          char * addr = NULL;\n+\n+\t  struct sigcontext *scp = (struct sigcontext *)(&sc);\n+\n+\t  int format = (scp->sc_formatvec >> 12) & 0xf;\n+\t  unsigned long *framedata = (unsigned long *)(scp + 1); \n+\t  unsigned long ea;\n+\n+\t  if (format == 0xa || format == 0xb) {\n+\t  \t/* 68020/030 */\n+\t  \tea = framedata[2];\n+\t  } else if (format == 7) {\n+\t  \t/* 68040 */\n+\t  \tea = framedata[3];\n+\t  } else if (format == 4) {\n+\t  \t/* 68060 */\n+\t  \tea = framedata[0];\n+\t  \tif (framedata[1] & 0x08000000) {\n+\t  \t\t/* correct addr on misaligned access */\n+\t  \t\tea = (ea+4095)&(~4095);\n+\t  \t}\n+\t  }\t\n+\t  addr = (char *)ea;\n+#\telse\n+#\t  ifdef ALPHA\n+            char * addr = get_fault_addr(sc);\n+#\t  else\n+#\t    ifdef IA64\n+\t      char * addr = si -> si_addr;\n+#\t    else\n+#             if defined(POWERPC)\n+                char * addr = (char *) (sc.regs->dar);\n+#\t      else\n+\t\t--> architecture not supported\n+#\t      endif\n+#\t    endif\n+#\t  endif\n+#\tendif\n #     endif\n #   endif\n #   if defined(MSWIN32)\n@@ -1644,6 +1920,7 @@ SIG_PF GC_old_segv_handler;\t/* Also old MSWIN32 ACCESS_VIOLATION filter */\n             }\n             if (old_handler == SIG_DFL) {\n #\t\tifndef MSWIN32\n+\t\t    GC_err_printf1(\"Segfault at 0x%lx\\n\", addr);\n                     ABORT(\"Unexpected bus error or segmentation fault\");\n #\t\telse\n \t\t    return(EXCEPTION_CONTINUE_SEARCH);\n@@ -1658,7 +1935,15 @@ SIG_PF GC_old_segv_handler;\t/* Also old MSWIN32 ACCESS_VIOLATION filter */\n \t\t    return;\n #\t\tendif\n #\t\tif defined (LINUX)\n-\t\t    (*(REAL_SIG_PF)old_handler) (sig, sc);\n+#\t\t    if defined(ALPHA) || defined(M68K)\n+\t\t        (*(REAL_SIG_PF)old_handler) (sig, code, sc);\n+#\t\t    else \n+#\t\t      if defined(IA64)\n+\t\t        (*(REAL_SIG_PF)old_handler) (sig, si, scp);\n+#\t\t      else\n+\t\t        (*(REAL_SIG_PF)old_handler) (sig, sc);\n+#\t\t      endif\n+#\t\t    endif\n \t\t    return;\n #\t\tendif\n #\t\tif defined (IRIX5) || defined(OSF1)\n@@ -1691,6 +1976,7 @@ SIG_PF GC_old_segv_handler;\t/* Also old MSWIN32 ACCESS_VIOLATION filter */\n #ifdef MSWIN32\n     return EXCEPTION_CONTINUE_SEARCH;\n #else\n+    GC_err_printf1(\"Segfault at 0x%lx\\n\", addr);\n     ABORT(\"Unexpected bus error or segmentation fault\");\n #endif\n }\n@@ -1724,7 +2010,7 @@ struct hblk *h;\n \n void GC_dirty_init()\n {\n-#if defined(SUNOS5SIGS) || defined(IRIX5)\n+#if defined(SUNOS5SIGS) || defined(IRIX5) /* || defined(OSF1) */\n     struct sigaction\tact, oldact;\n #   ifdef IRIX5\n     \tact.sa_flags\t= SA_RESTART;\n@@ -1768,7 +2054,7 @@ void GC_dirty_init()\n       }\n #   endif\n #   if defined(SUNOS5SIGS) || defined(IRIX5)\n-#     ifdef IRIX_THREADS\n+#     if defined(IRIX_THREADS) || defined(IRIX_JDK_THREADS)\n       \tsigaction(SIGSEGV, 0, &oldact);\n       \tsigaction(SIGSEGV, &act, 0);\n #     else\n@@ -1794,6 +2080,15 @@ void GC_dirty_init()\n \t  GC_err_printf0(\"Replaced other SIGSEGV handler\\n\");\n #       endif\n       }\n+#     ifdef HPUX\n+      \t  sigaction(SIGBUS, &act, &oldact);\n+          GC_old_bus_handler = oldact.sa_handler;\n+          if (GC_old_segv_handler != SIG_DFL) {\n+#           ifdef PRINTSTATS\n+\t      GC_err_printf0(\"Replaced other SIGBUS handler\\n\");\n+#           endif\n+          }\n+#     endif\n #    endif\n #   if defined(MSWIN32)\n       GC_old_segv_handler = SetUnhandledExceptionFilter(GC_write_fault_handler);\n@@ -1969,8 +2264,6 @@ word n;\n word GC_proc_buf_size = INITIAL_BUF_SZ;\n char *GC_proc_buf;\n \n-page_hash_table GC_written_pages = { 0 };\t/* Pages ever dirtied\t*/\n-\n #ifdef SOLARIS_THREADS\n /* We don't have exact sp values for threads.  So we count on\t*/\n /* occasionally declaring stack pages to be fresh.  Thus we \t*/\n@@ -2261,14 +2554,18 @@ struct hblk *h;\n  * Call stack save code for debugging.\n  * Should probably be in mach_dep.c, but that requires reorganization.\n  */\n-#if defined(SPARC)\n+#if defined(SPARC) && !defined(LINUX)\n #   if defined(SUNOS4)\n #     include <machine/frame.h>\n #   else\n #     if defined (DRSNX)\n #\tinclude <sys/sparc/frame.h>\n #     else\n-#       include <sys/frame.h>\n+#        if defined(OPENBSD)\n+#          include <frame.h>\n+#        else\n+#          include <sys/frame.h>\n+#        endif\n #     endif\n #   endif\n #   if NARGS > 6\n@@ -2278,6 +2575,15 @@ struct hblk *h;\n #ifdef SAVE_CALL_CHAIN\n /* Fill in the pc and argument information for up to NFRAMES of my\t*/\n /* callers.  Ignore my frame and my callers frame.\t\t\t*/\n+\n+#ifdef OPENBSD\n+#  define FR_SAVFP fr_fp\n+#  define FR_SAVPC fr_pc\n+#else\n+#  define FR_SAVFP fr_savfp\n+#  define FR_SAVPC fr_savpc\n+#endif\n+\n void GC_save_callers (info) \n struct callinfo info[NFRAMES];\n {\n@@ -2288,11 +2594,11 @@ struct callinfo info[NFRAMES];\n \n   frame = (struct frame *) GC_save_regs_in_stack ();\n   \n-  for (fp = frame -> fr_savfp; fp != 0 && nframes < NFRAMES;\n-       fp = fp -> fr_savfp, nframes++) {\n+  for (fp = frame -> FR_SAVFP; fp != 0 && nframes < NFRAMES;\n+       fp = fp -> FR_SAVFP, nframes++) {\n       register int i;\n       \n-      info[nframes].ci_pc = fp->fr_savpc;\n+      info[nframes].ci_pc = fp->FR_SAVPC;\n       for (i = 0; i < NARGS; i++) {\n \tinfo[nframes].ci_arg[i] = ~(fp->fr_arg[i]);\n       }"}, {"sha": "6e0f53bb0589ab2dc82cd981800939146117bf2e", "filename": "boehm-gc/reclaim.c", "status": "modified", "additions": 235, "deletions": 59, "changes": 294, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20bbd3cd53a80ddafa56a5d21337aae0c24f94ca/boehm-gc%2Freclaim.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20bbd3cd53a80ddafa56a5d21337aae0c24f94ca/boehm-gc%2Freclaim.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Freclaim.c?ref=20bbd3cd53a80ddafa56a5d21337aae0c24f94ca", "patch": "@@ -1,6 +1,8 @@\n /* \n  * Copyright 1988, 1989 Hans-J. Boehm, Alan J. Demers\n- * Copyright (c) 1991-1994 by Xerox Corporation.  All rights reserved.\n+ * Copyright (c) 1991-1996 by Xerox Corporation.  All rights reserved.\n+ * Copyright (c) 1996-1999 by Silicon Graphics.  All rights reserved.\n+ * Copyright (c) 1999 by Hewlett-Packard Company. All rights reserved.\n  *\n  * THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED\n  * OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.\n@@ -11,15 +13,13 @@\n  * provided the above notices are retained, and a notice that the code was\n  * modified is included with the above copyright notice.\n  */\n-/* Boehm, February 15, 1996 2:41 pm PST */\n \n #include <stdio.h>\n #include \"gc_priv.h\"\n \n signed_word GC_mem_found = 0;\n \t\t\t/* Number of words of memory reclaimed     */\n \n-# ifdef FIND_LEAK\n static void report_leak(p, sz)\n ptr_t p;\n word sz;\n@@ -39,13 +39,10 @@ word sz;\n }\n \n #   define FOUND_FREE(hblk, word_no) \\\n-      if (abort_if_found) { \\\n+      { \\\n          report_leak((ptr_t)hblk + WORDS_TO_BYTES(word_no), \\\n          \t     HDR(hblk) -> hb_sz); \\\n       }\n-# else\n-#   define FOUND_FREE(hblk, word_no)\n-# endif\n \n /*\n  * reclaim phase\n@@ -71,6 +68,139 @@ register hdr * hhdr;\n     return(TRUE);\n }\n \n+/* The following functions sometimes return a DONT_KNOW value. */\n+#define DONT_KNOW  2\n+\n+#ifdef SMALL_CONFIG\n+# define GC_block_nearly_full1(hhdr, pat1) DONT_KNOW\n+# define GC_block_nearly_full3(hhdr, pat1, pat2) DONT_KNOW\n+# define GC_block_nearly_full(hhdr) DONT_KNOW\n+#else\n+\n+/*\n+ * Test whether nearly all of the mark words consist of the same\n+ * repeating pattern.\n+ */\n+#define FULL_THRESHOLD (MARK_BITS_SZ/16)\n+\n+GC_bool GC_block_nearly_full1(hhdr, pat1)\n+hdr *hhdr;\n+word pat1;\n+{\n+    unsigned i;\n+    unsigned misses = 0;\n+    GC_ASSERT((MARK_BITS_SZ & 1) == 0);\n+    for (i = 0; i < MARK_BITS_SZ; ++i) {\n+\tif ((hhdr -> hb_marks[i] | ~pat1) != ONES) {\n+\t    if (++misses > FULL_THRESHOLD) return FALSE;\n+\t}\n+    }\n+    return TRUE;\n+}\n+\n+/*\n+ * Test whether the same repeating 3 word pattern occurs in nearly\n+ * all the mark bit slots.\n+ * This is used as a heuristic, so we're a bit sloppy and ignore\n+ * the last one or two words.\n+ */\n+GC_bool GC_block_nearly_full3(hhdr, pat1, pat2, pat3)\n+hdr *hhdr;\n+word pat1, pat2, pat3;\n+{\n+    unsigned i;\n+    unsigned misses = 0;\n+\n+    if (MARK_BITS_SZ < 4) {\n+      return DONT_KNOW;\n+    }\n+    for (i = 0; i < MARK_BITS_SZ - 2; i += 3) {\n+\tif ((hhdr -> hb_marks[i] | ~pat1) != ONES) {\n+\t    if (++misses > FULL_THRESHOLD) return FALSE;\n+\t}\n+\tif ((hhdr -> hb_marks[i+1] | ~pat2) != ONES) {\n+\t    if (++misses > FULL_THRESHOLD) return FALSE;\n+\t}\n+\tif ((hhdr -> hb_marks[i+2] | ~pat3) != ONES) {\n+\t    if (++misses > FULL_THRESHOLD) return FALSE;\n+\t}\n+    }\n+    return TRUE;\n+}\n+\n+/* Check whether a small object block is nearly full by looking at only */\n+/* the mark bits.\t\t\t\t\t\t\t*/\n+/* We manually precomputed the mark bit patterns that need to be \t*/\n+/* checked for, and we give up on the ones that are unlikely to occur,\t*/\n+/* or have period > 3.\t\t\t\t\t\t\t*/\n+/* This would be a lot easier with a mark bit per object instead of per\t*/\n+/* word, but that would rewuire computing object numbers in the mark\t*/\n+/* loop, which would require different data structures ...\t\t*/\n+GC_bool GC_block_nearly_full(hhdr)\n+hdr *hhdr;\n+{\n+    int sz = hhdr -> hb_sz;\n+\n+#   if CPP_WORDSZ != 32 && CPP_WORDSZ != 64\n+      return DONT_KNOW;\t/* Shouldn't be used in any standard config.\t*/\n+#   endif\n+    if (0 != HDR_WORDS) return DONT_KNOW;\n+\t/* Also shouldn't happen */\n+#   if CPP_WORDSZ == 32\n+      switch(sz) {\n+        case 1:\n+\t  return GC_block_nearly_full1(hhdr, 0xffffffffl);\n+\tcase 2:\n+\t  return GC_block_nearly_full1(hhdr, 0x55555555l);\n+\tcase 4:\n+\t  return GC_block_nearly_full1(hhdr, 0x11111111l);\n+\tcase 6:\n+\t  return GC_block_nearly_full3(hhdr, 0x41041041l,\n+\t\t\t\t\t      0x10410410l,\n+\t\t\t\t\t       0x04104104l);\n+\tcase 8:\n+\t  return GC_block_nearly_full1(hhdr, 0x01010101l);\n+\tcase 12:\n+\t  return GC_block_nearly_full3(hhdr, 0x01001001l,\n+\t\t\t\t\t      0x10010010l,\n+\t\t\t\t\t       0x00100100l);\n+\tcase 16:\n+\t  return GC_block_nearly_full1(hhdr, 0x00010001l);\n+\tcase 32:\n+\t  return GC_block_nearly_full1(hhdr, 0x00000001l);\n+\tdefault:\n+\t  return DONT_KNOW;\n+      }\n+#   endif\n+#   if CPP_WORDSZ == 64\n+      switch(sz) {\n+        case 1:\n+\t  return GC_block_nearly_full1(hhdr, 0xffffffffffffffffl);\n+\tcase 2:\n+\t  return GC_block_nearly_full1(hhdr, 0x5555555555555555l);\n+\tcase 4:\n+\t  return GC_block_nearly_full1(hhdr, 0x1111111111111111l);\n+\tcase 6:\n+\t  return GC_block_nearly_full3(hhdr, 0x1041041041041041l,\n+\t\t\t\t\t       0x4104104104104104l,\n+\t\t\t\t\t         0x0410410410410410l);\n+\tcase 8:\n+\t  return GC_block_nearly_full1(hhdr, 0x0101010101010101l);\n+\tcase 12:\n+\t  return GC_block_nearly_full3(hhdr, 0x1001001001001001l,\n+\t\t\t\t\t       0x0100100100100100l,\n+\t\t\t\t\t         0x0010010010010010l);\n+\tcase 16:\n+\t  return GC_block_nearly_full1(hhdr, 0x0001000100010001l);\n+\tcase 32:\n+\t  return GC_block_nearly_full1(hhdr, 0x0000000100000001l);\n+\tdefault:\n+\t  return DONT_KNOW;\n+      }\n+#   endif\n+}\n+#endif /* !SMALL_CONFIG */\n+\n # ifdef GATHERSTATS\n #   define INCR_WORDS(sz) n_words_found += (sz)\n # else\n@@ -82,10 +212,9 @@ register hdr * hhdr;\n  * Clears unmarked objects.\n  */\n /*ARGSUSED*/\n-ptr_t GC_reclaim_clear(hbp, hhdr, sz, list, abort_if_found)\n+ptr_t GC_reclaim_clear(hbp, hhdr, sz, list)\n register struct hblk *hbp;\t/* ptr to current heap block\t\t*/\n register hdr * hhdr;\n-GC_bool abort_if_found;\t\t/* Abort if a reclaimable object is found */\n register ptr_t list;\n register word sz;\n {\n@@ -105,7 +234,6 @@ register word sz;\n \t    if( mark_bit_from_hdr(hhdr, word_no) ) {\n \t\tp += sz;\n \t    } else {\n-\t\tFOUND_FREE(hbp, word_no);\n \t\tINCR_WORDS(sz);\n \t\t/* object is available - put on list */\n \t\t    obj_link(p) = list;\n@@ -131,10 +259,9 @@ register word sz;\n  * A special case for 2 word composite objects (e.g. cons cells):\n  */\n /*ARGSUSED*/\n-ptr_t GC_reclaim_clear2(hbp, hhdr, list, abort_if_found)\n+ptr_t GC_reclaim_clear2(hbp, hhdr, list)\n register struct hblk *hbp;\t/* ptr to current heap block\t\t*/\n hdr * hhdr;\n-GC_bool abort_if_found;\t\t/* Abort if a reclaimable object is found */\n register ptr_t list;\n {\n     register word * mark_word_addr = &(hhdr->hb_marks[divWORDSZ(HDR_WORDS)]);\n@@ -146,7 +273,6 @@ register ptr_t list;\n     register int i;\n #   define DO_OBJ(start_displ) \\\n \tif (!(mark_word & ((word)1 << start_displ))) { \\\n-\t    FOUND_FREE(hbp, p - (word *)hbp + start_displ); \\\n \t    p[start_displ] = (word)list; \\\n \t    list = (ptr_t)(p+start_displ); \\\n \t    p[start_displ+1] = 0; \\\n@@ -179,10 +305,9 @@ register ptr_t list;\n  * Another special case for 4 word composite objects:\n  */\n /*ARGSUSED*/\n-ptr_t GC_reclaim_clear4(hbp, hhdr, list, abort_if_found)\n+ptr_t GC_reclaim_clear4(hbp, hhdr, list)\n register struct hblk *hbp;\t/* ptr to current heap block\t\t*/\n hdr * hhdr;\n-GC_bool abort_if_found;\t\t/* Abort if a reclaimable object is found */\n register ptr_t list;\n {\n     register word * mark_word_addr = &(hhdr->hb_marks[divWORDSZ(HDR_WORDS)]);\n@@ -193,7 +318,6 @@ register ptr_t list;\n     register word mark_word;\n #   define DO_OBJ(start_displ) \\\n \tif (!(mark_word & ((word)1 << start_displ))) { \\\n-\t    FOUND_FREE(hbp, p - (word *)hbp + start_displ); \\\n \t    p[start_displ] = (word)list; \\\n \t    list = (ptr_t)(p+start_displ); \\\n \t    p[start_displ+1] = 0; \\\n@@ -239,10 +363,9 @@ register ptr_t list;\n \n /* The same thing, but don't clear objects: */\n /*ARGSUSED*/\n-ptr_t GC_reclaim_uninit(hbp, hhdr, sz, list, abort_if_found)\n+ptr_t GC_reclaim_uninit(hbp, hhdr, sz, list)\n register struct hblk *hbp;\t/* ptr to current heap block\t\t*/\n register hdr * hhdr;\n-GC_bool abort_if_found;\t\t/* Abort if a reclaimable object is found */\n register ptr_t list;\n register word sz;\n {\n@@ -260,7 +383,6 @@ register word sz;\n     /* go through all words in block */\n \twhile( p <= plim )  {\n \t    if( !mark_bit_from_hdr(hhdr, word_no) ) {\n-\t\tFOUND_FREE(hbp, word_no);\n \t\tINCR_WORDS(sz);\n \t\t/* object is available - put on list */\n \t\t    obj_link(p) = list;\n@@ -275,15 +397,42 @@ register word sz;\n     return(list);\n }\n \n+/* Don't really reclaim objects, just check for unmarked ones: */\n+/*ARGSUSED*/\n+void GC_reclaim_check(hbp, hhdr, sz)\n+register struct hblk *hbp;\t/* ptr to current heap block\t\t*/\n+register hdr * hhdr;\n+register word sz;\n+{\n+    register int word_no;\n+    register word *p, *plim;\n+#   ifdef GATHERSTATS\n+        register int n_words_found = 0;\n+#   endif\n+    \n+    p = (word *)(hbp->hb_body);\n+    word_no = HDR_WORDS;\n+    plim = (word *)((((word)hbp) + HBLKSIZE)\n+\t\t   - WORDS_TO_BYTES(sz));\n+\n+    /* go through all words in block */\n+\twhile( p <= plim )  {\n+\t    if( !mark_bit_from_hdr(hhdr, word_no) ) {\n+\t\tFOUND_FREE(hbp, word_no);\n+\t    }\n+\t    p += sz;\n+\t    word_no += sz;\n+\t}\n+}\n+\n #ifndef SMALL_CONFIG\n /*\n  * Another special case for 2 word atomic objects:\n  */\n /*ARGSUSED*/\n-ptr_t GC_reclaim_uninit2(hbp, hhdr, list, abort_if_found)\n+ptr_t GC_reclaim_uninit2(hbp, hhdr, list)\n register struct hblk *hbp;\t/* ptr to current heap block\t\t*/\n hdr * hhdr;\n-GC_bool abort_if_found;\t\t/* Abort if a reclaimable object is found */\n register ptr_t list;\n {\n     register word * mark_word_addr = &(hhdr->hb_marks[divWORDSZ(HDR_WORDS)]);\n@@ -295,7 +444,6 @@ register ptr_t list;\n     register int i;\n #   define DO_OBJ(start_displ) \\\n \tif (!(mark_word & ((word)1 << start_displ))) { \\\n-\t    FOUND_FREE(hbp, p - (word *)hbp + start_displ); \\\n \t    p[start_displ] = (word)list; \\\n \t    list = (ptr_t)(p+start_displ); \\\n \t    INCR_WORDS(2); \\\n@@ -327,10 +475,9 @@ register ptr_t list;\n  * Another special case for 4 word atomic objects:\n  */\n /*ARGSUSED*/\n-ptr_t GC_reclaim_uninit4(hbp, hhdr, list, abort_if_found)\n+ptr_t GC_reclaim_uninit4(hbp, hhdr, list)\n register struct hblk *hbp;\t/* ptr to current heap block\t\t*/\n hdr * hhdr;\n-GC_bool abort_if_found;\t\t/* Abort if a reclaimable object is found */\n register ptr_t list;\n {\n     register word * mark_word_addr = &(hhdr->hb_marks[divWORDSZ(HDR_WORDS)]);\n@@ -341,7 +488,6 @@ register ptr_t list;\n     register word mark_word;\n #   define DO_OBJ(start_displ) \\\n \tif (!(mark_word & ((word)1 << start_displ))) { \\\n-\t    FOUND_FREE(hbp, p - (word *)hbp + start_displ); \\\n \t    p[start_displ] = (word)list; \\\n \t    list = (ptr_t)(p+start_displ); \\\n \t    INCR_WORDS(4); \\\n@@ -382,10 +528,9 @@ register ptr_t list;\n \n /* Finally the one word case, which never requires any clearing: */\n /*ARGSUSED*/\n-ptr_t GC_reclaim1(hbp, hhdr, list, abort_if_found)\n+ptr_t GC_reclaim1(hbp, hhdr, list)\n register struct hblk *hbp;\t/* ptr to current heap block\t\t*/\n hdr * hhdr;\n-GC_bool abort_if_found;\t\t/* Abort if a reclaimable object is found */\n register ptr_t list;\n {\n     register word * mark_word_addr = &(hhdr->hb_marks[divWORDSZ(HDR_WORDS)]);\n@@ -397,7 +542,6 @@ register ptr_t list;\n     register int i;\n #   define DO_OBJ(start_displ) \\\n \tif (!(mark_word & ((word)1 << start_displ))) { \\\n-\t    FOUND_FREE(hbp, p - (word *)hbp + start_displ); \\\n \t    p[start_displ] = (word)list; \\\n \t    list = (ptr_t)(p+start_displ); \\\n \t    INCR_WORDS(1); \\\n@@ -433,59 +577,87 @@ register ptr_t list;\n  * If entirely empty blocks are to be completely deallocated, then\n  * caller should perform that check.\n  */\n-void GC_reclaim_small_nonempty_block(hbp, abort_if_found)\n+void GC_reclaim_small_nonempty_block(hbp, report_if_found)\n register struct hblk *hbp;\t/* ptr to current heap block\t\t*/\n-int abort_if_found;\t\t/* Abort if a reclaimable object is found */\n+int report_if_found;\t\t/* Abort if a reclaimable object is found */\n {\n     hdr * hhdr;\n-    register word sz;\t\t/* size of objects in current block\t*/\n-    register struct obj_kind * ok;\n-    register ptr_t * flh;\n-    register int kind;\n+    word sz;\t\t/* size of objects in current block\t*/\n+    struct obj_kind * ok;\n+    ptr_t * flh;\n+    int kind;\n+    GC_bool full;\n     \n     hhdr = HDR(hbp);\n     sz = hhdr -> hb_sz;\n     hhdr -> hb_last_reclaimed = (unsigned short) GC_gc_no;\n     kind = hhdr -> hb_obj_kind;\n     ok = &GC_obj_kinds[kind];\n     flh = &(ok -> ok_freelist[sz]);\n-    GC_write_hint(hbp);\n \n-    if (ok -> ok_init) {\n+    if (report_if_found) {\n+\tGC_reclaim_check(hbp, hhdr, sz);\n+    } else if (ok -> ok_init) {\n       switch(sz) {\n #      ifndef SMALL_CONFIG\n         case 1:\n-            *flh = GC_reclaim1(hbp, hhdr, *flh, abort_if_found);\n+\t    full = GC_block_nearly_full1(hhdr, 0xffffffffl);\n+\t    if (TRUE == full) goto out;\n+\t    if (FALSE == full) GC_write_hint(hbp);\n+\t    /* In the DONT_KNOW case, we let reclaim fault.\t*/\n+            *flh = GC_reclaim1(hbp, hhdr, *flh);\n             break;\n         case 2:\n-            *flh = GC_reclaim_clear2(hbp, hhdr, *flh, abort_if_found);\n+\t    full = GC_block_nearly_full1(hhdr, 0x55555555l);\n+\t    if (TRUE == full) goto out;\n+\t    if (FALSE == full) GC_write_hint(hbp);\n+            *flh = GC_reclaim_clear2(hbp, hhdr, *flh);\n             break;\n         case 4:\n-            *flh = GC_reclaim_clear4(hbp, hhdr, *flh, abort_if_found);\n+\t    full = GC_block_nearly_full1(hhdr, 0x11111111l);\n+\t    if (TRUE == full) goto out;\n+\t    if (FALSE == full) GC_write_hint(hbp);\n+            *flh = GC_reclaim_clear4(hbp, hhdr, *flh);\n             break;\n #      endif\n         default:\n-            *flh = GC_reclaim_clear(hbp, hhdr, sz, *flh, abort_if_found);\n+\t    full = GC_block_nearly_full(hhdr);\n+\t    if (TRUE == full) goto out;\n+\t    if (FALSE == full) GC_write_hint(hbp);\n+            *flh = GC_reclaim_clear(hbp, hhdr, sz, *flh);\n             break;\n       }\n     } else {\n       switch(sz) {\n #      ifndef SMALL_CONFIG\n         case 1:\n-            *flh = GC_reclaim1(hbp, hhdr, *flh, abort_if_found);\n+\t    full = GC_block_nearly_full1(hhdr, 0xffffffffl);\n+\t    if (TRUE == full) goto out;\n+\t    if (FALSE == full) GC_write_hint(hbp);\n+            *flh = GC_reclaim1(hbp, hhdr, *flh);\n             break;\n         case 2:\n-            *flh = GC_reclaim_uninit2(hbp, hhdr, *flh, abort_if_found);\n+\t    full = GC_block_nearly_full1(hhdr, 0x55555555l);\n+\t    if (TRUE == full) goto out;\n+\t    if (FALSE == full) GC_write_hint(hbp);\n+            *flh = GC_reclaim_uninit2(hbp, hhdr, *flh);\n             break;\n         case 4:\n-            *flh = GC_reclaim_uninit4(hbp, hhdr, *flh, abort_if_found);\n+\t    full = GC_block_nearly_full1(hhdr, 0x11111111l);\n+\t    if (TRUE == full) goto out;\n+\t    if (FALSE == full) GC_write_hint(hbp);\n+            *flh = GC_reclaim_uninit4(hbp, hhdr, *flh);\n             break;\n #      endif\n         default:\n-            *flh = GC_reclaim_uninit(hbp, hhdr, sz, *flh, abort_if_found);\n+\t    full = GC_block_nearly_full(hhdr);\n+\t    if (TRUE == full) goto out;\n+\t    if (FALSE == full) GC_write_hint(hbp);\n+            *flh = GC_reclaim_uninit(hbp, hhdr, sz, *flh);\n             break;\n       }\n     } \n+out:\n     if (IS_UNCOLLECTABLE(kind)) GC_set_hdr_marks(hhdr);\n }\n \n@@ -494,11 +666,12 @@ int abort_if_found;\t\t/* Abort if a reclaimable object is found */\n  * to the heap block free list.\n  * Otherwise enqueue the block for later processing\n  * by GC_reclaim_small_nonempty_block.\n- * If abort_if_found is TRUE, then process any block immediately.\n+ * If report_if_found is TRUE, then process any block immediately, and\n+ * simply report free objects; do not actually reclaim them.\n  */\n-void GC_reclaim_block(hbp, abort_if_found)\n+void GC_reclaim_block(hbp, report_if_found)\n register struct hblk *hbp;\t/* ptr to current heap block\t\t*/\n-word abort_if_found;\t\t/* Abort if a reclaimable object is found */\n+word report_if_found;\t\t/* Abort if a reclaimable object is found */\n {\n     register hdr * hhdr;\n     register word sz;\t\t/* size of objects in current block\t*/\n@@ -511,16 +684,19 @@ word abort_if_found;\t\t/* Abort if a reclaimable object is found */\n \n     if( sz > MAXOBJSZ ) {  /* 1 big object */\n         if( !mark_bit_from_hdr(hhdr, HDR_WORDS) ) {\n-\t    FOUND_FREE(hbp, HDR_WORDS);\n-#\t    ifdef GATHERSTATS\n+\t    if (report_if_found) {\n+\t      FOUND_FREE(hbp, HDR_WORDS);\n+\t    } else {\n+#\t      ifdef GATHERSTATS\n \t        GC_mem_found += sz;\n-#\t    endif\n-\t    GC_freehblk(hbp);\n+#\t      endif\n+\t      GC_freehblk(hbp);\n+\t    }\n \t}\n     } else {\n         GC_bool empty = GC_block_empty(hhdr);\n-        if (abort_if_found) {\n-    \t  GC_reclaim_small_nonempty_block(hbp, (int)abort_if_found);\n+        if (report_if_found) {\n+    \t  GC_reclaim_small_nonempty_block(hbp, (int)report_if_found);\n         } else if (empty) {\n #\t  ifdef GATHERSTATS\n             GC_mem_found += BYTES_TO_WORDS(HBLKSIZE);\n@@ -600,11 +776,11 @@ void GC_print_block_list()\n #endif /* NO_DEBUGGING */\n \n /*\n- * Do the same thing on the entire heap, after first clearing small object\n- * free lists (if we are not just looking for leaks).\n+ * Perform GC_reclaim_block on the entire heap, after first clearing\n+ * small object free lists (if we are not just looking for leaks).\n  */\n-void GC_start_reclaim(abort_if_found)\n-int abort_if_found;\t\t/* Abort if a GC_reclaimable object is found */\n+void GC_start_reclaim(report_if_found)\n+int report_if_found;\t\t/* Abort if a GC_reclaimable object is found */\n {\n     int kind;\n     \n@@ -617,7 +793,7 @@ int abort_if_found;\t\t/* Abort if a GC_reclaimable object is found */\n         register struct hblk ** rlist = GC_obj_kinds[kind].ok_reclaim_list;\n         \n         if (rlist == 0) continue;\t/* This kind not used.\t*/\n-        if (!abort_if_found) {\n+        if (!report_if_found) {\n             lim = &(GC_obj_kinds[kind].ok_freelist[MAXOBJSZ+1]);\n \t    for( fop = GC_obj_kinds[kind].ok_freelist; fop < lim; fop++ ) {\n \t      *fop = 0;\n@@ -637,7 +813,7 @@ int abort_if_found;\t\t/* Abort if a GC_reclaimable object is found */\n \n   /* Go through all heap blocks (in hblklist) and reclaim unmarked objects */\n   /* or enqueue the block for later processing.\t\t\t\t   */\n-    GC_apply_to_all_blocks(GC_reclaim_block, (word)abort_if_found);\n+    GC_apply_to_all_blocks(GC_reclaim_block, (word)report_if_found);\n     \n }\n "}, {"sha": "1c9253e98a663a8f31073cc170a419cbc8c7de98", "filename": "boehm-gc/setjmp_t.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20bbd3cd53a80ddafa56a5d21337aae0c24f94ca/boehm-gc%2Fsetjmp_t.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20bbd3cd53a80ddafa56a5d21337aae0c24f94ca/boehm-gc%2Fsetjmp_t.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fsetjmp_t.c?ref=20bbd3cd53a80ddafa56a5d21337aae0c24f94ca", "patch": "@@ -25,7 +25,7 @@\n #include <stdio.h>\n #include <setjmp.h>\n #include <string.h>\n-#include \"config.h\"\n+#include \"gcconfig.h\"\n \n #ifdef OS2\n /* GETPAGESIZE() is set to getpagesize() by default, but that\t*/"}, {"sha": "65b2c6517b179da2d918d4de888317f2a0c8d6d9", "filename": "boehm-gc/solaris_threads.c", "status": "modified", "additions": 21, "deletions": 6, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20bbd3cd53a80ddafa56a5d21337aae0c24f94ca/boehm-gc%2Fsolaris_threads.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20bbd3cd53a80ddafa56a5d21337aae0c24f94ca/boehm-gc%2Fsolaris_threads.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fsolaris_threads.c?ref=20bbd3cd53a80ddafa56a5d21337aae0c24f94ca", "patch": "@@ -616,6 +616,25 @@ GC_thread GC_lookup_thread(thread_t id)\n     return(p);\n }\n \n+# define MAX_ORIG_STACK_SIZE (8 * 1024 * 1024)\n+\n+word GC_get_orig_stack_size() {\n+    struct rlimit rl;\n+    static int warned = 0;\n+    int result;\n+\n+    if (getrlimit(RLIMIT_STACK, &rl) != 0) ABORT(\"getrlimit failed\");\n+    result = (word)rl.rlim_cur & ~(HBLKSIZE-1);\n+    if (result > MAX_ORIG_STACK_SIZE) {\n+\tif (!warned) {\n+\t    WARN(\"Large stack limit(%ld): only scanning 8 MB\", result);\n+\t    warned = 1;\n+\t}\n+\tresult = MAX_ORIG_STACK_SIZE;\n+    }\n+    return result;\n+}\n+\n /* Notify dirty bit implementation of unused parts of my stack. */\n /* Caller holds allocation lock.\t\t\t\t*/\n void GC_my_stack_limits()\n@@ -628,12 +647,9 @@ void GC_my_stack_limits()\n     \n     if (stack_size == 0) {\n       /* original thread */\n-        struct rlimit rl;\n-         \n-        if (getrlimit(RLIMIT_STACK, &rl) != 0) ABORT(\"getrlimit failed\");\n         /* Empirically, what should be the stack page with lowest\t*/\n         /* address is actually inaccessible.\t\t\t\t*/\n-        stack_size = ((word)rl.rlim_cur & ~(HBLKSIZE-1)) - GC_page_sz;\n+        stack_size = GC_get_orig_stack_size() - GC_page_sz;\n         stack = GC_stackbottom - stack_size + GC_page_sz;\n     } else {\n         stack = me -> stack;\n@@ -671,8 +687,7 @@ void GC_push_all_stacks()\n             top = p -> stack + p -> stack_size;\n         } else {\n             /* The original stack. */\n-            if (getrlimit(RLIMIT_STACK, &rl) != 0) ABORT(\"getrlimit failed\");\n-            bottom = GC_stackbottom - rl.rlim_cur + GC_page_sz;\n+            bottom = GC_stackbottom - GC_get_orig_stack_size() + GC_page_sz;\n             top = GC_stackbottom;\n         }\n         if ((word)sp > (word)bottom && (word)sp < (word)top) bottom = sp;"}, {"sha": "9831c6ca4028c038a1c2784304c4a3680db4e79f", "filename": "boehm-gc/sparc_mach_dep.s", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20bbd3cd53a80ddafa56a5d21337aae0c24f94ca/boehm-gc%2Fsparc_mach_dep.s", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20bbd3cd53a80ddafa56a5d21337aae0c24f94ca/boehm-gc%2Fsparc_mach_dep.s", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fsparc_mach_dep.s?ref=20bbd3cd53a80ddafa56a5d21337aae0c24f94ca", "patch": "@@ -1,4 +1,4 @@\n-!\tSPARCompiler 3.0 and later apparently no loner handles\n+!\tSPARCompiler 3.0 and later apparently no longer handles\n !\tasm outside functions.  So we need a separate .s file\n !\tThis is only set up for SunOS 5, not SunOS 4.\n !\tAssumes this is called before the stack contents are\n@@ -35,4 +35,4 @@ loop:\n \t\t\n \t\t\n \t\t\n-\t\n\\ No newline at end of file\n+\t"}, {"sha": "41858073ef9b051f7b5dde16540053368b2ba3e0", "filename": "boehm-gc/sparc_sunos4_mach_dep.s", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20bbd3cd53a80ddafa56a5d21337aae0c24f94ca/boehm-gc%2Fsparc_sunos4_mach_dep.s", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20bbd3cd53a80ddafa56a5d21337aae0c24f94ca/boehm-gc%2Fsparc_sunos4_mach_dep.s", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fsparc_sunos4_mach_dep.s?ref=20bbd3cd53a80ddafa56a5d21337aae0c24f94ca", "patch": "@@ -1,4 +1,4 @@\n-!\tSPARCompiler 3.0 and later apparently no loner handles\n+!\tSPARCompiler 3.0 and later apparently no longer handles\n !\tasm outside functions.  So we need a separate .s file\n !\tThis is only set up for SunOS 4.\n !\tAssumes this is called before the stack contents are"}, {"sha": "43b09010f8017ac7abc27ccb8a84de6a4776ce79", "filename": "boehm-gc/test.c", "status": "modified", "additions": 138, "deletions": 25, "changes": 163, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20bbd3cd53a80ddafa56a5d21337aae0c24f94ca/boehm-gc%2Ftest.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20bbd3cd53a80ddafa56a5d21337aae0c24f94ca/boehm-gc%2Ftest.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Ftest.c?ref=20bbd3cd53a80ddafa56a5d21337aae0c24f94ca", "patch": "@@ -25,7 +25,7 @@\n # include \"gc.h\"\n # include \"gc_typed.h\"\n # include \"gc_priv.h\"\t/* For output, locking,  and some statistics\t*/\n-# include \"config.h\"\n+# include \"gcconfig.h\"\n \n # ifdef MSWIN32\n #   include <windows.h>\n@@ -45,17 +45,14 @@\n #   include <synch.h>\n # endif\n \n-# if defined(IRIX_THREADS) || defined(LINUX_THREADS)\n+# if defined(IRIX_THREADS) || defined(LINUX_THREADS) || defined(HPUX_THREADS)\n #   include <pthread.h>\n # endif\n \n # ifdef WIN32_THREADS\n #   include <process.h>\n     static CRITICAL_SECTION incr_cs;\n # endif\n-# if defined(PCR) || defined(SOLARIS_THREADS) || defined(WIN32_THREADS)\n-#   define THREADS\n-# endif\n \n # ifdef AMIGA\n    long __stack = 200000;\n@@ -265,6 +262,72 @@ struct {\n } A;\n #define a A.aa\n \n+/*\n+ * A tiny list reversal test to check thread creation.\n+ */\n+#ifdef THREADS\n+\n+# ifdef WIN32_THREADS\n+    unsigned __stdcall tiny_reverse_test(void * arg)\n+# else\n+    void * tiny_reverse_test(void * arg)\n+# endif\n+{\n+    check_ints(reverse(reverse(ints(1,10))), 1, 10);\n+    return 0;\n+}\n+\n+# if defined(IRIX_THREADS) || defined(LINUX_THREADS) \\\n+     || defined(SOLARIS_PTHREADS) || defined(HPUX_THREADS)\n+    void fork_a_thread()\n+    {\n+      pthread_t t;\n+      int code;\n+      if ((code = pthread_create(&t, 0, tiny_reverse_test, 0)) != 0) {\n+    \t(void)GC_printf1(\"Small thread creation failed %lu\\n\",\n+\t\t         (unsigned long)code);\n+    \tFAIL;\n+      }\n+      if ((code = pthread_join(t, 0)) != 0) {\n+        (void)GC_printf1(\"Small thread join failed %lu\\n\",\n+\t(unsigned long)code);\n+        FAIL;\n+      }\n+    }\n+\n+# elif defined(WIN32_THREADS)\n+    void fork_a_thread()\n+    {\n+  \tunsigned thread_id;\n+\tHANDLE h;\n+    \th = (HANDLE)_beginthreadex(NULL, 0, tiny_reverse_test,\n+\t\t\t\t   0, 0, &thread_id);\n+        if (h == (HANDLE)-1) {\n+            (void)GC_printf1(\"Small thread creation failed %lu\\n\",\n+\t\t\t     (unsigned long)GetLastError());\n+      \t    FAIL;\n+        }\n+    \tif (WaitForSingleObject(h, INFINITE) != WAIT_OBJECT_0) {\n+      \t    (void)GC_printf1(\"Small thread wait failed %lu\\n\",\n+\t\t\t     (unsigned long)GetLastError());\n+      \t    FAIL;\n+    \t}\n+    }\n+\n+/* # elif defined(SOLARIS_THREADS) */\n+\n+# else\n+\n+#   define fork_a_thread()\n+\n+# endif\n+\n+#else\n+\n+# define fork_a_thread()\n+\n+#endif \n+\n /*\n  * Repeatedly reverse lists built out of very different sized cons cells.\n  * Check that we didn't lose anything.\n@@ -296,14 +359,14 @@ void reverse_test()\n     d = uncollectable_ints(1, 100);\n     e = uncollectable_ints(1, 1);\n     /* Check that realloc updates object descriptors correctly */\n-    f = (sexpr *)GC_malloc(4 * sizeof(sexpr));\n-    f = (sexpr *)GC_realloc((GC_PTR)f, 6 * sizeof(sexpr));\n+    f = (sexpr *)GC_MALLOC(4 * sizeof(sexpr));\n+    f = (sexpr *)GC_REALLOC((GC_PTR)f, 6 * sizeof(sexpr));\n     f[5] = ints(1,17);\n-    g = (sexpr *)GC_malloc(513 * sizeof(sexpr));\n-    g = (sexpr *)GC_realloc((GC_PTR)g, 800 * sizeof(sexpr));\n+    g = (sexpr *)GC_MALLOC(513 * sizeof(sexpr));\n+    g = (sexpr *)GC_REALLOC((GC_PTR)g, 800 * sizeof(sexpr));\n     g[799] = ints(1,18);\n-    h = (sexpr *)GC_malloc(1025 * sizeof(sexpr));\n-    h = (sexpr *)GC_realloc((GC_PTR)h, 2000 * sizeof(sexpr));\n+    h = (sexpr *)GC_MALLOC(1025 * sizeof(sexpr));\n+    h = (sexpr *)GC_REALLOC((GC_PTR)h, 2000 * sizeof(sexpr));\n     h[1999] = ints(1,19);\n     /* Try to force some collections and reuse of small list elements */\n       for (i = 0; i < 10; i++) {\n@@ -327,6 +390,7 @@ void reverse_test()\n     check_ints(b,1,50);\n     check_ints(a,1,49);\n     for (i = 0; i < 60; i++) {\n+\tif (i % 10 == 0) fork_a_thread();\n     \t/* This maintains the invariant that a always points to a list of */\n     \t/* 49 integers.  Thus this is thread safe without locks,\t  */\n     \t/* assuming atomic pointer assignments.\t\t\t\t  */\n@@ -386,7 +450,7 @@ VOLATILE int dropped_something = 0;\n     static mutex_t incr_lock;\n     mutex_lock(&incr_lock);\n # endif\n-# if  defined(IRIX_THREADS) || defined(LINUX_THREADS)\n+# if  defined(IRIX_THREADS) || defined(LINUX_THREADS) || defined(HPUX_THREADS)\n     static pthread_mutex_t incr_lock = PTHREAD_MUTEX_INITIALIZER;\n     pthread_mutex_lock(&incr_lock);\n # endif\n@@ -404,7 +468,7 @@ VOLATILE int dropped_something = 0;\n # ifdef SOLARIS_THREADS\n     mutex_unlock(&incr_lock);\n # endif\n-# if defined(IRIX_THREADS) || defined(LINUX_THREADS)\n+# if defined(IRIX_THREADS) || defined(LINUX_THREADS) || defined(HPUX_THREADS)\n     pthread_mutex_unlock(&incr_lock);\n # endif\n # ifdef WIN32_THREADS\n@@ -465,7 +529,8 @@ int n;\n \t    static mutex_t incr_lock;\n \t    mutex_lock(&incr_lock);\n #\t  endif\n-#         if defined(IRIX_THREADS) || defined(LINUX_THREADS)\n+#         if defined(IRIX_THREADS) || defined(LINUX_THREADS) \\\n+\t     || defined(HPUX_THREADS)\n             static pthread_mutex_t incr_lock = PTHREAD_MUTEX_INITIALIZER;\n             pthread_mutex_lock(&incr_lock);\n #         endif\n@@ -481,7 +546,8 @@ int n;\n #\t  ifdef SOLARIS_THREADS\n \t    mutex_unlock(&incr_lock);\n #\t  endif\n-#\t  if defined(IRIX_THREADS) || defined(LINUX_THREADS)\n+#\t  if defined(IRIX_THREADS) || defined(LINUX_THREADS) \\\n+\t     || defined(HPUX_THREADS)\n \t    pthread_mutex_unlock(&incr_lock);\n #\t  endif\n #         ifdef WIN32_THREADS\n@@ -538,13 +604,13 @@ int n;\n     chktree(t -> rchild, n-1);\n }\n \n-# ifdef SOLARIS_THREADS\n+# if defined(SOLARIS_THREADS) && !defined(_SOLARIS_PTHREADS)\n thread_key_t fl_key;\n \n void * alloc8bytes()\n {\n-# ifdef SMALL_CONFIG\n-    return(GC_malloc(8));\n+# if defined(SMALL_CONFIG) || defined(GC_DEBUG)\n+    return(GC_MALLOC(8));\n # else\n     void ** my_free_list_ptr;\n     void * my_free_list;\n@@ -575,7 +641,44 @@ void * alloc8bytes()\n }\n \n #else\n-# define alloc8bytes() GC_MALLOC_ATOMIC(8)\n+\n+# if defined(_SOLARIS_PTHREADS) || defined(IRIX_THREADS) \\\n+     || defined(LINUX_THREADS) || defined(HPUX_THREADS)\n+pthread_key_t fl_key;\n+\n+void * alloc8bytes()\n+{\n+# ifdef SMALL_CONFIG\n+    return(GC_malloc(8));\n+# else\n+    void ** my_free_list_ptr;\n+    void * my_free_list;\n+    \n+    my_free_list_ptr = (void **)pthread_getspecific(fl_key);\n+    if (my_free_list_ptr == 0) {\n+        my_free_list_ptr = GC_NEW_UNCOLLECTABLE(void *);\n+        if (pthread_setspecific(fl_key, my_free_list_ptr) != 0) {\n+    \t    (void)GC_printf0(\"pthread_setspecific failed\\n\");\n+    \t    FAIL;\n+        }\n+    }\n+    my_free_list = *my_free_list_ptr;\n+    if (my_free_list == 0) {\n+        my_free_list = GC_malloc_many(8);\n+        if (my_free_list == 0) {\n+            (void)GC_printf0(\"alloc8bytes out of memory\\n\");\n+    \t    FAIL;\n+        }\n+    }\n+    *my_free_list_ptr = GC_NEXT(my_free_list);\n+    GC_NEXT(my_free_list) = 0;\n+    return(my_free_list);\n+# endif\n+}\n+\n+# else\n+#   define alloc8bytes() GC_MALLOC_ATOMIC(8)\n+# endif\n #endif\n \n void alloc_small(n)\n@@ -753,6 +856,7 @@ void run_one_test()\n     \t(void)GC_printf0(\"GC_malloc_uncollectable(0) failed\\n\");\n \t    FAIL;\n     }\n+    GC_FREE(0);\n     GC_is_valid_displacement_print_proc = fail_proc1;\n     GC_is_visible_print_proc = fail_proc1;\n     x = GC_malloc(16);\n@@ -775,7 +879,7 @@ void run_one_test()\n \tFAIL;\n     }\n     if (!TEST_FAIL_COUNT(1)) {\n-#\tif!(defined(RS6000) || defined(POWERPC))\n+#\tif!(defined(RS6000) || defined(POWERPC) || defined(IA64))\n \t  /* ON RS6000s function pointers point to a descriptor in the\t*/\n \t  /* data segment, so there should have been no failures.\t*/\n     \t  (void)GC_printf0(\"GC_is_visible produced wrong failure indication\\n\");\n@@ -826,7 +930,7 @@ void check_heap_stats()\n     int late_finalize_count = 0;\n     \n     if (sizeof(char *) > 4) {\n-        max_heap_sz = 13000000;\n+        max_heap_sz = 15000000;\n     } else {\n     \tmax_heap_sz = 11000000;\n     }\n@@ -926,7 +1030,8 @@ void SetMinimumStack(long minSize)\n \n \n #if !defined(PCR) && !defined(SOLARIS_THREADS) && !defined(WIN32_THREADS) \\\n-  && !defined(IRIX_THREADS) && !defined(LINUX_THREADS) || defined(LINT)\n+  && !defined(IRIX_THREADS) && !defined(LINUX_THREADS) \\\n+  && !defined(HPUX_THREADS) || defined(LINT)\n #ifdef MSWIN32\n   int APIENTRY WinMain(HINSTANCE instance, HINSTANCE prev, LPSTR cmd, int n)\n #else\n@@ -979,6 +1084,9 @@ void SetMinimumStack(long minSize)\n \t\tGC_malloc_ignore_off_page, GC_malloc_atomic_ignore_off_page,\n \t\tGC_set_max_heap_size, GC_get_bytes_since_gc,\n \t\tGC_pre_incr, GC_post_incr);\n+#   endif\n+#   ifdef MSWIN32\n+      GC_win32_free_heap();\n #   endif\n     return(0);\n }\n@@ -1054,7 +1162,8 @@ test()\n }\n #endif\n \n-#if defined(SOLARIS_THREADS) || defined(IRIX_THREADS) || defined(LINUX_THREADS)\n+#if defined(SOLARIS_THREADS) || defined(IRIX_THREADS) \\\n+ || defined(HPUX_THREADS) || defined(LINUX_THREADS)\n void * thr_run_one_test(void * arg)\n {\n     run_one_test();\n@@ -1115,7 +1224,7 @@ main()\n \t*((volatile char *)&code - 1024*1024) = 0;      /* Require 1 Mb */\n #   endif /* IRIX_THREADS */\n     pthread_attr_init(&attr);\n-#   ifdef IRIX_THREADS\n+#   if defined(IRIX_THREADS) || defined(HPUX_THREADS)\n     \tpthread_attr_setstacksize(&attr, 1000000);\n #   endif\n     n_tests = 0;\n@@ -1125,6 +1234,10 @@ main()\n \t(void) GC_printf0(\"Emulating dirty bits with mprotect/signals\\n\");\n #   endif\n     (void) GC_set_warn_proc(warn_proc);\n+    if ((code = pthread_key_create(&fl_key, 0)) != 0) {\n+        (void)GC_printf1(\"Key creation failed %lu\\n\", (unsigned long)code);\n+    \tFAIL;\n+    }\n     if ((code = pthread_create(&th1, &attr, thr_run_one_test, 0)) != 0) {\n     \t(void)GC_printf1(\"Thread 1 creation failed %lu\\n\", (unsigned long)code);\n     \tFAIL;\n@@ -1149,4 +1262,4 @@ main()\n     return(0);\n }\n #endif /* pthreads */\n-#endif /* SOLARIS_THREADS || IRIX_THREADS || LINUX_THREADS */\n+#endif /* SOLARIS_THREADS || IRIX_THREADS || LINUX_THREADS || HPUX_THREADS */"}, {"sha": "df4eb77bb1da64abd258061985371e7ba44227c8", "filename": "boehm-gc/threadlibs.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20bbd3cd53a80ddafa56a5d21337aae0c24f94ca/boehm-gc%2Fthreadlibs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20bbd3cd53a80ddafa56a5d21337aae0c24f94ca/boehm-gc%2Fthreadlibs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fthreadlibs.c?ref=20bbd3cd53a80ddafa56a5d21337aae0c24f94ca", "patch": "@@ -1,11 +1,14 @@\n-# include \"config.h\"\n+# include \"gcconfig.h\"\n # include <stdio.h>\n \n int main()\n {\n #   if defined(IRIX_THREADS) || defined(LINUX_THREADS)\n \tprintf(\"-lpthread\\n\");\n #   endif\n+#   if defined(HPUX_THREADS)\n+\tprintf(\"-lpthread -lrt\\n\");\n+#   endif\n #   ifdef SOLARIS_THREADS\n         printf(\"-lthread -ldl\\n\");\n #   endif"}, {"sha": "74f455d926cc6619e084ff05f2338fd8ffa18af6", "filename": "boehm-gc/typd_mlc.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20bbd3cd53a80ddafa56a5d21337aae0c24f94ca/boehm-gc%2Ftypd_mlc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20bbd3cd53a80ddafa56a5d21337aae0c24f94ca/boehm-gc%2Ftypd_mlc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Ftypd_mlc.c?ref=20bbd3cd53a80ddafa56a5d21337aae0c24f94ca", "patch": "@@ -632,7 +632,7 @@ ptr_t GC_clear_stack();\n     (GC_PTR)GC_clear_stack(GC_generic_malloc((word)lb, k))\n     \n #define GENERAL_MALLOC_IOP(lb,k) \\\n-    (GC_PTR)GC_clear_stack(GC_generic_malloc_ignore_off_page((word)lb, k))\n+    (GC_PTR)GC_clear_stack(GC_generic_malloc_ignore_off_page(lb, k))\n \n #if defined(__STDC__) || defined(__cplusplus)\n   void * GC_malloc_explicitly_typed(size_t lb, GC_descr d)\n@@ -702,7 +702,7 @@ DCL_LOCK_STATE;\n \tFASTLOCK();\n         if( !FASTLOCK_SUCCEEDED() || (op = *opp) == 0 ) {\n             FASTUNLOCK();\n-            op = (ptr_t)GENERAL_MALLOC_IOP((word)lb, GC_explicit_kind);\n+            op = (ptr_t)GENERAL_MALLOC_IOP(lb, GC_explicit_kind);\n #\t    ifdef MERGE_SIZES\n \t\tlw = GC_size_map[lb];\t/* May have been uninitialized.\t*/            \n #\t    endif\n@@ -712,7 +712,7 @@ DCL_LOCK_STATE;\n             FASTUNLOCK();\n         }\n    } else {\n-       op = (ptr_t)GENERAL_MALLOC_IOP((word)lb, GC_explicit_kind);\n+       op = (ptr_t)GENERAL_MALLOC_IOP(lb, GC_explicit_kind);\n        if (op != NULL)\n        lw = BYTES_TO_WORDS(GC_size(op));\n    }"}, {"sha": "df0770c9b04c534d5626a65abcd66a1b1b368940", "filename": "boehm-gc/version.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20bbd3cd53a80ddafa56a5d21337aae0c24f94ca/boehm-gc%2Fversion.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20bbd3cd53a80ddafa56a5d21337aae0c24f94ca/boehm-gc%2Fversion.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fversion.h?ref=20bbd3cd53a80ddafa56a5d21337aae0c24f94ca", "patch": "@@ -1,6 +1,6 @@\n-#define GC_VERSION_MAJOR 4\n-#define GC_VERSION_MINOR 13\n-#define GC_ALPHA_VERSION 2\n+#define GC_VERSION_MAJOR 5\n+#define GC_VERSION_MINOR 0\n+#define GC_ALPHA_VERSION 4\n \n #   define GC_NOT_ALPHA 0xff\n "}, {"sha": "f6f74bd1111939d847e3285cf0c2657a13e98324", "filename": "boehm-gc/win32_threads.c", "status": "modified", "additions": 51, "deletions": 10, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20bbd3cd53a80ddafa56a5d21337aae0c24f94ca/boehm-gc%2Fwin32_threads.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20bbd3cd53a80ddafa56a5d21337aae0c24f94ca/boehm-gc%2Fwin32_threads.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fwin32_threads.c?ref=20bbd3cd53a80ddafa56a5d21337aae0c24f94ca", "patch": "@@ -8,22 +8,32 @@\n #define MAX_THREADS 64\n \n struct thread_entry {\n+  LONG in_use;\n   DWORD id;\n   HANDLE handle;\n-  void *stack;   /* The cold end of the stack. */\n+  void *stack;\t\t/* The cold end of the stack.   */\n+\t\t\t/* 0 ==> entry not valid.\t*/\n+\t\t\t/* !in_use ==> stack == 0\t*/\n   CONTEXT context;\n+  GC_bool suspended;\n };\n \n-struct thread_entry thread_table[MAX_THREADS];\n+volatile GC_bool GC_please_stop = FALSE;\n+\n+volatile struct thread_entry thread_table[MAX_THREADS];\n \n void GC_stop_world()\n {\n   DWORD thread_id = GetCurrentThreadId();\n   int i;\n+\n+  GC_please_stop = TRUE;\n   for (i = 0; i < MAX_THREADS; i++)\n-    if (thread_table[i].stack != 0 && thread_table[i].id != thread_id) {\n+    if (thread_table[i].stack != 0\n+\t&& thread_table[i].id != thread_id) {\n       if (SuspendThread(thread_table[i].handle) == (DWORD)-1)\n \tABORT(\"SuspendThread failed\");\n+      thread_table[i].suspended = TRUE;\n     }\n }\n \n@@ -32,10 +42,13 @@ void GC_start_world()\n   DWORD thread_id = GetCurrentThreadId();\n   int i;\n   for (i = 0; i < MAX_THREADS; i++)\n-    if (thread_table[i].stack != 0 && thread_table[i].id != thread_id) {\n+    if (thread_table[i].stack != 0 && thread_table[i].suspended\n+\t&& thread_table[i].id != thread_id) {\n       if (ResumeThread(thread_table[i].handle) == (DWORD)-1)\n \tABORT(\"ResumeThread failed\");\n+      thread_table[i].suspended = FALSE;\n     }\n+  GC_please_stop = FALSE;\n }\n \n ptr_t GC_current_stackbottom()\n@@ -78,6 +91,12 @@ void GC_push_all_stacks()\n \tif (thread_table[i].context.Esp >= (DWORD)thread_table[i].stack\n \t    || thread_table[i].context.Esp < (DWORD)bottom)\n \t    ABORT(\"Thread stack pointer out of range\");\n+\tGC_push_one ((word) thread_table[i].context.Edi);\n+    \tGC_push_one ((word) thread_table[i].context.Esi);\n+    \tGC_push_one ((word) thread_table[i].context.Ebx);\n+    \tGC_push_one ((word) thread_table[i].context.Edx);\n+    \tGC_push_one ((word) thread_table[i].context.Ecx);\n+    \tGC_push_one ((word) thread_table[i].context.Eax);\n \tGC_push_all_stack(thread_table[i].context.Esp, thread_table[i].stack);\n       }\n     }\n@@ -117,20 +136,34 @@ BOOL WINAPI DllMain(HINSTANCE inst, ULONG reason, LPVOID reserved)\n   switch (reason) {\n   case DLL_PROCESS_ATTACH:\n     InitializeCriticalSection(&GC_allocate_ml);\n+    GC_init();\t/* Force initialization before thread attach.\t*/\n     /* fall through */\n   case DLL_THREAD_ATTACH:\n     {\n       int i;\n-      LOCK();\n+      /* It appears to be unsafe to acquire a lock here, since this\t*/\n+      /* code is apparently not preeemptible on some systems.\t\t*/\n+      /* (This is based on complaints, not on Microsoft's official\t*/\n+      /* documentation, which says this should perform \"only simple\t*/\n+      /* inititalization tasks\".)\t\t\t\t\t*/\n+      /* Hence we make do with nonblocking synchronization.\t\t*/\n+\n       /* The following should be a noop according to the win32\t*/\n       /* documentation.  There is empirical evidence that it\t*/\n       /* isn't.\t\t- HB\t\t\t\t\t*/\n-      if (GC_incremental) SetUnhandledExceptionFilter(GC_write_fault_handler);\n-      for (i = 0; thread_table[i].stack != 0; i++) {\n+#     ifndef SMALL_CONFIG\n+       if (GC_incremental) SetUnhandledExceptionFilter(GC_write_fault_handler);\n+#     endif\n+\n+      for (i = 0; InterlockedExchange(&thread_table[i].in_use,1) != 0; i++) {\n+\t/* Compare-and-swap would make this cleaner, but that's not \t*/\n+\t/* supported before Windows 98 and NT 4.0.  In Windows 2000,\t*/\n+\t/* InterlockedExchange is supposed to be replaced by\t\t*/\n+\t/* InterlockedExchangePointer, but that's not really what I\t*/\n+\t/* want here.\t\t\t\t\t\t\t*/\n \tif (i == MAX_THREADS - 1)\n \t  ABORT(\"too many threads\");\n       }\n-      thread_table[i].stack = GC_get_stack_base();\n       thread_table[i].id = GetCurrentThreadId();\n       if (!DuplicateHandle(GetCurrentProcess(),\n \t                   GetCurrentThread(),\n@@ -143,7 +176,11 @@ BOOL WINAPI DllMain(HINSTANCE inst, ULONG reason, LPVOID reserved)\n \t    GC_printf1(\"Last error code: %lx\\n\", last_error);\n \t    ABORT(\"DuplicateHandle failed\");\n       }\n-      UNLOCK();\n+      thread_table[i].stack = GC_get_stack_base();\n+      /* If this thread is being created while we are trying to stop\t*/\n+      /* the world, wait here.  Hopefully this can't happen on any\t*/\n+      /* systems that don't allow us to block here.\t\t\t*/\n+      while (GC_please_stop) Sleep(20);\n     }\n     break;\n   case DLL_PROCESS_DETACH:\n@@ -152,10 +189,14 @@ BOOL WINAPI DllMain(HINSTANCE inst, ULONG reason, LPVOID reserved)\n       int i;\n       DWORD thread_id = GetCurrentThreadId();\n       LOCK();\n-      for (i = 0; thread_table[i].stack == 0 || thread_table[i].id != thread_id; i++)\n+      for (i = 0;\n+           thread_table[i].stack == 0 || thread_table[i].id != thread_id;\n+\t   i++) {\n \tif (i == MAX_THREADS - 1)\n \t  ABORT(\"thread not found on detach\");\n+      }\n       thread_table[i].stack = 0;\n+      thread_table[i].in_use = FALSE;\n       CloseHandle(thread_table[i].handle);\n       BZERO(&thread_table[i].context, sizeof(CONTEXT));\n       UNLOCK();"}]}