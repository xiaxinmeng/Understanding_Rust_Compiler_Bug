{"sha": "85f6d7e2d277bc7d409302673892ff2ca2c45535", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODVmNmQ3ZTJkMjc3YmM3ZDQwOTMwMjY3Mzg5MmZmMmNhMmM0NTUzNQ==", "commit": {"author": {"name": "Gary Dismukes", "email": "dismukes@adacore.com", "date": "2020-05-17T21:57:05Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2020-07-08T14:55:50Z"}, "message": "[Ada] Static expression function problems with -gnatc and -gnatd.F (SPARK mode)\n\ngcc/ada/\n\n\t* exp_ch6.adb (Expand_Simple_Function_Return): Remove ugly code\n\tthat was copying the return expression, resetting Analyzed\n\tflags, etc. for the return expression of static expression\n\tfunctions.\n\t* inline.adb (Inline_Static_Expression_Function_Call): Set the\n\tParent of the copied expression to that of the call. This avoids\n\ta blowup in Insert_Actions when GNATprove_Mode is set and there\n\tare nested SEF calls. Add ??? comment.\n\t* sem_ch6.adb (Analyze_Expression_Function): In the case of a\n\tstatic expression function, create a new copy of the expression\n\tand replace the function's expression with the copy; the\n\toriginal expression is used in the expression function's body\n\tand will be analyzed and rewritten, and we need to save a clean\n\tcopy for later use in processing static calls to the function.\n\tThis allows removing the kludgy code that was in\n\tExpand_Simple_Function_Return.\n\t* sem_eval.adb (Eval_Qualified_Expression): Return immediately\n\tif any errors have been posted on the qualified expression, to\n\tavoid blowups when GNATprove_Mode is enabled (or with -gnatd.F),\n\tsince illegal static expressions are handled differently in that\n\tcase and attempting to fold such expressions would fail.", "tree": {"sha": "4eb82ce8ad1f9de973ea4f47232f4732a22deb34", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4eb82ce8ad1f9de973ea4f47232f4732a22deb34"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/85f6d7e2d277bc7d409302673892ff2ca2c45535", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/85f6d7e2d277bc7d409302673892ff2ca2c45535", "html_url": "https://github.com/Rust-GCC/gccrs/commit/85f6d7e2d277bc7d409302673892ff2ca2c45535", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/85f6d7e2d277bc7d409302673892ff2ca2c45535/comments", "author": {"login": "dismukes", "id": 50880541, "node_id": "MDQ6VXNlcjUwODgwNTQx", "avatar_url": "https://avatars.githubusercontent.com/u/50880541?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dismukes", "html_url": "https://github.com/dismukes", "followers_url": "https://api.github.com/users/dismukes/followers", "following_url": "https://api.github.com/users/dismukes/following{/other_user}", "gists_url": "https://api.github.com/users/dismukes/gists{/gist_id}", "starred_url": "https://api.github.com/users/dismukes/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dismukes/subscriptions", "organizations_url": "https://api.github.com/users/dismukes/orgs", "repos_url": "https://api.github.com/users/dismukes/repos", "events_url": "https://api.github.com/users/dismukes/events{/privacy}", "received_events_url": "https://api.github.com/users/dismukes/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0f2d27e5fe82467329e0bbe8295bb4857b5da53c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f2d27e5fe82467329e0bbe8295bb4857b5da53c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0f2d27e5fe82467329e0bbe8295bb4857b5da53c"}], "stats": {"total": 67, "additions": 28, "deletions": 39}, "files": [{"sha": "c882630fd1cd10c4b2b13db4431dd128bbaf4e3c", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 0, "deletions": 39, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85f6d7e2d277bc7d409302673892ff2ca2c45535/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85f6d7e2d277bc7d409302673892ff2ca2c45535/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=85f6d7e2d277bc7d409302673892ff2ca2c45535", "patch": "@@ -7356,33 +7356,9 @@ package body Exp_Ch6 is\n                  Reason => PE_Accessibility_Check_Failed));\n       end Check_Against_Result_Level;\n \n-      --  Local Data\n-\n-      New_Copy_Of_Exp : Node_Id := Empty;\n-\n    --  Start of processing for Expand_Simple_Function_Return\n \n    begin\n-      --  For static expression functions, the expression of the function\n-      --  needs to be available in a form that can be replicated later for\n-      --  calls, but rewriting of the return expression in the body created\n-      --  for expression functions will cause the original expression to no\n-      --  longer be properly copyable via New_Copy_Tree, because the Parent\n-      --  fields of the nodes will now point to nodes in the rewritten tree,\n-      --  and New_Copy_Tree won't copy the deeper nodes of the original tree.\n-      --  So we work around that by making a copy of the expression tree\n-      --  before any rewriting occurs, and replacing the original expression\n-      --  tree with this copy (see the end of this procedure). We also reset\n-      --  the Analyzed flags on the nodes in the tree copy to ensure that\n-      --  later copies of the tree will be fully reanalyzed. This copying\n-      --  is of course rather inelegant, to say the least, and it would be\n-      --  nice if there were a way to avoid it. ???\n-\n-      if Is_Static_Expression_Function (Scope_Id) then\n-         New_Copy_Of_Exp := New_Copy_Tree (Exp);\n-         Reset_Analyzed_Flags (New_Copy_Of_Exp);\n-      end if;\n-\n       if Is_Class_Wide_Type (R_Type)\n         and then not Is_Class_Wide_Type (Exp_Typ)\n         and then Nkind (Exp) /= N_Type_Conversion\n@@ -8094,21 +8070,6 @@ package body Exp_Ch6 is\n          Analyze_And_Resolve (Exp);\n       end if;\n \n-      --  If a new copy of a static expression function's expression was made\n-      --  (see the beginning of this procedure's statement part), then we now\n-      --  replace the original expression tree with the copy and also change\n-      --  the Original_Node field of the rewritten expression to point to that\n-      --  copy. It would be nice to find a way to avoid this???\n-\n-      if Present (New_Copy_Of_Exp) then\n-         Set_Expression\n-           (Original_Node (Subprogram_Spec (Scope_Id)), New_Copy_Of_Exp);\n-\n-         if Exp /= Original_Node (Exp) then\n-            Set_Original_Node (Exp, New_Copy_Of_Exp);\n-         end if;\n-      end if;\n-\n       --  Ada 2020 (AI12-0279)\n \n       if Has_Yield_Aspect (Scope_Id)"}, {"sha": "53ca6853673a124541b3fc710d1f9f408f8719b4", "filename": "gcc/ada/inline.adb", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85f6d7e2d277bc7d409302673892ff2ca2c45535/gcc%2Fada%2Finline.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85f6d7e2d277bc7d409302673892ff2ca2c45535/gcc%2Fada%2Finline.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Finline.adb?ref=85f6d7e2d277bc7d409302673892ff2ca2c45535", "patch": "@@ -4714,6 +4714,13 @@ package body Inline is\n \n          Establish_Actual_Mapping_For_Inlined_Call (N, Subp, Decls, Func_Expr);\n \n+         --  Ensure that the copy has the same parent as the call (this seems\n+         --  to matter when GNATprove_Mode is set and there are nested static\n+         --  calls; prevents blowups in Insert_Actions, though it's not clear\n+         --  exactly why this is needed???).\n+\n+         Set_Parent (Expr_Copy, Parent (N));\n+\n          Insert_Actions (N, Decls);\n \n          --  Now substitute actuals for their corresponding formal references"}, {"sha": "0785c1cab4c992a1faaad8944d9d891d7c5b7604", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85f6d7e2d277bc7d409302673892ff2ca2c45535/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85f6d7e2d277bc7d409302673892ff2ca2c45535/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=85f6d7e2d277bc7d409302673892ff2ca2c45535", "patch": "@@ -598,6 +598,19 @@ package body Sem_Ch6 is\n                         Set_Checking_Potentially_Static_Expression (False);\n                      end;\n                   end if;\n+\n+                  --  We also make an additional copy of the expression and\n+                  --  replace the expression of the expression function with\n+                  --  this copy, because the currently present expression is\n+                  --  now associated with the body created for the static\n+                  --  expression function, which will later be analyzed and\n+                  --  possibly rewritten, and we need to have the separate\n+                  --  unanalyzed copy available for use with later static\n+                  --  calls.\n+\n+                  Set_Expression\n+                    (Original_Node (Subprogram_Spec (Def_Id)),\n+                     New_Copy_Tree (Expr));\n                end if;\n             end if;\n          end;"}, {"sha": "57dbaba886dfd642f99390c34f35915aaecd68a8", "filename": "gcc/ada/sem_eval.adb", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85f6d7e2d277bc7d409302673892ff2ca2c45535/gcc%2Fada%2Fsem_eval.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85f6d7e2d277bc7d409302673892ff2ca2c45535/gcc%2Fada%2Fsem_eval.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_eval.adb?ref=85f6d7e2d277bc7d409302673892ff2ca2c45535", "patch": "@@ -3243,6 +3243,14 @@ package body Sem_Eval is\n          end if;\n \n          return;\n+\n+      --  Also return if a semantic error has been posted on the node, as we\n+      --  don't want to fold in that case (for GNATprove, the node might lead\n+      --  to Constraint_Error but won't have been replaced with a raise node\n+      --  or marked as raising CE).\n+\n+      elsif Error_Posted (N) then\n+         return;\n       end if;\n \n       --  If not foldable we are done"}]}