{"sha": "474eccc60315960b14fb0af4b7da9c6795ac4f0e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDc0ZWNjYzYwMzE1OTYwYjE0ZmIwYWY0YjdkYTljNjc5NWFjNGYwZQ==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2006-01-17T07:04:20Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2006-01-17T07:04:20Z"}, "message": "common.opt (ftoplevel-reorder): New option.\n\n./:\t* common.opt (ftoplevel-reorder): New option.\n\t* cgraph.c (cgraph_asm_nodes): New global variable.\n\t(cgraph_asm_last_node): New static variable.\n\t(cgraph_order): New global variable.\n\t(cgraph_create_node): Set new order field.\n\t(cgraph_varpool_node): Likewise.\n\t(decide_is_variable_needed): Return true if not\n\tflag_toplevel_reorder.\n\t(cgraph_add_asm_node): New function.\n\t* cgraph.h (struct cgraph_node): Add order field.\n\t(struct cgraph_varpool_node): Add order field.\n\t(struct cgraph_asm_node): Define.\n\t(cgraph_asm_nodes, cgraph_order): Declare.\n\t(cgraph_add_asm_node): Declare.\n\t* cgraphunit.c (cgraph_varpool_assemble_decl): New static\n\tfunction.\n\t(cgraph_varpool_assemble_pending_decls): Call it.\n\t(cgraph_output_pending_asms): New static function.\n\t(cgraph_finalize_compilation_unit): Call it.\n\t(struct cgraph_order_sort): Define.\n\t(cgraph_output_in_order): New static function.\n\t(cgraph_optimize): Call cgraph_output_pending_asms.  Add code for\n\t!flag_toplevel_reorder case.\n\t* c-parser.c: Include \"cgraph.h\".\n\t(c_parser_asm_definition): Call cgraph_add_asm_node rather than\n\tassemble_asm.\n\t* Makefile.in (CRTSTUFF_CFLAGS): Use -fno-toplevel-reorder rather\n\tthan -fno-unit-at-a-time.\n\t* doc/invoke.texi (Option Summary): Mention\n\t-fno-toplevel-reorder.\n\t(Optimize Options): Document -fno-toplevel-reorder.  Mention it in\n\t-funit-at-a-time documentation.\ncp/:\n\t* parser.c: Include \"cgraph.h\".\n\t(cp_parser_asm_definition): Call cgraph_add_asm_node rather than\n\tassemble_asm.\n\nFrom-SVN: r109811", "tree": {"sha": "11320048997fd124915d16755d4d699f94cce278", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/11320048997fd124915d16755d4d699f94cce278"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/474eccc60315960b14fb0af4b7da9c6795ac4f0e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/474eccc60315960b14fb0af4b7da9c6795ac4f0e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/474eccc60315960b14fb0af4b7da9c6795ac4f0e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/474eccc60315960b14fb0af4b7da9c6795ac4f0e/comments", "author": null, "committer": null, "parents": [{"sha": "2fbdae3614e1e34d29ca5ce2af89739e39e305bd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2fbdae3614e1e34d29ca5ce2af89739e39e305bd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2fbdae3614e1e34d29ca5ce2af89739e39e305bd"}], "stats": {"total": 306, "additions": 269, "deletions": 37}, "files": [{"sha": "030333b3e0758c8dbf86dddf9a3ea88ad6a54c14", "filename": "gcc/ChangeLog", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/474eccc60315960b14fb0af4b7da9c6795ac4f0e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/474eccc60315960b14fb0af4b7da9c6795ac4f0e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=474eccc60315960b14fb0af4b7da9c6795ac4f0e", "patch": "@@ -1,3 +1,38 @@\n+2006-01-16  Ian Lance Taylor  <ian@airs.com>\n+\n+\t* common.opt (ftoplevel-reorder): New option.\n+\t* cgraph.c (cgraph_asm_nodes): New global variable.\n+\t(cgraph_asm_last_node): New static variable.\n+\t(cgraph_order): New global variable.\n+\t(cgraph_create_node): Set new order field.\n+\t(cgraph_varpool_node): Likewise.\n+\t(decide_is_variable_needed): Return true if not\n+\tflag_toplevel_reorder.\n+\t(cgraph_add_asm_node): New function.\n+\t* cgraph.h (struct cgraph_node): Add order field.\n+\t(struct cgraph_varpool_node): Add order field.\n+\t(struct cgraph_asm_node): Define.\n+\t(cgraph_asm_nodes, cgraph_order): Declare.\n+\t(cgraph_add_asm_node): Declare.\n+\t* cgraphunit.c (cgraph_varpool_assemble_decl): New static\n+\tfunction.\n+\t(cgraph_varpool_assemble_pending_decls): Call it.\n+\t(cgraph_output_pending_asms): New static function.\n+\t(cgraph_finalize_compilation_unit): Call it.\n+\t(struct cgraph_order_sort): Define.\n+\t(cgraph_output_in_order): New static function.\n+\t(cgraph_optimize): Call cgraph_output_pending_asms.  Add code for\n+\t!flag_toplevel_reorder case.\n+\t* c-parser.c: Include \"cgraph.h\".\n+\t(c_parser_asm_definition): Call cgraph_add_asm_node rather than\n+\tassemble_asm.\n+\t* Makefile.in (CRTSTUFF_CFLAGS): Use -fno-toplevel-reorder rather\n+\tthan -fno-unit-at-a-time.\n+\t* doc/invoke.texi (Option Summary): Mention\n+\t-fno-toplevel-reorder.\n+\t(Optimize Options): Document -fno-toplevel-reorder.  Mention it in\n+\t-funit-at-a-time documentation.\n+\n 2006-01-17  Hans-Peter Nilsson  <hp@axis.com>\n \t    Kazu Hirata  <kazu@codesourcery.com>\n "}, {"sha": "93e95dc61401b091670bdf10c55c82634ead1822", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/474eccc60315960b14fb0af4b7da9c6795ac4f0e/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/474eccc60315960b14fb0af4b7da9c6795ac4f0e/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=474eccc60315960b14fb0af4b7da9c6795ac4f0e", "patch": "@@ -554,7 +554,7 @@ TARGET_LIBGCC2_CFLAGS =\n # Options to use when compiling crtbegin/end.\n CRTSTUFF_CFLAGS = -O2 $(GCC_CFLAGS) $(INCLUDES) $(MULTILIB_CFLAGS) -g0 \\\n   -finhibit-size-directive -fno-inline-functions -fno-exceptions \\\n-  -fno-zero-initialized-in-bss -fno-unit-at-a-time \\\n+  -fno-zero-initialized-in-bss -fno-toplevel-reorder \\\n   $(INHIBIT_LIBC_CFLAGS)\n \n # Additional sources to handle exceptions; overridden by targets as needed."}, {"sha": "522f2d2e4a547740f997d7460623c752e5e7f526", "filename": "gcc/c-parser.c", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/474eccc60315960b14fb0af4b7da9c6795ac4f0e/gcc%2Fc-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/474eccc60315960b14fb0af4b7da9c6795ac4f0e/gcc%2Fc-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parser.c?ref=474eccc60315960b14fb0af4b7da9c6795ac4f0e", "patch": "@@ -56,6 +56,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"c-common.h\"\n #include \"vec.h\"\n #include \"target.h\"\n+#include \"cgraph.h\"\n \n \f\n /* Miscellaneous data and functions needed for the parser.  */\n@@ -1387,12 +1388,8 @@ static void\n c_parser_asm_definition (c_parser *parser)\n {\n   tree asm_str = c_parser_simple_asm_expr (parser);\n-  /* ??? This only works sensibly in the presence of\n-     -fno-unit-at-a-time; file-scope asms really need to be passed to\n-     cgraph which needs to preserve the order of functions and\n-     file-scope asms.  */\n   if (asm_str)\n-    assemble_asm (asm_str);\n+    cgraph_add_asm_node (asm_str);\n   c_parser_skip_until_found (parser, CPP_SEMICOLON, \"expected %<;%>\");\n }\n "}, {"sha": "10a22334771407e0deba772e60dff63dfd8f4906", "filename": "gcc/cgraph.c", "status": "modified", "additions": 35, "deletions": 5, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/474eccc60315960b14fb0af4b7da9c6795ac4f0e/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/474eccc60315960b14fb0af4b7da9c6795ac4f0e/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=474eccc60315960b14fb0af4b7da9c6795ac4f0e", "patch": "@@ -131,13 +131,23 @@ static GTY((param_is (struct cgraph_varpool_node))) htab_t cgraph_varpool_hash;\n /* Queue of cgraph nodes scheduled to be lowered and output.  */\n struct cgraph_varpool_node *cgraph_varpool_nodes_queue, *cgraph_varpool_first_unanalyzed_node;\n \n-\n /* The linked list of cgraph varpool nodes.  */\n static GTY(()) struct cgraph_varpool_node *cgraph_varpool_nodes;\n \n /* End of the varpool queue.  Needs to be QTYed to work with PCH.  */\n static GTY(()) struct cgraph_varpool_node *cgraph_varpool_last_needed_node;\n \n+/* Linked list of cgraph asm nodes.  */\n+struct cgraph_asm_node *cgraph_asm_nodes;\n+\n+/* Last node in cgraph_asm_nodes.  */\n+static GTY(()) struct cgraph_asm_node *cgraph_asm_last_node;\n+\n+/* The order index of the next cgraph node to be created.  This is\n+   used so that we can sort the cgraph nodes in order by when we saw\n+   them, to support -fno-toplevel-reorder.  */\n+int cgraph_order;\n+\n static hashval_t hash_node (const void *);\n static int eq_node (const void *, const void *);\n \n@@ -169,6 +179,7 @@ cgraph_create_node (void)\n   node = GGC_CNEW (struct cgraph_node);\n   node->next = cgraph_nodes;\n   node->uid = cgraph_max_uid++;\n+  node->order = cgraph_order++;\n   if (cgraph_nodes)\n     cgraph_nodes->previous = node;\n   node->previous = NULL;\n@@ -745,6 +756,7 @@ cgraph_varpool_node (tree decl)\n     return *slot;\n   node = GGC_CNEW (struct cgraph_varpool_node);\n   node->decl = decl;\n+  node->order = cgraph_order++;\n   node->next = cgraph_varpool_nodes;\n   cgraph_varpool_nodes = node;\n   *slot = node;\n@@ -847,12 +859,11 @@ decide_is_variable_needed (struct cgraph_varpool_node *node, tree decl)\n   if (TREE_PUBLIC (decl) && !DECL_COMDAT (decl) && !DECL_EXTERNAL (decl))\n     return true;\n \n-  if (flag_unit_at_a_time)\n+  /* When not reordering top level variables, we have to assume that\n+     we are going to keep everything.  */\n+  if (flag_unit_at_a_time && flag_toplevel_reorder)\n     return false;\n \n-  /* If not doing unit at a time, then we'll only defer this function\n-     if its marked for inlining.  Otherwise we want to emit it now.  */\n-\n   /* We want to emit COMDAT variables only when absolutely necessary.  */\n   if (DECL_COMDAT (decl))\n     return false;\n@@ -889,6 +900,25 @@ cgraph_varpool_finalize_decl (tree decl)\n     cgraph_varpool_assemble_pending_decls ();\n }\n \n+/* Add a top-level asm statement to the list.  */\n+\n+struct cgraph_asm_node *\n+cgraph_add_asm_node (tree asm_str)\n+{\n+  struct cgraph_asm_node *node;\n+\n+  node = GGC_CNEW (struct cgraph_asm_node);\n+  node->asm_str = asm_str;\n+  node->order = cgraph_order++;\n+  node->next = NULL;\n+  if (cgraph_asm_nodes == NULL)\n+    cgraph_asm_nodes = node;\n+  else\n+    cgraph_asm_last_node->next = node;\n+  cgraph_asm_last_node = node;\n+  return node;\n+}\n+\n /* Return true when the DECL can possibly be inlined.  */\n bool\n cgraph_function_possibly_inlined_p (tree decl)"}, {"sha": "82cf2d9fe13b46ff69e6fbb04481ce1f6374b64f", "filename": "gcc/cgraph.h", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/474eccc60315960b14fb0af4b7da9c6795ac4f0e/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/474eccc60315960b14fb0af4b7da9c6795ac4f0e/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=474eccc60315960b14fb0af4b7da9c6795ac4f0e", "patch": "@@ -144,6 +144,8 @@ struct cgraph_node GTY((chain_next (\"%h.next\"), chain_prev (\"%h.previous\")))\n   gcov_type count;\n   /* Unique id of the node.  */\n   int uid;\n+  /* Ordering of all cgraph nodes.  */\n+  int order;\n   /* Set when function must be output - it is externally visible\n      or its address is taken.  */\n   bool needed;\n@@ -197,6 +199,8 @@ struct cgraph_varpool_node GTY(())\n   struct cgraph_varpool_node *next;\n   /* Pointer to the next function in cgraph_varpool_nodes_queue.  */\n   struct cgraph_varpool_node *next_needed;\n+  /* Ordering of all cgraph nodes.  */\n+  int order;\n \n   /* Set when function must be output - it is externally visible\n      or its address is taken.  */\n@@ -217,6 +221,18 @@ struct cgraph_varpool_node GTY(())\n   bool alias;\n };\n \n+/* Every top level asm statement is put into a cgraph_asm_node.  */\n+\n+struct cgraph_asm_node GTY(())\n+{\n+  /* Next asm node.  */\n+  struct cgraph_asm_node *next;\n+  /* String for this asm node.  */\n+  tree asm_str;\n+  /* Ordering of all cgraph nodes.  */\n+  int order;\n+};\n+\n extern GTY(()) struct cgraph_node *cgraph_nodes;\n extern GTY(()) int cgraph_n_nodes;\n extern GTY(()) int cgraph_max_uid;\n@@ -226,6 +242,8 @@ extern GTY(()) struct cgraph_node *cgraph_nodes_queue;\n \n extern GTY(()) struct cgraph_varpool_node *cgraph_varpool_first_unanalyzed_node;\n extern GTY(()) struct cgraph_varpool_node *cgraph_varpool_nodes_queue;\n+extern GTY(()) struct cgraph_asm_node *cgraph_asm_nodes;\n+extern GTY(()) int cgraph_order;\n \n /* In cgraph.c  */\n void dump_cgraph (FILE *);\n@@ -258,6 +276,8 @@ void cgraph_varpool_mark_needed_node (struct cgraph_varpool_node *);\n void cgraph_varpool_finalize_decl (tree);\n void cgraph_redirect_edge_callee (struct cgraph_edge *, struct cgraph_node *);\n \n+struct cgraph_asm_node *cgraph_add_asm_node (tree);\n+\n bool cgraph_function_possibly_inlined_p (tree);\n void cgraph_unnest_node (struct cgraph_node *);\n void cgraph_varpool_enqueue_needed_node (struct cgraph_varpool_node *);"}, {"sha": "ae9f690013ecaf5f11031a55be69100e1cf3145c", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 150, "deletions": 21, "changes": 171, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/474eccc60315960b14fb0af4b7da9c6795ac4f0e/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/474eccc60315960b14fb0af4b7da9c6795ac4f0e/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=474eccc60315960b14fb0af4b7da9c6795ac4f0e", "patch": "@@ -807,6 +807,34 @@ verify_cgraph (void)\n     verify_cgraph_node (node);\n }\n \n+/* Output one variable, if necessary.  Return whether we output it.  */\n+static bool\n+cgraph_varpool_assemble_decl (struct cgraph_varpool_node *node)\n+{\n+  tree decl = node->decl;\n+\n+  if (!TREE_ASM_WRITTEN (decl)\n+      && !node->alias\n+      && !DECL_EXTERNAL (decl)\n+      && (TREE_CODE (decl) != VAR_DECL || !DECL_HAS_VALUE_EXPR_P (decl)))\n+    {\n+      assemble_variable (decl, 0, 1, 0);\n+      /* Local static variables are never seen by check_global_declarations\n+\t so we need to output debug info by hand.  */\n+      if (DECL_CONTEXT (decl) \n+\t  && (TREE_CODE (DECL_CONTEXT (decl)) == BLOCK\n+\t      || TREE_CODE (DECL_CONTEXT (decl)) == FUNCTION_DECL)\n+\t  && errorcount == 0 && sorrycount == 0)\n+\t{\n+\t  timevar_push (TV_SYMOUT);\n+\t  (*debug_hooks->global_decl) (decl);\n+\t  timevar_pop (TV_SYMOUT);\n+\t}\n+      return true;\n+    }\n+\n+  return false;\n+}\n \n /* Output all variables enqueued to be assembled.  */\n bool\n@@ -824,31 +852,31 @@ cgraph_varpool_assemble_pending_decls (void)\n \n   while (cgraph_varpool_nodes_queue)\n     {\n-      tree decl = cgraph_varpool_nodes_queue->decl;\n       struct cgraph_varpool_node *node = cgraph_varpool_nodes_queue;\n \n       cgraph_varpool_nodes_queue = cgraph_varpool_nodes_queue->next_needed;\n-      if (!TREE_ASM_WRITTEN (decl) && !node->alias && !DECL_EXTERNAL (decl))\n-\t{\n-\t  assemble_variable (decl, 0, 1, 0);\n-\t  /* Local static variables are never seen by check_global_declarations\n-\t     so we need to output debug info by hand.  */\n-\t  if (DECL_CONTEXT (decl) \n-\t      && (TREE_CODE (DECL_CONTEXT (decl)) == BLOCK\n-\t          || TREE_CODE (DECL_CONTEXT (decl)) == FUNCTION_DECL)\n-\t      && errorcount == 0 && sorrycount == 0)\n-\t    {\n-\t      timevar_push (TV_SYMOUT);\n-\t      (*debug_hooks->global_decl) (decl);\n-\t      timevar_pop (TV_SYMOUT);\n-\t    }\n-\t  changed = true;\n-\t}\n+      if (cgraph_varpool_assemble_decl (node))\n+\tchanged = true;\n       node->next_needed = NULL;\n     }\n   return changed;\n }\n \n+/* Output all asm statements we have stored up to be output.  */\n+\n+static void\n+cgraph_output_pending_asms (void)\n+{\n+  struct cgraph_asm_node *can;\n+\n+  if (errorcount || sorrycount)\n+    return;\n+\n+  for (can = cgraph_asm_nodes; can; can = can->next)\n+    assemble_asm (can->asm_str);\n+  cgraph_asm_nodes = NULL;\n+}\n+\n /* Analyze the function scheduled to be output.  */\n static void\n cgraph_analyze_function (struct cgraph_node *node)\n@@ -892,6 +920,7 @@ cgraph_finalize_compilation_unit (void)\n \n   if (!flag_unit_at_a_time)\n     {\n+      cgraph_output_pending_asms ();\n       cgraph_assemble_pending_functions ();\n       return;\n     }\n@@ -1125,6 +1154,97 @@ cgraph_expand_all_functions (void)\n   free (order);\n }\n \n+/* This is used to sort the node types by the cgraph order number.  */\n+\n+struct cgraph_order_sort\n+{\n+  enum { ORDER_UNDEFINED = 0, ORDER_FUNCTION, ORDER_VAR, ORDER_ASM } kind;\n+  union\n+  {\n+    struct cgraph_node *f;\n+    struct cgraph_varpool_node *v;\n+    struct cgraph_asm_node *a;\n+  } u;\n+};\n+\n+/* Output all functions, variables, and asm statements in the order\n+   according to their order fields, which is the order in which they\n+   appeared in the file.  This implements -fno-toplevel-reorder.  In\n+   this mode we may output functions and variables which don't really\n+   need to be output.  */\n+\n+static void\n+cgraph_output_in_order (void)\n+{\n+  int max;\n+  size_t size;\n+  struct cgraph_order_sort *nodes;\n+  int i;\n+  struct cgraph_node *pf;\n+  struct cgraph_varpool_node *pv;\n+  struct cgraph_asm_node *pa;\n+\n+  max = cgraph_order;\n+  size = max * sizeof (struct cgraph_order_sort);\n+  nodes = (struct cgraph_order_sort *) alloca (size);\n+  memset (nodes, 0, size);\n+\n+  cgraph_varpool_analyze_pending_decls ();\n+\n+  for (pf = cgraph_nodes; pf; pf = pf->next)\n+    {\n+      if (pf->output)\n+\t{\n+\t  i = pf->order;\n+\t  gcc_assert (nodes[i].kind == ORDER_UNDEFINED);\n+\t  nodes[i].kind = ORDER_FUNCTION;\n+\t  nodes[i].u.f = pf;\n+\t}\n+    }\n+\n+  for (pv = cgraph_varpool_nodes_queue; pv; pv = pv->next_needed)\n+    {\n+      i = pv->order;\n+      gcc_assert (nodes[i].kind == ORDER_UNDEFINED);\n+      nodes[i].kind = ORDER_VAR;\n+      nodes[i].u.v = pv;\n+    }\n+\n+  for (pa = cgraph_asm_nodes; pa; pa = pa->next)\n+    {\n+      i = pa->order;\n+      gcc_assert (nodes[i].kind == ORDER_UNDEFINED);\n+      nodes[i].kind = ORDER_ASM;\n+      nodes[i].u.a = pa;\n+    }\n+  cgraph_asm_nodes = NULL;\n+\n+  for (i = 0; i < max; ++i)\n+    {\n+      switch (nodes[i].kind)\n+\t{\n+\tcase ORDER_FUNCTION:\n+\t  nodes[i].u.f->output = 0;\n+\t  cgraph_expand_function (nodes[i].u.f);\n+\t  break;\n+\n+\tcase ORDER_VAR:\n+\t  cgraph_varpool_assemble_decl (nodes[i].u.v);\n+\t  break;\n+\n+\tcase ORDER_ASM:\n+\t  assemble_asm (nodes[i].u.a->asm_str);\n+\t  break;\n+\n+\tcase ORDER_UNDEFINED:\n+\t  break;\n+\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+    }\n+}\n+\n /* Mark visibility of all functions.\n    \n    A local function is one whose calls can occur only in the current\n@@ -1232,6 +1352,7 @@ cgraph_optimize (void)\n #endif\n   if (!flag_unit_at_a_time)\n     {\n+      cgraph_output_pending_asms ();\n       cgraph_varpool_assemble_pending_decls ();\n       return;\n     }\n@@ -1271,12 +1392,20 @@ cgraph_optimize (void)\n #ifdef ENABLE_CHECKING\n   verify_cgraph ();\n #endif\n-  \n+\n   cgraph_mark_functions_to_output ();\n-  cgraph_expand_all_functions ();\n-  cgraph_varpool_remove_unreferenced_decls ();\n \n-  cgraph_varpool_assemble_pending_decls ();\n+  if (!flag_toplevel_reorder)\n+    cgraph_output_in_order ();\n+  else\n+    {\n+      cgraph_output_pending_asms ();\n+\n+      cgraph_expand_all_functions ();\n+      cgraph_varpool_remove_unreferenced_decls ();\n+\n+      cgraph_varpool_assemble_pending_decls ();\n+    }\n \n   if (cgraph_dump_file)\n     {"}, {"sha": "8fe9bee7e9a5151a7ae3fd3511f7234eec95aca4", "filename": "gcc/common.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/474eccc60315960b14fb0af4b7da9c6795ac4f0e/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/474eccc60315960b14fb0af4b7da9c6795ac4f0e/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=474eccc60315960b14fb0af4b7da9c6795ac4f0e", "patch": "@@ -868,6 +868,10 @@ ftls-model=\n Common Joined RejectNegative\n -ftls-model=[global-dynamic|local-dynamic|initial-exec|local-exec]\tSet the default thread-local storage code generation model\n \n+ftoplevel-reorder\n+Common Report Var(flag_toplevel_reorder) Init(1)\n+Reorder top level functions, variables, and asms\n+\n ftracer\n Common Report Var(flag_tracer)\n Perform superblock formation via tail duplication"}, {"sha": "34538932b49f81226f33208c6320bab0ddf27282", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/474eccc60315960b14fb0af4b7da9c6795ac4f0e/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/474eccc60315960b14fb0af4b7da9c6795ac4f0e/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=474eccc60315960b14fb0af4b7da9c6795ac4f0e", "patch": "@@ -1,3 +1,9 @@\n+2006-01-16  Ian Lance Taylor  <ian@airs.com>\n+\n+\t* parser.c: Include \"cgraph.h\".\n+\t(cp_parser_asm_definition): Call cgraph_add_asm_node rather than\n+\tassemble_asm.\n+\n 2006-01-16  Rafael \ufffdvila de Esp\ufffdndola  <rafael.espindola@gmail.com>\n \n \t* g++spec.c (lang_specific_spec_functions): Remove.\n@@ -43,7 +49,7 @@\n \t* parser.c (cp_parser_primary_expression): Document the grammar\n \tfor the built-in offsetof, a GNU extension.\n \n-2005-01-04  Zdenek Dvorak <dvorakz@suse.cz>\n+2006-01-04  Zdenek Dvorak <dvorakz@suse.cz>\n \n \tPR c++/25632\n \t* init.c (constant_value_1): Unshare use of DECL_INITIAL.  Fix a typo"}, {"sha": "ec4c2ea5bc5facb923ec3ee10ca573873025a712", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/474eccc60315960b14fb0af4b7da9c6795ac4f0e/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/474eccc60315960b14fb0af4b7da9c6795ac4f0e/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=474eccc60315960b14fb0af4b7da9c6795ac4f0e", "patch": "@@ -36,6 +36,7 @@\n #include \"toplev.h\"\n #include \"output.h\"\n #include \"target.h\"\n+#include \"cgraph.h\"\n #include \"c-common.h\"\n \n \f\n@@ -10741,7 +10742,7 @@ cp_parser_asm_definition (cp_parser* parser)\n \t}\n     }\n   else\n-    assemble_asm (string);\n+    cgraph_add_asm_node (string);\n }\n \n /* Declarators [gram.dcl.decl] */"}, {"sha": "c1c87f25089324ae72b3bdf97499960ccd3e0f42", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/474eccc60315960b14fb0af4b7da9c6795ac4f0e/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/474eccc60315960b14fb0af4b7da9c6795ac4f0e/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=474eccc60315960b14fb0af4b7da9c6795ac4f0e", "patch": "@@ -319,7 +319,7 @@ Objective-C and Objective-C++ Dialects}.\n -fno-function-cse  -fno-guess-branch-probability @gol\n -fno-inline  -fno-math-errno  -fno-peephole  -fno-peephole2 @gol\n -funsafe-math-optimizations  -funsafe-loop-optimizations  -ffinite-math-only @gol\n--fno-trapping-math  -fno-zero-initialized-in-bss @gol\n+-fno-toplevel-reorder -fno-trapping-math  -fno-zero-initialized-in-bss @gol\n -fomit-frame-pointer  -foptimize-register-move @gol\n -foptimize-sibling-calls  -fprefetch-loop-arrays @gol\n -fprofile-generate -fprofile-use @gol\n@@ -5336,14 +5336,16 @@ Enabled at levels @option{-O2}, @option{-O3}.\n Parse the whole compilation unit before starting to produce code.\n This allows some extra optimizations to take place but consumes\n more memory (in general).  There are some compatibility issues\n-with @emph{unit-at-at-time} mode:\n+with @emph{unit-at-a-time} mode:\n @itemize @bullet\n @item\n enabling @emph{unit-at-a-time} mode may change the order\n in which functions, variables, and top-level @code{asm} statements\n are emitted, and will likely break code relying on some particular\n ordering.  The majority of such top-level @code{asm} statements,\n-though, can be replaced by @code{section} attributes.\n+though, can be replaced by @code{section} attributes.  The\n+@option{fno-toplevel-reorder} option may be used to keep the ordering\n+used in the input file, at the cost of some optimizations.\n \n @item\n @emph{unit-at-a-time} mode removes unreferenced static variables\n@@ -5365,6 +5367,14 @@ but this scheme may not be supported by future releases of GCC@.\n \n Enabled at levels @option{-O2}, @option{-O3}.\n \n+@item -fno-toplevel-reorder\n+Do not reorder top-level functions, variables, and @code{asm}\n+statements.  Output them in the same order that they appear in the\n+input file.  When this option is used, unreferenced static variables\n+will not be removed.  This option is intended to support existing code\n+which relies on a particular ordering.  For new code, it is better to\n+use attributes.\n+\n @item -fweb\n @opindex fweb\n Constructs webs as commonly used for register allocation purposes and assign"}]}