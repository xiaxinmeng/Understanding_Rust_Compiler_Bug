{"sha": "0ca5af51abe63d31a944080e63f04ff3525363e6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGNhNWFmNTFhYmU2M2QzMWE5NDQwODBlNjNmMDRmZjM1MjUzNjNlNg==", "commit": {"author": {"name": "Alexandre Oliva", "email": "aoliva@redhat.com", "date": "2009-10-12T18:58:38Z"}, "committer": {"name": "Alexandre Oliva", "email": "aoliva@gcc.gnu.org", "date": "2009-10-12T18:58:38Z"}, "message": "re PR debug/41343 (sysdeps/ieee754/dbl-64/dosincos.c from glibc causes excessive memory use)\n\ngcc/ChangeLog:\nPR debug/41343\nPR debug/41447\nPR debug/41264\nPR debug/41338\n* tree.def (DEBUG_EXPR_DECL): New.\n* rtl.def (DEBUG_EXPR): New.\n* gengtype.c (adjust_field_rtx_def): Handle it.\n* tree-ssa.c (propagate_var_def_into_debug_stmts): Rename to...\n(insert_debug_temp_for_var_def): ... this.  Drop support for\nmoving.  Take iterator for def stmt; insert debug stmt before it.\nScan early for use count and kind in debug stmts.\n(propagate_defs_into_debug_stmts): Rename to...\n(insert_debug_temps_for_defs): ... this.  Likewise.\n* tree.h (DEBUG_TEMP_UID): New.\n* tree.c (next_debug_decl_uid): New.\n(make_node_stat): Count debug decls separately.\n(copy_node_stat): Likewise.\n* cfgexpand.c (expand_debug_expr): Handle DEBUG_EXPR_DECL.\n* var-tracking.c (dv_is_decl_p): Recognize it.\n(VALUE_RECURSED_INTO): Apply to DEBUG_EXPRs too.\n(track_expr_p): Track expanded DEBUG_EXPR_DECLs.\n(vt_expand_loc_callback): Expand DEBUG_EXPRs.\n(emit_note_insn_var_location): Don't emit notes for DEBUG_EXPR_DECLs.\n* cselib.c (rtx_equal_for_cselib_p): Handle DEBUG_EXPR.\n(cselib_hash_rtx): Likewise.\n(cselib_expand_value_rtx_1): Use callback for DEBUG_EXPR.\n* tree-ssa-operands.c (get_expr_operands): Skip DEBUG_EXPR_DECLs in\ndebug bind stmts.\n* emit-rtl.c (verify_rtx_sharing): Handle DEBUG_EXPR and VALUE.\n(copy_rtx_if_shared_1, reset_used_flags, set_used_flags): Likewise.\n* rtl.c (copy_rtx): Likewise.\n(rtx_equal_p_cb, rtx_equal_p): Handle DEBUG_EXPR.\n* print-rtl.c (print_rtx): Likewise.\n* sched-vis.c (print_value): Likewise.\n(print_insn): Handle DEBUG_EXPR_DECL.\n* tree-dump.c (dequeue_and_dump): Likewise.\n* tree-pretty-print.c (dump_decl_name, dump_generic_node): Likewise.\n* gimple-iterator (gsi_replace): Check for same lhs.\n(gsi_remove): Insert debug temps.\n* tree-ssa-loop-im.c (rewrite_reciprocal): Replace with same lhs.\n(move_computations_stmt): Drop explicit propagation into debug stmts.\n(rewrite_bittest): Likewise.  Use gsi_remove for propagation.\n* tree-ssa-reassoc.c (rewrite_expr_tree, linearize_expr): Likewise.\n* tree-ssa-sink.c (statement_sink_location): Likewise.\n* tree-ssa-forwprop (forward_propagate_addr_expr): Likewise.\n* tree-ssanames.c (release_ssa_name): Adjust for rename.\n* tree-flow.h: Likewise.\n* tree-ssa-dce.c (mark_stmt_if_obviously_necessary): Don't mark\ndebug temps without values.\n(eliminate_unnecessary_stmts): Don't discard just-inserted\ndebug stmts.\ngcc/testsuite/ChangeLog:\nPR debug/41343\nPR debug/41447\nPR debug/41264\nPR debug/41338\n* gcc.dg/guality/pr41447-1.c: New.\n* gcc.dg/debug/pr41264-1.c: New.\n* gcc.dg/debug/pr41343-1.c: New.\n\nFrom-SVN: r152681", "tree": {"sha": "0cd2fe4eab12298b796d2e872b3b8cd073d8ef6c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0cd2fe4eab12298b796d2e872b3b8cd073d8ef6c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0ca5af51abe63d31a944080e63f04ff3525363e6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ca5af51abe63d31a944080e63f04ff3525363e6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0ca5af51abe63d31a944080e63f04ff3525363e6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ca5af51abe63d31a944080e63f04ff3525363e6/comments", "author": null, "committer": null, "parents": [{"sha": "2e723874b5ed813da802a8dcb81134172d6408c6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e723874b5ed813da802a8dcb81134172d6408c6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2e723874b5ed813da802a8dcb81134172d6408c6"}], "stats": {"total": 598, "additions": 444, "deletions": 154}, "files": [{"sha": "9e066b4d1f657f5bb670009bb4f95813b4188e80", "filename": "gcc/ChangeLog", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ca5af51abe63d31a944080e63f04ff3525363e6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ca5af51abe63d31a944080e63f04ff3525363e6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0ca5af51abe63d31a944080e63f04ff3525363e6", "patch": "@@ -1,3 +1,57 @@\n+2009-10-12  Alexandre Oliva  <aoliva@redhat.com>\n+\n+\tPR debug/41343\n+\tPR debug/41447\n+\tPR debug/41264\n+\tPR debug/41338\n+\t* tree.def (DEBUG_EXPR_DECL): New.\n+\t* rtl.def (DEBUG_EXPR): New.\n+\t* gengtype.c (adjust_field_rtx_def): Handle it.\n+\t* tree-ssa.c (propagate_var_def_into_debug_stmts): Rename to...\n+\t(insert_debug_temp_for_var_def): ... this.  Drop support for\n+\tmoving.  Take iterator for def stmt; insert debug stmt before it.\n+\tScan early for use count and kind in debug stmts.\n+\t(propagate_defs_into_debug_stmts): Rename to...\n+\t(insert_debug_temps_for_defs): ... this.  Likewise.\n+\t* tree.h (DEBUG_TEMP_UID): New.\n+\t* tree.c (next_debug_decl_uid): New.\n+\t(make_node_stat): Count debug decls separately.\n+\t(copy_node_stat): Likewise.\n+\t* cfgexpand.c (expand_debug_expr): Handle DEBUG_EXPR_DECL.\n+\t* var-tracking.c (dv_is_decl_p): Recognize it.\n+\t(VALUE_RECURSED_INTO): Apply to DEBUG_EXPRs too.\n+\t(track_expr_p): Track expanded DEBUG_EXPR_DECLs.\n+\t(vt_expand_loc_callback): Expand DEBUG_EXPRs.\n+\t(emit_note_insn_var_location): Don't emit notes for DEBUG_EXPR_DECLs.\n+\t* cselib.c (rtx_equal_for_cselib_p): Handle DEBUG_EXPR.\n+\t(cselib_hash_rtx): Likewise.\n+\t(cselib_expand_value_rtx_1): Use callback for DEBUG_EXPR.\n+\t* tree-ssa-operands.c (get_expr_operands): Skip DEBUG_EXPR_DECLs in\n+\tdebug bind stmts.\n+\t* emit-rtl.c (verify_rtx_sharing): Handle DEBUG_EXPR and VALUE.\n+\t(copy_rtx_if_shared_1, reset_used_flags, set_used_flags): Likewise.\n+\t* rtl.c (copy_rtx): Likewise.\n+\t(rtx_equal_p_cb, rtx_equal_p): Handle DEBUG_EXPR.\n+\t* print-rtl.c (print_rtx): Likewise.\n+\t* sched-vis.c (print_value): Likewise.\n+\t(print_insn): Handle DEBUG_EXPR_DECL.\n+\t* tree-dump.c (dequeue_and_dump): Likewise.\n+\t* tree-pretty-print.c (dump_decl_name, dump_generic_node): Likewise.\n+\t* gimple-iterator (gsi_replace): Check for same lhs.\n+\t(gsi_remove): Insert debug temps.\n+\t* tree-ssa-loop-im.c (rewrite_reciprocal): Replace with same lhs.\n+\t(move_computations_stmt): Drop explicit propagation into debug stmts.\n+\t(rewrite_bittest): Likewise.  Use gsi_remove for propagation.\n+\t* tree-ssa-reassoc.c (rewrite_expr_tree, linearize_expr): Likewise.\n+\t* tree-ssa-sink.c (statement_sink_location): Likewise.\n+\t* tree-ssa-forwprop (forward_propagate_addr_expr): Likewise.\n+\t* tree-ssanames.c (release_ssa_name): Adjust for rename.\n+\t* tree-flow.h: Likewise.\n+\t* tree-ssa-dce.c (mark_stmt_if_obviously_necessary): Don't mark\n+\tdebug temps without values.\n+\t(eliminate_unnecessary_stmts): Don't discard just-inserted\n+\tdebug stmts.\n+\n 2009-10-12  Hans-Peter Nilsson  <hp@axis.com>\n \n \tPR target/26515"}, {"sha": "31832e71c87f1de634c5dbfef45a10a7b20083cd", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ca5af51abe63d31a944080e63f04ff3525363e6/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ca5af51abe63d31a944080e63f04ff3525363e6/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=0ca5af51abe63d31a944080e63f04ff3525363e6", "patch": "@@ -2361,6 +2361,18 @@ expand_debug_expr (tree exp)\n       op1 = wrap_constant (GET_MODE_INNER (mode), op1);\n       return gen_rtx_CONCAT (mode, op0, op1);\n \n+    case DEBUG_EXPR_DECL:\n+      op0 = DECL_RTL_IF_SET (exp);\n+\n+      if (op0)\n+\treturn op0;\n+\n+      op0 = gen_rtx_DEBUG_EXPR (mode);\n+      XTREE (op0, 0) = exp;\n+      SET_DECL_RTL (exp, op0);\n+\n+      return op0;\n+\n     case VAR_DECL:\n     case PARM_DECL:\n     case FUNCTION_DECL:"}, {"sha": "c26742ddf1a08dc4a18b2cba80a2c2eb2f68f844", "filename": "gcc/cselib.c", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ca5af51abe63d31a944080e63f04ff3525363e6/gcc%2Fcselib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ca5af51abe63d31a944080e63f04ff3525363e6/gcc%2Fcselib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcselib.c?ref=0ca5af51abe63d31a944080e63f04ff3525363e6", "patch": "@@ -585,6 +585,7 @@ rtx_equal_for_cselib_p (rtx x, rtx y)\n     {\n     case CONST_DOUBLE:\n     case CONST_FIXED:\n+    case DEBUG_EXPR:\n       return 0;\n \n     case LABEL_REF:\n@@ -703,6 +704,10 @@ cselib_hash_rtx (rtx x, int create)\n \n       return e->value;\n \n+    case DEBUG_EXPR:\n+      hash += ((unsigned) DEBUG_EXPR << 7) + DEBUG_TEMP_UID (XTREE (x, 0));\n+      return hash ? hash : (unsigned int) DEBUG_EXPR;\n+\n     case CONST_INT:\n       hash += ((unsigned) CONST_INT << 7) + INTVAL (x);\n       return hash ? hash : (unsigned int) CONST_INT;\n@@ -1213,6 +1218,13 @@ cselib_expand_value_rtx_1 (rtx orig, struct expand_value_data *evd,\n \tresult = expand_loc (CSELIB_VAL_PTR (orig)->locs, evd, max_depth);\n \treturn result;\n       }\n+\n+    case DEBUG_EXPR:\n+      if (evd->callback)\n+\treturn evd->callback (orig, evd->regs_active, max_depth,\n+\t\t\t      evd->callback_arg);\n+      return orig;\n+\n     default:\n       break;\n     }"}, {"sha": "b8682984eca9861dd9e2373d37c63c9f2445b2bd", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ca5af51abe63d31a944080e63f04ff3525363e6/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ca5af51abe63d31a944080e63f04ff3525363e6/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=0ca5af51abe63d31a944080e63f04ff3525363e6", "patch": "@@ -2393,6 +2393,8 @@ verify_rtx_sharing (rtx orig, rtx insn)\n   switch (code)\n     {\n     case REG:\n+    case DEBUG_EXPR:\n+    case VALUE:\n     case CONST_INT:\n     case CONST_DOUBLE:\n     case CONST_FIXED:\n@@ -2593,6 +2595,8 @@ copy_rtx_if_shared_1 (rtx *orig1)\n   switch (code)\n     {\n     case REG:\n+    case DEBUG_EXPR:\n+    case VALUE:\n     case CONST_INT:\n     case CONST_DOUBLE:\n     case CONST_FIXED:\n@@ -2712,6 +2716,8 @@ reset_used_flags (rtx x)\n   switch (code)\n     {\n     case REG:\n+    case DEBUG_EXPR:\n+    case VALUE:\n     case CONST_INT:\n     case CONST_DOUBLE:\n     case CONST_FIXED:\n@@ -2783,6 +2789,8 @@ set_used_flags (rtx x)\n   switch (code)\n     {\n     case REG:\n+    case DEBUG_EXPR:\n+    case VALUE:\n     case CONST_INT:\n     case CONST_DOUBLE:\n     case CONST_FIXED:"}, {"sha": "8e882f171f9d29e7eab174d02768eb3505a11f1a", "filename": "gcc/gengtype.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ca5af51abe63d31a944080e63f04ff3525363e6/gcc%2Fgengtype.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ca5af51abe63d31a944080e63f04ff3525363e6/gcc%2Fgengtype.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype.c?ref=0ca5af51abe63d31a944080e63f04ff3525363e6", "patch": "@@ -1117,6 +1117,8 @@ adjust_field_rtx_def (type_p t, options_p ARG_UNUSED (opt))\n \t\tt = scalar_tp, subname = \"rt_int\";\n \t      else if (i == VALUE && aindex == 0)\n \t\tt = scalar_tp, subname = \"rt_int\";\n+\t      else if (i == DEBUG_EXPR && aindex == 0)\n+\t\tt = tree_tp, subname = \"rt_tree\";\n \t      else if (i == REG && aindex == 1)\n \t\tt = scalar_tp, subname = \"rt_int\";\n \t      else if (i == REG && aindex == 2)"}, {"sha": "c3ca0e37501baf56db86193c6cf6a196bc6507a3", "filename": "gcc/gimple-iterator.c", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ca5af51abe63d31a944080e63f04ff3525363e6/gcc%2Fgimple-iterator.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ca5af51abe63d31a944080e63f04ff3525363e6/gcc%2Fgimple-iterator.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-iterator.c?ref=0ca5af51abe63d31a944080e63f04ff3525363e6", "patch": "@@ -358,7 +358,8 @@ gsi_split_seq_before (gimple_stmt_iterator *i)\n \n /* Replace the statement pointed-to by GSI to STMT.  If UPDATE_EH_INFO\n    is true, the exception handling information of the original\n-   statement is moved to the new statement.  */\n+   statement is moved to the new statement.  Assignments must only be\n+   replaced with assignments to the same LHS.  */\n \n void\n gsi_replace (gimple_stmt_iterator *gsi, gimple stmt, bool update_eh_info)\n@@ -368,6 +369,9 @@ gsi_replace (gimple_stmt_iterator *gsi, gimple stmt, bool update_eh_info)\n   if (stmt == orig_stmt)\n     return;\n \n+  gcc_assert (!gimple_has_lhs (orig_stmt)\n+\t      || gimple_get_lhs (orig_stmt) == gimple_get_lhs (stmt));\n+\n   gimple_set_location (stmt, gimple_location (orig_stmt));\n   gimple_set_bb (stmt, gsi_bb (*gsi));\n \n@@ -470,6 +474,8 @@ gsi_remove (gimple_stmt_iterator *i, bool remove_permanently)\n   gimple_seq_node cur, next, prev;\n   gimple stmt = gsi_stmt (*i);\n \n+  insert_debug_temps_for_defs (i);\n+\n   /* Free all the data flow information for STMT.  */\n   gimple_set_bb (stmt, NULL);\n   delink_stmt_imm_use (stmt);"}, {"sha": "5ba5e634a66a59e915f9ec714ffde4208e19bb6b", "filename": "gcc/print-rtl.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ca5af51abe63d31a944080e63f04ff3525363e6/gcc%2Fprint-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ca5af51abe63d31a944080e63f04ff3525363e6/gcc%2Fprint-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-rtl.c?ref=0ca5af51abe63d31a944080e63f04ff3525363e6", "patch": "@@ -316,6 +316,12 @@ print_rtx (const_rtx in_rtx)\n \t    fprintf (outfile, \" %i\", val->value);\n \t    dump_addr (outfile, \" @\", in_rtx);\n \t    dump_addr (outfile, \"/\", (void*)val);\n+#endif\n+\t  }\n+\telse if (i == 0 && GET_CODE (in_rtx) == DEBUG_EXPR)\n+\t  {\n+#ifndef GENERATOR_FILE\n+\t    fprintf (outfile, \" D#%i\", DEBUG_TEMP_UID (XTREE (in_rtx, 0)));\n #endif\n \t  }\n \tbreak;"}, {"sha": "53a4992f4829b5330e949a4ece40d4dfeb42118a", "filename": "gcc/rtl.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ca5af51abe63d31a944080e63f04ff3525363e6/gcc%2Frtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ca5af51abe63d31a944080e63f04ff3525363e6/gcc%2Frtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.c?ref=0ca5af51abe63d31a944080e63f04ff3525363e6", "patch": "@@ -232,6 +232,8 @@ copy_rtx (rtx orig)\n   switch (code)\n     {\n     case REG:\n+    case DEBUG_EXPR:\n+    case VALUE:\n     case CONST_INT:\n     case CONST_DOUBLE:\n     case CONST_FIXED:\n@@ -381,6 +383,7 @@ rtx_equal_p_cb (const_rtx x, const_rtx y, rtx_equal_p_callback_function cb)\n     case SYMBOL_REF:\n       return XSTR (x, 0) == XSTR (y, 0);\n \n+    case DEBUG_EXPR:\n     case VALUE:\n     case SCRATCH:\n     case CONST_DOUBLE:\n@@ -496,6 +499,7 @@ rtx_equal_p (const_rtx x, const_rtx y)\n     case SYMBOL_REF:\n       return XSTR (x, 0) == XSTR (y, 0);\n \n+    case DEBUG_EXPR:\n     case VALUE:\n     case SCRATCH:\n     case CONST_DOUBLE:"}, {"sha": "acb7ee915b87d0c7c4b1348f124679bdf819c171", "filename": "gcc/rtl.def", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ca5af51abe63d31a944080e63f04ff3525363e6/gcc%2Frtl.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ca5af51abe63d31a944080e63f04ff3525363e6/gcc%2Frtl.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.def?ref=0ca5af51abe63d31a944080e63f04ff3525363e6", "patch": "@@ -88,6 +88,10 @@ DEF_RTL_EXPR(UNKNOWN, \"UnKnown\", \"*\", RTX_EXTRA)\n    DECL codes in trees.  */\n DEF_RTL_EXPR(VALUE, \"value\", \"0\", RTX_OBJ)\n \n+/* The RTL generated for a DEBUG_EXPR_DECL.  It links back to the\n+   DEBUG_EXPR_DECL in the first operand.  */\n+DEF_RTL_EXPR(DEBUG_EXPR, \"debug_expr\", \"0\", RTX_OBJ)\n+\n /* ---------------------------------------------------------------------\n    Expressions used in constructing lists.\n    --------------------------------------------------------------------- */"}, {"sha": "d95235ee3ec87d7ab4f79576c0040c30ae7adcba", "filename": "gcc/sched-vis.c", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ca5af51abe63d31a944080e63f04ff3525363e6/gcc%2Fsched-vis.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ca5af51abe63d31a944080e63f04ff3525363e6/gcc%2Fsched-vis.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-vis.c?ref=0ca5af51abe63d31a944080e63f04ff3525363e6", "patch": "@@ -521,6 +521,10 @@ print_value (char *buf, const_rtx x, int verbose)\n       cur = safe_concat (buf, cur, t);\n       cur = safe_concat (buf, cur, \"]\");\n       break;\n+    case DEBUG_EXPR:\n+      sprintf (t, \"D#%i\", DEBUG_TEMP_UID (XTREE (x, 0)));\n+      cur = safe_concat (buf, cur, t);\n+      break;\n     default:\n       print_exp (t, x, verbose);\n       cur = safe_concat (buf, cur, t);\n@@ -670,11 +674,18 @@ print_insn (char *buf, const_rtx x, int verbose)\n \tif (DECL_P (INSN_VAR_LOCATION_DECL (insn)))\n \t  {\n \t    tree id = DECL_NAME (INSN_VAR_LOCATION_DECL (insn));\n+\t    char idbuf[32];\n \t    if (id)\n \t      name = IDENTIFIER_POINTER (id);\n+\t    else if (TREE_CODE (INSN_VAR_LOCATION_DECL (insn))\n+\t\t     == DEBUG_EXPR_DECL)\n+\t      {\n+\t\tsprintf (idbuf, \"D#%i\",\n+\t\t\t DEBUG_TEMP_UID (INSN_VAR_LOCATION_DECL (insn)));\n+\t\tname = idbuf;\n+\t      }\n \t    else\n \t      {\n-\t\tchar idbuf[32];\n \t\tsprintf (idbuf, \"D.%i\",\n \t\t\t DECL_UID (INSN_VAR_LOCATION_DECL (insn)));\n \t\tname = idbuf;"}, {"sha": "7e2c9ab6ff49d60b00bbc25a6c6cad4bb554c216", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ca5af51abe63d31a944080e63f04ff3525363e6/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ca5af51abe63d31a944080e63f04ff3525363e6/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=0ca5af51abe63d31a944080e63f04ff3525363e6", "patch": "@@ -1,3 +1,13 @@\n+2009-10-12  Alexandre Oliva  <aoliva@redhat.com>\n+\n+\tPR debug/41343\n+\tPR debug/41447\n+\tPR debug/41264\n+\tPR debug/41338\n+\t* gcc.dg/guality/pr41447-1.c: New.\n+\t* gcc.dg/debug/pr41264-1.c: New.\n+\t* gcc.dg/debug/pr41343-1.c: New.\n+\n 2009-10-12  Hans-Peter Nilsson  <hp@axis.com>\n \n \tPR target/26515"}, {"sha": "b5555b554ba2ca01158739e7addee1fe94d4813b", "filename": "gcc/testsuite/gcc.dg/debug/pr41264-1.c", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ca5af51abe63d31a944080e63f04ff3525363e6/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fpr41264-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ca5af51abe63d31a944080e63f04ff3525363e6/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fpr41264-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fpr41264-1.c?ref=0ca5af51abe63d31a944080e63f04ff3525363e6", "patch": "@@ -0,0 +1,36 @@\n+/* { dg-do compile } */\n+\n+typedef unsigned int hashval_t;\n+static hashval_t __attribute__((always_inline))\n+iterative_hash_host_wide_int (long val, hashval_t val2)\n+{\n+  hashval_t a = (hashval_t) val;\n+  int zero = 0;\n+  hashval_t b = (hashval_t) (val >> (sizeof (hashval_t) * 8 + zero));\n+\n+  a -= b; a -= val2; a ^= (val2>>13);\n+  b -= val2; b -= a; b ^= (a<< 8);\n+  val2 -= a; val2 -= b; val2 ^= ((b&0xffffffff)>>13);\n+  a -= b; a -= val2; a ^= ((val2&0xffffffff)>>12);\n+  b -= val2; b -= a; b = (b ^ (a<<16)) & 0xffffffff;\n+  val2 -= a; val2 -= b; val2 = (val2 ^ (b>> 5)) & 0xffffffff;\n+  a -= b; a -= val2; a = (a ^ (val2>> 3)) & 0xffffffff;\n+  b -= val2; b -= a; b = (b ^ (a<<10)) & 0xffffffff;\n+  val2 -= a; val2 -= b; val2 = (val2 ^ (b>>15)) & 0xffffffff;\n+  return val2;\n+}\n+\n+hashval_t\n+bla (int nunits, int mode)\n+{\n+  hashval_t hashcode = 0;\n+\n+\n+  hashcode = iterative_hash_host_wide_int (14, hashcode);\n+  hashcode = iterative_hash_host_wide_int (nunits, hashcode);\n+  hashcode = iterative_hash_host_wide_int (mode, hashcode);\n+  if (nunits)\n+    return 0;\n+  else\n+    return hashcode;\n+}"}, {"sha": "6d56380383dad94b354223b5893cbc1fb0ecccd3", "filename": "gcc/testsuite/gcc.dg/debug/pr41343-1.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ca5af51abe63d31a944080e63f04ff3525363e6/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fpr41343-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ca5af51abe63d31a944080e63f04ff3525363e6/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fpr41343-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fpr41343-1.c?ref=0ca5af51abe63d31a944080e63f04ff3525363e6", "patch": "@@ -0,0 +1,20 @@\n+/* { dg-do compile } */\n+\n+#define X(new,old) int i ## new = i ## old + i ## old;\n+#define Y(pfx) X(pfx ## 1, pfx) \\\n+  X(pfx ## 2, pfx ## 1) \\\n+  X(pfx ## 3, pfx ## 2) \\\n+  X(pfx ## 4, pfx ## 3) \\\n+  X(pfx ## 5, pfx ## 4) \\\n+  X(pfx ## 6, pfx ## 5) \\\n+  X(pfx ## 7, pfx ## 6) \\\n+  X(pfx ## 8, pfx ## 7) \\\n+  X(pfx ## 9, pfx ## 8)\n+\n+void foo (int i1)\n+{\n+  Y(1)\n+  Y(11)\n+  Y(111)\n+  asm (\"\" : : \"X\" (i1));\n+}"}, {"sha": "675b03046614f5a7354af3e14f5519672c064169", "filename": "gcc/testsuite/gcc.dg/guality/pr41447-1.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ca5af51abe63d31a944080e63f04ff3525363e6/gcc%2Ftestsuite%2Fgcc.dg%2Fguality%2Fpr41447-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ca5af51abe63d31a944080e63f04ff3525363e6/gcc%2Ftestsuite%2Fgcc.dg%2Fguality%2Fpr41447-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fguality%2Fpr41447-1.c?ref=0ca5af51abe63d31a944080e63f04ff3525363e6", "patch": "@@ -0,0 +1,25 @@\n+/* { dg-do run { xfail *-*-* } } */\n+/* { dg-options \"-g -O2\" } */\n+\n+#include \"guality.h\"\n+\n+int a;\n+\n+int foo()\n+{\n+  int tmp = a;\n+  int tmp2 = a;\n+  int tmp3;\n+  int res;\n+  GUALCHKVAL (a);\n+  GUALCHKVAL (tmp);\n+  GUALCHKVAL (tmp2);\n+  a = 0;\n+  tmp3 = tmp2;\n+  GUALCHKVAL (a);\n+  GUALCHKVAL (tmp);\n+  GUALCHKVAL (tmp2);\n+  GUALCHKVAL (tmp3);\n+  res = tmp - tmp2 + 1;\n+  return res;\n+}"}, {"sha": "7b7a85f50825fe3153d88d970b24785c64f46f08", "filename": "gcc/tree-dump.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ca5af51abe63d31a944080e63f04ff3525363e6/gcc%2Ftree-dump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ca5af51abe63d31a944080e63f04ff3525363e6/gcc%2Ftree-dump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-dump.c?ref=0ca5af51abe63d31a944080e63f04ff3525363e6", "patch": "@@ -511,6 +511,10 @@ dequeue_and_dump (dump_info_p di)\n       dump_child (\"cnst\", DECL_INITIAL (t));\n       break;\n \n+    case DEBUG_EXPR_DECL:\n+      dump_int (di, \"-uid\", DEBUG_TEMP_UID (t));\n+      /* Fall through.  */\n+\n     case VAR_DECL:\n     case PARM_DECL:\n     case FIELD_DECL:"}, {"sha": "85f1f5ef60a5f30d916cd41577b06ac3f2319021", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ca5af51abe63d31a944080e63f04ff3525363e6/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ca5af51abe63d31a944080e63f04ff3525363e6/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=0ca5af51abe63d31a944080e63f04ff3525363e6", "patch": "@@ -637,10 +637,8 @@ typedef bool (*walk_use_def_chains_fn) (tree, gimple, void *);\n \n extern void walk_use_def_chains (tree, walk_use_def_chains_fn, void *, bool);\n \n-void propagate_defs_into_debug_stmts (gimple, basic_block,\n-\t\t\t\t      const gimple_stmt_iterator *);\n-void propagate_var_def_into_debug_stmts (tree, basic_block,\n-\t\t\t\t\t const gimple_stmt_iterator *);\n+void insert_debug_temps_for_defs (gimple_stmt_iterator *);\n+void insert_debug_temp_for_var_def (gimple_stmt_iterator *, tree);\n void release_defs_bitset (bitmap toremove);\n \n /* In tree-into-ssa.c  */"}, {"sha": "cfc20a178ea1c03d0b5c4c7778cc55eaea214025", "filename": "gcc/tree-pretty-print.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ca5af51abe63d31a944080e63f04ff3525363e6/gcc%2Ftree-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ca5af51abe63d31a944080e63f04ff3525363e6/gcc%2Ftree-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pretty-print.c?ref=0ca5af51abe63d31a944080e63f04ff3525363e6", "patch": "@@ -183,6 +183,8 @@ dump_decl_name (pretty_printer *buffer, tree node, int flags)\n     {\n       if (TREE_CODE (node) == LABEL_DECL && LABEL_DECL_UID (node) != -1)\n         pp_printf (buffer, \"L.%d\", (int) LABEL_DECL_UID (node));\n+      else if (TREE_CODE (node) == DEBUG_EXPR_DECL)\n+\tpp_printf (buffer, \"D#%i\", DEBUG_TEMP_UID (node));\n       else\n \t{\n \t  char c = TREE_CODE (node) == CONST_DECL ? 'C' : 'D';\n@@ -1051,6 +1053,7 @@ dump_generic_node (pretty_printer *buffer, tree node, int spc, int flags,\n     case VAR_DECL:\n     case PARM_DECL:\n     case FIELD_DECL:\n+    case DEBUG_EXPR_DECL:\n     case NAMESPACE_DECL:\n       dump_decl_name (buffer, node, flags);\n       break;"}, {"sha": "7dd07c1ca2c780ed5e998713967e92ea7d31e72a", "filename": "gcc/tree-ssa-dce.c", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ca5af51abe63d31a944080e63f04ff3525363e6/gcc%2Ftree-ssa-dce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ca5af51abe63d31a944080e63f04ff3525363e6/gcc%2Ftree-ssa-dce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dce.c?ref=0ca5af51abe63d31a944080e63f04ff3525363e6", "patch": "@@ -325,7 +325,13 @@ mark_stmt_if_obviously_necessary (gimple stmt, bool aggressive)\n       break;\n \n     case GIMPLE_DEBUG:\n-      mark_stmt_necessary (stmt, false);\n+      /* Debug temps without a value are not useful.  ??? If we could\n+\t easily locate the debug temp bind stmt for a use thereof,\n+\t would could refrain from marking all debug temps here, and\n+\t mark them only if they're used.  */\n+      if (gimple_debug_bind_has_value_p (stmt)\n+\t  || TREE_CODE (gimple_debug_bind_get_var (stmt)) != DEBUG_EXPR_DECL)\n+\tmark_stmt_necessary (stmt, false);\n       return;\n \n     case GIMPLE_GOTO:\n@@ -1071,7 +1077,7 @@ eliminate_unnecessary_stmts (void)\n {\n   bool something_changed = false;\n   basic_block bb;\n-  gimple_stmt_iterator gsi;\n+  gimple_stmt_iterator gsi, psi;\n   gimple stmt;\n   tree call;\n   VEC (basic_block, heap) *h;\n@@ -1111,25 +1117,20 @@ eliminate_unnecessary_stmts (void)\n       bb = VEC_pop (basic_block, h);\n \n       /* Remove dead statements.  */\n-      for (gsi = gsi_last_bb (bb); !gsi_end_p (gsi);)\n+      for (gsi = gsi_last_bb (bb); !gsi_end_p (gsi); gsi = psi)\n \t{\n \t  stmt = gsi_stmt (gsi);\n \n+\t  psi = gsi;\n+\t  gsi_prev (&psi);\n+\n \t  stats.total++;\n \n \t  /* If GSI is not necessary then remove it.  */\n \t  if (!gimple_plf (stmt, STMT_NECESSARY))\n \t    {\n \t      remove_dead_stmt (&gsi, bb);\n \t      something_changed = true;\n-\n-\t      /* If stmt was the last stmt in the block, we want to\n-\t\t move gsi to the stmt that became the last stmt, but\n-\t\t gsi_prev would crash.  */\n-\t      if (gsi_end_p (gsi))\n-\t\tgsi = gsi_last_bb (bb);\n-\t      else\n-\t\tgsi_prev (&gsi);\n \t    }\n \t  else if (is_gimple_call (stmt))\n \t    {\n@@ -1159,10 +1160,7 @@ eliminate_unnecessary_stmts (void)\n \t\t    }\n \t\t  notice_special_calls (stmt);\n \t\t}\n-\t      gsi_prev (&gsi);\n \t    }\n-\t  else\n-\t    gsi_prev (&gsi);\n \t}\n     }\n "}, {"sha": "6ba800d8288773b2743362c51605b378741e5814", "filename": "gcc/tree-ssa-forwprop.c", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ca5af51abe63d31a944080e63f04ff3525363e6/gcc%2Ftree-ssa-forwprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ca5af51abe63d31a944080e63f04ff3525363e6/gcc%2Ftree-ssa-forwprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-forwprop.c?ref=0ca5af51abe63d31a944080e63f04ff3525363e6", "patch": "@@ -939,7 +939,6 @@ forward_propagate_addr_expr (tree name, tree rhs)\n   gimple use_stmt;\n   bool all = true;\n   bool single_use_p = has_single_use (name);\n-  bool debug = false;\n \n   FOR_EACH_IMM_USE_STMT (use_stmt, iter, name)\n     {\n@@ -950,9 +949,7 @@ forward_propagate_addr_expr (tree name, tree rhs)\n \t there is nothing we can do.  */\n       if (gimple_code (use_stmt) != GIMPLE_ASSIGN)\n \t{\n-\t  if (is_gimple_debug (use_stmt))\n-\t    debug = true;\n-\t  else\n+\t  if (!is_gimple_debug (use_stmt))\n \t    all = false;\n \t  continue;\n \t}\n@@ -995,9 +992,6 @@ forward_propagate_addr_expr (tree name, tree rhs)\n \t}\n     }\n \n-  if (all && debug)\n-    propagate_var_def_into_debug_stmts (name, NULL, NULL);\n-\n   return all;\n }\n "}, {"sha": "6c6a9f17a1d5ea68de5e2a3695ecc480bcd28a9d", "filename": "gcc/tree-ssa-loop-im.c", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ca5af51abe63d31a944080e63f04ff3525363e6/gcc%2Ftree-ssa-loop-im.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ca5af51abe63d31a944080e63f04ff3525363e6/gcc%2Ftree-ssa-loop-im.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-im.c?ref=0ca5af51abe63d31a944080e63f04ff3525363e6", "patch": "@@ -764,6 +764,7 @@ rewrite_reciprocal (gimple_stmt_iterator *bsi)\n   gimple stmt, stmt1, stmt2;\n   tree var, name, lhs, type;\n   tree real_one;\n+  gimple_stmt_iterator gsi;\n \n   stmt = gsi_stmt (*bsi);\n   lhs = gimple_assign_lhs (stmt);\n@@ -798,8 +799,9 @@ rewrite_reciprocal (gimple_stmt_iterator *bsi)\n   /* Replace division stmt with reciprocal and multiply stmts.\n      The multiply stmt is not invariant, so update iterator\n      and avoid rescanning.  */\n-  gsi_replace (bsi, stmt1, true);\n-  gsi_insert_after (bsi, stmt2, GSI_NEW_STMT);\n+  gsi = *bsi;\n+  gsi_insert_before (bsi, stmt1, GSI_NEW_STMT);\n+  gsi_replace (&gsi, stmt2, true);\n \n   /* Continue processing with invariant reciprocal statement.  */\n   return stmt1;\n@@ -858,6 +860,8 @@ rewrite_bittest (gimple_stmt_iterator *bsi)\n   if (outermost_invariant_loop (b, loop_containing_stmt (stmt1)) != NULL\n       && outermost_invariant_loop (a, loop_containing_stmt (stmt1)) == NULL)\n     {\n+      gimple_stmt_iterator rsi;\n+\n       /* 1 << B */\n       var = create_tmp_var (TREE_TYPE (a), \"shifttmp\");\n       add_referenced_var (var);\n@@ -878,9 +882,14 @@ rewrite_bittest (gimple_stmt_iterator *bsi)\n       SET_USE (use, name);\n       gimple_cond_set_rhs (use_stmt, build_int_cst_type (TREE_TYPE (name), 0));\n \n-      gsi_insert_before (bsi, stmt1, GSI_SAME_STMT);\n-      propagate_defs_into_debug_stmts (gsi_stmt (*bsi), NULL, NULL);\n-      gsi_replace (bsi, stmt2, true);\n+      /* Don't use gsi_replace here, none of the new assignments sets\n+\t the variable originally set in stmt.  Move bsi to stmt1, and\n+\t then remove the original stmt, so that we get a chance to\n+\t retain debug info for it.  */\n+      rsi = *bsi;\n+      gsi_insert_before (bsi, stmt1, GSI_NEW_STMT);\n+      gsi_insert_before (&rsi, stmt2, GSI_SAME_STMT);\n+      gsi_remove (&rsi, true);\n \n       return stmt1;\n     }\n@@ -1060,7 +1069,6 @@ move_computations_stmt (struct dom_walk_data *dw_data ATTRIBUTE_UNUSED,\n \n       mark_virtual_ops_for_renaming (stmt);\n       gsi_insert_on_edge (loop_preheader_edge (level), stmt);\n-      propagate_defs_into_debug_stmts (gsi_stmt (bsi), NULL, NULL);\n       gsi_remove (&bsi, false);\n     }\n }"}, {"sha": "6af31a437ea50a2c7f69b4540672bbabf8f1ea68", "filename": "gcc/tree-ssa-operands.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ca5af51abe63d31a944080e63f04ff3525363e6/gcc%2Ftree-ssa-operands.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ca5af51abe63d31a944080e63f04ff3525363e6/gcc%2Ftree-ssa-operands.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-operands.c?ref=0ca5af51abe63d31a944080e63f04ff3525363e6", "patch": "@@ -894,6 +894,10 @@ get_expr_operands (gimple stmt, tree *expr_p, int flags)\n       add_stmt_operand (expr_p, stmt, flags);\n       return;\n \n+    case DEBUG_EXPR_DECL:\n+      gcc_assert (gimple_debug_bind_p (stmt));\n+      return;\n+\n     case MISALIGNED_INDIRECT_REF:\n       get_expr_operands (stmt, &TREE_OPERAND (expr, 1), flags);\n       /* fall through */"}, {"sha": "5136aee5d32ba7bfef2829ada1a656a6c25f27c7", "filename": "gcc/tree-ssa-reassoc.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ca5af51abe63d31a944080e63f04ff3525363e6/gcc%2Ftree-ssa-reassoc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ca5af51abe63d31a944080e63f04ff3525363e6/gcc%2Ftree-ssa-reassoc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-reassoc.c?ref=0ca5af51abe63d31a944080e63f04ff3525363e6", "patch": "@@ -1405,7 +1405,6 @@ rewrite_expr_tree (gimple stmt, unsigned int opindex,\n \t    {\n \t      stmt2 = SSA_NAME_DEF_STMT (gimple_assign_rhs1 (stmt1));\n \t      gsirhs1 = gsi_for_stmt (stmt2);\n-\t      propagate_defs_into_debug_stmts (stmt2, gimple_bb (stmt), &gsinow);\n \t      gsi_move_before (&gsirhs1, &gsinow);\n \t      gsi_prev (&gsinow);\n \t      stmt1 = stmt2;\n@@ -1452,7 +1451,6 @@ linearize_expr (gimple stmt)\n \n   gsinow = gsi_for_stmt (stmt);\n   gsirhs = gsi_for_stmt (binrhs);\n-  propagate_defs_into_debug_stmts (binrhs, gimple_bb (stmt), &gsinow);\n   gsi_move_before (&gsirhs, &gsinow);\n \n   gimple_assign_set_rhs2 (stmt, gimple_assign_rhs1 (binrhs));"}, {"sha": "be3fb7145fdadbe027cb5f9d019b48429ec49be0", "filename": "gcc/tree-ssa-sink.c", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ca5af51abe63d31a944080e63f04ff3525363e6/gcc%2Ftree-ssa-sink.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ca5af51abe63d31a944080e63f04ff3525363e6/gcc%2Ftree-ssa-sink.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sink.c?ref=0ca5af51abe63d31a944080e63f04ff3525363e6", "patch": "@@ -385,9 +385,6 @@ statement_sink_location (gimple stmt, basic_block frombb,\n \n       *togsi = gsi_after_labels (commondom);\n \n-      if (debug_stmts)\n-\tpropagate_defs_into_debug_stmts (stmt, commondom, togsi);\n-\n       return true;\n     }\n \n@@ -406,8 +403,6 @@ statement_sink_location (gimple stmt, basic_block frombb,\n \n       *togsi = gsi_for_stmt (use);\n \n-      propagate_defs_into_debug_stmts (stmt, sinkbb, togsi);\n-\n       return true;\n     }\n \n@@ -441,8 +436,6 @@ statement_sink_location (gimple stmt, basic_block frombb,\n \n   *togsi = gsi_after_labels (sinkbb);\n \n-  propagate_defs_into_debug_stmts (stmt, sinkbb, togsi);\n-\n   return true;\n }\n "}, {"sha": "9858b109d037e0e0acc4c44772c2c0b059ef5823", "filename": "gcc/tree-ssa.c", "status": "modified", "additions": 143, "deletions": 97, "changes": 240, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ca5af51abe63d31a944080e63f04ff3525363e6/gcc%2Ftree-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ca5af51abe63d31a944080e63f04ff3525363e6/gcc%2Ftree-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa.c?ref=0ca5af51abe63d31a944080e63f04ff3525363e6", "patch": "@@ -295,152 +295,198 @@ find_released_ssa_name (tree *tp, int *walk_subtrees, void *data_)\n   return NULL_TREE;\n }\n \n-/* Given a VAR whose definition STMT is to be moved to the iterator\n-   position TOGSIP in the TOBB basic block, verify whether we're\n-   moving it across any of the debug statements that use it, and\n-   adjust them as needed.  If TOBB is NULL, then the definition is\n-   understood as being removed, and TOGSIP is unused.  */\n+/* Insert a DEBUG BIND stmt before the DEF of VAR if VAR is referenced\n+   by other DEBUG stmts, and replace uses of the DEF with the\n+   newly-created debug temp.  */\n+\n void\n-propagate_var_def_into_debug_stmts (tree var,\n-\t\t\t\t    basic_block tobb,\n-\t\t\t\t    const gimple_stmt_iterator *togsip)\n+insert_debug_temp_for_var_def (gimple_stmt_iterator *gsi, tree var)\n {\n   imm_use_iterator imm_iter;\n-  gimple stmt;\n   use_operand_p use_p;\n+  gimple stmt;\n+  gimple def_stmt = NULL;\n+  int usecount = 0;\n   tree value = NULL;\n-  bool no_value = false;\n \n   if (!MAY_HAVE_DEBUG_STMTS)\n     return;\n \n-  FOR_EACH_IMM_USE_STMT (stmt, imm_iter, var)\n+  /* First of all, check whether there are debug stmts that reference\n+     this variable and, if there are, decide whether we should use a\n+     debug temp.  */\n+  FOR_EACH_IMM_USE_FAST (use_p, imm_iter, var)\n     {\n-      basic_block bb;\n-      gimple_stmt_iterator si;\n+      stmt = USE_STMT (use_p);\n \n-      if (!is_gimple_debug (stmt))\n+      if (!gimple_debug_bind_p (stmt))\n \tcontinue;\n \n-      if (tobb)\n+      if (usecount++)\n+\tbreak;\n+\n+      if (gimple_debug_bind_get_value (stmt) != var)\n \t{\n-\t  bb = gimple_bb (stmt);\n+\t  /* Count this as an additional use, so as to make sure we\n+\t     use a temp unless VAR's definition has a SINGLE_RHS that\n+\t     can be shared.  */\n+\t  usecount++;\n+\t  break;\n+\t}\n+    }\n \n-\t  if (bb != tobb)\n-\t    {\n-\t      gcc_assert (dom_info_available_p (CDI_DOMINATORS));\n-\t      if (dominated_by_p (CDI_DOMINATORS, bb, tobb))\n-\t\tcontinue;\n-\t    }\n-\t  else\n-\t    {\n-\t      si = *togsip;\n+  if (!usecount)\n+    return;\n \n-\t      if (gsi_end_p (si))\n-\t\tcontinue;\n+  if (gsi)\n+    def_stmt = gsi_stmt (*gsi);\n+  else\n+    def_stmt = SSA_NAME_DEF_STMT (var);\n \n-\t      do\n-\t\t{\n-\t\t  gsi_prev (&si);\n-\t\t  if (gsi_end_p (si))\n-\t\t    break;\n-\t\t}\n-\t      while (gsi_stmt (si) != stmt);\n+  /* If we didn't get an insertion point, and the stmt has already\n+     been removed, we won't be able to insert the debug bind stmt, so\n+     we'll have to drop debug information.  */\n+  if (is_gimple_assign (def_stmt))\n+    {\n+      bool no_value = false;\n \n-\t      if (gsi_end_p (si))\n-\t\tcontinue;\n-\t    }\n+      if (!dom_info_available_p (CDI_DOMINATORS))\n+\t{\n+\t  struct walk_stmt_info wi;\n+\n+\t  memset (&wi, 0, sizeof (wi));\n+\n+\t  /* When removing blocks without following reverse dominance\n+\t     order, we may sometimes encounter SSA_NAMEs that have\n+\t     already been released, referenced in other SSA_DEFs that\n+\t     we're about to release.  Consider:\n+\n+\t     <bb X>:\n+\t     v_1 = foo;\n+\n+\t     <bb Y>:\n+\t     w_2 = v_1 + bar;\n+\t     # DEBUG w => w_2\n+\n+\t     If we deleted BB X first, propagating the value of w_2\n+\t     won't do us any good.  It's too late to recover their\n+\t     original definition of v_1: when it was deleted, it was\n+\t     only referenced in other DEFs, it couldn't possibly know\n+\t     it should have been retained, and propagating every\n+\t     single DEF just in case it might have to be propagated\n+\t     into a DEBUG STMT would probably be too wasteful.\n+\n+\t     When dominator information is not readily available, we\n+\t     check for and accept some loss of debug information.  But\n+\t     if it is available, there's no excuse for us to remove\n+\t     blocks in the wrong order, so we don't even check for\n+\t     dead SSA NAMEs.  SSA verification shall catch any\n+\t     errors.  */\n+\t  if ((!gsi && !gimple_bb (def_stmt))\n+\t      || !walk_gimple_op (def_stmt, find_released_ssa_name,\n+\t\t\t\t  &wi))\n+\t    no_value = true;\n \t}\n \n-      /* Here we compute (lazily) the value assigned to VAR, but we\n-\t remember if we tried before and failed, so that we don't try\n-\t again.  */\n-      if (!value && !no_value)\n+      if (!no_value)\n+\tvalue = gimple_assign_rhs_to_tree (def_stmt);\n+    }\n+\n+  if (value)\n+    {\n+      /* If there's a single use of VAR, and VAR is the entire debug\n+\t expression (usecount would have been incremented again\n+\t otherwise), and the definition involves only constants and\n+\t SSA names, then we can propagate VALUE into this single use,\n+\t avoiding the temp.\n+\n+\t We can also avoid using a temp if VALUE can be shared and\n+\t propagated into all uses, without generating expressions that\n+\t wouldn't be valid gimple RHSs.\n+\n+\t Other cases that would require unsharing or non-gimple RHSs\n+\t are deferred to a debug temp, although we could avoid temps\n+\t at the expense of duplication of expressions.  */\n+\n+      if (CONSTANT_CLASS_P (value)\n+\t  || (usecount == 1\n+\t      && (!gimple_assign_single_p (def_stmt)\n+\t\t  || is_gimple_min_invariant (value)))\n+\t  || is_gimple_reg (value))\n+\tvalue = unshare_expr (value);\n+      else\n \t{\n-\t  gimple def_stmt = SSA_NAME_DEF_STMT (var);\n+\t  gimple def_temp;\n+\t  tree vexpr = make_node (DEBUG_EXPR_DECL);\n \n-\t  if (is_gimple_assign (def_stmt))\n-\t    {\n-\t      if (!dom_info_available_p (CDI_DOMINATORS))\n-\t\t{\n-\t\t  struct walk_stmt_info wi;\n-\n-\t\t  memset (&wi, 0, sizeof (wi));\n-\n-\t\t  /* When removing blocks without following reverse\n-\t\t     dominance order, we may sometimes encounter SSA_NAMEs\n-\t\t     that have already been released, referenced in other\n-\t\t     SSA_DEFs that we're about to release.  Consider:\n-\n-\t\t     <bb X>:\n-\t\t     v_1 = foo;\n-\n-\t\t     <bb Y>:\n-\t\t     w_2 = v_1 + bar;\n-\t\t     # DEBUG w => w_2\n-\n-\t\t     If we deleted BB X first, propagating the value of\n-\t\t     w_2 won't do us any good.  It's too late to recover\n-\t\t     their original definition of v_1: when it was\n-\t\t     deleted, it was only referenced in other DEFs, it\n-\t\t     couldn't possibly know it should have been retained,\n-\t\t     and propagating every single DEF just in case it\n-\t\t     might have to be propagated into a DEBUG STMT would\n-\t\t     probably be too wasteful.\n-\n-\t\t     When dominator information is not readily\n-\t\t     available, we check for and accept some loss of\n-\t\t     debug information.  But if it is available,\n-\t\t     there's no excuse for us to remove blocks in the\n-\t\t     wrong order, so we don't even check for dead SSA\n-\t\t     NAMEs.  SSA verification shall catch any\n-\t\t     errors.  */\n-\t\t  if (!walk_gimple_op (def_stmt, find_released_ssa_name, &wi))\n-\t\t    no_value = true;\n-\t\t}\n+\t  def_temp = gimple_build_debug_bind (vexpr,\n+\t\t\t\t\t      unshare_expr (value),\n+\t\t\t\t\t      def_stmt);\n+\n+\t  DECL_ARTIFICIAL (vexpr) = 1;\n+\t  TREE_TYPE (vexpr) = TREE_TYPE (value);\n+\t  if (DECL_P (value))\n+\t    DECL_MODE (vexpr) = DECL_MODE (value);\n+\t  else\n+\t    DECL_MODE (vexpr) = TYPE_MODE (TREE_TYPE (value));\n \n-\t      if (!no_value)\n-\t\tvalue = gimple_assign_rhs_to_tree (def_stmt);\n+\t  if (gsi)\n+\t    gsi_insert_before (gsi, def_temp, GSI_SAME_STMT);\n+\t  else\n+\t    {\n+\t      gimple_stmt_iterator ngsi = gsi_for_stmt (def_stmt);\n+\t      gsi_insert_before (&ngsi, def_temp, GSI_SAME_STMT);\n \t    }\n \n-\t  if (!value)\n-\t    no_value = true;\n+\t  value = vexpr;\n \t}\n+    }\n \n-      if (no_value)\n-\tgimple_debug_bind_reset_value (stmt);\n-      else\n+  FOR_EACH_IMM_USE_STMT (stmt, imm_iter, var)\n+    {\n+      if (!gimple_debug_bind_p (stmt))\n+\tcontinue;\n+\n+      if (value)\n \tFOR_EACH_IMM_USE_ON_STMT (use_p, imm_iter)\n-\t  SET_USE (use_p, unshare_expr (value));\n+\t  /* unshare_expr is not needed here.  vexpr is either a\n+\t     SINGLE_RHS, that can be safely shared, some other RHS\n+\t     that was unshared when we found it had a single debug\n+\t     use, or a DEBUG_EXPR_DECL, that can be safely\n+\t     shared.  */\n+\t  SET_USE (use_p, value);\n+      else\n+\tgimple_debug_bind_reset_value (stmt);\n \n       update_stmt (stmt);\n     }\n }\n \n \n-/* Given a STMT to be moved to the iterator position TOBSIP in the\n-   TOBB basic block, verify whether we're moving it across any of the\n-   debug statements that use it.  If TOBB is NULL, then the definition\n-   is understood as being removed, and TOBSIP is unused.  */\n+/* Insert a DEBUG BIND stmt before STMT for each DEF referenced by\n+   other DEBUG stmts, and replace uses of the DEF with the\n+   newly-created debug temp.  */\n \n void\n-propagate_defs_into_debug_stmts (gimple def, basic_block tobb,\n-\t\t\t\t const gimple_stmt_iterator *togsip)\n+insert_debug_temps_for_defs (gimple_stmt_iterator *gsi)\n {\n+  gimple stmt;\n   ssa_op_iter op_iter;\n   def_operand_p def_p;\n \n   if (!MAY_HAVE_DEBUG_STMTS)\n     return;\n \n-  FOR_EACH_SSA_DEF_OPERAND (def_p, def, op_iter, SSA_OP_DEF)\n+  stmt = gsi_stmt (*gsi);\n+\n+  FOR_EACH_SSA_DEF_OPERAND (def_p, stmt, op_iter, SSA_OP_DEF)\n     {\n       tree var = DEF_FROM_PTR (def_p);\n \n       if (TREE_CODE (var) != SSA_NAME)\n \tcontinue;\n \n-      propagate_var_def_into_debug_stmts (var, tobb, togsip);\n+      insert_debug_temp_for_var_def (gsi, var);\n     }\n }\n "}, {"sha": "bb0880260ffcce8f7830c764c3e87628a444dc85", "filename": "gcc/tree-ssanames.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ca5af51abe63d31a944080e63f04ff3525363e6/gcc%2Ftree-ssanames.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ca5af51abe63d31a944080e63f04ff3525363e6/gcc%2Ftree-ssanames.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssanames.c?ref=0ca5af51abe63d31a944080e63f04ff3525363e6", "patch": "@@ -206,7 +206,7 @@ release_ssa_name (tree var)\n       use_operand_p imm = &(SSA_NAME_IMM_USE_NODE (var));\n \n       if (MAY_HAVE_DEBUG_STMTS)\n-\tpropagate_var_def_into_debug_stmts (var, NULL, NULL);\n+\tinsert_debug_temp_for_var_def (NULL, var);\n \n #ifdef ENABLE_CHECKING\n       verify_imm_links (stderr, var);"}, {"sha": "9e463c048726d9b502b796c2b599a0d9f78ca8b8", "filename": "gcc/tree.c", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ca5af51abe63d31a944080e63f04ff3525363e6/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ca5af51abe63d31a944080e63f04ff3525363e6/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=0ca5af51abe63d31a944080e63f04ff3525363e6", "patch": "@@ -152,6 +152,9 @@ static const char * const tree_node_kind_names[] = {\n static GTY(()) int next_decl_uid;\n /* Unique id for next type created.  */\n static GTY(()) int next_type_uid = 1;\n+/* Unique id for next debug decl created.  Use negative numbers,\n+   to catch erroneous uses.  */\n+static GTY(()) int next_debug_decl_uid;\n \n /* Since we cannot rehash a type after it is in the table, we have to\n    keep the hash code.  */\n@@ -872,7 +875,10 @@ make_node_stat (enum tree_code code MEM_STAT_DECL)\n \t    DECL_ALIGN (t) = 1;\n \t}\n       DECL_SOURCE_LOCATION (t) = input_location;\n-      DECL_UID (t) = next_decl_uid++;\n+      if (TREE_CODE (t) == DEBUG_EXPR_DECL)\n+\tDECL_UID (t) = --next_debug_decl_uid;\n+      else\n+\tDECL_UID (t) = next_decl_uid++;\n       if (TREE_CODE (t) == LABEL_DECL)\n \tLABEL_DECL_UID (t) = -1;\n \n@@ -948,7 +954,10 @@ copy_node_stat (tree node MEM_STAT_DECL)\n \n   if (TREE_CODE_CLASS (code) == tcc_declaration)\n     {\n-      DECL_UID (t) = next_decl_uid++;\n+      if (code == DEBUG_EXPR_DECL)\n+\tDECL_UID (t) = --next_debug_decl_uid;\n+      else\n+\tDECL_UID (t) = next_decl_uid++;\n       if ((TREE_CODE (node) == PARM_DECL || TREE_CODE (node) == VAR_DECL)\n \t  && DECL_HAS_VALUE_EXPR_P (node))\n \t{"}, {"sha": "01d91b76a6fc3a736194bf8eb4bbdd604f48964f", "filename": "gcc/tree.def", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ca5af51abe63d31a944080e63f04ff3525363e6/gcc%2Ftree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ca5af51abe63d31a944080e63f04ff3525363e6/gcc%2Ftree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.def?ref=0ca5af51abe63d31a944080e63f04ff3525363e6", "patch": "@@ -351,6 +351,10 @@ DEFTREECODE (PARM_DECL, \"parm_decl\", tcc_declaration, 0)\n DEFTREECODE (TYPE_DECL, \"type_decl\", tcc_declaration, 0)\n DEFTREECODE (RESULT_DECL, \"result_decl\", tcc_declaration, 0)\n \n+/* A \"declaration\" of a debug temporary.  It should only appear in\n+   DEBUG stmts.  */\n+DEFTREECODE (DEBUG_EXPR_DECL, \"debug_expr_decl\", tcc_declaration, 0)\n+\n /* A namespace declaration.  Namespaces appear in DECL_CONTEXT of other\n    _DECLs, providing a hierarchy of names.  */\n DEFTREECODE (NAMESPACE_DECL, \"namespace_decl\", tcc_declaration, 0)"}, {"sha": "2487a1ce9fedaf5966e04020da8b795729004078", "filename": "gcc/tree.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ca5af51abe63d31a944080e63f04ff3525363e6/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ca5af51abe63d31a944080e63f04ff3525363e6/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=0ca5af51abe63d31a944080e63f04ff3525363e6", "patch": "@@ -2455,6 +2455,10 @@ struct function;\n /* Every ..._DECL node gets a unique number.  */\n #define DECL_UID(NODE) (DECL_MINIMAL_CHECK (NODE)->decl_minimal.uid)\n \n+/* DEBUG_EXPR_DECLs get negative UID numbers, to catch erroneous\n+   uses.  */\n+#define DEBUG_TEMP_UID(NODE) (-DECL_UID (TREE_CHECK ((NODE), DEBUG_EXPR_DECL)))\n+\n /* These two fields describe where in the source code the declaration\n    was.  If the declaration appears in several places (as for a C\n    function that is declared first and then defined later), this"}, {"sha": "840128cf7c817249f053d7397b1a6a97ab735294", "filename": "gcc/var-tracking.c", "status": "modified", "additions": 29, "deletions": 12, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ca5af51abe63d31a944080e63f04ff3525363e6/gcc%2Fvar-tracking.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ca5af51abe63d31a944080e63f04ff3525363e6/gcc%2Fvar-tracking.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvar-tracking.c?ref=0ca5af51abe63d31a944080e63f04ff3525363e6", "patch": "@@ -732,6 +732,7 @@ dv_is_decl_p (decl_or_value dv)\n     case (int)PARM_DECL:\n     case (int)RESULT_DECL:\n     case (int)FUNCTION_DECL:\n+    case (int)DEBUG_EXPR_DECL:\n     case (int)COMPONENT_REF:\n       return true;\n \n@@ -2222,7 +2223,7 @@ dataflow_set_union (dataflow_set *dst, dataflow_set *src)\n \n /* Whether the value is currently being expanded.  */\n #define VALUE_RECURSED_INTO(x) \\\n-  (RTL_FLAG_CHECK1 (\"VALUE_RECURSED_INTO\", (x), VALUE)->used)\n+  (RTL_FLAG_CHECK2 (\"VALUE_RECURSED_INTO\", (x), VALUE, DEBUG_EXPR)->used)\n /* Whether the value is in changed_variables hash table.  */\n #define VALUE_CHANGED(x) \\\n   (RTL_FLAG_CHECK1 (\"VALUE_CHANGED\", (x), VALUE)->frame_related)\n@@ -4112,6 +4113,9 @@ track_expr_p (tree expr, bool need_rtl)\n   rtx decl_rtl;\n   tree realdecl;\n \n+  if (TREE_CODE (expr) == DEBUG_EXPR_DECL)\n+    return DECL_RTL_SET_P (expr);\n+\n   /* If EXPR is not a parameter or a variable do not track it.  */\n   if (TREE_CODE (expr) != VAR_DECL && TREE_CODE (expr) != PARM_DECL)\n     return 0;\n@@ -6271,11 +6275,12 @@ vt_expand_loc_callback (rtx x, bitmap regs, int max_depth, void *data)\n   decl_or_value dv;\n   variable var;\n   location_chain loc;\n-  rtx result;\n+  rtx result, subreg, xret;\n \n-  if (GET_CODE (x) == SUBREG)\n+  switch (GET_CODE (x))\n     {\n-      rtx subreg = SUBREG_REG (x);\n+    case SUBREG:\n+      subreg = SUBREG_REG (x);\n \n       if (GET_CODE (SUBREG_REG (x)) != VALUE)\n \treturn x;\n@@ -6297,22 +6302,31 @@ vt_expand_loc_callback (rtx x, bitmap regs, int max_depth, void *data)\n \tresult = gen_rtx_raw_SUBREG (GET_MODE (x), subreg, SUBREG_BYTE (x));\n \n       return result;\n-    }\n \n-  if (GET_CODE (x) != VALUE)\n-    return x;\n+    case DEBUG_EXPR:\n+      dv = dv_from_decl (XTREE (x, 0));\n+      xret = NULL;\n+      break;\n+\n+    case VALUE:\n+      dv = dv_from_value (x);\n+      xret = x;\n+      break;\n+\n+    default:\n+      return x;\n+    }\n \n   if (VALUE_RECURSED_INTO (x))\n-    return x;\n+    return NULL;\n \n-  dv = dv_from_value (x);\n   var = (variable) htab_find_with_hash (vars, dv, dv_htab_hash (dv));\n \n   if (!var)\n-    return x;\n+    return xret;\n \n   if (var->n_var_parts == 0)\n-    return x;\n+    return xret;\n \n   gcc_assert (var->n_var_parts == 1);\n \n@@ -6332,7 +6346,7 @@ vt_expand_loc_callback (rtx x, bitmap regs, int max_depth, void *data)\n   if (result)\n     return result;\n   else\n-    return x;\n+    return xret;\n }\n \n /* Expand VALUEs in LOC, using VARS as well as cselib's equivalence\n@@ -6382,6 +6396,9 @@ emit_note_insn_var_location (void **varp, void *data)\n \n   decl = dv_as_decl (var->dv);\n \n+  if (TREE_CODE (decl) == DEBUG_EXPR_DECL)\n+    goto clear;\n+\n   gcc_assert (decl);\n \n   complete = true;"}]}