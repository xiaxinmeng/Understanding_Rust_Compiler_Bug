{"sha": "ede68b7ba64ace5fbcb900b37c7e8572a2ddefb5", "node_id": "C_kwDOANBUbNoAKGVkZTY4YjdiYTY0YWNlNWZiY2I5MDBiMzdjN2U4NTcyYTJkZGVmYjU", "commit": {"author": {"name": "Arthur Cohen", "email": "arthur.cohen@embecosm.com", "date": "2022-02-26T10:10:38Z"}, "committer": {"name": "Arthur Cohen", "email": "arthur.cohen@embecosm.com", "date": "2022-02-26T12:21:46Z"}, "message": "lexer: Add ability to lex strings directly\n\nBy allowing us to parse strings directly instead of necessarily a\nfilename, we are now able to reuse the parser and lexer in various\nplaces of the compiler. This is useful for -frust-cfg, but may also come\nin handy for\nother compiler mechanics such as the include!() builtin macro, where we\ndo not actually want location info but just a stream of tokens.", "tree": {"sha": "94bd8e33757e8e019143fa8177e7d79ec8e6cd5d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/94bd8e33757e8e019143fa8177e7d79ec8e6cd5d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ede68b7ba64ace5fbcb900b37c7e8572a2ddefb5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ede68b7ba64ace5fbcb900b37c7e8572a2ddefb5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ede68b7ba64ace5fbcb900b37c7e8572a2ddefb5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ede68b7ba64ace5fbcb900b37c7e8572a2ddefb5/comments", "author": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "committer": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bf92a1012264f2544e73a7a8dd0ac1e473c7f658", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bf92a1012264f2544e73a7a8dd0ac1e473c7f658", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bf92a1012264f2544e73a7a8dd0ac1e473c7f658"}], "stats": {"total": 135, "additions": 84, "deletions": 51}, "files": [{"sha": "f620e15e1d31005af7b0fdafadf82609a685171e", "filename": "gcc/rust/lex/rust-lex.cc", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ede68b7ba64ace5fbcb900b37c7e8572a2ddefb5/gcc%2Frust%2Flex%2Frust-lex.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ede68b7ba64ace5fbcb900b37c7e8572a2ddefb5/gcc%2Frust%2Flex%2Frust-lex.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Flex%2Frust-lex.cc?ref=ede68b7ba64ace5fbcb900b37c7e8572a2ddefb5", "patch": "@@ -128,7 +128,8 @@ Lexer::Lexer (const char *filename, RAIIFile file_input, Linemap *linemap)\n     token_queue (TokenSource (this))\n {\n   // inform line_table that file is being entered and is in line 1\n-  line_map->start_file (filename, current_line);\n+  if (linemap)\n+    line_map->start_file (filename, current_line);\n }\n \n Lexer::~Lexer ()\n@@ -152,7 +153,11 @@ Lexer::~Lexer ()\n Location\n Lexer::get_current_location ()\n {\n-  return line_map->get_location (current_column);\n+  if (line_map)\n+    return line_map->get_location (current_column);\n+  else\n+    // If we have no linemap, we're lexing something without proper locations\n+    return Location ();\n }\n \n int"}, {"sha": "b0d7494f063ec6ede9067262665bf7771611af6b", "filename": "gcc/rust/lex/rust-lex.h", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ede68b7ba64ace5fbcb900b37c7e8572a2ddefb5/gcc%2Frust%2Flex%2Frust-lex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ede68b7ba64ace5fbcb900b37c7e8572a2ddefb5/gcc%2Frust%2Flex%2Frust-lex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Flex%2Frust-lex.h?ref=ede68b7ba64ace5fbcb900b37c7e8572a2ddefb5", "patch": "@@ -23,6 +23,7 @@\n #include \"rust-buffered-queue.h\"\n #include \"rust-token.h\"\n \n+#include <cstdio>\n #include <utility>\n #include <tuple>\n \n@@ -49,6 +50,13 @@ struct RAIIFile\n       file = fopen (filename, \"r\");\n   }\n \n+  /**\n+   * Create a RAIIFile from an existing instance of FILE*\n+   */\n+  RAIIFile (FILE *raw, const char *filename = nullptr)\n+    : file (raw), filename (filename)\n+  {}\n+\n   RAIIFile (const RAIIFile &other) = delete;\n   RAIIFile &operator= (const RAIIFile &other) = delete;\n \n@@ -57,6 +65,7 @@ struct RAIIFile\n   {\n     other.file = nullptr;\n   }\n+\n   RAIIFile &operator= (RAIIFile &&other)\n   {\n     close ();\n@@ -132,6 +141,19 @@ class Lexer\n   Lexer (const char *filename, RAIIFile input, Linemap *linemap);\n   ~Lexer ();\n \n+  /**\n+   * Lex the contents of a string instead of a file\n+   */\n+  static Lexer lex_string (std::string &input)\n+  {\n+    // We can perform this ugly cast to a non-const char* since we're only\n+    // *reading* the string. This would not be valid if we were doing any\n+    // modification to it.\n+    auto string_file = fmemopen (&input[0], input.length (), \"r\");\n+\n+    return Lexer (nullptr, RAIIFile (string_file), nullptr);\n+  }\n+\n   // don't allow copy semantics (for now, at least)\n   Lexer (const Lexer &other) = delete;\n   Lexer &operator= (const Lexer &other) = delete;"}, {"sha": "54a64435a60cd21c119a0f38b4cd900bc8fce9ad", "filename": "gcc/rust/rust-session-manager.cc", "status": "modified", "additions": 50, "deletions": 47, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ede68b7ba64ace5fbcb900b37c7e8572a2ddefb5/gcc%2Frust%2Frust-session-manager.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ede68b7ba64ace5fbcb900b37c7e8572a2ddefb5/gcc%2Frust%2Frust-session-manager.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-session-manager.cc?ref=ede68b7ba64ace5fbcb900b37c7e8572a2ddefb5", "patch": "@@ -366,9 +366,11 @@ Session::handle_option (\n       Compile::Mangler::set_mangling (flag_rust_mangling);\n       break;\n \n-    case OPT_frust_cfg_:\n-      ret = handle_cfg_option (std::string (arg));\n-      break;\n+      case OPT_frust_cfg_: {\n+\tauto string_arg = std::string (arg);\n+\tret = handle_cfg_option (string_arg);\n+\tbreak;\n+      }\n \n     default:\n       break;\n@@ -378,7 +380,7 @@ Session::handle_option (\n }\n \n bool\n-Session::handle_cfg_option (const std::string &input)\n+Session::handle_cfg_option (std::string &input)\n {\n   std::string key;\n   std::string value;\n@@ -402,8 +404,8 @@ Session::handle_cfg_option (const std::string &input)\n   return true;\n }\n \n-/* Enables a certain dump depending on the name passed in. Returns true if name\n- * is valid, false otherwise. */\n+/* Enables a certain dump depending on the name passed in. Returns true if\n+ * name is valid, false otherwise. */\n bool\n Session::enable_dump (std::string arg)\n {\n@@ -532,8 +534,8 @@ Session::parse_file (const char *filename)\n    * line into crate root)\n    *  - injection (some lint checks or dummy, register builtin macros, crate\n    * injection)\n-   *  - expansion (expands all macros, maybe build test harness, AST validation,\n-   * maybe macro crate)\n+   *  - expansion (expands all macros, maybe build test harness, AST\n+   * validation, maybe macro crate)\n    *  - resolution (name resolution, type resolution, maybe feature checking,\n    * maybe buffered lints)\n    *  TODO not done */\n@@ -603,8 +605,8 @@ Session::parse_file (const char *filename)\n   if (saw_errors ())\n     return;\n \n-  // scan unused has to be done after type resolution since methods are resolved\n-  // at that point\n+  // scan unused has to be done after type resolution since methods are\n+  // resolved at that point\n   Resolver::ScanUnused::Scan ();\n \n   if (saw_errors ())\n@@ -638,11 +640,11 @@ Session::debug_dump_load_crates (Parser<Lexer> &parser)\n \n   /* TODO: search through inner attrs and see whether any of those attr paths\n    * contain \"no_core\", \"no_std\", \"compiler_builtins\". If so/not, save certain\n-   * crate names. In these names, insert items at beginning of crate items. This\n-   * is crate injection. Also, inject prelude use decl at beginning (first name\n-   * is assumed to be prelude - prelude is a use decl automatically generated to\n-   * enable using Option and Copy without qualifying it or importing it via\n-   * 'use' manually) */\n+   * crate names. In these names, insert items at beginning of crate items.\n+   * This is crate injection. Also, inject prelude use decl at beginning\n+   * (first name is assumed to be prelude - prelude is a use decl\n+   * automatically generated to enable using Option and Copy without\n+   * qualifying it or importing it via 'use' manually) */\n \n   std::vector<std::string> crate_names;\n   for (const auto &item : crate.items)\n@@ -695,8 +697,8 @@ Session::injection (AST::Crate &crate)\n \n   // register builtin macros\n   /* In rustc, builtin macros are divided into 3 categories depending on use -\n-   * \"bang\" macros, \"attr\" macros, and \"derive\" macros. I think the meanings of\n-   * these categories should be fairly obvious to anyone who has used rust.\n+   * \"bang\" macros, \"attr\" macros, and \"derive\" macros. I think the meanings\n+   * of these categories should be fairly obvious to anyone who has used rust.\n    * Builtin macro list by category: Bang\n    *      - asm\n    *      - assert\n@@ -739,8 +741,8 @@ Session::injection (AST::Crate &crate)\n    * rustc also has a \"quote\" macro that is defined differently and is\n    * supposedly not stable so eh. */\n   /* TODO: actually implement injection of these macros. In particular, derive\n-   * macros, cfg, and test should be prioritised since they seem to be used the\n-   * most. */\n+   * macros, cfg, and test should be prioritised since they seem to be used\n+   * the most. */\n \n   // crate injection\n   std::vector<std::string> names;\n@@ -804,11 +806,11 @@ Session::injection (AST::Crate &crate)\n   crate.items.insert (crate.items.begin (), std::move (use_decl));\n \n   /* TODO: potentially add checking attribute crate type? I can't figure out\n-   * what this does currently comment says \"Unconditionally collect crate types\n-   * from attributes to make them used\", which presumably refers to checking the\n-   * linkage info by \"crate_type\". It also seems to ensure that an invalid crate\n-   * type is not specified, so maybe just do that. Valid crate types: bin lib\n-   * dylib staticlib cdylib rlib proc-macro */\n+   * what this does currently comment says \"Unconditionally collect crate\n+   * types from attributes to make them used\", which presumably refers to\n+   * checking the linkage info by \"crate_type\". It also seems to ensure that\n+   * an invalid crate type is not specified, so maybe just do that. Valid\n+   * crate types: bin lib dylib staticlib cdylib rlib proc-macro */\n \n   rust_debug (\"finished injection\");\n }\n@@ -818,8 +820,8 @@ Session::expansion (AST::Crate &crate)\n {\n   rust_debug (\"started expansion\");\n \n-  /* rustc has a modification to windows PATH temporarily here, which may end up\n-   * being required */\n+  /* rustc has a modification to windows PATH temporarily here, which may end\n+   * up being required */\n \n   // create macro expansion config?\n   // if not, would at least have to configure recursion_limit\n@@ -1036,10 +1038,10 @@ TargetOptions::enable_implicit_feature_reqs (std::string feature)\n  * [types/values] or absolute paths)\n  *  - HIR lower (convert modified AST to simpler HIR [both expressions and\n  * module tree])\n- *  - resolve type aliases (replace any usages of type aliases with actual type\n- * [except associated types])\n- *  - resolve bind (iterate HIR tree and set binding annotations on all concrete\n- * types [avoids path lookups later])\n+ *  - resolve type aliases (replace any usages of type aliases with actual\n+ * type [except associated types])\n+ *  - resolve bind (iterate HIR tree and set binding annotations on all\n+ * concrete types [avoids path lookups later])\n  *  - resolve HIR markings (generate \"markings\" [e.g. for Copy/Send/Sync/...]\n  * for all types\n  *  - sort impls (small pass - sort impls into groups)\n@@ -1059,8 +1061,8 @@ TargetOptions::enable_implicit_feature_reqs (std::string feature)\n  * function calls)\n  *  - expand HIR reborrows (apply reborrow rules [taking '&mut *v' instead of\n  * 'v'])\n- *  - expand HIR erasedtype (replace all erased types 'impl Trait' with the true\n- * type)\n+ *  - expand HIR erasedtype (replace all erased types 'impl Trait' with the\n+ * true type)\n  *  - typecheck expressions (validate - double check that previous passes\n  * haven't broke type system rules)\n  *  - lower MIR (convert HIR exprs into a control-flow graph [MIR])\n@@ -1071,24 +1073,25 @@ TargetOptions::enable_implicit_feature_reqs (std::string feature)\n  *  - MIR optimise (perform various simple optimisations on the MIR - constant\n  * propagation, dead code elimination, borrow elimination, some inlining)\n  *  - MIR validate PO (re-validate the MIR)\n- *  - MIR validate full (optionally: perform expensive state-tracking validation\n- * on MIR)\n- *  - trans enumerate (enumerate all items needed for code generation, primarily\n- * types used for generics)\n- *  - trans auto impls (create magic trait impls as enumerated in previous pass)\n+ *  - MIR validate full (optionally: perform expensive state-tracking\n+ * validation on MIR)\n+ *  - trans enumerate (enumerate all items needed for code generation,\n+ * primarily types used for generics)\n+ *  - trans auto impls (create magic trait impls as enumerated in previous\n+ * pass)\n  *  - trans monomorph (generate monomorphised copies of all functions [with\n  * generics replaced with real types])\n- *  - MIR optimise inline (run optimisation again, this time with full type info\n- * [primarily for inlining])\n+ *  - MIR optimise inline (run optimisation again, this time with full type\n+ * info [primarily for inlining])\n  *  - HIR serialise (write out HIR dump [module tree and generic/inline MIR])\n  *  - trans codegen (generate final output file: emit C source file and call C\n  * compiler) */\n \n /* rustc compile pipeline (basic, in way less detail):\n  *  - parse input (parse .rs to AST)\n  *  - name resolution, macro expansion, and configuration (process AST\n- * recursively, resolving paths, expanding macros, processing #[cfg] nodes [i.e.\n- * maybe stripping stuff from AST])\n+ * recursively, resolving paths, expanding macros, processing #[cfg] nodes\n+ * [i.e. maybe stripping stuff from AST])\n  *  - lower to HIR\n  *  - type check and other analyses (e.g. privacy checking)\n  *  - lower to MIR and post-processing (and do stuff like borrow checking)\n@@ -1100,14 +1103,14 @@ TargetOptions::enable_implicit_feature_reqs (std::string feature)\n  *  - register plugins (attributes injection, set various options, register\n  * lints, load plugins)\n  *  - expansion/configure and expand (initial 'cfg' processing, 'loading\n- * compiler plugins', syntax expansion, secondary 'cfg' expansion, synthesis of\n- * a test harness if required, injection of any std lib dependency and prelude,\n- * and name resolution) - actually documented inline\n+ * compiler plugins', syntax expansion, secondary 'cfg' expansion, synthesis\n+ * of a test harness if required, injection of any std lib dependency and\n+ * prelude, and name resolution) - actually documented inline\n  *      - seeming pierced-together order: pre-AST expansion lint checks,\n  * registering builtin macros, crate injection, then expand all macros, then\n- * maybe build test harness, AST validation, maybe create a macro crate (if not\n- * rustdoc), name resolution, complete gated feature checking, add all buffered\n- * lints\n+ * maybe build test harness, AST validation, maybe create a macro crate (if\n+ * not rustdoc), name resolution, complete gated feature checking, add all\n+ * buffered lints\n  *  - create global context (lower to HIR)\n  *  - analysis on global context (HIR optimisations? create MIR?)\n  *  - code generation"}, {"sha": "99d16287973aae0f96c0f0115008d61805afb6d3", "filename": "gcc/rust/rust-session-manager.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ede68b7ba64ace5fbcb900b37c7e8572a2ddefb5/gcc%2Frust%2Frust-session-manager.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ede68b7ba64ace5fbcb900b37c7e8572a2ddefb5/gcc%2Frust%2Frust-session-manager.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-session-manager.h?ref=ede68b7ba64ace5fbcb900b37c7e8572a2ddefb5", "patch": "@@ -288,7 +288,7 @@ struct Session\n   void expansion (AST::Crate &crate);\n \n   // handle cfg_option\n-  bool handle_cfg_option (const std::string &data);\n+  bool handle_cfg_option (std::string &data);\n };\n } // namespace Rust\n "}, {"sha": "da0db00e1e7b040ab88ce239784e006a221c93fa", "filename": "gcc/rust/util/rust-hir-map.cc", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ede68b7ba64ace5fbcb900b37c7e8572a2ddefb5/gcc%2Frust%2Futil%2Frust-hir-map.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ede68b7ba64ace5fbcb900b37c7e8572a2ddefb5/gcc%2Frust%2Futil%2Frust-hir-map.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Futil%2Frust-hir-map.cc?ref=ede68b7ba64ace5fbcb900b37c7e8572a2ddefb5", "patch": "@@ -139,7 +139,10 @@ NodeId\n Mappings::get_next_node_id (CrateNum crateNum)\n {\n   auto it = nodeIdIter.find (crateNum);\n-  rust_assert (it != nodeIdIter.end ());\n+  // We're probably *not* parsing actual rust code... but mostly reusing\n+  // the parser in another way. Return 0\n+  if (it == nodeIdIter.end ())\n+    return 0;\n \n   auto id = it->second + 1;\n   nodeIdIter[crateNum] = id;"}]}