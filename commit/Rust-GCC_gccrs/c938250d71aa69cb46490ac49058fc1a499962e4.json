{"sha": "c938250d71aa69cb46490ac49058fc1a499962e4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzkzODI1MGQ3MWFhNjljYjQ2NDkwYWM0OTA1OGZjMWE0OTk5NjJlNA==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2005-06-07T10:17:34Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2005-06-07T10:17:34Z"}, "message": "re PR debug/21946 (Invalid DWARF2 debug info emitted)\n\n\tPR debug/21946\n\t* dwarf2out.c (add_loc_descr_op_piece): New function.\n\t(multiple_reg_loc_descriptor, concat_loc_descriptor,\n\tloc_descriptor): Use it.\n\t* var-tracking.c: Include regs.h and expr.h.\n\t(emit_note_insn_var_location): Skip over pieces where offset\n\tis smaller than previous offset plus previous piece mode size.\n\tOptimize adjacent hard registers or memory locations.\n\t* Makefile.in (var-tracking.o): Depend on $(REGS_H) and $(EXPR_H).\n\nFrom-SVN: r100706", "tree": {"sha": "3d83f825275a51b79b1350ef28d9e4102c823d54", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3d83f825275a51b79b1350ef28d9e4102c823d54"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c938250d71aa69cb46490ac49058fc1a499962e4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c938250d71aa69cb46490ac49058fc1a499962e4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c938250d71aa69cb46490ac49058fc1a499962e4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c938250d71aa69cb46490ac49058fc1a499962e4/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "2214de30422cc30ce6a88feefc97bc8329dd6c2c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2214de30422cc30ce6a88feefc97bc8329dd6c2c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2214de30422cc30ce6a88feefc97bc8329dd6c2c"}], "stats": {"total": 160, "additions": 132, "deletions": 28}, "files": [{"sha": "c56a403aa97de7c1ccd820ef7764da29b08266c3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c938250d71aa69cb46490ac49058fc1a499962e4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c938250d71aa69cb46490ac49058fc1a499962e4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c938250d71aa69cb46490ac49058fc1a499962e4", "patch": "@@ -1,3 +1,15 @@\n+2005-06-07  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR debug/21946\n+\t* dwarf2out.c (add_loc_descr_op_piece): New function.\n+\t(multiple_reg_loc_descriptor, concat_loc_descriptor,\n+\tloc_descriptor): Use it.\n+\t* var-tracking.c: Include regs.h and expr.h.\n+\t(emit_note_insn_var_location): Skip over pieces where offset\n+\tis smaller than previous offset plus previous piece mode size.\n+\tOptimize adjacent hard registers or memory locations.\n+\t* Makefile.in (var-tracking.o): Depend on $(REGS_H) and $(EXPR_H).\n+\n 2005-06-07  Richard Guenther  <rguenth@gcc.gnu.org>\n \n \t* c-typeck.c (c_finish_if_stmt): Use void_type_node as type"}, {"sha": "67c91e3430b5ca3cf43948f5aac522ef688b1cf8", "filename": "gcc/Makefile.in", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c938250d71aa69cb46490ac49058fc1a499962e4/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c938250d71aa69cb46490ac49058fc1a499962e4/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=c938250d71aa69cb46490ac49058fc1a499962e4", "patch": "@@ -2136,7 +2136,8 @@ df.o : df.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    $(BASIC_BLOCK_H) $(DF_H) bitmap.h sbitmap.h $(TM_P_H)\n var-tracking.o : var-tracking.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(RTL_H) $(TREE_H) hard-reg-set.h insn-config.h reload.h $(FLAGS_H) \\\n-   $(BASIC_BLOCK_H) output.h sbitmap.h alloc-pool.h $(FIBHEAP_H) $(HASHTAB_H)\n+   $(BASIC_BLOCK_H) output.h sbitmap.h alloc-pool.h $(FIBHEAP_H) $(HASHTAB_H) \\\n+   $(REGS_H) $(EXPR_H)\n conflict.o : conflict.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(OBSTACK_H) \\\n    $(HASHTAB_H) $(RTL_H) hard-reg-set.h $(BASIC_BLOCK_H)\n profile.o : profile.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\"}, {"sha": "e11cd806376605c64616f8bb3839ad89b7e2d5af", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 28, "deletions": 13, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c938250d71aa69cb46490ac49058fc1a499962e4/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c938250d71aa69cb46490ac49058fc1a499962e4/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=c938250d71aa69cb46490ac49058fc1a499962e4", "patch": "@@ -2659,6 +2659,7 @@ static const char *dwarf_stack_op_name (unsigned);\n static dw_loc_descr_ref new_loc_descr (enum dwarf_location_atom,\n \t\t\t\t       unsigned HOST_WIDE_INT, unsigned HOST_WIDE_INT);\n static void add_loc_descr (dw_loc_descr_ref *, dw_loc_descr_ref);\n+static void add_loc_descr_op_piece (dw_loc_descr_ref *, int);\n static unsigned long size_of_loc_descr (dw_loc_descr_ref);\n static unsigned long size_of_locs (dw_loc_descr_ref);\n static void output_loc_operands (dw_loc_descr_ref);\n@@ -3011,6 +3012,27 @@ add_loc_descr (dw_loc_descr_ref *list_head, dw_loc_descr_ref descr)\n   *d = descr;\n }\n \n+\n+/* Optionally add a DW_OP_piece term to a location description expression.\n+   DW_OP_piece is only added if the location description expression already\n+   doesn't end with DW_OP_piece.  */\n+\n+static void\n+add_loc_descr_op_piece (dw_loc_descr_ref *list_head, int size)\n+{\n+  dw_loc_descr_ref loc;\n+\n+  if (*list_head != NULL)\n+    {\n+      /* Find the end of the chain.  */\n+      for (loc = *list_head; loc->dw_loc_next != NULL; loc = loc->dw_loc_next)\n+\t;\n+\n+      if (loc->dw_loc_opc != DW_OP_piece)\n+\tloc->dw_loc_next = new_loc_descr (DW_OP_piece, size, 0);\n+    }\n+}\n+\n /* Return the size of a location descriptor.  */\n \n static unsigned long\n@@ -8467,7 +8489,7 @@ multiple_reg_loc_descriptor (rtx rtl, rtx regs)\n \n \t  t = one_reg_loc_descriptor (reg);\n \t  add_loc_descr (&loc_result, t);\n-\t  add_loc_descr (&loc_result, new_loc_descr (DW_OP_piece, size, 0));\n+\t  add_loc_descr_op_piece (&loc_result, size);\n \t  ++reg;\n \t}\n       return loc_result;\n@@ -8487,7 +8509,7 @@ multiple_reg_loc_descriptor (rtx rtl, rtx regs)\n       t = one_reg_loc_descriptor (REGNO (XVECEXP (regs, 0, i)));\n       add_loc_descr (&loc_result, t);\n       size = GET_MODE_SIZE (GET_MODE (XVECEXP (regs, 0, 0)));\n-      add_loc_descr (&loc_result, new_loc_descr (DW_OP_piece, size, 0));\n+      add_loc_descr_op_piece (&loc_result, size);\n     }\n   return loc_result;\n }\n@@ -8790,14 +8812,10 @@ concat_loc_descriptor (rtx x0, rtx x1)\n     return 0;\n \n   cc_loc_result = x0_ref;\n-  add_loc_descr (&cc_loc_result,\n-\t\t new_loc_descr (DW_OP_piece,\n-\t\t\t\tGET_MODE_SIZE (GET_MODE (x0)), 0));\n+  add_loc_descr_op_piece (&cc_loc_result, GET_MODE_SIZE (GET_MODE (x0)));\n \n   add_loc_descr (&cc_loc_result, x1_ref);\n-  add_loc_descr (&cc_loc_result,\n-\t\t new_loc_descr (DW_OP_piece,\n-\t\t\t\tGET_MODE_SIZE (GET_MODE (x1)), 0));\n+  add_loc_descr_op_piece (&cc_loc_result, GET_MODE_SIZE (GET_MODE (x1)));\n \n   return cc_loc_result;\n }\n@@ -8862,8 +8880,7 @@ loc_descriptor (rtx rtl, bool can_use_fbreg)\n \tloc_result = loc_descriptor (XEXP (RTVEC_ELT (par_elems, 0), 0),\n \t\t\t\t     can_use_fbreg);\n \tmode = GET_MODE (XEXP (RTVEC_ELT (par_elems, 0), 0));\n-\tadd_loc_descr (&loc_result,\n-\t\t       new_loc_descr (DW_OP_piece, GET_MODE_SIZE (mode), 0));\n+\tadd_loc_descr_op_piece (&loc_result, GET_MODE_SIZE (mode));\n \tfor (i = 1; i < num_elem; i++)\n \t  {\n \t    dw_loc_descr_ref temp;\n@@ -8872,9 +8889,7 @@ loc_descriptor (rtx rtl, bool can_use_fbreg)\n \t\t\t\t   can_use_fbreg);\n \t    add_loc_descr (&loc_result, temp);\n \t    mode = GET_MODE (XEXP (RTVEC_ELT (par_elems, i), 0));\n-\t    add_loc_descr (&loc_result,\n-\t\t\t   new_loc_descr (DW_OP_piece,\n-\t\t\t\t\t  GET_MODE_SIZE (mode), 0));\n+\t    add_loc_descr_op_piece (&loc_result, GET_MODE_SIZE (mode));\n \t  }\n       }\n       break;"}, {"sha": "6d5c14c6055bf1ec7e5bc92e3de34fd990d9382b", "filename": "gcc/var-tracking.c", "status": "modified", "additions": 90, "deletions": 14, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c938250d71aa69cb46490ac49058fc1a499962e4/gcc%2Fvar-tracking.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c938250d71aa69cb46490ac49058fc1a499962e4/gcc%2Fvar-tracking.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvar-tracking.c?ref=c938250d71aa69cb46490ac49058fc1a499962e4", "patch": "@@ -102,6 +102,8 @@\n #include \"alloc-pool.h\"\n #include \"fibheap.h\"\n #include \"hashtab.h\"\n+#include \"regs.h\"\n+#include \"expr.h\"\n \n /* Type of micro operation.  */\n enum micro_operation_type\n@@ -2167,25 +2169,101 @@ emit_note_insn_var_location (void **varp, void *data)\n   rtx insn = ((emit_note_data *)data)->insn;\n   enum emit_note_where where = ((emit_note_data *)data)->where;\n   rtx note;\n-  int i;\n+  int i, j, n_var_parts;\n   bool complete;\n   HOST_WIDE_INT last_limit;\n   tree type_size_unit;\n+  HOST_WIDE_INT offsets[MAX_VAR_PARTS];\n+  rtx loc[MAX_VAR_PARTS];\n \n   gcc_assert (var->decl);\n \n   complete = true;\n   last_limit = 0;\n+  n_var_parts = 0;\n   for (i = 0; i < var->n_var_parts; i++)\n     {\n+      enum machine_mode mode, wider_mode;\n+\n       if (last_limit < var->var_part[i].offset)\n \t{\n \t  complete = false;\n \t  break;\n \t}\n-      last_limit\n-\t= (var->var_part[i].offset\n-\t   + GET_MODE_SIZE (GET_MODE (var->var_part[i].loc_chain->loc)));\n+      else if (last_limit > var->var_part[i].offset)\n+\tcontinue;\n+      offsets[n_var_parts] = var->var_part[i].offset;\n+      loc[n_var_parts] = var->var_part[i].loc_chain->loc;\n+      mode = GET_MODE (loc[n_var_parts]);\n+      last_limit = offsets[n_var_parts] + GET_MODE_SIZE (mode);\n+\n+      /* Attempt to merge adjacent registers or memory.  */\n+      wider_mode = GET_MODE_WIDER_MODE (mode);\n+      for (j = i + 1; j < var->n_var_parts; j++)\n+\tif (last_limit <= var->var_part[j].offset)\n+\t  break;\n+      if (j < var->n_var_parts\n+\t  && wider_mode != VOIDmode\n+\t  && GET_CODE (loc[n_var_parts])\n+\t     == GET_CODE (var->var_part[j].loc_chain->loc)\n+\t  && mode == GET_MODE (var->var_part[j].loc_chain->loc)\n+\t  && last_limit == var->var_part[j].offset)\n+\t{\n+\t  rtx new_loc = NULL;\n+\t  rtx loc2 = var->var_part[j].loc_chain->loc;\n+\n+\t  if (REG_P (loc[n_var_parts])\n+\t      && hard_regno_nregs[REGNO (loc[n_var_parts])][mode] * 2\n+\t\t == hard_regno_nregs[REGNO (loc[n_var_parts])][wider_mode]\n+\t      && REGNO (loc[n_var_parts])\n+\t\t + hard_regno_nregs[REGNO (loc[n_var_parts])][mode]\n+\t\t == REGNO (loc2))\n+\t    {\n+\t      if (! WORDS_BIG_ENDIAN && ! BYTES_BIG_ENDIAN)\n+\t\tnew_loc = simplify_subreg (wider_mode, loc[n_var_parts],\n+\t\t\t\t\t   mode, 0);\n+\t      else if (WORDS_BIG_ENDIAN && BYTES_BIG_ENDIAN)\n+\t\tnew_loc = simplify_subreg (wider_mode, loc2, mode, 0);\n+\t      if (new_loc)\n+\t\t{\n+\t\t  if (!REG_P (new_loc)\n+\t\t      || REGNO (new_loc) != REGNO (loc[n_var_parts]))\n+\t\t    new_loc = NULL;\n+\t\t  else\n+\t\t    REG_ATTRS (new_loc) = REG_ATTRS (loc[n_var_parts]);\n+\t\t}\n+\t    }\n+\t  else if (MEM_P (loc[n_var_parts])\n+\t\t   && GET_CODE (XEXP (loc2, 0)) == PLUS\n+\t\t   && GET_CODE (XEXP (XEXP (loc2, 0), 0)) == REG\n+\t\t   && GET_CODE (XEXP (XEXP (loc2, 0), 1)) == CONST_INT)\n+\t    {\n+\t      if ((GET_CODE (XEXP (loc[n_var_parts], 0)) == REG\n+\t\t   && rtx_equal_p (XEXP (loc[n_var_parts], 0),\n+\t\t\t\t   XEXP (XEXP (loc2, 0), 0))\n+\t\t   && INTVAL (XEXP (XEXP (loc2, 0), 1))\n+\t\t      == GET_MODE_SIZE (mode))\n+\t\t  || (GET_CODE (XEXP (loc[n_var_parts], 0)) == PLUS\n+\t\t      && GET_CODE (XEXP (XEXP (loc[n_var_parts], 0), 1))\n+\t\t\t == CONST_INT\n+\t\t      && rtx_equal_p (XEXP (XEXP (loc[n_var_parts], 0), 0),\n+\t\t\t\t      XEXP (XEXP (loc2, 0), 0))\n+\t\t      && INTVAL (XEXP (XEXP (loc[n_var_parts], 0), 1))\n+\t\t\t + GET_MODE_SIZE (mode)\n+\t\t\t == INTVAL (XEXP (XEXP (loc2, 0), 1))))\n+\t\tnew_loc = adjust_address_nv (loc[n_var_parts],\n+\t\t\t\t\t     wider_mode, 0);\n+\t    }\n+\n+\t  if (new_loc)\n+\t    {\n+\t      loc[n_var_parts] = new_loc;\n+\t      mode = wider_mode;\n+\t      last_limit = offsets[n_var_parts] + GET_MODE_SIZE (mode);\n+\t      i = j;\n+\t    }\n+\t}\n+      ++n_var_parts;\n     }\n   type_size_unit = TYPE_SIZE_UNIT (TREE_TYPE (var->decl));\n   if ((unsigned HOST_WIDE_INT) last_limit < TREE_INT_CST_LOW (type_size_unit))\n@@ -2201,26 +2279,24 @@ emit_note_insn_var_location (void **varp, void *data)\n       NOTE_VAR_LOCATION (note) = gen_rtx_VAR_LOCATION (VOIDmode, var->decl,\n \t\t\t\t\t\t       NULL_RTX);\n     }\n-  else if (var->n_var_parts == 1)\n+  else if (n_var_parts == 1)\n     {\n       rtx expr_list\n-\t= gen_rtx_EXPR_LIST (VOIDmode,\n-\t\t\t     var->var_part[0].loc_chain->loc,\n-\t\t\t     GEN_INT (var->var_part[0].offset));\n+\t= gen_rtx_EXPR_LIST (VOIDmode, loc[0], GEN_INT (offsets[0]));\n \n       NOTE_VAR_LOCATION (note) = gen_rtx_VAR_LOCATION (VOIDmode, var->decl,\n \t\t\t\t\t\t       expr_list);\n     }\n-  else if (var->n_var_parts)\n+  else if (n_var_parts)\n     {\n-      rtx argp[MAX_VAR_PARTS];\n       rtx parallel;\n \n-      for (i = 0; i < var->n_var_parts; i++)\n-\targp[i] = gen_rtx_EXPR_LIST (VOIDmode, var->var_part[i].loc_chain->loc,\n-\t\t\t\t     GEN_INT (var->var_part[i].offset));\n+      for (i = 0; i < n_var_parts; i++)\n+\tloc[i]\n+\t  = gen_rtx_EXPR_LIST (VOIDmode, loc[i], GEN_INT (offsets[i]));\n+\n       parallel = gen_rtx_PARALLEL (VOIDmode,\n-\t\t\t\t   gen_rtvec_v (var->n_var_parts, argp));\n+\t\t\t\t   gen_rtvec_v (n_var_parts, loc));\n       NOTE_VAR_LOCATION (note) = gen_rtx_VAR_LOCATION (VOIDmode, var->decl,\n \t\t\t\t\t\t       parallel);\n     }"}]}