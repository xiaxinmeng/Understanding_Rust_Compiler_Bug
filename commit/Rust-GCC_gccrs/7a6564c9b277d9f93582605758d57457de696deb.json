{"sha": "7a6564c9b277d9f93582605758d57457de696deb", "node_id": "C_kwDOANBUbNoAKDdhNjU2NGM5YjI3N2Q5ZjkzNTgyNjA1NzU4ZDU3NDU3ZGU2OTZkZWI", "commit": {"author": {"name": "Tim Lange", "email": "mail@tim-lange.me", "date": "2022-09-07T15:41:28Z"}, "committer": {"name": "Tim Lange", "email": "mail@tim-lange.me", "date": "2022-09-08T17:29:06Z"}, "message": "analyzer: support for symbolic values in the out-of-bounds checker [PR106625]\n\nThis patch adds support for reasoning about the inequality of two symbolic\nvalues in the special case specifically suited for reasoning about\nout-of-bounds past the end of the buffer. With this patch, the analyzer\ncatches off-by-one errors and more even when the offset and capacity is\nsymbolic.\n\nRegrtested on Linux x86_64 and tested on coreutils, curl, httpd and\nopenssh as usual.\n\n2022-09-07  Tim Lange  <mail@tim-lange.me>\n\ngcc/analyzer/ChangeLog:\n\n\tPR analyzer/106625\n\t* analyzer.h (region_offset): Eliminate m_is_symbolic member.\n\t* region-model-impl-calls.cc (region_model::impl_call_realloc):\n\tRefine implementation to be more precise.\n\t* region-model.cc (class symbolic_past_the_end):\n\tAbstract diagnostic class to complain about accesses past the end\n\twith symbolic values.\n\t(class symbolic_buffer_overflow):\n\tConcrete diagnostic class to complain about buffer overflows with\n\tsymbolic values.\n\t(class symbolic_buffer_overread):\n\tConcrete diagnostic class to complain about buffer overreads with\n\tsymbolic values.\n\t(region_model::check_symbolic_bounds): New function.\n\t(maybe_get_integer_cst_tree): New helper function.\n\t(region_model::check_region_bounds):\n\tAdd call to check_symbolic_bounds if offset is not concrete.\n\t(region_model::eval_condition_without_cm):\n\tAdd support for EQ_EXPR and GT_EXPR with binaryop_svalues.\n\t(is_positive_svalue): New hleper function.\n\t(region_model::symbolic_greater_than):\n\tNew function to handle GT_EXPR comparisons with symbolic values.\n\t(region_model::structural_equality): New function to compare\n\twhether two svalues are structured the same, i.e. evaluate to\n\tthe same value.\n\t(test_struct): Reflect changes to region::calc_offset.\n\t(test_var): Likewise.\n\t(test_array_2): Likewise and add selftest with symbolic i.\n\t* region-model.h (class region_model): Add check_symbolic_bounds,\n\tsymbolic_greater_than and structural_equality.\n\t* region.cc (region::get_offset):\n\tReflect changes to region::calc_offset.\n\t(region::calc_offset):\n\tCompute the symbolic offset if the offset is not concrete.\n\t(region::get_relative_symbolic_offset): New function to return the\n\tsymbolic offset in bytes relative to its parent.\n\t(field_region::get_relative_symbolic_offset): Likewise.\n\t(element_region::get_relative_symbolic_offset): Likewise.\n\t(offset_region::get_relative_symbolic_offset): Likewise.\n\t(bit_range_region::get_relative_symbolic_offset): Likewise.\n\t* region.h: Add get_relative_symbolic_offset.\n\t* store.cc (binding_key::make):\n\tReflect changes to region::calc_offset.\n\t(binding_map::apply_ctor_val_to_range): Likewise.\n\t(binding_map::apply_ctor_pair_to_child_region): Likewise.\n\t(binding_cluster::bind_compound_sval): Likewise.\n\t(binding_cluster::get_any_binding): Likewise.\n\t(binding_cluster::maybe_get_compound_binding): Likewise.\n\ngcc/ChangeLog:\n\n\tPR analyzer/106625\n\t* doc/invoke.texi:\n\tState that the checker also reasons about symbolic values.\n\ngcc/testsuite/ChangeLog:\n\n\tPR analyzer/106625\n\t* gcc.dg/analyzer/data-model-1.c: Change expected result.\n\t* gcc.dg/analyzer/out-of-bounds-5.c: New test.\n\t* gcc.dg/analyzer/out-of-bounds-realloc-grow.c: New test.\n\t* gcc.dg/analyzer/symbolic-gt-1.c: New test.", "tree": {"sha": "aae70307f5b1daf3f82104002b31c1cad518fa43", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/aae70307f5b1daf3f82104002b31c1cad518fa43"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7a6564c9b277d9f93582605758d57457de696deb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a6564c9b277d9f93582605758d57457de696deb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7a6564c9b277d9f93582605758d57457de696deb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a6564c9b277d9f93582605758d57457de696deb/comments", "author": {"login": "timll", "id": 10032775, "node_id": "MDQ6VXNlcjEwMDMyNzc1", "avatar_url": "https://avatars.githubusercontent.com/u/10032775?v=4", "gravatar_id": "", "url": "https://api.github.com/users/timll", "html_url": "https://github.com/timll", "followers_url": "https://api.github.com/users/timll/followers", "following_url": "https://api.github.com/users/timll/following{/other_user}", "gists_url": "https://api.github.com/users/timll/gists{/gist_id}", "starred_url": "https://api.github.com/users/timll/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/timll/subscriptions", "organizations_url": "https://api.github.com/users/timll/orgs", "repos_url": "https://api.github.com/users/timll/repos", "events_url": "https://api.github.com/users/timll/events{/privacy}", "received_events_url": "https://api.github.com/users/timll/received_events", "type": "User", "site_admin": false}, "committer": {"login": "timll", "id": 10032775, "node_id": "MDQ6VXNlcjEwMDMyNzc1", "avatar_url": "https://avatars.githubusercontent.com/u/10032775?v=4", "gravatar_id": "", "url": "https://api.github.com/users/timll", "html_url": "https://github.com/timll", "followers_url": "https://api.github.com/users/timll/followers", "following_url": "https://api.github.com/users/timll/following{/other_user}", "gists_url": "https://api.github.com/users/timll/gists{/gist_id}", "starred_url": "https://api.github.com/users/timll/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/timll/subscriptions", "organizations_url": "https://api.github.com/users/timll/orgs", "repos_url": "https://api.github.com/users/timll/repos", "events_url": "https://api.github.com/users/timll/events{/privacy}", "received_events_url": "https://api.github.com/users/timll/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9f2fca56593a2b87026b399d26adcdca90705685", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9f2fca56593a2b87026b399d26adcdca90705685", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9f2fca56593a2b87026b399d26adcdca90705685"}], "stats": {"total": 1036, "additions": 941, "deletions": 95}, "files": [{"sha": "e4dd6d6339d785840761c6b04e395e2f29ebdd14", "filename": "gcc/analyzer/analyzer.h", "status": "modified", "additions": 15, "deletions": 8, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a6564c9b277d9f93582605758d57457de696deb/gcc%2Fanalyzer%2Fanalyzer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a6564c9b277d9f93582605758d57457de696deb/gcc%2Fanalyzer%2Fanalyzer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fanalyzer.h?ref=7a6564c9b277d9f93582605758d57457de696deb", "patch": "@@ -172,39 +172,46 @@ class region_offset\n   static region_offset make_concrete (const region *base_region,\n \t\t\t\t      bit_offset_t offset)\n   {\n-    return region_offset (base_region, offset, false);\n+    return region_offset (base_region, offset, NULL);\n   }\n-  static region_offset make_symbolic (const region *base_region)\n+  static region_offset make_symbolic (const region *base_region,\n+\t\t\t\t      const svalue *sym_offset)\n   {\n-    return region_offset (base_region, 0, true);\n+    return region_offset (base_region, 0, sym_offset);\n   }\n \n   const region *get_base_region () const { return m_base_region; }\n \n-  bool symbolic_p () const { return m_is_symbolic; }\n+  bool symbolic_p () const { return m_sym_offset != NULL; }\n \n   bit_offset_t get_bit_offset () const\n   {\n     gcc_assert (!symbolic_p ());\n     return m_offset;\n   }\n \n+  const svalue *get_symbolic_byte_offset () const\n+  {\n+    gcc_assert (symbolic_p ());\n+    return m_sym_offset;\n+  }\n+\n   bool operator== (const region_offset &other) const\n   {\n     return (m_base_region == other.m_base_region\n \t    && m_offset == other.m_offset\n-\t    && m_is_symbolic == other.m_is_symbolic);\n+\t    && m_sym_offset == other.m_sym_offset);\n   }\n \n private:\n   region_offset (const region *base_region, bit_offset_t offset,\n-\t\t bool is_symbolic)\n-  : m_base_region (base_region), m_offset (offset), m_is_symbolic (is_symbolic)\n+\t\t const svalue *sym_offset)\n+  : m_base_region (base_region), m_offset (offset), m_sym_offset (sym_offset)\n   {}\n \n   const region *m_base_region;\n   bit_offset_t m_offset;\n-  bool m_is_symbolic;\n+  const svalue *m_sym_offset;\n };\n \n extern location_t get_stmt_location (const gimple *stmt, function *fun);"}, {"sha": "617491be3060dbe57355ab5ec4fb030e7742efdd", "filename": "gcc/analyzer/region-model-impl-calls.cc", "status": "modified", "additions": 13, "deletions": 26, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a6564c9b277d9f93582605758d57457de696deb/gcc%2Fanalyzer%2Fregion-model-impl-calls.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a6564c9b277d9f93582605758d57457de696deb/gcc%2Fanalyzer%2Fregion-model-impl-calls.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model-impl-calls.cc?ref=7a6564c9b277d9f93582605758d57457de696deb", "patch": "@@ -850,7 +850,7 @@ region_model::impl_call_realloc (const call_details &cd)\n \t  if (old_size_sval)\n \t    {\n \t      const svalue *copied_size_sval\n-\t\t= get_copied_size (old_size_sval, new_size_sval);\n+\t\t= get_copied_size (model, old_size_sval, new_size_sval);\n \t      const region *copied_old_reg\n \t\t= model->m_mgr->get_sized_region (freed_reg, NULL,\n \t\t\t\t\t\t  copied_size_sval);\n@@ -896,35 +896,22 @@ region_model::impl_call_realloc (const call_details &cd)\n \n   private:\n     /* Return the lesser of OLD_SIZE_SVAL and NEW_SIZE_SVAL.\n-       If either one is symbolic, the symbolic svalue is returned.  */\n-    const svalue *get_copied_size (const svalue *old_size_sval,\n+       If unknown, OLD_SIZE_SVAL is returned.  */\n+    const svalue *get_copied_size (region_model *model,\n+\t\t\t\t   const svalue *old_size_sval,\n \t\t\t\t   const svalue *new_size_sval) const\n     {\n-      tree old_size_cst = old_size_sval->maybe_get_constant ();\n-      tree new_size_cst = new_size_sval->maybe_get_constant ();\n-\n-      if (old_size_cst && new_size_cst)\n-\t{\n-\t  /* Both are constants and comparable.  */\n-\t  tree cmp = fold_binary (LT_EXPR, boolean_type_node,\n-\t\t\t\t  old_size_cst, new_size_cst);\n-\n-\t  if (cmp == boolean_true_node)\n-\t    return old_size_sval;\n-\t  else\n-\t    return new_size_sval;\n-\t}\n-      else if (new_size_cst)\n+      tristate res\n+\t= model->eval_condition (old_size_sval, GT_EXPR, new_size_sval);\n+      switch (res.get_value ())\n \t{\n-\t  /* OLD_SIZE_SVAL is symbolic, so return that.  */\n-\t  return old_size_sval;\n-\t}\n-      else\n-\t{\n-\t  /* NEW_SIZE_SVAL is symbolic or both are symbolic.\n-\t     Return NEW_SIZE_SVAL, because implementations of realloc\n-\t     probably only moves the buffer if the new size is larger.  */\n+\tcase tristate::TS_TRUE:\n \t  return new_size_sval;\n+\tcase tristate::TS_FALSE:\n+\tcase tristate::TS_UNKNOWN:\n+\t  return old_size_sval;\n+\tdefault:\n+\t  gcc_unreachable ();\n \t}\n     }\n   };"}, {"sha": "d321e5b6479a95dfbd519b1faf8eb084d126132c", "filename": "gcc/analyzer/region-model.cc", "status": "modified", "additions": 437, "deletions": 32, "changes": 469, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a6564c9b277d9f93582605758d57457de696deb/gcc%2Fanalyzer%2Fregion-model.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a6564c9b277d9f93582605758d57457de696deb/gcc%2Fanalyzer%2Fregion-model.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model.cc?ref=7a6564c9b277d9f93582605758d57457de696deb", "patch": "@@ -1268,7 +1268,7 @@ region_model::on_stmt_pre (const gimple *stmt,\n     }\n }\n \n-/* Abstract base class for all out-of-bounds warnings.  */\n+/* Abstract base class for all out-of-bounds warnings with concrete values.  */\n \n class out_of_bounds : public pending_diagnostic_subclass<out_of_bounds>\n {\n@@ -1591,49 +1591,285 @@ class buffer_underread : public out_of_bounds\n   }\n };\n \n+/* Abstract class to complain about out-of-bounds read/writes where\n+   the values are symbolic.  */\n+\n+class symbolic_past_the_end\n+  : public pending_diagnostic_subclass<symbolic_past_the_end>\n+{\n+public:\n+  symbolic_past_the_end (const region *reg, tree diag_arg, tree offset,\n+\t\t\t tree num_bytes, tree capacity)\n+  : m_reg (reg), m_diag_arg (diag_arg), m_offset (offset),\n+    m_num_bytes (num_bytes), m_capacity (capacity)\n+  {}\n+\n+  const char *get_kind () const final override\n+  {\n+    return \"symbolic_past_the_end\";\n+  }\n+\n+  bool operator== (const symbolic_past_the_end &other) const\n+  {\n+    return m_reg == other.m_reg\n+\t   && pending_diagnostic::same_tree_p (m_diag_arg, other.m_diag_arg)\n+\t   && pending_diagnostic::same_tree_p (m_offset, other.m_offset)\n+\t   && pending_diagnostic::same_tree_p (m_num_bytes, other.m_num_bytes)\n+\t   && pending_diagnostic::same_tree_p (m_capacity, other.m_capacity);\n+  }\n+\n+  int get_controlling_option () const final override\n+  {\n+    return OPT_Wanalyzer_out_of_bounds;\n+  }\n+\n+  void mark_interesting_stuff (interesting_t *interest) final override\n+  {\n+    interest->add_region_creation (m_reg);\n+  }\n+\n+  label_text\n+  describe_region_creation_event (const evdesc::region_creation &ev) final\n+  override\n+  {\n+    if (m_capacity)\n+      return ev.formatted_print (\"capacity is %qE bytes\", m_capacity);\n+\n+    return label_text ();\n+  }\n+\n+  label_text\n+  describe_final_event (const evdesc::final_event &ev) final override\n+  {\n+    const char *byte_str;\n+    if (pending_diagnostic::same_tree_p (m_num_bytes, integer_one_node))\n+      byte_str = \"byte\";\n+    else\n+      byte_str = \"bytes\";\n+\n+    if (m_offset)\n+      {\n+\tif (m_num_bytes && TREE_CODE (m_num_bytes) == INTEGER_CST)\n+\t  {\n+\t    if (m_diag_arg)\n+\t      return ev.formatted_print (\"%s of %E %s at offset %qE\"\n+\t\t\t\t\t \" exceeds %qE\", m_dir_str,\n+\t\t\t\t\t m_num_bytes, byte_str,\n+\t\t\t\t\t m_offset, m_diag_arg);\n+\t    else\n+\t      return ev.formatted_print (\"%s of %E %s at offset %qE\"\n+\t\t\t\t\t \" exceeds the buffer\", m_dir_str,\n+\t\t\t\t\t m_num_bytes, byte_str, m_offset);\n+\t  }\n+\telse if (m_num_bytes)\n+\t  {\n+\t    if (m_diag_arg)\n+\t      return ev.formatted_print (\"%s of %qE %s at offset %qE\"\n+\t\t\t\t\t \" exceeds %qE\", m_dir_str,\n+\t\t\t\t\t m_num_bytes, byte_str,\n+\t\t\t\t\t m_offset, m_diag_arg);\n+\t    else\n+\t      return ev.formatted_print (\"%s of %qE %s at offset %qE\"\n+\t\t\t\t\t \" exceeds the buffer\", m_dir_str,\n+\t\t\t\t\t m_num_bytes, byte_str, m_offset);\n+\t  }\n+\telse\n+\t  {\n+\t    if (m_diag_arg)\n+\t      return ev.formatted_print (\"%s at offset %qE exceeds %qE\",\n+\t\t\t\t\t m_dir_str, m_offset, m_diag_arg);\n+\t    else\n+\t      return ev.formatted_print (\"%s at offset %qE exceeds the\"\n+\t\t\t\t\t \" buffer\", m_dir_str, m_offset);\n+\t  }\n+      }\n+    if (m_diag_arg)\n+      return ev.formatted_print (\"out-of-bounds %s on %qE\",\n+\t\t\t\t m_dir_str, m_diag_arg);\n+    return ev.formatted_print (\"out-of-bounds %s\", m_dir_str);\n+  }\n+\n+protected:\n+  const region *m_reg;\n+  tree m_diag_arg;\n+  tree m_offset;\n+  tree m_num_bytes;\n+  tree m_capacity;\n+  const char *m_dir_str;\n+};\n+\n+/* Concrete subclass to complain about overflows with symbolic values.  */\n+\n+class symbolic_buffer_overflow : public symbolic_past_the_end\n+{\n+public:\n+  symbolic_buffer_overflow (const region *reg, tree diag_arg, tree offset,\n+\t\t\t    tree num_bytes, tree capacity)\n+  : symbolic_past_the_end (reg, diag_arg, offset, num_bytes, capacity)\n+  {\n+    m_dir_str = \"write\";\n+  }\n+\n+  bool emit (rich_location *rich_loc) final override\n+  {\n+    diagnostic_metadata m;\n+    switch (m_reg->get_memory_space ())\n+      {\n+      default:\n+\tm.add_cwe (787);\n+\treturn warning_meta (rich_loc, m, get_controlling_option (),\n+\t\t\t     \"buffer overflow\");\n+      case MEMSPACE_STACK:\n+\tm.add_cwe (121);\n+\treturn warning_meta (rich_loc, m, get_controlling_option (),\n+\t\t\t     \"stack-based buffer overflow\");\n+      case MEMSPACE_HEAP:\n+\tm.add_cwe (122);\n+\treturn warning_meta (rich_loc, m, get_controlling_option (),\n+\t\t\t     \"heap-based buffer overflow\");\n+      }\n+  }\n+};\n+\n+/* Concrete subclass to complain about overreads with symbolic values.  */\n+\n+class symbolic_buffer_overread : public symbolic_past_the_end\n+{\n+public:\n+  symbolic_buffer_overread (const region *reg, tree diag_arg, tree offset,\n+\t\t\t    tree num_bytes, tree capacity)\n+  : symbolic_past_the_end (reg, diag_arg, offset, num_bytes, capacity)\n+  {\n+    m_dir_str = \"read\";\n+  }\n+\n+  bool emit (rich_location *rich_loc) final override\n+  {\n+    diagnostic_metadata m;\n+    m.add_cwe (126);\n+    return warning_meta (rich_loc, m, get_controlling_option (),\n+\t\t\t \"buffer overread\");\n+  }\n+};\n+\n+/* Check whether an access is past the end of the BASE_REG.  */\n+\n+void region_model::check_symbolic_bounds (const region *base_reg,\n+\t\t\t\t\t  const svalue *sym_byte_offset,\n+\t\t\t\t\t  const svalue *num_bytes_sval,\n+\t\t\t\t\t  const svalue *capacity,\n+\t\t\t\t\t  enum access_direction dir,\n+\t\t\t\t\t  region_model_context *ctxt) const\n+{\n+  gcc_assert (ctxt);\n+\n+  const svalue *next_byte\n+    = m_mgr->get_or_create_binop (num_bytes_sval->get_type (), PLUS_EXPR,\n+\t\t\t\t  sym_byte_offset, num_bytes_sval);\n+\n+  if (eval_condition_without_cm (next_byte, GT_EXPR, capacity).is_true ())\n+    {\n+      tree diag_arg = get_representative_tree (base_reg);\n+      tree offset_tree = get_representative_tree (sym_byte_offset);\n+      tree num_bytes_tree = get_representative_tree (num_bytes_sval);\n+      tree capacity_tree = get_representative_tree (capacity);\n+      switch (dir)\n+\t{\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t  break;\n+\tcase DIR_READ:\n+\t  ctxt->warn (new symbolic_buffer_overread (base_reg, diag_arg,\n+\t\t\t\t\t\t    offset_tree,\n+\t\t\t\t\t\t    num_bytes_tree,\n+\t\t\t\t\t\t    capacity_tree));\n+\t  break;\n+\tcase DIR_WRITE:\n+\t  ctxt->warn (new symbolic_buffer_overflow (base_reg, diag_arg,\n+\t\t\t\t\t\t    offset_tree,\n+\t\t\t\t\t\t    num_bytes_tree,\n+\t\t\t\t\t\t    capacity_tree));\n+\t  break;\n+\t}\n+    }\n+}\n+\n+static tree\n+maybe_get_integer_cst_tree (const svalue *sval)\n+{\n+  tree cst_tree = sval->maybe_get_constant ();\n+  if (cst_tree && TREE_CODE (cst_tree) == INTEGER_CST)\n+    return cst_tree;\n+\n+  return NULL_TREE;\n+}\n+\n /* May complain when the access on REG is out-of-bounds.  */\n \n-void region_model::check_region_bounds (const region *reg,\n-\t\t\t\t\tenum access_direction dir,\n-\t\t\t\t\tregion_model_context *ctxt) const\n+void\n+region_model::check_region_bounds (const region *reg,\n+\t\t\t\t   enum access_direction dir,\n+\t\t\t\t   region_model_context *ctxt) const\n {\n   gcc_assert (ctxt);\n \n-  region_offset reg_offset = reg->get_offset ();\n+  /* Get the offset.  */\n+  region_offset reg_offset = reg->get_offset (m_mgr);\n   const region *base_reg = reg_offset.get_base_region ();\n \n-  /* Bail out on symbolic offsets or symbolic regions.\n+  /* Bail out on symbolic regions.\n      (e.g. because the analyzer did not see previous offsets on the latter,\n      it might think that a negative access is before the buffer).  */\n-  if (reg_offset.symbolic_p () || base_reg->symbolic_p ())\n+  if (base_reg->symbolic_p ())\n     return;\n-  byte_offset_t offset_unsigned\n-    = reg_offset.get_bit_offset () >> LOG2_BITS_PER_UNIT;\n+\n+  /* Find out how many bytes were accessed.  */\n+  const svalue *num_bytes_sval = reg->get_byte_size_sval (m_mgr);\n+  tree num_bytes_tree = maybe_get_integer_cst_tree (num_bytes_sval);\n+\n+  /* Get the capacity of the buffer.  */\n+  const svalue *capacity = get_capacity (base_reg);\n+  tree cst_capacity_tree = maybe_get_integer_cst_tree (capacity);\n+\n   /* The constant offset from a pointer is represented internally as a sizetype\n      but should be interpreted as a signed value here.  The statement below\n-     converts the offset to a signed integer with the same precision the\n-     sizetype has on the target system.\n+     converts the offset from bits to bytes and then to a signed integer with\n+     the same precision the sizetype has on the target system.\n \n      For example, this is needed for out-of-bounds-3.c test1 to pass when\n      compiled with a 64-bit gcc build targeting 32-bit systems.  */\n-  byte_offset_t offset\n-    = offset_unsigned.to_shwi (TYPE_PRECISION (size_type_node));\n-\n-  /* Find out how many bytes were accessed.  */\n-  const svalue *num_bytes_sval = reg->get_byte_size_sval (m_mgr);\n-  tree num_bytes_tree = num_bytes_sval->maybe_get_constant ();\n-  if (!num_bytes_tree || TREE_CODE (num_bytes_tree) != INTEGER_CST)\n-    /* If we do not know how many bytes were read/written,\n-       assume that at least one byte was read/written.  */\n-    num_bytes_tree = integer_one_node;\n+  byte_offset_t offset;\n+  if (!reg_offset.symbolic_p ())\n+    offset = wi::sext (reg_offset.get_bit_offset () >> LOG2_BITS_PER_UNIT,\n+\t\t       TYPE_PRECISION (size_type_node));\n+\n+  /* If either the offset or the number of bytes accessed are symbolic,\n+     we have to reason about symbolic values.  */\n+  if (reg_offset.symbolic_p () || !num_bytes_tree)\n+    {\n+      const svalue* byte_offset_sval;\n+      if (!reg_offset.symbolic_p ())\n+\t{\n+\t  tree offset_tree = wide_int_to_tree (integer_type_node, offset);\n+\t  byte_offset_sval\n+\t    = m_mgr->get_or_create_constant_svalue (offset_tree);\n+\t}\n+      else\n+\tbyte_offset_sval = reg_offset.get_symbolic_byte_offset ();\n+      check_symbolic_bounds (base_reg, byte_offset_sval, num_bytes_sval,\n+\t\t\t     capacity, dir, ctxt);\n+      return;\n+    }\n \n+  /* Otherwise continue to check with concrete values.  */\n   byte_range out (0, 0);\n   /* NUM_BYTES_TREE should always be interpreted as unsigned.  */\n-  byte_range read_bytes (offset, wi::to_offset (num_bytes_tree).to_uhwi ());\n+  byte_offset_t num_bytes_unsigned = wi::to_offset (num_bytes_tree);\n+  byte_range read_bytes (offset, num_bytes_unsigned);\n   /* If read_bytes has a subset < 0, we do have an underflow.  */\n   if (read_bytes.falls_short_of_p (0, &out))\n     {\n-      tree diag_arg = get_representative_tree (reg->get_base_region ());\n+      tree diag_arg = get_representative_tree (base_reg);\n       switch (dir)\n \t{\n \tdefault:\n@@ -1648,9 +1884,10 @@ void region_model::check_region_bounds (const region *reg,\n \t}\n     }\n \n-  const svalue *capacity = get_capacity (base_reg);\n-  tree cst_capacity_tree = capacity->maybe_get_constant ();\n-  if (!cst_capacity_tree || TREE_CODE (cst_capacity_tree) != INTEGER_CST)\n+  /* For accesses past the end, we do need a concrete capacity.  No need to\n+     do a symbolic check here because the inequality check does not reason\n+     whether constants are greater than symbolic values.  */\n+  if (!cst_capacity_tree)\n     return;\n \n   byte_range buffer (0, wi::to_offset (cst_capacity_tree));\n@@ -1659,7 +1896,7 @@ void region_model::check_region_bounds (const region *reg,\n     {\n       tree byte_bound = wide_int_to_tree (size_type_node,\n \t\t\t\t\t  buffer.get_next_byte_offset ());\n-      tree diag_arg = get_representative_tree (reg->get_base_region ());\n+      tree diag_arg = get_representative_tree (base_reg);\n \n       switch (dir)\n \t{\n@@ -3907,6 +4144,49 @@ region_model::eval_condition_without_cm (const svalue *lhs,\n \t  return res;\n       }\n \n+  /* Handle comparisons between two svalues with more than one operand.  */\n+\tif (const binop_svalue *binop = lhs->dyn_cast_binop_svalue ())\n+    {\n+      switch (op)\n+\t{\n+\tdefault:\n+\t  break;\n+\tcase EQ_EXPR:\n+\t  {\n+\t    /* TODO: binops can be equal even if they are not structurally\n+\t\t     equal in case of commutative operators.  */\n+\t    tristate res = structural_equality (lhs, rhs);\n+\t    if (res.is_true ())\n+\t      return res;\n+\t  }\n+\t  break;\n+\tcase LE_EXPR:\n+\t  {\n+\t    tristate res = structural_equality (lhs, rhs);\n+\t    if (res.is_true ())\n+\t      return res;\n+\t  }\n+\t  break;\n+\tcase GE_EXPR:\n+\t  {\n+\t    tristate res = structural_equality (lhs, rhs);\n+\t    if (res.is_true ())\n+\t      return res;\n+\t    res = symbolic_greater_than (binop, rhs);\n+\t    if (res.is_true ())\n+\t      return res;\n+\t  }\n+\t  break;\n+\tcase GT_EXPR:\n+\t  {\n+\t    tristate res = symbolic_greater_than (binop, rhs);\n+\t    if (res.is_true ())\n+\t      return res;\n+\t  }\n+\t  break;\n+\t}\n+    }\n+\n   return tristate::TS_UNKNOWN;\n }\n \n@@ -3928,6 +4208,123 @@ region_model::compare_initial_and_pointer (const initial_svalue *init,\n   return tristate::TS_UNKNOWN;\n }\n \n+/* Return true if SVAL is definitely positive.  */\n+\n+static bool\n+is_positive_svalue (const svalue *sval)\n+{\n+  if (tree cst = sval->maybe_get_constant ())\n+    return !zerop (cst) && get_range_pos_neg (cst) == 1;\n+  tree type = sval->get_type ();\n+  if (!type)\n+    return false;\n+  /* Consider a binary operation size_t + int.  The analyzer wraps the int in\n+     an unaryop_svalue, converting it to a size_t, but in the dynamic execution\n+     the result is smaller than the first operand.  Thus, we have to look if\n+     the argument of the unaryop_svalue is also positive.  */\n+  if (const unaryop_svalue *un_op = dyn_cast <const unaryop_svalue *> (sval))\n+    return CONVERT_EXPR_CODE_P (un_op->get_op ()) && TYPE_UNSIGNED (type)\n+\t   && is_positive_svalue (un_op->get_arg ());\n+  return TYPE_UNSIGNED (type);\n+}\n+\n+/* Return true if A is definitely larger than B.\n+\n+   Limitation: does not account for integer overflows and does not try to\n+\t       return false, so it can not be used negated.  */\n+\n+tristate\n+region_model::symbolic_greater_than (const binop_svalue *bin_a,\n+\t\t\t\t     const svalue *b) const\n+{\n+  if (bin_a->get_op () == PLUS_EXPR || bin_a->get_op () == MULT_EXPR)\n+    {\n+      /* Eliminate the right-hand side of both svalues.  */\n+      if (const binop_svalue *bin_b = dyn_cast <const binop_svalue *> (b))\n+\tif (bin_a->get_op () == bin_b->get_op ()\n+\t    && eval_condition_without_cm (bin_a->get_arg1 (),\n+\t\t\t\t\t  GT_EXPR,\n+\t\t\t\t\t  bin_b->get_arg1 ()).is_true ()\n+\t    && eval_condition_without_cm (bin_a->get_arg0 (),\n+\t\t\t\t\t  GE_EXPR,\n+\t\t\t\t\t  bin_b->get_arg0 ()).is_true ())\n+\t  return tristate (tristate::TS_TRUE);\n+\n+      /* Otherwise, try to remove a positive offset or factor from BIN_A.  */\n+      if (is_positive_svalue (bin_a->get_arg1 ())\n+\t  && eval_condition_without_cm (bin_a->get_arg0 (),\n+\t\t\t\t\tGE_EXPR, b).is_true ())\n+\t  return tristate (tristate::TS_TRUE);\n+    }\n+  return tristate::unknown ();\n+}\n+\n+/* Return true if A and B are equal structurally.\n+\n+   Structural equality means that A and B are equal if the svalues A and B have\n+   the same nodes at the same positions in the tree and the leafs are equal.\n+   Equality for conjured_svalues and initial_svalues is determined by comparing\n+   the pointers while constants are compared by value.  That behavior is useful\n+   to check for binaryop_svlaues that evaluate to the same concrete value but\n+   might use one operand with a different type but the same constant value.\n+\n+   For example,\n+     binop_svalue (mult_expr,\n+       initial_svalue (\u2018size_t\u2019, decl_region (..., 'some_var')),\n+       constant_svalue (\u2018size_t\u2019, 4))\n+   and\n+     binop_svalue (mult_expr,\n+       initial_svalue (\u2018size_t\u2019, decl_region (..., 'some_var'),\n+       constant_svalue (\u2018sizetype\u2019, 4))\n+   are structurally equal.  A concrete C code example, where this occurs, can\n+   be found in test7 of out-of-bounds-5.c.  */\n+\n+tristate\n+region_model::structural_equality (const svalue *a, const svalue *b) const\n+{\n+  /* If A and B are referentially equal, they are also structurally equal.  */\n+  if (a == b)\n+    return tristate (tristate::TS_TRUE);\n+\n+  switch (a->get_kind ())\n+    {\n+    default:\n+      return tristate::unknown ();\n+    /* SK_CONJURED and SK_INITIAL are already handled\n+       by the referential equality above.  */\n+    case SK_CONSTANT:\n+      {\n+\ttree a_cst = a->maybe_get_constant ();\n+\ttree b_cst = b->maybe_get_constant ();\n+\tif (a_cst && b_cst)\n+\t  return tristate (tree_int_cst_equal (a_cst, b_cst));\n+      }\n+      return tristate (tristate::TS_FALSE);\n+    case SK_UNARYOP:\n+      {\n+\tconst unaryop_svalue *un_a = as_a <const unaryop_svalue *> (a);\n+\tif (const unaryop_svalue *un_b = dyn_cast <const unaryop_svalue *> (b))\n+\t  return tristate (pending_diagnostic::same_tree_p (un_a->get_type (),\n+\t\t\t\t\t\t\t    un_b->get_type ())\n+\t\t\t   && un_a->get_op () == un_b->get_op ()\n+\t\t\t   && structural_equality (un_a->get_arg (),\n+\t\t\t\t\t\t   un_b->get_arg ()));\n+      }\n+      return tristate (tristate::TS_FALSE);\n+    case SK_BINOP:\n+      {\n+\tconst binop_svalue *bin_a = as_a <const binop_svalue *> (a);\n+\tif (const binop_svalue *bin_b = dyn_cast <const binop_svalue *> (b))\n+\t  return tristate (bin_a->get_op () == bin_b->get_op ()\n+\t\t\t   && structural_equality (bin_a->get_arg0 (),\n+\t\t\t\t\t\t   bin_b->get_arg0 ())\n+\t\t\t   && structural_equality (bin_a->get_arg1 (),\n+\t\t\t\t\t\t   bin_b->get_arg1 ()));\n+      }\n+      return tristate (tristate::TS_FALSE);\n+    }\n+}\n+\n /* Handle various constraints of the form:\n      LHS: ((bool)INNER_LHS INNER_OP INNER_RHS))\n      OP : == or !=\n@@ -5637,15 +6034,15 @@ test_struct ()\n   /* Verify get_offset for \"c.x\".  */\n   {\n     const region *c_x_reg = model.get_lvalue (c_x, NULL);\n-    region_offset offset = c_x_reg->get_offset ();\n+    region_offset offset = c_x_reg->get_offset (&mgr);\n     ASSERT_EQ (offset.get_base_region (), model.get_lvalue (c, NULL));\n     ASSERT_EQ (offset.get_bit_offset (), 0);\n   }\n \n   /* Verify get_offset for \"c.y\".  */\n   {\n     const region *c_y_reg = model.get_lvalue (c_y, NULL);\n-    region_offset offset = c_y_reg->get_offset ();\n+    region_offset offset = c_y_reg->get_offset (&mgr);\n     ASSERT_EQ (offset.get_base_region (), model.get_lvalue (c, NULL));\n     ASSERT_EQ (offset.get_bit_offset (), INT_TYPE_SIZE);\n   }\n@@ -7140,7 +7537,7 @@ test_var ()\n \n   /* Verify get_offset for \"i\".  */\n   {\n-    region_offset offset = i_reg->get_offset ();\n+    region_offset offset = i_reg->get_offset (&mgr);\n     ASSERT_EQ (offset.get_base_region (), i_reg);\n     ASSERT_EQ (offset.get_bit_offset (), 0);\n   }\n@@ -7189,19 +7586,27 @@ test_array_2 ()\n   /* Verify get_offset for \"arr[0]\".  */\n   {\n     const region *arr_0_reg = model.get_lvalue (arr_0, NULL);\n-    region_offset offset = arr_0_reg->get_offset ();\n+    region_offset offset = arr_0_reg->get_offset (&mgr);\n     ASSERT_EQ (offset.get_base_region (), model.get_lvalue (arr, NULL));\n     ASSERT_EQ (offset.get_bit_offset (), 0);\n   }\n \n   /* Verify get_offset for \"arr[1]\".  */\n   {\n     const region *arr_1_reg = model.get_lvalue (arr_1, NULL);\n-    region_offset offset = arr_1_reg->get_offset ();\n+    region_offset offset = arr_1_reg->get_offset (&mgr);\n     ASSERT_EQ (offset.get_base_region (), model.get_lvalue (arr, NULL));\n     ASSERT_EQ (offset.get_bit_offset (), INT_TYPE_SIZE);\n   }\n \n+  /* Verify get_offset for \"arr[i]\".  */\n+  {\n+    const region *arr_i_reg = model.get_lvalue (arr_i, NULL);\n+    region_offset offset = arr_i_reg->get_offset (&mgr);\n+    ASSERT_EQ (offset.get_base_region (), model.get_lvalue (arr, NULL));\n+    ASSERT_EQ (offset.get_symbolic_byte_offset ()->get_kind (), SK_BINOP);\n+  }\n+\n   /* \"arr[i] = i;\" - this should remove the earlier bindings.  */\n   model.set_value (arr_i, i, NULL);\n   ASSERT_EQ (model.get_rvalue (arr_i, NULL), model.get_rvalue (i, NULL));"}, {"sha": "977cccf0ef769429718783a3da72b3120963b4a1", "filename": "gcc/analyzer/region-model.h", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a6564c9b277d9f93582605758d57457de696deb/gcc%2Fanalyzer%2Fregion-model.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a6564c9b277d9f93582605758d57457de696deb/gcc%2Fanalyzer%2Fregion-model.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model.h?ref=7a6564c9b277d9f93582605758d57457de696deb", "patch": "@@ -717,6 +717,9 @@ class region_model\n \t\t\t\t      const svalue *rhs) const;\n   tristate compare_initial_and_pointer (const initial_svalue *init,\n \t\t\t\t\tconst region_svalue *ptr) const;\n+  tristate symbolic_greater_than (const binop_svalue *a,\n+\t\t\t\t  const svalue *b) const;\n+  tristate structural_equality (const svalue *a, const svalue *b) const;\n   tristate eval_condition (tree lhs,\n \t\t\t   enum tree_code op,\n \t\t\t   tree rhs,\n@@ -874,6 +877,12 @@ class region_model\n \t\t\t      region_model_context *ctxt) const;\n   void check_region_size (const region *lhs_reg, const svalue *rhs_sval,\n \t\t\t  region_model_context *ctxt) const;\n+  void check_symbolic_bounds (const region *base_reg,\n+\t\t\t      const svalue *sym_byte_offset,\n+\t\t\t      const svalue *num_bytes_sval,\n+\t\t\t      const svalue *capacity,\n+\t\t\t      enum access_direction dir,\n+\t\t\t      region_model_context *ctxt) const;\n   void check_region_bounds (const region *reg, enum access_direction dir,\n \t\t\t    region_model_context *ctxt) const;\n "}, {"sha": "09646bfc98ab68afaa4943bd2fe4e719cfeb67fe", "filename": "gcc/analyzer/region.cc", "status": "modified", "additions": 117, "deletions": 14, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a6564c9b277d9f93582605758d57457de696deb/gcc%2Fanalyzer%2Fregion.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a6564c9b277d9f93582605758d57457de696deb/gcc%2Fanalyzer%2Fregion.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion.cc?ref=7a6564c9b277d9f93582605758d57457de696deb", "patch": "@@ -290,10 +290,10 @@ region::maybe_get_decl () const\n    first call and caching it internally).  */\n \n region_offset\n-region::get_offset () const\n+region::get_offset (region_model_manager *mgr) const\n {\n   if(!m_cached_offset)\n-    m_cached_offset = new region_offset (calc_offset ());\n+    m_cached_offset = new region_offset (calc_offset (mgr));\n   return *m_cached_offset;\n }\n \n@@ -491,10 +491,11 @@ region::get_subregions_for_binding (region_model_manager *mgr,\n    or a symbolic offset.  */\n \n region_offset\n-region::calc_offset () const\n+region::calc_offset (region_model_manager *mgr) const\n {\n   const region *iter_region = this;\n   bit_offset_t accum_bit_offset = 0;\n+  const svalue *accum_byte_sval = NULL;\n \n   while (iter_region)\n     {\n@@ -504,16 +505,36 @@ region::calc_offset () const\n \tcase RK_ELEMENT:\n \tcase RK_OFFSET:\n \tcase RK_BIT_RANGE:\n-\t  {\n-\t    bit_offset_t rel_bit_offset;\n-\t    if (!iter_region->get_relative_concrete_offset (&rel_bit_offset))\n-\t      return region_offset::make_symbolic\n-\t\t(iter_region->get_parent_region ());\n-\t    accum_bit_offset += rel_bit_offset;\n-\t    iter_region = iter_region->get_parent_region ();\n-\t  }\n+\t  if (accum_byte_sval)\n+\t    {\n+\t      const svalue *sval\n+\t\t= iter_region->get_relative_symbolic_offset (mgr);\n+\t      accum_byte_sval\n+\t\t= mgr->get_or_create_binop (sval->get_type (), PLUS_EXPR,\n+\t\t\t\t\t    accum_byte_sval, sval);\n+\t      iter_region = iter_region->get_parent_region ();\n+\t    }\n+\t  else\n+\t    {\n+\t      bit_offset_t rel_bit_offset;\n+\t      if (iter_region->get_relative_concrete_offset (&rel_bit_offset))\n+\t\t{\n+\t\t  accum_bit_offset += rel_bit_offset;\n+\t\t  iter_region = iter_region->get_parent_region ();\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  /* If the iter_region is not concrete anymore, convert the\n+\t\t     accumulated bits to a svalue in bytes and revisit the\n+\t\t     iter_region collecting the symbolic value.  */\n+\t\t  byte_offset_t byte_offset = accum_bit_offset / BITS_PER_UNIT;\n+\t\t  tree offset_tree = wide_int_to_tree (integer_type_node,\n+\t\t\t\t\t\t       byte_offset);\n+\t\t  accum_byte_sval\n+\t\t    = mgr->get_or_create_constant_svalue (offset_tree);\n+\t\t}\n+\t    }\n \t  continue;\n-\n \tcase RK_SIZED:\n \t  iter_region = iter_region->get_parent_region ();\n \t  continue;\n@@ -527,10 +548,18 @@ region::calc_offset () const\n \t  continue;\n \n \tdefault:\n-\t  return region_offset::make_concrete (iter_region, accum_bit_offset);\n+\t  return accum_byte_sval\n+\t\t  ? region_offset::make_symbolic (iter_region,\n+\t\t\t\t\t\t  accum_byte_sval)\n+\t\t  : region_offset::make_concrete (iter_region,\n+\t\t\t\t\t\t  accum_bit_offset);\n \t}\n     }\n-  return region_offset::make_concrete (iter_region, accum_bit_offset);\n+\n+  return accum_byte_sval ? region_offset::make_symbolic (iter_region,\n+\t\t\t\t\t\t\t accum_byte_sval)\n+\t\t\t : region_offset::make_concrete (iter_region,\n+\t\t\t\t\t\t\t accum_bit_offset);\n }\n \n /* Base implementation of region::get_relative_concrete_offset vfunc.  */\n@@ -541,6 +570,14 @@ region::get_relative_concrete_offset (bit_offset_t *) const\n   return false;\n }\n \n+/* Base implementation of region::get_relative_symbolic_offset vfunc.  */\n+\n+const svalue *\n+region::get_relative_symbolic_offset (region_model_manager *mgr) const\n+{\n+  return mgr->get_or_create_unknown_svalue (integer_type_node);\n+}\n+\n /* Attempt to get the position and size of this region expressed as a\n    concrete range of bytes relative to its parent.\n    If successful, return true and write to *OUT.\n@@ -1316,6 +1353,25 @@ field_region::get_relative_concrete_offset (bit_offset_t *out) const\n   return true;\n }\n \n+\n+/* Implementation of region::get_relative_symbolic_offset vfunc\n+   for field_region.\n+   If known, the returned svalue is equal to the offset converted to bytes and\n+   rounded off.  */\n+\n+const svalue *\n+field_region::get_relative_symbolic_offset (region_model_manager *mgr) const\n+{\n+  bit_offset_t out;\n+  if (get_relative_concrete_offset (&out))\n+    {\n+      tree cst_tree\n+\t= wide_int_to_tree (integer_type_node, out / BITS_PER_UNIT);\n+      return mgr->get_or_create_constant_svalue (cst_tree);\n+    }\n+  return mgr->get_or_create_unknown_svalue (integer_type_node);\n+}\n+\n /* class element_region : public region.  */\n \n /* Implementation of region::accept vfunc for element_region.  */\n@@ -1382,6 +1438,29 @@ element_region::get_relative_concrete_offset (bit_offset_t *out) const\n   return false;\n }\n \n+/* Implementation of region::get_relative_symbolic_offset vfunc\n+   for element_region.  */\n+\n+const svalue *\n+element_region::get_relative_symbolic_offset (region_model_manager *mgr) const\n+{\n+  tree elem_type = get_type ();\n+\n+  /* First, use int_size_in_bytes, to reject the case where we\n+     have an incomplete type, or a non-constant value.  */\n+  HOST_WIDE_INT hwi_byte_size = int_size_in_bytes (elem_type);\n+  if (hwi_byte_size > 0)\n+\t  {\n+      tree byte_size_tree = wide_int_to_tree (integer_type_node,\n+\t\t\t\t\t      hwi_byte_size);\n+      const svalue *byte_size_sval\n+\t= mgr->get_or_create_constant_svalue (byte_size_tree);\n+      return mgr->get_or_create_binop (integer_type_node, MULT_EXPR,\n+\t\t\t\t       m_index, byte_size_sval);\n+    }\n+  return mgr->get_or_create_unknown_svalue (integer_type_node);\n+}\n+\n /* class offset_region : public region.  */\n \n /* Implementation of region::accept vfunc for offset_region.  */\n@@ -1438,6 +1517,16 @@ offset_region::get_relative_concrete_offset (bit_offset_t *out) const\n   return false;\n }\n \n+/* Implementation of region::get_relative_symbolic_offset vfunc\n+   for offset_region.  */\n+\n+const svalue *\n+offset_region::get_relative_symbolic_offset (region_model_manager *mgr\n+\t\t\t\t\t      ATTRIBUTE_UNUSED) const\n+{\n+  return get_byte_offset ();\n+}\n+\n /* Implementation of region::get_byte_size_sval vfunc for offset_region.  */\n \n const svalue *\n@@ -1683,6 +1772,20 @@ bit_range_region::get_relative_concrete_offset (bit_offset_t *out) const\n   return true;\n }\n \n+/* Implementation of region::get_relative_symbolic_offset vfunc for\n+   bit_range_region.\n+   The returned svalue is equal to the offset converted to bytes and\n+   rounded off.  */\n+\n+const svalue *\n+bit_range_region::get_relative_symbolic_offset (region_model_manager *mgr)\n+  const\n+{\n+  byte_offset_t start_byte = m_bits.get_start_bit_offset () / BITS_PER_UNIT;\n+  tree start_bit_tree = wide_int_to_tree (integer_type_node, start_byte);\n+  return mgr->get_or_create_constant_svalue (start_bit_tree);\n+}\n+\n /* class var_arg_region : public region.  */\n \n void"}, {"sha": "6315fac62e543782a43f8cb4ddbcd3ce8a0d84e5", "filename": "gcc/analyzer/region.h", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a6564c9b277d9f93582605758d57457de696deb/gcc%2Fanalyzer%2Fregion.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a6564c9b277d9f93582605758d57457de696deb/gcc%2Fanalyzer%2Fregion.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion.h?ref=7a6564c9b277d9f93582605758d57457de696deb", "patch": "@@ -175,7 +175,7 @@ class region\n \n   bool involves_p (const svalue *sval) const;\n \n-  region_offset get_offset () const;\n+  region_offset get_offset (region_model_manager *mgr) const;\n \n   /* Attempt to get the size of this region as a concrete number of bytes.\n      If successful, return true and write the size to *OUT.\n@@ -196,6 +196,11 @@ class region\n      Otherwise return false.  */\n   virtual bool get_relative_concrete_offset (bit_offset_t *out) const;\n \n+  /* Get the offset in bytes of this region relative to its parent as a svalue.\n+     Might return an unknown_svalue.  */\n+  virtual const svalue *\n+  get_relative_symbolic_offset (region_model_manager *mgr) const;\n+\n   /* Attempt to get the position and size of this region expressed as a\n      concrete range of bytes relative to its parent.\n      If successful, return true and write to *OUT.\n@@ -226,7 +231,7 @@ class region\n   region (complexity c, unsigned id, const region *parent, tree type);\n \n  private:\n-  region_offset calc_offset () const;\n+  region_offset calc_offset (region_model_manager *mgr) const;\n \n   complexity m_complexity;\n   unsigned m_id; // purely for deterministic sorting at this stage, for dumps\n@@ -751,6 +756,8 @@ class field_region : public region\n   tree get_field () const { return m_field; }\n \n   bool get_relative_concrete_offset (bit_offset_t *out) const final override;\n+  const svalue *get_relative_symbolic_offset (region_model_manager *mgr)\n+    const final override;\n \n private:\n   tree m_field;\n@@ -835,6 +842,8 @@ class element_region : public region\n \n   virtual bool\n   get_relative_concrete_offset (bit_offset_t *out) const final override;\n+  const svalue *get_relative_symbolic_offset (region_model_manager *mgr)\n+    const final override;\n \n private:\n   const svalue *m_index;\n@@ -919,6 +928,8 @@ class offset_region : public region\n   const svalue *get_byte_offset () const { return m_byte_offset; }\n \n   bool get_relative_concrete_offset (bit_offset_t *out) const final override;\n+  const svalue *get_relative_symbolic_offset (region_model_manager *mgr)\n+    const final override;\n   const svalue * get_byte_size_sval (region_model_manager *mgr)\n     const final override;\n \n@@ -1245,6 +1256,8 @@ class bit_range_region : public region\n   bool get_bit_size (bit_size_t *out) const final override;\n   const svalue *get_byte_size_sval (region_model_manager *mgr) const final override;\n   bool get_relative_concrete_offset (bit_offset_t *out) const final override;\n+  const svalue *get_relative_symbolic_offset (region_model_manager *mgr)\n+    const final override;\n \n private:\n   bit_range m_bits;"}, {"sha": "ec5232cb055eaae3f9de8ebc59e6ddab304b58ca", "filename": "gcc/analyzer/store.cc", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a6564c9b277d9f93582605758d57457de696deb/gcc%2Fanalyzer%2Fstore.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a6564c9b277d9f93582605758d57457de696deb/gcc%2Fanalyzer%2Fstore.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fstore.cc?ref=7a6564c9b277d9f93582605758d57457de696deb", "patch": "@@ -123,7 +123,7 @@ uncertainty_t::dump (bool simple) const\n const binding_key *\n binding_key::make (store_manager *mgr, const region *r)\n {\n-  region_offset offset = r->get_offset ();\n+  region_offset offset = r->get_offset (mgr->get_svalue_manager ());\n   if (offset.symbolic_p ())\n     return mgr->get_symbolic_binding (r);\n   else\n@@ -897,7 +897,7 @@ binding_map::apply_ctor_val_to_range (const region *parent_reg,\n     = get_subregion_within_ctor (parent_reg, min_index, mgr);\n   const region *max_element\n     = get_subregion_within_ctor (parent_reg, max_index, mgr);\n-  region_offset min_offset = min_element->get_offset ();\n+  region_offset min_offset = min_element->get_offset (mgr);\n   if (min_offset.symbolic_p ())\n     return false;\n   bit_offset_t start_bit_offset = min_offset.get_bit_offset ();\n@@ -955,11 +955,11 @@ binding_map::apply_ctor_pair_to_child_region (const region *parent_reg,\n \t  gcc_assert (sval_byte_size != -1);\n \t  bit_size_t sval_bit_size = sval_byte_size * BITS_PER_UNIT;\n \t  /* Get offset of child relative to base region.  */\n-\t  region_offset child_base_offset = child_reg->get_offset ();\n+\t  region_offset child_base_offset = child_reg->get_offset (mgr);\n \t  if (child_base_offset.symbolic_p ())\n \t    return false;\n \t  /* Convert to an offset relative to the parent region.  */\n-\t  region_offset parent_base_offset = parent_reg->get_offset ();\n+\t  region_offset parent_base_offset = parent_reg->get_offset (mgr);\n \t  gcc_assert (!parent_base_offset.symbolic_p ());\n \t  bit_offset_t child_parent_offset\n \t    = (child_base_offset.get_bit_offset ()\n@@ -1365,7 +1365,8 @@ binding_cluster::bind_compound_sval (store_manager *mgr,\n \t\t\t\t     const region *reg,\n \t\t\t\t     const compound_svalue *compound_sval)\n {\n-  region_offset reg_offset = reg->get_offset ();\n+  region_offset reg_offset\n+    = reg->get_offset (mgr->get_svalue_manager ());\n   if (reg_offset.symbolic_p ())\n     {\n       m_touched = true;\n@@ -1614,7 +1615,7 @@ binding_cluster::get_any_binding (store_manager *mgr,\n   /* Alternatively, if this is a symbolic read and the cluster has any bindings,\n      then we don't know if we're reading those values or not, so the result\n      is also \"UNKNOWN\".  */\n-  if (reg->get_offset ().symbolic_p ()\n+  if (reg->get_offset (mgr->get_svalue_manager ()).symbolic_p ()\n       && m_map.elements () > 0)\n     {\n       region_model_manager *rmm_mgr = mgr->get_svalue_manager ();\n@@ -1643,10 +1644,11 @@ const svalue *\n binding_cluster::maybe_get_compound_binding (store_manager *mgr,\n \t\t\t\t\t     const region *reg) const\n {\n-  region_offset cluster_offset = m_base_region->get_offset ();\n+  region_offset cluster_offset\n+    = m_base_region->get_offset (mgr->get_svalue_manager ());\n   if (cluster_offset.symbolic_p ())\n     return NULL;\n-  region_offset reg_offset = reg->get_offset ();\n+  region_offset reg_offset = reg->get_offset (mgr->get_svalue_manager ());\n   if (reg_offset.symbolic_p ())\n     return NULL;\n "}, {"sha": "5c066219a7d6cce9ec346a5ac60d41b2a0d32a8e", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a6564c9b277d9f93582605758d57457de696deb/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a6564c9b277d9f93582605758d57457de696deb/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=7a6564c9b277d9f93582605758d57457de696deb", "patch": "@@ -10051,9 +10051,11 @@ This warning requires @option{-fanalyzer} to enable it; use\n @option{-Wno-analyzer-out-of-bounds} to disable it.\n \n This diagnostic warns for path through the code in which a buffer is\n-definitely read or written out-of-bounds.  The diagnostic only applies\n-for cases where the analyzer is able to determine a constant offset and\n-for accesses past the end of a buffer, also a constant capacity.\n+definitely read or written out-of-bounds.  The diagnostic applies for\n+cases where the analyzer is able to determine a constant offset and for\n+accesses past the end of a buffer, also a constant capacity.  Further,\n+the diagnostic does limited checking for accesses past the end when the\n+offset as well as the capacity is symbolic.\n \n See @uref{https://cwe.mitre.org/data/definitions/119.html, CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer}.\n "}, {"sha": "d8930d189bbda878f39a448c74157f6d004bdf93", "filename": "gcc/testsuite/gcc.dg/analyzer/data-model-1.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a6564c9b277d9f93582605758d57457de696deb/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fdata-model-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a6564c9b277d9f93582605758d57457de696deb/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fdata-model-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fdata-model-1.c?ref=7a6564c9b277d9f93582605758d57457de696deb", "patch": "@@ -624,8 +624,7 @@ void test_29a (struct coord p[])\n   __analyzer_eval (q[-2].y == 107025); /* { dg-warning \"TRUE\" } */\n \n   q -= 2;\n-  __analyzer_eval (q == &p[7]); /* { dg-warning \"UNKNOWN\" } */\n-  // TODO: make this be TRUE\n+  __analyzer_eval (q == &p[7]); /* { dg-warning \"TRUE\" } */\n \n   __analyzer_eval (q->x == 107024); /* { dg-warning \"TRUE\" } */\n   __analyzer_eval (q->y == 107025); /* { dg-warning \"TRUE\" } */"}, {"sha": "7dc0bc5bf18ebe70739b7cbfaf96fab67097814f", "filename": "gcc/testsuite/gcc.dg/analyzer/out-of-bounds-5.c", "status": "added", "additions": 156, "deletions": 0, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a6564c9b277d9f93582605758d57457de696deb/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fout-of-bounds-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a6564c9b277d9f93582605758d57457de696deb/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fout-of-bounds-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fout-of-bounds-5.c?ref=7a6564c9b277d9f93582605758d57457de696deb", "patch": "@@ -0,0 +1,156 @@\n+/* { dg-additional-options \"-Wno-unused-but-set-variable\" } */\n+\n+#include <string.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <alloca.h>\n+#include <stdint.h>\n+\n+/* Tests with symbolic values.  */\n+\n+void test1 (size_t size)\n+{\n+  char *buf = __builtin_malloc (size);\n+  if (!buf) return;\n+\n+  buf[size] = '\\0'; /* { dg-warning \"overflow\" } */\n+  free (buf);\n+}\n+\n+void test2 (size_t size)\n+{\n+  char *buf = __builtin_malloc (size);\n+  if (!buf) return;\n+\n+  buf[size + 1] = '\\0'; /* { dg-warning \"overflow\" } */\n+  free (buf);\n+}\n+\n+void test3 (size_t size, size_t op)\n+{\n+  char *buf = __builtin_malloc (size);\n+  if (!buf) return;\n+\n+  buf[size + op] = '\\0'; /* { dg-warning \"overflow\" } */\n+  free (buf);\n+}\n+\n+void test4 (size_t size, unsigned short s)\n+{\n+  char *buf = __builtin_alloca (size);\n+  buf[size + s] = '\\0'; /* { dg-warning \"overflow\" } */\n+}\n+\n+void test5 (size_t size)\n+{\n+  int32_t *buf = __builtin_alloca (4 * size);\n+  buf[size] = 42; /* { dg-warning \"overflow\" } */\n+}\n+\n+void test6 (size_t size)\n+{\n+  int32_t *buf = __builtin_alloca (4 * size);\n+  memset (buf, 0, 4 * size);\n+  int32_t last = *(buf + 4 * size); /* { dg-warning \"overread\" } */\n+}\n+\n+void test7 (size_t size)\n+{\n+  int32_t *buf = __builtin_alloca (4 * size + 3); /* { dg-warning \"allocated buffer size is not a multiple of the pointee's size\" } */\n+  buf[size] = 42; /* { dg-warning \"overflow\" } */\n+}\n+\n+/* Test where the offset itself is not out-of-bounds\n+   but multiple bytes are read.  */\n+\n+void test8 (size_t size, size_t offset)\n+{\n+  char src[size];\n+  char dst[size];\n+  memcpy (dst, src, size + offset); /* { dg-line test8 } */\n+  /* { dg-warning \"overread\" \"warning\" { target *-*-* } test8 } */\n+  /* { dg-warning \"overflow\" \"warning\" { target *-*-* } test8 } */\n+}\n+\n+void test9 (size_t size, size_t offset)\n+{\n+  int32_t src[size];\n+  int32_t dst[size];\n+  memcpy (dst, src, 4 * size + 1); /* { dg-line test9 } */\n+  /* { dg-warning \"overread\" \"warning\" { target *-*-* } test9 } */\n+  /* { dg-warning \"overflow\" \"warning\" { target *-*-* } test9 } */\n+}\n+\n+/* Test for no false-positives.  */\n+\n+void test10 (size_t size)\n+{\n+  int32_t buf[4 * size];\n+  /* 4 * size is smaller than 4 * 4 * size.  */\n+  buf[size] = 42;\n+}\n+\n+void test11 (size_t size)\n+{\n+  int32_t *buf = __builtin_alloca (4 * size + 5); /* { dg-warning \"allocated buffer size is not a multiple of the pointee's size\" } */\n+  buf[size] = 42;\n+}\n+\n+void test12 (size_t size, size_t offset)\n+{\n+  int buf[size];\n+  buf[offset] = 42;\n+}\n+\n+void test13 (size_t size, int offset)\n+{\n+  int buf[size];\n+  /* We don't know whether offset is positive or not.  */\n+  buf[size + offset] = 42;\n+}\n+\n+void test14 (size_t size, size_t offset, size_t offset2)\n+{\n+  int buf[size];\n+  /* We don't know whether offset > offset2.  */\n+  buf[size + offset - offset2] = 42;\n+}\n+\n+void test15 (size_t a, size_t b)\n+{\n+  int buf[a * b];\n+  /* We can't reason about a*b < a+b either.  */\n+  buf[a + b] = 42;\n+}\n+\n+/* Misc.  */\n+\n+char *test98 (const char *x, const char *y)\n+{\n+  size_t len_x = __builtin_strlen (x);\n+  size_t len_y = __builtin_strlen (y);\n+  size_t sz = len_x + len_y + 1;\n+  char *result = __builtin_malloc (sz);\n+  if (!result)\n+    return NULL;\n+  __builtin_memcpy (result, x, len_x);\n+  __builtin_memcpy (result + len_x, y, len_y);\n+  result[len_x + len_y] = '\\0';\n+  return result;\n+}\n+\n+char *test99 (const char *x, const char *y)\n+{\n+  size_t len_x = __builtin_strlen (x);\n+  size_t len_y = __builtin_strlen (y);\n+  /* BUG (root cause): forgot to add 1 for terminator.  */\n+  size_t sz = len_x + len_y;\n+  char *result = __builtin_malloc (sz);\n+  if (!result)\n+    return NULL;\n+  __builtin_memcpy (result, x, len_x);\n+  __builtin_memcpy (result + len_x, y, len_y);\n+  /* BUG (symptom): off-by-one out-of-bounds write to heap.  */\n+  result[len_x + len_y] = '\\0'; /* { dg-warning \"overflow\" } */\n+  return result;\n+}"}, {"sha": "707611e08a6163bea0862bf3b4e05d7a2a6393db", "filename": "gcc/testsuite/gcc.dg/analyzer/out-of-bounds-realloc-grow.c", "status": "added", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a6564c9b277d9f93582605758d57457de696deb/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fout-of-bounds-realloc-grow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a6564c9b277d9f93582605758d57457de696deb/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fout-of-bounds-realloc-grow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fout-of-bounds-realloc-grow.c?ref=7a6564c9b277d9f93582605758d57457de696deb", "patch": "@@ -0,0 +1,87 @@\n+/* { dg-additional-options \"-Wno-analyzer-too-complex\" } */\n+\n+/* Reduced from gnulib/read-file.c.\n+\n+   Tests that there is no false-positive on\n+   realloc when the buffer is growing.  */\n+\n+#include <stdlib.h>\n+\n+/* Indicate that the file is treated as binary.  */\n+#define RF_BINARY 0x1\n+\n+#include <stdio.h>\n+#include <stdint.h>\n+#include <string.h>\n+#include <errno.h>\n+\n+char *\n+fread_file (FILE *stream, int flags, size_t *length)\n+{\n+  char *buf = NULL;\n+  size_t alloc = BUFSIZ;\n+\n+  if (!(buf = malloc (alloc)))\n+    return NULL; /* errno is ENOMEM.  */\n+\n+  {\n+    size_t size = 0; /* number of bytes read so far */\n+    int save_errno;\n+\n+    for (;;)\n+      {\n+        /* This reads 1 more than the size of a regular file\n+           so that we get eof immediately.  */\n+        size_t requested = alloc - size;\n+        size_t count = fread (buf + size, 1, requested, stream);\n+        size += count;\n+\n+        {\n+          char *new_buf;\n+\n+          if (alloc < PTRDIFF_MAX - alloc / 2)\n+            alloc = alloc + alloc / 2;\n+          else\n+            alloc = PTRDIFF_MAX;\n+\n+           if (!(new_buf = realloc (buf, alloc)))\n+            {\n+              save_errno = errno;\n+              break;\n+            }\n+\n+          buf = new_buf;\n+        }\n+      }\n+\n+    free (buf);\n+    errno = save_errno;\n+    return NULL;\n+  }\n+}\n+\n+/* Open and read the contents of FILENAME, and return a newly\n+   allocated string with the content, and set *LENGTH to the length of\n+   the string.  The string is zero-terminated, but the terminating\n+   zero byte is not counted in *LENGTH.  On errors, *LENGTH is\n+   undefined, errno preserves the values set by system functions (if\n+   any), and NULL is returned.\n+   If the RF_BINARY flag is set in FLAGS, the file is opened in binary\n+   mode.  If the RF_SENSITIVE flag is set in FLAGS, the memory buffer\n+   internally allocated will be cleared upon failure.  */\n+char *\n+read_file (const char *filename, int flags, size_t *length)\n+{\n+  const char *mode = (flags & RF_BINARY) ? \"rbe\" : \"re\";\n+  FILE *stream = fopen (filename, mode);\n+  char *out;\n+\n+  if (!stream)\n+    return NULL;\n+\n+  out = fread_file (stream, flags, length);\n+\n+  fclose (stream);\n+\n+  return out;\n+}"}, {"sha": "140abce6961a4bd5f976ca415c23776cd7b8f852", "filename": "gcc/testsuite/gcc.dg/analyzer/symbolic-gt-1.c", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a6564c9b277d9f93582605758d57457de696deb/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fsymbolic-gt-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a6564c9b277d9f93582605758d57457de696deb/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fsymbolic-gt-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fsymbolic-gt-1.c?ref=7a6564c9b277d9f93582605758d57457de696deb", "patch": "@@ -0,0 +1,76 @@\n+#include <string.h>\n+#include \"analyzer-decls.h\"\n+\n+/* Test GT_EXPR comparison of symbolic values.  */\n+\n+void test1 (size_t size)\n+{\n+  size_t a = 4 * size + 1;\n+  size_t b = 4 * size;\n+  __analyzer_eval (a > b); /* { dg-warning \"TRUE\" } */\n+}\n+\n+void test2 (size_t size, size_t offset)\n+{\n+  size_t a = size + offset;\n+  size_t b = size;\n+  __analyzer_eval (a > b); /* { dg-warning \"TRUE\" } */\n+}\n+\n+void test3 (size_t size, size_t offset)\n+{\n+  size_t a = size * offset;\n+  size_t b = size;\n+  __analyzer_eval (a > b); /* { dg-warning \"TRUE\" } */\n+}\n+\n+void test4 (size_t size)\n+{\n+  size_t op = -1;\n+  size_t a = size + op;\n+  size_t b = size;\n+  __analyzer_eval (a > b); /* { dg-warning \"UNKNOWN\" } */\n+}\n+\n+void test5 (size_t size)\n+{\n+  size_t a = size - 1;\n+  size_t b = size;\n+  __analyzer_eval (a > b); /* { dg-warning \"UNKNOWN\" } */\n+}\n+\n+void test6 (size_t size, int offset)\n+{\n+  /* OFFSET is a symbolic integer, thus could be negative.  */\n+  size_t a = size + offset;\n+  size_t b = size;\n+  __analyzer_eval (a > b); /* { dg-warning \"UNKNOWN\" } */\n+}\n+\n+void test7 (size_t size, size_t mul)\n+{\n+  size_t a = mul * size + 1;\n+  size_t b = mul * size;\n+  __analyzer_eval (a > b); /* { dg-warning \"TRUE\" } */\n+}\n+\n+void test8 (size_t size)\n+{\n+  size_t a = size - 5;\n+  size_t b = size - 1;\n+  __analyzer_eval (a > b); /* { dg-warning \"UNKNOWN\" } */\n+}\n+\n+void test9 (size_t size)\n+{\n+  size_t a = size + 1;\n+  size_t b = size + 2;\n+  __analyzer_eval (a > b); /* { dg-warning \"UNKNOWN\" } */\n+}\n+\n+void test10 (size_t size)\n+{\n+  size_t a = size + 2;\n+  size_t b = size + 1;\n+  __analyzer_eval (a > b); /* { dg-warning \"TRUE\" } */\n+}"}]}