{"sha": "114cbee61c04db655b2a2987366a8326df89fbef", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTE0Y2JlZTYxYzA0ZGI2NTViMmEyOTg3MzY2YTgzMjZkZjg5ZmJlZg==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-01-19T04:23:39Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-01-19T04:23:39Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r217", "tree": {"sha": "7cc6295dad7ae1b102e0bdee8cbdc4c76acbe5f2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7cc6295dad7ae1b102e0bdee8cbdc4c76acbe5f2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/114cbee61c04db655b2a2987366a8326df89fbef", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/114cbee61c04db655b2a2987366a8326df89fbef", "html_url": "https://github.com/Rust-GCC/gccrs/commit/114cbee61c04db655b2a2987366a8326df89fbef", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/114cbee61c04db655b2a2987366a8326df89fbef/comments", "author": null, "committer": null, "parents": [{"sha": "e13d81d074d439ce1138092ca455f9dd7b68582f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e13d81d074d439ce1138092ca455f9dd7b68582f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e13d81d074d439ce1138092ca455f9dd7b68582f"}], "stats": {"total": 1039, "additions": 954, "deletions": 85}, "files": [{"sha": "7da84b43ae2e858482baba4ffe7432c0142faaea", "filename": "gcc/ginclude/va-i860.h", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/114cbee61c04db655b2a2987366a8326df89fbef/gcc%2Fginclude%2Fva-i860.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/114cbee61c04db655b2a2987366a8326df89fbef/gcc%2Fginclude%2Fva-i860.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fginclude%2Fva-i860.h?ref=114cbee61c04db655b2a2987366a8326df89fbef", "patch": "@@ -46,10 +46,10 @@ typedef struct {\n #ifdef __SVR4__\n   unsigned\t__ireg_used;\t/* How many int regs consumed 'til now? */\n   unsigned\t__freg_used;\t/* How many flt regs consumed 'til now? */\n-  __va_saved_regs *__reg_base;\t/* Address of where we stored the regs. */\n+  long\t\t*__reg_base;\t/* Address of where we stored the regs. */\n   long *\t__mem_ptr;\t/* Address of memory overflow args area. */\n #else /* pre-SVR4 */\n-  __va_saved_regs *__reg_base;\t/* Address of where we stored the regs. */\n+  long\t\t*__reg_base;\t/* Address of where we stored the regs. */\n   long *\t__mem_ptr;\t/* Address of memory overflow args area. */\n   unsigned\t__ireg_used;\t/* How many int regs consumed 'til now? */\n   unsigned\t__freg_used;\t/* How many flt regs consumed 'til now? */\n@@ -88,7 +88,7 @@ enum {\n #define __NUM_PARM_FREGS\t8\n #define __NUM_PARM_IREGS\t12\n \n-#define __savereg(__va) (__va.__reg_base)\n+#define __savereg(__va) ((__va_saved_regs *) (__va.__reg_base)\n \n /* This macro works both for SVR4 and pre-SVR4 environments.  */\n \n@@ -105,6 +105,7 @@ enum {\n #endif\n \n #define va_arg(__va, __type)\t\t\t\t\t\t\\\n+__extension__\t\t\t\t\t\t\t\t\\\n (* (__type *)\t\t\t\t\t\t\t\t\\\n ({\t\t\t\t\t\t\t\t\t\\\n   register void *__rv;  /* result value */\t\t\t\t\\"}, {"sha": "ec2c37c6c38f2b12650fbe93dbcc196cb263f72b", "filename": "gcc/reg-stack.c", "status": "modified", "additions": 950, "deletions": 82, "changes": 1032, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/114cbee61c04db655b2a2987366a8326df89fbef/gcc%2Freg-stack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/114cbee61c04db655b2a2987366a8326df89fbef/gcc%2Freg-stack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freg-stack.c?ref=114cbee61c04db655b2a2987366a8326df89fbef", "patch": "@@ -1,5 +1,5 @@\n /* Register to Stack convert for GNU compiler.\n-   Copyright (C) 1990 Free Software Foundation, Inc.\n+   Copyright (C) 1992 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -30,8 +30,7 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n    numbers have been substituted, and various pop and exchange insns have\n    been emitted.  The hard register numbers and the virtual register\n    numbers completely overlap - before this pass, all stack register\n-   numbers are virtual, and afterward they are all hard, with the\n-   exception of ASM_OPERANDS, which are discussed below.\n+   numbers are virtual, and afterward they are all hard.\n \n    The virtual registers can be manipulated normally by gcc, and their\n    semantics are the same as for normal registers.  After the hard\n@@ -81,14 +80,87 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n    information is valid until after reg_to_stack returns, and is used\n    from jump_optimize.\n \n-   * Limitations:\n+   * asm_operands:\n \n-   Inline assembly isn't handled yet. */\n+   There are several rules on the usage of stack-like regs in\n+   asm_operands insns.  These rules apply only to the operands that are\n+   stack-like regs:\n+\n+   1. Given a set of input regs that die in an asm_operands, it is\n+      necessary to know which are implicitly popped by the asm, and\n+      which must be explicitly popped by gcc.\n+\n+\tAn input reg that is implicitly popped by the asm must be\n+\texplicitly clobbered, unless it is constrained to match an\n+\toutput operand.\n+\n+   2. For any input reg that is implicitly popped by an asm, it is\n+      necessary to know how to adjust the stack to compensate for the pop.\n+      If any non-popped input is closer to the top of the reg-stack than\n+      the implicitly popped reg, it would not be possible to know what the\n+      stack looked like - it's not clear how the rest of the stack \"slides\n+      up\".\n+\n+\tAll implicitly popped input regs must be closer to the top of\n+\tthe reg-stack than any input that is not implicitly popped.\n+\n+   3. It is possible that if an input dies in an insn, reload might\n+      use the input reg for an output reload.  Consider this example:\n+\n+\t\tasm (\"foo\" : \"=t\" (a) : \"f\" (b));\n+\n+      This asm says that input B is not popped by the asm, and that\n+      the asm pushes a result onto the reg-stack, ie, the stack is one\n+      deeper after the asm than it was before.  But, it is possible that\n+      reload will think that it can use the same reg for both the input and\n+      the output, if input B dies in this insn.\n+\n+\tIf any input operand uses the \"f\" constraint, all output reg\n+\tconstraints must use the \"&\" earlyclobber.\n+\n+      The asm above would be written as\n+\n+\t\tasm (\"foo\" : \"=&t\" (a) : \"f\" (b));\n+\n+   4. Some operands need to be in particular places on the stack.  All\n+      output operands fall in this category - there is no other way to\n+      know which regs the outputs appear in unless the user indicates\n+      this in the constraints.\n+\n+\tOutput operands must specifically indicate which reg an output\n+\tappears in after an asm.  \"=f\" is not allowed: the operand\n+\tconstraints must select a class with a single reg.\n+\n+   5. Output operands may not be \"inserted\" between existing stack regs.\n+      Since no 387 opcode uses a read/write operand, all output operands\n+      are dead before the asm_operands, and are pushed by the asm_operands.\n+      It makes no sense to push anywhere but the top of the reg-stack.\n+\n+\tOutput operands must start at the top of the reg-stack: output\n+\toperands may not \"skip\" a reg.\n+\n+   6. Some asm statements may need extra stack space for internal\n+      calculations.  This can be guaranteed by clobbering stack registers\n+      unrelated to the inputs and outputs.\n+\n+   Here are a couple of reasonable asms to want to write.  This asm\n+   takes one input, which is internally popped, and produces two outputs.\n+\n+\tasm (\"fsincos\" : \"=t\" (cos), \"=u\" (sin) : \"0\" (inp));\n+\n+   This asm takes two inputs, which are popped by the fyl2xp1 opcode,\n+   and replaces them with one output.  The user must code the \"st(1)\"\n+   clobber for reg-stack.c to know that fyl2xp1 pops both inputs.\n+\n+\tasm (\"fyl2xp1\" : \"=t\" (result) : \"0\" (x), \"u\" (y) : \"st(1)\");\n+\n+   */\n \f\n #include <stdio.h>\n #include \"config.h\"\n #include \"tree.h\"\n #include \"rtl.h\"\n+#include \"insn-config.h\"\n #include \"regs.h\"\n #include \"hard-reg-set.h\"\n #include \"flags.h\"\n@@ -147,9 +219,6 @@ static short *block_number;\n /* This is the register file for all register after conversion */\n static rtx FP_mode_reg[FIRST_PSEUDO_REGISTER][(int) MAX_MACHINE_MODE];\n \n-/* ??? set of register to delete after ASM_OPERAND */\n-HARD_REG_SET asm_regs;\n-\n /* Get the basic block number of an insn.  See note at block_number\n    definition are validity of this information. */\n \n@@ -168,10 +237,9 @@ extern rtx emit_label_after ();\n \n static void find_blocks ();\n static void stack_reg_life_analysis ();\n+static void change_stack ();\n static void convert_regs ();\n static void dump_stack_info ();\n-static void fatal_for_asm ();\n-\f\n \f\n /* Return non-zero if any stack register is mentioned somewhere within\n    PAT. */\n@@ -410,6 +478,503 @@ record_note_if_dead (insn, regstack, reg, dest)\n       abort ();\n }\n \f\n+/* Scan the OPERANDS and OPERAND_CONSTRAINTS of an asm_operands.\n+   N_OPERANDS is the total number of operands.  Return which alternative\n+   matched, or -1 is no alternative matches.\n+\n+   OPERAND_MATCHES is an array which indicates which operand this\n+   operand matches due to the constraints, or -1 if no match is required.\n+   If two operands match by coincidence, but are not required to match by\n+   the constraints, -1 is returned.\n+\n+   OPERAND_CLASS is an array which indicates the smallest class\n+   required by the constraints.  If the alternative that matches calls\n+   for some class `class', and the operand matches a subclass of `class',\n+   OPERAND_CLASS is set to `class' as required by the constraints, not to\n+   the subclass. If an alternative allows more than one class,\n+   OPERAND_CLASS is set to the smallest class that is a union of the\n+   allowed classes. */\n+\n+static int\n+constrain_asm_operands (n_operands, operands, operand_constraints,\n+\t\t\toperand_matches, operand_class)\n+     int n_operands;\n+     rtx *operands;\n+     char **operand_constraints;\n+     int *operand_matches;\n+     enum reg_class *operand_class;\n+{\n+  char **constraints = (char **) alloca (n_operands * sizeof (char *));\n+  char *q;\n+  int this_alternative, this_operand;\n+  int n_alternatives;\n+  int j;\n+\n+  for (j = 0; j < n_operands; j++)\n+    constraints[j] = operand_constraints[j];\n+\n+  /* Compute the number of alternatives in the operands.  reload has\n+     already guaranteed that all operands have the same number of\n+     alternatives.  */\n+\n+  n_alternatives = 1;\n+  for (q = constraints[0]; *q; q++)\n+    n_alternatives += (*q == ',');\n+\n+  this_alternative = 0;\n+  while (this_alternative < n_alternatives)\n+    {\n+      int lose = 0;\n+      int i;\n+\n+      /* No operands match, no narrow class requirements yet.  */\n+      for (i = 0; i < n_operands; i++)\n+\t{\n+\t  operand_matches[i] = -1;\n+\t  operand_class[i] = NO_REGS;\n+\t}\n+\n+      for (this_operand = 0; this_operand < n_operands; this_operand++)\n+\t{\n+\t  rtx op = operands[this_operand];\n+\t  enum machine_mode mode = GET_MODE (op);\n+\t  char *p = constraints[this_operand];\n+\t  int offset = 0;\n+\t  int win = 0;\n+\t  int c;\n+\n+\t  if (GET_CODE (op) == SUBREG)\n+\t    {\n+\t      if (GET_CODE (SUBREG_REG (op)) == REG\n+\t\t  && REGNO (SUBREG_REG (op)) < FIRST_PSEUDO_REGISTER)\n+\t\toffset = SUBREG_WORD (op);\n+\t      op = SUBREG_REG (op);\n+\t    }\n+\n+\t  /* An empty constraint or empty alternative\n+\t     allows anything which matched the pattern.  */\n+\t  if (*p == 0 || *p == ',')\n+\t    win = 1;\n+\n+\t  while (*p && (c = *p++) != ',')\n+\t    switch (c)\n+\t      {\n+\t      case '=':\n+\t      case '+':\n+\t      case '?':\n+\t      case '#':\n+\t      case '&':\n+\t      case '!':\n+\t      case '*':\n+\t      case '%':\n+\t\t/* Ignore these. */\n+\t\tbreak;\n+\n+\t      case '0':\n+\t      case '1':\n+\t      case '2':\n+\t      case '3':\n+\t      case '4':\n+\t      case '5':\n+\t\t/* This operand must be the same as a previous one.\n+\t\t   This kind of constraint is used for instructions such\n+\t\t   as add when they take only two operands.\n+\n+\t\t   Note that the lower-numbered operand is passed first. */\n+\n+\t\tif (operands_match_p (operands[c - '0'],\n+\t\t\t\t      operands[this_operand]))\n+\t\t  {\n+\t\t    operand_matches[this_operand] = c - '0';\n+\t\t    win = 1;\n+\t\t  }\n+\t\tbreak;\n+\n+\t      case 'p':\n+\t\t/* p is used for address_operands.  Since this is an asm,\n+\t\t   just to make sure that the operand is valid for Pmode. */\n+\n+\t\tif (strict_memory_address_p (Pmode, op))\n+\t\t  win = 1;\n+\t\tbreak;\n+\n+\t      case 'g':\n+\t\t/* Anything goes unless it is a REG and really has a hard reg\n+\t\t   but the hard reg is not in the class GENERAL_REGS.  */\n+\t\tif (GENERAL_REGS == ALL_REGS\n+\t\t    || GET_CODE (op) != REG\n+\t\t    || reg_fits_class_p (op, GENERAL_REGS, offset, mode))\n+\t\t  {\n+\t\t    if (GET_CODE (op) == REG)\n+\t\t      operand_class[this_operand]\n+\t\t\t= reg_class_subunion[(int) operand_class[this_operand]][(int) GENERAL_REGS];\n+\t\t    win = 1;\n+\t\t  }\n+\t\tbreak;\n+\n+\t      case 'r':\n+\t\tif (GET_CODE (op) == REG\n+\t\t    && (GENERAL_REGS == ALL_REGS\n+\t\t\t|| reg_fits_class_p (op, GENERAL_REGS, offset, mode)))\n+\t\t  {\n+\t\t    operand_class[this_operand]\n+\t\t      = reg_class_subunion[(int) operand_class[this_operand]][(int) GENERAL_REGS];\n+\t\t    win = 1;\n+\t\t  }\n+\t\tbreak;\n+\n+\t      case 'X':\n+\t\t/* This is used for a MATCH_SCRATCH in the cases when we\n+\t\t   don't actually need anything.  So anything goes any time. */\n+\t\twin = 1;\n+\t\tbreak;\n+\n+\t      case 'm':\n+\t\tif (GET_CODE (op) == MEM)\n+\t\t  win = 1;\n+\t\tbreak;\n+\n+\t      case '<':\n+\t\tif (GET_CODE (op) == MEM\n+\t\t    && (GET_CODE (XEXP (op, 0)) == PRE_DEC\n+\t\t\t|| GET_CODE (XEXP (op, 0)) == POST_DEC))\n+\t\t  win = 1;\n+\t\tbreak;\n+\n+\t      case '>':\n+\t\tif (GET_CODE (op) == MEM\n+\t\t    && (GET_CODE (XEXP (op, 0)) == PRE_INC\n+\t\t\t|| GET_CODE (XEXP (op, 0)) == POST_INC))\n+\t\t  win = 1;\n+\t\tbreak;\n+\n+\t      case 'E':\n+\t\t/* Match any CONST_DOUBLE, but only if\n+\t\t   we can examine the bits of it reliably.  */\n+\t\tif ((HOST_FLOAT_FORMAT != TARGET_FLOAT_FORMAT\n+\t\t     || HOST_BITS_PER_INT != BITS_PER_WORD)\n+\t\t    && GET_CODE (op) != VOIDmode && ! flag_pretend_float)\n+\t\t  break;\n+\t\tif (GET_CODE (op) == CONST_DOUBLE)\n+\t\t  win = 1;\n+\t\tbreak;\n+\n+\t      case 'F':\n+\t\tif (GET_CODE (op) == CONST_DOUBLE)\n+\t\t  win = 1;\n+\t\tbreak;\n+\n+\t      case 'G':\n+\t      case 'H':\n+\t\tif (GET_CODE (op) == CONST_DOUBLE\n+\t\t    && CONST_DOUBLE_OK_FOR_LETTER_P (op, c))\n+\t\t  win = 1;\n+\t\tbreak;\n+\n+\t      case 's':\n+\t\tif (GET_CODE (op) == CONST_INT\n+\t\t    || (GET_CODE (op) == CONST_DOUBLE\n+\t\t\t&& GET_MODE (op) == VOIDmode))\n+\t\t  break;\n+\t\t/* Fall through */\n+\t      case 'i':\n+\t\tif (CONSTANT_P (op))\n+\t\t  win = 1;\n+\t\tbreak;\n+\n+\t      case 'n':\n+\t\tif (GET_CODE (op) == CONST_INT\n+\t\t    || (GET_CODE (op) == CONST_DOUBLE\n+\t\t\t&& GET_MODE (op) == VOIDmode))\n+\t\t  win = 1;\n+\t\tbreak;\n+\n+\t      case 'I':\n+\t      case 'J':\n+\t      case 'K':\n+\t      case 'L':\n+\t      case 'M':\n+\t      case 'N':\n+\t      case 'O':\n+\t      case 'P':\n+\t\tif (GET_CODE (op) == CONST_INT\n+\t\t    && CONST_OK_FOR_LETTER_P (INTVAL (op), c))\n+\t\t  win = 1;\n+\t\tbreak;\n+\n+#ifdef EXTRA_CONSTRAINT\n+              case 'Q':\n+              case 'R':\n+              case 'S':\n+              case 'T':\n+              case 'U':\n+\t\tif (EXTRA_CONSTRAINT (op, c))\n+\t\t  win = 1;\n+\t\tbreak;\n+#endif\n+\n+\t      case 'V':\n+\t\tif (GET_CODE (op) == MEM && ! offsettable_memref_p (op))\n+\t\t  win = 1;\n+\t\tbreak;\n+\n+\t      case 'o':\n+\t\tif (offsettable_memref_p (op))\n+\t\t  win = 1;\n+\t\tbreak;\n+\n+\t      default:\n+\t\tif (GET_CODE (op) == REG\n+\t\t    && reg_fits_class_p (op, REG_CLASS_FROM_LETTER (c),\n+\t\t\t\t\t offset, mode))\n+\t\t  {\n+\t\t    operand_class[this_operand]\n+\t\t      = reg_class_subunion[(int)operand_class[this_operand]][(int) REG_CLASS_FROM_LETTER (c)];\n+\t\t    win = 1;\n+\t\t  }\n+\t      }\n+\n+\t  constraints[this_operand] = p;\n+\t  /* If this operand did not win somehow,\n+\t     this alternative loses.  */\n+\t  if (! win)\n+\t    lose = 1;\n+\t}\n+      /* This alternative won; the operands are ok.\n+\t Change whichever operands this alternative says to change.  */\n+      if (! lose)\n+\tbreak;\n+\n+      this_alternative++;\n+    }\n+\n+  /* For operands constrained to match another operand, copy the other\n+     operand's class to this operand's class. */\n+  for (j = 0; j < n_operands; j++)\n+    if (operand_matches[j] >= 0)\n+      operand_class[j] = operand_class[operand_matches[j]];\n+\n+  return this_alternative == n_alternatives ? -1 : this_alternative;\n+}\n+\f\n+/* Record the life info of each stack reg in INSN, updating REGSTACK.\n+   N_INPUTS is the number of inputs; N_OUTPUTS the outputs.  CONSTRAINTS\n+   is an array of the constraint strings used in the asm statement.\n+   OPERANDS is an array of all operands for the insn, and is assumed to\n+   contain all output operands, then all inputs operands.\n+\n+   There are many rules that an asm statement for stack-like regs must\n+   follow.  Those rules are explained at the top of this file: the rule\n+   numbers below refer to that explanation. */\n+\n+static void\n+record_asm_reg_life (insn, regstack, operands, constraints,\n+\t\t     n_inputs, n_outputs)\n+     rtx insn;\n+     stack regstack;\n+     rtx *operands;\n+     char **constraints;\n+     int n_inputs, n_outputs;\n+{\n+  int i;\n+  int n_operands = n_inputs + n_outputs;\n+  int first_input = n_outputs;\n+  int n_clobbers;\n+  int malformed_asm = 0;\n+  rtx body = PATTERN (insn);\n+\n+  int *operand_matches = (int *) alloca (n_operands * sizeof (int *));\n+\n+  enum reg_class *operand_class \n+    = (enum reg_class *) alloca (n_operands * sizeof (enum reg_class *));\n+\n+  int reg_used_as_output[FIRST_PSEUDO_REGISTER];\n+  int implicitly_dies[FIRST_PSEUDO_REGISTER];\n+\n+  rtx *clobber_reg;\n+\n+  /* Find out what the constraints required.  If no constraint\n+     alternative matches, that is a compiler bug: we should have caught\n+     such an insn during reload.  */\n+  i = constrain_asm_operands (n_operands, operands, constraints,\n+\t\t\t      operand_matches, operand_class);\n+  if (i < 0)\n+    abort ();\n+\n+  /* Strip SUBREGs here to make the following code simpler. */\n+  for (i = 0; i < n_operands; i++)\n+    if (GET_CODE (operands[i]) == SUBREG\n+\t&& GET_CODE (SUBREG_REG (operands[i])) == REG)\n+      operands[i] = SUBREG_REG (operands[i]);\n+\n+  /* Set up CLOBBER_REG.  */\n+\n+  n_clobbers = 0;\n+  clobber_reg = (rtx *) alloca (XVECLEN (body, 0) * sizeof (rtx *));\n+\n+  if (GET_CODE (body) == PARALLEL)\n+    for (i = 0; i < XVECLEN (body, 0); i++)\n+      if (GET_CODE (XVECEXP (body, 0, i)) == CLOBBER)\n+\t{\n+\t  rtx clobber = XVECEXP (body, 0, i);\n+\t  rtx reg = XEXP (clobber, 0);\n+\n+\t  if (GET_CODE (reg) == SUBREG && GET_CODE (SUBREG_REG (reg)) == REG)\n+\t    reg = SUBREG_REG (reg);\n+\n+\t  if (STACK_REG_P (reg))\n+\t    {\n+\t      clobber_reg[n_clobbers] = reg;\n+\t      n_clobbers++;\n+\t    }\n+\t}\n+\n+  /* Enforce rule #4: Output operands must specifically indicate which\n+     reg an output appears in after an asm.  \"=f\" is not allowed: the\n+     operand constraints must select a class with a single reg.\n+\n+     Also enforce rule #5: Output operands must start at the top of\n+     the reg-stack: output operands may not \"skip\" a reg. */\n+\n+  bzero (reg_used_as_output, sizeof (reg_used_as_output));\n+  for (i = 0; i < n_outputs; i++)\n+    if (STACK_REG_P (operands[i]))\n+      if (reg_class_size[operand_class[i]] != 1)\n+\t{\n+\t  error_for_asm\n+\t    (insn, \"Output constraint %d must specify a single register\", i);\n+\t  malformed_asm = 1;\n+\t}\n+      else\n+\treg_used_as_output[REGNO (operands[i])] = 1;\n+\n+\n+  /* Search for first non-popped reg.  */\n+  for (i = FIRST_STACK_REG; i < LAST_STACK_REG + 1; i++)\n+    if (! reg_used_as_output[i])\n+      break;\n+\n+  /* If there are any other popped regs, that's an error.  */\n+  for (; i < LAST_STACK_REG + 1; i++)\n+    if (reg_used_as_output[i])\n+      break;\n+\n+  if (i != LAST_STACK_REG + 1)\n+    {\n+      error_for_asm (insn, \"Output regs must be grouped at top of stack\");\n+      malformed_asm = 1;\n+    }\n+\n+  /* Enforce rule #2: All implicitly popped input regs must be closer\n+     to the top of the reg-stack than any input that is not implicitly\n+     popped. */\n+\n+  bzero (implicitly_dies, sizeof (implicitly_dies));\n+  for (i = first_input; i < first_input + n_inputs; i++)\n+    if (STACK_REG_P (operands[i]))\n+      {\n+\t/* An input reg is implicitly popped if it is tied to an\n+\t   output, or if there is a CLOBBER for it. */\n+\tint j;\n+\n+\tfor (j = 0; j < n_clobbers; j++)\n+\t  if (operands_match_p (clobber_reg[j], operands[i]))\n+\t    break;\n+\n+\tif (j < n_clobbers || operand_matches[i] >= 0)\n+\t  implicitly_dies[REGNO (operands[i])] = 1;\n+      }\n+\n+  /* Search for first non-popped reg.  */\n+  for (i = FIRST_STACK_REG; i < LAST_STACK_REG + 1; i++)\n+    if (! implicitly_dies[i])\n+      break;\n+\n+  /* If there are any other popped regs, that's an error.  */\n+  for (; i < LAST_STACK_REG + 1; i++)\n+    if (implicitly_dies[i])\n+      break;\n+\n+  if (i != LAST_STACK_REG + 1)\n+    {\n+      error_for_asm (insn,\n+\t\t     \"Implicitly popped regs must be grouped at top of stack\");\n+      malformed_asm = 1;\n+    }\n+\n+  /* Enfore rule #3: If any input operand uses the \"f\" constraint, all\n+     output constraints must use the \"&\" earlyclobber.\n+\n+     ???  Detect this more deterministically by having constraint_asm_operands\n+     record any earlyclobber. */\n+\n+  for (i = first_input; i < first_input + n_inputs; i++)\n+    if (operand_matches[i] == -1)\n+      {\n+\tint j;\n+\n+\tfor (j = 0; j < n_outputs; j++)\n+\t  if (operands_match_p (operands[j], operands[i]))\n+\t    {\n+\t      error_for_asm (insn,\n+\t\t\t     \"Output operand %d must use `&' constraint\", j);\n+\t      malformed_asm = 1;\n+\t    }\n+      }\n+\n+  if (malformed_asm)\n+    {\n+      /* Avoid further trouble with this insn.  */\n+      PATTERN (insn) = gen_rtx (USE, VOIDmode, const0_rtx);\n+      PUT_MODE (insn, VOIDmode);\n+      return;\n+    }\n+\n+  /* Process all outputs */\n+  for (i = 0; i < n_outputs; i++)\n+    {\n+      rtx op = operands[i];\n+\n+      if (! STACK_REG_P (op))\n+\tif (stack_regs_mentioned_p (op))\n+\t  abort ();\n+\telse\n+\t  continue;\n+\n+      /* Each destination is dead before this insn.  If the\n+\t destination is not used after this insn, record this with\n+\t REG_UNUSED.  */\n+\n+      if (! TEST_HARD_REG_BIT (regstack->reg_set, REGNO (op)))\n+\tREG_NOTES (insn) = gen_rtx (EXPR_LIST, REG_UNUSED, op,\n+\t\t\t\t    REG_NOTES (insn));\n+\n+      CLEAR_HARD_REG_BIT (regstack->reg_set, REGNO (op));\n+    }\n+\n+  /* Process all inputs */\n+  for (i = first_input; i < first_input + n_inputs; i++)\n+    {\n+      if (! STACK_REG_P (operands[i]))\n+\tif (stack_regs_mentioned_p (operands[i]))\n+\t  abort ();\n+\telse\n+\t  continue;\n+\n+      /* If an input is dead after the insn, record a death note.\n+\t But don't record a death note if there is already a death note,\n+\t or if the input is also an output.  */\n+\n+      if (! TEST_HARD_REG_BIT (regstack->reg_set, REGNO (operands[i]))\n+\t  && operand_matches[i] == -1\n+\t  && ! find_regno_note (insn, REG_DEAD, REGNO (operands[i])))\n+\tREG_NOTES (insn) = gen_rtx (EXPR_LIST, REG_DEAD, operands[i],\n+\t\t\t\t    REG_NOTES (insn));\n+\n+      SET_HARD_REG_BIT (regstack->reg_set, REGNO (operands[i]));\n+    }\n+}\n+\n /* Scan PAT, which is part of INSN, and record the life & death of\n    stack registers in REGSTACK.  If a register was dead, but is an input\n    operand in this insn, then mark the register live and record a death\n@@ -429,14 +994,9 @@ record_reg_life_pat (insn, regstack, pat)\n {\n   rtx src, dest;\n \n-  if (GET_CODE (pat) == CLOBBER\n-      && GET_CODE (PATTERN (insn)) == PARALLEL\n-      && GET_CODE (SET_SRC (XVECEXP (PATTERN (insn), 0, 0))) == ASM_OPERANDS)\n-    {\n-      if (STACK_REG_P (XEXP (pat, 0)))\n-\tabort ();\n-      return;\n-    }\n+  /* We should have already handled any asm.  */\n+  if (GET_CODE (pat) == ASM_INPUT || GET_CODE (pat) == ASM_OPERANDS)\n+    abort ();\n \n   if (GET_CODE (pat) != SET)\n     return;\n@@ -498,17 +1058,8 @@ record_reg_life_pat (insn, regstack, pat)\n       break;\n \n     case ASM_OPERANDS:\n-      {\n-\tregister int j;\n-\n-\t/* ??? This needs much improvement */\n-\n-\tif (stack_regs_mentioned_p (pat))\n-\t  abort ();\n-\n-\tfor (j = 0; j < XVECLEN (src, 3); j++)\n-\t  record_note_if_dead (insn, regstack, XVECEXP (src, 3, j), dest);\n-      }\n+    case ASM_INPUT:\n+      abort ();  /* we should have caught this already. */\n       break;\n \n     case REG:\n@@ -524,6 +1075,36 @@ record_reg_life_pat (insn, regstack, pat)\n     }\n }\n \f\n+/* Calculate the number of inputs and outputs in BODY, an\n+   asm_operands.  N_OPERANDS is the total number of operands, and\n+   N_INPUTS and N_OUTPUTS are pointers to ints into which the results are\n+   placed. */\n+\n+static void\n+get_asm_operand_lengths (body, n_operands, n_inputs, n_outputs)\n+     rtx body;\n+     int n_operands;\n+     int *n_inputs, *n_outputs;\n+{\n+  if (GET_CODE (body) == SET && GET_CODE (SET_SRC (body)) == ASM_OPERANDS)\n+    *n_inputs = ASM_OPERANDS_INPUT_LENGTH (SET_SRC (body));\n+\n+  else if (GET_CODE (body) == ASM_OPERANDS)\n+    *n_inputs = ASM_OPERANDS_INPUT_LENGTH (body);\n+\n+  else if (GET_CODE (body) == PARALLEL\n+\t   && GET_CODE (XVECEXP (body, 0, 0)) == SET)\n+    *n_inputs = ASM_OPERANDS_INPUT_LENGTH (SET_SRC (XVECEXP (body, 0, 0)));\n+\n+  else if (GET_CODE (body) == PARALLEL\n+\t   && GET_CODE (XVECEXP (body, 0, 0)) == ASM_OPERANDS)\n+    *n_inputs = ASM_OPERANDS_INPUT_LENGTH (XVECEXP (body, 0, 0));\n+  else\n+    abort ();\n+\n+  *n_outputs = n_operands - *n_inputs;\n+}\n+\f\n /* Scan INSN, which is in BLOCK, and record the life & death of stack\n    registers in REGSTACK.  This function is called to process insns from\n    the last insn in a block to the first.  The actual scanning is done in\n@@ -543,6 +1124,7 @@ record_reg_life (insn, block, regstack)\n      stack regstack;\n {\n   rtx note, *note_link;\n+  int n_operands;\n \n   if ((GET_CODE (insn) != INSN && GET_CODE (insn) != CALL_INSN)\n       || INSN_DELETED_P (insn))\n@@ -561,6 +1143,24 @@ record_reg_life (insn, block, regstack)\n \n   /* Process all patterns in the insn. */\n \n+  n_operands = asm_noperands (PATTERN (insn));\n+  if (n_operands >= 0)\n+    {\n+      /* This insn is an `asm' with operands.  Decode the operands,\n+\t decide how many are inputs, and record the life information. */\n+\n+      rtx operands[MAX_RECOG_OPERANDS];\n+      rtx body = PATTERN (insn);\n+      int n_inputs, n_outputs;\n+      char **constraints = (char **) alloca (n_operands * sizeof (char *));\n+\n+      decode_asm_operands (body, operands, 0, constraints, 0);\n+      get_asm_operand_lengths (body, n_operands, &n_inputs, &n_outputs);\n+      record_asm_reg_life (insn, regstack, operands, constraints,\n+\t\t\t   n_inputs, n_outputs);\n+      return;\n+    }\n+\n   if (GET_CODE (PATTERN (insn)) == PARALLEL)\n     {\n       register int i;\n@@ -867,7 +1467,7 @@ replace_reg (reg, regno)\n     abort ();\n \n   if (GET_MODE_CLASS (GET_MODE (*reg)) != MODE_FLOAT)\n-    abort;\n+    abort ();\n \n   *reg = FP_mode_reg[regno][(int) GET_MODE (*reg)];\n }\n@@ -1019,6 +1619,8 @@ emit_swap_insn (insn, regstack, reg, when)\n   int hard_regno;\n \n   hard_regno = get_hard_regnum (regstack, reg);\n+  if (hard_regno < FIRST_STACK_REG)\n+    abort ();\n \n   emit_hard_swap_insn (insn, regstack, hard_regno, when);\n }\n@@ -1430,6 +2032,286 @@ subst_stack_regs_pat (insn, regstack, pat)\n       }\n }\n \f\n+/* Substitute hard regnums for any stack regs in INSN, which has\n+   N_INPUTS inputs and N_OUTPUTS outputs.  REGSTACK is the stack info\n+   before the insn, and is updated with changes made here.  CONSTAINTS is\n+   an array of the constraint strings used in the asm statement.\n+\n+   OPERANDS is an array of the operands, and OPERANDS_LOC is a\n+   parallel array of where the operands were found.  The output operands\n+   all preceed the input operands.\n+\n+   There are several requirements and assumptions about the use of\n+   stack-like regs in asm statements.  These rules are enforced by\n+   record_asm_stack_regs; see comments there for details.  Any\n+   asm_operands left in the RTL at this point may be assume to meet the\n+   requirements, since record_asm_stack_regs removes any problem asm.  */\n+\n+static void\n+subst_asm_stack_regs (insn, regstack, operands, operands_loc, constraints,\n+\t\t      n_inputs, n_outputs)\n+     rtx insn;\n+     stack regstack;\n+     rtx *operands, **operands_loc;\n+     char **constraints;\n+     int n_inputs, n_outputs;\n+{\n+  int n_operands = n_inputs + n_outputs;\n+  int first_input = n_outputs;\n+  rtx body = PATTERN (insn);\n+\n+  int *operand_matches = (int *) alloca (n_operands * sizeof (int *));\n+  enum reg_class *operand_class \n+    = (enum reg_class *) alloca (n_operands * sizeof (enum reg_class *));\n+\n+  rtx *note_reg;\t\t/* Array of note contents */\n+  rtx **note_loc;\t\t/* Address of REG field of each note */\n+  enum reg_note *note_kind;\t/* The type of each note */\n+\n+  rtx *clobber_reg;\n+  rtx **clobber_loc;\n+\n+  struct stack_def temp_stack;\n+  int n_notes;\n+  int n_clobbers;\n+  rtx note;\n+  int i;\n+\n+  /* Find out what the constraints required.  If no constraint\n+     alternative matches, that is a compiler bug: we should have caught\n+     such an insn during the life analysis pass (and reload should have\n+     caught it regardless). */\n+\n+  i = constrain_asm_operands (n_operands, operands, constraints,\n+\t\t\t      operand_matches, operand_class);\n+  if (i < 0)\n+    abort ();\n+\n+  /* Strip SUBREGs here to make the following code simpler. */\n+  for (i = 0; i < n_operands; i++)\n+    if (GET_CODE (operands[i]) == SUBREG\n+\t&& GET_CODE (SUBREG_REG (operands[i])) == REG)\n+      {\n+\toperands_loc[i] = & SUBREG_REG (operands[i]);\n+\toperands[i] = SUBREG_REG (operands[i]);\n+      }\n+\n+  /* Set up NOTE_REG, NOTE_LOC and NOTE_KIND.  */\n+\n+  for (i = 0, note = REG_NOTES (insn); note; note = XEXP (note, 1))\n+    i++;\n+\n+  note_reg = (rtx *) alloca (i * sizeof (rtx));\n+  note_loc = (rtx **) alloca (i * sizeof (rtx *));\n+  note_kind = (enum reg_note *) alloca (i * sizeof (enum reg_note));\n+\n+  n_notes = 0;\n+  for (note = REG_NOTES (insn); note; note = XEXP (note, 1))\n+    {\n+      rtx reg = XEXP (note, 0);\n+      rtx *loc = & XEXP (note, 0);\n+\n+      if (GET_CODE (reg) == SUBREG && GET_CODE (SUBREG_REG (reg)) == REG)\n+\t{\n+\t  loc = & SUBREG_REG (reg);\n+\t  reg = SUBREG_REG (reg);\n+\t}\n+\n+      if (STACK_REG_P (reg)\n+\t  && (REG_NOTE_KIND (note) == REG_DEAD\n+\t      || REG_NOTE_KIND (note) == REG_UNUSED))\n+\t{\n+\t  note_reg[n_notes] = reg;\n+\t  note_loc[n_notes] = loc;\n+\t  note_kind[n_notes] = REG_NOTE_KIND (note);\n+\t  n_notes++;\n+\t}\n+    }\n+\n+  /* Set up CLOBBER_REG and CLOBBER_LOC.  */\n+\n+  n_clobbers = 0;\n+  clobber_reg = (rtx *) alloca (XVECLEN (body, 0) * sizeof (rtx *));\n+  clobber_loc = (rtx **) alloca (XVECLEN (body, 0) * sizeof (rtx **));\n+\n+  if (GET_CODE (body) == PARALLEL)\n+    for (i = 0; i < XVECLEN (body, 0); i++)\n+      if (GET_CODE (XVECEXP (body, 0, i)) == CLOBBER)\n+\t{\n+\t  rtx clobber = XVECEXP (body, 0, i);\n+\t  rtx reg = XEXP (clobber, 0);\n+\t  rtx *loc = & XEXP (clobber, 0);\n+\n+\t  if (GET_CODE (reg) == SUBREG && GET_CODE (SUBREG_REG (reg)) == REG)\n+\t    {\n+\t      loc = & SUBREG_REG (reg);\n+\t      reg = SUBREG_REG (reg);\n+\t    }\n+\n+\t  if (STACK_REG_P (reg))\n+\t    {\n+\t      clobber_reg[n_clobbers] = reg;\n+\t      clobber_loc[n_clobbers] = loc;\n+\t      n_clobbers++;\n+\t    }\n+\t}\n+\n+  bcopy (regstack, &temp_stack, sizeof (temp_stack));\n+\n+  /* Put the input regs into the desired place in TEMP_STACK.  */\n+\n+  for (i = first_input; i < first_input + n_inputs; i++)\n+    if (STACK_REG_P (operands[i])\n+\t&& reg_class_subset_p (operand_class[i], FLOAT_REGS)\n+\t&& operand_class[i] != FLOAT_REGS)\n+      {\n+\t/* If an operand needs to be in a particular reg in\n+\t   FLOAT_REGS, the constraint was either 't' or 'u'.  Since\n+\t   these constraints are for single register classes, and reload\n+\t   guaranteed that operand[i] is already in that class, we can\n+\t   just use REGNO (operands[i]) to know which actual reg this\n+\t   operand needs to be in. */\n+\n+\tint regno = get_hard_regnum (&temp_stack, operands[i]);\n+\n+\tif (regno < 0)\n+\t  abort ();\n+\n+\tif (regno != REGNO (operands[i]))\n+\t  {\n+\t    /* operands[i] is not in the right place.  Find it\n+\t       and swap it with whatever is already in I's place.\n+\t       K is where operands[i] is now.  J is where it should\n+\t       be. */\n+\t    int j, k, temp;\n+\n+\t    k = temp_stack.top - (regno - FIRST_STACK_REG);\n+\t    j = (temp_stack.top\n+\t\t - (REGNO (operands[i]) - FIRST_STACK_REG));\n+\n+\t    temp = temp_stack.reg[k];\n+\t    temp_stack.reg[k] = temp_stack.reg[j];\n+\t    temp_stack.reg[j] = temp;\n+\t  }\n+      }\n+\n+  /* emit insns before INSN to make sure the reg-stack is in the right\n+     order.  */\n+\n+  change_stack (insn, regstack, &temp_stack, emit_insn_before);\n+\n+  /* Make the needed input register substitutions.  Do death notes and\n+     clobbers too, because these are for inputs, not outputs. */\n+\n+  for (i = first_input; i < first_input + n_inputs; i++)\n+    if (STACK_REG_P (operands[i]))\n+      {\n+\tint regnum = get_hard_regnum (regstack, operands[i]);\n+\n+\tif (regnum < 0)\n+\t  abort ();\n+\n+\treplace_reg (operands_loc[i], regnum);\n+      }\n+\n+  for (i = 0; i < n_notes; i++)\n+    if (note_kind[i] == REG_DEAD)\n+      {\n+\tint regnum = get_hard_regnum (regstack, note_reg[i]);\n+\n+\tif (regnum < 0)\n+\t  abort ();\n+\n+\treplace_reg (note_loc[i], regnum);\n+      }\n+\n+  for (i = 0; i < n_clobbers; i++)\n+    {\n+      /* It's OK for a CLOBBER to reference a reg that is not live.\n+         Don't try to replace it in that case.  */\n+      int regnum = get_hard_regnum (regstack, clobber_reg[i]);\n+\n+      if (regnum >= 0)\n+\t{\n+\t  /* Sigh - clobbers always have QImode.  But replace_reg knows\n+\t     that these regs can't be MODE_INT and will abort.  Just put\n+\t     the right reg there without calling replace_reg.  */\n+\n+\t  *clobber_loc[i] = FP_mode_reg[regnum][(int) DFmode];\n+\t}\n+    }\n+\n+  /* Now remove from REGSTACK any inputs that the asm implicitly popped. */\n+\n+  for (i = first_input; i < first_input + n_inputs; i++)\n+    if (STACK_REG_P (operands[i]))\n+      {\n+\t/* An input reg is implicitly popped if it is tied to an\n+\t   output, or if there is a CLOBBER for it. */\n+\tint j;\n+\n+\tfor (j = 0; j < n_clobbers; j++)\n+\t  if (operands_match_p (clobber_reg[j], operands[i]))\n+\t    break;\n+\n+\tif (j < n_clobbers || operand_matches[i] >= 0)\n+\t  {\n+\t    /* operands[i] might not be at the top of stack.  But that's OK,\n+\t       because all we need to do is pop the right number of regs\n+\t       off of the top of the reg-stack.  record_asm_stack_regs\n+\t       guaranteed that all implicitly popped regs were grouped\n+\t       at the top of the reg-stack.  */\n+\n+\t    CLEAR_HARD_REG_BIT (regstack->reg_set,\n+\t\t\t\tregstack->reg[regstack->top]);\n+\t    regstack->top--;\n+\t  }\n+      }\n+\n+  /* Now add to REGSTACK any outputs that the asm implicitly pushed.\n+     Note that there isn't any need to substitute register numbers.\n+     ???  Explain why this is true. */\n+\n+  for (i = LAST_STACK_REG; i >= FIRST_STACK_REG; i--)\n+    {\n+      /* See if there is an output for this hard reg.  */\n+      int j;\n+\n+      for (j = 0; j < n_outputs; j++)\n+\tif (STACK_REG_P (operands[j]) && REGNO (operands[j]) == i)\n+\t  {\n+\t    regstack->reg[++regstack->top] = i;\n+\t    SET_HARD_REG_BIT (regstack->reg_set, i);\n+\t    break;\n+\t  }\n+    }\n+\n+  /* Now emit a pop insn for any REG_UNUSED output, or any REG_DEAD\n+     input that the asm didn't implicitly pop.  If the asm didn't\n+     implicitly pop a reg, that reg will still be live.\n+\n+     Note that we can't use find_regno_note here: the register numbers\n+     in the death notes have already been substituted.  */\n+\n+  for (i = 0; i < n_outputs + n_inputs; i++)\n+    if (STACK_REG_P (operands[i]))\n+      {\n+\tint j;\n+\n+\tfor (j = 0; j < n_notes; j++)\n+\t  if (REGNO (operands[i]) == REGNO (note_reg[j])\n+\t      && (note_kind[j] == REG_UNUSED\n+\t\t  || (note_kind[j] == REG_DEAD\n+\t\t      && TEST_HARD_REG_BIT (regstack->reg_set,\n+\t\t\t\t\t    REGNO (operands[i])))))\n+\t    {\n+\t      insn = emit_pop_insn (insn, regstack, operands[i],\n+\t\t\t\t    emit_insn_after);\n+\t      break;\n+\t    }\n+      }\n+}\n+\f\n /* Substitute stack hard reg numbers for stack virtual registers in\n    INSN.  Non-stack register numbers are not changed.  REGSTACK is the\n    current stack content.  Insns may be emitted as needed to arrange the\n@@ -1442,6 +2324,7 @@ subst_stack_regs (insn, regstack)\n {\n   register rtx *note_link, note;\n   register int i;\n+  int n_operands;\n \n   if ((GET_CODE (insn) != INSN && GET_CODE (insn) != CALL_INSN)\n       || INSN_DELETED_P (insn))\n@@ -1462,6 +2345,27 @@ subst_stack_regs (insn, regstack)\n \n   if (GET_MODE (insn) == QImode)\n     {\n+      n_operands = asm_noperands (PATTERN (insn));\n+      if (n_operands >= 0)\n+\t{\n+\t  /* This insn is an `asm' with operands.  Decode the operands,\n+\t     decide how many are inputs, and do register substitution.\n+\t     Any REG_UNUSED notes will be handled by subst_asm_stack_regs. */\n+\n+\t  rtx operands[MAX_RECOG_OPERANDS];\n+\t  rtx *operands_loc[MAX_RECOG_OPERANDS];\n+\t  rtx body = PATTERN (insn);\n+\t  int n_inputs, n_outputs;\n+\t  char **constraints\n+\t    = (char **) alloca (n_operands * sizeof (char *));\n+\n+\t  decode_asm_operands (body, operands, operands_loc, constraints, 0);\n+\t  get_asm_operand_lengths (body, n_operands, &n_inputs, &n_outputs);\n+\t  subst_asm_stack_regs (insn, regstack, operands, operands_loc,\n+\t\t\t\tconstraints, n_inputs, n_outputs);\n+\t  return;\n+\t}\n+\n       if (GET_CODE (PATTERN (insn)) == PARALLEL)\n \tfor (i = 0; i < XVECLEN (PATTERN (insn) , 0); i++)\n \t  {\n@@ -1489,8 +2393,7 @@ subst_stack_regs (insn, regstack)\n     if (REG_NOTE_KIND (note) == REG_UNUSED && STACK_REG_P (XEXP (note, 0)))\n       {\n \t*note_link = XEXP (note, 1);\n-\temit_pop_insn (insn, regstack, XEXP (note, 0),\n-\t\t       emit_insn_after);\n+\tinsn = emit_pop_insn (insn, regstack, XEXP (note, 0), emit_insn_after);\n       }\n     else\n       note_link = &XEXP (note, 1);\n@@ -1500,25 +2403,29 @@ subst_stack_regs (insn, regstack)\n    block.  Some registers might have to be popped, but there can never be\n    a register live in the new block that is not now live.\n \n-   Insert any needed insns after INSN.  OLD is the original stack\n-   layout, and NEW is the desired form.  OLD is updated to reflect the\n-   code emitted, ie, it will be the same as NEW upon return.\n+   Insert any needed insns before or after INSN.  WHEN is emit_insn_before\n+   or emit_insn_after. OLD is the original stack layout, and NEW is\n+   the desired form.  OLD is updated to reflect the code emitted, ie, it\n+   will be the same as NEW upon return.\n \n    This function will not preserve block_end[].  But that information\n    is no longer needed once this has executed. */\n \n static void\n-change_stack (insn, old, new)\n+change_stack (insn, old, new, when)\n      rtx insn;\n      stack old;\n      stack new;\n+     rtx (*when)();\n {\n   int reg;\n \n-  /* We will be inserting new insns after INSN, by first finding the\n-     next insn, and inserting before it. */\n+  /* We will be inserting new insns \"backwards\", by calling emit_insn_before.\n+     If we are to insert after INSN, find the next insn, and insert before\n+     it.  */\n \n-  insn = NEXT_INSN (insn);\n+  if (when == emit_insn_after)\n+    insn = NEXT_INSN (insn);\n \n   /* Pop any registers that are not needed in the new block. */\n \n@@ -1660,7 +2567,7 @@ goto_block_pat (insn, regstack, pat)\n \t{\n \t  /* change_stack will not emit any code in this case. */\n \n-\t  change_stack (label, regstack, label_stack);\n+\t  change_stack (label, regstack, label_stack, emit_insn_after);\n \t  return;\n \t}\n     }\n@@ -1712,7 +2619,7 @@ goto_block_pat (insn, regstack, pat)\n \n   temp_stack = *regstack;\n \n-  change_stack (new_label, &temp_stack, label_stack);\n+  change_stack (new_label, &temp_stack, label_stack, emit_insn_after);\n }\n \f\n /* Traverse all basic blocks in a function, converting the register\n@@ -1781,7 +2688,8 @@ convert_regs ()\n       /* Likewise handle the case where we fall into the next block. */\n \n       if ((block < blocks - 1) && block_drops_in[block+1])\n-\tchange_stack (insn, &regstack, &block_stack_in[block+1]);\n+\tchange_stack (insn, &regstack, &block_stack_in[block+1],\n+\t\t      emit_insn_after);\n     }\n \n   /* If the last basic block is the end of a loop, and that loop has\n@@ -1896,44 +2804,4 @@ dump_stack_info (file)\n       fprintf (file, \"\\n\");\n     }\n }\n-\f\n-/* Report an error at line LINE of file FILE.\n-   S is a string and an arg for `printf'.  */\n-\n-/* Report an fatal error at the line number of the insn INSN (ASM_OPERAND).\n-   S1, S2 is a string and an arg for `printf'. */\n-\n-static void\n-fatal_for_asm (insn, s1, s2)\n-     rtx insn;\n-     char *s1, *s2;\n-{\n-  char *filename;\n-  int line;\n-  rtx body = PATTERN (insn);\n-  rtx asmop = 0;\n-\n-  /* Find the (or one of the) ASM_OPERANDS in the insn.  */\n-  if (GET_CODE (body) == SET && GET_CODE (SET_SRC (body)) == ASM_OPERANDS)\n-    asmop = SET_SRC (body);\n-  else if (GET_CODE (body) == ASM_OPERANDS)\n-    asmop = body;\n-  else if (GET_CODE (body) == PARALLEL\n-\t   && GET_CODE (XVECEXP (body, 0, 0)) == SET)\n-    asmop = SET_SRC (XVECEXP (body, 0, 0));\n-  else if (GET_CODE (body) == PARALLEL\n-\t   && GET_CODE (XVECEXP (body, 0, 0)) == ASM_OPERANDS)\n-    asmop = XVECEXP (body, 0, 0);\n-  else\n-    abort ();\n-\n-  filename = ASM_OPERANDS_SOURCE_FILE (asmop);\n-  line = ASM_OPERANDS_SOURCE_LINE (asmop);\n-\n-  fprintf (stderr, s1);\n-  debug_rtx (insn);\n-\n-  error_with_file_and_line (filename, line, s2, NULL, NULL);\n-  exit (34);\n-}\n #endif /* STACK_REGS */"}]}