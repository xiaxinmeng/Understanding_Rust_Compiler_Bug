{"sha": "05708d6eef87a3dd0c68b1aed7f8d9c3824062b8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDU3MDhkNmVlZjg3YTNkZDBjNjhiMWFlZDdmOGQ5YzM4MjQwNjJiOA==", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2021-04-08T17:07:37Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2021-04-08T17:07:37Z"}, "message": "c++: constrained CTAD for nested class template [PR97679]\n\nIn the testcase below, we're crashing during constraint checking of the\nimplicitly generated deduction guides for the nested class template A::B\nbecause we never substitute the outer template arguments (for A) into\nthe constraint, neither ahead of time nor as part of satisfaction.\n\nIdeally we'd like to avoid substituting into a constraint ahead of\ntime, but the \"flattening\" vector 'tsubst_args' is constructed under the\nassumption that all outer template arguments are already substituted in,\nand eliminating this assumption to yield a flattening vector that\nincludes outer (generic) template arguments suitable for substituting\ninto the constraint would be tricky and error-prone.  So this patch\ntakes the approximate approach of substituting the outer arguments into\nthe constraint ahead of time, so that the subsequent substitution of\n'tsubst_args' is coherent and so later satisfaction just works.\n\ngcc/cp/ChangeLog:\n\n\tPR c++/97679\n\t* pt.c (build_deduction_guide): Document OUTER_ARGS.  Substitute\n\tthem into the propagated constraints.\n\ngcc/testsuite/ChangeLog:\n\n\tPR c++/97679\n\t* g++.dg/cpp2a/concepts-ctad3.C: New test.", "tree": {"sha": "71f82a4fb51036fb05439ae45b5aabf9ea4bab18", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/71f82a4fb51036fb05439ae45b5aabf9ea4bab18"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/05708d6eef87a3dd0c68b1aed7f8d9c3824062b8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/05708d6eef87a3dd0c68b1aed7f8d9c3824062b8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/05708d6eef87a3dd0c68b1aed7f8d9c3824062b8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/05708d6eef87a3dd0c68b1aed7f8d9c3824062b8/comments", "author": null, "committer": null, "parents": [{"sha": "0567998287649833744ad728b1dfb785fe17c545", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0567998287649833744ad728b1dfb785fe17c545", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0567998287649833744ad728b1dfb785fe17c545"}], "stats": {"total": 36, "additions": 33, "deletions": 3}, "files": [{"sha": "842a58cf2f9f6f88c6cc5b13d0daacd78562a897", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 17, "deletions": 3, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05708d6eef87a3dd0c68b1aed7f8d9c3824062b8/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05708d6eef87a3dd0c68b1aed7f8d9c3824062b8/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=05708d6eef87a3dd0c68b1aed7f8d9c3824062b8", "patch": "@@ -28602,7 +28602,8 @@ rewrite_tparm_list (tree oldelt, unsigned index, unsigned level,\n /* Returns a C++17 class deduction guide template based on the constructor\n    CTOR.  As a special case, CTOR can be a RECORD_TYPE for an implicit default\n    guide, REFERENCE_TYPE for an implicit copy/move guide, or TREE_LIST for an\n-   aggregate initialization guide.  */\n+   aggregate initialization guide.  OUTER_ARGS are the template arguments\n+   for the enclosing scope of the class.  */\n \n static tree\n build_deduction_guide (tree type, tree ctor, tree outer_args, tsubst_flags_t complain)\n@@ -28728,7 +28729,15 @@ build_deduction_guide (tree type, tree ctor, tree outer_args, tsubst_flags_t com\n \t  if (fparms == error_mark_node)\n \t    ok = false;\n \t  if (ci)\n-\t    ci = tsubst_constraint_info (ci, tsubst_args, complain, ctor);\n+\t    {\n+\t      if (outer_args)\n+\t\t/* FIXME: We'd like to avoid substituting outer template\n+\t\t   arguments into the constraint ahead of time, but the\n+\t\t   construction of tsubst_args assumes that outer arguments\n+\t\t   are already substituted in.  */\n+\t\tci = tsubst_constraint_info (ci, outer_args, complain, ctor);\n+\t      ci = tsubst_constraint_info (ci, tsubst_args, complain, ctor);\n+\t    }\n \n \t  /* Parms are to have DECL_CHAIN tsubsted, which would be skipped if\n \t     cp_unevaluated_operand.  */\n@@ -28744,7 +28753,12 @@ build_deduction_guide (tree type, tree ctor, tree outer_args, tsubst_flags_t com\n \t  fparms = tsubst_arg_types (fparms, targs, NULL_TREE, complain, ctor);\n \t  fargs = tsubst (fargs, targs, complain, ctor);\n \t  if (ci)\n-\t    ci = tsubst_constraint_info (ci, targs, complain, ctor);\n+\t    {\n+\t      if (outer_args)\n+\t\t/* FIXME: As above.  */\n+\t\tci = tsubst_constraint_info (ci, outer_args, complain, ctor);\n+\t      ci = tsubst_constraint_info (ci, targs, complain, ctor);\n+\t    }\n \t}\n \n       --processing_template_decl;"}, {"sha": "3546b7461a84d3afade66c2efd029963703c6cd1", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-ctad3.C", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05708d6eef87a3dd0c68b1aed7f8d9c3824062b8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-ctad3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05708d6eef87a3dd0c68b1aed7f8d9c3824062b8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-ctad3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-ctad3.C?ref=05708d6eef87a3dd0c68b1aed7f8d9c3824062b8", "patch": "@@ -0,0 +1,16 @@\n+// PR c++/97679\n+// { dg-do compile { target c++20 } }\n+\n+template <bool V> struct A {\n+  template <class T> struct B {\n+    B(T) requires V;\n+    template <class U> B(T, U) requires V || (__is_same(T, char) && __is_same(U, int));\n+  };\n+};\n+\n+A<true>::B x1(0);\n+A<false>::B x2(0); // { dg-error \"deduction|no match\" }\n+\n+A<true>::B y1(0, '0');\n+A<false>::B y2(0, '0'); // { dg-error \"deduction|no match\" }\n+A<false>::B y3('0', 0);"}]}