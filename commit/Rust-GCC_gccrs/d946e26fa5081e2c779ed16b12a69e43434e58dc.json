{"sha": "d946e26fa5081e2c779ed16b12a69e43434e58dc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDk0NmUyNmZhNTA4MWUyYzc3OWVkMTZiMTJhNjllNDM0MzRlNThkYw==", "commit": {"author": {"name": "Charles Hannum", "email": "mycroft@gnu.org", "date": "1991-12-01T04:47:39Z"}, "committer": {"name": "Charles Hannum", "email": "mycroft@gnu.org", "date": "1991-12-01T04:47:39Z"}, "message": "entered into RCS\n\nFrom-SVN: r84", "tree": {"sha": "a856a650835896f8ef04b3dd30c19ad952f81d6f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a856a650835896f8ef04b3dd30c19ad952f81d6f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d946e26fa5081e2c779ed16b12a69e43434e58dc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d946e26fa5081e2c779ed16b12a69e43434e58dc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d946e26fa5081e2c779ed16b12a69e43434e58dc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d946e26fa5081e2c779ed16b12a69e43434e58dc/comments", "author": null, "committer": null, "parents": [{"sha": "d17804d82a082e70d89985139a2aa7b99d5be295", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d17804d82a082e70d89985139a2aa7b99d5be295", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d17804d82a082e70d89985139a2aa7b99d5be295"}], "stats": {"total": 983, "additions": 983, "deletions": 0}, "files": [{"sha": "cd4b058758adb99b151c4e7d4229d36ab7ed6816", "filename": "gcc/config/gmicro/gmicro.c", "status": "added", "additions": 983, "deletions": 0, "changes": 983, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d946e26fa5081e2c779ed16b12a69e43434e58dc/gcc%2Fconfig%2Fgmicro%2Fgmicro.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d946e26fa5081e2c779ed16b12a69e43434e58dc/gcc%2Fconfig%2Fgmicro%2Fgmicro.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fgmicro%2Fgmicro.c?ref=d946e26fa5081e2c779ed16b12a69e43434e58dc", "patch": "@@ -0,0 +1,983 @@\n+/* Subroutines for insn-output.c for the Gmicro.\n+   Ported by Masanobu Yuhara, Fujitsu Laboratories LTD.\n+   (yuhara@flab.fujitsu.co.jp)\n+\n+   Copyright (C) 1990, 1991 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Among other things, the copyright\n+notice and this notice must be preserved on all copies.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+\n+#include <stdio.h>\n+#include \"config.h\"\n+#include \"rtl.h\"\n+#include \"regs.h\"\n+#include \"hard-reg-set.h\"\n+#include \"real.h\"\n+#include \"insn-config.h\"\n+#include \"conditions.h\"\n+#include \"insn-flags.h\"\n+#include \"output.h\"\n+#include \"insn-attr.h\"\n+\n+extern char *rtx_name[];\n+\n+mypr (s, a1, a2, a3, a4, a5)\n+     char *s;\n+     int a1, a2, a3, a4, a5;\n+{\n+  fprintf (stderr, s, a1, a2, a3, a4, a5);\n+}\n+\n+myprcode (i)\n+     int i;\n+{\n+  if (i < 0 || i > 90)\n+    fprintf (stderr, \"code = %d\\n\", i);\n+  else\n+    fprintf (stderr, \"code = %s\\n\", rtx_name[i]);\n+}\n+\n+myabort (i)\n+     int i;\n+{\n+  fprintf (stderr, \"myabort\");\n+  myprcode (i);\n+}\n+\n+\n+/* This is how to output an ascii string.  */\n+/* See ASM_OUTPUT_ASCII in gmicro.h.  */\n+output_ascii (file, p, size)\n+     FILE *file;\n+     char *p;\n+     int size;\n+{\n+  int i;\n+  int in_quote = 0;\n+  register int c;\n+\n+  fprintf (file, \"\\t.sdata \");\n+\n+  for (i = 0; i < size; i++) \n+    {\n+      c = p[i];\n+      if (c >= ' ' && c < 0x7f) \n+\t{\n+\t  if (!in_quote) \n+\t    {\n+\t      putc ('\"', file);\n+\t      in_quote = 1;\n+\t    }\n+\t  putc (c, file);\n+\t}\n+      else \n+\t{\n+\t  if (in_quote) \n+\t    {\n+\t      putc ('\"', file);\n+\t      in_quote = 0;\n+\t    }\n+\t  fprintf (file, \"<%d>\", c);\n+\t}\n+    }\n+  if (in_quote)\n+    putc ('\"', file);\n+  putc ('\\n', file);\n+}\n+\n+\n+/* call this when GET_CODE (index) is MULT. */\n+print_scaled_index (file, index)\n+     FILE *file;\n+     register rtx index;\n+{\n+  register rtx ireg;\n+  int scale;\n+\n+  if (GET_CODE (XEXP (index, 0)) == REG) \n+    {\n+      ireg = XEXP (index, 0);\n+      scale = INTVAL (XEXP (index, 1));\n+    }\n+  else \n+    {\n+      ireg = XEXP (index, 1);\n+      scale = INTVAL (XEXP (index, 0));\n+    }\n+  if (scale == 1)\n+    fprintf (file, \"%s\", reg_names[REGNO (ireg)]);\n+  else\n+    fprintf (file, \"%s*%d\", reg_names[REGNO (ireg)], scale);\n+}\n+    \n+\n+print_operand_address (file, addr)\n+     FILE *file;\n+     register rtx addr;\n+{\n+  register rtx xtmp0, xtmp1, breg, ixreg;\n+  int scale;\n+  int needcomma = 0;\n+  rtx offset;\n+\n+  fprintf (file, \"@\");\n+ retry:\n+  switch (GET_CODE (addr)) \n+    {\n+    case MEM:\n+      fprintf (file, \"@\");\n+      addr = XEXP (addr, 0);\n+      goto retry;\n+\n+    case REG:\n+      fprintf (file, \"%s\", reg_names[REGNO (addr)]);\n+      break;\n+\n+    case MULT:\n+      print_scaled_index (file, addr);\n+      break;\n+\n+    case PRE_DEC:\n+      fprintf (file, \"-%s\", reg_names[REGNO (XEXP (addr, 0))]);\n+      break;\n+\n+    case POST_INC:\n+      fprintf (file, \"%s+\", reg_names[REGNO (XEXP (addr, 0))]);\n+      break;\n+\n+    case PLUS:\n+      xtmp0 = XEXP (addr, 0);\n+      xtmp1 = XEXP (addr, 1);\n+      ixreg = 0;\tbreg = 0;\n+      offset = 0;\n+      if (CONSTANT_ADDRESS_P (xtmp0)) \n+\t{\n+\t  offset = xtmp0;\n+\t  breg = xtmp1;\n+\t}\n+      else if (CONSTANT_ADDRESS_P (xtmp1)) \n+\t{\n+\t  offset = xtmp1;\n+\t  breg = xtmp0;\n+\t}\n+      else \n+\t{\n+\t  goto NOT_DISP;\n+\t}\n+\n+      if (REG_CODE_BASE_P (breg))\n+\tgoto PRINT_MEM;\n+\n+      if (GET_CODE (breg) == MULT) \n+\t{\n+\t  if (REG_CODE_INDEX_P (XEXP (breg, 0))) \n+\t    {\n+\t      ixreg = XEXP (breg, 0);\n+\t      scale = INTVAL (XEXP (breg, 1));\n+\t      breg = 0;\n+\t    }\n+\t  else \n+\t    {\n+\t      ixreg = XEXP (breg, 1);\n+\t      scale = INTVAL (XEXP (breg, 0));\n+\t      breg = 0;\n+\t    }\n+\t  goto PRINT_MEM;\n+\t}\n+\n+      /* GET_CODE (breg) must be PLUS here. */\n+      xtmp0 = XEXP (breg, 0);\n+      xtmp1 = XEXP (breg, 1);\n+      if (REG_CODE_BASE_P (xtmp0)) \n+\t{\n+\t  breg = xtmp0;\n+\t  xtmp0 = xtmp1;\n+\t}\n+      else \n+\t{\n+\t  breg = xtmp1;\n+\t  /* xtmp0 = xtmp0; */\n+\t}\n+\n+      if (GET_CODE (xtmp0) == MULT) \n+\t{\n+\t  if (REG_CODE_INDEX_P (XEXP (xtmp0, 0))) \n+\t    {\n+\t      ixreg = XEXP (xtmp0, 0);\n+\t      scale = INTVAL (XEXP (xtmp0, 1));\n+\t    }\n+\t  else \n+\t    {\n+\t      ixreg = XEXP (xtmp0, 1);\n+\t      scale = INTVAL (XEXP (xtmp0, 0));\n+\t    }\n+\t}\n+      else \n+\t{\n+\t  ixreg = xtmp0;\n+\t  scale = 1;\n+\t}\n+      goto PRINT_MEM;\n+\n+    NOT_DISP:\n+      if (REG_CODE_BASE_P (xtmp0)) \n+\t{\n+\t  breg = xtmp0;\n+\t  xtmp0 = xtmp1;\n+\t}\n+      else if (REG_CODE_BASE_P (xtmp1)) \n+\t{\n+\t  breg = xtmp1;\n+\t  /* xtmp0 = xtmp0; */\n+\t}\n+      else\n+\tgoto NOT_BASE;\n+    \n+      if (REG_CODE_INDEX_P (xtmp0)) \n+\t{\n+\t  ixreg = xtmp0;\n+\t  scale = 1;\n+\t  goto PRINT_MEM;\n+\t}\n+      else if (CONSTANT_ADDRESS_P (xtmp0)) \n+\t{\n+\t  offset = xtmp0;\n+\t  goto PRINT_MEM;\n+\t}\n+      else if (GET_CODE (xtmp0) == MULT) \n+\t{\n+\t  if (REG_CODE_INDEX_P (XEXP (xtmp0, 0))) \n+\t    {\n+\t      ixreg = XEXP (xtmp0, 0);\n+\t      scale = INTVAL (XEXP (xtmp0, 1));\n+\t    }\n+\t  else \n+\t    {\n+\t      ixreg = XEXP (xtmp0, 1);\n+\t      scale = INTVAL (XEXP (xtmp0, 0));\n+\t    }\n+\t  goto PRINT_MEM;\n+\t}\n+\n+      /* GET_CODE (xtmp0) must be PLUS. */\n+      xtmp1 = XEXP (xtmp0, 1);\n+      xtmp0 = XEXP (xtmp0, 0);\n+\n+      if (CONSTANT_ADDRESS_P (xtmp0)) \n+\t{\n+\t  offset = xtmp0;\n+\t  xtmp0 = xtmp1;\n+\t}\n+      else \n+\t{\n+\t  offset = xtmp1;\n+\t  /* xtmp0 = xtmp0; */\n+\t}\n+\n+      if (REG_CODE_INDEX_P (xtmp0)) \n+\t{\n+\t  ixreg = xtmp0;\n+\t}\n+      else \n+\t{\t\t\t/* GET_CODE (xtmp0) must be MULT. */\n+\t  if (REG_CODE_INDEX_P (XEXP (xtmp0, 0))) \n+\t    {\n+\t      ixreg = XEXP (xtmp0, 0);\n+\t      scale = INTVAL (XEXP (xtmp0, 1));\n+\t    }\n+\t  else \n+\t    {\n+\t      ixreg = XEXP (xtmp0, 1);\n+\t      scale = INTVAL (XEXP (xtmp0, 0));\n+\t    }\n+\t}\n+      goto PRINT_MEM;\n+\n+    NOT_BASE:\n+      if (GET_CODE (xtmp0) == PLUS) \n+\t{\n+\t  ixreg = xtmp1;\n+\t  /* xtmp0 = xtmp0; */\n+\t}\n+      else \n+\t{\n+\t  ixreg = xtmp0;\n+\t  xtmp0 = xtmp1;\n+\t}\n+\n+      if (REG_CODE_INDEX_P (ixreg)) \n+\t{\n+\t  scale = 1;\n+\t}\n+      else if (REG_CODE_INDEX_P (XEXP (ixreg, 0))) \n+\t{\n+\t  scale = INTVAL (XEXP (ixreg, 1));\n+\t  ixreg = XEXP (ixreg, 0);\n+\t}\n+      else \n+\t{\t\t\t/* was else if with no condition. OK ??? */\n+\t  scale = INTVAL (XEXP (ixreg, 0));\n+\t  ixreg = XEXP (ixreg, 1);\n+\t}\n+\n+      if (REG_CODE_BASE_P (XEXP (xtmp0, 0))) \n+\t{\n+\t  breg = XEXP (xtmp0, 0);\n+\t  offset = XEXP (xtmp0, 1);\n+\t}\n+      else \n+\t{\n+\t  breg = XEXP (xtmp0, 1);\n+\t  offset = XEXP (xtmp0, 0);\n+\t}\n+\n+    PRINT_MEM:\n+      if (breg == 0 && ixreg == 0) \n+\t{\n+\t  output_address (offset);\n+\t  break;\n+\t}\n+      else if (ixreg == 0 && offset == 0) \n+\t{\n+\t  fprintf (file, \"%s\", reg_names[REGNO (breg)]);\n+\t  break;\n+\t}\n+      else \n+\t{\n+\t  fprintf (file, \"(\");\n+\t  if (offset != 0) \n+\t    {\n+\t      output_addr_const (file, offset);\n+\t      needcomma = 1;\n+\t    }\n+\t  if (breg != 0) \n+\t    {\n+\t      if (needcomma)\n+\t\tfprintf (file, \",\");\n+\t      fprintf (file, \"%s\", reg_names[REGNO (breg)]);\n+\t      needcomma = 1;\n+\t    }\n+\t  if (ixreg != 0) \n+\t    {\n+\t      if (needcomma)\n+\t\tfprintf (file, \",\");\n+\t      fprintf (file, \"%s\", reg_names[REGNO (ixreg)]);\n+\t      if (scale != 1)\n+\t\tfprintf (file,\"*%d\", scale);\n+\t    }\n+\t  fprintf (file, \")\");\n+\n+\t  break;\n+\t}\n+\n+    default:\n+      output_addr_const (file, addr);\n+    }\n+}\n+\n+\n+\n+/* Return a REG that occurs in ADDR with coefficient 1.\n+   ADDR can be effectively incremented by incrementing REG.  */\n+\n+static rtx\n+find_addr_reg (addr)\n+     rtx addr;\n+{\n+  while (GET_CODE (addr) == PLUS)\n+    {\n+      if (GET_CODE (XEXP (addr, 0)) == REG)\n+\taddr = XEXP (addr, 0);\n+      else if (GET_CODE (XEXP (addr, 1)) == REG)\n+\taddr = XEXP (addr, 1);\n+      else if (GET_CODE (XEXP (addr, 0)) == PLUS)\n+\taddr = XEXP (addr, 0);\n+      else if (GET_CODE (XEXP (addr, 1)) == PLUS)\n+\taddr = XEXP (addr, 1);\n+    }\n+  if (GET_CODE (addr) == REG)\n+    return addr;\n+  return 0;\n+}\n+\n+\n+    /* Return the best assembler insn template\n+    for moving operands[1] into operands[0] as a fullword.  */\n+\n+static char *\n+singlemove_string (operands)\n+     rtx *operands;\n+{\n+  if (FPU_REG_P (operands[0]) || FPU_REG_P (operands[1])) \n+    {\n+      if (GREG_P (operands[0]) || GREG_P (operands[1])) \n+\t{\n+\t  myabort (101);\t/* Not Supported yet !! */\n+\t}\n+      else \n+\t{\n+\t  return \"fmov.s %1,%0\";\n+\t}\n+    }\n+  return \"mov.w %1,%0\";\n+}\n+\n+\n+/* Output assembler code to perform a doubleword move insn\n+   with operands OPERANDS.  */\n+\n+char *\n+output_move_double (operands)\n+     rtx *operands;\n+{\n+  enum \n+    { REGOP, OFFSOP, MEMOP, PUSHOP, POPOP, CNSTOP, RNDOP }\n+  optype0, optype1;\n+  rtx latehalf[2];\n+  rtx addreg0 = 0, addreg1 = 0;\n+\n+  /* First classify both operands.  */\n+\n+  if (REG_P (operands[0]))\n+    optype0 = REGOP;\n+  else if (offsettable_memref_p (operands[0]))\n+    optype0 = OFFSOP;\n+  else if (GET_CODE (XEXP (operands[0], 0)) == POST_INC)\n+    optype0 = POPOP;\n+  else if (GET_CODE (XEXP (operands[0], 0)) == PRE_DEC)\n+    optype0 = PUSHOP;\n+  else if (GET_CODE (operands[0]) == MEM)\n+    optype0 = MEMOP;\n+  else\n+    optype0 = RNDOP;\n+\n+  if (REG_P (operands[1]))\n+    optype1 = REGOP;\n+  else if (CONSTANT_P (operands[1]))\n+    optype1 = CNSTOP;\n+  else if (offsettable_memref_p (operands[1]))\n+    optype1 = OFFSOP;\n+  else if (GET_CODE (XEXP (operands[1], 0)) == POST_INC)\n+    optype1 = POPOP;\n+  else if (GET_CODE (XEXP (operands[1], 0)) == PRE_DEC)\n+    optype1 = PUSHOP;\n+  else if (GET_CODE (operands[1]) == MEM)\n+    optype1 = MEMOP;\n+  else\n+    optype1 = RNDOP;\n+\n+  /* Check for the cases that the operand constraints are not\n+     supposed to allow to happen.  Abort if we get one,\n+     because generating code for these cases is painful.  */\n+\n+  if (optype0 == RNDOP || optype1 == RNDOP)\n+    myabort (102);\n+\n+  /* If one operand is decrementing and one is incrementing\n+     decrement the former register explicitly\n+     and change that operand into ordinary indexing.  */\n+\n+  if (optype0 == PUSHOP && optype1 == POPOP)\n+    {\n+      operands[0] = XEXP (XEXP (operands[0], 0), 0);\n+      output_asm_insn (\"sub.w %#8,%0\", operands);\n+      operands[0] = gen_rtx (MEM, DImode, operands[0]);\n+      optype0 = OFFSOP;\n+    }\n+  if (optype0 == POPOP && optype1 == PUSHOP)\n+    {\n+      operands[1] = XEXP (XEXP (operands[1], 0), 0);\n+      output_asm_insn (\"sub.w %#8,%1\", operands);\n+      operands[1] = gen_rtx (MEM, DImode, operands[1]);\n+      optype1 = OFFSOP;\n+    }\n+\n+  /* If an operand is an unoffsettable memory ref, find a register\n+     we can increment temporarily to make it refer to the second word.  */\n+\n+  if (optype0 == MEMOP)\n+    addreg0 = find_addr_reg (operands[0]);\n+\n+  if (optype1 == MEMOP)\n+    addreg1 = find_addr_reg (operands[1]);\n+\n+  /* Ok, we can do one word at a time.\n+     Normally we do the low-numbered word first,\n+     but if either operand is autodecrementing then we\n+     do the high-numbered word first.\n+     \n+     In either case, set up in LATEHALF the operands to use\n+     for the high-numbered word and in some cases alter the\n+     operands in OPERANDS to be suitable for the low-numbered word.  */\n+\n+  if (optype0 == REGOP)\n+    latehalf[0] = gen_rtx (REG, SImode, REGNO (operands[0]) + 1);\n+  else if (optype0 == OFFSOP)\n+    latehalf[0] = adj_offsettable_operand (operands[0], 4);\n+  else\n+    latehalf[0] = operands[0];\n+\n+  if (optype1 == REGOP)\n+    latehalf[1] = gen_rtx (REG, SImode, REGNO (operands[1]) + 1);\n+  else if (optype1 == OFFSOP)\n+    latehalf[1] = adj_offsettable_operand (operands[1], 4);\n+  else if (optype1 == CNSTOP)\n+    {\n+      if (GET_CODE (operands[1]) == CONST_DOUBLE)\n+\tsplit_double (operands[1], &operands[1], &latehalf[1]);\n+      else if (CONSTANT_P (operands[1]))\n+\tlatehalf[1] = const0_rtx;\n+    }\n+  else\n+    latehalf[1] = operands[1];\n+\n+  /* If insn is effectively movd N(sp),-(sp) then we will do the\n+     high word first.  We should use the adjusted operand 1 (which is N+4(sp))\n+     for the low word as well, to compensate for the first decrement of sp.  */\n+  if (optype0 == PUSHOP\n+      && REGNO (XEXP (XEXP (operands[0], 0), 0)) == STACK_POINTER_REGNUM\n+      && reg_overlap_mentioned_p (stack_pointer_rtx, operands[1]))\n+    operands[1] = latehalf[1];\n+\n+  /* If one or both operands autodecrementing,\n+     do the two words, high-numbered first.  */\n+\n+  /* Likewise,  the first move would clobber the source of the second one,\n+     do them in the other order.  This happens only for registers;\n+     such overlap can't happen in memory unless the user explicitly\n+     sets it up, and that is an undefined circumstance.  */\n+\n+  if (optype0 == PUSHOP || optype1 == PUSHOP\n+      || (optype0 == REGOP && optype1 == REGOP\n+\t  && REGNO (operands[0]) == REGNO (latehalf[1])))\n+    {\n+      /* Make any unoffsettable addresses point at high-numbered word.  */\n+      if (addreg0)\n+\toutput_asm_insn (\"add.w %#4,%0\", &addreg0);\n+      if (addreg1)\n+\toutput_asm_insn (\"add.w %#4,%0\", &addreg1);\n+\n+      /* Do that word.  */\n+      output_asm_insn (singlemove_string (latehalf), latehalf);\n+\n+      /* Undo the adds we just did.  */\n+      if (addreg0)\n+\toutput_asm_insn (\"sub.w %#4,%0\", &addreg0);\n+      if (addreg1)\n+\toutput_asm_insn (\"sub.w %#4,%0\", &addreg1);\n+\n+      /* Do low-numbered word.  */\n+      return singlemove_string (operands);\n+    }\n+\n+  /* Normal case: do the two words, low-numbered first.  */\n+\n+  output_asm_insn (singlemove_string (operands), operands);\n+\n+  /* Make any unoffsettable addresses point at high-numbered word.  */\n+  if (addreg0)\n+    output_asm_insn (\"add.w %#4,%0\", &addreg0);\n+  if (addreg1)\n+    output_asm_insn (\"add.w %#4,%0\", &addreg1);\n+\n+  /* Do that word.  */\n+  output_asm_insn (singlemove_string (latehalf), latehalf);\n+\n+  /* Undo the adds we just did.  */\n+  if (addreg0)\n+    output_asm_insn (\"sub.w %#4,%0\", &addreg0);\n+  if (addreg1)\n+    output_asm_insn (\"sub.w %#4,%0\", &addreg1);\n+\n+  return \"\";\n+}\n+\n+/* Move const_double to floating point register (DF) */\n+char *\n+output_move_const_double (operands)\n+     rtx *operands;\n+{\n+  int code = standard_fpu_constant_p (operands[1]);\n+\n+  if (FPU_REG_P (operands[0])) \n+    {\n+      if (code != 0)\n+\t{\n+\t  static char buf[40];\n+\n+\t  sprintf (buf, \"fmvr from%d,%%0.d\", code);\n+\t  return buf;\n+\t}\n+      else \n+\t{\n+\t  return \"fmov %1,%0.d\";\n+\t}\n+    }\n+  else if (GREG_P (operands[0])) \n+    {\n+      rtx xoperands[2];\n+      xoperands[0] = gen_rtx (REG, SImode, REGNO (operands[0]) + 1);\n+      xoperands[1] = gen_rtx (CONST_INT, VOIDmode,\n+\t\t\t      CONST_DOUBLE_HIGH (operands[1]));\n+      output_asm_insn (\"mov.w %1,%0\", xoperands);\n+      operands[1] = gen_rtx (CONST_INT, VOIDmode,\n+\t\t\t     CONST_DOUBLE_LOW (operands[1]));\n+      return \"mov.w %1,%0\";\n+    }\n+  else \n+    {\n+      return output_move_double (operands); /* ?????? */\n+    }\n+}\n+\n+char *\n+output_move_const_single (operands)\n+     rtx *operands;\n+{\n+  int code = standard_fpu_constant_p (operands[1]);\n+  static char buf[40];\n+\n+  if (FPU_REG_P (operands[0])) \n+    {\n+      if (code != 0)\n+\t{\n+\t  sprintf (buf, \"fmvr from%d,%%0.s\", code);\n+\t  return buf;\n+\t}\n+      return \"fmov.s %f1,%0\";\n+    }\n+  else \n+    return \"mov.w %f1,%0\";\n+}\n+\n+\n+/* Return nonzero if X, a CONST_DOUBLE, has a value that we can get\n+   from the \"fmvr\" instruction of the Gmicro FPU.\n+   The value, anded with 0xff, gives the code to use in fmovecr\n+   to get the desired constant.  */\n+\n+  u.i[0] = CONST_DOUBLE_LOW (x);\n+  u.i[1] = CONST_DOUBLE_HIGH (x);\n+  d = u.d;\n+\n+  if (d == 0.0)\t\t\t/* +0.0 */\n+    return 0x0;\n+  /* Note: there are various other constants available\n+     but it is a nuisance to put in their values here.  */\n+  if (d == 1.0)\t\t\t/* +1.0 */\n+    return 0x1;\n+\n+  /*\n+   * Stuff that looks different if it's single or double\n+   */\n+  if (GET_MODE (x) == SFmode)\n+    {\n+      if (d == S_PI)\n+\treturn 0x2;\n+      if (d == (S_PI / 2.0))\n+\treturn 0x3;\n+      if (d == S_E)\n+\treturn 0x4;\n+      if (d == S_LOGEof2)\n+\treturn 0x5;\n+      if (d == S_LOGEof10)\n+\treturn 0x6;\n+      if (d == S_LOG10of2)\n+\treturn 0x7;\n+      if (d == S_LOG10ofE)\n+\treturn 0x8;\n+      if (d == S_LOG2ofE)\n+\treturn 0x9;\n+    }\n+  else\n+    {\n+      if (d == D_PI)\n+\treturn 0x2;\n+      if (d == (D_PI / 2.0))\n+\treturn 0x3;\n+      if (d == D_E)\n+\treturn 0x4;\n+      if (d == D_LOGEof2)\n+\treturn 0x5;\n+      if (d == D_LOGEof10)\n+\treturn 0x6;\n+      if (d == D_LOG10of2)\n+\treturn 0x7;\n+      if (d == D_LOG10ofE)\n+\treturn 0x8;\n+      if (d == D_LOG2ofE)\n+\treturn 0x9;\n+    }\n+\n+  return 0;\n+}\n+\n+#undef S_PI\n+#undef D_PI\n+#undef S_E\n+#undef D_E\n+#undef S_LOGEof2\n+#undef D_LOGEof2\n+#undef S_LOGEof10\n+#undef D_LOGEof10\n+#undef S_LOG10of2\n+#undef D_LOG10of2\n+#undef S_LOG10ofE\n+#undef D_LOG10ofE\n+#undef S_LOG2ofE\n+#undef D_LOG2ofE\n+\n+/* dest should be operand 0 */\n+/* imm should be operand 1 */\n+\n+extern char *sub_imm_word ();\n+\n+char *\n+add_imm_word (imm, dest, immp)\n+     int imm;\n+     rtx dest, *immp;\n+{\n+  int is_reg, short_ok;\n+\n+\n+  if (imm < 0) \n+    {\n+      *immp = gen_rtx (CONST_INT, VOIDmode, -imm);\n+      return sub_imm_word (-imm, dest);\n+    }\n+    \n+  if (imm == 0)\n+    return \"mov:l.w #0,%0\";\n+    \n+  short_ok = short_format_ok (dest);\n+\n+  if (short_ok && imm <= 8)\n+    return \"add:q %1,%0.w\";\n+\n+  if (imm < 128)\n+    return \"add:e %1,%0.w\";\n+\n+  is_reg = (GET_CODE (dest) == REG);\n+\n+  if (is_reg)\n+    return \"add:l %1,%0.w\";\n+    \n+  if (short_ok)\n+    return \"add:i %1,%0.w\";\n+    \n+  return \"add %1,%0.w\";\n+}\n+\n+char *\n+sub_imm_word (imm, dest, immp)\n+     int imm;\n+     rtx dest, *immp;\n+{\n+  int is_reg, short_ok;\n+\n+  if (imm < 0 &&  imm != 0x80000000) \n+    {\n+      *immp = gen_rtx (CONST_INT, VOIDmode, -imm);\n+      return add_imm_word (-imm, dest);\n+    }\n+    \n+  if (imm == 0)\n+    return \"mov:z.w #0,%0\";\n+    \n+  short_ok = short_format_ok (dest);\n+\n+  if (short_ok && imm <= 8)\n+    return \"sub:q %1,%0.w\";\n+\n+  if (imm < 128)\n+    return \"sub:e %1,%0.w\";\n+\n+  is_reg = (GET_CODE (dest) == REG);\n+\n+  if (is_reg)\n+    return \"sub:l %1,%0.w\";\n+    \n+  if (short_ok)\n+    return \"sub:i %1,%0.w\";\n+    \n+  return \"sub %1,%0.w\";\n+}\n+\n+int\n+short_format_ok (x)\n+     rtx x;\n+{\n+  rtx x0, x1;\n+\n+  if (GET_CODE (x) == REG)\n+    return 1;\n+\n+  if (GET_CODE (x) == MEM \n+      && GET_CODE (XEXP (x, 0)) == PLUS) \n+    {\n+      x0 = XEXP (XEXP (x, 0), 0);\n+      x1 = XEXP (XEXP (x, 0), 1);\n+      return ((GET_CODE (x0) == REG\n+\t       && CONSTANT_P (x1)\n+\t       && ((unsigned) (INTVAL (x1) + 0x8000)  < 0x10000))\n+\t      ||\n+\t      (GET_CODE (x1) == REG\n+\t       && CONSTANT_P (x0)\n+\t       && ((unsigned) (INTVAL (x0) + 0x8000)  < 0x10000)));\n+    }\n+\n+  return 0;\n+}\n+\n+myoutput_sp_adjust (file, op, fsize)\n+     FILE *file;\n+     char *op;\n+     int fsize;\n+{\n+  if (fsize == 0)\n+    ;\n+  else if (fsize < 8)\n+    fprintf (file, \"\\t%s:q #%d,sp.w\\n\", op, fsize);\n+  else if (fsize < 128)\n+    fprintf (file, \"\\t%s:e #%d,sp.w\\n\", op, fsize);\n+  else\n+    fprintf (file, \"\\t%s:l #%d,sp.w\\n\", op, fsize);\n+}\n+\n+\n+char *\n+mov_imm_word (imm, dest)\n+     int imm;\n+     rtx dest;\n+{\n+  int is_reg, short_ok;\n+\n+  if (imm == 0)\n+    return \"mov:z.w #0,%0\";\n+    \n+  short_ok = short_format_ok (dest);\n+\n+  if (short_ok && imm > 0 && imm <= 8)\n+    return \"mov:q %1,%0.w\";\n+\n+  if (-128 <= imm && imm < 128)\n+    return \"mov:e %1,%0.w\";\n+\n+  is_reg = (GET_CODE (dest) == REG);\n+\n+  if (is_reg)\n+    return \"mov:l %1,%0.w\";\n+    \n+  if (short_ok)\n+    return \"mov:i %1,%0.w\";\n+    \n+  return \"mov %1,%0.w\";\n+}\n+\n+char *\n+cmp_imm_word (imm, dest)\n+     int imm;\n+     rtx dest;\n+{\n+  int is_reg, short_ok;\n+\n+  if (imm == 0)\n+    return \"cmp:z.w #0,%0\";\n+    \n+  short_ok = short_format_ok (dest);\n+\n+  if (short_ok && imm >0 && imm <= 8)\n+    return \"cmp:q %1,%0.w\";\n+\n+  if (-128 <= imm && imm < 128)\n+    return \"cmp:e %1,%0.w\";\n+\n+  is_reg = (GET_CODE (dest) == REG);\n+\n+  if (is_reg)\n+    return \"cmp:l %1,%0.w\";\n+    \n+  if (short_ok)\n+    return \"cmp:i %1,%0.w\";\n+    \n+  return \"cmp %1,%0.w\";\n+}\n+\n+char *\n+push_imm_word (imm)\n+     int imm;\n+{\n+  if (imm == 0)\n+    return \"mov:z.w #0,%-\";\n+    \n+  if (imm > 0 && imm <= 8)\n+    return \"mov:q %1,%-.w\";\n+\n+  if (-128 <= imm && imm < 128)\n+    return \"mov:e %1,%-.w\";\n+\n+  return \"mov:g %1,%-.w\";\n+    \n+  /* In some cases, g-format may be better than I format.??\n+     return \"mov %1,%0.w\";\n+     */\n+}\n+\n+my_signed_comp (insn)\n+     rtx insn;\n+{\n+  rtx my_insn;\n+\n+  my_insn = NEXT_INSN (insn);\n+  if (GET_CODE (my_insn) != JUMP_INSN) \n+    {\n+      fprintf (stderr, \"my_signed_comp: Not Jump_insn \");\n+      myabort (GET_CODE (my_insn));\n+    }\n+  my_insn = PATTERN (my_insn);\n+  if (GET_CODE (my_insn) != SET) \n+    {\n+      fprintf (stderr, \"my_signed_comp: Not Set \");\n+      myabort (GET_CODE (my_insn));\n+    }\n+  my_insn = SET_SRC (my_insn);\n+  if (GET_CODE (my_insn) != IF_THEN_ELSE) \n+    {\n+      fprintf (stderr, \"my_signed_comp: Not if_then_else \");\n+      myabort (GET_CODE (my_insn));\n+    }\n+  switch (GET_CODE (XEXP (my_insn, 0)))\n+    {\n+    case NE:\n+    case EQ:\n+    case GE:\n+    case GT:\n+    case LE:\n+    case LT:\n+      return 1;\n+    case GEU:\n+    case GTU:\n+    case LEU:\n+    case LTU:\n+      return 0;\n+    }\n+  fprintf (stderr, \"my_signed_comp: Not cccc \");\n+  myabort (GET_CODE (XEXP (my_insn, 0)));\n+}"}]}