{"sha": "1595fe44e11a969d8ae462212886fb0a87b46226", "node_id": "C_kwDOANBUbNoAKDE1OTVmZTQ0ZTExYTk2OWQ4YWU0NjIyMTI4ODZmYjBhODdiNDYyMjY", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2021-10-14T02:04:53Z"}, "committer": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2021-10-15T01:40:11Z"}, "message": "c++: instantiate less for constant folding\n\nI've been experimenting with a change to make all inline functions\nimplicitly constexpr; this revealed that we are instantiating too\naggressively for speculative constant evaluation, leading to ordering\ndifficulties with e.g. is_a_helper<cgraph_node*>::test.  This patch tries to\navoid such instantiation until we actually need the function definition to\ndetermine whether a call is constant, by limiting the initial instantiation\nof all used functions to manifestly-constant-evaluated expressions, and\nchecking whether the function arguments are constant before instantiating\nthe function.\n\nThis change resulted in a change in the diagnostics for a few library tests\ndue to instantiating the function with the static_assert later (during\nconstant evaluation) than we did before (during instantiation of the\nintermediate function).\n\ngcc/cp/ChangeLog:\n\n\t* constexpr.c (cxx_bind_parameters_in_call): Replace\n\tnew_call parameter with fun.\n\t(cxx_eval_call_expression): Call it before instantiation.\n\t(cxx_eval_outermost_constant_expr): Only instantiate fns\n\twhen manifestly_const_eval.\n\t* typeck2.c (check_narrowing): This context is manifestly\n\tconstant-evaluated.\n\nlibstdc++-v3/ChangeLog:\n\n\t* testsuite/20_util/integer_comparisons/greater_equal_neg.cc:\n\t* testsuite/20_util/integer_comparisons/greater_neg.cc:\n\t* testsuite/20_util/integer_comparisons/less_equal_neg.cc:\n\tAdjust expected message.\n\t* testsuite/lib/prune.exp: Prune 'in constexpr expansion'.\n\ngcc/testsuite/ChangeLog:\n\n\t* g++.dg/ext/vla22.C: Don't expect a narrowing error.\n\t* g++.dg/cpp0x/constexpr-inst1.C: New test.", "tree": {"sha": "597c4fe89c15dd41e714e99532514947bc5add95", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/597c4fe89c15dd41e714e99532514947bc5add95"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1595fe44e11a969d8ae462212886fb0a87b46226", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1595fe44e11a969d8ae462212886fb0a87b46226", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1595fe44e11a969d8ae462212886fb0a87b46226", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1595fe44e11a969d8ae462212886fb0a87b46226/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5bb1e518b4a5b772665a22cc27245ece5bf82750", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5bb1e518b4a5b772665a22cc27245ece5bf82750", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5bb1e518b4a5b772665a22cc27245ece5bf82750"}], "stats": {"total": 152, "additions": 87, "deletions": 65}, "files": [{"sha": "c5f01b9547033570434e35da532aaabf4b83a221", "filename": "gcc/cp/constexpr.c", "status": "modified", "additions": 31, "deletions": 27, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1595fe44e11a969d8ae462212886fb0a87b46226/gcc%2Fcp%2Fconstexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1595fe44e11a969d8ae462212886fb0a87b46226/gcc%2Fcp%2Fconstexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstexpr.c?ref=1595fe44e11a969d8ae462212886fb0a87b46226", "patch": "@@ -1609,24 +1609,24 @@ addr_of_non_const_var (tree *tp, int *walk_subtrees, void *data)\n    all arguments and bind their values to correspondings\n    parameters, making up the NEW_CALL context.  */\n \n-static void\n-cxx_bind_parameters_in_call (const constexpr_ctx *ctx, tree t,\n-                             constexpr_call *new_call,\n+static tree\n+cxx_bind_parameters_in_call (const constexpr_ctx *ctx, tree t, tree fun,\n \t\t\t     bool *non_constant_p, bool *overflow_p,\n \t\t\t     bool *non_constant_args)\n {\n   const int nargs = call_expr_nargs (t);\n-  tree fun = new_call->fundef->decl;\n-  tree parms = new_call->fundef->parms;\n+  tree parms = DECL_ARGUMENTS (fun);\n   int i;\n   /* We don't record ellipsis args below.  */\n   int nparms = list_length (parms);\n   int nbinds = nargs < nparms ? nargs : nparms;\n-  tree binds = new_call->bindings = make_tree_vec (nbinds);\n+  tree binds = make_tree_vec (nbinds);\n   for (i = 0; i < nargs; ++i)\n     {\n       tree x, arg;\n       tree type = parms ? TREE_TYPE (parms) : void_type_node;\n+      if (parms && DECL_BY_REFERENCE (parms))\n+\ttype = TREE_TYPE (type);\n       x = get_nth_callarg (t, i);\n       /* For member function, the first argument is a pointer to the implied\n          object.  For a constructor, it might still be a dummy object, in\n@@ -1647,7 +1647,7 @@ cxx_bind_parameters_in_call (const constexpr_ctx *ctx, tree t,\n \t\t\t\t\t  non_constant_p, overflow_p);\n       /* Don't VERIFY_CONSTANT here.  */\n       if (*non_constant_p && ctx->quiet)\n-\treturn;\n+\tbreak;\n       /* Just discard ellipsis args after checking their constantitude.  */\n       if (!parms)\n \tcontinue;\n@@ -1698,6 +1698,8 @@ cxx_bind_parameters_in_call (const constexpr_ctx *ctx, tree t,\n \t}\n       parms = TREE_CHAIN (parms);\n     }\n+\n+  return binds;\n }\n \n /* Variables and functions to manage constexpr call expansion context.\n@@ -2564,6 +2566,26 @@ cxx_eval_call_expression (const constexpr_ctx *ctx, tree t,\n \t}\n     }\n \n+  bool non_constant_args = false;\n+  new_call.bindings\n+    = cxx_bind_parameters_in_call (ctx, t, fun, non_constant_p,\n+\t\t\t\t   overflow_p, &non_constant_args);\n+\n+  /* We build up the bindings list before we know whether we already have this\n+     call cached.  If we don't end up saving these bindings, ggc_free them when\n+     this function exits.  */\n+  class free_bindings\n+  {\n+    tree *bindings;\n+  public:\n+    free_bindings (tree &b): bindings (&b) { }\n+    ~free_bindings () { if (bindings) ggc_free (*bindings); }\n+    void preserve () { bindings = NULL; }\n+  } fb (new_call.bindings);\n+\n+  if (*non_constant_p)\n+    return t;\n+\n   /* We can't defer instantiating the function any longer.  */\n   if (!DECL_INITIAL (fun)\n       && DECL_TEMPLOID_INSTANTIATION (fun)\n@@ -2615,25 +2637,6 @@ cxx_eval_call_expression (const constexpr_ctx *ctx, tree t,\n         }\n     }\n \n-  bool non_constant_args = false;\n-  cxx_bind_parameters_in_call (ctx, t, &new_call,\n-\t\t\t       non_constant_p, overflow_p, &non_constant_args);\n-\n-  /* We build up the bindings list before we know whether we already have this\n-     call cached.  If we don't end up saving these bindings, ggc_free them when\n-     this function exits.  */\n-  class free_bindings\n-  {\n-    tree *bindings;\n-  public:\n-    free_bindings (tree &b): bindings (&b) { }\n-    ~free_bindings () { if (bindings) ggc_free (*bindings); }\n-    void preserve () { bindings = NULL; }\n-  } fb (new_call.bindings);\n-\n-  if (*non_constant_p)\n-    return t;\n-\n   depth_ok = push_cx_call_context (t);\n \n   /* Remember the object we are constructing or destructing.  */\n@@ -7394,7 +7397,8 @@ cxx_eval_outermost_constant_expr (tree t, bool allow_non_constant,\n   auto_vec<tree, 16> cleanups;\n   global_ctx.cleanups = &cleanups;\n \n-  instantiate_constexpr_fns (r);\n+  if (manifestly_const_eval)\n+    instantiate_constexpr_fns (r);\n   r = cxx_eval_constant_expression (&ctx, r,\n \t\t\t\t    false, &non_constant_p, &overflow_p);\n "}, {"sha": "c01f2f8ced449acf3fd5ebd1f884635d8895823e", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1595fe44e11a969d8ae462212886fb0a87b46226/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1595fe44e11a969d8ae462212886fb0a87b46226/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=1595fe44e11a969d8ae462212886fb0a87b46226", "patch": "@@ -892,7 +892,7 @@ check_narrowing (tree type, tree init, tsubst_flags_t complain,\n \n   /* Even non-dependent expressions can still have template\n      codes like CAST_EXPR, so use *_non_dependent_expr to cope.  */\n-  init = fold_non_dependent_expr (init, complain);\n+  init = fold_non_dependent_expr (init, complain, /*manifest*/true);\n   if (init == error_mark_node)\n     return ok;\n "}, {"sha": "3ce513d6e256152b3203318dba2971891d499dc9", "filename": "gcc/testsuite/g++.dg/cpp0x/constexpr-inst1.C", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1595fe44e11a969d8ae462212886fb0a87b46226/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-inst1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1595fe44e11a969d8ae462212886fb0a87b46226/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-inst1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-inst1.C?ref=1595fe44e11a969d8ae462212886fb0a87b46226", "patch": "@@ -0,0 +1,17 @@\n+// Test that we don't uselessly instantiate f<A> immediately while parsing g.\n+// Doing so is permitted by the standard, but has no benefit and breaks code\n+// unnecessarily.\n+\n+// { dg-do compile { target c++11 } }\n+\n+// -O activates the call to maybe_constant_value in cp_fold.\n+// { dg-additional-options -O }\n+\n+template <class T>\n+constexpr int f (const T* p) { return p->i; }\n+\n+constexpr int g(const struct A* p) { return f(p); }\n+\n+struct A { int i; };\n+\n+// Instantiating f<A> at EOF works fine."}, {"sha": "2308ee748df0b2f4031793eec5728a952c41779d", "filename": "gcc/testsuite/g++.dg/ext/vla22.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1595fe44e11a969d8ae462212886fb0a87b46226/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fvla22.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1595fe44e11a969d8ae462212886fb0a87b46226/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fvla22.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fvla22.C?ref=1595fe44e11a969d8ae462212886fb0a87b46226", "patch": "@@ -6,4 +6,4 @@ void\n f ()\n {\n   const int tbl[(long) \"h\"] = { 12 }; // { dg-error \"size of array .tbl. is not an integral constant-expression\" }\n-}\t\t\t\t      // { dg-warning \"narrowing conversion\" \"\" { target c++11 } .-1 }\n+}"}, {"sha": "8fc6179c07db809d2ce7789e6b92108f9331d842", "filename": "libstdc++-v3/testsuite/20_util/integer_comparisons/greater_equal_neg.cc", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1595fe44e11a969d8ae462212886fb0a87b46226/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Finteger_comparisons%2Fgreater_equal_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1595fe44e11a969d8ae462212886fb0a87b46226/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Finteger_comparisons%2Fgreater_equal_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Finteger_comparisons%2Fgreater_equal_neg.cc?ref=1595fe44e11a969d8ae462212886fb0a87b46226", "patch": "@@ -20,17 +20,17 @@\n \n #include <utility>\n \n-bool a = std::cmp_greater_equal('1', 49); // { dg-error \"here\" }\n-bool b = std::cmp_greater_equal(50, '2'); // { dg-error \"here\" }\n-bool c = std::cmp_greater_equal(2, L'2'); // { dg-error \"here\" }\n-bool d = std::cmp_greater_equal(L'2', 2); // { dg-error \"here\" }\n-bool e = std::cmp_greater_equal(true, 1); // { dg-error \"here\" }\n-bool f = std::cmp_greater_equal(0, false); // { dg-error \"here\" }\n-bool g = std::cmp_greater_equal(97, u8'a'); // { dg-error \"here\" }\n-bool h = std::cmp_greater_equal(u8'a', 97); // { dg-error \"here\" }\n-bool i = std::cmp_greater_equal(97, u'a'); // { dg-error \"here\" }\n-bool j = std::cmp_greater_equal(u'a', 97); // { dg-error \"here\" }\n-bool k = std::cmp_greater_equal(97, U'a'); // { dg-error \"here\" }\n-bool l = std::cmp_greater_equal(U'a', 97); // { dg-error \"here\" }\n+bool a = std::cmp_greater_equal('1', 49); // { dg-error \"constexpr\" }\n+bool b = std::cmp_greater_equal(50, '2'); // { dg-error \"constexpr\" }\n+bool c = std::cmp_greater_equal(2, L'2'); // { dg-error \"constexpr\" }\n+bool d = std::cmp_greater_equal(L'2', 2); // { dg-error \"constexpr\" }\n+bool e = std::cmp_greater_equal(true, 1); // { dg-error \"constexpr\" }\n+bool f = std::cmp_greater_equal(0, false); // { dg-error \"constexpr\" }\n+bool g = std::cmp_greater_equal(97, u8'a'); // { dg-error \"constexpr\" }\n+bool h = std::cmp_greater_equal(u8'a', 97); // { dg-error \"constexpr\" }\n+bool i = std::cmp_greater_equal(97, u'a'); // { dg-error \"constexpr\" }\n+bool j = std::cmp_greater_equal(u'a', 97); // { dg-error \"constexpr\" }\n+bool k = std::cmp_greater_equal(97, U'a'); // { dg-error \"constexpr\" }\n+bool l = std::cmp_greater_equal(U'a', 97); // { dg-error \"constexpr\" }\n \n // { dg-error \"static assertion failed\" \"\" { target *-*-* } 0 }"}, {"sha": "d5524b86c261d6efe8d30706b139dd86aeaa384d", "filename": "libstdc++-v3/testsuite/20_util/integer_comparisons/greater_neg.cc", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1595fe44e11a969d8ae462212886fb0a87b46226/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Finteger_comparisons%2Fgreater_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1595fe44e11a969d8ae462212886fb0a87b46226/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Finteger_comparisons%2Fgreater_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Finteger_comparisons%2Fgreater_neg.cc?ref=1595fe44e11a969d8ae462212886fb0a87b46226", "patch": "@@ -20,17 +20,17 @@\n \n #include <utility>\n \n-bool a = std::cmp_greater('1', 49); // { dg-error \"here\" }\n-bool b = std::cmp_greater(50, '2'); // { dg-error \"here\" }\n-bool c = std::cmp_greater(2, L'2'); // { dg-error \"here\" }\n-bool d = std::cmp_greater(L'2', 2); // { dg-error \"here\" }\n-bool e = std::cmp_greater(true, 1); // { dg-error \"here\" }\n-bool f = std::cmp_greater(0, false); // { dg-error \"here\" }\n-bool g = std::cmp_greater(97, u8'a'); // { dg-error \"here\" }\n-bool h = std::cmp_greater(u8'a', 97); // { dg-error \"here\" }\n-bool i = std::cmp_greater(97, u'a'); // { dg-error \"here\" }\n-bool j = std::cmp_greater(u'a', 97); // { dg-error \"here\" }\n-bool k = std::cmp_greater(97, U'a'); // { dg-error \"here\" }\n-bool l = std::cmp_greater(U'a', 97); // { dg-error \"here\" }\n+bool a = std::cmp_greater('1', 49); // { dg-error \"constexpr\" }\n+bool b = std::cmp_greater(50, '2'); // { dg-error \"constexpr\" }\n+bool c = std::cmp_greater(2, L'2'); // { dg-error \"constexpr\" }\n+bool d = std::cmp_greater(L'2', 2); // { dg-error \"constexpr\" }\n+bool e = std::cmp_greater(true, 1); // { dg-error \"constexpr\" }\n+bool f = std::cmp_greater(0, false); // { dg-error \"constexpr\" }\n+bool g = std::cmp_greater(97, u8'a'); // { dg-error \"constexpr\" }\n+bool h = std::cmp_greater(u8'a', 97); // { dg-error \"constexpr\" }\n+bool i = std::cmp_greater(97, u'a'); // { dg-error \"constexpr\" }\n+bool j = std::cmp_greater(u'a', 97); // { dg-error \"constexpr\" }\n+bool k = std::cmp_greater(97, U'a'); // { dg-error \"constexpr\" }\n+bool l = std::cmp_greater(U'a', 97); // { dg-error \"constexpr\" }\n \n // { dg-error \"static assertion failed\" \"\" { target *-*-* } 0 }"}, {"sha": "61a987561da805b16719848e106b28b5461bcce2", "filename": "libstdc++-v3/testsuite/20_util/integer_comparisons/less_equal_neg.cc", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1595fe44e11a969d8ae462212886fb0a87b46226/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Finteger_comparisons%2Fless_equal_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1595fe44e11a969d8ae462212886fb0a87b46226/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Finteger_comparisons%2Fless_equal_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Finteger_comparisons%2Fless_equal_neg.cc?ref=1595fe44e11a969d8ae462212886fb0a87b46226", "patch": "@@ -20,17 +20,17 @@\n \n #include <utility>\n \n-bool a = std::cmp_less_equal('1', 49); // { dg-error \"here\" }\n-bool b = std::cmp_less_equal(50, '2'); // { dg-error \"here\" }\n-bool c = std::cmp_less_equal(2, L'2'); // { dg-error \"here\" }\n-bool d = std::cmp_less_equal(L'2', 2); // { dg-error \"here\" }\n-bool e = std::cmp_less_equal(true, 1); // { dg-error \"here\" }\n-bool f = std::cmp_less_equal(0, false); // { dg-error \"here\" }\n-bool g = std::cmp_less_equal(97, u8'a'); // { dg-error \"here\" }\n-bool h = std::cmp_less_equal(u8'a', 97); // { dg-error \"here\" }\n-bool i = std::cmp_less_equal(97, u'a'); // { dg-error \"here\" }\n-bool j = std::cmp_less_equal(u'a', 97); // { dg-error \"here\" }\n-bool k = std::cmp_less_equal(97, U'a'); // { dg-error \"here\" }\n-bool l = std::cmp_less_equal(U'a', 97); // { dg-error \"here\" }\n+bool a = std::cmp_less_equal('1', 49); // { dg-error \"constexpr\" }\n+bool b = std::cmp_less_equal(50, '2'); // { dg-error \"constexpr\" }\n+bool c = std::cmp_less_equal(2, L'2'); // { dg-error \"constexpr\" }\n+bool d = std::cmp_less_equal(L'2', 2); // { dg-error \"constexpr\" }\n+bool e = std::cmp_less_equal(true, 1); // { dg-error \"constexpr\" }\n+bool f = std::cmp_less_equal(0, false); // { dg-error \"constexpr\" }\n+bool g = std::cmp_less_equal(97, u8'a'); // { dg-error \"constexpr\" }\n+bool h = std::cmp_less_equal(u8'a', 97); // { dg-error \"constexpr\" }\n+bool i = std::cmp_less_equal(97, u'a'); // { dg-error \"constexpr\" }\n+bool j = std::cmp_less_equal(u'a', 97); // { dg-error \"constexpr\" }\n+bool k = std::cmp_less_equal(97, U'a'); // { dg-error \"constexpr\" }\n+bool l = std::cmp_less_equal(U'a', 97); // { dg-error \"constexpr\" }\n \n // { dg-error \"static assertion failed\" \"\" { target *-*-* } 0 }"}, {"sha": "334f8218d1673bae05177072f1eb2cf4e0e0d878", "filename": "libstdc++-v3/testsuite/lib/prune.exp", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1595fe44e11a969d8ae462212886fb0a87b46226/libstdc%2B%2B-v3%2Ftestsuite%2Flib%2Fprune.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1595fe44e11a969d8ae462212886fb0a87b46226/libstdc%2B%2B-v3%2Ftestsuite%2Flib%2Fprune.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Flib%2Fprune.exp?ref=1595fe44e11a969d8ae462212886fb0a87b46226", "patch": "@@ -46,6 +46,7 @@ proc libstdc++-dg-prune { system text } {\n     regsub -all \"(^|\\n)\\[^\\n\\]*(: )?At (top level|global scope):\\[^\\n\\]*\" $text \"\" text\n     regsub -all \"(^|\\n)\\[^\\n\\]*:   (recursively )?required \\[^\\n\\]*\" $text \"\" text\n     regsub -all \"(^|\\n)\\[^\\n\\]*:   . skipping \\[0-9\\]* instantiation contexts \\[^\\n\\]*\" $text \"\" text\n+    regsub -all \"(^|\\n)\\[^\\n\\]*:   in .constexpr. expansion \\[^\\n\\]*\" $text \"\" text\n     regsub -all \"(^|\\n)    inlined from \\[^\\n\\]*\" $text \"\" text\n     # Why doesn't GCC need these to strip header context?\n     regsub -all \"(^|\\n)In file included from \\[^\\n\\]*\" $text \"\" text"}]}