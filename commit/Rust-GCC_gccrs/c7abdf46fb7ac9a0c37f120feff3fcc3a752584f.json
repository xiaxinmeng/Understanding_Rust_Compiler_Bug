{"sha": "c7abdf46fb7ac9a0c37f120feff3fcc3a752584f", "node_id": "C_kwDOANBUbNoAKGM3YWJkZjQ2ZmI3YWM5YTBjMzdmMTIwZmVmZjNmY2MzYTc1MjU4NGY", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2021-10-20T07:34:51Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2021-10-20T07:34:51Z"}, "message": "openmp: Fix up struct gomp_work_share handling [PR102838]\n\nIf GOMP_HAVE_EFFICIENT_ALIGNED_ALLOC is not defined, the intent was to\ntreat the split of the structure between first cacheline (64 bytes)\nas mostly write-once, use afterwards and second cacheline as rw just\nas an optimization.  But as has been reported, with vectorization enabled\nat -O2 it can now result in aligned vector 16-byte or larger stores.\nWhen not having posix_memalign/aligned_alloc/memalign or other similar API,\nalloc.c emulates it but it needs to allocate extra memory for the dynamic\nrealignment.\nSo, for the GOMP_HAVE_EFFICIENT_ALIGNED_ALLOC not defined case, this patch\nstops using aligned (64) attribute in the middle of the structure and instead\ninserts padding that puts the second half of the structure at offset 64 bytes.\n\nAnd when GOMP_HAVE_EFFICIENT_ALIGNED_ALLOC is defined, usually it was allocated\nas aligned, but for the orphaned case it could still be allocated just with\ngomp_malloc without guaranteed proper alignment.\n\n2021-10-20  Jakub Jelinek  <jakub@redhat.com>\n\n\tPR libgomp/102838\n\t* libgomp.h (struct gomp_work_share_1st_cacheline): New type.\n\t(struct gomp_work_share): Only use aligned(64) attribute if\n\tGOMP_HAVE_EFFICIENT_ALIGNED_ALLOC is defined, otherwise just\n\tadd padding before lock to ensure lock is at offset 64 bytes\n\tinto the structure.\n\t(gomp_workshare_struct_check1, gomp_workshare_struct_check2):\n\tNew poor man's static assertions.\n\t* work.c (gomp_work_share_start): Use gomp_aligned_alloc instead of\n\tgomp_malloc if GOMP_HAVE_EFFICIENT_ALIGNED_ALLOC.", "tree": {"sha": "d44e8ae64477a9dc5975549901a8e0ec5210f614", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d44e8ae64477a9dc5975549901a8e0ec5210f614"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c7abdf46fb7ac9a0c37f120feff3fcc3a752584f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c7abdf46fb7ac9a0c37f120feff3fcc3a752584f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c7abdf46fb7ac9a0c37f120feff3fcc3a752584f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c7abdf46fb7ac9a0c37f120feff3fcc3a752584f/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d4044db034b40c275b5f287d5854a102d22e07c0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d4044db034b40c275b5f287d5854a102d22e07c0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d4044db034b40c275b5f287d5854a102d22e07c0"}], "stats": {"total": 40, "additions": 40, "deletions": 0}, "files": [{"sha": "023d8a8c1df7f9da618f69125633559b7be9caef", "filename": "libgomp/libgomp.h", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7abdf46fb7ac9a0c37f120feff3fcc3a752584f/libgomp%2Flibgomp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7abdf46fb7ac9a0c37f120feff3fcc3a752584f/libgomp%2Flibgomp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Flibgomp.h?ref=c7abdf46fb7ac9a0c37f120feff3fcc3a752584f", "patch": "@@ -257,6 +257,30 @@ struct gomp_doacross_work_share\n   unsigned int shift_counts[];\n };\n \n+/* Like struct gomp_work_share, but only the 1st cacheline of it plus\n+   flexible array at the end.\n+   Keep in sync with struct gomp_work_share.  */\n+struct gomp_work_share_1st_cacheline\n+{\n+  enum gomp_schedule_type sched;\n+  int mode;\n+  union {\n+    struct {\n+      long chunk_size, end, incr;\n+    };\n+    struct {\n+      unsigned long long chunk_size_ull, end_ull, incr_ull;\n+    };\n+  };\n+  union {\n+    unsigned *ordered_team_ids;\n+    struct gomp_doacross_work_share *doacross;\n+  };\n+  unsigned ordered_num_used, ordered_owner, ordered_cur;\n+  struct gomp_work_share *next_alloc;\n+  char pad[];\n+};\n+\n struct gomp_work_share\n {\n   /* This member records the SCHEDULE clause to be used for this construct.\n@@ -324,7 +348,12 @@ struct gomp_work_share\n      are in a different cache line.  */\n \n   /* This lock protects the update of the following members.  */\n+#ifdef GOMP_HAVE_EFFICIENT_ALIGNED_ALLOC\n   gomp_mutex_t lock __attribute__((aligned (64)));\n+#else\n+  char pad[64 - offsetof (struct gomp_work_share_1st_cacheline, pad)];\n+  gomp_mutex_t lock;\n+#endif\n \n   /* This is the count of the number of threads that have exited the work\n      share construct.  If the construct was marked nowait, they have moved on\n@@ -362,6 +391,12 @@ struct gomp_work_share\n   unsigned inline_ordered_team_ids[0];\n };\n \n+extern char gomp_workshare_struct_check1\n+  [offsetof (struct gomp_work_share_1st_cacheline, next_alloc)\n+   == offsetof (struct gomp_work_share, next_alloc) ? 1 : -1];\n+extern char gomp_workshare_struct_check2\n+  [offsetof (struct gomp_work_share, lock) == 64 ? 1 : -1];\n+\n /* This structure contains all of the thread-local data associated with \n    a thread team.  This is the data that must be saved when a thread\n    encounters a nested PARALLEL construct.  */"}, {"sha": "bf2559155f1ef3f346aa9a876fadd145245f7e31", "filename": "libgomp/work.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7abdf46fb7ac9a0c37f120feff3fcc3a752584f/libgomp%2Fwork.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7abdf46fb7ac9a0c37f120feff3fcc3a752584f/libgomp%2Fwork.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fwork.c?ref=c7abdf46fb7ac9a0c37f120feff3fcc3a752584f", "patch": "@@ -191,7 +191,12 @@ gomp_work_share_start (size_t ordered)\n   /* Work sharing constructs can be orphaned.  */\n   if (team == NULL)\n     {\n+#ifdef GOMP_HAVE_EFFICIENT_ALIGNED_ALLOC\n+      ws = gomp_aligned_alloc (__alignof (struct gomp_work_share),\n+\t\t\t       sizeof (*ws));\n+#else\n       ws = gomp_malloc (sizeof (*ws));\n+#endif\n       gomp_init_work_share (ws, ordered, 1);\n       thr->ts.work_share = ws;\n       return true;"}]}