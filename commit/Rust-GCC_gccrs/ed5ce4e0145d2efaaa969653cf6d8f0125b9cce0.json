{"sha": "ed5ce4e0145d2efaaa969653cf6d8f0125b9cce0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWQ1Y2U0ZTAxNDVkMmVmYWFhOTY5NjUzY2Y2ZDhmMDEyNWI5Y2NlMA==", "commit": {"author": {"name": "Matthew Sachs", "email": "msachs@apple.com", "date": "2006-09-28T01:50:45Z"}, "committer": {"name": "Matthew Sachs", "email": "matthewg@gcc.gnu.org", "date": "2006-09-28T01:50:45Z"}, "message": "dglib.pm: Initial commit.\n\n* dglib.pm: Initial commit.\n* compareSumTests3: Initial commit.\n\nFrom-SVN: r117269", "tree": {"sha": "315889e49ddc236f81e4c468a13ddd11f56436e2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/315889e49ddc236f81e4c468a13ddd11f56436e2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ed5ce4e0145d2efaaa969653cf6d8f0125b9cce0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ed5ce4e0145d2efaaa969653cf6d8f0125b9cce0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ed5ce4e0145d2efaaa969653cf6d8f0125b9cce0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ed5ce4e0145d2efaaa969653cf6d8f0125b9cce0/comments", "author": null, "committer": null, "parents": [{"sha": "3441f1062c9aefab4a89f3d68a80a55323d9aec8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3441f1062c9aefab4a89f3d68a80a55323d9aec8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3441f1062c9aefab4a89f3d68a80a55323d9aec8"}], "stats": {"total": 681, "additions": 681, "deletions": 0}, "files": [{"sha": "069659dd05780383779eb17211d715e942f6cb49", "filename": "contrib/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed5ce4e0145d2efaaa969653cf6d8f0125b9cce0/contrib%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed5ce4e0145d2efaaa969653cf6d8f0125b9cce0/contrib%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/contrib%2FChangeLog?ref=ed5ce4e0145d2efaaa969653cf6d8f0125b9cce0", "patch": "@@ -1,3 +1,8 @@\n+2006-09-27  Matthew Sachs  <msachs@apple.com>\n+\n+\t* dglib.pm: Initial commit.\n+\t* compareSumTests3: Initial commit.\n+\n 2006-09-18  Bernhard Fischer  <aldot@gcc.gnu.org>\n \n \t* dg-cmp-results.sh (compare-$$.awk): Print name[old]"}, {"sha": "bcaad2035bae83ee6cda6719d125e52c0f54d5d5", "filename": "contrib/compareSumTests3", "status": "added", "additions": 252, "deletions": 0, "changes": 252, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed5ce4e0145d2efaaa969653cf6d8f0125b9cce0/contrib%2FcompareSumTests3", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed5ce4e0145d2efaaa969653cf6d8f0125b9cce0/contrib%2FcompareSumTests3", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/contrib%2FcompareSumTests3?ref=ed5ce4e0145d2efaaa969653cf6d8f0125b9cce0", "patch": "@@ -0,0 +1,252 @@\n+#!/usr/bin/perl\n+\n+# Three-way DejaGNU comparison; uses dglib.pm.  Run perldoc on this file for\n+# usage.\n+#\n+# Author: Matthew Sachs <msachs@apple.com>\n+#\n+# Copyright (c) 2006 Free Software Foundation.\n+#\n+# This file is part of GCC.\n+#\n+# GCC is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 2, or (at your option)\n+# any later version.\n+#\n+# GCC is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with GCC; see the file COPYING.  If not, write to\n+# the Free Software Foundation, 51 Franklin Street, Fifth Floor,\n+# Boston, MA 02110-1301, USA.\n+\n+=pod\n+\n+=head1 SYNOPSIS\n+\n+compareSumTests3 -- Two-way or three-way compare between DejaGNU .sum files\n+\n+=head1 USAGE\n+\n+\tcompareSumTests3 old1.sum [old2.sum] new.sum\n+\tcompareSumTests3 -i 1:2 -x 2:3 old1.sum old2.sum new.sum\n+\n+=head1 DESCRIPTION\n+\n+Gives results in terms of 'new' (e.g. things that work in 'new' and don't in\n+other compilers are improvements, things that don't in 'new' and do in others\n+are regressions, and it tells you which of the two old compilers (or both)\n+the test is a regression from.\n+\n+We treat any DG result other than PASS or XFAIL as a failure, e.g.\n+UNRESOLVED, UNTESTED or test was not run.\n+\n+We merge some tests into 'logical tests' with multiple subphases.\n+For instance, some tests will have compile, execute, and link\n+subtests.  For these tests, if one of the phases fails, we\n+indicate which phase the failure originates in.  For instance,\n+in the following test results:\n+\n+\tgcc.c-torture/compile_execute/xxxx.c: [FAIL:C,FAIL:X,PASS]\n+\n+the \"compile_execute\" replaces the compile or execute portion of the test name,\n+and \"FAIL:C\" and \"FAIL:X\" indicates where the combined test failed.\n+\n+=head1 OPTIONS\n+\n+=head2 OVERVIEW\n+\n+=over 4\n+\n+=item *\n+\n+C<-i X:Y>: Only display differences between the two indicated runs.\n+\n+=item *\n+\n+C<-p>: Give plain output, suitable for piping to another program.\n+\n+=item *\n+\n+C<-x X:Y>: Exclude differences between the two indicated runs.\n+\n+=back\n+\n+=head2 PLAIN OUTPUT FORMAT\n+\n+In the plain\n+output format, the category headers are not displayed and there are no tabs\n+in front of each result line.  Instead, each result line has two characters\n+followed by a space in front of it.  The first character will be either an 'I'\n+for improvement or 'R' for regression; the second character will be a 1, 2, or 3,\n+indicating which run was the odd one out.\n+\n+=back\n+\n+=head2 SELECTING CHANGE SUBSETS\n+\n+The following options cause only a selected subset of changes to be displayed.\n+These options ask for a \"run\", a number which is used to select\n+one of the three runs (C<old1>, C<old2>, or C<new>.)  C<1> and C<2> signify C<old1> and C<old2>\n+respectively; 3 signifies C<new>. If multiple options are given, the changes displayed\n+will be those which obey all of the given restrictions.\n+\n+Typical usage of these options is to express something like \"give me all changes\n+between 2 and 3, except for those where there was the same difference betwen 1 and 2\n+(as between 2 and 3.)\"  This would be given as:\n+\n+\t-i 2:3 -x 1:2\n+\n+=over 4\n+\n+=item *\n+\n+C<-i X:Y>: Only differences which are present between the two runs given\n+are displayed. For instance, if C<-i 1:2> is given and test A passes in\n+runs 1 and 2 but fails in run 3, that result will not be displayed.\n+\n+=item *\n+\n+C<-x X:Y>: Differences which are identical to a difference between the two runs\n+given will B<not> be displayed. For instance, if C<-x 1:2> is given and\n+test A passes in run 1 and fails in runs 2 and 3, that result will not be\n+displayed (since C<-x> will cause the difference between 1 and 2 to be ignored,\n+and the difference in 1 and 3 parallels the difference between 1 and 2.)\n+This option may only be used in conjunction with C<-i>.\n+\n+=back\n+\n+=cut\n+\n+use strict;\n+use warnings;\n+use Getopt::Long;\n+\n+use FindBin qw($Bin);\n+use lib \"$Bin\";\n+use dglib;\n+\n+my %options;\n+my $error = undef;\n+\n+if(!GetOptions(\n+\t\"p\" => \\$options{p},\n+\t\"i=s\" => \\$options{i},\n+\t\"x=s\" => \\$options{x},\n+)) {\n+\t$error = \"\";\n+} elsif(@ARGV != 2 and @ARGV != 3) {\n+\t$error = \"\";\n+} elsif($options{x} and !$options{i}) {\n+\t$error = \"-x may only be given in conjunction with -i.\";\n+} else {\n+\tforeach my $opt(\"i\", \"x\") {\n+\t\tif($options{$opt} and\n+\t\t  ($options{$opt} !~ /^([123]):([123])$/ or\n+\t\t   $1 == $2)\n+\t\t) {\n+\t\t\t$error = \"Invalid -$opt argument.\";\n+\t\t}\n+\t}\n+}\n+\n+if(defined($error)) {\n+\tprint STDERR \"$error\\n\" if $error;\n+\tprint STDERR \"Usage: compareSumTests3 [-p] [-i X:Y [-x X:Y]] old1.sum old2.sum new.sum\\n\";\n+\tprint STDERR \"Try 'perldoc $0' for further information.\\n\";\n+\texit 1;\n+} \n+\n+my(@sumfiles) = @ARGV;\n+-f $_ || die \"$_ is not a regular file!\\n\" foreach @sumfiles;\n+my(%results, @inc_changes, @exc_changes, %checksums);\n+\n+# We decrement the values given so that they correspond\n+# to indices into our results array.\n+if($options{i}) {\n+\t$options{i} =~ /(\\d+):(\\d+)/;\n+\t@inc_changes = ($1 - 1, $2 - 1);\n+}\n+if($options{x}) {\n+\t$options{x} =~ /(\\d+):(\\d+)/;\n+\t@exc_changes = ($1 - 1, $2 - 1);\n+}\n+\n+\n+my %analyzed_results = compareSumFiles(\\@sumfiles);\n+\n+foreach my $cat (qw(improvements regressions miscellaneous)) {\n+\tif(@sumfiles == 3) {\n+\t\tmy @subcounts;\n+\t\tif(!$options{p}) {\n+\t\t\t$subcounts[$_] = @{$analyzed_results{$cat}->[$_] || []} for(0..2);\n+\t\t\tprint \"\\u$cat: \", ($subcounts[0]+$subcounts[1]+$subcounts[2]), \"\\n\";\n+\t\t}\n+\n+\t\tfor(my $i = 0; $i < 3; $i++) {\n+\t\t\tif(!$options{p} and $cat ne \"miscellaneous\") {\n+\t\t\t\tif($i == 0) {\n+\t\t\t\t\tif($cat eq \"regressions\") {\n+\t\t\t\t\t\tprint \"\\tSuccess in old1 only: $subcounts[$i]\\n\";\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tprint \"\\tFailure in old1 only: $subcounts[$i]\\n\";\n+\t\t\t\t\t}\n+\t\t\t\t} elsif($i == 1) {\n+\t\t\t\t\tif($cat eq \"regressions\") {\n+\t\t\t\t\t\tprint \"\\tSuccess in old2 only: $subcounts[$i]\\n\";\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tprint \"\\tFailure in old2 only: $subcounts[$i]\\n\";\n+\t\t\t\t\t}\n+\t\t\t\t} else {\n+\t\t\t\t\tif($cat eq \"regressions\") {\n+\t\t\t\t\t\tprint \"\\tFailure in new only: $subcounts[$i]\\n\";\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tprint \"\\tSuccess in new only: $subcounts[$i]\\n\";\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tforeach my $test (sort {$a->{name} cmp $b->{name}} @{$analyzed_results{$cat}->[$i] || []}) {\n+\t\t\t\tif(!$options{p}) {\n+\t\t\t\t\tif($cat eq \"miscellaneous\") {\n+\t\t\t\t\t\tprint \"\\t\";\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tprint \"\\t\\t\";\n+\t\t\t\t\t}\n+\t\t\t\t} else {\n+\t\t\t\t\tif($cat eq \"regressions\") {\n+\t\t\t\t\t\tprint \"R\";\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tprint \"I\";\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tprint $i+1, \" \";\n+\t\t\t\t}\n+\t\t\t\tprintf \"%s [%s,%s,%s]\\n\", $test->{name}, $test->{data}->[0], $test->{data}->[1], $test->{data}->[2];\n+\t\t\t}\n+\t\t}\n+\t} else {\n+\t\tif(!$options{p}) {\n+\t\t\tmy $subcount = @{$analyzed_results{$cat}};\n+\t\t\tprint \"\\u$cat: $subcount\\n\";\n+\t\t}\n+\n+\t\tforeach my $test (sort {$a->{name} cmp $b->{name}} @{$analyzed_results{$cat}}) {\n+\t\t\tif(!$options{p}) {\n+\t\t\t\tprint \"\\t\";\n+\t\t\t} else {\n+\t\t\t\tif($cat eq \"regressions\") {\n+\t\t\t\t\tprint \"R\";\t\t\t\t} else {\n+\t\t\t\t\tprint \"I\";\n+\t\t\t\t}\n+\n+\t\t\t\tprint \"  \";\n+\t\t\t}\n+\t\t\tprintf \"%s [%s,%s]\\n\", $test->{name}, $test->{data}->[0], $test->{data}->[1], $test->{data}->[2];\n+\t\t}\n+\t}\n+}"}, {"sha": "2d2016e099407ee890e31bda750ef54e3277b21e", "filename": "contrib/dglib.pm", "status": "added", "additions": 424, "deletions": 0, "changes": 424, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed5ce4e0145d2efaaa969653cf6d8f0125b9cce0/contrib%2Fdglib.pm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed5ce4e0145d2efaaa969653cf6d8f0125b9cce0/contrib%2Fdglib.pm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/contrib%2Fdglib.pm?ref=ed5ce4e0145d2efaaa969653cf6d8f0125b9cce0", "patch": "@@ -0,0 +1,424 @@\n+# Library of functions for dealing with DejaGNU, or which are otherwise\n+# generally useful for the DejaGNU tool stack.\n+#\n+# Author: Matthew Sachs <msachs@apple.com>\n+#\n+# Functions:\n+#\tparseLogFile: See \"sub parseLogFile\" below for details.  This function\n+#\t\treturns a detailed parse of a DejaGNU log or sum file.\n+#\tispass: Takes a DejaGNU result (e.g. \"PASS\", \"XPASS\") and returns\n+#\t\ttrue if and only if it is a passing result (PASS, XFAIL, or\n+#\t\tKFAIL.)\n+#\n+# Copyright (c) 2006 Free Software Foundation.\n+#\n+# This file is part of GCC.\n+#\n+# GCC is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 2, or (at your option)\n+# any later version.\n+#\n+# GCC is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with GCC; see the file COPYING.  If not, write to\n+# the Free Software Foundation, 51 Franklin Street, Fifth Floor,\n+# Boston, MA 02110-1301, USA.\n+\n+package dglib;\n+\n+use strict;\n+use warnings;\n+use Exporter;\n+\n+our @ISA = qw(Exporter);\n+our @EXPORT = qw(ispass parseLogFile);\n+\n+use File::Basename;\n+use POSIX qw(mktime);\n+\n+\n+# Create a group hierarchy, returning the leaf node\n+sub mkGroupPath {\n+\tmy($root, $groups, @newgroups) = @_;\n+\n+\tmy $parent = $root;\n+\tmy $fullname = \"\";\n+\tforeach my $group(@newgroups) {\n+\t\t$fullname .= \"/\" if $fullname;\n+\t\t$fullname .= $group;\n+\t\tif(exists($groups->{$fullname})) {\n+\t\t\t$parent = $groups->{$fullname};\n+\t\t} else {\n+\t\t\tmy $newgroup = {name => $group, parent => $parent};\n+\t\t\t$groups->{$fullname} = $newgroup;\n+\t\t\t$parent->{testgroup} ||= [];\n+\t\t\tpush @{$parent->{testgroup}}, $newgroup;\n+\t\t\t$parent = $newgroup;\n+\t\t}\n+\t}\n+\n+\treturn $parent;\n+}\n+\n+# Extract information from DejaGNU log or sum files.\n+# Options, if provided, should be a hashref with zero or more of the following keys:\n+#\tgccdir:\n+# \t\tPassing in the full path to the root of the gcc/testsuite directory\n+#\t\twill help in the parsing, but if it isn't provided, it will be guessed.\n+#\tdiagnostics:\n+#\t\tIf set to 0, diagnostics will not be returned.  This can save a lot\n+#\t\tof memory if you are not using this information.\n+#\tfullname:\n+#\t\tIf set to 0, the fullname key will not be included in tests.\n+# Returns a hash with the following keys:\n+#\tincomplete: 1 if the summary file appears truncated, otherwise 0\n+#\tdiagnostics: List of (type, value) for any errors detected.  Type can be ERROR, WARNING, or NOTE.\n+#\ttest: Array of root-level tests, with keys:\n+#\t\tname: Name of the test, relative to the enclosing test group.\n+#\t\tfullname: Fully-qualified name of the test.\n+#\t\tresult: DejaGNU result (PASS, FAIL, XPASS, &c)\n+#\t\tdetail: For multi-phase (e.g. compile/link/execute), this will be\n+#\t\t        the furthest phase which the test was able to attempt,\n+#\t\t\tso if the result is FAIL and this is \"link phase\", the test\n+#\t\t\tcompiled but failed to link.  This key may contain other\n+#\t\t\tauxiliary data.\n+#\t\tpseudotest: If 1, this test may not really exist; see \"pseudotest\" below.\n+#\ttestgroup: Array of root-level testgroups, with keys:\n+#\t\tname: Name of the group.\n+#\t\tparent: Parent test group.\n+#\t\ttest: As per above.\n+#\t\ttestgroup: Child test groups.\n+#\tcompiler: Version string from compiler used to run the tests (if detected)\n+sub parseLogFile($;$) {\n+\tmy($logfile, $options) = @_;\n+\t$options ||= {};\n+\tmy $gccdir = $options->{gccdir} || \"\";\n+\tmy $return_diags = exists($options->{diagnostics}) ? $options->{diagnostics} : 1;\n+\tmy $emit_fullname = exists($options->{fullname}) ? $options->{fullname} : 1;\n+\tmy $is_gdb = 0;\n+\tmy $gdbhack = \"\";\n+\n+\tmy %ret = (incomplete => 1, diagnostics => [], testgroup => []);\n+\tmy(%testindex, %groupindex);\n+\n+\topen(LOGFILE, $logfile) or die \"Couldn't open log file $logfile: $!\\n\";\n+\n+\tmy($currgroup, $currtest, $lastrun);\n+\t$currgroup = \\%ret;\n+\n+\tmy %monmap = (Jan => 0, Feb => 1, Mar => 2, Apr => 3, May => 4, Jun => 5, Jul => 6, Aug => 7, Sep => 8, Oct => 9, Nov => 10, Dec => 11);\n+\n+\t# We don't want gccdir matching on an empty string.\n+\t$gccdir ||= \"this will never match, or my name isn't Reginald St. Croix\";\n+\n+\tmy $line = 1;\n+\twhile(<LOGFILE>) {\n+\t\tchomp;\n+\t\ts/\\x{d}$//; #^M\n+\t\tnext if $_ eq \"\";\n+\n+\t\tif(/^gcc version/) {\n+\t\t\t$ret{compiler} = $_;\n+\t\t} elsif(/^got a .* signal, interrupted by user /) {\n+\t\t\t$ret{incomplete} = 2;\n+\t\t} elsif(/^\\s*=== gdb/) {\n+\t\t\t$is_gdb = 1;\n+\t\t\t# The log file from the GDB test suite is prone to have random crap\n+\t\t\t# in front of test result lines, so we need to be looser about how\n+\t\t\t# we parse those for GDB.\n+\t\t\t$gdbhack = \".*\";\n+\t\t} elsif(/^(Test Run By \\S+ on|runtest completed at) ... (.{3}) (\\d{1,2}) (\\d{1,2}):(\\d{1,2}):(\\d{1,2}) (\\d{4})/) {\n+\t\t\tmy $time = mktime($6, $5, $4, $3, $monmap{$2}, $7 - 1900);\n+\t\t\tif($1 eq \"runtest completed at\") {\n+\t\t\t\t$ret{end_time} = $time;\n+\t\t\t} else {\n+\t\t\t\t$ret{start_time} = $time;\n+\t\t\t}\n+\t\t} elsif(m<^Running (?!target )\\Q$gccdir\\E/?(\\S+)> or m<^Running (?!target )\\S*?((?:gcc|gdb|libstdc\\+\\+-v3)/testsuite/\\S+)>) {\n+\t\t\t# We keep track of the last \"Running foo/bar/baz.exp\" line because\n+\t\t\t# some tests don't bother printing out the full paths of their files,\n+\t\t\t# and this gives us the directory information.\n+\n+\t\t\t$lastrun = $1;\n+\t\t\t$lastrun =~ s!/[^/]*/\\.\\.!!; # foo/bar/../baz -> foo/baz\n+\t\t\t$currgroup = mkGroupPath(\\%ret, \\%groupindex, split(m!/!, $lastrun));\n+\t\t\t#$currgroup->{testfile} = $lastrun;\n+\t\t} elsif(/^Executing on (.*?):(.*)/) {\n+\t\t\t# Okay, if it's \"Executing on host\", it's a new\n+\t\t\t# file.  If it's \"Executing on unix\", it's probably\n+\t\t\t# a test within the file -- an execution test, specifically --\n+\t\t\t# (makes sense, no?)  But not always, sometimes we\n+\t\t\t# see \"Executing on unix\" outside the context of a\n+\t\t\t# file.\n+\n+\t\t\t# Try to pick out the gccdir-relative filename.\n+\t\t\t# If we can't find it, it isn't really a new testfile,\n+\t\t\t# but a derived file.\n+\t\t\tmy($exectype, $execwhat) = ($1, $2);\n+\t\t\tnext if $execwhat =~ /^dsymutil/;\n+\t\t\t$execwhat =~\n+\t\t\t\ts!.*?\\s\\Q$gccdir\\E/?(\\S+).*!$1! or\n+\t\t\t\ts!.*?/((?:gcc|gdb|libstdc\\+\\+-v3)/testsuite/\\S+).*!$1! or\n+\t\t\t\t$exectype = \"unix\";\n+\n+\t\t\tif($exectype eq \"host\" or !$currgroup) {\n+\t\t\t\t# New file\n+\n+\t\t\t\tmy $nogroup = 0;\n+\t\t\t\tif($execwhat =~ / /) {\n+\t\t\t\t\t# We probably haven't parsed the file correctly.\n+\t\t\t\t\t# Try getting it from $lastrun.\n+\n+\t\t\t\t\t$execwhat = dirname($lastrun) . \"/\" . basename($execwhat) if $lastrun and $execwhat;\n+\t\t\t\t\t$execwhat =~ s/\\s.*//;\n+\n+\t\t\t\t\t# At the end of each tool, it invokes \"gcc -v\" or \"c++ -v\"\n+\t\t\t\t\t# as a test.  We don't really want to treat this as a test.\n+\t\t\t\t\tif($execwhat =~ m!/(gcc|c\\+\\+)$!) {\n+\t\t\t\t\t\tundef $currtest;\n+\t\t\t\t\t\tundef $currgroup;\n+\t\t\t\t\t\t$nogroup = 1;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\t\tif(!$nogroup) {\n+\t\t\t\t\tundef $currtest;\n+\t\t\t\t\t$execwhat =~ s!/[^/]*/\\.\\.!!; # foo/bar/../baz -> foo/baz\n+\n+\t\t\t\t\tif($lastrun) {\n+\t\t\t\t\t\tmy $lastbase = dirname($lastrun);\n+\t\t\t\t\t\tmy $basegroup = $execwhat;\n+\t\t\t\t\t\t$basegroup =~ s!^\\Q$lastbase\\E/!!;\n+\t\t\t\t\t\t$execwhat = \"$lastrun/$basegroup\";\n+\t\t\t\t\t}\n+\n+\t\t\t\t\t$currgroup = mkGroupPath(\\%ret, \\%groupindex, split(m!/!, $execwhat));\n+\t\t\t\t\t#$currgroup->{testfile} = $execwhat;\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\t# New test within current file\n+\n+\t\t\t\t$currtest = {};\n+\t\t\t}\n+\t\t} elsif(/^# of/) {\n+\t\t\t# This line appears should appear near the end of summary files.\n+\t\t\t# If it doesn't, something went wrong.\n+\n+\t\t\tif($ret{incomplete} == 2) {\n+\t\t\t\t#Ah, but we previously saw indication that we were killed via a signal.\n+\t\t\t\t$ret{incomplete} = 1;\n+\t\t\t} else {\n+\t\t\t\t$ret{incomplete} = 0;\n+\t\t\t}\n+\t\t} elsif(/^testcase .* completed/) {\n+\t\t\t# End of a .exp file\n+\t\t\tundef $currtest;\n+\t\t\tundef $currgroup;\n+\t\t} elsif(/^$gdbhack(FAIL|PASS|UNRESOLVED|UNSUPPORTED|UNTESTED|XFAIL|XPASS|KFAIL|KPASS): (.*)/) {\n+\t\t\t# If the currtest already has a name, that means we've already seen\n+\t\t\t# its results, so what we have now is a new test.  However, if we\n+\t\t\t# haven't seen results for currtest yet, that means currtest just\n+\t\t\t# has some diagnostics associated with it but no actual results,\n+\t\t\t# so just use that one.\n+\t\t\tundef $currtest if $currtest->{name};\n+\n+\t\t\tmy $phase = \"\"; # compile/link/execute\n+\t\t\tmy($test, $result) = ($2, $1);\n+\n+\t\t\t# Compile/(link/)execute combining\n+\t\t\tif($test =~ /^(.*) compile\\s*$/) {\n+\t\t\t\t$test = \"$1 compile,link,execute\";\n+\t\t\t\t$phase = \"compile\";\n+\t\t\t} elsif($test =~ /^(.*)-(.*) (link|execute)\\s*$/) {\n+\t\t\t\t$test = \"$1 compile,link,execute\";\n+\t\t\t\tif($3 eq \"link\") {\n+\t\t\t\t\t$phase = \"link\";\n+\t\t\t\t} else {\n+\t\t\t\t\t$phase = \"execute\";\n+\t\t\t\t}\n+\t\t\t} elsif($test =~ /(compile|compilation|execute|execution)/) {\n+\t\t\t\tmy $phasematch = $1;\n+\t\t\t\tif($test =~ /^com/) {\n+\t\t\t\t\t$phase = \"compile\";\n+\t\t\t\t} else {\n+\t\t\t\t\t$phase = \"execute\";\n+\t\t\t\t}\n+\t\t\t\t$test =~ s!\\Q$phasematch\\E!compile,execute!;\n+\t\t\t}\n+\n+\t\t\t# gcov tests behave in non-standard fashion.\n+\t\t\tmy $failwhy = \"\";\n+\t\t\t$test =~ s/ gcov failed: (.*)// and $failwhy = $1;\n+\n+\t\t\t# And some other tests have random information after a colon :(\n+\t\t\t# But for scan-assembler, this really is part of the name.\n+\t\t\tif(!$is_gdb and $test !~ /scan-assembler/ and $test =~ s/:\\s*(.+)//) {\n+\t\t\t\t$failwhy = $1;\n+\t\t\t}\n+\n+\t\t\t$test =~ s/\\s*$//;\n+\t\t\t$test =~ s/^\\s*$//;\n+\n+\t\t\t# Sometimes there's a test which shows up as:\n+\t\t\t#\tfoo (test for excess errors)\n+\t\t\t#\tfoo (something else)\n+\t\t\t#\tfoo: error executing dg-final\n+\t\t\t# if it runs, but just:\n+\t\t\t#\tfoo\n+\t\t\t# if it doesn't.  When we see the top form, we create a\n+\t\t\t# \"pseudotest\" in the bottom form, so that comparisons\n+\t\t\t# can be made.\n+\t\t\tmy $basetest = $test;\n+\t\t\t$basetest =~ s/:? .*//;\n+\n+\t\t\tif(exists($testindex{$test}) and !$testindex{$test}->{pseudotest}) {\n+\t\t\t\t$currtest = $testindex{$test};\n+\t\t\t\tif(ispass($currtest->{result})) {\n+\t\t\t\t\t$currtest->{result} = $result;\n+\t\t\t\t\t$currtest->{detail} = \"$phase phase\";\n+\t\t\t\t\t$currtest->{detail} .= \"; $failwhy\" if $failwhy;\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\t# This might have been created earlier as a pseudotest.\n+\t\t\t\t# If so, overwrite it.\n+\t\t\t\t$currtest ||= $testindex{$test} || {};\n+\n+\t\t\t\t$currtest->{name} = basename($test);\n+\t\t\t\tif($emit_fullname) {\n+\t\t\t\t\t$currtest->{fullname} = ($currgroup->{name} || dirname($test)) . \"/$currtest->{name}\";\n+\t\t\t\t}\n+\t\t\t\tmy $grpname = $currgroup->{name} || \"\";\n+\t\t\t\t$currtest->{name} =~ s/^\\s*\\Q$grpname\\E\\s*//;\n+\t\t\t\t$currtest->{name} =~ s/^: // if $is_gdb;\n+\t\t\t\t# Sometimes there's a test at the root of the group.\n+\t\t\t\t# For instance, you'll have:\n+\t\t\t\t#\tFAIL: foo/bar.c (test for excess errors)\n+\t\t\t\t#\tUNRESOLVED: foo/bar.c: couldn't open \"bar.s\": no such file or directory\n+\t\t\t\t# In this case, groupname *is* the entire name, so the regex above will make the test name empty.\n+\t\t\t\t# In this case, we actually want to use the parent group and make this a test within that group.\n+\t\t\t\tmy $orig_currgroup = $currgroup;\n+\t\t\t\tif(!$currtest->{name}) {\n+\t\t\t\t\t$currtest->{name} = $grpname;\n+\t\t\t\t\t$currgroup = $currgroup->{parent};\n+\t\t\t\t\t$grpname = $currgroup->{name} || \"\";\n+\t\t\t\t}\n+\n+\t\t\t\t$currtest->{result} = $result;\n+\t\t\t\tif($phase and $failwhy) {\n+\t\t\t\t\t$currtest->{detail} = \"$phase phase; $failwhy\" if $phase;\n+\t\t\t\t} elsif($phase) {\n+\t\t\t\t\t$currtest->{detail} = \"$phase phase\";\n+\t\t\t\t} elsif($failwhy) {\n+\t\t\t\t\t$currtest->{detail} = $failwhy;\n+\t\t\t\t}\n+\n+\t\t\t\t$currgroup->{test} ||= [];\n+\t\t\t\tpush @{$currgroup->{test}}, $currtest;\n+\t\t\t\t$testindex{$test} = $currtest;\n+\t\t\t\t$currgroup = $orig_currgroup;\n+\n+\t\t\t\tif($basetest ne $test) {\n+\t\t\t\t\tif(!exists($testindex{$basetest}) ) {\n+\t\t\t\t\t\tmy $btbase = basename($basetest);\n+\t\t\t\t\t\t$testindex{$basetest} = {\n+\t\t\t\t\t\t\tname => $btbase,\n+\t\t\t\t\t\t\tresult => $result,\n+\t\t\t\t\t\t\tpseudotest => 1,\n+\t\t\t\t\t\t\tfullname => $btbase\n+\t\t\t\t\t\t};\n+\t\t\t\t\t\tif($emit_fullname) {\n+\t\t\t\t\t\t\t$testindex{basetest}->{fullname} = ($currgroup->{name} || dirname($basetest)) . \"/$btbase\";\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tpush @{$currgroup->{parent}->{test}}, $testindex{$basetest};\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\t# Only let the base test pass if all the sub-tests pass\n+\t\t\t\t\t\t$testindex{$basetest}->{result} = $result if !ispass($result);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\t}\n+\t\t} elsif(/^\\s+=== .* Summary ===\\s*$/) {\n+\t\t\tundef $currgroup;\n+\t\t\tundef $currtest;\n+\t\t}\n+\n+\t\tmy $severity;\n+\t\tif(/^(ERROR|WARNING|NOTE): (.*)/) {\n+\t\t\t$severity = $1;\n+\t\t\tmy $message = $2;\n+\n+\t\t\tif($message eq \"program timed out.\") {\n+\t\t\t\t$currtest->{result} = \"TIMEDOUT\";\n+\t\t\t} elsif(\n+\t\t\t\t$message =~ /can't read \"(HOSTCC|libiconv)\": no such variable/ or\n+\t\t\t\t$message =~ /no files matched glob pattern/ or\n+\t\t\t\t$message =~ /error executing dg-final: .*: no such file/\n+\t\t\t) {\n+\t\t\t\t$severity = \"NOTE\";\n+\t\t\t}\n+\t\t} else {\n+\t\t\t$severity = \"logline\";\n+\t\t}\n+\n+\t\tif($return_diags) {\n+\t\t\tmy $dobj;\n+\t\t\tif($currtest) {\n+\t\t\t$currtest->{diagnostics} ||= [];\n+\t\t\t\t$dobj = $currtest->{diagnostics};\n+\t\t\t} elsif($currgroup) {\n+\t\t\t\t$currgroup->{diagnostics} ||= [];\n+\t\t\t\t$dobj = $currgroup->{diagnostics};\n+\t\t\t} else {\n+\t\t\t\t$dobj = $ret{diagnostics};\n+\t\t\t}\n+\n+\t\t\tpush @$dobj, {message => $_, severity => $severity, line => $line};\n+\t\t}\n+\t} continue {\n+\t\t$line++;\n+\t}\n+\tclose LOGFILE;\n+\n+\treturn %ret;\n+}\n+\n+# Split a test into testdivs\n+sub splitTest($$) {\n+\tmy($root, $test) = @_;\n+\n+\t$test->{fullname} =~ /^(\\S+)\\s*(.*)/;\n+\tmy($path, $descriptor) = ($1, $2);\n+\tmy @nodes = split(m!/!, $path);\n+\tpush @nodes, $descriptor if $descriptor;\n+\tmy $lastnode = pop @nodes;\n+\n+\tmy $hash = $root;\n+\tforeach (@nodes) {\n+\t\t$hash->{testdiv} ||= {};\n+\t\t$hash = $hash->{testdiv}->{$_} ||= {};\n+\t}\n+\n+\n+\t$hash->{test} ||= {};\n+\t$hash->{test}->{$lastnode} = $test;\n+}\n+\n+\n+# ==== Comparison ====\n+\n+sub ispass($) {\n+\tmy $result = shift;\n+\n+\tif($result eq \"PASS\" or $result eq \"XFAIL\" or $result eq \"KFAIL\") {\n+\t\treturn 1;\n+\t} else {\n+\t\treturn 0;\n+\t}\n+}\n+\n+1;"}]}