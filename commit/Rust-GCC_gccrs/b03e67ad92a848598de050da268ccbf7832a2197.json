{"sha": "b03e67ad92a848598de050da268ccbf7832a2197", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjAzZTY3YWQ5MmE4NDg1OThkZTA1MGRhMjY4Y2NiZjc4MzJhMjE5Nw==", "commit": {"author": {"name": "Oleg Endo", "email": "olegendo@gcc.gnu.org", "date": "2015-10-02T12:30:05Z"}, "committer": {"name": "Oleg Endo", "email": "olegendo@gcc.gnu.org", "date": "2015-10-02T12:30:05Z"}, "message": "sh.md: Add new unnamed split pattern to handle movt-movt sequences.\n\ngcc/\n\t* config/sh/sh.md: Add new unnamed split pattern to handle movt-movt\n\tsequences.\n\nFrom-SVN: r228386", "tree": {"sha": "2f8f5db8aadd999a3718e851ee59d517d54c0f33", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2f8f5db8aadd999a3718e851ee59d517d54c0f33"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b03e67ad92a848598de050da268ccbf7832a2197", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b03e67ad92a848598de050da268ccbf7832a2197", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b03e67ad92a848598de050da268ccbf7832a2197", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b03e67ad92a848598de050da268ccbf7832a2197/comments", "author": null, "committer": null, "parents": [{"sha": "1d3e6ed315efea1a646ce13b57a5c1dc849d6e7e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1d3e6ed315efea1a646ce13b57a5c1dc849d6e7e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1d3e6ed315efea1a646ce13b57a5c1dc849d6e7e"}], "stats": {"total": 45, "additions": 45, "deletions": 0}, "files": [{"sha": "a84b8a9f31f5ac4031e34a58918c1e7af98732e1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b03e67ad92a848598de050da268ccbf7832a2197/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b03e67ad92a848598de050da268ccbf7832a2197/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b03e67ad92a848598de050da268ccbf7832a2197", "patch": "@@ -1,3 +1,8 @@\n+2015-10-02  Oleg Endo  <olegendo@gcc.gnu.org>\n+\n+\t* config/sh/sh.md: Add new unnamed split pattern to handle movt-movt\n+\tsequences.\n+\n 2015-10-02  Renlin Li  <renlin.li@arm.com>\n \n \tPR target/66776"}, {"sha": "3b56afb5b9eec2b24882b47be88952fc1de9dac8", "filename": "gcc/config/sh/sh.md", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b03e67ad92a848598de050da268ccbf7832a2197/gcc%2Fconfig%2Fsh%2Fsh.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b03e67ad92a848598de050da268ccbf7832a2197/gcc%2Fconfig%2Fsh%2Fsh.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.md?ref=b03e67ad92a848598de050da268ccbf7832a2197", "patch": "@@ -14860,6 +14860,46 @@ label:\n \t\t\t  gen_rtx_REG (SImode, (REGNO (operands[1])))));\n })\n \n+;; This is not a peephole, but it's here because it's actually supposed\n+;; to be one.  It tries to convert a sequence such as\n+;;\tmovt\tr2\t->\tmovt\tr2\n+;;\tmovt\tr13\t\tmov\tr2,r13\n+;; This gives the schduler a bit more freedom to hoist a following\n+;; comparison insn.  Moreover, it the reg-reg mov insn is MT group which has\n+;; better chances for parallel execution.\n+;; We can do this with a peephole2 pattern, but then the cprop_hardreg\n+;; pass will revert the change.  See also PR 64331.\n+;; Thus do it manually in one of the split passes after register allocation.\n+;; Sometimes the cprop_hardreg pass might also eliminate the reg-reg copy.\n+(define_split\n+  [(set (match_operand:SI 0 \"arith_reg_dest\")\n+\t(match_operand:SI 1 \"t_reg_operand\"))]\n+  \"TARGET_SH1 && reload_completed\"\n+  [(set (match_dup 0) (match_dup 1))]\n+{\n+  rtx t_reg = get_t_reg_rtx ();\n+\n+  for (rtx_insn* i = prev_nonnote_insn_bb (curr_insn); i != NULL;\n+       i = prev_nonnote_insn_bb (i))\n+    {\n+      if (!INSN_P (i) || DEBUG_INSN_P (i))\n+\tcontinue;\n+\n+      if (modified_in_p (t_reg, i) || BARRIER_P (i))\n+\tFAIL;\n+\n+      if (sh_is_movt_insn (i))\n+\t{\n+\t  rtx r = sh_movt_set_dest (i);\n+\t  if (!modified_between_p (r, i, curr_insn))\n+\t    {\n+\t      operands[1] = r;\n+\t      break;\n+\t   }\n+\t}\n+    }\n+})\n+\n (define_peephole\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(plus:SI (match_dup 0) (match_operand:SI 1 \"register_operand\" \"r\")))"}]}