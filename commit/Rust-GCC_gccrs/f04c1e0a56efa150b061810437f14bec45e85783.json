{"sha": "f04c1e0a56efa150b061810437f14bec45e85783", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjA0YzFlMGE1NmVmYTE1MGIwNjE4MTA0MzdmMTRiZWM0NWU4NTc4Mw==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2016-10-31T16:59:21Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2016-10-31T16:59:21Z"}, "message": "dwarf2out.h (enum dw_val_class): Add dw_val_class_const_implicit...\n\n\t* dwarf2out.h (enum dw_val_class): Add dw_val_class_const_implicit,\n\tdw_val_class_unsigned_const_implicit and dw_val_class_file_implicit.\n\t(struct dw_val_node): Add val_file_implicit field.\n\t* dwarf2out.c (dw_val_equal_p, print_dw_val, attr_checksum,\n\tattr_checksum_ordered, same_dw_val_p, size_of_die, value_format,\n\toutput_die): Handle dw_val_class_const_implicit,\n\tdw_val_class_unsigned_const_implicit and dw_val_class_file_implicit.\n\t(abbrev_die_table): Change into va_gc vec.\n\t(abbrev_die_table_allocated, abbrev_die_table_in_use,\n\tABBREV_DIE_TABLE_INCREMENT): Remove.\n\t(AT_int, AT_unsigned, AT_file): Allow dw_val_class_*_implicit.\n\t(abbrev_opt_start, abbrev_usage_count, sorted_abbrev_dies): New\n\tvariables.\n\t(build_abbrev_table): Adjust for abbrev_die_table being a va_gc vec.\n\tIf abbrev_opt_start, fill in abbrev_usage_count and abbrev_dies\n\tvectors.\n\t(die_abbrev_cmp, optimize_implicit_const, optimize_abbrev_table): New\n\tfunctions.\n\t(output_die_abbrevs): For DW_FORM_implicit_const emit sleb128 with\n\tthe implicit value.\n\t(output_abbrev_section): Adjust for abbrev_die_table being a va_gc\n\tvec.\n\t(output_comp_unit): Initialize abbrev_opt_start if emitting the main\n\tunit.  Call optimize_abbrev_table.\n\t(dwarf2out_init, dwarf2out_finish, dwarf2out_c_finalize): Adjust for\n\tabbrev_die_table being a va_gc vec.\n\nFrom-SVN: r241709", "tree": {"sha": "6132fbd6a6a647ca735694e54de0441975b78155", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6132fbd6a6a647ca735694e54de0441975b78155"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f04c1e0a56efa150b061810437f14bec45e85783", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f04c1e0a56efa150b061810437f14bec45e85783", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f04c1e0a56efa150b061810437f14bec45e85783", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f04c1e0a56efa150b061810437f14bec45e85783/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "aee69156daee2e9ca8e9f80ecd1c5b8c808946f5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aee69156daee2e9ca8e9f80ecd1c5b8c808946f5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aee69156daee2e9ca8e9f80ecd1c5b8c808946f5"}], "stats": {"total": 351, "additions": 304, "deletions": 47}, "files": [{"sha": "e3347c00cee570a50b20d91f2506a7fad3ab2dfb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f04c1e0a56efa150b061810437f14bec45e85783/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f04c1e0a56efa150b061810437f14bec45e85783/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f04c1e0a56efa150b061810437f14bec45e85783", "patch": "@@ -1,5 +1,32 @@\n 2016-10-31  Jakub Jelinek  <jakub@redhat.com>\n \n+\t* dwarf2out.h (enum dw_val_class): Add dw_val_class_const_implicit,\n+\tdw_val_class_unsigned_const_implicit and dw_val_class_file_implicit.\n+\t(struct dw_val_node): Add val_file_implicit field.\n+\t* dwarf2out.c (dw_val_equal_p, print_dw_val, attr_checksum,\n+\tattr_checksum_ordered, same_dw_val_p, size_of_die, value_format,\n+\toutput_die): Handle dw_val_class_const_implicit,\n+\tdw_val_class_unsigned_const_implicit and dw_val_class_file_implicit.\n+\t(abbrev_die_table): Change into va_gc vec.\n+\t(abbrev_die_table_allocated, abbrev_die_table_in_use,\n+\tABBREV_DIE_TABLE_INCREMENT): Remove.\n+\t(AT_int, AT_unsigned, AT_file): Allow dw_val_class_*_implicit.\n+\t(abbrev_opt_start, abbrev_usage_count, sorted_abbrev_dies): New\n+\tvariables.\n+\t(build_abbrev_table): Adjust for abbrev_die_table being a va_gc vec.\n+\tIf abbrev_opt_start, fill in abbrev_usage_count and abbrev_dies\n+\tvectors.\n+\t(die_abbrev_cmp, optimize_implicit_const, optimize_abbrev_table): New\n+\tfunctions.\n+\t(output_die_abbrevs): For DW_FORM_implicit_const emit sleb128 with\n+\tthe implicit value.\n+\t(output_abbrev_section): Adjust for abbrev_die_table being a va_gc\n+\tvec.\n+\t(output_comp_unit): Initialize abbrev_opt_start if emitting the main\n+\tunit.  Call optimize_abbrev_table.\n+\t(dwarf2out_init, dwarf2out_finish, dwarf2out_c_finalize): Adjust for\n+\tabbrev_die_table being a va_gc vec.\n+\n \tPR tree-optimization/77860\n \t* tree-ssa-reassoc.c (eliminate_using_constants): Handle\n \talso integral complex and vector constants."}, {"sha": "60e22742fef6e8d088ca0cc246b858045dd2089e", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 269, "deletions": 45, "changes": 314, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f04c1e0a56efa150b061810437f14bec45e85783/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f04c1e0a56efa150b061810437f14bec45e85783/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=f04c1e0a56efa150b061810437f14bec45e85783", "patch": "@@ -1363,6 +1363,8 @@ dw_val_equal_p (dw_val_node *a, dw_val_node *b)\n     case dw_val_class_offset:\n     case dw_val_class_unsigned_const:\n     case dw_val_class_const:\n+    case dw_val_class_unsigned_const_implicit:\n+    case dw_val_class_const_implicit:\n     case dw_val_class_range_list:\n     case dw_val_class_lineptr:\n     case dw_val_class_macptr:\n@@ -1385,6 +1387,7 @@ dw_val_equal_p (dw_val_node *a, dw_val_node *b)\n     case dw_val_class_flag:\n       return a->v.val_flag == b->v.val_flag;\n     case dw_val_class_file:\n+    case dw_val_class_file_implicit:\n       return a->v.val_file == b->v.val_file;\n     case dw_val_class_decl_ref:\n       return a->v.val_decl_ref == b->v.val_decl_ref;\n@@ -3006,28 +3009,16 @@ struct dw_loc_list_hasher : ggc_ptr_hash<cached_dw_loc_list>\n /* Table of cached location lists.  */\n static GTY (()) hash_table<dw_loc_list_hasher> *cached_dw_loc_list_table;\n \n-/* A pointer to the base of a list of references to DIE's that\n-   are uniquely identified by their tag, presence/absence of\n-   children DIE's, and list of attribute/value pairs.  */\n-static GTY((length (\"abbrev_die_table_allocated\")))\n-  dw_die_ref *abbrev_die_table;\n-\n-/* Number of elements currently allocated for abbrev_die_table.  */\n-static GTY(()) unsigned abbrev_die_table_allocated;\n-\n-/* Number of elements in abbrev_die_table currently in use.  */\n-static GTY(()) unsigned abbrev_die_table_in_use;\n+/* A vector of references to DIE's that are uniquely identified by their tag,\n+   presence/absence of children DIE's, and list of attribute/value pairs.  */\n+static GTY(()) vec<dw_die_ref, va_gc> *abbrev_die_table;\n \n /* A hash map to remember the stack usage for DWARF procedures.  The value\n    stored is the stack size difference between before the DWARF procedure\n    invokation and after it returned.  In other words, for a DWARF procedure\n    that consumes N stack slots and that pushes M ones, this stores M - N.  */\n static hash_map<dw_die_ref, int> *dwarf_proc_stack_usage_map;\n \n-/* Size (in elements) of increments by which we may expand the\n-   abbrev_die_table.  */\n-#define ABBREV_DIE_TABLE_INCREMENT 256\n-\n /* A global counter for generating labels for line number data.  */\n static unsigned int line_info_label_num;\n \n@@ -3905,7 +3896,8 @@ add_AT_int (dw_die_ref die, enum dwarf_attribute attr_kind, HOST_WIDE_INT int_va\n static inline HOST_WIDE_INT\n AT_int (dw_attr_node *a)\n {\n-  gcc_assert (a && AT_class (a) == dw_val_class_const);\n+  gcc_assert (a && (AT_class (a) == dw_val_class_const\n+\t\t    || AT_class (a) == dw_val_class_const_implicit));\n   return a->dw_attr_val.v.val_int;\n }\n \n@@ -3927,7 +3919,8 @@ add_AT_unsigned (dw_die_ref die, enum dwarf_attribute attr_kind,\n static inline unsigned HOST_WIDE_INT\n AT_unsigned (dw_attr_node *a)\n {\n-  gcc_assert (a && AT_class (a) == dw_val_class_unsigned_const);\n+  gcc_assert (a && (AT_class (a) == dw_val_class_unsigned_const\n+\t\t    || AT_class (a) == dw_val_class_unsigned_const_implicit));\n   return a->dw_attr_val.v.val_unsigned;\n }\n \n@@ -4506,7 +4499,8 @@ add_AT_file (dw_die_ref die, enum dwarf_attribute attr_kind,\n static inline struct dwarf_file_data *\n AT_file (dw_attr_node *a)\n {\n-  gcc_assert (a && AT_class (a) == dw_val_class_file);\n+  gcc_assert (a && (AT_class (a) == dw_val_class_file\n+\t\t    || AT_class (a) == dw_val_class_file_implicit));\n   return a->dw_attr_val.v.val_file;\n }\n \n@@ -5581,9 +5575,11 @@ print_dw_val (dw_val_node *val, bool recurse, FILE *outfile)\n       fprintf (outfile, \"range list\");\n       break;\n     case dw_val_class_const:\n+    case dw_val_class_const_implicit:\n       fprintf (outfile, HOST_WIDE_INT_PRINT_DEC, val->v.val_int);\n       break;\n     case dw_val_class_unsigned_const:\n+    case dw_val_class_unsigned_const_implicit:\n       fprintf (outfile, HOST_WIDE_INT_PRINT_UNSIGNED, val->v.val_unsigned);\n       break;\n     case dw_val_class_const_double:\n@@ -5650,6 +5646,7 @@ print_dw_val (dw_val_node *val, bool recurse, FILE *outfile)\n \tfprintf (outfile, \"<null>\");\n       break;\n     case dw_val_class_file:\n+    case dw_val_class_file_implicit:\n       fprintf (outfile, \"\\\"%s\\\" (%d)\", val->v.val_file->filename,\n \t       val->v.val_file->emitted_number);\n       break;\n@@ -5979,9 +5976,11 @@ attr_checksum (dw_attr_node *at, struct md5_ctx *ctx, int *mark)\n   switch (AT_class (at))\n     {\n     case dw_val_class_const:\n+    case dw_val_class_const_implicit:\n       CHECKSUM (at->dw_attr_val.v.val_int);\n       break;\n     case dw_val_class_unsigned_const:\n+    case dw_val_class_unsigned_const_implicit:\n       CHECKSUM (at->dw_attr_val.v.val_unsigned);\n       break;\n     case dw_val_class_const_double:\n@@ -6032,6 +6031,7 @@ attr_checksum (dw_attr_node *at, struct md5_ctx *ctx, int *mark)\n       break;\n \n     case dw_val_class_file:\n+    case dw_val_class_file_implicit:\n       CHECKSUM_STRING (AT_file (at)->filename);\n       break;\n \n@@ -6256,11 +6256,13 @@ attr_checksum_ordered (enum dwarf_tag tag, dw_attr_node *at,\n   switch (AT_class (at))\n     {\n     case dw_val_class_const:\n+    case dw_val_class_const_implicit:\n       CHECKSUM_ULEB128 (DW_FORM_sdata);\n       CHECKSUM_SLEB128 (at->dw_attr_val.v.val_int);\n       break;\n \n     case dw_val_class_unsigned_const:\n+    case dw_val_class_unsigned_const_implicit:\n       CHECKSUM_ULEB128 (DW_FORM_sdata);\n       CHECKSUM_SLEB128 ((int) at->dw_attr_val.v.val_unsigned);\n       break;\n@@ -6324,6 +6326,7 @@ attr_checksum_ordered (enum dwarf_tag tag, dw_attr_node *at,\n       break;\n \n     case dw_val_class_file:\n+    case dw_val_class_file_implicit:\n       CHECKSUM_ULEB128 (DW_FORM_string);\n       CHECKSUM_STRING (AT_file (at)->filename);\n       break;\n@@ -6766,8 +6769,10 @@ same_dw_val_p (const dw_val_node *v1, const dw_val_node *v2, int *mark)\n   switch (v1->val_class)\n     {\n     case dw_val_class_const:\n+    case dw_val_class_const_implicit:\n       return v1->v.val_int == v2->v.val_int;\n     case dw_val_class_unsigned_const:\n+    case dw_val_class_unsigned_const_implicit:\n       return v1->v.val_unsigned == v2->v.val_unsigned;\n     case dw_val_class_const_double:\n       return v1->v.val_double.high == v2->v.val_double.high\n@@ -6817,6 +6822,7 @@ same_dw_val_p (const dw_val_node *v1, const dw_val_node *v2, int *mark)\n       return 1;\n \n     case dw_val_class_file:\n+    case dw_val_class_file_implicit:\n       return v1->v.val_file == v2->v.val_file;\n \n     case dw_val_class_data8:\n@@ -8252,6 +8258,20 @@ optimize_external_refs (dw_die_ref die)\n   return map;\n }\n \n+/* The following 3 variables are temporaries that are computed only during the\n+   build_abbrev_table call and used and released during the following\n+   optimize_abbrev_table call.  */\n+\n+/* First abbrev_id that can be optimized based on usage.  */\n+static unsigned int abbrev_opt_start;\n+\n+/* Vector of usage counts during build_abbrev_table.  Indexed by\n+   abbrev_id - abbrev_opt_start.  */\n+static vec<unsigned int> abbrev_usage_count;\n+\n+/* Vector of all DIEs added with die_abbrev >= abbrev_opt_start.  */\n+static vec<dw_die_ref> sorted_abbrev_dies;\n+\n /* The format of each DIE (and its attribute value pairs) is encoded in an\n    abbreviation table.  This routine builds the abbreviation table and assigns\n    a unique abbreviation id for each abbreviation entry.  The children of each\n@@ -8260,11 +8280,11 @@ optimize_external_refs (dw_die_ref die)\n static void\n build_abbrev_table (dw_die_ref die, external_ref_hash_type *extern_map)\n {\n-  unsigned long abbrev_id;\n-  unsigned int n_alloc;\n+  unsigned int abbrev_id = 0;\n   dw_die_ref c;\n   dw_attr_node *a;\n   unsigned ix;\n+  dw_die_ref abbrev;\n \n   /* Scan the DIE references, and replace any that refer to\n      DIEs from other CUs (i.e. those which are not marked) with\n@@ -8284,13 +8304,14 @@ build_abbrev_table (dw_die_ref die, external_ref_hash_type *extern_map)\n \t  set_AT_ref_external (a, 1);\n       }\n \n-  for (abbrev_id = 1; abbrev_id < abbrev_die_table_in_use; ++abbrev_id)\n+  FOR_EACH_VEC_SAFE_ELT (abbrev_die_table, abbrev_id, abbrev)\n     {\n-      dw_die_ref abbrev = abbrev_die_table[abbrev_id];\n       dw_attr_node *die_a, *abbrev_a;\n       unsigned ix;\n       bool ok = true;\n \n+      if (abbrev_id == 0)\n+\tcontinue;\n       if (abbrev->die_tag != die->die_tag)\n \tcontinue;\n       if ((abbrev->die_child != NULL) != (die->die_child != NULL))\n@@ -8313,25 +8334,179 @@ build_abbrev_table (dw_die_ref die, external_ref_hash_type *extern_map)\n \tbreak;\n     }\n \n-  if (abbrev_id >= abbrev_die_table_in_use)\n+  if (abbrev_id >= vec_safe_length (abbrev_die_table))\n+    {\n+      vec_safe_push (abbrev_die_table, die);\n+      if (abbrev_opt_start)\n+\tabbrev_usage_count.safe_push (0);\n+    }\n+  if (abbrev_opt_start && abbrev_id >= abbrev_opt_start)\n+    {\n+      abbrev_usage_count[abbrev_id - abbrev_opt_start]++;\n+      sorted_abbrev_dies.safe_push (die);\n+    }\n+\n+  die->die_abbrev = abbrev_id;\n+  FOR_EACH_CHILD (die, c, build_abbrev_table (c, extern_map));\n+}\n+\n+/* Callback function for sorted_abbrev_dies vector sorting.  We sort\n+   by die_abbrev's usage count, from the most commonly used\n+   abbreviation to the least.  */\n+\n+static int\n+die_abbrev_cmp (const void *p1, const void *p2)\n+{\n+  dw_die_ref die1 = *(const dw_die_ref *) p1;\n+  dw_die_ref die2 = *(const dw_die_ref *) p2;\n+\n+  gcc_checking_assert (die1->die_abbrev >= abbrev_opt_start);\n+  gcc_checking_assert (die2->die_abbrev >= abbrev_opt_start);\n+\n+  if (abbrev_usage_count[die1->die_abbrev - abbrev_opt_start]\n+      > abbrev_usage_count[die2->die_abbrev - abbrev_opt_start])\n+    return -1;\n+  if (abbrev_usage_count[die1->die_abbrev - abbrev_opt_start]\n+      < abbrev_usage_count[die2->die_abbrev - abbrev_opt_start])\n+    return 1;\n+\n+  /* Stabilize the sort.  */\n+  if (die1->die_abbrev < die2->die_abbrev)\n+    return -1;\n+  if (die1->die_abbrev > die2->die_abbrev)\n+    return 1;\n+\n+  return 0;\n+}\n+\n+/* Convert dw_val_class_const and dw_val_class_unsigned_const class attributes\n+   of DIEs in between sorted_abbrev_dies[first_id] and abbrev_dies[end_id - 1]\n+   into dw_val_class_const_implicit or\n+   dw_val_class_unsigned_const_implicit.  */\n+\n+static void\n+optimize_implicit_const (unsigned int first_id, unsigned int end,\n+\t\t\t vec<bool> &implicit_consts)\n+{\n+  /* It never makes sense if there is just one DIE using the abbreviation.  */\n+  if (end < first_id + 2)\n+    return;\n+\n+  dw_attr_node *a;\n+  unsigned ix, i;\n+  dw_die_ref die = sorted_abbrev_dies[first_id];\n+  FOR_EACH_VEC_SAFE_ELT (die->die_attr, ix, a)\n+    if (implicit_consts[ix])\n+      {\n+\tenum dw_val_class new_class = dw_val_class_none;\n+\tswitch (AT_class (a))\n+\t  {\n+\t  case dw_val_class_unsigned_const:\n+\t    if ((HOST_WIDE_INT) AT_unsigned (a) < 0)\n+\t      continue;\n+\n+\t    /* The .debug_abbrev section will grow by\n+\t       size_of_sleb128 (AT_unsigned (a)) and we avoid the constants\n+\t       in all the DIEs using that abbreviation.  */\n+\t    if (constant_size (AT_unsigned (a)) * (end - first_id)\n+\t\t<= (unsigned) size_of_sleb128 (AT_unsigned (a)))\n+\t      continue;\n+\n+\t    new_class = dw_val_class_unsigned_const_implicit;\n+\t    break;\n+\n+\t  case dw_val_class_const:\n+\t    new_class = dw_val_class_const_implicit;\n+\t    break;\n+\n+\t  case dw_val_class_file:\n+\t    new_class = dw_val_class_file_implicit;\n+\t    break;\n+\n+\t  default:\n+\t    continue;\n+\t  }\n+\tfor (i = first_id; i < end; i++)\n+\t  (*sorted_abbrev_dies[i]->die_attr)[ix].dw_attr_val.val_class\n+\t    = new_class;\n+      }\n+}\n+\n+/* Attempt to optimize abbreviation table from abbrev_opt_start\n+   abbreviation above.  */\n+\n+static void\n+optimize_abbrev_table (void)\n+{\n+  if (abbrev_opt_start\n+      && vec_safe_length (abbrev_die_table) > abbrev_opt_start\n+      && (dwarf_version >= 5 || vec_safe_length (abbrev_die_table) > 127))\n     {\n-      if (abbrev_die_table_in_use >= abbrev_die_table_allocated)\n+      auto_vec<bool, 32> implicit_consts;\n+      sorted_abbrev_dies.qsort (die_abbrev_cmp);\n+\n+      unsigned int abbrev_id = abbrev_opt_start - 1;\n+      unsigned int first_id = 0;\n+      unsigned int last_abbrev_id = 0;\n+      unsigned int i;\n+      dw_die_ref die;\n+      /* Reassign abbreviation ids from abbrev_opt_start above, so that\n+\t most commonly used abbreviations come first.  */\n+      FOR_EACH_VEC_ELT (sorted_abbrev_dies, i, die)\n \t{\n-\t  n_alloc = abbrev_die_table_allocated + ABBREV_DIE_TABLE_INCREMENT;\n-\t  abbrev_die_table = GGC_RESIZEVEC (dw_die_ref, abbrev_die_table,\n-\t\t\t\t\t    n_alloc);\n+\t  dw_attr_node *a;\n+\t  unsigned ix;\n \n-\t  memset (&abbrev_die_table[abbrev_die_table_allocated], 0,\n-\t\t (n_alloc - abbrev_die_table_allocated) * sizeof (dw_die_ref));\n-\t  abbrev_die_table_allocated = n_alloc;\n-\t}\n+\t  if (die->die_abbrev != last_abbrev_id)\n+\t    {\n+\t      last_abbrev_id = die->die_abbrev;\n+\t      if (dwarf_version >= 5 && i)\n+\t\toptimize_implicit_const (first_id, i, implicit_consts);\n+\t      abbrev_id++;\n+\t      (*abbrev_die_table)[abbrev_id] = die;\n+\t      if (dwarf_version >= 5)\n+\t\t{\n+\t\t  first_id = i;\n+\t\t  implicit_consts.truncate (0);\n \n-      ++abbrev_die_table_in_use;\n-      abbrev_die_table[abbrev_id] = die;\n+\t\t  FOR_EACH_VEC_SAFE_ELT (die->die_attr, ix, a)\n+\t\t    switch (AT_class (a))\n+\t\t      {\n+\t\t      case dw_val_class_const:\n+\t\t      case dw_val_class_unsigned_const:\n+\t\t      case dw_val_class_file:\n+\t\t\timplicit_consts.safe_push (true);\n+\t\t\tbreak;\n+\t\t      default:\n+\t\t\timplicit_consts.safe_push (false);\n+\t\t\tbreak;\n+\t\t      }\n+\t\t}\n+\t    }\n+\t  else if (dwarf_version >= 5)\n+\t    {\n+\t      FOR_EACH_VEC_SAFE_ELT (die->die_attr, ix, a)\n+\t\tif (!implicit_consts[ix])\n+\t\t  continue;\n+\t\telse\n+\t\t  {\n+\t\t    dw_attr_node *other_a\n+\t\t      = &(*(*abbrev_die_table)[abbrev_id]->die_attr)[ix];\n+\t\t    if (!dw_val_equal_p (&a->dw_attr_val,\n+\t\t\t\t\t &other_a->dw_attr_val))\n+\t\t      implicit_consts[ix] = false;\n+\t\t  }\n+\t    }\n+\t  die->die_abbrev = abbrev_id;\n+\t}\n+      gcc_assert (abbrev_id == vec_safe_length (abbrev_die_table) - 1);\n+      if (dwarf_version >= 5)\n+\toptimize_implicit_const (first_id, i, implicit_consts);\n     }\n \n-  die->die_abbrev = abbrev_id;\n-  FOR_EACH_CHILD (die, c, build_abbrev_table (c, extern_map));\n+  abbrev_opt_start = 0;\n+  abbrev_usage_count.release ();\n+  sorted_abbrev_dies.release ();\n }\n \f\n /* Return the power-of-two number of bytes necessary to represent VALUE.  */\n@@ -8418,6 +8593,12 @@ size_of_die (dw_die_ref die)\n \t      size += csize;\n \t  }\n \t  break;\n+\tcase dw_val_class_const_implicit:\n+\tcase dw_val_class_unsigned_const_implicit:\n+\tcase dw_val_class_file_implicit:\n+\t  /* These occupy no size in the DIE, just an extra sleb128 in\n+\t     .debug_abbrev.  */\n+\t  break;\n \tcase dw_val_class_const_double:\n \t  size += HOST_BITS_PER_DOUBLE_INT / HOST_BITS_PER_CHAR;\n \t  if (HOST_BITS_PER_WIDE_INT >= 64)\n@@ -8798,6 +8979,10 @@ value_format (dw_attr_node *a)\n \tdefault:\n \t  gcc_unreachable ();\n \t}\n+    case dw_val_class_const_implicit:\n+    case dw_val_class_unsigned_const_implicit:\n+    case dw_val_class_file_implicit:\n+      return DW_FORM_implicit_const;\n     case dw_val_class_const_double:\n       switch (HOST_BITS_PER_WIDE_INT)\n \t{\n@@ -8951,6 +9136,17 @@ output_die_abbrevs (unsigned long abbrev_id, dw_die_ref abbrev)\n       dw2_asm_output_data_uleb128 (a_attr->dw_attr, \"(%s)\",\n                                    dwarf_attr_name (a_attr->dw_attr));\n       output_value_format (a_attr);\n+      if (value_format (a_attr) == DW_FORM_implicit_const)\n+\t{\n+\t  if (AT_class (a_attr) == dw_val_class_file_implicit)\n+\t    {\n+\t      int f = maybe_emit_file (a_attr->dw_attr_val.v.val_file);\n+\t      const char *filename = a_attr->dw_attr_val.v.val_file->filename;\n+\t      dw2_asm_output_data_sleb128 (f, \"(%s)\", filename);\n+\t    }\n+\t  else\n+\t    dw2_asm_output_data_sleb128 (a_attr->dw_attr_val.v.val_int, NULL);\n+\t}\n     }\n \n   dw2_asm_output_data (1, 0, NULL);\n@@ -8964,10 +9160,12 @@ output_die_abbrevs (unsigned long abbrev_id, dw_die_ref abbrev)\n static void\n output_abbrev_section (void)\n {\n-  unsigned long abbrev_id;\n+  unsigned int abbrev_id;\n+  dw_die_ref abbrev;\n \n-  for (abbrev_id = 1; abbrev_id < abbrev_die_table_in_use; ++abbrev_id)\n-    output_die_abbrevs (abbrev_id, abbrev_die_table[abbrev_id]);\n+  FOR_EACH_VEC_SAFE_ELT (abbrev_die_table, abbrev_id, abbrev)\n+    if (abbrev_id != 0)\n+      output_die_abbrevs (abbrev_id, abbrev);\n \n   /* Terminate the table.  */\n   dw2_asm_output_data (1, 0, NULL);\n@@ -9264,6 +9462,20 @@ output_die (dw_die_ref die)\n \t  }\n \t  break;\n \n+\tcase dw_val_class_const_implicit:\n+\t  if (flag_debug_asm)\n+\t    fprintf (asm_out_file, \"\\t\\t\\t%s %s (\"\n+\t\t\t\t   HOST_WIDE_INT_PRINT_DEC \")\\n\",\n+\t\t     ASM_COMMENT_START, name, AT_int (a));\n+\t  break;\n+\n+\tcase dw_val_class_unsigned_const_implicit:\n+\t  if (flag_debug_asm)\n+\t    fprintf (asm_out_file, \"\\t\\t\\t%s %s (\"\n+\t\t\t\t   HOST_WIDE_INT_PRINT_HEX \")\\n\",\n+\t\t     ASM_COMMENT_START, name, AT_unsigned (a));\n+\t  break;\n+\n \tcase dw_val_class_const_double:\n \t  {\n \t    unsigned HOST_WIDE_INT first, second;\n@@ -9457,6 +9669,14 @@ output_die (dw_die_ref die)\n \t    break;\n \t  }\n \n+\tcase dw_val_class_file_implicit:\n+\t  if (flag_debug_asm)\n+\t    fprintf (asm_out_file, \"\\t\\t\\t%s %s (%d, %s)\\n\",\n+\t\t     ASM_COMMENT_START, name,\n+\t\t     maybe_emit_file (a->dw_attr_val.v.val_file),\n+\t\t     a->dw_attr_val.v.val_file->filename);\n+\t  break;\n+\n \tcase dw_val_class_data8:\n \t  {\n \t    int i;\n@@ -9564,8 +9784,16 @@ output_comp_unit (dw_die_ref die, int output_if_empty)\n \n   external_ref_hash_type *extern_map = optimize_external_refs (die);\n \n+  /* For now, optimize only the main CU, in order to optimize the rest\n+     we'd need to see all of them earlier.  Leave the rest for post-linking\n+     tools like DWZ.  */\n+  if (die == comp_unit_die ())\n+    abbrev_opt_start = vec_safe_length (abbrev_die_table);\n+\n   build_abbrev_table (die, extern_map);\n \n+  optimize_abbrev_table ();\n+\n   delete extern_map;\n \n   /* Initialize the beginning DIE offset - and calculate sizes/offsets.  */\n@@ -25720,11 +25948,9 @@ dwarf2out_init (const char *filename ATTRIBUTE_UNUSED)\n   vec_alloc (decl_scope_table, 256);\n \n   /* Allocate the initial hunk of the abbrev_die_table.  */\n-  abbrev_die_table = ggc_cleared_vec_alloc<dw_die_ref>\n-    (ABBREV_DIE_TABLE_INCREMENT);\n-  abbrev_die_table_allocated = ABBREV_DIE_TABLE_INCREMENT;\n+  vec_alloc (abbrev_die_table, 256);\n   /* Zero-th entry is allocated, but unused.  */\n-  abbrev_die_table_in_use = 1;\n+  abbrev_die_table->quick_push (NULL);\n \n   /* Allocate the dwarf_proc_stack_usage_map.  */\n   dwarf_proc_stack_usage_map = new hash_map<dw_die_ref, int>;\n@@ -28111,7 +28337,7 @@ dwarf2out_finish (const char *)\n     output_skeleton_debug_sections (main_comp_unit_die);\n \n   /* Output the abbreviation table.  */\n-  if (abbrev_die_table_in_use != 1)\n+  if (vec_safe_length (abbrev_die_table) != 1)\n     {\n       switch_to_section (debug_abbrev_section);\n       ASM_OUTPUT_LABEL (asm_out_file, abbrev_section_label);\n@@ -28334,8 +28560,6 @@ dwarf2out_c_finalize (void)\n   tail_call_site_count = -1;\n   cached_dw_loc_list_table = NULL;\n   abbrev_die_table = NULL;\n-  abbrev_die_table_allocated = 0;\n-  abbrev_die_table_in_use = 0;\n   delete dwarf_proc_stack_usage_map;\n   dwarf_proc_stack_usage_map = NULL;\n   line_info_label_num = 0;"}, {"sha": "a0e881a9eeee39145658e95cf0b11ab73d0b7914", "filename": "gcc/dwarf2out.h", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f04c1e0a56efa150b061810437f14bec45e85783/gcc%2Fdwarf2out.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f04c1e0a56efa150b061810437f14bec45e85783/gcc%2Fdwarf2out.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.h?ref=f04c1e0a56efa150b061810437f14bec45e85783", "patch": "@@ -153,7 +153,10 @@ enum dw_val_class\n   dw_val_class_vms_delta,\n   dw_val_class_high_pc,\n   dw_val_class_discr_value,\n-  dw_val_class_discr_list\n+  dw_val_class_discr_list,\n+  dw_val_class_const_implicit,\n+  dw_val_class_unsigned_const_implicit,\n+  dw_val_class_file_implicit\n };\n \n /* Describe a floating point constant value, or a vector constant value.  */\n@@ -198,7 +201,8 @@ struct GTY(()) dw_val_node {\n       dw_loc_list_ref GTY ((tag (\"dw_val_class_loc_list\"))) val_loc_list;\n       dw_loc_descr_ref GTY ((tag (\"dw_val_class_loc\"))) val_loc;\n       HOST_WIDE_INT GTY ((default)) val_int;\n-      unsigned HOST_WIDE_INT GTY ((tag (\"dw_val_class_unsigned_const\"))) val_unsigned;\n+      unsigned HOST_WIDE_INT\n+\tGTY ((tag (\"dw_val_class_unsigned_const\"))) val_unsigned;\n       double_int GTY ((tag (\"dw_val_class_const_double\"))) val_double;\n       wide_int_ptr GTY ((tag (\"dw_val_class_wide_int\"))) val_wide;\n       dw_vec_const GTY ((tag (\"dw_val_class_vec\"))) val_vec;\n@@ -212,6 +216,8 @@ struct GTY(()) dw_val_node {\n       char * GTY ((tag (\"dw_val_class_lbl_id\"))) val_lbl_id;\n       unsigned char GTY ((tag (\"dw_val_class_flag\"))) val_flag;\n       struct dwarf_file_data * GTY ((tag (\"dw_val_class_file\"))) val_file;\n+      struct dwarf_file_data *\n+\tGTY ((tag (\"dw_val_class_file_implicit\"))) val_file_implicit;\n       unsigned char GTY ((tag (\"dw_val_class_data8\"))) val_data8[8];\n       tree GTY ((tag (\"dw_val_class_decl_ref\"))) val_decl_ref;\n       struct dw_val_vms_delta_union"}]}