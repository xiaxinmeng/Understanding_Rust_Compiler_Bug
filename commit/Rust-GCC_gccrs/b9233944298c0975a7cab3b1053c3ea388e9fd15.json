{"sha": "b9233944298c0975a7cab3b1053c3ea388e9fd15", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjkyMzM5NDQyOThjMDk3NWE3Y2FiM2IxMDUzYzNlYTM4OGU5ZmQxNQ==", "commit": {"author": {"name": "Janne Blomqvist", "email": "jb@gcc.gnu.org", "date": "2016-10-09T18:05:56Z"}, "committer": {"name": "Janne Blomqvist", "email": "jb@gcc.gnu.org", "date": "2016-10-09T18:05:56Z"}, "message": "PR 67585 Handle EINTR\n\nMany POSIX systems have the bad habit of not restarting interrupted\nsyscalls. On these systems it's up to the user to check for an error\nwith errno == EINTR and restart manually. This patch does this for\nlibgfortran, so that GFortran users don't have to do it.\n\n2016-10-09  Janne Blomqvist  <jb@gcc.gnu.org>\n\n        PR libfortran/67585\n        * io/io.h: TEMP_FAILURE_RETRY: Define macro if not found.\n        * io/unix.c (raw_read): Handle EINTR.\n        (raw_write): Check for return value -1.\n        (raw_seek): Handle EINTR.\n        (raw_tell): Likewise.\n        (raw_size): Likewise.\n        (raw_truncate): Likewise.\n        (raw_close): Likewise.\n        (buf_flush): Call raw_seek instead of lseek.\n        (buf_read): Likewise.\n        (buf_write): Likewise.\n        (fd_to_stream): Handle EINTR.\n        (tempfile_open): Likewise.\n        (regular_file2): Likewise.\n        (compare_file_filename): Likewise.\n        (find_file): Likewise.\n        (inquire_sequential): Likewise.\n        (inquire_direct): Likewise.\n        (inquire_formatted): Likewise.\n\nFrom-SVN: r240902", "tree": {"sha": "c793adb9e84177e3ddeb8a327cecd0543a6f697f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c793adb9e84177e3ddeb8a327cecd0543a6f697f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b9233944298c0975a7cab3b1053c3ea388e9fd15", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b9233944298c0975a7cab3b1053c3ea388e9fd15", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b9233944298c0975a7cab3b1053c3ea388e9fd15", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b9233944298c0975a7cab3b1053c3ea388e9fd15/comments", "author": null, "committer": null, "parents": [{"sha": "df74f099d381013b4f52a32654f9a97c5bd39327", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df74f099d381013b4f52a32654f9a97c5bd39327", "html_url": "https://github.com/Rust-GCC/gccrs/commit/df74f099d381013b4f52a32654f9a97c5bd39327"}], "stats": {"total": 124, "additions": 98, "deletions": 26}, "files": [{"sha": "62b5222609014ef825402717ed7769e38ae3380f", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9233944298c0975a7cab3b1053c3ea388e9fd15/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9233944298c0975a7cab3b1053c3ea388e9fd15/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=b9233944298c0975a7cab3b1053c3ea388e9fd15", "patch": "@@ -1,3 +1,26 @@\n+2016-10-09  Janne Blomqvist  <jb@gcc.gnu.org>\n+\n+        PR libfortran/67585\n+        * io/io.h: TEMP_FAILURE_RETRY: Define macro if not found.\n+        * io/unix.c (raw_read): Handle EINTR.\n+        (raw_write): Check for return value -1.\n+        (raw_seek): Handle EINTR.\n+        (raw_tell): Likewise.\n+        (raw_size): Likewise.\n+        (raw_truncate): Likewise.\n+        (raw_close): Likewise.\n+        (buf_flush): Call raw_seek instead of lseek.\n+        (buf_read): Likewise.\n+        (buf_write): Likewise.\n+        (fd_to_stream): Handle EINTR.\n+        (tempfile_open): Likewise.\n+        (regular_file2): Likewise.\n+        (compare_file_filename): Likewise.\n+        (find_file): Likewise.\n+        (inquire_sequential): Likewise.\n+        (inquire_direct): Likewise.\n+        (inquire_formatted): Likewise.\n+\n 2016-10-05  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n \n \tPR fortran/77868"}, {"sha": "ea93fbaf99d5561cc1185671f4f319d2d8d7448c", "filename": "libgfortran/io/io.h", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9233944298c0975a7cab3b1053c3ea388e9fd15/libgfortran%2Fio%2Fio.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9233944298c0975a7cab3b1053c3ea388e9fd15/libgfortran%2Fio%2Fio.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fio.h?ref=b9233944298c0975a7cab3b1053c3ea388e9fd15", "patch": "@@ -660,6 +660,21 @@ typedef struct gfc_saved_unit\n }\n gfc_saved_unit;\n \n+/* TEMP_FAILURE_RETRY macro from glibc.  */\n+\n+#ifndef TEMP_FAILURE_RETRY\n+/* Evaluate EXPRESSION, and repeat as long as it returns -1 with `errno'\n+   set to EINTR.  */\n+\n+# define TEMP_FAILURE_RETRY(expression) \\\n+  (__extension__                                                              \\\n+    ({ long int __result;                                                     \\\n+       do __result = (long int) (expression);                                 \\\n+       while (__result == -1L && errno == EINTR);                             \\\n+       __result; }))\n+#endif\n+\n+\n /* unit.c */\n \n /* Maximum file offset, computed at library initialization time.  */"}, {"sha": "1e84c42dd3a39c37536a04e10340bb4b29a7ace1", "filename": "libgfortran/io/unix.c", "status": "modified", "additions": 60, "deletions": 26, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9233944298c0975a7cab3b1053c3ea388e9fd15/libgfortran%2Fio%2Funix.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9233944298c0975a7cab3b1053c3ea388e9fd15/libgfortran%2Fio%2Funix.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Funix.c?ref=b9233944298c0975a7cab3b1053c3ea388e9fd15", "patch": "@@ -298,8 +298,15 @@ static ssize_t\n raw_read (unix_stream * s, void * buf, ssize_t nbyte)\n {\n   /* For read we can't do I/O in a loop like raw_write does, because\n-     that will break applications that wait for interactive I/O.  */\n-  return read (s->fd, buf, nbyte);\n+     that will break applications that wait for interactive I/O.  We\n+     still can loop around EINTR, though.  */\n+  while (true)\n+    {\n+      ssize_t trans = read (s->fd, buf, nbyte);\n+      if (trans == -1 && errno == EINTR)\n+\tcontinue;\n+      return trans;\n+    }\n }\n \n static ssize_t\n@@ -316,7 +323,7 @@ raw_write (unix_stream * s, const void * buf, ssize_t nbyte)\n   while (bytes_left > 0)\n     {\n       trans = write (s->fd, buf_st, bytes_left);\n-      if (trans < 0)\n+      if (trans == -1)\n \t{\n \t  if (errno == EINTR)\n \t    continue;\n@@ -333,22 +340,33 @@ raw_write (unix_stream * s, const void * buf, ssize_t nbyte)\n static gfc_offset\n raw_seek (unix_stream * s, gfc_offset offset, int whence)\n {\n-  return lseek (s->fd, offset, whence);\n+  while (true)\n+    {\n+      gfc_offset off = lseek (s->fd, offset, whence);\n+      if (off == (gfc_offset) -1 && errno == EINTR)\n+\tcontinue;\n+      return off;\n+    }\n }\n \n static gfc_offset\n raw_tell (unix_stream * s)\n {\n-  return lseek (s->fd, 0, SEEK_CUR);\n+  while (true)\n+    {\n+      gfc_offset off = lseek (s->fd, 0, SEEK_CUR);\n+      if (off == (gfc_offset) -1 && errno == EINTR)\n+\tcontinue;\n+      return off;\n+    }\n }\n \n static gfc_offset\n raw_size (unix_stream * s)\n {\n   struct stat statbuf;\n-  int ret = fstat (s->fd, &statbuf);\n-  if (ret == -1)\n-    return ret;\n+  if (TEMP_FAILURE_RETRY (fstat (s->fd, &statbuf)) == -1)\n+    return -1;\n   if (S_ISREG (statbuf.st_mode))\n     return statbuf.st_size;\n   else\n@@ -390,7 +408,9 @@ raw_truncate (unix_stream * s, gfc_offset length)\n   lseek (s->fd, cur, SEEK_SET);\n   return -1;\n #elif defined HAVE_FTRUNCATE\n-  return ftruncate (s->fd, length);\n+  if (TEMP_FAILURE_RETRY (ftruncate (s->fd, length)) == -1)\n+    return -1;\n+  return 0;\n #elif defined HAVE_CHSIZE\n   return chsize (s->fd, length);\n #else\n@@ -409,7 +429,17 @@ raw_close (unix_stream * s)\n   else if (s->fd != STDOUT_FILENO\n       && s->fd != STDERR_FILENO\n       && s->fd != STDIN_FILENO)\n-    retval = close (s->fd);\n+    {\n+      retval = close (s->fd);\n+      /* close() and EINTR is special, as the file descriptor is\n+\t deallocated before doing anything that might cause the\n+\t operation to be interrupted. Thus if we get EINTR the best we\n+\t can do is ignore it and continue (otherwise if we try again\n+\t the file descriptor may have been allocated again to some\n+\t other file).  */\n+      if (retval == -1 && errno == EINTR)\n+\tretval = errno = 0;\n+    }\n   else\n     retval = 0;\n   free (s);\n@@ -463,7 +493,7 @@ buf_flush (unix_stream * s)\n     return 0;\n   \n   if (s->physical_offset != s->buffer_offset\n-      && lseek (s->fd, s->buffer_offset, SEEK_SET) < 0)\n+      && raw_seek (s, s->buffer_offset, SEEK_SET) < 0)\n     return -1;\n \n   writelen = raw_write (s, s->buffer, s->ndirty);\n@@ -518,7 +548,7 @@ buf_read (unix_stream * s, void * buf, ssize_t nbyte)\n       to_read = nbyte - nread;\n       new_logical = s->logical_offset + nread;\n       if (s->physical_offset != new_logical\n-          && lseek (s->fd, new_logical, SEEK_SET) < 0)\n+          && raw_seek (s, new_logical, SEEK_SET) < 0)\n         return -1;\n       s->buffer_offset = s->physical_offset = new_logical;\n       if (to_read <= BUFFER_SIZE/2)\n@@ -587,7 +617,7 @@ buf_write (unix_stream * s, const void * buf, ssize_t nbyte)\n \t{\n \t  if (s->physical_offset != s->logical_offset)\n \t    {\n-\t      if (lseek (s->fd, s->logical_offset, SEEK_SET) < 0)\n+\t      if (raw_seek (s, s->logical_offset, SEEK_SET) < 0)\n \t\treturn -1;\n \t      s->physical_offset = s->logical_offset;\n \t    }\n@@ -1025,7 +1055,7 @@ fd_to_stream (int fd, bool unformatted)\n \n   /* Get the current length of the file. */\n \n-  if (fstat (fd, &statbuf) == -1)\n+  if (TEMP_FAILURE_RETRY (fstat (fd, &statbuf)) == -1)\n     {\n       s->st_dev = s->st_ino = -1;\n       s->file_length = 0;\n@@ -1134,9 +1164,9 @@ tempfile_open (const char *tempdir, char **fname)\n #endif\n \n #if defined(HAVE_MKOSTEMP) && defined(O_CLOEXEC)\n-  fd = mkostemp (template, O_CLOEXEC);\n+  TEMP_FAILURE_RETRY (fd = mkostemp (template, O_CLOEXEC));\n #else\n-  fd = mkstemp (template);\n+  TEMP_FAILURE_RETRY (fd = mkstemp (template));\n   set_close_on_exec (fd);\n #endif\n \n@@ -1178,7 +1208,7 @@ tempfile_open (const char *tempdir, char **fname)\n \tcontinue;\n       }\n \n-      fd = open (template, flags, S_IRUSR | S_IWUSR);\n+      TEMP_FAILURE_RETRY (fd = open (template, flags, S_IRUSR | S_IWUSR));\n     }\n   while (fd == -1 && errno == EEXIST);\n #ifndef O_CLOEXEC\n@@ -1355,7 +1385,7 @@ regular_file2 (const char *path, st_parameter_open *opp, unit_flags *flags)\n #endif\n \n   mode = S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH;\n-  fd = open (path, rwflag | crflag, mode);\n+  TEMP_FAILURE_RETRY (fd = open (path, rwflag | crflag, mode));\n   if (flags->action != ACTION_UNSPECIFIED)\n     return fd;\n \n@@ -1373,7 +1403,7 @@ regular_file2 (const char *path, st_parameter_open *opp, unit_flags *flags)\n     crflag2 = crflag & ~(O_CREAT);\n   else\n     crflag2 = crflag;\n-  fd = open (path, rwflag | crflag2, mode);\n+  TEMP_FAILURE_RETRY (fd = open (path, rwflag | crflag2, mode));\n   if (fd >=0)\n     {\n       flags->action = ACTION_READ;\n@@ -1385,7 +1415,7 @@ regular_file2 (const char *path, st_parameter_open *opp, unit_flags *flags)\n \n   /* retry for write-only access */\n   rwflag = O_WRONLY;\n-  fd = open (path, rwflag | crflag, mode);\n+  TEMP_FAILURE_RETRY (fd = open (path, rwflag | crflag, mode));\n   if (fd >=0)\n     {\n       flags->action = ACTION_WRITE;\n@@ -1512,7 +1542,7 @@ compare_file_filename (gfc_unit *u, const char *name, int len)\n   /* If the filename doesn't exist, then there is no match with the\n    * existing file. */\n \n-  if (stat (path, &st) < 0)\n+  if (TEMP_FAILURE_RETRY (stat (path, &st)) < 0)\n     {\n       ret = 0;\n       goto done;\n@@ -1614,7 +1644,7 @@ find_file (const char *file, gfc_charlen_type file_len)\n \n   char *path = fc_strdup (file, file_len);\n \n-  if (stat (path, &st[0]) < 0)\n+  if (TEMP_FAILURE_RETRY (stat (path, &st[0])) < 0)\n     {\n       u = NULL;\n       goto done;\n@@ -1742,7 +1772,8 @@ file_size (const char *file, gfc_charlen_type file_len)\n {\n   char *path = fc_strdup (file, file_len);\n   struct stat statbuf;\n-  int err = stat (path, &statbuf);\n+  int err;\n+  TEMP_FAILURE_RETRY (err = stat (path, &statbuf));\n   free (path);\n   if (err == -1)\n     return -1;\n@@ -1764,7 +1795,8 @@ inquire_sequential (const char *string, int len)\n     return unknown;\n \n   char *path = fc_strdup (string, len);\n-  int err = stat (path, &statbuf);\n+  int err;\n+  TEMP_FAILURE_RETRY (err = stat (path, &statbuf));\n   free (path);\n   if (err == -1)\n     return unknown;\n@@ -1792,7 +1824,8 @@ inquire_direct (const char *string, int len)\n     return unknown;\n \n   char *path = fc_strdup (string, len);\n-  int err = stat (path, &statbuf);\n+  int err;\n+  TEMP_FAILURE_RETRY (err = stat (path, &statbuf));\n   free (path);\n   if (err == -1)\n     return unknown;\n@@ -1820,7 +1853,8 @@ inquire_formatted (const char *string, int len)\n     return unknown;\n \n   char *path = fc_strdup (string, len);\n-  int err = stat (path, &statbuf);\n+  int err;\n+  TEMP_FAILURE_RETRY (err = stat (path, &statbuf));\n   free (path);\n   if (err == -1)\n     return unknown;"}]}