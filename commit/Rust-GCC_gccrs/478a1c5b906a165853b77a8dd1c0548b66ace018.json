{"sha": "478a1c5b906a165853b77a8dd1c0548b66ace018", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDc4YTFjNWI5MDZhMTY1ODUzYjc3YThkZDFjMDU0OGI2NmFjZTAxOA==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "iant@google.com", "date": "2010-10-04T03:50:39Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2010-10-04T03:50:39Z"}, "message": "c-typeck.c (lookup_field): If -fplan9-extensions, permit referring to a field using a typedef name.\n\ngcc/:\n\t* c-typeck.c (lookup_field): If -fplan9-extensions, permit\n\treferring to a field using a typedef name.\n\t(find_anonymous_field_with_type): New static function.\n\t(convert_to_anonymous_field): New static function.\n\t(convert_for_assignment): If -fplan9-extensions, permit converting\n\tpointer to struct to pointer to anonymous field.\n\t* c-decl.c (grokfield): If -fplan9-extensions, permit anonymous\n\tfields.\n\t(is_duplicate_field): New static function.\n\t(detect_field_duplicates_hash): If -fplan9-extensions, check for\n\ttypedef names duplicating field names.\n\t(detect_field_duplicates): Likewise.\n\t* doc/invoke.texi (Option Summary): Mention -fplan9-extensions.\n\t(C Dialect Options): Document -fplan9-extensions.\n\t* doc/extend.texi (Unnamed Fields): Document -fplan9-extensions.\ngcc/c-family/:\n\t* c.opt (-fplan9-extensions): New option.\ngcc/testsuite/:\n\t* gcc.dg/anon-struct-11.c: New test.\n\t* gcc.dg/anon-struct-12.c: New test.\n\t* gcc.dg/anon-struct-13.c: New test.\n\t* gcc.dg/anon-struct-14.c: New test.\n\nFrom-SVN: r164926", "tree": {"sha": "c18cd90272c7a2cb06261eb2a6d5a845ebb150f2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c18cd90272c7a2cb06261eb2a6d5a845ebb150f2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/478a1c5b906a165853b77a8dd1c0548b66ace018", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/478a1c5b906a165853b77a8dd1c0548b66ace018", "html_url": "https://github.com/Rust-GCC/gccrs/commit/478a1c5b906a165853b77a8dd1c0548b66ace018", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/478a1c5b906a165853b77a8dd1c0548b66ace018/comments", "author": null, "committer": null, "parents": [{"sha": "3b5269a95e9e50001c2e4fabbb1712c9e984a09d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3b5269a95e9e50001c2e4fabbb1712c9e984a09d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3b5269a95e9e50001c2e4fabbb1712c9e984a09d"}], "stats": {"total": 600, "additions": 591, "deletions": 9}, "files": [{"sha": "72bfaf4abd7914190a5fc88081068998be5d3534", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/478a1c5b906a165853b77a8dd1c0548b66ace018/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/478a1c5b906a165853b77a8dd1c0548b66ace018/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=478a1c5b906a165853b77a8dd1c0548b66ace018", "patch": "@@ -1,3 +1,21 @@\n+2010-10-03  Ian Lance Taylor  <iant@google.com>\n+\n+\t* c-typeck.c (lookup_field): If -fplan9-extensions, permit\n+\treferring to a field using a typedef name.\n+\t(find_anonymous_field_with_type): New static function.\n+\t(convert_to_anonymous_field): New static function.\n+\t(convert_for_assignment): If -fplan9-extensions, permit converting\n+\tpointer to struct to pointer to anonymous field.\n+\t* c-decl.c (grokfield): If -fplan9-extensions, permit anonymous\n+\tfields.\n+\t(is_duplicate_field): New static function.\n+\t(detect_field_duplicates_hash): If -fplan9-extensions, check for\n+\ttypedef names duplicating field names.\n+\t(detect_field_duplicates): Likewise.\n+\t* doc/invoke.texi (Option Summary): Mention -fplan9-extensions.\n+\t(C Dialect Options): Document -fplan9-extensions.\n+\t* doc/extend.texi (Unnamed Fields): Document -fplan9-extensions.\n+\n 2010-10-03  H.J. Lu  <hongjiu.lu@intel.com>\n \n \t* tree-vect-data-refs.c (vect_analyze_data_ref_access): Revert"}, {"sha": "91d853fd0387a70ef034d43f47ab710011bbfc17", "filename": "gcc/c-decl.c", "status": "modified", "additions": 75, "deletions": 8, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/478a1c5b906a165853b77a8dd1c0548b66ace018/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/478a1c5b906a165853b77a8dd1c0548b66ace018/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=478a1c5b906a165853b77a8dd1c0548b66ace018", "patch": "@@ -6614,15 +6614,15 @@ grokfield (location_t loc,\n \t is the anonymous union extension.  Similarly for struct.\n \n \t If this is something of the form \"struct foo;\", then\n-\t   If MS extensions are enabled, this is handled as an\n-\t     anonymous struct.\n+\t   If MS or Plan 9 extensions are enabled, this is handled as\n+\t     an anonymous struct.\n \t   Otherwise this is a forward declaration of a structure tag.\n \n \t If this is something of the form \"foo;\" and foo is a TYPE_DECL, then\n \t   If foo names a structure or union without a tag, then this\n \t     is an anonymous struct (this is permitted by C1X).\n-\t   If MS extensions are enabled and foo names a structure, then\n-\t     again this is an anonymous struct.\n+\t   If MS or Plan 9 extensions are enabled and foo names a\n+\t     structure, then again this is an anonymous struct.\n \t   Otherwise this is an error.\n \n \t Oh what a horrid tangled web we weave.  I wonder if MS consciously\n@@ -6636,7 +6636,7 @@ grokfield (location_t loc,\n \n       if (type_ok)\n \t{\n-\t  if (flag_ms_extensions)\n+\t  if (flag_ms_extensions || flag_plan9_extensions)\n \t    ok = true;\n \t  else if (TYPE_NAME (TYPE_MAIN_VARIANT (type)) == NULL)\n \t    ok = true;\n@@ -6688,6 +6688,50 @@ grokfield (location_t loc,\n   return value;\n }\n \f\n+/* Subroutine of detect_field_duplicates: return whether X and Y,\n+   which are both fields in the same struct, have duplicate field\n+   names.  */\n+\n+static bool\n+is_duplicate_field (tree x, tree y)\n+{\n+  if (DECL_NAME (x) != NULL_TREE && DECL_NAME (x) == DECL_NAME (y))\n+    return true;\n+\n+  /* When using -fplan9-extensions, an anonymous field whose name is a\n+     typedef can duplicate a field name.  */\n+  if (flag_plan9_extensions\n+      && (DECL_NAME (x) == NULL_TREE || DECL_NAME (y) == NULL_TREE))\n+    {\n+      tree xt, xn, yt, yn;\n+\n+      xt = TREE_TYPE (x);\n+      if (DECL_NAME (x) != NULL_TREE)\n+\txn = DECL_NAME (x);\n+      else if ((TREE_CODE (xt) == RECORD_TYPE || TREE_CODE (xt) == UNION_TYPE)\n+\t       && TYPE_NAME (xt) != NULL_TREE\n+\t       && TREE_CODE (TYPE_NAME (xt)) == TYPE_DECL)\n+\txn = DECL_NAME (TYPE_NAME (xt));\n+      else\n+\txn = NULL_TREE;\n+\n+      yt = TREE_TYPE (y);\n+      if (DECL_NAME (y) != NULL_TREE)\n+\tyn = DECL_NAME (y);\n+      else if ((TREE_CODE (yt) == RECORD_TYPE || TREE_CODE (yt) == UNION_TYPE)\n+\t       && TYPE_NAME (yt) != NULL_TREE\n+\t       && TREE_CODE (TYPE_NAME (yt)) == TYPE_DECL)\n+\tyn = DECL_NAME (TYPE_NAME (yt));\n+      else\n+\tyn = NULL_TREE;\n+\n+      if (xn != NULL_TREE && xn == yn)\n+\treturn true;\n+    }\n+\n+  return false;\n+}\n+\n /* Subroutine of detect_field_duplicates: add the fields of FIELDLIST\n    to HTAB, giving errors for any duplicates.  */\n \n@@ -6710,7 +6754,22 @@ detect_field_duplicates_hash (tree fieldlist, htab_t htab)\n       }\n     else if (TREE_CODE (TREE_TYPE (x)) == RECORD_TYPE\n \t     || TREE_CODE (TREE_TYPE (x)) == UNION_TYPE)\n-      detect_field_duplicates_hash (TYPE_FIELDS (TREE_TYPE (x)), htab);\n+      {\n+\tdetect_field_duplicates_hash (TYPE_FIELDS (TREE_TYPE (x)), htab);\n+\n+\t/* When using -fplan9-extensions, an anonymous field whose\n+\t   name is a typedef can duplicate a field name.  */\n+\tif (flag_plan9_extensions\n+\t    && TYPE_NAME (TREE_TYPE (x)) != NULL_TREE\n+\t    && TREE_CODE (TYPE_NAME (TREE_TYPE (x))) == TYPE_DECL)\n+\t  {\n+\t    tree xn = DECL_NAME (TYPE_NAME (TREE_TYPE (x)));\n+\t    slot = htab_find_slot (htab, xn, INSERT);\n+\t    if (*slot)\n+\t      error (\"duplicate member %q+D\", TYPE_NAME (TREE_TYPE (x)));\n+\t    *slot = xn;\n+\t  }\n+      }\n }\n \n /* Generate an error for any duplicate field names in FIELDLIST.  Munge\n@@ -6755,10 +6814,18 @@ detect_field_duplicates (tree fieldlist)\n   if (timeout > 0)\n     {\n       for (x = DECL_CHAIN (fieldlist); x; x = DECL_CHAIN (x))\n-\tif (DECL_NAME (x))\n+\t/* When using -fplan9-extensions, we can have duplicates\n+\t   between typedef names and fields.  */\n+\tif (DECL_NAME (x)\n+\t    || (flag_plan9_extensions\n+\t\t&& DECL_NAME (x) == NULL_TREE\n+\t\t&& (TREE_CODE (TREE_TYPE (x)) == RECORD_TYPE\n+\t\t    || TREE_CODE (TREE_TYPE (x)) == UNION_TYPE)\n+\t\t&& TYPE_NAME (TREE_TYPE (x)) != NULL_TREE\n+\t\t&& TREE_CODE (TYPE_NAME (TREE_TYPE (x))) == TYPE_DECL))\n \t  {\n \t    for (y = fieldlist; y != x; y = TREE_CHAIN (y))\n-\t      if (DECL_NAME (y) == DECL_NAME (x))\n+\t      if (is_duplicate_field (y, x))\n \t\t{\n \t\t  error (\"duplicate member %q+D\", x);\n \t\t  DECL_NAME (x) = NULL_TREE;"}, {"sha": "6f6aa908deeb5f5f7adc9f12e103dd649aa1a395", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/478a1c5b906a165853b77a8dd1c0548b66ace018/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/478a1c5b906a165853b77a8dd1c0548b66ace018/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=478a1c5b906a165853b77a8dd1c0548b66ace018", "patch": "@@ -1,3 +1,7 @@\n+2010-10-03  Ian Lance Taylor  <iant@google.com>\n+\n+\t* c.opt (-fplan9-extensions): New option.\n+\n 2010-10-03  Francois-Xavier Coudert  <fxcoudert@gcc.gnu.org>\n \n \t* c-cppbuiltin.c (define__GNUC__, builtin_define_type_precision):"}, {"sha": "cacf24907a90a7deb35f22543f90bbad581cb459", "filename": "gcc/c-family/c.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/478a1c5b906a165853b77a8dd1c0548b66ace018/gcc%2Fc-family%2Fc.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/478a1c5b906a165853b77a8dd1c0548b66ace018/gcc%2Fc-family%2Fc.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc.opt?ref=478a1c5b906a165853b77a8dd1c0548b66ace018", "patch": "@@ -893,6 +893,10 @@ fpermissive\n C++ ObjC++\n Downgrade conformance errors to warnings\n \n+fplan9-extensions\n+C ObjC Var(flag_plan9_extensions)\n+Enable Plan 9 language extensions\n+\n fpreprocessed\n C ObjC C++ ObjC++\n Treat the input file as already preprocessed"}, {"sha": "14bc281615e20b943e73837d202e5642d4963f75", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 140, "deletions": 0, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/478a1c5b906a165853b77a8dd1c0548b66ace018/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/478a1c5b906a165853b77a8dd1c0548b66ace018/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=478a1c5b906a165853b77a8dd1c0548b66ace018", "patch": "@@ -2044,6 +2044,17 @@ lookup_field (tree type, tree component)\n \n \t\t      if (anon)\n \t\t\treturn tree_cons (NULL_TREE, field, anon);\n+\n+\t\t      /* The Plan 9 compiler permits referring\n+\t\t\t directly to an anonymous struct/union field\n+\t\t\t using a typedef name.  */\n+\t\t      if (flag_plan9_extensions\n+\t\t\t  && TYPE_NAME (TREE_TYPE (field)) != NULL_TREE\n+\t\t\t  && (TREE_CODE (TYPE_NAME (TREE_TYPE (field)))\n+\t\t\t      == TYPE_DECL)\n+\t\t\t  && (DECL_NAME (TYPE_NAME (TREE_TYPE (field)))\n+\t\t\t      == component))\n+\t\t\tbreak;\n \t\t    }\n \t\t}\n \n@@ -2080,6 +2091,16 @@ lookup_field (tree type, tree component)\n \n \t      if (anon)\n \t\treturn tree_cons (NULL_TREE, field, anon);\n+\n+\t      /* The Plan 9 compiler permits referring directly to an\n+\t\t anonymous struct/union field using a typedef\n+\t\t name.  */\n+\t      if (flag_plan9_extensions\n+\t\t  && TYPE_NAME (TREE_TYPE (field)) != NULL_TREE\n+\t\t  && TREE_CODE (TYPE_NAME (TREE_TYPE (field))) == TYPE_DECL\n+\t\t  && (DECL_NAME (TYPE_NAME (TREE_TYPE (field)))\n+\t\t      == component))\n+\t\tbreak;\n \t    }\n \n \t  if (DECL_NAME (field) == component)\n@@ -4952,6 +4973,106 @@ build_modify_expr (location_t location, tree lhs, tree lhs_origtype,\n   return result;\n }\n \f\n+/* Return whether STRUCT_TYPE has an anonymous field with type TYPE.\n+   This is used to implement -fplan9-extensions.  */\n+\n+static bool\n+find_anonymous_field_with_type (tree struct_type, tree type)\n+{\n+  tree field;\n+  bool found;\n+\n+  gcc_assert (TREE_CODE (struct_type) == RECORD_TYPE\n+\t      || TREE_CODE (struct_type) == UNION_TYPE);\n+  found = false;\n+  for (field = TYPE_FIELDS (struct_type);\n+       field != NULL_TREE;\n+       field = TREE_CHAIN (field))\n+    {\n+      if (DECL_NAME (field) == NULL\n+\t  && comptypes (type, TYPE_MAIN_VARIANT (TREE_TYPE (field))))\n+\t{\n+\t  if (found)\n+\t    return false;\n+\t  found = true;\n+\t}\n+      else if (DECL_NAME (field) == NULL\n+\t       && (TREE_CODE (TREE_TYPE (field)) == RECORD_TYPE\n+\t\t   || TREE_CODE (TREE_TYPE (field)) == UNION_TYPE)\n+\t       && find_anonymous_field_with_type (TREE_TYPE (field), type))\n+\t{\n+\t  if (found)\n+\t    return false;\n+\t  found = true;\n+\t}\n+    }\n+  return found;\n+}\n+\n+/* RHS is an expression whose type is pointer to struct.  If there is\n+   an anonymous field in RHS with type TYPE, then return a pointer to\n+   that field in RHS.  This is used with -fplan9-extensions.  This\n+   returns NULL if no conversion could be found.  */\n+\n+static tree\n+convert_to_anonymous_field (location_t location, tree type, tree rhs)\n+{\n+  tree rhs_struct_type, lhs_main_type;\n+  tree field, found_field;\n+  bool found_sub_field;\n+  tree ret;\n+\n+  gcc_assert (POINTER_TYPE_P (TREE_TYPE (rhs)));\n+  rhs_struct_type = TREE_TYPE (TREE_TYPE (rhs));\n+  gcc_assert (TREE_CODE (rhs_struct_type) == RECORD_TYPE\n+\t      || TREE_CODE (rhs_struct_type) == UNION_TYPE);\n+\n+  gcc_assert (POINTER_TYPE_P (type));\n+  lhs_main_type = TYPE_MAIN_VARIANT (TREE_TYPE (type));\n+\n+  found_field = NULL_TREE;\n+  found_sub_field = false;\n+  for (field = TYPE_FIELDS (rhs_struct_type);\n+       field != NULL_TREE;\n+       field = TREE_CHAIN (field))\n+    {\n+      if (DECL_NAME (field) != NULL_TREE\n+\t  || (TREE_CODE (TREE_TYPE (field)) != RECORD_TYPE\n+\t      && TREE_CODE (TREE_TYPE (field)) != UNION_TYPE))\n+\tcontinue;\n+      if (comptypes (lhs_main_type, TYPE_MAIN_VARIANT (TREE_TYPE (field))))\n+\t{\n+\t  if (found_field != NULL_TREE)\n+\t    return NULL_TREE;\n+\t  found_field = field;\n+\t}\n+      else if (find_anonymous_field_with_type (TREE_TYPE (field),\n+\t\t\t\t\t       lhs_main_type))\n+\t{\n+\t  if (found_field != NULL_TREE)\n+\t    return NULL_TREE;\n+\t  found_field = field;\n+\t  found_sub_field = true;\n+\t}\n+    }\n+\n+  if (found_field == NULL_TREE)\n+    return NULL_TREE;\n+\n+  ret = fold_build3_loc (location, COMPONENT_REF, TREE_TYPE (found_field),\n+\t\t\t build_fold_indirect_ref (rhs), found_field,\n+\t\t\t NULL_TREE);\n+  ret = build_fold_addr_expr_loc (location, ret);\n+\n+  if (found_sub_field)\n+    {\n+      ret = convert_to_anonymous_field (location, type, ret);\n+      gcc_assert (ret != NULL_TREE);\n+    }\n+\n+  return ret;\n+}\n+\n /* Convert value RHS to type TYPE as preparation for an assignment to\n    an lvalue of type TYPE.  If ORIGTYPE is not NULL_TREE, it is the\n    original type of RHS; this differs from TREE_TYPE (RHS) for enum\n@@ -5323,6 +5444,25 @@ convert_for_assignment (location_t location, tree type, tree rhs,\n       /* Opaque pointers are treated like void pointers.  */\n       is_opaque_pointer = vector_targets_convertible_p (ttl, ttr);\n \n+      /* The Plan 9 compiler permits a pointer to a struct to be\n+\t automatically converted into a pointer to an anonymous field\n+\t within the struct.  */\n+      if (flag_plan9_extensions\n+\t  && (TREE_CODE (mvl) == RECORD_TYPE || TREE_CODE(mvl) == UNION_TYPE)\n+\t  && (TREE_CODE (mvr) == RECORD_TYPE || TREE_CODE(mvr) == UNION_TYPE)\n+\t  && mvl != mvr)\n+\t{\n+\t  tree new_rhs = convert_to_anonymous_field (location, type, rhs);\n+\t  if (new_rhs != NULL_TREE)\n+\t    {\n+\t      rhs = new_rhs;\n+\t      rhstype = TREE_TYPE (rhs);\n+\t      coder = TREE_CODE (rhstype);\n+\t      ttr = TREE_TYPE (rhstype);\n+\t      mvr = TYPE_MAIN_VARIANT (ttr);\n+\t    }\n+\t}\n+\n       /* C++ does not allow the implicit conversion void* -> T*.  However,\n \t for the purpose of reducing the number of false positives, we\n \t tolerate the special case of"}, {"sha": "fc40d5301ce43d8d032ba228c24f6021e1a494ca", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/478a1c5b906a165853b77a8dd1c0548b66ace018/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/478a1c5b906a165853b77a8dd1c0548b66ace018/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=478a1c5b906a165853b77a8dd1c0548b66ace018", "patch": "@@ -13027,6 +13027,34 @@ also be a definition with a tag such as @samp{struct foo @{ int a;\n @samp{struct foo;}, or a reference to a @code{typedef} name for a\n previously defined structure or union type with a tag.\n \n+@opindex fplan9-extensions\n+The option @option{-fplan9-extensions} enables\n+@option{-fms-extensions} as well as two other extensions.  First, a\n+pointer to a structure is automatically converted to a pointer to an\n+anonymous field for assignments and function calls.  For example:\n+\n+@smallexample\n+struct s1 @{ int a; @};\n+struct s2 @{ struct s1; @};\n+extern void f1 (struct s1 *);\n+void f2 (struct s2 *p) @{ f1 (p); @}\n+@end smallexample\n+\n+In the call to @code{f1} inside @code{f2}, the pointer @code{p} is\n+converted into a pointer to the anonymous field.\n+\n+Second, when the type of an anonymous field is a @code{typedef} for a\n+@code{struct} or @code{union}, code may refer to the field using the\n+name of the @code{typedef}.\n+\n+@smallexample\n+typedef struct @{ int a; @} s1;\n+struct s2 @{ s1; @};\n+s1 f1 (struct s2 *p) @{ return p->s1; @}\n+@end smallexample\n+\n+These usages are only permitted when they are not ambiguous.\n+\n @node Thread-Local\n @section Thread-Local Storage\n @cindex Thread-Local Storage"}, {"sha": "d106672010398f172e62c9e22e487b6fd30b1112", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/478a1c5b906a165853b77a8dd1c0548b66ace018/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/478a1c5b906a165853b77a8dd1c0548b66ace018/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=478a1c5b906a165853b77a8dd1c0548b66ace018", "patch": "@@ -172,7 +172,7 @@ in the following sections.\n @gccoptlist{-ansi  -std=@var{standard}  -fgnu89-inline @gol\n -aux-info @var{filename} @gol\n -fno-asm  -fno-builtin  -fno-builtin-@var{function} @gol\n--fhosted  -ffreestanding -fopenmp -fms-extensions @gol\n+-fhosted  -ffreestanding -fopenmp -fms-extensions -fplan9-extensions @gol\n -trigraphs  -no-integrated-cpp  -traditional  -traditional-cpp @gol\n -fallow-single-precision  -fcond-mismatch -flax-vector-conversions @gol\n -fsigned-bitfields  -fsigned-char @gol\n@@ -1700,6 +1700,16 @@ Some cases of unnamed fields in structures and unions are only\n accepted with this option.  @xref{Unnamed Fields,,Unnamed struct/union\n fields within structs/unions}, for details.\n \n+@item -fplan9-extensions\n+Accept some non-standard constructs used in Plan 9 code.\n+\n+This enables @option{-fms-extensions}, permits passing pointers to\n+structures with anonymous fields to functions which expect pointers to\n+elements of the type of the field, and permits referring to anonymous\n+fields declared using a typedef.  @xref{Unnamed Fields,,Unnamed\n+struct/union fields within structs/unions}, for details.  This is only\n+supported for C, not C++.\n+\n @item -trigraphs\n @opindex trigraphs\n Support ISO C trigraphs.  The @option{-ansi} option (and @option{-std}"}, {"sha": "00fc30c80e2f92b7b3f1fabad04015db35e1338e", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/478a1c5b906a165853b77a8dd1c0548b66ace018/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/478a1c5b906a165853b77a8dd1c0548b66ace018/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=478a1c5b906a165853b77a8dd1c0548b66ace018", "patch": "@@ -1,3 +1,10 @@\n+2010-10-03  Ian Lance Taylor  <iant@google.com>\n+\n+\t* gcc.dg/anon-struct-11.c: New test.\n+\t* gcc.dg/anon-struct-12.c: New test.\n+\t* gcc.dg/anon-struct-13.c: New test.\n+\t* gcc.dg/anon-struct-14.c: New test.\n+\n 2010-10-03  H.J. Lu  <hongjiu.lu@intel.com>\n \n \t* g++.dg/torture/pr45764.C: Revert revision 164914."}, {"sha": "1084e5bded67db349b025b061ab4079d143dc7cc", "filename": "gcc/testsuite/gcc.dg/anon-struct-11.c", "status": "added", "additions": 111, "deletions": 0, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/478a1c5b906a165853b77a8dd1c0548b66ace018/gcc%2Ftestsuite%2Fgcc.dg%2Fanon-struct-11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/478a1c5b906a165853b77a8dd1c0548b66ace018/gcc%2Ftestsuite%2Fgcc.dg%2Fanon-struct-11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanon-struct-11.c?ref=478a1c5b906a165853b77a8dd1c0548b66ace018", "patch": "@@ -0,0 +1,111 @@\n+/* { dg-do compile } */\n+\n+/* No special options--in particular, turn off the default\n+   -pedantic-errors option.  */\n+/* { dg-options \"\" } */\n+\n+/* When not using -fplan9-extensions, we don't support automatic\n+   conversion of pointer types, and we don't support referring to a\n+   typedef name directly.  */\n+\n+extern void exit (int);\n+extern void abort (void);\n+\n+struct A { char a; };\n+\n+struct B {\n+  char b;\n+  struct A;\t\t/* { dg-warning \"does not declare anything\" } */\n+  char c;\n+};\n+\n+void\n+f1 (struct A *p)\t/* { dg-message \"expected\" } */\n+{\n+  p->a = 1;\n+}\n+\n+void\n+test1 (void)\n+{\n+  struct B b;\n+  struct A *p;\n+\n+  b.b = 2;\n+  b.c = 3;\n+  f1 (&b);\t\t/* { dg-warning \"incompatible pointer type\" } */\n+  if (b.a != 1)\t\t/* { dg-error \"no member\" } */\n+    abort ();\n+  if (b.b != 2 || b.c != 3)\n+    abort ();\n+  p = &b;\t\t/* { dg-warning \"incompatible pointer type\" } */\n+  if (p->a != 1)\n+    abort ();\n+}\n+\n+typedef struct { char d; } D;\n+\n+struct E {\n+  char b;\n+  struct F { char f; };\t/* { dg-warning \"does not declare anything\" } */\n+  char c;\n+  union {\n+    D;\n+  };\n+  char e;\n+};\n+\n+void\n+f2 (struct F *p)\t/* { dg-message \"expected\" } */\n+{\n+  p->f = 6;\n+}\n+\n+void\n+f3 (D *p)\t\t/* { dg-message \"expected\" } */\n+{\n+  p->d = 4;\n+}\n+\n+void\n+f4 (D d)\n+{\n+}\n+\n+void\n+test2 (void)\n+{\n+  struct E e;\n+  struct F *pf;\n+  D *pd;\n+  D d;\n+\n+  e.b = 2;\n+  e.c = 3;\n+  e.e = 5;\n+  f2 (&e);\t\t/* { dg-warning \"incompatible pointer type\" } */\n+  f3 (&e);\t\t/* { dg-warning \"incompatible pointer type\" } */\n+  if (e.d != 4)\n+    abort ();\n+  if (e.f != 6)\t\t/* { dg-error \"no member\" } */\n+    abort ();\n+  if (e.b != 2 || e.c != 3 || e.e != 5)\n+    abort ();\n+  pf = &e;\t\t/* { dg-warning \"incompatible pointer type\" } */\n+  if (pf->f != 6)\n+    abort ();\n+  pd = &e;\t\t/* { dg-warning \"incompatible pointer type\" } */\n+  if (pd->d != 4)\n+    abort ();\n+  d = e.D;\t\t/* { dg-error \"no member\" } */\n+  f3 (&e.D);\t\t/* { dg-error \"no member\" } */\n+  f4 (e.D);\t\t/* { dg-error \"no member\" } */\n+}\n+\n+int\n+main ()\n+{\n+  test1 ();\n+  test2 ();\n+  exit (0);\n+}"}, {"sha": "60cd178224ed81fb4df971d478f3b4a4c0bb59f7", "filename": "gcc/testsuite/gcc.dg/anon-struct-12.c", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/478a1c5b906a165853b77a8dd1c0548b66ace018/gcc%2Ftestsuite%2Fgcc.dg%2Fanon-struct-12.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/478a1c5b906a165853b77a8dd1c0548b66ace018/gcc%2Ftestsuite%2Fgcc.dg%2Fanon-struct-12.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanon-struct-12.c?ref=478a1c5b906a165853b77a8dd1c0548b66ace018", "patch": "@@ -0,0 +1,108 @@\n+/* { dg-do run } */\n+/* { dg-options \"-fplan9-extensions\" } */\n+\n+/* When using -fplan9-extensions, we support automatic conversion of\n+   pointer types, and we support referring to a typedef name\n+   directly.  */\n+\n+extern void exit (int);\n+extern void abort (void);\n+\n+struct A { char a; };\n+\n+struct B {\n+  char b;\n+  struct A;\n+  char c;\n+};\n+\n+void\n+f1 (struct A *p)\n+{\n+  p->a = 1;\n+}\n+\n+void\n+test1 (void)\n+{\n+  struct B b;\n+  struct A *p;\n+\n+  b.b = 2;\n+  b.c = 3;\n+  f1 (&b);\n+  if (b.a != 1)\n+    abort ();\n+  if (b.b != 2 || b.c != 3)\n+    abort ();\n+  p = &b;\n+  if (p->a != 1)\n+    abort ();\n+}\n+\n+typedef struct { char d; } D;\n+\n+struct E {\n+  char b;\n+  struct F { char f; };\n+  char c;\n+  union {\n+    D;\n+  };\n+  char e;\n+};\n+\n+void\n+f2 (struct F *p)\n+{\n+  p->f = 6;\n+}\n+\n+void\n+f3 (D *p)\n+{\n+  p->d = 4;\n+}\n+\n+void\n+f4 (D d)\n+{\n+}\n+\n+void\n+test2 (void)\n+{\n+  struct E e;\n+  struct F *pf;\n+  D *pd;\n+  D d;\n+\n+  e.b = 2;\n+  e.c = 3;\n+  e.e = 5;\n+  f2 (&e);\n+  f3 (&e);\n+  if (e.d != 4)\n+    abort ();\n+  if (e.f != 6)\n+    abort ();\n+  if (e.b != 2 || e.c != 3 || e.e != 5)\n+    abort ();\n+  pf = &e;\n+  if (pf->f != 6)\n+    abort ();\n+  pd = &e;\n+  if (pd->d != 4)\n+    abort ();\n+  d = e.D;\n+  f3 (&e.D);\n+  f4 (e.D);\n+}\n+\n+int\n+main ()\n+{\n+  test1 ();\n+  test2 ();\n+  exit (0);\n+}"}, {"sha": "6a508141bac547c644dca54688d20d528604d6a5", "filename": "gcc/testsuite/gcc.dg/anon-struct-13.c", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/478a1c5b906a165853b77a8dd1c0548b66ace018/gcc%2Ftestsuite%2Fgcc.dg%2Fanon-struct-13.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/478a1c5b906a165853b77a8dd1c0548b66ace018/gcc%2Ftestsuite%2Fgcc.dg%2Fanon-struct-13.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanon-struct-13.c?ref=478a1c5b906a165853b77a8dd1c0548b66ace018", "patch": "@@ -0,0 +1,76 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fplan9-extensions\" } */\n+\n+/* Test for ambiguity when using the Plan 9 extensions.  */\n+\n+struct A {\n+  char a;\t\t/* { dg-error \"duplicate member\" } */\n+};\n+\n+struct B\n+{\n+  struct A;\n+  struct A;\n+};\n+\n+char\n+f1 (struct B *p)\n+{\n+  return p->a;\t\t/* { dg-error \"no member\" } */\n+}\n+\n+void\n+f2 (struct A *p)\t/* { dg-message \"expected\" } */\n+{\n+}\n+\n+void\n+f3 (struct B *p)\n+{\n+  f2 (p);\t\t/* { dg-warning \"incompatible pointer type\" } */\n+}\n+\n+struct C\n+{\n+  char c;\t\t/* { dg-error \"duplicate member\" } */\n+};\n+\n+struct D\n+{\n+  struct C;\n+};\n+\n+struct E\n+{\n+  struct C;\n+  struct D;\n+};\n+\n+char\n+f4 (struct E *p)\n+{\n+  return p->c;\t\t/* { dg-error \"no member\" } */\n+}\n+\n+void\n+f6 (struct C *p)\t/* { dg-message \"expected\" } */\n+{\n+}\n+\n+void\n+f7 (struct E *p)\n+{\n+  f6 (p);\t\t/* { dg-warning \"incompatible pointer type\" } */\n+}\n+\n+struct A\n+f8 (struct B *p)\n+{\n+  return p->A;\t\t/* { dg-error \"no member\" } */\n+}\n+\n+struct C\n+f9 (struct E *p)\n+{\n+  return p->C;\t\t/* { dg-error \"no member\" } */\n+}"}, {"sha": "293ccc75a687567d3aa606a07020ffcc17b6533a", "filename": "gcc/testsuite/gcc.dg/anon-struct-14.c", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/478a1c5b906a165853b77a8dd1c0548b66ace018/gcc%2Ftestsuite%2Fgcc.dg%2Fanon-struct-14.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/478a1c5b906a165853b77a8dd1c0548b66ace018/gcc%2Ftestsuite%2Fgcc.dg%2Fanon-struct-14.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanon-struct-14.c?ref=478a1c5b906a165853b77a8dd1c0548b66ace018", "patch": "@@ -0,0 +1,9 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fplan9-extensions\" } */\n+\n+/* When using Plan 9 extensions, a typedef can conflict with an\n+   anonymous field.  */\n+\n+typedef struct { int a; } s1;\n+struct s2 { s1; int s1; };\t\t/* { dg-error \"duplicate\" } */\n+int f(struct s2 *p) { return p->s1; }\t/* { dg-error \"incompatible\" } */"}]}