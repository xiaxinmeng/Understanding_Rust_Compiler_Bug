{"sha": "997636716c5dde7d59d026726a6f58918069f122", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTk3NjM2NzE2YzVkZGU3ZDU5ZDAyNjcyNmE2ZjU4OTE4MDY5ZjEyMg==", "commit": {"author": {"name": "Alejandro Martinez", "email": "alejandro.martinezvicente@arm.com", "date": "2019-05-28T13:48:44Z"}, "committer": {"name": "Alejandro Martinez", "email": "alejandro@gcc.gnu.org", "date": "2019-05-28T13:48:44Z"}, "message": "Current vectoriser doesn't support masked loads for SLP.\n\nCurrent vectoriser doesn't support masked loads for SLP. We should add that, to\nallow things like:\n\nvoid\nf (int *restrict x, int *restrict y, int *restrict z, int n)\n{\n  for (int i = 0; i < n; i += 2)\n    {\n      x[i] = y[i] ? z[i] : 1;\n      x[i + 1] = y[i + 1] ? z[i + 1] : 2;\n    }\n}\n\nto be vectorized using contiguous loads rather than LD2 and ST2.\n\nThis patch was motivated by SVE, but it is completely generic and should apply\nto any architecture with masked loads.\n\nFrom-SVN: r271704", "tree": {"sha": "d18d1d7f5388bc0bb743583ce506e284c8eb60d3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d18d1d7f5388bc0bb743583ce506e284c8eb60d3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/997636716c5dde7d59d026726a6f58918069f122", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/997636716c5dde7d59d026726a6f58918069f122", "html_url": "https://github.com/Rust-GCC/gccrs/commit/997636716c5dde7d59d026726a6f58918069f122", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/997636716c5dde7d59d026726a6f58918069f122/comments", "author": null, "committer": null, "parents": [{"sha": "8b4e7143550cd1f3f4b1dca005a5e656506979d9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b4e7143550cd1f3f4b1dca005a5e656506979d9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8b4e7143550cd1f3f4b1dca005a5e656506979d9"}], "stats": {"total": 252, "additions": 229, "deletions": 23}, "files": [{"sha": "f48289f0f56d539286a8f8752af7d7a1f9a80789", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/997636716c5dde7d59d026726a6f58918069f122/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/997636716c5dde7d59d026726a6f58918069f122/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=997636716c5dde7d59d026726a6f58918069f122", "patch": "@@ -1,3 +1,23 @@\n+2019-05-28  Alejandro Martinez  <alejandro.martinezvicente@arm.com>\n+\n+\t* internal-fn.c: Marked mask_load_direct as vectorizable.\n+\t* tree-data-ref.c (data_ref_compare_tree): Fixed comment typo.\n+\t* tree-vect-data-refs.c (can_group_stmts_p): Allow masked loads to be\n+\tcombined even if masks different with allow_slp_p param.\n+\t(vect_analyze_data_ref_accesses): Mark SLP only vectorizable groups.\n+\t* tree-vect-loop.c (vect_dissolve_slp_only_groups): New function to\n+\tdissolve SLP-only vectorizable groups when SLP has been discarded.\n+\t(vect_analyze_loop_2): Call vect_dissolve_slp_only_groups when needed.\n+\t* tree-vect-slp.c (vect_get_and_check_slp_defs): Check masked loads\n+\tmasks.\n+\t(vect_build_slp_tree_1): Fixed comment typo.\n+\t(vect_build_slp_tree_2): Include masks from masked loads in SLP tree.\n+\t* tree-vect-stmts.c (vectorizable_load): Allow vectorizaion of masked\n+\tloads for SLP only.\n+\t* tree-vectorizer.h (_stmt_vec_info): Added flag for SLP-only\n+\tvectorizable.\n+\t* tree-vectorizer.c (vec_info::new_stmt_vec_info): Likewise.\n+\n 2019-05-28  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n \n \t* config/alpha/alpha.c [TARGET_ABI_OSF] (alpha_output_mi_thunk_osf):"}, {"sha": "3051a7aa72df26de325c6183784bb8119e2d3669", "filename": "gcc/internal-fn.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/997636716c5dde7d59d026726a6f58918069f122/gcc%2Finternal-fn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/997636716c5dde7d59d026726a6f58918069f122/gcc%2Finternal-fn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.c?ref=997636716c5dde7d59d026726a6f58918069f122", "patch": "@@ -100,7 +100,7 @@ init_internal_fns ()\n /* Create static initializers for the information returned by\n    direct_internal_fn.  */\n #define not_direct { -2, -2, false }\n-#define mask_load_direct { -1, 2, false }\n+#define mask_load_direct { -1, 2, true }\n #define load_lanes_direct { -1, -1, false }\n #define mask_load_lanes_direct { -1, -1, false }\n #define gather_load_direct { -1, -1, false }"}, {"sha": "5f4be276bdbaa2f249297926abdc645be50028a8", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/997636716c5dde7d59d026726a6f58918069f122/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/997636716c5dde7d59d026726a6f58918069f122/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=997636716c5dde7d59d026726a6f58918069f122", "patch": "@@ -1,3 +1,8 @@\n+2019-05-28  Alejandro Martinez  <alejandro.martinezvicente@arm.com>\n+\n+\t* gcc.target/aarch64/sve/mask_load_slp_1.c: New test for SLP\n+\tvectorized masked loads.\n+\n 2019-05-28  Jeff Law  <law@redhat.com>\n \n \t* testsuite/gcc.target/sh/pr50749-qihisi-predec-3.c: Disable"}, {"sha": "78c70b2be3202819cc2bfbd3bedbe0e3a3702d30", "filename": "gcc/testsuite/gcc.target/aarch64/sve/mask_load_slp_1.c", "status": "added", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/997636716c5dde7d59d026726a6f58918069f122/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fmask_load_slp_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/997636716c5dde7d59d026726a6f58918069f122/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fmask_load_slp_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fmask_load_slp_1.c?ref=997636716c5dde7d59d026726a6f58918069f122", "patch": "@@ -0,0 +1,90 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -ftree-vectorize\" } */\n+\n+#include <stdint.h>\n+\n+#define MASK_SLP_2(TYPE_COND, ALT_VAL)\t\t\t\t\t\\\n+void __attribute__ ((noinline, noclone))\t\t\t\t\\\n+mask_slp_##TYPE_COND##_2_##ALT_VAL (int *restrict x, int *restrict y,\t\\\n+\t\t\t\t    TYPE_COND *restrict z, int n)\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  for (int i = 0; i < n; i += 2)\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      x[i] = y[i] ? z[i] : 1;\t\t\t\t\t\t\\\n+      x[i + 1] = y[i + 1] ? z[i + 1] : ALT_VAL;\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+}\n+\n+#define MASK_SLP_4(TYPE_COND, ALT_VAL)\t\t\t\t\t\\\n+void __attribute__ ((noinline, noclone))\t\t\t\t\\\n+mask_slp_##TYPE_COND##_4_##ALT_VAL (int *restrict x, int *restrict y,\t\\\n+\t\t\t\t    TYPE_COND *restrict z, int n)\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  for (int i = 0; i < n; i += 4)\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      x[i] = y[i] ? z[i] : 1;\t\t\t\t\t\t\\\n+      x[i + 1] = y[i + 1] ? z[i + 1] : ALT_VAL;\t\t\t\t\\\n+      x[i + 2] = y[i + 2] ? z[i + 2] : 1;\t\t\t\t\\\n+      x[i + 3] = y[i + 3] ? z[i + 3] : ALT_VAL;\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+}\n+\n+#define MASK_SLP_8(TYPE_COND, ALT_VAL)\t\t\t\t\t\\\n+void __attribute__ ((noinline, noclone))\t\t\t\t\\\n+mask_slp_##TYPE_COND##_8_##ALT_VAL (int *restrict x, int *restrict y,\t\\\n+\t\t\t\t    TYPE_COND *restrict z, int n)\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  for (int i = 0; i < n; i += 8)\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      x[i] = y[i] ? z[i] : 1;\t\t\t\t\t\t\\\n+      x[i + 1] = y[i + 1] ? z[i + 1] : ALT_VAL;\t\t\t\t\\\n+      x[i + 2] = y[i + 2] ? z[i + 2] : 1;\t\t\t\t\\\n+      x[i + 3] = y[i + 3] ? z[i + 3] : ALT_VAL;\t\t\t\t\\\n+      x[i + 4] = y[i + 4] ? z[i + 4] : 1;\t\t\t\t\\\n+      x[i + 5] = y[i + 5] ? z[i + 5] : ALT_VAL;\t\t\t\t\\\n+      x[i + 6] = y[i + 6] ? z[i + 6] : 1;\t\t\t\t\\\n+      x[i + 7] = y[i + 7] ? z[i + 7] : ALT_VAL;\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+}\n+\n+#define MASK_SLP_FAIL(TYPE_COND)\t\t\t\t\t\\\n+void __attribute__ ((noinline, noclone))\t\t\t\t\\\n+mask_slp_##TYPE_COND##_FAIL (int *restrict x, int *restrict y,\t\t\\\n+\t\t\t     TYPE_COND *restrict z, int n)\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  for (int i = 0; i < n; i += 2)\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      x[i] = y[i] ? z[i] : 1;\t\t\t\t\t\t\\\n+      x[i + 1] = y[i + 1] ? z[i + 1] : x[z[i + 1]];\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+}\n+\n+MASK_SLP_2(int8_t, 1)\n+MASK_SLP_2(int8_t, 2)\n+MASK_SLP_2(int, 1)\n+MASK_SLP_2(int, 2)\n+MASK_SLP_2(int64_t, 1)\n+MASK_SLP_2(int64_t, 2)\n+\n+MASK_SLP_4(int8_t, 1)\n+MASK_SLP_4(int8_t, 2)\n+MASK_SLP_4(int, 1)\n+MASK_SLP_4(int, 2)\n+MASK_SLP_4(int64_t, 1)\n+MASK_SLP_4(int64_t, 2)\n+\n+MASK_SLP_8(int8_t, 1)\n+MASK_SLP_8(int8_t, 2)\n+MASK_SLP_8(int, 1)\n+MASK_SLP_8(int, 2)\n+MASK_SLP_8(int64_t, 1)\n+MASK_SLP_8(int64_t, 2)\n+\n+MASK_SLP_FAIL(int8_t)\n+MASK_SLP_FAIL(int)\n+MASK_SLP_FAIL(int64_t)\n+\n+/* { dg-final { scan-assembler-not {\\tld2w\\t} } } */\n+/* { dg-final { scan-assembler-not {\\tst2w\\t} } } */\n+/* { dg-final { scan-assembler-times {\\tld1w\\t} 48 } } */\n+/* { dg-final { scan-assembler-times {\\tst1w\\t} 40 } } */"}, {"sha": "4dc03efd1dee6bff3fc538c2dda4556d6eb5821f", "filename": "gcc/tree-data-ref.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/997636716c5dde7d59d026726a6f58918069f122/gcc%2Ftree-data-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/997636716c5dde7d59d026726a6f58918069f122/gcc%2Ftree-data-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.c?ref=997636716c5dde7d59d026726a6f58918069f122", "patch": "@@ -1271,7 +1271,7 @@ create_data_ref (edge nest, loop_p loop, tree memref, gimple *stmt,\n   return dr;\n }\n \n-/*  A helper function computes order between two tree epxressions T1 and T2.\n+/*  A helper function computes order between two tree expressions T1 and T2.\n     This is used in comparator functions sorting objects based on the order\n     of tree expressions.  The function returns -1, 0, or 1.  */\n "}, {"sha": "55d87f8f59fd6b292ff15c2466c1dcd292623240", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/997636716c5dde7d59d026726a6f58918069f122/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/997636716c5dde7d59d026726a6f58918069f122/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=997636716c5dde7d59d026726a6f58918069f122", "patch": "@@ -2863,10 +2863,12 @@ strip_conversion (tree op)\n }\n \n /* Return true if vectorizable_* routines can handle statements STMT1_INFO\n-   and STMT2_INFO being in a single group.  */\n+   and STMT2_INFO being in a single group.  When ALLOW_SLP_P, masked loads can\n+   be grouped in SLP mode.  */\n \n static bool\n-can_group_stmts_p (stmt_vec_info stmt1_info, stmt_vec_info stmt2_info)\n+can_group_stmts_p (stmt_vec_info stmt1_info, stmt_vec_info stmt2_info,\n+\t\t   bool allow_slp_p)\n {\n   if (gimple_assign_single_p (stmt1_info->stmt))\n     return gimple_assign_single_p (stmt2_info->stmt);\n@@ -2888,7 +2890,8 @@ can_group_stmts_p (stmt_vec_info stmt1_info, stmt_vec_info stmt2_info)\n \t like those created by build_mask_conversion.  */\n       tree mask1 = gimple_call_arg (call1, 2);\n       tree mask2 = gimple_call_arg (call2, 2);\n-      if (!operand_equal_p (mask1, mask2, 0))\n+      if (!operand_equal_p (mask1, mask2, 0)\n+          && (ifn == IFN_MASK_STORE || !allow_slp_p))\n \t{\n \t  mask1 = strip_conversion (mask1);\n \t  if (!mask1)\n@@ -2974,7 +2977,7 @@ vect_analyze_data_ref_accesses (vec_info *vinfo)\n \t      || data_ref_compare_tree (DR_BASE_ADDRESS (dra),\n \t\t\t\t\tDR_BASE_ADDRESS (drb)) != 0\n \t      || data_ref_compare_tree (DR_OFFSET (dra), DR_OFFSET (drb)) != 0\n-\t      || !can_group_stmts_p (stmtinfo_a, stmtinfo_b))\n+\t      || !can_group_stmts_p (stmtinfo_a, stmtinfo_b, true))\n \t    break;\n \n \t  /* Check that the data-refs have the same constant size.  */\n@@ -3059,6 +3062,13 @@ vect_analyze_data_ref_accesses (vec_info *vinfo)\n \t  DR_GROUP_NEXT_ELEMENT (lastinfo) = stmtinfo_b;\n \t  lastinfo = stmtinfo_b;\n \n+\t  STMT_VINFO_SLP_VECT_ONLY (stmtinfo_a)\n+\t    = !can_group_stmts_p (stmtinfo_a, stmtinfo_b, false);\n+\n+\t  if (dump_enabled_p () && STMT_VINFO_SLP_VECT_ONLY (stmtinfo_a))\n+\t    dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t     \"Load suitable for SLP vectorization only.\\n\");\n+\n \t  if (init_b == init_prev\n \t      && !to_fixup.add (DR_GROUP_FIRST_ELEMENT (stmtinfo_a))\n \t      && dump_enabled_p ())"}, {"sha": "4942c6937e00859be9b065dee89f302d3373c387", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/997636716c5dde7d59d026726a6f58918069f122/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/997636716c5dde7d59d026726a6f58918069f122/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=997636716c5dde7d59d026726a6f58918069f122", "patch": "@@ -1774,6 +1774,50 @@ vect_get_datarefs_in_loop (loop_p loop, basic_block *bbs,\n   return opt_result::success ();\n }\n \n+/* Look for SLP-only access groups and turn each individual access into its own\n+   group.  */\n+static void\n+vect_dissolve_slp_only_groups (loop_vec_info loop_vinfo)\n+{\n+  unsigned int i;\n+  struct data_reference *dr;\n+\n+  DUMP_VECT_SCOPE (\"vect_dissolve_slp_only_groups\");\n+\n+  vec<data_reference_p> datarefs = loop_vinfo->shared->datarefs;\n+  FOR_EACH_VEC_ELT (datarefs, i, dr)\n+    {\n+      gcc_assert (DR_REF (dr));\n+      stmt_vec_info stmt_info = loop_vinfo->lookup_stmt (DR_STMT (dr));\n+\n+      /* Check if the load is a part of an interleaving chain.  */\n+      if (STMT_VINFO_GROUPED_ACCESS (stmt_info))\n+\t{\n+\t  stmt_vec_info first_element = DR_GROUP_FIRST_ELEMENT (stmt_info);\n+\t  unsigned int group_size = DR_GROUP_SIZE (first_element);\n+\n+\t  /* Check if SLP-only groups.  */\n+\t  if (!STMT_SLP_TYPE (stmt_info)\n+\t      && STMT_VINFO_SLP_VECT_ONLY (first_element))\n+\t    {\n+\t      /* Dissolve the group.  */\n+\t      STMT_VINFO_SLP_VECT_ONLY (first_element) = false;\n+\n+\t      stmt_vec_info vinfo = first_element;\n+\t      while (vinfo)\n+\t\t{\n+\t\t  stmt_vec_info next = DR_GROUP_NEXT_ELEMENT (vinfo);\n+\t\t  DR_GROUP_FIRST_ELEMENT (vinfo) = vinfo;\n+\t\t  DR_GROUP_NEXT_ELEMENT (vinfo) = NULL;\n+\t\t  DR_GROUP_SIZE (vinfo) = 1;\n+\t\t  DR_GROUP_GAP (vinfo) = group_size - 1;\n+\t\t  vinfo = next;\n+\t\t}\n+\t    }\n+\t}\n+    }\n+}\n+\n /* Function vect_analyze_loop_2.\n \n    Apply a set of analyses on LOOP, and create a loop_vec_info struct\n@@ -1990,6 +2034,9 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo, bool &fatal, unsigned *n_stmts)\n \t}\n     }\n \n+  /* Dissolve SLP-only groups.  */\n+  vect_dissolve_slp_only_groups (loop_vinfo);\n+\n   /* Scan all the remaining operations in the loop that are not subject\n      to SLP and make sure they are vectorizable.  */\n   ok = vect_analyze_loop_operations (loop_vinfo);"}, {"sha": "884db33c8ec61ceff24a07ce71a30acba7d9f1f5", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 23, "deletions": 6, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/997636716c5dde7d59d026726a6f58918069f122/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/997636716c5dde7d59d026726a6f58918069f122/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=997636716c5dde7d59d026726a6f58918069f122", "patch": "@@ -325,6 +325,14 @@ vect_get_and_check_slp_defs (vec_info *vinfo, unsigned char *swap,\n \t{\n \t  internal_fn ifn = gimple_call_internal_fn (stmt);\n \t  commutative_op = first_commutative_argument (ifn);\n+\n+\t  /* Masked load, only look at mask.  */\n+\t  if (ifn == IFN_MASK_LOAD)\n+\t    {\n+\t      number_of_oprnds = 1;\n+\t      /* Mask operand index.  */\n+\t      first_op_idx = 5;\n+\t    }\n \t}\n     }\n   else if (gassign *stmt = dyn_cast <gassign *> (stmt_info->stmt))\n@@ -626,7 +634,7 @@ vect_two_operations_perm_ok_p (vec<stmt_vec_info> stmts,\n    is false then this indicates the comparison could not be\n    carried out or the stmts will never be vectorized by SLP.\n \n-   Note COND_EXPR is possibly ismorphic to another one after swapping its\n+   Note COND_EXPR is possibly isomorphic to another one after swapping its\n    operands.  Set SWAP[i] to 1 if stmt I is COND_EXPR and isomorphic to\n    the first stmt by swapping the two operands of comparison; set SWAP[i]\n    to 2 if stmt I is isormorphic to the first stmt by inverting the code\n@@ -1146,14 +1154,23 @@ vect_build_slp_tree_2 (vec_info *vinfo,\n \t\t\t      &this_max_nunits, matches, &two_operators))\n     return NULL;\n \n-  /* If the SLP node is a load, terminate the recursion.  */\n+  /* If the SLP node is a load, terminate the recursion unless masked.  */\n   if (STMT_VINFO_GROUPED_ACCESS (stmt_info)\n       && DR_IS_READ (STMT_VINFO_DATA_REF (stmt_info)))\n     {\n-      *max_nunits = this_max_nunits;\n-      (*tree_size)++;\n-      node = vect_create_new_slp_node (stmts);\n-      return node;\n+      if (gcall *stmt = dyn_cast <gcall *> (stmt_info->stmt))\n+\t{\n+\t  /* Masked load.  */\n+\t  gcc_assert (gimple_call_internal_p (stmt, IFN_MASK_LOAD));\n+\t  nops = 1;\n+\t}\n+      else\n+\t{\n+\t  *max_nunits = this_max_nunits;\n+\t  (*tree_size)++;\n+\t  node = vect_create_new_slp_node (stmts);\n+\t  return node;\n+\t}\n     }\n \n   /* Get at the operands, verifying they are compatible.  */"}, {"sha": "21046931243d4cc01fd8d98d9af3f734079c14d3", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 22, "deletions": 10, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/997636716c5dde7d59d026726a6f58918069f122/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/997636716c5dde7d59d026726a6f58918069f122/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=997636716c5dde7d59d026726a6f58918069f122", "patch": "@@ -7622,14 +7622,6 @@ vectorizable_load (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n       if (!scalar_dest)\n \treturn false;\n \n-      if (slp_node != NULL)\n-\t{\n-\t  if (dump_enabled_p ())\n-\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t     \"SLP of masked loads not supported.\\n\");\n-\t  return false;\n-\t}\n-\n       int mask_index = internal_fn_mask_index (ifn);\n       if (mask_index >= 0)\n \t{\n@@ -7712,6 +7704,15 @@ vectorizable_load (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n       first_stmt_info = DR_GROUP_FIRST_ELEMENT (stmt_info);\n       group_size = DR_GROUP_SIZE (first_stmt_info);\n \n+      /* Refuse non-SLP vectorization of SLP-only groups.  */\n+      if (!slp && STMT_VINFO_SLP_VECT_ONLY (first_stmt_info))\n+\t{\n+\t  if (dump_enabled_p ())\n+\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t     \"cannot vectorize load in non-SLP mode.\\n\");\n+\t  return false;\n+\t}\n+\n       if (slp && SLP_TREE_LOAD_PERMUTATION (slp_node).exists ())\n \tslp_perm = true;\n \n@@ -8389,8 +8390,19 @@ vectorizable_load (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n \t\t\t\t\t  simd_lane_access_p,\n \t\t\t\t\t  byte_offset, bump);\n \t  if (mask)\n-\t    vec_mask = vect_get_vec_def_for_operand (mask, stmt_info,\n-\t\t\t\t\t\t     mask_vectype);\n+\t    {\n+\t      if (slp_node)\n+\t\t{\n+\t\t  auto_vec<tree> ops (1);\n+\t\t  auto_vec<vec<tree> > vec_defs (1);\n+\t\t  ops.quick_push (mask);\n+\t\t  vect_get_slp_defs (ops, slp_node, &vec_defs);\n+\t\t  vec_mask = vec_defs[0][0];\n+\t\t}\n+\t      else\n+\t\tvec_mask = vect_get_vec_def_for_operand (mask, stmt_info,\n+\t\t\t\t\t\t\t mask_vectype);\n+\t    }\n \t}\n       else\n \t{"}, {"sha": "4f6c65faf640acfb79ce40d8b75fff041566c396", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/997636716c5dde7d59d026726a6f58918069f122/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/997636716c5dde7d59d026726a6f58918069f122/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=997636716c5dde7d59d026726a6f58918069f122", "patch": "@@ -641,6 +641,7 @@ vec_info::new_stmt_vec_info (gimple *stmt)\n   STMT_VINFO_VECTORIZABLE (res) = true;\n   STMT_VINFO_VEC_REDUCTION_TYPE (res) = TREE_CODE_REDUCTION;\n   STMT_VINFO_VEC_CONST_COND_REDUC_CODE (res) = ERROR_MARK;\n+  STMT_VINFO_SLP_VECT_ONLY (res) = false;\n \n   if (gimple_code (stmt) == GIMPLE_PHI\n       && is_loop_header_bb_p (gimple_bb (stmt)))"}, {"sha": "4db30ccc22bba1dd2013570fe4a9d6bfae3f90c4", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/997636716c5dde7d59d026726a6f58918069f122/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/997636716c5dde7d59d026726a6f58918069f122/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=997636716c5dde7d59d026726a6f58918069f122", "patch": "@@ -396,7 +396,7 @@ typedef struct _loop_vec_info : public vec_info {\n   /* Condition under which this loop is analyzed and versioned.  */\n   tree num_iters_assumptions;\n \n-  /* Threshold of number of iterations below which vectorzation will not be\n+  /* Threshold of number of iterations below which vectorization will not be\n      performed. It is calculated from MIN_PROFITABLE_ITERS and\n      PARAM_MIN_VECT_LOOP_BOUND.  */\n   unsigned int th;\n@@ -946,6 +946,9 @@ struct _stmt_vec_info {\n      and OPERATION_BITS without changing the result.  */\n   unsigned int operation_precision;\n   signop operation_sign;\n+\n+  /* True if this is only suitable for SLP vectorization.  */\n+  bool slp_vect_only_p;\n };\n \n /* Information about a gather/scatter call.  */\n@@ -1041,6 +1044,7 @@ STMT_VINFO_BB_VINFO (stmt_vec_info stmt_vinfo)\n #define STMT_VINFO_NUM_SLP_USES(S)\t(S)->num_slp_uses\n #define STMT_VINFO_REDUC_TYPE(S)\t(S)->reduc_type\n #define STMT_VINFO_REDUC_DEF(S)\t\t(S)->reduc_def\n+#define STMT_VINFO_SLP_VECT_ONLY(S)     (S)->slp_vect_only_p\n \n #define DR_GROUP_FIRST_ELEMENT(S) \\\n   (gcc_checking_assert ((S)->dr_aux.dr), (S)->first_element)"}]}