{"sha": "868363d4f52df19d8d5e9529b8906fa25c8d0c95", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODY4MzYzZDRmNTJkZjE5ZDhkNWU5NTI5Yjg5MDZmYTI1YzhkMGM5NQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2019-08-05T16:46:58Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2019-08-05T16:46:58Z"}, "message": "Fold MASK_LOAD/STORE with an all-true mask\n\nThis patch folds IFN_MASK_LOAD and IFN_MASK_STOREs to normal accesses\nif the mask is all-true.  This can happen for fully-masked loops that\ndidn't actually need to be (which could be handled by the vectoriser\ninstead), or for unrolled fully-masked loops whose first iteration is\nguaranteed to operate on a full vector.  It's also useful when the\naccesses are generated directly by intrinsics (to follow for SVE).\n\n2019-08-05  Richard Sandiford  <richard.sandiford@arm.com>\n\ngcc/\n\t* gimple-fold.c (gimple_fold_mask_load_store_mem_ref)\n\t(gimple_fold_mask_load, gimple_fold_mask_store): New functions.\n\t(gimple_fold_call): Use them to fold IFN_MASK_LOAD and\n\tIFN_MASK_STORE.\n\ngcc/testsuite/\n\t* gcc.target/aarch64/sve/mask_load_1.c: New test.\n\nFrom-SVN: r274118", "tree": {"sha": "53d8dc707b6539ee636b896399f561e66e1c88d6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/53d8dc707b6539ee636b896399f561e66e1c88d6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/868363d4f52df19d8d5e9529b8906fa25c8d0c95", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/868363d4f52df19d8d5e9529b8906fa25c8d0c95", "html_url": "https://github.com/Rust-GCC/gccrs/commit/868363d4f52df19d8d5e9529b8906fa25c8d0c95", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/868363d4f52df19d8d5e9529b8906fa25c8d0c95/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "779724a5913b4e6a7ccccc0b8b415a772144a067", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/779724a5913b4e6a7ccccc0b8b415a772144a067", "html_url": "https://github.com/Rust-GCC/gccrs/commit/779724a5913b4e6a7ccccc0b8b415a772144a067"}], "stats": {"total": 86, "additions": 86, "deletions": 0}, "files": [{"sha": "26ada9c99916a63d8a9d582cd998cf364700acde", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/868363d4f52df19d8d5e9529b8906fa25c8d0c95/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/868363d4f52df19d8d5e9529b8906fa25c8d0c95/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=868363d4f52df19d8d5e9529b8906fa25c8d0c95", "patch": "@@ -1,3 +1,10 @@\n+2019-08-05  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* gimple-fold.c (gimple_fold_mask_load_store_mem_ref)\n+\t(gimple_fold_mask_load, gimple_fold_mask_store): New functions.\n+\t(gimple_fold_call): Use them to fold IFN_MASK_LOAD and\n+\tIFN_MASK_STORE.\n+\n 2019-08-05  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* gimple.h (gimple_move_vops): Declare."}, {"sha": "fc57fb45e3ac080cf2e36b471ce48227dc8a91f7", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/868363d4f52df19d8d5e9529b8906fa25c8d0c95/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/868363d4f52df19d8d5e9529b8906fa25c8d0c95/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=868363d4f52df19d8d5e9529b8906fa25c8d0c95", "patch": "@@ -4180,6 +4180,63 @@ arith_overflowed_p (enum tree_code code, const_tree type,\n   return wi::min_precision (wres, sign) > TYPE_PRECISION (type);\n }\n \n+/* If IFN_MASK_LOAD/STORE call CALL is unconditional, return a MEM_REF\n+   for the memory it references, otherwise return null.  VECTYPE is the\n+   type of the memory vector.  */\n+\n+static tree\n+gimple_fold_mask_load_store_mem_ref (gcall *call, tree vectype)\n+{\n+  tree ptr = gimple_call_arg (call, 0);\n+  tree alias_align = gimple_call_arg (call, 1);\n+  tree mask = gimple_call_arg (call, 2);\n+  if (!tree_fits_uhwi_p (alias_align) || !integer_all_onesp (mask))\n+    return NULL_TREE;\n+\n+  unsigned HOST_WIDE_INT align = tree_to_uhwi (alias_align) * BITS_PER_UNIT;\n+  if (TYPE_ALIGN (vectype) != align)\n+    vectype = build_aligned_type (vectype, align);\n+  tree offset = build_zero_cst (TREE_TYPE (alias_align));\n+  return fold_build2 (MEM_REF, vectype, ptr, offset);\n+}\n+\n+/* Try to fold IFN_MASK_LOAD call CALL.  Return true on success.  */\n+\n+static bool\n+gimple_fold_mask_load (gimple_stmt_iterator *gsi, gcall *call)\n+{\n+  tree lhs = gimple_call_lhs (call);\n+  if (!lhs)\n+    return false;\n+\n+  if (tree rhs = gimple_fold_mask_load_store_mem_ref (call, TREE_TYPE (lhs)))\n+    {\n+      gassign *new_stmt = gimple_build_assign (lhs, rhs);\n+      gimple_set_location (new_stmt, gimple_location (call));\n+      gimple_move_vops (new_stmt, call);\n+      gsi_replace (gsi, new_stmt, false);\n+      return true;\n+    }\n+  return false;\n+}\n+\n+/* Try to fold IFN_MASK_STORE call CALL.  Return true on success.  */\n+\n+static bool\n+gimple_fold_mask_store (gimple_stmt_iterator *gsi, gcall *call)\n+{\n+  tree rhs = gimple_call_arg (call, 3);\n+  if (tree lhs = gimple_fold_mask_load_store_mem_ref (call, TREE_TYPE (rhs)))\n+    {\n+      gassign *new_stmt = gimple_build_assign (lhs, rhs);\n+      gimple_set_location (new_stmt, gimple_location (call));\n+      gimple_move_vops (new_stmt, call);\n+      gsi_replace (gsi, new_stmt, false);\n+      return true;\n+    }\n+  return false;\n+}\n+\n /* Attempt to fold a call statement referenced by the statement iterator GSI.\n    The statement may be replaced by another statement, e.g., if the call\n    simplifies to a constant value. Return true if any changes were made.\n@@ -4409,6 +4466,12 @@ gimple_fold_call (gimple_stmt_iterator *gsi, bool inplace)\n \t  subcode = MULT_EXPR;\n \t  cplx_result = true;\n \t  break;\n+\tcase IFN_MASK_LOAD:\n+\t  changed |= gimple_fold_mask_load (gsi, stmt);\n+\t  break;\n+\tcase IFN_MASK_STORE:\n+\t  changed |= gimple_fold_mask_store (gsi, stmt);\n+\t  break;\n \tdefault:\n \t  break;\n \t}"}, {"sha": "2db452910db7ad29dbfbb8a86189400d5eb47be1", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/868363d4f52df19d8d5e9529b8906fa25c8d0c95/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/868363d4f52df19d8d5e9529b8906fa25c8d0c95/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=868363d4f52df19d8d5e9529b8906fa25c8d0c95", "patch": "@@ -1,3 +1,7 @@\n+2019-08-05  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* gcc.target/aarch64/sve/mask_load_1.c: New test.\n+\n 2019-08-05  Jozef Lawrynowicz  <jozef.l@mittosystems.com>\n \n \t* gcc.target/msp430/pr80993.c: Add cleanup-saved-temps to final"}, {"sha": "e76d365cb620aeb44ce18bcc564534bfb0b2495b", "filename": "gcc/testsuite/gcc.target/aarch64/sve/mask_load_1.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/868363d4f52df19d8d5e9529b8906fa25c8d0c95/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fmask_load_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/868363d4f52df19d8d5e9529b8906fa25c8d0c95/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fmask_load_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fmask_load_1.c?ref=868363d4f52df19d8d5e9529b8906fa25c8d0c95", "patch": "@@ -0,0 +1,12 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -ftree-vectorize -msve-vector-bits=256 -fdump-tree-optimized\" } */\n+\n+void\n+f (int *x)\n+{\n+  for (int i = 0; i < 8; ++i)\n+    x[i] += 1;\n+}\n+\n+/* { dg-final { scan-tree-dump { = MEM <vector\\(8\\) int>} \"optimized\" } } */\n+/* { dg-final { scan-tree-dump { MEM <vector\\(8\\) int> \\[[^]]*\\] = } \"optimized\" } } */"}]}