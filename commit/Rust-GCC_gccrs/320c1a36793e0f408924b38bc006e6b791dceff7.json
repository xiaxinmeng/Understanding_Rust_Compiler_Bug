{"sha": "320c1a36793e0f408924b38bc006e6b791dceff7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzIwYzFhMzY3OTNlMGY0MDg5MjRiMzhiYzAwNmU2Yjc5MWRjZWZmNw==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2016-03-31T17:10:15Z"}, "committer": {"name": "Martin Liska", "email": "marxin@gcc.gnu.org", "date": "2016-03-31T17:10:15Z"}, "message": "HSA: support alignment for hsa_symbols (PR hsa/70391)\n\n\tPR hsa/70391\n\t* hsa-brig.c (emit_directive_variable): Emit alignment\n\taccording to hsa_symbol::m_align.\n\t* hsa-dump.c (hsa_byte_alignment): Move the function to\n\tanother file.\n\t(dump_hsa_symbol): Dump alignment of HSA symbols.\n\t* hsa-gen.c (get_symbol_for_decl): Set-up alignment\n\tof a symbol.\n\t(gen_hsa_addr_with_align): New function.\n\t(hsa_bitmemref_alignment): Use newly added function.\n\t(gen_hsa_insns_for_load): Likewise.\n\t(gen_hsa_insns_for_store): Likewise.\n\t(gen_hsa_memory_copy): New argument added.\n\t(gen_hsa_insns_for_single_assignment): Respect\n\talignment for assignments processed via\n\tgen_hsa_memory_copy.\n\t(gen_hsa_insns_for_direct_call): Likewise.\n\t(gen_hsa_insns_for_return): Likewise.\n\t(gen_function_def_parameters): Set default\n\talignment.\n\t* hsa.c (hsa_object_alignment): New function.\n\t(hsa_byte_alignment): Pasted function.\n\t* hsa.h (hsa_symbol::m_align): New field.\n\nFrom-SVN: r234643", "tree": {"sha": "5ed5ca7dff70ab72534570302bae6e0c19e1b345", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5ed5ca7dff70ab72534570302bae6e0c19e1b345"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/320c1a36793e0f408924b38bc006e6b791dceff7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/320c1a36793e0f408924b38bc006e6b791dceff7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/320c1a36793e0f408924b38bc006e6b791dceff7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/320c1a36793e0f408924b38bc006e6b791dceff7/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8f80cbdb26ca754ff3b6fe6c735eca6dd01401fa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8f80cbdb26ca754ff3b6fe6c735eca6dd01401fa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8f80cbdb26ca754ff3b6fe6c735eca6dd01401fa"}], "stats": {"total": 160, "additions": 125, "deletions": 35}, "files": [{"sha": "83f1cb6e6ae755117a61d5f17f24976038aa8593", "filename": "gcc/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/320c1a36793e0f408924b38bc006e6b791dceff7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/320c1a36793e0f408924b38bc006e6b791dceff7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=320c1a36793e0f408924b38bc006e6b791dceff7", "patch": "@@ -1,3 +1,29 @@\n+2016-03-31  Martin Liska  <mliska@suse.cz>\n+\n+\tPR hsa/70391\n+\t* hsa-brig.c (emit_directive_variable): Emit alignment\n+\taccording to hsa_symbol::m_align.\n+\t* hsa-dump.c (hsa_byte_alignment): Move the function to\n+\tanother file.\n+\t(dump_hsa_symbol): Dump alignment of HSA symbols.\n+\t* hsa-gen.c (get_symbol_for_decl): Set-up alignment\n+\tof a symbol.\n+\t(gen_hsa_addr_with_align): New function.\n+\t(hsa_bitmemref_alignment): Use newly added function.\n+\t(gen_hsa_insns_for_load): Likewise.\n+\t(gen_hsa_insns_for_store): Likewise.\n+\t(gen_hsa_memory_copy): New argument added.\n+\t(gen_hsa_insns_for_single_assignment): Respect\n+\talignment for assignments processed via\n+\tgen_hsa_memory_copy.\n+\t(gen_hsa_insns_for_direct_call): Likewise.\n+\t(gen_hsa_insns_for_return): Likewise.\n+\t(gen_function_def_parameters): Set default\n+\talignment.\n+\t* hsa.c (hsa_object_alignment): New function.\n+\t(hsa_byte_alignment): Pasted function.\n+\t* hsa.h (hsa_symbol::m_align): New field.\n+\n 2016-03-31  Bin Cheng  <bin.cheng@arm.com>\n \n \t* tree-ssa-loop-ivopts.c (get_computation_cost_at): Initialize"}, {"sha": "ee587dbc066ce12a3667511a5155bf2a5d7c42df", "filename": "gcc/hsa-brig.c", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/320c1a36793e0f408924b38bc006e6b791dceff7/gcc%2Fhsa-brig.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/320c1a36793e0f408924b38bc006e6b791dceff7/gcc%2Fhsa-brig.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhsa-brig.c?ref=320c1a36793e0f408924b38bc006e6b791dceff7", "patch": "@@ -605,10 +605,7 @@ emit_directive_variable (struct hsa_symbol *symbol)\n   dirvar.init = 0;\n   dirvar.type = lendian16 (symbol->m_type);\n   dirvar.segment = symbol->m_segment;\n-  /* TODO: Once we are able to access global variables, we must copy their\n-     alignment.  */\n-  dirvar.align = MAX (hsa_natural_alignment (dirvar.type),\n-\t\t      (BrigAlignment8_t) BRIG_ALIGNMENT_4);\n+  dirvar.align = symbol->m_align;\n   dirvar.linkage = symbol->m_linkage;\n   dirvar.dim.lo = symbol->m_dim;\n   dirvar.dim.hi = symbol->m_dim >> 32;"}, {"sha": "d33ac4b7857e7ebd8d9875a641df53cf4193de94", "filename": "gcc/hsa-dump.c", "status": "modified", "additions": 2, "deletions": 11, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/320c1a36793e0f408924b38bc006e6b791dceff7/gcc%2Fhsa-dump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/320c1a36793e0f408924b38bc006e6b791dceff7/gcc%2Fhsa-dump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhsa-dump.c?ref=320c1a36793e0f408924b38bc006e6b791dceff7", "patch": "@@ -621,16 +621,6 @@ hsa_m_atomicop_name (enum BrigAtomicOperation op)\n     }\n }\n \n-/* Return byte alignment for given BrigAlignment8_t value.  */\n-\n-static unsigned\n-hsa_byte_alignment (BrigAlignment8_t alignment)\n-{\n-  gcc_assert (alignment != BRIG_ALIGNMENT_NONE);\n-\n-  return 1 << (alignment - 1);\n-}\n-\n /* Dump textual representation of HSA IL register REG to file F.  */\n \n static void\n@@ -716,7 +706,8 @@ dump_hsa_symbol (FILE *f, hsa_symbol *symbol)\n       name = buf;\n     }\n \n-  fprintf (f, \"%s_%s %s\", hsa_seg_name (symbol->m_segment),\n+  fprintf (f, \"align(%u) %s_%s %s\", hsa_byte_alignment (symbol->m_align),\n+\t   hsa_seg_name (symbol->m_segment),\n \t   hsa_type_name (symbol->m_type & ~BRIG_TYPE_ARRAY_MASK), name);\n \n   if (symbol->m_type & BRIG_TYPE_ARRAY_MASK)"}, {"sha": "55c46cadf03e7f69fe12dc092a79342e096bc638", "filename": "gcc/hsa-gen.c", "status": "modified", "additions": 69, "deletions": 19, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/320c1a36793e0f408924b38bc006e6b791dceff7/gcc%2Fhsa-gen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/320c1a36793e0f408924b38bc006e6b791dceff7/gcc%2Fhsa-gen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhsa-gen.c?ref=320c1a36793e0f408924b38bc006e6b791dceff7", "patch": "@@ -169,12 +169,12 @@ hsa_symbol::hsa_symbol ()\n \n hsa_symbol::hsa_symbol (BrigType16_t type, BrigSegment8_t segment,\n \t\t\tBrigLinkage8_t linkage, bool global_scope_p,\n-\t\t\tBrigAllocation allocation)\n+\t\t\tBrigAllocation allocation, BrigAlignment8_t align)\n   : m_decl (NULL_TREE), m_name (NULL), m_name_number (0),\n     m_directive_offset (0), m_type (type), m_segment (segment),\n     m_linkage (linkage), m_dim (0), m_cst_value (NULL),\n     m_global_scope_p (global_scope_p), m_seen_error (false),\n-    m_allocation (allocation), m_emitted_to_brig (false)\n+    m_allocation (allocation), m_emitted_to_brig (false), m_align (align)\n {\n }\n \n@@ -908,21 +908,29 @@ get_symbol_for_decl (tree decl)\n     {\n       hsa_symbol *sym;\n       gcc_assert (TREE_CODE (decl) == VAR_DECL);\n+      BrigAlignment8_t align = hsa_object_alignment (decl);\n \n       if (is_in_global_vars)\n \t{\n \t  sym = new hsa_symbol (BRIG_TYPE_NONE, BRIG_SEGMENT_GLOBAL,\n \t\t\t\tBRIG_LINKAGE_PROGRAM, true,\n-\t\t\t\tBRIG_ALLOCATION_PROGRAM);\n+\t\t\t\tBRIG_ALLOCATION_PROGRAM, align);\n \t  hsa_cfun->m_global_symbols.safe_push (sym);\n \t}\n       else\n \t{\n+\t  /* As generation of efficient memory copy instructions relies\n+\t     on alignment greater or equal to 8 bytes,\n+\t     we need to increase alignment of all aggregate types.. */\n+\t  if (AGGREGATE_TYPE_P (TREE_TYPE (decl)))\n+\t    align = MAX ((BrigAlignment8_t) BRIG_ALIGNMENT_8, align);\n+\n \t  /* PARM_DECL and RESULT_DECL should be already in m_local_symbols.  */\n \t  gcc_assert (TREE_CODE (decl) == VAR_DECL);\n \n \t  sym = new hsa_symbol (BRIG_TYPE_NONE, BRIG_SEGMENT_PRIVATE,\n \t\t\t\tBRIG_LINKAGE_FUNCTION);\n+\t  sym->m_align = align;\n \t  hsa_cfun->m_private_variables.safe_push (sym);\n \t}\n \n@@ -2192,6 +2200,30 @@ gen_hsa_addr (tree ref, hsa_bb *hbb, HOST_WIDE_INT *output_bitsize = NULL,\n   return new hsa_op_address (symbol, reg, hwi_offset);\n }\n \n+/* Generate HSA address operand for a given tree memory reference REF.  If\n+   instructions need to be created to calculate the address, they will be added\n+   to the end of HBB.  OUTPUT_ALIGN is alignment of the created address.  */\n+\n+static hsa_op_address *\n+gen_hsa_addr_with_align (tree ref, hsa_bb *hbb, BrigAlignment8_t *output_align)\n+{\n+  hsa_op_address *addr = gen_hsa_addr (ref, hbb);\n+  if (addr->m_reg || !addr->m_symbol)\n+    *output_align = hsa_object_alignment (ref);\n+  else\n+    {\n+      /* If the address consists only of a symbol and an offset, we\n+         compute the alignment ourselves to take into account any alignment\n+         promotions we might have done for the HSA symbol representation.  */\n+      unsigned align = hsa_byte_alignment (addr->m_symbol->m_align);\n+      unsigned misalign = addr->m_imm_offset & (align - 1);\n+      if (misalign)\n+        align = (misalign & -misalign);\n+      *output_align = hsa_alignment_encoding (BITS_PER_UNIT * align);\n+    }\n+  return addr;\n+}\n+\n /* Generate HSA address for a function call argument of given TYPE.\n    INDEX is used to generate corresponding name of the arguments.\n    Special value -1 represents fact that result value is created.  */\n@@ -2398,7 +2430,7 @@ hsa_bitmemref_alignment (tree ref)\n \n   unsigned HOST_WIDE_INT bits = bit_offset % BITS_PER_UNIT;\n   unsigned HOST_WIDE_INT byte_bits = bit_offset - bits;\n-  BrigAlignment8_t base = hsa_alignment_encoding (get_object_alignment (ref));\n+  BrigAlignment8_t base = hsa_object_alignment (ref);\n   if (byte_bits == 0)\n     return base;\n   return MIN (base, hsa_alignment_encoding (byte_bits & -byte_bits));\n@@ -2537,7 +2569,7 @@ gen_hsa_insns_for_load (hsa_op_reg *dest, tree rhs, tree type, hsa_bb *hbb)\n \t\t\t\t\t\t\t\t    false));\n \t  hsa_insn_mem *mem = new hsa_insn_mem (BRIG_OPCODE_LD, mtype, dest,\n \t\t\t\t\t\taddr);\n-\t  mem->set_align (hsa_alignment_encoding (get_object_alignment (rhs)));\n+\t  mem->set_align (hsa_object_alignment (rhs));\n \t  hbb->append_insn (mem);\n \t}\n     }\n@@ -2656,7 +2688,7 @@ gen_hsa_insns_for_store (tree lhs, hsa_op_base *src, hsa_bb *hbb)\n       mtype = mem_type;\n     }\n   else\n-    req_align = hsa_alignment_encoding (get_object_alignment (lhs));\n+    req_align = hsa_object_alignment (lhs);\n \n   hsa_insn_mem *mem = new hsa_insn_mem (BRIG_OPCODE_ST, mtype, src, addr);\n   mem->set_align (req_align);\n@@ -2697,16 +2729,18 @@ gen_hsa_insns_for_store (tree lhs, hsa_op_base *src, hsa_bb *hbb)\n \n /* Generate memory copy instructions that are going to be used\n    for copying a HSA symbol SRC_SYMBOL (or SRC_REG) to TARGET memory,\n-   represented by pointer in a register.  */\n+   represented by pointer in a register.  MIN_ALIGN is minimal alignment\n+   of provided HSA addresses. */\n \n static void\n gen_hsa_memory_copy (hsa_bb *hbb, hsa_op_address *target, hsa_op_address *src,\n-\t\t     unsigned size)\n+\t\t     unsigned size, BrigAlignment8_t min_align)\n {\n   hsa_op_address *addr;\n   hsa_insn_mem *mem;\n \n   unsigned offset = 0;\n+  unsigned min_byte_align = hsa_byte_alignment (min_align);\n \n   while (size)\n     {\n@@ -2720,6 +2754,9 @@ gen_hsa_memory_copy (hsa_bb *hbb, hsa_op_address *target, hsa_op_address *src,\n       else\n \ts = 1;\n \n+      if (s > min_byte_align)\n+\ts = min_byte_align;\n+\n       BrigType16_t t = get_integer_type_by_bytes (s, false);\n \n       hsa_op_reg *tmp = new hsa_op_reg (t);\n@@ -2837,16 +2874,21 @@ gen_hsa_insns_for_single_assignment (tree lhs, tree rhs, hsa_bb *hbb)\n     }\n   else\n     {\n-      hsa_op_address *addr_lhs = gen_hsa_addr (lhs, hbb);\n+      BrigAlignment8_t lhs_align;\n+      hsa_op_address *addr_lhs = gen_hsa_addr_with_align (lhs, hbb,\n+\t\t\t\t\t\t\t  &lhs_align);\n \n       if (TREE_CODE (rhs) == CONSTRUCTOR)\n \tgen_hsa_ctor_assignment (addr_lhs, rhs, hbb);\n       else\n \t{\n-\t  hsa_op_address *addr_rhs = gen_hsa_addr (rhs, hbb);\n+\t  BrigAlignment8_t rhs_align;\n+\t  hsa_op_address *addr_rhs = gen_hsa_addr_with_align (rhs, hbb,\n+\t\t\t\t\t\t\t      &rhs_align);\n \n \t  unsigned size = tree_to_uhwi (TYPE_SIZE_UNIT (TREE_TYPE (rhs)));\n-\t  gen_hsa_memory_copy (hbb, addr_lhs, addr_rhs, size);\n+\t  gen_hsa_memory_copy (hbb, addr_lhs, addr_rhs, size,\n+\t\t\t       MIN (lhs_align, rhs_align));\n \t}\n     }\n }\n@@ -3513,9 +3555,10 @@ gen_hsa_insns_for_direct_call (gimple *stmt, hsa_bb *hbb)\n       if (AGGREGATE_TYPE_P (TREE_TYPE (parm)))\n \t{\n \t  addr = gen_hsa_addr_for_arg (TREE_TYPE (parm), i);\n-\t  hsa_op_address *src = gen_hsa_addr (parm, hbb);\n+\t  BrigAlignment8_t align;\n+\t  hsa_op_address *src = gen_hsa_addr_with_align (parm, hbb, &align);\n \t  gen_hsa_memory_copy (hbb, addr, src,\n-\t\t\t       addr->m_symbol->total_byte_size ());\n+\t\t\t       addr->m_symbol->total_byte_size (), align);\n \t}\n       else\n \t{\n@@ -3574,9 +3617,11 @@ gen_hsa_insns_for_direct_call (gimple *stmt, hsa_bb *hbb)\n \n \t  if (AGGREGATE_TYPE_P (lhs_type))\n \t    {\n-\t      hsa_op_address *result_addr = gen_hsa_addr (result, hbb);\n+\t      BrigAlignment8_t align;\n+\t      hsa_op_address *result_addr\n+\t\t= gen_hsa_addr_with_align (result, hbb, &align);\n \t      gen_hsa_memory_copy (hbb, result_addr, addr,\n-\t\t\t\t   addr->m_symbol->total_byte_size ());\n+\t\t\t\t   addr->m_symbol->total_byte_size (), align);\n \t    }\n \t  else\n \t    {\n@@ -3685,9 +3730,12 @@ gen_hsa_insns_for_return (greturn *stmt, hsa_bb *hbb)\n \n       if (AGGREGATE_TYPE_P (TREE_TYPE (retval)))\n \t{\n-\t  hsa_op_address *retval_addr = gen_hsa_addr (retval, hbb);\n+\t  BrigAlignment8_t align;\n+\t  hsa_op_address *retval_addr = gen_hsa_addr_with_align (retval, hbb,\n+\t\t\t\t\t\t\t\t &align);\n \t  gen_hsa_memory_copy (hbb, addr, retval_addr,\n-\t\t\t       hsa_cfun->m_output_arg->total_byte_size ());\n+\t\t\t       hsa_cfun->m_output_arg->total_byte_size (),\n+\t\t\t       align);\n \t}\n       else\n \t{\n@@ -5143,7 +5191,7 @@ gen_hsa_insns_for_call (gimple *stmt, hsa_bb *hbb)\n \thsa_op_address *dst_addr = get_address_from_value (dst, hbb);\n \thsa_op_address *src_addr = get_address_from_value (src, hbb);\n \n-\tgen_hsa_memory_copy (hbb, dst_addr, src_addr, n);\n+\tgen_hsa_memory_copy (hbb, dst_addr, src_addr, n, BRIG_ALIGNMENT_1);\n \n \ttree lhs = gimple_call_lhs (stmt);\n \tif (lhs)\n@@ -5597,9 +5645,11 @@ gen_function_def_parameters ()\n \t  private_arg = hsa_cfun->create_hsa_temporary (arg->m_type);\n \t  private_arg->fillup_for_decl (parm);\n \n+\t  BrigAlignment8_t align = MIN (arg->m_align, private_arg->m_align);\n+\n \t  hsa_op_address *private_arg_addr = new hsa_op_address (private_arg);\n \t  gen_hsa_memory_copy (prologue, private_arg_addr, parm_addr,\n-\t\t\t       arg->total_byte_size ());\n+\t\t\t       arg->total_byte_size (), align);\n \t}\n       else\n \tprivate_arg = arg;"}, {"sha": "ff978702489720c1c6250d34d2fe23666b3d4048", "filename": "gcc/hsa.c", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/320c1a36793e0f408924b38bc006e6b791dceff7/gcc%2Fhsa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/320c1a36793e0f408924b38bc006e6b791dceff7/gcc%2Fhsa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhsa.c?ref=320c1a36793e0f408924b38bc006e6b791dceff7", "patch": "@@ -39,6 +39,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"hsa.h\"\n #include \"internal-fn.h\"\n #include \"ctype.h\"\n+#include \"builtins.h\"\n \n /* Structure containing intermediate HSA representation of the generated\n    function.  */\n@@ -570,6 +571,25 @@ hsa_alignment_encoding (unsigned n)\n     }\n }\n \n+/* Return HSA alignment encoding alignment of T got\n+   by get_object_alignment.  */\n+\n+BrigAlignment8_t\n+hsa_object_alignment (tree t)\n+{\n+  return hsa_alignment_encoding (get_object_alignment (t));\n+}\n+\n+/* Return byte alignment for given BrigAlignment8_t value.  */\n+\n+unsigned\n+hsa_byte_alignment (BrigAlignment8_t alignment)\n+{\n+  gcc_assert (alignment != BRIG_ALIGNMENT_NONE);\n+\n+  return 1 << (alignment - 1);\n+}\n+\n /* Return natural alignment of HSA TYPE.  */\n \n BrigAlignment8_t"}, {"sha": "ac692fb7e618ced9409d9a6ceb2630a11cb6410a", "filename": "gcc/hsa.h", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/320c1a36793e0f408924b38bc006e6b791dceff7/gcc%2Fhsa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/320c1a36793e0f408924b38bc006e6b791dceff7/gcc%2Fhsa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhsa.h?ref=320c1a36793e0f408924b38bc006e6b791dceff7", "patch": "@@ -60,7 +60,8 @@ struct hsa_symbol\n   /* Constructor.  */\n   hsa_symbol (BrigType16_t type, BrigSegment8_t segment,\n \t      BrigLinkage8_t linkage, bool global_scope_p = false,\n-\t      BrigAllocation allocation = BRIG_ALLOCATION_AUTOMATIC);\n+\t      BrigAllocation allocation = BRIG_ALLOCATION_AUTOMATIC,\n+\t      BrigAlignment8_t align = BRIG_ALIGNMENT_8);\n \n   /* Return total size of the symbol.  */\n   unsigned HOST_WIDE_INT total_byte_size ();\n@@ -113,6 +114,9 @@ struct hsa_symbol\n   /* Flag used for global variables if a variable is already emitted or not.  */\n   bool m_emitted_to_brig;\n \n+  /* Alignment of the symbol.  */\n+  BrigAlignment8_t m_align;\n+\n private:\n   /* Default constructor.  */\n   hsa_symbol ();\n@@ -1347,6 +1351,8 @@ bool hsa_type_integer_p (BrigType16_t type);\n bool hsa_btype_p (BrigType16_t type);\n BrigAlignment8_t hsa_alignment_encoding (unsigned n);\n BrigAlignment8_t hsa_natural_alignment (BrigType16_t type);\n+BrigAlignment8_t hsa_object_alignment (tree t);\n+unsigned hsa_byte_alignment (BrigAlignment8_t alignment);\n void hsa_destroy_operand (hsa_op_base *op);\n void hsa_destroy_insn (hsa_insn_basic *insn);\n void hsa_add_kern_decl_mapping (tree decl, char *name, unsigned, bool);"}]}