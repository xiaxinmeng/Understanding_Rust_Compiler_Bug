{"sha": "27768ae6ae1433441ae6bb34625d0b5b25eda10c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mjc3NjhhZTZhZTE0MzM0NDFhZTZiYjM0NjI1ZDBiNWIyNWVkYTEwYw==", "commit": {"author": {"name": "Hartmut Penner", "email": "hpenner@de.ibm.com", "date": "2004-01-14T09:23:06Z"}, "committer": {"name": "Hartmut Penner", "email": "hpenner@gcc.gnu.org", "date": "2004-01-14T09:23:06Z"}, "message": "* gcc.dg/ppc64-abi-1.c: New test.\n\nFrom-SVN: r75852", "tree": {"sha": "fa27a40df59e659b4b825335e724ee2d94432795", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fa27a40df59e659b4b825335e724ee2d94432795"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/27768ae6ae1433441ae6bb34625d0b5b25eda10c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/27768ae6ae1433441ae6bb34625d0b5b25eda10c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/27768ae6ae1433441ae6bb34625d0b5b25eda10c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/27768ae6ae1433441ae6bb34625d0b5b25eda10c/comments", "author": null, "committer": null, "parents": [{"sha": "d22c417920998fe96973c74e5068cff8f3a47811", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d22c417920998fe96973c74e5068cff8f3a47811", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d22c417920998fe96973c74e5068cff8f3a47811"}], "stats": {"total": 367, "additions": 367, "deletions": 0}, "files": [{"sha": "05a6b6027c21f7d0cf60b4302828f268096995f1", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27768ae6ae1433441ae6bb34625d0b5b25eda10c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27768ae6ae1433441ae6bb34625d0b5b25eda10c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=27768ae6ae1433441ae6bb34625d0b5b25eda10c", "patch": "@@ -1,3 +1,7 @@\n+2004-01-14  Hartmut Penner  <hpenner@de.ibm.com>\n+\n+\t* gcc.dg/ppc64-abi-1.c: New test.\n+\n 2004-01-14  Danny Smith  <dannysmith@users.sourceforge.net>\n \n \t * g++.dg/ext/attrib9.C: Add dg-warnings."}, {"sha": "fa196595f382fd3324cb4a8c9db9b8fe24905159", "filename": "gcc/testsuite/gcc.dg/ppc64-abi-1.c", "status": "added", "additions": 363, "deletions": 0, "changes": 363, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27768ae6ae1433441ae6bb34625d0b5b25eda10c/gcc%2Ftestsuite%2Fgcc.dg%2Fppc64-abi-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27768ae6ae1433441ae6bb34625d0b5b25eda10c/gcc%2Ftestsuite%2Fgcc.dg%2Fppc64-abi-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fppc64-abi-1.c?ref=27768ae6ae1433441ae6bb34625d0b5b25eda10c", "patch": "@@ -0,0 +1,363 @@\n+/* { dg-do run { target powerpc64-*-* } } */\n+/* { dg-options \"-O2\" } */\n+#include <stdarg.h>\n+#include <signal.h>\n+#include <stdio.h>\n+\n+/* Testcase to check for ABI compliance of parameter passing\n+   for the PowerPC64 ABI.  \n+   Parameter passing of integral and floating point is tested.  */\n+\n+extern void abort (void);\n+\n+typedef struct\n+{\n+  unsigned long gprs[8];\n+  double fprs[13];\n+} reg_parms_t;\n+\n+reg_parms_t gparms;\n+\n+\n+/* Testcase could break on future gcc's, if parameter regs\n+   are changed before this asm.  */\n+\n+#ifndef __MACH__\n+#define save_parms(lparms)\t\t\t\t\\\n+    asm volatile (\"ld 11,gparms@got(2)\\n\\t\"                \\\n+                  \"std 3,0(11)\\n\\t\"\t\t        \\\n+\t          \"std 4,8(11)\\n\\t\"\t\t\t\\\n+\t          \"std 5,16(11)\\n\\t\"\t\t\t\\\n+\t          \"std 6,24(11)\\n\\t\"\t\t\t\\\n+\t          \"std 7,32(11)\\n\\t\"\t\t\t\\\n+\t          \"std 8,40(11)\\n\\t\"\t\t\t\\\n+\t          \"std 9,48(11)\\n\\t\"\t\t\t\\\n+\t          \"std 10,56(11)\\n\\t\"                 \\\n+                  \"stfd 1,64(11)\\n\\t\"\t\t        \\\n+\t          \"stfd 2,72(11)\\n\\t\"\t\t\t\\\n+\t          \"stfd 3,80(11)\\n\\t\"\t\t\t\\\n+\t          \"stfd 4,88(11)\\n\\t\"\t\t\t\\\n+\t          \"stfd 5,96(11)\\n\\t\"\t\t\t\\\n+\t          \"stfd 6,104(11)\\n\\t\"\t\t\t\\\n+\t          \"stfd 7,112(11)\\n\\t\"\t\t\t\\\n+\t          \"stfd 8,120(11)\\n\\t\"\t\t\t\\\n+\t          \"stfd 9,128(11)\\n\\t\"\t\t\t\\\n+\t          \"stfd 10,136(11)\\n\\t\"\t\t\t\\\n+\t          \"stfd 11,144(11)\\n\\t\"\t\t\t\\\n+\t          \"stfd 12,152(11)\\n\\t\"                 \\\n+\t          \"stfd 13,160(11)\\n\\t\":::\"11\", \"memory\");  \\\n+                  lparms = gparms;\n+#else\n+#define save_parms(lparms)\t\t\t\t\\\n+    asm volatile (\"ld r11,gparms@got(r2)\\n\\t\"           \\\n+                  \"std r3,0(r11)\\n\\t\"\t\t        \\\n+\t          \"std r4,8(r11)\\n\\t\"\t\t\t\\\n+\t          \"std r5,16(r11)\\n\\t\"\t\t\t\\\n+\t          \"std r6,24(r11)\\n\\t\"\t\t\t\\\n+\t          \"std r7,32(r11)\\n\\t\"\t\t\t\\\n+\t          \"std r8,40(r11)\\n\\t\"\t\t\t\\\n+\t          \"std r9,48(r11)\\n\\t\"\t\t\t\\\n+\t          \"std r10,56(r11)\\n\\t\"                 \\\n+                  \"stfd f1,64(r11)\\n\\t\"\t\t        \\\n+\t          \"stfd f2,72(r11)\\n\\t\"\t\t\t\\\n+\t          \"stfd f3,80(r11)\\n\\t\"\t\t\t\\\n+\t          \"stfd f4,88(r11)\\n\\t\"\t\t\t\\\n+\t          \"stfd f5,96(r11)\\n\\t\"\t\t\t\\\n+\t          \"stfd f6,104(r11)\\n\\t\"\t\t\\\n+\t          \"stfd f7,112(r11)\\n\\t\"\t\t\\\n+\t          \"stfd f8,120(r11)\\n\\t\"\t\t\\\n+\t          \"stfd f9,128(r11)\\n\\t\"\t\t\\\n+\t          \"stfd f10,136(r11)\\n\\t\"\t\t\\\n+\t          \"stfd f11,144(r11)\\n\\t\"\t\t\\\n+\t          \"stfd f12,152(r11)\\n\\t\"               \\\n+\t          \"stfd f13,160(r11)\\n\\t\":::\"r11\", \"memory\");  \\\n+                  lparms = gparms;\n+#endif\n+\n+/* Stackframe structure relevant for parameter passing.  */\n+typedef union\n+{\n+  double d;\n+  unsigned long l;\n+  unsigned int i[2];\n+} parm_t;\n+\n+typedef struct sf\n+{\n+  struct sf *backchain;\n+  long a1;\n+  long a2;\n+  long a3;\n+  long a4;\n+  long a5;\n+  parm_t slot[100];\n+} stack_frame_t;\n+\n+\n+/* Paramter passing.\n+   s : gpr 3\n+   l : gpr 4\n+   d : fpr 1\n+*/\n+void __attribute__ ((noinline)) fcld (char *s, long l, double d)\n+{\n+  reg_parms_t lparms;\n+  save_parms (lparms);\n+\n+  if (s != (char *) lparms.gprs[0])\n+    abort ();\n+\n+  if (l != lparms.gprs[1])\n+    abort ();\n+\n+  if (d != lparms.fprs[0])\n+    abort ();\n+}\n+\n+/* Paramter passing.\n+   s : gpr 3\n+   l : gpr 4\n+   d : fpr 2\n+   i : gpr 5\n+*/\n+void __attribute__ ((noinline))\n+fcldi (char *s, long l, double d, signed int i)\n+{\n+  reg_parms_t lparms;\n+  save_parms (lparms);\n+\n+  if (s != (char *) lparms.gprs[0])\n+    abort ();\n+\n+  if (l != lparms.gprs[1])\n+    abort ();\n+\n+  if (d != lparms.fprs[0])\n+    abort ();\n+\n+  if ((signed long) i != lparms.gprs[3])\n+    abort ();\n+}\n+\n+/* Paramter passing.\n+   s : gpr 3\n+   l : gpr 4\n+   d : fpr 2\n+   i : gpr 5\n+*/\n+void __attribute__ ((noinline))\n+fcldu (char *s, long l, float d, unsigned int i)\n+{\n+  reg_parms_t lparms;\n+  save_parms (lparms);\n+\n+  if (s != (char *) lparms.gprs[0])\n+    abort ();\n+\n+  if (l != lparms.gprs[1])\n+    abort ();\n+\n+  if ((double) d != lparms.fprs[0])\n+    abort ();\n+\n+  if ((unsigned long) i != lparms.gprs[3])\n+    abort ();\n+}\n+\n+/* Paramter passing.\n+   s : gpr 3\n+   l : slot 1\n+   d : slot 2\n+*/\n+\n+void __attribute__ ((noinline)) fceld (char *s, ...)\n+{\n+  stack_frame_t *sp;\n+  reg_parms_t lparms;\n+  va_list arg;\n+  double d;\n+  long l;\n+  save_parms (lparms);\n+\n+  va_start (arg, s);\n+\n+  if (s != (char *) lparms.gprs[0])\n+    abort ();\n+\n+  l = va_arg (arg, long);\n+  d = va_arg (arg, double);\n+\n+  /* Go back one frame.  */\n+  sp = __builtin_frame_address (0);\n+  sp = sp->backchain;\n+\n+  if (sp->slot[1].l != l)\n+    abort ();\n+\n+  if (sp->slot[2].d != d)\n+    abort ();\n+}\n+\n+/* Paramter passing.\n+   s : gpr 3\n+   i : gpr 4\n+   j : gpr 5\n+   d : slot 3\n+   l : slot 4\n+*/\n+void __attribute__ ((noinline)) fciiedl (char *s, int i, int j, ...)\n+{\n+  stack_frame_t *sp;\n+  reg_parms_t lparms;\n+  va_list arg;\n+  double d;\n+  long l;\n+  save_parms (lparms);\n+\n+  va_start (arg, j);\n+\n+  if (s != (char *) lparms.gprs[0])\n+    abort ();\n+\n+  if ((long) i != lparms.gprs[1])\n+    abort ();\n+\n+  if ((long) j != lparms.gprs[2])\n+    abort ();\n+\n+  d = va_arg (arg, double);\n+  l = va_arg (arg, long);\n+\n+  sp = __builtin_frame_address (0);\n+  sp = sp->backchain;\n+\n+  if (sp->slot[3].d != d)\n+    abort ();\n+\n+  if (sp->slot[4].l != l)\n+    abort ();\n+}\n+\n+/* \n+Parameter     Register     Offset in parameter save area\n+c             r3           0-7    (not stored in parameter save area)\n+ff            f1           8-15   (not stored)\n+d             r5           16-23  (not stored)\n+ld            f2           24-31  (not stored)\n+f             r7           32-39  (not stored)\n+s             r8,r9        40-55  (not stored)\n+gg            f3           56-63  (not stored)\n+t             (none)       64-79  (stored in parameter save area)\n+e             (none)       80-87  (stored)\n+hh            f4           88-95  (stored)  \n+\n+*/\n+\n+typedef struct\n+{\n+  int a;\n+  double dd;\n+} sparm;\n+\n+typedef union\n+{\n+  int i[2];\n+  long l;\n+  double d;\n+} double_t;\n+\n+/* Example from ABI documentation with slight changes.\n+   Paramter passing. \n+   c  : gpr 3\n+   ff : fpr 1\n+   d  : gpr 5\n+   ld : fpr 2\n+   f  : gpr 7\n+   s  : gpr 8 - 9\n+   gg : fpr 3\n+   t  : save area offset 64 - 79 \n+   e  : save area offset 80 - 88\n+   hh : fpr 4   \n+*/\n+\n+void __attribute__ ((noinline))\n+fididisdsid (int c, double ff, int d, double ld, int f,\n+\t     sparm s, double gg, sparm t, int e, double hh)\n+{\n+  stack_frame_t *sp;\n+  reg_parms_t lparms;\n+  double_t dx, dy;\n+\n+  save_parms (lparms);\n+\n+  /* Parm 0: int.  */\n+  if ((long) c != lparms.gprs[0])\n+    abort ();\n+\n+  /* Parm 1: double.  */\n+  if (ff != lparms.fprs[0])\n+    abort ();\n+\n+  /* Parm 2: int.  */\n+  if ((long) d != lparms.gprs[2])\n+    abort ();\n+\n+  /* Parm 3: double.  */\n+  if (ld != lparms.fprs[1])\n+    abort ();\n+\n+  /* Parm 4: int.  */\n+  if ((long) f != lparms.gprs[4])\n+    abort ();\n+\n+  /* Parm 5: struct sparm.  */\n+  dx.l = lparms.gprs[5];\n+  dy.l = lparms.gprs[6];\n+\n+  if (s.a != dx.i[0])\n+    abort ();\n+  if (s.dd != dy.d)\n+    abort ();\n+\n+  /* Parm 6: double.  */\n+  if (gg != lparms.fprs[2])\n+    abort ();\n+\n+  sp = __builtin_frame_address (0);\n+  sp = sp->backchain;\n+\n+  /* Parm 7: struct sparm.  */\n+  dx.l = sp->slot[8].l;\n+  dy.l = sp->slot[9].l;\n+  if (t.a != dx.i[0])\n+    abort ();\n+  if (t.dd != dy.d)\n+    abort ();\n+\n+  /* Parm 8: int.  */\n+  if (e != sp->slot[10].l)\n+    abort ();\n+\n+  /* Parm 9: double.  */\n+\n+  if (hh != lparms.fprs[3])\n+    abort ();\n+}\n+\n+int\n+main ()\n+{\n+  char *s = \"ii\";\n+\n+  fcld (s, 1, 1.0);\n+  fcldi (s, 1, 1.0, -2);\n+  fcldu (s, 1, 1.0, 2);\n+  fceld (s, 1, 1.0);\n+  fciiedl (s, 1, 2, 1.0, 3);\n+  fididisdsid (1, 1.0, 2, 2.0, -1, (sparm)\n+\t       {\n+\t       3, 3.0}, 4.0, (sparm)\n+\t       {\n+\t       5, 5.0}, 6, 7.0);\n+  return 0;\n+}"}]}