{"sha": "506b0f9eaf6a5143975461c1bea16e72f640df64", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTA2YjBmOWVhZjZhNTE0Mzk3NTQ2MWMxYmVhMTZlNzJmNjQwZGY2NA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1997-06-25T20:12:28Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1997-06-25T20:12:28Z"}, "message": "(objc_send_load): New function.\n\n(objc_class_tree): New structure.\n(create_tree_of_subclasses_inherited_from): New function.\n(__objc_tree_insert_class): New function.\n(objc_tree_insert_class): New function.\n(objc_preorder_traverse): New function.\n(objc_postorder_traverse): New function.\n(__objc_tree_print): New function.\n(__objc_destroy_class_tree_node): New function.\n(class_is_subclass_of_class): New function.\n(__objc_exec_class): Allocate class tree list and load hash table.\n(__objc_send_message_in_list): Rewrite using hash table.\n(__objc_send_load): Remove calls to _objc_load_callback.\n(objc_send_load): Make static.  Create Tree of classes resembling\nclass hierarchy for all modules.  Call __objc_send_load on all of\nthe modules in __objc_module_list.\n(__objc_create_classes_tree): New function.\n\nFrom-SVN: r14304", "tree": {"sha": "7b62e437003e54650fce12969ab5f707160d5c4a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7b62e437003e54650fce12969ab5f707160d5c4a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/506b0f9eaf6a5143975461c1bea16e72f640df64", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/506b0f9eaf6a5143975461c1bea16e72f640df64", "html_url": "https://github.com/Rust-GCC/gccrs/commit/506b0f9eaf6a5143975461c1bea16e72f640df64", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/506b0f9eaf6a5143975461c1bea16e72f640df64/comments", "author": null, "committer": null, "parents": [{"sha": "723778b07348445e8a0a319c32cd83bc87c08e15", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/723778b07348445e8a0a319c32cd83bc87c08e15", "html_url": "https://github.com/Rust-GCC/gccrs/commit/723778b07348445e8a0a319c32cd83bc87c08e15"}], "stats": {"total": 402, "additions": 355, "deletions": 47}, "files": [{"sha": "5e56146c42341c9b6eb2be22505737698e3fcc0a", "filename": "gcc/objc/init.c", "status": "modified", "additions": 355, "deletions": 47, "changes": 402, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/506b0f9eaf6a5143975461c1bea16e72f640df64/gcc%2Fobjc%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/506b0f9eaf6a5143975461c1bea16e72f640df64/gcc%2Fobjc%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Finit.c?ref=506b0f9eaf6a5143975461c1bea16e72f640df64", "patch": "@@ -1,6 +1,7 @@\n /* GNU Objective C Runtime initialization \n    Copyright (C) 1993, 1995, 1996, 1997 Free Software Foundation, Inc.\n    Contributed by Kresten Krab Thorup\n+   +load support contributed by Ovidiu Predescu <ovidiu@net-community.com>\n \n This file is part of GNU CC.\n \n@@ -40,7 +41,7 @@ static struct objc_list* unclaimed_proto_list = 0; \t/* !T:MUTEX */\n static struct objc_list *uninitialized_statics = 0; \t/* !T:MUTEX */\n \n /* Global runtime \"write\" mutex. */\n-objc_mutex_t __objc_runtime_mutex;\n+objc_mutex_t __objc_runtime_mutex = 0;\n \n /* Number of threads that are alive. */\n int __objc_runtime_threads_alive = 1;\t\t\t/* !T:MUTEX */\n@@ -67,15 +68,306 @@ extern SEL\n __sel_register_typed_name (const char *name, const char *types, \n \t\t\t   struct objc_selector *orig, BOOL is_const);\n \n-/* Send +load to all classes and categories from a module that implement\n-   this method */\n-static void __objc_send_load(Module_t module);\n+/* Sends +load to all classes and categories in certain situations. */\n+static void objc_send_load (void);\n+\n+/* Inserts all the classes defined in module in a tree of classes that\n+   resembles the class hierarchy. This tree is traversed in preorder and the\n+   classes in its nodes receive the +load message if these methods were not\n+   executed before. The algorithm ensures that when the +load method of a class\n+   is executed all the superclasses have been already received the +load\n+   message. */\n+static void __objc_create_classes_tree (Module_t module);\n+\n+static void __objc_call_callback (Module_t module);\n+\n+/* A special version that works only before the classes are completely\n+   installed in the runtime. */\n+static BOOL class_is_subclass_of_class (Class class, Class superclass);\n+\n+typedef struct objc_class_tree {\n+  Class class;\n+  struct objc_list *subclasses; /* `head' is pointer to an objc_class_tree */\n+} objc_class_tree;\n+\n+/* This is a linked list of objc_class_tree trees. The head of these trees\n+   are root classes (their super class is Nil). These different trees\n+   represent different class hierarchies. */\n+static struct objc_list *__objc_class_tree_list = NULL;\n+\n+/* Keeps the +load methods who have been already executed. This hash should\n+   not be destroyed during the execution of the program. */\n+static cache_ptr __objc_load_methods = NULL;\n+\n+/* Creates a tree of classes whose topmost class is directly inherited from\n+   `upper' and the bottom class in this tree is `bottom_class'. The classes\n+   in this tree are super classes of `bottom_class'. `subclasses' member\n+   of each tree node point to the next subclass tree node. */\n+static objc_class_tree *\n+create_tree_of_subclasses_inherited_from (Class bottom_class, Class upper)\n+{\n+  Class superclass = bottom_class->super_class ?\n+\t\t\tobjc_lookup_class ((char*)bottom_class->super_class)\n+\t\t      : Nil;\n+\t\t\t\t\t\n+  objc_class_tree *tree, *prev;\n+\n+  DEBUG_PRINTF (\"create_tree_of_subclasses_inherited_from:\");\n+  DEBUG_PRINTF (\"bottom_class = %s, upper = %s\\n\",\n+\t\t(bottom_class ? bottom_class->name : NULL),\n+\t\t(upper ? upper->name : NULL));\n+\n+  tree = prev = objc_calloc (1, sizeof (objc_class_tree));\n+  prev->class = bottom_class;\n+\n+  while (superclass != upper)\n+    {\n+      tree = objc_calloc (1, sizeof (objc_class_tree));\n+      tree->class = superclass;\n+      tree->subclasses = list_cons (prev, tree->subclasses);\n+      superclass = (superclass->super_class ?\n+\t\t\tobjc_lookup_class ((char*)superclass->super_class)\n+\t\t      : Nil);\n+      prev = tree;\n+    }\n+\n+  return tree;\n+}\n+\n+/* Insert the `class' into the proper place in the `tree' class hierarchy. This\n+   function returns a new tree if the class has been successfully inserted into\n+   the tree or NULL if the class is not part of the classes hierarchy described\n+   by `tree'. This function is private to objc_tree_insert_class(), you should\n+   not call it directly. */\n+static objc_class_tree *\n+__objc_tree_insert_class (objc_class_tree *tree, Class class)\n+{\n+  DEBUG_PRINTF (\"__objc_tree_insert_class: tree = %x, class = %s\\n\",\n+\t\ttree, class->name);\n+\n+  if (tree == NULL)\n+    return create_tree_of_subclasses_inherited_from (class, NULL);\n+  else if (class == tree->class)\n+    {\n+      /* `class' has been already inserted */\n+      DEBUG_PRINTF (\"1. class %s was previously inserted\\n\", class->name);\n+      return tree;\n+    }\n+  else if ((class->super_class ?\n+\t\t    objc_lookup_class ((char*)class->super_class)\n+\t\t  : Nil)\n+\t    == tree->class)\n+    {\n+      /* If class is a direct subclass of tree->class then add class to the\n+\t list of subclasses. First check to see if it wasn't already\n+\t inserted. */\n+      struct objc_list *list = tree->subclasses;\n+      objc_class_tree *node;\n+\n+      while (list)\n+\t{\n+\t  /* Class has been already inserted; do nothing just return\n+\t     the tree. */\n+\t  if (((objc_class_tree*)list->head)->class == class)\n+\t    {\n+\t      DEBUG_PRINTF (\"2. class %s was previously inserted\\n\",\n+\t\t\t    class->name);\n+\t      return tree;\n+\t    }\n+\t  list = list->tail;\n+\t}\n+\n+      /* Create a new node class and insert it into the list of subclasses */\n+      node = objc_calloc (1, sizeof (objc_class_tree));\n+      node->class = class;\n+      tree->subclasses = list_cons (node, tree->subclasses);\n+      DEBUG_PRINTF (\"3. class %s inserted\\n\", class->name);\n+      return tree;\n+    }\n+  else\n+    {\n+      /* The class is not a direct subclass of tree->class. Search for class's\n+         superclasses in the list of subclasses. */\n+      struct objc_list *subclasses = tree->subclasses;\n+\n+      /* Precondition: the class must be a subclass of tree->class; otherwise\n+         return NULL to indicate our caller that it must take the next tree. */\n+      if (!class_is_subclass_of_class (class, tree->class))\n+\treturn NULL;\n+\n+      for (; subclasses != NULL; subclasses = subclasses->tail)\n+\t{\n+\t  Class aClass = ((objc_class_tree*)(subclasses->head))->class;\n+\n+\t  if (class_is_subclass_of_class (class, aClass))\n+\t    {\n+\t      /* If we found one of class's superclasses we insert the class\n+\t         into its subtree and return the original tree since nothing\n+\t\t has been changed. */\n+\t      subclasses->head\n+\t\t  = __objc_tree_insert_class (subclasses->head, class);\n+ \t      DEBUG_PRINTF (\"4. class %s inserted\\n\", class->name);\n+\t      return tree;\n+\t    }\n+\t}\n+\n+      /* We haven't found a subclass of `class' in the `subclasses' list.\n+         Create a new tree of classes whose topmost class is a direct subclass\n+\t of tree->class. */\n+      {\n+\tobjc_class_tree *new_tree\n+\t    = create_tree_of_subclasses_inherited_from (class, tree->class);\n+\ttree->subclasses = list_cons (new_tree, tree->subclasses);\n+ \tDEBUG_PRINTF (\"5. class %s inserted\\n\", class->name);\n+\treturn tree;\n+      }\n+    }\n+}\n+\n+/* This function inserts `class' in the right tree hierarchy classes. */\n+static void\n+objc_tree_insert_class (Class class)\n+{\n+  struct objc_list *list_node;\n+  objc_class_tree *tree;\n+\n+  list_node = __objc_class_tree_list;\n+  while (list_node)\n+    {\n+      tree = __objc_tree_insert_class (list_node->head, class);\n+      if (tree)\n+\t{\n+\t  list_node->head = tree;\n+\t  break;\n+\t}\n+      else\n+\tlist_node = list_node->tail;\n+    }\n+\n+  /* If the list was finished but the class hasn't been inserted, insert it\n+     here. */\n+  if (!list_node)\n+    {\n+      __objc_class_tree_list = list_cons (NULL, __objc_class_tree_list);\n+      __objc_class_tree_list->head = __objc_tree_insert_class (NULL, class);\n+    }\n+}\n+\n+/* Traverse tree in preorder. Used to send +load. */\n+static void\n+objc_preorder_traverse (objc_class_tree *tree,\n+\t\t\tint level,\n+\t\t\tvoid (*function)(objc_class_tree*, int))\n+{\n+  struct objc_list *node;\n+\n+  (*function) (tree, level);\n+  for (node = tree->subclasses; node; node = node->tail)\n+    objc_preorder_traverse (node->head, level + 1, function);\n+}\n+\n+/* Traverse tree in postorder. Used to destroy a tree. */\n+static void\n+objc_postorder_traverse (objc_class_tree *tree,\n+\t\t\tint level,\n+\t\t\tvoid (*function)(objc_class_tree*, int))\n+{\n+  struct objc_list *node;\n+\n+  for (node = tree->subclasses; node; node = node->tail)\n+    objc_postorder_traverse (node->head, level + 1, function);\n+  (*function) (tree, level);\n+}\n+\n+/* Used to print a tree class hierarchy. */\n+static void\n+__objc_tree_print (objc_class_tree *tree, int level)\n+{\n+  int i;\n+\n+  for (i = 0; i < level; i++)\n+    printf (\"  \");\n+  printf (\"%s\\n\", tree->class->name);\n+}\n+\n+/* Walks on a linked list of methods in the reverse order and executes all\n+   the methods corresponding to `op' selector. Walking in the reverse order\n+   assures the +load of class is executed first and then +load of categories\n+   because of the way in which categories are added to the class methods. */\n+static void\n+__objc_send_message_in_list (MethodList_t method_list, Class class, SEL op)\n+{\n+  int i;\n+\n+  if (!method_list)\n+    return;\n+\n+  /* First execute the `op' message in the following method lists */\n+  __objc_send_message_in_list (method_list->method_next, class, op);\n+\n+  /* Search the method list. */\n+  for (i = 0; i < method_list->method_count; i++)\n+    {\n+      Method_t mth = &method_list->method_list[i];\n+\n+      if (mth->method_name && sel_eq (mth->method_name, op)\n+\t  && !hash_is_key_in_hash (__objc_load_methods, mth->method_name))\n+\t{\n+\t  /* The method was found and wasn't previously executed. */\n+\t  (*mth->method_imp) ((id)class, mth->method_name);\n+\n+\t  /* Add this method into the +load hash table */\n+\t  hash_add (&__objc_load_methods, mth->method_imp, mth->method_imp);\n+\n+\t  DEBUG_PRINTF (\"sending +load in class: %s\\n\", class->name);\n+\n+\t  break;\n+\t}\n+    }\n+}\n+\n+static void\n+__objc_send_load (objc_class_tree *tree, int level)\n+{\n+  static SEL load_sel = 0;\n+  Class class = tree->class;\n+  MethodList_t method_list = class->class_pointer->methods;\n+\n+  if (!load_sel)\n+    load_sel = sel_register_name (\"load\");\n+\n+  __objc_send_message_in_list (method_list, class, load_sel);\n+}\n+\n+static void\n+__objc_destroy_class_tree_node (objc_class_tree *tree, int level)\n+{\n+  objc_free (tree);\n+}\n+\n+/* This is used to check if the relationship between two classes before the\n+   runtime completely installs the classes. */\n+static BOOL\n+class_is_subclass_of_class (Class class, Class superclass)\n+{\n+  for (; class != Nil;)\n+    {\n+      if (class == superclass)\n+\treturn YES;\n+      class = (class->super_class ?\n+\t\t  objc_lookup_class ((char*)class->super_class)\n+\t\t: Nil);\n+    }\n+\n+  return NO;\n+}\n \n /* This list contains all the classes in the runtime system for whom their\n    superclasses are not yet know to the runtime. */\n static struct objc_list* unresolved_classes = 0;\n \n-/* Static function used to references the Object and NXConstantString classes. */\n+/* Static function used to reference the Object and NXConstantString classes.\n+ */\n static void\n __objc_force_linking (void)\n {\n@@ -191,6 +483,9 @@ __objc_exec_class (Module_t module)\n       __objc_init_selector_tables();\n       __objc_init_class_tables();\n       __objc_init_dispatch_tables();\n+      __objc_class_tree_list = list_cons (NULL, __objc_class_tree_list);\n+      __objc_load_methods\n+\t  = hash_new (128, (hash_func_type)hash_ptr, compare_ptrs);\n       previous_constructors = 1;\n     }\n \n@@ -226,6 +521,10 @@ __objc_exec_class (Module_t module)\n       assert (CLS_ISMETA(class->class_pointer));\n       DEBUG_PRINTF (\"phase 1, processing class: %s\\n\", class->name);\n \n+      /* Initialize the subclass list to be NULL.\n+\t In some cases it isn't and this crashes the program. */\n+      class->subclass_list = NULL;\n+\n       /* Store the class in the class table and assign class numbers.  */\n       __objc_add_class_to_hash (class);\n \n@@ -237,6 +536,10 @@ __objc_exec_class (Module_t module)\n       __objc_install_premature_dtable(class);\n       __objc_install_premature_dtable(class->class_pointer);\n \n+      /* Register the instance methods as class methods, this is\n+\t only done for root classes. */\n+      __objc_register_instance_methods_to_class(class);\n+\n       if (class->protocols)\n \t__objc_init_protocols (class->protocols);\n \n@@ -275,8 +578,9 @@ __objc_exec_class (Module_t module)\n \t      __objc_class_add_protocols (class, category->protocols);\n \t    }\n \n-          if (_objc_load_callback)\n-\t    _objc_load_callback(class, category);\n+          /* Register the instance methods as class methods, this is\n+             only done for root classes. */\n+          __objc_register_instance_methods_to_class(class);\n \t}\n       else\n \t{\n@@ -313,15 +617,16 @@ __objc_exec_class (Module_t module)\n \t  if (category->class_methods)\n \t    class_add_method_list ((Class) class->class_pointer,\n \t\t\t\t   category->class_methods);\n-\t  \n+\n \t  if (category->protocols)\n \t    {\n \t      __objc_init_protocols (category->protocols);\n \t      __objc_class_add_protocols (class, category->protocols);\n \t    }\n-\t  \n-          if (_objc_load_callback)\n-\t    _objc_load_callback(class, category);\n+\n+          /* Register the instance methods as class methods, this is\n+             only done for root classes. */\n+          __objc_register_instance_methods_to_class(class);\n \t}\n     }\n   \n@@ -337,7 +642,7 @@ __objc_exec_class (Module_t module)\n   objc_mutex_unlock(__objc_runtime_mutex);\n }\n \n-void objc_send_load (void)\n+static void objc_send_load (void)\n {\n   if (!__objc_module_list)\n     return;\n@@ -360,71 +665,74 @@ void objc_send_load (void)\n \t}\n \n       /*\n-       * If we still have classes for which we don't have yet their super\n+       * If we still have classes for whom we don't have yet their super\n        * classes known to the runtime we don't send the +load messages.\n        */\n       if (unresolved_classes)\n \treturn;\n     }\n \n-  /* Special check to allow sending messages to constant strings in +load\n-     methods. If the class is not yet known, even if all the classes are known,\n-     delay sending of +load. */\n-  if (!objc_lookup_class (\"NXConstantString\"))\n+  /* Special check to allow creating and sending messages to constant strings\n+     in +load methods. If these classes are not yet known, even if all the\n+     other classes are known, delay sending of +load. */\n+  if (!objc_lookup_class (\"NXConstantString\") ||\n+      !objc_lookup_class (\"Object\"))\n     return;\n \n   /* Iterate over all modules in the __objc_module_list and call on them the\n-     __objc_send_load function that sends the +load message. */\n-  list_mapcar (__objc_module_list, (void(*)(void*))__objc_send_load);\n+     __objc_create_classes_tree function. This function creates a tree of\n+     classes that resembles the class hierarchy. */\n+  list_mapcar (__objc_module_list, (void(*)(void*))__objc_create_classes_tree);\n+\n+  while (__objc_class_tree_list)\n+    {\n+#ifdef DEBUG\n+      objc_preorder_traverse (__objc_class_tree_list->head,\n+\t\t\t      0, __objc_tree_print);\n+#endif\n+      objc_preorder_traverse (__objc_class_tree_list->head,\n+\t\t\t      0, __objc_send_load);\n+      objc_postorder_traverse (__objc_class_tree_list->head,\n+\t\t\t      0, __objc_destroy_class_tree_node);\n+      list_remove_head (&__objc_class_tree_list);\n+    }\n+\n+  list_mapcar (__objc_module_list, (void(*)(void*))__objc_call_callback);\n   list_free (__objc_module_list);\n   __objc_module_list = NULL;\n }\n \n static void\n-__objc_send_message_in_list (MethodList_t method_list, id object, SEL op)\n+__objc_create_classes_tree (Module_t module)\n {\n-  while (method_list)\n-    {\n-      int i;\n+  /* The runtime mutex is locked in this point */\n \n-      /* Search the method list. */\n-      for (i = 0; i < method_list->method_count; i++)\n-\t{\n-\t  Method_t mth = &method_list->method_list[i];\n+  Symtab_t symtab = module->symtab;\n+  int i;\n \n-\t  if (mth->method_name && sel_eq (mth->method_name, op))\n-\t    {\n-\t      /* The method was found. */\n-\t      (*mth->method_imp) (object, mth->method_name);\n-\t      break;\n-\t    }\n-\t}\n-      method_list = method_list->method_next;\n+  /* Iterate thru classes defined in this module and insert them in the classes\n+     tree hierarchy. */\n+  for (i = 0; i < symtab->cls_def_cnt; i++)\n+    {\n+      Class class = (Class) symtab->defs[i];\n+\n+      objc_tree_insert_class (class);\n     }\n }\n \n static void\n-__objc_send_load(Module_t module)\n+__objc_call_callback (Module_t module)\n {\n   /* The runtime mutex is locked in this point */\n \n   Symtab_t symtab = module->symtab;\n-  static SEL load_sel = 0;\n   int i;\n \n-  if (!load_sel)\n-    load_sel = sel_register_name (\"load\");\n-\n-  /* Iterate thru classes defined in this module and send them the +load\n-     message if they implement it. At this point all methods defined in\n-     categories were added to the corresponding class, so all the +load\n-     methods of categories are in their corresponding classes. */\n+  /* Iterate thru classes defined in this module and call the callback for\n+     each one. */\n   for (i = 0; i < symtab->cls_def_cnt; i++)\n     {\n       Class class = (Class) symtab->defs[i];\n-      MethodList_t method_list = class->class_pointer->methods;\n-\n-      __objc_send_message_in_list (method_list, (id)class, load_sel);\n \n       /* Call the _objc_load_callback for this class. */\n       if (_objc_load_callback)"}]}