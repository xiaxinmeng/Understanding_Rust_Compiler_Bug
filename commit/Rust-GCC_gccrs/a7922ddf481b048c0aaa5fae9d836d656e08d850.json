{"sha": "a7922ddf481b048c0aaa5fae9d836d656e08d850", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTc5MjJkZGY0ODFiMDQ4YzBhYWE1ZmFlOWQ4MzZkNjU2ZTA4ZDg1MA==", "commit": {"author": {"name": "JeanHeyd \"ThePhD\" Meneide", "email": "phdofthehouse@gmail.com", "date": "2019-12-05T13:50:01Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2019-12-05T13:50:01Z"}, "message": "libstdc++: Implement P1872R0 and P1394R0 for std::span\n\nThis also fixes a bug in the implementation of LWG 3255, which causes:\nFAIL: 23_containers/span/lwg3255.cc (test for excess errors)\nThat's because the test was wrong and verified the buggy behaviour. That\nwill be fixed in the following commit.\n\n2019-12-05  JeanHeyd \"ThePhD\" Meneide  <phdofthehouse@gmail.com>\n\n\tImplement P1872R0 and P1394R0 for std::span\n\t* include/bits/range_access.h (__adl_begin, __adl_end): Remove.\n\t(sentinel_t, range_value_t, range_reference_t)\n\t(range_rvalue_reference_t, __forwarding_range, disable_sized_range)\n\t(output_range, input_range, forward_range, bidirectional_range)\n\t(random_access_range, contiguous_range, common_range): Move here from\n\t<ranges>, to make this the \"ranges lite\" internal header.\n\t* include/std/ranges: Move basic aliases and concepts to\n\t<bits/range_access.h>.\n\t* include/std/span: Use concepts and ranges:: calls instead of\n\tenable_if and friends.\n\t* include/std/type_traits: Add __is_array_convertible trait.\n\nFrom-SVN: r279000", "tree": {"sha": "0aac0d4f9357853a545e717fb374821c1183f288", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0aac0d4f9357853a545e717fb374821c1183f288"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a7922ddf481b048c0aaa5fae9d836d656e08d850", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a7922ddf481b048c0aaa5fae9d836d656e08d850", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a7922ddf481b048c0aaa5fae9d836d656e08d850", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a7922ddf481b048c0aaa5fae9d836d656e08d850/comments", "author": {"login": "ThePhD", "id": 2886436, "node_id": "MDQ6VXNlcjI4ODY0MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/2886436?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ThePhD", "html_url": "https://github.com/ThePhD", "followers_url": "https://api.github.com/users/ThePhD/followers", "following_url": "https://api.github.com/users/ThePhD/following{/other_user}", "gists_url": "https://api.github.com/users/ThePhD/gists{/gist_id}", "starred_url": "https://api.github.com/users/ThePhD/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ThePhD/subscriptions", "organizations_url": "https://api.github.com/users/ThePhD/orgs", "repos_url": "https://api.github.com/users/ThePhD/repos", "events_url": "https://api.github.com/users/ThePhD/events{/privacy}", "received_events_url": "https://api.github.com/users/ThePhD/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b0a71a184c6e2ec2cdf5eed90308d4e96fb1beda", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b0a71a184c6e2ec2cdf5eed90308d4e96fb1beda", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b0a71a184c6e2ec2cdf5eed90308d4e96fb1beda"}], "stats": {"total": 368, "additions": 141, "deletions": 227}, "files": [{"sha": "82cb5a9940005d3d2b326095b4d2885ea8782750", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7922ddf481b048c0aaa5fae9d836d656e08d850/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7922ddf481b048c0aaa5fae9d836d656e08d850/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=a7922ddf481b048c0aaa5fae9d836d656e08d850", "patch": "@@ -1,3 +1,18 @@\n+2019-12-05  JeanHeyd \"ThePhD\" Meneide  <phdofthehouse@gmail.com>\n+\n+\tImplement P1872R0 and P1394R0 for std::span\n+\t* include/bits/range_access.h (__adl_begin, __adl_end): Remove.\n+\t(sentinel_t, range_value_t, range_reference_t)\n+\t(range_rvalue_reference_t, __forwarding_range, disable_sized_range)\n+\t(output_range, input_range, forward_range, bidirectional_range)\n+\t(random_access_range, contiguous_range, common_range): Move here from\n+\t<ranges>, to make this the \"ranges lite\" internal header.\n+\t* include/std/ranges: Move basic aliases and concepts to\n+\t<bits/range_access.h>.\n+\t* include/std/span: Use concepts and ranges:: calls instead of\n+\tenable_if and friends.\n+\t* include/std/type_traits: Add __is_array_convertible trait.\n+\n 2019-12-05  Jonathan Wakely  <jwakely@redhat.com>\n \n \t* include/bits/stl_algobase.h (lexicographical_compare_three_way):"}, {"sha": "c94e965afb4f958bb05a9a719cfd5f9f5b0355bb", "filename": "libstdc++-v3/include/bits/range_access.h", "status": "modified", "additions": 60, "deletions": 19, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7922ddf481b048c0aaa5fae9d836d656e08d850/libstdc%2B%2B-v3%2Finclude%2Fbits%2Frange_access.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7922ddf481b048c0aaa5fae9d836d656e08d850/libstdc%2B%2B-v3%2Finclude%2Fbits%2Frange_access.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Frange_access.h?ref=a7922ddf481b048c0aaa5fae9d836d656e08d850", "patch": "@@ -336,19 +336,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     ssize(const _Tp (&)[_Num]) noexcept\n     { return _Num; }\n \n-  // \"why are these in namespace std:: and not __gnu_cxx:: ?\"\n-  // because if we don't put them here it's impossible to\n-  // have implicit ADL with \"using std::begin/end/size/data;\".\n-  template <typename _Container>\n-    constexpr auto\n-    __adl_begin(_Container& __cont) noexcept(noexcept(begin(__cont)))\n-    { return begin(__cont); }\n-\n-  template <typename _Container>\n-    constexpr auto\n-    __adl_data(_Container& __cont) noexcept(noexcept(data(__cont)))\n-    { return data(__cont); }\n-\n #ifdef __cpp_lib_concepts\n namespace ranges\n {\n@@ -869,11 +856,71 @@ namespace ranges\n   template<typename _Tp>\n     concept range = __detail::__range_impl<_Tp&>;\n \n+  template<range _Range>\n+    using sentinel_t = decltype(ranges::end(std::declval<_Range&>()));\n+\n+  template<range _Range>\n+    using iterator_t = decltype(ranges::begin(std::declval<_Range&>()));\n+\n+  template<range _Range>\n+    using range_value_t = iter_value_t<iterator_t<_Range>>;\n+\n+  template<range _Range>\n+    using range_reference_t = iter_reference_t<iterator_t<_Range>>;\n+\n+  template<range _Range>\n+    using range_rvalue_reference_t\n+      = iter_rvalue_reference_t<iterator_t<_Range>>;\n+\n+  template<range _Range>\n+    using range_difference_t = iter_difference_t<iterator_t<_Range>>;\n+\n+  namespace __detail\n+  {\n+    template<typename _Tp>\n+      concept __forwarding_range = range<_Tp> && __range_impl<_Tp>;\n+  } // namespace __detail\n+\n   /// [range.sized] The sized_range concept.\n   template<typename _Tp>\n     concept sized_range = range<_Tp>\n       && requires(_Tp& __t) { ranges::size(__t); };\n \n+  template<typename>\n+    inline constexpr bool disable_sized_range = false;\n+\n+  // [range.refinements]\n+  template<typename _Range, typename _Tp>\n+    concept output_range\n+      = range<_Range> && output_iterator<iterator_t<_Range>, _Tp>;\n+\n+  template<typename _Tp>\n+    concept input_range = range<_Tp> && input_iterator<iterator_t<_Tp>>;\n+\n+  template<typename _Tp>\n+    concept forward_range\n+      = input_range<_Tp> && forward_iterator<iterator_t<_Tp>>;\n+\n+  template<typename _Tp>\n+    concept bidirectional_range\n+      = forward_range<_Tp> && bidirectional_iterator<iterator_t<_Tp>>;\n+\n+  template<typename _Tp>\n+    concept random_access_range\n+      = bidirectional_range<_Tp> && random_access_iterator<iterator_t<_Tp>>;\n+\n+  template<typename _Tp>\n+    concept contiguous_range\n+      = random_access_range<_Tp> && contiguous_iterator<iterator_t<_Tp>>\n+      && requires(_Tp& __t)\n+      {\n+\t{ ranges::data(__t) } -> same_as<add_pointer_t<range_reference_t<_Tp>>>;\n+      };\n+\n+  template<typename _Tp>\n+    concept common_range\n+      = range<_Tp> && same_as<iterator_t<_Tp>, sentinel_t<_Tp>>;\n+\n     // [range.iter.ops] range iterator operations\n \n   template<input_or_output_iterator _It>\n@@ -1008,12 +1055,6 @@ namespace ranges\n \t}\n     }\n \n-  template<range _Range>\n-    using iterator_t = decltype(ranges::begin(std::declval<_Range&>()));\n-\n-  template<range _Range>\n-    using range_difference_t = iter_difference_t<iterator_t<_Range>>;\n-\n   template<range _Range>\n     constexpr range_difference_t<_Range>\n     distance(_Range&& __r)"}, {"sha": "e1bf6eec5d03fb58d7c1bb43cb48f90452f4c03c", "filename": "libstdc++-v3/include/std/ranges", "status": "modified", "additions": 2, "deletions": 55, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7922ddf481b048c0aaa5fae9d836d656e08d850/libstdc%2B%2B-v3%2Finclude%2Fstd%2Franges", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7922ddf481b048c0aaa5fae9d836d656e08d850/libstdc%2B%2B-v3%2Finclude%2Fstd%2Franges", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Franges?ref=a7922ddf481b048c0aaa5fae9d836d656e08d850", "patch": "@@ -56,64 +56,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n namespace ranges\n {\n   // [range.range] The range concept.\n-  // Defined in <bits/range_iterator.h>\n-  // template<typename> concept range;\n-\n-  template<range _Range>\n-    using sentinel_t = decltype(ranges::end(std::declval<_Range&>()));\n-\n-  template<range _Range>\n-    using range_value_t = iter_value_t<iterator_t<_Range>>;\n-\n-  template<range _Range>\n-    using range_reference_t = iter_reference_t<iterator_t<_Range>>;\n-\n-  template<range _Range>\n-    using range_rvalue_reference_t\n-      = iter_rvalue_reference_t<iterator_t<_Range>>;\n-\n-  namespace __detail\n-  {\n-    template<typename _Tp>\n-      concept __forwarding_range = range<_Tp> && __range_impl<_Tp>;\n-  } // namespace __detail\n-\n   // [range.sized] The sized_range concept.\n-  // Defined in <bits/range_iterator.h>\n-  // template<typename> concept sized_range;\n+  // Defined in <bits/range_access.h>\n \n   // [range.refinements]\n-\n-  template<typename _Range, typename _Tp>\n-    concept output_range\n-      = range<_Range> && output_iterator<iterator_t<_Range>, _Tp>;\n-\n-  template<typename _Tp>\n-    concept input_range = range<_Tp> && input_iterator<iterator_t<_Tp>>;\n-\n-  template<typename _Tp>\n-    concept forward_range\n-      = input_range<_Tp> && forward_iterator<iterator_t<_Tp>>;\n-\n-  template<typename _Tp>\n-    concept bidirectional_range\n-      = forward_range<_Tp> && bidirectional_iterator<iterator_t<_Tp>>;\n-\n-  template<typename _Tp>\n-    concept random_access_range\n-      = bidirectional_range<_Tp> && random_access_iterator<iterator_t<_Tp>>;\n-\n-  template<typename _Tp>\n-    concept contiguous_range\n-      = random_access_range<_Tp> && contiguous_iterator<iterator_t<_Tp>>\n-      && requires(_Tp& __t)\n-      {\n-\t{ ranges::data(__t) } -> same_as<add_pointer_t<range_reference_t<_Tp>>>;\n-      };\n-\n-  template<typename _Tp>\n-    concept common_range\n-      = range<_Tp> && same_as<iterator_t<_Tp>, sentinel_t<_Tp>>;\n+  // Defined in <bits/range_access.h>\n \n   struct view_base { };\n "}, {"sha": "c71f8bc3f89742fe3b6ba3a6aa8eb1ddb8dd0cea", "filename": "libstdc++-v3/include/std/span", "status": "modified", "additions": 59, "deletions": 153, "changes": 212, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7922ddf481b048c0aaa5fae9d836d656e08d850/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fspan", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7922ddf481b048c0aaa5fae9d836d656e08d850/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fspan", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fspan?ref=a7922ddf481b048c0aaa5fae9d836d656e08d850", "patch": "@@ -45,6 +45,7 @@\n #include <bits/stl_iterator.h>\n #include <bits/range_access.h>\n \n+#if __cpp_lib_concepts\n namespace std _GLIBCXX_VISIBILITY(default)\n {\n _GLIBCXX_BEGIN_NAMESPACE_VERSION\n@@ -104,7 +105,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       private:\n \tsize_t _M_extent_value;\n       };\n-\n   } // namespace __detail\n \n   template<typename _Type, size_t _Extent = dynamic_extent>\n@@ -122,21 +122,29 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t    return dynamic_extent;\n \t}\n \n-      template<typename _Tp>\n-\tusing __is_compatible = is_convertible<_Tp(*)[], _Type(*)[]>;\n-\n       // _GLIBCXX_RESOLVE_LIB_DEFECTS\n       // 3255. span's array constructor is too strict\n-      template<typename _Tp, size_t _ArrayExtent,\n-\t       typename = enable_if_t<_Extent == dynamic_extent\n-\t\t\t\t      || _ArrayExtent == _Extent>>\n-\tusing __is_compatible_array  = __is_compatible<_Tp>;\n+      template<typename _Tp, size_t _ArrayExtent>\n+\tusing __is_compatible_array = __and_<\n+\t  bool_constant<(_Extent == dynamic_extent || _ArrayExtent == _Extent)>,\n+\t  __is_array_convertible<_Type, _Tp>>;\n+\n+      template<typename _Iter, typename _Ref = iter_reference_t<_Iter>>\n+\tusing __is_compatible_iterator = __and_<\n+\t  bool_constant<contiguous_iterator<_Iter>>,\n+\t  is_lvalue_reference<iter_reference_t<_Iter>>,\n+\t  is_same<iter_value_t<_Iter>, remove_cvref_t<_Ref>>,\n+\t  __is_array_convertible<_Type, remove_reference_t<_Ref>>>;\n+\n+      template<typename _Range>\n+\tusing __is_compatible_range\n+\t  = __is_compatible_iterator<ranges::iterator_t<_Range>>;\n \n     public:\n       // member types\n       using value_type             = remove_cv_t<_Type>;\n       using element_type           = _Type;\n-      using index_type             = size_t;\n+      using size_type              = size_t;\n       using reference              = element_type&;\n       using const_reference        = const element_type&;\n       using pointer                = _Type*;\n@@ -148,168 +156,80 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       using reverse_iterator       = std::reverse_iterator<iterator>;\n       using const_reverse_iterator = std::reverse_iterator<const_iterator>;\n       using difference_type        = ptrdiff_t;\n-      // Official wording has no size_type -- why??\n-      // using size_type = size_t;\n \n       // member constants\n       static inline constexpr size_t extent = _Extent;\n \n       // constructors\n \n-      template<bool _DefaultConstructible = (_Extent + 1u) <= 1u,\n-\t       enable_if_t<_DefaultConstructible>* = nullptr>\n-\tconstexpr\n-\tspan() noexcept : _M_extent(0), _M_ptr(nullptr)\n-\t{ }\n+      constexpr\n+      span() noexcept\n+      requires ((_Extent + 1u) <= 1u)\n+      : _M_extent(0), _M_ptr(nullptr)\n+      { }\n \n       constexpr\n       span(const span&) noexcept = default;\n \n-      template<typename _Tp, size_t _ArrayExtent,\n-\t       typename = _Require<__is_compatible_array<_Tp, _ArrayExtent>>>\n+      template<typename _Tp, size_t _ArrayExtent>\n+\trequires (__is_compatible_array<_Tp, _ArrayExtent>::value)\n \tconstexpr\n \tspan(_Tp (&__arr)[_ArrayExtent]) noexcept\n \t: span(static_cast<pointer>(__arr), _ArrayExtent)\n \t{ }\n \n-      template<typename _Tp, size_t _ArrayExtent,\n-\t       typename = _Require<__is_compatible_array<_Tp, _ArrayExtent>>>\n+      template<typename _Tp, size_t _ArrayExtent>\n+\trequires (__is_compatible_array<_Tp, _ArrayExtent>::value)\n \tconstexpr\n \tspan(array<_Tp, _ArrayExtent>& __arr) noexcept\n \t: span(static_cast<pointer>(__arr.data()), _ArrayExtent)\n \t{ }\n \n-      template<typename _Tp, size_t _ArrayExtent,\n-\t       typename = _Require<__is_compatible_array<_Tp, _ArrayExtent>>>\n+      template<typename _Tp, size_t _ArrayExtent>\n+\t  requires (__is_compatible_array<const _Tp, _ArrayExtent>::value)\n \tconstexpr\n \tspan(const array<_Tp, _ArrayExtent>& __arr) noexcept\n \t: span(static_cast<pointer>(__arr.data()), _ArrayExtent)\n \t{ }\n \n-      // NOTE: when the time comes, and P1394 -\n-      // range constructors for std::span - ships in\n-      // the standard, delete the #else block and remove\n-      // the conditional\n-      // if the paper fails, delete #if block\n-      // and keep the crappy #else block\n-      // and then cry that NB comments failed C++20...\n-      // but maybe for C++23?\n-#ifdef _GLIBCXX_P1394\n-    private:\n-      // FIXME: use std::iter_reference_t\n-      template<typename _Iterator>\n-\tusing iter_reference_t = decltype(*std::declval<_Iterator&>());\n-      // FIXME: use std::ranges::iterator_t\n-      // N.B. constraint is needed to prevent a cycle when __adl_begin finds\n-      // begin(span) which does overload resolution on span(Range&&).\n-      template<typename _Rng,\n-\t       typename _Rng2 = remove_cvref_t<_Rng>,\n-\t       typename = enable_if_t<!__detail::__is_std_span<_Rng2>::value>>\n-\tusing iterator_t = decltype(std::__adl_begin(std::declval<_Rng&>()));\n-      // FIXME: use std::iter_value_t\n-      template<typename _Iter>\n-\tusing iter_value_t = typename iterator_traits<_Iter>::value_type;\n-      // FIXME: use std::derived_from concept\n-      template<typename _Derived, typename _Base>\n-\tusing derived_from\n-\t  = __and_<is_base_of<_Base, _Derived>,\n-\t      is_convertible<const volatile _Derived*, const volatile _Base*>>;\n-      // FIXME: require contiguous_iterator<_Iterator>\n-      template<typename _Iter,\n-\t       typename _Ref = iter_reference_t<_Iter>,\n-\t       typename _Traits = iterator_traits<_Iter>,\n-\t       typename _Tag = typename _Traits::iterator_category>\n-\tusing __is_compatible_iterator\n-\t  = __and_<derived_from<_Tag, random_access_iterator_tag>,\n-\t\t   is_lvalue_reference<_Ref>,\n-\t\t   is_same<iter_value_t<_Iter>, remove_cvref_t<_Ref>>,\n-\t\t   __is_compatible<remove_reference_t<_Ref>>>;\n-\n-      template<typename _Range>\n-\tusing __is_compatible_range\n-\t  = __is_compatible_iterator<iterator_t<_Range>>;\n-\n     public:\n-      template<typename _Range, typename = _Require<\n-\t  bool_constant<_Extent == dynamic_extent>,\n-\t  __not_<__detail::__is_std_span<remove_cvref_t<_Range>>>,\n-\t  __not_<__detail::__is_std_array<remove_cvref_t<_Range>>>,\n-\t  __not_<is_array<remove_reference_t<_Range>>>,\n-\t  __is_compatible_range<_Range>>,\n-\t  typename = decltype(std::__adl_data(std::declval<_Range&>()))>\n+      template<ranges::contiguous_range _Range>\n+\trequires (_Extent == dynamic_extent)\n+\t  && (!__detail::__is_std_span<remove_cvref_t<_Range>>::value)\n+\t  && (!__detail::__is_std_array<remove_cvref_t<_Range>>::value)\n+\t  && (!is_array_v<remove_reference_t<_Range>>)\n+\t  && (__is_compatible_range<_Range>::value)\n \tconstexpr\n \tspan(_Range&& __range)\n-\tnoexcept(noexcept(::std::__adl_data(__range))\n-\t\t  && noexcept(::std::__adl_size(__range)))\n-\t: span(::std::__adl_data(__range), ::std::__adl_size(__range))\n+\tnoexcept(noexcept(ranges::data(__range))\n+\t\t  && noexcept(ranges::size(__range)))\n+\t: span(ranges::data(__range), ranges::size(__range))\n \t{ }\n \n-      template<typename _ContiguousIterator, typename _Sentinel, typename\n-\t\t= _Require<__not_<is_convertible<_Sentinel, index_type>>,\n-\t\t\t   __is_compatible_iterator<_ContiguousIterator>>>\n+      template<contiguous_iterator _ContiguousIterator,\n+\tsized_sentinel_for<_ContiguousIterator> _Sentinel>\n+\t  requires (__is_compatible_iterator<_ContiguousIterator>::value)\n+\t    && (!is_convertible_v<_Sentinel, size_type>)\n \tconstexpr\n \tspan(_ContiguousIterator __first, _Sentinel __last)\n-\t: _M_extent(static_cast<index_type>(__last - __first)),\n+\t: _M_extent(static_cast<size_type>(__last - __first)),\n \t  _M_ptr(std::to_address(__first))\n \t{\n \t  if (_Extent != dynamic_extent)\n \t    __glibcxx_assert((__last - __first) == _Extent);\n \t}\n \n-      template<typename _ContiguousIterator, typename\n-\t\t= _Require<__is_compatible_iterator<_ContiguousIterator>>>\n+      template<contiguous_iterator _ContiguousIterator>\n+\trequires (__is_compatible_iterator<_ContiguousIterator>::value)\n \tconstexpr\n-\tspan(_ContiguousIterator __first, index_type __count)\n+\tspan(_ContiguousIterator __first, size_type __count)\n \tnoexcept(noexcept(std::to_address(__first)))\n \t: _M_extent(__count), _M_ptr(std::to_address(__first))\n \t{ __glibcxx_assert(_Extent == dynamic_extent || __count == _Extent); }\n-#else\n-    private:\n-      template<typename _Container,\n-\t  typename _DataT = decltype(std::data(std::declval<_Container&>())),\n-\t  typename _SizeT = decltype(std::size(std::declval<_Container&>()))>\n-\tusing __is_compatible_container\n-\t  = __is_compatible<remove_pointer_t<_DataT>>;\n \n-    public:\n-      template<typename _Container, typename = _Require<\n-\t\tbool_constant<_Extent == dynamic_extent>,\n-\t\t__not_<__detail::__is_std_span<remove_cv_t<_Container>>>,\n-\t\t__not_<__detail::__is_std_array<remove_cv_t<_Container>>>,\n-\t\t__not_<is_array<_Container>>,\n-\t\t__is_compatible_container<_Container>>>\n-\tconstexpr\n-\tspan(_Container& __cont)\n-\tnoexcept(noexcept(std::data(__cont)) && noexcept(std::size(__cont)))\n-\t: _M_extent(std::size(__cont)), _M_ptr(std::data(__cont))\n-\t{ }\n-\n-      template<typename _Container, typename = _Require<\n-\t\tbool_constant<_Extent == dynamic_extent>,\n-\t\t__not_<__detail::__is_std_span<remove_cv_t<_Container>>>,\n-\t\t__not_<__detail::__is_std_array<remove_cv_t<_Container>>>,\n-\t\t__not_<is_array<_Container>>,\n-\t\t__is_compatible_container<const _Container>>>\n-\tconstexpr\n-\tspan(const _Container& __cont)\n-\tnoexcept(noexcept(std::data(__cont)) && noexcept(std::size(__cont)))\n-\t: _M_extent(std::size(__cont)), _M_ptr(std::data(__cont))\n-\t{ }\n-\n-      constexpr\n-      span(pointer __first, index_type __count) noexcept\n-      : _M_extent(__count), _M_ptr(__first)\n-      { __glibcxx_assert(_Extent == dynamic_extent || __count == _Extent); }\n-\n-      constexpr\n-      span(pointer __first, pointer __last) noexcept\n-      : span(__first, static_cast<index_type>(__last - __first))\n-      { }\n-#endif // P1394\n-\n-      template<typename _OType, size_t _OExtent, typename = _Require<\n-\t  __bool_constant<_Extent == dynamic_extent || _Extent == _OExtent>,\n-\t  is_convertible<_OType(*)[], _Type(*)[]>>>\n+      template<typename _OType, size_t _OExtent>\n+\trequires (_Extent == dynamic_extent || _Extent == _OExtent)\n+\t  && (__is_array_convertible<_Type, _OType>::value)\n \tconstexpr\n \tspan(const span<_OType, _OExtent>& __s) noexcept\n \t: _M_extent(__s.size()), _M_ptr(__s.data())\n@@ -322,11 +242,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n       // observers\n \n-      constexpr index_type\n+      constexpr size_type\n       size() const noexcept\n       { return this->_M_extent._M_extent(); }\n \n-      constexpr index_type\n+      constexpr size_type\n       size_bytes() const noexcept\n       { return this->_M_extent._M_extent() * sizeof(element_type); }\n \n@@ -353,7 +273,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       }\n \n       constexpr reference\n-      operator[](index_type __idx) const noexcept\n+      operator[](size_type __idx) const noexcept\n       {\n \tstatic_assert(extent != 0);\n \t__glibcxx_assert(__idx < size());\n@@ -412,7 +332,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t}\n \n       constexpr span<element_type, dynamic_extent>\n-      first(index_type __count) const noexcept\n+      first(size_type __count) const noexcept\n       {\n \t__glibcxx_assert(__count <= size());\n \treturn { this->data(), __count };\n@@ -430,7 +350,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t}\n \n       constexpr span<element_type, dynamic_extent>\n-      last(index_type __count) const noexcept\n+      last(size_type __count) const noexcept\n       {\n \t__glibcxx_assert(__count <= size());\n \treturn { this->data() + (this->size() - __count), __count };\n@@ -465,7 +385,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t}\n \n       constexpr span<element_type, dynamic_extent>\n-      subspan(index_type __offset, index_type __count = dynamic_extent) const\n+      subspan(size_type __offset, size_type __count = dynamic_extent) const\n       noexcept\n       {\n \t__glibcxx_assert(__offset <= size());\n@@ -505,27 +425,13 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     span(const array<_Type, _ArrayExtent>&)\n       -> span<const _Type, _ArrayExtent>;\n \n-#ifdef _GLIBCXX_P1394\n-\n-  template<typename _ContiguousIterator, typename _Sentinel>\n-    span(_ContiguousIterator, _Sentinel)\n-      -> span<remove_reference_t<\n-\ttypename iterator_traits<_ContiguousIterator>::reference>>;\n+  template<contiguous_iterator _Iter, typename _Sentinel>\n+    span(_Iter, _Sentinel)\n+      -> span<remove_reference_t<ranges::range_reference_t<_Iter>>>;\n \n   template<typename _Range>\n     span(_Range &&)\n-      -> span<remove_reference_t<typename iterator_traits<\n-\t  decltype(std::__adl_begin(::std::declval<_Range&>()))>::reference>>;\n-\n-#else\n-\n-  template<typename _Container>\n-    span(_Container&) -> span<typename _Container::value_type>;\n-\n-  template<typename _Container>\n-    span(const _Container&) -> span<const typename _Container::value_type>;\n-\n-#endif // P1394\n+      -> span<remove_reference_t<ranges::range_reference_t<_Range&>>>;\n \n   template<typename _Type, size_t _Extent>\n     inline\n@@ -574,6 +480,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n _GLIBCXX_END_NAMESPACE_VERSION\n } // namespace std\n-\n+#endif // concepts\n #endif // C++20\n #endif // _GLIBCXX_SPAN"}, {"sha": "28981d84e76f5337271c4b370bdab75e0b71b889", "filename": "libstdc++-v3/include/std/type_traits", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7922ddf481b048c0aaa5fae9d836d656e08d850/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftype_traits", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7922ddf481b048c0aaa5fae9d836d656e08d850/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftype_traits", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftype_traits?ref=a7922ddf481b048c0aaa5fae9d836d656e08d850", "patch": "@@ -1475,6 +1475,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     };\n #pragma GCC diagnostic pop\n \n+  // helper trait for unique_ptr<T[]>, shared_ptr<T[]>, and span<T, N>\n+  template<typename _ToElementType, typename _FromElementType>\n+    using __is_array_convertible\n+      = is_convertible<_FromElementType(*)[], _ToElementType(*)[]>;\n+\n   // is_nothrow_convertible for C++11\n   template<typename _From, typename _To>\n     struct __is_nothrow_convertible"}]}