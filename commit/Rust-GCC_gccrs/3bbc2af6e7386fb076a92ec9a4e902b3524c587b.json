{"sha": "3bbc2af6e7386fb076a92ec9a4e902b3524c587b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2JiYzJhZjZlNzM4NmZiMDc2YTkyZWM5YTRlOTAyYjM1MjRjNTg3Yg==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2003-12-25T04:49:32Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2003-12-25T04:49:32Z"}, "message": "elf.h: Fix comment formatting.\n\n\t* config/xtensa/elf.h: Fix comment formatting.\n\t* config/xtensa/xtensa-protos.h: Likewise.\n\t* config/xtensa/xtensa.c: Likewise.\n\t* config/xtensa/xtensa.h: Likewise.\n\nFrom-SVN: r75018", "tree": {"sha": "79d78595bbfec3135627370a23ac0e181918cdb4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/79d78595bbfec3135627370a23ac0e181918cdb4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3bbc2af6e7386fb076a92ec9a4e902b3524c587b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3bbc2af6e7386fb076a92ec9a4e902b3524c587b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3bbc2af6e7386fb076a92ec9a4e902b3524c587b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3bbc2af6e7386fb076a92ec9a4e902b3524c587b/comments", "author": null, "committer": null, "parents": [{"sha": "be886286218f7b11a4bfcc754f7abcae0b345beb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be886286218f7b11a4bfcc754f7abcae0b345beb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/be886286218f7b11a4bfcc754f7abcae0b345beb"}], "stats": {"total": 141, "additions": 74, "deletions": 67}, "files": [{"sha": "0dd837b7075c9b96e76197d8f96c5a49c4fbca92", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bbc2af6e7386fb076a92ec9a4e902b3524c587b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bbc2af6e7386fb076a92ec9a4e902b3524c587b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3bbc2af6e7386fb076a92ec9a4e902b3524c587b", "patch": "@@ -1,3 +1,10 @@\n+2003-12-24  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* config/xtensa/elf.h: Fix comment formatting.\n+\t* config/xtensa/xtensa-protos.h: Likewise.\n+\t* config/xtensa/xtensa.c: Likewise.\n+\t* config/xtensa/xtensa.h: Likewise.\n+\n 2003-12-24  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* config/avr/avr.c: Fix comment formatting."}, {"sha": "1ef309bfa8cea8d1193fba7f98cbde13fd413175", "filename": "gcc/config/xtensa/elf.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bbc2af6e7386fb076a92ec9a4e902b3524c587b/gcc%2Fconfig%2Fxtensa%2Felf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bbc2af6e7386fb076a92ec9a4e902b3524c587b/gcc%2Fconfig%2Fxtensa%2Felf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Felf.h?ref=3bbc2af6e7386fb076a92ec9a4e902b3524c587b", "patch": "@@ -21,7 +21,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n \n #define TARGET_SECTION_TYPE_FLAGS xtensa_multibss_section_type_flags\n \n-/* Don't assume anything about the header files. */\n+/* Don't assume anything about the header files.  */\n #define NO_IMPLICIT_EXTERN_C\n \n #undef ASM_APP_ON"}, {"sha": "cf7f09075c97214616a5fa72efa592cc0e293434", "filename": "gcc/config/xtensa/xtensa-protos.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bbc2af6e7386fb076a92ec9a4e902b3524c587b/gcc%2Fconfig%2Fxtensa%2Fxtensa-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bbc2af6e7386fb076a92ec9a4e902b3524c587b/gcc%2Fconfig%2Fxtensa%2Fxtensa-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Fxtensa-protos.h?ref=3bbc2af6e7386fb076a92ec9a4e902b3524c587b", "patch": "@@ -22,7 +22,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #ifndef __XTENSA_PROTOS_H__\n #define __XTENSA_PROTOS_H__\n \n-/* Functions to test whether an immediate fits in a given field. */\n+/* Functions to test whether an immediate fits in a given field.  */\n extern int xtensa_simm7 (int);\n extern int xtensa_simm8 (int);\n extern int xtensa_simm8x256 (int);"}, {"sha": "e8926c9c1e36c6eace948e6914fb7b767b69586c", "filename": "gcc/config/xtensa/xtensa.c", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bbc2af6e7386fb076a92ec9a4e902b3524c587b/gcc%2Fconfig%2Fxtensa%2Fxtensa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bbc2af6e7386fb076a92ec9a4e902b3524c587b/gcc%2Fconfig%2Fxtensa%2Fxtensa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Fxtensa.c?ref=3bbc2af6e7386fb076a92ec9a4e902b3524c587b", "patch": "@@ -600,7 +600,7 @@ move_operand (rtx op, enum machine_mode mode)\n     case SImode:\n       if (TARGET_CONST16)\n \treturn CONSTANT_P (op);\n-      /* fall through */\n+      /* Fall through.  */\n \n     case HImode:\n     case QImode:\n@@ -652,12 +652,12 @@ constantpool_address_p (rtx addr)\n     {\n       rtx offset;\n \n-      /* only handle (PLUS (SYM, OFFSET)) form */\n+      /* Only handle (PLUS (SYM, OFFSET)) form.  */\n       addr = XEXP (addr, 0);\n       if (GET_CODE (addr) != PLUS)\n \treturn FALSE;\n \n-      /* make sure the address is word aligned */\n+      /* Make sure the address is word aligned.  */\n       offset = XEXP (addr, 1);\n       if ((GET_CODE (offset) != CONST_INT)\n \t  || ((INTVAL (offset) & 3) != 0))\n@@ -728,7 +728,7 @@ xtensa_extend_reg (rtx dst, rtx src)\n   rtx temp = gen_reg_rtx (SImode);\n   rtx shift = GEN_INT (BITS_PER_WORD - GET_MODE_BITSIZE (GET_MODE (src)));\n \n-  /* generate paradoxical subregs as needed so that the modes match */\n+  /* Generate paradoxical subregs as needed so that the modes match.  */\n   src = simplify_gen_subreg (SImode, src, GET_MODE (src), 0);\n   dst = simplify_gen_subreg (SImode, dst, GET_MODE (dst), 0);\n \n@@ -1080,14 +1080,14 @@ gen_conditional_move (rtx cmp)\n \n       if (boolean_operator (cmp, VOIDmode))\n \t{\n-\t  /* swap the operands to make const0 second */\n+\t  /* Swap the operands to make const0 second.  */\n \t  if (op0 == const0_rtx)\n \t    {\n \t      op0 = op1;\n \t      op1 = const0_rtx;\n \t    }\n \n-\t  /* if not comparing against zero, emit a comparison (subtract) */\n+\t  /* If not comparing against zero, emit a comparison (subtract).  */\n \t  if (op1 != const0_rtx)\n \t    {\n \t      op0 = expand_binop (SImode, sub_optab, op0, op1,\n@@ -1097,7 +1097,7 @@ gen_conditional_move (rtx cmp)\n \t}\n       else if (branch_operator (cmp, VOIDmode))\n \t{\n-\t  /* swap the operands to make const0 second */\n+\t  /* Swap the operands to make const0 second.  */\n \t  if (op0 == const0_rtx)\n \t    {\n \t      op0 = op1;\n@@ -1379,26 +1379,26 @@ xtensa_expand_block_move (rtx *operands)\n   int align = XINT (operands[3], 0);\n   int num_pieces, move_ratio;\n \n-  /* If this is not a fixed size move, just call memcpy */\n+  /* If this is not a fixed size move, just call memcpy.  */\n   if (!optimize || (GET_CODE (operands[2]) != CONST_INT))\n     return 0;\n \n-  /* Anything to move? */\n+  /* Anything to move?  */\n   if (bytes <= 0)\n     return 1;\n \n   if (align > MOVE_MAX)\n     align = MOVE_MAX;\n \n-  /* decide whether to expand inline based on the optimization level */\n+  /* Decide whether to expand inline based on the optimization level.  */\n   move_ratio = 4;\n   if (optimize > 2)\n     move_ratio = LARGEST_MOVE_RATIO;\n-  num_pieces = (bytes / align) + (bytes % align); /* close enough anyway */\n+  num_pieces = (bytes / align) + (bytes % align); /* Close enough anyway.  */\n   if (num_pieces >= move_ratio)\n     return 0;\n \n-  /* make sure the memory addresses are valid */\n+  /* Make sure the memory addresses are valid.  */\n   operands[0] = validize_mem (dest);\n   operands[1] = validize_mem (src);\n \n@@ -1408,10 +1408,10 @@ xtensa_expand_block_move (rtx *operands)\n }\n \n \n-/*  Emit a sequence of instructions to implement a block move, trying\n-    to hide load delay slots as much as possible.  Load N values into\n-    temporary registers, store those N values, and repeat until the\n-    complete block has been moved.  N=delay_slots+1 */\n+/* Emit a sequence of instructions to implement a block move, trying\n+   to hide load delay slots as much as possible.  Load N values into\n+   temporary registers, store those N values, and repeat until the\n+   complete block has been moved.  N=delay_slots+1.  */\n \n struct meminsnbuf\n {\n@@ -1467,15 +1467,15 @@ xtensa_emit_block_move (rtx *operands, rtx *tmpregs, int delay_slots)\n \n \t  if (bytes < item_size)\n \t    {\n-\t      /* find a smaller item_size which we can load & store */\n+\t      /* Find a smaller item_size which we can load & store.  */\n \t      item_size = bytes;\n \t      mode = xtensa_find_mode_for_size (item_size);\n \t      item_size = GET_MODE_SIZE (mode);\n \t      ldname = xtensa_ld_opcodes[(int) mode];\n \t      stname = xtensa_st_opcodes[(int) mode];\n \t    }\n \n-\t  /* record the load instruction opcode and operands */\n+\t  /* Record the load instruction opcode and operands.  */\n \t  addr = plus_constant (from_addr, offset);\n \t  mem = gen_rtx_MEM (mode, addr);\n \t  if (! memory_address_p (mode, addr))\n@@ -1485,7 +1485,7 @@ xtensa_emit_block_move (rtx *operands, rtx *tmpregs, int delay_slots)\n \t  ldinsns[n].operands[1] = mem;\n \t  sprintf (ldinsns[n].template, \"%s\\t%%0, %%1\", ldname);\n \n-\t  /* record the store instruction opcode and operands */\n+\t  /* Record the store instruction opcode and operands.  */\n \t  addr = plus_constant (to_addr, offset);\n \t  mem = gen_rtx_MEM (mode, addr);\n \t  if (! memory_address_p (mode, addr))\n@@ -1499,7 +1499,7 @@ xtensa_emit_block_move (rtx *operands, rtx *tmpregs, int delay_slots)\n \t  bytes -= item_size;\n \t}\n \n-      /* now output the loads followed by the stores */\n+      /* Now output the loads followed by the stores.  */\n       for (n = 0; n < chunk_size; n++)\n \toutput_asm_insn (ldinsns[n].template, ldinsns[n].operands);\n       for (n = 0; n < chunk_size; n++)\n@@ -1517,7 +1517,7 @@ xtensa_find_mode_for_size (unsigned item_size)\n     {\n       mode = VOIDmode;\n \n-      /* find mode closest to but not bigger than item_size */\n+      /* Find mode closest to but not bigger than item_size.  */\n       for (tmode = GET_CLASS_NARROWEST_MODE (MODE_INT);\n \t   tmode != VOIDmode; tmode = GET_MODE_WIDER_MODE (tmode))\n \tif (GET_MODE_SIZE (tmode) <= item_size)\n@@ -1531,7 +1531,7 @@ xtensa_find_mode_for_size (unsigned item_size)\n \t  && xtensa_st_opcodes[(int) mode])\n \tbreak;\n \n-      /* cannot load & store this mode; try something smaller */\n+      /* Cannot load & store this mode; try something smaller.  */\n       item_size -= 1;\n     }\n \n@@ -1545,8 +1545,8 @@ xtensa_expand_nonlocal_goto (rtx *operands)\n   rtx goto_handler = operands[1];\n   rtx containing_fp = operands[3];\n \n-  /* generate a call to \"__xtensa_nonlocal_goto\" (in libgcc); the code\n-     is too big to generate in-line */\n+  /* Generate a call to \"__xtensa_nonlocal_goto\" (in libgcc); the code\n+     is too big to generate in-line.  */\n \n   if (GET_CODE (containing_fp) != REG)\n     containing_fp = force_reg (Pmode, containing_fp);\n@@ -1789,7 +1789,7 @@ override_options (void)\n   if (!TARGET_BOOLEANS && TARGET_HARD_FLOAT)\n     error (\"boolean registers required for the floating-point option\");\n \n-  /* set up the tables of ld/st opcode names for block moves */\n+  /* Set up the tables of ld/st opcode names for block moves.  */\n   xtensa_ld_opcodes[(int) SImode] = \"l32i\";\n   xtensa_ld_opcodes[(int) HImode] = \"l16ui\";\n   xtensa_ld_opcodes[(int) QImode] = \"l8ui\";\n@@ -2366,7 +2366,7 @@ xtensa_builtin_saveregs (void)\n   if (gp_left == 0)\n     return const0_rtx;\n \n-  /* allocate the general-purpose register space */\n+  /* Allocate the general-purpose register space.  */\n   gp_regs = assign_stack_local\n     (BLKmode, MAX_ARGS_IN_REGISTERS * UNITS_PER_WORD, -1);\n   set_mem_alias_set (gp_regs, get_varargs_alias_set ());\n@@ -2662,8 +2662,8 @@ order_regs_for_local_alloc (void)\n       int i, num_arg_regs;\n       int nxt = 0;\n \n-      /* use the AR registers in increasing order (skipping a0 and a1)\n-\t but save the incoming argument registers for a last resort */\n+      /* Use the AR registers in increasing order (skipping a0 and a1)\n+\t but save the incoming argument registers for a last resort.  */\n       num_arg_regs = current_function_args_info.arg_words;\n       if (num_arg_regs > MAX_ARGS_IN_REGISTERS)\n \tnum_arg_regs = MAX_ARGS_IN_REGISTERS;\n@@ -2672,11 +2672,11 @@ order_regs_for_local_alloc (void)\n       for (i = 0; i < num_arg_regs; i++)\n \treg_alloc_order[nxt++] = GP_ARG_FIRST + i;\n \n-      /* list the coprocessor registers in order */\n+      /* List the coprocessor registers in order.  */\n       for (i = 0; i < BR_REG_NUM; i++)\n \treg_alloc_order[nxt++] = BR_REG_FIRST + i;\n \n-      /* list the FP registers in order for now */\n+      /* List the FP registers in order for now.  */\n       for (i = 0; i < 16; i++)\n \treg_alloc_order[nxt++] = FP_REG_FIRST + i;\n \n@@ -2821,7 +2821,7 @@ xtensa_rtx_costs (rtx x, int code, int outer_code, int *total)\n \tcase LSHIFTRT:\n \tcase ROTATE:\n \tcase ROTATERT:\n-\t  /* no way to tell if X is the 2nd operand so be conservative */\n+\t  /* No way to tell if X is the 2nd operand so be conservative.  */\n \tdefault: break;\n \t}\n       if (xtensa_simm12b (INTVAL (x)))\n@@ -2948,7 +2948,7 @@ xtensa_rtx_costs (rtx x, int code, int outer_code, int *total)\n \t    return true;\n \t  }\n       }\n-      /* fall through */\n+      /* Fall through.  */\n \n     case UDIV:\n     case UMOD:"}, {"sha": "a7f470ec0b5a684d7e49dad030310813915e9ed9", "filename": "gcc/config/xtensa/xtensa.h", "status": "modified", "additions": 33, "deletions": 33, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bbc2af6e7386fb076a92ec9a4e902b3524c587b/gcc%2Fconfig%2Fxtensa%2Fxtensa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bbc2af6e7386fb076a92ec9a4e902b3524c587b/gcc%2Fconfig%2Fxtensa%2Fxtensa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Fxtensa.h?ref=3bbc2af6e7386fb076a92ec9a4e902b3524c587b", "patch": "@@ -142,10 +142,10 @@ extern unsigned xtensa_current_frame_size;\n    in instructions that operate on numbered bit-fields.  */\n #define BITS_BIG_ENDIAN (TARGET_BIG_ENDIAN != 0)\n \n-/* Define this if most significant byte of a word is the lowest numbered. */\n+/* Define this if most significant byte of a word is the lowest numbered.  */\n #define BYTES_BIG_ENDIAN (TARGET_BIG_ENDIAN != 0)\n \n-/* Define this if most significant word of a multiword number is the lowest. */\n+/* Define this if most significant word of a multiword number is the lowest.  */\n #define WORDS_BIG_ENDIAN (TARGET_BIG_ENDIAN != 0)\n \n #define MAX_BITS_PER_WORD 32\n@@ -271,11 +271,11 @@ extern unsigned xtensa_current_frame_size;\n \n #define FIRST_PSEUDO_REGISTER 36\n \n-/* Return the stabs register number to use for REGNO. */\n+/* Return the stabs register number to use for REGNO.  */\n #define DBX_REGISTER_NUMBER(REGNO) xtensa_dbx_register_number (REGNO)\n \n /* 1 for registers that have pervasive standard uses\n-   and are not available for the register allocator. */\n+   and are not available for the register allocator.  */\n #define FIXED_REGISTERS\t\t\t\t\t\t\t\\\n {\t\t\t\t\t\t\t\t\t\\\n   1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\t\t\t\\\n@@ -326,18 +326,18 @@ extern unsigned xtensa_current_frame_size;\n    giving preference to call-used registers.  To minimize window\n    overflows for the AR registers, we want to give preference to the\n    lower-numbered AR registers.  For other register files, which are\n-   not windowed, we still prefer call-used registers, if there are any. */\n+   not windowed, we still prefer call-used registers, if there are any.  */\n extern const char xtensa_leaf_regs[FIRST_PSEUDO_REGISTER];\n #define LEAF_REGISTERS xtensa_leaf_regs\n \n /* For Xtensa, no remapping is necessary, but this macro must be\n-   defined if LEAF_REGISTERS is defined. */\n+   defined if LEAF_REGISTERS is defined.  */\n #define LEAF_REG_REMAP(REGNO) (REGNO)\n \n-/* this must be declared if LEAF_REGISTERS is set */\n+/* This must be declared if LEAF_REGISTERS is set.  */\n extern int leaf_function;\n \n-/* Internal macros to classify a register number. */\n+/* Internal macros to classify a register number.  */\n \n /* 16 address registers + fake registers */\n #define GP_REG_FIRST 0\n@@ -372,7 +372,7 @@ extern int leaf_function;\n \t((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD))\n \n /* Value is 1 if hard register REGNO can hold a value of machine-mode\n-   MODE. */\n+   MODE.  */\n extern char xtensa_hard_regno_mode_ok[][FIRST_PSEUDO_REGISTER];\n \n #define HARD_REGNO_MODE_OK(REGNO, MODE)\t\t\t\t\t\\\n@@ -397,7 +397,7 @@ extern char xtensa_hard_regno_mode_ok[][FIRST_PSEUDO_REGISTER];\n /* The register number of the frame pointer register, which is used to\n    access automatic variables in the stack frame.  For Xtensa, this\n    register never appears in the output.  It is always eliminated to\n-   either the stack pointer or the hard frame pointer. */\n+   either the stack pointer or the hard frame pointer.  */\n #define FRAME_POINTER_REGNUM (GP_REG_FIRST + 16)\n \n /* Value should be nonzero if functions must have frame pointers.\n@@ -518,7 +518,7 @@ extern const enum reg_class xtensa_regno_to_class[FIRST_PSEUDO_REGISTER];\n \n /* SMALL_REGISTER_CLASSES is required for Xtensa, because all of the\n    16 AR registers may be explicitly used in the RTL, as either\n-   incoming or outgoing arguments. */\n+   incoming or outgoing arguments.  */\n #define SMALL_REGISTER_CLASSES 1\n \n \n@@ -599,7 +599,7 @@ extern enum reg_class xtensa_char_to_class[256];\n    the meantime, the constraints are checked and none match.  The\n    solution seems to be to simply skip the offset check here.  The\n    address will be checked anyway because of the code in\n-   GO_IF_LEGITIMATE_ADDRESS. */\n+   GO_IF_LEGITIMATE_ADDRESS.  */\n \n #define EXTRA_CONSTRAINT(OP, CODE)\t\t\t\t\t\\\n   ((GET_CODE (OP) != MEM) ?\t\t\t\t\t\t\\\n@@ -714,7 +714,7 @@ extern enum reg_class xtensa_char_to_class[256];\n /* Define how to find the value returned by a library function\n    assuming the value has mode MODE.  Because we have defined\n    PROMOTE_FUNCTION_RETURN, we have to perform the same promotions as\n-   PROMOTE_MODE. */\n+   PROMOTE_MODE.  */\n #define XTENSA_LIBCALL_VALUE(MODE, OUTGOINGP)\t\t\t\t\\\n   gen_rtx_REG ((GET_MODE_CLASS (MODE) == MODE_INT\t\t\t\\\n \t\t&& GET_MODE_SIZE (MODE) < UNITS_PER_WORD)\t\t\\\n@@ -750,7 +750,7 @@ extern enum reg_class xtensa_char_to_class[256];\n    be recognized by this macro.  If the machine has register windows,\n    so that the caller and the called function use different registers\n    for the return value, this macro should recognize only the caller's\n-   register numbers. */\n+   register numbers.  */\n #define FUNCTION_VALUE_REGNO_P(N)\t\t\t\t\t\\\n   ((N) == GP_RETURN)\n \n@@ -759,22 +759,22 @@ extern enum reg_class xtensa_char_to_class[256];\n    does *not* include implicit arguments such as the static chain and\n    the structure-value address.  On many machines, no registers can be\n    used for this purpose since all function arguments are pushed on\n-   the stack. */\n+   the stack.  */\n #define FUNCTION_ARG_REGNO_P(N)\t\t\t\t\t\t\\\n   ((N) >= GP_OUTGOING_ARG_FIRST && (N) <= GP_OUTGOING_ARG_LAST)\n \n /* Define a data type for recording info about an argument list\n    during the scan of that argument list.  This data type should\n    hold all necessary information about the function itself\n    and about the args processed so far, enough to enable macros\n-   such as FUNCTION_ARG to determine where the next arg should go. */\n+   such as FUNCTION_ARG to determine where the next arg should go.  */\n typedef struct xtensa_args {\n     int arg_words;\t\t/* # total words the arguments take */\n } CUMULATIVE_ARGS;\n \n /* Initialize a variable CUM of type CUMULATIVE_ARGS\n    for a call to a function whose data type is FNTYPE.\n-   For a library call, FNTYPE is 0. */\n+   For a library call, FNTYPE is 0.  */\n #define INIT_CUMULATIVE_ARGS(CUM, FNTYPE, LIBNAME, INDIRECT)\t\t\\\n   init_cumulative_args (&CUM, FNTYPE, LIBNAME)\n \n@@ -816,7 +816,7 @@ typedef struct xtensa_args {\n \n    This differs from the default in that it does not check if the padding\n    and mode of the type are such that a copy into a register would put it\n-   into the wrong part of the register. */\n+   into the wrong part of the register.  */\n \n #define MUST_PASS_IN_STACK(MODE, TYPE)\t\t\t\t\t\\\n   ((TYPE) != 0\t\t\t\t\t\t\t\t\\\n@@ -835,7 +835,7 @@ typedef struct xtensa_args {\n    values contain window size information in the two most significant\n    bits; we assume that _mcount will mask off those bits.  The call to\n    _mcount uses a window size of 8 to make sure that it doesn't clobber\n-   any incoming argument values. */\n+   any incoming argument values.  */\n \n #define NO_PROFILE_COUNTERS\t1\n \n@@ -865,7 +865,7 @@ typedef struct xtensa_args {\n    from the entry instruction at the target and the current frame is\n    adjusted to match.  The trampoline then transfers control to the\n    instruction following the entry at the target.  Note: this assumes\n-   that the target begins with an entry instruction. */\n+   that the target begins with an entry instruction.  */\n \n /* minimum frame = reg save area (4 words) plus static chain (1 word)\n    and the total number of words must be a multiple of 128 bits */\n@@ -934,7 +934,7 @@ typedef struct xtensa_args {\n    code for a call to '__builtin_saveregs'.  This code will be moved\n    to the very beginning of the function, before any parameter access\n    are made.  The return value of this function should be an RTX that\n-   contains the value to use as the return of '__builtin_saveregs'. */\n+   contains the value to use as the return of '__builtin_saveregs'.  */\n #define EXPAND_BUILTIN_SAVEREGS \\\n   xtensa_builtin_saveregs\n \n@@ -962,7 +962,7 @@ typedef struct xtensa_args {\n    specify whether to start from the stack pointer or frame pointer.  That\n    would also allow us to skip the machine->accesses_prev_frame stuff that\n    we currently need to ensure that there is a frame pointer when these\n-   builtin functions are used. */\n+   builtin functions are used.  */\n \n #define SETUP_FRAME_ADDRESSES  xtensa_setup_frame_addresses\n \n@@ -976,14 +976,14 @@ typedef struct xtensa_args {\n    macro is used for continuing to walk back up the stack, so it must\n    return the stack pointer address.  Thus, there is some inconsistency\n    here in that __builtin_frame_address will return the frame pointer\n-   when count == 0 and the stack pointer when count > 0. */\n+   when count == 0 and the stack pointer when count > 0.  */\n \n #define DYNAMIC_CHAIN_ADDRESS(frame)\t\t\t\t\t\\\n   gen_rtx (PLUS, Pmode, frame,\t\t\t\t\t\t\\\n \t   gen_rtx_CONST_INT (VOIDmode, -3 * UNITS_PER_WORD))\n \n /* Define this if the return address of a particular stack frame is\n-   accessed from the frame pointer of the previous stack frame. */\n+   accessed from the frame pointer of the previous stack frame.  */\n #define RETURN_ADDR_IN_PREVIOUS_FRAME\n \n /* A C expression whose value is RTL representing the value of the\n@@ -998,7 +998,7 @@ typedef struct xtensa_args {\n    be either a suitable hard register or a pseudo register that has\n    been allocated such a hard register. The difference between an\n    index register and a base register is that the index register may\n-   be scaled. */\n+   be scaled.  */\n \n #define REGNO_OK_FOR_BASE_P(NUM) \\\n   (GP_REG_P (NUM) || GP_REG_P ((unsigned) reg_renumber[NUM]))\n@@ -1012,7 +1012,7 @@ typedef struct xtensa_args {\n    must be controlled by `REG_OK_STRICT'.  This usually requires two\n    variant definitions, of which `REG_OK_STRICT' controls the one\n    actually used. The difference between an index register and a base\n-   register is that the index register may be scaled. */\n+   register is that the index register may be scaled.  */\n \n #ifdef REG_OK_STRICT\n \n@@ -1091,7 +1091,7 @@ typedef struct xtensa_args {\n     || (GET_CODE (X) == CONST)))\n \n /* Nonzero if the constant value X is a legitimate general operand.\n-   It is given that X satisfies CONSTANT_P or is a CONST_DOUBLE. */\n+   It is given that X satisfies CONSTANT_P or is a CONST_DOUBLE.  */\n #define LEGITIMATE_CONSTANT_P(X) 1\n \n /* A C expression that is nonzero if X is a legitimate immediate\n@@ -1179,7 +1179,7 @@ typedef struct xtensa_args {\n #define SHIFT_COUNT_TRUNCATED 1\n \n /* Value is 1 if truncating an integer of INPREC bits to OUTPREC bits\n-   is done just by pretending it is already truncated. */\n+   is done just by pretending it is already truncated.  */\n #define TRULY_NOOP_TRUNCATION(OUTPREC, INPREC) 1\n \n /* Specify the machine mode that pointers have.\n@@ -1245,7 +1245,7 @@ typedef struct xtensa_args {\n /* Control the assembler format that we output.  */\n \n /* How to refer to registers in assembler output.\n-   This sequence is indexed by compiler's hard-register-number (see above). */\n+   This sequence is indexed by compiler's hard-register-number (see above).  */\n #define REGISTER_NAMES\t\t\t\t\t\t\t\\\n {\t\t\t\t\t\t\t\t\t\\\n   \"a0\",   \"sp\",   \"a2\",   \"a3\",   \"a4\",   \"a5\",   \"a6\",   \"a7\",\t\t\\\n@@ -1259,7 +1259,7 @@ typedef struct xtensa_args {\n /* If defined, a C initializer for an array of structures containing a\n    name and a register number.  This macro defines additional names\n    for hard registers, thus allowing the 'asm' option in declarations\n-   to refer to registers using alternate names. */\n+   to refer to registers using alternate names.  */\n #define ADDITIONAL_REGISTER_NAMES\t\t\t\t\t\\\n {\t\t\t\t\t\t\t\t\t\\\n   { \"a1\",\t 1 + GP_REG_FIRST }\t\t\t\t\t\\\n@@ -1302,7 +1302,7 @@ typedef struct xtensa_args {\n \t   LOCAL_LABEL_PREFIX, VALUE)\n \n /* This is how to output an element of a case-vector that is relative.\n-   This is used for pc-relative code. */\n+   This is used for pc-relative code.  */\n #define ASM_OUTPUT_ADDR_DIFF_ELT(STREAM, BODY, VALUE, REL)\t\t\\\n   do {\t\t\t\t\t\t\t\t\t\\\n     fprintf (STREAM, \"%s%sL%u-%sL%u\\n\",\tinteger_asm_op (4, TRUE),\t\\\n@@ -1332,7 +1332,7 @@ typedef struct xtensa_args {\n /* Define output to appear before the constant pool.  If the function\n    has been assigned to a specific ELF section, or if it goes into a\n    unique section, set the name of that section to be the literal\n-   prefix. */\n+   prefix.  */\n #define ASM_OUTPUT_POOL_PROLOGUE(FILE, FUNNAME, FUNDECL, SIZE)          \\\n   do {\t\t\t\t\t\t\t\t\t\\\n     tree fnsection;\t\t\t\t\t\t\t\\\n@@ -1367,7 +1367,7 @@ typedef struct xtensa_args {\n     goto JUMPTO;\t\t\t\t\t\t\t\\\n   } while (0)\n \n-/* How to start an assembler comment. */\n+/* How to start an assembler comment.  */\n #define ASM_COMMENT_START \"#\"\n \n /* Exception handling TODO!! */"}]}