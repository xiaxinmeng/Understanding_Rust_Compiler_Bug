{"sha": "15954beb2b32750807397741eda32d81fcb66121", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTU5NTRiZWIyYjMyNzUwODA3Mzk3NzQxZWRhMzJkODFmY2I2NjEyMQ==", "commit": {"author": {"name": "Hristian Kirtchev", "email": "kirtchev@adacore.com", "date": "2011-12-20T13:55:31Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-12-20T13:55:31Z"}, "message": "sem_ch4.adb (Operator_Check): Update the call to Is_Dimensioned_Type.\n\n2011-12-20  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* sem_ch4.adb (Operator_Check): Update the call to\n\tIs_Dimensioned_Type.\n\t* sem_dim.adb: Remove with and use clause for Namet.Sp. Reorganize\n\tall type declarations and datastructures involved. Propagate\n\tall changes involving data structures and types throughout\n\tthe pakage. Alphabetize all subprograms. Add ??? comments.\n\t(AD_Hash): Removed.\n\t(Analyze_Aspect_Dimension): Rewritten. This\n\troutine now does all its checks in one pass rather than\n\ttwo. Refactor code. The error message are now in a more GNAT-ish style.\n\t(Create_Rational_From_Expr): This is now a function.\n\t(Get_Dimensions): Removed.\n\t(Get_Dimensions_String_Id): Removed.\n\t(Dimensions_Of): New rouitne.\n\t(Exists): New routines.\n\t(Is_Invalid): New routine.\n\t(Permits_Dimensions): Removed.\n\t(Present): Removed.\n\t(Set_Symbol): New routine.\n\t(System_Of): New routine.\n\t* sem_dim.ads: Rewrite the top level description of the\n\tpackage. Alphabetize subprograms. Add various comments on\n\tsubprogram usage. Add ??? comments.\n\t(Is_Dimensioned_Type):\n\tRenamed to Has_Dimension_System.\n\t* sem_res.adb (Resolve_Op_Expon): Update the call to Is_Dimensioned_Type\n\nFrom-SVN: r182537", "tree": {"sha": "0d8ec627102afb8f521f3ec74acc1b8fcebe8f89", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0d8ec627102afb8f521f3ec74acc1b8fcebe8f89"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/15954beb2b32750807397741eda32d81fcb66121", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/15954beb2b32750807397741eda32d81fcb66121", "html_url": "https://github.com/Rust-GCC/gccrs/commit/15954beb2b32750807397741eda32d81fcb66121", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/15954beb2b32750807397741eda32d81fcb66121/comments", "author": {"login": "kirtchev-adacore", "id": 60669983, "node_id": "MDQ6VXNlcjYwNjY5OTgz", "avatar_url": "https://avatars.githubusercontent.com/u/60669983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kirtchev-adacore", "html_url": "https://github.com/kirtchev-adacore", "followers_url": "https://api.github.com/users/kirtchev-adacore/followers", "following_url": "https://api.github.com/users/kirtchev-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/kirtchev-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/kirtchev-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kirtchev-adacore/subscriptions", "organizations_url": "https://api.github.com/users/kirtchev-adacore/orgs", "repos_url": "https://api.github.com/users/kirtchev-adacore/repos", "events_url": "https://api.github.com/users/kirtchev-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/kirtchev-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "76d49f494a31b307249417d0f78ed93303bbd96c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/76d49f494a31b307249417d0f78ed93303bbd96c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/76d49f494a31b307249417d0f78ed93303bbd96c"}], "stats": {"total": 1867, "additions": 834, "deletions": 1033}, "files": [{"sha": "1728be4adfc3d6c1ee9da3434e3d9948a2fb5337", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15954beb2b32750807397741eda32d81fcb66121/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15954beb2b32750807397741eda32d81fcb66121/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=15954beb2b32750807397741eda32d81fcb66121", "patch": "@@ -1,3 +1,32 @@\n+2011-12-20  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* sem_ch4.adb (Operator_Check): Update the call to\n+\tIs_Dimensioned_Type.\n+\t* sem_dim.adb: Remove with and use clause for Namet.Sp. Reorganize\n+\tall type declarations and datastructures involved. Propagate\n+\tall changes involving data structures and types throughout\n+\tthe pakage. Alphabetize all subprograms. Add ??? comments.\n+\t(AD_Hash): Removed.\n+\t(Analyze_Aspect_Dimension): Rewritten. This\n+\troutine now does all its checks in one pass rather than\n+\ttwo. Refactor code. The error message are now in a more GNAT-ish style.\n+\t(Create_Rational_From_Expr): This is now a function.\n+\t(Get_Dimensions): Removed.\n+\t(Get_Dimensions_String_Id): Removed.\n+\t(Dimensions_Of): New rouitne.\n+\t(Exists): New routines.\n+\t(Is_Invalid): New routine.\n+\t(Permits_Dimensions): Removed.\n+\t(Present): Removed.\n+\t(Set_Symbol): New routine.\n+\t(System_Of): New routine.\n+\t* sem_dim.ads: Rewrite the top level description of the\n+\tpackage. Alphabetize subprograms. Add various comments on\n+\tsubprogram usage. Add ??? comments.\n+\t(Is_Dimensioned_Type):\n+\tRenamed to Has_Dimension_System.\n+\t* sem_res.adb (Resolve_Op_Expon): Update the call to Is_Dimensioned_Type\n+\n 2011-12-20  Ed Schonberg  <schonberg@adacore.com>\n \n \t* sem_ch13.adb (Check_Indexing_Functions): The return type of an"}, {"sha": "eb8d8e695c5cacf3cdf026dc8508f432625a8897", "filename": "gcc/ada/s-dimkio.ads", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15954beb2b32750807397741eda32d81fcb66121/gcc%2Fada%2Fs-dimkio.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15954beb2b32750807397741eda32d81fcb66121/gcc%2Fada%2Fs-dimkio.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-dimkio.ads?ref=15954beb2b32750807397741eda32d81fcb66121", "patch": "@@ -1,14 +1,14 @@\n ------------------------------------------------------------------------------\n --                                                                          --\n---                  GNAT RUN-TIME LIBRARY (GNARL) COMPONENTS                --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n --                                                                          --\n --                     S Y S T E M . D I M _ M K S _ I O                    --\n --                                                                          --\n --                                  S p e c                                 --\n --                                                                          --\n---          Copyright (C) 1992-2011, Free Software Foundation, Inc.         --\n+--            Copyright (C) 2011, Free Software Foundation, Inc.            --\n --                                                                          --\n--- GNARL is free software; you can  redistribute it  and/or modify it under --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n -- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n -- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n@@ -24,8 +24,8 @@\n -- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n -- <http://www.gnu.org/licenses/>.                                          --\n --                                                                          --\n--- GNARL was developed by the GNARL team at Florida State University.       --\n--- Extensive contributions were provided by Ada Core Technologies, Inc.     --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n --                                                                          --\n ------------------------------------------------------------------------------\n "}, {"sha": "88a29ddc352d1fddd753ae141fc2061a7c9700b9", "filename": "gcc/ada/s-dimmks.ads", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15954beb2b32750807397741eda32d81fcb66121/gcc%2Fada%2Fs-dimmks.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15954beb2b32750807397741eda32d81fcb66121/gcc%2Fada%2Fs-dimmks.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-dimmks.ads?ref=15954beb2b32750807397741eda32d81fcb66121", "patch": "@@ -1,14 +1,14 @@\n ------------------------------------------------------------------------------\n --                                                                          --\n---                  GNAT RUN-TIME LIBRARY (GNARL) COMPONENTS                --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n --                                                                          --\n --                        S Y S T E M . D I M _ M K S                       --\n --                                                                          --\n --                                  S p e c                                 --\n --                                                                          --\n---          Copyright (C) 1992-2011, Free Software Foundation, Inc.         --\n+--            Copyright (C) 2011, Free Software Foundation, Inc.            --\n --                                                                          --\n--- GNARL is free software; you can  redistribute it  and/or modify it under --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n -- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n -- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n@@ -24,14 +24,14 @@\n -- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n -- <http://www.gnu.org/licenses/>.                                          --\n --                                                                          --\n--- GNARL was developed by the GNARL team at Florida State University.       --\n--- Extensive contributions were provided by Ada Core Technologies, Inc.     --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n --                                                                          --\n ------------------------------------------------------------------------------\n \n---  This package defines the MKS dimension system which is the SI system of\n---  units.\n---  Some other prefixes of this sytem are defined in a child package (see\n+--  Defines the MKS dimension system which is the SI system of units\n+\n+--  Some other prefixes of this system are defined in a child package (see\n --  System.Dim_Mks.Other_Prefixes) in order to avoid too many constant\n --  declarations in this package.\n "}, {"sha": "57fa139e4d9692fab906fbc05e60647e00f08698", "filename": "gcc/ada/s-dmotpr.ads", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15954beb2b32750807397741eda32d81fcb66121/gcc%2Fada%2Fs-dmotpr.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15954beb2b32750807397741eda32d81fcb66121/gcc%2Fada%2Fs-dmotpr.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-dmotpr.ads?ref=15954beb2b32750807397741eda32d81fcb66121", "patch": "@@ -1,14 +1,14 @@\n ------------------------------------------------------------------------------\n --                                                                          --\n---                  GNAT RUN-TIME LIBRARY (GNARL) COMPONENTS                --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n --                                                                          --\n --         S Y S T E M . D I M _ M K S . O T H E R _ P R E F I X E S        --\n --                                                                          --\n --                                  S p e c                                 --\n --                                                                          --\n---          Copyright (C) 1992-2011, Free Software Foundation, Inc.         --\n+--            Copyright (C) 2011, Free Software Foundation, Inc.            --\n --                                                                          --\n--- GNARL is free software; you can  redistribute it  and/or modify it under --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n -- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n -- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n@@ -24,8 +24,8 @@\n -- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n -- <http://www.gnu.org/licenses/>.                                          --\n --                                                                          --\n--- GNARL was developed by the GNARL team at Florida State University.       --\n--- Extensive contributions were provided by Ada Core Technologies, Inc.     --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n --                                                                          --\n ------------------------------------------------------------------------------\n "}, {"sha": "99f29668cd68100afbf8ff89e920fc5ac7ef6d71", "filename": "gcc/ada/sem_ch4.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15954beb2b32750807397741eda32d81fcb66121/gcc%2Fada%2Fsem_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15954beb2b32750807397741eda32d81fcb66121/gcc%2Fada%2Fsem_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch4.adb?ref=15954beb2b32750807397741eda32d81fcb66121", "patch": "@@ -6042,7 +6042,7 @@ package body Sem_Ch4 is\n               and then Base_Type (Etype (R)) /= Universal_Integer\n             then\n                if Ada_Version >= Ada_2012\n-                 and then Is_Dimensioned_Type (Etype (L))\n+                 and then Has_Dimension_System (Etype (L))\n                then\n                   Error_Msg_NE\n                     (\"exponent for dimensioned type must be a rational\" &"}, {"sha": "341ceda29c1c06d308b51534675df90a1928da42", "filename": "gcc/ada/sem_dim.adb", "status": "modified", "additions": 731, "deletions": 964, "changes": 1695, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15954beb2b32750807397741eda32d81fcb66121/gcc%2Fada%2Fsem_dim.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15954beb2b32750807397741eda32d81fcb66121/gcc%2Fada%2Fsem_dim.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_dim.adb?ref=15954beb2b32750807397741eda32d81fcb66121", "patch": "@@ -29,7 +29,6 @@ with Einfo;    use Einfo;\n with Errout;   use Errout;\n with Lib;      use Lib;\n with Namet;    use Namet;\n-with Namet.Sp; use Namet.Sp;\n with Nlists;   use Nlists;\n with Nmake;    use Nmake;\n with Opt;      use Opt;\n@@ -51,61 +50,9 @@ with GNAT.HTable;\n \n package body Sem_Dim is\n \n-   Max_Dimensions : constant Int := 7;\n-   --  Maximum number of dimensions in a dimension system\n-\n-   subtype Dim_Id is Pos range 1 .. Max_Dimensions;\n-   --  Dim_Id values are used to identify dimensions in a dimension system\n-   --  Note that the highest value of Dim_Id is Max_Dimensions\n-\n-   --  Record type for dimension system\n-\n-   --  A dimension system is defined by the number and the names of its\n-   --  dimensions and its base type.\n-\n-   subtype N_Of_Dimensions is Int range 0 .. Max_Dimensions;\n-\n-   No_Dimensions : constant N_Of_Dimensions := N_Of_Dimensions'First;\n-\n-   type Name_Array is array (Dim_Id) of Name_Id;\n-\n-   No_Names : constant Name_Array := (others => No_Name);\n-\n-   --  The symbols are used for IO purposes\n-\n-   type Symbol_Array is array (Dim_Id) of String_Id;\n-\n-   No_Symbols : constant Symbol_Array := (others => No_String);\n-\n-   type Dimension_System is record\n-      Base_Type : Node_Id;\n-      Names     : Name_Array;\n-      N_Of_Dims : N_Of_Dimensions;\n-      Symbols   : Symbol_Array;\n-   end record;\n-\n-   No_Dimension_System : constant Dimension_System :=\n-                           (Empty, No_Names, No_Dimensions, No_Symbols);\n-\n-   --  Dim_Sys_Id values are used to identify dimension system in the Table\n-   --  Note that the special value No_Dim_Sys has no corresponding component in\n-   --  the Table since it represents no dimension system.\n-\n-   subtype Dim_Sys_Id is Nat;\n-\n-   No_Dim_Sys : constant Dim_Sys_Id := Dim_Sys_Id'First;\n-\n-   --  The following table records every dimension system\n-\n-   package Dim_Systems is new Table.Table (\n-     Table_Component_Type => Dimension_System,\n-     Table_Index_Type     => Dim_Sys_Id,\n-     Table_Low_Bound      => 1,\n-     Table_Initial        => 5,\n-     Table_Increment      => 5,\n-     Table_Name           => \"Dim_Systems\");\n-\n-   --  Rational (definitions & operations)\n+   -------------------------\n+   -- Rational arithmetic --\n+   -------------------------\n \n    type Whole is new Int;\n    subtype Positive_Whole is Whole range 1 .. Whole'Last;\n@@ -115,7 +62,7 @@ package body Sem_Dim is\n       Denominator : Positive_Whole;\n    end record;\n \n-   Zero_Rational : constant Rational := (0, 1);\n+   Zero : constant Rational := (0, 1);\n \n    --  Rational constructors\n \n@@ -138,222 +85,152 @@ package body Sem_Dim is\n \n    function \"*\" (Left : Rational; Right : Whole) return Rational;\n \n-   ---------\n-   -- GCD --\n-   ---------\n-\n-   function GCD (Left, Right : Whole) return Int is\n-      L : Whole;\n-      R : Whole;\n-\n-   begin\n-      L := Left;\n-      R := Right;\n-      while R /= 0 loop\n-         L := L mod R;\n-\n-         if L = 0 then\n-            return Int (R);\n-         end if;\n-\n-         R := R mod L;\n-      end loop;\n-\n-      return Int (L);\n-   end GCD;\n-\n-   ------------\n-   -- Reduce --\n-   ------------\n-\n-   function Reduce (X : Rational) return Rational is\n-   begin\n-      if X.Numerator = 0 then\n-         return Zero_Rational;\n-      end if;\n-\n-      declare\n-         G : constant Int := GCD (X.Numerator, X.Denominator);\n-\n-      begin\n-         return Rational'(Numerator   => Whole (Int (X.Numerator) / G),\n-                          Denominator => Whole (Int (X.Denominator) / G));\n-      end;\n-   end Reduce;\n-\n-   ---------\n-   -- \"+\" --\n-   ---------\n-\n-   function \"+\" (Right : Whole) return Rational is\n-   begin\n-      return (Right, 1);\n-   end \"+\";\n-\n-   function \"+\" (Left, Right : Rational) return Rational is\n-      R : constant Rational :=\n-            Rational'(Numerator   => Left.Numerator * Right.Denominator +\n-                                       Left.Denominator * Right.Numerator,\n-                      Denominator => Left.Denominator * Right.Denominator);\n-   begin\n-      return Reduce (R);\n-   end \"+\";\n-\n-   ---------\n-   -- \"-\" --\n-   ---------\n-\n-   function \"-\" (Right : Rational) return Rational is\n-   begin\n-      return Rational'(Numerator   => -Right.Numerator,\n-                       Denominator => Right.Denominator);\n-   end \"-\";\n-\n-   function \"-\" (Left, Right : Rational) return Rational is\n-      R : constant Rational :=\n-            Rational'(Numerator   => Left.Numerator * Right.Denominator -\n-                                       Left.Denominator * Right.Numerator,\n-                      Denominator => Left.Denominator * Right.Denominator);\n-\n-   begin\n-      return Reduce (R);\n-   end \"-\";\n-\n-   ---------\n-   -- \"*\" --\n-   ---------\n-\n-   function \"*\" (Left, Right : Rational) return Rational is\n-      R : constant Rational :=\n-            Rational'(Numerator   => Left.Numerator * Right.Numerator,\n-                      Denominator => Left.Denominator * Right.Denominator);\n-\n-   begin\n-      return Reduce (R);\n-   end \"*\";\n-\n-   function \"*\" (Left : Rational; Right : Whole) return Rational is\n-      R : constant Rational :=\n-            Rational'(Numerator   => Left.Numerator * Right,\n-                      Denominator => Left.Denominator);\n+   ------------------\n+   -- System types --\n+   ------------------\n \n-   begin\n-      return Reduce (R);\n-   end \"*\";\n+   Max_Number_Of_Dimensions : constant := 7;\n+   --  Maximum number of dimensions in a dimension system\n \n-   ---------\n-   -- \"/\" --\n-   ---------\n+   High_Position_Bound : constant := Max_Number_Of_Dimensions;\n+   Invalid_Position    : constant := 0;\n+   Low_Position_Bound  : constant := 1;\n \n-   function \"/\" (Left, Right : Whole) return  Rational is\n-      R : constant Int := abs Int (Right);\n-      L : Int          := Int (Left);\n+   subtype Dimension_Position is\n+     Nat range Invalid_Position .. High_Position_Bound;\n \n-   begin\n-      if Right < 0 then\n-         L := -L;\n-      end if;\n+   type Name_Array is\n+     array (Dimension_Position range\n+              Low_Position_Bound .. High_Position_Bound) of Name_Id;\n+   --  A data structure used to store the names of all units within a system\n \n-      return Reduce (Rational'(Numerator   => Whole (L),\n-                               Denominator => Whole (R)));\n-   end \"/\";\n+   No_Names : constant Name_Array := (others => No_Name);\n \n-   --  Hash Table for aspect dimension.\n+   type Symbol_Array is\n+     array (Dimension_Position range\n+              Low_Position_Bound ..  High_Position_Bound) of String_Id;\n+   --  A data structure used to store the symbols of all units within a system\n \n-   --  The following table provides a relation between nodes and its dimension\n-   --  (if not dimensionless). If a node is not stored in the Hash Table, the\n-   --  node is considered to be dimensionless.\n+   No_Symbols : constant Symbol_Array := (others => No_String);\n \n-   --  A dimension is represented by an array of Max_Dimensions Rationals.\n-   --  If the corresponding dimension system has less than Max_Dimensions\n-   --  dimensions, the array is filled by as many as Zero_Rationals needed to\n-   --  complete the array.\n+   type System_Type is record\n+      Type_Decl : Node_Id;\n+      Names     : Name_Array;\n+      Symbols   : Symbol_Array;\n+      Count     : Dimension_Position;\n+   end record;\n \n-   --  Here is a list of nodes that can have entries in this Htable:\n+   Null_System : constant System_Type :=\n+                   (Empty, No_Names, No_Symbols, Invalid_Position);\n \n-   --  N_Attribute_Reference\n-   --  N_Defining_Identifier\n-   --  N_Function_Call\n-   --  N_Identifier\n-   --  N_Indexed_Component\n-   --  N_Integer_Literal\n-   --  N_Op_Abs\n-   --  N_Op_Add\n-   --  N_Op_Divide\n-   --  N_Op_Expon\n-   --  N_Op_Minus\n-   --  N_Op_Mod\n-   --  N_Op_Multiply\n-   --  N_Op_Plus\n-   --  N_Op_Rem\n-   --  N_Op_Subtract\n-   --  N_Qualified_Expression\n-   --  N_Real_Literal\n-   --  N_Selected_Component\n-   --  N_Slice\n-   --  N_Type_Conversion\n-   --  N_Unchecked_Type_Conversion\n+   subtype System_Id is Nat;\n \n-   type Dimensions is array (Dim_Id) of Rational;\n+   --  The following table maps types to systems\n \n-   Zero_Dimensions : constant Dimensions := (others => Zero_Rational);\n+   package System_Table is new Table.Table (\n+     Table_Component_Type => System_Type,\n+     Table_Index_Type     => System_Id,\n+     Table_Low_Bound      => 1,\n+     Table_Initial        => 5,\n+     Table_Increment      => 5,\n+     Table_Name           => \"System_Table\");\n \n-   type AD_Hash_Range is range 0 .. 511;\n+   --------------------\n+   -- Dimension type --\n+   --------------------\n \n-   function AD_Hash (F : Node_Id) return AD_Hash_Range;\n+   type Dimension_Type is\n+     array (Dimension_Position range\n+              Low_Position_Bound ..  High_Position_Bound) of Rational;\n \n-   -------------\n-   -- AD_Hash --\n-   -------------\n+   Null_Dimension : constant Dimension_Type := (others => Zero);\n \n-   function AD_Hash (F : Node_Id) return AD_Hash_Range is\n-   begin\n-      return AD_Hash_Range (F mod 512);\n-   end AD_Hash;\n+   type Dimension_Table_Range is range 0 .. 510;\n+   function Dimension_Table_Hash (Key : Node_Id) return Dimension_Table_Range;\n \n-   --  Node_Id --> Dimensions\n+   --  The following table associates nodes with dimensions\n \n-   package Aspect_Dimension_Hash_Table is new\n+   package Dimension_Table is new\n      GNAT.HTable.Simple_HTable\n-       (Header_Num => AD_Hash_Range,\n-        Element    => Dimensions,\n-        No_Element => Zero_Dimensions,\n+       (Header_Num => Dimension_Table_Range,\n+        Element    => Dimension_Type,\n+        No_Element => Null_Dimension,\n         Key        => Node_Id,\n-        Hash       => AD_Hash,\n+        Hash       => Dimension_Table_Hash,\n         Equal      => \"=\");\n \n-   --  Table to record the string of each subtype declaration\n-   --  Note that this table is only used for IO purposes\n+   ------------------\n+   -- Symbol types --\n+   ------------------\n \n-   --  Entity_Id --> String_Id\n+   type Symbol_Table_Range is range 0 .. 510;\n+   function Symbol_Table_Hash (Key : Entity_Id) return Symbol_Table_Range;\n \n-   package Aspect_Dimension_String_Id_Hash_Table is new\n+   --  Each subtype with a dimension has a symbolic representation of the\n+   --  related unit. This table establishes a relation between the subtype\n+   --  and the symbol.\n+\n+   package Symbol_Table is new\n      GNAT.HTable.Simple_HTable\n-       (Header_Num => AD_Hash_Range,\n+       (Header_Num => Symbol_Table_Range,\n         Element    => String_Id,\n         No_Element => No_String,\n         Key        => Entity_Id,\n-        Hash       => AD_Hash,\n+        Hash       => Symbol_Table_Hash,\n         Equal      => \"=\");\n \n+   --  The following array enumerates all contexts which may contain or\n+   --  produce a dimension.\n+\n+   OK_For_Dimension : constant array (Node_Kind) of Boolean :=\n+     (N_Attribute_Reference       => True,\n+      N_Defining_Identifier       => True,\n+      N_Function_Call             => True,\n+      N_Identifier                => True,\n+      N_Indexed_Component         => True,\n+      N_Integer_Literal           => True,\n+      N_Op_Abs                    => True,\n+      N_Op_Add                    => True,\n+      N_Op_Divide                 => True,\n+      N_Op_Expon                  => True,\n+      N_Op_Minus                  => True,\n+      N_Op_Mod                    => True,\n+      N_Op_Multiply               => True,\n+      N_Op_Plus                   => True,\n+      N_Op_Rem                    => True,\n+      N_Op_Subtract               => True,\n+      N_Qualified_Expression      => True,\n+      N_Real_Literal              => True,\n+      N_Selected_Component        => True,\n+      N_Slice                     => True,\n+      N_Type_Conversion           => True,\n+      N_Unchecked_Type_Conversion => True,\n+\n+      others                      => False);\n+\n    -----------------------\n    -- Local Subprograms --\n    -----------------------\n \n    procedure Analyze_Dimension_Assignment_Statement (N : Node_Id);\n    --  Subroutine of Analyze_Dimension for assignment statement\n+   --  ??? what does this routine do?\n \n    procedure Analyze_Dimension_Binary_Op (N : Node_Id);\n    --  Subroutine of Analyze_Dimension for binary operators\n+   --  ??? same here\n \n    procedure Analyze_Dimension_Component_Declaration (N : Node_Id);\n    --  Subroutine of Analyze_Dimension for component declaration\n+   --  ??? same here\n \n    procedure Analyze_Dimension_Extended_Return_Statement (N : Node_Id);\n    --  Subroutine of Analyze_Dimension for extended return statement\n+   --  ??? same here\n \n    procedure Analyze_Dimension_Function_Call (N : Node_Id);\n    --  Subroutine of Analyze_Dimension for function call\n+   --  ??? same here\n \n    procedure Analyze_Dimension_Has_Etype (N : Node_Id);\n    --  Subroutine of Analyze_Dimension for N_Has_Etype nodes:\n@@ -364,647 +241,511 @@ package body Sem_Dim is\n    --  N_Slice\n    --  N_Type_Conversion\n    --  N_Unchecked_Type_Conversion\n+   --  ??? poor comment, N_Has_Etype contains Node_Ids not listed above, what\n+   --  about those?\n \n    procedure Analyze_Dimension_Identifier (N : Node_Id);\n    --  Subroutine of Analyze_Dimension for identifier\n+   --  ??? what does this routine do?\n \n    procedure Analyze_Dimension_Object_Declaration (N : Node_Id);\n    --  Subroutine of Analyze_Dimension for object declaration\n+   --  ??? same here\n \n    procedure Analyze_Dimension_Object_Renaming_Declaration (N : Node_Id);\n    --  Subroutine of Analyze_Dimension for object renaming declaration\n+   --  ??? same here\n \n    procedure Analyze_Dimension_Simple_Return_Statement (N : Node_Id);\n    --  Subroutine of Analyze_Dimension for simple return statement\n+   --  ??? same here\n \n    procedure Analyze_Dimension_Subtype_Declaration (N : Node_Id);\n    --  Subroutine of Analyze_Dimension for subtype declaration\n+   --  ??? same here\n \n    procedure Analyze_Dimension_Unary_Op (N : Node_Id);\n    --  Subroutine of Analyze_Dimension for unary operators\n+   --  ??? same here\n \n-   procedure Copy_Dimensions (From, To : Node_Id);\n-   --  Propagate dimensions between two nodes\n+   procedure Copy_Dimensions (From : Node_Id; To : Node_Id);\n+   --  Copy the dimension vector from one node to another\n \n-   procedure Create_Rational_From_Expr (Expr : Node_Id; R : in out Rational);\n+   function Create_Rational_From_Expr (Expr : Node_Id) return Rational;\n    --  Given an expression, creates a rational number\n+   --  ??? what does this expression represent?\n+\n+   function Dimensions_Of (N : Node_Id) return Dimension_Type;\n+   --  Return the dimension vector of node N\n \n    procedure Eval_Op_Expon_With_Rational_Exponent\n      (N   : Node_Id;\n       Rat : Rational);\n    --  Evaluate the Expon if the exponent is a rational and the operand has a\n    --  dimension.\n \n+   function Exists (Dim : Dimension_Type) return Boolean;\n+   --  Determine whether Dim does not denote the null dimension\n+\n+   function Exists (Sys : System_Type) return Boolean;\n+   --  Determine whether Sys does not denote the null system\n+\n    function From_Dimension_To_String_Id\n-     (Dims : Dimensions;\n-      Sys  : Dim_Sys_Id) return String_Id;\n+     (Dims   : Dimension_Type;\n+      System : System_Type) return String_Id;\n    --  Given a dimension vector and a dimension system, return the proper\n    --  string of symbols.\n \n-   function Get_Dimensions (N : Node_Id) return Dimensions;\n-   --  Return the dimensions for the corresponding node\n-\n-   function Get_Dimensions_String_Id (E : Entity_Id) return String_Id;\n-   --  Return the String_Id of dimensions for the corresponding entity\n+   function Is_Invalid (Position : Dimension_Position) return Boolean;\n+   --  Determine whether Pos denotes the invalid position\n \n-   function Get_Dimension_System_Id (E : Entity_Id) return Dim_Sys_Id;\n-   --  Return the Dim_Id of the corresponding dimension system\n-\n-   procedure Move_Dimensions (From, To : Node_Id);\n-   --  Move Dimensions from 'From' to 'To'. Only called when 'From' has a\n-   --  dimension.\n-\n-   function Permits_Dimensions (N : Node_Id) return Boolean;\n-   --  Return True if a node can have a dimension\n-\n-   function Present (Dim : Dimensions) return Boolean;\n-   --  Return True if Dim is not equal to Zero_Dimensions.\n+   procedure Move_Dimensions (From : Node_Id; To : Node_Id);\n+   --  Copy dimension vector of From to To, delete dimension vector of From\n \n    procedure Remove_Dimensions (N : Node_Id);\n-   --  Remove the node from the HTable\n-\n-   procedure Set_Dimensions (N : Node_Id; Dims : Dimensions);\n-   --  Store the dimensions of N in the Hash_Table for Dimensions\n-\n-   procedure Set_Dimensions_String_Id (E : Entity_Id; Str : String_Id);\n-   --  Store the string of dimensions of E in the Hash_Table for String_Id\n-\n-   ------------------------------\n-   -- Analyze_Aspect_Dimension --\n-   ------------------------------\n-\n-   --  with Dimension => DIMENSION_FOR_SUBTYPE\n-   --  DIMENSION_FOR_SUBTYPE ::= (DIMENSION_STRING, DIMENSION_RATIONALS)\n-   --  DIMENSION_RATIONALS ::=\n-   --    RATIONAL,  {, RATIONAL}\n-   --  | RATIONAL {, RATIONAL}, others => RATIONAL\n-   --  | DISCRETE_CHOICE_LIST => RATIONAL\n+   --  Remove the dimension vector of node N\n \n-   --  (see Analyze_Aspect_Dimension_System for DIMENSION_STRING grammar)\n+   procedure Set_Dimensions (N : Node_Id; Val : Dimension_Type);\n+   --  Associate a dimension vector with a node\n \n-   procedure Analyze_Aspect_Dimension\n-     (N    : Node_Id;\n-      Id   : Node_Id;\n-      Expr : Node_Id)\n-   is\n-      Def_Id : constant Entity_Id := Defining_Identifier (N);\n-      N_Kind : constant Node_Kind := Nkind (N);\n+   procedure Set_Symbol (E : Entity_Id; Val : String_Id);\n+   --  Associate a symbol representation of a dimension vector with a subtype\n \n-      Analyzed : array (Dimensions'Range) of Boolean := (others => False);\n-      --  This array has been defined in order to deals with Others_Choice\n-      --  It is a reminder of the dimensions in the aggregate that have already\n-      --  been analyzed.\n-\n-      Choice      : Node_Id;\n-      Comp_Expr   : Node_Id;\n-      Comp_Assn   : Node_Id;\n-      Dim         : Dim_Id;\n-      Dims        : Dimensions := Zero_Dimensions;\n-      Dim_Str_Lit : Node_Id;\n-      D_Sys       : Dim_Sys_Id := No_Dim_Sys;\n-      N_Of_Dims   : N_Of_Dimensions;\n-      Str         : String_Id := No_String;\n-\n-      function Check_Identifier_Is_Dimension\n-        (Id    : Node_Id;\n-         D_Sys : Dim_Sys_Id) return Boolean;\n-      --  Return True if the identifier name is the name of a dimension in the\n-      --  dimension system D_Sys.\n-\n-      function Check_Compile_Time_Known_Expressions_In_Aggregate\n-        (Expr : Node_Id) return Boolean;\n-      --  Check that each expression in the aggregate is known at compile time\n-\n-      function Check_Number_Dimensions_Aggregate\n-        (Expr      : Node_Id;\n-         D_Sys     : Dim_Sys_Id;\n-         N_Of_Dims : N_Of_Dimensions) return Boolean;\n-      --  This routine checks the number of dimensions in the aggregate.\n-\n-      function Corresponding_Dimension_System (N : Node_Id) return Dim_Sys_Id;\n-      --  Return the Dim_Sys_Id of the corresponding dimension system\n-\n-      function Corresponding_Etype_Has_Dimensions (N : Node_Id) return Boolean;\n-      --  Return True if the Etype of N has a dimension\n-\n-      function Get_Dimension_Id\n-        (Id    : Node_Id;\n-         D_Sys : Dim_Sys_Id) return Dim_Id;\n-      --  Given an identifier and the Dim_Sys_Id of the dimension system in the\n-      --  Table, returns the Dim_Id that has the same name as the identifier.\n-\n-      ------------------------------------\n-      -- Corresponding_Dimension_System --\n-      ------------------------------------\n-\n-      function Corresponding_Dimension_System\n-        (N : Node_Id) return Dim_Sys_Id\n-      is\n-         B_Typ   : Node_Id;\n-         Sub_Ind : Node_Id;\n+   function Symbol_Of (E : Entity_Id) return String_Id;\n+   --  E denotes a subtype with a dimension. Return the symbol representation\n+   --  of the dimension vector.\n \n-      begin\n-         --  Aspect_Dimension can only apply for subtypes\n+   function System_Of (E : Entity_Id) return System_Type;\n+   --  E denotes a type, return associated system of the type if it has one\n \n-         --  Look for the dimension system corresponding to this\n-         --  Aspect_Dimension.\n-\n-         if Nkind (N) = N_Subtype_Declaration then\n-            Sub_Ind := Subtype_Indication (N);\n-\n-            if Nkind (Sub_Ind) /= N_Subtype_Indication then\n-               B_Typ := Etype (Sub_Ind);\n-               return Get_Dimension_System_Id (B_Typ);\n-            else\n-               return No_Dim_Sys;\n-            end if;\n-\n-         else\n-            return No_Dim_Sys;\n-         end if;\n-      end Corresponding_Dimension_System;\n-\n-      ----------------------------------------\n-      -- Corresponding_Etype_Has_Dimensions --\n-      ----------------------------------------\n-\n-      function Corresponding_Etype_Has_Dimensions\n-        (N : Node_Id) return Boolean\n-      is\n-         Dims_Typ : Dimensions;\n-         Typ      : Entity_Id;\n-\n-      begin\n-         --  Check the type is dimensionless before assigning a dimension\n-\n-         if Nkind (N) = N_Subtype_Declaration then\n-            declare\n-               Sub : constant Node_Id := Subtype_Indication (N);\n-\n-            begin\n-               if Nkind (Sub) /= N_Subtype_Indication then\n-                  Typ := Etype (Sub);\n-               else\n-                  Typ := Etype (Subtype_Mark (Sub));\n-               end if;\n-\n-               Dims_Typ := Get_Dimensions (Typ);\n-               return Present (Dims_Typ);\n-            end;\n-\n-         else\n-            return False;\n-         end if;\n-      end Corresponding_Etype_Has_Dimensions;\n+   ---------\n+   -- \"+\" --\n+   ---------\n \n-      ---------------------------------------\n-      -- Check_Number_Dimensions_Aggregate --\n-      ---------------------------------------\n+   function \"+\" (Right : Whole) return Rational is\n+   begin\n+      return (Right, 1);\n+   end \"+\";\n \n-      function Check_Number_Dimensions_Aggregate\n-        (Expr      : Node_Id;\n-         D_Sys     : Dim_Sys_Id;\n-         N_Of_Dims : N_Of_Dimensions) return Boolean\n-      is\n-         Assoc       : Node_Id;\n-         Choice      : Node_Id;\n-         Comp_Expr   : Node_Id;\n-         N_Dims_Aggr : Int := No_Dimensions;\n-         --  The number of dimensions in this aggregate\n+   function \"+\" (Left, Right : Rational) return Rational is\n+      R : constant Rational :=\n+            Rational'(Numerator   => Left.Numerator * Right.Denominator +\n+                                       Left.Denominator * Right.Numerator,\n+                      Denominator => Left.Denominator * Right.Denominator);\n+   begin\n+      return Reduce (R);\n+   end \"+\";\n \n-      begin\n-         --  Check the size of the aggregate match with the size of the\n-         --  corresponding dimension system.\n+   ---------\n+   -- \"-\" --\n+   ---------\n \n-         Comp_Expr := First (Expressions (Expr));\n+   function \"-\" (Right : Rational) return Rational is\n+   begin\n+      return Rational'(Numerator   => -Right.Numerator,\n+                       Denominator => Right.Denominator);\n+   end \"-\";\n \n-         --  Skip the first argument in the aggregate since it's a character or\n-         --  a string and not a dimension value.\n+   function \"-\" (Left, Right : Rational) return Rational is\n+      R : constant Rational :=\n+            Rational'(Numerator   => Left.Numerator * Right.Denominator -\n+                                       Left.Denominator * Right.Numerator,\n+                      Denominator => Left.Denominator * Right.Denominator);\n \n-         Next (Comp_Expr);\n+   begin\n+      return Reduce (R);\n+   end \"-\";\n \n-         if Present (Component_Associations (Expr)) then\n+   ---------\n+   -- \"*\" --\n+   ---------\n \n-            --  For a positional aggregate with an Others_Choice, the number\n-            --  of expressions must be less than or equal to N_Of_Dims - 1.\n+   function \"*\" (Left, Right : Rational) return Rational is\n+      R : constant Rational :=\n+            Rational'(Numerator   => Left.Numerator * Right.Numerator,\n+                      Denominator => Left.Denominator * Right.Denominator);\n \n-            if Present (Comp_Expr) then\n-               N_Dims_Aggr := List_Length (Expressions (Expr)) - 1;\n-               return N_Dims_Aggr <= N_Of_Dims - 1;\n+   begin\n+      return Reduce (R);\n+   end \"*\";\n \n-            --  If the aggregate is a named aggregate, N_Dims_Aggr is used to\n-            --  count all the dimensions referenced by the aggregate.\n+   function \"*\" (Left : Rational; Right : Whole) return Rational is\n+      R : constant Rational :=\n+            Rational'(Numerator   => Left.Numerator * Right,\n+                      Denominator => Left.Denominator);\n \n-            else\n-               Assoc := First (Component_Associations (Expr));\n-\n-               while Present (Assoc) loop\n-                  if Nkind (Assoc) = N_Range then\n-                     Choice := First (Choices (Assoc));\n-\n-                     declare\n-                        HB     : constant Node_Id := High_Bound (Choice);\n-                        LB     : constant Node_Id := Low_Bound (Choice);\n-                        LB_Dim : Dim_Id;\n-                        HB_Dim : Dim_Id;\n-\n-                     begin\n-                        if not Check_Identifier_Is_Dimension (HB, D_Sys)\n-                          or else not Check_Identifier_Is_Dimension (LB, D_Sys)\n-                        then\n-                           return False;\n-                        end if;\n+   begin\n+      return Reduce (R);\n+   end \"*\";\n \n-                        HB_Dim := Get_Dimension_Id (HB, D_Sys);\n-                        LB_Dim := Get_Dimension_Id (LB, D_Sys);\n+   ---------\n+   -- \"/\" --\n+   ---------\n \n-                        N_Dims_Aggr := N_Dims_Aggr + HB_Dim - LB_Dim +  1;\n-                     end;\n+   function \"/\" (Left, Right : Whole) return  Rational is\n+      R : constant Int := abs Int (Right);\n+      L : Int          := Int (Left);\n \n-                  else\n-                     N_Dims_Aggr :=\n-                       N_Dims_Aggr + List_Length (Choices (Assoc));\n-                  end if;\n+   begin\n+      if Right < 0 then\n+         L := -L;\n+      end if;\n \n-                  Next (Assoc);\n-               end loop;\n+      return Reduce (Rational'(Numerator   => Whole (L),\n+                               Denominator => Whole (R)));\n+   end \"/\";\n \n-               --  Check whether an Others_Choice is present or not\n+   ------------------------------\n+   -- Analyze_Aspect_Dimension --\n+   ------------------------------\n \n-               if Nkind\n-                    (First (Choices (Last (Component_Associations (Expr))))) =\n-                     N_Others_Choice\n-               then\n-                  return N_Dims_Aggr <= N_Of_Dims;\n-               else\n-                  return N_Dims_Aggr = N_Of_Dims;\n-               end if;\n-            end if;\n+   --  with Dimension => DIMENSION_FOR_SUBTYPE\n+   --  DIMENSION_FOR_SUBTYPE ::= (DIMENSION_STRING, DIMENSION_RATIONALS)\n+   --  DIMENSION_RATIONALS ::=\n+   --    RATIONAL,  {, RATIONAL}\n+   --  | RATIONAL {, RATIONAL}, others => RATIONAL\n+   --  | DISCRETE_CHOICE_LIST => RATIONAL\n \n-         --  If the aggregate is a positional aggregate without Others_Choice,\n-         --  the number of expressions must match the number of dimensions in\n-         --  the dimension system.\n+   --  (see Analyze_Aspect_Dimension_System for DIMENSION_STRING grammar)\n \n+   procedure Analyze_Aspect_Dimension\n+     (N    : Node_Id;\n+      Id   : Node_Id;\n+      Aggr : Node_Id)\n+   is\n+      Def_Id   : constant Entity_Id   := Defining_Identifier (N);\n+      Typ      : constant Entity_Id   := Etype (Def_Id);\n+      Base_Typ : constant Entity_Id   := Base_Type (Typ);\n+      System   : constant System_Type := System_Of (Base_Typ);\n+\n+      Processed : array (Dimension_Type'Range) of Boolean := (others => False);\n+      --  This array is used when processing ranges or Others_Choice as part of\n+      --  the dimension aggregate.\n+\n+      Dimensions : Dimension_Type := Null_Dimension;\n+\n+      procedure Extract_Power\n+        (Expr     : Node_Id;\n+         Position : Dimension_Position);\n+      --  Given an expression with denotes a rational number, read the number\n+      --  and associate it with Position in Dimensions.\n+\n+      function Has_Compile_Time_Known_Expressions\n+        (Aggr : Node_Id) return Boolean;\n+      --  Determine whether aggregate Aggr contains only expressions that are\n+      --  known at compile time.\n+\n+      function Position_In_System\n+        (Id     : Node_Id;\n+         System : System_Type) return Dimension_Position;\n+      --  Given an identifier which denotes a dimension, return the position of\n+      --  that dimension within System.\n+\n+      -------------------\n+      -- Extract_Power --\n+      -------------------\n+\n+      procedure Extract_Power\n+        (Expr     : Node_Id;\n+         Position : Dimension_Position)\n+      is\n+      begin\n+         if Is_Integer_Type (Def_Id) then\n+            Dimensions (Position) := +Whole (UI_To_Int (Expr_Value (Expr)));\n          else\n-            N_Dims_Aggr := List_Length (Expressions (Expr)) - 1;\n-            return N_Dims_Aggr = N_Of_Dims;\n+            Dimensions (Position) := Create_Rational_From_Expr (Expr);\n          end if;\n-      end Check_Number_Dimensions_Aggregate;\n \n-      -----------------------------------\n-      -- Check_Identifier_Is_Dimension --\n-      -----------------------------------\n+         Processed (Position) := True;\n+      end Extract_Power;\n+\n+      ----------------------------------------\n+      -- Has_Compile_Time_Known_Expressions --\n+      ----------------------------------------\n \n-      function Check_Identifier_Is_Dimension\n-        (Id    : Node_Id;\n-         D_Sys : Dim_Sys_Id) return Boolean\n+      function Has_Compile_Time_Known_Expressions\n+        (Aggr : Node_Id) return Boolean\n       is\n-         Na_Id     : constant Name_Id := Chars (Id);\n-         Dim_Name1 : Name_Id;\n-         Dim_Name2 : Name_Id;\n+         Comp : Node_Id;\n+         Expr : Node_Id;\n \n       begin\n+         Expr := First (Expressions (Aggr));\n+         if Present (Expr) then\n \n-         for Dim1 in Dim_Id'Range loop\n-            Dim_Name1 := Dim_Systems.Table (D_Sys).Names (Dim1);\n+            --  The first expression within the aggregate describes the\n+            --  symbolic name of a dimension, skip it.\n \n-            if Dim_Name1 = Na_Id then\n-               return True;\n-            end if;\n+            Next (Expr);\n+            while Present (Expr) loop\n+               Analyze_And_Resolve (Expr);\n \n-            if Dim1 = Max_Dimensions then\n+               if not Compile_Time_Known_Value (Expr) then\n+                  return False;\n+               end if;\n \n-               --  Check for possible misspelling\n+               Next (Expr);\n+            end loop;\n+         end if;\n \n-               Error_Msg_N (\"& is not a dimension argument for aspect%\", Id);\n+         Comp := First (Component_Associations (Aggr));\n+         while Present (Comp) loop\n+            Expr := Expression (Comp);\n \n-               for Dim2 in Dim_Id'Range loop\n-                  Dim_Name2 := Dim_Systems.Table (D_Sys).Names (Dim2);\n+            Analyze_And_Resolve (Expr);\n \n-                  if Is_Bad_Spelling_Of (Na_Id, Dim_Name2) then\n-                     Error_Msg_Name_1 := Dim_Name2;\n-                     Error_Msg_N (\"\\possible misspelling of%\", Id);\n-                     exit;\n-                  end if;\n-               end loop;\n+            if not Compile_Time_Known_Value (Expr) then\n+               return False;\n             end if;\n-         end loop;\n-\n-         return False;\n-      end Check_Identifier_Is_Dimension;\n-\n-      ----------------------\n-      -- Get_Dimension_Id --\n-      ----------------------\n-\n-      --  Given an identifier, returns the correponding position of the\n-      --  dimension in the dimension system.\n-\n-      function Get_Dimension_Id\n-        (Id    : Node_Id;\n-         D_Sys : Dim_Sys_Id) return Dim_Id\n-      is\n-         Na_Id    : constant Name_Id := Chars (Id);\n-         Dim      : Dim_Id;\n-         Dim_Name : Name_Id;\n \n-      begin\n-         for D in Dim_Id'Range loop\n-            Dim_Name := Dim_Systems.Table (D_Sys).Names (D);\n-\n-            if Dim_Name = Na_Id then\n-               Dim := D;\n-            end if;\n+            Next (Comp);\n          end loop;\n \n-         return Dim;\n-      end Get_Dimension_Id;\n+         return True;\n+      end Has_Compile_Time_Known_Expressions;\n \n-      -------------------------------------------------------\n-      -- Check_Compile_Time_Known_Expressions_In_Aggregate --\n-      -------------------------------------------------------\n+      ------------------------\n+      -- Position_In_System --\n+      ------------------------\n \n-      function Check_Compile_Time_Known_Expressions_In_Aggregate\n-        (Expr : Node_Id) return Boolean\n+      function Position_In_System\n+        (Id     : Node_Id;\n+         System : System_Type) return Dimension_Position\n       is\n-         Comp_Assn : Node_Id;\n-         Comp_Expr : Node_Id;\n+         Dimension_Name : constant Name_Id := Chars (Id);\n \n       begin\n-\n-         Comp_Expr := Next (First (Expressions (Expr)));\n-         while Present (Comp_Expr) loop\n-\n-            --  First, analyze the expression\n-\n-            Analyze_And_Resolve (Comp_Expr);\n-\n-            if not Compile_Time_Known_Value (Comp_Expr) then\n-               return False;\n+         for Position in System.Names'Range loop\n+            if Dimension_Name = System.Names (Position) then\n+               return Position;\n             end if;\n-\n-            Next (Comp_Expr);\n          end loop;\n \n-         Comp_Assn := First (Component_Associations (Expr));\n-         while Present (Comp_Assn) loop\n-            Comp_Expr := Expression (Comp_Assn);\n-\n-            --  First, analyze the expression\n-\n-            Analyze_And_Resolve (Comp_Expr);\n+         return Invalid_Position;\n+      end Position_In_System;\n \n-            if not Compile_Time_Known_Value (Comp_Expr) then\n-               return False;\n-            end if;\n-\n-            Next (Comp_Assn);\n-         end loop;\n+      --  Local variables\n \n-         return True;\n-      end Check_Compile_Time_Known_Expressions_In_Aggregate;\n+      Assoc          : Node_Id;\n+      Choice         : Node_Id;\n+      Expr           : Node_Id;\n+      Num_Choices    : Nat := 0;\n+      Num_Dimensions : Nat := 0;\n+      Others_Seen    : Boolean := False;\n+      Position       : Nat := 0;\n+      Symbol         : String_Id;\n+      Symbol_Decl    : Node_Id;\n \n    --  Start of processing for Analyze_Aspect_Dimension\n \n    begin\n-      --  Syntax checking\n+      --  STEP 1: Legality of aspect\n \n-      Error_Msg_Name_1 := Chars (Id);\n-\n-      if N_Kind /= N_Subtype_Declaration then\n-         Error_Msg_N (\"aspect% doesn't apply here\", N);\n+      if Nkind (N) /= N_Subtype_Declaration then\n+         Error_Msg_NE (\"aspect % must apply to subtype declaration\", N, Id);\n          return;\n       end if;\n \n-      if Nkind (Expr) /= N_Aggregate then\n-         Error_Msg_N (\"wrong syntax for aspect%\", Expr);\n+      if Nkind (Aggr) /= N_Aggregate then\n+         Error_Msg_N (\"aggregate expected\", Aggr);\n          return;\n       end if;\n \n-      D_Sys := Corresponding_Dimension_System (N);\n-\n-      if D_Sys = No_Dim_Sys then\n-         Error_Msg_N (\"dimension system not found for aspect%\", N);\n-         return;\n-      end if;\n+      --  Each expression in dimension aggregate must be known at compile time\n \n-      if Corresponding_Etype_Has_Dimensions (N) then\n-         Error_Msg_N (\"corresponding type already has a dimension\", N);\n+      if not Has_Compile_Time_Known_Expressions (Aggr) then\n+         Error_Msg_N (\"values of aggregate must be static\", Aggr);\n          return;\n       end if;\n \n-      --  Check the first expression is a string or a character literal and\n-      --  skip it.\n+      --  The dimension declarations are useless if the parent type does not\n+      --  declare a valid system.\n \n-      Dim_Str_Lit := First (Expressions (Expr));\n-\n-      if not Present (Dim_Str_Lit)\n-        or else not Nkind_In (Dim_Str_Lit,\n-                              N_String_Literal,\n-                              N_Character_Literal)\n-      then\n-         Error_Msg_N\n-           (\"wrong syntax for aspect%: first argument in the aggregate must \" &\n-            \"be a character or a string\",\n-            Expr);\n+      if not Exists (System) then\n+         Error_Msg_NE (\"parent type of % lacks dimension system\", N, Def_Id);\n          return;\n       end if;\n \n-      Comp_Expr := Next (Dim_Str_Lit);\n+      --  STEP 2: Structural verification of the dimension aggregate\n \n-      --  Check the number of dimensions match with the dimension system\n+      --  The first entry in the aggregate is the symbolic representation of\n+      --  the dimension.\n \n-      N_Of_Dims := Dim_Systems.Table (D_Sys).N_Of_Dims;\n+      Symbol_Decl := First (Expressions (Aggr));\n \n-      if not Check_Number_Dimensions_Aggregate (Expr, D_Sys, N_Of_Dims) then\n-         Error_Msg_N (\"wrong number of dimensions for aspect%\", Expr);\n+      if No (Symbol_Decl)\n+        or else not Nkind_In (Symbol_Decl, N_Character_Literal,\n+                                           N_String_Literal)\n+      then\n+         Error_Msg_N (\"first argument must be character or string\", Aggr);\n          return;\n       end if;\n \n-      Dim := Dim_Id'First;\n-      Comp_Assn := First (Component_Associations (Expr));\n+      --  STEP 3: Name and value extraction\n \n-      if Present (Comp_Expr) then\n-         if List_Length (Component_Associations (Expr)) > 1 then\n-            Error_Msg_N (\"named association cannot follow \" &\n-                         \"positional association for aspect%\", Expr);\n-            return;\n-         end if;\n+      --  Positional elements\n \n-         if Present (Comp_Assn)\n-           and then Nkind (First (Choices (Comp_Assn))) /= N_Others_Choice\n-         then\n-            Error_Msg_N (\"named association cannot follow \" &\n-                         \"positional association for aspect%\", Expr);\n+      Expr := Next (Symbol_Decl);\n+      Position := Low_Position_Bound;\n+      while Present (Expr) loop\n+         if Position > High_Position_Bound then\n+            Error_Msg_N\n+              (\"type has more dimensions than system allows\", Def_Id);\n             return;\n          end if;\n-      end if;\n-\n-      --  Check each expression in the aspect Dimension aggregate is known at\n-      --  compile time.\n-\n-      if not Check_Compile_Time_Known_Expressions_In_Aggregate (Expr) then\n-         Error_Msg_N (\"wrong syntax for aspect%\", Expr);\n-         return;\n-      end if;\n-\n-      --  Get the dimension values and store them in the Hash_Table\n-\n-      --  Positional aggregate case\n-\n-      while Present (Comp_Expr) loop\n-         if Is_Integer_Type (Def_Id) then\n-            Dims (Dim) := +Whole (UI_To_Int (Expr_Value (Comp_Expr)));\n-         else\n-            Create_Rational_From_Expr (Comp_Expr, Dims (Dim));\n-         end if;\n \n-         Analyzed (Dim) := True;\n+         Extract_Power (Expr, Position);\n \n-         exit when Dim = Max_Dimensions;\n+         Position := Position + 1;\n+         Num_Dimensions := Num_Dimensions + 1;\n \n-         Dim := Dim + 1;\n-         Next (Comp_Expr);\n+         Next (Expr);\n       end loop;\n \n-      --  Named aggregate case\n+      --  Named elements\n \n-      while Present (Comp_Assn) loop\n-         Comp_Expr := Expression (Comp_Assn);\n-         Choice := First (Choices (Comp_Assn));\n+      Assoc := First (Component_Associations (Aggr));\n+      while Present (Assoc) loop\n+         Expr   := Expression (Assoc);\n+         Choice := First (Choices (Assoc));\n \n-         if List_Length (Choices (Comp_Assn)) = 1 then\n+         while Present (Choice) loop\n \n-            --  N_Identifier case\n+            --  Identifier case: NAME => EXPRESSION\n \n             if Nkind (Choice) = N_Identifier then\n+               Position := Position_In_System (Choice, System);\n \n-               if not Check_Identifier_Is_Dimension (Choice, D_Sys) then\n+               if Is_Invalid (Position) then\n+                  Error_Msg_N (\"dimension name not part of system\", Choice);\n                   return;\n                end if;\n \n-               Dim := Get_Dimension_Id (Choice, D_Sys);\n-\n-               if Is_Integer_Type (Def_Id) then\n-                  Dims (Dim) := +Whole (UI_To_Int (Expr_Value (Comp_Expr)));\n-               else\n-                  Create_Rational_From_Expr (Comp_Expr, Dims (Dim));\n-               end if;\n-\n-               Analyzed (Dim) := True;\n+               Extract_Power (Expr, Position);\n \n-            --  N_Range case\n+            --  Range case: NAME .. NAME => EXPRESSION\n \n             elsif Nkind (Choice) = N_Range then\n                declare\n-                  HB     : constant Node_Id := High_Bound (Choice);\n-                  LB     : constant Node_Id := Low_Bound (Choice);\n-                  LB_Dim : constant Dim_Id  := Get_Dimension_Id (LB, D_Sys);\n-                  HB_Dim : constant Dim_Id  := Get_Dimension_Id (HB, D_Sys);\n+                  Low      : constant Node_Id := Low_Bound (Choice);\n+                  High     : constant Node_Id := High_Bound (Choice);\n+                  Low_Pos  : Dimension_Position;\n+                  High_Pos : Dimension_Position;\n \n                begin\n-                  for Dim in LB_Dim .. HB_Dim loop\n-                     if Is_Integer_Type (Def_Id) then\n-                        Dims (Dim) :=\n-                          +Whole (UI_To_Int (Expr_Value (Comp_Expr)));\n-                     else\n-                        Create_Rational_From_Expr (Comp_Expr, Dims (Dim));\n-                     end if;\n+                  if Nkind (Low) /= N_Identifier then\n+                     Error_Msg_N (\"bound must denote a dimension name\", Low);\n+                     return;\n+                  elsif Nkind (High) /= N_Identifier then\n+                     Error_Msg_N (\"bound must denote a dimension name\", High);\n+                     return;\n+                  end if;\n+\n+                  Low_Pos  := Position_In_System (Low, System);\n+                  High_Pos := Position_In_System (High, System);\n+\n+                  if Is_Invalid (Low_Pos) then\n+                     Error_Msg_N (\"dimension name not part of system\", Low);\n+                     return;\n+\n+                  elsif Is_Invalid (High_Pos) then\n+                     Error_Msg_N (\"dimension name not part of system\", High);\n+                     return;\n+\n+                  elsif Low_Pos > High_Pos then\n+                     Error_Msg_N (\"expected low to high range\", Choice);\n+                     return;\n+                  end if;\n \n-                     Analyzed (Dim) := True;\n+                  for Position in Low_Pos .. High_Pos loop\n+                     Extract_Power (Expr, Position);\n                   end loop;\n                end;\n \n-            --  N_Others_Choice case\n+            --  Others case: OTHERS => EXPRESSION\n \n             elsif Nkind (Choice) = N_Others_Choice then\n+               if Present (Next (Choice)) then\n+                  Error_Msg_N\n+                    (\"OTHERS must appear alone in a choice list\", Choice);\n+                  return;\n \n-               --  Check the Others_Choice is alone and last in the aggregate\n-\n-               if Present (Next (Comp_Assn)) then\n+               elsif Present (Next (Assoc)) then\n                   Error_Msg_N\n-                    (\"OTHERS must appear alone and last in expression \" &\n-                     \"for aspect%\", Choice);\n+                    (\"OTHERS must appear last in an aggregate\", Choice);\n+                  return;\n+\n+               elsif Others_Seen then\n+                  Error_Msg_N (\"multiple OTHERS not allowed\", Choice);\n                   return;\n                end if;\n \n-               --  End the filling of Dims by the Others_Choice value. If\n-               --  N_Of_Dims < Max_Dimensions then only the positions that\n-               --  haven't been already analyzed from Dim_Id'First to N_Of_Dims\n-               --  are filled.\n+               Others_Seen := True;\n \n-               for Dim in Dim_Id'First .. N_Of_Dims loop\n-                  if not Analyzed (Dim) then\n-                     if Is_Integer_Type (Def_Id) then\n-                        Dims (Dim) :=\n-                          +Whole (UI_To_Int (Expr_Value (Comp_Expr)));\n-                     else\n-                        Create_Rational_From_Expr (Comp_Expr, Dims (Dim));\n-                     end if;\n+               --  Fill the non-processed dimensions with the default value\n+               --  supplied by others.\n+\n+               for Position in Processed'Range loop\n+                  if not Processed (Position) then\n+                     Extract_Power (Expr, Position);\n                   end if;\n                end loop;\n \n+            --  All other cases are erroneous declarations of dimension names\n+\n             else\n-               Error_Msg_N (\"wrong syntax for aspect%\", Id);\n+               Error_Msg_N (\"wrong syntax for aspect%\", Choice);\n+               return;\n             end if;\n \n-         else\n-            while Present (Choice) loop\n-               if Nkind (Choice) = N_Identifier then\n+            Num_Choices := Num_Choices + 1;\n \n-                  if not Check_Identifier_Is_Dimension (Choice, D_Sys) then\n-                     return;\n-                  end if;\n+            Next (Choice);\n+         end loop;\n \n-                  Dim := Get_Dimension_Id (Choice, D_Sys);\n+         Num_Dimensions := Num_Dimensions + 1;\n \n-                  if Is_Integer_Type (Def_Id) then\n-                     Dims (Dim) := +Whole (UI_To_Int (Expr_Value (Comp_Expr)));\n-                  else\n-                     Create_Rational_From_Expr (Comp_Expr, Dims (Dim));\n-                  end if;\n+         Next (Assoc);\n+      end loop;\n \n-                  Analyzed (Dim) := True;\n-                  Next (Choice);\n-               else\n-                  Error_Msg_N (\"wrong syntax for aspect%\", Id);\n-               end if;\n-            end loop;\n-         end if;\n+      --  STEP 4: Consistency of system and dimensions\n \n-         Next (Comp_Assn);\n-      end loop;\n+      if Present (Next (Symbol_Decl))\n+        and then (Num_Choices > 1\n+                   or else (Num_Choices = 1 and then not Others_Seen))\n+      then\n+         Error_Msg_N\n+           (\"named associations cannot follow positional associations\", Aggr);\n \n-      --  Create the string of dimensions\n+      elsif Num_Dimensions > System.Count then\n+         Error_Msg_N (\"type has more dimensions than system allows\", Def_Id);\n \n-      if Nkind (Dim_Str_Lit) = N_Character_Literal then\n-         Start_String;\n-         Store_String_Char (UI_To_CC (Char_Literal_Value (Dim_Str_Lit)));\n-         Str := End_String;\n-      else\n-         Str := Strval (Dim_Str_Lit);\n+      elsif Num_Dimensions < System.Count and then not Others_Seen then\n+         Error_Msg_N (\"type has less dimensions than system allows\", Def_Id);\n       end if;\n \n-      --  Store the dimensions in the Hash Table if not all equal to zero and\n-      --  string is empty.\n+      --  STEP 5: Dimension symbol extraction\n \n-      if not Present (Dims) then\n-         if String_Length (Str) = 0 then\n-            Error_Msg_N\n-              (\"?dimension values all equal to zero for aspect%\", Expr);\n-            return;\n-         end if;\n+      if Nkind (Symbol_Decl) = N_Character_Literal then\n+         Start_String;\n+         Store_String_Char (UI_To_CC (Char_Literal_Value (Symbol_Decl)));\n+         Symbol := End_String;\n       else\n-         Set_Dimensions (Def_Id, Dims);\n+         Symbol := Strval (Symbol_Decl);\n+      end if;\n+\n+      if String_Length (Symbol) = 0 and then not Exists (Dimensions) then\n+         Error_Msg_N (\"useless dimension declaration\", Aggr);\n       end if;\n \n-      --  Store the string in the Hash Table\n-      --  When the string is empty, don't store the string in the Hash Table\n+      --  STEP 6: Storage of extracted values\n \n-      if Str /= No_String\n-        and then String_Length (Str) /= 0\n-      then\n-         Set_Dimensions_String_Id (Def_Id, Str);\n+      if String_Length (Symbol) /= 0 then\n+         Set_Symbol (Def_Id, Symbol);\n+      end if;\n+\n+      if Exists (Dimensions) then\n+         Set_Dimensions (Def_Id, Dimensions);\n       end if;\n    end Analyze_Aspect_Dimension;\n \n@@ -1034,10 +775,10 @@ package body Sem_Dim is\n       Dim_Name   : Node_Id;\n       Dim_Node   : Node_Id;\n       Dim_Symbol : Node_Id;\n-      D_Sys      : Dimension_System := No_Dimension_System;\n-      Names      : Name_Array       := No_Names;\n-      N_Of_Dims  : N_Of_Dimensions;\n-      Symbols    : Symbol_Array     := No_Symbols;\n+      D_Sys      : System_Type  := Null_System;\n+      Names      : Name_Array   := No_Names;\n+      N_Of_Dims  : Dimension_Position;\n+      Symbols    : Symbol_Array := No_Symbols;\n \n       function Derived_From_Numeric_Type (N : Node_Id) return Boolean;\n       --  Return True if the node is a derived type declaration from any\n@@ -1048,7 +789,7 @@ package body Sem_Dim is\n \n       function Check_Number_Of_Dimensions (Expr : Node_Id) return Boolean;\n       --  Return True if the number of dimensions in the corresponding\n-      --  dimension is positive and lower than Max_Dimensions.\n+      --  dimension is positive and lower than Max_Number_Of_Dimensions.\n \n       -------------------------------\n       -- Derived_From_Numeric_Type --\n@@ -1161,10 +902,9 @@ package body Sem_Dim is\n \n       function Check_Number_Of_Dimensions (Expr : Node_Id) return Boolean is\n          List_Expr : constant List_Id := Expressions (Expr);\n-\n       begin\n-         if List_Length (List_Expr) < Dim_Id'First\n-           or else List_Length (List_Expr) > Max_Dimensions\n+         if List_Length (List_Expr) < Dimension_Position'First\n+           or else List_Length (List_Expr) > Max_Number_Of_Dimensions\n          then\n             return False;\n          else\n@@ -1175,7 +915,7 @@ package body Sem_Dim is\n    --  Start of processing for Analyze_Aspect_Dimension_System\n \n    begin\n-      Error_Msg_Name_1 := Chars (Id);\n+      --  Error_Msg_Name_1 := Chars (Id);\n \n       --  Syntax checking\n \n@@ -1206,10 +946,10 @@ package body Sem_Dim is\n \n       --  Create the new dimension system\n \n-      D_Sys.Base_Type := N;\n+      D_Sys.Type_Decl := N;\n       Dim_Node := First (Expressions (Expr));\n \n-      for Dim in Dim_Id'First .. N_Of_Dims loop\n+      for Dim in Names'First .. N_Of_Dims loop\n          Dim_Name := First (Expressions (Dim_Node));\n          Names (Dim) := Chars (Dim_Name);\n          Dim_Symbol := Next (Dim_Name);\n@@ -1230,13 +970,13 @@ package body Sem_Dim is\n          Next (Dim_Node);\n       end loop;\n \n-      D_Sys.Names     := Names;\n-      D_Sys.N_Of_Dims := N_Of_Dims;\n-      D_Sys.Symbols   := Symbols;\n+      D_Sys.Names := Names;\n+      D_Sys.Count := N_Of_Dims;\n+      D_Sys.Symbols := Symbols;\n \n       --  Store the dimension system in the Table\n \n-      Dim_Systems.Append (D_Sys);\n+      System_Table.Append (D_Sys);\n    end Analyze_Aspect_Dimension_System;\n \n    -----------------------\n@@ -1308,28 +1048,28 @@ package body Sem_Dim is\n \n    procedure Analyze_Dimension_Assignment_Statement (N : Node_Id) is\n       Lhs     : constant Node_Id    := Name (N);\n-      Dim_Lhs : constant Dimensions := Get_Dimensions (Lhs);\n+      Dim_Lhs : constant Dimension_Type := Dimensions_Of (Lhs);\n       Rhs     : constant Node_Id    := Expression (N);\n-      Dim_Rhs : constant Dimensions := Get_Dimensions (Rhs);\n+      Dim_Rhs : constant Dimension_Type := Dimensions_Of (Rhs);\n \n       procedure Analyze_Dimensions_In_Assignment\n-        (Dim_Lhs : Dimensions;\n-         Dim_Rhs : Dimensions);\n-      --  Subroutine to perform the dimensionnality checking for assignment\n+        (Dim_Lhs : Dimension_Type;\n+         Dim_Rhs : Dimension_Type);\n+      --  Perform the dimensionality checking for assignment\n \n       --------------------------------------\n       -- Analyze_Dimensions_In_Assignment --\n       --------------------------------------\n \n       procedure Analyze_Dimensions_In_Assignment\n-        (Dim_Lhs : Dimensions;\n-         Dim_Rhs : Dimensions)\n+        (Dim_Lhs : Dimension_Type;\n+         Dim_Rhs : Dimension_Type)\n       is\n       begin\n          --  Check the lhs and the rhs have the same dimension\n \n-         if not Present (Dim_Lhs) then\n-            if Present (Dim_Rhs) then\n+         if not Exists (Dim_Lhs) then\n+            if Exists (Dim_Rhs) then\n                Error_Msg_N (\"?dimensions missmatch in assignment\", N);\n             end if;\n \n@@ -1360,16 +1100,18 @@ package body Sem_Dim is\n       then\n          declare\n             L                 : constant Node_Id := Left_Opnd (N);\n-            L_Dims            : constant Dimensions := Get_Dimensions (L);\n-            L_Has_Dimensions  : constant Boolean := Present (L_Dims);\n+            L_Dims            : constant Dimension_Type := Dimensions_Of (L);\n+            L_Has_Dimensions  : constant Boolean := Exists (L_Dims);\n             R                 : constant Node_Id := Right_Opnd (N);\n-            R_Dims            : constant Dimensions := Get_Dimensions (R);\n-            R_Has_Dimensions  : constant Boolean := Present (R_Dims);\n-            Dims              : Dimensions := Zero_Dimensions;\n+            R_Dims            : constant Dimension_Type := Dimensions_Of (R);\n+            R_Has_Dimensions  : constant Boolean := Exists (R_Dims);\n+            Dims              : Dimension_Type := Null_Dimension;\n \n          begin\n             if Nkind_In (N, N_Op_Add, N_Op_Mod, N_Op_Rem, N_Op_Subtract) then\n-               Error_Msg_Name_1 := Chars (N);\n+\n+               --  What is the following deleted code about\n+               --  Error_Msg_Name_1 := Chars (N);\n \n                --  Check both operands dimension\n \n@@ -1403,14 +1145,14 @@ package body Sem_Dim is\n                   --  Get both operands dimension and add them\n \n                   if N_Kind = N_Op_Multiply then\n-                     for Dim in Dimensions'Range loop\n+                     for Dim in Dimension_Type'Range loop\n                         Dims (Dim) := L_Dims (Dim) + R_Dims (Dim);\n                      end loop;\n \n                   --  Get both operands dimension and subtract them\n \n                   else\n-                     for Dim in Dimensions'Range loop\n+                     for Dim in Dimension_Type'Range loop\n                         Dims (Dim) := L_Dims (Dim) - R_Dims (Dim);\n                      end loop;\n                   end if;\n@@ -1428,17 +1170,18 @@ package body Sem_Dim is\n                   end if;\n                end if;\n \n-               if Present (Dims) then\n+               if Exists (Dims) then\n                   Set_Dimensions (N, Dims);\n                end if;\n \n-            --  N_Op_Expon\n+               --  N_Op_Expon\n+\n             --  Propagation of the dimension and evaluation of the result if\n             --  the exponent is a rational and if the operand has a dimension.\n \n             elsif N_Kind = N_Op_Expon then\n                declare\n-                  Rat : Rational := Zero_Rational;\n+                  Rat : Rational := Zero;\n \n                begin\n                   --  Check exponent is dimensionless\n@@ -1455,23 +1198,23 @@ package body Sem_Dim is\n                      --  compile time. Otherwise, the exponentiation evaluation\n                      --  will return an error message.\n \n-                     if Get_Dimension_System_Id\n-                          (Base_Type (Etype (L))) /= No_Dim_Sys\n+                     if Exists (System_Of (Base_Type (Etype (L))))\n                        and then Compile_Time_Known_Value (R)\n                      then\n                         --  Real exponent case\n \n                         if Is_Real_Type (Etype (L)) then\n+\n                            --  Define the exponent as a Rational number\n \n-                           Create_Rational_From_Expr (R, Rat);\n+                           Rat := Create_Rational_From_Expr (R);\n \n                            if L_Has_Dimensions then\n-                              for Dim in Dimensions'Range loop\n+                              for Dim in Dimension_Type'Range loop\n                                  Dims (Dim) := L_Dims (Dim) * Rat;\n                               end loop;\n \n-                              if Present (Dims) then\n+                              if Exists (Dims) then\n                                  Set_Dimensions (N, Dims);\n                               end if;\n                            end if;\n@@ -1483,13 +1226,13 @@ package body Sem_Dim is\n                         --  Integer exponent case\n \n                         else\n-                           for Dim in Dimensions'Range loop\n+                           for Dim in Dimension_Type'Range loop\n                               Dims (Dim) :=\n                                 L_Dims (Dim) *\n                                  Whole (UI_To_Int (Expr_Value (R)));\n                            end loop;\n \n-                           if Present (Dims) then\n+                           if Exists (Dims) then\n                               Set_Dimensions (N, Dims);\n                            end if;\n                         end if;\n@@ -1501,7 +1244,9 @@ package body Sem_Dim is\n             --  performed (no propagation).\n \n             elsif N_Kind in N_Op_Compare then\n-               Error_Msg_Name_1 := Chars (N);\n+\n+               --  What is this deleted code about ???\n+               --  Error_Msg_Name_1 := Chars (N);\n \n                if (L_Has_Dimensions or R_Has_Dimensions)\n                   and then L_Dims /= R_Dims\n@@ -1526,19 +1271,19 @@ package body Sem_Dim is\n       Expr   : constant Node_Id    := Expression (N);\n       Id     : constant Entity_Id  := Defining_Identifier (N);\n       E_Typ  : constant Entity_Id  := Etype (Id);\n-      Dim_T  : constant Dimensions := Get_Dimensions (E_Typ);\n-      Dim_E  : Dimensions;\n+      Dim_T  : constant Dimension_Type := Dimensions_Of (E_Typ);\n+      Dim_E  : Dimension_Type;\n \n    begin\n-      if Present (Dim_T) then\n+      if Exists (Dim_T) then\n \n          --  If the component type has a dimension and there is no expression,\n          --  propagates the dimension.\n \n          if Present (Expr) then\n-            Dim_E := Get_Dimensions (Expr);\n+            Dim_E := Dimensions_Of (Expr);\n \n-            if Present (Dim_E) then\n+            if Exists (Dim_E) then\n \n                --  Return an error if the dimension of the expression and the\n                --  dimension of the type missmatch.\n@@ -1571,8 +1316,8 @@ package body Sem_Dim is\n       Obj_Decls : constant List_Id := Return_Object_Declarations (N);\n       R_Ent     : constant Entity_Id := Return_Statement_Entity (N);\n       R_Etyp    : constant Entity_Id := Etype (Return_Applies_To (R_Ent));\n-      Dims_R    : constant Dimensions := Get_Dimensions (R_Etyp);\n-      Dims_Obj  : Dimensions;\n+      Dims_R    : constant Dimension_Type := Dimensions_Of (R_Etyp);\n+      Dims_Obj  : Dimension_Type;\n       Obj_Decl  : Node_Id;\n       Obj_Id    : Entity_Id;\n \n@@ -1584,11 +1329,11 @@ package body Sem_Dim is\n                Obj_Id := Defining_Identifier (Obj_Decl);\n \n                if Is_Return_Object (Obj_Id) then\n-                  Dims_Obj := Get_Dimensions (Obj_Id);\n+                  Dims_Obj := Dimensions_Of (Obj_Id);\n \n                   if Dims_R /= Dims_Obj then\n-                     Error_Msg_N (\"?dimensions missmatch in return statement\",\n-                                  N);\n+                     Error_Msg_N\n+                       (\"?dimensions missmatch in return statement\", N);\n                      return;\n                   end if;\n                end if;\n@@ -1606,8 +1351,8 @@ package body Sem_Dim is\n    procedure Analyze_Dimension_Function_Call (N : Node_Id) is\n       Name_Call  : constant Node_Id := Name (N);\n       Par_Ass    : constant List_Id := Parameter_Associations (N);\n-      Dims       : Dimensions;\n-      Dims_Param : Dimensions;\n+      Dims       : Dimension_Type;\n+      Dims_Param : Dimension_Type;\n       Param      : Node_Id;\n \n       function Is_Elementary_Function_Call (N : Node_Id) return Boolean;\n@@ -1624,9 +1369,7 @@ package body Sem_Dim is\n       begin\n          --  Note that the node must come from source\n \n-         if Comes_From_Source (N)\n-           and then Is_Entity_Name (Name_Call)\n-         then\n+         if Comes_From_Source (N) and then Is_Entity_Name (Name_Call) then\n             Ent := Entity (Name_Call);\n \n             --  Check the procedure is defined in an instantiation of a generic\n@@ -1659,9 +1402,9 @@ package body Sem_Dim is\n          --  Sqrt function call case\n \n          if Chars (Name_Call) = Name_Sqrt then\n-            Dims := Get_Dimensions (First (Par_Ass));\n+            Dims := Dimensions_Of (First (Par_Ass));\n \n-            if Present (Dims) then\n+            if Exists (Dims) then\n                for Dim in Dims'Range loop\n                   Dims (Dim) := Dims (Dim) * (1, 2);\n                end loop;\n@@ -1675,14 +1418,16 @@ package body Sem_Dim is\n          else\n             Param := First (Par_Ass);\n             while Present (Param) loop\n-               Dims_Param := Get_Dimensions (Param);\n+               Dims_Param := Dimensions_Of (Param);\n+\n+               if Exists (Dims_Param) then\n+\n+                  --  What is this deleted code about ???\n+                  --  Error_Msg_Name_1 := Chars (Name_Call);\n \n-               if Present (Dims_Param) then\n-                  Error_Msg_Name_1 := Chars (Name_Call);\n                   Error_Msg_N\n-                    (\"?parameter should be dimensionless for elementary \" &\n-                     \"function%\",\n-                      Param);\n+                    (\"?parameter should be dimensionless for elementary \"\n+                     & \"function%\", Param);\n                   return;\n                end if;\n \n@@ -1703,13 +1448,13 @@ package body Sem_Dim is\n \n    procedure Analyze_Dimension_Has_Etype (N : Node_Id) is\n       E_Typ  : constant Entity_Id := Etype (N);\n-      Dims   : constant Dimensions := Get_Dimensions (E_Typ);\n+      Dims   : constant Dimension_Type := Dimensions_Of (E_Typ);\n       N_Kind : constant Node_Kind := Nkind (N);\n \n    begin\n       --  Propagation of the dimensions from the type\n \n-      if Present (Dims) then\n+      if Exists (Dims) then\n          Set_Dimensions (N, Dims);\n       end if;\n \n@@ -1749,9 +1494,9 @@ package body Sem_Dim is\n \n    procedure Analyze_Dimension_Identifier (N : Node_Id) is\n       Ent  : constant Entity_Id := Entity (N);\n-      Dims : constant Dimensions := Get_Dimensions (Ent);\n+      Dims : constant Dimension_Type := Dimensions_Of (Ent);\n    begin\n-      if Present (Dims) then\n+      if Exists (Dims) then\n          Set_Dimensions (N, Dims);\n       else\n          Analyze_Dimension_Has_Etype (N);\n@@ -1766,18 +1511,18 @@ package body Sem_Dim is\n       Expr   : constant Node_Id   := Expression (N);\n       Id     : constant Entity_Id := Defining_Identifier (N);\n       E_Typ  : constant Entity_Id := Etype (Id);\n-      Dim_T  : constant Dimensions := Get_Dimensions (E_Typ);\n-      Dim_E  : Dimensions;\n+      Dim_T  : constant Dimension_Type := Dimensions_Of (E_Typ);\n+      Dim_E  : Dimension_Type;\n \n    begin\n-      if Present (Dim_T) then\n+      if Exists (Dim_T) then\n \n          --  Expression is present\n \n          if Present (Expr) then\n-            Dim_E := Get_Dimensions (Expr);\n+            Dim_E := Dimensions_Of (Expr);\n \n-            if Present (Dim_E) then\n+            if Exists (Dim_E) then\n \n                --  Return an error if the dimension of the expression and the\n                --  dimension of the type missmatch.\n@@ -1790,9 +1535,8 @@ package body Sem_Dim is\n             --  If the expression is dimensionless\n \n             else\n-               --  If the node is not a real constant or an integer constant\n-               --  (depending on the dimensioned numeric type), return an error\n-               --  message.\n+               --  If node is not a real or integer constant (depending on the\n+               --  dimensioned numeric type), generate an error message.\n \n                if not Nkind_In (Original_Node (Expr),\n                                 N_Real_Literal,\n@@ -1819,9 +1563,9 @@ package body Sem_Dim is\n       Id       : constant Entity_Id := Defining_Identifier (N);\n       Ren_Id   : constant Node_Id   := Name (N);\n       E_Typ    : constant Entity_Id := Etype (Ren_Id);\n-      Dims_Typ : constant Dimensions := Get_Dimensions (E_Typ);\n+      Dims_Typ : constant Dimension_Type := Dimensions_Of (E_Typ);\n    begin\n-      if Present (Dims_Typ) then\n+      if Exists (Dims_Typ) then\n          Copy_Dimensions (E_Typ, Id);\n       end if;\n    end Analyze_Dimension_Object_Renaming_Declaration;\n@@ -1832,10 +1576,10 @@ package body Sem_Dim is\n \n    procedure Analyze_Dimension_Simple_Return_Statement (N : Node_Id) is\n       Expr      : constant Node_Id := Expression (N);\n-      Dims_Expr : constant Dimensions := Get_Dimensions (Expr);\n+      Dims_Expr : constant Dimension_Type := Dimensions_Of (Expr);\n       R_Ent     : constant Entity_Id := Return_Statement_Entity (N);\n       R_Etyp    : constant Entity_Id := Etype (Return_Applies_To (R_Ent));\n-      Dims_R    : constant Dimensions := Get_Dimensions (R_Etyp);\n+      Dims_R    : constant Dimension_Type := Dimensions_Of (R_Etyp);\n    begin\n       if Dims_R /= Dims_Expr then\n          Error_Msg_N (\"?dimensions missmatch in return statement\", N);\n@@ -1849,50 +1593,48 @@ package body Sem_Dim is\n \n    procedure Analyze_Dimension_Subtype_Declaration (N : Node_Id) is\n       Ent      : constant Entity_Id := Defining_Identifier (N);\n-      Dims_Ent : constant Dimensions := Get_Dimensions (Ent);\n+      Dims_Ent : constant Dimension_Type := Dimensions_Of (Ent);\n       E_Typ    : Node_Id;\n \n    begin\n       if Nkind (Subtype_Indication (N)) /= N_Subtype_Indication then\n          E_Typ := Etype (Subtype_Indication (N));\n          declare\n-            Dims_Typ : constant Dimensions := Get_Dimensions (E_Typ);\n+            Dims_Typ : constant Dimension_Type := Dimensions_Of (E_Typ);\n \n          begin\n-            if Present (Dims_Typ) then\n+            if Exists (Dims_Typ) then\n \n                --  If subtype already has a dimension (from Aspect_Dimension),\n                --  it cannot inherit a dimension from its subtype.\n \n-               if Present (Dims_Ent) then\n+               if Exists (Dims_Ent) then\n                   Error_Msg_N (\"?subtype& already has a dimension\", N);\n \n                else\n                   Set_Dimensions (Ent, Dims_Typ);\n-                  Set_Dimensions_String_Id\n-                    (Ent, Get_Dimensions_String_Id (E_Typ));\n+                  Set_Symbol (Ent, Symbol_Of (E_Typ));\n                end if;\n             end if;\n          end;\n \n       else\n          E_Typ := Etype (Subtype_Mark (Subtype_Indication (N)));\n          declare\n-            Dims_Typ : constant Dimensions := Get_Dimensions (E_Typ);\n+            Dims_Typ : constant Dimension_Type := Dimensions_Of (E_Typ);\n \n          begin\n-            if Present (Dims_Typ) then\n+            if Exists (Dims_Typ) then\n \n                --  If subtype already has a dimension (from Aspect_Dimension),\n                --  it cannot inherit a dimension from its subtype.\n \n-               if Present (Dims_Ent) then\n+               if Exists (Dims_Ent) then\n                   Error_Msg_N (\"?subtype& already has a dimension\", N);\n \n                else\n                   Set_Dimensions (Ent, Dims_Typ);\n-                  Set_Dimensions_String_Id\n-                    (Ent, Get_Dimensions_String_Id (E_Typ));\n+                  Set_Symbol (Ent, Symbol_Of (E_Typ));\n                end if;\n             end if;\n          end;\n@@ -1925,22 +1667,22 @@ package body Sem_Dim is\n    -- Copy_Dimensions --\n    ---------------------\n \n-   procedure Copy_Dimensions (From, To : Node_Id) is\n-      Dims : constant Dimensions := Aspect_Dimension_Hash_Table.Get (From);\n+   procedure Copy_Dimensions (From : Node_Id; To : Node_Id) is\n+      Dims : constant Dimension_Type := Dimensions_Of (From);\n \n    begin\n       --  Propagate the dimension from one node to another\n \n-      pragma Assert (Permits_Dimensions (To));\n-      pragma Assert (Present (Dims));\n-      Aspect_Dimension_Hash_Table.Set (To, Dims);\n+      pragma Assert (OK_For_Dimension (Nkind (To)));\n+      pragma Assert (Exists (Dims));\n+      Set_Dimensions (To, Dims);\n    end Copy_Dimensions;\n \n    -------------------------------\n    -- Create_Rational_From_Expr --\n    -------------------------------\n \n-   procedure Create_Rational_From_Expr (Expr : Node_Id; R : in out Rational) is\n+   function Create_Rational_From_Expr (Expr : Node_Id) return Rational is\n       Or_N         : constant Node_Id := Original_Node (Expr);\n       Left         : Node_Id;\n       Left_Int     : Int;\n@@ -1949,6 +1691,7 @@ package body Sem_Dim is\n       Right_Int    : Int;\n       R_Opnd_Minus : Node_Id;\n       Rtype        : Entity_Id;\n+      Result       : Rational;\n \n    begin\n       --  A rational number is a number that can be expressed as the quotient\n@@ -1974,9 +1717,9 @@ package body Sem_Dim is\n \n             if Right_Int > 0 then\n                if Left_Int mod Right_Int = 0 then\n-                  R := +Whole (UI_To_Int (Expr_Value (Expr)));\n+                  Result := +Whole (UI_To_Int (Expr_Value (Expr)));\n                else\n-                  R := Whole (Left_Int) / Whole (Right_Int);\n+                  Result := Whole (Left_Int) / Whole (Right_Int);\n                end if;\n \n             else\n@@ -2009,9 +1752,9 @@ package body Sem_Dim is\n \n             if Right_Int > 0 then\n                if Left_Int mod Right_Int = 0 then\n-                  R := +Whole (-UI_To_Int (Expr_Value (Expr)));\n+                  Result := +Whole (-UI_To_Int (Expr_Value (Expr)));\n                else\n-                  R := Whole (-Left_Int) / Whole (Right_Int);\n+                  Result := Whole (-Left_Int) / Whole (Right_Int);\n                end if;\n \n             else\n@@ -2028,19 +1771,41 @@ package body Sem_Dim is\n       else\n          if Is_Integer_Type (Etype (Expr)) then\n             Right_Int := UI_To_Int (Expr_Value (Expr));\n-            R         :=  +Whole (Right_Int);\n+            Result    :=  +Whole (Right_Int);\n \n          else\n             Error_Msg_N (\"must be a rational\", Expr);\n          end if;\n       end if;\n+\n+      return Result;\n    end Create_Rational_From_Expr;\n \n+   -------------------\n+   -- Dimensions_Of --\n+   -------------------\n+\n+   function Dimensions_Of (N : Node_Id) return Dimension_Type is\n+   begin\n+      return Dimension_Table.Get (N);\n+   end Dimensions_Of;\n+\n+   --------------------------\n+   -- Dimension_Table_Hash --\n+   --------------------------\n+\n+   function Dimension_Table_Hash\n+     (Key : Node_Id) return Dimension_Table_Range\n+   is\n+   begin\n+      return Dimension_Table_Range (Key mod 511);\n+   end Dimension_Table_Hash;\n+\n    ----------------------------------------\n    -- Eval_Op_Expon_For_Dimensioned_Type --\n    ----------------------------------------\n \n-   --  Eval the expon operator for dimensioned type\n+   --  Evaluate the expon operator for dimensioned type\n \n    --  Note that if the exponent is an integer (denominator = 1) the node is\n    --  not evaluated here and must be evaluated by the Eval_Op_Expon routine.\n@@ -2050,10 +1815,10 @@ package body Sem_Dim is\n       B_Typ : Entity_Id)\n    is\n       R   : constant Node_Id := Right_Opnd (N);\n-      Rat : Rational := Zero_Rational;\n+      Rat : Rational := Zero;\n    begin\n       if Compile_Time_Known_Value (R) and then Is_Real_Type (B_Typ) then\n-         Create_Rational_From_Expr (R, Rat);\n+         Rat := Create_Rational_From_Expr (R);\n          Eval_Op_Expon_With_Rational_Exponent (N, Rat);\n       end if;\n    end Eval_Op_Expon_For_Dimensioned_Type;\n@@ -2071,7 +1836,7 @@ package body Sem_Dim is\n      (N   : Node_Id;\n       Rat : Rational)\n    is\n-      Dims         : constant Dimensions := Get_Dimensions (N);\n+      Dims         : constant Dimension_Type := Dimensions_Of (N);\n       L            : constant Node_Id := Left_Opnd (N);\n       Etyp         : constant Entity_Id := Etype (L);\n       Loc          : constant Source_Ptr := Sloc (N);\n@@ -2085,25 +1850,23 @@ package body Sem_Dim is\n       New_E        : Entity_Id;\n       New_N        : Node_Id;\n       New_Typ_L    : Node_Id;\n-      Sys          : Dim_Sys_Id;\n+      System       : System_Type;\n \n    begin\n       --  If Rat.Denominator = 1 that means the exponent is an Integer so\n       --  nothing has to be changed. Note that the node must come from source.\n \n-      if Comes_From_Source (N)\n-        and then Rat.Denominator /= 1\n-      then\n+      if Comes_From_Source (N) and then Rat.Denominator /= 1 then\n          Base_Typ := Base_Type (Etyp);\n \n          --  Case when the operand is not dimensionless\n \n-         if Present (Dims) then\n+         if Exists (Dims) then\n \n             --  Get the corresponding Dim_Sys_Id to know the exact number of\n             --  dimensions in the system.\n \n-            Sys := Get_Dimension_System_Id (Base_Typ);\n+            System := System_Of (Base_Typ);\n \n             --  Step 1: Generation of a new subtype with the proper dimensions\n \n@@ -2114,10 +1877,10 @@ package body Sem_Dim is\n             --  Generate:\n \n             --  Base_Typ  : constant Entity_Id := Base_Type (Etyp);\n-            --  Sys       : constant Dim_Sys_Id :=\n+            --  Sys       : constant System_Id :=\n             --               Get_Dimension_System_Id (Base_Typ);\n-            --  N_Dims    : constant N_Of_Dimensions :=\n-            --               Dim_Systems.Table (Sys).N_Of_Dims;\n+            --  N_Dims    : constant Number_Of_Dimensions :=\n+            --               Dimension_Systems.Table (Sys).Dimension_Count;\n             --  Dim_Value : Rational;\n \n             --  Aspect_Dim_Expr : List;\n@@ -2144,7 +1907,7 @@ package body Sem_Dim is\n \n             Append (Make_String_Literal (Loc, No_String), List_Of_Dims);\n \n-            for Dim in Dims'First .. Dim_Systems.Table (Sys).N_Of_Dims loop\n+            for Dim in Dims'First ..  System.Count loop\n                Dim_Value := Dims (Dim);\n \n                if Dim_Value.Denominator /= 1 then\n@@ -2245,6 +2008,20 @@ package body Sem_Dim is\n       end if;\n    end Eval_Op_Expon_With_Rational_Exponent;\n \n+   ------------\n+   -- Exists --\n+   ------------\n+\n+   function Exists (Dim : Dimension_Type) return Boolean is\n+   begin\n+      return Dim /= Null_Dimension;\n+   end Exists;\n+\n+   function Exists (Sys : System_Type) return Boolean is\n+   begin\n+      return Sys /= Null_System;\n+   end Exists;\n+\n    -------------------------------------------\n    -- Expand_Put_Call_With_Dimension_String --\n    -------------------------------------------\n@@ -2278,12 +2055,12 @@ package body Sem_Dim is\n       Actual       : Node_Id;\n       Base_Typ     : Node_Id;\n       Char_Pack    : Name_Id;\n-      Dims         : Dimensions;\n+      Dims         : Dimension_Type;\n       Etyp         : Entity_Id;\n       First_Actual : Node_Id;\n       New_Par_Ass  : List_Id;\n       New_Str_Lit  : Node_Id;\n-      Sys          : Dim_Sys_Id;\n+      System       : System_Type;\n \n       function Is_Procedure_Put_Call (N : Node_Id) return Boolean;\n       --  Return True if the current call is a call of an instantiation of a\n@@ -2363,17 +2140,17 @@ package body Sem_Dim is\n          end if;\n \n          Base_Typ := Base_Type (Etype (Actual));\n-         Sys := Get_Dimension_System_Id (Base_Typ);\n+         System := System_Of (Base_Typ);\n \n-         if Sys /= No_Dim_Sys then\n-            Dims := Get_Dimensions (Actual);\n+         if Exists (System) then\n+            Dims := Dimensions_Of (Actual);\n             Etyp := Etype (Actual);\n \n             --  Add the string as a suffix of the value if the subtype has a\n             --  string of dimensions or if the parameter is not dimensionless.\n \n-            if Present (Dims)\n-              or else Get_Dimensions_String_Id (Etyp) /= No_String\n+            if Exists (Dims)\n+              or else Symbol_Of (Etyp) /= No_String\n             then\n                New_Par_Ass := New_List;\n \n@@ -2392,15 +2169,14 @@ package body Sem_Dim is\n                --  Check if the type of N is a subtype that has a string of\n                --  dimensions in Aspect_Dimension_String_Id_Hash_Table.\n \n-               if Get_Dimensions_String_Id (Etyp) /= No_String then\n+               if Symbol_Of (Etyp) /= No_String then\n                   Start_String;\n \n                   --  Put a space between the value and the dimension\n \n                   Store_String_Char (' ');\n-                  Store_String_Chars (Get_Dimensions_String_Id (Etyp));\n-                  New_Str_Lit :=\n-                    Make_String_Literal (Loc, End_String);\n+                  Store_String_Chars (Symbol_Of (Etyp));\n+                  New_Str_Lit := Make_String_Literal (Loc, End_String);\n \n                --  Rewrite the String_Literal of the second actual with the\n                --  new String_Id created by the routine\n@@ -2409,7 +2185,7 @@ package body Sem_Dim is\n                else\n                   New_Str_Lit :=\n                     Make_String_Literal (Loc,\n-                      From_Dimension_To_String_Id (Dims, Sys));\n+                      From_Dimension_To_String_Id (Dims, System));\n                end if;\n \n                Append (New_Str_Lit, New_Par_Ass);\n@@ -2418,7 +2194,7 @@ package body Sem_Dim is\n \n                Rewrite (N,\n                  Make_Procedure_Call_Statement (Loc,\n-                   Name => New_Copy (Name_Call),\n+                   Name                   => New_Copy (Name_Call),\n                    Parameter_Associations => New_Par_Ass));\n \n                Analyze (N);\n@@ -2436,8 +2212,8 @@ package body Sem_Dim is\n    --  dimensions Dims.\n \n    function From_Dimension_To_String_Id\n-     (Dims : Dimensions;\n-      Sys  : Dim_Sys_Id) return String_Id\n+     (Dims   : Dimension_Type;\n+      System : System_Type) return String_Id\n    is\n       Dim_Rat          : Rational;\n       First_Dim_In_Str : Boolean := True;\n@@ -2451,9 +2227,9 @@ package body Sem_Dim is\n \n       Store_String_Char (' ');\n \n-      for Dim in Dimensions'Range loop\n+      for Dim in Dimension_Type'Range loop\n          Dim_Rat := Dims (Dim);\n-         if Dim_Rat /= Zero_Rational then\n+         if Dim_Rat /= Zero then\n \n             if First_Dim_In_Str then\n                First_Dim_In_Str := False;\n@@ -2464,11 +2240,10 @@ package body Sem_Dim is\n             --  Positive dimension case\n \n             if Dim_Rat.Numerator > 0 then\n-               if Dim_Systems.Table (Sys).Symbols (Dim) = No_String then\n-                  Store_String_Chars\n-                    (Get_Name_String (Dim_Systems.Table (Sys).Names (Dim)));\n+               if System.Symbols (Dim) = No_String then\n+                  Store_String_Chars (Get_Name_String (System.Names (Dim)));\n                else\n-                  Store_String_Chars (Dim_Systems.Table (Sys).Symbols (Dim));\n+                  Store_String_Chars (System.Symbols (Dim));\n                end if;\n \n                --  Integer case\n@@ -2493,11 +2268,10 @@ package body Sem_Dim is\n             --  Negative dimension case\n \n             else\n-               if Dim_Systems.Table (Sys).Symbols (Dim) = No_String then\n-                  Store_String_Chars\n-                    (Get_Name_String (Dim_Systems.Table (Sys).Names (Dim)));\n+               if System.Symbols (Dim) = No_String then\n+                  Store_String_Chars (Get_Name_String (System.Names (Dim)));\n                else\n-                  Store_String_Chars (Dim_Systems.Table (Sys).Symbols (Dim));\n+                  Store_String_Chars (System.Symbols (Dim));\n                end if;\n \n                Store_String_Chars (\"**\");\n@@ -2524,153 +2298,112 @@ package body Sem_Dim is\n       return End_String;\n    end From_Dimension_To_String_Id;\n \n-   --------------------\n-   -- Get_Dimensions --\n-   --------------------\n-\n-   function Get_Dimensions (N : Node_Id) return Dimensions is\n-   begin\n-      return Aspect_Dimension_Hash_Table.Get (N);\n-   end Get_Dimensions;\n-\n-   ------------------------------\n-   -- Get_Dimensions_String_Id --\n-   ------------------------------\n-\n-   function Get_Dimensions_String_Id (E : Entity_Id) return String_Id is\n-   begin\n-      return Aspect_Dimension_String_Id_Hash_Table.Get (E);\n-   end Get_Dimensions_String_Id;\n-\n-   -----------------------------\n-   -- Get_Dimension_System_Id --\n-   -----------------------------\n+   ---------\n+   -- GCD --\n+   ---------\n \n-   function Get_Dimension_System_Id (E : Entity_Id) return Dim_Sys_Id is\n-      D_Sys : Dim_Sys_Id := No_Dim_Sys;\n+   function GCD (Left, Right : Whole) return Int is\n+      L : Whole;\n+      R : Whole;\n \n    begin\n-      --  Scan the Table in order to find N\n-      --  What is N??? no sign of anything called N here ???\n+      L := Left;\n+      R := Right;\n+      while R /= 0 loop\n+         L := L mod R;\n \n-      for Dim_Sys in 1 .. Dim_Systems.Last loop\n-         if Parent (E) = Dim_Systems.Table (Dim_Sys).Base_Type then\n-            D_Sys := Dim_Sys;\n+         if L = 0 then\n+            return Int (R);\n          end if;\n+\n+         R := R mod L;\n       end loop;\n \n-      return D_Sys;\n-   end Get_Dimension_System_Id;\n+      return Int (L);\n+   end GCD;\n \n    --------------------------\n-   -- Is_Dimensioned_Type --\n+   -- Has_Dimension_System --\n    --------------------------\n \n-   function Is_Dimensioned_Type (E : Entity_Id) return Boolean is\n+   function Has_Dimension_System (Typ : Entity_Id) return Boolean is\n    begin\n-      if Get_Dimension_System_Id (E) /= No_Dim_Sys then\n-         return True;\n-      else\n-         return False;\n-      end if;\n-   end Is_Dimensioned_Type;\n+      return Exists (System_Of (Typ));\n+   end Has_Dimension_System;\n+\n+   ----------------\n+   -- Is_Invalid --\n+   ----------------\n+\n+   function Is_Invalid (Position : Dimension_Position) return Boolean is\n+   begin\n+      return Position = Invalid_Position;\n+   end Is_Invalid;\n \n    ---------------------\n    -- Move_Dimensions --\n    ---------------------\n \n    procedure Move_Dimensions (From, To : Node_Id) is\n-      Dims : constant Dimensions := Get_Dimensions (From);\n+      Dims : constant Dimension_Type := Dimensions_Of (From);\n \n    begin\n       --  Copy the dimension of 'From to 'To' and remove dimension of 'From'\n \n-      if Present (Dims) then\n+      if Exists (Dims) then\n          Set_Dimensions (To, Dims);\n          Remove_Dimensions (From);\n       end if;\n    end Move_Dimensions;\n \n-   ------------------------\n-   -- Permits_Dimensions --\n-   ------------------------\n-\n-   --  Here is the list of node that permits a dimension\n-\n-   Dimensions_Permission : constant array (Node_Kind) of Boolean :=\n-     (N_Attribute_Reference       => True,\n-      N_Defining_Identifier       => True,\n-      N_Function_Call             => True,\n-      N_Identifier                => True,\n-      N_Indexed_Component         => True,\n-      N_Integer_Literal           => True,\n-\n-      N_Op_Abs                    => True,\n-      N_Op_Add                    => True,\n-      N_Op_Divide                 => True,\n-      N_Op_Expon                  => True,\n-      N_Op_Minus                  => True,\n-      N_Op_Mod                    => True,\n-      N_Op_Multiply               => True,\n-      N_Op_Plus                   => True,\n-      N_Op_Rem                    => True,\n-      N_Op_Subtract               => True,\n-\n-      N_Qualified_Expression      => True,\n-      N_Real_Literal              => True,\n-      N_Selected_Component        => True,\n-      N_Slice                     => True,\n-      N_Type_Conversion           => True,\n-      N_Unchecked_Type_Conversion => True,\n-\n-      others                      => False);\n+   ------------\n+   -- Reduce --\n+   ------------\n \n-   function Permits_Dimensions (N : Node_Id) return Boolean is\n+   function Reduce (X : Rational) return Rational is\n    begin\n-      return Dimensions_Permission (Nkind (N));\n-   end Permits_Dimensions;\n+      if X.Numerator = 0 then\n+         return Zero;\n+      end if;\n \n-   -------------\n-   -- Present --\n-   -------------\n+      declare\n+         G : constant Int := GCD (X.Numerator, X.Denominator);\n \n-   function Present (Dim : Dimensions) return Boolean is\n-   begin\n-      return Dim /= Zero_Dimensions;\n-   end Present;\n+      begin\n+         return Rational'(Numerator   => Whole (Int (X.Numerator) / G),\n+                          Denominator => Whole (Int (X.Denominator) / G));\n+      end;\n+   end Reduce;\n \n    -----------------------\n    -- Remove_Dimensions --\n    -----------------------\n \n    procedure Remove_Dimensions (N : Node_Id) is\n-      Dims : constant Dimensions := Get_Dimensions (N);\n+      Dims : constant Dimension_Type := Dimensions_Of (N);\n    begin\n-      if Present (Dims) then\n-         Aspect_Dimension_Hash_Table.Remove (N);\n+      if Exists (Dims) then\n+         Dimension_Table.Remove (N);\n       end if;\n    end Remove_Dimensions;\n \n    ------------------------------\n    -- Remove_Dimension_In_Call --\n    ------------------------------\n \n-   procedure Remove_Dimension_In_Call (N : Node_Id) is\n-      Actual  : Node_Id;\n-      Par_Ass : constant List_Id := Parameter_Associations (N);\n+   procedure Remove_Dimension_In_Call (Call : Node_Id) is\n+      Actual : Node_Id;\n \n    begin\n       if Ada_Version < Ada_2012 then\n          return;\n       end if;\n \n-      if Present (Par_Ass) then\n-         Actual := First (Par_Ass);\n-         while Present (Actual) loop\n-            Remove_Dimensions (Actual);\n-            Next (Actual);\n-         end loop;\n-      end if;\n+      Actual := First (Parameter_Associations (Call));\n+      while Present (Actual) loop\n+         Remove_Dimensions (Actual);\n+         Next (Actual);\n+      end loop;\n    end Remove_Dimension_In_Call;\n \n    -------------------------------------\n@@ -2681,16 +2414,13 @@ package body Sem_Dim is\n    --  N_Component_Declaration as part of the Analyze_Declarations routine\n    --  (see package Sem_Ch3).\n \n-   procedure Remove_Dimension_In_Declaration (D : Node_Id) is\n+   procedure Remove_Dimension_In_Declaration (Decl : Node_Id) is\n    begin\n-      if Ada_Version < Ada_2012 then\n-         return;\n-      end if;\n-\n-      if Nkind_In (D, N_Object_Declaration, N_Component_Declaration) then\n-         if Present (Expression (D)) then\n-            Remove_Dimensions (Expression (D));\n-         end if;\n+      if Ada_Version >= Ada_2012\n+        and then Nkind_In (Decl, N_Object_Declaration, N_Component_Declaration)\n+        and then Present (Expression (Decl))\n+      then\n+         Remove_Dimensions (Expression (Decl));\n       end if;\n    end Remove_Dimension_In_Declaration;\n \n@@ -2701,19 +2431,17 @@ package body Sem_Dim is\n    --  Removal of dimension in statement as part of the Analyze_Statements\n    --  routine (see package Sem_Ch5).\n \n-   procedure Remove_Dimension_In_Statement (S : Node_Id) is\n-      S_Kind : constant Node_Kind := Nkind (S);\n-\n+   procedure Remove_Dimension_In_Statement (Stmt : Node_Id) is\n    begin\n       if Ada_Version < Ada_2012 then\n          return;\n       end if;\n \n       --  Remove dimension in parameter specifications for accept statement\n \n-      if S_Kind = N_Accept_Statement then\n+      if Nkind (Stmt) = N_Accept_Statement then\n          declare\n-            Param : Node_Id := First (Parameter_Specifications (S));\n+            Param : Node_Id := First (Parameter_Specifications (Stmt));\n          begin\n             while Present (Param) loop\n                Remove_Dimensions (Param);\n@@ -2723,30 +2451,69 @@ package body Sem_Dim is\n \n       --  Remove dimension of name and expression in assignments\n \n-      elsif S_Kind = N_Assignment_Statement then\n-         Remove_Dimensions (Expression (S));\n-         Remove_Dimensions (Name (S));\n+      elsif Nkind (Stmt) = N_Assignment_Statement then\n+         Remove_Dimensions (Expression (Stmt));\n+         Remove_Dimensions (Name (Stmt));\n       end if;\n    end Remove_Dimension_In_Statement;\n \n    --------------------\n    -- Set_Dimensions --\n    --------------------\n \n-   procedure Set_Dimensions (N : Node_Id; Dims : Dimensions) is\n+   procedure Set_Dimensions (N : Node_Id; Val : Dimension_Type) is\n    begin\n-      pragma Assert (Permits_Dimensions (N));\n-      pragma Assert (Present (Dims));\n-      Aspect_Dimension_Hash_Table.Set (N, Dims);\n+      pragma Assert (OK_For_Dimension (Nkind (N)));\n+      pragma Assert (Exists (Val));\n+\n+      Dimension_Table.Set (N, Val);\n    end Set_Dimensions;\n \n-   ------------------------------\n-   -- Set_Dimensions_String_Id --\n-   ------------------------------\n+   ----------------\n+   -- Set_Symbol --\n+   ----------------\n+\n+   procedure Set_Symbol (E : Entity_Id; Val : String_Id) is\n+   begin\n+      Symbol_Table.Set (E, Val);\n+   end Set_Symbol;\n+\n+   ---------------\n+   -- Symbol_Of --\n+   ---------------\n+\n+   function Symbol_Of (E : Entity_Id) return String_Id is\n+   begin\n+      return Symbol_Table.Get (E);\n+   end Symbol_Of;\n+\n+   -----------------------\n+   -- Symbol_Table_Hash --\n+   -----------------------\n+\n+   function Symbol_Table_Hash (Key : Entity_Id) return Symbol_Table_Range is\n+   begin\n+      return Symbol_Table_Range (Key mod 511);\n+   end Symbol_Table_Hash;\n+\n+   ---------------\n+   -- System_Of --\n+   ---------------\n+\n+   function System_Of (E : Entity_Id) return System_Type is\n+      Type_Decl : constant Node_Id := Parent (E);\n \n-   procedure Set_Dimensions_String_Id (E : Entity_Id; Str : String_Id) is\n    begin\n-      Aspect_Dimension_String_Id_Hash_Table.Set (E, Str);\n-   end Set_Dimensions_String_Id;\n+      --  Scan the Table in order to find N\n+      --  What is N??? no sign of anything called N here ???\n+\n+      for Dim_Sys in 1 .. System_Table.Last loop\n+         if Type_Decl = System_Table.Table (Dim_Sys).Type_Decl then\n+            return System_Table.Table (Dim_Sys);\n+         end if;\n+      end loop;\n+\n+      return Null_System;\n+   end System_Of;\n \n end Sem_Dim;"}, {"sha": "be6a8da3f2fd9d9e7f172626bddf0296395d89c6", "filename": "gcc/ada/sem_dim.ads", "status": "modified", "additions": 54, "deletions": 49, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15954beb2b32750807397741eda32d81fcb66121/gcc%2Fada%2Fsem_dim.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15954beb2b32750807397741eda32d81fcb66121/gcc%2Fada%2Fsem_dim.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_dim.ads?ref=15954beb2b32750807397741eda32d81fcb66121", "patch": "@@ -23,17 +23,17 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n---  This new package of the GNAT compiler has been created in order to enable\n---  any user of the GNAT compiler to deal with physical issues.\n+--  This package provides support for numerical systems with dimensions. A\n+--  \"dimension\" is a compile-time property of a numerical type which represents\n+--  a relation between various quantifiers such as length, velocity, etc.\n \n---  Indeed, the user is now able to create their own dimension system and to\n---  assign a dimension, defined from the MKS system (package System.Dim_Mks)\n---  or their own dimension systems, with any item and to run operations with\n---  dimensionned entities.\n+--  Package System.Dim_Mks offers a ready-to-use system of SI base units. In\n+--  addition, the implementation of this feature offers the ability to define\n+--  an arbitrary system of units through the use of Ada 2012 aspects.\n \n---  In that case, a dimensionality checking will be performed at compile time.\n---  If no dimension has been assigned, the compiler assumes that the item is\n---  dimensionless.\n+--  Dimensionality checking is part of type analysis performed by the compiler.\n+--  It ensures that manipulation of quantified numeric values is sensible with\n+--  respect to the system of units.\n \n -----------------------------\n -- Aspect_Dimension_System --\n@@ -93,63 +93,68 @@ with Types; use Types;\n \n package Sem_Dim is\n \n-   -----------------------------\n-   -- Aspect_Dimension_System --\n-   -----------------------------\n-\n-   procedure Analyze_Aspect_Dimension_System\n+   procedure Analyze_Aspect_Dimension\n      (N    : Node_Id;\n       Id   : Node_Id;\n-      Expr : Node_Id);\n-   --  Analyzes the aggregate of Aspect_Dimension_System\n-\n-   ----------------------\n-   -- Aspect_Dimension --\n-   ----------------------\n+      Aggr : Node_Id);\n+   --  Analyze the contents of aspect Dimension. Associate the provided values\n+   --  and quantifiers with the related context N.\n+   --  ??? comment on usage of formals needed\n \n-   procedure Analyze_Aspect_Dimension\n+   procedure Analyze_Aspect_Dimension_System\n      (N    : Node_Id;\n       Id   : Node_Id;\n       Expr : Node_Id);\n-   --  Analyzes the aggregate of Aspect_Dimension and attaches the\n-   --  corresponding dimension to N.\n-\n-   -------------------------------------------\n-   -- Dimensionality checking & propagation --\n-   -------------------------------------------\n+   --  Analyze the contents of aspect Dimension_System. Extract the numerical\n+   --  type, unit name and corresponding symbol from each indivitual dimension.\n+   --  ??? comment on usage of formals needed\n \n    procedure Analyze_Dimension (N : Node_Id);\n-   --  Performs a dimension analysis and propagates dimension between nodes\n-   --  when needed.\n+   --  N may denote any of the following contexts:\n+   --    * assignment statement\n+   --    * attribute reference\n+   --    * binary operator\n+   --    * compontent declaration\n+   --    * extended return statement\n+   --    * function call\n+   --    * identifier\n+   --    * indexed component\n+   --    * object declaration\n+   --    * object renaming declaration\n+   --    * qualified expression\n+   --    * selected component\n+   --    * simple return statement\n+   --    * slice\n+   --    * subtype declaration\n+   --    * type conversion\n+   --    * unary operator\n+   --    * unchecked type conversion\n+   --  Depending on the context, ensure that all expressions and entities\n+   --  involved do not violate the rules of a system.\n \n    procedure Eval_Op_Expon_For_Dimensioned_Type\n      (N     : Node_Id;\n       B_Typ : Entity_Id);\n    --  Evaluate the Expon operator for dimensioned type with rational exponent\n+   --  ??? the above doesn't explain the purpose of this routine. why is this\n+   --  procedure needed?\n \n-   function Is_Dimensioned_Type (E : Entity_Id) return Boolean;\n-   --  Return True if the type is a dimensioned type (i.e: a type which has an\n-   --  aspect Dimension_System)\n-\n-   procedure Remove_Dimension_In_Call (N : Node_Id);\n-   --  At the end of the Expand_Call routine, remove the dimensions of every\n-   --  parameter in the call N.\n+   procedure Expand_Put_Call_With_Dimension_String (N : Node_Id);\n+   --  Determine whether N denotes a subprogram call to one of the routines\n+   --  defined in System.Dim_Float_IO or System.Dim_Integer_IO and add an\n+   --  extra actual to the call to represent the symbolic representation of\n+   --  a dimension.\n \n-   procedure Remove_Dimension_In_Declaration (D : Node_Id);\n-   --  At the end of Analyze_Declarations routine (see Sem_Ch3), removes the\n-   --  dimension of the expression for each declaration.\n+   function Has_Dimension_System (Typ : Entity_Id) return Boolean;\n+   --  Return True if type Typ has aspect Dimension_System applied to it\n \n-   procedure Remove_Dimension_In_Statement (S : Node_Id);\n-   --  At the end of the Analyze_Statements routine (see Sem_Ch5), removes the\n-   --  dimension for every statements.\n+   procedure Remove_Dimension_In_Call (Call : Node_Id);\n+   --  Remove the dimensions from all formal parameters of Call\n \n-   ------------------\n-   -- Dimension_IO --\n-   ------------------\n+   procedure Remove_Dimension_In_Declaration (Decl : Node_Id);\n+   --  Remove the dimensions from the expression of Decl\n \n-   procedure Expand_Put_Call_With_Dimension_String (N : Node_Id);\n-   --  Expansion of Put call (from package System.Dim_Float_IO and\n-   --  System.Dim_Integer_IO) for a dimensioned object in order to add the\n-   --  dimension symbols as a suffix of the numeric value.\n+   procedure Remove_Dimension_In_Statement (Stmt : Node_Id);\n+   --  Remove the dimensions associated with Stmt\n \n end Sem_Dim;"}, {"sha": "5a5ebfa6a5f73a016ca7e1499a2d6c06e3b2ec76", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15954beb2b32750807397741eda32d81fcb66121/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15954beb2b32750807397741eda32d81fcb66121/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=15954beb2b32750807397741eda32d81fcb66121", "patch": "@@ -8016,7 +8016,7 @@ package body Sem_Res is\n       --  Evaluate the exponentiation operator for dimensioned type with\n       --  rational exponent.\n \n-      if Ada_Version >= Ada_2012 and then Is_Dimensioned_Type (B_Typ) then\n+      if Ada_Version >= Ada_2012 and then Has_Dimension_System (B_Typ) then\n          Eval_Op_Expon_For_Dimensioned_Type (N, B_Typ);\n \n          --  Skip the Eval_Op_Expon if the node has already been evaluated"}]}