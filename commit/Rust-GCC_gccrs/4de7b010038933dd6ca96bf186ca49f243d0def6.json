{"sha": "4de7b010038933dd6ca96bf186ca49f243d0def6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGRlN2IwMTAwMzg5MzNkZDZjYTk2YmYxODZjYTQ5ZjI0M2QwZGVmNg==", "commit": {"author": {"name": "liuhongt", "email": "hongtao.liu@intel.com", "date": "2020-09-26T07:08:32Z"}, "committer": {"name": "liuhongt", "email": "hongtao.liu@intel.com", "date": "2020-10-22T02:28:56Z"}, "message": "Extend special_memory_constraint.\n\nFor operand with special_memory_constraint, there could be a wrapper\nfor memory_operand. Extract mem for operand for conditional judgement\nlike MEM_P, also for record_address_regs.\n\ngcc/ChangeLog:\n\n\tPR target/87767\n\t* ira-costs.c (record_operand_costs): Extract memory operand\n\tfrom recog_data.operand[i] for record_address_regs.\n\t(record_reg_classes): Extract memory operand from OP for\n\tconditional judgement MEM_P.\n\t* ira.c (ira_setup_alts): Ditto.\n\t* lra-constraints.c (extract_mem_from_operand): New function.\n\t(satisfies_memory_constraint_p): Extract memory operand from\n\tOP for decompose_mem_address, return false when there's no\n\tmemory operand inside OP.\n\t(process_alt_operands): Remove MEM_P (op) since it would be\n\tjudged in satisfies_memory_constraint_p.\n\t* recog.c (asm_operand_ok): Extract memory operand from OP for\n\tjudgement of memory_operand (OP, VOIDmode).\n\t(constrain_operands): Don't unwrapper unary operator when\n\tthere's memory operand inside.\n\t* rtl.h (extract_mem_from_operand): New decl.", "tree": {"sha": "f6564cb47f71a34dfe28aa96dfc8f3e70b5a270d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f6564cb47f71a34dfe28aa96dfc8f3e70b5a270d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4de7b010038933dd6ca96bf186ca49f243d0def6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4de7b010038933dd6ca96bf186ca49f243d0def6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4de7b010038933dd6ca96bf186ca49f243d0def6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4de7b010038933dd6ca96bf186ca49f243d0def6/comments", "author": {"login": "algebra84", "id": 22926165, "node_id": "MDQ6VXNlcjIyOTI2MTY1", "avatar_url": "https://avatars.githubusercontent.com/u/22926165?v=4", "gravatar_id": "", "url": "https://api.github.com/users/algebra84", "html_url": "https://github.com/algebra84", "followers_url": "https://api.github.com/users/algebra84/followers", "following_url": "https://api.github.com/users/algebra84/following{/other_user}", "gists_url": "https://api.github.com/users/algebra84/gists{/gist_id}", "starred_url": "https://api.github.com/users/algebra84/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/algebra84/subscriptions", "organizations_url": "https://api.github.com/users/algebra84/orgs", "repos_url": "https://api.github.com/users/algebra84/repos", "events_url": "https://api.github.com/users/algebra84/events{/privacy}", "received_events_url": "https://api.github.com/users/algebra84/received_events", "type": "User", "site_admin": false}, "committer": {"login": "algebra84", "id": 22926165, "node_id": "MDQ6VXNlcjIyOTI2MTY1", "avatar_url": "https://avatars.githubusercontent.com/u/22926165?v=4", "gravatar_id": "", "url": "https://api.github.com/users/algebra84", "html_url": "https://github.com/algebra84", "followers_url": "https://api.github.com/users/algebra84/followers", "following_url": "https://api.github.com/users/algebra84/following{/other_user}", "gists_url": "https://api.github.com/users/algebra84/gists{/gist_id}", "starred_url": "https://api.github.com/users/algebra84/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/algebra84/subscriptions", "organizations_url": "https://api.github.com/users/algebra84/orgs", "repos_url": "https://api.github.com/users/algebra84/repos", "events_url": "https://api.github.com/users/algebra84/events{/privacy}", "received_events_url": "https://api.github.com/users/algebra84/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "76835dca95ab9f3f106a0db1e6152ad0740b38b3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/76835dca95ab9f3f106a0db1e6152ad0740b38b3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/76835dca95ab9f3f106a0db1e6152ad0740b38b3"}], "stats": {"total": 50, "additions": 37, "deletions": 13}, "files": [{"sha": "aeda6588bcd8ee0959c22e7fecb10ee30a8b25ec", "filename": "gcc/ira-costs.c", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4de7b010038933dd6ca96bf186ca49f243d0def6/gcc%2Fira-costs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4de7b010038933dd6ca96bf186ca49f243d0def6/gcc%2Fira-costs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-costs.c?ref=4de7b010038933dd6ca96bf186ca49f243d0def6", "patch": "@@ -781,7 +781,8 @@ record_reg_classes (int n_alts, int n_ops, rtx *ops,\n \n \t\t    case CT_SPECIAL_MEMORY:\n \t\t      insn_allows_mem[i] = allows_mem[i] = 1;\n-\t\t      if (MEM_P (op) && constraint_satisfied_p (op, cn))\n+\t\t      if (MEM_P (extract_mem_from_operand (op))\n+\t\t\t  && constraint_satisfied_p (op, cn))\n \t\t\twin = 1;\n \t\t      break;\n \n@@ -1397,15 +1398,16 @@ record_operand_costs (rtx_insn *insn, enum reg_class *pref)\n      commutative.  */\n   for (i = 0; i < recog_data.n_operands; i++)\n     {\n+      rtx op_mem = extract_mem_from_operand (recog_data.operand[i]);\n       memcpy (op_costs[i], init_cost, struct_costs_size);\n \n       if (GET_CODE (recog_data.operand[i]) == SUBREG)\n \trecog_data.operand[i] = SUBREG_REG (recog_data.operand[i]);\n \n-      if (MEM_P (recog_data.operand[i]))\n-\trecord_address_regs (GET_MODE (recog_data.operand[i]),\n-\t\t\t     MEM_ADDR_SPACE (recog_data.operand[i]),\n-\t\t\t     XEXP (recog_data.operand[i], 0),\n+      if (MEM_P (op_mem))\n+\trecord_address_regs (GET_MODE (op_mem),\n+\t\t\t     MEM_ADDR_SPACE (op_mem),\n+\t\t\t     XEXP (op_mem, 0),\n \t\t\t     0, MEM, SCRATCH, frequency * 2);\n       else if (constraints[i][0] == 'p'\n \t       || (insn_extra_address_constraint"}, {"sha": "a61138c6e94d4dc3858dd8d978fc0dff04d8f862", "filename": "gcc/ira.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4de7b010038933dd6ca96bf186ca49f243d0def6/gcc%2Fira.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4de7b010038933dd6ca96bf186ca49f243d0def6/gcc%2Fira.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.c?ref=4de7b010038933dd6ca96bf186ca49f243d0def6", "patch": "@@ -1868,7 +1868,7 @@ ira_setup_alts (rtx_insn *insn)\n \n \t\t\tcase CT_MEMORY:\n \t\t\tcase CT_SPECIAL_MEMORY:\n-\t\t\t  if (MEM_P (op))\n+\t\t\t  if (MEM_P (extract_mem_from_operand (op)))\n \t\t\t    goto op_success;\n \t\t\t  win_p = true;\n \t\t\t  break;"}, {"sha": "b5c010d503013ad4f693de0a0f32c4fff1744fca", "filename": "gcc/lra-constraints.c", "status": "modified", "additions": 23, "deletions": 5, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4de7b010038933dd6ca96bf186ca49f243d0def6/gcc%2Flra-constraints.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4de7b010038933dd6ca96bf186ca49f243d0def6/gcc%2Flra-constraints.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-constraints.c?ref=4de7b010038933dd6ca96bf186ca49f243d0def6", "patch": "@@ -416,14 +416,34 @@ valid_address_p (rtx op, struct address_info *ad,\n   return valid_address_p (ad->mode, *ad->outer, ad->as);\n }\n \n+/* For special_memory_operand, it could be false for MEM_P (op),\n+   i.e. bcst_mem_operand in i386 backend.\n+   Extract and return real memory operand or op.  */\n+rtx\n+extract_mem_from_operand (rtx op)\n+{\n+  for (rtx x = op;; x = XEXP (x, 0))\n+    {\n+      if (MEM_P (x))\n+\treturn x;\n+      if (GET_RTX_LENGTH (GET_CODE (x)) != 1\n+\t  || GET_RTX_FORMAT (GET_CODE (x))[0] != 'e')\n+\tbreak;\n+    }\n+  return op;\n+}\n+\n /* Return true if the eliminated form of memory reference OP satisfies\n    extra (special) memory constraint CONSTRAINT.  */\n static bool\n satisfies_memory_constraint_p (rtx op, enum constraint_num constraint)\n {\n   struct address_info ad;\n+  rtx mem = extract_mem_from_operand (op);\n+  if (!MEM_P (mem))\n+    return false;\n \n-  decompose_mem_address (&ad, op);\n+  decompose_mem_address (&ad, mem);\n   address_eliminator eliminator (&ad);\n   return constraint_satisfied_p (op, constraint);\n }\n@@ -2406,8 +2426,7 @@ process_alt_operands (int only_alternative)\n \t\t      break;\n \n \t\t    case CT_MEMORY:\n-\t\t      if (MEM_P (op)\n-\t\t\t  && satisfies_memory_constraint_p (op, cn))\n+\t\t      if (satisfies_memory_constraint_p (op, cn))\n \t\t\twin = true;\n \t\t      else if (spilled_pseudo_p (op))\n \t\t\twin = true;\n@@ -2448,8 +2467,7 @@ process_alt_operands (int only_alternative)\n \t\t      break;\n \n \t\t    case CT_SPECIAL_MEMORY:\n-\t\t      if (MEM_P (op)\n-\t\t\t  && satisfies_memory_constraint_p (op, cn))\n+\t\t      if (satisfies_memory_constraint_p (op, cn))\n \t\t\twin = true;\n \t\t      else if (spilled_pseudo_p (op))\n \t\t\twin = true;"}, {"sha": "d3552ec63eb26c38817931468d8fbf7df4084470", "filename": "gcc/recog.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4de7b010038933dd6ca96bf186ca49f243d0def6/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4de7b010038933dd6ca96bf186ca49f243d0def6/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=4de7b010038933dd6ca96bf186ca49f243d0def6", "patch": "@@ -1798,7 +1798,8 @@ asm_operand_ok (rtx op, const char *constraint, const char **constraints)\n \t    case CT_MEMORY:\n \t    case CT_SPECIAL_MEMORY:\n \t      /* Every memory operand can be reloaded to fit.  */\n-\t      result = result || memory_operand (op, VOIDmode);\n+\t      result = result || memory_operand (extract_mem_from_operand (op),\n+\t\t\t\t\t\t VOIDmode);\n \t      break;\n \n \t    case CT_ADDRESS:\n@@ -2584,7 +2585,9 @@ constrain_operands (int strict, alternative_mask alternatives)\n \n \t  /* A unary operator may be accepted by the predicate, but it\n \t     is irrelevant for matching constraints.  */\n-\t  if (UNARY_P (op))\n+\t  /* For special_memory_operand, there could be a memory operand inside,\n+\t     and it would cause a mismatch for constraint_satisfied_p.  */\n+\t  if (UNARY_P (op) && op == extract_mem_from_operand (op))\n \t    op = XEXP (op, 0);\n \n \t  if (GET_CODE (op) == SUBREG)"}, {"sha": "fcec9dc6387226a4edb364cdd1f808eafbbb3e57", "filename": "gcc/rtl.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4de7b010038933dd6ca96bf186ca49f243d0def6/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4de7b010038933dd6ca96bf186ca49f243d0def6/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=4de7b010038933dd6ca96bf186ca49f243d0def6", "patch": "@@ -4324,6 +4324,7 @@ extern rtx gen_hard_reg_clobber (machine_mode, unsigned int);\n extern rtx get_reg_known_value (unsigned int);\n extern bool get_reg_known_equiv_p (unsigned int);\n extern rtx get_reg_base_value (unsigned int);\n+extern rtx extract_mem_from_operand (rtx);\n \n #ifdef STACK_REGS\n extern int stack_regs_mentioned (const_rtx insn);"}]}