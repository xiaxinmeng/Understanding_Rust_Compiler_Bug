{"sha": "350f4ea897ebddd78030dbb18e4876deac235490", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzUwZjRlYTg5N2ViZGRkNzgwMzBkYmIxOGU0ODc2ZGVhYzIzNTQ5MA==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2004-03-07T14:45:42Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2004-03-07T14:45:42Z"}, "message": "fold-const.c (fold): Rewrite optimization to transform \"foo++ == const\" into \"++foo == const+incr\".\n\n\n\t* fold-const.c (fold) <EQ_EXPR>: Rewrite optimization to transform\n\t\"foo++ == const\" into \"++foo == const+incr\".\n\n\t* gcc.c-torture/execute/20040307-1.c: New test case.\n\nFrom-SVN: r79064", "tree": {"sha": "c066b1f921c1765205dcabe6946ec95358650be6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c066b1f921c1765205dcabe6946ec95358650be6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/350f4ea897ebddd78030dbb18e4876deac235490", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/350f4ea897ebddd78030dbb18e4876deac235490", "html_url": "https://github.com/Rust-GCC/gccrs/commit/350f4ea897ebddd78030dbb18e4876deac235490", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/350f4ea897ebddd78030dbb18e4876deac235490/comments", "author": null, "committer": null, "parents": [{"sha": "688556b9a734e54128f31dc0d56b26a7f5eb766f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/688556b9a734e54128f31dc0d56b26a7f5eb766f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/688556b9a734e54128f31dc0d56b26a7f5eb766f"}], "stats": {"total": 246, "additions": 106, "deletions": 140}, "files": [{"sha": "2094b29bc1478752051cd84af1eaa33a34cdd491", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/350f4ea897ebddd78030dbb18e4876deac235490/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/350f4ea897ebddd78030dbb18e4876deac235490/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=350f4ea897ebddd78030dbb18e4876deac235490", "patch": "@@ -1,3 +1,8 @@\n+2004-03-07  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* fold-const.c (fold) <EQ_EXPR>: Rewrite optimization to transform\n+\t\"foo++ == const\" into \"++foo == const+incr\".\n+\n 2004-03-07  Richard Sandiford  <rsandifo@redhat.com>\n \n \t* config/mips/mips.c (mips_in_small_data_p): Return false if"}, {"sha": "042cd9ebc14c90ebe48f6e9749e9802a30470f83", "filename": "gcc/fold-const.c", "status": "modified", "additions": 71, "deletions": 140, "changes": 211, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/350f4ea897ebddd78030dbb18e4876deac235490/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/350f4ea897ebddd78030dbb18e4876deac235490/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=350f4ea897ebddd78030dbb18e4876deac235490", "patch": "@@ -7295,150 +7295,81 @@ fold (tree expr)\n \t    }\n \t}\n \n-      /* Convert foo++ == CONST into ++foo == CONST + INCR.\n-\t First, see if one arg is constant; find the constant arg\n-\t and the other one.  */\n-      {\n-\ttree constop = 0, varop = NULL_TREE;\n-\tint constopnum = -1;\n+      /* Convert foo++ == CONST into ++foo == CONST + INCR.  */\n+      if (TREE_CONSTANT (arg1)\n+\t  && (TREE_CODE (arg0) == POSTINCREMENT_EXPR\n+\t      || TREE_CODE (arg0) == POSTDECREMENT_EXPR)\n+\t  /* This optimization is invalid for ordered comparisons\n+\t     if CONST+INCR overflows or if foo+incr might overflow.\n+\t     This optimization is invalid for floating point due to rounding.\n+\t     For pointer types we assume overflow doesn't happen.  */\n+\t  && (POINTER_TYPE_P (TREE_TYPE (arg0))\n+\t      || (INTEGRAL_TYPE_P (TREE_TYPE (arg0))\n+\t\t  && (code == EQ_EXPR || code == NE_EXPR))))\n+\t{\n+\t  tree varop, newconst;\n \n-\tif (TREE_CONSTANT (arg1))\n-\t  constopnum = 1, constop = arg1, varop = arg0;\n-\tif (TREE_CONSTANT (arg0))\n-\t  constopnum = 0, constop = arg0, varop = arg1;\n+\t  if (TREE_CODE (arg0) == POSTINCREMENT_EXPR)\n+\t    {\n+\t      newconst = fold (build2 (PLUS_EXPR, TREE_TYPE (arg0),\n+\t\t\t\t       arg1, TREE_OPERAND (arg0, 1)));\n+\t      varop = build2 (PREINCREMENT_EXPR, TREE_TYPE (arg0),\n+\t\t\t      TREE_OPERAND (arg0, 0),\n+\t\t\t      TREE_OPERAND (arg0, 1));\n+\t    }\n+\t  else\n+\t    {\n+\t      newconst = fold (build2 (MINUS_EXPR, TREE_TYPE (arg0),\n+\t\t\t\t       arg1, TREE_OPERAND (arg0, 1)));\n+\t      varop = build2 (PREDECREMENT_EXPR, TREE_TYPE (arg0),\n+\t\t\t      TREE_OPERAND (arg0, 0),\n+\t\t\t      TREE_OPERAND (arg0, 1));\n+\t    }\n \n-\tif (constop && TREE_CODE (varop) == POSTINCREMENT_EXPR)\n-\t  {\n-\t    /* This optimization is invalid for ordered comparisons\n-\t       if CONST+INCR overflows or if foo+incr might overflow.\n-\t       This optimization is invalid for floating point due to rounding.\n-\t       For pointer types we assume overflow doesn't happen.  */\n-\t    if (POINTER_TYPE_P (TREE_TYPE (varop))\n-\t\t|| (! FLOAT_TYPE_P (TREE_TYPE (varop))\n-\t\t    && (code == EQ_EXPR || code == NE_EXPR)))\n-\t      {\n-\t\ttree newconst\n-\t\t  = fold (build (PLUS_EXPR, TREE_TYPE (varop),\n-\t\t\t\t constop, TREE_OPERAND (varop, 1)));\n-\n-\t\t/* Do not overwrite the current varop to be a preincrement,\n-\t\t   create a new node so that we won't confuse our caller who\n-\t\t   might create trees and throw them away, reusing the\n-\t\t   arguments that they passed to build.  This shows up in\n-\t\t   the THEN or ELSE parts of ?: being postincrements.  */\n-\t\tvarop = build (PREINCREMENT_EXPR, TREE_TYPE (varop),\n-\t\t\t       TREE_OPERAND (varop, 0),\n-\t\t\t       TREE_OPERAND (varop, 1));\n-\n-\t\t/* If VAROP is a reference to a bitfield, we must mask\n-\t\t   the constant by the width of the field.  */\n-\t\tif (TREE_CODE (TREE_OPERAND (varop, 0)) == COMPONENT_REF\n-\t\t    && DECL_BIT_FIELD(TREE_OPERAND\n-\t\t\t\t      (TREE_OPERAND (varop, 0), 1)))\n-\t\t  {\n-\t\t    int size\n-\t\t      = TREE_INT_CST_LOW (DECL_SIZE\n-\t\t\t\t\t  (TREE_OPERAND\n-\t\t\t\t\t   (TREE_OPERAND (varop, 0), 1)));\n-\t\t    tree mask, unsigned_type;\n-\t\t    unsigned int precision;\n-\t\t    tree folded_compare;\n-\n-\t\t    /* First check whether the comparison would come out\n-\t\t       always the same.  If we don't do that we would\n-\t\t       change the meaning with the masking.  */\n-\t\t    if (constopnum == 0)\n-\t\t      folded_compare = fold (build (code, type, constop,\n-\t\t\t\t\t\t    TREE_OPERAND (varop, 0)));\n-\t\t    else\n-\t\t      folded_compare = fold (build (code, type,\n-\t\t\t\t\t\t    TREE_OPERAND (varop, 0),\n-\t\t\t\t\t\t    constop));\n-\t\t    if (integer_zerop (folded_compare)\n-\t\t\t|| integer_onep (folded_compare))\n-\t\t      return omit_one_operand (type, folded_compare, varop);\n-\n-\t\t    unsigned_type = (*lang_hooks.types.type_for_size)(size, 1);\n-\t\t    precision = TYPE_PRECISION (unsigned_type);\n-\t\t    mask = build_int_2 (~0, ~0);\n-\t\t    TREE_TYPE (mask) = unsigned_type;\n-\t\t    force_fit_type (mask, 0);\n-\t\t    mask = const_binop (RSHIFT_EXPR, mask,\n-\t\t\t\t\tsize_int (precision - size), 0);\n-\t\t    newconst = fold (build (BIT_AND_EXPR,\n-\t\t\t\t\t    TREE_TYPE (varop), newconst,\n-\t\t\t\t\t    fold_convert (TREE_TYPE (varop),\n-\t\t\t\t\t\t\t  mask)));\n-\t\t  }\n \n-\t\tt = build (code, type,\n-\t\t\t   (constopnum == 0) ? newconst : varop,\n-\t\t\t   (constopnum == 1) ? newconst : varop);\n-\t\treturn t;\n-\t      }\n-\t  }\n-\telse if (constop && TREE_CODE (varop) == POSTDECREMENT_EXPR)\n-\t  {\n-\t    if (POINTER_TYPE_P (TREE_TYPE (varop))\n-\t\t|| (! FLOAT_TYPE_P (TREE_TYPE (varop))\n-\t\t    && (code == EQ_EXPR || code == NE_EXPR)))\n-\t      {\n-\t\ttree newconst\n-\t\t  = fold (build (MINUS_EXPR, TREE_TYPE (varop),\n-\t\t\t\t constop, TREE_OPERAND (varop, 1)));\n-\n-\t\t/* Do not overwrite the current varop to be a predecrement,\n-\t\t   create a new node so that we won't confuse our caller who\n-\t\t   might create trees and throw them away, reusing the\n-\t\t   arguments that they passed to build.  This shows up in\n-\t\t   the THEN or ELSE parts of ?: being postdecrements.  */\n-\t\tvarop = build (PREDECREMENT_EXPR, TREE_TYPE (varop),\n-\t\t\t       TREE_OPERAND (varop, 0),\n-\t\t\t       TREE_OPERAND (varop, 1));\n-\n-\t\tif (TREE_CODE (TREE_OPERAND (varop, 0)) == COMPONENT_REF\n-\t\t    && DECL_BIT_FIELD(TREE_OPERAND\n-\t\t\t\t      (TREE_OPERAND (varop, 0), 1)))\n-\t\t  {\n-\t\t    int size\n-\t\t      = TREE_INT_CST_LOW (DECL_SIZE\n-\t\t\t\t\t  (TREE_OPERAND\n-\t\t\t\t\t   (TREE_OPERAND (varop, 0), 1)));\n-\t\t    tree mask, unsigned_type;\n-\t\t    unsigned int precision;\n-\t\t    tree folded_compare;\n-\n-\t\t    if (constopnum == 0)\n-\t\t      folded_compare = fold (build (code, type, constop,\n-\t\t\t\t\t\t    TREE_OPERAND (varop, 0)));\n-\t\t    else\n-\t\t      folded_compare = fold (build (code, type,\n-\t\t\t\t\t\t    TREE_OPERAND (varop, 0),\n-\t\t\t\t\t\t    constop));\n-\t\t    if (integer_zerop (folded_compare)\n-\t\t\t|| integer_onep (folded_compare))\n-\t\t      return omit_one_operand (type, folded_compare, varop);\n-\n-\t\t    unsigned_type = (*lang_hooks.types.type_for_size)(size, 1);\n-\t\t    precision = TYPE_PRECISION (unsigned_type);\n-\t\t    mask = build_int_2 (~0, ~0);\n-\t\t    TREE_TYPE (mask) = TREE_TYPE (varop);\n-\t\t    force_fit_type (mask, 0);\n-\t\t    mask = const_binop (RSHIFT_EXPR, mask,\n-\t\t\t\t\tsize_int (precision - size), 0);\n-\t\t    newconst = fold (build (BIT_AND_EXPR,\n-\t\t\t\t\t    TREE_TYPE (varop), newconst,\n-\t\t\t\t\t    fold_convert (TREE_TYPE (varop),\n-\t\t\t\t\t\t\t  mask)));\n-\t\t  }\n+\t  /* If VAROP is a reference to a bitfield, we must mask\n+\t     the constant by the width of the field.  */\n+\t  if (TREE_CODE (TREE_OPERAND (varop, 0)) == COMPONENT_REF\n+\t      && DECL_BIT_FIELD(TREE_OPERAND (TREE_OPERAND (varop, 0), 1)))\n+\t    {\n+\t      tree fielddecl = TREE_OPERAND (TREE_OPERAND (varop, 0), 1);\n+\t      int size = TREE_INT_CST_LOW (DECL_SIZE (fielddecl));\n+\t      tree folded_compare;\n+\t      tree mask = 0;\n+\n+\t      /* First check whether the comparison would come out\n+\t\t always the same.  If we don't do that we would\n+\t\t change the meaning with the masking.  */\n+\t      folded_compare = fold (build2 (code, type,\n+\t\t\t\t\t     TREE_OPERAND (varop, 0),\n+\t\t\t\t\t     arg1));\n+\t      if (integer_zerop (folded_compare)\n+\t\t  || integer_onep (folded_compare))\n+\t\treturn omit_one_operand (type, folded_compare, varop);\n+\n+\t      if (size < HOST_BITS_PER_WIDE_INT)\n+\t\t{\n+\t\t  unsigned HOST_WIDE_INT lo = ((unsigned HOST_WIDE_INT) 1\n+\t\t\t\t\t       << size) - 1;\n+\t\t  mask = build_int_2 (lo, 0);\n+\t\t}\n+\t      else if (size < 2 * HOST_BITS_PER_WIDE_INT)\n+\t\t{\n+\t\t  HOST_WIDE_INT hi = ((HOST_WIDE_INT) 1\n+\t\t\t\t      << (size - HOST_BITS_PER_WIDE_INT)) - 1;\n+\t\t  mask = build_int_2 (~0, hi);\n+\t\t}\n+\t\t   \n+\t      if (mask)\n+\t\t{\n+\t\t  mask = fold_convert (TREE_TYPE (varop), mask);\n+\t\t  newconst = fold (build2 (BIT_AND_EXPR, TREE_TYPE (varop),\n+\t\t\t\t\t   newconst, mask));\n+\t\t}\n+\t    }\n \n-\t\tt = build (code, type,\n-\t\t\t   (constopnum == 0) ? newconst : varop,\n-\t\t\t   (constopnum == 1) ? newconst : varop);\n-\t\treturn t;\n-\t      }\n-\t  }\n-      }\n+\t  return fold (build2 (code, type, varop, newconst));\n+\t}\n \n       /* Change X >= C to X > (C - 1) and X < C to X <= (C - 1) if C > 0.\n \t This transformation affects the cases which are handled in later"}, {"sha": "99035b46e06ec94ce6cccb205150620506403a0d", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/350f4ea897ebddd78030dbb18e4876deac235490/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/350f4ea897ebddd78030dbb18e4876deac235490/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=350f4ea897ebddd78030dbb18e4876deac235490", "patch": "@@ -1,3 +1,7 @@\n+2004-03-07  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* gcc.c-torture/execute/20040307-1.c: New test case.\n+\n 2004-03-07  Richard Sandiford  <rsandifo@redhat.com>\n \n \t* gcc.dg/torture/mips-sdata-1.c: Restrict to mips*-*-elf*."}, {"sha": "33cab6c7feae17043ecb2ac30d96a22575261ce4", "filename": "gcc/testsuite/gcc.c-torture/execute/20040307-1.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/350f4ea897ebddd78030dbb18e4876deac235490/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20040307-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/350f4ea897ebddd78030dbb18e4876deac235490/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20040307-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20040307-1.c?ref=350f4ea897ebddd78030dbb18e4876deac235490", "patch": "@@ -0,0 +1,26 @@\n+int main()\n+{\n+  int b = 0;\n+\n+  struct {\n+    unsigned int bit0:1;\n+    unsigned int bit1:1;\n+    unsigned int bit2:1;\n+    unsigned int bit3:1;\n+    unsigned int bit4:1;\n+    unsigned int bit5:1;\n+    unsigned int bit6:1;\n+    unsigned int bit7:1;\n+    unsigned int ubyte:24;\n+  } sdata = {0x01};\n+\n+  while ( sdata.bit0-- > 0 ) {\n+    b++ ;\n+    if ( b > 100 ) break;\n+  }\n+\n+  if (b != 1)\n+    abort ();\n+  return 0;\n+}\n+"}]}