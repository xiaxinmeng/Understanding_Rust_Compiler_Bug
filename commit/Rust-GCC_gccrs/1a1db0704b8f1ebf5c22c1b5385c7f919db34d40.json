{"sha": "1a1db0704b8f1ebf5c22c1b5385c7f919db34d40", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWExZGIwNzA0YjhmMWViZjVjMjJjMWI1Mzg1YzdmOTE5ZGIzNGQ0MA==", "commit": {"author": {"name": "Uros Bizjak", "email": "ubizjak@gmail.com", "date": "2014-10-15T17:57:17Z"}, "committer": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2014-10-15T17:57:17Z"}, "message": "re PR go/59432 (sync/atomic FAILs on 32bit x86 systems without .cfi directives)\n\n\tPR go/59432\n\t* config/i386/sync.md (atomic_compare_and_swap<dwi>_doubleword):\n\tRemove the second alternative.\n\t(regprefix): Remove mode attribute.\n\t(atomic_compare_and_swap<mode>): Do not fixup operand 2.\n\t* config/i386/predicates.md (cmpxchg8b_pic_memory_operand): Remove.\n\n\tRevert:\n\t2013-11-05  Ian Lance Taylor  <iant@google.com>\n\n\t* config/i386/sync.md (atomic_compare_and_swap<dwi>_doubleword):\n\tIf possible, add .cfi directives to record change to bx.\n\t* config/i386/i386.c (ix86_emit_cfi): New function.\n\t* config/i386/i386-protos.h (ix86_emit_cfi): Declare.\n\nFrom-SVN: r216281", "tree": {"sha": "9a08ff29bf3aff9de93ef0f8623be649e00e2efa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9a08ff29bf3aff9de93ef0f8623be649e00e2efa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1a1db0704b8f1ebf5c22c1b5385c7f919db34d40", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a1db0704b8f1ebf5c22c1b5385c7f919db34d40", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1a1db0704b8f1ebf5c22c1b5385c7f919db34d40", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a1db0704b8f1ebf5c22c1b5385c7f919db34d40/comments", "author": {"login": "ubizjak", "id": 55479990, "node_id": "MDQ6VXNlcjU1NDc5OTkw", "avatar_url": "https://avatars.githubusercontent.com/u/55479990?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ubizjak", "html_url": "https://github.com/ubizjak", "followers_url": "https://api.github.com/users/ubizjak/followers", "following_url": "https://api.github.com/users/ubizjak/following{/other_user}", "gists_url": "https://api.github.com/users/ubizjak/gists{/gist_id}", "starred_url": "https://api.github.com/users/ubizjak/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ubizjak/subscriptions", "organizations_url": "https://api.github.com/users/ubizjak/orgs", "repos_url": "https://api.github.com/users/ubizjak/repos", "events_url": "https://api.github.com/users/ubizjak/events{/privacy}", "received_events_url": "https://api.github.com/users/ubizjak/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1cbd117475aadccc2e29b4de26aea893bbfe8aa8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1cbd117475aadccc2e29b4de26aea893bbfe8aa8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1cbd117475aadccc2e29b4de26aea893bbfe8aa8"}], "stats": {"total": 119, "additions": 28, "deletions": 91}, "files": [{"sha": "80cd255d571ec69837ceab48126c9d79831383df", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a1db0704b8f1ebf5c22c1b5385c7f919db34d40/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a1db0704b8f1ebf5c22c1b5385c7f919db34d40/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1a1db0704b8f1ebf5c22c1b5385c7f919db34d40", "patch": "@@ -1,3 +1,20 @@\n+2014-10-15  Uros Bizjak  <ubizjak@gmail.com>\n+\n+\tPR go/59432\n+\t* config/i386/sync.md (atomic_compare_and_swap<dwi>_doubleword):\n+\tRemove the second alternative.\n+\t(regprefix): Remove mode attribute.\n+\t(atomic_compare_and_swap<mode>): Do not fixup operand 2.\n+\t* config/i386/predicates.md (cmpxchg8b_pic_memory_operand): Remove.\n+\n+\tRevert:\n+\t2013-11-05  Ian Lance Taylor  <iant@google.com>\n+\n+\t* config/i386/sync.md (atomic_compare_and_swap<dwi>_doubleword):\n+\tIf possible, add .cfi directives to record change to bx.\n+\t* config/i386/i386.c (ix86_emit_cfi): New function.\n+\t* config/i386/i386-protos.h (ix86_emit_cfi): Declare.\n+\n 2014-10-15  Jan Hubicka  <hubicka@ucw.cz>\n \n \tPR lto/62026"}, {"sha": "c54bdb4cf3f7c3354aa1b67f0d350e47fd786900", "filename": "gcc/config/i386/i386-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a1db0704b8f1ebf5c22c1b5385c7f919db34d40/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a1db0704b8f1ebf5c22c1b5385c7f919db34d40/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-protos.h?ref=1a1db0704b8f1ebf5c22c1b5385c7f919db34d40", "patch": "@@ -142,7 +142,6 @@ extern void ix86_split_lshr (rtx *, rtx, enum machine_mode);\n extern rtx ix86_find_base_term (rtx);\n extern bool ix86_check_movabs (rtx, int);\n extern void ix86_split_idivmod (enum machine_mode, rtx[], bool);\n-extern bool ix86_emit_cfi ();\n \n extern rtx assign_386_stack_local (enum machine_mode, enum ix86_stack_slot);\n extern int ix86_attr_length_immediate_default (rtx_insn *, bool);"}, {"sha": "64a5c552b4ad8e998ef14e2108d76170af45b4a2", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a1db0704b8f1ebf5c22c1b5385c7f919db34d40/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a1db0704b8f1ebf5c22c1b5385c7f919db34d40/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=1a1db0704b8f1ebf5c22c1b5385c7f919db34d40", "patch": "@@ -17778,14 +17778,6 @@ ix86_split_idivmod (enum machine_mode mode, rtx operands[],\n   emit_label (end_label);\n }\n \n-/* Whether it is OK to emit CFI directives when emitting asm code.  */\n-\n-bool\n-ix86_emit_cfi ()\n-{\n-  return dwarf2out_do_cfi_asm ();\n-}\n-\n #define LEA_MAX_STALL (3)\n #define LEA_SEARCH_THRESHOLD (LEA_MAX_STALL << 1)\n "}, {"sha": "8188dbe940fa77c2d56859f5d3c5ab22c3a0938e", "filename": "gcc/config/i386/predicates.md", "status": "modified", "additions": 0, "deletions": 37, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a1db0704b8f1ebf5c22c1b5385c7f919db34d40/gcc%2Fconfig%2Fi386%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a1db0704b8f1ebf5c22c1b5385c7f919db34d40/gcc%2Fconfig%2Fi386%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fpredicates.md?ref=1a1db0704b8f1ebf5c22c1b5385c7f919db34d40", "patch": "@@ -1101,43 +1101,6 @@\n   return parts.disp != NULL_RTX;\n })\n \n-;; Return true if OP is memory operand which will need zero or\n-;; one register at most, not counting stack pointer or frame pointer.\n-(define_predicate \"cmpxchg8b_pic_memory_operand\"\n-  (match_operand 0 \"memory_operand\")\n-{\n-  struct ix86_address parts;\n-  int ok;\n-\n-  if (TARGET_64BIT || !flag_pic)\n-    return true;\n-\n-  ok = ix86_decompose_address (XEXP (op, 0), &parts);\n-  gcc_assert (ok);\n-\n-  if (parts.base && GET_CODE (parts.base) == SUBREG)\n-    parts.base = SUBREG_REG (parts.base);\n-  if (parts.index && GET_CODE (parts.index) == SUBREG)\n-    parts.index = SUBREG_REG (parts.index);\n-\n-  if (parts.base == NULL_RTX\n-      || parts.base == arg_pointer_rtx\n-      || parts.base == frame_pointer_rtx\n-      || parts.base == hard_frame_pointer_rtx\n-      || parts.base == stack_pointer_rtx)\n-    return true;\n-\n-  if (parts.index == NULL_RTX\n-      || parts.index == arg_pointer_rtx\n-      || parts.index == frame_pointer_rtx\n-      || parts.index == hard_frame_pointer_rtx\n-      || parts.index == stack_pointer_rtx)\n-    return true;\n-\n-  return false;\n-})\n-\n-\n ;; Return true if OP is memory operand that cannot be represented\n ;; by the modRM array.\n (define_predicate \"long_memory_operand\""}, {"sha": "98db523b5fab42ee9e08de478ce1bdb94cc9453d", "filename": "gcc/config/i386/sync.md", "status": "modified", "additions": 11, "deletions": 45, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a1db0704b8f1ebf5c22c1b5385c7f919db34d40/gcc%2Fconfig%2Fi386%2Fsync.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a1db0704b8f1ebf5c22c1b5385c7f919db34d40/gcc%2Fconfig%2Fi386%2Fsync.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fsync.md?ref=1a1db0704b8f1ebf5c22c1b5385c7f919db34d40", "patch": "@@ -351,10 +351,9 @@\n   else\n     {\n       enum machine_mode hmode = <CASHMODE>mode;\n-      rtx lo_o, lo_e, lo_n, hi_o, hi_e, hi_n, mem;\n+      rtx lo_o, lo_e, lo_n, hi_o, hi_e, hi_n;\n \n       lo_o = operands[1];\n-      mem  = operands[2];\n       lo_e = operands[3];\n       lo_n = operands[4];\n       hi_o = gen_highpart (hmode, lo_o);\n@@ -364,12 +363,9 @@\n       lo_e = gen_lowpart (hmode, lo_e);\n       lo_n = gen_lowpart (hmode, lo_n);\n \n-      if (!cmpxchg8b_pic_memory_operand (mem, <MODE>mode))\n- \tmem = replace_equiv_address (mem, force_reg (Pmode, XEXP (mem, 0)));\n-\n       emit_insn\n        (gen_atomic_compare_and_swap<mode>_doubleword\n-        (lo_o, hi_o, mem, lo_e, hi_e, lo_n, hi_n, operands[6]));\n+        (lo_o, hi_o, operands[2], lo_e, hi_e, lo_n, hi_n, operands[6]));\n     }\n \n   ix86_expand_setcc (operands[0], EQ, gen_rtx_REG (CCZmode, FLAGS_REG),\n@@ -398,56 +394,26 @@\n ;; That said, in order to take advantage of possible lower-subreg opts,\n ;; treat all of the integral operands in the same way.\n \n-;; Operands 5 and 6 really need to be different registers, which in\n-;; this case means op5 must not be ecx.  If op5 and op6 are the same\n-;; (like when the input is -1LL) GCC might chose to allocate op5 to ecx,\n-;; like op6.  This breaks, as the xchg will move the PIC register\n-;; contents to %ecx then --> boom.\n-\n (define_mode_attr doublemodesuffix [(SI \"8\") (DI \"16\")])\n-(define_mode_attr regprefix [(SI \"e\") (DI \"r\")])\n \n (define_insn \"atomic_compare_and_swap<dwi>_doubleword\"\n-  [(set (match_operand:DWIH 0 \"register_operand\" \"=a,a\")\n+  [(set (match_operand:DWIH 0 \"register_operand\" \"=a\")\n \t(unspec_volatile:DWIH\n-\t  [(match_operand:<DWI> 2 \"cmpxchg8b_pic_memory_operand\" \"+m,m\")\n-\t   (match_operand:DWIH 3 \"register_operand\" \"0,0\")\n-\t   (match_operand:DWIH 4 \"register_operand\" \"1,1\")\n-\t   (match_operand:DWIH 5 \"register_operand\" \"b,!*r\")\n-\t   (match_operand:DWIH 6 \"register_operand\" \"c,c\")\n+\t  [(match_operand:<DWI> 2 \"memory_operand\" \"+m\")\n+\t   (match_operand:DWIH 3 \"register_operand\" \"0\")\n+\t   (match_operand:DWIH 4 \"register_operand\" \"1\")\n+\t   (match_operand:DWIH 5 \"register_operand\" \"b\")\n+\t   (match_operand:DWIH 6 \"register_operand\" \"c\")\n \t   (match_operand:SI 7 \"const_int_operand\")]\n \t  UNSPECV_CMPXCHG))\n-   (set (match_operand:DWIH 1 \"register_operand\" \"=d,d\")\n+   (set (match_operand:DWIH 1 \"register_operand\" \"=d\")\n \t(unspec_volatile:DWIH [(const_int 0)] UNSPECV_CMPXCHG))\n    (set (match_dup 2)\n \t(unspec_volatile:<DWI> [(const_int 0)] UNSPECV_CMPXCHG))\n    (set (reg:CCZ FLAGS_REG)\n-        (unspec_volatile:CCZ [(const_int 0)] UNSPECV_CMPXCHG))\n-   (clobber (match_scratch:DWIH 8 \"=X,&5\"))]\n+        (unspec_volatile:CCZ [(const_int 0)] UNSPECV_CMPXCHG))]\n   \"TARGET_CMPXCHG<doublemodesuffix>B\"\n-{\n-  bool swap = REGNO (operands[5]) != BX_REG;\n-  const char *xchg = \"xchg{<imodesuffix>}\\t%%<regprefix>bx, %5\";\n-\n-  if (swap)\n-    {\n-      output_asm_insn (xchg, operands);\n-      if (ix86_emit_cfi ())\n-\t{\n-\t  output_asm_insn (\".cfi_remember_state\", operands);\n-\t  output_asm_insn (\".cfi_register\\t%%<regprefix>bx, %5\", operands);\n-\t}\n-    }\n-  output_asm_insn (\"lock{%;} %K7cmpxchg<doublemodesuffix>b\\t%2\", operands);\n-  if (swap)\n-    {\n-      output_asm_insn (xchg, operands);\n-      if (ix86_emit_cfi ())\n-\toutput_asm_insn (\".cfi_restore_state\", operands);\n-    }\n-\n-  return \"\";\n-})\n+  \"lock{%;} %K7cmpxchg<doublemodesuffix>b\\t%2\")\n \n ;; For operand 2 nonmemory_operand predicate is used instead of\n ;; register_operand to allow combiner to better optimize atomic"}]}