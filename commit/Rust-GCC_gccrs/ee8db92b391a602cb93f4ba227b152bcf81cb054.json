{"sha": "ee8db92b391a602cb93f4ba227b152bcf81cb054", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWU4ZGI5MmIzOTFhNjAyY2I5M2Y0YmEyMjdiMTUyYmNmODFjYjA1NA==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2004-06-19T00:17:33Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2004-06-19T00:17:33Z"}, "message": "fold-const.c (fold): Add constant folding for unordered comparison tree nodes.\n\n\n\t* fold-const.c (fold) <UNORDERED_EXPR, ORDERED_EXPR, UNLT_EXPR,\n\tUNLE_EXPR, UNGT_EXPR, UNGE_EXPR, UNEQ_EXPR, LTGT_EXPR>: Add\n\tconstant folding for unordered comparison tree nodes.  If both\n\toperands are real constants, call fold_relational_const.  If either\n\toperand is a NaN, evaluate the other for side-effects and return a\n\tconstant.  Optimize (double)float1 CMP (double)float2 into the\n\tequivalent float1 CMP float2.\n\t(nondestructive_fold_binary_to_constant) <UNORDERED_EXPR,\n\tORDERED_EXPR, UNLT_EXPR, UNLE_EXPR, UNGT_EXPR, UNGE_EXPR, UNEQ_EXPR,\n\tLTGT_EXPR>: Call fold_relational_const for constant operands.\n\t(fold_relational_const): Add support for unordered comparison tree\n\tnodes.  Don't constant fold \"ordered\" floating point comparisons\n\tagainst NaN if when flag_trapping_math is set.\n\n\t* gcc.dg/unordered-2.c: New test case.\n\t* gcc.dg/unordered-3.c: New test case.\n\nFrom-SVN: r83379", "tree": {"sha": "9819bd8cdb1d4003c3909100c418617db3fb2944", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9819bd8cdb1d4003c3909100c418617db3fb2944"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ee8db92b391a602cb93f4ba227b152bcf81cb054", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ee8db92b391a602cb93f4ba227b152bcf81cb054", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ee8db92b391a602cb93f4ba227b152bcf81cb054", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ee8db92b391a602cb93f4ba227b152bcf81cb054/comments", "author": null, "committer": null, "parents": [{"sha": "1c37e0b6e8b036fc3dce3765d195cf57919bed02", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1c37e0b6e8b036fc3dce3765d195cf57919bed02", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1c37e0b6e8b036fc3dce3765d195cf57919bed02"}], "stats": {"total": 306, "additions": 292, "deletions": 14}, "files": [{"sha": "7694596d8b5752f2225856a5e2f36036f5029e3c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee8db92b391a602cb93f4ba227b152bcf81cb054/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee8db92b391a602cb93f4ba227b152bcf81cb054/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ee8db92b391a602cb93f4ba227b152bcf81cb054", "patch": "@@ -1,3 +1,19 @@\n+2004-06-18  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* fold-const.c (fold) <UNORDERED_EXPR, ORDERED_EXPR, UNLT_EXPR,\n+\tUNLE_EXPR, UNGT_EXPR, UNGE_EXPR, UNEQ_EXPR, LTGT_EXPR>: Add\n+\tconstant folding for unordered comparison tree nodes.  If both\n+\toperands are real constants, call fold_relational_const.  If either\n+\toperand is a NaN, evaluate the other for side-effects and return a\n+\tconstant.  Optimize (double)float1 CMP (double)float2 into the\n+\tequivalent float1 CMP float2.\n+\t(nondestructive_fold_binary_to_constant) <UNORDERED_EXPR,\n+\tORDERED_EXPR, UNLT_EXPR, UNLE_EXPR, UNGT_EXPR, UNGE_EXPR, UNEQ_EXPR,\n+\tLTGT_EXPR>: Call fold_relational_const for constant operands.\n+\t(fold_relational_const): Add support for unordered comparison tree\n+\tnodes.  Don't constant fold \"ordered\" floating point comparisons\n+\tagainst NaN if when flag_trapping_math is set.\n+\n 2004-06-19  Jakub Jelinek  <jakub@redhat.com>\n \n \t* fold-const.c (build_range_check): If !in_p and recursive call"}, {"sha": "5266b000bee7c078bece1776495901688b6fcf32", "filename": "gcc/fold-const.c", "status": "modified", "additions": 141, "deletions": 14, "changes": 155, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee8db92b391a602cb93f4ba227b152bcf81cb054/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee8db92b391a602cb93f4ba227b152bcf81cb054/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=ee8db92b391a602cb93f4ba227b152bcf81cb054", "patch": "@@ -8252,6 +8252,59 @@ fold (tree expr)\n       t1 = fold_relational_const (code, type, arg0, arg1);\n       return (t1 == NULL_TREE ? t : t1);\n \n+    case UNORDERED_EXPR:\n+    case ORDERED_EXPR:\n+    case UNLT_EXPR:\n+    case UNLE_EXPR:\n+    case UNGT_EXPR:\n+    case UNGE_EXPR:\n+    case UNEQ_EXPR:\n+    case LTGT_EXPR:\n+      if (TREE_CODE (arg0) == REAL_CST && TREE_CODE (arg1) == REAL_CST)\n+\t{\n+\t  t1 = fold_relational_const (code, type, arg0, arg1);\n+\t  if (t1 != NULL_TREE)\n+\t    return t1;\n+\t}\n+\n+      /* If the first operand is NaN, the result is constant.  */\n+      if (TREE_CODE (arg0) == REAL_CST\n+\t  && REAL_VALUE_ISNAN (TREE_REAL_CST (arg0))\n+\t  && (code != LTGT_EXPR || ! flag_trapping_math))\n+\t{\n+\t  t1 = (code == ORDERED_EXPR || code == LTGT_EXPR)\n+\t       ? integer_zero_node\n+\t       : integer_one_node;\n+\t  return omit_one_operand (type, t1, arg1);\n+\t}\n+\n+      /* If the second operand is NaN, the result is constant.  */\n+      if (TREE_CODE (arg1) == REAL_CST\n+\t  && REAL_VALUE_ISNAN (TREE_REAL_CST (arg1))\n+\t  && (code != LTGT_EXPR || ! flag_trapping_math))\n+\t{\n+\t  t1 = (code == ORDERED_EXPR || code == LTGT_EXPR)\n+\t       ? integer_zero_node\n+\t       : integer_one_node;\n+\t  return omit_one_operand (type, t1, arg0);\n+\t}\n+\n+      /* Fold (double)float1 CMP (double)float2 into float1 CMP float2.  */\n+      {\n+\ttree targ0 = strip_float_extensions (arg0);\n+\ttree targ1 = strip_float_extensions (arg1);\n+\ttree newtype = TREE_TYPE (targ0);\n+\n+\tif (TYPE_PRECISION (TREE_TYPE (targ1)) > TYPE_PRECISION (newtype))\n+\t  newtype = TREE_TYPE (targ1);\n+\n+\tif (TYPE_PRECISION (newtype) < TYPE_PRECISION (TREE_TYPE (arg0)))\n+\t  return fold (build2 (code, type, fold_convert (newtype, targ0),\n+\t\t\t       fold_convert (newtype, targ1)));\n+      }\n+\n+      return t;\n+\n     case COND_EXPR:\n       /* Pedantic ANSI C says that a conditional expression is never an lvalue,\n \t so all simple results must be passed through pedantic_non_lvalue.  */\n@@ -9770,6 +9823,16 @@ nondestructive_fold_binary_to_constant (enum tree_code code, tree type,\n       if (tem)\n \treturn tem;\n \n+      /* Fall through.  */\n+\n+    case ORDERED_EXPR:\n+    case UNORDERED_EXPR:\n+    case UNLT_EXPR:\n+    case UNLE_EXPR:\n+    case UNGT_EXPR:\n+    case UNGE_EXPR:\n+    case UNEQ_EXPR:\n+    case LTGT_EXPR:\n       if (!wins)\n \treturn NULL_TREE;\n \n@@ -10075,7 +10138,82 @@ fold_relational_const (enum tree_code code, tree type, tree op0, tree op1)\n   int result, invert;\n \n   /* From here on, the only cases we handle are when the result is\n-     known to be a constant.\n+     known to be a constant.  */\n+\n+  if (TREE_CODE (op0) == REAL_CST && TREE_CODE (op1) == REAL_CST)\n+    {\n+      /* Handle the cases where either operand is a NaN.  */\n+      if (REAL_VALUE_ISNAN (TREE_REAL_CST (op0))\n+          || REAL_VALUE_ISNAN (TREE_REAL_CST (op1)))\n+\t{\n+\t  switch (code)\n+\t    {\n+\t    case EQ_EXPR:\n+\t    case ORDERED_EXPR:\n+\t      result = 0;\n+\t      break;\n+\n+\t    case NE_EXPR:\n+\t    case UNORDERED_EXPR:\n+\t    case UNLT_EXPR:\n+\t    case UNLE_EXPR:\n+\t    case UNGT_EXPR:\n+\t    case UNGE_EXPR:\n+\t    case UNEQ_EXPR:\n+              result = 1;\n+\t      break;\n+\n+\t    case LT_EXPR:\n+\t    case LE_EXPR:\n+\t    case GT_EXPR:\n+\t    case GE_EXPR:\n+\t    case LTGT_EXPR:\n+\t      if (flag_trapping_math)\n+\t\treturn NULL_TREE;\n+\t      result = 0;\n+\t      break;\n+\n+\t    default:\n+\t      abort ();\n+\t    }\n+\n+\t  return constant_boolean_node (result, type);\n+\t}\n+\n+      /* From here on we're sure there are no NaNs.  */\n+      switch (code)\n+\t{\n+\tcase ORDERED_EXPR:\n+\t  return constant_boolean_node (true, type);\n+\n+\tcase UNORDERED_EXPR:\n+\t  return constant_boolean_node (false, type);\n+\n+\tcase UNLT_EXPR:\n+\t  code = LT_EXPR;\n+\t  break;\n+\tcase UNLE_EXPR:\n+\t  code = LE_EXPR;\n+\t  break;\n+\tcase UNGT_EXPR:\n+\t  code = GT_EXPR;\n+\t  break;\n+\tcase UNGE_EXPR:\n+\t  code = GE_EXPR;\n+\t  break;\n+\tcase UNEQ_EXPR:\n+\t  code = EQ_EXPR;\n+\t  break;\n+\tcase LTGT_EXPR:\n+\t  code = NE_EXPR;\n+\t  break;\n+\n+\tdefault:\n+\t  break;\n+\t}\n+    }\n+\n+  /* From here on we only handle LT, LE, GT, GE, EQ and NE.\n \n      To compute GT, swap the arguments and do LT.\n      To compute GE, do LT and invert the result.\n@@ -10093,7 +10231,7 @@ fold_relational_const (enum tree_code code, tree type, tree op0, tree op1)\n     }\n \n   /* Note that it is safe to invert for real values here because we\n-     will check below in the one case that it matters.  */\n+     have already handled the one case that it matters.  */\n \n   invert = 0;\n   if (code == NE_EXPR || code == GE_EXPR)\n@@ -10121,18 +10259,7 @@ fold_relational_const (enum tree_code code, tree type, tree op0, tree op1)\n   /* Two real constants can be compared explicitly.  */\n   else if (TREE_CODE (op0) == REAL_CST && TREE_CODE (op1) == REAL_CST)\n     {\n-      /* If either operand is a NaN, the result is false with two\n-\t exceptions: First, an NE_EXPR is true on NaNs, but that case\n-\t is already handled correctly since we will be inverting the\n-\t result for NE_EXPR.  Second, if we had inverted a LE_EXPR\n-\t or a GE_EXPR into a LT_EXPR, we must return true so that it\n-\t will be inverted into false.  */\n-\n-      if (REAL_VALUE_ISNAN (TREE_REAL_CST (op0))\n-          || REAL_VALUE_ISNAN (TREE_REAL_CST (op1)))\n-\tresult = invert && code == LT_EXPR;\n-\n-      else if (code == EQ_EXPR)\n+      if (code == EQ_EXPR)\n \tresult = REAL_VALUES_EQUAL (TREE_REAL_CST (op0),\n \t\t\t\t    TREE_REAL_CST (op1));\n       else"}, {"sha": "362d4f92e1426bdedc90a666d7dcad35f911aa2c", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee8db92b391a602cb93f4ba227b152bcf81cb054/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee8db92b391a602cb93f4ba227b152bcf81cb054/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=ee8db92b391a602cb93f4ba227b152bcf81cb054", "patch": "@@ -1,3 +1,8 @@\n+2004-06-18  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* gcc.dg/unordered-2.c: New test case.\n+\t* gcc.dg/unordered-3.c: New test case.\n+\n 2004-06-19  David Billinghurst (David.Billinghurst@riotinto.com)\n \n \tPR other/16043"}, {"sha": "0696d37cfb40c5aeaed6af81e27a53231f83ca1c", "filename": "gcc/testsuite/gcc.dg/unordered-2.c", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee8db92b391a602cb93f4ba227b152bcf81cb054/gcc%2Ftestsuite%2Fgcc.dg%2Funordered-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee8db92b391a602cb93f4ba227b152bcf81cb054/gcc%2Ftestsuite%2Fgcc.dg%2Funordered-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Funordered-2.c?ref=ee8db92b391a602cb93f4ba227b152bcf81cb054", "patch": "@@ -0,0 +1,51 @@\n+/* { dg-do link } */\n+\n+void link_error ();\n+\n+int main()\n+{\n+  if (__builtin_isgreater(1.0,2.0) != 0)\n+    link_error ();\n+  if (__builtin_isgreater(3.0,3.0) != 0)\n+    link_error ();\n+  if (__builtin_isgreater(5.0,4.0) == 0)\n+    link_error ();\n+\n+  if (__builtin_isgreaterequal(1.0,2.0) != 0)\n+    link_error ();\n+  if (__builtin_isgreaterequal(3.0,3.0) == 0)\n+    link_error ();\n+  if (__builtin_isgreaterequal(5.0,4.0) == 0)\n+    link_error ();\n+\n+  if (__builtin_isless(1.0,2.0) == 0)\n+    link_error ();\n+  if (__builtin_isless(3.0,3.0) != 0)\n+    link_error ();\n+  if (__builtin_isless(5.0,4.0) != 0)\n+    link_error ();\n+\n+  if (__builtin_islessequal(1.0,2.0) == 0)\n+    link_error ();\n+  if (__builtin_islessequal(3.0,3.0) == 0)\n+    link_error ();\n+  if (__builtin_islessequal(5.0,4.0) != 0)\n+    link_error ();\n+\n+  if (__builtin_islessgreater(1.0,2.0) == 0)\n+    link_error ();\n+  if (__builtin_islessgreater(3.0,3.0) != 0)\n+    link_error ();\n+  if (__builtin_islessgreater(5.0,4.0) == 0)\n+    link_error ();\n+\n+  if (__builtin_isunordered(1.0,2.0) != 0)\n+    link_error ();\n+  if (__builtin_isunordered(3.0,3.0) != 0)\n+    link_error ();\n+  if (__builtin_isunordered(5.0,4.0) != 0)\n+    link_error ();\n+\n+  return 0;\n+}\n+"}, {"sha": "4a11a6d48d834caaf03cea6489e2c377fbc8cf2b", "filename": "gcc/testsuite/gcc.dg/unordered-3.c", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee8db92b391a602cb93f4ba227b152bcf81cb054/gcc%2Ftestsuite%2Fgcc.dg%2Funordered-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee8db92b391a602cb93f4ba227b152bcf81cb054/gcc%2Ftestsuite%2Fgcc.dg%2Funordered-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Funordered-3.c?ref=ee8db92b391a602cb93f4ba227b152bcf81cb054", "patch": "@@ -0,0 +1,79 @@\n+/* { dg-do link } */\n+\n+void link_error ();\n+\n+void test1()\n+{\n+  if (__builtin_isgreater(1.0,__builtin_nan(\"\")) != 0)\n+    link_error ();\n+  if (__builtin_isgreater(__builtin_nan(\"\"),1.0) != 0)\n+    link_error ();\n+\n+  if (__builtin_isgreaterequal(1.0,__builtin_nan(\"\")) != 0)\n+    link_error ();\n+  if (__builtin_isgreaterequal(__builtin_nan(\"\"),1.0) != 0)\n+    link_error ();\n+\n+  if (__builtin_isless(1.0,__builtin_nan(\"\")) != 0)\n+    link_error ();\n+  if (__builtin_isless(__builtin_nan(\"\"),1.0) != 0)\n+    link_error ();\n+\n+  if (__builtin_islessequal(1.0,__builtin_nan(\"\")) != 0)\n+    link_error ();\n+  if (__builtin_islessequal(__builtin_nan(\"\"),1.0) != 0)\n+    link_error ();\n+\n+  if (__builtin_islessgreater(1.0,__builtin_nan(\"\")) != 0)\n+    link_error ();\n+  if (__builtin_islessgreater(__builtin_nan(\"\"),1.0) != 0)\n+    link_error ();\n+\n+  if (__builtin_isunordered(1.0,__builtin_nan(\"\")) == 0)\n+    link_error ();\n+  if (__builtin_isunordered(__builtin_nan(\"\"),1.0) == 0)\n+    link_error ();\n+}\n+\n+\n+void test2(double x)\n+{\n+  if (__builtin_isgreater(x,__builtin_nan(\"\")) != 0)\n+    link_error ();\n+  if (__builtin_isgreater(__builtin_nan(\"\"),x) != 0)\n+    link_error ();\n+\n+  if (__builtin_isgreaterequal(x,__builtin_nan(\"\")) != 0)\n+    link_error ();\n+  if (__builtin_isgreaterequal(__builtin_nan(\"\"),x) != 0)\n+    link_error ();\n+\n+  if (__builtin_isless(x,__builtin_nan(\"\")) != 0)\n+    link_error ();\n+  if (__builtin_isless(__builtin_nan(\"\"),x) != 0)\n+    link_error ();\n+\n+  if (__builtin_islessequal(x,__builtin_nan(\"\")) != 0)\n+    link_error ();\n+  if (__builtin_islessequal(__builtin_nan(\"\"),x) != 0)\n+    link_error ();\n+\n+  if (__builtin_islessgreater(x,__builtin_nan(\"\")) != 0)\n+    link_error ();\n+  if (__builtin_islessgreater(__builtin_nan(\"\"),x) != 0)\n+    link_error ();\n+\n+  if (__builtin_isunordered(x,__builtin_nan(\"\")) == 0)\n+    link_error ();\n+  if (__builtin_isunordered(__builtin_nan(\"\"),x) == 0)\n+    link_error ();\n+}\n+\n+\n+int main()\n+{\n+  test1 ();\n+  test2 (1.0);\n+  return 0;\n+}\n+"}]}