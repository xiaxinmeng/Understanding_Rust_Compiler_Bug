{"sha": "a520f0b0aeb4f9f73b9b39bfb2923bd6c383ffb6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTUyMGYwYjBhZWI0ZjlmNzNiOWIzOWJmYjI5MjNiZDZjMzgzZmZiNg==", "commit": {"author": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2004-10-25T19:05:58Z"}, "committer": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2004-10-25T19:05:58Z"}, "message": "[multiple changes]\n\n\n2004-10-25  Benjamin Kosnik  <bkoz@redhat.com>\n\n\t* include/Makefile.am (tr1_headers): Add tuple.\n\t* include/Makefile.in: Regenerate.\n\n2004-10-25  Chris Jefferson  <chris@bubblescope.net>\n\n        * include/tr1/tuple: Implementation of tuple from library TR.\n\t* testsuite/tr1/6_containers/tuple/tuple_element.cc: New.\n\t* testsuite/tr1/6_containers/tuple/tuple_size.cc: New.\n\t* testsuite/tr1/6_containers/tuple/comparison_operators/comparisons.cc:\n\tNew.\n\t* testsuite/tr1/6_containers/tuple/cons/assignment.cc: New.\n\t* testsuite/tr1/6_containers/tuple/cons/big_tuples.cc: New.\n\t* testsuite/tr1/6_containers/tuple/cons/constructor.cc: New.\n\t* testsuite/tr1/6_containers/tuple/creation_functions/make_tuple.cc:\n\tNew.\n\t* testsuite/tr1/6_containers/tuple/creation_functions/tie.cc: New.\n\t* testsuite/tr1/6_containers/tuple/element_access/get.cc: New.\n\nFrom-SVN: r89548", "tree": {"sha": "11dcf52a589c71d73f2fcb6563dc837a2913025d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/11dcf52a589c71d73f2fcb6563dc837a2913025d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a520f0b0aeb4f9f73b9b39bfb2923bd6c383ffb6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a520f0b0aeb4f9f73b9b39bfb2923bd6c383ffb6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a520f0b0aeb4f9f73b9b39bfb2923bd6c383ffb6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a520f0b0aeb4f9f73b9b39bfb2923bd6c383ffb6/comments", "author": null, "committer": null, "parents": [{"sha": "08a692679fb8ff32f7d63932fd97a90b2aef4c0c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/08a692679fb8ff32f7d63932fd97a90b2aef4c0c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/08a692679fb8ff32f7d63932fd97a90b2aef4c0c"}], "stats": {"total": 2029, "additions": 2027, "deletions": 2}, "files": [{"sha": "8ef259f24cae141dee97d110612256bb82c62c5b", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a520f0b0aeb4f9f73b9b39bfb2923bd6c383ffb6/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a520f0b0aeb4f9f73b9b39bfb2923bd6c383ffb6/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=a520f0b0aeb4f9f73b9b39bfb2923bd6c383ffb6", "patch": "@@ -1,3 +1,23 @@\n+2004-10-25  Benjamin Kosnik  <bkoz@redhat.com>\n+\n+\t* include/Makefile.am (tr1_headers): Add tuple.\n+\t* include/Makefile.in: Regenerate.\n+\n+2004-10-25  Chris Jefferson  <chris@bubblescope.net>\n+\n+        * include/tr1/tuple: Implementation of tuple from library TR.\n+\t* testsuite/tr1/6_containers/tuple/tuple_element.cc: New.\n+\t* testsuite/tr1/6_containers/tuple/tuple_size.cc: New.\n+\t* testsuite/tr1/6_containers/tuple/comparison_operators/comparisons.cc:\n+\tNew.\n+\t* testsuite/tr1/6_containers/tuple/cons/assignment.cc: New.\n+\t* testsuite/tr1/6_containers/tuple/cons/big_tuples.cc: New.\n+\t* testsuite/tr1/6_containers/tuple/cons/constructor.cc: New.\n+\t* testsuite/tr1/6_containers/tuple/creation_functions/make_tuple.cc: \n+\tNew.\n+\t* testsuite/tr1/6_containers/tuple/creation_functions/tie.cc: New.\n+\t* testsuite/tr1/6_containers/tuple/element_access/get.cc: New.\n+\n 2004-10-25  Paolo Carlini  <pcarlini@suse.de>\n \t\n \t* include/bits/basic_string.h (_Rep::_M_is_safe): Move to"}, {"sha": "68e7641cbefa4841e4bc336ac7786df9a2f42613", "filename": "libstdc++-v3/include/Makefile.am", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a520f0b0aeb4f9f73b9b39bfb2923bd6c383ffb6/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a520f0b0aeb4f9f73b9b39bfb2923bd6c383ffb6/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.am?ref=a520f0b0aeb4f9f73b9b39bfb2923bd6c383ffb6", "patch": "@@ -228,7 +228,8 @@ ext_headers = \\\n tr1_srcdir = ${glibcxx_srcdir}/include/tr1\n tr1_builddir = ./tr1\n tr1_headers = \\\n-\t${tr1_srcdir}/array\n+\t${tr1_srcdir}/array \\\n+\t${tr1_srcdir}/tuple\n \n # This is the common subset of files that all three \"C\" header models use.\n c_base_srcdir = $(C_INCLUDE_DIR)"}, {"sha": "90ddb9b9704a7cd7d7c6ee73607e9f5e689939e3", "filename": "libstdc++-v3/include/Makefile.in", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a520f0b0aeb4f9f73b9b39bfb2923bd6c383ffb6/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a520f0b0aeb4f9f73b9b39bfb2923bd6c383ffb6/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.in?ref=a520f0b0aeb4f9f73b9b39bfb2923bd6c383ffb6", "patch": "@@ -445,7 +445,8 @@ ext_headers = \\\n tr1_srcdir = ${glibcxx_srcdir}/include/tr1\n tr1_builddir = ./tr1\n tr1_headers = \\\n-\t${tr1_srcdir}/array\n+\t${tr1_srcdir}/array \\\n+\t${tr1_srcdir}/tuple\n \n \n # This is the common subset of files that all three \"C\" header models use."}, {"sha": "d17135ad1538d38349892c33489fb971d8fb623d", "filename": "libstdc++-v3/include/tr1/tuple", "status": "added", "additions": 1524, "deletions": 0, "changes": 1524, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a520f0b0aeb4f9f73b9b39bfb2923bd6c383ffb6/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Ftuple", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a520f0b0aeb4f9f73b9b39bfb2923bd6c383ffb6/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Ftuple", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Ftuple?ref=a520f0b0aeb4f9f73b9b39bfb2923bd6c383ffb6", "patch": "@@ -0,0 +1,1524 @@\n+// class template tuple -*- C++ -*-\n+\n+// Copyright (C) 2004 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// Chris Jefferson <chris@bubblescope.net>\n+\n+// This header is automatically generated: see maketuple.c for details.\n+\n+#ifndef _TUPLE\n+#define _TUPLE 1\n+\n+#include<utility>\n+\n+namespace std\n+{\n+namespace tr1\n+{\n+  // An implementation specific class which is used in the tuple class\n+  // when the tuple is not maximum possible size.\n+  struct _NullClass { };\n+\n+  // Foward definition of the tuple class\n+  template<typename _T0 = _NullClass, typename _T1 = _NullClass, \n+\t   typename _T2 = _NullClass, typename _T3 = _NullClass, \n+\t   typename _T4 = _NullClass, typename _T5 = _NullClass, \n+\t   typename _T6 = _NullClass, typename _T7 = _NullClass, \n+\t   typename _T8 = _NullClass, typename _T9 = _NullClass>\n+    class tuple;\n+\n+  // Gives the type of the ith element of a given tuple type.\n+  template<int __i, typename _T>\n+    struct tuple_element;\n+\n+  template<typename _T0, typename _T1, typename _T2, typename _T3, \n+\t   typename _T4, typename _T5, typename _T6, typename _T7, \n+\t   typename _T8, typename _T9>\n+    struct tuple_element<0, tuple<_T0, _T1, _T2, _T3, _T4, _T5, _T6, \n+\t\t\t\t  _T7, _T8, _T9> >\n+    { typedef _T0 type; };\n+  \n+  template<typename _T0, typename _T1, typename _T2, typename _T3, \n+\t   typename _T4, typename _T5, typename _T6, typename _T7, \n+\t   typename _T8, typename _T9>\n+    struct tuple_element<1, tuple<_T0, _T1, _T2, _T3, _T4, _T5, _T6, \n+\t\t\t\t  _T7, _T8, _T9> >\n+    { typedef _T1 type; };\n+  \n+  template<typename _T0, typename _T1, typename _T2, typename _T3, \n+\t   typename _T4, typename _T5, typename _T6, typename _T7, \n+\t   typename _T8, typename _T9>\n+    struct tuple_element<2, tuple<_T0, _T1, _T2, _T3, _T4, _T5, _T6, \n+\t\t\t\t  _T7, _T8, _T9> >\n+    { typedef _T2 type; };\n+  \n+  template<typename _T0, typename _T1, typename _T2, typename _T3, \n+\t   typename _T4, typename _T5, typename _T6, typename _T7, \n+\t   typename _T8, typename _T9>\n+    struct tuple_element<3, tuple<_T0, _T1, _T2, _T3, _T4, _T5, _T6, \n+\t\t\t\t  _T7, _T8, _T9> >\n+    { typedef _T3 type; };\n+  \n+  template<typename _T0, typename _T1, typename _T2, typename _T3, \n+\t   typename _T4, typename _T5, typename _T6, typename _T7, \n+\t   typename _T8, typename _T9>\n+    struct tuple_element<4, tuple<_T0, _T1, _T2, _T3, _T4, _T5, _T6, \n+\t\t\t\t  _T7, _T8, _T9> > \n+    { typedef _T4 type; };\n+  \n+  template<typename _T0, typename _T1, typename _T2, typename _T3, \n+\t   typename _T4, typename _T5, typename _T6, typename _T7, \n+\t   typename _T8, typename _T9>\n+    struct tuple_element<5, tuple<_T0, _T1, _T2, _T3, _T4, _T5, _T6, \n+\t\t\t\t  _T7, _T8, _T9> >\n+    { typedef _T5 type; };\n+  \n+  template<typename _T0, typename _T1, typename _T2, typename _T3, \n+\t   typename _T4, typename _T5, typename _T6, typename _T7, \n+\t   typename _T8, typename _T9>\n+    struct tuple_element<6, tuple<_T0, _T1, _T2, _T3, _T4, _T5, _T6, \n+\t\t\t\t  _T7, _T8, _T9> >\n+    { typedef _T6 type; };\n+  \n+  template<typename _T0, typename _T1, typename _T2, typename _T3, \n+\t   typename _T4, typename _T5, typename _T6, typename _T7, \n+\t   typename _T8, typename _T9>\n+    struct tuple_element<7, tuple<_T0, _T1, _T2, _T3, _T4, _T5, _T6, \n+\t\t\t\t  _T7, _T8, _T9> >\n+    { typedef _T7 type; };\n+  \n+  template<typename _T0, typename _T1, typename _T2, typename _T3, \n+\t   typename _T4, typename _T5, typename _T6, typename _T7, \n+\t   typename _T8, typename _T9>\n+    struct tuple_element<8, tuple<_T0, _T1, _T2, _T3, _T4, _T5, _T6, \n+\t\t\t\t  _T7, _T8, _T9> >\n+    { typedef _T8 type; };\n+  \n+  template<typename _T0, typename _T1, typename _T2, typename _T3, \n+\t   typename _T4, typename _T5, typename _T6, typename _T7, \n+\t   typename _T8, typename _T9>\n+    struct tuple_element<9, tuple<_T0, _T1, _T2, _T3, _T4, _T5, _T6, \n+\t\t\t\t  _T7, _T8, _T9> >\n+   { typedef _T9 type; };\n+  \n+  // Finds the size of a given tuple type.\n+  // NB: Can't this be done via value->type conversions in the generic\n+  // tuple class, say with an enum?\n+  template<typename _T>\n+    struct tuple_size;\n+\n+  template<>\n+    struct tuple_size<tuple<_NullClass, _NullClass, _NullClass, _NullClass, \n+\t\t\t    _NullClass, _NullClass, _NullClass, _NullClass, \n+\t\t\t    _NullClass, _NullClass> >\n+    { static const int value = 0; };\n+  \n+  template<typename _T0>\n+    struct tuple_size<tuple<_T0, _NullClass, _NullClass, _NullClass, \n+\t\t\t    _NullClass, _NullClass, _NullClass, _NullClass, \n+\t\t\t    _NullClass, _NullClass> >\n+    { static const int value = 1; };\n+  \n+  template<typename _T0, typename _T1>\n+    struct tuple_size<tuple<_T0, _T1, _NullClass, _NullClass, _NullClass, \n+\t\t\t    _NullClass, _NullClass, _NullClass, _NullClass, \n+\t\t\t    _NullClass> >\n+    { static const int value = 2; };\n+  \n+  template<typename _T0, typename _T1, typename _T2>\n+    struct tuple_size<tuple<_T0, _T1, _T2, _NullClass, _NullClass, \n+\t\t\t    _NullClass, _NullClass, _NullClass, _NullClass, \n+\t\t\t    _NullClass> >\n+    { static const int value = 3; };\n+  \n+  template<typename _T0, typename _T1, typename _T2, typename _T3>\n+    struct tuple_size<tuple<_T0, _T1, _T2, _T3, _NullClass, _NullClass, \n+\t\t\t    _NullClass, _NullClass, _NullClass, _NullClass> >\n+    { static const int value = 4; };\n+  \n+  template<typename _T0, typename _T1, typename _T2, typename _T3, \n+\t   typename _T4>\n+    struct tuple_size<tuple<_T0, _T1, _T2, _T3, _T4, _NullClass, \n+\t\t\t    _NullClass, _NullClass, _NullClass, _NullClass> >\n+    { static const int value = 5; };\n+  \n+  template<typename _T0, typename _T1, typename _T2, typename _T3, \n+\t   typename _T4, typename _T5>\n+    struct tuple_size<tuple<_T0, _T1, _T2, _T3, _T4, _T5, _NullClass, \n+\t\t\t    _NullClass, _NullClass, _NullClass> >\n+    { static const int value = 6; };\n+  \n+  template<typename _T0, typename _T1, typename _T2, typename _T3, \n+\t   typename _T4, typename _T5, typename _T6>\n+    struct tuple_size<tuple<_T0, _T1, _T2, _T3, _T4, _T5, _T6, \n+\t\t\t    _NullClass, _NullClass, _NullClass> >\n+    { static const int value = 7; };\n+  \n+  template<typename _T0, typename _T1, typename _T2, typename _T3, \n+\t   typename _T4, typename _T5, typename _T6, typename _T7>\n+    struct tuple_size<tuple<_T0, _T1, _T2, _T3, _T4, _T5, _T6, _T7, \n+\t\t\t    _NullClass, _NullClass> >\n+    { static const int value = 8; };\n+  \n+  template<typename _T0, typename _T1, typename _T2, typename _T3, \n+\t   typename _T4, typename _T5, typename _T6, typename _T7, \n+\t   typename _T8>\n+    struct tuple_size<tuple<_T0, _T1, _T2, _T3, _T4, _T5, _T6, _T7, \n+\t\t\t    _T8, _NullClass> >\n+    { static const int value = 9; };\n+  \n+  template<typename _T0, typename _T1, typename _T2, typename _T3, \n+\t   typename _T4, typename _T5, typename _T6, typename _T7, \n+\t   typename _T8, typename _T9>\n+    struct tuple_size<tuple<_T0, _T1, _T2, _T3, _T4, _T5, _T6, _T7, \n+\t\t\t    _T8, _T9> >\n+    { static const int value = 10; };\n+  \n+  // Adds a const reference to a non-reference type.\n+  template<typename _T>\n+    struct __add_const_ref\n+    { typedef const _T& type; };\n+  \n+  template<typename _T>\n+    struct __add_const_ref<_T&>\n+    { typedef _T& type; };\n+  \n+  // Adds a reference to a non-reference type.\n+  template<typename _T>\n+    struct __add_ref\n+    { typedef _T& type; };\n+  \n+  template<typename _T>\n+    struct __add_ref<_T&>\n+    { typedef _T& type; };\n+  \n+  // The empty tuple.\n+  template<>\n+    class tuple<_NullClass, _NullClass, _NullClass, _NullClass, _NullClass, \n+\t\t_NullClass, _NullClass, _NullClass, _NullClass, _NullClass>\n+    {\n+    public:\n+      tuple()\n+      { }\n+      \n+      tuple(const tuple& __in)\n+      { }\n+      \n+      tuple& operator=(const tuple& __in)\n+      { return *this; }\n+    };\n+  \n+  template<typename _T0>\n+    class tuple<_T0, _NullClass, _NullClass, _NullClass, _NullClass, \n+\t\t_NullClass, _NullClass, _NullClass, _NullClass, _NullClass>\n+    {\n+      _T0 __t0;\n+\n+    public:\n+      tuple()\n+      { }\n+      \n+      explicit tuple(typename __add_const_ref<_T0>::type __in0):\n+      __t0(__in0)\n+      { }\n+      \n+    tuple(const tuple& __in):\n+      __t0(__in.__t0)\n+    { }\n+    template <typename _U0>\n+    tuple(const tuple<_U0>& __in):\n+      __t0(__in.__t0)\n+    { }\n+      \n+    tuple& operator=(const tuple& __in)\n+    {\n+      __t0=__in.__t0;\n+      return *this;\n+    }\n+      \n+    template <typename _U0>\n+    tuple&\n+    operator=(const tuple<_U0>& __in)\n+    {\n+      __t0=__in.__t0;\n+      return *this;\n+    }\n+    template<int __i, typename _U>\n+    friend class __get_helper;\n+    template<typename, typename, typename, typename, typename, typename, \n+\t     typename, typename, typename, typename>\n+    friend class tuple;\n+  };\n+  \n+  template<typename _T0, typename _T1>\n+  class tuple<_T0, _T1, _NullClass, _NullClass, _NullClass, _NullClass, \n+\t      _NullClass, _NullClass, _NullClass, _NullClass>\n+  {\n+    _T0 __t0;\n+    _T1 __t1;\n+  public:\n+    tuple()\n+    { }\n+      \n+    explicit tuple(typename __add_const_ref<_T0>::type __in0, \n+\t\t   typename __add_const_ref<_T1>::type __in1):\n+      __t0(__in0), __t1(__in1)\n+    { }\n+      \n+    tuple(const tuple& __in):\n+      __t0(__in.__t0), __t1(__in.__t1)\n+    { }\n+    template <typename _U0, typename _U1>\n+    tuple(const tuple<_U0, _U1>& __in):\n+      __t0(__in.__t0), __t1(__in.__t1)\n+    { }\n+      \n+    template<class _U1, class _U2>\n+    tuple(const std::pair<_U1, _U2>& __u): __t0(__u.first), __t1(__u.second)\n+    { }\n+      \n+    tuple& operator=(const tuple& __in)\n+    {\n+      __t0=__in.__t0;\n+      __t1=__in.__t1;\n+      return *this;\n+    }\n+      \n+    template <typename _U0, typename _U1>\n+    tuple&\n+    operator=(const tuple<_U0, _U1>& __in)\n+    {\n+      __t0=__in.__t0;\n+      __t1=__in.__t1;\n+      return *this;\n+    }\n+    template<int __i, typename _U>\n+    friend class __get_helper;\n+    template<typename, typename, typename, typename, typename, typename, \n+\t     typename, typename, typename, typename>\n+    friend class tuple;\n+  };\n+  \n+  template<typename _T0, typename _T1, typename _T2>\n+  class tuple<_T0, _T1, _T2, _NullClass, _NullClass, _NullClass, \n+\t      _NullClass, _NullClass, _NullClass, _NullClass>\n+  {\n+    _T0 __t0;\n+    _T1 __t1;\n+    _T2 __t2;\n+  public:\n+    tuple()\n+    { }\n+      \n+    explicit tuple(typename __add_const_ref<_T0>::type __in0, \n+\t\t   typename __add_const_ref<_T1>::type __in1, \n+\t\t   typename __add_const_ref<_T2>::type __in2):\n+      __t0(__in0), __t1(__in1), __t2(__in2)\n+    { }\n+      \n+    tuple(const tuple& __in):\n+      __t0(__in.__t0), __t1(__in.__t1), __t2(__in.__t2)\n+    { }\n+    template <typename _U0, typename _U1, typename _U2>\n+    tuple(const tuple<_U0, _U1, _U2>& __in):\n+      __t0(__in.__t0), __t1(__in.__t1), __t2(__in.__t2)\n+    { }\n+      \n+    tuple& operator=(const tuple& __in)\n+    {\n+      __t0=__in.__t0;\n+      __t1=__in.__t1;\n+      __t2=__in.__t2;\n+      return *this;\n+    }\n+      \n+    template <typename _U0, typename _U1, typename _U2>\n+    tuple&\n+    operator=(const tuple<_U0, _U1, _U2>& __in)\n+    {\n+      __t0=__in.__t0;\n+      __t1=__in.__t1;\n+      __t2=__in.__t2;\n+      return *this;\n+    }\n+    template<int __i, typename _U>\n+    friend class __get_helper;\n+    template<typename, typename, typename, typename, typename, typename, \n+\t     typename, typename, typename, typename>\n+    friend class tuple;\n+  };\n+  \n+  template<typename _T0, typename _T1, typename _T2, typename _T3>\n+  class tuple<_T0, _T1, _T2, _T3, _NullClass, _NullClass, _NullClass, \n+\t      _NullClass, _NullClass, _NullClass>\n+  {\n+    _T0 __t0;\n+    _T1 __t1;\n+    _T2 __t2;\n+    _T3 __t3;\n+  public:\n+    tuple()\n+    { }\n+      \n+    explicit tuple(typename __add_const_ref<_T0>::type __in0, \n+\t\t   typename __add_const_ref<_T1>::type __in1, \n+\t\t   typename __add_const_ref<_T2>::type __in2, \n+\t\t   typename __add_const_ref<_T3>::type __in3):\n+      __t0(__in0), __t1(__in1), __t2(__in2), __t3(__in3)\n+    { }\n+      \n+    tuple(const tuple& __in):\n+      __t0(__in.__t0), __t1(__in.__t1), __t2(__in.__t2), \n+      __t3(__in.__t3)\n+    { }\n+    template <typename _U0, typename _U1, typename _U2, typename _U3>\n+    tuple(const tuple<_U0, _U1, _U2, _U3>& __in):\n+      __t0(__in.__t0), __t1(__in.__t1), __t2(__in.__t2), \n+      __t3(__in.__t3)\n+    { }\n+      \n+    tuple& operator=(const tuple& __in)\n+    {\n+      __t0=__in.__t0;\n+      __t1=__in.__t1;\n+      __t2=__in.__t2;\n+      __t3=__in.__t3;\n+      return *this;\n+    }\n+      \n+    template <typename _U0, typename _U1, typename _U2, typename _U3>\n+    tuple&\n+    operator=(const tuple<_U0, _U1, _U2, _U3>& __in)\n+    {\n+      __t0=__in.__t0;\n+      __t1=__in.__t1;\n+      __t2=__in.__t2;\n+      __t3=__in.__t3;\n+      return *this;\n+    }\n+    template<int __i, typename _U>\n+    friend class __get_helper;\n+    template<typename, typename, typename, typename, typename, typename, \n+\t     typename, typename, typename, typename>\n+    friend class tuple;\n+  };\n+  \n+  template<typename _T0, typename _T1, typename _T2, typename _T3, \n+\t   typename _T4>\n+  class tuple<_T0, _T1, _T2, _T3, _T4, _NullClass, _NullClass, \n+\t      _NullClass, _NullClass, _NullClass>\n+  {\n+    _T0 __t0;\n+    _T1 __t1;\n+    _T2 __t2;\n+    _T3 __t3;\n+    _T4 __t4;\n+  public:\n+    tuple()\n+    { }\n+      \n+    explicit tuple(typename __add_const_ref<_T0>::type __in0, \n+\t\t   typename __add_const_ref<_T1>::type __in1, \n+\t\t   typename __add_const_ref<_T2>::type __in2, \n+\t\t   typename __add_const_ref<_T3>::type __in3, \n+\t\t   typename __add_const_ref<_T4>::type __in4):\n+      __t0(__in0), __t1(__in1), __t2(__in2), __t3(__in3), \n+      __t4(__in4)\n+    { }\n+      \n+    tuple(const tuple& __in):\n+      __t0(__in.__t0), __t1(__in.__t1), __t2(__in.__t2), \n+      __t3(__in.__t3), __t4(__in.__t4)\n+    { }\n+    template <typename _U0, typename _U1, typename _U2, typename _U3, \n+\t      typename _U4>\n+    tuple(const tuple<_U0, _U1, _U2, _U3, _U4>& __in):\n+      __t0(__in.__t0), __t1(__in.__t1), __t2(__in.__t2), \n+      __t3(__in.__t3), __t4(__in.__t4)\n+    { }\n+      \n+    tuple& operator=(const tuple& __in)\n+    {\n+      __t0=__in.__t0;\n+      __t1=__in.__t1;\n+      __t2=__in.__t2;\n+      __t3=__in.__t3;\n+      __t4=__in.__t4;\n+      return *this;\n+    }\n+      \n+    template <typename _U0, typename _U1, typename _U2, typename _U3, \n+\t      typename _U4>\n+    tuple&\n+    operator=(const tuple<_U0, _U1, _U2, _U3, _U4>& __in)\n+    {\n+      __t0=__in.__t0;\n+      __t1=__in.__t1;\n+      __t2=__in.__t2;\n+      __t3=__in.__t3;\n+      __t4=__in.__t4;\n+      return *this;\n+    }\n+    template<int __i, typename _U>\n+    friend class __get_helper;\n+    template<typename, typename, typename, typename, typename, typename, \n+\t     typename, typename, typename, typename>\n+    friend class tuple;\n+  };\n+  \n+  template<typename _T0, typename _T1, typename _T2, typename _T3, \n+\t   typename _T4, typename _T5>\n+  class tuple<_T0, _T1, _T2, _T3, _T4, _T5, _NullClass, _NullClass, \n+\t      _NullClass, _NullClass>\n+  {\n+    _T0 __t0;\n+    _T1 __t1;\n+    _T2 __t2;\n+    _T3 __t3;\n+    _T4 __t4;\n+    _T5 __t5;\n+  public:\n+    tuple()\n+    { }\n+      \n+    explicit tuple(typename __add_const_ref<_T0>::type __in0, \n+\t\t   typename __add_const_ref<_T1>::type __in1, \n+\t\t   typename __add_const_ref<_T2>::type __in2, \n+\t\t   typename __add_const_ref<_T3>::type __in3, \n+\t\t   typename __add_const_ref<_T4>::type __in4, \n+\t\t   typename __add_const_ref<_T5>::type __in5):\n+      __t0(__in0), __t1(__in1), __t2(__in2), __t3(__in3), \n+      __t4(__in4), __t5(__in5)\n+    { }\n+      \n+    tuple(const tuple& __in):\n+      __t0(__in.__t0), __t1(__in.__t1), __t2(__in.__t2), \n+      __t3(__in.__t3), __t4(__in.__t4), __t5(__in.__t5)\n+    { }\n+    template <typename _U0, typename _U1, typename _U2, typename _U3, \n+\t      typename _U4, typename _U5>\n+    tuple(const tuple<_U0, _U1, _U2, _U3, _U4, _U5>& __in):\n+      __t0(__in.__t0), __t1(__in.__t1), __t2(__in.__t2), \n+      __t3(__in.__t3), __t4(__in.__t4), __t5(__in.__t5)\n+    { }\n+      \n+    tuple& operator=(const tuple& __in)\n+    {\n+      __t0=__in.__t0;\n+      __t1=__in.__t1;\n+      __t2=__in.__t2;\n+      __t3=__in.__t3;\n+      __t4=__in.__t4;\n+      __t5=__in.__t5;\n+      return *this;\n+    }\n+      \n+    template <typename _U0, typename _U1, typename _U2, typename _U3, \n+\t      typename _U4, typename _U5>\n+    tuple&\n+    operator=(const tuple<_U0, _U1, _U2, _U3, _U4, _U5>& __in)\n+    {\n+      __t0=__in.__t0;\n+      __t1=__in.__t1;\n+      __t2=__in.__t2;\n+      __t3=__in.__t3;\n+      __t4=__in.__t4;\n+      __t5=__in.__t5;\n+      return *this;\n+    }\n+    template<int __i, typename _U>\n+    friend class __get_helper;\n+    template<typename, typename, typename, typename, typename, typename, \n+\t     typename, typename, typename, typename>\n+    friend class tuple;\n+  };\n+  \n+  template<typename _T0, typename _T1, typename _T2, typename _T3, \n+\t   typename _T4, typename _T5, typename _T6>\n+  class tuple<_T0, _T1, _T2, _T3, _T4, _T5, _T6, _NullClass, \n+\t      _NullClass, _NullClass>\n+  {\n+    _T0 __t0;\n+    _T1 __t1;\n+    _T2 __t2;\n+    _T3 __t3;\n+    _T4 __t4;\n+    _T5 __t5;\n+    _T6 __t6;\n+  public:\n+    tuple()\n+    { }\n+      \n+    explicit tuple(typename __add_const_ref<_T0>::type __in0, \n+\t\t   typename __add_const_ref<_T1>::type __in1, \n+\t\t   typename __add_const_ref<_T2>::type __in2, \n+\t\t   typename __add_const_ref<_T3>::type __in3, \n+\t\t   typename __add_const_ref<_T4>::type __in4, \n+\t\t   typename __add_const_ref<_T5>::type __in5, \n+\t\t   typename __add_const_ref<_T6>::type __in6):\n+      __t0(__in0), __t1(__in1), __t2(__in2), __t3(__in3), \n+      __t4(__in4), __t5(__in5), __t6(__in6)\n+    { }\n+      \n+    tuple(const tuple& __in):\n+      __t0(__in.__t0), __t1(__in.__t1), __t2(__in.__t2), \n+      __t3(__in.__t3), __t4(__in.__t4), __t5(__in.__t5), \n+      __t6(__in.__t6)\n+    { }\n+    template <typename _U0, typename _U1, typename _U2, typename _U3, \n+\t      typename _U4, typename _U5, typename _U6>\n+    tuple(const tuple<_U0, _U1, _U2, _U3, _U4, _U5, _U6>& __in):\n+      __t0(__in.__t0), __t1(__in.__t1), __t2(__in.__t2), \n+      __t3(__in.__t3), __t4(__in.__t4), __t5(__in.__t5), \n+      __t6(__in.__t6)\n+    { }\n+      \n+    tuple& operator=(const tuple& __in)\n+    {\n+      __t0=__in.__t0;\n+      __t1=__in.__t1;\n+      __t2=__in.__t2;\n+      __t3=__in.__t3;\n+      __t4=__in.__t4;\n+      __t5=__in.__t5;\n+      __t6=__in.__t6;\n+      return *this;\n+    }\n+      \n+    template <typename _U0, typename _U1, typename _U2, typename _U3, \n+\t      typename _U4, typename _U5, typename _U6>\n+    tuple&\n+    operator=(const tuple<_U0, _U1, _U2, _U3, _U4, _U5, _U6>& __in)\n+    {\n+      __t0=__in.__t0;\n+      __t1=__in.__t1;\n+      __t2=__in.__t2;\n+      __t3=__in.__t3;\n+      __t4=__in.__t4;\n+      __t5=__in.__t5;\n+      __t6=__in.__t6;\n+      return *this;\n+    }\n+    template<int __i, typename _U>\n+    friend class __get_helper;\n+    template<typename, typename, typename, typename, typename, typename, \n+\t     typename, typename, typename, typename>\n+    friend class tuple;\n+  };\n+  \n+  template<typename _T0, typename _T1, typename _T2, typename _T3, \n+\t   typename _T4, typename _T5, typename _T6, typename _T7>\n+  class tuple<_T0, _T1, _T2, _T3, _T4, _T5, _T6, _T7, _NullClass, \n+\t      _NullClass>\n+  {\n+    _T0 __t0;\n+    _T1 __t1;\n+    _T2 __t2;\n+    _T3 __t3;\n+    _T4 __t4;\n+    _T5 __t5;\n+    _T6 __t6;\n+    _T7 __t7;\n+  public:\n+    tuple()\n+    { }\n+      \n+    explicit tuple(typename __add_const_ref<_T0>::type __in0, \n+\t\t   typename __add_const_ref<_T1>::type __in1, \n+\t\t   typename __add_const_ref<_T2>::type __in2, \n+\t\t   typename __add_const_ref<_T3>::type __in3, \n+\t\t   typename __add_const_ref<_T4>::type __in4, \n+\t\t   typename __add_const_ref<_T5>::type __in5, \n+\t\t   typename __add_const_ref<_T6>::type __in6, \n+\t\t   typename __add_const_ref<_T7>::type __in7):\n+      __t0(__in0), __t1(__in1), __t2(__in2), __t3(__in3), \n+      __t4(__in4), __t5(__in5), __t6(__in6), __t7(__in7)\n+    { }\n+      \n+    tuple(const tuple& __in):\n+      __t0(__in.__t0), __t1(__in.__t1), __t2(__in.__t2), \n+      __t3(__in.__t3), __t4(__in.__t4), __t5(__in.__t5), \n+      __t6(__in.__t6), __t7(__in.__t7)\n+    { }\n+    template <typename _U0, typename _U1, typename _U2, typename _U3, \n+\t      typename _U4, typename _U5, typename _U6, typename _U7>\n+    tuple(const tuple<_U0, _U1, _U2, _U3, _U4, _U5, _U6, _U7\n+\t  >& __in):\n+      __t0(__in.__t0), __t1(__in.__t1), __t2(__in.__t2), \n+      __t3(__in.__t3), __t4(__in.__t4), __t5(__in.__t5), \n+      __t6(__in.__t6), __t7(__in.__t7)\n+    { }\n+      \n+    tuple& operator=(const tuple& __in)\n+    {\n+      __t0=__in.__t0;\n+      __t1=__in.__t1;\n+      __t2=__in.__t2;\n+      __t3=__in.__t3;\n+      __t4=__in.__t4;\n+      __t5=__in.__t5;\n+      __t6=__in.__t6;\n+      __t7=__in.__t7;\n+      return *this;\n+    }\n+      \n+    template <typename _U0, typename _U1, typename _U2, typename _U3, \n+\t      typename _U4, typename _U5, typename _U6, typename _U7>\n+    tuple&\n+    operator=(const tuple<_U0, _U1, _U2, _U3, _U4, _U5, _U6, _U7\n+\t      >& __in)\n+    {\n+      __t0=__in.__t0;\n+      __t1=__in.__t1;\n+      __t2=__in.__t2;\n+      __t3=__in.__t3;\n+      __t4=__in.__t4;\n+      __t5=__in.__t5;\n+      __t6=__in.__t6;\n+      __t7=__in.__t7;\n+      return *this;\n+    }\n+    template<int __i, typename _U>\n+    friend class __get_helper;\n+    template<typename, typename, typename, typename, typename, typename, \n+\t     typename, typename, typename, typename>\n+    friend class tuple;\n+  };\n+  \n+  template<typename _T0, typename _T1, typename _T2, typename _T3, \n+\t   typename _T4, typename _T5, typename _T6, typename _T7, \n+\t   typename _T8>\n+  class tuple<_T0, _T1, _T2, _T3, _T4, _T5, _T6, _T7, _T8, \n+\t      _NullClass>\n+  {\n+    _T0 __t0;\n+    _T1 __t1;\n+    _T2 __t2;\n+    _T3 __t3;\n+    _T4 __t4;\n+    _T5 __t5;\n+    _T6 __t6;\n+    _T7 __t7;\n+    _T8 __t8;\n+  public:\n+    tuple()\n+    { }\n+      \n+    explicit tuple(typename __add_const_ref<_T0>::type __in0, \n+\t\t   typename __add_const_ref<_T1>::type __in1, \n+\t\t   typename __add_const_ref<_T2>::type __in2, \n+\t\t   typename __add_const_ref<_T3>::type __in3, \n+\t\t   typename __add_const_ref<_T4>::type __in4, \n+\t\t   typename __add_const_ref<_T5>::type __in5, \n+\t\t   typename __add_const_ref<_T6>::type __in6, \n+\t\t   typename __add_const_ref<_T7>::type __in7, \n+\t\t   typename __add_const_ref<_T8>::type __in8):\n+      __t0(__in0), __t1(__in1), __t2(__in2), __t3(__in3), \n+      __t4(__in4), __t5(__in5), __t6(__in6), __t7(__in7), \n+      __t8(__in8)\n+    { }\n+      \n+    tuple(const tuple& __in):\n+      __t0(__in.__t0), __t1(__in.__t1), __t2(__in.__t2), \n+      __t3(__in.__t3), __t4(__in.__t4), __t5(__in.__t5), \n+      __t6(__in.__t6), __t7(__in.__t7), __t8(__in.__t8)\n+    { }\n+    template <typename _U0, typename _U1, typename _U2, typename _U3, \n+\t      typename _U4, typename _U5, typename _U6, typename _U7, \n+\t      typename _U8>\n+    tuple(const tuple<_U0, _U1, _U2, _U3, _U4, _U5, _U6, _U7, _U8\n+\t  >& __in):\n+      __t0(__in.__t0), __t1(__in.__t1), __t2(__in.__t2), \n+      __t3(__in.__t3), __t4(__in.__t4), __t5(__in.__t5), \n+      __t6(__in.__t6), __t7(__in.__t7), __t8(__in.__t8)\n+    { }\n+      \n+    tuple& operator=(const tuple& __in)\n+    {\n+      __t0=__in.__t0;\n+      __t1=__in.__t1;\n+      __t2=__in.__t2;\n+      __t3=__in.__t3;\n+      __t4=__in.__t4;\n+      __t5=__in.__t5;\n+      __t6=__in.__t6;\n+      __t7=__in.__t7;\n+      __t8=__in.__t8;\n+      return *this;\n+    }\n+      \n+    template <typename _U0, typename _U1, typename _U2, typename _U3, \n+\t      typename _U4, typename _U5, typename _U6, typename _U7, \n+\t      typename _U8>\n+    tuple&\n+    operator=(const tuple<_U0, _U1, _U2, _U3, _U4, _U5, _U6, _U7, \n+\t      _U8>& __in)\n+    {\n+      __t0=__in.__t0;\n+      __t1=__in.__t1;\n+      __t2=__in.__t2;\n+      __t3=__in.__t3;\n+      __t4=__in.__t4;\n+      __t5=__in.__t5;\n+      __t6=__in.__t6;\n+      __t7=__in.__t7;\n+      __t8=__in.__t8;\n+      return *this;\n+    }\n+    template<int __i, typename _U>\n+    friend class __get_helper;\n+    template<typename, typename, typename, typename, typename, typename, \n+\t     typename, typename, typename, typename>\n+    friend class tuple;\n+  };\n+  \n+  template<typename _T0, typename _T1, typename _T2, typename _T3, \n+\t   typename _T4, typename _T5, typename _T6, typename _T7, \n+\t   typename _T8, typename _T9>\n+  class tuple\n+  {\n+    _T0 __t0;\n+    _T1 __t1;\n+    _T2 __t2;\n+    _T3 __t3;\n+    _T4 __t4;\n+    _T5 __t5;\n+    _T6 __t6;\n+    _T7 __t7;\n+    _T8 __t8;\n+    _T9 __t9;\n+  public:\n+    tuple()\n+    { }\n+      \n+    explicit tuple(typename __add_const_ref<_T0>::type __in0, \n+\t\t   typename __add_const_ref<_T1>::type __in1, \n+\t\t   typename __add_const_ref<_T2>::type __in2, \n+\t\t   typename __add_const_ref<_T3>::type __in3, \n+\t\t   typename __add_const_ref<_T4>::type __in4, \n+\t\t   typename __add_const_ref<_T5>::type __in5, \n+\t\t   typename __add_const_ref<_T6>::type __in6, \n+\t\t   typename __add_const_ref<_T7>::type __in7, \n+\t\t   typename __add_const_ref<_T8>::type __in8, \n+\t\t   typename __add_const_ref<_T9>::type __in9):\n+      __t0(__in0), __t1(__in1), __t2(__in2), __t3(__in3), \n+      __t4(__in4), __t5(__in5), __t6(__in6), __t7(__in7), \n+      __t8(__in8), __t9(__in9)\n+    { }\n+      \n+    tuple(const tuple& __in):\n+      __t0(__in.__t0), __t1(__in.__t1), __t2(__in.__t2), \n+      __t3(__in.__t3), __t4(__in.__t4), __t5(__in.__t5), \n+      __t6(__in.__t6), __t7(__in.__t7), __t8(__in.__t8), \n+      __t9(__in.__t9)\n+    { }\n+    template <typename _U0, typename _U1, typename _U2, typename _U3, \n+\t      typename _U4, typename _U5, typename _U6, typename _U7, \n+\t      typename _U8, typename _U9>\n+    tuple(const tuple<_U0, _U1, _U2, _U3, _U4, _U5, _U6, _U7, _U8, \n+\t  _U9>& __in):\n+      __t0(__in.__t0), __t1(__in.__t1), __t2(__in.__t2), \n+      __t3(__in.__t3), __t4(__in.__t4), __t5(__in.__t5), \n+      __t6(__in.__t6), __t7(__in.__t7), __t8(__in.__t8), \n+      __t9(__in.__t9)\n+    { }\n+      \n+    tuple& operator=(const tuple& __in)\n+    {\n+      __t0=__in.__t0;\n+      __t1=__in.__t1;\n+      __t2=__in.__t2;\n+      __t3=__in.__t3;\n+      __t4=__in.__t4;\n+      __t5=__in.__t5;\n+      __t6=__in.__t6;\n+      __t7=__in.__t7;\n+      __t8=__in.__t8;\n+      __t9=__in.__t9;\n+      return *this;\n+    }\n+      \n+    template <typename _U0, typename _U1, typename _U2, typename _U3, \n+\t      typename _U4, typename _U5, typename _U6, typename _U7, \n+\t      typename _U8, typename _U9>\n+    tuple&\n+    operator=(const tuple<_U0, _U1, _U2, _U3, _U4, _U5, _U6, _U7, \n+\t      _U8, _U9>& __in)\n+    {\n+      __t0=__in.__t0;\n+      __t1=__in.__t1;\n+      __t2=__in.__t2;\n+      __t3=__in.__t3;\n+      __t4=__in.__t4;\n+      __t5=__in.__t5;\n+      __t6=__in.__t6;\n+      __t7=__in.__t7;\n+      __t8=__in.__t8;\n+      __t9=__in.__t9;\n+      return *this;\n+    }\n+    template<int __i, typename _U>\n+    friend class __get_helper;\n+    template<typename, typename, typename, typename, typename, typename, \n+\t     typename, typename, typename, typename>\n+    friend class tuple;\n+  };\n+  \n+  // Class used in the implementation of get\n+  template<int __i, typename _T>\n+    struct __get_helper;\n+\n+  template<typename _T>\n+    struct __get_helper<0, _T>\n+    {\n+      static typename __add_ref<typename tuple_element<0, _T>::type>::type\n+      get_value(_T& __in) \n+      { return __in.__t0; }\n+\n+      static typename __add_const_ref<typename tuple_element<0, _T>::type>::type\n+      get_value(const _T& __in)\n+      { return __in.__t0; }\n+    };\n+  \n+  template<typename _T>\n+  struct __get_helper<1, _T>\n+  {\n+    static typename __add_ref<typename tuple_element<1, _T>::type>::type\n+    get_value(_T& __in)\n+    {\n+      return __in.__t1;\n+    }\n+    static typename __add_const_ref<typename tuple_element<1, _T>::type>::type\n+    get_value(const _T& __in)\n+    {\n+      return __in.__t1;\n+    }\n+  };\n+  \n+  template<typename _T>\n+  struct __get_helper<2, _T>\n+  {\n+    static typename __add_ref<typename tuple_element<2, _T>::type>::type\n+    get_value(_T& __in)\n+    {\n+      return __in.__t2;\n+    }\n+    static typename __add_const_ref<typename tuple_element<2, _T>::type>::type\n+    get_value(const _T& __in)\n+    {\n+      return __in.__t2;\n+    }\n+  };\n+  \n+  template<typename _T>\n+  struct __get_helper<3, _T>\n+  {\n+    static typename __add_ref<typename tuple_element<3, _T>::type>::type\n+    get_value(_T& __in)\n+    {\n+      return __in.__t3;\n+    }\n+    static typename __add_const_ref<typename tuple_element<3, _T>::type>::type\n+    get_value(const _T& __in)\n+    {\n+      return __in.__t3;\n+    }\n+  };\n+  \n+  template<typename _T>\n+  struct __get_helper<4, _T>\n+  {\n+    static typename __add_ref<typename tuple_element<4, _T>::type>::type\n+    get_value(_T& __in)\n+    {\n+      return __in.__t4;\n+    }\n+    static typename __add_const_ref<typename tuple_element<4, _T>::type>::type\n+    get_value(const _T& __in)\n+    {\n+      return __in.__t4;\n+    }\n+  };\n+  \n+  template<typename _T>\n+  struct __get_helper<5, _T>\n+  {\n+    static typename __add_ref<typename tuple_element<5, _T>::type>::type\n+    get_value(_T& __in)\n+    {\n+      return __in.__t5;\n+    }\n+    static typename __add_const_ref<typename tuple_element<5, _T>::type>::type\n+    get_value(const _T& __in)\n+    {\n+      return __in.__t5;\n+    }\n+  };\n+  \n+  template<typename _T>\n+  struct __get_helper<6, _T>\n+  {\n+    static typename __add_ref<typename tuple_element<6, _T>::type>::type\n+    get_value(_T& __in)\n+    {\n+      return __in.__t6;\n+    }\n+    static typename __add_const_ref<typename tuple_element<6, _T>::type>::type\n+    get_value(const _T& __in)\n+    {\n+      return __in.__t6;\n+    }\n+  };\n+  \n+  template<typename _T>\n+  struct __get_helper<7, _T>\n+  {\n+    static typename __add_ref<typename tuple_element<7, _T>::type>::type\n+    get_value(_T& __in)\n+    {\n+      return __in.__t7;\n+    }\n+    static typename __add_const_ref<typename tuple_element<7, _T>::type>::type\n+    get_value(const _T& __in)\n+    {\n+      return __in.__t7;\n+    }\n+  };\n+  \n+  template<typename _T>\n+  struct __get_helper<8, _T>\n+  {\n+    static typename __add_ref<typename tuple_element<8, _T>::type>::type\n+    get_value(_T& __in)\n+    {\n+      return __in.__t8;\n+    }\n+    static typename __add_const_ref<typename tuple_element<8, _T>::type>::type\n+    get_value(const _T& __in)\n+    {\n+      return __in.__t8;\n+    }\n+  };\n+  \n+  template<typename _T>\n+  struct __get_helper<9, _T>\n+  {\n+    static typename __add_ref<typename tuple_element<9, _T>::type>::type\n+    get_value(_T& __in)\n+    {\n+      return __in.__t9;\n+    }\n+    static typename __add_const_ref<typename tuple_element<9, _T>::type>::type\n+    get_value(const _T& __in)\n+    {\n+      return __in.__t9;\n+    }\n+  };\n+  \n+  /* Returns a reference to the ith element of a tuple.\n+   * Any const or non-const ref elements are returned with their original type\n+   */\n+  template<int __i, typename _T0, typename _T1, typename _T2, typename _T3, \n+\t   typename _T4, typename _T5, typename _T6, typename _T7, \n+\t   typename _T8, typename _T9>\n+  typename __add_ref<typename tuple_element<__i,tuple<_T0, _T1, _T2, _T3, \n+\t\t\t\t\t\t      _T4, _T5, _T6, _T7, _T8, _T9> >::type>::type\n+  get(tuple<_T0, _T1, _T2, _T3, _T4, _T5, _T6, _T7, _T8, _T9>& __t)\n+  {\n+    return __get_helper<__i,tuple<_T0, _T1, _T2, _T3, _T4, _T5, _T6, \n+      _T7, _T8, _T9> >::get_value(__t);\n+  }\n+\n+  /* Returns a const reference to the ith element of a tuple.\n+   * Any const or non-const ref elements are returned with their original type\n+   */\n+  template<int __i, typename _T0, typename _T1, typename _T2, typename _T3, \n+\t   typename _T4, typename _T5, typename _T6, typename _T7, \n+\t   typename _T8, typename _T9>\n+  typename __add_const_ref<typename tuple_element<__i,tuple<_T0, _T1, _T2, \n+\t\t\t\t\t\t\t    _T3, _T4, _T5, _T6, _T7, _T8, _T9> >::type>::type\n+  get(const tuple<_T0, _T1, _T2, _T3, _T4, _T5, _T6, _T7, _T8, _T9\n+      >& __t)\n+  {\n+    return __get_helper<__i,tuple<_T0, _T1, _T2, _T3, _T4, _T5, _T6, \n+      _T7, _T8, _T9> >::get_value(__t);\n+  }\n+\n+  // This class helps construct the various comparison operations on tuples\n+  template<int __check_equal_size, int __i, int __j, typename _T, typename _U>\n+  struct __tuple_compare;\n+\n+  template<int __i, int __j, typename _T, typename _U>\n+  struct __tuple_compare<0, __i, __j, _T, _U>\n+  {\n+    static bool __eq(const _T& __t, const _U& __u)\n+    {\n+      return get<__i>(__t) == get<__i>(__u) &&\n+\t__tuple_compare<0, __i+1, __j, _T, _U>::__eq(__t, __u) ;\n+    }\n+    static bool __neq(const _T& __t, const _U& __u)\n+    {\n+      return get<__i>(__t) != get<__i>(__u) ||\n+\t__tuple_compare<0, __i+1, __j, _T, _U>::__neq(__t, __u) ;\n+    }\n+    static bool __less(const _T& __t, const _U& __u)\n+    {\n+      return (get<__i>(__t) < get<__i>(__u)) || !(get<__i>(__u) < get<__i>(__t)) &&\n+\t__tuple_compare<0, __i+1, __j, _T, _U>::__less(__t, __u) ;\n+    }\n+    static bool __greater(const _T& __t, const _U& __u)\n+    {\n+      return (get<__i>(__t) > get<__i>(__u)) || !(get<__i>(__u) > get<__i>(__t)) &&\n+\t__tuple_compare<0, __i+1, __j, _T, _U>::__greater(__t, __u) ;\n+    }\n+    static bool __leq(const _T& __t, const _U& __u)\n+    {\n+      return (get<__i>(__t) <= get<__i>(__u)) && (!(get<__i>(__u)<=get<__i>(__t)) ||\n+\t\t\t\t\t\t  __tuple_compare<0, __i+1, __j, _T, _U>::__leq(__t, __u) );\n+    }\n+    static bool __geq(const _T& __t, const _U& __u)\n+    {\n+      return (get<__i>(__t) >= get<__i>(__u)) && (!(get<__i>(__u)>=get<__i>(__t)) ||\n+\t\t\t\t\t\t  __tuple_compare<0, __i+1, __j, _T, _U>::__geq(__t, __u) );\n+    }\n+  };\n+  \n+  template<int __i, typename _T, typename _U>\n+  struct __tuple_compare<0, __i, __i, _T, _U>\n+  {\n+    static bool __eq(const _T&, const _U&)\n+    {\n+      return true;\n+    }\n+    static bool __neq(const _T&, const _U&)\n+    {\n+      return false;\n+    }\n+    static bool __leq(const _T&, const _U&)\n+    {\n+      return true;\n+    }\n+    static bool __geq(const _T&, const _U&)\n+    {\n+      return true;\n+    }\n+    static bool __less(const _T&, const _U&)\n+    {\n+      return false;\n+    }\n+    static bool __greater(const _T&, const _U&)\n+    {\n+      return false;\n+    }\n+  };\n+\n+  template<typename _T0, typename _T1, typename _T2, typename _T3, \n+\t   typename _T4, typename _T5, typename _T6, typename _T7, \n+\t   typename _T8, typename _T9, typename _U0, typename _U1, \n+\t   typename _U2, typename _U3, typename _U4, typename _U5, \n+\t   typename _U6, typename _U7, typename _U8, typename _U9>\n+  bool\n+  operator==(const tuple<_T0, _T1, _T2, _T3, _T4, _T5, _T6, _T7, _T8, \n+\t     _T9>& __t, const tuple<_U0, _U1, _U2, _U3, _U4, _U5, _U6, \n+\t     _U7, _U8, _U9>& __u)\n+  {\n+    typedef tuple<_T0, _T1, _T2, _T3, _T4, _T5, _T6, _T7, _T8, _T9\n+      > __T_tuple;\n+    typedef tuple<_U0, _U1, _U2, _U3, _U4, _U5, _U6, _U7, _U8, _U9\n+      > __U_tuple;\n+    return __tuple_compare<tuple_size<__T_tuple>::value -\n+      tuple_size<__U_tuple>::value, 0,\n+      tuple_size<__T_tuple>::value, __T_tuple, __U_tuple>::__eq(__t, __u);\n+  }\n+\n+  template<typename _T0, typename _T1, typename _T2, typename _T3, \n+\t   typename _T4, typename _T5, typename _T6, typename _T7, \n+\t   typename _T8, typename _T9, typename _U0, typename _U1, \n+\t   typename _U2, typename _U3, typename _U4, typename _U5, \n+\t   typename _U6, typename _U7, typename _U8, typename _U9>\n+  bool\n+  operator!=(const tuple<_T0, _T1, _T2, _T3, _T4, _T5, _T6, _T7, _T8, \n+\t     _T9>& __t, const tuple<_U0, _U1, _U2, _U3, _U4, _U5, _U6, \n+\t     _U7, _U8, _U9>& __u)\n+  {\n+    typedef tuple<_T0, _T1, _T2, _T3, _T4, _T5, _T6, _T7, _T8, _T9\n+      > __T_tuple;\n+    typedef tuple<_U0, _U1, _U2, _U3, _U4, _U5, _U6, _U7, _U8, _U9\n+      > __U_tuple;\n+    return __tuple_compare<tuple_size<__T_tuple>::value -\n+      tuple_size<__U_tuple>::value, 0,\n+      tuple_size<__T_tuple>::value, __T_tuple, __U_tuple>::__neq(__t, __u);\n+  }\n+\n+  template<typename _T0, typename _T1, typename _T2, typename _T3, \n+\t   typename _T4, typename _T5, typename _T6, typename _T7, \n+\t   typename _T8, typename _T9, typename _U0, typename _U1, \n+\t   typename _U2, typename _U3, typename _U4, typename _U5, \n+\t   typename _U6, typename _U7, typename _U8, typename _U9>\n+  bool\n+  operator<(const tuple<_T0, _T1, _T2, _T3, _T4, _T5, _T6, _T7, _T8, \n+\t    _T9>& __t, const tuple<_U0, _U1, _U2, _U3, _U4, _U5, _U6, \n+\t    _U7, _U8, _U9>& __u)\n+  {\n+    typedef tuple<_T0, _T1, _T2, _T3, _T4, _T5, _T6, _T7, _T8, _T9\n+      > __T_tuple;\n+    typedef tuple<_U0, _U1, _U2, _U3, _U4, _U5, _U6, _U7, _U8, _U9\n+      > __U_tuple;\n+    return __tuple_compare<tuple_size<__T_tuple>::value -\n+      tuple_size<__U_tuple>::value, 0,\n+      tuple_size<__T_tuple>::value, __T_tuple, __U_tuple>::__less(__t, __u);\n+  }\n+\n+  template<typename _T0, typename _T1, typename _T2, typename _T3, \n+\t   typename _T4, typename _T5, typename _T6, typename _T7, \n+\t   typename _T8, typename _T9, typename _U0, typename _U1, \n+\t   typename _U2, typename _U3, typename _U4, typename _U5, \n+\t   typename _U6, typename _U7, typename _U8, typename _U9>\n+  bool\n+  operator>(const tuple<_T0, _T1, _T2, _T3, _T4, _T5, _T6, _T7, _T8, \n+\t    _T9>& __t, const tuple<_U0, _U1, _U2, _U3, _U4, _U5, _U6, \n+\t    _U7, _U8, _U9>& __u)\n+  {\n+    typedef tuple<_T0, _T1, _T2, _T3, _T4, _T5, _T6, _T7, _T8, _T9\n+      > __T_tuple;\n+    typedef tuple<_U0, _U1, _U2, _U3, _U4, _U5, _U6, _U7, _U8, _U9\n+      > __U_tuple;\n+    return __tuple_compare<tuple_size<__T_tuple>::value -\n+      tuple_size<__U_tuple>::value, 0,\n+      tuple_size<__T_tuple>::value, __T_tuple, __U_tuple>::__greater(__t, __u);\n+  }\n+\n+  template<typename _T0, typename _T1, typename _T2, typename _T3, \n+\t   typename _T4, typename _T5, typename _T6, typename _T7, \n+\t   typename _T8, typename _T9, typename _U0, typename _U1, \n+\t   typename _U2, typename _U3, typename _U4, typename _U5, \n+\t   typename _U6, typename _U7, typename _U8, typename _U9>\n+  bool\n+  operator<=(const tuple<_T0, _T1, _T2, _T3, _T4, _T5, _T6, _T7, _T8, \n+\t     _T9>& __t, const tuple<_U0, _U1, _U2, _U3, _U4, _U5, _U6, \n+\t     _U7, _U8, _U9>& __u)\n+  {\n+    typedef tuple<_T0, _T1, _T2, _T3, _T4, _T5, _T6, _T7, _T8, _T9\n+      > __T_tuple;\n+    typedef tuple<_U0, _U1, _U2, _U3, _U4, _U5, _U6, _U7, _U8, _U9\n+      > __U_tuple;\n+    return __tuple_compare<tuple_size<__T_tuple>::value -\n+      tuple_size<__U_tuple>::value, 0,\n+      tuple_size<__T_tuple>::value, __T_tuple, __U_tuple>::__leq(__t, __u);\n+  }\n+\n+  template<typename _T0, typename _T1, typename _T2, typename _T3, \n+\t   typename _T4, typename _T5, typename _T6, typename _T7, \n+\t   typename _T8, typename _T9, typename _U0, typename _U1, \n+\t   typename _U2, typename _U3, typename _U4, typename _U5, \n+\t   typename _U6, typename _U7, typename _U8, typename _U9>\n+  bool\n+  operator>=(const tuple<_T0, _T1, _T2, _T3, _T4, _T5, _T6, _T7, _T8, \n+\t     _T9>& __t, const tuple<_U0, _U1, _U2, _U3, _U4, _U5, _U6, \n+\t     _U7, _U8, _U9>& __u)\n+  {\n+    typedef tuple<_T0, _T1, _T2, _T3, _T4, _T5, _T6, _T7, _T8, _T9\n+      > __T_tuple;\n+    typedef tuple<_U0, _U1, _U2, _U3, _U4, _U5, _U6, _U7, _U8, _U9\n+      > __U_tuple;\n+    return __tuple_compare<tuple_size<__T_tuple>::value -\n+      tuple_size<__U_tuple>::value, 0,\n+      tuple_size<__T_tuple>::value, __T_tuple, __U_tuple>::__geq(__t, __u);\n+  }\n+\n+  // Provides a way to annotate that a reference to\n+  // an object should be passed.\n+  template<typename _T>\n+  class reference_wrapper\n+  {\n+    _T& __data;\n+\n+  public:\n+    typedef _T type;\n+\n+    explicit reference_wrapper(_T& __indata): __data(__indata)\n+    { }\n+    \n+    operator _T&() const\n+    { return this->get(); }\n+    \n+    _T&\n+    get() const\n+    { return __data; }\n+  };\n+\n+  // Denotes a reference should be taken to a variable.\n+  template<typename _T>\n+    reference_wrapper<_T>\n+    ref(_T& __t)\n+    { return reference_wrapper<_T>(__t); }\n+\n+  // Denotes a const reference should be taken to a variable.\n+  template<typename _T>\n+    reference_wrapper<_T const>\n+    cref(const _T& __t)\n+    { return reference_wrapper<_T const>(__t); }\n+\n+  // Helper which adds a reference to a type when given a reference_wrapper\n+  template<typename _T>\n+    struct __strip_reference_wrapper\n+    { typedef _T __type; };\n+\n+  template<typename _T>\n+    struct __strip_reference_wrapper<reference_wrapper<_T> >\n+    { typedef _T& __type; };\n+\n+  template<typename _T>\n+    struct __strip_reference_wrapper<const reference_wrapper<_T> >\n+    { typedef _T& __type; };\n+\n+  template<typename _T0 = _NullClass, typename _T1 = _NullClass, \n+\t   typename _T2 = _NullClass, typename _T3 = _NullClass, \n+\t   typename _T4 = _NullClass, typename _T5 = _NullClass, \n+\t   typename _T6 = _NullClass, typename _T7 = _NullClass, \n+\t   typename _T8 = _NullClass, typename _T9 = _NullClass>\n+    struct __stripped_tuple_type\n+    {\n+      typedef tuple<typename __strip_reference_wrapper<_T0>::__type, \n+\t\t    typename __strip_reference_wrapper<_T1>::__type, \n+\t\t    typename __strip_reference_wrapper<_T2>::__type, \n+\t\t    typename __strip_reference_wrapper<_T3>::__type, \n+\t\t    typename __strip_reference_wrapper<_T4>::__type, \n+\t\t    typename __strip_reference_wrapper<_T5>::__type, \n+\t\t    typename __strip_reference_wrapper<_T6>::__type, \n+\t\t    typename __strip_reference_wrapper<_T7>::__type, \n+\t\t    typename __strip_reference_wrapper<_T8>::__type, \n+\t\t    typename __strip_reference_wrapper<_T9>::__type>  __type;\n+    };\n+\n+  tuple<>\n+  make_tuple()\n+  {\n+    return tuple<>();\n+  };\n+\n+  template<typename _T0>\n+  typename __stripped_tuple_type<_T0>::__type\n+  make_tuple(_T0 __t0)\n+  {\n+    return typename  __stripped_tuple_type<_T0>::__type(__t0);};\n+\n+  template<typename _T0, typename _T1>\n+  typename __stripped_tuple_type<_T0, _T1>::__type\n+  make_tuple(_T0 __t0, _T1 __t1)\n+  {\n+    return typename  __stripped_tuple_type<_T0, _T1>::__type(__t0, __t1);};\n+\n+  template<typename _T0, typename _T1, typename _T2>\n+  typename __stripped_tuple_type<_T0, _T1, _T2>::__type\n+  make_tuple(_T0 __t0, _T1 __t1, _T2 __t2)\n+  {\n+    return typename __stripped_tuple_type<_T0, _T1, _T2>::__type(__t0, __t1, __t2);};\n+\n+  template<typename _T0, typename _T1, typename _T2, typename _T3>\n+  typename __stripped_tuple_type<_T0, _T1, _T2, _T3>::__type\n+  make_tuple(_T0 __t0, _T1 __t1, _T2 __t2, _T3 __t3)\n+  {\n+    return typename  __stripped_tuple_type<_T0, _T1, _T2, _T3>::__type(__t0, __t1, __t2, __t3);};\n+\n+  template<typename _T0, typename _T1, typename _T2, typename _T3, \n+\t   typename _T4>\n+  typename __stripped_tuple_type<_T0, _T1, _T2, _T3, _T4>::__type\n+  make_tuple(_T0 __t0, _T1 __t1, _T2 __t2, _T3 __t3, _T4 __t4)\n+  {\n+    return typename  __stripped_tuple_type<_T0, _T1, _T2, _T3, _T4>::__type(__t0, __t1, __t2, __t3, __t4);};\n+\n+  template<typename _T0, typename _T1, typename _T2, typename _T3, \n+\t   typename _T4, typename _T5>\n+  typename __stripped_tuple_type<_T0, _T1, _T2, _T3, _T4, _T5>::__type\n+  make_tuple(_T0 __t0, _T1 __t1, _T2 __t2, _T3 __t3, _T4 __t4, \n+\t     _T5 __t5)\n+  {\n+    return typename  __stripped_tuple_type<_T0, _T1, _T2, _T3, _T4, _T5\n+      >::__type(__t0, __t1, __t2, __t3, __t4, __t5);};\n+\n+  template<typename _T0, typename _T1, typename _T2, typename _T3, \n+\t   typename _T4, typename _T5, typename _T6>\n+  typename __stripped_tuple_type<_T0, _T1, _T2, _T3, _T4, _T5, _T6\n+\t\t\t\t >::__type\n+  make_tuple(_T0 __t0, _T1 __t1, _T2 __t2, _T3 __t3, _T4 __t4, \n+\t     _T5 __t5, _T6 __t6)\n+  {\n+    return typename  __stripped_tuple_type<_T0, _T1, _T2, _T3, _T4, _T5, \n+      _T6>::__type(__t0, __t1, __t2, __t3, __t4, __t5, __t6);};\n+\n+  template<typename _T0, typename _T1, typename _T2, typename _T3, \n+\t   typename _T4, typename _T5, typename _T6, typename _T7>\n+  typename __stripped_tuple_type<_T0, _T1, _T2, _T3, _T4, _T5, _T6, _T7\n+\t\t\t\t >::__type\n+  make_tuple(_T0 __t0, _T1 __t1, _T2 __t2, _T3 __t3, _T4 __t4, \n+\t     _T5 __t5, _T6 __t6, _T7 __t7)\n+  {\n+    return typename  __stripped_tuple_type<_T0, _T1, _T2, _T3, _T4, _T5, \n+      _T6, _T7>::__type(__t0, __t1, __t2, __t3, __t4, __t5, __t6, __t7);};\n+\n+  template<typename _T0, typename _T1, typename _T2, typename _T3, \n+\t   typename _T4, typename _T5, typename _T6, typename _T7, \n+\t   typename _T8>\n+  typename __stripped_tuple_type<_T0, _T1, _T2, _T3, _T4, _T5, _T6, _T7, \n+\t\t\t\t _T8>::__type\n+  make_tuple(_T0 __t0, _T1 __t1, _T2 __t2, _T3 __t3, _T4 __t4, \n+\t     _T5 __t5, _T6 __t6, _T7 __t7, _T8 __t8)\n+  {\n+    return typename  __stripped_tuple_type<_T0, _T1, _T2, _T3, _T4, _T5, \n+      _T6, _T7, _T8>::__type(__t0, __t1, __t2, __t3, __t4, __t5, __t6, __t7, __t8);};\n+\n+  template<typename _T0, typename _T1, typename _T2, typename _T3, \n+\t   typename _T4, typename _T5, typename _T6, typename _T7, \n+\t   typename _T8, typename _T9>\n+  typename __stripped_tuple_type<_T0, _T1, _T2, _T3, _T4, _T5, _T6, _T7, \n+\t\t\t\t _T8, _T9>::__type\n+  make_tuple(_T0 __t0, _T1 __t1, _T2 __t2, _T3 __t3, _T4 __t4, \n+\t     _T5 __t5, _T6 __t6, _T7 __t7, _T8 __t8, _T9 __t9)\n+  {\n+    return typename  __stripped_tuple_type<_T0, _T1, _T2, _T3, _T4, _T5, \n+      _T6, _T7, _T8, _T9>::__type(__t0, __t1, __t2, __t3, __t4, __t5, __t6, __t7, __t8, __t9\n+\t\t\t\t    );};\n+\n+  // A class (and instance) which can be used in 'tie' when a element\n+  // is not required.\n+  struct swallow_assign\n+  {\n+    template<class T>\n+      swallow_assign&\n+      operator=(const T&)\n+      { return *this; }\n+  };\n+\n+  // TODO: Put this in some kind of shared file\n+  namespace\n+  {\n+    swallow_assign ignore;\n+  };\n+\n+  //  extern swallow_assign ignore;\n+\n+\n+  // Allows forms a tuple of references to a list of variables.\n+  template<typename _T0>\n+    tuple<_T0&>\n+    tie(_T0& __t0)\n+    { return make_tuple(ref(__t0)); };\n+\n+  template<typename _T0, typename _T1>\n+    tuple<_T0&, _T1&>\n+    tie(_T0& __t0, _T1& __t1)\n+    { return make_tuple(ref(__t0), ref(__t1)); };\n+\n+  template<typename _T0, typename _T1, typename _T2>\n+    tuple<_T0&, _T1&, _T2&>\n+    tie(_T0& __t0, _T1& __t1, _T2& __t2)\n+    { return make_tuple(ref(__t0), ref(__t1), ref(__t2)); };\n+\n+  template<typename _T0, typename _T1, typename _T2, typename _T3>\n+    tuple<_T0&, _T1&, _T2&, _T3&>\n+    tie(_T0& __t0, _T1& __t1, _T2& __t2, _T3& __t3)\n+    { return make_tuple(ref(__t0), ref(__t1), ref(__t2), ref(__t3)); };\n+\n+  template<typename _T0, typename _T1, typename _T2, typename _T3, \n+\t   typename _T4>\n+    tuple<_T0&, _T1&, _T2&, _T3&, _T4&>\n+    tie(_T0& __t0, _T1& __t1, _T2& __t2, _T3& __t3, _T4& __t4)\n+    { \n+      return make_tuple(ref(__t0), ref(__t1), ref(__t2), ref(__t3), ref(__t4));\n+    };\n+\n+  template<typename _T0, typename _T1, typename _T2, typename _T3, \n+\t   typename _T4, typename _T5>\n+    tuple<_T0&, _T1&, _T2&, _T3&, _T4&, _T5&>\n+    tie(_T0& __t0, _T1& __t1, _T2& __t2, _T3& __t3, _T4& __t4, _T5& __t5)\n+    {\n+      return make_tuple(ref(__t0), ref(__t1), ref(__t2), ref(__t3), \n+\t\t\tref(__t4), ref(__t5));\n+    };\n+\n+  template<typename _T0, typename _T1, typename _T2, typename _T3, \n+\t   typename _T4, typename _T5, typename _T6>\n+    tuple<_T0&, _T1&, _T2&, _T3&, _T4&, _T5&, _T6&>\n+    tie(_T0& __t0, _T1& __t1, _T2& __t2, _T3& __t3, _T4& __t4, \n+\t_T5& __t5, _T6& __t6)\n+    {\n+      return make_tuple(ref(__t0), ref(__t1), ref(__t2), ref(__t3), \n+\t\t\tref(__t4), ref(__t5), ref(__t6));\n+    };\n+\n+  template<typename _T0, typename _T1, typename _T2, typename _T3, \n+\t   typename _T4, typename _T5, typename _T6, typename _T7>\n+    tuple<_T0&, _T1&, _T2&, _T3&, _T4&, _T5&, _T6&, _T7&>\n+    tie(_T0& __t0, _T1& __t1, _T2& __t2, _T3& __t3, _T4& __t4, \n+\t_T5& __t5, _T6& __t6, _T7& __t7)\n+    {\n+      return make_tuple(ref(__t0), ref(__t1), ref(__t2), ref(__t3), \n+\t\t\tref(__t4), ref(__t5), ref(__t6), ref(__t7));\n+    };\n+\n+  template<typename _T0, typename _T1, typename _T2, typename _T3, \n+\t   typename _T4, typename _T5, typename _T6, typename _T7, \n+\t   typename _T8>\n+    tuple<_T0&, _T1&, _T2&, _T3&, _T4&, _T5&, _T6&, _T7&, _T8&>\n+    tie(_T0& __t0, _T1& __t1, _T2& __t2, _T3& __t3, _T4& __t4, \n+\t_T5& __t5, _T6& __t6, _T7& __t7, _T8& __t8)\n+    {\n+      return make_tuple(ref(__t0), ref(__t1), ref(__t2), ref(__t3), \n+\t\t\tref(__t4), ref(__t5), ref(__t6), ref(__t7), ref(__t8));\n+    };\n+\n+  template<typename _T0, typename _T1, typename _T2, typename _T3, \n+\t   typename _T4, typename _T5, typename _T6, typename _T7, \n+\t   typename _T8, typename _T9>\n+    tuple<_T0&, _T1&, _T2&, _T3&, _T4&, _T5&, _T6&, _T7&, _T8&, _T9&>\n+    tie(_T0& __t0, _T1& __t1, _T2& __t2, _T3& __t3, _T4& __t4, \n+\t_T5& __t5, _T6& __t6, _T7& __t7, _T8& __t8, _T9& __t9)\n+    {\n+      return make_tuple(ref(__t0), ref(__t1), ref(__t2), ref(__t3), \n+\t\t\tref(__t4), ref(__t5), ref(__t6), ref(__t7), ref(__t8), \n+\t\t\tref(__t9));\n+    };\n+\n+  // Various functions which give std::pair a tuple-like interface.\n+  template<class _T1, class _T2>\n+    struct tuple_size<std::pair<_T1, _T2> >\n+    { static const int value = 2; };\n+\n+  template<class _T1, class _T2>\n+    struct tuple_element<0, std::pair<_T1, _T2> >\n+    { typedef _T1 type; };\n+\n+  template<class _T1, class _T2>\n+    struct tuple_element<1, std::pair<_T1, _T2> >\n+    { typedef _T2 type; };\n+\n+  template<int _I,class _T1,class _T2>\n+    typename tuple_element<_I, tuple<_T1, _T2> >::type\n+    get(pair<_T1, _T2>& __in)\n+    { return get<_I>(tie(__in.first, __in.second)); }\n+\n+  template<int _I,class _T1,class _T2>\n+    typename tuple_element<_I, tuple<_T1, _T2> >::type\n+    get(const pair<_T1, _T2>& __in)\n+    { return get<_I>(tie(__in.first, __in.second)); }\n+}\n+}\n+\n+#endif"}, {"sha": "ed3ad656c76dcfe17c1cc05773df224e07c170a2", "filename": "libstdc++-v3/testsuite/tr1/6_containers/tuple/comparison_operators/comparisons.cc", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a520f0b0aeb4f9f73b9b39bfb2923bd6c383ffb6/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F6_containers%2Ftuple%2Fcomparison_operators%2Fcomparisons.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a520f0b0aeb4f9f73b9b39bfb2923bd6c383ffb6/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F6_containers%2Ftuple%2Fcomparison_operators%2Fcomparisons.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F6_containers%2Ftuple%2Fcomparison_operators%2Fcomparisons.cc?ref=a520f0b0aeb4f9f73b9b39bfb2923bd6c383ffb6", "patch": "@@ -0,0 +1,50 @@\n+// 2004-09-23 Chris Jefferson <chris@bubblescope.net>\n+\n+// Copyright (C) 2004 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// Tuple\n+\n+#include <tr1/tuple>\n+#include <testsuite_hooks.h>\n+\n+using namespace std;\n+using namespace tr1;\n+\n+#define TEST1(x) VERIFY( x == x && !(x != x) && x <= x && !(x < x) )\n+\n+int\n+main()\n+{\n+  int i=0;\n+  int j=0;\n+  int k=2;\n+  tuple<int, int, int> a(0, 0, 0);\n+  tuple<int, int, int> b(0, 0, 1);\n+  tuple<int& , int& , int&> c(i,j,k);\n+  tuple<const int&, const int&, const int&> d(c);\n+  TEST1(a);\n+  TEST1(b);\n+  TEST1(c);\n+  TEST1(d);\n+  VERIFY(!(a > a) && !(b > b));\n+  VERIFY(a >= a && b >= b);\n+  VERIFY(a < b && !(b < a) && a <= b && !(b <= a));\n+  VERIFY(b > a && !(a > b) && b >= a && !(a >= b));  \n+}\n+"}, {"sha": "3723e59fd40a266348369c1f7b4eabe8fcb6836f", "filename": "libstdc++-v3/testsuite/tr1/6_containers/tuple/cons/assignment.cc", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a520f0b0aeb4f9f73b9b39bfb2923bd6c383ffb6/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F6_containers%2Ftuple%2Fcons%2Fassignment.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a520f0b0aeb4f9f73b9b39bfb2923bd6c383ffb6/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F6_containers%2Ftuple%2Fcons%2Fassignment.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F6_containers%2Ftuple%2Fcons%2Fassignment.cc?ref=a520f0b0aeb4f9f73b9b39bfb2923bd6c383ffb6", "patch": "@@ -0,0 +1,53 @@\n+// 2004-09-23 Chris Jefferson <chris@bubblescope.net>\n+\n+// Copyright (C) 2004 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// Tuple\n+\n+#include <tr1/tuple>\n+#include <testsuite_hooks.h>\n+\n+using namespace std;\n+using namespace tr1;\n+\n+int\n+main()\n+{\n+  tuple<> ta;\n+  tuple<> tb;\n+  ta = tb;\n+\n+  tuple<int> tc(1);\n+  tuple<int> td(0);\n+  td = tc;\n+  VERIFY(get<0>(td) == 1);\n+\n+  int i=0;\n+  tuple<int&> te(i);\n+  te = tc;\n+  VERIFY(i == 1);\n+\n+  tuple<const int&> tf(tc);\n+\n+  get<0>(tc) = 2;\n+  VERIFY(get<0>(tf) == 2);\n+  tuple<double> tg;\n+  tg = tc;\n+}\n+"}, {"sha": "860a354e542fbf247a023048d1ae5463b0371cf1", "filename": "libstdc++-v3/testsuite/tr1/6_containers/tuple/cons/big_tuples.cc", "status": "added", "additions": 106, "deletions": 0, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a520f0b0aeb4f9f73b9b39bfb2923bd6c383ffb6/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F6_containers%2Ftuple%2Fcons%2Fbig_tuples.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a520f0b0aeb4f9f73b9b39bfb2923bd6c383ffb6/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F6_containers%2Ftuple%2Fcons%2Fbig_tuples.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F6_containers%2Ftuple%2Fcons%2Fbig_tuples.cc?ref=a520f0b0aeb4f9f73b9b39bfb2923bd6c383ffb6", "patch": "@@ -0,0 +1,106 @@\n+// 2004-09-23 Chris Jefferson <chris@bubblescope.net>\n+\n+// Copyright (C) 2004 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// Tuple\n+\n+#include <tr1/tuple>\n+#include <testsuite_hooks.h>\n+\n+using namespace std;\n+using namespace tr1;\n+\n+// A simple class without conversions to check some things\n+struct foo\n+{ };\n+\n+void\n+test_constructors()\n+{\n+  int x1=0,x2=0;\n+  const int &z1=x1;\n+\n+  // Test empty constructor\n+  tuple<> ta;\n+  tuple<int,int> tb;\n+  // Test construction from values\n+  tuple<int,int> tc(x1,x2);\n+  tuple<int,int&> td(x1,x2);\n+  tuple<const int&> te(z1);\n+  x1=1;\n+  x2=1;\n+  VERIFY(get<0>(td) == 0 && get<1>(td) == 1 && get<0>(te) == 1);\n+\n+  // Test identical tuple copy constructor\n+  tuple<int,int> tf(tc);\n+  tuple<int,int> tg(td);\n+  tuple<const int&> th(te);\n+  // Test different tuple copy constructor\n+  tuple<int,double> ti(tc);\n+  tuple<int,double> tj(td);\n+  // Test constructing from a pair\n+  pair<int,int> pair1(1,1);\n+  const pair<int,int> pair2(pair1);\n+  tuple<int,int> tl(pair1);\n+  tuple<int,const int&> tm(pair1);\n+  tuple<int,int> tn(pair2);\n+  tuple<int,const int&> to(pair2);  \n+}\n+\n+int \n+main(void) \n+{\n+  //test construction\n+  typedef tuple<int,int,int,int,int,int,int,int,int,int> type1;\n+  type1 a(0, 0, 0, 0, 0, 0, 0, 0, 0, 1);\n+  type1 b(0, 0, 0, 0, 0, 0, 0, 0, 0, 2);\n+  type1 c(a);\n+  typedef tuple<int,int,int,int,int,int,int,int,int,char> type2;\n+  type2 d(0, 0, 0, 0, 0, 0, 0, 0, 0, 3);\n+  type1 e(d);\n+  typedef tuple<foo,int,int,int,int,int,int,int,int,foo> type3;\n+  // get\n+  VERIFY(get<9>(a)==1 && get<9>(b)==2);\n+  // comparisons\n+  VERIFY(a==a && !(a!=a) && a<=a && a>=a && !(a<a) && !(a>a));\n+  VERIFY(!(a==b) && a!=b && a<=b && a<b && !(a>=b) && !(a>b));\n+  //tie\n+  {\n+    int i = 0;\n+  tie(ignore, ignore, ignore, ignore, ignore, ignore, ignore, ignore, \n+      ignore, i) = a;\n+  VERIFY(i == 1);\n+  }\n+  //test_assignment\n+  a=d;\n+  a=b;\n+  //make_tuple\n+  make_tuple(0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n+  \n+  //tuple_size\n+  VERIFY(tuple_size<type3>::value == 10);\n+  //tuple_element\n+  {  \n+    foo q1;\n+    tuple_element<0,type3>::type q2(q1);\n+    tuple_element<9,type3>::type q3(q1);\n+  }\n+  \n+}\n+"}, {"sha": "f3efc53953cbc9921a67046b17bcb6166e288781", "filename": "libstdc++-v3/testsuite/tr1/6_containers/tuple/cons/constructor.cc", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a520f0b0aeb4f9f73b9b39bfb2923bd6c383ffb6/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F6_containers%2Ftuple%2Fcons%2Fconstructor.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a520f0b0aeb4f9f73b9b39bfb2923bd6c383ffb6/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F6_containers%2Ftuple%2Fcons%2Fconstructor.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F6_containers%2Ftuple%2Fcons%2Fconstructor.cc?ref=a520f0b0aeb4f9f73b9b39bfb2923bd6c383ffb6", "patch": "@@ -0,0 +1,65 @@\n+// 2004-09-23 Chris Jefferson <chris@bubblescope.net>\n+\n+// Copyright (C) 2004 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// Tuple\n+\n+#include <tr1/tuple>\n+#include <testsuite_hooks.h>\n+\n+using namespace std;\n+using namespace tr1;\n+\n+int\n+main()\n+{\n+  int x1=0,x2=0;\n+  const int &z1=x1;\n+\n+  // Test empty constructor\n+  tuple<> ta;\n+  tuple<int,int> tb;\n+  // Test construction from values\n+  tuple<int,int> tc(x1,x2);\n+  tuple<int,int&> td(x1,x2);\n+  tuple<const int&> te(z1);\n+  x1=1;\n+  x2=1;\n+  VERIFY(get<0>(td) == 0 && get<1>(td) == 1 && get<0>(te) == 1);\n+\n+  // Test identical tuple copy constructor\n+  tuple<int,int> tf(tc);\n+  tuple<int,int> tg(td);\n+  tuple<const int&> th(te);\n+  // Test different tuple copy constructor\n+  tuple<int,double> ti(tc);\n+  tuple<int,double> tj(td);\n+  //tuple<int&, int&> tk(tc);\n+  tuple<const int&, const int&> tl(tc);\n+  tuple<const int&, const int&> tm(tl);\n+  // Test constructing from a pair\n+  pair<int,int> pair1(1,1);\n+  const pair<int,int> pair2(pair1);\n+  tuple<int,int> tn(pair1);\n+  tuple<int,const int&> to(pair1);\n+  tuple<int,int> tp(pair2);\n+  tuple<int,const int&> tq(pair2);  \n+  return 0;\n+}\n+"}, {"sha": "67b69f55f356791c61b2a0beb07b5cf1c05a2281", "filename": "libstdc++-v3/testsuite/tr1/6_containers/tuple/creation_functions/make_tuple.cc", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a520f0b0aeb4f9f73b9b39bfb2923bd6c383ffb6/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F6_containers%2Ftuple%2Fcreation_functions%2Fmake_tuple.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a520f0b0aeb4f9f73b9b39bfb2923bd6c383ffb6/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F6_containers%2Ftuple%2Fcreation_functions%2Fmake_tuple.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F6_containers%2Ftuple%2Fcreation_functions%2Fmake_tuple.cc?ref=a520f0b0aeb4f9f73b9b39bfb2923bd6c383ffb6", "patch": "@@ -0,0 +1,37 @@\n+// 2004-09-23 Chris Jefferson <chris@bubblescope.net>\n+\n+// Copyright (C) 2004 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// Tuple\n+\n+#include <tr1/tuple>\n+#include <testsuite_hooks.h>\n+\n+using namespace std;\n+using namespace tr1;\n+\n+int\n+main()\n+{\n+  int i=0;\n+  make_tuple(1,2,4.0);\n+  make_tuple(ref(i)) = tuple<int>(1);\n+  VERIFY(i == 1);\n+}\n+"}, {"sha": "4de95672741540e34dcf7d89fee49830b64154d8", "filename": "libstdc++-v3/testsuite/tr1/6_containers/tuple/creation_functions/tie.cc", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a520f0b0aeb4f9f73b9b39bfb2923bd6c383ffb6/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F6_containers%2Ftuple%2Fcreation_functions%2Ftie.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a520f0b0aeb4f9f73b9b39bfb2923bd6c383ffb6/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F6_containers%2Ftuple%2Fcreation_functions%2Ftie.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F6_containers%2Ftuple%2Fcreation_functions%2Ftie.cc?ref=a520f0b0aeb4f9f73b9b39bfb2923bd6c383ffb6", "patch": "@@ -0,0 +1,43 @@\n+// 2004-09-23 Chris Jefferson <chris@bubblescope.net>\n+\n+// Copyright (C) 2004 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// Tuple\n+\n+#include <tr1/tuple>\n+#include <testsuite_hooks.h>\n+\n+using namespace std;\n+using namespace tr1;\n+\n+int\n+main()\n+{\n+  int x1 = 0;\n+  int x2 = 0;\n+  int y1 = 0;\n+  int y2 = 0;\n+  tuple<int,int> ta(1,1);\n+  tuple<const int&,const int&> tc(x1,x2);\n+  tie(y1,y2)=ta;\n+  VERIFY(y1 == 1 && y2 == 1);\n+  tie(y1,y2)=tc;\n+  VERIFY(y1 == 0 && y2 == 0);\n+}\n+"}, {"sha": "83ff17c44f4044829b16430fdc6c87c349d10e17", "filename": "libstdc++-v3/testsuite/tr1/6_containers/tuple/element_access/get.cc", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a520f0b0aeb4f9f73b9b39bfb2923bd6c383ffb6/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F6_containers%2Ftuple%2Felement_access%2Fget.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a520f0b0aeb4f9f73b9b39bfb2923bd6c383ffb6/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F6_containers%2Ftuple%2Felement_access%2Fget.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F6_containers%2Ftuple%2Felement_access%2Fget.cc?ref=a520f0b0aeb4f9f73b9b39bfb2923bd6c383ffb6", "patch": "@@ -0,0 +1,45 @@\n+// 2004-09-23 Chris Jefferson <chris@bubblescope.net>\n+\n+// Copyright (C) 2004 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// Tuple\n+\n+#include <tr1/tuple>\n+#include <testsuite_hooks.h>\n+\n+using namespace std;\n+using namespace tr1;\n+\n+int\n+main()\n+{\n+  int j=1;\n+  const int k=2;\n+  tuple<int,int &,const int&> a(0,j,k);\n+  const tuple<int,int &,const int&> b(1,j,k); \n+  VERIFY(get<0>(a)==0 && get<1>(a)==1 && get<2>(a)==2);\n+  get<0>(a)=3;\n+  get<1>(a)=4;  \n+  VERIFY(get<0>(a)==3 && get<1>(a)==4);\n+  VERIFY(j==4);\n+  get<1>(b)=5;\n+  VERIFY(get<0>(b)==1 && get<1>(b)==5 && get<2>(b)==2);\n+  VERIFY(j==5);\n+}\n+"}, {"sha": "8a8b6305e1a1000af03e18e6d119a692b166e5a7", "filename": "libstdc++-v3/testsuite/tr1/6_containers/tuple/tuple_element.cc", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a520f0b0aeb4f9f73b9b39bfb2923bd6c383ffb6/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F6_containers%2Ftuple%2Ftuple_element.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a520f0b0aeb4f9f73b9b39bfb2923bd6c383ffb6/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F6_containers%2Ftuple%2Ftuple_element.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F6_containers%2Ftuple%2Ftuple_element.cc?ref=a520f0b0aeb4f9f73b9b39bfb2923bd6c383ffb6", "patch": "@@ -0,0 +1,41 @@\n+// 2004-09-23 Chris Jefferson <chris@bubblescope.net>\n+\n+// Copyright (C) 2004 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// Tuple\n+\n+#include <tr1/tuple>\n+#include <testsuite_hooks.h>\n+\n+using namespace std;\n+using namespace tr1;\n+\n+struct foo\n+{ };\n+\n+int\n+main()\n+{\n+  // As foo isn't constructable from anything else, this\n+  // lets us check if type is returning foo when it should\n+  foo q1;\n+  tuple_element<0,tuple<foo,void,int> >::type q2(q1);\n+  tuple_element<2,tuple<void,int,foo> >::type q3(q1);\n+}\n+"}, {"sha": "eb6c427b2e68c9f220301a1dd24c913fa794d9df", "filename": "libstdc++-v3/testsuite/tr1/6_containers/tuple/tuple_size.cc", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a520f0b0aeb4f9f73b9b39bfb2923bd6c383ffb6/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F6_containers%2Ftuple%2Ftuple_size.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a520f0b0aeb4f9f73b9b39bfb2923bd6c383ffb6/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F6_containers%2Ftuple%2Ftuple_size.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F6_containers%2Ftuple%2Ftuple_size.cc?ref=a520f0b0aeb4f9f73b9b39bfb2923bd6c383ffb6", "patch": "@@ -0,0 +1,39 @@\n+// 2004-09-23 Chris Jefferson <chris@bubblescope.net>\n+\n+// Copyright (C) 2004 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// Tuple\n+\n+#include <tr1/tuple>\n+#include <testsuite_hooks.h>\n+\n+using namespace std;\n+using namespace tr1;\n+\n+int\n+main()\n+{\n+  VERIFY(tuple_size<tuple<> >::value == 0);\n+  VERIFY(tuple_size<tuple<int> >::value == 1);\n+  VERIFY(tuple_size<tuple<void> >::value == 1);\n+  typedef tuple<int,const int&,void> test_tuple1;\n+  VERIFY(tuple_size<test_tuple1>::value == 3);\n+  VERIFY(tuple_size<tuple<tuple<void> > >::value == 1);\n+}\n+"}]}