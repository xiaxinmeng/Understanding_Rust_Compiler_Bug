{"sha": "6a58cccac65539b1ab89af806b829b5423b6de9a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmE1OGNjY2FjNjU1MzliMWFiODlhZjgwNmI4MjliNTQyM2I2ZGU5YQ==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2013-11-29T14:37:07Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2013-11-29T14:37:07Z"}, "message": "re PR middle-end/59208 (ice in initialize_flags_in_bb)\n\n2013-11-29  Richard Biener  <rguenther@suse.de>\n\n\tPR middle-end/59208\n\t* tree-ssa-operands.h (fini_ssa_operands, verify_ssa_operands,\n\tfree_stmt_operands, update_stmt_operands): Add struct function\n\targument.\n\t* tree-ssa-operands.c: Remove uses of cfun, propagate struct\n\tfunction argument from fini_ssa_operands, verify_ssa_operands,\n\tfree_stmt_operands and update_stmt_operands everywhere.\n\t* tree-ssanames.h (release_ssa_name_fn): New.\n\t(release_ssa_name): Inline wrapper around release_ssa_name_fn.\n\t* tree-ssanames.c (release_ssa_name): Rename to ...\n\t(release_ssa_name_fn): ... this and add struct function argument.\n\t* gimple-ssa.h (update_stmt, update_stmt_if_modified): Adjust.\n\t(update_stmt_fn): New function.\n\t* tree-cfg.c (move_block_to_fn): Adjust.\n\t* tree-if-conv.c (free_bb_predicate): Likewise.\n\t* tree-ssa.c (verify_ssa): Likewise.\n\t(delete_tree_ssa): Likewise.\n\t* gimple-pretty-print.c (dump_gimple_mem_ops): Remove guard.\n\t* cgraph.c (cgraph_redirect_edge_call_stmt_to_callee): Call\n\tupdate_stmt_fn instead of update_stmt.\n\n\t* g++.dg/torture/pr59208.C: New testcase.\n\nFrom-SVN: r205528", "tree": {"sha": "d8461c2dc057c316e7b6a321c5f73c5134c8fef6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d8461c2dc057c316e7b6a321c5f73c5134c8fef6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6a58cccac65539b1ab89af806b829b5423b6de9a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a58cccac65539b1ab89af806b829b5423b6de9a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6a58cccac65539b1ab89af806b829b5423b6de9a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a58cccac65539b1ab89af806b829b5423b6de9a/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "78a14aa81e61e50a667854dc45243188cc861d95", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/78a14aa81e61e50a667854dc45243188cc861d95", "html_url": "https://github.com/Rust-GCC/gccrs/commit/78a14aa81e61e50a667854dc45243188cc861d95"}], "stats": {"total": 306, "additions": 177, "deletions": 129}, "files": [{"sha": "6a0b66c7cb479215014b9e99a2e9ed4efc295449", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a58cccac65539b1ab89af806b829b5423b6de9a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a58cccac65539b1ab89af806b829b5423b6de9a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6a58cccac65539b1ab89af806b829b5423b6de9a", "patch": "@@ -1,3 +1,26 @@\n+2013-11-29  Richard Biener  <rguenther@suse.de>\n+\n+\tPR middle-end/59208\n+\t* tree-ssa-operands.h (fini_ssa_operands, verify_ssa_operands,\n+\tfree_stmt_operands, update_stmt_operands): Add struct function\n+\targument.\n+\t* tree-ssa-operands.c: Remove uses of cfun, propagate struct\n+\tfunction argument from fini_ssa_operands, verify_ssa_operands,\n+\tfree_stmt_operands and update_stmt_operands everywhere.\n+\t* tree-ssanames.h (release_ssa_name_fn): New.\n+\t(release_ssa_name): Inline wrapper around release_ssa_name_fn.\n+\t* tree-ssanames.c (release_ssa_name): Rename to ...\n+\t(release_ssa_name_fn): ... this and add struct function argument.\n+\t* gimple-ssa.h (update_stmt, update_stmt_if_modified): Adjust.\n+\t(update_stmt_fn): New function.\n+\t* tree-cfg.c (move_block_to_fn): Adjust.\n+\t* tree-if-conv.c (free_bb_predicate): Likewise.\n+\t* tree-ssa.c (verify_ssa): Likewise.\n+\t(delete_tree_ssa): Likewise.\n+\t* gimple-pretty-print.c (dump_gimple_mem_ops): Remove guard.\n+\t* cgraph.c (cgraph_redirect_edge_call_stmt_to_callee): Call\n+\tupdate_stmt_fn instead of update_stmt.\n+\n 2013-11-29  Yvan Roux  <yvan.roux@linaro.org>\n \n \t* config/arm/arm.h (THUMB_SECONDARY_INPUT_RELOAD_CLASS): Return NO_REGS"}, {"sha": "9501afa0c668c051ca4dbfc77b5faf33fb922ff8", "filename": "gcc/cgraph.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a58cccac65539b1ab89af806b829b5423b6de9a/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a58cccac65539b1ab89af806b829b5423b6de9a/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=6a58cccac65539b1ab89af806b829b5423b6de9a", "patch": "@@ -1468,7 +1468,7 @@ cgraph_redirect_edge_call_stmt_to_callee (struct cgraph_edge *e)\n     {\n       new_stmt = e->call_stmt;\n       gimple_call_set_fndecl (new_stmt, e->callee->decl);\n-      update_stmt (new_stmt);\n+      update_stmt_fn (DECL_STRUCT_FUNCTION (e->caller->decl), new_stmt);\n     }\n \n   cgraph_set_call_stmt_including_clones (e->caller, e->call_stmt, new_stmt, false);"}, {"sha": "42e3f5f7e7e6db2b1ecd38fdcb1d3270f7de8372", "filename": "gcc/gimple-pretty-print.c", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a58cccac65539b1ab89af806b829b5423b6de9a/gcc%2Fgimple-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a58cccac65539b1ab89af806b829b5423b6de9a/gcc%2Fgimple-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-pretty-print.c?ref=6a58cccac65539b1ab89af806b829b5423b6de9a", "patch": "@@ -2021,10 +2021,6 @@ dump_gimple_mem_ops (pretty_printer *buffer, gimple gs, int spc, int flags)\n   tree vdef = gimple_vdef (gs);\n   tree vuse = gimple_vuse (gs);\n \n-  if (!ssa_operands_active (DECL_STRUCT_FUNCTION (current_function_decl))\n-      || !gimple_references_memory_p (gs))\n-    return;\n-\n   if (vdef != NULL_TREE)\n     {\n       pp_string (buffer, \"# \");"}, {"sha": "8290af285fb80a829f500e832f8515b42cb3af01", "filename": "gcc/gimple-ssa.h", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a58cccac65539b1ab89af806b829b5423b6de9a/gcc%2Fgimple-ssa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a58cccac65539b1ab89af806b829b5423b6de9a/gcc%2Fgimple-ssa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa.h?ref=6a58cccac65539b1ab89af806b829b5423b6de9a", "patch": "@@ -141,7 +141,7 @@ update_stmt (gimple s)\n   if (gimple_has_ops (s))\n     {\n       gimple_set_modified (s, true);\n-      update_stmt_operands (s);\n+      update_stmt_operands (cfun, s);\n     }\n }\n \n@@ -151,7 +151,19 @@ static inline void\n update_stmt_if_modified (gimple s)\n {\n   if (gimple_modified_p (s))\n-    update_stmt_operands (s);\n+    update_stmt_operands (cfun, s);\n+}\n+\n+/* Mark statement S as modified, and update it.  */\n+\n+static inline void\n+update_stmt_fn (struct function *fn, gimple s)\n+{\n+  if (gimple_has_ops (s))\n+    {\n+      gimple_set_modified (s, true);\n+      update_stmt_operands (fn, s);\n+    }\n }\n \n "}, {"sha": "9fbc94df4cf79a2fdabe192358dda7ec3075d916", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a58cccac65539b1ab89af806b829b5423b6de9a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a58cccac65539b1ab89af806b829b5423b6de9a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=6a58cccac65539b1ab89af806b829b5423b6de9a", "patch": "@@ -1,3 +1,8 @@\n+2013-11-29  Richard Biener  <rguenther@suse.de>\n+\n+\tPR middle-end/59208\n+\t* g++.dg/torture/pr59208.C: New testcase.\n+\n 2013-11-29  Jakub Jelinek  <jakub@redhat.com>\n \t    Yury Gribov  <y.gribov@samsung.com>\n "}, {"sha": "6d1ebe622d2f70bb612df12176c74e51de904501", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a58cccac65539b1ab89af806b829b5423b6de9a/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a58cccac65539b1ab89af806b829b5423b6de9a/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=6a58cccac65539b1ab89af806b829b5423b6de9a", "patch": "@@ -6540,7 +6540,7 @@ move_block_to_fn (struct function *dest_cfun, basic_block bb,\n \n       /* We cannot leave any operands allocated from the operand caches of\n \t the current function.  */\n-      free_stmt_operands (stmt);\n+      free_stmt_operands (cfun, stmt);\n       push_cfun (dest_cfun);\n       update_stmt (stmt);\n       pop_cfun ();"}, {"sha": "7f6a1503085bfbc0eb2531250049f00d61055dfc", "filename": "gcc/tree-if-conv.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a58cccac65539b1ab89af806b829b5423b6de9a/gcc%2Ftree-if-conv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a58cccac65539b1ab89af806b829b5423b6de9a/gcc%2Ftree-if-conv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-if-conv.c?ref=6a58cccac65539b1ab89af806b829b5423b6de9a", "patch": "@@ -212,7 +212,7 @@ free_bb_predicate (basic_block bb)\n       gimple_stmt_iterator i;\n \n       for (i = gsi_start (stmts); !gsi_end_p (i); gsi_next (&i))\n-\tfree_stmt_operands (gsi_stmt (i));\n+\tfree_stmt_operands (cfun, gsi_stmt (i));\n     }\n \n   free (bb->aux);"}, {"sha": "9a7002cc7df1f6189285f5f456bc974cc6ed6b97", "filename": "gcc/tree-ssa-operands.c", "status": "modified", "additions": 114, "deletions": 110, "changes": 224, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a58cccac65539b1ab89af806b829b5423b6de9a/gcc%2Ftree-ssa-operands.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a58cccac65539b1ab89af806b829b5423b6de9a/gcc%2Ftree-ssa-operands.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-operands.c?ref=6a58cccac65539b1ab89af806b829b5423b6de9a", "patch": "@@ -129,7 +129,7 @@ static tree build_vuse;\n    compilations of multiple functions.  */\n static bitmap_obstack operands_bitmap_obstack;\n \n-static void get_expr_operands (gimple, tree *, int);\n+static void get_expr_operands (struct function *, gimple, tree *, int);\n \n /* Number of functions with initialized ssa_operands.  */\n static int n_initialized = 0;\n@@ -217,7 +217,7 @@ init_ssa_operands (struct function *fn)\n /* Dispose of anything required by the operand routines.  */\n \n void\n-fini_ssa_operands (void)\n+fini_ssa_operands (struct function *fn)\n {\n   struct ssa_operand_memory_d *ptr;\n \n@@ -228,97 +228,97 @@ fini_ssa_operands (void)\n       build_vuse = NULL_TREE;\n     }\n \n-  gimple_ssa_operands (cfun)->free_uses = NULL;\n+  gimple_ssa_operands (fn)->free_uses = NULL;\n \n-  while ((ptr = gimple_ssa_operands (cfun)->operand_memory) != NULL)\n+  while ((ptr = gimple_ssa_operands (fn)->operand_memory) != NULL)\n     {\n-      gimple_ssa_operands (cfun)->operand_memory\n-\t= gimple_ssa_operands (cfun)->operand_memory->next;\n+      gimple_ssa_operands (fn)->operand_memory\n+\t= gimple_ssa_operands (fn)->operand_memory->next;\n       ggc_free (ptr);\n     }\n \n-  gimple_ssa_operands (cfun)->ops_active = false;\n+  gimple_ssa_operands (fn)->ops_active = false;\n \n   if (!n_initialized)\n     bitmap_obstack_release (&operands_bitmap_obstack);\n \n-  cfun->gimple_df->vop = NULL_TREE;\n+  fn->gimple_df->vop = NULL_TREE;\n }\n \n \n /* Return memory for an operand of size SIZE.  */\n \n static inline void *\n-ssa_operand_alloc (unsigned size)\n+ssa_operand_alloc (struct function *fn, unsigned size)\n {\n   char *ptr;\n \n   gcc_assert (size == sizeof (struct use_optype_d));\n \n-  if (gimple_ssa_operands (cfun)->operand_memory_index + size\n-      >= gimple_ssa_operands (cfun)->ssa_operand_mem_size)\n+  if (gimple_ssa_operands (fn)->operand_memory_index + size\n+      >= gimple_ssa_operands (fn)->ssa_operand_mem_size)\n     {\n       struct ssa_operand_memory_d *ptr;\n \n-      switch (gimple_ssa_operands (cfun)->ssa_operand_mem_size)\n+      switch (gimple_ssa_operands (fn)->ssa_operand_mem_size)\n \t{\n \tcase OP_SIZE_INIT:\n-\t  gimple_ssa_operands (cfun)->ssa_operand_mem_size = OP_SIZE_1;\n+\t  gimple_ssa_operands (fn)->ssa_operand_mem_size = OP_SIZE_1;\n \t  break;\n \tcase OP_SIZE_1:\n-\t  gimple_ssa_operands (cfun)->ssa_operand_mem_size = OP_SIZE_2;\n+\t  gimple_ssa_operands (fn)->ssa_operand_mem_size = OP_SIZE_2;\n \t  break;\n \tcase OP_SIZE_2:\n \tcase OP_SIZE_3:\n-\t  gimple_ssa_operands (cfun)->ssa_operand_mem_size = OP_SIZE_3;\n+\t  gimple_ssa_operands (fn)->ssa_operand_mem_size = OP_SIZE_3;\n \t  break;\n \tdefault:\n \t  gcc_unreachable ();\n \t}\n \n \n       ptr = ggc_alloc_ssa_operand_memory_d (sizeof (void *)\n-                        + gimple_ssa_operands (cfun)->ssa_operand_mem_size);\n+                        + gimple_ssa_operands (fn)->ssa_operand_mem_size);\n \n-      ptr->next = gimple_ssa_operands (cfun)->operand_memory;\n-      gimple_ssa_operands (cfun)->operand_memory = ptr;\n-      gimple_ssa_operands (cfun)->operand_memory_index = 0;\n+      ptr->next = gimple_ssa_operands (fn)->operand_memory;\n+      gimple_ssa_operands (fn)->operand_memory = ptr;\n+      gimple_ssa_operands (fn)->operand_memory_index = 0;\n     }\n \n-  ptr = &(gimple_ssa_operands (cfun)->operand_memory\n-\t  ->mem[gimple_ssa_operands (cfun)->operand_memory_index]);\n-  gimple_ssa_operands (cfun)->operand_memory_index += size;\n+  ptr = &(gimple_ssa_operands (fn)->operand_memory\n+\t  ->mem[gimple_ssa_operands (fn)->operand_memory_index]);\n+  gimple_ssa_operands (fn)->operand_memory_index += size;\n   return ptr;\n }\n \n \n /* Allocate a USE operand.  */\n \n static inline struct use_optype_d *\n-alloc_use (void)\n+alloc_use (struct function *fn)\n {\n   struct use_optype_d *ret;\n-  if (gimple_ssa_operands (cfun)->free_uses)\n+  if (gimple_ssa_operands (fn)->free_uses)\n     {\n-      ret = gimple_ssa_operands (cfun)->free_uses;\n-      gimple_ssa_operands (cfun)->free_uses\n-\t= gimple_ssa_operands (cfun)->free_uses->next;\n+      ret = gimple_ssa_operands (fn)->free_uses;\n+      gimple_ssa_operands (fn)->free_uses\n+\t= gimple_ssa_operands (fn)->free_uses->next;\n     }\n   else\n     ret = (struct use_optype_d *)\n-          ssa_operand_alloc (sizeof (struct use_optype_d));\n+          ssa_operand_alloc (fn, sizeof (struct use_optype_d));\n   return ret;\n }\n \n \n /* Adds OP to the list of uses of statement STMT after LAST.  */\n \n static inline use_optype_p\n-add_use_op (gimple stmt, tree *op, use_optype_p last)\n+add_use_op (struct function *fn, gimple stmt, tree *op, use_optype_p last)\n {\n   use_optype_p new_use;\n \n-  new_use = alloc_use ();\n+  new_use = alloc_use (fn);\n   USE_OP_PTR (new_use)->use = op;\n   link_imm_use_stmt (USE_OP_PTR (new_use), *op, stmt);\n   last->next = new_use;\n@@ -332,7 +332,7 @@ add_use_op (gimple stmt, tree *op, use_optype_p last)\n    TODO -- Make build_defs vec of tree *.  */\n \n static inline void\n-finalize_ssa_defs (gimple stmt)\n+finalize_ssa_defs (struct function *fn, gimple stmt)\n {\n   /* Pre-pend the vdef we may have built.  */\n   if (build_vdef != NULL_TREE)\n@@ -352,7 +352,7 @@ finalize_ssa_defs (gimple stmt)\n       if (TREE_CODE (gimple_vdef (stmt)) == SSA_NAME)\n \t{\n \t  unlink_stmt_vdef (stmt);\n-\t  release_ssa_name (gimple_vdef (stmt));\n+\t  release_ssa_name_fn (fn, gimple_vdef (stmt));\n \t}\n       gimple_set_vdef (stmt, NULL_TREE);\n     }\n@@ -361,8 +361,8 @@ finalize_ssa_defs (gimple stmt)\n   if (gimple_vdef (stmt)\n       && TREE_CODE (gimple_vdef (stmt)) != SSA_NAME)\n     {\n-      cfun->gimple_df->rename_vops = 1;\n-      cfun->gimple_df->ssa_renaming_needed = 1;\n+      fn->gimple_df->rename_vops = 1;\n+      fn->gimple_df->ssa_renaming_needed = 1;\n     }\n }\n \n@@ -371,7 +371,7 @@ finalize_ssa_defs (gimple stmt)\n    TODO -- Make build_uses vec of tree *.  */\n \n static inline void\n-finalize_ssa_uses (gimple stmt)\n+finalize_ssa_uses (struct function *fn, gimple stmt)\n {\n   unsigned new_i;\n   struct use_optype_d new_list;\n@@ -405,25 +405,25 @@ finalize_ssa_uses (gimple stmt)\n     {\n       for (ptr = old_ops; ptr; ptr = ptr->next)\n \tdelink_imm_use (USE_OP_PTR (ptr));\n-      old_ops->next = gimple_ssa_operands (cfun)->free_uses;\n-      gimple_ssa_operands (cfun)->free_uses = old_ops;\n+      old_ops->next = gimple_ssa_operands (fn)->free_uses;\n+      gimple_ssa_operands (fn)->free_uses = old_ops;\n     }\n \n   /* If we added a VUSE, make sure to set the operand if it is not already\n      present and mark it for renaming.  */\n   if (build_vuse != NULL_TREE\n       && gimple_vuse (stmt) == NULL_TREE)\n     {\n-      gimple_set_vuse (stmt, gimple_vop (cfun));\n-      cfun->gimple_df->rename_vops = 1;\n-      cfun->gimple_df->ssa_renaming_needed = 1;\n+      gimple_set_vuse (stmt, gimple_vop (fn));\n+      fn->gimple_df->rename_vops = 1;\n+      fn->gimple_df->ssa_renaming_needed = 1;\n     }\n \n   /* Now create nodes for all the new nodes.  */\n   for (new_i = 0; new_i < build_uses.length (); new_i++)\n     {\n       tree *op = (tree *) build_uses[new_i];\n-      last = add_use_op (stmt, op, last);\n+      last = add_use_op (fn, stmt, op, last);\n     }\n \n   /* Now set the stmt's operands.  */\n@@ -446,10 +446,10 @@ cleanup_build_arrays (void)\n /* Finalize all the build vectors, fill the new ones into INFO.  */\n \n static inline void\n-finalize_ssa_stmt_operands (gimple stmt)\n+finalize_ssa_stmt_operands (struct function *fn, gimple stmt)\n {\n-  finalize_ssa_defs (stmt);\n-  finalize_ssa_uses (stmt);\n+  finalize_ssa_defs (fn, stmt);\n+  finalize_ssa_uses (fn, stmt);\n   cleanup_build_arrays ();\n }\n \n@@ -509,7 +509,8 @@ append_vuse (tree var)\n /* Add virtual operands for STMT.  FLAGS is as in get_expr_operands.  */\n \n static void\n-add_virtual_operand (gimple stmt ATTRIBUTE_UNUSED, int flags)\n+add_virtual_operand (struct function *fn,\n+\t\t     gimple stmt ATTRIBUTE_UNUSED, int flags)\n {\n   /* Add virtual operands to the stmt, unless the caller has specifically\n      requested not to do that (used when adding operands inside an\n@@ -520,9 +521,9 @@ add_virtual_operand (gimple stmt ATTRIBUTE_UNUSED, int flags)\n   gcc_assert (!is_gimple_debug (stmt));\n \n   if (flags & opf_def)\n-    append_vdef (gimple_vop (cfun));\n+    append_vdef (gimple_vop (fn));\n   else\n-    append_vuse (gimple_vop (cfun));\n+    append_vuse (gimple_vop (fn));\n }\n \n \n@@ -532,7 +533,7 @@ add_virtual_operand (gimple stmt ATTRIBUTE_UNUSED, int flags)\n    added to virtual operands.  */\n \n static void\n-add_stmt_operand (tree *var_p, gimple stmt, int flags)\n+add_stmt_operand (struct function *fn, tree *var_p, gimple stmt, int flags)\n {\n   tree var = *var_p;\n \n@@ -546,7 +547,7 @@ add_stmt_operand (tree *var_p, gimple stmt, int flags)\n       else\n \tappend_use (var_p);\n       if (DECL_P (*var_p))\n-\tcfun->gimple_df->ssa_renaming_needed = 1;\n+\tfn->gimple_df->ssa_renaming_needed = 1;\n     }\n   else\n     {\n@@ -556,7 +557,7 @@ add_stmt_operand (tree *var_p, gimple stmt, int flags)\n \tgimple_set_has_volatile_ops (stmt, true);\n \n       /* The variable is a memory access.  Add virtual operands.  */\n-      add_virtual_operand (stmt, flags);\n+      add_virtual_operand (fn, stmt, flags);\n     }\n }\n \n@@ -596,7 +597,8 @@ mark_address_taken (tree ref)\n    FLAGS is as in get_expr_operands.  */\n \n static void\n-get_indirect_ref_operands (gimple stmt, tree expr, int flags)\n+get_indirect_ref_operands (struct function *fn,\n+\t\t\t   gimple stmt, tree expr, int flags)\n {\n   tree *pptr = &TREE_OPERAND (expr, 0);\n \n@@ -605,10 +607,10 @@ get_indirect_ref_operands (gimple stmt, tree expr, int flags)\n     gimple_set_has_volatile_ops (stmt, true);\n \n   /* Add the VOP.  */\n-  add_virtual_operand (stmt, flags);\n+  add_virtual_operand (fn, stmt, flags);\n \n   /* If requested, add a USE operand for the base pointer.  */\n-  get_expr_operands (stmt, pptr,\n+  get_expr_operands (fn, stmt, pptr,\n \t\t     opf_non_addressable | opf_use\n \t\t     | (flags & (opf_no_vops|opf_not_non_addressable)));\n }\n@@ -617,26 +619,29 @@ get_indirect_ref_operands (gimple stmt, tree expr, int flags)\n /* A subroutine of get_expr_operands to handle TARGET_MEM_REF.  */\n \n static void\n-get_tmr_operands (gimple stmt, tree expr, int flags)\n+get_tmr_operands (struct function *fn, gimple stmt, tree expr, int flags)\n {\n   if (!(flags & opf_no_vops)\n       && TREE_THIS_VOLATILE (expr))\n     gimple_set_has_volatile_ops (stmt, true);\n \n   /* First record the real operands.  */\n-  get_expr_operands (stmt, &TMR_BASE (expr), opf_use | (flags & opf_no_vops));\n-  get_expr_operands (stmt, &TMR_INDEX (expr), opf_use | (flags & opf_no_vops));\n-  get_expr_operands (stmt, &TMR_INDEX2 (expr), opf_use | (flags & opf_no_vops));\n-\n-  add_virtual_operand (stmt, flags);\n+  get_expr_operands (fn, stmt,\n+\t\t     &TMR_BASE (expr), opf_use | (flags & opf_no_vops));\n+  get_expr_operands (fn, stmt,\n+\t\t     &TMR_INDEX (expr), opf_use | (flags & opf_no_vops));\n+  get_expr_operands (fn, stmt,\n+\t\t     &TMR_INDEX2 (expr), opf_use | (flags & opf_no_vops));\n+\n+  add_virtual_operand (fn, stmt, flags);\n }\n \n \n /* If STMT is a call that may clobber globals and other symbols that\n    escape, add them to the VDEF/VUSE lists for it.  */\n \n static void\n-maybe_add_call_vops (gimple stmt)\n+maybe_add_call_vops (struct function *fn, gimple stmt)\n {\n   int call_flags = gimple_call_flags (stmt);\n \n@@ -649,17 +654,17 @@ maybe_add_call_vops (gimple stmt)\n \t A 'noreturn' function might, but since we don't return anyway\n \t there is no point in recording that.  */\n       if (!(call_flags & (ECF_PURE | ECF_CONST | ECF_NORETURN)))\n-\tadd_virtual_operand (stmt, opf_def);\n+\tadd_virtual_operand (fn, stmt, opf_def);\n       else if (!(call_flags & ECF_CONST))\n-\tadd_virtual_operand (stmt, opf_use);\n+\tadd_virtual_operand (fn, stmt, opf_use);\n     }\n }\n \n \n /* Scan operands in the ASM_EXPR stmt referred to in INFO.  */\n \n static void\n-get_asm_expr_operands (gimple stmt)\n+get_asm_expr_operands (struct function *fn, gimple stmt)\n {\n   size_t i, noutputs;\n   const char **oconstraints;\n@@ -686,7 +691,8 @@ get_asm_expr_operands (gimple stmt)\n       if (!allows_reg && allows_mem)\n \tmark_address_taken (TREE_VALUE (link));\n \n-      get_expr_operands (stmt, &TREE_VALUE (link), opf_def | opf_not_non_addressable);\n+      get_expr_operands (fn, stmt,\n+\t\t\t &TREE_VALUE (link), opf_def | opf_not_non_addressable);\n     }\n \n   /* Gather all input operands.  */\n@@ -702,12 +708,12 @@ get_asm_expr_operands (gimple stmt)\n       if (!allows_reg && allows_mem)\n \tmark_address_taken (TREE_VALUE (link));\n \n-      get_expr_operands (stmt, &TREE_VALUE (link), opf_not_non_addressable);\n+      get_expr_operands (fn, stmt, &TREE_VALUE (link), opf_not_non_addressable);\n     }\n \n   /* Clobber all memory and addressable symbols for asm (\"\" : : : \"memory\");  */\n   if (gimple_asm_clobbers_memory_p (stmt))\n-    add_virtual_operand (stmt, opf_def);\n+    add_virtual_operand (fn, stmt, opf_def);\n }\n \n \n@@ -716,7 +722,7 @@ get_asm_expr_operands (gimple stmt)\n    interpret the operands found.  */\n \n static void\n-get_expr_operands (gimple stmt, tree *expr_p, int flags)\n+get_expr_operands (struct function *fn, gimple stmt, tree *expr_p, int flags)\n {\n   enum tree_code code;\n   enum tree_code_class codeclass;\n@@ -755,27 +761,27 @@ get_expr_operands (gimple stmt, tree *expr_p, int flags)\n \t here are ARRAY_REF indices which will always be real operands\n \t (GIMPLE does not allow non-registers as array indices).  */\n       flags |= opf_no_vops;\n-      get_expr_operands (stmt, &TREE_OPERAND (expr, 0),\n+      get_expr_operands (fn, stmt, &TREE_OPERAND (expr, 0),\n \t\t\t flags | opf_not_non_addressable);\n       return;\n \n     case SSA_NAME:\n     case VAR_DECL:\n     case PARM_DECL:\n     case RESULT_DECL:\n-      add_stmt_operand (expr_p, stmt, flags);\n+      add_stmt_operand (fn, expr_p, stmt, flags);\n       return;\n \n     case DEBUG_EXPR_DECL:\n       gcc_assert (gimple_debug_bind_p (stmt));\n       return;\n \n     case MEM_REF:\n-      get_indirect_ref_operands (stmt, expr, flags);\n+      get_indirect_ref_operands (fn, stmt, expr, flags);\n       return;\n \n     case TARGET_MEM_REF:\n-      get_tmr_operands (stmt, expr, flags);\n+      get_tmr_operands (fn, stmt, expr, flags);\n       return;\n \n     case ARRAY_REF:\n@@ -788,20 +794,20 @@ get_expr_operands (gimple stmt, tree *expr_p, int flags)\n \t    && TREE_THIS_VOLATILE (expr))\n \t  gimple_set_has_volatile_ops (stmt, true);\n \n-\tget_expr_operands (stmt, &TREE_OPERAND (expr, 0), flags);\n+\tget_expr_operands (fn, stmt, &TREE_OPERAND (expr, 0), flags);\n \n \tif (code == COMPONENT_REF)\n \t  {\n \t    if (!(flags & opf_no_vops)\n \t\t&& TREE_THIS_VOLATILE (TREE_OPERAND (expr, 1)))\n \t      gimple_set_has_volatile_ops (stmt, true);\n-\t    get_expr_operands (stmt, &TREE_OPERAND (expr, 2), uflags);\n+\t    get_expr_operands (fn, stmt, &TREE_OPERAND (expr, 2), uflags);\n \t  }\n \telse if (code == ARRAY_REF || code == ARRAY_RANGE_REF)\n \t  {\n-            get_expr_operands (stmt, &TREE_OPERAND (expr, 1), uflags);\n-            get_expr_operands (stmt, &TREE_OPERAND (expr, 2), uflags);\n-            get_expr_operands (stmt, &TREE_OPERAND (expr, 3), uflags);\n+            get_expr_operands (fn, stmt, &TREE_OPERAND (expr, 1), uflags);\n+            get_expr_operands (fn, stmt, &TREE_OPERAND (expr, 2), uflags);\n+            get_expr_operands (fn, stmt, &TREE_OPERAND (expr, 3), uflags);\n \t  }\n \n \treturn;\n@@ -810,16 +816,16 @@ get_expr_operands (gimple stmt, tree *expr_p, int flags)\n     case WITH_SIZE_EXPR:\n       /* WITH_SIZE_EXPR is a pass-through reference to its first argument,\n \t and an rvalue reference to its second argument.  */\n-      get_expr_operands (stmt, &TREE_OPERAND (expr, 1), uflags);\n-      get_expr_operands (stmt, &TREE_OPERAND (expr, 0), flags);\n+      get_expr_operands (fn, stmt, &TREE_OPERAND (expr, 1), uflags);\n+      get_expr_operands (fn, stmt, &TREE_OPERAND (expr, 0), flags);\n       return;\n \n     case COND_EXPR:\n     case VEC_COND_EXPR:\n     case VEC_PERM_EXPR:\n-      get_expr_operands (stmt, &TREE_OPERAND (expr, 0), uflags);\n-      get_expr_operands (stmt, &TREE_OPERAND (expr, 1), uflags);\n-      get_expr_operands (stmt, &TREE_OPERAND (expr, 2), uflags);\n+      get_expr_operands (fn, stmt, &TREE_OPERAND (expr, 0), uflags);\n+      get_expr_operands (fn, stmt, &TREE_OPERAND (expr, 1), uflags);\n+      get_expr_operands (fn, stmt, &TREE_OPERAND (expr, 2), uflags);\n       return;\n \n     case CONSTRUCTOR:\n@@ -839,7 +845,7 @@ get_expr_operands (gimple stmt, tree *expr_p, int flags)\n \tfor (idx = 0;\n \t     vec_safe_iterate (CONSTRUCTOR_ELTS (expr), idx, &ce);\n \t     idx++)\n-\t  get_expr_operands (stmt, &ce->value, uflags);\n+\t  get_expr_operands (fn, stmt, &ce->value, uflags);\n \n \treturn;\n       }\n@@ -852,16 +858,16 @@ get_expr_operands (gimple stmt, tree *expr_p, int flags)\n \n     case VIEW_CONVERT_EXPR:\n     do_unary:\n-      get_expr_operands (stmt, &TREE_OPERAND (expr, 0), flags);\n+      get_expr_operands (fn, stmt, &TREE_OPERAND (expr, 0), flags);\n       return;\n \n     case COMPOUND_EXPR:\n     case OBJ_TYPE_REF:\n     case ASSERT_EXPR:\n     do_binary:\n       {\n-\tget_expr_operands (stmt, &TREE_OPERAND (expr, 0), flags);\n-\tget_expr_operands (stmt, &TREE_OPERAND (expr, 1), flags);\n+\tget_expr_operands (fn, stmt, &TREE_OPERAND (expr, 0), flags);\n+\tget_expr_operands (fn, stmt, &TREE_OPERAND (expr, 1), flags);\n \treturn;\n       }\n \n@@ -871,9 +877,9 @@ get_expr_operands (gimple stmt, tree *expr_p, int flags)\n     case WIDEN_MULT_MINUS_EXPR:\n     case FMA_EXPR:\n       {\n-\tget_expr_operands (stmt, &TREE_OPERAND (expr, 0), flags);\n-\tget_expr_operands (stmt, &TREE_OPERAND (expr, 1), flags);\n-\tget_expr_operands (stmt, &TREE_OPERAND (expr, 2), flags);\n+\tget_expr_operands (fn, stmt, &TREE_OPERAND (expr, 0), flags);\n+\tget_expr_operands (fn, stmt, &TREE_OPERAND (expr, 1), flags);\n+\tget_expr_operands (fn, stmt, &TREE_OPERAND (expr, 2), flags);\n \treturn;\n       }\n \n@@ -907,48 +913,48 @@ get_expr_operands (gimple stmt, tree *expr_p, int flags)\n    build_* operand vectors will have potential operands in them.  */\n \n static void\n-parse_ssa_operands (gimple stmt)\n+parse_ssa_operands (struct function *fn, gimple stmt)\n {\n   enum gimple_code code = gimple_code (stmt);\n   size_t i, n, start = 0;\n \n   switch (code)\n     {\n     case GIMPLE_ASM:\n-      get_asm_expr_operands (stmt);\n+      get_asm_expr_operands (fn, stmt);\n       break;\n \n     case GIMPLE_TRANSACTION:\n       /* The start of a transaction is a memory barrier.  */\n-      add_virtual_operand (stmt, opf_def | opf_use);\n+      add_virtual_operand (fn, stmt, opf_def | opf_use);\n       break;\n \n     case GIMPLE_DEBUG:\n       if (gimple_debug_bind_p (stmt)\n \t  && gimple_debug_bind_has_value_p (stmt))\n-\tget_expr_operands (stmt, gimple_debug_bind_get_value_ptr (stmt),\n+\tget_expr_operands (fn, stmt, gimple_debug_bind_get_value_ptr (stmt),\n \t\t\t   opf_use | opf_no_vops);\n       break;\n \n     case GIMPLE_RETURN:\n-      append_vuse (gimple_vop (cfun));\n+      append_vuse (gimple_vop (fn));\n       goto do_default;\n \n     case GIMPLE_CALL:\n       /* Add call-clobbered operands, if needed.  */\n-      maybe_add_call_vops (stmt);\n+      maybe_add_call_vops (fn, stmt);\n       /* FALLTHRU */\n \n     case GIMPLE_ASSIGN:\n-      get_expr_operands (stmt, gimple_op_ptr (stmt, 0), opf_def);\n+      get_expr_operands (fn, stmt, gimple_op_ptr (stmt, 0), opf_def);\n       start = 1;\n       /* FALLTHRU */\n \n     default:\n     do_default:\n       n = gimple_num_ops (stmt);\n       for (i = start; i < n; i++)\n-\tget_expr_operands (stmt, gimple_op_ptr (stmt, i), opf_use);\n+\tget_expr_operands (fn, stmt, gimple_op_ptr (stmt, i), opf_use);\n       break;\n     }\n }\n@@ -957,20 +963,20 @@ parse_ssa_operands (gimple stmt)\n /* Create an operands cache for STMT.  */\n \n static void\n-build_ssa_operands (gimple stmt)\n+build_ssa_operands (struct function *fn, gimple stmt)\n {\n   /* Initially assume that the statement has no volatile operands.  */\n   gimple_set_has_volatile_ops (stmt, false);\n \n   start_ssa_stmt_operands ();\n-  parse_ssa_operands (stmt);\n-  finalize_ssa_stmt_operands (stmt);\n+  parse_ssa_operands (fn, stmt);\n+  finalize_ssa_stmt_operands (fn, stmt);\n }\n \n /* Verifies SSA statement operands.  */\n \n DEBUG_FUNCTION bool\n-verify_ssa_operands (gimple stmt)\n+verify_ssa_operands (struct function *fn, gimple stmt)\n {\n   use_operand_p use_p;\n   def_operand_p def_p;\n@@ -982,7 +988,7 @@ verify_ssa_operands (gimple stmt)\n   /* build_ssa_operands w/o finalizing them.  */\n   gimple_set_has_volatile_ops (stmt, false);\n   start_ssa_stmt_operands ();\n-  parse_ssa_operands (stmt);\n+  parse_ssa_operands (fn, stmt);\n \n   /* Now verify the built operands are the same as present in STMT.  */\n   def = gimple_vdef (stmt);\n@@ -1059,7 +1065,7 @@ verify_ssa_operands (gimple stmt)\n    the stmt operand lists.  */\n \n void\n-free_stmt_operands (gimple stmt)\n+free_stmt_operands (struct function *fn, gimple stmt)\n {\n   use_optype_p uses = gimple_use_ops (stmt), last_use;\n \n@@ -1068,8 +1074,8 @@ free_stmt_operands (gimple stmt)\n       for (last_use = uses; last_use->next; last_use = last_use->next)\n \tdelink_imm_use (USE_OP_PTR (last_use));\n       delink_imm_use (USE_OP_PTR (last_use));\n-      last_use->next = gimple_ssa_operands (cfun)->free_uses;\n-      gimple_ssa_operands (cfun)->free_uses = uses;\n+      last_use->next = gimple_ssa_operands (fn)->free_uses;\n+      gimple_ssa_operands (fn)->free_uses = uses;\n       gimple_set_use_ops (stmt, NULL);\n     }\n \n@@ -1084,11 +1090,11 @@ free_stmt_operands (gimple stmt)\n /* Get the operands of statement STMT.  */\n \n void\n-update_stmt_operands (gimple stmt)\n+update_stmt_operands (struct function *fn, gimple stmt)\n {\n   /* If update_stmt_operands is called before SSA is initialized, do\n      nothing.  */\n-  if (!ssa_operands_active (cfun))\n+  if (!ssa_operands_active (fn))\n     return;\n \n   timevar_push (TV_TREE_OPS);\n@@ -1097,10 +1103,10 @@ update_stmt_operands (gimple stmt)\n      split_bbs_on_noreturn_calls during cfg cleanup.  */\n   if (is_gimple_call (stmt)\n       && gimple_call_noreturn_p (stmt))\n-    vec_safe_push (MODIFIED_NORETURN_CALLS (cfun), stmt);\n+    vec_safe_push (MODIFIED_NORETURN_CALLS (fn), stmt);\n \n   gcc_assert (gimple_modified_p (stmt));\n-  build_ssa_operands (stmt);\n+  build_ssa_operands (fn, stmt);\n   gimple_set_modified (stmt, false);\n \n   timevar_pop (TV_TREE_OPS);\n@@ -1117,8 +1123,6 @@ swap_ssa_operands (gimple stmt, tree *exp0, tree *exp1)\n   op0 = *exp0;\n   op1 = *exp1;\n \n-  gcc_checking_assert (ssa_operands_active (cfun));\n-\n   if (op0 != op1)\n     {\n       /* Attempt to preserve the relative positions of these two operands in"}, {"sha": "2d83800595564afa0a040a03b83408b85c1b8197", "filename": "gcc/tree-ssa-operands.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a58cccac65539b1ab89af806b829b5423b6de9a/gcc%2Ftree-ssa-operands.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a58cccac65539b1ab89af806b829b5423b6de9a/gcc%2Ftree-ssa-operands.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-operands.h?ref=6a58cccac65539b1ab89af806b829b5423b6de9a", "patch": "@@ -91,10 +91,10 @@ struct GTY(()) ssa_operands {\n \n extern bool ssa_operands_active (struct function *);\n extern void init_ssa_operands (struct function *fn);\n-extern void fini_ssa_operands (void);\n-extern bool verify_ssa_operands (gimple stmt);\n-extern void free_stmt_operands (gimple);\n-extern void update_stmt_operands (gimple);\n+extern void fini_ssa_operands (struct function *);\n+extern bool verify_ssa_operands (struct function *, gimple stmt);\n+extern void free_stmt_operands (struct function *, gimple);\n+extern void update_stmt_operands (struct function *, gimple);\n extern void swap_ssa_operands (gimple, tree *, tree *);\n extern bool verify_imm_links (FILE *f, tree var);\n "}, {"sha": "f1025b2b9d4d18f77f80a993b83cacd870e411c9", "filename": "gcc/tree-ssa.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a58cccac65539b1ab89af806b829b5423b6de9a/gcc%2Ftree-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a58cccac65539b1ab89af806b829b5423b6de9a/gcc%2Ftree-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa.c?ref=6a58cccac65539b1ab89af806b829b5423b6de9a", "patch": "@@ -1042,7 +1042,7 @@ verify_ssa (bool check_modified_stmt)\n \t      goto err;\n \t    }\n \n-\t  if (verify_ssa_operands (stmt))\n+\t  if (verify_ssa_operands (cfun, stmt))\n \t    {\n \t      print_gimple_stmt (stderr, stmt, 0, TDF_VOPS);\n \t      goto err;\n@@ -1195,7 +1195,7 @@ delete_tree_ssa (void)\n \n   /* We no longer maintain the SSA operand cache at this point.  */\n   if (ssa_operands_active (cfun))\n-    fini_ssa_operands ();\n+    fini_ssa_operands (cfun);\n \n   htab_delete (cfun->gimple_df->default_defs);\n   cfun->gimple_df->default_defs = NULL;"}, {"sha": "4e576977235b73859666e7235971a73015a28006", "filename": "gcc/tree-ssanames.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a58cccac65539b1ab89af806b829b5423b6de9a/gcc%2Ftree-ssanames.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a58cccac65539b1ab89af806b829b5423b6de9a/gcc%2Ftree-ssanames.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssanames.c?ref=6a58cccac65539b1ab89af806b829b5423b6de9a", "patch": "@@ -301,7 +301,7 @@ get_nonzero_bits (const_tree name)\n    other fields must be assumed clobbered.  */\n \n void\n-release_ssa_name (tree var)\n+release_ssa_name_fn (struct function *fn, tree var)\n {\n   if (!var)\n     return;\n@@ -341,7 +341,7 @@ release_ssa_name (tree var)\n       while (imm->next != imm)\n \tdelink_imm_use (imm->next);\n \n-      (*SSANAMES (cfun))[SSA_NAME_VERSION (var)] = NULL_TREE;\n+      (*SSANAMES (fn))[SSA_NAME_VERSION (var)] = NULL_TREE;\n       memset (var, 0, tree_size (var));\n \n       imm->prev = imm;\n@@ -363,7 +363,7 @@ release_ssa_name (tree var)\n       SSA_NAME_IN_FREE_LIST (var) = 1;\n \n       /* And finally put it on the free list.  */\n-      vec_safe_push (FREE_SSANAMES (cfun), var);\n+      vec_safe_push (FREE_SSANAMES (fn), var);\n     }\n }\n "}, {"sha": "3cb1bdaf4ebee5a6f15c6381617193c85f8aa812", "filename": "gcc/tree-ssanames.h", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a58cccac65539b1ab89af806b829b5423b6de9a/gcc%2Ftree-ssanames.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a58cccac65539b1ab89af806b829b5423b6de9a/gcc%2Ftree-ssanames.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssanames.h?ref=6a58cccac65539b1ab89af806b829b5423b6de9a", "patch": "@@ -81,7 +81,7 @@ extern void init_ssanames (struct function *, int);\n extern void fini_ssanames (void);\n extern void ssanames_print_statistics (void);\n extern tree make_ssa_name_fn (struct function *, tree, gimple);\n-extern void release_ssa_name (tree);\n+extern void release_ssa_name_fn (struct function *, tree);\n extern bool get_ptr_info_alignment (struct ptr_info_def *, unsigned int *,\n \t\t\t\t    unsigned int *);\n extern void mark_ptr_info_alignment_unknown (struct ptr_info_def *);\n@@ -127,6 +127,14 @@ duplicate_ssa_name (tree var, gimple stmt)\n   return duplicate_ssa_name_fn (cfun, var, stmt);\n }\n \n+/* Release the SSA name NAME used in function cfun.  */\n+\n+static inline void\n+release_ssa_name (tree name)\n+{\n+  release_ssa_name_fn (cfun, name);\n+}\n+\n /* Return an anonymous SSA_NAME node for type TYPE defined in statement STMT\n    in function cfun.  Arrange so that it uses NAME in dumps.  */\n "}]}