{"sha": "ae4d12ca9f1208a84a5e6d66aa1587cf5fb48b31", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWU0ZDEyY2E5ZjEyMDhhODRhNWU2ZDY2YWExNTg3Y2Y1ZmI0OGIzMQ==", "commit": {"author": {"name": "Nick Clifton", "email": "nickc@cygnus.com", "date": "1998-09-02T10:02:27Z"}, "committer": {"name": "Nick Clifton", "email": "nickc@gcc.gnu.org", "date": "1998-09-02T10:02:27Z"}, "message": "Change HANDLE_PRAGMA macro so that it will work with USE_CPPLIB\n\nFrom-SVN: r22166", "tree": {"sha": "f889acf6c571afc213d2fe87fc5b44ab0bd5f5d2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f889acf6c571afc213d2fe87fc5b44ab0bd5f5d2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ae4d12ca9f1208a84a5e6d66aa1587cf5fb48b31", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ae4d12ca9f1208a84a5e6d66aa1587cf5fb48b31", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ae4d12ca9f1208a84a5e6d66aa1587cf5fb48b31", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ae4d12ca9f1208a84a5e6d66aa1587cf5fb48b31/comments", "author": null, "committer": null, "parents": [{"sha": "f09db6e0cab711b2a0f3401174169452c2c92157", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f09db6e0cab711b2a0f3401174169452c2c92157", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f09db6e0cab711b2a0f3401174169452c2c92157"}], "stats": {"total": 169, "additions": 147, "deletions": 22}, "files": [{"sha": "e416eb82ebf1246b884ab939c50ddfc73e9a9d8b", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae4d12ca9f1208a84a5e6d66aa1587cf5fb48b31/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae4d12ca9f1208a84a5e6d66aa1587cf5fb48b31/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=ae4d12ca9f1208a84a5e6d66aa1587cf5fb48b31", "patch": "@@ -1,3 +1,16 @@\n+Wed Sep 02 09:25:29 1998  Nick Clifton  <nickc@cygnus.com>\n+\n+\t* lex.c (check_newline):  Call HANDLE_PRAGMA before\n+\tHANDLE_SYSV_PRAGMA if both are defined.  Generate warning messages\n+\tif unknown pragmas are encountered.\n+\t(handle_sysv_pragma): Interpret return code from\n+\thandle_pragma_token ().  Return success/failure indication rather\n+\tthan next unprocessed character. \n+\t(pragma_getc): New function: retrieves characters from the\n+\tinput stream.  Defined when HANDLE_PRAGMA is defined.\n+\t(pragma_ungetc): New function: replaces characters back into the\n+\tinput stream.  Defined when HANDLE_PRAGMA is defined.\n+\n 1998-09-01  Jason Merrill  <jason@yorick.cygnus.com>\n \n \t* decl2.c (output_vtable_inherit): Use %cDIGIT in the operands."}, {"sha": "e2ab945a0cdc2b768b5a539f5ff3f32b792927b9", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 74, "deletions": 15, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae4d12ca9f1208a84a5e6d66aa1587cf5fb48b31/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae4d12ca9f1208a84a5e6d66aa1587cf5fb48b31/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=ae4d12ca9f1208a84a5e6d66aa1587cf5fb48b31", "patch": "@@ -2216,6 +2216,32 @@ get_last_nonwhite_on_line ()\n   return c;\n }\n \n+#if defined HANDLE_PRAGMA\n+/* Local versions of these macros, that can be passed as function pointers.  */\n+static int\n+pragma_getc ()\n+{\n+  int c;\n+      \n+  if (nextchar != EOF)\n+    {\n+      c = nextchar;\n+      nextchar = EOF;\n+    }\n+  else\n+    c = getch ();\n+\n+  return c;\n+}\n+\n+static void\n+pragma_ungetc (arg)\n+     int arg;\n+{\n+  yyungetc (arg, 0);\n+}\n+#endif /* HANDLE_PRAGMA */\n+\n /* At the beginning of a line, increment the line number\n    and process any #-directive on this line.\n    If the line is a #-directive, read the entire line and return a newline.\n@@ -2282,21 +2308,29 @@ check_newline ()\n \t      else if (token == END_OF_LINE)\n \t\tgoto skipline;\n \n+#ifdef HANDLE_PRAGMA\n+\t      /* We invoke HANDLE_PRAGMA before HANDLE_SYSV_PRAGMA\n+\t\t (if both are defined), in order to give the back\n+\t\t end a chance to override the interpretation of\n+\t\t SYSV style pragmas.  */\n+\t      if (HANDLE_PRAGMA (pragma_getc, pragma_ungetc,\n+\t\t\t\t IDENTIFIER_POINTER (yylval.ttype)))\n+\t\tgoto skipline;\n+#endif /* HANDLE_PRAGMA */\n+\t      \n #ifdef HANDLE_SYSV_PRAGMA\n \t      if (handle_sysv_pragma (token))\n \t\tgoto skipline;\n-#else\n-#ifdef HANDLE_PRAGMA\n-#if USE_CPPLIB\n-              /* TODO: ??? */\n-              goto skipline;\n-#else\n-  \t      if (HANDLE_PRAGMA (finput, yylval.ttype))\n-  \t\tgoto skipline;\n-#endif /* !USE_CPPLIB */\n-#endif\n-#endif\n+#endif /* !HANDLE_SYSV_PRAGMA */\n+\n+\t      /* Issue a warning message if we have been asked to do so.\n+\t\t Ignoring unknown pragmas in system header file unless\n+\t\t an explcit -Wunknown-pragmas has been given. */\n+\t      if (warn_unknown_pragmas > 1\n+\t\t  || (warn_unknown_pragmas && ! in_system_header))\n+\t\twarning (\"ignoring pragma: %s\", token_buffer);\n \t    }\n+\t  \n \t  goto skipline;\n \t}\n       else if (c == 'd')\n@@ -4730,7 +4764,33 @@ handle_cp_pragma (pname)\n {\n   register int token;\n \n-  if (! strcmp (pname, \"unit\"))\n+  if (! strcmp (pname, \"vtable\"))\n+    {\n+      extern tree pending_vtables;\n+\n+      /* More follows: it must be a string constant (class name).  */\n+      token = real_yylex ();\n+      if (token != STRING || TREE_CODE (yylval.ttype) != STRING_CST)\n+\t{\n+\t  error (\"invalid #pragma vtable\");\n+\t  return -1;\n+\t}\n+\n+      if (write_virtuals != 2)\n+\t{\n+\t  warning (\"use `+e2' option to enable #pragma vtable\");\n+\t  return -1;\n+\t}\n+      pending_vtables\n+\t= perm_tree_cons (NULL_TREE,\n+\t\t\t  get_identifier (TREE_STRING_POINTER (yylval.ttype)),\n+\t\t\t  pending_vtables);\n+      token = real_yylex ();\n+      if (token != END_OF_LINE)\n+\twarning (\"trailing characters ignored\");\n+      return 1;\n+    }\n+  else if (! strcmp (pname, \"unit\"))\n     {\n       /* More follows: it must be a string constant (unit name).  */\n       token = real_yylex ();\n@@ -4895,7 +4955,7 @@ handle_sysv_pragma (token)\n \tcase TYPENAME:\n \tcase STRING:\n \tcase CONSTANT:\n-\t  handle_pragma_token (\"ignored\", yylval.ttype);\n+\t  handle_pragma_token (IDENTIFIER_POINTER(yylval.ttype), yylval.ttype);\n \t  break;\n \tcase '(':\n \t  handle_pragma_token (\"(\", NULL_TREE);\n@@ -4915,8 +4975,7 @@ handle_sysv_pragma (token)\n \t  break;\n \tcase END_OF_LINE:\n \tdefault:\n-\t  handle_pragma_token (NULL_PTR, NULL_TREE);\n-\t  return 1;\n+\t  return handle_pragma_token (NULL_PTR, NULL_TREE);\n \t}\n       token = real_yylex ();\n     }"}, {"sha": "30997b898f2c222285907b691281216c72aa1fe8", "filename": "gcc/f/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae4d12ca9f1208a84a5e6d66aa1587cf5fb48b31/gcc%2Ff%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae4d12ca9f1208a84a5e6d66aa1587cf5fb48b31/gcc%2Ff%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2FChangeLog?ref=ae4d12ca9f1208a84a5e6d66aa1587cf5fb48b31", "patch": "@@ -1,3 +1,14 @@\n+Wed Sep 02 09:25:29 1998  Nick Clifton  <nickc@cygnus.com>\n+\n+\t* lex.c (ffe_lex_hash):  Change how HANDLE_PRAGMA and\n+\tHANDLE_SYSV_PRAGMA would be called if they pragma parsing was\n+\tenabled in this code.\n+\tGenerate warning messages if unknown pragmas are encountered.\n+\t(pragma_getc): New function: retrieves characters from the\n+\tinput stream.  Defined when HANDLE_PRAGMA is defined.\n+\t(pragma_ungetc): New function: replaces characters back into the\n+\tinput stream.  Defined when HANDLE_PRAGMA is defined.\n+\n Tue Sep  1 10:00:21 1998  Craig Burley  <burley@gnu.org>\n \n \t* bugs.texi, g77.1, g77.texi, intdoc.in, news.texi: Doc updates"}, {"sha": "2ccdc078c03f895978479e4a5e6d36b3ac98938b", "filename": "gcc/f/lex.c", "status": "modified", "additions": 49, "deletions": 7, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae4d12ca9f1208a84a5e6d66aa1587cf5fb48b31/gcc%2Ff%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae4d12ca9f1208a84a5e6d66aa1587cf5fb48b31/gcc%2Ff%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Flex.c?ref=ae4d12ca9f1208a84a5e6d66aa1587cf5fb48b31", "patch": "@@ -1,5 +1,5 @@\n /* Implementation of Fortran lexer\n-   Copyright (C) 1995-1997 Free Software Foundation, Inc.\n+   Copyright (C) 1995-1998 Free Software Foundation, Inc.\n    Contributed by James Craig Burley (burley@gnu.org).\n \n This file is part of GNU Fortran.\n@@ -1077,6 +1077,23 @@ ffelex_get_directive_line_ (char **text, FILE *finput)\n    Returns the next character unhandled, which is always newline or EOF.  */\n \n #if FFECOM_targetCURRENT == FFECOM_targetGCC\n+\n+#if defined HANDLE_PRAGMA\n+/* Local versions of these macros, that can be passed as function pointers.  */\n+static int\n+pragma_getc ()\n+{\n+  return getc (finput);\n+}\n+\n+static void\n+pragma_ungetc (arg)\n+     int arg;\n+{\n+  ungetc (arg, finput);\n+}\n+#endif /* HANDLE_PRAGMA */\n+\n static int\n ffelex_hash_ (FILE *finput)\n {\n@@ -1105,17 +1122,42 @@ ffelex_hash_ (FILE *finput)\n \t      && ((c = getc (finput)) == ' ' || c == '\\t' || c == '\\n'\n \t\t  || c == EOF))\n \t    {\n-\t      goto skipline;\n #if 0\t/* g77 doesn't handle pragmas, so ignores them FOR NOW. */\n-#ifdef HANDLE_SYSV_PRAGMA\n-\t      return handle_sysv_pragma (finput, c);\n-#else /* !HANDLE_SYSV_PRAGMA */\n+\t      static char buffer [128];\n+\t      char * buff = buffer;\n+\n+\t      /* Read the pragma name into a buffer.  */\n+\t      while (isspace (c = getc (finput)))\n+\t\tcontinue;\n+\t      \n+\t      do\n+\t\t{\n+\t\t  * buff ++ = c;\n+\t\t  c = getc (finput);\n+\t\t}\n+\t      while (c != EOF && ! isspace (c) && c != '\\n'\n+\t\t     && buff < buffer + 128);\n+\n+\t      pragma_ungetc (c);\n+\t\t\n+\t      * -- buff = 0;\n #ifdef HANDLE_PRAGMA\n-\t      HANDLE_PRAGMA (finput);\n+\t      if (HANDLE_PRAGMA (pragma_getc, pragma_ungetc, buffer))\n+\t\tgoto skipline;\n #endif /* HANDLE_PRAGMA */\n-\t      goto skipline;\n+#ifdef HANDLE_SYSV_PRAGMA\n+\t      if (handle_sysv_pragma (buffer))\n+\t\tgoto skipline;\n #endif /* !HANDLE_SYSV_PRAGMA */\n+\n+\t      /* Issue a warning message if we have been asked to do so.\n+\t\t Ignoring unknown pragmas in system header file unless\n+\t\t an explcit -Wunknown-pragmas has been given. */\n+\t      if (warn_unknown_pragmas > 1\n+\t\t  || (warn_unknown_pragmas && ! in_system_header))\n+\t\twarning (\"ignoring pragma: %s\", token_buffer);\n #endif /* 0 */\n+\t      goto skipline;\n \t    }\n \t}\n "}]}