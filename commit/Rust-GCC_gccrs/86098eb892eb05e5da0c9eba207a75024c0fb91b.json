{"sha": "86098eb892eb05e5da0c9eba207a75024c0fb91b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODYwOThlYjg5MmViMDVlNWRhMGM5ZWJhMjA3YTc1MDI0YzBmYjkxYg==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2003-11-11T22:27:32Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2003-11-11T22:27:32Z"}, "message": "cp-tree.h (DECL_NAMESPACE_ASSOCIATIONS): New macro.\n\n        * cp-tree.h (DECL_NAMESPACE_ASSOCIATIONS): New macro.\n        * name-lookup.c (parse_using_directive): New fn.\n        (is_associated_namespace): New fn.\n        (arg_assoc_namespace): Also check associated namespaces.\n        * name-lookup.h: Declare new fns.\n        * pt.c (maybe_process_partial_specialization): Allow\n        specialization in associated namespace.\n        * parser.c (cp_parser_using_directive): Accept attributes.  Use\n        parse_using_directive.\n\nFrom-SVN: r73468", "tree": {"sha": "8082fe968555564efdd07e3add06e1110ab8b493", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8082fe968555564efdd07e3add06e1110ab8b493"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/86098eb892eb05e5da0c9eba207a75024c0fb91b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/86098eb892eb05e5da0c9eba207a75024c0fb91b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/86098eb892eb05e5da0c9eba207a75024c0fb91b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/86098eb892eb05e5da0c9eba207a75024c0fb91b/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "292d9f2bcd1b1f21ae717064c7c9823b3a9c83cc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/292d9f2bcd1b1f21ae717064c7c9823b3a9c83cc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/292d9f2bcd1b1f21ae717064c7c9823b3a9c83cc"}], "stats": {"total": 131, "additions": 128, "deletions": 3}, "files": [{"sha": "d3b8316b4649aab3797804d54040703ec0c80ea4", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86098eb892eb05e5da0c9eba207a75024c0fb91b/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86098eb892eb05e5da0c9eba207a75024c0fb91b/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=86098eb892eb05e5da0c9eba207a75024c0fb91b", "patch": "@@ -1,3 +1,15 @@\n+2003-11-11  Jason Merrill  <jason@redhat.com>\n+\n+\t* cp-tree.h (DECL_NAMESPACE_ASSOCIATIONS): New macro.\n+\t* name-lookup.c (parse_using_directive): New fn.\n+\t(is_associated_namespace): New fn.\n+\t(arg_assoc_namespace): Also check associated namespaces.\n+\t* name-lookup.h: Declare new fns.\n+\t* pt.c (maybe_process_partial_specialization): Allow\n+\tspecialization in associated namespace.\n+\t* parser.c (cp_parser_using_directive): Accept attributes.  Use\n+\tparse_using_directive.\n+\n 2003-11-10  Richard Henderson  <rth@redhat.com>\n \n \t* cvt.c (convert_to_void): Use void_zero_node after overload failure."}, {"sha": "def9b81e3510ffa9e9d60cc00b71b5df675633e6", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86098eb892eb05e5da0c9eba207a75024c0fb91b/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86098eb892eb05e5da0c9eba207a75024c0fb91b/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=86098eb892eb05e5da0c9eba207a75024c0fb91b", "patch": "@@ -2063,6 +2063,11 @@ struct lang_decl GTY(())\n    of a namespace, to record the transitive closure of using namespace.  */\n #define DECL_NAMESPACE_USERS(NODE) DECL_INITIAL (NAMESPACE_DECL_CHECK (NODE))\n \n+/* In a NAMESPACE_DECL, the list of namespaces which have associated\n+   themselves with this one.  */\n+#define DECL_NAMESPACE_ASSOCIATIONS(NODE) \\\n+  (NAMESPACE_DECL_CHECK (NODE)->decl.saved_tree)\n+\n /* In a NAMESPACE_DECL, points to the original namespace if this is\n    a namespace alias.  */\n #define DECL_NAMESPACE_ALIAS(NODE) \\"}, {"sha": "185c04fb63d3571f5125839e3d42be48a0a29d04", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86098eb892eb05e5da0c9eba207a75024c0fb91b/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86098eb892eb05e5da0c9eba207a75024c0fb91b/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=86098eb892eb05e5da0c9eba207a75024c0fb91b", "patch": "@@ -3286,6 +3286,33 @@ do_using_directive (tree namespace)\n     add_using_namespace (current_namespace, namespace, 0);\n }\n \n+/* Deal with a using-directive seen by the parser.  Currently we only\n+   handle attributes here, since they cannot appear inside a template.  */\n+\n+void\n+parse_using_directive (tree namespace, tree attribs)\n+{\n+  tree a;\n+\n+  do_using_directive (namespace);\n+\n+  for (a = attribs; a; a = TREE_CHAIN (a))\n+    {\n+      tree name = TREE_PURPOSE (a);\n+      if (is_attribute_p (\"strong\", name))\n+\t{\n+\t  if (!toplevel_bindings_p ())\n+\t    error (\"strong using only meaningful at namespace scope\");\n+\t  else\n+\t    DECL_NAMESPACE_ASSOCIATIONS (namespace)\n+\t      = tree_cons (current_namespace, 0,\n+\t\t\t   DECL_NAMESPACE_ASSOCIATIONS (namespace));\n+\t}\n+      else\n+\twarning (\"`%D' attribute directive ignored\", name);\n+    }\n+}\n+\n /* Like pushdecl, only it places X in the global scope if appropriate.\n    Calls cp_finish_decl to register the variable, initializing it with\n    *INIT, if INIT is non-NULL.  */\n@@ -4011,6 +4038,34 @@ add_function (struct arg_lookup *k, tree fn)\n   return false;\n }\n \n+/* Returns true iff CURRENT has declared itself to be an associated\n+   namespace of SCOPE via a strong using-directive (or transitive chain\n+   thereof).  Both are namespaces.  */\n+\n+bool\n+is_associated_namespace (tree current, tree scope)\n+{\n+  tree seen = NULL_TREE;\n+  tree todo = NULL_TREE;\n+  tree t;\n+  while (1)\n+    {\n+      if (scope == current)\n+\treturn true;\n+      seen = tree_cons (scope, NULL_TREE, seen);\n+      for (t = DECL_NAMESPACE_ASSOCIATIONS (scope); t; t = TREE_CHAIN (t))\n+\tif (!purpose_member (TREE_PURPOSE (t), seen))\n+\t  todo = tree_cons (TREE_PURPOSE (t), NULL_TREE, todo);\n+      if (todo)\n+\t{\n+\t  scope = TREE_PURPOSE (todo);\n+\t  todo = TREE_CHAIN (todo);\n+\t}\n+      else\n+\treturn false;\n+    }\n+}\n+\n /* Add functions of a namespace to the lookup structure.\n    Returns true on error.  */\n \n@@ -4022,6 +4077,12 @@ arg_assoc_namespace (struct arg_lookup *k, tree scope)\n   if (purpose_member (scope, k->namespaces))\n     return 0;\n   k->namespaces = tree_cons (scope, NULL_TREE, k->namespaces);\n+\n+  /* Check out our super-users.  */\n+  for (value = DECL_NAMESPACE_ASSOCIATIONS (scope); value;\n+       value = TREE_CHAIN (value))\n+    if (arg_assoc_namespace (k, TREE_PURPOSE (value)))\n+      return true;\n   \n   value = namespace_binding (k->name, scope);\n   if (!value)"}, {"sha": "df7615a0db65e6c109e7cff59fac81ccd42ee7e1", "filename": "gcc/cp/name-lookup.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86098eb892eb05e5da0c9eba207a75024c0fb91b/gcc%2Fcp%2Fname-lookup.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86098eb892eb05e5da0c9eba207a75024c0fb91b/gcc%2Fcp%2Fname-lookup.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.h?ref=86098eb892eb05e5da0c9eba207a75024c0fb91b", "patch": "@@ -306,6 +306,8 @@ extern void do_local_using_decl (tree);\n extern tree do_class_using_decl (tree);\n extern void do_using_directive (tree);\n extern tree lookup_arg_dependent (tree, tree, tree);\n+extern bool is_associated_namespace (tree, tree);\n+extern void parse_using_directive (tree, tree);\n \n \n /* Set *DECL to the (non-hidden) declaration for ID at global scope,"}, {"sha": "d08588fc4be80bd5f6001e8f70a90c1212e3289f", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86098eb892eb05e5da0c9eba207a75024c0fb91b/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86098eb892eb05e5da0c9eba207a75024c0fb91b/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=86098eb892eb05e5da0c9eba207a75024c0fb91b", "patch": "@@ -9078,6 +9078,7 @@ static void\n cp_parser_using_directive (cp_parser* parser)\n {\n   tree namespace_decl;\n+  tree attribs;\n \n   /* Look for the `using' keyword.  */\n   cp_parser_require_keyword (parser, RID_USING, \"`using'\");\n@@ -9092,8 +9093,10 @@ cp_parser_using_directive (cp_parser* parser)\n \t\t\t\t       /*type_p=*/false);\n   /* Get the namespace being used.  */\n   namespace_decl = cp_parser_namespace_name (parser);\n+  /* And any specified attributes.  */\n+  attribs = cp_parser_attributes_opt (parser);\n   /* Update the symbol table.  */\n-  do_using_directive (namespace_decl);\n+  parse_using_directive (namespace_decl, attribs);\n   /* Look for the final `;'.  */\n   cp_parser_require (parser, CPP_SEMICOLON, \"`;'\");\n }"}, {"sha": "cd93423ed6dd3af1031ebcdbcbd76e7c3ef29138", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86098eb892eb05e5da0c9eba207a75024c0fb91b/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86098eb892eb05e5da0c9eba207a75024c0fb91b/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=86098eb892eb05e5da0c9eba207a75024c0fb91b", "patch": "@@ -731,8 +731,10 @@ maybe_process_partial_specialization (tree type)\n       if (CLASSTYPE_IMPLICIT_INSTANTIATION (type)\n \t  && !COMPLETE_TYPE_P (type))\n \t{\n-\t  if (current_namespace\n-\t      != decl_namespace_context (CLASSTYPE_TI_TEMPLATE (type)))\n+\t  tree tpl_ns = decl_namespace_context (CLASSTYPE_TI_TEMPLATE (type));\n+\t  if (is_associated_namespace (current_namespace, tpl_ns))\n+\t    /* Same or super-using namespace.  */;\n+\t  else\n \t    {\n \t      pedwarn (\"specializing `%#T' in different namespace\", type);\n \t      cp_pedwarn_at (\"  from definition of `%#D'\","}, {"sha": "7825a12376de2c18ff94e57e431b7cdfe67852ba", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86098eb892eb05e5da0c9eba207a75024c0fb91b/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86098eb892eb05e5da0c9eba207a75024c0fb91b/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=86098eb892eb05e5da0c9eba207a75024c0fb91b", "patch": "@@ -7649,6 +7649,7 @@ Predefined Macros,cpp,The GNU C Preprocessor}).\n * Bound member functions:: You can extract a function pointer to the\n                         method denoted by a @samp{->*} or @samp{.*} expression.\n * C++ Attributes::      Variable, function, and type attributes for C++ only.\n+* Strong Using::      Strong using-directives for namespace composition.\n * Java Exceptions::     Tweaking exception handling to work with Java.\n * Deprecated Features:: Things will disappear from g++.\n * Backwards Compatibility:: Compatibilities with earlier definitions of C++.\n@@ -8249,6 +8250,45 @@ interface table mechanism, instead of regular virtual table dispatch.\n \n @end table\n \n+See also @xref{Strong Using}.\n+\n+@node Strong Using\n+@section Strong Using\n+\n+A using-directive with @code{__attribute ((strong))} is stronger\n+than a normal using-directive in two ways:\n+\n+@itemize @bullet\n+@item\n+Templates from the used namespace can be specialized as though they were members of the using namespace.\n+\n+@item\n+The using namespace is considered an associated namespace of all\n+templates in the used namespace for purposes of argument-dependent\n+name lookup.\n+@end itemize\n+\n+This is useful for composing a namespace transparently from\n+implementation namespaces.  For example:\n+\n+@smallexample\n+namespace std @{\n+  namespace debug @{\n+    template <class T> struct A @{ @};\n+  @}\n+  using namespace debug __attribute ((__strong__));\n+  template <> struct A<int> @{ @};   // ok to specialize\n+\n+  template <class T> void f (A<T>);\n+@}\n+\n+int main()\n+@{\n+  f (std::A<float>());             // lookup finds std::f\n+  f (std::A<int>());\n+@}\n+@end smallexample\n+\n @node Java Exceptions\n @section Java Exceptions\n "}]}