{"sha": "7c8f7639c5512799bed5c441e06964bd4ca32961", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2M4Zjc2MzljNTUxMjc5OWJlZDVjNDQxZTA2OTY0YmQ0Y2EzMjk2MQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2008-03-12T09:55:48Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2008-03-12T09:55:48Z"}, "message": "re PR middle-end/35549 (Invalid use of copy-in/out for shared vars in nested parallels)\n\n\tPR middle-end/35549\n\t* omp-low.c (maybe_lookup_decl): Constify first argument.\n\t(use_pointer_for_field): Change last argument from bool to\n\tomp_context *.  Disallow shared copy-in/out in nested\n\tparallel if decl is shared in outer parallel too.\n\t(build_outer_var_ref, scan_sharing_clauses,\n\tlower_rec_input_clauses, lower_copyprivate_clauses,\n\tlower_send_clauses, lower_send_shared_vars): Adjust callers.\n\n\t* testsuite/libgomp.c/pr35549.c: New test.\n\nFrom-SVN: r133136", "tree": {"sha": "cda5526042cb74fb68ccf75d855c64c449f59a35", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cda5526042cb74fb68ccf75d855c64c449f59a35"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7c8f7639c5512799bed5c441e06964bd4ca32961", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7c8f7639c5512799bed5c441e06964bd4ca32961", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7c8f7639c5512799bed5c441e06964bd4ca32961", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7c8f7639c5512799bed5c441e06964bd4ca32961/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "628781031e0b4f75bb9a59a045b5ed2a4daf568b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/628781031e0b4f75bb9a59a045b5ed2a4daf568b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/628781031e0b4f75bb9a59a045b5ed2a4daf568b"}], "stats": {"total": 102, "additions": 88, "deletions": 14}, "files": [{"sha": "db105a96e9322bcab081a2d3bcb3729723e03f15", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c8f7639c5512799bed5c441e06964bd4ca32961/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c8f7639c5512799bed5c441e06964bd4ca32961/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7c8f7639c5512799bed5c441e06964bd4ca32961", "patch": "@@ -1,3 +1,14 @@\n+2008-03-12  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR middle-end/35549\n+\t* omp-low.c (maybe_lookup_decl): Constify first argument.\n+\t(use_pointer_for_field): Change last argument from bool to\n+\tomp_context *.  Disallow shared copy-in/out in nested\n+\tparallel if decl is shared in outer parallel too.\n+\t(build_outer_var_ref, scan_sharing_clauses,\n+\tlower_rec_input_clauses, lower_copyprivate_clauses,\n+\tlower_send_clauses, lower_send_shared_vars): Adjust callers.\n+\n 2008-03-12  Victor Kaplansky  <victork@il.ibm.com>\n \t    Ira Rosen  <irar@il.ibm.com>\n "}, {"sha": "47114b6941f31291519fd88e913c61795e4dd71a", "filename": "gcc/omp-low.c", "status": "modified", "additions": 42, "deletions": 14, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c8f7639c5512799bed5c441e06964bd4ca32961/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c8f7639c5512799bed5c441e06964bd4ca32961/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=7c8f7639c5512799bed5c441e06964bd4ca32961", "patch": "@@ -456,7 +456,7 @@ lookup_decl (tree var, omp_context *ctx)\n }\n \n static inline tree\n-maybe_lookup_decl (tree var, omp_context *ctx)\n+maybe_lookup_decl (const_tree var, omp_context *ctx)\n {\n   tree *n;\n   n = (tree *) pointer_map_contains (ctx->cb.decl_map, var);\n@@ -479,18 +479,18 @@ maybe_lookup_field (tree var, omp_context *ctx)\n   return n ? (tree) n->value : NULL_TREE;\n }\n \n-/* Return true if DECL should be copied by pointer.  SHARED_P is true\n-   if DECL is to be shared.  */\n+/* Return true if DECL should be copied by pointer.  SHARED_CTX is\n+   the parallel context if DECL is to be shared.  */\n \n static bool\n-use_pointer_for_field (const_tree decl, bool shared_p)\n+use_pointer_for_field (const_tree decl, omp_context *shared_ctx)\n {\n   if (AGGREGATE_TYPE_P (TREE_TYPE (decl)))\n     return true;\n \n   /* We can only use copy-in/copy-out semantics for shared variables\n      when we know the value is not accessible from an outer scope.  */\n-  if (shared_p)\n+  if (shared_ctx)\n     {\n       /* ??? Trivially accessible from anywhere.  But why would we even\n \t be passing an address in this case?  Should we simply assert\n@@ -510,6 +510,34 @@ use_pointer_for_field (const_tree decl, bool shared_p)\n \t address taken.  */\n       if (TREE_ADDRESSABLE (decl))\n \treturn true;\n+\n+      /* Disallow copy-in/out in nested parallel if\n+\t decl is shared in outer parallel, otherwise\n+\t each thread could store the shared variable\n+\t in its own copy-in location, making the\n+\t variable no longer really shared.  */\n+      if (!TREE_READONLY (decl) && shared_ctx->is_nested)\n+\t{\n+\t  omp_context *up;\n+\n+\t  for (up = shared_ctx->outer; up; up = up->outer)\n+\t    if (maybe_lookup_decl (decl, up))\n+\t      break;\n+\n+\t  if (up && is_parallel_ctx (up))\n+\t    {\n+\t      tree c;\n+\n+\t      for (c = OMP_PARALLEL_CLAUSES (up->stmt);\n+\t\t   c; c = OMP_CLAUSE_CHAIN (c))\n+\t\tif (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_SHARED\n+\t\t    && OMP_CLAUSE_DECL (c) == decl)\n+\t\t  break;\n+\n+\t      if (c)\n+\t\treturn true;\n+\t    }\n+\t}\n     }\n \n   return false;\n@@ -596,7 +624,7 @@ build_outer_var_ref (tree var, omp_context *ctx)\n     }\n   else if (is_parallel_ctx (ctx))\n     {\n-      bool by_ref = use_pointer_for_field (var, false);\n+      bool by_ref = use_pointer_for_field (var, NULL);\n       x = build_receiver_ref (var, by_ref, ctx);\n     }\n   else if (ctx->outer)\n@@ -966,7 +994,7 @@ scan_sharing_clauses (tree clauses, omp_context *ctx)\n \t  gcc_assert (is_parallel_ctx (ctx));\n \t  decl = OMP_CLAUSE_DECL (c);\n \t  gcc_assert (!is_variable_sized (decl));\n-\t  by_ref = use_pointer_for_field (decl, true);\n+\t  by_ref = use_pointer_for_field (decl, ctx);\n \t  /* Global variables don't need to be copied,\n \t     the receiver side will use them directly.  */\n \t  if (is_global_var (maybe_lookup_decl_in_outer_ctx (decl, ctx)))\n@@ -1001,7 +1029,7 @@ scan_sharing_clauses (tree clauses, omp_context *ctx)\n \t\t   && ! is_global_var (maybe_lookup_decl_in_outer_ctx (decl,\n \t\t\t\t\t\t\t\t       ctx)))\n \t    {\n-\t      by_ref = use_pointer_for_field (decl, false);\n+\t      by_ref = use_pointer_for_field (decl, NULL);\n \t      install_var_field (decl, by_ref, ctx);\n \t    }\n \t  install_var_local (decl, ctx);\n@@ -1014,7 +1042,7 @@ scan_sharing_clauses (tree clauses, omp_context *ctx)\n \n \tcase OMP_CLAUSE_COPYIN:\n \t  decl = OMP_CLAUSE_DECL (c);\n-\t  by_ref = use_pointer_for_field (decl, false);\n+\t  by_ref = use_pointer_for_field (decl, NULL);\n \t  install_var_field (decl, by_ref, ctx);\n \t  break;\n \n@@ -1751,7 +1779,7 @@ lower_rec_input_clauses (tree clauses, tree *ilist, tree *dlist,\n \t      /* Set up the DECL_VALUE_EXPR for shared variables now.  This\n \t\t needs to be delayed until after fixup_child_record_type so\n \t\t that we get the correct type during the dereference.  */\n-\t      by_ref = use_pointer_for_field (var, true);\n+\t      by_ref = use_pointer_for_field (var, ctx);\n \t      x = build_receiver_ref (var, by_ref, ctx);\n \t      SET_DECL_VALUE_EXPR (new_var, x);\n \t      DECL_HAS_VALUE_EXPR_P (new_var) = 1;\n@@ -1794,7 +1822,7 @@ lower_rec_input_clauses (tree clauses, tree *ilist, tree *dlist,\n \t      break;\n \n \t    case OMP_CLAUSE_COPYIN:\n-\t      by_ref = use_pointer_for_field (var, false);\n+\t      by_ref = use_pointer_for_field (var, NULL);\n \t      x = build_receiver_ref (var, by_ref, ctx);\n \t      x = lang_hooks.decls.omp_clause_assign_op (c, new_var, x);\n \t      append_to_statement_list (x, &copyin_seq);\n@@ -2007,7 +2035,7 @@ lower_copyprivate_clauses (tree clauses, tree *slist, tree *rlist,\n \tcontinue;\n \n       var = OMP_CLAUSE_DECL (c);\n-      by_ref = use_pointer_for_field (var, false);\n+      by_ref = use_pointer_for_field (var, NULL);\n \n       ref = build_sender_ref (var, ctx);\n       x = lookup_decl_in_outer_ctx (var, ctx);\n@@ -2059,7 +2087,7 @@ lower_send_clauses (tree clauses, tree *ilist, tree *olist, omp_context *ctx)\n \tcontinue;\n       if (is_variable_sized (val))\n \tcontinue;\n-      by_ref = use_pointer_for_field (val, false);\n+      by_ref = use_pointer_for_field (val, NULL);\n \n       switch (OMP_CLAUSE_CODE (c))\n \t{\n@@ -2129,7 +2157,7 @@ lower_send_shared_vars (tree *ilist, tree *olist, omp_context *ctx)\n \t mapping for OVAR.  */\n       var = lookup_decl_in_outer_ctx (ovar, ctx);\n \n-      if (use_pointer_for_field (ovar, true))\n+      if (use_pointer_for_field (ovar, ctx))\n \t{\n \t  x = build_sender_ref (ovar, ctx);\n \t  var = build_fold_addr_expr (var);"}, {"sha": "3078243448771033a434ac87f819b27cbba0b600", "filename": "libgomp/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c8f7639c5512799bed5c441e06964bd4ca32961/libgomp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c8f7639c5512799bed5c441e06964bd4ca32961/libgomp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2FChangeLog?ref=7c8f7639c5512799bed5c441e06964bd4ca32961", "patch": "@@ -1,3 +1,8 @@\n+2008-03-12  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR middle-end/35549\n+\t* testsuite/libgomp.c/pr35549.c: New test.\n+\n 2008-03-06  Jakub Jelinek  <jakub@redhat.com>\n \n \t* testsuite/libgomp.c/atomic-3.c: New test."}, {"sha": "269a0c26290c5e9b56c6b180e55277de5a9bc0dc", "filename": "libgomp/testsuite/libgomp.c/pr35549.c", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c8f7639c5512799bed5c441e06964bd4ca32961/libgomp%2Ftestsuite%2Flibgomp.c%2Fpr35549.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c8f7639c5512799bed5c441e06964bd4ca32961/libgomp%2Ftestsuite%2Flibgomp.c%2Fpr35549.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Fpr35549.c?ref=7c8f7639c5512799bed5c441e06964bd4ca32961", "patch": "@@ -0,0 +1,30 @@\n+/* PR middle-end/35549 */\n+/* { dg-do run } */\n+\n+#include <omp.h>\n+#include <stdlib.h>\n+\n+int\n+main (void)\n+{\n+  int i = 6, n = 0;\n+  omp_set_dynamic (0);\n+  omp_set_nested (1);\n+  #pragma omp parallel shared (i) num_threads (3)\n+  {\n+    if (omp_get_num_threads () != 3)\n+      #pragma omp atomic\n+\tn += 1;\n+    #pragma omp parallel shared (i) num_threads (4)\n+    {\n+      if (omp_get_num_threads () != 4)\n+\t#pragma omp atomic\n+\t  n += 1;\n+      #pragma omp critical\n+\ti += 1;\n+    }\n+  }\n+  if (n == 0 && i != 6 + 3 * 4)\n+    abort ();\n+  return 0;\n+}"}]}