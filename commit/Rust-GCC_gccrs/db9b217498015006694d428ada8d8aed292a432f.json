{"sha": "db9b217498015006694d428ada8d8aed292a432f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGI5YjIxNzQ5ODAxNTAwNjY5NGQ0MjhhZGE4ZDhhZWQyOTJhNDMyZg==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2000-04-11T20:16:36Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2000-04-11T20:16:36Z"}, "message": "cp-tree.h (cp_tree_index): Add CPTI_DTOR_IDENTIFIER.\n\n\t* cp-tree.h (cp_tree_index): Add CPTI_DTOR_IDENTIFIER.\n\t(complete_dtor_identifier): New macro.\n\t(CLASSTYPE_FIRST_CONVERSION): Remove.\n\t(CLASSTYPE_CONSTRUCTOR_SLOT): New macro.\n\t(CLASSTYPE_DESTRUCTOR_SLOT): Likewise.\n\t(CLASSTYPE_FIRST_CONVERSION_SLOT): Likewise.\n\t(CLASSTYPE_CONSTRUCTORS): Likewise.\n\t(CLASSTYPE_DESTRUCTORS): Likewise.\n\t(lang_decl): Add cloned_function.\n\t(DECL_COMPLETE_CONSTRUCTOR_P): New macro.\n\t(DECL_BASE_CONSTRUCTOR_P): Likewise.\n\t(DECL_MAYBE_IN_CHARGE_CONSTRUCTOR_P): Likewise.\n\t(DECL_MAYBE_IN_CHARGE_DESTRUCTOR_P): Likewise.\n\t(DECL_CLONED_FUNCTION_P): Likewise.\n\t(DECL_CLONED_FUNCTION): Likewise.\n\t(clone_function_decl): Declare.\n\t(maybe_clone_body): Likewise.\n\t* call.c (build_user_type_conversion_1): Call complete object\n\tconstructors in the new ABI.\n\t(build_new_method_call): Don't add in-charge parameters under the\n\tnew ABI.\n\t* class.c (add_method): Use DECL_MAYBE_IN_CHARGE_CONSTRUCTOR_P,\n\tDECL_MAYBE_IN_CHARGE_DESTRUCTOR_P, CLASSTYPE_CONSTRUCTOR_SLOT, and\n\tCLASSTYPE_DESTRUCTOR_SLOT.\n\t(build_clone): New function.\n\t(clone_function_decl): Likewise.\n\t(clone_constructors_and_destructors): Likewise.\n\t(check_bases_and_members): Use it.\n\t* decl.c (iniitialize_predefined_identifiers): Initialize\n\tcomplete_dtor_identifier.\n\t(finish_function): Don't add extra code to a clone.\n\t(lang_mark_tree): Mark cloned_function.\n\t* decl2.c (mark_used): Don't bother trying to instantiate things\n\twe synthesized.\n\t* dump.c (dequeue_and_dump): Don't dump CP_DECL_CONTEXT twice.\n\t* method.c (set_mangled_name_for_decl): Don't treat clones as\n\tconstructors.\n\t(synthesize_method): Sythesize cloned functions, not the clones.\n\t* optimize.c (inline_data): Update comment on ret_label.\n\t(remap_block): Don't assume DECL_INITIAL exists.\n\t(copy_body_r): Allow ret_label to be NULL.\n\t(maybe_clone_body): Define.\n\t* pt.c (tsubst_decl): Handle clones.\n\t(instantiate_clone): New function.\n\t(instantiate_template): Use it.\n\t(set_mangled_name_for_template_decl): Don't treat clones as\n\tconstructors.\n\t* search.c (lookup_fnfields_1): Use CLASSTYPE_CONSTRUCTOR_SLOT,\n\tCLASSTYPE_DESTRUCTOR_SLOT, and CLASSTYPE_FIRST_CONVERSION_SLOT.\n\t* semantics.c (expand_body): Clone function bodies as necessary.\n\nFrom-SVN: r33084", "tree": {"sha": "00bde8ebf754ce1bd6c1c550c95312c0647e115f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/00bde8ebf754ce1bd6c1c550c95312c0647e115f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/db9b217498015006694d428ada8d8aed292a432f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/db9b217498015006694d428ada8d8aed292a432f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/db9b217498015006694d428ada8d8aed292a432f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/db9b217498015006694d428ada8d8aed292a432f/comments", "author": null, "committer": null, "parents": [{"sha": "c23c855f38f4287ce82018ca40892379bcdbf715", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c23c855f38f4287ce82018ca40892379bcdbf715", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c23c855f38f4287ce82018ca40892379bcdbf715"}], "stats": {"total": 561, "additions": 515, "deletions": 46}, "files": [{"sha": "18f252d2bf904fe1a100b2a6d9c7b4e0b2a6a8b1", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db9b217498015006694d428ada8d8aed292a432f/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db9b217498015006694d428ada8d8aed292a432f/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=db9b217498015006694d428ada8d8aed292a432f", "patch": "@@ -1,5 +1,56 @@\n 2000-04-11  Mark Mitchell  <mark@codesourcery.com>\n \n+\t* cp-tree.h (cp_tree_index): Add CPTI_DTOR_IDENTIFIER.\n+\t(complete_dtor_identifier): New macro.\n+\t(CLASSTYPE_FIRST_CONVERSION): Remove.\n+\t(CLASSTYPE_CONSTRUCTOR_SLOT): New macro.\n+\t(CLASSTYPE_DESTRUCTOR_SLOT): Likewise.\n+\t(CLASSTYPE_FIRST_CONVERSION_SLOT): Likewise.\n+\t(CLASSTYPE_CONSTRUCTORS): Likewise.\n+\t(CLASSTYPE_DESTRUCTORS): Likewise.\n+\t(lang_decl): Add cloned_function.\n+\t(DECL_COMPLETE_CONSTRUCTOR_P): New macro.\n+\t(DECL_BASE_CONSTRUCTOR_P): Likewise.\n+\t(DECL_MAYBE_IN_CHARGE_CONSTRUCTOR_P): Likewise.\n+\t(DECL_MAYBE_IN_CHARGE_DESTRUCTOR_P): Likewise.\n+\t(DECL_CLONED_FUNCTION_P): Likewise.\n+\t(DECL_CLONED_FUNCTION): Likewise.\n+\t(clone_function_decl): Declare.\n+\t(maybe_clone_body): Likewise.\n+\t* call.c (build_user_type_conversion_1): Call complete object\n+\tconstructors in the new ABI.\n+\t(build_new_method_call): Don't add in-charge parameters under the\n+\tnew ABI.\n+\t* class.c (add_method): Use DECL_MAYBE_IN_CHARGE_CONSTRUCTOR_P,\n+\tDECL_MAYBE_IN_CHARGE_DESTRUCTOR_P, CLASSTYPE_CONSTRUCTOR_SLOT, and\n+\tCLASSTYPE_DESTRUCTOR_SLOT.\n+\t(build_clone): New function.\n+\t(clone_function_decl): Likewise.\n+\t(clone_constructors_and_destructors): Likewise.\n+\t(check_bases_and_members): Use it.\n+\t* decl.c (iniitialize_predefined_identifiers): Initialize\n+\tcomplete_dtor_identifier.\n+\t(finish_function): Don't add extra code to a clone.\n+\t(lang_mark_tree): Mark cloned_function.\n+\t* decl2.c (mark_used): Don't bother trying to instantiate things\n+\twe synthesized.\n+\t* dump.c (dequeue_and_dump): Don't dump CP_DECL_CONTEXT twice.\n+\t* method.c (set_mangled_name_for_decl): Don't treat clones as\n+\tconstructors.\n+\t(synthesize_method): Sythesize cloned functions, not the clones.\n+\t* optimize.c (inline_data): Update comment on ret_label.\n+\t(remap_block): Don't assume DECL_INITIAL exists.\n+\t(copy_body_r): Allow ret_label to be NULL.\n+\t(maybe_clone_body): Define.\n+\t* pt.c (tsubst_decl): Handle clones.\n+\t(instantiate_clone): New function.\n+\t(instantiate_template): Use it.\n+\t(set_mangled_name_for_template_decl): Don't treat clones as\n+\tconstructors.\n+\t* search.c (lookup_fnfields_1): Use CLASSTYPE_CONSTRUCTOR_SLOT,\n+\tCLASSTYPE_DESTRUCTOR_SLOT, and CLASSTYPE_FIRST_CONVERSION_SLOT.\n+\t* semantics.c (expand_body): Clone function bodies as necessary.\n+\t\n \t* optimize.c (remap_decl): Avoid sharing structure for arrays\n \twhose size is only known at run-time.\n \t* tree.c (copy_tree_r): Don't copy PARM_DECLs."}, {"sha": "c0032488e9b37e045c1c71a0de62f38ebcf22602", "filename": "gcc/cp/call.c", "status": "modified", "additions": 22, "deletions": 13, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db9b217498015006694d428ada8d8aed292a432f/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db9b217498015006694d428ada8d8aed292a432f/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=db9b217498015006694d428ada8d8aed292a432f", "patch": "@@ -2277,7 +2277,12 @@ build_user_type_conversion_1 (totype, expr, flags)\n   tree templates = NULL_TREE;\n \n   if (IS_AGGR_TYPE (totype))\n-    ctors = lookup_fnfields (TYPE_BINFO (totype), ctor_identifier, 0);\n+    ctors = lookup_fnfields (TYPE_BINFO (totype),\n+\t\t\t     (flag_new_abi \n+\t\t\t      ? complete_ctor_identifier\n+\t\t\t      : ctor_identifier),\n+\t\t\t     0);\n+\n   if (IS_AGGR_TYPE (fromtype)\n       && (! IS_AGGR_TYPE (totype) || ! DERIVED_FROM_P (totype, fromtype)))\n     convs = lookup_conversions (fromtype);\n@@ -4253,22 +4258,26 @@ build_new_method_call (instance, name, args, basetype_path, flags)\n       || name == base_ctor_identifier)\n     {\n       pretty_name = constructor_name (basetype);\n-      /* Add the in-charge parameter as an implicit first argument.  */\n-      if (TYPE_USES_VIRTUAL_BASECLASSES (basetype))\n+\n+      if (!flag_new_abi)\n \t{\n-\t  tree in_charge;\n+\t  /* Add the in-charge parameter as an implicit first argument.  */\n+\t  if (TYPE_USES_VIRTUAL_BASECLASSES (basetype))\n+\t    {\n+\t      tree in_charge;\n \n-\t  if (name == complete_ctor_identifier)\n-\t    in_charge = integer_one_node;\n-\t  else\n-\t    in_charge = integer_zero_node;\n+\t      if (name == complete_ctor_identifier)\n+\t\tin_charge = integer_one_node;\n+\t      else\n+\t\tin_charge = integer_zero_node;\n \n-\t  args = tree_cons (NULL_TREE, in_charge, args);\n-\t}\n+\t      args = tree_cons (NULL_TREE, in_charge, args);\n+\t    }\n \n-      /* We want to call the normal constructor function under the old\n-\t ABI.  */\n-      name = ctor_identifier;\n+\t  /* We want to call the normal constructor function under the\n+\t     old ABI.  */\n+\t  name = ctor_identifier;\n+\t}\n     }\n   else\n     pretty_name = name;"}, {"sha": "d954ac0b736b828845650df3be693b8ae54ccf20", "filename": "gcc/cp/class.c", "status": "modified", "additions": 157, "deletions": 5, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db9b217498015006694d428ada8d8aed292a432f/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db9b217498015006694d428ada8d8aed292a432f/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=db9b217498015006694d428ada8d8aed292a432f", "patch": "@@ -174,6 +174,8 @@ static void build_vcall_and_vbase_vtbl_entries PARAMS ((tree,\n \t\t\t\t\t\t\tvcall_offset_data *));\n static tree dfs_mark_primary_bases PARAMS ((tree, void *));\n static void mark_primary_bases PARAMS ((tree));\n+static void clone_constructors_and_destructors PARAMS ((tree));\n+static tree build_clone PARAMS ((tree, tree));\n \n /* Variables shared between class.c and call.c.  */\n \n@@ -1150,14 +1152,15 @@ add_method (type, fields, method)\n       method_vec = CLASSTYPE_METHOD_VEC (type);\n       len = TREE_VEC_LENGTH (method_vec);\n \n-      if (DECL_NAME (method) == constructor_name (type))\n-\t/* A new constructor or destructor.  Constructors go in \n-\t   slot 0; destructors go in slot 1.  */\n-\tslot = DESTRUCTOR_NAME_P (DECL_ASSEMBLER_NAME (method)) ? 1 : 0;\n+      /* Constructors and destructors go in special slots.  */\n+      if (DECL_MAYBE_IN_CHARGE_CONSTRUCTOR_P (method))\n+\tslot = CLASSTYPE_CONSTRUCTOR_SLOT;\n+      else if (DECL_MAYBE_IN_CHARGE_DESTRUCTOR_P (method))\n+\tslot = CLASSTYPE_DESTRUCTOR_SLOT;\n       else\n \t{\n \t  /* See if we already have an entry with this name.  */\n-\t  for (slot = 2; slot < len; ++slot)\n+\t  for (slot = CLASSTYPE_FIRST_CONVERSION_SLOT; slot < len; ++slot)\n \t    if (!TREE_VEC_ELT (method_vec, slot)\n \t\t|| (DECL_NAME (OVL_CURRENT (TREE_VEC_ELT (method_vec, \n \t\t\t\t\t\t\t  slot))) \n@@ -3855,6 +3858,151 @@ check_methods (t)\n     }\n }\n \n+/* FN is a constructor or destructor.  Clone the declaration to create\n+   a specialized in-charge or not-in-charge version, as indicated by\n+   NAME.  */\n+\n+static tree\n+build_clone (fn, name)\n+     tree fn;\n+     tree name;\n+{\n+  tree parms;\n+  tree clone;\n+\n+  /* Copy the function.  */\n+  clone = copy_decl (fn);\n+  /* Remember where this function came from.  */\n+  DECL_CLONED_FUNCTION (clone) = fn;\n+  /* Reset the function name.  */\n+  DECL_NAME (clone) = name;\n+  DECL_ASSEMBLER_NAME (clone) = DECL_NAME (clone);\n+  /* There's no pending inline data for this function.  */\n+  DECL_PENDING_INLINE_INFO (clone) = NULL;\n+  DECL_PENDING_INLINE_P (clone) = 0;\n+  /* And it hasn't yet been deferred.  */\n+  DECL_DEFERRED_FN (clone) = 0;\n+\n+  /* If there was an in-charge paramter, drop it from the function\n+     type.  */\n+  if (DECL_HAS_IN_CHARGE_PARM_P (clone))\n+    {\n+      tree basetype;\n+      tree parmtypes;\n+      tree exceptions;\n+\n+      exceptions = TYPE_RAISES_EXCEPTIONS (TREE_TYPE (clone));\n+      basetype = TYPE_METHOD_BASETYPE (TREE_TYPE (clone));\n+      parmtypes = TYPE_ARG_TYPES (TREE_TYPE (clone));\n+      /* Skip the `this' parameter.  */\n+      parmtypes = TREE_CHAIN (parmtypes);\n+      /* Skip the in-charge parameter.  */\n+      parmtypes = TREE_CHAIN (parmtypes);\n+      TREE_TYPE (clone) \n+\t= build_cplus_method_type (basetype,\n+\t\t\t\t   TREE_TYPE (TREE_TYPE (clone)),\n+\t\t\t\t   parmtypes);\n+      if (exceptions)\n+\tTREE_TYPE (clone) = build_exception_variant (TREE_TYPE (clone),\n+\t\t\t\t\t\t     exceptions);\n+    }\n+\n+  /* Copy the function parameters.  But, DECL_ARGUMENTS aren't\n+     function parameters; instead, those are the template parameters.  */\n+  if (TREE_CODE (clone) != TEMPLATE_DECL)\n+    {\n+      DECL_ARGUMENTS (clone) = copy_list (DECL_ARGUMENTS (clone));\n+      /* Remove the in-charge parameter.  */\n+      if (DECL_HAS_IN_CHARGE_PARM_P (clone))\n+\t{\n+\t  TREE_CHAIN (DECL_ARGUMENTS (clone))\n+\t    = TREE_CHAIN (TREE_CHAIN (DECL_ARGUMENTS (clone)));\n+\t  DECL_HAS_IN_CHARGE_PARM_P (clone) = 0;\n+\t}\n+      for (parms = DECL_ARGUMENTS (clone); parms; parms = TREE_CHAIN (parms))\n+\t{\n+\t  DECL_CONTEXT (parms) = clone;\n+\t  copy_lang_decl (parms);\n+\t}\n+    }\n+\n+  /* Mangle the function name.  */\n+  set_mangled_name_for_decl (clone);\n+\n+  /* Create the RTL for this function.  */\n+  DECL_RTL (clone) = NULL_RTX;\n+  rest_of_decl_compilation (clone, NULL, /*top_level=*/1, at_eof);\n+  \n+  /* Make it easy to find the CLONE given the FN.  */\n+  TREE_CHAIN (clone) = TREE_CHAIN (fn);\n+  TREE_CHAIN (fn) = clone;\n+\n+  /* If this is a template, handle the DECL_TEMPLATE_RESULT as well.  */\n+  if (TREE_CODE (clone) == TEMPLATE_DECL)\n+    {\n+      tree result;\n+\n+      DECL_TEMPLATE_RESULT (clone) \n+\t= build_clone (DECL_TEMPLATE_RESULT (clone), name);\n+      result = DECL_TEMPLATE_RESULT (clone);\n+      DECL_TEMPLATE_INFO (result) = copy_node (DECL_TEMPLATE_INFO (result));\n+      DECL_TI_TEMPLATE (result) = clone;\n+    }\n+\n+  return clone;\n+}\n+\n+/* Produce declarations for all appropriate clones of FN.  If\n+   UPDATE_METHOD_VEC_P is non-zero, the clones are added to the\n+   CLASTYPE_METHOD_VEC as well.  */\n+\n+void\n+clone_function_decl (fn, update_method_vec_p)\n+     tree fn;\n+     int update_method_vec_p;\n+{\n+  tree clone;\n+\n+  if (DECL_CONSTRUCTOR_P (fn))\n+    {\n+      clone = build_clone (fn, complete_ctor_identifier);\n+      if (update_method_vec_p)\n+\tadd_method (DECL_CONTEXT (clone), NULL, clone);\n+      clone = build_clone (fn, base_ctor_identifier);\n+      if (update_method_vec_p)\n+\tadd_method (DECL_CONTEXT (clone), NULL, clone);\n+    }\n+  else\n+    /* We don't do destructors yet.  */\n+    my_friendly_abort (20000411);\n+}\n+\n+/* For each of the constructors and destructors in T, create an\n+   in-charge and not-in-charge variant.  */\n+\n+static void\n+clone_constructors_and_destructors (t)\n+     tree t;\n+{\n+  tree fns;\n+\n+  /* We only clone constructors and destructors under the new ABI.  */\n+  if (!flag_new_abi)\n+    return;\n+\n+  /* If for some reason we don't have a CLASSTYPE_METHOD_VEC, we bail\n+     out now.  */\n+  if (!CLASSTYPE_METHOD_VEC (t))\n+    return;\n+\n+  /* For each constructor, we need two variants: an in-charge version\n+     and a not-in-charge version.  */\n+  for (fns = CLASSTYPE_CONSTRUCTORS (t); fns; fns = OVL_NEXT (fns))\n+    clone_function_decl (OVL_CURRENT (fns), /*update_method_vec_p=*/1);\n+\n+  /* For now, we don't do the destructors.  */\n+}\n+\n /* Remove all zero-width bit-fields from T.  */\n \n static void\n@@ -3950,6 +4098,10 @@ check_bases_and_members (t, empty_p)\n \t\t\t\t   cant_have_const_ctor,\n \t\t\t\t   no_const_asn_ref);\n \n+  /* Create the in-charge and not-in-charge variants of constructors\n+     and destructors.  */\n+  clone_constructors_and_destructors (t);\n+\n   /* Process the using-declarations.  */\n   for (; access_decls; access_decls = TREE_CHAIN (access_decls))\n     handle_using_decl (TREE_VALUE (access_decls), t);"}, {"sha": "db6a41c7c3a9cadedbcea556e08f18fe0e164cc8", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 67, "deletions": 11, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db9b217498015006694d428ada8d8aed292a432f/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db9b217498015006694d428ada8d8aed292a432f/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=db9b217498015006694d428ada8d8aed292a432f", "patch": "@@ -559,6 +559,7 @@ enum cp_tree_index\n     CPTI_COMPLETE_CTOR_IDENTIFIER,\n     CPTI_BASE_CTOR_IDENTIFIER,\n     CPTI_DTOR_IDENTIFIER,\n+    CPTI_COMPLETE_DTOR_IDENTIFIER,\n     CPTI_BASE_DTOR_IDENTIFIER,\n     CPTI_DELETING_DTOR_IDENTIFIER,\n     CPTI_DELTA2_IDENTIFIER,\n@@ -653,14 +654,18 @@ extern tree cp_global_trees[CPTI_MAX];\n    frequently.  */\n \n /* The name of a constructor that takes an in-charge parameter to\n-   decide whether or not to call virtual base classes.  */\n+   decide whether or not to construct virtual base classes.  */\n #define ctor_identifier                 cp_global_trees[CPTI_CTOR_IDENTIFIER]\n /* The name of a constructor that constructs virtual base classes.  */\n #define complete_ctor_identifier        cp_global_trees[CPTI_COMPLETE_CTOR_IDENTIFIER]\n /* The name of a constructor that does not construct virtual base classes.  */\n #define base_ctor_identifier            cp_global_trees[CPTI_BASE_CTOR_IDENTIFIER]\n-/* The name of a destructor that destroys virtual base classes.  */\n+/* The name of a destructor that takes an in-charge parameter to\n+   decide whether or not to destroy virtual base classes and whether\n+   or not to delete the object.  */\n #define dtor_identifier                 cp_global_trees[CPTI_DTOR_IDENTIFIER]\n+/* The name of a destructor that destroys virtual base classes.  */\n+#define complete_dtor_identifier        cp_global_trees[CPTI_COMPLETE_DTOR_IDENTIFIER]\n /* The name of a destructor that does not destroy virtual base\n    classes.  */\n #define base_dtor_identifier            cp_global_trees[CPTI_BASE_DTOR_IDENTIFIER]\n@@ -1475,17 +1480,29 @@ struct lang_type\n    either a FUNCTION_DECL, a TEMPLATE_DECL, or an OVERLOAD.  All\n    functions with the same name end up in the same slot.  The first\n    two elements are for constructors, and destructors, respectively.\n-   These are followed by ordinary member functions.  There may be\n-   empty entries at the end of the vector.  */\n+   Any conversion operators are next, followed by ordinary member\n+   functions.  There may be empty entries at the end of the vector.  */\n #define CLASSTYPE_METHOD_VEC(NODE) (TYPE_LANG_SPECIFIC(NODE)->methods)\n \n-/* The first type conversion operator in the class (the others can be\n-   searched with TREE_CHAIN), or the first non-constructor function if\n-   there are no type conversion operators.  */\n-#define CLASSTYPE_FIRST_CONVERSION(NODE) \\\n-  TREE_VEC_LENGTH (CLASSTYPE_METHOD_VEC (NODE)) > 2 \\\n-    ? TREE_VEC_ELT (CLASSTYPE_METHOD_VEC (NODE), 2) \\\n-    : NULL_TREE;\n+/* The slot in the CLASSTYPE_METHOD_VEC where constructors go.  */\n+#define CLASSTYPE_CONSTRUCTOR_SLOT 0\n+\n+/* The slot in the CLASSTYPE_METHOD_VEC where destructors go.  */\n+#define CLASSTYPE_DESTRUCTOR_SLOT 1\n+\n+/* The first slot in the CLASSTYPE_METHOD_VEC where conversion\n+   operators can appear.  */\n+#define CLASSTYPE_FIRST_CONVERSION_SLOT 2\n+\n+/* A FUNCTION_DECL or OVERLOAD for the constructors for NODE.  These\n+   are the constructors that take an in-charge parameter.  */\n+#define CLASSTYPE_CONSTRUCTORS(NODE) \\\n+  (TREE_VEC_ELT (CLASSTYPE_METHOD_VEC (NODE), CLASSTYPE_CONSTRUCTOR_SLOT))\n+\n+/* A FUNCTION_DECL for the destructor for NODE.  These are te\n+   destructors that take an in-charge parameter.  */\n+#define CLASSTYPE_DESTRUCTORS(NODE) \\\n+  (TREE_VEC_ELT (CLASSTYPE_METHOD_VEC (NODE), CLASSTYPE_DESTRUCTOR_SLOT))\n \n /* Mark bits for depth-first and breath-first searches.  */\n \n@@ -1882,6 +1899,9 @@ struct lang_decl\n   /* In a FUNCTION_DECL, this is DECL_SAVED_TREE.  */\n   tree saved_tree;\n \n+  /* In a FUNCTION_DECL, this is DECL_CLONED_FUNCTION.  */\n+  tree cloned_function;\n+\n   union\n   {\n     tree sorted_fields;\n@@ -1909,6 +1929,24 @@ struct lang_decl\n /* For FUNCTION_DECLs: nonzero means that this function is a constructor.  */\n #define DECL_CONSTRUCTOR_P(NODE) (DECL_LANG_SPECIFIC(NODE)->decl_flags.constructor_attr)\n \n+/* Nonzero if NODE (a FUNCTION_DECL) is a constructor for a complete\n+   object.  */\n+#define DECL_COMPLETE_CONSTRUCTOR_P(NODE)\t\t\\\n+  (DECL_CONSTRUCTOR_P (NODE) \t\t\t\t\\\n+   && DECL_NAME (NODE) == complete_ctor_identifier)\n+\n+/* Nonzero if NODE (a FUNCTION_DECL) is a constructor for a base\n+   object.  */\n+#define DECL_BASE_CONSTRUCTOR_P(NODE)\t\t\\\n+  (DECL_CONSTRUCTOR_P (NODE)\t\t\t\\\n+   && DECL_NAME (NODE) == base_ctor_identifier)\n+\n+/* Nonzero if NODE (a FUNCTION_DECL) is a constructor, but not either the\n+   specialized in-charge constructor or the specialized not-in-charge\n+   constructor.  */\n+#define DECL_MAYBE_IN_CHARGE_CONSTRUCTOR_P(NODE)\t\t\\\n+  (DECL_CONSTRUCTOR_P (NODE) && !DECL_CLONED_FUNCTION_P (NODE))\n+\n /* Nonzero if NODE (a FUNCTION_DECL) is a copy constructor.  */\n #define DECL_COPY_CONSTRUCTOR_P(NODE) \\\n   (DECL_CONSTRUCTOR_P (NODE) && copy_args_p (NODE))\n@@ -1919,6 +1957,22 @@ struct lang_decl\n   (DESTRUCTOR_NAME_P (DECL_ASSEMBLER_NAME (NODE))\t\\\n    && DECL_LANGUAGE (NODE) == lang_cplusplus)\n \n+/* Nonzero if NODE (a FUNCTION_DECL) is a destructor, but not the\n+   specialized in-charge constructor, in-charge deleting constructor,\n+   or the the base destructor.  */\n+#define DECL_MAYBE_IN_CHARGE_DESTRUCTOR_P(NODE)\t\t\t\\\n+  (DECL_DESTRUCTOR_P (NODE) && !DECL_CLONED_FUNCTION_P (NODE))\n+\n+/* Nonzero if NODE (a FUNCTION_DECL) is a cloned constructor or\n+   destructor.  */\n+#define DECL_CLONED_FUNCTION_P(NODE) \\\n+  (DECL_CLONED_FUNCTION (NODE) != NULL_TREE)\n+\n+/* If DECL_CLONED_FUNCTION_P holds, this is the function that was\n+   cloned.  */\n+#define DECL_CLONED_FUNCTION(NODE) \\\n+  (DECL_LANG_SPECIFIC (NODE)->cloned_function)\n+\n /* Non-zero if NODE is a user-defined conversion operator.  */\n #define DECL_CONV_FN_P(NODE)\t\t\t\t\t\t     \\\n   (IDENTIFIER_TYPENAME_P (DECL_NAME (NODE)) && TREE_TYPE (DECL_NAME (NODE)))\n@@ -3723,6 +3777,7 @@ extern tree build_type_conversion\t\tPARAMS ((tree, tree, int));\n extern tree build_expr_type_conversion\t\tPARAMS ((int, tree, int));\n extern tree type_promotes_to\t\t\tPARAMS ((tree));\n extern tree perform_qualification_conversions   PARAMS ((tree, tree));\n+extern void clone_function_decl                 PARAMS ((tree, int));\n \n /* decl.c */\n /* resume_binding_level */\n@@ -4093,6 +4148,7 @@ extern tree implicitly_declare_fn               PARAMS ((special_function_kind,\n /* In optimize.c */\n extern void optimize_function                   PARAMS ((tree));\n extern int calls_setjmp_p                       PARAMS ((tree));\n+extern int maybe_clone_body                     PARAMS ((tree));\n \n /* in pt.c */\n extern void init_pt                             PARAMS ((void));"}, {"sha": "6b490a651317b7c85c5bc576ed85b5a112219218", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db9b217498015006694d428ada8d8aed292a432f/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db9b217498015006694d428ada8d8aed292a432f/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=db9b217498015006694d428ada8d8aed292a432f", "patch": "@@ -6063,6 +6063,7 @@ initialize_predefined_identifiers ()\n     { \"__base_ctor\", &base_ctor_identifier },\n     { \"__comp_ctor\", &complete_ctor_identifier },\n     { DTOR_NAME, &dtor_identifier },\n+    { \"__comp_dtor\", &complete_dtor_identifier },\n     { \"__base_dtor\", &base_dtor_identifier },\n     { \"__deleting_dtor\", &deleting_dtor_identifier },\n     { VTABLE_DELTA2_NAME, &delta2_identifier },\n@@ -13966,7 +13967,11 @@ finish_function (flags)\n       store_parm_decls ();\n     }\n \n-  if (building_stmt_tree ())\n+  /* For a cloned function, we've already got all the code we need;\n+     there's no need to add any extra bits.  */\n+  if (building_stmt_tree () && DECL_CLONED_FUNCTION_P (fndecl))\n+    ;\n+  else if (building_stmt_tree ())\n     {\n       if (DECL_CONSTRUCTOR_P (fndecl))\n \t{\n@@ -14763,6 +14768,7 @@ lang_mark_tree (t)\n \t    {\n \t      ggc_mark_tree (ld->befriending_classes);\n \t      ggc_mark_tree (ld->saved_tree);\n+\t      ggc_mark_tree (ld->cloned_function);\n \t      if (TREE_CODE (t) == TYPE_DECL)\n \t\tggc_mark_tree (ld->u.sorted_fields);\n \t      else if (TREE_CODE (t) == FUNCTION_DECL"}, {"sha": "83279a12efc3162efe26c5e9b9c8f3195ad6fcc5", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db9b217498015006694d428ada8d8aed292a432f/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db9b217498015006694d428ada8d8aed292a432f/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=db9b217498015006694d428ada8d8aed292a432f", "patch": "@@ -5228,7 +5228,12 @@ mark_used (decl)\n       && ! DECL_INITIAL (decl)\n       /* Kludge: don't synthesize for default args.  */\n       && current_function_decl)\n-    synthesize_method (decl);\n+    {\n+      synthesize_method (decl);\n+      /* If we've already synthesized the method we don't need to\n+\t instantiate it, so we can return right away.  */\n+      return;\n+    }\n \n   /* If this is a function or variable that is an instance of some\n      template, we now know that we will need to actually do the"}, {"sha": "dd6673c4e5483046f524c2e5fc802ad893b710d3", "filename": "gcc/cp/dump.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db9b217498015006694d428ada8d8aed292a432f/gcc%2Fcp%2Fdump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db9b217498015006694d428ada8d8aed292a432f/gcc%2Fcp%2Fdump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdump.c?ref=db9b217498015006694d428ada8d8aed292a432f", "patch": "@@ -557,7 +557,6 @@ dequeue_and_dump (di)\n \n     case FUNCTION_DECL:\n     case THUNK_DECL:\n-      dump_child (\"scpe\", CP_DECL_CONTEXT (t));\n       dump_child (\"mngl\", DECL_ASSEMBLER_NAME (t));\n       dump_child (\"args\", DECL_ARGUMENTS (t));\n       if (DECL_EXTERNAL (t))"}, {"sha": "ecc7dc03fc574872d7548107c9dc95bc1a9f1865", "filename": "gcc/cp/method.c", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db9b217498015006694d428ada8d8aed292a432f/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db9b217498015006694d428ada8d8aed292a432f/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=db9b217498015006694d428ada8d8aed292a432f", "patch": "@@ -1748,7 +1748,7 @@ set_mangled_name_for_decl (decl)\n   DECL_ASSEMBLER_NAME (decl)\n     = build_decl_overload (DECL_NAME (decl), parm_types, \n \t\t\t   DECL_FUNCTION_MEMBER_P (decl)\n-\t\t\t   + DECL_CONSTRUCTOR_P (decl));\n+\t\t\t   + DECL_MAYBE_IN_CHARGE_CONSTRUCTOR_P (decl));\n }\n \n /* Build an overload name for the type expression TYPE.  */\n@@ -2359,6 +2359,15 @@ synthesize_method (fndecl)\n   if (at_eof)\n     import_export_decl (fndecl);\n \n+  /* If we've been asked to synthesize a clone, just synthesize the\n+     cloned function instead.  Doing so will automatically fill in the\n+     body for the clone.  */\n+  if (DECL_CLONED_FUNCTION_P (fndecl))\n+    {\n+      synthesize_method (DECL_CLONED_FUNCTION (fndecl));\n+      return;\n+    }\n+\n   if (! context)\n     push_to_top_level ();\n   else if (nested)"}, {"sha": "9f2fe35ac664361ca12960def65be6aa2c306866", "filename": "gcc/cp/optimize.c", "status": "modified", "additions": 120, "deletions": 7, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db9b217498015006694d428ada8d8aed292a432f/gcc%2Fcp%2Foptimize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db9b217498015006694d428ada8d8aed292a432f/gcc%2Fcp%2Foptimize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Foptimize.c?ref=db9b217498015006694d428ada8d8aed292a432f", "patch": "@@ -50,7 +50,9 @@ typedef struct inline_data\n      inlining the body of `h', the stack will contain, `h', followed\n      by `g', followed by `f'.  */\n   varray_type fns;\n-  /* The label to jump to when a return statement is encountered.  */\n+  /* The label to jump to when a return statement is encountered.  If\n+     this value is NULL, then return statements will simply be\n+     remapped as return statements, rather than as jumps.  */\n   tree ret_label;\n   /* The map from local declarations in the inlined function to\n      equivalents in the function into which it is being inlined.  */\n@@ -157,6 +159,7 @@ remap_block (scope_stmt, decls, id)\n       tree old_block;\n       tree new_block;\n       tree old_var;\n+      tree *first_block;\n       tree fn;\n \n       /* Make the new block.  */\n@@ -175,9 +178,12 @@ remap_block (scope_stmt, decls, id)\n \n \t  /* Remap the variable.  */\n \t  new_var = remap_decl (old_var, id);\n-\t  if (!new_var)\n-\t    /* We didn't remap this variable, so we can't mess with\n-\t       its TREE_CHAIN.  */\n+\t  /* If we didn't remap this variable, so we can't mess with\n+\t     its TREE_CHAIN.  If we remapped this variable to\n+\t     something other than a declaration (say, if we mapped it\n+\t     to a constant), then we must similarly omit any mention\n+\t     of it here.  */\n+\t  if (!new_var || !DECL_P (new_var))\n \t    ;\n \t  else\n \t    {\n@@ -191,8 +197,12 @@ remap_block (scope_stmt, decls, id)\n \t function into which this block is being inlined.  In\n \t rest_of_compilation we will straighten out the BLOCK tree.  */\n       fn = VARRAY_TREE (id->fns, 0);\n-      BLOCK_CHAIN (new_block) = BLOCK_CHAIN (DECL_INITIAL (fn));\n-      BLOCK_CHAIN (DECL_INITIAL (fn)) = new_block;\n+      if (DECL_INITIAL (fn))\n+\tfirst_block = &BLOCK_CHAIN (DECL_INITIAL (fn));\n+      else\n+\tfirst_block = &DECL_INITIAL (fn);\n+      BLOCK_CHAIN (new_block) = *first_block;\n+      *first_block = new_block;\n       /* Remember the remapped block.  */\n       splay_tree_insert (id->decl_map,\n \t\t\t (splay_tree_key) old_block,\n@@ -261,7 +271,7 @@ copy_body_r (tp, walk_subtrees, data)\n \n   /* If this is a RETURN_STMT, change it into an EXPR_STMT and a\n      GOTO_STMT with the RET_LABEL as its target.  */\n-  if (TREE_CODE (*tp) == RETURN_STMT)\n+  if (TREE_CODE (*tp) == RETURN_STMT && id->ret_label)\n     {\n       tree return_stmt = *tp;\n       tree goto_stmt;\n@@ -774,3 +784,106 @@ calls_setjmp_p (fn)\n \t  != NULL_TREE);\n }\n \n+/* FN is a function that has a complete body.  Clone the body as\n+   necessary.  Returns non-zero if there's no longer any need to\n+   process the main body.  */\n+\n+int\n+maybe_clone_body (fn)\n+     tree fn;\n+{\n+  inline_data id;\n+  tree clone;\n+\n+  /* We don't clone constructors and destructors under the old ABI.  */\n+  if (!flag_new_abi)\n+    return 0;\n+\n+  /* We only clone constructors and destructors.  */\n+  if (!DECL_MAYBE_IN_CHARGE_CONSTRUCTOR_P (fn)\n+      && !DECL_MAYBE_IN_CHARGE_DESTRUCTOR_P (fn))\n+    return 0;\n+\n+  /* We don't yet handle destructors.  */\n+  if (DECL_DESTRUCTOR_P (fn))\n+    return 0;\n+\n+  /* We know that any clones immediately follow FN in the TYPE_METHODS\n+     list.  */\n+  for (clone = TREE_CHAIN (fn);\n+       clone && DECL_CLONED_FUNCTION_P (clone);\n+       clone = TREE_CHAIN (clone))\n+    {\n+      tree parm;\n+      tree clone_parm;\n+      int parmno;\n+\n+      /* Update CLONE's source position information to match FN's.  */\n+      DECL_SOURCE_FILE (clone) = DECL_SOURCE_FILE (fn);\n+      DECL_SOURCE_LINE (clone) = DECL_SOURCE_LINE (fn);\n+\n+      /* Start processing the function.  */\n+      push_to_top_level ();\n+      start_function (NULL_TREE, clone, NULL_TREE, SF_PRE_PARSED);\n+      store_parm_decls ();\n+\n+      /* Just clone the body, as if we were making an inline call.\n+\t But, remap the parameters in the callee to the parameters of\n+\t caller.  If there's an in-charge parameter, map it to an\n+\t appropriate constant.  */\n+      memset (&id, 0, sizeof (id));\n+      VARRAY_TREE_INIT (id.fns, 2, \"fns\");\n+      VARRAY_PUSH_TREE (id.fns, clone);\n+      VARRAY_PUSH_TREE (id.fns, fn);\n+\n+      /* Remap the parameters.  */\n+      id.decl_map = splay_tree_new (splay_tree_compare_pointers,\n+\t\t\t\t    NULL, NULL);\n+      for (parmno = 0,\n+\t     parm = DECL_ARGUMENTS (fn),\n+\t     clone_parm = DECL_ARGUMENTS (clone);\n+\t   parm;\n+\t   ++parmno,\n+\t     parm = TREE_CHAIN (parm))\n+\t{\n+\t  /* Map the in-charge parameter to an appropriate constant.  */\n+\t  if (DECL_HAS_IN_CHARGE_PARM_P (fn) && parmno == 1)\n+\t    {\n+\t      tree in_charge;\n+\n+\t      if (DECL_COMPLETE_CONSTRUCTOR_P (clone))\n+\t\tin_charge = integer_one_node;\n+\t      else\n+\t\tin_charge = integer_zero_node;\n+\n+\t      splay_tree_insert (id.decl_map,\n+\t\t\t\t (splay_tree_key) parm,\n+\t\t\t\t (splay_tree_key) in_charge);\n+\t    }\n+\t  /* Map other parameters to their equivalents in the cloned\n+\t     function.  */\n+\t  else\n+\t    {\n+\t      splay_tree_insert (id.decl_map,\n+\t\t\t\t (splay_tree_key) parm,\n+\t\t\t\t (splay_tree_value) clone_parm);\n+\t      clone_parm = TREE_CHAIN (clone_parm);\n+\t    }\n+\t}\n+\n+      /* Actually copy the body.  */\n+      TREE_CHAIN (DECL_SAVED_TREE (clone)) = copy_body (&id);\n+\n+      /* Clean up.  */\n+      splay_tree_delete (id.decl_map);\n+      VARRAY_FREE (id.fns);\n+\n+      /* Now, expand this function into RTL, if appropriate.  */\n+      current_function_name_declared = 1;\n+      expand_body (finish_function (0));\n+      pop_from_top_level ();\n+    }\n+  \n+  /* We don't need to process the original function any further.  */\n+  return 1;\n+}"}, {"sha": "caf84c8d516bfb3fce68dea91dd4a33274404b0f", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 55, "deletions": 1, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db9b217498015006694d428ada8d8aed292a432f/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db9b217498015006694d428ada8d8aed292a432f/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=db9b217498015006694d428ada8d8aed292a432f", "patch": "@@ -159,6 +159,7 @@ static int template_args_equal PARAMS ((tree, tree));\n static void print_template_context PARAMS ((int));\n static void tsubst_default_arguments PARAMS ((tree));\n static tree for_each_template_parm_r PARAMS ((tree *, int *, void *));\n+static tree instantiate_clone PARAMS ((tree, tree));\n \n /* Called once to initialize pt.c.  */\n \n@@ -5708,6 +5709,13 @@ tsubst_decl (t, args, type, in_decl)\n \tDECL_PENDING_INLINE_INFO (r) = 0;\n \tDECL_PENDING_INLINE_P (r) = 0;\n \tTREE_USED (r) = 0;\n+\tif (DECL_CLONED_FUNCTION (r))\n+\t  {\n+\t    DECL_CLONED_FUNCTION (r) = tsubst (DECL_CLONED_FUNCTION (t),\n+\t\t\t\t\t       args, /*complain=*/1, t);\n+\t    TREE_CHAIN (r) = TREE_CHAIN (DECL_CLONED_FUNCTION (r));\n+\t    TREE_CHAIN (DECL_CLONED_FUNCTION (r)) = r;\n+\t  }\n \n \t/* Set up the DECL_TEMPLATE_INFO for R and compute its mangled\n \t   name.  There's no need to do this in the special friend\n@@ -7367,6 +7375,43 @@ tsubst_expr (t, args, complain, in_decl)\n   return NULL_TREE;\n }\n \n+/* TMPL is a TEMPLATE_DECL for a cloned constructor or destructor.\n+   Instantiate it with the ARGS.  */\n+\n+static tree\n+instantiate_clone (tmpl, args)\n+     tree tmpl;\n+     tree args;\n+{\n+  tree spec;\n+  tree clone;\n+\n+  /* Instantiated the cloned function, rather than the clone.  */\n+  spec = instantiate_template (DECL_CLONED_FUNCTION (tmpl), args);\n+\n+  /* Then, see if we've already cloned the instantiation.  */\n+  for (clone = TREE_CHAIN (spec);\n+       clone && DECL_CLONED_FUNCTION_P (clone);\n+       clone = TREE_CHAIN (clone))\n+    if (DECL_NAME (clone) == DECL_NAME (tmpl))\n+      return clone;\n+\n+  /* If we haven't, do so know.  */\n+  if (!clone)\n+    clone_function_decl (spec, /*update_method_vec_p=*/0);\n+\n+  /* Look again.  */\n+  for (clone = TREE_CHAIN (spec);\n+       clone && DECL_CLONED_FUNCTION_P (clone);\n+       clone = TREE_CHAIN (clone))\n+    if (DECL_NAME (clone) == DECL_NAME (tmpl))\n+      return clone;\n+\n+  /* We should always have found the clone by now.  */\n+  my_friendly_abort (20000411);\n+  return NULL_TREE;\n+}\n+\n /* Instantiate the indicated variable or function template TMPL with\n    the template arguments in TARG_PTR.  */\n \n@@ -7385,6 +7430,10 @@ instantiate_template (tmpl, targ_ptr)\n \n   my_friendly_assert (TREE_CODE (tmpl) == TEMPLATE_DECL, 283);\n \n+  /* If this function is a clone, handle it specially.  */\n+  if (DECL_CLONED_FUNCTION_P (tmpl))\n+    return instantiate_clone (tmpl, targ_ptr);\n+\n   /* Check to see if we already have this specialization.  */\n   spec = retrieve_specialization (tmpl, targ_ptr);\n   if (spec != NULL_TREE)\n@@ -9389,6 +9438,11 @@ instantiate_decl (d, defer_ok)\n   my_friendly_assert (TREE_CODE (d) == FUNCTION_DECL\n \t\t      || TREE_CODE (d) == VAR_DECL, 0);\n \n+  /* Don't instantiate cloned functions.  Instead, instantiate the\n+     functions they cloned.  */\n+  if (TREE_CODE (d) == FUNCTION_DECL && DECL_CLONED_FUNCTION_P (d))\n+    d = DECL_CLONED_FUNCTION (d);\n+\n   if (DECL_TEMPLATE_INSTANTIATED (d))\n     /* D has already been instantiated.  It might seem reasonable to\n        check whether or not D is an explict instantiation, and, if so,\n@@ -9935,7 +9989,7 @@ set_mangled_name_for_template_decl (decl)\n     = build_decl_overload_real (DECL_NAME (decl), parm_types, ret_type,\n \t\t\t\ttparms, targs, \n \t\t\t\tDECL_FUNCTION_MEMBER_P (decl) \n-\t\t\t\t+ DECL_CONSTRUCTOR_P (decl));\n+\t\t\t\t+ DECL_MAYBE_IN_CHARGE_CONSTRUCTOR_P (decl));\n \n   /* Restore the previously active namespace.  */\n   current_namespace = saved_namespace;"}, {"sha": "7ca43b3e67dd756a3f05288281eff1fc2e8f79b8", "filename": "gcc/cp/search.c", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db9b217498015006694d428ada8d8aed292a432f/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db9b217498015006694d428ada8d8aed292a432f/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=db9b217498015006694d428ada8d8aed292a432f", "patch": "@@ -1688,13 +1688,16 @@ lookup_fnfields_1 (type, name)\n \n       /* Constructors are first...  */\n       if (name == ctor_identifier)\n-\treturn methods[0] ? 0 : -1;\n-\n+\treturn (methods[CLASSTYPE_CONSTRUCTOR_SLOT] \n+\t\t? CLASSTYPE_CONSTRUCTOR_SLOT : -1);\n       /* and destructors are second.  */\n       if (name == dtor_identifier)\n-\treturn methods[1] ? 1 : -1;\n+\treturn (methods[CLASSTYPE_DESTRUCTOR_SLOT]\n+\t\t? CLASSTYPE_DESTRUCTOR_SLOT : -1);\n \n-      for (i = 2; i < len && methods[i]; ++i)\n+      for (i = CLASSTYPE_FIRST_CONVERSION_SLOT; \n+\t   i < len && methods[i]; \n+\t   ++i)\n \t{\n #ifdef GATHER_STATISTICS\n \t  n_outer_fields_searched++;\n@@ -1737,7 +1740,9 @@ lookup_fnfields_1 (type, name)\n \t above so that we will always find specializations first.)  */\n       if (IDENTIFIER_TYPENAME_P (name)) \n \t{\n-\t  for (i = 2; i < len && methods[i]; ++i)\n+\t  for (i = CLASSTYPE_FIRST_CONVERSION_SLOT; \n+\t       i < len && methods[i]; \n+\t       ++i)\n \t    {\n \t      tmp = OVL_CURRENT (methods[i]);\n \t      if (! DECL_CONV_FN_P (tmp))"}, {"sha": "8b9bfac7acd5b8b694bbd1f65b0e9ead7ff05dfe", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db9b217498015006694d428ada8d8aed292a432f/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db9b217498015006694d428ada8d8aed292a432f/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=db9b217498015006694d428ada8d8aed292a432f", "patch": "@@ -2717,6 +2717,16 @@ expand_body (fn)\n   /* Replace AGGR_INIT_EXPRs with appropriate CALL_EXPRs.  */\n   walk_tree (&DECL_SAVED_TREE (fn), simplify_aggr_init_exprs_r, NULL);\n \n+  /* If this is a constructor or destructor body, we have to clone it\n+     under the new ABI.  */\n+  if (maybe_clone_body (fn))\n+    {\n+      /* We don't want to process FN again, so pretend we've written\n+\t it out, even though we haven't.  */\n+      TREE_ASM_WRITTEN (fn) = 1;\n+      return;\n+    }\n+\n   /* There's no reason to do any of the work here if we're only doing\n      semantic analysis; this code just generates RTL.  */\n   if (flag_syntax_only)"}]}