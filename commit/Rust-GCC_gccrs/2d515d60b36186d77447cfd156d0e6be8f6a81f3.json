{"sha": "2d515d60b36186d77447cfd156d0e6be8f6a81f3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmQ1MTVkNjBiMzYxODZkNzc0NDdjZmQxNTZkMGU2YmU4ZjZhODFmMw==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2001-08-14T13:01:20Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2001-08-14T13:01:20Z"}, "message": "genattrtab.c (simplify_test_exp_in_temp): New function.\n\n        * genattrtab.c (simplify_test_exp_in_temp): New function.\n        (simplify_test_exp): Avoid explicit use of temporary obstack.\n        (simplify_cond, insert_right_side, evaluate_eq_attr,\n        simplify_and_tree, simplify_or_tree, eliminate_known_true):\n        Use simplify_test_exp_in_temp.\n        (optimize_attrs): Iterate until expression stabilizes.\n\nFrom-SVN: r44890", "tree": {"sha": "4ddc309b99f34626d241fa62484a45d7f047a33a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4ddc309b99f34626d241fa62484a45d7f047a33a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2d515d60b36186d77447cfd156d0e6be8f6a81f3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2d515d60b36186d77447cfd156d0e6be8f6a81f3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2d515d60b36186d77447cfd156d0e6be8f6a81f3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2d515d60b36186d77447cfd156d0e6be8f6a81f3/comments", "author": null, "committer": null, "parents": [{"sha": "3119bd48ccf691534999204835f2b34729cd8a2b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3119bd48ccf691534999204835f2b34729cd8a2b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3119bd48ccf691534999204835f2b34729cd8a2b"}], "stats": {"total": 115, "additions": 72, "deletions": 43}, "files": [{"sha": "c0ed70396ad20ed69d05fad12b5853367020a1fb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d515d60b36186d77447cfd156d0e6be8f6a81f3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d515d60b36186d77447cfd156d0e6be8f6a81f3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2d515d60b36186d77447cfd156d0e6be8f6a81f3", "patch": "@@ -1,3 +1,12 @@\n+Tue Aug 14 14:57:07 CEST 2001  Jan Hubicka  <jh@suse.cz>\n+\n+        * genattrtab.c (simplify_test_exp_in_temp): New function.\n+        (simplify_test_exp): Avoid explicit use of temporary obstack.\n+        (simplify_cond, insert_right_side, evaluate_eq_attr,\n+        simplify_and_tree, simplify_or_tree, eliminate_known_true):\n+        Use simplify_test_exp_in_temp.\n+        (optimize_attrs): Iterate until expression stabilizes.\n+\n 2001-08-13  Ulrich Weigand  <uweigand@de.ibm.com>:\n  \n \t* glimits.h: Remove the __LONG_MAX__ special case for s390x."}, {"sha": "2894e686113b8f425a026b386fc67fdea64bc361", "filename": "gcc/genattrtab.c", "status": "modified", "additions": 63, "deletions": 43, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d515d60b36186d77447cfd156d0e6be8f6a81f3/gcc%2Fgenattrtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d515d60b36186d77447cfd156d0e6be8f6a81f3/gcc%2Fgenattrtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenattrtab.c?ref=2d515d60b36186d77447cfd156d0e6be8f6a81f3", "patch": "@@ -417,6 +417,7 @@ static rtx evaluate_eq_attr\tPARAMS ((rtx, rtx, int, int));\n static rtx simplify_and_tree\tPARAMS ((rtx, rtx *, int, int));\n static rtx simplify_or_tree\tPARAMS ((rtx, rtx *, int, int));\n static rtx simplify_test_exp\tPARAMS ((rtx, int, int));\n+static rtx simplify_test_exp_in_temp PARAMS ((rtx, int, int));\n static void optimize_attrs\tPARAMS ((void));\n static void gen_attr\t\tPARAMS ((rtx, int));\n static int count_alternatives\tPARAMS ((rtx));\n@@ -2593,7 +2594,7 @@ simplify_cond (exp, insn_code, insn_index)\n       rtx newtest, newval;\n \n       /* Simplify this test.  */\n-      newtest = SIMPLIFY_TEST_EXP (tests[i], insn_code, insn_index);\n+      newtest = simplify_test_exp_in_temp (tests[i], insn_code, insn_index);\n       tests[i] = newtest;\n \n       newval = tests[i + 1];\n@@ -2782,7 +2783,7 @@ insert_right_side (code, exp, term, insn_code, insn_index)\n       newexp = attr_rtx (code, exp, term);\n     }\n \n-  return SIMPLIFY_TEST_EXP (newexp, insn_code, insn_index);\n+  return simplify_test_exp_in_temp (newexp, insn_code, insn_index);\n }\n \f\n /* If we have an expression which AND's a bunch of\n@@ -2910,8 +2911,8 @@ evaluate_eq_attr (exp, value, insn_code, insn_index)\n \n       for (i = 0; i < XVECLEN (value, 0); i += 2)\n \t{\n-\t  rtx this = SIMPLIFY_TEST_EXP (XVECEXP (value, 0, i),\n-\t\t\t\t\tinsn_code, insn_index);\n+\t  rtx this = simplify_test_exp_in_temp (XVECEXP (value, 0, i),\n+\t\t\t\t\t\tinsn_code, insn_index);\n \n \t  SIMPLIFY_ALTERNATIVE (this);\n \n@@ -2992,7 +2993,7 @@ simplify_and_tree (exp, pterm, insn_code, insn_index)\n \t{\n \t  newexp = attr_rtx (GET_CODE (exp), left, right);\n \n-\t  exp = SIMPLIFY_TEST_EXP (newexp, insn_code, insn_index);\n+\t  exp = simplify_test_exp_in_temp (newexp, insn_code, insn_index);\n \t}\n     }\n \n@@ -3015,7 +3016,7 @@ simplify_and_tree (exp, pterm, insn_code, insn_index)\n \t{\n \t  newexp = attr_rtx (GET_CODE (exp), left, right);\n \n-\t  exp = SIMPLIFY_TEST_EXP (newexp, insn_code, insn_index);\n+\t  exp = simplify_test_exp_in_temp (newexp, insn_code, insn_index);\n \t}\n     }\n \n@@ -3111,7 +3112,7 @@ simplify_or_tree (exp, pterm, insn_code, insn_index)\n \t{\n \t  newexp = attr_rtx (GET_CODE (exp), left, right);\n \n-\t  exp = SIMPLIFY_TEST_EXP (newexp, insn_code, insn_index);\n+\t  exp = simplify_test_exp_in_temp (newexp, insn_code, insn_index);\n \t}\n     }\n \n@@ -3134,7 +3135,7 @@ simplify_or_tree (exp, pterm, insn_code, insn_index)\n \t{\n \t  newexp = attr_rtx (GET_CODE (exp), left, right);\n \n-\t  exp = SIMPLIFY_TEST_EXP (newexp, insn_code, insn_index);\n+\t  exp = simplify_test_exp_in_temp (newexp, insn_code, insn_index);\n \t}\n     }\n \n@@ -3207,6 +3208,29 @@ attr_rtx_cost (x)\n   return cost;\n }\n \f\n+\n+/* Simplify test expression and use temporary obstack in order to avoid\n+   memory bloat.  Use RTX_UNCHANGING_P to avoid unnecesary simplifications\n+   and avoid unnecesary copying if possible.  */\n+\n+static rtx\n+simplify_test_exp_in_temp (exp, insn_code, insn_index)\n+  rtx exp;\n+  int insn_code, insn_index;\n+{\n+  rtx x;\n+  struct obstack *old;\n+  if (RTX_UNCHANGING_P (exp))\n+    return exp;\n+  old = rtl_obstack;\n+  rtl_obstack = temp_obstack;\n+  x = simplify_test_exp (exp, insn_code, insn_index);\n+  rtl_obstack = old;\n+  if (x == exp || rtl_obstack == temp_obstack)\n+    return x;\n+  return attr_copy_rtx (x);\n+}\n+\n /* Given an expression, see if it can be simplified for a particular insn\n    code based on the values of other attributes being tested.  This can\n    eliminate nested get_attr_... calls.\n@@ -3464,13 +3488,10 @@ simplify_test_exp (exp, insn_code, insn_index)\n \t    if (ie->insn_code == insn_code)\n \t      {\n \t\trtx x;\n-\t\tstruct obstack *old = rtl_obstack;\n-\t\trtl_obstack = temp_obstack;\n \t\tx = evaluate_eq_attr (exp, av->value, insn_code, insn_index);\n \t\tx = SIMPLIFY_TEST_EXP (x, insn_code, insn_index);\n-\t\trtl_obstack = old;\n \t\tif (attr_rtx_cost(x) < 20)\n-\t\t  return attr_copy_rtx (x);\n+\t\t  return x;\n \t      }\n       break;\n \n@@ -3499,7 +3520,6 @@ optimize_attrs ()\n   struct attr_value *av;\n   struct insn_ent *ie;\n   rtx newexp;\n-  int something_changed = 1;\n   int i;\n   struct attr_value_list\n   {\n@@ -3556,42 +3576,42 @@ optimize_attrs ()\n       for (iv = insn_code_values[i]; iv; iv = iv->next)\n \tclear_struct_flag (iv->av->value);\n \n-      /* Loop until nothing changes for one iteration.  */\n-      something_changed = 1;\n-      while (something_changed)\n+      for (iv = insn_code_values[i]; iv; iv = iv->next)\n \t{\n-\t  something_changed = 0;\n-\t  for (iv = insn_code_values[i]; iv; iv = iv->next)\n-\t    {\n-\t      struct obstack *old = rtl_obstack;\n+\t  struct obstack *old = rtl_obstack;\n \n-\t      attr = iv->attr;\n-\t      av = iv->av;\n-\t      ie = iv->ie;\n-\t      if (GET_CODE (av->value) != COND)\n-\t\tcontinue;\n+\t  attr = iv->attr;\n+\t  av = iv->av;\n+\t  ie = iv->ie;\n+\t  if (GET_CODE (av->value) != COND)\n+\t    continue;\n \n-\t      rtl_obstack = temp_obstack;\n+\t  rtl_obstack = temp_obstack;\n #if 0 /* This was intended as a speed up, but it was slower.  */\n-\t      if (insn_n_alternatives[ie->insn_code] > 6\n-\t\t  && count_sub_rtxs (av->value, 200) >= 200)\n-\t\tnewexp = simplify_by_alternatives (av->value, ie->insn_code,\n-\t\t\t\t\t\t   ie->insn_index);\n-\t      else\n+\t  if (insn_n_alternatives[ie->insn_code] > 6\n+\t      && count_sub_rtxs (av->value, 200) >= 200)\n+\t    newexp = simplify_by_alternatives (av->value, ie->insn_code,\n+\t\t\t\t\t       ie->insn_index);\n+\t  else\n #endif\n-\t\tnewexp = simplify_cond (av->value, ie->insn_code,\n-\t\t\t\t\tie->insn_index);\n+\t  newexp = av->value;\n+\t  while (GET_CODE (newexp) == COND)\n+\t    {\n+\t      rtx newexp2 = simplify_cond (newexp, ie->insn_code,\n+\t\t\t\t\t   ie->insn_index);\n+\t      if (newexp2 == newexp)\n+\t\tbreak;\n+\t      newexp = newexp2;\n+\t    }\n \n-\t      rtl_obstack = old;\n-\t      if (newexp != av->value)\n-\t\t{\n-\t\t  newexp = attr_copy_rtx (newexp);\n-\t\t  remove_insn_ent (av, ie);\n-\t\t  av = get_attr_value (newexp, attr, ie->insn_code);\n-\t\t  iv->av = av;\n-\t\t  insert_insn_ent (av, ie);\n-\t\t  something_changed = 1;\n-\t\t}\n+\t  rtl_obstack = old;\n+\t  if (newexp != av->value)\n+\t    {\n+\t      newexp = attr_copy_rtx (newexp);\n+\t      remove_insn_ent (av, ie);\n+\t      av = get_attr_value (newexp, attr, ie->insn_code);\n+\t      iv->av = av;\n+\t      insert_insn_ent (av, ie);\n \t    }\n \t}\n     }"}]}