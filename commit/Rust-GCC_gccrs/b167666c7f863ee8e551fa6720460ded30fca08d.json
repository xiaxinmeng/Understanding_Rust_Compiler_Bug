{"sha": "b167666c7f863ee8e551fa6720460ded30fca08d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjE2NzY2NmM3Zjg2M2VlOGU1NTFmYTY3MjA0NjBkZWQzMGZjYTA4ZA==", "commit": {"author": {"name": "Richard Sandiford", "email": "rsandifo@redhat.com", "date": "2005-05-15T08:10:10Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2005-05-15T08:10:10Z"}, "message": "* optc-gen.awk: Remove excess indentation.\n\nFrom-SVN: r99714", "tree": {"sha": "35e4c21a7369fe5539b33cc05d3f15893c262aed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/35e4c21a7369fe5539b33cc05d3f15893c262aed"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b167666c7f863ee8e551fa6720460ded30fca08d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b167666c7f863ee8e551fa6720460ded30fca08d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b167666c7f863ee8e551fa6720460ded30fca08d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b167666c7f863ee8e551fa6720460ded30fca08d/comments", "author": null, "committer": null, "parents": [{"sha": "b078dfbf39bdea09e613beb800c8261d57ba4c3b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b078dfbf39bdea09e613beb800c8261d57ba4c3b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b078dfbf39bdea09e613beb800c8261d57ba4c3b"}], "stats": {"total": 76, "additions": 40, "deletions": 36}, "files": [{"sha": "6412b9bbeb82f02b839850ad063636b76414e2a7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b167666c7f863ee8e551fa6720460ded30fca08d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b167666c7f863ee8e551fa6720460ded30fca08d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b167666c7f863ee8e551fa6720460ded30fca08d", "patch": "@@ -1,3 +1,7 @@\n+2005-05-15  Richard Sandiford  <rsandifo@redhat.com>\n+\n+\t* optc-gen.awk: Remove excess indentation.\n+\n 2005-05-14  Kaz Kojima  <kkojima@gcc.gnu.org>\n \n \t* config/sh/sh.c (sh_output_mi_thunk): Check cfun->cfg instead"}, {"sha": "5476674a1635c24c3b686a6022bd6f5063c12a33", "filename": "gcc/optc-gen.awk", "status": "modified", "additions": 36, "deletions": 36, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b167666c7f863ee8e551fa6720460ded30fca08d/gcc%2Foptc-gen.awk", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b167666c7f863ee8e551fa6720460ded30fca08d/gcc%2Foptc-gen.awk", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptc-gen.awk?ref=b167666c7f863ee8e551fa6720460ded30fca08d", "patch": "@@ -98,47 +98,47 @@ print \"const struct cl_option cl_options[] =\\n{\"\n for (i = 0; i < n_opts; i++)\n \tback_chain[i] = \"N_OPTS\";\n \n-\tfor (i = 0; i < n_opts; i++) {\n-\t\t# Combine the flags of identical switches.  Switches\n-\t\t# appear many times if they are handled by many front\n-\t\t# ends, for example.\n-\t\twhile( i + 1 != n_opts && opts[i] == opts[i + 1] ) {\n-\t\t\tflags[i + 1] = flags[i] \" \" flags[i + 1];\n-\t\t\ti++;\n-\t\t}\n+for (i = 0; i < n_opts; i++) {\n+\t# Combine the flags of identical switches.  Switches\n+\t# appear many times if they are handled by many front\n+\t# ends, for example.\n+\twhile( i + 1 != n_opts && opts[i] == opts[i + 1] ) {\n+\t\tflags[i + 1] = flags[i] \" \" flags[i + 1];\n+\t\ti++;\n+\t}\n \n-\t\tlen = length (opts[i]);\n-\t\tenum = \"OPT_\" opts[i]\n-\t\tif (opts[i] == \"finline-limit=\")\n-\t\t\tenum = enum \"eq\"\n-\t\tgsub (\"[^A-Za-z0-9]\", \"_\", enum)\n-\n-\t\t# If this switch takes joined arguments, back-chain all\n-\t\t# subsequent switches to it for which it is a prefix.  If\n-\t\t# a later switch S is a longer prefix of a switch T, T\n-\t\t# will be back-chained to S in a later iteration of this\n-\t\t# for() loop, which is what we want.\n-\t\tif (flag_set_p(\"Joined.*\", flags[i])) {\n-\t\t\tfor (j = i + 1; j < n_opts; j++) {\n-\t\t\t\tif (substr (opts[j], 1, len) != opts[i])\n-\t\t\t\t\tbreak;\n-\t\t\t\tback_chain[j] = enum;\n-\t\t\t}\n+\tlen = length (opts[i]);\n+\tenum = \"OPT_\" opts[i]\n+\tif (opts[i] == \"finline-limit=\")\n+\t\tenum = enum \"eq\"\n+\tgsub (\"[^A-Za-z0-9]\", \"_\", enum)\n+\n+\t# If this switch takes joined arguments, back-chain all\n+\t# subsequent switches to it for which it is a prefix.  If\n+\t# a later switch S is a longer prefix of a switch T, T\n+\t# will be back-chained to S in a later iteration of this\n+\t# for() loop, which is what we want.\n+\tif (flag_set_p(\"Joined.*\", flags[i])) {\n+\t\tfor (j = i + 1; j < n_opts; j++) {\n+\t\t\tif (substr (opts[j], 1, len) != opts[i])\n+\t\t\t\tbreak;\n+\t\t\tback_chain[j] = enum;\n \t\t}\n+\t}\n \n-\t\ts = substr(\"                                  \", length (opts[i]))\n-\t\tif (i + 1 == n_opts)\n-\t\t\tcomma = \"\"\n+\ts = substr(\"                                  \", length (opts[i]))\n+\tif (i + 1 == n_opts)\n+\t\tcomma = \"\"\n \n-\t\tif (help[i] == \"\")\n-\t\t\thlp = \"0\"\n-\t\telse\n-\t\t\thlp = quote help[i] quote;\n+\tif (help[i] == \"\")\n+\t\thlp = \"0\"\n+\telse\n+\t\thlp = quote help[i] quote;\n \n-\t\tprintf(\"  { %c-%s%c,\\n    %s,\\n    %s, %u, %s, %s, %s }%s\\n\",\n-\t\t\tquote, opts[i], quote, hlp, back_chain[i], len,\n-\t\t\tswitch_flags(flags[i]),\n-\t\t\tvar_ref(flags[i]), var_set(flags[i]), comma)\n+\tprintf(\"  { %c-%s%c,\\n    %s,\\n    %s, %u, %s, %s, %s }%s\\n\",\n+\t\tquote, opts[i], quote, hlp, back_chain[i], len,\n+\t\tswitch_flags(flags[i]),\n+\t\tvar_ref(flags[i]), var_set(flags[i]), comma)\n }\n \n print \"};\""}]}