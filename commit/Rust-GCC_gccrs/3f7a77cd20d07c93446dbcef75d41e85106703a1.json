{"sha": "3f7a77cd20d07c93446dbcef75d41e85106703a1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2Y3YTc3Y2QyMGQwN2M5MzQ0NmRiY2VmNzVkNDFlODUxMDY3MDNhMQ==", "commit": {"author": {"name": "Will Schmidt", "email": "will_schmidt@vnet.ibm.com", "date": "2018-08-13T18:13:20Z"}, "committer": {"name": "Will Schmidt", "email": "willschm@gcc.gnu.org", "date": "2018-08-13T18:13:20Z"}, "message": "rs6000.c (rs6000_builtin_valid_without_lhs): Add vec_xst variants to the list.\n\n[gcc]\n\n2018-08-13 Will Schmidt <will_schmidt@vnet.ibm.com>\n\n\t* config/rs6000/rs6000.c (rs6000_builtin_valid_without_lhs): Add\n\tvec_xst variants to the list.\n\t(rs6000_gimple_fold_builtin): Add support for folding unaligned\n\tvector loads and stores.\n\nFrom-SVN: r263512", "tree": {"sha": "a2689e9a16911d275c1dd235966d7b0c75b5c2db", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a2689e9a16911d275c1dd235966d7b0c75b5c2db"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3f7a77cd20d07c93446dbcef75d41e85106703a1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f7a77cd20d07c93446dbcef75d41e85106703a1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3f7a77cd20d07c93446dbcef75d41e85106703a1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f7a77cd20d07c93446dbcef75d41e85106703a1/comments", "author": {"login": "willschm", "id": 44359, "node_id": "MDQ6VXNlcjQ0MzU5", "avatar_url": "https://avatars.githubusercontent.com/u/44359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/willschm", "html_url": "https://github.com/willschm", "followers_url": "https://api.github.com/users/willschm/followers", "following_url": "https://api.github.com/users/willschm/following{/other_user}", "gists_url": "https://api.github.com/users/willschm/gists{/gist_id}", "starred_url": "https://api.github.com/users/willschm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/willschm/subscriptions", "organizations_url": "https://api.github.com/users/willschm/orgs", "repos_url": "https://api.github.com/users/willschm/repos", "events_url": "https://api.github.com/users/willschm/events{/privacy}", "received_events_url": "https://api.github.com/users/willschm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "23aa9f7c4637ad51587e536e245ae6adb5391bbc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/23aa9f7c4637ad51587e536e245ae6adb5391bbc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/23aa9f7c4637ad51587e536e245ae6adb5391bbc"}], "stats": {"total": 84, "additions": 84, "deletions": 0}, "files": [{"sha": "00b03c9d1d4ce7ad976a205c13a0d1a3e8f2f951", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f7a77cd20d07c93446dbcef75d41e85106703a1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f7a77cd20d07c93446dbcef75d41e85106703a1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3f7a77cd20d07c93446dbcef75d41e85106703a1", "patch": "@@ -1,3 +1,10 @@\n+2018-08-13 Will Schmidt <will_schmidt@vnet.ibm.com>\n+\n+\t* config/rs6000/rs6000.c (rs6000_builtin_valid_without_lhs): Add\n+\tvec_xst variants to the list.\n+\t(rs6000_gimple_fold_builtin): Add support for folding unaligned\n+\tvector loads and stores.\n+\n 2018-08-13  David Edelsohn  <dje.gcc@gmail.com>\n \n \t* config.gcc (rs6000-ibm-aix4.x): Delete."}, {"sha": "9a1fb7da4f3b00a6bca8f57812813511d89538cc", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f7a77cd20d07c93446dbcef75d41e85106703a1/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f7a77cd20d07c93446dbcef75d41e85106703a1/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=3f7a77cd20d07c93446dbcef75d41e85106703a1", "patch": "@@ -15069,6 +15069,12 @@ rs6000_builtin_valid_without_lhs (enum rs6000_builtins fn_code)\n     case ALTIVEC_BUILTIN_STVX_V4SF:\n     case ALTIVEC_BUILTIN_STVX_V2DI:\n     case ALTIVEC_BUILTIN_STVX_V2DF:\n+    case VSX_BUILTIN_STXVW4X_V16QI:\n+    case VSX_BUILTIN_STXVW4X_V8HI:\n+    case VSX_BUILTIN_STXVW4X_V4SF:\n+    case VSX_BUILTIN_STXVW4X_V4SI:\n+    case VSX_BUILTIN_STXVD2X_V2DF:\n+    case VSX_BUILTIN_STXVD2X_V2DI:\n       return true;\n     default:\n       return false;\n@@ -15578,6 +15584,77 @@ rs6000_gimple_fold_builtin (gimple_stmt_iterator *gsi)\n \treturn true;\n       }\n \n+    /* unaligned Vector loads.  */\n+    case VSX_BUILTIN_LXVW4X_V16QI:\n+    case VSX_BUILTIN_LXVW4X_V8HI:\n+    case VSX_BUILTIN_LXVW4X_V4SF:\n+    case VSX_BUILTIN_LXVW4X_V4SI:\n+    case VSX_BUILTIN_LXVD2X_V2DF:\n+    case VSX_BUILTIN_LXVD2X_V2DI:\n+      {\n+\t arg0 = gimple_call_arg (stmt, 0);  // offset\n+\t arg1 = gimple_call_arg (stmt, 1);  // address\n+\t lhs = gimple_call_lhs (stmt);\n+\t location_t loc = gimple_location (stmt);\n+\t /* Since arg1 may be cast to a different type, just use ptr_type_node\n+\t    here instead of trying to enforce TBAA on pointer types.  */\n+\t tree arg1_type = ptr_type_node;\n+\t tree lhs_type = TREE_TYPE (lhs);\n+\t /* In GIMPLE the type of the MEM_REF specifies the alignment.  The\n+\t   required alignment (power) is 4 bytes regardless of data type.  */\n+\t tree align_ltype = build_aligned_type (lhs_type, 4);\n+\t /* POINTER_PLUS_EXPR wants the offset to be of type 'sizetype'.  Create\n+\t    the tree using the value from arg0.  The resulting type will match\n+\t    the type of arg1.  */\n+\t gimple_seq stmts = NULL;\n+\t tree temp_offset = gimple_convert (&stmts, loc, sizetype, arg0);\n+\t tree temp_addr = gimple_build (&stmts, loc, POINTER_PLUS_EXPR,\n+\t\t\t\t       arg1_type, arg1, temp_offset);\n+\t gsi_insert_seq_before (gsi, stmts, GSI_SAME_STMT);\n+\t /* Use the build2 helper to set up the mem_ref.  The MEM_REF could also\n+\t    take an offset, but since we've already incorporated the offset\n+\t    above, here we just pass in a zero.  */\n+\t gimple *g;\n+\t g = gimple_build_assign (lhs, build2 (MEM_REF, align_ltype, temp_addr,\n+\t\t\t\t\t\tbuild_int_cst (arg1_type, 0)));\n+\t gimple_set_location (g, loc);\n+\t gsi_replace (gsi, g, true);\n+\t return true;\n+      }\n+\n+    /* unaligned Vector stores.  */\n+    case VSX_BUILTIN_STXVW4X_V16QI:\n+    case VSX_BUILTIN_STXVW4X_V8HI:\n+    case VSX_BUILTIN_STXVW4X_V4SF:\n+    case VSX_BUILTIN_STXVW4X_V4SI:\n+    case VSX_BUILTIN_STXVD2X_V2DF:\n+    case VSX_BUILTIN_STXVD2X_V2DI:\n+      {\n+\t arg0 = gimple_call_arg (stmt, 0); /* Value to be stored.  */\n+\t arg1 = gimple_call_arg (stmt, 1); /* Offset.  */\n+\t tree arg2 = gimple_call_arg (stmt, 2); /* Store-to address.  */\n+\t location_t loc = gimple_location (stmt);\n+\t tree arg0_type = TREE_TYPE (arg0);\n+\t /* Use ptr_type_node (no TBAA) for the arg2_type.  */\n+\t tree arg2_type = ptr_type_node;\n+\t /* In GIMPLE the type of the MEM_REF specifies the alignment.  The\n+\t    required alignment (power) is 4 bytes regardless of data type.  */\n+\t tree align_stype = build_aligned_type (arg0_type, 4);\n+\t /* POINTER_PLUS_EXPR wants the offset to be of type 'sizetype'.  Create\n+\t    the tree using the value from arg1.  */\n+\t gimple_seq stmts = NULL;\n+\t tree temp_offset = gimple_convert (&stmts, loc, sizetype, arg1);\n+\t tree temp_addr = gimple_build (&stmts, loc, POINTER_PLUS_EXPR,\n+\t\t\t\t       arg2_type, arg2, temp_offset);\n+\t gsi_insert_seq_before (gsi, stmts, GSI_SAME_STMT);\n+\t gimple *g;\n+\t g = gimple_build_assign (build2 (MEM_REF, align_stype, temp_addr,\n+\t\t\t\t\t   build_int_cst (arg2_type, 0)), arg0);\n+\t gimple_set_location (g, loc);\n+\t gsi_replace (gsi, g, true);\n+\t return true;\n+      }\n+\n     /* Vector Fused multiply-add (fma).  */\n     case ALTIVEC_BUILTIN_VMADDFP:\n     case VSX_BUILTIN_XVMADDDP:"}]}