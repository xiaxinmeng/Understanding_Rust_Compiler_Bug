{"sha": "51597c23dae3e1613a73afe81e4e7c5247ae4986", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTE1OTdjMjNkYWUzZTE2MTNhNzNhZmU4MWU0ZTdjNTI0N2FlNDk4Ng==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-04-24T14:56:49Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-04-24T14:56:49Z"}, "message": "[multiple changes]\n\n2013-04-24  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* exp_ch6.adb (Expand_Actuals): Add a predicate check on an\n\tactual the related type has a predicate function.\n\t* sem_ch3.adb (Constant_Redeclaration): Ensure that the related\n\ttype has an invariant procedure before building a call to it.\n\t* sem_ch6.adb (Append_Enabled_Item): New routine.\n\t(Check_Access_Invariants): Use routine\n\tAppend_Enabled_Item to chain onto the list of postconditions.\n\t(Contains_Enabled_Pragmas): Removed.\n\t(Expand_Contract_Cases): Use routine Append_Enabled_Item to chain onto\n\tthe list of postconditions.\n\t(Invariants_Or_Predicates_Present): Removed.\n\t(Process_PPCs): Partially reimplemented.\n\n2013-04-24  Sergey Rybin  <rybin@adacore.com frybin>\n\n\t* tree_io.ads: Update ASIS_Version_Number because of changes\n\tin the way how entities are chained in a scope by means of\n\tNext_Entity link.\n\n2013-04-24  Ed Schonberg  <schonberg@adacore.com>\n\n\t* exp_ch13.adb (Expand_N_Attribute_Definition_Clause, case\n\tStorage_Size): If the clause is not from an aspect, insert\n\tassignment to size variable of task type at the point of the\n\tclause, not after the task definition, to prevent access before\n\telaboration in the back-end.\n\n2013-04-24  Yannick Moy  <moy@adacore.com>\n\n\t* sem_prag.adb (Sig_Flags): Set correct value for Pragma_Assume.\n\n2013-04-24  Yannick Moy  <moy@adacore.com>\n\n\t* gnat_rm.texi: Document 'Loop_Entry.\n\n2013-04-24  Jose Ruiz  <ruiz@adacore.com>\n\n\t* s-tassta.adb, s-tarest.adb (Task_Wrapper): Start looking for\n\tfall-back termination handlers from the parents, because they apply\n\tonly to dependent tasks.\n\t* s-solita.adb (Task_Termination_Handler_T): Do not look for fall-back\n\ttermination handlers because the environment task has no parent,\n\tand if it defines one of these handlers it does not apply to\n\titself because they apply only to dependent tasks.\n\nFrom-SVN: r198244", "tree": {"sha": "7276b93044bc9733edaa3d76786517d84dc677c8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7276b93044bc9733edaa3d76786517d84dc677c8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/51597c23dae3e1613a73afe81e4e7c5247ae4986", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/51597c23dae3e1613a73afe81e4e7c5247ae4986", "html_url": "https://github.com/Rust-GCC/gccrs/commit/51597c23dae3e1613a73afe81e4e7c5247ae4986", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/51597c23dae3e1613a73afe81e4e7c5247ae4986/comments", "author": null, "committer": null, "parents": [{"sha": "0d5fbf52732b39f55714baad348c3269db8bb1b9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d5fbf52732b39f55714baad348c3269db8bb1b9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0d5fbf52732b39f55714baad348c3269db8bb1b9"}], "stats": {"total": 594, "additions": 310, "deletions": 284}, "files": [{"sha": "cfa0ea749abf8f9b67206f42b3dd5e599a6e16c4", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51597c23dae3e1613a73afe81e4e7c5247ae4986/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51597c23dae3e1613a73afe81e4e7c5247ae4986/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=51597c23dae3e1613a73afe81e4e7c5247ae4986", "patch": "@@ -1,3 +1,50 @@\n+2013-04-24  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* exp_ch6.adb (Expand_Actuals): Add a predicate check on an\n+\tactual the related type has a predicate function.\n+\t* sem_ch3.adb (Constant_Redeclaration): Ensure that the related\n+\ttype has an invariant procedure before building a call to it.\n+\t* sem_ch6.adb (Append_Enabled_Item): New routine.\n+\t(Check_Access_Invariants): Use routine\n+\tAppend_Enabled_Item to chain onto the list of postconditions.\n+\t(Contains_Enabled_Pragmas): Removed.\n+\t(Expand_Contract_Cases): Use routine Append_Enabled_Item to chain onto\n+\tthe list of postconditions.\n+\t(Invariants_Or_Predicates_Present): Removed.\n+\t(Process_PPCs): Partially reimplemented.\n+\n+2013-04-24  Sergey Rybin  <rybin@adacore.com frybin>\n+\n+\t* tree_io.ads: Update ASIS_Version_Number because of changes\n+\tin the way how entities are chained in a scope by means of\n+\tNext_Entity link.\n+\n+2013-04-24  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* exp_ch13.adb (Expand_N_Attribute_Definition_Clause, case\n+\tStorage_Size): If the clause is not from an aspect, insert\n+\tassignment to size variable of task type at the point of the\n+\tclause, not after the task definition, to prevent access before\n+\telaboration in the back-end.\n+\n+2013-04-24  Yannick Moy  <moy@adacore.com>\n+\n+\t* sem_prag.adb (Sig_Flags): Set correct value for Pragma_Assume.\n+\n+2013-04-24  Yannick Moy  <moy@adacore.com>\n+\n+\t* gnat_rm.texi: Document 'Loop_Entry.\n+\n+2013-04-24  Jose Ruiz  <ruiz@adacore.com>\n+\n+\t* s-tassta.adb, s-tarest.adb (Task_Wrapper): Start looking for\n+\tfall-back termination handlers from the parents, because they apply\n+\tonly to dependent tasks.\n+\t* s-solita.adb (Task_Termination_Handler_T): Do not look for fall-back\n+\ttermination handlers because the environment task has no parent,\n+\tand if it defines one of these handlers it does not apply to\n+\titself because they apply only to dependent tasks.\n+\n 2013-04-24  Robert Dewar  <dewar@adacore.com>\n \n \t* sem_type.adb, exp_attr.adb, exp_ch4.adb: Minor reformatting."}, {"sha": "295d4ade56a25babe0b94fea32deef763a863c3d", "filename": "gcc/ada/exp_ch13.adb", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51597c23dae3e1613a73afe81e4e7c5247ae4986/gcc%2Fada%2Fexp_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51597c23dae3e1613a73afe81e4e7c5247ae4986/gcc%2Fada%2Fexp_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch13.adb?ref=51597c23dae3e1613a73afe81e4e7c5247ae4986", "patch": "@@ -184,8 +184,19 @@ package body Exp_Ch13 is\n                       Expression =>\n                         Convert_To (RTE (RE_Size_Type), Expression (N)));\n \n-                  Insert_After\n-                    (Parent (Storage_Size_Variable (Entity (N))), Assign);\n+                  --  If the clause is not generated by an aspect, insert\n+                  --  the assignment here.  Freezing rules ensure that this\n+                  --  is safe, or clause will have been rejected already.\n+\n+                  if Is_List_Member (N) then\n+                     Insert_After (N, Assign);\n+\n+                  --  Otherwise, insert assignment after task declaration.\n+\n+                  else\n+                     Insert_After\n+                       (Parent (Storage_Size_Variable (Entity (N))), Assign);\n+                  end if;\n \n                   Analyze (Assign);\n                end;"}, {"sha": "5b9773999570055b4efb42c3992f41a99aefdb2b", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51597c23dae3e1613a73afe81e4e7c5247ae4986/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51597c23dae3e1613a73afe81e4e7c5247ae4986/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=51597c23dae3e1613a73afe81e4e7c5247ae4986", "patch": "@@ -1728,17 +1728,19 @@ package body Exp_Ch6 is\n             --  procedure does not include a predicate call, so it has to be\n             --  generated explicitly.\n \n-            if (Has_Aspect (E_Actual, Aspect_Predicate)\n-                  or else\n-                Has_Aspect (E_Actual, Aspect_Dynamic_Predicate)\n-                  or else\n-                Has_Aspect (E_Actual, Aspect_Static_Predicate))\n-              and then not Is_Init_Proc (Subp)\n+            if not Is_Init_Proc (Subp)\n+              and then (Has_Aspect (E_Actual, Aspect_Predicate)\n+                          or else\n+                        Has_Aspect (E_Actual, Aspect_Dynamic_Predicate)\n+                          or else\n+                        Has_Aspect (E_Actual, Aspect_Static_Predicate))\n+              and then Present (Predicate_Function (E_Actual))\n             then\n-               if (Is_Derived_Type (E_Actual)\n-                    and then Is_Overloadable (Subp)\n-                    and then Is_Inherited_Operation_For_Type (Subp, E_Actual))\n-                 or else Is_Entity_Name (Actual)\n+               if Is_Entity_Name (Actual)\n+                 or else\n+                   (Is_Derived_Type (E_Actual)\n+                     and then Is_Overloadable (Subp)\n+                     and then Is_Inherited_Operation_For_Type (Subp, E_Actual))\n                then\n                   Append_To (Post_Call,\n                     Make_Predicate_Check (E_Actual, Actual));"}, {"sha": "6b2574b823db3e37b29cbed4ac416ad7b05dd778", "filename": "gcc/ada/gnat_rm.texi", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51597c23dae3e1613a73afe81e4e7c5247ae4986/gcc%2Fada%2Fgnat_rm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51597c23dae3e1613a73afe81e4e7c5247ae4986/gcc%2Fada%2Fgnat_rm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_rm.texi?ref=51597c23dae3e1613a73afe81e4e7c5247ae4986", "patch": "@@ -277,6 +277,7 @@ Implementation Defined Attributes\n * Integer_Value::\n * Invalid_Value::\n * Large::\n+* Loop_Entry::\n * Machine_Size::\n * Mantissa::\n * Max_Interrupt_Priority::\n@@ -6682,6 +6683,7 @@ consideration, you should minimize the use of these attributes.\n * Integer_Value::\n * Invalid_Value::\n * Large::\n+* Loop_Entry::\n * Machine_Size::\n * Mantissa::\n * Max_Interrupt_Priority::\n@@ -7173,6 +7175,36 @@ The @code{Large} attribute is provided for compatibility with Ada 83.  See\n the Ada 83 reference manual for an exact description of the semantics of\n this attribute.\n \n+@node Loop_Entry\n+@unnumberedsec Loop_Entry\n+@findex Loop_Entry\n+@noindent\n+Syntax:\n+\n+@smallexample @c ada\n+X'Loop_Entry [(loop_name)]\n+@end smallexample\n+\n+@noindent\n+The @code{Loop_Entry} attribute is used to refer to the value that an\n+expression had upon entry to a given loop in much the same way that the\n+@code{Old} attribute in a subprogram postcondition can be used to refer\n+to the value an expression had upon entry to the subprogram. The\n+relevant loop is either identified by the given loop name, or it is the\n+innermost enclosing loop when no loop name is given.\n+\n+@noindent\n+A @code{Loop_Entry} attribute can only occur within a\n+@code{Loop_Variant} or @code{Loop_Invariant} pragma. A common use of\n+@code{Loop_Entry} is to compare the current value of objects with their\n+initial value at loop entry, in a @code{Loop_Invariant} pragma.\n+\n+@noindent\n+The effect of using @code{X'Loop_Entry} is the same as declaring\n+a constant initialized with the initial value of @code{X} at loop\n+entry. This copy is not performed if the loop is not entered, or if the\n+corresponding pragmas are ignored or disabled.\n+\n @node Machine_Size\n @unnumberedsec Machine_Size\n @findex Machine_Size"}, {"sha": "19a422a81dff09f6172be2b0477b88aa0cb6a9b5", "filename": "gcc/ada/s-solita.adb", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51597c23dae3e1613a73afe81e4e7c5247ae4986/gcc%2Fada%2Fs-solita.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51597c23dae3e1613a73afe81e4e7c5247ae4986/gcc%2Fada%2Fs-solita.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-solita.adb?ref=51597c23dae3e1613a73afe81e4e7c5247ae4986", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2004-2011, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2004-2013, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -181,12 +181,13 @@ package body System.Soft_Links.Tasking is\n \n       --  There is no need for explicit protection against race conditions for\n       --  this part because it can only be executed by the environment task\n-      --  after all the other tasks have been finalized.\n+      --  after all the other tasks have been finalized. Note that there is no\n+      --  fall-back handler which could apply to this environment task because\n+      --  it has no parents, and, as specified in ARM C.7.3 par. 9/2, \"the\n+      --  fall-back handler applies only to the dependent tasks of the task\".\n \n       if Self_Id.Common.Specific_Handler /= null then\n          Self_Id.Common.Specific_Handler.all (Cause, Self_Id, EO);\n-      elsif Self_Id.Common.Fall_Back_Handler /= null then\n-         Self_Id.Common.Fall_Back_Handler.all (Cause, Self_Id, EO);\n       end if;\n    end Task_Termination_Handler_T;\n "}, {"sha": "399437fccd8c1671a7e903ed2e8d4333cfaa3e76", "filename": "gcc/ada/s-tarest.adb", "status": "modified", "additions": 27, "deletions": 31, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51597c23dae3e1613a73afe81e4e7c5247ae4986/gcc%2Fada%2Fs-tarest.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51597c23dae3e1613a73afe81e4e7c5247ae4986/gcc%2Fada%2Fs-tarest.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-tarest.adb?ref=51597c23dae3e1613a73afe81e4e7c5247ae4986", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                  B o d y                                 --\n --                                                                          --\n---         Copyright (C) 1999-2012, Free Software Foundation, Inc.          --\n+--         Copyright (C) 1999-2013, Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -268,49 +268,45 @@ package body System.Tasking.Restricted.Stages is\n             Save_Occurrence (EO, E);\n       end;\n \n-      --  Look for a fall-back handler. It can be either in the task itself\n-      --  or in the environment task. Note that this code is always executed\n-      --  by a task whose master is the environment task. The task termination\n-      --  code for the environment task is executed by\n-      --  SSL.Task_Termination_Handler.\n+      --  Look for a fall-back handler.\n \n       --  This package is part of the restricted run time which supports\n       --  neither task hierarchies (No_Task_Hierarchy) nor specific task\n       --  termination handlers (No_Specific_Termination_Handlers).\n \n-      --  There is no need for explicit protection against race conditions\n-      --  for Self_ID.Common.Fall_Back_Handler because this procedure can\n-      --  only be executed by Self, and the Fall_Back_Handler can only be\n-      --  modified by Self.\n+      --  As specified in ARM C.7.3 par. 9/2, \"the fall-back handler applies\n+      --  only to the dependent tasks of the task\". Hence, if the terminating\n+      --  tasks (Self_ID) had a fall-back handler, it would not apply to\n+      --  itself. This code is always executed by a task whose master is the\n+      --  environment task (the task termination code for the environment task\n+      --  is executed by SSL.Task_Termination_Handler), so the fall-back\n+      --  handler to execute for this task can only be defined by its parent\n+      --  (there is no grandparent).\n \n-      if Self_ID.Common.Fall_Back_Handler /= null then\n-         Self_ID.Common.Fall_Back_Handler (Cause, Self_ID, EO);\n-      else\n-         declare\n-            TH : Termination_Handler := null;\n+      declare\n+         TH : Termination_Handler := null;\n \n-         begin\n-            if Single_Lock then\n-               Lock_RTS;\n-            end if;\n+      begin\n+         if Single_Lock then\n+            Lock_RTS;\n+         end if;\n \n-            Write_Lock (Self_ID.Common.Parent);\n+         Write_Lock (Self_ID.Common.Parent);\n \n-            TH := Self_ID.Common.Parent.Common.Fall_Back_Handler;\n+         TH := Self_ID.Common.Parent.Common.Fall_Back_Handler;\n \n-            Unlock (Self_ID.Common.Parent);\n+         Unlock (Self_ID.Common.Parent);\n \n-            if Single_Lock then\n-               Unlock_RTS;\n-            end if;\n+         if Single_Lock then\n+            Unlock_RTS;\n+         end if;\n \n-            --  Execute the task termination handler if we found it\n+         --  Execute the task termination handler if we found it\n \n-            if TH /= null then\n-               TH.all (Cause, Self_ID, EO);\n-            end if;\n-         end;\n-      end if;\n+         if TH /= null then\n+            TH.all (Cause, Self_ID, EO);\n+         end if;\n+      end;\n \n       Terminate_Task (Self_ID);\n    end Task_Wrapper;"}, {"sha": "487bf8d5340a81c895e3e5f0cbe13d2d57a0dd3b", "filename": "gcc/ada/s-tassta.adb", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51597c23dae3e1613a73afe81e4e7c5247ae4986/gcc%2Fada%2Fs-tassta.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51597c23dae3e1613a73afe81e4e7c5247ae4986/gcc%2Fada%2Fs-tassta.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-tassta.adb?ref=51597c23dae3e1613a73afe81e4e7c5247ae4986", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                  B o d y                                 --\n --                                                                          --\n---         Copyright (C) 1992-2012, Free Software Foundation, Inc.          --\n+--         Copyright (C) 1992-2013, Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -1075,29 +1075,30 @@ package body System.Tasking.Stages is\n       procedure Search_Fall_Back_Handler (ID : Task_Id);\n       --  Procedure that searches recursively a fall-back handler through the\n       --  master relationship. If the handler is found, its pointer is stored\n-      --  in TH.\n+      --  in TH. It stops when the handler is found or when the ID is null.\n \n       ------------------------------\n       -- Search_Fall_Back_Handler --\n       ------------------------------\n \n       procedure Search_Fall_Back_Handler (ID : Task_Id) is\n       begin\n+         --  A null Task_Id indicates that we have reached the root of the\n+         --  task hierarchy and no handler has been found.\n+\n+         if ID = null then\n+            return;\n+\n          --  If there is a fall back handler, store its pointer for later\n          --  execution.\n \n-         if ID.Common.Fall_Back_Handler /= null then\n+         elsif ID.Common.Fall_Back_Handler /= null then\n             TH := ID.Common.Fall_Back_Handler;\n \n          --  Otherwise look for a fall back handler in the parent\n \n-         elsif ID.Common.Parent /= null then\n-            Search_Fall_Back_Handler (ID.Common.Parent);\n-\n-         --  Otherwise, do nothing\n-\n          else\n-            return;\n+            Search_Fall_Back_Handler (ID.Common.Parent);\n          end if;\n       end Search_Fall_Back_Handler;\n \n@@ -1331,9 +1332,12 @@ package body System.Tasking.Stages is\n          TH := Self_ID.Common.Specific_Handler;\n       else\n          --  Look for a fall-back handler following the master relationship\n-         --  for the task.\n+         --  for the task. As specified in ARM C.7.3 par. 9/2, \"the fall-back\n+         --  handler applies only to the dependent tasks of the task\". Hence,\n+         --  if the terminating tasks (Self_ID) had a fall-back handler, it\n+         --  would not apply to itself, so we start the search with the parent.\n \n-         Search_Fall_Back_Handler (Self_ID);\n+         Search_Fall_Back_Handler (Self_ID.Common.Parent);\n       end if;\n \n       Unlock (Self_ID);"}, {"sha": "9e5b8deb313c65b9d92bcaea2690f8bf3a9caa57", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51597c23dae3e1613a73afe81e4e7c5247ae4986/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51597c23dae3e1613a73afe81e4e7c5247ae4986/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=51597c23dae3e1613a73afe81e4e7c5247ae4986", "patch": "@@ -10761,13 +10761,9 @@ package body Sem_Ch3 is\n          --  A deferred constant is a visible entity. If type has invariants,\n          --  verify that the initial value satisfies them.\n \n-         if Expander_Active and then Has_Invariants (T) then\n-            declare\n-               Call : constant Node_Id :=\n-                 Make_Invariant_Call (New_Occurrence_Of (Prev, Sloc (N)));\n-            begin\n-               Insert_After (N, Call);\n-            end;\n+         if Has_Invariants (T) and then Present (Invariant_Procedure (T)) then\n+            Insert_After (N,\n+              Make_Invariant_Call (New_Occurrence_Of (Prev, Sloc (N))));\n          end if;\n       end if;\n    end Constant_Redeclaration;"}, {"sha": "b9be549578ac8343dabcd02ed548a7e313554675", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 152, "deletions": 217, "changes": 369, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51597c23dae3e1613a73afe81e4e7c5247ae4986/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51597c23dae3e1613a73afe81e4e7c5247ae4986/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=51597c23dae3e1613a73afe81e4e7c5247ae4986", "patch": "@@ -332,14 +332,14 @@ package body Sem_Ch6 is\n          end;\n       end if;\n \n-      Prev     := Current_Entity_In_Scope (Defining_Entity (Spec));\n+      Prev := Current_Entity_In_Scope (Defining_Entity (Spec));\n \n       --  If there are previous overloadable entities with the same name,\n       --  check whether any of them is completed by the expression function.\n \n       if Present (Prev) and then Is_Overloadable (Prev) then\n-         Def_Id   := Analyze_Subprogram_Specification (Spec);\n-         Prev     := Find_Corresponding_Spec (N);\n+         Def_Id := Analyze_Subprogram_Specification (Spec);\n+         Prev   := Find_Corresponding_Spec (N);\n       end if;\n \n       Ret := Make_Simple_Return_Statement (LocX, Expression (N));\n@@ -11198,18 +11198,17 @@ package body Sem_Ch6 is\n       Plist : List_Id := No_List;\n       --  List of generated postconditions\n \n+      procedure Append_Enabled_Item (Item : Node_Id; List : in out List_Id);\n+      --  Append a node to a list. If there is no list, create a new one. When\n+      --  the item denotes a pragma, it is added to the list only when it is\n+      --  enabled.\n+\n       procedure Check_Access_Invariants (E : Entity_Id);\n       --  If the subprogram returns an access to a type with invariants, or\n       --  has access parameters whose designated type has an invariant, then\n       --  under the same visibility conditions as for other invariant checks,\n       --  the type invariant must be applied to the returned value.\n \n-      function Contains_Enabled_Pragmas (L : List_Id) return Boolean;\n-      --  Determine whether list L has at least one enabled pragma. The routine\n-      --  ignores other non-pragma elements.\n-      --  This is NOT what the routine does??? It returns False if there is\n-      --  one ignored pragma ???\n-\n       procedure Expand_Contract_Cases (CCs : Node_Id; Subp_Id : Entity_Id);\n       --  Given pragma Contract_Cases CCs, create the circuitry needed to\n       --  evaluate case guards and trigger consequence expressions. Subp_Id\n@@ -11226,11 +11225,6 @@ package body Sem_Ch6 is\n       procedure Insert_After_Last_Declaration (Nod : Node_Id);\n       --  Insert node Nod after the last declaration of the context\n \n-      function Invariants_Or_Predicates_Present return Boolean;\n-      --  Determines if any invariants or predicates are present for any OUT\n-      --  or IN OUT parameters of the subprogram, or (for a function) if the\n-      --  return value has an invariant.\n-\n       function Is_Public_Subprogram_For (T : Entity_Id) return Boolean;\n       --  T is the entity for a private type for which invariants are defined.\n       --  This function returns True if the procedure corresponding to the\n@@ -11240,6 +11234,30 @@ package body Sem_Ch6 is\n       --  that an invariant check is required (for an IN OUT parameter, or\n       --  the returned value of a function.\n \n+      -------------------------\n+      -- Append_Enabled_Item --\n+      -------------------------\n+\n+      procedure Append_Enabled_Item (Item : Node_Id; List : in out List_Id) is\n+      begin\n+         --  Do not chain ignored or disabled pragmas\n+\n+         if Nkind (Item) = N_Pragma\n+           and then (Is_Ignored (Item) or else Is_Disabled (Item))\n+         then\n+            null;\n+\n+         --  Add the item\n+\n+         else\n+            if No (List) then\n+               List := New_List;\n+            end if;\n+\n+            Append (Item, List);\n+         end if;\n+      end Append_Enabled_Item;\n+\n       -----------------------------\n       -- Check_Access_Invariants --\n       -----------------------------\n@@ -11266,39 +11284,18 @@ package body Sem_Ch6 is\n \n                Call := Make_Invariant_Call (Obj);\n \n-               Append_To (Plist,\n-                 Make_If_Statement (Loc,\n-                   Condition =>\n-                     Make_Op_Ne (Loc,\n-                       Left_Opnd   => Make_Null (Loc),\n-                       Right_Opnd  => New_Occurrence_Of (E, Loc)),\n-                   Then_Statements => New_List (Call)));\n+               Append_Enabled_Item\n+                 (Make_If_Statement (Loc,\n+                    Condition =>\n+                      Make_Op_Ne (Loc,\n+                        Left_Opnd   => Make_Null (Loc),\n+                        Right_Opnd  => New_Occurrence_Of (E, Loc)),\n+                    Then_Statements => New_List (Call)),\n+                  List => Plist);\n             end if;\n          end if;\n       end Check_Access_Invariants;\n \n-      ------------------------------\n-      -- Contains_Enabled_Pragmas --\n-      ------------------------------\n-\n-      --  This routine does not implement its documented spec ???\n-\n-      function Contains_Enabled_Pragmas (L : List_Id) return Boolean is\n-         Prag : Node_Id;\n-\n-      begin\n-         Prag := First (L);\n-         while Present (Prag) loop\n-            if Nkind (Prag) = N_Pragma and then Is_Ignored (Prag) then\n-               return False;\n-            end if;\n-\n-            Next (Prag);\n-         end loop;\n-\n-         return True;\n-      end Contains_Enabled_Pragmas;\n-\n       ---------------------------\n       -- Expand_Contract_Cases --\n       ---------------------------\n@@ -11759,11 +11756,7 @@ package body Sem_Ch6 is\n          --  Raise Assertion_Error when the corresponding consequence of a case\n          --  guard that evaluated to True fails.\n \n-         if No (Plist) then\n-            Plist := New_List;\n-         end if;\n-\n-         Append_To (Plist, Conseq_Checks);\n+         Append_Enabled_Item (Conseq_Checks, Plist);\n       end Expand_Contract_Cases;\n \n       --------------\n@@ -11889,51 +11882,6 @@ package body Sem_Ch6 is\n          end if;\n       end Insert_After_Last_Declaration;\n \n-      --------------------------------------\n-      -- Invariants_Or_Predicates_Present --\n-      --------------------------------------\n-\n-      function Invariants_Or_Predicates_Present return Boolean is\n-         Formal : Entity_Id;\n-\n-      begin\n-         --  Check function return result. If result is an access type there\n-         --  may be invariants on the designated type.\n-\n-         if Ekind (Designator) /= E_Procedure\n-           and then Has_Invariants (Etype (Designator))\n-         then\n-            return True;\n-\n-         elsif Ekind (Designator) /= E_Procedure\n-           and then Is_Access_Type (Etype (Designator))\n-           and then Has_Invariants (Designated_Type (Etype (Designator)))\n-         then\n-            return True;\n-         end if;\n-\n-         --  Check parameters\n-\n-         Formal := First_Formal (Designator);\n-         while Present (Formal) loop\n-            if Ekind (Formal) /= E_In_Parameter\n-              and then (Has_Invariants (Etype (Formal))\n-                         or else Present (Predicate_Function (Etype (Formal))))\n-            then\n-               return True;\n-\n-            elsif Is_Access_Type (Etype (Formal))\n-              and then Has_Invariants (Designated_Type (Etype (Formal)))\n-            then\n-               return True;\n-            end if;\n-\n-            Next_Formal (Formal);\n-         end loop;\n-\n-         return False;\n-      end Invariants_Or_Predicates_Present;\n-\n       ------------------------------\n       -- Is_Public_Subprogram_For --\n       ------------------------------\n@@ -11986,6 +11934,14 @@ package body Sem_Ch6 is\n          end if;\n       end Is_Public_Subprogram_For;\n \n+      --  Local variables\n+\n+      Formal     : Node_Id;\n+      Formal_Typ : Entity_Id;\n+      Func_Typ   : Entity_Id;\n+      Post_Proc  : Entity_Id;\n+      Result     : Node_Id;\n+\n    --  Start of processing for Process_PPCs\n \n    begin\n@@ -11997,10 +11953,18 @@ package body Sem_Ch6 is\n          Designator := Body_Id;\n       end if;\n \n+      --  Do not process a predicate function as its body will contain a\n+      --  recursive call to itself and blow up the stack.\n+\n+      if Ekind (Designator) = E_Function\n+        and then Is_Predicate_Function (Designator)\n+      then\n+         return;\n+\n       --  Internally generated subprograms, such as type-specific functions,\n       --  don't get assertion checks.\n \n-      if Get_TSS_Name (Designator) /= TSS_Null then\n+      elsif Get_TSS_Name (Designator) /= TSS_Null then\n          return;\n       end if;\n \n@@ -12153,10 +12117,6 @@ package body Sem_Ch6 is\n                --  Capture postcondition pragmas\n \n                if Pragma_Name (Prag) = Name_Postcondition then\n-                  if Plist = No_List then\n-                     Plist := Empty_List;\n-                  end if;\n-\n                   Analyze (Prag);\n \n                   --  If expansion is disabled, as in a generic unit, save\n@@ -12165,7 +12125,7 @@ package body Sem_Ch6 is\n                   if not Expander_Active then\n                      Prepend (Grab_PPC, Declarations (N));\n                   else\n-                     Append (Grab_PPC, Plist);\n+                     Append_Enabled_Item (Grab_PPC, Plist);\n                   end if;\n                end if;\n \n@@ -12244,14 +12204,10 @@ package body Sem_Ch6 is\n                   if Pragma_Name (Prag) = Name_Postcondition\n                     and then (not Class or else Class_Present (Prag))\n                   then\n-                     if Plist = No_List then\n-                        Plist := Empty_List;\n-                     end if;\n-\n                      if not Expander_Active then\n                         Prepend (Grab_PPC (Pspec), Declarations (N));\n                      else\n-                        Append (Grab_PPC (Pspec), Plist);\n+                        Append_Enabled_Item (Grab_PPC (Pspec), Plist);\n                      end if;\n                   end if;\n \n@@ -12285,147 +12241,126 @@ package body Sem_Ch6 is\n          end Spec_Postconditions;\n       end if;\n \n-      --  If we had any postconditions and expansion is enabled, or if the\n-      --  subprogram has invariants, then build the _Postconditions procedure.\n+      --  Add an invariant call to check the result of a function\n \n-      if Expander_Active\n-        and then (Invariants_Or_Predicates_Present\n-                   or else (Present (Plist)\n-                             and then Contains_Enabled_Pragmas (Plist)))\n+      if Ekind (Designator) /= E_Procedure\n+        and then Expander_Active\n+        and then Assertions_Enabled\n       then\n-         if No (Plist) then\n-            Plist := Empty_List;\n-         end if;\n+         Func_Typ := Etype (Designator);\n+         Result   := Make_Defining_Identifier (Loc, Name_uResult);\n \n-         --  Special processing for function return\n+         Set_Etype (Result, Func_Typ);\n \n-         if Ekind (Designator) /= E_Procedure then\n-            declare\n-               Rent : constant Entity_Id :=\n-                        Make_Defining_Identifier (Loc, Name_uResult);\n-               Ftyp : constant Entity_Id := Etype (Designator);\n+         --  Add argument for return\n \n-            begin\n-               Set_Etype (Rent, Ftyp);\n+         Parms := New_List (\n+           Make_Parameter_Specification (Loc,\n+             Defining_Identifier => Result,\n+             Parameter_Type      => New_Occurrence_Of (Func_Typ, Loc)));\n \n-               --  Add argument for return\n+         --  Add invariant call if returning type with invariants and this is a\n+         --  public function, i.e. a function declared in the visible part of\n+         --  the package defining the private type.\n \n-               Parms :=\n-                 New_List (\n-                   Make_Parameter_Specification (Loc,\n-                     Parameter_Type      => New_Occurrence_Of (Ftyp, Loc),\n-                     Defining_Identifier => Rent));\n+         if Has_Invariants (Func_Typ)\n+           and then Present (Invariant_Procedure (Func_Typ))\n+           and then Is_Public_Subprogram_For (Func_Typ)\n+         then\n+            Append_Enabled_Item\n+              (Make_Invariant_Call (New_Occurrence_Of (Result, Loc)), Plist);\n+         end if;\n \n-               --  Add invariant call if returning type with invariants and\n-               --  this is a public function, i.e. a function declared in the\n-               --  visible part of the package defining the private type.\n+         --  Same if return value is an access to type with invariants\n \n-               if Has_Invariants (Etype (Rent))\n-                 and then Present (Invariant_Procedure (Etype (Rent)))\n-                 and then Is_Public_Subprogram_For (Etype (Rent))\n-               then\n-                  Append_To (Plist,\n-                    Make_Invariant_Call (New_Occurrence_Of (Rent, Loc)));\n-               end if;\n+         Check_Access_Invariants (Result);\n \n-               --  Same if return value is an access to type with invariants\n+      --  Procedure case\n \n-               Check_Access_Invariants (Rent);\n-            end;\n+      else\n+         Parms := No_List;\n+      end if;\n \n-         --  Procedure rather than a function\n+      --  Add invariant calls and predicate calls for parameters. Note that\n+      --  this is done for functions as well, since in Ada 2012 they can have\n+      --  IN OUT args.\n \n-         else\n-            Parms := No_List;\n-         end if;\n+      if Expander_Active and then Assertions_Enabled then\n+         Formal := First_Formal (Designator);\n+         while Present (Formal) loop\n+            if Ekind (Formal) /= E_In_Parameter\n+              or else Is_Access_Type (Etype (Formal))\n+            then\n+               Formal_Typ := Etype (Formal);\n \n-         --  Add invariant calls and predicate calls for parameters. Note that\n-         --  this is done for functions as well, since in Ada 2012 they can\n-         --  have IN OUT args.\n+               if Has_Invariants (Formal_Typ)\n+                 and then Present (Invariant_Procedure (Formal_Typ))\n+                 and then Is_Public_Subprogram_For (Formal_Typ)\n+               then\n+                  Append_Enabled_Item\n+                    (Make_Invariant_Call (New_Occurrence_Of (Formal, Loc)),\n+                     Plist);\n+               end if;\n \n-         declare\n-            Formal : Entity_Id;\n-            Ftype  : Entity_Id;\n+               Check_Access_Invariants (Formal);\n \n-         begin\n-            Formal := First_Formal (Designator);\n-            while Present (Formal) loop\n-               if Ekind (Formal) /= E_In_Parameter\n-                 or else Is_Access_Type (Etype (Formal))\n-               then\n-                  Ftype := Etype (Formal);\n+               if Present (Predicate_Function (Formal_Typ)) then\n+                  Append_Enabled_Item\n+                    (Make_Predicate_Check\n+                      (Formal_Typ, New_Occurrence_Of (Formal, Loc)),\n+                     Plist);\n+               end if;\n+            end if;\n \n-                  if Has_Invariants (Ftype)\n-                    and then Present (Invariant_Procedure (Ftype))\n-                    and then Is_Public_Subprogram_For (Ftype)\n-                  then\n-                     Append_To (Plist,\n-                       Make_Invariant_Call\n-                         (New_Occurrence_Of (Formal, Loc)));\n-                  end if;\n+            Next_Formal (Formal);\n+         end loop;\n+      end if;\n \n-                  Check_Access_Invariants (Formal);\n+      --  Build and insert postcondition procedure\n \n-                  if Present (Predicate_Function (Ftype)) then\n-                     Append_To (Plist,\n-                       Make_Predicate_Check\n-                         (Ftype, New_Occurrence_Of (Formal, Loc)));\n-                  end if;\n-               end if;\n+      if Expander_Active and then Present (Plist) then\n+         Post_Proc :=\n+           Make_Defining_Identifier (Loc, Chars => Name_uPostconditions);\n \n-               Next_Formal (Formal);\n-            end loop;\n-         end;\n+         --  Insert the corresponding body of a post condition pragma after the\n+         --  last declaration of the context. This ensures that the body will\n+         --  not cause any premature freezing as it may mention types:\n \n-         --  Build and insert postcondition procedure\n+         --    procedure Proc (Obj : Array_Typ) is\n+         --       procedure _postconditions is\n+         --       begin\n+         --          ... Obj ...\n+         --       end _postconditions;\n \n-         declare\n-            Post_Proc : constant Entity_Id :=\n-              Make_Defining_Identifier (Loc, Chars => Name_uPostconditions);\n-            --  The entity for the _Postconditions procedure\n+         --       subtype T is Array_Typ (Obj'First (1) .. Obj'Last (1));\n+         --    begin\n \n-         begin\n-            --  Insert the corresponding body of a post condition pragma after\n-            --  the last declaration of the context. This ensures that the body\n-            --  will not cause any premature freezing as it may mention types:\n-\n-            --    procedure Proc (Obj : Array_Typ) is\n-            --       procedure _postconditions is\n-            --       begin\n-            --          ... Obj ...\n-            --       end _postconditions;\n-\n-            --       subtype T is Array_Typ (Obj'First (1) .. Obj'Last (1));\n-            --    begin\n-\n-            --  In the example above, Obj is of type T but the incorrect\n-            --  placement of _postconditions will cause a crash in gigi due to\n-            --  an out of order reference. The body of _postconditions must be\n-            --  placed after the declaration of Temp to preserve correct\n-            --  visibility.\n-\n-            Insert_After_Last_Declaration (\n-              Make_Subprogram_Body (Loc,\n-                Specification =>\n-                  Make_Procedure_Specification (Loc,\n-                    Defining_Unit_Name => Post_Proc,\n-                    Parameter_Specifications => Parms),\n+         --  In the example above, Obj is of type T but the incorrect placement\n+         --  of _postconditions will cause a crash in gigi due to an out of\n+         --  order reference. The body of _postconditions must be placed after\n+         --  the declaration of Temp to preserve correct visibility.\n \n-                Declarations => Empty_List,\n+         Insert_After_Last_Declaration (\n+           Make_Subprogram_Body (Loc,\n+             Specification              =>\n+               Make_Procedure_Specification (Loc,\n+                 Defining_Unit_Name       => Post_Proc,\n+                 Parameter_Specifications => Parms),\n \n-                Handled_Statement_Sequence =>\n-                  Make_Handled_Sequence_Of_Statements (Loc,\n-                    Statements => Plist)));\n+             Declarations               => Empty_List,\n \n-            Set_Ekind (Post_Proc, E_Procedure);\n+             Handled_Statement_Sequence =>\n+               Make_Handled_Sequence_Of_Statements (Loc,\n+                 Statements => Plist)));\n \n-            --  If this is a procedure, set the Postcondition_Proc attribute on\n-            --  the proper defining entity for the subprogram.\n+         Set_Ekind (Post_Proc, E_Procedure);\n \n-            if Ekind (Designator) = E_Procedure then\n-               Set_Postcondition_Proc (Designator, Post_Proc);\n-            end if;\n-         end;\n+         --  If this is a procedure, set the Postcondition_Proc attribute on\n+         --  the proper defining entity for the subprogram.\n+\n+         if Ekind (Designator) = E_Procedure then\n+            Set_Postcondition_Proc (Designator, Post_Proc);\n+         end if;\n \n          Set_Has_Postconditions (Designator);\n       end if;"}, {"sha": "18fd9ea7835b55e5a49d1e349e1d2ba7bbd8c2a0", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51597c23dae3e1613a73afe81e4e7c5247ae4986/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51597c23dae3e1613a73afe81e4e7c5247ae4986/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=51597c23dae3e1613a73afe81e4e7c5247ae4986", "patch": "@@ -18218,7 +18218,7 @@ package body Sem_Prag is\n       Pragma_Assert                         => -1,\n       Pragma_Assert_And_Cut                 => -1,\n       Pragma_Assertion_Policy               =>  0,\n-      Pragma_Assume                         =>  0,\n+      Pragma_Assume                         => -1,\n       Pragma_Assume_No_Invalid_Values       =>  0,\n       Pragma_Attribute_Definition           => +3,\n       Pragma_Asynchronous                   => -1,"}, {"sha": "3692d1ec65045f7f6a2b051644f8ab8b2b96ca3d", "filename": "gcc/ada/tree_io.ads", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51597c23dae3e1613a73afe81e4e7c5247ae4986/gcc%2Fada%2Ftree_io.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51597c23dae3e1613a73afe81e4e7c5247ae4986/gcc%2Fada%2Ftree_io.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftree_io.ads?ref=51597c23dae3e1613a73afe81e4e7c5247ae4986", "patch": "@@ -47,7 +47,7 @@ package Tree_IO is\n    Tree_Format_Error : exception;\n    --  Raised if a format error is detected in the input file\n \n-   ASIS_Version_Number : constant := 31;\n+   ASIS_Version_Number : constant := 32;\n    --  ASIS Version. This is used to check for consistency between the compiler\n    --  used to generate trees and an ASIS application that is reading the\n    --  trees. It must be incremented whenever a change is made to the tree\n@@ -60,6 +60,8 @@ package Tree_IO is\n    --      for concurrent types).\n    --  30  Add Check_Float_Overflow boolean to tree file\n    --  31  Remove read/write of Debug_Pragmas_Disabled/Debug_Pragmas_Enabled\n+   --  32  Change the way entities are changed through Next_Entity field in\n+   --      the hierarchy of child units\n \n    procedure Tree_Read_Initialize (Desc : File_Descriptor);\n    --  Called to initialize reading of a tree file. This call must be made"}]}