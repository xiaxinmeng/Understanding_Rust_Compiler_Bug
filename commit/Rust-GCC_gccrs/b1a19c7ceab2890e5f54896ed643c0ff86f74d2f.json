{"sha": "b1a19c7ceab2890e5f54896ed643c0ff86f74d2f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjFhMTljN2NlYWIyODkwZTVmNTQ4OTZlZDY0M2MwZmY4NmY3NGQyZg==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2003-11-12T18:15:02Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2003-11-12T18:15:02Z"}, "message": "re PR c++/12735 (duplicate error messages for redeclaration errors)\n\n\tPR c++/12735\n\t* cp-tree.h (duplicate_decls): Return a tree.\n\t* decl.c (duplicate_decls): Clarify documentation.  Return\n\terror_mark_node to indicate a failed redeclaration.\n\t* friend.c (do_friend): Handle that case.\n\t* name-lookup.c (pushdecl): Likewise.\n\nFrom-SVN: r73503", "tree": {"sha": "0f04f75058aff68b14b918b990eec3296d9afca8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0f04f75058aff68b14b918b990eec3296d9afca8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b1a19c7ceab2890e5f54896ed643c0ff86f74d2f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b1a19c7ceab2890e5f54896ed643c0ff86f74d2f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b1a19c7ceab2890e5f54896ed643c0ff86f74d2f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b1a19c7ceab2890e5f54896ed643c0ff86f74d2f/comments", "author": null, "committer": null, "parents": [{"sha": "3197c4fd19020428a20e2e78b397588f5a0c8fcf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3197c4fd19020428a20e2e78b397588f5a0c8fcf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3197c4fd19020428a20e2e78b397588f5a0c8fcf"}], "stats": {"total": 145, "additions": 91, "deletions": 54}, "files": [{"sha": "647bcd02661a90ed777eae04875f371ba976e5b6", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1a19c7ceab2890e5f54896ed643c0ff86f74d2f/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1a19c7ceab2890e5f54896ed643c0ff86f74d2f/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=b1a19c7ceab2890e5f54896ed643c0ff86f74d2f", "patch": "@@ -1,3 +1,12 @@\n+2003-11-12  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tPR c++/12735\n+\t* cp-tree.h (duplicate_decls): Return a tree.\n+\t* decl.c (duplicate_decls): Clarify documentation.  Return\n+\terror_mark_node to indicate a failed redeclaration.\n+\t* friend.c (do_friend): Handle that case.\n+\t* name-lookup.c (pushdecl): Likewise.\n+\n 2003-11-11  Jason Merrill  <jason@redhat.com>\n \n \t* cp-tree.h (DECL_NAMESPACE_ASSOCIATIONS): New macro."}, {"sha": "1c6154f469dc9e3c5445100d26e8a0c40cd7dc7b", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1a19c7ceab2890e5f54896ed643c0ff86f74d2f/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1a19c7ceab2890e5f54896ed643c0ff86f74d2f/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=b1a19c7ceab2890e5f54896ed643c0ff86f74d2f", "patch": "@@ -3623,7 +3623,7 @@ extern void pushtag\t\t\t\t(tree, tree, int);\n extern tree make_anon_name\t\t\t(void);\n extern void clear_anon_tags\t\t\t(void);\n extern int decls_match\t\t\t\t(tree, tree);\n-extern int duplicate_decls\t\t\t(tree, tree);\n+extern tree duplicate_decls\t\t\t(tree, tree);\n extern tree pushdecl_top_level\t\t\t(tree);\n extern tree pushdecl_top_level_and_finish       (tree, tree);\n extern tree push_using_decl                     (tree, tree);"}, {"sha": "3894c7ac0ecd518e9d6e8c5ddebaaf21b7bb50c3", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 47, "deletions": 27, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1a19c7ceab2890e5f54896ed643c0ff86f74d2f/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1a19c7ceab2890e5f54896ed643c0ff86f74d2f/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=b1a19c7ceab2890e5f54896ed643c0ff86f74d2f", "patch": "@@ -1137,22 +1137,22 @@ warn_extern_redeclared_static (tree newdecl, tree olddecl)\n   cp_pedwarn_at (\"previous declaration of `%D'\", olddecl);\n }\n \n-/* Handle when a new declaration NEWDECL has the same name as an old\n-   one OLDDECL in the same binding contour.  Prints an error message\n-   if appropriate.\n+/* If NEWDECL is a redeclaration of OLDDECL, merge the declarations.\n+   If the redeclaration is invalid, a diagnostic is issued, and the\n+   error_mark_node is returned.  Otherwise, OLDDECL is returned.\n \n-   If safely possible, alter OLDDECL to look like NEWDECL, and return 1.\n-   Otherwise, return 0.  */\n+   If NEWDECL is not a redeclaration of OLDDECL, NULL_TREE is\n+   returned.  */\n \n-int\n+tree\n duplicate_decls (tree newdecl, tree olddecl)\n {\n   unsigned olddecl_uid = DECL_UID (olddecl);\n   int olddecl_friend = 0, types_match = 0;\n   int new_defines_function = 0;\n \n   if (newdecl == olddecl)\n-    return 1;\n+    return olddecl;\n \n   types_match = decls_match (newdecl, olddecl);\n \n@@ -1205,7 +1205,7 @@ duplicate_decls (tree newdecl, tree olddecl)\n \t{\n           /* Avoid warnings redeclaring anticipated built-ins.  */\n           if (DECL_ANTICIPATED (olddecl))\n-            return 0;\n+            return NULL_TREE;\n \n \t  /* If you declare a built-in or predefined function name as static,\n \t     the old definition is overridden, but optionally warn this was a\n@@ -1217,7 +1217,7 @@ duplicate_decls (tree newdecl, tree olddecl)\n \t\t\t    DECL_BUILT_IN (olddecl) ? \"built-in\" : \"library\",\n \t\t\t    olddecl);\n \t      /* Discard the old built-in function.  */\n-\t      return 0;\n+\t      return NULL_TREE;\n \t    }\n \t  /* If the built-in is not ansi, then programs can override\n \t     it even globally without an error.  */\n@@ -1230,7 +1230,7 @@ duplicate_decls (tree newdecl, tree olddecl)\n \t      error (\"conflicts with built-in declaration `%#D'\",\n \t\t\tolddecl);\n \t    }\n-\t  return 0;\n+\t  return NULL_TREE;\n \t}\n       else if (!types_match)\n \t{\n@@ -1257,7 +1257,7 @@ duplicate_decls (tree newdecl, tree olddecl)\n \t    }\n \t  else\n \t    /* Discard the old built-in function.  */\n-\t    return 0;\n+\t    return NULL_TREE;\n \n \t  /* Replace the old RTL to avoid problems with inlining.  */\n \t  SET_DECL_RTL (olddecl, DECL_RTL (newdecl));\n@@ -1302,14 +1302,14 @@ duplicate_decls (tree newdecl, tree olddecl)\n \t     get shadowed, and know that if we need to find a TYPE_DECL\n \t     for a given name, we can look in the IDENTIFIER_TYPE_VALUE\n \t     slot of the identifier.  */\n-\t  return 0;\n+\t  return NULL_TREE;\n \t}\n \n       if ((TREE_CODE (newdecl) == FUNCTION_DECL\n \t   && DECL_FUNCTION_TEMPLATE_P (olddecl))\n \t  || (TREE_CODE (olddecl) == FUNCTION_DECL\n \t      && DECL_FUNCTION_TEMPLATE_P (newdecl)))\n-\treturn 0;\n+\treturn NULL_TREE;\n \n       error (\"`%#D' redeclared as different kind of symbol\", newdecl);\n       if (TREE_CODE (olddecl) == TREE_LIST)\n@@ -1319,14 +1319,14 @@ duplicate_decls (tree newdecl, tree olddecl)\n       /* New decl is completely inconsistent with the old one =>\n \t tell caller to replace the old one.  */\n \n-      return 0;\n+      return NULL_TREE;\n     }\n   else if (!types_match)\n     {\n       if (CP_DECL_CONTEXT (newdecl) != CP_DECL_CONTEXT (olddecl))\n \t/* These are certainly not duplicate declarations; they're\n \t   from different scopes.  */\n-\treturn 0;\n+\treturn NULL_TREE;\n \n       if (TREE_CODE (newdecl) == TEMPLATE_DECL)\n \t{\n@@ -1354,7 +1354,7 @@ duplicate_decls (tree newdecl, tree olddecl)\n \t      error (\"new declaration `%#D'\", newdecl);\n \t      cp_error_at (\"ambiguates old declaration `%#D'\", olddecl);\n \t    }\n-\t  return 0;\n+\t  return NULL_TREE;\n \t}\n       if (TREE_CODE (newdecl) == FUNCTION_DECL)\n \t{\n@@ -1371,7 +1371,7 @@ duplicate_decls (tree newdecl, tree olddecl)\n \t      cp_error_at (\"ambiguates old declaration `%#D'\", olddecl);\n \t    }\n \t  else\n-\t    return 0;\n+\t    return NULL_TREE;\n \t}\n \n       /* Already complained about this, so don't do so again.  */\n@@ -1381,7 +1381,7 @@ duplicate_decls (tree newdecl, tree olddecl)\n \t  error (\"conflicting declaration '%#D'\", newdecl);\n \t  cp_error_at (\"'%D' has a previous declaration as `%#D'\",\n                        olddecl, olddecl);\n-          return false;\n+          return NULL_TREE;\n \t}\n     }\n   else if (TREE_CODE (newdecl) == FUNCTION_DECL\n@@ -1401,20 +1401,28 @@ duplicate_decls (tree newdecl, tree olddecl)\n        can occur if we instantiate a template class, and then\n        specialize one of its methods.  This situation is valid, but\n        the declarations must be merged in the usual way.  */\n-    return 0;\n+    return NULL_TREE;\n   else if (TREE_CODE (newdecl) == FUNCTION_DECL\n \t   && ((DECL_TEMPLATE_INSTANTIATION (olddecl)\n \t\t&& !DECL_USE_TEMPLATE (newdecl))\n \t       || (DECL_TEMPLATE_INSTANTIATION (newdecl)\n \t\t   && !DECL_USE_TEMPLATE (olddecl))))\n     /* One of the declarations is a template instantiation, and the\n        other is not a template at all.  That's OK.  */\n-    return 0;\n+    return NULL_TREE;\n   else if (TREE_CODE (newdecl) == NAMESPACE_DECL\n            && DECL_NAMESPACE_ALIAS (newdecl)\n            && DECL_NAMESPACE_ALIAS (newdecl) == DECL_NAMESPACE_ALIAS (olddecl))\n-    /* Redeclaration of namespace alias, ignore it.  */\n-    return 1;\n+    /* In [namespace.alias] we have:\n+\n+\t In a declarative region, a namespace-alias-definition can be\n+\t used to redefine a namespace-alias declared in that declarative\n+\t region to refer only to the namespace to which it already\n+\t refers.  \n+\n+      Therefore, if we encounter a second alias directive for the same\n+      alias, we can just ignore the second directive.  */\n+    return olddecl;\n   else\n     {\n       const char *errmsg = redeclaration_error_message (newdecl, olddecl);\n@@ -1426,7 +1434,7 @@ duplicate_decls (tree newdecl, tree olddecl)\n \t\t\t  && namespace_bindings_p ())\n \t\t\t ? \"`%#D' previously defined here\"\n \t\t\t : \"`%#D' previously declared here\", olddecl);\n-\t  return 0;\n+\t  return error_mark_node;\n \t}\n       else if (TREE_CODE (olddecl) == FUNCTION_DECL\n \t       && DECL_INITIAL (olddecl) != NULL_TREE\n@@ -1506,7 +1514,7 @@ duplicate_decls (tree newdecl, tree olddecl)\n   if (TREE_CODE (olddecl) == TYPE_DECL\n       && (DECL_IMPLICIT_TYPEDEF_P (olddecl)\n \t  || DECL_IMPLICIT_TYPEDEF_P (newdecl)))\n-    return 0;\n+    return NULL_TREE;\n \n   /* If new decl is `static' and an `extern' was seen previously,\n      warn about it.  */\n@@ -1585,7 +1593,7 @@ duplicate_decls (tree newdecl, tree olddecl)\n \t    = DECL_SOURCE_LOCATION (newdecl);\n \t}\n \n-      return 1;\n+      return olddecl;\n     }\n \n   if (types_match)\n@@ -1914,7 +1922,7 @@ duplicate_decls (tree newdecl, tree olddecl)\n \t      && TREE_STATIC (olddecl))))\n     make_decl_rtl (olddecl, NULL);\n \n-  return 1;\n+  return olddecl;\n }\n \f\n /* Generate an implicit declaration for identifier FUNCTIONID\n@@ -10218,7 +10226,19 @@ start_function (tree declspecs, tree declarator, tree attrs, int flags)\n       /* A specialization is not used to guide overload resolution.  */\n       if (!DECL_TEMPLATE_SPECIALIZATION (decl1)\n \t  && ! DECL_FUNCTION_MEMBER_P (decl1))\n-\tdecl1 = pushdecl (decl1);\n+\t{\n+\t  tree olddecl = pushdecl (decl1);\n+\n+\t  if (olddecl == error_mark_node)\n+\t    /* If something went wrong when registering the declaration,\n+\t       use DECL1; we have to have a FUNCTION_DECL to use when\n+\t       parsing the body of the function.  */\n+\t    ;\n+\t  else\n+\t    /* Otherwise, OLDDECL is either a previous declaration of\n+\t       the same function or DECL1 itself.  */\n+\t    decl1 = olddecl;\n+\t}\n       else\n \t{\n \t  /* We need to set the DECL_CONTEXT.  */"}, {"sha": "e9547005bba48da6a2e4207ca9c6df74b595878b", "filename": "gcc/cp/friend.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1a19c7ceab2890e5f54896ed643c0ff86f74d2f/gcc%2Fcp%2Ffriend.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1a19c7ceab2890e5f54896ed643c0ff86f74d2f/gcc%2Fcp%2Ffriend.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ffriend.c?ref=b1a19c7ceab2890e5f54896ed643c0ff86f74d2f", "patch": "@@ -455,6 +455,9 @@ do_friend (tree ctype, tree declarator, tree decl, tree parmdecls,\n \t    }\n \t}\n \n+      if (decl == error_mark_node)\n+\treturn error_mark_node;\n+      \n       add_friend (current_class_type, \n \t\t  is_friend_template ? DECL_TI_TEMPLATE (decl) : decl,\n \t\t  /*complain=*/true);"}, {"sha": "a31aeebbcafe8e686ba448fabfed615d4f44d84c", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 31, "deletions": 26, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1a19c7ceab2890e5f54896ed643c0ff86f74d2f/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1a19c7ceab2890e5f54896ed643c0ff86f74d2f/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=b1a19c7ceab2890e5f54896ed643c0ff86f74d2f", "patch": "@@ -680,33 +680,38 @@ pushdecl (tree x)\n \t      /* Throw away the redeclaration.  */\n \t      POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, t);\n \t    }\n-\t  else if (TREE_CODE (t) != TREE_CODE (x))\n-\t    {\n-\t      if (duplicate_decls (x, t))\n-\t\tPOP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, t);\n-\t    }\n-\t  else if (duplicate_decls (x, t))\n-\t    {\n-\t      if (TREE_CODE (t) == TYPE_DECL)\n-\t\tSET_IDENTIFIER_TYPE_VALUE (name, TREE_TYPE (t));\n-\t      else if (TREE_CODE (t) == FUNCTION_DECL)\n-\t\tcheck_default_args (t);\n-\n-\t      POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, t);\n-\t    }\n-\t  else if (DECL_MAIN_P (x))\n+\t  else\n \t    {\n-\t      /* A redeclaration of main, but not a duplicate of the\n-\t\t previous one.\n-\n-\t\t [basic.start.main]\n+\t      tree olddecl = duplicate_decls (x, t);\n+\t      \n+\t      /* If the redeclaration failed, we can stop at this\n+\t\t point.  */\n+\t      if (olddecl == error_mark_node)\n+\t\tPOP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, error_mark_node);\n+\n+\t      if (olddecl)\n+\t\t{\n+\t\t  if (TREE_CODE (t) == TYPE_DECL)\n+\t\t    SET_IDENTIFIER_TYPE_VALUE (name, TREE_TYPE (t));\n+\t\t  else if (TREE_CODE (t) == FUNCTION_DECL)\n+\t\t    check_default_args (t);\n \n-\t         This function shall not be overloaded.  */\n-\t      cp_error_at (\"invalid redeclaration of `%D'\", t);\n-\t      error (\"as `%D'\", x);\n-\t      /* We don't try to push this declaration since that\n-\t\t causes a crash.  */\n-\t      POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, x);\n+\t\t  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, t);\n+\t\t}\n+\t      else if (DECL_MAIN_P (x))\n+\t\t{\n+\t\t  /* A redeclaration of main, but not a duplicate of the\n+\t\t     previous one.\n+\t\t     \n+\t\t     [basic.start.main]\n+\t\t     \n+\t\t     This function shall not be overloaded.  */\n+\t\t  cp_error_at (\"invalid redeclaration of `%D'\", t);\n+\t\t  error (\"as `%D'\", x);\n+\t\t  /* We don't try to push this declaration since that\n+\t\t     causes a crash.  */\n+\t\t  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, x);\n+\t\t}\n \t    }\n \t}\n \n@@ -1982,7 +1987,7 @@ push_overloaded_decl (tree decl, int flags)\n \t\terror (\"`%#D' conflicts with previous using declaration `%#D'\",\n \t\t\t  decl, fn);\n \n-\t      if (duplicate_decls (decl, fn))\n+\t      if (duplicate_decls (decl, fn) == fn)\n \t\tPOP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, fn);\n \t    }\n \t}"}]}