{"sha": "106c3c10bfe5ed32edfbc3e253b6bf24276344e0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTA2YzNjMTBiZmU1ZWQzMmVkZmJjM2UyNTNiNmJmMjQyNzYzNDRlMA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2010-08-04T23:58:39Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2010-08-04T23:58:39Z"}, "message": "Force the use of stack_pointer_offset in computing the frame size.\n\nBy exporting padding[012] and to_allocate from ix86_compute_frame_layout,\nwe encouraged re-computation of the size of the local frame.  All of the\ntruly relevant offsets are now exported directly, and should be compared\nagainst directly.\n\nFrom-SVN: r162891", "tree": {"sha": "eb7cc072f73c55f1af23829cd414a70b94485c9b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/eb7cc072f73c55f1af23829cd414a70b94485c9b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/106c3c10bfe5ed32edfbc3e253b6bf24276344e0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/106c3c10bfe5ed32edfbc3e253b6bf24276344e0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/106c3c10bfe5ed32edfbc3e253b6bf24276344e0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/106c3c10bfe5ed32edfbc3e253b6bf24276344e0/comments", "author": null, "committer": null, "parents": [{"sha": "87ec2632b86f9ecab4308bbbadb9f791bcd2e8fa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/87ec2632b86f9ecab4308bbbadb9f791bcd2e8fa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/87ec2632b86f9ecab4308bbbadb9f791bcd2e8fa"}], "stats": {"total": 71, "additions": 31, "deletions": 40}, "files": [{"sha": "a954245ccb7d1fff6133ed621f8667247a60ae5b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/106c3c10bfe5ed32edfbc3e253b6bf24276344e0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/106c3c10bfe5ed32edfbc3e253b6bf24276344e0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=106c3c10bfe5ed32edfbc3e253b6bf24276344e0", "patch": "@@ -1,5 +1,15 @@\n 2010-08-04  Richard Henderson  <rth@redhat.com>\n \n+\t* config/i386/i386.c (struct ix86_frame): Remove padding and\n+\tto_allocate members.\n+\t(ix86_compute_frame_layout): Don't store them.\n+\t(ix86_can_use_return_insn_p): Use a more direct and more obviously\n+\tcorrect condition for the position of the stack pointer.\n+\t(ix86_expand_prologue): Compute remaining stack allocation based\n+\ton the ultimate stack pointer offset.\n+\t(ix86_expand_epilogue): Use more obvious expressions testing for\n+\tthe stack pointer already pointing to the saved registers.\n+\n \t* config/i386/i386.c (ix86_expand_epilogue): Eliminate code\n \tduplication deconstructing the frame pointer.  Simplify\n \tdeallocation of the local stack frame."}, {"sha": "d809d443bd1046046f7e110d554b7a371a8e5c25", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 21, "deletions": 40, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/106c3c10bfe5ed32edfbc3e253b6bf24276344e0/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/106c3c10bfe5ed32edfbc3e253b6bf24276344e0/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=106c3c10bfe5ed32edfbc3e253b6bf24276344e0", "patch": "@@ -1846,17 +1846,13 @@ struct GTY(()) stack_local_entry {\n   */\n struct ix86_frame\n {\n-  int padding0;\n   int nsseregs;\n   int nregs;\n-  int padding1;\n   int va_arg_size;\n   int red_zone_size;\n-  HOST_WIDE_INT frame;\n-  int padding2;\n   int outgoing_arguments_size;\n+  HOST_WIDE_INT frame;\n \n-  HOST_WIDE_INT to_allocate;\n   /* The offsets relative to ARG_POINTER.  */\n   HOST_WIDE_INT frame_pointer_offset;\n   HOST_WIDE_INT hard_frame_pointer_offset;\n@@ -7873,15 +7869,14 @@ ix86_can_use_return_insn_p (void)\n   if (! reload_completed || frame_pointer_needed)\n     return 0;\n \n-  /* Don't allow more than 32 pop, since that's all we can do\n+  /* Don't allow more than 32k pop, since that's all we can do\n      with one instruction.  */\n-  if (crtl->args.pops_args\n-      && crtl->args.size >= 32768)\n+  if (crtl->args.pops_args && crtl->args.size >= 32768)\n     return 0;\n \n   ix86_compute_frame_layout (&frame);\n-  return frame.to_allocate == 0 && frame.padding0 == 0\n-         && (frame.nregs + frame.nsseregs) == 0;\n+  return (frame.stack_pointer_offset == UNITS_PER_WORD\n+\t  && (frame.nregs + frame.nsseregs) == 0);\n }\n \f\n /* Value should be nonzero if functions must have frame pointers.\n@@ -8330,6 +8325,7 @@ ix86_compute_frame_layout (struct ix86_frame *frame)\n   HOST_WIDE_INT offset;\n   unsigned int preferred_alignment;\n   HOST_WIDE_INT size = get_frame_size ();\n+  HOST_WIDE_INT to_allocate;\n \n   frame->nregs = ix86_nsaved_regs ();\n   frame->nsseregs = ix86_nsaved_sseregs ();\n@@ -8416,25 +8412,20 @@ ix86_compute_frame_layout (struct ix86_frame *frame)\n   offset += frame->nregs * UNITS_PER_WORD;\n   frame->reg_save_offset = offset;\n \n-  /* Align SSE reg save area.  */\n+  /* Align and set SSE register save area.  */\n   if (frame->nsseregs)\n-    frame->padding0 = ((offset + 16 - 1) & -16) - offset;\n-  else\n-    frame->padding0 = 0;\n-\n-  /* SSE register save area.  */\n-  offset += frame->padding0 + frame->nsseregs * 16;\n+    {\n+      offset = (offset + 16 - 1) & -16;\n+      offset += frame->nsseregs * 16;\n+    }\n   frame->sse_reg_save_offset = offset;\n \n   /* Va-arg area */\n   frame->va_arg_size = ix86_varargs_gpr_size + ix86_varargs_fpr_size;\n   offset += frame->va_arg_size;\n \n   /* Align start of frame for local function.  */\n-  frame->padding1 = ((offset + stack_alignment_needed - 1)\n-\t\t     & -stack_alignment_needed) - offset;\n-\n-  offset += frame->padding1;\n+  offset = (offset + stack_alignment_needed - 1) & -stack_alignment_needed;\n \n   /* Frame pointer points here.  */\n   frame->frame_pointer_offset = offset;\n@@ -8460,39 +8451,31 @@ ix86_compute_frame_layout (struct ix86_frame *frame)\n      or using alloca.  */\n   if (!current_function_is_leaf || cfun->calls_alloca\n       || ix86_current_function_calls_tls_descriptor)\n-    frame->padding2 = ((offset + preferred_alignment - 1)\n-\t\t       & -preferred_alignment) - offset;\n-  else\n-    frame->padding2 = 0;\n-\n-  offset += frame->padding2;\n+    offset = (offset + preferred_alignment - 1) & -preferred_alignment;\n \n   /* We've reached end of stack frame.  */\n   frame->stack_pointer_offset = offset;\n \n   /* Size prologue needs to allocate.  */\n-  frame->to_allocate =\n-    (size + frame->padding1 + frame->padding2\n-     + frame->outgoing_arguments_size + frame->va_arg_size);\n+  to_allocate = offset - frame->sse_reg_save_offset;\n \n-  if ((!frame->to_allocate && frame->nregs <= 1)\n-      || (TARGET_64BIT && frame->to_allocate >= (HOST_WIDE_INT) 0x80000000))\n+  if ((!to_allocate && frame->nregs <= 1)\n+      || (TARGET_64BIT && to_allocate >= (HOST_WIDE_INT) 0x80000000))\n     frame->save_regs_using_mov = false;\n \n   if (ix86_using_red_zone ()\n       && current_function_sp_is_unchanging\n       && current_function_is_leaf\n       && !ix86_current_function_calls_tls_descriptor)\n     {\n-      frame->red_zone_size = frame->to_allocate;\n+      frame->red_zone_size = to_allocate;\n       if (frame->save_regs_using_mov)\n \tframe->red_zone_size += frame->nregs * UNITS_PER_WORD;\n       if (frame->red_zone_size > RED_ZONE_SIZE - RED_ZONE_RESERVE)\n \tframe->red_zone_size = RED_ZONE_SIZE - RED_ZONE_RESERVE;\n     }\n   else\n     frame->red_zone_size = 0;\n-  frame->to_allocate -= frame->red_zone_size;\n   frame->stack_pointer_offset -= frame->red_zone_size;\n }\n \n@@ -9597,16 +9580,13 @@ ix86_expand_prologue (void)\n       m->fs.realigned = true;\n     }\n \n-  allocate = frame.to_allocate + frame.nsseregs * 16 + frame.padding0;\n-\n   if (!frame.save_regs_using_mov)\n     {\n       ix86_emit_save_regs ();\n       int_registers_saved = true;\n       gcc_assert (m->fs.sp_offset == frame.reg_save_offset);\n     }\n-  else\n-    allocate += frame.nregs * UNITS_PER_WORD;\n+  allocate = frame.stack_pointer_offset - m->fs.sp_offset;\n \n   /* The stack has already been decremented by the instruction calling us\n      so we need to probe unconditionally to preserve the protection area.  */\n@@ -9998,11 +9978,12 @@ ix86_expand_epilogue (int style)\n     restore_regs_via_mov = true;\n   else if (TARGET_EPILOGUE_USING_MOVE\n \t   && cfun->machine->use_fast_prologue_epilogue\n-\t   && (frame.nregs > 1 || (frame.to_allocate + frame.padding0) != 0))\n+\t   && (frame.nregs > 1\n+\t       || m->fs.sp_offset != frame.reg_save_offset))\n     restore_regs_via_mov = true;\n   else if (frame_pointer_needed\n \t   && !frame.nregs\n-\t   && (frame.to_allocate + frame.padding0) != 0)\n+\t   && m->fs.sp_offset != frame.reg_save_offset)\n     restore_regs_via_mov = true;\n   else if (frame_pointer_needed\n \t   && TARGET_USE_LEAVE"}]}