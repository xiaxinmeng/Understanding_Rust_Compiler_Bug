{"sha": "fd7215d7119221065b6aeb6ac70e2b75a74a94fb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmQ3MjE1ZDcxMTkyMjEwNjViNmFlYjZhYzcwZTJiNzVhNzRhOTRmYg==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-07-31T13:31:48Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-07-31T13:31:48Z"}, "message": "[multiple changes]\n\n2014-07-31  Robert Dewar  <dewar@adacore.com>\n\n\t* exp_util.adb, lib-writ.adb, sem_ch12.adb, s-direio.adb: Minor\n\treformatting.\n\n2014-07-31  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* exp_attr.adb (Expand_Loop_Entry_Attribute): Update the comment\n\twhich demonstrates the expansion of while loops subject to\n\tattribute 'Loop_Entry. The condition of a while loop along with\n\trelated condition actions is now wrapped in a function.  Instead\n\tof repeating the condition, the expansion now calls the function.\n\n2014-07-31  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_case.adb (Check_Against_Predicate): Correct off-by-one\n\terror when reporting of missing values in a case statement for\n\ta type with a static predicate.\n\t(Check_Choices): Reject a choice given by a subtype to which a\n\tDynamic_Predicate applies.\n\t* sem_ch3.adb (Analyze_Subtype_Declaration): Inherit\n\tHas_Dynamic_Predicate_Aspect flag from parent.\n\n2014-07-31  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch13.adb (Analyze_Aspect_Specifications): A predicate\n\tcannot apply to a subtype of an incomplete type.\n\t(Is_Static_Choice): Treat an Others_Clause as static. The\n\tstaticness of the expression and of the range are checked\n\telsewhere.\n\n2014-07-31  Pascal Obry  <obry@adacore.com>\n\n\t* adaint.h (__gnat_ftell64): Added.\n\t(__gnat_fseek64): Added.\n\t(__int64): Added.\n\t* cstreams.c (__int64): Removed.\n\nFrom-SVN: r213366", "tree": {"sha": "72fb50968b15d55500d2c2168f57e976dedc2b1f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/72fb50968b15d55500d2c2168f57e976dedc2b1f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fd7215d7119221065b6aeb6ac70e2b75a74a94fb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fd7215d7119221065b6aeb6ac70e2b75a74a94fb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fd7215d7119221065b6aeb6ac70e2b75a74a94fb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fd7215d7119221065b6aeb6ac70e2b75a74a94fb/comments", "author": null, "committer": null, "parents": [{"sha": "d1e0e1480b0210a6a5cfff7bc8be2bfea298a95b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d1e0e1480b0210a6a5cfff7bc8be2bfea298a95b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d1e0e1480b0210a6a5cfff7bc8be2bfea298a95b"}], "stats": {"total": 287, "additions": 191, "deletions": 96}, "files": [{"sha": "deed861a34c4e7bbb069f3acc2b4da83f376486b", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd7215d7119221065b6aeb6ac70e2b75a74a94fb/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd7215d7119221065b6aeb6ac70e2b75a74a94fb/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=fd7215d7119221065b6aeb6ac70e2b75a74a94fb", "patch": "@@ -1,3 +1,41 @@\n+2014-07-31  Robert Dewar  <dewar@adacore.com>\n+\n+\t* exp_util.adb, lib-writ.adb, sem_ch12.adb, s-direio.adb: Minor\n+\treformatting.\n+\n+2014-07-31  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* exp_attr.adb (Expand_Loop_Entry_Attribute): Update the comment\n+\twhich demonstrates the expansion of while loops subject to\n+\tattribute 'Loop_Entry. The condition of a while loop along with\n+\trelated condition actions is now wrapped in a function.  Instead\n+\tof repeating the condition, the expansion now calls the function.\n+\n+2014-07-31  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_case.adb (Check_Against_Predicate): Correct off-by-one\n+\terror when reporting of missing values in a case statement for\n+\ta type with a static predicate.\n+\t(Check_Choices): Reject a choice given by a subtype to which a\n+\tDynamic_Predicate applies.\n+\t* sem_ch3.adb (Analyze_Subtype_Declaration): Inherit\n+\tHas_Dynamic_Predicate_Aspect flag from parent.\n+\n+2014-07-31  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch13.adb (Analyze_Aspect_Specifications): A predicate\n+\tcannot apply to a subtype of an incomplete type.\n+\t(Is_Static_Choice): Treat an Others_Clause as static. The\n+\tstaticness of the expression and of the range are checked\n+\telsewhere.\n+\n+2014-07-31  Pascal Obry  <obry@adacore.com>\n+\n+\t* adaint.h (__gnat_ftell64): Added.\n+\t(__gnat_fseek64): Added.\n+\t(__int64): Added.\n+\t* cstreams.c (__int64): Removed.\n+\n 2014-07-31  Pascal Obry  <obry@adacore.com>\n \n \t* a-stream.ads (Stream_Element_Offset): Now a signed 64bit type."}, {"sha": "6db5bab65adef2653a30f0fb98bcc76c505f14f7", "filename": "gcc/ada/adaint.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd7215d7119221065b6aeb6ac70e2b75a74a94fb/gcc%2Fada%2Fadaint.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd7215d7119221065b6aeb6ac70e2b75a74a94fb/gcc%2Fada%2Fadaint.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fadaint.h?ref=fd7215d7119221065b6aeb6ac70e2b75a74a94fb", "patch": "@@ -72,6 +72,8 @@ typedef long long OS_Time;\n typedef long OS_Time;\n #endif\n \n+#define __int64 long long\n+\n /* A lazy cache for the attributes of a file. On some systems, a single call to\n    stat() will give all this information, so it is better than doing a system\n    call every time. On other systems this require several system calls.\n@@ -251,6 +253,10 @@ extern int    __gnat_set_close_on_exec\t\t   (int, int);\n extern int    __gnat_dup\t\t\t   (int);\n extern int    __gnat_dup2\t\t\t   (int, int);\n \n+/* large file support */\n+extern __int64 __gnat_ftell64                      (FILE *);\n+extern int     __gnat_fseek64                      (FILE *, __int64, int);\n+\n extern int    __gnat_number_of_cpus                (void);\n \n extern void   __gnat_os_filename                   (char *, char *, char *,"}, {"sha": "a58d9e5f76e8defa1815f61c7dd17fd352b2f3e0", "filename": "gcc/ada/cstreams.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd7215d7119221065b6aeb6ac70e2b75a74a94fb/gcc%2Fada%2Fcstreams.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd7215d7119221065b6aeb6ac70e2b75a74a94fb/gcc%2Fada%2Fcstreams.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fcstreams.c?ref=fd7215d7119221065b6aeb6ac70e2b75a74a94fb", "patch": "@@ -253,8 +253,6 @@ __gnat_full_name (char *nam, char *buffer)\n   return buffer;\n }\n \n-#define __int64 long long\n-\n #ifdef _WIN32\n   /* On Windows we want to use the fseek/fteel supporting large files. This\n      issue is due to the fact that a long on Win64 is still a 32 bits value */"}, {"sha": "6bc73b7013b1e7e98069941774503a59bfa175aa", "filename": "gcc/ada/exp_attr.adb", "status": "modified", "additions": 71, "deletions": 21, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd7215d7119221065b6aeb6ac70e2b75a74a94fb/gcc%2Fada%2Fexp_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd7215d7119221065b6aeb6ac70e2b75a74a94fb/gcc%2Fada%2Fexp_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_attr.adb?ref=fd7215d7119221065b6aeb6ac70e2b75a74a94fb", "patch": "@@ -1120,15 +1120,21 @@ package body Exp_Attr is\n \n          --  While loops are transformed into:\n \n-         --    if <Condition> then\n+         --    function Fnn return Boolean is\n+         --    begin\n+         --       <condition actions>\n+         --       return <condition>;\n+         --    end Fnn;\n+\n+         --    if Fnn then\n          --       declare\n          --          Temp1 : constant <type of Pref1> := <Pref1>;\n          --          . . .\n          --          TempN : constant <type of PrefN> := <PrefN>;\n          --       begin\n          --          loop\n          --             <original source statements with attribute rewrites>\n-         --             exit when not <Condition>;\n+         --             exit when not Fnn;\n          --          end loop;\n          --       end;\n          --    end if;\n@@ -1138,23 +1144,81 @@ package body Exp_Attr is\n \n          elsif Present (Condition (Scheme)) then\n             declare\n-               Cond : constant Node_Id := Condition (Scheme);\n+               Func_Decl : Node_Id;\n+               Func_Id   : Entity_Id;\n+               Stmts     : List_Id;\n \n             begin\n+               --  Wrap the condition of the while loop in a Boolean function.\n+               --  This avoids the duplication of the same code which may lead\n+               --  to gigi issues with respect to multiple declaration of the\n+               --  same entity in the presence of side effects or checks. Note\n+               --  that the condition actions must also be relocated to the\n+               --  wrapping function.\n+\n+               --  Generate:\n+               --    <condition actions>\n+               --    return <condition>;\n+\n+               if Present (Condition_Actions (Scheme)) then\n+                  Stmts := Condition_Actions (Scheme);\n+               else\n+                  Stmts := New_List;\n+               end if;\n+\n+               Append_To (Stmts,\n+                 Make_Simple_Return_Statement (Loc,\n+                   Expression => Relocate_Node (Condition (Scheme))));\n+\n+               --  Generate:\n+               --    function Fnn return Boolean is\n+               --    begin\n+               --       <Stmts>\n+               --    end Fnn;\n+\n+               Func_Id   := Make_Temporary (Loc, 'F');\n+               Func_Decl :=\n+                 Make_Subprogram_Body (Loc,\n+                   Specification              =>\n+                     Make_Function_Specification (Loc,\n+                       Defining_Unit_Name => Func_Id,\n+                       Result_Definition  =>\n+                         New_Occurrence_Of (Standard_Boolean, Loc)),\n+                   Declarations               => Empty_List,\n+                   Handled_Statement_Sequence =>\n+                     Make_Handled_Sequence_Of_Statements (Loc,\n+                       Statements => Stmts));\n+\n+               --  The function is inserted before the related loop. Make sure\n+               --  to analyze it in the context of the loop's enclosing scope.\n+\n+               Push_Scope (Scope (Loop_Id));\n+               Insert_Action (Loop_Stmt, Func_Decl);\n+               Pop_Scope;\n+\n                --  Transform the original while loop into an infinite loop\n                --  where the last statement checks the negated condition. This\n                --  placement ensures that the condition will not be evaluated\n                --  twice on the first iteration.\n \n+               Set_Iteration_Scheme (Loop_Stmt, Empty);\n+               Scheme := Empty;\n+\n                --  Generate:\n-               --    exit when not <Cond>:\n+               --    exit when not Fnn;\n \n                Append_To (Statements (Loop_Stmt),\n                  Make_Exit_Statement (Loc,\n-                   Condition => Make_Op_Not (Loc, New_Copy_Tree (Cond))));\n+                   Condition =>\n+                     Make_Op_Not (Loc,\n+                       Right_Opnd =>\n+                         Make_Function_Call (Loc,\n+                           Name => New_Occurrence_Of (Func_Id, Loc)))));\n \n                Build_Conditional_Block (Loc,\n-                 Cond      => Relocate_Node (Cond),\n+                 Cond      =>\n+                   Make_Function_Call (Loc,\n+                     Name => New_Occurrence_Of (Func_Id, Loc)),\n                  Loop_Stmt => Relocate_Node (Loop_Stmt),\n                  If_Stmt   => Result,\n                  Blk_Stmt  => Blk);\n@@ -1289,8 +1353,6 @@ package body Exp_Attr is\n \n       --  Step 4: Analyze all bits\n \n-      Rewrite (N, New_Occurrence_Of (Temp_Id, Loc));\n-\n       Installed := Current_Scope = Scope (Loop_Id);\n \n       --  Depending on the pracement of attribute 'Loop_Entry relative to the\n@@ -1305,19 +1367,6 @@ package body Exp_Attr is\n \n       if Present (Result) then\n          Rewrite (Loop_Stmt, Result);\n-\n-         --  The insertion of condition actions associated with an iteration\n-         --  scheme is usually done by the expansion of loop statements. The\n-         --  expansion of Loop_Entry however reuses the iteration scheme to\n-         --  build an if statement. As a result any condition actions must be\n-         --  inserted before the if statement to avoid references before\n-         --  declaration.\n-\n-         if Present (Scheme) and then Present (Condition_Actions (Scheme)) then\n-            Insert_Actions (Loop_Stmt, Condition_Actions (Scheme));\n-            Set_Condition_Actions (Scheme, No_List);\n-         end if;\n-\n          Analyze (Loop_Stmt);\n \n       --  The conditional block was analyzed when a previous 'Loop_Entry was\n@@ -1328,6 +1377,7 @@ package body Exp_Attr is\n          Analyze (Temp_Decl);\n       end if;\n \n+      Rewrite (N, New_Occurrence_Of (Temp_Id, Loc));\n       Analyze (N);\n \n       if not Installed then"}, {"sha": "a91380f7425252a99f14d0c09326ba7a402f5327", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 16, "deletions": 13, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd7215d7119221065b6aeb6ac70e2b75a74a94fb/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd7215d7119221065b6aeb6ac70e2b75a74a94fb/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=fd7215d7119221065b6aeb6ac70e2b75a74a94fb", "patch": "@@ -3325,7 +3325,6 @@ package body Exp_Util is\n    function Has_Annotate_Pragma_For_External_Axiomatization\n      (E : Entity_Id) return Boolean\n    is\n-\n       function Is_Annotate_Pragma_For_External_Axiomatization\n         (N : Node_Id) return Boolean;\n       --  Returns whether N is\n@@ -3352,26 +3351,26 @@ package body Exp_Util is\n       --    pragma Annotate (GNATprove, External_Axiomatization);\n \n       function Is_Annotate_Pragma_For_External_Axiomatization\n-        (N : Node_Id) return Boolean is\n-\n-         -------------------\n-         -- Special Names --\n-         -------------------\n-\n-         Name_GNATprove : constant String := \"gnatprove\";\n+        (N : Node_Id) return Boolean\n+      is\n+         Name_GNATprove               : constant String :=\n+                                          \"gnatprove\";\n          Name_External_Axiomatization : constant String :=\n-           \"external_axiomatization\";\n+                                          \"external_axiomatization\";\n+         --  Special names\n+\n       begin\n          if Nkind (N) = N_Pragma\n            and then Get_Pragma_Id (Pragma_Name (N)) = Pragma_Annotate\n            and then List_Length (Pragma_Argument_Associations (N)) = 2\n          then\n             declare\n                Arg1 : constant Node_Id :=\n-                 First (Pragma_Argument_Associations (N));\n+                        First (Pragma_Argument_Associations (N));\n                Arg2 : constant Node_Id := Next (Arg1);\n                Nam1 : Name_Id;\n                Nam2 : Name_Id;\n+\n             begin\n                --  Fill in Name_Buffer with Name_GNATprove first, and then with\n                --  Name_External_Axiomatization so that Name_Find returns the\n@@ -3386,19 +3385,23 @@ package body Exp_Util is\n                Nam2 := Name_Find;\n \n                return Chars (Get_Pragma_Arg (Arg1)) = Nam1\n-                 and then\n-                   Chars (Get_Pragma_Arg (Arg2)) = Nam2;\n+                         and then\n+                      Chars (Get_Pragma_Arg (Arg2)) = Nam2;\n             end;\n \n          else\n             return False;\n          end if;\n       end Is_Annotate_Pragma_For_External_Axiomatization;\n \n-      Decl : Node_Id;\n+      --  Local variables\n+\n+      Decl      : Node_Id;\n       Vis_Decls : List_Id;\n       N         : Node_Id;\n \n+   --  Start of processing for Has_Annotate_Pragma_For_External_Axiomatization\n+\n    begin\n       if Nkind (Parent (E)) = N_Defining_Program_Unit_Name then\n          Decl := Parent (Parent (E));"}, {"sha": "c92d0aa9d46d97e2892d398a14e9240d5fbf7d88", "filename": "gcc/ada/lib-writ.adb", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd7215d7119221065b6aeb6ac70e2b75a74a94fb/gcc%2Fada%2Flib-writ.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd7215d7119221065b6aeb6ac70e2b75a74a94fb/gcc%2Fada%2Flib-writ.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-writ.adb?ref=fd7215d7119221065b6aeb6ac70e2b75a74a94fb", "patch": "@@ -662,8 +662,7 @@ package body Lib.Writ is\n                --  compilation unit.\n \n             begin\n-               if U /= No_Unit\n-                 and then Nkind (Unit (Cunit (U))) = N_Subunit\n+               if U /= No_Unit and then Nkind (Unit (Cunit (U))) = N_Subunit\n                then\n                   Note_Unit := Main_Unit;\n                else"}, {"sha": "e4ccf364064f086c3366dc5a10586a7968293517", "filename": "gcc/ada/s-direio.adb", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd7215d7119221065b6aeb6ac70e2b75a74a94fb/gcc%2Fada%2Fs-direio.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd7215d7119221065b6aeb6ac70e2b75a74a94fb/gcc%2Fada%2Fs-direio.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-direio.adb?ref=fd7215d7119221065b6aeb6ac70e2b75a74a94fb", "patch": "@@ -282,8 +282,9 @@ package body System.Direct_IO is\n    procedure Set_Position (File : File_Type) is\n       R : int;\n    begin\n-      R := fseek64\n-        (File.Stream, int64 (File.Bytes) * int64 (File.Index - 1), SEEK_SET);\n+      R :=\n+        fseek64\n+          (File.Stream, int64 (File.Bytes) * int64 (File.Index - 1), SEEK_SET);\n \n       if R /= 0 then\n          raise Use_Error;\n@@ -296,6 +297,7 @@ package body System.Direct_IO is\n \n    function Size (File : File_Type) return Count is\n       Pos : int64;\n+\n    begin\n       FIO.Check_File_Open (AP (File));\n       File.Last_Op := Op_Other;"}, {"sha": "e00b567e7ba9c227adf1f10f42483ab4a3d48b44", "filename": "gcc/ada/sem_case.adb", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd7215d7119221065b6aeb6ac70e2b75a74a94fb/gcc%2Fada%2Fsem_case.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd7215d7119221065b6aeb6ac70e2b75a74a94fb/gcc%2Fada%2Fsem_case.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_case.adb?ref=fd7215d7119221065b6aeb6ac70e2b75a74a94fb", "patch": "@@ -433,9 +433,10 @@ package body Sem_Case is\n                   Error := True;\n \n                --  The previous choice covered part of the static predicate set\n+               --  but there is a gap after Prev_Hi.\n \n                else\n-                  Missing_Choice (Prev_Hi, Choice_Lo - 1);\n+                  Missing_Choice (Prev_Hi + 1, Choice_Lo - 1);\n                   Error := True;\n                end if;\n             end if;\n@@ -1462,6 +1463,7 @@ package body Sem_Case is\n \n                            if not Is_Discrete_Type (E)\n                              or else not Has_Static_Predicate (E)\n+                             or else Has_Dynamic_Predicate_Aspect (E)\n                            then\n                               Bad_Predicated_Subtype_Use\n                                 (\"cannot use subtype& with non-static \""}, {"sha": "09621e7a171e9227c18470928403baa0b5216781", "filename": "gcc/ada/sem_ch12.adb", "status": "modified", "additions": 34, "deletions": 46, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd7215d7119221065b6aeb6ac70e2b75a74a94fb/gcc%2Fada%2Fsem_ch12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd7215d7119221065b6aeb6ac70e2b75a74a94fb/gcc%2Fada%2Fsem_ch12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch12.adb?ref=fd7215d7119221065b6aeb6ac70e2b75a74a94fb", "patch": "@@ -1018,17 +1018,17 @@ package body Sem_Ch12 is\n         (Formal : Entity_Id;\n          Actual : Entity_Id := Empty) return Node_Id\n       is\n-         Loc     : constant Source_Ptr := Sloc (I_Node);\n-         Typ     : constant Entity_Id := Etype (Formal);\n+         Loc       : constant Source_Ptr := Sloc (I_Node);\n+         Typ       : constant Entity_Id := Etype (Formal);\n          Is_Binary : constant Boolean :=\n-                        Present (Next_Formal (First_Formal (Formal)));\n+                       Present (Next_Formal (First_Formal (Formal)));\n \n-         Decl   : Node_Id;\n-         Expr   : Node_Id;\n-         F1, F2 : Entity_Id;\n-         Func   : Entity_Id;\n+         Decl    : Node_Id;\n+         Expr    : Node_Id;\n+         F1, F2  : Entity_Id;\n+         Func    : Entity_Id;\n          Op_Name : Name_Id;\n-         Spec   : Node_Id;\n+         Spec    : Node_Id;\n \n          L, R   : Node_Id;\n \n@@ -1050,110 +1050,98 @@ package body Sem_Ch12 is\n          Set_Ekind (Func, E_Function);\n          Set_Is_Generic_Actual_Subprogram (Func);\n \n-         Spec := Make_Function_Specification (Loc,\n-            Defining_Unit_Name => Func,\n-\n-            Parameter_Specifications => New_List (\n-              Make_Parameter_Specification (Loc,\n-                Defining_Identifier => F1,\n-                Parameter_Type => Make_Identifier\n-                  (Loc, Chars (Etype (First_Formal (Formal)))))),\n-\n-            Result_Definition => Make_Identifier (Loc, Chars (Typ)));\n+         Spec :=\n+           Make_Function_Specification (Loc,\n+             Defining_Unit_Name       => Func,\n+             Parameter_Specifications => New_List (\n+               Make_Parameter_Specification (Loc,\n+                  Defining_Identifier => F1,\n+                  Parameter_Type      =>\n+                    Make_Identifier (Loc,\n+                      Chars => Chars (Etype (First_Formal (Formal)))))),\n+             Result_Definition        => Make_Identifier (Loc, Chars (Typ)));\n \n          if Is_Binary then\n             Append_To (Parameter_Specifications (Spec),\n                Make_Parameter_Specification (Loc,\n                  Defining_Identifier => F2,\n-                 Parameter_Type => Make_Identifier (Loc,\n-                   Chars (Etype (Next_Formal (First_Formal (Formal)))))));\n+                 Parameter_Type =>\n+                   Make_Identifier (Loc,\n+                     Chars (Etype (Next_Formal (First_Formal (Formal)))))));\n          end if;\n \n          --  Build expression as a function call, or as an operator node\n          --  that corresponds to the name of the actual, starting with binary\n          --  operators.\n \n          if Present (Actual) and then Op_Name not in Any_Operator_Name then\n-            Expr := Make_Function_Call (Loc,\n-                      Name => New_Occurrence_Of (Entity (Actual), Loc),\n-                      Parameter_Associations => New_List (L));\n+            Expr :=\n+              Make_Function_Call (Loc,\n+                Name                   =>\n+                  New_Occurrence_Of (Entity (Actual), Loc),\n+                Parameter_Associations => New_List (L));\n \n             if Is_Binary then\n                Append_To (Parameter_Associations (Expr), R);\n             end if;\n \n+         --  Binary operators\n+\n          elsif Is_Binary then\n             if Op_Name = Name_Op_And then\n                Expr := Make_Op_And (Loc, Left_Opnd => L, Right_Opnd => R);\n-\n             elsif Op_Name = Name_Op_Or then\n                Expr := Make_Op_Or (Loc, Left_Opnd => L, Right_Opnd => R);\n-\n             elsif Op_Name = Name_Op_Xor then\n                Expr := Make_Op_Xor (Loc, Left_Opnd => L, Right_Opnd => R);\n-\n             elsif Op_Name = Name_Op_Eq then\n                Expr := Make_Op_Eq (Loc, Left_Opnd => L, Right_Opnd => R);\n-\n             elsif Op_Name = Name_Op_Ne then\n                Expr := Make_Op_Ne (Loc, Left_Opnd => L, Right_Opnd => R);\n-\n             elsif Op_Name = Name_Op_Le then\n                Expr := Make_Op_Le (Loc, Left_Opnd => L, Right_Opnd => R);\n-\n             elsif Op_Name = Name_Op_Gt then\n                Expr := Make_Op_Gt (Loc, Left_Opnd => L, Right_Opnd => R);\n-\n             elsif Op_Name = Name_Op_Ge then\n                Expr := Make_Op_Ge (Loc, Left_Opnd => L, Right_Opnd => R);\n-\n             elsif Op_Name = Name_Op_Lt then\n                Expr := Make_Op_Lt (Loc, Left_Opnd => L, Right_Opnd => R);\n-\n             elsif Op_Name = Name_Op_Add then\n                Expr := Make_Op_Add (Loc, Left_Opnd => L, Right_Opnd => R);\n-\n             elsif Op_Name = Name_Op_Subtract then\n                Expr := Make_Op_Subtract (Loc, Left_Opnd => L, Right_Opnd => R);\n-\n             elsif Op_Name = Name_Op_Concat then\n                Expr := Make_Op_Concat (Loc, Left_Opnd => L, Right_Opnd => R);\n-\n             elsif Op_Name = Name_Op_Multiply then\n                Expr := Make_Op_Multiply (Loc, Left_Opnd => L, Right_Opnd => R);\n-\n             elsif Op_Name = Name_Op_Divide then\n                Expr := Make_Op_Divide (Loc, Left_Opnd => L, Right_Opnd => R);\n-\n             elsif Op_Name = Name_Op_Mod then\n                Expr := Make_Op_Mod (Loc, Left_Opnd => L, Right_Opnd => R);\n-\n             elsif Op_Name = Name_Op_Rem then\n                Expr := Make_Op_Rem (Loc, Left_Opnd => L, Right_Opnd => R);\n-\n             elsif Op_Name = Name_Op_Expon then\n                Expr := Make_Op_Expon (Loc, Left_Opnd => L, Right_Opnd => R);\n             end if;\n \n-         else    --  Unary operators.\n+         --  Unary operators\n \n+         else\n             if Op_Name = Name_Op_Add then\n                Expr := Make_Op_Plus (Loc, Right_Opnd => L);\n-\n             elsif Op_Name = Name_Op_Subtract then\n                Expr := Make_Op_Minus (Loc, Right_Opnd => L);\n-\n             elsif Op_Name = Name_Op_Abs then\n                Expr := Make_Op_Abs (Loc, Right_Opnd => L);\n-\n             elsif Op_Name = Name_Op_Not then\n                Expr := Make_Op_Not (Loc, Right_Opnd => L);\n             end if;\n          end if;\n \n-         Decl := Make_Expression_Function (Loc,\n-                    Specification => Spec,\n-                    Expression => Expr);\n+         Decl :=\n+           Make_Expression_Function (Loc,\n+             Specification => Spec,\n+             Expression    => Expr);\n \n          return Decl;\n       end Build_Wrapper;"}, {"sha": "9685d7500f46341bb180caba7eb6e1afa23bcb43", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 16, "deletions": 9, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd7215d7119221065b6aeb6ac70e2b75a74a94fb/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd7215d7119221065b6aeb6ac70e2b75a74a94fb/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=fd7215d7119221065b6aeb6ac70e2b75a74a94fb", "patch": "@@ -1787,6 +1787,11 @@ package body Sem_Ch13 is\n                        (\"predicate can only be specified for a subtype\",\n                         Aspect);\n                      goto Continue;\n+\n+                  elsif Is_Incomplete_Type (E) then\n+                     Error_Msg_N\n+                       (\"predicate cannot apply to incomplete view\", Aspect);\n+                     goto Continue;\n                   end if;\n \n                   --  Construct the pragma (always a pragma Predicate, with\n@@ -3544,8 +3549,9 @@ package body Sem_Ch13 is\n             if Ekind (Current_Scope) = E_Package\n               and then Has_Private_Declaration (Ent)\n               and then From_Aspect_Specification (N)\n-              and then List_Containing (Parent (Ent))\n-                 = Private_Declarations\n+              and then\n+                List_Containing (Parent (Ent)) =\n+                  Private_Declarations\n                     (Specification (Unit_Declaration_Node (Current_Scope)))\n               and then Nkind (N) = N_Attribute_Definition_Clause\n             then\n@@ -3555,8 +3561,8 @@ package body Sem_Ch13 is\n                begin\n                   Decl :=\n                      First (Visible_Declarations\n-                      (Specification\n-                        (Unit_Declaration_Node (Current_Scope))));\n+                              (Specification\n+                                 (Unit_Declaration_Node (Current_Scope))));\n \n                   while Present (Decl) loop\n                      if Nkind (Decl) = N_Private_Type_Declaration\n@@ -3566,7 +3572,7 @@ package body Sem_Ch13 is\n                      then\n                         Illegal_Indexing\n                           (\"Indexing aspect cannot be specified on full view \"\n-                             & \"if partial view is tagged\");\n+                           & \"if partial view is tagged\");\n                         return;\n                      end if;\n \n@@ -3678,9 +3684,7 @@ package body Sem_Ch13 is\n             end;\n          end if;\n \n-         if not Indexing_Found\n-           and then not Error_Posted (N)\n-         then\n+         if not Indexing_Found and then not Error_Posted (N) then\n             Error_Msg_NE\n               (\"aspect Indexing requires a local function that \"\n                & \"applies to type&\", Expr, Ent);\n@@ -10618,6 +10622,8 @@ package body Sem_Ch13 is\n       --  Returns true if all elements of the list are OK static choices\n       --  as defined below for Is_Static_Choice. Used for case expression\n       --  alternatives and for the right operand of a membership test.\n+      --  An others_choice is static if the corresponding expression is static.\n+      --  The staticness of the bounds is checked separately.\n \n       function Is_Static_Choice (N : Node_Id) return Boolean;\n       --  Returns True if N represents a static choice (static subtype, or\n@@ -10683,7 +10689,8 @@ package body Sem_Ch13 is\n \n       function Is_Static_Choice (N : Node_Id) return Boolean is\n       begin\n-         return Is_OK_Static_Expression (N)\n+         return Nkind (N) = N_Others_Choice\n+           or else Is_OK_Static_Expression (N)\n            or else (Is_Entity_Name (N) and then Is_Type (Entity (N))\n                      and then Is_OK_Static_Subtype (Entity (N)))\n            or else (Nkind (N) = N_Subtype_Indication"}, {"sha": "19b323523146fc7b8cce80d7f546662cee60f94f", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd7215d7119221065b6aeb6ac70e2b75a74a94fb/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd7215d7119221065b6aeb6ac70e2b75a74a94fb/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=fd7215d7119221065b6aeb6ac70e2b75a74a94fb", "patch": "@@ -4514,6 +4514,8 @@ package body Sem_Ch3 is\n \n             when Enumeration_Kind =>\n                Set_Ekind                (Id, E_Enumeration_Subtype);\n+               Set_Has_Dynamic_Predicate_Aspect (Id,\n+                                   Has_Dynamic_Predicate_Aspect (T));\n                Set_First_Literal        (Id, First_Literal (Base_Type (T)));\n                Set_Scalar_Range         (Id, Scalar_Range       (T));\n                Set_Is_Character_Type    (Id, Is_Character_Type  (T));"}]}