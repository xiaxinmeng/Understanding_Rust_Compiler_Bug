{"sha": "48df3fa66cf86d6da365a459aae689bb937128a3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDhkZjNmYTY2Y2Y4NmQ2ZGEzNjVhNDU5YWFlNjg5YmI5MzcxMjhhMw==", "commit": {"author": {"name": "Ira Rosen", "email": "ira.rosen@linaro.org", "date": "2011-05-26T07:50:09Z"}, "committer": {"name": "Ira Rosen", "email": "irar@gcc.gnu.org", "date": "2011-05-26T07:50:09Z"}, "message": "re PR tree-optimization/49038 (-ftree-vectorise introduces reads past end of array)\n\n\n        PR tree-optimization/49038\n        * tree-vect-loop-manip.c (vect_generate_tmps_on_preheader):\n        Ensure at least one epilogue iteration if required by data\n        accesses with gaps.\n        * tree-vectorizer.h (struct _loop_vec_info): Add new field \n        to mark loops that require peeling for gaps.\n        * tree-vect-loop.c (new_loop_vec_info): Initialize new field.\n        (vect_get_known_peeling_cost): Take peeling for gaps into \n        account.\n        (vect_transform_loop): Generate epilogue if required by data\n        access with gaps.\n        * tree-vect-data-refs.c (vect_analyze_group_access): Mark the\n        loop as requiring an epilogue if there are gaps in the end of\n        the strided group.\n\nFrom-SVN: r174265", "tree": {"sha": "bb4f5ec4b88af2d477845faf8d6148011a0f8df8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bb4f5ec4b88af2d477845faf8d6148011a0f8df8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/48df3fa66cf86d6da365a459aae689bb937128a3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/48df3fa66cf86d6da365a459aae689bb937128a3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/48df3fa66cf86d6da365a459aae689bb937128a3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/48df3fa66cf86d6da365a459aae689bb937128a3/comments", "author": null, "committer": null, "parents": [{"sha": "688571c7d50ec32bd99ee6acda4afc2d3f8ab247", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/688571c7d50ec32bd99ee6acda4afc2d3f8ab247", "html_url": "https://github.com/Rust-GCC/gccrs/commit/688571c7d50ec32bd99ee6acda4afc2d3f8ab247"}], "stats": {"total": 236, "additions": 232, "deletions": 4}, "files": [{"sha": "3e348cca419ef463a4891f01fda4dc63dda837f7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48df3fa66cf86d6da365a459aae689bb937128a3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48df3fa66cf86d6da365a459aae689bb937128a3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=48df3fa66cf86d6da365a459aae689bb937128a3", "patch": "@@ -1,3 +1,20 @@\n+2011-05-26  Ira Rosen  <ira.rosen@linaro.org>\n+\n+\tPR tree-optimization/49038\n+\t* tree-vect-loop-manip.c (vect_generate_tmps_on_preheader):\n+\tEnsure at least one epilogue iteration if required by data\n+\taccesses with gaps.\n+\t* tree-vectorizer.h (struct _loop_vec_info): Add new field\n+\tto mark loops that require peeling for gaps.\n+\t* tree-vect-loop.c (new_loop_vec_info): Initialize new field.\n+\t(vect_get_known_peeling_cost): Take peeling for gaps into\n+\taccount.\n+\t(vect_transform_loop): Generate epilogue if required by data\n+\taccess with gaps.\n+\t* tree-vect-data-refs.c (vect_analyze_group_access): Mark the\n+\tloop as requiring an epilogue if there are gaps in the end of\n+\tthe strided group.\n+\n 2011-05-25  Ian Lance Taylor  <iant@google.com>\n \n \t* godump.c (go_format_type): Output the first field with a usable"}, {"sha": "44ab3d0bebd0ef45620b74ddb3c95aea1676c7e9", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48df3fa66cf86d6da365a459aae689bb937128a3/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48df3fa66cf86d6da365a459aae689bb937128a3/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=48df3fa66cf86d6da365a459aae689bb937128a3", "patch": "@@ -1,3 +1,9 @@\n+2011-05-26  Ira Rosen  <ira.rosen@linaro.org>\n+\n+\tPR tree-optimization/49038\n+\t* gcc.dg/vect/vect-strided-u8-i8-gap4-unknown.c: New test.\n+\t* gcc.dg/vect/pr49038.c: New test.\n+\n 2011-05-26  Fabien Ch\u00eane  <fabien@gcc.gnu.org>\n \t* g++.dg/init/pr25811-3.C: New.\n \t* g++.dg/init/pr25811-4.C: New."}, {"sha": "ab440a38996eea0369926f92af6c5d49fc4df4f5", "filename": "gcc/testsuite/gcc.dg/vect/pr49038.c", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48df3fa66cf86d6da365a459aae689bb937128a3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr49038.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48df3fa66cf86d6da365a459aae689bb937128a3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr49038.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr49038.c?ref=48df3fa66cf86d6da365a459aae689bb937128a3", "patch": "@@ -0,0 +1,38 @@\n+#include <sys/mman.h>\n+#include <stdio.h>\n+\n+#define COUNT 320\n+#define MMAP_SIZE 0x10000\n+#define ADDRESS 0x1122000000\n+#define TYPE unsigned short\n+\n+void __attribute__((noinline))\n+foo (TYPE *__restrict a, TYPE *__restrict b)\n+{\n+  int n;\n+\n+  for (n = 0; n < COUNT; n++)\n+    a[n] = b[n * 2];\n+}\n+\n+int\n+main (void)\n+{\n+  void *x;\n+  size_t b_offset;\n+\n+  x = mmap ((void *) ADDRESS, MMAP_SIZE, PROT_READ | PROT_WRITE,\n+\t    MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n+  if (x == MAP_FAILED)\n+    {\n+      perror (\"mmap\");\n+      return 1;\n+    }\n+\n+  b_offset = MMAP_SIZE - (2 * COUNT - 1) * sizeof (TYPE);\n+  foo ((unsigned short *) x,\n+       (unsigned short *) ((char *) x + b_offset));\n+  return 0;\n+}\n+\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "a13bc98ba051f3644230c506e25f2bd495085e20", "filename": "gcc/testsuite/gcc.dg/vect/vect-strided-u8-i8-gap4-unknown.c", "status": "added", "additions": 103, "deletions": 0, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48df3fa66cf86d6da365a459aae689bb937128a3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-strided-u8-i8-gap4-unknown.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48df3fa66cf86d6da365a459aae689bb937128a3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-strided-u8-i8-gap4-unknown.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-strided-u8-i8-gap4-unknown.c?ref=48df3fa66cf86d6da365a459aae689bb937128a3", "patch": "@@ -0,0 +1,103 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include <stdio.h>\n+#include \"tree-vect.h\"\n+\n+#define N 160 \n+\n+typedef struct {\n+   unsigned char a;\n+   unsigned char b;\n+   unsigned char c;\n+   unsigned char d;\n+   unsigned char e;\n+   unsigned char f;\n+   unsigned char g;\n+   unsigned char h;\n+} s;\n+\n+__attribute__ ((noinline)) int\n+main1 (s *arr, int n)\n+{\n+  int i;\n+  s *ptr = arr;\n+  s res[N];\n+  unsigned char x;\n+\n+  /* Check peeling for gaps for unknown loop bound.  */\n+  for (i = 0; i < n; i++)\n+    {\n+      res[i].c = ptr->b + ptr->c;\n+      x = ptr->c + ptr->f;\n+      res[i].a = x + ptr->b;\n+      res[i].d = ptr->b + ptr->c;\n+      res[i].b = ptr->c;\n+      res[i].f = ptr->f + ptr->e;\n+      res[i].e = ptr->b + ptr->e; \n+      res[i].h = ptr->c;   \n+      res[i].g = ptr->b + ptr->c;\n+      ptr++; \n+    } \n+   \n+  /* check results:  */\n+  for (i = 0; i < n; i++)\n+    { \n+      if (res[i].c != arr[i].b + arr[i].c\n+          || res[i].a != arr[i].c + arr[i].f + arr[i].b\n+          || res[i].d != arr[i].b + arr[i].c\n+          || res[i].b != arr[i].c\n+          || res[i].f != arr[i].f + arr[i].e\n+          || res[i].e != arr[i].b + arr[i].e\n+          || res[i].h != arr[i].c\n+          || res[i].g != arr[i].b + arr[i].c)\n+        abort ();\n+   }\n+\n+  /* Check also that we don't do more iterations than needed.  */\n+  for (i = n; i < N; i++)\n+    {\n+      if (res[i].c == arr[i].b + arr[i].c\n+          || res[i].a == arr[i].c + arr[i].f + arr[i].b\n+          || res[i].d == arr[i].b + arr[i].c\n+          || res[i].b == arr[i].c\n+          || res[i].f == arr[i].f + arr[i].e\n+          || res[i].e == arr[i].b + arr[i].e\n+          || res[i].h == arr[i].c\n+          || res[i].g == arr[i].b + arr[i].c)\n+        abort ();\n+   }\n+\n+  return 0;\n+}\n+\n+\n+int main (void)\n+{\n+  int i;\n+  s arr[N];\n+  \n+  check_vect ();\n+\n+  for (i = 0; i < N; i++)\n+    { \n+      arr[i].a = 5;\n+      arr[i].b = 6;\n+      arr[i].c = 17;\n+      arr[i].d = 3;\n+      arr[i].e = 16;\n+      arr[i].f = 16;\n+      arr[i].g = 3;\n+      arr[i].h = 56;\n+      if (arr[i].a == 178)\n+         abort(); \n+    } \n+\n+  main1 (arr, N-2);\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { target vect_strided8 } } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+  "}, {"sha": "ee059977559f17b4a0c36d4921048ecd76923bcc", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48df3fa66cf86d6da365a459aae689bb937128a3/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48df3fa66cf86d6da365a459aae689bb937128a3/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=48df3fa66cf86d6da365a459aae689bb937128a3", "patch": "@@ -2043,7 +2043,7 @@ vect_analyze_group_access (struct data_reference *dr)\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n   bb_vec_info bb_vinfo = STMT_VINFO_BB_VINFO (stmt_info);\n   HOST_WIDE_INT dr_step = TREE_INT_CST_LOW (step);\n-  HOST_WIDE_INT stride;\n+  HOST_WIDE_INT stride, last_accessed_element = 1;\n   bool slp_impossible = false;\n \n   /* For interleaving, STRIDE is STEP counted in elements, i.e., the size of the\n@@ -2072,6 +2072,16 @@ vect_analyze_group_access (struct data_reference *dr)\n \t      fprintf (vect_dump, \" step \");\n \t      print_generic_expr (vect_dump, step, TDF_SLIM);\n \t    }\n+\n+\t  if (loop_vinfo)\n+\t    {\n+\t      LOOP_VINFO_PEELING_FOR_GAPS (loop_vinfo) = true;\n+\n+\t      if (vect_print_dump_info (REPORT_DETAILS))\n+\t\tfprintf (vect_dump, \"Data access with gaps requires scalar \"\n+\t\t\t\t    \"epilogue loop\");\n+\t    }\n+\n \t  return true;\n \t}\n \n@@ -2137,6 +2147,7 @@ vect_analyze_group_access (struct data_reference *dr)\n               next = GROUP_NEXT_ELEMENT (vinfo_for_stmt (next));\n               continue;\n             }\n+\n           prev = next;\n \n           /* Check that all the accesses have the same STEP.  */\n@@ -2167,6 +2178,8 @@ vect_analyze_group_access (struct data_reference *dr)\n               gaps += diff - 1;\n \t    }\n \n+\t  last_accessed_element += diff;\n+\n           /* Store the gap from the previous member of the group. If there is no\n              gap in the access, GROUP_GAP is always 1.  */\n           GROUP_GAP (vinfo_for_stmt (next)) = diff;\n@@ -2245,6 +2258,15 @@ vect_analyze_group_access (struct data_reference *dr)\n             VEC_safe_push (gimple, heap, BB_VINFO_STRIDED_STORES (bb_vinfo),\n                            stmt);\n         }\n+\n+      /* There is a gap in the end of the group.  */\n+      if (stride - last_accessed_element > 0 && loop_vinfo)\n+\t{\n+\t  LOOP_VINFO_PEELING_FOR_GAPS (loop_vinfo) = true;\n+\t  if (vect_print_dump_info (REPORT_DETAILS))\n+\t    fprintf (vect_dump, \"Data access with gaps requires scalar \"\n+\t\t\t\t\"epilogue loop\");\n+\t}\n     }\n \n   return true;"}, {"sha": "89b45745364c9b226ae08d7c39a3da86a6884715", "filename": "gcc/tree-vect-loop-manip.c", "status": "modified", "additions": 32, "deletions": 2, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48df3fa66cf86d6da365a459aae689bb937128a3/gcc%2Ftree-vect-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48df3fa66cf86d6da365a459aae689bb937128a3/gcc%2Ftree-vect-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop-manip.c?ref=48df3fa66cf86d6da365a459aae689bb937128a3", "patch": "@@ -1551,7 +1551,7 @@ vect_generate_tmps_on_preheader (loop_vec_info loop_vinfo,\n   edge pe;\n   basic_block new_bb;\n   gimple_seq stmts;\n-  tree ni_name;\n+  tree ni_name, ni_minus_gap_name;\n   tree var;\n   tree ratio_name;\n   tree ratio_mult_vf_name;\n@@ -1568,9 +1568,39 @@ vect_generate_tmps_on_preheader (loop_vec_info loop_vinfo,\n   ni_name = vect_build_loop_niters (loop_vinfo, cond_expr_stmt_list);\n   log_vf = build_int_cst (TREE_TYPE (ni), exact_log2 (vf));\n \n+  /* If epilogue loop is required because of data accesses with gaps, we\n+     subtract one iteration from the total number of iterations here for\n+     correct calculation of RATIO.  */\n+  if (LOOP_VINFO_PEELING_FOR_GAPS (loop_vinfo))\n+    {\n+      ni_minus_gap_name = fold_build2 (MINUS_EXPR, TREE_TYPE (ni_name),\n+\t\t\t\t       ni_name,\n+\t\t\t               build_one_cst (TREE_TYPE (ni_name)));\n+      if (!is_gimple_val (ni_minus_gap_name))\n+\t{\n+\t  var = create_tmp_var (TREE_TYPE (ni), \"ni_gap\");\n+          add_referenced_var (var);\n+\n+          stmts = NULL;\n+          ni_minus_gap_name = force_gimple_operand (ni_minus_gap_name, &stmts,\n+\t\t\t\t\t\t    true, var);\n+          if (cond_expr_stmt_list)\n+            gimple_seq_add_seq (&cond_expr_stmt_list, stmts);\n+          else\n+            {\n+              pe = loop_preheader_edge (loop);\n+              new_bb = gsi_insert_seq_on_edge_immediate (pe, stmts);\n+              gcc_assert (!new_bb);\n+            }\n+        }\n+    }\n+  else\n+    ni_minus_gap_name = ni_name;\n+\n   /* Create: ratio = ni >> log2(vf) */\n \n-  ratio_name = fold_build2 (RSHIFT_EXPR, TREE_TYPE (ni_name), ni_name, log_vf);\n+  ratio_name = fold_build2 (RSHIFT_EXPR, TREE_TYPE (ni_minus_gap_name),\n+\t\t\t    ni_minus_gap_name, log_vf);\n   if (!is_gimple_val (ratio_name))\n     {\n       var = create_tmp_var (TREE_TYPE (ni), \"bnd\");"}, {"sha": "666bd9b0fa7b8d675bca47af93cadf223f893063", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48df3fa66cf86d6da365a459aae689bb937128a3/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48df3fa66cf86d6da365a459aae689bb937128a3/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=48df3fa66cf86d6da365a459aae689bb937128a3", "patch": "@@ -761,6 +761,7 @@ new_loop_vec_info (struct loop *loop)\n   LOOP_VINFO_SLP_INSTANCES (res) = VEC_alloc (slp_instance, heap, 10);\n   LOOP_VINFO_SLP_UNROLLING_FACTOR (res) = 1;\n   LOOP_VINFO_PEELING_HTAB (res) = NULL;\n+  LOOP_VINFO_PEELING_FOR_GAPS (res) = false;\n \n   return res;\n }\n@@ -2333,6 +2334,10 @@ vect_get_known_peeling_cost (loop_vec_info loop_vinfo, int peel_iters_prologue,\n       peel_iters_prologue = niters < peel_iters_prologue ?\n                             niters : peel_iters_prologue;\n       *peel_iters_epilogue = (niters - peel_iters_prologue) % vf;\n+      /* If we need to peel for gaps, but no peeling is required, we have to\n+\t peel VF iterations.  */\n+      if (LOOP_VINFO_PEELING_FOR_GAPS (loop_vinfo) && !*peel_iters_epilogue)\n+        *peel_iters_epilogue = vf;\n     }\n \n    return (peel_iters_prologue * scalar_single_iter_cost)\n@@ -4987,7 +4992,8 @@ vect_transform_loop (loop_vec_info loop_vinfo)\n   do_peeling_for_loop_bound\n     = (!LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo)\n        || (LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo)\n-\t   && LOOP_VINFO_INT_NITERS (loop_vinfo) % vectorization_factor != 0));\n+\t   && LOOP_VINFO_INT_NITERS (loop_vinfo) % vectorization_factor != 0)\n+       || LOOP_VINFO_PEELING_FOR_GAPS (loop_vinfo));\n \n   if (LOOP_REQUIRES_VERSIONING_FOR_ALIGNMENT (loop_vinfo)\n       || LOOP_REQUIRES_VERSIONING_FOR_ALIAS (loop_vinfo))"}, {"sha": "3a0a65e931724467f6109d30f79c48b7e25b99c7", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48df3fa66cf86d6da365a459aae689bb937128a3/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48df3fa66cf86d6da365a459aae689bb937128a3/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=48df3fa66cf86d6da365a459aae689bb937128a3", "patch": "@@ -255,6 +255,11 @@ typedef struct _loop_vec_info {\n   /* Hash table used to choose the best peeling option.  */\n   htab_t peeling_htab;\n \n+  /* When we have strided data accesses with gaps, we may introduce invalid\n+     memory accesses.  We peel the last iteration of the loop to prevent\n+     this.  */\n+  bool peeling_for_gaps;\n+\n } *loop_vec_info;\n \n /* Access Functions.  */\n@@ -283,6 +288,7 @@ typedef struct _loop_vec_info {\n #define LOOP_VINFO_REDUCTIONS(L)           (L)->reductions\n #define LOOP_VINFO_REDUCTION_CHAINS(L)     (L)->reduction_chains\n #define LOOP_VINFO_PEELING_HTAB(L)         (L)->peeling_htab\n+#define LOOP_VINFO_PEELING_FOR_GAPS(L)     (L)->peeling_for_gaps\n \n #define LOOP_REQUIRES_VERSIONING_FOR_ALIGNMENT(L) \\\n VEC_length (gimple, (L)->may_misalign_stmts) > 0"}]}