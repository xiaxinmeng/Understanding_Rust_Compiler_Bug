{"sha": "e4bb1bd60a9fd1bed36092a990aa5fed5d45bfa6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTRiYjFiZDYwYTlmZDFiZWQzNjA5MmE5OTBhYTVmZWQ1ZDQ1YmZhNg==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2021-03-29T20:13:32Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2021-03-31T23:16:48Z"}, "message": "analyzer: avoid printing '<unknown>' for SSA names [PR99771]\n\nWe don't want to print '<unknown>' in our diagnostics, but\nPR analyzer/99771 lists various cases where -fanalyzer does, due to\nusing the SSA_NAME for a temporary when determining the best tree to\nuse.\n\nThis can happen in two ways:\n\n(a) ...when a better expression than the SSA_NAME could be built, but\nfinding it requires traversing the relationships in the region_model\nin a graph-like way, rather than by considering individual svalues and\nregions.\n\n(b) ...when the only remaining user of the underlying svalue is the\nSSA_NAME, typically due to the diagnostic referring to a temporary.\n\nI've been experimenting with fixing (a), but don't have a good fix yet.\nIn the meantime, this patch addresses (b) by detecting if we have\nthe SSA_NAME for a temporary, and, for the cases where it's possible,\nreconstructing a tree by walking the def-stmts.  This fixes various\ncases of (b) and ameliorates some cases of (a).\n\ngcc/analyzer/ChangeLog:\n\tPR analyzer/99771\n\t* analyzer.cc (maybe_reconstruct_from_def_stmt): New.\n\t(fixup_tree_for_diagnostic_1): New.\n\t(fixup_tree_for_diagnostic): New.\n\t* analyzer.h (fixup_tree_for_diagnostic): New decl.\n\t* checker-path.cc (call_event::get_desc): Call\n\tfixup_tree_for_diagnostic and use it for the call_with_state call.\n\t(warning_event::get_desc): Likewise for the final_event and\n\tmake_label_text calls.\n\t* engine.cc (impl_region_model_context::on_state_leak): Likewise\n\tfor the on_leak and add_diagnostic calls.\n\t* region-model.cc (region_model::get_representative_tree):\n\tLikewise for the result.\n\ngcc/testsuite/ChangeLog:\n\tPR analyzer/99771\n\t* gcc.dg/analyzer/data-model-10.c: Update expected output.\n\t* gcc.dg/analyzer/malloc-ipa-13.c: Likewise.\n\t* gcc.dg/analyzer/malloc-ipa-13a.c: New test.\n\t* gcc.dg/analyzer/pr99771-1.c: New test.", "tree": {"sha": "aa5dbd79a180cc2509761705283b40f5a10c2b41", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/aa5dbd79a180cc2509761705283b40f5a10c2b41"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e4bb1bd60a9fd1bed36092a990aa5fed5d45bfa6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e4bb1bd60a9fd1bed36092a990aa5fed5d45bfa6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e4bb1bd60a9fd1bed36092a990aa5fed5d45bfa6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e4bb1bd60a9fd1bed36092a990aa5fed5d45bfa6/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e7fd3b783238d034018443e43a58ff87908b4db6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e7fd3b783238d034018443e43a58ff87908b4db6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e7fd3b783238d034018443e43a58ff87908b4db6"}], "stats": {"total": 255, "additions": 244, "deletions": 11}, "files": [{"sha": "2b4cffd08f5209eedb3ac95df9fb0a537df10be0", "filename": "gcc/analyzer/analyzer.cc", "status": "modified", "additions": 128, "deletions": 0, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4bb1bd60a9fd1bed36092a990aa5fed5d45bfa6/gcc%2Fanalyzer%2Fanalyzer.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4bb1bd60a9fd1bed36092a990aa5fed5d45bfa6/gcc%2Fanalyzer%2Fanalyzer.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fanalyzer.cc?ref=e4bb1bd60a9fd1bed36092a990aa5fed5d45bfa6", "patch": "@@ -60,6 +60,134 @@ get_stmt_location (const gimple *stmt, function *fun)\n   return stmt->location;\n }\n \n+static tree\n+fixup_tree_for_diagnostic_1 (tree expr, hash_set<tree> *visited);\n+\n+/*  Subroutine of fixup_tree_for_diagnostic_1, called on SSA names.\n+    Attempt to reconstruct a a tree expression for SSA_NAME\n+    based on its def-stmt.\n+    SSA_NAME must be non-NULL.\n+    VISITED must be non-NULL; it is used to ensure termination.\n+\n+    Return NULL_TREE if there is a problem.  */\n+\n+static tree\n+maybe_reconstruct_from_def_stmt (tree ssa_name,\n+\t\t\t\t hash_set<tree> *visited)\n+{\n+  /* Ensure termination.  */\n+  if (visited->contains (ssa_name))\n+    return NULL_TREE;\n+  visited->add (ssa_name);\n+\n+  gimple *def_stmt = SSA_NAME_DEF_STMT (ssa_name);\n+\n+  switch (gimple_code (def_stmt))\n+    {\n+    default:\n+      gcc_unreachable ();\n+    case GIMPLE_NOP:\n+    case GIMPLE_PHI:\n+      /* Can't handle these.  */\n+      return NULL_TREE;\n+    case GIMPLE_ASSIGN:\n+      {\n+\tenum tree_code code = gimple_assign_rhs_code (def_stmt);\n+\n+\t/* Reverse the effect of extract_ops_from_tree during\n+\t   gimplification.  */\n+\tswitch (get_gimple_rhs_class (code))\n+\t  {\n+\t  default:\n+\t  case GIMPLE_INVALID_RHS:\n+\t    gcc_unreachable ();\n+\t  case GIMPLE_TERNARY_RHS:\n+\t  case GIMPLE_BINARY_RHS:\n+\t  case GIMPLE_UNARY_RHS:\n+\t    {\n+\t      tree t = make_node (code);\n+\t      TREE_TYPE (t) = TREE_TYPE (ssa_name);\n+\t      unsigned num_rhs_args = gimple_num_ops (def_stmt) - 1;\n+\t      for (unsigned i = 0; i < num_rhs_args; i++)\n+\t\t{\n+\t\t  tree op = gimple_op (def_stmt, i + 1);\n+\t\t  if (op)\n+\t\t    {\n+\t\t      op = fixup_tree_for_diagnostic_1 (op, visited);\n+\t\t      if (op == NULL_TREE)\n+\t\t\treturn NULL_TREE;\n+\t\t    }\n+\t\t  TREE_OPERAND (t, i) = op;\n+\t\t}\n+\t      return t;\n+\t    }\n+\t  case GIMPLE_SINGLE_RHS:\n+\t    {\n+\t      tree op = gimple_op (def_stmt, 1);\n+\t      op = fixup_tree_for_diagnostic_1 (op, visited);\n+\t      return op;\n+\t    }\n+\t  }\n+      }\n+      break;\n+    case GIMPLE_CALL:\n+      {\n+\tgcall *call_stmt = as_a <gcall *> (def_stmt);\n+\ttree return_type = gimple_call_return_type (call_stmt);\n+\ttree fn = fixup_tree_for_diagnostic_1 (gimple_call_fn (call_stmt),\n+\t\t\t\t\t       visited);\n+\tunsigned num_args = gimple_call_num_args (call_stmt);\n+\tauto_vec<tree> args (num_args);\n+\tfor (unsigned i = 0; i < num_args; i++)\n+\t  {\n+\t    tree arg = gimple_call_arg (call_stmt, i);\n+\t    arg = fixup_tree_for_diagnostic_1 (arg, visited);\n+\t    if (arg == NULL_TREE)\n+\t      return NULL_TREE;\n+\t    args.quick_push (arg);\n+\t  }\n+\treturn build_call_array_loc (gimple_location (call_stmt),\n+\t\t\t\t     return_type, fn,\n+\t\t\t\t     num_args, &args[0]);\n+      }\n+      break;\n+    }\n+}\n+\n+/* Subroutine of fixup_tree_for_diagnostic: attempt to fixup EXPR,\n+   which can be NULL.\n+   VISITED must be non-NULL; it is used to ensure termination.  */\n+\n+static tree\n+fixup_tree_for_diagnostic_1 (tree expr, hash_set<tree> *visited)\n+{\n+  if (expr\n+      && TREE_CODE (expr) == SSA_NAME\n+      && (SSA_NAME_VAR (expr) == NULL_TREE\n+\t  || DECL_ARTIFICIAL (SSA_NAME_VAR (expr))))\n+    if (tree expr2 = maybe_reconstruct_from_def_stmt (expr, visited))\n+      return expr2;\n+  return expr;\n+}\n+\n+/* We don't want to print '<unknown>' in our diagnostics (PR analyzer/99771),\n+   but sometimes we generate diagnostics involving an ssa name for a\n+   temporary.\n+\n+   Work around this by attempting to reconstruct a tree expression for\n+   such temporaries based on their def-stmts.\n+\n+   Otherwise return EXPR.\n+\n+   EXPR can be NULL.  */\n+\n+tree\n+fixup_tree_for_diagnostic (tree expr)\n+{\n+  hash_set<tree> visited;\n+  return fixup_tree_for_diagnostic_1 (expr, &visited);\n+}\n+\n } // namespace ana\n \n /* Helper function for checkers.  Is the CALL to the given function name,"}, {"sha": "fb568e44d38d1e7890f6849ff97896fb821045a2", "filename": "gcc/analyzer/analyzer.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4bb1bd60a9fd1bed36092a990aa5fed5d45bfa6/gcc%2Fanalyzer%2Fanalyzer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4bb1bd60a9fd1bed36092a990aa5fed5d45bfa6/gcc%2Fanalyzer%2Fanalyzer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fanalyzer.h?ref=e4bb1bd60a9fd1bed36092a990aa5fed5d45bfa6", "patch": "@@ -108,6 +108,7 @@ extern void dump_quoted_tree (pretty_printer *pp, tree t);\n extern void print_quoted_type (pretty_printer *pp, tree t);\n extern int readability_comparator (const void *p1, const void *p2);\n extern int tree_cmp (const void *p1, const void *p2);\n+extern tree fixup_tree_for_diagnostic (tree);\n \n /* A tree, extended with stack frame information for locals, so that\n    we can distinguish between different values of locals within a potentially"}, {"sha": "7d229bbf823d6759a24a9bd03d691ffb96473181", "filename": "gcc/analyzer/checker-path.cc", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4bb1bd60a9fd1bed36092a990aa5fed5d45bfa6/gcc%2Fanalyzer%2Fchecker-path.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4bb1bd60a9fd1bed36092a990aa5fed5d45bfa6/gcc%2Fanalyzer%2Fchecker-path.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fchecker-path.cc?ref=e4bb1bd60a9fd1bed36092a990aa5fed5d45bfa6", "patch": "@@ -634,12 +634,13 @@ call_event::get_desc (bool can_colorize) const\n   if (m_critical_state && m_pending_diagnostic)\n     {\n       gcc_assert (m_var);\n+      tree var = fixup_tree_for_diagnostic (m_var);\n       label_text custom_desc\n \t= m_pending_diagnostic->describe_call_with_state\n \t    (evdesc::call_with_state (can_colorize,\n \t\t\t\t      m_sedge->m_src->m_fun->decl,\n \t\t\t\t      m_sedge->m_dest->m_fun->decl,\n-\t\t\t\t      m_var,\n+\t\t\t\t      var,\n \t\t\t\t      m_critical_state));\n       if (custom_desc.m_buffer)\n \treturn custom_desc;\n@@ -880,19 +881,20 @@ warning_event::get_desc (bool can_colorize) const\n {\n   if (m_pending_diagnostic)\n     {\n+      tree var = fixup_tree_for_diagnostic (m_var);\n       label_text ev_desc\n \t= m_pending_diagnostic->describe_final_event\n-\t    (evdesc::final_event (can_colorize, m_var, m_state));\n+\t    (evdesc::final_event (can_colorize, var, m_state));\n       if (ev_desc.m_buffer)\n \t{\n \t  if (m_sm && flag_analyzer_verbose_state_changes)\n \t    {\n \t      label_text result;\n-\t      if (m_var)\n+\t      if (var)\n \t\tresult = make_label_text (can_colorize,\n \t\t\t\t\t  \"%s (%qE is in state %qs)\",\n \t\t\t\t\t  ev_desc.m_buffer,\n-\t\t\t\t\t  m_var, m_state->get_name ());\n+\t\t\t\t\t  var, m_state->get_name ());\n \t      else\n \t\tresult = make_label_text (can_colorize,\n \t\t\t\t\t  \"%s (in global state %qs)\","}, {"sha": "1fb96de608262205ab2e968804cb50fad8a9d7ab", "filename": "gcc/analyzer/engine.cc", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4bb1bd60a9fd1bed36092a990aa5fed5d45bfa6/gcc%2Fanalyzer%2Fengine.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4bb1bd60a9fd1bed36092a990aa5fed5d45bfa6/gcc%2Fanalyzer%2Fengine.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fengine.cc?ref=e4bb1bd60a9fd1bed36092a990aa5fed5d45bfa6", "patch": "@@ -634,12 +634,13 @@ impl_region_model_context::on_state_leak (const state_machine &sm,\n \t}\n     }\n \n-  pending_diagnostic *pd = sm.on_leak (leaked_tree);\n+  tree leaked_tree_for_diag = fixup_tree_for_diagnostic (leaked_tree);\n+  pending_diagnostic *pd = sm.on_leak (leaked_tree_for_diag);\n   if (pd)\n     m_eg->get_diagnostic_manager ().add_diagnostic\n       (&sm, m_enode_for_diag, m_enode_for_diag->get_supernode (),\n        m_stmt, &stmt_finder,\n-       leaked_tree, sval, state, pd);\n+       leaked_tree_for_diag, sval, state, pd);\n }\n \n /* Implementation of region_model_context::on_condition vfunc."}, {"sha": "c245bfe05125c36b109cc63d60d04813c03294a8", "filename": "gcc/analyzer/region-model.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4bb1bd60a9fd1bed36092a990aa5fed5d45bfa6/gcc%2Fanalyzer%2Fregion-model.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4bb1bd60a9fd1bed36092a990aa5fed5d45bfa6/gcc%2Fanalyzer%2Fregion-model.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model.cc?ref=e4bb1bd60a9fd1bed36092a990aa5fed5d45bfa6", "patch": "@@ -2325,9 +2325,9 @@ region_model::get_representative_tree (const svalue *sval) const\n \n   /* Strip off any top-level cast.  */\n   if (expr && TREE_CODE (expr) == NOP_EXPR)\n-    return TREE_OPERAND (expr, 0);\n+    expr = TREE_OPERAND (expr, 0);\n \n-  return expr;\n+  return fixup_tree_for_diagnostic (expr);\n }\n \n /* Implementation of region_model::get_representative_path_var."}, {"sha": "04c9891d89bd38ed3f3f36af788c031e25006297", "filename": "gcc/testsuite/gcc.dg/analyzer/data-model-10.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4bb1bd60a9fd1bed36092a990aa5fed5d45bfa6/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fdata-model-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4bb1bd60a9fd1bed36092a990aa5fed5d45bfa6/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fdata-model-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fdata-model-10.c?ref=e4bb1bd60a9fd1bed36092a990aa5fed5d45bfa6", "patch": "@@ -12,6 +12,7 @@ test (void)\n   if (!new_table)\n     return NULL;\n   new_table->m_f = (char **)malloc(sizeof(char **));\n-  *new_table->m_f = NULL; /* { dg-warning \"dereference of possibly-NULL '<unknown>'\" } */ // FIXME: something better than \"unknown\" here\n+  *new_table->m_f = NULL; /* { dg-warning \"dereference of possibly-NULL '\\\\*new_table.m_f'\" } */\n+  /* { dg-message \"'\\\\*new_table.m_f' could be NULL\" \"final event wording\" { target *-*-* } .-1 } */\n   return new_table;\n }"}, {"sha": "a08386a46266cdc1e737cffc720f17a2e7f74b6f", "filename": "gcc/testsuite/gcc.dg/analyzer/malloc-ipa-13.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4bb1bd60a9fd1bed36092a990aa5fed5d45bfa6/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-ipa-13.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4bb1bd60a9fd1bed36092a990aa5fed5d45bfa6/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-ipa-13.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-ipa-13.c?ref=e4bb1bd60a9fd1bed36092a990aa5fed5d45bfa6", "patch": "@@ -23,8 +23,7 @@ void test (struct foo f)\n \n   do_stuff ();\n \n-  calls_free (f.m_p); /* { dg-message \"passing freed pointer '<unknown>' in call to 'calls_free' from 'test'\" } */\n-  // TODO: something better than '<unknown>'\n+  calls_free (f.m_p); /* { dg-message \"passing freed pointer 'f\\\\.m_p' in call to 'calls_free' from 'test'\" } */\n \n   do_stuff ();\n }"}, {"sha": "d74ef59c7cf35f7a9a93d9d663dc5b09f9d69000", "filename": "gcc/testsuite/gcc.dg/analyzer/malloc-ipa-13a.c", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4bb1bd60a9fd1bed36092a990aa5fed5d45bfa6/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-ipa-13a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4bb1bd60a9fd1bed36092a990aa5fed5d45bfa6/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-ipa-13a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fmalloc-ipa-13a.c?ref=e4bb1bd60a9fd1bed36092a990aa5fed5d45bfa6", "patch": "@@ -0,0 +1,38 @@\n+/* { dg-additional-options \"-fanalyzer-verbosity=1\" } */\n+\n+#include <stdlib.h>\n+\n+void\n+calls_free (void *victim)\n+{\n+  free (victim); /* { dg-warning \"double-'free' of 'victim'\" } */\n+}\n+\n+extern void do_stuff (void);\n+\n+struct foo\n+{\n+  void *m_p;\n+};\n+\n+static void *  __attribute__((noinline))\n+test_a (struct foo f)\n+{\n+  do_stuff ();\n+\n+  calls_free (f.m_p);\n+\n+  do_stuff ();\n+\n+  return f.m_p;\n+}\n+\n+void test_b (void *p)\n+{\n+  void *q;\n+  struct foo f;\n+  f.m_p = p;\n+  q = test_a (f);\n+  calls_free (q); /* { dg-message \"passing freed pointer 'q' in call to 'calls_free' from 'test_b'\" } */\n+  do_stuff ();\n+}"}, {"sha": "08449f9249eb471b8bf7777221998dc85b0217f1", "filename": "gcc/testsuite/gcc.dg/analyzer/pr99771-1.c", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4bb1bd60a9fd1bed36092a990aa5fed5d45bfa6/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr99771-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4bb1bd60a9fd1bed36092a990aa5fed5d45bfa6/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr99771-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr99771-1.c?ref=e4bb1bd60a9fd1bed36092a990aa5fed5d45bfa6", "patch": "@@ -0,0 +1,63 @@\n+/* Verify that we don't print \"<unknown>\" in various diagnostics\n+   (PR analyzer/99771). */\n+\n+#include <stdlib.h>\n+\n+void test_1 (void)\n+{\n+  *(char*)malloc (1024) = 42; /* { dg-warning \"dereference of possibly-NULL 'malloc\\\\(1024\\\\)'\" } */\n+} /* { dg-warning \"leak of 'malloc\\\\(1024\\\\)'\" \"warning\" } */\n+  /* { dg-message \"'malloc\\\\(1024\\\\)' leaks here\" \"final event\" { target *-*-* } .-1 } */\n+\n+void test_2 (size_t n)\n+{\n+  *(char*)malloc (4 * n) = 42; /* { dg-warning \"dereference of possibly-NULL 'malloc\\\\(n \\\\* 4\\\\)'\" \"warning\" } */\n+  /* { dg-message \"'malloc\\\\(n \\\\* 4\\\\)' could be NULL\" \"final event\" { target *-*-* } .-1 } */\n+} /* { dg-warning \"leak of 'malloc\\\\(n \\\\* 4\\\\)'\" \"warning\" } */\n+  /* { dg-message \"'malloc\\\\(n \\\\* 4\\\\)' leaks here\" \"final event\" { target *-*-* } .-1 } */\n+\n+/* A compound example.  */\n+\n+void test_3 (size_t a, size_t b, size_t c)\n+{\n+  *(char*)malloc (a + (b * c)) = 42; /* { dg-warning \"dereference of possibly-NULL 'malloc\\\\(a \\\\+ b \\\\* c\\\\)'\" \"warning\" } */\n+  /* { dg-message \"'malloc\\\\(a \\\\+ b \\\\* c\\\\)' could be NULL\" \"final event\" { target *-*-* } .-1 } */\n+} /* { dg-warning \"leak of 'malloc\\\\(a \\\\+ b \\\\* c\\\\)'\" \"warning\" } */\n+  /* { dg-message \"'malloc\\\\(a \\\\+ b \\\\* c\\\\)' leaks here\" \"final event\" { target *-*-* } .-1 } */\n+\n+void test_4 (size_t a, size_t b, size_t c)\n+{\n+  *(char *)malloc (a ? b : c) = 42; /* { dg-warning \"dereference of possibly-NULL 'malloc\\\\(<unknown>\\\\)'\" \"warning\" } */\n+  /* { dg-message \"'malloc\\\\(<unknown>\\\\)' could be NULL\" \"final event\" { target *-*-* } .-1 } */\n+} /* { dg-warning \"leak of 'malloc\\\\(<unknown>\\\\)'\" \"warning\" } */\n+  /* { dg-message \"'malloc\\\\(<unknown>\\\\)' leaks here\" \"final event\" { target *-*-* } .-1 } */\n+\n+/* Unary operators.  */\n+\n+void test_5 (size_t a)\n+{\n+  *(char*)malloc (-a) = 42; /* { dg-warning \"dereference of possibly-NULL 'malloc\\\\(-a\\\\)'\" } */\n+} /* { dg-warning \"leak of 'malloc\\\\(-a\\\\)'\" \"warning\" } */\n+  /* { dg-message \"'malloc\\\\(-a\\\\)' leaks here\" \"final event\" { target *-*-* } .-1 } */\n+\n+void test_6 (size_t a)\n+{\n+  *(char*)malloc (~a) = 42; /* { dg-warning \"dereference of possibly-NULL 'malloc\\\\(~a\\\\)'\" } */\n+} /* { dg-warning \"leak of 'malloc\\\\(~a\\\\)'\" \"warning\" } */\n+  /* { dg-message \"'malloc\\\\(~a\\\\)' leaks here\" \"final event\" { target *-*-* } .-1 } */\n+\n+/* Field access.  */\n+\n+struct s7 { size_t sz; };\n+\n+void test_7a(struct s7 s)\n+{\n+  *(char*)malloc (s.sz) = 42; /* { dg-warning \"dereference of possibly-NULL 'malloc\\\\(s\\\\.sz\\\\)'\" } */\n+} /* { dg-warning \"leak of 'malloc\\\\(s\\\\.sz\\\\)'\" \"warning\" } */\n+  /* { dg-message \"'malloc\\\\(s\\\\.sz\\\\)' leaks here\" \"final event\" { target *-*-* } .-1 } */\n+\n+void test_7b (struct s7 *s)\n+{\n+  *(char*)malloc (s->sz) = 42; /* { dg-warning \"dereference of possibly-NULL 'malloc\\\\(\\\\*s\\\\.sz\\\\)'\" } */\n+} /* { dg-warning \"leak of 'malloc\\\\(\\\\*s\\\\.sz\\\\)'\" \"warning\" } */\n+  /* { dg-message \"'malloc\\\\(\\\\*s\\\\.sz\\\\)' leaks here\" \"final event\" { target *-*-* } .-1 } */"}]}