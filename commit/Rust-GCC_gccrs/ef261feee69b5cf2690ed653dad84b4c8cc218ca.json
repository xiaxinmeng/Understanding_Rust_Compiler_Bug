{"sha": "ef261feee69b5cf2690ed653dad84b4c8cc218ca", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWYyNjFmZWVlNjliNWNmMjY5MGVkNjUzZGFkODRiNGM4Y2MyMThjYQ==", "commit": {"author": {"name": "J\"orn Rennecke", "email": "joern.rennecke@superh.com", "date": "2002-08-27T18:12:24Z"}, "committer": {"name": "Joern Rennecke", "email": "amylaar@gcc.gnu.org", "date": "2002-08-27T18:12:24Z"}, "message": "Aldy Hernandez <aldyh at redhat dot com>\n\nTue Aug 27 18:30:47 2002  J\"orn Rennecke <joern.rennecke@superh.com>\n\t\t\t  Aldy Hernandez <aldyh at redhat dot com>\n\n\t* doc/tm.texi: Applied numerous fixes to the automaton based\n\tscheduler descrition.\n\nCo-Authored-By: Aldy Hernandez <aldyh@redhat.com>\n\nFrom-SVN: r56610", "tree": {"sha": "e1e3f7a3fe159d8d7f6d8597c018e48d7631ba80", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e1e3f7a3fe159d8d7f6d8597c018e48d7631ba80"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ef261feee69b5cf2690ed653dad84b4c8cc218ca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef261feee69b5cf2690ed653dad84b4c8cc218ca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ef261feee69b5cf2690ed653dad84b4c8cc218ca", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef261feee69b5cf2690ed653dad84b4c8cc218ca/comments", "author": null, "committer": null, "parents": [{"sha": "c60ee6f503e41f54ced5925dbe39cbf1f33602fb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c60ee6f503e41f54ced5925dbe39cbf1f33602fb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c60ee6f503e41f54ced5925dbe39cbf1f33602fb"}], "stats": {"total": 97, "additions": 52, "deletions": 45}, "files": [{"sha": "83d64bb4af2a7ac72fea312eff99818585916248", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef261feee69b5cf2690ed653dad84b4c8cc218ca/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef261feee69b5cf2690ed653dad84b4c8cc218ca/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ef261feee69b5cf2690ed653dad84b4c8cc218ca", "patch": "@@ -1,3 +1,9 @@\n+Tue Aug 27 18:30:47 2002  J\"orn Rennecke <joern.rennecke@superh.com>\n+\t\t\t  Aldy Hernandez <aldyh at redhat dot com>\n+\n+\t* doc/tm.texi: Applied numerous fixes to the automaton based\n+\tscheduler descrition.\n+\n Tue Aug 27 19:51:05 CEST 2002  Jan Hubicka  <jh@suse.cz>\n \n \t* i386.c (classify_argument): Handle variable sized objects."}, {"sha": "8eb38ce80fcb02431d300ec78d6fe467d84ff64e", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 46, "deletions": 45, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef261feee69b5cf2690ed653dad84b4c8cc218ca/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef261feee69b5cf2690ed653dad84b4c8cc218ca/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=ef261feee69b5cf2690ed653dad84b4c8cc218ca", "patch": "@@ -5246,12 +5246,12 @@ branch is true, we might represent this as follows:\n @cindex RISC\n @cindex VLIW\n \n-To achieve better productivity most modern processors\n+To achieve better performance, most modern processors\n (super-pipelined, superscalar @acronym{RISC}, and @acronym{VLIW}\n processors) have many @dfn{functional units} on which several\n instructions can be executed simultaneously.  An instruction starts\n execution if its issue conditions are satisfied.  If not, the\n-instruction is interlocked until its conditions are satisfied.  Such\n+instruction is stalled until its conditions are satisfied.  Such\n @dfn{interlock (pipeline) delay} causes interruption of the fetching\n of successor instructions (or demands nop instructions, e.g. for some\n MIPS processors).\n@@ -5274,25 +5274,25 @@ of delay into account is complex especially for modern @acronym{RISC}\n processors.\n \n The task of exploiting more processor parallelism is solved by an\n-instruction scheduler.  For better solution of this problem, the\n+instruction scheduler.  For a better solution to this problem, the\n instruction scheduler has to have an adequate description of the\n-processor parallelism (or @dfn{pipeline description}).  Currently GCC\n-has two ways to describe processor parallelism.  The first one is old\n-and originated from instruction scheduler written by Michael Tiemann\n-and described in the first subsequent section.  The second one was\n-created later.  It is based on description of functional unit\n-reservations by processor instructions with the aid of @dfn{regular\n-expressions}.  This is so called @dfn{automaton based description}.\n-\n-Gcc instruction scheduler uses a @dfn{pipeline hazard recognizer} to\n+processor parallelism (or @dfn{pipeline description}).  Currently GCC \n+provides two alternative ways to describe processor parallelism,\n+both described below.  The first method is outlined in the next section;\n+it was once the only method provided by GCC, and thus is used in a number\n+of exiting ports.  The second, and preferred method, specifies functional\n+unit reservations for groups of instructions with the aid of @dfn{regular\n+expressions}.  This is called the @dfn{automaton based description}.\t\n+\n+The GCC instruction scheduler uses a @dfn{pipeline hazard recognizer} to\n figure out the possibility of the instruction issue by the processor\n-on given simulated processor cycle.  The pipeline hazard recognizer is\n-a code generated from the processor pipeline description.  The\n+on a given simulated processor cycle.  The pipeline hazard recognizer is\n+automatically generated from the processor pipeline description.  The\n pipeline hazard recognizer generated from the automaton based\n-description is more sophisticated and based on deterministic finite\n+description is more sophisticated and based on a deterministic finite\n state automaton (@acronym{DFA}) and therefore faster than one\n-generated from the old description.  Also its speed is not depended on\n-processor complexity.  The instruction issue is possible if there is\n+generated from the old description.  Furthermore, its speed is not dependent\n+on processor complexity.  The instruction issue is possible if there is\n a transition from one automaton state to another one.\n \n You can use any model to describe processor pipeline characteristics\n@@ -5450,7 +5450,7 @@ in the machine description file is not important.\n The following optional construction describes names of automata\n generated and used for the pipeline hazards recognition.  Sometimes\n the generated finite state automaton used by the pipeline hazard\n-recognizer is large.  If we use more one automaton and bind functional\n+recognizer is large.  If we use more than one automaton and bind functional\n units to the automata, the summary size of the automata usually is\n less than the size of the single automaton.  If there is no one such\n construction, only one finite state automaton is generated.\n@@ -5477,7 +5477,7 @@ reservations should be described by the following construction.\n separated by commas.  Don't use name @samp{nothing}, it is reserved\n for other goals.\n \n-@var{automaton-name} is a string giving the name of automaton with\n+@var{automaton-name} is a string giving the name of the automaton with\n which the unit is bound.  The automaton should be described in\n construction @code{define_automaton}.  You should give\n @dfn{automaton-name}, if there is a defined automaton.\n@@ -5500,14 +5500,14 @@ templates).\n @var{unit-names} is a string giving names of the functional units\n separated by commas.\n \n-@var{automaton-name} is a string giving name of the automaton with\n+@var{automaton-name} is a string giving the name of the automaton with\n which the unit is bound.\n \n @findex define_insn_reservation\n @cindex instruction latency time\n @cindex regular expressions\n @cindex data bypass\n-The following construction is major one to describe pipeline\n+The following construction is the major one to describe pipeline\n characteristics of an instruction.\n \n @smallexample\n@@ -5519,18 +5519,18 @@ characteristics of an instruction.\n instruction.  There is an important difference between the old\n description and the automaton based pipeline description.  The latency\n time is used for all dependencies when we use the old description.  In\n-the automaton based pipeline description, given latency time is used\n-only for true dependencies.  The cost of anti-dependencies is always\n+the automaton based pipeline description, the given latency time is only\n+used for true dependencies.  The cost of anti-dependencies is always\n zero and the cost of output dependencies is the difference between\n latency times of the producing and consuming insns (if the difference\n-is negative, the cost is considered to be zero).  You always can\n-change the default costs for any description by using target hook\n+is negative, the cost is considered to be zero).  You can always\n+change the default costs for any description by using the target hook\n @code{TARGET_SCHED_ADJUST_COST} (@pxref{Scheduling}).\n \n-@var{insn-names} is a string giving internal name of the insn.  The\n+@var{insn-names} is a string giving the internal name of the insn.  The\n internal names are used in constructions @code{define_bypass} and in\n the automaton description file generated for debugging.  The internal\n-name has nothing common with the names in @code{define_insn}.  It is a\n+name has nothing in common with the names in @code{define_insn}.  It is a\n good practice to use insn classes described in the processor manual.\n \n @var{condition} defines what RTL insns are described by this\n@@ -5545,7 +5545,7 @@ contain @code{symbol_ref}).  It is also not checked during the\n pipeline hazard recognizer work because it would slow down the\n recognizer considerably.\n \n-@var{regexp} is a string describing reservation of the cpu functional\n+@var{regexp} is a string describing the reservation of the cpu's functional\n units by the instruction.  The reservations are described by a regular\n expression according to the following syntax:\n \n@@ -5631,11 +5631,11 @@ given in string @var{out_insn_names} will be ready for the\n instructions given in string @var{in_insn_names}.  The instructions in\n the string are separated by commas.\n \n-@var{guard} is an optional string giving name of a C function which\n+@var{guard} is an optional string giving the name of a C function which\n defines an additional guard for the bypass.  The function will get the\n two insns as parameters.  If the function returns zero the bypass will\n be ignored for this case.  The additional guard is necessary to\n-recognize complicated bypasses, e.g. when consumer is only an address\n+recognize complicated bypasses, e.g. when the consumer is only an address\n of insn @samp{store} (not a stored value).\n \n @findex exclusion_set\n@@ -5680,7 +5680,7 @@ it is symmetric).  For example, it is useful for description that\n @acronym{VLIW} @samp{slot0} can not be reserved after @samp{slot1} or\n @samp{slot2} reservation.\n \n-All functional units mentioned in a set should belong the same\n+All functional units mentioned in a set should belong to the same\n automaton.\n \n @findex automata_option\n@@ -5734,7 +5734,7 @@ the following functional units.\n \n @smallexample\n (define_cpu_unit \"i0_pipeline, i1_pipeline, f_pipeline\")\n-(define_cpu_unit \"port_0, port1\")\n+(define_cpu_unit \"port0, port1\")\n @end smallexample\n \n All simple integer insns can be executed in any integer pipeline and\n@@ -5746,26 +5746,26 @@ pipeline and their results are ready correspondingly in 8 and 4\n cycles.  The integer division is not pipelined, i.e. the subsequent\n integer division insn can not be issued until the current division\n insn finished.  Floating point insns are fully pipelined and their\n-results are ready in 3 cycles.  There is also additional one cycle\n-delay in the usage by integer insns of result produced by floating\n-point insns.  To describe all of this we could specify\n+results are ready in 3 cycles.  Where the result of a floating point\n+insn is used by an integer insn, an additional delay of one cycle is\n+incurred.  To describe all of this we could specify\n \n @smallexample\n (define_cpu_unit \"div\")\n \n (define_insn_reservation \"simple\" 2 (eq_attr \"cpu\" \"int\")\n-                         \"(i0_pipeline | i1_pipeline), (port_0 | port1)\")\n+                         \"(i0_pipeline | i1_pipeline), (port0 | port1)\")\n \n (define_insn_reservation \"mult\" 4 (eq_attr \"cpu\" \"mult\")\n-                         \"i1_pipeline, nothing*2, (port_0 | port1)\")\n+                         \"i1_pipeline, nothing*2, (port0 | port1)\")\n \n (define_insn_reservation \"div\" 8 (eq_attr \"cpu\" \"div\")\n-                         \"i1_pipeline, div*7, div + (port_0 | port1)\")\n+                         \"i1_pipeline, div*7, div + (port0 | port1)\")\n \n (define_insn_reservation \"float\" 3 (eq_attr \"cpu\" \"float\")\n-                         \"f_pipeline, nothing, (port_0 | port1))\n+                         \"f_pipeline, nothing, (port0 | port1))\n \n-(define_bypass 4 \"float\" \"simple,mut,div\")\n+(define_bypass 4 \"float\" \"simple,mult,div\")\n @end smallexample\n \n To simplify the description we could describe the following reservation\n@@ -5821,17 +5821,18 @@ The interface to the pipeline hazard recognizer is more complex than\n one to the automaton based pipeline recognizer.\n \n @item\n-An unnatural description when you write an unit and a condition which\n+An unnatural description when you write a unit and a condition which\n selects instructions using the unit.  Writing all unit reservations\n for an instruction (an instruction class) is more natural.\n \n @item\n-The recognition of the interlock delays has slow implementation.  GCC\n+The recognition of the interlock delays has a slow implementation.  The GCC\n scheduler supports structures which describe the unit reservations.\n-The more processor has functional units, the slower pipeline hazard\n-recognizer.  Such implementation would become slower when we enable to\n+The more functional units a processor has, the slower its pipeline hazard\n+recognizer will be.  Such an implementation would become even slower when we\n+allowed to\n reserve functional units not only at the instruction execution start.\n-The automaton based pipeline hazard recognizer speed is not depended\n+In an automaton based pipeline hazard recognizer, speed is not dependent\n on processor complexity.\n @end itemize\n "}]}