{"sha": "bcc3c3f1ca89628f02802fda20f2232b9deef5f9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmNjM2MzZjFjYTg5NjI4ZjAyODAyZmRhMjBmMjIzMmI5ZGVlZjVmOQ==", "commit": {"author": {"name": "Jose E. Marchesi", "email": "jose.marchesi@oracle.com", "date": "2017-07-07T13:59:30Z"}, "committer": {"name": "Jose E. Marchesi", "email": "jemarch@gcc.gnu.org", "date": "2017-07-07T13:59:30Z"}, "message": "Support for the SPARC M8 cpu.\n\nThis patch serie adds support for the SPARC M8 processor to GCC.\nThe SPARC M8 processor implements the Oracle SPARC Architecture 2017.\n\n- bmask* instructions are put in their own instruction type.  It makes\n  little sense to have them in the same category than array\n  instructions.\n\n- Similarly, VIS compare instructions are put in their own instruction\n  type.  This is to better accommodate subtypes, which are not quite\n  the same than the subtypes of `visl' instructions.\n\n- The introduction of a new `subtype' insn attribute in sparc.md\n  avoids the need for adjusting the instruction scheduler DFAs for\n  previous cpu models every time a new cpu is introduced.\n\n- The full set of SPARC instructions used in sparc.md, and their\n  position in the type/subtype hierarchy, is documented in a comment.\n  This eases the modification of the DFA schedulers, and the addition\n  of new cpus.\n\n- The M7 DFA scheduler is reworked:\n\n  + To use the new type/subtype hierarchy.\n  + The v3pipe insn attribute is no longer needed.\n  + More accurate latencies for instructions.\n  + The C4 core pipeline is documented in a comment in niagara7.md.\n\n- Support for -mcpu=m8 (we are thus suggesting to abandon the niagaraN\n  denomination for M8 and later processors.)\n\n- Support for a new VIS level, VIS4B, covering the new VIS\n  instructions introduced in OSA2017 and implemented in the M8.  Also\n  built-ins.\n\n- A M8 DFA scheduler:\n\n  + Also based on the new type/subtype hierarchy.\n  + The functional units in the C5 core are explicitly documented in a\n    comment in m8.md.\n\ngcc/ChangeLog:\n\n\t* config/sparc/m8.md: New file.\n\t* config/sparc/sparc.md: Include m8.md.\n\n\t* config/sparc/sparc.opt: New option -mvis4b.\n\t* config/sparc/sparc.c (dump_target_flag_bits): Handle MASK_VIS4B.\n\t(sparc_option_override): Handle VIS4B.\n\t(enum sparc_builtins): Define\n\tSPARC_BUILTIN_DICTUNPACK{8,16,32},\n\tSPARC_BUILTIN_FPCMP{LE,GT,EQ,NE}{8,16,32}SHL,\n\tSPARC_BUILTIN_FPCMPU{LE,GT}{8,16,32}SHL,\n\tSPARC_BUILTIN_FPCMPDE{8,16,32}SHL and\n\tSPARC_BUILTIN_FPCMPUR{8,16,32}SHL.\n\t(check_constant_argument): New function.\n\t(sparc_vis_init_builtins): Define builtins\n\t__builtin_vis_dictunpack{8,16,32},\n\t__builtin_vis_fpcmp{le,gt,eq,ne}{8,16,32}shl,\n\t__builtin_vis_fpcmpu{le,gt}{8,16,32}shl,\n\t__builtin_vis_fpcmpde{8,16,32}shl and\n\t__builtin_vis_fpcmpur{8,16,32}shl.\n\t(sparc_expand_builtin): Check that the constant operands to\n\t__builtin_vis_fpcmp*shl and _builtin_vis_dictunpack* are indeed\n\tconstant and in range.\n\t* config/sparc/sparc-c.c (sparc_target_macros): Handle\n\tTARGET_VIS4B.\n\t* config/sparc/sparc.h (SPARC_IMM2_P): Define.\n\t(SPARC_IMM5_P): Likewise.\n\t* config/sparc/sparc.md (cpu_feature): Add new feagure \"vis4b\".\n\t(enabled): Handle vis4b.\n\t(UNSPEC_DICTUNPACK): New unspec.\n\t(UNSPEC_FPCMPSHL): Likewise.\n\t(UNSPEC_FPUCMPSHL): Likewise.\n\t(UNSPEC_FPCMPDESHL): Likewise.\n\t(UNSPEC_FPCMPURSHL): Likewise.\n\t(cpu_feature): New CPU feature `vis4b'.\n\t(dictunpack{8,16,32}): New insns.\n\t(FPCSMODE): New mode iterator.\n\t(fpcscond): New code iterator.\n\t(fpcsucond): Likewise.\n\t(fpcmp{le,gt,eq,ne}{8,16,32}{si,di}shl): New insns.\n\t(fpcmpu{le,gt}{8,16,32}{si,di}shl): Likewise.\n\t(fpcmpde{8,16,32}{si,di}shl): Likewise.\n\t(fpcmpur{8,16,32}{si,di}shl): Likewise.\n\t* config/sparc/constraints.md: Define constraints `q' for unsigned\n\t2-bit integer constants and `t' for unsigned 5-bit integer\n\tconstants.\n\t* config/sparc/predicates.md (imm5_operand_dictunpack8): New\n\tpredicate.\n\t(imm5_operand_dictunpack16): Likewise.\n\t(imm5_operand_dictunpack32): Likewise.\n\t(imm2_operand): Likewise.\n\t* doc/invoke.texi (SPARC Options): Document -mvis4b.\n\t* doc/extend.texi (SPARC VIS Built-in Functions): Document the\n\tditunpack* and fpcmp*shl builtins.\n\n\t* config.gcc: Handle m8 in --with-{cpu,tune} options.\n\t* config.in: Add HAVE_AS_SPARC6 define.\n\t* config/sparc/driver-sparc.c (cpu_names): Add entry for the SPARC\n\tM8.\n\t* config/sparc/sol2.h (CPP_CPU64_DEFAULT_SPEC): Define for\n\tTARGET_CPU_m8.\n\t(ASM_CPU32_DEFAUILT_SPEC): Likewise.\n\t(CPP_CPU_SPEC): Handle m8.\n\t(ASM_CPU_SPEC): Likewise.\n\t* config/sparc/sparc-opts.h (enum processor_type): Add\n\tPROCESSOR_M8.\n\t* config/sparc/sparc.c (m8_costs): New struct.\n\t(sparc_option_override): Handle TARGET_CPU_m8.\n\t(sparc32_initialize_trampoline): Likewise.\n\t(sparc64_initialize_trampoline): Likewise.\n\t(sparc_issue_rate): Likewise.\n\t(sparc_register_move_cost): Likewise.\n\t* config/sparc/sparc.h (TARGET_CPU_m8): Define.\n\t(CPP_CPU64_DEFAULT_SPEC): Define for M8.\n\t(ASM_CPU64_DEFAULT_SPEC): Likewise.\n\t(CPP_CPU_SPEC): Handle M8.\n\t(ASM_CPU_SPEC): Likewise.\n\t(AS_M8_FLAG): Define.\n\t* config/sparc/sparc.md: Add m8 to the cpu attribute.\n\t* config/sparc/sparc.opt: New option -mcpu=m8 for sparc targets.\n\t* configure.ac (HAVE_AS_SPARC6): Check for assembler support for\n\tM8 instructions.\n\t* configure: Regenerate.\n\t* doc/invoke.texi (SPARC Options): Document -mcpu=m8 and\n\t-mtune=m8.\n\n\t* config/sparc/niagara7.md: Rework the DFA scheduler to use insn\n\tsubtypes.\n\t* config/sparc/sparc.md: Remove the `v3pipe' insn attribute.\n\t(\"*movdi_insn_sp32\"): Do not set v3pipe.\n\t(\"*movsi_insn\"): Likewise.\n\t(\"*movdi_insn_sp64\"): Likewise.\n\t(\"*movsf_insn\"): Likewise.\n\t(\"*movdf_insn_sp32\"): Likewise.\n\t(\"*movdf_insn_sp64\"): Likewise.\n\t(\"*zero_extendsidi2_insn_sp64\"): Likewise.\n\t(\"*sign_extendsidi2_insn\"): Likewise.\n\t(\"*mov<VM32:mode>_insn\"): Likewise.\n\t(\"*mov<VM64:mode>_insn_sp64\"): Likewise.\n\t(\"*mov<VM64:mode>_insn_sp32\"): Likewise.\n\t(\"<plusminus_insn><VADDSUB:mode>3\"): Likewise.\n\t(\"<vlop:code><VL:mode>3\"): Likewise.\n\t(\"*not_<vlop:code><VL:mode>3\"): Likewise.\n\t(\"*nand<VL:mode>_vis\"): Likewise.\n\t(\"*<vlnotop:code>_not1<VL:mode>_vis\"): Likewise.\n\t(\"*<vlnotop:code>_not2<VL:mode>_vis\"): Likewise.\n\t(\"one_cmpl<VL:mode>2\"): Likewise.\n\t(\"faligndata<VM64:mode>_vis\"): Likewise.\n\t(\"alignaddrsi_vis\"): Likewise.\n\t(\"alignaddrdi_vis\"): Likweise.\n\t(\"alignaddrlsi_vis\"): Likewise.\n\t(\"alignaddrldi_vis\"): Likewise.\n\t(\"fcmp<gcond:code><GCM:gcm_name><P:mode>_vis\"): Likewise.\n\t(\"bmaskdi_vis\"): Likewise.\n\t(\"bmasksi_vis\"): Likewise.\n\t(\"bshuffle<VM64:mode>_vis\"): Likewise.\n\t(\"cmask8<P:mode>_vis\"): Likewise.\n\t(\"cmask16<P:mode>_vis\"): Likewise.\n\t(\"cmask32<P:mode>_vis\"): Likewise.\n\t(\"pdistn<P:mode>_vis\"): Likewise.\n\t(\"<vis3_addsub_ss_patname><VASS:mode>3\"): Likewise.\n\n\t* config/sparc/sparc.md (\"subtype\"): New insn attribute.\n\t(\"*wrgsr_sp64\"): Set insn subtype.\n\t(\"*rdgsr_sp64\"): Likewise.\n\t(\"alignaddrsi_vis\"): Likewise.\n\t(\"alignaddrdi_vis\"): Likewise.\n\t(\"alignaddrlsi_vis\"): Likewise.\n\t(\"alignaddrldi_vis\"): Likewise.\n\t(\"<plusminus_insn><VADDSUB:mode>3\"): Likewise.\n\t(\"fexpand_vis\"): Likewise.\n\t(\"fpmerge_vis\"): Likewise.\n\t(\"faligndata<VM64:mode>_vis\"): Likewise.\n\t(\"bshuffle<VM64:mode>_vis\"): Likewise.\n\t(\"cmask8<P:mode>_vis\"): Likewise.\n\t(\"cmask16<P:mode>_vis\"): Likewise.\n\t(\"cmask32<P:mode>_vis\"): Likewise.\n\t(\"fchksm16_vis\"): Likewise.\n\t(\"v<vis3_shift_patname><GCM:mode>3\"): Likewise.\n\t(\"fmean16_vis\"): Likewise.\n\t(\"fp<plusminus_insn>64_vis\"): Likewise.\n\t(\"<plusminus_insn>v8qi3\"): Likewise.\n\t(\"<vis3_addsub_ss_patname><VASS:mode>3\"): Likewise.\n\t(\"<vis4_minmax_patname><VMMAX:mode>3\"): Likewise.\n\t(\"<vis4_uminmax_patname><VMMAX:mode>3\"): Likewise.\n\t(\"<vis3_addsub_ss_patname>v8qi3\"): Likewise.\n\t(\"<vis4_addsub_us_patname><VAUS:mode>3\"): Likewise.\n\t(\"*movqi_insn\"): Likewise.\n\t(\"*movhi_insn\"): Likewise.\n\t(\"*movsi_insn\"): Likewise.\n\t(\"movsi_pic_gotdata_op\"): Likewise.\n\t(\"*movdi_insn_sp32\"): Likewise.\n\t(\"*movdi_insn_sp64\"): Likewise.\n\t(\"movdi_pic_gotdata_op\"): Likewise.\n\t(\"*movsf_insn\"): Likewise.\n\t(\"*movdf_insn_sp32\"): Likewise.\n\t(\"*movdf_insn_sp64\"): Likewise.\n\t(\"*zero_extendhisi2_insn\"): Likewise.\n\t(\"*zero_extendqihi2_insn\"): Likewise.\n\t(\"*zero_extendqisi2_insn\"): Likewise.\n\t(\"*zero_extendqidi2_insn\"): Likewise.\n\t(\"*zero_extendhidi2_insn\"): Likewise.\n\t(\"*zero_extendsidi2_insn_sp64\"): Likewise.\n\t(\"ldfsr\"): Likewise.\n\t(\"prefetch_64\"): Likewise.\n\t(\"prefetch_32\"): Likewise.\n\t(\"tie_ld32\"): Likewise.\n\t(\"tie_ld64\"): Likewise.\n\t(\"*tldo_ldub_sp32\"): Likewise.\n\t(\"*tldo_ldub1_sp32\"): Likewise.\n\t(\"*tldo_ldub2_sp32\"): Likewise.\n\t(\"*tldo_ldub_sp64\"): Likewise.\n\t(\"*tldo_ldub1_sp64\"): Likewise.\n\t(\"*tldo_ldub2_sp64\"): Likewise.\n\t(\"*tldo_ldub3_sp64\"): Likewise.\n\t(\"*tldo_lduh_sp32\"): Likewise.\n\t(\"*tldo_lduh1_sp32\"): Likewise.\n\t(\"*tldo_lduh_sp64\"): Likewise.\n\t(\"*tldo_lduh1_sp64\"): Likewise.\n\t(\"*tldo_lduh2_sp64\"): Likewise.\n\t(\"*tldo_lduw_sp32\"): Likewise.\n\t(\"*tldo_lduw_sp64\"): Likewise.\n\t(\"*tldo_lduw1_sp64\"): Likewise.\n\t(\"*tldo_ldx_sp64\"): Likewise.\n\t(\"*mov<VM32:mode>_insn\"): Likewise.\n\t(\"*mov<VM64:mode>_insn_sp64\"): Likewise.\n\t(\"*mov<VM64:mode>_insn_sp32\"): Likewise.\n\n\t* config/sparc/sparc.md (\"type\"): New insn type viscmp.\n\t(\"fcmp<gcond:code><GCM:gcm_name><P:mode>_vis\"): Set insn type to\n\tviscmp.\n\t(\"fpcmp<gcond:code>8<P:mode>_vis\"): Likewise.\n\t(\"fucmp<gcond:code>8<P:mode>_vis\"): Likewise.\n\t(\"fpcmpu<gcond:code><GCM:gcm_name><P:mode>_vis\"): Likewise.\n\t* config/sparc/niagara7.md (\"n7_vis_logical_v3pipe\"): Handle\n\tviscmp.\n\t(\"n7_vis_logical_11cycle\"): Likewise.\n\t* config/sparc/niagara4.md (\"n4_vis_logical\"): Likewise.\n\t* config/sparc/niagara2.md (\"niag3_vis\": Likewise.\n\t* config/sparc/niagara.md (\"niag_vis\"): Likewise.\n\t* config/sparc/ultra3.md (\"us3_fga\"): Likewise.\n\t* config/sparc/ultra1_2.md (\"us1_fga_double\"): Likewise.\n\n\t* config/sparc/sparc.md: New instruction type `bmask'.\n\t(bmaskdi_vis): Use the `bmask' type.\n\t(bmasksi_vis): Likewise.\n\t* config/sparc/ultra3.md (us3_array): Likewise.\n\t* config/sparc/niagara7.md (n7_array): Likewise.\n\t* config/sparc/niagara4.md (n4_array): Likewise.\n\t* config/sparc/niagara2.md (niag2_vis): Likewise.\n\t(niag3_vis): Likewise.\n\t* config/sparc/niagara.md (niag_vis): Likewise.\n\ngcc/testsuite/ChangeLog:\n\n\t* gcc.target/sparc/dictunpack.c: New file.\n\t* gcc.target/sparc/fpcmpdeshl.c: Likewise.\n\t* gcc.target/sparc/fpcmpshl.c: Likewise.\n\t* gcc.target/sparc/fpcmpurshl.c: Likewise.\n\t* gcc.target/sparc/fpcmpushl.c: Likewise.\n\nFrom-SVN: r250049", "tree": {"sha": "c27dff158187a376c430d072ea07d8538db7442f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c27dff158187a376c430d072ea07d8538db7442f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bcc3c3f1ca89628f02802fda20f2232b9deef5f9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bcc3c3f1ca89628f02802fda20f2232b9deef5f9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bcc3c3f1ca89628f02802fda20f2232b9deef5f9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bcc3c3f1ca89628f02802fda20f2232b9deef5f9/comments", "author": {"login": "jemarch", "id": 7061875, "node_id": "MDQ6VXNlcjcwNjE4NzU=", "avatar_url": "https://avatars.githubusercontent.com/u/7061875?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jemarch", "html_url": "https://github.com/jemarch", "followers_url": "https://api.github.com/users/jemarch/followers", "following_url": "https://api.github.com/users/jemarch/following{/other_user}", "gists_url": "https://api.github.com/users/jemarch/gists{/gist_id}", "starred_url": "https://api.github.com/users/jemarch/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jemarch/subscriptions", "organizations_url": "https://api.github.com/users/jemarch/orgs", "repos_url": "https://api.github.com/users/jemarch/repos", "events_url": "https://api.github.com/users/jemarch/events{/privacy}", "received_events_url": "https://api.github.com/users/jemarch/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "29f1e2b173f1701b66410bc3624a989e98e23724", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/29f1e2b173f1701b66410bc3624a989e98e23724", "html_url": "https://github.com/Rust-GCC/gccrs/commit/29f1e2b173f1701b66410bc3624a989e98e23724"}], "stats": {"total": 1763, "additions": 1579, "deletions": 184}, "files": [{"sha": "a642e4a45b338bc00c1a58fce146991d52a1c78a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 226, "deletions": 0, "changes": 226, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcc3c3f1ca89628f02802fda20f2232b9deef5f9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcc3c3f1ca89628f02802fda20f2232b9deef5f9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bcc3c3f1ca89628f02802fda20f2232b9deef5f9", "patch": "@@ -1,3 +1,229 @@\n+2017-07-07  Jose E. Marchesi  <jose.marchesi@oracle.com>\n+\n+\t* config/sparc/m8.md: New file.\n+\t* config/sparc/sparc.md: Include m8.md.\n+\n+2017-07-07  Jose E. Marchesi  <jose.marchesi@oracle.com>\n+\n+\t* config/sparc/sparc.opt: New option -mvis4b.\n+\t* config/sparc/sparc.c (dump_target_flag_bits): Handle MASK_VIS4B.\n+\t(sparc_option_override): Handle VIS4B.\n+\t(enum sparc_builtins): Define\n+\tSPARC_BUILTIN_DICTUNPACK{8,16,32},\n+\tSPARC_BUILTIN_FPCMP{LE,GT,EQ,NE}{8,16,32}SHL,\n+\tSPARC_BUILTIN_FPCMPU{LE,GT}{8,16,32}SHL,\n+\tSPARC_BUILTIN_FPCMPDE{8,16,32}SHL and\n+\tSPARC_BUILTIN_FPCMPUR{8,16,32}SHL.\n+\t(check_constant_argument): New function.\n+\t(sparc_vis_init_builtins): Define builtins\n+\t__builtin_vis_dictunpack{8,16,32},\n+\t__builtin_vis_fpcmp{le,gt,eq,ne}{8,16,32}shl,\n+\t__builtin_vis_fpcmpu{le,gt}{8,16,32}shl,\n+\t__builtin_vis_fpcmpde{8,16,32}shl and\n+\t__builtin_vis_fpcmpur{8,16,32}shl.\n+\t(sparc_expand_builtin): Check that the constant operands to\n+\t__builtin_vis_fpcmp*shl and _builtin_vis_dictunpack* are indeed\n+\tconstant and in range.\n+\t* config/sparc/sparc-c.c (sparc_target_macros): Handle\n+\tTARGET_VIS4B.\n+\t* config/sparc/sparc.h (SPARC_IMM2_P): Define.\n+\t(SPARC_IMM5_P): Likewise.\n+\t* config/sparc/sparc.md (cpu_feature): Add new feagure \"vis4b\".\n+\t(enabled): Handle vis4b.\n+\t(UNSPEC_DICTUNPACK): New unspec.\n+\t(UNSPEC_FPCMPSHL): Likewise.\n+\t(UNSPEC_FPUCMPSHL): Likewise.\n+\t(UNSPEC_FPCMPDESHL): Likewise.\n+\t(UNSPEC_FPCMPURSHL): Likewise.\n+\t(cpu_feature): New CPU feature `vis4b'.\n+\t(dictunpack{8,16,32}): New insns.\n+\t(FPCSMODE): New mode iterator.\n+\t(fpcscond): New code iterator.\n+\t(fpcsucond): Likewise.\n+\t(fpcmp{le,gt,eq,ne}{8,16,32}{si,di}shl): New insns.\n+\t(fpcmpu{le,gt}{8,16,32}{si,di}shl): Likewise.\n+\t(fpcmpde{8,16,32}{si,di}shl): Likewise.\n+\t(fpcmpur{8,16,32}{si,di}shl): Likewise.\n+\t* config/sparc/constraints.md: Define constraints `q' for unsigned\n+\t2-bit integer constants and `t' for unsigned 5-bit integer\n+\tconstants.\n+\t* config/sparc/predicates.md (imm5_operand_dictunpack8): New\n+\tpredicate.\n+\t(imm5_operand_dictunpack16): Likewise.\n+\t(imm5_operand_dictunpack32): Likewise.\n+\t(imm2_operand): Likewise.\n+\t* doc/invoke.texi (SPARC Options): Document -mvis4b.\n+\t* doc/extend.texi (SPARC VIS Built-in Functions): Document the\n+\tditunpack* and fpcmp*shl builtins.\n+\n+2017-07-07  Jose E. Marchesi  <jose.marchesi@oracle.com>\n+\n+\t* config.gcc: Handle m8 in --with-{cpu,tune} options.\n+\t* config.in: Add HAVE_AS_SPARC6 define.\n+\t* config/sparc/driver-sparc.c (cpu_names): Add entry for the SPARC\n+\tM8.\n+\t* config/sparc/sol2.h (CPP_CPU64_DEFAULT_SPEC): Define for\n+\tTARGET_CPU_m8.\n+\t(ASM_CPU32_DEFAUILT_SPEC): Likewise.\n+\t(CPP_CPU_SPEC): Handle m8.\n+\t(ASM_CPU_SPEC): Likewise.\n+\t* config/sparc/sparc-opts.h (enum processor_type): Add\n+\tPROCESSOR_M8.\n+\t* config/sparc/sparc.c (m8_costs): New struct.\n+\t(sparc_option_override): Handle TARGET_CPU_m8.\n+\t(sparc32_initialize_trampoline): Likewise.\n+\t(sparc64_initialize_trampoline): Likewise.\n+\t(sparc_issue_rate): Likewise.\n+\t(sparc_register_move_cost): Likewise.\n+\t* config/sparc/sparc.h (TARGET_CPU_m8): Define.\n+\t(CPP_CPU64_DEFAULT_SPEC): Define for M8.\n+\t(ASM_CPU64_DEFAULT_SPEC): Likewise.\n+\t(CPP_CPU_SPEC): Handle M8.\n+\t(ASM_CPU_SPEC): Likewise.\n+\t(AS_M8_FLAG): Define.\n+\t* config/sparc/sparc.md: Add m8 to the cpu attribute.\n+\t* config/sparc/sparc.opt: New option -mcpu=m8 for sparc targets.\n+\t* configure.ac (HAVE_AS_SPARC6): Check for assembler support for\n+\tM8 instructions.\n+\t* configure: Regenerate.\n+\t* doc/invoke.texi (SPARC Options): Document -mcpu=m8 and\n+\t-mtune=m8.\n+\n+2017-07-07  Jose E. Marchesi  <jose.marchesi@oracle.com>\n+\n+\t* config/sparc/niagara7.md: Rework the DFA scheduler to use insn\n+\tsubtypes.\n+\t* config/sparc/sparc.md: Remove the `v3pipe' insn attribute.\n+\t(\"*movdi_insn_sp32\"): Do not set v3pipe.\n+\t(\"*movsi_insn\"): Likewise.\n+\t(\"*movdi_insn_sp64\"): Likewise.\n+\t(\"*movsf_insn\"): Likewise.\n+\t(\"*movdf_insn_sp32\"): Likewise.\n+\t(\"*movdf_insn_sp64\"): Likewise.\n+\t(\"*zero_extendsidi2_insn_sp64\"): Likewise.\n+\t(\"*sign_extendsidi2_insn\"): Likewise.\n+\t(\"*mov<VM32:mode>_insn\"): Likewise.\n+\t(\"*mov<VM64:mode>_insn_sp64\"): Likewise.\n+\t(\"*mov<VM64:mode>_insn_sp32\"): Likewise.\n+\t(\"<plusminus_insn><VADDSUB:mode>3\"): Likewise.\n+\t(\"<vlop:code><VL:mode>3\"): Likewise.\n+\t(\"*not_<vlop:code><VL:mode>3\"): Likewise.\n+\t(\"*nand<VL:mode>_vis\"): Likewise.\n+\t(\"*<vlnotop:code>_not1<VL:mode>_vis\"): Likewise.\n+\t(\"*<vlnotop:code>_not2<VL:mode>_vis\"): Likewise.\n+\t(\"one_cmpl<VL:mode>2\"): Likewise.\n+\t(\"faligndata<VM64:mode>_vis\"): Likewise.\n+\t(\"alignaddrsi_vis\"): Likewise.\n+\t(\"alignaddrdi_vis\"): Likweise.\n+\t(\"alignaddrlsi_vis\"): Likewise.\n+\t(\"alignaddrldi_vis\"): Likewise.\n+\t(\"fcmp<gcond:code><GCM:gcm_name><P:mode>_vis\"): Likewise.\n+\t(\"bmaskdi_vis\"): Likewise.\n+\t(\"bmasksi_vis\"): Likewise.\n+\t(\"bshuffle<VM64:mode>_vis\"): Likewise.\n+\t(\"cmask8<P:mode>_vis\"): Likewise.\n+\t(\"cmask16<P:mode>_vis\"): Likewise.\n+\t(\"cmask32<P:mode>_vis\"): Likewise.\n+\t(\"pdistn<P:mode>_vis\"): Likewise.\n+\t(\"<vis3_addsub_ss_patname><VASS:mode>3\"): Likewise.\n+\n+2017-07-07  Jose E. Marchesi  <jose.marchesi@oracle.com>\n+\n+\t* config/sparc/sparc.md (\"subtype\"): New insn attribute.\n+\t(\"*wrgsr_sp64\"): Set insn subtype.\n+\t(\"*rdgsr_sp64\"): Likewise.\n+\t(\"alignaddrsi_vis\"): Likewise.\n+\t(\"alignaddrdi_vis\"): Likewise.\n+\t(\"alignaddrlsi_vis\"): Likewise.\n+\t(\"alignaddrldi_vis\"): Likewise.\n+\t(\"<plusminus_insn><VADDSUB:mode>3\"): Likewise.\n+\t(\"fexpand_vis\"): Likewise.\n+\t(\"fpmerge_vis\"): Likewise.\n+\t(\"faligndata<VM64:mode>_vis\"): Likewise.\n+\t(\"bshuffle<VM64:mode>_vis\"): Likewise.\n+\t(\"cmask8<P:mode>_vis\"): Likewise.\n+\t(\"cmask16<P:mode>_vis\"): Likewise.\n+\t(\"cmask32<P:mode>_vis\"): Likewise.\n+\t(\"fchksm16_vis\"): Likewise.\n+\t(\"v<vis3_shift_patname><GCM:mode>3\"): Likewise.\n+\t(\"fmean16_vis\"): Likewise.\n+\t(\"fp<plusminus_insn>64_vis\"): Likewise.\n+\t(\"<plusminus_insn>v8qi3\"): Likewise.\n+\t(\"<vis3_addsub_ss_patname><VASS:mode>3\"): Likewise.\n+\t(\"<vis4_minmax_patname><VMMAX:mode>3\"): Likewise.\n+\t(\"<vis4_uminmax_patname><VMMAX:mode>3\"): Likewise.\n+\t(\"<vis3_addsub_ss_patname>v8qi3\"): Likewise.\n+\t(\"<vis4_addsub_us_patname><VAUS:mode>3\"): Likewise.\n+\t(\"*movqi_insn\"): Likewise.\n+\t(\"*movhi_insn\"): Likewise.\n+\t(\"*movsi_insn\"): Likewise.\n+\t(\"movsi_pic_gotdata_op\"): Likewise.\n+\t(\"*movdi_insn_sp32\"): Likewise.\n+\t(\"*movdi_insn_sp64\"): Likewise.\n+\t(\"movdi_pic_gotdata_op\"): Likewise.\n+\t(\"*movsf_insn\"): Likewise.\n+\t(\"*movdf_insn_sp32\"): Likewise.\n+\t(\"*movdf_insn_sp64\"): Likewise.\n+\t(\"*zero_extendhisi2_insn\"): Likewise.\n+\t(\"*zero_extendqihi2_insn\"): Likewise.\n+\t(\"*zero_extendqisi2_insn\"): Likewise.\n+\t(\"*zero_extendqidi2_insn\"): Likewise.\n+\t(\"*zero_extendhidi2_insn\"): Likewise.\n+\t(\"*zero_extendsidi2_insn_sp64\"): Likewise.\n+\t(\"ldfsr\"): Likewise.\n+\t(\"prefetch_64\"): Likewise.\n+\t(\"prefetch_32\"): Likewise.\n+\t(\"tie_ld32\"): Likewise.\n+\t(\"tie_ld64\"): Likewise.\n+\t(\"*tldo_ldub_sp32\"): Likewise.\n+\t(\"*tldo_ldub1_sp32\"): Likewise.\n+\t(\"*tldo_ldub2_sp32\"): Likewise.\n+\t(\"*tldo_ldub_sp64\"): Likewise.\n+\t(\"*tldo_ldub1_sp64\"): Likewise.\n+\t(\"*tldo_ldub2_sp64\"): Likewise.\n+\t(\"*tldo_ldub3_sp64\"): Likewise.\n+\t(\"*tldo_lduh_sp32\"): Likewise.\n+\t(\"*tldo_lduh1_sp32\"): Likewise.\n+\t(\"*tldo_lduh_sp64\"): Likewise.\n+\t(\"*tldo_lduh1_sp64\"): Likewise.\n+\t(\"*tldo_lduh2_sp64\"): Likewise.\n+\t(\"*tldo_lduw_sp32\"): Likewise.\n+\t(\"*tldo_lduw_sp64\"): Likewise.\n+\t(\"*tldo_lduw1_sp64\"): Likewise.\n+\t(\"*tldo_ldx_sp64\"): Likewise.\n+\t(\"*mov<VM32:mode>_insn\"): Likewise.\n+\t(\"*mov<VM64:mode>_insn_sp64\"): Likewise.\n+\t(\"*mov<VM64:mode>_insn_sp32\"): Likewise.\n+\n+2017-07-07  Jose E. Marchesi  <jose.marchesi@oracle.com>\n+\n+\t* config/sparc/sparc.md (\"type\"): New insn type viscmp.\n+\t(\"fcmp<gcond:code><GCM:gcm_name><P:mode>_vis\"): Set insn type to\n+\tviscmp.\n+\t(\"fpcmp<gcond:code>8<P:mode>_vis\"): Likewise.\n+\t(\"fucmp<gcond:code>8<P:mode>_vis\"): Likewise.\n+\t(\"fpcmpu<gcond:code><GCM:gcm_name><P:mode>_vis\"): Likewise.\n+\t* config/sparc/niagara7.md (\"n7_vis_logical_v3pipe\"): Handle\n+\tviscmp.\n+\t(\"n7_vis_logical_11cycle\"): Likewise.\n+\t* config/sparc/niagara4.md (\"n4_vis_logical\"): Likewise.\n+\t* config/sparc/niagara2.md (\"niag3_vis\": Likewise.\n+\t* config/sparc/niagara.md (\"niag_vis\"): Likewise.\n+\t* config/sparc/ultra3.md (\"us3_fga\"): Likewise.\n+\t* config/sparc/ultra1_2.md (\"us1_fga_double\"): Likewise.\n+\n+2017-07-07  Jose E. Marchesi  <jose.marchesi@oracle.com>\n+\n+\t* config/sparc/sparc.md: New instruction type `bmask'.\n+\t(bmaskdi_vis): Use the `bmask' type.\n+\t(bmasksi_vis): Likewise.\n+\t* config/sparc/ultra3.md (us3_array): Likewise.\n+\t* config/sparc/niagara7.md (n7_array): Likewise.\n+\t* config/sparc/niagara4.md (n4_array): Likewise.\n+\t* config/sparc/niagara2.md (niag2_vis): Likewise.\n+\t(niag3_vis): Likewise.\n+\t* config/sparc/niagara.md (niag_vis): Likewise.\n+\n 2017-07-06  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* ipa-comdats.c: Remove optimize check from gate."}, {"sha": "a1e0f8f1e4d4fc3d600267831d12d808ad7777b9", "filename": "gcc/config.gcc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcc3c3f1ca89628f02802fda20f2232b9deef5f9/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcc3c3f1ca89628f02802fda20f2232b9deef5f9/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=bcc3c3f1ca89628f02802fda20f2232b9deef5f9", "patch": "@@ -4435,7 +4435,7 @@ case \"${target}\" in\n \t\t\t| sparclite | f930 | f934 | sparclite86x \\\n \t\t\t| sparclet | tsc701 \\\n \t\t\t| v9 | ultrasparc | ultrasparc3 | niagara | niagara2 \\\n-\t\t\t| niagara3 | niagara4 | niagara7)\n+\t\t\t| niagara3 | niagara4 | niagara7 | m8)\n \t\t\t\t# OK\n \t\t\t\t;;\n \t\t\t*)"}, {"sha": "73c9f92bb5d69c1abe9b93d767f505e627ce2bf1", "filename": "gcc/config.in", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcc3c3f1ca89628f02802fda20f2232b9deef5f9/gcc%2Fconfig.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcc3c3f1ca89628f02802fda20f2232b9deef5f9/gcc%2Fconfig.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.in?ref=bcc3c3f1ca89628f02802fda20f2232b9deef5f9", "patch": "@@ -660,6 +660,10 @@\n #undef HAVE_AS_SPARC5_VIS4\n #endif\n \n+/* Define if your assembler supports SPARC6 instructions. */\n+#ifndef USED_FOR_TARGET\n+#undef HAVE_AS_SPARC6\n+#endif\n \n /* Define if your assembler and linker support GOTDATA_OP relocs. */\n #ifndef USED_FOR_TARGET"}, {"sha": "cff5a61b1de2e3880d4548bb3dda40f8fdd07dd9", "filename": "gcc/config/sparc/constraints.md", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcc3c3f1ca89628f02802fda20f2232b9deef5f9/gcc%2Fconfig%2Fsparc%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcc3c3f1ca89628f02802fda20f2232b9deef5f9/gcc%2Fconfig%2Fsparc%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fconstraints.md?ref=bcc3c3f1ca89628f02802fda20f2232b9deef5f9", "patch": "@@ -19,7 +19,7 @@\n \n ;;; Unused letters:\n ;;;     B\n-;;;    a        jkl    q  tuv xyz\n+;;;    a        jkl        uv xyz\n \n \n ;; Register constraints\n@@ -58,6 +58,16 @@\n \n ;; Integer constant constraints\n \n+(define_constraint \"q\"\n+ \"Unsigned 2-bit integer constant\"\n+  (and (match_code \"const_int\")\n+       (match_test \"SPARC_IMM2_P (ival)\")))\n+\n+(define_constraint \"t\"\n+ \"Unsigned 5-bit integer constant\"\n+ (and (match_code \"const_int\")\n+      (match_test \"SPARC_IMM5_P (ival)\")))\n+\n (define_constraint \"A\"\n  \"Signed 5-bit integer constant\"\n  (and (match_code \"const_int\")"}, {"sha": "0c25d6cfa1509bd47780fc5befef98597636aa94", "filename": "gcc/config/sparc/driver-sparc.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcc3c3f1ca89628f02802fda20f2232b9deef5f9/gcc%2Fconfig%2Fsparc%2Fdriver-sparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcc3c3f1ca89628f02802fda20f2232b9deef5f9/gcc%2Fconfig%2Fsparc%2Fdriver-sparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fdriver-sparc.c?ref=bcc3c3f1ca89628f02802fda20f2232b9deef5f9", "patch": "@@ -79,6 +79,7 @@ static const struct cpu_names {\n #endif\n   { \"SPARC-M7\",\t\t\"niagara7\" },\n   { \"SPARC-S7\",\t\t\"niagara7\" },\n+  { \"SPARC-M8\",\t\t\"m8\" },\n   { NULL,\tNULL }\n   };\n "}, {"sha": "f0fe1b27a2038fecec5ed23f9ad35dace12f27cd", "filename": "gcc/config/sparc/m8.md", "status": "added", "additions": 242, "deletions": 0, "changes": 242, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcc3c3f1ca89628f02802fda20f2232b9deef5f9/gcc%2Fconfig%2Fsparc%2Fm8.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcc3c3f1ca89628f02802fda20f2232b9deef5f9/gcc%2Fconfig%2Fsparc%2Fm8.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fm8.md?ref=bcc3c3f1ca89628f02802fda20f2232b9deef5f9", "patch": "@@ -0,0 +1,242 @@\n+;; Scheduling description for the SPARC M8.\n+;;   Copyright (C) 2017 Free Software Foundation, Inc.\n+;;\n+;; This file is part of GCC.\n+;;\n+;; GCC is free software; you can redistribute it and/or modify\n+;; it under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 3, or (at your option)\n+;; any later version.\n+;;\n+;; GCC is distributed in the hope that it will be useful,\n+;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+;; GNU General Public License for more details.\n+;;\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING3.  If not see\n+;; <http://www.gnu.org/licenses/>.\n+\n+;; Thigs to improve:\n+;;\n+;; - Store instructions are implemented by micro-ops, one of which\n+;;   generates the store address and is executed in the store address\n+;;   generation unit in the slot0.  We need to model that.\n+;;\n+;; - There are two V3 pipes connected to different slots.  The current\n+;;   implementation assumes that all the instructions executing in a\n+;;   V3 pipe are issued to the unit in slot3.\n+;;\n+;; - Single-issue ALU operations incur an additional cycle of latency to\n+;;   slot 0 and slot 1 instructions.  This is not currently reflected\n+;;   in the DFA.\n+\n+(define_automaton \"m8_0\")\n+\n+;; The S5 core has two dual-issue queues, PQLS and PQEX.  Each queue\n+;; is divided into two slots: PQLS corresponds to slots 0 and 1, and\n+;; PQEX corresponds to slots 2 and 3.  The core can issue 4\n+;; instructions per-cycle, and up to 4 instructions are committed each\n+;; cycle.\n+;;\n+;;                            \n+;;                   m8_slot0  - Load Unit.\n+;;                             - Store address gen. Unit.\n+;;                                                       \n+;;                            \n+;;   === PQLS ==>    m8_slot1  - Store data unit.\n+;;                             - Branch unit.\n+;;                                            \n+;;                             \n+;;   === PQEX ==>    m8_slot2  - Integer Unit (EXU2).                     \n+;;                             - 3-cycles Crypto Unit (SPU2).\n+;;                                                     \n+;;                   m8_slot3  - Integer Unit (EXU3).\n+;;                             - 3-cycles Crypto Unit (SPU3).\n+;;                             - Floating-point and graphics unit (FPG).\n+;;                             - Long-latency Crypto Unit.\n+;;                             - Oracle Numbers Unit (ONU).\n+\n+(define_cpu_unit \"m8_slot0,m8_slot1,m8_slot2,m8_slot3\" \"m8_0\")\n+\n+;; Some instructions stall the pipeline and avoid any other\n+;; instruction to be issued in the same cycle.  We assume the same for\n+;; multi-instruction insns.\n+\n+(define_reservation \"m8_single_issue\" \"m8_slot0 + m8_slot1 + m8_slot2 + m8_slot3\")\n+\n+(define_insn_reservation \"m8_single\" 1\n+  (and (eq_attr \"cpu\" \"m8\")\n+       (eq_attr \"type\" \"multi,savew,flushw,trap,bmask\"))\n+  \"m8_single_issue\")\n+\n+;; Most of the instructions executing in the integer units have a\n+;; latency of 1.\n+\n+(define_insn_reservation \"m8_integer\" 1\n+  (and (eq_attr \"cpu\" \"m8\")\n+       (eq_attr \"type\" \"ialu,ialuX,shift,cmove,compare,bmask\"))\n+  \"(m8_slot2 | m8_slot3)\")\n+\n+;; Flushing the instruction memory takes 27 cycles.\n+\n+\n+(define_insn_reservation \"m8_iflush\" 27\n+  (and (eq_attr \"cpu\" \"m8\")\n+       (eq_attr \"type\" \"iflush\"))\n+  \"(m8_slot2 | m8_slot3), nothing*26\")\n+\n+;; The integer multiplication instructions have a latency of 10 cycles\n+;; and execute in integer units.\n+;;\n+;; Likewise for array*, edge* and pdistn instructions.\n+;;\n+;; However, the latency is only 9 cycles if the consumer of the\n+;; operation is also capable of 9 cycles latency.  We model this with\n+;; a bypass.\n+\n+(define_insn_reservation \"m8_imul\" 10\n+  (and (eq_attr \"cpu\" \"m8\")\n+       (eq_attr \"type\" \"imul,array,edge,edgen,pdistn\"))\n+  \"(m8_slot2 | m8_slot3), nothing*12\")\n+\n+(define_bypass 9 \"m8_imul\" \"m8_imul\")\n+\n+;; The integer division instructions `sdiv' and `udivx' have a latency\n+;; of 30 cycles and execute in integer units.\n+\n+(define_insn_reservation \"m8_idiv\" 30\n+  (and (eq_attr \"cpu\" \"m8\")\n+       (eq_attr \"type\" \"idiv\"))\n+  \"(m8_slot2 | m8_slot3), nothing*29\")\n+\n+;; Both integer and floating-point load instructions have a latency of\n+;; only 3 cycles,and execute in the slot0.\n+;;\n+;; Misaligned load instructions feature a latency of 11 cycles.\n+;;\n+;; The prefetch instruction also executes in the load unit, but it's\n+;; latency is only 1 cycle.\n+\n+(define_insn_reservation \"m8_load\" 3\n+  (and (eq_attr \"cpu\" \"m8\")\n+       (ior (eq_attr \"type\" \"fpload,sload\")\n+            (and (eq_attr \"type\" \"load\")\n+                 (eq_attr \"subtype\" \"regular\"))))\n+  \"m8_slot0, nothing*2\")\n+\n+;; (define_insn_reservation \"m8_load_misalign\" 11\n+;;  (and (eq_attr \"cpu\" \"m8\")\n+;;       (eq_attr \"type\" \"load_mis,fpload_mis\"))\n+;;  \"m8_slot0, nothing*10\")\n+\n+(define_insn_reservation \"m8_prefetch\" 1\n+  (and (eq_attr \"cpu\" \"m8\")\n+       (eq_attr \"type\" \"load\")\n+       (eq_attr \"subtype\" \"prefetch\"))\n+  \"m8_slot0\")\n+\n+;; Both integer and floating-point store instructions have a latency\n+;; of 1 cycle, and execute in the store data unit in slot1.\n+;;\n+;; However, misaligned store instructions feature a latency of 3\n+;; cycles.\n+\n+(define_insn_reservation \"m8_store\" 1\n+  (and (eq_attr \"cpu\" \"m8\")\n+       (eq_attr \"type\" \"store,fpstore\"))\n+  \"m8_slot1\")\n+\n+;; (define_insn_reservation \"m8_store_misalign\" 3\n+;;   (and (eq_attr \"cpu\" \"m8\")\n+;;        (eq_attr \"type\" \"store_mis,fpstore_mis\"))\n+;;   \"m8_slot1, nothing*2\")\n+\n+;; Control-transfer instructions execute in the Branch Unit in the\n+;; slot1.\n+\n+(define_insn_reservation \"m8_cti\" 1\n+  (and (eq_attr \"cpu\" \"m8\")\n+       (eq_attr \"type\" \"cbcond,uncond_cbcond,branch,call,sibcall,call_no_delay_slot,uncond_branch,return\"))\n+  \"m8_slot1\")\n+\n+;; Many instructions executing in the Floating-point and Graphics Unit\n+;; (FGU) serving slot3 feature a default latency of 9 cycles.\n+\n+(define_insn_reservation \"m8_fp\" 9\n+  (and (eq_attr \"cpu\" \"m8\")\n+       (ior (eq_attr \"type\" \"fpmove,fpcmove,fpcrmove,fp,fpcmp,fpmul,fgm_pack,fgm_mul,pdist\")\n+            (and (eq_attr \"type\" \"fga\")\n+                 (eq_attr \"subtype\" \"fpu\"))))\n+  \"m8_slot3, nothing*8\")\n+\n+;; Floating-point division and floating-point square-root instructions\n+;; have high latencies.  They execute in the FGU.\n+\n+(define_insn_reservation \"m8_fpdivs\" 26\n+  (and (eq_attr \"cpu\" \"m8\")\n+       (eq_attr \"type\" \"fpdivs\"))\n+  \"m8_slot3, nothing*25\")\n+\n+(define_insn_reservation \"m8_fpsqrts\" 33\n+  (and (eq_attr \"cpu\" \"m8\")\n+       (eq_attr \"type\" \"fpsqrts\"))\n+  \"m8_slot3, nothing*32\")\n+\n+(define_insn_reservation \"m8_fpdivd\" 30\n+  (and (eq_attr \"cpu\" \"m8\")\n+       (eq_attr \"type\" \"fpdivd\"))\n+  \"m8_slot3, nothing*29\")\n+\n+(define_insn_reservation \"m8_fpsqrtd\" 41\n+  (and (eq_attr \"cpu\" \"m8\")\n+       (eq_attr \"type\" \"fpsqrtd\"))\n+  \"m8_slot3, nothing*40\")\n+\n+;; SIMD VIS instructions executing in the Floating-point and graphics\n+;; unit (FPG) in slot3 usually have a latency of 5 cycles.\n+;;\n+;; However, the latency for many instructions is only 3 cycles if the\n+;; consumer can also be executed in 3 cycles.  We model this with a\n+;; bypass.  In these cases the instructions are executed in one of the\n+;; two 3-cycle crypto units (SPU, also known as \"v3-pipes\") in slots 2\n+;; and 3.\n+\n+(define_insn_reservation \"m8_vis\" 5\n+  (and (eq_attr \"cpu\" \"m8\")\n+       (ior (eq_attr \"type\" \"viscmp,lzd\")\n+            (and (eq_attr \"type\" \"fga\")\n+                 (eq_attr \"subtype\" \"maxmin,cmask,other\"))\n+            (and (eq_attr \"type\" \"vismv\")\n+                 (eq_attr \"subtype\" \"single,movstouw\"))\n+            (and (eq_attr \"type\" \"visl\")\n+                 (eq_attr \"subtype\" \"single\"))))\n+  \"m8_slot3, nothing*4\")\n+\n+(define_bypass 3 \"m8_vis\" \"m8_vis\")\n+\n+(define_insn_reservation \"m8_gsr\" 5\n+  (and (eq_attr \"cpu\" \"m8\")\n+       (eq_attr \"type\" \"gsr\")\n+       (eq_attr \"subtype\" \"alignaddr\"))\n+  \"m8_slot3, nothing*4\")\n+\n+;; A few VIS instructions have a latency of 1.\n+\n+(define_insn_reservation \"m8_vis_1cycle\" 1\n+  (and (eq_attr \"cpu\" \"m8\")\n+       (ior (and (eq_attr \"type\" \"vismv\")\n+                 (eq_attr \"subtype\" \"double,movxtod,movdtox\"))\n+            (and (eq_attr \"type\" \"visl\")\n+                 (eq_attr \"subtype\" \"double\"))\n+            (and (eq_attr \"type\" \"fga\")\n+                 (eq_attr \"subtype\" \"addsub64\"))))\n+  \"m8_slot3\")\n+\n+;; Reading and writing to the gsr register takes more than 70 cycles.\n+\n+(define_insn_reservation \"m8_gsr_reg\" 70\n+  (and (eq_attr \"cpu\" \"m8\")\n+       (eq_attr \"type\" \"gsr\")\n+       (eq_attr \"subtype\" \"reg\"))\n+  \"m8_slot3, nothing*69\")"}, {"sha": "a8e23b8f894a0dbbd7ab0c1bc5852e9cfb4dcc04", "filename": "gcc/config/sparc/niagara.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcc3c3f1ca89628f02802fda20f2232b9deef5f9/gcc%2Fconfig%2Fsparc%2Fniagara.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcc3c3f1ca89628f02802fda20f2232b9deef5f9/gcc%2Fconfig%2Fsparc%2Fniagara.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fniagara.md?ref=bcc3c3f1ca89628f02802fda20f2232b9deef5f9", "patch": "@@ -114,5 +114,5 @@\n  */\n (define_insn_reservation \"niag_vis\" 8\n   (and (eq_attr \"cpu\" \"niagara\")\n-    (eq_attr \"type\" \"fga,visl,vismv,fgm_pack,fgm_mul,pdist,edge,edgen,gsr,array\"))\n+    (eq_attr \"type\" \"fga,visl,viscmp,vismv,fgm_pack,fgm_mul,pdist,edge,edgen,gsr,array,bmask\"))\n   \"niag_pipe*8\")"}, {"sha": "3190d556e53f9608b55a6d0c0466612c6c15db19", "filename": "gcc/config/sparc/niagara2.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcc3c3f1ca89628f02802fda20f2232b9deef5f9/gcc%2Fconfig%2Fsparc%2Fniagara2.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcc3c3f1ca89628f02802fda20f2232b9deef5f9/gcc%2Fconfig%2Fsparc%2Fniagara2.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fniagara2.md?ref=bcc3c3f1ca89628f02802fda20f2232b9deef5f9", "patch": "@@ -111,10 +111,10 @@\n \n (define_insn_reservation \"niag2_vis\" 6\n   (and (eq_attr \"cpu\" \"niagara2\")\n-    (eq_attr \"type\" \"fga,vismv,visl,fgm_pack,fgm_mul,pdist,edge,edgen,array,gsr\"))\n+    (eq_attr \"type\" \"fga,vismv,visl,viscmp,fgm_pack,fgm_mul,pdist,edge,edgen,array,bmask,gsr\"))\n   \"niag2_pipe*6\")\n \n (define_insn_reservation \"niag3_vis\" 9\n   (and (eq_attr \"cpu\" \"niagara3\")\n-    (eq_attr \"type\" \"fga,vismv,visl,fgm_pack,fgm_mul,pdist,pdistn,edge,edgen,array,gsr\"))\n+    (eq_attr \"type\" \"fga,vismv,visl,viscmp,fgm_pack,fgm_mul,pdist,pdistn,edge,edgen,array,bmask,gsr\"))\n   \"niag2_pipe*9\")"}, {"sha": "a3417d21c715ef5c29cbe1ee3c501b0e036ead3f", "filename": "gcc/config/sparc/niagara4.md", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcc3c3f1ca89628f02802fda20f2232b9deef5f9/gcc%2Fconfig%2Fsparc%2Fniagara4.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcc3c3f1ca89628f02802fda20f2232b9deef5f9/gcc%2Fconfig%2Fsparc%2Fniagara4.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fniagara4.md?ref=bcc3c3f1ca89628f02802fda20f2232b9deef5f9", "patch": "@@ -66,7 +66,7 @@\n \n (define_insn_reservation \"n4_array\" 12\n   (and (eq_attr \"cpu\" \"niagara4\")\n-    (eq_attr \"type\" \"array,edge,edgen\"))\n+    (eq_attr \"type\" \"array,bmask,edge,edgen\"))\n   \"n4_slot1, nothing*11\")\n \n (define_insn_reservation \"n4_vis_move_1cycle\" 1\n@@ -90,8 +90,9 @@\n \n (define_insn_reservation \"n4_vis_logical\" 3\n   (and (eq_attr \"cpu\" \"niagara4\")\n-    (and (eq_attr \"type\" \"visl,pdistn\")\n-      (eq_attr \"fptype\" \"double\")))\n+       (ior (and (eq_attr \"type\" \"visl,pdistn\")\n+                 (eq_attr \"fptype\" \"double\"))\n+            (eq_attr \"type\" \"viscmp\")))\n   \"n4_slot1, nothing*2\")\n \n (define_insn_reservation \"n4_vis_logical_11cycle\" 11"}, {"sha": "23b67075e2bd27b847fadee912a6872f709e8ac1", "filename": "gcc/config/sparc/niagara7.md", "status": "modified", "additions": 125, "deletions": 56, "changes": 181, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcc3c3f1ca89628f02802fda20f2232b9deef5f9/gcc%2Fconfig%2Fsparc%2Fniagara7.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcc3c3f1ca89628f02802fda20f2232b9deef5f9/gcc%2Fconfig%2Fsparc%2Fniagara7.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fniagara7.md?ref=bcc3c3f1ca89628f02802fda20f2232b9deef5f9", "patch": "@@ -19,118 +19,187 @@\n \n (define_automaton \"niagara7_0\")\n \n-(define_cpu_unit \"n7_slot0,n7_slot1,n7_slot2\" \"niagara7_0\")\n-(define_reservation \"n7_single_issue\" \"n7_slot0 + n7_slot1 + n7_slot2\")\n+;; The S4 core has a dual-issue queue.  This queue is divided into two\n+;; slots.  One instruction can be issued each cycle to each slot, and\n+;; up to 2 instructions are committed each cycle.  Each slot serves\n+;; several execution units, as depicted below:\n+;;\n+;;\n+;;                 m7_slot0 - Integer unit.\n+;;                          - Load/Store unit.\n+;; === QUEUE ==>\n+;;\n+;;                 m7_slot1 - Integer unit.\n+;;                          - Branch unit.\n+;;                          - Floating-point and graphics unit.\n+;;                          - 3-cycles crypto unit.\n \n-(define_cpu_unit \"n7_load_store\" \"niagara7_0\")\n+(define_cpu_unit \"n7_slot0,n7_slot1\" \"niagara7_0\")\n+\n+;; Some instructions stall the pipeline and avoid any other\n+;; instruction to be issued in the same cycle.  We assume the same for\n+;; multi-instruction insns.\n+\n+(define_reservation \"n7_single_issue\" \"n7_slot0 + n7_slot1\")\n \n (define_insn_reservation \"n7_single\" 1\n   (and (eq_attr \"cpu\" \"niagara7\")\n     (eq_attr \"type\" \"multi,savew,flushw,trap\"))\n   \"n7_single_issue\")\n \n-(define_insn_reservation \"n7_iflush\" 27\n-  (and (eq_attr \"cpu\" \"niagara7\")\n-       (eq_attr \"type\" \"iflush\"))\n-  \"(n7_slot0 | n7_slot1), nothing*26\")\n+;; Most of the instructions executing in the integer unit have a\n+;; latency of 1.\n \n (define_insn_reservation \"n7_integer\" 1\n   (and (eq_attr \"cpu\" \"niagara7\")\n     (eq_attr \"type\" \"ialu,ialuX,shift,cmove,compare\"))\n   \"(n7_slot0 | n7_slot1)\")\n \n+;; Flushing the instruction memory takes 27 cycles.\n+\n+(define_insn_reservation \"n7_iflush\" 27\n+  (and (eq_attr \"cpu\" \"niagara7\")\n+       (eq_attr \"type\" \"iflush\"))\n+  \"(n7_slot0 | n7_slot1), nothing*26\")\n+\n+;; The integer multiplication instructions have a latency of 12 cycles\n+;; and execute in the integer unit.\n+;;\n+;; Likewise for array*, edge* and pdistn instructions.\n+\n (define_insn_reservation \"n7_imul\" 12\n   (and (eq_attr \"cpu\" \"niagara7\")\n-    (eq_attr \"type\" \"imul\"))\n-  \"n7_slot1, nothing*11\")\n+    (eq_attr \"type\" \"imul,array,edge,edgen,pdistn\"))\n+  \"(n7_slot0 | n7_slot1), nothing*11\")\n+\n+;; The integer division instructions have a latency of 35 cycles and\n+;; execute in the integer unit.\n \n (define_insn_reservation \"n7_idiv\" 35\n   (and (eq_attr \"cpu\" \"niagara7\")\n     (eq_attr \"type\" \"idiv\"))\n-  \"n7_slot1, nothing*34\")\n+  \"(n7_slot0 | n7_slot1), nothing*34\")\n+\n+;; Both integer and floating-point load instructions have a latency of\n+;; 5 cycles, and execute in the slot0.\n+;;\n+;; The prefetch instruction also executes in the load/store unit, but\n+;; its latency is only 1 cycle.\n \n (define_insn_reservation \"n7_load\" 5\n   (and (eq_attr \"cpu\" \"niagara7\")\n-    (eq_attr \"type\" \"load,fpload,sload\"))\n-  \"(n7_slot0 + n7_load_store), nothing*4\")\n+       (ior (eq_attr \"type\" \"fpload,sload\")\n+            (and (eq_attr \"type\" \"load\")\n+                 (eq_attr \"subtype\" \"regular\"))))\n+  \"n7_slot0, nothing*4\")\n+\n+(define_insn_reservation \"n7_prefetch\" 1\n+  (and (eq_attr \"cpu\" \"niagara7\")\n+       (eq_attr \"type\" \"load\")\n+       (eq_attr \"subtype\" \"prefetch\"))\n+  \"n7_slot0\")\n+\n+;; Both integer and floating-point store instructions have a latency\n+;; of 1 cycle, and execute in the load/store unit in slot0.\n \n (define_insn_reservation \"n7_store\" 1\n   (and (eq_attr \"cpu\" \"niagara7\")\n     (eq_attr \"type\" \"store,fpstore\"))\n-  \"(n7_slot0 | n7_slot2) + n7_load_store\")\n+  \"n7_slot0\")\n+\n+;; Control-transfer instructions execute in the Branch Unit in the\n+;; slot1.\n \n (define_insn_reservation \"n7_cti\" 1\n   (and (eq_attr \"cpu\" \"niagara7\")\n     (eq_attr \"type\" \"cbcond,uncond_cbcond,branch,call,sibcall,call_no_delay_slot,uncond_branch,return\"))\n   \"n7_slot1\")\n \n+;; Many instructions executing in the Floating-point and Graphics unit\n+;; in the slot1 feature a latency of 11 cycles.\n+\n (define_insn_reservation \"n7_fp\" 11\n   (and (eq_attr \"cpu\" \"niagara7\")\n-    (eq_attr \"type\" \"fpmove,fpcmove,fpcrmove,fp,fpcmp,fpmul\"))\n+       (ior (eq_attr \"type\" \"fpmove,fpcmove,fpcrmove,fp,fpcmp,fpmul,fgm_pack,fgm_mul,pdist\")\n+            (and (eq_attr \"type\" \"fga\")\n+                 (eq_attr \"subtype\" \"fpu,maxmin\"))))\n   \"n7_slot1, nothing*10\")\n \n-(define_insn_reservation \"n7_array\" 12\n-  (and (eq_attr \"cpu\" \"niagara7\")\n-    (eq_attr \"type\" \"array,edge,edgen\"))\n-  \"n7_slot1, nothing*11\")\n+;; Floating-point division and floating-point square-root instructions\n+;; have high latencies.  They execute in the floating-point and\n+;; graphics unit in the slot1.\n+\n \n (define_insn_reservation \"n7_fpdivs\" 24\n   (and (eq_attr \"cpu\" \"niagara7\")\n-    (eq_attr \"type\" \"fpdivs,fpsqrts\"))\n+       (eq_attr \"type\" \"fpdivs,fpsqrts\"))\n   \"n7_slot1, nothing*23\")\n \n (define_insn_reservation \"n7_fpdivd\" 37\n   (and (eq_attr \"cpu\" \"niagara7\")\n     (eq_attr \"type\" \"fpdivd,fpsqrtd\"))\n   \"n7_slot1, nothing*36\")\n \n-(define_insn_reservation \"n7_lzd\" 12\n-  (and (eq_attr \"cpu\" \"niagara7\")\n-       (eq_attr \"type\" \"lzd\"))\n-  \"(n7_slot0 | n7_slot1), nothing*11\")\n-\n-;; There is an internal unit called the \"V3 pipe\", that was originally\n-;; intended to process some of the short cryptographic instructions.\n-;; However, as soon as in the T4 several of the VIS instructions\n-;; (notably non-FP instructions) have been moved to the V3 pipe.\n-;; Consequently, these instructions feature a latency of 3 instead of\n-;; 11 or 12 cycles, provided their consumers also execute in the V3\n-;; pipe.\n+;; SIMD VIS instructions executing in the Floating-point and graphics\n+;; unit (FPG) in slot1 usually have a latency of either 11 or 12\n+;; cycles.\n ;;\n-;; This is modelled here with a bypass.\n+;; However, the latency for many instructions is only 3 cycles if the\n+;; consumer can also be executed in 3 cycles.  We model this with a\n+;; bypass.  In these cases the instructions are executed in the\n+;; 3-cycle crypto unit which also serves slot1.\n+\n+(define_insn_reservation \"n7_vis_11cycles\" 11\n+  (and (eq_attr \"cpu\" \"niagara7\")\n+       (ior (and (eq_attr \"type\" \"fga\")\n+                 (eq_attr \"subtype\" \"addsub64,other\"))\n+            (and (eq_attr \"type\" \"vismv\")\n+                 (eq_attr \"subtype\" \"double,single\"))\n+            (and (eq_attr \"type\" \"visl\")\n+                 (eq_attr \"subtype\" \"double,single\"))))\n+  \"n7_slot1, nothing*10\")\n \n-(define_insn_reservation \"n7_vis_fga\" 11\n+(define_insn_reservation \"n7_vis_12cycles\" 12\n   (and (eq_attr \"cpu\" \"niagara7\")\n-    (eq_attr \"type\" \"fga,gsr\"))\n-  \"n7_slot1, nothing*10\")\n+       (ior (eq_attr \"type\" \"bmask,viscmp\")\n+            (and (eq_attr \"type\" \"fga\")\n+                 (eq_attr \"subtype\" \"cmask\"))\n+            (and (eq_attr \"type\" \"vismv\")\n+                 (eq_attr \"subtype\" \"movstouw\"))))\n+  \"n7_slot1, nothing*11\")\n+\n+(define_bypass 3 \"n7_vis_*\" \"n7_vis_*\")\n+\n+;; Some other VIS instructions have a latency of 12 cycles, and won't\n+;; be executed in the 3-cycle crypto pipe.\n \n-(define_insn_reservation \"n7_vis_fgm\" 11\n+(define_insn_reservation \"n7_lzd\" 12\n   (and (eq_attr \"cpu\" \"niagara7\")\n-    (eq_attr \"type\" \"fgm_pack,fgm_mul,pdist\"))\n-  \"n7_slot1, nothing*10\")\n+       (ior (eq_attr \"type\" \"lzd,\")\n+            (and (eq_attr \"type\" \"gsr\")\n+                 (eq_attr \"subtype\" \"alignaddr\"))))\n+  \"n7_slot1, nothing*11\")\n \n-(define_insn_reservation \"n7_vis_move_v3pipe\" 11\n+;; A couple of VIS instructions feature very low latencies in the M7.\n+\n+(define_insn_reservation \"n7_single_vis\" 1\n   (and (eq_attr \"cpu\" \"niagara7\")\n-    (and (eq_attr \"type\" \"vismv\")\n-         (eq_attr \"v3pipe\" \"true\")))\n+       (eq_attr \"type\" \"vismv\")\n+       (eq_attr \"subtype\" \"movxtod\"))\n   \"n7_slot1\")\n \n-(define_insn_reservation \"n7_vis_move_11cycle\" 11\n+(define_insn_reservation \"n7_double_vis\" 2\n   (and (eq_attr \"cpu\" \"niagara7\")\n-    (and (eq_attr \"type\" \"vismv\")\n-         (eq_attr \"v3pipe\" \"false\")))\n-  \"n7_slot1, nothing*10\")\n+       (eq_attr \"type\" \"vismv\")\n+       (eq_attr \"subtype\" \"movdtox\"))\n+  \"n7_slot1, nothing\")\n \n-(define_insn_reservation \"n7_vis_logical_v3pipe\" 11\n-  (and (eq_attr \"cpu\" \"niagara7\")\n-    (and (eq_attr \"type\" \"visl,pdistn\")\n-         (eq_attr \"v3pipe\" \"true\")))\n-  \"n7_slot1, nothing*2\")\n+;; Reading and writing to the gsr register takes a high number of\n+;; cycles that is not documented in the PRM.  Let's use the same value\n+;; than the M8.\n \n-(define_insn_reservation \"n7_vis_logical_11cycle\" 11\n+(define_insn_reservation \"n7_gsr_reg\" 70\n   (and (eq_attr \"cpu\" \"niagara7\")\n-    (and (eq_attr \"type\" \"visl\")\n-      (eq_attr \"v3pipe\" \"false\")))\n-  \"n7_slot1, nothing*10\")\n-\n-(define_bypass 3 \"*_v3pipe\" \"*_v3pipe\")\n+       (eq_attr \"type\" \"gsr\")\n+       (eq_attr \"subtype\" \"reg\"))\n+  \"n7_slot1, nothing*70\")"}, {"sha": "3f8526dc3efef4d1e70ecc4a998979af58069273", "filename": "gcc/config/sparc/predicates.md", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcc3c3f1ca89628f02802fda20f2232b9deef5f9/gcc%2Fconfig%2Fsparc%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcc3c3f1ca89628f02802fda20f2232b9deef5f9/gcc%2Fconfig%2Fsparc%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fpredicates.md?ref=bcc3c3f1ca89628f02802fda20f2232b9deef5f9", "patch": "@@ -328,6 +328,33 @@\n        (and (match_code \"const_int\")\n             (match_test \"SPARC_SIMM5_P (INTVAL (op))\"))))\n \n+;; Return true if OP is a constant in the range 0..7.  This is an\n+;; acceptable second operand for dictunpack instructions setting a\n+;; V8QI mode in the destination register.\n+(define_predicate \"imm5_operand_dictunpack8\"\n+  (and (match_code \"const_int\")\n+       (match_test \"(INTVAL (op) >= 0 && INTVAL (op) < 8)\")))\n+\n+;; Return true if OP is a constant in the range 7..15.  This is an\n+;; acceptable second operand for dictunpack instructions setting a\n+;; V4HI mode in the destination register.\n+(define_predicate \"imm5_operand_dictunpack16\"\n+  (and (match_code \"const_int\")\n+       (match_test \"(INTVAL (op) >= 8 && INTVAL (op) < 16)\")))\n+\n+;; Return true if OP is a constant in the range 15..31.  This is an\n+;; acceptable second operand for dictunpack instructions setting a\n+;; V2SI mode in the destination register.\n+(define_predicate \"imm5_operand_dictunpack32\"\n+  (and (match_code \"const_int\")\n+       (match_test \"(INTVAL (op) >= 16 && INTVAL (op) < 32)\")))\n+\n+;; Return true if OP is a constant that is representable by a 2-bit\n+;; unsigned field.  This is an acceptable third operand for\n+;; fpcmp*shl instructions.\n+(define_predicate \"imm2_operand\"\n+  (and (match_code \"const_int\")\n+       (match_test \"SPARC_IMM2_P (INTVAL (op))\")))\n \n ;; Predicates for miscellaneous instructions.\n "}, {"sha": "b8177c0b692f37e71e81afec02c910788f9510e4", "filename": "gcc/config/sparc/sol2.h", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcc3c3f1ca89628f02802fda20f2232b9deef5f9/gcc%2Fconfig%2Fsparc%2Fsol2.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcc3c3f1ca89628f02802fda20f2232b9deef5f9/gcc%2Fconfig%2Fsparc%2Fsol2.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsol2.h?ref=bcc3c3f1ca89628f02802fda20f2232b9deef5f9", "patch": "@@ -174,13 +174,22 @@ along with GCC; see the file COPYING3.  If not see\n #define ASM_CPU64_DEFAULT_SPEC AS_SPARC64_FLAG AS_NIAGARA7_FLAG\n #endif\n \n+#if TARGET_CPU_DEFAULT == TARGET_CPU_m8\n+#undef CPP_CPU64_DEFAULT_SPEC\n+#define CPP_CPU64_DEFAULT_SPEC \"\"\n+#undef ASM_CPU32_DEFAULT_SPEC\n+#define ASM_CPU32_DEFAULT_SPEC AS_SPARC32_FLAG AS_M8_FLAG\n+#undef ASM_CPU64_DEFAULT_SPEC\n+#define ASM_CPU64_DEFAULT_SPEC AS_SPARC64_FLAG AS_M8_FLAG\n+#endif\n+\n #undef CPP_CPU_SPEC\n #define CPP_CPU_SPEC \"\\\n %{mcpu=sparclet|mcpu=tsc701:-D__sparclet__} \\\n %{mcpu=sparclite|mcpu-f930|mcpu=f934:-D__sparclite__} \\\n %{mcpu=v8:\" DEF_ARCH32_SPEC(\"-D__sparcv8\") \"} \\\n %{mcpu=supersparc:-D__supersparc__ \" DEF_ARCH32_SPEC(\"-D__sparcv8\") \"} \\\n-%{mcpu=v9|mcpu=ultrasparc|mcpu=ultrasparc3|mcpu=niagara|mcpu=niagara2|mcpu=niagara3|mcpu=niagara4|mcpu=niagara7:\" DEF_ARCH32_SPEC(\"-D__sparcv8\") \"} \\\n+%{mcpu=v9|mcpu=ultrasparc|mcpu=ultrasparc3|mcpu=niagara|mcpu=niagara2|mcpu=niagara3|mcpu=niagara4|mcpu=niagara7|mcpu=m8:\" DEF_ARCH32_SPEC(\"-D__sparcv8\") \"} \\\n %{!mcpu*:%(cpp_cpu_default)} \\\n \"\n \n@@ -290,7 +299,8 @@ extern const char *host_detect_local_cpu (int argc, const char **argv);\n %{mcpu=niagara3:\" DEF_ARCH32_SPEC(\"-xarch=v8plus\" AS_NIAGARA3_FLAG) DEF_ARCH64_SPEC(\"-xarch=v9\" AS_NIAGARA3_FLAG) \"} \\\n %{mcpu=niagara4:\" DEF_ARCH32_SPEC(AS_SPARC32_FLAG AS_NIAGARA4_FLAG) DEF_ARCH64_SPEC(AS_SPARC64_FLAG AS_NIAGARA4_FLAG) \"} \\\n %{mcpu=niagara7:\" DEF_ARCH32_SPEC(AS_SPARC32_FLAG AS_NIAGARA7_FLAG) DEF_ARCH64_SPEC(AS_SPARC64_FLAG AS_NIAGARA7_FLAG) \"} \\\n-%{!mcpu=niagara7:%{!mcpu=niagara4:%{!mcpu=niagara3:%{!mcpu=niagara2:%{!mcpu=niagara:%{!mcpu=ultrasparc3:%{!mcpu=ultrasparc:%{!mcpu=v9:%{mcpu*:\" DEF_ARCH32_SPEC(\"-xarch=v8\") DEF_ARCH64_SPEC(\"-xarch=v9\") \"}}}}}}}}} \\\n+%{mcpu=m8:\" DEF_ARCH32_SPEC(AS_SPARC32_FLAG AS_M8_FLAG) DEF_ARCH64_SPEC(AS_SPARC64_FLAG AS_M8_FLAG) \"} \\\n+%{!mcpu=m8:%{!mcpu=niagara7:%{!mcpu=niagara4:%{!mcpu=niagara3:%{!mcpu=niagara2:%{!mcpu=niagara:%{!mcpu=ultrasparc3:%{!mcpu=ultrasparc:%{!mcpu=v9:%{mcpu*:\" DEF_ARCH32_SPEC(\"-xarch=v8\") DEF_ARCH64_SPEC(\"-xarch=v9\") \"}}}}}}}}}} \\\n %{!mcpu*:%(asm_cpu_default)} \\\n \"\n "}, {"sha": "4aacfff05ff7cb4bd06dd3f0467a62d7d60bb7c6", "filename": "gcc/config/sparc/sparc-c.c", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcc3c3f1ca89628f02802fda20f2232b9deef5f9/gcc%2Fconfig%2Fsparc%2Fsparc-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcc3c3f1ca89628f02802fda20f2232b9deef5f9/gcc%2Fconfig%2Fsparc%2Fsparc-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc-c.c?ref=bcc3c3f1ca89628f02802fda20f2232b9deef5f9", "patch": "@@ -40,7 +40,12 @@ sparc_target_macros (void)\n       cpp_assert (parse_in, \"machine=sparc\");\n     }\n \n-  if (TARGET_VIS4)\n+  if (TARGET_VIS4B)\n+    {\n+      cpp_define (parse_in, \"__VIS__=0x410\");\n+      cpp_define (parse_in, \"__VIS=0x410\");\n+    }\n+  else if (TARGET_VIS4)\n     {\n       cpp_define (parse_in, \"__VIS__=0x400\");\n       cpp_define (parse_in, \"__VIS=0x400\");"}, {"sha": "581e86e49d1c5d6f6b9492f4a46fd8deef3af445", "filename": "gcc/config/sparc/sparc-opts.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcc3c3f1ca89628f02802fda20f2232b9deef5f9/gcc%2Fconfig%2Fsparc%2Fsparc-opts.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcc3c3f1ca89628f02802fda20f2232b9deef5f9/gcc%2Fconfig%2Fsparc%2Fsparc-opts.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc-opts.h?ref=bcc3c3f1ca89628f02802fda20f2232b9deef5f9", "patch": "@@ -46,6 +46,7 @@ enum processor_type {\n   PROCESSOR_NIAGARA3,\n   PROCESSOR_NIAGARA4,\n   PROCESSOR_NIAGARA7,\n+  PROCESSOR_M8,\n   PROCESSOR_NATIVE\n };\n "}, {"sha": "9f9a29ac4d2f5fc6676455956655bbab346970db", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 298, "deletions": 14, "changes": 312, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcc3c3f1ca89628f02802fda20f2232b9deef5f9/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcc3c3f1ca89628f02802fda20f2232b9deef5f9/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=bcc3c3f1ca89628f02802fda20f2232b9deef5f9", "patch": "@@ -448,6 +448,30 @@ struct processor_costs niagara7_costs = {\n   0, /* shift penalty */\n };\n \n+static const\n+struct processor_costs m8_costs = {\n+  COSTS_N_INSNS (3), /* int load */\n+  COSTS_N_INSNS (3), /* int signed load */\n+  COSTS_N_INSNS (3), /* int zeroed load */\n+  COSTS_N_INSNS (3), /* float load */\n+  COSTS_N_INSNS (9), /* fmov, fneg, fabs */\n+  COSTS_N_INSNS (9), /* fadd, fsub */\n+  COSTS_N_INSNS (9), /* fcmp */\n+  COSTS_N_INSNS (9), /* fmov, fmovr */\n+  COSTS_N_INSNS (9), /* fmul */\n+  COSTS_N_INSNS (26), /* fdivs */\n+  COSTS_N_INSNS (30), /* fdivd */\n+  COSTS_N_INSNS (33), /* fsqrts */\n+  COSTS_N_INSNS (41), /* fsqrtd */\n+  COSTS_N_INSNS (12), /* imul */\n+  COSTS_N_INSNS (10), /* imulX */\n+  0, /* imul bit factor */\n+  COSTS_N_INSNS (57), /* udiv/sdiv */\n+  COSTS_N_INSNS (30), /* udivx/sdivx */\n+  COSTS_N_INSNS (1), /* movcc/movr */\n+  0, /* shift penalty */\n+};\n+\n static const struct processor_costs *sparc_costs = &cypress_costs;\n \n #ifdef HAVE_AS_RELAX_OPTION\n@@ -1222,6 +1246,8 @@ dump_target_flag_bits (const int flags)\n     fprintf (stderr, \"VIS3 \");\n   if (flags & MASK_VIS4)\n     fprintf (stderr, \"VIS4 \");\n+  if (flags & MASK_VIS4B)\n+    fprintf (stderr, \"VIS4B \");\n   if (flags & MASK_CBCOND)\n     fprintf (stderr, \"CBCOND \");\n   if (flags & MASK_DEPRECATED_V8_INSNS)\n@@ -1286,6 +1312,7 @@ sparc_option_override (void)\n     { TARGET_CPU_niagara3, PROCESSOR_NIAGARA3 },\n     { TARGET_CPU_niagara4, PROCESSOR_NIAGARA4 },\n     { TARGET_CPU_niagara7, PROCESSOR_NIAGARA7 },\n+    { TARGET_CPU_m8, PROCESSOR_M8 },\n     { -1, PROCESSOR_V7 }\n   };\n   const struct cpu_default *def;\n@@ -1337,7 +1364,11 @@ sparc_option_override (void)\n       MASK_V9|MASK_POPC|MASK_VIS3|MASK_FMAF|MASK_CBCOND },\n     /* UltraSPARC M7 */\n     { \"niagara7\",\tMASK_ISA,\n-      MASK_V9|MASK_POPC|MASK_VIS4|MASK_FMAF|MASK_CBCOND|MASK_SUBXC }\n+      MASK_V9|MASK_POPC|MASK_VIS4|MASK_FMAF|MASK_CBCOND|MASK_SUBXC },\n+    /* UltraSPARC M8 */\n+    { \"m8\",\t\tMASK_ISA,\n+      MASK_V9|MASK_POPC|MASK_VIS4|MASK_FMAF|MASK_CBCOND|MASK_SUBXC\n+      |MASK_VIS4B }\n   };\n   const struct cpu_table *cpu;\n   unsigned int i;\n@@ -1467,6 +1498,9 @@ sparc_option_override (void)\n #ifndef HAVE_AS_SPARC5_VIS4\n \t\t   & ~(MASK_VIS4 | MASK_SUBXC)\n #endif\n+#ifndef HAVE_AS_SPARC6\n+\t\t   & ~(MASK_VIS4B)\n+#endif\n #ifndef HAVE_AS_LEON\n \t\t   & ~(MASK_LEON | MASK_LEON3)\n #endif\n@@ -1485,11 +1519,15 @@ sparc_option_override (void)\n   if (TARGET_VIS4)\n     target_flags |= MASK_VIS3 | MASK_VIS2 | MASK_VIS;\n \n-  /* Don't allow -mvis, -mvis2, -mvis3, -mvis4 or -mfmaf if FPU is\n-     disabled.  */\n+  /* -mvis4b implies -mvis4, -mvis3, -mvis2 and -mvis */\n+  if (TARGET_VIS4B)\n+    target_flags |= MASK_VIS4 | MASK_VIS3 | MASK_VIS2 | MASK_VIS;\n+\n+  /* Don't allow -mvis, -mvis2, -mvis3, -mvis4, -mvis4b and -mfmaf if\n+     FPU is disabled.  */\n   if (! TARGET_FPU)\n     target_flags &= ~(MASK_VIS | MASK_VIS2 | MASK_VIS3 | MASK_VIS4\n-\t\t      | MASK_FMAF);\n+\t\t      | MASK_VIS4B | MASK_FMAF);\n \n   /* -mvis assumes UltraSPARC+, so we are sure v9 instructions\n      are available; -m64 also implies v9.  */\n@@ -1529,7 +1567,8 @@ sparc_option_override (void)\n \t  || sparc_cpu == PROCESSOR_NIAGARA3\n \t  || sparc_cpu == PROCESSOR_NIAGARA4)\n \talign_functions = 32;\n-      else if (sparc_cpu == PROCESSOR_NIAGARA7)\n+      else if (sparc_cpu == PROCESSOR_NIAGARA7\n+\t       || sparc_cpu == PROCESSOR_M8)\n \talign_functions = 64;\n     }\n \n@@ -1597,6 +1636,9 @@ sparc_option_override (void)\n     case PROCESSOR_NIAGARA7:\n       sparc_costs = &niagara7_costs;\n       break;\n+    case PROCESSOR_M8:\n+      sparc_costs = &m8_costs;\n+      break;\n     case PROCESSOR_NATIVE:\n       gcc_unreachable ();\n     };\n@@ -1659,13 +1701,14 @@ sparc_option_override (void)\n \t\t\t   || sparc_cpu == PROCESSOR_NIAGARA4)\n \t\t\t  ? 2\n \t\t\t  : (sparc_cpu == PROCESSOR_ULTRASPARC3\n-\t\t\t     ? 8 : (sparc_cpu == PROCESSOR_NIAGARA7\n+\t\t\t     ? 8 : ((sparc_cpu == PROCESSOR_NIAGARA7\n+\t\t\t\t     || sparc_cpu == PROCESSOR_M8)\n \t\t\t\t    ? 32 : 3))),\n \t\t\t global_options.x_param_values,\n \t\t\t global_options_set.x_param_values);\n \n-  /* For PARAM_L1_CACHE_LINE_SIZE we use the default 32 bytes (see\n-     params.def), so no maybe_set_param_value is needed.\n+  /* PARAM_L1_CACHE_LINE_SIZE is the size of the L1 cache line, in\n+     bytes.\n \n      The Oracle SPARC Architecture (previously the UltraSPARC\n      Architecture) specification states that when a PREFETCH[A]\n@@ -1681,6 +1724,11 @@ sparc_option_override (void)\n      L2 and L3, but only 32B are brought into the L1D$. (Assuming it\n      is a read_n prefetch, which is the only type which allocates to\n      the L1.)  */\n+  maybe_set_param_value (PARAM_L1_CACHE_LINE_SIZE,\n+\t\t\t (sparc_cpu == PROCESSOR_M8\n+\t\t\t  ? 64 : 32),\n+\t\t\t global_options.x_param_values,\n+\t\t\t global_options_set.x_param_values);\n \n   /* PARAM_L1_CACHE_SIZE is the size of the L1D$ (most SPARC chips use\n      Hardvard level-1 caches) in kilobytes.  Both UltraSPARC and\n@@ -1692,7 +1740,8 @@ sparc_option_override (void)\n \t\t\t   || sparc_cpu == PROCESSOR_NIAGARA2\n \t\t\t   || sparc_cpu == PROCESSOR_NIAGARA3\n \t\t\t   || sparc_cpu == PROCESSOR_NIAGARA4\n-\t\t\t   || sparc_cpu == PROCESSOR_NIAGARA7)\n+\t\t\t   || sparc_cpu == PROCESSOR_NIAGARA7\n+\t\t\t   || sparc_cpu == PROCESSOR_M8)\n \t\t\t  ? 16 : 64),\n \t\t\t global_options.x_param_values,\n \t\t\t global_options_set.x_param_values);\n@@ -1701,7 +1750,8 @@ sparc_option_override (void)\n   /* PARAM_L2_CACHE_SIZE is the size fo the L2 in kilobytes.  Note\n      that 512 is the default in params.def.  */\n   maybe_set_param_value (PARAM_L2_CACHE_SIZE,\n-\t\t\t (sparc_cpu == PROCESSOR_NIAGARA4\n+\t\t\t ((sparc_cpu == PROCESSOR_NIAGARA4\n+\t\t\t   || sparc_cpu == PROCESSOR_M8)\n \t\t\t  ? 128 : (sparc_cpu == PROCESSOR_NIAGARA7\n \t\t\t\t   ? 256 : 512)),\n \t\t\t global_options.x_param_values,\n@@ -9478,7 +9528,8 @@ sparc32_initialize_trampoline (rtx m_tramp, rtx fnaddr, rtx cxt)\n       && sparc_cpu != PROCESSOR_NIAGARA2\n       && sparc_cpu != PROCESSOR_NIAGARA3\n       && sparc_cpu != PROCESSOR_NIAGARA4\n-      && sparc_cpu != PROCESSOR_NIAGARA7)\n+      && sparc_cpu != PROCESSOR_NIAGARA7\n+      && sparc_cpu != PROCESSOR_M8)\n     emit_insn (gen_flushsi (validize_mem (adjust_address (m_tramp, SImode, 8))));\n \n   /* Call __enable_execute_stack after writing onto the stack to make sure\n@@ -9524,7 +9575,8 @@ sparc64_initialize_trampoline (rtx m_tramp, rtx fnaddr, rtx cxt)\n       && sparc_cpu != PROCESSOR_NIAGARA2\n       && sparc_cpu != PROCESSOR_NIAGARA3\n       && sparc_cpu != PROCESSOR_NIAGARA4\n-      && sparc_cpu != PROCESSOR_NIAGARA7)\n+      && sparc_cpu != PROCESSOR_NIAGARA7\n+      && sparc_cpu != PROCESSOR_M8)\n     emit_insn (gen_flushdi (validize_mem (adjust_address (m_tramp, DImode, 8))));\n \n   /* Call __enable_execute_stack after writing onto the stack to make sure\n@@ -9724,7 +9776,8 @@ sparc_use_sched_lookahead (void)\n       || sparc_cpu == PROCESSOR_NIAGARA3)\n     return 0;\n   if (sparc_cpu == PROCESSOR_NIAGARA4\n-      || sparc_cpu == PROCESSOR_NIAGARA7)\n+      || sparc_cpu == PROCESSOR_NIAGARA7\n+      || sparc_cpu == PROCESSOR_M8)\n     return 2;\n   if (sparc_cpu == PROCESSOR_ULTRASPARC\n       || sparc_cpu == PROCESSOR_ULTRASPARC3)\n@@ -9758,6 +9811,7 @@ sparc_issue_rate (void)\n       return 2;\n     case PROCESSOR_ULTRASPARC:\n     case PROCESSOR_ULTRASPARC3:\n+    case PROCESSOR_M8:\n       return 4;\n     }\n }\n@@ -10340,13 +10394,73 @@ enum sparc_builtins\n   SPARC_BUILTIN_FPSUBS8,\n   SPARC_BUILTIN_FPSUBUS8,\n   SPARC_BUILTIN_FPSUBUS16,\n+\n+  /* VIS 4.0B builtins.  */\n+\n+  /* Note that all the DICTUNPACK* entries should be kept\n+     contiguous.  */\n+  SPARC_BUILTIN_FIRST_DICTUNPACK,\n+  SPARC_BUILTIN_DICTUNPACK8 = SPARC_BUILTIN_FIRST_DICTUNPACK,\n+  SPARC_BUILTIN_DICTUNPACK16,\n+  SPARC_BUILTIN_DICTUNPACK32,\n+  SPARC_BUILTIN_LAST_DICTUNPACK = SPARC_BUILTIN_DICTUNPACK32,\n+\n+  /* Note that all the FPCMP*SHL entries should be kept\n+     contiguous.  */\n+  SPARC_BUILTIN_FIRST_FPCMPSHL,\n+  SPARC_BUILTIN_FPCMPLE8SHL = SPARC_BUILTIN_FIRST_FPCMPSHL,\n+  SPARC_BUILTIN_FPCMPGT8SHL,\n+  SPARC_BUILTIN_FPCMPEQ8SHL,\n+  SPARC_BUILTIN_FPCMPNE8SHL,\n+  SPARC_BUILTIN_FPCMPLE16SHL,\n+  SPARC_BUILTIN_FPCMPGT16SHL,\n+  SPARC_BUILTIN_FPCMPEQ16SHL,\n+  SPARC_BUILTIN_FPCMPNE16SHL,\n+  SPARC_BUILTIN_FPCMPLE32SHL,\n+  SPARC_BUILTIN_FPCMPGT32SHL,\n+  SPARC_BUILTIN_FPCMPEQ32SHL,\n+  SPARC_BUILTIN_FPCMPNE32SHL,\n+  SPARC_BUILTIN_FPCMPULE8SHL,\n+  SPARC_BUILTIN_FPCMPUGT8SHL,\n+  SPARC_BUILTIN_FPCMPULE16SHL,\n+  SPARC_BUILTIN_FPCMPUGT16SHL,\n+  SPARC_BUILTIN_FPCMPULE32SHL,\n+  SPARC_BUILTIN_FPCMPUGT32SHL,\n+  SPARC_BUILTIN_FPCMPDE8SHL,\n+  SPARC_BUILTIN_FPCMPDE16SHL,\n+  SPARC_BUILTIN_FPCMPDE32SHL,\n+  SPARC_BUILTIN_FPCMPUR8SHL,\n+  SPARC_BUILTIN_FPCMPUR16SHL,\n+  SPARC_BUILTIN_FPCMPUR32SHL,\n+  SPARC_BUILTIN_LAST_FPCMPSHL = SPARC_BUILTIN_FPCMPUR32SHL,\n   \n   SPARC_BUILTIN_MAX\n };\n \n static GTY (()) tree sparc_builtins[(int) SPARC_BUILTIN_MAX];\n static enum insn_code sparc_builtins_icode[(int) SPARC_BUILTIN_MAX];\n \n+/* Return true if OPVAL can be used for operand OPNUM of instruction ICODE.\n+   The instruction should require a constant operand of some sort.  The\n+   function prints an error if OPVAL is not valid.  */\n+\n+static int\n+check_constant_argument (enum insn_code icode, int opnum, rtx opval)\n+{\n+  if (GET_CODE (opval) != CONST_INT)\n+    {\n+      error (\"%qs expects a constant argument\", insn_data[icode].name);\n+      return false;\n+    }\n+\n+  if (!(*insn_data[icode].operand[opnum].predicate) (opval, VOIDmode))\n+    {\n+      error (\"constant argument out of range for %qs\", insn_data[icode].name);\n+      return false;\n+    }\n+  return true;\n+}\n+\n /* Add a SPARC builtin function with NAME, ICODE, CODE and TYPE.  Return the\n    function decl or NULL_TREE if the builtin was not added.  */\n \n@@ -10440,6 +10554,12 @@ sparc_vis_init_builtins (void)\n \t\t\t\t\t\t      v8qi, v8qi, 0);\n   tree si_ftype_v8qi_v8qi = build_function_type_list (intSI_type_node,\n \t\t\t\t\t\t      v8qi, v8qi, 0);\n+  tree v8qi_ftype_df_si = build_function_type_list (v8qi, double_type_node,\n+\t\t\t\t\t\t    intSI_type_node, 0);\n+  tree v4hi_ftype_df_si = build_function_type_list (v4hi, double_type_node,\n+\t\t\t\t\t\t    intSI_type_node, 0);\n+  tree v2si_ftype_df_si = build_function_type_list (v2si, double_type_node,\n+\t\t\t\t\t\t    intDI_type_node, 0);\n   tree di_ftype_di_di = build_function_type_list (intDI_type_node,\n \t\t\t\t\t\t  intDI_type_node,\n \t\t\t\t\t\t  intDI_type_node, 0);\n@@ -10894,6 +11014,156 @@ sparc_vis_init_builtins (void)\n       def_builtin_const (\"__builtin_vis_fpsubus16\", CODE_FOR_ussubv4hi3,\n \t\t\t SPARC_BUILTIN_FPSUBUS16, v4hi_ftype_v4hi_v4hi);\n     }\n+\n+  if (TARGET_VIS4B)\n+    {\n+      def_builtin_const (\"__builtin_vis_dictunpack8\", CODE_FOR_dictunpack8,\n+\t\t\t SPARC_BUILTIN_DICTUNPACK8, v8qi_ftype_df_si);\n+      def_builtin_const (\"__builtin_vis_dictunpack16\", CODE_FOR_dictunpack16,\n+\t\t\t SPARC_BUILTIN_DICTUNPACK16, v4hi_ftype_df_si);\n+      def_builtin_const (\"__builtin_vis_dictunpack32\", CODE_FOR_dictunpack32,\n+\t\t\t SPARC_BUILTIN_DICTUNPACK32, v2si_ftype_df_si);\n+\n+      if (TARGET_ARCH64)\n+\t{\n+\t  tree di_ftype_v8qi_v8qi_si = build_function_type_list (intDI_type_node,\n+\t\t\t\t\t\t\t\t v8qi, v8qi,\n+\t\t\t\t\t\t\t\t intSI_type_node, 0);\n+\t  tree di_ftype_v4hi_v4hi_si = build_function_type_list (intDI_type_node,\n+\t\t\t\t\t\t\t\t v4hi, v4hi,\n+\t\t\t\t\t\t\t\t intSI_type_node, 0);\n+\t  tree di_ftype_v2si_v2si_si = build_function_type_list (intDI_type_node,\n+\t\t\t\t\t\t\t\t v2si, v2si,\n+\t\t\t\t\t\t\t\t intSI_type_node, 0);\n+\t  \n+\t  def_builtin_const (\"__builtin_vis_fpcmple8shl\", CODE_FOR_fpcmple8dishl,\n+\t\t\t     SPARC_BUILTIN_FPCMPLE8SHL, di_ftype_v8qi_v8qi_si);\n+\t  def_builtin_const (\"__builtin_vis_fpcmpgt8shl\", CODE_FOR_fpcmpgt8dishl,\n+\t\t\t     SPARC_BUILTIN_FPCMPGT8SHL, di_ftype_v8qi_v8qi_si);\n+\t  def_builtin_const (\"__builtin_vis_fpcmpeq8shl\", CODE_FOR_fpcmpeq8dishl,\n+\t\t\t     SPARC_BUILTIN_FPCMPEQ8SHL, di_ftype_v8qi_v8qi_si);\n+\t  def_builtin_const (\"__builtin_vis_fpcmpne8shl\", CODE_FOR_fpcmpne8dishl,\n+\t\t\t     SPARC_BUILTIN_FPCMPNE8SHL, di_ftype_v8qi_v8qi_si);\n+\n+\t  def_builtin_const (\"__builtin_vis_fpcmple16shl\", CODE_FOR_fpcmple16dishl,\n+\t\t\t     SPARC_BUILTIN_FPCMPLE16SHL, di_ftype_v4hi_v4hi_si);\n+\t  def_builtin_const (\"__builtin_vis_fpcmpgt16shl\", CODE_FOR_fpcmpgt16dishl,\n+\t\t\t     SPARC_BUILTIN_FPCMPGT16SHL, di_ftype_v4hi_v4hi_si);\n+\t  def_builtin_const (\"__builtin_vis_fpcmpeq16shl\", CODE_FOR_fpcmpeq16dishl,\n+\t\t\t     SPARC_BUILTIN_FPCMPEQ16SHL, di_ftype_v4hi_v4hi_si);\n+\t  def_builtin_const (\"__builtin_vis_fpcmpne16shl\", CODE_FOR_fpcmpne16dishl,\n+\t\t\t     SPARC_BUILTIN_FPCMPNE16SHL, di_ftype_v4hi_v4hi_si);\n+\n+\t  def_builtin_const (\"__builtin_vis_fpcmple32shl\", CODE_FOR_fpcmple32dishl,\n+\t\t\t     SPARC_BUILTIN_FPCMPLE32SHL, di_ftype_v2si_v2si_si);\n+\t  def_builtin_const (\"__builtin_vis_fpcmpgt32shl\", CODE_FOR_fpcmpgt32dishl,\n+\t\t\t     SPARC_BUILTIN_FPCMPGT32SHL, di_ftype_v2si_v2si_si);\n+\t  def_builtin_const (\"__builtin_vis_fpcmpeq32shl\", CODE_FOR_fpcmpeq32dishl,\n+\t\t\t     SPARC_BUILTIN_FPCMPEQ32SHL, di_ftype_v2si_v2si_si);\n+\t  def_builtin_const (\"__builtin_vis_fpcmpne32shl\", CODE_FOR_fpcmpne32dishl,\n+\t\t\t     SPARC_BUILTIN_FPCMPNE32SHL, di_ftype_v2si_v2si_si);\n+\n+\n+\t  def_builtin_const (\"__builtin_vis_fpcmpule8shl\", CODE_FOR_fpcmpule8dishl,\n+\t\t\t     SPARC_BUILTIN_FPCMPULE8SHL, di_ftype_v8qi_v8qi_si);\n+\t  def_builtin_const (\"__builtin_vis_fpcmpugt8shl\", CODE_FOR_fpcmpugt8dishl,\n+\t\t\t     SPARC_BUILTIN_FPCMPUGT8SHL, di_ftype_v8qi_v8qi_si);\n+\n+\t  def_builtin_const (\"__builtin_vis_fpcmpule16shl\", CODE_FOR_fpcmpule16dishl,\n+\t\t\t     SPARC_BUILTIN_FPCMPULE16SHL, di_ftype_v4hi_v4hi_si);\n+\t  def_builtin_const (\"__builtin_vis_fpcmpugt16shl\", CODE_FOR_fpcmpugt16dishl,\n+\t\t\t     SPARC_BUILTIN_FPCMPUGT16SHL, di_ftype_v4hi_v4hi_si);\n+\n+\t  def_builtin_const (\"__builtin_vis_fpcmpule32shl\", CODE_FOR_fpcmpule32dishl,\n+\t\t\t     SPARC_BUILTIN_FPCMPULE32SHL, di_ftype_v2si_v2si_si);\n+\t  def_builtin_const (\"__builtin_vis_fpcmpugt32shl\", CODE_FOR_fpcmpugt32dishl,\n+\t\t\t     SPARC_BUILTIN_FPCMPUGT32SHL, di_ftype_v2si_v2si_si);\n+\n+\t  def_builtin_const (\"__builtin_vis_fpcmpde8shl\", CODE_FOR_fpcmpde8dishl,\n+\t\t\t     SPARC_BUILTIN_FPCMPDE8SHL, di_ftype_v8qi_v8qi_si);\n+\t  def_builtin_const (\"__builtin_vis_fpcmpde16shl\", CODE_FOR_fpcmpde16dishl,\n+\t\t\t     SPARC_BUILTIN_FPCMPDE16SHL, di_ftype_v4hi_v4hi_si);\n+\t  def_builtin_const (\"__builtin_vis_fpcmpde32shl\", CODE_FOR_fpcmpde32dishl,\n+\t\t\t     SPARC_BUILTIN_FPCMPDE32SHL, di_ftype_v2si_v2si_si);\n+\n+\t  def_builtin_const (\"__builtin_vis_fpcmpur8shl\", CODE_FOR_fpcmpur8dishl,\n+\t\t\t     SPARC_BUILTIN_FPCMPUR8SHL, di_ftype_v8qi_v8qi_si);\n+\t  def_builtin_const (\"__builtin_vis_fpcmpur16shl\", CODE_FOR_fpcmpur16dishl,\n+\t\t\t     SPARC_BUILTIN_FPCMPUR16SHL, di_ftype_v4hi_v4hi_si);\n+\t  def_builtin_const (\"__builtin_vis_fpcmpur32shl\", CODE_FOR_fpcmpur32dishl,\n+\t\t\t     SPARC_BUILTIN_FPCMPUR32SHL, di_ftype_v2si_v2si_si);\n+\n+\t}\n+      else\n+\t{\n+\t  tree si_ftype_v8qi_v8qi_si = build_function_type_list (intSI_type_node,\n+\t\t\t\t\t\t\t\t v8qi, v8qi,\n+\t\t\t\t\t\t\t\t intSI_type_node, 0);\n+\t  tree si_ftype_v4hi_v4hi_si = build_function_type_list (intSI_type_node,\n+\t\t\t\t\t\t\t\t v4hi, v4hi,\n+\t\t\t\t\t\t\t\t intSI_type_node, 0);\n+\t  tree si_ftype_v2si_v2si_si = build_function_type_list (intSI_type_node,\n+\t\t\t\t\t\t\t\t v2si, v2si,\n+\t\t\t\t\t\t\t\t intSI_type_node, 0);\n+\t  \n+\t  def_builtin_const (\"__builtin_vis_fpcmple8shl\", CODE_FOR_fpcmple8sishl,\n+\t\t\t     SPARC_BUILTIN_FPCMPLE8SHL, si_ftype_v8qi_v8qi_si);\n+\t  def_builtin_const (\"__builtin_vis_fpcmpgt8shl\", CODE_FOR_fpcmpgt8sishl,\n+\t\t\t     SPARC_BUILTIN_FPCMPGT8SHL, si_ftype_v8qi_v8qi_si);\n+\t  def_builtin_const (\"__builtin_vis_fpcmpeq8shl\", CODE_FOR_fpcmpeq8sishl,\n+\t\t\t     SPARC_BUILTIN_FPCMPEQ8SHL, si_ftype_v8qi_v8qi_si);\n+\t  def_builtin_const (\"__builtin_vis_fpcmpne8shl\", CODE_FOR_fpcmpne8sishl,\n+\t\t\t     SPARC_BUILTIN_FPCMPNE8SHL, si_ftype_v8qi_v8qi_si);\n+\n+\t  def_builtin_const (\"__builtin_vis_fpcmple16shl\", CODE_FOR_fpcmple16sishl,\n+\t\t\t     SPARC_BUILTIN_FPCMPLE16SHL, si_ftype_v4hi_v4hi_si);\n+\t  def_builtin_const (\"__builtin_vis_fpcmpgt16shl\", CODE_FOR_fpcmpgt16sishl,\n+\t\t\t     SPARC_BUILTIN_FPCMPGT16SHL, si_ftype_v4hi_v4hi_si);\n+\t  def_builtin_const (\"__builtin_vis_fpcmpeq16shl\", CODE_FOR_fpcmpeq16sishl,\n+\t\t\t     SPARC_BUILTIN_FPCMPEQ16SHL, si_ftype_v4hi_v4hi_si);\n+\t  def_builtin_const (\"__builtin_vis_fpcmpne16shl\", CODE_FOR_fpcmpne16sishl,\n+\t\t\t     SPARC_BUILTIN_FPCMPNE16SHL, si_ftype_v4hi_v4hi_si);\n+\n+\t  def_builtin_const (\"__builtin_vis_fpcmple32shl\", CODE_FOR_fpcmple32sishl,\n+\t\t\t     SPARC_BUILTIN_FPCMPLE32SHL, si_ftype_v2si_v2si_si);\n+\t  def_builtin_const (\"__builtin_vis_fpcmpgt32shl\", CODE_FOR_fpcmpgt32sishl,\n+\t\t\t     SPARC_BUILTIN_FPCMPGT32SHL, si_ftype_v2si_v2si_si);\n+\t  def_builtin_const (\"__builtin_vis_fpcmpeq32shl\", CODE_FOR_fpcmpeq32sishl,\n+\t\t\t     SPARC_BUILTIN_FPCMPEQ32SHL, si_ftype_v2si_v2si_si);\n+\t  def_builtin_const (\"__builtin_vis_fpcmpne32shl\", CODE_FOR_fpcmpne32sishl,\n+\t\t\t     SPARC_BUILTIN_FPCMPNE32SHL, si_ftype_v2si_v2si_si);\n+\n+\n+\t  def_builtin_const (\"__builtin_vis_fpcmpule8shl\", CODE_FOR_fpcmpule8sishl,\n+\t\t\t     SPARC_BUILTIN_FPCMPULE8SHL, si_ftype_v8qi_v8qi_si);\n+\t  def_builtin_const (\"__builtin_vis_fpcmpugt8shl\", CODE_FOR_fpcmpugt8sishl,\n+\t\t\t     SPARC_BUILTIN_FPCMPUGT8SHL, si_ftype_v8qi_v8qi_si);\n+\n+\t  def_builtin_const (\"__builtin_vis_fpcmpule16shl\", CODE_FOR_fpcmpule16sishl,\n+\t\t\t     SPARC_BUILTIN_FPCMPULE16SHL, si_ftype_v4hi_v4hi_si);\n+\t  def_builtin_const (\"__builtin_vis_fpcmpugt16shl\", CODE_FOR_fpcmpugt16sishl,\n+\t\t\t     SPARC_BUILTIN_FPCMPUGT16SHL, si_ftype_v4hi_v4hi_si);\n+\n+\t  def_builtin_const (\"__builtin_vis_fpcmpule32shl\", CODE_FOR_fpcmpule32sishl,\n+\t\t\t     SPARC_BUILTIN_FPCMPULE32SHL, si_ftype_v2si_v2si_si);\n+\t  def_builtin_const (\"__builtin_vis_fpcmpugt32shl\", CODE_FOR_fpcmpugt32sishl,\n+\t\t\t     SPARC_BUILTIN_FPCMPUGT32SHL, si_ftype_v2si_v2si_si);\n+\n+\t  def_builtin_const (\"__builtin_vis_fpcmpde8shl\", CODE_FOR_fpcmpde8sishl,\n+\t\t\t     SPARC_BUILTIN_FPCMPDE8SHL, si_ftype_v8qi_v8qi_si);\n+\t  def_builtin_const (\"__builtin_vis_fpcmpde16shl\", CODE_FOR_fpcmpde16sishl,\n+\t\t\t     SPARC_BUILTIN_FPCMPDE16SHL, si_ftype_v4hi_v4hi_si);\n+\t  def_builtin_const (\"__builtin_vis_fpcmpde32shl\", CODE_FOR_fpcmpde32sishl,\n+\t\t\t     SPARC_BUILTIN_FPCMPDE32SHL, si_ftype_v2si_v2si_si);\n+\n+\t  def_builtin_const (\"__builtin_vis_fpcmpur8shl\", CODE_FOR_fpcmpur8sishl,\n+\t\t\t     SPARC_BUILTIN_FPCMPUR8SHL, si_ftype_v8qi_v8qi_si);\n+\t  def_builtin_const (\"__builtin_vis_fpcmpur16shl\", CODE_FOR_fpcmpur16sishl,\n+\t\t\t     SPARC_BUILTIN_FPCMPUR16SHL, si_ftype_v4hi_v4hi_si);\n+\t  def_builtin_const (\"__builtin_vis_fpcmpur32shl\", CODE_FOR_fpcmpur32sishl,\n+\t\t\t     SPARC_BUILTIN_FPCMPUR32SHL, si_ftype_v2si_v2si_si);\n+\t}\n+    }\n }\n \n /* Implement TARGET_BUILTIN_DECL hook.  */\n@@ -10948,6 +11218,19 @@ sparc_expand_builtin (tree exp, rtx target,\n       insn_op = &insn_data[icode].operand[idx];\n       op[arg_count] = expand_normal (arg);\n \n+      /* Some of the builtins require constant arguments.  We check\n+\t for this here.  */\n+      if ((code >= SPARC_BUILTIN_FIRST_FPCMPSHL\n+\t   && code <= SPARC_BUILTIN_LAST_FPCMPSHL\n+\t   && arg_count == 3)\n+\t  || (code >= SPARC_BUILTIN_FIRST_DICTUNPACK\n+\t      && code <= SPARC_BUILTIN_LAST_DICTUNPACK\n+\t      && arg_count == 2))\n+\t{\n+\t  if (!check_constant_argument (icode, idx, op[arg_count]))\n+\t    return const0_rtx;\n+\t}\n+\n       if (code == SPARC_BUILTIN_LDFSR || code == SPARC_BUILTIN_STFSR)\n \t{\n \t  if (!address_operand (op[arg_count], SImode))\n@@ -11458,7 +11741,8 @@ sparc_register_move_cost (machine_mode mode ATTRIBUTE_UNUSED,\n \t  || sparc_cpu == PROCESSOR_NIAGARA2\n \t  || sparc_cpu == PROCESSOR_NIAGARA3\n \t  || sparc_cpu == PROCESSOR_NIAGARA4\n-\t  || sparc_cpu == PROCESSOR_NIAGARA7)\n+\t  || sparc_cpu == PROCESSOR_NIAGARA7\n+\t  || sparc_cpu == PROCESSOR_M8)\n \treturn 12;\n \n       return 6;"}, {"sha": "d7c617e06c3e055edffb2b35dac67991060b9e39", "filename": "gcc/config/sparc/sparc.h", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcc3c3f1ca89628f02802fda20f2232b9deef5f9/gcc%2Fconfig%2Fsparc%2Fsparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcc3c3f1ca89628f02802fda20f2232b9deef5f9/gcc%2Fconfig%2Fsparc%2Fsparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.h?ref=bcc3c3f1ca89628f02802fda20f2232b9deef5f9", "patch": "@@ -143,6 +143,7 @@ extern enum cmodel sparc_cmodel;\n #define TARGET_CPU_niagara3\t15\n #define TARGET_CPU_niagara4\t16\n #define TARGET_CPU_niagara7\t19\n+#define TARGET_CPU_m8\t\t20\n \n #if TARGET_CPU_DEFAULT == TARGET_CPU_v9 \\\n  || TARGET_CPU_DEFAULT == TARGET_CPU_ultrasparc \\\n@@ -151,7 +152,8 @@ extern enum cmodel sparc_cmodel;\n  || TARGET_CPU_DEFAULT == TARGET_CPU_niagara2 \\\n  || TARGET_CPU_DEFAULT == TARGET_CPU_niagara3 \\\n  || TARGET_CPU_DEFAULT == TARGET_CPU_niagara4 \\\n- || TARGET_CPU_DEFAULT == TARGET_CPU_niagara7\n+ || TARGET_CPU_DEFAULT == TARGET_CPU_niagara7 \\\n+ || TARGET_CPU_DEFAULT == TARGET_CPU_m8\n \n #define CPP_CPU32_DEFAULT_SPEC \"\"\n #define ASM_CPU32_DEFAULT_SPEC \"\"\n@@ -192,6 +194,10 @@ extern enum cmodel sparc_cmodel;\n #define CPP_CPU64_DEFAULT_SPEC \"-D__sparc_v9__\"\n #define ASM_CPU64_DEFAULT_SPEC AS_NIAGARA7_FLAG\n #endif\n+#if TARGET_CPU_DEFAULT == TARGET_CPU_m8\n+#define CPP_CPU64_DEFAULT_SPEC \"-D__sparc_v9__\"\n+#define ASM_CPU64_DEFAULT_SPEC AS_M8_FLAG\n+#endif\n \n #else\n \n@@ -295,6 +301,7 @@ extern enum cmodel sparc_cmodel;\n %{mcpu=niagara3:-D__sparc_v9__} \\\n %{mcpu=niagara4:-D__sparc_v9__} \\\n %{mcpu=niagara7:-D__sparc_v9__} \\\n+%{mcpu=m8:-D__sparc_v9__} \\\n %{!mcpu*:%(cpp_cpu_default)} \\\n \"\n #define CPP_ARCH32_SPEC \"\"\n@@ -347,6 +354,7 @@ extern enum cmodel sparc_cmodel;\n %{mcpu=niagara3:%{!mv8plus:-Av9\" AS_NIAGARA3_FLAG \"}} \\\n %{mcpu=niagara4:%{!mv8plus:\" AS_NIAGARA4_FLAG \"}} \\\n %{mcpu=niagara7:%{!mv8plus:\" AS_NIAGARA7_FLAG \"}} \\\n+%{mcpu=m8:%{!mv8plus:\" AS_M8_FLAG \"}} \\\n %{!mcpu*:%(asm_cpu_default)} \\\n \"\n \n@@ -1039,6 +1047,10 @@ extern char leaf_reg_remap[];\n /* Local macro to handle the two v9 classes of FP regs.  */\n #define FP_REG_CLASS_P(CLASS) ((CLASS) == FP_REGS || (CLASS) == EXTRA_FP_REGS)\n \n+/* Predicate for 2-bit and 5-bit unsigned constants.  */\n+#define SPARC_IMM2_P(X) (((unsigned HOST_WIDE_INT) (X) & ~0x3) == 0)\n+#define SPARC_IMM5_P(X) (((unsigned HOST_WIDE_INT) (X) & ~0x1F)\t== 0)\n+\n /* Predicates for 5-bit, 10-bit, 11-bit and 13-bit signed constants.  */\n #define SPARC_SIMM5_P(X)  ((unsigned HOST_WIDE_INT) (X) + 0x10 < 0x20)\n #define SPARC_SIMM10_P(X) ((unsigned HOST_WIDE_INT) (X) + 0x200 < 0x400)\n@@ -1799,6 +1811,12 @@ extern int sparc_indent_opcode;\n #define AS_NIAGARA7_FLAG AS_NIAGARA4_FLAG\n #endif\n \n+#ifdef HAVE_AS_SPARC6\n+#define AS_M8_FLAG \"-xarch=sparc6\"\n+#else\n+#define AS_M8_FLAG AS_NIAGARA7_FLAG\n+#endif\n+\n #ifdef HAVE_AS_LEON\n #define AS_LEON_FLAG \"-Aleon\"\n #define AS_LEONV7_FLAG \"-Aleon\""}, {"sha": "cac1bd9343f5ba2ef52ee90cb2ff1fba12be47aa", "filename": "gcc/config/sparc/sparc.md", "status": "modified", "additions": 273, "deletions": 91, "changes": 364, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcc3c3f1ca89628f02802fda20f2232b9deef5f9/gcc%2Fconfig%2Fsparc%2Fsparc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcc3c3f1ca89628f02802fda20f2232b9deef5f9/gcc%2Fconfig%2Fsparc%2Fsparc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.md?ref=bcc3c3f1ca89628f02802fda20f2232b9deef5f9", "patch": "@@ -94,6 +94,12 @@\n   UNSPEC_ADDV\n   UNSPEC_SUBV\n   UNSPEC_NEGV\n+\n+  UNSPEC_DICTUNPACK\n+  UNSPEC_FPCMPSHL\n+  UNSPEC_FPUCMPSHL\n+  UNSPEC_FPCMPDESHL\n+  UNSPEC_FPCMPURSHL\n ])\n \n (define_c_enum \"unspecv\" [\n@@ -238,7 +244,8 @@\n    niagara2,\n    niagara3,\n    niagara4,\n-   niagara7\"\n+   niagara7,\n+   m8\"\n   (const (symbol_ref \"sparc_cpu_attr\")))\n \n ;; Attribute for the instruction set.\n@@ -251,7 +258,7 @@\n \t (symbol_ref \"TARGET_SPARCLET\") (const_string \"sparclet\")]\n \t(const_string \"v7\"))))\n \n-(define_attr \"cpu_feature\" \"none,fpu,fpunotv9,v9,vis,vis3,vis4\"\n+(define_attr \"cpu_feature\" \"none,fpu,fpunotv9,v9,vis,vis3,vis4,vis4b\"\n   (const_string \"none\"))\n \n (define_attr \"lra\" \"disabled,enabled\"\n@@ -265,10 +272,92 @@\n          (eq_attr \"cpu_feature\" \"v9\") (symbol_ref \"TARGET_V9\")\n          (eq_attr \"cpu_feature\" \"vis\") (symbol_ref \"TARGET_VIS\")\n          (eq_attr \"cpu_feature\" \"vis3\") (symbol_ref \"TARGET_VIS3\")\n-         (eq_attr \"cpu_feature\" \"vis4\") (symbol_ref \"TARGET_VIS4\")]\n+         (eq_attr \"cpu_feature\" \"vis4\") (symbol_ref \"TARGET_VIS4\")\n+         (eq_attr \"cpu_feature\" \"vis4b\") (symbol_ref \"TARGET_VIS4B\")]\n         (const_int 0)))\n \n-;; Insn type.\n+;; The SPARC instructions used by the backend are organized into a\n+;; hierarchy using the insn attributes \"type\" and \"subtype\".\n+;;\n+;; The mnemonics used in the list below are the architectural names\n+;; used in the Oracle SPARC Architecture specs.  A / character\n+;; separates the type from the subtype where appropriate.  For\n+;; brevity, text enclosed in {} denotes alternatives, while text\n+;; enclosed in [] is optional.\n+;;\n+;; Please keep this list updated.  It is of great help for keeping the\n+;; correctness and coherence of the DFA schedulers.\n+;;\n+;; ialu:  <empty>\n+;; ialuX: ADD[X]C SUB[X]C\n+;; shift: SLL[X] SRL[X] SRA[X]\n+;; cmove: MOV{A,N,NE,E,G,LE,GE,L,GU,LEU,CC,CS,POS,NEG,VC,VS}\n+;;        MOVF{A,N,U,G,UG,L,UL,LG,NE,E,UE,GE,UGE,LE,ULE,O}\n+;;        MOVR{Z,LEZ,LZ,NZ,GZ,GEZ}\n+;; compare: ADDcc ADDCcc ANDcc ORcc SUBcc SUBCcc XORcc XNORcc\n+;; imul: MULX SMUL[cc] UMUL UMULXHI XMULX XMULXHI\n+;; idiv: UDIVX SDIVX\n+;; flush: FLUSH\n+;; load/regular: LD{UB,UH,UW} LDFSR\n+;; load/prefetch: PREFETCH\n+;; fpload: LDF LDDF LDQF\n+;; sload: LD{SB,SH,SW}\n+;; store: ST{B,H,W,X} STFSR\n+;; fpstore: STF STDF STQF\n+;; cbcond: CWB{NE,E,G,LE,GE,L,GU,LEU,CC,CS,POS,NEG,VC,VS}\n+;;         CXB{NE,E,G,LE,GE,L,GU,LEU,CC,CS,POS,NEG,VC,VS}\n+;; uncond_branch: BA BPA JMPL\n+;; branch: B{NE,E,G,LE,GE,L,GU,LEU,CC,CS,POS,NEG,VC,VS}\n+;;         BP{NE,E,G,LE,GE,L,GU,LEU,CC,CS,POS,NEG,VC,VS}\n+;;         FB{U,G,UG,L,UL,LG,NE,BE,UE,GE,UGE,LE,ULE,O}\n+;; call: CALL\n+;; return: RESTORE RETURN\n+;; fpmove: FABS{s,d,q} FMOV{s,d,q} FNEG{s,d,q}\n+;; fpcmove: FMOV{S,D,Q}{icc,xcc,fcc}\n+;; fpcrmove: FMOVR{s,d,q}{Z,LEZ,LZ,NZ,GZ,GEZ}\n+;; fp: FADD{s,d,q} FSUB{s,d,q} FHSUB{s,d} FNHADD{s,d} FNADD{s,d}\n+;;     FiTO{s,d,q} FsTO{i,x,d,q} FdTO{i,x,s,q} FxTO{d,s,q} FqTO{i,x,s,d}\n+;; fpcmp: FCMP{s,d,q} FCMPE{s,d,q}\n+;; fpmul: FMADD{s,d}  FMSUB{s,d} FMUL{s,d,q} FNMADD{s,d}\n+;;        FNMSUB{s,d} FNMUL{s,d} FNsMULd FsMULd\n+;;        FdMULq\n+;; array: ARRAY{8,16,32}\n+;; bmask: BMASK\n+;; edge: EDGE{8,16,32}[L]cc\n+;; edgen: EDGE{8,16,32}[L]n\n+;; fpdivs: FDIV{s,q}\n+;; fpsqrts: FSQRT{s,q}\n+;; fpdivd: FDIVd\n+;; fpsqrtd: FSQRTd\n+;; lzd: LZCNT\n+;; fga/addsub64: FP{ADD,SUB}64\n+;; fga/fpu: FCHKSM16 FEXPANd FMEAN16 FPMERGE\n+;;          FS{LL,RA,RL}{16,32}\n+;; fga/maxmin: FP{MAX,MIN}[U]{8,16,32}\n+;; fga/cmask: CMASK{8,16,32}\n+;; fga/other: BSHUFFLE FALIGNDATAg FP{ADD,SUB}[S]{8,16,32}\n+;;            FP{ADD,SUB}US{8,16} DICTUNPACK\n+;; gsr/reg: RDGSR WRGSR\n+;; gsr/alignaddr: ALIGNADDRESS[_LITTLE]\n+;; vismv/double:  FSRC2d\n+;; vismv/single:  MOVwTOs FSRC2s\n+;; vismv/movstouw: MOVsTOuw\n+;; vismv/movxtod: MOVxTOd\n+;; vismv/movdtox: MOVdTOx\n+;; visl/single: F{AND,NAND,NOR,OR,NOT1}s\n+;;              F{AND,OR}NOT{1,2}s\n+;;              FONEs F{ZERO,XNOR,XOR}s FNOT2s\n+;; visl/double: FONEd FZEROd FNOT1d F{OR,AND,XOR}d F{NOR,NAND,XNOR}d\n+;;              F{OR,AND}NOT1d F{OR,AND}NOT2d\n+;; viscmp: FPCMP{LE,GT,NE,EQ}{8,16,32} FPCMPU{LE,GT,NE,EQ}{8,16,32}\n+;;         FPCMP{LE,GT,EQ,NE}{8,16,32}SHL FPCMPU{LE,GT,EQ,NE}{8,16,32}SHL\n+;;         FPCMPDE{8,16,32}SHL FPCMPUR{8,16,32}SHL\n+;; fgm_pack: FPACKFIX FPACK{8,16,32}\n+;; fgm_mul: FMUL8SUx16 FMUL8ULx16 FMUL8x16 FMUL8x16AL\n+;;          FMUL8x16AU FMULD8SUx16 FMULD8ULx16\n+;; pdist: PDIST\n+;; pdistn: PDISTN\n+\n (define_attr \"type\"\n   \"ialu,compare,shift,\n    load,sload,store,\n@@ -281,12 +370,20 @@\n    fpcmp,\n    fpmul,fpdivs,fpdivd,\n    fpsqrts,fpsqrtd,\n-   fga,visl,vismv,fgm_pack,fgm_mul,pdist,pdistn,edge,edgen,gsr,array,\n+   fga,visl,vismv,viscmp,\n+   fgm_pack,fgm_mul,pdist,pdistn,edge,edgen,gsr,array,bmask,\n    cmove,\n    ialuX,\n    multi,savew,flushw,iflush,trap,lzd\"\n   (const_string \"ialu\"))\n \n+(define_attr \"subtype\"\n+  \"single,double,movstouw,movxtod,movdtox,\n+   addsub64,cmask,fpu,maxmin,other,\n+   reg,alignaddr,\n+   prefetch,regular\"\n+  (const_string \"single\"))\n+\n ;; True if branch/call has empty delay slot and will emit a nop in it\n (define_attr \"empty_delay_slot\" \"false,true\"\n   (symbol_ref \"(empty_delay_slot (insn)\n@@ -487,9 +584,6 @@\n \t   (const_string \"true\")\n \t] (const_string \"false\")))\n \n-;; True if the instruction executes in the V3 pipeline, in M7 and later processors.\n-(define_attr \"v3pipe\" \"false,true\" (const_string \"false\"))\n-\n (define_delay (eq_attr \"type\" \"call\")\n   [(eq_attr \"in_call_delay\" \"true\") (nil) (nil)])\n \n@@ -519,6 +613,7 @@\n (include \"niagara2.md\")\n (include \"niagara4.md\")\n (include \"niagara7.md\")\n+(include \"m8.md\")\n \n \n ;; Operand and operator predicates and constraints\n@@ -1507,6 +1602,7 @@\n    ldub\\t%1, %0\n    stb\\t%r1, %0\"\n   [(set_attr \"type\" \"*,load,store\")\n+   (set_attr \"subtype\" \"*,regular,*\")\n    (set_attr \"us3load_type\" \"*,3cycle,*\")])\n \n (define_expand \"movhi\"\n@@ -1529,6 +1625,7 @@\n    lduh\\t%1, %0\n    sth\\t%r1, %0\"\n   [(set_attr \"type\" \"*,*,load,store\")\n+   (set_attr \"subtype\" \"*,*,regular,*\")\n    (set_attr \"us3load_type\" \"*,*,3cycle,*\")])\n \n ;; We always work with constants here.\n@@ -1566,8 +1663,8 @@\n    fzeros\\t%0\n    fones\\t%0\"\n   [(set_attr \"type\" \"*,*,load,store,vismv,vismv,fpmove,fpload,fpstore,visl,visl\")\n-   (set_attr \"cpu_feature\" \"*,*,*,*,vis3,vis3,*,*,*,vis,vis\")\n-   (set_attr \"v3pipe\" \"*,*,*,*,true,true,*,*,*,true,true\")])\n+   (set_attr \"subtype\" \"*,*,regular,*,movstouw,single,*,*,*,single,single\")\n+   (set_attr \"cpu_feature\" \"*,*,*,*,vis3,vis3,*,*,*,vis,vis\")])\n \n (define_insn \"*movsi_lo_sum\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n@@ -1624,7 +1721,8 @@\n   return \"ld\\t[%1 + %2], %0\";\n #endif\n }\n-  [(set_attr \"type\" \"load\")])\n+  [(set_attr \"type\" \"load\")\n+   (set_attr \"subtype\" \"regular\")])\n \n (define_expand \"movsi_pic_label_ref\"\n   [(set (match_dup 3) (high:SI\n@@ -1733,11 +1831,12 @@\n    std\\t%1, %0\n    fzero\\t%0\n    fone\\t%0\"\n-  [(set_attr \"type\" \"store,*,load,store,load,store,*,*,fpload,fpstore,*,*,fpmove,*,*,*,fpload,fpstore,visl,visl\")\n+  [(set_attr \"type\" \"store,*,load,store,load,store,*,*,fpload,fpstore,*,*,fpmove,*,*,*,fpload,fpstore,visl,\n+visl\")\n+   (set_attr \"subtype\" \"*,*,regular,*,regular,*,*,*,*,*,*,*,*,*,*,*,*,*,double,double\")\n    (set_attr \"length\" \"*,2,*,*,*,*,2,2,*,*,2,2,*,2,2,2,*,*,*,*\")\n    (set_attr \"fptype\" \"*,*,*,*,*,*,*,*,*,*,*,*,double,*,*,*,*,*,double,double\")\n    (set_attr \"cpu_feature\" \"v9,*,*,*,*,*,*,*,fpu,fpu,fpu,fpu,v9,fpunotv9,vis3,vis3,fpu,fpu,vis,vis\")\n-   (set_attr \"v3pipe\" \"*,*,*,*,*,*,*,*,*,*,*,*,*,*,*,*,*,*,true,true\")\n    (set_attr \"lra\" \"*,*,disabled,disabled,*,*,*,*,*,*,*,*,*,*,*,*,*,*,*,*\")])\n \n (define_insn \"*movdi_insn_sp64\"\n@@ -1759,9 +1858,9 @@\n    fzero\\t%0\n    fone\\t%0\"\n   [(set_attr \"type\" \"*,*,load,store,vismv,vismv,fpmove,fpload,fpstore,visl,visl\")\n+   (set_attr \"subtype\" \"*,*,regular,*,movdtox,movxtod,*,*,*,double,double\")\n    (set_attr \"fptype\" \"*,*,*,*,*,*,double,*,*,double,double\")\n-   (set_attr \"cpu_feature\" \"*,*,*,*,vis3,vis3,*,*,*,vis,vis\")\n-   (set_attr \"v3pipe\" \"*,*,*,*,*,*,*,*,*,true,true\")])\n+   (set_attr \"cpu_feature\" \"*,*,*,*,vis3,vis3,*,*,*,vis,vis\")])\n \n (define_expand \"movdi_pic_label_ref\"\n   [(set (match_dup 3) (high:DI\n@@ -1847,7 +1946,8 @@\n   return \"ldx\\t[%1 + %2], %0\";\n #endif\n }\n-  [(set_attr \"type\" \"load\")])\n+  [(set_attr \"type\" \"load\")\n+   (set_attr \"subtype\" \"regular\")])\n \n (define_insn \"*sethi_di_medlow_embmedany_pic\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n@@ -2289,8 +2389,8 @@\n     }\n }\n   [(set_attr \"type\" \"visl,visl,fpmove,*,*,*,vismv,vismv,fpload,load,fpstore,store\")\n-   (set_attr \"cpu_feature\" \"vis,vis,fpu,*,*,*,vis3,vis3,fpu,*,fpu,*\")\n-   (set_attr \"v3pipe\" \"true,true,*,*,*,*,true,true,*,*,*,*\")])\n+   (set_attr \"subtype\" \"single,single,*,*,*,*,movstouw,single,*,regular,*,*\")\n+   (set_attr \"cpu_feature\" \"vis,vis,fpu,*,*,*,vis3,vis3,fpu,*,fpu,*\")])\n \n ;; The following 3 patterns build SFmode constants in integer registers.\n \n@@ -2362,10 +2462,10 @@\n   ldd\\t%1, %0\n   std\\t%1, %0\"\n   [(set_attr \"type\" \"store,*,visl,visl,fpmove,*,*,*,fpload,fpstore,load,store,*,*,*,load,store\")\n+   (set_attr \"subtype\" \"*,*,double,double,*,*,*,*,*,*,regular,*,*,*,*,regular,*\")\n    (set_attr \"length\" \"*,2,*,*,*,2,2,2,*,*,*,*,2,2,2,*,*\")\n    (set_attr \"fptype\" \"*,*,double,double,double,*,*,*,*,*,*,*,*,*,*,*,*\")\n    (set_attr \"cpu_feature\" \"v9,*,vis,vis,v9,fpunotv9,vis3,vis3,fpu,fpu,*,*,fpu,fpu,*,*,*\")\n-   (set_attr \"v3pipe\" \"*,*,true,true,*,*,*,*,*,*,*,*,*,*,*,*,*\")\n    (set_attr \"lra\" \"*,*,*,*,*,*,*,*,*,*,disabled,disabled,*,*,*,*,*\")])\n \n (define_insn \"*movdf_insn_sp64\"\n@@ -2387,10 +2487,10 @@\n   stx\\t%r1, %0\n   #\"\n   [(set_attr \"type\" \"visl,visl,fpmove,vismv,vismv,load,store,*,load,store,*\")\n+   (set_attr \"subtype\" \"double,double,*,movdtox,movxtod,regular,*,*,regular,*,*\")\n    (set_attr \"length\" \"*,*,*,*,*,*,*,*,*,*,2\")\n    (set_attr \"fptype\" \"double,double,double,double,double,*,*,*,*,*,*\")\n-   (set_attr \"cpu_feature\" \"vis,vis,fpu,vis3,vis3,fpu,fpu,*,*,*,*\")\n-   (set_attr \"v3pipe\" \"true,true,*,*,*,*,*,*,*,*,*\")])\n+   (set_attr \"cpu_feature\" \"vis,vis,fpu,vis3,vis3,fpu,fpu,*,*,*,*\")])\n \n ;; This pattern builds DFmode constants in integer registers.\n (define_split\n@@ -2916,6 +3016,7 @@\n   \"\"\n   \"lduh\\t%1, %0\"\n   [(set_attr \"type\" \"load\")\n+   (set_attr \"subtype\" \"regular\")\n    (set_attr \"us3load_type\" \"3cycle\")])\n \n (define_expand \"zero_extendqihi2\"\n@@ -2932,6 +3033,7 @@\n    and\\t%1, 0xff, %0\n    ldub\\t%1, %0\"\n   [(set_attr \"type\" \"*,load\")\n+   (set_attr \"subtype\" \"*,regular\")\n    (set_attr \"us3load_type\" \"*,3cycle\")])\n \n (define_expand \"zero_extendqisi2\"\n@@ -2948,6 +3050,7 @@\n    and\\t%1, 0xff, %0\n    ldub\\t%1, %0\"\n   [(set_attr \"type\" \"*,load\")\n+   (set_attr \"subtype\" \"*,regular\")\n    (set_attr \"us3load_type\" \"*,3cycle\")])\n \n (define_expand \"zero_extendqidi2\"\n@@ -2964,6 +3067,7 @@\n    and\\t%1, 0xff, %0\n    ldub\\t%1, %0\"\n   [(set_attr \"type\" \"*,load\")\n+   (set_attr \"subtype\" \"*,regular\")\n    (set_attr \"us3load_type\" \"*,3cycle\")])\n \n (define_expand \"zero_extendhidi2\"\n@@ -2995,6 +3099,7 @@\n   \"TARGET_ARCH64\"\n   \"lduh\\t%1, %0\"\n   [(set_attr \"type\" \"load\")\n+   (set_attr \"subtype\" \"regular\")\n    (set_attr \"us3load_type\" \"3cycle\")])\n \n ;; ??? Write truncdisi pattern using sra?\n@@ -3015,8 +3120,8 @@\n    lduw\\t%1, %0\n    movstouw\\t%1, %0\"\n   [(set_attr \"type\" \"shift,load,vismv\")\n-   (set_attr \"cpu_feature\" \"*,*,vis3\")\n-   (set_attr \"v3pipe\" \"*,*,true\")])\n+   (set_attr \"subtype\" \"*,regular,movstouw\")\n+   (set_attr \"cpu_feature\" \"*,*,vis3\")])\n \n (define_insn_and_split \"*zero_extendsidi2_insn_sp32\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n@@ -3331,8 +3436,7 @@\n   movstosw\\t%1, %0\"\n   [(set_attr \"type\" \"shift,sload,vismv\")\n    (set_attr \"us3load_type\" \"*,3cycle,*\")\n-   (set_attr \"cpu_feature\" \"*,*,vis3\")\n-   (set_attr \"v3pipe\" \"*,*,true\")])\n+   (set_attr \"cpu_feature\" \"*,*,vis3\")])\n \n \n ;; Special pattern for optimizing bit-field compares.  This is needed\n@@ -7356,7 +7460,8 @@\n   [(unspec_volatile [(match_operand:SI 0 \"memory_operand\" \"m\")] UNSPECV_LDFSR)]\n   \"TARGET_FPU\"\n   \"ld\\t%0, %%fsr\"\n-  [(set_attr \"type\" \"load\")])\n+  [(set_attr \"type\" \"load\")\n+   (set_attr \"subtype\" \"regular\")])\n \n (define_insn \"stfsr\"\n   [(set (match_operand:SI 0 \"memory_operand\" \"=m\")\n@@ -7720,7 +7825,8 @@\n   gcc_assert (locality >= 0 && locality < 4);\n   return prefetch_instr [read_or_write][locality == 0 ? 0 : 1];\n }\n-  [(set_attr \"type\" \"load\")])\n+  [(set_attr \"type\" \"load\")\n+   (set_attr \"subtype\" \"prefetch\")])\n \n (define_insn \"prefetch_32\"\n   [(prefetch (match_operand:SI 0 \"address_operand\" \"p\")\n@@ -7745,7 +7851,8 @@\n   gcc_assert (locality >= 0 && locality < 4);\n   return prefetch_instr [read_or_write][locality == 0 ? 0 : 1];\n }\n-  [(set_attr \"type\" \"load\")])\n+  [(set_attr \"type\" \"load\")\n+   (set_attr \"subtype\" \"prefetch\")])\n \n \n ;; Trap instructions.\n@@ -7966,7 +8073,8 @@\n \t\t   UNSPEC_TLSIE))]\n   \"TARGET_TLS && TARGET_ARCH32\"\n   \"ld\\\\t[%1 + %2], %0, %%tie_ld(%a3)\"\n-  [(set_attr \"type\" \"load\")])\n+  [(set_attr \"type\" \"load\")\n+   (set_attr \"subtype\" \"regular\")])\n \n (define_insn \"tie_ld64\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n@@ -7976,7 +8084,8 @@\n \t\t   UNSPEC_TLSIE))]\n   \"TARGET_TLS && TARGET_ARCH64\"\n   \"ldx\\\\t[%1 + %2], %0, %%tie_ldx(%a3)\"\n-  [(set_attr \"type\" \"load\")])\n+  [(set_attr \"type\" \"load\")\n+   (set_attr \"subtype\" \"regular\")])\n \n (define_insn \"tie_add32\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n@@ -8036,6 +8145,7 @@\n   \"TARGET_TLS && TARGET_ARCH32\"\n   \"ldub\\t[%1 + %2], %0, %%tldo_add(%3)\"\n   [(set_attr \"type\" \"load\")\n+   (set_attr \"subtype\" \"regular\")\n    (set_attr \"us3load_type\" \"3cycle\")])\n \n (define_insn \"*tldo_ldub1_sp32\"\n@@ -8048,6 +8158,7 @@\n   \"TARGET_TLS && TARGET_ARCH32\"\n   \"ldub\\t[%1 + %2], %0, %%tldo_add(%3)\"\n   [(set_attr \"type\" \"load\")\n+   (set_attr \"subtype\" \"regular\")\n    (set_attr \"us3load_type\" \"3cycle\")])\n \n (define_insn \"*tldo_ldub2_sp32\"\n@@ -8060,6 +8171,7 @@\n   \"TARGET_TLS && TARGET_ARCH32\"\n   \"ldub\\t[%1 + %2], %0, %%tldo_add(%3)\"\n   [(set_attr \"type\" \"load\")\n+   (set_attr \"subtype\" \"regular\")\n    (set_attr \"us3load_type\" \"3cycle\")])\n \n (define_insn \"*tldo_ldsb1_sp32\"\n@@ -8095,6 +8207,7 @@\n   \"TARGET_TLS && TARGET_ARCH64\"\n   \"ldub\\t[%1 + %2], %0, %%tldo_add(%3)\"\n   [(set_attr \"type\" \"load\")\n+   (set_attr \"subtype\" \"regular\")\n    (set_attr \"us3load_type\" \"3cycle\")])\n \n (define_insn \"*tldo_ldub1_sp64\"\n@@ -8107,6 +8220,7 @@\n   \"TARGET_TLS && TARGET_ARCH64\"\n   \"ldub\\t[%1 + %2], %0, %%tldo_add(%3)\"\n   [(set_attr \"type\" \"load\")\n+   (set_attr \"subtype\" \"regular\")\n    (set_attr \"us3load_type\" \"3cycle\")])\n \n (define_insn \"*tldo_ldub2_sp64\"\n@@ -8119,6 +8233,7 @@\n   \"TARGET_TLS && TARGET_ARCH64\"\n   \"ldub\\t[%1 + %2], %0, %%tldo_add(%3)\"\n   [(set_attr \"type\" \"load\")\n+   (set_attr \"subtype\" \"regular\")\n    (set_attr \"us3load_type\" \"3cycle\")])\n \n (define_insn \"*tldo_ldub3_sp64\"\n@@ -8131,6 +8246,7 @@\n   \"TARGET_TLS && TARGET_ARCH64\"\n   \"ldub\\t[%1 + %2], %0, %%tldo_add(%3)\"\n   [(set_attr \"type\" \"load\")\n+   (set_attr \"subtype\" \"regular\")\n    (set_attr \"us3load_type\" \"3cycle\")])\n \n (define_insn \"*tldo_ldsb1_sp64\"\n@@ -8178,6 +8294,7 @@\n   \"TARGET_TLS && TARGET_ARCH32\"\n   \"lduh\\t[%1 + %2], %0, %%tldo_add(%3)\"\n   [(set_attr \"type\" \"load\")\n+   (set_attr \"subtype\" \"regular\")\n    (set_attr \"us3load_type\" \"3cycle\")])\n \n (define_insn \"*tldo_lduh1_sp32\"\n@@ -8190,6 +8307,7 @@\n   \"TARGET_TLS && TARGET_ARCH32\"\n   \"lduh\\t[%1 + %2], %0, %%tldo_add(%3)\"\n   [(set_attr \"type\" \"load\")\n+   (set_attr \"subtype\" \"regular\")\n    (set_attr \"us3load_type\" \"3cycle\")])\n \n (define_insn \"*tldo_ldsh1_sp32\"\n@@ -8213,6 +8331,7 @@\n   \"TARGET_TLS && TARGET_ARCH64\"\n   \"lduh\\t[%1 + %2], %0, %%tldo_add(%3)\"\n   [(set_attr \"type\" \"load\")\n+   (set_attr \"subtype\" \"regular\")\n    (set_attr \"us3load_type\" \"3cycle\")])\n \n (define_insn \"*tldo_lduh1_sp64\"\n@@ -8225,6 +8344,7 @@\n   \"TARGET_TLS && TARGET_ARCH64\"\n   \"lduh\\t[%1 + %2], %0, %%tldo_add(%3)\"\n   [(set_attr \"type\" \"load\")\n+   (set_attr \"subtype\" \"regular\")\n    (set_attr \"us3load_type\" \"3cycle\")])\n \n (define_insn \"*tldo_lduh2_sp64\"\n@@ -8237,6 +8357,7 @@\n   \"TARGET_TLS && TARGET_ARCH64\"\n   \"lduh\\t[%1 + %2], %0, %%tldo_add(%3)\"\n   [(set_attr \"type\" \"load\")\n+   (set_attr \"subtype\" \"regular\")\n    (set_attr \"us3load_type\" \"3cycle\")])\n \n (define_insn \"*tldo_ldsh1_sp64\"\n@@ -8271,7 +8392,8 @@\n \t\t\t (match_operand:SI 1 \"register_operand\" \"r\"))))]\n   \"TARGET_TLS && TARGET_ARCH32\"\n   \"ld\\t[%1 + %2], %0, %%tldo_add(%3)\"\n-  [(set_attr \"type\" \"load\")])\n+  [(set_attr \"type\" \"load\")\n+   (set_attr \"subtype\" \"regular\")])\n \n (define_insn \"*tldo_lduw_sp64\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n@@ -8281,7 +8403,8 @@\n \t\t\t (match_operand:DI 1 \"register_operand\" \"r\"))))]\n   \"TARGET_TLS && TARGET_ARCH64\"\n   \"lduw\\t[%1 + %2], %0, %%tldo_add(%3)\"\n-  [(set_attr \"type\" \"load\")])\n+  [(set_attr \"type\" \"load\")\n+   (set_attr \"subtype\" \"regular\")])\n \n (define_insn \"*tldo_lduw1_sp64\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n@@ -8292,7 +8415,8 @@\n \t\t\t   (match_operand:DI 1 \"register_operand\" \"r\")))))]\n   \"TARGET_TLS && TARGET_ARCH64\"\n   \"lduw\\t[%1 + %2], %0, %%tldo_add(%3)\"\n-  [(set_attr \"type\" \"load\")])\n+  [(set_attr \"type\" \"load\")\n+   (set_attr \"subtype\" \"regular\")])\n \n (define_insn \"*tldo_ldsw1_sp64\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n@@ -8314,7 +8438,8 @@\n \t\t\t (match_operand:DI 1 \"register_operand\" \"r\"))))]\n   \"TARGET_TLS && TARGET_ARCH64\"\n   \"ldx\\t[%1 + %2], %0, %%tldo_add(%3)\"\n-  [(set_attr \"type\" \"load\")])\n+  [(set_attr \"type\" \"load\")\n+   (set_attr \"subtype\" \"regular\")])\n \n (define_insn \"*tldo_stb_sp32\"\n   [(set (mem:QI (plus:SI (unspec:SI [(match_operand:SI 2 \"register_operand\" \"r\")\n@@ -8519,8 +8644,8 @@\n   movstouw\\t%1, %0\n   movwtos\\t%1, %0\"\n   [(set_attr \"type\" \"visl,visl,vismv,fpload,fpstore,store,load,store,*,vismv,vismv\")\n-   (set_attr \"cpu_feature\" \"vis,vis,vis,*,*,*,*,*,*,vis3,vis3\")\n-   (set_attr \"v3pipe\" \"true,true,true,*,*,*,*,*,*,true,true\")])\n+   (set_attr \"subtype\" \"single,single,single,*,*,*,regular,*,*,movstouw,single\")\n+   (set_attr \"cpu_feature\" \"vis,vis,vis,*,*,*,*,*,*,vis3,vis3\")])\n \n (define_insn \"*mov<VM64:mode>_insn_sp64\"\n   [(set (match_operand:VM64 0 \"nonimmediate_operand\" \"=e,e,e,e,W,m,*r, m,*r, e,*r\")\n@@ -8542,8 +8667,8 @@\n   movxtod\\t%1, %0\n   mov\\t%1, %0\"\n   [(set_attr \"type\" \"visl,visl,vismv,fpload,fpstore,store,load,store,vismv,vismv,*\")\n-   (set_attr \"cpu_feature\" \"vis,vis,vis,*,*,*,*,*,vis3,vis3,*\")\n-   (set_attr \"v3pipe\" \"true,true,true,*,*,*,*,*,*,*,*\")])\n+   (set_attr \"subtype\" \"double,double,double,*,*,*,regular,*,movdtox,movxtod,*\")\n+   (set_attr \"cpu_feature\" \"vis,vis,vis,*,*,*,*,*,vis3,vis3,*\")])\n \n (define_insn \"*mov<VM64:mode>_insn_sp32\"\n   [(set (match_operand:VM64 0 \"nonimmediate_operand\"\n@@ -8572,9 +8697,9 @@\n   ldd\\t%1, %0\n   std\\t%1, %0\"\n   [(set_attr \"type\" \"store,*,visl,visl,vismv,*,*,fpload,fpstore,load,store,*,*,*,load,store\")\n+   (set_attr \"subtype\" \"*,*,double,double,double,*,*,*,*,regular,*,*,*,*,regular,*\")\n    (set_attr \"length\" \"*,2,*,*,*,2,2,*,*,*,*,2,2,2,*,*\")\n    (set_attr \"cpu_feature\" \"*,*,vis,vis,vis,vis3,vis3,*,*,*,*,*,*,*,*,*\")\n-   (set_attr \"v3pipe\" \"*,*,true,true,true,*,*,*,*,*,*,*,*,*,*,*\")\n    (set_attr \"lra\" \"*,*,*,*,*,*,*,*,*,disabled,disabled,*,*,*,*,*\")])\n \n (define_split\n@@ -8652,8 +8777,8 @@\n   \"TARGET_VIS\"\n   \"fp<plusminus_insn><vbits>\\t%1, %2, %0\"\n   [(set_attr \"type\" \"fga\")\n-   (set_attr \"fptype\" \"<vfptype>\")\n-   (set_attr \"v3pipe\" \"true\")])\n+   (set_attr \"subtype\" \"other\")\n+   (set_attr \"fptype\" \"<vfptype>\")])\n \n (define_mode_iterator VL [V1SI V2HI V4QI V1DI V2SI V4HI V8QI])\n (define_mode_attr vlsuf [(V1SI \"s\") (V2HI \"s\") (V4QI \"s\")\n@@ -8669,8 +8794,7 @@\n   \"TARGET_VIS\"\n   \"f<vlinsn><vlsuf>\\t%1, %2, %0\"\n   [(set_attr \"type\" \"visl\")\n-   (set_attr \"fptype\" \"<vfptype>\")\n-   (set_attr \"v3pipe\" \"true\")])\n+   (set_attr \"fptype\" \"<vfptype>\")])\n \n (define_insn \"*not_<vlop:code><VL:mode>3\"\n   [(set (match_operand:VL 0 \"register_operand\" \"=<vconstr>\")\n@@ -8679,8 +8803,7 @@\n   \"TARGET_VIS\"\n   \"f<vlninsn><vlsuf>\\t%1, %2, %0\"\n   [(set_attr \"type\" \"visl\")\n-   (set_attr \"fptype\" \"<vfptype>\")\n-   (set_attr \"v3pipe\" \"true\")])\n+   (set_attr \"fptype\" \"<vfptype>\")])\n \n ;; (ior (not (op1)) (not (op2))) is the canonical form of NAND.\n (define_insn \"*nand<VL:mode>_vis\"\n@@ -8690,8 +8813,7 @@\n   \"TARGET_VIS\"\n   \"fnand<vlsuf>\\t%1, %2, %0\"\n   [(set_attr \"type\" \"visl\")\n-   (set_attr \"fptype\" \"<vfptype>\")\n-   (set_attr \"v3pipe\" \"true\")])\n+   (set_attr \"fptype\" \"<vfptype>\")])\n \n (define_code_iterator vlnotop [ior and])\n \n@@ -8702,8 +8824,7 @@\n   \"TARGET_VIS\"\n   \"f<vlinsn>not1<vlsuf>\\t%1, %2, %0\"\n   [(set_attr \"type\" \"visl\")\n-   (set_attr \"fptype\" \"<vfptype>\")\n-   (set_attr \"v3pipe\" \"true\")])\n+   (set_attr \"fptype\" \"<vfptype>\")])\n \n (define_insn \"*<vlnotop:code>_not2<VL:mode>_vis\"\n   [(set (match_operand:VL 0 \"register_operand\" \"=<vconstr>\")\n@@ -8712,17 +8833,15 @@\n   \"TARGET_VIS\"\n   \"f<vlinsn>not2<vlsuf>\\t%1, %2, %0\"\n   [(set_attr \"type\" \"visl\")\n-   (set_attr \"fptype\" \"<vfptype>\")\n-   (set_attr \"v3pipe\" \"true\")])\n+   (set_attr \"fptype\" \"<vfptype>\")])\n \n (define_insn \"one_cmpl<VL:mode>2\"\n   [(set (match_operand:VL 0 \"register_operand\" \"=<vconstr>\")\n \t(not:VL (match_operand:VL 1 \"register_operand\" \"<vconstr>\")))]\n   \"TARGET_VIS\"\n   \"fnot1<vlsuf>\\t%1, %0\"\n   [(set_attr \"type\" \"visl\")\n-   (set_attr \"fptype\" \"<vfptype>\")\n-   (set_attr \"v3pipe\" \"true\")])\n+   (set_attr \"fptype\" \"<vfptype>\")])\n \n ;; Hard to generate VIS instructions.  We have builtins for these.\n \n@@ -8764,6 +8883,7 @@\n  \"TARGET_VIS\"\n  \"fexpand\\t%1, %0\"\n  [(set_attr \"type\" \"fga\")\n+  (set_attr \"subtype\" \"fpu\")\n   (set_attr \"fptype\" \"double\")])\n \n (define_insn \"fpmerge_vis\"\n@@ -8778,6 +8898,7 @@\n  \"TARGET_VIS\"\n  \"fpmerge\\t%1, %2, %0\"\n  [(set_attr \"type\" \"fga\")\n+  (set_attr \"subtype\" \"fpu\")\n   (set_attr \"fptype\" \"double\")])\n \n ;; Partitioned multiply instructions\n@@ -8866,7 +8987,8 @@\n   [(set (reg:DI GSR_REG) (match_operand:DI 0 \"arith_operand\" \"rI\"))]\n   \"TARGET_VIS && TARGET_ARCH64\"\n   \"wr\\t%%g0, %0, %%gsr\"\n-  [(set_attr \"type\" \"gsr\")])\n+  [(set_attr \"type\" \"gsr\")\n+   (set_attr \"subtype\" \"reg\")])\n \n (define_insn \"wrgsr_v8plus\"\n   [(set (reg:DI GSR_REG) (match_operand:DI 0 \"arith_operand\" \"I,r\"))\n@@ -8897,7 +9019,8 @@\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\") (reg:DI GSR_REG))]\n   \"TARGET_VIS && TARGET_ARCH64\"\n   \"rd\\t%%gsr, %0\"\n-  [(set_attr \"type\" \"gsr\")])\n+  [(set_attr \"type\" \"gsr\")\n+   (set_attr \"subtype\" \"reg\")])\n \n (define_insn \"rdgsr_v8plus\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\") (reg:DI GSR_REG))\n@@ -8920,8 +9043,8 @@\n   \"TARGET_VIS\"\n   \"faligndata\\t%1, %2, %0\"\n   [(set_attr \"type\" \"fga\")\n-   (set_attr \"fptype\" \"double\")\n-   (set_attr \"v3pipe\" \"true\")])\n+   (set_attr \"subtype\" \"other\")\n+   (set_attr \"fptype\" \"double\")])\n \n (define_insn \"alignaddrsi_vis\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n@@ -8932,7 +9055,7 @@\n   \"TARGET_VIS\"\n   \"alignaddr\\t%r1, %r2, %0\"\n   [(set_attr \"type\" \"gsr\")\n-   (set_attr \"v3pipe\" \"true\")])\n+   (set_attr \"subtype\" \"alignaddr\")])\n \n (define_insn \"alignaddrdi_vis\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n@@ -8943,7 +9066,7 @@\n   \"TARGET_VIS\"\n   \"alignaddr\\t%r1, %r2, %0\"\n   [(set_attr \"type\" \"gsr\")\n-   (set_attr \"v3pipe\" \"true\")])\n+   (set_attr \"subtype\" \"alignaddr\")])\n \n (define_insn \"alignaddrlsi_vis\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n@@ -8955,7 +9078,7 @@\n   \"TARGET_VIS\"\n   \"alignaddrl\\t%r1, %r2, %0\"\n   [(set_attr \"type\" \"gsr\")\n-   (set_attr \"v3pipe\" \"true\")])\n+   (set_attr \"subtype\" \"alignaddr\")])\n \n (define_insn \"alignaddrldi_vis\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n@@ -8967,7 +9090,7 @@\n   \"TARGET_VIS\"\n   \"alignaddrl\\t%r1, %r2, %0\"\n   [(set_attr \"type\" \"gsr\")\n-   (set_attr \"v3pipe\" \"true\")])\n+   (set_attr \"subtype\" \"alignaddr\")])\n \n (define_insn \"pdist_vis\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=e\")\n@@ -9059,9 +9182,7 @@\n \t UNSPEC_FCMP))]\n   \"TARGET_VIS\"\n   \"fcmp<gcond:code><GCM:gcm_name>\\t%1, %2, %0\"\n-  [(set_attr \"type\" \"visl\")\n-   (set_attr \"fptype\" \"double\")\n-   (set_attr \"v3pipe\" \"true\")])\n+  [(set_attr \"type\" \"viscmp\")])\n \n (define_insn \"fpcmp<gcond:code>8<P:mode>_vis\"\n   [(set (match_operand:P 0 \"register_operand\" \"=r\")\n@@ -9070,8 +9191,7 @@\n \t UNSPEC_FCMP))]\n   \"TARGET_VIS4\"\n   \"fpcmp<gcond:code>8\\t%1, %2, %0\"\n-  [(set_attr \"type\" \"visl\")\n-   (set_attr \"fptype\" \"double\")])\n+  [(set_attr \"type\" \"viscmp\")])\n \n (define_expand \"vcond<GCM:mode><GCM:mode>\"\n   [(match_operand:GCM 0 \"register_operand\" \"\")\n@@ -9134,8 +9254,7 @@\n         (plus:DI (match_dup 1) (match_dup 2)))]\n   \"TARGET_VIS2 && TARGET_ARCH64\"\n   \"bmask\\t%r1, %r2, %0\"\n-  [(set_attr \"type\" \"array\")\n-   (set_attr \"v3pipe\" \"true\")])\n+  [(set_attr \"type\" \"bmask\")])\n \n (define_insn \"bmasksi_vis\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n@@ -9145,8 +9264,7 @@\n         (zero_extend:DI (plus:SI (match_dup 1) (match_dup 2))))]\n   \"TARGET_VIS2\"\n   \"bmask\\t%r1, %r2, %0\"\n-  [(set_attr \"type\" \"array\")\n-   (set_attr \"v3pipe\" \"true\")])\n+  [(set_attr \"type\" \"bmask\")])\n \n (define_insn \"bshuffle<VM64:mode>_vis\"\n   [(set (match_operand:VM64 0 \"register_operand\" \"=e\")\n@@ -9157,8 +9275,8 @@\n   \"TARGET_VIS2\"\n   \"bshuffle\\t%1, %2, %0\"\n   [(set_attr \"type\" \"fga\")\n-   (set_attr \"fptype\" \"double\")\n-   (set_attr \"v3pipe\" \"true\")])\n+   (set_attr \"subtype\" \"other\")\n+   (set_attr \"fptype\" \"double\")])\n \n ;; The rtl expanders will happily convert constant permutations on other\n ;; modes down to V8QI.  Rely on this to avoid the complexity of the byte\n@@ -9261,7 +9379,7 @@\n   \"TARGET_VIS3\"\n   \"cmask8\\t%r0\"\n   [(set_attr \"type\" \"fga\")\n-   (set_attr \"v3pipe\" \"true\")])\n+   (set_attr \"subtype\" \"cmask\")])\n \n (define_insn \"cmask16<P:mode>_vis\"\n   [(set (reg:DI GSR_REG)\n@@ -9271,7 +9389,7 @@\n   \"TARGET_VIS3\"\n   \"cmask16\\t%r0\"\n   [(set_attr \"type\" \"fga\")\n-   (set_attr \"v3pipe\" \"true\")])\n+   (set_attr \"subtype\" \"cmask\")])\n \n (define_insn \"cmask32<P:mode>_vis\"\n   [(set (reg:DI GSR_REG)\n@@ -9281,7 +9399,7 @@\n   \"TARGET_VIS3\"\n   \"cmask32\\t%r0\"\n   [(set_attr \"type\" \"fga\")\n-   (set_attr \"v3pipe\" \"true\")])\n+   (set_attr \"subtype\" \"cmask\")])\n \n (define_insn \"fchksm16_vis\"\n   [(set (match_operand:V4HI 0 \"register_operand\" \"=e\")\n@@ -9290,7 +9408,8 @@\n                      UNSPEC_FCHKSM16))]\n   \"TARGET_VIS3\"\n   \"fchksm16\\t%1, %2, %0\"\n-  [(set_attr \"type\" \"fga\")])\n+  [(set_attr \"type\" \"fga\")\n+   (set_attr \"subtype\" \"fpu\")])\n \n (define_code_iterator vis3_shift [ashift ss_ashift lshiftrt ashiftrt])\n (define_code_attr vis3_shift_insn\n@@ -9304,7 +9423,8 @@\n \t\t\t(match_operand:GCM 2 \"register_operand\" \"<vconstr>\")))]\n   \"TARGET_VIS3\"\n   \"<vis3_shift_insn><vbits>\\t%1, %2, %0\"\n-  [(set_attr \"type\" \"fga\")])\n+  [(set_attr \"type\" \"fga\")\n+   (set_attr \"subtype\" \"fpu\")])\n \n (define_insn \"pdistn<P:mode>_vis\"\n   [(set (match_operand:P 0 \"register_operand\" \"=r\")\n@@ -9314,8 +9434,7 @@\n   \"TARGET_VIS3\"\n   \"pdistn\\t%1, %2, %0\"\n   [(set_attr \"type\" \"pdistn\")\n-   (set_attr \"fptype\" \"double\")\n-   (set_attr \"v3pipe\" \"true\")])\n+   (set_attr \"fptype\" \"double\")])\n \n (define_insn \"fmean16_vis\"\n   [(set (match_operand:V4HI 0 \"register_operand\" \"=e\")\n@@ -9332,23 +9451,26 @@\n           (const_int 1))))]\n   \"TARGET_VIS3\"\n   \"fmean16\\t%1, %2, %0\"\n-  [(set_attr \"type\" \"fga\")])\n+  [(set_attr \"type\" \"fga\")\n+   (set_attr \"subtype\" \"fpu\")])\n \n (define_insn \"fp<plusminus_insn>64_vis\"\n   [(set (match_operand:V1DI 0 \"register_operand\" \"=e\")\n \t(plusminus:V1DI (match_operand:V1DI 1 \"register_operand\" \"e\")\n \t\t\t(match_operand:V1DI 2 \"register_operand\" \"e\")))]\n   \"TARGET_VIS3\"\n   \"fp<plusminus_insn>64\\t%1, %2, %0\"\n-  [(set_attr \"type\" \"fga\")])\n+  [(set_attr \"type\" \"fga\")\n+   (set_attr \"subtype\" \"addsub64\")])\n \n (define_insn \"<plusminus_insn>v8qi3\"\n   [(set (match_operand:V8QI 0 \"register_operand\" \"=e\")\n         (plusminus:V8QI (match_operand:V8QI 1 \"register_operand\" \"e\")\n                         (match_operand:V8QI 2 \"register_operand\" \"e\")))]\n   \"TARGET_VIS4\"\n   \"fp<plusminus_insn>8\\t%1, %2, %0\"\n-  [(set_attr \"type\" \"fga\")])\n+  [(set_attr \"type\" \"fga\")\n+   (set_attr \"subtype\" \"other\")])\n \n (define_mode_iterator VASS [V4HI V2SI V2HI V1SI])\n (define_code_iterator vis3_addsub_ss [ss_plus ss_minus])\n@@ -9364,7 +9486,7 @@\n   \"TARGET_VIS3\"\n   \"<vis3_addsub_ss_insn><vbits>\\t%1, %2, %0\"\n   [(set_attr \"type\" \"fga\")\n-   (set_attr \"v3pipe\" \"true\")])\n+   (set_attr \"subtype\" \"other\")])\n \n (define_mode_iterator VMMAX [V8QI V4HI V2SI])\n (define_code_iterator vis4_minmax [smin smax])\n@@ -9379,7 +9501,8 @@\n                            (match_operand:VMMAX 2 \"register_operand\" \"<vconstr>\")))]\n   \"TARGET_VIS4\"\n   \"<vis4_minmax_insn><vbits>\\t%1, %2, %0\"\n-  [(set_attr \"type\" \"fga\")])\n+  [(set_attr \"type\" \"fga\")\n+   (set_attr \"subtype\" \"maxmin\")])\n \n (define_code_iterator vis4_uminmax [umin umax])\n (define_code_attr vis4_uminmax_insn\n@@ -9393,7 +9516,8 @@\n                             (match_operand:VMMAX 2 \"register_operand\" \"<vconstr>\")))]\n   \"TARGET_VIS4\"\n   \"<vis4_uminmax_insn><vbits>\\t%1, %2, %0\"\n-  [(set_attr \"type\" \"fga\")])\n+  [(set_attr \"type\" \"fga\")\n+   (set_attr \"subtype\" \"maxmin\")])\n \n ;; The use of vis3_addsub_ss_patname in the VIS4 instruction below is\n ;; intended.\n@@ -9403,7 +9527,8 @@\n                              (match_operand:V8QI 2 \"register_operand\" \"e\")))]\n   \"TARGET_VIS4\"\n   \"<vis3_addsub_ss_insn>8\\t%1, %2, %0\"\n-  [(set_attr \"type\" \"fga\")])\n+  [(set_attr \"type\" \"fga\")\n+   (set_attr \"subtype\" \"other\")])\n \n (define_mode_iterator VAUS [V4HI V8QI])\n (define_code_iterator vis4_addsub_us [us_plus us_minus])\n@@ -9418,7 +9543,8 @@\n                             (match_operand:VAUS 2 \"register_operand\" \"<vconstr>\")))]\n  \"TARGET_VIS4\"\n  \"<vis4_addsub_us_insn><vbits>\\t%1, %2, %0\"\n- [(set_attr \"type\" \"fga\")])\n+ [(set_attr \"type\" \"fga\")\n+  (set_attr \"subtype\" \"other\")])\n \n (define_insn \"fucmp<gcond:code>8<P:mode>_vis\"\n   [(set (match_operand:P 0 \"register_operand\" \"=r\")\n@@ -9427,8 +9553,7 @@\n \t UNSPEC_FUCMP))]\n   \"TARGET_VIS3\"\n   \"fucmp<gcond:code>8\\t%1, %2, %0\"\n-  [(set_attr \"type\" \"visl\")\n-   (set_attr \"v3pipe\" \"true\")])\n+  [(set_attr \"type\" \"viscmp\")])\n \n (define_insn \"fpcmpu<gcond:code><GCM:gcm_name><P:mode>_vis\"\n   [(set (match_operand:P 0 \"register_operand\" \"=r\")\n@@ -9437,8 +9562,7 @@\n \t UNSPEC_FUCMP))]\n   \"TARGET_VIS4\"\n   \"fpcmpu<gcond:code><GCM:gcm_name>\\t%1, %2, %0\"\n-  [(set_attr \"type\" \"visl\")\n-   (set_attr \"fptype\" \"double\")])\n+  [(set_attr \"type\" \"viscmp\")])\n \n (define_insn \"*naddsf3\"\n   [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n@@ -9542,4 +9666,62 @@\n   [(set_attr \"type\" \"fp\")\n    (set_attr \"fptype\" \"double\")])\n \n+;; VIS4B instructions.\n+\n+(define_mode_iterator DUMODE [V2SI V4HI V8QI])\n+\n+(define_insn \"dictunpack<DUMODE:vbits>\"\n+  [(set (match_operand:DUMODE 0 \"register_operand\" \"=e\")\n+        (unspec:DUMODE [(match_operand:DF 1 \"register_operand\" \"e\")\n+                        (match_operand:SI 2 \"imm5_operand_dictunpack<DUMODE:vbits>\" \"t\")]\n+         UNSPEC_DICTUNPACK))]\n+  \"TARGET_VIS4B\"\n+  \"dictunpack\\t%1, %2, %0\"\n+  [(set_attr \"type\" \"fga\")\n+   (set_attr \"subtype\" \"other\")])\n+\n+(define_mode_iterator FPCSMODE [V2SI V4HI V8QI])\n+(define_code_iterator fpcscond [le gt eq ne])\n+(define_code_iterator fpcsucond [le gt])\n+\n+(define_insn \"fpcmp<fpcscond:code><FPCSMODE:vbits><P:mode>shl\"\n+  [(set (match_operand:P 0 \"register_operand\" \"=r\")\n+        (unspec:P [(fpcscond:FPCSMODE (match_operand:FPCSMODE 1 \"register_operand\" \"e\")\n+                                      (match_operand:FPCSMODE 2 \"register_operand\" \"e\"))\n+                   (match_operand:SI 3 \"imm2_operand\" \"q\")]\n+         UNSPEC_FPCMPSHL))]\n+   \"TARGET_VIS4B\"\n+   \"fpcmp<fpcscond:code><FPCSMODE:vbits>shl\\t%1, %2, %3, %0\"\n+   [(set_attr \"type\" \"viscmp\")])\n+\n+(define_insn \"fpcmpu<fpcsucond:code><FPCSMODE:vbits><P:mode>shl\"\n+  [(set (match_operand:P 0 \"register_operand\" \"=r\")\n+        (unspec:P [(fpcsucond:FPCSMODE (match_operand:FPCSMODE 1 \"register_operand\" \"e\")\n+                                       (match_operand:FPCSMODE 2 \"register_operand\" \"e\"))\n+                   (match_operand:SI 3 \"imm2_operand\" \"q\")]\n+         UNSPEC_FPUCMPSHL))]\n+   \"TARGET_VIS4B\"\n+   \"fpcmpu<fpcsucond:code><FPCSMODE:vbits>shl\\t%1, %2, %3, %0\"\n+   [(set_attr \"type\" \"viscmp\")])\n+\n+(define_insn \"fpcmpde<FPCSMODE:vbits><P:mode>shl\"\n+  [(set (match_operand:P 0 \"register_operand\" \"=r\")\n+        (unspec:P [(match_operand:FPCSMODE 1 \"register_operand\" \"e\")\n+                   (match_operand:FPCSMODE 2 \"register_operand\" \"e\")\n+                   (match_operand:SI 3 \"imm2_operand\" \"q\")]\n+         UNSPEC_FPCMPDESHL))]\n+   \"TARGET_VIS4B\"\n+   \"fpcmpde<FPCSMODE:vbits>shl\\t%1, %2, %3, %0\"\n+   [(set_attr \"type\" \"viscmp\")])\n+\n+(define_insn \"fpcmpur<FPCSMODE:vbits><P:mode>shl\"\n+  [(set (match_operand:P 0 \"register_operand\" \"=r\")\n+        (unspec:P [(match_operand:FPCSMODE 1 \"register_operand\" \"e\")\n+                   (match_operand:FPCSMODE 2 \"register_operand\" \"e\")\n+                   (match_operand:SI 3 \"imm2_operand\" \"q\")]\n+         UNSPEC_FPCMPURSHL))]\n+   \"TARGET_VIS4B\"\n+   \"fpcmpur<FPCSMODE:vbits>shl\\t%1, %2, %3, %0\"\n+   [(set_attr \"type\" \"viscmp\")])\n+\n (include \"sync.md\")"}, {"sha": "cc51bd4b584fe18e166173d194ab58531642184d", "filename": "gcc/config/sparc/sparc.opt", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcc3c3f1ca89628f02802fda20f2232b9deef5f9/gcc%2Fconfig%2Fsparc%2Fsparc.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcc3c3f1ca89628f02802fda20f2232b9deef5f9/gcc%2Fconfig%2Fsparc%2Fsparc.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.opt?ref=bcc3c3f1ca89628f02802fda20f2232b9deef5f9", "patch": "@@ -81,6 +81,10 @@ mvis4\n Target Report Mask(VIS4)\n Use UltraSPARC Visual Instruction Set version 4.0 extensions.\n \n+mvis4b\n+Target Report Mask(VIS4B)\n+Use additional VIS instructions introduced in OSA2017.\n+\n mcbcond\n Target Report Mask(CBCOND)\n Use UltraSPARC Compare-and-Branch extensions.\n@@ -209,6 +213,9 @@ Enum(sparc_processor_type) String(niagara4) Value(PROCESSOR_NIAGARA4)\n EnumValue\n Enum(sparc_processor_type) String(niagara7) Value(PROCESSOR_NIAGARA7)\n \n+EnumValue\n+Enum(sparc_processor_type) String(m8) Value(PROCESSOR_M8)\n+\n mcmodel=\n Target RejectNegative Joined Var(sparc_cmodel_string)\n Use given SPARC-V9 code model."}, {"sha": "a4fb88345d61ab00771c9b9ce842bacdb2c64ba1", "filename": "gcc/config/sparc/ultra1_2.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcc3c3f1ca89628f02802fda20f2232b9deef5f9/gcc%2Fconfig%2Fsparc%2Fultra1_2.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcc3c3f1ca89628f02802fda20f2232b9deef5f9/gcc%2Fconfig%2Fsparc%2Fultra1_2.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fultra1_2.md?ref=bcc3c3f1ca89628f02802fda20f2232b9deef5f9", "patch": "@@ -263,10 +263,10 @@\n \n (define_insn_reservation \"us1_fga_double\"\n   2\n-  (and (and\n-         (eq_attr \"cpu\" \"ultrasparc\")\n-         (eq_attr \"type\" \"fga,visl,vismv\"))\n-       (eq_attr \"fptype\" \"double\"))\n+  (and (eq_attr \"cpu\" \"ultrasparc\")\n+       (ior (and (eq_attr \"type\" \"fga,visl,vismv\")\n+                 (eq_attr \"fptype\" \"double\"))\n+            (eq_attr \"type\" \"viscmp\")))\n   \"us1_fpa + us1_fp_double + us1_slotany, nothing\")\n \n (define_bypass 1 \"us1_fga_double\" \"us1_fga_double\")"}, {"sha": "db20cd9c98291c8204fc6386723f9b4b26cb5681", "filename": "gcc/config/sparc/ultra3.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcc3c3f1ca89628f02802fda20f2232b9deef5f9/gcc%2Fconfig%2Fsparc%2Fultra3.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcc3c3f1ca89628f02802fda20f2232b9deef5f9/gcc%2Fconfig%2Fsparc%2Fultra3.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fultra3.md?ref=bcc3c3f1ca89628f02802fda20f2232b9deef5f9", "patch": "@@ -56,7 +56,7 @@\n \n (define_insn_reservation \"us3_array\" 2\n   (and (eq_attr \"cpu\" \"ultrasparc3\")\n-    (eq_attr \"type\" \"array,edgen\"))\n+    (eq_attr \"type\" \"array,edgen,bmask\"))\n   \"us3_ms + us3_slotany, nothing\")\n \n ;; ??? Not entirely accurate.\n@@ -176,7 +176,7 @@\n (define_insn_reservation \"us3_fga\"\n   3\n   (and (eq_attr \"cpu\" \"ultrasparc3\")\n-       (eq_attr \"type\" \"fga,visl,vismv\"))\n+       (eq_attr \"type\" \"fga,visl,viscmp,vismv\"))\n   \"us3_fpa + us3_slotany, nothing*2\")\n \n (define_insn_reservation \"us3_fgm\""}, {"sha": "893f9587efa1ad3d94daf191ab5d4f1adc4321d3", "filename": "gcc/configure", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcc3c3f1ca89628f02802fda20f2232b9deef5f9/gcc%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcc3c3f1ca89628f02802fda20f2232b9deef5f9/gcc%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure?ref=bcc3c3f1ca89628f02802fda20f2232b9deef5f9", "patch": "@@ -25282,6 +25282,41 @@ $as_echo \"#define HAVE_AS_SPARC5_VIS4 1\" >>confdefs.h\n \n fi\n \n+    { $as_echo \"$as_me:${as_lineno-$LINENO}: checking assembler for SPARC6 instructions\" >&5\n+$as_echo_n \"checking assembler for SPARC6 instructions... \" >&6; }\n+if test \"${gcc_cv_as_sparc_sparc6+set}\" = set; then :\n+  $as_echo_n \"(cached) \" >&6\n+else\n+  gcc_cv_as_sparc_sparc6=no\n+  if test x$gcc_cv_as != x; then\n+    $as_echo '.text\n+       .register %g2, #scratch\n+       .register %g3, #scratch\n+       .align 4\n+       rd %entropy, %g1\n+       fpsll64x %f0, %f2, %f4' > conftest.s\n+    if { ac_try='$gcc_cv_as $gcc_cv_as_flags -xarch=sparc6 -o conftest.o conftest.s >&5'\n+  { { eval echo \"\\\"\\$as_me\\\":${as_lineno-$LINENO}: \\\"$ac_try\\\"\"; } >&5\n+  (eval $ac_try) 2>&5\n+  ac_status=$?\n+  $as_echo \"$as_me:${as_lineno-$LINENO}: \\$? = $ac_status\" >&5\n+  test $ac_status = 0; }; }\n+    then\n+\tgcc_cv_as_sparc_sparc6=yes\n+    else\n+      echo \"configure: failed program was\" >&5\n+      cat conftest.s >&5\n+    fi\n+    rm -f conftest.o conftest.s\n+  fi\n+fi\n+{ $as_echo \"$as_me:${as_lineno-$LINENO}: result: $gcc_cv_as_sparc_sparc6\" >&5\n+$as_echo \"$gcc_cv_as_sparc_sparc6\" >&6; }\n+if test $gcc_cv_as_sparc_sparc6 = yes; then\n+\n+$as_echo \"#define HAVE_AS_SPARC6 1\" >>confdefs.h\n+\n+fi\n \n     { $as_echo \"$as_me:${as_lineno-$LINENO}: checking assembler for LEON instructions\" >&5\n $as_echo_n \"checking assembler for LEON instructions... \" >&6; }"}, {"sha": "c6a9929a093a928ae8677b991dfe9fd027d042f4", "filename": "gcc/configure.ac", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcc3c3f1ca89628f02802fda20f2232b9deef5f9/gcc%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcc3c3f1ca89628f02802fda20f2232b9deef5f9/gcc%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure.ac?ref=bcc3c3f1ca89628f02802fda20f2232b9deef5f9", "patch": "@@ -4003,6 +4003,18 @@ foo:\n       [AC_DEFINE(HAVE_AS_SPARC5_VIS4, 1,\n                 [Define if your assembler supports SPARC5 and VIS 4.0 instructions.])])\n \n+    gcc_GAS_CHECK_FEATURE([SPARC6 instructions],\n+      gcc_cv_as_sparc_sparc6,,\n+      [-xarch=sparc6],\n+      [.text\n+       .register %g2, #scratch\n+       .register %g3, #scratch\n+       .align 4\n+       rd %entropy, %g1\n+       fpsll64x %f0, %f2, %f4],,\n+      [AC_DEFINE(HAVE_AS_SPARC6, 1,\n+                [Define if your assembler supports SPARC6 instructions.])])\n+\n     gcc_GAS_CHECK_FEATURE([LEON instructions],\n       gcc_cv_as_sparc_leon,,\n       [-Aleon],"}, {"sha": "3bef461c8f39d74bd2ac01f8ba5fbf50a92bdaca", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcc3c3f1ca89628f02802fda20f2232b9deef5f9/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcc3c3f1ca89628f02802fda20f2232b9deef5f9/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=bcc3c3f1ca89628f02802fda20f2232b9deef5f9", "patch": "@@ -19253,6 +19253,45 @@ v4hi __builtin_vis_fpminu16 (v4hi, v4hi);\n v2si __builtin_vis_fpminu32 (v2si, v2si);\n @end smallexample\n \n+When you use the @option{-mvis4b} switch, the VIS version 4.0B\n+built-in functions also become available:\n+\n+@smallexample\n+v8qi __builtin_vis_dictunpack8 (double, int);\n+v4hi __builtin_vis_dictunpack16 (double, int);\n+v2si __builtin_vis_dictunpack32 (double, int);\n+\n+long __builtin_vis_fpcmple8shl (v8qi, v8qi, int);\n+long __builtin_vis_fpcmpgt8shl (v8qi, v8qi, int);\n+long __builtin_vis_fpcmpeq8shl (v8qi, v8qi, int);\n+long __builtin_vis_fpcmpne8shl (v8qi, v8qi, int);\n+\n+long __builtin_vis_fpcmple16shl (v4hi, v4hi, int);\n+long __builtin_vis_fpcmpgt16shl (v4hi, v4hi, int);\n+long __builtin_vis_fpcmpeq16shl (v4hi, v4hi, int);\n+long __builtin_vis_fpcmpne16shl (v4hi, v4hi, int);\n+\n+long __builtin_vis_fpcmple32shl (v2si, v2si, int);\n+long __builtin_vis_fpcmpgt32shl (v2si, v2si, int);\n+long __builtin_vis_fpcmpeq32shl (v2si, v2si, int);\n+long __builtin_vis_fpcmpne32shl (v2si, v2si, int);\n+\n+long __builtin_vis_fpcmpule8shl (v8qi, v8qi, int);\n+long __builtin_vis_fpcmpugt8shl (v8qi, v8qi, int);\n+long __builtin_vis_fpcmpule16shl (v4hi, v4hi, int);\n+long __builtin_vis_fpcmpugt16shl (v4hi, v4hi, int);\n+long __builtin_vis_fpcmpule32shl (v2si, v2si, int);\n+long __builtin_vis_fpcmpugt32shl (v2si, v2si, int);\n+\n+long __builtin_vis_fpcmpde8shl (v8qi, v8qi, int);\n+long __builtin_vis_fpcmpde16shl (v4hi, v4hi, int);\n+long __builtin_vis_fpcmpde32shl (v2si, v2si, int);\n+\n+long __builtin_vis_fpcmpur8shl (v8qi, v8qi, int);\n+long __builtin_vis_fpcmpur16shl (v4hi, v4hi, int);\n+long __builtin_vis_fpcmpur32shl (v2si, v2si, int);\n+@end smallexample\n+\n @node SPU Built-in Functions\n @subsection SPU Built-in Functions\n "}, {"sha": "aa848bb23489e54554754e09c3df031536a5f3cf", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 20, "deletions": 5, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcc3c3f1ca89628f02802fda20f2232b9deef5f9/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcc3c3f1ca89628f02802fda20f2232b9deef5f9/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=bcc3c3f1ca89628f02802fda20f2232b9deef5f9", "patch": "@@ -1125,6 +1125,7 @@ See RS/6000 and PowerPC Options.\n -muser-mode  -mno-user-mode @gol\n -mv8plus  -mno-v8plus  -mvis  -mno-vis @gol\n -mvis2  -mno-vis2  -mvis3  -mno-vis3 @gol\n+-mvis4 -mno-vis4 -mvis4b -mno-vis4b @gol\n -mcbcond  -mno-cbcond  -mfmaf  -mno-fmaf  @gol\n -mpopc  -mno-popc  -msubxc  -mno-subxc@gol\n -mfix-at697f  -mfix-ut699 @gol\n@@ -23893,7 +23894,7 @@ for machine type @var{cpu_type}.  Supported values for @var{cpu_type} are\n @samp{leon}, @samp{leon3}, @samp{leon3v7}, @samp{sparclite}, @samp{f930},\n @samp{f934}, @samp{sparclite86x}, @samp{sparclet}, @samp{tsc701}, @samp{v9},\n @samp{ultrasparc}, @samp{ultrasparc3}, @samp{niagara}, @samp{niagara2},\n-@samp{niagara3}, @samp{niagara4} and @samp{niagara7}.\n+@samp{niagara3}, @samp{niagara4}, @samp{niagara7} and @samp{m8}.\n \n Native Solaris and GNU/Linux toolchains also support the value @samp{native},\n which selects the best architecture option for the host processor.\n@@ -23921,7 +23922,8 @@ f930, f934, sparclite86x\n tsc701\n \n @item v9\n-ultrasparc, ultrasparc3, niagara, niagara2, niagara3, niagara4, niagara7\n+ultrasparc, ultrasparc3, niagara, niagara2, niagara3, niagara4,\n+niagara7, m8\n @end table\n \n By default (unless configured otherwise), GCC generates code for the V7\n@@ -23965,7 +23967,8 @@ additionally optimizes it for Sun UltraSPARC T2 chips. With\n UltraSPARC T3 chips.  With @option{-mcpu=niagara4}, the compiler\n additionally optimizes it for Sun UltraSPARC T4 chips.  With\n @option{-mcpu=niagara7}, the compiler additionally optimizes it for\n-Oracle SPARC M7 chips.\n+Oracle SPARC M7 chips.  With @option{-mcpu=m8}, the compiler\n+additionally optimizes it for Oracle M8 chips.\n \n @item -mtune=@var{cpu_type}\n @opindex mtune\n@@ -23980,8 +23983,8 @@ that select a particular CPU implementation.  Those are\n @samp{leon3}, @samp{leon3v7}, @samp{f930}, @samp{f934},\n @samp{sparclite86x}, @samp{tsc701}, @samp{ultrasparc},\n @samp{ultrasparc3}, @samp{niagara}, @samp{niagara2}, @samp{niagara3},\n-@samp{niagara4} and @samp{niagara7}.  With native Solaris and\n-GNU/Linux toolchains, @samp{native} can also be used.\n+@samp{niagara4}, @samp{niagara7} and @samp{m8}.  With native Solaris\n+and GNU/Linux toolchains, @samp{native} can also be used.\n \n @item -mv8plus\n @itemx -mno-v8plus\n@@ -24029,6 +24032,18 @@ default is @option{-mvis4} when targeting a cpu that supports such\n instructions, such as niagara-7 and later.  Setting @option{-mvis4}\n also sets @option{-mvis3}, @option{-mvis2} and @option{-mvis}.\n \n+@item -mvis4b\n+@itemx -mno-vis4b\n+@opindex mvis4b\n+@opindex mno-vis4b\n+With @option{-mvis4b}, GCC generates code that takes advantage of\n+version 4.0 of the UltraSPARC Visual Instruction Set extensions, plus\n+the additional VIS instructions introduced in the Oracle SPARC\n+Architecture 2017.  The default is @option{-mvis4b} when targeting a\n+cpu that supports such instructions, such as m8 and later.  Setting\n+@option{-mvis4b} also sets @option{-mvis4}, @option{-mvis3},\n+@option{-mvis2} and @option{-mvis}.\n+\n @item -mcbcond\n @itemx -mno-cbcond\n @opindex mcbcond"}, {"sha": "6e53e295b5acd6a129cece700c2eabb9238d57a1", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcc3c3f1ca89628f02802fda20f2232b9deef5f9/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcc3c3f1ca89628f02802fda20f2232b9deef5f9/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=bcc3c3f1ca89628f02802fda20f2232b9deef5f9", "patch": "@@ -1,3 +1,11 @@\n+2017-07-07  Jose E. Marchesi  <jose.marchesi@oracle.com>\n+\n+\t* gcc.target/sparc/dictunpack.c: New file.\n+\t* gcc.target/sparc/fpcmpdeshl.c: Likewise.\n+\t* gcc.target/sparc/fpcmpshl.c: Likewise.\n+\t* gcc.target/sparc/fpcmpurshl.c: Likewise.\n+\t* gcc.target/sparc/fpcmpushl.c: Likewise.\n+\n 2017-07-06  Harald Anlauf  <anlauf@gmx.de>\n \n \tPR fortran/70071"}, {"sha": "4334dee2b2e3f9c06f7c77b9898787d9a2f5338b", "filename": "gcc/testsuite/gcc.target/sparc/dictunpack.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcc3c3f1ca89628f02802fda20f2232b9deef5f9/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Fdictunpack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcc3c3f1ca89628f02802fda20f2232b9deef5f9/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Fdictunpack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Fdictunpack.c?ref=bcc3c3f1ca89628f02802fda20f2232b9deef5f9", "patch": "@@ -0,0 +1,25 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-mvis4b\" } */\n+\n+typedef unsigned char vec8 __attribute__((vector_size(8)));\n+typedef short vec16 __attribute__((vector_size(8)));\n+typedef int vec32 __attribute__((vector_size(8)));\n+\n+vec8 test_dictunpack8 (double a)\n+{\n+  return __builtin_vis_dictunpack8 (a, 6);\n+}\n+\n+vec16 test_dictunpack16 (double a)\n+{\n+  return __builtin_vis_dictunpack16 (a, 14);\n+}\n+\n+vec32 test_dictunpack32 (double a)\n+{\n+  return __builtin_vis_dictunpack32 (a, 30);\n+}\n+\n+/* { dg-final { scan-assembler \"dictunpack\\t%\" } } */\n+/* { dg-final { scan-assembler \"dictunpack\\t%\" } } */\n+/* { dg-final { scan-assembler \"dictunpack\\t%\" } } */"}, {"sha": "3e3daa6e99f151dabe4b013beeaa86ec8c1db83b", "filename": "gcc/testsuite/gcc.target/sparc/fpcmpdeshl.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcc3c3f1ca89628f02802fda20f2232b9deef5f9/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Ffpcmpdeshl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcc3c3f1ca89628f02802fda20f2232b9deef5f9/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Ffpcmpdeshl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Ffpcmpdeshl.c?ref=bcc3c3f1ca89628f02802fda20f2232b9deef5f9", "patch": "@@ -0,0 +1,25 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-mvis4b\" } */\n+\n+typedef unsigned char vec8 __attribute__((vector_size(8)));\n+typedef short vec16 __attribute__((vector_size(8)));\n+typedef int vec32 __attribute__((vector_size(8)));\n+\n+long test_fpcmpde8shl (vec8 a, vec8 b)\n+{\n+  return __builtin_vis_fpcmpde8shl (a, b, 2);\n+}\n+\n+long test_fpcmpde16shl (vec16 a, vec16 b)\n+{\n+  return __builtin_vis_fpcmpde16shl (a, b, 2);\n+}\n+\n+long test_fpcmpde32shl (vec32 a, vec32 b)\n+{\n+  return __builtin_vis_fpcmpde32shl (a, b, 2);\n+}\n+\n+/* { dg-final { scan-assembler \"fpcmpde8shl\\t%\" } } */\n+/* { dg-final { scan-assembler \"fpcmpde16shl\\t%\" } } */\n+/* { dg-final { scan-assembler \"fpcmpde32shl\\t%\" } } */"}, {"sha": "0985251cbfd788f0e9cf34cf7c5cb35378ab8b01", "filename": "gcc/testsuite/gcc.target/sparc/fpcmpshl.c", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcc3c3f1ca89628f02802fda20f2232b9deef5f9/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Ffpcmpshl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcc3c3f1ca89628f02802fda20f2232b9deef5f9/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Ffpcmpshl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Ffpcmpshl.c?ref=bcc3c3f1ca89628f02802fda20f2232b9deef5f9", "patch": "@@ -0,0 +1,81 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-mvis4b\" } */\n+\n+typedef unsigned char vec8 __attribute__((vector_size(8)));\n+typedef short vec16 __attribute__((vector_size(8)));\n+typedef int vec32 __attribute__((vector_size(8)));\n+\n+long test_fpcmple8shl (vec8 a, vec8 b)\n+{\n+  return __builtin_vis_fpcmple8shl (a, b, 2);\n+}\n+\n+long test_fpcmpgt8shl (vec8 a, vec8 b)\n+{\n+  return __builtin_vis_fpcmpgt8shl (a, b, 2);\n+}\n+\n+long test_fpcmpeq8shl (vec8 a, vec8 b)\n+{\n+  return __builtin_vis_fpcmpeq8shl (a, b, 2);\n+}\n+\n+long test_fpcmpne8shl (vec8 a, vec8 b)\n+{\n+  return __builtin_vis_fpcmpne8shl (a, b, 2);\n+}\n+\n+long test_fpcmple16shl (vec16 a, vec16 b)\n+{\n+  return __builtin_vis_fpcmple16shl (a, b, 2);\n+}\n+\n+long test_fpcmpgt16shl (vec16 a, vec16 b)\n+{\n+  return __builtin_vis_fpcmpgt16shl (a, b, 2);\n+}\n+\n+long test_fpcmpeq16shl (vec16 a, vec16 b)\n+{\n+  return __builtin_vis_fpcmpeq16shl (a, b, 2);\n+}\n+\n+long test_fpcmpne16shl (vec16 a, vec16 b)\n+{\n+  return __builtin_vis_fpcmpne16shl (a, b, 2);\n+}\n+\n+long test_fpcmple32shl (vec32 a, vec32 b)\n+{\n+  return __builtin_vis_fpcmple32shl (a, b, 2);\n+}\n+\n+long test_fpcmpgt32shl (vec32 a, vec32 b)\n+{\n+  return __builtin_vis_fpcmpgt32shl (a, b, 2);\n+}\n+\n+long test_fpcmpeq32shl (vec32 a, vec32 b)\n+{\n+  return __builtin_vis_fpcmpeq32shl (a, b, 2);\n+}\n+\n+long test_fpcmpne32shl (vec32 a, vec32 b)\n+{\n+  return __builtin_vis_fpcmpne32shl (a, b, 2);\n+}\n+\n+/* { dg-final { scan-assembler \"fpcmple8shl\\t%\" } } */\n+/* { dg-final { scan-assembler \"fpcmpgt8shl\\t%\" } } */\n+/* { dg-final { scan-assembler \"fpcmpeq8shl\\t%\" } } */\n+/* { dg-final { scan-assembler \"fpcmpne8shl\\t%\" } } */\n+\n+/* { dg-final { scan-assembler \"fpcmple16shl\\t%\" } } */\n+/* { dg-final { scan-assembler \"fpcmpgt16shl\\t%\" } } */\n+/* { dg-final { scan-assembler \"fpcmpeq16shl\\t%\" } } */\n+/* { dg-final { scan-assembler \"fpcmpne16shl\\t%\" } } */\n+\n+/* { dg-final { scan-assembler \"fpcmple32shl\\t%\" } } */\n+/* { dg-final { scan-assembler \"fpcmpgt32shl\\t%\" } } */\n+/* { dg-final { scan-assembler \"fpcmpeq32shl\\t%\" } } */\n+/* { dg-final { scan-assembler \"fpcmpne32shl\\t%\" } } */"}, {"sha": "db74e01b5f2c2359d53e71d45a22ee14a6f8c6dc", "filename": "gcc/testsuite/gcc.target/sparc/fpcmpurshl.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcc3c3f1ca89628f02802fda20f2232b9deef5f9/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Ffpcmpurshl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcc3c3f1ca89628f02802fda20f2232b9deef5f9/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Ffpcmpurshl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Ffpcmpurshl.c?ref=bcc3c3f1ca89628f02802fda20f2232b9deef5f9", "patch": "@@ -0,0 +1,25 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-mvis4b\" } */\n+\n+typedef unsigned char vec8 __attribute__((vector_size(8)));\n+typedef short vec16 __attribute__((vector_size(8)));\n+typedef int vec32 __attribute__((vector_size(8)));\n+\n+long test_fpcmpur8shl (vec8 a, vec8 b)\n+{\n+  return __builtin_vis_fpcmpur8shl (a, b, 2);\n+}\n+\n+long test_fpcmpur16shl (vec16 a, vec16 b)\n+{\n+  return __builtin_vis_fpcmpur16shl (a, b, 2);\n+}\n+\n+long test_fpcmpur32shl (vec32 a, vec32 b)\n+{\n+  return __builtin_vis_fpcmpur32shl (a, b, 2);\n+}\n+\n+/* { dg-final { scan-assembler \"fpcmpur8shl\\t%\" } } */\n+/* { dg-final { scan-assembler \"fpcmpur16shl\\t%\" } } */\n+/* { dg-final { scan-assembler \"fpcmpur32shl\\t%\" } } */"}, {"sha": "fc58deddb4555f8192398454946d4dcba19919e7", "filename": "gcc/testsuite/gcc.target/sparc/fpcmpushl.c", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcc3c3f1ca89628f02802fda20f2232b9deef5f9/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Ffpcmpushl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcc3c3f1ca89628f02802fda20f2232b9deef5f9/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Ffpcmpushl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Ffpcmpushl.c?ref=bcc3c3f1ca89628f02802fda20f2232b9deef5f9", "patch": "@@ -0,0 +1,43 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-mvis4b\" } */\n+\n+typedef unsigned char vec8 __attribute__((vector_size(8)));\n+typedef short vec16 __attribute__((vector_size(8)));\n+typedef int vec32 __attribute__((vector_size(8)));\n+\n+long test_fpcmpule8shl (vec8 a, vec8 b)\n+{\n+  return __builtin_vis_fpcmpule8shl (a, b, 2);\n+}\n+\n+long test_fpcmpugt8shl (vec8 a, vec8 b)\n+{\n+  return __builtin_vis_fpcmpugt8shl (a, b, 2);\n+}\n+\n+long test_fpcmpule16shl (vec16 a, vec16 b)\n+{\n+  return __builtin_vis_fpcmpule16shl (a, b, 2);\n+}\n+\n+long test_fpcmpugt16shl (vec16 a, vec16 b)\n+{\n+  return __builtin_vis_fpcmpugt16shl (a, b, 2);\n+}\n+\n+long test_fpcmpule32shl (vec32 a, vec32 b)\n+{\n+  return __builtin_vis_fpcmpule32shl (a, b, 2);\n+}\n+\n+long test_fpcmpugt32shl (vec32 a, vec32 b)\n+{\n+  return __builtin_vis_fpcmpugt32shl (a, b, 2);\n+}\n+\n+/* { dg-final { scan-assembler \"fpcmpule8shl\\t%\" } } */\n+/* { dg-final { scan-assembler \"fpcmpugt8shl\\t%\" } } */\n+/* { dg-final { scan-assembler \"fpcmpule16shl\\t%\" } } */\n+/* { dg-final { scan-assembler \"fpcmpugt16shl\\t%\" } } */\n+/* { dg-final { scan-assembler \"fpcmpule32shl\\t%\" } } */\n+/* { dg-final { scan-assembler \"fpcmpugt32shl\\t%\" } } */"}]}