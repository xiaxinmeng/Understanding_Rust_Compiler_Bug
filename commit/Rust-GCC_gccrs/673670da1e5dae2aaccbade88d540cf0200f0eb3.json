{"sha": "673670da1e5dae2aaccbade88d540cf0200f0eb3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjczNjcwZGExZTVkYWUyYWFjY2JhZGU4OGQ1NDBjZjAyMDBmMGViMw==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2018-11-29T17:48:58Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@gcc.gnu.org", "date": "2018-11-29T17:48:58Z"}, "message": "PR c/88172 - attribute aligned of zero silently accepted but ignored\n\nPR c/88172 - attribute aligned of zero silently accepted but ignored\nPR testsuite/88208 - new test case c-c++-common/builtin-has-attribute-3.c in r266335 has multiple excess errors\n\ngcc/ChangeLog:\n\n\tPR c/88172\n\tPR testsuite/88208\n\t* doc/extend.texi (attribute constructor): Clarify.\n\ngcc/c/ChangeLog:\n\n\tPR c/88172\n\tPR testsuite/88208\n\t* c-decl.c (declspec_add_alignas): Adjust call to check_user_alignment.\n\ngcc/c-family/ChangeLog:\n\n\tPR c/88172\n\tPR testsuite/88208\n\t* c-attribs.c (common_handle_aligned_attribute): Silently avoid setting\n\talignments to values less than the target requires.\n\t(has_attribute): For attribute aligned consider both the attribute\n\tand the alignment bits.\n\t* c-common.c (c_init_attributes): Optionally issue a warning for\n\tzero alignment.\n\ngcc/testsuite/ChangeLog:\n\n\tPR c/88172\n\tPR testsuite/88208\n\t* gcc.dg/attr-aligned-2.c: New test.\n\t* gcc.dg/builtin-has-attribute.c: Adjust.\n\t* c-c++-common/builtin-has-attribute-2.c: Same.\n\t* c-c++-common/builtin-has-attribute-3.c: Same.\n\t* c-c++-common/builtin-has-attribute-4.c: Same.\n\t* c-c++-common/builtin-has-attribute-5.c: New test.\n\t* gcc.target/aarch64/attr-aligned.c: Same.\n\t* gcc.target/i386/attr-aligned.c: Same.\n\t* gcc.target/powerpc/attr-aligned.c: Same.\n\t* gcc.target/sparc/attr-aligned.c: Same.\n\nFrom-SVN: r266633", "tree": {"sha": "6e9c098954bf73d9254094221f8aa7aee090062f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6e9c098954bf73d9254094221f8aa7aee090062f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/673670da1e5dae2aaccbade88d540cf0200f0eb3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/673670da1e5dae2aaccbade88d540cf0200f0eb3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/673670da1e5dae2aaccbade88d540cf0200f0eb3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/673670da1e5dae2aaccbade88d540cf0200f0eb3/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "2831adb5623797825234bf006b9f2fc8f027c36d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2831adb5623797825234bf006b9f2fc8f027c36d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2831adb5623797825234bf006b9f2fc8f027c36d"}], "stats": {"total": 550, "additions": 467, "deletions": 83}, "files": [{"sha": "bc8d2b172e9ade2d3e18c4f66fe68d4aa4af7f15", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/673670da1e5dae2aaccbade88d540cf0200f0eb3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/673670da1e5dae2aaccbade88d540cf0200f0eb3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=673670da1e5dae2aaccbade88d540cf0200f0eb3", "patch": "@@ -1,3 +1,9 @@\n+2018-11-29  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR c/88172\n+\tPR testsuite/88208\n+\t* doc/extend.texi (attribute constructor): Clarify.\n+\n 2018-11-29  Martin Liska  <mliska@suse.cz>\n \n \tPR middle-end/88246"}, {"sha": "890b014449d81959859bb99960f8aa36f67a907b", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/673670da1e5dae2aaccbade88d540cf0200f0eb3/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/673670da1e5dae2aaccbade88d540cf0200f0eb3/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=673670da1e5dae2aaccbade88d540cf0200f0eb3", "patch": "@@ -1,3 +1,14 @@\n+2018-11-29  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR c/88172\n+\tPR testsuite/88208\n+\t* c-attribs.c (common_handle_aligned_attribute): Silently avoid setting\n+\talignments to values less than the target requires.\n+\t(has_attribute): For attribute aligned consider both the attribute\n+\tand the alignment bits.\n+\t* c-common.c (c_init_attributes): Optionally issue a warning for\n+\tzero alignment.\n+\n 2018-11-28  Martin Sebor  <msebor@redhat.com>\n \n \tPR c/88065"}, {"sha": "1454e2f3640945641487b65c3fdea7162d6067a5", "filename": "gcc/c-family/c-attribs.c", "status": "modified", "additions": 55, "deletions": 43, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/673670da1e5dae2aaccbade88d540cf0200f0eb3/gcc%2Fc-family%2Fc-attribs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/673670da1e5dae2aaccbade88d540cf0200f0eb3/gcc%2Fc-family%2Fc-attribs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-attribs.c?ref=673670da1e5dae2aaccbade88d540cf0200f0eb3", "patch": "@@ -2003,7 +2003,8 @@ common_handle_aligned_attribute (tree *node, tree name, tree args, int flags,\n   bool objfile = (TREE_CODE (*node) == FUNCTION_DECL\n \t\t  || (VAR_P (*node) && TREE_STATIC (*node)));\n   /* Log2 of specified alignment.  */\n-  int pow2align = check_user_alignment (align_expr, objfile, true);\n+  int pow2align = check_user_alignment (align_expr, objfile,\n+\t\t\t\t\t/* warn_zero = */ true);\n   if (pow2align == -1\n       || !check_cxx_fundamental_alignment_constraints (*node, pow2align, flags))\n     {\n@@ -2019,6 +2020,9 @@ common_handle_aligned_attribute (tree *node, tree name, tree args, int flags,\n   unsigned curalign = 0;\n   unsigned lastalign = 0;\n \n+  /* True when SET_DECL_ALIGN() should be called for the decl when\n+     *NO_ADD_ATTRS is false.  */\n+  bool set_align = true;\n   if (is_type)\n     {\n       if ((flags & (int) ATTR_FLAG_TYPE_IN_PLACE))\n@@ -2067,23 +2071,35 @@ common_handle_aligned_attribute (tree *node, tree name, tree args, int flags,\n \tcuralign = lastalign;\n \n       curalign /= BITS_PER_UNIT;\n-      bitalign /= BITS_PER_UNIT;\n+      unsigned newalign = bitalign / BITS_PER_UNIT;\n \n-      bool diagd = true;\n       auto_diagnostic_group d;\n-      if (DECL_USER_ALIGN (decl) || DECL_USER_ALIGN (last_decl))\n-\tdiagd = warning (OPT_Wattributes,\n-\t\t\t  \"ignoring attribute %<%E (%u)%> because it conflicts \"\n-\t\t\t  \"with attribute %<%E (%u)%>\",\n-\t\t\t  name, bitalign, name, curalign);\n+      if ((DECL_USER_ALIGN (decl)\n+\t   || DECL_USER_ALIGN (last_decl)))\n+\t{\n+\t  if (warning (OPT_Wattributes,\n+\t\t       \"ignoring attribute %<%E (%u)%> because it conflicts \"\n+\t\t       \"with attribute %<%E (%u)%>\",\n+\t\t       name, newalign, name, curalign)\n+\t      && note)\n+\t    inform (DECL_SOURCE_LOCATION (last_decl),\n+\t\t    \"previous declaration here\");\n+\t  /* Only reject attempts to relax/override an alignment\n+\t     explicitly specified previously and accept declarations\n+\t     that appear to relax the implicit function alignment for\n+\t     the target.  Both increasing and increasing the alignment\n+\t     set by -falign-functions setting is permitted.  */\n+\t  *no_add_attrs = true;\n+\t}\n       else if (!warn_if_not_aligned_p)\n-\t/* Do not error out for attribute warn_if_not_aligned.  */\n-\terror (\"alignment for %q+D must be at least %d\", decl, curalign);\n-\n-      if (diagd && note)\n-\tinform (DECL_SOURCE_LOCATION (last_decl), \"previous declaration here\");\n-\n-      *no_add_attrs = true;\n+\t{\n+\t  /* Do not fail for attribute warn_if_not_aligned.  Otherwise,\n+\t     silently avoid applying the alignment to the declaration\n+\t     because it's implicitly satisfied by the target.  Apply\n+\t     the attribute nevertheless so it can be retrieved by\n+\t     __builtin_has_attribute.  */\n+\t  set_align = false;\n+\t}\n     }\n   else if (DECL_USER_ALIGN (decl)\n \t   && DECL_ALIGN (decl) > bitalign)\n@@ -2100,40 +2116,41 @@ common_handle_aligned_attribute (tree *node, tree name, tree args, int flags,\n \t   && TREE_CODE (decl) == FUNCTION_DECL\n \t   && DECL_ALIGN (decl) > bitalign)\n     {\n-      /* Don't warn function alignment here if warn_if_not_aligned_p is\n-\t true.  It will be warned later.  */\n+      /* Don't warn for function alignment here if warn_if_not_aligned_p\n+\t is true.  It will be warned about later.  */\n       if (DECL_USER_ALIGN (decl))\n-\terror (\"alignment for %q+D was previously specified as %d \"\n-\t       \"and may not be decreased\", decl,\n-\t       DECL_ALIGN (decl) / BITS_PER_UNIT);\n-      else\n-\terror (\"alignment for %q+D must be at least %d\", decl,\n-\t       DECL_ALIGN (decl) / BITS_PER_UNIT);\n-      *no_add_attrs = true;\n-    }\n-  else\n-    {\n-      if (warn_if_not_aligned_p)\n-\t{\n-\t  if (TREE_CODE (decl) == FIELD_DECL && !DECL_C_BIT_FIELD (decl))\n-\t    {\n-\t      SET_DECL_WARN_IF_NOT_ALIGN (decl, bitalign);\n-\t      warn_if_not_aligned_p = false;\n-\t    }\n-\t}\n-      else\n \t{\n-\t  SET_DECL_ALIGN (decl, bitalign);\n-\t  DECL_USER_ALIGN (decl) = 1;\n+\t  /* Only reject attempts to relax/override an alignment\n+\t     explicitly specified previously and accept declarations\n+\t     that appear to relax the implicit function alignment for\n+\t     the target.  Both increasing and increasing the alignment\n+\t     set by -falign-functions setting is permitted.  */\n+\t  error (\"alignment for %q+D was previously specified as %d \"\n+\t\t \"and may not be decreased\", decl,\n+\t\t DECL_ALIGN (decl) / BITS_PER_UNIT);\n+\t  *no_add_attrs = true;\n \t}\n     }\n+  else if (warn_if_not_aligned_p\n+\t   && TREE_CODE (decl) == FIELD_DECL\n+\t   && !DECL_C_BIT_FIELD (decl))\n+    {\n+      SET_DECL_WARN_IF_NOT_ALIGN (decl, bitalign);\n+      warn_if_not_aligned_p = false;\n+      set_align = false;\n+    }\n \n   if (warn_if_not_aligned_p)\n     {\n       error (\"%<warn_if_not_aligned%> may not be specified for %q+D\",\n \t     decl);\n       *no_add_attrs = true;\n     }\n+  else if (!is_type && !*no_add_attrs && set_align)\n+    {\n+      SET_DECL_ALIGN (decl, bitalign);\n+      DECL_USER_ALIGN (decl) = 1;\n+    }\n \n   return NULL_TREE;\n }\n@@ -4086,11 +4103,6 @@ has_attribute (location_t atloc, tree t, tree attr, tree (*convert)(tree))\n \t with the sought attributes) has been found on the attribute chain.  */\n       bool found_attr = false;\n \n-      /* For attribute aligned ignore the attribute list and consider\n-\t the tree node itself instead.  */\n-      if (type && !strcmp (\"aligned\", namestr))\n-\tatlist = NULL_TREE;\n-\n       /* When clear, the first mismatched attribute argument results\n \t in failure.  Otherwise, the first matched attribute argument\n \t results in success.  */"}, {"sha": "4c903650650d2a42f044e7a99012ee4040f0e4c4", "filename": "gcc/c-family/c-common.c", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/673670da1e5dae2aaccbade88d540cf0200f0eb3/gcc%2Fc-family%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/673670da1e5dae2aaccbade88d540cf0200f0eb3/gcc%2Fc-family%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.c?ref=673670da1e5dae2aaccbade88d540cf0200f0eb3", "patch": "@@ -5143,11 +5143,11 @@ c_init_attributes (void)\n    then reject alignments greater than MAX_OFILE_ALIGNMENT when\n    converted to bits.  Otherwise, consider valid only alignments\n    that are less than HOST_BITS_PER_INT - LOG2_BITS_PER_UNIT.\n-   If ALLOW_ZERO then 0 is valid and should result in\n-   a return of -1 with no error.  */\n+   Zero is not considered a valid argument (and results in -1 on\n+   return) but it only triggers a warning when WARN_ZERO is set.  */\n \n int\n-check_user_alignment (const_tree align, bool objfile, bool allow_zero)\n+check_user_alignment (const_tree align, bool objfile, bool warn_zero)\n {\n   if (error_operand_p (align))\n     return -1;\n@@ -5159,8 +5159,14 @@ check_user_alignment (const_tree align, bool objfile, bool allow_zero)\n       return -1;\n     }\n \n-  if (allow_zero && integer_zerop (align))\n-    return -1;\n+  if (integer_zerop (align))\n+    {\n+      if (warn_zero)\n+\twarning (OPT_Wattributes,\n+\t\t \"requested alignment %qE is not a positive power of 2\",\n+\t\t align);\n+      return -1;\n+    }\n \n   int log2bitalign;\n   if (tree_int_cst_sgn (align) == -1"}, {"sha": "4ed5b4bd8f530bab85efc4b7b2ba6d6dbfa65a34", "filename": "gcc/c/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/673670da1e5dae2aaccbade88d540cf0200f0eb3/gcc%2Fc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/673670da1e5dae2aaccbade88d540cf0200f0eb3/gcc%2Fc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2FChangeLog?ref=673670da1e5dae2aaccbade88d540cf0200f0eb3", "patch": "@@ -1,3 +1,9 @@\n+2018-11-29  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR c/88172\n+\tPR testsuite/88208\n+\t* c-decl.c (declspec_add_alignas): Adjust call to check_user_alignment.\n+\n 2018-11-23  Martin Sebor  <msebor@redhat.com>\n \n \tPR testsuite/88098"}, {"sha": "b50f2bfd3198893b944a804cdcafee455555e747", "filename": "gcc/c/c-decl.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/673670da1e5dae2aaccbade88d540cf0200f0eb3/gcc%2Fc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/673670da1e5dae2aaccbade88d540cf0200f0eb3/gcc%2Fc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-decl.c?ref=673670da1e5dae2aaccbade88d540cf0200f0eb3", "patch": "@@ -11061,12 +11061,15 @@ struct c_declspecs *\n declspecs_add_alignas (location_t loc,\n \t\t       struct c_declspecs *specs, tree align)\n {\n-  int align_log;\n   specs->alignas_p = true;\n   specs->locations[cdw_alignas] = loc;\n   if (align == error_mark_node)\n     return specs;\n-  align_log = check_user_alignment (align, false, true);\n+\n+  /* Only accept the alignment if it's valid and greater than\n+     the current one.  Zero is invalid but by C11 required to\n+     be silently ignored.  */\n+  int align_log = check_user_alignment (align, false, /* warn_zero = */false);\n   if (align_log > specs->align_log)\n     specs->align_log = align_log;\n   return specs;"}, {"sha": "8c7b178519a29b1ba4278b0e14e362dcd9febbe9", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/673670da1e5dae2aaccbade88d540cf0200f0eb3/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/673670da1e5dae2aaccbade88d540cf0200f0eb3/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=673670da1e5dae2aaccbade88d540cf0200f0eb3", "patch": "@@ -2552,8 +2552,9 @@ called.  Functions with these attributes are useful for\n initializing data that is used implicitly during the execution of\n the program.\n \n-You may provide an optional integer priority to control the order in\n-which constructor and destructor functions are run.  A constructor\n+On some targets the attributes also accept an integer argument to\n+specify a priority to control the order in which constructor and\n+destructor functions are run.  A constructor\n with a smaller priority number runs before a constructor with a larger\n priority number; the opposite relationship holds for destructors.  So,\n if you have a constructor that allocates a resource and a destructor\n@@ -2566,6 +2567,10 @@ decorated with attribute @code{constructor} are invoked is unspecified.\n In mixed declarations, attribute @code{init_priority} can be used to\n impose a specific ordering.\n \n+Using the argument forms of the @code{constructor} and @code{destructor}\n+attributes on targets where the feature is not supported is rejected with\n+an error.\n+\n @item copy\n @itemx copy (@var{function})\n @cindex @code{copy} function attribute"}, {"sha": "ecb1ad6095d8d8bec10f670001d97b73d0d7dfee", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/673670da1e5dae2aaccbade88d540cf0200f0eb3/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/673670da1e5dae2aaccbade88d540cf0200f0eb3/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=673670da1e5dae2aaccbade88d540cf0200f0eb3", "patch": "@@ -1,3 +1,18 @@\n+2018-11-29  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR c/88172\n+\tPR testsuite/88208\n+\t* gcc.dg/attr-aligned-2.c: New test.\n+\t* gcc.dg/builtin-has-attribute.c: Adjust.\n+\t* c-c++-common/builtin-has-attribute-2.c: Same.\n+\t* c-c++-common/builtin-has-attribute-3.c: Same.\n+\t* c-c++-common/builtin-has-attribute-4.c: Same.\n+\t* c-c++-common/builtin-has-attribute-5.c: New test.\n+\t* gcc.target/aarch64/attr-aligned.c: Same.\n+\t* gcc.target/i386/attr-aligned.c: Same.\n+\t* gcc.target/powerpc/attr-aligned.c: Same.\n+\t* gcc.target/sparc/attr-aligned.c: Same.\n+\n 2018-11-29  qing zhao  <qing.zhao@oracle.com>\n \n \t* gcc.dg/live-patching-1.c: New test."}, {"sha": "f842241015c2b1331f4248563a227f48729b6984", "filename": "gcc/testsuite/c-c++-common/builtin-has-attribute-2.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/673670da1e5dae2aaccbade88d540cf0200f0eb3/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fbuiltin-has-attribute-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/673670da1e5dae2aaccbade88d540cf0200f0eb3/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fbuiltin-has-attribute-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fbuiltin-has-attribute-2.c?ref=673670da1e5dae2aaccbade88d540cf0200f0eb3", "patch": "@@ -42,8 +42,8 @@ void test_type (int n)\n \n   A (0, int ATTR (aligned (4)), aligned (2));\n   A (0, int ATTR (aligned (2)), aligned (4));\n-  /* GCC retains both attributes in the */\n-  A (0, int ATTR (aligned (2), aligned (4)), aligned (2));\n+  /* GCC retains both attributes when the type is defined in the builtin.  */\n+  A (1, int ATTR (aligned (2), aligned (4)), aligned (2));\n   A (1, int ATTR (aligned (2), aligned (4)), aligned (4));\n   /* The following fails due to bug 87524.\n      A (1, int ATTR (aligned (4), aligned (2))), aligned (4)); */\n@@ -132,7 +132,7 @@ void test_typedef (int n)\n   A (1, MAI, may_alias);\n \n   typedef ATTR (aligned (4), may_alias) char A4MAC;\n-  A (0, A4MAC, aligned (0));\n+  A (0, A4MAC, aligned (0));    /* { dg-warning \"requested alignment .0. is not a positive power of 2\" } */\n   A (0, A4MAC, aligned (1));\n   A (0, A4MAC, aligned (2));\n   A (1, A4MAC, aligned (4));\n@@ -141,7 +141,7 @@ void test_typedef (int n)\n \n   typedef ATTR (may_alias, aligned (8)) char A8MAC;\n   A (1, A8MAC, aligned);\n-  A (0, A8MAC, aligned (0));\n+  A (0, A8MAC, aligned (0));    /* { dg-warning \"requested alignment .0. is not a positive power of 2\" } */\n   A (0, A8MAC, aligned (1));\n   A (0, A8MAC, aligned (2));\n   A (0, A8MAC, aligned (4));"}, {"sha": "f0480595da2ad520bcf5cd4fb6ee3b56c6cbf0db", "filename": "gcc/testsuite/c-c++-common/builtin-has-attribute-3.c", "status": "modified", "additions": 4, "deletions": 16, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/673670da1e5dae2aaccbade88d540cf0200f0eb3/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fbuiltin-has-attribute-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/673670da1e5dae2aaccbade88d540cf0200f0eb3/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fbuiltin-has-attribute-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fbuiltin-has-attribute-3.c?ref=673670da1e5dae2aaccbade88d540cf0200f0eb3", "patch": "@@ -35,26 +35,26 @@ ATTR (alias (\"fnoreturn\")) void falias (void);\n void test_aligned (void)\n {\n   A (0, fnone, aligned);\n-  A (0, fnone, aligned (0));\n+  A (0, fnone, aligned (0));            /* { dg-warning \"requested alignment .0. is not a positive power of 2\" } */\n   A (0, fnone, aligned (1));\n   A (0, fnone, aligned (2));\n   A (0, fnone, aligned (4));\n   A (0, fnone, aligned (8));\n   A (0, fnone, aligned (16));\n \n   A (1, faligned, aligned);\n-  A (0, faligned, aligned (0));\n+  A (0, faligned, aligned (0));         /* { dg-warning \"requested alignment .0. is not a positive power of 2\" } */\n   A (0, faligned, aligned (1));\n   A (0, faligned, aligned (2));\n \n   A (1, faligned_1, aligned);\n-  A (0, faligned_1, aligned (0));\n+  A (0, faligned_1, aligned (0));       /* { dg-warning \"requested alignment .0. is not a positive power of 2\" } */\n   A (1, faligned_1, aligned (1));\n   A (0, faligned_1, aligned (2));\n   A (0, faligned_1, aligned (4));\n \n   A (1, faligned_2, aligned);\n-  A (0, faligned_2, aligned (0));\n+  A (0, faligned_2, aligned (0));       /* { dg-warning \"requested alignment .0. is not a positive power of 2\" } */\n   A (0, faligned_2, aligned (1));\n   A (1, faligned_2, aligned (2));\n   A (0, faligned_2, aligned (4));\n@@ -193,18 +193,6 @@ void test_ctor_dtor (void)\n \n   A (1, fctor_dtor, constructor);\n   A (1, fctor_dtor, destructor);\n-\n-  extern ATTR (constructor (123)) void fctor_123 (void);\n-  A (1, fctor_123, constructor);\n-  A (0, fctor_123, destructor);\n-  A (1, fctor_123, constructor (123));\n-  A (0, fctor_123, constructor (124));\n-\n-  extern ATTR (destructor (234)) void fctor_123 (void);\n-  A (1, fctor_123, constructor (123));\n-  A (1, fctor_123, destructor);\n-  A (1, fctor_123, destructor (234));\n-  A (0, fctor_123, destructor (235));\n }\n \n "}, {"sha": "d56ef6bb9a22b66927e2b1179f607bb8fab1e3f6", "filename": "gcc/testsuite/c-c++-common/builtin-has-attribute-4.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/673670da1e5dae2aaccbade88d540cf0200f0eb3/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fbuiltin-has-attribute-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/673670da1e5dae2aaccbade88d540cf0200f0eb3/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fbuiltin-has-attribute-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fbuiltin-has-attribute-4.c?ref=673670da1e5dae2aaccbade88d540cf0200f0eb3", "patch": "@@ -19,26 +19,26 @@ ATTR (aligned (8)) char valigned_8;\n void test_aligned (void)\n {\n   A (0, vnone, aligned);\n-  A (0, vnone, aligned (0));\n+  A (0, vnone, aligned (0));      /* { dg-warning \"requested alignment .0. is not a positive power of 2\" } */\n   A (0, vnone, aligned (1));\n   A (0, vnone, aligned (2));\n   A (0, vnone, aligned (4));\n   A (0, vnone, aligned (8));\n   A (0, vnone, aligned (16));\n \n   A (1, valigned, aligned);\n-  A (0, valigned, aligned (0));\n+  A (0, valigned, aligned (0));   /* { dg-warning \"requested alignment .0. is not a positive power of 2\" } */\n   A (0, valigned, aligned (1));\n   A (0, valigned, aligned (2));\n \n   A (1, valigned_1, aligned);\n-  A (0, valigned_1, aligned (0));\n+  A (0, valigned_1, aligned (0)); /* { dg-warning \"requested alignment .0. is not a positive power of 2\" } */\n   A (1, valigned_1, aligned (1));\n   A (0, valigned_1, aligned (2));\n   A (0, valigned_1, aligned (4));\n \n   A (1, valigned_2, aligned);\n-  A (0, valigned_2, aligned (0));\n+  A (0, valigned_2, aligned (0)); /* { dg-warning \"requested alignment .0. is not a positive power of 2\" } */\n   A (0, valigned_2, aligned (1));\n   A (1, valigned_2, aligned (2));\n   A (0, valigned_2, aligned (4));"}, {"sha": "20d95d85d5edc522453ce41d322d043b934de3cb", "filename": "gcc/testsuite/c-c++-common/builtin-has-attribute-5.c", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/673670da1e5dae2aaccbade88d540cf0200f0eb3/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fbuiltin-has-attribute-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/673670da1e5dae2aaccbade88d540cf0200f0eb3/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fbuiltin-has-attribute-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fbuiltin-has-attribute-5.c?ref=673670da1e5dae2aaccbade88d540cf0200f0eb3", "patch": "@@ -0,0 +1,48 @@\n+/* Verify __builtin_has_attribute return value for attributes constructor\n+   and destructor with explicit priorities.\n+   { dg-do compile { target init_priority } }\n+   { dg-options \"-Wall -ftrack-macro-expansion=0\" }\n+   { dg-options \"-Wall -Wno-narrowing -Wno-unused -ftrack-macro-expansion=0\" { target c++ } }  */\n+\n+#define ATTR(...) __attribute__ ((__VA_ARGS__))\n+\n+#define A(expect, sym, attr)\t\t\t\t\t\t\\\n+  typedef int Assert [1 - 2 * !(__builtin_has_attribute (sym, attr) == expect)]\n+\n+void fnone (void);\n+\n+void test_ctor_dtor_prio (void)\n+{\n+  extern ATTR (constructor) void fctor (void);\n+  extern ATTR (destructor) void fdtor (void);\n+  extern ATTR (constructor, destructor) void fctor_dtor (void);\n+\n+  A (0, fnone, constructor);\n+  A (0, fnone, constructor (123));\n+  A (0, fnone, destructor);\n+  A (0, fnone, constructor (234));\n+\n+  A (1, fctor, constructor);\n+  A (0, fctor, constructor (123));\n+  A (1, fdtor, destructor);\n+  A (0, fdtor, destructor (234));\n+\n+  extern ATTR (constructor) void fctor_dtor (void);\n+  extern ATTR (destructor) void fctor_dtor (void);\n+  extern ATTR (constructor, destructor) void fctor_dtor (void);\n+\n+  A (1, fctor_dtor, constructor);\n+  A (1, fctor_dtor, destructor);\n+\n+  extern ATTR (constructor (123)) void fctor_123 (void);\n+  A (1, fctor_123, constructor);\n+  A (0, fctor_123, destructor);\n+  A (1, fctor_123, constructor (123));\n+  A (0, fctor_123, constructor (124));\n+\n+  extern ATTR (destructor (234)) void fctor_123 (void);\n+  A (1, fctor_123, constructor (123));\n+  A (1, fctor_123, destructor);\n+  A (1, fctor_123, destructor (234));\n+  A (0, fctor_123, destructor (235));\n+}"}, {"sha": "ff6516c41e00b404d94e267f10d0c73e98dbf5a6", "filename": "gcc/testsuite/gcc.dg/attr-aligned-2.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/673670da1e5dae2aaccbade88d540cf0200f0eb3/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-aligned-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/673670da1e5dae2aaccbade88d540cf0200f0eb3/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-aligned-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-aligned-2.c?ref=673670da1e5dae2aaccbade88d540cf0200f0eb3", "patch": "@@ -0,0 +1,21 @@\n+/* PR c/88172 - attribute aligned of zero silently accepted but ignored\n+   Verify that valid alignment on functions is accepted for all targets\n+   and that alignment of zero is ignored with a warning.\n+   { dg-do compile }\n+   { dg-options \"-Wno-pedantic\" }  */\n+\n+#define ASSERT(expr)   _Static_assert (expr, #expr)\n+#define ALIGN(n)       __attribute__ ((aligned (n)))\n+#define alignof(expr)  __alignof__ (expr)\n+\n+ALIGN (0) void f0 (void) { }    /* { dg-warning \"requested alignment .0. is not a positive power of 2\" } */\n+ALIGN (1) void f1 (void) { }\n+ALIGN (2) void f2 (void) { }\n+ALIGN (3) void f3 (void) { }    /* { dg-error \"requested alignment '3' is not a positive power of 2\" } */\n+ALIGN (4) void f4 (void) { }\n+\n+ASSERT (alignof (f0) > 0);\n+ASSERT (alignof (f1) >= 1);\n+ASSERT (alignof (f2) >= 2);\n+ASSERT (alignof (f3) >= 1);\n+ASSERT (alignof (f4) >= 4);"}, {"sha": "9668acec0e2f068f619da9bc480fb00a95525334", "filename": "gcc/testsuite/gcc.dg/builtin-has-attribute.c", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/673670da1e5dae2aaccbade88d540cf0200f0eb3/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-has-attribute.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/673670da1e5dae2aaccbade88d540cf0200f0eb3/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-has-attribute.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-has-attribute.c?ref=673670da1e5dae2aaccbade88d540cf0200f0eb3", "patch": "@@ -3,16 +3,14 @@\n    Also verify that the expression in __builtin_has_attribute is\n    not evaluated.\n \n-  { dg-do run }\n-  { dg-options \"-O2 -Wall -Wc++-compat\" }  */\n+  { dg-do compile }\n+  { dg-options \"-O2 -Wall -Wc++-compat -fdump-tree-optimized -ftrack-macro-expansion=0\" }  */\n \n #define ATTR(list) __attribute__ (list)\n \n #define A(expect, sym, attr)\t\t\t\t\t\t\\\n   typedef int Assert [1 - 2 * !(__builtin_has_attribute (sym, attr) == expect)]\n \n-int nfails;\n-\n #define assert(expr)\t\t\t\t\t\t\\\n   ((expr)\t\t\t\t\t\t\t\\\n    ? (void)0\t\t\t\t\t\t\t\\\n@@ -24,22 +22,27 @@ A (0, struct A { int i; }, aligned);   /* { dg-warning \"expression is invalid in\n A (1, struct ATTR ((aligned)) B { int i; }, aligned);   /* { dg-warning \"expression is invalid in C\\\\\\+\\\\\\+\" } */\n \n \n-int f (void)\n+static int f (void)\n {\n   __builtin_abort ();\n }\n \n-int n = 1;\n-\n int main (void)\n {\n+  int n = 0, nfails = 0;\n+\n   assert (0 == __builtin_has_attribute (int[n++], aligned));\n   assert (1 == __builtin_has_attribute (ATTR ((aligned)) int[n++], aligned));\n   assert (1 == __builtin_has_attribute (ATTR ((aligned)) int[f ()], aligned));\n   assert (1 == 1);\n \n+  if (n)\n+    __builtin_abort ();\n+\n   if (nfails)\n     __builtin_abort ();\n \n   return 0;\n }\n+\n+/* { dg-final { scan-tree-dump-times \"abort\" 0 \"optimized\" } } */"}, {"sha": "fe37dba5efad0fa74774486c23beb6bf51eaab27", "filename": "gcc/testsuite/gcc.target/aarch64/attr-aligned.c", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/673670da1e5dae2aaccbade88d540cf0200f0eb3/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fattr-aligned.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/673670da1e5dae2aaccbade88d540cf0200f0eb3/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fattr-aligned.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fattr-aligned.c?ref=673670da1e5dae2aaccbade88d540cf0200f0eb3", "patch": "@@ -0,0 +1,65 @@\n+/* Verify that valid alignment on functions is accepted and results\n+   in the alignment expected for the target and that alignment of\n+   zero is ignored with a warning.\n+   { dg-do compile }\n+   { dg-options \"-Wno-pedantic -ftrack-macro-expansion=0\" }  */\n+\n+#define ASSERT(expr)     _Static_assert (expr, #expr)\n+#define ALIGN(n)         __attribute__ ((aligned (n)))\n+#define alignof(expr)    __alignof__ (expr)\n+#define HAS_ALIGN(f, n)  __builtin_has_attribute (f, __aligned__ (n))\n+\n+#define MINALIGN(N)   ((N) < 4 ? 4 : (N))\n+#define MAXALIGN      16\n+\n+/* No alignment specified.  */\n+void f (void) { }\n+\n+/* Empty alignment means maximum.  */\n+ALIGN () void f_ (void) { }\n+\n+ALIGN (0) void f0 (void) { }    /* { dg-warning \"requested alignment .0. is not a positive power of 2\" } */\n+ALIGN (1) void f1 (void) { }\n+ALIGN (2) void f2 (void) { }\n+ALIGN (4) void f4 (void) { }\n+ALIGN (8) void f8 (void) { }\n+ALIGN (16) void f16 (void) { }\n+ALIGN (32) void f32 (void) { }\n+\n+ASSERT (alignof (f_) == MAXALIGN);\n+ASSERT (alignof (f0) == alignof (f));\n+ASSERT (alignof (f1) == MINALIGN (1));\n+ASSERT (alignof (f2) == MINALIGN (2));\n+ASSERT (alignof (f4) == MINALIGN (4));\n+ASSERT (alignof (f8) == MINALIGN (8));\n+ASSERT (alignof (f16) == MINALIGN (16));\n+ASSERT (alignof (f32) == MINALIGN (32));\n+\n+ASSERT (!__builtin_has_attribute (f, aligned));\n+ASSERT (__builtin_has_attribute (f_, aligned));\n+ASSERT (!__builtin_has_attribute (f0, aligned));\n+\n+ASSERT (!HAS_ALIGN (f_, MAXALIGN));\n+\n+ASSERT (HAS_ALIGN (f1, 1));\n+ASSERT (!HAS_ALIGN (f1, 2));\n+\n+ASSERT (!HAS_ALIGN (f2, 1));\n+ASSERT (HAS_ALIGN (f2, 2));\n+ASSERT (!HAS_ALIGN (f2, 4));\n+\n+ASSERT (!HAS_ALIGN (f4, 2));\n+ASSERT (HAS_ALIGN (f4, 4));\n+ASSERT (!HAS_ALIGN (f4, 8));\n+\n+ASSERT (!HAS_ALIGN (f8, 4));\n+ASSERT (HAS_ALIGN (f8, 8));\n+ASSERT (!HAS_ALIGN (f8, 16));\n+\n+ASSERT (!HAS_ALIGN (f16, 8));\n+ASSERT (HAS_ALIGN (f16, 16));\n+ASSERT (!HAS_ALIGN (f16, 32));\n+\n+ASSERT (!HAS_ALIGN (f32, 16));\n+ASSERT (HAS_ALIGN (f32, 32));\n+ASSERT (!HAS_ALIGN (f32, 64));"}, {"sha": "1ed9c8ce3058f37b434149f226019446a99497d6", "filename": "gcc/testsuite/gcc.target/i386/attr-aligned.c", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/673670da1e5dae2aaccbade88d540cf0200f0eb3/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fattr-aligned.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/673670da1e5dae2aaccbade88d540cf0200f0eb3/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fattr-aligned.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fattr-aligned.c?ref=673670da1e5dae2aaccbade88d540cf0200f0eb3", "patch": "@@ -0,0 +1,65 @@\n+/* Verify that valid alignment on functions is accepted and results\n+   in the alignment expected for the target and that alignment of\n+   zero is ignored with a warning.\n+   { dg-do compile }\n+   { dg-options \"-Wno-pedantic -ftrack-macro-expansion=0\" }  */\n+\n+#define ASSERT(expr)     _Static_assert (expr, #expr)\n+#define ALIGN(n)         __attribute__ ((aligned (n)))\n+#define alignof(expr)    __alignof__ (expr)\n+#define HAS_ALIGN(f, n)  __builtin_has_attribute (f, __aligned__ (n))\n+\n+#define MINALIGN(N)   N\n+#define MAXALIGN      16\n+\n+/* No alignment specified.  */\n+void f (void) { }\n+\n+/* Empty alignment means maximum.  */\n+ALIGN () void f_ (void) { }\n+\n+ALIGN (0) void f0 (void) { }    /* { dg-warning \"requested alignment .0. is not a positive power of 2\" } */\n+ALIGN (1) void f1 (void) { }\n+ALIGN (2) void f2 (void) { }\n+ALIGN (4) void f4 (void) { }\n+ALIGN (8) void f8 (void) { }\n+ALIGN (16) void f16 (void) { }\n+ALIGN (32) void f32 (void) { }\n+\n+ASSERT (alignof (f_) == MAXALIGN);\n+ASSERT (alignof (f0) == alignof (f));\n+ASSERT (alignof (f1) == MINALIGN (1));\n+ASSERT (alignof (f2) == MINALIGN (2));\n+ASSERT (alignof (f4) == MINALIGN (4));\n+ASSERT (alignof (f8) == MINALIGN (8));\n+ASSERT (alignof (f16) == MINALIGN (16));\n+ASSERT (alignof (f32) == MINALIGN (32));\n+\n+ASSERT (!__builtin_has_attribute (f, aligned));\n+ASSERT (__builtin_has_attribute (f_, aligned));\n+ASSERT (!__builtin_has_attribute (f0, aligned));\n+\n+ASSERT (!HAS_ALIGN (f_, MAXALIGN));\n+\n+ASSERT (HAS_ALIGN (f1, 1));\n+ASSERT (!HAS_ALIGN (f1, 2));\n+\n+ASSERT (!HAS_ALIGN (f2, 1));\n+ASSERT (HAS_ALIGN (f2, 2));\n+ASSERT (!HAS_ALIGN (f2, 4));\n+\n+ASSERT (!HAS_ALIGN (f4, 2));\n+ASSERT (HAS_ALIGN (f4, 4));\n+ASSERT (!HAS_ALIGN (f4, 8));\n+\n+ASSERT (!HAS_ALIGN (f8, 4));\n+ASSERT (HAS_ALIGN (f8, 8));\n+ASSERT (!HAS_ALIGN (f8, 16));\n+\n+ASSERT (!HAS_ALIGN (f16, 8));\n+ASSERT (HAS_ALIGN (f16, 16));\n+ASSERT (!HAS_ALIGN (f16, 32));\n+\n+ASSERT (!HAS_ALIGN (f32, 16));\n+ASSERT (HAS_ALIGN (f32, 32));\n+ASSERT (!HAS_ALIGN (f32, 64));"}, {"sha": "4b5b6661be8c80c305e91c315324a65042a2f16b", "filename": "gcc/testsuite/gcc.target/powerpc/attr-aligned.c", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/673670da1e5dae2aaccbade88d540cf0200f0eb3/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fattr-aligned.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/673670da1e5dae2aaccbade88d540cf0200f0eb3/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fattr-aligned.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fattr-aligned.c?ref=673670da1e5dae2aaccbade88d540cf0200f0eb3", "patch": "@@ -0,0 +1,65 @@\n+/* Verify that valid alignment on functions is accepted and results\n+   in the alignment expected for the target and that alignment of\n+   zero is ignored with a warning.\n+   { dg-do compile }\n+   { dg-options \"-Wno-pedantic -ftrack-macro-expansion=0\" }  */\n+\n+#define ASSERT(expr)     _Static_assert (expr, #expr)\n+#define ALIGN(n)         __attribute__ ((aligned (n)))\n+#define alignof(expr)    __alignof__ (expr)\n+#define HAS_ALIGN(f, n)  __builtin_has_attribute (f, __aligned__ (n))\n+\n+#define MINALIGN(N)   (N < 4 ? 4 : N)\n+#define MAXALIGN      16\n+\n+/* No alignment specified.  */\n+void f (void) { }\n+\n+/* Empty alignment means maximum.  */\n+ALIGN () void f_ (void) { }\n+\n+ALIGN (0) void f0 (void) { }    /* { dg-warning \"requested alignment .0. is not a positive power of 2\" } */\n+ALIGN (1) void f1 (void) { }\n+ALIGN (2) void f2 (void) { }\n+ALIGN (4) void f4 (void) { }\n+ALIGN (8) void f8 (void) { }\n+ALIGN (16) void f16 (void) { }\n+ALIGN (32) void f32 (void) { }\n+\n+ASSERT (alignof (f_) == MAXALIGN);\n+ASSERT (alignof (f0) == alignof (f));\n+ASSERT (alignof (f1) == MINALIGN (1));\n+ASSERT (alignof (f2) == MINALIGN (2));\n+ASSERT (alignof (f4) == MINALIGN (4));\n+ASSERT (alignof (f8) == MINALIGN (8));\n+ASSERT (alignof (f16) == MINALIGN (16));\n+ASSERT (alignof (f32) == MINALIGN (32));\n+\n+ASSERT (!__builtin_has_attribute (f, aligned));\n+ASSERT (__builtin_has_attribute (f_, aligned));\n+ASSERT (!__builtin_has_attribute (f0, aligned));\n+\n+ASSERT (!HAS_ALIGN (f_, MAXALIGN));\n+\n+ASSERT (HAS_ALIGN (f1, 1));\n+ASSERT (!HAS_ALIGN (f1, 2));\n+\n+ASSERT (!HAS_ALIGN (f2, 1));\n+ASSERT (HAS_ALIGN (f2, 2));\n+ASSERT (!HAS_ALIGN (f2, 4));\n+\n+ASSERT (!HAS_ALIGN (f4, 2));\n+ASSERT (HAS_ALIGN (f4, 4));\n+ASSERT (!HAS_ALIGN (f4, 8));\n+\n+ASSERT (!HAS_ALIGN (f8, 4));\n+ASSERT (HAS_ALIGN (f8, 8));\n+ASSERT (!HAS_ALIGN (f8, 16));\n+\n+ASSERT (!HAS_ALIGN (f16, 8));\n+ASSERT (HAS_ALIGN (f16, 16));\n+ASSERT (!HAS_ALIGN (f16, 32));\n+\n+ASSERT (!HAS_ALIGN (f32, 16));\n+ASSERT (HAS_ALIGN (f32, 32));\n+ASSERT (!HAS_ALIGN (f32, 64));"}, {"sha": "7dc9b19b92b8110265ade1cab1ce2c5278827f6f", "filename": "gcc/testsuite/gcc.target/sparc/attr-aligned.c", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/673670da1e5dae2aaccbade88d540cf0200f0eb3/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Fattr-aligned.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/673670da1e5dae2aaccbade88d540cf0200f0eb3/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Fattr-aligned.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsparc%2Fattr-aligned.c?ref=673670da1e5dae2aaccbade88d540cf0200f0eb3", "patch": "@@ -0,0 +1,65 @@\n+/* Verify that valid alignment on functions is accepted and results\n+   in the alignment expected for the target and that alignment of\n+   zero is ignored with a warning.\n+   { dg-do compile }\n+   { dg-options \"-Wno-pedantic -ftrack-macro-expansion=0\" }  */\n+\n+#define ASSERT(expr)     _Static_assert (expr, #expr)\n+#define ALIGN(n)         __attribute__ ((aligned (n)))\n+#define alignof(expr)    __alignof__ (expr)\n+#define HAS_ALIGN(f, n)  __builtin_has_attribute (f, __aligned__ (n))\n+\n+#define MINALIGN(N)   ((N) < 4 ? 4 : (N))\n+#define MAXALIGN      8\n+\n+/* No alignment specified.  */\n+void f (void) { }\n+\n+/* Empty alignment means maximum.  */\n+ALIGN () void f_ (void) { }\n+\n+ALIGN (0) void f0 (void) { }    /* { dg-warning \"requested alignment .0. is not a positive power of 2\" } */\n+ALIGN (1) void f1 (void) { }\n+ALIGN (2) void f2 (void) { }\n+ALIGN (4) void f4 (void) { }\n+ALIGN (8) void f8 (void) { }\n+ALIGN (16) void f16 (void) { }\n+ALIGN (32) void f32 (void) { }\n+\n+ASSERT (alignof (f_) == MAXALIGN);\n+ASSERT (alignof (f0) == alignof (f));\n+ASSERT (alignof (f1) == MINALIGN (1));\n+ASSERT (alignof (f2) == MINALIGN (2));\n+ASSERT (alignof (f4) == MINALIGN (4));\n+ASSERT (alignof (f8) == MINALIGN (8));\n+ASSERT (alignof (f16) == MINALIGN (16));\n+ASSERT (alignof (f32) == MINALIGN (32));\n+\n+ASSERT (!__builtin_has_attribute (f, aligned));\n+ASSERT (__builtin_has_attribute (f_, aligned));\n+ASSERT (!__builtin_has_attribute (f0, aligned));\n+\n+ASSERT (!HAS_ALIGN (f_, MAXALIGN));\n+\n+ASSERT (HAS_ALIGN (f1, 1));\n+ASSERT (!HAS_ALIGN (f1, 2));\n+\n+ASSERT (!HAS_ALIGN (f2, 1));\n+ASSERT (HAS_ALIGN (f2, 2));\n+ASSERT (!HAS_ALIGN (f2, 4));\n+\n+ASSERT (!HAS_ALIGN (f4, 2));\n+ASSERT (HAS_ALIGN (f4, 4));\n+ASSERT (!HAS_ALIGN (f4, 8));\n+\n+ASSERT (!HAS_ALIGN (f8, 4));\n+ASSERT (HAS_ALIGN (f8, 8));\n+ASSERT (!HAS_ALIGN (f8, 16));\n+\n+ASSERT (!HAS_ALIGN (f16, 8));\n+ASSERT (HAS_ALIGN (f16, 16));\n+ASSERT (!HAS_ALIGN (f16, 32));\n+\n+ASSERT (!HAS_ALIGN (f32, 16));\n+ASSERT (HAS_ALIGN (f32, 32));\n+ASSERT (!HAS_ALIGN (f32, 64));"}]}