{"sha": "2660d12d0a69539959dc1f77648f9f29f5e0edf8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjY2MGQxMmQwYTY5NTM5OTU5ZGMxZjc3NjQ4ZjlmMjlmNWUwZWRmOA==", "commit": {"author": {"name": "Kostya Serebryany", "email": "kcc@google.com", "date": "2013-01-23T11:41:33Z"}, "committer": {"name": "Kostya Serebryany", "email": "kcc@gcc.gnu.org", "date": "2013-01-23T11:41:33Z"}, "message": "libsanitizer merge from upstream r173241\n\nFrom-SVN: r195404", "tree": {"sha": "80989bd161e60d01560788cb7427eb644b227884", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/80989bd161e60d01560788cb7427eb644b227884"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2660d12d0a69539959dc1f77648f9f29f5e0edf8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2660d12d0a69539959dc1f77648f9f29f5e0edf8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2660d12d0a69539959dc1f77648f9f29f5e0edf8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2660d12d0a69539959dc1f77648f9f29f5e0edf8/comments", "author": {"login": "kcc", "id": 1789297, "node_id": "MDQ6VXNlcjE3ODkyOTc=", "avatar_url": "https://avatars.githubusercontent.com/u/1789297?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kcc", "html_url": "https://github.com/kcc", "followers_url": "https://api.github.com/users/kcc/followers", "following_url": "https://api.github.com/users/kcc/following{/other_user}", "gists_url": "https://api.github.com/users/kcc/gists{/gist_id}", "starred_url": "https://api.github.com/users/kcc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kcc/subscriptions", "organizations_url": "https://api.github.com/users/kcc/orgs", "repos_url": "https://api.github.com/users/kcc/repos", "events_url": "https://api.github.com/users/kcc/events{/privacy}", "received_events_url": "https://api.github.com/users/kcc/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b39968989d6ae4289c01202c45268b5651d1c222", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b39968989d6ae4289c01202c45268b5651d1c222", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b39968989d6ae4289c01202c45268b5651d1c222"}], "stats": {"total": 2624, "additions": 1564, "deletions": 1060}, "files": [{"sha": "8e5c18b90c23fe4f7d470906de9170d99a32c155", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2660d12d0a69539959dc1f77648f9f29f5e0edf8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2660d12d0a69539959dc1f77648f9f29f5e0edf8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2660d12d0a69539959dc1f77648f9f29f5e0edf8", "patch": "@@ -1,3 +1,7 @@\n+2013-01-23  Kostya Serebryany  <kcc@google.com>\n+\n+\t* config/darwin.h: remove dependency on CoreFoundation (asan on Mac OS).\n+\n 2013-01-23  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR target/49069"}, {"sha": "696451876058defccaba3e9190328d63fe880ffe", "filename": "gcc/config/darwin.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2660d12d0a69539959dc1f77648f9f29f5e0edf8/gcc%2Fconfig%2Fdarwin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2660d12d0a69539959dc1f77648f9f29f5e0edf8/gcc%2Fconfig%2Fdarwin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdarwin.h?ref=2660d12d0a69539959dc1f77648f9f29f5e0edf8", "patch": "@@ -178,7 +178,7 @@ extern GTY(()) int darwin_ms_struct;\n     %{L*} %(link_libgcc) %o %{fprofile-arcs|fprofile-generate*|coverage:-lgcov} \\\n     %{fopenmp|ftree-parallelize-loops=*: \\\n       %{static|static-libgcc|static-libstdc++|static-libgfortran: libgomp.a%s; : -lgomp } } \\\n-    %{fsanitize=address: -framework CoreFoundation -lasan } \\\n+    %{fsanitize=address: -lasan } \\\n     %{fgnu-tm: \\\n       %{static|static-libgcc|static-libstdc++|static-libgfortran: libitm.a%s; : -litm } } \\\n     %{!nostdlib:%{!nodefaultlibs:\\"}, {"sha": "e52cbea54393ea71d618c6b28b39ac135ce67d54", "filename": "libsanitizer/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2660d12d0a69539959dc1f77648f9f29f5e0edf8/libsanitizer%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2660d12d0a69539959dc1f77648f9f29f5e0edf8/libsanitizer%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2FChangeLog?ref=2660d12d0a69539959dc1f77648f9f29f5e0edf8", "patch": "@@ -1,3 +1,9 @@\n+2013-01-23  Kostya Serebryany  <kcc@google.com>\n+\n+        PR sanitizer/55989\n+\t* All source files: Merge from upstream r173241.\n+\t* merge.sh: Support merging .inc files.\n+\n 2013-01-16  Jakub Jelinek  <jakub@redhat.com>\n \n \t* sanitizer_common/Makefile.am (AM_CXXFLAGS): Remove"}, {"sha": "c8e733f1594f02e6e7b0fcc52bd41955c440f912", "filename": "libsanitizer/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2660d12d0a69539959dc1f77648f9f29f5e0edf8/libsanitizer%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2660d12d0a69539959dc1f77648f9f29f5e0edf8/libsanitizer%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2FMERGE?ref=2660d12d0a69539959dc1f77648f9f29f5e0edf8", "patch": "@@ -1,4 +1,4 @@\n-171973\n+173241\n \n The first line of this file holds the svn revision number of the\n last merge done from the master library sources."}, {"sha": "f01d2db9dbcce701739f67b7cbffd897bbfb0cbc", "filename": "libsanitizer/asan/asan_allocator.cc", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2660d12d0a69539959dc1f77648f9f29f5e0edf8/libsanitizer%2Fasan%2Fasan_allocator.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2660d12d0a69539959dc1f77648f9f29f5e0edf8/libsanitizer%2Fasan%2Fasan_allocator.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_allocator.cc?ref=2660d12d0a69539959dc1f77648f9f29f5e0edf8", "patch": "@@ -27,14 +27,14 @@\n #if ASAN_ALLOCATOR_VERSION == 1\n #include \"asan_interceptors.h\"\n #include \"asan_internal.h\"\n-#include \"asan_lock.h\"\n #include \"asan_mapping.h\"\n #include \"asan_stats.h\"\n #include \"asan_report.h\"\n #include \"asan_thread.h\"\n #include \"asan_thread_registry.h\"\n #include \"sanitizer/asan_interface.h\"\n #include \"sanitizer_common/sanitizer_atomic.h\"\n+#include \"sanitizer_common/sanitizer_mutex.h\"\n \n namespace __asan {\n \n@@ -227,7 +227,7 @@ class MallocInfo {\n     AsanChunk *m = 0;\n     AsanChunk **fl = &free_lists_[size_class];\n     {\n-      ScopedLock lock(&mu_);\n+      BlockingMutexLock lock(&mu_);\n       for (uptr i = 0; i < n_chunks; i++) {\n         if (!(*fl)) {\n           *fl = GetNewChunks(size_class);\n@@ -245,7 +245,7 @@ class MallocInfo {\n   void SwallowThreadLocalMallocStorage(AsanThreadLocalMallocStorage *x,\n                                        bool eat_free_lists) {\n     CHECK(flags()->quarantine_size > 0);\n-    ScopedLock lock(&mu_);\n+    BlockingMutexLock lock(&mu_);\n     AsanChunkFifoList *q = &x->quarantine_;\n     if (q->size() > 0) {\n       quarantine_.PushList(q);\n@@ -269,18 +269,18 @@ class MallocInfo {\n   }\n \n   void BypassThreadLocalQuarantine(AsanChunk *chunk) {\n-    ScopedLock lock(&mu_);\n+    BlockingMutexLock lock(&mu_);\n     quarantine_.Push(chunk);\n   }\n \n   AsanChunk *FindChunkByAddr(uptr addr) {\n-    ScopedLock lock(&mu_);\n+    BlockingMutexLock lock(&mu_);\n     return FindChunkByAddrUnlocked(addr);\n   }\n \n   uptr AllocationSize(uptr ptr) {\n     if (!ptr) return 0;\n-    ScopedLock lock(&mu_);\n+    BlockingMutexLock lock(&mu_);\n \n     // Make sure this is our chunk and |ptr| actually points to the beginning\n     // of the allocated memory.\n@@ -303,7 +303,7 @@ class MallocInfo {\n   }\n \n   void PrintStatus() {\n-    ScopedLock lock(&mu_);\n+    BlockingMutexLock lock(&mu_);\n     uptr malloced = 0;\n \n     Printf(\" MallocInfo: in quarantine: %zu malloced: %zu; \",\n@@ -321,7 +321,7 @@ class MallocInfo {\n   }\n \n   PageGroup *FindPageGroup(uptr addr) {\n-    ScopedLock lock(&mu_);\n+    BlockingMutexLock lock(&mu_);\n     return FindPageGroupUnlocked(addr);\n   }\n \n@@ -479,7 +479,7 @@ class MallocInfo {\n \n   AsanChunk *free_lists_[kNumberOfSizeClasses];\n   AsanChunkFifoList quarantine_;\n-  AsanLock mu_;\n+  BlockingMutex mu_;\n \n   PageGroup *page_groups_[kMaxAvailableRam / kMinMmapSize];\n   atomic_uint32_t n_page_groups_;"}, {"sha": "cc16ce85497fa73dc2a3f3b8133ae24be969aac7", "filename": "libsanitizer/asan/asan_allocator.h", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2660d12d0a69539959dc1f77648f9f29f5e0edf8/libsanitizer%2Fasan%2Fasan_allocator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2660d12d0a69539959dc1f77648f9f29f5e0edf8/libsanitizer%2Fasan%2Fasan_allocator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_allocator.h?ref=2660d12d0a69539959dc1f77648f9f29f5e0edf8", "patch": "@@ -20,8 +20,14 @@\n // We are in the process of transitioning from the old allocator (version 1)\n // to a new one (version 2). The change is quite intrusive so both allocators\n // will co-exist in the source base for a while. The actual allocator is chosen\n-// at build time by redefining this macrozz.\n-#define ASAN_ALLOCATOR_VERSION 1\n+// at build time by redefining this macro.\n+#ifndef ASAN_ALLOCATOR_VERSION\n+# if ASAN_LINUX && !ASAN_ANDROID\n+#  define ASAN_ALLOCATOR_VERSION 2\n+# else\n+#  define ASAN_ALLOCATOR_VERSION 1\n+# endif\n+#endif  // ASAN_ALLOCATOR_VERSION\n \n namespace __asan {\n \n@@ -96,17 +102,21 @@ class AsanChunkFifoList: public IntrusiveList<AsanChunk> {\n \n struct AsanThreadLocalMallocStorage {\n   explicit AsanThreadLocalMallocStorage(LinkerInitialized x)\n-      : quarantine_(x) { }\n+#if ASAN_ALLOCATOR_VERSION == 1\n+      : quarantine_(x)\n+#endif\n+      { }\n   AsanThreadLocalMallocStorage() {\n     CHECK(REAL(memset));\n     REAL(memset)(this, 0, sizeof(AsanThreadLocalMallocStorage));\n   }\n \n-  AsanChunkFifoList quarantine_;\n #if ASAN_ALLOCATOR_VERSION == 1\n+  AsanChunkFifoList quarantine_;\n   AsanChunk *free_lists_[kNumberOfSizeClasses];\n #else\n-  uptr allocator2_cache[1024];  // Opaque.\n+  uptr quarantine_cache[16];\n+  uptr allocator2_cache[96 * (512 * 8 + 16)];  // Opaque.\n #endif\n   void CommitBack();\n };"}, {"sha": "4aa5141f2a789124a1d26ac81b32292884fc5e3a", "filename": "libsanitizer/asan/asan_allocator2.cc", "status": "modified", "additions": 62, "deletions": 68, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2660d12d0a69539959dc1f77648f9f29f5e0edf8/libsanitizer%2Fasan%2Fasan_allocator2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2660d12d0a69539959dc1f77648f9f29f5e0edf8/libsanitizer%2Fasan%2Fasan_allocator2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_allocator2.cc?ref=2660d12d0a69539959dc1f77648f9f29f5e0edf8", "patch": "@@ -25,6 +25,7 @@\n #include \"sanitizer_common/sanitizer_internal_defs.h\"\n #include \"sanitizer_common/sanitizer_list.h\"\n #include \"sanitizer_common/sanitizer_stackdepot.h\"\n+#include \"sanitizer_common/sanitizer_quarantine.h\"\n \n namespace __asan {\n \n@@ -90,15 +91,6 @@ static const uptr kMaxThreadLocalQuarantine =\n \n static const uptr kReturnOnZeroMalloc = 2048;  // Zero page is protected.\n \n-static int inited = 0;\n-\n-static void Init() {\n-  if (inited) return;\n-  __asan_init();\n-  inited = true;  // this must happen before any threads are created.\n-  allocator.Init();\n-}\n-\n // Every chunk of memory allocated by this allocator can be in one of 3 states:\n // CHUNK_AVAILABLE: the chunk is in the free list and ready to be allocated.\n // CHUNK_ALLOCATED: the chunk is allocated and not yet freed.\n@@ -244,31 +236,26 @@ void AsanChunkView::GetFreeStack(StackTrace *stack) {\n                                 chunk_->FreeStackSize());\n }\n \n-class Quarantine: public AsanChunkFifoList {\n- public:\n-  void SwallowThreadLocalQuarantine(AsanThreadLocalMallocStorage *ms) {\n-    AsanChunkFifoList *q = &ms->quarantine_;\n-    if (!q->size()) return;\n-    SpinMutexLock l(&mutex_);\n-    PushList(q);\n-    PopAndDeallocateLoop(ms);\n-  }\n+struct QuarantineCallback;\n+typedef Quarantine<QuarantineCallback, AsanChunk> AsanQuarantine;\n+typedef AsanQuarantine::Cache QuarantineCache;\n+static AsanQuarantine quarantine(LINKER_INITIALIZED);\n+static QuarantineCache fallback_quarantine_cache(LINKER_INITIALIZED);\n+static AllocatorCache fallback_allocator_cache;\n+static SpinMutex fallback_mutex;\n \n-  void BypassThreadLocalQuarantine(AsanChunk *m) {\n-    SpinMutexLock l(&mutex_);\n-    Push(m);\n-  }\n+QuarantineCache *GetQuarantineCache(AsanThreadLocalMallocStorage *ms) {\n+  CHECK(ms);\n+  CHECK_LE(sizeof(QuarantineCache), sizeof(ms->quarantine_cache));\n+  return reinterpret_cast<QuarantineCache *>(ms->quarantine_cache);\n+}\n \n- private:\n-  void PopAndDeallocateLoop(AsanThreadLocalMallocStorage *ms) {\n-    while (size() > (uptr)flags()->quarantine_size) {\n-      PopAndDeallocate(ms);\n-    }\n+struct QuarantineCallback {\n+  explicit QuarantineCallback(AllocatorCache *cache)\n+      : cache_(cache) {\n   }\n-  void PopAndDeallocate(AsanThreadLocalMallocStorage *ms) {\n-    CHECK_GT(size(), 0);\n-    AsanChunk *m = Pop();\n-    CHECK(m);\n+\n+  void Recycle(AsanChunk *m) {\n     CHECK(m->chunk_state == CHUNK_QUARANTINE);\n     m->chunk_state = CHUNK_AVAILABLE;\n     CHECK_NE(m->alloc_tid, kInvalidTid);\n@@ -288,34 +275,27 @@ class Quarantine: public AsanChunkFifoList {\n     thread_stats.real_frees++;\n     thread_stats.really_freed += m->UsedSize();\n \n-    allocator.Deallocate(GetAllocatorCache(ms), p);\n+    allocator.Deallocate(cache_, p);\n   }\n-  SpinMutex mutex_;\n-};\n \n-static Quarantine quarantine;\n+  void *Allocate(uptr size) {\n+    return allocator.Allocate(cache_, size, 1, false);\n+  }\n \n-void AsanChunkFifoList::PushList(AsanChunkFifoList *q) {\n-  CHECK(q->size() > 0);\n-  size_ += q->size();\n-  append_back(q);\n-  q->clear();\n-}\n+  void Deallocate(void *p) {\n+    allocator.Deallocate(cache_, p);\n+  }\n \n-void AsanChunkFifoList::Push(AsanChunk *n) {\n-  push_back(n);\n-  size_ += n->UsedSize();\n-}\n+  AllocatorCache *cache_;\n+};\n \n-// Interesting performance observation: this function takes up to 15% of overal\n-// allocator time. That's because *first_ has been evicted from cache long time\n-// ago. Not sure if we can or want to do anything with this.\n-AsanChunk *AsanChunkFifoList::Pop() {\n-  CHECK(first_);\n-  AsanChunk *res = front();\n-  size_ -= res->UsedSize();\n-  pop_front();\n-  return res;\n+static void Init() {\n+  static int inited = 0;\n+  if (inited) return;\n+  __asan_init();\n+  inited = true;  // this must happen before any threads are created.\n+  allocator.Init();\n+  quarantine.Init((uptr)flags()->quarantine_size, kMaxThreadLocalQuarantine);\n }\n \n static void *Allocate(uptr size, uptr alignment, StackTrace *stack,\n@@ -355,9 +335,18 @@ static void *Allocate(uptr size, uptr alignment, StackTrace *stack,\n   }\n \n   AsanThread *t = asanThreadRegistry().GetCurrent();\n-  AllocatorCache *cache = t ? GetAllocatorCache(&t->malloc_storage()) : 0;\n-  void *allocated = allocator.Allocate(cache, needed_size, 8, false);\n+  void *allocated;\n+  if (t) {\n+    AllocatorCache *cache = GetAllocatorCache(&t->malloc_storage());\n+    allocated = allocator.Allocate(cache, needed_size, 8, false);\n+  } else {\n+    SpinMutexLock l(&fallback_mutex);\n+    AllocatorCache *cache = &fallback_allocator_cache;\n+    allocated = allocator.Allocate(cache, needed_size, 8, false);\n+  }\n   uptr alloc_beg = reinterpret_cast<uptr>(allocated);\n+  // Clear the first allocated word (an old kMemalignMagic may still be there).\n+  reinterpret_cast<uptr *>(alloc_beg)[0] = 0;\n   uptr alloc_end = alloc_beg + needed_size;\n   uptr beg_plus_redzone = alloc_beg + rz_size;\n   uptr user_beg = beg_plus_redzone;\n@@ -432,7 +421,7 @@ static void Deallocate(void *ptr, StackTrace *stack, AllocType alloc_type) {\n \n   // Flip the chunk_state atomically to avoid race on double-free.\n   u8 old_chunk_state = atomic_exchange((atomic_uint8_t*)m, CHUNK_QUARANTINE,\n-                                       memory_order_acq_rel);\n+                                       memory_order_relaxed);\n \n   if (old_chunk_state == CHUNK_QUARANTINE)\n     ReportDoubleFree((uptr)ptr, stack);\n@@ -466,13 +455,15 @@ static void Deallocate(void *ptr, StackTrace *stack, AllocType alloc_type) {\n \n   // Push into quarantine.\n   if (t) {\n-    AsanChunkFifoList &q = t->malloc_storage().quarantine_;\n-    q.Push(m);\n-\n-    if (q.size() > kMaxThreadLocalQuarantine)\n-      quarantine.SwallowThreadLocalQuarantine(&t->malloc_storage());\n+    AsanThreadLocalMallocStorage *ms = &t->malloc_storage();\n+    AllocatorCache *ac = GetAllocatorCache(ms);\n+    quarantine.Put(GetQuarantineCache(ms), QuarantineCallback(ac),\n+                   m, m->UsedSize());\n   } else {\n-    quarantine.BypassThreadLocalQuarantine(m);\n+    SpinMutexLock l(&fallback_mutex);\n+    AllocatorCache *ac = &fallback_allocator_cache;\n+    quarantine.Put(&fallback_quarantine_cache, QuarantineCallback(ac),\n+                   m, m->UsedSize());\n   }\n \n   ASAN_FREE_HOOK(ptr);\n@@ -584,7 +575,8 @@ AsanChunkView FindHeapChunkByAddress(uptr addr) {\n }\n \n void AsanThreadLocalMallocStorage::CommitBack() {\n-  quarantine.SwallowThreadLocalQuarantine(this);\n+  AllocatorCache *ac = GetAllocatorCache(this);\n+  quarantine.Drain(GetQuarantineCache(this), QuarantineCallback(ac));\n   allocator.SwallowCache(GetAllocatorCache(this));\n }\n \n@@ -681,16 +673,18 @@ uptr __asan_get_estimated_allocated_size(uptr size) {\n }\n \n bool __asan_get_ownership(const void *p) {\n-  return AllocationSize(reinterpret_cast<uptr>(p)) > 0;\n+  uptr ptr = reinterpret_cast<uptr>(p);\n+  return (ptr == kReturnOnZeroMalloc) || (AllocationSize(ptr) > 0);\n }\n \n uptr __asan_get_allocated_size(const void *p) {\n   if (p == 0) return 0;\n-  uptr allocated_size = AllocationSize(reinterpret_cast<uptr>(p));\n+  uptr ptr = reinterpret_cast<uptr>(p);\n+  uptr allocated_size = AllocationSize(ptr);\n   // Die if p is not malloced or if it is already freed.\n-  if (allocated_size == 0) {\n+  if (allocated_size == 0 && ptr != kReturnOnZeroMalloc) {\n     GET_STACK_TRACE_FATAL_HERE;\n-    ReportAsanGetAllocatedSizeNotOwned(reinterpret_cast<uptr>(p), &stack);\n+    ReportAsanGetAllocatedSizeNotOwned(ptr, &stack);\n   }\n   return allocated_size;\n }"}, {"sha": "88aeefa8fe5e75ba24e49388a28d43d488a334aa", "filename": "libsanitizer/asan/asan_globals.cc", "status": "modified", "additions": 7, "deletions": 25, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2660d12d0a69539959dc1f77648f9f29f5e0edf8/libsanitizer%2Fasan%2Fasan_globals.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2660d12d0a69539959dc1f77648f9f29f5e0edf8/libsanitizer%2Fasan%2Fasan_globals.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_globals.cc?ref=2660d12d0a69539959dc1f77648f9f29f5e0edf8", "patch": "@@ -11,13 +11,13 @@\n //===----------------------------------------------------------------------===//\n #include \"asan_interceptors.h\"\n #include \"asan_internal.h\"\n-#include \"asan_lock.h\"\n #include \"asan_mapping.h\"\n #include \"asan_report.h\"\n #include \"asan_stack.h\"\n #include \"asan_stats.h\"\n #include \"asan_thread.h\"\n #include \"sanitizer/asan_interface.h\"\n+#include \"sanitizer_common/sanitizer_mutex.h\"\n \n namespace __asan {\n \n@@ -28,7 +28,7 @@ struct ListOfGlobals {\n   ListOfGlobals *next;\n };\n \n-static AsanLock mu_for_globals(LINKER_INITIALIZED);\n+static BlockingMutex mu_for_globals(LINKER_INITIALIZED);\n static LowLevelAllocator allocator_for_globals;\n static ListOfGlobals *list_of_all_globals;\n static ListOfGlobals *list_of_dynamic_init_globals;\n@@ -53,14 +53,9 @@ void PoisonRedZones(const Global &g)  {\n   }\n }\n \n-static uptr GetAlignedSize(uptr size) {\n-  return ((size + kGlobalAndStackRedzone - 1) / kGlobalAndStackRedzone)\n-      * kGlobalAndStackRedzone;\n-}\n-\n bool DescribeAddressIfGlobal(uptr addr) {\n   if (!flags()->report_globals) return false;\n-  ScopedLock lock(&mu_for_globals);\n+  BlockingMutexLock lock(&mu_for_globals);\n   bool res = false;\n   for (ListOfGlobals *l = list_of_all_globals; l; l = l->next) {\n     const Global &g = *l->g;\n@@ -140,23 +135,10 @@ static void UnpoisonGlobal(const Global *g) {\n // ---------------------- Interface ---------------- {{{1\n using namespace __asan;  // NOLINT\n \n-// Register one global with a default redzone.\n-void __asan_register_global(uptr addr, uptr size,\n-                            const char *name) {\n-  if (!flags()->report_globals) return;\n-  ScopedLock lock(&mu_for_globals);\n-  Global *g = (Global *)allocator_for_globals.Allocate(sizeof(Global));\n-  g->beg = addr;\n-  g->size = size;\n-  g->size_with_redzone = GetAlignedSize(size) + kGlobalAndStackRedzone;\n-  g->name = name;\n-  RegisterGlobal(g);\n-}\n-\n // Register an array of globals.\n void __asan_register_globals(__asan_global *globals, uptr n) {\n   if (!flags()->report_globals) return;\n-  ScopedLock lock(&mu_for_globals);\n+  BlockingMutexLock lock(&mu_for_globals);\n   for (uptr i = 0; i < n; i++) {\n     RegisterGlobal(&globals[i]);\n   }\n@@ -166,7 +148,7 @@ void __asan_register_globals(__asan_global *globals, uptr n) {\n // We must do this when a shared objects gets dlclosed.\n void __asan_unregister_globals(__asan_global *globals, uptr n) {\n   if (!flags()->report_globals) return;\n-  ScopedLock lock(&mu_for_globals);\n+  BlockingMutexLock lock(&mu_for_globals);\n   for (uptr i = 0; i < n; i++) {\n     UnregisterGlobal(&globals[i]);\n   }\n@@ -179,7 +161,7 @@ void __asan_unregister_globals(__asan_global *globals, uptr n) {\n void __asan_before_dynamic_init(uptr first_addr, uptr last_addr) {\n   if (!flags()->check_initialization_order) return;\n   CHECK(list_of_dynamic_init_globals);\n-  ScopedLock lock(&mu_for_globals);\n+  BlockingMutexLock lock(&mu_for_globals);\n   bool from_current_tu = false;\n   // The list looks like:\n   // a => ... => b => last_addr => ... => first_addr => c => ...\n@@ -200,7 +182,7 @@ void __asan_before_dynamic_init(uptr first_addr, uptr last_addr) {\n // TU are poisoned.  It simply unpoisons all dynamically initialized globals.\n void __asan_after_dynamic_init() {\n   if (!flags()->check_initialization_order) return;\n-  ScopedLock lock(&mu_for_globals);\n+  BlockingMutexLock lock(&mu_for_globals);\n   for (ListOfGlobals *l = list_of_dynamic_init_globals; l; l = l->next)\n     UnpoisonGlobal(l->g);\n }"}, {"sha": "2d678ab70005f202396d6cc6a1f05c4c1ba5026d", "filename": "libsanitizer/asan/asan_intercepted_functions.h", "status": "modified", "additions": 54, "deletions": 16, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2660d12d0a69539959dc1f77648f9f29f5e0edf8/libsanitizer%2Fasan%2Fasan_intercepted_functions.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2660d12d0a69539959dc1f77648f9f29f5e0edf8/libsanitizer%2Fasan%2Fasan_intercepted_functions.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_intercepted_functions.h?ref=2660d12d0a69539959dc1f77648f9f29f5e0edf8", "patch": "@@ -16,6 +16,8 @@\n #include \"interception/interception.h\"\n #include \"sanitizer_common/sanitizer_platform_interceptors.h\"\n \n+#include <stdarg.h>\n+\n using __sanitizer::uptr;\n \n // Use macro to describe if specific function should be\n@@ -40,10 +42,8 @@ using __sanitizer::uptr;\n \n #if defined(__linux__)\n # define ASAN_USE_ALIAS_ATTRIBUTE_FOR_INDEX 1\n-# define ASAN_INTERCEPT_PRCTL 1\n #else\n # define ASAN_USE_ALIAS_ATTRIBUTE_FOR_INDEX 0\n-# define ASAN_INTERCEPT_PRCTL 0\n #endif\n \n #if !defined(__APPLE__)\n@@ -105,7 +105,7 @@ DECLARE_FUNCTION_AND_WRAPPER(void, siglongjmp, void *env, int value);\n # endif\n # if ASAN_INTERCEPT___CXA_THROW\n DECLARE_FUNCTION_AND_WRAPPER(void, __cxa_throw, void *a, void *b, void *c);\n-#endif\n+# endif\n \n // string.h / strings.h\n DECLARE_FUNCTION_AND_WRAPPER(int, memcmp,\n@@ -139,9 +139,9 @@ DECLARE_FUNCTION_AND_WRAPPER(char*, strdup, const char *s);\n # if ASAN_INTERCEPT_STRNLEN\n DECLARE_FUNCTION_AND_WRAPPER(uptr, strnlen, const char *s, uptr maxlen);\n # endif\n-#if ASAN_INTERCEPT_INDEX\n+# if ASAN_INTERCEPT_INDEX\n DECLARE_FUNCTION_AND_WRAPPER(char*, index, const char *string, int c);\n-#endif\n+# endif\n \n // stdlib.h\n DECLARE_FUNCTION_AND_WRAPPER(int, atoi, const char *nptr);\n@@ -165,6 +165,13 @@ DECLARE_FUNCTION_AND_WRAPPER(SSIZE_T, pread64, int fd, void *buf,\n                              SIZE_T count, OFF64_T offset);\n # endif\n \n+# if SANITIZER_INTERCEPT_WRITE\n+DECLARE_FUNCTION_AND_WRAPPER(SSIZE_T, write, int fd, void *ptr, SIZE_T count);\n+# endif\n+# if SANITIZER_INTERCEPT_PWRITE\n+DECLARE_FUNCTION_AND_WRAPPER(SSIZE_T, pwrite, int fd, void *ptr, SIZE_T count);\n+# endif\n+\n # if ASAN_INTERCEPT_MLOCKX\n // mlock/munlock\n DECLARE_FUNCTION_AND_WRAPPER(int, mlock, const void *addr, SIZE_T len);\n@@ -186,7 +193,18 @@ DECLARE_FUNCTION_AND_WRAPPER(int, pthread_create,\n                              void *(*start_routine)(void*), void *arg);\n # endif\n \n-#if defined(__APPLE__)\n+DECLARE_FUNCTION_AND_WRAPPER(int, vscanf, const char *format, va_list ap);\n+DECLARE_FUNCTION_AND_WRAPPER(int, vsscanf, const char *str, const char *format,\n+                             va_list ap);\n+DECLARE_FUNCTION_AND_WRAPPER(int, vfscanf, void *stream, const char *format,\n+                             va_list ap);\n+DECLARE_FUNCTION_AND_WRAPPER(int, scanf, const char *format, ...);\n+DECLARE_FUNCTION_AND_WRAPPER(int, fscanf,\n+                             void* stream, const char *format, ...);\n+DECLARE_FUNCTION_AND_WRAPPER(int, sscanf,  // NOLINT\n+                             const char *str, const char *format, ...);\n+\n+# if defined(__APPLE__)\n typedef void* pthread_workqueue_t;\n typedef void* pthread_workitem_handle_t;\n \n@@ -196,8 +214,6 @@ typedef void* dispatch_source_t;\n typedef u64 dispatch_time_t;\n typedef void (*dispatch_function_t)(void *block);\n typedef void* (*worker_t)(void *block);\n-typedef void* CFStringRef;\n-typedef void* CFAllocatorRef;\n \n DECLARE_FUNCTION_AND_WRAPPER(void, dispatch_async_f,\n                              dispatch_queue_t dq,\n@@ -215,11 +231,7 @@ DECLARE_FUNCTION_AND_WRAPPER(void, dispatch_group_async_f,\n                              dispatch_group_t group, dispatch_queue_t dq,\n                              void *ctxt, dispatch_function_t func);\n \n-DECLARE_FUNCTION_AND_WRAPPER(void, __CFInitialize, void);\n-DECLARE_FUNCTION_AND_WRAPPER(CFStringRef, CFStringCreateCopy,\n-                             CFAllocatorRef alloc, CFStringRef str);\n-DECLARE_FUNCTION_AND_WRAPPER(void, free, void* ptr);\n-#if MAC_INTERPOSE_FUNCTIONS && !defined(MISSING_BLOCKS_SUPPORT)\n+#  if MAC_INTERPOSE_FUNCTIONS && !defined(MISSING_BLOCKS_SUPPORT)\n DECLARE_FUNCTION_AND_WRAPPER(void, dispatch_group_async,\n                              dispatch_group_t dg,\n                              dispatch_queue_t dq, void (^work)(void));\n@@ -231,9 +243,35 @@ DECLARE_FUNCTION_AND_WRAPPER(void, dispatch_source_set_event_handler,\n                              dispatch_source_t ds, void (^work)(void));\n DECLARE_FUNCTION_AND_WRAPPER(void, dispatch_source_set_cancel_handler,\n                              dispatch_source_t ds, void (^work)(void));\n-#endif  // MAC_INTERPOSE_FUNCTIONS\n-#endif  // __APPLE__\n+#  endif  // MAC_INTERPOSE_FUNCTIONS\n+\n+typedef void malloc_zone_t;\n+typedef size_t vm_size_t;\n+DECLARE_FUNCTION_AND_WRAPPER(malloc_zone_t *, malloc_create_zone,\n+                             vm_size_t start_size, unsigned flags);\n+DECLARE_FUNCTION_AND_WRAPPER(malloc_zone_t *, malloc_default_zone, void);\n+DECLARE_FUNCTION_AND_WRAPPER(\n+    malloc_zone_t *, malloc_default_purgeable_zone, void);\n+DECLARE_FUNCTION_AND_WRAPPER(void, malloc_make_purgeable, void *ptr);\n+DECLARE_FUNCTION_AND_WRAPPER(int, malloc_make_nonpurgeable, void *ptr);\n+DECLARE_FUNCTION_AND_WRAPPER(void, malloc_set_zone_name,\n+                             malloc_zone_t *zone, const char *name);\n+DECLARE_FUNCTION_AND_WRAPPER(void *, malloc, size_t size);\n+DECLARE_FUNCTION_AND_WRAPPER(void, free, void *ptr);\n+DECLARE_FUNCTION_AND_WRAPPER(void *, realloc, void *ptr, size_t size);\n+DECLARE_FUNCTION_AND_WRAPPER(void *, calloc, size_t nmemb, size_t size);\n+DECLARE_FUNCTION_AND_WRAPPER(void *, valloc, size_t size);\n+DECLARE_FUNCTION_AND_WRAPPER(size_t, malloc_good_size, size_t size);\n+DECLARE_FUNCTION_AND_WRAPPER(int, posix_memalign,\n+                             void **memptr, size_t alignment, size_t size);\n+DECLARE_FUNCTION_AND_WRAPPER(void, _malloc_fork_prepare, void);\n+DECLARE_FUNCTION_AND_WRAPPER(void, _malloc_fork_parent, void);\n+DECLARE_FUNCTION_AND_WRAPPER(void, _malloc_fork_child, void);\n+\n+\n+\n+# endif  // __APPLE__\n }  // extern \"C\"\n-#endif\n+#endif  // defined(__APPLE__) || (defined(_WIN32) && !defined(_DLL))\n \n #endif  // ASAN_INTERCEPTED_FUNCTIONS_H"}, {"sha": "98329f38e61b7ec7ce28ca744fbaeb42b17f9310", "filename": "libsanitizer/asan/asan_interceptors.cc", "status": "modified", "additions": 36, "deletions": 29, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2660d12d0a69539959dc1f77648f9f29f5e0edf8/libsanitizer%2Fasan%2Fasan_interceptors.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2660d12d0a69539959dc1f77648f9f29f5e0edf8/libsanitizer%2Fasan%2Fasan_interceptors.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_interceptors.cc?ref=2660d12d0a69539959dc1f77648f9f29f5e0edf8", "patch": "@@ -73,15 +73,30 @@ static inline uptr MaybeRealStrnlen(const char *s, uptr maxlen) {\n   return internal_strnlen(s, maxlen);\n }\n \n+void SetThreadName(const char *name) {\n+  AsanThread *t = asanThreadRegistry().GetCurrent();\n+  if (t)\n+    t->summary()->set_name(name);\n+}\n+\n }  // namespace __asan\n \n // ---------------------- Wrappers ---------------- {{{1\n using namespace __asan;  // NOLINT\n \n-#define COMMON_INTERCEPTOR_WRITE_RANGE(ptr, size) ASAN_WRITE_RANGE(ptr, size)\n-#define COMMON_INTERCEPTOR_READ_RANGE(ptr, size) ASAN_READ_RANGE(ptr, size)\n-#define COMMON_INTERCEPTOR_ENTER(func, ...) ENSURE_ASAN_INITED()\n-#include \"sanitizer_common/sanitizer_common_interceptors.h\"\n+#define COMMON_INTERCEPTOR_WRITE_RANGE(ctx, ptr, size) \\\n+  ASAN_WRITE_RANGE(ptr, size)\n+#define COMMON_INTERCEPTOR_READ_RANGE(ctx, ptr, size) ASAN_READ_RANGE(ptr, size)\n+#define COMMON_INTERCEPTOR_ENTER(ctx, func, ...) \\\n+  do {                                           \\\n+    ctx = 0;                                     \\\n+    (void)ctx;                                   \\\n+    ENSURE_ASAN_INITED();                        \\\n+  } while (false)\n+#define COMMON_INTERCEPTOR_FD_ACQUIRE(ctx, fd) do { } while (false)\n+#define COMMON_INTERCEPTOR_FD_RELEASE(ctx, fd) do { } while (false)\n+#define COMMON_INTERCEPTOR_SET_THREAD_NAME(ctx, name) SetThreadName(name)\n+#include \"sanitizer_common/sanitizer_common_interceptors.inc\"\n \n static thread_return_t THREAD_CALLING_CONV asan_thread_start(void *arg) {\n   AsanThread *t = (AsanThread*)arg;\n@@ -122,6 +137,18 @@ DEFINE_REAL(int, sigaction, int signum, const struct sigaction *act,\n #endif  // ASAN_INTERCEPT_SIGNAL_AND_SIGACTION\n \n #if ASAN_INTERCEPT_SWAPCONTEXT\n+static void ClearShadowMemoryForContextStack(uptr stack, uptr ssize) {\n+  // Align to page size.\n+  uptr PageSize = GetPageSizeCached();\n+  uptr bottom = stack & ~(PageSize - 1);\n+  ssize += stack - bottom;\n+  ssize = RoundUpTo(ssize, PageSize);\n+  static const uptr kMaxSaneContextStackSize = 1 << 22;  // 4 Mb\n+  if (ssize && ssize <= kMaxSaneContextStackSize) {\n+    PoisonShadow(bottom, ssize, 0);\n+  }\n+}\n+\n INTERCEPTOR(int, swapcontext, struct ucontext_t *oucp,\n             struct ucontext_t *ucp) {\n   static bool reported_warning = false;\n@@ -132,16 +159,18 @@ INTERCEPTOR(int, swapcontext, struct ucontext_t *oucp,\n   }\n   // Clear shadow memory for new context (it may share stack\n   // with current context).\n-  ClearShadowMemoryForContext(ucp);\n+  uptr stack, ssize;\n+  ReadContextStack(ucp, &stack, &ssize);\n+  ClearShadowMemoryForContextStack(stack, ssize);\n   int res = REAL(swapcontext)(oucp, ucp);\n   // swapcontext technically does not return, but program may swap context to\n   // \"oucp\" later, that would look as if swapcontext() returned 0.\n   // We need to clear shadow for ucp once again, as it may be in arbitrary\n   // state.\n-  ClearShadowMemoryForContext(ucp);\n+  ClearShadowMemoryForContextStack(stack, ssize);\n   return res;\n }\n-#endif\n+#endif  // ASAN_INTERCEPT_SWAPCONTEXT\n \n INTERCEPTOR(void, longjmp, void *env, int val) {\n   __asan_handle_no_return();\n@@ -162,25 +191,6 @@ INTERCEPTOR(void, siglongjmp, void *env, int val) {\n }\n #endif\n \n-#if ASAN_INTERCEPT_PRCTL\n-#define PR_SET_NAME 15\n-INTERCEPTOR(int, prctl, int option,\n-            unsigned long arg2, unsigned long arg3,  // NOLINT\n-            unsigned long arg4, unsigned long arg5) {  // NOLINT\n-  int res = REAL(prctl(option, arg2, arg3, arg4, arg5));\n-  if (option == PR_SET_NAME) {\n-    AsanThread *t = asanThreadRegistry().GetCurrent();\n-    if (t) {\n-      char buff[17];\n-      internal_strncpy(buff, (char*)arg2, 16);\n-      buff[16] = 0;\n-      t->summary()->set_name(buff);\n-    }\n-  }\n-  return res;\n-}\n-#endif\n-\n #if ASAN_INTERCEPT___CXA_THROW\n INTERCEPTOR(void, __cxa_throw, void *a, void *b, void *c) {\n   CHECK(REAL(__cxa_throw));\n@@ -727,9 +737,6 @@ void InitializeAsanInterceptors() {\n #if ASAN_INTERCEPT_SIGLONGJMP\n   ASAN_INTERCEPT_FUNC(siglongjmp);\n #endif\n-#if ASAN_INTERCEPT_PRCTL\n-  ASAN_INTERCEPT_FUNC(prctl);\n-#endif\n \n   // Intercept exception handling functions.\n #if ASAN_INTERCEPT___CXA_THROW"}, {"sha": "a9c6c0f9022502cb1b455bd2a3b65f5741a2752c", "filename": "libsanitizer/asan/asan_internal.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2660d12d0a69539959dc1f77648f9f29f5e0edf8/libsanitizer%2Fasan%2Fasan_internal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2660d12d0a69539959dc1f77648f9f29f5e0edf8/libsanitizer%2Fasan%2Fasan_internal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_internal.h?ref=2660d12d0a69539959dc1f77648f9f29f5e0edf8", "patch": "@@ -114,7 +114,7 @@ bool AsanInterceptsSignal(int signum);\n void SetAlternateSignalStack();\n void UnsetAlternateSignalStack();\n void InstallSignalHandlers();\n-void ClearShadowMemoryForContext(void *context);\n+void ReadContextStack(void *context, uptr *stack, uptr *ssize);\n void AsanPlatformThreadInit();\n \n // Wrapper for TLS/TSD."}, {"sha": "a030fcd397298696c078488fa51a14e50c95b8f1", "filename": "libsanitizer/asan/asan_linux.cc", "status": "modified", "additions": 4, "deletions": 31, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2660d12d0a69539959dc1f77648f9f29f5e0edf8/libsanitizer%2Fasan%2Fasan_linux.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2660d12d0a69539959dc1f77648f9f29f5e0edf8/libsanitizer%2Fasan%2Fasan_linux.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_linux.cc?ref=2660d12d0a69539959dc1f77648f9f29f5e0edf8", "patch": "@@ -13,7 +13,6 @@\n \n #include \"asan_interceptors.h\"\n #include \"asan_internal.h\"\n-#include \"asan_lock.h\"\n #include \"asan_thread.h\"\n #include \"asan_thread_registry.h\"\n #include \"sanitizer_common/sanitizer_libc.h\"\n@@ -100,26 +99,6 @@ void AsanPlatformThreadInit() {\n   // Nothing here for now.\n }\n \n-AsanLock::AsanLock(LinkerInitialized) {\n-  // We assume that pthread_mutex_t initialized to all zeroes is a valid\n-  // unlocked mutex. We can not use PTHREAD_MUTEX_INITIALIZER as it triggers\n-  // a gcc warning:\n-  // extended initializer lists only available with -std=c++0x or -std=gnu++0x\n-}\n-\n-void AsanLock::Lock() {\n-  CHECK(sizeof(pthread_mutex_t) <= sizeof(opaque_storage_));\n-  pthread_mutex_lock((pthread_mutex_t*)&opaque_storage_);\n-  CHECK(!owner_);\n-  owner_ = (uptr)pthread_self();\n-}\n-\n-void AsanLock::Unlock() {\n-  CHECK(owner_ == (uptr)pthread_self());\n-  owner_ = 0;\n-  pthread_mutex_unlock((pthread_mutex_t*)&opaque_storage_);\n-}\n-\n void GetStackTrace(StackTrace *stack, uptr max_s, uptr pc, uptr bp, bool fast) {\n #if defined(__arm__) || \\\n     defined(__powerpc__) || defined(__powerpc64__) || \\\n@@ -139,19 +118,13 @@ void GetStackTrace(StackTrace *stack, uptr max_s, uptr pc, uptr bp, bool fast) {\n }\n \n #if !ASAN_ANDROID\n-void ClearShadowMemoryForContext(void *context) {\n+void ReadContextStack(void *context, uptr *stack, uptr *ssize) {\n   ucontext_t *ucp = (ucontext_t*)context;\n-  uptr sp = (uptr)ucp->uc_stack.ss_sp;\n-  uptr size = ucp->uc_stack.ss_size;\n-  // Align to page size.\n-  uptr PageSize = GetPageSizeCached();\n-  uptr bottom = sp & ~(PageSize - 1);\n-  size += sp - bottom;\n-  size = RoundUpTo(size, PageSize);\n-  PoisonShadow(bottom, size, 0);\n+  *stack = (uptr)ucp->uc_stack.ss_sp;\n+  *ssize = ucp->uc_stack.ss_size;\n }\n #else\n-void ClearShadowMemoryForContext(void *context) {\n+void ReadContextStack(void *context, uptr *stack, uptr *ssize) {\n   UNIMPLEMENTED();\n }\n #endif"}, {"sha": "8b137891791fe96927ad78e64b0aad7bded08bdc", "filename": "libsanitizer/asan/asan_lock.h", "status": "modified", "additions": 0, "deletions": 39, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2660d12d0a69539959dc1f77648f9f29f5e0edf8/libsanitizer%2Fasan%2Fasan_lock.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2660d12d0a69539959dc1f77648f9f29f5e0edf8/libsanitizer%2Fasan%2Fasan_lock.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_lock.h?ref=2660d12d0a69539959dc1f77648f9f29f5e0edf8", "patch": "@@ -1,40 +1 @@\n-//===-- asan_lock.h ---------------------------------------------*- C++ -*-===//\n-//\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n-//\n-//===----------------------------------------------------------------------===//\n-//\n-// This file is a part of AddressSanitizer, an address sanity checker.\n-//\n-// A wrapper for a simple lock.\n-//===----------------------------------------------------------------------===//\n-#ifndef ASAN_LOCK_H\n-#define ASAN_LOCK_H\n \n-#include \"sanitizer_common/sanitizer_mutex.h\"\n-#include \"asan_internal.h\"\n-\n-// The locks in ASan are global objects and they are never destroyed to avoid\n-// at-exit races (that is, a lock is being used by other threads while the main\n-// thread is doing atexit destructors).\n-// We define the class using opaque storage to avoid including system headers.\n-\n-namespace __asan {\n-\n-class AsanLock {\n- public:\n-  explicit AsanLock(LinkerInitialized);\n-  void Lock();\n-  void Unlock();\n-  bool IsLocked() { return owner_ != 0; }\n- private:\n-  uptr opaque_storage_[10];\n-  uptr owner_;  // for debugging and for malloc_introspection_t interface\n-};\n-\n-typedef GenericScopedLock<AsanLock> ScopedLock;\n-\n-}  // namespace __asan\n-\n-#endif  // ASAN_LOCK_H"}, {"sha": "a49d5c5ab8f9df39e0cf1819145667a47c1d8dfb", "filename": "libsanitizer/asan/asan_mac.cc", "status": "modified", "additions": 1, "deletions": 115, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2660d12d0a69539959dc1f77648f9f29f5e0edf8/libsanitizer%2Fasan%2Fasan_mac.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2660d12d0a69539959dc1f77648f9f29f5e0edf8/libsanitizer%2Fasan%2Fasan_mac.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_mac.cc?ref=2660d12d0a69539959dc1f77648f9f29f5e0edf8", "patch": "@@ -34,7 +34,6 @@\n #include <stdlib.h>  // for free()\n #include <unistd.h>\n #include <libkern/OSAtomic.h>\n-#include <CoreFoundation/CFString.h>\n \n namespace __asan {\n \n@@ -129,33 +128,6 @@ bool AsanInterceptsSignal(int signum) {\n }\n \n void AsanPlatformThreadInit() {\n-  // For the first program thread, we can't replace the allocator before\n-  // __CFInitialize() has been called. If it hasn't, we'll call\n-  // MaybeReplaceCFAllocator() later on this thread.\n-  // For other threads __CFInitialize() has been called before their creation.\n-  // See also asan_malloc_mac.cc.\n-  if (((CFRuntimeBase*)kCFAllocatorSystemDefault)->_cfisa) {\n-    MaybeReplaceCFAllocator();\n-  }\n-}\n-\n-AsanLock::AsanLock(LinkerInitialized) {\n-  // We assume that OS_SPINLOCK_INIT is zero\n-}\n-\n-void AsanLock::Lock() {\n-  CHECK(sizeof(OSSpinLock) <= sizeof(opaque_storage_));\n-  CHECK(OS_SPINLOCK_INIT == 0);\n-  CHECK(owner_ != (uptr)pthread_self());\n-  OSSpinLockLock((OSSpinLock*)&opaque_storage_);\n-  CHECK(!owner_);\n-  owner_ = (uptr)pthread_self();\n-}\n-\n-void AsanLock::Unlock() {\n-  CHECK(owner_ == (uptr)pthread_self());\n-  owner_ = 0;\n-  OSSpinLockUnlock((OSSpinLock*)&opaque_storage_);\n }\n \n void GetStackTrace(StackTrace *stack, uptr max_s, uptr pc, uptr bp, bool fast) {\n@@ -170,7 +142,7 @@ void GetStackTrace(StackTrace *stack, uptr max_s, uptr pc, uptr bp, bool fast) {\n   }\n }\n \n-void ClearShadowMemoryForContext(void *context) {\n+void ReadContextStack(void *context, uptr *stack, uptr *ssize) {\n   UNIMPLEMENTED();\n }\n \n@@ -254,9 +226,6 @@ mach_error_t __interception_deallocate_island(void *ptr) {\n // The implementation details are at\n //   http://libdispatch.macosforge.org/trac/browser/trunk/src/queue.c\n \n-typedef void* pthread_workqueue_t;\n-typedef void* pthread_workitem_handle_t;\n-\n typedef void* dispatch_group_t;\n typedef void* dispatch_queue_t;\n typedef void* dispatch_source_t;\n@@ -287,9 +256,6 @@ void dispatch_barrier_async_f(dispatch_queue_t dq, void *ctxt,\n                               dispatch_function_t func);\n void dispatch_group_async_f(dispatch_group_t group, dispatch_queue_t dq,\n                             void *ctxt, dispatch_function_t func);\n-int pthread_workqueue_additem_np(pthread_workqueue_t workq,\n-    void *(*workitem_func)(void *), void * workitem_arg,\n-    pthread_workitem_handle_t * itemhandlep, unsigned int *gencountp);\n }  // extern \"C\"\n \n static ALWAYS_INLINE\n@@ -444,66 +410,6 @@ INTERCEPTOR(void, dispatch_source_set_event_handler,\n }\n #endif\n \n-// The following stuff has been extremely helpful while looking for the\n-// unhandled functions that spawned jobs on Chromium shutdown. If the verbosity\n-// level is 2 or greater, we wrap pthread_workqueue_additem_np() in order to\n-// find the points of worker thread creation (each of such threads may be used\n-// to run several tasks, that's why this is not enough to support the whole\n-// libdispatch API.\n-extern \"C\"\n-void *wrap_workitem_func(void *arg) {\n-  if (flags()->verbosity >= 2) {\n-    Report(\"wrap_workitem_func: %p, pthread_self: %p\\n\", arg, pthread_self());\n-  }\n-  asan_block_context_t *ctxt = (asan_block_context_t*)arg;\n-  worker_t fn = (worker_t)(ctxt->func);\n-  void *result =  fn(ctxt->block);\n-  GET_STACK_TRACE_THREAD;\n-  asan_free(arg, &stack, FROM_MALLOC);\n-  return result;\n-}\n-\n-INTERCEPTOR(int, pthread_workqueue_additem_np, pthread_workqueue_t workq,\n-    void *(*workitem_func)(void *), void * workitem_arg,\n-    pthread_workitem_handle_t * itemhandlep, unsigned int *gencountp) {\n-  GET_STACK_TRACE_THREAD;\n-  asan_block_context_t *asan_ctxt =\n-      (asan_block_context_t*) asan_malloc(sizeof(asan_block_context_t), &stack);\n-  asan_ctxt->block = workitem_arg;\n-  asan_ctxt->func = (dispatch_function_t)workitem_func;\n-  asan_ctxt->parent_tid = asanThreadRegistry().GetCurrentTidOrInvalid();\n-  if (flags()->verbosity >= 2) {\n-    Report(\"pthread_workqueue_additem_np: %p\\n\", asan_ctxt);\n-    PRINT_CURRENT_STACK();\n-  }\n-  return REAL(pthread_workqueue_additem_np)(workq, wrap_workitem_func,\n-                                            asan_ctxt, itemhandlep,\n-                                            gencountp);\n-}\n-\n-// See http://opensource.apple.com/source/CF/CF-635.15/CFString.c\n-int __CFStrIsConstant(CFStringRef str) {\n-  CFRuntimeBase *base = (CFRuntimeBase*)str;\n-#if __LP64__\n-  return base->_rc == 0;\n-#else\n-  return (base->_cfinfo[CF_RC_BITS]) == 0;\n-#endif\n-}\n-\n-INTERCEPTOR(CFStringRef, CFStringCreateCopy, CFAllocatorRef alloc,\n-                                             CFStringRef str) {\n-  if (__CFStrIsConstant(str)) {\n-    return str;\n-  } else {\n-    return REAL(CFStringCreateCopy)(alloc, str);\n-  }\n-}\n-\n-DECLARE_REAL_AND_INTERCEPTOR(void, free, void *ptr)\n-\n-DECLARE_REAL_AND_INTERCEPTOR(void, __CFInitialize, void)\n-\n namespace __asan {\n \n void InitializeMacInterceptors() {\n@@ -512,26 +418,6 @@ void InitializeMacInterceptors() {\n   CHECK(INTERCEPT_FUNCTION(dispatch_after_f));\n   CHECK(INTERCEPT_FUNCTION(dispatch_barrier_async_f));\n   CHECK(INTERCEPT_FUNCTION(dispatch_group_async_f));\n-  // We don't need to intercept pthread_workqueue_additem_np() to support the\n-  // libdispatch API, but it helps us to debug the unsupported functions. Let's\n-  // intercept it only during verbose runs.\n-  if (flags()->verbosity >= 2) {\n-    CHECK(INTERCEPT_FUNCTION(pthread_workqueue_additem_np));\n-  }\n-  // Normally CFStringCreateCopy should not copy constant CF strings.\n-  // Replacing the default CFAllocator causes constant strings to be copied\n-  // rather than just returned, which leads to bugs in big applications like\n-  // Chromium and WebKit, see\n-  // http://code.google.com/p/address-sanitizer/issues/detail?id=10\n-  // Until this problem is fixed we need to check that the string is\n-  // non-constant before calling CFStringCreateCopy.\n-  CHECK(INTERCEPT_FUNCTION(CFStringCreateCopy));\n-  // Some of the library functions call free() directly, so we have to\n-  // intercept it.\n-  CHECK(INTERCEPT_FUNCTION(free));\n-  if (flags()->replace_cfallocator) {\n-    CHECK(INTERCEPT_FUNCTION(__CFInitialize));\n-  }\n }\n \n }  // namespace __asan"}, {"sha": "3ae6c59465093c31dac1f66231cb509b536719aa", "filename": "libsanitizer/asan/asan_malloc_mac.cc", "status": "modified", "additions": 104, "deletions": 176, "changes": 280, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2660d12d0a69539959dc1f77648f9f29f5e0edf8/libsanitizer%2Fasan%2Fasan_malloc_mac.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2660d12d0a69539959dc1f77648f9f29f5e0edf8/libsanitizer%2Fasan%2Fasan_malloc_mac.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_malloc_mac.cc?ref=2660d12d0a69539959dc1f77648f9f29f5e0edf8", "patch": "@@ -34,85 +34,108 @@ using namespace __asan;  // NOLINT\n \n // TODO(glider): do we need both zones?\n static malloc_zone_t *system_malloc_zone = 0;\n-static malloc_zone_t *system_purgeable_zone = 0;\n static malloc_zone_t asan_zone;\n-CFAllocatorRef cf_asan = 0;\n-\n-// _CFRuntimeCreateInstance() checks whether the supplied allocator is\n-// kCFAllocatorSystemDefault and, if it is not, stores the allocator reference\n-// at the beginning of the allocated memory and returns the pointer to the\n-// allocated memory plus sizeof(CFAllocatorRef). See\n-// http://www.opensource.apple.com/source/CF/CF-635.21/CFRuntime.c\n-// Pointers returned by _CFRuntimeCreateInstance() can then be passed directly\n-// to free() or CFAllocatorDeallocate(), which leads to false invalid free\n-// reports.\n-// The corresponding rdar bug is http://openradar.appspot.com/radar?id=1796404.\n-void* ALWAYS_INLINE get_saved_cfallocator_ref(void *ptr) {\n-  if (flags()->replace_cfallocator) {\n-    // Make sure we're not hitting the previous page. This may be incorrect\n-    // if ASan's malloc returns an address ending with 0xFF8, which will be\n-    // then padded to a page boundary with a CFAllocatorRef.\n-    uptr arith_ptr = (uptr)ptr;\n-    if ((arith_ptr & 0xFFF) > sizeof(CFAllocatorRef)) {\n-      CFAllocatorRef *saved =\n-          (CFAllocatorRef*)(arith_ptr - sizeof(CFAllocatorRef));\n-      if ((*saved == cf_asan) && asan_mz_size(saved)) ptr = (void*)saved;\n-    }\n+\n+INTERCEPTOR(malloc_zone_t *, malloc_create_zone,\n+                             vm_size_t start_size, unsigned zone_flags) {\n+  if (!asan_inited) __asan_init();\n+  GET_STACK_TRACE_MALLOC;\n+  malloc_zone_t *new_zone =\n+      (malloc_zone_t*)asan_malloc(sizeof(asan_zone), &stack);\n+  internal_memcpy(new_zone, &asan_zone, sizeof(asan_zone));\n+  new_zone->zone_name = NULL;  // The name will be changed anyway.\n+  return new_zone;\n+}\n+\n+INTERCEPTOR(malloc_zone_t *, malloc_default_zone, void) {\n+  if (!asan_inited) __asan_init();\n+  return &asan_zone;\n+}\n+\n+INTERCEPTOR(malloc_zone_t *, malloc_default_purgeable_zone, void) {\n+  // FIXME: ASan should support purgeable allocations.\n+  // https://code.google.com/p/address-sanitizer/issues/detail?id=139\n+  if (!asan_inited) __asan_init();\n+  return &asan_zone;\n+}\n+\n+INTERCEPTOR(void, malloc_make_purgeable, void *ptr) {\n+  // FIXME: ASan should support purgeable allocations. Ignoring them is fine\n+  // for now.\n+  if (!asan_inited) __asan_init();\n+}\n+\n+INTERCEPTOR(int, malloc_make_nonpurgeable, void *ptr) {\n+  // FIXME: ASan should support purgeable allocations. Ignoring them is fine\n+  // for now.\n+  if (!asan_inited) __asan_init();\n+  // Must return 0 if the contents were not purged since the last call to\n+  // malloc_make_purgeable().\n+  return 0;\n+}\n+\n+INTERCEPTOR(void, malloc_set_zone_name, malloc_zone_t *zone, const char *name) {\n+  if (!asan_inited) __asan_init();\n+  // Allocate |strlen(\"asan-\") + 1 + internal_strlen(name)| bytes.\n+  size_t buflen = 6 + (name ? internal_strlen(name) : 0);\n+  InternalScopedBuffer<char> new_name(buflen);\n+  if (name && zone->introspect == asan_zone.introspect) {\n+    internal_snprintf(new_name.data(), buflen, \"asan-%s\", name);\n+    name = new_name.data();\n   }\n-  return ptr;\n+\n+  // Call the system malloc's implementation for both external and our zones,\n+  // since that appropriately changes VM region protections on the zone.\n+  REAL(malloc_set_zone_name)(zone, name);\n+}\n+\n+INTERCEPTOR(void *, malloc, size_t size) {\n+  if (!asan_inited) __asan_init();\n+  GET_STACK_TRACE_MALLOC;\n+  void *res = asan_malloc(size, &stack);\n+  return res;\n }\n \n-// The free() implementation provided by OS X calls malloc_zone_from_ptr()\n-// to find the owner of |ptr|. If the result is 0, an invalid free() is\n-// reported. Our implementation falls back to asan_free() in this case\n-// in order to print an ASan-style report.\n-//\n-// For the objects created by _CFRuntimeCreateInstance a CFAllocatorRef is\n-// placed at the beginning of the allocated chunk and the pointer returned by\n-// our allocator is off by sizeof(CFAllocatorRef). This pointer can be then\n-// passed directly to free(), which will lead to errors.\n-// To overcome this we're checking whether |ptr-sizeof(CFAllocatorRef)|\n-// contains a pointer to our CFAllocator (assuming no other allocator is used).\n-// See http://code.google.com/p/address-sanitizer/issues/detail?id=70 for more\n-// info.\n INTERCEPTOR(void, free, void *ptr) {\n-  malloc_zone_t *zone = malloc_zone_from_ptr(ptr);\n-  if (zone) {\n-#if defined(MAC_OS_X_VERSION_10_6) && \\\n-    MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_6\n-    if ((zone->version >= 6) && (zone->free_definite_size)) {\n-      zone->free_definite_size(zone, ptr, malloc_size(ptr));\n-    } else {\n-      malloc_zone_free(zone, ptr);\n-    }\n-#else\n-    malloc_zone_free(zone, ptr);\n-#endif\n-  } else {\n-    if (!asan_mz_size(ptr)) ptr = get_saved_cfallocator_ref(ptr);\n-    GET_STACK_TRACE_FREE;\n-    asan_free(ptr, &stack, FROM_MALLOC);\n-  }\n+  if (!asan_inited) __asan_init();\n+  if (!ptr) return;\n+  GET_STACK_TRACE_FREE;\n+  asan_free(ptr, &stack, FROM_MALLOC);\n }\n \n-// We can't always replace the default CFAllocator with cf_asan right in\n-// ReplaceSystemMalloc(), because it is sometimes called before\n-// __CFInitialize(), when the default allocator is invalid and replacing it may\n-// crash the program. Instead we wait for the allocator to initialize and jump\n-// in just after __CFInitialize(). Nobody is going to allocate memory using\n-// CFAllocators before that, so we won't miss anything.\n-//\n-// See http://code.google.com/p/address-sanitizer/issues/detail?id=87\n-// and http://opensource.apple.com/source/CF/CF-550.43/CFRuntime.c\n-INTERCEPTOR(void, __CFInitialize, void) {\n-  // If the runtime is built as dynamic library, __CFInitialize wrapper may be\n-  // called before __asan_init.\n-#if !MAC_INTERPOSE_FUNCTIONS\n-  CHECK(flags()->replace_cfallocator);\n-  CHECK(asan_inited);\n-#endif\n-  REAL(__CFInitialize)();\n-  if (!cf_asan && asan_inited) MaybeReplaceCFAllocator();\n+INTERCEPTOR(void *, realloc, void *ptr, size_t size) {\n+  if (!asan_inited) __asan_init();\n+  GET_STACK_TRACE_MALLOC;\n+  return asan_realloc(ptr, size, &stack);\n+}\n+\n+INTERCEPTOR(void *, calloc, size_t nmemb, size_t size) {\n+  if (!asan_inited) __asan_init();\n+  GET_STACK_TRACE_MALLOC;\n+  return asan_calloc(nmemb, size, &stack);\n+}\n+\n+INTERCEPTOR(void *, valloc, size_t size) {\n+  if (!asan_inited) __asan_init();\n+  GET_STACK_TRACE_MALLOC;\n+  return asan_memalign(GetPageSizeCached(), size, &stack, FROM_MALLOC);\n+}\n+\n+INTERCEPTOR(size_t, malloc_good_size, size_t size) {\n+  if (!asan_inited) __asan_init();\n+  return asan_zone.introspect->good_size(&asan_zone, size);\n+}\n+\n+INTERCEPTOR(int, posix_memalign, void **memptr, size_t alignment, size_t size) {\n+  if (!asan_inited) __asan_init();\n+  CHECK(memptr);\n+  GET_STACK_TRACE_MALLOC;\n+  void *result = asan_memalign(alignment, size, &stack, FROM_MALLOC);\n+  if (result) {\n+    *memptr = result;\n+    return 0;\n+  }\n+  return -1;\n }\n \n namespace {\n@@ -132,15 +155,6 @@ void *mz_malloc(malloc_zone_t *zone, size_t size) {\n   return asan_malloc(size, &stack);\n }\n \n-void *cf_malloc(CFIndex size, CFOptionFlags hint, void *info) {\n-  if (!asan_inited) {\n-    CHECK(system_malloc_zone);\n-    return malloc_zone_malloc(system_malloc_zone, size);\n-  }\n-  GET_STACK_TRACE_MALLOC;\n-  return asan_malloc(size, &stack);\n-}\n-\n void *mz_calloc(malloc_zone_t *zone, size_t nmemb, size_t size) {\n   if (!asan_inited) {\n     // Hack: dlsym calls calloc before REAL(calloc) is retrieved from dlsym.\n@@ -172,31 +186,14 @@ void *mz_valloc(malloc_zone_t *zone, size_t size) {\n \n void ALWAYS_INLINE free_common(void *context, void *ptr) {\n   if (!ptr) return;\n-  if (asan_mz_size(ptr)) {\n-    GET_STACK_TRACE_FREE;\n+  GET_STACK_TRACE_FREE;\n+  // FIXME: need to retire this flag.\n+  if (!flags()->mac_ignore_invalid_free) {\n     asan_free(ptr, &stack, FROM_MALLOC);\n   } else {\n-    // If the pointer does not belong to any of the zones, use one of the\n-    // fallback methods to free memory.\n-    malloc_zone_t *zone_ptr = malloc_zone_from_ptr(ptr);\n-    if (zone_ptr == system_purgeable_zone) {\n-      // allocations from malloc_default_purgeable_zone() done before\n-      // __asan_init() may be occasionally freed via free_common().\n-      // see http://code.google.com/p/address-sanitizer/issues/detail?id=99.\n-      malloc_zone_free(zone_ptr, ptr);\n-    } else {\n-      // If the memory chunk pointer was moved to store additional\n-      // CFAllocatorRef, fix it back.\n-      ptr = get_saved_cfallocator_ref(ptr);\n-      GET_STACK_TRACE_FREE;\n-      if (!flags()->mac_ignore_invalid_free) {\n-        asan_free(ptr, &stack, FROM_MALLOC);\n-      } else {\n-        GET_ZONE_FOR_PTR(ptr);\n-        WarnMacFreeUnallocated((uptr)ptr, (uptr)zone_ptr, zone_name, &stack);\n-        return;\n-      }\n-    }\n+    GET_ZONE_FOR_PTR(ptr);\n+    WarnMacFreeUnallocated((uptr)ptr, (uptr)zone_ptr, zone_name, &stack);\n+    return;\n   }\n }\n \n@@ -205,10 +202,6 @@ void mz_free(malloc_zone_t *zone, void *ptr) {\n   free_common(zone, ptr);\n }\n \n-void cf_free(void *ptr, void *info) {\n-  free_common(info, ptr);\n-}\n-\n void *mz_realloc(malloc_zone_t *zone, void *ptr, size_t size) {\n   if (!ptr) {\n     GET_STACK_TRACE_MALLOC;\n@@ -228,29 +221,11 @@ void *mz_realloc(malloc_zone_t *zone, void *ptr, size_t size) {\n   }\n }\n \n-void *cf_realloc(void *ptr, CFIndex size, CFOptionFlags hint, void *info) {\n-  if (!ptr) {\n-    GET_STACK_TRACE_MALLOC;\n-    return asan_malloc(size, &stack);\n-  } else {\n-    if (asan_mz_size(ptr)) {\n-      GET_STACK_TRACE_MALLOC;\n-      return asan_realloc(ptr, size, &stack);\n-    } else {\n-      // We can't recover from reallocating an unknown address, because\n-      // this would require reading at most |size| bytes from\n-      // potentially unaccessible memory.\n-      GET_STACK_TRACE_FREE;\n-      GET_ZONE_FOR_PTR(ptr);\n-      ReportMacCfReallocUnknown((uptr)ptr, (uptr)zone_ptr, zone_name, &stack);\n-    }\n-  }\n-}\n-\n void mz_destroy(malloc_zone_t* zone) {\n   // A no-op -- we will not be destroyed!\n-  Printf(\"mz_destroy() called -- ignoring\\n\");\n+  Report(\"mz_destroy() called -- ignoring\\n\");\n }\n+\n   // from AvailabilityMacros.h\n #if defined(MAC_OS_X_VERSION_10_6) && \\\n     MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_6\n@@ -322,23 +297,7 @@ boolean_t mi_zone_locked(malloc_zone_t *zone) {\n \n }  // unnamed namespace\n \n-extern int __CFRuntimeClassTableSize;\n-\n namespace __asan {\n-void MaybeReplaceCFAllocator() {\n-  static CFAllocatorContext asan_context = {\n-        /*version*/ 0, /*info*/ &asan_zone,\n-        /*retain*/ 0, /*release*/ 0,\n-        /*copyDescription*/0,\n-        /*allocate*/ &cf_malloc,\n-        /*reallocate*/ &cf_realloc,\n-        /*deallocate*/ &cf_free,\n-        /*preferredSize*/ 0 };\n-  if (!cf_asan)\n-    cf_asan = CFAllocatorCreate(kCFAllocatorUseContext, &asan_context);\n-  if (flags()->replace_cfallocator && CFAllocatorGetDefault() != cf_asan)\n-    CFAllocatorSetDefault(cf_asan);\n-}\n \n void ReplaceSystemMalloc() {\n   static malloc_introspection_t asan_introspection;\n@@ -378,41 +337,10 @@ void ReplaceSystemMalloc() {\n   asan_zone.free_definite_size = 0;\n   asan_zone.memalign = &mz_memalign;\n   asan_introspection.zone_locked = &mi_zone_locked;\n-\n-  // Request the default purgable zone to force its creation. The\n-  // current default zone is registered with the purgable zone for\n-  // doing tiny and small allocs.  Sadly, it assumes that the default\n-  // zone is the szone implementation from OS X and will crash if it\n-  // isn't.  By creating the zone now, this will be true and changing\n-  // the default zone won't cause a problem.  (OS X 10.6 and higher.)\n-  system_purgeable_zone = malloc_default_purgeable_zone();\n #endif\n \n-  // Register the ASan zone. At this point, it will not be the\n-  // default zone.\n+  // Register the ASan zone.\n   malloc_zone_register(&asan_zone);\n-\n-  // Unregister and reregister the default zone.  Unregistering swaps\n-  // the specified zone with the last one registered which for the\n-  // default zone makes the more recently registered zone the default\n-  // zone.  The default zone is then re-registered to ensure that\n-  // allocations made from it earlier will be handled correctly.\n-  // Things are not guaranteed to work that way, but it's how they work now.\n-  system_malloc_zone = malloc_default_zone();\n-  malloc_zone_unregister(system_malloc_zone);\n-  malloc_zone_register(system_malloc_zone);\n-  // Make sure the default allocator was replaced.\n-  CHECK(malloc_default_zone() == &asan_zone);\n-\n-  // If __CFInitialize() hasn't been called yet, cf_asan will be created and\n-  // installed as the default allocator after __CFInitialize() finishes (see\n-  // the interceptor for __CFInitialize() above). Otherwise install cf_asan\n-  // right now. On both Snow Leopard and Lion __CFInitialize() calls\n-  // __CFAllocatorInitialize(), which initializes the _base._cfisa field of\n-  // the default allocators we check here.\n-  if (((CFRuntimeBase*)kCFAllocatorSystemDefault)->_cfisa) {\n-    MaybeReplaceCFAllocator();\n-  }\n }\n }  // namespace __asan\n "}, {"sha": "be645c4afcd798472ec36ef6ee63c05eaa67f35f", "filename": "libsanitizer/asan/asan_mapping.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2660d12d0a69539959dc1f77648f9f29f5e0edf8/libsanitizer%2Fasan%2Fasan_mapping.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2660d12d0a69539959dc1f77648f9f29f5e0edf8/libsanitizer%2Fasan%2Fasan_mapping.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_mapping.h?ref=2660d12d0a69539959dc1f77648f9f29f5e0edf8", "patch": "@@ -109,6 +109,10 @@ static inline bool AddrIsInShadow(uptr a) {\n }\n \n static inline bool AddrIsInShadowGap(uptr a) {\n+  // In zero-based shadow mode we treat addresses near zero as addresses\n+  // in shadow gap as well.\n+  if (SHADOW_OFFSET == 0)\n+    return a <= kShadowGapEnd;\n   return a >= kShadowGapBeg && a <= kShadowGapEnd;\n }\n "}, {"sha": "e41135d0e51387b3827461b138f39bd6425a8267", "filename": "libsanitizer/asan/asan_new_delete.cc", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2660d12d0a69539959dc1f77648f9f29f5e0edf8/libsanitizer%2Fasan%2Fasan_new_delete.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2660d12d0a69539959dc1f77648f9f29f5e0edf8/libsanitizer%2Fasan%2Fasan_new_delete.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_new_delete.cc?ref=2660d12d0a69539959dc1f77648f9f29f5e0edf8", "patch": "@@ -25,8 +25,9 @@ void ReplaceOperatorsNewAndDelete() { }\n \n using namespace __asan;  // NOLINT\n \n-// On Android new() goes through malloc interceptors.\n-#if !ASAN_ANDROID\n+// On Mac and Android new() goes through malloc interceptors.\n+// See also https://code.google.com/p/address-sanitizer/issues/detail?id=131.\n+#if !ASAN_ANDROID && !ASAN_MAC\n \n // Fake std::nothrow_t to avoid including <new>.\n namespace std {"}, {"sha": "11edca57ae0a938aef406aa7b914fb77a73f1875", "filename": "libsanitizer/asan/asan_poisoning.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2660d12d0a69539959dc1f77648f9f29f5e0edf8/libsanitizer%2Fasan%2Fasan_poisoning.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2660d12d0a69539959dc1f77648f9f29f5e0edf8/libsanitizer%2Fasan%2Fasan_poisoning.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_poisoning.cc?ref=2660d12d0a69539959dc1f77648f9f29f5e0edf8", "patch": "@@ -23,7 +23,7 @@ void PoisonShadow(uptr addr, uptr size, u8 value) {\n   CHECK(AddrIsAlignedByGranularity(addr));\n   CHECK(AddrIsAlignedByGranularity(addr + size));\n   uptr shadow_beg = MemToShadow(addr);\n-  uptr shadow_end = MemToShadow(addr + size);\n+  uptr shadow_end = MemToShadow(addr + size - SHADOW_GRANULARITY) + 1;\n   CHECK(REAL(memset) != 0);\n   REAL(memset)((void*)shadow_beg, value, shadow_end - shadow_beg);\n }"}, {"sha": "04d2d7af63fa86437ca00f1aff09f5c13d2a87b4", "filename": "libsanitizer/asan/asan_rtl.cc", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2660d12d0a69539959dc1f77648f9f29f5e0edf8/libsanitizer%2Fasan%2Fasan_rtl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2660d12d0a69539959dc1f77648f9f29f5e0edf8/libsanitizer%2Fasan%2Fasan_rtl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_rtl.cc?ref=2660d12d0a69539959dc1f77648f9f29f5e0edf8", "patch": "@@ -12,7 +12,6 @@\n #include \"asan_allocator.h\"\n #include \"asan_interceptors.h\"\n #include \"asan_internal.h\"\n-#include \"asan_lock.h\"\n #include \"asan_mapping.h\"\n #include \"asan_report.h\"\n #include \"asan_stack.h\"\n@@ -140,10 +139,12 @@ void InitializeFlags(Flags *f, const char *env) {\n   f->allow_reexec = true;\n   f->print_full_thread_history = true;\n   f->log_path = 0;\n-  f->fast_unwind_on_fatal = true;\n+  f->fast_unwind_on_fatal = false;\n   f->fast_unwind_on_malloc = true;\n   f->poison_heap = true;\n-  f->alloc_dealloc_mismatch = true;\n+  // Turn off alloc/dealloc mismatch checker on Mac for now.\n+  // TODO(glider): Fix known issues and enable this back.\n+  f->alloc_dealloc_mismatch = (ASAN_MAC == 0);\n   f->use_stack_depot = true;  // Only affects allocator2.\n \n   // Override from user-specified string.\n@@ -228,7 +229,6 @@ static NOINLINE void force_interface_symbols() {\n     case 8: __asan_report_store4(0); break;\n     case 9: __asan_report_store8(0); break;\n     case 10: __asan_report_store16(0); break;\n-    case 11: __asan_register_global(0, 0, 0); break;\n     case 12: __asan_register_globals(0, 0); break;\n     case 13: __asan_unregister_globals(0, 0); break;\n     case 14: __asan_set_death_callback(0); break;"}, {"sha": "1187bd92f97df8cfc4071c02d8a3271fa7d99d2e", "filename": "libsanitizer/asan/asan_stats.cc", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2660d12d0a69539959dc1f77648f9f29f5e0edf8/libsanitizer%2Fasan%2Fasan_stats.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2660d12d0a69539959dc1f77648f9f29f5e0edf8/libsanitizer%2Fasan%2Fasan_stats.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_stats.cc?ref=2660d12d0a69539959dc1f77648f9f29f5e0edf8", "patch": "@@ -11,7 +11,6 @@\n //===----------------------------------------------------------------------===//\n #include \"asan_interceptors.h\"\n #include \"asan_internal.h\"\n-#include \"asan_lock.h\"\n #include \"asan_stats.h\"\n #include \"asan_thread_registry.h\"\n #include \"sanitizer/asan_interface.h\"\n@@ -53,13 +52,13 @@ void AsanStats::Print() {\n              malloc_large, malloc_small_slow);\n }\n \n-static AsanLock print_lock(LINKER_INITIALIZED);\n+static BlockingMutex print_lock(LINKER_INITIALIZED);\n \n static void PrintAccumulatedStats() {\n   AsanStats stats;\n   asanThreadRegistry().GetAccumulatedStats(&stats);\n   // Use lock to keep reports from mixing up.\n-  ScopedLock lock(&print_lock);\n+  BlockingMutexLock lock(&print_lock);\n   stats.Print();\n   StackDepotStats *stack_depot_stats = StackDepotGetStats();\n   Printf(\"Stats: StackDepot: %zd ids; %zdM mapped\\n\","}, {"sha": "02f49dd59ef9fbb19960605a1ed64e4ac8aea8a1", "filename": "libsanitizer/asan/asan_thread.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2660d12d0a69539959dc1f77648f9f29f5e0edf8/libsanitizer%2Fasan%2Fasan_thread.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2660d12d0a69539959dc1f77648f9f29f5e0edf8/libsanitizer%2Fasan%2Fasan_thread.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_thread.cc?ref=2660d12d0a69539959dc1f77648f9f29f5e0edf8", "patch": "@@ -72,7 +72,7 @@ void AsanThread::Destroy() {\n void AsanThread::Init() {\n   SetThreadStackTopAndBottom();\n   CHECK(AddrIsInMem(stack_bottom_));\n-  CHECK(AddrIsInMem(stack_top_));\n+  CHECK(AddrIsInMem(stack_top_ - 1));\n   ClearShadowForThreadStack();\n   if (flags()->verbosity >= 1) {\n     int local = 0;"}, {"sha": "8fda9b6ea0a7b0ca41724ba72b4ec09c1062c000", "filename": "libsanitizer/asan/asan_thread_registry.cc", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2660d12d0a69539959dc1f77648f9f29f5e0edf8/libsanitizer%2Fasan%2Fasan_thread_registry.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2660d12d0a69539959dc1f77648f9f29f5e0edf8/libsanitizer%2Fasan%2Fasan_thread_registry.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_thread_registry.cc?ref=2660d12d0a69539959dc1f77648f9f29f5e0edf8", "patch": "@@ -42,7 +42,7 @@ void AsanThreadRegistry::Init() {\n }\n \n void AsanThreadRegistry::RegisterThread(AsanThread *thread) {\n-  ScopedLock lock(&mu_);\n+  BlockingMutexLock lock(&mu_);\n   u32 tid = n_threads_;\n   n_threads_++;\n   CHECK(n_threads_ < kMaxNumberOfThreads);\n@@ -54,7 +54,7 @@ void AsanThreadRegistry::RegisterThread(AsanThread *thread) {\n }\n \n void AsanThreadRegistry::UnregisterThread(AsanThread *thread) {\n-  ScopedLock lock(&mu_);\n+  BlockingMutexLock lock(&mu_);\n   FlushToAccumulatedStatsUnlocked(&thread->stats());\n   AsanThreadSummary *summary = thread->summary();\n   CHECK(summary);\n@@ -103,13 +103,13 @@ AsanStats &AsanThreadRegistry::GetCurrentThreadStats() {\n }\n \n void AsanThreadRegistry::GetAccumulatedStats(AsanStats *stats) {\n-  ScopedLock lock(&mu_);\n+  BlockingMutexLock lock(&mu_);\n   UpdateAccumulatedStatsUnlocked();\n   internal_memcpy(stats, &accumulated_stats_, sizeof(accumulated_stats_));\n }\n \n uptr AsanThreadRegistry::GetCurrentAllocatedBytes() {\n-  ScopedLock lock(&mu_);\n+  BlockingMutexLock lock(&mu_);\n   UpdateAccumulatedStatsUnlocked();\n   uptr malloced = accumulated_stats_.malloced;\n   uptr freed = accumulated_stats_.freed;\n@@ -119,13 +119,13 @@ uptr AsanThreadRegistry::GetCurrentAllocatedBytes() {\n }\n \n uptr AsanThreadRegistry::GetHeapSize() {\n-  ScopedLock lock(&mu_);\n+  BlockingMutexLock lock(&mu_);\n   UpdateAccumulatedStatsUnlocked();\n   return accumulated_stats_.mmaped - accumulated_stats_.munmaped;\n }\n \n uptr AsanThreadRegistry::GetFreeBytes() {\n-  ScopedLock lock(&mu_);\n+  BlockingMutexLock lock(&mu_);\n   UpdateAccumulatedStatsUnlocked();\n   uptr total_free = accumulated_stats_.mmaped\n                   - accumulated_stats_.munmaped\n@@ -141,7 +141,7 @@ uptr AsanThreadRegistry::GetFreeBytes() {\n // Return several stats counters with a single call to\n // UpdateAccumulatedStatsUnlocked().\n void AsanThreadRegistry::FillMallocStatistics(AsanMallocStats *malloc_stats) {\n-  ScopedLock lock(&mu_);\n+  BlockingMutexLock lock(&mu_);\n   UpdateAccumulatedStatsUnlocked();\n   malloc_stats->blocks_in_use = accumulated_stats_.mallocs;\n   malloc_stats->size_in_use = accumulated_stats_.malloced;\n@@ -156,7 +156,7 @@ AsanThreadSummary *AsanThreadRegistry::FindByTid(u32 tid) {\n }\n \n AsanThread *AsanThreadRegistry::FindThreadByStackAddress(uptr addr) {\n-  ScopedLock lock(&mu_);\n+  BlockingMutexLock lock(&mu_);\n   for (u32 tid = 0; tid < n_threads_; tid++) {\n     AsanThread *t = thread_summaries_[tid]->thread();\n     if (!t || !(t->fake_stack().StackSize())) continue;"}, {"sha": "8c3d0c886e0aff424961cc84f520c8a24a594938", "filename": "libsanitizer/asan/asan_thread_registry.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2660d12d0a69539959dc1f77648f9f29f5e0edf8/libsanitizer%2Fasan%2Fasan_thread_registry.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2660d12d0a69539959dc1f77648f9f29f5e0edf8/libsanitizer%2Fasan%2Fasan_thread_registry.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_thread_registry.h?ref=2660d12d0a69539959dc1f77648f9f29f5e0edf8", "patch": "@@ -13,10 +13,10 @@\n #ifndef ASAN_THREAD_REGISTRY_H\n #define ASAN_THREAD_REGISTRY_H\n \n-#include \"asan_lock.h\"\n #include \"asan_stack.h\"\n #include \"asan_stats.h\"\n #include \"asan_thread.h\"\n+#include \"sanitizer_common/sanitizer_mutex.h\"\n \n namespace __asan {\n \n@@ -71,7 +71,7 @@ class AsanThreadRegistry {\n   // per-thread AsanStats.\n   uptr max_malloced_memory_;\n   u32 n_threads_;\n-  AsanLock mu_;\n+  BlockingMutex mu_;\n   bool inited_;\n };\n "}, {"sha": "6acfeebc8bfe0dac7d2ddbad0f45e1f14e5fa4bf", "filename": "libsanitizer/asan/asan_win.cc", "status": "modified", "additions": 4, "deletions": 42, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2660d12d0a69539959dc1f77648f9f29f5e0edf8/libsanitizer%2Fasan%2Fasan_win.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2660d12d0a69539959dc1f77648f9f29f5e0edf8/libsanitizer%2Fasan%2Fasan_win.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_win.cc?ref=2660d12d0a69539959dc1f77648f9f29f5e0edf8", "patch": "@@ -15,18 +15,16 @@\n #include <dbghelp.h>\n #include <stdlib.h>\n \n-#include <new>  // FIXME: temporarily needed for placement new in AsanLock.\n-\n #include \"asan_interceptors.h\"\n #include \"asan_internal.h\"\n-#include \"asan_lock.h\"\n #include \"asan_thread.h\"\n #include \"sanitizer_common/sanitizer_libc.h\"\n+#include \"sanitizer_common/sanitizer_mutex.h\"\n \n namespace __asan {\n \n // ---------------------- Stacktraces, symbols, etc. ---------------- {{{1\n-static AsanLock dbghelp_lock(LINKER_INITIALIZED);\n+static BlockingMutex dbghelp_lock(LINKER_INITIALIZED);\n static bool dbghelp_initialized = false;\n #pragma comment(lib, \"dbghelp.lib\")\n \n@@ -54,42 +52,6 @@ void GetStackTrace(StackTrace *stack, uptr max_s, uptr pc, uptr bp, bool fast) {\n     stack->trace[i] = (uptr)tmp[i + offset];\n }\n \n-// ---------------------- AsanLock ---------------- {{{1\n-enum LockState {\n-  LOCK_UNINITIALIZED = 0,\n-  LOCK_READY = -1,\n-};\n-\n-AsanLock::AsanLock(LinkerInitialized li) {\n-  // FIXME: see comments in AsanLock::Lock() for the details.\n-  CHECK(li == LINKER_INITIALIZED || owner_ == LOCK_UNINITIALIZED);\n-\n-  CHECK(sizeof(CRITICAL_SECTION) <= sizeof(opaque_storage_));\n-  InitializeCriticalSection((LPCRITICAL_SECTION)opaque_storage_);\n-  owner_ = LOCK_READY;\n-}\n-\n-void AsanLock::Lock() {\n-  if (owner_ == LOCK_UNINITIALIZED) {\n-    // FIXME: hm, global AsanLock objects are not initialized?!?\n-    // This might be a side effect of the clang+cl+link Frankenbuild...\n-    new(this) AsanLock((LinkerInitialized)(LINKER_INITIALIZED + 1));\n-\n-    // FIXME: If it turns out the linker doesn't invoke our\n-    // constructors, we should probably manually Lock/Unlock all the global\n-    // locks while we're starting in one thread to avoid double-init races.\n-  }\n-  EnterCriticalSection((LPCRITICAL_SECTION)opaque_storage_);\n-  CHECK(owner_ == LOCK_READY);\n-  owner_ = GetThreadSelf();\n-}\n-\n-void AsanLock::Unlock() {\n-  CHECK(owner_ == GetThreadSelf());\n-  owner_ = LOCK_READY;\n-  LeaveCriticalSection((LPCRITICAL_SECTION)opaque_storage_);\n-}\n-\n // ---------------------- TSD ---------------- {{{1\n static bool tsd_key_inited = false;\n \n@@ -138,7 +100,7 @@ void AsanPlatformThreadInit() {\n   // Nothing here for now.\n }\n \n-void ClearShadowMemoryForContext(void *context) {\n+void ReadContextStack(void *context, uptr *stack, uptr *ssize) {\n   UNIMPLEMENTED();\n }\n \n@@ -150,7 +112,7 @@ using namespace __asan;  // NOLINT\n extern \"C\" {\n SANITIZER_INTERFACE_ATTRIBUTE NOINLINE\n bool __asan_symbolize(const void *addr, char *out_buffer, int buffer_size) {\n-  ScopedLock lock(&dbghelp_lock);\n+  BlockingMutexLock lock(&dbghelp_lock);\n   if (!dbghelp_initialized) {\n     SymSetOptions(SYMOPT_DEFERRED_LOADS |\n                   SYMOPT_UNDNAME |"}, {"sha": "757c704bd5541a633f226821bbd85b3b38aa60d6", "filename": "libsanitizer/asan/dynamic/asan_interceptors_dynamic.cc", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2660d12d0a69539959dc1f77648f9f29f5e0edf8/libsanitizer%2Fasan%2Fdynamic%2Fasan_interceptors_dynamic.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2660d12d0a69539959dc1f77648f9f29f5e0edf8/libsanitizer%2Fasan%2Fdynamic%2Fasan_interceptors_dynamic.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fdynamic%2Fasan_interceptors_dynamic.cc?ref=2660d12d0a69539959dc1f77648f9f29f5e0edf8", "patch": "@@ -99,9 +99,19 @@ const interpose_substitution substitutions[]\n   INTERPOSE_FUNCTION(signal),\n   INTERPOSE_FUNCTION(sigaction),\n \n-  INTERPOSE_FUNCTION(__CFInitialize),\n-  INTERPOSE_FUNCTION(CFStringCreateCopy),\n+  INTERPOSE_FUNCTION(malloc_create_zone),\n+  INTERPOSE_FUNCTION(malloc_default_zone),\n+  INTERPOSE_FUNCTION(malloc_default_purgeable_zone),\n+  INTERPOSE_FUNCTION(malloc_make_purgeable),\n+  INTERPOSE_FUNCTION(malloc_make_nonpurgeable),\n+  INTERPOSE_FUNCTION(malloc_set_zone_name),\n+  INTERPOSE_FUNCTION(malloc),\n   INTERPOSE_FUNCTION(free),\n+  INTERPOSE_FUNCTION(realloc),\n+  INTERPOSE_FUNCTION(calloc),\n+  INTERPOSE_FUNCTION(valloc),\n+  INTERPOSE_FUNCTION(malloc_good_size),\n+  INTERPOSE_FUNCTION(posix_memalign),\n };\n \n }  // namespace __asan"}, {"sha": "9f9f12cbfa2dee695bd94edec0fc81cb2644a076", "filename": "libsanitizer/include/sanitizer/asan_interface.h", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2660d12d0a69539959dc1f77648f9f29f5e0edf8/libsanitizer%2Finclude%2Fsanitizer%2Fasan_interface.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2660d12d0a69539959dc1f77648f9f29f5e0edf8/libsanitizer%2Finclude%2Fsanitizer%2Fasan_interface.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finclude%2Fsanitizer%2Fasan_interface.h?ref=2660d12d0a69539959dc1f77648f9f29f5e0edf8", "patch": "@@ -26,11 +26,6 @@ extern \"C\" {\n   // before any instrumented code is executed and before any call to malloc.\n   void __asan_init() SANITIZER_INTERFACE_ATTRIBUTE;\n \n-  // This function should be called by the instrumented code.\n-  // 'addr' is the address of a global variable called 'name' of 'size' bytes.\n-  void __asan_register_global(uptr addr, uptr size, const char *name)\n-      SANITIZER_INTERFACE_ATTRIBUTE;\n-\n   // This structure describes an instrumented global variable.\n   struct __asan_global {\n     uptr beg;                // The address of the global."}, {"sha": "ccf5e1b1ec0c33535f6bae78f2c926871866fc98", "filename": "libsanitizer/interception/interception.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2660d12d0a69539959dc1f77648f9f29f5e0edf8/libsanitizer%2Finterception%2Finterception.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2660d12d0a69539959dc1f77648f9f29f5e0edf8/libsanitizer%2Finterception%2Finterception.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finterception%2Finterception.h?ref=2660d12d0a69539959dc1f77648f9f29f5e0edf8", "patch": "@@ -23,6 +23,8 @@\n // the standard system types (e.g. SSIZE_T instead of ssize_t)\n typedef __sanitizer::uptr SIZE_T;\n typedef __sanitizer::sptr SSIZE_T;\n+typedef __sanitizer::sptr PTRDIFF_T;\n+typedef __sanitizer::s64  INTMAX_T;\n typedef __sanitizer::u64  OFF_T;\n typedef __sanitizer::u64  OFF64_T;\n "}, {"sha": "d2e622aeb1a808c16156f7e6b2aa63dd7edd99e1", "filename": "libsanitizer/merge.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2660d12d0a69539959dc1f77648f9f29f5e0edf8/libsanitizer%2Fmerge.sh", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2660d12d0a69539959dc1f77648f9f29f5e0edf8/libsanitizer%2Fmerge.sh", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fmerge.sh?ref=2660d12d0a69539959dc1f77648f9f29f5e0edf8", "patch": "@@ -16,7 +16,7 @@ get_current_rev() {\n }\n \n list_files() {\n-  (cd $1; ls *.{cc,h} 2> /dev/null)\n+  (cd $1; ls *.{cc,h,inc} 2> /dev/null)\n \n }\n "}, {"sha": "1c9852e50035997c7c5cff99abc6e6995fad1e64", "filename": "libsanitizer/sanitizer_common/sanitizer_allocator.h", "status": "modified", "additions": 181, "deletions": 177, "changes": 358, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2660d12d0a69539959dc1f77648f9f29f5e0edf8/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2660d12d0a69539959dc1f77648f9f29f5e0edf8/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator.h?ref=2660d12d0a69539959dc1f77648f9f29f5e0edf8", "patch": "@@ -17,6 +17,7 @@\n #include \"sanitizer_libc.h\"\n #include \"sanitizer_list.h\"\n #include \"sanitizer_mutex.h\"\n+#include \"sanitizer_lfstack.h\"\n \n namespace __sanitizer {\n \n@@ -62,7 +63,8 @@ namespace __sanitizer {\n //    c32 => s: 512 diff: +32 06% l 9 cached: 64 32768; id 32\n \n \n-template <uptr kMaxSizeLog, uptr kMaxNumCached, uptr kMaxBytesCachedLog>\n+template <uptr kMaxSizeLog, uptr kMaxNumCachedT, uptr kMaxBytesCachedLog,\n+          uptr kMinBatchClassT>\n class SizeClassMap {\n   static const uptr kMinSizeLog = 3;\n   static const uptr kMidSizeLog = kMinSizeLog + 4;\n@@ -73,6 +75,14 @@ class SizeClassMap {\n   static const uptr M = (1 << S) - 1;\n \n  public:\n+  static const uptr kMaxNumCached = kMaxNumCachedT;\n+  struct TransferBatch {\n+    TransferBatch *next;\n+    uptr count;\n+    void *batch[kMaxNumCached];\n+  };\n+\n+  static const uptr kMinBatchClass = kMinBatchClassT;\n   static const uptr kMaxSize = 1 << kMaxSizeLog;\n   static const uptr kNumClasses =\n       kMidClass + ((kMaxSizeLog - kMidSizeLog) << S) + 1;\n@@ -148,44 +158,25 @@ class SizeClassMap {\n       if (c > 0)\n         CHECK_LT(Size(c-1), s);\n     }\n-  }\n-};\n-\n-typedef SizeClassMap<15, 256, 16> DefaultSizeClassMap;\n-typedef SizeClassMap<15, 64, 14> CompactSizeClassMap;\n \n-\n-struct AllocatorListNode {\n-  AllocatorListNode *next;\n+    // TransferBatch for kMinBatchClass must fit into the block itself.\n+    const uptr batch_size = sizeof(TransferBatch)\n+        - sizeof(void*)  // NOLINT\n+            * (kMaxNumCached - MaxCached(kMinBatchClass));\n+    CHECK_LE(batch_size, Size(kMinBatchClass));\n+    // TransferBatch for kMinBatchClass-1 must not fit into the block itself.\n+    const uptr batch_size1 = sizeof(TransferBatch)\n+        - sizeof(void*)  // NOLINT\n+            * (kMaxNumCached - MaxCached(kMinBatchClass - 1));\n+    CHECK_GT(batch_size1, Size(kMinBatchClass - 1));\n+  }\n };\n \n-typedef IntrusiveList<AllocatorListNode> AllocatorFreeList;\n-\n-// Move at most max_count chunks from allocate_from to allocate_to.\n-// This function is better be a method of AllocatorFreeList, but we can't\n-// inherit it from IntrusiveList as the ancient gcc complains about non-PODness.\n-static inline uptr BulkMove(uptr max_count,\n-                            AllocatorFreeList *allocate_from,\n-                            AllocatorFreeList *allocate_to) {\n-  CHECK(!allocate_from->empty());\n-  CHECK(allocate_to->empty());\n-  uptr res = 0;\n-  if (allocate_from->size() <= max_count) {\n-    res = allocate_from->size();\n-    allocate_to->append_front(allocate_from);\n-    CHECK(allocate_from->empty());\n-  } else {\n-    for (uptr i = 0; i < max_count; i++) {\n-      AllocatorListNode *node = allocate_from->front();\n-      allocate_from->pop_front();\n-      allocate_to->push_front(node);\n-    }\n-    res = max_count;\n-    CHECK(!allocate_from->empty());\n-  }\n-  CHECK(!allocate_to->empty());\n-  return res;\n-}\n+typedef SizeClassMap<17, 256, 16, FIRST_32_SECOND_64(33, 36)>\n+    DefaultSizeClassMap;\n+typedef SizeClassMap<17, 64, 14, FIRST_32_SECOND_64(25, 28)>\n+    CompactSizeClassMap;\n+template<class SizeClassAllocator> struct SizeClassAllocatorLocalCache;\n \n // Allocators call these callbacks on mmap/munmap.\n struct NoOpMapUnmapCallback {\n@@ -214,6 +205,11 @@ template <const uptr kSpaceBeg, const uptr kSpaceSize,\n           class MapUnmapCallback = NoOpMapUnmapCallback>\n class SizeClassAllocator64 {\n  public:\n+  typedef typename SizeClassMap::TransferBatch Batch;\n+  typedef SizeClassAllocator64<kSpaceBeg, kSpaceSize, kMetadataSize,\n+      SizeClassMap, MapUnmapCallback> ThisT;\n+  typedef SizeClassAllocatorLocalCache<ThisT> AllocatorCache;\n+\n   void Init() {\n     CHECK_EQ(kSpaceBeg,\n              reinterpret_cast<uptr>(Mprotect(kSpaceBeg, kSpaceSize)));\n@@ -235,36 +231,20 @@ class SizeClassAllocator64 {\n       alignment <= SizeClassMap::kMaxSize;\n   }\n \n-  void *Allocate(uptr size, uptr alignment) {\n-    if (size < alignment) size = alignment;\n-    CHECK(CanAllocate(size, alignment));\n-    return AllocateBySizeClass(ClassID(size));\n-  }\n-\n-  void Deallocate(void *p) {\n-    CHECK(PointerIsMine(p));\n-    DeallocateBySizeClass(p, GetSizeClass(p));\n-  }\n-\n-  // Allocate several chunks of the given class_id.\n-  void BulkAllocate(uptr class_id, AllocatorFreeList *free_list) {\n+  Batch *NOINLINE AllocateBatch(AllocatorCache *c, uptr class_id) {\n     CHECK_LT(class_id, kNumClasses);\n     RegionInfo *region = GetRegionInfo(class_id);\n-    SpinMutexLock l(&region->mutex);\n-    if (region->free_list.empty()) {\n-      PopulateFreeList(class_id, region);\n-    }\n-    region->n_allocated += BulkMove(SizeClassMap::MaxCached(class_id),\n-                                    &region->free_list, free_list);\n+    Batch *b = region->free_list.Pop();\n+    if (b == 0)\n+      b = PopulateFreeList(c, class_id, region);\n+    region->n_allocated += b->count;\n+    return b;\n   }\n \n-  // Swallow the entire free_list for the given class_id.\n-  void BulkDeallocate(uptr class_id, AllocatorFreeList *free_list) {\n-    CHECK_LT(class_id, kNumClasses);\n+  void NOINLINE DeallocateBatch(uptr class_id, Batch *b) {\n     RegionInfo *region = GetRegionInfo(class_id);\n-    SpinMutexLock l(&region->mutex);\n-    region->n_freed += free_list->size();\n-    region->free_list.append_front(free_list);\n+    region->free_list.Push(b);\n+    region->n_freed += b->count;\n   }\n \n   static bool PointerIsMine(void *p) {\n@@ -352,15 +332,15 @@ class SizeClassAllocator64 {\n   COMPILER_CHECK((kRegionSize) >= (1ULL << (SANITIZER_WORDSIZE / 2)));\n   // Populate the free list with at most this number of bytes at once\n   // or with one element if its size is greater.\n-  static const uptr kPopulateSize = 1 << 15;\n+  static const uptr kPopulateSize = 1 << 14;\n   // Call mmap for user memory with at least this size.\n   static const uptr kUserMapSize = 1 << 15;\n   // Call mmap for metadata memory with at least this size.\n   static const uptr kMetaMapSize = 1 << 16;\n \n   struct RegionInfo {\n-    SpinMutex mutex;\n-    AllocatorFreeList free_list;\n+    BlockingMutex mutex;\n+    LFStack<Batch> free_list;\n     uptr allocated_user;  // Bytes allocated for user memory.\n     uptr allocated_meta;  // Bytes allocated for metadata.\n     uptr mapped_user;  // Bytes mapped for user memory.\n@@ -388,11 +368,16 @@ class SizeClassAllocator64 {\n     return offset / (u32)size;\n   }\n \n-  void PopulateFreeList(uptr class_id, RegionInfo *region) {\n-    CHECK(region->free_list.empty());\n+  Batch *NOINLINE PopulateFreeList(AllocatorCache *c, uptr class_id,\n+                                   RegionInfo *region) {\n+    BlockingMutexLock l(&region->mutex);\n+    Batch *b = region->free_list.Pop();\n+    if (b)\n+      return b;\n     uptr size = SizeClassMap::Size(class_id);\n+    uptr count = size < kPopulateSize ? SizeClassMap::MaxCached(class_id) : 1;\n     uptr beg_idx = region->allocated_user;\n-    uptr end_idx = beg_idx + kPopulateSize;\n+    uptr end_idx = beg_idx + count * size;\n     uptr region_beg = kSpaceBeg + kRegionSize * class_id;\n     if (end_idx + size > region->mapped_user) {\n       // Do the mmap for the user memory.\n@@ -403,17 +388,9 @@ class SizeClassAllocator64 {\n       MapWithCallback(region_beg + region->mapped_user, map_size);\n       region->mapped_user += map_size;\n     }\n-    uptr idx = beg_idx;\n-    uptr i = 0;\n-    do {  // do-while loop because we need to put at least one item.\n-      uptr p = region_beg + idx;\n-      region->free_list.push_front(reinterpret_cast<AllocatorListNode*>(p));\n-      idx += size;\n-      i++;\n-    } while (idx < end_idx);\n-    region->allocated_user += idx - beg_idx;\n-    CHECK_LE(region->allocated_user, region->mapped_user);\n-    region->allocated_meta += i * kMetadataSize;\n+    uptr total_count = (region->mapped_user - beg_idx - size)\n+        / size / count * count;\n+    region->allocated_meta += total_count * kMetadataSize;\n     if (region->allocated_meta > region->mapped_meta) {\n       uptr map_size = kMetaMapSize;\n       while (region->allocated_meta > region->mapped_meta + map_size)\n@@ -431,27 +408,22 @@ class SizeClassAllocator64 {\n           kRegionSize / 1024 / 1024, size);\n       Die();\n     }\n-  }\n-\n-  void *AllocateBySizeClass(uptr class_id) {\n-    CHECK_LT(class_id, kNumClasses);\n-    RegionInfo *region = GetRegionInfo(class_id);\n-    SpinMutexLock l(&region->mutex);\n-    if (region->free_list.empty()) {\n-      PopulateFreeList(class_id, region);\n+    for (;;) {\n+      if (class_id < SizeClassMap::kMinBatchClass)\n+        b = (Batch*)c->Allocate(this, SizeClassMap::ClassID(sizeof(Batch)));\n+      else\n+        b = (Batch*)(region_beg + beg_idx);\n+      b->count = count;\n+      for (uptr i = 0; i < count; i++)\n+        b->batch[i] = (void*)(region_beg + beg_idx + i * size);\n+      region->allocated_user += count * size;\n+      CHECK_LE(region->allocated_user, region->mapped_user);\n+      beg_idx += count * size;\n+      if (beg_idx + count * size + size > region->mapped_user)\n+        break;\n+      region->free_list.Push(b);\n     }\n-    CHECK(!region->free_list.empty());\n-    AllocatorListNode *node = region->free_list.front();\n-    region->free_list.pop_front();\n-    region->n_allocated++;\n-    return reinterpret_cast<void*>(node);\n-  }\n-\n-  void DeallocateBySizeClass(void *p, uptr class_id) {\n-    RegionInfo *region = GetRegionInfo(class_id);\n-    SpinMutexLock l(&region->mutex);\n-    region->free_list.push_front(reinterpret_cast<AllocatorListNode*>(p));\n-    region->n_freed++;\n+    return b;\n   }\n };\n \n@@ -480,6 +452,11 @@ template <const uptr kSpaceBeg, const u64 kSpaceSize,\n           class MapUnmapCallback = NoOpMapUnmapCallback>\n class SizeClassAllocator32 {\n  public:\n+  typedef typename SizeClassMap::TransferBatch Batch;\n+  typedef SizeClassAllocator32<kSpaceBeg, kSpaceSize, kMetadataSize,\n+      SizeClassMap, MapUnmapCallback> ThisT;\n+  typedef SizeClassAllocatorLocalCache<ThisT> AllocatorCache;\n+\n   void Init() {\n     state_ = reinterpret_cast<State *>(MapWithCallback(sizeof(State)));\n   }\n@@ -500,17 +477,6 @@ class SizeClassAllocator32 {\n       alignment <= SizeClassMap::kMaxSize;\n   }\n \n-  void *Allocate(uptr size, uptr alignment) {\n-    if (size < alignment) size = alignment;\n-    CHECK(CanAllocate(size, alignment));\n-    return AllocateBySizeClass(ClassID(size));\n-  }\n-\n-  void Deallocate(void *p) {\n-    CHECK(PointerIsMine(p));\n-    DeallocateBySizeClass(p, GetSizeClass(p));\n-  }\n-\n   void *GetMetaData(void *p) {\n     CHECK(PointerIsMine(p));\n     uptr mem = reinterpret_cast<uptr>(p);\n@@ -522,20 +488,23 @@ class SizeClassAllocator32 {\n     return reinterpret_cast<void*>(meta);\n   }\n \n-  // Allocate several chunks of the given class_id.\n-  void BulkAllocate(uptr class_id, AllocatorFreeList *free_list) {\n+  Batch *NOINLINE AllocateBatch(AllocatorCache *c, uptr class_id) {\n+    CHECK_LT(class_id, kNumClasses);\n     SizeClassInfo *sci = GetSizeClassInfo(class_id);\n     SpinMutexLock l(&sci->mutex);\n-    EnsureSizeClassHasAvailableChunks(sci, class_id);\n+    if (sci->free_list.empty())\n+      PopulateFreeList(c, sci, class_id);\n     CHECK(!sci->free_list.empty());\n-    BulkMove(SizeClassMap::MaxCached(class_id), &sci->free_list, free_list);\n+    Batch *b = sci->free_list.front();\n+    sci->free_list.pop_front();\n+    return b;\n   }\n \n-  // Swallow the entire free_list for the given class_id.\n-  void BulkDeallocate(uptr class_id, AllocatorFreeList *free_list) {\n+  void NOINLINE DeallocateBatch(uptr class_id, Batch *b) {\n+    CHECK_LT(class_id, kNumClasses);\n     SizeClassInfo *sci = GetSizeClassInfo(class_id);\n     SpinMutexLock l(&sci->mutex);\n-    sci->free_list.append_front(free_list);\n+    sci->free_list.push_front(b);\n   }\n \n   bool PointerIsMine(void *p) {\n@@ -593,8 +562,8 @@ class SizeClassAllocator32 {\n \n   struct SizeClassInfo {\n     SpinMutex mutex;\n-    AllocatorFreeList free_list;\n-    char padding[kCacheLineSize - sizeof(uptr) - sizeof(AllocatorFreeList)];\n+    IntrusiveList<Batch> free_list;\n+    char padding[kCacheLineSize - sizeof(uptr) - sizeof(IntrusiveList<Batch>)];\n   };\n   COMPILER_CHECK(sizeof(SizeClassInfo) == kCacheLineSize);\n \n@@ -624,31 +593,28 @@ class SizeClassAllocator32 {\n     return &state_->size_class_info_array[class_id];\n   }\n \n-  void EnsureSizeClassHasAvailableChunks(SizeClassInfo *sci, uptr class_id) {\n-    if (!sci->free_list.empty()) return;\n+  void PopulateFreeList(AllocatorCache *c, SizeClassInfo *sci, uptr class_id) {\n     uptr size = SizeClassMap::Size(class_id);\n     uptr reg = AllocateRegion(class_id);\n     uptr n_chunks = kRegionSize / (size + kMetadataSize);\n-    for (uptr i = reg; i < reg + n_chunks * size; i += size)\n-      sci->free_list.push_back(reinterpret_cast<AllocatorListNode*>(i));\n-  }\n-\n-  void *AllocateBySizeClass(uptr class_id) {\n-    CHECK_LT(class_id, kNumClasses);\n-    SizeClassInfo *sci = GetSizeClassInfo(class_id);\n-    SpinMutexLock l(&sci->mutex);\n-    EnsureSizeClassHasAvailableChunks(sci, class_id);\n-    CHECK(!sci->free_list.empty());\n-    AllocatorListNode *node = sci->free_list.front();\n-    sci->free_list.pop_front();\n-    return reinterpret_cast<void*>(node);\n-  }\n-\n-  void DeallocateBySizeClass(void *p, uptr class_id) {\n-    CHECK_LT(class_id, kNumClasses);\n-    SizeClassInfo *sci = GetSizeClassInfo(class_id);\n-    SpinMutexLock l(&sci->mutex);\n-    sci->free_list.push_front(reinterpret_cast<AllocatorListNode*>(p));\n+    uptr max_count = SizeClassMap::MaxCached(class_id);\n+    Batch *b = 0;\n+    for (uptr i = reg; i < reg + n_chunks * size; i += size) {\n+      if (b == 0) {\n+        if (class_id < SizeClassMap::kMinBatchClass)\n+          b = (Batch*)c->Allocate(this, SizeClassMap::ClassID(sizeof(Batch)));\n+        else\n+          b = (Batch*)i;\n+        b->count = 0;\n+      }\n+      b->batch[b->count++] = (void*)i;\n+      if (b->count == max_count) {\n+        sci->free_list.push_back(b);\n+        b = 0;\n+      }\n+    }\n+    if (b)\n+      sci->free_list.push_back(b);\n   }\n \n   struct State {\n@@ -658,13 +624,14 @@ class SizeClassAllocator32 {\n   State *state_;\n };\n \n-// Objects of this type should be used as local caches for SizeClassAllocator64.\n-// Since the typical use of this class is to have one object per thread in TLS,\n-// is has to be POD.\n+// Objects of this type should be used as local caches for SizeClassAllocator64\n+// or SizeClassAllocator32. Since the typical use of this class is to have one\n+// object per thread in TLS, is has to be POD.\n template<class SizeClassAllocator>\n struct SizeClassAllocatorLocalCache {\n   typedef SizeClassAllocator Allocator;\n   static const uptr kNumClasses = SizeClassAllocator::kNumClasses;\n+\n   // Don't need to call Init if the object is a global (i.e. zero-initialized).\n   void Init() {\n     internal_memset(this, 0, sizeof(*this));\n@@ -673,46 +640,77 @@ struct SizeClassAllocatorLocalCache {\n   void *Allocate(SizeClassAllocator *allocator, uptr class_id) {\n     CHECK_NE(class_id, 0UL);\n     CHECK_LT(class_id, kNumClasses);\n-    AllocatorFreeList *free_list = &free_lists_[class_id];\n-    if (free_list->empty())\n-      allocator->BulkAllocate(class_id, free_list);\n-    CHECK(!free_list->empty());\n-    void *res = free_list->front();\n-    free_list->pop_front();\n+    PerClass *c = &per_class_[class_id];\n+    if (UNLIKELY(c->count == 0))\n+      Refill(allocator, class_id);\n+    void *res = c->batch[--c->count];\n+    PREFETCH(c->batch[c->count - 1]);\n     return res;\n   }\n \n   void Deallocate(SizeClassAllocator *allocator, uptr class_id, void *p) {\n     CHECK_NE(class_id, 0UL);\n     CHECK_LT(class_id, kNumClasses);\n-    AllocatorFreeList *free_list = &free_lists_[class_id];\n-    free_list->push_front(reinterpret_cast<AllocatorListNode*>(p));\n-    if (free_list->size() >= 2 * SizeClassMap::MaxCached(class_id))\n-      DrainHalf(allocator, class_id);\n+    PerClass *c = &per_class_[class_id];\n+    if (UNLIKELY(c->count == c->max_count))\n+      Drain(allocator, class_id);\n+    c->batch[c->count++] = p;\n   }\n \n   void Drain(SizeClassAllocator *allocator) {\n-    for (uptr i = 0; i < kNumClasses; i++) {\n-      allocator->BulkDeallocate(i, &free_lists_[i]);\n-      CHECK(free_lists_[i].empty());\n+    for (uptr class_id = 0; class_id < kNumClasses; class_id++) {\n+      PerClass *c = &per_class_[class_id];\n+      while (c->count > 0)\n+        Drain(allocator, class_id);\n     }\n   }\n \n   // private:\n   typedef typename SizeClassAllocator::SizeClassMapT SizeClassMap;\n-  AllocatorFreeList free_lists_[kNumClasses];\n-\n-  void DrainHalf(SizeClassAllocator *allocator, uptr class_id) {\n-    AllocatorFreeList *free_list = &free_lists_[class_id];\n-    AllocatorFreeList half;\n-    half.clear();\n-    const uptr count = free_list->size() / 2;\n-    for (uptr i = 0; i < count; i++) {\n-      AllocatorListNode *node = free_list->front();\n-      free_list->pop_front();\n-      half.push_front(node);\n+  typedef typename SizeClassMap::TransferBatch Batch;\n+  struct PerClass {\n+    uptr count;\n+    uptr max_count;\n+    void *batch[2 * SizeClassMap::kMaxNumCached];\n+  };\n+  PerClass per_class_[kNumClasses];\n+\n+  void InitCache() {\n+    if (per_class_[0].max_count)\n+      return;\n+    for (uptr i = 0; i < kNumClasses; i++) {\n+      PerClass *c = &per_class_[i];\n+      c->max_count = 2 * SizeClassMap::MaxCached(i);\n+    }\n+  }\n+\n+  void NOINLINE Refill(SizeClassAllocator *allocator, uptr class_id) {\n+    InitCache();\n+    PerClass *c = &per_class_[class_id];\n+    Batch *b = allocator->AllocateBatch(this, class_id);\n+    for (uptr i = 0; i < b->count; i++)\n+      c->batch[i] = b->batch[i];\n+    c->count = b->count;\n+    if (class_id < SizeClassMap::kMinBatchClass)\n+      Deallocate(allocator, SizeClassMap::ClassID(sizeof(Batch)), b);\n+  }\n+\n+  void NOINLINE Drain(SizeClassAllocator *allocator, uptr class_id) {\n+    InitCache();\n+    PerClass *c = &per_class_[class_id];\n+    Batch *b;\n+    if (class_id < SizeClassMap::kMinBatchClass)\n+      b = (Batch*)Allocate(allocator, SizeClassMap::ClassID(sizeof(Batch)));\n+    else\n+      b = (Batch*)c->batch[0];\n+    uptr cnt = Min(c->max_count / 2, c->count);\n+    for (uptr i = 0; i < cnt; i++) {\n+      b->batch[i] = c->batch[i];\n+      c->batch[i] = c->batch[i + c->max_count / 2];\n     }\n-    allocator->BulkDeallocate(class_id, &half);\n+    b->count = cnt;\n+    c->count -= cnt;\n+    allocator->DeallocateBatch(class_id, b);\n   }\n };\n \n@@ -726,6 +724,7 @@ class LargeMmapAllocator {\n     internal_memset(this, 0, sizeof(*this));\n     page_size_ = GetPageSizeCached();\n   }\n+\n   void *Allocate(uptr size, uptr alignment) {\n     CHECK(IsPowerOfTwo(alignment));\n     uptr map_size = RoundUpMapSize(size);\n@@ -745,6 +744,8 @@ class LargeMmapAllocator {\n     h->size = size;\n     h->map_beg = map_beg;\n     h->map_size = map_size;\n+    uptr size_log = SANITIZER_WORDSIZE - __builtin_clzl(map_size) - 1;\n+    CHECK_LT(size_log, ARRAY_SIZE(stats.by_size_log));\n     {\n       SpinMutexLock l(&mutex_);\n       uptr idx = n_chunks_++;\n@@ -754,6 +755,7 @@ class LargeMmapAllocator {\n       stats.n_allocs++;\n       stats.currently_allocated += map_size;\n       stats.max_allocated = Max(stats.max_allocated, stats.currently_allocated);\n+      stats.by_size_log[size_log]++;\n     }\n     return reinterpret_cast<void*>(res);\n   }\n@@ -825,9 +827,15 @@ class LargeMmapAllocator {\n \n   void PrintStats() {\n     Printf(\"Stats: LargeMmapAllocator: allocated %zd times, \"\n-           \"remains %zd (%zd K) max %zd M\\n\",\n+           \"remains %zd (%zd K) max %zd M; by size logs: \",\n            stats.n_allocs, stats.n_allocs - stats.n_frees,\n            stats.currently_allocated >> 10, stats.max_allocated >> 20);\n+    for (uptr i = 0; i < ARRAY_SIZE(stats.by_size_log); i++) {\n+      uptr c = stats.by_size_log[i];\n+      if (!c) continue;\n+      Printf(\"%zd:%zd; \", i, c);\n+    }\n+    Printf(\"\\n\");\n   }\n \n  private:\n@@ -858,7 +866,7 @@ class LargeMmapAllocator {\n   Header *chunks_[kMaxNumChunks];\n   uptr n_chunks_;\n   struct Stats {\n-    uptr n_allocs, n_frees, currently_allocated, max_allocated;\n+    uptr n_allocs, n_frees, currently_allocated, max_allocated, by_size_log[64];\n   } stats;\n   SpinMutex mutex_;\n };\n@@ -888,14 +896,10 @@ class CombinedAllocator {\n     if (alignment > 8)\n       size = RoundUpTo(size, alignment);\n     void *res;\n-    if (primary_.CanAllocate(size, alignment)) {\n-      if (cache)  // Allocate from cache.\n-        res = cache->Allocate(&primary_, primary_.ClassID(size));\n-      else  // No thread-local cache, allocate directly from primary allocator.\n-        res = primary_.Allocate(size, alignment);\n-    } else {  // Secondary allocator does not use cache.\n+    if (primary_.CanAllocate(size, alignment))\n+      res = cache->Allocate(&primary_, primary_.ClassID(size));\n+    else\n       res = secondary_.Allocate(size, alignment);\n-    }\n     if (alignment > 8)\n       CHECK_EQ(reinterpret_cast<uptr>(res) & (alignment - 1), 0);\n     if (cleared && res)"}, {"sha": "bb4611d51e64e049b508aaaa060856e961080e49", "filename": "libsanitizer/sanitizer_common/sanitizer_atomic_clang.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2660d12d0a69539959dc1f77648f9f29f5e0edf8/libsanitizer%2Fsanitizer_common%2Fsanitizer_atomic_clang.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2660d12d0a69539959dc1f77648f9f29f5e0edf8/libsanitizer%2Fsanitizer_common%2Fsanitizer_atomic_clang.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_atomic_clang.h?ref=2660d12d0a69539959dc1f77648f9f29f5e0edf8", "patch": "@@ -39,6 +39,7 @@ INLINE typename T::Type atomic_load(\n       | memory_order_acquire | memory_order_seq_cst));\n   DCHECK(!((uptr)a % sizeof(*a)));\n   typename T::Type v;\n+  // FIXME(dvyukov): 64-bit load is not atomic on 32-bits.\n   if (mo == memory_order_relaxed) {\n     v = a->val_dont_use;\n   } else {\n@@ -54,6 +55,7 @@ INLINE void atomic_store(volatile T *a, typename T::Type v, memory_order mo) {\n   DCHECK(mo & (memory_order_relaxed | memory_order_release\n       | memory_order_seq_cst));\n   DCHECK(!((uptr)a % sizeof(*a)));\n+  // FIXME(dvyukov): 64-bit store is not atomic on 32-bits.\n   if (mo == memory_order_relaxed) {\n     a->val_dont_use = v;\n   } else {"}, {"sha": "919e24f3b11ac47d3fdaa7d152ffa01ebcb9d3d8", "filename": "libsanitizer/sanitizer_common/sanitizer_atomic_msvc.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2660d12d0a69539959dc1f77648f9f29f5e0edf8/libsanitizer%2Fsanitizer_common%2Fsanitizer_atomic_msvc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2660d12d0a69539959dc1f77648f9f29f5e0edf8/libsanitizer%2Fsanitizer_common%2Fsanitizer_atomic_msvc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_atomic_msvc.h?ref=2660d12d0a69539959dc1f77648f9f29f5e0edf8", "patch": "@@ -70,6 +70,7 @@ INLINE typename T::Type atomic_load(\n       | memory_order_acquire | memory_order_seq_cst));\n   DCHECK(!((uptr)a % sizeof(*a)));\n   typename T::Type v;\n+  // FIXME(dvyukov): 64-bit load is not atomic on 32-bits.\n   if (mo == memory_order_relaxed) {\n     v = a->val_dont_use;\n   } else {\n@@ -85,6 +86,7 @@ INLINE void atomic_store(volatile T *a, typename T::Type v, memory_order mo) {\n   DCHECK(mo & (memory_order_relaxed | memory_order_release\n       | memory_order_seq_cst));\n   DCHECK(!((uptr)a % sizeof(*a)));\n+  // FIXME(dvyukov): 64-bit store is not atomic on 32-bits.\n   if (mo == memory_order_relaxed) {\n     a->val_dont_use = v;\n   } else {"}, {"sha": "9b70ee0eb5475099f87e5a761802985a3b2ec7d0", "filename": "libsanitizer/sanitizer_common/sanitizer_common.cc", "status": "modified", "additions": 27, "deletions": 11, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2660d12d0a69539959dc1f77648f9f29f5e0edf8/libsanitizer%2Fsanitizer_common%2Fsanitizer_common.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2660d12d0a69539959dc1f77648f9f29f5e0edf8/libsanitizer%2Fsanitizer_common%2Fsanitizer_common.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_common.cc?ref=2660d12d0a69539959dc1f77648f9f29f5e0edf8", "patch": "@@ -21,10 +21,16 @@ uptr GetPageSizeCached() {\n   return PageSize;\n }\n \n-// By default, dump to stderr. If report_fd is kInvalidFd, try to obtain file\n-// descriptor by opening file in report_path.\n+static bool log_to_file = false;  // Set to true by __sanitizer_set_report_path\n+\n+// By default, dump to stderr. If |log_to_file| is true and |report_fd_pid|\n+// isn't equal to the current PID, try to obtain file descriptor by opening\n+// file \"report_path_prefix.<PID>\".\n static fd_t report_fd = kStderrFd;\n-static char report_path[4096];  // Set via __sanitizer_set_report_path.\n+static char report_path_prefix[4096];  // Set via __sanitizer_set_report_path.\n+// PID of process that opened |report_fd|. If a fork() occurs, the PID of the\n+// child thread will be different from |report_fd_pid|.\n+static int report_fd_pid = 0;\n \n static void (*DieCallback)(void);\n void SetDieCallback(void (*callback)(void)) {\n@@ -48,21 +54,29 @@ void NORETURN CheckFailed(const char *file, int line, const char *cond,\n   if (CheckFailedCallback) {\n     CheckFailedCallback(file, line, cond, v1, v2);\n   }\n-  Report(\"Sanitizer CHECK failed: %s:%d %s (%zd, %zd)\\n\", file, line, cond,\n-                                                          v1, v2);\n+  Report(\"Sanitizer CHECK failed: %s:%d %s (%lld, %lld)\\n\", file, line, cond,\n+                                                            v1, v2);\n   Die();\n }\n \n static void MaybeOpenReportFile() {\n-  if (report_fd != kInvalidFd)\n-    return;\n-  fd_t fd = internal_open(report_path, true);\n+  if (!log_to_file || (report_fd_pid == GetPid())) return;\n+  InternalScopedBuffer<char> report_path_full(4096);\n+  internal_snprintf(report_path_full.data(), report_path_full.size(),\n+                    \"%s.%d\", report_path_prefix, GetPid());\n+  fd_t fd = internal_open(report_path_full.data(), true);\n   if (fd == kInvalidFd) {\n     report_fd = kStderrFd;\n-    Report(\"ERROR: Can't open file: %s\\n\", report_path);\n+    log_to_file = false;\n+    Report(\"ERROR: Can't open file: %s\\n\", report_path_full.data());\n     Die();\n   }\n+  if (report_fd != kInvalidFd) {\n+    // We're in the child. Close the parent's log.\n+    internal_close(report_fd);\n+  }\n   report_fd = fd;\n+  report_fd_pid = GetPid();\n }\n \n bool PrintsToTty() {\n@@ -182,14 +196,16 @@ extern \"C\" {\n void __sanitizer_set_report_path(const char *path) {\n   if (!path) return;\n   uptr len = internal_strlen(path);\n-  if (len > sizeof(report_path) - 100) {\n+  if (len > sizeof(report_path_prefix) - 100) {\n     Report(\"ERROR: Path is too long: %c%c%c%c%c%c%c%c...\\n\",\n            path[0], path[1], path[2], path[3],\n            path[4], path[5], path[6], path[7]);\n     Die();\n   }\n-  internal_snprintf(report_path, sizeof(report_path), \"%s.%d\", path, GetPid());\n+  internal_strncpy(report_path_prefix, path, sizeof(report_path_prefix));\n+  report_path_prefix[len] = '\\0';\n   report_fd = kInvalidFd;\n+  log_to_file = true;\n }\n \n void __sanitizer_set_report_fd(int fd) {"}, {"sha": "97c6b6f7beb0105a828fc2c14230b07470cbea20", "filename": "libsanitizer/sanitizer_common/sanitizer_common_interceptors.h", "status": "removed", "additions": 0, "deletions": 77, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b39968989d6ae4289c01202c45268b5651d1c222/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interceptors.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b39968989d6ae4289c01202c45268b5651d1c222/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interceptors.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interceptors.h?ref=b39968989d6ae4289c01202c45268b5651d1c222", "patch": "@@ -1,77 +0,0 @@\n-//===-- sanitizer_common_interceptors.h -------------------------*- C++ -*-===//\n-//\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n-//\n-//===----------------------------------------------------------------------===//\n-//\n-// Common function interceptors for tools like AddressSanitizer,\n-// ThreadSanitizer, MemorySanitizer, etc.\n-//\n-// This file should be included into the tool's interceptor file,\n-// which has to define it's own macros:\n-//   COMMON_INTERCEPTOR_ENTER\n-//   COMMON_INTERCEPTOR_READ_RANGE\n-//   COMMON_INTERCEPTOR_WRITE_RANGE\n-//\n-//===----------------------------------------------------------------------===//\n-#ifndef SANITIZER_COMMON_INTERCEPTORS_H\n-#define SANITIZER_COMMON_INTERCEPTORS_H\n-\n-#include \"interception/interception.h\"\n-#include \"sanitizer_platform_interceptors.h\"\n-\n-#if SANITIZER_INTERCEPT_READ\n-INTERCEPTOR(SSIZE_T, read, int fd, void *ptr, SIZE_T count) {\n-  COMMON_INTERCEPTOR_ENTER(read, fd, ptr, count);\n-  SSIZE_T res = REAL(read)(fd, ptr, count);\n-  if (res > 0)\n-    COMMON_INTERCEPTOR_WRITE_RANGE(ptr, res);\n-  return res;\n-}\n-#endif\n-\n-#if SANITIZER_INTERCEPT_PREAD\n-INTERCEPTOR(SSIZE_T, pread, int fd, void *ptr, SIZE_T count, OFF_T offset) {\n-  COMMON_INTERCEPTOR_ENTER(pread, fd, ptr, count, offset);\n-  SSIZE_T res = REAL(pread)(fd, ptr, count, offset);\n-  if (res > 0)\n-    COMMON_INTERCEPTOR_WRITE_RANGE(ptr, res);\n-  return res;\n-}\n-#endif\n-\n-#if SANITIZER_INTERCEPT_PREAD64\n-INTERCEPTOR(SSIZE_T, pread64, int fd, void *ptr, SIZE_T count, OFF64_T offset) {\n-  COMMON_INTERCEPTOR_ENTER(pread64, fd, ptr, count, offset);\n-  SSIZE_T res = REAL(pread64)(fd, ptr, count, offset);\n-  if (res > 0)\n-    COMMON_INTERCEPTOR_WRITE_RANGE(ptr, res);\n-  return res;\n-}\n-#endif\n-\n-#if SANITIZER_INTERCEPT_READ\n-# define INIT_READ INTERCEPT_FUNCTION(read)\n-#else\n-# define INIT_READ\n-#endif\n-\n-#if SANITIZER_INTERCEPT_PREAD\n-# define INIT_PREAD INTERCEPT_FUNCTION(pread)\n-#else\n-# define INIT_PREAD\n-#endif\n-\n-#if SANITIZER_INTERCEPT_PREAD64\n-# define INIT_PREAD64 INTERCEPT_FUNCTION(pread64)\n-#else\n-# define INIT_PREAD64\n-#endif\n-\n-#define SANITIZER_COMMON_INTERCEPTORS_INIT \\\n-  INIT_READ;                               \\\n-  INIT_PREAD;                              \\\n-  INIT_PREAD64;                            \\\n-\n-#endif  // SANITIZER_COMMON_INTERCEPTORS_H"}, {"sha": "724a326ef4c4b4895b902da91989e28ec1abe9ee", "filename": "libsanitizer/sanitizer_common/sanitizer_common_interceptors.inc", "status": "added", "additions": 222, "deletions": 0, "changes": 222, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2660d12d0a69539959dc1f77648f9f29f5e0edf8/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interceptors.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2660d12d0a69539959dc1f77648f9f29f5e0edf8/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interceptors.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interceptors.inc?ref=2660d12d0a69539959dc1f77648f9f29f5e0edf8", "patch": "@@ -0,0 +1,222 @@\n+//===-- sanitizer_common_interceptors.inc -----------------------*- C++ -*-===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// Common function interceptors for tools like AddressSanitizer,\n+// ThreadSanitizer, MemorySanitizer, etc.\n+//\n+// This file should be included into the tool's interceptor file,\n+// which has to define it's own macros:\n+//   COMMON_INTERCEPTOR_ENTER\n+//   COMMON_INTERCEPTOR_READ_RANGE\n+//   COMMON_INTERCEPTOR_WRITE_RANGE\n+//   COMMON_INTERCEPTOR_FD_ACQUIRE\n+//   COMMON_INTERCEPTOR_FD_RELEASE\n+//   COMMON_INTERCEPTOR_SET_THREAD_NAME\n+//===----------------------------------------------------------------------===//\n+#include \"interception/interception.h\"\n+#include \"sanitizer_platform_interceptors.h\"\n+\n+#include <stdarg.h>\n+\n+#if SANITIZER_INTERCEPT_READ\n+INTERCEPTOR(SSIZE_T, read, int fd, void *ptr, SIZE_T count) {\n+  void* ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, read, fd, ptr, count);\n+  SSIZE_T res = REAL(read)(fd, ptr, count);\n+  if (res > 0)\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, ptr, res);\n+  if (res >= 0 && fd >= 0)\n+    COMMON_INTERCEPTOR_FD_ACQUIRE(ctx, fd);\n+  return res;\n+}\n+# define INIT_READ INTERCEPT_FUNCTION(read)\n+#else\n+# define INIT_READ\n+#endif\n+\n+#if SANITIZER_INTERCEPT_PREAD\n+INTERCEPTOR(SSIZE_T, pread, int fd, void *ptr, SIZE_T count, OFF_T offset) {\n+  void* ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, pread, fd, ptr, count, offset);\n+  SSIZE_T res = REAL(pread)(fd, ptr, count, offset);\n+  if (res > 0)\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, ptr, res);\n+  if (res >= 0 && fd >= 0)\n+    COMMON_INTERCEPTOR_FD_ACQUIRE(ctx, fd);\n+  return res;\n+}\n+# define INIT_PREAD INTERCEPT_FUNCTION(pread)\n+#else\n+# define INIT_PREAD\n+#endif\n+\n+#if SANITIZER_INTERCEPT_PREAD64\n+INTERCEPTOR(SSIZE_T, pread64, int fd, void *ptr, SIZE_T count, OFF64_T offset) {\n+  void* ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, pread64, fd, ptr, count, offset);\n+  SSIZE_T res = REAL(pread64)(fd, ptr, count, offset);\n+  if (res > 0)\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, ptr, res);\n+  if (res >= 0 && fd >= 0)\n+    COMMON_INTERCEPTOR_FD_ACQUIRE(ctx, fd);\n+  return res;\n+}\n+# define INIT_PREAD64 INTERCEPT_FUNCTION(pread64)\n+#else\n+# define INIT_PREAD64\n+#endif\n+\n+#if SANITIZER_INTERCEPT_WRITE\n+INTERCEPTOR(SSIZE_T, write, int fd, void *ptr, SIZE_T count) {\n+  void* ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, write, fd, ptr, count);\n+  if (fd >= 0)\n+    COMMON_INTERCEPTOR_FD_RELEASE(ctx, fd);\n+  SSIZE_T res = REAL(write)(fd, ptr, count);\n+  if (res > 0)\n+    COMMON_INTERCEPTOR_READ_RANGE(ctx, ptr, res);\n+  return res;\n+}\n+# define INIT_WRITE INTERCEPT_FUNCTION(write)\n+#else\n+# define INIT_WRITE\n+#endif\n+\n+#if SANITIZER_INTERCEPT_PWRITE\n+INTERCEPTOR(SSIZE_T, pwrite, int fd, void *ptr, SIZE_T count) {\n+  void* ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, pwrite, fd, ptr, count);\n+  if (fd >= 0)\n+    COMMON_INTERCEPTOR_FD_RELEASE(ctx, fd);\n+  SSIZE_T res = REAL(pwrite)(fd, ptr, count);\n+  if (res > 0)\n+    COMMON_INTERCEPTOR_READ_RANGE(ctx, ptr, res);\n+  return res;\n+}\n+# define INIT_PWRITE INTERCEPT_FUNCTION(pwrite)\n+#else\n+# define INIT_PWRITE\n+#endif\n+\n+#if SANITIZER_INTERCEPT_PWRITE64\n+INTERCEPTOR(SSIZE_T, pwrite64, int fd, void *ptr, OFF64_T count) {\n+  void* ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, pwrite64, fd, ptr, count);\n+  if (fd >= 0)\n+    COMMON_INTERCEPTOR_FD_RELEASE(ctx, fd);\n+  SSIZE_T res = REAL(pwrite64)(fd, ptr, count);\n+  if (res > 0)\n+    COMMON_INTERCEPTOR_READ_RANGE(ctx, ptr, res);\n+  return res;\n+}\n+# define INIT_PWRITE64 INTERCEPT_FUNCTION(pwrite64)\n+#else\n+# define INIT_PWRITE64\n+#endif\n+\n+#if SANITIZER_INTERCEPT_PRCTL\n+INTERCEPTOR(int, prctl, int option,\n+            unsigned long arg2, unsigned long arg3,  // NOLINT\n+            unsigned long arg4, unsigned long arg5) {  // NOLINT\n+  void* ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, prctl, option, arg2, arg3, arg4, arg5);\n+  static const int PR_SET_NAME = 15;\n+  int res = REAL(prctl(option, arg2, arg3, arg4, arg5));\n+  if (option == PR_SET_NAME) {\n+    char buff[16];\n+    internal_strncpy(buff, (char*)arg2, 15);\n+    buff[15] = 0;\n+    COMMON_INTERCEPTOR_SET_THREAD_NAME(ctx, buff);\n+  }\n+  return res;\n+}\n+# define INIT_PRCTL INTERCEPT_FUNCTION(prctl)\n+#else\n+# define INIT_PRCTL\n+#endif  // SANITIZER_INTERCEPT_PRCTL\n+\n+\n+#if SANITIZER_INTERCEPT_SCANF\n+\n+#include \"sanitizer_common_interceptors_scanf.inc\"\n+\n+INTERCEPTOR(int, vscanf, const char *format, va_list ap) {  // NOLINT\n+  void* ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, vscanf, format, ap);\n+  scanf_common(ctx, format, ap);\n+  int res = REAL(vscanf)(format, ap);  // NOLINT\n+  return res;\n+}\n+\n+INTERCEPTOR(int, vsscanf, const char *str, const char *format,  // NOLINT\n+    va_list ap) {\n+  void* ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, vsscanf, str, format, ap);\n+  scanf_common(ctx, format, ap);\n+  int res = REAL(vsscanf)(str, format, ap);  // NOLINT\n+  // FIXME: read of str\n+  return res;\n+}\n+\n+INTERCEPTOR(int, vfscanf, void *stream, const char *format,  // NOLINT\n+    va_list ap) {\n+  void* ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, vfscanf, stream, format, ap);\n+  scanf_common(ctx, format, ap);\n+  int res = REAL(vfscanf)(stream, format, ap);  // NOLINT\n+  return res;\n+}\n+\n+INTERCEPTOR(int, scanf, const char *format, ...) {  // NOLINT\n+  void* ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, scanf, format);\n+  va_list ap;\n+  va_start(ap, format);\n+  int res = vscanf(format, ap);  // NOLINT\n+  va_end(ap);\n+  return res;\n+}\n+\n+INTERCEPTOR(int, fscanf, void* stream, const char *format, ...) {  // NOLINT\n+  void* ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, fscanf, stream, format);\n+  va_list ap;\n+  va_start(ap, format);\n+  int res = vfscanf(stream, format, ap);  // NOLINT\n+  va_end(ap);\n+  return res;\n+}\n+\n+INTERCEPTOR(int, sscanf, const char *str, const char *format, ...) {  // NOLINT\n+  void* ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, sscanf, str, format);  // NOLINT\n+  va_list ap;\n+  va_start(ap, format);\n+  int res = vsscanf(str, format, ap);  // NOLINT\n+  va_end(ap);\n+  return res;\n+}\n+\n+#define INIT_SCANF \\\n+  INTERCEPT_FUNCTION(scanf);                    \\\n+  INTERCEPT_FUNCTION(sscanf);  /* NOLINT */     \\\n+  INTERCEPT_FUNCTION(fscanf);                   \\\n+  INTERCEPT_FUNCTION(vscanf);                   \\\n+  INTERCEPT_FUNCTION(vsscanf);                  \\\n+  INTERCEPT_FUNCTION(vfscanf)\n+\n+#else\n+#define INIT_SCANF\n+#endif\n+\n+#define SANITIZER_COMMON_INTERCEPTORS_INIT \\\n+  INIT_READ;                               \\\n+  INIT_PREAD;                              \\\n+  INIT_PREAD64;                            \\\n+  INIT_PRCTL;                              \\\n+  INIT_WRITE;                              \\\n+  INIT_SCANF;"}, {"sha": "f7cab5f0dbb53b17b2b6d5e81a7a414f0f95681f", "filename": "libsanitizer/sanitizer_common/sanitizer_common_interceptors_scanf.inc", "status": "added", "additions": 144, "deletions": 0, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2660d12d0a69539959dc1f77648f9f29f5e0edf8/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interceptors_scanf.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2660d12d0a69539959dc1f77648f9f29f5e0edf8/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interceptors_scanf.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interceptors_scanf.inc?ref=2660d12d0a69539959dc1f77648f9f29f5e0edf8", "patch": "@@ -0,0 +1,144 @@\n+//===-- sanitizer_common_interceptors_scanf.inc -----------------*- C++ -*-===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// Scanf implementation for use in *Sanitizer interceptors.\n+//\n+//===----------------------------------------------------------------------===//\n+#include <stdarg.h>\n+\n+#ifdef _WIN32\n+#define va_copy(dst, src) ((dst) = (src))\n+#endif  // _WIN32\n+\n+struct ScanfSpec {\n+  char c;\n+  unsigned size;\n+};\n+\n+// One-letter specs.\n+static const ScanfSpec scanf_specs[] = {\n+  {'p', sizeof(void *)},\n+  {'e', sizeof(float)},\n+  {'E', sizeof(float)},\n+  {'a', sizeof(float)},\n+  {'f', sizeof(float)},\n+  {'g', sizeof(float)},\n+  {'d', sizeof(int)},\n+  {'i', sizeof(int)},\n+  {'o', sizeof(int)},\n+  {'u', sizeof(int)},\n+  {'x', sizeof(int)},\n+  {'X', sizeof(int)},\n+  {'n', sizeof(int)},\n+  {'t', sizeof(PTRDIFF_T)},\n+  {'z', sizeof(SIZE_T)},\n+  {'j', sizeof(INTMAX_T)},\n+  {'h', sizeof(short)}\n+};\n+\n+static const unsigned scanf_specs_cnt =\n+  sizeof(scanf_specs) / sizeof(scanf_specs[0]);\n+\n+// %ll?, %L?, %q? specs\n+static const ScanfSpec scanf_llspecs[] = {\n+  {'e', sizeof(long double)},\n+  {'f', sizeof(long double)},\n+  {'g', sizeof(long double)},\n+  {'d', sizeof(long long)},\n+  {'i', sizeof(long long)},\n+  {'o', sizeof(long long)},\n+  {'u', sizeof(long long)},\n+  {'x', sizeof(long long)}\n+};\n+\n+static const unsigned scanf_llspecs_cnt =\n+  sizeof(scanf_llspecs) / sizeof(scanf_llspecs[0]);\n+\n+// %l? specs\n+static const ScanfSpec scanf_lspecs[] = {\n+  {'e', sizeof(double)},\n+  {'f', sizeof(double)},\n+  {'g', sizeof(double)},\n+  {'d', sizeof(long)},\n+  {'i', sizeof(long)},\n+  {'o', sizeof(long)},\n+  {'u', sizeof(long)},\n+  {'x', sizeof(long)},\n+  {'X', sizeof(long)},\n+};\n+\n+static const unsigned scanf_lspecs_cnt =\n+  sizeof(scanf_lspecs) / sizeof(scanf_lspecs[0]);\n+\n+static unsigned match_spec(const struct ScanfSpec *spec, unsigned n, char c) {\n+  for (unsigned i = 0; i < n; ++i)\n+    if (spec[i].c == c)\n+      return spec[i].size;\n+  return 0;\n+}\n+\n+static void scanf_common(void *ctx, const char *format, va_list ap_const) {\n+  va_list aq;\n+  va_copy(aq, ap_const);\n+\n+  const char *p = format;\n+  unsigned size;\n+\n+  while (*p) {\n+    if (*p != '%') {\n+      ++p;\n+      continue;\n+    }\n+    ++p;\n+    if (*p == '*' || *p == '%' || *p == 0) {\n+      ++p;\n+      continue;\n+    }\n+    if (*p == '0' || (*p >= '1' && *p <= '9')) {\n+      size = internal_atoll(p);\n+      // +1 for the \\0 at the end\n+      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, va_arg(aq, void *), size + 1);\n+      ++p;\n+      continue;\n+    }\n+\n+    if (*p == 'L' || *p == 'q') {\n+      ++p;\n+      size = match_spec(scanf_llspecs, scanf_llspecs_cnt, *p);\n+      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, va_arg(aq, void *), size);\n+      continue;\n+    }\n+\n+    if (*p == 'l') {\n+      ++p;\n+      if (*p == 'l') {\n+        ++p;\n+        size = match_spec(scanf_llspecs, scanf_llspecs_cnt, *p);\n+        COMMON_INTERCEPTOR_WRITE_RANGE(ctx, va_arg(aq, void *), size);\n+        continue;\n+      } else {\n+        size = match_spec(scanf_lspecs, scanf_lspecs_cnt, *p);\n+        COMMON_INTERCEPTOR_WRITE_RANGE(ctx, va_arg(aq, void *), size);\n+        continue;\n+      }\n+    }\n+\n+    if (*p == 'h' && *(p + 1) == 'h') {\n+      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, va_arg(aq, void *), sizeof(char));\n+      p += 2;\n+      continue;\n+    }\n+\n+    size = match_spec(scanf_specs, scanf_specs_cnt, *p);\n+    if (size) {\n+      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, va_arg(aq, void *), size);\n+      ++p;\n+      continue;\n+    }\n+  }\n+  va_end(aq);\n+}"}, {"sha": "01f08f578011da9b3a0a1a4a4452b46278133623", "filename": "libsanitizer/sanitizer_common/sanitizer_internal_defs.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2660d12d0a69539959dc1f77648f9f29f5e0edf8/libsanitizer%2Fsanitizer_common%2Fsanitizer_internal_defs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2660d12d0a69539959dc1f77648f9f29f5e0edf8/libsanitizer%2Fsanitizer_common%2Fsanitizer_internal_defs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_internal_defs.h?ref=2660d12d0a69539959dc1f77648f9f29f5e0edf8", "patch": "@@ -36,6 +36,7 @@ using namespace __sanitizer;  // NOLINT\n # define UNLIKELY(x) (x)\n # define UNUSED\n # define USED\n+# define PREFETCH(x) /* _mm_prefetch(x, _MM_HINT_NTA) */\n #else  // _MSC_VER\n # define ALWAYS_INLINE __attribute__((always_inline))\n # define ALIAS(x) __attribute__((alias(x)))\n@@ -49,6 +50,12 @@ using namespace __sanitizer;  // NOLINT\n # define UNLIKELY(x)   __builtin_expect(!!(x), 0)\n # define UNUSED __attribute__((unused))\n # define USED __attribute__((used))\n+# if defined(__i386__) || defined(__x86_64__)\n+// __builtin_prefetch(x) generates prefetchnt0 on x86\n+#  define PREFETCH(x) __asm__(\"prefetchnta (%0)\" : : \"r\" (x))\n+# else\n+#  define PREFETCH(x) __builtin_prefetch(x)\n+# endif\n #endif  // _MSC_VER\n \n #if defined(_WIN32)"}, {"sha": "63fbf066943b0a264e9217cec689780d9060a500", "filename": "libsanitizer/sanitizer_common/sanitizer_lfstack.h", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2660d12d0a69539959dc1f77648f9f29f5e0edf8/libsanitizer%2Fsanitizer_common%2Fsanitizer_lfstack.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2660d12d0a69539959dc1f77648f9f29f5e0edf8/libsanitizer%2Fsanitizer_common%2Fsanitizer_lfstack.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_lfstack.h?ref=2660d12d0a69539959dc1f77648f9f29f5e0edf8", "patch": "@@ -0,0 +1,71 @@\n+//===-- sanitizer_lfstack.h -=-----------------------------------*- C++ -*-===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// Lock-free stack.\n+// Uses 32/17 bits as ABA-counter on 32/64-bit platforms.\n+// The memory passed to Push() must not be ever munmap'ed.\n+// The type T must contain T *next field.\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#ifndef SANITIZER_LFSTACK_H\n+#define SANITIZER_LFSTACK_H\n+\n+#include \"sanitizer_internal_defs.h\"\n+#include \"sanitizer_common.h\"\n+#include \"sanitizer_atomic.h\"\n+\n+namespace __sanitizer {\n+\n+template<typename T>\n+struct LFStack {\n+  void Clear() {\n+    atomic_store(&head_, 0, memory_order_relaxed);\n+  }\n+\n+  bool Empty() const {\n+    return (atomic_load(&head_, memory_order_relaxed) & kPtrMask) == 0;\n+  }\n+\n+  void Push(T *p) {\n+    u64 cmp = atomic_load(&head_, memory_order_relaxed);\n+    for (;;) {\n+      u64 cnt = (cmp & kCounterMask) + kCounterInc;\n+      u64 xch = (u64)(uptr)p | cnt;\n+      p->next = (T*)(uptr)(cmp & kPtrMask);\n+      if (atomic_compare_exchange_weak(&head_, &cmp, xch,\n+                                       memory_order_release))\n+        break;\n+    }\n+  }\n+\n+  T *Pop() {\n+    u64 cmp = atomic_load(&head_, memory_order_acquire);\n+    for (;;) {\n+      T *cur = (T*)(uptr)(cmp & kPtrMask);\n+      if (cur == 0)\n+        return 0;\n+      T *nxt = cur->next;\n+      u64 cnt = (cmp & kCounterMask);\n+      u64 xch = (u64)(uptr)nxt | cnt;\n+      if (atomic_compare_exchange_weak(&head_, &cmp, xch,\n+                                       memory_order_acquire))\n+        return cur;\n+    }\n+  }\n+\n+  // private:\n+  static const int kCounterBits = FIRST_32_SECOND_64(32, 17);\n+  static const u64 kPtrMask = ((u64)-1) >> kCounterBits;\n+  static const u64 kCounterMask = ~kPtrMask;\n+  static const u64 kCounterInc = kPtrMask + 1;\n+\n+  atomic_uint64_t head_;\n+};\n+}\n+\n+#endif  // #ifndef SANITIZER_LFSTACK_H"}, {"sha": "dc2148f7fc4b46c12994a0bddff87e886cdba13c", "filename": "libsanitizer/sanitizer_common/sanitizer_linux.cc", "status": "modified", "additions": 55, "deletions": 13, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2660d12d0a69539959dc1f77648f9f29f5e0edf8/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2660d12d0a69539959dc1f77648f9f29f5e0edf8/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux.cc?ref=2660d12d0a69539959dc1f77648f9f29f5e0edf8", "patch": "@@ -32,6 +32,7 @@\n #include <unwind.h>\n #include <errno.h>\n #include <sys/prctl.h>\n+#include <linux/futex.h>\n \n // Are we using 32-bit or 64-bit syscalls?\n // x32 (which defines __x86_64__) has SANITIZER_WORDSIZE == 32\n@@ -198,24 +199,31 @@ const char *GetEnv(const char *name) {\n   return 0;  // Not found.\n }\n \n-void ReExec() {\n-  static const int kMaxArgv = 100;\n-  InternalScopedBuffer<char*> argv(kMaxArgv + 1);\n-  static char *buff;\n+static void ReadNullSepFileToArray(const char *path, char ***arr,\n+                                   int arr_size) {\n+  char *buff;\n   uptr buff_size = 0;\n-  ReadFileToBuffer(\"/proc/self/cmdline\", &buff, &buff_size, 1024 * 1024);\n-  argv[0] = buff;\n-  int argc, i;\n-  for (argc = 1, i = 1; ; i++) {\n+  *arr = (char **)MmapOrDie(arr_size * sizeof(char *), \"NullSepFileArray\");\n+  ReadFileToBuffer(path, &buff, &buff_size, 1024 * 1024);\n+  (*arr)[0] = buff;\n+  int count, i;\n+  for (count = 1, i = 1; ; i++) {\n     if (buff[i] == 0) {\n       if (buff[i+1] == 0) break;\n-      argv[argc] = &buff[i+1];\n-      CHECK_LE(argc, kMaxArgv);  // FIXME: make this more flexible.\n-      argc++;\n+      (*arr)[count] = &buff[i+1];\n+      CHECK_LE(count, arr_size - 1);  // FIXME: make this more flexible.\n+      count++;\n     }\n   }\n-  argv[argc] = 0;\n-  execv(argv[0], argv.data());\n+  (*arr)[count] = 0;\n+}\n+\n+void ReExec() {\n+  static const int kMaxArgv = 100, kMaxEnvp = 1000;\n+  char **argv, **envp;\n+  ReadNullSepFileToArray(\"/proc/self/cmdline\", &argv, kMaxArgv);\n+  ReadNullSepFileToArray(\"/proc/self/environ\", &envp, kMaxEnvp);\n+  execve(argv[0], argv, envp);\n }\n \n void PrepareForSandboxing() {\n@@ -366,16 +374,24 @@ bool MemoryMappingLayout::GetObjectNameAndOffset(uptr addr, uptr *offset,\n }\n \n bool SanitizerSetThreadName(const char *name) {\n+#ifdef PR_SET_NAME\n   return 0 == prctl(PR_SET_NAME, (unsigned long)name, 0, 0, 0);  // NOLINT\n+#else\n+  return false;\n+#endif\n }\n \n bool SanitizerGetThreadName(char *name, int max_len) {\n+#ifdef PR_GET_NAME\n   char buff[17];\n   if (prctl(PR_GET_NAME, (unsigned long)buff, 0, 0, 0))  // NOLINT\n     return false;\n   internal_strncpy(name, buff, max_len);\n   name[max_len] = 0;\n   return true;\n+#else\n+  return false;\n+#endif\n }\n \n #ifndef SANITIZER_GO\n@@ -434,6 +450,32 @@ void StackTrace::SlowUnwindStack(uptr pc, uptr max_depth) {\n \n #endif  // #ifndef SANITIZER_GO\n \n+enum MutexState {\n+  MtxUnlocked = 0,\n+  MtxLocked = 1,\n+  MtxSleeping = 2\n+};\n+\n+BlockingMutex::BlockingMutex(LinkerInitialized) {\n+  CHECK_EQ(owner_, 0);\n+}\n+\n+void BlockingMutex::Lock() {\n+  atomic_uint32_t *m = reinterpret_cast<atomic_uint32_t *>(&opaque_storage_);\n+  if (atomic_exchange(m, MtxLocked, memory_order_acquire) == MtxUnlocked)\n+    return;\n+  while (atomic_exchange(m, MtxSleeping, memory_order_acquire) != MtxUnlocked)\n+    syscall(__NR_futex, m, FUTEX_WAIT, MtxSleeping, 0, 0, 0);\n+}\n+\n+void BlockingMutex::Unlock() {\n+  atomic_uint32_t *m = reinterpret_cast<atomic_uint32_t *>(&opaque_storage_);\n+  u32 v = atomic_exchange(m, MtxUnlocked, memory_order_relaxed);\n+  CHECK_NE(v, MtxUnlocked);\n+  if (v == MtxSleeping)\n+    syscall(__NR_futex, m, FUTEX_WAKE, 1, 0, 0, 0);\n+}\n+\n }  // namespace __sanitizer\n \n #endif  // __linux__"}, {"sha": "9692e01b8e0183a7c2148a7adda8906cafbacd66", "filename": "libsanitizer/sanitizer_common/sanitizer_list.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2660d12d0a69539959dc1f77648f9f29f5e0edf8/libsanitizer%2Fsanitizer_common%2Fsanitizer_list.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2660d12d0a69539959dc1f77648f9f29f5e0edf8/libsanitizer%2Fsanitizer_common%2Fsanitizer_list.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_list.h?ref=2660d12d0a69539959dc1f77648f9f29f5e0edf8", "patch": "@@ -70,6 +70,8 @@ struct IntrusiveList {\n \n   void append_front(IntrusiveList<Item> *l) {\n     CHECK_NE(this, l);\n+    if (l->empty())\n+      return;\n     if (empty()) {\n       *this = *l;\n     } else if (!l->empty()) {\n@@ -82,6 +84,8 @@ struct IntrusiveList {\n \n   void append_back(IntrusiveList<Item> *l) {\n     CHECK_NE(this, l);\n+    if (l->empty())\n+      return;\n     if (empty()) {\n       *this = *l;\n     } else {"}, {"sha": "76bf86708709dd27901c90c9c3b36c19cc5462d0", "filename": "libsanitizer/sanitizer_common/sanitizer_mac.cc", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2660d12d0a69539959dc1f77648f9f29f5e0edf8/libsanitizer%2Fsanitizer_common%2Fsanitizer_mac.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2660d12d0a69539959dc1f77648f9f29f5e0edf8/libsanitizer%2Fsanitizer_common%2Fsanitizer_mac.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_mac.cc?ref=2660d12d0a69539959dc1f77648f9f29f5e0edf8", "patch": "@@ -28,6 +28,7 @@\n #include <sys/stat.h>\n #include <sys/types.h>\n #include <unistd.h>\n+#include <libkern/OSAtomic.h>\n \n namespace __sanitizer {\n \n@@ -265,6 +266,25 @@ bool MemoryMappingLayout::GetObjectNameAndOffset(uptr addr, uptr *offset,\n   return IterateForObjectNameAndOffset(addr, offset, filename, filename_size);\n }\n \n+BlockingMutex::BlockingMutex(LinkerInitialized) {\n+  // We assume that OS_SPINLOCK_INIT is zero\n+}\n+\n+void BlockingMutex::Lock() {\n+  CHECK(sizeof(OSSpinLock) <= sizeof(opaque_storage_));\n+  CHECK(OS_SPINLOCK_INIT == 0);\n+  CHECK(owner_ != (uptr)pthread_self());\n+  OSSpinLockLock((OSSpinLock*)&opaque_storage_);\n+  CHECK(!owner_);\n+  owner_ = (uptr)pthread_self();\n+}\n+\n+void BlockingMutex::Unlock() {\n+  CHECK(owner_ == (uptr)pthread_self());\n+  owner_ = 0;\n+  OSSpinLockUnlock((OSSpinLock*)&opaque_storage_);\n+}\n+\n }  // namespace __sanitizer\n \n #endif  // __APPLE__"}, {"sha": "27009118e62fb9b9611106ce249811ed023a388c", "filename": "libsanitizer/sanitizer_common/sanitizer_mutex.h", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2660d12d0a69539959dc1f77648f9f29f5e0edf8/libsanitizer%2Fsanitizer_common%2Fsanitizer_mutex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2660d12d0a69539959dc1f77648f9f29f5e0edf8/libsanitizer%2Fsanitizer_common%2Fsanitizer_mutex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_mutex.h?ref=2660d12d0a69539959dc1f77648f9f29f5e0edf8", "patch": "@@ -25,11 +25,15 @@ class StaticSpinMutex {\n   }\n \n   void Lock() {\n-    if (atomic_exchange(&state_, 1, memory_order_acquire) == 0)\n+    if (TryLock())\n       return;\n     LockSlow();\n   }\n \n+  bool TryLock() {\n+    return atomic_exchange(&state_, 1, memory_order_acquire) == 0;\n+  }\n+\n   void Unlock() {\n     atomic_store(&state_, 0, memory_order_release);\n   }\n@@ -61,6 +65,16 @@ class SpinMutex : public StaticSpinMutex {\n   void operator=(const SpinMutex&);\n };\n \n+class BlockingMutex {\n+ public:\n+  explicit BlockingMutex(LinkerInitialized);\n+  void Lock();\n+  void Unlock();\n+ private:\n+  uptr opaque_storage_[10];\n+  uptr owner_;  // for debugging\n+};\n+\n template<typename MutexType>\n class GenericScopedLock {\n  public:\n@@ -100,6 +114,7 @@ class GenericScopedReadLock {\n };\n \n typedef GenericScopedLock<StaticSpinMutex> SpinMutexLock;\n+typedef GenericScopedLock<BlockingMutex> BlockingMutexLock;\n \n }  // namespace __sanitizer\n "}, {"sha": "0ca9444fcb8b714d85b5e4f0ffab411e31eeaa75", "filename": "libsanitizer/sanitizer_common/sanitizer_platform_interceptors.h", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2660d12d0a69539959dc1f77648f9f29f5e0edf8/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_interceptors.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2660d12d0a69539959dc1f77648f9f29f5e0edf8/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_interceptors.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_interceptors.h?ref=2660d12d0a69539959dc1f77648f9f29f5e0edf8", "patch": "@@ -13,15 +13,24 @@\n #include \"sanitizer_internal_defs.h\"\n \n #if !defined(_WIN32)\n-# define SANITIZER_INTERCEPT_READ 1\n-# define SANITIZER_INTERCEPT_PREAD 1\n+# define SI_NOT_WINDOWS 1\n #else\n-# define SANITIZER_INTERCEPT_READ 0\n-# define SANITIZER_INTERCEPT_PREAD 0\n+# define SI_NOT_WINDOWS 0\n #endif\n \n #if defined(__linux__) && !defined(ANDROID)\n-# define SANITIZER_INTERCEPT_PREAD64 1\n+# define SI_LINUX_NOT_ANDROID 1\n #else\n-# define SANITIZER_INTERCEPT_PREAD64 0\n+# define SI_LINUX_NOT_ANDROID 0\n #endif\n+\n+# define SANITIZER_INTERCEPT_READ   SI_NOT_WINDOWS\n+# define SANITIZER_INTERCEPT_PREAD  SI_NOT_WINDOWS\n+# define SANITIZER_INTERCEPT_WRITE  SI_NOT_WINDOWS\n+# define SANITIZER_INTERCEPT_PWRITE SI_NOT_WINDOWS\n+\n+# define SANITIZER_INTERCEPT_PREAD64 SI_LINUX_NOT_ANDROID\n+# define SANITIZER_INTERCEPT_PWRITE64 SI_LINUX_NOT_ANDROID\n+# define SANITIZER_INTERCEPT_PRCTL   SI_LINUX_NOT_ANDROID\n+\n+# define SANITIZER_INTERCEPT_SCANF 0"}, {"sha": "042fba7c1daf5af2aff3f62bcb867e87118105c2", "filename": "libsanitizer/sanitizer_common/sanitizer_quarantine.h", "status": "added", "additions": 170, "deletions": 0, "changes": 170, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2660d12d0a69539959dc1f77648f9f29f5e0edf8/libsanitizer%2Fsanitizer_common%2Fsanitizer_quarantine.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2660d12d0a69539959dc1f77648f9f29f5e0edf8/libsanitizer%2Fsanitizer_common%2Fsanitizer_quarantine.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_quarantine.h?ref=2660d12d0a69539959dc1f77648f9f29f5e0edf8", "patch": "@@ -0,0 +1,170 @@\n+//===-- sanitizer_quarantine.h ----------------------------------*- C++ -*-===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// Memory quarantine for AddressSanitizer and potentially other tools.\n+// Quarantine caches some specified amount of memory in per-thread caches,\n+// then evicts to global FIFO queue. When the queue reaches specified threshold,\n+// oldest memory is recycled.\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#ifndef SANITIZER_QUARANTINE_H\n+#define SANITIZER_QUARANTINE_H\n+\n+#include \"sanitizer_internal_defs.h\"\n+#include \"sanitizer_mutex.h\"\n+#include \"sanitizer_list.h\"\n+\n+namespace __sanitizer {\n+\n+template<typename Node> class QuarantineCache;\n+\n+struct QuarantineBatch {\n+  static const uptr kSize = 1024;\n+  QuarantineBatch *next;\n+  uptr size;\n+  uptr count;\n+  void *batch[kSize];\n+};\n+\n+// The callback interface is:\n+// void Callback::Recycle(Node *ptr);\n+// void *cb.Allocate(uptr size);\n+// void cb.Deallocate(void *ptr);\n+template<typename Callback, typename Node>\n+class Quarantine {\n+ public:\n+  typedef QuarantineCache<Callback> Cache;\n+\n+  explicit Quarantine(LinkerInitialized)\n+      : cache_(LINKER_INITIALIZED) {\n+  }\n+\n+  void Init(uptr size, uptr cache_size) {\n+    max_size_ = size;\n+    min_size_ = size / 10 * 9;  // 90% of max size.\n+    max_cache_size_ = cache_size;\n+  }\n+\n+  void Put(Cache *c, Callback cb, Node *ptr, uptr size) {\n+    c->Enqueue(cb, ptr, size);\n+    if (c->Size() > max_cache_size_)\n+      Drain(c, cb);\n+  }\n+\n+  void NOINLINE Drain(Cache *c, Callback cb) {\n+    {\n+      SpinMutexLock l(&cache_mutex_);\n+      cache_.Transfer(c);\n+    }\n+    if (cache_.Size() > max_size_ && recycle_mutex_.TryLock())\n+      Recycle(cb);\n+  }\n+\n+ private:\n+  // Read-only data.\n+  char pad0_[kCacheLineSize];\n+  uptr max_size_;\n+  uptr min_size_;\n+  uptr max_cache_size_;\n+  char pad1_[kCacheLineSize];\n+  SpinMutex cache_mutex_;\n+  SpinMutex recycle_mutex_;\n+  Cache cache_;\n+  char pad2_[kCacheLineSize];\n+\n+  void NOINLINE Recycle(Callback cb) {\n+    Cache tmp;\n+    {\n+      SpinMutexLock l(&cache_mutex_);\n+      while (cache_.Size() > min_size_) {\n+        QuarantineBatch *b = cache_.DequeueBatch();\n+        tmp.EnqueueBatch(b);\n+      }\n+    }\n+    recycle_mutex_.Unlock();\n+    DoRecycle(&tmp, cb);\n+  }\n+\n+  void NOINLINE DoRecycle(Cache *c, Callback cb) {\n+    while (QuarantineBatch *b = c->DequeueBatch()) {\n+      const uptr kPrefetch = 16;\n+      for (uptr i = 0; i < kPrefetch; i++)\n+        PREFETCH(b->batch[i]);\n+      for (uptr i = 0; i < b->count; i++) {\n+        PREFETCH(b->batch[i + kPrefetch]);\n+        cb.Recycle((Node*)b->batch[i]);\n+      }\n+      cb.Deallocate(b);\n+    }\n+  }\n+};\n+\n+// Per-thread cache of memory blocks.\n+template<typename Callback>\n+class QuarantineCache {\n+ public:\n+  explicit QuarantineCache(LinkerInitialized) {\n+  }\n+\n+  QuarantineCache()\n+      : size_() {\n+    list_.clear();\n+  }\n+\n+  uptr Size() const {\n+    return atomic_load(&size_, memory_order_relaxed);\n+  }\n+\n+  void Enqueue(Callback cb, void *ptr, uptr size) {\n+    if (list_.empty() || list_.back()->count == QuarantineBatch::kSize)\n+      AllocBatch(cb);\n+    QuarantineBatch *b = list_.back();\n+    b->batch[b->count++] = ptr;\n+    b->size += size;\n+    SizeAdd(size);\n+  }\n+\n+  void Transfer(QuarantineCache *c) {\n+    list_.append_back(&c->list_);\n+    SizeAdd(c->Size());\n+    atomic_store(&c->size_, 0, memory_order_relaxed);\n+  }\n+\n+  void EnqueueBatch(QuarantineBatch *b) {\n+    list_.push_back(b);\n+    SizeAdd(b->size);\n+  }\n+\n+  QuarantineBatch *DequeueBatch() {\n+    if (list_.empty())\n+      return 0;\n+    QuarantineBatch *b = list_.front();\n+    list_.pop_front();\n+    SizeAdd(-b->size);\n+    return b;\n+  }\n+\n+ private:\n+  IntrusiveList<QuarantineBatch> list_;\n+  atomic_uintptr_t size_;\n+\n+  void SizeAdd(uptr add) {\n+    atomic_store(&size_, Size() + add, memory_order_relaxed);\n+  }\n+\n+  QuarantineBatch *NOINLINE AllocBatch(Callback cb) {\n+    QuarantineBatch *b = (QuarantineBatch *)cb.Allocate(sizeof(*b));\n+    b->count = 0;\n+    b->size = 0;\n+    list_.push_back(b);\n+    return b;\n+  }\n+};\n+}\n+\n+#endif  // #ifndef SANITIZER_QUARANTINE_H"}, {"sha": "f62acf35f8fdf3bc410eae37ffbe6eb02aaf8ac5", "filename": "libsanitizer/sanitizer_common/sanitizer_symbolizer.cc", "status": "modified", "additions": 102, "deletions": 88, "changes": 190, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2660d12d0a69539959dc1f77648f9f29f5e0edf8/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2660d12d0a69539959dc1f77648f9f29f5e0edf8/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer.cc?ref=2660d12d0a69539959dc1f77648f9f29f5e0edf8", "patch": "@@ -66,7 +66,18 @@ static const char *ExtractInt(const char *str, const char *delims,\n   char *buff;\n   const char *ret = ExtractToken(str, delims, &buff);\n   if (buff != 0) {\n-    *result = internal_atoll(buff);\n+    *result = (int)internal_atoll(buff);\n+  }\n+  InternalFree(buff);\n+  return ret;\n+}\n+\n+static const char *ExtractUptr(const char *str, const char *delims,\n+                               uptr *result) {\n+  char *buff;\n+  const char *ret = ExtractToken(str, delims, &buff);\n+  if (buff != 0) {\n+    *result = (uptr)internal_atoll(buff);\n   }\n   InternalFree(buff);\n   return ret;\n@@ -96,66 +107,15 @@ class ExternalSymbolizer {\n     CHECK_NE(output_fd_, kInvalidFd);\n   }\n \n-  // Returns the number of frames for a given address, or zero if\n-  // symbolization failed.\n-  uptr SymbolizeCode(uptr addr, const char *module_name, uptr module_offset,\n-                     AddressInfo *frames, uptr max_frames) {\n+  char *SendCommand(bool is_data, const char *module_name, uptr module_offset) {\n     CHECK(module_name);\n-    // FIXME: Make sure this buffer always has sufficient size to hold\n-    // large debug info.\n-    static const int kMaxBufferSize = 4096;\n-    InternalScopedBuffer<char> buffer(kMaxBufferSize);\n-    char *buffer_data = buffer.data();\n-    internal_snprintf(buffer_data, kMaxBufferSize, \"%s 0x%zx\\n\",\n-                      module_name, module_offset);\n-    if (!writeToSymbolizer(buffer_data, internal_strlen(buffer_data)))\n+    internal_snprintf(buffer_, kBufferSize, \"%s%s 0x%zx\\n\",\n+                      is_data ? \"DATA \" : \"\", module_name, module_offset);\n+    if (!writeToSymbolizer(buffer_, internal_strlen(buffer_)))\n       return 0;\n-\n-    if (!readFromSymbolizer(buffer_data, kMaxBufferSize))\n+    if (!readFromSymbolizer(buffer_, kBufferSize))\n       return 0;\n-    const char *str = buffer_data;\n-    uptr frame_id;\n-    CHECK_GT(max_frames, 0);\n-    for (frame_id = 0; frame_id < max_frames; frame_id++) {\n-      AddressInfo *info = &frames[frame_id];\n-      char *function_name = 0;\n-      str = ExtractToken(str, \"\\n\", &function_name);\n-      CHECK(function_name);\n-      if (function_name[0] == '\\0') {\n-        // There are no more frames.\n-        break;\n-      }\n-      info->Clear();\n-      info->FillAddressAndModuleInfo(addr, module_name, module_offset);\n-      info->function = function_name;\n-      // Parse <file>:<line>:<column> buffer.\n-      char *file_line_info = 0;\n-      str = ExtractToken(str, \"\\n\", &file_line_info);\n-      CHECK(file_line_info);\n-      const char *line_info = ExtractToken(file_line_info, \":\", &info->file);\n-      line_info = ExtractInt(line_info, \":\", &info->line);\n-      line_info = ExtractInt(line_info, \"\", &info->column);\n-      InternalFree(file_line_info);\n-\n-      // Functions and filenames can be \"??\", in which case we write 0\n-      // to address info to mark that names are unknown.\n-      if (0 == internal_strcmp(info->function, \"??\")) {\n-        InternalFree(info->function);\n-        info->function = 0;\n-      }\n-      if (0 == internal_strcmp(info->file, \"??\")) {\n-        InternalFree(info->file);\n-        info->file = 0;\n-      }\n-    }\n-    if (frame_id == 0) {\n-      // Make sure we return at least one frame.\n-      AddressInfo *info = &frames[0];\n-      info->Clear();\n-      info->FillAddressAndModuleInfo(addr, module_name, module_offset);\n-      frame_id = 1;\n-    }\n-    return frame_id;\n+    return buffer_;\n   }\n \n   bool Restart() {\n@@ -189,6 +149,7 @@ class ExternalSymbolizer {\n     }\n     return true;\n   }\n+\n   bool writeToSymbolizer(const char *buffer, uptr length) {\n     if (length == 0)\n       return true;\n@@ -204,6 +165,9 @@ class ExternalSymbolizer {\n   int input_fd_;\n   int output_fd_;\n \n+  static const uptr kBufferSize = 16 * 1024;\n+  char buffer_[kBufferSize];\n+\n   static const uptr kMaxTimesRestarted = 5;\n   uptr times_restarted_;\n };\n@@ -220,48 +184,75 @@ class Symbolizer {\n       return 0;\n     const char *module_name = module->full_name();\n     uptr module_offset = addr - module->base_address();\n-    uptr actual_frames = 0;\n-    if (external_symbolizer_ == 0) {\n-      ReportExternalSymbolizerError(\n-          \"WARNING: Trying to symbolize code, but external \"\n-          \"symbolizer is not initialized!\\n\");\n-    } else {\n-      while (true) {\n-        actual_frames = external_symbolizer_->SymbolizeCode(\n-            addr, module_name, module_offset, frames, max_frames);\n-        if (actual_frames > 0) {\n-          // Symbolization was successful.\n-          break;\n-        }\n-        // Try to restart symbolizer subprocess. If we don't succeed, forget\n-        // about it and don't try to use it later.\n-        if (!external_symbolizer_->Restart()) {\n-          ReportExternalSymbolizerError(\n-              \"WARNING: Failed to use and restart external symbolizer!\\n\");\n-          external_symbolizer_ = 0;\n-          break;\n-        }\n-      }\n-    }\n-    if (external_symbolizer_ == 0) {\n+    const char *str = SendCommand(false, module_name, module_offset);\n+    if (str == 0) {\n       // External symbolizer was not initialized or failed. Fill only data\n       // about module name and offset.\n       AddressInfo *info = &frames[0];\n       info->Clear();\n       info->FillAddressAndModuleInfo(addr, module_name, module_offset);\n       return 1;\n     }\n-    // Otherwise, the data was filled by external symbolizer.\n-    return actual_frames;\n+    uptr frame_id = 0;\n+    for (frame_id = 0; frame_id < max_frames; frame_id++) {\n+      AddressInfo *info = &frames[frame_id];\n+      char *function_name = 0;\n+      str = ExtractToken(str, \"\\n\", &function_name);\n+      CHECK(function_name);\n+      if (function_name[0] == '\\0') {\n+        // There are no more frames.\n+        break;\n+      }\n+      info->Clear();\n+      info->FillAddressAndModuleInfo(addr, module_name, module_offset);\n+      info->function = function_name;\n+      // Parse <file>:<line>:<column> buffer.\n+      char *file_line_info = 0;\n+      str = ExtractToken(str, \"\\n\", &file_line_info);\n+      CHECK(file_line_info);\n+      const char *line_info = ExtractToken(file_line_info, \":\", &info->file);\n+      line_info = ExtractInt(line_info, \":\", &info->line);\n+      line_info = ExtractInt(line_info, \"\", &info->column);\n+      InternalFree(file_line_info);\n+\n+      // Functions and filenames can be \"??\", in which case we write 0\n+      // to address info to mark that names are unknown.\n+      if (0 == internal_strcmp(info->function, \"??\")) {\n+        InternalFree(info->function);\n+        info->function = 0;\n+      }\n+      if (0 == internal_strcmp(info->file, \"??\")) {\n+        InternalFree(info->file);\n+        info->file = 0;\n+      }\n+    }\n+    if (frame_id == 0) {\n+      // Make sure we return at least one frame.\n+      AddressInfo *info = &frames[0];\n+      info->Clear();\n+      info->FillAddressAndModuleInfo(addr, module_name, module_offset);\n+      frame_id = 1;\n+    }\n+    return frame_id;\n   }\n \n-  bool SymbolizeData(uptr addr, AddressInfo *frame) {\n+  bool SymbolizeData(uptr addr, DataInfo *info) {\n     LoadedModule *module = FindModuleForAddress(addr);\n     if (module == 0)\n       return false;\n     const char *module_name = module->full_name();\n     uptr module_offset = addr - module->base_address();\n-    frame->FillAddressAndModuleInfo(addr, module_name, module_offset);\n+    internal_memset(info, 0, sizeof(*info));\n+    info->address = addr;\n+    info->module = internal_strdup(module_name);\n+    info->module_offset = module_offset;\n+    const char *str = SendCommand(true, module_name, module_offset);\n+    if (str == 0)\n+      return true;\n+    str = ExtractToken(str, \"\\n\", &info->name);\n+    str = ExtractUptr(str, \" \", &info->start);\n+    str = ExtractUptr(str, \"\\n\", &info->size);\n+    info->start += module->base_address();\n     return true;\n   }\n \n@@ -276,6 +267,29 @@ class Symbolizer {\n   }\n \n  private:\n+  char *SendCommand(bool is_data, const char *module_name, uptr module_offset) {\n+    if (external_symbolizer_ == 0) {\n+      ReportExternalSymbolizerError(\n+          \"WARNING: Trying to symbolize code, but external \"\n+          \"symbolizer is not initialized!\\n\");\n+      return 0;\n+    }\n+    for (;;) {\n+      char *reply = external_symbolizer_->SendCommand(is_data, module_name,\n+          module_offset);\n+      if (reply)\n+        return reply;\n+      // Try to restart symbolizer subprocess. If we don't succeed, forget\n+      // about it and don't try to use it later.\n+      if (!external_symbolizer_->Restart()) {\n+        ReportExternalSymbolizerError(\n+            \"WARNING: Failed to use and restart external symbolizer!\\n\");\n+        external_symbolizer_ = 0;\n+        return 0;\n+      }\n+    }\n+  }\n+\n   LoadedModule *FindModuleForAddress(uptr address) {\n     if (modules_ == 0) {\n       modules_ = (LoadedModule*)(symbolizer_allocator.Allocate(\n@@ -316,8 +330,8 @@ uptr SymbolizeCode(uptr address, AddressInfo *frames, uptr max_frames) {\n   return symbolizer.SymbolizeCode(address, frames, max_frames);\n }\n \n-bool SymbolizeData(uptr address, AddressInfo *frame) {\n-  return symbolizer.SymbolizeData(address, frame);\n+bool SymbolizeData(uptr address, DataInfo *info) {\n+  return symbolizer.SymbolizeData(address, info);\n }\n \n bool InitializeExternalSymbolizer(const char *path_to_symbolizer) {"}, {"sha": "b88fa3f655aa217266632ff70b1f872a22862404", "filename": "libsanitizer/sanitizer_common/sanitizer_symbolizer.h", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2660d12d0a69539959dc1f77648f9f29f5e0edf8/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2660d12d0a69539959dc1f77648f9f29f5e0edf8/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer.h?ref=2660d12d0a69539959dc1f77648f9f29f5e0edf8", "patch": "@@ -51,12 +51,21 @@ struct AddressInfo {\n   }\n };\n \n+struct DataInfo {\n+  uptr address;\n+  char *module;\n+  uptr module_offset;\n+  char *name;\n+  uptr start;\n+  uptr size;\n+};\n+\n // Fills at most \"max_frames\" elements of \"frames\" with descriptions\n // for a given address (in all inlined functions). Returns the number\n // of descriptions actually filled.\n // This function should NOT be called from two threads simultaneously.\n uptr SymbolizeCode(uptr address, AddressInfo *frames, uptr max_frames);\n-bool SymbolizeData(uptr address, AddressInfo *frame);\n+bool SymbolizeData(uptr address, DataInfo *info);\n \n // Attempts to demangle the provided C++ mangled name.\n const char *Demangle(const char *Name);"}, {"sha": "242b4429bd76edfd5c6eb5d6c6d7f3c9a3757d8e", "filename": "libsanitizer/sanitizer_common/sanitizer_win.cc", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2660d12d0a69539959dc1f77648f9f29f5e0edf8/libsanitizer%2Fsanitizer_common%2Fsanitizer_win.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2660d12d0a69539959dc1f77648f9f29f5e0edf8/libsanitizer%2Fsanitizer_common%2Fsanitizer_win.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_win.cc?ref=2660d12d0a69539959dc1f77648f9f29f5e0edf8", "patch": "@@ -18,6 +18,8 @@\n \n #include \"sanitizer_common.h\"\n #include \"sanitizer_libc.h\"\n+#include \"sanitizer_placement_new.h\"\n+#include \"sanitizer_mutex.h\"\n \n namespace __sanitizer {\n \n@@ -224,6 +226,42 @@ int internal_sched_yield() {\n   return 0;\n }\n \n+// ---------------------- BlockingMutex ---------------- {{{1\n+enum LockState {\n+  LOCK_UNINITIALIZED = 0,\n+  LOCK_READY = -1,\n+};\n+\n+BlockingMutex::BlockingMutex(LinkerInitialized li) {\n+  // FIXME: see comments in BlockingMutex::Lock() for the details.\n+  CHECK(li == LINKER_INITIALIZED || owner_ == LOCK_UNINITIALIZED);\n+\n+  CHECK(sizeof(CRITICAL_SECTION) <= sizeof(opaque_storage_));\n+  InitializeCriticalSection((LPCRITICAL_SECTION)opaque_storage_);\n+  owner_ = LOCK_READY;\n+}\n+\n+void BlockingMutex::Lock() {\n+  if (owner_ == LOCK_UNINITIALIZED) {\n+    // FIXME: hm, global BlockingMutex objects are not initialized?!?\n+    // This might be a side effect of the clang+cl+link Frankenbuild...\n+    new(this) BlockingMutex((LinkerInitialized)(LINKER_INITIALIZED + 1));\n+\n+    // FIXME: If it turns out the linker doesn't invoke our\n+    // constructors, we should probably manually Lock/Unlock all the global\n+    // locks while we're starting in one thread to avoid double-init races.\n+  }\n+  EnterCriticalSection((LPCRITICAL_SECTION)opaque_storage_);\n+  CHECK(owner_ == LOCK_READY);\n+  owner_ = GetThreadSelf();\n+}\n+\n+void BlockingMutex::Unlock() {\n+  CHECK(owner_ == GetThreadSelf());\n+  owner_ = LOCK_READY;\n+  LeaveCriticalSection((LPCRITICAL_SECTION)opaque_storage_);\n+}\n+\n }  // namespace __sanitizer\n \n #endif  // _WIN32"}, {"sha": "f640c4f893eaec8cae4da6f1fd3eb07e52c6cf96", "filename": "libsanitizer/tsan/tsan_fd.cc", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2660d12d0a69539959dc1f77648f9f29f5e0edf8/libsanitizer%2Ftsan%2Ftsan_fd.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2660d12d0a69539959dc1f77648f9f29f5e0edf8/libsanitizer%2Ftsan%2Ftsan_fd.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_fd.cc?ref=2660d12d0a69539959dc1f77648f9f29f5e0edf8", "patch": "@@ -162,6 +162,12 @@ void FdRelease(ThreadState *thr, uptr pc, int fd) {\n   MemoryRead8Byte(thr, pc, (uptr)d);\n }\n \n+void FdAccess(ThreadState *thr, uptr pc, int fd) {\n+  DPrintf(\"#%d: FdAccess(%d)\\n\", thr->tid, fd);\n+  FdDesc *d = fddesc(thr, pc, fd);\n+  MemoryRead8Byte(thr, pc, (uptr)d);\n+}\n+\n void FdClose(ThreadState *thr, uptr pc, int fd) {\n   DPrintf(\"#%d: FdClose(%d)\\n\", thr->tid, fd);\n   FdDesc *d = fddesc(thr, pc, fd);"}, {"sha": "3306873223e743d2ffc4df7d83e104474f39329a", "filename": "libsanitizer/tsan/tsan_fd.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2660d12d0a69539959dc1f77648f9f29f5e0edf8/libsanitizer%2Ftsan%2Ftsan_fd.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2660d12d0a69539959dc1f77648f9f29f5e0edf8/libsanitizer%2Ftsan%2Ftsan_fd.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_fd.h?ref=2660d12d0a69539959dc1f77648f9f29f5e0edf8", "patch": "@@ -39,6 +39,7 @@ namespace __tsan {\n void FdInit();\n void FdAcquire(ThreadState *thr, uptr pc, int fd);\n void FdRelease(ThreadState *thr, uptr pc, int fd);\n+void FdAccess(ThreadState *thr, uptr pc, int fd);\n void FdClose(ThreadState *thr, uptr pc, int fd);\n void FdFileCreate(ThreadState *thr, uptr pc, int fd);\n void FdDup(ThreadState *thr, uptr pc, int oldfd, int newfd);"}, {"sha": "d8f66de23275c8858f6b9b4b2135055d4bd14c45", "filename": "libsanitizer/tsan/tsan_interceptors.cc", "status": "modified", "additions": 32, "deletions": 57, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2660d12d0a69539959dc1f77648f9f29f5e0edf8/libsanitizer%2Ftsan%2Ftsan_interceptors.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2660d12d0a69539959dc1f77648f9f29f5e0edf8/libsanitizer%2Ftsan%2Ftsan_interceptors.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_interceptors.cc?ref=2660d12d0a69539959dc1f77648f9f29f5e0edf8", "patch": "@@ -1239,33 +1239,6 @@ TSAN_INTERCEPTOR(int, pipe2, int *pipefd, int flags) {\n   return res;\n }\n \n-TSAN_INTERCEPTOR(long_t, read, int fd, void *buf, long_t sz) {\n-  SCOPED_TSAN_INTERCEPTOR(read, fd, buf, sz);\n-  int res = REAL(read)(fd, buf, sz);\n-  if (res >= 0 && fd >= 0) {\n-    FdAcquire(thr, pc, fd);\n-  }\n-  return res;\n-}\n-\n-TSAN_INTERCEPTOR(long_t, pread, int fd, void *buf, long_t sz, unsigned off) {\n-  SCOPED_TSAN_INTERCEPTOR(pread, fd, buf, sz, off);\n-  int res = REAL(pread)(fd, buf, sz, off);\n-  if (res >= 0 && fd >= 0) {\n-    FdAcquire(thr, pc, fd);\n-  }\n-  return res;\n-}\n-\n-TSAN_INTERCEPTOR(long_t, pread64, int fd, void *buf, long_t sz, u64 off) {\n-  SCOPED_TSAN_INTERCEPTOR(pread64, fd, buf, sz, off);\n-  int res = REAL(pread64)(fd, buf, sz, off);\n-  if (res >= 0 && fd >= 0) {\n-    FdAcquire(thr, pc, fd);\n-  }\n-  return res;\n-}\n-\n TSAN_INTERCEPTOR(long_t, readv, int fd, void *vec, int cnt) {\n   SCOPED_TSAN_INTERCEPTOR(readv, fd, vec, cnt);\n   int res = REAL(readv)(fd, vec, cnt);\n@@ -1284,30 +1257,6 @@ TSAN_INTERCEPTOR(long_t, preadv64, int fd, void *vec, int cnt, u64 off) {\n   return res;\n }\n \n-TSAN_INTERCEPTOR(long_t, write, int fd, void *buf, long_t sz) {\n-  SCOPED_TSAN_INTERCEPTOR(write, fd, buf, sz);\n-  if (fd >= 0)\n-    FdRelease(thr, pc, fd);\n-  int res = REAL(write)(fd, buf, sz);\n-  return res;\n-}\n-\n-TSAN_INTERCEPTOR(long_t, pwrite, int fd, void *buf, long_t sz, unsigned off) {\n-  SCOPED_TSAN_INTERCEPTOR(pwrite, fd, buf, sz, off);\n-  if (fd >= 0)\n-    FdRelease(thr, pc, fd);\n-  int res = REAL(pwrite)(fd, buf, sz, off);\n-  return res;\n-}\n-\n-TSAN_INTERCEPTOR(long_t, pwrite64, int fd, void *buf, long_t sz, u64 off) {\n-  SCOPED_TSAN_INTERCEPTOR(pwrite64, fd, buf, sz, off);\n-  if (fd >= 0)\n-    FdRelease(thr, pc, fd);\n-  int res = REAL(pwrite64)(fd, buf, sz, off);\n-  return res;\n-}\n-\n TSAN_INTERCEPTOR(long_t, writev, int fd, void *vec, int cnt) {\n   SCOPED_TSAN_INTERCEPTOR(writev, fd, vec, cnt);\n   if (fd >= 0)\n@@ -1449,6 +1398,8 @@ TSAN_INTERCEPTOR(int, epoll_ctl, int epfd, int op, int fd, void *ev) {\n     FdRelease(thr, pc, epfd);\n   }\n   int res = REAL(epoll_ctl)(epfd, op, fd, ev);\n+  if (fd >= 0)\n+    FdAccess(thr, pc, fd);\n   return res;\n }\n \n@@ -1641,6 +1592,33 @@ TSAN_INTERCEPTOR(int, fork, int fake) {\n   return pid;\n }\n \n+struct TsanInterceptorContext {\n+  ThreadState *thr;\n+  const uptr caller_pc;\n+  const uptr pc;\n+};\n+\n+#define COMMON_INTERCEPTOR_WRITE_RANGE(ctx, ptr, size) \\\n+    MemoryAccessRange(((TsanInterceptorContext*)ctx)->thr,  \\\n+                      ((TsanInterceptorContext*)ctx)->pc,   \\\n+                      (uptr)ptr, size, true)\n+#define COMMON_INTERCEPTOR_READ_RANGE(ctx, ptr, size)       \\\n+    MemoryAccessRange(((TsanInterceptorContext*)ctx)->thr,  \\\n+                      ((TsanInterceptorContext*)ctx)->pc,   \\\n+                      (uptr)ptr, size, false)\n+#define COMMON_INTERCEPTOR_ENTER(ctx, func, ...) \\\n+    SCOPED_TSAN_INTERCEPTOR(func, __VA_ARGS__) \\\n+    TsanInterceptorContext _ctx = {thr, caller_pc, pc}; \\\n+    ctx = (void*)&_ctx; \\\n+    (void)ctx;\n+#define COMMON_INTERCEPTOR_FD_ACQUIRE(ctx, fd) \\\n+    FdAcquire(((TsanInterceptorContext*)ctx)->thr, pc, fd)\n+#define COMMON_INTERCEPTOR_FD_RELEASE(ctx, fd) \\\n+    FdRelease(((TsanInterceptorContext*)ctx)->thr, pc, fd)\n+#define COMMON_INTERCEPTOR_SET_THREAD_NAME(ctx, name) \\\n+    ThreadSetName(((TsanInterceptorContext*)ctx)->thr, name)\n+#include \"sanitizer_common/sanitizer_common_interceptors.inc\"\n+\n namespace __tsan {\n \n void ProcessPendingSignals(ThreadState *thr) {\n@@ -1675,6 +1653,7 @@ void ProcessPendingSignals(ThreadState *thr) {\n               (uptr)sigactions[sig].sa_sigaction :\n               (uptr)sigactions[sig].sa_handler;\n           stack.Init(&pc, 1);\n+          Lock l(&ctx->thread_mtx);\n           ScopedReport rep(ReportTypeErrnoInSignal);\n           if (!IsFiredSuppression(ctx, rep, stack)) {\n             rep.AddStack(&stack);\n@@ -1703,6 +1682,8 @@ void InitializeInterceptors() {\n   REAL(memcpy) = internal_memcpy;\n   REAL(memcmp) = internal_memcmp;\n \n+  SANITIZER_COMMON_INTERCEPTORS_INIT;\n+\n   TSAN_INTERCEPT(longjmp);\n   TSAN_INTERCEPT(siglongjmp);\n \n@@ -1806,14 +1787,8 @@ void InitializeInterceptors() {\n   TSAN_INTERCEPT(pipe);\n   TSAN_INTERCEPT(pipe2);\n \n-  TSAN_INTERCEPT(read);\n-  TSAN_INTERCEPT(pread);\n-  TSAN_INTERCEPT(pread64);\n   TSAN_INTERCEPT(readv);\n   TSAN_INTERCEPT(preadv64);\n-  TSAN_INTERCEPT(write);\n-  TSAN_INTERCEPT(pwrite);\n-  TSAN_INTERCEPT(pwrite64);\n   TSAN_INTERCEPT(writev);\n   TSAN_INTERCEPT(pwritev64);\n   TSAN_INTERCEPT(send);"}, {"sha": "f4fafaf77f0d71a4daca768ddd35d5e65be8e0c6", "filename": "libsanitizer/tsan/tsan_mman.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2660d12d0a69539959dc1f77648f9f29f5e0edf8/libsanitizer%2Ftsan%2Ftsan_mman.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2660d12d0a69539959dc1f77648f9f29f5e0edf8/libsanitizer%2Ftsan%2Ftsan_mman.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_mman.cc?ref=2660d12d0a69539959dc1f77648f9f29f5e0edf8", "patch": "@@ -46,6 +46,7 @@ static void SignalUnsafeCall(ThreadState *thr, uptr pc) {\n   Context *ctx = CTX();\n   StackTrace stack;\n   stack.ObtainCurrent(thr, pc);\n+  Lock l(&ctx->thread_mtx);\n   ScopedReport rep(ReportTypeSignalUnsafe);\n   if (!IsFiredSuppression(ctx, rep, stack)) {\n     rep.AddStack(&stack);"}, {"sha": "f99fd2ea1053279dcccaa31b5d7114288467b226", "filename": "libsanitizer/tsan/tsan_report.cc", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2660d12d0a69539959dc1f77648f9f29f5e0edf8/libsanitizer%2Ftsan%2Ftsan_report.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2660d12d0a69539959dc1f77648f9f29f5e0edf8/libsanitizer%2Ftsan%2Ftsan_report.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_report.cc?ref=2660d12d0a69539959dc1f77648f9f29f5e0edf8", "patch": "@@ -102,16 +102,17 @@ static void PrintMop(const ReportMop *mop, bool first) {\n static void PrintLocation(const ReportLocation *loc) {\n   char thrbuf[kThreadBufSize];\n   if (loc->type == ReportLocationGlobal) {\n-    Printf(\"  Location is global '%s' of size %zu at %zx %s:%d (%s+%p)\\n\\n\",\n-               loc->name, loc->size, loc->addr, loc->file, loc->line,\n-               loc->module, loc->offset);\n+    Printf(\"  Location is global '%s' of size %zu at %zx (%s+%p)\\n\\n\",\n+               loc->name, loc->size, loc->addr, loc->module, loc->offset);\n   } else if (loc->type == ReportLocationHeap) {\n     char thrbuf[kThreadBufSize];\n     Printf(\"  Location is heap block of size %zu at %p allocated by %s:\\n\",\n         loc->size, loc->addr, thread_name(thrbuf, loc->tid));\n     PrintStack(loc->stack);\n   } else if (loc->type == ReportLocationStack) {\n-    Printf(\"  Location is stack of %s\\n\\n\", thread_name(thrbuf, loc->tid));\n+    Printf(\"  Location is stack of %s.\\n\\n\", thread_name(thrbuf, loc->tid));\n+  } else if (loc->type == ReportLocationTLS) {\n+    Printf(\"  Location is TLS of %s.\\n\\n\", thread_name(thrbuf, loc->tid));\n   } else if (loc->type == ReportLocationFD) {\n     Printf(\"  Location is file descriptor %d created by %s at:\\n\",\n         loc->fd, thread_name(thrbuf, loc->tid));"}, {"sha": "42f52af9e374c6d3e4c214f42e6e150e9e2b5281", "filename": "libsanitizer/tsan/tsan_report.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2660d12d0a69539959dc1f77648f9f29f5e0edf8/libsanitizer%2Ftsan%2Ftsan_report.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2660d12d0a69539959dc1f77648f9f29f5e0edf8/libsanitizer%2Ftsan%2Ftsan_report.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_report.h?ref=2660d12d0a69539959dc1f77648f9f29f5e0edf8", "patch": "@@ -56,6 +56,7 @@ enum ReportLocationType {\n   ReportLocationGlobal,\n   ReportLocationHeap,\n   ReportLocationStack,\n+  ReportLocationTLS,\n   ReportLocationFD\n };\n "}, {"sha": "db97e1d9853f42cd4f5f542306f28129d6585e09", "filename": "libsanitizer/tsan/tsan_rtl_mutex.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2660d12d0a69539959dc1f77648f9f29f5e0edf8/libsanitizer%2Ftsan%2Ftsan_rtl_mutex.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2660d12d0a69539959dc1f77648f9f29f5e0edf8/libsanitizer%2Ftsan%2Ftsan_rtl_mutex.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_rtl_mutex.cc?ref=2660d12d0a69539959dc1f77648f9f29f5e0edf8", "patch": "@@ -53,6 +53,7 @@ void MutexDestroy(ThreadState *thr, uptr pc, uptr addr) {\n       && s->owner_tid != SyncVar::kInvalidTid\n       && !s->is_broken) {\n     s->is_broken = true;\n+    Lock l(&ctx->thread_mtx);\n     ScopedReport rep(ReportTypeMutexDestroyLocked);\n     rep.AddMutex(s);\n     StackTrace trace;"}, {"sha": "c4256da412a0e8778741a292202ad2cf893ac4cd", "filename": "libsanitizer/tsan/tsan_rtl_report.cc", "status": "modified", "additions": 36, "deletions": 17, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2660d12d0a69539959dc1f77648f9f29f5e0edf8/libsanitizer%2Ftsan%2Ftsan_rtl_report.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2660d12d0a69539959dc1f77648f9f29f5e0edf8/libsanitizer%2Ftsan%2Ftsan_rtl_report.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_rtl_report.cc?ref=2660d12d0a69539959dc1f77648f9f29f5e0edf8", "patch": "@@ -119,6 +119,7 @@ static ReportStack *SymbolizeStack(const StackTrace& trace) {\n \n ScopedReport::ScopedReport(ReportType typ) {\n   ctx_ = CTX();\n+  ctx_->thread_mtx.CheckLocked();\n   void *mem = internal_alloc(MBlockReport, sizeof(ReportDesc));\n   rep_ = new(mem) ReportDesc;\n   rep_->typ = typ;\n@@ -185,15 +186,37 @@ void ScopedReport::AddThread(const ThreadContext *tctx) {\n \n #ifndef TSAN_GO\n static ThreadContext *FindThread(int unique_id) {\n-  CTX()->thread_mtx.CheckLocked();\n+  Context *ctx = CTX();\n+  ctx->thread_mtx.CheckLocked();\n   for (unsigned i = 0; i < kMaxTid; i++) {\n-    ThreadContext *tctx = CTX()->threads[i];\n+    ThreadContext *tctx = ctx->threads[i];\n     if (tctx && tctx->unique_id == unique_id) {\n       return tctx;\n     }\n   }\n   return 0;\n }\n+\n+ThreadContext *IsThreadStackOrTls(uptr addr, bool *is_stack) {\n+  Context *ctx = CTX();\n+  ctx->thread_mtx.CheckLocked();\n+  for (unsigned i = 0; i < kMaxTid; i++) {\n+    ThreadContext *tctx = ctx->threads[i];\n+    if (tctx == 0 || tctx->status != ThreadStatusRunning)\n+      continue;\n+    ThreadState *thr = tctx->thr;\n+    CHECK(thr);\n+    if (addr >= thr->stk_addr && addr < thr->stk_addr + thr->stk_size) {\n+      *is_stack = true;\n+      return tctx;\n+    }\n+    if (addr >= thr->tls_addr && addr < thr->tls_addr + thr->tls_size) {\n+      *is_stack = false;\n+      return tctx;\n+    }\n+  }\n+  return 0;\n+}\n #endif\n \n void ScopedReport::AddMutex(const SyncVar *s) {\n@@ -274,25 +297,21 @@ void ScopedReport::AddLocation(uptr addr, uptr size) {\n       AddThread(tctx);\n     return;\n   }\n-#endif\n-  ReportStack *symb = SymbolizeData(addr);\n-  if (symb) {\n+  bool is_stack = false;\n+  if (ThreadContext *tctx = IsThreadStackOrTls(addr, &is_stack)) {\n     void *mem = internal_alloc(MBlockReportLoc, sizeof(ReportLocation));\n     ReportLocation *loc = new(mem) ReportLocation();\n     rep_->locs.PushBack(loc);\n-    loc->type = ReportLocationGlobal;\n-    loc->addr = addr;\n-    loc->size = size;\n-    loc->module = symb->module ? internal_strdup(symb->module) : 0;\n-    loc->offset = symb->offset;\n-    loc->tid = 0;\n-    loc->name = symb->func ? internal_strdup(symb->func) : 0;\n-    loc->file = symb->file ? internal_strdup(symb->file) : 0;\n-    loc->line = symb->line;\n-    loc->stack = 0;\n-    internal_free(symb);\n+    loc->type = is_stack ? ReportLocationStack : ReportLocationTLS;\n+    loc->tid = tctx->tid;\n+    AddThread(tctx);\n+  }\n+  ReportLocation *loc = SymbolizeData(addr);\n+  if (loc) {\n+    rep_->locs.PushBack(loc);\n     return;\n   }\n+#endif\n }\n \n #ifndef TSAN_GO\n@@ -386,7 +405,7 @@ static bool HandleRacyStacks(ThreadState *thr, const StackTrace (&traces)[2],\n     uptr addr_min, uptr addr_max) {\n   Context *ctx = CTX();\n   bool equal_stack = false;\n-  RacyStacks hash = {};\n+  RacyStacks hash;\n   if (flags()->suppress_equal_stacks) {\n     hash.hash[0] = md5_hash(traces[0].Begin(), traces[0].Size() * sizeof(uptr));\n     hash.hash[1] = md5_hash(traces[1].Begin(), traces[1].Size() * sizeof(uptr));"}, {"sha": "105d0bc23758268b8a163f522a763ff369e10484", "filename": "libsanitizer/tsan/tsan_stat.cc", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2660d12d0a69539959dc1f77648f9f29f5e0edf8/libsanitizer%2Ftsan%2Ftsan_stat.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2660d12d0a69539959dc1f77648f9f29f5e0edf8/libsanitizer%2Ftsan%2Ftsan_stat.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_stat.cc?ref=2660d12d0a69539959dc1f77648f9f29f5e0edf8", "patch": "@@ -202,6 +202,7 @@ void StatOutput(u64 *stat) {\n   name[StatInt_pipe]                     = \"  pipe                            \";\n   name[StatInt_pipe2]                    = \"  pipe2                           \";\n   name[StatInt_read]                     = \"  read                            \";\n+  name[StatInt_prctl]                    = \"  prctl                           \";\n   name[StatInt_pread]                    = \"  pread                           \";\n   name[StatInt_pread64]                  = \"  pread64                         \";\n   name[StatInt_readv]                    = \"  readv                           \";\n@@ -233,6 +234,12 @@ void StatOutput(u64 *stat) {\n   name[StatInt_nanosleep]                = \"  nanosleep                       \";\n   name[StatInt_gettimeofday]             = \"  gettimeofday                    \";\n   name[StatInt_fork]                     = \"  fork                            \";\n+  name[StatInt_vscanf]                   = \"  vscanf                          \";\n+  name[StatInt_vsscanf]                  = \"  vsscanf                         \";\n+  name[StatInt_vfscanf]                  = \"  vfscanf                         \";\n+  name[StatInt_scanf]                    = \"  scanf                           \";\n+  name[StatInt_sscanf]                   = \"  sscanf                          \";\n+  name[StatInt_fscanf]                   = \"  fscanf                          \";\n \n   name[StatAnnotation]                   = \"Dynamic annotations               \";\n   name[StatAnnotateHappensBefore]        = \"  HappensBefore                   \";"}, {"sha": "f40d3a2ac5e9c4e98d38d666711e68aaac1d9144", "filename": "libsanitizer/tsan/tsan_stat.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2660d12d0a69539959dc1f77648f9f29f5e0edf8/libsanitizer%2Ftsan%2Ftsan_stat.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2660d12d0a69539959dc1f77648f9f29f5e0edf8/libsanitizer%2Ftsan%2Ftsan_stat.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_stat.h?ref=2660d12d0a69539959dc1f77648f9f29f5e0edf8", "patch": "@@ -197,6 +197,7 @@ enum StatType {\n   StatInt_pipe,\n   StatInt_pipe2,\n   StatInt_read,\n+  StatInt_prctl,\n   StatInt_pread,\n   StatInt_pread64,\n   StatInt_readv,\n@@ -232,6 +233,12 @@ enum StatType {\n   StatInt_nanosleep,\n   StatInt_gettimeofday,\n   StatInt_fork,\n+  StatInt_vscanf,\n+  StatInt_vsscanf,\n+  StatInt_vfscanf,\n+  StatInt_scanf,\n+  StatInt_sscanf,\n+  StatInt_fscanf,\n \n   // Dynamic annotations.\n   StatAnnotation,"}, {"sha": "015b98717f1f8e025826b4feb8ab2cb38ecde3f1", "filename": "libsanitizer/tsan/tsan_symbolize.cc", "status": "modified", "additions": 31, "deletions": 19, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2660d12d0a69539959dc1f77648f9f29f5e0edf8/libsanitizer%2Ftsan%2Ftsan_symbolize.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2660d12d0a69539959dc1f77648f9f29f5e0edf8/libsanitizer%2Ftsan%2Ftsan_symbolize.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_symbolize.cc?ref=2660d12d0a69539959dc1f77648f9f29f5e0edf8", "patch": "@@ -27,21 +27,24 @@ ReportStack *NewReportStackEntry(uptr addr) {\n   return ent;\n }\n \n+// Strip module path to make output shorter.\n+static char *StripModuleName(const char *module) {\n+  if (module == 0)\n+    return 0;\n+  const char *short_module_name = internal_strrchr(module, '/');\n+  if (short_module_name)\n+    short_module_name += 1;\n+  else\n+    short_module_name = module;\n+  return internal_strdup(short_module_name);\n+}\n+\n static ReportStack *NewReportStackEntry(const AddressInfo &info) {\n   ReportStack *ent = NewReportStackEntry(info.address);\n-  if (info.module) {\n-    // Strip module path to make output shorter.\n-    const char *short_module_name = internal_strrchr(info.module, '/');\n-    if (short_module_name)\n-      short_module_name += 1;\n-    else\n-      short_module_name = info.module;\n-    ent->module = internal_strdup(short_module_name);\n-  }\n+  ent->module = StripModuleName(info.module);\n   ent->offset = info.module_offset;\n-  if (info.function) {\n+  if (info.function)\n     ent->func = internal_strdup(info.function);\n-  }\n   if (info.file)\n     ent->file = internal_strdup(info.file);\n   ent->line = info.line;\n@@ -76,14 +79,23 @@ ReportStack *SymbolizeCode(uptr addr) {\n   return SymbolizeCodeAddr2Line(addr);\n }\n \n-ReportStack *SymbolizeData(uptr addr) {\n-  if (flags()->external_symbolizer_path[0]) {\n-    AddressInfo frame;\n-    if (!__sanitizer::SymbolizeData(addr, &frame))\n-      return 0;\n-    return NewReportStackEntry(frame);\n-  }\n-  return SymbolizeDataAddr2Line(addr);\n+ReportLocation *SymbolizeData(uptr addr) {\n+  if (flags()->external_symbolizer_path[0] == 0)\n+    return 0;\n+  DataInfo info;\n+  if (!__sanitizer::SymbolizeData(addr, &info))\n+    return 0;\n+  ReportLocation *ent = (ReportLocation*)internal_alloc(MBlockReportStack,\n+                                                        sizeof(ReportLocation));\n+  internal_memset(ent, 0, sizeof(*ent));\n+  ent->type = ReportLocationGlobal;\n+  ent->module = StripModuleName(info.module);\n+  ent->offset = info.module_offset;\n+  if (info.name)\n+    ent->name = internal_strdup(info.name);\n+  ent->addr = info.start;\n+  ent->size = info.size;\n+  return ent;\n }\n \n }  // namespace __tsan"}, {"sha": "5275936a29377dac059292e48549657e196ad919", "filename": "libsanitizer/tsan/tsan_symbolize.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2660d12d0a69539959dc1f77648f9f29f5e0edf8/libsanitizer%2Ftsan%2Ftsan_symbolize.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2660d12d0a69539959dc1f77648f9f29f5e0edf8/libsanitizer%2Ftsan%2Ftsan_symbolize.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_symbolize.h?ref=2660d12d0a69539959dc1f77648f9f29f5e0edf8", "patch": "@@ -17,10 +17,9 @@\n namespace __tsan {\n \n ReportStack *SymbolizeCode(uptr addr);\n-ReportStack *SymbolizeData(uptr addr);\n+ReportLocation *SymbolizeData(uptr addr);\n \n ReportStack *SymbolizeCodeAddr2Line(uptr addr);\n-ReportStack *SymbolizeDataAddr2Line(uptr addr);\n \n ReportStack *NewReportStackEntry(uptr addr);\n "}]}