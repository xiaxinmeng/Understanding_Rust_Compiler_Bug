{"sha": "e543e219eb1865d4230278c3db3d2bedd60b1de0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTU0M2UyMTllYjE4NjVkNDIzMDI3OGMzZGIzZDJiZWRkNjBiMWRlMA==", "commit": {"author": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2004-08-12T07:49:00Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2004-08-12T07:49:00Z"}, "message": "genpreds.c: Add capability to generate predicate bodies as well as function prototypes.\n\n\t* genpreds.c: Add capability to generate predicate bodies as\n\twell as function prototypes.  Write function prototypes for\n\tthe generic predicates too.\n\t(process_define_predicate, write_tm_preds_h, write_insn_preds_c)\n\t(write_predicate_subfunction, mark_mode_tests, add_mode_tests)\n\t(write_match_code, write_predicate_expr, write_one_predicate_function)\n\t(parse_option): New functions.\n\t(output_predicate_decls): Delete.\n\t(main): Read the machine description, process DEFINE_PREDICATE or\n\tDEFINE_SPECIAL_PREDICATE patterns, write tm-preds.h or insn-preds.c\n\tas appropriate.\n\n\t* genrecog.c (struct decision_test): Replace index with\n\tstruct pred_data pointer.\n\t(next_index): Remove, unused.\n\t(pred_table, preds, special_mode_pred_table): Delete.\n\t(compute_predicate_codes, process_define_predicate): New functions.\n\t(validate_pattern, add_to_sequence, write_switch): Update for\n\tnew data structures.\n\t(main): Handle DEFINE_PREDICATE and DEFINE_SPECIAL_PREDICATE.\n\tCheck both error_count and have_error.\n\n\t* gensupport.c (in_fname, first_predicate): New globals.\n\t(define_pred_queue, define_pred_tail): New RTL-pattern queue.\n\t(predicate_table, last_predicate, old_pred_table)\n\t(old_special_pred_table): New statics.\n\t(hash_struct_pred_data, eq_struct_pred_data, lookup_predicate)\n\t(add_predicate, init_predicate_table): New functions.\n\t(process_rtx): Handle DEFINE_PREDICATE and DEFINE_SPECIAL_PREDICATE.\n\t(init_md_reader_args_cb): Use the global in_fname.  No need to zero\n\tit or max_include_len.  Call init_predicate_table.\n\t(read_rtx): Run the predicate queue after the attribute queue\n\tbut before all the others.\n\t* gensupport.h (in_fname, struct pred_data, first_predicate)\n\t(lookup_predicate, add_predicate, FOR_ALL_PREDICATES): Declare.\n\t* rtl.def (MATCH_CODE, MATCH_TEST, DEFINE_PREDICATE)\n\t(DEFINE_SPECIAL_PREDICATE): New RTL codes.\n\t* dummy-conditions.c: Don't include bconfig.h, system.h,\n\tcoretypes.h, tm.h, or system.h.  Do include stddef.h.\n\tDuplicate declaration of struct c_test from gensupport.h.\n\n\t* Makefile.in (OBJS-common): Add insn-preds.o.\n\t(STAGESTUFF, .PRECIOUS): Add insn-preds.c.\n\t(insn-preds.c, insn-preds.o): New rules.\n\t(s-preds): Also generate insn-preds.c.\n\t(dummy-conditions.o, genpreds$(build_exeext), genpreds.o):\n\tUpdate dependencies.\n\t(print-rtl.o, print-rtl1.o): Correct dependencies.\n\n\t* recog.h: Delete prototypes of predicate functions.\n\n\t* doc/md.texi (Predicates): New section with complete\n\tdocumentation of operand/operator predicates.  Remove some\n\tincomplete documentation of predicates from other places.\n\t* doc/tm.texi (Misc): Move SPECIAL_MODE_PREDICATES next to\n\tPREDICATE_CODES; indicate that both are deprecated in favor\n\tof define_predicate/define_special_predicate.\n\n\t* config/ia64/ia64.c: All predicate function definitions moved\n\tto ia64.md, except\n\t(small_addr_symbolic_operand, tls_symbolic_operand): Delete.\n\t(ia64_expand_load_address, ia64_expand_move):\n\tCheck SYMBOL_REF_TLS_MODEL directly, don't use tls_symbolic_operand.\n\n\t* config/ia64/ia64.md: All predicates now defined here.\n\t(symbolic_operand): Is now a special predicate.\n\n\t* config/ia64/ia64.h: Declare ia64_section_threshold.\n\t(PREDICATE_CODES): Delete.\n\nFrom-SVN: r85855", "tree": {"sha": "35550b19b3978c830f6043f43687018fe8198d2d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/35550b19b3978c830f6043f43687018fe8198d2d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e543e219eb1865d4230278c3db3d2bedd60b1de0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e543e219eb1865d4230278c3db3d2bedd60b1de0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e543e219eb1865d4230278c3db3d2bedd60b1de0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e543e219eb1865d4230278c3db3d2bedd60b1de0/comments", "author": null, "committer": null, "parents": [{"sha": "b4d49f49bf21837bef59aa30788e2e9bf2ce2e3b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b4d49f49bf21837bef59aa30788e2e9bf2ce2e3b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b4d49f49bf21837bef59aa30788e2e9bf2ce2e3b"}], "stats": {"total": 2658, "additions": 1777, "deletions": 881}, "files": [{"sha": "7de4f0b0fb9edfb8164e3664b1b2f772949a6c6f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 78, "deletions": 6, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e543e219eb1865d4230278c3db3d2bedd60b1de0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e543e219eb1865d4230278c3db3d2bedd60b1de0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e543e219eb1865d4230278c3db3d2bedd60b1de0", "patch": "@@ -1,3 +1,75 @@\n+2004-08-12  Zack Weinberg  <zack@codesourcery.com>\n+\n+\t* genpreds.c: Add capability to generate predicate bodies as\n+\twell as function prototypes.  Write function prototypes for\n+\tthe generic predicates too.\n+\t(process_define_predicate, write_tm_preds_h, write_insn_preds_c)\n+\t(write_predicate_subfunction, mark_mode_tests, add_mode_tests)\n+\t(write_match_code, write_predicate_expr, write_one_predicate_function)\n+\t(parse_option): New functions.\n+\t(output_predicate_decls): Delete.\n+\t(main): Read the machine description, process DEFINE_PREDICATE or\n+\tDEFINE_SPECIAL_PREDICATE patterns, write tm-preds.h or insn-preds.c\n+\tas appropriate.\n+\n+\t* genrecog.c (struct decision_test): Replace index with\n+\tstruct pred_data pointer.\n+\t(next_index): Remove, unused.\n+\t(pred_table, preds, special_mode_pred_table): Delete.\n+\t(compute_predicate_codes, process_define_predicate): New functions.\n+\t(validate_pattern, add_to_sequence, write_switch): Update for\n+\tnew data structures.\n+\t(main): Handle DEFINE_PREDICATE and DEFINE_SPECIAL_PREDICATE.\n+\tCheck both error_count and have_error.\n+\n+\t* gensupport.c (in_fname, first_predicate): New globals.\n+\t(define_pred_queue, define_pred_tail): New RTL-pattern queue.\n+\t(predicate_table, last_predicate, old_pred_table)\n+\t(old_special_pred_table): New statics.\n+\t(hash_struct_pred_data, eq_struct_pred_data, lookup_predicate)\n+\t(add_predicate, init_predicate_table): New functions.\n+\t(process_rtx): Handle DEFINE_PREDICATE and DEFINE_SPECIAL_PREDICATE.\n+\t(init_md_reader_args_cb): Use the global in_fname.  No need to zero\n+\tit or max_include_len.  Call init_predicate_table.\n+\t(read_rtx): Run the predicate queue after the attribute queue\n+\tbut before all the others.\n+\t* gensupport.h (in_fname, struct pred_data, first_predicate)\n+\t(lookup_predicate, add_predicate, FOR_ALL_PREDICATES): Declare.\n+\t* rtl.def (MATCH_CODE, MATCH_TEST, DEFINE_PREDICATE)\n+\t(DEFINE_SPECIAL_PREDICATE): New RTL codes.\n+\t* dummy-conditions.c: Don't include bconfig.h, system.h,\n+\tcoretypes.h, tm.h, or system.h.  Do include stddef.h.\n+\tDuplicate declaration of struct c_test from gensupport.h.\n+\n+\t* Makefile.in (OBJS-common): Add insn-preds.o.\n+\t(STAGESTUFF, .PRECIOUS): Add insn-preds.c.\n+\t(insn-preds.c, insn-preds.o): New rules.\n+\t(s-preds): Also generate insn-preds.c.\n+\t(dummy-conditions.o, genpreds$(build_exeext), genpreds.o):\n+\tUpdate dependencies.\n+\t(print-rtl.o, print-rtl1.o): Correct dependencies.\n+\n+\t* recog.h: Delete prototypes of predicate functions.\n+\n+\t* doc/md.texi (Predicates): New section with complete\n+\tdocumentation of operand/operator predicates.  Remove some\n+\tincomplete documentation of predicates from other places.\n+\t* doc/tm.texi (Misc): Move SPECIAL_MODE_PREDICATES next to\n+\tPREDICATE_CODES; indicate that both are deprecated in favor\n+\tof define_predicate/define_special_predicate.\n+\n+\t* config/ia64/ia64.c: All predicate function definitions moved\n+\tto ia64.md, except\n+\t(small_addr_symbolic_operand, tls_symbolic_operand): Delete.\n+\t(ia64_expand_load_address, ia64_expand_move):\n+\tCheck SYMBOL_REF_TLS_MODEL directly, don't use tls_symbolic_operand.\n+\n+\t* config/ia64/ia64.md: All predicates now defined here.\n+\t(symbolic_operand): Is now a special predicate.\n+\n+\t* config/ia64/ia64.h: Declare ia64_section_threshold.\n+\t(PREDICATE_CODES): Delete.\n+\n 2004-08-12  Richard Henderson  <rth@redhat.com>\n \n \t* c-common.h (STATEMENT_LIST_HAS_LABEL): New.\n@@ -8,7 +80,7 @@\n 2004-08-12  Richard Henderson  <rth@redhat.com>\n \n \t* stor-layout.c (round_up, round_down): Move ...\n-\t* fold-const.c (round_up, round_down): ... here.  Use \n+\t* fold-const.c (round_up, round_down): ... here.  Use\n \tmultiple_of_p to avoid any arithmetic at all.\n \n 2004-08-12  Richard Henderson  <rth@redhat.com>\n@@ -56,7 +128,7 @@\n \t(LINK_SPEC): Same.\n \t* doc/invoke.texi (Darwin Options): Document -dead_strip and\n \t-no_dead_strip_inits_and_terms.\n-\t\n+\n 2004-08-11  Paul Brook  <paul@codesourcery.com>\n \n \t* config/arm/arm-protos.h (arm_finalize_pic) Rename ...\n@@ -102,15 +174,15 @@\n \tget_vuse_ops,get_v_must_def_ops): Add operand structure reference.\n \t(get_v_may_def_result_ptr, get_v_may_def_op_ptr): New access struct.\n \t(start_ssa_stmt_operands): Delete.\n-\t* tree-flow.h (struct stmt_ann_d): Replace operand vectors with new \n+\t* tree-flow.h (struct stmt_ann_d): Replace operand vectors with new\n \tstruct stmt_operands_d.\n \t(build_ssa_operands): New extern entry point.\n-\t* tree-ssa-dom.c (record_equivalences_from_stmt): Remove operand \n+\t* tree-ssa-dom.c (record_equivalences_from_stmt): Remove operand\n \tbuilding code, replace with create_ssa_artficial_load_stmt().\n \t* tree-ssa-operands.c (struct voperands_d): Delete.\n \t(allocate_v_may_def_optype): Allocate v_may_def_operand_type_t vector.\n \t(allocate_v_must_def_optype): Use sizeof (tree), not sizeof (tree *).\n-\t(free_uses, free_defs, free_vuses, free_v_may_defs, \n+\t(free_uses, free_defs, free_vuses, free_v_may_defs,\n \tfree_v_must_defs): Remove dealloc parameter.\n \t(remove_vuses, remove_v_may_def, remove_v_must_defs): Delete.\n \t(finalize_ssa_defs, finalize_ssa_uses, finalize_ssa_v_may_defs,\n@@ -125,7 +197,7 @@\n \tduplicates and simple accumulation.\n \t(free_ssa_operands): Free vectors in a stmt_operand structure.\n \t(build_ssa_operands): New. Create a new stmt_operand structure from\n-\ta stmt and an old set of stmt_operands.  \n+\ta stmt and an old set of stmt_operands.\n \t(get_stmt_operands): Simplify and call build_ssa_operands.\n \t(get_expr_operands, get_asm_expr_operands, get_indirect_ref_operands,\n \tget_call_expr_operands, add_stmt_operand, add_call_clobber_ops,"}, {"sha": "e58a3a2141b2c0c253fb96c8915f9f1f3b595a4b", "filename": "gcc/Makefile.in", "status": "modified", "additions": 23, "deletions": 14, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e543e219eb1865d4230278c3db3d2bedd60b1de0/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e543e219eb1865d4230278c3db3d2bedd60b1de0/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=e543e219eb1865d4230278c3db3d2bedd60b1de0", "patch": "@@ -910,8 +910,8 @@ OBJS-common = \\\n  genrtl.o ggc-common.o global.o graph.o gtype-desc.o\t\t\t   \\\n  haifa-sched.o hooks.o ifcvt.o insn-attrtab.o insn-emit.o insn-modes.o\t   \\\n  insn-extract.o insn-opinit.o insn-output.o insn-peep.o insn-recog.o\t   \\\n- integrate.o intl.o jump.o  langhooks.o lcm.o lists.o local-alloc.o  \t   \\\n- loop.o modulo-sched.o\t\t\t\t\t\t\t   \\\n+ insn-preds.o integrate.o intl.o jump.o  langhooks.o lcm.o lists.o \t   \\\n+ local-alloc.o loop.o modulo-sched.o\t\t\t\t\t   \\\n  optabs.o options.o opts.o params.o postreload.o predict.o\t\t   \\\n  print-rtl.o print-tree.o value-prof.o var-tracking.o\t\t\t   \\\n  profile.o ra.o ra-build.o ra-colorize.o ra-debug.o ra-rewrite.o\t   \\\n@@ -937,7 +937,8 @@ BACKEND = main.o @TREEBROWSER@ libbackend.a $(CPPLIB)\n # Files to be copied away after each stage in building.\n STAGESTUFF = *$(objext) insn-flags.h insn-config.h insn-codes.h \\\n  insn-output.c insn-recog.c insn-emit.c insn-extract.c insn-peep.c \\\n- insn-attr.h insn-attrtab.c insn-opinit.c insn-constants.h tm-preds.h \\\n+ insn-attr.h insn-attrtab.c insn-opinit.c insn-preds.c insn-constants.h \\\n+ tm-preds.h \\\n  tree-check.h insn-conditions.c min-insn-modes.c insn-modes.c insn-modes.h \\\n  s-flags s-config s-codes s-mlib s-genrtl s-modes s-gtype gtyp-gen.h \\\n  s-gtyp-gen s-output s-recog s-emit s-extract s-peep s-check s-conditions \\\n@@ -1796,7 +1797,7 @@ rtl.o : rtl.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(GTM_H) $(RTL_H) real.h \\\n \t$(CC) -c $(ALL_CFLAGS) -DGENERATOR_FILE $(ALL_CPPFLAGS) $(INCLUDES) $< $(OUTPUT_OPTION)\n \n print-rtl.o : print-rtl.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n-    $(RTL_H) $(TREE_H) hard-reg-set.h $(BASIC_BLOCK_H) real.h\n+    $(RTL_H) $(TREE_H) hard-reg-set.h $(BASIC_BLOCK_H) real.h $(FLAGS_H)\n rtlanal.o : rtlanal.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) toplev.h \\\n    $(RTL_H) hard-reg-set.h $(TM_P_H) insn-config.h $(RECOG_H) real.h $(FLAGS_H) \\\n    $(BASIC_BLOCK_H) $(REGS_H) output.h target.h function.h\n@@ -2166,7 +2167,7 @@ libbackend.o : $(OBJS-common:.o=.c) $(out_file) \\\n \n .PRECIOUS: insn-config.h insn-flags.h insn-codes.h insn-constants.h \\\n   insn-emit.c insn-recog.c insn-extract.c insn-output.c insn-peep.c \\\n-  insn-attr.h insn-attrtab.c\n+  insn-attr.h insn-attrtab.c insn-preds.c\n \n # The following pair of rules has this effect:\n # genconfig is run only if the md has changed since genconfig was last run;\n@@ -2205,8 +2206,7 @@ insn-conditions.o : insn-conditions.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n   insn-constants.h\n \t$(CC_FOR_BUILD) -c $(BUILD_CFLAGS) $(BUILD_CPPFLAGS) $(INCLUDES) insn-conditions.c\n \n-dummy-conditions.o : dummy-conditions.c $(BCONFIG_H) $(SYSTEM_H) \\\n-  coretypes.h $(GTM_H) gensupport.h\n+dummy-conditions.o : dummy-conditions.c\n \n insn-flags.h: s-flags ; @true\n s-flags : $(md_file) genflags$(build_exeext)\n@@ -2340,13 +2340,19 @@ s-modes: genmodes$(build_exeext)\n \t$(SHELL) $(srcdir)/../move-if-change tmp-modes.c insn-modes.c\n \t$(STAMP) s-modes\n \n-tm-preds.h: s-preds; @true\n+insn-preds.c tm-preds.h: s-preds; @true\n \n-s-preds: genpreds$(build_exeext)\n-\t$(RUN_GEN) ./genpreds$(build_exeext) > tmp-preds.h\n+s-preds: $(md_file) genpreds$(build_exeext)\n+\t$(RUN_GEN) ./genpreds$(build_exeext) -h $(md_file) > tmp-preds.h\n \t$(SHELL) $(srcdir)/../move-if-change tmp-preds.h tm-preds.h\n+\t$(RUN_GEN) ./genpreds$(build_exeext) $(md_file) > tmp-preds.c\n+\t$(SHELL) $(srcdir)/../move-if-change tmp-preds.c insn-preds.c\n \t$(STAMP) s-preds\n \n+insn-preds.o : insn-preds.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n+  $(RTL_H) insn-config.h $(RECOG_H) real.h output.h $(FLAGS_H)  function.h \\\n+  hard-reg-set.h $(RESOURCE_H) $(TM_P_H) toplev.h reload.h\n+\n GTFILES = $(srcdir)/input.h $(srcdir)/coretypes.h \\\n   $(CPP_ID_DATA_H) $(host_xm_file_list) \\\n   $(tm_file_list) $(HASHTAB_H) $(SPLAY_TREE_H) $(srcdir)/bitmap.h \\\n@@ -2539,11 +2545,14 @@ genmodes$(build_exeext) : genmodes.o $(BUILD_ERRORS) $(BUILD_LIBDEPS)\n genmodes.o : genmodes.c $(BCONFIG_H) $(SYSTEM_H) errors.h $(HASHTAB_H) \\\n \t     machmode.def $(extra_modes_file)\n \n-genpreds$(build_exeext) : genpreds.o $(BUILD_LIBDEPS)\n+genpreds$(build_exeext) : genpreds.o $(BUILD_RTL) $(BUILD_EARLY_SUPPORT) \\\n+  $(BUILD_PRINT) $(BUILD_ERRORS) $(BUILD_LIBDEPS)\n \t$(CC_FOR_BUILD) $(BUILD_CFLAGS) $(BUILD_LDFLAGS) -o $@ \\\n-\t genpreds.o $(BUILD_LIBS)\n+\t genpreds.o $(BUILD_RTL) $(BUILD_EARLY_SUPPORT) $(BUILD_PRINT) \\\n+\t $(BUILD_ERRORS) $(BUILD_LIBS)\n \n-genpreds.o : genpreds.c $(RTL_BASE_H) $(BCONFIG_H) $(SYSTEM_H) coretypes.h $(GTM_H)\n+genpreds.o : genpreds.c $(RTL_BASE_H) $(BCONFIG_H) $(SYSTEM_H) coretypes.h \\\n+\t$(GTM_H) errors.h gensupport.h $(OBSTACK_H)\n \n gengtype$(build_exeext) : gengtype.o gengtype-lex.o gengtype-yacc.o \\\n   $(BUILD_LIBDEPS)\n@@ -2593,7 +2602,7 @@ $(BUILD_PREFIX_1)rtl.o: $(srcdir)/rtl.c $(BCONFIG_H) coretypes.h $(GTM_H) $(SYST\n \t$(CC_FOR_BUILD) -c $(BUILD_CFLAGS) $(BUILD_CPPFLAGS) $(INCLUDES) $(BUILD_PREFIX)rtl.c $(OUTPUT_OPTION)\n \n print-rtl1.o: $(srcdir)/print-rtl.c $(BCONFIG_H) $(SYSTEM_H) coretypes.h \\\n-  $(GTM_H) $(RTL_H) $(TREE_H) hard-reg-set.h $(BASIC_BLOCK_H)\n+  $(GTM_H) $(RTL_BASE_H) $(TREE_H) $(FLAGS_H) hard-reg-set.h $(BASIC_BLOCK_H) \n \trm -f print-rtl1.c\n \tsed -e 's/config[.]h/bconfig.h/' $(srcdir)/print-rtl.c > print-rtl1.c\n \t$(CC_FOR_BUILD) -c $(BUILD_CFLAGS) $(BUILD_CPPFLAGS) $(INCLUDES) print-rtl1.c $(OUTPUT_OPTION)"}, {"sha": "ce48d3fe6447358a83bd7be0396a4ccafefcd9d7", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 3, "deletions": 509, "changes": 512, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e543e219eb1865d4230278c3db3d2bedd60b1de0/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e543e219eb1865d4230278c3db3d2bedd60b1de0/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=e543e219eb1865d4230278c3db3d2bedd60b1de0", "patch": "@@ -418,513 +418,6 @@ static const struct attribute_spec ia64_attribute_table[] =\n \n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n-/* Return 1 if OP is a valid operand for the MEM of a CALL insn.  */\n-\n-int\n-call_operand (rtx op, enum machine_mode mode)\n-{\n-  if (mode != GET_MODE (op) && mode != VOIDmode)\n-    return 0;\n-\n-  return (GET_CODE (op) == SYMBOL_REF || GET_CODE (op) == REG\n-\t  || (GET_CODE (op) == SUBREG && GET_CODE (XEXP (op, 0)) == REG));\n-}\n-\n-/* Return 1 if OP refers to a symbol in the sdata section.  */\n-\n-int\n-sdata_symbolic_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  switch (GET_CODE (op))\n-    {\n-    case CONST:\n-      if (GET_CODE (XEXP (op, 0)) != PLUS\n-\t  || GET_CODE (XEXP (XEXP (op, 0), 0)) != SYMBOL_REF)\n-\tbreak;\n-      op = XEXP (XEXP (op, 0), 0);\n-      /* FALLTHRU */\n-\n-    case SYMBOL_REF:\n-      if (CONSTANT_POOL_ADDRESS_P (op))\n-\treturn GET_MODE_SIZE (get_pool_mode (op)) <= ia64_section_threshold;\n-      else\n-\treturn SYMBOL_REF_LOCAL_P (op) && SYMBOL_REF_SMALL_P (op);\n-\n-    default:\n-      break;\n-    }\n-\n-  return 0;\n-}\n-\n-int\n-small_addr_symbolic_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  return SYMBOL_REF_SMALL_ADDR_P (op);\n-}\n-\n-/* Return 1 if OP refers to a symbol, and is appropriate for a GOT load.  */\n-\n-int\n-got_symbolic_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  switch (GET_CODE (op))\n-    {\n-    case CONST:\n-      /* Accept only (plus (symbol_ref) (const_int)).  */\n-      op = XEXP (op, 0);\n-      if (GET_CODE (op) != PLUS)\n-\treturn 0;\n-      if (GET_CODE (XEXP (op, 0)) != SYMBOL_REF)\n-\treturn 0;\n-      op = XEXP (op, 1);\n-      if (GET_CODE (op) != CONST_INT)\n-\treturn 0;\n-\n-     /* Ok if we're not using GOT entries at all.  */\n-     if (TARGET_NO_PIC || TARGET_AUTO_PIC)\n-      return 1;\n-      \n-     /* The low 14 bits of the constant have been forced to zero\n-\tby ia64_expand_load_address, so that we do not use up so\n-\tmany GOT entries.  Prevent cse from undoing this.  */\n-     return (INTVAL (op) & 0x3fff) == 0;\n-\n-    case SYMBOL_REF:\n-      /* This sort of load should not be used for things in sdata.  */\n-      return !SYMBOL_REF_SMALL_ADDR_P (op);\n-\n-    case LABEL_REF:\n-      return 1;\n-\n-    default:\n-      break;\n-    }\n-  return 0;\n-}\n-\n-/* Return 1 if OP refers to a symbol.  */\n-\n-int\n-symbolic_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  switch (GET_CODE (op))\n-    {\n-    case CONST:\n-    case SYMBOL_REF:\n-    case LABEL_REF:\n-      return 1;\n-\n-    default:\n-      break;\n-    }\n-  return 0;\n-}\n-\n-/* Return tls_model if OP refers to a TLS symbol.  */\n-\n-int\n-tls_symbolic_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  if (GET_CODE (op) != SYMBOL_REF)\n-    return 0;\n-  return SYMBOL_REF_TLS_MODEL (op);\n-}\n-\n-\n-/* Return 1 if OP refers to a function.  */\n-\n-int\n-function_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  if (GET_CODE (op) == SYMBOL_REF && SYMBOL_REF_FUNCTION_P (op))\n-    return 1;\n-  else\n-    return 0;\n-}\n-\n-/* Return 1 if OP is a general operand, excluding tls symbolic operands.  */\n-\n-int\n-move_operand (rtx op, enum machine_mode mode)\n-{\n-  return general_operand (op, mode) && !tls_symbolic_operand (op, mode);\n-}\n-\n-/* Return 1 if OP is a register operand that is (or could be) a GR reg.  */\n-\n-int\n-gr_register_operand (rtx op, enum machine_mode mode)\n-{\n-  if (! register_operand (op, mode))\n-    return 0;\n-  if (GET_CODE (op) == SUBREG)\n-    op = SUBREG_REG (op);\n-  if (GET_CODE (op) == REG)\n-    {\n-      unsigned int regno = REGNO (op);\n-      if (regno < FIRST_PSEUDO_REGISTER)\n-\treturn GENERAL_REGNO_P (regno);\n-    }\n-  return 1;\n-}\n-\n-/* Return 1 if OP is a register operand that is (or could be) an FR reg.  */\n-\n-int\n-fr_register_operand (rtx op, enum machine_mode mode)\n-{\n-  if (! register_operand (op, mode))\n-    return 0;\n-  if (GET_CODE (op) == SUBREG)\n-    op = SUBREG_REG (op);\n-  if (GET_CODE (op) == REG)\n-    {\n-      unsigned int regno = REGNO (op);\n-      if (regno < FIRST_PSEUDO_REGISTER)\n-\treturn FR_REGNO_P (regno);\n-    }\n-  return 1;\n-}\n-\n-/* Return 1 if OP is a register operand that is (or could be) a GR/FR reg.  */\n-\n-int\n-grfr_register_operand (rtx op, enum machine_mode mode)\n-{\n-  if (! register_operand (op, mode))\n-    return 0;\n-  if (GET_CODE (op) == SUBREG)\n-    op = SUBREG_REG (op);\n-  if (GET_CODE (op) == REG)\n-    {\n-      unsigned int regno = REGNO (op);\n-      if (regno < FIRST_PSEUDO_REGISTER)\n-\treturn GENERAL_REGNO_P (regno) || FR_REGNO_P (regno);\n-    }\n-  return 1;\n-}\n-\n-/* Return 1 if OP is a nonimmediate operand that is (or could be) a GR reg.  */\n-\n-int\n-gr_nonimmediate_operand (rtx op, enum machine_mode mode)\n-{\n-  if (! nonimmediate_operand (op, mode))\n-    return 0;\n-  if (GET_CODE (op) == SUBREG)\n-    op = SUBREG_REG (op);\n-  if (GET_CODE (op) == REG)\n-    {\n-      unsigned int regno = REGNO (op);\n-      if (regno < FIRST_PSEUDO_REGISTER)\n-\treturn GENERAL_REGNO_P (regno);\n-    }\n-  return 1;\n-}\n-\n-/* Return 1 if OP is a nonimmediate operand that is (or could be) a FR reg.  */\n-\n-int\n-fr_nonimmediate_operand (rtx op, enum machine_mode mode)\n-{\n-  if (! nonimmediate_operand (op, mode))\n-    return 0;\n-  if (GET_CODE (op) == SUBREG)\n-    op = SUBREG_REG (op);\n-  if (GET_CODE (op) == REG)\n-    {\n-      unsigned int regno = REGNO (op);\n-      if (regno < FIRST_PSEUDO_REGISTER)\n-\treturn FR_REGNO_P (regno);\n-    }\n-  return 1;\n-}\n-\n-/* Return 1 if OP is a nonimmediate operand that is a GR/FR reg.  */\n-\n-int\n-grfr_nonimmediate_operand (rtx op, enum machine_mode mode)\n-{\n-  if (! nonimmediate_operand (op, mode))\n-    return 0;\n-  if (GET_CODE (op) == SUBREG)\n-    op = SUBREG_REG (op);\n-  if (GET_CODE (op) == REG)\n-    {\n-      unsigned int regno = REGNO (op);\n-      if (regno < FIRST_PSEUDO_REGISTER)\n-\treturn GENERAL_REGNO_P (regno) || FR_REGNO_P (regno);\n-    }\n-  return 1;\n-}\n-\n-/* Return 1 if OP is a GR register operand, or zero.  */\n-\n-int\n-gr_reg_or_0_operand (rtx op, enum machine_mode mode)\n-{\n-  return (op == const0_rtx || gr_register_operand (op, mode));\n-}\n-\n-/* Return 1 if OP is a GR register operand, or a 5 bit immediate operand.  */\n-\n-int\n-gr_reg_or_5bit_operand (rtx op, enum machine_mode mode)\n-{\n-  return ((GET_CODE (op) == CONST_INT && INTVAL (op) >= 0 && INTVAL (op) < 32)\n-\t  || gr_register_operand (op, mode));\n-}\n-\n-/* Return 1 if OP is a GR register operand, or a 6 bit immediate operand.  */\n-\n-int\n-gr_reg_or_6bit_operand (rtx op, enum machine_mode mode)\n-{\n-  return ((GET_CODE (op) == CONST_INT && CONST_OK_FOR_M (INTVAL (op)))\n-\t  || gr_register_operand (op, mode));\n-}\n-\n-/* Return 1 if OP is a GR register operand, or an 8 bit immediate operand.  */\n-\n-int\n-gr_reg_or_8bit_operand (rtx op, enum machine_mode mode)\n-{\n-  return ((GET_CODE (op) == CONST_INT && CONST_OK_FOR_K (INTVAL (op)))\n-\t  || gr_register_operand (op, mode));\n-}\n-\n-/* Return 1 if OP is a GR/FR register operand, or an 8 bit immediate.  */\n-\n-int\n-grfr_reg_or_8bit_operand (rtx op, enum machine_mode mode)\n-{\n-  return ((GET_CODE (op) == CONST_INT && CONST_OK_FOR_K (INTVAL (op)))\n-\t  || grfr_register_operand (op, mode));\n-}\n-\n-/* Return 1 if OP is a register operand, or an 8 bit adjusted immediate\n-   operand.  */\n-\n-int\n-gr_reg_or_8bit_adjusted_operand (rtx op, enum machine_mode mode)\n-{\n-  return ((GET_CODE (op) == CONST_INT && CONST_OK_FOR_L (INTVAL (op)))\n-\t  || gr_register_operand (op, mode));\n-}\n-\n-/* Return 1 if OP is a register operand, or is valid for both an 8 bit\n-   immediate and an 8 bit adjusted immediate operand.  This is necessary\n-   because when we emit a compare, we don't know what the condition will be,\n-   so we need the union of the immediates accepted by GT and LT.  */\n-\n-int\n-gr_reg_or_8bit_and_adjusted_operand (rtx op, enum machine_mode mode)\n-{\n-  return ((GET_CODE (op) == CONST_INT && CONST_OK_FOR_K (INTVAL (op))\n-\t   && CONST_OK_FOR_L (INTVAL (op)))\n-\t  || gr_register_operand (op, mode));\n-}\n-\n-/* Return 1 if OP is a register operand, or a 14 bit immediate operand.  */\n-\n-int\n-gr_reg_or_14bit_operand (rtx op, enum machine_mode mode)\n-{\n-  return ((GET_CODE (op) == CONST_INT && CONST_OK_FOR_I (INTVAL (op)))\n-\t  || gr_register_operand (op, mode));\n-}\n-\n-/* Return 1 if OP is a register operand, or a 22 bit immediate operand.  */\n-\n-int\n-gr_reg_or_22bit_operand (rtx op, enum machine_mode mode)\n-{\n-  return ((GET_CODE (op) == CONST_INT && CONST_OK_FOR_J (INTVAL (op)))\n-\t  || gr_register_operand (op, mode));\n-}\n-\n-/* Return 1 if OP is a 6 bit immediate operand.  */\n-\n-int\n-shift_count_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  return (GET_CODE (op) == CONST_INT && CONST_OK_FOR_M (INTVAL (op)));\n-}\n-\n-/* Return 1 if OP is a 5 bit immediate operand.  */\n-\n-int\n-shift_32bit_count_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  return (GET_CODE (op) == CONST_INT\n-\t   && (INTVAL (op) >= 0 && INTVAL (op) < 32));\n-}\n-\n-/* Return 1 if OP is a 2, 4, 8, or 16 immediate operand.  */\n-\n-int\n-shladd_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  return (GET_CODE (op) == CONST_INT\n-\t  && (INTVAL (op) == 2 || INTVAL (op) == 4\n-\t      || INTVAL (op) == 8 || INTVAL (op) == 16));\n-}\n-\n-/* Return 1 if OP is a -16, -8, -4, -1, 1, 4, 8, or 16 immediate operand.  */\n-\n-int\n-fetchadd_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  return (GET_CODE (op) == CONST_INT\n-          && (INTVAL (op) == -16 || INTVAL (op) == -8 ||\n-              INTVAL (op) == -4  || INTVAL (op) == -1 ||\n-              INTVAL (op) == 1   || INTVAL (op) == 4  ||\n-              INTVAL (op) == 8   || INTVAL (op) == 16));\n-}\n-\n-/* Return 1 if OP is a floating-point constant zero, one, or a register.  */\n-\n-int\n-fr_reg_or_fp01_operand (rtx op, enum machine_mode mode)\n-{\n-  return ((GET_CODE (op) == CONST_DOUBLE && CONST_DOUBLE_OK_FOR_G (op))\n-\t  || fr_register_operand (op, mode));\n-}\n-\n-/* Like nonimmediate_operand, but don't allow MEMs that try to use a\n-   POST_MODIFY with a REG as displacement.  */\n-\n-int\n-destination_operand (rtx op, enum machine_mode mode)\n-{\n-  if (! nonimmediate_operand (op, mode))\n-    return 0;\n-  if (GET_CODE (op) == MEM\n-      && GET_CODE (XEXP (op, 0)) == POST_MODIFY\n-      && GET_CODE (XEXP (XEXP (XEXP (op, 0), 1), 1)) == REG)\n-    return 0;\n-  return 1;\n-}\n-\n-/* Like memory_operand, but don't allow post-increments.  */\n-\n-int\n-not_postinc_memory_operand (rtx op, enum machine_mode mode)\n-{\n-  return (memory_operand (op, mode)\n-\t  && GET_RTX_CLASS (GET_CODE (XEXP (op, 0))) != RTX_AUTOINC);\n-}\n-\n-/* Return 1 if this is a comparison operator, which accepts a normal 8-bit\n-   signed immediate operand.  */\n-\n-int\n-normal_comparison_operator (register rtx op, enum machine_mode mode)\n-{\n-  enum rtx_code code = GET_CODE (op);\n-  return ((mode == VOIDmode || GET_MODE (op) == mode)\n-\t  && (code == EQ || code == NE\n-\t      || code == GT || code == LE || code == GTU || code == LEU));\n-}\n-\n-/* Return 1 if this is a comparison operator, which accepts an adjusted 8-bit\n-   signed immediate operand.  */\n-\n-int\n-adjusted_comparison_operator (register rtx op, enum machine_mode mode)\n-{\n-  enum rtx_code code = GET_CODE (op);\n-  return ((mode == VOIDmode || GET_MODE (op) == mode)\n-\t  && (code == LT || code == GE || code == LTU || code == GEU));\n-}\n-\n-/* Return 1 if this is a signed inequality operator.  */\n-\n-int\n-signed_inequality_operator (register rtx op, enum machine_mode mode)\n-{\n-  enum rtx_code code = GET_CODE (op);\n-  return ((mode == VOIDmode || GET_MODE (op) == mode)\n-\t  && (code == GE || code == GT\n-\t      || code == LE || code == LT));\n-}\n-\n-/* Return 1 if this operator is valid for predication.  */\n-\n-int\n-predicate_operator (register rtx op, enum machine_mode mode)\n-{\n-  enum rtx_code code = GET_CODE (op);\n-  return ((GET_MODE (op) == mode || mode == VOIDmode)\n-\t  && (code == EQ || code == NE));\n-}\n-\n-/* Return 1 if this operator can be used in a conditional operation.  */\n-\n-int\n-condop_operator (register rtx op, enum machine_mode mode)\n-{\n-  enum rtx_code code = GET_CODE (op);\n-  return ((GET_MODE (op) == mode || mode == VOIDmode)\n-\t  && (code == PLUS || code == MINUS || code == AND\n-\t      || code == IOR || code == XOR));\n-}\n-\n-/* Return 1 if this is the ar.lc register.  */\n-\n-int\n-ar_lc_reg_operand (register rtx op, enum machine_mode mode)\n-{\n-  return (GET_MODE (op) == DImode\n-\t  && (mode == DImode || mode == VOIDmode)\n-\t  && GET_CODE (op) == REG\n-\t  && REGNO (op) == AR_LC_REGNUM);\n-}\n-\n-/* Return 1 if this is the ar.ccv register.  */\n-\n-int\n-ar_ccv_reg_operand (register rtx op, enum machine_mode mode)\n-{\n-  return ((GET_MODE (op) == mode || mode == VOIDmode)\n-\t  && GET_CODE (op) == REG\n-\t  && REGNO (op) == AR_CCV_REGNUM);\n-}\n-\n-/* Return 1 if this is the ar.pfs register.  */\n-\n-int\n-ar_pfs_reg_operand (register rtx op, enum machine_mode mode)\n-{\n-  return ((GET_MODE (op) == mode || mode == VOIDmode)\n-\t  && GET_CODE (op) == REG\n-\t  && REGNO (op) == AR_PFS_REGNUM);\n-}\n-\n-/* Similarly.  */\n-\n-int\n-xfreg_or_fp01_operand (rtx op, enum machine_mode mode)\n-{\n-  if (GET_CODE (op) == SUBREG)\n-    return 0;\n-  return fr_reg_or_fp01_operand (op, mode);\n-}\n-\n-/* Return 1 if OP is valid as a base register in a reg + offset address.  */\n-\n-int\n-basereg_operand (rtx op, enum machine_mode mode)\n-{\n-  /* ??? Should I copy the flag_omit_frame_pointer and cse_not_expected\n-     checks from pa.c basereg_operand as well?  Seems to be OK without them\n-     in test runs.  */\n-\n-  return (register_operand (op, mode) &&\n-\t  REG_POINTER ((GET_CODE (op) == SUBREG) ? SUBREG_REG (op) : op));\n-}\n-\f\n typedef enum\n   {\n     ADDR_AREA_NORMAL,\t/* normal address area */\n@@ -1099,7 +592,7 @@ ia64_depz_field_mask (rtx rop, rtx rshift)\n void\n ia64_expand_load_address (rtx dest, rtx src)\n {\n-  if (tls_symbolic_operand (src, VOIDmode))\n+  if (GET_CODE (src) == SYMBOL_REF && SYMBOL_REF_TLS_MODEL (src))\n     abort ();\n   if (GET_CODE (dest) != REG)\n     abort ();\n@@ -1299,7 +792,8 @@ ia64_expand_move (rtx op0, rtx op1)\n   if ((mode == Pmode || mode == ptr_mode) && symbolic_operand (op1, VOIDmode))\n     {\n       enum tls_model tls_kind;\n-      if ((tls_kind = tls_symbolic_operand (op1, VOIDmode)))\n+      if (GET_CODE (op1) == SYMBOL_REF\n+\t  && (tls_kind = SYMBOL_REF_TLS_MODEL (op1)))\n \treturn ia64_expand_tls_address (tls_kind, op0, op1);\n \n       if (!TARGET_NO_PIC && reload_completed)"}, {"sha": "58304a9b36661e1d0b268f5c6b7d71f1d00e9247", "filename": "gcc/config/ia64/ia64.h", "status": "modified", "additions": 4, "deletions": 47, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e543e219eb1865d4230278c3db3d2bedd60b1de0/gcc%2Fconfig%2Fia64%2Fia64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e543e219eb1865d4230278c3db3d2bedd60b1de0/gcc%2Fconfig%2Fia64%2Fia64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.h?ref=e543e219eb1865d4230278c3db3d2bedd60b1de0", "patch": "@@ -146,6 +146,10 @@ extern int target_flags;\n \n #define TARGET_DWARF2_ASM\t(target_flags & MASK_DWARF2_ASM)\n \n+/* Variables which are this size or smaller are put in the sdata/sbss\n+   sections.  */\n+extern unsigned int ia64_section_threshold;\n+\n /* If the assembler supports thread-local storage, assume that the\n    system does as well.  If a particular target system has an\n    assembler that supports TLS -- but the rest of the system does not\n@@ -2140,53 +2144,6 @@ do {\t\t\t\t\t\t\t\t\t\\\n #define SYMBOL_REF_SMALL_ADDR_P(X)\t\\\n \t((SYMBOL_REF_FLAGS (X) & SYMBOL_FLAG_SMALL_ADDR) != 0)\n \n-/* Define this if you have defined special-purpose predicates in the file\n-   `MACHINE.c'.  For each predicate, list all rtl codes that can be in\n-   expressions matched by the predicate.  */\n-\n-#define PREDICATE_CODES \\\n-{ \"call_operand\", {SUBREG, REG, SYMBOL_REF}},\t\t\t\t\\\n-{ \"got_symbolic_operand\", {SYMBOL_REF, CONST, LABEL_REF}},\t\t\\\n-{ \"sdata_symbolic_operand\", {SYMBOL_REF, CONST}},\t\t\t\\\n-{ \"small_addr_symbolic_operand\", {SYMBOL_REF}},\t\t\t\t\\\n-{ \"symbolic_operand\", {SYMBOL_REF, CONST, LABEL_REF}},\t\t\t\\\n-{ \"tls_symbolic_operand\", {SYMBOL_REF}},\t\t\t\t\\\n-{ \"function_operand\", {SYMBOL_REF}},\t\t\t\t\t\\\n-{ \"destination_operand\", {SUBREG, REG, MEM}},\t\t\t\t\\\n-{ \"not_postinc_memory_operand\", {MEM}},\t\t\t\t\t\\\n-{ \"move_operand\", {SUBREG, REG, MEM, CONST_INT, CONST_DOUBLE,\t\t\\\n-\t\t     SYMBOL_REF, CONST, LABEL_REF}},\t\t\t\\\n-{ \"gr_register_operand\", {SUBREG, REG}},\t\t\t\t\\\n-{ \"fr_register_operand\", {SUBREG, REG}},\t\t\t\t\\\n-{ \"grfr_register_operand\", {SUBREG, REG}},\t\t\t\t\\\n-{ \"gr_nonimmediate_operand\", {SUBREG, REG, MEM}},\t\t\t\\\n-{ \"fr_nonimmediate_operand\", {SUBREG, REG, MEM}},\t\t\t\\\n-{ \"grfr_nonimmediate_operand\", {SUBREG, REG, MEM}},\t\t\t\\\n-{ \"gr_reg_or_0_operand\", {SUBREG, REG, CONST_INT}},\t\t\t\\\n-{ \"gr_reg_or_5bit_operand\", {SUBREG, REG, CONST_INT}},\t\t\t\\\n-{ \"gr_reg_or_6bit_operand\", {SUBREG, REG, CONST_INT}},\t\t\t\\\n-{ \"gr_reg_or_8bit_operand\", {SUBREG, REG, CONST_INT}},\t\t\t\\\n-{ \"grfr_reg_or_8bit_operand\", {SUBREG, REG, CONST_INT}}, \t\t\\\n-{ \"gr_reg_or_8bit_adjusted_operand\", {SUBREG, REG, CONST_INT}},\t\t\\\n-{ \"gr_reg_or_8bit_and_adjusted_operand\", {SUBREG, REG, CONST_INT}},\t\\\n-{ \"gr_reg_or_14bit_operand\", {SUBREG, REG, CONST_INT}}, \t\t\\\n-{ \"gr_reg_or_22bit_operand\", {SUBREG, REG, CONST_INT}}, \t\t\\\n-{ \"shift_count_operand\", {SUBREG, REG, CONST_INT}},\t\t\t\\\n-{ \"shift_32bit_count_operand\", {SUBREG, REG, CONST_INT}},\t\t\\\n-{ \"shladd_operand\", {CONST_INT}},\t\t\t\t\t\\\n-{ \"fetchadd_operand\", {CONST_INT}},\t\t\t\t\t\\\n-{ \"fr_reg_or_fp01_operand\", {SUBREG, REG, CONST_DOUBLE}},\t\t\\\n-{ \"normal_comparison_operator\", {EQ, NE, GT, LE, GTU, LEU}},\t\t\\\n-{ \"adjusted_comparison_operator\", {LT, GE, LTU, GEU}},\t\t\t\\\n-{ \"signed_inequality_operator\", {GE, GT, LE, LT}},\t\t\t\\\n-{ \"predicate_operator\", {NE, EQ}},\t\t\t\t\t\\\n-{ \"condop_operator\", {PLUS, MINUS, IOR, XOR, AND}},\t\t\t\\\n-{ \"ar_lc_reg_operand\", {REG}},\t\t\t\t\t\t\\\n-{ \"ar_ccv_reg_operand\", {REG}},\t\t\t\t\t\t\\\n-{ \"ar_pfs_reg_operand\", {REG}},\t\t\t\t\t\t\\\n-{ \"xfreg_or_fp01_operand\", {REG, CONST_DOUBLE}},\t\t\t\\\n-{ \"basereg_operand\", {SUBREG, REG}},\n-\n /* An alias for a machine mode name.  This is the machine mode that elements of\n    a jump-table should have.  */\n "}, {"sha": "31af3bbd5346483ea86214f0cc540e94da5769ca", "filename": "gcc/config/ia64/ia64.md", "status": "modified", "additions": 336, "deletions": 0, "changes": 336, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e543e219eb1865d4230278c3db3d2bedd60b1de0/gcc%2Fconfig%2Fia64%2Fia64.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e543e219eb1865d4230278c3db3d2bedd60b1de0/gcc%2Fconfig%2Fia64%2Fia64.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.md?ref=e543e219eb1865d4230278c3db3d2bedd60b1de0", "patch": "@@ -89,6 +89,342 @@\n    (UNSPECV_PSAC_NORMAL\t\t6)\n    (UNSPECV_SETJMP_RECEIVER\t7)\n   ])\n+\f\n+;; ::::::::::::::::::::\n+;; ::\n+;; :: Predicates\n+;; ::\n+;; ::::::::::::::::::::\n+\n+;; True if OP is a valid operand for the MEM of a CALL insn.\n+(define_predicate \"call_operand\"\n+  (ior (match_code \"symbol_ref\")\n+       (match_operand 0 \"register_operand\")))\n+\n+;; True if OP refers to any kind of symbol.\n+;; For roughly the same reasons that pmode_register_operand exists, this\n+;; predicate ignores its mode argument.\n+(define_special_predicate \"symbolic_operand\" \n+   (match_code \"symbol_ref,const,label_ref\"))\n+\n+;; True if OP is a SYMBOL_REF which refers to a function.\n+(define_predicate \"function_operand\"\n+  (and (match_code \"symbol_ref\")\n+       (match_test \"SYMBOL_REF_FUNCTION_P (op)\")))\n+\n+;; True if OP refers to a symbol, and is appropriate for a GOT load.\n+(define_predicate \"got_symbolic_operand\" \n+  (match_operand 0 \"symbolic_operand\" \"\")\n+{\n+  switch (GET_CODE (op))\n+    {\n+    case LABEL_REF:\n+      return true;\n+\n+    case SYMBOL_REF:\n+      /* This sort of load should not be used for things in sdata.  */\n+      return !SYMBOL_REF_SMALL_ADDR_P (op);\n+\n+    case CONST:\n+      /* Accept only (plus (symbol_ref) (const_int)).  */\n+      op = XEXP (op, 0);\n+      if (GET_CODE (op) != PLUS\n+\t  || GET_CODE (XEXP (op, 0)) != SYMBOL_REF\n+          || GET_CODE (XEXP (op, 1)) != CONST_INT)\n+        return false;\n+\n+      /* Ok if we're not using GOT entries at all.  */\n+      if (TARGET_NO_PIC || TARGET_AUTO_PIC)\n+        return true;\n+\n+      /* The low 14 bits of the constant have been forced to zero\n+\t by ia64_expand_load_address, so that we do not use up so\n+\t many GOT entries.  Prevent cse from undoing this.  */\n+      op = XEXP (op, 1);\n+      return (INTVAL (op) & 0x3fff) == 0;\n+\n+    default:\n+      abort ();\n+    }\n+})\n+\n+;; True if OP refers to a symbol in the sdata section.\n+(define_predicate \"sdata_symbolic_operand\" \n+  (match_code \"symbol_ref,const\")\n+{\n+  switch (GET_CODE (op))\n+    {\n+    case CONST:\n+      op = XEXP (op, 0);\n+      if (GET_CODE (op) != PLUS\n+\t  || GET_CODE (XEXP (op, 0)) != SYMBOL_REF)\n+\treturn false;\n+      op = XEXP (op, 0);\n+      /* FALLTHRU */\n+\n+    case SYMBOL_REF:\n+      if (CONSTANT_POOL_ADDRESS_P (op))\n+\treturn GET_MODE_SIZE (get_pool_mode (op)) <= ia64_section_threshold;\n+      else\n+\treturn SYMBOL_REF_LOCAL_P (op) && SYMBOL_REF_SMALL_P (op);\n+\n+    default:\n+      abort ();\n+    }\n+})\n+\n+;; Like nonimmediate_operand, but don't allow MEMs that try to use a\n+;; POST_MODIFY with a REG as displacement.\n+(define_predicate \"destination_operand\"\n+  (and (match_operand 0 \"nonimmediate_operand\")\n+       (match_test \"GET_CODE (op) != MEM\n+\t\t    || GET_CODE (XEXP (op, 0)) != POST_MODIFY\n+\t\t    || GET_CODE (XEXP (XEXP (XEXP (op, 0), 1), 1)) != REG\")))\n+\n+;; Like memory_operand, but don't allow post-increments.\n+(define_predicate \"not_postinc_memory_operand\"\n+  (and (match_operand 0 \"memory_operand\")\n+       (match_test \"GET_RTX_CLASS (GET_CODE (XEXP (op, 0))) != RTX_AUTOINC\")))\n+\n+;; True if OP is a general operand, excluding tls symbolic operands.\n+(define_predicate \"move_operand\"\n+  (and (match_operand 0 \"general_operand\")\n+       (not (match_test \n+\t     \"GET_CODE (op) == SYMBOL_REF && SYMBOL_REF_TLS_MODEL (op)\"))))\n+\n+;; True if OP is a register operand that is (or could be) a GR reg.\n+(define_predicate \"gr_register_operand\"\n+  (match_operand 0 \"register_operand\")\n+{\n+  unsigned int regno;\n+  if (GET_CODE (op) == SUBREG)\n+    op = SUBREG_REG (op);\n+\n+  regno = REGNO (op);\n+  return (regno >= FIRST_PSEUDO_REGISTER || GENERAL_REGNO_P (regno));\n+})\n+\n+;; True if OP is a register operand that is (or could be) an FR reg.\n+(define_predicate \"fr_register_operand\"\n+  (match_operand 0 \"register_operand\")\n+{\n+  unsigned int regno;\n+  if (GET_CODE (op) == SUBREG)\n+    op = SUBREG_REG (op);\n+\n+  regno = REGNO (op);\n+  return (regno >= FIRST_PSEUDO_REGISTER || FR_REGNO_P (regno));\n+})\n+\n+;; True if OP is a register operand that is (or could be) a GR/FR reg.\n+(define_predicate \"grfr_register_operand\"\n+  (match_operand 0 \"register_operand\")\n+{\n+  unsigned int regno;\n+  if (GET_CODE (op) == SUBREG)\n+    op = SUBREG_REG (op);\n+\n+  regno = REGNO (op);\n+  return (regno >= FIRST_PSEUDO_REGISTER\n+\t  || GENERAL_REGNO_P (regno)\n+\t  || FR_REGNO_P (regno));\n+})\n+\n+;; True if OP is a nonimmediate operand that is (or could be) a GR reg.\n+(define_predicate \"gr_nonimmediate_operand\"\n+  (match_operand 0 \"nonimmediate_operand\")\n+{\n+  unsigned int regno;\n+\n+  if (GET_CODE (op) == MEM)\n+    return true;\n+  if (GET_CODE (op) == SUBREG)\n+    op = SUBREG_REG (op);\n+\n+  regno = REGNO (op);\n+  return (regno >= FIRST_PSEUDO_REGISTER || GENERAL_REGNO_P (regno));\n+})\n+\n+;; True if OP is a nonimmediate operand that is (or could be) a FR reg.\n+(define_predicate \"fr_nonimmediate_operand\"\n+  (match_operand 0 \"nonimmediate_operand\")\n+{\n+  unsigned int regno;\n+\n+  if (GET_CODE (op) == MEM)\n+    return true;\n+  if (GET_CODE (op) == SUBREG)\n+    op = SUBREG_REG (op);\n+\n+  regno = REGNO (op);\n+  return (regno >= FIRST_PSEUDO_REGISTER || FR_REGNO_P (regno));\n+})\n+\n+;; True if OP is a nonimmediate operand that is (or could be) a GR/FR reg.\n+(define_predicate \"grfr_nonimmediate_operand\"\n+  (match_operand 0 \"nonimmediate_operand\")\n+{\n+  unsigned int regno;\n+\n+  if (GET_CODE (op) == MEM)\n+    return true;\n+  if (GET_CODE (op) == SUBREG)\n+    op = SUBREG_REG (op);\n+\n+  regno = REGNO (op);\n+  return (regno >= FIRST_PSEUDO_REGISTER\n+\t  || GENERAL_REGNO_P (regno)\n+\t  || FR_REGNO_P (regno));\n+})\n+\n+;; True if OP is a GR register operand, or zero.\n+(define_predicate \"gr_reg_or_0_operand\"\n+  (ior (match_operand 0 \"gr_register_operand\")\n+       (and (match_code \"const_int\")\n+\t    (match_test \"op == const0_rtx\"))))\n+\n+;; True if OP is a GR register operand, or a 5 bit immediate operand.\n+(define_predicate \"gr_reg_or_5bit_operand\"\n+  (ior (match_operand 0 \"gr_register_operand\")\n+       (and (match_code \"const_int\")\n+\t    (match_test \"INTVAL (op) >= 0 && INTVAL (op) < 32\"))))\n+\n+;; True if OP is a GR register operand, or a 6 bit immediate operand.\n+(define_predicate \"gr_reg_or_6bit_operand\"\n+  (ior (match_operand 0 \"gr_register_operand\")\n+       (and (match_code \"const_int\")\n+\t    (match_test \"CONST_OK_FOR_M (INTVAL (op))\"))))\n+\n+;; True if OP is a GR register operand, or an 8 bit immediate operand.\n+(define_predicate \"gr_reg_or_8bit_operand\"\n+  (ior (match_operand 0 \"gr_register_operand\")\n+       (and (match_code \"const_int\")\n+\t    (match_test \"CONST_OK_FOR_K (INTVAL (op))\"))))\n+\n+;; True if OP is a GR/FR register operand, or an 8 bit immediate operand.\n+(define_predicate \"grfr_reg_or_8bit_operand\"\n+  (ior (match_operand 0 \"grfr_register_operand\")\n+       (and (match_code \"const_int\")\n+\t    (match_test \"CONST_OK_FOR_K (INTVAL (op))\"))))\n+\n+;; True if OP is a register operand, or an 8 bit adjusted immediate operand.\n+(define_predicate \"gr_reg_or_8bit_adjusted_operand\"\n+  (ior (match_operand 0 \"gr_register_operand\")\n+       (and (match_code \"const_int\")\n+\t    (match_test \"CONST_OK_FOR_L (INTVAL (op))\"))))\n+\n+;; True if OP is a register operand, or is valid for both an 8 bit\n+;; immediate and an 8 bit adjusted immediate operand.  This is necessary\n+;; because when we emit a compare, we don't know what the condition will be,\n+;; so we need the union of the immediates accepted by GT and LT.\n+(define_predicate \"gr_reg_or_8bit_and_adjusted_operand\"\n+  (ior (match_operand 0 \"gr_register_operand\")\n+       (and (match_code \"const_int\")\n+\t    (match_test \"CONST_OK_FOR_K (INTVAL (op))\n+                         && CONST_OK_FOR_L (INTVAL (op))\"))))\n+\n+;; True if OP is a register operand, or a 14 bit immediate operand.\n+(define_predicate \"gr_reg_or_14bit_operand\"\n+  (ior (match_operand 0 \"gr_register_operand\")\n+       (and (match_code \"const_int\")\n+\t    (match_test \"CONST_OK_FOR_I (INTVAL (op))\"))))\n+\n+;;  True if OP is a register operand, or a 22 bit immediate operand.\n+(define_predicate \"gr_reg_or_22bit_operand\"\n+  (ior (match_operand 0 \"gr_register_operand\")\n+       (and (match_code \"const_int\")\n+\t    (match_test \"CONST_OK_FOR_J (INTVAL (op))\"))))\n+\n+;; True if OP is a 6 bit immediate operand.\n+(define_predicate \"shift_count_operand\"\n+  (and (match_code \"const_int\")\n+       (match_test \"CONST_OK_FOR_M (INTVAL (op))\")))\n+\n+;; True if OP is a 5 bit immediate operand.\n+(define_predicate \"shift_32bit_count_operand\"\n+   (and (match_code \"const_int\")\n+        (match_test \"INTVAL (op) >= 0 && INTVAL (op) < 32\")))\n+\n+;; True if OP is one of the immediate valuse 2, 4, 8, or 16.\n+(define_predicate \"shladd_operand\"\n+  (and (match_code \"const_int\")\n+       (match_test \"INTVAL (op) == 2 || INTVAL (op) == 4 ||\n+\t            INTVAL (op) == 8 || INTVAL (op) == 16\")))\n+\n+;; True if OP is one of the immediate values  -16, -8, -4, -1, 1, 4, 8, 16.\n+(define_predicate \"fetchadd_operand\"\n+  (and (match_code \"const_int\")\n+       (match_test \"INTVAL (op) == -16 || INTVAL (op) == -8 ||\n+                    INTVAL (op) == -4  || INTVAL (op) == -1 ||\n+                    INTVAL (op) == 1   || INTVAL (op) == 4  ||\n+                    INTVAL (op) == 8   || INTVAL (op) == 16\")))\n+\n+\n+;; True if OP is a floating-point constant zero, one, or a register.\n+(define_predicate \"fr_reg_or_fp01_operand\"\n+  (ior (match_operand 0 \"fr_register_operand\")\n+       (and (match_code \"const_double\")\n+\t    (match_test \"CONST_DOUBLE_OK_FOR_G (op)\"))))\n+\n+;; Like fr_reg_or_fp01_operand, but don't allow any SUBREGs.\n+(define_predicate \"xfreg_or_fp01_operand\"\n+  (and (match_operand 0 \"fr_reg_or_fp01_operand\")\n+       (not (match_code \"subreg\"))))\n+\n+;; True if this is a comparison operator, which accepts a normal 8-bit\n+;; signed immediate operand.\n+(define_predicate \"normal_comparison_operator\"\n+  (match_code \"eq,ne,gt,le,gtu,leu\"))\n+\n+;; True if this is a comparison operator, which accepts an adjusted 8-bit\n+;; signed immediate operand.\n+(define_predicate \"adjusted_comparison_operator\"\n+  (match_code \"lt,ge,ltu,geu\"))\n+\n+;; True if this is a signed inequality operator.\n+(define_predicate \"signed_inequality_operator\"\n+  (match_code \"ge,gt,le,lt\"))\n+\n+;; True if this operator is valid for predication.\n+(define_predicate \"predicate_operator\"\n+  (match_code \"eq,ne\"))\n+\n+;; True if this operator can be used in a conditional operation.\n+(define_predicate \"condop_operator\"\n+  (match_code \"plus,minus,ior,xor,and\"))\n+\n+;; These three are hardware registers that can only be addressed in\n+;; DImode.  It's not strictly necessary to test mode == DImode here,\n+;; but it makes decent insurance against someone writing a\n+;; match_operand wrong.\n+\n+;; True if this is the ar.lc register.\n+(define_predicate \"ar_lc_reg_operand\"\n+  (and (match_code \"reg\")\n+       (match_test \"mode == DImode && REGNO (op) == AR_LC_REGNUM\")))\n+\n+;; True if this is the ar.ccv register.\n+(define_predicate \"ar_ccv_reg_operand\"\n+  (and (match_code \"reg\")\n+       (match_test \"mode == DImode && REGNO (op) == AR_CCV_REGNUM\")))\n+\n+;; True if this is the ar.pfs register.\n+(define_predicate \"ar_pfs_reg_operand\"\n+  (and (match_code \"reg\")\n+       (match_test \"mode == DImode && REGNO (op) == AR_PFS_REGNUM\")))\n+\n+;; True if OP is valid as a base register in a reg + offset address.\n+;; ??? Should I copy the flag_omit_frame_pointer and cse_not_expected\n+;; checks from pa.c basereg_operand as well?  Seems to be OK without them\n+;; in test runs.\n+(define_predicate \"basereg_operand\"\n+  (match_operand 0 \"register_operand\")\n+{\n+  if (GET_CODE (op) == SUBREG)\n+    op = SUBREG_REG (op);\n+  return REG_POINTER (op);\n+})\n+\n \f\n ;; ::::::::::::::::::::\n ;; ::"}, {"sha": "6b85836cb0fc28b727353c0d6c6111a21c82f7b1", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 346, "deletions": 35, "changes": 381, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e543e219eb1865d4230278c3db3d2bedd60b1de0/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e543e219eb1865d4230278c3db3d2bedd60b1de0/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=e543e219eb1865d4230278c3db3d2bedd60b1de0", "patch": "@@ -28,7 +28,9 @@ See the next chapter for information on the C header file.\n                           from such an insn.\n * Output Statement::    For more generality, write C code to output\n                           the assembler code.\n-* Constraints::         When not all operands are general operands.\n+* Predicates::          Controlling what kinds of operands can be used\n+                          for an insn.\n+* Constraints::         Fine-tuning operand selection.\n * Standard Names::      Names mark patterns to use for code generation.\n * Pattern Ordering::    When the order of patterns makes a difference.\n * Dependent Patterns::  Having one pattern may make you need another.\n@@ -258,14 +260,16 @@ expressions.  In the case of a @code{define_expand}, any operand numbers\n used only in @code{match_dup} expressions have higher values than all\n other operand numbers.\n \n-@var{predicate} is a string that is the name of a C function that accepts two\n-arguments, an expression and a machine mode.  During matching, the\n-function will be called with the putative operand as the expression and\n-@var{m} as the mode argument (if @var{m} is not specified,\n-@code{VOIDmode} will be used, which normally causes @var{predicate} to accept\n-any mode).  If it returns zero, this instruction pattern fails to match.\n-@var{predicate} may be an empty string; then it means no test is to be done\n-on the operand, so anything which occurs in this position is valid.\n+@var{predicate} is a string that is the name of a function that\n+accepts two arguments, an expression and a machine mode.\n+@xref{Predicates}.  During matching, the function will be called with\n+the putative operand as the expression and @var{m} as the mode\n+argument (if @var{m} is not specified, @code{VOIDmode} will be used,\n+which normally causes @var{predicate} to accept any mode).  If it\n+returns zero, this instruction pattern fails to match.\n+@var{predicate} may be an empty string; then it means no test is to be\n+done on the operand, so anything which occurs in this position is\n+valid.\n \n Most of the time, @var{predicate} will reject modes other than @var{m}---but\n not always.  For example, the predicate @code{address_operand} uses\n@@ -275,36 +279,13 @@ Many predicates accept @code{const_int} nodes even though their mode is\n \n @var{constraint} controls reloading and the choice of the best register\n class to use for a value, as explained later (@pxref{Constraints}).\n+If the constraint would be an empty string, it can be omitted.\n \n People are often unclear on the difference between the constraint and the\n predicate.  The predicate helps decide whether a given insn matches the\n pattern.  The constraint plays no role in this decision; instead, it\n controls various decisions in the case of an insn which does match.\n \n-@findex general_operand\n-On CISC machines, the most common @var{predicate} is\n-@code{\"general_operand\"}.  This function checks that the putative\n-operand is either a constant, a register or a memory reference, and that\n-it is valid for mode @var{m}.\n-\n-@findex register_operand\n-For an operand that must be a register, @var{predicate} should be\n-@code{\"register_operand\"}.  Using @code{\"general_operand\"} would be\n-valid, since the reload pass would copy any non-register operands\n-through registers, but this would make GCC do extra work, it would\n-prevent invariant operands (such as constant) from being removed from\n-loops, and it would prevent the register allocator from doing the best\n-possible job.  On RISC machines, it is usually most efficient to allow\n-@var{predicate} to accept only objects that the constraints allow.\n-\n-@findex immediate_operand\n-For an operand that must be a constant, you must be sure to either use\n-@code{\"immediate_operand\"} for @var{predicate}, or make the instruction\n-pattern's extra condition require a constant, or both.  You cannot\n-expect the constraints to do this work!  If the constraints allow only\n-constants, but the predicate allows something else, the compiler will\n-crash when that case arises.\n-\n @findex match_scratch\n @item (match_scratch:@var{m} @var{n} @var{constraint})\n This expression is also a placeholder for operand number @var{n}\n@@ -681,6 +662,333 @@ as follows, having the output control string start with a @samp{@@}:\n    clrmem %0\")\n @end group\n @end smallexample\n+\n+@node Predicates\n+@section Predicates\n+@cindex predicates\n+@cindex operand predicates\n+@cindex operator predicates\n+\n+A predicate determines whether a @code{match_operand} or\n+@code{match_operator} expression matches, and therefore whether the\n+surrounding instruction pattern will be used for that combination of\n+operands.  GCC has a number of machine-independent predicates, and you\n+can define machine-specific predicates as needed.  By convention,\n+predicates used with @code{match_operand} have names that end in\n+@samp{_operand}, and those used with @code{match_operator} have names\n+that end in @samp{_operator}.\n+\n+All predicates are Boolean functions (in the mathematical sense) of\n+two arguments: the RTL expression that is being considered at that\n+position in the instruction pattern, and the machine mode that the\n+@code{match_operand} or @code{match_operator} specifies.  In this\n+section, the first argument is called @var{op} and the second argument\n+@var{mode}.  Predicates can be called from C as ordinary two-argument\n+functions; this can be useful in output templates or other\n+machine-specific code.\n+\n+Operand predicates can allow operands that are not actually acceptable\n+to the hardware, as long as the constraints give reload the ability to\n+fix them up (@pxref{Constraints}).  However, GCC will usually generate\n+better code if the predicates specify the requirements of the machine\n+instructions as closely as possible.  Reload cannot fix up operands\n+that must be constants (``immediate operands''); you must use a\n+predicate that allows only constants, or else enforce the requirement\n+in the extra condition.\n+\n+@cindex predicates and machine modes\n+@cindex normal predicates\n+@cindex special predicates\n+Most predicates handle their @var{mode} argument in a uniform manner.\n+If @var{mode} is @code{VOIDmode} (unspecified), then @var{op} can have\n+any mode.  If @var{mode} is anything else, then @var{op} must have the\n+same mode, unless @var{op} is a @code{CONST_INT} or integer\n+@code{CONST_DOUBLE}.  These RTL expressions always have\n+@code{VOIDmode}, so it would be counterproductive to check that their\n+mode matches.  Instead, predicates that accept @code{CONST_INT} and/or\n+integer @code{CONST_DOUBLE} check that the value stored in the\n+constant will fit in the requested mode.\n+\n+Predicates with this behavior are called @dfn{normal}.\n+@command{genrecog} can optimize the instruction recognizer based on\n+knowledge of how normal predicates treat modes.  It can also diagnose\n+certain kinds of common errors in the use of normal predicates; for\n+instance, it is almost always an error to use a normal predicate\n+without specifying a mode.\n+\n+Predicates that do something different with their @var{mode} argument\n+are called @dfn{special}.  The generic predicates\n+@code{address_operand} and @code{pmode_register_operand} are special\n+predicates.  @command{genrecog} does not do any optimizations or\n+diagnosis when special predicates are used.\n+\n+@menu\n+* Machine-Independent Predicates::  Predicates available to all back ends.\n+* Defining Predicates::             How to write machine-specific predicate\n+                                    functions.\n+@end menu\n+\n+@node Machine-Independent Predicates\n+@subsection Machine-Independent Predicates\n+@cindex machine-independent predicates\n+@cindex generic predicates\n+\n+These are the generic predicates available to all back ends.  They are\n+defined in @file{recog.c}.  The first category of predicates allow\n+only constant, or @dfn{immediate}, operands.\n+\n+@defun immediate_operand\n+This predicate allows any sort of constant that fits in @var{mode}.\n+It is an appropriate choice for instructions that take operands that\n+must be constant.\n+@end defun\n+\n+@defun const_int_operand\n+This predicate allows any @code{CONST_INT} expression that fits in\n+@var{mode}.  It is an appropriate choice for an immediate operand that\n+does not allow a symbol or label.\n+@end defun\n+\n+@defun const_double_operand\n+This predicate accepts any @code{CONST_DOUBLE} expression that has\n+exactly @var{mode}.  If @var{mode} is @code{VOIDmode}, it will also\n+accept @code{CONST_INT}.  It is intended for immediate floating point\n+constants.\n+@end defun\n+\n+@noindent\n+The second category of predicates allow only some kind of machine\n+register.\n+\n+@defun register_operand\n+This predicate allows any @code{REG} or @code{SUBREG} expression that\n+is valid for @var{mode}.  It is often suitable for arithmetic\n+instruction operands on a RISC machine.\n+@end defun\n+\n+@defun pmode_register_operand\n+This is a slight variant on @code{register_operand} which works around\n+a limitation in the machine-description reader.\n+\n+@example\n+(match_operand @var{n} \"pmode_register_operand\" @var{constraint})\n+@end example\n+\n+@noindent\n+means exactly what\n+\n+@example\n+(match_operand:P @var{n} \"register_operand\" @var{constraint})\n+@end example\n+\n+@noindent\n+would mean, if the machine-description reader accepted @samp{:P}\n+mode suffixes.  Unfortunately, it cannot, because @code{Pmode} is an\n+alias for some other mode, and might vary with machine-specific\n+options. @xref{Misc}.\n+@end defun\n+\n+@defun scratch_operand\n+This predicate allows hard registers and @code{SCRATCH} expressions,\n+but not pseudo-registers.  It is used internally by @code{match_scratch};\n+it should not be used directly.\n+@end defun\n+\n+@noindent\n+The third category of predicates allow only some kind of memory reference.\n+\n+@defun memory_operand\n+This predicate allows any valid reference to a quantity of mode\n+@var{mode} in memory, as determined by the weak form of\n+@code{GO_IF_LEGITIMATE_ADDRESS} (@pxref{Addressing Modes}).\n+@end defun\n+\n+@defun address_operand\n+This predicate is a little unusual; it allows any operand that is a\n+valid expression for the @emph{address} of a quantity of mode\n+@var{mode}, again determined by the weak form of\n+@code{GO_IF_LEGITIMATE_ADDRESS}.  To first order, if\n+@samp{@w{(mem:@var{mode} (@var{exp}))}} is acceptable to\n+@code{memory_operand}, then @var{exp} is acceptable to\n+@code{address_operand}.  Note that @var{exp} does not necessarily have\n+the mode @var{mode}.\n+@end defun\n+\n+@defun indirect_operand\n+This is a stricter form of @code{memory_operand} which allows only\n+memory references with a @code{general_operand} as the address\n+expression.  New uses of this predicate are discouraged, because\n+@code{general_operand} is very permissive, so it's hard to tell what\n+an @code{indirect_operand} does or does not allow.  If a target has\n+different requirements for memory operands for different instructions,\n+it is better to define target-specific predicates which enforce the\n+hardware's requirements explicitly.\n+@end defun\n+\n+@defun push_operand\n+This predicate allows a memory reference suitable for pushing a value\n+onto the stack.  This will be a @code{MEM} which refers to\n+@code{stack_pointer_rtx}, with a side-effect in its address expression\n+(@pxref{Incdec}); which one is determined by the\n+@code{STACK_PUSH_CODE} macro (@pxref{Frame Layout}).\n+@end defun\n+\n+@defun pop_operand\n+This predicate allows a memory reference suitable for popping a value\n+off the stack.  Again, this will be a @code{MEM} referring to\n+@code{stack_pointer_rtx}, with a side-effect in its address\n+expression.  However, this time @code{STACK_POP_CODE} is expected.\n+@end defun\n+\n+@noindent\n+The fourth category of predicates allow some combination of the above\n+operands.\n+\n+@defun nonmemory_operand\n+This predicate allows any immediate or register operand valid for @var{mode}.\n+@end defun\n+\n+@defun nonimmediate_operand\n+This predicate allows any register or memory operand valid for @var{mode}.\n+@end defun\n+\n+@defun general_operand\n+This predicate allows any immediate, register, or memory operand\n+valid for @var{mode}.\n+@end defun\n+\n+@noindent\n+Finally, there is one generic operator predicate.\n+\n+@defun comparison_operator\n+This predicate matches any expression which performs an arithmetic\n+comparison in @var{mode}; that is, @code{COMPARISON_P} is true for the\n+expression code.\n+@end defun\n+\n+@node Defining Predicates\n+@subsection Defining Machine-Specific Predicates\n+@cindex defining predicates\n+@findex define_predicate\n+@findex define_special_predicate\n+\n+Many machines have requirements for their operands that cannot be\n+expressed precisely using the generic predicates.  You can define\n+additional predicates using @code{define_predicate} and\n+@code{define_special_predicate} expressions.  These expressions have\n+three operands:\n+\n+@itemize @bullet\n+@item\n+The name of the predicate, as it will be referred to in\n+@code{match_operand} or @code{match_operator} expressions.\n+\n+@item\n+An RTL expression which evaluates to true if the predicate allows the\n+operand @var{op}, false if it does not.  This expression can only use\n+the following RTL codes:\n+\n+@table @code\n+@item MATCH_OPERAND\n+When written inside a predicate expression, a @code{MATCH_OPERAND}\n+expression evaluates to true if the predicate it names would allow\n+@var{op}.  The operand number and constraint are ignored.  Due to\n+limitations in @command{genrecog}, you can only refer to generic\n+predicates and predicates that have already been defined.\n+\n+@item MATCH_CODE\n+This expression has one operand, a string constant containing a\n+comma-separated list of RTX code names (in lower case).  It evaluates\n+to true if @var{op} has any of the listed codes.\n+\n+@item MATCH_TEST\n+This expression has one operand, a string constant containing a C\n+expression.  The predicate's arguments, @var{op} and @var{mode}, are\n+available with those names in the C expression.  The @code{MATCH_TEST}\n+evaluates to true if the C expression evaluates to a nonzero value.\n+@code{MATCH_TEST} expressions must not have side effects.\n+\n+@item  AND\n+@itemx IOR\n+@itemx NOT\n+@itemx IF_THEN_ELSE\n+The basic @samp{MATCH_} expressions can be combined using these\n+logical operators, which have the semantics of the C operators\n+@samp{&&}, @samp{||}, @samp{!}, and @samp{@w{? :}} respectively.\n+@end table\n+\n+@item\n+An optional block of C code, which should execute \n+@samp{@w{return true}} if the predicate is found to match and\n+@samp{@w{return false}} if it does not.  It must not have any side\n+effects.  The predicate arguments, @var{op} and @var{mode}, are\n+available with those names.\n+\n+If a code block is present in a predicate definition, then the RTL\n+expression must evaluate to true @emph{and} the code block must\n+execute @samp{@w{return true}} for the predicate to allow the operand.\n+The RTL expression is evaluated first; do not re-check anything in the\n+code block that was checked in the RTL expression.\n+@end itemize\n+\n+The program @command{genrecog} scans @code{define_predicate} and\n+@code{define_special_predicate} expressions to determine which RTX\n+codes are possibly allowed.  You should always make this explicit in\n+the RTL predicate expression, using @code{MATCH_OPERAND} and\n+@code{MATCH_CODE}.\n+\n+Here is an example of a simple predicate definition, from the IA64\n+machine description:\n+\n+@smallexample\n+@group\n+;; @r{True if @var{op} is a @code{SYMBOL_REF} which refers to the sdata section.}\n+(define_predicate \"small_addr_symbolic_operand\"\n+  (and (match_code \"symbol_ref\")\n+       (match_test \"SYMBOL_REF_SMALL_ADDR_P (op)\")))\n+@end group\n+@end smallexample\n+\n+@noindent\n+And here is another, showing the use of the C block.\n+\n+@smallexample\n+@group\n+;; @r{True if @var{op} is a register operand that is (or could be) a GR reg.}\n+(define_predicate \"gr_register_operand\"\n+  (match_operand 0 \"register_operand\")\n+@{\n+  unsigned int regno;\n+  if (GET_CODE (op) == SUBREG)\n+    op = SUBREG_REG (op);\n+\n+  regno = REGNO (op);\n+  return (regno >= FIRST_PSEUDO_REGISTER || GENERAL_REGNO_P (regno));\n+@})\n+@end group\n+@end smallexample\n+\n+Predicates written with @code{define_predicate} automatically include\n+a test that @var{mode} is @code{VOIDmode}, or @var{op} has the same\n+mode as @var{mode}, or @var{op} is a @code{CONST_INT} or\n+@code{CONST_DOUBLE}.  They do @emph{not} check specifically for\n+integer @code{CONST_DOUBLE}, nor do they test that the value of either\n+kind of constant fits in the requested mode.  This is because\n+target-specific predicates that take constants usually have to do more\n+stringent value checks anyway.  If you need the exact same treatment\n+of @code{CONST_INT} or @code{CONST_DOUBLE} that the generic predicates\n+provide, use a @code{MATCH_OPERAND} subexpression to call\n+@code{const_int_operand}, @code{const_double_operand}, or\n+@code{immediate_operand}.\n+\n+Predicates written with @code{define_special_predicate} do not get any\n+automatic mode checks, and are treated as having special mode handling\n+by @command{genrecog}.\n+\n+The program @command{genpreds} is responsible for generating code to\n+test predicates.  It also writes a header file containing function\n+declarations for all machine-specific predicates.  It is not necessary\n+to declare these predicates in @file{@var{cpu}-protos.h}.\n @end ifset\n \n @c Most of this node appears by itself (in a different place) even\n@@ -692,8 +1000,11 @@ as follows, having the output control string start with a @samp{@@}:\n @cindex operand constraints\n @cindex constraints\n \n-Each @code{match_operand} in an instruction pattern can specify a\n-constraint for the type of operands allowed.\n+Each @code{match_operand} in an instruction pattern can specify\n+constraints for the operands allowed.  The constraints allow you to\n+fine-tune matching within the set of operands allowed by the\n+predicate.\n+\n @end ifset\n @ifclear INTERNALS\n @node Constraints"}, {"sha": "2910730879397d1eace17101e5857e464d6c9773", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 23, "deletions": 17, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e543e219eb1865d4230278c3db3d2bedd60b1de0/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e543e219eb1865d4230278c3db3d2bedd60b1de0/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=e543e219eb1865d4230278c3db3d2bedd60b1de0", "patch": "@@ -8539,24 +8539,9 @@ patterns.\n \n For each predicate function named in @code{PREDICATE_CODES}, a\n declaration will be generated in @file{insn-codes.h}.\n-@end defmac\n-\n-@defmac HAS_LONG_COND_BRANCH\n-Define this boolean macro to indicate whether or not your architecture\n-has conditional branches that can span all of memory.  It is used in\n-conjunction with an optimization that partitions hot and cold basic\n-blocks into separate sections of the executable.  If this macro is\n-set to false, gcc will convert any conditional branches that attempt\n-to cross between sections into unconditional branches or indirect jumps.\n-@end defmac\n \n-@defmac HAS_LONG_UNCOND_BRANCH\n-Define this boolean macro to indicate whether or not your architecture\n-has unconditional branches that can span all of memory.  It is used in\n-conjunction with an optimization that partitions hot and cold basic\n-blocks into separate sections of the executable.  If this macro is\n-set to false, gcc will convert any unconditional branches that attempt\n-to cross between sections into indirect jumps.\n+Use of this macro is deprecated; use @code{define_predicate} instead.\n+@xref{Defining Predicates}.\n @end defmac\n \n @defmac SPECIAL_MODE_PREDICATES\n@@ -8574,6 +8559,27 @@ for a byte extraction from @code{%ah} etc.).\n #define SPECIAL_MODE_PREDICATES \\\n   \"ext_register_operand\",\n @end smallexample\n+\n+Use of this macro is deprecated; use @code{define_special_predicate}\n+instead.  @xref{Defining Predicates}.\n+@end defmac\n+\n+@defmac HAS_LONG_COND_BRANCH\n+Define this boolean macro to indicate whether or not your architecture\n+has conditional branches that can span all of memory.  It is used in\n+conjunction with an optimization that partitions hot and cold basic\n+blocks into separate sections of the executable.  If this macro is\n+set to false, gcc will convert any conditional branches that attempt\n+to cross between sections into unconditional branches or indirect jumps.\n+@end defmac\n+\n+@defmac HAS_LONG_UNCOND_BRANCH\n+Define this boolean macro to indicate whether or not your architecture\n+has unconditional branches that can span all of memory.  It is used in\n+conjunction with an optimization that partitions hot and cold basic\n+blocks into separate sections of the executable.  If this macro is\n+set to false, gcc will convert any unconditional branches that attempt\n+to cross between sections into indirect jumps.\n @end defmac\n \n @defmac CASE_VECTOR_MODE"}, {"sha": "95db257bd0971d7084ee80b2ac3935ac1651d650", "filename": "gcc/dummy-conditions.c", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e543e219eb1865d4230278c3db3d2bedd60b1de0/gcc%2Fdummy-conditions.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e543e219eb1865d4230278c3db3d2bedd60b1de0/gcc%2Fdummy-conditions.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdummy-conditions.c?ref=e543e219eb1865d4230278c3db3d2bedd60b1de0", "patch": "@@ -1,5 +1,5 @@\n /* Support for calculating constant conditions.\n-   Copyright (C) 2002 Free Software Foundation, Inc.\n+   Copyright (C) 2002, 2004 Free Software Foundation, Inc.\n \n    This file is part of GCC.\n \n@@ -18,16 +18,22 @@\n    the Free Software Foundation, 59 Temple Place - Suite 330,\n    Boston, MA 02111-1307, USA.  */\n \n-#include \"bconfig.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"tm.h\"\n-#include \"gensupport.h\"\n+#include <stddef.h>  /* for size_t */\n \n /* MD generators that are run before insn-conditions.c exists should\n    link against this file instead.  Currently that is genconditions\n    and genconstants.  */\n \n+/* In order to avoid dragging in all the headers that are needed to\n+   declare things that gensupport.h uses, we duplicate the declaration\n+   of struct c_test here.  (In particular we do not want to have to\n+   include tm.h nor rtl.h in this file.)  */\n+struct c_test\n+{\n+  const char *expr;\n+  int value;\n+};\n+\n /* Empty conditions table to prevent link errors.  */\n const struct c_test insn_conditions[1] = { { 0, 0 } };\n const size_t n_insn_conditions = 0;"}, {"sha": "833d47f907be88b4dbf2769aec0f4e3448bfccda", "filename": "gcc/genpreds.c", "status": "modified", "additions": 448, "deletions": 27, "changes": 475, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e543e219eb1865d4230278c3db3d2bedd60b1de0/gcc%2Fgenpreds.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e543e219eb1865d4230278c3db3d2bedd60b1de0/gcc%2Fgenpreds.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenpreds.c?ref=e543e219eb1865d4230278c3db3d2bedd60b1de0", "patch": "@@ -1,8 +1,8 @@\n /* Generate from machine description:\n-   - some macros CODE_FOR_... giving the insn_code_number value\n-   for each of the defined standard insn names.\n-   Copyright (C) 1987, 1991, 1995, 1998,\n-   1999, 2000, 2001, 2003 Free Software Foundation, Inc.\n+   - prototype declarations for operand predicates (tm-preds.h)\n+   - function definitions of operand predicates, if defined new-style\n+     (insn-preds.c)\n+   Copyright (C) 2001, 2002, 2003, 2004 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -26,40 +26,461 @@ Boston, MA 02111-1307, USA.  */\n #include \"coretypes.h\"\n #include \"tm.h\"\n #include \"rtl.h\"\n+#include \"errors.h\"\n+#include \"gensupport.h\"\n+#include \"obstack.h\"\n \n+/* The new way to declare predicates is with (define_predicate) or\n+   (define_special_predicate) expressions in the machine description.\n+   This provides a function body as well as a name.  */\n static void\n-output_predicate_decls (void)\n+process_define_predicate (rtx defn)\n {\n-#ifdef PREDICATE_CODES\n-  static const struct {\n-    const char *const name;\n-    const RTX_CODE codes[NUM_RTX_CODE];\n-  } predicate[] = {\n-    PREDICATE_CODES\n-  };\n-  size_t i;\n-\n-  puts (\"#ifdef RTX_CODE\\n\");\n-  for (i = 0; i < ARRAY_SIZE (predicate); i++)\n-    printf (\"extern int %s (rtx, enum machine_mode);\\n\",\n-\t    predicate[i].name);\n-  puts (\"\\n#endif /* RTX_CODE */\\n\");\n-#endif\n+  struct pred_data *pred;\n+  if (XEXP (defn, 1) == 0)\n+    {\n+      error (\"%s: must give a predicate expression\", XSTR (defn, 0));\n+      return;\n+    }\n+\n+  pred = xcalloc (sizeof (struct pred_data), 1);\n+  pred->name    = XSTR (defn, 0);\n+  pred->exp     = XEXP (defn, 1);\n+  pred->c_block = XSTR (defn, 2);\n+\n+  if (GET_CODE (defn) == DEFINE_SPECIAL_PREDICATE)\n+    pred->special = true;\n+\n+  add_predicate (pred);\n+}\n+\n+/* Write tm-preds.h.  Unfortunately, it is impossible to forward-declare\n+   an enumeration in portable C, so we have to condition all these\n+   prototypes on HAVE_MACHINE_MODES.  */\n+static void\n+write_tm_preds_h (void)\n+{\n+  struct pred_data *p;\n+\n+  printf (\"\\\n+/* Generated automatically by the program '%s'\\n\\\n+   from the machine description file '%s'.  */\\n\\n\", progname, in_fname);\n+\n+  puts (\"\\\n+#ifndef GCC_TM_PREDS_H\\n\\\n+#define GCC_TM_PREDS_H\\n\\\n+\\n\\\n+#ifdef HAVE_MACHINE_MODES\");\n+\n+  FOR_ALL_PREDICATES (p)\n+    printf (\"extern int %s (rtx, enum machine_mode);\\n\", p->name);\n+\n+  puts (\"\\\n+#endif /* HAVE_MACHINE_MODES */\\n\\\n+#endif /* tm-preds.h */\");\n+}\n+\n+/* Given a predicate, if it has an embedded C block, write the block\n+   out as a static inline subroutine, and augment the RTL test with a\n+   match_test that calls that subroutine.  For instance,\n+\n+       (define_predicate \"basereg_operand\"\n+         (match_operand 0 \"register_operand\")\n+       {\n+         if (GET_CODE (op) == SUBREG)\n+           op = SUBREG_REG (op);\n+         return REG_POINTER (op);\n+       })\n+\n+   becomes\n+\n+       static inline int basereg_operand_1(rtx op, enum machine_mode mode)\n+       {\n+         if (GET_CODE (op) == SUBREG)\n+           op = SUBREG_REG (op);\n+         return REG_POINTER (op);\n+       }\n+\n+       (define_predicate \"basereg_operand\"\n+         (and (match_operand 0 \"register_operand\")\n+\t      (match_test \"basereg_operand_1 (op, mode)\")))\n+\n+   The only wart is that there's no way to insist on a { } string in\n+   an RTL template, so we have to handle \"\" strings. */\n+\n+   \n+static void\n+write_predicate_subfunction (struct pred_data *p)\n+{\n+  const char *match_test_str;\n+  rtx match_test_exp, and_exp;\n+\n+  if (p->c_block[0] == '\\0')\n+    return;\n+\n+  /* Construct the function-call expression.  */\n+  obstack_grow (rtl_obstack, p->name, strlen (p->name));\n+  obstack_grow (rtl_obstack, \"_1 (op, mode)\",\n+\t\tsizeof \"_1 (op, mode)\");\n+  match_test_str = obstack_finish (rtl_obstack);\n+\n+  /* Add the function-call expression to the complete expression to be\n+     evaluated.  */\n+  match_test_exp = rtx_alloc (MATCH_TEST);\n+  XSTR (match_test_exp, 0) = match_test_str;\n+\n+  and_exp = rtx_alloc (AND);\n+  XEXP (and_exp, 0) = p->exp;\n+  XEXP (and_exp, 1) = match_test_exp;\n+\n+  p->exp = and_exp;\n+\n+  printf (\"static inline int\\n\"\n+\t  \"%s_1 (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\\n\",\n+\t  p->name);\n+  if (p->c_block[0] == '{')\n+    fputs (p->c_block, stdout);\n+  else\n+    printf (\"{\\n  %s\\n}\", p->c_block);\n+  fputs (\"\\n\\n\", stdout);\n+}\n+\n+/* Given an RTL expression EXP, find all subexpressions which we may\n+   assume to perform mode tests.  Normal MATCH_OPERAND does;\n+   MATCH_CODE does if and only if it accepts CONST_INT or\n+   CONST_DOUBLE; and we have to assume that MATCH_TEST does not.\n+   These combine in almost-boolean fashion - the only exception is\n+   that (not X) must be assumed not to perform a mode test, whether or\n+   not X does.\n+\n+   The mark is the RTL /v flag, which is true for subexpressions which\n+   do *not* perform mode tests.\n+*/\n+#define NO_MODE_TEST(EXP) RTX_FLAG (EXP, volatil)\n+static void\n+mark_mode_tests (rtx exp)\n+{\n+  switch (GET_CODE (exp))\n+    {\n+    case MATCH_OPERAND:\n+      {\n+\tstruct pred_data *p = lookup_predicate (XSTR (exp, 1));\n+\tif (!p)\n+\t  error (\"reference to undefined predicate '%s'\", XSTR (exp, 1));\n+\telse if (p->special)\n+\t  NO_MODE_TEST (exp) = 1;\n+      }\n+      break;\n+\n+    case MATCH_CODE:\n+      if (!strstr (XSTR (exp, 0), \"const_int\")\n+\t  && !strstr (XSTR (exp, 0), \"const_double\"))\n+\tNO_MODE_TEST (exp) = 1;\n+      break;\n+\n+    case MATCH_TEST:\n+    case NOT:\n+      NO_MODE_TEST (exp) = 1;\n+      break;\n+\n+    case AND:\n+      mark_mode_tests (XEXP (exp, 0));\n+      mark_mode_tests (XEXP (exp, 1));\n+\n+      NO_MODE_TEST (exp) = (NO_MODE_TEST (XEXP (exp, 0))\n+\t\t\t    && NO_MODE_TEST (XEXP (exp, 1)));\n+      break;\n+      \n+    case IOR:\n+      mark_mode_tests (XEXP (exp, 0));\n+      mark_mode_tests (XEXP (exp, 1));\n+\n+      NO_MODE_TEST (exp) = (NO_MODE_TEST (XEXP (exp, 0))\n+\t\t\t    || NO_MODE_TEST (XEXP (exp, 1)));\n+      break;\n+\n+    case IF_THEN_ELSE:\n+      /* A ? B : C does a mode test if (one of A and B) does a mode\n+\t test, and C does too.  */\n+      mark_mode_tests (XEXP (exp, 0));\n+      mark_mode_tests (XEXP (exp, 1));\n+      mark_mode_tests (XEXP (exp, 2));\n+\n+      NO_MODE_TEST (exp) = ((NO_MODE_TEST (XEXP (exp, 0))\n+\t\t\t     && NO_MODE_TEST (XEXP (exp, 1)))\n+\t\t\t    || NO_MODE_TEST (XEXP (exp, 2)));\n+      break;\n+\n+    default:\n+      error (\"'%s' cannot be used in a define_predicate expression\",\n+\t     GET_RTX_NAME (GET_CODE (exp)));\n+    }\n+}\n+\n+/* Given a predicate, work out where in its RTL expression to add\n+   tests for proper modes.  Special predicates do not get any such\n+   tests.  We try to avoid adding tests when we don't have to; in\n+   particular, other normal predicates can be counted on to do it for\n+   us.  */\n+\n+static void\n+add_mode_tests (struct pred_data *p)\n+{\n+  rtx match_test_exp, and_exp;\n+  rtx *pos;\n+\n+  /* Don't touch special predicates.  */\n+  if (p->special)\n+    return;\n+\n+  mark_mode_tests (p->exp);\n+\n+  /* If the whole expression already tests the mode, we're done.  */\n+  if (!NO_MODE_TEST (p->exp))\n+    return;\n+\n+  match_test_exp = rtx_alloc (MATCH_TEST);\n+  XSTR (match_test_exp, 0) = \"mode == VOIDmode || GET_MODE (op) == mode\";\n+  and_exp = rtx_alloc (AND);\n+  XEXP (and_exp, 1) = match_test_exp;\n+\n+  /* It is always correct to rewrite p->exp as\n+\n+        (and (...) (match_test \"mode == VOIDmode || GET_MODE (op) == mode\"))\n+\n+     but there are a couple forms where we can do better.  If the\n+     top-level pattern is an IOR, and one of the two branches does test\n+     the mode, we can wrap just the branch that doesn't.  Likewise, if\n+     we have an IF_THEN_ELSE, and one side of it tests the mode, we can\n+     wrap just the side that doesn't.  And, of course, we can repeat this\n+     descent as many times as it works.  */\n+\n+  pos = &p->exp;\n+  for (;;)\n+    {\n+      rtx subexp = *pos;\n+      if (GET_CODE (subexp) == IOR)\n+\t{\n+\t  if (NO_MODE_TEST (XEXP (subexp, 0))\n+\t      && NO_MODE_TEST (XEXP (subexp, 1)))\n+\t    break;\n+\t  else if (NO_MODE_TEST (XEXP (subexp, 0)))\n+\t    pos = &XEXP (subexp, 0);\n+\t  else if (NO_MODE_TEST (XEXP (subexp, 1)))\n+\t    pos = &XEXP (subexp, 1);\n+\t  else\n+\t    abort ();\n+\t}\n+      else if (GET_CODE (subexp) == IF_THEN_ELSE)\n+\t{\n+\t  if (NO_MODE_TEST (XEXP (subexp, 0))\n+\t      && NO_MODE_TEST (XEXP (subexp, 1))\n+\t      && NO_MODE_TEST (XEXP (subexp, 2)))\n+\t    break;\n+\t  else if (NO_MODE_TEST (XEXP (subexp, 0))\n+\t\t   && NO_MODE_TEST (XEXP (subexp, 1)))\n+\t    /* Must put it on the dependent clause, not the controlling\n+\t       expression, or we change the meaning of the test. */\n+\t    pos = &XEXP (subexp, 1);\n+\t  else if (NO_MODE_TEST (XEXP (subexp, 2)))\n+\t    pos = &XEXP (subexp, 2);\n+\t  else\n+\t    abort ();\n+\t}\n+      else\n+\tbreak;\n+    }\n+\n+  XEXP (and_exp, 0) = *pos;\n+  *pos = and_exp;\n+}\n+\n+\n+/* CODES is a list of RTX codes.  Write out an expression which\n+   determines whether the operand has one of those codes.  */\n+static void\n+write_match_code (const char *codes)\n+{\n+  const char *code;\n+\n+  while ((code = scan_comma_elt (&codes)) != 0)\n+    {\n+      fputs (\"GET_CODE (op) == \", stdout);\n+      while (code < codes)\n+\t{\n+\t  putchar (TOUPPER (*code));\n+\t  code++;\n+\t}\n+      \n+      if (*codes == ',')\n+\tfputs (\" || \", stdout);\n+    }\n+}\n+\n+/* EXP is an RTL (sub)expression for a predicate.  Recursively\n+   descend the expression and write out an equivalent C expression.  */\n+static void\n+write_predicate_expr (const char *name, rtx exp)\n+{\n+  switch (GET_CODE (exp))\n+    {\n+    case AND:\n+      putchar ('(');\n+      write_predicate_expr (name, XEXP (exp, 0));\n+      fputs (\") && (\", stdout);\n+      write_predicate_expr (name, XEXP (exp, 1));\n+      putchar (')');\n+      break;\n+  \n+    case IOR:\n+      putchar ('(');\n+      write_predicate_expr (name, XEXP (exp, 0));\n+      fputs (\") || (\", stdout);\n+      write_predicate_expr (name, XEXP (exp, 1));\n+      putchar (')');\n+      break;\n+\n+    case NOT:\n+      fputs (\"!(\", stdout);\n+      write_predicate_expr (name, XEXP (exp, 0));\n+      putchar (')');\n+      break;\n+\n+    case IF_THEN_ELSE:\n+      putchar ('(');\n+      write_predicate_expr (name, XEXP (exp, 0));\n+      fputs (\") ? (\", stdout);\n+      write_predicate_expr (name, XEXP (exp, 1));\n+      fputs (\") : (\", stdout);\n+      write_predicate_expr (name, XEXP (exp, 2));\n+      putchar (')');\n+      break;\n+\n+    case MATCH_OPERAND:\n+      printf (\"%s (op, mode)\", XSTR (exp, 1));\n+      break;\n+\n+    case MATCH_CODE:\n+      write_match_code (XSTR (exp, 0));\n+      break;\n+\n+    case MATCH_TEST:\n+      fputs (XSTR (exp, 0), stdout);\n+      break;\n+\n+    default:\n+      error (\"%s: cannot use '%s' in a predicate expression\",\n+\t     name, GET_RTX_NAME (GET_CODE (exp)));\n+      putchar ('0');\n+    }\n+}\n+\n+/* Given a predicate, write out a complete C function to compute it.  */\n+static void\n+write_one_predicate_function (struct pred_data *p)\n+{\n+  if (!p->exp)\n+    return;\n+\n+  write_predicate_subfunction (p);\n+  add_mode_tests (p);\n+\n+  /* A normal predicate can legitimately not look at enum machine_mode\n+     if it accepts only CONST_INTs and/or CONST_DOUBLEs.  */\n+  printf (\"int\\n%s (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\\n\"\n+\t  \"{\\n  return \",\n+\t  p->name);\n+  write_predicate_expr (p->name, p->exp);\n+  fputs (\";\\n}\\n\\n\", stdout);\n }\n \n+/* Write insn-preds.c.  \n+   N.B. the list of headers to include was copied from genrecog; it\n+   may not be ideal.\n+\n+   FUTURE: Write #line markers referring back to the machine\n+   description.  (Can't practically do this now since we don't know\n+   the line number of the C block - just the line number of the enclosing\n+   expression.)  */\n+static void\n+write_insn_preds_c (void)\n+{\n+  struct pred_data *p;\n+\n+  printf (\"\\\n+/* Generated automatically by the program '%s'\\n\\\n+   from the machine description file '%s'.  */\\n\\n\", progname, in_fname);\n+\n+  puts (\"\\\n+#include \\\"config.h\\\"\\n\\\n+#include \\\"system.h\\\"\\n\\\n+#include \\\"coretypes.h\\\"\\n\\\n+#include \\\"tm.h\\\"\\n\\\n+#include \\\"rtl.h\\\"\\n\\\n+#include \\\"tm_p.h\\\"\\n\\\n+#include \\\"function.h\\\"\\n\\\n+#include \\\"insn-config.h\\\"\\n\\\n+#include \\\"recog.h\\\"\\n\\\n+#include \\\"real.h\\\"\\n\\\n+#include \\\"output.h\\\"\\n\\\n+#include \\\"flags.h\\\"\\n\\\n+#include \\\"hard-reg-set.h\\\"\\n\\\n+#include \\\"resource.h\\\"\\n\\\n+#include \\\"toplev.h\\\"\\n\\\n+#include \\\"reload.h\\\"\\n\");\n+\n+  FOR_ALL_PREDICATES (p)\n+    write_one_predicate_function (p);\n+}\n+\n+/* Argument parsing.  */\n+static bool gen_header;\n+static bool\n+parse_option (const char *opt)\n+{\n+  if (!strcmp (opt, \"-h\"))\n+    {\n+      gen_header = true;\n+      return 1;\n+    }\n+  else\n+    return 0;\n+}\n+\n+/* Master control.  */\n int\n-main (void)\n+main (int argc, char **argv)\n {\n-  puts (\"/* Generated automatically by the program `genpreds'.  */\\n\");\n-  puts (\"#ifndef GCC_TM_PREDS_H\");\n-  puts (\"#define GCC_TM_PREDS_H\\n\");\n+  rtx defn;\n+  int pattern_lineno, next_insn_code = 0;\n \n-  output_predicate_decls ();\n+  progname = argv[0];\n+  if (argc <= 1)\n+    fatal (\"no input file name\");\n+  if (init_md_reader_args_cb (argc, argv, parse_option) != SUCCESS_EXIT_CODE)\n+    return FATAL_EXIT_CODE;\n+\n+  while ((defn = read_md_rtx (&pattern_lineno, &next_insn_code)) != 0)\n+    {\n+      if (GET_CODE (defn) == DEFINE_PREDICATE\n+\t  || GET_CODE (defn) == DEFINE_SPECIAL_PREDICATE)\n+\tprocess_define_predicate (defn);\n+    }\n \n-  puts (\"#endif /* GCC_TM_PREDS_H */\");\n+  if (gen_header)\n+    write_tm_preds_h ();\n+  else\n+    write_insn_preds_c ();\n \n-  if (ferror (stdout) || fflush (stdout) || fclose (stdout))\n+  if (have_error || ferror (stdout) || fflush (stdout) || fclose (stdout))\n     return FATAL_EXIT_CODE;\n \n   return SUCCESS_EXIT_CODE;\n }\n+\n+/* Dummy for debugging purposes.  */\n+const char *\n+get_insn_name (int code ATTRIBUTE_UNUSED)\n+{\n+  return 0;\n+}"}, {"sha": "f3c052c4fbef22a78a17d7ae4e6413c57111d0c8", "filename": "gcc/genrecog.c", "status": "modified", "additions": 285, "deletions": 201, "changes": 486, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e543e219eb1865d4230278c3db3d2bedd60b1de0/gcc%2Fgenrecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e543e219eb1865d4230278c3db3d2bedd60b1de0/gcc%2Fgenrecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenrecog.c?ref=e543e219eb1865d4230278c3db3d2bedd60b1de0", "patch": "@@ -58,7 +58,6 @@\n #include \"errors.h\"\n #include \"gensupport.h\"\n \n-\n #define OUTPUT_LABEL(INDENT_STRING, LABEL_NUMBER) \\\n   printf(\"%sL%d: ATTRIBUTE_UNUSED_LABEL\\n\", (INDENT_STRING), (LABEL_NUMBER))\n \n@@ -103,7 +102,8 @@ struct decision_test\n     struct\n     {\n       const char *name;\t\t/* Predicate to call.  */\n-      int index;\t\t/* Index into `preds' or -1.  */\n+      const struct pred_data *data;\n+                                /* Optimization hints for this predicate.  */\n       enum machine_mode mode;\t/* Machine mode for node.  */\n     } pred;\n \n@@ -162,11 +162,6 @@ static int next_number;\n \n static int next_insn_code;\n \n-/* Similar, but counts all expressions in the MD file; used for\n-   error messages.  */\n-\n-static int next_index;\n-\n /* Record the highest depth we ever have so we know how many variables to\n    allocate in each subroutine we make.  */\n \n@@ -178,55 +173,213 @@ static int pattern_lineno;\n /* Count of errors.  */\n static int error_count;\n \f\n-/* This table contains a list of the rtl codes that can possibly match a\n-   predicate defined in recog.c.  The function `maybe_both_true' uses it to\n-   deduce that there are no expressions that can be matches by certain pairs\n-   of tree nodes.  Also, if a predicate can match only one code, we can\n-   hardwire that code into the node testing the predicate.  */\n+/* Predicate handling. \n+\n+   We construct from the machine description a table mapping each\n+   predicate to a list of the rtl codes it can possibly match.  The\n+   function 'maybe_both_true' uses it to deduce that there are no\n+   expressions that can be matches by certain pairs of tree nodes.\n+   Also, if a predicate can match only one code, we can hardwire that\n+   code into the node testing the predicate.\n+\n+   Some predicates are flagged as special.  validate_pattern will not\n+   warn about modeless match_operand expressions if they have a\n+   special predicate.  Predicates that allow only constants are also\n+   treated as special, for this purpose.\n+\n+   validate_pattern will warn about predicates that allow non-lvalues\n+   when they appear in destination operands.\n+\n+   Calculating the set of rtx codes that can possibly be accepted by a\n+   predicate expression EXP requires a three-state logic: any given\n+   subexpression may definitively accept a code C (Y), definitively\n+   reject a code C (N), or may have an indeterminate effect (I).  N\n+   and I is N; Y or I is Y; Y and I, N or I are both I.  Here are full\n+   truth tables.\n+\n+     a b  a&b  a|b\n+     Y Y   Y    Y\n+     N Y   N    Y\n+     N N   N    N\n+     I Y   I    Y\n+     I N   N    I\n+     I I   I    I\n+\n+   We represent Y with 1, N with 0, I with 2.  If any code is left in\n+   an I state by the complete expression, we must assume that that\n+   code can be accepted.  */\n+\n+#define N 0\n+#define Y 1\n+#define I 2\n+\n+#define TRISTATE_AND(a,b)\t\t\t\\\n+  ((a) == I ? ((b) == N ? N : I) :\t\t\\\n+   (b) == I ? ((a) == N ? N : I) :\t\t\\\n+   (a) && (b))\n+\n+#define TRISTATE_OR(a,b)\t\t\t\\\n+  ((a) == I ? ((b) == Y ? Y : I) :\t\t\\\n+   (b) == I ? ((a) == Y ? Y : I) :\t\t\\\n+   (a) || (b))\n+\n+#define TRISTATE_NOT(a)\t\t\t\t\\\n+  ((a) == I ? I : !(a))\n+\n+/* Recursively calculate the set of rtx codes accepted by the\n+   predicate expression EXP, writing the result to CODES.  */\n+static void\n+compute_predicate_codes (rtx exp, char codes[NUM_RTX_CODE])\n+{\n+  char op0_codes[NUM_RTX_CODE];\n+  char op1_codes[NUM_RTX_CODE];\n+  char op2_codes[NUM_RTX_CODE];\n+  int i;\n+\n+  switch (GET_CODE (exp))\n+    {\n+    case AND:\n+      compute_predicate_codes (XEXP (exp, 0), op0_codes);\n+      compute_predicate_codes (XEXP (exp, 1), op1_codes);\n+      for (i = 0; i < NUM_RTX_CODE; i++)\n+\tcodes[i] = TRISTATE_AND (op0_codes[i], op1_codes[i]);\n+      break;\n+\n+    case IOR:\n+      compute_predicate_codes (XEXP (exp, 0), op0_codes);\n+      compute_predicate_codes (XEXP (exp, 1), op1_codes);\n+      for (i = 0; i < NUM_RTX_CODE; i++)\n+\tcodes[i] = TRISTATE_OR (op0_codes[i], op1_codes[i]);\n+      break;\n+    case NOT:\n+      compute_predicate_codes (XEXP (exp, 0), op0_codes);\n+      for (i = 0; i < NUM_RTX_CODE; i++)\n+\tcodes[i] = TRISTATE_NOT (codes[i]);\n+      break;\n+\n+    case IF_THEN_ELSE:\n+      /* a ? b : c  accepts the same codes as (a & b) | (!a & c).  */ \n+      compute_predicate_codes (XEXP (exp, 0), op0_codes);\n+      compute_predicate_codes (XEXP (exp, 1), op1_codes);\n+      compute_predicate_codes (XEXP (exp, 2), op2_codes);\n+      for (i = 0; i < NUM_RTX_CODE; i++)\n+\tcodes[i] = TRISTATE_OR (TRISTATE_AND (op0_codes[i], op1_codes[i]),\n+\t\t\t\tTRISTATE_AND (TRISTATE_NOT (op0_codes[i]),\n+\t\t\t\t\t      op2_codes[i]));\n+      break;\n+\n+    case MATCH_CODE:\n+      /* MATCH_CODE allows a specified list of codes.  */\n+      memset (codes, N, NUM_RTX_CODE);\n+      {\n+\tconst char *next_code = XSTR (exp, 0);\n+\tconst char *code;\n \n-static const struct pred_table\n+\tif (*next_code == '\\0')\n+\t  {\n+\t    message_with_line (pattern_lineno, \"empty match_code expression\");\n+\t    error_count++;\n+\t    break;\n+\t  }\n+\n+\twhile ((code = scan_comma_elt (&next_code)) != 0)\n+\t  {\n+\t    size_t n = next_code - code;\n+\t    \n+\t    for (i = 0; i < NUM_RTX_CODE; i++)\n+\t      if (!strncmp (code, GET_RTX_NAME (i), n)\n+\t\t  && GET_RTX_NAME (i)[n] == '\\0')\n+\t\t{\n+\t\t  codes[i] = Y;\n+\t\t  break;\n+\t\t}\n+\t  }\n+      }\n+      break;\n+\n+    case MATCH_OPERAND:\n+      /* MATCH_OPERAND disallows the set of codes that the named predicate\n+\t disallows, and is indeterminate for the codes that it does allow.  */\n+      {\n+\tstruct pred_data *p = lookup_predicate (XSTR (exp, 1));\n+\tif (!p)\n+\t  {\n+\t    message_with_line (pattern_lineno,\n+\t\t\t       \"reference to unknown predicate '%s'\",\n+\t\t\t       XSTR (exp, 1));\n+\t    error_count++;\n+\t    break;\n+\t  }\n+\tfor (i = 0; i < NUM_RTX_CODE; i++)\n+\t  codes[i] = p->codes[i] ? I : N;\n+      }\n+      break;\n+\n+\n+    case MATCH_TEST:\n+      /* (match_test WHATEVER) is completely indeterminate.  */\n+      memset (codes, I, NUM_RTX_CODE);\n+      break;\n+\n+    default:\n+      message_with_line (pattern_lineno,\n+\t \"'%s' cannot be used in a define_predicate expression\",\n+\t GET_RTX_NAME (GET_CODE (exp)));\n+      error_count++;\n+      memset (codes, I, NUM_RTX_CODE);\n+      break;\n+    }\n+}\n+\n+#undef TRISTATE_OR\n+#undef TRISTATE_AND\n+#undef TRISTATE_NOT\n+\n+/* Process a define_predicate expression: compute the set of predicates\n+   that can be matched, and record this as a known predicate.  */\n+static void\n+process_define_predicate (rtx desc)\n {\n-  const char *const name;\n-  const RTX_CODE codes[NUM_RTX_CODE];\n-} preds[] = {\n-  {\"general_operand\", {CONST_INT, CONST_DOUBLE, CONST, SYMBOL_REF,\n-\t\t       LABEL_REF, SUBREG, REG, MEM }},\n-#ifdef PREDICATE_CODES\n-  PREDICATE_CODES\n-#endif\n-  {\"address_operand\", {CONST_INT, CONST_DOUBLE, CONST, SYMBOL_REF,\n-\t\t       LABEL_REF, SUBREG, REG, MEM,\n-\t\t       PLUS, MINUS, MULT}},\n-  {\"register_operand\", {SUBREG, REG}},\n-  {\"pmode_register_operand\", {SUBREG, REG}},\n-  {\"scratch_operand\", {SCRATCH, REG}},\n-  {\"immediate_operand\", {CONST_INT, CONST_DOUBLE, CONST, SYMBOL_REF,\n-\t\t\t LABEL_REF}},\n-  {\"const_int_operand\", {CONST_INT}},\n-  {\"const_double_operand\", {CONST_INT, CONST_DOUBLE}},\n-  {\"nonimmediate_operand\", {SUBREG, REG, MEM}},\n-  {\"nonmemory_operand\", {CONST_INT, CONST_DOUBLE, CONST, SYMBOL_REF,\n-\t\t\t LABEL_REF, SUBREG, REG}},\n-  {\"push_operand\", {MEM}},\n-  {\"pop_operand\", {MEM}},\n-  {\"memory_operand\", {SUBREG, MEM}},\n-  {\"indirect_operand\", {SUBREG, MEM}},\n-  {\"comparison_operator\", {EQ, NE, LE, LT, GE, GT, LEU, LTU, GEU, GTU,\n-\t\t\t   UNORDERED, ORDERED, UNEQ, UNGE, UNGT, UNLE,\n-\t\t\t   UNLT, LTGT}}\n-};\n+  struct pred_data *pred = xcalloc (sizeof (struct pred_data), 1);\n+  char codes[NUM_RTX_CODE];\n+  bool seen_one = false;\n+  int i;\n \n-#define NUM_KNOWN_PREDS ARRAY_SIZE (preds)\n+  pred->name = XSTR (desc, 0);\n+  if (GET_CODE (desc) == DEFINE_SPECIAL_PREDICATE)\n+    pred->special = 1;\n \n-static const char *const special_mode_pred_table[] = {\n-#ifdef SPECIAL_MODE_PREDICATES\n-  SPECIAL_MODE_PREDICATES\n-#endif\n-  \"pmode_register_operand\"\n-};\n+  compute_predicate_codes (XEXP (desc, 1), codes);\n \n-#define NUM_SPECIAL_MODE_PREDS ARRAY_SIZE (special_mode_pred_table)\n+  for (i = 0; i < NUM_RTX_CODE; i++)\n+    if (codes[i] != N)\n+      {\n+\tpred->codes[i] = true;\n+\tif (GET_RTX_CLASS (i) != RTX_CONST_OBJ)\n+\t  pred->allows_non_const = true;\n+\tif (i != REG\n+\t    && i != SUBREG\n+\t    && i != MEM\n+\t    && i != CONCAT\n+\t    && i != PARALLEL\n+\t    && i != STRICT_LOW_PART)\n+\t  pred->allows_non_lvalue = true;\n+\n+\tif (seen_one)\n+\t  pred->singleton = UNKNOWN;\n+\telse\n+\t  {\n+\t    pred->singleton = i;\n+\t    seen_one = true;\n+\t  }\n+      }\n+  add_predicate (pred);\n+}\n+#undef I\n+#undef N\n+#undef Y\n \n+\f\n static struct decision *new_decision\n   (const char *, struct decision_head *);\n static struct decision_test *new_decision_test\n@@ -485,8 +638,7 @@ validate_pattern (rtx pattern, rtx insn, rtx set, int set_code)\n     case MATCH_OPERATOR:\n       {\n \tconst char *pred_name = XSTR (pattern, 1);\n-\tint allows_non_lvalue = 1, allows_non_const = 1;\n-\tint special_mode_pred = 0;\n+\tconst struct pred_data *pred;\n \tconst char *c_test;\n \n \tif (GET_CODE (insn) == DEFINE_INSN)\n@@ -496,53 +648,14 @@ validate_pattern (rtx pattern, rtx insn, rtx set, int set_code)\n \n \tif (pred_name[0] != 0)\n \t  {\n-\t    for (i = 0; i < NUM_KNOWN_PREDS; i++)\n-\t      if (! strcmp (preds[i].name, pred_name))\n-\t\tbreak;\n-\n-\t    if (i < NUM_KNOWN_PREDS)\n-\t      {\n-\t\tint j;\n-\n-\t\tallows_non_lvalue = allows_non_const = 0;\n-\t\tfor (j = 0; preds[i].codes[j] != 0; j++)\n-\t\t  {\n-\t\t    RTX_CODE c = preds[i].codes[j];\n-\t\t    if (c != LABEL_REF\n-\t\t\t&& c != SYMBOL_REF\n-\t\t\t&& c != CONST_INT\n-\t\t\t&& c != CONST_DOUBLE\n-\t\t\t&& c != CONST\n-\t\t\t&& c != HIGH)\n-\t\t      allows_non_const = 1;\n-\n-\t\t    if (c != REG\n-\t\t\t&& c != SUBREG\n-\t\t\t&& c != MEM\n-\t\t\t&& c != CONCAT\n-\t\t\t&& c != PARALLEL\n-\t\t\t&& c != STRICT_LOW_PART)\n-\t\t      allows_non_lvalue = 1;\n-\t\t  }\n-\t      }\n-\t    else\n-\t      {\n-#ifdef PREDICATE_CODES\n-\t\t/* If the port has a list of the predicates it uses but\n-\t\t   omits one, warn.  */\n-\t\tmessage_with_line (pattern_lineno,\n-\t\t\t\t   \"warning: `%s' not in PREDICATE_CODES\",\n-\t\t\t\t   pred_name);\n-#endif\n-\t      }\n-\n-\t    for (i = 0; i < NUM_SPECIAL_MODE_PREDS; ++i)\n-\t      if (strcmp (pred_name, special_mode_pred_table[i]) == 0)\n-\t\t{\n-\t\t  special_mode_pred = 1;\n-\t\t  break;\n-\t\t}\n+\t    pred = lookup_predicate (pred_name);\n+\t    if (!pred)\n+\t      message_with_line (pattern_lineno,\n+\t\t\t\t \"warning: unknown predicate '%s'\",\n+\t\t\t\t pred_name);\n \t  }\n+\telse\n+\t  pred = 0;\n \n \tif (code == MATCH_OPERAND)\n \t  {\n@@ -595,39 +708,33 @@ validate_pattern (rtx pattern, rtx insn, rtx set, int set_code)\n \t/* Allowing non-lvalues in destinations -- particularly CONST_INT --\n \t   while not likely to occur at runtime, results in less efficient\n \t   code from insn-recog.c.  */\n-\tif (set\n-\t    && pred_name[0] != '\\0'\n-\t    && allows_non_lvalue)\n-\t  {\n-\t    message_with_line (pattern_lineno,\n-\t\t\t\"warning: destination operand %d allows non-lvalue\",\n-\t\t\tXINT (pattern, 0));\n-\t  }\n+\tif (set && pred && pred->allows_non_lvalue)\n+\t  message_with_line (pattern_lineno,\n+\t\t\t     \"warning: destination operand %d \"\n+\t\t\t     \"allows non-lvalue\",\n+\t\t\t     XINT (pattern, 0));\n \n-\t/* A modeless MATCH_OPERAND can be handy when we can\n-\t   check for multiple modes in the c_test.  In most other cases,\n-\t   it is a mistake.  Only DEFINE_INSN is eligible, since SPLIT\n-\t   and PEEP2 can FAIL within the output pattern.  Exclude\n-\t   address_operand, since its mode is related to the mode of\n-\t   the memory not the operand.  Exclude the SET_DEST of a call\n-\t   instruction, as that is a common idiom.  */\n+\t/* A modeless MATCH_OPERAND can be handy when we can check for\n+\t   multiple modes in the c_test.  In most other cases, it is a\n+\t   mistake.  Only DEFINE_INSN is eligible, since SPLIT and\n+\t   PEEP2 can FAIL within the output pattern.  Exclude special\n+\t   predicates, which check the mode themselves.  Also exclude\n+\t   predicates that allow only constants.  Exclude the SET_DEST\n+\t   of a call instruction, as that is a common idiom.  */\n \n \tif (GET_MODE (pattern) == VOIDmode\n \t    && code == MATCH_OPERAND\n \t    && GET_CODE (insn) == DEFINE_INSN\n-\t    && allows_non_const\n-\t    && ! special_mode_pred\n-\t    && pred_name[0] != '\\0'\n-\t    && strcmp (pred_name, \"address_operand\") != 0\n+\t    && pred\n+\t    && !pred->special\n+\t    && pred->allows_non_const\n \t    && strstr (c_test, \"operands\") == NULL\n \t    && ! (set\n \t\t  && GET_CODE (set) == SET\n \t\t  && GET_CODE (SET_SRC (set)) == CALL))\n-\t  {\n-\t    message_with_line (pattern_lineno,\n-\t\t\t       \"warning: operand %d missing mode?\",\n-\t\t\t       XINT (pattern, 0));\n-\t  }\n+\t  message_with_line (pattern_lineno,\n+\t\t\t     \"warning: operand %d missing mode?\",\n+\t\t\t     XINT (pattern, 0));\n \treturn;\n       }\n \n@@ -829,9 +936,9 @@ add_to_sequence (rtx pattern, struct decision_head *last, const char *position,\n     case MATCH_SCRATCH:\n     case MATCH_OPERATOR:\n       {\n-\tconst char *pred_name;\n \tRTX_CODE was_code = code;\n-\tint allows_const_int = 1;\n+\tconst char *pred_name;\n+\tbool allows_const_int = true;\n \n \tif (code == MATCH_SCRATCH)\n \t  {\n@@ -849,44 +956,26 @@ add_to_sequence (rtx pattern, struct decision_head *last, const char *position,\n \n \tif (pred_name[0] != 0)\n \t  {\n+\t    const struct pred_data *pred;\n+\n \t    test = new_decision_test (DT_pred, &place);\n \t    test->u.pred.name = pred_name;\n \t    test->u.pred.mode = mode;\n \n-\t    /* See if we know about this predicate and save its number.\n-\t       If we do, and it only accepts one code, note that fact.\n-\n-\t       If we know that the predicate does not allow CONST_INT,\n-\t       we know that the only way the predicate can match is if\n-\t       the modes match (here we use the kludge of relying on the\n-\t       fact that \"address_operand\" accepts CONST_INT; otherwise,\n-\t       it would have to be a special case), so we can test the\n-\t       mode (but we need not).  This fact should considerably\n-\t       simplify the generated code.  */\n-\n-\t    for (i = 0; i < NUM_KNOWN_PREDS; i++)\n-\t      if (! strcmp (preds[i].name, pred_name))\n-\t\tbreak;\n+\t    /* See if we know about this predicate.\n+\t       If we do, remember it for use below.\n \n-\t    if (i < NUM_KNOWN_PREDS)\n+\t       We can optimize the generated code a little if either\n+\t       (a) the predicate only accepts one code, or (b) the\n+\t       predicate does not allow CONST_INT, in which case it\n+\t       can match only if the modes match.  */\n+\t    pred = lookup_predicate (pred_name);\n+\t    if (pred)\n \t      {\n-\t\tint j;\n-\n-\t\ttest->u.pred.index = i;\n-\n-\t\tif (preds[i].codes[1] == 0 && code == UNKNOWN)\n-\t\t  code = preds[i].codes[0];\n-\n-\t\tallows_const_int = 0;\n-\t\tfor (j = 0; preds[i].codes[j] != 0; j++)\n-\t\t  if (preds[i].codes[j] == CONST_INT)\n-\t\t    {\n-\t\t      allows_const_int = 1;\n-\t\t      break;\n-\t\t    }\n+\t\ttest->u.pred.data = pred;\n+\t\tallows_const_int = pred->codes[CONST_INT];\n+\t\tcode = pred->singleton;\n \t      }\n-\t    else\n-\t      test->u.pred.index = -1;\n \t  }\n \n \t/* Can't enforce a mode if we allow const_int.  */\n@@ -1109,39 +1198,28 @@ maybe_both_true_2 (struct decision_test *d1, struct decision_test *d2)\n \t     separate DT_mode that will make maybe_both_true_1 return 0.  */\n \t}\n \n-      if (d1->u.pred.index >= 0)\n+      if (d1->u.pred.data)\n \t{\n \t  /* If D2 tests a code, see if it is in the list of valid\n \t     codes for D1's predicate.  */\n \t  if (d2->type == DT_code)\n \t    {\n-\t      const RTX_CODE *c = &preds[d1->u.pred.index].codes[0];\n-\t      while (*c != 0)\n-\t\t{\n-\t\t  if (*c == d2->u.code)\n-\t\t    break;\n-\t\t  ++c;\n-\t\t}\n-\t      if (*c == 0)\n+\t      if (!d1->u.pred.data->codes[d2->u.code])\n \t\treturn 0;\n \t    }\n \n \t  /* Otherwise see if the predicates have any codes in common.  */\n-\t  else if (d2->type == DT_pred && d2->u.pred.index >= 0)\n+\t  else if (d2->type == DT_pred && d2->u.pred.data)\n \t    {\n-\t      const RTX_CODE *c1 = &preds[d1->u.pred.index].codes[0];\n-\t      int common = 0;\n+\t      bool common = false;\n+\t      enum rtx_code c;\n \n-\t      while (*c1 != 0 && !common)\n-\t\t{\n-\t\t  const RTX_CODE *c2 = &preds[d2->u.pred.index].codes[0];\n-\t\t  while (*c2 != 0 && !common)\n-\t\t    {\n-\t\t      common = (*c1 == *c2);\n-\t\t      ++c2;\n-\t\t    }\n-\t\t  ++c1;\n-\t\t}\n+\t      for (c = 0; c < NUM_RTX_CODE; c++)\n+\t\tif (d1->u.pred.data->codes[c] && d2->u.pred.data->codes[c])\n+\t\t  {\n+\t\t    common = true;\n+\t\t    break;\n+\t\t  }\n \n \t      if (!common)\n \t\treturn 0;\n@@ -1823,22 +1901,22 @@ write_switch (struct decision *start, int depth)\n       else\n \tret = p;\n \n-      while (p && p->tests->type == DT_pred\n-\t     && p->tests->u.pred.index >= 0)\n+      while (p && p->tests->type == DT_pred && p->tests->u.pred.data)\n \t{\n-\t  const RTX_CODE *c;\n-\n-\t  for (c = &preds[p->tests->u.pred.index].codes[0]; *c ; ++c)\n-\t    if (codemap[(int) *c] != 0)\n+\t  const struct pred_data *data = p->tests->u.pred.data;\n+\t  RTX_CODE c;\n+\t  for (c = 0; c < NUM_RTX_CODE; c++)\n+\t    if (codemap[c] && data->codes[c])\n \t      goto pred_done;\n \n-\t  for (c = &preds[p->tests->u.pred.index].codes[0]; *c ; ++c)\n-\t    {\n-\t      printf (\"    case \");\n-\t      print_code (*c);\n-\t      printf (\":\\n\");\n-\t      codemap[(int) *c] = 1;\n-\t    }\n+\t  for (c = 0; c < NUM_RTX_CODE; c++)\n+\t    if (data->codes[c])\n+\t      {\n+\t\tfputs (\"    case \", stdout);\n+\t\tprint_code (c);\n+\t\tfputs (\":\\n\", stdout);\n+\t\tcodemap[c] = 1;\n+\t      }\n \n \t  printf (\"      goto L%d;\\n\", p->number);\n \t  p->need_label = 1;\n@@ -2640,7 +2718,6 @@ main (int argc, char **argv)\n     return (FATAL_EXIT_CODE);\n \n   next_insn_code = 0;\n-  next_index = 0;\n \n   write_header ();\n \n@@ -2652,26 +2729,33 @@ main (int argc, char **argv)\n       if (desc == NULL)\n \tbreak;\n \n-      if (GET_CODE (desc) == DEFINE_INSN)\n+      switch (GET_CODE (desc))\n \t{\n+\tcase DEFINE_PREDICATE:\n+\tcase DEFINE_SPECIAL_PREDICATE:\n+\t  process_define_predicate (desc);\n+\t  break;\n+\n+\tcase DEFINE_INSN:\n \t  h = make_insn_sequence (desc, RECOG);\n \t  merge_trees (&recog_tree, &h);\n-\t}\n-      else if (GET_CODE (desc) == DEFINE_SPLIT)\n-\t{\n+\t  break;\n+\n+\tcase DEFINE_SPLIT:\n \t  h = make_insn_sequence (desc, SPLIT);\n \t  merge_trees (&split_tree, &h);\n-\t}\n-      else if (GET_CODE (desc) == DEFINE_PEEPHOLE2)\n-\t{\n+\t  break;\n+\n+\tcase DEFINE_PEEPHOLE2:\n \t  h = make_insn_sequence (desc, PEEPHOLE2);\n \t  merge_trees (&peephole2_tree, &h);\n-\t}\n \n-      next_index++;\n+\tdefault:\n+\t  /* do nothing */;\n+\t}\n     }\n \n-  if (error_count)\n+  if (error_count || have_error)\n     return FATAL_EXIT_CODE;\n \n   puts (\"\\n\\n\");"}, {"sha": "618e1a271a5840657eec27eb8a54f40886f310e2", "filename": "gcc/gensupport.c", "status": "modified", "additions": 165, "deletions": 3, "changes": 168, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e543e219eb1865d4230278c3db3d2bedd60b1de0/gcc%2Fgensupport.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e543e219eb1865d4230278c3db3d2bedd60b1de0/gcc%2Fgensupport.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgensupport.c?ref=e543e219eb1865d4230278c3db3d2bedd60b1de0", "patch": "@@ -35,6 +35,8 @@ int target_flags;\n \n int insn_elision = 1;\n \n+const char *in_fname;\n+\n static struct obstack obstack;\n struct obstack *rtl_obstack = &obstack;\n \n@@ -65,6 +67,8 @@ struct queue_elem\n \n static struct queue_elem *define_attr_queue;\n static struct queue_elem **define_attr_tail = &define_attr_queue;\n+static struct queue_elem *define_pred_queue;\n+static struct queue_elem **define_pred_tail = &define_pred_queue;\n static struct queue_elem *define_insn_queue;\n static struct queue_elem **define_insn_tail = &define_insn_queue;\n static struct queue_elem *define_cond_exec_queue;\n@@ -109,6 +113,7 @@ static void process_one_cond_exec (struct queue_elem *);\n static void process_define_cond_exec (void);\n static void process_include (rtx, int);\n static char *save_string (const char *, int);\n+static void init_predicate_table (void);\n \f\n void\n message_with_line (int lineno, const char *msg, ...)\n@@ -284,6 +289,11 @@ process_rtx (rtx desc, int lineno)\n       queue_pattern (desc, &define_attr_tail, read_rtx_filename, lineno);\n       break;\n \n+    case DEFINE_PREDICATE:\n+    case DEFINE_SPECIAL_PREDICATE:\n+      queue_pattern (desc, &define_pred_tail, read_rtx_filename, lineno);\n+      break;\n+\n     case INCLUDE:\n       process_include (desc, lineno);\n       break;\n@@ -904,10 +914,7 @@ init_md_reader_args_cb (int argc, char **argv, bool (*parse_opt)(const char *))\n   int i;\n   size_t ix;\n   char *lastsl;\n-  const char *in_fname;\n \n-  max_include_len = 0;\n-  in_fname = NULL;\n   for (i = 1; i < argc; i++)\n     {\n       if (argv[i][0] != '-')\n@@ -977,6 +984,8 @@ init_md_reader_args_cb (int argc, char **argv, bool (*parse_opt)(const char *))\n     *(htab_find_slot (condition_table, &insn_conditions[ix], INSERT))\n       = (void *) &insn_conditions[ix];\n \n+  init_predicate_table ();\n+\n   obstack_init (rtl_obstack);\n   errors = 0;\n   sequence_num = 0;\n@@ -1025,6 +1034,8 @@ read_md_rtx (int *lineno, int *seqnr)\n   /* Read all patterns from a given queue before moving on to the next.  */\n   if (define_attr_queue != NULL)\n     queue = &define_attr_queue;\n+  else if (define_pred_queue != NULL)\n+    queue = &define_pred_queue;\n   else if (define_insn_queue != NULL)\n     queue = &define_insn_queue;\n   else if (other_queue != NULL)\n@@ -1181,3 +1192,154 @@ scan_comma_elt (const char **pstr)\n   *pstr = p;\n   return start;\n }\n+\n+/* Helper functions for define_predicate and define_special_predicate\n+   processing.  Shared between genrecog.c and genpreds.c.  */\n+\n+static htab_t predicate_table;\n+struct pred_data *first_predicate;\n+static struct pred_data **last_predicate = &first_predicate;\n+\n+static hashval_t\n+hash_struct_pred_data (const void *ptr)\n+{\n+  return htab_hash_string (((const struct pred_data *)ptr)->name);\n+}\n+\n+static int\n+eq_struct_pred_data (const void *a, const void *b)\n+{\n+  return !strcmp (((const struct pred_data *)a)->name,\n+\t\t  ((const struct pred_data *)b)->name);\n+}\n+\n+struct pred_data *\n+lookup_predicate (const char *name)\n+{\n+  struct pred_data key;\n+  key.name = name;\n+  return htab_find (predicate_table, &key);\n+}\n+\n+void\n+add_predicate (struct pred_data *pred)\n+{\n+  void **slot = htab_find_slot (predicate_table, pred, INSERT);\n+  if (*slot)\n+    {\n+      error (\"duplicate predicate definition for '%s'\", pred->name);\n+      return;\n+    }\n+  *slot = pred;\n+  *last_predicate = pred;\n+  last_predicate = &pred->next;\n+}\n+\n+/* This array gives the initial content of the predicate table.  It\n+   has entries for all predicates defined in recog.c.  The back end\n+   can define PREDICATE_CODES to give additional entries for the\n+   table; this is considered an obsolete mechanism (use\n+   define_predicate instead).  */\n+\n+struct old_pred_table\n+{\n+  const char *name;\n+  RTX_CODE codes[NUM_RTX_CODE];\n+};\n+\n+static const struct old_pred_table old_preds[] = {\n+  {\"general_operand\", {CONST_INT, CONST_DOUBLE, CONST, SYMBOL_REF,\n+\t\t       LABEL_REF, SUBREG, REG, MEM }},\n+  {\"address_operand\", {CONST_INT, CONST_DOUBLE, CONST, SYMBOL_REF,\n+\t\t       LABEL_REF, SUBREG, REG, MEM,\n+\t\t       PLUS, MINUS, MULT}},\n+  {\"register_operand\", {SUBREG, REG}},\n+  {\"pmode_register_operand\", {SUBREG, REG}},\n+  {\"scratch_operand\", {SCRATCH, REG}},\n+  {\"immediate_operand\", {CONST_INT, CONST_DOUBLE, CONST, SYMBOL_REF,\n+\t\t\t LABEL_REF}},\n+  {\"const_int_operand\", {CONST_INT}},\n+  {\"const_double_operand\", {CONST_INT, CONST_DOUBLE}},\n+  {\"nonimmediate_operand\", {SUBREG, REG, MEM}},\n+  {\"nonmemory_operand\", {CONST_INT, CONST_DOUBLE, CONST, SYMBOL_REF,\n+\t\t\t LABEL_REF, SUBREG, REG}},\n+  {\"push_operand\", {MEM}},\n+  {\"pop_operand\", {MEM}},\n+  {\"memory_operand\", {SUBREG, MEM}},\n+  {\"indirect_operand\", {SUBREG, MEM}},\n+  {\"comparison_operator\", {EQ, NE, LE, LT, GE, GT, LEU, LTU, GEU, GTU,\n+\t\t\t   UNORDERED, ORDERED, UNEQ, UNGE, UNGT, UNLE,\n+\t\t\t   UNLT, LTGT}},\n+#ifdef PREDICATE_CODES\n+  PREDICATE_CODES\n+#endif\n+};\n+#define NUM_KNOWN_OLD_PREDS ARRAY_SIZE (old_preds)\n+\n+/* This table gives the initial set of special predicates.  It has\n+   entries for all special predicates defined in recog.c.  The back\n+   end can define SPECIAL_MODE_PREDICATES to give additional entries\n+   for the table; this is considered an obsolete mechanism (use\n+   define_special_predicate instead).  */\n+static const char *const old_special_pred_table[] = {\n+  \"address_operand\",\n+  \"pmode_register_operand\",\n+#ifdef SPECIAL_MODE_PREDICATES\n+  SPECIAL_MODE_PREDICATES\n+#endif\n+};\n+\n+#define NUM_OLD_SPECIAL_MODE_PREDS ARRAY_SIZE (old_special_pred_table)\n+\n+/* Initialize the table of predicate definitions, starting with\n+   the information we have on generic predicates, and the old-style\n+   PREDICATE_CODES definitions.  */\n+\n+static void\n+init_predicate_table (void)\n+{\n+  size_t i, j;\n+  struct pred_data *pred;\n+\n+  predicate_table = htab_create_alloc (37, hash_struct_pred_data,\n+\t\t\t\t       eq_struct_pred_data, 0,\n+\t\t\t\t       xcalloc, free);\n+\n+  for (i = 0; i < NUM_KNOWN_OLD_PREDS; i++)\n+    {\n+      pred = xcalloc (sizeof (struct pred_data), 1);\n+      pred->name = old_preds[i].name;\n+\n+      for (j = 0; old_preds[i].codes[j] != 0; j++)\n+\t{\n+\t  enum rtx_code code = old_preds[i].codes[j];\n+\n+\t  pred->codes[code] = true;\n+\t  if (GET_RTX_CLASS (code) != RTX_CONST_OBJ)\n+\t    pred->allows_non_const = true;\n+\t  if (code != REG\n+\t      && code != SUBREG\n+\t      && code != MEM\n+\t      && code != CONCAT\n+\t      && code != PARALLEL\n+\t      && code != STRICT_LOW_PART)\n+\t    pred->allows_non_lvalue = true;\n+\t}\n+      if (j == 1)\n+\tpred->singleton = old_preds[i].codes[0];\n+      \n+      add_predicate (pred);\n+    }\n+\n+  for (i = 0; i < NUM_OLD_SPECIAL_MODE_PREDS; i++)\n+    {\n+      pred = lookup_predicate (old_special_pred_table[i]);\n+      if (!pred)\n+\t{\n+\t  error (\"old-style special predicate list refers \"\n+\t\t \"to unknown predicate '%s'\", old_special_pred_table[i]);\n+\t  continue;\n+\t}\n+      pred->special = true;\n+    }\n+}"}, {"sha": "90f866a2f56c50afd2ef52f7e06417fab31e40ea", "filename": "gcc/gensupport.h", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e543e219eb1865d4230278c3db3d2bedd60b1de0/gcc%2Fgensupport.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e543e219eb1865d4230278c3db3d2bedd60b1de0/gcc%2Fgensupport.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgensupport.h?ref=e543e219eb1865d4230278c3db3d2bedd60b1de0", "patch": "@@ -23,6 +23,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n \n struct obstack;\n extern struct obstack *rtl_obstack;\n+extern const char *in_fname;\n \n extern int init_md_reader_args_cb (int, char **, bool (*)(const char *));\n extern int init_md_reader_args (int, char **);\n@@ -66,4 +67,29 @@ extern int cmp_c_test (const void *, const void *);\n extern int n_comma_elts\t(const char *);\n extern const char *scan_comma_elt (const char **);\n \n+/* Predicate handling: helper functions and data structures.  */\n+\n+struct pred_data\n+{\n+  struct pred_data *next;\t/* for iterating over the set of all preds */\n+  const char *name;\t\t/* predicate name */\n+  bool special;\t\t\t/* special handling of modes? */\n+\n+  /* data used primarily by genpreds.c */\n+  const char *c_block;\t\t/* C test block */\n+  rtx exp;\t\t\t/* RTL test expression */\n+\n+  /* data used primarily by genrecog.c */\n+  enum rtx_code singleton;\t/* if pred takes only one code, that code */\n+  bool allows_non_lvalue;\t/* if pred allows non-lvalue expressions */\n+  bool allows_non_const;\t/* if pred allows non-const expressions */\n+  bool codes[NUM_RTX_CODE];\t/* set of codes accepted */\n+};\n+\n+extern struct pred_data *first_predicate;\n+extern struct pred_data *lookup_predicate (const char *);\n+extern void add_predicate (struct pred_data *);\n+\n+#define FOR_ALL_PREDICATES(p) for (p = first_predicate; p; p = p->next)\n+\n #endif /* GCC_GENSUPPORT_H */"}, {"sha": "eae37fb4442cadfc608f777f2e98a284c5f3ea23", "filename": "gcc/recog.h", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e543e219eb1865d4230278c3db3d2bedd60b1de0/gcc%2Frecog.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e543e219eb1865d4230278c3db3d2bedd60b1de0/gcc%2Frecog.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.h?ref=e543e219eb1865d4230278c3db3d2bedd60b1de0", "patch": "@@ -96,22 +96,6 @@ extern int next_insn_tests_no_inequality (rtx);\n extern int reg_fits_class_p (rtx, enum reg_class, int, enum machine_mode);\n extern rtx *find_single_use (rtx, rtx, rtx *);\n \n-extern int general_operand (rtx, enum machine_mode);\n-extern int address_operand (rtx, enum machine_mode);\n-extern int register_operand (rtx, enum machine_mode);\n-extern int pmode_register_operand (rtx, enum machine_mode);\n-extern int scratch_operand (rtx, enum machine_mode);\n-extern int immediate_operand (rtx, enum machine_mode);\n-extern int const_int_operand (rtx, enum machine_mode);\n-extern int const_double_operand (rtx, enum machine_mode);\n-extern int nonimmediate_operand (rtx, enum machine_mode);\n-extern int nonmemory_operand (rtx, enum machine_mode);\n-extern int push_operand (rtx, enum machine_mode);\n-extern int pop_operand (rtx, enum machine_mode);\n-extern int memory_operand (rtx, enum machine_mode);\n-extern int indirect_operand (rtx, enum machine_mode);\n-extern int comparison_operator (rtx, enum machine_mode);\n-\n extern int offsettable_memref_p (rtx);\n extern int offsettable_nonstrict_memref_p (rtx);\n extern int offsettable_address_p (int, enum machine_mode, rtx);"}, {"sha": "300d9d50267f2224dc94df13af560c3c539ee093", "filename": "gcc/rtl.def", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e543e219eb1865d4230278c3db3d2bedd60b1de0/gcc%2Frtl.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e543e219eb1865d4230278c3db3d2bedd60b1de0/gcc%2Frtl.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.def?ref=e543e219eb1865d4230278c3db3d2bedd60b1de0", "patch": "@@ -182,6 +182,17 @@ DEF_RTL_EXPR(MATCH_OP_DUP, \"match_op_dup\", \"iE\", RTX_MATCH)\n    at the index specified by the argument.  For MATCH_PARALLEL.  */\n DEF_RTL_EXPR(MATCH_PAR_DUP, \"match_par_dup\", \"iE\", RTX_MATCH)\n \n+/* Appears only in define_predicate/define_special predicate\n+   expressions in a machine description.  Evaluates true only if the\n+   operand has an RTX code from the set given by the argument (a\n+   comma-separated list).  */\n+DEF_RTL_EXPR(MATCH_CODE, \"match_code\", \"s\", RTX_MATCH)\n+\n+/* Appears only in define_predicate/define_special_predicate expressions\n+   in a machine description.  The argument is a C expression to be injected\n+   at this point in the predicate formula.  */\n+DEF_RTL_EXPR(MATCH_TEST, \"match_test\", \"s\", RTX_MATCH)\n+\n /* Appears only in machine descriptions.\n    Defines the pattern for one kind of instruction.\n    Operand:\n@@ -297,6 +308,23 @@ DEF_RTL_EXPR(DEFINE_ASM_ATTRIBUTES, \"define_asm_attributes\", \"V\", RTX_EXTRA)\n    2: A template or C code to produce assembler output.  */\n DEF_RTL_EXPR(DEFINE_COND_EXEC, \"define_cond_exec\", \"Ess\", RTX_EXTRA)\n \n+/* Definition of an operand predicate.  The difference between\n+   DEFINE_PREDICATE and DEFINE_SPECIAL_PREDICATE is that genrecog will\n+   not warn about a match_operand with no mode if it has a predicate\n+   defined with DEFINE_SPECIAL_PREDICATE.\n+\n+   Operand:\n+   0: The name of the predicate.\n+   1: A boolean expression which computes whether or not the predicate\n+      matches.  This expression can use IOR, AND, NOT, MATCH_OPERAND,\n+      MATCH_CODE, and MATCH_TEST.  It must be specific enough that genrecog\n+      can calculate the set of RTX codes that can possibly match.\n+   2: A C function body which must return true for the predicate to match.\n+      Optional.  Use this when the test is too complicated to fit into a\n+      match_test expression.  */\n+DEF_RTL_EXPR(DEFINE_PREDICATE, \"define_predicate\", \"ses\", RTX_EXTRA)\n+DEF_RTL_EXPR(DEFINE_SPECIAL_PREDICATE, \"define_special_predicate\", \"ses\", RTX_EXTRA)\n+\n /* SEQUENCE appears in the result of a `gen_...' function\n    for a DEFINE_EXPAND that wants to make several insns.\n    Its elements are the bodies of the insns that should be made."}]}