{"sha": "1a4cb2276c4de8021a305c23a5b08680e1b25400", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWE0Y2IyMjc2YzRkZTgwMjFhMzA1YzIzYTViMDg2ODBlMWIyNTQwMA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@adacore.com", "date": "2014-07-18T10:19:34Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-07-18T10:19:34Z"}, "message": "decl.c, [...] (Is_Packed_Array_Type): Renamed Is_Packed_Array_Impl_Type.\n\n\t* gcc-interface/decl.c, gcc-interface/trans.c,\n\tgcc-interface/utils.c (Is_Packed_Array_Type): Renamed\n\tIs_Packed_Array_Impl_Type.\n\nFrom-SVN: r212808", "tree": {"sha": "17a487ffdf4f9aec35da1a89325cff9277c0d047", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/17a487ffdf4f9aec35da1a89325cff9277c0d047"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1a4cb2276c4de8021a305c23a5b08680e1b25400", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a4cb2276c4de8021a305c23a5b08680e1b25400", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1a4cb2276c4de8021a305c23a5b08680e1b25400", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a4cb2276c4de8021a305c23a5b08680e1b25400/comments", "author": {"login": "ArnaudCharlet", "id": 30291825, "node_id": "MDQ6VXNlcjMwMjkxODI1", "avatar_url": "https://avatars.githubusercontent.com/u/30291825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ArnaudCharlet", "html_url": "https://github.com/ArnaudCharlet", "followers_url": "https://api.github.com/users/ArnaudCharlet/followers", "following_url": "https://api.github.com/users/ArnaudCharlet/following{/other_user}", "gists_url": "https://api.github.com/users/ArnaudCharlet/gists{/gist_id}", "starred_url": "https://api.github.com/users/ArnaudCharlet/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ArnaudCharlet/subscriptions", "organizations_url": "https://api.github.com/users/ArnaudCharlet/orgs", "repos_url": "https://api.github.com/users/ArnaudCharlet/repos", "events_url": "https://api.github.com/users/ArnaudCharlet/events{/privacy}", "received_events_url": "https://api.github.com/users/ArnaudCharlet/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c74afd846db25c438a7f24254fe501a829109117", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c74afd846db25c438a7f24254fe501a829109117", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c74afd846db25c438a7f24254fe501a829109117"}], "stats": {"total": 66, "additions": 38, "deletions": 28}, "files": [{"sha": "55cc2df2cc72947821fc81b6a4544ddb75ac4709", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a4cb2276c4de8021a305c23a5b08680e1b25400/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a4cb2276c4de8021a305c23a5b08680e1b25400/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=1a4cb2276c4de8021a305c23a5b08680e1b25400", "patch": "@@ -1,3 +1,9 @@\n+2014-07-18  Arnaud Charlet  <charlet@adacore.com>\n+\n+\t* gcc-interface/decl.c, gcc-interface/trans.c,\n+\tgcc-interface/utils.c (Is_Packed_Array_Type): Renamed \n+\tIs_Packed_Array_Impl_Type.\n+\n 2014-07-18  Gary Dismukes  <dismukes@adacore.com>\n \n \t* sem_util.adb: Minor typo correction."}, {"sha": "6ece8d87b3013e363dd56c518f328f742b4526e2", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 23, "deletions": 21, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a4cb2276c4de8021a305c23a5b08680e1b25400/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a4cb2276c4de8021a305c23a5b08680e1b25400/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=1a4cb2276c4de8021a305c23a5b08680e1b25400", "patch": "@@ -1676,8 +1676,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t   of bits and then set up the modulus, if required.  */\n \ttree gnu_modulus, gnu_high = NULL_TREE;\n \n-\t/* Packed array types are supposed to be subtypes only.  */\n-\tgcc_assert (!Is_Packed_Array_Type (gnat_entity));\n+\t/* Packed Array Impl. Types are supposed to be subtypes only.  */\n+\tgcc_assert (!Is_Packed_Array_Impl_Type (gnat_entity));\n \n \tgnu_type = make_unsigned_type (esize);\n \n@@ -1737,7 +1737,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \tgnat_to_gnu_entity (Ancestor_Subtype (gnat_entity), gnu_expr, 0);\n \n       /* Set the precision to the Esize except for bit-packed arrays.  */\n-      if (Is_Packed_Array_Type (gnat_entity)\n+      if (Is_Packed_Array_Impl_Type (gnat_entity)\n \t  && Is_Bit_Packed_Array (Original_Array_Type (gnat_entity)))\n \tesize = UI_To_Int (RM_Size (gnat_entity));\n \n@@ -1790,7 +1790,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \n       /* For a packed array, make the original array type a parallel type.  */\n       if (debug_info_p\n-\t  && Is_Packed_Array_Type (gnat_entity)\n+\t  && Is_Packed_Array_Impl_Type (gnat_entity)\n \t  && present_gnu_tree (Original_Array_Type (gnat_entity)))\n \tadd_parallel_type (gnu_type,\n \t\t\t   gnat_to_gnu_type\n@@ -1800,7 +1800,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \n       /* We have to handle clauses that under-align the type specially.  */\n       if ((Present (Alignment_Clause (gnat_entity))\n-\t   || (Is_Packed_Array_Type (gnat_entity)\n+\t   || (Is_Packed_Array_Impl_Type (gnat_entity)\n \t       && Present\n \t\t  (Alignment_Clause (Original_Array_Type (gnat_entity)))))\n \t  && UI_Is_In_Int_Range (Alignment (gnat_entity)))\n@@ -1817,7 +1817,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t such values), we only get the good bits, since the unused bits\n \t are uninitialized.  Both goals are accomplished by wrapping up\n \t the modular type in an enclosing record type.  */\n-      if (Is_Packed_Array_Type (gnat_entity)\n+      if (Is_Packed_Array_Impl_Type (gnat_entity)\n \t  && Is_Bit_Packed_Array (Original_Array_Type (gnat_entity)))\n \t{\n \t  tree gnu_field_type, gnu_field;\n@@ -2245,7 +2245,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t/* If an alignment is specified, use it if valid.  But ignore it\n \t   for the original type of packed array types.  If the alignment\n \t   was requested with an explicit alignment clause, state so.  */\n-\tif (No (Packed_Array_Type (gnat_entity))\n+\tif (No (Packed_Array_Impl_Type (gnat_entity))\n \t    && Known_Alignment (gnat_entity))\n \t  {\n \t    TYPE_ALIGN (tem)\n@@ -2288,10 +2288,10 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t\t  !Comes_From_Source (gnat_entity), debug_info_p,\n \t\t\t  gnat_entity);\n \n-\t/* Give the fat pointer type a name.  If this is a packed type, tell\n+\t/* Give the fat pointer type a name.  If this is a packed array, tell\n \t   the debugger how to interpret the underlying bits.  */\n-\tif (Present (Packed_Array_Type (gnat_entity)))\n-\t  gnat_name = Packed_Array_Type (gnat_entity);\n+\tif (Present (Packed_Array_Impl_Type (gnat_entity)))\n+\t  gnat_name = Packed_Array_Impl_Type (gnat_entity);\n \telse\n \t  gnat_name = gnat_entity;\n \tcreate_type_decl (create_concat_name (gnat_name, \"XUP\"), gnu_fat_type,\n@@ -2413,7 +2413,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t      else if ((Nkind (gnat_index) == N_Range\n \t\t        && cannot_be_superflat_p (gnat_index))\n \t\t       /* Bit-Packed Array Types are never superflat.  */\n-\t\t       || (Is_Packed_Array_Type (gnat_entity)\n+\t\t       || (Is_Packed_Array_Impl_Type (gnat_entity)\n \t\t\t   && Is_Bit_Packed_Array\n \t\t\t      (Original_Array_Type (gnat_entity))))\n \t\tgnu_high = gnu_max;\n@@ -2538,7 +2538,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t     used to implement a packed array, get the component type from\n \t     the original array type since the representation clauses that\n \t     can affect it are on the latter.  */\n-\t  if (Is_Packed_Array_Type (gnat_entity)\n+\t  if (Is_Packed_Array_Impl_Type (gnat_entity)\n \t      && !Is_Bit_Packed_Array (Original_Array_Type (gnat_entity)))\n \t    {\n \t      gnu_type = gnat_to_gnu_type (Original_Array_Type (gnat_entity));\n@@ -2642,7 +2642,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t     since the bounds are conveyed by the original array type.  */\n \t  if (need_index_type_struct\n \t      && debug_info_p\n-\t      && !Is_Packed_Array_Type (gnat_entity))\n+\t      && !Is_Packed_Array_Impl_Type (gnat_entity))\n \t    {\n \t      tree gnu_bound_rec = make_node (RECORD_TYPE);\n \t      tree gnu_field_list = NULL_TREE;\n@@ -2674,7 +2674,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t     isn't artificial to make sure it is kept in the debug info.  */\n \t  if (debug_info_p)\n \t    {\n-\t      if (Is_Packed_Array_Type (gnat_entity)\n+\t      if (Is_Packed_Array_Impl_Type (gnat_entity)\n \t\t  && present_gnu_tree (Original_Array_Type (gnat_entity)))\n \t\tadd_parallel_type (gnu_type,\n \t\t\t\t   gnat_to_gnu_type\n@@ -2691,7 +2691,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \n \t  TYPE_CONVENTION_FORTRAN_P (gnu_type) = convention_fortran_p;\n \t  TYPE_PACKED_ARRAY_TYPE_P (gnu_type)\n-\t    = (Is_Packed_Array_Type (gnat_entity)\n+\t    = (Is_Packed_Array_Impl_Type (gnat_entity)\n \t       && Is_Bit_Packed_Array (Original_Array_Type (gnat_entity)));\n \n \t  /* If the size is self-referential and the maximum size doesn't\n@@ -2716,7 +2716,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \n \t  /* If this is a packed type, make this type the same as the packed\n \t     array type, but do some adjusting in the type first.  */\n-\t  if (Present (Packed_Array_Type (gnat_entity)))\n+\t  if (Present (Packed_Array_Impl_Type (gnat_entity)))\n \t    {\n \t      Entity_Id gnat_index;\n \t      tree gnu_inner;\n@@ -2741,8 +2741,9 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t this type again.  */\n \t      save_gnu_tree (gnat_entity, gnu_decl, false);\n \n-\t      gnu_decl = gnat_to_gnu_entity (Packed_Array_Type (gnat_entity),\n-\t\t\t\t\t     NULL_TREE, 0);\n+\t      gnu_decl\n+\t\t= gnat_to_gnu_entity (Packed_Array_Impl_Type (gnat_entity),\n+\t\t\t\t      NULL_TREE, 0);\n \t      this_made_decl = true;\n \t      gnu_type = TREE_TYPE (gnu_decl);\n \t      save_gnu_tree (gnat_entity, NULL_TREE, false);\n@@ -2806,7 +2807,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t    }\n \n \t  else\n-\t    /* Abort if packed array with no Packed_Array_Type field set.  */\n+\t    /* Abort if packed array with no Packed_Array_Impl_Type.  */\n \t    gcc_assert (!Is_Packed (gnat_entity));\n \t}\n       break;\n@@ -5364,7 +5365,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \n   /* If this is a packed array type whose original array type is itself\n      an Itype without freeze node, make sure the latter is processed.  */\n-  if (Is_Packed_Array_Type (gnat_entity)\n+  if (Is_Packed_Array_Impl_Type (gnat_entity)\n       && Is_Itype (Original_Array_Type (gnat_entity))\n       && No (Freeze_Node (Original_Array_Type (gnat_entity)))\n       && !present_gnu_tree (Original_Array_Type (gnat_entity)))\n@@ -5620,7 +5621,8 @@ gnat_to_gnu_component_type (Entity_Id gnat_array, bool definition,\n       /* If an alignment is specified, use it as a cap on the component type\n \t so that it can be honored for the whole type.  But ignore it for the\n \t original type of packed array types.  */\n-      if (No (Packed_Array_Type (gnat_array)) && Known_Alignment (gnat_array))\n+      if (No (Packed_Array_Impl_Type (gnat_array))\n+\t  && Known_Alignment (gnat_array))\n \tmax_align = validate_alignment (Alignment (gnat_array), gnat_array, 0);\n       else\n \tmax_align = 0;"}, {"sha": "e0ecf065c7dcaacb852a338123ef21051d6f55ef", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a4cb2276c4de8021a305c23a5b08680e1b25400/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a4cb2276c4de8021a305c23a5b08680e1b25400/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=1a4cb2276c4de8021a305c23a5b08680e1b25400", "patch": "@@ -1065,15 +1065,16 @@ Identifier_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p)\n \n   gcc_assert (Etype (gnat_node) == gnat_temp_type\n \t      || (Is_Packed (gnat_temp_type)\n-\t\t  && Etype (gnat_node) == Packed_Array_Type (gnat_temp_type))\n+\t\t  && (Etype (gnat_node)\n+\t\t      == Packed_Array_Impl_Type (gnat_temp_type)))\n \t      || (Is_Class_Wide_Type (Etype (gnat_node)))\n \t      || (IN (Ekind (gnat_temp_type), Private_Kind)\n \t\t  && Present (Full_View (gnat_temp_type))\n \t\t  && ((Etype (gnat_node) == Full_View (gnat_temp_type))\n \t\t      || (Is_Packed (Full_View (gnat_temp_type))\n \t\t\t  && (Etype (gnat_node)\n-\t\t\t      == Packed_Array_Type (Full_View\n-\t\t\t\t\t\t    (gnat_temp_type))))))\n+\t\t\t      == Packed_Array_Impl_Type\n+\t\t\t           (Full_View (gnat_temp_type))))))\n \t      || (Is_Itype (Etype (gnat_node)) && Is_Itype (gnat_temp_type))\n \t      || !(Ekind (gnat_temp) == E_Variable\n \t\t   || Ekind (gnat_temp) == E_Component\n@@ -1107,7 +1108,7 @@ Identifier_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p)\n       if ((Ekind (gnat_temp) == E_Constant\n \t   || Ekind (gnat_temp) == E_Variable || Is_Formal (gnat_temp))\n \t  && !(Is_Array_Type (Etype (gnat_temp))\n-\t       && Present (Packed_Array_Type (Etype (gnat_temp))))\n+\t       && Present (Packed_Array_Impl_Type (Etype (gnat_temp))))\n \t  && Present (Actual_Subtype (gnat_temp))\n \t  && present_gnu_tree (Actual_Subtype (gnat_temp)))\n \tgnat_temp_type = Actual_Subtype (gnat_temp);\n@@ -5359,9 +5360,9 @@ unchecked_conversion_nop (Node_Id gnat_node)\n   if (to_type == from_type)\n     return true;\n \n-  /* For an array subtype, the conversion to the PAT is a no-op.  */\n+  /* For an array subtype, the conversion to the PAIT is a no-op.  */\n   if (Ekind (from_type) == E_Array_Subtype\n-      && to_type == Packed_Array_Type (from_type))\n+      && to_type == Packed_Array_Impl_Type (from_type))\n     return true;\n \n   /* For a record subtype, the conversion to the type is a no-op.  */"}, {"sha": "022bca7fead0591da231033cd3e86381fc4166df", "filename": "gcc/ada/gcc-interface/utils.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a4cb2276c4de8021a305c23a5b08680e1b25400/gcc%2Fada%2Fgcc-interface%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a4cb2276c4de8021a305c23a5b08680e1b25400/gcc%2Fada%2Fgcc-interface%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.c?ref=1a4cb2276c4de8021a305c23a5b08680e1b25400", "patch": "@@ -1252,7 +1252,8 @@ maybe_pad_type (tree type, tree size, unsigned int align,\n     {\n       Node_Id gnat_error_node = Empty;\n \n-      if (Is_Packed_Array_Type (gnat_entity))\n+      /* For a packed array, post the message on the original array type.  */\n+      if (Is_Packed_Array_Impl_Type (gnat_entity))\n \tgnat_entity = Original_Array_Type (gnat_entity);\n \n       if ((Ekind (gnat_entity) == E_Component"}]}