{"sha": "2ca862e9dd939d7dd686b771f401012fb9ed9bfe", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmNhODYyZTlkZDkzOWQ3ZGQ2ODZiNzcxZjQwMTAxMmZiOWVkOWJmZQ==", "commit": {"author": {"name": "Joseph Myers", "email": "joseph@codesourcery.com", "date": "2009-05-08T10:22:08Z"}, "committer": {"name": "Joseph Myers", "email": "jsm28@gcc.gnu.org", "date": "2009-05-08T10:22:08Z"}, "message": "re PR c/24581 (Complex arithmetic on special cases is incorrect.)\n\n\tPR c/24581\n\t* c-typeck.c (build_binary_op): Handle arithmetic between one real\n\tand one complex operand specially.\n\t* tree-complex.c (some_nonzerop): Do not identify a real value as\n\tzero if flag_signed_zeros.\n\ntestsuite:\n\t* gcc.dg/torture/complex-sign.h: New header.\n\t* gcc.dg/torture/complex-sign-add.c,\n\tgcc.dg/torture/complex-sign-mixed-add.c,\n\tgcc.dg/torture/complex-sign-mixed-div.c,\n\tgcc.dg/torture/complex-sign-mixed-mul.c,\n\tgcc.dg/torture/complex-sign-mixed-sub.c,\n\tgcc.dg/torture/complex-sign-mul.c,\n\tgcc.dg/torture/complex-sign-sub.c: New tests.\n\nFrom-SVN: r147281", "tree": {"sha": "0d1b08d95e3e4458bfdcc780995e149747769e39", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0d1b08d95e3e4458bfdcc780995e149747769e39"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2ca862e9dd939d7dd686b771f401012fb9ed9bfe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ca862e9dd939d7dd686b771f401012fb9ed9bfe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2ca862e9dd939d7dd686b771f401012fb9ed9bfe", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ca862e9dd939d7dd686b771f401012fb9ed9bfe/comments", "author": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cb8e4445ef25e1da025712d0595274b297b78ec1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cb8e4445ef25e1da025712d0595274b297b78ec1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cb8e4445ef25e1da025712d0595274b297b78ec1"}], "stats": {"total": 549, "additions": 547, "deletions": 2}, "files": [{"sha": "502da99c89fc34ce13e7dd58b4986033790683e3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ca862e9dd939d7dd686b771f401012fb9ed9bfe/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ca862e9dd939d7dd686b771f401012fb9ed9bfe/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2ca862e9dd939d7dd686b771f401012fb9ed9bfe", "patch": "@@ -1,3 +1,11 @@\n+2009-05-08  Joseph Myers  <joseph@codesourcery.com>\n+\n+\tPR c/24581\n+\t* c-typeck.c (build_binary_op): Handle arithmetic between one real\n+\tand one complex operand specially.\n+\t* tree-complex.c (some_nonzerop): Do not identify a real value as\n+\tzero if flag_signed_zeros.\n+\n 2009-05-08  Paolo Bonzini  <bonzini@gnu.org>\n \n \tPR rtl-optimization/33928"}, {"sha": "4d07a880a9c2a28c52060c75c90114aae96b22c1", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 86, "deletions": 1, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ca862e9dd939d7dd686b771f401012fb9ed9bfe/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ca862e9dd939d7dd686b771f401012fb9ed9bfe/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=2ca862e9dd939d7dd686b771f401012fb9ed9bfe", "patch": "@@ -9246,7 +9246,9 @@ build_binary_op (location_t location, enum tree_code code,\n       (code1 == INTEGER_TYPE || code1 == REAL_TYPE || code1 == COMPLEX_TYPE\n        || code1 == FIXED_POINT_TYPE || code1 == VECTOR_TYPE))\n     {\n-      int none_complex = (code0 != COMPLEX_TYPE && code1 != COMPLEX_TYPE);\n+      bool first_complex = (code0 == COMPLEX_TYPE);\n+      bool second_complex = (code1 == COMPLEX_TYPE);\n+      int none_complex = (!first_complex && !second_complex);\n \n       if (shorten || common || short_compare)\n \t{\n@@ -9255,6 +9257,89 @@ build_binary_op (location_t location, enum tree_code code,\n \t    return error_mark_node;\n \t}\n \n+      if (first_complex != second_complex\n+\t  && (code == PLUS_EXPR\n+\t      || code == MINUS_EXPR\n+\t      || code == MULT_EXPR\n+\t      || (code == TRUNC_DIV_EXPR && first_complex))\n+\t  && TREE_CODE (TREE_TYPE (result_type)) == REAL_TYPE\n+\t  && flag_signed_zeros)\n+\t{\n+\t  /* An operation on mixed real/complex operands must be\n+\t     handled specially, but the language-independent code can\n+\t     more easily optimize the plain complex arithmetic if\n+\t     -fno-signed-zeros.  */\n+\t  tree real_type = TREE_TYPE (result_type);\n+\t  tree real, imag;\n+\t  if (type0 != orig_type0 || type1 != orig_type1)\n+\t    {\n+\t      gcc_assert (may_need_excess_precision && common);\n+\t      real_result_type = c_common_type (orig_type0, orig_type1);\n+\t    }\n+\t  if (first_complex)\n+\t    {\n+\t      if (TREE_TYPE (op0) != result_type)\n+\t\top0 = convert_and_check (result_type, op0);\n+\t      if (TREE_TYPE (op1) != real_type)\n+\t\top1 = convert_and_check (real_type, op1);\n+\t    }\n+\t  else\n+\t    {\n+\t      if (TREE_TYPE (op0) != real_type)\n+\t\top0 = convert_and_check (real_type, op0);\n+\t      if (TREE_TYPE (op1) != result_type)\n+\t\top1 = convert_and_check (result_type, op1);\n+\t    }\n+\t  if (TREE_CODE (op0) == ERROR_MARK || TREE_CODE (op1) == ERROR_MARK)\n+\t    return error_mark_node;\n+\t  if (first_complex)\n+\t    {\n+\t      op0 = c_save_expr (op0);\n+\t      real = build_unary_op (EXPR_LOCATION (orig_op0), REALPART_EXPR,\n+\t\t\t\t     op0, 1);\n+\t      imag = build_unary_op (EXPR_LOCATION (orig_op0), IMAGPART_EXPR,\n+\t\t\t\t     op0, 1);\n+\t      switch (code)\n+\t\t{\n+\t\tcase MULT_EXPR:\n+\t\tcase TRUNC_DIV_EXPR:\n+\t\t  imag = build2 (resultcode, real_type, imag, op1);\n+\t\t  /* Fall through.  */\n+\t\tcase PLUS_EXPR:\n+\t\tcase MINUS_EXPR:\n+\t\t  real = build2 (resultcode, real_type, real, op1);\n+\t\t  break;\n+\t\tdefault:\n+\t\t  gcc_unreachable();\n+\t\t}\n+\t    }\n+\t  else\n+\t    {\n+\t      op1 = c_save_expr (op1);\n+\t      real = build_unary_op (EXPR_LOCATION (orig_op1), REALPART_EXPR,\n+\t\t\t\t     op1, 1);\n+\t      imag = build_unary_op (EXPR_LOCATION (orig_op1), IMAGPART_EXPR,\n+\t\t\t\t     op1, 1);\n+\t      switch (code)\n+\t\t{\n+\t\tcase MULT_EXPR:\n+\t\t  imag = build2 (resultcode, real_type, op0, imag);\n+\t\t  /* Fall through.  */\n+\t\tcase PLUS_EXPR:\n+\t\t  real = build2 (resultcode, real_type, op0, real);\n+\t\t  break;\n+\t\tcase MINUS_EXPR:\n+\t\t  real = build2 (resultcode, real_type, op0, real);\n+\t\t  imag = build1 (NEGATE_EXPR, real_type, imag);\n+\t\t  break;\n+\t\tdefault:\n+\t\t  gcc_unreachable();\n+\t\t}\n+\t    }\n+\t  ret = build2 (COMPLEX_EXPR, result_type, real, imag);\n+\t  goto return_build_binary_op;\n+\t}\n+\n       /* For certain operations (which identify themselves by shorten != 0)\n \t if both args were extended from the same smaller type,\n \t do the arithmetic in that type and then extend."}, {"sha": "1f523be6bc709a10dd48e08af7643db892baf780", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ca862e9dd939d7dd686b771f401012fb9ed9bfe/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ca862e9dd939d7dd686b771f401012fb9ed9bfe/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=2ca862e9dd939d7dd686b771f401012fb9ed9bfe", "patch": "@@ -1,3 +1,15 @@\n+2009-05-08  Joseph Myers  <joseph@codesourcery.com>\n+\n+\tPR c/24581\n+\t* gcc.dg/torture/complex-sign.h: New header.\n+\t* gcc.dg/torture/complex-sign-add.c,\n+\tgcc.dg/torture/complex-sign-mixed-add.c,\n+\tgcc.dg/torture/complex-sign-mixed-div.c,\n+\tgcc.dg/torture/complex-sign-mixed-mul.c,\n+\tgcc.dg/torture/complex-sign-mixed-sub.c,\n+\tgcc.dg/torture/complex-sign-mul.c,\n+\tgcc.dg/torture/complex-sign-sub.c: New tests.\n+\n 2009-05-08  Janus Weil  <janus@gcc.gnu.org>\n \n \tPR fortran/39876"}, {"sha": "db92140667170e62a3e16c8626d9481290485873", "filename": "gcc/testsuite/gcc.dg/torture/complex-sign-add.c", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ca862e9dd939d7dd686b771f401012fb9ed9bfe/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fcomplex-sign-add.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ca862e9dd939d7dd686b771f401012fb9ed9bfe/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fcomplex-sign-add.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fcomplex-sign-add.c?ref=2ca862e9dd939d7dd686b771f401012fb9ed9bfe", "patch": "@@ -0,0 +1,53 @@\n+/* Test complex arithmetic with signed zeros.  Pure complex\n+   addition.  */\n+/* { dg-do run } */\n+/* { dg-options \"-std=gnu99\" } */\n+\n+#include \"complex-sign.h\"\n+\n+#define CHECK_ADD(TYPE, COPY, ZERO, ZEROI)\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\\\n+    CHECK_ARITH (TYPE, COPY, ZERO, ZEROI, +, +, +, +, +, +, +);\t\\\n+    CHECK_ARITH (TYPE, COPY, ZERO, ZEROI, +, +, +, +, -, +, +);\t\\\n+    CHECK_ARITH (TYPE, COPY, ZERO, ZEROI, +, +, +, -, +, +, +);\t\\\n+    CHECK_ARITH (TYPE, COPY, ZERO, ZEROI, +, +, +, -, -, +, +);\t\\\n+    CHECK_ARITH (TYPE, COPY, ZERO, ZEROI, +, +, -, +, +, +, +);\t\\\n+    CHECK_ARITH (TYPE, COPY, ZERO, ZEROI, +, +, -, +, -, +, -);\t\\\n+    CHECK_ARITH (TYPE, COPY, ZERO, ZEROI, +, +, -, -, +, +, +);\t\\\n+    CHECK_ARITH (TYPE, COPY, ZERO, ZEROI, +, +, -, -, -, +, -);\t\\\n+    CHECK_ARITH (TYPE, COPY, ZERO, ZEROI, +, -, +, +, +, +, +);\t\\\n+    CHECK_ARITH (TYPE, COPY, ZERO, ZEROI, +, -, +, +, -, +, +);\t\\\n+    CHECK_ARITH (TYPE, COPY, ZERO, ZEROI, +, -, +, -, +, -, +);\t\\\n+    CHECK_ARITH (TYPE, COPY, ZERO, ZEROI, +, -, +, -, -, -, +);\t\\\n+    CHECK_ARITH (TYPE, COPY, ZERO, ZEROI, +, -, -, +, +, +, +);\t\\\n+    CHECK_ARITH (TYPE, COPY, ZERO, ZEROI, +, -, -, +, -, +, -);\t\\\n+    CHECK_ARITH (TYPE, COPY, ZERO, ZEROI, +, -, -, -, +, -, +);\t\\\n+    CHECK_ARITH (TYPE, COPY, ZERO, ZEROI, +, -, -, -, -, -, -);\t\\\n+  } while (0)\n+\n+void\n+check_add_float (void)\n+{\n+  CHECK_ADD (float, __builtin_copysignf, 0.0f, 0.0if);\n+}\n+\n+void\n+check_add_double (void)\n+{\n+  CHECK_ADD (double, __builtin_copysign, 0.0, 0.0i);\n+}\n+\n+void\n+check_add_long_double (void)\n+{\n+  CHECK_ADD (long double, __builtin_copysignl, 0.0l, 0.0il);\n+}\n+\n+int\n+main (void)\n+{\n+  check_add_float ();\n+  check_add_double ();\n+  check_add_long_double ();\n+  exit (0);\n+}"}, {"sha": "5548fe431e8e735aa5bcc614ebacefad674286b8", "filename": "gcc/testsuite/gcc.dg/torture/complex-sign-mixed-add.c", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ca862e9dd939d7dd686b771f401012fb9ed9bfe/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fcomplex-sign-mixed-add.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ca862e9dd939d7dd686b771f401012fb9ed9bfe/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fcomplex-sign-mixed-add.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fcomplex-sign-mixed-add.c?ref=2ca862e9dd939d7dd686b771f401012fb9ed9bfe", "patch": "@@ -0,0 +1,53 @@\n+/* Test complex arithmetic with signed zeros.  Mixed real/complex\n+   addition.  */\n+/* { dg-do run } */\n+/* { dg-options \"-std=gnu99\" } */\n+\n+#include \"complex-sign.h\"\n+\n+#define CHECK_ADD(TYPE, COPY, ZERO, ZEROI)\t\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    CHECK_ARITH_RC (TYPE, COPY, ZERO, ZEROI, +, +, +, +, +, +);\t\t\\\n+    CHECK_ARITH_RC (TYPE, COPY, ZERO, ZEROI, +, +, +, -, +, -);\t\t\\\n+    CHECK_ARITH_RC (TYPE, COPY, ZERO, ZEROI, +, +, -, +, +, +);\t\t\\\n+    CHECK_ARITH_RC (TYPE, COPY, ZERO, ZEROI, +, +, -, -, +, -);\t\t\\\n+    CHECK_ARITH_RC (TYPE, COPY, ZERO, ZEROI, +, -, +, +, +, +);\t\t\\\n+    CHECK_ARITH_RC (TYPE, COPY, ZERO, ZEROI, +, -, +, -, +, -);\t\t\\\n+    CHECK_ARITH_RC (TYPE, COPY, ZERO, ZEROI, +, -, -, +, -, +);\t\t\\\n+    CHECK_ARITH_RC (TYPE, COPY, ZERO, ZEROI, +, -, -, -, -, -);\t\t\\\n+    CHECK_ARITH_CR (TYPE, COPY, ZERO, ZEROI, +, +, +, +, ZERO, +, +);\t\\\n+    CHECK_ARITH_CR (TYPE, COPY, ZERO, ZEROI, +, +, +, -, ZERO, +, +);\t\\\n+    CHECK_ARITH_CR (TYPE, COPY, ZERO, ZEROI, +, +, -, +, ZERO, +, -);\t\\\n+    CHECK_ARITH_CR (TYPE, COPY, ZERO, ZEROI, +, +, -, -, ZERO, +, -);\t\\\n+    CHECK_ARITH_CR (TYPE, COPY, ZERO, ZEROI, +, -, +, +, ZERO, +, +);\t\\\n+    CHECK_ARITH_CR (TYPE, COPY, ZERO, ZEROI, +, -, +, -, ZERO, -, +);\t\\\n+    CHECK_ARITH_CR (TYPE, COPY, ZERO, ZEROI, +, -, -, +, ZERO, +, -);\t\\\n+    CHECK_ARITH_CR (TYPE, COPY, ZERO, ZEROI, +, -, -, -, ZERO, -, -);\t\\\n+  } while (0)\n+\n+void\n+check_add_float (void)\n+{\n+  CHECK_ADD (float, __builtin_copysignf, 0.0f, 0.0if);\n+}\n+\n+void\n+check_add_double (void)\n+{\n+  CHECK_ADD (double, __builtin_copysign, 0.0, 0.0i);\n+}\n+\n+void\n+check_add_long_double (void)\n+{\n+  CHECK_ADD (long double, __builtin_copysignl, 0.0l, 0.0il);\n+}\n+\n+int\n+main (void)\n+{\n+  check_add_float ();\n+  check_add_double ();\n+  check_add_long_double ();\n+  exit (0);\n+}"}, {"sha": "4a315dcd529ebc7711c8d493e154f89013473d1b", "filename": "gcc/testsuite/gcc.dg/torture/complex-sign-mixed-div.c", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ca862e9dd939d7dd686b771f401012fb9ed9bfe/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fcomplex-sign-mixed-div.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ca862e9dd939d7dd686b771f401012fb9ed9bfe/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fcomplex-sign-mixed-div.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fcomplex-sign-mixed-div.c?ref=2ca862e9dd939d7dd686b771f401012fb9ed9bfe", "patch": "@@ -0,0 +1,45 @@\n+/* Test complex arithmetic with signed zeros.  Mixed real/complex\n+   division.  */\n+/* { dg-do run } */\n+/* { dg-options \"-std=gnu99\" } */\n+\n+#include \"complex-sign.h\"\n+\n+#define CHECK_DIV(TYPE, COPY, ZERO, ZEROI, ONE)\t\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    CHECK_ARITH_CR (TYPE, COPY, ZERO, ZEROI, /, +, +, +, ONE, +, +);\t\\\n+    CHECK_ARITH_CR (TYPE, COPY, ZERO, ZEROI, /, +, +, -, ONE, -, -);\t\\\n+    CHECK_ARITH_CR (TYPE, COPY, ZERO, ZEROI, /, +, -, +, ONE, +, -);\t\\\n+    CHECK_ARITH_CR (TYPE, COPY, ZERO, ZEROI, /, +, -, -, ONE, -, +);\t\\\n+    CHECK_ARITH_CR (TYPE, COPY, ZERO, ZEROI, /, -, +, +, ONE, -, +);\t\\\n+    CHECK_ARITH_CR (TYPE, COPY, ZERO, ZEROI, /, -, +, -, ONE, +, -);\t\\\n+    CHECK_ARITH_CR (TYPE, COPY, ZERO, ZEROI, /, -, -, +, ONE, -, -);\t\\\n+    CHECK_ARITH_CR (TYPE, COPY, ZERO, ZEROI, /, -, -, -, ONE, +, +);\t\\\n+  } while (0)\n+\n+void\n+check_div_float (void)\n+{\n+  CHECK_DIV (float, __builtin_copysignf, 0.0f, 0.0if, 1.0f);\n+}\n+\n+void\n+check_div_double (void)\n+{\n+  CHECK_DIV (double, __builtin_copysign, 0.0, 0.0i, 1.0);\n+}\n+\n+void\n+check_div_long_double (void)\n+{\n+  CHECK_DIV (long double, __builtin_copysignl, 0.0l, 0.0il, 1.0l);\n+}\n+\n+int\n+main (void)\n+{\n+  check_div_float ();\n+  check_div_double ();\n+  check_div_long_double ();\n+  exit (0);\n+}"}, {"sha": "f5b1fc47e2041f0ed784d96e49f96ceae3134963", "filename": "gcc/testsuite/gcc.dg/torture/complex-sign-mixed-mul.c", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ca862e9dd939d7dd686b771f401012fb9ed9bfe/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fcomplex-sign-mixed-mul.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ca862e9dd939d7dd686b771f401012fb9ed9bfe/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fcomplex-sign-mixed-mul.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fcomplex-sign-mixed-mul.c?ref=2ca862e9dd939d7dd686b771f401012fb9ed9bfe", "patch": "@@ -0,0 +1,53 @@\n+/* Test complex arithmetic with signed zeros.  Mixed real/complex\n+   multiplication.  */\n+/* { dg-do run } */\n+/* { dg-options \"-std=gnu99\" } */\n+\n+#include \"complex-sign.h\"\n+\n+#define CHECK_MUL(TYPE, COPY, ZERO, ZEROI)\t\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    CHECK_ARITH_RC (TYPE, COPY, ZERO, ZEROI, *, +, +, +, +, +);\t\t\\\n+    CHECK_ARITH_RC (TYPE, COPY, ZERO, ZEROI, *, +, +, -, +, -);\t\t\\\n+    CHECK_ARITH_RC (TYPE, COPY, ZERO, ZEROI, *, +, -, +, -, +);\t\t\\\n+    CHECK_ARITH_RC (TYPE, COPY, ZERO, ZEROI, *, +, -, -, -, -);\t\t\\\n+    CHECK_ARITH_RC (TYPE, COPY, ZERO, ZEROI, *, -, +, +, -, -);\t\t\\\n+    CHECK_ARITH_RC (TYPE, COPY, ZERO, ZEROI, *, -, +, -, -, +);\t\t\\\n+    CHECK_ARITH_RC (TYPE, COPY, ZERO, ZEROI, *, -, -, +, +, -);\t\t\\\n+    CHECK_ARITH_RC (TYPE, COPY, ZERO, ZEROI, *, -, -, -, +, +);\t\t\\\n+    CHECK_ARITH_CR (TYPE, COPY, ZERO, ZEROI, *, +, +, +, ZERO, +, +);\t\\\n+    CHECK_ARITH_CR (TYPE, COPY, ZERO, ZEROI, *, +, +, -, ZERO, -, -);\t\\\n+    CHECK_ARITH_CR (TYPE, COPY, ZERO, ZEROI, *, +, -, +, ZERO, +, -);\t\\\n+    CHECK_ARITH_CR (TYPE, COPY, ZERO, ZEROI, *, +, -, -, ZERO, -, +);\t\\\n+    CHECK_ARITH_CR (TYPE, COPY, ZERO, ZEROI, *, -, +, +, ZERO, -, +);\t\\\n+    CHECK_ARITH_CR (TYPE, COPY, ZERO, ZEROI, *, -, +, -, ZERO, +, -);\t\\\n+    CHECK_ARITH_CR (TYPE, COPY, ZERO, ZEROI, *, -, -, +, ZERO, -, -);\t\\\n+    CHECK_ARITH_CR (TYPE, COPY, ZERO, ZEROI, *, -, -, -, ZERO, +, +);\t\\\n+  } while (0)\n+\n+void\n+check_mul_float (void)\n+{\n+  CHECK_MUL (float, __builtin_copysignf, 0.0f, 0.0if);\n+}\n+\n+void\n+check_mul_double (void)\n+{\n+  CHECK_MUL (double, __builtin_copysign, 0.0, 0.0i);\n+}\n+\n+void\n+check_mul_long_double (void)\n+{\n+  CHECK_MUL (long double, __builtin_copysignl, 0.0l, 0.0il);\n+}\n+\n+int\n+main (void)\n+{\n+  check_mul_float ();\n+  check_mul_double ();\n+  check_mul_long_double ();\n+  exit (0);\n+}"}, {"sha": "adc384548c6e6e782b29a64129c8a8bfba339703", "filename": "gcc/testsuite/gcc.dg/torture/complex-sign-mixed-sub.c", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ca862e9dd939d7dd686b771f401012fb9ed9bfe/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fcomplex-sign-mixed-sub.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ca862e9dd939d7dd686b771f401012fb9ed9bfe/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fcomplex-sign-mixed-sub.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fcomplex-sign-mixed-sub.c?ref=2ca862e9dd939d7dd686b771f401012fb9ed9bfe", "patch": "@@ -0,0 +1,53 @@\n+/* Test complex arithmetic with signed zeros.  Mixed real/complex\n+   subtraction.  */\n+/* { dg-do run } */\n+/* { dg-options \"-std=gnu99\" } */\n+\n+#include \"complex-sign.h\"\n+\n+#define CHECK_SUB(TYPE, COPY, ZERO, ZEROI)\t\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    CHECK_ARITH_RC (TYPE, COPY, ZERO, ZEROI, -, +, +, +, +, -);\t\t\\\n+    CHECK_ARITH_RC (TYPE, COPY, ZERO, ZEROI, -, +, +, -, +, +);\t\t\\\n+    CHECK_ARITH_RC (TYPE, COPY, ZERO, ZEROI, -, +, -, +, +, -);\t\t\\\n+    CHECK_ARITH_RC (TYPE, COPY, ZERO, ZEROI, -, +, -, -, +, +);\t\t\\\n+    CHECK_ARITH_RC (TYPE, COPY, ZERO, ZEROI, -, -, +, +, -, -);\t\t\\\n+    CHECK_ARITH_RC (TYPE, COPY, ZERO, ZEROI, -, -, +, -, -, +);\t\t\\\n+    CHECK_ARITH_RC (TYPE, COPY, ZERO, ZEROI, -, -, -, +, +, -);\t\t\\\n+    CHECK_ARITH_RC (TYPE, COPY, ZERO, ZEROI, -, -, -, -, +, +);\t\t\\\n+    CHECK_ARITH_CR (TYPE, COPY, ZERO, ZEROI, -, +, +, +, ZERO, +, +);\t\\\n+    CHECK_ARITH_CR (TYPE, COPY, ZERO, ZEROI, -, +, +, -, ZERO, +, +);\t\\\n+    CHECK_ARITH_CR (TYPE, COPY, ZERO, ZEROI, -, +, -, +, ZERO, +, -);\t\\\n+    CHECK_ARITH_CR (TYPE, COPY, ZERO, ZEROI, -, +, -, -, ZERO, +, -);\t\\\n+    CHECK_ARITH_CR (TYPE, COPY, ZERO, ZEROI, -, -, +, +, ZERO, -, +);\t\\\n+    CHECK_ARITH_CR (TYPE, COPY, ZERO, ZEROI, -, -, +, -, ZERO, +, +);\t\\\n+    CHECK_ARITH_CR (TYPE, COPY, ZERO, ZEROI, -, -, -, +, ZERO, -, -);\t\\\n+    CHECK_ARITH_CR (TYPE, COPY, ZERO, ZEROI, -, -, -, -, ZERO, +, -);\t\\\n+  } while (0)\n+\n+void\n+check_sub_float (void)\n+{\n+  CHECK_SUB (float, __builtin_copysignf, 0.0f, 0.0if);\n+}\n+\n+void\n+check_sub_double (void)\n+{\n+  CHECK_SUB (double, __builtin_copysign, 0.0, 0.0i);\n+}\n+\n+void\n+check_sub_long_double (void)\n+{\n+  CHECK_SUB (long double, __builtin_copysignl, 0.0l, 0.0il);\n+}\n+\n+int\n+main (void)\n+{\n+  check_sub_float ();\n+  check_sub_double ();\n+  check_sub_long_double ();\n+  exit (0);\n+}"}, {"sha": "d9a06a5359bba9fa2e49d832fc2e4babbca8249a", "filename": "gcc/testsuite/gcc.dg/torture/complex-sign-mul.c", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ca862e9dd939d7dd686b771f401012fb9ed9bfe/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fcomplex-sign-mul.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ca862e9dd939d7dd686b771f401012fb9ed9bfe/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fcomplex-sign-mul.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fcomplex-sign-mul.c?ref=2ca862e9dd939d7dd686b771f401012fb9ed9bfe", "patch": "@@ -0,0 +1,53 @@\n+/* Test complex arithmetic with signed zeros.  Pure complex\n+   multiplication.  */\n+/* { dg-do run } */\n+/* { dg-options \"-std=gnu99\" } */\n+\n+#include \"complex-sign.h\"\n+\n+#define CHECK_MUL(TYPE, COPY, ZERO, ZEROI)\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\\\n+    CHECK_ARITH (TYPE, COPY, ZERO, ZEROI, *, +, +, +, +, +, +);\t\\\n+    CHECK_ARITH (TYPE, COPY, ZERO, ZEROI, *, +, +, +, -, +, +);\t\\\n+    CHECK_ARITH (TYPE, COPY, ZERO, ZEROI, *, +, +, -, +, -, +);\t\\\n+    CHECK_ARITH (TYPE, COPY, ZERO, ZEROI, *, +, +, -, -, +, -);\t\\\n+    CHECK_ARITH (TYPE, COPY, ZERO, ZEROI, *, +, -, +, +, +, +);\t\\\n+    CHECK_ARITH (TYPE, COPY, ZERO, ZEROI, *, +, -, +, -, +, -);\t\\\n+    CHECK_ARITH (TYPE, COPY, ZERO, ZEROI, *, +, -, -, +, +, +);\t\\\n+    CHECK_ARITH (TYPE, COPY, ZERO, ZEROI, *, +, -, -, -, -, +);\t\\\n+    CHECK_ARITH (TYPE, COPY, ZERO, ZEROI, *, -, +, +, +, -, +);\t\\\n+    CHECK_ARITH (TYPE, COPY, ZERO, ZEROI, *, -, +, +, -, +, +);\t\\\n+    CHECK_ARITH (TYPE, COPY, ZERO, ZEROI, *, -, +, -, +, +, -);\t\\\n+    CHECK_ARITH (TYPE, COPY, ZERO, ZEROI, *, -, +, -, -, +, +);\t\\\n+    CHECK_ARITH (TYPE, COPY, ZERO, ZEROI, *, -, -, +, +, +, -);\t\\\n+    CHECK_ARITH (TYPE, COPY, ZERO, ZEROI, *, -, -, +, -, -, +);\t\\\n+    CHECK_ARITH (TYPE, COPY, ZERO, ZEROI, *, -, -, -, +, +, +);\t\\\n+    CHECK_ARITH (TYPE, COPY, ZERO, ZEROI, *, -, -, -, -, +, +);\t\\\n+  } while (0)\n+\n+void\n+check_mul_float (void)\n+{\n+  CHECK_MUL (float, __builtin_copysignf, 0.0f, 0.0if);\n+}\n+\n+void\n+check_mul_double (void)\n+{\n+  CHECK_MUL (double, __builtin_copysign, 0.0, 0.0i);\n+}\n+\n+void\n+check_mul_long_double (void)\n+{\n+  CHECK_MUL (long double, __builtin_copysignl, 0.0l, 0.0il);\n+}\n+\n+int\n+main (void)\n+{\n+  check_mul_float ();\n+  check_mul_double ();\n+  check_mul_long_double ();\n+  exit (0);\n+}"}, {"sha": "94ab17d7fc6bb45d0a56206843fa167f800ab70b", "filename": "gcc/testsuite/gcc.dg/torture/complex-sign-sub.c", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ca862e9dd939d7dd686b771f401012fb9ed9bfe/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fcomplex-sign-sub.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ca862e9dd939d7dd686b771f401012fb9ed9bfe/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fcomplex-sign-sub.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fcomplex-sign-sub.c?ref=2ca862e9dd939d7dd686b771f401012fb9ed9bfe", "patch": "@@ -0,0 +1,53 @@\n+/* Test complex arithmetic with signed zeros.  Pure complex\n+   subtraction.  */\n+/* { dg-do run } */\n+/* { dg-options \"-std=gnu99\" } */\n+\n+#include \"complex-sign.h\"\n+\n+#define CHECK_SUB(TYPE, COPY, ZERO, ZEROI)\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\\\n+    CHECK_ARITH (TYPE, COPY, ZERO, ZEROI, -, +, +, +, +, +, +);\t\\\n+    CHECK_ARITH (TYPE, COPY, ZERO, ZEROI, -, +, +, +, -, +, +);\t\\\n+    CHECK_ARITH (TYPE, COPY, ZERO, ZEROI, -, +, +, -, +, +, +);\t\\\n+    CHECK_ARITH (TYPE, COPY, ZERO, ZEROI, -, +, +, -, -, +, +);\t\\\n+    CHECK_ARITH (TYPE, COPY, ZERO, ZEROI, -, +, -, +, +, +, -);\t\\\n+    CHECK_ARITH (TYPE, COPY, ZERO, ZEROI, -, +, -, +, -, +, +);\t\\\n+    CHECK_ARITH (TYPE, COPY, ZERO, ZEROI, -, +, -, -, +, +, -);\t\\\n+    CHECK_ARITH (TYPE, COPY, ZERO, ZEROI, -, +, -, -, -, +, +);\t\\\n+    CHECK_ARITH (TYPE, COPY, ZERO, ZEROI, -, -, +, +, +, -, +);\t\\\n+    CHECK_ARITH (TYPE, COPY, ZERO, ZEROI, -, -, +, +, -, -, +);\t\\\n+    CHECK_ARITH (TYPE, COPY, ZERO, ZEROI, -, -, +, -, +, +, +);\t\\\n+    CHECK_ARITH (TYPE, COPY, ZERO, ZEROI, -, -, +, -, -, +, +);\t\\\n+    CHECK_ARITH (TYPE, COPY, ZERO, ZEROI, -, -, -, +, +, -, -);\t\\\n+    CHECK_ARITH (TYPE, COPY, ZERO, ZEROI, -, -, -, +, -, -, +);\t\\\n+    CHECK_ARITH (TYPE, COPY, ZERO, ZEROI, -, -, -, -, +, +, -);\t\\\n+    CHECK_ARITH (TYPE, COPY, ZERO, ZEROI, -, -, -, -, -, +, +);\t\\\n+  } while (0)\n+\n+void\n+check_sub_float (void)\n+{\n+  CHECK_SUB (float, __builtin_copysignf, 0.0f, 0.0if);\n+}\n+\n+void\n+check_sub_double (void)\n+{\n+  CHECK_SUB (double, __builtin_copysign, 0.0, 0.0i);\n+}\n+\n+void\n+check_sub_long_double (void)\n+{\n+  CHECK_SUB (long double, __builtin_copysignl, 0.0l, 0.0il);\n+}\n+\n+int\n+main (void)\n+{\n+  check_sub_float ();\n+  check_sub_double ();\n+  check_sub_long_double ();\n+  exit (0);\n+}"}, {"sha": "f12e25d656fa91071d8677abd1047136ef178140", "filename": "gcc/testsuite/gcc.dg/torture/complex-sign.h", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ca862e9dd939d7dd686b771f401012fb9ed9bfe/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fcomplex-sign.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ca862e9dd939d7dd686b771f401012fb9ed9bfe/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fcomplex-sign.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fcomplex-sign.h?ref=2ca862e9dd939d7dd686b771f401012fb9ed9bfe", "patch": "@@ -0,0 +1,74 @@\n+/* Common header for complex arithmetic sign tests.  */\n+\n+extern void abort (void);\n+extern void exit (int);\n+\n+#define CHECK_RES(VALUE, COPY, SIGN_REAL, SIGN_IMAG)\t\t\\\n+  do {\t\t\t\t\t\t\t\t\\\n+    if ((VALUE) != 0\t\t\t\t\t\t\\\n+\t|| COPY (1.0, __real__ (VALUE)) != SIGN_REAL 1.0\t\\\n+\t|| COPY (1.0, __imag__ (VALUE)) != SIGN_IMAG 1.0)\t\\\n+      abort ();\t\t\t\t\t\t\t\\\n+  } while (0)\n+\n+/* This definition is intended to work with or without imaginary\n+   types, as long as mixed real/complex arithmetic is handled\n+   correctly.  */\n+#define ENCODE(ZERO, ZEROI, SA, SB)\t\t\t\\\n+  (SA 1 == 1\t\t\t\t\t\t\\\n+   ? SB 1 == 1 ? ZERO + ZEROI : ZERO - ZEROI\t\t\\\n+   : SB 1 == 1 ? -(ZERO - ZEROI) : -(ZERO + ZEROI))\n+\n+#define CHECK_ARITH(TYPE, COPY, ZERO, ZEROI, OP, S1, S2, S3, S4, SR, SI) \\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    _Complex TYPE a1, b1, c1;\t\t\t\t\t\t\\\n+    volatile _Complex TYPE a2, b2, c2;\t\t\t\t\t\\\n+    a1 = ENCODE(ZERO, ZEROI, S1, S2);\t\t\t\t\t\\\n+    CHECK_RES (a1, COPY, S1, S2);\t\t\t\t\t\\\n+    b1 = ENCODE(ZERO, ZEROI, S3, S4);\t\t\t\t\t\\\n+    CHECK_RES (b1, COPY, S3, S4);\t\t\t\t\t\\\n+    c1 = a1 OP b1;\t\t\t\t\t\t\t\\\n+    CHECK_RES (c1, COPY, SR, SI);\t\t\t\t\t\\\n+    a2 = ENCODE(ZERO, ZEROI, S1, S2);\t\t\t\t\t\\\n+    CHECK_RES (a2, COPY, S1, S2);\t\t\t\t\t\\\n+    b2 = ENCODE(ZERO, ZEROI, S3, S4);\t\t\t\t\t\\\n+    CHECK_RES (b2, COPY, S3, S4);\t\t\t\t\t\\\n+    c2 = a2 OP b2;\t\t\t\t\t\t\t\\\n+    CHECK_RES (c2, COPY, SR, SI);\t\t\t\t\t\\\n+  } while (0)\n+\n+#define CHECK_ARITH_RC(TYPE, COPY, ZERO, ZEROI, OP, S1, S3, S4, SR, SI) \\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    TYPE a1;\t\t\t\t\t\t\t\t\\\n+    _Complex TYPE b1, c1;\t\t\t\t\t\t\\\n+    volatile TYPE a2;\t\t\t\t\t\t\t\\\n+    volatile _Complex TYPE b2, c2;\t\t\t\t\t\\\n+    a1 = S1 ZERO;\t\t\t\t\t\t\t\\\n+    b1 = ENCODE(ZERO, ZEROI, S3, S4);\t\t\t\t\t\\\n+    CHECK_RES (b1, COPY, S3, S4);\t\t\t\t\t\\\n+    c1 = a1 OP b1;\t\t\t\t\t\t\t\\\n+    CHECK_RES (c1, COPY, SR, SI);\t\t\t\t\t\\\n+    a2 = S1 ZERO;\t\t\t\t\t\t\t\\\n+    b2 = ENCODE(ZERO, ZEROI, S3, S4);\t\t\t\t\t\\\n+    CHECK_RES (b2, COPY, S3, S4);\t\t\t\t\t\\\n+    c2 = a2 OP b2;\t\t\t\t\t\t\t\\\n+    CHECK_RES (c2, COPY, SR, SI);\t\t\t\t\t\\\n+  } while (0)\n+\n+#define CHECK_ARITH_CR(TYPE, COPY, ZERO, ZEROI, OP, S1, S2, S3, V3, SR, SI) \\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    _Complex TYPE a1, c1;\t\t\t\t\t\t\\\n+    TYPE b1;\t\t\t\t\t\t\t\t\\\n+    volatile _Complex TYPE a2, c2;\t\t\t\t\t\\\n+    volatile TYPE b2;\t\t\t\t\t\t\t\\\n+    a1 = ENCODE(ZERO, ZEROI, S1, S2);\t\t\t\t\t\\\n+    CHECK_RES (a1, COPY, S1, S2);\t\t\t\t\t\\\n+    b1 = S3 V3;\t\t\t\t\t\t\t\t\\\n+    c1 = a1 OP b1;\t\t\t\t\t\t\t\\\n+    CHECK_RES (c1, COPY, SR, SI);\t\t\t\t\t\\\n+    a2 = ENCODE(ZERO, ZEROI, S1, S2);\t\t\t\t\t\\\n+    CHECK_RES (a2, COPY, S1, S2);\t\t\t\t\t\\\n+    b2 = S3 V3;\t\t\t\t\t\t\t\t\\\n+    c2 = a2 OP b2;\t\t\t\t\t\t\t\\\n+    CHECK_RES (c2, COPY, SR, SI);\t\t\t\t\t\\\n+  } while (0)"}, {"sha": "2835220c206c940ab5cd425ebcbb72a3339912b9", "filename": "gcc/tree-complex.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ca862e9dd939d7dd686b771f401012fb9ed9bfe/gcc%2Ftree-complex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ca862e9dd939d7dd686b771f401012fb9ed9bfe/gcc%2Ftree-complex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-complex.c?ref=2ca862e9dd939d7dd686b771f401012fb9ed9bfe", "patch": "@@ -99,7 +99,10 @@ some_nonzerop (tree t)\n {\n   int zerop = false;\n \n-  if (TREE_CODE (t) == REAL_CST)\n+  /* Operations with real or imaginary part of a complex number zero\n+     cannot be treated the same as operations with a real or imaginary\n+     operand if we care about the signs of zeros in the result.  */\n+  if (TREE_CODE (t) == REAL_CST && !flag_signed_zeros)\n     zerop = REAL_VALUES_IDENTICAL (TREE_REAL_CST (t), dconst0);\n   else if (TREE_CODE (t) == FIXED_CST)\n     zerop = fixed_zerop (t);"}]}