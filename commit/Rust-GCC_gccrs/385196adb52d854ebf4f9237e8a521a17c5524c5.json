{"sha": "385196adb52d854ebf4f9237e8a521a17c5524c5", "node_id": "C_kwDOANBUbNoAKDM4NTE5NmFkYjUyZDg1NGViZjRmOTIzN2U4YTUyMWExN2M1NTI0YzU", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2022-01-24T10:50:15Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2022-01-24T10:50:15Z"}, "message": "options: Add EnumSet and Set property support [PR104158]\n\nThe following patch is infrastructure support for at least 3 different\noptions that need changes:\n1) PR104158 talks about a regression with the -fsanitizer-coverage=\n   option; in GCC 11 and older and on trunk prior to r12-1177, this\n   option behaved similarly to -f{,no-}sanitizer{,-recover}= options,\n   namely that the option allows negative and argument of the option\n   is a list of strings, each of them has some enumerator and\n   -fsanitize-coverage= enabled those bits in the underlying\n   flag_sanitize_coverage, while -fno-sanitize-coverage= disabled them.\n   So, -fsanitize-coverage=trace-pc,trace-cmp was equivalent to\n   -fsanitize-coverage=trace-pc -fsanitize-coverage=trace-cmp and both\n   set flag_sanitize_coverage to\n   (SANITIZE_COV_TRACE_PC | SANITIZE_COV_TRACE_CMP)\n   Also, e.g.\n   -fsanitize-coverage=trace-pc,trace-cmp -fno-sanitize-coverage=trace-pc\n   would in the end set flag_sanitize_coverage to\n   SANITIZE_COV_TRACE_CMP (first set both bits, then subtract one)\n   The r12-1177 change, I think done to improve argument misspelling\n   diagnostic, changed the option incompatibly in multiple ways,\n   -fno-sanitize-coverage= is now rejected, only a single argument\n   is allowed, not multiple and\n   -fsanitize-coverage=trace-pc -fsanitize-coverage=trace-cmp\n   enables just SANITIZE_COV_TRACE_CMP and not both (each option\n   overrides the previous value)\n2) Thomas Koenig wants to extend Fortran -fconvert= option for the\n   ppc64le real(kind=16) swapping support; currently the option\n   accepts -fconvert={native,swap,big-endian,little-endian} and the\n   intent is to add support for -fconvert=r16_ibm and -fconvert=r16_ieee\n   (that alone is just normal Enum), but also to handle\n   -fconvert=swap,r16_ieee or -fconvert=r16_ieee,big-endian but not\n   -fconvert=big-endian,little-endian - the\n   native/swap/big-endian/little-endian are one mutually exclusive set\n   and r16_ieee/r16_ibm another one.\n   See https://gcc.gnu.org/pipermail/gcc-patches/2022-January/587943.html\n   and thread around that.\n3) Similarly Marek Polacek wants to extend the -Wbidi-chars= option,\n   such that it will handle not just the current\n   -Wbidi-chars={none,bidirectional,any}, but also -Wbidi-chars=ucn\n   and bidirectional,ucn and ucn,any etc.  Again two separate sets,\n   one none/bidirectional/any and another one ucn.\n   See https://gcc.gnu.org/pipermail/gcc-patches/2022-January/588960.html\n\nThe following patch adds framework for this and I'll post incremental\npatches for 1) and 2).\nAs I've tried to document, such options are marked by additional\nEnumSet property on the option and in that case all the EnumValues\nin the Enum referenced from it must use a new Set property with set\nnumber (initially I wanted just mark last enumerator in each mutually\nexclusive set, but optionlist is sorted and so it doesn't really work\nwell).  So e.g. for the Fortran -fconvert=, one specifies:\nfconvert=\nFortran RejectNegative Joined Enum(gfc_convert) EnumSet Var(flag_convert) Init(GFC_FLAG_CONVERT_NATIVE)\n-fconvert=<big-endian|little-endian|native|swap|r16_ieee|r16_ibm>      The endianness used for unformatted files.\n\nEnum\nName(gfc_convert) Type(enum gfc_convert) UnknownError(Unrecognized option to endianness value: %qs)\n\nEnumValue\nEnum(gfc_convert) String(big-endian) Value(GFC_FLAG_CONVERT_BIG) Set(1)\n\nEnumValue\nEnum(gfc_convert) String(little-endian) Value(GFC_FLAG_CONVERT_LITTLE) Set(1)\n\nEnumValue\nEnum(gfc_convert) String(native) Value(GFC_FLAG_CONVERT_NATIVE) Set(1)\n\nEnumValue\nEnum(gfc_convert) String(swap) Value(GFC_FLAG_CONVERT_SWAP) Set(1)\n\nEnumValue\nEnum(gfc_convert) String(r16_ieee) Value(GFC_FLAG_CONVERT_R16_IEEE) Set(2)\n\nEnumValue\nEnum(gfc_convert) String(r16_ibm) Value(GFC_FLAG_CONVERT_R16_IBM) Set(2)\n\nand this says to the option handling code that\n1) if only one arg is specified to one instance of the option, it can be any\nof those 6\n2) if two args are specified, one has to be from the first 4 and another\nfrom the last 2, in any order\n3) at most 2 args may be specified (there are just 2 sets)\n\nThere is a requirement on the Value values checked in self-test, the\nvalues from one set ored together must be disjunct from values from\nanother set ored together.  In the Fortran case, the first 4 are 0-3\nso mask is 3, and the last 2 are 4 and 8, so mask is 12.\nWhen say -fconvert=big-endian is specified, it sets the first set\nto GFC_FLAG_CONVERT_BIG (2) but doesn't modify whatever value the\nother set had, so e.g.\n-fconvert=big-endian -fconvert=r16_ieee\n-fconvert=r16_ieee -fconvert=big-endian\n-fconvert=r16_ieee,big_endian\n-fconvert=big_endian,r16_ieee\nall behave the same.\n\nAlso, with the EnumSet support, it is now possible to allow\nnot specifying RejectNegative - we can set some set's value and\nthen clear it and set it again to some other value etc.\n\nI think with the 2) patch I achieve what we want for Fortran, for 1)\nthe only behavior from gcc 11 is that\n-fsanitize-coverage=trace-cmp,trace-cmp is now rejected.\nThis is mainly from the desire to disallow\n-fconvert=big-endian,little-endian or -Wbidi-chars=bidirectional,any\netc. where it would be confusing to users what exactly it means.\nBut it is the only from these options that actually acts as an Enum\nbit set, each enumerator can be specified with all the others.\nSo one option would be stop requiring the EnumSet implies Set properties\nmust be specified and just require that either they are specified on all\nEnumValues, or on none of them; the latter case would be for\n-fsanitize-coverage= and the non-Set case would mean that all the\nEnumValues need to have disjoint Value bitmasks and that they can\nbe all specified and unlike the Set case also repeated.\nThoughts on this?\n\n2022-01-24  Jakub Jelinek  <jakub@redhat.com>\n\n\tPR sanitizer/104158\n\t* opt-functions.awk (var_set): Handle EnumSet property.\n\t* optc-gen.awk: Don't disallow RejectNegative if EnumSet is\n\tspecified.\n\t* opt-read.awk: Handle Set property.\n\t* opts.h (CL_ENUM_SET_SHIFT, CL_ERR_ENUM_SET_ARG): Define.\n\t(struct cl_decoded_option): Mention enum in value description.\n\tAdd mask member.\n\t(set_option): Add mask argument defaulted to 0.\n\t* opts.cc (test_enum_sets): New function.\n\t(opts_cc_tests): Call it.\n\t* opts-common.cc (enum_arg_to_value): Change return argument\n\tfrom bool to int, on success return index into the cl_enum_arg\n\tarray, on failure -1.  Add len argument, if non-0, use strncmp\n\tinstead of strcmp.\n\t(opt_enum_arg_to_value): Adjust caller.\n\t(decode_cmdline_option): Handle EnumSet represented as\n\tCLVC_ENUM with non-zero var_value.  Initialize decoded->mask.\n\t(decode_cmdline_options_to_array): CLear opt_array[0].mask.\n\t(handle_option): Pass decoded->mask to set_options last argument.\n\t(generate_option): Clear decoded->mask.\n\t(generate_option_input_file): Likewise.\n\t(cmdline_handle_error): Handle CL_ERR_ENUM_SET_ARG.\n\t(set_option): Add mask argument, use it for CLVC_ENUM.\n\t(control_warning_option): Adjust enum_arg_to_value caller.\n\t* doc/options.texi: Document Set and EnumSet properties.", "tree": {"sha": "a778a1a0908bb08e591a79a7dd1022a7b42c9fd7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a778a1a0908bb08e591a79a7dd1022a7b42c9fd7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/385196adb52d854ebf4f9237e8a521a17c5524c5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/385196adb52d854ebf4f9237e8a521a17c5524c5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/385196adb52d854ebf4f9237e8a521a17c5524c5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/385196adb52d854ebf4f9237e8a521a17c5524c5/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2c31a8be4a5db11a0a0e97c366dded6362421086", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c31a8be4a5db11a0a0e97c366dded6362421086", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2c31a8be4a5db11a0a0e97c366dded6362421086"}], "stats": {"total": 252, "additions": 233, "deletions": 19}, "files": [{"sha": "9387c82cd3d3b24002c8e41133dc25db0a9da949", "filename": "gcc/doc/options.texi", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/385196adb52d854ebf4f9237e8a521a17c5524c5/gcc%2Fdoc%2Foptions.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/385196adb52d854ebf4f9237e8a521a17c5524c5/gcc%2Fdoc%2Foptions.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Foptions.texi?ref=385196adb52d854ebf4f9237e8a521a17c5524c5", "patch": "@@ -132,6 +132,21 @@ be accepted by the driver.  This is used for cases such as\n @option{-march=native} that are processed by the driver so that\n @samp{gcc -v} shows how the options chosen depended on the system on\n which the compiler was run.\n+\n+@item Set(@var{number})\n+This property is optional, required for enumerations used in\n+@code{EnumSet} options.  @var{number} should be decimal number between\n+1 and 64 inclusive and divides the enumeration into a set of\n+sets of mutually exclusive arguments.  Arguments with the same\n+@var{number} can't be specified together in the same option, but\n+arguments with different @var{number} can.  @var{value} needs to be\n+chosen such that a mask of all @var{value} values from the same set\n+@var{number} bitwise ored doesn't overlap with masks for other sets.\n+When @code{-foption=arg_from_set1,arg_from_set4} and\n+@code{-fno-option=arg_from_set3} are used, the effect is that previous\n+value of the @code{Var} will get bits from set 1 and 4 masks cleared,\n+ored @code{Value} of @code{arg_from_set1} and @code{arg_from_set4}\n+and then will get bits from set 3 mask cleared.\n @end table\n \n @item\n@@ -396,6 +411,16 @@ with the corresponding @samp{Enum} record.  The string is checked and\n converted to the integer specified in the corresponding\n @samp{EnumValue} record before being passed to option handlers.\n \n+@item EnumSet\n+Must be used together with the @code{Enum(@var{name})} property.\n+Corresponding @samp{Enum} record must use @code{Set} properties.\n+The option's argument is either a string from the set like for\n+@code{Enum(@var{name})}, but with a slightly different behavior that\n+the whole @code{Var} isn't overwritten, but only the bits in all the\n+enumeration values with the same set bitwise ored together.\n+Or option's argument can be a comma separated list of strings where\n+each string is from a different @code{Set(@var{number})}.\n+\n @item Defer\n The option should be stored in a vector, specified with @code{Var},\n for later processing."}, {"sha": "b2b11bee25e116bc2aa635438abe1ded622b4402", "filename": "gcc/opt-functions.awk", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/385196adb52d854ebf4f9237e8a521a17c5524c5/gcc%2Fopt-functions.awk", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/385196adb52d854ebf4f9237e8a521a17c5524c5/gcc%2Fopt-functions.awk", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopt-functions.awk?ref=385196adb52d854ebf4f9237e8a521a17c5524c5", "patch": "@@ -297,7 +297,10 @@ function var_set(flags)\n \t}\n \tif (flag_set_p(\"Enum.*\", flags)) {\n \t\ten = opt_args(\"Enum\", flags);\n-\t\treturn enum_index[en] \", CLVC_ENUM, 0\"\n+\t\tif (flag_set_p(\"EnumSet\", flags))\n+\t\t\treturn enum_index[en] \", CLVC_ENUM, 1\"\n+\t\telse\n+\t\t\treturn enum_index[en] \", CLVC_ENUM, 0\"\n \t}\n \tif (var_type(flags) == \"const char *\")\n \t\treturn \"0, CLVC_STRING, 0\""}, {"sha": "ce3617c8d4aa11db8531e8ba703636ecccf9b7f6", "filename": "gcc/opt-read.awk", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/385196adb52d854ebf4f9237e8a521a17c5524c5/gcc%2Fopt-read.awk", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/385196adb52d854ebf4f9237e8a521a17c5524c5/gcc%2Fopt-read.awk", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopt-read.awk?ref=385196adb52d854ebf4f9237e8a521a17c5524c5", "patch": "@@ -97,10 +97,14 @@ BEGIN {\n \t\t\tenum_name = opt_args_non_empty(\"Enum\", props)\n \t\t\tstring = opt_args_non_empty(\"String\", props)\n \t\t\tvalue = opt_args_non_empty(\"Value\", props)\n+\t\t\tset = opt_args(\"Set\", props)\n \t\t\tval_flags = \"0\"\n \t\t\tval_flags = val_flags \\\n \t\t\t  test_flag(\"Canonical\", props, \"| CL_ENUM_CANONICAL\") \\\n \t\t\t  test_flag(\"DriverOnly\", props, \"| CL_ENUM_DRIVER_ONLY\")\n+\t\t\tif (set != \"\")\n+\t\t\t\tval_flags = val_flags \"| ((\" set \\\n+\t\t\t\t\t    \") << CL_ENUM_SET_SHIFT)\"\n \t\t\tenum_data[enum_name] = enum_data[enum_name] \\\n \t\t\t  \"  { \" quote string quote \", \" value \", \" val_flags \\\n \t\t\t  \" },\\n\""}, {"sha": "d7c8e2b80a754601c8cf79d1d77eb5a59b3b5012", "filename": "gcc/optc-gen.awk", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/385196adb52d854ebf4f9237e8a521a17c5524c5/gcc%2Foptc-gen.awk", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/385196adb52d854ebf4f9237e8a521a17c5524c5/gcc%2Foptc-gen.awk", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptc-gen.awk?ref=385196adb52d854ebf4f9237e8a521a17c5524c5", "patch": "@@ -348,6 +348,7 @@ for (i = 0; i < n_opts; i++) {\n \t\t\talias_data = \"NULL, NULL, N_OPTS\"\n \t\tif (flag_set_p(\"Enum.*\", flags[i])) {\n \t\t\tif (!flag_set_p(\"RejectNegative\", flags[i]) \\\n+\t\t\t    && !flag_set_p(\"EnumSet\", flags[i]) \\\n \t\t\t    && opts[i] ~ \"^[Wfgm]\")\n \t\t\t\tprint \"#error Enum allowing negative form\"\n \t\t}"}, {"sha": "fb5d953968cc34dd66bf61680d82f25da8c33ec8", "filename": "gcc/opts-common.cc", "status": "modified", "additions": 145, "deletions": 16, "changes": 161, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/385196adb52d854ebf4f9237e8a521a17c5524c5/gcc%2Fopts-common.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/385196adb52d854ebf4f9237e8a521a17c5524c5/gcc%2Fopts-common.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts-common.cc?ref=385196adb52d854ebf4f9237e8a521a17c5524c5", "patch": "@@ -289,26 +289,29 @@ enum_arg_ok_for_language (const struct cl_enum_arg *enum_arg,\n   return (lang_mask & CL_DRIVER) || !(enum_arg->flags & CL_ENUM_DRIVER_ONLY);\n }\n \n-/* Look up ARG in ENUM_ARGS for language LANG_MASK, returning true and\n-   storing the value in *VALUE if found, and returning false without\n+/* Look up ARG in ENUM_ARGS for language LANG_MASK, returning the cl_enum_arg\n+   index and storing the value in *VALUE if found, and returning -1 without\n    modifying *VALUE if not found.  */\n \n-static bool\n+static int\n enum_arg_to_value (const struct cl_enum_arg *enum_args,\n-\t\t   const char *arg, HOST_WIDE_INT *value,\n+\t\t   const char *arg, size_t len, HOST_WIDE_INT *value,\n \t\t   unsigned int lang_mask)\n {\n   unsigned int i;\n \n   for (i = 0; enum_args[i].arg != NULL; i++)\n-    if (strcmp (arg, enum_args[i].arg) == 0\n+    if ((len\n+\t ? (strncmp (arg, enum_args[i].arg, len) == 0\n+\t    && enum_args[i].arg[len] == '\\0')\n+\t : strcmp (arg, enum_args[i].arg) == 0)\n \t&& enum_arg_ok_for_language (&enum_args[i], lang_mask))\n       {\n \t*value = enum_args[i].value;\n-\treturn true;\n+\treturn i;\n       }\n \n-  return false;\n+  return -1;\n }\n \n /* Look up ARG in the enum used by option OPT_INDEX for language\n@@ -324,8 +327,8 @@ opt_enum_arg_to_value (size_t opt_index, const char *arg,\n   gcc_assert (option->var_type == CLVC_ENUM);\n \n   HOST_WIDE_INT wideval;\n-  if (enum_arg_to_value (cl_enums[option->var_enum].values, arg,\n-\t\t\t &wideval, lang_mask))\n+  if (enum_arg_to_value (cl_enums[option->var_enum].values, arg, 0,\n+\t\t\t &wideval, lang_mask) >= 0)\n     {\n       *value = wideval;\n       return true;\n@@ -534,7 +537,7 @@ decode_cmdline_option (const char *const *argv, unsigned int lang_mask,\n {\n   size_t opt_index;\n   const char *arg = 0;\n-  HOST_WIDE_INT value = 1;\n+  HOST_WIDE_INT value = 1, mask = 0;\n   unsigned int result = 1, i, extra_args, separate_args = 0;\n   int adjust_len = 0;\n   size_t total_len;\n@@ -808,8 +811,56 @@ decode_cmdline_option (const char *const *argv, unsigned int lang_mask,\n     {\n       const struct cl_enum *e = &cl_enums[option->var_enum];\n \n-      gcc_assert (value == 1);\n-      if (enum_arg_to_value (e->values, arg, &value, lang_mask))\n+      gcc_assert (option->var_value || value == 1);\n+      if (option->var_value)\n+\t{\n+\t  const char *p = arg;\n+\t  HOST_WIDE_INT sum_value = 0;\n+\t  unsigned HOST_WIDE_INT used_sets = 0;\n+\t  do\n+\t    {\n+\t      const char *q = strchr (p, ',');\n+\t      HOST_WIDE_INT this_value = 0;\n+\t      if (q && q == p)\n+\t\t{\n+\t\t  errors |= CL_ERR_ENUM_SET_ARG;\n+\t\t  break;\n+\t\t}\n+\t      int idx = enum_arg_to_value (e->values, p, q ? q - p : 0,\n+\t\t\t\t\t   &this_value, lang_mask);\n+\t      if (idx < 0)\n+\t\t{\n+\t\t  errors |= CL_ERR_ENUM_SET_ARG;\n+\t\t  break;\n+\t\t}\n+\n+\t      unsigned set = e->values[idx].flags >> CL_ENUM_SET_SHIFT;\n+\t      gcc_checking_assert (set >= 1 && set <= HOST_BITS_PER_WIDE_INT);\n+\t      if ((used_sets & (HOST_WIDE_INT_1U << (set - 1))) != 0)\n+\t\t{\n+\t\t  errors |= CL_ERR_ENUM_SET_ARG;\n+\t\t  break;\n+\t\t}\n+\t      used_sets |= HOST_WIDE_INT_1U << (set - 1);\n+\n+\t      HOST_WIDE_INT this_mask = 0;\n+\t      for (int i = 0; e->values[i].arg != NULL; i++)\n+\t\tif (set == (e->values[i].flags >> CL_ENUM_SET_SHIFT))\n+\t\t  this_mask |= e->values[i].value;\n+\n+\t      sum_value |= this_value;\n+\t      mask |= this_mask;\n+\t      if (q == NULL)\n+\t\tbreak;\n+\t      p = q + 1;\n+\t    }\n+\t  while (1);\n+\t  if (value == 1)\n+\t    value = sum_value;\n+\t  else\n+\t    gcc_checking_assert (value == 0);\n+\t}\n+      else if (enum_arg_to_value (e->values, arg, 0, &value, lang_mask) >= 0)\n \t{\n \t  const char *carg = NULL;\n \n@@ -825,6 +876,7 @@ decode_cmdline_option (const char *const *argv, unsigned int lang_mask,\n   decoded->opt_index = opt_index;\n   decoded->arg = arg;\n   decoded->value = value;\n+  decoded->mask = mask;\n   decoded->errors = errors;\n   decoded->warn_message = warn_message;\n \n@@ -958,6 +1010,7 @@ decode_cmdline_options_to_array (unsigned int argc, const char **argv,\n   opt_array[0].canonical_option[2] = NULL;\n   opt_array[0].canonical_option[3] = NULL;\n   opt_array[0].value = 1;\n+  opt_array[0].mask = 0;\n   opt_array[0].errors = 0;\n   num_decoded_options = 1;\n \n@@ -1167,13 +1220,14 @@ handle_option (struct gcc_options *opts,\n   size_t opt_index = decoded->opt_index;\n   const char *arg = decoded->arg;\n   HOST_WIDE_INT value = decoded->value;\n+  HOST_WIDE_INT mask = decoded->mask;\n   const struct cl_option *option = &cl_options[opt_index];\n   void *flag_var = option_flag_var (opt_index, opts);\n   size_t i;\n \n   if (flag_var)\n     set_option (opts, (generated_p ? NULL : opts_set),\n-\t\topt_index, value, arg, kind, loc, dc);\n+\t\topt_index, value, arg, kind, loc, dc, mask);\n \n   for (i = 0; i < handlers->num_handlers; i++)\n     if (option->flags & handlers->handlers[i].mask)\n@@ -1222,6 +1276,7 @@ generate_option (size_t opt_index, const char *arg, HOST_WIDE_INT value,\n   decoded->warn_message = NULL;\n   decoded->arg = arg;\n   decoded->value = value;\n+  decoded->mask = 0;\n   decoded->errors = (option_ok_for_language (option, lang_mask)\n \t\t     ? 0\n \t\t     : CL_ERR_WRONG_LANG);\n@@ -1260,6 +1315,7 @@ generate_option_input_file (const char *file,\n   decoded->canonical_option[2] = NULL;\n   decoded->canonical_option[3] = NULL;\n   decoded->value = 1;\n+  decoded->mask = 0;\n   decoded->errors = 0;\n }\n \n@@ -1342,6 +1398,74 @@ cmdline_handle_error (location_t loc, const struct cl_option *option,\n       return true;\n     }\n \n+  if (errors & CL_ERR_ENUM_SET_ARG)\n+    {\n+      const struct cl_enum *e = &cl_enums[option->var_enum];\n+      const char *p = arg;\n+      unsigned HOST_WIDE_INT used_sets = 0;\n+      const char *second_opt = NULL;\n+      size_t second_opt_len = 0;\n+      errors = 0;\n+      do\n+\t{\n+\t  const char *q = strchr (p, ',');\n+\t  HOST_WIDE_INT this_value = 0;\n+\t  if (q && q == p)\n+\t    {\n+\t      arg = \"\";\n+\t      errors = CL_ERR_ENUM_ARG;\n+\t      break;\n+\t    }\n+\t  int idx = enum_arg_to_value (e->values, p, q ? q - p : 0,\n+\t\t\t\t       &this_value, lang_mask);\n+\t  if (idx < 0)\n+\t    {\n+\t      if (q == NULL)\n+\t\tq = strchr (p, '\\0');\n+\t      char *narg = XALLOCAVEC (char, (q - p) + 1);\n+\t      memcpy (narg, p, q - p);\n+\t      narg[q - p] = '\\0';\n+\t      arg = narg;\n+\t      errors = CL_ERR_ENUM_ARG;\n+\t      break;\n+\t    }\n+\n+\t  unsigned set = e->values[idx].flags >> CL_ENUM_SET_SHIFT;\n+\t  gcc_checking_assert (set >= 1 && set <= HOST_BITS_PER_WIDE_INT);\n+\t  if ((used_sets & (HOST_WIDE_INT_1U << (set - 1))) != 0)\n+\t    {\n+\t      if (q == NULL)\n+\t\tq = strchr (p, '\\0');\n+\t      if (second_opt == NULL)\n+\t\t{\n+\t\t  used_sets = HOST_WIDE_INT_1U << (set - 1);\n+\t\t  second_opt = p;\n+\t\t  second_opt_len = q - p;\n+\t\t  p = arg;\n+\t\t  continue;\n+\t\t}\n+\t      char *args = XALLOCAVEC (char, (q - p) + 1 + second_opt_len + 1);\n+\t      memcpy (args, p, q - p);\n+\t      args[q - p] = '\\0';\n+\t      memcpy (args + (q - p) + 1, second_opt, second_opt_len);\n+\t      args[(q - p) + 1 + second_opt_len] = '\\0';\n+\t      error_at (loc, \"invalid argument in option %qs\", opt);\n+\t      if (strcmp (args, args + (q - p) + 1) == 0)\n+\t\tinform (loc, \"%qs specified multiple times in the same option\",\n+\t\t\targs);\n+\t      else\n+\t\tinform (loc, \"%qs is mutually exclusive with %qs and cannot be\"\n+\t\t\t     \" specified together\", args, args + (q - p) + 1);\n+\t      return true;\n+\t    }\n+\t  used_sets |= HOST_WIDE_INT_1U << (set - 1);\n+\t  if (q == NULL)\n+\t    break;\n+\t  p = q + 1;\n+\t}\n+      while (1);\n+    }\n+\n   if (errors & CL_ERR_ENUM_ARG)\n     {\n       const struct cl_enum *e = &cl_enums[option->var_enum];\n@@ -1441,7 +1565,8 @@ read_cmdline_option (struct gcc_options *opts,\n void\n set_option (struct gcc_options *opts, struct gcc_options *opts_set,\n \t    int opt_index, HOST_WIDE_INT value, const char *arg, int kind,\n-\t    location_t loc, diagnostic_context *dc)\n+\t    location_t loc, diagnostic_context *dc,\n+\t    HOST_WIDE_INT mask /* = 0 */)\n {\n   const struct cl_option *option = &cl_options[opt_index];\n   void *flag_var = option_flag_var (opt_index, opts);\n@@ -1550,7 +1675,10 @@ set_option (struct gcc_options *opts, struct gcc_options *opts_set,\n       {\n \tconst struct cl_enum *e = &cl_enums[option->var_enum];\n \n-\te->set (flag_var, value);\n+\tif (mask)\n+\t  e->set (flag_var, value | (e->get (flag_var) & ~mask));\n+\telse\n+\t  e->set (flag_var, value);\n \tif (set_flag_var)\n \t  e->set (set_flag_var, 1);\n       }\n@@ -1767,7 +1895,8 @@ control_warning_option (unsigned int opt_index, int kind, const char *arg,\n \t    {\n \t      const struct cl_enum *e = &cl_enums[option->var_enum];\n \n-\t      if (enum_arg_to_value (e->values, arg, &value, lang_mask))\n+\t      if (enum_arg_to_value (e->values, arg, 0, &value,\n+\t\t\t\t     lang_mask) >= 0)\n \t\t{\n \t\t  const char *carg = NULL;\n "}, {"sha": "733f3943871317765280747161b6d52fd76124fd", "filename": "gcc/opts.cc", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/385196adb52d854ebf4f9237e8a521a17c5524c5/gcc%2Fopts.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/385196adb52d854ebf4f9237e8a521a17c5524c5/gcc%2Fopts.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.cc?ref=385196adb52d854ebf4f9237e8a521a17c5524c5", "patch": "@@ -3709,12 +3709,56 @@ test_get_option_html_page ()\n #endif\n }\n \n+/* Verify EnumSet requirements.  */\n+\n+static void\n+test_enum_sets ()\n+{\n+  for (unsigned i = 0; i < cl_options_count; ++i)\n+    if (cl_options[i].var_type == CLVC_ENUM && cl_options[i].var_value)\n+      {\n+\tconst struct cl_enum *e = &cl_enums[cl_options[i].var_enum];\n+\tunsigned HOST_WIDE_INT used_sets = 0;\n+\tunsigned HOST_WIDE_INT mask = 0;\n+\tunsigned highest_set = 0;\n+\tfor (unsigned j = 0; e->values[j].arg; ++j)\n+\t  {\n+\t    unsigned set = e->values[j].flags >> CL_ENUM_SET_SHIFT;\n+\t    /* Test that enumerators referenced in EnumSet have all\n+\t       Set(n) on them within the valid range.  */\n+\t    ASSERT_TRUE (set >= 1 && set <= HOST_BITS_PER_WIDE_INT);\n+\t    highest_set = MAX (set, highest_set);\n+\t    used_sets |= HOST_WIDE_INT_1U << (set - 1);\n+\t  }\n+\t/* If there is just one set, no point to using EnumSet.  */\n+\tASSERT_TRUE (highest_set >= 2);\n+\t/* Test that there are no gaps in between the sets.  */\n+\tif (highest_set == HOST_BITS_PER_WIDE_INT)\n+\t  ASSERT_TRUE (used_sets == HOST_WIDE_INT_M1U);\n+\telse\n+\t  ASSERT_TRUE (used_sets == (HOST_WIDE_INT_1U << highest_set) - 1);\n+\tfor (unsigned int j = 1; j <= highest_set; ++j)\n+\t  {\n+\t    unsigned HOST_WIDE_INT this_mask = 0;\n+\t    for (unsigned k = 0; e->values[k].arg; ++k)\n+\t      {\n+\t\tunsigned set = e->values[j].flags >> CL_ENUM_SET_SHIFT;\n+\t\tif (set == j)\n+\t\t  this_mask |= e->values[j].value;\n+\t      }\n+\t    ASSERT_TRUE ((mask & this_mask) == 0);\n+\t    mask |= this_mask;\n+\t  }\n+      }\n+}\n+\n /* Run all of the selftests within this file.  */\n \n void\n opts_cc_tests ()\n {\n   test_get_option_html_page ();\n+  test_enum_sets ();\n }\n \n } // namespace selftest"}, {"sha": "88fabf9fddc069d89f4558dbba2e1e5abed7bd80", "filename": "gcc/opts.h", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/385196adb52d854ebf4f9237e8a521a17c5524c5/gcc%2Fopts.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/385196adb52d854ebf4f9237e8a521a17c5524c5/gcc%2Fopts.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.h?ref=385196adb52d854ebf4f9237e8a521a17c5524c5", "patch": "@@ -170,6 +170,7 @@ extern const unsigned int cl_lang_count;\n /* Flags for an enumerated option argument.  */\n #define CL_ENUM_CANONICAL\t(1 << 0) /* Canonical for this value.  */\n #define CL_ENUM_DRIVER_ONLY\t(1 << 1) /* Only accepted in the driver.  */\n+#define CL_ENUM_SET_SHIFT\t2\t /* Shift for enum set.  */\n \n /* Structure describing an enumerated option argument.  */\n \n@@ -226,6 +227,7 @@ extern const unsigned int cl_enums_count;\n #define CL_ERR_NEGATIVE\t\t(1 << 6) /* Negative form of option\n \t\t\t\t\t    not permitted (together\n \t\t\t\t\t    with OPT_SPECIAL_unknown).  */\n+#define CL_ERR_ENUM_SET_ARG\t(1 << 7) /* Bad argument of enumerated set.  */\n \n /* Structure describing the result of decoding an option.  */\n \n@@ -260,9 +262,14 @@ struct cl_decoded_option\n \n   /* For a boolean option, 1 for the true case and 0 for the \"no-\"\n      case.  For an unsigned integer option, the value of the\n-     argument.  1 in all other cases.  */\n+     argument.  For enum the value of the enumerator corresponding\n+     to argument string.  1 in all other cases.  */\n   HOST_WIDE_INT value;\n \n+  /* For EnumSet the value mask.  Variable should be changed to\n+     value | (prev_value & ~mask).  */\n+  HOST_WIDE_INT mask;\n+\n   /* Any flags describing errors detected in this option.  */\n   int errors;\n };\n@@ -374,7 +381,8 @@ extern bool get_option_state (struct gcc_options *, int,\n extern void set_option (struct gcc_options *opts,\n \t\t\tstruct gcc_options *opts_set,\n \t\t\tint opt_index, HOST_WIDE_INT value, const char *arg,\n-\t\t\tint kind, location_t loc, diagnostic_context *dc);\n+\t\t\tint kind, location_t loc, diagnostic_context *dc,\n+\t\t\tHOST_WIDE_INT = 0);\n extern void *option_flag_var (int opt_index, struct gcc_options *opts);\n bool handle_generated_option (struct gcc_options *opts,\n \t\t\t      struct gcc_options *opts_set,"}]}