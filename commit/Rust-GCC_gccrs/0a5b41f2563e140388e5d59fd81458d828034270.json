{"sha": "0a5b41f2563e140388e5d59fd81458d828034270", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGE1YjQxZjI1NjNlMTQwMzg4ZTVkNTlmZDgxNDU4ZDgyODAzNDI3MA==", "commit": {"author": {"name": "Michael Hayes", "email": "mhayes@cygnus.com", "date": "2000-09-11T21:44:21Z"}, "committer": {"name": "Michael Hayes", "email": "m.hayes@gcc.gnu.org", "date": "2000-09-11T21:44:21Z"}, "message": "unroll.c (iteration_info): Subsume into loop_iterations.\n\n\t* unroll.c (iteration_info): Subsume into loop_iterations.\n\t* loop.h (loop_info): New field iv.\n\nFrom-SVN: r36334", "tree": {"sha": "2685a2294a1b0e4bec326a6361e1c23f754e39d4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2685a2294a1b0e4bec326a6361e1c23f754e39d4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0a5b41f2563e140388e5d59fd81458d828034270", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0a5b41f2563e140388e5d59fd81458d828034270", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0a5b41f2563e140388e5d59fd81458d828034270", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0a5b41f2563e140388e5d59fd81458d828034270/comments", "author": null, "committer": null, "parents": [{"sha": "5d6a16e27e7ee47c6d2168d10c1e8d5c532816a9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d6a16e27e7ee47c6d2168d10c1e8d5c532816a9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5d6a16e27e7ee47c6d2168d10c1e8d5c532816a9"}], "stats": {"total": 247, "additions": 122, "deletions": 125}, "files": [{"sha": "276252b7d3179ad9821bc2b6403775128d77b68a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a5b41f2563e140388e5d59fd81458d828034270/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a5b41f2563e140388e5d59fd81458d828034270/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0a5b41f2563e140388e5d59fd81458d828034270", "patch": "@@ -1,3 +1,8 @@\n+2000-09-12  Michael Hayes  <mhayes@cygnus.com>\n+\n+\t* unroll.c (iteration_info): Subsume into loop_iterations.\n+\t* loop.h (loop_info): New field iv.\n+\n 2000-09-12  Michael Hayes  <mhayes@cygnus.com>\n \n \t* basic-block.h (LOOP_TREE, LOOP_PRE_HEADER, LOOP_EDGES): New."}, {"sha": "addd6747ccf534f2abac2c70fc4b2086633106c1", "filename": "gcc/loop.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a5b41f2563e140388e5d59fd81458d828034270/gcc%2Floop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a5b41f2563e140388e5d59fd81458d828034270/gcc%2Floop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.h?ref=0a5b41f2563e140388e5d59fd81458d828034270", "patch": "@@ -216,6 +216,8 @@ struct loop_info\n   /* The number of times the loop body was unrolled.  */\n   unsigned int unroll_number;\n   int used_count_register;\n+  /* The loop iterator induction variable.  */\n+  struct iv_class *iv;\n   /* List of MEMs that are stored in this loop.  */\n   rtx store_mems;\n   /* Array of MEMs that are used (read or written) in this loop, but"}, {"sha": "bc6655cf624067c7c4cf4136a2fa39faa2fb7dfd", "filename": "gcc/unroll.c", "status": "modified", "additions": 115, "deletions": 125, "changes": 240, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a5b41f2563e140388e5d59fd81458d828034270/gcc%2Funroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a5b41f2563e140388e5d59fd81458d828034270/gcc%2Funroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funroll.c?ref=0a5b41f2563e140388e5d59fd81458d828034270", "patch": "@@ -203,7 +203,6 @@ static rtx initial_reg_note_copy PARAMS ((rtx, struct inline_remap *));\n static void final_reg_note_copy PARAMS ((rtx, struct inline_remap *));\n static void copy_loop_body PARAMS ((rtx, rtx, struct inline_remap *, rtx, int,\n \t\t\t\t  enum unroll_types, rtx, rtx, rtx, rtx));\n-static void iteration_info PARAMS ((const struct loop *, rtx, rtx *, rtx *));\n static int find_splittable_regs PARAMS ((const struct loop *,\n \t\t\t\t\t enum unroll_types, rtx, int));\n static int find_splittable_givs PARAMS ((const struct loop *, \n@@ -1477,7 +1476,7 @@ precondition_loop_p (loop, initial_value, final_value, increment, mode)\n       return 0;\n     }\n \n-  /* Note that iteration_info biases the initial value for GIV iterators\n+  /* Note that loop_iterations biases the initial value for GIV iterators\n      such as \"while (i-- > 0)\" so that we can calculate the number of\n      iterations just like for BIV iterators.\n \n@@ -2427,125 +2426,6 @@ biv_total_increment (bl)\n   return result;\n }\n \n-/* Determine the initial value of the iteration variable, and the amount\n-   that it is incremented each loop.  Use the tables constructed by\n-   the strength reduction pass to calculate these values.\n-\n-   Initial_value and/or increment are set to zero if their values could not\n-   be calculated.  */\n-\n-static void\n-iteration_info (loop, iteration_var, initial_value, increment)\n-     const struct loop *loop ATTRIBUTE_UNUSED;\n-     rtx iteration_var, *initial_value, *increment;\n-{\n-  struct iv_class *bl;\n-\n-  /* Clear the result values, in case no answer can be found.  */\n-  *initial_value = 0;\n-  *increment = 0;\n-\n-  /* The iteration variable can be either a giv or a biv.  Check to see\n-     which it is, and compute the variable's initial value, and increment\n-     value if possible.  */\n-\n-  /* If this is a new register, can't handle it since we don't have any\n-     reg_iv_type entry for it.  */\n-  if ((unsigned) REGNO (iteration_var) >= reg_iv_type->num_elements)\n-    {\n-      if (loop_dump_stream)\n-\tfprintf (loop_dump_stream,\n-\t\t \"Loop unrolling: No reg_iv_type entry for iteration var.\\n\");\n-      return;\n-    }\n-\n-  /* Reject iteration variables larger than the host wide int size, since they\n-     could result in a number of iterations greater than the range of our\n-     `unsigned HOST_WIDE_INT' variable loop_info->n_iterations.  */\n-  else if ((GET_MODE_BITSIZE (GET_MODE (iteration_var))\n-\t    > HOST_BITS_PER_WIDE_INT))\n-    {\n-      if (loop_dump_stream)\n-\tfprintf (loop_dump_stream,\n-\t\t \"Loop unrolling: Iteration var rejected because mode too large.\\n\");\n-      return;\n-    }\n-  else if (GET_MODE_CLASS (GET_MODE (iteration_var)) != MODE_INT)\n-    {\n-      if (loop_dump_stream)\n-\tfprintf (loop_dump_stream,\n-\t\t \"Loop unrolling: Iteration var not an integer.\\n\");\n-      return;\n-    }\n-  else if (REG_IV_TYPE (REGNO (iteration_var)) == BASIC_INDUCT)\n-    {\n-      /* When reg_iv_type / reg_iv_info is resized for biv increments\n-\t that are turned into givs, reg_biv_class is not resized.\n-\t So check here that we don't make an out-of-bounds access.  */\n-      if (REGNO (iteration_var) >= max_reg_before_loop)\n-\tabort ();\n-\n-      /* Grab initial value, only useful if it is a constant.  */\n-      bl = reg_biv_class[REGNO (iteration_var)];\n-      *initial_value = bl->initial_value;\n-\n-      *increment = biv_total_increment (bl);\n-    }\n-  else if (REG_IV_TYPE (REGNO (iteration_var)) == GENERAL_INDUCT)\n-    {\n-      HOST_WIDE_INT offset = 0;\n-      struct induction *v = REG_IV_INFO (REGNO (iteration_var));\n-      rtx biv_initial_value;\n-\n-      if (REGNO (v->src_reg) >= max_reg_before_loop)\n-\tabort ();\n-\n-      bl = reg_biv_class[REGNO (v->src_reg)];\n-\n-      /* Increment value is mult_val times the increment value of the biv.  */\n-\n-      *increment = biv_total_increment (bl);\n-      if (*increment)\n-\t{\n-\t  struct induction *biv_inc;\n-\n-\t  *increment\n-\t    = fold_rtx_mult_add (v->mult_val, *increment, const0_rtx, v->mode);\n-\t  /* The caller assumes that one full increment has occured at the\n-\t     first loop test.  But that's not true when the biv is incremented\n-\t     after the giv is set (which is the usual case), e.g.:\n-\t     i = 6; do {;} while (i++ < 9) .\n-\t     Therefore, we bias the initial value by subtracting the amount of\n-\t     the increment that occurs between the giv set and the giv test.  */\n-\t  for (biv_inc = bl->biv; biv_inc; biv_inc = biv_inc->next_iv)\n-\t    {\n-\t      if (loop_insn_first_p (v->insn, biv_inc->insn))\n-\t\toffset -= INTVAL (biv_inc->add_val);\n-\t    }\n-\t  offset *= INTVAL (v->mult_val);\n-\t}\n-      if (loop_dump_stream)\n-\tfprintf (loop_dump_stream,\n-\t\t \"Loop unrolling: Giv iterator, initial value bias %ld.\\n\",\n-\t\t (long) offset);\n-\n-      /* Initial value is mult_val times the biv's initial value plus\n-\t add_val.  Only useful if it is a constant.  */\n-      biv_initial_value = extend_value_for_giv (v, bl->initial_value);\n-      *initial_value\n-\t= fold_rtx_mult_add (v->mult_val,\n-\t\t\t     plus_constant (biv_initial_value, offset),\n-\t\t\t     v->add_val, v->mode);\n-    }\n-  else\n-    {\n-      if (loop_dump_stream)\n-\tfprintf (loop_dump_stream,\n-\t\t \"Loop unrolling: Not basic or general induction var.\\n\");\n-      return;\n-    }\n-}\n-\n \n /* For each biv and giv, determine whether it can be safely split into\n    a different variable for each unrolled copy of the loop body.  If it\n@@ -3631,8 +3511,10 @@ find_common_reg_term (op0, op1)\n   return NULL_RTX;\n }\n \n-/* Calculate the number of loop iterations.  Returns the exact number of loop\n-   iterations if it can be calculated, otherwise returns zero.  */\n+\n+/* Determine the loop iterator and calculate the number of loop\n+   iterations.  Returns the exact number of loop iterations if it can\n+   be calculated, otherwise returns zero.  */\n \n unsigned HOST_WIDE_INT\n loop_iterations (loop)\n@@ -3649,6 +3531,7 @@ loop_iterations (loop)\n   rtx last_loop_insn;\n   rtx reg_term;\n   struct loop_info *loop_info = LOOP_INFO (loop);\n+  struct iv_class *bl;\n \n   loop_info->n_iterations = 0;\n   loop_info->initial_value = 0;\n@@ -3659,6 +3542,7 @@ loop_iterations (loop)\n   loop_info->increment = 0;\n   loop_info->iteration_var = 0;\n   loop_info->unroll_number = 1;\n+  loop_info->iv = 0;\n \n   /* We used to use prev_nonnote_insn here, but that fails because it might\n      accidentally get the branch for a contained loop if the branch for this\n@@ -3725,10 +3609,115 @@ loop_iterations (loop)\n       && ! REG_USERVAR_P (iteration_var))\n     abort ();\n \n-  iteration_info (loop, iteration_var, &initial_value, &increment);\n+  /* Determine the initial value of the iteration variable, and the amount\n+     that it is incremented each loop.  Use the tables constructed by\n+     the strength reduction pass to calculate these values.  */\n+\n+  /* Clear the result values, in case no answer can be found.  */\n+  initial_value = 0;\n+  increment = 0;\n+\n+  /* The iteration variable can be either a giv or a biv.  Check to see\n+     which it is, and compute the variable's initial value, and increment\n+     value if possible.  */\n+\n+  /* If this is a new register, can't handle it since we don't have any\n+     reg_iv_type entry for it.  */\n+  if ((unsigned) REGNO (iteration_var) >= reg_iv_type->num_elements)\n+    {\n+      if (loop_dump_stream)\n+\tfprintf (loop_dump_stream,\n+\t\t \"Loop iterations: No reg_iv_type entry for iteration var.\\n\");\n+      return 0;\n+    }\n+\n+  /* Reject iteration variables larger than the host wide int size, since they\n+     could result in a number of iterations greater than the range of our\n+     `unsigned HOST_WIDE_INT' variable loop_info->n_iterations.  */\n+  else if ((GET_MODE_BITSIZE (GET_MODE (iteration_var))\n+\t    > HOST_BITS_PER_WIDE_INT))\n+    {\n+      if (loop_dump_stream)\n+\tfprintf (loop_dump_stream,\n+\t\t \"Loop iterations: Iteration var rejected because mode too large.\\n\");\n+      return 0;\n+    }\n+  else if (GET_MODE_CLASS (GET_MODE (iteration_var)) != MODE_INT)\n+    {\n+      if (loop_dump_stream)\n+\tfprintf (loop_dump_stream,\n+\t\t \"Loop iterations: Iteration var not an integer.\\n\");\n+      return 0;\n+    }\n+  else if (REG_IV_TYPE (REGNO (iteration_var)) == BASIC_INDUCT)\n+    {\n+      /* When reg_iv_type / reg_iv_info is resized for biv increments\n+\t that are turned into givs, reg_biv_class is not resized.\n+\t So check here that we don't make an out-of-bounds access.  */\n+      if (REGNO (iteration_var) >= max_reg_before_loop)\n+\tabort ();\n+\n+      /* Grab initial value, only useful if it is a constant.  */\n+      bl = reg_biv_class[REGNO (iteration_var)];\n+      initial_value = bl->initial_value;\n+\n+      increment = biv_total_increment (bl);\n+    }\n+  else if (REG_IV_TYPE (REGNO (iteration_var)) == GENERAL_INDUCT)\n+    {\n+      HOST_WIDE_INT offset = 0;\n+      struct induction *v = REG_IV_INFO (REGNO (iteration_var));\n+      rtx biv_initial_value;\n+\n+      if (REGNO (v->src_reg) >= max_reg_before_loop)\n+\tabort ();\n+\n+      bl = reg_biv_class[REGNO (v->src_reg)];\n+\n+      /* Increment value is mult_val times the increment value of the biv.  */\n+\n+      increment = biv_total_increment (bl);\n+      if (increment)\n+\t{\n+\t  struct induction *biv_inc;\n+\n+\t  increment\n+\t    = fold_rtx_mult_add (v->mult_val, increment, const0_rtx, v->mode);\n+\t  /* The caller assumes that one full increment has occured at the\n+\t     first loop test.  But that's not true when the biv is incremented\n+\t     after the giv is set (which is the usual case), e.g.:\n+\t     i = 6; do {;} while (i++ < 9) .\n+\t     Therefore, we bias the initial value by subtracting the amount of\n+\t     the increment that occurs between the giv set and the giv test.  */\n+\t  for (biv_inc = bl->biv; biv_inc; biv_inc = biv_inc->next_iv)\n+\t    {\n+\t      if (loop_insn_first_p (v->insn, biv_inc->insn))\n+\t\toffset -= INTVAL (biv_inc->add_val);\n+\t    }\n+\t  offset *= INTVAL (v->mult_val);\n+\t}\n+      if (loop_dump_stream)\n+\tfprintf (loop_dump_stream,\n+\t\t \"Loop iterations: Giv iterator, initial value bias %ld.\\n\",\n+\t\t (long) offset);\n+\n+      /* Initial value is mult_val times the biv's initial value plus\n+\t add_val.  Only useful if it is a constant.  */\n+      biv_initial_value = extend_value_for_giv (v, bl->initial_value);\n+      initial_value\n+\t= fold_rtx_mult_add (v->mult_val,\n+\t\t\t     plus_constant (biv_initial_value, offset),\n+\t\t\t     v->add_val, v->mode);\n+    }\n+  else\n+    {\n+      if (loop_dump_stream)\n+\tfprintf (loop_dump_stream,\n+\t\t \"Loop iterations: Not basic or general induction var.\\n\");\n+      return 0;\n+    }\n \n   if (initial_value == 0)\n-    /* iteration_info already printed a message.  */\n     return 0;\n \n   unsigned_p = 0;\n@@ -3809,6 +3798,7 @@ loop_iterations (loop)\n   loop_info->increment = increment;\n   loop_info->iteration_var = iteration_var;\n   loop_info->comparison_code = comparison_code;\n+  loop_info->iv = bl;\n \n   /* Try to determine the iteration count for loops such\n      as (for i = init; i < init + const; i++).  When running the"}]}