{"sha": "e45b72c408a765beb3687e966af9c946cd6c1330", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTQ1YjcyYzQwOGE3NjViZWIzNjg3ZTk2NmFmOWM5NDZjZDZjMTMzMA==", "commit": {"author": {"name": "Richard Earnshaw", "email": "rearnsha@gcc.gnu.org", "date": "2000-08-15T13:41:34Z"}, "committer": {"name": "Richard Earnshaw", "email": "rearnsha@gcc.gnu.org", "date": "2000-08-15T13:41:34Z"}, "message": "ARM support for unordered FP operations.\n\n* arm-protos.h (arm_comparison_operator): Declare.\n* arm.c (arm_comparison_operator): New function.\n(arm_select_cc_mode): Add unordered comparison codes.\n(get_arm_condition_code): Likewise.\n(arm_final_prescan_insn): Can't handle unordered jumps that can't\nbe done in one insn.\n* arm.h (PREDICATE_CODES): Add arm_comparison_operator.\n* arm.md (all uses of comparison_operator): Replace with\narm_comparison_operator.\n(bunordered, bordered, bugt, bunlt, bunge, bunle, buneq, bltgt): New\nexpands.\n(arm_buneq, arm_bltgt, arm_buneq_reversed, arm_bltgt_reveresed): New\npatterns.\n\nFrom-SVN: r35705", "tree": {"sha": "21a08ec005e530c8439d5c34a0ba5d2e0132b452", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/21a08ec005e530c8439d5c34a0ba5d2e0132b452"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e45b72c408a765beb3687e966af9c946cd6c1330", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e45b72c408a765beb3687e966af9c946cd6c1330", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e45b72c408a765beb3687e966af9c946cd6c1330", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e45b72c408a765beb3687e966af9c946cd6c1330/comments", "author": null, "committer": null, "parents": [{"sha": "05ed98a11fe00c67e745f36dfda87f346c3d8983", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/05ed98a11fe00c67e745f36dfda87f346c3d8983", "html_url": "https://github.com/Rust-GCC/gccrs/commit/05ed98a11fe00c67e745f36dfda87f346c3d8983"}], "stats": {"total": 61, "additions": 56, "deletions": 5}, "files": [{"sha": "e905daeea747ce3b1fea2fc89dd61ac80588b7c3", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 53, "deletions": 5, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e45b72c408a765beb3687e966af9c946cd6c1330/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e45b72c408a765beb3687e966af9c946cd6c1330/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=e45b72c408a765beb3687e966af9c946cd6c1330", "patch": "@@ -3000,6 +3000,17 @@ equality_operator (x, mode)\n   return GET_CODE (x) == EQ || GET_CODE (x) == NE;\n }\n \n+/* Return TRUE if x is a comparison operator other than LTGT or UNEQ.  */\n+int\n+arm_comparison_operator (x, mode)\n+     rtx x;\n+     enum machine_mode mode;\n+{\n+  return (comparison_operator (x, mode)\n+\t  && GET_CODE (x) != LTGT\n+\t  && GET_CODE (x) != UNEQ);\n+}\n+\n /* Return TRUE for SMIN SMAX UMIN UMAX operators.  */\n int\n minmax_operator (x, mode)\n@@ -4194,7 +4205,31 @@ arm_select_cc_mode (op, x, y)\n   /* All floating point compares return CCFP if it is an equality\n      comparison, and CCFPE otherwise.  */\n   if (GET_MODE_CLASS (GET_MODE (x)) == MODE_FLOAT)\n-    return (op == EQ || op == NE) ? CCFPmode : CCFPEmode;\n+    {\n+      switch (op)\n+\t{\n+\tcase EQ:\n+\tcase NE:\n+\tcase UNORDERED:\n+\tcase ORDERED:\n+\tcase UNLT:\n+\tcase UNLE:\n+\tcase UNGT:\n+\tcase UNGE:\n+\tcase UNEQ:\n+\tcase LTGT:\n+\t  return CCFPmode;\n+\n+\tcase LT:\n+\tcase LE:\n+\tcase GT:\n+\tcase GE:\n+\t  return CCFPEmode;\n+\n+\tdefault:\n+\t  abort ();\n+\t}\n+    }\n   \n   /* A compare with a shifted operand.  Because of canonicalization, the\n      comparison will have to be swapped when we emit the assembler.  */\n@@ -7642,7 +7677,6 @@ get_arm_condition_code (comparison)\n \t}\n \n     case CC_Zmode:\n-    case CCFPmode:\n       switch (comp_code)\n \t{\n \tcase NE: return ARM_NE;\n@@ -7651,12 +7685,27 @@ get_arm_condition_code (comparison)\n \t}\n \n     case CCFPEmode:\n+    case CCFPmode:\n+      /* These encodings assume that AC=1 in the FPA system control\n+\t byte.  This allows us to handle all cases except UNEQ and\n+\t LTGT.  */\n       switch (comp_code)\n \t{\n \tcase GE: return ARM_GE;\n \tcase GT: return ARM_GT;\n \tcase LE: return ARM_LS;\n \tcase LT: return ARM_MI;\n+\tcase NE: return ARM_NE;\n+\tcase EQ: return ARM_EQ;\n+\tcase ORDERED: return ARM_VC;\n+\tcase UNORDERED: return ARM_VS;\n+\tcase UNLT: return ARM_LT;\n+\tcase UNLE: return ARM_LE;\n+\tcase UNGT: return ARM_HI;\n+\tcase UNGE: return ARM_PL;\n+\t  /* UNEQ and LTGT do not have a representation.  */\n+\tcase UNEQ: /* Fall through.  */\n+\tcase LTGT: /* Fall through.  */\n \tdefault: abort ();\n \t}\n \n@@ -7812,11 +7861,10 @@ arm_final_prescan_insn (insn)\n       int then_not_else = TRUE;\n       rtx this_insn = start_insn, label = 0;\n \n+      /* If the jump cannot be done with one instruction, we cannot \n+\t conditionally execute the instruction in the inverse case.  */\n       if (get_attr_conds (insn) == CONDS_JUMP_CLOB)\n \t{\n-\t  /* The code below is wrong for these, and I haven't time to\n-\t     fix it now.  So we just do the safe thing and return.  This\n-\t     whole function needs re-writing anyway.  */\n \t  jump_clobbers = 1;\n \t  return;\n \t}"}, {"sha": "04702f1134c47ad3486598042b874686cefe8ec7", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e45b72c408a765beb3687e966af9c946cd6c1330/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e45b72c408a765beb3687e966af9c946cd6c1330/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=e45b72c408a765beb3687e966af9c946cd6c1330", "patch": "@@ -2883,6 +2883,9 @@ extern int making_const_table;\n   {\"load_multiple_operation\",  {PARALLEL}},\t\t\t\t\\\n   {\"store_multiple_operation\", {PARALLEL}},\t\t\t\t\\\n   {\"equality_operator\", {EQ, NE}},\t\t\t\t\t\\\n+  {\"arm_comparison_operator\", {EQ, NE, LE, LT, GE, GT, GEU, GTU, LEU,\t\\\n+\t\t\t       LTU, UNORDERED, ORDERED, UNLT, UNLE,\t\\\n+\t\t\t       UNGE, UNGT}},\t\t\t\t\\\n   {\"arm_rhsm_operand\", {SUBREG, REG, CONST_INT, MEM}},\t\t\t\\\n   {\"const_shift_operand\", {CONST_INT}},\t\t\t\t\t\\\n   {\"multi_register_push\", {PARALLEL}},\t\t\t\t\t\\"}]}