{"sha": "4bdf641875669a5f94a5acb2cd54100f5e52a835", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGJkZjY0MTg3NTY2OWE1Zjk0YTVhY2IyY2Q1NDEwMGY1ZTUyYTgzNQ==", "commit": {"author": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2014-07-11T07:42:50Z"}, "committer": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2014-07-11T07:42:50Z"}, "message": "re PR target/56858 (alpha looks for NOTE_INSN_EH_REGION notes that cannot exist)\n\n\tPR target/56858\n\t* config/alpha/alpha.c: Include tree-pass.h, context.h\n\tand pass_manager.h.\n\t(pass_data_handle_trap_shadows): New pass.\n\t(pass_handle_trap_shadows::gate): New pass gate function.\n\t(make_pass_handle_trap_shadows): New function.\n\t(rest_of_handle_trap_shadows): Ditto.\n\n\t(alpha_align_insns_1): Rename from alpha_align_insns.\n\t(pass_data_align_insns): New pass.\n\t(pass_align_insns::gate): New pass gate function.\n\t(make_pass_aling_insns): New function.\n\t(rest_of_align_insns): Ditto.\n\t(alpha_align_insns): Ditto.\n\n\t(alpha_option_override): Declare handle_trap_shadows info\n\tand align_insns_info.  Register handle_trap_shadows and align_insns\n\tpasses here.\n\t(alpha_reorg): Do not call alpha_trap_shadows and\n\talpha_align_insn from here.\n\n\t(alpha_pad_function_end): Do not skip BARRIERs.\n\nFrom-SVN: r212449", "tree": {"sha": "07bc9f05cb6956bbbd90edf7dd1c55245df2aa98", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/07bc9f05cb6956bbbd90edf7dd1c55245df2aa98"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4bdf641875669a5f94a5acb2cd54100f5e52a835", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4bdf641875669a5f94a5acb2cd54100f5e52a835", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4bdf641875669a5f94a5acb2cd54100f5e52a835", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4bdf641875669a5f94a5acb2cd54100f5e52a835/comments", "author": null, "committer": null, "parents": [{"sha": "c77556a5d1e225024a4f9dafe5a1a6c316a86b83", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c77556a5d1e225024a4f9dafe5a1a6c316a86b83", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c77556a5d1e225024a4f9dafe5a1a6c316a86b83"}], "stats": {"total": 236, "additions": 185, "deletions": 51}, "files": [{"sha": "f9d02b531f79a582bf8540193464d576281cf4ee", "filename": "gcc/ChangeLog", "status": "modified", "additions": 43, "deletions": 26, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bdf641875669a5f94a5acb2cd54100f5e52a835/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bdf641875669a5f94a5acb2cd54100f5e52a835/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4bdf641875669a5f94a5acb2cd54100f5e52a835", "patch": "@@ -1,7 +1,31 @@\n+2014-07-11  Uros Bizjak  <ubizjak@gmail.com>\n+\n+\tPR target/56858\n+\t* config/alpha/alpha.c: Include tree-pass.h, context.h\n+\tand pass_manager.h.\n+\t(pass_data_handle_trap_shadows): New pass.\n+\t(pass_handle_trap_shadows::gate): New pass gate function.\n+\t(make_pass_handle_trap_shadows): New function.\n+\t(rest_of_handle_trap_shadows): Ditto.\n+\n+\t(alpha_align_insns_1): Rename from alpha_align_insns.\n+\t(pass_data_align_insns): New pass.\n+\t(pass_align_insns::gate): New pass gate function.\n+\t(make_pass_aling_insns): New function.\n+\t(rest_of_align_insns): Ditto.\n+\t(alpha_align_insns): Ditto.\n+\n+\t(alpha_option_override): Declare handle_trap_shadows info\n+\tand align_insns_info.  Register handle_trap_shadows and align_insns\n+\tpasses here.\n+\t(alpha_reorg): Do not call alpha_trap_shadows and\n+\talpha_align_insn from here.\n+\n+\t(alpha_pad_function_end): Do not skip BARRIERs.\n+\n 2014-07-10  Rong Xu  <xur@google.com>\n \n-\tAdd gcov-tool: an offline gcda profile processing tool\n-\tSupport.\n+\tAdd gcov-tool: an offline gcda profile processing tool support.\n \t* gcov-io.c (gcov_position): Make avaialble to gcov-tool.\n \t(gcov_is_error): Ditto.\n \t(gcov_read_string): Ditto.\n@@ -55,9 +79,9 @@\n \n 2014-07-09  Tom de Vries  <tom@codesourcery.com>\n \n-       * final.c (get_call_fndecl): Declare.\n-       (self_recursive_call_p): New function.\n-       (collect_fn_hard_reg_usage): Handle self-recursive function calls.\n+\t* final.c (get_call_fndecl): Declare.\n+\t(self_recursive_call_p): New function.\n+\t(collect_fn_hard_reg_usage): Handle self-recursive function calls.\n \n 2014-07-08  Jan Hubicka  <hubicka@ucw.cz>\n \n@@ -96,8 +120,8 @@\n 2014-07-08  Trevor Saunders  <tsaunders@mozilla.com>\n \n \tPR bootstrap/61679\n-\t * hash-table.h: use hash_table::value_type instead of\n-       \tDescriptor::value_type in the return types of several methods.\n+\t* hash-table.h: use hash_table::value_type instead of\n+\tDescriptor::value_type in the return types of several methods.\n \n 2014-07-08  Trevor Saunders  <tsaunders@mozilla.com>\n \n@@ -212,9 +236,8 @@\n 2014-07-08  Yuri Rumyantsev  <ysrumyan@gmail.com>\n \n \tPR tree-optimization/61576\n-\t* tree-if-conv.c (is_cond_scalar_reduction): Add check that\n-\tbasic block containing reduction statement is predecessor\n-\tof phi basi block.\n+\t* tree-if-conv.c (is_cond_scalar_reduction): Add check that basic\n+\tblock containing reduction statement is predecessor of phi basi block.\n \n 2014-07-08  Marek Polacek  <polacek@redhat.com>\n \n@@ -226,30 +249,24 @@\n \n 2014-07-07  Jan Hubicka  <hubicka@ucw.cz>\n \n-\t* symtab.c: Include calls.h\n-\t(symtab_nonoverwritable_alias_1): Check sanity of the local\n-\talias.\n+\t* symtab.c: Include calls.h.\n+\t(symtab_nonoverwritable_alias_1): Check sanity of the local alias.\n \n 2014-07-07  Maciej W. Rozycki  <macro@codesourcery.com>\n \n \t* config/rs6000/rs6000.c (output_vec_const_move): Handle\n \tlittle-endian code generation.\n \t* config/rs6000/spe.md (spe_evmergehi): Rename to...\n-\t(vec_perm00_v2si): ... this.  Handle little-endian code \n-\tgeneration.\n+\t(vec_perm00_v2si): ... this.  Handle little-endian code generation.\n \t(spe_evmergehilo): Rename to...\n-\t(vec_perm01_v2si): ... this.  Handle little-endian code\n-\tgeneration.\n+\t(vec_perm01_v2si): ... this.  Handle little-endian code generation.\n \t(spe_evmergelo): Rename to...\n-\t(vec_perm11_v2si): ... this.  Handle little-endian code\n-\tgeneration.\n+\t(vec_perm11_v2si): ... this.  Handle little-endian code generation.\n \t(spe_evmergelohi): Rename to...\n-\t(vec_perm10_v2si): ... this.  Handle little-endian code\n-\tgeneration.\n+\t(vec_perm10_v2si): ... this.  Handle little-endian code generation.\n \t(spe_evmergehi, spe_evmergehilo): New expanders.\n \t(spe_evmergelo, spe_evmergelohi): Likewise.\n-\t(*frob_<SPE64:mode>_<DITI:mode>): Handle little-endian code\n-\tgeneration.\n+\t(*frob_<SPE64:mode>_<DITI:mode>): Handle little-endian code generation.\n \t(*frob_tf_ti): Likewise.\n \t(*frob_<mode>_di_2): Likewise.\n \t(*frob_tf_di_8_2): Likewise.\n@@ -263,7 +280,7 @@\n \tendianness only.\n \t(*mov_si<mode>_e500_subreg0_le): New instruction pattern.\n \t(*mov_si<mode>_e500_subreg0_elf_low): Rename to...\n-\t(*mov_si<mode>_e500_subreg0_elf_low_be): ... this.  Restrict to \n+\t(*mov_si<mode>_e500_subreg0_elf_low_be): ... this.  Restrict to\n \tthe big endianness only.\n \t(*mov_si<mode>_e500_subreg0_elf_low_le): New instruction pattern.\n \t(*mov_si<mode>_e500_subreg0_2): Rename to...\n@@ -302,8 +319,8 @@\n \n 2014-07-07  Max Ostapenko  <m.ostapenko@partner.samsung.com>\n \n-\t* asan.c (instrument_strlen_call): Do not instrument first byte in strlen\n-\tif already instrumented.\n+\t* asan.c (instrument_strlen_call): Do not instrument first byte\n+\tin strlen if already instrumented.\n \n 2014-07-07  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n "}, {"sha": "d5a2b141f97365a023e6c7276d4b752cd625c983", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 142, "deletions": 25, "changes": 167, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bdf641875669a5f94a5acb2cd54100f5e52a835/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bdf641875669a5f94a5acb2cd54100f5e52a835/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=4bdf641875669a5f94a5acb2cd54100f5e52a835", "patch": "@@ -62,6 +62,9 @@ along with GCC; see the file COPYING3.  If not see\n #include \"gimple-expr.h\"\n #include \"is-a.h\"\n #include \"gimple.h\"\n+#include \"tree-pass.h\"\n+#include \"context.h\"\n+#include \"pass_manager.h\"\n #include \"gimple-iterator.h\"\n #include \"gimplify.h\"\n #include \"gimple-ssa.h\"\n@@ -209,6 +212,8 @@ static struct alpha_rtx_cost_data const alpha_rtx_cost_size =\n /* Declarations of static functions.  */\n static struct machine_function *alpha_init_machine_status (void);\n static rtx alpha_emit_xfloating_compare (enum rtx_code *, rtx, rtx);\n+static void alpha_handle_trap_shadows (void);\n+static void alpha_align_insns (void);\n \n #if TARGET_ABI_OPEN_VMS\n static void alpha_write_linkage (FILE *, const char *);\n@@ -217,6 +222,113 @@ static bool vms_valid_pointer_mode (enum machine_mode);\n #define vms_patch_builtins()  gcc_unreachable()\n #endif\n \f\n+static unsigned int\n+rest_of_handle_trap_shadows (void)\n+{\n+  alpha_handle_trap_shadows ();\n+  return 0;\n+}\n+\n+namespace {\n+\n+const pass_data pass_data_handle_trap_shadows =\n+{\n+  RTL_PASS,\n+  \"trap_shadows\",\t\t\t/* name */\n+  OPTGROUP_NONE,\t\t\t/* optinfo_flags */\n+  TV_NONE,\t\t\t\t/* tv_id */\n+  0,\t\t\t\t\t/* properties_required */\n+  0,\t\t\t\t\t/* properties_provided */\n+  0,\t\t\t\t\t/* properties_destroyed */\n+  0,\t\t\t\t\t/* todo_flags_start */\n+  TODO_df_finish,\t\t\t/* todo_flags_finish */\n+};\n+\n+class pass_handle_trap_shadows : public rtl_opt_pass\n+{\n+public:\n+  pass_handle_trap_shadows(gcc::context *ctxt)\n+    : rtl_opt_pass(pass_data_handle_trap_shadows, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  virtual bool gate (function *)\n+    {\n+      return alpha_tp != ALPHA_TP_PROG || flag_exceptions;\n+    }\n+\n+  virtual unsigned int execute (function *)\n+    {\n+      return rest_of_handle_trap_shadows ();\n+    }\n+\n+}; // class pass_handle_trap_shadows\n+\n+} // anon namespace\n+\n+rtl_opt_pass *\n+make_pass_handle_trap_shadows (gcc::context *ctxt)\n+{\n+  return new pass_handle_trap_shadows (ctxt);\n+}\n+\n+static unsigned int\n+rest_of_align_insns (void)\n+{\n+  alpha_align_insns ();\n+  return 0;\n+}\n+\n+namespace {\n+\n+const pass_data pass_data_align_insns =\n+{\n+  RTL_PASS,\n+  \"align_insns\",\t\t\t/* name */\n+  OPTGROUP_NONE,\t\t\t/* optinfo_flags */\n+  TV_NONE,\t\t\t\t/* tv_id */\n+  0,\t\t\t\t\t/* properties_required */\n+  0,\t\t\t\t\t/* properties_provided */\n+  0,\t\t\t\t\t/* properties_destroyed */\n+  0,\t\t\t\t\t/* todo_flags_start */\n+  TODO_df_finish,\t\t\t/* todo_flags_finish */\n+};\n+\n+class pass_align_insns : public rtl_opt_pass\n+{\n+public:\n+  pass_align_insns(gcc::context *ctxt)\n+    : rtl_opt_pass(pass_data_align_insns, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  virtual bool gate (function *)\n+    {\n+      /* Due to the number of extra trapb insns, don't bother fixing up\n+\t alignment when trap precision is instruction.  Moreover, we can\n+\t only do our job when sched2 is run.  */\n+      return ((alpha_tune == PROCESSOR_EV4\n+\t       || alpha_tune == PROCESSOR_EV5)\n+\t      && optimize && !optimize_size\n+\t      && alpha_tp != ALPHA_TP_INSN\n+\t      && flag_schedule_insns_after_reload);\n+    }\n+\n+  virtual unsigned int execute (function *)\n+    {\n+      return rest_of_align_insns ();\n+    }\n+\n+}; // class pass_align_insns\n+\n+} // anon namespace\n+\n+rtl_opt_pass *\n+make_pass_align_insns (gcc::context *ctxt)\n+{\n+  return new pass_align_insns (ctxt);\n+}\n+\n #ifdef TARGET_ALTERNATE_LONG_DOUBLE_MANGLING\n /* Implement TARGET_MANGLE_TYPE.  */\n \n@@ -273,6 +385,18 @@ alpha_option_override (void)\n       64, 64, 16*1024 }\n   };\n \n+  opt_pass *pass_handle_trap_shadows = make_pass_handle_trap_shadows (g);\n+  static struct register_pass_info handle_trap_shadows_info\n+    = { pass_handle_trap_shadows, \"eh_ranges\",\n+\t1, PASS_POS_INSERT_AFTER\n+      };\n+\n+  opt_pass *pass_align_insns = make_pass_align_insns (g);\n+  static struct register_pass_info align_insns_info\n+    = { pass_align_insns, \"shorten\",\n+\t1, PASS_POS_INSERT_BEFORE\n+      };\n+\n   int const ct_size = ARRAY_SIZE (cpu_table);\n   int line_size = 0, l1_size = 0, l2_size = 0;\n   int i;\n@@ -506,6 +630,10 @@ alpha_option_override (void)\n   if (!(target_flags_explicit & MASK_LONG_DOUBLE_128))\n     target_flags |= MASK_LONG_DOUBLE_128;\n #endif\n+\n+  /* This needs to be done at start up.  It's convenient to do it here.  */\n+  register_pass (&handle_trap_shadows_info);\n+  register_pass (&align_insns_info);\n }\n \f\n /* Returns 1 if VALUE is a mask that contains full bytes of zero or ones.  */\n@@ -9178,9 +9306,9 @@ alphaev5_next_nop (int *pin_use)\n /* The instruction group alignment main loop.  */\n \n static void\n-alpha_align_insns (unsigned int max_align,\n-\t\t   rtx (*next_group) (rtx, int *, int *),\n-\t\t   rtx (*next_nop) (int *))\n+alpha_align_insns_1 (unsigned int max_align,\n+\t\t     rtx (*next_group) (rtx, int *, int *),\n+\t\t     rtx (*next_nop) (int *))\n {\n   /* ALIGN is the known alignment for the insn group.  */\n   unsigned int align;\n@@ -9305,6 +9433,17 @@ alpha_align_insns (unsigned int max_align,\n     }\n }\n \n+static void\n+alpha_align_insns (void)\n+{\n+  if (alpha_tune == PROCESSOR_EV4)\n+    alpha_align_insns_1 (8, alphaev4_next_group, alphaev4_next_nop);\n+  else if (alpha_tune == PROCESSOR_EV5)\n+    alpha_align_insns_1 (16, alphaev5_next_group, alphaev5_next_nop);\n+  else\n+    gcc_unreachable ();\n+}\n+\n /* Insert an unop between sibcall or noreturn function call and GP load.  */\n \n static void\n@@ -9324,12 +9463,6 @@ alpha_pad_function_end (void)\n       next = NEXT_INSN (insn);\n       if (next == NULL)\n \tcontinue;\n-      if (BARRIER_P (next))\n-\t{\n-\t  next = NEXT_INSN (next);\n-\t  if (next == NULL)\n-\t    continue;\n-\t}\n       if (NOTE_P (next) && NOTE_KIND (next) == NOTE_INSN_CALL_ARG_LOCATION)\n \tinsn = next;\n \n@@ -9397,22 +9530,6 @@ And in the noreturn case:\n \n   if (current_function_has_exception_handlers ())\n     alpha_pad_function_end ();\n-\n-  if (alpha_tp != ALPHA_TP_PROG || flag_exceptions)\n-    alpha_handle_trap_shadows ();\n-\n-  /* Due to the number of extra trapb insns, don't bother fixing up\n-     alignment when trap precision is instruction.  Moreover, we can\n-     only do our job when sched2 is run.  */\n-  if (optimize && !optimize_size\n-      && alpha_tp != ALPHA_TP_INSN\n-      && flag_schedule_insns_after_reload)\n-    {\n-      if (alpha_tune == PROCESSOR_EV4)\n-\talpha_align_insns (8, alphaev4_next_group, alphaev4_next_nop);\n-      else if (alpha_tune == PROCESSOR_EV5)\n-\talpha_align_insns (16, alphaev5_next_group, alphaev5_next_nop);\n-    }\n }\n \f\n static void"}]}