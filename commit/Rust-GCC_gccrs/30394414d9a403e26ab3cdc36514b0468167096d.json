{"sha": "30394414d9a403e26ab3cdc36514b0468167096d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzAzOTQ0MTRkOWE0MDNlMjZhYjNjZGMzNjUxNGIwNDY4MTY3MDk2ZA==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1998-02-25T00:49:51Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1998-02-25T00:49:51Z"}, "message": "Partial implementation of namespaces.\n\n\t* decl.c (push_namespace): Handle redeclaration error.\n\t* cp-tree.h (IDENTIFIER_NAMESPACE_VALUE): New macro.\n\t(IDENTIFIER_NAMESPACE_BINDINGS): New macro.\n\t(NAMESPACE_BINDING): New macro.\n\t(IDENTIFIER_GLOBAL_VALUE): Use NAMESPACE_BINDING.\n\t* *.c: Use them.\n\t* pt.c (push_template_decl): Use innermost_args.\n\t* decl.c (get_unique_name): Tweak from earlier in the name.\n\t* cp-tree.def: Add CPLUS_BINDING node.\n\t* cp-tree.h (tree_binding): new struct\n\t(BINDING_SCOPE, BINDING_VALUE): new macros\n\t(current_namespace, global_namespace): declare extern\n\t(struct lang_decl_flags): new field in_namespace\n\t(DECL_NAMESPACE_USING, DECL_NAMESPACE_USERS): new macros\n\t(DECL_NAMESPACE, SET_DECL_NAMESPACE): new macros\n\t(TREE_INDIRECT_USING): new macro\n\t* decl2.c (current_namespace, global_namespace): Declare.  The\n\tvalue is a NAMESPACE_DECL now, not a TREE_LIST.\n\t(is_namespace_ancestor, namespace_ancestor):new static functions.\n\t(add_using_namespace, ambiguous_decl): likewise.\n\t(lookup_using_namespace): new support function for lookup_name.\n\t(qualified_lookup_using_namespace): new support function for\n\tdo_scoped_id and lookup_namespace_name\n\t(get_namespace_id): mark as obsolete.\n\t(current_namespace_id): Likewise.\n\t(do_namespace_alias): Implement.\n\t(do_using_directive): Implement as call to add_using_namespace.\n\t* decl.c (binding_for_name): new function.\n\t(push_namespace, pop_namespace): implement.\n\t(push_decl): don't install a FUNCTION_DECL in the global branch.\n\t(lookup_namespace_name): implement using qualified lookup.\n\t(lookup_name_real): For global scoping, lookup in\n\tglobal_namespace. For namespace scoping, lookup in given\n\tnamespace. For unscoped lookup, iterate over namespace,\n\tconsidering using directives.\n\t(init_decl_processing): initialize global_namespace.\n\t(grokvardecl): Build assembler name as static name for globals.\n\t(grokdeclarator): Remove old namespace mangling.\n\t(xref_tag): When installing a global binding for the\n\ttag, make sure we have an identifier.\n\t* method.c (build_overload_nested_name): mangle namespaces.\n\t(build_qualified_name): Likewise.\n\t(build_decl_overload_real): Likewise.\n\t* lex.c (build_lang_decl): set namespace for new declaration to\n\tcurrent_namespace.\n\t(do_scoped_id): find global names in global or current\n\tnamespace, or using qualified namespace lookup, depending on\n\tcontext.\n\t* init.c (build_member_call): When scope is namespace, use\n\tbuild_x_function_call instead.\n\t(build_offset_ref): When scope is namespace, collapse processing\n\tto lookup_namespace_name instead.\n\t* error.c (dump_decl): Support NAMESPACE_DECL.\n\t* decl.c (pushdecl): Bind globals to current namespace.\n\t(push_overloaded_decl): Likewise.\n\t(lookup_tag): Likewise.\n\t(lookup_name_current_level): Likewise.\n\t(xref_tag): Likewise.\n\t(start_function): Likewise.\n\t* lex.c (do_identifier): Likewise.\n\t(identifier_typedecl_value): Likewise.\n\t(real_yylex): Likewise.\n\t* method.c (do_inline_function_hair): Likewise.\n\t* parse.y (unscoped): Likewise.\n\t* pt.c (check_explicit_specialization): Likewise.\n\t(lookup_template_class): Likewise.\n\t* rtti.c (call_void_fn): Likewise.\n\t* sig.c (build_sigtable): Likewise.\n\t* ptree.c (lang_print_xnode): New function.\n\nFrom-SVN: r18227", "tree": {"sha": "e73e02e4d84a416ffd3f786f3aac7b49634b0e88", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e73e02e4d84a416ffd3f786f3aac7b49634b0e88"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/30394414d9a403e26ab3cdc36514b0468167096d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/30394414d9a403e26ab3cdc36514b0468167096d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/30394414d9a403e26ab3cdc36514b0468167096d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/30394414d9a403e26ab3cdc36514b0468167096d/comments", "author": null, "committer": null, "parents": [{"sha": "8dfafd99fde27a63ae9ed9c16518e65037069937", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8dfafd99fde27a63ae9ed9c16518e65037069937", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8dfafd99fde27a63ae9ed9c16518e65037069937"}], "stats": {"total": 677, "additions": 597, "deletions": 80}, "files": [{"sha": "115e786e47c6908bcf709787218e65049ee3c2c7", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30394414d9a403e26ab3cdc36514b0468167096d/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30394414d9a403e26ab3cdc36514b0468167096d/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=30394414d9a403e26ab3cdc36514b0468167096d", "patch": "@@ -1,3 +1,81 @@\n+Wed Feb 25 00:35:33 1998  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* decl.c (push_namespace): Handle redeclaration error.\n+\n+\t* cp-tree.h (IDENTIFIER_NAMESPACE_VALUE): New macro.\n+\t(IDENTIFIER_NAMESPACE_BINDINGS): New macro.\n+\t(NAMESPACE_BINDING): New macro.\n+\t(IDENTIFIER_GLOBAL_VALUE): Use NAMESPACE_BINDING.\n+\t* *.c: Use them.\n+\n+\t* pt.c (push_template_decl): Use innermost_args.\n+\n+\t* decl.c (get_unique_name): Tweak from earlier in the name.\n+\n+Tue Feb 24 22:15:04 1998  Martin von Loewis  <loewis@informatik.hu-berlin.de>\n+\n+\t* cp-tree.def: Add CPLUS_BINDING node.\n+\t* cp-tree.h (tree_binding): new struct\n+\t(BINDING_SCOPE, BINDING_VALUE): new macros\n+\t(current_namespace, global_namespace): declare extern\n+\t(struct lang_decl_flags): new field in_namespace\n+\t(DECL_NAMESPACE_USING, DECL_NAMESPACE_USERS): new macros\n+\t(DECL_NAMESPACE, SET_DECL_NAMESPACE): new macros\n+\t(TREE_INDIRECT_USING): new macro\n+\t* decl2.c (current_namespace, global_namespace): Declare.  The\n+\tvalue is a NAMESPACE_DECL now, not a TREE_LIST.\n+\t(is_namespace_ancestor, namespace_ancestor):new static functions.\n+\t(add_using_namespace, ambiguous_decl): likewise.\n+\t(lookup_using_namespace): new support function for lookup_name.\n+\t(qualified_lookup_using_namespace): new support function for\n+\tdo_scoped_id and lookup_namespace_name\n+\t(get_namespace_id): mark as obsolete.\n+\t(current_namespace_id): Likewise.\n+\t(do_namespace_alias): Implement.\n+\t(do_using_directive): Implement as call to add_using_namespace.\n+\t* decl.c (binding_for_name): new function.\n+\t(push_namespace, pop_namespace): implement.\n+\t(push_decl): don't install a FUNCTION_DECL in the global branch.\n+\t(lookup_namespace_name): implement using qualified lookup.\n+\t(lookup_name_real): For global scoping, lookup in\n+\tglobal_namespace. For namespace scoping, lookup in given\n+\tnamespace. For unscoped lookup, iterate over namespace,\n+\tconsidering using directives.\n+\t(init_decl_processing): initialize global_namespace.\n+\t(grokvardecl): Build assembler name as static name for globals.\n+\t(grokdeclarator): Remove old namespace mangling.\n+\t(xref_tag): When installing a global binding for the\n+\ttag, make sure we have an identifier.\n+\t* method.c (build_overload_nested_name): mangle namespaces.\n+\t(build_qualified_name): Likewise.\n+\t(build_decl_overload_real): Likewise.\n+\t* lex.c (build_lang_decl): set namespace for new declaration to\n+\tcurrent_namespace.\n+\t(do_scoped_id): find global names in global or current\n+\tnamespace, or using qualified namespace lookup, depending on\n+\tcontext.\n+\t* init.c (build_member_call): When scope is namespace, use\n+\tbuild_x_function_call instead.\n+\t(build_offset_ref): When scope is namespace, collapse processing\n+\tto lookup_namespace_name instead.\n+\t* error.c (dump_decl): Support NAMESPACE_DECL.\n+\t* decl.c (pushdecl): Bind globals to current namespace.\n+\t(push_overloaded_decl): Likewise.\n+\t(lookup_tag): Likewise.\n+\t(lookup_name_current_level): Likewise.\n+\t(xref_tag): Likewise.\n+\t(start_function): Likewise.\n+\t* lex.c (do_identifier): Likewise.\n+\t(identifier_typedecl_value): Likewise.\n+\t(real_yylex): Likewise.\n+\t* method.c (do_inline_function_hair): Likewise.\n+\t* parse.y (unscoped): Likewise.\n+\t* pt.c (check_explicit_specialization): Likewise.\n+\t(lookup_template_class): Likewise.\n+\t* rtti.c (call_void_fn): Likewise.\n+\t* sig.c (build_sigtable): Likewise.\n+\t* ptree.c (lang_print_xnode): New function.\n+\n Tue Feb 24 01:40:24 1998  Jason Merrill  <jason@yorick.cygnus.com>\n \n \t* pt.c (instantiate_class_template): Don't instantiate if pedantic"}, {"sha": "1f39768a91dd25d60fa9e634181fa59021467a72", "filename": "gcc/cp/cp-tree.def", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30394414d9a403e26ab3cdc36514b0468167096d/gcc%2Fcp%2Fcp-tree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30394414d9a403e26ab3cdc36514b0468167096d/gcc%2Fcp%2Fcp-tree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.def?ref=30394414d9a403e26ab3cdc36514b0468167096d", "patch": "@@ -169,6 +169,10 @@ DEFTREECODE (DEFAULT_ARG, \"default_arg\", 'c', 2)\n    the template will will be an IDENTIFIER_NODE.  */\n DEFTREECODE (TEMPLATE_ID_EXPR, \"template_id_expr\", 'e', 2)\n \n+/* has two fields: scope and value */\n+/* XXX: could recycle some of the common fields */\n+DEFTREECODE (CPLUS_BINDING, \"binding\", 'x', 2)\n+\n /* A whole bunch of tree codes for the initial, superficial parsing of\n    templates.  */\n DEFTREECODE (LOOKUP_EXPR, \"lookup_expr\", 'e', 2)"}, {"sha": "dcaf69fb6de25b1924b7dbd80beccad44d76bdf2", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 44, "deletions": 3, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30394414d9a403e26ab3cdc36514b0468167096d/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30394414d9a403e26ab3cdc36514b0468167096d/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=30394414d9a403e26ab3cdc36514b0468167096d", "patch": "@@ -58,13 +58,28 @@ typedef struct\n   tree decl;\n } template_parm_index;\n \n+#define BINDING_SCOPE(NODE)    (((struct tree_binding*)NODE)->scope)\n+#define BINDING_VALUE(NODE)   (((struct tree_binding*)NODE)->value)\n+#define NAMESPACE_BINDING(ID,NS) BINDING_VALUE (binding_for_name (ID, NS))\n+#define IDENTIFIER_GLOBAL_VALUE(NODE) \\\n+  NAMESPACE_BINDING (NODE, global_namespace)\n+#define IDENTIFIER_NAMESPACE_VALUE(NODE) \\\n+  NAMESPACE_BINDING (NODE, current_namespace)\n+\n+struct tree_binding\n+{\n+  char common[sizeof (struct tree_common)];\n+  tree scope;\n+  tree value;\n+};\n+\n /* To identify to the debug emitters if it should pay attention to the\n    flag `-Wtemplate-debugging'.  */\n #define HAVE_TEMPLATES 1\n \n /* Macros for access to language-specific slots in an identifier.  */\n \n-#define IDENTIFIER_GLOBAL_VALUE(NODE)\t\\\n+#define IDENTIFIER_NAMESPACE_BINDINGS(NODE)\t\\\n   (((struct lang_identifier *)(NODE))->global_value)\n #define IDENTIFIER_CLASS_VALUE(NODE)\t\\\n   (((struct lang_identifier *)(NODE))->class_value)\n@@ -161,6 +176,9 @@ extern int current_function_returns_value;\n extern int current_function_returns_null;\n extern tree current_function_return_value;\n \n+extern tree current_namespace;\n+extern tree global_namespace;\n+\n extern tree ridpointers[];\n extern tree ansi_opname[];\n extern tree ansi_assopname[];\n@@ -967,6 +985,7 @@ struct lang_decl_flags\n   tree memfunc_pointer_to;\n   tree template_info;\n   struct binding_level *level;\n+  tree in_namespace;\n };\n \n struct lang_decl\n@@ -1071,20 +1090,32 @@ struct lang_decl\n \n /* The _TYPE context in which this _DECL appears.  This field holds the\n    class where a virtual function instance is actually defined, and the\n-   lexical scope of a friend function defined in a class body.  */\n+   lexical scope of a friend function defined in a class body. */\n #define DECL_CLASS_CONTEXT(NODE) (DECL_LANG_SPECIFIC(NODE)->decl_flags.context)\n #define DECL_REAL_CONTEXT(NODE) \\\n   ((TREE_CODE (NODE) == FUNCTION_DECL && DECL_FUNCTION_MEMBER_P (NODE)) \\\n    ? DECL_CLASS_CONTEXT (NODE) : DECL_CONTEXT (NODE))\n \n /* For a FUNCTION_DECL: the chain through which the next method\n    with the same name is found.  We now use TREE_CHAIN to\n-   walk through the methods in order of declaration.  */\n+   walk through the methods in order of declaration.  \n+   For a NAMESPACE_DECL: the list of using namespace directives\n+   The PURPOSE is the used namespace, the value is the namespace\n+   that is the common ancestor */\n #if 1\n #define DECL_CHAIN(NODE) (DECL_LANG_SPECIFIC(NODE)->chain)\n #else\n #define DECL_CHAIN(NODE) (TREE_CHAIN (NODE))\n #endif\n+#define DECL_NAMESPACE_USING(NODE) (DECL_LANG_SPECIFIC(NODE)->chain)\n+\n+/* In a NAMESPACE_DECL, the DECL_INITIAL is used to record all users\n+   of a namespace, to record the transitive closure of using namespace */\n+#define DECL_NAMESPACE_USERS(NODE) DECL_INITIAL (NODE)\n+\n+/* In a TREE_LIST concatenating using directives, indicate indirekt\n+   directives  */\n+#define TREE_INDIRECT_USING(NODE) ((NODE)->common.lang_flag_0)\n \n /* In a VAR_DECL for a variable declared in a for statement,\n    this is the shadowed (local) variable.  */\n@@ -1473,6 +1504,12 @@ extern int flag_new_for_scope;\n #define DECL_REALLY_EXTERN(NODE) \\\n   (DECL_EXTERNAL (NODE) && ! DECL_NOT_REALLY_EXTERN (NODE))\n \n+/* Records the namespace we are in */\n+#define DECL_NAMESPACE(NODE) \\\n+     (DECL_LANG_SPECIFIC (NODE) ? DECL_LANG_SPECIFIC (NODE)->decl_flags.in_namespace : 0)\n+#define SET_DECL_NAMESPACE(NODE, val) \\\n+     DECL_LANG_SPECIFIC (NODE)->decl_flags.in_namespace = val\n+\n /* Used to tell cp_finish_decl that it should approximate comdat linkage\n    as best it can for this decl.  */\n #define DECL_COMDAT(NODE) (DECL_LANG_SPECIFIC (NODE)->decl_flags.comdat)\n@@ -2122,11 +2159,14 @@ extern tree gettags\t\t\t\tPROTO((void));\n #if 0\n extern void set_current_level_tags_transparency\tPROTO((int));\n #endif\n+extern tree binding_for_name                    PROTO((tree, tree));\n extern tree lookup_namespace_name\t\tPROTO((tree, tree));\n extern tree make_typename_type\t\t\tPROTO((tree, tree));\n extern tree lookup_name_nonclass\t\tPROTO((tree));\n extern tree lookup_name\t\t\t\tPROTO((tree, int));\n extern tree lookup_name_current_level\t\tPROTO((tree));\n+extern tree lookup_using_namespace              PROTO((tree,tree,tree,tree));\n+extern tree qualified_lookup_using_namespace    PROTO((tree,tree));\n extern tree auto_function\t\t\tPROTO((tree, tree, enum built_in_function));\n extern void init_decl_processing\t\tPROTO((void));\n extern int init_type_desc\t\t\tPROTO((void));\n@@ -2375,6 +2415,7 @@ extern void synthesize_method\t\t\tPROTO((tree));\n extern tree get_id_2\t\t\t\tPROTO((char *, tree));\n \n /* in pt.c */\n+extern tree innermost_args\t\t\tPROTO ((tree, int));\n extern tree tsubst\t\t\t\tPROTO ((tree, tree, tree));\n extern tree tsubst_expr\t\t\t\tPROTO ((tree, tree, tree));\n extern tree tsubst_copy\t\t\t\tPROTO ((tree, tree, tree));"}, {"sha": "92730438dc44aa2a1fbfefa80616f86338a943ff", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 158, "deletions": 36, "changes": 194, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30394414d9a403e26ab3cdc36514b0468167096d/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30394414d9a403e26ab3cdc36514b0468167096d/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=30394414d9a403e26ab3cdc36514b0468167096d", "patch": "@@ -63,6 +63,9 @@ extern tree static_ctors, static_dtors;\n \n extern int static_labelno;\n \n+extern tree current_namespace;\n+extern tree global_namespace;\n+\n /* Stack of places to restore the search obstack back to.  */\n    \n /* Obstack used for remembering local class declarations (like\n@@ -1664,6 +1667,34 @@ print_binding_stack ()\n   print_binding_level (global_binding_level);\n }\n \n+/* Return the tree_binding for the name in the given scope\n+   If there are no bindings for the name in the scope, make a new\n+   bindings node. This bindings list of this node will be empty, though.  */\n+\n+tree\n+binding_for_name (name, scope)\n+     tree name;\n+     tree scope;\n+{\n+  tree iter;\n+  for (iter = IDENTIFIER_NAMESPACE_BINDINGS (name); iter;\n+       iter = TREE_CHAIN (iter))\n+    {\n+      my_friendly_assert (TREE_CODE (iter) == CPLUS_BINDING, 374);\n+      if (BINDING_SCOPE (iter) == scope)\n+\treturn iter;\n+    }\n+  /* not found, make a new permanent one */\n+  push_obstacks (&permanent_obstack, &permanent_obstack);\n+  iter = make_node (CPLUS_BINDING);\n+  TREE_CHAIN (iter) = IDENTIFIER_NAMESPACE_BINDINGS (name);\n+  IDENTIFIER_NAMESPACE_BINDINGS (name) = iter;\n+  BINDING_SCOPE (iter) = scope;\n+  BINDING_VALUE (iter) = NULL_TREE;\n+  pop_obstacks ();\n+  return iter;\n+}\n+\n extern char * first_global_object_name;\n \n /* Get a unique name for each call to this routine for unnamed namespaces.\n@@ -1692,7 +1723,7 @@ get_unique_name ()\n   /* Don't need to pull weird characters out of global names.  */\n   if (p != first_global_object_name)\n     {\n-      for (p = buf+11; *p; p++)\n+      for (p = buf+2; *p; p++)\n \tif (! ((*p >= '0' && *p <= '9')\n #ifndef NO_DOLLAR_IN_LABEL\t/* this for `$'; unlikely, but... -- kr */\n \t       || *p == '$'\n@@ -1716,13 +1747,42 @@ push_namespace (name)\n      tree name;\n {\n #if 1\n-  static int warned;\n-  if (! warned)\n-    sorry (\"namespace\");\n+  tree d;\n+  int need_new = 1;\n+  int implicit_use = 0;\n+  int nodecl = 0;\n+  if (!global_namespace)\n+    {\n+      /* this must be :: */\n+      my_friendly_assert (name == get_identifier (\"::\"), 377);\n+      nodecl = 1;\n+    }\n+  else if (!name)\n+    {\n+      name = get_unique_name ();\n+      implicit_use = 1;\n+    } \n+  else\n+    {\n+      /* check whether this is an extended namespace definition */\n+      d = IDENTIFIER_NAMESPACE_VALUE (name);\n+      if (d != NULL_TREE && TREE_CODE (d) == NAMESPACE_DECL)\n+\tneed_new = 0;\n+    }\n   \n-  warned = 1;\n+  if (need_new)\n+    {\n+      /* make a new namespace, binding the name to it */\n+      d = build_lang_decl (NAMESPACE_DECL, name, void_type_node);\n+      if (!nodecl)\n+\td = pushdecl (d);\n+    }\n+  if (implicit_use)\n+    do_using_directive (d);\n+  /* enter the name space */\n+  current_namespace = d;\n+\n #else\n-  extern tree current_namespace;\n   tree old_id = get_namespace_id ();\n   char *buf;\n   tree d;\n@@ -1766,8 +1826,9 @@ push_namespace (name)\n void\n pop_namespace ()\n {\n-#if 0\n-  extern tree current_namespace;\n+#if 1\n+  current_namespace = DECL_NAMESPACE (current_namespace);\n+#else\n   tree decls, link;\n   current_namespace = TREE_CHAIN (current_namespace);\n \n@@ -3242,11 +3303,12 @@ pushdecl (x)\n       if (TREE_PUBLIC (x) && TREE_CODE (x) != FUNCTION_DECL)\n \t{\n \t  tree decl;\n+\t  tree bindings = binding_for_name (name, current_namespace);\n \n-\t  if (IDENTIFIER_GLOBAL_VALUE (name) != NULL_TREE\n-\t      && (DECL_EXTERNAL (IDENTIFIER_GLOBAL_VALUE (name))\n-\t\t  || TREE_PUBLIC (IDENTIFIER_GLOBAL_VALUE (name))))\n-\t    decl = IDENTIFIER_GLOBAL_VALUE (name);\n+\t  if (BINDING_VALUE (bindings) != NULL_TREE\n+\t      && (DECL_EXTERNAL (BINDING_VALUE (bindings))\n+\t\t  || TREE_PUBLIC (BINDING_VALUE (bindings))))\n+\t    decl = BINDING_VALUE (bindings);\n \t  else\n \t    decl = NULL_TREE;\n \n@@ -3265,18 +3327,24 @@ pushdecl (x)\n       if (b == global_binding_level)\n \t{\n \t  /* Install a global value.  */\n+\t  tree bindings = binding_for_name (name, current_namespace);\n \n \t  /* If the first global decl has external linkage,\n \t     warn if we later see static one.  */\n-\t  if (IDENTIFIER_GLOBAL_VALUE (name) == NULL_TREE && TREE_PUBLIC (x))\n+\t  if (BINDING_VALUE (bindings) == NULL_TREE && TREE_PUBLIC (x))\n \t    TREE_PUBLIC (name) = 1;\n \n \t  /* Don't install an artificial TYPE_DECL if we already have\n \t     another _DECL with that name.  */\n \t  if (TREE_CODE (x) != TYPE_DECL\n \t      || t == NULL_TREE\n \t      || ! DECL_ARTIFICIAL (x))\n-\t    IDENTIFIER_GLOBAL_VALUE (name) = x;\n+\t    {\n+\t      if (TREE_CODE (x) == FUNCTION_DECL)\n+\t\tmy_friendly_assert ((BINDING_VALUE (bindings) == NULL_TREE)\n+\t\t                    || BINDING_VALUE (bindings) == x, 378);\n+\t      BINDING_VALUE (bindings) = x;\n+\t    }\n \n \t  /* Don't forget if the function was used via an implicit decl.  */\n \t  if (IDENTIFIER_IMPLICIT_DECL (name)\n@@ -3305,7 +3373,7 @@ pushdecl (x)\n \t{\n \t  /* Here to install a non-global value.  */\n \t  tree oldlocal = IDENTIFIER_LOCAL_VALUE (name);\n-\t  tree oldglobal = IDENTIFIER_GLOBAL_VALUE (name);\n+\t  tree oldglobal = binding_for_name (name, current_namespace);\n \n \t  /* Don't install an artificial TYPE_DECL if we already have\n \t     another _DECL with that name.  */\n@@ -3331,24 +3399,24 @@ pushdecl (x)\n \t     have a global definition or declaration for the function.  */\n \t  if (oldlocal == NULL_TREE\n \t      && DECL_EXTERNAL (x)\n-\t      && oldglobal != NULL_TREE\n+\t      && BINDING_VALUE (oldglobal) != NULL_TREE\n \t      && TREE_CODE (x) == FUNCTION_DECL\n-\t      && TREE_CODE (oldglobal) == FUNCTION_DECL)\n+\t      && TREE_CODE (BINDING_VALUE (oldglobal)) == FUNCTION_DECL)\n \t    {\n \t      /* We have one.  Their types must agree.  */\n-\t      if (decls_match (x, oldglobal))\n+\t      if (decls_match (x, BINDING_VALUE (oldglobal)))\n \t\t/* OK */;\n \t      else\n \t\t{\n \t\t  cp_warning (\"extern declaration of `%#D' doesn't match\", x);\n-\t\t  cp_warning_at (\"global declaration `%#D'\", oldglobal);\n+\t\t  cp_warning_at (\"global declaration `%#D'\", BINDING_VALUE (oldglobal));\n \t\t}\n \t    }\n \t  /* If we have a local external declaration,\n \t     and no file-scope declaration has yet been seen,\n \t     then if we later have a file-scope decl it must not be static.  */\n \t  if (oldlocal == NULL_TREE\n-\t      && oldglobal == NULL_TREE\n+\t      && BINDING_VALUE (oldglobal) == NULL_TREE\n \t      && DECL_EXTERNAL (x)\n \t      && TREE_PUBLIC (x))\n \t    {\n@@ -3398,7 +3466,8 @@ pushdecl (x)\n \t\twarnstring = \"declaration of `%s' shadows a member of `this'\";\n \t      else if (oldlocal != NULL_TREE)\n \t\twarnstring = \"declaration of `%s' shadows previous local\";\n-\t      else if (oldglobal != NULL_TREE)\n+\t      else if (BINDING_VALUE (oldglobal) != NULL_TREE)\n+\t\t/* XXX shadow warnings in outer-more namespaces */\n \t\twarnstring = \"declaration of `%s' shadows global declaration\";\n \n \t      if (warnstring)\n@@ -3641,7 +3710,7 @@ push_overloaded_decl (decl, forgettable)\n \n   if (doing_global)\n     {\n-      old = IDENTIFIER_GLOBAL_VALUE (orig_name);\n+      old =  IDENTIFIER_NAMESPACE_VALUE (orig_name);\n       if (old && TREE_CODE (old) == FUNCTION_DECL\n \t  && DECL_ARTIFICIAL (old)\n \t  && (DECL_BUILT_IN (old) || DECL_BUILT_IN_NONANSI (old)))\n@@ -3704,7 +3773,7 @@ push_overloaded_decl (decl, forgettable)\n     old = decl;\n \n   if (doing_global)\n-    IDENTIFIER_GLOBAL_VALUE (orig_name) = old;\n+    IDENTIFIER_NAMESPACE_VALUE (orig_name) = old;\n   else\n     IDENTIFIER_LOCAL_VALUE (orig_name) = old;\n \n@@ -4207,7 +4276,8 @@ lookup_tag (form, name, binding_level, thislevel_only)\n \t{\n \t  if (level->pseudo_global)\n \t    {\n-\t      tree t = IDENTIFIER_GLOBAL_VALUE (name);\n+\t      /* XXX MvL */\n+\t      tree t = IDENTIFIER_NAMESPACE_VALUE (name);\n \t      if (t && TREE_CODE (t) == TEMPLATE_DECL\n \t\t  && TREE_CODE (DECL_TEMPLATE_RESULT (t)) == TYPE_DECL)\n \t\treturn TREE_TYPE (t);\n@@ -4358,9 +4428,19 @@ tree\n lookup_namespace_name (namespace, name)\n      tree namespace, name;\n {\n+#if 1\n+  tree val;\n+  my_friendly_assert (TREE_CODE (namespace) == NAMESPACE_DECL, 370);\n+  my_friendly_assert (TREE_CODE (name) == IDENTIFIER_NODE, 373);\n+  \n+  val = qualified_lookup_using_namespace (name, namespace);\n+  if (val)\n+    return val;\n+  cp_error (\"`%D' undeclared in namespace `%D'\", name, namespace);\n+  return error_mark_node;\n+#else\n   struct binding_level *b = (struct binding_level *)NAMESPACE_LEVEL (namespace);\n   tree x = NULL_TREE;\n-\n #if 1\n   /* This searches just one level.  */\n   if (b)\n@@ -4379,6 +4459,7 @@ lookup_namespace_name (namespace, name)\n     }\n #endif\n   return x;\n+#endif\n }\n \n tree\n@@ -4518,7 +4599,7 @@ lookup_name_real (name, prefer_type, nonclass)\n \t    val = IDENTIFIER_GLOBAL_VALUE (name);\n \t  else if (TREE_CODE (type) == NAMESPACE_DECL)\n \t    {\n-\t      val = lookup_namespace_name (type, name);\n+\t      val = NAMESPACE_BINDING (name, type);\n \t    }\n \t  else if (! IS_AGGR_TYPE (type)\n \t\t   || TREE_CODE (type) == TEMPLATE_TYPE_PARM\n@@ -4635,7 +4716,22 @@ lookup_name_real (name, prefer_type, nonclass)\n   else if (classval)\n     val = classval;\n   else\n-    val = IDENTIFIER_GLOBAL_VALUE (name);\n+    {\n+      /* unscoped lookup of a global, iterate over namespaces,\n+         considering using namespace statements */\n+      tree binding;\n+      tree scope = current_namespace;\n+      do\n+\t{\n+\t  binding = binding_for_name (name, scope);\n+\t  val = BINDING_VALUE (binding);\n+\t  val = lookup_using_namespace (name, val, current_namespace, scope);\n+\t  if (scope == global_namespace)\n+\t    break;\n+\t  scope = DECL_NAMESPACE (scope);\n+\t}\n+      while (!val);\n+    }\n \n  done:\n   if (val)\n@@ -4695,7 +4791,7 @@ lookup_name_current_level (name)\n \n   if (current_binding_level == global_binding_level)\n     {\n-      t = IDENTIFIER_GLOBAL_VALUE (name);\n+      t =  IDENTIFIER_NAMESPACE_VALUE (name);\n \n       /* extern \"C\" function() */\n       if (t != NULL_TREE && TREE_CODE (t) == TREE_LIST)\n@@ -4782,6 +4878,7 @@ record_builtin_type (rid_index, name, type)\n       tdecl = pushdecl (build_decl (TYPE_DECL, tname, type));\n       set_identifier_type_value (tname, NULL_TREE);\n       if ((int) rid_index < (int) RID_MAX)\n+\t/* builtin types live in the global namespace */\n \tIDENTIFIER_GLOBAL_VALUE (tname) = tdecl;\n     }\n   if (rname != NULL_TREE)\n@@ -4851,6 +4948,14 @@ init_decl_processing ()\n   lang_name_cplusplus = get_identifier (\"C++\");\n   lang_name_c = get_identifier (\"C\");\n \n+  /* enter the global namespace */\n+  my_friendly_assert (global_namespace == NULL_TREE, 375);\n+  my_friendly_assert (current_lang_name == NULL_TREE, 375);\n+  current_lang_name = lang_name_cplusplus;\n+  push_namespace (get_identifier (\"::\"));\n+  global_namespace = current_namespace;\n+  current_lang_name = NULL_TREE;\n+\n   if (flag_strict_prototype == 2)\n     {\n       if (pedantic)\n@@ -7484,6 +7589,7 @@ grokfndecl (ctype, type, declarator, orig_declarator, virtualp, flags, quals,\n \n       if (check == 0 && ! current_function_decl)\n \t{\n+\t  /* assembler names live in the global namespace */\n \t  tmp = IDENTIFIER_GLOBAL_VALUE (DECL_ASSEMBLER_NAME (decl));\n \t  if (tmp == NULL_TREE)\n \t    IDENTIFIER_GLOBAL_VALUE (DECL_ASSEMBLER_NAME (decl)) = decl;\n@@ -7611,9 +7717,12 @@ grokvardecl (type, declarator, specbits_in, initialized, constp)\n       DECL_ASSEMBLER_NAME (decl) = build_static_name (basetype, declarator);\n     }\n   else\n-    decl = build_decl (VAR_DECL, declarator, complete_type (type));\n-\n-  DECL_ASSEMBLER_NAME (decl) = current_namespace_id (DECL_ASSEMBLER_NAME (decl));\n+    {\n+      decl = build_decl (VAR_DECL, declarator, complete_type (type));\n+      if (current_namespace != global_namespace)\n+\tDECL_ASSEMBLER_NAME (decl) =  build_static_name (current_namespace,\n+\t\t\t\t\t\t\t declarator);\n+    }\n \n   if (RIDBIT_SETP (RID_EXTERN, specbits))\n     {\n@@ -9928,7 +10037,12 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \tif (ctype == NULL_TREE && DECL_LANGUAGE (decl) != lang_c\n \t    && (! DECL_USE_TEMPLATE (decl) ||\n \t\tname_mangling_version < 1)) \n+#if 0\n+\t/* XXX is support for the old __ns_ mangling really needed? MvL */\n \t  DECL_ASSEMBLER_NAME (decl) = current_namespace_id (declarator);\n+#else\n+\t  DECL_ASSEMBLER_NAME (decl) = declarator;\n+#endif\t\n \t\n \tif (staticp == 1)\n \t  {\n@@ -10931,10 +11045,16 @@ xref_tag (code_type_node, name, binfo, globalize)\n   else\n     {\n       /* If it no longer looks like a nested type, make sure it's\n-\t in global scope.  */\n+\t in global scope.  \n+         If it is not an IDENTIFIER, this is not a declaration */\n       if (b == global_binding_level && !class_binding_level\n-\t  && IDENTIFIER_GLOBAL_VALUE (name) == NULL_TREE)\n-\tIDENTIFIER_GLOBAL_VALUE (name) = TYPE_NAME (ref);\n+\t  && TREE_CODE (name) == IDENTIFIER_NODE)\n+\t{\n+\t  tree binding;\n+\t  binding = binding_for_name (name, current_namespace);\n+\t  if (BINDING_VALUE (binding) == NULL_TREE)\n+\t    BINDING_VALUE (binding) = TYPE_NAME (ref);\n+\t}\n     }\n \n   if (binfo)\n@@ -11465,11 +11585,13 @@ start_function (declspecs, declarator, attrs, pre_parsed_p)\n \t  && TYPE_IDENTIFIER (DECL_CONTEXT (decl1))\n \t  && IDENTIFIER_TEMPLATE (TYPE_IDENTIFIER (DECL_CONTEXT (decl1))))\n \t{\n+\t  tree binding = binding_for_name (DECL_NAME (decl1), \n+\t\t\t\t\t   current_namespace);\n \t  cp_error (\"redeclaration of `%#D'\", decl1);\n \t  if (IDENTIFIER_CLASS_VALUE (DECL_NAME (decl1)))\n \t    cp_error_at (\"previous declaration here\", IDENTIFIER_CLASS_VALUE (DECL_NAME (decl1)));\n-\t  else if (IDENTIFIER_GLOBAL_VALUE (DECL_NAME (decl1)))\n-\t    cp_error_at (\"previous declaration here\", IDENTIFIER_GLOBAL_VALUE (DECL_NAME (decl1)));\n+\t  else if (BINDING_VALUE (binding))\n+\t    cp_error_at (\"previous declaration here\", BINDING_VALUE (binding));\n \t}\n \n       fntype = TREE_TYPE (decl1);"}, {"sha": "b0363f1f2cec301b80a106352f5b257cfc09c30a", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 210, "deletions": 3, "changes": 213, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30394414d9a403e26ab3cdc36514b0468167096d/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30394414d9a403e26ab3cdc36514b0468167096d/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=30394414d9a403e26ab3cdc36514b0468167096d", "patch": "@@ -90,6 +90,12 @@ int at_eof;\n /* Functions called along with real static constructors and destructors.  */\n \n tree static_ctors, static_dtors;\n+\n+/* The current open namespace, and :: */\n+\n+tree current_namespace;\n+tree global_namespace;\n+\n \f\n /* C (and C++) language-specific option variables.  */\n \n@@ -2880,6 +2886,9 @@ get_sentry (base)\n      tree base;\n {\n   tree sname = get_id_2 (\"__sn\", base);\n+  /* for struct X foo __attribute__((weak)), there is a counter\n+     __snfoo. Since base is already an assembler name, sname should\n+     be globally unique */\n   tree sentry = IDENTIFIER_GLOBAL_VALUE (sname);\n   if (! sentry)\n     {\n@@ -3756,8 +3765,179 @@ check_cp_case_value (value)\n   return value;\n }\n \n-tree current_namespace;\n+/* return 1 if root encloses child */\n+static int\n+is_namespace_ancestor (root, child)\n+     tree root, child;\n+{\n+  if (root == child)\n+    return 1;\n+  if (root == global_namespace)\n+    return 1;\n+  if (child == global_namespace)\n+    return 0;\n+  return is_namespace_ancestor (root, DECL_NAMESPACE (child));\n+}\n+  \n+\n+/* return the namespace that is the common ancestor \n+   of two given namespaces */\n+static tree\n+namespace_ancestor (ns1, ns2)\n+     tree ns1, ns2;\n+{\n+  if (is_namespace_ancestor (ns1, ns2))\n+    return ns1;\n+  return namespace_ancestor (DECL_NAMESPACE (ns1), ns2);\n+}\n+\n+/* Insert used into the using list of user. Set indirect_flag if this\n+   directive is not directly from the source. Also find the common\n+   ancestor and let our users know about the new namespace */\n+static void \n+add_using_namespace (user, used, indirect)\n+     tree user;\n+     tree used;\n+     int indirect;\n+{\n+  tree iter;\n+  /* using oneself is a no-op */\n+  if (user == used)\n+    return;\n+  my_friendly_assert (TREE_CODE (user) == NAMESPACE_DECL, 380);\n+  my_friendly_assert (TREE_CODE (used) == NAMESPACE_DECL, 380);\n+  /* check if we already have this */\n+  if (purpose_member (used, DECL_NAMESPACE_USING (user)) != NULL_TREE)\n+    return;\n+\n+  /* add used to the user's using list */\n+  DECL_NAMESPACE_USING (user) \n+    = perm_tree_cons (used, namespace_ancestor (user, used), \n+\t\t      DECL_NAMESPACE_USING (user));\n+\n+  TREE_INDIRECT_USING (DECL_NAMESPACE_USING (user)) = indirect;\n+\n+  /* add user to the used's users list */\n+  DECL_NAMESPACE_USERS (used)\n+    = perm_tree_cons (user, 0, DECL_NAMESPACE_USERS (used));\n+\t\t      \n+  for (iter = DECL_NAMESPACE_USERS (user); iter; iter = TREE_CHAIN (iter))\n+    /* indirect usage */\n+    add_using_namespace (TREE_PURPOSE (iter), used, 1);\n+}\n+\n+/* This should return an error not all definitions define functions.\n+   It is not an error if we find two functions with exactly the\n+   same signature, only if these are selected in overload resolution.\n+   XXX Do we want to give *all* candidates in case of ambiguity?\n+   XXX In what way should I treat extern declarations?\n+   XXX I don't want to repeat the entire duplicate_decls here */\n+static tree\n+ambiguous_decl (name, val1, val2)\n+     tree val1, val2;\n+{\n+  my_friendly_assert (val1 != val2, 376);\n+  if (is_overloaded_fn (val1) && is_overloaded_fn (val1))\n+    {\n+      /* now built a joint list of all overloaded declarations */\n+      /* XXX if I chain'em together, they will be always considered\n+\t as overloaded */\n+      sorry (\"overloaded functions used from different namespaces\");\n+    }\n+  cp_error (\"ambiguous definition `%D' used\", name);\n+  cp_error_at (\"first definition here\", val1);\n+  cp_error_at (\"other definition here\", val2);\n+  return error_mark_node;\n+}\n+\n+/* add the bindings of name in used namespaces to val \n+   the using list is defined by current, and the lookup goes to scope */\n+tree\n+lookup_using_namespace (name, val, current, scope)\n+     tree name, val, current, scope;\n+{\n+  tree iter;\n+  tree val1;\n+  /* iterate over all namespaces from current to scope */\n+  while (1)\n+    {\n+      /* iterate over all used namespaces in current, searching for\n+\t using directives of scope */\n+      for (iter = DECL_NAMESPACE_USING (current); \n+\t   iter; iter = TREE_CHAIN (iter))\n+\tif (TREE_VALUE (iter) == scope)\n+\t  {\n+\t    val1 = NAMESPACE_BINDING (name, TREE_PURPOSE (iter));\n+\t    /* name not found in this space */\n+\t    if (!val1) \n+\t      continue;\n+\t    /* first definition ever */\n+\t    if (!val)\n+\t      {\n+\t\tval = val1;\n+\t\tcontinue;\n+\t      }\n+\t    /* Hmmm. Ambiguity. As long as both are overloaded functions,\n+\t       this is fine */\n+\t    val = ambiguous_decl (name, val, val1);\n+\t    if (val == error_mark_node)\n+\t      break;\n+\t  }\n+      if (current == scope)\n+\tbreak;\n+      current = DECL_NAMESPACE (current);\n+    }\n+  return val;\n+}\n \n+/* [namespace.qual] */\n+tree\n+qualified_lookup_using_namespace (name, scope)\n+     tree name;\n+     tree scope;\n+{\n+  tree val = NULL_TREE;\n+  tree val1;\n+  /* maintain a list of namespaces visited */\n+  tree seen = NULL_TREE;\n+  /* and a list of namespace yet to see */\n+  tree todo = NULL_TREE;\n+  tree usings;\n+  while (scope)\n+    {\n+      seen = temp_tree_cons (scope, NULL_TREE, seen);\n+      val1 = NAMESPACE_BINDING (name, scope);\n+      if (val1)\n+\t{\n+\t  if (val)\n+\t    {\n+\t      val = ambiguous_decl (name, val, val1);\n+\t      break;\n+\t    }\n+\t  else\n+\t    val = val1;\n+\t}\n+      else\n+\t/* consider using directives */\n+\tfor (usings = DECL_NAMESPACE_USING (scope); usings;\n+\t     usings = TREE_CHAIN (usings))\n+\t  /* if this was a real directive, and we have not seen it */\n+\t  if (!TREE_INDIRECT_USING (usings)\n+\t      && !purpose_member (seen, TREE_PURPOSE (usings)))\n+\t    todo = temp_tree_cons (TREE_PURPOSE (usings), NULL_TREE, todo);\n+      if (todo)\n+\t{\n+\t  scope = TREE_PURPOSE (todo);\n+\t  todo = TREE_CHAIN (todo);\n+\t}\n+      else\n+\tscope = NULL_TREE; /* if there never was a todo list */\n+    }\n+  return val;\n+}\n+\n+#if 0\n+/* this is broken and should not be called anymore */\n /* Get the inner part of a namespace id.  It doesn't have any prefix, nor\n    postfix.  Returns 0 if in global namespace.  */\n \n@@ -3789,12 +3969,35 @@ current_namespace_id (name)\n \t   IDENTIFIER_POINTER (name));\n   return get_identifier (buf);\n }\n+#endif\n \n void\n do_namespace_alias (alias, namespace)\n      tree alias, namespace;\n {\n-  sorry (\"namespace alias\");\n+  tree binding;\n+  tree ns;\n+  if (TREE_CODE (namespace) == IDENTIFIER_NODE)\n+    ns = lookup_name (namespace, 1);\n+  else\n+    ns = namespace;\n+  if (TREE_CODE (ns) != NAMESPACE_DECL)\n+    {\n+      cp_error (\"`%D' is not a namespace\", namespace);\n+      return;\n+    }\n+  binding = binding_for_name (alias, current_namespace);\n+  if (BINDING_VALUE (binding) && BINDING_VALUE (binding) != namespace)\n+    {\n+      cp_error (\"invalid namespace alias `%D'\", alias);\n+      cp_error_at (\"`%D' previously declared here\", alias);\n+    }\n+  else\n+    {\n+      /* XXX the alias is not exactly identical to the name space,\n+\t it must not be used in a using directive or namespace alias */\n+      BINDING_VALUE (binding) = ns;\n+    }\n }\n \n void\n@@ -3856,7 +4059,11 @@ do_using_directive (namespace)\n {\n   if (namespace == std_node)\n     return;\n-  sorry (\"using directive\");\n+  /* using A::B::C; */\n+  if (TREE_CODE (namespace) == SCOPE_REF)\n+      namespace = TREE_OPERAND (namespace, 1);\n+  /* direct usage */\n+  add_using_namespace (current_namespace, namespace, 0);\n }\n \n void"}, {"sha": "31a38bb52d33eed34b5c5a553e0bdf0fe4189d75", "filename": "gcc/cp/error.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30394414d9a403e26ab3cdc36514b0468167096d/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30394414d9a403e26ab3cdc36514b0468167096d/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=30394414d9a403e26ab3cdc36514b0468167096d", "patch": "@@ -697,6 +697,11 @@ dump_decl (t, v)\n       break;\n \n     case NAMESPACE_DECL:\n+      if (DECL_NAMESPACE (t) != global_namespace)\n+\t{\n+\t  dump_decl (DECL_NAMESPACE (t), v);\n+\t  OB_PUTC2 (':',':');\n+\t}\n       OB_PUTID (DECL_NAME (t));\n       break;\n "}, {"sha": "c80403e7ae5cecabb7e48d485f0523ccad67737a", "filename": "gcc/cp/init.c", "status": "modified", "additions": 5, "deletions": 14, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30394414d9a403e26ab3cdc36514b0468167096d/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30394414d9a403e26ab3cdc36514b0468167096d/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=30394414d9a403e26ab3cdc36514b0468167096d", "patch": "@@ -1703,6 +1703,9 @@ build_member_call (type, name, parmlist)\n   if (type == std_node)\n     return build_x_function_call (do_scoped_id (name, 0), parmlist,\n \t\t\t\t  current_class_ref);\n+  if (TREE_CODE (type) == NAMESPACE_DECL)\n+    return build_x_function_call (lookup_namespace_name (type, name),\n+\t\t\t\t  parmlist, current_class_ref);\n \n   if (TREE_CODE (name) != TEMPLATE_ID_EXPR)\n     method_name = name;\n@@ -1840,20 +1843,8 @@ build_offset_ref (type, name)\n     return build_min_nt (SCOPE_REF, type, name);\n \n   /* Handle namespace names fully here.  */\n-  if (TREE_CODE (type) == IDENTIFIER_NODE\n-      && get_aggr_from_typedef (type, 0) == 0)\n-    {\n-      tree ns = lookup_name (type, 0);\n-      tree val;\n-      if (ns && TREE_CODE (ns) == NAMESPACE_DECL)\n-\t{\n-\t  val = lookup_namespace_name (ns, name);\n-\t  if (val)\n-\t    return val;\n-\t  cp_error (\"namespace `%D' has no member named `%D'\", ns, name);\n-\t  return error_mark_node;\n-\t}\n-    }\n+  if (TREE_CODE (type) == NAMESPACE_DECL)\n+      return lookup_namespace_name (type, name);\n \n   if (type == NULL_TREE || ! is_aggr_type (type, 1))\n     return error_mark_node;"}, {"sha": "3b71c49f3ad49fc63ee840f92790b68d2f36ddd0", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 16, "deletions": 9, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30394414d9a403e26ab3cdc36514b0468167096d/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30394414d9a403e26ab3cdc36514b0468167096d/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=30394414d9a403e26ab3cdc36514b0468167096d", "patch": "@@ -2800,7 +2800,7 @@ do_identifier (token, parsing)\n     yychar = yylex ();\n   /* Scope class declarations before global\n      declarations.  */\n-  if (id == IDENTIFIER_GLOBAL_VALUE (token)\n+  if (id == IDENTIFIER_NAMESPACE_VALUE (token)\n       && current_class_type != 0\n       && TYPE_SIZE (current_class_type) == 0)\n     {\n@@ -2868,7 +2868,7 @@ do_identifier (token, parsing)\n \t}\n       else\n \t{\n-\t  if (IDENTIFIER_GLOBAL_VALUE (token) != error_mark_node\n+\t  if (IDENTIFIER_NAMESPACE_VALUE (token) != error_mark_node\n \t      || IDENTIFIER_ERROR_LOCUS (token) != current_function_decl)\n \t    {\n \t      static int undeclared_variable_notice;\n@@ -2884,7 +2884,7 @@ do_identifier (token, parsing)\n \t    }\n \t  id = error_mark_node;\n \t  /* Prevent repeated error messages.  */\n-\t  IDENTIFIER_GLOBAL_VALUE (token) = error_mark_node;\n+\t  IDENTIFIER_NAMESPACE_VALUE (token) = error_mark_node;\n \t  SET_IDENTIFIER_ERROR_LOCUS (token, current_function_decl);\n \t}\n     }\n@@ -2896,7 +2896,7 @@ do_identifier (token, parsing)\n \t     && DECL_DEAD_FOR_LOCAL (shadowed))\n \tshadowed = DECL_SHADOWED_FOR_VAR (shadowed);\n       if (!shadowed)\n-\tshadowed = IDENTIFIER_GLOBAL_VALUE (DECL_NAME (id));\n+\tshadowed = IDENTIFIER_NAMESPACE_VALUE (DECL_NAME (id));\n       if (shadowed)\n \t{\n \t  if (!DECL_ERROR_REPORTED (id))\n@@ -2953,7 +2953,7 @@ do_identifier (token, parsing)\n \t{\n \t  tree t = build_min (LOOKUP_EXPR, unknown_type_node,\n \t\t\t      token, get_first_fn (id));\n-\t  if (id != IDENTIFIER_GLOBAL_VALUE (token))\n+\t  if (id != IDENTIFIER_NAMESPACE_VALUE (token))\n \t    TREE_OPERAND (t, 1) = error_mark_node;\n \t  id = t;\n \t}\n@@ -2971,7 +2971,12 @@ do_scoped_id (token, parsing)\n      tree token;\n      int parsing;\n {\n-  tree id = IDENTIFIER_GLOBAL_VALUE (token);\n+  tree id;\n+  /* during parsing, this is ::name. Otherwise, it is black magic. */\n+  if (parsing)\n+    id = qualified_lookup_using_namespace (token, global_namespace);\n+  else\n+    id = IDENTIFIER_GLOBAL_VALUE (token);\n   if (parsing && yychar == YYEMPTY)\n     yychar = yylex ();\n   if (! id)\n@@ -2986,12 +2991,12 @@ do_scoped_id (token, parsing)\n \tid = implicitly_declare (token);\n       else\n \t{\n-\t  if (IDENTIFIER_GLOBAL_VALUE (token) != error_mark_node)\n+\t  if (IDENTIFIER_NAMESPACE_VALUE (token) != error_mark_node)\n \t    error (\"undeclared variable `%s' (first use here)\",\n \t\t   IDENTIFIER_POINTER (token));\n \t  id = error_mark_node;\n \t  /* Prevent repeated error messages.  */\n-\t  IDENTIFIER_GLOBAL_VALUE (token) = error_mark_node;\n+\t  IDENTIFIER_NAMESPACE_VALUE (token) = error_mark_node;\n \t}\n     }\n   else\n@@ -3040,7 +3045,7 @@ identifier_typedecl_value (node)\n   }\n   do (IDENTIFIER_LOCAL_VALUE (node));\n   do (IDENTIFIER_CLASS_VALUE (node));\n-  do (IDENTIFIER_GLOBAL_VALUE (node));\n+  do (IDENTIFIER_NAMESPACE_VALUE (node));\n #undef do\n   /* Will this one ever happen?  */\n   if (TYPE_MAIN_DECL (type))\n@@ -4376,6 +4381,8 @@ build_lang_decl (code, name, type)\n     DECL_LANGUAGE (t) = lang_c;\n   else my_friendly_abort (64);\n \n+  SET_DECL_NAMESPACE (t, current_namespace);\n+\n #if 0 /* not yet, should get fixed properly later */\n   if (code == TYPE_DECL)\n     {"}, {"sha": "beb5f2952113c219ee3063ff8b1ed86228498994", "filename": "gcc/cp/method.c", "status": "modified", "additions": 56, "deletions": 12, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30394414d9a403e26ab3cdc36514b0468167096d/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30394414d9a403e26ab3cdc36514b0468167096d/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=30394414d9a403e26ab3cdc36514b0468167096d", "patch": "@@ -537,7 +537,14 @@ build_overload_nested_name (decl)\n             }\n         }\n     }\n-\n+  else if (decl == global_namespace)\n+    return;\n+  else if (DECL_NAMESPACE (decl))\n+    build_overload_nested_name (DECL_NAMESPACE (decl));\n+  else\n+    /* XXX the above does not work for non-namespaces */\n+    if (current_namespace && TREE_CODE (decl) != NAMESPACE_DECL)\n+      build_overload_nested_name (current_namespace);\n \n   if (TREE_CODE (decl) == FUNCTION_DECL)\n     {\n@@ -553,6 +560,8 @@ build_overload_nested_name (decl)\n       OB_PUTCP (label);\n       numeric_output_need_bar = 1;\n     }\n+  else if (TREE_CODE (decl) == NAMESPACE_DECL)\n+    build_overload_identifier (DECL_NAME (decl));\n   else\t\t\t\t/* TYPE_DECL */\n     build_overload_identifier (decl);\n }\n@@ -969,16 +978,37 @@ build_qualified_name (decl)\n   context = decl;\n   /* if we can't find a Ktype, do it the hard way */\n   if (check_ktype (context, FALSE) == -1)\n-    while (DECL_CONTEXT (context))\n-      {\n-        i += 1;\n-        context = DECL_CONTEXT (context);\n-        if (check_ktype (context, FALSE) != -1)  /* found it! */\n-          break;\n-        if (TREE_CODE_CLASS (TREE_CODE (context)) == 't')\n-          context = TYPE_NAME (context);\n-      }\n+    {\n+      /* count type scopes */\n+      while (DECL_CONTEXT (context))\n+\t{\n+\t  i += 1;\n+\t  context = DECL_CONTEXT (context);\n+\t  if (check_ktype (context, FALSE) != -1)  /* found it! */\n+\t    break;\n+\t  if (TREE_CODE_CLASS (TREE_CODE (context)) == 't')\n+\t    context = TYPE_NAME (context);\n+\t}\n+      /* now count namespace scopes */\n+      if (TREE_CODE (decl) == NAMESPACE_DECL)\n+\t{\n+\t  i = 0; /* we have nothing done, yet: reset */\n+\t  context = decl;\n+\t}\n+      else\n+\t/* decl must be a type, which we have to scope with the\n+\t   namespace */\n+\t{\n+\t  /* XXX MvL somehow, types have no lang_decl, so no namespace */\n+\t  context = current_namespace;\n+\t}    \n+    }\n \n+  while (context != global_namespace)\n+    {\n+      i += 1;\n+      context = DECL_NAMESPACE (context);\n+    }\n \n   if (i > 1)\n     {\n@@ -1515,7 +1545,10 @@ build_decl_overload_real (dname, parms, ret_type, tparms, targs,\n     }\n   else if (tparms)\n     OB_PUTC ('H');\n-  else\n+  /* XXX this works only if we call this in the same namespace\n+     as the declaration. Unfortunately, we don't have the _DECL,\n+     only its name */\n+  else if (current_namespace == global_namespace)\n     OB_PUTC ('F');\n \n   if (tparms)\n@@ -1524,6 +1557,10 @@ build_decl_overload_real (dname, parms, ret_type, tparms, targs,\n       OB_PUTC ('_');\n     }\n \n+  /* qualify with namespace */\n+  if (!for_method && current_namespace != global_namespace)\n+    build_qualified_name (current_namespace);\n+\n   if (parms == NULL_TREE)\n     OB_PUTC ('e');\n   else if (parms == void_list_node)\n@@ -1552,7 +1589,14 @@ build_decl_overload_real (dname, parms, ret_type, tparms, targs,\n \t    OB_PUTC ('e');\n \t}\n       else\n-\tbuild_mangled_name (parms, 0, 0);\n+\t{\n+\t  /* the namespace qualifier for a global function \n+\t     will count as type */\n+\t  if (current_namespace != global_namespace\n+\t      && !flag_do_squangling)\n+\t    typevec[maxtype++] = current_namespace;\n+\t  build_mangled_name (parms, 0, 0);\n+\t}\n \n       if (!flag_do_squangling)     /* Deallocate typevec array */\n         {"}, {"sha": "6783b12dbf89be0d23e53ac980201febd55114ff", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30394414d9a403e26ab3cdc36514b0468167096d/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30394414d9a403e26ab3cdc36514b0468167096d/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=30394414d9a403e26ab3cdc36514b0468167096d", "patch": "@@ -788,7 +788,7 @@ check_explicit_specialization (declarator, decl, template_count, flags)\n \t  my_friendly_assert (TREE_CODE (declarator) == IDENTIFIER_NODE, \n \t\t\t      0);\n \t  if (!ctype)\n-\t    fns = IDENTIFIER_GLOBAL_VALUE (dname);\n+\t    fns = IDENTIFIER_NAMESPACE_VALUE (dname);\n \t  else\n \t    fns = dname;\n \n@@ -1465,7 +1465,7 @@ push_template_decl (decl)\n \t}\n     }\n   /* Get the innermost set of template arguments. */\n-  args = TREE_VEC_ELT (args, TREE_VEC_LENGTH (args) - 1);\n+  args = innermost_args (args, 0);\n \n   DECL_TEMPLATE_RESULT (tmpl) = decl;\n   TREE_TYPE (tmpl) = TREE_TYPE (decl);\n@@ -2359,7 +2359,7 @@ lookup_template_class (d1, arglist, in_decl, context)\n \ttemplate = IDENTIFIER_LOCAL_VALUE (d1);\n       else\n \t{\n-\t  template = IDENTIFIER_GLOBAL_VALUE (d1); /* XXX */\n+\t  template = IDENTIFIER_NAMESPACE_VALUE (d1); /* XXX */\n \t  if (! template)\n \t    template = IDENTIFIER_CLASS_VALUE (d1);\n \t}"}, {"sha": "13f171aa0a19280861645619a502451102c9b9c2", "filename": "gcc/cp/ptree.c", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30394414d9a403e26ab3cdc36514b0468167096d/gcc%2Fcp%2Fptree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30394414d9a403e26ab3cdc36514b0468167096d/gcc%2Fcp%2Fptree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fptree.c?ref=30394414d9a403e26ab3cdc36514b0468167096d", "patch": "@@ -163,3 +163,21 @@ print_lang_identifier (file, node, indent)\n   print_node (file, \"implicit\", IDENTIFIER_IMPLICIT_DECL (node), indent + 4);\n   print_node (file, \"error locus\", IDENTIFIER_ERROR_LOCUS (node), indent + 4);\n }\n+\n+void\n+lang_print_xnode (file, node, indent)\n+     FILE *file;\n+     tree node;\n+     int indent;\n+{\n+  switch (TREE_CODE (node))\n+    {\n+    case CPLUS_BINDING:\n+      print_node (file, \"scope\", BINDING_SCOPE (node), indent+4);\n+      print_node (file, \"value\", BINDING_VALUE (node), indent+4);\n+      print_node (file, \"chain\", TREE_CHAIN (node), indent+4);\n+      break;\n+    default:\n+      break;\n+    }\n+}"}]}