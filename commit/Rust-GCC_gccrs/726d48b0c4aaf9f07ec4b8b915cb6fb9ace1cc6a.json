{"sha": "726d48b0c4aaf9f07ec4b8b915cb6fb9ace1cc6a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzI2ZDQ4YjBjNGFhZjlmMDdlYzRiOGI5MTVjYjZmYjlhY2UxY2M2YQ==", "commit": {"author": {"name": "Paolo Carlini", "email": "paolo.carlini@oracle.com", "date": "2014-08-18T22:26:03Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2014-08-18T22:26:03Z"}, "message": "parser.c (cp_parser_expression): Add default arguments.\n\n2014-08-18  Paolo Carlini  <paolo.carlini@oracle.com>\n\n\t* parser.c (cp_parser_expression): Add default arguments.\n\t(cp_parser_primary_expression, cp_parser_postfix_expression,\n\tcp_parser_array_notation, cp_parser_postfix_open_square_expression,\n\tcp_parser_unary_expression, cp_parser_direct_new_declarator,\n\tcp_parser_question_colon_clause, cp_parser_assignment_operator_opt,\n\tcp_parser_lambda_body, cp_parser_expression_statement,\n\tcp_parser_condition, cp_parser_c_for, cp_parser_range_for,\n\tcp_parser_iteration_statement, cp_parser_jump_statement,\n\tcp_parser_decltype_expr, cp_parser_noexcept_specification_opt,\n\tcp_parser_asm_operand_list, cp_parser_objc_message_receiver,\n\tcp_parser_objc_synchronized_statement, cp_parser_objc_throw_statement,\n\tcp_parser_omp_var_list_no_open, cp_parser_omp_clause_num_threads,\n\tcp_parser_omp_clause_num_teams, cp_parser_omp_clause_thread_limit,\n\tcp_parser_omp_clause_linear, cp_parser_omp_clause_device,\n\tcp_parser_omp_atomic, cp_parser_omp_for_loop_init,\n\tcp_parser_omp_for_loop, cp_parser_omp_declare_reduction_exprs,\n\tcp_parser_transaction_expression): Adjust.\n\nFrom-SVN: r214122", "tree": {"sha": "d39cf20a282027551bcf98d6f0aa2c56146f4154", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d39cf20a282027551bcf98d6f0aa2c56146f4154"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/726d48b0c4aaf9f07ec4b8b915cb6fb9ace1cc6a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/726d48b0c4aaf9f07ec4b8b915cb6fb9ace1cc6a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/726d48b0c4aaf9f07ec4b8b915cb6fb9ace1cc6a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/726d48b0c4aaf9f07ec4b8b915cb6fb9ace1cc6a/comments", "author": null, "committer": null, "parents": [{"sha": "190bea879f9e6c85aa7a8d191e09b1ef1e85ac26", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/190bea879f9e6c85aa7a8d191e09b1ef1e85ac26", "html_url": "https://github.com/Rust-GCC/gccrs/commit/190bea879f9e6c85aa7a8d191e09b1ef1e85ac26"}], "stats": {"total": 115, "additions": 62, "deletions": 53}, "files": [{"sha": "69876090ec6d13b4852cce9ee6bc9adb6afc096f", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726d48b0c4aaf9f07ec4b8b915cb6fb9ace1cc6a/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726d48b0c4aaf9f07ec4b8b915cb6fb9ace1cc6a/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=726d48b0c4aaf9f07ec4b8b915cb6fb9ace1cc6a", "patch": "@@ -1,3 +1,23 @@\n+2014-08-18  Paolo Carlini  <paolo.carlini@oracle.com>\n+\n+\t* parser.c (cp_parser_expression): Add default arguments.\n+\t(cp_parser_primary_expression, cp_parser_postfix_expression,\n+\tcp_parser_array_notation, cp_parser_postfix_open_square_expression,\n+\tcp_parser_unary_expression, cp_parser_direct_new_declarator,\n+\tcp_parser_question_colon_clause, cp_parser_assignment_operator_opt,\n+\tcp_parser_lambda_body, cp_parser_expression_statement,\n+\tcp_parser_condition, cp_parser_c_for, cp_parser_range_for,\n+\tcp_parser_iteration_statement, cp_parser_jump_statement,\n+\tcp_parser_decltype_expr, cp_parser_noexcept_specification_opt,\n+\tcp_parser_asm_operand_list, cp_parser_objc_message_receiver,\n+\tcp_parser_objc_synchronized_statement, cp_parser_objc_throw_statement,\n+\tcp_parser_omp_var_list_no_open, cp_parser_omp_clause_num_threads,\n+\tcp_parser_omp_clause_num_teams, cp_parser_omp_clause_thread_limit,\n+\tcp_parser_omp_clause_linear, cp_parser_omp_clause_device,\n+\tcp_parser_omp_atomic, cp_parser_omp_for_loop_init,\n+\tcp_parser_omp_for_loop, cp_parser_omp_declare_reduction_exprs,\n+\tcp_parser_transaction_expression): Adjust.\n+\n 2014-08-15  Jason Merrill  <jason@redhat.com>\n \n \tPR c++/61566"}, {"sha": "9053bfa62e56876ab6889e9b63368090a471499f", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 42, "deletions": 53, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/726d48b0c4aaf9f07ec4b8b915cb6fb9ace1cc6a/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/726d48b0c4aaf9f07ec4b8b915cb6fb9ace1cc6a/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=726d48b0c4aaf9f07ec4b8b915cb6fb9ace1cc6a", "patch": "@@ -1963,9 +1963,7 @@ static tree cp_parser_assignment_expression\n static enum tree_code cp_parser_assignment_operator_opt\n   (cp_parser *);\n static tree cp_parser_expression\n-  (cp_parser *, bool, cp_id_kind *);\n-static tree cp_parser_expression\n-  (cp_parser *, bool, bool, cp_id_kind *);\n+  (cp_parser *, cp_id_kind * = NULL, bool = false, bool = false);\n static tree cp_parser_constant_expression\n   (cp_parser *, bool, bool *);\n static tree cp_parser_builtin_offsetof\n@@ -4314,7 +4312,7 @@ cp_parser_primary_expression (cp_parser *parser,\n \telse\n \t  {\n \t    /* Parse the parenthesized expression.  */\n-\t    expr = cp_parser_expression (parser, cast_p, decltype_p, idk);\n+\t    expr = cp_parser_expression (parser, idk, cast_p, decltype_p);\n \t    /* Let the front end know that this expression was\n \t       enclosed in parentheses. This matters in case, for\n \t       example, the expression is of the form `A::B', since\n@@ -5736,7 +5734,7 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p, bool cast_p,\n \n \t/* And the expression which is being cast.  */\n \tcp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN);\n-\texpression = cp_parser_expression (parser, /*cast_p=*/true, & idk);\n+\texpression = cp_parser_expression (parser, & idk, /*cast_p=*/true);\n \tcp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN);\n \n \tparser->greater_than_is_operator_p\n@@ -5808,7 +5806,7 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p, bool cast_p,\n \t    tree expression;\n \n \t    /* Look for an expression.  */\n-\t    expression = cp_parser_expression (parser, /*cast_p=*/false, & idk);\n+\t    expression = cp_parser_expression (parser, & idk);\n \t    /* Compute its typeid.  */\n \t    postfix_expression = build_typeid (expression, tf_warning_or_error);\n \t    /* Look for the `)' token.  */\n@@ -6350,7 +6348,7 @@ cp_parser_array_notation (location_t loc, cp_parser *parser, tree *init_index,\n \t 2. ARRAY [ EXP : EXP ]\n \t 3. ARRAY [ EXP : EXP : EXP ]  */\n \n-      *init_index = cp_parser_expression (parser, false, NULL);\t\n+      *init_index = cp_parser_expression (parser);\t\n       if (cp_lexer_peek_token (parser->lexer)->type != CPP_COLON)\n \t{  \n \t  /* This indicates that we have a normal array expression.  */\n@@ -6360,11 +6358,11 @@ cp_parser_array_notation (location_t loc, cp_parser *parser, tree *init_index,\n       \n       /* Consume the ':'.  */\n       cp_lexer_consume_token (parser->lexer);\n-      length_index = cp_parser_expression (parser, false, NULL);\n+      length_index = cp_parser_expression (parser);\n       if (cp_lexer_peek_token (parser->lexer)->type == CPP_COLON)\n \t{\n \t  cp_lexer_consume_token (parser->lexer);\n-\t  stride = cp_parser_expression (parser, false, NULL);\n+\t  stride = cp_parser_expression (parser);\n \t}\n     }\n   parser->colon_corrects_to_scope_p = saved_colon_corrects;\n@@ -6449,7 +6447,7 @@ cp_parser_postfix_open_square_expression (cp_parser *parser,\n \t    return an_exp;\n \t}\n       else\n-\tindex = cp_parser_expression (parser, /*cast_p=*/false, NULL);\n+\tindex = cp_parser_expression (parser);\n     }\n \n   parser->greater_than_is_operator_p = saved_greater_than_is_operator_p;\n@@ -7149,7 +7147,7 @@ cp_parser_unary_expression (cp_parser *parser, bool address_p, bool cast_p,\n \n \t    ++cp_unevaluated_operand;\n \t    ++c_inhibit_evaluation_warnings;\n-\t    expr = cp_parser_expression (parser, false, NULL);\n+\t    expr = cp_parser_expression (parser);\n \t    --c_inhibit_evaluation_warnings;\n \t    --cp_unevaluated_operand;\n \n@@ -7582,7 +7580,7 @@ cp_parser_direct_new_declarator (cp_parser* parser)\n       cp_parser_require (parser, CPP_OPEN_SQUARE, RT_OPEN_SQUARE);\n \n       token = cp_lexer_peek_token (parser->lexer);\n-      expression = cp_parser_expression (parser, /*cast_p=*/false, NULL);\n+      expression = cp_parser_expression (parser);\n       /* The standard requires that the expression have integral\n \t type.  DR 74 adds enumeration types.  We believe that the\n \t real intent is that these expressions be handled like the\n@@ -8221,7 +8219,7 @@ cp_parser_question_colon_clause (cp_parser* parser, tree logical_or_expr)\n       parser->colon_corrects_to_scope_p = false;\n       /* Parse the expression.  */\n       c_inhibit_evaluation_warnings += logical_or_expr == truthvalue_false_node;\n-      expr = cp_parser_expression (parser, /*cast_p=*/false, NULL);\n+      expr = cp_parser_expression (parser);\n       c_inhibit_evaluation_warnings +=\n \t((logical_or_expr == truthvalue_true_node)\n \t - (logical_or_expr == truthvalue_false_node));\n@@ -8420,8 +8418,8 @@ cp_parser_assignment_operator_opt (cp_parser* parser)\n    Returns a representation of the expression.  */\n \n static tree\n-cp_parser_expression (cp_parser* parser, bool cast_p, bool decltype_p,\n-\t\t      cp_id_kind * pidk)\n+cp_parser_expression (cp_parser* parser, cp_id_kind * pidk,\n+\t\t      bool cast_p, bool decltype_p)\n {\n   tree expression = NULL_TREE;\n   location_t loc = UNKNOWN_LOCATION;\n@@ -8468,12 +8466,6 @@ cp_parser_expression (cp_parser* parser, bool cast_p, bool decltype_p,\n   return expression;\n }\n \n-static inline tree\n-cp_parser_expression (cp_parser* parser, bool cast_p, cp_id_kind * pidk)\n-{\n-  return cp_parser_expression (parser, cast_p, /*decltype*/false, pidk);\n-}\n-\n /* Parse a constant-expression.\n \n    constant-expression:\n@@ -9398,7 +9390,7 @@ cp_parser_lambda_body (cp_parser* parser, tree lambda_expr)\n \n \tcp_parser_require_keyword (parser, RID_RETURN, RT_RETURN);\n \n-\texpr = cp_parser_expression (parser, /*cast_p=*/false, &idk);\n+\texpr = cp_parser_expression (parser, &idk);\n \n \tcp_parser_require (parser, CPP_SEMICOLON, RT_SEMICOLON);\n \tcp_parser_require (parser, CPP_CLOSE_BRACE, RT_CLOSE_BRACE);\n@@ -9810,7 +9802,7 @@ cp_parser_expression_statement (cp_parser* parser, tree in_statement_expr)\n      statement.  */\n   if (cp_lexer_next_token_is_not (parser->lexer, CPP_SEMICOLON))\n     {\n-      statement = cp_parser_expression (parser, /*cast_p=*/false, NULL);\n+      statement = cp_parser_expression (parser);\n       if (statement == error_mark_node\n \t  && !cp_parser_uncommitted_to_tentative_parse_p (parser))\n \t{\n@@ -10211,7 +10203,7 @@ cp_parser_condition (cp_parser* parser)\n     cp_parser_abort_tentative_parse (parser);\n \n   /* Otherwise, we are looking at an expression.  */\n-  return cp_parser_expression (parser, /*cast_p=*/false, NULL);\n+  return cp_parser_expression (parser);\n }\n \n /* Parses a for-statement or range-for-statement until the closing ')',\n@@ -10263,7 +10255,7 @@ cp_parser_c_for (cp_parser *parser, tree scope, tree init, bool ivdep)\n \n   /* If there's an expression, process it.  */\n   if (cp_lexer_next_token_is_not (parser->lexer, CPP_CLOSE_PAREN))\n-    expression = cp_parser_expression (parser, /*cast_p=*/false, NULL);\n+    expression = cp_parser_expression (parser);\n   finish_for_expr (expression, stmt);\n \n   return stmt;\n@@ -10291,7 +10283,7 @@ cp_parser_range_for (cp_parser *parser, tree scope, tree init, tree range_decl,\n       range_expr = cp_parser_braced_list (parser, &expr_non_constant_p);\n     }\n   else\n-    range_expr = cp_parser_expression (parser, /*cast_p=*/false, NULL);\n+    range_expr = cp_parser_expression (parser);\n \n   /* If in template, STMT is converted to a normal for-statement\n      at instantiation. If not, it is done just ahead. */\n@@ -10679,7 +10671,7 @@ cp_parser_iteration_statement (cp_parser* parser, bool ivdep)\n \t/* Look for the `('.  */\n \tcp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN);\n \t/* Parse the expression.  */\n-\texpression = cp_parser_expression (parser, /*cast_p=*/false, NULL);\n+\texpression = cp_parser_expression (parser);\n \t/* We're done with the do-statement.  */\n \tfinish_do_stmt (expression, statement, ivdep);\n \t/* Look for the `)'.  */\n@@ -10889,7 +10881,7 @@ cp_parser_jump_statement (cp_parser* parser)\n \t    expr = cp_parser_braced_list (parser, &expr_non_constant_p);\n \t  }\n \telse if (cp_lexer_next_token_is_not (parser->lexer, CPP_SEMICOLON))\n-\t  expr = cp_parser_expression (parser, /*cast_p=*/false, NULL);\n+\t  expr = cp_parser_expression (parser);\n \telse\n \t  /* If the next token is a `;', then there is no\n \t     expression.  */\n@@ -10910,7 +10902,7 @@ cp_parser_jump_statement (cp_parser* parser)\n \t  /* Consume the '*' token.  */\n \t  cp_lexer_consume_token (parser->lexer);\n \t  /* Parse the dependent expression.  */\n-\t  finish_goto_stmt (cp_parser_expression (parser, /*cast_p=*/false, NULL));\n+\t  finish_goto_stmt (cp_parser_expression (parser));\n \t}\n       else\n \tfinish_goto_stmt (cp_parser_identifier (parser));\n@@ -12130,8 +12122,8 @@ cp_parser_decltype_expr (cp_parser *parser,\n       cp_parser_abort_tentative_parse (parser);\n \n       /* Parse a full expression.  */\n-      expr = cp_parser_expression (parser, /*cast_p=*/false,\n-\t\t\t\t   /*decltype*/true, NULL);\n+      expr = cp_parser_expression (parser, /*pidk=*/NULL, /*cast_p=*/false,\n+\t\t\t\t   /*decltype_p=*/true);\n     }\n \n   return expr;\n@@ -21215,7 +21207,7 @@ cp_parser_noexcept_specification_opt (cp_parser* parser,\n \t    }\n \t  else\n \t    {\n-\t      expr = cp_parser_expression (parser, false, NULL);\n+\t      expr = cp_parser_expression (parser);\n \t      *consumed_expr = true;\n \t    }\n \n@@ -21612,7 +21604,7 @@ cp_parser_asm_operand_list (cp_parser* parser)\n       /* Look for the `('.  */\n       cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN);\n       /* Parse the expression.  */\n-      expression = cp_parser_expression (parser, /*cast_p=*/false, NULL);\n+      expression = cp_parser_expression (parser);\n       /* Look for the `)'.  */\n       cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN);\n \n@@ -25386,7 +25378,7 @@ cp_parser_objc_message_receiver (cp_parser* parser)\n   /* An Objective-C message receiver may be either (1) a type\n      or (2) an expression.  */\n   cp_parser_parse_tentatively (parser);\n-  rcv = cp_parser_expression (parser, false, NULL);\n+  rcv = cp_parser_expression (parser);\n \n   if (cp_parser_parse_definitely (parser))\n     return rcv;\n@@ -26740,7 +26732,7 @@ cp_parser_objc_synchronized_statement (cp_parser *parser)\n   location = cp_lexer_peek_token (parser->lexer)->location;\n   objc_maybe_warn_exceptions (location);\n   cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN);\n-  lock = cp_parser_expression (parser, false, NULL);\n+  lock = cp_parser_expression (parser);\n   cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN);\n \n   /* NB: The @synchronized block needs to be wrapped in its own STATEMENT_LIST\n@@ -26767,7 +26759,7 @@ cp_parser_objc_throw_statement (cp_parser *parser)\n   cp_parser_require_keyword (parser, RID_AT_THROW, RT_AT_THROW);\n \n   if (cp_lexer_next_token_is_not (parser->lexer, CPP_SEMICOLON))\n-    expr = cp_parser_expression (parser, /*cast_p=*/false, NULL);\n+    expr = cp_parser_expression (parser);\n \n   cp_parser_consume_semicolon_at_end_of_statement (parser);\n \n@@ -27424,8 +27416,7 @@ cp_parser_omp_var_list_no_open (cp_parser *parser, enum omp_clause_code kind,\n \t\t  parser->colon_corrects_to_scope_p = false;\n \t\t  cp_lexer_consume_token (parser->lexer);\n \t\t  if (!cp_lexer_next_token_is (parser->lexer, CPP_COLON))\n-\t\t    low_bound = cp_parser_expression (parser, /*cast_p=*/false,\n-\t\t\t\t\t\t      NULL);\n+\t\t    low_bound = cp_parser_expression (parser);\n \t\t  if (!colon)\n \t\t    parser->colon_corrects_to_scope_p\n \t\t      = saved_colon_corrects_to_scope_p;\n@@ -27438,9 +27429,7 @@ cp_parser_omp_var_list_no_open (cp_parser *parser, enum omp_clause_code kind,\n \t\t\tgoto skip_comma;\n \t\t      if (!cp_lexer_next_token_is (parser->lexer,\n \t\t\t\t\t\t   CPP_CLOSE_SQUARE))\n-\t\t\tlength = cp_parser_expression (parser,\n-\t\t\t\t\t\t       /*cast_p=*/false,\n-\t\t\t\t\t\t       NULL);\n+\t\t\tlength = cp_parser_expression (parser);\n \t\t    }\n \t\t  /* Look for the closing `]'.  */\n \t\t  if (!cp_parser_require (parser, CPP_CLOSE_SQUARE,\n@@ -27708,7 +27697,7 @@ cp_parser_omp_clause_num_threads (cp_parser *parser, tree list,\n   if (!cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN))\n     return list;\n \n-  t = cp_parser_expression (parser, false, NULL);\n+  t = cp_parser_expression (parser);\n \n   if (t == error_mark_node\n       || !cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN))\n@@ -28002,7 +27991,7 @@ cp_parser_omp_clause_num_teams (cp_parser *parser, tree list,\n   if (!cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN))\n     return list;\n \n-  t = cp_parser_expression (parser, false, NULL);\n+  t = cp_parser_expression (parser);\n \n   if (t == error_mark_node\n       || !cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN))\n@@ -28032,7 +28021,7 @@ cp_parser_omp_clause_thread_limit (cp_parser *parser, tree list,\n   if (!cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN))\n     return list;\n \n-  t = cp_parser_expression (parser, false, NULL);\n+  t = cp_parser_expression (parser);\n \n   if (t == error_mark_node\n       || !cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN))\n@@ -28104,7 +28093,7 @@ cp_parser_omp_clause_linear (cp_parser *parser, tree list,\n \n   if (colon)\n     {\n-      step = cp_parser_expression (parser, false, NULL);\n+      step = cp_parser_expression (parser);\n \n       if (is_cilk_simd_fn && TREE_CODE (step) == PARM_DECL)\n \t{\n@@ -28300,7 +28289,7 @@ cp_parser_omp_clause_device (cp_parser *parser, tree list,\n   if (!cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN))\n     return list;\n \n-  t = cp_parser_expression (parser, false, NULL);\n+  t = cp_parser_expression (parser);\n \n   if (t == error_mark_node\n       || !cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN))\n@@ -28839,7 +28828,7 @@ cp_parser_omp_atomic (cp_parser *parser, cp_token *pragma_tok)\n       if (!cp_parser_require (parser, CPP_EQ, RT_EQ))\n \tgoto saw_error;\n       if (code == NOP_EXPR)\n-\tlhs = cp_parser_expression (parser, /*cast_p=*/false, NULL);\n+\tlhs = cp_parser_expression (parser);\n       else\n \tlhs = cp_parser_unary_expression (parser, /*address_p=*/false,\n \t\t\t\t\t  /*cast_p=*/false, NULL);\n@@ -29019,7 +29008,7 @@ cp_parser_omp_atomic (cp_parser *parser, cp_token *pragma_tok)\n \t      cp_parser_abort_tentative_parse (parser);\n \t      if (structured_block && code == OMP_ATOMIC_CAPTURE_OLD)\n \t\t{\n-\t\t  rhs = cp_parser_expression (parser, /*cast_p=*/false, NULL);\n+\t\t  rhs = cp_parser_expression (parser);\n \t\t  if (rhs == error_mark_node)\n \t\t    goto saw_error;\n \t\t  opcode = NOP_EXPR;\n@@ -29105,7 +29094,7 @@ cp_parser_omp_atomic (cp_parser *parser, cp_token *pragma_tok)\n \t}\n       cp_lexer_consume_token (parser->lexer);\n \n-      rhs = cp_parser_expression (parser, false, NULL);\n+      rhs = cp_parser_expression (parser);\n       if (rhs == error_mark_node)\n \tgoto saw_error;\n       break;\n@@ -29511,7 +29500,7 @@ cp_parser_omp_for_loop_init (cp_parser *parser,\n \t{\n \t  decl = NULL;\n \t  cp_parser_abort_tentative_parse (parser);\n-\t  init = cp_parser_expression (parser, false, NULL);\n+\t  init = cp_parser_expression (parser);\n \t  if (init)\n \t    {\n \t      if (TREE_CODE (init) == MODIFY_EXPR\n@@ -29685,7 +29674,7 @@ cp_parser_omp_for_loop (cp_parser *parser, enum tree_code code, tree clauses,\n \t\t  || CLASS_TYPE_P (TREE_TYPE (real_decl))))\n \t    incr = cp_parser_omp_for_incr (parser, real_decl);\n \t  else\n-\t    incr = cp_parser_expression (parser, false, NULL);\n+\t    incr = cp_parser_expression (parser);\n \t  if (CAN_HAVE_LOCATION_P (incr) && !EXPR_HAS_LOCATION (incr))\n \t    SET_EXPR_LOCATION (incr, input_location);\n \t}\n@@ -30895,7 +30884,7 @@ cp_parser_omp_declare_reduction_exprs (tree fndecl, cp_parser *parser)\n \n   keep_next_level (true);\n   tree block = begin_omp_structured_block ();\n-  combiner = cp_parser_expression (parser, false, NULL);\n+  combiner = cp_parser_expression (parser);\n   finish_expr_stmt (combiner);\n   block = finish_omp_structured_block (block);\n   add_stmt (block);\n@@ -31512,7 +31501,7 @@ cp_parser_transaction_expression (cp_parser *parser, enum rid keyword)\n     {\n       cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN);\n \n-      expr = cp_parser_expression (parser, /*cast_p=*/false, NULL);\n+      expr = cp_parser_expression (parser);\n       expr = finish_parenthesized_expr (expr);\n \n       cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN);"}]}