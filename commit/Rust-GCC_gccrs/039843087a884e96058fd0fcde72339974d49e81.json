{"sha": "039843087a884e96058fd0fcde72339974d49e81", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDM5ODQzMDg3YTg4NGU5NjA1OGZkMGZjZGU3MjMzOTk3NGQ0OWU4MQ==", "commit": {"author": {"name": "Bob Wilson", "email": "bob.wilson@acm.org", "date": "2002-01-23T21:03:53Z"}, "committer": {"name": "Bob Wilson", "email": "bwilson@gcc.gnu.org", "date": "2002-01-23T21:03:53Z"}, "message": "elf.h: New file.\n\n        * config/xtensa/elf.h: New file.\n        * config/xtensa/lib1funcs.asm: New file.\n        * config/xtensa/lib2funcs.S: New file.\n        * config/xtensa/linux.h: New file.\n        * config/xtensa/t-xtensa: New file.\n        * config/xtensa/xtensa-config.h: New file.\n        * config/xtensa/xtensa-protos.h: New file.\n        * config/xtensa/xtensa.c: New file.\n        * config/xtensa/xtensa.h: New file.\n        * config/xtensa/xtensa.md: New file.\n        * config.gcc (xtensa-*-elf*): New target.\n        (xtensa-*-linux*): New target.\n        * cse.c (canon_hash): Compare rtx pointers instead of register\n        numbers.  This is required for the Xtensa port.\n        * integrate.c (copy_insn_list): Handle case where the static\n        chain is in memory and the memory address has to be copied to\n        a register.\n        * doc/invoke.texi (Option Summary): Add Xtensa options.\n        (Xtensa Options): New node.\n        * doc/md.texi (Machine Constraints): Add Xtensa machine constraints.\n        * gcc.c-torture/compile/20001226-1.x: xfail for Xtensa.\n\nFrom-SVN: r49155", "tree": {"sha": "474190a92649d5af6ccd7a6f3ed51d377009630f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/474190a92649d5af6ccd7a6f3ed51d377009630f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/039843087a884e96058fd0fcde72339974d49e81", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/039843087a884e96058fd0fcde72339974d49e81", "html_url": "https://github.com/Rust-GCC/gccrs/commit/039843087a884e96058fd0fcde72339974d49e81", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/039843087a884e96058fd0fcde72339974d49e81/comments", "author": null, "committer": null, "parents": [{"sha": "5b1a76105bb377230a838ddeb0c94d384b33e97b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b1a76105bb377230a838ddeb0c94d384b33e97b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5b1a76105bb377230a838ddeb0c94d384b33e97b"}], "stats": {"total": 8148, "additions": 8137, "deletions": 11}, "files": [{"sha": "624aa13e1cb4509437d52b91cd9a67b2de5080de", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/039843087a884e96058fd0fcde72339974d49e81/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/039843087a884e96058fd0fcde72339974d49e81/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=039843087a884e96058fd0fcde72339974d49e81", "patch": "@@ -1,3 +1,26 @@\n+2002-01-23  Bob Wilson  <bob.wilson@acm.org>\n+\n+\t* config/xtensa/elf.h: New file.\n+\t* config/xtensa/lib1funcs.asm: New file.\n+\t* config/xtensa/lib2funcs.S: New file.\n+\t* config/xtensa/linux.h: New file.\n+\t* config/xtensa/t-xtensa: New file.\n+\t* config/xtensa/xtensa-config.h: New file.\n+\t* config/xtensa/xtensa-protos.h: New file.\n+\t* config/xtensa/xtensa.c: New file.\n+\t* config/xtensa/xtensa.h: New file.\n+\t* config/xtensa/xtensa.md: New file.\n+\t* config.gcc (xtensa-*-elf*): New target.\n+\t(xtensa-*-linux*): New target.\n+\t* cse.c (canon_hash): Compare rtx pointers instead of register\n+\tnumbers.  This is required for the Xtensa port.\n+\t* integrate.c (copy_insn_list): Handle case where the static\n+\tchain is in memory and the memory address has to be copied to\n+\ta register.\n+\t* doc/invoke.texi (Option Summary): Add Xtensa options.\n+\t(Xtensa Options): New node.\n+\t* doc/md.texi (Machine Constraints): Add Xtensa machine constraints.\n+\n 2002-01-23  Zack Weinberg  <zack@codesourcery.com>\n \n \t* diagnostic.c (internal_error): Do ICE suppression only"}, {"sha": "ad60a20a6a39c2e0688a05e6c54d1d0be4fa66cd", "filename": "gcc/config.gcc", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/039843087a884e96058fd0fcde72339974d49e81/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/039843087a884e96058fd0fcde72339974d49e81/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=039843087a884e96058fd0fcde72339974d49e81", "patch": "@@ -3260,6 +3260,22 @@ xstormy16-*-elf)\n \ttmake_file=\"stormy16/t-stormy16\"\n \textra_parts=\"crtbegin.o crtend.o\"\n \t;;\n+xtensa-*-elf*)\n+\ttm_file=\"${tm_file} dbxelf.h elfos.h svr4.h xtensa/elf.h\"\n+\twith_newlib=yes\n+\ttmake_file=xtensa/t-xtensa\n+\textra_parts=\"crtbegin.o crtend.o\"\n+\tfixincludes=Makefile.in # newlib headers should be OK\n+\t;;\n+xtensa-*-linux*)\n+\ttm_file=\"${tm_file} dbxelf.h elfos.h svr4.h linux.h xtensa/linux.h\"\n+\ttmake_file=\"t-linux xtensa/t-xtensa\"\n+\textra_parts=\"crtbegin.o crtbeginS.o crtbeginT.o crtend.o crtendS.o\"\n+\tgas=yes gnu_ld=yes\n+\tif test x$enable_threads = xyes; then\n+\t\tthread_file='posix'\n+\tfi\n+\t;;\n *)\n \techo \"Configuration $machine not supported\" 1>&2\n \texit 1"}, {"sha": "dea1e5f84141f79cb07c9005c0a0460a67690af1", "filename": "gcc/config/xtensa/elf.h", "status": "added", "additions": 138, "deletions": 0, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/039843087a884e96058fd0fcde72339974d49e81/gcc%2Fconfig%2Fxtensa%2Felf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/039843087a884e96058fd0fcde72339974d49e81/gcc%2Fconfig%2Fxtensa%2Felf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Felf.h?ref=039843087a884e96058fd0fcde72339974d49e81", "patch": "@@ -0,0 +1,138 @@\n+/* Xtensa/Elf configuration.\n+   Derived from the configuration for GCC for Intel i386 running Linux.\n+   Copyright (C) 2001 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n+02111-1307, USA.  */\n+\n+/* Don't assume anything about the header files. */\n+#define NO_IMPLICIT_EXTERN_C\n+\n+#undef ASM_APP_ON\n+#define ASM_APP_ON \"#APP\\n\"\n+\n+#undef ASM_APP_OFF\n+#define ASM_APP_OFF \"#NO_APP\\n\"\n+\n+#undef MD_EXEC_PREFIX\n+#undef MD_STARTFILE_PREFIX\n+\n+#undef TARGET_VERSION\n+#define TARGET_VERSION fputs (\" (Xtensa/ELF)\", stderr);\n+\n+#undef SIZE_TYPE\n+#define SIZE_TYPE \"unsigned int\"\n+\n+#undef PTRDIFF_TYPE\n+#define PTRDIFF_TYPE \"int\"\n+\n+#undef WCHAR_TYPE\n+#define WCHAR_TYPE \"int\"\n+\n+#undef WCHAR_TYPE_SIZE\n+#define WCHAR_TYPE_SIZE BITS_PER_WORD\n+\n+#undef ASM_SPEC\n+#define ASM_SPEC \"%{v} %{mno-density:--no-density} \\\n+                  %{mtext-section-literals:--text-section-literals} \\\n+                  %{mno-text-section-literals:--no-text-section-literals} \\\n+\t\t  %{mtarget-align:--target-align} \\\n+\t\t  %{mno-target-align:--no-target-align} \\\n+\t\t  %{mlongcalls:--longcalls} \\\n+\t\t  %{mno-longcalls:--no-longcalls}\"\n+\n+#undef ASM_FINAL_SPEC\n+\n+#undef LIB_SPEC\n+#define LIB_SPEC \"-lc -lsim -lc -lhandlers-sim\"\n+\n+#undef STARTFILE_SPEC\n+#define STARTFILE_SPEC \"crt1-sim%O%s crti%O%s crtbegin%O%s _vectors%O%s\"\n+\n+#undef ENDFILE_SPEC\n+#define ENDFILE_SPEC \"crtend%O%s crtn%O%s\"  \n+\n+#undef LINK_SPEC\n+#define LINK_SPEC \\\n+ \"%{shared:-shared} \\\n+  %{!shared: \\\n+    %{!static: \\\n+      %{rdynamic:-export-dynamic} \\\n+    %{static:-static}}}\"\n+\n+#undef CPP_PREDEFINES\n+#define CPP_PREDEFINES \"-D__XTENSA__ -D__ELF__ -Acpu=xtensa -Amachine=xtensa\"\n+\n+/* Local compiler-generated symbols must have a prefix that the assembler\n+   understands.   By default, this is $, although some targets (e.g.,\n+   NetBSD-ELF) need to override this. */\n+\n+#ifndef LOCAL_LABEL_PREFIX\n+#define LOCAL_LABEL_PREFIX\t\".\"\n+#endif\n+\n+/* By default, external symbols do not have an underscore prepended. */\n+\n+#ifndef USER_LABEL_PREFIX\n+#define USER_LABEL_PREFIX\t\"\"\n+#endif\n+\n+/* Define this macro if the assembler does not accept the character\n+   \".\" in label names.  By default constructors and destructors in G++\n+   have names that use \".\".  If this macro is defined, these names\n+   are rewritten to avoid \".\". */\n+#define NO_DOT_IN_LABEL\n+\n+/* Define NO_DOLLAR_IN_LABEL in your favorite tm file if your assembler\n+   doesn't allow $ in symbol names.  */\n+#undef NO_DOLLAR_IN_LABEL\n+\n+/* Don't switch sections in the middle of a literal pool! */\n+#undef SELECT_RTX_SECTION\n+#define SELECT_RTX_SECTION(MODE,RTX,ALIGN)\n+  \n+/* Do not force \"-fpic\" for this target.  */\n+#define XTENSA_ALWAYS_PIC 0\n+\n+/* Redefine the standard ELF version of ASM_DECLARE_FUNCTION_SIZE to\n+   allow adding the \".end literal_prefix\" directive at the end of the\n+   function.  */\n+#undef ASM_DECLARE_FUNCTION_SIZE\n+#define ASM_DECLARE_FUNCTION_SIZE(FILE, FNAME, DECL)\t\t\\\n+  do\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      if (!flag_inhibit_size_directive)\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\\\n+\t  char label[256];\t\t\t\t\t\\\n+\t  static int labelno;\t\t\t\t\t\\\n+\t  \t\t\t\t\t\t\t\\\n+\t  labelno++;\t\t\t\t\t\t\\\n+\t  \t\t\t\t\t\t\t\\\n+\t  ASM_GENERATE_INTERNAL_LABEL (label, \"Lfe\", labelno);\t\\\n+\t  ASM_OUTPUT_INTERNAL_LABEL (FILE, \"Lfe\", labelno);\t\\\n+\t  \t\t\t\t\t\t\t\\\n+\t  fprintf (FILE, \"%s\", SIZE_ASM_OP);\t\t\t\\\n+\t  assemble_name (FILE, (FNAME));\t\t\t\\\n+\t  fprintf (FILE, \",\");\t\t\t\t\t\\\n+\t  assemble_name (FILE, label);\t\t\t\t\\\n+\t  fprintf (FILE, \"-\");\t\t\t\t\t\\\n+\t  assemble_name (FILE, (FNAME));\t\t\t\\\n+\t  putc ('\\n', FILE);\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\\\n+      XTENSA_DECLARE_FUNCTION_SIZE(FILE, FNAME, DECL);\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  while (0)"}, {"sha": "acfb35769bf4dd1abdfe6d97cec04f9726d4f222", "filename": "gcc/config/xtensa/lib1funcs.asm", "status": "added", "additions": 419, "deletions": 0, "changes": 419, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/039843087a884e96058fd0fcde72339974d49e81/gcc%2Fconfig%2Fxtensa%2Flib1funcs.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/039843087a884e96058fd0fcde72339974d49e81/gcc%2Fconfig%2Fxtensa%2Flib1funcs.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Flib1funcs.asm?ref=039843087a884e96058fd0fcde72339974d49e81", "patch": "@@ -0,0 +1,419 @@\n+/* Assembly functions for the Xtensa version of libgcc1.\n+   Copyright (C) 2001 Free Software Foundation, Inc.\n+   Contributed by Bob Wilson (bwilson@tensilica.com) at Tensilica.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n+02111-1307, USA.  */\n+\n+#include \"xtensa/xtensa-config.h\"\n+\n+#ifdef L_mulsi3\n+\t.align\t4\n+\t.global\t__mulsi3\n+\t.type\t__mulsi3,@function\n+__mulsi3:\n+\tentry\tsp, 16\n+\n+#if XCHAL_HAVE_MUL16\n+\tor\ta4, a2, a3\n+\tsrai\ta4, a4, 16\n+\tbnez\ta4, .LMUL16\n+\tmul16u\ta2, a2, a3\n+\tretw\n+.LMUL16:\n+\tsrai\ta4, a2, 16\n+\tsrai\ta5, a3, 16\n+\tmul16u\ta7, a4, a3\n+\tmul16u\ta6, a5, a2\n+\tmul16u\ta4, a2, a3\n+\tadd\ta7, a7, a6\n+\tslli\ta7, a7, 16\n+\tadd\ta2, a7, a4\n+\n+#elif XCHAL_HAVE_MAC16\n+\tmul.aa.hl a2, a3\n+\tmula.aa.lh a2, a3\n+\trsr\ta5, 16 # ACCLO\n+\tumul.aa.ll a2, a3\n+\trsr\ta4, 16 # ACCLO\n+\tslli\ta5, a5, 16\n+\tadd\ta2, a4, a5\n+\n+#else /* !XCHAL_HAVE_MUL16 && !XCHAL_HAVE_MAC16 */\n+\n+        # Multiply one bit at a time, but unroll the loop 4x to better\n+        # exploit the addx instructions.\n+        \n+        # Peel the first iteration to save a cycle on init\n+\n+        # avoid negative numbers \n+\n+\txor\ta5, a2, a3  # top bit is 1 iff one of the inputs is negative\n+\tabs     a3, a3\n+\tabs     a2, a2\n+\n+        # swap so that second argument is smaller\n+        sub     a7, a2, a3\n+        mov     a4, a3\n+        movgez  a4, a2, a7  # a4 = max(a2, a3) \n+        movltz  a3, a2, a7  # a3 = min(a2, a3)\n+\n+        movi    a2, 0\n+        extui   a6, a3, 0, 1\n+        movnez  a2, a4, a6\n+\n+        addx2   a7, a4, a2\n+        extui   a6, a3, 1, 1\n+        movnez  a2, a7, a6\n+\n+        addx4   a7, a4, a2\n+        extui   a6, a3, 2, 1\n+        movnez  a2, a7, a6\n+\n+        addx8   a7, a4, a2\n+        extui   a6, a3, 3, 1\n+        movnez  a2, a7, a6\n+\n+        bgeui   a3, 16, .Lmult_main_loop\n+        neg     a3, a2\n+        movltz  a2, a3, a5\n+        retw\n+\n+\n+        .align  4\n+.Lmult_main_loop:\n+        srli    a3, a3, 4\n+        slli    a4, a4, 4\n+\n+        add     a7, a4, a2\n+        extui   a6, a3, 0, 1\n+        movnez  a2, a7, a6\n+\n+        addx2   a7, a4, a2\n+        extui   a6, a3, 1, 1\n+        movnez  a2, a7, a6\n+\n+        addx4   a7, a4, a2\n+        extui   a6, a3, 2, 1\n+        movnez  a2, a7, a6\n+\n+        addx8   a7, a4, a2\n+        extui   a6, a3, 3, 1\n+        movnez  a2, a7, a6\n+\n+\n+        bgeui   a3, 16, .Lmult_main_loop\n+\n+        neg     a3, a2\n+        movltz  a2, a3, a5\n+\n+#endif /* !XCHAL_HAVE_MUL16 && !XCHAL_HAVE_MAC16 */\n+\n+\tretw\n+.Lfe0:\n+\t.size\t__mulsi3,.Lfe0-__mulsi3\n+\n+#endif /* L_mulsi3 */\n+\n+\n+\t# Some Xtensa configurations include the NSAU (unsigned\n+\t# normalize shift amount) instruction which computes the number\n+\t# of leading zero bits.  For other configurations, the \"nsau\"\n+\t# operation is implemented as a macro.\n+\t\n+#if !XCHAL_HAVE_NSA\n+\t.macro\tnsau cnt, val, tmp, a\n+\tmov\t\\a, \\val\n+\tmovi\t\\cnt, 0\n+\textui\t\\tmp, \\a, 16, 16\n+\tbnez\t\\tmp, 0f\n+\tmovi\t\\cnt, 16\n+\tslli\t\\a, \\a, 16\n+0:\t\n+\textui\t\\tmp, \\a, 24, 8\n+\tbnez\t\\tmp, 1f\n+\taddi\t\\cnt, \\cnt, 8\n+\tslli\t\\a, \\a, 8\n+1:\t\n+\tmovi\t\\tmp, __nsau_data\n+\textui\t\\a, \\a, 24, 8\n+\tadd\t\\tmp, \\tmp, \\a\n+\tl8ui\t\\tmp, \\tmp, 0\n+\tadd\t\\cnt, \\cnt, \\tmp\n+\t.endm\n+#endif /* !XCHAL_HAVE_NSA */\n+\n+#ifdef L_nsau\n+\t.section .rodata\n+\t.align\t4\n+\t.global\t__nsau_data\n+\t.type\t__nsau_data,@object\n+__nsau_data:\t\n+#if !XCHAL_HAVE_NSA\n+\t.byte\t8, 7, 6, 6, 5, 5, 5, 5, 4, 4, 4, 4, 4, 4, 4, 4\n+\t.byte\t3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3\n+\t.byte\t2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2\n+\t.byte\t2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2\n+\t.byte\t1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1\n+\t.byte\t1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1\n+\t.byte\t1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1\n+\t.byte\t1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1\n+\t.byte\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0\n+\t.byte\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0\n+\t.byte\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0\n+\t.byte\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0\n+\t.byte\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0\n+\t.byte\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0\n+\t.byte\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0\n+\t.byte\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0\n+#endif /* !XCHAL_HAVE_NSA */\n+.Lfe1:\n+\t.size\t__nsau_data,.Lfe1-__nsau_data\n+\t.hidden\t__nsau_data\n+#endif /* L_nsau */\n+\n+\n+#ifdef L_udivsi3\n+\t.align\t4\n+\t.global\t__udivsi3\n+\t.type\t__udivsi3,@function\n+__udivsi3:\n+\tentry\tsp, 16\n+\tbltui\ta3, 2, .Lle_one\t# check if the divisor <= 1\n+\n+\tmov\ta6, a2\t\t# keep dividend in a6\n+#if XCHAL_HAVE_NSA\n+\tnsau\ta5, a6\t\t# dividend_shift = nsau(dividend)\n+\tnsau\ta4, a3\t\t# divisor_shift = nsau(divisor)\n+#else /* !XCHAL_HAVE_NSA */\n+\tnsau\ta5, a6, a2, a7\t# dividend_shift = nsau(dividend)\n+\tnsau\ta4, a3, a2, a7\t# divisor_shift = nsau(divisor)\n+#endif /* !XCHAL_HAVE_NSA */\n+\tbgeu\ta5, a4, .Lspecial\n+\n+\tsub\ta4, a4, a5\t# count = divisor_shift - dividend_shift\n+\tssl\ta4\n+\tsll\ta3, a3\t\t# divisor <<= count\n+\tmovi\ta2, 0\t\t# quotient = 0\n+\n+\t# test-subtract-and-shift loop; one quotient bit on each iteration\n+\tloopnez\ta4, .Lloopend\n+\tbltu\ta6, a3, .Lzerobit\n+\tsub\ta6, a6, a3\n+\taddi\ta2, a2, 1\n+.Lzerobit:\n+\tslli\ta2, a2, 1\n+\tsrli\ta3, a3, 1\n+.Lloopend:\n+\n+\tbltu\ta6, a3, .Lreturn\n+\taddi\ta2, a2, 1\t# increment quotient if dividend >= divisor\n+.Lreturn:\n+\tretw\n+\n+.Lspecial:\n+\t# return dividend >= divisor\n+\tmovi\ta2, 0\n+\tbltu\ta6, a3, .Lreturn2\n+\tmovi\ta2, 1\n+.Lreturn2:\n+\tretw\n+\n+.Lle_one:\n+\tbeqz\ta3, .Lerror\t# if divisor == 1, return the dividend\n+\tretw\n+.Lerror:\n+\tmovi\ta2, 0\t\t# just return 0; could throw an exception\n+\tretw\n+.Lfe2:\n+\t.size\t__udivsi3,.Lfe2-__udivsi3\n+\n+#endif /* L_udivsi3 */\n+\n+\n+#ifdef L_divsi3\n+\t.align\t4\n+\t.global\t__divsi3\n+\t.type\t__divsi3,@function\n+__divsi3:\n+\tentry\tsp, 16\n+\txor\ta7, a2, a3\t# sign = dividend ^ divisor\n+\tabs\ta6, a2\t\t# udividend = abs(dividend)\n+\tabs\ta3, a3\t\t# udivisor = abs(divisor)\n+\tbltui\ta3, 2, .Lle_one\t# check if udivisor <= 1\n+#if XCHAL_HAVE_NSA\n+\tnsau\ta5, a6\t\t# udividend_shift = nsau(udividend)\n+\tnsau\ta4, a3\t\t# udivisor_shift = nsau(udivisor)\n+#else /* !XCHAL_HAVE_NSA */\n+\tnsau\ta5, a6, a2, a8\t# udividend_shift = nsau(udividend)\n+\tnsau\ta4, a3, a2, a8\t# udivisor_shift = nsau(udivisor)\n+#endif /* !XCHAL_HAVE_NSA */\n+\tbgeu\ta5, a4, .Lspecial\n+\n+\tsub\ta4, a4, a5\t# count = udivisor_shift - udividend_shift\n+\tssl\ta4\n+\tsll\ta3, a3\t\t# udivisor <<= count\n+\tmovi\ta2, 0\t\t# quotient = 0\n+\n+\t# test-subtract-and-shift loop; one quotient bit on each iteration\n+\tloopnez\ta4, .Lloopend\n+\tbltu\ta6, a3, .Lzerobit\n+\tsub\ta6, a6, a3\n+\taddi\ta2, a2, 1\n+.Lzerobit:\n+\tslli\ta2, a2, 1\n+\tsrli\ta3, a3, 1\n+.Lloopend:\n+\n+\tbltu\ta6, a3, .Lreturn\n+\taddi\ta2, a2, 1\t# increment quotient if udividend >= udivisor\n+.Lreturn:\n+\tneg\ta5, a2\n+\tmovltz\ta2, a5, a7\t# return (sign < 0) ? -quotient : quotient\n+\tretw\n+\n+.Lspecial:\n+\tmovi\ta2, 0\n+\tbltu\ta6, a3, .Lreturn2 #  if dividend < divisor, return 0\n+\tmovi\ta2, 1\n+\tmovi\ta4, -1\n+\tmovltz\ta2, a4, a7\t# else return (sign < 0) ? -1 :\t 1 \n+.Lreturn2:\n+\tretw\n+\n+.Lle_one:\n+\tbeqz\ta3, .Lerror\n+\tneg\ta2, a6\t\t# if udivisor == 1, then return...\n+\tmovgez\ta2, a6, a7\t# (sign < 0) ? -udividend : udividend\n+\tretw\n+.Lerror:\n+\tmovi\ta2, 0\t\t# just return 0; could throw an exception\n+\tretw\n+.Lfe3:\n+\t.size\t__divsi3,.Lfe3-__divsi3\n+\n+#endif /* L_divsi3 */\n+\n+\n+#ifdef L_umodsi3\n+\t.align\t4\n+\t.global\t__umodsi3\n+\t.type\t__umodsi3,@function\n+__umodsi3:\n+\tentry\tsp, 16\n+\tbltui\ta3, 2, .Lle_one\t# check if the divisor is <= 1\n+\n+#if XCHAL_HAVE_NSA\n+\tnsau\ta5, a2\t\t# dividend_shift = nsau(dividend)\n+\tnsau\ta4, a3\t\t# divisor_shift = nsau(divisor)\n+#else /* !XCHAL_HAVE_NSA */\n+\tnsau\ta5, a2, a6, a7\t# dividend_shift = nsau(dividend)\n+\tnsau\ta4, a3, a6, a7\t# divisor_shift = nsau(divisor)\n+#endif /* !XCHAL_HAVE_NSA */\n+\tbgeu\ta5, a4, .Lspecial\n+\n+\tsub\ta4, a4, a5\t# count = divisor_shift - dividend_shift\n+\tssl\ta4\n+\tsll\ta3, a3\t\t# divisor <<= count\n+\n+\t# test-subtract-and-shift loop\n+\tloopnez\ta4, .Lloopend\n+\tbltu\ta2, a3, .Lzerobit\n+\tsub\ta2, a2, a3\n+.Lzerobit:\n+\tsrli\ta3, a3, 1\n+.Lloopend:\n+\n+\tbltu\ta2, a3, .Lreturn\n+\tsub\ta2, a2, a3\t# subtract once more if dividend >= divisor\n+.Lreturn:\n+\tretw\n+\n+.Lspecial:\n+\tbltu\ta2, a3, .Lreturn2\n+\tsub\ta2, a2, a3\t# subtract once if dividend >= divisor\n+.Lreturn2:\n+\tretw\n+\n+.Lle_one:\n+\t# the divisor is either 0 or 1, so just return 0.\n+\t# someday we may want to throw an exception if the divisor is 0.\n+\tmovi\ta2, 0\n+\tretw\n+.Lfe4:\n+\t.size\t__umodsi3,.Lfe4-__umodsi3\n+\n+#endif /* L_umodsi3 */\n+\n+\n+#ifdef L_modsi3\n+\t.align\t4\n+\t.global\t__modsi3\n+\t.type\t__modsi3,@function\n+__modsi3:\n+\tentry\tsp, 16\n+\tmov\ta7, a2\t\t# save original (signed) dividend\n+\tabs\ta2, a2\t\t# udividend = abs(dividend)\n+\tabs\ta3, a3\t\t# udivisor = abs(divisor)\n+\tbltui\ta3, 2, .Lle_one\t# check if udivisor <= 1\n+#if XCHAL_HAVE_NSA\n+\tnsau\ta5, a2\t\t# udividend_shift = nsau(udividend)\n+\tnsau\ta4, a3\t\t# udivisor_shift = nsau(udivisor)\n+#else /* !XCHAL_HAVE_NSA */\n+\tnsau\ta5, a2, a6, a8\t# udividend_shift = nsau(udividend)\n+\tnsau\ta4, a3, a6, a8\t# udivisor_shift = nsau(udivisor)\n+#endif /* !XCHAL_HAVE_NSA */\n+\tbgeu\ta5, a4, .Lspecial\n+\n+\tsub\ta4, a4, a5\t# count = udivisor_shift - udividend_shift\n+\tssl\ta4\n+\tsll\ta3, a3\t\t# udivisor <<= count\n+\n+\t# test-subtract-and-shift loop\n+\tloopnez\ta4, .Lloopend\n+\tbltu\ta2, a3, .Lzerobit\n+\tsub\ta2, a2, a3\n+.Lzerobit:\n+\tsrli\ta3, a3, 1\n+.Lloopend:\n+\n+\tbltu\ta2, a3, .Lreturn\n+\tsub\ta2, a2, a3\t# subtract once more if udividend >= udivisor\n+.Lreturn:\n+\tbgez\ta7, .Lpositive\n+\tneg\ta2, a2\t\t# if (dividend < 0), return -udividend\n+.Lpositive:\t\n+\tretw\n+\n+.Lspecial:\n+\tbltu\ta2, a3, .Lreturn2\n+\tsub\ta2, a2, a3\t# subtract once if dividend >= divisor\n+.Lreturn2:\n+\tbgez\ta7, .Lpositive2\n+\tneg\ta2, a2\t\t# if (dividend < 0), return -udividend\n+.Lpositive2:\t\n+\tretw\n+\n+.Lle_one:\n+\t# udivisor is either 0 or 1, so just return 0.\n+\t# someday we may want to throw an exception if udivisor is 0.\n+\tmovi\ta2, 0\n+\tretw\n+.Lfe5:\n+\t.size\t__modsi3,.Lfe5-__modsi3\n+\n+#endif /* L_modsi3 */"}, {"sha": "82679e65733f8bf3be6ab59bbe7301d69879dd28", "filename": "gcc/config/xtensa/lib2funcs.S", "status": "added", "additions": 205, "deletions": 0, "changes": 205, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/039843087a884e96058fd0fcde72339974d49e81/gcc%2Fconfig%2Fxtensa%2Flib2funcs.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/039843087a884e96058fd0fcde72339974d49e81/gcc%2Fconfig%2Fxtensa%2Flib2funcs.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Flib2funcs.S?ref=039843087a884e96058fd0fcde72339974d49e81", "patch": "@@ -0,0 +1,205 @@\n+/* Assembly functions for libgcc2.\n+   Copyright (C) 2001 Free Software Foundation, Inc.\n+   Contributed by Bob Wilson (bwilson@tensilica.com) at Tensilica.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n+02111-1307, USA.  */\n+\n+#include \"xtensa/xtensa-config.h\"\n+\n+/* __xtensa_libgcc_window_spill: This function uses a series of nested\n+   calls to flush out all but the current register window.  This is\n+   used to set up the stack so that arbitrary frames can be accessed.\n+   The functions used for the nested calls are also reused by the\n+   nonlocal goto function below. */\n+\n+        .align  4\n+        .global __xtensa_libgcc_window_spill\n+        .type   __xtensa_libgcc_window_spill,@function\n+__xtensa_libgcc_window_spill:\n+\tentry\tsp, 48\n+\tcall4\t.L__wdwspill_assist52\t// called with call8, only need a call4\n+\tretw\n+        .size   __xtensa_libgcc_window_spill,.-__xtensa_libgcc_window_spill\n+\n+        .align  4\n+.L__wdwspill_assist56:\n+\tentry\tsp, 16\n+\tcall4\t.L__wdwspill_assist52\n+\tretw\n+        .align  4\n+.L__wdwspill_assist52:\n+\tentry\tsp, 48\n+\tcall12\t.L__wdwspill_assist40\n+\tretw\n+        .align  4\n+.L__wdwspill_assist40:\n+\tentry\tsp, 48\n+\tcall12\t.L__wdwspill_assist28\n+\tretw\n+        .align  4\n+.L__wdwspill_assist28:\n+\tentry\tsp, 48\n+\tcall12\t.L__wdwspill_assist16\n+\tretw\n+        .align  4\n+.L__wdwspill_assist16:\n+\tentry\tsp, 16\n+\tmovi\ta15, 0\n+\tretw\n+\n+\n+/* __xtensa_nonlocal_goto: This code does all the hard work of a\n+   nonlocal goto on Xtensa.  It is here in the library to avoid the\n+   code size bloat of generating it in-line.  There are two\n+   arguments:\n+\n+\ta2 = frame pointer for the procedure containing the label\n+\ta3 = goto handler address\n+\n+  This function never returns to its caller but instead goes directly\n+  to the address of the specified goto handler.  */\n+\n+\t.align\t4\n+\t.global\t__xtensa_nonlocal_goto\n+\t.type\t__xtensa_nonlocal_goto,@function\n+__xtensa_nonlocal_goto:\n+\tentry\tsp, 32\n+\n+\t/* flush registers */\n+\tcall8\t.L__wdwspill_assist56\n+\n+\t/* Because the save area for a0-a3 is stored one frame below\n+\t   the one identified by a2, the only way to restore those\n+\t   registers is to unwind the stack.  If alloca() were never\n+\t   called, we could just unwind until finding the sp value\n+\t   matching a2.  However, a2 is a frame pointer, not a stack\n+\t   pointer, and may not be encountered during the unwinding.\n+\t   The solution is to unwind until going _past_ the value\n+\t   given by a2.  This involves keeping three stack pointer\n+\t   values during the unwinding:\n+\n+\t\tnext = sp of frame N-1\n+\t\tcur = sp of frame N\n+\t\tprev = sp of frame N+1\n+\n+\t   When next > a2, the desired save area is stored relative\n+\t   to prev.  At this point, cur will be the same as a2\n+\t   except in the alloca() case.\n+\n+\t   Besides finding the values to be restored to a0-a3, we also\n+\t   need to find the current window size for the target\n+\t   function.  This can be extracted from the high bits of the\n+\t   return address, initially in a0.  As the unwinding\n+\t   proceeds, the window size is taken from the value of a0\n+\t   saved _two_ frames below the current frame. */\n+\n+\taddi\ta5, sp, -16\t\t# a5 = prev - save area\n+\tl32i\ta6, a5, 4\n+\taddi\ta6, a6, -16\t\t# a6 = cur - save area\n+\tmov\ta8, a0\t\t\t# a8 = return address (for window size)\n+\tj\t.Lfirstframe\n+\n+.Lnextframe:\t\n+\tl32i\ta8, a5, 0\t\t# next return address (for window size)\n+\tmov\ta5, a6\t\t\t# advance prev\n+\taddi\ta6, a7, -16\t\t# advance cur\n+.Lfirstframe:\t\n+\tl32i\ta7, a6, 4\t\t# a7 = next\n+\tbge\ta2, a7, .Lnextframe\n+\n+\t/* At this point, prev (a5) points to the save area with the saved\n+\t   values of a0-a3.  Copy those values into the save area at the\n+\t   current sp so they will be reloaded when the return from this\n+\t   function underflows.  We don't have to worry about exceptions\n+\t   while updating the current save area, because the windows have\n+\t   already been flushed. */\n+\n+\taddi\ta4, sp, -16\t\t# a4 = save area of this function\n+\tl32i\ta6, a5, 0\n+\tl32i\ta7, a5, 4\n+\ts32i\ta6, a4, 0\n+\ts32i\ta7, a4, 4\n+\tl32i\ta6, a5, 8\n+\tl32i\ta7, a5, 12 \n+\ts32i\ta6, a4, 8\n+\ts32i\ta7, a4, 12\n+\t\n+\t/* Set return address to goto handler.  Use the window size bits\n+\t   from the return address two frames below the target. */\n+\textui\ta8, a8, 30, 2\t\t# get window size from return addr.\n+\tslli\ta3, a3, 2\t\t# get goto handler addr. << 2\n+\tssai\t2\n+\tsrc\ta0, a8, a3\t\t# combine them with a funnel shift\n+\n+\tretw\n+\t.size\t__xtensa_nonlocal_goto,.-__xtensa_nonlocal_goto\n+\n+\n+/* __xtensa_sync_caches: This function is called after writing a trampoline\n+   on the stack to force all the data writes to memory and invalidate the\n+   instruction cache. a2 is the address of the new trampoline.\n+\n+   After the trampoline data is written out, it must be flushed out of\n+   the data cache into memory.  We use DHWB in case we have a writeback\n+   cache.  At least one DHWB instruction is needed for each data cache\n+   line which may be touched by the trampoline.  An ISYNC instruction\n+   must follow the DHWBs.\n+\n+   We have to flush the i-cache to make sure that the new values get used.\n+   At least one IHI instruction is needed for each i-cache line which may\n+   be touched by the trampoline.  An ISYNC instruction is also needed to\n+   make sure that the modified instructions are loaded into the instruction\n+   fetch buffer. */\n+\t\n+#define TRAMPOLINE_SIZE 49\n+\n+\t.text\n+\t.align\t4\n+\t.global\t__xtensa_sync_caches\n+\t.type\t__xtensa_sync_caches,@function\n+__xtensa_sync_caches:\n+\tentry \tsp, 32\n+#if XCHAL_DCACHE_SIZE > 0 && XCHAL_DCACHE_IS_WRITEBACK\n+\t# Flush the trampoline from the data cache\n+\textui\ta4, a2, 0, XCHAL_DCACHE_LINEWIDTH\n+\taddi\ta4, a4, TRAMPOLINE_SIZE\n+\taddi\ta4, a4, (1 << XCHAL_DCACHE_LINEWIDTH) - 1\n+\tsrli\ta4, a4, XCHAL_DCACHE_LINEWIDTH\n+\tmov\ta3, a2\n+.Ldcache_loop:\n+\tdhwb\ta3, 0\n+\taddi\ta3, a3, (1 << XCHAL_DCACHE_LINEWIDTH)\n+\taddi\ta4, a4, -1\n+\tbnez\ta4, .Ldcache_loop\n+\tisync\n+#endif \n+#if XCHAL_ICACHE_SIZE > 0\n+\t# Invalidate the corresponding lines in the instruction cache\n+\textui\ta4, a2, 0, XCHAL_ICACHE_LINEWIDTH\n+\taddi\ta4, a4, TRAMPOLINE_SIZE\n+\taddi\ta4, a4, (1 << XCHAL_ICACHE_LINEWIDTH) - 1\n+\tsrli\ta4, a4, XCHAL_ICACHE_LINEWIDTH\n+.Licache_loop:\n+\tihi\ta2, 0\n+\taddi\ta2, a2, (1 << XCHAL_ICACHE_LINEWIDTH)\n+\taddi\ta4, a4, -1\n+\tbnez\ta4, .Licache_loop\n+\tisync\n+#endif\n+\tretw\n+\t.size\t__xtensa_sync_caches,.-__xtensa_sync_caches"}, {"sha": "04c6b7f3d6dba2a700a58f0d41ee0d5b0e1b8e54", "filename": "gcc/config/xtensa/linux.h", "status": "added", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/039843087a884e96058fd0fcde72339974d49e81/gcc%2Fconfig%2Fxtensa%2Flinux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/039843087a884e96058fd0fcde72339974d49e81/gcc%2Fconfig%2Fxtensa%2Flinux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Flinux.h?ref=039843087a884e96058fd0fcde72339974d49e81", "patch": "@@ -0,0 +1,94 @@\n+/* Xtensa Linux configuration.\n+   Derived from the configuration for GCC for Intel i386 running Linux.\n+   Copyright (C) 2001 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n+02111-1307, USA.  */\n+\n+#undef TARGET_VERSION\n+#define TARGET_VERSION fputs (\" (Xtensa GNU/Linux with ELF)\", stderr);\n+\n+#undef ASM_SPEC\n+#define ASM_SPEC \"%{v} %{mno-density:--no-density} \\\n+                  %{mtext-section-literals:--text-section-literals} \\\n+                  %{mno-text-section-literals:--no-text-section-literals} \\\n+\t\t  %{mtarget-align:--target-align} \\\n+\t\t  %{mno-target-align:--no-target-align} \\\n+\t\t  %{mlongcalls:--longcalls} \\\n+\t\t  %{mno-longcalls:--no-longcalls}\"\n+\n+#undef ASM_FINAL_SPEC\n+\n+#undef LIB_SPEC\n+#define LIB_SPEC \\\n+  \"%{shared: -lc} \\\n+   %{!shared: %{pthread:-lpthread} \\\n+   %{profile:-lc_p} %{!profile: -lc}}\"\n+\n+#undef LINK_SPEC\n+#define LINK_SPEC \\\n+ \"%{shared:-shared} \\\n+  %{!shared: \\\n+    %{!ibcs: \\\n+      %{!static: \\\n+        %{rdynamic:-export-dynamic} \\\n+        %{!dynamic-linker:-dynamic-linker /lib/ld.so.1}} \\\n+      %{static:-static}}}\"\n+\n+#undef CPP_PREDEFINES\n+#define CPP_PREDEFINES \\\n+ \"-D__XTENSA__ -D__ELF__ -Acpu=xtensa -Amachine=xtensa \\\n+  -Dunix -Dlinux -Asystem=posix\"\n+\n+#undef LOCAL_LABEL_PREFIX\n+#define LOCAL_LABEL_PREFIX\t\".\"\n+\n+/* Don't switch sections in the middle of a literal pool! */\n+#undef SELECT_RTX_SECTION\n+#define SELECT_RTX_SECTION(MODE,RTX,ALIGN)\n+\n+/* Always enable \"-fpic\" for Xtensa Linux.  */\n+#define XTENSA_ALWAYS_PIC 1\n+\n+/* Redefine the standard ELF version of ASM_DECLARE_FUNCTION_SIZE to\n+   allow adding the \".end literal_prefix\" directive at the end of the\n+   function.  */\n+#undef ASM_DECLARE_FUNCTION_SIZE\n+#define ASM_DECLARE_FUNCTION_SIZE(FILE, FNAME, DECL)\t\t\\\n+  do\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      if (!flag_inhibit_size_directive)\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\\\n+\t  char label[256];\t\t\t\t\t\\\n+\t  static int labelno;\t\t\t\t\t\\\n+\t  \t\t\t\t\t\t\t\\\n+\t  labelno++;\t\t\t\t\t\t\\\n+\t  \t\t\t\t\t\t\t\\\n+\t  ASM_GENERATE_INTERNAL_LABEL (label, \"Lfe\", labelno);\t\\\n+\t  ASM_OUTPUT_INTERNAL_LABEL (FILE, \"Lfe\", labelno);\t\\\n+\t  \t\t\t\t\t\t\t\\\n+\t  fprintf (FILE, \"%s\", SIZE_ASM_OP);\t\t\t\\\n+\t  assemble_name (FILE, (FNAME));\t\t\t\\\n+\t  fprintf (FILE, \",\");\t\t\t\t\t\\\n+\t  assemble_name (FILE, label);\t\t\t\t\\\n+\t  fprintf (FILE, \"-\");\t\t\t\t\t\\\n+\t  assemble_name (FILE, (FNAME));\t\t\t\\\n+\t  putc ('\\n', FILE);\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\\\n+      XTENSA_DECLARE_FUNCTION_SIZE(FILE, FNAME, DECL);\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  while (0)"}, {"sha": "76b8df65efea87d98642cf187fceff5ffdf56681", "filename": "gcc/config/xtensa/t-xtensa", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/039843087a884e96058fd0fcde72339974d49e81/gcc%2Fconfig%2Fxtensa%2Ft-xtensa", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/039843087a884e96058fd0fcde72339974d49e81/gcc%2Fconfig%2Fxtensa%2Ft-xtensa", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Ft-xtensa?ref=039843087a884e96058fd0fcde72339974d49e81", "patch": "@@ -0,0 +1,28 @@\n+# Use GCC's floating-point emulation code\n+LIB2FUNCS_EXTRA = fp-bit.c dp-bit.c\n+\n+dp-bit.c: $(srcdir)/config/fp-bit.c\n+\tcat $(srcdir)/config/fp-bit.c > dp-bit.c\n+\n+fp-bit.c: $(srcdir)/config/fp-bit.c\n+\techo '#define FLOAT' > fp-bit.c\n+\tcat $(srcdir)/config/fp-bit.c >> fp-bit.c\n+\n+########################################################################\n+\n+# Skip the libgcc1 test.\n+LIBGCC1_TEST =\n+\n+# Don't run fixproto\n+STMP_FIXPROTO =\n+\n+# Build crtbegin and crtend with the \"longcalls\" option\n+CRTSTUFF_T_CFLAGS += -mlongcalls\n+\n+CROSS_LIBGCC1 = libgcc1-asm.a\n+LIB1ASMSRC = xtensa/lib1funcs.asm\n+LIB1ASMFUNCS = _mulsi3 _nsau _divsi3 _modsi3 _udivsi3 _umodsi3\n+\n+TARGET_LIBGCC2_CFLAGS += -mlongcalls\n+\n+LIB2FUNCS_EXTRA += $(srcdir)/config/xtensa/lib2funcs.S"}, {"sha": "277efb2a82251d2f8d08b860ea2262534deba22c", "filename": "gcc/config/xtensa/xtensa-config.h", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/039843087a884e96058fd0fcde72339974d49e81/gcc%2Fconfig%2Fxtensa%2Fxtensa-config.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/039843087a884e96058fd0fcde72339974d49e81/gcc%2Fconfig%2Fxtensa%2Fxtensa-config.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Fxtensa-config.h?ref=039843087a884e96058fd0fcde72339974d49e81", "patch": "@@ -0,0 +1,50 @@\n+/* Xtensa configuration settings.\n+   Copyright (C) 2001 Free Software Foundation, Inc.\n+   Contributed by Bob Wilson (bwilson@tensilica.com) at Tensilica.\n+\n+This program is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+This program is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with this program; if not, write to the Free Software\n+Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n+*/\n+\n+#ifndef XTENSA_CONFIG_H\n+#define XTENSA_CONFIG_H\n+\n+#define XCHAL_HAVE_BE\t\t\t1\n+#define XCHAL_HAVE_DENSITY\t\t1\n+#define XCHAL_HAVE_MAC16\t\t0\n+#define XCHAL_HAVE_MUL16\t\t0\n+#define XCHAL_HAVE_MUL32\t\t0\n+#define XCHAL_HAVE_DIV32\t\t0\n+#define XCHAL_HAVE_NSA\t\t\t1\n+#define XCHAL_HAVE_MINMAX\t\t0\n+#define XCHAL_HAVE_SEXT\t\t\t0\n+#define XCHAL_HAVE_BOOLEANS\t\t0\n+#define XCHAL_HAVE_FP\t\t\t0\n+#define XCHAL_HAVE_FP_DIV\t\t0\n+#define XCHAL_HAVE_FP_RECIP\t\t0\n+#define XCHAL_HAVE_FP_SQRT\t\t0\n+#define XCHAL_HAVE_FP_RSQRT\t\t0\n+\n+#define XCHAL_ICACHE_SIZE\t\t8192\n+#define XCHAL_DCACHE_SIZE\t\t8192\n+#define XCHAL_ICACHE_LINESIZE\t\t16\n+#define XCHAL_DCACHE_LINESIZE\t\t16\n+#define XCHAL_ICACHE_LINEWIDTH\t\t4\n+#define XCHAL_DCACHE_LINEWIDTH\t\t4\n+#define XCHAL_DCACHE_IS_WRITEBACK\t0\n+\n+#define XCHAL_HAVE_MMU\t\t\t1\n+#define XCHAL_MMU_MIN_PTE_PAGE_SIZE\t12\n+\n+#endif /* !XTENSA_CONFIG_H */"}, {"sha": "bb18e3ae84adb68d44658f6e4caf1f5efbb50640", "filename": "gcc/config/xtensa/xtensa-protos.h", "status": "added", "additions": 116, "deletions": 0, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/039843087a884e96058fd0fcde72339974d49e81/gcc%2Fconfig%2Fxtensa%2Fxtensa-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/039843087a884e96058fd0fcde72339974d49e81/gcc%2Fconfig%2Fxtensa%2Fxtensa-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Fxtensa-protos.h?ref=039843087a884e96058fd0fcde72339974d49e81", "patch": "@@ -0,0 +1,116 @@\n+/* Prototypes of target machine for GNU compiler for Xtensa.\n+   Copyright (C) 2001 Free Software Foundation, Inc.\n+   Contributed by Bob Wilson (bwilson@tensilica.com) at Tensilica.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n+02111-1307, USA.  */\n+\n+#ifndef __XTENSA_PROTOS_H__\n+#define __XTENSA_PROTOS_H__\n+\n+/* Functions to test whether an immediate fits in a given field. */\n+extern int xtensa_simm7 PARAMS ((int));\n+extern int xtensa_simm8 PARAMS ((int));\n+extern int xtensa_simm8x256 PARAMS ((int));\n+extern int xtensa_simm12b PARAMS ((int));\n+extern int xtensa_uimm8 PARAMS ((int));\n+extern int xtensa_uimm8x2 PARAMS ((int));\n+extern int xtensa_uimm8x4 PARAMS ((int));\n+extern int xtensa_ai4const PARAMS ((int));\n+extern int xtensa_lsi4x4 PARAMS ((int));\n+extern int xtensa_b4const PARAMS ((int));\n+extern int xtensa_b4constu PARAMS ((int));\n+extern int xtensa_tp7 PARAMS ((int));\n+\n+/* Functions within xtensa.c that we reference.  */\n+#ifdef RTX_CODE\n+extern int xt_true_regnum PARAMS ((rtx));\n+extern int add_operand PARAMS ((rtx, enum machine_mode));\n+extern int arith_operand PARAMS ((rtx, enum machine_mode));\n+extern int nonimmed_operand PARAMS ((rtx, enum machine_mode));\n+extern int mem_operand PARAMS ((rtx, enum machine_mode));\n+extern int non_acc_reg_operand PARAMS ((rtx, enum machine_mode));\n+extern int mask_operand PARAMS ((rtx, enum machine_mode));\n+extern int extui_fldsz_operand PARAMS ((rtx, enum machine_mode));\n+extern int sext_operand PARAMS ((rtx, enum machine_mode));\n+extern int sext_fldsz_operand PARAMS ((rtx, enum machine_mode));\n+extern int lsbitnum_operand PARAMS ((rtx, enum machine_mode));\n+extern int branch_operand PARAMS ((rtx, enum machine_mode));\n+extern int ubranch_operand PARAMS ((rtx, enum machine_mode));\n+extern int call_insn_operand PARAMS ((rtx, enum machine_mode));\n+extern int move_operand PARAMS ((rtx, enum machine_mode));\n+extern int smalloffset_mem_p PARAMS ((rtx));\n+extern int smalloffset_double_mem_p PARAMS ((rtx));\n+extern int constantpool_address_p PARAMS ((rtx));\n+extern int constantpool_mem_p PARAMS ((rtx));\n+extern int non_const_move_operand PARAMS ((rtx, enum machine_mode));\n+extern int const_float_1_operand PARAMS ((rtx, enum machine_mode));\n+extern int fpmem_offset_operand PARAMS ((rtx, enum machine_mode));\n+extern void xtensa_extend_reg PARAMS ((rtx, rtx));\n+extern void xtensa_load_constant PARAMS ((rtx, rtx));\n+extern int branch_operator PARAMS ((rtx, enum machine_mode));\n+extern int ubranch_operator PARAMS ((rtx, enum machine_mode));\n+extern int boolean_operator PARAMS ((rtx, enum machine_mode));\n+extern void xtensa_expand_conditional_branch PARAMS ((rtx *, enum rtx_code));\n+extern int xtensa_expand_conditional_move PARAMS ((rtx *, int));\n+extern int xtensa_expand_scc PARAMS ((rtx *));\n+extern int xtensa_expand_block_move PARAMS ((rtx *));\n+extern int xtensa_emit_move_sequence PARAMS ((rtx *, enum machine_mode));\n+extern void xtensa_emit_block_move PARAMS ((rtx *, rtx *, int));\n+extern void xtensa_expand_nonlocal_goto PARAMS ((rtx *));\n+extern void xtensa_emit_loop_end PARAMS ((rtx, rtx *));\n+extern char * xtensa_emit_call PARAMS ((int, rtx *));\n+\n+#ifdef TREE_CODE\n+extern void init_cumulative_args PARAMS ((CUMULATIVE_ARGS *, tree, rtx));\n+extern void xtensa_va_start PARAMS ((int, tree, rtx));\n+extern rtx xtensa_va_arg PARAMS ((tree, tree));\n+#endif /* TREE_CODE */\n+\n+extern void print_operand PARAMS ((FILE *, rtx, int));\n+extern void print_operand_address PARAMS ((FILE *, rtx));\n+extern void xtensa_output_literal\n+  PARAMS ((FILE *, rtx, enum machine_mode, int labelno));\n+extern void xtensa_reorg PARAMS ((rtx));\n+extern rtx xtensa_builtin_saveregs PARAMS ((void));\n+extern enum reg_class xtensa_secondary_reload_class\n+  PARAMS ((enum reg_class, enum machine_mode, rtx, int));\n+extern int a7_overlap_mentioned_p PARAMS ((rtx x));\n+#endif /* RTX_CODE */\n+\n+#ifdef TREE_CODE\n+extern void function_arg_advance\n+  PARAMS ((CUMULATIVE_ARGS *, enum machine_mode, tree));\n+extern struct rtx_def * function_arg\n+  PARAMS ((CUMULATIVE_ARGS *, enum machine_mode, tree, int));\n+extern tree xtensa_build_va_list PARAMS ((void));\n+#endif /* TREE_CODE */\n+\n+extern int xtensa_mask_immediate PARAMS ((int));\n+extern int xtensa_mem_offset PARAMS ((unsigned, enum machine_mode));\n+extern void xtensa_setup_frame_addresses PARAMS ((void));\n+extern int xtensa_dbx_register_number PARAMS ((int));\n+extern void override_options PARAMS ((void));\n+extern void xtensa_declare_object\n+  PARAMS ((FILE *, char *, char *, char *, int));\n+extern long compute_frame_size PARAMS ((int));\n+extern int xtensa_frame_pointer_required PARAMS ((void));\n+extern void xtensa_function_prologue PARAMS ((FILE *, int));\n+extern void xtensa_function_epilogue PARAMS ((FILE *, int));\n+extern void order_regs_for_local_alloc PARAMS ((void));\n+\n+#endif /* !__XTENSA_PROTOS_H__ */"}, {"sha": "979b3e216bd267a5b808a91fcd8322d70bfe643a", "filename": "gcc/config/xtensa/xtensa.c", "status": "added", "additions": 2658, "deletions": 0, "changes": 2658, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/039843087a884e96058fd0fcde72339974d49e81/gcc%2Fconfig%2Fxtensa%2Fxtensa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/039843087a884e96058fd0fcde72339974d49e81/gcc%2Fconfig%2Fxtensa%2Fxtensa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Fxtensa.c?ref=039843087a884e96058fd0fcde72339974d49e81", "patch": "@@ -0,0 +1,2658 @@\n+/* Subroutines for insn-output.c for Tensilica's Xtensa architecture.\n+   Copyright (C) 2001 Free Software Foundation, Inc.\n+   Contributed by Bob Wilson (bwilson@tensilica.com) at Tensilica.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n+02111-1307, USA.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"rtl.h\"\n+#include \"regs.h\"\n+#include \"machmode.h\"\n+#include \"hard-reg-set.h\"\n+#include \"basic-block.h\"\n+#include \"real.h\"\n+#include \"insn-config.h\"\n+#include \"conditions.h\"\n+#include \"insn-flags.h\"\n+#include \"insn-attr.h\"\n+#include \"insn-codes.h\"\n+#include \"recog.h\"\n+#include \"output.h\"\n+#include \"tree.h\"\n+#include \"expr.h\"\n+#include \"flags.h\"\n+#include \"reload.h\"\n+#include \"tm_p.h\"\n+#include \"function.h\"\n+#include \"toplev.h\"\n+#include \"optabs.h\"\n+#include \"libfuncs.h\"\n+#include \"target.h\"\n+#include \"target-def.h\"\n+\n+/* Enumeration for all of the relational tests, so that we can build\n+   arrays indexed by the test type, and not worry about the order\n+   of EQ, NE, etc. */\n+\n+enum internal_test {\n+    ITEST_EQ,\n+    ITEST_NE,\n+    ITEST_GT,\n+    ITEST_GE,\n+    ITEST_LT,\n+    ITEST_LE,\n+    ITEST_GTU,\n+    ITEST_GEU,\n+    ITEST_LTU,\n+    ITEST_LEU,\n+    ITEST_MAX\n+  };\n+\n+/* Cached operands, and operator to compare for use in set/branch on\n+   condition codes.  */\n+rtx branch_cmp[2];\n+\n+/* what type of branch to use */\n+enum cmp_type branch_type;\n+\n+/* Array giving truth value on whether or not a given hard register\n+   can support a given mode.  */\n+char xtensa_hard_regno_mode_ok[(int) MAX_MACHINE_MODE][FIRST_PSEUDO_REGISTER];\n+\n+/* Current frame size calculated by compute_frame_size.  */\n+unsigned xtensa_current_frame_size;\n+\n+/* Tables of ld/st opcode names for block moves */\n+const char *xtensa_ld_opcodes[(int) MAX_MACHINE_MODE];\n+const char *xtensa_st_opcodes[(int) MAX_MACHINE_MODE];\n+#define LARGEST_MOVE_RATIO 15\n+\n+/* Define the structure for the machine field in struct function.  */\n+struct machine_function\n+{\n+  int accesses_prev_frame;\n+};\n+\n+/* Vector, indexed by hard register number, which contains 1 for a\n+   register that is allowable in a candidate for leaf function\n+   treatment. */\n+\n+const char xtensa_leaf_regs[FIRST_PSEUDO_REGISTER] =\n+{\n+  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n+  1, 1, 1,\n+  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n+  1\n+};\n+\n+/* Map hard register number to register class */\n+const enum reg_class xtensa_regno_to_class[FIRST_PSEUDO_REGISTER] =\n+{\n+  GR_REGS,\tSP_REG,\t\tGR_REGS,\tGR_REGS,\n+  GR_REGS,\tGR_REGS,\tGR_REGS,\tGR_REGS,\n+  GR_REGS,\tGR_REGS,\tGR_REGS,\tGR_REGS,\n+  GR_REGS,\tGR_REGS,\tGR_REGS,\tGR_REGS,\n+  AR_REGS,\tAR_REGS,\tBR_REGS,\n+  FP_REGS,\tFP_REGS,\tFP_REGS,\tFP_REGS,\n+  FP_REGS,\tFP_REGS,\tFP_REGS,\tFP_REGS,\n+  FP_REGS,\tFP_REGS,\tFP_REGS,\tFP_REGS,\n+  FP_REGS,\tFP_REGS,\tFP_REGS,\tFP_REGS,\n+  ACC_REG,\n+};\n+\n+/* Map register constraint character to register class.  */\n+enum reg_class xtensa_char_to_class[256] =\n+{\n+  NO_REGS,\tNO_REGS,\tNO_REGS,\tNO_REGS,\n+  NO_REGS,\tNO_REGS,\tNO_REGS,\tNO_REGS,\n+  NO_REGS,\tNO_REGS,\tNO_REGS,\tNO_REGS,\n+  NO_REGS,\tNO_REGS,\tNO_REGS,\tNO_REGS,\n+  NO_REGS,\tNO_REGS,\tNO_REGS,\tNO_REGS,\n+  NO_REGS,\tNO_REGS,\tNO_REGS,\tNO_REGS,\n+  NO_REGS,\tNO_REGS,\tNO_REGS,\tNO_REGS,\n+  NO_REGS,\tNO_REGS,\tNO_REGS,\tNO_REGS,\n+  NO_REGS,\tNO_REGS,\tNO_REGS,\tNO_REGS,\n+  NO_REGS,\tNO_REGS,\tNO_REGS,\tNO_REGS,\n+  NO_REGS,\tNO_REGS,\tNO_REGS,\tNO_REGS,\n+  NO_REGS,\tNO_REGS,\tNO_REGS,\tNO_REGS,\n+  NO_REGS,\tNO_REGS,\tNO_REGS,\tNO_REGS,\n+  NO_REGS,\tNO_REGS,\tNO_REGS,\tNO_REGS,\n+  NO_REGS,\tNO_REGS,\tNO_REGS,\tNO_REGS,\n+  NO_REGS,\tNO_REGS,\tNO_REGS,\tNO_REGS,\n+  NO_REGS,\tNO_REGS,\tNO_REGS,\tNO_REGS,\n+  NO_REGS,\tNO_REGS,\tNO_REGS,\tNO_REGS,\n+  NO_REGS,\tNO_REGS,\tNO_REGS,\tNO_REGS,\n+  NO_REGS,\tNO_REGS,\tNO_REGS,\tNO_REGS,\n+  NO_REGS,\tNO_REGS,\tNO_REGS,\tNO_REGS,\n+  NO_REGS,\tNO_REGS,\tNO_REGS,\tNO_REGS,\n+  NO_REGS,\tNO_REGS,\tNO_REGS,\tNO_REGS,\n+  NO_REGS,\tNO_REGS,\tNO_REGS,\tNO_REGS,\n+  NO_REGS,\tNO_REGS,\tNO_REGS,\tNO_REGS,\n+  NO_REGS,\tNO_REGS,\tNO_REGS,\tNO_REGS,\n+  NO_REGS,\tNO_REGS,\tNO_REGS,\tNO_REGS,\n+  NO_REGS,\tNO_REGS,\tNO_REGS,\tNO_REGS,\n+  NO_REGS,\tNO_REGS,\tNO_REGS,\tNO_REGS,\n+  NO_REGS,\tNO_REGS,\tNO_REGS,\tNO_REGS,\n+  NO_REGS,\tNO_REGS,\tNO_REGS,\tNO_REGS,\n+  NO_REGS,\tNO_REGS,\tNO_REGS,\tNO_REGS,\n+  NO_REGS,\tNO_REGS,\tNO_REGS,\tNO_REGS,\n+  NO_REGS,\tNO_REGS,\tNO_REGS,\tNO_REGS,\n+  NO_REGS,\tNO_REGS,\tNO_REGS,\tNO_REGS,\n+  NO_REGS,\tNO_REGS,\tNO_REGS,\tNO_REGS,\n+  NO_REGS,\tNO_REGS,\tNO_REGS,\tNO_REGS,\n+  NO_REGS,\tNO_REGS,\tNO_REGS,\tNO_REGS,\n+  NO_REGS,\tNO_REGS,\tNO_REGS,\tNO_REGS,\n+  NO_REGS,\tNO_REGS,\tNO_REGS,\tNO_REGS,\n+  NO_REGS,\tNO_REGS,\tNO_REGS,\tNO_REGS,\n+  NO_REGS,\tNO_REGS,\tNO_REGS,\tNO_REGS,\n+  NO_REGS,\tNO_REGS,\tNO_REGS,\tNO_REGS,\n+  NO_REGS,\tNO_REGS,\tNO_REGS,\tNO_REGS,\n+  NO_REGS,\tNO_REGS,\tNO_REGS,\tNO_REGS,\n+  NO_REGS,\tNO_REGS,\tNO_REGS,\tNO_REGS,\n+  NO_REGS,\tNO_REGS,\tNO_REGS,\tNO_REGS,\n+  NO_REGS,\tNO_REGS,\tNO_REGS,\tNO_REGS,\n+  NO_REGS,\tNO_REGS,\tNO_REGS,\tNO_REGS,\n+  NO_REGS,\tNO_REGS,\tNO_REGS,\tNO_REGS,\n+  NO_REGS,\tNO_REGS,\tNO_REGS,\tNO_REGS,\n+  NO_REGS,\tNO_REGS,\tNO_REGS,\tNO_REGS,\n+  NO_REGS,\tNO_REGS,\tNO_REGS,\tNO_REGS,\n+  NO_REGS,\tNO_REGS,\tNO_REGS,\tNO_REGS,\n+  NO_REGS,\tNO_REGS,\tNO_REGS,\tNO_REGS,\n+  NO_REGS,\tNO_REGS,\tNO_REGS,\tNO_REGS,\n+  NO_REGS,\tNO_REGS,\tNO_REGS,\tNO_REGS,\n+  NO_REGS,\tNO_REGS,\tNO_REGS,\tNO_REGS,\n+  NO_REGS,\tNO_REGS,\tNO_REGS,\tNO_REGS,\n+  NO_REGS,\tNO_REGS,\tNO_REGS,\tNO_REGS,\n+  NO_REGS,\tNO_REGS,\tNO_REGS,\tNO_REGS,\n+  NO_REGS,\tNO_REGS,\tNO_REGS,\tNO_REGS,\n+  NO_REGS,\tNO_REGS,\tNO_REGS,\tNO_REGS,\n+  NO_REGS,\tNO_REGS,\tNO_REGS,\tNO_REGS,\n+};\n+\n+/* This macro generates the assembly code for function entry.\n+   FILE is a stdio stream to output the code to.\n+   SIZE is an int: how many units of temporary storage to allocate.\n+   Refer to the array 'regs_ever_live' to determine which registers\n+   to save; 'regs_ever_live[I]' is nonzero if register number I\n+   is ever used in the function.  This macro is responsible for\n+   knowing which registers should not be saved even if used.  */\n+\n+#undef TARGET_ASM_FUNCTION_PROLOGUE\n+#define TARGET_ASM_FUNCTION_PROLOGUE xtensa_function_prologue\n+\n+/* This macro generates the assembly code for function exit,\n+   on machines that need it.  If FUNCTION_EPILOGUE is not defined\n+   then individual return instructions are generated for each\n+   return statement.  Args are same as for FUNCTION_PROLOGUE.  */\n+\n+#undef TARGET_ASM_FUNCTION_EPILOGUE\n+#define TARGET_ASM_FUNCTION_EPILOGUE xtensa_function_epilogue\n+\n+/* These hooks specify assembly directives for creating certain kinds\n+   of integer object.  */\n+\n+#undef TARGET_ASM_ALIGNED_SI_OP\n+#define TARGET_ASM_ALIGNED_SI_OP \"\\t.word\\t\"\n+\n+struct gcc_target targetm = TARGET_INITIALIZER;\n+\n+static int b4const_or_zero PARAMS ((int));\n+static enum internal_test map_test_to_internal_test PARAMS ((enum rtx_code));\n+static rtx gen_int_relational PARAMS ((enum rtx_code, rtx, rtx, int *));\n+static rtx gen_float_relational PARAMS ((enum rtx_code, rtx, rtx));\n+static rtx gen_conditional_move PARAMS ((rtx));\n+static rtx fixup_subreg_mem PARAMS ((rtx x));\n+static enum machine_mode xtensa_find_mode_for_size PARAMS ((unsigned));\n+static void xtensa_init_machine_status PARAMS ((struct function *p));\n+static void xtensa_free_machine_status PARAMS ((struct function *p));\n+static void printx PARAMS ((FILE *, signed int));\n+static rtx frame_size_const;\n+static int current_function_arg_words;\n+static const int reg_nonleaf_alloc_order[FIRST_PSEUDO_REGISTER] =\n+  REG_ALLOC_ORDER;\n+\n+\n+/*\n+ * Functions to test Xtensa immediate operand validity.\n+ */\n+\n+int\n+xtensa_b4constu (v)\n+     int v;\n+{\n+  switch (v)\n+    {\n+    case 32768:\n+    case 65536:\n+    case 2:\n+    case 3:\n+    case 4:\n+    case 5:\n+    case 6:\n+    case 7:\n+    case 8:\n+    case 10:\n+    case 12:\n+    case 16:\n+    case 32:\n+    case 64:\n+    case 128:\n+    case 256:\n+      return 1;\n+    }\n+  return 0;\n+}\n+\n+int\n+xtensa_simm8x256 (v)\n+     int v;\n+{\n+  return (v & 255) == 0 && (v >= -32768 && v <= 32512);\n+}\n+\n+int\n+xtensa_ai4const (v)\n+     int v;\n+{\n+  return (v == -1 || (v >= 1 && v <= 15));\n+}\n+\n+int\n+xtensa_simm7 (v)\n+     int v;\n+{\n+  return v >= -32 && v <= 95;\n+}\n+\n+int\n+xtensa_b4const (v)\n+     int v;\n+{\n+  switch (v)\n+    {\n+    case -1:\n+    case 1:\n+    case 2:\n+    case 3:\n+    case 4:\n+    case 5:\n+    case 6:\n+    case 7:\n+    case 8:\n+    case 10:\n+    case 12:\n+    case 16:\n+    case 32:\n+    case 64:\n+    case 128:\n+    case 256:\n+      return 1;\n+    }\n+  return 0;\n+}\n+\n+int\n+xtensa_simm8 (v)\n+     int v;\n+{\n+  return v >= -128 && v <= 127;\n+}\n+\n+int\n+xtensa_tp7 (v)\n+     int v;\n+{\n+  return (v >= 7 && v <= 22);\n+}\n+\n+int\n+xtensa_lsi4x4 (v)\n+     int v;\n+{\n+  return (v & 3) == 0 && (v >= 0 && v <= 60);\n+}\n+\n+int\n+xtensa_simm12b (v)\n+     int v;\n+{\n+  return v >= -2048 && v <= 2047;\n+}\n+\n+int\n+xtensa_uimm8 (v)\n+     int v;\n+{\n+  return v >= 0 && v <= 255;\n+}\n+\n+int\n+xtensa_uimm8x2 (v)\n+     int v;\n+{\n+  return (v & 1) == 0 && (v >= 0 && v <= 510);\n+}\n+\n+int\n+xtensa_uimm8x4 (v)\n+     int v;\n+{\n+  return (v & 3) == 0 && (v >= 0 && v <= 1020);\n+}\n+\n+\n+/* This is just like the standard true_regnum() function except that it\n+   works even when reg_renumber is not initialized. */\n+\n+int\n+xt_true_regnum (x)\n+     rtx x;\n+{\n+  if (GET_CODE (x) == REG)\n+    {\n+      if (reg_renumber\n+\t  && REGNO (x) >= FIRST_PSEUDO_REGISTER\n+\t  && reg_renumber[REGNO (x)] >= 0)\n+\treturn reg_renumber[REGNO (x)];\n+      return REGNO (x);\n+    }\n+  if (GET_CODE (x) == SUBREG)\n+    {\n+      int base = xt_true_regnum (SUBREG_REG (x));\n+      if (base >= 0 && base < FIRST_PSEUDO_REGISTER)\n+        return base + subreg_regno_offset (REGNO (SUBREG_REG (x)),\n+                                           GET_MODE (SUBREG_REG (x)),\n+                                           SUBREG_BYTE (x), GET_MODE (x));\n+    }\n+  return -1;\n+}\n+\n+\n+int\n+add_operand (op, mode)\n+    rtx op;\n+    enum machine_mode mode;\n+{\n+    if (GET_CODE (op) == CONST_INT)\n+\treturn (xtensa_simm8 (INTVAL (op)) ||\n+\t\txtensa_simm8x256 (INTVAL (op)));\n+\n+    return register_operand (op, mode);\n+}\n+\n+\n+int\n+arith_operand (op, mode)\n+    rtx op;\n+    enum machine_mode mode;\n+{\n+    if (GET_CODE (op) == CONST_INT)\n+\treturn xtensa_simm8 (INTVAL (op));\n+\n+    return register_operand (op, mode);\n+}\n+\n+\n+int\n+nonimmed_operand (op, mode)\n+    rtx op;\n+    enum machine_mode mode;\n+{\n+    /* We cannot use the standard nonimmediate_operand() predicate because\n+       it includes constant pool memory operands. */\n+\n+    if (memory_operand (op, mode))\n+\treturn !constantpool_address_p (XEXP (op, 0));\n+\n+    return register_operand (op, mode);\n+}\n+\n+\n+int\n+mem_operand (op, mode)\n+    rtx op;\n+    enum machine_mode mode;\n+{\n+    /* We cannot use the standard memory_operand() predicate because\n+       it includes constant pool memory operands. */\n+\n+    if (memory_operand (op, mode))\n+\treturn !constantpool_address_p (XEXP (op, 0));\n+\n+    return FALSE;\n+}\n+\n+\n+int\n+non_acc_reg_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  if (register_operand (op, mode))\n+    return !ACC_REG_P (xt_true_regnum (op));\n+  return FALSE;\n+}\n+\n+\n+int\n+mask_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  if (GET_CODE (op) == CONST_INT)\n+    return xtensa_mask_immediate (INTVAL (op));\n+\n+  return register_operand (op, mode);\n+}\n+\n+\n+int\n+extui_fldsz_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode ATTRIBUTE_UNUSED;\n+{\n+  return ((GET_CODE (op) == CONST_INT)\n+\t  && xtensa_mask_immediate ((1 << INTVAL (op)) - 1));\n+}\n+\n+\n+int\n+sext_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  if (TARGET_SEXT)\n+    return nonimmed_operand (op, mode);\n+  return mem_operand (op, mode);\n+}\n+\n+\n+int\n+sext_fldsz_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode ATTRIBUTE_UNUSED;\n+{\n+  return ((GET_CODE (op) == CONST_INT) && xtensa_tp7 (INTVAL (op) - 1));\n+}\n+\n+\n+int\n+lsbitnum_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode ATTRIBUTE_UNUSED;\n+{\n+  if (GET_CODE (op) == CONST_INT)\n+    {\n+      return (BITS_BIG_ENDIAN\n+\t      ? (INTVAL (op) == BITS_PER_WORD-1)\n+\t      : (INTVAL (op) == 0));\n+    }\n+  return FALSE;\n+}\n+\n+\n+static int\n+b4const_or_zero (v)\n+     int v;\n+{\n+  if (v == 0)\n+    return TRUE;\n+  return xtensa_b4const (v);\n+}\n+\n+\n+int\n+branch_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  if (GET_CODE (op) == CONST_INT)\n+    return b4const_or_zero (INTVAL (op));\n+\n+  return register_operand (op, mode);\n+}\n+\n+\n+int\n+ubranch_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  if (GET_CODE (op) == CONST_INT)\n+    return xtensa_b4constu (INTVAL (op));\n+\n+  return register_operand (op, mode);\n+}\n+\n+\n+int\n+call_insn_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode ATTRIBUTE_UNUSED;\n+{\n+  if ((GET_CODE (op) == REG)\n+      && (op != arg_pointer_rtx)\n+      && ((REGNO (op) < FRAME_POINTER_REGNUM)\n+\t  || (REGNO (op) > LAST_VIRTUAL_REGISTER)))\n+    return TRUE;\n+\n+  if (CONSTANT_ADDRESS_P (op))\n+    {\n+      /* Direct calls only allowed to static functions with PIC.  */\n+      return (!flag_pic || (GET_CODE (op) == SYMBOL_REF\n+\t\t\t    && SYMBOL_REF_FLAG (op)));\n+    }\n+\n+  return FALSE;\n+}\n+\n+\n+int\n+move_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  if (register_operand (op, mode))\n+    return TRUE;\n+\n+  /* Accept CONSTANT_P_RTX, since it will be gone by CSE1 and\n+     result in 0/1. */\n+  if (GET_CODE (op) == CONSTANT_P_RTX)\n+    return TRUE;\n+\n+  if (GET_CODE (op) == CONST_INT)\n+    return xtensa_simm12b (INTVAL (op));\n+\n+  if (GET_CODE (op) == MEM)\n+    return memory_address_p (mode, XEXP (op, 0));\n+\n+  return FALSE;\n+}\n+\n+\n+int\n+smalloffset_mem_p (op)\n+     rtx op;\n+{\n+  if (GET_CODE (op) == MEM)\n+    {\n+      rtx addr = XEXP (op, 0);\n+      if (GET_CODE (addr) == REG)\n+\treturn REG_OK_FOR_BASE_P (addr);\n+      if (GET_CODE (addr) == PLUS)\n+\t{\n+\t  rtx offset = XEXP (addr, 0);\n+\t  if (GET_CODE (offset) != CONST_INT)\n+\t    offset = XEXP (addr, 1);\n+\t  if (GET_CODE (offset) != CONST_INT)\n+\t    return FALSE;\n+\t  return xtensa_lsi4x4 (INTVAL (offset));\n+\t}\n+    }\n+  return FALSE;\n+}\n+\n+\n+int\n+smalloffset_double_mem_p (op)\n+     rtx op;\n+{\n+  if (!smalloffset_mem_p (op))\n+    return FALSE;\n+  return smalloffset_mem_p (adjust_address (op, GET_MODE (op), 4));\n+}\n+\n+\n+int\n+constantpool_address_p (addr)\n+     rtx addr;\n+{\n+  rtx sym = addr;\n+\n+  if (GET_CODE (addr) == CONST)\n+    {\n+      rtx offset;\n+\n+      /* only handle (PLUS (SYM, OFFSET)) form */\n+      addr = XEXP (addr, 0);\n+      if (GET_CODE (addr) != PLUS)\n+\treturn FALSE;\n+\n+      /* make sure the address is word aligned */\n+      offset = XEXP (addr, 1);\n+      if ((GET_CODE (offset) != CONST_INT)\n+\t  || ((INTVAL (offset) & 3) != 0))\n+\treturn FALSE;\n+\n+      sym = XEXP (addr, 0);\n+    }\n+\n+  if ((GET_CODE (sym) == SYMBOL_REF)\n+      && CONSTANT_POOL_ADDRESS_P (sym))\n+    return TRUE;\n+  return FALSE;\n+}\n+\n+\n+int\n+constantpool_mem_p (op)\n+     rtx op;\n+{\n+  if (GET_CODE (op) == MEM)\n+    return constantpool_address_p (XEXP (op, 0));\n+  return FALSE;\n+}\n+\n+\n+int\n+non_const_move_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  if (register_operand (op, mode))\n+    return 1;\n+  if (GET_CODE (op) == SUBREG)\n+    op = SUBREG_REG (op);\n+  if (GET_CODE (op) == MEM)\n+    return memory_address_p (mode, XEXP (op, 0));\n+  return FALSE;\n+}\n+\n+\n+/* Accept the floating point constant 1 in the appropriate mode.  */\n+\n+int\n+const_float_1_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  REAL_VALUE_TYPE d;\n+  static REAL_VALUE_TYPE onedf;\n+  static REAL_VALUE_TYPE onesf;\n+  static int one_initialized;\n+\n+  if ((GET_CODE (op) != CONST_DOUBLE)\n+      || (mode != GET_MODE (op))\n+      || (mode != DFmode && mode != SFmode))\n+    return FALSE;\n+\n+  REAL_VALUE_FROM_CONST_DOUBLE (d, op);\n+\n+  if (! one_initialized)\n+    {\n+      onedf = REAL_VALUE_ATOF (\"1.0\", DFmode);\n+      onesf = REAL_VALUE_ATOF (\"1.0\", SFmode);\n+      one_initialized = TRUE;\n+    }\n+\n+  if (mode == DFmode)\n+    return REAL_VALUES_EQUAL (d, onedf);\n+  else\n+    return REAL_VALUES_EQUAL (d, onesf);\n+}\n+\n+\n+int\n+fpmem_offset_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode ATTRIBUTE_UNUSED;\n+{\n+  if (GET_CODE (op) == CONST_INT)\n+    return xtensa_mem_offset (INTVAL (op), SFmode);\n+  return 0;\n+}\n+\n+\n+void\n+xtensa_extend_reg (dst, src)\n+     rtx dst;\n+     rtx src;\n+{\n+  rtx temp = gen_reg_rtx (SImode);\n+  rtx shift = GEN_INT (BITS_PER_WORD - GET_MODE_BITSIZE (GET_MODE (src)));\n+\n+  /* generate paradoxical subregs as needed so that the modes match */\n+  src = simplify_gen_subreg (SImode, src, GET_MODE (src), 0);\n+  dst = simplify_gen_subreg (SImode, dst, GET_MODE (dst), 0);\n+\n+  emit_insn (gen_ashlsi3 (temp, src, shift));\n+  emit_insn (gen_ashrsi3 (dst, temp, shift));\n+}\n+\n+\n+void\n+xtensa_load_constant (dst, src)\n+     rtx dst;\n+     rtx src;\n+{\n+  enum machine_mode mode = GET_MODE (dst);\n+  src = force_const_mem (SImode, src);\n+\n+  /* PC-relative loads are always SImode so we have to add a SUBREG if that\n+     is not the desired mode */\n+\n+  if (mode != SImode)\n+    {\n+      if (register_operand (dst, mode))\n+\tdst = simplify_gen_subreg (SImode, dst, mode, 0);\n+      else\n+\t{\n+\t  src = force_reg (SImode, src);\n+\t  src = gen_lowpart_SUBREG (mode, src);\n+\t}\n+    }\n+\n+  emit_move_insn (dst, src);\n+}\n+\n+\n+int\n+branch_operator (x, mode)\n+     rtx x;\n+     enum machine_mode mode;\n+{\n+  if (GET_MODE (x) != mode)\n+    return FALSE;\n+\n+  switch (GET_CODE (x))\n+    {\n+    case EQ:\n+    case NE:\n+    case LT:\n+    case GE:\n+      return TRUE;\n+    default:\n+      break;\n+    }\n+  return FALSE;\n+}\n+\n+\n+int\n+ubranch_operator (x, mode)\n+     rtx x;\n+     enum machine_mode mode;\n+{\n+  if (GET_MODE (x) != mode)\n+    return FALSE;\n+\n+  switch (GET_CODE (x))\n+    {\n+    case LTU:\n+    case GEU:\n+      return TRUE;\n+    default:\n+      break;\n+    }\n+  return FALSE;\n+}\n+\n+\n+int\n+boolean_operator (x, mode)\n+     rtx x;\n+     enum machine_mode mode;\n+{\n+  if (GET_MODE (x) != mode)\n+    return FALSE;\n+\n+  switch (GET_CODE (x))\n+    {\n+    case EQ:\n+    case NE:\n+      return TRUE;\n+    default:\n+      break;\n+    }\n+  return FALSE;\n+}\n+\n+\n+int\n+xtensa_mask_immediate (v)\n+     int v;\n+{\n+#define MAX_MASK_SIZE 16\n+  int mask_size;\n+\n+  for (mask_size = 1; mask_size <= MAX_MASK_SIZE; mask_size++)\n+    {\n+      if ((v & 1) == 0)\n+\treturn FALSE;\n+      v = v >> 1;\n+      if (v == 0)\n+\treturn TRUE;\n+    }\n+\n+  return FALSE;\n+}\n+\n+\n+int\n+xtensa_mem_offset (v, mode)\n+     unsigned v;\n+     enum machine_mode mode;\n+{\n+  switch (mode)\n+    {\n+    case BLKmode:\n+      /* Handle the worst case for block moves.  See xtensa_expand_block_move\n+\t where we emit an optimized block move operation if the block can be\n+\t moved in < \"move_ratio\" pieces.  The worst case is when the block is\n+\t aligned but has a size of (3 mod 4) (does this happen?) so that the\n+\t last piece requires a byte load/store. */\n+      return (xtensa_uimm8 (v) &&\n+\t      xtensa_uimm8 (v + MOVE_MAX * LARGEST_MOVE_RATIO));\n+\n+    case QImode:\n+      return xtensa_uimm8 (v);\n+\n+    case HImode:\n+      return xtensa_uimm8x2 (v);\n+\n+    case DFmode:\n+      return (xtensa_uimm8x4 (v) && xtensa_uimm8x4 (v + 4));\n+\n+    default:\n+      break;\n+    }\n+\n+  return xtensa_uimm8x4 (v);\n+}\n+\n+\n+/* Make normal rtx_code into something we can index from an array */\n+\n+static enum internal_test\n+map_test_to_internal_test (test_code)\n+     enum rtx_code test_code;\n+{\n+  enum internal_test test = ITEST_MAX;\n+\n+  switch (test_code)\n+    {\n+    default:\t\t\tbreak;\n+    case EQ:  test = ITEST_EQ;  break;\n+    case NE:  test = ITEST_NE;  break;\n+    case GT:  test = ITEST_GT;  break;\n+    case GE:  test = ITEST_GE;  break;\n+    case LT:  test = ITEST_LT;  break;\n+    case LE:  test = ITEST_LE;  break;\n+    case GTU: test = ITEST_GTU; break;\n+    case GEU: test = ITEST_GEU; break;\n+    case LTU: test = ITEST_LTU; break;\n+    case LEU: test = ITEST_LEU; break;\n+    }\n+\n+  return test;\n+}\n+\n+\n+/* Generate the code to compare two integer values.  The return value is\n+   the comparison expression. */\n+\n+static rtx\n+gen_int_relational (test_code, cmp0, cmp1, p_invert)\n+     enum rtx_code test_code;\t/* relational test (EQ, etc) */\n+     rtx cmp0;\t\t\t/* first operand to compare */\n+     rtx cmp1;\t\t\t/* second operand to compare */\n+     int *p_invert;\t\t/* whether branch needs to reverse its test */\n+{\n+  struct cmp_info {\n+    enum rtx_code test_code;\t/* test code to use in insn */\n+    int (*const_range_p) PARAMS ((int)); /* predicate function to check range */\n+    int const_add;\t\t/* constant to add (convert LE -> LT) */\n+    int reverse_regs;\t\t/* reverse registers in test */\n+    int invert_const;\t\t/* != 0 if invert value if cmp1 is constant */\n+    int invert_reg;\t\t/* != 0 if invert value if cmp1 is register */\n+    int unsignedp;\t\t/* != 0 for unsigned comparisons.  */\n+  };\n+\n+  static struct cmp_info info[ (int)ITEST_MAX ] = {\n+\n+    { EQ,\tb4const_or_zero,\t0, 0, 0, 0, 0 },\t/* EQ  */\n+    { NE,\tb4const_or_zero,\t0, 0, 0, 0, 0 },\t/* NE  */\n+\n+    { LT,\tb4const_or_zero,\t1, 1, 1, 0, 0 },\t/* GT  */\n+    { GE,\tb4const_or_zero,\t0, 0, 0, 0, 0 },\t/* GE  */\n+    { LT,\tb4const_or_zero,\t0, 0, 0, 0, 0 },\t/* LT  */\n+    { GE,\tb4const_or_zero,\t1, 1, 1, 0, 0 },\t/* LE  */\n+\n+    { LTU,\txtensa_b4constu,\t1, 1, 1, 0, 1 },\t/* GTU */\n+    { GEU,\txtensa_b4constu,\t0, 0, 0, 0, 1 },\t/* GEU */\n+    { LTU,\txtensa_b4constu,\t0, 0, 0, 0, 1 },\t/* LTU */\n+    { GEU,\txtensa_b4constu,\t1, 1, 1, 0, 1 },\t/* LEU */\n+  };\n+\n+  enum internal_test test;\n+  enum machine_mode mode;\n+  struct cmp_info *p_info;\n+\n+  test = map_test_to_internal_test (test_code);\n+  if (test == ITEST_MAX)\n+    abort ();\n+\n+  p_info = &info[ (int)test ];\n+\n+  mode = GET_MODE (cmp0);\n+  if (mode == VOIDmode)\n+    mode = GET_MODE (cmp1);\n+\n+  /* Make sure we can handle any constants given to us.  */\n+  if (GET_CODE (cmp1) == CONST_INT)\n+    {\n+      HOST_WIDE_INT value = INTVAL (cmp1);\n+      unsigned HOST_WIDE_INT uvalue = (unsigned HOST_WIDE_INT)value;\n+\n+      /* if the immediate overflows or does not fit in the immediate field,\n+\t spill it to a register */\n+\n+      if ((p_info->unsignedp ?\n+\t   (uvalue + p_info->const_add > uvalue) :\n+\t   (value + p_info->const_add > value)) != (p_info->const_add > 0))\n+\t{\n+\t  cmp1 = force_reg (mode, cmp1);\n+\t}\n+      else if (!(p_info->const_range_p) (value + p_info->const_add))\n+\t{\n+\t  cmp1 = force_reg (mode, cmp1);\n+\t}\n+    }\n+  else if ((GET_CODE (cmp1) != REG) && (GET_CODE (cmp1) != SUBREG))\n+    {\n+      cmp1 = force_reg (mode, cmp1);\n+    }\n+\n+  /* See if we need to invert the result.  */\n+  *p_invert = ((GET_CODE (cmp1) == CONST_INT)\n+\t       ? p_info->invert_const\n+\t       : p_info->invert_reg);\n+\n+  /* Comparison to constants, may involve adding 1 to change a LT into LE.\n+     Comparison between two registers, may involve switching operands.  */\n+  if (GET_CODE (cmp1) == CONST_INT)\n+    {\n+      if (p_info->const_add != 0)\n+\tcmp1 = GEN_INT (INTVAL (cmp1) + p_info->const_add);\n+\n+    }\n+  else if (p_info->reverse_regs)\n+    {\n+      rtx temp = cmp0;\n+      cmp0 = cmp1;\n+      cmp1 = temp;\n+    }\n+\n+  return gen_rtx (p_info->test_code, VOIDmode, cmp0, cmp1);\n+}\n+\n+\n+/* Generate the code to compare two float values.  The return value is\n+   the comparison expression. */\n+\n+static rtx\n+gen_float_relational (test_code, cmp0, cmp1)\n+     enum rtx_code test_code;\t/* relational test (EQ, etc) */\n+     rtx cmp0;\t\t\t/* first operand to compare */\n+     rtx cmp1;\t\t\t/* second operand to compare */\n+{\n+  rtx (*gen_fn) PARAMS ((rtx, rtx, rtx));\n+  rtx brtmp;\n+  int reverse_regs, invert;\n+\n+  switch (test_code)\n+    {\n+    case EQ: reverse_regs = 0; invert = 0; gen_fn = gen_seq_sf; break;\n+    case NE: reverse_regs = 0; invert = 1; gen_fn = gen_seq_sf; break;\n+    case LE: reverse_regs = 0; invert = 0; gen_fn = gen_sle_sf; break;\n+    case GT: reverse_regs = 1; invert = 0; gen_fn = gen_slt_sf; break;\n+    case LT: reverse_regs = 0; invert = 0; gen_fn = gen_slt_sf; break;\n+    case GE: reverse_regs = 1; invert = 0; gen_fn = gen_sle_sf; break;\n+    default: \n+      fatal_insn (\"bad test\", gen_rtx (test_code, VOIDmode, cmp0, cmp1));\n+      reverse_regs = 0; invert = 0; gen_fn = 0; /* avoid compiler warnings */\n+    }\n+\n+  if (reverse_regs)\n+    {\n+      rtx temp = cmp0;\n+      cmp0 = cmp1;\n+      cmp1 = temp;\n+    }\n+\n+  brtmp = gen_rtx_REG (CCmode, FPCC_REGNUM);\n+  emit_insn (gen_fn (brtmp, cmp0, cmp1));\n+\n+  return gen_rtx (invert ? EQ : NE, VOIDmode, brtmp, const0_rtx);\n+}\n+\n+\n+void\n+xtensa_expand_conditional_branch (operands, test_code)\n+     rtx *operands;\n+     enum rtx_code test_code;\n+{\n+  enum cmp_type type = branch_type;\n+  rtx cmp0 = branch_cmp[0];\n+  rtx cmp1 = branch_cmp[1];\n+  rtx cmp;\n+  int invert;\n+  rtx label1, label2;\n+\n+  switch (type)\n+    {\n+    case CMP_DF:\n+    default:\n+      fatal_insn (\"bad test\", gen_rtx (test_code, VOIDmode, cmp0, cmp1));\n+\n+    case CMP_SI:\n+      invert = FALSE;\n+      cmp = gen_int_relational (test_code, cmp0, cmp1, &invert);\n+      break;\n+\n+    case CMP_SF:\n+      if (!TARGET_HARD_FLOAT)\n+\tfatal_insn (\"bad test\", gen_rtx (test_code, VOIDmode, cmp0, cmp1));\n+      invert = FALSE;\n+      cmp = gen_float_relational (test_code, cmp0, cmp1);\n+      break;\n+    }\n+\n+  /* Generate the branch.  */\n+\n+  label1 = gen_rtx_LABEL_REF (VOIDmode, operands[0]);\n+  label2 = pc_rtx;\n+\n+  if (invert)\n+    {\n+      label2 = label1;\n+      label1 = pc_rtx;\n+    }\n+\n+  emit_jump_insn (gen_rtx_SET (VOIDmode, pc_rtx,\n+\t\t\t       gen_rtx_IF_THEN_ELSE (VOIDmode, cmp,\n+\t\t\t\t\t\t     label1,\n+\t\t\t\t\t\t     label2)));\n+}\n+\n+\n+static rtx\n+gen_conditional_move (cmp)\n+     rtx cmp;\n+{\n+  enum rtx_code code = GET_CODE (cmp);\n+  rtx op0 = branch_cmp[0];\n+  rtx op1 = branch_cmp[1];\n+\n+  if (branch_type == CMP_SI)\n+    {\n+      /* Jump optimization calls get_condition() which canonicalizes\n+\t comparisons like (GE x <const>) to (GT x <const-1>).\n+\t Transform those comparisons back to GE, since that is the\n+\t comparison supported in Xtensa.  We shouldn't have to\n+\t transform <LE x const> comparisons, because neither\n+\t xtensa_expand_conditional_branch() nor get_condition() will\n+\t produce them. */\n+\n+      if ((code == GT) && (op1 == constm1_rtx))\n+\t{\n+\t  code = GE;\n+\t  op1 = const0_rtx;\n+\t}\n+      cmp = gen_rtx (code, VOIDmode, cc0_rtx, const0_rtx);\n+\n+      if (boolean_operator (cmp, VOIDmode))\n+\t{\n+\t  /* swap the operands to make const0 second */\n+\t  if (op0 == const0_rtx)\n+\t    {\n+\t      op0 = op1;\n+\t      op1 = const0_rtx;\n+\t    }\n+\n+\t  /* if not comparing against zero, emit a comparison (subtract) */\n+\t  if (op1 != const0_rtx)\n+\t    {\n+\t      op0 = expand_binop (SImode, sub_optab, op0, op1,\n+\t\t\t\t  0, 0, OPTAB_LIB_WIDEN);\n+\t      op1 = const0_rtx;\n+\t    }\n+\t}\n+      else if (branch_operator (cmp, VOIDmode))\n+\t{\n+\t  /* swap the operands to make const0 second */\n+\t  if (op0 == const0_rtx)\n+\t    {\n+\t      op0 = op1;\n+\t      op1 = const0_rtx;\n+\n+\t      switch (code)\n+\t\t{\n+\t\tcase LT: code = GE; break;\n+\t\tcase GE: code = LT; break;\n+\t\tdefault: abort ();\n+\t\t}\n+\t    }\n+\n+\t  if (op1 != const0_rtx)\n+\t    return 0;\n+\t}\n+      else\n+\treturn 0;\n+\n+      return gen_rtx (code, VOIDmode, op0, op1);\n+    }\n+\n+  if (TARGET_HARD_FLOAT && (branch_type == CMP_SF))\n+    return gen_float_relational (code, op0, op1);\n+\n+  return 0;\n+}\n+\n+\n+int\n+xtensa_expand_conditional_move (operands, isflt)\n+    rtx *operands;\n+    int isflt;\n+{\n+  rtx cmp;\n+  rtx (*gen_fn) PARAMS ((rtx, rtx, rtx, rtx, rtx));\n+\n+  if (!(cmp = gen_conditional_move (operands[1])))\n+    return 0;\n+\n+  if (isflt)\n+    gen_fn = (branch_type == CMP_SI\n+\t      ? gen_movsfcc_internal0\n+\t      : gen_movsfcc_internal1);\n+  else\n+    gen_fn = (branch_type == CMP_SI\n+\t      ? gen_movsicc_internal0\n+\t      : gen_movsicc_internal1);\n+\n+  emit_insn (gen_fn (operands[0], XEXP (cmp, 0),\n+\t\t     operands[2], operands[3], cmp));\n+  return 1;\n+}\n+\n+\n+int\n+xtensa_expand_scc (operands)\n+     rtx *operands;\n+{\n+  rtx dest = operands[0];\n+  rtx cmp = operands[1];\n+  rtx one_tmp, zero_tmp;\n+  rtx (*gen_fn) PARAMS ((rtx, rtx, rtx, rtx, rtx));\n+\n+  if (!(cmp = gen_conditional_move (cmp)))\n+    return 0;\n+\n+  one_tmp = gen_reg_rtx (SImode);\n+  zero_tmp = gen_reg_rtx (SImode);\n+  emit_insn (gen_movsi (one_tmp, const_true_rtx));\n+  emit_insn (gen_movsi (zero_tmp, const0_rtx));\n+\n+  gen_fn = (branch_type == CMP_SI\n+\t    ? gen_movsicc_internal0\n+\t    : gen_movsicc_internal1);\n+  emit_insn (gen_fn (dest, XEXP (cmp, 0), one_tmp, zero_tmp, cmp));\n+  return 1;\n+}\n+\n+\n+/* Emit insns to move operands[1] into operands[0].\n+\n+   Return 1 if we have written out everything that needs to be done to\n+   do the move.  Otherwise, return 0 and the caller will emit the move\n+   normally.  */\n+\n+int\n+xtensa_emit_move_sequence (operands, mode)\n+     rtx *operands;\n+     enum machine_mode mode;\n+{\n+  if (CONSTANT_P (operands[1])\n+      && GET_CODE (operands[1]) != CONSTANT_P_RTX\n+      && (GET_CODE (operands[1]) != CONST_INT\n+\t  || !xtensa_simm12b (INTVAL (operands[1]))))\n+    {\n+      xtensa_load_constant (operands[0], operands[1]);\n+      return 1;\n+    }\n+\n+  if (!(reload_in_progress | reload_completed))\n+    {\n+      if (!non_acc_reg_operand (operands[0], mode)\n+\t  && !non_acc_reg_operand (operands[1], mode))\n+\toperands[1] = force_reg (mode, operands[1]);\n+\n+      /* Check if this move is copying an incoming argument in a7.  If\n+\t so, emit the move, followed by the special \"set_frame_ptr\"\n+\t unspec_volatile insn, at the very beginning of the function.\n+\t This is necessary because the register allocator will ignore\n+\t conflicts with a7 and may assign some other pseudo to a7.  If\n+\t that pseudo was assigned prior to this move, it would clobber\n+\t the incoming argument in a7.  By copying the argument out of\n+\t a7 as the very first thing, and then immediately following\n+\t that with an unspec_volatile to keep the scheduler away, we\n+\t should avoid any problems.  */\n+\n+      if (a7_overlap_mentioned_p (operands[1]))\n+\t{\n+\t  rtx mov;\n+\t  switch (mode)\n+\t    {\n+\t    case SImode:\n+\t      mov = gen_movsi_internal (operands[0], operands[1]);\n+\t      break;\n+\t    case HImode:\n+\t      mov = gen_movhi_internal (operands[0], operands[1]);\n+\t      break;\n+\t    case QImode:\n+\t      mov = gen_movqi_internal (operands[0], operands[1]);\n+\t      break;\n+\t    default:\n+\t      abort ();\n+\t    }\n+\n+\t  /* Insert the instructions before any other argument copies.\n+\t     (The set_frame_ptr insn comes _after_ the move, so push it\n+\t     out first.)  */\n+\t  push_topmost_sequence ();\n+\t  emit_insn_after (gen_set_frame_ptr (), get_insns ());\n+\t  emit_insn_after (mov, get_insns ());\n+\t  pop_topmost_sequence ();\n+\n+\t  return 1;\n+\t}\n+    }\n+\n+  /* During reload we don't want to emit (subreg:X (mem:Y)) since that\n+     instruction won't be recognized after reload. So we remove the\n+     subreg and adjust mem accordingly. */\n+  if (reload_in_progress)\n+    {\n+      operands[0] = fixup_subreg_mem (operands[0]);\n+      operands[1] = fixup_subreg_mem (operands[1]);\n+    }\n+  return 0;\n+}\n+\n+static rtx\n+fixup_subreg_mem (x)\n+     rtx x;\n+{\n+  if (GET_CODE (x) == SUBREG\n+      && GET_CODE (SUBREG_REG (x)) == REG\n+      && REGNO (SUBREG_REG (x)) >= FIRST_PSEUDO_REGISTER)\n+    {\n+      rtx temp =\n+\tgen_rtx_SUBREG (GET_MODE (x),\n+\t\t\treg_equiv_mem [REGNO (SUBREG_REG (x))],\n+\t\t\tSUBREG_BYTE (x));\n+      x = alter_subreg (&temp);\n+    }\n+  return x;\n+}\n+\n+\n+/* Try to expand a block move operation to an RTL block move instruction.\n+   If not optimizing or if the block size is not a constant or if the\n+   block is small, the expansion fails and GCC falls back to calling\n+   memcpy().\n+\n+   operands[0] is the destination\n+   operands[1] is the source\n+   operands[2] is the length\n+   operands[3] is the alignment */\n+\n+int\n+xtensa_expand_block_move (operands)\n+     rtx *operands;\n+{\n+  rtx dest = operands[0];\n+  rtx src = operands[1];\n+  int bytes = INTVAL (operands[2]);\n+  int align = XINT (operands[3], 0);\n+  int num_pieces, move_ratio;\n+\n+  /* If this is not a fixed size move, just call memcpy */\n+  if (!optimize || (GET_CODE (operands[2]) != CONST_INT))\n+    return 0;\n+\n+  /* Anything to move? */\n+  if (bytes <= 0)\n+    return 1;\n+\n+  if (align > MOVE_MAX)\n+    align = MOVE_MAX;\n+\n+  /* decide whether to expand inline based on the optimization level */\n+  move_ratio = 4;\n+  if (optimize > 2)\n+    move_ratio = LARGEST_MOVE_RATIO;\n+  num_pieces = (bytes / align) + (bytes % align); /* close enough anyway */\n+  if (num_pieces >= move_ratio)\n+    return 0;\n+\n+   /* make sure the memory addresses are valid */\n+  operands[0] = change_address (dest, VOIDmode, NULL);\n+  operands[1] = change_address (src, VOIDmode, NULL);\n+\n+  emit_insn (gen_movstrsi_internal (operands[0], operands[1],\n+\t\t\t\t    operands[2], operands[3]));\n+  return 1;\n+}\n+\n+\n+/*  Emit a sequence of instructions to implement a block move, trying\n+    to hide load delay slots as much as possible.  Load N values into\n+    temporary registers, store those N values, and repeat until the\n+    complete block has been moved.  N=delay_slots+1 */\n+\n+struct meminsnbuf {\n+  char template[30];\n+  rtx operands[2];\n+};\n+\n+void\n+xtensa_emit_block_move (operands, tmpregs, delay_slots)\n+     rtx *operands;\n+     rtx *tmpregs;\n+     int delay_slots;\n+{\n+  rtx dest = operands[0];\n+  rtx src = operands[1];\n+  int bytes = INTVAL (operands[2]);\n+  int align = XINT (operands[3], 0);\n+  rtx from_addr = XEXP (src, 0);\n+  rtx to_addr = XEXP (dest, 0);\n+  int from_struct = MEM_IN_STRUCT_P (src);\n+  int to_struct = MEM_IN_STRUCT_P (dest);\n+  int offset = 0;\n+  int chunk_size, item_size;\n+  struct meminsnbuf *ldinsns, *stinsns;\n+  const char *ldname, *stname;\n+  enum machine_mode mode;\n+\n+  if (align > MOVE_MAX)\n+    align = MOVE_MAX;\n+  item_size = align;\n+  chunk_size = delay_slots + 1;\n+\n+  ldinsns = (struct meminsnbuf *)\n+    alloca (chunk_size * sizeof (struct meminsnbuf));\n+  stinsns = (struct meminsnbuf *)\n+    alloca (chunk_size * sizeof (struct meminsnbuf));\n+\n+  mode = xtensa_find_mode_for_size (item_size);\n+  item_size = GET_MODE_SIZE (mode);\n+  ldname = xtensa_ld_opcodes[(int) mode];\n+  stname = xtensa_st_opcodes[(int) mode];\n+\n+  while (bytes > 0)\n+    {\n+      int n;\n+\n+      for (n = 0; n < chunk_size; n++)\n+\t{\n+\t  rtx addr, mem;\n+\n+\t  if (bytes == 0)\n+\t    {\n+\t      chunk_size = n;\n+\t      break;\n+\t    }\n+\n+\t  if (bytes < item_size)\n+\t    {\n+\t      /* find a smaller item_size which we can load & store */\n+\t      item_size = bytes;\n+\t      mode = xtensa_find_mode_for_size (item_size);\n+\t      item_size = GET_MODE_SIZE (mode);\n+\t      ldname = xtensa_ld_opcodes[(int) mode];\n+\t      stname = xtensa_st_opcodes[(int) mode];\n+\t    }\n+\n+\t  /* record the load instruction opcode and operands */\n+\t  addr = plus_constant (from_addr, offset);\n+\t  mem = gen_rtx_MEM (mode, addr);\n+\t  if (! memory_address_p (mode, addr))\n+\t    abort ();\n+\t  MEM_IN_STRUCT_P (mem) = from_struct;\n+\t  ldinsns[n].operands[0] = tmpregs[n];\n+\t  ldinsns[n].operands[1] = mem;\n+\t  sprintf (ldinsns[n].template, \"%s\\t%%0, %%1\", ldname);\n+\n+\t  /* record the store instruction opcode and operands */\n+\t  addr = plus_constant (to_addr, offset);\n+\t  mem = gen_rtx_MEM (mode, addr);\n+\t  if (! memory_address_p (mode, addr))\n+\t    abort ();\n+\t  MEM_IN_STRUCT_P (mem) = to_struct;\n+\t  stinsns[n].operands[0] = tmpregs[n];\n+\t  stinsns[n].operands[1] = mem;\n+\t  sprintf (stinsns[n].template, \"%s\\t%%0, %%1\", stname);\n+\n+\t  offset += item_size;\n+\t  bytes -= item_size;\n+\t}\n+\n+      /* now output the loads followed by the stores */\n+      for (n = 0; n < chunk_size; n++)\n+\toutput_asm_insn (ldinsns[n].template, ldinsns[n].operands);\n+      for (n = 0; n < chunk_size; n++)\n+\toutput_asm_insn (stinsns[n].template, stinsns[n].operands);\n+    }\n+}\n+\n+\n+static enum machine_mode\n+xtensa_find_mode_for_size (item_size)\n+     unsigned item_size;\n+{\n+  enum machine_mode mode, tmode;\n+\n+  while (1)\n+    {\n+      mode = VOIDmode;\n+\n+      /* find mode closest to but not bigger than item_size */\n+      for (tmode = GET_CLASS_NARROWEST_MODE (MODE_INT);\n+\t   tmode != VOIDmode; tmode = GET_MODE_WIDER_MODE (tmode))\n+\tif (GET_MODE_SIZE (tmode) <= item_size)\n+\t  mode = tmode;\n+      if (mode == VOIDmode)\n+\tabort ();\n+\n+      item_size = GET_MODE_SIZE (mode);\n+\n+      if (xtensa_ld_opcodes[(int) mode]\n+\t  && xtensa_st_opcodes[(int) mode])\n+\tbreak;\n+\n+      /* cannot load & store this mode; try something smaller */\n+      item_size -= 1;\n+    }\n+\n+  return mode;\n+}\n+\n+\n+void\n+xtensa_expand_nonlocal_goto (operands)\n+     rtx *operands;\n+{\n+  rtx goto_handler = operands[1];\n+  rtx containing_fp = operands[3];\n+\n+  /* generate a call to \"__xtensa_nonlocal_goto\" (in libgcc); the code\n+     is too big to generate in-line */\n+\n+  if (GET_CODE (containing_fp) != REG)\n+    containing_fp = force_reg (Pmode, containing_fp);\n+\n+  goto_handler = replace_rtx (copy_rtx (goto_handler),\n+\t\t\t      virtual_stack_vars_rtx,\n+\t\t\t      containing_fp);\n+\n+  emit_library_call (gen_rtx_SYMBOL_REF (Pmode, \"__xtensa_nonlocal_goto\"),\n+\t\t     0, VOIDmode, 2,\n+\t\t     containing_fp, Pmode,\n+\t\t     goto_handler, Pmode);\n+}\n+\n+\n+static void\n+xtensa_init_machine_status (p)\n+     struct function *p;\n+{\n+  p->machine = (struct machine_function *)\n+    xcalloc (1, sizeof (struct machine_function));\n+}\n+\n+\n+static void\n+xtensa_free_machine_status (p)\n+     struct function *p;\n+{\n+  free (p->machine);\n+  p->machine = NULL;\n+}\n+\n+\n+void\n+xtensa_setup_frame_addresses ()\n+{\n+  /* Set flag to cause FRAME_POINTER_REQUIRED to be set. */\n+  cfun->machine->accesses_prev_frame = 1;\n+\n+  emit_library_call\n+    (gen_rtx_SYMBOL_REF (Pmode, \"__xtensa_libgcc_window_spill\"),\n+     0, VOIDmode, 0);\n+}\n+\n+\n+/* Emit the assembly for the end of a zero-cost loop. Normally we just emit\n+   a comment showing where the end of the loop is. However, if there is a\n+   label or a branch at the end of the loop then we need to place a nop\n+   there. If the loop ends with a label we need the nop so that branches\n+   targetting that label will target the nop (and thus remain in the loop),\n+   instead of targetting the instruction after the loop (and thus exiting\n+   the loop). If the loop ends with a branch, we need the nop in case the\n+   branch is targetting a location inside the loop. When the branch\n+   executes it will cause the loop count to be decremented even if it is\n+   taken (because it is the last instruction in the loop), so we need to\n+   nop after the branch to prevent the loop count from being decremented\n+   when the branch is taken. */\n+\n+void\n+xtensa_emit_loop_end (insn, operands)\n+     rtx insn;\n+     rtx *operands;\n+{\n+  char done = 0;\n+\n+  for (insn = PREV_INSN (insn); insn && !done; insn = PREV_INSN (insn))\n+    {\n+      switch (GET_CODE (insn))\n+\t{\n+\tcase NOTE:\n+\tcase BARRIER:\n+\t  break;\n+\n+\tcase CODE_LABEL:\n+\t  output_asm_insn (\"nop.n\", operands);\n+\t  done = 1;\n+\t  break;\n+\n+\tdefault:\n+\t  {\n+\t    rtx body = PATTERN (insn);\n+\n+\t    if (GET_CODE (body) == JUMP_INSN)\n+\t      {\n+\t\toutput_asm_insn (\"nop.n\", operands);\n+\t\tdone = 1;\n+\t      }\n+\t    else if ((GET_CODE (body) != USE)\n+\t\t     && (GET_CODE (body) != CLOBBER))\n+\t      done = 1;\n+\t  }\n+\t  break;\n+        }\n+    }\n+\n+  output_asm_insn (\"# loop end for %0\", operands);\n+}\n+\n+\n+char *\n+xtensa_emit_call (callop, operands)\n+     int callop;\n+     rtx *operands;\n+{\n+  char *result = (char *) malloc (64);\n+  rtx tgt = operands[callop];\n+\n+  if (GET_CODE (tgt) == CONST_INT)\n+    sprintf (result, \"call8\\t0x%x\", INTVAL (tgt));\n+  else if (register_operand (tgt, VOIDmode))\n+    sprintf (result, \"callx8\\t%%%d\", callop);\n+  else\n+    sprintf (result, \"call8\\t%%%d\", callop);\n+\n+  return result;\n+}\n+\n+\n+/* Return the stabs register number to use for 'regno'. */\n+\n+int\n+xtensa_dbx_register_number (regno)\n+     int regno;\n+{\n+  int first = -1;\n+  \n+  if (GP_REG_P (regno)) {\n+    regno -= GP_REG_FIRST;\n+    first = 0;\n+  }\n+  else if (BR_REG_P (regno)) {\n+    regno -= BR_REG_FIRST;\n+    first = 16;\n+  }\n+  else if (FP_REG_P (regno)) {\n+    regno -= FP_REG_FIRST;\n+    /* The current numbering convention is that TIE registers are\n+       numbered in libcc order beginning with 256.  We can't guarantee\n+       that the FP registers will come first, so the following is just\n+       a guess.  It seems like we should make a special case for FP\n+       registers and give them fixed numbers < 256. */\n+    first = 256;\n+  }\n+  else if (ACC_REG_P (regno))\n+    {\n+      first = 0;\n+      regno = -1;\n+    }\n+\n+  /* When optimizing, we sometimes get asked about pseudo-registers\n+     that don't represent hard registers. Return 0 for these. */\n+  if (first == -1)\n+    return 0;\n+\n+  return first + regno;\n+}\n+\n+\n+/* Argument support functions.  */\n+\n+/* Initialize CUMULATIVE_ARGS for a function.  */\n+\n+void\n+init_cumulative_args (cum, fntype, libname)\n+     CUMULATIVE_ARGS *cum;\t/* argument info to initialize */\n+     tree fntype ATTRIBUTE_UNUSED;\t/* tree ptr for function decl */\n+     rtx libname ATTRIBUTE_UNUSED;\t/* SYMBOL_REF of library name or 0 */\n+{\n+  cum->arg_words = 0;\n+}\n+\n+/* Advance the argument to the next argument position.  */\n+\n+void\n+function_arg_advance (cum, mode, type)\n+     CUMULATIVE_ARGS *cum;\t/* current arg information */\n+     enum machine_mode mode;\t/* current arg mode */\n+     tree type;\t\t\t/* type of the argument or 0 if lib support */\n+{\n+  int words, max;\n+  int *arg_words;\n+\n+  arg_words = &cum->arg_words;\n+  max = MAX_ARGS_IN_REGISTERS;\n+\n+  words = (((mode != BLKmode)\n+\t    ? (int) GET_MODE_SIZE (mode)\n+\t    : int_size_in_bytes (type)) + UNITS_PER_WORD - 1) / UNITS_PER_WORD;\n+\n+  if ((*arg_words + words > max) && (*arg_words < max))\n+    *arg_words = max;\n+\n+  *arg_words += words;\n+}\n+\n+\n+/* Return an RTL expression containing the register for the given mode,\n+   or 0 if the argument is to be passed on the stack.  */\n+\n+rtx\n+function_arg (cum, mode, type, incoming_p)\n+     CUMULATIVE_ARGS *cum;\t/* current arg information */\n+     enum machine_mode mode;\t/* current arg mode */\n+     tree type;\t\t\t/* type of the argument or 0 if lib support */\n+     int incoming_p;\t\t/* computing the incoming registers? */\n+{\n+  int regbase, words, max;\n+  int *arg_words;\n+  int regno;\n+  enum machine_mode result_mode;\n+\n+  arg_words = &cum->arg_words;\n+  regbase = (incoming_p ? GP_ARG_FIRST : GP_OUTGOING_ARG_FIRST);\n+  max = MAX_ARGS_IN_REGISTERS;\n+\n+  words = (((mode != BLKmode)\n+\t    ? (int) GET_MODE_SIZE (mode)\n+\t    : int_size_in_bytes (type)) + UNITS_PER_WORD - 1) / UNITS_PER_WORD;\n+\n+  if (type && (TYPE_ALIGN (type) > BITS_PER_WORD))\n+    *arg_words += (*arg_words & 1);\n+\n+  if (*arg_words + words > max)\n+    return (rtx)0;\n+\n+  regno = regbase + *arg_words;\n+  result_mode = (mode == BLKmode ? TYPE_MODE (type) : mode);\n+\n+  /* We need to make sure that references to a7 are represented with\n+     rtx that is not equal to hard_frame_pointer_rtx.  For BLKmode and\n+     modes bigger than 2 words (because we only have patterns for\n+     modes of 2 words or smaller), we can't control the expansion\n+     unless we explicitly list the individual registers in a PARALLEL. */\n+\n+  if ((mode == BLKmode || words > 2)\n+      && regno < A7_REG\n+      && regno + words > A7_REG)\n+    {\n+      rtx result;\n+      int n;\n+\n+      result = gen_rtx_PARALLEL (result_mode, rtvec_alloc (words));\n+      for (n = 0; n < words; n++)\n+\t{\n+\t  XVECEXP (result, 0, n) =\n+\t    gen_rtx_EXPR_LIST (VOIDmode,\n+\t\t\t       gen_raw_REG (SImode, regno + n),\n+\t\t\t       GEN_INT (n * UNITS_PER_WORD));\n+\t}\n+      return result;\n+    }\n+\n+  return gen_raw_REG (result_mode, regno);\n+}\n+\n+\n+void\n+override_options ()\n+{\n+  int regno;\n+  enum machine_mode mode;\n+\n+  if (!TARGET_BOOLEANS && TARGET_HARD_FLOAT)\n+    error (\"boolean registers required for the floating-point option\");\n+\n+  /* set up the tables of ld/st opcode names for block moves */\n+  xtensa_ld_opcodes[(int) SImode] = \"l32i\";\n+  xtensa_ld_opcodes[(int) HImode] = \"l16ui\";\n+  xtensa_ld_opcodes[(int) QImode] = \"l8ui\";\n+  xtensa_st_opcodes[(int) SImode] = \"s32i\";\n+  xtensa_st_opcodes[(int) HImode] = \"s16i\";\n+  xtensa_st_opcodes[(int) QImode] = \"s8i\";\n+\n+  xtensa_char_to_class['q'] = SP_REG;\n+  xtensa_char_to_class['a'] = GR_REGS;\n+  xtensa_char_to_class['b'] = ((TARGET_BOOLEANS) ? BR_REGS : NO_REGS);\n+  xtensa_char_to_class['f'] = ((TARGET_HARD_FLOAT) ? FP_REGS : NO_REGS);\n+  xtensa_char_to_class['A'] = ((TARGET_MAC16) ? ACC_REG : NO_REGS);\n+  xtensa_char_to_class['B'] = ((TARGET_SEXT) ? GR_REGS : NO_REGS);\n+  xtensa_char_to_class['C'] = ((TARGET_MUL16) ? GR_REGS: NO_REGS);\n+  xtensa_char_to_class['D'] = ((TARGET_DENSITY) ? GR_REGS: NO_REGS);\n+  xtensa_char_to_class['d'] = ((TARGET_DENSITY) ? AR_REGS: NO_REGS);\n+\n+  /* Set up array giving whether a given register can hold a given mode. */\n+  for (mode = VOIDmode;\n+       mode != MAX_MACHINE_MODE;\n+       mode = (enum machine_mode) ((int) mode + 1))\n+    {\n+      int size = GET_MODE_SIZE (mode);\n+      enum mode_class class = GET_MODE_CLASS (mode);\n+\n+      for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n+\t{\n+\t  int temp;\n+\n+\t  if (ACC_REG_P (regno))\n+\t    temp = (TARGET_MAC16 &&\n+\t\t    (class == MODE_INT) && (size <= UNITS_PER_WORD));\n+\t  else if (GP_REG_P (regno))\n+\t    temp = ((regno & 1) == 0 || (size <= UNITS_PER_WORD));\n+\t  else if (FP_REG_P (regno))\n+\t    temp = (TARGET_HARD_FLOAT && (mode == SFmode));\n+\t  else if (BR_REG_P (regno))\n+\t    temp = (TARGET_BOOLEANS && (mode == CCmode));\n+\t  else\n+\t    temp = FALSE;\n+\n+\t  xtensa_hard_regno_mode_ok[(int) mode][regno] = temp;\n+\t}\n+    }\n+\n+  init_machine_status = xtensa_init_machine_status;\n+  free_machine_status = xtensa_free_machine_status;\n+\n+  /* Check PIC settings.  There's no need for -fPIC on Xtensa and\n+     some targets need to always use PIC.  */\n+  if (XTENSA_ALWAYS_PIC)\n+    {\n+      if (flag_pic)\n+\twarning (\"-f%s ignored (all code is position independent)\",\n+\t\t (flag_pic > 1 ? \"PIC\" : \"pic\"));\n+      flag_pic = 1;\n+    }\n+  if (flag_pic > 1)\n+    flag_pic = 1;\n+}\n+\n+\n+/* A C compound statement to output to stdio stream STREAM the\n+   assembler syntax for an instruction operand X.  X is an RTL\n+   expression.\n+\n+   CODE is a value that can be used to specify one of several ways\n+   of printing the operand.  It is used when identical operands\n+   must be printed differently depending on the context.  CODE\n+   comes from the '%' specification that was used to request\n+   printing of the operand.  If the specification was just '%DIGIT'\n+   then CODE is 0; if the specification was '%LTR DIGIT' then CODE\n+   is the ASCII code for LTR.\n+\n+   If X is a register, this macro should print the register's name.\n+   The names can be found in an array 'reg_names' whose type is\n+   'char *[]'.  'reg_names' is initialized from 'REGISTER_NAMES'.\n+\n+   When the machine description has a specification '%PUNCT' (a '%'\n+   followed by a punctuation character), this macro is called with\n+   a null pointer for X and the punctuation character for CODE.\n+\n+   'a', 'c', 'l', and 'n' are reserved.\n+   \n+   The Xtensa specific codes are:\n+\n+   'd'  CONST_INT, print as signed decimal\n+   'x'  CONST_INT, print as signed hexadecimal\n+   'K'  CONST_INT, print number of bits in mask for EXTUI\n+   'R'  CONST_INT, print (X & 0x1f)\n+   'L'  CONST_INT, print ((32 - X) & 0x1f)\n+   'D'  REG, print second register of double-word register operand\n+   'N'  MEM, print address of next word following a memory operand\n+   'v'  MEM, if memory reference is volatile, output a MEMW before it\n+*/\n+\n+static void\n+printx (file, val)\n+     FILE *file;\n+     signed int val;\n+{\n+  /* print a hexadecimal value in a nice way */\n+  if ((val > -0xa) && (val < 0xa))\n+    fprintf (file, \"%d\", val);\n+  else if (val < 0)\n+    fprintf (file, \"-0x%x\", -val);\n+  else\n+    fprintf (file, \"0x%x\", val);\n+}\n+\n+\n+void\n+print_operand (file, op, letter)\n+     FILE *file;\t\t/* file to write to */\n+     rtx op;\t\t/* operand to print */\n+     int letter;\t\t/* %<letter> or 0 */\n+{\n+  enum rtx_code code;\n+\n+  if (! op)\n+    error (\"PRINT_OPERAND null pointer\");\n+\n+  code = GET_CODE (op);\n+  switch (code)\n+    {\n+    case REG:\n+    case SUBREG:\n+      {\n+\tint regnum = xt_true_regnum (op);\n+\tif (letter == 'D')\n+\t  regnum++;\n+\tfprintf (file, \"%s\", reg_names[regnum]);\n+\tbreak;\n+      }\n+\n+    case MEM:\n+        /*\n+\t * For a volatile memory reference, emit a MEMW before the\n+\t * load or store.\n+\t */\n+ \tif (letter == 'v')\n+\t  {\n+\t    if (MEM_VOLATILE_P (op) && TARGET_SERIALIZE_VOLATILE)\n+\t      fprintf (file, \"memw\\n\\t\");\n+\t    break;\n+\t  }\n+ \telse if (letter == 'N')\n+\t  op = adjust_address (op, GET_MODE (op), 4);\n+\n+\toutput_address (XEXP (op, 0));\n+\tbreak;\n+\n+    case CONST_INT:\n+      switch (letter)\n+\t{\n+\tcase 'K':\n+\t  {\n+\t    int num_bits = 0;\n+\t    unsigned val = INTVAL (op);\n+\t    while (val & 1)\n+\t      {\n+\t\tnum_bits += 1;\n+\t\tval = val >> 1;\n+\t      }\n+\t    if ((val != 0) || (num_bits == 0) || (num_bits > 16))\n+\t      fatal_insn (\"invalid mask\", op);\n+\n+\t    fprintf (file, \"%d\", num_bits);\n+\t    break;\n+\t  }\n+\n+\tcase 'L':\n+\t  fprintf (file, \"%d\", (32 - INTVAL (op)) & 0x1f);\n+\t  break;\n+\n+\tcase 'R':\n+\t  fprintf (file, \"%d\", INTVAL (op) & 0x1f);\n+\t  break;\n+\n+\tcase 'x':\n+\t  printx (file, INTVAL (op));\n+\t  break;\n+\n+\tcase 'd':\n+\tdefault:\n+\t  fprintf (file, \"%d\", INTVAL (op));\n+\t  break;\n+\n+\t}\n+      break;\n+\n+    default:\n+      output_addr_const (file, op);\n+    }\n+}\n+\n+\n+/* A C compound statement to output to stdio stream STREAM the\n+   assembler syntax for an instruction operand that is a memory\n+   reference whose address is ADDR.  ADDR is an RTL expression.\n+\n+   On some machines, the syntax for a symbolic address depends on\n+   the section that the address refers to.  On these machines,\n+   define the macro 'ENCODE_SECTION_INFO' to store the information\n+   into the 'symbol_ref', and then check for it here.  */\n+\n+void\n+print_operand_address (file, addr)\n+     FILE *file;\n+     rtx addr;\n+{\n+  if (!addr)\n+    error (\"PRINT_OPERAND_ADDRESS, null pointer\");\n+\n+  switch (GET_CODE (addr))\n+    {\n+    default:\n+      fatal_insn (\"invalid address\", addr);\n+      break;\n+\n+    case REG:\n+      fprintf (file, \"%s, 0\", reg_names [REGNO (addr)]);\n+      break;\n+\n+    case PLUS:\n+      {\n+\trtx reg = (rtx)0;\n+\trtx offset = (rtx)0;\n+\trtx arg0 = XEXP (addr, 0);\n+\trtx arg1 = XEXP (addr, 1);\n+\n+\tif (GET_CODE (arg0) == REG)\n+\t  {\n+\t    reg = arg0;\n+\t    offset = arg1;\n+\t  }\n+\telse if (GET_CODE (arg1) == REG)\n+\t  {\n+\t    reg = arg1;\n+\t    offset = arg0;\n+\t  }\n+\telse\n+\t  fatal_insn (\"no register in address\", addr);\n+\n+\tif (CONSTANT_P (offset))\n+\t  {\n+\t    fprintf (file, \"%s, \", reg_names [REGNO (reg)]);\n+\t    output_addr_const (file, offset);\n+\t  }\n+\telse\n+\t  fatal_insn (\"address offset not a constant\", addr);\n+      }\n+      break;\n+\n+    case LABEL_REF:\n+    case SYMBOL_REF:\n+    case CONST_INT:\n+    case CONST:\n+      output_addr_const (file, addr);\n+      break;\n+    }\n+}\n+\n+\n+/* Emit either a label, .comm, or .lcomm directive. */\n+\n+void\n+xtensa_declare_object (file, name, init_string, final_string, size)\n+     FILE *file;\n+     char *name;\n+     char *init_string;\n+     char *final_string;\n+     int size;\n+{\n+  fputs (init_string, file);\t\t/* \"\", \"\\t.comm\\t\", or \"\\t.lcomm\\t\" */\n+  assemble_name (file, name);\n+  fprintf (file, final_string, size);\t/* \":\\n\", \",%u\\n\", \",%u\\n\" */\n+}\n+\n+\n+void\n+xtensa_output_literal (file, x, mode, labelno)\n+     FILE *file;\n+     rtx x;\n+     enum machine_mode mode;\n+     int labelno;\n+{\n+  long value_long[2];\n+  union real_extract u;\n+  int size;\n+\n+  fprintf (file, \"\\t.literal .LC%u, \", (unsigned) labelno);\n+\n+  switch (GET_MODE_CLASS (mode))\n+    {\n+    case MODE_FLOAT:\n+      if (GET_CODE (x) != CONST_DOUBLE)\n+\tabort ();\n+\n+      memcpy ((char *) &u, (char *) &CONST_DOUBLE_LOW (x), sizeof u);\n+      switch (mode)\n+\t{\n+\tcase SFmode:\n+\t  REAL_VALUE_TO_TARGET_SINGLE (u.d, value_long[0]);\n+\t  fprintf (file, \"0x%08lx\\t\\t# %.12g (float)\\n\", value_long[0], u.d);\n+\t  break;\n+\n+\tcase DFmode:\n+\t  REAL_VALUE_TO_TARGET_DOUBLE (u.d, value_long);\n+\t  fprintf (file, \"0x%08lx, 0x%08lx # %.20g (double)\\n\",\n+\t\t   value_long[0], value_long[1], u.d);\n+\t  break;\n+\n+\tdefault:\n+\t  abort ();\n+\t}\n+\n+      break;\n+\n+    case MODE_INT:\n+    case MODE_PARTIAL_INT:\n+      size = GET_MODE_SIZE (mode);\n+      if (size == 4)\n+\t{\n+\t  output_addr_const (file, x);\n+\t  fputs (\"\\n\", file);\n+\t}\n+      else if (size == 8)\n+\t{\n+\t  output_addr_const (file, operand_subword (x, 0, 0, DImode));\n+\t  fputs (\", \", file);\n+\t  output_addr_const (file, operand_subword (x, 1, 0, DImode));\n+\t  fputs (\"\\n\", file);\n+\t}\n+      else\n+\tabort ();\n+      break;\n+\n+    default:\n+      abort ();\n+    }\n+}\n+\n+\n+/* Return the bytes needed to compute the frame pointer from the current\n+   stack pointer. */\n+\n+#define STACK_BYTES (STACK_BOUNDARY / BITS_PER_UNIT)\n+#define XTENSA_STACK_ALIGN(LOC) (((LOC) + STACK_BYTES-1) & ~(STACK_BYTES-1))\n+\n+long\n+compute_frame_size (size)\n+     int size;\t\t\t/* # of var. bytes allocated */\n+{\n+  /* add space for the incoming static chain value */\n+  if (current_function_needs_context)\n+    size += (1 * UNITS_PER_WORD);\n+\n+  xtensa_current_frame_size =\n+    XTENSA_STACK_ALIGN (size\n+\t\t\t+ current_function_outgoing_args_size\n+\t\t\t+ (WINDOW_SIZE * UNITS_PER_WORD));\n+  return xtensa_current_frame_size;\n+}\n+\n+\n+int\n+xtensa_frame_pointer_required ()\n+{\n+  /* The code to expand builtin_frame_addr and builtin_return_addr\n+     currently uses the hard_frame_pointer instead of frame_pointer.\n+     This seems wrong but maybe it's necessary for other architectures.\n+     This function is derived from the i386 code. */\n+\n+  if (cfun->machine->accesses_prev_frame)\n+    return 1;\n+\n+  return 0;\n+}\n+\n+\n+void\n+xtensa_reorg (first)\n+    rtx first;\n+{\n+  rtx insn, set_frame_ptr_insn = 0;\n+    \n+  unsigned long tsize = compute_frame_size (get_frame_size ());\n+  if (tsize < (1 << (12+3)))\n+    frame_size_const = 0;\n+  else\n+    {\n+      frame_size_const = force_const_mem (SImode, GEN_INT (tsize - 16));;\n+\n+      /* make sure the constant is used so it doesn't get eliminated\n+\t from the constant pool */\n+      emit_insn_before (gen_rtx_USE (SImode, frame_size_const), first);\n+    }\n+\n+  if (!frame_pointer_needed)\n+    return;\n+\n+  /* Search all instructions, looking for the insn that sets up the\n+     frame pointer.  This search will fail if the function does not\n+     have an incoming argument in $a7, but in that case, we can just\n+     set up the frame pointer at the very beginning of the\n+     function. */\n+\n+  for (insn = first; insn; insn = NEXT_INSN (insn))\n+    {\n+      rtx pat;\n+\n+      if (!INSN_P (insn))\n+\tcontinue;\n+\n+      pat = PATTERN (insn);\n+      if (GET_CODE (pat) == UNSPEC_VOLATILE\n+\t  && (XINT (pat, 1) == UNSPECV_SET_FP))\n+\t{\n+\t  set_frame_ptr_insn = insn;\n+\t  break;\n+\t}\n+    }\n+\n+  if (set_frame_ptr_insn)\n+    {\n+      /* for all instructions prior to set_frame_ptr_insn, replace\n+\t hard_frame_pointer references with stack_pointer */\n+      for (insn = first; insn != set_frame_ptr_insn; insn = NEXT_INSN (insn))\n+\t{\n+\t  if (INSN_P (insn))\n+\t    PATTERN (insn) = replace_rtx (copy_rtx (PATTERN (insn)),\n+\t\t\t\t\t  hard_frame_pointer_rtx,\n+\t\t\t\t\t  stack_pointer_rtx);\n+\t}\n+    }\n+  else\n+    {\n+      /* emit the frame pointer move immediately after the NOTE that starts\n+\t the function */\n+      emit_insn_after (gen_movsi (hard_frame_pointer_rtx,\n+\t\t\t\t  stack_pointer_rtx), first);\n+    }\n+}\n+\n+\n+/* Set up the stack and frame (if desired) for the function.  */\n+\n+void\n+xtensa_function_prologue (file, size)\n+     FILE *file;\n+     int size ATTRIBUTE_UNUSED;\n+{\n+  unsigned long tsize = compute_frame_size (get_frame_size ());\n+\n+  if (frame_pointer_needed)\n+    fprintf (file, \"\\t.frame\\ta7, %ld\\n\", tsize);\n+  else\n+    fprintf (file, \"\\t.frame\\tsp, %ld\\n\", tsize);\n+ \n+\n+  if (tsize < (1 << (12+3)))\n+    {\n+      fprintf (file, \"\\tentry\\tsp, %ld\\n\", tsize);\n+    }\n+  else\n+    {\n+      fprintf (file, \"\\tentry\\tsp, 16\\n\");\n+\n+      /* use a8 as a temporary since a0-a7 may be live */\n+      fprintf (file, \"\\tl32r\\ta8, \");\n+      print_operand (file, frame_size_const, 0);\n+      fprintf (file, \"\\n\\tsub\\ta8, sp, a8\\n\");\n+      fprintf (file, \"\\tmovsp\\tsp, a8\\n\");\n+    }\n+}\n+\n+\n+/* Do any necessary cleanup after a function to restore\n+   stack, frame, and regs. */\n+\n+void\n+xtensa_function_epilogue (file, size)\n+     FILE *file;\n+     int size ATTRIBUTE_UNUSED;\n+{\n+  rtx insn = get_last_insn ();\n+  /* If the last insn was a BARRIER, we don't have to write anything. */\n+  if (GET_CODE (insn) == NOTE)\n+    insn = prev_nonnote_insn (insn);\n+  if (insn == 0 || GET_CODE (insn) != BARRIER)\n+    fprintf (file, TARGET_DENSITY ? \"\\tretw.n\\n\" : \"\\tretw\\n\");\n+\n+  xtensa_current_frame_size = 0;\n+}\n+\n+\n+/* Create the va_list data type.\n+   This structure is set up by __builtin_saveregs.  The __va_reg\n+   field points to a stack-allocated region holding the contents of the\n+   incoming argument registers.  The __va_ndx field is an index initialized\n+   to the position of the first unnamed (variable) argument.  This same index\n+   is also used to address the arguments passed in memory.  Thus, the\n+   __va_stk field is initialized to point to the position of the first\n+   argument in memory offset to account for the arguments passed in\n+   registers.  E.G., if there are 6 argument registers, and each register is\n+   4 bytes, then __va_stk is set to $sp - (6 * 4); then __va_reg[N*4]\n+   references argument word N for 0 <= N < 6, and __va_stk[N*4] references\n+   argument word N for N >= 6. */\n+\n+tree\n+xtensa_build_va_list (void)\n+{\n+  tree f_stk, f_reg, f_ndx, record;\n+\n+  record = make_node (RECORD_TYPE);\n+\n+  f_stk = build_decl (FIELD_DECL, get_identifier (\"__va_stk\"),\n+\t\t      ptr_type_node);\n+  f_reg = build_decl (FIELD_DECL, get_identifier (\"__va_reg\"),\n+\t\t      ptr_type_node);\n+  f_ndx = build_decl (FIELD_DECL, get_identifier (\"__va_ndx\"),\n+\t\t      integer_type_node);\n+\n+  DECL_FIELD_CONTEXT (f_stk) = record;\n+  DECL_FIELD_CONTEXT (f_reg) = record;\n+  DECL_FIELD_CONTEXT (f_ndx) = record;\n+\n+  TYPE_FIELDS (record) = f_stk;\n+  TREE_CHAIN (f_stk) = f_reg;\n+  TREE_CHAIN (f_reg) = f_ndx;\n+\n+  layout_type (record);\n+  return record;\n+}\n+\n+\n+/* Save the incoming argument registers on the stack.  Returns the\n+   address of the saved registers. */\n+\n+rtx\n+xtensa_builtin_saveregs ()\n+{\n+  rtx gp_regs, dest;\n+  int arg_words = current_function_arg_words;\n+  int gp_left = MAX_ARGS_IN_REGISTERS - arg_words;\n+  int i;\n+\n+  if (gp_left == 0)\n+    return const0_rtx;\n+\n+  /* allocate the general-purpose register space */\n+  gp_regs = assign_stack_local\n+    (BLKmode, MAX_ARGS_IN_REGISTERS * UNITS_PER_WORD, -1);\n+  MEM_IN_STRUCT_P (gp_regs) = 1;\n+  RTX_UNCHANGING_P (gp_regs) = 1;\n+  RTX_UNCHANGING_P (XEXP (gp_regs, 0)) = 1;\n+\n+  /* Now store the incoming registers.  */\n+  dest = change_address (gp_regs, SImode,\n+\t\t\t plus_constant (XEXP (gp_regs, 0),\n+\t\t\t\t\targ_words * UNITS_PER_WORD));\n+\n+  /* Note: Don't use move_block_from_reg() here because the incoming\n+     argument in a7 cannot be represented by hard_frame_pointer_rtx.\n+     Instead, call gen_raw_REG() directly so that we get a distinct\n+     instance of (REG:SI 7). */\n+  for (i = 0; i < gp_left; i++)\n+    {\n+      emit_move_insn (operand_subword (dest, i, 1, BLKmode),\n+\t\t      gen_raw_REG (SImode, GP_ARG_FIRST + arg_words + i));\n+    }\n+\n+  return XEXP (gp_regs, 0);\n+}\n+\n+\n+/* Implement `va_start' for varargs and stdarg.  We look at the\n+   current function to fill in an initial va_list. */\n+\n+void\n+xtensa_va_start (stdarg_p, valist, nextarg)\n+     int stdarg_p ATTRIBUTE_UNUSED;\n+     tree valist;\n+     rtx nextarg ATTRIBUTE_UNUSED;\n+{\n+  tree f_stk, stk;\n+  tree f_reg, reg;\n+  tree f_ndx, ndx;\n+  tree t, u;\n+  int arg_words;\n+\n+  arg_words = current_function_args_info.arg_words;\n+\n+  f_stk = TYPE_FIELDS (va_list_type_node);\n+  f_reg = TREE_CHAIN (f_stk);\n+  f_ndx = TREE_CHAIN (f_reg);\n+\n+  stk = build (COMPONENT_REF, TREE_TYPE (f_stk), valist, f_stk);\n+  reg = build (COMPONENT_REF, TREE_TYPE (f_reg), valist, f_reg);\n+  ndx = build (COMPONENT_REF, TREE_TYPE (f_ndx), valist, f_ndx);\n+\n+  /* Call __builtin_saveregs; save the result in __va_reg */\n+  current_function_arg_words = arg_words;\n+  u = make_tree (ptr_type_node, expand_builtin_saveregs ());\n+  t = build (MODIFY_EXPR, ptr_type_node, reg, u);\n+  TREE_SIDE_EFFECTS (t) = 1;\n+  expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n+\n+  /* Set the __va_stk member to $arg_ptr - (size of __va_reg area) */\n+  u = make_tree (ptr_type_node, virtual_incoming_args_rtx);\n+  u = fold (build (PLUS_EXPR, ptr_type_node, u,\n+\t\t   build_int_2 (-MAX_ARGS_IN_REGISTERS * UNITS_PER_WORD, -1)));\n+  t = build (MODIFY_EXPR, ptr_type_node, stk, u);\n+  TREE_SIDE_EFFECTS (t) = 1;\n+  expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n+\n+  /* Set the __va_ndx member. */\n+  u = build_int_2 (arg_words * UNITS_PER_WORD, 0);\n+  t = build (MODIFY_EXPR, integer_type_node, ndx, u);\n+  TREE_SIDE_EFFECTS (t) = 1;\n+  expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n+}\n+\n+\n+/* Implement `va_arg'.  */\n+\n+rtx\n+xtensa_va_arg (valist, type)\n+     tree valist, type;\n+{\n+  tree f_stk, stk;\n+  tree f_reg, reg;\n+  tree f_ndx, ndx;\n+  tree tmp, addr_tree;\n+  rtx array, orig_ndx, r, addr;\n+  HOST_WIDE_INT size, va_size;\n+  rtx lab_false, lab_over, lab_false2;\n+\n+  size = int_size_in_bytes (type);\n+  va_size = (size + UNITS_PER_WORD - 1) & -UNITS_PER_WORD;\n+\n+  f_stk = TYPE_FIELDS (va_list_type_node);\n+  f_reg = TREE_CHAIN (f_stk);\n+  f_ndx = TREE_CHAIN (f_reg);\n+\n+  stk = build (COMPONENT_REF, TREE_TYPE (f_stk), valist, f_stk);\n+  reg = build (COMPONENT_REF, TREE_TYPE (f_reg), valist, f_reg);\n+  ndx = build (COMPONENT_REF, TREE_TYPE (f_ndx), valist, f_ndx);\n+\n+\n+  /* First align __va_ndx to a double word boundary if necessary for this arg:\n+\n+     if (__alignof__ (TYPE) > 4)\n+       (AP).__va_ndx = (((AP).__va_ndx + 7) & -8)\n+  */\n+\n+  if (TYPE_ALIGN (type) > BITS_PER_WORD)\n+    {\n+      tmp = build (PLUS_EXPR, integer_type_node, ndx,\n+\t\t   build_int_2 ((2 * UNITS_PER_WORD) - 1, 0));\n+      tmp = build (BIT_AND_EXPR, integer_type_node, tmp,\n+\t\t   build_int_2 (-2 * UNITS_PER_WORD, -1));\n+      tmp = build (MODIFY_EXPR, integer_type_node, ndx, tmp);\n+      TREE_SIDE_EFFECTS (tmp) = 1;\n+      expand_expr (tmp, const0_rtx, VOIDmode, EXPAND_NORMAL);\n+    }\n+\n+\n+  /* Increment __va_ndx to point past the argument:\n+\n+     orig_ndx = (AP).__va_ndx;\n+     (AP).__va_ndx += __va_size (TYPE);\n+  */\n+\n+  orig_ndx = gen_reg_rtx (SImode);\n+  r = expand_expr (ndx, orig_ndx, SImode, EXPAND_NORMAL);\n+  if (r != orig_ndx)\n+    emit_move_insn (orig_ndx, r);\n+\n+  tmp = build (PLUS_EXPR, integer_type_node, ndx, build_int_2 (va_size, 0));\n+  tmp = build (MODIFY_EXPR, integer_type_node, ndx, tmp);\n+  TREE_SIDE_EFFECTS (tmp) = 1;\n+  expand_expr (tmp, const0_rtx, VOIDmode, EXPAND_NORMAL);\n+\n+\n+  /* Check if the argument is in registers:\n+\n+     if ((AP).__va_ndx <= __MAX_ARGS_IN_REGISTERS * 4)\n+        __array = (AP).__va_reg;\n+  */\n+\n+  lab_false = gen_label_rtx ();\n+  lab_over = gen_label_rtx ();\n+  array = gen_reg_rtx (Pmode);\n+\n+  emit_cmp_and_jump_insns (expand_expr (ndx, NULL_RTX, SImode, EXPAND_NORMAL),\n+\t\t\t   GEN_INT (MAX_ARGS_IN_REGISTERS * UNITS_PER_WORD),\n+\t\t\t   GT, const1_rtx, SImode, 0, lab_false);\n+\n+  r = expand_expr (reg, array, Pmode, EXPAND_NORMAL);\n+  if (r != array)\n+    emit_move_insn (array, r);\n+\n+  emit_jump_insn (gen_jump (lab_over));\n+  emit_barrier ();\n+  emit_label (lab_false);\n+\n+\n+  /* ...otherwise, the argument is on the stack (never split between\n+     registers and the stack -- change __va_ndx if necessary):\n+\n+     else\n+       {\n+\t if (orig_ndx < __MAX_ARGS_IN_REGISTERS * 4)\n+\t     (AP).__va_ndx = __MAX_ARGS_IN_REGISTERS * 4 + __va_size (TYPE);\n+\t __array = (AP).__va_stk;\n+       }\n+  */\n+\n+  lab_false2 = gen_label_rtx ();\n+  emit_cmp_and_jump_insns (orig_ndx,\n+\t\t\t   GEN_INT (MAX_ARGS_IN_REGISTERS * UNITS_PER_WORD),\n+\t\t\t   GE, const1_rtx, SImode, 0, lab_false2);\n+\n+  tmp = build_int_2 ((MAX_ARGS_IN_REGISTERS * UNITS_PER_WORD) + va_size, 0);\n+  tmp = build (MODIFY_EXPR, integer_type_node, ndx, tmp);\n+  TREE_SIDE_EFFECTS (tmp) = 1;\n+  expand_expr (tmp, const0_rtx, VOIDmode, EXPAND_NORMAL);\n+\n+  emit_label (lab_false2);\n+\n+  r = expand_expr (stk, array, Pmode, EXPAND_NORMAL);\n+  if (r != array)\n+    emit_move_insn (array, r);\n+\n+\n+  /* Given the base array pointer (__array) and index to the subsequent\n+     argument (__va_ndx), find the address:\n+\n+     Big-endian:\n+     __array + (AP).__va_ndx - sizeof (TYPE)\n+\n+     Little-endian:\n+     __array + (AP).__va_ndx - __va_size (TYPE)\n+\n+     The results are endian-dependent because values smaller than one word\n+     are aligned differently.\n+  */\n+\n+  emit_label (lab_over);\n+\n+  addr_tree = build (PLUS_EXPR, ptr_type_node,\n+\t\t     make_tree (ptr_type_node, array),\n+\t\t     ndx);\n+  addr_tree = build (PLUS_EXPR, ptr_type_node,\n+\t\t     addr_tree,\n+\t\t     build_int_2 (BYTES_BIG_ENDIAN\n+\t\t\t\t  && size < (PARM_BOUNDARY / BITS_PER_UNIT)\n+\t\t\t\t  ? -size\n+\t\t\t\t  : -va_size, -1));\n+  addr = expand_expr (addr_tree, NULL_RTX, Pmode, EXPAND_NORMAL);\n+  addr = copy_to_reg (addr);\n+  return addr;\n+}\n+\n+\n+enum reg_class\n+xtensa_secondary_reload_class (class, mode, x, isoutput)\n+     enum reg_class class;\n+     enum machine_mode mode ATTRIBUTE_UNUSED;\n+     rtx x;\n+     int isoutput;\n+{\n+  int regno;\n+\n+  if (GET_CODE (x) == SIGN_EXTEND)\n+    x = XEXP (x, 0);\n+  regno = xt_true_regnum (x);\n+\n+  if (!isoutput)\n+    {\n+      if (class == FP_REGS && constantpool_mem_p (x))\n+\treturn GR_REGS;\n+    }\n+\n+  if (ACC_REG_P (regno))\n+    return (class == GR_REGS ? NO_REGS : GR_REGS);\n+  if (class == ACC_REG)\n+    return (GP_REG_P (regno) ? NO_REGS : GR_REGS);\n+\n+  return NO_REGS;\n+}\n+\n+\n+void\n+order_regs_for_local_alloc ()\n+{\n+  if (!leaf_function_p ())\n+    {\n+      memcpy (reg_alloc_order, reg_nonleaf_alloc_order,\n+\t      FIRST_PSEUDO_REGISTER * sizeof (int));\n+    }\n+  else\n+    {\n+      int i, num_arg_regs;\n+      int nxt = 0;\n+\n+      /* use the AR registers in increasing order (skipping a0 and a1)\n+\t but save the incoming argument registers for a last resort */\n+      num_arg_regs = current_function_args_info.arg_words;\n+      if (num_arg_regs > MAX_ARGS_IN_REGISTERS)\n+\tnum_arg_regs = MAX_ARGS_IN_REGISTERS;\n+      for (i = GP_ARG_FIRST; i < 16 - num_arg_regs; i++)\n+\treg_alloc_order[nxt++] = i + num_arg_regs;\n+      for (i = 0; i < num_arg_regs; i++)\n+\treg_alloc_order[nxt++] = GP_ARG_FIRST + i;\n+\n+      /* list the FP registers in order for now */\n+      for (i = 0; i < 16; i++)\n+\treg_alloc_order[nxt++] = FP_REG_FIRST + i;\n+\n+      /* GCC requires that we list *all* the registers.... */\n+      reg_alloc_order[nxt++] = 0;\t/* a0 = return address */\n+      reg_alloc_order[nxt++] = 1;\t/* a1 = stack pointer */\n+      reg_alloc_order[nxt++] = 16;\t/* pseudo frame pointer */\n+      reg_alloc_order[nxt++] = 17;\t/* pseudo arg pointer */\n+\n+      /* list the coprocessor registers in order */\n+      for (i = 0; i < BR_REG_NUM; i++)\n+\treg_alloc_order[nxt++] = BR_REG_FIRST + i;\n+\n+      reg_alloc_order[nxt++] = ACC_REG_FIRST;\t/* MAC16 accumulator */\n+    }\n+}\n+\n+\n+/* A customized version of reg_overlap_mentioned_p that only looks for\n+   references to a7 (as opposed to hard_frame_pointer_rtx). */\n+\n+int\n+a7_overlap_mentioned_p (x)\n+     rtx x;\n+{\n+  int i, j;\n+  unsigned int x_regno;\n+  const char *fmt;\n+\n+  if (GET_CODE (x) == REG)\n+    {\n+      x_regno = REGNO (x);\n+      return (x != hard_frame_pointer_rtx\n+\t      && x_regno < A7_REG + 1\n+\t      && x_regno + HARD_REGNO_NREGS (A7_REG, GET_MODE (x)) > A7_REG);\n+    }\n+\n+  if (GET_CODE (x) == SUBREG\n+      && GET_CODE (SUBREG_REG (x)) == REG\n+      && REGNO (SUBREG_REG (x)) < FIRST_PSEUDO_REGISTER)\n+    {\n+      x_regno = subreg_regno (x);\n+      return (SUBREG_REG (x) != hard_frame_pointer_rtx\n+\t      && x_regno < A7_REG + 1\n+\t      && x_regno + HARD_REGNO_NREGS (A7_REG, GET_MODE (x)) > A7_REG);\n+    }\n+\n+  /* X does not match, so try its subexpressions.  */\n+  fmt = GET_RTX_FORMAT (GET_CODE (x));\n+  for (i = GET_RTX_LENGTH (GET_CODE (x)) - 1; i >= 0; i--)\n+    {\n+      if (fmt[i] == 'e')\n+\t{\n+\t  if (a7_overlap_mentioned_p (XEXP (x, i)))\n+\t    return 1;\n+\t}\n+      else if (fmt[i] == 'E')\n+\t{\n+\t  for (j = XVECLEN (x, i) - 1; j >=0; j--)\n+\t    if (a7_overlap_mentioned_p (XVECEXP (x, i, j)))\n+\t      return 1;\n+\t}\n+    }\n+\n+  return 0;\n+}"}, {"sha": "0cfbdb24d7e650a6d74909fdaccd20ed7355f6e7", "filename": "gcc/config/xtensa/xtensa.h", "status": "added", "additions": 1701, "deletions": 0, "changes": 1701, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/039843087a884e96058fd0fcde72339974d49e81/gcc%2Fconfig%2Fxtensa%2Fxtensa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/039843087a884e96058fd0fcde72339974d49e81/gcc%2Fconfig%2Fxtensa%2Fxtensa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Fxtensa.h?ref=039843087a884e96058fd0fcde72339974d49e81", "patch": "@@ -0,0 +1,1701 @@\n+/* Definitions of Tensilica's Xtensa target machine for GNU compiler.\n+   Copyright (C) 2001 Free Software Foundation, Inc.\n+   Contributed by Bob Wilson (bwilson@tensilica.com) at Tensilica.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n+02111-1307, USA.  */\n+\n+/* Get Xtensa configuration settings */\n+#include \"xtensa/xtensa-config.h\"\n+\n+/* Standard GCC variables that we reference.  */\n+extern int current_function_calls_alloca;\n+extern int target_flags;\n+extern int optimize;\n+\n+/* External variables defined in xtensa.c.  */\n+\n+/* comparison type */\n+enum cmp_type {\n+  CMP_SI,\t\t\t\t/* four byte integers */\n+  CMP_DI,\t\t\t\t/* eight byte integers */\n+  CMP_SF,\t\t\t\t/* single precision floats */\n+  CMP_DF,\t\t\t\t/* double precision floats */\n+  CMP_MAX\t\t\t\t/* max comparison type */\n+};\n+\n+extern struct rtx_def * branch_cmp[2];\t/* operands for compare */\n+extern enum cmp_type branch_type;\t/* what type of branch to use */\n+extern unsigned xtensa_current_frame_size;\n+\n+/* Run-time compilation parameters selecting different hardware subsets.  */\n+\n+#define MASK_BIG_ENDIAN\t\t0x00000001\t/* big or little endian */\n+#define MASK_DENSITY\t\t0x00000002\t/* code density option */\n+#define MASK_MAC16\t\t0x00000004\t/* MAC16 option */\n+#define MASK_MUL16\t\t0x00000008\t/* 16-bit integer multiply */\n+#define MASK_MUL32\t\t0x00000010\t/* integer multiply/divide */\n+#define MASK_DIV32\t\t0x00000020\t/* integer multiply/divide */\n+#define MASK_NSA\t\t0x00000040\t/* nsa instruction option */\n+#define MASK_MINMAX\t\t0x00000080\t/* min/max instructions */\n+#define MASK_SEXT\t\t0x00000100\t/* sign extend insn option */\n+#define MASK_BOOLEANS\t\t0x00000200\t/* boolean register option */\n+#define MASK_HARD_FLOAT\t\t0x00000400\t/* floating-point option */\n+#define MASK_HARD_FLOAT_DIV\t0x00000800\t/* floating-point divide */\n+#define MASK_HARD_FLOAT_RECIP\t0x00001000\t/* floating-point reciprocal */\n+#define MASK_HARD_FLOAT_SQRT\t0x00002000\t/* floating-point sqrt */\n+#define MASK_HARD_FLOAT_RSQRT\t0x00004000\t/* floating-point recip sqrt */\n+#define MASK_NO_FUSED_MADD\t0x00008000\t/* avoid f-p mul/add */\n+#define MASK_SERIALIZE_VOLATILE 0x00010000\t/* serialize volatile refs */\n+\n+/* Macros used in the machine description to test the flags.  */\n+\n+#define TARGET_BIG_ENDIAN\t(target_flags & MASK_BIG_ENDIAN)\n+#define TARGET_DENSITY\t\t(target_flags & MASK_DENSITY)\n+#define TARGET_MAC16\t\t(target_flags & MASK_MAC16)\n+#define TARGET_MUL16\t\t(target_flags & MASK_MUL16)\n+#define TARGET_MUL32\t\t(target_flags & MASK_MUL32)\n+#define TARGET_DIV32\t\t(target_flags & MASK_DIV32)\n+#define TARGET_NSA\t\t(target_flags & MASK_NSA)\n+#define TARGET_MINMAX\t\t(target_flags & MASK_MINMAX)\n+#define TARGET_SEXT\t\t(target_flags & MASK_SEXT)\n+#define TARGET_BOOLEANS\t\t(target_flags & MASK_BOOLEANS)\n+#define TARGET_HARD_FLOAT\t(target_flags & MASK_HARD_FLOAT)\n+#define TARGET_HARD_FLOAT_DIV\t(target_flags & MASK_HARD_FLOAT_DIV)\n+#define TARGET_HARD_FLOAT_RECIP\t(target_flags & MASK_HARD_FLOAT_RECIP)\n+#define TARGET_HARD_FLOAT_SQRT\t(target_flags & MASK_HARD_FLOAT_SQRT)\n+#define TARGET_HARD_FLOAT_RSQRT\t(target_flags & MASK_HARD_FLOAT_RSQRT)\n+#define TARGET_NO_FUSED_MADD\t(target_flags & MASK_NO_FUSED_MADD)\n+#define TARGET_SERIALIZE_VOLATILE (target_flags & MASK_SERIALIZE_VOLATILE)\n+\n+/* Default target_flags if no switches are specified  */\n+\n+#define TARGET_DEFAULT (\t\t\t\t\t\t\\\n+  (XCHAL_HAVE_BE\t? MASK_BIG_ENDIAN : 0) |\t\t\t\\\n+  (XCHAL_HAVE_DENSITY\t? MASK_DENSITY : 0) |\t\t\t\t\\\n+  (XCHAL_HAVE_MAC16\t? MASK_MAC16 : 0) |\t\t\t\t\\\n+  (XCHAL_HAVE_MUL16\t? MASK_MUL16 : 0) |\t\t\t\t\\\n+  (XCHAL_HAVE_MUL32\t? MASK_MUL32 : 0) |\t\t\t\t\\\n+  (XCHAL_HAVE_DIV32\t? MASK_DIV32 : 0) |\t\t\t\t\\\n+  (XCHAL_HAVE_NSA\t? MASK_NSA : 0) |\t\t\t\t\\\n+  (XCHAL_HAVE_MINMAX\t? MASK_MINMAX : 0) |\t\t\t\t\\\n+  (XCHAL_HAVE_SEXT\t? MASK_SEXT : 0) |\t\t\t\t\\\n+  (XCHAL_HAVE_BOOLEANS\t? MASK_BOOLEANS : 0) |\t\t\t\t\\\n+  (XCHAL_HAVE_FP\t? MASK_HARD_FLOAT : 0) |\t\t\t\\\n+  (XCHAL_HAVE_FP_DIV\t? MASK_HARD_FLOAT_DIV : 0) |\t\t\t\\\n+  (XCHAL_HAVE_FP_RECIP\t? MASK_HARD_FLOAT_RECIP : 0) |\t\t\t\\\n+  (XCHAL_HAVE_FP_SQRT\t? MASK_HARD_FLOAT_SQRT : 0) |\t\t\t\\\n+  (XCHAL_HAVE_FP_RSQRT\t? MASK_HARD_FLOAT_RSQRT : 0) |\t\t\t\\\n+  MASK_SERIALIZE_VOLATILE)\n+\n+/* Macro to define tables used to set the flags.  */\n+\n+#define TARGET_SWITCHES\t\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  {\"big-endian\",\t\tMASK_BIG_ENDIAN,\t\t\t\\\n+    N_(\"Use big-endian byte order\")},\t\t\t\t\t\\\n+  {\"little-endian\",\t\t-MASK_BIG_ENDIAN,\t\t\t\\\n+    N_(\"Use little-endian byte order\")},\t\t\t\t\\\n+  {\"density\",\t\t\tMASK_DENSITY,\t\t\t\t\\\n+    N_(\"Use the Xtensa code density option\")},\t\t\t\t\\\n+  {\"no-density\",\t\t-MASK_DENSITY,\t\t\t\t\\\n+    N_(\"Do not use the Xtensa code density option\")},\t\t\t\\\n+  {\"mac16\",\t\t\tMASK_MAC16,\t\t\t\t\\\n+    N_(\"Use the Xtensa MAC16 option\")},\t\t\t\t\t\\\n+  {\"no-mac16\",\t\t\t-MASK_MAC16,\t\t\t\t\\\n+    N_(\"Do not use the Xtensa MAC16 option\")},\t\t\t\t\\\n+  {\"mul16\",\t\t\tMASK_MUL16,\t\t\t\t\\\n+    N_(\"Use the Xtensa MUL16 option\")},\t\t\t\t\t\\\n+  {\"no-mul16\",\t\t\t-MASK_MUL16,\t\t\t\t\\\n+    N_(\"Do not use the Xtensa MUL16 option\")},\t\t\t\t\\\n+  {\"mul32\",\t\t\tMASK_MUL32,\t\t\t\t\\\n+    N_(\"Use the Xtensa MUL32 option\")},\t\t\t\t\t\\\n+  {\"no-mul32\",\t\t\t-MASK_MUL32,\t\t\t\t\\\n+    N_(\"Do not use the Xtensa MUL32 option\")},\t\t\t\t\\\n+  {\"div32\",\t\t\tMASK_DIV32,\t\t\t\t\\\n+    0 /* undocumented */},\t\t\t\t\t\t\\\n+  {\"no-div32\",\t\t\t-MASK_DIV32,\t\t\t\t\\\n+    0 /* undocumented */},\t\t\t\t\t\t\\\n+  {\"nsa\",\t\t\tMASK_NSA,\t\t\t\t\\\n+    N_(\"Use the Xtensa NSA option\")},\t\t\t\t\t\\\n+  {\"no-nsa\",\t\t\t-MASK_NSA,\t\t\t\t\\\n+    N_(\"Do not use the Xtensa NSA option\")},\t\t\t\t\\\n+  {\"minmax\",\t\t\tMASK_MINMAX,\t\t\t\t\\\n+    N_(\"Use the Xtensa MIN/MAX option\")},\t\t\t\t\\\n+  {\"no-minmax\",\t\t\t-MASK_MINMAX,\t\t\t\t\\\n+    N_(\"Do not use the Xtensa MIN/MAX option\")},\t\t\t\\\n+  {\"sext\",\t\t\tMASK_SEXT,\t\t\t\t\\\n+    N_(\"Use the Xtensa SEXT option\")},\t\t\t\t\t\\\n+  {\"no-sext\",\t\t\t-MASK_SEXT,\t\t\t\t\\\n+    N_(\"Do not use the Xtensa SEXT option\")},\t\t\t\t\\\n+  {\"booleans\",\t\t\tMASK_BOOLEANS,\t\t\t\t\\\n+    N_(\"Use the Xtensa boolean register option\")},\t\t\t\\\n+  {\"no-booleans\",\t\t-MASK_BOOLEANS,\t\t\t\t\\\n+    N_(\"Do not use the Xtensa boolean register option\")},\t\t\\\n+  {\"hard-float\",\t\tMASK_HARD_FLOAT,\t\t\t\\\n+    N_(\"Use the Xtensa floating-point unit\")},\t\t\t\t\\\n+  {\"soft-float\",\t\t-MASK_HARD_FLOAT,\t\t\t\\\n+    N_(\"Do not use the Xtensa floating-point unit\")},\t\t\t\\\n+  {\"hard-float-div\",\t\tMASK_HARD_FLOAT_DIV,\t\t\t\\\n+    0 /* undocumented */},\t\t\t\t\t\t\\\n+  {\"no-hard-float-div\",\t\t-MASK_HARD_FLOAT_DIV,\t\t\t\\\n+    0 /* undocumented */},\t\t\t\t\t\t\\\n+  {\"hard-float-recip\",\t\tMASK_HARD_FLOAT_RECIP,\t\t\t\\\n+    0 /* undocumented */},\t\t\t\t\t\t\\\n+  {\"no-hard-float-recip\",\t-MASK_HARD_FLOAT_RECIP,\t\t\t\\\n+    0 /* undocumented */},\t\t\t\t\t\t\\\n+  {\"hard-float-sqrt\",\t\tMASK_HARD_FLOAT_SQRT,\t\t\t\\\n+    0 /* undocumented */},\t\t\t\t\t\t\\\n+  {\"no-hard-float-sqrt\",\t-MASK_HARD_FLOAT_SQRT,\t\t\t\\\n+    0 /* undocumented */},\t\t\t\t\t\t\\\n+  {\"hard-float-rsqrt\",\t\tMASK_HARD_FLOAT_RSQRT,\t\t\t\\\n+    0 /* undocumented */},\t\t\t\t\t\t\\\n+  {\"no-hard-float-rsqrt\",\t-MASK_HARD_FLOAT_RSQRT,\t\t\t\\\n+    0 /* undocumented */},\t\t\t\t\t\t\\\n+  {\"no-fused-madd\",\t\tMASK_NO_FUSED_MADD,\t\t\t\\\n+    N_(\"Disable fused multiply/add and multiply/subtract FP instructions\")}, \\\n+  {\"fused-madd\",\t\t-MASK_NO_FUSED_MADD,\t\t\t\\\n+    N_(\"Enable fused multiply/add and multiply/subtract FP instructions\")}, \\\n+  {\"serialize-volatile\",\tMASK_SERIALIZE_VOLATILE,\t\t\\\n+    N_(\"Serialize volatile memory references with MEMW instructions\")},\t\\\n+  {\"no-serialize-volatile\",\t-MASK_SERIALIZE_VOLATILE,\t\t\\\n+    N_(\"Do not serialize volatile memory references with MEMW instructions\")},\\\n+  {\"text-section-literals\",\t0,\t\t\t\t\t\\\n+    N_(\"Intersperse literal pools with code in the text section\")},\t\\\n+  {\"no-text-section-literals\",\t0,\t\t\t\t\t\\\n+    N_(\"Put literal pools in a separate literal section\")},\t\t\\\n+  {\"target-align\",\t\t0,\t\t\t\t\t\\\n+    N_(\"Automatically align branch targets to reduce branch penalties\")}, \\\n+  {\"no-target-align\",\t\t0,\t\t\t\t\t\\\n+    N_(\"Do not automatically align branch targets\")},\t\t\t\\\n+  {\"longcalls\",\t\t\t0,\t\t\t\t\t\\\n+    N_(\"Use indirect CALLXn instructions for large programs\")},\t\t\\\n+  {\"no-longcalls\",\t\t0,\t\t\t\t\t\\\n+    N_(\"Use direct CALLn instructions for fast calls\")},\t\t\\\n+  {\"\",\t\t\t\tTARGET_DEFAULT, 0}\t\t\t\\\n+}\n+\n+\n+#define OVERRIDE_OPTIONS override_options ()\n+\n+#if XCHAL_HAVE_BE\n+#define CPP_ENDIAN_SPEC \"\\\n+  %{mlittle-endian:-D__XTENSA_EL__} \\\n+  %{!mlittle-endian:-D__XTENSA_EB__} \"\n+#else /* !XCHAL_HAVE_BE */\n+#define CPP_ENDIAN_SPEC \"\\\n+  %{mbig-endian:-D__XTENSA_EB__} \\\n+  %{!mbig-endian:-D__XTENSA_EL__} \"\n+#endif /* !XCHAL_HAVE_BE */\n+\n+#if XCHAL_HAVE_FP\n+#define CPP_FLOAT_SPEC \"%{msoft-float:-D__XTENSA_SOFT_FLOAT__}\"\n+#else\n+#define CPP_FLOAT_SPEC \"%{!mhard-float:-D__XTENSA_SOFT_FLOAT__}\"\n+#endif\n+\n+#undef CPP_SPEC\n+#define CPP_SPEC CPP_ENDIAN_SPEC CPP_FLOAT_SPEC\n+\n+/* Define this to set the endianness to use in libgcc2.c, which can\n+   not depend on target_flags.  */\n+#define LIBGCC2_WORDS_BIG_ENDIAN XCHAL_HAVE_BE\n+\n+/* Show we can debug even without a frame pointer.  */\n+#define CAN_DEBUG_WITHOUT_FP\n+\n+\n+/* Target machine storage layout */\n+\n+/* Define in order to support both big and little endian float formats\n+   in the same gcc binary.  */\n+#define REAL_ARITHMETIC\n+\n+/* Define this if most significant bit is lowest numbered\n+   in instructions that operate on numbered bit-fields.  */\n+#define BITS_BIG_ENDIAN (TARGET_BIG_ENDIAN != 0)\n+\n+/* Define this if most significant byte of a word is the lowest numbered. */\n+#define BYTES_BIG_ENDIAN (TARGET_BIG_ENDIAN != 0)\n+\n+/* Define this if most significant word of a multiword number is the lowest. */\n+#define WORDS_BIG_ENDIAN (TARGET_BIG_ENDIAN != 0)\n+\n+/* Number of bits in an addressable storage unit */\n+#define BITS_PER_UNIT 8\n+\n+/* Width in bits of a \"word\", which is the contents of a machine register.  */\n+#define BITS_PER_WORD 32\n+#define MAX_BITS_PER_WORD 32\n+\n+/* Width of a word, in units (bytes).  */\n+#define UNITS_PER_WORD 4\n+#define MIN_UNITS_PER_WORD 4\n+\n+/* Width of a floating point register.  */\n+#define UNITS_PER_FPREG 4\n+\n+/* Size in bits of various types on the target machine.  */\n+#define INT_TYPE_SIZE 32\n+#define MAX_INT_TYPE_SIZE 32\n+#define SHORT_TYPE_SIZE 16\n+#define LONG_TYPE_SIZE 32\n+#define MAX_LONG_TYPE_SIZE 32\n+#define LONG_LONG_TYPE_SIZE 64\n+#define CHAR_TYPE_SIZE BITS_PER_UNIT\n+#define FLOAT_TYPE_SIZE 32\n+#define DOUBLE_TYPE_SIZE 64\n+#define LONG_DOUBLE_TYPE_SIZE 64\n+#define POINTER_SIZE 32\n+\n+/* Tell the preprocessor the maximum size of wchar_t.  */\n+#ifndef MAX_WCHAR_TYPE_SIZE\n+#ifndef WCHAR_TYPE_SIZE\n+#define MAX_WCHAR_TYPE_SIZE MAX_INT_TYPE_SIZE\n+#endif\n+#endif\n+\n+/* Allocation boundary (in *bits*) for storing pointers in memory.  */\n+#define POINTER_BOUNDARY 32\n+\n+/* Allocation boundary (in *bits*) for storing arguments in argument list.  */\n+#define PARM_BOUNDARY 32\n+\n+/* Allocation boundary (in *bits*) for the code of a function.  */\n+#define FUNCTION_BOUNDARY 32\n+\n+/* Alignment of field after 'int : 0' in a structure.  */\n+#define EMPTY_FIELD_BOUNDARY 32\n+\n+/* Every structure's size must be a multiple of this.  */\n+#define STRUCTURE_SIZE_BOUNDARY 8\n+\n+/* There is no point aligning anything to a rounder boundary than this.  */\n+#define BIGGEST_ALIGNMENT 128\n+\n+/* Set this nonzero if move instructions will actually fail to work\n+   when given unaligned data.  */\n+#define STRICT_ALIGNMENT 1\n+\n+/* Promote integer modes smaller than a word to SImode.  Set UNSIGNEDP\n+   for QImode, because there is no 8-bit load from memory with sign\n+   extension.  Otherwise, leave UNSIGNEDP alone, since Xtensa has 16-bit\n+   loads both with and without sign extension.  */\n+#define PROMOTE_MODE(MODE, UNSIGNEDP, TYPE)\t\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    if (GET_MODE_CLASS (MODE) == MODE_INT\t\t\t\t\\\n+\t&& GET_MODE_SIZE (MODE) < UNITS_PER_WORD)\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\tif ((MODE) == QImode)\t\t\t\t\t\t\\\n+\t  (UNSIGNEDP) = 1;\t\t\t\t\t\t\\\n+\t(MODE) = SImode;\t\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+  } while (0)\n+\n+/* The promotion described by `PROMOTE_MODE' should also be done for\n+   outgoing function arguments.  */\n+#define PROMOTE_FUNCTION_ARGS\n+\n+/* The promotion described by `PROMOTE_MODE' should also be done for\n+   the return value of functions.  Note: `FUNCTION_VALUE' must perform\n+   the same promotions done by `PROMOTE_MODE'.  */\n+#define PROMOTE_FUNCTION_RETURN\n+\n+/* Imitate the way many other C compilers handle alignment of\n+   bitfields and the structures that contain them.  */\n+#define PCC_BITFIELD_TYPE_MATTERS 1\n+\n+/* Align string constants and constructors to at least a word boundary.\n+   The typical use of this macro is to increase alignment for string\n+   constants to be word aligned so that 'strcpy' calls that copy\n+   constants can be done inline.  */\n+#define CONSTANT_ALIGNMENT(EXP, ALIGN)\t\t\t\t\t\\\n+  ((TREE_CODE (EXP) == STRING_CST || TREE_CODE (EXP) == CONSTRUCTOR)\t\\\n+   && (ALIGN) < BITS_PER_WORD\t\t\t\t\t\t\\\n+\t? BITS_PER_WORD\t\t\t\t\t\t\t\\\n+\t: (ALIGN))\n+\n+/* Align arrays, unions and records to at least a word boundary.\n+   One use of this macro is to increase alignment of medium-size\n+   data to make it all fit in fewer cache lines.  Another is to\n+   cause character arrays to be word-aligned so that 'strcpy' calls\n+   that copy constants to character arrays can be done inline.  */\n+#undef DATA_ALIGNMENT\n+#define DATA_ALIGNMENT(TYPE, ALIGN)\t\t\t\t\t\\\n+  ((((ALIGN) < BITS_PER_WORD)\t\t\t\t\t\t\\\n+    && (TREE_CODE (TYPE) == ARRAY_TYPE\t\t\t\t\t\\\n+\t|| TREE_CODE (TYPE) == UNION_TYPE\t\t\t\t\\\n+\t|| TREE_CODE (TYPE) == RECORD_TYPE)) ? BITS_PER_WORD : (ALIGN))\n+\n+/* An argument declared as 'char' or 'short' in a prototype should\n+   actually be passed as an 'int'.  */\n+#define PROMOTE_PROTOTYPES 1\n+\n+/* Operations between registers always perform the operation\n+   on the full register even if a narrower mode is specified.  */\n+#define WORD_REGISTER_OPERATIONS\n+\n+/* Xtensa loads are zero-extended by default.  */\n+#define LOAD_EXTEND_OP(MODE) ZERO_EXTEND\n+\n+/* Standard register usage.  */\n+\n+/* Number of actual hardware registers.\n+   The hardware registers are assigned numbers for the compiler\n+   from 0 to just below FIRST_PSEUDO_REGISTER.\n+   All registers that the compiler knows about must be given numbers,\n+   even those that are not normally considered general registers.\n+\n+   The fake frame pointer and argument pointer will never appear in\n+   the generated code, since they will always be eliminated and replaced\n+   by either the stack pointer or the hard frame pointer.\n+\n+   0 - 15\tAR[0] - AR[15]\n+   16\t\tFRAME_POINTER (fake = initial sp)\n+   17\t\tARG_POINTER (fake = initial sp + framesize)\n+   18           LOOP_COUNT (loop count special register)\n+   18\t\tBR[0] for floating-point CC\n+   19 - 34\tFR[0] - FR[15]\n+   35\t\tMAC16 accumulator */\n+\n+#define FIRST_PSEUDO_REGISTER 36\n+\n+/* Return the stabs register number to use for REGNO. */\n+#define DBX_REGISTER_NUMBER(REGNO) xtensa_dbx_register_number (REGNO)\n+\n+/* 1 for registers that have pervasive standard uses\n+   and are not available for the register allocator. */\n+#define FIXED_REGISTERS\t\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\t\t\t\\\n+  1, 1, 0,\t\t\t\t\t\t\t\t\\\n+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\t\t\t\\\n+  0,\t\t\t\t\t\t\t\t\t\\\n+}\n+\n+/* 1 for registers not available across function calls.\n+   These must include the FIXED_REGISTERS and also any\n+   registers that can be used without being saved.\n+   The latter must include the registers where values are returned\n+   and the register where structure-value addresses are passed.\n+   Aside from that, you can include as many other registers as you like.  */\n+#define CALL_USED_REGISTERS\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1,\t\t\t\\\n+  1, 1, 1,\t\t\t\t\t\t\t\t\\\n+  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\t\t\t\\\n+  1,\t\t\t\t\t\t\t\t\t\\\n+}\n+\n+/* For non-leaf procedures on Xtensa processors, the allocation order\n+   is as specified below by REG_ALLOC_ORDER.  For leaf procedures, we\n+   want to use the lowest numbered registers first to minimize\n+   register window overflows.  However, local-alloc is not smart\n+   enough to consider conflicts with incoming arguments.  If an\n+   incoming argument in a2 is live throughout the function and\n+   local-alloc decides to use a2, then the incoming argument must\n+   either be spilled or copied to another register.  To get around\n+   this, we define ORDER_REGS_FOR_LOCAL_ALLOC to redefine\n+   reg_alloc_order for leaf functions such that lowest numbered\n+   registers are used first with the exception that the incoming\n+   argument registers are not used until after other register choices\n+   have been exhausted.  */\n+\n+#define REG_ALLOC_ORDER \\\n+{  8,  9, 10, 11, 12, 13, 14, 15,  7,  6,  5,  4,  3,  2, 19, \\\n+  20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, \\\n+   0,  1, 16, 17, \\\n+  36, \\\n+}\n+\n+#define ORDER_REGS_FOR_LOCAL_ALLOC order_regs_for_local_alloc ()\n+\n+/* For Xtensa, the only point of this is to prevent GCC from otherwise\n+   giving preference to call-used registers.  To minimize window\n+   overflows for the AR registers, we want to give preference to the\n+   lower-numbered AR registers.  For other register files, which are\n+   not windowed, we still prefer call-used registers, if there are any. */\n+extern const char xtensa_leaf_regs[FIRST_PSEUDO_REGISTER];\n+#define LEAF_REGISTERS xtensa_leaf_regs\n+\n+/* For Xtensa, no remapping is necessary, but this macro must be\n+   defined if LEAF_REGISTERS is defined. */\n+#define LEAF_REG_REMAP(REGNO) (REGNO)\n+\n+/* this must be declared if LEAF_REGISTERS is set */\n+extern int leaf_function;\n+\n+/* Internal macros to classify a register number. */\n+\n+/* 16 address registers + fake registers */\n+#define GP_REG_FIRST 0\n+#define GP_REG_LAST  17\n+#define GP_REG_NUM   (GP_REG_LAST - GP_REG_FIRST + 1)\n+\n+/* Special registers */\n+#define SPEC_REG_FIRST 18\n+#define SPEC_REG_LAST  18\n+#define SPEC_REG_NUM   (SPEC_REG_LAST - SPEC_REG_FIRST + 1)\n+\n+/* Coprocessor registers */\n+#define BR_REG_FIRST 18\n+#define BR_REG_LAST  18 \n+#define BR_REG_NUM   (BR_REG_LAST - BR_REG_FIRST + 1)\n+\n+/* 16 floating-point registers */\n+#define FP_REG_FIRST 19\n+#define FP_REG_LAST  34\n+#define FP_REG_NUM   (FP_REG_LAST - FP_REG_FIRST + 1)\n+\n+/* MAC16 accumulator */\n+#define ACC_REG_FIRST 35\n+#define ACC_REG_LAST 35\n+#define ACC_REG_NUM  (ACC_REG_LAST - ACC_REG_FIRST + 1)\n+\n+#define GP_REG_P(REGNO) ((unsigned) ((REGNO) - GP_REG_FIRST) < GP_REG_NUM)\n+#define BR_REG_P(REGNO) ((unsigned) ((REGNO) - BR_REG_FIRST) < BR_REG_NUM)\n+#define FP_REG_P(REGNO) ((unsigned) ((REGNO) - FP_REG_FIRST) < FP_REG_NUM)\n+#define ACC_REG_P(REGNO) ((unsigned) ((REGNO) - ACC_REG_FIRST) < ACC_REG_NUM)\n+\n+/* Return number of consecutive hard regs needed starting at reg REGNO\n+   to hold something of mode MODE.  */\n+#define HARD_REGNO_NREGS(REGNO, MODE)\t\t\t\t\t\\\n+  (FP_REG_P (REGNO) ?\t\t\t\t\t\t\t\\\n+\t((GET_MODE_SIZE (MODE) + UNITS_PER_FPREG - 1) / UNITS_PER_FPREG) : \\\n+\t((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD))\n+\n+/* Value is 1 if hard register REGNO can hold a value of machine-mode\n+   MODE. */\n+extern char xtensa_hard_regno_mode_ok[][FIRST_PSEUDO_REGISTER];\n+\n+#define HARD_REGNO_MODE_OK(REGNO, MODE)\t\t\t\t\t\\\n+  xtensa_hard_regno_mode_ok[(int) (MODE)][(REGNO)]\n+\n+/* Value is 1 if it is a good idea to tie two pseudo registers\n+   when one has mode MODE1 and one has mode MODE2.\n+   If HARD_REGNO_MODE_OK could produce different values for MODE1 and MODE2,\n+   for any hard reg, then this must be 0 for correct output.  */\n+#define MODES_TIEABLE_P(MODE1, MODE2)\t\t\t\t\t\\\n+  ((GET_MODE_CLASS (MODE1) == MODE_FLOAT ||\t\t\t\t\\\n+    GET_MODE_CLASS (MODE1) == MODE_COMPLEX_FLOAT)\t\t\t\\\n+   == (GET_MODE_CLASS (MODE2) == MODE_FLOAT ||\t\t\t\t\\\n+       GET_MODE_CLASS (MODE2) == MODE_COMPLEX_FLOAT))\n+\n+/* Register to use for LCOUNT special register.  */\n+#define COUNT_REGISTER_REGNUM (SPEC_REG_FIRST + 0)\n+\n+/* Register to use for pushing function arguments.  */\n+#define STACK_POINTER_REGNUM (GP_REG_FIRST + 1)\n+\n+/* Base register for access to local variables of the function.  */\n+#define HARD_FRAME_POINTER_REGNUM (GP_REG_FIRST + 7)\n+\n+/* The register number of the frame pointer register, which is used to\n+   access automatic variables in the stack frame.  For Xtensa, this\n+   register never appears in the output.  It is always eliminated to\n+   either the stack pointer or the hard frame pointer. */\n+#define FRAME_POINTER_REGNUM (GP_REG_FIRST + 16)\n+\n+/* Value should be nonzero if functions must have frame pointers.\n+   Zero means the frame pointer need not be set up (and parms\n+   may be accessed via the stack pointer) in functions that seem suitable.\n+   This is computed in 'reload', in reload1.c.  */\n+#define FRAME_POINTER_REQUIRED xtensa_frame_pointer_required ()\n+\n+/* Base register for access to arguments of the function.  */\n+#define ARG_POINTER_REGNUM (GP_REG_FIRST + 17)\n+\n+/* If the static chain is passed in memory, these macros provide rtx\n+   giving 'mem' expressions that denote where they are stored.\n+   'STATIC_CHAIN' and 'STATIC_CHAIN_INCOMING' give the locations as\n+   seen by the calling and called functions, respectively.  */\n+\n+#define STATIC_CHAIN\t\t\t\t\t\t\t\\\n+  gen_rtx_MEM (Pmode, plus_constant (stack_pointer_rtx, -5 * UNITS_PER_WORD))\n+\n+#define STATIC_CHAIN_INCOMING\t\t\t\t\t\t\\\n+  gen_rtx_MEM (Pmode, plus_constant (arg_pointer_rtx, -5 * UNITS_PER_WORD))\n+\n+/* For now we don't try to use the full set of boolean registers.  Without\n+   software pipelining of FP operations, there's not much to gain and it's\n+   a real pain to get them reloaded.  */\n+#define FPCC_REGNUM (BR_REG_FIRST + 0)\n+\n+/* Pass structure value address as an \"invisible\" first argument.  */\n+#define STRUCT_VALUE 0\n+\n+/* It is as good or better to call a constant function address than to\n+   call an address kept in a register.  */\n+#define NO_FUNCTION_CSE 1\n+\n+/* It is as good or better for a function to call itself with an\n+   explicit address than to call an address kept in a register.  */\n+#define NO_RECURSIVE_FUNCTION_CSE 1\n+\n+/* Xtensa processors have \"register windows\".  GCC does not currently\n+   take advantage of the possibility for variable-sized windows; instead,\n+   we use a fixed window size of 8.  */\n+\n+#define INCOMING_REGNO(OUT)\t\t\t\t\t\t\\\n+  ((GP_REG_P (OUT) &&\t\t\t\t\t\t\t\\\n+    ((unsigned) ((OUT) - GP_REG_FIRST) >= WINDOW_SIZE)) ?\t\t\\\n+   (OUT) - WINDOW_SIZE : (OUT))\n+\n+#define OUTGOING_REGNO(IN)\t\t\t\t\t\t\\\n+  ((GP_REG_P (IN) &&\t\t\t\t\t\t\t\\\n+    ((unsigned) ((IN) - GP_REG_FIRST) < WINDOW_SIZE)) ?\t\t\t\\\n+   (IN) + WINDOW_SIZE : (IN))\n+\n+\n+/* Define the classes of registers for register constraints in the\n+   machine description.  */\n+enum reg_class\n+{\n+  NO_REGS,\t\t\t/* no registers in set */\n+  BR_REGS,\t\t\t/* coprocessor boolean registers */\n+  FP_REGS,\t\t\t/* floating point registers */\n+  ACC_REG,\t\t\t/* MAC16 accumulator */\n+  SP_REG,\t\t\t/* sp register (aka a1) */\n+  GR_REGS,\t\t\t/* integer registers except sp */\n+  AR_REGS,\t\t\t/* all integer registers */\n+  ALL_REGS,\t\t\t/* all registers */\n+  LIM_REG_CLASSES\t\t/* max value + 1 */\n+};\n+\n+#define N_REG_CLASSES (int) LIM_REG_CLASSES\n+\n+#define GENERAL_REGS AR_REGS\n+\n+/* An initializer containing the names of the register classes as C\n+   string constants.  These names are used in writing some of the\n+   debugging dumps.  */\n+#define REG_CLASS_NAMES\t\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  \"NO_REGS\",\t\t\t\t\t\t\t\t\\\n+  \"BR_REGS\",\t\t\t\t\t\t\t\t\\\n+  \"FP_REGS\",\t\t\t\t\t\t\t\t\\\n+  \"ACC_REG\",\t\t\t\t\t\t\t\t\\\n+  \"SP_REG\",\t\t\t\t\t\t\t\t\\\n+  \"GR_REGS\",\t\t\t\t\t\t\t\t\\\n+  \"AR_REGS\",\t\t\t\t\t\t\t\t\\\n+  \"ALL_REGS\"\t\t\t\t\t\t\t\t\\\n+}\n+\n+/* Contents of the register classes.  The Nth integer specifies the\n+   contents of class N.  The way the integer MASK is interpreted is\n+   that register R is in the class if 'MASK & (1 << R)' is 1.  */\n+#define REG_CLASS_CONTENTS \\\n+{ \\\n+  { 0x00000000, 0x00000000 }, /* no registers */ \\\n+  { 0x00040000, 0x00000000 }, /* coprocessor boolean registers */ \\\n+  { 0xfff80000, 0x00000007 }, /* floating-point registers */ \\\n+  { 0x00000000, 0x00000008 }, /* MAC16 accumulator */ \\\n+  { 0x00000002, 0x00000000 }, /* stack pointer register */ \\\n+  { 0x0000fffd, 0x00000000 }, /* general-purpose registers */ \\\n+  { 0x0003ffff, 0x00000000 }, /* integer registers */ \\\n+  { 0xffffffff, 0x0000000f }  /* all registers */ \\\n+}\n+\n+/* A C expression whose value is a register class containing hard\n+   register REGNO.  In general there is more that one such class;\n+   choose a class which is \"minimal\", meaning that no smaller class\n+   also contains the register.  */\n+extern const enum reg_class xtensa_regno_to_class[FIRST_PSEUDO_REGISTER];\n+\n+#define REGNO_REG_CLASS(REGNO) xtensa_regno_to_class[ (REGNO) ]\n+\n+/* Use the Xtensa AR register file for base registers.\n+   No index registers.  */\n+#define BASE_REG_CLASS AR_REGS\n+#define INDEX_REG_CLASS NO_REGS\n+\n+/* SMALL_REGISTER_CLASSES is required for Xtensa, because all of the\n+   16 AR registers may be explicitly used in the RTL, as either\n+   incoming or outgoing arguments. */\n+#define SMALL_REGISTER_CLASSES 1\n+\n+\n+/* REGISTER AND CONSTANT CLASSES */\n+\n+/* Get reg_class from a letter such as appears in the machine\n+   description.\n+\n+   Available letters: a-f,h,j-l,q,t-z,A-D,W,Y-Z\n+\n+   DEFINED REGISTER CLASSES:\n+\n+   'a'  general-purpose registers except sp\n+   'q'  sp (aka a1)\n+   'D'\tgeneral-purpose registers (only if density option enabled)\n+   'd'  general-purpose registers, including sp (only if density enabled)\n+   'A'\tMAC16 accumulator (only if MAC16 option enabled)\n+   'B'\tgeneral-purpose registers (only if sext instruction enabled)\n+   'C'  general-purpose registers (only if mul16 option enabled)\n+   'b'\tcoprocessor boolean registers\n+   'f'\tfloating-point registers\n+*/\n+\n+extern enum reg_class xtensa_char_to_class[256];\n+\n+#define REG_CLASS_FROM_LETTER(C) xtensa_char_to_class[ (int) (C) ]\n+\n+/* The letters I, J, K, L, M, N, O, and P in a register constraint\n+   string can be used to stand for particular ranges of immediate\n+   operands.  This macro defines what the ranges are.  C is the\n+   letter, and VALUE is a constant value.  Return 1 if VALUE is\n+   in the range specified by C.\n+\n+   For Xtensa:\n+\n+   I = 12-bit signed immediate for movi\n+   J = 8-bit signed immediate for addi\n+   K = 4-bit value in (b4const U {0})\n+   L = 4-bit value in b4constu\n+   M = 7-bit value in simm7\n+   N = 8-bit unsigned immediate shifted left by 8 bits for addmi\n+   O = 4-bit value in ai4const\n+   P = valid immediate mask value for extui */\n+\n+#define CONST_OK_FOR_LETTER_P(VALUE, C)\t\t\t\t\t\\\n+  ((C) == 'I' ? (xtensa_simm12b (VALUE))\t\t\t\t\\\n+   : (C) == 'J' ? (xtensa_simm8 (VALUE))\t\t\t\t\\\n+   : (C) == 'K' ? (((VALUE) == 0) || xtensa_b4const (VALUE))\t\t\\\n+   : (C) == 'L' ? (xtensa_b4constu (VALUE))\t\t\t\t\\\n+   : (C) == 'M' ? (xtensa_simm7 (VALUE))\t\t\t\t\\\n+   : (C) == 'N' ? (xtensa_simm8x256 (VALUE))\t\t\t\t\\\n+   : (C) == 'O' ? (xtensa_ai4const (VALUE))\t\t\t\t\\\n+   : (C) == 'P' ? (xtensa_mask_immediate (VALUE))\t\t\t\\\n+   : FALSE)\n+\n+\n+/* Similar, but for floating constants, and defining letters G and H.\n+   Here VALUE is the CONST_DOUBLE rtx itself.  */\n+#define CONST_DOUBLE_OK_FOR_LETTER_P(VALUE, C) (0)\n+\n+\n+/* Other letters can be defined in a machine-dependent fashion to\n+   stand for particular classes of registers or other arbitrary\n+   operand types.\n+\n+   R = memory that can be accessed with a 4-bit unsigned offset\n+   S = memory where the second word can be addressed with a 4-bit offset\n+   T = memory in a constant pool (addressable with a pc-relative load)\n+   U = memory *NOT* in a constant pool\n+\n+   The offset range should not be checked here (except to distinguish\n+   denser versions of the instructions for which more general versions\n+   are available).  Doing so leads to problems in reloading: an\n+   argptr-relative address may become invalid when the phony argptr is\n+   eliminated in favor of the stack pointer (the offset becomes too\n+   large to fit in the instruction's immediate field); a reload is\n+   generated to fix this but the RTL is not immediately updated; in\n+   the meantime, the constraints are checked and none match.  The\n+   solution seems to be to simply skip the offset check here.  The\n+   address will be checked anyway because of the code in\n+   GO_IF_LEGITIMATE_ADDRESS. */\n+\n+#define EXTRA_CONSTRAINT(OP, CODE)\t\t\t\t\t\\\n+  ((GET_CODE (OP) != MEM) ?\t\t\t\t\t\t\\\n+       ((CODE) >= 'R' && (CODE) <= 'U'\t\t\t\t\t\\\n+\t&& reload_in_progress && GET_CODE (OP) == REG\t\t\t\\\n+        && REGNO (OP) >= FIRST_PSEUDO_REGISTER)\t\t\t\t\\\n+   : ((CODE) == 'R') ? smalloffset_mem_p (OP)\t\t\t\t\\\n+   : ((CODE) == 'S') ? smalloffset_double_mem_p (OP)\t\t\t\\\n+   : ((CODE) == 'T') ? constantpool_mem_p (OP)\t\t\t\t\\\n+   : ((CODE) == 'U') ? !constantpool_mem_p (OP)\t\t\t\t\\\n+   : FALSE)\n+\n+/* Given an rtx X being reloaded into a reg required to be\n+   in class CLASS, return the class of reg to actually use.  */\n+#define PREFERRED_RELOAD_CLASS(X, CLASS)\t\t\t\t\\\n+  (CONSTANT_P (X)\t\t\t\t\t\t\t\\\n+   ? (GET_CODE (X) == CONST_DOUBLE) ? NO_REGS : (CLASS)\t\t\t\\\n+   : (CLASS))\n+\n+#define PREFERRED_OUTPUT_RELOAD_CLASS(X, CLASS)\t\t\t\t\\\n+  (CLASS)\n+  \n+#define SECONDARY_INPUT_RELOAD_CLASS(CLASS, MODE, X)\t\t\t\\\n+  xtensa_secondary_reload_class (CLASS, MODE, X, 0)\n+\n+#define SECONDARY_OUTPUT_RELOAD_CLASS(CLASS, MODE, X)\t\t\t\\\n+  xtensa_secondary_reload_class (CLASS, MODE, X, 1)\n+\n+/* Return the maximum number of consecutive registers\n+   needed to represent mode MODE in a register of class CLASS.  */\n+#define CLASS_UNITS(mode, size)\t\t\t\t\t\t\\\n+  ((GET_MODE_SIZE (mode) + (size) - 1) / (size))\n+\n+#define CLASS_MAX_NREGS(CLASS, MODE)\t\t\t\t\t\\\n+  (CLASS_UNITS (MODE, UNITS_PER_WORD))\n+\n+\n+/* Stack layout; function entry, exit and calling.  */\n+\n+#define STACK_GROWS_DOWNWARD\n+\n+/* Offset within stack frame to start allocating local variables at.  */\n+#define STARTING_FRAME_OFFSET\t\t\t\t\t\t\\\n+  current_function_outgoing_args_size\n+\n+/* The ARG_POINTER and FRAME_POINTER are not real Xtensa registers, so\n+   they are eliminated to either the stack pointer or hard frame pointer.  */\n+#define ELIMINABLE_REGS\t\t\t\t\t\t\t\\\n+{{ ARG_POINTER_REGNUM,\t\tSTACK_POINTER_REGNUM},\t\t\t\\\n+ { ARG_POINTER_REGNUM,\t\tHARD_FRAME_POINTER_REGNUM},\t\t\\\n+ { FRAME_POINTER_REGNUM,\tSTACK_POINTER_REGNUM},\t\t\t\\\n+ { FRAME_POINTER_REGNUM,\tHARD_FRAME_POINTER_REGNUM}}\n+\n+#define CAN_ELIMINATE(FROM, TO) 1\n+\n+/* Specify the initial difference between the specified pair of registers.  */\n+#define INITIAL_ELIMINATION_OFFSET(FROM, TO, OFFSET)\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    compute_frame_size (get_frame_size ());\t\t\t\t\\\n+    if ((FROM) == FRAME_POINTER_REGNUM)\t\t\t\t\t\\\n+      (OFFSET) = 0;\t\t\t\t\t\t\t\\\n+    else if ((FROM) == ARG_POINTER_REGNUM)\t\t\t\t\\\n+      (OFFSET) = xtensa_current_frame_size;\t\t\t\t\\\n+    else\t\t\t\t\t\t\t\t\\\n+      abort ();\t\t\t\t\t\t\t\t\\\n+  } while (0)\n+\n+/* If defined, the maximum amount of space required for outgoing\n+   arguments will be computed and placed into the variable\n+   'current_function_outgoing_args_size'.  No space will be pushed\n+   onto the stack for each call; instead, the function prologue\n+   should increase the stack frame size by this amount.  */\n+#define ACCUMULATE_OUTGOING_ARGS 1\n+\n+/* Offset from the argument pointer register to the first argument's\n+   address.  On some machines it may depend on the data type of the\n+   function.  If 'ARGS_GROW_DOWNWARD', this is the offset to the\n+   location above the first argument's address.  */\n+#define FIRST_PARM_OFFSET(FNDECL) 0\n+\n+/* Align stack frames on 128 bits for Xtensa.  This is necessary for\n+   128-bit datatypes defined in TIE (e.g., for Vectra).  */\n+#define STACK_BOUNDARY 128\n+\n+/* Functions do not pop arguments off the stack.  */\n+#define RETURN_POPS_ARGS(FUNDECL, FUNTYPE, SIZE) 0\n+\n+/* Use a fixed register window size of 8.  */\n+#define WINDOW_SIZE 8\n+\n+/* Symbolic macros for the registers used to return integer, floating\n+   point, and values of coprocessor and user-defined modes.  */\n+#define GP_RETURN (GP_REG_FIRST + 2 + WINDOW_SIZE)\n+#define GP_OUTGOING_RETURN (GP_REG_FIRST + 2)\n+\n+/* Symbolic macros for the first/last argument registers.  */\n+#define GP_ARG_FIRST (GP_REG_FIRST + 2)\n+#define GP_ARG_LAST  (GP_REG_FIRST + 7)\n+#define GP_OUTGOING_ARG_FIRST (GP_REG_FIRST + 2 + WINDOW_SIZE)\n+#define GP_OUTGOING_ARG_LAST  (GP_REG_FIRST + 7 + WINDOW_SIZE)\n+\n+#define MAX_ARGS_IN_REGISTERS 6\n+\n+/* Don't worry about compatibility with PCC.  */\n+#define DEFAULT_PCC_STRUCT_RETURN 0\n+\n+/* For Xtensa, we would like to be able to return up to 6 words in\n+   memory but GCC cannot support that.  The return value must be given\n+   one of the standard MODE_INT modes, and there is no 6 word mode.\n+   Instead, if we try to return a 6 word structure, GCC selects the\n+   next biggest mode (OImode, 8 words) and then the register allocator\n+   fails because there is no 8-register group beginning with a10.  So\n+   we have to fall back on the next largest size which is 4 words... */\n+#define RETURN_IN_MEMORY(TYPE)\t\t\t\t\t\t\\\n+  ((unsigned HOST_WIDE_INT) int_size_in_bytes (TYPE) > 4 * UNITS_PER_WORD)\n+\n+/* Define how to find the value returned by a library function\n+   assuming the value has mode MODE.  Because we have defined\n+   PROMOTE_FUNCTION_RETURN, we have to perform the same promotions as\n+   PROMOTE_MODE. */\n+#define XTENSA_LIBCALL_VALUE(MODE, OUTGOINGP)\t\t\t\t\\\n+  gen_rtx_REG ((GET_MODE_CLASS (MODE) == MODE_INT\t\t\t\\\n+\t\t&& GET_MODE_SIZE (MODE) < UNITS_PER_WORD)\t\t\\\n+\t       ? SImode : (MODE),\t\t\t\t\t\\\n+\t       OUTGOINGP ? GP_OUTGOING_RETURN : GP_RETURN)\n+\n+#define LIBCALL_VALUE(MODE)\t\t\t\t\t\t\\\n+  XTENSA_LIBCALL_VALUE ((MODE), 0)\n+\n+#define LIBCALL_OUTGOING_VALUE(MODE)\t\t\t \t\t\\\n+  XTENSA_LIBCALL_VALUE ((MODE), 1)\n+\n+/* Define how to find the value returned by a function.\n+   VALTYPE is the data type of the value (as a tree).\n+   If the precise function being called is known, FUNC is its FUNCTION_DECL;\n+   otherwise, FUNC is 0.  */\n+#define XTENSA_FUNCTION_VALUE(VALTYPE, FUNC, OUTGOINGP)\t\t\t\\\n+  gen_rtx_REG ((INTEGRAL_TYPE_P (VALTYPE)\t\t\t\t\\\n+\t        && TYPE_PRECISION (VALTYPE) < BITS_PER_WORD)\t\t\\\n+\t       ? SImode: TYPE_MODE (VALTYPE),\t\t\t\t\\\n+\t       OUTGOINGP ? GP_OUTGOING_RETURN : GP_RETURN)\n+\n+#define FUNCTION_VALUE(VALTYPE, FUNC)\t\t\t\t\t\\\n+  XTENSA_FUNCTION_VALUE (VALTYPE, FUNC, 0)\n+\n+#define FUNCTION_OUTGOING_VALUE(VALTYPE, FUNC)\t\t\t\t\\\n+  XTENSA_FUNCTION_VALUE (VALTYPE, FUNC, 1)\n+\n+/* A C expression that is nonzero if REGNO is the number of a hard\n+   register in which the values of called function may come back.  A\n+   register whose use for returning values is limited to serving as\n+   the second of a pair (for a value of type 'double', say) need not\n+   be recognized by this macro.  If the machine has register windows,\n+   so that the caller and the called function use different registers\n+   for the return value, this macro should recognize only the caller's\n+   register numbers. */\n+#define FUNCTION_VALUE_REGNO_P(N)\t\t\t\t\t\\\n+  ((N) == GP_RETURN)\n+\n+/* A C expression that is nonzero if REGNO is the number of a hard\n+   register in which function arguments are sometimes passed.  This\n+   does *not* include implicit arguments such as the static chain and\n+   the structure-value address.  On many machines, no registers can be\n+   used for this purpose since all function arguments are pushed on\n+   the stack. */\n+#define FUNCTION_ARG_REGNO_P(N)\t\t\t\t\t\t\\\n+  ((N) >= GP_OUTGOING_ARG_FIRST && (N) <= GP_OUTGOING_ARG_LAST)\n+\n+/* Use IEEE floating-point format.  */\n+#define TARGET_FLOAT_FORMAT IEEE_FLOAT_FORMAT\n+\n+/* Define a data type for recording info about an argument list\n+   during the scan of that argument list.  This data type should\n+   hold all necessary information about the function itself\n+   and about the args processed so far, enough to enable macros\n+   such as FUNCTION_ARG to determine where the next arg should go. */\n+typedef struct xtensa_args {\n+    int arg_words;\t\t/* # total words the arguments take */\n+} CUMULATIVE_ARGS;\n+\n+/* Initialize a variable CUM of type CUMULATIVE_ARGS\n+   for a call to a function whose data type is FNTYPE.\n+   For a library call, FNTYPE is 0. */\n+#define INIT_CUMULATIVE_ARGS(CUM, FNTYPE, LIBNAME, INDIRECT)\t\t\\\n+  init_cumulative_args (&CUM, FNTYPE, LIBNAME)\n+\n+#define INIT_CUMULATIVE_INCOMING_ARGS(CUM, FNTYPE, LIBNAME)\t\t\\\n+  init_cumulative_args (&CUM, FNTYPE, LIBNAME)\n+\n+/* Update the data in CUM to advance over an argument\n+   of mode MODE and data type TYPE.\n+   (TYPE is null for libcalls where that information may not be available.)  */\n+#define FUNCTION_ARG_ADVANCE(CUM, MODE, TYPE, NAMED)\t\t\t\\\n+  function_arg_advance (&CUM, MODE, TYPE)\n+\n+#define FUNCTION_ARG(CUM, MODE, TYPE, NAMED) \\\n+  function_arg (&CUM, MODE, TYPE, FALSE)\n+\n+#define FUNCTION_INCOMING_ARG(CUM, MODE, TYPE, NAMED) \\\n+  function_arg (&CUM, MODE, TYPE, TRUE)\n+\n+/* Arguments are never passed partly in memory and partly in registers.  */\n+#define FUNCTION_ARG_PARTIAL_NREGS(CUM, MODE, TYPE, NAMED) (0)\n+\n+/* Specify function argument alignment.  */\n+#define FUNCTION_ARG_BOUNDARY(MODE, TYPE)\t\t\t\t\\\n+  ((TYPE) != 0\t\t\t\t\t\t\t\t\\\n+   ? (TYPE_ALIGN (TYPE) <= PARM_BOUNDARY\t\t\t\t\\\n+      ? PARM_BOUNDARY\t\t\t\t\t\t\t\\\n+      : TYPE_ALIGN (TYPE))\t\t\t\t\t\t\\\n+   : (GET_MODE_ALIGNMENT (MODE) <= PARM_BOUNDARY\t\t\t\\\n+      ? PARM_BOUNDARY\t\t\t\t\t\t\t\\\n+      : GET_MODE_ALIGNMENT (MODE)))\n+\n+\n+/* Nonzero if we do not know how to pass TYPE solely in registers.\n+   We cannot do so in the following cases:\n+\n+   - if the type has variable size\n+   - if the type is marked as addressable (it is required to be constructed\n+     into the stack)\n+\n+   This differs from the default in that it does not check if the padding\n+   and mode of the type are such that a copy into a register would put it\n+   into the wrong part of the register. */\n+\n+#define MUST_PASS_IN_STACK(MODE, TYPE)\t\t\t\t\t\\\n+  ((TYPE) != 0\t\t\t\t\t\t\t\t\\\n+   && (TREE_CODE (TYPE_SIZE (TYPE)) != INTEGER_CST\t\t\t\\\n+       || TREE_ADDRESSABLE (TYPE)))\n+\n+/* Output assembler code to FILE to increment profiler label LABELNO\n+   for profiling a function entry.\n+\n+   The mcount code in glibc doesn't seem to use this LABELNO stuff.\n+   Some ports (e.g., MIPS) don't even bother to pass the label\n+   address, and even those that do (e.g., i386) don't seem to use it.\n+   The information needed by mcount() is the current PC and the\n+   current return address, so that mcount can identify an arc in the\n+   call graph.  For Xtensa, we pass the current return address as\n+   the first argument to mcount, and the current PC is available as\n+   a0 in mcount's register window.  Both of these values contain\n+   window size information in the two most significant bits; we assume\n+   that the mcount code will mask off those bits.  The call to mcount\n+   uses a window size of 8 to make sure that mcount doesn't clobber\n+   any incoming argument values. */\n+\n+#define FUNCTION_PROFILER(FILE, LABELNO)\t\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    fprintf (FILE, \"\\taddi\\t%s, %s, 0\\t# save current return address\\n\", \\\n+\t     reg_names[GP_REG_FIRST+10],\t\t\t\t\\\n+\t     reg_names[GP_REG_FIRST+0]);\t\t\t\t\\\n+    fprintf (FILE, \"\\tcall8\\t_mcount\\n\");\t\t\t\t\\\n+  } while (0);\n+\n+/* Stack pointer value doesn't matter at exit.  */\n+#define EXIT_IGNORE_STACK 1\n+\n+/* A C statement to output, on the stream FILE, assembler code for a\n+   block of data that contains the constant parts of a trampoline. \n+   This code should not include a label--the label is taken care of\n+   automatically.\n+\n+   For Xtensa, the trampoline must perform an entry instruction with a\n+   minimal stack frame in order to get some free registers.  Once the\n+   actual call target is known, the proper stack frame size is extracted\n+   from the entry instruction at the target and the current frame is\n+   adjusted to match.  The trampoline then transfers control to the\n+   instruction following the entry at the target.  Note: this assumes\n+   that the target begins with an entry instruction. */\n+\n+/* minimum frame = reg save area (4 words) plus static chain (1 word)\n+   and the total number of words must be a multiple of 128 bits */\n+#define MIN_FRAME_SIZE (8 * UNITS_PER_WORD)\n+\n+#define TRAMPOLINE_TEMPLATE(STREAM)\t\t\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    fprintf (STREAM, \"\\t.begin no-generics\\n\");\t\t\t\t\\\n+    fprintf (STREAM, \"\\tentry\\tsp, %d\\n\", MIN_FRAME_SIZE);\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+    /* GCC isn't prepared to deal with data at the beginning of the\t\\\n+       trampoline, and the Xtensa l32r instruction requires that the\t\\\n+       constant pool be located before the code.  We put the constant\t\\\n+       pool in the middle of the trampoline and jump around it. */ \t\\\n+\t\t\t\t\t\t\t\t\t\\\n+    fprintf (STREAM, \"\\tj\\t.Lskipconsts\\n\");\t\t\t\t\\\n+    fprintf (STREAM, \"\\t.align\\t4\\n\");\t\t\t\t\t\\\n+    fprintf (STREAM, \".Lfnaddr:%s0\\n\", integer_asm_op (4, TRUE));\t\\\n+    fprintf (STREAM, \".Lchainval:%s0\\n\", integer_asm_op (4, TRUE));\t\\\n+    fprintf (STREAM, \".Lskipconsts:\\n\");\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+    /* store the static chain */\t\t\t\t\t\\\n+    fprintf (STREAM, \"\\tl32r\\ta8, .Lchainval\\n\");\t\t\t\\\n+    fprintf (STREAM, \"\\ts32i\\ta8, sp, %d\\n\",\t\t\t\t\\\n+\t     MIN_FRAME_SIZE - (5 * UNITS_PER_WORD));\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+    /* set the proper stack pointer value */\t\t\t\t\\\n+    fprintf (STREAM, \"\\tl32r\\ta8, .Lfnaddr\\n\");\t\t\t\t\\\n+    fprintf (STREAM, \"\\tl32i\\ta9, a8, 0\\n\");\t\t\t\t\\\n+    fprintf (STREAM, \"\\textui\\ta9, a9, %d, 12\\n\",\t\t\t\\\n+\t     TARGET_BIG_ENDIAN ? 8 : 12);\t\t\t\t\\\n+    fprintf (STREAM, \"\\tslli\\ta9, a9, 3\\n\");\t\t\t\t\\\n+    fprintf (STREAM, \"\\taddi\\ta9, a9, %d\\n\", -MIN_FRAME_SIZE);\t\t\\\n+    fprintf (STREAM, \"\\tsub\\ta9, sp, a9\\n\");\t\t\t\t\\\n+    fprintf (STREAM, \"\\tmovsp\\tsp, a9\\n\");\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+    /* jump to the instruction following the entry */\t\t\t\\\n+    fprintf (STREAM, \"\\taddi\\ta8, a8, 3\\n\");\t\t\t\t\\\n+    fprintf (STREAM, \"\\tjx\\ta8\\n\");\t\t\t\t\t\\\n+    fprintf (STREAM, \"\\t.end no-generics\\n\");\t\t\t\t\\\n+  } while (0)\n+\n+/* Size in bytes of the trampoline, as an integer.  */\n+#define TRAMPOLINE_SIZE 49\n+\n+/* Alignment required for trampolines, in bits.  */\n+#define TRAMPOLINE_ALIGNMENT (32)\n+\n+/* A C statement to initialize the variable parts of a trampoline.  */\n+#define INITIALIZE_TRAMPOLINE(ADDR, FUNC, CHAIN)\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    rtx addr = ADDR;\t\t\t\t\t\t\t\\\n+    emit_move_insn (gen_rtx_MEM (SImode, plus_constant (addr, 8)), FUNC); \\\n+    emit_move_insn (gen_rtx_MEM (SImode, plus_constant (addr, 12)), CHAIN); \\\n+    emit_library_call (gen_rtx (SYMBOL_REF, Pmode, \"__xtensa_sync_caches\"), \\\n+\t\t       0, VOIDmode, 1, addr, Pmode);\t\t\t\\\n+  } while (0)\n+\n+/* Define the `__builtin_va_list' type for the ABI.  */\n+#define BUILD_VA_LIST_TYPE(VALIST) \\\n+  (VALIST) = xtensa_build_va_list ()\n+\n+/* If defined, is a C expression that produces the machine-specific\n+   code for a call to '__builtin_saveregs'.  This code will be moved\n+   to the very beginning of the function, before any parameter access\n+   are made.  The return value of this function should be an RTX that\n+   contains the value to use as the return of '__builtin_saveregs'. */\n+#define EXPAND_BUILTIN_SAVEREGS \\\n+  xtensa_builtin_saveregs\n+\n+/* Implement `va_start' for varargs and stdarg.  */\n+#define EXPAND_BUILTIN_VA_START(stdarg, valist, nextarg) \\\n+  xtensa_va_start (stdarg, valist, nextarg)\n+\n+/* Implement `va_arg'.  */\n+#define EXPAND_BUILTIN_VA_ARG(valist, type) \\\n+  xtensa_va_arg (valist, type)\n+\n+/* If defined, a C expression that produces the machine-specific code\n+   to setup the stack so that arbitrary frames can be accessed.\n+\n+   On Xtensa, a stack back-trace must always begin from the stack pointer,\n+   so that the register overflow save area can be located.  However, the\n+   stack-walking code in GCC always begins from the hard_frame_pointer\n+   register, not the stack pointer.  The frame pointer is usually equal\n+   to the stack pointer, but the __builtin_return_address and\n+   __builtin_frame_address functions will not work if count > 0 and\n+   they are called from a routine that uses alloca.  These functions\n+   are not guaranteed to work at all if count > 0 so maybe that is OK.\n+\n+   A nicer solution would be to allow the architecture-specific files to\n+   specify whether to start from the stack pointer or frame pointer.  That\n+   would also allow us to skip the machine->accesses_prev_frame stuff that\n+   we currently need to ensure that there is a frame pointer when these\n+   builtin functions are used. */\n+\n+#define SETUP_FRAME_ADDRESSES() \\\n+  xtensa_setup_frame_addresses ()\n+\n+/* A C expression whose value is RTL representing the address in a\n+   stack frame where the pointer to the caller's frame is stored.\n+   Assume that FRAMEADDR is an RTL expression for the address of the\n+   stack frame itself.\n+\n+   For Xtensa, there is no easy way to get the frame pointer if it is\n+   not equivalent to the stack pointer.  Moreover, the result of this\n+   macro is used for continuing to walk back up the stack, so it must\n+   return the stack pointer address.  Thus, there is some inconsistency\n+   here in that __builtin_frame_address will return the frame pointer\n+   when count == 0 and the stack pointer when count > 0. */\n+\n+#define DYNAMIC_CHAIN_ADDRESS(frame)\t\t\t\t\t\\\n+  gen_rtx (PLUS, Pmode, frame,\t\t\t\t\t\t\\\n+\t   gen_rtx_CONST_INT (VOIDmode, -3 * UNITS_PER_WORD))\n+\n+/* Define this if the return address of a particular stack frame is\n+   accessed from the frame pointer of the previous stack frame. */\n+#define RETURN_ADDR_IN_PREVIOUS_FRAME\n+\n+/* A C expression whose value is RTL representing the value of the\n+   return address for the frame COUNT steps up from the current\n+   frame, after the prologue.  FRAMEADDR is the frame pointer of the\n+   COUNT frame, or the frame pointer of the COUNT - 1 frame if\n+   'RETURN_ADDR_IN_PREVIOUS_FRAME' is defined.\n+\n+   The 2 most-significant bits of the return address on Xtensa hold\n+   the register window size.  To get the real return address, these bits\n+   must be masked off and replaced with the high bits from the current\n+   PC.  Since it is unclear how the __builtin_return_address function\n+   is used, the current code does not do this masking and simply returns\n+   the raw return address from the a0 register. */\n+#define RETURN_ADDR_RTX(count, frame)\t\t\t\t\t\\\n+  ((count) == -1\t\t\t\t\t\t\t\\\n+   ? gen_rtx_REG (Pmode, 0)\t\t\t\t\t\t\\\n+   : gen_rtx_MEM (Pmode, memory_address\t\t\t\t\t\\\n+\t\t  (Pmode, plus_constant (frame, -4 * UNITS_PER_WORD))))\n+\n+\n+/* Addressing modes, and classification of registers for them.  */\n+\n+/* C expressions which are nonzero if register number NUM is suitable\n+   for use as a base or index register in operand addresses.  It may\n+   be either a suitable hard register or a pseudo register that has\n+   been allocated such a hard register. The difference between an\n+   index register and a base register is that the index register may\n+   be scaled. */\n+\n+#define REGNO_OK_FOR_BASE_P(NUM) \\\n+  (GP_REG_P (NUM) || GP_REG_P ((unsigned) reg_renumber[NUM]))\n+\n+#define REGNO_OK_FOR_INDEX_P(NUM) 0\n+\n+/* C expressions that are nonzero if X (assumed to be a `reg' RTX) is\n+   valid for use as a base or index register.  For hard registers, it\n+   should always accept those which the hardware permits and reject\n+   the others.  Whether the macro accepts or rejects pseudo registers\n+   must be controlled by `REG_OK_STRICT'.  This usually requires two\n+   variant definitions, of which `REG_OK_STRICT' controls the one\n+   actually used. The difference between an index register and a base\n+   register is that the index register may be scaled. */\n+\n+#ifdef REG_OK_STRICT\n+\n+#define REG_OK_FOR_INDEX_P(X) 0\n+#define REG_OK_FOR_BASE_P(X) \\\n+  REGNO_OK_FOR_BASE_P (REGNO (X))\n+\n+#else /* !REG_OK_STRICT */\n+\n+#define REG_OK_FOR_INDEX_P(X) 0\n+#define REG_OK_FOR_BASE_P(X) \\\n+  ((REGNO (X) >= FIRST_PSEUDO_REGISTER) || (GP_REG_P (REGNO (X))))\n+\n+#endif /* !REG_OK_STRICT */\n+\n+/* Maximum number of registers that can appear in a valid memory address.  */\n+#define MAX_REGS_PER_ADDRESS 1\n+\n+/* Identify valid Xtensa addresses.  */\n+#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR)\t\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    rtx xinsn = (X);\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+    /* allow constant pool addresses */\t\t\t\t\t\\\n+    if ((MODE) != BLKmode && GET_MODE_SIZE (MODE) >= UNITS_PER_WORD\t\\\n+\t&& constantpool_address_p (xinsn))\t\t\t\t\\\n+      goto ADDR;\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+    while (GET_CODE (xinsn) == SUBREG)\t\t\t\t\t\\\n+      xinsn = SUBREG_REG (xinsn);\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+    /* allow base registers */\t\t\t\t\t\t\\\n+    if (GET_CODE (xinsn) == REG && REG_OK_FOR_BASE_P (xinsn))\t\t\\\n+      goto ADDR;\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+    /* check for \"register + offset\" addressing */\t\t\t\\\n+    if (GET_CODE (xinsn) == PLUS)\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\trtx xplus0 = XEXP (xinsn, 0);\t\t\t\t\t\\\n+\trtx xplus1 = XEXP (xinsn, 1);\t\t\t\t\t\\\n+\tenum rtx_code code0;\t\t\t\t\t\t\\\n+\tenum rtx_code code1;\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+\twhile (GET_CODE (xplus0) == SUBREG)\t\t\t\t\\\n+\t  xplus0 = SUBREG_REG (xplus0);\t\t\t\t\t\\\n+\tcode0 = GET_CODE (xplus0);\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+\twhile (GET_CODE (xplus1) == SUBREG)\t\t\t\t\\\n+\t  xplus1 = SUBREG_REG (xplus1);\t\t\t\t\t\\\n+\tcode1 = GET_CODE (xplus1);\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+\t/* swap operands if necessary so the register is first */\t\\\n+\tif (code0 != REG && code1 == REG)\t\t\t\t\\\n+\t  {\t\t\t\t\t\t\t\t\\\n+\t    xplus0 = XEXP (xinsn, 1);\t\t\t\t\t\\\n+\t    xplus1 = XEXP (xinsn, 0);\t\t\t\t\t\\\n+\t    code0 = GET_CODE (xplus0);\t\t\t\t\t\\\n+\t    code1 = GET_CODE (xplus1);\t\t\t\t\t\\\n+\t  }\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+\tif (code0 == REG && REG_OK_FOR_BASE_P (xplus0)\t\t\t\\\n+\t    && code1 == CONST_INT\t\t\t\t\t\\\n+\t    && xtensa_mem_offset (INTVAL (xplus1), (MODE)))\t\t\\\n+\t  {\t\t\t\t\t\t\t\t\\\n+\t    goto ADDR;\t\t\t\t\t\t\t\\\n+\t  }\t\t\t\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+  } while (0)\n+\n+/* A C expression that is 1 if the RTX X is a constant which is a\n+   valid address.  This is defined to be the same as 'CONSTANT_P (X)',\n+   but rejecting CONST_DOUBLE.  */\n+#define CONSTANT_ADDRESS_P(X)\t\t\t\t\t\t\\\n+  ((GET_CODE (X) == LABEL_REF || GET_CODE (X) == SYMBOL_REF\t\t\\\n+    || GET_CODE (X) == CONST_INT || GET_CODE (X) == HIGH\t\t\\\n+    || (GET_CODE (X) == CONST)))\n+\n+/* Nonzero if the constant value X is a legitimate general operand.\n+   It is given that X satisfies CONSTANT_P or is a CONST_DOUBLE. */\n+#define LEGITIMATE_CONSTANT_P(X) 1\n+\n+/* A C expression that is nonzero if X is a legitimate immediate\n+   operand on the target machine when generating position independent\n+   code.  */\n+#define LEGITIMATE_PIC_OPERAND_P(X)\t\t\t\t\t\\\n+  ((GET_CODE (X) != SYMBOL_REF || SYMBOL_REF_FLAG (X))\t\t\t\\\n+   && GET_CODE (X) != LABEL_REF\t\t\t\t\t\t\\\n+   && GET_CODE (X) != CONST)\n+\n+/* Tell GCC how to use ADDMI to generate addresses.  */\n+#define LEGITIMIZE_ADDRESS(X, OLDX, MODE, WIN)\t\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    rtx xinsn = (X);\t\t\t\t\t\t\t\\\n+    if (GET_CODE (xinsn) == PLUS)\t\t\t\t\t\\\n+      { \t\t\t\t\t\t\t\t\\\n+\trtx plus0 = XEXP (xinsn, 0);\t\t\t\t\t\\\n+\trtx plus1 = XEXP (xinsn, 1);\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+\tif (GET_CODE (plus0) != REG && GET_CODE (plus1) == REG)\t\t\\\n+\t  {\t\t\t\t\t\t\t\t\\\n+\t    plus0 = XEXP (xinsn, 1);\t\t\t\t\t\\\n+\t    plus1 = XEXP (xinsn, 0);\t\t\t\t\t\\\n+\t  }\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+\tif (GET_CODE (plus0) == REG\t\t\t\t\t\\\n+\t    && GET_CODE (plus1) == CONST_INT\t\t\t\t\\\n+\t    && !xtensa_mem_offset (INTVAL (plus1), MODE)\t\t\\\n+\t    && !xtensa_simm8 (INTVAL (plus1))\t\t\t\t\\\n+\t    && xtensa_mem_offset (INTVAL (plus1) & 0xff, MODE)\t\t\\\n+\t    && xtensa_simm8x256 (INTVAL (plus1) & ~0xff))\t\t\\\n+\t  {\t\t\t\t\t\t\t\t\\\n+\t    rtx temp = gen_reg_rtx (Pmode);\t\t\t\t\\\n+\t    emit_insn (gen_rtx (SET, Pmode, temp,\t\t\t\\\n+\t\t\t\tgen_rtx (PLUS, Pmode, plus0,\t\t\\\n+\t\t\t\t\t GEN_INT (INTVAL (plus1) & ~0xff)))); \\\n+\t    (X) = gen_rtx (PLUS, Pmode, temp,\t\t\t\t\\\n+\t\t\t   GEN_INT (INTVAL (plus1) & 0xff));\t\t\\\n+\t    goto WIN;\t\t\t\t\t\t\t\\\n+\t  }\t\t\t\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+  } while (0)\n+\n+\n+#define GO_IF_MODE_DEPENDENT_ADDRESS(ADDR, LABEL) {}\n+\n+/* If we are referencing a function that is static, make the SYMBOL_REF\n+   special so that we can generate direct calls to it even with -fpic.  */\n+#define ENCODE_SECTION_INFO(DECL)\t\t\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    if (TREE_CODE (DECL) == FUNCTION_DECL && ! TREE_PUBLIC (DECL))\t\\\n+      SYMBOL_REF_FLAG (XEXP (DECL_RTL (DECL), 0)) = 1;\t\t\t\\\n+  } while (0)\n+\n+/* Specify the machine mode that this machine uses\n+   for the index in the tablejump instruction.  */\n+#define CASE_VECTOR_MODE (SImode)\n+\n+/* Define this if the tablejump instruction expects the table\n+   to contain offsets from the address of the table.\n+   Do not define this if the table should contain absolute addresses.  */\n+/* #define CASE_VECTOR_PC_RELATIVE */\n+\n+/* Specify the tree operation to be used to convert reals to integers.  */\n+#define IMPLICIT_FIX_EXPR FIX_ROUND_EXPR\n+\n+/* This is the kind of divide that is easiest to do in the general case.  */\n+#define EASY_DIV_EXPR TRUNC_DIV_EXPR\n+\n+/* Define this as 1 if 'char' should by default be signed; else as 0.  */\n+#define DEFAULT_SIGNED_CHAR 0\n+\n+/* Max number of bytes we can move from memory to memory\n+   in one reasonably fast instruction.  */\n+#define MOVE_MAX 4\n+#define MAX_MOVE_MAX 4\n+\n+/* Prefer word-sized loads.  */\n+#define SLOW_BYTE_ACCESS 1\n+\n+/* Xtensa doesn't have any instructions that set integer values based on the\n+   results of comparisons, but the simplification code in the combiner also\n+   uses this macro.  The value should be either 1 or -1 to enable some\n+   optimizations in the combiner; I'm not sure which is better for us.\n+   Since we've been using 1 for a while, it should probably stay that way for\n+   compatibility.  */\n+#define STORE_FLAG_VALUE 1\n+\n+/* Shift instructions ignore all but the low-order few bits.  */\n+#define SHIFT_COUNT_TRUNCATED 1\n+\n+/* Value is 1 if truncating an integer of INPREC bits to OUTPREC bits\n+   is done just by pretending it is already truncated. */\n+#define TRULY_NOOP_TRUNCATION(OUTPREC, INPREC) 1\n+\n+/* Specify the machine mode that pointers have.\n+   After generation of rtl, the compiler makes no further distinction\n+   between pointers and any other objects of this machine mode.  */\n+#define Pmode SImode\n+\n+/* A function address in a call instruction is a word address (for\n+   indexing purposes) so give the MEM rtx a words's mode.  */\n+#define FUNCTION_MODE SImode\n+\n+/* A C expression that evaluates to true if it is ok to perform a\n+   sibling call to DECL.  */\n+/* TODO: fix this up to allow at least some sibcalls */\n+#define FUNCTION_OK_FOR_SIBCALL(DECL) 0\n+\n+/* Xtensa constant costs.  */\n+#define CONST_COSTS(X, CODE, OUTER_CODE)\t\t\t\t\\\n+  case CONST_INT:\t\t\t\t\t\t\t\\\n+    switch (OUTER_CODE)\t\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+      case SET:\t\t\t\t\t\t\t\t\\\n+\tif (xtensa_simm12b (INTVAL (X))) return 4;\t\t\t\\\n+\tbreak;\t\t\t\t\t\t\t\t\\\n+      case PLUS:\t\t\t\t\t\t\t\\\n+\tif (xtensa_simm8 (INTVAL (X))) return 0;\t\t\t\\\n+\tif (xtensa_simm8x256 (INTVAL (X))) return 0;\t\t\t\\\n+\tbreak;\t\t\t\t\t\t\t\t\\\n+      case AND:\t\t\t\t\t\t\t\t\\\n+\tif (xtensa_mask_immediate (INTVAL (X))) return 0;\t\t\\\n+\tbreak;\t\t\t\t\t\t\t\t\\\n+      case COMPARE:\t\t\t\t\t\t\t\\\n+\tif ((INTVAL (X) == 0) || xtensa_b4const (INTVAL (X))) return 0;\t\\\n+\tbreak;\t\t\t\t\t\t\t\t\\\n+      case ASHIFT:\t\t\t\t\t\t\t\\\n+      case ASHIFTRT:\t\t\t\t\t\t\t\\\n+      case LSHIFTRT:\t\t\t\t\t\t\t\\\n+      case ROTATE:\t\t\t\t\t\t\t\\\n+      case ROTATERT:\t\t\t\t\t\t\t\\\n+        /* no way to tell if X is the 2nd operand so be conservative */\t\\\n+      default: break;\t\t\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+    if (xtensa_simm12b (INTVAL (X))) return 5;\t\t\t\t\\\n+    return 6;\t\t\t\t\t\t\t\t\\\n+  case CONST:\t\t\t\t\t\t\t\t\\\n+  case LABEL_REF:\t\t\t\t\t\t\t\\\n+  case SYMBOL_REF:\t\t\t\t\t\t\t\\\n+    return 5;\t\t\t\t\t\t\t\t\\\n+  case CONST_DOUBLE:\t\t\t\t\t\t\t\\\n+    return 7;\n+\n+/* Costs of various Xtensa operations.  */\n+#define RTX_COSTS(X, CODE, OUTER_CODE)\t\t\t\t\t\\\n+  case MEM:\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+\tint num_words =\t\t\t\t\t\t\t\\\n+\t  (GET_MODE_SIZE (GET_MODE (X)) > UNITS_PER_WORD) ?  2 : 1;\t\\\n+\tif (memory_address_p (GET_MODE (X), XEXP ((X), 0)))\t\t\\\n+\t  return COSTS_N_INSNS (num_words);\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+\treturn COSTS_N_INSNS (2*num_words);\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  case FFS:\t\t\t\t\t\t\t\t\\\n+    return COSTS_N_INSNS (TARGET_NSA ? 5 : 50);\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  case NOT:\t\t\t\t\t\t\t\t\\\n+    return COSTS_N_INSNS ((GET_MODE (X) == DImode) ? 3 : 2);\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  case AND:\t\t\t\t\t\t\t\t\\\n+  case IOR:\t\t\t\t\t\t\t\t\\\n+  case XOR:\t\t\t\t\t\t\t\t\\\n+    if (GET_MODE (X) == DImode) return COSTS_N_INSNS (2);\t\t\\\n+    return COSTS_N_INSNS (1);\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  case ASHIFT:\t\t\t\t\t\t\t\t\\\n+  case ASHIFTRT:\t\t\t\t\t\t\t\\\n+  case LSHIFTRT:\t\t\t\t\t\t\t\\\n+    if (GET_MODE (X) == DImode) return COSTS_N_INSNS (50);\t\t\\\n+    return COSTS_N_INSNS (1);\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  case ABS:\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+\tenum machine_mode xmode = GET_MODE (X);\t\t\t\t\\\n+\tif (xmode == SFmode)\t\t\t\t\t\t\\\n+\t  return COSTS_N_INSNS (TARGET_HARD_FLOAT ? 1 : 50);\t\t\\\n+\tif (xmode == DFmode)\t\t\t\t\t\t\\\n+\t  return COSTS_N_INSNS (50);\t\t\t\t\t\\\n+\treturn COSTS_N_INSNS (4);\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  case PLUS:\t\t\t\t\t\t\t\t\\\n+  case MINUS:\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+\tenum machine_mode xmode = GET_MODE (X);\t\t\t\t\\\n+\tif (xmode == SFmode)\t\t\t\t\t\t\\\n+\t  return COSTS_N_INSNS (TARGET_HARD_FLOAT ? 1 : 50);\t\t\\\n+\tif (xmode == DFmode || xmode == DImode)\t\t\t\t\\\n+\t  return COSTS_N_INSNS (50);\t\t\t\t\t\\\n+\treturn COSTS_N_INSNS (1);\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  case NEG:\t\t\t\t\t\t\t\t\\\n+    return COSTS_N_INSNS ((GET_MODE (X) == DImode) ? 4 : 2);\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  case MULT:\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+\tenum machine_mode xmode = GET_MODE (X);\t\t\t\t\\\n+\tif (xmode == SFmode)\t\t\t\t\t\t\\\n+\t  return COSTS_N_INSNS (TARGET_HARD_FLOAT ? 4 : 50);\t\t\\\n+\tif (xmode == DFmode || xmode == DImode)\t\t\t\t\\\n+\t    return COSTS_N_INSNS (50);\t\t\t\t\t\\\n+\tif (TARGET_MUL32)\t\t\t\t\t\t\\\n+\t  return COSTS_N_INSNS (4);\t\t\t\t\t\\\n+\tif (TARGET_MAC16)\t\t\t\t\t\t\\\n+\t  return COSTS_N_INSNS (16);\t\t\t\t\t\\\n+\tif (TARGET_MUL16)\t\t\t\t\t\t\\\n+\t  return COSTS_N_INSNS (12);\t\t\t\t\t\\\n+\treturn COSTS_N_INSNS (50);\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  case DIV:\t\t\t\t\t\t\t\t\\\n+  case MOD:\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+\tenum machine_mode xmode = GET_MODE (X);\t\t\t\t\\\n+\tif (xmode == SFmode)\t\t\t\t\t\t\\\n+\t  return COSTS_N_INSNS (TARGET_HARD_FLOAT_DIV ? 8 : 50);\t\\\n+\tif (xmode == DFmode)\t\t\t\t\t\t\\\n+\t  return COSTS_N_INSNS (50);\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+    /* fall through */\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  case UDIV:\t\t\t\t\t\t\t\t\\\n+  case UMOD:\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+\tenum machine_mode xmode = GET_MODE (X);\t\t\t\t\\\n+\tif (xmode == DImode)\t\t\t\t\t\t\\\n+\t  return COSTS_N_INSNS (50);\t\t\t\t\t\\\n+\tif (TARGET_DIV32)\t\t\t\t\t\t\\\n+\t  return COSTS_N_INSNS (32);\t\t\t\t\t\\\n+\treturn COSTS_N_INSNS (50);\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  case SQRT:\t\t\t\t\t\t\t\t\\\n+    if (GET_MODE (X) == SFmode)\t\t\t\t\t\t\\\n+      return COSTS_N_INSNS (TARGET_HARD_FLOAT_SQRT ? 8 : 50);\t\t\\\n+    return COSTS_N_INSNS (50);\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  case SMIN:\t\t\t\t\t\t\t\t\\\n+  case UMIN:\t\t\t\t\t\t\t\t\\\n+  case SMAX:\t\t\t\t\t\t\t\t\\\n+  case UMAX:\t\t\t\t\t\t\t\t\\\n+    return COSTS_N_INSNS (TARGET_MINMAX ? 1 : 50);\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  case SIGN_EXTRACT:\t\t\t\t\t\t\t\\\n+  case SIGN_EXTEND:\t\t\t\t\t\t\t\\\n+    return COSTS_N_INSNS (TARGET_SEXT ? 1 : 2);\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  case ZERO_EXTRACT:\t\t\t\t\t\t\t\\\n+  case ZERO_EXTEND:\t\t\t\t\t\t\t\\\n+    return COSTS_N_INSNS (1);\n+\n+\n+/* An expression giving the cost of an addressing mode that\n+   contains ADDRESS.  */\n+#define ADDRESS_COST(ADDR) 1\n+\n+/* A C expression for the cost of moving data from a register in\n+   class FROM to one in class TO.  The classes are expressed using\n+   the enumeration values such as 'GENERAL_REGS'.  A value of 2 is\n+   the default; other values are interpreted relative to that.  */\n+#define REGISTER_MOVE_COST(MODE, FROM, TO)\t\t\t\t\\\n+  (((FROM) == (TO) && (FROM) != BR_REGS && (TO) != BR_REGS)\t\t\\\n+   ? 2\t\t\t\t\t\t\t\t\t\\\n+   : (reg_class_subset_p ((FROM), AR_REGS)\t\t\t\t\\\n+      && reg_class_subset_p ((TO), AR_REGS)\t\t\t\t\\\n+      ? 2\t\t\t\t\t\t\t\t\\\n+      : (reg_class_subset_p ((FROM), AR_REGS)\t\t\t\t\\\n+\t && (TO) == ACC_REG\t\t\t\t\t\t\\\n+\t ? 3\t\t\t\t\t\t\t\t\\\n+\t : ((FROM) == ACC_REG\t\t\t\t\t\t\\\n+\t    && reg_class_subset_p ((TO), AR_REGS)\t\t\t\\\n+\t    ? 3\t\t\t\t\t\t\t\t\\\n+\t    : 10))))\n+\n+#define MEMORY_MOVE_COST(MODE, CLASS, IN) 4\n+\n+#define BRANCH_COST 3\n+\n+/* Optionally define this if you have added predicates to\n+   'MACHINE.c'.  This macro is called within an initializer of an\n+   array of structures.  The first field in the structure is the\n+   name of a predicate and the second field is an array of rtl\n+   codes.  For each predicate, list all rtl codes that can be in\n+   expressions matched by the predicate.  The list should have a\n+   trailing comma.  */\n+\n+#define PREDICATE_CODES\t\t\t\t\t\t\t\\\n+  {\"add_operand\",\t\t{ REG, CONST_INT, SUBREG }},\t\t\\\n+  {\"arith_operand\",\t\t{ REG, CONST_INT, SUBREG }},\t\t\\\n+  {\"nonimmed_operand\",\t\t{ REG, SUBREG, MEM }},\t\t\t\\\n+  {\"non_acc_reg_operand\",\t{ REG, SUBREG }},\t\t\t\\\n+  {\"mem_operand\",\t\t{ MEM }},\t\t\t\t\\\n+  {\"mask_operand\",\t\t{ REG, CONST_INT, SUBREG }},\t\t\\\n+  {\"extui_fldsz_operand\",\t{ CONST_INT }},\t\t\t\t\\\n+  {\"sext_fldsz_operand\",\t{ CONST_INT }},\t\t\t\t\\\n+  {\"lsbitnum_operand\",\t\t{ CONST_INT }},\t\t\t\t\\\n+  {\"fpmem_offset_operand\",\t{ CONST_INT }},\t\t\t\t\\\n+  {\"sext_operand\",\t\t{ REG, SUBREG, MEM }},\t\t\t\\\n+  {\"branch_operand\",\t\t{ REG, CONST_INT, SUBREG }},\t\t\\\n+  {\"ubranch_operand\",\t\t{ REG, CONST_INT, SUBREG }},\t\t\\\n+  {\"call_insn_operand\",\t\t{ CONST_INT, CONST, SYMBOL_REF, REG }},\t\\\n+  {\"move_operand\",\t\t{ REG, SUBREG, MEM, CONST_INT, CONST_DOUBLE, \\\n+\t\t\t\t  CONST, SYMBOL_REF, LABEL_REF }},\t\\\n+  {\"non_const_move_operand\",\t{ REG, SUBREG, MEM }},\t\t\t\\\n+  {\"const_float_1_operand\",\t{ CONST_DOUBLE }},\t\t\t\\\n+  {\"branch_operator\",\t\t{ EQ, NE, LT, GE }},\t\t\t\\\n+  {\"ubranch_operator\",\t\t{ LTU, GEU }},\t\t\t\t\\\n+  {\"boolean_operator\",\t\t{ EQ, NE }},\n+\n+/* Control the assembler format that we output.  */\n+\n+/* How to refer to registers in assembler output.\n+   This sequence is indexed by compiler's hard-register-number (see above). */\n+#define REGISTER_NAMES\t\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  \"a0\",   \"sp\",   \"a2\",   \"a3\",   \"a4\",   \"a5\",   \"a6\",   \"a7\",\t\t\\\n+  \"a8\",   \"a9\",   \"a10\",  \"a11\",  \"a12\",  \"a13\",  \"a14\",  \"a15\",\t\\\n+  \"fp\",   \"argp\", \"b0\",\t\t\t\t\t\t\t\\\n+  \"f0\",   \"f1\",   \"f2\",   \"f3\",   \"f4\",   \"f5\",   \"f6\",   \"f7\",\t\t\\\n+  \"f8\",   \"f9\",   \"f10\",  \"f11\",  \"f12\",  \"f13\",  \"f14\",  \"f15\",\t\\\n+  \"acc\"\t\t\t\t\t\t\t\t\t\\\n+}\n+\n+/* If defined, a C initializer for an array of structures containing a\n+   name and a register number.  This macro defines additional names\n+   for hard registers, thus allowing the 'asm' option in declarations\n+   to refer to registers using alternate names. */\n+#define ADDITIONAL_REGISTER_NAMES\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  { \"a1\",\t 1 + GP_REG_FIRST }\t\t\t\t\t\\\n+}\n+\n+#define PRINT_OPERAND(FILE, X, CODE) print_operand (FILE, X, CODE)\n+#define PRINT_OPERAND_ADDRESS(FILE, ADDR) print_operand_address (FILE, ADDR)\n+\n+/* Recognize machine-specific patterns that may appear within\n+   constants.  Used for PIC-specific UNSPECs.  */\n+#define OUTPUT_ADDR_CONST_EXTRA(STREAM, X, FAIL)\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    if (flag_pic && GET_CODE (X) == UNSPEC && XVECLEN ((X), 0) == 1)\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\tswitch (XINT ((X), 1))\t\t\t\t\t\t\\\n+\t  {\t\t\t\t\t\t\t\t\\\n+\t  case UNSPEC_PLT:\t\t\t\t\t\t\\\n+\t    output_addr_const ((STREAM), XVECEXP ((X), 0, 0));\t\t\\\n+\t    fputs (\"@PLT\", (STREAM));\t\t\t\t\t\\\n+\t    break;\t\t\t\t\t\t\t\\\n+\t  default:\t\t\t\t\t\t\t\\\n+\t    goto FAIL;\t\t\t\t\t\t\t\\\n+\t  }\t\t\t\t\t\t\t\t\\\n+\tbreak;\t\t\t\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+    else\t\t\t\t\t\t\t\t\\\n+      goto FAIL;\t\t\t\t\t\t\t\\\n+  } while (0)\n+\n+\n+/* This is how to output the definition of a user-level label named NAME,\n+   such as the label on a static function or variable NAME. */\n+#define ASM_OUTPUT_LABEL(STREAM, NAME)\t\t\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    assemble_name (STREAM, NAME);\t\t\t\t\t\\\n+    fputs (\":\\n\", STREAM);\t\t\t\t\t\t\\\n+  } while (0)\n+\n+/* This is how to output a command to make the user-level label named NAME\n+   defined for reference from other files.  */\n+#define ASM_GLOBALIZE_LABEL(STREAM, NAME)\t\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    fputs (\"\\t.global\\t\", STREAM);\t\t\t\t\t\\\n+    assemble_name (STREAM, NAME);\t\t\t\t\t\\\n+    fputs (\"\\n\", STREAM);\t\t\t\t\t\t\\\n+  } while (0)\n+\n+/* This says how to define a global common symbol.  */\n+#define ASM_OUTPUT_COMMON(STREAM, NAME, SIZE, ROUNDED)\t\t\t\\\n+  xtensa_declare_object (STREAM, NAME, \"\\n\\t.comm\\t\", \",%u\\n\", (SIZE))\n+\n+/* This says how to define a local common symbol (ie, not visible to\n+   linker).  */\n+#define ASM_OUTPUT_LOCAL(STREAM, NAME, SIZE, ROUNDED)\t\t\t\\\n+  xtensa_declare_object (STREAM, NAME, \"\\n\\t.lcomm\\t\", \",%u\\n\", (SIZE))\n+\n+/* This is how to output an element of a case-vector that is absolute.  */\n+#define ASM_OUTPUT_ADDR_VEC_ELT(STREAM, VALUE)\t\t\t\t\\\n+  fprintf (STREAM, \"%s%sL%u\\n\", integer_asm_op (4, TRUE),\t\t\\\n+\t   LOCAL_LABEL_PREFIX, VALUE)\n+\n+/* This is how to output an element of a case-vector that is relative.\n+   This is used for pc-relative code. */\n+#define ASM_OUTPUT_ADDR_DIFF_ELT(STREAM, BODY, VALUE, REL)\t\t\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    fprintf (STREAM, \"%s%sL%u-%sL%u\\n\",\tinteger_asm_op (4, TRUE),\t\\\n+\t     LOCAL_LABEL_PREFIX, (VALUE),\t\t\t\t\\\n+\t     LOCAL_LABEL_PREFIX, (REL));\t\t\t\t\\\n+  } while (0)\n+\n+/* This is how to output an assembler line that says to advance the\n+   location counter to a multiple of 2**LOG bytes.  */\n+#define ASM_OUTPUT_ALIGN(STREAM, LOG)\t\t\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    if ((LOG) != 0)\t\t\t\t\t\t\t\\\n+      fprintf (STREAM, \"\\t.align\\t%d\\n\", 1 << (LOG));\t\t\t\\\n+  } while (0)\n+\n+/* Indicate that jump tables go in the text section.  This is\n+   necessary when compiling PIC code.  */\n+#define JUMP_TABLES_IN_TEXT_SECTION (flag_pic)\n+\n+\n+/* Define this macro for the rare case where the RTL needs some sort of\n+   machine-dependent fixup immediately before register allocation is done. \n+\n+   If the stack frame size is too big to fit in the immediate field of\n+   the ENTRY instruction, we need to store the frame size in the\n+   constant pool.  However, the code in xtensa_function_prologue runs too\n+   late to be able to add anything to the constant pool.  Since the\n+   final frame size isn't known until reload is complete, this seems\n+   like the best place to do it.\n+\n+   There may also be some fixup required if there is an incoming argument\n+   in a7 and the function requires a frame pointer. */\n+\n+#define MACHINE_DEPENDENT_REORG(INSN) xtensa_reorg (INSN)\n+\n+\n+/* Define the strings to put out for each section in the object file.  */\n+#define TEXT_SECTION_ASM_OP\t\"\\t.text\"  \t/* instructions */\n+#define DATA_SECTION_ASM_OP\t\"\\t.data\" \t/* large data */\n+\n+\n+/* Define output to appear before the constant pool.  If the function\n+   has been assigned to a specific ELF section, or if it goes into a\n+   unique section, set the name of that section to be the literal\n+   prefix. */\n+#define ASM_OUTPUT_POOL_PROLOGUE(FILE, FUNNAME, FUNDECL, SIZE)          \\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    tree fnsection;\t\t\t\t\t\t\t\\\n+    resolve_unique_section ((FUNDECL), 0);\t\t\t\t\\\n+    fnsection = DECL_SECTION_NAME (FUNDECL);\t\t\t\t\\\n+    if (fnsection != NULL_TREE)\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\tconst char *fnsectname = TREE_STRING_POINTER (fnsection);\t\\\n+\tfprintf (FILE, \"\\t.begin\\tliteral_prefix %s\\n\",\t\t\t\\\n+\t\t strcmp (fnsectname, \".text\") ? fnsectname : \"\");\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+  } while (0)\n+\n+\n+/* Define code to write out the \".end literal_prefix\" directive for a\n+   function in a special section.  This is appended to the standard ELF\n+   code for ASM_DECLARE_FUNCTION_SIZE.  */\n+#define XTENSA_DECLARE_FUNCTION_SIZE(FILE, FNAME, DECL)\t\t\t\\\n+  if (DECL_SECTION_NAME (DECL) != NULL_TREE)\t\t\t\t\\\n+    fprintf (FILE, \"\\t.end\\tliteral_prefix\\n\")\n+\n+/* A C statement (with or without semicolon) to output a constant in\n+   the constant pool, if it needs special treatment.  */\n+#define ASM_OUTPUT_SPECIAL_POOL_ENTRY(FILE, X, MODE, ALIGN, LABELNO, JUMPTO) \\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    xtensa_output_literal (FILE, X, MODE, LABELNO);\t\t\t\\\n+    goto JUMPTO;\t\t\t\t\t\t\t\\\n+  } while (0)\n+\n+/* Store in OUTPUT a string (made with alloca) containing\n+   an assembler-name for a local static variable named NAME.\n+   LABELNO is an integer which is different for each call.  */\n+#define ASM_FORMAT_PRIVATE_NAME(OUTPUT, NAME, LABELNO)\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    (OUTPUT) = (char *) alloca (strlen (NAME) + 10);\t\t\t\\\n+    sprintf ((OUTPUT), \"%s.%u\", (NAME), (LABELNO));\t\t\t\\\n+  } while (0)\n+\n+/* How to start an assembler comment. */\n+#define ASM_COMMENT_START \"#\"\n+\n+/* Exception handling TODO!! */\n+#define DWARF_UNWIND_INFO 0\n+"}, {"sha": "d1fd5edf4c7b37f63db304dea3a697a76e2c277f", "filename": "gcc/config/xtensa/xtensa.md", "status": "added", "additions": 2415, "deletions": 0, "changes": 2415, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/039843087a884e96058fd0fcde72339974d49e81/gcc%2Fconfig%2Fxtensa%2Fxtensa.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/039843087a884e96058fd0fcde72339974d49e81/gcc%2Fconfig%2Fxtensa%2Fxtensa.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Fxtensa.md?ref=039843087a884e96058fd0fcde72339974d49e81", "patch": "@@ -0,0 +1,2415 @@\n+;; GCC machine description for Tensilica's Xtensa architecture.\n+;; Copyright (C) 2001 Free Software Foundation, Inc.\n+;; Contributed by Bob Wilson (bwilson@tensilica.com) at Tensilica.\n+\n+;; This file is part of GCC.\n+\n+;; GCC is free software; you can redistribute it and/or modify it\n+;; under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 2, or (at your option)\n+;; any later version.\n+\n+;; GCC is distributed in the hope that it will be useful, but WITHOUT\n+;; ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+;; or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+;; License for more details.\n+\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING.  If not, write to the Free\n+;; Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n+;; 02111-1307, USA.\n+\n+;;\n+;; ....................\n+;;\n+;;\tCONSTANTS\n+;;\n+;; ....................\n+;;\n+\n+(define_constants [\n+  (A0_REG\t\t0)\n+  (A7_REG\t\t7)\n+\n+  (UNSPEC_NSAU\t\t1)\n+  (UNSPEC_NOP\t\t2)\n+  (UNSPEC_PLT\t\t3)\n+  (UNSPECV_SET_FP\t1)\n+])\n+\n+;;\n+;; ....................\n+;;\n+;;\tATTRIBUTES\n+;;\n+;; ....................\n+;;\n+\n+(define_attr \"type\"\n+  \"unknown,branch,jump,call,load,store,move,arith,multi,nop,misc,farith,fmadd,fdiv,fsqrt,fconv,fload,fstore,mul16,mul32,div32,mac16,rsr,wsr,udef_move,udef_loadi,udef_storei,udef_loadiu,udef_storeiu,udef_conv,udef_conv_loadiu,udef_conv_storeiu\" \n+  (const_string \"unknown\"))\n+\n+(define_attr \"mode\"\n+  \"unknown,none,QI,HI,SI,DI,SF,DF,BL\"\n+  (const_string \"unknown\"))\n+\n+(define_attr \"length\" \"\" (const_int 1))\n+\n+;; Describe a user's asm statement.\n+(define_asm_attributes\n+  [(set_attr \"type\" \"multi\")])\n+\n+\n+;;\n+;; ....................\n+;;\n+;;\tFUNCTIONAL UNITS\n+;;\n+;; ....................\n+;;\n+\n+(define_function_unit \"memory\" 1 0 (eq_attr \"type\" \"load,fload\") 2 0)\n+\n+(define_function_unit \"sreg\" 1 1 (eq_attr \"type\" \"rsr\") 2 0)\n+\n+(define_function_unit \"mul16\" 1 0 (eq_attr \"type\" \"mul16\") 2 0)\n+\n+(define_function_unit \"mul32\" 1 0 (eq_attr \"type\" \"mul32\") 2 0)\n+\n+(define_function_unit \"fpmadd\" 1 0 (eq_attr \"type\" \"fmadd\") 4 0)\n+\n+(define_function_unit \"fpconv\" 1 0 (eq_attr \"type\" \"fconv\") 2 0)\n+\n+\n+;;\n+;;  ....................\n+;;\n+;;\tADDITION\n+;;\n+;;  ....................\n+;;\n+\n+(define_insn \"addsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=D,D,a,a,a\")\n+\t(plus:SI (match_operand:SI 1 \"register_operand\" \"%d,d,r,r,r\")\n+\t\t (match_operand:SI 2 \"add_operand\" \"d,O,r,J,N\")))]\n+  \"\"\n+  \"@\n+   add.n\\\\t%0, %1, %2\n+   addi.n\\\\t%0, %1, %d2\n+   add\\\\t%0, %1, %2\n+   addi\\\\t%0, %1, %d2\n+   addmi\\\\t%0, %1, %x2\"\n+  [(set_attr \"type\"\t\"arith,arith,arith,arith,arith\")\n+   (set_attr \"mode\"\t\"SI\")\n+   (set_attr \"length\"\t\"2,2,3,3,3\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=a\")\n+\t(plus:SI (mult:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t\t  (const_int 2))\n+\t\t (match_operand:SI 2 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"addx2\\\\t%0, %1, %2\"\n+  [(set_attr \"type\"\t\"arith\")\n+   (set_attr \"mode\"\t\"SI\")\n+   (set_attr \"length\"\t\"3\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=a\")\n+\t(plus:SI (mult:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t\t  (const_int 4))\n+\t\t (match_operand:SI 2 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"addx4\\\\t%0, %1, %2\"\n+  [(set_attr \"type\"\t\"arith\")\n+   (set_attr \"mode\"\t\"SI\")\n+   (set_attr \"length\"\t\"3\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=a\")\n+\t(plus:SI (mult:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t\t  (const_int 8))\n+\t\t (match_operand:SI 2 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"addx8\\\\t%0, %1, %2\"\n+  [(set_attr \"type\"\t\"arith\")\n+   (set_attr \"mode\"\t\"SI\")\n+   (set_attr \"length\"\t\"3\")])\n+\n+(define_insn \"addsf3\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n+\t(plus:SF (match_operand:SF 1 \"register_operand\" \"%f\")\n+\t\t (match_operand:SF 2 \"register_operand\" \"f\")))]\n+  \"TARGET_HARD_FLOAT\"\n+  \"add.s\\\\t%0, %1, %2\"\n+  [(set_attr \"type\"\t\"fmadd\")\n+   (set_attr \"mode\"\t\"SF\")\n+   (set_attr \"length\"\t\"3\")])\n+\n+\n+;;\n+;;  ....................\n+;;\n+;;\tSUBTRACTION\n+;;\n+;;  ....................\n+;;\n+\n+(define_insn \"subsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=a\")\n+        (minus:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t  (match_operand:SI 2 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"sub\\\\t%0, %1, %2\"\n+  [(set_attr \"type\"\t\"arith\")\n+   (set_attr \"mode\"\t\"SI\")\n+   (set_attr \"length\"\t\"3\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=a\")\n+\t(minus:SI (mult:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t\t   (const_int 2))\n+\t\t  (match_operand:SI 2 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"subx2\\\\t%0, %1, %2\"\n+  [(set_attr \"type\"\t\"arith\")\n+   (set_attr \"mode\"\t\"SI\")\n+   (set_attr \"length\"\t\"3\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=a\")\n+\t(minus:SI (mult:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t\t   (const_int 4))\n+\t\t  (match_operand:SI 2 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"subx4\\\\t%0, %1, %2\"\n+  [(set_attr \"type\"\t\"arith\")\n+   (set_attr \"mode\"\t\"SI\")\n+   (set_attr \"length\"\t\"3\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=a\")\n+\t(minus:SI (mult:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t\t   (const_int 8))\n+\t\t  (match_operand:SI 2 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"subx8\\\\t%0, %1, %2\"\n+  [(set_attr \"type\"\t\"arith\")\n+   (set_attr \"mode\"\t\"SI\")\n+   (set_attr \"length\"\t\"3\")])\n+\n+(define_insn \"subsf3\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n+\t(minus:SF (match_operand:SF 1 \"register_operand\" \"f\")\n+\t\t  (match_operand:SF 2 \"register_operand\" \"f\")))]\n+  \"TARGET_HARD_FLOAT\"\n+  \"sub.s\\\\t%0, %1, %2\"\n+  [(set_attr \"type\"\t\"fmadd\")\n+   (set_attr \"mode\"\t\"SF\")\n+   (set_attr \"length\"\t\"3\")])\n+\n+\n+;;\n+;;  ....................\n+;;\n+;;\tMULTIPLICATION\n+;;\n+;;  ....................\n+;;\n+\n+(define_insn \"mulsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=a\")\n+\t(mult:SI (match_operand:SI 1 \"register_operand\" \"%r\")\n+\t\t (match_operand:SI 2 \"register_operand\" \"r\")))]\n+  \"TARGET_MUL32\"\n+  \"mull\\\\t%0, %1, %2\"\n+  [(set_attr \"type\"\t\"mul32\")\n+   (set_attr \"mode\"\t\"SI\")\n+   (set_attr \"length\"\t\"3\")])\n+\n+(define_insn \"mulhisi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=C,A\")\n+\t(mult:SI (sign_extend:SI\n+\t\t  (match_operand:HI 1 \"register_operand\" \"%r,r\"))\n+\t\t (sign_extend:SI\n+\t\t  (match_operand:HI 2 \"register_operand\" \"r,r\"))))]\n+  \"TARGET_MUL16 || TARGET_MAC16\"\n+  \"@\n+   mul16s\\\\t%0, %1, %2\n+   mul.aa.ll\\\\t%1, %2\"\n+  [(set_attr \"type\"\t\"mul16,mac16\")\n+   (set_attr \"mode\"\t\"SI\")\n+   (set_attr \"length\"\t\"3,3\")])\n+\n+(define_insn \"umulhisi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=C,A\")\n+\t(mult:SI (zero_extend:SI\n+\t\t  (match_operand:HI 1 \"register_operand\" \"%r,r\"))\n+\t\t (zero_extend:SI\n+\t\t  (match_operand:HI 2 \"register_operand\" \"r,r\"))))]\n+  \"TARGET_MUL16 || TARGET_MAC16\"\n+  \"@\n+   mul16u\\\\t%0, %1, %2\n+   umul.aa.ll\\\\t%1, %2\"\n+  [(set_attr \"type\"\t\"mul16,mac16\")\n+   (set_attr \"mode\"\t\"SI\")\n+   (set_attr \"length\"\t\"3,3\")])\n+\n+(define_insn \"muladdhisi\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=A\")\n+\t(plus:SI (mult:SI (sign_extend:SI\n+\t\t\t   (match_operand:HI 1 \"register_operand\" \"%r\"))\n+\t\t\t  (sign_extend:SI\n+\t\t\t   (match_operand:HI 2 \"register_operand\" \"r\")))\n+\t\t (match_operand:SI 3 \"register_operand\" \"0\")))]\n+  \"TARGET_MAC16\"\n+  \"mula.aa.ll\\\\t%1, %2\"\n+  [(set_attr \"type\"\t\"mac16\")\n+   (set_attr \"mode\"\t\"SI\")\n+   (set_attr \"length\"\t\"3\")])\n+\n+(define_insn \"mulsubhisi\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=A\")\n+\t(minus:SI (match_operand:SI 1 \"register_operand\" \"0\")\n+\t\t  (mult:SI (sign_extend:SI\n+\t\t\t    (match_operand:HI 2 \"register_operand\" \"%r\"))\n+\t\t\t   (sign_extend:SI\n+\t\t\t    (match_operand:HI 3 \"register_operand\" \"r\")))))]\n+  \"TARGET_MAC16\"\n+  \"muls.aa.ll\\\\t%2, %3\"\n+  [(set_attr \"type\"\t\"mac16\")\n+   (set_attr \"mode\"\t\"SI\")\n+   (set_attr \"length\"\t\"3\")])\n+\n+(define_insn \"mulsf3\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n+\t(mult:SF (match_operand:SF 1 \"register_operand\" \"%f\")\n+\t\t (match_operand:SF 2 \"register_operand\" \"f\")))]\n+  \"TARGET_HARD_FLOAT\"\n+  \"mul.s\\\\t%0, %1, %2\"\n+  [(set_attr \"type\"\t\"fmadd\")\n+   (set_attr \"mode\"\t\"SF\")\n+   (set_attr \"length\"\t\"3\")])\n+\n+(define_insn \"muladdsf3\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n+\t(plus:SF (mult:SF (match_operand:SF 1 \"register_operand\" \"%f\")\n+\t\t\t  (match_operand:SF 2 \"register_operand\" \"f\"))\n+\t\t (match_operand:SF 3 \"register_operand\" \"0\")))]\n+  \"TARGET_HARD_FLOAT && !TARGET_NO_FUSED_MADD\"\n+  \"madd.s\\\\t%0, %1, %2\"\n+  [(set_attr \"type\"\t\"fmadd\")\n+   (set_attr \"mode\"\t\"SF\")\n+   (set_attr \"length\"\t\"3\")])\n+\n+(define_insn \"mulsubsf3\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n+\t(minus:SF (match_operand:SF 1 \"register_operand\" \"0\")\n+\t\t  (mult:SF (match_operand:SF 2 \"register_operand\" \"%f\")\n+\t\t\t   (match_operand:SF 3 \"register_operand\" \"f\"))))]\n+  \"TARGET_HARD_FLOAT && !TARGET_NO_FUSED_MADD\"\n+  \"msub.s\\\\t%0, %2, %3\"\n+  [(set_attr \"type\"\t\"fmadd\")\n+   (set_attr \"mode\"\t\"SF\")\n+   (set_attr \"length\"\t\"3\")])\n+\n+\n+;;\n+;;  ....................\n+;;\n+;;\tDIVISION\n+;;\n+;;  ....................\n+;;\n+\n+(define_insn \"divsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=a\")\n+\t(div:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t(match_operand:SI 2 \"register_operand\" \"r\")))]\n+  \"TARGET_DIV32\"\n+  \"quos\\\\t%0, %1, %2\"\n+  [(set_attr \"type\"\t\"div32\")\n+   (set_attr \"mode\"\t\"SI\")\n+   (set_attr \"length\"\t\"3\")])\n+\n+(define_insn \"udivsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=a\")\n+\t(udiv:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t (match_operand:SI 2 \"register_operand\" \"r\")))]\n+  \"TARGET_DIV32\"\n+  \"quou\\\\t%0, %1, %2\"\n+  [(set_attr \"type\"\t\"div32\")\n+   (set_attr \"mode\"\t\"SI\")\n+   (set_attr \"length\"\t\"3\")])\n+\n+(define_insn \"divsf3\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n+\t(div:SF (match_operand:SF 1 \"register_operand\" \"f\")\n+\t\t(match_operand:SF 2 \"register_operand\" \"f\")))]\n+  \"TARGET_HARD_FLOAT_DIV\"\n+  \"div.s\\\\t%0, %1, %2\"\n+  [(set_attr \"type\"\t\"fdiv\")\n+   (set_attr \"mode\"\t\"SF\")\n+   (set_attr \"length\"\t\"3\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n+\t(div:SF (match_operand:SF 1 \"const_float_1_operand\" \"\")\n+\t\t(match_operand:SF 2 \"register_operand\" \"f\")))]\n+  \"TARGET_HARD_FLOAT_RECIP && flag_unsafe_math_optimizations\"\n+  \"recip.s\\\\t%0, %2\"\n+  [(set_attr \"type\"\t\"fdiv\")\n+   (set_attr \"mode\"\t\"SF\")\n+   (set_attr \"length\"\t\"3\")])\n+\n+\n+;;\n+;;  ....................\n+;;\n+;;\tREMAINDER\n+;;\n+;;  ....................\n+;;\n+\n+(define_insn \"modsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=a\")\n+\t(mod:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t(match_operand:SI 2 \"register_operand\" \"r\")))]\n+  \"TARGET_DIV32\"\n+  \"rems\\\\t%0, %1, %2\"\n+  [(set_attr \"type\"\t\"div32\")\n+   (set_attr \"mode\"\t\"SI\")\n+   (set_attr \"length\"\t\"3\")])\n+\n+(define_insn \"umodsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=a\")\n+\t(umod:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t (match_operand:SI 2 \"register_operand\" \"r\")))]\n+  \"TARGET_DIV32\"\n+  \"remu\\\\t%0, %1, %2\"\n+  [(set_attr \"type\"\t\"div32\")\n+   (set_attr \"mode\"\t\"SI\")\n+   (set_attr \"length\"\t\"3\")])\n+\n+\n+;;\n+;;  ....................\n+;;\n+;;\tSQUARE ROOT\n+;;\n+;;  ....................\n+;;\n+\n+(define_insn \"sqrtsf2\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n+\t(sqrt:SF (match_operand:SF 1 \"register_operand\" \"f\")))]\n+  \"TARGET_HARD_FLOAT_SQRT\"\n+  \"sqrt.s\\\\t%0, %1\"\n+  [(set_attr \"type\"\t\"fsqrt\")\n+   (set_attr \"mode\"\t\"SF\")\n+   (set_attr \"length\"\t\"3\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n+\t(div:SF (match_operand:SF 1 \"const_float_1_operand\" \"\")\n+\t\t(sqrt:SF (match_operand:SF 2 \"register_operand\" \"f\"))))]\n+  \"TARGET_HARD_FLOAT_RSQRT && flag_unsafe_math_optimizations\"\n+  \"rsqrt.s\\\\t%0, %2\"\n+  [(set_attr \"type\"\t\"fsqrt\")\n+   (set_attr \"mode\"\t\"SF\")\n+   (set_attr \"length\"\t\"3\")])\n+\n+\n+;;\n+;;  ....................\n+;;\n+;;\tABSOLUTE VALUE\n+;;\n+;;  ....................\n+;;\n+\n+(define_insn \"abssi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=a\")\n+\t(abs:SI (match_operand:SI 1 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"abs\\\\t%0, %1\"\n+  [(set_attr \"type\"\t\"arith\")\n+   (set_attr \"mode\"\t\"SI\")\n+   (set_attr \"length\"\t\"3\")])\n+\n+(define_insn \"abssf2\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n+\t(abs:SF (match_operand:SF 1 \"register_operand\" \"f\")))]\n+  \"TARGET_HARD_FLOAT\"\n+  \"abs.s\\\\t%0, %1\"\n+  [(set_attr \"type\"\t\"farith\")\n+   (set_attr \"mode\"\t\"SF\")\n+   (set_attr \"length\"\t\"3\")])\n+\n+\n+;;\n+;;  ....................\n+;;\n+;;\tMIN AND MAX INSTRUCTIONS\n+;;\n+;;  ....................\n+;;\n+\n+(define_insn \"sminsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=a\")\n+        (smin:SI (match_operand:SI 1 \"register_operand\" \"%r\")\n+                 (match_operand:SI 2 \"register_operand\" \"r\")))]\n+  \"TARGET_MINMAX\"\n+  \"min\\\\t%0, %1, %2\"\n+  [(set_attr \"type\"\t\"arith\")\n+   (set_attr \"mode\"\t\"SI\")\n+   (set_attr \"length\"\t\"3\")])\n+\n+(define_insn \"uminsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=a\")\n+        (umin:SI (match_operand:SI 1 \"register_operand\" \"%r\")\n+                 (match_operand:SI 2 \"register_operand\" \"r\")))]\n+  \"TARGET_MINMAX\"\n+  \"minu\\\\t%0, %1, %2\"\n+  [(set_attr \"type\"\t\"arith\")\n+   (set_attr \"mode\"\t\"SI\")\n+   (set_attr \"length\"\t\"3\")])\n+\n+(define_insn \"smaxsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=a\")\n+        (smax:SI (match_operand:SI 1 \"register_operand\" \"%r\")\n+                 (match_operand:SI 2 \"register_operand\" \"r\")))]\n+  \"TARGET_MINMAX\"\n+  \"max\\\\t%0, %1, %2\"\n+  [(set_attr \"type\"\t\"arith\")\n+   (set_attr \"mode\"\t\"SI\")\n+   (set_attr \"length\"\t\"3\")])\n+\n+(define_insn \"umaxsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=a\")\n+        (umax:SI (match_operand:SI 1 \"register_operand\" \"%r\")\n+                 (match_operand:SI 2 \"register_operand\" \"r\")))]\n+  \"TARGET_MINMAX\"\n+  \"maxu\\\\t%0, %1, %2\"\n+  [(set_attr \"type\"\t\"arith\")\n+   (set_attr \"mode\"\t\"SI\")\n+   (set_attr \"length\"\t\"3\")])\n+\n+\n+;;\n+;;  ....................\n+;;\n+;;\tFIND FIRST BIT INSTRUCTION\n+;;\n+;;  ....................\n+;;\n+\n+(define_expand \"ffssi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(ffs:SI (match_operand:SI 1 \"register_operand\" \"\")))]\n+  \"TARGET_NSA\"\n+  \"\n+{\n+  rtx temp = gen_reg_rtx (SImode);\n+  emit_insn (gen_negsi2 (temp, operands[1]));\n+  emit_insn (gen_andsi3 (temp, temp, operands[1]));\n+  emit_insn (gen_nsau (temp, temp));\n+  emit_insn (gen_negsi2 (temp, temp));\n+  emit_insn (gen_addsi3 (operands[0], temp, GEN_INT (32)));\n+  DONE;\n+}\")\n+\n+;; there is no RTL operator corresponding to NSAU\n+(define_insn \"nsau\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=a\")\n+\t(unspec:SI [(match_operand:SI 1 \"register_operand\" \"r\")] UNSPEC_NSAU))]\n+  \"TARGET_NSA\"\n+  \"nsau\\\\t%0, %1\"\n+  [(set_attr \"type\"\t\"arith\")\n+   (set_attr \"mode\"\t\"SI\")\n+   (set_attr \"length\"\t\"3\")])\n+\n+\n+;;\n+;;  ....................\n+;;\n+;;\tNEGATION and ONE'S COMPLEMENT\n+;;\n+;;  ....................\n+;;\n+\n+(define_insn \"negsi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=a\")\n+\t(neg:SI (match_operand:SI 1 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"neg\\\\t%0, %1\"\n+  [(set_attr \"type\"\t\"arith\")\n+   (set_attr \"mode\"\t\"SI\")\n+   (set_attr \"length\"\t\"3\")])\n+\n+(define_expand \"one_cmplsi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(not:SI (match_operand:SI 1 \"register_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  rtx temp = gen_reg_rtx (SImode);\n+  emit_insn (gen_movsi (temp, constm1_rtx));\n+  emit_insn (gen_xorsi3 (operands[0], temp, operands[1]));\n+  DONE;\n+}\")\n+\n+(define_insn \"negsf2\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n+\t(neg:SF (match_operand:SF 1 \"register_operand\" \"f\")))]\n+  \"TARGET_HARD_FLOAT\"\n+  \"neg.s\\\\t%0, %1\"\n+  [(set_attr \"type\"\t\"farith\")\n+   (set_attr \"mode\"\t\"SF\")\n+   (set_attr \"length\"\t\"3\")])\n+\n+\n+;;\n+;;  ....................\n+;;\n+;;\tLOGICAL\n+;;\n+;;  ....................\n+;;\n+\n+(define_insn \"andsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=a,a\")\n+\t(and:SI (match_operand:SI 1 \"register_operand\" \"%r,r\")\n+\t\t(match_operand:SI 2 \"mask_operand\" \"P,r\")))]\n+  \"\"\n+  \"@\n+   extui\\\\t%0, %1, 0, %K2\n+   and\\\\t%0, %1, %2\"\n+  [(set_attr \"type\"\t\"arith,arith\")\n+   (set_attr \"mode\"\t\"SI\")\n+   (set_attr \"length\"\t\"3,3\")])\n+\n+(define_insn \"iorsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=a\")\n+\t(ior:SI (match_operand:SI 1 \"register_operand\" \"%r\")\n+\t\t(match_operand:SI 2 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"or\\\\t%0, %1, %2\"\n+  [(set_attr \"type\"\t\"arith\")\n+   (set_attr \"mode\"\t\"SI\")\n+   (set_attr \"length\"\t\"3\")])\n+\n+(define_insn \"xorsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=a\")\n+\t(xor:SI (match_operand:SI 1 \"register_operand\" \"%r\")\n+\t\t(match_operand:SI 2 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"xor\\\\t%0, %1, %2\"\n+  [(set_attr \"type\"\t\"arith\")\n+   (set_attr \"mode\"\t\"SI\")\n+   (set_attr \"length\"\t\"3\")])\n+\n+\n+;;\n+;;  ....................\n+;;\n+;;\tZERO EXTENSION\n+;;\n+;;  ....................\n+;;\n+\n+(define_insn \"zero_extendhisi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=a,a\")\n+\t(zero_extend:SI (match_operand:HI 1 \"nonimmed_operand\" \"r,U\")))]\n+  \"\"\n+  \"@\n+   extui\\\\t%0, %1, 0, 16\n+   l16ui\\\\t%0, %1\"\n+  [(set_attr \"type\"\t\"arith,load\")\n+   (set_attr \"mode\"\t\"SI\")\n+   (set_attr \"length\"\t\"3,3\")])\n+\n+(define_insn \"zero_extendqisi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=a,a\")\n+\t(zero_extend:SI (match_operand:QI 1 \"nonimmed_operand\" \"r,U\")))]\n+  \"\"\n+  \"@\n+   extui\\\\t%0, %1, 0, 8\n+   l8ui\\\\t%0, %1\"\n+  [(set_attr \"type\"\t\"arith,load\")\n+   (set_attr \"mode\"\t\"SI\")\n+   (set_attr \"length\"\t\"3,3\")])\n+\n+\n+;;\n+;;  ....................\n+;;\n+;;\tSIGN EXTENSION\n+;;\n+;;  ....................\n+;;\n+\n+(define_expand \"extendhisi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(sign_extend:SI (match_operand:HI 1 \"register_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  if (sext_operand (operands[1], HImode))\n+    emit_insn (gen_extendhisi2_internal (operands[0], operands[1]));\n+  else\n+    xtensa_extend_reg (operands[0], operands[1]);\n+  DONE;\n+}\")\n+\n+(define_insn \"extendhisi2_internal\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=B,a\")\n+\t(sign_extend:SI (match_operand:HI 1 \"sext_operand\" \"r,U\")))]\n+  \"\"\n+  \"@\n+   sext\\\\t%0, %1, 15\n+   l16si\\\\t%0, %1\"\n+  [(set_attr \"type\"\t\"arith,load\")\n+   (set_attr \"mode\"\t\"SI\")\n+   (set_attr \"length\"\t\"3,3\")])\n+\n+(define_expand \"extendqisi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(sign_extend:SI (match_operand:QI 1 \"register_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  if (TARGET_SEXT)\n+    {\n+      emit_insn (gen_extendqisi2_internal (operands[0], operands[1]));\n+      DONE;\n+    }\n+  xtensa_extend_reg (operands[0], operands[1]);\n+  DONE;\n+}\")\n+\n+(define_insn \"extendqisi2_internal\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=B\")\n+\t(sign_extend:SI (match_operand:QI 1 \"register_operand\" \"r\")))]\n+  \"TARGET_SEXT\"\n+  \"sext\\\\t%0, %1, 7\"\n+  [(set_attr \"type\"\t\"arith\")\n+   (set_attr \"mode\"\t\"SI\")\n+   (set_attr \"length\"\t\"3\")])\n+\n+\n+;;\n+;;  ....................\n+;;\n+;;\tFIELD EXTRACT\n+;;\n+;;  ....................\n+;;\n+\n+(define_expand \"extv\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(sign_extract:SI (match_operand:SI 1 \"register_operand\" \"\")\n+\t\t\t (match_operand:SI 2 \"const_int_operand\" \"\")\n+\t\t\t (match_operand:SI 3 \"const_int_operand\" \"\")))]\n+  \"TARGET_SEXT\"\n+  \"\n+{\n+  if (!sext_fldsz_operand (operands[2], SImode)) FAIL;\n+  /* we could expand to a right shift followed by sext but that's\n+     no better than the standard left and right shift sequence */\n+  if (!lsbitnum_operand (operands[3], SImode)) FAIL;\n+  emit_insn (gen_extv_internal (operands[0], operands[1],\n+\t\t\t\toperands[2], operands[3]));\n+  DONE;\n+}\")\n+\n+(define_insn \"extv_internal\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=a\")\n+\t(sign_extract:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t\t (match_operand:SI 2 \"sext_fldsz_operand\" \"i\")\n+\t\t\t (match_operand:SI 3 \"lsbitnum_operand\" \"i\")))]\n+  \"TARGET_SEXT\"\n+  \"*\n+{\n+  int fldsz = INTVAL (operands[2]);\n+  operands[2] = GEN_INT (fldsz - 1);\n+  return \\\"sext\\\\t%0, %1, %2\\\";\n+}\"\n+  [(set_attr \"type\"\t\"arith\")\n+   (set_attr \"mode\"\t\"SI\")\n+   (set_attr \"length\"\t\"3\")])\n+\n+(define_expand \"extzv\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(zero_extract:SI (match_operand:SI 1 \"register_operand\" \"\")\n+\t\t\t (match_operand:SI 2 \"const_int_operand\" \"\")\n+\t\t\t (match_operand:SI 3 \"const_int_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  if (!extui_fldsz_operand (operands[2], SImode)) FAIL;\n+  emit_insn (gen_extzv_internal (operands[0], operands[1],\n+\t\t\t\t operands[2], operands[3]));\n+  DONE;\n+}\")\n+\n+(define_insn \"extzv_internal\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=a\")\n+\t(zero_extract:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t\t (match_operand:SI 2 \"extui_fldsz_operand\" \"i\")\n+\t\t\t (match_operand:SI 3 \"const_int_operand\" \"i\")))]\n+  \"\"\n+  \"*\n+{\n+  int shift;\n+  if (BITS_BIG_ENDIAN)\n+    shift = (32 - (INTVAL (operands[2]) + INTVAL (operands[3]))) & 0x1f;\n+  else\n+    shift = INTVAL (operands[3]) & 0x1f;\n+  operands[3] = GEN_INT (shift);\n+  return \\\"extui\\\\t%0, %1, %3, %2\\\";\n+}\"\n+  [(set_attr \"type\"\t\"arith\")\n+   (set_attr \"mode\"\t\"SI\")\n+   (set_attr \"length\"\t\"3\")])\n+\n+\n+;;\n+;;  ....................\n+;;\n+;;\tCONVERSIONS\n+;;\n+;;  ....................\n+;;\n+\n+(define_insn \"fix_truncsfsi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=a\")\n+\t(fix:SI (match_operand:SF 1 \"register_operand\" \"f\")))]\n+  \"TARGET_HARD_FLOAT\"\n+  \"trunc.s\\\\t%0, %1, 0\"\n+  [(set_attr \"type\"\t\"fconv\")\n+   (set_attr \"mode\"\t\"SF\")\n+   (set_attr \"length\"\t\"3\")])\n+\n+(define_insn \"fixuns_truncsfsi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=a\")\n+\t(unsigned_fix:SI (match_operand:SF 1 \"register_operand\" \"f\")))]\n+  \"TARGET_HARD_FLOAT\"\n+  \"utrunc.s %0, %1, 0\"\n+  [(set_attr \"type\"\t\"fconv\")\n+   (set_attr \"mode\"\t\"SF\")\n+   (set_attr \"length\"\t\"3\")])\n+\n+(define_insn \"floatsisf2\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n+\t(float:SF (match_operand:SI 1 \"register_operand\" \"a\")))]\n+  \"TARGET_HARD_FLOAT\"\n+  \"float.s\\\\t%0, %1, 0\"\n+  [(set_attr \"type\"\t\"fconv\")\n+   (set_attr \"mode\"\t\"SF\")\n+   (set_attr \"length\"\t\"3\")])\n+\n+(define_insn \"floatunssisf2\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n+\t(unsigned_float:SF (match_operand:SI 1 \"register_operand\" \"a\")))]\n+  \"TARGET_HARD_FLOAT\"\n+  \"ufloat.s %0, %1, 0\"\n+  [(set_attr \"type\"\t\"fconv\")\n+   (set_attr \"mode\"\t\"SF\")\n+   (set_attr \"length\"\t\"3\")])\n+\n+\n+;;\n+;;  ....................\n+;;\n+;;\tDATA MOVEMENT\n+;;\n+;;  ....................\n+;;\n+\n+;; 64-bit Integer moves\n+\n+(define_expand \"movdi\"\n+  [(set (match_operand:DI 0 \"nonimmed_operand\" \"\")\n+\t(match_operand:DI 1 \"general_operand\" \"\"))]\n+  \"\"\n+  \"\n+{\n+  if (CONSTANT_P (operands[1]))\n+    {\n+      rtx src0, src1, dst0, dst1;\n+      if ((dst0 = operand_subword (operands[0], 0, 1, DImode))\n+\t  && (src0 = operand_subword (operands[1], 0, 1, DImode))\n+\t  && (dst1 = operand_subword (operands[0], 1, 1, DImode))\n+\t  && (src1 = operand_subword (operands[1], 1, 1, DImode)))\n+\t{\n+\t  emit_insn (gen_movsi (dst0, src0));\n+\t  emit_insn (gen_movsi (dst1, src1));\n+\t  DONE;\n+\t}\n+      else\n+\t/* any other constant will be loaded from memory */\n+\toperands[1] = force_const_mem (DImode, operands[1]);\n+    }\n+\n+  if (!(reload_in_progress | reload_completed))\n+    {\n+      if (!register_operand (operands[0], DImode)\n+\t  && !register_operand (operands[1], DImode))\n+\toperands[1] = force_reg (DImode, operands[1]);\n+\n+      if (a7_overlap_mentioned_p (operands[1]))\n+\t{\n+\t  emit_insn (gen_movdi_internal (operands[0], operands[1]));\n+\t  emit_insn (gen_set_frame_ptr ());\n+\t  DONE;\n+\t}\n+    }\n+}\")\n+\n+(define_insn \"movdi_internal\"\n+  [(set (match_operand:DI 0 \"nonimmed_operand\" \"=D,D,S,a,a,a,U\")\n+\t(match_operand:DI 1 \"non_const_move_operand\" \"d,S,d,r,T,U,r\"))]\n+  \"register_operand (operands[0], DImode)\n+   || register_operand (operands[1], DImode)\"\n+  \"*\n+{\n+  switch (which_alternative)\n+    {\n+    case 0: return \\\"mov.n\\\\t%0, %1\\;mov.n\\\\t%D0, %D1\\\";\n+    case 2: return \\\"%v0s32i.n\\\\t%1, %0\\;s32i.n\\\\t%D1, %N0\\\";\n+    case 3: return \\\"mov\\\\t%0, %1\\;mov\\\\t%D0, %D1\\\";\n+    case 6: return \\\"%v0s32i\\\\t%1, %0\\;s32i\\\\t%D1, %N0\\\";\n+\n+    case 1:\n+    case 4:\n+    case 5:\n+      {\n+\t/* Check if the first half of the destination register is used\n+\t   in the source address.  If so, reverse the order of the loads\n+\t   so that the source address doesn't get clobbered until it is\n+\t   no longer needed. */\n+\n+\trtx dstreg = operands[0];\n+\tif (GET_CODE (dstreg) == SUBREG)\n+\t  dstreg = SUBREG_REG (dstreg);\n+\tif (GET_CODE (dstreg) != REG)\n+\t  abort();\n+\n+\tif (reg_mentioned_p (dstreg, operands[1]))\n+\t  {\n+\t    switch (which_alternative)\n+\t      {\n+\t      case 1: return \\\"%v1l32i.n\\\\t%D0, %N1\\;l32i.n\\\\t%0, %1\\\";\n+\t      case 4: return \\\"%v1l32r\\\\t%D0, %N1\\;l32r\\\\t%0, %1\\\";\n+\t      case 5: return \\\"%v1l32i\\\\t%D0, %N1\\;l32i\\\\t%0, %1\\\";\n+\t      }\n+\t  }\n+\telse\n+\t  {\n+\t    switch (which_alternative)\n+\t      {\n+\t      case 1: return \\\"%v1l32i.n\\\\t%0, %1\\;l32i.n\\\\t%D0, %N1\\\";\n+\t      case 4: return \\\"%v1l32r\\\\t%0, %1\\;l32r\\\\t%D0, %N1\\\";\n+\t      case 5: return \\\"%v1l32i\\\\t%0, %1\\;l32i\\\\t%D0, %N1\\\";\n+\t      }\n+\t  }\n+      }\n+    }\n+  abort ();\n+  return \\\"\\\";\n+}\"\n+  [(set_attr \"type\"\t\"move,load,store,move,load,load,store\")\n+   (set_attr \"mode\"\t\"DI\")\n+   (set_attr \"length\"\t\"4,4,4,6,6,6,6\")])\n+\n+\n+;; 32-bit Integer moves\n+\n+(define_expand \"movsi\"\n+  [(set (match_operand:SI 0 \"nonimmed_operand\" \"\")\n+\t(match_operand:SI 1 \"general_operand\" \"\"))]\n+  \"\"\n+  \"\n+{\n+  if (xtensa_emit_move_sequence (operands, SImode))\n+    DONE;\n+}\")\n+\n+(define_insn \"movsi_internal\"\n+  [(set (match_operand:SI 0 \"nonimmed_operand\" \"=D,D,D,D,R,R,a,q,a,a,a,U,*a,*A\")\n+\t(match_operand:SI 1 \"move_operand\" \"M,D,d,R,D,d,r,r,I,T,U,r,*A,*r\"))]\n+  \"non_acc_reg_operand (operands[0], SImode)\n+   || non_acc_reg_operand (operands[1], SImode)\"\n+  \"@\n+   movi.n\\\\t%0, %x1\n+   mov.n\\\\t%0, %1\n+   mov.n\\\\t%0, %1\n+   %v1l32i.n\\\\t%0, %1\n+   %v0s32i.n\\\\t%1, %0\n+   %v0s32i.n\\\\t%1, %0\n+   mov\\\\t%0, %1\n+   movsp\\\\t%0, %1\n+   movi\\\\t%0, %x1\n+   %v1l32r\\\\t%0, %1\n+   %v1l32i\\\\t%0, %1\n+   %v0s32i\\\\t%1, %0\n+   rsr\\\\t%0, 16 # ACCLO\n+   wsr\\\\t%1, 16 # ACCLO\"\n+  [(set_attr \"type\"\t\"move,move,move,load,store,store,move,move,move,load,load,store,rsr,wsr\")\n+   (set_attr \"mode\"\t\"SI\")\n+   (set_attr \"length\"\t\"2,2,2,2,2,2,3,3,3,3,3,3,3,3\")])\n+\n+;; 16-bit Integer moves\n+\n+(define_expand \"movhi\"\n+  [(set (match_operand:HI 0 \"nonimmed_operand\" \"\")\n+\t(match_operand:HI 1 \"general_operand\" \"\"))]\n+  \"\"\n+  \"\n+{\n+  if (xtensa_emit_move_sequence (operands, HImode))\n+    DONE;\n+}\")\n+\n+(define_insn \"movhi_internal\"\n+  [(set (match_operand:HI 0 \"nonimmed_operand\" \"=D,D,a,a,a,U,*a,*A\")\n+\t(match_operand:HI 1 \"move_operand\" \"M,d,r,I,U,r,*A,*r\"))]\n+  \"non_acc_reg_operand (operands[0], HImode)\n+   || non_acc_reg_operand (operands[1], HImode)\"\n+  \"@\n+   movi.n\\\\t%0, %x1\n+   mov.n\\\\t%0, %1\n+   mov\\\\t%0, %1\n+   movi\\\\t%0, %x1\n+   %v1l16ui\\\\t%0, %1\n+   %v0s16i\\\\t%1, %0\n+   rsr\\\\t%0, 16 # ACCLO\n+   wsr\\\\t%1, 16 # ACCLO\"\n+  [(set_attr \"type\"\t\"move,move,move,move,load,store,rsr,wsr\")\n+   (set_attr \"mode\"\t\"HI\")\n+   (set_attr \"length\"\t\"2,2,3,3,3,3,3,3\")])\n+\n+;; 8-bit Integer moves\n+\n+(define_expand \"movqi\"\n+  [(set (match_operand:QI 0 \"nonimmed_operand\" \"\")\n+\t(match_operand:QI 1 \"general_operand\" \"\"))]\n+  \"\"\n+  \"\n+{\n+  if (xtensa_emit_move_sequence (operands, QImode))\n+    DONE;\n+}\")\n+\n+(define_insn \"movqi_internal\"\n+  [(set (match_operand:QI 0 \"nonimmed_operand\" \"=D,D,a,a,a,U,*a,*A\")\n+\t(match_operand:QI 1 \"move_operand\" \"M,d,r,I,U,r,*A,*r\"))]\n+  \"non_acc_reg_operand (operands[0], QImode)\n+   || non_acc_reg_operand (operands[1], QImode)\"\n+  \"@\n+   movi.n\\\\t%0, %x1\n+   mov.n\\\\t%0, %1\n+   mov\\\\t%0, %1\n+   movi\\\\t%0, %x1\n+   %v1l8ui\\\\t%0, %1\n+   %v0s8i\\\\t%1, %0\n+   rsr\\\\t%0, 16 # ACCLO\n+   wsr\\\\t%1, 16 # ACCLO\"\n+  [(set_attr \"type\"\t\"move,move,move,move,load,store,rsr,wsr\")\n+   (set_attr \"mode\"\t\"QI\")\n+   (set_attr \"length\"\t\"2,2,3,3,3,3,3,3\")])\n+\n+;; 32-bit floating point moves\n+\n+(define_expand \"movsf\"\n+  [(set (match_operand:SF 0 \"nonimmed_operand\" \"\")\n+\t(match_operand:SF 1 \"general_operand\" \"\"))]\n+  \"\"\n+  \"\n+{\n+  if (GET_CODE (operands[1]) == CONST_DOUBLE)\n+    operands[1] = force_const_mem (SFmode, operands[1]);\n+\n+  if (!(reload_in_progress | reload_completed))\n+    {\n+      if (((!register_operand (operands[0], SFmode)\n+\t   && !register_operand (operands[1], SFmode))\n+\t  || (FP_REG_P (xt_true_regnum (operands[0]))\n+\t      && constantpool_mem_p (operands[1]))))\n+\toperands[1] = force_reg (SFmode, operands[1]);\n+\n+      if (a7_overlap_mentioned_p (operands[1]))\n+\t{\n+\t  emit_insn (gen_movsf_internal (operands[0], operands[1]));\n+\t  emit_insn (gen_set_frame_ptr ());\n+\t  DONE;\n+\t}\n+    }\n+}\")\n+\n+(define_insn \"movsf_internal\"\n+  [(set (match_operand:SF 0 \"nonimmed_operand\"\n+\t\t\t    \"=f,f,U,D,D,R,a,f,a,a,a,U\")\n+\t(match_operand:SF 1 \"non_const_move_operand\"\n+\t\t\t    \"f,U,f,d,R,d,r,r,f,T,U,r\"))]\n+  \"((register_operand (operands[0], SFmode)\n+     || register_operand (operands[1], SFmode))\n+    && (!FP_REG_P (xt_true_regnum (operands[0]))\n+        || !constantpool_mem_p (operands[1])))\"\n+  \"@\n+   mov.s\\\\t%0, %1\n+   %v1lsi\\\\t%0, %1\n+   %v0ssi\\\\t%1, %0\n+   mov.n\\\\t%0, %1\n+   %v1l32i.n\\\\t%0, %1\n+   %v0s32i.n\\\\t%1, %0\n+   mov\\\\t%0, %1\n+   wfr\\\\t%0, %1\n+   rfr\\\\t%0, %1\n+   %v1l32r\\\\t%0, %1\n+   %v1l32i\\\\t%0, %1\n+   %v0s32i\\\\t%1, %0\"\n+  [(set_attr \"type\"\t\"farith,fload,fstore,move,load,store,move,farith,farith,load,load,store\")\n+   (set_attr \"mode\"\t\"SF\")\n+   (set_attr \"length\"\t\"3,3,3,2,2,2,3,3,3,3,3,3\")])\n+\n+(define_insn \"\"\n+  [(parallel\n+    [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n+\t  (mem:SF (plus:SI (match_operand:SI 1 \"register_operand\" \"+a\")\n+\t\t\t   (match_operand:SI 2 \"fpmem_offset_operand\" \"i\"))))\n+     (set (match_dup 1)\n+\t  (plus:SI (match_dup 1) (match_dup 2)))])]\n+  \"TARGET_HARD_FLOAT\"\n+  \"*\n+{\n+  if (TARGET_SERIALIZE_VOLATILE && volatile_refs_p (PATTERN (insn)))\n+    output_asm_insn (\\\"memw\\\", operands);\n+  return \\\"lsiu\\\\t%0, %1, %2\\\";\n+}\"\n+  [(set_attr \"type\"\t\"fload\")\n+   (set_attr \"mode\"\t\"SF\")\n+   (set_attr \"length\"\t\"3\")])\n+\n+(define_insn \"\"\n+  [(parallel\n+    [(set (mem:SF (plus:SI (match_operand:SI 0 \"register_operand\" \"+a\")\n+\t\t\t   (match_operand:SI 1 \"fpmem_offset_operand\" \"i\")))\n+\t  (match_operand:SF 2 \"register_operand\" \"f\"))\n+     (set (match_dup 0)\n+\t  (plus:SI (match_dup 0) (match_dup 1)))])]\n+  \"TARGET_HARD_FLOAT\"\n+  \"*\n+{\n+  if (TARGET_SERIALIZE_VOLATILE && volatile_refs_p (PATTERN (insn)))\n+    output_asm_insn (\\\"memw\\\", operands);\n+  return \\\"ssiu\\\\t%2, %0, %1\\\";\n+}\"\n+  [(set_attr \"type\"\t\"fstore\")\n+   (set_attr \"mode\"\t\"SF\")\n+   (set_attr \"length\"\t\"3\")])\n+\n+;; 64-bit floating point moves\n+\n+(define_expand \"movdf\"\n+  [(set (match_operand:DF 0 \"nonimmed_operand\" \"\")\n+\t(match_operand:DF 1 \"general_operand\" \"\"))]\n+  \"\"\n+  \"\n+{\n+  if (GET_CODE (operands[1]) == CONST_DOUBLE)\n+    operands[1] = force_const_mem (DFmode, operands[1]);\n+\n+  if (!(reload_in_progress | reload_completed))\n+    {\n+      if (!register_operand (operands[0], DFmode)\n+\t  && !register_operand (operands[1], DFmode))\n+\toperands[1] = force_reg (DFmode, operands[1]);\n+\n+      if (a7_overlap_mentioned_p (operands[1]))\n+\t{\n+\t  emit_insn (gen_movdf_internal (operands[0], operands[1]));\n+\t  emit_insn (gen_set_frame_ptr ());\n+\t  DONE;\n+\t}\n+    }\n+}\")\n+\n+(define_insn \"movdf_internal\"\n+  [(set (match_operand:DF 0 \"nonimmed_operand\" \"=D,D,S,a,a,a,U\")\n+\t(match_operand:DF 1 \"non_const_move_operand\" \"d,S,d,r,T,U,r\"))]\n+  \"register_operand (operands[0], DFmode)\n+   || register_operand (operands[1], DFmode)\"\n+  \"*\n+{\n+  switch (which_alternative)\n+    {\n+    case 0: return \\\"mov.n\\\\t%0, %1\\;mov.n\\\\t%D0, %D1\\\";\n+    case 2: return \\\"%v0s32i.n\\\\t%1, %0\\;s32i.n\\\\t%D1, %N0\\\";\n+    case 3: return \\\"mov\\\\t%0, %1\\;mov\\\\t%D0, %D1\\\";\n+    case 6: return \\\"%v0s32i\\\\t%1, %0\\;s32i\\\\t%D1, %N0\\\";\n+\n+    case 1:\n+    case 4:\n+    case 5:\n+      {\n+\t/* Check if the first half of the destination register is used\n+\t   in the source address.  If so, reverse the order of the loads\n+\t   so that the source address doesn't get clobbered until it is\n+\t   no longer needed. */\n+\n+\trtx dstreg = operands[0];\n+\tif (GET_CODE (dstreg) == SUBREG)\n+\t  dstreg = SUBREG_REG (dstreg);\n+\tif (GET_CODE (dstreg) != REG)\n+\t  abort ();\n+\n+\tif (reg_mentioned_p (dstreg, operands[1]))\n+\t  {\n+\t    switch (which_alternative)\n+\t      {\n+\t      case 1: return \\\"%v1l32i.n\\\\t%D0, %N1\\;l32i.n\\\\t%0, %1\\\";\n+\t      case 4: return \\\"%v1l32r\\\\t%D0, %N1\\;l32r\\\\t%0, %1\\\";\n+\t      case 5: return \\\"%v1l32i\\\\t%D0, %N1\\;l32i\\\\t%0, %1\\\";\n+\t      }\n+\t  }\n+\telse\n+\t  {\n+\t    switch (which_alternative)\n+\t      {\n+\t      case 1: return \\\"%v1l32i.n\\\\t%0, %1\\;l32i.n\\\\t%D0, %N1\\\";\n+\t      case 4: return \\\"%v1l32r\\\\t%0, %1\\;l32r\\\\t%D0, %N1\\\";\n+\t      case 5: return \\\"%v1l32i\\\\t%0, %1\\;l32i\\\\t%D0, %N1\\\";\n+\t      }\n+\t  }\n+      }\n+    }\n+  abort ();\n+  return \\\"\\\";\n+}\"\n+  [(set_attr \"type\"\t\"move,load,store,move,load,load,store\")\n+   (set_attr \"mode\"\t\"DF\")\n+   (set_attr \"length\"\t\"4,4,4,6,6,6,6\")])\n+\n+;; Block moves\n+\n+(define_expand \"movstrsi\"\n+  [(parallel [(set (match_operand:BLK 0 \"\" \"\")\n+\t\t   (match_operand:BLK 1 \"\" \"\"))\n+\t      (use (match_operand:SI 2 \"arith_operand\" \"\"))\n+\t      (use (match_operand:SI 3 \"const_int_operand\" \"\"))])]\n+  \"\"\n+  \"\n+{\n+  if (!xtensa_expand_block_move (operands)) FAIL;\n+  DONE;\n+}\")\n+\n+(define_insn \"movstrsi_internal\"\n+  [(parallel [(set (match_operand:BLK 0 \"memory_operand\" \"=U\")\n+\t\t   (match_operand:BLK 1 \"memory_operand\" \"U\"))\n+\t      (use (match_operand:SI 2 \"arith_operand\" \"\"))\n+\t      (use (match_operand:SI 3 \"const_int_operand\" \"\"))\n+\t      (clobber (match_scratch:SI 4 \"=&r\"))\n+\t      (clobber (match_scratch:SI 5 \"=&r\"))])]\n+  \"\"\n+  \"*\n+{\n+  rtx tmpregs[2];\n+  tmpregs[0] = operands[4];\n+  tmpregs[1] = operands[5];\n+  xtensa_emit_block_move (operands, tmpregs, 1);\n+  return \\\"\\\";\n+}\"\n+  [(set_attr \"type\"\t\"multi\")\n+   (set_attr \"mode\"\t\"none\")\n+   (set_attr \"length\"\t\"300\")])\n+\n+\n+;;\n+;;  ....................\n+;;\n+;;\tSHIFTS\n+;;\n+;;  ....................\n+;;\n+\n+(define_insn \"ashlsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=a,a\")\n+\t(ashift:SI (match_operand:SI 1 \"register_operand\" \"r,r\")\n+\t\t   (match_operand:SI 2 \"arith_operand\" \"J,r\")))]\n+  \"\"      \n+  \"@\n+   slli\\\\t%0, %1, %R2\n+   ssl\\\\t%2\\;sll\\\\t%0, %1\"\n+  [(set_attr \"type\"\t\"arith,arith\")\n+   (set_attr \"mode\"\t\"SI\")\n+   (set_attr \"length\"\t\"3,6\")])\n+\n+(define_insn \"ashrsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=a,a\")\n+\t(ashiftrt:SI (match_operand:SI 1 \"register_operand\" \"r,r\")\n+\t\t     (match_operand:SI 2 \"arith_operand\" \"J,r\")))]\n+  \"\"\n+  \"@\n+   srai\\\\t%0, %1, %R2\n+   ssr\\\\t%2\\;sra\\\\t%0, %1\"\n+  [(set_attr \"type\"\t\"arith,arith\")\n+   (set_attr \"mode\"\t\"SI\")\n+   (set_attr \"length\"\t\"3,6\")])\n+\n+(define_insn \"lshrsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=a,a\")\n+\t(lshiftrt:SI (match_operand:SI 1 \"register_operand\" \"r,r\")\n+\t\t     (match_operand:SI 2 \"arith_operand\" \"J,r\")))]\n+  \"\"\n+  \"*\n+{\n+  if (which_alternative == 0)\n+    {\n+      if ((INTVAL (operands[2]) & 0x1f) < 16)\n+        return \\\"srli\\\\t%0, %1, %R2\\\";\n+      else\n+      \treturn \\\"extui\\\\t%0, %1, %R2, %L2\\\";\n+    }\n+  return \\\"ssr\\\\t%2\\;srl\\\\t%0, %1\\\";\n+}\"\n+  [(set_attr \"type\"\t\"arith,arith\")\n+   (set_attr \"mode\"\t\"SI\")\n+   (set_attr \"length\"\t\"3,6\")])\n+\n+(define_insn \"rotlsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=a,a\")\n+\t(rotate:SI (match_operand:SI 1 \"register_operand\" \"r,r\")\n+\t\t     (match_operand:SI 2 \"arith_operand\" \"J,r\")))]\n+  \"\"\n+  \"@\n+   ssai\\\\t%L2\\;src\\\\t%0, %1, %1\n+   ssl\\\\t%2\\;src\\\\t%0, %1, %1\"\n+  [(set_attr \"type\"\t\"multi,multi\")\n+   (set_attr \"mode\"\t\"SI\")\n+   (set_attr \"length\"\t\"6,6\")])\n+\n+(define_insn \"rotrsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=a,a\")\n+\t(rotatert:SI (match_operand:SI 1 \"register_operand\" \"r,r\")\n+\t\t     (match_operand:SI 2 \"arith_operand\" \"J,r\")))]\n+  \"\"\n+  \"@\n+   ssai\\\\t%R2\\;src\\\\t%0, %1, %1\n+   ssr\\\\t%2\\;src\\\\t%0, %1, %1\"\n+  [(set_attr \"type\"\t\"multi,multi\")\n+   (set_attr \"mode\"\t\"SI\")\n+   (set_attr \"length\"\t\"6,6\")])\n+\n+;;\n+;;  ....................\n+;;\n+;;\tCOMPARISONS\n+;;\n+;;  ....................\n+;;\n+\n+;; Like the md files for MIPS and SPARC, we handle comparisons by stashing\n+;; away the operands and then using that information in the subsequent\n+;; conditional branch.\n+\n+(define_expand \"cmpsi\"\n+  [(set (cc0)\n+\t(compare:CC (match_operand:SI 0 \"register_operand\" \"\")\n+\t\t    (match_operand:SI 1 \"nonmemory_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  branch_cmp[0] = operands[0];\n+  branch_cmp[1] = operands[1];\n+  branch_type = CMP_SI;\n+  DONE;\n+}\")\n+\n+(define_expand \"tstsi\"\n+  [(set (cc0)\n+\t(match_operand:SI 0 \"register_operand\" \"\"))]\n+  \"\"\n+  \"\n+{\n+  branch_cmp[0] = operands[0];\n+  branch_cmp[1] = const0_rtx;\n+  branch_type = CMP_SI;\n+  DONE;\n+}\")\n+\n+(define_expand \"cmpsf\"\n+  [(set (cc0)\n+\t(compare:CC (match_operand:SF 0 \"register_operand\" \"\")\n+\t\t    (match_operand:SF 1 \"register_operand\" \"\")))]\n+  \"TARGET_HARD_FLOAT\"\n+  \"\n+{\n+  branch_cmp[0] = operands[0];\n+  branch_cmp[1] = operands[1];\n+  branch_type = CMP_SF;\n+  DONE;\n+}\")\n+\n+\n+;;\n+;;  ....................\n+;;\n+;;\tCONDITIONAL BRANCHES\n+;;\n+;;  ....................\n+;;\n+\n+(define_expand \"beq\"\n+  [(set (pc)\n+\t(if_then_else (eq (cc0) (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\n+{\n+  xtensa_expand_conditional_branch (operands, EQ);\n+  DONE;\n+}\")\n+\n+(define_expand \"bne\"\n+  [(set (pc)\n+\t(if_then_else (ne (cc0) (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\n+{\n+  xtensa_expand_conditional_branch (operands, NE);\n+  DONE;\n+}\")\n+\n+(define_expand \"bgt\"\n+  [(set (pc)\n+\t(if_then_else (gt (cc0) (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\n+{\n+  xtensa_expand_conditional_branch (operands, GT);\n+  DONE;\n+}\")\n+\n+(define_expand \"bge\"\n+  [(set (pc)\n+\t(if_then_else (ge (cc0) (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\n+{\n+  xtensa_expand_conditional_branch (operands, GE);\n+  DONE;\n+}\")\n+\n+(define_expand \"blt\"\n+  [(set (pc)\n+\t(if_then_else (lt (cc0) (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\n+{\n+  xtensa_expand_conditional_branch (operands, LT);\n+  DONE;\n+}\")\n+\n+(define_expand \"ble\"\n+  [(set (pc)\n+\t(if_then_else (le (cc0) (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\n+{\n+  xtensa_expand_conditional_branch (operands, LE);\n+  DONE;\n+}\")\n+\n+(define_expand \"bgtu\"\n+  [(set (pc)\n+\t(if_then_else (gtu (cc0) (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\n+{\n+  xtensa_expand_conditional_branch (operands, GTU);\n+  DONE;\n+}\")\n+\n+(define_expand \"bgeu\"\n+  [(set (pc)\n+\t(if_then_else (geu (cc0) (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\n+{\n+  xtensa_expand_conditional_branch (operands, GEU);\n+  DONE;\n+}\")\n+\n+(define_expand \"bltu\"\n+  [(set (pc)\n+\t(if_then_else (ltu (cc0) (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\n+{\n+  xtensa_expand_conditional_branch (operands, LTU);\n+  DONE;\n+}\")\n+\n+(define_expand \"bleu\"\n+  [(set (pc)\n+\t(if_then_else (leu (cc0) (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\n+{\n+  xtensa_expand_conditional_branch (operands, LEU);\n+  DONE;\n+}\")\n+\n+;; Branch patterns for standard integer comparisons\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else (match_operator 3 \"branch_operator\"\n+\t\t\t [(match_operand:SI 0 \"register_operand\" \"r,r\")\n+\t\t\t  (match_operand:SI 1 \"branch_operand\" \"K,r\")])\n+\t\t      (label_ref (match_operand 2 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"*\n+{\n+  if (which_alternative == 1)\n+    {\n+      switch (GET_CODE (operands[3]))\n+\t{\n+\tcase EQ:\treturn \\\"beq\\\\t%0, %1, %2\\\";\n+\tcase NE:\treturn \\\"bne\\\\t%0, %1, %2\\\";\n+\tcase LT:\treturn \\\"blt\\\\t%0, %1, %2\\\";\n+\tcase GE:\treturn \\\"bge\\\\t%0, %1, %2\\\";\n+\tdefault:\tbreak;\n+\t}\n+    }\n+  else if (INTVAL (operands[1]) == 0)\n+    {\n+      switch (GET_CODE (operands[3]))\n+\t{\n+\tcase EQ:\treturn (TARGET_DENSITY\n+\t\t\t\t? \\\"beqz.n\\\\t%0, %2\\\"\n+\t\t\t\t: \\\"beqz\\\\t%0, %2\\\");\n+\tcase NE:\treturn (TARGET_DENSITY\n+\t\t\t\t? \\\"bnez.n\\\\t%0, %2\\\"\n+\t\t\t\t: \\\"bnez\\\\t%0, %2\\\");\n+\tcase LT:\treturn \\\"bltz\\\\t%0, %2\\\";\n+\tcase GE:\treturn \\\"bgez\\\\t%0, %2\\\";\n+\tdefault:\tbreak;\n+\t}\n+    }\n+  else\n+    {\n+      switch (GET_CODE (operands[3]))\n+\t{\n+\tcase EQ:\treturn \\\"beqi\\\\t%0, %d1, %2\\\";\n+\tcase NE:\treturn \\\"bnei\\\\t%0, %d1, %2\\\";\n+\tcase LT:\treturn \\\"blti\\\\t%0, %d1, %2\\\";\n+\tcase GE:\treturn \\\"bgei\\\\t%0, %d1, %2\\\";\n+\tdefault:\tbreak;\n+\t}\n+    }\n+  fatal_insn (\\\"unexpected branch operator\\\", operands[3]);\n+  return \\\"\\\";\n+}\"\n+  [(set_attr \"type\"\t\"jump,jump\")\n+   (set_attr \"mode\"\t\"none\")\n+   (set_attr \"length\"\t\"3,3\")])\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else (match_operator 3 \"branch_operator\"\n+\t\t\t [(match_operand:SI 0 \"register_operand\" \"r,r\")\n+\t\t\t  (match_operand:SI 1 \"branch_operand\" \"K,r\")])\n+\t\t      (pc)\n+\t\t      (label_ref (match_operand 2 \"\" \"\"))))]\n+  \"\"\n+  \"*\n+{\n+  if (which_alternative == 1)\n+    {\n+      switch (GET_CODE (operands[3]))\n+\t{\n+\tcase EQ:\treturn \\\"bne\\\\t%0, %1, %2\\\";\n+\tcase NE:\treturn \\\"beq\\\\t%0, %1, %2\\\";\n+\tcase LT:\treturn \\\"bge\\\\t%0, %1, %2\\\";\n+\tcase GE:\treturn \\\"blt\\\\t%0, %1, %2\\\";\n+\tdefault:\tbreak;\n+\t}\n+    }\n+  else if (INTVAL (operands[1]) == 0)\n+    {\n+      switch (GET_CODE (operands[3]))\n+\t{\n+\tcase EQ:\treturn (TARGET_DENSITY\n+\t\t\t\t? \\\"bnez.n\\\\t%0, %2\\\"\n+\t\t\t\t: \\\"bnez\\\\t%0, %2\\\");\n+\tcase NE:\treturn (TARGET_DENSITY\n+\t\t\t\t? \\\"beqz.n\\\\t%0, %2\\\"\n+\t\t\t\t: \\\"beqz\\\\t%0, %2\\\");\n+\tcase LT:\treturn \\\"bgez\\\\t%0, %2\\\";\n+\tcase GE:\treturn \\\"bltz\\\\t%0, %2\\\";\n+\tdefault:\tbreak;\n+\t}\n+    }\n+  else\n+    {\n+      switch (GET_CODE (operands[3]))\n+\t{\n+\tcase EQ:\treturn \\\"bnei\\\\t%0, %d1, %2\\\";\n+\tcase NE:\treturn \\\"beqi\\\\t%0, %d1, %2\\\";\n+\tcase LT:\treturn \\\"bgei\\\\t%0, %d1, %2\\\";\n+\tcase GE:\treturn \\\"blti\\\\t%0, %d1, %2\\\";\n+\tdefault:\tbreak;\n+\t}\n+    }\n+  fatal_insn (\\\"unexpected branch operator\\\", operands[3]);\n+  return \\\"\\\";\n+}\"\n+  [(set_attr \"type\"\t\"jump,jump\")\n+   (set_attr \"mode\"\t\"none\")\n+   (set_attr \"length\"\t\"3,3\")])\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else (match_operator 3 \"ubranch_operator\"\n+\t\t\t [(match_operand:SI 0 \"register_operand\" \"r,r\")\n+\t\t\t  (match_operand:SI 1 \"ubranch_operand\" \"L,r\")])\n+\t\t      (label_ref (match_operand 2 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"*\n+{\n+  if (which_alternative == 1)\n+    {\n+      switch (GET_CODE (operands[3]))\n+\t{\n+\tcase LTU:\treturn \\\"bltu\\\\t%0, %1, %2\\\";\n+\tcase GEU:\treturn \\\"bgeu\\\\t%0, %1, %2\\\";\n+\tdefault:\tbreak;\n+\t}\n+    }\n+  else\n+    {\n+      switch (GET_CODE (operands[3]))\n+\t{\n+\tcase LTU:\treturn \\\"bltui\\\\t%0, %d1, %2\\\";\n+\tcase GEU:\treturn \\\"bgeui\\\\t%0, %d1, %2\\\";\n+\tdefault:\tbreak;\n+\t}\n+    }\n+  fatal_insn (\\\"unexpected branch operator\\\", operands[3]);\n+  return \\\"\\\";\n+}\"\n+  [(set_attr \"type\"\t\"jump,jump\")\n+   (set_attr \"mode\"\t\"none\")\n+   (set_attr \"length\"\t\"3,3\")])\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else (match_operator 3 \"ubranch_operator\"\n+\t\t\t [(match_operand:SI 0 \"register_operand\" \"r,r\")\n+\t\t\t  (match_operand:SI 1 \"ubranch_operand\" \"L,r\")])\n+\t\t      (pc)\n+\t\t      (label_ref (match_operand 2 \"\" \"\"))))]\n+  \"\"\n+  \"*\n+{\n+  if (which_alternative == 1)\n+    {\n+      switch (GET_CODE (operands[3]))\n+\t{\n+\tcase LTU:\treturn \\\"bgeu\\\\t%0, %1, %2\\\";\n+\tcase GEU:\treturn \\\"bltu\\\\t%0, %1, %2\\\";\n+\tdefault:\tbreak;\n+\t}\n+    }\n+  else\n+    {\n+      switch (GET_CODE (operands[3]))\n+\t{\n+\tcase LTU:\treturn \\\"bgeui\\\\t%0, %d1, %2\\\";\n+\tcase GEU:\treturn \\\"bltui\\\\t%0, %d1, %2\\\";\n+\tdefault:\tbreak;\n+\t}\n+    }\n+  fatal_insn (\\\"unexpected branch operator\\\", operands[3]);\n+  return \\\"\\\";\n+}\"\n+  [(set_attr \"type\"\t\"jump,jump\")\n+   (set_attr \"mode\"\t\"none\")\n+   (set_attr \"length\"\t\"3,3\")])\n+\n+;; Branch patterns for bit testing\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else (match_operator 3 \"boolean_operator\"\n+\t\t\t[(zero_extract:SI\n+\t\t\t    (match_operand:SI 0 \"register_operand\" \"r,r\")\n+\t\t\t    (const_int 1)\n+\t\t\t    (match_operand:SI 1 \"arith_operand\" \"J,r\"))\n+\t\t\t (const_int 0)])\n+\t\t      (label_ref (match_operand 2 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"*\n+{\n+  if (which_alternative == 0)\n+    {\n+      unsigned bitnum = INTVAL(operands[1]) & 0x1f;\n+      operands[1] = GEN_INT(bitnum);\n+      switch (GET_CODE (operands[3]))\n+\t{\n+\tcase EQ:\treturn \\\"bbci\\\\t%0, %d1, %2\\\";\n+\tcase NE:\treturn \\\"bbsi\\\\t%0, %d1, %2\\\";\n+\tdefault:\tbreak;\n+\t}\n+    }\n+  else\n+    {\n+      switch (GET_CODE (operands[3]))\n+\t{\n+\tcase EQ:\treturn \\\"bbc\\\\t%0, %1, %2\\\";\n+\tcase NE:\treturn \\\"bbs\\\\t%0, %1, %2\\\";\n+\tdefault:\tbreak;\n+\t}\n+    }\n+  fatal_insn (\\\"unexpected branch operator\\\", operands[3]);\n+  return \\\"\\\";\n+}\"\n+  [(set_attr \"type\"\t\"jump\")\n+   (set_attr \"mode\"\t\"none\")\n+   (set_attr \"length\"\t\"3\")])\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else (match_operator 3 \"boolean_operator\"\n+\t\t\t[(zero_extract:SI\n+\t\t\t    (match_operand:SI 0 \"register_operand\" \"r,r\")\n+\t\t\t    (const_int 1)\n+\t\t\t    (match_operand:SI 1 \"arith_operand\" \"J,r\"))\n+\t\t\t (const_int 0)])\n+\t\t      (pc)\n+\t\t      (label_ref (match_operand 2 \"\" \"\"))))]\n+  \"\"\n+  \"*\n+{\n+  if (which_alternative == 0)\n+    {\n+      unsigned bitnum = INTVAL (operands[1]) & 0x1f;\n+      operands[1] = GEN_INT (bitnum);\n+      switch (GET_CODE (operands[3]))\n+\t{\n+\tcase EQ:    return \\\"bbsi\\\\t%0, %d1, %2\\\";\n+\tcase NE:    return \\\"bbci\\\\t%0, %d1, %2\\\";\n+\tdefault:    break;\n+\t}\n+    }\n+  else\n+    {\n+      switch (GET_CODE (operands[3]))\n+\t{\n+\tcase EQ:\treturn \\\"bbs\\\\t%0, %1, %2\\\";\n+\tcase NE:\treturn \\\"bbc\\\\t%0, %1, %2\\\";\n+\tdefault:\tbreak;\n+\t}\n+    }\n+  fatal_insn (\\\"unexpected branch operator\\\", operands[3]);\n+  return \\\"\\\";\n+}\"\n+  [(set_attr \"type\"\t\"jump\")\n+   (set_attr \"mode\"\t\"none\")\n+   (set_attr \"length\"\t\"3\")])\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else (match_operator 3 \"boolean_operator\"\n+\t\t [(and:SI (match_operand:SI 0 \"register_operand\" \"r\")\n+\t\t\t  (match_operand:SI 1 \"register_operand\" \"r\"))\n+\t\t  (const_int 0)])\n+\t\t      (label_ref (match_operand 2 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"*\n+{\n+  switch (GET_CODE (operands[3]))\n+    {\n+    case EQ:\treturn \\\"bnone\\\\t%0, %1, %2\\\";\n+    case NE:\treturn \\\"bany\\\\t%0, %1, %2\\\";\n+    default:\tbreak;\n+    }\n+  fatal_insn (\\\"unexpected branch operator\\\", operands[3]);\n+  return \\\"\\\";\n+}\"\n+  [(set_attr \"type\"\t\"jump\")\n+   (set_attr \"mode\"\t\"none\")\n+   (set_attr \"length\"\t\"3\")])\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else (match_operator 3 \"boolean_operator\"\n+\t\t [(and:SI (match_operand:SI 0 \"register_operand\" \"r\")\n+\t\t\t  (match_operand:SI 1 \"register_operand\" \"r\"))\n+\t\t  (const_int 0)])\n+\t\t      (pc)\n+\t\t      (label_ref (match_operand 2 \"\" \"\"))))]\n+  \"\"\n+  \"*\n+{\n+  switch (GET_CODE (operands[3]))\n+    {\n+    case EQ:\treturn \\\"bany\\\\t%0, %1, %2\\\";\n+    case NE:\treturn \\\"bnone\\\\t%0, %1, %2\\\";\n+    default:\tbreak;\n+    }\n+  fatal_insn (\\\"unexpected branch operator\\\", operands[3]);\n+  return \\\"\\\";\n+}\"\n+  [(set_attr \"type\"\t\"jump\")\n+   (set_attr \"mode\"\t\"none\")\n+   (set_attr \"length\"\t\"3\")])\n+\n+\n+;; Define the loop insns that is used by bct optimization to represent the\n+;; start and end of a zero-overhead loop (in loop.c). This start template\n+;; generates the loop insn, the end template doesn't generate any instructions\n+;; since since loop end is handled in hardware.\n+\n+(define_insn \"zero_cost_loop_start\"\n+  [(parallel [(set (pc) (if_then_else (eq (match_operand:SI 0 \"register_operand\" \"a\")\n+\t\t\t\t\t  (const_int 0))\n+\t\t\t\t      (label_ref (match_operand 1 \"\" \"\"))\n+\t\t\t\t      (pc)))\n+\t      (set (reg:SI 19)\n+\t\t   (plus:SI (match_dup 0)\n+\t\t\t    (const_int -1)))])]\n+  \"\"\n+  \"loopnez %0, %l1\"\n+  [(set_attr \"type\"\t\"jump\")\n+   (set_attr \"mode\"\t\"none\")\n+   (set_attr \"length\"\t\"3\")])\n+\n+(define_insn \"zero_cost_loop_end\"\n+  [(parallel [(set (pc) (if_then_else (ne (reg:SI 19)\n+\t\t\t\t\t  (const_int 0))\n+\t\t\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t\t\t      (pc)))\n+\t      (set (reg:SI 19)\n+\t\t   (plus:SI (reg:SI 19)\n+\t\t\t    (const_int -1)))])]\n+  \"\"\n+  \"*\n+    xtensa_emit_loop_end (insn, operands);\n+    return \\\"\\\";\n+  \"\n+  [(set_attr \"type\"\t\"jump\")\n+   (set_attr \"mode\"\t\"none\")\n+   (set_attr \"length\"\t\"0\")])\n+\n+\n+;;\n+;;  ....................\n+;;\n+;;\tSETTING A REGISTER FROM A COMPARISON\n+;;\n+;;  ....................\n+;;\n+\n+(define_expand \"seq\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(match_dup 1))]\n+  \"\"\n+  \"\n+{\n+  operands[1] = gen_rtx (EQ, SImode, branch_cmp[0], branch_cmp[1]);\n+  if (!xtensa_expand_scc (operands)) FAIL;\n+  DONE;\n+}\")\n+\n+(define_expand \"sne\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(match_dup 1))]\n+  \"\"\n+  \"\n+{\n+  operands[1] = gen_rtx (NE, SImode, branch_cmp[0], branch_cmp[1]);\n+  if (!xtensa_expand_scc (operands)) FAIL;\n+  DONE;\n+}\")\n+\n+(define_expand \"sgt\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(match_dup 1))]\n+  \"\"\n+  \"\n+{\n+  operands[1] = gen_rtx (GT, SImode, branch_cmp[0], branch_cmp[1]);\n+  if (!xtensa_expand_scc (operands)) FAIL;\n+  DONE;\n+}\")\n+\n+(define_expand \"sge\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(match_dup 1))]\n+  \"\"\n+  \"\n+{\n+  operands[1] = gen_rtx (GE, SImode, branch_cmp[0], branch_cmp[1]);\n+  if (!xtensa_expand_scc (operands)) FAIL;\n+  DONE;\n+}\")\n+\n+(define_expand \"slt\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(match_dup 1))]\n+  \"\"\n+  \"\n+{\n+  operands[1] = gen_rtx (LT, SImode, branch_cmp[0], branch_cmp[1]);\n+  if (!xtensa_expand_scc (operands)) FAIL;\n+  DONE;\n+}\")\n+\n+(define_expand \"sle\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(match_dup 1))]\n+  \"\"\n+  \"\n+{\n+  operands[1] = gen_rtx (LE, SImode, branch_cmp[0], branch_cmp[1]);\n+  if (!xtensa_expand_scc (operands)) FAIL;\n+  DONE;\n+}\")\n+\n+\n+;;\n+;;  ....................\n+;;\n+;;\tCONDITIONAL MOVES\n+;;\n+;;  ....................\n+;;\n+\n+(define_expand \"movsicc\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(if_then_else:SI (match_operand 1 \"comparison_operator\" \"\")\n+\t\t\t (match_operand:SI 2 \"register_operand\" \"\")\n+\t\t\t (match_operand:SI 3 \"register_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  if (!xtensa_expand_conditional_move (operands, 0)) FAIL;\n+  DONE;\n+}\")\n+\n+(define_expand \"movsfcc\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"\")\n+\t(if_then_else:SF (match_operand 1 \"comparison_operator\" \"\")\n+\t\t\t (match_operand:SF 2 \"register_operand\" \"\")\n+\t\t\t (match_operand:SF 3 \"register_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  if (!xtensa_expand_conditional_move (operands, 1)) FAIL;\n+  DONE;\n+}\")\n+\n+(define_insn \"movsicc_internal0\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=a,a\")\n+\t(if_then_else:SI (match_operator 4 \"branch_operator\"\n+\t\t\t   [(match_operand:SI 1 \"register_operand\" \"r,r\")\n+\t\t\t    (const_int 0)])\n+\t\t\t (match_operand:SI 2 \"register_operand\" \"r,0\")\n+\t\t\t (match_operand:SI 3 \"register_operand\" \"0,r\")))]\n+  \"\"\n+  \"*\n+{\n+  if (which_alternative == 0)\n+    {\n+      switch (GET_CODE (operands[4]))\n+\t{\n+\tcase EQ:\treturn \\\"moveqz\\\\t%0, %2, %1\\\";\n+\tcase NE:\treturn \\\"movnez\\\\t%0, %2, %1\\\";\n+\tcase LT:\treturn \\\"movltz\\\\t%0, %2, %1\\\";\n+\tcase GE:\treturn \\\"movgez\\\\t%0, %2, %1\\\";\n+\tdefault:\tbreak;\n+\t}\n+    }\n+  else\n+    {\n+      switch (GET_CODE (operands[4]))\n+\t{\n+\tcase EQ:\treturn \\\"movnez\\\\t%0, %3, %1\\\";\n+\tcase NE:\treturn \\\"moveqz\\\\t%0, %3, %1\\\";\n+\tcase LT:\treturn \\\"movgez\\\\t%0, %3, %1\\\";\n+\tcase GE:\treturn \\\"movltz\\\\t%0, %3, %1\\\";\n+\tdefault:\tbreak;\n+\t}\n+    }\n+  fatal_insn (\\\"unexpected cmov operator\\\", operands[4]);\n+  return \\\"\\\";\n+}\"\n+  [(set_attr \"type\"\t\"move,move\")\n+   (set_attr \"mode\"\t\"SI\")\n+   (set_attr \"length\"\t\"3,3\")])\n+\n+(define_insn \"movsicc_internal1\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=a,a\")\n+\t(if_then_else:SI (match_operator 4 \"boolean_operator\"\n+\t\t\t   [(match_operand:CC 1 \"register_operand\" \"b,b\")\n+\t\t\t    (const_int 0)])\n+\t\t\t (match_operand:SI 2 \"register_operand\" \"r,0\")\n+\t\t\t (match_operand:SI 3 \"register_operand\" \"0,r\")))]\n+  \"TARGET_BOOLEANS\"\n+  \"*\n+{\n+  int isEq = (GET_CODE (operands[4]) == EQ);\n+  switch (which_alternative)\n+    {\n+    case 0:\n+      if (isEq) return \\\"movf\\\\t%0, %2, %1\\\";\n+      return \\\"movt\\\\t%0, %2, %1\\\";\n+    case 1:\n+      if (isEq) return \\\"movt\\\\t%0, %3, %1\\\";\n+      return \\\"movf\\\\t%0, %3, %1\\\";\n+    }\n+  abort ();\n+  return \\\"\\\";\n+}\"\n+  [(set_attr \"type\"\t\"move,move\")\n+   (set_attr \"mode\"\t\"SI\")\n+   (set_attr \"length\"\t\"3,3\")])\n+\n+(define_insn \"movsfcc_internal0\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=a,a,f,f\")\n+\t(if_then_else:SF (match_operator 4 \"branch_operator\"\n+\t\t\t   [(match_operand:SI 1 \"register_operand\" \"r,r,r,r\")\n+\t\t\t    (const_int 0)])\n+\t\t\t (match_operand:SF 2 \"register_operand\" \"r,0,f,0\")\n+\t\t\t (match_operand:SF 3 \"register_operand\" \"0,r,0,f\")))]\n+  \"\"\n+  \"*\n+{\n+  if (which_alternative == 0)\n+    {\n+      switch (GET_CODE (operands[4]))\n+\t{\n+\tcase EQ:\treturn \\\"moveqz\\\\t%0, %2, %1\\\";\n+\tcase NE:\treturn \\\"movnez\\\\t%0, %2, %1\\\";\n+\tcase LT:\treturn \\\"movltz\\\\t%0, %2, %1\\\";\n+\tcase GE:\treturn \\\"movgez\\\\t%0, %2, %1\\\";\n+\tdefault:\tbreak;\n+\t}\n+    }\n+  else if (which_alternative == 1)\n+    {\n+      switch (GET_CODE (operands[4]))\n+\t{\n+\tcase EQ:\treturn \\\"movnez\\\\t%0, %3, %1\\\";\n+\tcase NE:\treturn \\\"moveqz\\\\t%0, %3, %1\\\";\n+\tcase LT:\treturn \\\"movgez\\\\t%0, %3, %1\\\";\n+\tcase GE:\treturn \\\"movltz\\\\t%0, %3, %1\\\";\n+\tdefault:\tbreak;\n+\t}\n+    }\n+  else if (which_alternative == 2)\n+    {\n+      switch (GET_CODE (operands[4]))\n+\t{\n+\tcase EQ:\treturn \\\"moveqz.s %0, %2, %1\\\";\n+\tcase NE:\treturn \\\"movnez.s %0, %2, %1\\\";\n+\tcase LT:\treturn \\\"movltz.s %0, %2, %1\\\";\n+\tcase GE:\treturn \\\"movgez.s %0, %2, %1\\\";\n+\tdefault:\tbreak;\n+\t}\n+    }\n+  else if (which_alternative == 3)\n+    {\n+      switch (GET_CODE (operands[4]))\n+\t{\n+\tcase EQ:\treturn \\\"movnez.s %0, %3, %1\\\";\n+\tcase NE:\treturn \\\"moveqz.s %0, %3, %1\\\";\n+\tcase LT:\treturn \\\"movgez.s %0, %3, %1\\\";\n+\tcase GE:\treturn \\\"movltz.s %0, %3, %1\\\";\n+\tdefault:\tbreak;\n+\t}\n+    }\n+  fatal_insn (\\\"unexpected cmov operator\\\", operands[4]);\n+  return \\\"\\\";\n+}\"\n+  [(set_attr \"type\"\t\"move,move,move,move\")\n+   (set_attr \"mode\"\t\"SF\")\n+   (set_attr \"length\"\t\"3,3,3,3\")])\n+\n+(define_insn \"movsfcc_internal1\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=a,a,f,f\")\n+\t(if_then_else:SF (match_operator 4 \"boolean_operator\"\n+\t\t\t   [(match_operand:CC 1 \"register_operand\" \"b,b,b,b\")\n+\t\t\t    (const_int 0)])\n+\t\t\t (match_operand:SF 2 \"register_operand\" \"r,0,f,0\")\n+\t\t\t (match_operand:SF 3 \"register_operand\" \"0,r,0,f\")))]\n+  \"TARGET_BOOLEANS\"\n+  \"*\n+{\n+  int isEq = (GET_CODE (operands[4]) == EQ);\n+  switch (which_alternative)\n+    {\n+    case 0:\n+      if (isEq) return \\\"movf\\\\t%0, %2, %1\\\";\n+      return \\\"movt\\\\t%0, %2, %1\\\";\n+    case 1:\n+      if (isEq) return \\\"movt\\\\t%0, %3, %1\\\";\n+      return \\\"movf\\\\t%0, %3, %1\\\";\n+    case 2:\n+      if (isEq) return \\\"movf.s\\\\t%0, %2, %1\\\";\n+      return \\\"movt.s\\\\t%0, %2, %1\\\";\n+    case 3:\n+      if (isEq) return \\\"movt.s\\\\t%0, %3, %1\\\";\n+      return \\\"movf.s\\\\t%0, %3, %1\\\";\n+    }\n+  abort ();\n+  return \\\"\\\";\n+}\"\n+  [(set_attr \"type\"\t\"move,move,move,move\")\n+   (set_attr \"mode\"\t\"SF\")\n+   (set_attr \"length\"\t\"3,3,3,3\")])\n+\n+\n+;;\n+;;  ....................\n+;;\n+;;\tFLOATING POINT COMPARISONS\n+;;\n+;;  ....................\n+;;\n+\n+(define_insn \"seq_sf\"\n+  [(set (match_operand:CC 0 \"register_operand\" \"=b\")\n+\t(eq:CC (match_operand:SF 1 \"register_operand\" \"f\")\n+\t       (match_operand:SF 2 \"register_operand\" \"f\")))]\n+  \"TARGET_HARD_FLOAT\"\n+  \"oeq.s\\\\t%0, %1, %2\"\n+  [(set_attr \"type\"\t\"farith\")\n+   (set_attr \"mode\"\t\"BL\")\n+   (set_attr \"length\"\t\"3\")])\n+\n+(define_insn \"slt_sf\"\n+  [(set (match_operand:CC 0 \"register_operand\" \"=b\")\n+\t(lt:CC (match_operand:SF 1 \"register_operand\" \"f\")\n+\t       (match_operand:SF 2 \"register_operand\" \"f\")))]\n+  \"TARGET_HARD_FLOAT\"\n+  \"olt.s\\\\t%0, %1, %2\"\n+  [(set_attr \"type\"\t\"farith\")\n+   (set_attr \"mode\"\t\"BL\")\n+   (set_attr \"length\"\t\"3\")])\n+\n+(define_insn \"sle_sf\"\n+  [(set (match_operand:CC 0 \"register_operand\" \"=b\")\n+\t(le:CC (match_operand:SF 1 \"register_operand\" \"f\")\n+\t       (match_operand:SF 2 \"register_operand\" \"f\")))]\n+  \"TARGET_HARD_FLOAT\"\n+  \"ole.s\\\\t%0, %1, %2\"\n+  [(set_attr \"type\"\t\"farith\")\n+   (set_attr \"mode\"\t\"BL\")\n+   (set_attr \"length\"\t\"3\")])\n+\n+\n+;;\n+;;  ....................\n+;;\n+;;\tUNCONDITIONAL BRANCHES\n+;;\n+;;  ....................\n+;;\n+\n+(define_insn \"jump\"\n+  [(set (pc)\n+\t(label_ref (match_operand 0 \"\" \"\")))]\n+  \"\"\n+  \"j\\\\t%l0\"\n+  [(set_attr \"type\"\t\"jump\")\n+   (set_attr \"mode\"\t\"none\")\n+   (set_attr \"length\"\t\"3\")])\n+\n+(define_expand \"indirect_jump\"\n+  [(set (pc) (match_operand 0 \"register_operand\" \"\"))]\n+  \"\"\n+  \"\n+{\n+  rtx dest = operands[0];\n+  if (GET_CODE (dest) != REG || GET_MODE (dest) != Pmode)\n+    operands[0] = copy_to_mode_reg (Pmode, dest);\n+\n+  emit_jump_insn (gen_indirect_jump_internal (dest));\n+  DONE;\n+}\")\n+\n+(define_insn \"indirect_jump_internal\"\n+  [(set (pc) (match_operand:SI 0 \"register_operand\" \"r\"))]\n+  \"\"\n+  \"jx\\\\t%0\"\n+  [(set_attr \"type\"\t\"jump\")\n+   (set_attr \"mode\"\t\"none\")\n+   (set_attr \"length\"\t\"3\")])\n+\n+\n+(define_expand \"tablejump\"\n+  [(use (match_operand:SI 0 \"register_operand\" \"\"))\n+   (use (label_ref (match_operand 1 \"\" \"\")))]\n+   \"\"\n+   \"\n+{\n+  rtx target = operands[0];\n+  if (flag_pic)\n+    {\n+      /* For PIC, the table entry is relative to the start of the table. */\n+      rtx label = gen_reg_rtx (SImode);\n+      target = gen_reg_rtx (SImode);\n+      emit_move_insn (label, gen_rtx_LABEL_REF (SImode, operands[1]));\n+      emit_insn (gen_addsi3 (target, operands[0], label));\n+    }\n+  emit_jump_insn (gen_tablejump_internal (target, operands[1]));\n+  DONE;\n+}\")\n+\n+(define_insn \"tablejump_internal\"\n+  [(set (pc)\n+\t(match_operand:SI 0 \"register_operand\" \"r\"))\n+   (use (label_ref (match_operand 1 \"\" \"\")))]\n+  \"\"\n+  \"jx\\\\t%0\"\n+  [(set_attr \"type\"\t\"jump\")\n+   (set_attr \"mode\"\t\"none\")\n+   (set_attr \"length\"\t\"3\")])\n+\n+\n+;;\n+;;  ....................\n+;;\n+;;\tFUNCTION CALLS\n+;;\n+;;  ....................\n+;;\n+\n+(define_expand \"sym_PLT\"\n+  [(const (unspec [(match_operand:SI 0 \"\" \"\")] UNSPEC_PLT))]\n+  \"\"\n+  \"\")\n+\n+(define_expand \"call\"\n+  [(call (match_operand 0 \"memory_operand\" \"\")\n+\t (match_operand 1 \"\" \"\"))]\n+  \"\"\n+  \"\n+{\n+  rtx addr = XEXP (operands[0], 0);\n+  if (flag_pic && GET_CODE (addr) == SYMBOL_REF && !SYMBOL_REF_FLAG (addr))\n+    addr = gen_sym_PLT (addr);\n+  if (!call_insn_operand (addr, VOIDmode))\n+    XEXP (operands[0], 0) = copy_to_mode_reg (Pmode, addr);\n+}\")\n+\n+(define_insn \"call_internal\"\n+  [(call (mem (match_operand:SI 0 \"call_insn_operand\" \"n,i,r\"))\n+\t (match_operand 1 \"\" \"i,i,i\"))]\n+  \"\"\n+  \"*\n+    return xtensa_emit_call (0, operands);\n+  \"\n+  [(set_attr \"type\"\t\"call\")\n+   (set_attr \"mode\"\t\"none\")\n+   (set_attr \"length\"\t\"3\")])\n+\n+(define_expand \"call_value\"\n+  [(set (match_operand 0 \"register_operand\" \"\")\n+\t(call (match_operand 1 \"memory_operand\" \"\")\n+\t      (match_operand 2 \"\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  rtx addr = XEXP (operands[1], 0);\n+  if (flag_pic && GET_CODE (addr) == SYMBOL_REF && !SYMBOL_REF_FLAG (addr))\n+    addr = gen_sym_PLT (addr);\n+  if (!call_insn_operand (addr, VOIDmode))\n+    XEXP (operands[1], 0) = copy_to_mode_reg (Pmode, addr);\n+}\")\n+\n+;; cannot combine constraints for operand 0 into \"afvb\"\n+;; reload.c:find_reloads seems to assume that grouped constraints somehow\n+;; specify related register classes, and when they don't the constraints\n+;; fail to match. By not grouping the constraints, we get the correct\n+;; behavior.\n+(define_insn \"call_value_internal\"\n+   [(set (match_operand 0 \"register_operand\" \"=af,af,af,v,v,v,b,b,b\")\n+         (call (mem (match_operand:SI 1 \"call_insn_operand\"\n+\t\t\t\t\t\"n,i,r,n,i,r,n,i,r\"))\n+               (match_operand 2 \"\" \"i,i,i,i,i,i,i,i,i\")))]\n+  \"\"\n+  \"*\n+    return xtensa_emit_call (1, operands);\n+  \"\n+  [(set_attr \"type\"\t\"call\")\n+   (set_attr \"mode\"\t\"none\")\n+   (set_attr \"length\"\t\"3\")])\n+\n+(define_insn \"return\"\n+  [(return)\n+   (use (reg:SI A0_REG))]\n+  \"reload_completed\"\n+  \"*\n+{\n+  return (TARGET_DENSITY ? \\\"retw.n\\\" : \\\"retw\\\");\n+}\"\n+  [(set_attr \"type\"\t\"jump\")\n+   (set_attr \"mode\"\t\"none\")\n+   (set_attr \"length\"\t\"2\")])\n+\n+\n+;;\n+;;  ....................\n+;;\n+;;\tMISC.\n+;;\n+;;  ....................\n+;;\n+\n+(define_insn \"nop\"\n+  [(const_int 0)]\n+  \"\"\n+  \"*\n+{\n+  return (TARGET_DENSITY ? \\\"nop.n\\\" : \\\"nop\\\");\n+}\"\n+  [(set_attr \"type\"\t\"nop\")\n+   (set_attr \"mode\"\t\"none\")\n+   (set_attr \"length\"\t\"3\")])\n+\n+(define_expand \"nonlocal_goto\"\n+  [(match_operand:SI 0 \"general_operand\" \"\")\n+   (match_operand:SI 1 \"general_operand\" \"\")\n+   (match_operand:SI 2 \"general_operand\" \"\")\n+   (match_operand:SI 3 \"\" \"\")]\n+  \"\"\n+  \"\n+{\n+  xtensa_expand_nonlocal_goto (operands);\n+  DONE;\n+}\")\n+\n+;; Setting up a frame pointer is tricky for Xtensa because GCC doesn't\n+;; know if a frame pointer is required until the reload pass, and\n+;; because there may be an incoming argument value in the hard frame\n+;; pointer register (a7). If there is an incoming argument in that\n+;; register, the \"set_frame_ptr\" insn gets inserted immediately after\n+;; the insn that copies the incoming argument to a pseudo or to the\n+;; stack.  This serves several purposes here: (1) it keeps the\n+;; optimizer from copy-propagating or scheduling the use of a7 as an\n+;; incoming argument away from the beginning of the function; (2) we\n+;; can use a post-reload splitter to expand away the insn if a frame\n+;; pointer is not required, so that the post-reload scheduler can do\n+;; the right thing; and (3) it makes it easy for xtensa_reorg() to\n+;; search for this insn to determine whether it should add a new insn\n+;; to set up the frame pointer.\n+\n+(define_insn \"set_frame_ptr\"\n+  [(unspec_volatile [(const_int 0)] UNSPECV_SET_FP)]\n+  \"\"\n+  \"*\n+{\n+  if (frame_pointer_needed)\n+    return \\\"mov\\\\ta7, sp\\\";\n+  return \\\"\\\";\n+}\"\n+  [(set_attr \"type\"\t\"move\")\n+   (set_attr \"mode\"\t\"SI\")\n+   (set_attr \"length\"\t\"3\")])\n+\n+;; Post-reload splitter to remove fp assignment when it's not needed.\n+(define_split\n+  [(unspec_volatile [(const_int 0)] UNSPECV_SET_FP)]\n+  \"reload_completed && !frame_pointer_needed\"\n+  [(unspec [(const_int 0)] UNSPEC_NOP)]\n+  \"\")\n+\n+;; The preceding splitter needs something to split the insn into;\n+;; things start breaking if the result is just a \"use\" so instead we\n+;; generate the following insn.\n+(define_insn \"\"\n+  [(unspec [(const_int 0)] UNSPEC_NOP)]\n+  \"\"\n+  \"\"\n+  [(set_attr \"type\"\t\"nop\")\n+   (set_attr \"mode\"\t\"none\")\n+   (set_attr \"length\"\t\"0\")])\n+\n+;;\n+;;  ....................\n+;;\n+;;\tBOOLEANS\n+;;\n+;;  ....................\n+;;\n+\n+;; branch patterns\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else (match_operator 2 \"boolean_operator\"\n+\t\t\t [(match_operand:CC 0 \"register_operand\" \"b\")\n+\t\t\t  (const_int 0)])\n+\t\t      (label_ref (match_operand 1 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"TARGET_BOOLEANS\"\n+  \"*\n+{\n+  if (GET_CODE (operands[2]) == EQ)\n+    return \\\"bf\\\\t%0, %1\\\";\n+  else\n+    return \\\"bt\\\\t%0, %1\\\";\n+}\"\n+  [(set_attr \"type\"\t\"jump\")\n+   (set_attr \"mode\"\t\"none\")\n+   (set_attr \"length\"\t\"3\")])\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else (match_operator 2 \"boolean_operator\"\n+\t\t\t [(match_operand:CC 0 \"register_operand\" \"b\")\n+\t\t\t  (const_int 0)])\n+\t\t      (pc)\n+\t\t      (label_ref (match_operand 1 \"\" \"\"))))]\n+  \"TARGET_BOOLEANS\"\n+  \"*\n+{\n+  if (GET_CODE (operands[2]) == EQ)\n+    return \\\"bt\\\\t%0, %1\\\";\n+  else\n+    return \\\"bf\\\\t%0, %1\\\";\n+}\"\n+  [(set_attr \"type\"\t\"jump\")\n+   (set_attr \"mode\"\t\"none\")\n+   (set_attr \"length\"\t\"3\")])"}, {"sha": "ac9e8860d38cbd047504481d39a8cafd44ce29f1", "filename": "gcc/cse.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/039843087a884e96058fd0fcde72339974d49e81/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/039843087a884e96058fd0fcde72339974d49e81/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=039843087a884e96058fd0fcde72339974d49e81", "patch": "@@ -2272,10 +2272,10 @@ canon_hash (x, mode)\n \t\t|| CLASS_LIKELY_SPILLED_P (REGNO_REG_CLASS (regno))\n \t\t|| (SMALL_REGISTER_CLASSES\n \t\t    && ! fixed_regs[regno]\n-\t\t    && regno != FRAME_POINTER_REGNUM\n-\t\t    && regno != HARD_FRAME_POINTER_REGNUM\n-\t\t    && regno != ARG_POINTER_REGNUM\n-\t\t    && regno != STACK_POINTER_REGNUM\n+\t\t    && x != frame_pointer_rtx\n+\t\t    && x != hard_frame_pointer_rtx\n+\t\t    && x != arg_pointer_rtx\n+\t\t    && x != stack_pointer_rtx\n \t\t    && GET_MODE_CLASS (GET_MODE (x)) != MODE_CC)))\n \t  {\n \t    do_not_record = 1;"}, {"sha": "fd8a5824ed2b65a8bd9ad3db8cbd38d08544f60a", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 192, "deletions": 0, "changes": 192, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/039843087a884e96058fd0fcde72339974d49e81/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/039843087a884e96058fd0fcde72339974d49e81/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=039843087a884e96058fd0fcde72339974d49e81", "patch": "@@ -636,6 +636,24 @@ in the following sections.\n @gccoptlist{\n -msim}\n \n+@emph{Xtensa Options}\n+@gccoptlist{\n+-mbig-endian -mlittle-endian @gol\n+-mdensity -mno-density @gol\n+-mmac16 -mno-mac16 @gol\n+-mmul16 -mno-mul16 @gol\n+-mmul32 -mno-mul32 @gol\n+-mnsa -mno-nsa @gol\n+-mminmax -mno-minmax @gol\n+-msext -mno-sext @gol\n+-mbooleans -mno-booleans @gol\n+-mhard-float -msoft-float @gol\n+-mfused-madd -mno-fused-madd @gol\n+-mserialize-volatile -mno-serialize-volatile @gol\n+-mtext-section-literals -mno-text-section-literals @gol\n+-mtarget-align -mno-target-align @gol\n+-mlongcalls -mno-longcalls}\n+\n @item Code Generation Options\n @xref{Code Gen Options,,Options for Code Generation Conventions}.\n @gccoptlist{\n@@ -5116,6 +5134,7 @@ that macro, which enables you to change the defaults.\n * MMIX Options::\n * PDP-11 Options::\n * Xstormy16 Options::\n+* Xtensa Options::\n @end menu\n \n @node M680x0 Options\n@@ -9604,6 +9623,179 @@ These options are defined for Xstormy16:\n Choose startup files and linker script suitable for the simulator.\n @end table\n \n+@node Xtensa Options\n+@subsection Xtensa Options\n+@cindex Xtensa Options\n+\n+The Xtensa architecture is designed to support many different\n+configurations.  The compiler's default options can be set to match a\n+particular Xtensa configuration by copying a configuration file into the\n+GCC sources when building GCC@.  The options below may be used to\n+override the default options.\n+\n+@table @gcctabopt\n+@item -mbig-endian\n+@itemx -mlittle-endian\n+@opindex mbig-endian\n+@opindex mlittle-endian\n+Specify big-endian or little-endian byte ordering for the target Xtensa\n+processor.\n+\n+@item -mdensity\n+@itemx -mno-density\n+@opindex mdensity\n+@opindex mno-density\n+Enable or disable use of the optional Xtensa code density instructions.\n+\n+@item -mmac16\n+@itemx -mno-mac16\n+@opindex mmac16\n+@opindex mno-mac16\n+Enable or disable use of the Xtensa MAC16 option.  When enabled, GCC\n+will generate MAC16 instructions from standard C code, with the\n+limitation that it will use neither the MR register file nor any\n+instruction that operates on the MR registers.  When this option is\n+disabled, GCC will translate 16-bit multiply/accumulate operations to a\n+combination of core instructions and library calls, depending on whether\n+any other multiplier options are enabled.\n+\n+@item -mmul16\n+@itemx -mno-mul16\n+@opindex mmul16\n+@opindex mno-mul16\n+Enable or disable use of the 16-bit integer multiplier option.  When\n+enabled, the compiler will generate 16-bit multiply instructions for\n+multiplications of 16 bits or smaller in standard C code.  When this\n+option is disabled, the compiler will either use 32-bit multiply or\n+MAC16 instructions if they are available or generate library calls to\n+perform the multiply operations using shifts and adds.\n+\n+@item -mmul32\n+@itemx -mno-mul32\n+@opindex mmul32\n+@opindex mno-mul32\n+Enable or disable use of the 32-bit integer multiplier option.  When\n+enabled, the compiler will generate 32-bit multiply instructions for\n+multiplications of 32 bits or smaller in standard C code.  When this\n+option is disabled, the compiler will generate library calls to perform\n+the multiply operations using either shifts and adds or 16-bit multiply\n+instructions if they are available.\n+\n+@item -mnsa\n+@itemx -mno-nsa\n+@opindex mnsa\n+@opindex mno-nsa\n+Enable or disable use of the optional normalization shift amount\n+(@code{NSA}) instructions to implement the built-in @code{ffs} function.\n+\n+@item -mminmax\n+@itemx -mno-minmax\n+@opindex mminmax\n+@opindex mno-minmax\n+Enable or disable use of the optional minimum and maximum value\n+instructions.\n+\n+@item -msext\n+@itemx -mno-sext\n+@opindex msext\n+@opindex mno-sext\n+Enable or disable use of the optional sign extend (@code{SEXT})\n+instruction.\n+\n+@item -mbooleans\n+@itemx -mno-booleans\n+@opindex mbooleans\n+@opindex mno-booleans\n+Enable or disable support for the boolean register file used by Xtensa\n+coprocessors.  This is not typically useful by itself but may be\n+required for other options that make use of the boolean registers (e.g.,\n+the floating-point option).\n+\n+@item -mhard-float\n+@itemx -msoft-float\n+@opindex mhard-float\n+@opindex msoft-float\n+Enable or disable use of the floating-point option.  When enabled, GCC\n+generates floating-point instructions for 32-bit @code{float}\n+operations.  When this option is disabled, GCC generates library calls\n+to emulate 32-bit floating-point operations using integer instructions.\n+Regardless of this option, 64-bit @code{double} operations are always\n+emulated with calls to library functions.\n+\n+@item -mfused-madd\n+@itemx -mno-fused-madd\n+@opindex mfused-madd\n+@opindex mno-fused-madd\n+Enable or disable use of fused multiply/add and multiply/subtract\n+instructions in the floating-point option.  This has no effect if the\n+floating-point option is not also enabled.  Disabling fused multiply/add\n+and multiply/subtract instructions forces the compiler to use separate\n+instructions for the multiply and add/subtract operations.  This may be\n+desirable in some cases where strict IEEE 754-compliant results are\n+required: the fused multiply add/subtract instructions do not round the\n+intermediate result, thereby producing results with @emph{more} bits of\n+precision than specified by the IEEE standard.  Disabling fused multiply\n+add/subtract instructions also ensures that the program output is not\n+sensitive to the compiler's ability to combine multiply and add/subtract\n+operations.\n+\n+@item -mserialize-volatile\n+@itemx -mno-serialize-volatile\n+@opindex mserialize-volatile\n+@opindex mno-serialize-volatile\n+When this option is enabled, GCC inserts @code{MEMW} instructions before\n+@code{volatile} memory references to guarantee sequential consistency.\n+The default is @option{-mserialize-volatile}.  Use\n+@option{-mno-serialize-volatile} to omit the @code{MEMW} instructions.\n+\n+@item -mtext-section-literals\n+@itemx -mno-text-section-literals\n+@opindex mtext-section-literals\n+@opindex mno-text-section-literals\n+Control the treatment of literal pools.  The default is\n+@option{-mno-text-section-literals}, which places literals in a separate\n+section in the output file.  This allows the literal pool to be placed\n+in a data RAM/ROM, and it also allows the linker to combine literal\n+pools from separate object files to remove redundant literals and\n+improve code size.  With @option{-mtext-section-literals}, the literals\n+are interspersed in the text section in order to keep them as close as\n+possible to their references.  This may be necessary for large assembly\n+files.\n+\n+@item -mtarget-align\n+@itemx -mno-target-align\n+@opindex mtarget-align\n+@opindex mno-target-align\n+When this option is enabled, GCC instructs the assembler to\n+automatically align instructions to reduce branch penalties at the\n+expense of some code density.  The assembler attempts to widen density\n+instructions to align branch targets and the instructions following call\n+instructions.  If there are not enough preceding safe density\n+instructions to align a target, no widening will be performed.  The\n+default is @option{-mtarget-align}.  These options do not affect the\n+treatment of auto-aligned instructions like @code{LOOP}, which the\n+assembler will always align, either by widening density instructions or\n+by inserting no-op instructions.\n+\n+@item -mlongcalls\n+@itemx -mno-longcalls\n+@opindex mlongcalls\n+@opindex mno-longcalls\n+When this option is enabled, GCC instructs the assembler to translate\n+direct calls to indirect calls unless it can determine that the target\n+of a direct call is in the range allowed by the call instruction.  This\n+translation typically occurs for calls to functions in other source\n+files.  Specifically, the assembler translates a direct @code{CALL}\n+instruction into an @code{L32R} followed by a @code{CALLX} instruction.\n+The default is @option{-mno-longcalls}.  This option should be used in\n+programs where the call target can potentially be out of range.  This\n+option is implemented in the assembler, not the compiler, so the\n+assembly code generated by GCC will still show direct call\n+instructions---look at the disassembled object code to see the actual\n+instructions.  Note that the assembler will use an indirect call for\n+every cross-file call, not just those that really will be out of range.\n+@end table\n+\n @node Code Gen Options\n @section Options for Code Generation Conventions\n @cindex code generation conventions"}, {"sha": "ca59a6c69e01335c4b70fe30e8245e29fd745b4e", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/039843087a884e96058fd0fcde72339974d49e81/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/039843087a884e96058fd0fcde72339974d49e81/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=039843087a884e96058fd0fcde72339974d49e81", "patch": "@@ -2068,6 +2068,31 @@ A constant that is not between 2 and 15 inclusive.\n \n @end table\n \n+@item Xtensa---@file{xtensa.h}\n+@table @code\n+@item a\n+General-purpose 32-bit register\n+\n+@item b\n+One-bit boolean register\n+\n+@item A\n+MAC16 40-bit accumulator register\n+\n+@item I\n+Signed 12-bit integer constant, for use in MOVI instructions\n+\n+@item J\n+Signed 8-bit integer constant, for use in ADDI instructions\n+\n+@item K\n+Integer constant valid for BccI instructions\n+\n+@item L\n+Unsigned constant valid for BccUI instructions\n+\n+@end table\n+\n @end table\n \n @ifset INTERNALS"}, {"sha": "10d98f2f8a83950a2260ef59d9ff0d539cfbdcfa", "filename": "gcc/integrate.c", "status": "modified", "additions": 44, "deletions": 6, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/039843087a884e96058fd0fcde72339974d49e81/gcc%2Fintegrate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/039843087a884e96058fd0fcde72339974d49e81/gcc%2Fintegrate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintegrate.c?ref=039843087a884e96058fd0fcde72339974d49e81", "patch": "@@ -1318,6 +1318,7 @@ copy_insn_list (insns, map, static_chain_value)\n #ifdef HAVE_cc0\n   rtx cc0_insn = 0;\n #endif\n+  rtx static_chain_mem = 0;\n \n   /* Copy the insns one by one.  Do this in two passes, first the insns and\n      then their REG_NOTES.  */\n@@ -1381,25 +1382,62 @@ copy_insn_list (insns, map, static_chain_value)\n \t\t   && REG_FUNCTION_VALUE_P (XEXP (pattern, 0)))\n \t    break;\n \n-\t  /* If this is setting the static chain rtx, omit it.  */\n+\t  /* Look for the address of the static chain slot. The\n+             rtx_equal_p comparisons against the\n+             static_chain_incoming_rtx below may fail if the static\n+             chain is in memory and the address specified is not\n+             \"legitimate\".  This happens on Xtensa where the static\n+             chain is at a negative offset from argp and where only\n+             positive offsets are legitimate.  When the RTL is\n+             generated, the address is \"legitimized\" by copying it\n+             into a register, causing the rtx_equal_p comparisons to\n+             fail.  This workaround looks for code that sets a\n+             register to the address of the static chain.  Subsequent\n+             memory references via that register can then be\n+             identified as static chain references.  We assume that\n+             the register is only assigned once, and that the static\n+             chain address is only live in one register at a time. */\n+\n \t  else if (static_chain_value != 0\n \t\t   && set != 0\n+\t\t   && GET_CODE (static_chain_incoming_rtx) == MEM\n \t\t   && GET_CODE (SET_DEST (set)) == REG\n-\t\t   && rtx_equal_p (SET_DEST (set),\n-\t\t\t\t   static_chain_incoming_rtx))\n+\t\t   && rtx_equal_p (SET_SRC (set),\n+\t\t\t\t   XEXP (static_chain_incoming_rtx, 0)))\n+\t    {\n+\t      static_chain_mem =\n+\t\t  gen_rtx_MEM (GET_MODE (static_chain_incoming_rtx),\n+\t\t\t       SET_DEST (set));\n+\n+\t      /* emit the instruction in case it is used for something\n+\t\t other than setting the static chain; if it's not used,\n+\t\t it can always be removed as dead code */\n+\t      copy = emit_insn (copy_rtx_and_substitute (pattern, map, 0));\n+\t    }\n+\n+\t  /* If this is setting the static chain rtx, omit it.  */\n+\t  else if (static_chain_value != 0\n+\t\t   && set != 0\n+\t\t   && (rtx_equal_p (SET_DEST (set),\n+\t\t\t\t    static_chain_incoming_rtx)\n+\t\t       || (static_chain_mem\n+\t\t\t   && rtx_equal_p (SET_DEST (set), static_chain_mem))))\n \t    break;\n \n \t  /* If this is setting the static chain pseudo, set it from\n \t     the value we want to give it instead.  */\n \t  else if (static_chain_value != 0\n \t\t   && set != 0\n-\t\t   && rtx_equal_p (SET_SRC (set),\n-\t\t\t\t   static_chain_incoming_rtx))\n+\t\t   && (rtx_equal_p (SET_SRC (set),\n+\t\t\t\t    static_chain_incoming_rtx)\n+\t\t       || (static_chain_mem\n+\t\t\t   && rtx_equal_p (SET_SRC (set), static_chain_mem))))\n \t    {\n \t      rtx newdest = copy_rtx_and_substitute (SET_DEST (set), map, 1);\n \n \t      copy = emit_move_insn (newdest, static_chain_value);\n-\t      static_chain_value = 0;\n+\t      if (GET_CODE (static_chain_incoming_rtx) != MEM)\n+\t\tstatic_chain_value = 0;\n \t    }\n \n \t  /* If this is setting the virtual stack vars register, this must"}, {"sha": "eb918c3eaecdbcb1f5d4431578ca029524149493", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/039843087a884e96058fd0fcde72339974d49e81/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/039843087a884e96058fd0fcde72339974d49e81/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=039843087a884e96058fd0fcde72339974d49e81", "patch": "@@ -1,3 +1,7 @@\n+2002-01-23  Bob Wilson  <bob.wilson@acm.org>\n+\n+\t* gcc.c-torture/compile/20001226-1.x: xfail for Xtensa.\n+\n 2002-01-23  Janis Johnson  <janis187@us.ibm.com>\n \n \t* gcc.dg/20020122-3.c: New."}, {"sha": "f1f000f8889ab7a97ccb58cb7f15ebdb9fb42088", "filename": "gcc/testsuite/gcc.c-torture/compile/20001226-1.x", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/039843087a884e96058fd0fcde72339974d49e81/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20001226-1.x", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/039843087a884e96058fd0fcde72339974d49e81/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20001226-1.x", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20001226-1.x?ref=039843087a884e96058fd0fcde72339974d49e81", "patch": "@@ -1,8 +1,12 @@\n # This does not assemble on m68hc11 because the function is larger\n # than 64K.\n \n+# It doesn't work on Xtensa with -O0 because the function is larger\n+# than the range of a jump instruction (+- 128K) and the assembler\n+# does not yet relax jumps to indirect jumps.\n+\n global target_triplet\n-if { [istarget \"m6811-*-*\"] || [istarget \"m6812-*-*\"] } {\n+if { [istarget \"m6811-*-*\"] || [istarget \"m6812-*-*\"] || [istarget \"xtensa-*-*\"]} {\n       set torture_compile_xfail \"$target_triplet\"\n       return 1\n }"}]}