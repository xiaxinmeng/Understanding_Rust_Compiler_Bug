{"sha": "9485d254d16e4f64b5c853b8f16a6cd476cf333b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTQ4NWQyNTRkMTZlNGY2NGI1Yzg1M2I4ZjE2YTZjZDQ3NmNmMzMzYg==", "commit": {"author": {"name": "Paolo Carlini", "email": "paolo.carlini@oracle.com", "date": "2013-08-19T14:23:37Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2013-08-19T14:23:37Z"}, "message": "parser.c (cp_parser_lambda_introducer, [...]): Use cp_parser_lookup_name_simple.\n\n2013-08-19  Paolo Carlini  <paolo.carlini@oracle.com>\n\n\t* parser.c (cp_parser_lambda_introducer, cp_parser_decltype_expr):\n\tUse cp_parser_lookup_name_simple.\n\n2013-08-19  Paolo Carlini  <paolo.carlini@oracle.com>\n\n\t* name-lookup.h (pop_bindings_and_leave_scope): Declare.\n\t* name-lookup.c (pop_bindings_and_leave_scope): Define.\n\t* parser.c (cp_parser_lambda_declarator_opt,\n\tcp_parser_direct_declarator, cp_parser_cache_defarg): Use it.\n\nFrom-SVN: r201839", "tree": {"sha": "56a2ea14fd30ce50d4202acac83a48c945c4a6e4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/56a2ea14fd30ce50d4202acac83a48c945c4a6e4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9485d254d16e4f64b5c853b8f16a6cd476cf333b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9485d254d16e4f64b5c853b8f16a6cd476cf333b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9485d254d16e4f64b5c853b8f16a6cd476cf333b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9485d254d16e4f64b5c853b8f16a6cd476cf333b/comments", "author": null, "committer": null, "parents": [{"sha": "d33d9e47d4392e7cb82d8cd585807cf72872e11d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d33d9e47d4392e7cb82d8cd585807cf72872e11d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d33d9e47d4392e7cb82d8cd585807cf72872e11d"}], "stats": {"total": 62, "additions": 32, "deletions": 30}, "files": [{"sha": "e4bf66994bbd199da7c344a911d37c0d2beec2ca", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9485d254d16e4f64b5c853b8f16a6cd476cf333b/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9485d254d16e4f64b5c853b8f16a6cd476cf333b/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=9485d254d16e4f64b5c853b8f16a6cd476cf333b", "patch": "@@ -1,3 +1,15 @@\n+2013-08-19  Paolo Carlini  <paolo.carlini@oracle.com>\n+\n+\t* parser.c (cp_parser_lambda_introducer, cp_parser_decltype_expr):\n+\tUse cp_parser_lookup_name_simple.\n+\n+2013-08-19  Paolo Carlini  <paolo.carlini@oracle.com>\n+\n+\t* name-lookup.h (pop_bindings_and_leave_scope): Declare.\n+\t* name-lookup.c (pop_bindings_and_leave_scope): Define.\n+\t* parser.c (cp_parser_lambda_declarator_opt,\n+\tcp_parser_direct_declarator, cp_parser_cache_defarg): Use it.\n+\n 2013-08-17  Jason Merrill  <jason@redhat.com>\n \n \tPR c++/58083"}, {"sha": "b09e85bcb66487a8c0764c367a080fa189e18a73", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9485d254d16e4f64b5c853b8f16a6cd476cf333b/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9485d254d16e4f64b5c853b8f16a6cd476cf333b/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=9485d254d16e4f64b5c853b8f16a6cd476cf333b", "patch": "@@ -392,6 +392,17 @@ pop_binding (tree id, tree decl)\n     }\n }\n \n+/* Remove the bindings for the decls of the current level and leave\n+   the current scope.  */\n+\n+void\n+pop_bindings_and_leave_scope (void)\n+{\n+  for (tree t = getdecls (); t; t = DECL_CHAIN (t))\n+    pop_binding (DECL_NAME (t), t);\n+  leave_scope ();\n+}\n+\n /* Strip non dependent using declarations.  */\n \n tree"}, {"sha": "57641a1990289e10d92d31bcb49af32c386c11f8", "filename": "gcc/cp/name-lookup.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9485d254d16e4f64b5c853b8f16a6cd476cf333b/gcc%2Fcp%2Fname-lookup.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9485d254d16e4f64b5c853b8f16a6cd476cf333b/gcc%2Fcp%2Fname-lookup.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.h?ref=9485d254d16e4f64b5c853b8f16a6cd476cf333b", "patch": "@@ -89,6 +89,7 @@ typedef struct GTY(()) cxx_saved_binding {\n extern tree identifier_type_value (tree);\n extern void set_identifier_type_value (tree, tree);\n extern void pop_binding (tree, tree);\n+extern void pop_bindings_and_leave_scope (void);\n extern tree constructor_name (tree);\n extern bool constructor_name_p (tree, tree);\n \f"}, {"sha": "923277b6daa7cb46f8403c22998ffa5ea132ca1e", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 8, "deletions": 30, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9485d254d16e4f64b5c853b8f16a6cd476cf333b/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9485d254d16e4f64b5c853b8f16a6cd476cf333b/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=9485d254d16e4f64b5c853b8f16a6cd476cf333b", "patch": "@@ -8710,15 +8710,8 @@ cp_parser_lambda_introducer (cp_parser* parser, tree lambda_expr)\n \n \t  /* Turn the identifier into an id-expression.  */\n \t  capture_init_expr\n-            = cp_parser_lookup_name\n-                (parser,\n-\t\t capture_id,\n-                 none_type,\n-                 /*is_template=*/false,\n-                 /*is_namespace=*/false,\n-                 /*check_dependency=*/true,\n-                 /*ambiguous_decls=*/NULL,\n-                 capture_token->location);\n+\t    = cp_parser_lookup_name_simple (parser, capture_id,\n+\t\t\t\t\t    capture_token->location);\n \n \t  if (capture_init_expr == error_mark_node)\n \t    {\n@@ -8809,7 +8802,6 @@ cp_parser_lambda_declarator_opt (cp_parser* parser, tree lambda_expr)\n   tree param_list = void_list_node;\n   tree attributes = NULL_TREE;\n   tree exception_spec = NULL_TREE;\n-  tree t;\n \n   /* The lambda-declarator is optional, but must begin with an opening\n      parenthesis if present.  */\n@@ -8824,7 +8816,7 @@ cp_parser_lambda_declarator_opt (cp_parser* parser, tree lambda_expr)\n \n       /* Default arguments shall not be specified in the\n \t parameter-declaration-clause of a lambda-declarator.  */\n-      for (t = param_list; t; t = TREE_CHAIN (t))\n+      for (tree t = param_list; t; t = TREE_CHAIN (t))\n \tif (TREE_PURPOSE (t))\n \t  pedwarn (DECL_SOURCE_LOCATION (TREE_VALUE (t)), OPT_Wpedantic,\n \t\t   \"default argument specified for lambda parameter\");\n@@ -8853,10 +8845,7 @@ cp_parser_lambda_declarator_opt (cp_parser* parser, tree lambda_expr)\n \n       /* The function parameters must be in scope all the way until after the\n          trailing-return-type in case of decltype.  */\n-      for (t = current_binding_level->names; t; t = DECL_CHAIN (t))\n-\tpop_binding (DECL_NAME (t), t);\n-\n-      leave_scope ();\n+      pop_bindings_and_leave_scope ();\n     }\n \n   /* Create the function call operator.\n@@ -11583,13 +11572,8 @@ cp_parser_decltype_expr (cp_parser *parser,\n \n       if (identifier_p (expr))\n \t/* Lookup the name we got back from the id-expression.  */\n-\texpr = cp_parser_lookup_name (parser, expr,\n-\t\t\t\t      none_type,\n-\t\t\t\t      /*is_template=*/false,\n-\t\t\t\t      /*is_namespace=*/false,\n-\t\t\t\t      /*check_dependency=*/true,\n-\t\t\t\t      /*ambiguous_decls=*/NULL,\n-\t\t\t\t      id_expr_start_token->location);\n+\texpr = cp_parser_lookup_name_simple (parser, expr,\n+\t\t\t\t\t     id_expr_start_token->location);\n \n       if (expr\n           && expr != error_mark_node\n@@ -16741,7 +16725,6 @@ cp_parser_direct_declarator (cp_parser* parser,\n \t      tree params;\n \t      unsigned saved_num_template_parameter_lists;\n \t      bool is_declarator = false;\n-\t      tree t;\n \n \t      /* In a member-declarator, the only valid interpretation\n \t\t of a parenthesis is the start of a\n@@ -16830,9 +16813,7 @@ cp_parser_direct_declarator (cp_parser* parser,\n \t\t}\n \n \t      /* Remove the function parms from scope.  */\n-\t      for (t = current_binding_level->names; t; t = DECL_CHAIN (t))\n-\t\tpop_binding (DECL_NAME (t), t);\n-\t      leave_scope();\n+\t      pop_bindings_and_leave_scope ();\n \n \t      if (is_declarator)\n \t\t/* Repeat the main loop.  */\n@@ -24101,7 +24082,6 @@ cp_parser_cache_defarg (cp_parser *parser, bool nsdmi)\n \t\t the default argument; otherwise the default\n \t\t argument continues.  */\n \t      bool error = false;\n-\t      tree t;\n \n \t      /* Set ITALP so cp_parser_parameter_declaration_list\n \t\t doesn't decide to commit to this parse.  */\n@@ -24123,9 +24103,7 @@ cp_parser_cache_defarg (cp_parser *parser, bool nsdmi)\n \t\t{\n \t\t  begin_scope (sk_function_parms, NULL_TREE);\n \t\t  cp_parser_parameter_declaration_list (parser, &error);\n-\t\t  for (t = current_binding_level->names; t; t = DECL_CHAIN (t))\n-\t\t    pop_binding (DECL_NAME (t), t);\n-\t\t  leave_scope ();\n+\t\t  pop_bindings_and_leave_scope ();\n \t\t}\n \t      if (!cp_parser_error_occurred (parser) && !error)\n \t\tdone = true;"}]}