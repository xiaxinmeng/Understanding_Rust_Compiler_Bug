{"sha": "8eaa0f34a3387db91dd66466d201930e83332300", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGVhYTBmMzRhMzM4N2RiOTFkZDY2NDY2ZDIwMTkzMGU4MzMzMjMwMA==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "dvorakz@suse.cz", "date": "2005-03-14T16:26:11Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2005-03-14T16:26:11Z"}, "message": "tree-ssa-phiopt.c (minmax_replacement, [...]): New functions.\n\n\t* tree-ssa-phiopt.c (minmax_replacement, blocks_in_phiopt_order):\n\tNew functions.\n\t(tree_ssa_phiopt): Use blocks_in_phiopt_order and minmax_replacement.\n\tRemove unused removed_phis variable.\n\t(conditional_replacement): Use build1/build2.\n\t(abs_replacement): Use last_and_only_stmt and build1/build2.\n\n\t* gcc.dg/tree-ssa/phi-opt-5.c: New test.\n\nFrom-SVN: r96439", "tree": {"sha": "95d7ef07115c27e647edbe4b995cc725bc5f2270", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/95d7ef07115c27e647edbe4b995cc725bc5f2270"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8eaa0f34a3387db91dd66466d201930e83332300", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8eaa0f34a3387db91dd66466d201930e83332300", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8eaa0f34a3387db91dd66466d201930e83332300", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8eaa0f34a3387db91dd66466d201930e83332300/comments", "author": null, "committer": null, "parents": [{"sha": "dcd6de6d69c1e59a28345db24de577f8e60fdbd0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dcd6de6d69c1e59a28345db24de577f8e60fdbd0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dcd6de6d69c1e59a28345db24de577f8e60fdbd0"}], "stats": {"total": 534, "additions": 458, "deletions": 76}, "files": [{"sha": "bb2cd5e0407812f209b64dc13e71f3f6e04f5d84", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8eaa0f34a3387db91dd66466d201930e83332300/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8eaa0f34a3387db91dd66466d201930e83332300/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8eaa0f34a3387db91dd66466d201930e83332300", "patch": "@@ -1,3 +1,12 @@\n+2005-03-14  Zdenek Dvorak  <dvorakz@suse.cz>\n+\n+\t* tree-ssa-phiopt.c (minmax_replacement, blocks_in_phiopt_order):\n+\tNew functions.\n+\t(tree_ssa_phiopt): Use blocks_in_phiopt_order and minmax_replacement.\n+\tRemove unused removed_phis variable.\n+\t(conditional_replacement): Use build1/build2.\n+\t(abs_replacement): Use last_and_only_stmt and build1/build2.\n+\n 2005-03-14  Zdenek Dvorak  <dvorakz@suse.cz>\n \n \t* builtin-attrs.def (ATTR_NOVOPS, ATTR_NOVOPS_LIST,"}, {"sha": "8ed2b48f36586a0722dca36e07439d8cd40142f3", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8eaa0f34a3387db91dd66466d201930e83332300/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8eaa0f34a3387db91dd66466d201930e83332300/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=8eaa0f34a3387db91dd66466d201930e83332300", "patch": "@@ -1,3 +1,7 @@\n+2005-03-14  Zdenek Dvorak  <dvorakz@suse.cz>\n+\n+\t* gcc.dg/tree-ssa/phi-opt-5.c: New test.\n+\n 2005-03-14  Zdenek Dvorak  <dvorakz@suse.cz>\n \n \t* gcc.dg/tree-ssa/20050314-1.c: New test."}, {"sha": "37041d7dabb7ac1ac8f96ac1295af98d1cc4d4ee", "filename": "gcc/testsuite/gcc.dg/tree-ssa/phi-opt-5.c", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8eaa0f34a3387db91dd66466d201930e83332300/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fphi-opt-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8eaa0f34a3387db91dd66466d201930e83332300/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fphi-opt-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fphi-opt-5.c?ref=8eaa0f34a3387db91dd66466d201930e83332300", "patch": "@@ -0,0 +1,58 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O1 -ffinite-math-only -fdump-tree-phiopt1\" } */\n+\n+float repl1 (float varx)\n+{\n+  if (varx < 0.0)\n+    return 0.0;\n+  else if (varx > 1.0)\n+    return 1.0;\n+  else\n+    return varx;\n+}\n+\n+/* Should be turned to\n+\n+   varx_4 = MIN_EXPR <1.0e+0, varx_2>;\n+   varx_5 = MAX_EXPR <varx_4, 0.0>;  */  \n+\n+/* { dg-final { scan-tree-dump \"varx.*MIN_EXPR.*1\\\\.0\" \"phiopt1\"} } */\n+/* { dg-final { scan-tree-dump \"varx.*MAX_EXPR.*0\\\\.0\" \"phiopt1\"} } */\n+\n+float repl2 (float vary)\n+{\n+  if (vary > 1.0)\n+    return 1.0;\n+  else if (vary < 0.0)\n+    return 0.0;\n+  else\n+    return vary;\n+}\n+\n+/* Should be turned to\n+\n+   vary_4 = MAX_EXPR <0.0, vary_2>;\n+   vary_5 = MIN_EXPR <vary_4, 1.0e+0>;  */\n+\n+/* { dg-final { scan-tree-dump \"vary.*MAX_EXPR.*0\\\\.0\" \"phiopt1\"} } */\n+/* { dg-final { scan-tree-dump \"vary.*MIN_EXPR.*1\\\\.0\" \"phiopt1\"} } */\n+\n+float repl3 (float varz, float vara, float varb)\n+{\n+  if (varz > vara)\n+    return vara;\n+  else if (varz < varb)\n+    return varb;\n+  else\n+    return varz;\n+}\n+\n+/* Should be turned to\n+\n+  if (varz_2 > vara_3) goto <L4>; else goto <L1>;\n+\n+<L1>:;\n+  vara_6 = MAX_EXPR <varb_5, varz_2>;  */\n+\n+/* { dg-final { scan-tree-dump \"if .*varz\" \"phiopt1\"} } */\n+/* { dg-final { scan-tree-dump \"vara.*MAX_EXPR\" \"phiopt1\"} } */"}, {"sha": "3eedf9974e444c6f0f18d3a0e61c58f7b3d7847f", "filename": "gcc/tree-ssa-phiopt.c", "status": "modified", "additions": 387, "deletions": 76, "changes": 463, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8eaa0f34a3387db91dd66466d201930e83332300/gcc%2Ftree-ssa-phiopt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8eaa0f34a3387db91dd66466d201930e83332300/gcc%2Ftree-ssa-phiopt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-phiopt.c?ref=8eaa0f34a3387db91dd66466d201930e83332300", "patch": "@@ -41,10 +41,13 @@ static bool conditional_replacement (basic_block, basic_block, basic_block,\n \t\t\t\t     edge, edge, tree, tree, tree);\n static bool value_replacement (basic_block, basic_block, basic_block,\n \t\t\t       edge, edge, tree, tree, tree);\n+static bool minmax_replacement (basic_block, basic_block, basic_block,\n+\t\t\t\tedge, edge, tree, tree, tree);\n static bool abs_replacement (basic_block, basic_block, basic_block,\n \t\t\t     edge, edge, tree, tree, tree);\n static void replace_phi_edge_with_variable (basic_block, basic_block, edge,\n \t\t\t\t\t    tree, tree);\n+static basic_block *blocks_in_phiopt_order (void);\n \n /* This pass eliminates PHI nodes which can be trivially implemented as\n    an assignment from a conditional expression.  i.e. if we have something\n@@ -102,6 +105,21 @@ static void replace_phi_edge_with_variable (basic_block, basic_block, edge,\n      bb2:\n       x = ABS_EXPR< a >;\n \n+   Similarly,\n+\n+     bb0:\n+      if (a <= b) goto bb2; else goto bb1;\n+     bb1:\n+      goto bb2;\n+     bb2:\n+      x = PHI (b (bb1), a (bb0));\n+\n+   Becomes\n+\n+     x = MIN_EXPR (a, b)\n+\n+   And the same transformation for MAX_EXPR.\n+\n    bb1 will become unreachable and bb0 and bb2 will almost always be merged\n    into a single block.  Similar transformations are done by the ifcvt\n    RTL optimizer.  */\n@@ -110,15 +128,28 @@ static void\n tree_ssa_phiopt (void)\n {\n   basic_block bb;\n+  basic_block *bb_order;\n+  unsigned n, i;\n+\n+  /* Search every basic block for COND_EXPR we may be able to optimize.\n+\n+     We walk the blocks in order that guarantees that a block with\n+     a single predecessor is processed before the predecessor.\n+     This ensures that we collapse inner ifs before visiting the\n+     outer ones, and also that we do not try to visit a removed\n+     block.  */\n+  bb_order = blocks_in_phiopt_order ();\n+  n = n_basic_blocks;\n \n-  /* Search every basic block for COND_EXPR we may be able to optimize\n-     in reverse order so we can find more.  */\n-  FOR_EACH_BB_REVERSE (bb)\n+  for (i = 0; i < n; i++)\n     {\n       tree cond_expr;\n       tree phi;\n       basic_block bb1, bb2;\n       edge e1, e2;\n+      tree arg0, arg1;\n+\n+      bb = bb_order[i];\n \n       cond_expr = last_stmt (bb);\n       /* Check to see if the last statement is a COND_EXPR.  */\n@@ -174,25 +205,80 @@ tree_ssa_phiopt (void)\n       /* Check to make sure that there is only one PHI node.\n          TODO: we could do it with more than one iff the other PHI nodes\n \t have the same elements for these two edges.  */\n-      if (phi && PHI_CHAIN (phi) == NULL)\n-\t{\n-\t  tree arg0 = NULL, arg1 = NULL;\n+      if (!phi || PHI_CHAIN (phi) != NULL)\n+\tcontinue;\n \n-\t  arg0 = PHI_ARG_DEF_TREE (phi, e1->dest_idx);\n-\t  arg1 = PHI_ARG_DEF_TREE (phi, e2->dest_idx);\n+      arg0 = PHI_ARG_DEF_TREE (phi, e1->dest_idx);\n+      arg1 = PHI_ARG_DEF_TREE (phi, e2->dest_idx);\n \n-\t  /* We know something is wrong if we cannot find the edges in the PHI\n-\t     node.  */\n-\t  gcc_assert (arg0 != NULL && arg1 != NULL);\n+      /* We know something is wrong if we cannot find the edges in the PHI\n+\t node.  */\n+      gcc_assert (arg0 != NULL && arg1 != NULL);\n \n-\t  /* Do the replacement of conditional if it can be done.  */\n-\t  if (conditional_replacement (bb, bb1, bb2, e1, e2, phi, arg0, arg1)\n-\t      || value_replacement (bb, bb1, bb2, e1, e2, phi, arg0, arg1)\n-\t      || abs_replacement (bb, bb1, bb2, e1, e2, phi, arg0, arg1))\n-\t    {\n-\t    }\n+      /* Do the replacement of conditional if it can be done.  */\n+      if (conditional_replacement (bb, bb1, bb2, e1, e2, phi, arg0, arg1))\n+\t;\n+      else if (value_replacement (bb, bb1, bb2, e1, e2, phi, arg0, arg1))\n+\t;\n+      else if (abs_replacement (bb, bb1, bb2, e1, e2, phi, arg0, arg1))\n+\t;\n+      else\n+\tminmax_replacement (bb, bb1, bb2, e1, e2, phi, arg0, arg1);\n+    }\n+\n+  free (bb_order);\n+}\n+\n+/* Returns the list of basic blocks in the function in an order that guarantees\n+   that if a block X has just a single predecessor Y, then Y is after X in the\n+   ordering.  */\n+\n+static basic_block *\n+blocks_in_phiopt_order (void)\n+{\n+  basic_block x, y;\n+  basic_block *order = xmalloc (sizeof (basic_block) * n_basic_blocks);\n+  unsigned n = n_basic_blocks, np, i;\n+  sbitmap visited = sbitmap_alloc (last_basic_block + 2);\n+\n+#define MARK_VISITED(BB) (SET_BIT (visited, (BB)->index + 2))\n+#define VISITED_P(BB) (TEST_BIT (visited, (BB)->index + 2))\n+\n+  sbitmap_zero (visited);\n+\n+  MARK_VISITED (ENTRY_BLOCK_PTR);\n+  FOR_EACH_BB (x)\n+    {\n+      if (VISITED_P (x))\n+\tcontinue;\n+\n+      /* Walk the predecessors of x as long as they have precisely one\n+\t predecessor and add them to the list, so that they get stored\n+\t after x.  */\n+      for (y = x, np = 1;\n+\t   single_pred_p (y) && !VISITED_P (single_pred (y));\n+\t   y = single_pred (y))\n+\tnp++;\n+      for (y = x, i = n - np;\n+\t   single_pred_p (y) && !VISITED_P (single_pred (y));\n+\t   y = single_pred (y), i++)\n+\t{\n+\t  order[i] = y;\n+\t  MARK_VISITED (y);\n \t}\n+      order[i] = y;\n+      MARK_VISITED (y);\n+\n+      gcc_assert (i == n - 1);\n+      n -= np;\n     }\n+\n+  sbitmap_free (visited);\n+  gcc_assert (n == 0);\n+  return order;\n+\n+#undef MARK_VISITED\n+#undef VISITED_P\n }\n \n /* Return TRUE if block BB has no executable statements, otherwise return\n@@ -324,11 +410,11 @@ conditional_replacement (basic_block cond_bb, basic_block middle_bb,\n       if (!COMPARISON_CLASS_P (old_result))\n \treturn false;\n \n-      new1 = build (TREE_CODE (old_result), TREE_TYPE (old_result),\n-\t\t    TREE_OPERAND (old_result, 0),\n-\t\t    TREE_OPERAND (old_result, 1));\n+      new1 = build2 (TREE_CODE (old_result), TREE_TYPE (old_result),\n+\t\t     TREE_OPERAND (old_result, 0),\n+\t\t     TREE_OPERAND (old_result, 1));\n \n-      new1 = build (MODIFY_EXPR, TREE_TYPE (old_result), new_var, new1);\n+      new1 = build2 (MODIFY_EXPR, TREE_TYPE (old_result), new_var, new1);\n       bsi_insert_after (&bsi, new1, BSI_NEW_STMT);\n     }\n \n@@ -357,7 +443,7 @@ conditional_replacement (basic_block cond_bb, basic_block middle_bb,\n       || (e1 == true_edge && integer_onep (arg1))\n       || (e1 == false_edge && integer_zerop (arg1)))\n     {\n-      new = build (MODIFY_EXPR, TREE_TYPE (new_var1), new_var1, cond);\n+      new = build2 (MODIFY_EXPR, TREE_TYPE (new_var1), new_var1, cond);\n     }\n   else\n     {\n@@ -379,7 +465,7 @@ conditional_replacement (basic_block cond_bb, basic_block middle_bb,\n \t{\n \t  tree temp = TREE_OPERAND (cond, 0);\n \t  tree new_var_1 = make_rename_temp (TREE_TYPE (temp), NULL);\n-\t  new = build (MODIFY_EXPR, TREE_TYPE (new_var_1), new_var_1, temp);\n+\t  new = build2 (MODIFY_EXPR, TREE_TYPE (new_var_1), new_var_1, temp);\n \t  bsi_insert_after (&bsi, new, BSI_NEW_STMT);\n \t  cond = fold_convert (TREE_TYPE (result), new_var_1);\n \t}\n@@ -391,7 +477,7 @@ conditional_replacement (basic_block cond_bb, basic_block middle_bb,\n \t  return false;\n \t}\n \n-      new = build (MODIFY_EXPR, TREE_TYPE (new_var1), new_var1, cond);\n+      new = build2 (MODIFY_EXPR, TREE_TYPE (new_var1), new_var1, cond);\n     }\n \n   bsi_insert_after (&bsi, new, BSI_NEW_STMT);\n@@ -482,6 +568,257 @@ value_replacement (basic_block cond_bb, basic_block middle_bb,\n   return false;\n }\n \n+/*  The function minmax_replacement does the main work of doing the minmax\n+    replacement.  Return true if the replacement is done.  Otherwise return\n+    false.\n+    BB is the basic block where the replacement is going to be done on.  ARG0\n+    is argument 0 from the PHI.  Likewise for ARG1.  */\n+\n+static bool\n+minmax_replacement (basic_block cond_bb, basic_block middle_bb,\n+\t\t    basic_block phi_bb, edge e0, edge e1, tree phi,\n+\t\t    tree arg0, tree arg1)\n+{\n+  tree result, type;\n+  tree cond, new;\n+  edge true_edge, false_edge;\n+  enum tree_code cmp, minmax, ass_code;\n+  tree smaller, larger, arg_true, arg_false;\n+  block_stmt_iterator bsi, bsi_from;\n+\n+  type = TREE_TYPE (PHI_RESULT (phi));\n+\n+  /* The optimization may be unsafe due to NaNs.  */\n+  if (HONOR_NANS (TYPE_MODE (type)))\n+    return false;\n+\n+  cond = COND_EXPR_COND (last_stmt (cond_bb));\n+  cmp = TREE_CODE (cond);\n+  result = PHI_RESULT (phi);\n+\n+  /* This transformation is only valid for order comparisons.  Record which\n+     operand is smaller/larger if the result of the comparison is true.  */\n+  if (cmp == LT_EXPR || cmp == LE_EXPR)\n+    {\n+      smaller = TREE_OPERAND (cond, 0);\n+      larger = TREE_OPERAND (cond, 1);\n+    }\n+  else if (cmp == GT_EXPR || cmp == GE_EXPR)\n+    {\n+      smaller = TREE_OPERAND (cond, 1);\n+      larger = TREE_OPERAND (cond, 0);\n+    }\n+  else\n+    return false;\n+\n+  /* We need to know which is the true edge and which is the false\n+      edge so that we know if have abs or negative abs.  */\n+  extract_true_false_edges_from_block (cond_bb, &true_edge, &false_edge);\n+\n+  /* Forward the edges over the middle basic block.  */\n+  if (true_edge->dest == middle_bb)\n+    true_edge = EDGE_SUCC (true_edge->dest, 0);\n+  if (false_edge->dest == middle_bb)\n+    false_edge = EDGE_SUCC (false_edge->dest, 0);\n+\n+  if (true_edge == e0)\n+    {\n+      gcc_assert (false_edge == e1);\n+      arg_true = arg0;\n+      arg_false = arg1;\n+    }\n+  else\n+    {\n+      gcc_assert (false_edge == e0);\n+      gcc_assert (true_edge == e1);\n+      arg_true = arg1;\n+      arg_false = arg0;\n+    }\n+\n+  if (empty_block_p (middle_bb))\n+    {\n+      if (operand_equal_for_phi_arg_p (arg_true, smaller)\n+\t  && operand_equal_for_phi_arg_p (arg_false, larger))\n+\t{\n+\t  /* Case\n+\t \n+\t     if (smaller < larger)\n+\t     rslt = smaller;\n+\t     else\n+\t     rslt = larger;  */\n+\t  minmax = MIN_EXPR;\n+\t}\n+      else if (operand_equal_for_phi_arg_p (arg_false, smaller)\n+\t       && operand_equal_for_phi_arg_p (arg_true, larger))\n+\tminmax = MAX_EXPR;\n+      else\n+\treturn false;\n+    }\n+  else\n+    {\n+      /* Recognize the following case, assuming d <= u:\n+\n+\t if (a <= u)\n+\t   b = MAX (a, d);\n+\t x = PHI <b, u>\n+\n+\t This is equivalent to\n+\n+\t b = MAX (a, d);\n+\t x = MIN (b, u);  */\n+\n+      tree assign = last_and_only_stmt (middle_bb);\n+      tree lhs, rhs, op0, op1, bound;\n+\n+      if (!assign\n+\t  || TREE_CODE (assign) != MODIFY_EXPR)\n+\treturn false;\n+\n+      lhs = TREE_OPERAND (assign, 0);\n+      rhs = TREE_OPERAND (assign, 1);\n+      ass_code = TREE_CODE (rhs);\n+      if (ass_code != MAX_EXPR && ass_code != MIN_EXPR)\n+\treturn false;\n+      op0 = TREE_OPERAND (rhs, 0);\n+      op1 = TREE_OPERAND (rhs, 1);\n+\n+      if (true_edge->src == middle_bb)\n+\t{\n+\t  /* We got here if the condition is true, i.e., SMALLER < LARGER.  */\n+\t  if (!operand_equal_for_phi_arg_p (lhs, arg_true))\n+\t    return false;\n+\n+\t  if (operand_equal_for_phi_arg_p (arg_false, larger))\n+\t    {\n+\t      /* Case\n+\n+\t\t if (smaller < larger)\n+\t\t   {\n+\t\t     r' = MAX_EXPR (smaller, bound)\n+\t\t   }\n+\t\t r = PHI <r', larger>  --> to be turned to MIN_EXPR.  */\n+\t      if (ass_code != MAX_EXPR)\n+\t\treturn false;\n+\n+\t      minmax = MIN_EXPR;\n+\t      if (operand_equal_for_phi_arg_p (op0, smaller))\n+\t\tbound = op1;\n+\t      else if (operand_equal_for_phi_arg_p (op1, smaller))\n+\t\tbound = op0;\n+\t      else\n+\t\treturn false;\n+\n+\t      /* We need BOUND <= LARGER.  */\n+\t      if (!integer_nonzerop (fold (build2 (LE_EXPR, boolean_type_node,\n+\t\t\t\t\t\t   bound, larger))))\n+\t\treturn false;\n+\t    }\n+\t  else if (operand_equal_for_phi_arg_p (arg_false, smaller))\n+\t    {\n+\t      /* Case\n+\n+\t\t if (smaller < larger)\n+\t\t   {\n+\t\t     r' = MIN_EXPR (larger, bound)\n+\t\t   }\n+\t\t r = PHI <r', smaller>  --> to be turned to MAX_EXPR.  */\n+\t      if (ass_code != MIN_EXPR)\n+\t\treturn false;\n+\n+\t      minmax = MAX_EXPR;\n+\t      if (operand_equal_for_phi_arg_p (op0, larger))\n+\t\tbound = op1;\n+\t      else if (operand_equal_for_phi_arg_p (op1, larger))\n+\t\tbound = op0;\n+\t      else\n+\t\treturn false;\n+\n+\t      /* We need BOUND >= SMALLER.  */\n+\t      if (!integer_nonzerop (fold (build2 (GE_EXPR, boolean_type_node,\n+\t\t\t\t\t\t   bound, smaller))))\n+\t\treturn false;\n+\t    }\n+\t  else\n+\t    return false;\n+\t}\n+      else\n+\t{\n+\t  /* We got here if the condition is false, i.e., SMALLER > LARGER.  */\n+\t  if (!operand_equal_for_phi_arg_p (lhs, arg_false))\n+\t    return false;\n+\n+\t  if (operand_equal_for_phi_arg_p (arg_true, larger))\n+\t    {\n+\t      /* Case\n+\n+\t\t if (smaller > larger)\n+\t\t   {\n+\t\t     r' = MIN_EXPR (smaller, bound)\n+\t\t   }\n+\t\t r = PHI <r', larger>  --> to be turned to MAX_EXPR.  */\n+\t      if (ass_code != MIN_EXPR)\n+\t\treturn false;\n+\n+\t      minmax = MAX_EXPR;\n+\t      if (operand_equal_for_phi_arg_p (op0, smaller))\n+\t\tbound = op1;\n+\t      else if (operand_equal_for_phi_arg_p (op1, smaller))\n+\t\tbound = op0;\n+\t      else\n+\t\treturn false;\n+\n+\t      /* We need BOUND >= LARGER.  */\n+\t      if (!integer_nonzerop (fold (build2 (GE_EXPR, boolean_type_node,\n+\t\t\t\t\t\t   bound, larger))))\n+\t\treturn false;\n+\t    }\n+\t  else if (operand_equal_for_phi_arg_p (arg_true, smaller))\n+\t    {\n+\t      /* Case\n+\n+\t\t if (smaller > larger)\n+\t\t   {\n+\t\t     r' = MAX_EXPR (larger, bound)\n+\t\t   }\n+\t\t r = PHI <r', smaller>  --> to be turned to MIN_EXPR.  */\n+\t      if (ass_code != MAX_EXPR)\n+\t\treturn false;\n+\n+\t      minmax = MIN_EXPR;\n+\t      if (operand_equal_for_phi_arg_p (op0, larger))\n+\t\tbound = op1;\n+\t      else if (operand_equal_for_phi_arg_p (op1, larger))\n+\t\tbound = op0;\n+\t      else\n+\t\treturn false;\n+\n+\t      /* We need BOUND <= SMALLER.  */\n+\t      if (!integer_nonzerop (fold (build2 (LE_EXPR, boolean_type_node,\n+\t\t\t\t\t\t   bound, smaller))))\n+\t\treturn false;\n+\t    }\n+\t  else\n+\t    return false;\n+\t}\n+\n+      /* Move the statement from the middle block.  */\n+      bsi = bsi_last (cond_bb);\n+      bsi_from = bsi_last (middle_bb);\n+      bsi_move_before (&bsi_from, &bsi);\n+    }\n+\n+  /* Emit the statement to compute min/max.  */\n+  result = duplicate_ssa_name (PHI_RESULT (phi), NULL);\n+  new = build2 (MODIFY_EXPR, type, result,\n+\t\tbuild2 (minmax, type, arg0, arg1));\n+  SSA_NAME_DEF_STMT (result) = new;\n+  bsi = bsi_last (cond_bb);\n+  bsi_insert_before (&bsi, new, BSI_NEW_STMT);\n+\n+  replace_phi_edge_with_variable (cond_bb, phi_bb, e1, phi, result);\n+  return true;\n+}\n+\n /*  The function absolute_replacement does the main work of doing the absolute\n     replacement.  Return true if the replacement is done.  Otherwise return\n     false.\n@@ -497,9 +834,9 @@ abs_replacement (basic_block cond_bb, basic_block middle_bb,\n   tree new, cond;\n   block_stmt_iterator bsi;\n   edge true_edge, false_edge;\n-  tree assign = NULL;\n+  tree assign;\n   edge e;\n-  tree rhs = NULL, lhs = NULL;\n+  tree rhs, lhs;\n   bool negate;\n   enum tree_code cond_code;\n \n@@ -510,57 +847,31 @@ abs_replacement (basic_block cond_bb, basic_block middle_bb,\n \n   /* OTHER_BLOCK must have only one executable statement which must have the\n      form arg0 = -arg1 or arg1 = -arg0.  */\n-  bsi = bsi_start (middle_bb);\n-  while (!bsi_end_p (bsi))\n-    {\n-      tree stmt = bsi_stmt (bsi);\n-\n-      /* Empty statements and labels are uninteresting.  */\n-      if (TREE_CODE (stmt) == LABEL_EXPR\n-          || IS_EMPTY_STMT (stmt))\n-        {\n-          bsi_next (&bsi);\n-          continue;\n-        }\n-\n-      /* If we found the assignment, but it was not the only executable\n-\t statement in OTHER_BLOCK, then we can not optimize.  */\n-      if (assign)\n-\treturn false;\n-\n-      /* If we got here, then we have found the first executable statement\n-\t in OTHER_BLOCK.  If it is anything other than arg = -arg1 or\n-\t arg1 = -arg0, then we can not optimize.  */\n-      if (TREE_CODE (stmt) == MODIFY_EXPR)\n-        {\n-          lhs = TREE_OPERAND (stmt, 0);\n-          rhs = TREE_OPERAND (stmt, 1);\n-\n-          if (TREE_CODE (rhs) == NEGATE_EXPR)\n-            {\n-              rhs = TREE_OPERAND (rhs, 0);\n-\n-              /* The assignment has to be arg0 = -arg1 or arg1 = -arg0.  */\n-              if ((lhs == arg0 && rhs == arg1)\n-\t\t  || (lhs == arg1 && rhs == arg0))\n-\t\t{\n-\t\t  assign = stmt;\n-\t\t  bsi_next (&bsi);\n-\t\t}\n-\t      else\n-\t\treturn false;\n-            }\n-\t  else\n-\t    return false;\n-        }\n-      else\n-\treturn false;\n-    }\n \n+  assign = last_and_only_stmt (middle_bb);\n   /* If we did not find the proper negation assignment, then we can not\n      optimize.  */\n   if (assign == NULL)\n     return false;\n+      \n+  /* If we got here, then we have found the only executable statement\n+     in OTHER_BLOCK.  If it is anything other than arg = -arg1 or\n+     arg1 = -arg0, then we can not optimize.  */\n+  if (TREE_CODE (assign) != MODIFY_EXPR)\n+    return false;\n+\n+  lhs = TREE_OPERAND (assign, 0);\n+  rhs = TREE_OPERAND (assign, 1);\n+\n+  if (TREE_CODE (rhs) != NEGATE_EXPR)\n+    return false;\n+\n+  rhs = TREE_OPERAND (rhs, 0);\n+              \n+  /* The assignment has to be arg0 = -arg1 or arg1 = -arg0.  */\n+  if (!(lhs == arg0 && rhs == arg1)\n+      && !(lhs == arg1 && rhs == arg0))\n+    return false;\n \n   cond = COND_EXPR_COND (last_stmt (cond_bb));\n   result = PHI_RESULT (phi);\n@@ -607,8 +918,8 @@ abs_replacement (basic_block cond_bb, basic_block middle_bb,\n     lhs = result;\n \n   /* Build the modify expression with abs expression.  */\n-  new = build (MODIFY_EXPR, TREE_TYPE (lhs),\n-               lhs, build1 (ABS_EXPR, TREE_TYPE (lhs), rhs));\n+  new = build2 (MODIFY_EXPR, TREE_TYPE (lhs),\n+\t\tlhs, build1 (ABS_EXPR, TREE_TYPE (lhs), rhs));\n \n   bsi = bsi_last (cond_bb);\n   bsi_insert_before (&bsi, new, BSI_NEW_STMT);\n@@ -618,8 +929,8 @@ abs_replacement (basic_block cond_bb, basic_block middle_bb,\n       /* Get the right BSI.  We want to insert after the recently\n \t added ABS_EXPR statement (which we know is the first statement\n \t in the block.  */\n-      new = build (MODIFY_EXPR, TREE_TYPE (result),\n-                   result, build1 (NEGATE_EXPR, TREE_TYPE (lhs), lhs));\n+      new = build2 (MODIFY_EXPR, TREE_TYPE (result),\n+\t\t    result, build1 (NEGATE_EXPR, TREE_TYPE (lhs), lhs));\n \n       bsi_insert_after (&bsi, new, BSI_NEW_STMT);\n     }"}]}