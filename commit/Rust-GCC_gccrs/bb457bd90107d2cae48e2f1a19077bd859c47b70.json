{"sha": "bb457bd90107d2cae48e2f1a19077bd859c47b70", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmI0NTdiZDkwMTA3ZDJjYWU0OGUyZjFhMTkwNzdiZDg1OWM0N2I3MA==", "commit": {"author": {"name": "Jeffrey A Law", "email": "law@cygnus.com", "date": "1999-09-20T14:53:51Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1999-09-20T14:53:51Z"}, "message": "basic-block.h (compute_flow_dominators): Declare.\n\n        * basic-block.h (compute_flow_dominators): Declare.\n\n        * gcse.c (alloc_code_hoist_mem): New function.\n        (free_code_hoist_mem, compute_code_hoist_vbeinout): Likewise.\n        (compute_code_hoist_data, hoist_expr_reaches_here_p): Likewise.\n        (hoist_code, one_code_hoisting_pass): Likewise.\n        (gcse_main): If optimizing for size, then hoist expressions\n        computed in multiple dominated basic blocks.\n\nFrom-SVN: r29523", "tree": {"sha": "077a01b5e5554bcfc46f5636896f0c1d59398553", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/077a01b5e5554bcfc46f5636896f0c1d59398553"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bb457bd90107d2cae48e2f1a19077bd859c47b70", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bb457bd90107d2cae48e2f1a19077bd859c47b70", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bb457bd90107d2cae48e2f1a19077bd859c47b70", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bb457bd90107d2cae48e2f1a19077bd859c47b70/comments", "author": null, "committer": null, "parents": [{"sha": "03d32d1a0882ca2fa5e93a84784ea926f1c27309", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/03d32d1a0882ca2fa5e93a84784ea926f1c27309", "html_url": "https://github.com/Rust-GCC/gccrs/commit/03d32d1a0882ca2fa5e93a84784ea926f1c27309"}], "stats": {"total": 392, "additions": 392, "deletions": 0}, "files": [{"sha": "cfb83bcda0dae5ae1477034f8b23ffb28344676d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb457bd90107d2cae48e2f1a19077bd859c47b70/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb457bd90107d2cae48e2f1a19077bd859c47b70/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bb457bd90107d2cae48e2f1a19077bd859c47b70", "patch": "@@ -24,6 +24,15 @@ Mon Sep 20 14:43:37 1999  Nick Clifton  <nickc@cygnus.com>\n \n Mon Sep 20 05:41:36 1999  Jeffrey A Law  (law@cygnus.com)\n \n+\t* basic-block.h (compute_flow_dominators): Declare.\n+\n+\t* gcse.c (alloc_code_hoist_mem): New function.\n+\t(free_code_hoist_mem, compute_code_hoist_vbeinout): Likewise.\n+\t(compute_code_hoist_data, hoist_expr_reaches_here_p): Likewise.\n+\t(hoist_code, one_code_hoisting_pass): Likewise.\n+\t(gcse_main): If optimizing for size, then hoist expressions\n+\tcomputed in multiple dominated basic blocks.\n+\n \t* gcse.c (invalid_nonnull_info): New function.\n \t(delete_null_pointer_checks): Likewise.\n \t* rtl.h (delete_null_pointer_checks): Declare."}, {"sha": "4eca203e2ec94f2f59d0d8b845c7c430d1209dc6", "filename": "gcc/basic-block.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb457bd90107d2cae48e2f1a19077bd859c47b70/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb457bd90107d2cae48e2f1a19077bd859c47b70/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=bb457bd90107d2cae48e2f1a19077bd859c47b70", "patch": "@@ -281,6 +281,7 @@ extern void compute_preds_succs\t\tPROTO ((int_list_ptr *, int_list_ptr *,\n extern void compute_dominators\t\tPROTO ((sbitmap *, sbitmap *,\n \t\t\t\t\t\tint_list_ptr *,\n \t\t\t\t\t\tint_list_ptr *));\n+extern void compute_flow_dominators\tPROTO ((sbitmap *, sbitmap *));\n extern void compute_immediate_dominators\tPROTO ((int *, sbitmap *));\n \n /* In lcm.c */"}, {"sha": "def34898cd7ac3c0d493920bc7b92f31fc79f4f4", "filename": "gcc/gcse.c", "status": "modified", "additions": 382, "deletions": 0, "changes": 382, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb457bd90107d2cae48e2f1a19077bd859c47b70/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb457bd90107d2cae48e2f1a19077bd859c47b70/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=bb457bd90107d2cae48e2f1a19077bd859c47b70", "patch": "@@ -600,6 +600,14 @@ static int one_pre_gcse_pass\t  PROTO ((int));\n \n static void add_label_notes\t      PROTO ((rtx, rtx));\n \n+static void alloc_code_hoist_mem\tPROTO ((int, int));\n+static void free_code_hoist_mem\t\tPROTO ((void));\n+static void compute_code_hoist_vbeinout\tPROTO ((void));\n+static void compute_code_hoist_data\tPROTO ((void));\n+static int hoist_expr_reaches_here_p\tPROTO ((int, int, int, char *));\n+static void hoist_code\t\t\tPROTO ((void));\n+static int one_code_hoisting_pass\tPROTO ((void));\n+\n static void alloc_rd_mem\t      PROTO ((int, int));\n static void free_rd_mem\t       PROTO ((void));\n static void handle_rd_kill_set\tPROTO ((rtx, int, int));\n@@ -730,8 +738,28 @@ gcse_main (f, file)\n       if (max_pass_bytes < bytes_used)\n \tmax_pass_bytes = bytes_used;\n \n+      /* Free up memory, then reallocate for code hoisting.  We can\n+\t not re-use the existing allocated memory because the tables\n+\t will not have info for the insns or registers created by\n+\t partial redundancy elimination.  */\n       free_gcse_mem ();\n \n+      /* It does not make sense to run code hoisting unless we optimizing\n+\t for code size -- it rarely makes programs faster, and can make\n+\t them bigger if we did partial redundancy elimination (when optimizing\n+\t for space, we use a classic gcse algorithm instead of partial\n+\t redundancy algorithms).  */\n+      if (optimize_size)\n+        {\n+\t  max_gcse_regno = max_reg_num ();\n+\t  alloc_gcse_mem (f);\n+\t  changed |= one_code_hoisting_pass ();\n+\t  free_gcse_mem ();\n+\n+\t  if (max_pass_bytes < bytes_used)\n+\t    max_pass_bytes = bytes_used;\n+        }\n+\n       if (file)\n \t{\n \t  fprintf (file, \"\\n\");\n@@ -5044,3 +5072,357 @@ delete_null_pointer_checks (f)\n   free (nonnull_avin);\n   free (nonnull_avout);\n }\n+\n+/* Code Hoisting variables and subroutines.  */\n+\n+/* Very busy expressions.  */\n+static sbitmap *hoist_vbein;\n+static sbitmap *hoist_vbeout;\n+\n+/* Hoistable expressions.  */\n+static sbitmap *hoist_exprs;\n+\n+/* Dominator bitmaps.  */\n+static sbitmap *dominators;\n+static sbitmap *post_dominators;\n+\n+/* ??? We could compute post dominators and run this algorithm in\n+   reverse to to perform tail merging, doing so would probably be\n+   more effective than the tail merging code in jump.c.\n+\n+   It's unclear if tail merging could be run in parallel with\n+   code hoisting.  It would be nice.  */\n+\n+/* Allocate vars used for code hoisting analysis.  */\n+\n+static void\n+alloc_code_hoist_mem (n_blocks, n_exprs)\n+     int n_blocks, n_exprs;\n+{\n+  antloc = sbitmap_vector_alloc (n_blocks, n_exprs);\n+  transp = sbitmap_vector_alloc (n_blocks, n_exprs);\n+  comp = sbitmap_vector_alloc (n_blocks, n_exprs);\n+\n+  hoist_vbein = sbitmap_vector_alloc (n_blocks, n_exprs);\n+  hoist_vbeout = sbitmap_vector_alloc (n_blocks, n_exprs);\n+  hoist_exprs = sbitmap_vector_alloc (n_blocks, n_exprs);\n+  transpout = sbitmap_vector_alloc (n_blocks, n_exprs);\n+\n+  dominators = sbitmap_vector_alloc (n_blocks, n_blocks);\n+  post_dominators = sbitmap_vector_alloc (n_blocks, n_blocks);\n+}\n+\n+/* Free vars used for code hoisting analysis.  */\n+\n+static void\n+free_code_hoist_mem ()\n+{\n+  free (antloc);\n+  free (transp);\n+  free (comp);\n+\n+  free (hoist_vbein);\n+  free (hoist_vbeout);\n+  free (hoist_exprs);\n+  free (transpout);\n+\n+  free (dominators);\n+  free (post_dominators);\n+}\n+\n+/* Compute the very busy expressions at entry/exit from each block.\n+\n+   An expression is very busy if all paths from a given point\n+   compute the expression.  */\n+\n+static void\n+compute_code_hoist_vbeinout ()\n+{\n+  int bb, changed, passes;\n+\n+  sbitmap_vector_zero (hoist_vbeout, n_basic_blocks);\n+  sbitmap_vector_zero (hoist_vbein, n_basic_blocks);\n+\n+  passes = 0;\n+  changed = 1;\n+  while (changed)\n+    {\n+      changed = 0;\n+      /* We scan the blocks in the reverse order to speed up\n+\t the convergence.  */\n+      for (bb = n_basic_blocks - 1; bb >= 0; bb--)\n+\t{\n+\t  changed |= sbitmap_a_or_b_and_c (hoist_vbein[bb], antloc[bb],\n+\t\t\t\t\t   hoist_vbeout[bb], transp[bb]);\n+\t  if (bb != n_basic_blocks - 1)\n+\t    sbitmap_intersect_of_successors (hoist_vbeout[bb], hoist_vbein,\n+\t\t\t\t\t     bb, s_succs);\n+\t}\n+      passes++;\n+    }\n+\n+  if (gcse_file)\n+    fprintf (gcse_file, \"hoisting vbeinout computation: %d passes\\n\", passes);\n+}\n+\n+/* Top level routine to do the dataflow analysis needed by code hoisting.  */\n+\n+static void\n+compute_code_hoist_data ()\n+{\n+  compute_local_properties (transp, comp, antloc, 0);\n+  compute_transpout ();\n+  compute_code_hoist_vbeinout ();\n+  compute_flow_dominators (dominators, post_dominators);\n+  if (gcse_file)\n+    fprintf (gcse_file, \"\\n\");\n+}\n+\n+/* Determine if the expression identified by EXPR_INDEX would\n+   reach BB unimpared if it was placed at the end of EXPR_BB.\n+\n+   It's unclear exactly what Muchnick meant by \"unimpared\".  It seems\n+   to me that the expression must either be computed or transparent in\n+   *every* block in the path(s) from EXPR_BB to BB.  Any other definition\n+   would allow the expression to be hoisted out of loops, even if\n+   the expression wasn't a loop invariant.\n+\n+   Contrast this to reachability for PRE where an expression is\n+   considered reachable if *any* path reaches instead of *all*\n+   paths.  */\n+\n+static int\n+hoist_expr_reaches_here_p (expr_bb, expr_index, bb, visited)\n+     int expr_bb;\n+     int expr_index;\n+     int bb;\n+     char *visited;\n+{\n+  edge pred;\n+\n+  if (visited == NULL)\n+    {\n+      visited = (char *) alloca (n_basic_blocks);\n+      bzero (visited, n_basic_blocks);\n+    }\n+\n+  visited[expr_bb] = 1;\n+  for (pred = BASIC_BLOCK (bb)->pred; pred != NULL; pred = pred->pred_next)\n+    {\n+      int pred_bb = pred->src->index;\n+\n+      if (pred->src == ENTRY_BLOCK_PTR)\n+\tbreak;\n+      else if (visited[pred_bb])\n+\tcontinue;\n+      /* Does this predecessor generate this expression?  */\n+      else if (TEST_BIT (comp[pred_bb], expr_index))\n+\tbreak;\n+      else if (! TEST_BIT (transp[pred_bb], expr_index))\n+\tbreak;\n+      /* Not killed.  */\n+      else\n+\t{\n+\t  visited[pred_bb] = 1;\n+\t  if (! hoist_expr_reaches_here_p (expr_bb, expr_index,\n+\t\t\t\t\t   pred_bb, visited))\n+\t    break;\n+\t}\n+    }\n+\n+  return (pred == NULL);\n+}\n+\f\n+/* Actually perform code hoisting.  */\n+static void\n+hoist_code ()\n+{\n+  int bb, dominated, i;\n+  struct expr **index_map;\n+\n+  sbitmap_vector_zero (hoist_exprs, n_basic_blocks);\n+\n+  /* Compute a mapping from expression number (`bitmap_index') to\n+     hash table entry.  */\n+\n+  index_map = (struct expr **) alloca (n_exprs * sizeof (struct expr *));\n+  bzero ((char *) index_map, n_exprs * sizeof (struct expr *));\n+  for (i = 0; i < expr_hash_table_size; i++)\n+    {\n+      struct expr *expr;\n+\n+      for (expr = expr_hash_table[i]; expr != NULL; expr = expr->next_same_hash)\n+\tindex_map[expr->bitmap_index] = expr;\n+    }\n+\n+  /* Walk over each basic block looking for potentially hoistable\n+     expressions, nothing gets hoisted from the entry block.  */\n+  for (bb = 0; bb < n_basic_blocks; bb++)\n+    {\n+      int found = 0;\n+      int insn_inserted_p;\n+\n+      /* Examine each expression that is very busy at the exit of this\n+\t block.  These are the potentially hoistable expressions.  */\n+      for (i = 0; i < hoist_vbeout[bb]->n_bits; i++)\n+\t{\n+\t  int hoistable = 0;\n+\t  if (TEST_BIT (hoist_vbeout[bb], i)\n+\t      && TEST_BIT (transpout[bb], i))\n+\t    {\n+\t      /* We've found a potentially hoistable expression, now\n+\t\t we look at every block BB dominates to see if it\n+\t\t computes the expression.  */\n+\t      for (dominated = 0; dominated < n_basic_blocks; dominated++)\n+\t\t{\n+\t\t  /* Ignore self dominance.  */\n+\t\t  if (bb == dominated\n+\t\t      || ! TEST_BIT (dominators[dominated], bb))\n+\t\t    continue;\n+\n+\t\t  /* We've found a dominated block, now see if it computes\n+\t\t     the busy expression and whether or not moving that\n+\t\t     expression to the \"beginning\" of that block is safe.  */\n+\t\t  if (!TEST_BIT (antloc[dominated], i))\n+\t\t    continue;\n+\n+\t\t  /* Note if the expression would reach the dominated block\n+\t\t     unimpared if it was placed at the end of BB. \n+\n+\t\t     Keep track of how many times this expression is hoistable\n+\t\t     from a dominated block into BB.  */\n+\t\t  if (hoist_expr_reaches_here_p (bb, i, dominated, NULL))\n+\t\t    hoistable++;\n+\t\t}\n+\n+\t      /* If we found more than one hoistable occurence of this\n+\t\t expression, then note it in the bitmap of expressions to\n+\t\t hoist.  It makes no sense to hoist things which are computed\n+\t\t in only one BB, and doing so tends to pessimize register\n+\t\t allocation.  One could increase this value to try harder\n+\t\t to avoid any possible code expansion due to register\n+\t\t allocation issues; however experiments have shown that\n+\t\t the vast majority of hoistable expressions are only movable\n+\t\t from two successors, so raising this threshhold is likely\n+\t\t to nullify any benefit we get from code hoisting.  */\n+\t      if (hoistable > 1)\n+\t\t{\n+\t\t  SET_BIT (hoist_exprs[bb], i);\n+\t\t  found = 1;\n+\t\t}\n+\t    }\n+\t}\n+\t\t\n+      /* If we found nothing to hoist, then quit now.  */\n+      if (! found)\n+\tcontinue;\n+\n+      /* Loop over all the hoistable expressions.  */\n+      for (i = 0; i < hoist_exprs[bb]->n_bits; i++)\n+\t{\n+\t  /* We want to insert the expression into BB only once, so\n+\t     note when we've inserted it.  */\n+\t  insn_inserted_p = 0;\n+\n+\t  /* These tests should be the same as the tests above.  */\n+\t  if (TEST_BIT (hoist_vbeout[bb], i))\n+\t    {\n+\t      /* We've found a potentially hoistable expression, now\n+\t\t we look at every block BB dominates to see if it\n+\t\t computes the expression.  */\n+\t      for (dominated = 0; dominated < n_basic_blocks; dominated++)\n+\t\t{\n+\t\t  /* Ignore self dominance.  */\n+\t\t  if (bb == dominated\n+\t\t      || ! TEST_BIT (dominators[dominated], bb))\n+\t\t    continue;\n+\n+\t\t  /* We've found a dominated block, now see if it computes\n+\t\t     the busy expression and whether or not moving that\n+\t\t     expression to the \"beginning\" of that block is safe.  */\n+\t\t  if (!TEST_BIT (antloc[dominated], i))\n+\t\t    continue;\n+\n+\t\t  /* The expression is computed in the dominated block and\n+\t\t     it would be safe to compute it at the start of the\n+\t\t     dominated block.  Now we have to determine if the\n+\t\t     expresion would reach the dominated block if it was\n+\t\t     placed at the end of BB.  */\n+\t\t  if (hoist_expr_reaches_here_p (bb, i, dominated, NULL))\n+\t\t    {\n+\t\t      struct expr *expr = index_map[i];\n+\t\t      struct occr *occr = expr->antic_occr;\n+\t\t      rtx insn;\n+\t\t      rtx set;\n+\n+\t\t  \n+\t\t      /* Find the right occurence of this expression.  */\n+\t\t      while (BLOCK_NUM (occr->insn) != dominated && occr)\n+\t\t\toccr = occr->next;\n+\n+\t\t      /* Should never happen.  */\n+\t\t      if (!occr)\n+\t\t\tabort ();\n+\n+\t\t      insn = occr->insn;\n+\t\t \n+\t\t      set = single_set (insn);\n+\t\t      if (! set)\n+\t\t\tabort ();\n+\n+\t\t      /* Create a pseudo-reg to store the result of reaching\n+\t\t\t expressions into.  Get the mode for the new pseudo\n+\t\t\t from the mode of the original destination pseudo.  */\n+\t\t      if (expr->reaching_reg == NULL)\n+\t\t\texpr->reaching_reg\n+\t\t\t  = gen_reg_rtx (GET_MODE (SET_DEST (set)));\n+\n+\t\t      /* In theory this should never fail since we're creating\n+\t\t\t a reg->reg copy.\n+\n+\t\t\t However, on the x86 some of the movXX patterns actually\n+\t\t\t contain clobbers of scratch regs.  This may cause the\n+\t\t\t insn created by validate_change to not match any\n+\t\t\t pattern and thus cause validate_change to fail.   */\n+\t\t      if (validate_change (insn, &SET_SRC (set),\n+\t\t\t\t\t   expr->reaching_reg, 0))\n+\t\t\t{\n+\t\t\t  occr->deleted_p = 1;\n+\t\t\t  if (!insn_inserted_p)\n+\t\t\t    {\n+\t\t\t      insert_insn_end_bb (index_map[i], bb, 0);\n+\t\t\t      insn_inserted_p = 1;\n+\t\t\t    }\n+\t\t\t}\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+    }\n+}\n+\n+/* Top level routine to perform one code hoisting (aka unification) pass\n+\n+   Return non-zero if a change was made.  */\n+\n+static int\n+one_code_hoisting_pass ()\n+{\n+  int changed = 0;\n+\n+  alloc_expr_hash_table (max_cuid);\n+  compute_expr_hash_table ();\n+  if (gcse_file)\n+    dump_hash_table (gcse_file, \"Code Hosting Expressions\", expr_hash_table,\n+\t\t     expr_hash_table_size, n_exprs);\n+  if (n_exprs > 0)\n+    {\n+      alloc_code_hoist_mem (n_basic_blocks, n_exprs);\n+      compute_code_hoist_data ();\n+      hoist_code ();\n+      free_code_hoist_mem ();\n+    }\n+  free_expr_hash_table ();\n+\n+  return changed;\n+}"}]}