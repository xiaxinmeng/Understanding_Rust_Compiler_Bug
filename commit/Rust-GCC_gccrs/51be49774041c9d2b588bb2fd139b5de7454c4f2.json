{"sha": "51be49774041c9d2b588bb2fd139b5de7454c4f2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTFiZTQ5Nzc0MDQxYzlkMmI1ODhiYjJmZDEzOWI1ZGU3NDU0YzRmMg==", "commit": {"author": {"name": "Bin Cheng", "email": "bin.cheng@arm.com", "date": "2014-12-03T05:25:40Z"}, "committer": {"name": "Bin Cheng", "email": "amker@gcc.gnu.org", "date": "2014-12-03T05:25:40Z"}, "message": "target.def (fusion_priority): Wrap code with @smallexample.\n\n\n\t* target.def (fusion_priority): Wrap code with @smallexample.\n\t* doc/tm.texi: Regenerated.\n\nFrom-SVN: r218301", "tree": {"sha": "3c382659e0834db1d511d369dd51eb84d07e6f83", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3c382659e0834db1d511d369dd51eb84d07e6f83"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/51be49774041c9d2b588bb2fd139b5de7454c4f2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/51be49774041c9d2b588bb2fd139b5de7454c4f2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/51be49774041c9d2b588bb2fd139b5de7454c4f2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/51be49774041c9d2b588bb2fd139b5de7454c4f2/comments", "author": null, "committer": null, "parents": [{"sha": "28fe2ab37c2990882795560f8bc345518f9aeb98", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/28fe2ab37c2990882795560f8bc345518f9aeb98", "html_url": "https://github.com/Rust-GCC/gccrs/commit/28fe2ab37c2990882795560f8bc345518f9aeb98"}], "stats": {"total": 49, "additions": 33, "deletions": 16}, "files": [{"sha": "cfc6628797931331b119c33ad3fa48b065785b24", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51be49774041c9d2b588bb2fd139b5de7454c4f2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51be49774041c9d2b588bb2fd139b5de7454c4f2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=51be49774041c9d2b588bb2fd139b5de7454c4f2", "patch": "@@ -1,3 +1,8 @@\n+2014-12-03  Bin Cheng  <bin.cheng@arm.com>\n+\n+\t* target.def (fusion_priority): Wrap code with @smallexample.\n+\t* doc/tm.texi: Regenerated.\n+\n 2014-12-03  Manuel L\u00f3pez-Ib\u00e1\u00f1ez  <manu@gcc.gnu.org>\n \n \t* diagnostic.c (diagnostic_show_locus): Honor override_column when"}, {"sha": "b9a7251d6a1033347a2cebdc0d456a2f47ab341b", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51be49774041c9d2b588bb2fd139b5de7454c4f2/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51be49774041c9d2b588bb2fd139b5de7454c4f2/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=51be49774041c9d2b588bb2fd139b5de7454c4f2", "patch": "@@ -6797,6 +6797,7 @@ instructions.\n \n Given below example:\n \n+@smallexample\n     ldr r10, [r1, 4]\n     add r4, r4, r10\n     ldr r15, [r2, 8]\n@@ -6805,26 +6806,30 @@ Given below example:\n     add r4, r4, r11\n     ldr r16, [r2, 12]\n     sub r5, r5, r16\n+@end smallexample\n \n On targets like ARM/AArch64, the two pairs of consecutive loads should be\n merged.  Since peephole2 pass can't help in this case unless consecutive\n loads are actually next to each other in instruction flow.  That's where\n this scheduling fusion pass works.  This hook calculates priority for each\n instruction based on its fustion type, like:\n \n-    ldr r10, [r1, 4]  ; fusion_pri=99,  pri=96   \n-    add r4, r4, r10   ; fusion_pri=100, pri=100  \n-    ldr r15, [r2, 8]  ; fusion_pri=98,  pri=92   \n-    sub r5, r5, r15   ; fusion_pri=100, pri=100  \n-    ldr r11, [r1, 0]  ; fusion_pri=99,  pri=100  \n-    add r4, r4, r11   ; fusion_pri=100, pri=100  \n-    ldr r16, [r2, 12] ; fusion_pri=98,  pri=88   \n-    sub r5, r5, r16   ; fusion_pri=100, pri=100  \n+@smallexample\n+    ldr r10, [r1, 4]  ; fusion_pri=99,  pri=96\n+    add r4, r4, r10   ; fusion_pri=100, pri=100\n+    ldr r15, [r2, 8]  ; fusion_pri=98,  pri=92\n+    sub r5, r5, r15   ; fusion_pri=100, pri=100\n+    ldr r11, [r1, 0]  ; fusion_pri=99,  pri=100\n+    add r4, r4, r11   ; fusion_pri=100, pri=100\n+    ldr r16, [r2, 12] ; fusion_pri=98,  pri=88\n+    sub r5, r5, r16   ; fusion_pri=100, pri=100\n+@end smallexample\n \n Scheduling fusion pass then sorts all ready to issue instructions according\n to the priorities.  As a result, instructions of same fusion type will be\n pushed together in instruction flow, like:\n \n+@smallexample\n     ldr r11, [r1, 0]\n     ldr r10, [r1, 4]\n     ldr r15, [r2, 8]\n@@ -6833,6 +6838,7 @@ pushed together in instruction flow, like:\n     sub r5, r5, r15\n     add r4, r4, r11\n     sub r5, r5, r16\n+@end smallexample\n \n Now peephole2 pass can simply merge the two pairs of loads.\n "}, {"sha": "647ebbe7bb6093c4cf568d80bcc3acb21332ded5", "filename": "gcc/target.def", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51be49774041c9d2b588bb2fd139b5de7454c4f2/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51be49774041c9d2b588bb2fd139b5de7454c4f2/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=51be49774041c9d2b588bb2fd139b5de7454c4f2", "patch": "@@ -1555,6 +1555,7 @@ instructions.\\n\\\n \\n\\\n Given below example:\\n\\\n \\n\\\n+@smallexample\\n\\\n     ldr r10, [r1, 4]\\n\\\n     add r4, r4, r10\\n\\\n     ldr r15, [r2, 8]\\n\\\n@@ -1563,26 +1564,30 @@ Given below example:\\n\\\n     add r4, r4, r11\\n\\\n     ldr r16, [r2, 12]\\n\\\n     sub r5, r5, r16\\n\\\n+@end smallexample\\n\\\n \\n\\\n On targets like ARM/AArch64, the two pairs of consecutive loads should be\\n\\\n merged.  Since peephole2 pass can't help in this case unless consecutive\\n\\\n loads are actually next to each other in instruction flow.  That's where\\n\\\n this scheduling fusion pass works.  This hook calculates priority for each\\n\\\n instruction based on its fustion type, like:\\n\\\n \\n\\\n-    ldr r10, [r1, 4]  ; fusion_pri=99,  pri=96   \\n\\\n-    add r4, r4, r10   ; fusion_pri=100, pri=100  \\n\\\n-    ldr r15, [r2, 8]  ; fusion_pri=98,  pri=92   \\n\\\n-    sub r5, r5, r15   ; fusion_pri=100, pri=100  \\n\\\n-    ldr r11, [r1, 0]  ; fusion_pri=99,  pri=100  \\n\\\n-    add r4, r4, r11   ; fusion_pri=100, pri=100  \\n\\\n-    ldr r16, [r2, 12] ; fusion_pri=98,  pri=88   \\n\\\n-    sub r5, r5, r16   ; fusion_pri=100, pri=100  \\n\\\n+@smallexample\\n\\\n+    ldr r10, [r1, 4]  ; fusion_pri=99,  pri=96\\n\\\n+    add r4, r4, r10   ; fusion_pri=100, pri=100\\n\\\n+    ldr r15, [r2, 8]  ; fusion_pri=98,  pri=92\\n\\\n+    sub r5, r5, r15   ; fusion_pri=100, pri=100\\n\\\n+    ldr r11, [r1, 0]  ; fusion_pri=99,  pri=100\\n\\\n+    add r4, r4, r11   ; fusion_pri=100, pri=100\\n\\\n+    ldr r16, [r2, 12] ; fusion_pri=98,  pri=88\\n\\\n+    sub r5, r5, r16   ; fusion_pri=100, pri=100\\n\\\n+@end smallexample\\n\\\n \\n\\\n Scheduling fusion pass then sorts all ready to issue instructions according\\n\\\n to the priorities.  As a result, instructions of same fusion type will be\\n\\\n pushed together in instruction flow, like:\\n\\\n \\n\\\n+@smallexample\\n\\\n     ldr r11, [r1, 0]\\n\\\n     ldr r10, [r1, 4]\\n\\\n     ldr r15, [r2, 8]\\n\\\n@@ -1591,6 +1596,7 @@ pushed together in instruction flow, like:\\n\\\n     sub r5, r5, r15\\n\\\n     add r4, r4, r11\\n\\\n     sub r5, r5, r16\\n\\\n+@end smallexample\\n\\\n \\n\\\n Now peephole2 pass can simply merge the two pairs of loads.\\n\\\n \\n\\"}]}