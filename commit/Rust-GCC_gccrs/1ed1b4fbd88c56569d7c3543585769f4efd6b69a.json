{"sha": "1ed1b4fbd88c56569d7c3543585769f4efd6b69a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWVkMWI0ZmJkODhjNTY1NjlkN2MzNTQzNTg1NzY5ZjRlZmQ2YjY5YQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@vlsi1.ultra.nyu.edu", "date": "2001-12-14T01:37:46Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2001-12-14T01:37:46Z"}, "message": "expr.c (copy_blkmode_from_reg): Add missing braces to eliminate warning and reformat comments.\n\n\t* expr.c (copy_blkmode_from_reg): Add missing braces to eliminate\n\twarning and reformat comments.\n\t(expand_assignment): Don't pass EXPAND_WRITE if LHS is component.\n\t(highest_pow2_factor, case INTEGER_CST): Return BIGGEST_ALIGNMENT\n\tif overflow.\n\nFrom-SVN: r47983", "tree": {"sha": "d7d30fc341bb1e436b8c390ca7b819b8ece70e80", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d7d30fc341bb1e436b8c390ca7b819b8ece70e80"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1ed1b4fbd88c56569d7c3543585769f4efd6b69a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ed1b4fbd88c56569d7c3543585769f4efd6b69a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1ed1b4fbd88c56569d7c3543585769f4efd6b69a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ed1b4fbd88c56569d7c3543585769f4efd6b69a/comments", "author": null, "committer": null, "parents": [{"sha": "10baca6bed5250bd1e6d0848a294b547de508a41", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10baca6bed5250bd1e6d0848a294b547de508a41", "html_url": "https://github.com/Rust-GCC/gccrs/commit/10baca6bed5250bd1e6d0848a294b547de508a41"}], "stats": {"total": 41, "additions": 27, "deletions": 14}, "files": [{"sha": "74563e64da821d1a6308db2cad590110785078db", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ed1b4fbd88c56569d7c3543585769f4efd6b69a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ed1b4fbd88c56569d7c3543585769f4efd6b69a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1ed1b4fbd88c56569d7c3543585769f4efd6b69a", "patch": "@@ -1,3 +1,11 @@\n+Thu Dec 13 20:30:08 2001  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* expr.c (copy_blkmode_from_reg): Add missing braces to eliminate\n+\twarning and reformat comments.\n+\t(expand_assignment): Don't pass EXPAND_WRITE if LHS is component.\n+\t(highest_pow2_factor, case INTEGER_CST): Return BIGGEST_ALIGNMENT\n+\tif overflow.\n+\n 2001-12-12  Aldy Hernandez  <aldyh@redhat.com>\n \n         * config/rs6000/rs6000.c (rs6000_override_options): Add"}, {"sha": "5884217e90ec1da9ebb9fda105b962d0a5bcda6c", "filename": "gcc/expr.c", "status": "modified", "additions": 19, "deletions": 14, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ed1b4fbd88c56569d7c3543585769f4efd6b69a/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ed1b4fbd88c56569d7c3543585769f4efd6b69a/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=1ed1b4fbd88c56569d7c3543585769f4efd6b69a", "patch": "@@ -2163,19 +2163,20 @@ copy_blkmode_from_reg (tgtblk, srcreg, type)\n       preserve_temp_slots (tgtblk);\n     }\n \n-  /* This code assumes srcreg is at least a full word.  If it isn't,\n-     copy it into a new pseudo which is a full word.  */\n+  /* This code assumes srcreg is at least a full word.  If it isn't, copy it\n+     into a new pseudo which is a full word.\n \n-  /* If FUNCTION_ARG_REG_LITTLE_ENDIAN is set and convert_to_mode does\n-     a copy, the wrong part of the register gets copied so we fake\n-     a type conversion in place.  */\n-     \n+     If FUNCTION_ARG_REG_LITTLE_ENDIAN is set and convert_to_mode does a copy,\n+     the wrong part of the register gets copied so we fake a type conversion\n+     in place.  */\n   if (GET_MODE (srcreg) != BLKmode\n       && GET_MODE_SIZE (GET_MODE (srcreg)) < UNITS_PER_WORD)\n-    if (FUNCTION_ARG_REG_LITTLE_ENDIAN)\n-       srcreg = simplify_gen_subreg (word_mode, srcreg, GET_MODE (srcreg), 0);\n-    else\n-       srcreg = convert_to_mode (word_mode, srcreg, TREE_UNSIGNED (type));\n+    {\n+      if (FUNCTION_ARG_REG_LITTLE_ENDIAN)\n+\tsrcreg = simplify_gen_subreg (word_mode, srcreg, GET_MODE (srcreg), 0);\n+      else\n+\tsrcreg = convert_to_mode (word_mode, srcreg, TREE_UNSIGNED (type));\n+    }\n \n   /* Structures whose size is not a multiple of a word are aligned\n      to the least significant byte (to the right).  On a BYTES_BIG_ENDIAN\n@@ -3645,8 +3646,8 @@ expand_assignment (to, from, want_value, suggest_reg)\n       if (mode1 == VOIDmode && want_value)\n \ttem = stabilize_reference (tem);\n \n-      orig_to_rtx = to_rtx = expand_expr (tem, NULL_RTX, VOIDmode,\n-\t\t\t\t\t  EXPAND_WRITE);\n+      orig_to_rtx = to_rtx = expand_expr (tem, NULL_RTX, VOIDmode, 0);\n+\n       if (offset != 0)\n \t{\n \t  rtx offset_rtx = expand_expr (offset, NULL_RTX, VOIDmode, 0);\n@@ -5794,8 +5795,12 @@ highest_pow2_factor (exp)\n       /* If the integer is expressable in a HOST_WIDE_INT, we can find the\n \t lowest bit that's a one.  If the result is zero, pessimize by\n \t returning 1.  This is overly-conservative, but such things should not\n-\t happen in the offset expressions that we are called with.  */\n-      if (host_integerp (exp, 0))\n+\t happen in the offset expressions that we are called with.  If\n+\t the constant overlows, we some erroneous program, so return\n+\t BIGGEST_ALIGNMENT to avoid any later ICE.  */\n+      if (TREE_CONSTANT_OVERFLOW (exp))\n+\treturn BIGGEST_ALIGNMENT;\n+      else if (host_integerp (exp, 0))\n \t{\n \t  c0 = tree_low_cst (exp, 0);\n \t  c0 = c0 < 0 ? - c0 : c0;"}]}