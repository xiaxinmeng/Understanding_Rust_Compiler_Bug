{"sha": "f5ff3a8ed4ca91737c16757ce4938cf2e0187fc0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjVmZjNhOGVkNGNhOTE3MzdjMTY3NTdjZTQ5MzhjZjJlMDE4N2ZjMA==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2021-08-28T18:57:08Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2021-08-28T18:57:08Z"}, "message": "Improve handling of table overflows in modref_ref_node\n\ngcc/ChangeLog:\n\n\t* ipa-modref-tree.h (modref_access_node::merge): Break out\n\tlogic combining offsets and logic merging ranges to ...\n\t(modref_access_node::combined_offsets): ... here\n\t(modref_access_node::update2): ... here\n\t(modref_access_node::closer_pair_p): New member function.\n\t(modref_access_node::forced_merge): New member function.\n\t(modre_ref_node::insert): Do merging when table is full.\n\ngcc/testsuite/ChangeLog:\n\n\t* gcc.dg/tree-ssa/modref-9.c: New test.", "tree": {"sha": "fe5a089cb19dec99f73e531ad96f2fb58b56b61c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fe5a089cb19dec99f73e531ad96f2fb58b56b61c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f5ff3a8ed4ca91737c16757ce4938cf2e0187fc0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f5ff3a8ed4ca91737c16757ce4938cf2e0187fc0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f5ff3a8ed4ca91737c16757ce4938cf2e0187fc0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f5ff3a8ed4ca91737c16757ce4938cf2e0187fc0/comments", "author": null, "committer": null, "parents": [{"sha": "f9809ef57005409ee658294d6e8dad9ee8897e88", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f9809ef57005409ee658294d6e8dad9ee8897e88", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f9809ef57005409ee658294d6e8dad9ee8897e88"}], "stats": {"total": 313, "additions": 264, "deletions": 49}, "files": [{"sha": "6a9ed5ce54b8b01cd0c7732e0a458cf06393935b", "filename": "gcc/ipa-modref-tree.h", "status": "modified", "additions": 249, "deletions": 49, "changes": 298, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5ff3a8ed4ca91737c16757ce4938cf2e0187fc0/gcc%2Fipa-modref-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5ff3a8ed4ca91737c16757ce4938cf2e0187fc0/gcc%2Fipa-modref-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-modref-tree.h?ref=f5ff3a8ed4ca91737c16757ce4938cf2e0187fc0", "patch": "@@ -196,8 +196,9 @@ struct GTY(()) modref_access_node\n      was prolonged and punt when there are too many.  */\n   bool merge (const modref_access_node &a, bool record_adjustments)\n     {\n-      poly_int64 aoffset_adj = 0, offset_adj = 0;\n-      poly_int64 new_parm_offset = parm_offset;\n+      poly_int64 offset1 = 0;\n+      poly_int64 aoffset1 = 0;\n+      poly_int64 new_parm_offset = 0;\n \n       /* We assume that containment was tested earlier.  */\n       gcc_checking_assert (!contains (a) && !a.contains (*this));\n@@ -209,29 +210,13 @@ struct GTY(()) modref_access_node\n \t    {\n \t      if (!a.parm_offset_known)\n \t\treturn false;\n-\t      if (known_le (a.parm_offset, parm_offset))\n-\t\t{\n-\t\t  offset_adj = (parm_offset - a.parm_offset)\n-\t\t\t\t<< LOG2_BITS_PER_UNIT;\n-\t\t  aoffset_adj = 0;\n-\t\t  new_parm_offset = a.parm_offset;\n-\t\t}\n-\t      else if (known_le (parm_offset, a.parm_offset))\n-\t\t{\n-\t\t  aoffset_adj = (a.parm_offset - parm_offset)\n-\t\t\t\t << LOG2_BITS_PER_UNIT;\n-\t\t  offset_adj = 0;\n-\t\t}\n-\t      else\n+\t      if (!combined_offsets (a, &new_parm_offset, &offset1, &aoffset1))\n \t\treturn false;\n \t    }\n \t}\n       /* See if we can merge ranges.  */\n       if (range_info_useful_p ())\n \t{\n-\t  poly_int64 offset1 = offset + offset_adj;\n-\t  poly_int64 aoffset1 = a.offset + aoffset_adj;\n-\n \t  /* In this case we have containment that should be\n \t     handled earlier.  */\n \t  gcc_checking_assert (a.range_info_useful_p ());\n@@ -255,46 +240,211 @@ struct GTY(()) modref_access_node\n \t    return false;\n \t  if (known_le (offset1, aoffset1))\n \t    {\n-\t      if (!known_size_p (max_size))\n+\t      if (!known_size_p (max_size)\n+\t\t  || known_ge (offset1 + max_size, aoffset1))\n \t\t{\n-\t\t  update (new_parm_offset, offset1, size, max_size,\n-\t\t\t  record_adjustments);\n-\t\t  return true;\n-\t\t}\n-\t      else if (known_ge (offset1 + max_size, aoffset1))\n-\t\t{\n-\t\t  poly_int64 new_max_size = max_size;\n-\t\t  if (known_le (max_size, a.max_size + aoffset1 - offset1))\n-\t\t    new_max_size = a.max_size + aoffset1 - offset1;\n-\t\t  update (new_parm_offset, offset1, size, new_max_size,\n-\t\t\t  record_adjustments);\n+\t\t  update2 (new_parm_offset, offset1, size, max_size,\n+\t\t\t   aoffset1, a.size, a.max_size,\n+\t\t\t   record_adjustments);\n \t\t  return true;\n \t\t}\n \t    }\n \t  else if (known_le (aoffset1, offset1))\n \t    {\n-\t      if (!known_size_p (a.max_size))\n-\t\t{\n-\t\t  update (new_parm_offset, aoffset1, size, a.max_size,\n-\t\t\t  record_adjustments);\n-\t\t  return true;\n-\t\t}\n-\t      else if (known_ge (aoffset1 + a.max_size, offset1))\n+\t      if (!known_size_p (a.max_size)\n+\t\t  || known_ge (aoffset1 + a.max_size, offset1))\n \t\t{\n-\t\t  poly_int64 new_max_size = a.max_size;\n-\t\t  if (known_le (a.max_size, max_size + offset1 - aoffset1))\n-\t\t    new_max_size = max_size + offset1 - aoffset1;\n-\t\t  update (new_parm_offset, aoffset1, size, new_max_size,\n-\t\t\t  record_adjustments);\n+\t\t  update2 (new_parm_offset, offset1, size, max_size,\n+\t\t\t   aoffset1, a.size, a.max_size,\n+\t\t\t   record_adjustments);\n \t\t  return true;\n \t\t}\n \t    }\n \t  return false;\n \t}\n-      update (new_parm_offset, offset + offset_adj,\n+      update (new_parm_offset, offset1,\n \t      size, max_size, record_adjustments);\n       return true;\n     }\n+  /* Return true if A1 and B1 can be merged with lower informatoin\n+     less than A2 and B2.\n+     Assume that no containment or lossless merging is possible.  */\n+  static bool closer_pair_p (const modref_access_node &a1,\n+\t\t\t     const modref_access_node &b1,\n+\t\t\t     const modref_access_node &a2,\n+\t\t\t     const modref_access_node &b2)\n+    {\n+      /* Merging different parm indexes comes to complete loss\n+\t of range info.  */\n+      if (a1.parm_index != b1.parm_index)\n+\treturn false;\n+      if (a2.parm_index != b2.parm_index)\n+\treturn true;\n+      /* If parm is known and parm indexes are the same we should\n+\t already have containment.  */\n+      gcc_checking_assert (a1.parm_offset_known && b1.parm_offset_known);\n+      gcc_checking_assert (a2.parm_offset_known && b2.parm_offset_known);\n+\n+      /* First normalize offsets for parm offsets.  */\n+      poly_int64 new_parm_offset, offseta1, offsetb1, offseta2, offsetb2;\n+      if (!a1.combined_offsets (b1, &new_parm_offset, &offseta1, &offsetb1)\n+\t  || !a2.combined_offsets (b2, &new_parm_offset, &offseta2, &offsetb2))\n+\tgcc_unreachable ();\n+\n+\n+      /* Now compute distnace of the intervals.  */\n+      poly_int64 dist1, dist2;\n+      if (known_le (offseta1, offsetb1))\n+\t{\n+\t  if (!known_size_p (a1.max_size))\n+\t    dist1 = 0;\n+\t  else\n+\t    dist1 = offsetb1 - offseta1 - a1.max_size;\n+\t}\n+      else\n+\t{\n+\t  if (!known_size_p (b1.max_size))\n+\t    dist1 = 0;\n+\t  else\n+\t    dist1 = offseta1 - offsetb1 - b1.max_size;\n+\t}\n+      if (known_le (offseta2, offsetb2))\n+\t{\n+\t  if (!known_size_p (a2.max_size))\n+\t    dist2 = 0;\n+\t  else\n+\t    dist2 = offsetb2 - offseta2 - a2.max_size;\n+\t}\n+      else\n+\t{\n+\t  if (!known_size_p (b2.max_size))\n+\t    dist2 = 0;\n+\t  else\n+\t    dist2 = offseta2 - offsetb2 - b2.max_size;\n+\t}\n+      /* It may happen that intervals overlap in case size\n+\t is different.  Preffer the overlap to non-overlap.  */\n+      if (known_lt (dist1, 0) && known_ge (dist2, 0))\n+\treturn true;\n+      if (known_lt (dist2, 0) && known_ge (dist1, 0))\n+\treturn false;\n+      if (known_lt (dist1, 0))\n+\t/* If both overlaps minimize overlap.  */\n+\treturn known_le (dist2, dist1);\n+      else\n+\t/* If both are disjoint look for smaller distance.  */\n+\treturn known_le (dist1, dist2);\n+    }\n+\n+  /* Merge in access A while losing precision.  */\n+  void forced_merge (const modref_access_node &a, bool record_adjustments)\n+    {\n+      if (parm_index != a.parm_index)\n+\t{\n+\t  gcc_checking_assert (parm_index != -1);\n+\t  parm_index = -1;\n+\t  return;\n+\t}\n+\n+      /* We assume that containment and lossless merging\n+\t was tested earlier.  */\n+      gcc_checking_assert (!contains (a) && !a.contains (*this)\n+\t\t\t   && !merge (a, record_adjustments));\n+      gcc_checking_assert (parm_offset_known && a.parm_offset_known);\n+\n+      poly_int64 new_parm_offset, offset1, aoffset1;\n+      if (!combined_offsets (a, &new_parm_offset, &offset1, &aoffset1))\n+\t{\n+\t  parm_offset_known = false;\n+\t  return;\n+\t}\n+      gcc_checking_assert (range_info_useful_p ()\n+\t\t\t   && a.range_info_useful_p ());\n+      if (record_adjustments)\n+\tadjustments += a.adjustments;\n+      update2 (new_parm_offset,\n+\t       offset1, size, max_size,\n+\t       aoffset1, a.size, a.max_size,\n+\t       record_adjustments);\n+    }\n+private:\n+  /* Merge two ranges both starting at parm_offset1 and update THIS\n+     with result.  */\n+  void update2 (poly_int64 parm_offset1,\n+\t\tpoly_int64 offset1, poly_int64 size1, poly_int64 max_size1,\n+\t\tpoly_int64 offset2, poly_int64 size2, poly_int64 max_size2,\n+\t\tbool record_adjustments)\n+    {\n+      poly_int64 new_size = size1;\n+\n+      if (!known_size_p (size2)\n+\t  || known_le (size2, size1))\n+\tnew_size = size2;\n+      else\n+\tgcc_checking_assert (known_le (size1, size2));\n+\n+      if (known_le (offset1, offset2))\n+\t;\n+      else if (known_le (offset2, offset1))\n+\t{\n+\t  std::swap (offset1, offset2);\n+\t  std::swap (max_size1, max_size2);\n+\t}\n+      else\n+\tgcc_unreachable ();\n+\n+      poly_int64 new_max_size;\n+\n+      if (!known_size_p (max_size1))\n+\tnew_max_size = max_size1;\n+      else if (!known_size_p (max_size2))\n+\tnew_max_size = max_size2;\n+      else\n+\t{\n+\t  max_size2 = max_size2 + offset2 - offset1;\n+\t  if (known_le (max_size, max_size2))\n+\t    new_max_size = max_size2;\n+\t  else if (known_le (max_size2, max_size))\n+\t    new_max_size = max_size;\n+\t  else\n+\t    gcc_unreachable ();\n+\t}\n+\n+      update (parm_offset1, offset1,\n+\t      new_size, new_max_size, record_adjustments);\n+    }\n+  /* Given access nodes THIS and A, return true if they\n+     can be done with common parm_offsets.  In this case\n+     return parm offset in new_parm_offset, new_offset\n+     which is start of range in THIS and new_aoffset that\n+     is start of range in A.  */\n+  bool combined_offsets (const modref_access_node &a,\n+\t\t\t poly_int64 *new_parm_offset,\n+\t\t\t poly_int64 *new_offset,\n+\t\t\t poly_int64 *new_aoffset) const\n+    {\n+      gcc_checking_assert (parm_offset_known && a.parm_offset_known);\n+      if (known_le (a.parm_offset, parm_offset))\n+\t{\n+\t  *new_offset = offset\n+\t\t\t+ ((parm_offset - a.parm_offset)\n+\t\t\t   << LOG2_BITS_PER_UNIT);\n+\t  *new_aoffset = a.offset;\n+\t  *new_parm_offset = a.parm_offset;\n+\t  return true;\n+\t}\n+      else if (known_le (parm_offset, a.parm_offset))\n+\t{\n+\t  *new_aoffset = a.offset\n+\t  \t\t  + ((a.parm_offset - parm_offset)\n+\t\t\t     << LOG2_BITS_PER_UNIT);\n+\t  *new_offset = offset;\n+\t  *new_parm_offset = parm_offset;\n+\t  return true;\n+\t}\n+      else\n+\treturn false;\n+    }\n };\n \n /* Access node specifying no useful info.  */\n@@ -348,7 +498,7 @@ struct GTY((user)) modref_ref_node\n       return false;\n \n     /* Otherwise, insert a node for the ref of the access under the base.  */\n-    size_t i;\n+    size_t i, j;\n     modref_access_node *a2;\n \n     if (flag_checking)\n@@ -390,11 +540,61 @@ struct GTY((user)) modref_ref_node\n        all accesses and bail out.  */\n     if (accesses && accesses->length () >= max_accesses)\n       {\n-\tif (dump_file)\n+\tif (max_accesses < 2)\n+\t  {\n+\t    collapse ();\n+\t    if (dump_file)\n+\t      fprintf (dump_file,\n+\t\t       \"--param param=modref-max-accesses limit reached;\"\n+\t\t       \" collapsing\\n\");\n+\t    return true;\n+\t  }\n+\t/* Find least harmful merge and perform it.  */\n+\tint best1 = -1, best2 = -1;\n+\tFOR_EACH_VEC_SAFE_ELT (accesses, i, a2)\n+\t  {\n+\t    for (j = i + 1; j < accesses->length (); j++)\n+\t      if (best1 < 0\n+\t\t  || modref_access_node::closer_pair_p\n+\t\t       (*a2, (*accesses)[j],\n+\t\t\t(*accesses)[best1],\n+\t\t\tbest2 < 0 ? a : (*accesses)[best2]))\n+\t\t{\n+\t\t  best1 = i;\n+\t\t  best2 = j;\n+\t\t}\n+\t    if (modref_access_node::closer_pair_p\n+\t\t       (*a2, a,\n+\t\t\t(*accesses)[best1],\n+\t\t\tbest2 < 0 ? a : (*accesses)[best2]))\n+\t      {\n+\t\tbest1 = i;\n+\t\tbest2 = -1;\n+\t      }\n+\t  }\n+\t(*accesses)[best1].forced_merge (best2 < 0 ? a : (*accesses)[best2],\n+\t\t\t\t\t record_adjustments);\n+\tif (!(*accesses)[best1].useful_p ())\n+\t  {\n+\t    collapse ();\n+\t    if (dump_file)\n+\t      fprintf (dump_file,\n+\t\t       \"--param param=modref-max-accesses limit reached;\"\n+\t\t       \" collapsing\\n\");\n+\t    return true;\n+\t  }\n+\tif (dump_file && best2 >= 0)\n \t  fprintf (dump_file,\n-\t\t   \"--param param=modref-max-accesses limit reached\\n\");\n-\tcollapse ();\n-\treturn true;\n+\t\t   \"--param param=modref-max-accesses limit reached;\"\n+\t\t   \" merging %i and %i\\n\", best1, best2);\n+\telse if (dump_file)\n+\t  fprintf (dump_file,\n+\t\t   \"--param param=modref-max-accesses limit reached;\"\n+\t\t   \" merging with %i\\n\", best1);\n+\ttry_merge_with (best1);\n+\tif (best2 >= 0)\n+\t  insert_access (a, max_accesses, record_adjustments);\n+\treturn 1;\n       }\n     a.adjustments = 0;\n     vec_safe_push (accesses, a);"}, {"sha": "02de2f09288a7edd9c45f5b5b83425cdc1c4c38f", "filename": "gcc/testsuite/gcc.dg/tree-ssa/modref-9.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5ff3a8ed4ca91737c16757ce4938cf2e0187fc0/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fmodref-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5ff3a8ed4ca91737c16757ce4938cf2e0187fc0/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fmodref-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fmodref-9.c?ref=f5ff3a8ed4ca91737c16757ce4938cf2e0187fc0", "patch": "@@ -0,0 +1,15 @@\n+/* { dg-options \"-O2 --param modref-max-accesses=2 -fdump-tree-modref1\"  } */\n+/* { dg-do compile } */\n+void\n+test(char *a)\n+{\n+  a[0] = 0;\n+  a[1] = 1;\n+  a[3] = 3;\n+  a[7] = 7;\n+  a[9] = 9;\n+}\n+/* We allow only two accesses per function.\n+   It is best to group together {0,1,3} and {7,9}.  */\n+/* { dg-final { scan-tree-dump \"access: Parm 0 param offset:0 offset:0 size:8 max_size:32\" \"modref1\" } } */\n+/* { dg-final { scan-tree-dump \"access: Parm 0 param offset:7 offset:0 size:8 max_size:24\" \"modref1\" } } */"}]}