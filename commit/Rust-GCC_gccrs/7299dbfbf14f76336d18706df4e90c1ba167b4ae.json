{"sha": "7299dbfbf14f76336d18706df4e90c1ba167b4ae", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzI5OWRiZmJmMTRmNzYzMzZkMTg3MDZkZjRlOTBjMWJhMTY3YjRhZQ==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "dvorakz@suse.cz", "date": "2004-11-10T20:49:55Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2004-11-10T20:49:55Z"}, "message": "tree-ssa-loop-ivopts.c (get_address_cost): Add address elements in right order.\n\n\t* tree-ssa-loop-ivopts.c (get_address_cost): Add address elements in\n\tright order.\n\t(force_var_cost): Determine cost of addition and multiplication more\n\tprecisely.\n\t(get_computation_cost_at): Add cost for computing address elements to\n\tthe final cost.\n\n\t* fold-const.c (fold): Attempt to use ptr_difference_const whenever\n\tone of the arguments of MINUS_EXPR is an address.\n\t(split_address_to_core_and_offset): New function.\n\t(ptr_difference_const): Handle case when one of the operands is a\n\tpointer.\n\t* tree-ssa-loop-ivopts.c (determine_base_object): Fold &*addr.\n\t(ptr_difference_cost): Pass addresses instead of objects to\n\tptr_difference_const.\n\nFrom-SVN: r90451", "tree": {"sha": "74c265b69ab975f9fd5932220b599547ade0412e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/74c265b69ab975f9fd5932220b599547ade0412e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7299dbfbf14f76336d18706df4e90c1ba167b4ae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7299dbfbf14f76336d18706df4e90c1ba167b4ae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7299dbfbf14f76336d18706df4e90c1ba167b4ae", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7299dbfbf14f76336d18706df4e90c1ba167b4ae/comments", "author": null, "committer": null, "parents": [{"sha": "9665466484bfb8035acf80f73d5d2449060b47e7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9665466484bfb8035acf80f73d5d2449060b47e7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9665466484bfb8035acf80f73d5d2449060b47e7"}], "stats": {"total": 142, "additions": 120, "deletions": 22}, "files": [{"sha": "57c0622dbb5c5cc2f1eb93fa302b9353975e907a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7299dbfbf14f76336d18706df4e90c1ba167b4ae/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7299dbfbf14f76336d18706df4e90c1ba167b4ae/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7299dbfbf14f76336d18706df4e90c1ba167b4ae", "patch": "@@ -1,3 +1,21 @@\n+2004-11-10  Zdenek Dvorak  <dvorakz@suse.cz>\n+\n+\t* tree-ssa-loop-ivopts.c (get_address_cost): Add address elements in\n+\tright order.\n+\t(force_var_cost): Determine cost of addition and multiplication more\n+\tprecisely.\n+\t(get_computation_cost_at): Add cost for computing address elements to\n+\tthe final cost.\n+\n+\t* fold-const.c (fold): Attempt to use ptr_difference_const whenever\n+\tone of the arguments of MINUS_EXPR is an address.\n+\t(split_address_to_core_and_offset): New function.\n+\t(ptr_difference_const): Handle case when one of the operands is a\n+\tpointer.\n+\t* tree-ssa-loop-ivopts.c (determine_base_object): Fold &*addr.\n+\t(ptr_difference_cost): Pass addresses instead of objects to\n+\tptr_difference_const.\n+\n 2004-11-10  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* tree.c (tree_check_failed): Emit general error if the list of"}, {"sha": "b8ccfa1d20708156385bed0cf755e49a5a052d2d", "filename": "gcc/fold-const.c", "status": "modified", "additions": 37, "deletions": 13, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7299dbfbf14f76336d18706df4e90c1ba167b4ae/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7299dbfbf14f76336d18706df4e90c1ba167b4ae/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=7299dbfbf14f76336d18706df4e90c1ba167b4ae", "patch": "@@ -7074,11 +7074,9 @@ fold (tree expr)\n       {\n \tHOST_WIDE_INT diff;\n \n-\tif (TREE_CODE (arg0) == ADDR_EXPR\n-\t    && TREE_CODE (arg1) == ADDR_EXPR\n-\t    && ptr_difference_const (TREE_OPERAND (arg0, 0),\n-\t\t\t\t     TREE_OPERAND (arg1, 0),\n-\t\t\t\t     &diff))\n+\tif ((TREE_CODE (arg0) == ADDR_EXPR\n+\t     || TREE_CODE (arg1) == ADDR_EXPR)\n+\t    && ptr_difference_const (arg0, arg1, &diff))\n \t  return build_int_cst_type (type, diff);\n       }\n \t  \n@@ -10815,23 +10813,49 @@ round_down (tree value, int divisor)\n   return value;\n }\n \n+/* Returns the pointer to the base of the object addressed by EXP and\n+   extracts the information about the offset of the access, storing it\n+   to PBITPOS and POFFSET.  */\n+\n+static tree\n+split_address_to_core_and_offset (tree exp,\n+\t\t\t\t  HOST_WIDE_INT *pbitpos, tree *poffset)\n+{\n+  tree core;\n+  enum machine_mode mode;\n+  int unsignedp, volatilep;\n+  HOST_WIDE_INT bitsize;\n+\n+  if (TREE_CODE (exp) == ADDR_EXPR)\n+    {\n+      core = get_inner_reference (TREE_OPERAND (exp, 0), &bitsize, pbitpos,\n+\t\t\t\t  poffset, &mode, &unsignedp, &volatilep);\n+\n+      if (TREE_CODE (core) == INDIRECT_REF)\n+\tcore = TREE_OPERAND (core, 0);\n+    }\n+  else\n+    {\n+      core = exp;\n+      *pbitpos = 0;\n+      *poffset = NULL_TREE;\n+    }\n+\n+  return core;\n+}\n+\n /* Returns true if addresses of E1 and E2 differ by a constant, false\n-   otherwise.  If they do, &E1 - &E2 is stored in *DIFF.  */\n+   otherwise.  If they do, E1 - E2 is stored in *DIFF.  */\n \n bool\n ptr_difference_const (tree e1, tree e2, HOST_WIDE_INT *diff)\n {\n   tree core1, core2;\n-  HOST_WIDE_INT bitsize1, bitsize2;\n   HOST_WIDE_INT bitpos1, bitpos2;\n   tree toffset1, toffset2, tdiff, type;\n-  enum machine_mode mode1, mode2;\n-  int unsignedp1, unsignedp2, volatilep1, volatilep2;\n \n-  core1 = get_inner_reference (e1, &bitsize1, &bitpos1, &toffset1, &mode1,\n-\t\t\t       &unsignedp1, &volatilep1);\n-  core2 = get_inner_reference (e2, &bitsize2, &bitpos2, &toffset2, &mode2,\n-\t\t\t       &unsignedp2, &volatilep2);\n+  core1 = split_address_to_core_and_offset (e1, &bitpos1, &toffset1);\n+  core2 = split_address_to_core_and_offset (e2, &bitpos2, &toffset2);\n \n   if (bitpos1 % BITS_PER_UNIT != 0\n       || bitpos2 % BITS_PER_UNIT != 0"}, {"sha": "417c4635943512a506a62a65a98c7066289cdb96", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 65, "deletions": 9, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7299dbfbf14f76336d18706df4e90c1ba167b4ae/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7299dbfbf14f76336d18706df4e90c1ba167b4ae/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=7299dbfbf14f76336d18706df4e90c1ba167b4ae", "patch": "@@ -678,6 +678,9 @@ determine_base_object (tree expr)\n       if (!base)\n \treturn fold_convert (ptr_type_node, expr);\n \n+      if (TREE_CODE (base) == INDIRECT_REF)\n+\treturn fold_convert (ptr_type_node, TREE_OPERAND (base, 0));\n+\n       return fold (build1 (ADDR_EXPR, ptr_type_node, base));\n \n     case PLUS_EXPR:\n@@ -2613,7 +2616,7 @@ get_address_cost (bool symbol_present, bool var_present,\n \taddr = gen_rtx_fmt_ee (MULT, Pmode, addr, GEN_INT (rat));\n \n       if (var_present)\n-\taddr = gen_rtx_fmt_ee (PLUS, Pmode, reg1, addr);\n+\taddr = gen_rtx_fmt_ee (PLUS, Pmode, addr, reg1);\n \n       if (symbol_present)\n \t{\n@@ -2630,7 +2633,7 @@ get_address_cost (bool symbol_present, bool var_present,\n \tbase = NULL_RTX;\n     \n       if (base)\n-\taddr = gen_rtx_fmt_ee (PLUS, Pmode, base, addr);\n+\taddr = gen_rtx_fmt_ee (PLUS, Pmode, addr, base);\n   \n       start_sequence ();\n       addr = memory_address (Pmode, addr);\n@@ -2672,7 +2675,7 @@ find_depends (tree *expr_p, int *ws ATTRIBUTE_UNUSED, void *data)\n   return NULL_TREE;\n }\n \n-/* Estimates cost of forcing EXPR into variable.  DEPENDS_ON is a set of the\n+/* Estimates cost of forcing EXPR into a variable.  DEPENDS_ON is a set of the\n    invariants the computation depends on.  */\n \n static unsigned\n@@ -2683,6 +2686,9 @@ force_var_cost (struct ivopts_data *data,\n   static unsigned integer_cost;\n   static unsigned symbol_cost;\n   static unsigned address_cost;\n+  tree op0, op1;\n+  unsigned cost0, cost1, cost;\n+  enum machine_mode mode;\n \n   if (!costs_initialized)\n     {\n@@ -2744,8 +2750,60 @@ force_var_cost (struct ivopts_data *data,\n       return address_cost;\n     }\n \n-  /* Just an arbitrary value, FIXME.  */\n-  return target_spill_cost;\n+  switch (TREE_CODE (expr))\n+    {\n+    case PLUS_EXPR:\n+    case MINUS_EXPR:\n+    case MULT_EXPR:\n+      op0 = TREE_OPERAND (expr, 0);\n+      op1 = TREE_OPERAND (expr, 1);\n+\n+      if (is_gimple_val (op0))\n+\tcost0 = 0;\n+      else\n+\tcost0 = force_var_cost (data, op0, NULL);\n+\n+      if (is_gimple_val (op1))\n+\tcost1 = 0;\n+      else\n+\tcost1 = force_var_cost (data, op1, NULL);\n+\n+      break;\n+\n+    default:\n+      /* Just an arbitrary value, FIXME.  */\n+      return target_spill_cost;\n+    }\n+\n+  mode = TYPE_MODE (TREE_TYPE (expr));\n+  switch (TREE_CODE (expr))\n+    {\n+    case PLUS_EXPR:\n+    case MINUS_EXPR:\n+      cost = add_cost (mode);\n+      break;\n+\n+    case MULT_EXPR:\n+      if (cst_and_fits_in_hwi (op0))\n+\tcost = multiply_by_cost (int_cst_value (op0), mode);\n+      else if (cst_and_fits_in_hwi (op1))\n+\tcost = multiply_by_cost (int_cst_value (op1), mode);\n+      else\n+\treturn target_spill_cost;\n+      break;\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  cost += cost0;\n+  cost += cost1;\n+\n+  /* Bound the cost by target_spill_cost.  The parts of complicated\n+     computations often are either loop invariant or at least can\n+     be shared between several iv uses, so letting this grow without\n+     limits would not give reasonable results.  */\n+  return cost < target_spill_cost ? cost : target_spill_cost;\n }\n \n /* Estimates cost of expressing address ADDR  as var + symbol + offset.  The\n@@ -2809,9 +2867,7 @@ ptr_difference_cost (struct ivopts_data *data,\n \n   gcc_assert (TREE_CODE (e1) == ADDR_EXPR);\n \n-  if (TREE_CODE (e2) == ADDR_EXPR\n-      && ptr_difference_const (TREE_OPERAND (e1, 0),\n-\t\t\t       TREE_OPERAND (e2, 0), &diff))\n+  if (ptr_difference_const (e1, e2, &diff))\n     {\n       *offset += diff;\n       *symbol_present = false;\n@@ -2994,7 +3050,7 @@ get_computation_cost_at (struct ivopts_data *data,\n      (symbol/var/const parts may be omitted).  If we are looking for an address,\n      find the cost of addressing this.  */\n   if (address_p)\n-    return get_address_cost (symbol_present, var_present, offset, ratio);\n+    return cost + get_address_cost (symbol_present, var_present, offset, ratio);\n \n   /* Otherwise estimate the costs for computing the expression.  */\n   aratio = ratio > 0 ? ratio : -ratio;"}]}