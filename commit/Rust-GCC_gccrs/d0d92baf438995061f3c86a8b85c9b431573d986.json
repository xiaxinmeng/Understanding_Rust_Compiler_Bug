{"sha": "d0d92baf438995061f3c86a8b85c9b431573d986", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDBkOTJiYWY0Mzg5OTUwNjFmM2M4NmE4Yjg1YzliNDMxNTczZDk4Ng==", "commit": {"author": {"name": "Kaveh R. Ghazi", "email": "ghazi@caip.rutgers.edu", "date": "2009-12-07T15:32:43Z"}, "committer": {"name": "Kaveh Ghazi", "email": "ghazi@gcc.gnu.org", "date": "2009-12-07T15:32:43Z"}, "message": "re PR other/40302 (GCC must hard-require MPC before release)\n\n\tPR other/40302\n\t* arith.c: Remove HAVE_mpc* checks throughout.\n\t* expr.c: Likewise.\n\t* gfortran.h: Likewise.\n\t* resolve.c: Likewise.\n\t* simplify.c: Likewise.\n\t* target-memory.c: Likewise.\n\t* target-memory.h: Likewise.\n\nFrom-SVN: r155043", "tree": {"sha": "8374386cd76e5ba3bcb337d91e5ac0dcf6838f84", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8374386cd76e5ba3bcb337d91e5ac0dcf6838f84"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d0d92baf438995061f3c86a8b85c9b431573d986", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d0d92baf438995061f3c86a8b85c9b431573d986", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d0d92baf438995061f3c86a8b85c9b431573d986", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d0d92baf438995061f3c86a8b85c9b431573d986/comments", "author": null, "committer": null, "parents": [{"sha": "2330bfb3f1e4aeab134177fa6bc23b70cffd39ae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2330bfb3f1e4aeab134177fa6bc23b70cffd39ae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2330bfb3f1e4aeab134177fa6bc23b70cffd39ae"}], "stats": {"total": 683, "additions": 29, "deletions": 654}, "files": [{"sha": "9d0506e1d53e109a948e671cf8c06c3fed0698c7", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0d92baf438995061f3c86a8b85c9b431573d986/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0d92baf438995061f3c86a8b85c9b431573d986/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=d0d92baf438995061f3c86a8b85c9b431573d986", "patch": "@@ -1,3 +1,14 @@\n+2009-12-07  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n+\n+\tPR other/40302\n+\t* arith.c: Remove HAVE_mpc* checks throughout.\n+\t* expr.c: Likewise.\n+\t* gfortran.h: Likewise.\n+\t* resolve.c: Likewise.\n+\t* simplify.c: Likewise.\n+\t* target-memory.c: Likewise.\n+\t* target-memory.h: Likewise.\n+\n 2009-12-06  Daniel Franke  <franke.daniel@gmail.com>\n \n \tPR fortran/40904"}, {"sha": "d119d1231f9e65e64ca75cb41fe5d7b37da9efd0", "filename": "gcc/fortran/arith.c", "status": "modified", "additions": 4, "deletions": 302, "changes": 306, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0d92baf438995061f3c86a8b85c9b431573d986/gcc%2Ffortran%2Farith.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0d92baf438995061f3c86a8b85c9b431573d986/gcc%2Ffortran%2Farith.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Farith.c?ref=d0d92baf438995061f3c86a8b85c9b431573d986", "patch": "@@ -429,12 +429,7 @@ gfc_constant_result (bt type, int kind, locus *where)\n \n     case BT_COMPLEX:\n       gfc_set_model_kind (kind);\n-#ifdef HAVE_mpc\n       mpc_init2 (result->value.complex, mpfr_get_default_prec());\n-#else\n-      mpfr_init (result->value.complex.r);\n-      mpfr_init (result->value.complex.i);\n-#endif\n       break;\n \n     default:\n@@ -639,12 +634,7 @@ gfc_arith_uminus (gfc_expr *op1, gfc_expr **resultp)\n       break;\n \n     case BT_COMPLEX:\n-#ifdef HAVE_mpc\n       mpc_neg (result->value.complex, op1->value.complex, GFC_MPC_RND_MODE);\n-#else\n-      mpfr_neg (result->value.complex.r, op1->value.complex.r, GFC_RND_MODE);\n-      mpfr_neg (result->value.complex.i, op1->value.complex.i, GFC_RND_MODE);\n-#endif\n       break;\n \n     default:\n@@ -677,16 +667,8 @@ gfc_arith_plus (gfc_expr *op1, gfc_expr *op2, gfc_expr **resultp)\n       break;\n \n     case BT_COMPLEX:\n-#ifdef HAVE_mpc\n       mpc_add (result->value.complex, op1->value.complex, op2->value.complex,\n \t       GFC_MPC_RND_MODE);\n-#else\n-      mpfr_add (result->value.complex.r, op1->value.complex.r,\n-\t\top2->value.complex.r, GFC_RND_MODE);\n-\n-      mpfr_add (result->value.complex.i, op1->value.complex.i,\n-\t\top2->value.complex.i, GFC_RND_MODE);\n-#endif\n       break;\n \n     default:\n@@ -719,16 +701,8 @@ gfc_arith_minus (gfc_expr *op1, gfc_expr *op2, gfc_expr **resultp)\n       break;\n \n     case BT_COMPLEX:\n-#ifdef HAVE_mpc\n       mpc_sub (result->value.complex, op1->value.complex,\n \t       op2->value.complex, GFC_MPC_RND_MODE);\n-#else\n-      mpfr_sub (result->value.complex.r, op1->value.complex.r,\n-\t\top2->value.complex.r, GFC_RND_MODE);\n-\n-      mpfr_sub (result->value.complex.i, op1->value.complex.i,\n-\t\top2->value.complex.i, GFC_RND_MODE);\n-#endif\n       break;\n \n     default:\n@@ -762,26 +736,8 @@ gfc_arith_times (gfc_expr *op1, gfc_expr *op2, gfc_expr **resultp)\n \n     case BT_COMPLEX:\n       gfc_set_model (mpc_realref (op1->value.complex));\n-#ifdef HAVE_mpc\n       mpc_mul (result->value.complex, op1->value.complex, op2->value.complex,\n \t       GFC_MPC_RND_MODE);\n-#else\n-    {\n-      mpfr_t x, y;\n-      mpfr_init (x);\n-      mpfr_init (y);\n-\n-      mpfr_mul (x, op1->value.complex.r, op2->value.complex.r, GFC_RND_MODE);\n-      mpfr_mul (y, op1->value.complex.i, op2->value.complex.i, GFC_RND_MODE);\n-      mpfr_sub (result->value.complex.r, x, y, GFC_RND_MODE);\n-\n-      mpfr_mul (x, op1->value.complex.r, op2->value.complex.i, GFC_RND_MODE);\n-      mpfr_mul (y, op1->value.complex.i, op2->value.complex.r, GFC_RND_MODE);\n-      mpfr_add (result->value.complex.i, x, y, GFC_RND_MODE);\n-\n-      mpfr_clears (x, y, NULL);\n-    }\n-#endif\n       break;\n \n     default:\n@@ -829,22 +785,14 @@ gfc_arith_divide (gfc_expr *op1, gfc_expr *op2, gfc_expr **resultp)\n       break;\n \n     case BT_COMPLEX:\n-      if (\n-#ifdef HAVE_mpc\n-\t  mpc_cmp_si_si (op2->value.complex, 0, 0) == 0\n-#else\n-\t  mpfr_sgn (op2->value.complex.r) == 0\n-\t  && mpfr_sgn (op2->value.complex.i) == 0\n-#endif\n+      if (mpc_cmp_si_si (op2->value.complex, 0, 0) == 0\n \t  && gfc_option.flag_range_check == 1)\n \t{\n \t  rc = ARITH_DIV0;\n \t  break;\n \t}\n \n       gfc_set_model (mpc_realref (op1->value.complex));\n-\t  \n-#ifdef HAVE_mpc\n       if (mpc_cmp_si_si (op2->value.complex, 0, 0) == 0)\n       {\n \t/* In Fortran, return (NaN + NaN I) for any zero divisor.  See\n@@ -855,32 +803,6 @@ gfc_arith_divide (gfc_expr *op1, gfc_expr *op2, gfc_expr **resultp)\n       else\n \tmpc_div (result->value.complex, op1->value.complex, op2->value.complex,\n \t\t GFC_MPC_RND_MODE);\n-#else\n-    {\n-      mpfr_t x, y, div;\n-      mpfr_init (x);\n-      mpfr_init (y);\n-      mpfr_init (div);\n-\n-      mpfr_mul (x, op2->value.complex.r, op2->value.complex.r, GFC_RND_MODE);\n-      mpfr_mul (y, op2->value.complex.i, op2->value.complex.i, GFC_RND_MODE);\n-      mpfr_add (div, x, y, GFC_RND_MODE);\n-\n-      mpfr_mul (x, op1->value.complex.r, op2->value.complex.r, GFC_RND_MODE);\n-      mpfr_mul (y, op1->value.complex.i, op2->value.complex.i, GFC_RND_MODE);\n-      mpfr_add (result->value.complex.r, x, y, GFC_RND_MODE);\n-      mpfr_div (result->value.complex.r, result->value.complex.r, div,\n-\t\tGFC_RND_MODE);\n-\n-      mpfr_mul (x, op1->value.complex.i, op2->value.complex.r, GFC_RND_MODE);\n-      mpfr_mul (y, op1->value.complex.r, op2->value.complex.i, GFC_RND_MODE);\n-      mpfr_sub (result->value.complex.i, x, y, GFC_RND_MODE);\n-      mpfr_div (result->value.complex.i, result->value.complex.i, div,\n-\t\tGFC_RND_MODE);\n-\n-      mpfr_clears (x, y, div, NULL);\n-    }\n-#endif\n       break;\n \n     default:\n@@ -893,107 +815,6 @@ gfc_arith_divide (gfc_expr *op1, gfc_expr *op2, gfc_expr **resultp)\n   return check_result (rc, op1, result, resultp);\n }\n \n-\n-/* Compute the reciprocal of a complex number (guaranteed nonzero).  */\n-\n-#if ! defined(HAVE_mpc_pow)\n-static void\n-complex_reciprocal (gfc_expr *op)\n-{\n-  gfc_set_model (mpc_realref (op->value.complex));\n-#ifdef HAVE_mpc\n-  mpc_ui_div (op->value.complex, 1, op->value.complex, GFC_MPC_RND_MODE);\n-#else\n-  {\n-  mpfr_t mod, tmp;\n-\n-  mpfr_init (mod);\n-  mpfr_init (tmp);\n-\n-  mpfr_mul (mod, op->value.complex.r, op->value.complex.r, GFC_RND_MODE);\n-  mpfr_mul (tmp, op->value.complex.i, op->value.complex.i, GFC_RND_MODE);\n-  mpfr_add (mod, mod, tmp, GFC_RND_MODE);\n-\n-  mpfr_div (op->value.complex.r, op->value.complex.r, mod, GFC_RND_MODE);\n-\n-  mpfr_neg (op->value.complex.i, op->value.complex.i, GFC_RND_MODE);\n-  mpfr_div (op->value.complex.i, op->value.complex.i, mod, GFC_RND_MODE);\n-\n-  mpfr_clears (tmp, mod, NULL);\n-  }\n-#endif\n-}\n-#endif /* ! HAVE_mpc_pow */\n-\n-\n-/* Raise a complex number to positive power (power > 0).\n-   This function will modify the content of power.\n-\n-   Use Binary Method, which is not an optimal but a simple and reasonable\n-   arithmetic. See section 4.6.3, \"Evaluation of Powers\" of Donald E. Knuth,\n-   \"Seminumerical Algorithms\", Vol. 2, \"The Art of Computer Programming\",\n-   3rd Edition, 1998.  */\n-\n-#if ! defined(HAVE_mpc_pow)\n-static void\n-complex_pow (gfc_expr *result, gfc_expr *base, mpz_t power)\n-{\n-  mpfr_t x_r, x_i, tmp, re, im;\n-\n-  gfc_set_model (mpc_realref (base->value.complex));\n-  mpfr_init (x_r);\n-  mpfr_init (x_i);\n-  mpfr_init (tmp);\n-  mpfr_init (re);\n-  mpfr_init (im);\n-\n-  /* res = 1 */\n-#ifdef HAVE_mpc\n-  mpc_set_ui (result->value.complex, 1, GFC_MPC_RND_MODE);\n-#else\n-  mpfr_set_ui (result->value.complex.r, 1, GFC_RND_MODE);\n-  mpfr_set_ui (result->value.complex.i, 0, GFC_RND_MODE);\n-#endif\n-\n-  /* x = base */\n-  mpfr_set (x_r, mpc_realref (base->value.complex), GFC_RND_MODE);\n-  mpfr_set (x_i, mpc_imagref (base->value.complex), GFC_RND_MODE);\n-\n-  /* Macro for complex multiplication. We have to take care that\n-     res_r/res_i and a_r/a_i can (and will) be the same variable.  */\n-#define CMULT(res_r,res_i,a_r,a_i,b_r,b_i) \\\n-    mpfr_mul (re, a_r, b_r, GFC_RND_MODE), \\\n-    mpfr_mul (tmp, a_i, b_i, GFC_RND_MODE), \\\n-    mpfr_sub (re, re, tmp, GFC_RND_MODE), \\\n-    \\\n-    mpfr_mul (im, a_r, b_i, GFC_RND_MODE), \\\n-    mpfr_mul (tmp, a_i, b_r, GFC_RND_MODE), \\\n-    mpfr_add (res_i, im, tmp, GFC_RND_MODE), \\\n-    mpfr_set (res_r, re, GFC_RND_MODE)\n-  \n-#define res_r mpc_realref (result->value.complex)\n-#define res_i mpc_imagref (result->value.complex)\n-\n-  /* for (; power > 0; x *= x) */\n-  for (; mpz_cmp_si (power, 0) > 0; CMULT(x_r,x_i,x_r,x_i,x_r,x_i))\n-    {\n-      /* if (power & 1) res = res * x; */\n-      if (mpz_congruent_ui_p (power, 1, 2))\n-\tCMULT(res_r,res_i,res_r,res_i,x_r,x_i);\n-\n-      /* power /= 2; */\n-      mpz_fdiv_q_ui (power, power, 2);\n-    }\n-\n-#undef res_r\n-#undef res_i\n-#undef CMULT\n-\n-  mpfr_clears (x_r, x_i, tmp, re, im, NULL);\n-}\n-#endif /* ! HAVE_mpc_pow */\n-\n-\n /* Raise a number to a power.  */\n \n static arith\n@@ -1028,12 +849,7 @@ arith_power (gfc_expr *op1, gfc_expr *op2, gfc_expr **resultp)\n \t      break;\n \n \t    case BT_COMPLEX:\n-#ifdef HAVE_mpc\n \t      mpc_set_ui (result->value.complex, 1, GFC_MPC_RND_MODE);\n-#else\n-\t      mpfr_set_ui (result->value.complex.r, 1, GFC_RND_MODE);\n-\t      mpfr_set_ui (result->value.complex.i, 0, GFC_RND_MODE);\n-#endif\n \t      break;\n \n \t    default:\n@@ -1110,32 +926,8 @@ arith_power (gfc_expr *op1, gfc_expr *op2, gfc_expr **resultp)\n \t      break;\n \n \t    case BT_COMPLEX:\n-\t      {\n-#ifdef HAVE_mpc_pow_z\n-\t\tmpc_pow_z (result->value.complex, op1->value.complex,\n-\t\t\t   op2->value.integer, GFC_MPC_RND_MODE);\n-#elif defined(HAVE_mpc_pow)\n-\t\tmpc_t apower;\n-\t\tgfc_set_model (mpc_realref (op1->value.complex));\n-\t\tmpc_init2 (apower, mpfr_get_default_prec());\n-\t\tmpc_set_z (apower, op2->value.integer, GFC_MPC_RND_MODE);\n-\t\tmpc_pow(result->value.complex, op1->value.complex, apower,\n-\t\t\tGFC_MPC_RND_MODE);\n-\t\tmpc_clear (apower);\n-#else\n-\t\tmpz_t apower;\n-\n-\t\t/* Compute op1**abs(op2)  */\n-\t\tmpz_init (apower);\n-\t\tmpz_abs (apower, op2->value.integer);\n-\t\tcomplex_pow (result, op1, apower);\n-\t\tmpz_clear (apower);\n-\n-\t\t/* If (op2 < 0), compute the inverse.  */\n-\t\tif (power_sign < 0)\n-\t\t  complex_reciprocal (result);\n-#endif /* HAVE_mpc_pow */\n-\t      }\n+\t      mpc_pow_z (result->value.complex, op1->value.complex,\n+\t\t\t op2->value.integer, GFC_MPC_RND_MODE);\n \t      break;\n \n \t    default:\n@@ -1176,63 +968,8 @@ arith_power (gfc_expr *op1, gfc_expr *op2, gfc_expr **resultp)\n \t      return ARITH_PROHIBIT;\n \t  }\n \n-#ifdef HAVE_mpc_pow\n \tmpc_pow (result->value.complex, op1->value.complex,\n \t\t op2->value.complex, GFC_MPC_RND_MODE);\n-#else\n-\t{\n-\tmpfr_t x, y, r, t;\n-\n-\tgfc_set_model (mpc_realref (op1->value.complex));\n-\n-\tmpfr_init (r);\n-\n-#ifdef HAVE_mpc\n-\tmpc_abs (r, op1->value.complex, GFC_RND_MODE);\n-#else\n-\tmpfr_hypot (r, op1->value.complex.r, op1->value.complex.i,\n-\t\t    GFC_RND_MODE);\n-#endif\n-\tif (mpfr_cmp_si (r, 0) == 0)\n-\t  {\n-#ifdef HAVE_mpc\n-\t    mpc_set_ui (result->value.complex, 0, GFC_MPC_RND_MODE);\n-#else\n-\t    mpfr_set_ui (result->value.complex.r, 0, GFC_RND_MODE);\n-\t    mpfr_set_ui (result->value.complex.i, 0, GFC_RND_MODE);\n-#endif\n-\t    mpfr_clear (r);\n-\t    break;\n-\t  }\n-\tmpfr_log (r, r, GFC_RND_MODE);\n-\n-\tmpfr_init (t);\n-\n-#ifdef HAVE_mpc\n-\tmpc_arg (t, op1->value.complex, GFC_RND_MODE);\n-#else\n-\tmpfr_atan2 (t, op1->value.complex.i, op1->value.complex.r, \n-\t\t    GFC_RND_MODE);\n-#endif\n-\n-\tmpfr_init (x);\n-\tmpfr_init (y);\n-\n-\tmpfr_mul (x, mpc_realref (op2->value.complex), r, GFC_RND_MODE);\n-\tmpfr_mul (y, mpc_imagref (op2->value.complex), t, GFC_RND_MODE);\n-\tmpfr_sub (x, x, y, GFC_RND_MODE);\n-\tmpfr_exp (x, x, GFC_RND_MODE);\n-\n-\tmpfr_mul (y, mpc_realref (op2->value.complex), t, GFC_RND_MODE);\n-\tmpfr_mul (t, mpc_imagref (op2->value.complex), r, GFC_RND_MODE);\n-\tmpfr_add (y, y, t, GFC_RND_MODE);\n-\tmpfr_cos (t, y, GFC_RND_MODE);\n-\tmpfr_sin (y, y, GFC_RND_MODE);\n-\tmpfr_mul (mpc_realref (result->value.complex), x, t, GFC_RND_MODE);\n-\tmpfr_mul (mpc_imagref (result->value.complex), x, y, GFC_RND_MODE);\n-\tmpfr_clears (r, t, x, y, NULL);\n-\t}\n-#endif /* HAVE_mpc_pow */\n       }\n       break;\n     default:\n@@ -1350,12 +1087,7 @@ gfc_compare_expr (gfc_expr *op1, gfc_expr *op2, gfc_intrinsic_op op)\n static int\n compare_complex (gfc_expr *op1, gfc_expr *op2)\n {\n-#ifdef HAVE_mpc\n   return mpc_cmp (op1->value.complex, op2->value.complex) == 0;\n-#else\n-  return (mpfr_equal_p (op1->value.complex.r, op2->value.complex.r)\n-\t  && mpfr_equal_p (op1->value.complex.i, op2->value.complex.i));\n-#endif\n }\n \n \n@@ -2224,13 +1956,8 @@ gfc_convert_complex (gfc_expr *real, gfc_expr *imag, int kind)\n   gfc_expr *e;\n \n   e = gfc_constant_result (BT_COMPLEX, kind, &real->where);\n-#ifdef HAVE_mpc\n   mpc_set_fr_fr (e->value.complex, real->value.real, imag->value.real,\n \t\t GFC_MPC_RND_MODE);\n-#else\n-  mpfr_set (e->value.complex.r, real->value.real, GFC_RND_MODE);\n-  mpfr_set (e->value.complex.i, imag->value.real, GFC_RND_MODE);\n-#endif\n \n   return e;\n }\n@@ -2350,12 +2077,7 @@ gfc_int2complex (gfc_expr *src, int kind)\n \n   result = gfc_constant_result (BT_COMPLEX, kind, &src->where);\n \n-#ifdef HAVE_mpc\n   mpc_set_z (result->value.complex, src->value.integer, GFC_MPC_RND_MODE);\n-#else\n-  mpfr_set_z (result->value.complex.r, src->value.integer, GFC_RND_MODE);\n-  mpfr_set_ui (result->value.complex.i, 0, GFC_RND_MODE);\n-#endif\n \n   if ((rc = gfc_check_real_range (mpc_realref (result->value.complex), kind))\n       != ARITH_OK)\n@@ -2433,12 +2155,7 @@ gfc_real2complex (gfc_expr *src, int kind)\n \n   result = gfc_constant_result (BT_COMPLEX, kind, &src->where);\n \n-#ifdef HAVE_mpc\n   mpc_set_fr (result->value.complex, src->value.real, GFC_MPC_RND_MODE);\n-#else\n-  mpfr_set (result->value.complex.r, src->value.real, GFC_RND_MODE);\n-  mpfr_set_ui (result->value.complex.i, 0, GFC_RND_MODE);\n-#endif\n \n   rc = gfc_check_real_range (mpc_realref (result->value.complex), kind);\n \n@@ -2493,11 +2210,7 @@ gfc_complex2real (gfc_expr *src, int kind)\n \n   result = gfc_constant_result (BT_REAL, kind, &src->where);\n \n-#ifdef HAVE_mpc\n   mpc_real (result->value.real, src->value.complex, GFC_RND_MODE);\n-#else\n-  mpfr_set (result->value.real, src->value.complex.r, GFC_RND_MODE);\n-#endif\n \n   rc = gfc_check_real_range (result->value.real, kind);\n \n@@ -2528,12 +2241,7 @@ gfc_complex2complex (gfc_expr *src, int kind)\n \n   result = gfc_constant_result (BT_COMPLEX, kind, &src->where);\n \n-#ifdef HAVE_mpc\n   mpc_set (result->value.complex, src->value.complex, GFC_MPC_RND_MODE);\n-#else\n-  mpfr_set (result->value.complex.r, src->value.complex.r, GFC_RND_MODE);\n-  mpfr_set (result->value.complex.i, src->value.complex.i, GFC_RND_MODE);\n-#endif\n \n   rc = gfc_check_real_range (mpc_realref (result->value.complex), kind);\n \n@@ -2698,13 +2406,7 @@ gfc_hollerith2complex (gfc_expr *src, int kind)\n \n   hollerith2representation (result, src);\n   gfc_interpret_complex (kind, (unsigned char *) result->representation.string,\n-\t\t\t result->representation.length,\n-#ifdef HAVE_mpc\n-\t\t\t result->value.complex\n-#else\n-\t\t\t result->value.complex.r, result->value.complex.i\n-#endif\n-\t\t\t );\n+\t\t\t result->representation.length, result->value.complex);\n \n   return result;\n }"}, {"sha": "c693773ebf20a97d9d84d8eecaac1a7eca7cee0f", "filename": "gcc/fortran/expr.c", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0d92baf438995061f3c86a8b85c9b431573d986/gcc%2Ffortran%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0d92baf438995061f3c86a8b85c9b431573d986/gcc%2Ffortran%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fexpr.c?ref=d0d92baf438995061f3c86a8b85c9b431573d986", "patch": "@@ -156,12 +156,7 @@ free_expr0 (gfc_expr *e)\n \t  break;\n \n \tcase BT_COMPLEX:\n-#ifdef HAVE_mpc\n \t  mpc_clear (e->value.complex);\n-#else\n-\t  mpfr_clear (e->value.complex.r);\n-\t  mpfr_clear (e->value.complex.i);\n-#endif\n \t  break;\n \n \tdefault:\n@@ -473,15 +468,8 @@ gfc_copy_expr (gfc_expr *p)\n \n \tcase BT_COMPLEX:\n \t  gfc_set_model_kind (q->ts.kind);\n-#ifdef HAVE_mpc\n \t  mpc_init2 (q->value.complex, mpfr_get_default_prec());\n \t  mpc_set (q->value.complex, p->value.complex, GFC_MPC_RND_MODE);\n-#else\n-\t  mpfr_init (q->value.complex.r);\n-\t  mpfr_init (q->value.complex.i);\n-\t  mpfr_set (q->value.complex.r, p->value.complex.r, GFC_RND_MODE);\n-\t  mpfr_set (q->value.complex.i, p->value.complex.i, GFC_RND_MODE);\n-#endif\n \t  break;\n \n \tcase BT_CHARACTER:"}, {"sha": "3a13cfe4b2693727f893de276f030022f694f56c", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 1, "deletions": 21, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0d92baf438995061f3c86a8b85c9b431573d986/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0d92baf438995061f3c86a8b85c9b431573d986/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=d0d92baf438995061f3c86a8b85c9b431573d986", "patch": "@@ -1624,19 +1624,7 @@ gfc_class_esym_list;\n \n #include <gmp.h>\n #include <mpfr.h>\n-#ifdef HAVE_mpc\n #include <mpc.h>\n-# if MPC_VERSION >= MPC_VERSION_NUM(0,6,1)\n-#  define HAVE_mpc_pow\n-# endif\n-# if MPC_VERSION >= MPC_VERSION_NUM(0,7,1)\n-#  define HAVE_mpc_arc\n-#  define HAVE_mpc_pow_z\n-# endif\n-#else\n-#define mpc_realref(X) ((X).r)\n-#define mpc_imagref(X) ((X).i)\n-#endif\n #define GFC_RND_MODE GMP_RNDN\n #define GFC_MPC_RND_MODE MPC_RNDNN\n \n@@ -1695,15 +1683,7 @@ typedef struct gfc_expr\n \n     mpfr_t real;\n \n-#ifdef HAVE_mpc\n-    mpc_t\n-#else\n-    struct\n-    {\n-      mpfr_t r, i;\n-    }\n-#endif\n-    complex;\n+    mpc_t complex;\n \n     struct\n     {"}, {"sha": "6f6cb7816061cc029d3c1c2ccc3de2981e785419", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0d92baf438995061f3c86a8b85c9b431573d986/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0d92baf438995061f3c86a8b85c9b431573d986/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=d0d92baf438995061f3c86a8b85c9b431573d986", "patch": "@@ -8649,12 +8649,7 @@ build_default_init_expr (gfc_symbol *sym)\n       break;\n \t  \n     case BT_COMPLEX:\n-#ifdef HAVE_mpc\n       mpc_init2 (init_expr->value.complex, mpfr_get_default_prec());\n-#else\n-      mpfr_init (init_expr->value.complex.r);\n-      mpfr_init (init_expr->value.complex.i);\n-#endif\n       switch (gfc_option.flag_init_real)\n \t{\n \tcase GFC_INIT_REAL_SNAN:\n@@ -8676,12 +8671,7 @@ build_default_init_expr (gfc_symbol *sym)\n \t  break;\n \n \tcase GFC_INIT_REAL_ZERO:\n-#ifdef HAVE_mpc\n \t  mpc_set_ui (init_expr->value.complex, 0, GFC_MPC_RND_MODE);\n-#else\n-\t  mpfr_set_ui (init_expr->value.complex.r, 0.0, GFC_RND_MODE);\n-\t  mpfr_set_ui (init_expr->value.complex.i, 0.0, GFC_RND_MODE);\n-#endif\n \t  break;\n \n \tdefault:"}, {"sha": "8768cb64de2894b6e0900da3fa781447b5eeaf75", "filename": "gcc/fortran/simplify.c", "status": "modified", "additions": 4, "deletions": 243, "changes": 247, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0d92baf438995061f3c86a8b85c9b431573d986/gcc%2Ffortran%2Fsimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0d92baf438995061f3c86a8b85c9b431573d986/gcc%2Ffortran%2Fsimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsimplify.c?ref=d0d92baf438995061f3c86a8b85c9b431573d986", "patch": "@@ -283,12 +283,7 @@ init_result_expr (gfc_expr *e, int init, gfc_expr *array)\n \t    break;\n \n \t  case BT_COMPLEX:\n-#ifdef HAVE_mpc\n \t    mpc_set_si (e->value.complex, init, GFC_MPC_RND_MODE);\n-#else\n-\t    mpfr_set_si (e->value.complex.r, init, GFC_RND_MODE);\n-\t    mpfr_set_si (e->value.complex.i, 0, GFC_RND_MODE);\n-#endif\n \t    break;\n \n \t  case BT_CHARACTER:\n@@ -644,12 +639,7 @@ gfc_simplify_abs (gfc_expr *e)\n \n       gfc_set_model_kind (e->ts.kind);\n \n-#ifdef HAVE_mpc\n       mpc_abs (result->value.real, e->value.complex, GFC_RND_MODE);\n-#else\n-      mpfr_hypot (result->value.real, e->value.complex.r, \n-\t\t  e->value.complex.i, GFC_RND_MODE);\n-#endif\n       result = range_check (result, \"CABS\");\n       break;\n \n@@ -749,13 +739,9 @@ gfc_simplify_acos (gfc_expr *x)\n \tmpfr_acos (result->value.real, x->value.real, GFC_RND_MODE);\n \tbreak;\n       case BT_COMPLEX:\n-#ifdef HAVE_mpc_arc\n \tresult = gfc_constant_result (x->ts.type, x->ts.kind, &x->where);\n \tmpc_acos (result->value.complex, x->value.complex, GFC_MPC_RND_MODE);\n \tbreak;\n-#else\n-\treturn NULL;\n-#endif\n       default:\n \tgfc_internal_error (\"in gfc_simplify_acos(): Bad type\");\n     }\n@@ -786,13 +772,9 @@ gfc_simplify_acosh (gfc_expr *x)\n \tmpfr_acosh (result->value.real, x->value.real, GFC_RND_MODE);\n \tbreak;\n       case BT_COMPLEX:\n-#ifdef HAVE_mpc_arc\n \tresult = gfc_constant_result (x->ts.type, x->ts.kind, &x->where);\n \tmpc_acosh (result->value.complex, x->value.complex, GFC_MPC_RND_MODE);\n \tbreak;\n-#else\n-\treturn NULL;\n-#endif\n       default:\n \tgfc_internal_error (\"in gfc_simplify_acosh(): Bad type\");\n     }\n@@ -1054,13 +1036,9 @@ gfc_simplify_asin (gfc_expr *x)\n \tmpfr_asin (result->value.real, x->value.real, GFC_RND_MODE);\n \tbreak;\n       case BT_COMPLEX:\n-#ifdef HAVE_mpc_arc\n \tresult = gfc_constant_result (x->ts.type, x->ts.kind, &x->where);\n \tmpc_asin (result->value.complex, x->value.complex, GFC_MPC_RND_MODE);\n \tbreak;\n-#else\n-\treturn NULL;\n-#endif\n       default:\n \tgfc_internal_error (\"in gfc_simplify_asin(): Bad type\");\n     }\n@@ -1084,13 +1062,9 @@ gfc_simplify_asinh (gfc_expr *x)\n \tmpfr_asinh (result->value.real, x->value.real, GFC_RND_MODE);\n \tbreak;\n       case BT_COMPLEX:\n-#ifdef HAVE_mpc_arc\n \tresult = gfc_constant_result (x->ts.type, x->ts.kind, &x->where);\n \tmpc_asinh (result->value.complex, x->value.complex, GFC_MPC_RND_MODE);\n \tbreak;\n-#else\n-\treturn NULL;\n-#endif\n       default:\n \tgfc_internal_error (\"in gfc_simplify_asinh(): Bad type\");\n     }\n@@ -1114,13 +1088,9 @@ gfc_simplify_atan (gfc_expr *x)\n \tmpfr_atan (result->value.real, x->value.real, GFC_RND_MODE);\n \tbreak;\n       case BT_COMPLEX:\n-#ifdef HAVE_mpc_arc\n \tresult = gfc_constant_result (x->ts.type, x->ts.kind, &x->where);\n \tmpc_atan (result->value.complex, x->value.complex, GFC_MPC_RND_MODE);\n \tbreak;\n-#else\n-\treturn NULL;\n-#endif\n       default:\n \tgfc_internal_error (\"in gfc_simplify_atan(): Bad type\");\n     }\n@@ -1152,13 +1122,9 @@ gfc_simplify_atanh (gfc_expr *x)\n \tmpfr_atanh (result->value.real, x->value.real, GFC_RND_MODE);\n \tbreak;\n       case BT_COMPLEX:\n-#ifdef HAVE_mpc_arc\n \tresult = gfc_constant_result (x->ts.type, x->ts.kind, &x->where);\n \tmpc_atanh (result->value.complex, x->value.complex, GFC_MPC_RND_MODE);\n \tbreak;\n-#else\n-\treturn NULL;\n-#endif\n       default:\n \tgfc_internal_error (\"in gfc_simplify_atanh(): Bad type\");\n     }\n@@ -1357,36 +1323,19 @@ simplify_cmplx (const char *name, gfc_expr *x, gfc_expr *y, int kind)\n \n   result = gfc_constant_result (BT_COMPLEX, kind, &x->where);\n \n-#ifndef HAVE_mpc\n-  mpfr_set_ui (result->value.complex.i, 0, GFC_RND_MODE);\n-#endif\n-\n   switch (x->ts.type)\n     {\n     case BT_INTEGER:\n       if (!x->is_boz)\n-#ifdef HAVE_mpc\n \tmpc_set_z (result->value.complex, x->value.integer, GFC_MPC_RND_MODE);\n-#else\n-\tmpfr_set_z (result->value.complex.r, x->value.integer, GFC_RND_MODE);\n-#endif\n       break;\n \n     case BT_REAL:\n-#ifdef HAVE_mpc\n       mpc_set_fr (result->value.complex, x->value.real, GFC_RND_MODE);\n-#else\n-      mpfr_set (result->value.complex.r, x->value.real, GFC_RND_MODE);\n-#endif\n       break;\n \n     case BT_COMPLEX:\n-#ifdef HAVE_mpc\n       mpc_set (result->value.complex, x->value.complex, GFC_MPC_RND_MODE);\n-#else\n-      mpfr_set (result->value.complex.r, x->value.complex.r, GFC_RND_MODE);\n-      mpfr_set (result->value.complex.i, x->value.complex.i, GFC_RND_MODE);\n-#endif\n       break;\n \n     default:\n@@ -1517,12 +1466,7 @@ gfc_simplify_conjg (gfc_expr *e)\n     return NULL;\n \n   result = gfc_copy_expr (e);\n-#ifdef HAVE_mpc\n   mpc_conj (result->value.complex, result->value.complex, GFC_MPC_RND_MODE);\n-#else\n-  mpfr_neg (result->value.complex.i, result->value.complex.i, GFC_RND_MODE);\n-#endif\n-\n   return range_check (result, \"CONJG\");\n }\n \n@@ -1544,26 +1488,7 @@ gfc_simplify_cos (gfc_expr *x)\n       break;\n     case BT_COMPLEX:\n       gfc_set_model_kind (x->ts.kind);\n-#ifdef HAVE_mpc\n       mpc_cos (result->value.complex, x->value.complex, GFC_MPC_RND_MODE);\n-#else\n-    {\n-      mpfr_t xp, xq;\n-      mpfr_init (xp);\n-      mpfr_init (xq);\n-\n-      mpfr_cos  (xp, x->value.complex.r, GFC_RND_MODE);\n-      mpfr_cosh (xq, x->value.complex.i, GFC_RND_MODE);\n-      mpfr_mul (result->value.complex.r, xp, xq, GFC_RND_MODE);\n-\n-      mpfr_sin  (xp, x->value.complex.r, GFC_RND_MODE);\n-      mpfr_sinh (xq, x->value.complex.i, GFC_RND_MODE);\n-      mpfr_mul (xp, xp, xq, GFC_RND_MODE);\n-      mpfr_neg (result->value.complex.i, xp, GFC_RND_MODE );\n-\n-      mpfr_clears (xp, xq, NULL);\n-    }\n-#endif\n       break;\n     default:\n       gfc_internal_error (\"in gfc_simplify_cos(): Bad type\");\n@@ -1587,14 +1512,7 @@ gfc_simplify_cosh (gfc_expr *x)\n   if (x->ts.type == BT_REAL)\n     mpfr_cosh (result->value.real, x->value.real, GFC_RND_MODE);\n   else if (x->ts.type == BT_COMPLEX)\n-    {\n-#if HAVE_mpc\n-      mpc_cosh (result->value.complex, x->value.complex, GFC_MPC_RND_MODE);\n-#else\n-      gfc_free_expr (result);\n-      return NULL;\n-#endif\n-    }\n+    mpc_cosh (result->value.complex, x->value.complex, GFC_MPC_RND_MODE);\n   else\n     gcc_unreachable ();\n \n@@ -2000,21 +1918,7 @@ gfc_simplify_exp (gfc_expr *x)\n \n     case BT_COMPLEX:\n       gfc_set_model_kind (x->ts.kind);\n-#ifdef HAVE_mpc\n       mpc_exp (result->value.complex, x->value.complex, GFC_MPC_RND_MODE);\n-#else\n-    {\n-      mpfr_t xp, xq;\n-      mpfr_init (xp);\n-      mpfr_init (xq);\n-      mpfr_exp (xq, x->value.complex.r, GFC_RND_MODE);\n-      mpfr_cos (xp, x->value.complex.i, GFC_RND_MODE);\n-      mpfr_mul (result->value.complex.r, xq, xp, GFC_RND_MODE);\n-      mpfr_sin (xp, x->value.complex.i, GFC_RND_MODE);\n-      mpfr_mul (result->value.complex.i, xq, xp, GFC_RND_MODE);\n-      mpfr_clears (xp, xq, NULL);\n-    }\n-#endif\n       break;\n \n     default:\n@@ -3393,26 +3297,7 @@ gfc_simplify_log (gfc_expr *x)\n \t}\n \n       gfc_set_model_kind (x->ts.kind);\n-#ifdef HAVE_mpc\n       mpc_log (result->value.complex, x->value.complex, GFC_MPC_RND_MODE);\n-#else\n-    {\n-      mpfr_t xr, xi;\n-      mpfr_init (xr);\n-      mpfr_init (xi);\n-\n-      mpfr_atan2 (result->value.complex.i, x->value.complex.i,\n-\t\t  x->value.complex.r, GFC_RND_MODE);\n-\n-      mpfr_mul (xr, x->value.complex.r, x->value.complex.r, GFC_RND_MODE);\n-      mpfr_mul (xi, x->value.complex.i, x->value.complex.i, GFC_RND_MODE);\n-      mpfr_add (xr, xr, xi, GFC_RND_MODE);\n-      mpfr_sqrt (xr, xr, GFC_RND_MODE);\n-      mpfr_log (result->value.complex.r, xr, GFC_RND_MODE);\n-\n-      mpfr_clears (xr, xi, NULL);\n-    }\n-#endif\n       break;\n \n     default:\n@@ -4305,12 +4190,7 @@ gfc_simplify_realpart (gfc_expr *e)\n     return NULL;\n \n   result = gfc_constant_result (BT_REAL, e->ts.kind, &e->where);\n-#ifdef HAVE_mpc\n   mpc_real (result->value.real, e->value.complex, GFC_RND_MODE);\n-#else\n-  mpfr_set (result->value.real, e->value.complex.r, GFC_RND_MODE);\n-#endif\n-\n   return range_check (result, \"REALPART\");\n }\n \n@@ -5089,25 +4969,7 @@ gfc_simplify_sin (gfc_expr *x)\n \n     case BT_COMPLEX:\n       gfc_set_model (x->value.real);\n-#ifdef HAVE_mpc\n       mpc_sin (result->value.complex, x->value.complex, GFC_MPC_RND_MODE);\n-#else\n-    {\n-      mpfr_t xp, xq;\n-      mpfr_init (xp);\n-      mpfr_init (xq);\n-\n-      mpfr_sin  (xp, x->value.complex.r, GFC_RND_MODE);\n-      mpfr_cosh (xq, x->value.complex.i, GFC_RND_MODE);\n-      mpfr_mul (result->value.complex.r, xp, xq, GFC_RND_MODE);\n-\n-      mpfr_cos  (xp, x->value.complex.r, GFC_RND_MODE);\n-      mpfr_sinh (xq, x->value.complex.i, GFC_RND_MODE);\n-      mpfr_mul (result->value.complex.i, xp, xq, GFC_RND_MODE);\n-\n-      mpfr_clears (xp, xq, NULL);\n-    }\n-#endif\n       break;\n \n     default:\n@@ -5131,14 +4993,7 @@ gfc_simplify_sinh (gfc_expr *x)\n   if (x->ts.type == BT_REAL)\n     mpfr_sinh (result->value.real, x->value.real, GFC_RND_MODE);\n   else if (x->ts.type == BT_COMPLEX)\n-    {\n-#if HAVE_mpc\n-      mpc_sinh (result->value.complex, x->value.complex, GFC_MPC_RND_MODE);\n-#else\n-      gfc_free_expr (result);\n-      return NULL;\n-#endif\n-    }\n+    mpc_sinh (result->value.complex, x->value.complex, GFC_MPC_RND_MODE);\n   else\n     gcc_unreachable ();\n \n@@ -5329,87 +5184,7 @@ gfc_simplify_sqrt (gfc_expr *e)\n \n     case BT_COMPLEX:\n       gfc_set_model (e->value.real);\n-#ifdef HAVE_mpc\n       mpc_sqrt (result->value.complex, e->value.complex, GFC_MPC_RND_MODE);\n-#else\n-    {\n-      /* Formula taken from Numerical Recipes to avoid over- and\n-\t underflow.  */\n-\n-      mpfr_t ac, ad, s, t, w;\n-      mpfr_init (ac);\n-      mpfr_init (ad);\n-      mpfr_init (s);\n-      mpfr_init (t);\n-      mpfr_init (w);\n-\n-      if (mpfr_cmp_ui (e->value.complex.r, 0) == 0\n-\t  && mpfr_cmp_ui (e->value.complex.i, 0) == 0)\n-\t{\n-\t  mpfr_set_ui (result->value.complex.r, 0, GFC_RND_MODE);\n-\t  mpfr_set_ui (result->value.complex.i, 0, GFC_RND_MODE);\n-\t  break;\n-\t}\n-\n-      mpfr_abs (ac, e->value.complex.r, GFC_RND_MODE);\n-      mpfr_abs (ad, e->value.complex.i, GFC_RND_MODE);\n-\n-      if (mpfr_cmp (ac, ad) >= 0)\n-\t{\n-\t  mpfr_div (t, e->value.complex.i, e->value.complex.r, GFC_RND_MODE);\n-\t  mpfr_mul (t, t, t, GFC_RND_MODE);\n-\t  mpfr_add_ui (t, t, 1, GFC_RND_MODE);\n-\t  mpfr_sqrt (t, t, GFC_RND_MODE);\n-\t  mpfr_add_ui (t, t, 1, GFC_RND_MODE);\n-\t  mpfr_div_ui (t, t, 2, GFC_RND_MODE);\n-\t  mpfr_sqrt (t, t, GFC_RND_MODE);\n-\t  mpfr_sqrt (s, ac, GFC_RND_MODE);\n-\t  mpfr_mul (w, s, t, GFC_RND_MODE);\n-\t}\n-      else\n-\t{\n-\t  mpfr_div (s, e->value.complex.r, e->value.complex.i, GFC_RND_MODE);\n-\t  mpfr_mul (t, s, s, GFC_RND_MODE);\n-\t  mpfr_add_ui (t, t, 1, GFC_RND_MODE);\n-\t  mpfr_sqrt (t, t, GFC_RND_MODE);\n-\t  mpfr_abs (s, s, GFC_RND_MODE);\n-\t  mpfr_add (t, t, s, GFC_RND_MODE);\n-\t  mpfr_div_ui (t, t, 2, GFC_RND_MODE);\n-\t  mpfr_sqrt (t, t, GFC_RND_MODE);\n-\t  mpfr_sqrt (s, ad, GFC_RND_MODE);\n-\t  mpfr_mul (w, s, t, GFC_RND_MODE);\n-\t}\n-\n-      if (mpfr_cmp_ui (w, 0) != 0 && mpfr_cmp_ui (e->value.complex.r, 0) >= 0)\n-\t{\n-\t  mpfr_mul_ui (t, w, 2, GFC_RND_MODE);\n-\t  mpfr_div (result->value.complex.i, e->value.complex.i, t, GFC_RND_MODE);\n-\t  mpfr_set (result->value.complex.r, w, GFC_RND_MODE);\n-\t}\n-      else if (mpfr_cmp_ui (w, 0) != 0\n-\t       && mpfr_cmp_ui (e->value.complex.r, 0) < 0\n-\t       && mpfr_cmp_ui (e->value.complex.i, 0) >= 0)\n-\t{\n-\t  mpfr_mul_ui (t, w, 2, GFC_RND_MODE);\n-\t  mpfr_div (result->value.complex.r, e->value.complex.i, t, GFC_RND_MODE);\n-\t  mpfr_set (result->value.complex.i, w, GFC_RND_MODE);\n-\t}\n-      else if (mpfr_cmp_ui (w, 0) != 0\n-\t       && mpfr_cmp_ui (e->value.complex.r, 0) < 0\n-\t       && mpfr_cmp_ui (e->value.complex.i, 0) < 0)\n-\t{\n-\t  mpfr_mul_ui (t, w, 2, GFC_RND_MODE);\n-\t  mpfr_div (result->value.complex.r, ad, t, GFC_RND_MODE);\n-\t  mpfr_neg (w, w, GFC_RND_MODE);\n-\t  mpfr_set (result->value.complex.i, w, GFC_RND_MODE);\n-\t}\n-      else\n-\tgfc_internal_error (\"invalid complex argument of SQRT at %L\",\n-\t\t\t    &e->where);\n-\n-      mpfr_clears (s, t, ac, ad, w, NULL);\n-    }\n-#endif\n       break;\n \n     default:\n@@ -5462,14 +5237,7 @@ gfc_simplify_tan (gfc_expr *x)\n   if (x->ts.type == BT_REAL)\n     mpfr_tan (result->value.real, x->value.real, GFC_RND_MODE);\n   else if (x->ts.type == BT_COMPLEX)\n-    {\n-#if HAVE_mpc\n-      mpc_tan (result->value.complex, x->value.complex, GFC_MPC_RND_MODE);\n-#else\n-      gfc_free_expr (result);\n-      return NULL;\n-#endif\n-    }\n+    mpc_tan (result->value.complex, x->value.complex, GFC_MPC_RND_MODE);\n   else\n     gcc_unreachable ();\n \n@@ -5490,14 +5258,7 @@ gfc_simplify_tanh (gfc_expr *x)\n   if (x->ts.type == BT_REAL)\n     mpfr_tanh (result->value.real, x->value.real, GFC_RND_MODE);\n   else if (x->ts.type == BT_COMPLEX)\n-    {\n-#if HAVE_mpc\n-      mpc_tanh (result->value.complex, x->value.complex, GFC_MPC_RND_MODE);\n-#else\n-      gfc_free_expr (result);\n-      return NULL;\n-#endif\n-    }\n+    mpc_tanh (result->value.complex, x->value.complex, GFC_MPC_RND_MODE);\n   else\n     gcc_unreachable ();\n "}, {"sha": "19b24c509edc3f98d863adf0065e2ea593099928", "filename": "gcc/fortran/target-memory.c", "status": "modified", "additions": 9, "deletions": 62, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0d92baf438995061f3c86a8b85c9b431573d986/gcc%2Ffortran%2Ftarget-memory.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0d92baf438995061f3c86a8b85c9b431573d986/gcc%2Ffortran%2Ftarget-memory.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftarget-memory.c?ref=d0d92baf438995061f3c86a8b85c9b431573d986", "patch": "@@ -164,28 +164,12 @@ encode_float (int kind, mpfr_t real, unsigned char *buffer, size_t buffer_size)\n \n \n static int\n-encode_complex (int kind,\n-#ifdef HAVE_mpc\n-\t\tmpc_t cmplx,\n-#else\n-\t\tmpfr_t real, mpfr_t imaginary,\n-#endif\n+encode_complex (int kind, mpc_t cmplx,\n \t\tunsigned char *buffer, size_t buffer_size)\n {\n   int size;\n-  size = encode_float (kind,\n-#ifdef HAVE_mpc\n-\t\t       mpc_realref (cmplx),\n-#else\n-\t\t       real,\n-#endif\n-\t\t       &buffer[0], buffer_size);\n-  size += encode_float (kind,\n-#ifdef HAVE_mpc\n-\t\t\tmpc_imagref (cmplx),\n-#else\n-\t\t\timaginary,\n-#endif\n+  size = encode_float (kind, mpc_realref (cmplx), &buffer[0], buffer_size);\n+  size += encode_float (kind, mpc_imagref (cmplx),\n \t\t\t&buffer[size], buffer_size - size);\n   return size;\n }\n@@ -283,13 +267,7 @@ gfc_target_encode_expr (gfc_expr *source, unsigned char *buffer,\n       return encode_float (source->ts.kind, source->value.real, buffer,\n \t\t\t   buffer_size);\n     case BT_COMPLEX:\n-      return encode_complex (source->ts.kind,\n-#ifdef HAVE_mpc\n-\t\t\t     source->value.complex,\n-#else\n-\t\t\t     source->value.complex.r,\n-\t\t\t     source->value.complex.i,\n-#endif\n+      return encode_complex (source->ts.kind, source->value.complex,\n \t\t\t     buffer, buffer_size);\n     case BT_LOGICAL:\n       return encode_logical (source->ts.kind, source->value.logical, buffer,\n@@ -391,28 +369,13 @@ gfc_interpret_float (int kind, unsigned char *buffer, size_t buffer_size,\n \n int\n gfc_interpret_complex (int kind, unsigned char *buffer, size_t buffer_size,\n-#ifdef HAVE_mpc\n-\t\t       mpc_t complex\n-#else\n-\t\t       mpfr_t real, mpfr_t imaginary\n-#endif\n-\t\t       )\n+\t\t       mpc_t complex)\n {\n   int size;\n   size = gfc_interpret_float (kind, &buffer[0], buffer_size,\n-#ifdef HAVE_mpc\n-\t\t\t      mpc_realref (complex)\n-#else\n-\t\t\t      real\n-#endif\n-\t\t\t      );\n+\t\t\t      mpc_realref (complex));\n   size += gfc_interpret_float (kind, &buffer[size], buffer_size - size,\n-#ifdef HAVE_mpc\n-\t\t\t       mpc_imagref (complex)\n-#else\n-\t\t\t       imaginary\n-#endif\n-\t\t\t       );\n+\t\t\t       mpc_imagref (complex));\n   return size;\n }\n \n@@ -559,13 +522,7 @@ gfc_target_interpret_expr (unsigned char *buffer, size_t buffer_size,\n     case BT_COMPLEX:\n       result->representation.length = \n         gfc_interpret_complex (result->ts.kind, buffer, buffer_size,\n-#ifdef HAVE_mpc\n-\t\t\t       result->value.complex\n-#else\n-\t\t\t       result->value.complex.r,\n-\t\t\t       result->value.complex.i\n-#endif\n-\t\t\t       );\n+\t\t\t       result->value.complex);\n       break;\n \n     case BT_LOGICAL:\n@@ -766,19 +723,9 @@ gfc_convert_boz (gfc_expr *expr, gfc_typespec *ts)\n     }\n   else\n     {\n-#ifdef HAVE_mpc\n       mpc_init2 (expr->value.complex, mpfr_get_default_prec());\n-#else\n-      mpfr_init (expr->value.complex.r);\n-      mpfr_init (expr->value.complex.i);\n-#endif\n       gfc_interpret_complex (ts->kind, buffer, buffer_size,\n-#ifdef HAVE_mpc\n-\t\t\t     expr->value.complex\n-#else\n-\t\t\t     expr->value.complex.r, expr->value.complex.i\n-#endif\n-\t\t\t     );\n+\t\t\t     expr->value.complex);\n     }\n   expr->is_boz = 0;  \n   expr->ts.type = ts->type;"}, {"sha": "603362638dd76c5ddd36df1555d4041b64e3de53", "filename": "gcc/fortran/target-memory.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0d92baf438995061f3c86a8b85c9b431573d986/gcc%2Ffortran%2Ftarget-memory.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0d92baf438995061f3c86a8b85c9b431573d986/gcc%2Ffortran%2Ftarget-memory.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftarget-memory.h?ref=d0d92baf438995061f3c86a8b85c9b431573d986", "patch": "@@ -39,11 +39,7 @@ int gfc_target_encode_expr (gfc_expr *, unsigned char *, size_t);\n \n int gfc_interpret_integer (int, unsigned char *, size_t, mpz_t);\n int gfc_interpret_float (int, unsigned char *, size_t, mpfr_t);\n-#ifdef HAVE_mpc\n int gfc_interpret_complex (int, unsigned char *, size_t, mpc_t);\n-#else\n-int gfc_interpret_complex (int, unsigned char *, size_t, mpfr_t, mpfr_t);\n-#endif\n int gfc_interpret_logical (int, unsigned char *, size_t, int *);\n int gfc_interpret_character (unsigned char *, size_t, gfc_expr *);\n int gfc_interpret_derived (unsigned char *, size_t, gfc_expr *);"}]}