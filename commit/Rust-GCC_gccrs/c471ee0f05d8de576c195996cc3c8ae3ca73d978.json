{"sha": "c471ee0f05d8de576c195996cc3c8ae3ca73d978", "node_id": "C_kwDOANBUbNoAKGM0NzFlZTBmMDVkOGRlNTc2YzE5NTk5NmNjM2M4YWUzY2E3M2Q5Nzg", "commit": {"author": {"name": "Richard Earnshaw", "email": "rearnsha@arm.com", "date": "2021-10-21T11:19:32Z"}, "committer": {"name": "Richard Earnshaw", "email": "rearnsha@arm.com", "date": "2022-01-20T11:14:43Z"}, "message": "arm: Consistently use crypto_mode attribute in crypto patterns\n\nA couple of patterns in the crypto support code were hard-coding the\nmode rather than using the iterators.  While not incorrect, it was\nslightly confusing, so adapt those patterns to the style of the rest\nof the file.\n\nAlso fix some white space issues.\n\ngcc/ChangeLog:\n\n\t* config/arm/crypto.md (crypto_<CYRPTO_AES:crypto_pattern>): Use\n\t<crypto_mode> rather than hard-coding the mode.\n\t(crypto_<CRYPTO_AESMC:crypto_pattern>): Fix white space.\n\t(crypto_<CRYPTO_AES:crypto_pattern>): Likewise.\n\t(*aarch32_crypto_aese_fused): Likewise.\n\t(*aarch32_crypto_aesd_fused): Likewise.\n\t(crypto_<CRYPTO_BINARY:crypto_pattern>): Likewise.\n\t(crypto_<CRYPTO_TERNARY:crypto_pattern>): Likewise.\n\t(crypto_sha1h_lb): Likewise.\n\t(crypto_vmullp64): Likewise.\n\t(crypto_<CRYPTO_SELECTING:crypto_pattern>): Likewise.\n\t(crypto_<CRYPTO_SELECTING:crypto_pattern>_lb): Likewise.", "tree": {"sha": "8107d59f8d5efc531eb3eb7eed8c8481956d3ac1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8107d59f8d5efc531eb3eb7eed8c8481956d3ac1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c471ee0f05d8de576c195996cc3c8ae3ca73d978", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c471ee0f05d8de576c195996cc3c8ae3ca73d978", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c471ee0f05d8de576c195996cc3c8ae3ca73d978", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c471ee0f05d8de576c195996cc3c8ae3ca73d978/comments", "author": null, "committer": null, "parents": [{"sha": "0042ca7b770aadd6ccf8f53109fdf955f44c18c3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0042ca7b770aadd6ccf8f53109fdf955f44c18c3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0042ca7b770aadd6ccf8f53109fdf955f44c18c3"}], "stats": {"total": 94, "additions": 47, "deletions": 47}, "files": [{"sha": "020dfba7dcfda838e40dd67e6fb6f6120a98c1ff", "filename": "gcc/config/arm/crypto.md", "status": "modified", "additions": 47, "deletions": 47, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c471ee0f05d8de576c195996cc3c8ae3ca73d978/gcc%2Fconfig%2Farm%2Fcrypto.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c471ee0f05d8de576c195996cc3c8ae3ca73d978/gcc%2Fconfig%2Farm%2Fcrypto.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fcrypto.md?ref=c471ee0f05d8de576c195996cc3c8ae3ca73d978", "patch": "@@ -22,20 +22,20 @@\n (define_insn \"crypto_<CRYPTO_AESMC:crypto_pattern>\"\n   [(set (match_operand:<crypto_mode> 0 \"register_operand\" \"=w\")\n \t(unspec:<crypto_mode>\n-\t\t[(match_operand:<crypto_mode> 1 \"register_operand\" \"w\")]\n+\t [(match_operand:<crypto_mode> 1 \"register_operand\" \"w\")]\n \t CRYPTO_AESMC))]\n   \"TARGET_CRYPTO\"\n   \"<crypto_pattern>.<crypto_size_sfx>\\\\t%q0, %q1\"\n   [(set_attr \"type\" \"<crypto_type>\")]\n )\n \n (define_insn \"crypto_<CRYPTO_AES:crypto_pattern>\"\n-  [(set (match_operand:V16QI 0 \"register_operand\" \"=w\")\n-\t(unspec:V16QI\n-\t\t[(xor:V16QI\n-\t\t     (match_operand:V16QI 1 \"register_operand\" \"%0\")\n-\t\t     (match_operand:V16QI 2 \"register_operand\" \"w\"))]\n-\tCRYPTO_AES))]\n+  [(set (match_operand:<crypto_mode> 0 \"register_operand\" \"=w\")\n+\t(unspec:<crypto_mode>\n+\t [(xor:<crypto_mode>\n+\t   (match_operand:<crypto_mode> 1 \"register_operand\" \"%0\")\n+\t   (match_operand:<crypto_mode> 2 \"register_operand\" \"w\"))]\n+\t CRYPTO_AES))]\n   \"TARGET_CRYPTO\"\n   \"<crypto_pattern>.<crypto_size_sfx>\\\\t%q0, %q2\"\n   [(set_attr \"type\" \"<crypto_type>\")]\n@@ -44,17 +44,16 @@\n ;; When AESE/AESMC fusion is enabled we really want to keep the two together\n ;; and enforce the register dependency without scheduling or register\n ;; allocation messing up the order or introducing moves inbetween.\n-;;  Mash the two together during combine.\n+;; Mash the two together during combine.\n \n (define_insn \"*aarch32_crypto_aese_fused\"\n   [(set (match_operand:V16QI 0 \"register_operand\" \"=w\")\n \t(unspec:V16QI\n-\t\t[(unspec:V16QI\n-\t\t    [(xor:V16QI\n-\t\t\t(match_operand:V16QI 1 \"register_operand\" \"%0\")\n-\t\t\t(match_operand:V16QI 2 \"register_operand\" \"w\"))]\n-\t\tUNSPEC_AESE)]\n-\tUNSPEC_AESMC))]\n+\t [(unspec:V16QI [(xor:V16QI\n+\t\t\t  (match_operand:V16QI 1 \"register_operand\" \"%0\")\n+\t\t\t  (match_operand:V16QI 2 \"register_operand\" \"w\"))]\n+\t   UNSPEC_AESE)]\n+\t UNSPEC_AESMC))]\n   \"TARGET_CRYPTO\n    && arm_fusion_enabled_p (tune_params::FUSE_AES_AESMC)\"\n   \"aese.8\\\\t%q0, %q2\\;aesmc.8\\\\t%q0, %q0\"\n@@ -65,17 +64,16 @@\n ;; When AESD/AESIMC fusion is enabled we really want to keep the two together\n ;; and enforce the register dependency without scheduling or register\n ;; allocation messing up the order or introducing moves inbetween.\n-;;  Mash the two together during combine.\n+;; Mash the two together during combine.\n \n (define_insn \"*aarch32_crypto_aesd_fused\"\n   [(set (match_operand:V16QI 0 \"register_operand\" \"=w\")\n \t(unspec:V16QI\n-\t\t[(unspec:V16QI\n-\t\t    [(xor:V16QI\n-\t\t\t(match_operand:V16QI 1 \"register_operand\" \"%0\")\n-\t\t\t(match_operand:V16QI 2 \"register_operand\" \"w\"))]\n-\t\tUNSPEC_AESD)]\n-\tUNSPEC_AESIMC))]\n+\t [(unspec:V16QI [(xor:V16QI\n+\t\t\t  (match_operand:V16QI 1 \"register_operand\" \"%0\")\n+\t\t\t  (match_operand:V16QI 2 \"register_operand\" \"w\"))]\n+\t   UNSPEC_AESD)]\n+\t UNSPEC_AESIMC))]\n   \"TARGET_CRYPTO\n    && arm_fusion_enabled_p (tune_params::FUSE_AES_AESMC)\"\n   \"aesd.8\\\\t%q0, %q2\\;aesimc.8\\\\t%q0, %q0\"\n@@ -86,28 +84,30 @@\n (define_insn \"crypto_<CRYPTO_BINARY:crypto_pattern>\"\n   [(set (match_operand:<crypto_mode> 0 \"register_operand\" \"=w\")\n \t(unspec:<crypto_mode>\n-\t\t[(match_operand:<crypto_mode> 1 \"register_operand\" \"0\")\n-\t\t(match_operand:<crypto_mode> 2 \"register_operand\" \"w\")]\n-\tCRYPTO_BINARY))]\n+\t [(match_operand:<crypto_mode> 1 \"register_operand\" \"0\")\n+\t  (match_operand:<crypto_mode> 2 \"register_operand\" \"w\")]\n+\t CRYPTO_BINARY))]\n   \"TARGET_CRYPTO\"\n   \"<crypto_pattern>.<crypto_size_sfx>\\\\t%q0, %q2\"\n   [(set_attr \"type\" \"<crypto_type>\")]\n )\n \n (define_insn \"crypto_<CRYPTO_TERNARY:crypto_pattern>\"\n   [(set (match_operand:<crypto_mode> 0 \"register_operand\" \"=w\")\n-        (unspec:<crypto_mode> [(match_operand:<crypto_mode> 1 \"register_operand\" \"0\")\n-                      (match_operand:<crypto_mode> 2 \"register_operand\" \"w\")\n-                      (match_operand:<crypto_mode> 3 \"register_operand\" \"w\")]\n-         CRYPTO_TERNARY))]\n+\t(unspec:<crypto_mode>\n+\t [(match_operand:<crypto_mode> 1 \"register_operand\" \"0\")\n+\t  (match_operand:<crypto_mode> 2 \"register_operand\" \"w\")\n+\t  (match_operand:<crypto_mode> 3 \"register_operand\" \"w\")]\n+\t CRYPTO_TERNARY))]\n   \"TARGET_CRYPTO\"\n   \"<crypto_pattern>.<crypto_size_sfx>\\\\t%q0, %q2, %q3\"\n   [(set_attr \"type\" \"<crypto_type>\")]\n )\n \n-/* The vec_select operation always selects index 0 from the lower V2SI subreg\n-   of the V4SI, adjusted for endianness. Required due to neon_vget_lane and\n-   neon_set_lane that change the element ordering in memory for big-endian.  */\n+;; The vec_select operation always selects index 0 from the lower V2SI\n+;; subreg of the V4SI, adjusted for endianness. Required due to\n+;; neon_vget_lane and neon_set_lane that change the element ordering\n+;; in memory for big-endian.\n \n (define_expand \"crypto_sha1h\"\n   [(set (match_operand:V4SI 0 \"register_operand\")\n@@ -122,20 +122,20 @@\n (define_insn \"crypto_sha1h_lb\"\n   [(set (match_operand:V4SI 0 \"register_operand\" \"=w\")\n \t(unspec:V4SI\n-\t  [(vec_select:SI\n+\t [(vec_select:SI\n \t   (match_operand:V4SI 1 \"register_operand\" \"w\")\n \t   (parallel [(match_operand:SI 2 \"immediate_operand\" \"i\")]))]\n-\tUNSPEC_SHA1H))]\n+\t UNSPEC_SHA1H))]\n   \"TARGET_CRYPTO && INTVAL (operands[2]) == NEON_ENDIAN_LANE_N (V2SImode, 0)\"\n   \"sha1h.32\\\\t%q0, %q1\"\n   [(set_attr \"type\" \"crypto_sha1_fast\")]\n )\n \n (define_insn \"crypto_vmullp64\"\n   [(set (match_operand:TI 0 \"register_operand\" \"=w\")\n-        (unspec:TI [(match_operand:DI 1 \"register_operand\" \"w\")\n-                    (match_operand:DI 2 \"register_operand\" \"w\")]\n-         UNSPEC_VMULLP64))]\n+\t(unspec:TI [(match_operand:DI 1 \"register_operand\" \"w\")\n+\t\t    (match_operand:DI 2 \"register_operand\" \"w\")]\n+\t UNSPEC_VMULLP64))]\n   \"TARGET_CRYPTO\"\n   \"vmull.p64\\\\t%q0, %P1, %P2\"\n   [(set_attr \"type\" \"crypto_pmull\")]\n@@ -148,10 +148,10 @@\n (define_expand \"crypto_<CRYPTO_SELECTING:crypto_pattern>\"\n   [(set (match_operand:V4SI 0 \"register_operand\")\n \t(unspec:<crypto_mode>\n-\t\t[(match_operand:<crypto_mode> 1 \"register_operand\")\n-\t\t (match_operand:<crypto_mode> 2 \"register_operand\")\n-\t\t (match_operand:<crypto_mode> 3 \"register_operand\")]\n-\tCRYPTO_SELECTING))]\n+\t [(match_operand:<crypto_mode> 1 \"register_operand\")\n+\t  (match_operand:<crypto_mode> 2 \"register_operand\")\n+\t  (match_operand:<crypto_mode> 3 \"register_operand\")]\n+\t CRYPTO_SELECTING))]\n   \"TARGET_CRYPTO\"\n {\n   rtx op4 = GEN_INT (NEON_ENDIAN_LANE_N (V2SImode, 0));\n@@ -162,13 +162,13 @@\n \n (define_insn \"crypto_<CRYPTO_SELECTING:crypto_pattern>_lb\"\n   [(set (match_operand:V4SI 0 \"register_operand\" \"=w\")\n-        (unspec:<crypto_mode>\n-                     [(match_operand:<crypto_mode> 1 \"register_operand\" \"0\")\n-                      (vec_select:SI\n-                        (match_operand:<crypto_mode> 2 \"register_operand\" \"w\")\n-                        (parallel [(match_operand:SI 4 \"immediate_operand\" \"i\")]))\n-                      (match_operand:<crypto_mode> 3 \"register_operand\" \"w\")]\n-         CRYPTO_SELECTING))]\n+\t(unspec:<crypto_mode>\n+\t [(match_operand:<crypto_mode> 1 \"register_operand\" \"0\")\n+\t  (vec_select:SI\n+\t   (match_operand:<crypto_mode> 2 \"register_operand\" \"w\")\n+\t   (parallel [(match_operand:SI 4 \"immediate_operand\" \"i\")]))\n+\t  (match_operand:<crypto_mode> 3 \"register_operand\" \"w\")]\n+\t CRYPTO_SELECTING))]\n   \"TARGET_CRYPTO && INTVAL (operands[4]) == NEON_ENDIAN_LANE_N (V2SImode, 0)\"\n   \"<crypto_pattern>.<crypto_size_sfx>\\\\t%q0, %q2, %q3\"\n   [(set_attr \"type\" \"<crypto_type>\")]"}]}