{"sha": "eef81eefcdc2a58111e50eb2162ea1f5becc8004", "node_id": "C_kwDOANBUbNoAKGVlZjgxZWVmY2RjMmE1ODExMWU1MGViMjE2MmVhMWY1YmVjYzgwMDQ", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2022-12-22T09:55:46Z"}, "committer": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2022-12-22T09:55:46Z"}, "message": "Zen4 tuning part 2\n\nAdds tunes needed for zen4 microarchitecture.  I added two new knobs.\nTARGET_AVX512_SPLIT_REGS which is used to specify that internally 512 vectors\nare split to 256 vectors.  This affects vectorization costs and reassociation\nwidth. It probably should also affect RTX costs however I doubt it is very useful\nsince RTL optimizers are usually not judging between 256 and 512 vectors.\n\nI also added X86_TUNE_AVOID_256FMA_CHAINS. Since fma has improved in zen4 this\nflag may not be a win except for very specific benchmarks. I am still doing some\nmore detailed testing here.\n\nOherwise I disabled gathers on zen4 for 2 parts nad 4 parts. We can open code them\nand since the latencies has only increased since zen3 opencoding is better than\nactual instrucction.  This shows at 4 tsvc benchmarks.\n\nI ended up setting AVX256_OPTIMAL. This is a compromise.  There are some tsvc\nbenchmarks that increase noticeably (up to 250%) however there are also few\nregressions.  Most of these can be solved by incrasing vec_perm cost in the\nvectorizer.  However this does not cure about 14% regression on x264 that is\nquite important.  Here we produce vectorized loops for avx512 that probably\nwould be faster if the loops in question had high enough iteration count.\nWe hit this problem with avx256 too: since the loop iterates few times, only\nprologues/epilogues are used.  Adding another round of prologue/epilogue\ncode does not make it better.\n\nFinally I enabled avx stores for constnat sized memcpy and memset.  I am not\nsure why this is an opt-in feature.  I think for most hardware this is a win.\n\ngcc/ChangeLog:\n\n2022-12-22  Jan Hubicka  <hubicka@ucw.cz>\n\n\t* config/i386/i386-expand.cc (ix86_expand_set_or_cpymem): Add\n\tTARGET_AVX512_SPLIT_REGS\n\t* config/i386/i386-options.cc (ix86_option_override_internal):\n\tHonor x86_TONE_AVOID_256FMA_CHAINS.\n\t* config/i386/i386.cc (ix86_vec_cost): Honor TARGET_AVX512_SPLIT_REGS.\n\t(ix86_reassociation_width): Likewise.\n\t* config/i386/i386.h (TARGET_AVX512_SPLIT_REGS): New tune.\n\t* config/i386/x86-tune.def (X86_TUNE_USE_GATHER_2PARTS): Disable\n\tfor znver4.\n\t(X86_TUNE_USE_GATHER_4PARTS): Likewise.\n\t(X86_TUNE_AVOID_256FMA_CHAINS): Set for znver4.\n\t(X86_TUNE_AVOID_512FMA_CHAINS): New utne; set for znver4.\n\t(X86_TUNE_AVX256_OPTIMAL): Add znver4.\n\t(X86_TUNE_AVX512_SPLIT_REGS): New tune.\n\t(X86_TUNE_AVX256_MOVE_BY_PIECES): Add znver1-3.\n\t(X86_TUNE_AVX256_STORE_BY_PIECES): Add znver1-3.\n\t(X86_TUNE_AVX512_MOVE_BY_PIECES): Add znver4.\n\t(X86_TUNE_AVX512_STORE_BY_PIECES): Add znver4.", "tree": {"sha": "b0d3c3b470571a449258d17627b29f189c46208a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b0d3c3b470571a449258d17627b29f189c46208a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/eef81eefcdc2a58111e50eb2162ea1f5becc8004", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eef81eefcdc2a58111e50eb2162ea1f5becc8004", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eef81eefcdc2a58111e50eb2162ea1f5becc8004", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eef81eefcdc2a58111e50eb2162ea1f5becc8004/comments", "author": null, "committer": null, "parents": [{"sha": "924033e39bd440caecbd4aaecf9f3fe917bffc0f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/924033e39bd440caecbd4aaecf9f3fe917bffc0f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/924033e39bd440caecbd4aaecf9f3fe917bffc0f"}], "stats": {"total": 40, "additions": 29, "deletions": 11}, "files": [{"sha": "0b887e74515f655fafe0c31e8a7badd58cf925a8", "filename": "gcc/config/i386/i386-expand.cc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eef81eefcdc2a58111e50eb2162ea1f5becc8004/gcc%2Fconfig%2Fi386%2Fi386-expand.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eef81eefcdc2a58111e50eb2162ea1f5becc8004/gcc%2Fconfig%2Fi386%2Fi386-expand.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-expand.cc?ref=eef81eefcdc2a58111e50eb2162ea1f5becc8004", "patch": "@@ -8661,6 +8661,8 @@ ix86_expand_set_or_cpymem (rtx dst, rtx src, rtx count_exp, rtx val_exp,\n \n       if (TARGET_AVX256_SPLIT_REGS && GET_MODE_BITSIZE (move_mode) > 128)\n \tmove_mode = TImode;\n+      if (TARGET_AVX512_SPLIT_REGS && GET_MODE_BITSIZE (move_mode) > 256)\n+\tmove_mode = OImode;\n \n       /* Find the corresponding vector mode with the same size as MOVE_MODE.\n \t MOVE_MODE is an integer mode at the moment (SI, DI, TI, etc.).  */"}, {"sha": "f73af2eb4771e419c45e8c76687b9a6a591b0be8", "filename": "gcc/config/i386/i386-options.cc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eef81eefcdc2a58111e50eb2162ea1f5becc8004/gcc%2Fconfig%2Fi386%2Fi386-options.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eef81eefcdc2a58111e50eb2162ea1f5becc8004/gcc%2Fconfig%2Fi386%2Fi386-options.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-options.cc?ref=eef81eefcdc2a58111e50eb2162ea1f5becc8004", "patch": "@@ -2983,6 +2983,8 @@ ix86_option_override_internal (bool main_args_p,\n     }\n \n   if (ix86_tune_features [X86_TUNE_AVOID_256FMA_CHAINS])\n+    SET_OPTION_IF_UNSET (opts, opts_set, param_avoid_fma_max_bits, 512);\n+  else if (ix86_tune_features [X86_TUNE_AVOID_256FMA_CHAINS])\n     SET_OPTION_IF_UNSET (opts, opts_set, param_avoid_fma_max_bits, 256);\n   else if (ix86_tune_features [X86_TUNE_AVOID_128FMA_CHAINS])\n     SET_OPTION_IF_UNSET (opts, opts_set, param_avoid_fma_max_bits, 128);"}, {"sha": "de978d19063e4aa7f25ed4b56b87b2551bb206e8", "filename": "gcc/config/i386/i386.cc", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eef81eefcdc2a58111e50eb2162ea1f5becc8004/gcc%2Fconfig%2Fi386%2Fi386.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eef81eefcdc2a58111e50eb2162ea1f5becc8004/gcc%2Fconfig%2Fi386%2Fi386.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.cc?ref=eef81eefcdc2a58111e50eb2162ea1f5becc8004", "patch": "@@ -20363,10 +20363,13 @@ ix86_vec_cost (machine_mode mode, int cost)\n \n   if (GET_MODE_BITSIZE (mode) == 128\n       && TARGET_SSE_SPLIT_REGS)\n-    return cost * 2;\n-  if (GET_MODE_BITSIZE (mode) > 128\n+    return cost * GET_MODE_BITSIZE (mode) / 64;\n+  else if (GET_MODE_BITSIZE (mode) > 128\n       && TARGET_AVX256_SPLIT_REGS)\n     return cost * GET_MODE_BITSIZE (mode) / 128;\n+  else if (GET_MODE_BITSIZE (mode) > 256\n+      && TARGET_AVX512_SPLIT_REGS)\n+    return cost * GET_MODE_BITSIZE (mode) / 256;\n   return cost;\n }\n \n@@ -23090,7 +23093,9 @@ ix86_reassociation_width (unsigned int op, machine_mode mode)\n \treturn 1;\n \n       /* Account for targets that splits wide vectors into multiple parts.  */\n-      if (TARGET_AVX256_SPLIT_REGS && GET_MODE_BITSIZE (mode) > 128)\n+      if (TARGET_AVX512_SPLIT_REGS && GET_MODE_BITSIZE (mode) > 256)\n+\tdiv = GET_MODE_BITSIZE (mode) / 256;\n+      else if (TARGET_AVX256_SPLIT_REGS && GET_MODE_BITSIZE (mode) > 128)\n \tdiv = GET_MODE_BITSIZE (mode) / 128;\n       else if (TARGET_SSE_SPLIT_REGS && GET_MODE_BITSIZE (mode) > 64)\n \tdiv = GET_MODE_BITSIZE (mode) / 64;"}, {"sha": "e6a603ed31a47501e500a587777aa68b10f58384", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eef81eefcdc2a58111e50eb2162ea1f5becc8004/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eef81eefcdc2a58111e50eb2162ea1f5becc8004/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=eef81eefcdc2a58111e50eb2162ea1f5becc8004", "patch": "@@ -419,6 +419,8 @@ extern unsigned char ix86_tune_features[X86_TUNE_LAST];\n \tix86_tune_features[X86_TUNE_SOFTWARE_PREFETCHING_BENEFICIAL]\n #define TARGET_AVX256_SPLIT_REGS \\\n \tix86_tune_features[X86_TUNE_AVX256_SPLIT_REGS]\n+#define TARGET_AVX512_SPLIT_REGS \\\n+\tix86_tune_features[X86_TUNE_AVX512_SPLIT_REGS]\n #define TARGET_GENERAL_REGS_SSE_SPILL \\\n \tix86_tune_features[X86_TUNE_GENERAL_REGS_SSE_SPILL]\n #define TARGET_AVOID_MEM_OPND_FOR_CMOVE \\"}, {"sha": "fae3b6504340c5c63eda19fd47a1bbdc98710351", "filename": "gcc/config/i386/x86-tune.def", "status": "modified", "additions": 15, "deletions": 8, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eef81eefcdc2a58111e50eb2162ea1f5becc8004/gcc%2Fconfig%2Fi386%2Fx86-tune.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eef81eefcdc2a58111e50eb2162ea1f5becc8004/gcc%2Fconfig%2Fi386%2Fx86-tune.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fx86-tune.def?ref=eef81eefcdc2a58111e50eb2162ea1f5becc8004", "patch": "@@ -481,12 +481,12 @@ DEF_TUNE (X86_TUNE_AVOID_4BYTE_PREFIXES, \"avoid_4byte_prefixes\",\n /* X86_TUNE_USE_GATHER_2PARTS: Use gather instructions for vectors with 2\n    elements.  */\n DEF_TUNE (X86_TUNE_USE_GATHER_2PARTS, \"use_gather_2parts\",\n-\t  ~(m_ZNVER1 | m_ZNVER2 | m_ZNVER3 | m_ALDERLAKE | m_CORE_ATOM | m_GENERIC))\n+\t  ~(m_ZNVER1 | m_ZNVER2 | m_ZNVER3 | m_ZNVER4 | m_ALDERLAKE | m_CORE_ATOM | m_GENERIC))\n \n /* X86_TUNE_USE_GATHER_4PARTS: Use gather instructions for vectors with 4\n    elements.  */\n DEF_TUNE (X86_TUNE_USE_GATHER_4PARTS, \"use_gather_4parts\",\n-\t  ~(m_ZNVER1 | m_ZNVER2 | m_ZNVER3 | m_ALDERLAKE | m_CORE_ATOM | m_GENERIC))\n+\t  ~(m_ZNVER1 | m_ZNVER2 | m_ZNVER3 | m_ZNVER4 | m_ALDERLAKE | m_CORE_ATOM | m_GENERIC))\n \n /* X86_TUNE_USE_GATHER: Use gather instructions for vectors with 8 or more\n    elements.  */\n@@ -499,9 +499,13 @@ DEF_TUNE (X86_TUNE_AVOID_128FMA_CHAINS, \"avoid_fma_chains\", m_ZNVER)\n \n /* X86_TUNE_AVOID_256FMA_CHAINS: Avoid creating loops with tight 256bit or\n    smaller FMA chain.  */\n-DEF_TUNE (X86_TUNE_AVOID_256FMA_CHAINS, \"avoid_fma256_chains\", m_ZNVER2 | m_ZNVER3\n+DEF_TUNE (X86_TUNE_AVOID_256FMA_CHAINS, \"avoid_fma256_chains\", m_ZNVER2 | m_ZNVER3 | m_ZNVER4\n \t  | m_ALDERLAKE | m_SAPPHIRERAPIDS | m_CORE_ATOM)\n \n+/* X86_TUNE_AVOID_512FMA_CHAINS: Avoid creating loops with tight 512bit or\n+   smaller FMA chain.  */\n+DEF_TUNE (X86_TUNE_AVOID_512FMA_CHAINS, \"avoid_fma512_chains\", m_ZNVER4)\n+\n /* X86_TUNE_V2DF_REDUCTION_PREFER_PHADDPD: Prefer haddpd\n    for v2df vector reduction.  */\n DEF_TUNE (X86_TUNE_V2DF_REDUCTION_PREFER_HADDPD,\n@@ -532,27 +536,30 @@ DEF_TUNE (X86_TUNE_AVX128_OPTIMAL, \"avx128_optimal\", m_BDVER | m_BTVER2\n \n /* X86_TUNE_AVX256_OPTIMAL: Use 256-bit AVX instructions instead of 512-bit AVX\n    instructions in the auto-vectorizer.  */\n-DEF_TUNE (X86_TUNE_AVX256_OPTIMAL, \"avx256_optimal\", m_CORE_AVX512)\n+DEF_TUNE (X86_TUNE_AVX256_OPTIMAL, \"avx256_optimal\", m_CORE_AVX512 | m_ZNVER4)\n+\n+/* X86_TUNE_AVX256_SPLIT_REGS: if true, AVX512 ops are split into two AVX256 ops.  */\n+DEF_TUNE (X86_TUNE_AVX512_SPLIT_REGS, \"avx512_split_regs\", m_ZNVER4)\n \n /* X86_TUNE_AVX256_MOVE_BY_PIECES: Optimize move_by_pieces with 256-bit\n    AVX instructions.  */\n DEF_TUNE (X86_TUNE_AVX256_MOVE_BY_PIECES, \"avx256_move_by_pieces\",\n-\t  m_ALDERLAKE | m_CORE_AVX2)\n+\t  m_ALDERLAKE | m_CORE_AVX2 | m_ZNVER1 | m_ZNVER2 | m_ZNVER3)\n \n /* X86_TUNE_AVX256_STORE_BY_PIECES: Optimize store_by_pieces with 256-bit\n    AVX instructions.  */\n DEF_TUNE (X86_TUNE_AVX256_STORE_BY_PIECES, \"avx256_store_by_pieces\",\n-\t  m_ALDERLAKE | m_CORE_AVX2)\n+\t  m_ALDERLAKE | m_CORE_AVX2 | m_ZNVER1 | m_ZNVER2 | m_ZNVER3)\n \n /* X86_TUNE_AVX512_MOVE_BY_PIECES: Optimize move_by_pieces with 512-bit\n    AVX instructions.  */\n DEF_TUNE (X86_TUNE_AVX512_MOVE_BY_PIECES, \"avx512_move_by_pieces\",\n-\t  m_SAPPHIRERAPIDS)\n+\t  m_SAPPHIRERAPIDS | m_ZNVER4)\n \n /* X86_TUNE_AVX512_STORE_BY_PIECES: Optimize store_by_pieces with 512-bit\n    AVX instructions.  */\n DEF_TUNE (X86_TUNE_AVX512_STORE_BY_PIECES, \"avx512_store_by_pieces\",\n-\t  m_SAPPHIRERAPIDS)\n+\t  m_SAPPHIRERAPIDS | m_ZNVER4)\n \n /*****************************************************************************/\n /*****************************************************************************/"}]}