{"sha": "05688bf703428871ef285958d1f4cf644017c4f1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDU2ODhiZjcwMzQyODg3MWVmMjg1OTU4ZDFmNGNmNjQ0MDE3YzRmMQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2012-05-03T19:55:16Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2012-05-03T19:55:16Z"}, "message": "dwarf2out.c (struct external_ref, [...]): New.\n\n\t* dwarf2out.c (struct external_ref, build_local_stub): New.\n\t(hash_external_ref, external_ref_eq, lookup_external_ref): New.\n\t(optimize_external_refs, optimize_external_refs_1): New.\n\t(change_AT_die_ref): New.\n\t(clone_as_declaration): Add DW_AT_signature when cloning a declaration.\n\t(build_abbrev_table): Take the external refs hashtable.\n\t(output_comp_unit): Get it from optimize_external_refs and pass it in.\n\nFrom-SVN: r187116", "tree": {"sha": "e8876d4b5b803b492b0d913c0c863dbd00026f2d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e8876d4b5b803b492b0d913c0c863dbd00026f2d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/05688bf703428871ef285958d1f4cf644017c4f1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/05688bf703428871ef285958d1f4cf644017c4f1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/05688bf703428871ef285958d1f4cf644017c4f1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/05688bf703428871ef285958d1f4cf644017c4f1/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f95f017c421cb6ae4e5adc7a8a51ab68df4b40ac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f95f017c421cb6ae4e5adc7a8a51ab68df4b40ac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f95f017c421cb6ae4e5adc7a8a51ab68df4b40ac"}], "stats": {"total": 221, "additions": 210, "deletions": 11}, "files": [{"sha": "a5a34e836944c84be13b4dc27be48b3024d4d8c8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05688bf703428871ef285958d1f4cf644017c4f1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05688bf703428871ef285958d1f4cf644017c4f1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=05688bf703428871ef285958d1f4cf644017c4f1", "patch": "@@ -1,3 +1,13 @@\n+2012-05-02  Jason Merrill  <jason@redhat.com>\n+\n+\t* dwarf2out.c (struct external_ref, build_local_stub): New.\n+\t(hash_external_ref, external_ref_eq, lookup_external_ref): New.\n+\t(optimize_external_refs, optimize_external_refs_1): New.\n+\t(change_AT_die_ref): New.\n+\t(clone_as_declaration): Add DW_AT_signature when cloning a declaration.\n+\t(build_abbrev_table): Take the external refs hashtable.\n+\t(output_comp_unit): Get it from optimize_external_refs and pass it in.\n+\n 2012-05-03  Jan Hubicka  <jh@suse.cz>\n \n \tPR middle-end/53093"}, {"sha": "80abb2e3ae12184f5664f487dcb9ad53f7200aee", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 189, "deletions": 10, "changes": 199, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05688bf703428871ef285958d1f4cf644017c4f1/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05688bf703428871ef285958d1f4cf644017c4f1/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=05688bf703428871ef285958d1f4cf644017c4f1", "patch": "@@ -2986,7 +2986,7 @@ static void htab_cu_del (void *);\n static int check_duplicate_cu (dw_die_ref, htab_t, unsigned *);\n static void record_comdat_symbol_number (dw_die_ref, htab_t, unsigned);\n static void add_sibling_attributes (dw_die_ref);\n-static void build_abbrev_table (dw_die_ref);\n+static void build_abbrev_table (dw_die_ref, htab_t);\n static void output_location_lists (dw_die_ref);\n static int constant_size (unsigned HOST_WIDE_INT);\n static unsigned long size_of_die (dw_die_ref);\n@@ -3718,6 +3718,16 @@ add_AT_die_ref (dw_die_ref die, enum dwarf_attribute attr_kind, dw_die_ref targ_\n   add_dwarf_attr (die, &attr);\n }\n \n+/* Change DIE reference REF to point to NEW_DIE instead.  */\n+\n+static inline void\n+change_AT_die_ref (dw_attr_ref ref, dw_die_ref new_die)\n+{\n+  gcc_assert (ref->dw_attr_val.val_class == dw_val_class_die_ref);\n+  ref->dw_attr_val.v.val_die_ref.die = new_die;\n+  ref->dw_attr_val.v.val_die_ref.external = 0;\n+}\n+\n /* Add an AT_specification attribute to a DIE, and also make the back\n    pointer from the specification to the definition.  */\n \n@@ -6277,7 +6287,12 @@ clone_as_declaration (dw_die_ref die)\n   /* If the DIE is a specification, just clone its declaration DIE.  */\n   decl = get_AT_ref (die, DW_AT_specification);\n   if (decl != NULL)\n-    return clone_die (decl);\n+    {\n+      clone = clone_die (decl);\n+      if (die->comdat_type_p)\n+\tadd_AT_die_ref (clone, DW_AT_signature, die);\n+      return clone;\n+    }\n \n   clone = ggc_alloc_cleared_die_node ();\n   clone->die_tag = die->die_tag;\n@@ -6816,28 +6831,182 @@ output_location_lists (dw_die_ref die)\n   FOR_EACH_CHILD (die, c, output_location_lists (c));\n }\n \n+/* We want to limit the number of external references, because they are\n+   larger than local references: a relocation takes multiple words, and\n+   even a sig8 reference is always eight bytes, whereas a local reference\n+   can be as small as one byte (though DW_FORM_ref is usually 4 in GCC).\n+   So if we encounter multiple external references to the same type DIE, we\n+   make a local typedef stub for it and redirect all references there.\n+\n+   This is the element of the hash table for keeping track of these\n+   references.  */\n+\n+struct external_ref\n+{\n+  dw_die_ref type;\n+  dw_die_ref stub;\n+  unsigned n_refs;\n+};\n+\n+/* Hash an external_ref.  */\n+\n+static hashval_t\n+hash_external_ref (const void *p)\n+{\n+  const struct external_ref *r = (const struct external_ref *)p;\n+  return htab_hash_pointer (r->type);\n+}\n+\n+/* Compare external_refs.  */\n+\n+static int\n+external_ref_eq (const void *p1, const void *p2)\n+{\n+  const struct external_ref *r1 = (const struct external_ref *)p1;\n+  const struct external_ref *r2 = (const struct external_ref *)p2;\n+  return r1->type == r2->type;\n+}\n+\n+/* Return a pointer to the external_ref for references to DIE.  */\n+\n+static struct external_ref *\n+lookup_external_ref (htab_t map, dw_die_ref die)\n+{\n+  struct external_ref ref, *ref_p;\n+  void ** slot;\n+\n+  ref.type = die;\n+  slot = htab_find_slot (map, &ref, INSERT);\n+  if (*slot != HTAB_EMPTY_ENTRY)\n+    return (struct external_ref *) *slot;\n+\n+  ref_p = XCNEW (struct external_ref);\n+  ref_p->type = die;\n+  *slot = ref_p;\n+  return ref_p;\n+}\n+\n+/* Subroutine of optimize_external_refs, below.\n+\n+   If we see a type skeleton, record it as our stub.  If we see external\n+   references, remember how many we've seen.  */\n+\n+static void\n+optimize_external_refs_1 (dw_die_ref die, htab_t map)\n+{\n+  dw_die_ref c;\n+  dw_attr_ref a;\n+  unsigned ix;\n+  struct external_ref *ref_p;\n+\n+  if (is_type_die (die)\n+      && (c = get_AT_ref (die, DW_AT_signature)))\n+    {\n+      /* This is a local skeleton; use it for local references.  */\n+      ref_p = lookup_external_ref (map, c);\n+      ref_p->stub = die;\n+    }\n+\n+  /* Scan the DIE references, and remember any that refer to DIEs from\n+     other CUs (i.e. those which are not marked).  */\n+  FOR_EACH_VEC_ELT (dw_attr_node, die->die_attr, ix, a)\n+    if (AT_class (a) == dw_val_class_die_ref\n+\t&& (c = AT_ref (a))->die_mark == 0\n+\t&& is_type_die (c))\n+      {\n+\tref_p = lookup_external_ref (map, c);\n+\tref_p->n_refs++;\n+      }\n+\n+  FOR_EACH_CHILD (die, c, optimize_external_refs_1 (c, map));\n+}\n+\n+/* htab_traverse callback function for optimize_external_refs, below.  SLOT\n+   points to an external_ref, DATA is the CU we're processing.  If we don't\n+   already have a local stub, and we have multiple refs, build a stub.  */\n+\n+static int\n+build_local_stub (void **slot, void *data)\n+{\n+  struct external_ref *ref_p = (struct external_ref *)*slot;\n+  dw_die_ref cu = (dw_die_ref) data;\n+  dw_die_ref type = ref_p->type;\n+  dw_die_ref stub = NULL;\n+\n+  if (ref_p->stub == NULL && ref_p->n_refs > 1)\n+    {\n+      if (!dwarf_strict)\n+\t{\n+\t  /* If we aren't being strict, use a typedef with no name\n+\t     to just forward to the real type.  In strict DWARF, a\n+\t     typedef must have a name.  */\n+\t  stub = new_die (DW_TAG_typedef, cu, NULL_TREE);\n+\t  add_AT_die_ref (stub, DW_AT_type, type);\n+\t}\n+      else if (type->comdat_type_p)\n+\t{\n+\t  /* If we refer to this type via sig8, we can use a simple\n+\t     declaration; this is larger than the typedef, but strictly\n+\t     correct.  */\n+\t  stub = new_die (type->die_tag, cu, NULL_TREE);\n+\t  add_AT_string (stub, DW_AT_name, get_AT_string (type, DW_AT_name));\n+\t  add_AT_flag (stub, DW_AT_declaration, 1);\n+\t  add_AT_die_ref (stub, DW_AT_signature, type);\n+\t}\n+\n+      if (stub)\n+\t{\n+\t  stub->die_mark++;\n+\t  ref_p->stub = stub;\n+\t}\n+    }\n+  return 1;\n+}\n+\n+/* DIE is a unit; look through all the DIE references to see if there are\n+   any external references to types, and if so, create local stubs for\n+   them which will be applied in build_abbrev_table.  This is useful because\n+   references to local DIEs are smaller.  */\n+\n+static htab_t\n+optimize_external_refs (dw_die_ref die)\n+{\n+  htab_t map = htab_create (10, hash_external_ref, external_ref_eq, free);\n+  optimize_external_refs_1 (die, map);\n+  htab_traverse (map, build_local_stub, die);\n+  return map;\n+}\n+\n /* The format of each DIE (and its attribute value pairs) is encoded in an\n    abbreviation table.  This routine builds the abbreviation table and assigns\n    a unique abbreviation id for each abbreviation entry.  The children of each\n    die are visited recursively.  */\n \n static void\n-build_abbrev_table (dw_die_ref die)\n+build_abbrev_table (dw_die_ref die, htab_t extern_map)\n {\n   unsigned long abbrev_id;\n   unsigned int n_alloc;\n   dw_die_ref c;\n   dw_attr_ref a;\n   unsigned ix;\n \n-  /* Scan the DIE references, and mark as external any that refer to\n-     DIEs from other CUs (i.e. those which are not marked).  */\n+  /* Scan the DIE references, and replace any that refer to\n+     DIEs from other CUs (i.e. those which are not marked) with\n+     the local stubs we built in optimize_external_refs.  */\n   FOR_EACH_VEC_ELT (dw_attr_node, die->die_attr, ix, a)\n     if (AT_class (a) == dw_val_class_die_ref\n-\t&& AT_ref (a)->die_mark == 0)\n+\t&& (c = AT_ref (a))->die_mark == 0)\n       {\n+\tstruct external_ref *ref_p;\n \tgcc_assert (AT_ref (a)->comdat_type_p || AT_ref (a)->die_id.die_symbol);\n-\tset_AT_ref_external (a, 1);\n+\n+\tref_p = lookup_external_ref (extern_map, c);\n+\tif (ref_p->stub && ref_p->stub != die)\n+\t  change_AT_die_ref (a, ref_p->stub);\n+\telse\n+\t  /* We aren't changing this reference, so mark it external.  */\n+\t  set_AT_ref_external (a, 1);\n       }\n \n   for (abbrev_id = 1; abbrev_id < abbrev_die_table_in_use; ++abbrev_id)\n@@ -6888,7 +7057,7 @@ build_abbrev_table (dw_die_ref die)\n     }\n \n   die->die_abbrev = abbrev_id;\n-  FOR_EACH_CHILD (die, c, build_abbrev_table (c));\n+  FOR_EACH_CHILD (die, c, build_abbrev_table (c, extern_map));\n }\n \f\n /* Return the power-of-two number of bytes necessary to represent VALUE.  */\n@@ -7811,6 +7980,7 @@ output_comp_unit (dw_die_ref die, int output_if_empty)\n {\n   const char *secname, *oldsym;\n   char *tmp;\n+  htab_t extern_map;\n \n   /* Unless we are outputting main CU, we may throw away empty ones.  */\n   if (!output_if_empty && die->die_child == NULL)\n@@ -7823,7 +7993,11 @@ output_comp_unit (dw_die_ref die, int output_if_empty)\n      this CU so we know which get local refs.  */\n   mark_dies (die);\n \n-  build_abbrev_table (die);\n+  extern_map = optimize_external_refs (die);\n+\n+  build_abbrev_table (die, extern_map);\n+\n+  htab_delete (extern_map);\n \n   /* Initialize the beginning DIE offset - and calculate sizes/offsets.  */\n   next_die_offset = DWARF_COMPILE_UNIT_HEADER_SIZE;\n@@ -7870,11 +8044,16 @@ output_comdat_type_unit (comdat_type_node *node)\n #if defined (OBJECT_FORMAT_ELF)\n   tree comdat_key;\n #endif\n+  htab_t extern_map;\n \n   /* First mark all the DIEs in this CU so we know which get local refs.  */\n   mark_dies (node->root_die);\n \n-  build_abbrev_table (node->root_die);\n+  extern_map = optimize_external_refs (node->root_die);\n+\n+  build_abbrev_table (node->root_die, extern_map);\n+\n+  htab_delete (extern_map);\n \n   /* Initialize the beginning DIE offset - and calculate sizes/offsets.  */\n   next_die_offset = DWARF_COMDAT_TYPE_UNIT_HEADER_SIZE;"}, {"sha": "0bdfa097a790ce21adcc62b7358c3ec733d66a50", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05688bf703428871ef285958d1f4cf644017c4f1/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05688bf703428871ef285958d1f4cf644017c4f1/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=05688bf703428871ef285958d1f4cf644017c4f1", "patch": "@@ -1,5 +1,7 @@\n 2012-05-03  Jason Merrill  <jason@redhat.com>\n \n+\t* g++.dg/debug/dwarf2/nested-3.C: Adjust pattern.\n+\n \t* gcc.dg/debug/dwarf2/dups-types.c: New.\n \t* gcc.dg/debug/dwarf2/dups-types.h: New.\n "}, {"sha": "42ee511151b0a192f50b2b79470740684dbd4c7a", "filename": "gcc/testsuite/g++.dg/debug/dwarf2/nested-3.C", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05688bf703428871ef285958d1f4cf644017c4f1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdebug%2Fdwarf2%2Fnested-3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05688bf703428871ef285958d1f4cf644017c4f1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdebug%2Fdwarf2%2Fnested-3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdebug%2Fdwarf2%2Fnested-3.C?ref=05688bf703428871ef285958d1f4cf644017c4f1", "patch": "@@ -37,6 +37,14 @@ main ()\n //\t.uleb128 0x9\t# (DIE (0x34) DW_TAG_class_type)\n //\t.long   .LASF0\t# DW_AT_name: \"Executor\"\n //\t\t\t# DW_AT_declaration\n+//      .byte   0xa0    # DW_AT_signature\n+//      .byte   0xfe\n+//      .byte   0xe6\n+//      .byte   0x7b\n+//      .byte   0x66\n+//      .byte   0xe9\n+//      .byte   0x38\n+//      .byte   0xf0\n //\t.uleb128 0x5\t# (DIE (0x39) DW_TAG_subprogram)\n //\t\t\t# DW_AT_external\n //\t.long   .LASF1\t# DW_AT_name: \"CurrentExecutor\"\n@@ -51,4 +59,4 @@ main ()\n //\n //     Hence the scary regexp:\n //\n-//     { dg-final { scan-assembler \"\\[^\\n\\r\\]*\\\\(DIE \\\\(0x(\\[0-9a-f\\]+)\\\\) DW_TAG_namespace\\\\)\\[\\n\\r\\]+\\[^\\n\\r\\]*\\\"thread\\[\\^\\n\\r]+\\[\\n\\r\\]+(\\[^\\n\\r\\]*\\[\\n\\r\\]+)+\\[^\\n\\r\\]*\\\\(DIE \\\\(0x(\\[0-9a-f\\]+)\\\\) DW_TAG_class_type\\\\)(\\[\\n\\r\\]+\\[^\\n\\r\\]*)+\\\"Executor\\[^\\n\\r\\]+\\[\\n\\r\\]+\\[^\\n\\r\\]*DW_AT_declaration\\[\\n\\r\\]+\\[^\\n\\r\\]*\\\\(DIE\\[^\\n\\r\\]*DW_TAG_subprogram\\\\)\\[\\n\\r\\]+(\\[^\\n\\r\\]*\\[\\n\\r\\]+)+\\[^\\n\\r\\]*\\\"CurrentExecutor\\[^\\n\\r\\]+\\[\\n\\r\\]+(\\[^\\n\\r\\]*\\[\\n\\r\\]+)+(\\[^\\n\\r\\]*\\[\\n\\r\\]+)+\\[^\\n\\r\\]*end of children of DIE 0x\\\\3\\[\\n\\r]+\\[^\\n\\r\\]*end of children of DIE 0x\\\\1\\[\\n\\r]+\" } }\n+//     { dg-final { scan-assembler \"\\[^\\n\\r\\]*\\\\(DIE \\\\(0x(\\[0-9a-f\\]+)\\\\) DW_TAG_namespace\\\\)\\[\\n\\r\\]+\\[^\\n\\r\\]*\\\"thread\\[\\^\\n\\r]+\\[\\n\\r\\]+(\\[^\\n\\r\\]*\\[\\n\\r\\]+)+\\[^\\n\\r\\]*\\\\(DIE \\\\(0x(\\[0-9a-f\\]+)\\\\) DW_TAG_class_type\\\\)(\\[\\n\\r\\]+\\[^\\n\\r\\]*)+\\\"Executor\\[^\\n\\r\\]+\\[\\n\\r\\]+\\[^\\n\\r\\]*DW_AT_declaration\\[\\n\\r\\]+\\[^\\n\\r\\]*DW_AT_signature\\[^#\\]*# \\\\(DIE\\[^\\n\\r\\]*DW_TAG_subprogram\\\\)\\[\\n\\r\\]+(\\[^\\n\\r\\]*\\[\\n\\r\\]+)+\\[^\\n\\r\\]*\\\"CurrentExecutor\\[^\\n\\r\\]+\\[\\n\\r\\]+(\\[^\\n\\r\\]*\\[\\n\\r\\]+)+(\\[^\\n\\r\\]*\\[\\n\\r\\]+)+\\[^\\n\\r\\]*end of children of DIE 0x\\\\3\\[\\n\\r]+\\[^\\n\\r\\]*end of children of DIE 0x\\\\1\\[\\n\\r]+\" } }"}]}