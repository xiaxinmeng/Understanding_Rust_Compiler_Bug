{"sha": "3d09ba95c150d9676f9a2585fb61315e86fa644a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2QwOWJhOTVjMTUwZDk2NzZmOWEyNTg1ZmI2MTMxNWU4NmZhNjQ0YQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2017-09-04T10:48:40Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-09-04T10:48:40Z"}, "message": "Add subreg_memory_offset helper functions\n\nThis patch adds routines for converting a SUBREG_BYTE offset into a\nmemory address offset.  The two only differ for paradoxical subregs,\nwhere SUBREG_BYTE is always 0 but the memory address offset can be\nnegative.\n\n2017-09-04  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* rtl.h (subreg_memory_offset): Declare.\n\t* emit-rtl.c (subreg_memory_offset): New function.\n\t* expmed.c (store_bit_field_1): Use it.\n\t* expr.c (undefined_operand_subword_p): Likewise.\n\t* simplify-rtx.c (simplify_subreg): Likewise.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r251644", "tree": {"sha": "6c37f118811f8cff123ef56870a20145fd74b472", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6c37f118811f8cff123ef56870a20145fd74b472"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3d09ba95c150d9676f9a2585fb61315e86fa644a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3d09ba95c150d9676f9a2585fb61315e86fa644a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3d09ba95c150d9676f9a2585fb61315e86fa644a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3d09ba95c150d9676f9a2585fb61315e86fa644a/comments", "author": null, "committer": null, "parents": [{"sha": "d8c40eff56f69877b33c697ded756d50fde90c27", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d8c40eff56f69877b33c697ded756d50fde90c27", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d8c40eff56f69877b33c697ded756d50fde90c27"}], "stats": {"total": 153, "additions": 58, "deletions": 95}, "files": [{"sha": "5d468c9493d98f260b3e1e7dcfb5301c67f6a21c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d09ba95c150d9676f9a2585fb61315e86fa644a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d09ba95c150d9676f9a2585fb61315e86fa644a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3d09ba95c150d9676f9a2585fb61315e86fa644a", "patch": "@@ -1,3 +1,13 @@\n+2017-09-04  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* rtl.h (subreg_memory_offset): Declare.\n+\t* emit-rtl.c (subreg_memory_offset): New function.\n+\t* expmed.c (store_bit_field_1): Use it.\n+\t* expr.c (undefined_operand_subword_p): Likewise.\n+\t* simplify-rtx.c (simplify_subreg): Likewise.\n+\n 2017-09-04  Alexander Monakov  <amonakov@ispras.ru>\n \n \tPR rtl-optimization/57448"}, {"sha": "ac6637d60a65bb36179d22d081a8ede81a4c9ac4", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d09ba95c150d9676f9a2585fb61315e86fa644a/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d09ba95c150d9676f9a2585fb61315e86fa644a/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=3d09ba95c150d9676f9a2585fb61315e86fa644a", "patch": "@@ -1005,6 +1005,33 @@ byte_lowpart_offset (machine_mode outer_mode,\n   else\n     return subreg_lowpart_offset (outer_mode, inner_mode);\n }\n+\n+/* Return the offset of (subreg:OUTER_MODE (mem:INNER_MODE X) OFFSET)\n+   from address X.  For paradoxical big-endian subregs this is a\n+   negative value, otherwise it's the same as OFFSET.  */\n+\n+int\n+subreg_memory_offset (machine_mode outer_mode, machine_mode inner_mode,\n+\t\t      unsigned int offset)\n+{\n+  if (paradoxical_subreg_p (outer_mode, inner_mode))\n+    {\n+      gcc_assert (offset == 0);\n+      return -subreg_lowpart_offset (inner_mode, outer_mode);\n+    }\n+  return offset;\n+}\n+\n+/* As above, but return the offset that existing subreg X would have\n+   if SUBREG_REG (X) were stored in memory.  The only significant thing\n+   about the current SUBREG_REG is its mode.  */\n+\n+int\n+subreg_memory_offset (const_rtx x)\n+{\n+  return subreg_memory_offset (GET_MODE (x), GET_MODE (SUBREG_REG (x)),\n+\t\t\t       SUBREG_BYTE (x));\n+}\n \f\n /* Generate a REG rtx for a new pseudo register of mode MODE.\n    This pseudo is assigned the next sequential register number.  */"}, {"sha": "f82bfc756274a6418c591a7cde7c5f97fdfdd4fb", "filename": "gcc/expmed.c", "status": "modified", "additions": 1, "deletions": 23, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d09ba95c150d9676f9a2585fb61315e86fa644a/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d09ba95c150d9676f9a2585fb61315e86fa644a/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=3d09ba95c150d9676f9a2585fb61315e86fa644a", "patch": "@@ -727,29 +727,7 @@ store_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n \n   while (GET_CODE (op0) == SUBREG)\n     {\n-      /* The following line once was done only if WORDS_BIG_ENDIAN,\n-\t but I think that is a mistake.  WORDS_BIG_ENDIAN is\n-\t meaningful at a much higher level; when structures are copied\n-\t between memory and regs, the higher-numbered regs\n-\t always get higher addresses.  */\n-      int inner_mode_size = GET_MODE_SIZE (GET_MODE (SUBREG_REG (op0)));\n-      int outer_mode_size = GET_MODE_SIZE (GET_MODE (op0));\n-      int byte_offset = 0;\n-\n-      /* Paradoxical subregs need special handling on big-endian machines.  */\n-      if (paradoxical_subreg_p (op0))\n-\t{\n-\t  int difference = inner_mode_size - outer_mode_size;\n-\n-\t  if (WORDS_BIG_ENDIAN)\n-\t    byte_offset += (difference / UNITS_PER_WORD) * UNITS_PER_WORD;\n-\t  if (BYTES_BIG_ENDIAN)\n-\t    byte_offset += difference % UNITS_PER_WORD;\n-\t}\n-      else\n-\tbyte_offset = SUBREG_BYTE (op0);\n-\n-      bitnum += byte_offset * BITS_PER_UNIT;\n+      bitnum += subreg_memory_offset (op0) * BITS_PER_UNIT;\n       op0 = SUBREG_REG (op0);\n     }\n "}, {"sha": "e912e683bb0aa0755918b1de61d520b246cb390b", "filename": "gcc/expr.c", "status": "modified", "additions": 4, "deletions": 22, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d09ba95c150d9676f9a2585fb61315e86fa644a/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d09ba95c150d9676f9a2585fb61315e86fa644a/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=3d09ba95c150d9676f9a2585fb61315e86fa644a", "patch": "@@ -3541,30 +3541,12 @@ emit_move_ccmode (machine_mode mode, rtx x, rtx y)\n static bool\n undefined_operand_subword_p (const_rtx op, int i)\n {\n-  machine_mode innermode, innermostmode;\n-  int offset;\n   if (GET_CODE (op) != SUBREG)\n     return false;\n-  innermode = GET_MODE (op);\n-  innermostmode = GET_MODE (SUBREG_REG (op));\n-  offset = i * UNITS_PER_WORD + SUBREG_BYTE (op);\n-  /* The SUBREG_BYTE represents offset, as if the value were stored in\n-     memory, except for a paradoxical subreg where we define\n-     SUBREG_BYTE to be 0; undo this exception as in\n-     simplify_subreg.  */\n-  if (SUBREG_BYTE (op) == 0\n-      && GET_MODE_SIZE (innermostmode) < GET_MODE_SIZE (innermode))\n-    {\n-      int difference = (GET_MODE_SIZE (innermostmode) - GET_MODE_SIZE (innermode));\n-      if (WORDS_BIG_ENDIAN)\n-\toffset += (difference / UNITS_PER_WORD) * UNITS_PER_WORD;\n-      if (BYTES_BIG_ENDIAN)\n-\toffset += difference % UNITS_PER_WORD;\n-    }\n-  if (offset >= GET_MODE_SIZE (innermostmode)\n-      || offset <= -GET_MODE_SIZE (word_mode))\n-    return true;\n-  return false;\n+  machine_mode innermostmode = GET_MODE (SUBREG_REG (op));\n+  HOST_WIDE_INT offset = i * UNITS_PER_WORD + subreg_memory_offset (op);\n+  return (offset >= GET_MODE_SIZE (innermostmode)\n+\t  || offset <= -UNITS_PER_WORD);\n }\n \n /* A subroutine of emit_move_insn_1.  Generate a move from Y into X."}, {"sha": "e1e664b32ff1366ae44b3a1299a3221636a248ba", "filename": "gcc/rtl.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d09ba95c150d9676f9a2585fb61315e86fa644a/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d09ba95c150d9676f9a2585fb61315e86fa644a/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=3d09ba95c150d9676f9a2585fb61315e86fa644a", "patch": "@@ -2888,6 +2888,8 @@ subreg_highpart_offset (machine_mode outermode, machine_mode innermode)\n }\n \n extern int byte_lowpart_offset (machine_mode, machine_mode);\n+extern int subreg_memory_offset (machine_mode, machine_mode, unsigned int);\n+extern int subreg_memory_offset (const_rtx);\n extern rtx make_safe_from (rtx, rtx);\n extern rtx convert_memory_address_addr_space_1 (scalar_int_mode, rtx,\n \t\t\t\t\t\taddr_space_t, bool, bool);"}, {"sha": "97a06528271cda6fa42b2aa62ed097f3ce0261ac", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 14, "deletions": 50, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d09ba95c150d9676f9a2585fb61315e86fa644a/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d09ba95c150d9676f9a2585fb61315e86fa644a/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=3d09ba95c150d9676f9a2585fb61315e86fa644a", "patch": "@@ -6069,34 +6069,18 @@ simplify_subreg (machine_mode outermode, rtx op,\n   if (GET_CODE (op) == SUBREG)\n     {\n       machine_mode innermostmode = GET_MODE (SUBREG_REG (op));\n-      int final_offset = byte + SUBREG_BYTE (op);\n       rtx newx;\n \n       if (outermode == innermostmode\n \t  && byte == 0 && SUBREG_BYTE (op) == 0)\n \treturn SUBREG_REG (op);\n \n-      /* The SUBREG_BYTE represents offset, as if the value were stored\n-\t in memory.  Irritating exception is paradoxical subreg, where\n-\t we define SUBREG_BYTE to be 0.  On big endian machines, this\n-\t value should be negative.  For a moment, undo this exception.  */\n-      if (byte == 0 && GET_MODE_SIZE (innermode) < GET_MODE_SIZE (outermode))\n-\t{\n-\t  int difference = (GET_MODE_SIZE (innermode) - GET_MODE_SIZE (outermode));\n-\t  if (WORDS_BIG_ENDIAN)\n-\t    final_offset += (difference / UNITS_PER_WORD) * UNITS_PER_WORD;\n-\t  if (BYTES_BIG_ENDIAN)\n-\t    final_offset += difference % UNITS_PER_WORD;\n-\t}\n-      if (SUBREG_BYTE (op) == 0\n-\t  && GET_MODE_SIZE (innermostmode) < GET_MODE_SIZE (innermode))\n-\t{\n-\t  int difference = (GET_MODE_SIZE (innermostmode) - GET_MODE_SIZE (innermode));\n-\t  if (WORDS_BIG_ENDIAN)\n-\t    final_offset += (difference / UNITS_PER_WORD) * UNITS_PER_WORD;\n-\t  if (BYTES_BIG_ENDIAN)\n-\t    final_offset += difference % UNITS_PER_WORD;\n-\t}\n+      /* Work out the memory offset of the final OUTERMODE value relative\n+\t to the inner value of OP.  */\n+      HOST_WIDE_INT mem_offset = subreg_memory_offset (outermode,\n+\t\t\t\t\t\t       innermode, byte);\n+      HOST_WIDE_INT op_mem_offset = subreg_memory_offset (op);\n+      HOST_WIDE_INT final_offset = mem_offset + op_mem_offset;\n \n       /* See whether resulting subreg will be paradoxical.  */\n       if (!paradoxical_subreg_p (outermode, innermostmode))\n@@ -6111,19 +6095,12 @@ simplify_subreg (machine_mode outermode, rtx op,\n \t}\n       else\n \t{\n-\t  int offset = 0;\n-\t  int difference = (GET_MODE_SIZE (innermostmode) - GET_MODE_SIZE (outermode));\n-\n-\t  /* In paradoxical subreg, see if we are still looking on lower part.\n-\t     If so, our SUBREG_BYTE will be 0.  */\n-\t  if (WORDS_BIG_ENDIAN)\n-\t    offset += (difference / UNITS_PER_WORD) * UNITS_PER_WORD;\n-\t  if (BYTES_BIG_ENDIAN)\n-\t    offset += difference % UNITS_PER_WORD;\n-\t  if (offset == final_offset)\n-\t    final_offset = 0;\n-\t  else\n+\t  HOST_WIDE_INT required_offset\n+\t    = subreg_memory_offset (outermode, innermostmode, 0);\n+\t  if (final_offset != required_offset)\n \t    return NULL_RTX;\n+\t  /* Paradoxical subregs always have byte offset 0.  */\n+\t  final_offset = 0;\n \t}\n \n       /* Recurse for further possible simplifications.  */\n@@ -6164,22 +6141,9 @@ simplify_subreg (machine_mode outermode, rtx op,\n       final_regno = simplify_subreg_regno (regno, innermode, byte, outermode);\n       if (HARD_REGISTER_NUM_P (final_regno))\n \t{\n-\t  rtx x;\n-\t  int final_offset = byte;\n-\n-\t  /* Adjust offset for paradoxical subregs.  */\n-\t  if (byte == 0\n-\t      && GET_MODE_SIZE (innermode) < GET_MODE_SIZE (outermode))\n-\t    {\n-\t      int difference = (GET_MODE_SIZE (innermode)\n-\t\t\t\t- GET_MODE_SIZE (outermode));\n-\t      if (WORDS_BIG_ENDIAN)\n-\t\tfinal_offset += (difference / UNITS_PER_WORD) * UNITS_PER_WORD;\n-\t      if (BYTES_BIG_ENDIAN)\n-\t\tfinal_offset += difference % UNITS_PER_WORD;\n-\t    }\n-\n-\t  x = gen_rtx_REG_offset (op, outermode, final_regno, final_offset);\n+\t  rtx x = gen_rtx_REG_offset (op, outermode, final_regno,\n+\t\t\t\t      subreg_memory_offset (outermode,\n+\t\t\t\t\t\t\t    innermode, byte));\n \n \t  /* Propagate original regno.  We don't have any way to specify\n \t     the offset inside original regno, so do so only for lowpart."}]}