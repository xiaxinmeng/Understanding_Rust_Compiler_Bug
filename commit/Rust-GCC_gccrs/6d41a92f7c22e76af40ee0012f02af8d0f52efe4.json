{"sha": "6d41a92f7c22e76af40ee0012f02af8d0f52efe4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmQ0MWE5MmY3YzIyZTc2YWY0MGVlMDAxMmYwMmFmOGQwZjUyZWZlNA==", "commit": {"author": {"name": "Olivier Hainque", "email": "hainque@act-europe.fr", "date": "2001-11-16T12:48:18Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2001-11-16T12:48:18Z"}, "message": "except.c: Support for catching a list of types with a single handler (struct eh_region):...\n\n        * except.c: Support for catching a list of types with a single handler\n        (struct eh_region): Change type and filter to lists for catch regions.\n        (mark_eh_region): Mark the filter list for GC also.\n        (expand_start_catch): Always build a list if argument not NULL and\n        register each type of the list through add_type_for_runtime.\n        (duplicate_eh_region_1): Change type into type_list for catch regions.\n        (assign_filter_values): Assign a filter to each type associated with a\n        catch region. Assign filter for NULL types in a unique entry in the\n        filter list.\n        (build_post_landing_pads): Emit compare and jump for each filter of\n        the list associated with a catch region.\n        (reachable_next_level): When the type thrown is known, stop the search\n        as soon as one type within a catch list matches. Also, a handler is\n        potentially reachable only if at least one of the types it catches\n        has not been previously caught.\n        (collect_one_action_chain): Retrieve the filter for a NULL type list\n        from the first filter list entry. For non NULL type lists, add an\n        action record for every filter assigned.\n        * except.h: Reflect changes in comment before expand_start_catch.\n\nFrom-SVN: r47087", "tree": {"sha": "c7687b57540a26d0d6218620d0cb0c8f6e8282d9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c7687b57540a26d0d6218620d0cb0c8f6e8282d9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6d41a92f7c22e76af40ee0012f02af8d0f52efe4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6d41a92f7c22e76af40ee0012f02af8d0f52efe4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6d41a92f7c22e76af40ee0012f02af8d0f52efe4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6d41a92f7c22e76af40ee0012f02af8d0f52efe4/comments", "author": null, "committer": null, "parents": [{"sha": "a8ca89dca83767049abf111dd2c659356a4c5880", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a8ca89dca83767049abf111dd2c659356a4c5880", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a8ca89dca83767049abf111dd2c659356a4c5880"}], "stats": {"total": 218, "additions": 178, "deletions": 40}, "files": [{"sha": "ba529ad867cc34114850eb0b7884a2d841278875", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d41a92f7c22e76af40ee0012f02af8d0f52efe4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d41a92f7c22e76af40ee0012f02af8d0f52efe4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6d41a92f7c22e76af40ee0012f02af8d0f52efe4", "patch": "@@ -1,3 +1,25 @@\n+2001-11-16  Olivier Hainque <hainque@act-europe.fr>\n+\n+        * except.c: Support for catching a list of types with a single handler\n+        (struct eh_region): Change type and filter to lists for catch regions.\n+        (mark_eh_region): Mark the filter list for GC also.\n+        (expand_start_catch): Always build a list if argument not NULL and\n+        register each type of the list through add_type_for_runtime.\n+        (duplicate_eh_region_1): Change type into type_list for catch regions.\n+        (assign_filter_values): Assign a filter to each type associated with a\n+        catch region. Assign filter for NULL types in a unique entry in the\n+        filter list.\n+        (build_post_landing_pads): Emit compare and jump for each filter of\n+        the list associated with a catch region.\n+        (reachable_next_level): When the type thrown is known, stop the search\n+        as soon as one type within a catch list matches. Also, a handler is\n+        potentially reachable only if at least one of the types it catches\n+        has not been previously caught.\n+        (collect_one_action_chain): Retrieve the filter for a NULL type list\n+        from the first filter list entry. For non NULL type lists, add an\n+        action record for every filter assigned.\n+        * except.h: Reflect changes in comment before expand_start_catch.\n+\n Fri Nov 16 07:12:51 2001  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n \t* expr.c (expand_expr, case ADDR_EXPR): Only copy for misaligned if"}, {"sha": "7ddb80734e89f17ef86be59649a593d02179af32", "filename": "gcc/except.c", "status": "modified", "additions": 154, "deletions": 39, "changes": 193, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d41a92f7c22e76af40ee0012f02af8d0f52efe4/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d41a92f7c22e76af40ee0012f02af8d0f52efe4/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=6d41a92f7c22e76af40ee0012f02af8d0f52efe4", "patch": "@@ -148,13 +148,13 @@ struct eh_region\n       rtx continue_label;\n     } try;\n \n-    /* The list through the catch handlers, the type object\n-       matched, and a pointer to the generated code.  */\n+    /* The list through the catch handlers, the list of type objects\n+       matched, and the list of associated filters.  */\n     struct {\n       struct eh_region *next_catch;\n       struct eh_region *prev_catch;\n-      tree type;\n-      int filter;\n+      tree type_list;\n+      tree filter_list;\n     } catch;\n \n     /* A tree_list of allowed types.  */\n@@ -485,7 +485,8 @@ mark_eh_region (region)\n       ggc_mark_rtx (region->u.try.continue_label);\n       break;\n     case ERT_CATCH:\n-      ggc_mark_tree (region->u.catch.type);\n+      ggc_mark_tree (region->u.catch.type_list);\n+      ggc_mark_tree (region->u.catch.filter_list);\n       break;\n     case ERT_ALLOWED_EXCEPTIONS:\n       ggc_mark_tree (region->u.allowed.type_list);\n@@ -767,26 +768,44 @@ expand_start_all_catch ()\n   emit_jump (region->u.try.continue_label);\n }\n \n-/* Begin a catch clause.  TYPE is the type caught, or null if this is\n-   a catch-all clause.  */\n+/* Begin a catch clause.  TYPE is the type caught, a list of such types, or\n+   null if this is a catch-all clause. Providing a type list enables to\n+   associate the catch region with potentially several exception types, which\n+   is useful e.g. for Ada. */\n \n void\n-expand_start_catch (type)\n-     tree type;\n+expand_start_catch (type_or_list)\n+     tree type_or_list;\n {\n   struct eh_region *t, *c, *l;\n+  tree type_list;\n \n   if (! doing_eh (0))\n     return;\n \n-  if (type)\n-    add_type_for_runtime (type);\n+  type_list = type_or_list;\n+\n+  if (type_or_list)\n+    {\n+      /* Ensure to always end up with a type list to normalize further\n+         processing, then register each type against the runtime types\n+         map.  */\n+      tree type_node;\n+\n+      if (TREE_CODE (type_or_list) != TREE_LIST)\n+        type_list = tree_cons (NULL_TREE, type_or_list, NULL_TREE);\n+\n+      type_node = type_list;\n+      for (; type_node; type_node = TREE_CHAIN (type_node))\n+        add_type_for_runtime (TREE_VALUE (type_node));\n+    }\n+\n   expand_eh_region_start ();\n \n   t = cfun->eh->try_region;\n   c = cfun->eh->cur_region;\n   c->type = ERT_CATCH;\n-  c->u.catch.type = type;\n+  c->u.catch.type_list = type_list;\n   c->label = gen_label_rtx ();\n \n   l = t->u.try.last_catch;\n@@ -1348,7 +1367,7 @@ duplicate_eh_region_1 (o, map)\n       break;\n \n     case ERT_CATCH:\n-      n->u.catch.type = o->u.catch.type;\n+      n->u.catch.type_list = o->u.catch.type_list;\n       break;\n \n     case ERT_ALLOWED_EXCEPTIONS:\n@@ -1693,7 +1712,36 @@ assign_filter_values ()\n       switch (r->type)\n \t{\n \tcase ERT_CATCH:\n-\t  r->u.catch.filter = add_ttypes_entry (ttypes, r->u.catch.type);\n+\t  /* Whatever type_list is (NULL or true list), we build a list\n+\t     of filters for the region.  */\n+\t  r->u.catch.filter_list = NULL_TREE;\n+\n+\t  if (r->u.catch.type_list != NULL)\n+\t    {\n+\t      /* Get a filter value for each of the types caught and store\n+\t\t them in the region's dedicated list.  */\n+\t      tree tp_node = r->u.catch.type_list;\n+\n+\t      for (;tp_node; tp_node = TREE_CHAIN (tp_node))\n+\t\t{\n+\t\t  int flt = add_ttypes_entry (ttypes, TREE_VALUE (tp_node));\n+\t\t  tree flt_node = build_int_2 (flt, 0);\n+\t\t  \n+\t\t  r->u.catch.filter_list \n+\t\t    = tree_cons (NULL_TREE, flt_node, r->u.catch.filter_list);\n+\t\t}\n+\t    }\n+\t  else\n+\t    {\n+\t      /* Get a filter value for the NULL list also since it will need\n+\t\t an action record anyway.  */\n+\t      int flt = add_ttypes_entry (ttypes, NULL);\n+\t      tree flt_node = build_int_2 (flt, 0);\n+\t      \n+\t      r->u.catch.filter_list \n+\t\t= tree_cons (NULL_TREE, flt_node, r->u.catch.filter_list);\n+\t    }\n+\t      \n \t  break;\n \n \tcase ERT_ALLOWED_EXCEPTIONS:\n@@ -1747,13 +1795,27 @@ build_post_landing_pads ()\n \t    for (c = region->u.try.catch; c ; c = c->u.catch.next_catch)\n \t      {\n \t\t/* ??? _Unwind_ForcedUnwind wants no match here.  */\n-\t\tif (c->u.catch.type == NULL)\n+\t\tif (c->u.catch.type_list == NULL)\n \t\t  emit_jump (c->label);\n \t\telse\n-\t\t  emit_cmp_and_jump_insns (cfun->eh->filter,\n-\t\t\t\t\t   GEN_INT (c->u.catch.filter),\n-\t\t\t\t\t   EQ, NULL_RTX, word_mode, 0,\n-\t\t\t\t\t   c->label);\n+\t\t  {\n+\t\t    /* Need for one cmp/jump per type caught. Each type\n+\t\t       list entry has a matching entry in the filter list\n+\t\t       (see assign_filter_values).  */\n+\t\t    tree tp_node = c->u.catch.type_list;\n+\t\t    tree flt_node = c->u.catch.filter_list;\n+\n+\t\t    for (; tp_node; )\n+\t\t      {\n+\t\t\temit_cmp_and_jump_insns\n+\t\t\t  (cfun->eh->filter,\n+\t\t\t   GEN_INT (tree_low_cst (TREE_VALUE (flt_node), 0)),\n+\t\t\t   EQ, NULL_RTX, word_mode, 0, c->label);\n+\n+\t\t\ttp_node = TREE_CHAIN (tp_node);\n+\t\t\tflt_node = TREE_CHAIN (flt_node);\n+\t\t      }\n+\t\t  }\n \t      }\n \t  }\n \n@@ -2568,22 +2630,28 @@ reachable_next_level (region, type_thrown, info)\n \t    /* A catch-all handler ends the search.  */\n \t    /* ??? _Unwind_ForcedUnwind will want outer cleanups\n \t       to be run as well.  */\n-\t    if (c->u.catch.type == NULL)\n+\t    if (c->u.catch.type_list == NULL)\n \t      {\n \t\tadd_reachable_handler (info, region, c);\n \t\treturn RNL_CAUGHT;\n \t      }\n \n \t    if (type_thrown)\n \t      {\n-\t\t/* If we have a type match, end the search.  */\n-\t\tif (c->u.catch.type == type_thrown\n-\t\t    || (lang_eh_type_covers\n-\t\t\t&& (*lang_eh_type_covers) (c->u.catch.type,\n-\t\t\t\t\t\t   type_thrown)))\n+\t\t/* If we have a at least one type match, end the search.  */\n+\t\ttree tp_node = c->u.catch.type_list;\n+\t\t\n+\t\tfor (; tp_node; tp_node = TREE_CHAIN (tp_node))\n \t\t  {\n-\t\t    add_reachable_handler (info, region, c);\n-\t\t    return RNL_CAUGHT;\n+\t\t    tree type = TREE_VALUE (tp_node);\n+\n+\t\t    if (type == type_thrown\n+\t\t\t|| (lang_eh_type_covers\n+\t\t\t    && (*lang_eh_type_covers) (type, type_thrown)))\n+\t\t      {\n+\t\t\tadd_reachable_handler (info, region, c);\n+\t\t\treturn RNL_CAUGHT;\n+\t\t      }\n \t\t  }\n \n \t\t/* If we have definitive information of a match failure,\n@@ -2592,19 +2660,49 @@ reachable_next_level (region, type_thrown, info)\n \t\t  return RNL_NOT_CAUGHT;\n \t      }\n \n+\t    /* At this point, we either don't know what type is thrown or\n+\t       don't have front-end assistance to help deciding if it is\n+\t       covered by one of the types in the list for this region.\n+\t    \n+\t       We'd then like to add this region to the list of reachable\n+\t       handlers since it is indeed potentially reachable based on the\n+\t       information we have. \n+\t       \n+\t       Actually, this handler is for sure not reachable if all the\n+\t       types it matches have already been caught. That is, it is only\n+\t       potentially reachable if at least one of the types it catches\n+\t       has not been previously caught.  */\n+\n \t    if (! info)\n \t      ret = RNL_MAYBE_CAUGHT;\n-\n-\t    /* A type must not have been previously caught.  */\n-\t    else if (! check_handled (info->types_caught, c->u.catch.type))\n+\t    else\n \t      {\n-\t\tadd_reachable_handler (info, region, c);\n-\t\tinfo->types_caught = tree_cons (NULL, c->u.catch.type,\n-\t\t\t\t\t\tinfo->types_caught);\n+\t\ttree tp_node = c->u.catch.type_list;\n+\t\tbool maybe_reachable = false;\n \n-\t\t/* ??? If the catch type is a base class of every allowed\n-\t\t   type, then we know we can stop the search.  */\n-\t\tret = RNL_MAYBE_CAUGHT;\n+\t\t/* Compute the potential reachability of this handler and\n+\t\t   update the list of types caught at the same time.  */\n+\t\tfor (; tp_node; tp_node = TREE_CHAIN (tp_node))\n+\t\t  {\n+\t\t    tree type = TREE_VALUE (tp_node);\n+\n+\t\t    if (! check_handled (info->types_caught, type))\n+\t\t      {\n+\t\t\tinfo->types_caught\n+\t\t\t  = tree_cons (NULL, type, info->types_caught);\n+\t\t\t\n+\t\t\tmaybe_reachable = true;\n+\t\t      }\n+\t\t  }\n+\t\t\n+\t\tif (maybe_reachable)\n+\t\t  {\n+\t\t    add_reachable_handler (info, region, c);\n+\t\t\n+\t\t    /* ??? If the catch type is a base class of every allowed\n+\t\t       type, then we know we can stop the search.  */\n+\t\t    ret = RNL_MAYBE_CAUGHT;\n+\t\t  }\n \t      }\n \t  }\n \n@@ -3144,10 +3242,21 @@ collect_one_action_chain (ar_hash, region)\n       next = -3;\n       for (c = region->u.try.last_catch; c ; c = c->u.catch.prev_catch)\n \t{\n-\t  if (c->u.catch.type == NULL)\n-\t    next = add_action_record (ar_hash, c->u.catch.filter, 0);\n+\t  if (c->u.catch.type_list == NULL)\n+\t    {\n+\t      /* Retrieve the filter from the head of the filter list\n+\t\t where we have stored it (see assign_filter_values).  */\n+\t      int filter \n+\t\t= TREE_INT_CST_LOW (TREE_VALUE (c->u.catch.filter_list));\n+\n+\t      next = add_action_record (ar_hash, filter, 0);\n+\t    }\n \t  else\n \t    {\n+\t      /* Once the outer search is done, trigger an action record for\n+                 each filter we have.  */\n+\t      tree flt_node;\n+\n \t      if (next == -3)\n \t\t{\n \t\t  next = collect_one_action_chain (ar_hash, region->outer);\n@@ -3162,7 +3271,13 @@ collect_one_action_chain (ar_hash, region)\n \t\t  else if (next <= 0)\n \t\t    next = add_action_record (ar_hash, 0, 0);\n \t\t}\n-\t      next = add_action_record (ar_hash, c->u.catch.filter, next);\n+\t      \n+\t      flt_node = c->u.catch.filter_list;\n+\t      for (; flt_node; flt_node = TREE_CHAIN (flt_node))\n+\t\t{\n+\t\t  int filter = TREE_INT_CST_LOW (TREE_VALUE (flt_node));\n+\t\t  next = add_action_record (ar_hash, filter, next);\n+\t\t}\n \t    }\n \t}\n       return next;"}, {"sha": "9510e9218a24090985c2d24a3afc54a1648643f0", "filename": "gcc/except.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d41a92f7c22e76af40ee0012f02af8d0f52efe4/gcc%2Fexcept.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d41a92f7c22e76af40ee0012f02af8d0f52efe4/gcc%2Fexcept.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.h?ref=6d41a92f7c22e76af40ee0012f02af8d0f52efe4", "patch": "@@ -61,7 +61,8 @@ extern void expand_eh_region_end_cleanup\tPARAMS ((tree));\n extern void expand_start_all_catch\t\tPARAMS ((void));\n \n /* Begin a catch clause.  TYPE is an object to be matched by the\n-   runtime, or null if this is a catch-all clause.  */\n+   runtime, or a list of such objects, or null if this is a catch-all\n+   clause.  */\n extern void expand_start_catch\t\t\tPARAMS ((tree));\n \n /* End a catch clause.  Control will resume after the try/catch block.  */"}]}