{"sha": "ceeedfc11a23c9223095ef4eace51f29fb036aa9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2VlZWRmYzExYTIzYzkyMjMwOTVlZjRlYWNlNTFmMjlmYjAzNmFhOQ==", "commit": {"author": {"name": "Neil Booth", "email": "neil@daikokuya.demon.co.uk", "date": "2002-06-02T19:37:34Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2002-06-02T19:37:34Z"}, "message": "c-common.c (c_common_init): Override cpplib's default warn_long_long setting.\n\n\t* c-common.c (c_common_init): Override cpplib's default\n\twarn_long_long setting.\n\t* c-lex.c (lex_number): Replace with interpret_integer,\n\tinterpret_float, narrowest_unsigned_type and\n\tnarrowest_signed_type, taking advantage of the new\n\tcpplib functionality.\n\t* cpperror.c (_cpp_begin_message): If a warning is turned\n\tinto an error, avoid printing \"warning:\".\n\t* cppexp.c (cpp_num_sign_extend): New.\n\t* cppinit.c: Update comment.\n\t* cpplib.h (cpp_num_sign_extend): New.\n\t* tree.h: Update comment.\ntestsuite:\n\t* gcc.dg/wtr-int-type-1.c, gcc.dg/wtr-suffix-1.c,\n\tgcc.dg/cpp/paste4.c, gcc.dg/cpp/sysmac2.c:\n\tUpdate for mofified diagnostics.\n\t* gcc.dg/c99-intconst-1.c: No longer fail.\n\nFrom-SVN: r54180", "tree": {"sha": "8660e3e7cbb02e35bffcba5d9bb626eaddc20430", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8660e3e7cbb02e35bffcba5d9bb626eaddc20430"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ceeedfc11a23c9223095ef4eace51f29fb036aa9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ceeedfc11a23c9223095ef4eace51f29fb036aa9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ceeedfc11a23c9223095ef4eace51f29fb036aa9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ceeedfc11a23c9223095ef4eace51f29fb036aa9/comments", "author": null, "committer": null, "parents": [{"sha": "27e511e0d56e4968abd1549b50b62071f22a224f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/27e511e0d56e4968abd1549b50b62071f22a224f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/27e511e0d56e4968abd1549b50b62071f22a224f"}], "stats": {"total": 758, "additions": 279, "deletions": 479}, "files": [{"sha": "69f0eab2f4c534d445e2d5d6b6e80df89099b4c8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ceeedfc11a23c9223095ef4eace51f29fb036aa9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ceeedfc11a23c9223095ef4eace51f29fb036aa9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ceeedfc11a23c9223095ef4eace51f29fb036aa9", "patch": "@@ -1,3 +1,18 @@\n+2002-06-02  Neil Booth  <neil@daikokuya.demon.co.uk>\n+\n+\t* c-common.c (c_common_init): Override cpplib's default\n+\twarn_long_long setting.\n+\t* c-lex.c (lex_number): Replace with interpret_integer,\n+\tinterpret_float, narrowest_unsigned_type and\n+\tnarrowest_signed_type, taking advantage of the new\n+\tcpplib functionality.\n+\t* cpperror.c (_cpp_begin_message): If a warning is turned\n+\tinto an error, avoid printing \"warning:\".\n+\t* cppexp.c (cpp_num_sign_extend): New.\n+\t* cppinit.c: Update comment.\n+\t* cpplib.h (cpp_num_sign_extend): New.\n+\t* tree.h: Update comment.\n+\n 2002-06-02  Gabriel Dos Reis  <gdr@codesourcery.com>\n \n \t* diagnostic.h (struct diagnostic_context):  Add new member"}, {"sha": "995fc0c3f8c1c61c022692101fbea8af07f6e3ae", "filename": "gcc/c-common.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ceeedfc11a23c9223095ef4eace51f29fb036aa9/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ceeedfc11a23c9223095ef4eace51f29fb036aa9/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=ceeedfc11a23c9223095ef4eace51f29fb036aa9", "patch": "@@ -4510,6 +4510,10 @@ c_common_init (filename)\n   options->warn_multichar = warn_multichar;\n   options->stdc_0_in_system_headers = STDC_0_IN_SYSTEM_HEADERS;\n \n+  /* We want -Wno-long-long to override -pedantic -std=non-c99\n+     whatever the ordering.  */\n+  options->warn_long_long = warn_long_long && !flag_isoc99 && pedantic;\n+\n   /* Register preprocessor built-ins before calls to\n      cpp_main_file.  */\n   cpp_get_callbacks (parse_in)->register_builtins = cb_register_builtins;"}, {"sha": "65c0f9f87556b70365df2799dd2f177703c8a956", "filename": "gcc/c-lex.c", "status": "modified", "additions": 199, "deletions": 455, "changes": 654, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ceeedfc11a23c9223095ef4eace51f29fb036aa9/gcc%2Fc-lex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ceeedfc11a23c9223095ef4eace51f29fb036aa9/gcc%2Fc-lex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-lex.c?ref=ceeedfc11a23c9223095ef4eace51f29fb036aa9", "patch": "@@ -73,7 +73,12 @@ int c_header_level;\t /* depth in C headers - C++ only */\n /* Nonzero tells yylex to ignore \\ in string constants.  */\n static int ignore_escape_flag;\n \n-static tree lex_number\t\tPARAMS ((const char *, unsigned int));\n+static tree interpret_integer\tPARAMS ((const cpp_token *, unsigned int));\n+static tree interpret_float\tPARAMS ((const cpp_token *, unsigned int));\n+static enum integer_type_kind\n+  narrowest_unsigned_type\tPARAMS ((tree, unsigned int));\n+static enum integer_type_kind\n+  narrowest_signed_type\t\tPARAMS ((tree, unsigned int));\n static tree lex_string\t\tPARAMS ((const unsigned char *, unsigned int,\n \t\t\t\t\t int));\n static tree lex_charconst\tPARAMS ((const cpp_token *));\n@@ -664,26 +669,6 @@ utf8_extend_token (c)\n   while (shift);\n }\n #endif\n-\n-#if 0\n-struct try_type\n-{\n-  tree *const node_var;\n-  const char unsigned_flag;\n-  const char long_flag;\n-  const char long_long_flag;\n-};\n-\n-struct try_type type_sequence[] =\n-{\n-  { &integer_type_node, 0, 0, 0},\n-  { &unsigned_type_node, 1, 0, 0},\n-  { &long_integer_type_node, 0, 1, 0},\n-  { &long_unsigned_type_node, 1, 1, 0},\n-  { &long_long_integer_type_node, 0, 1, 1},\n-  { &long_long_unsigned_type_node, 1, 1, 1}\n-};\n-#endif /* 0 */\n \f\n int\n c_lex (value)\n@@ -719,7 +704,27 @@ c_lex (value)\n       break;\n \n     case CPP_NUMBER:\n-      *value = lex_number ((const char *)tok->val.str.text, tok->val.str.len);\n+      {\n+\tunsigned int flags = cpp_classify_number (parse_in, tok);\n+\n+\tswitch (flags & CPP_N_CATEGORY)\n+\t  {\n+\t  case CPP_N_INVALID:\n+\t    /* cpplib has issued an error.  */\n+\t    break;\n+\n+\t  case CPP_N_INTEGER:\n+\t    *value = interpret_integer (tok, flags);\n+\t    break;\n+\n+\t  case CPP_N_FLOATING:\n+\t    *value = interpret_float (tok, flags);\n+\t    break;\n+\n+\t  default:\n+\t    abort ();\n+\t  }\n+      }\n       break;\n \n     case CPP_CHAR:\n@@ -745,469 +750,208 @@ c_lex (value)\n   return tok->type;\n }\n \n-#define ERROR(msgid) do { error(msgid); goto syntax_error; } while(0)\n-\n-static tree\n-lex_number (str, len)\n-     const char *str;\n-     unsigned int len;\n+/* Returns the narrowest C-visible unsigned type, starting with the\n+   minimum specified by FLAGS, that can fit VALUE, or itk_none if\n+   there isn't one.  */\n+static enum integer_type_kind\n+narrowest_unsigned_type (value, flags)\n+     tree value;\n+     unsigned int flags;\n {\n-  int base = 10;\n-  int count = 0;\n-  int largest_digit = 0;\n-  int numdigits = 0;\n-  int overflow = 0;\n-  int c;\n-  tree value;\n-  const char *p;\n-  enum anon1 { NOT_FLOAT = 0, AFTER_POINT, AFTER_EXPON } floatflag = NOT_FLOAT;\n-  \n-  /* We actually store only HOST_BITS_PER_CHAR bits in each part.\n-     The code below which fills the parts array assumes that a host\n-     int is at least twice as wide as a host char, and that \n-     HOST_BITS_PER_WIDE_INT is an even multiple of HOST_BITS_PER_CHAR.\n-     Two HOST_WIDE_INTs is the largest int literal we can store.\n-     In order to detect overflow below, the number of parts (TOTAL_PARTS)\n-     must be exactly the number of parts needed to hold the bits\n-     of two HOST_WIDE_INTs.  */\n-#define TOTAL_PARTS ((HOST_BITS_PER_WIDE_INT / HOST_BITS_PER_CHAR) * 2)\n-  unsigned int parts[TOTAL_PARTS];\n-  \n-  /* Optimize for most frequent case.  */\n-  if (len == 1)\n-    {\n-      if (*str == '0')\n-\treturn integer_zero_node;\n-      else if (*str == '1')\n-\treturn integer_one_node;\n-      else\n-\treturn build_int_2 (*str - '0', 0);\n-    }\n-\n-  for (count = 0; count < TOTAL_PARTS; count++)\n-    parts[count] = 0;\n-\n-  /* len is known to be >1 at this point.  */\n-  p = str;\n-\n-  if (len > 2 && str[0] == '0' && (str[1] == 'x' || str[1] == 'X'))\n-    {\n-      base = 16;\n-      p = str + 2;\n-    }\n-  /* The ISDIGIT check is so we are not confused by a suffix on 0.  */\n-  else if (str[0] == '0' && ISDIGIT (str[1]))\n-    {\n-      base = 8;\n-      p = str + 1;\n-    }\n-\n-  do\n-    {\n-      c = *p++;\n-\n-      if (c == '.')\n-\t{\n-\t  if (floatflag == AFTER_POINT)\n-\t    ERROR (\"too many decimal points in floating constant\");\n-\t  else if (floatflag == AFTER_EXPON)\n-\t    ERROR (\"decimal point in exponent - impossible!\");\n-\t  else\n-\t    floatflag = AFTER_POINT;\n-\n-\t  if (base == 8)\n-\t    base = 10;\n-\t}\n-      else if (c == '_')\n-\t/* Possible future extension: silently ignore _ in numbers,\n-\t   permitting cosmetic grouping - e.g. 0x8000_0000 == 0x80000000\n-\t   but somewhat easier to read.  Ada has this?  */\n-\tERROR (\"underscore in number\");\n-      else\n-\t{\n-\t  int n;\n-\t  /* It is not a decimal point.\n-\t     It should be a digit (perhaps a hex digit).  */\n-\n-\t  if (ISDIGIT (c)\n-\t      || (base == 16 && ISXDIGIT (c)))\n-\t    {\n-\t      n = hex_value (c);\n-\t    }\n-\t  else if (base <= 10 && (c == 'e' || c == 'E'))\n-\t    {\n-\t      base = 10;\n-\t      floatflag = AFTER_EXPON;\n-\t      break;\n-\t    }\n-\t  else if (base == 16 && (c == 'p' || c == 'P'))\n-\t    {\n-\t      floatflag = AFTER_EXPON;\n-\t      break;   /* start of exponent */\n-\t    }\n-\t  else\n-\t    {\n-\t      p--;\n-\t      break;  /* start of suffix */\n-\t    }\n-\n-\t  if (n >= largest_digit)\n-\t    largest_digit = n;\n-\t  numdigits++;\n-\n-\t  for (count = 0; count < TOTAL_PARTS; count++)\n-\t    {\n-\t      parts[count] *= base;\n-\t      if (count)\n-\t\t{\n-\t\t  parts[count]\n-\t\t    += (parts[count-1] >> HOST_BITS_PER_CHAR);\n-\t\t  parts[count-1]\n-\t\t    &= (1 << HOST_BITS_PER_CHAR) - 1;\n-\t\t}\n-\t      else\n-\t\tparts[0] += n;\n-\t    }\n-\n-\t  /* If the highest-order part overflows (gets larger than\n-\t     a host char will hold) then the whole number has \n-\t     overflowed.  Record this and truncate the highest-order\n-\t     part.  */\n-\t  if (parts[TOTAL_PARTS - 1] >> HOST_BITS_PER_CHAR)\n-\t    {\n-\t      overflow = 1;\n-\t      parts[TOTAL_PARTS - 1] &= (1 << HOST_BITS_PER_CHAR) - 1;\n-\t    }\n-\t}\n-    }\n-  while (p < str + len);\n-\n-  /* This can happen on input like `int i = 0x;' */\n-  if (numdigits == 0)\n-    ERROR (\"numeric constant with no digits\");\n-\n-  if (largest_digit >= base)\n-    ERROR (\"numeric constant contains digits beyond the radix\");\n-\n-  if (floatflag != NOT_FLOAT)\n-    {\n-      tree type;\n-      const char *typename;\n-      int imag, fflag, lflag;\n-      REAL_VALUE_TYPE real;\n-      char *copy;\n-\n-      if (base == 16 && floatflag != AFTER_EXPON)\n-\tERROR (\"hexadecimal floating constant has no exponent\");\n-\n-      /* Read explicit exponent if any, and put it in tokenbuf.  */\n-      if ((base == 10 && ((c == 'e') || (c == 'E')))\n-\t  || (base == 16 && (c == 'p' || c == 'P')))\n-\t{\n-\t  if (p < str + len)\n-\t    c = *p++;\n-\t  if (p < str + len && (c == '+' || c == '-'))\n-\t    c = *p++;\n-\t  /* Exponent is decimal, even if string is a hex float.  */\n-\t  if (! ISDIGIT (c))\n-\t    ERROR (\"floating constant exponent has no digits\");\n-\t  while (p < str + len && ISDIGIT (c))\n-\t    c = *p++;\n-\t  if (! ISDIGIT (c))\n-\t    p--;\n-\t}\n+  enum integer_type_kind itk;\n \n-      /* Copy the float constant now; we don't want any suffixes in the\n-\t string passed to parse_float.  */\n-      copy = alloca (p - str + 1);\n-      memcpy (copy, str, p - str);\n-      copy[p - str] = '\\0';\n+  if ((flags & CPP_N_WIDTH) == CPP_N_SMALL)\n+    itk = itk_unsigned_int;\n+  else if ((flags & CPP_N_WIDTH) == CPP_N_MEDIUM)\n+    itk = itk_unsigned_long;\n+  else\n+    itk = itk_unsigned_long_long;\n \n-      /* Now parse suffixes.  */\n-      fflag = lflag = imag = 0;\n-      while (p < str + len)\n-\tswitch (*p++)\n-\t  {\n-\t  case 'f': case 'F':\n-\t    if (fflag)\n-\t      ERROR (\"more than one 'f' suffix on floating constant\");\n-\t    else if (warn_traditional && !in_system_header\n-\t\t     && ! cpp_sys_macro_p (parse_in))\n-\t      warning (\"traditional C rejects the 'f' suffix\");\n-\n-\t    fflag = 1;\n-\t    break;\n+  /* int_fits_type_p must think the type of its first argument is\n+     wider than its second argument, or it won't do the proper check.  */\n+  TREE_TYPE (value) = widest_unsigned_literal_type_node;\n \n-\t  case 'l': case 'L':\n-\t    if (lflag)\n-\t      ERROR (\"more than one 'l' suffix on floating constant\");\n-\t    else if (warn_traditional && !in_system_header\n-\t\t     && ! cpp_sys_macro_p (parse_in))\n-\t      warning (\"traditional C rejects the 'l' suffix\");\n+  for (; itk < itk_none; itk += 2 /* skip unsigned types */)\n+    if (int_fits_type_p (value, integer_types[itk]))\n+      return itk;\n \n-\t    lflag = 1;\n-\t    break;\n+  return itk_none;\n+}\n \n-\t  case 'i': case 'I':\n-\t  case 'j': case 'J':\n-\t    if (imag)\n-\t      ERROR (\"more than one 'i' or 'j' suffix on floating constant\");\n-\t    else if (pedantic)\n-\t      pedwarn (\"ISO C forbids imaginary numeric constants\");\n-\t    imag = 1;\n-\t    break;\n+/* Ditto, but narrowest signed type.  */\n+static enum integer_type_kind\n+narrowest_signed_type (value, flags)\n+     tree value;\n+     unsigned int flags;\n+{\n+  enum integer_type_kind itk;\n \n-\t  default:\n-\t    ERROR (\"invalid suffix on floating constant\");\n-\t  }\n+  if ((flags & CPP_N_WIDTH) == CPP_N_SMALL)\n+    itk = itk_int;\n+  else if ((flags & CPP_N_WIDTH) == CPP_N_MEDIUM)\n+    itk = itk_long;\n+  else\n+    itk = itk_long_long;\n \n-      type = double_type_node;\n-      typename = \"double\";\n-\t\n-      if (fflag)\n-\t{\n-\t  if (lflag)\n-\t    ERROR (\"both 'f' and 'l' suffixes on floating constant\");\n+  /* int_fits_type_p must think the type of its first argument is\n+     wider than its second argument, or it won't do the proper check.  */\n+  TREE_TYPE (value) = widest_unsigned_literal_type_node;\n \n-\t  type = float_type_node;\n-\t  typename = \"float\";\n-\t}\n-      else if (lflag)\n-\t{\n-\t  type = long_double_type_node;\n-\t  typename = \"long double\";\n-\t}\n-      else if (flag_single_precision_constant)\n-\t{\n-\t  type = float_type_node;\n-\t  typename = \"float\";\n-\t}\n+  for (; itk < itk_none; itk += 2 /* skip signed types */)\n+    if (int_fits_type_p (value, integer_types[itk]))\n+      return itk;\n \n-      /* Warn about this only after we know we're not issuing an error.  */\n-      if (base == 16 && pedantic && !flag_isoc99)\n-\tpedwarn (\"hexadecimal floating constants are only valid in C99\");\n+  return itk_none;\n+}\n \n-      /* The second argument, machine_mode, of REAL_VALUE_ATOF\n-\t tells the desired precision of the binary result\n-\t of decimal-to-binary conversion.  */\n-      if (base == 16)\n-\treal = REAL_VALUE_HTOF (copy, TYPE_MODE (type));\n-      else\n-\treal = REAL_VALUE_ATOF (copy, TYPE_MODE (type));\n-\n-      /* A diagnostic is required here by some ISO C testsuites.\n-\t This is not pedwarn, because some people don't want\n-\t an error for this.  */\n-      if (REAL_VALUE_ISINF (real) && pedantic)\n-\twarning (\"floating point number exceeds range of 'double'\");\n-\n-      /* Create a node with determined type and value.  */\n-      if (imag)\n-\tvalue = build_complex (NULL_TREE, convert (type, integer_zero_node),\n-\t\t\t       build_real (type, real));\n-      else\n-\tvalue = build_real (type, real);\n-    }\n+/* Interpret TOKEN, an integer with FLAGS as classified by cpplib.  */\n+static tree\n+interpret_integer (token, flags)\n+     const cpp_token *token;\n+     unsigned int flags;\n+{\n+  tree value, type;\n+  enum integer_type_kind itk;\n+  cpp_num integer;\n+  cpp_options *options = cpp_get_options (parse_in);\n+\n+  integer = cpp_interpret_integer (parse_in, token, flags);\n+  integer = cpp_num_sign_extend (integer, options->precision);\n+  value = build_int_2_wide (integer.low, integer.high);\n+\n+  /* The type of a constant with a U suffix is straightforward.  */\n+  if (flags & CPP_N_UNSIGNED)\n+    itk = narrowest_unsigned_type (value, flags);\n   else\n     {\n-      tree trad_type, type;\n-      HOST_WIDE_INT high, low;\n-      int spec_unsigned = 0;\n-      int spec_long = 0;\n-      int spec_long_long = 0;\n-      int spec_imag = 0;\n-      int suffix_lu = 0;\n-      int warn = 0, i;\n-\n-      trad_type = type = NULL_TREE;\n-      while (p < str + len)\n+      /* The type of a potentially-signed integer constant varies\n+\t depending on the base it's in, the standard in use, and the\n+\t length suffixes.  */\n+      enum integer_type_kind itk_u = narrowest_unsigned_type (value, flags);\n+      enum integer_type_kind itk_s = narrowest_signed_type (value, flags);\n+\n+      /* In both C89 and C99, octal and hex constants may be signed or\n+\t unsigned, whichever fits tighter.  We do not warn about this\n+\t choice differing from the traditional choice, as the constant\n+\t is probably a bit pattern and either way will work.  */\n+      if ((flags & CPP_N_RADIX) != CPP_N_DECIMAL)\n+\titk = MIN (itk_u, itk_s);\n+      else\n \t{\n-\t  c = *p++;\n-\t  switch (c)\n+\t  /* In C99, decimal constants are always signed.\n+\t     In C89, decimal constants that don't fit in long have\n+\t     undefined behaviour; we try to make them unsigned long.\n+\t     In GCC's extended C89, that last is true of decimal\n+\t     constants that don't fit in long long, too.  */\n+\n+\t  itk = itk_s;\n+\t  if (itk_s > itk_u && itk_s > itk_long)\n \t    {\n-\t    case 'u': case 'U':\n-\t      if (spec_unsigned)\n-\t\terror (\"two 'u' suffixes on integer constant\");\n-\t      else if (warn_traditional && !in_system_header\n-\t\t       && ! cpp_sys_macro_p (parse_in))\n-\t\twarning (\"traditional C rejects the 'u' suffix\");\n-\n-\t      spec_unsigned = 1;\n-\t      if (spec_long)\n-\t\tsuffix_lu = 1;\n-\t      break;\n-\n-\t    case 'l': case 'L':\n-\t      if (spec_long)\n+\t      if (!flag_isoc99)\n \t\t{\n-\t\t  if (spec_long_long)\n-\t\t    error (\"three 'l' suffixes on integer constant\");\n-\t\t  else if (suffix_lu)\n-\t\t    error (\"'lul' is not a valid integer suffix\");\n-\t\t  else if (c != spec_long)\n-\t\t    error (\"'Ll' and 'lL' are not valid integer suffixes\");\n-\t\t  else if (pedantic && ! flag_isoc99\n-\t\t\t   && ! in_system_header && warn_long_long)\n-\t\t    pedwarn (\"ISO C89 forbids long long integer constants\");\n-\t\t  spec_long_long = 1;\n+\t\t  if (itk_u < itk_unsigned_long)\n+\t\t    itk_u = itk_unsigned_long;\n+\t\t  itk = itk_u;\n+\t\t  warning (\"this decimal constant is unsigned only in ISO C89\");\n \t\t}\n-\t      spec_long = c;\n-\t      break;\n-\n-\t    case 'i': case 'I': case 'j': case 'J':\n-\t      if (spec_imag)\n-\t\terror (\"more than one 'i' or 'j' suffix on integer constant\");\n-\t      else if (pedantic)\n-\t\tpedwarn (\"ISO C forbids imaginary numeric constants\");\n-\t      spec_imag = 1;\n-\t      break;\n-\n-\t    default:\n-\t      ERROR (\"invalid suffix on integer constant\");\n+\t      else if (warn_traditional)\n+\t\twarning (\"this decimal constant would be unsigned in ISO C89\");\n \t    }\n \t}\n+    }\n \n-      /* If the literal overflowed, pedwarn about it now.  */\n-      if (overflow)\n-\t{\n-\t  warn = 1;\n-\t  pedwarn (\"integer constant is too large for this configuration of the compiler - truncated to %d bits\", HOST_BITS_PER_WIDE_INT * 2);\n-\t}\n-\n-      /* This is simplified by the fact that our constant\n-\t is always positive.  */\n-\n-      high = low = 0;\n+  if (itk == itk_none)\n+    /* cpplib has already issued a warning for overflow.  */\n+    type = ((flags & CPP_N_UNSIGNED)\n+\t    ? widest_unsigned_literal_type_node\n+\t    : widest_integer_literal_type_node);\n+  else\n+    type = integer_types[itk];\n \n-      for (i = 0; i < HOST_BITS_PER_WIDE_INT / HOST_BITS_PER_CHAR; i++)\n-\t{\n-\t  high |= ((HOST_WIDE_INT) parts[i + (HOST_BITS_PER_WIDE_INT\n-\t\t\t\t\t      / HOST_BITS_PER_CHAR)]\n-\t\t   << (i * HOST_BITS_PER_CHAR));\n-\t  low |= (HOST_WIDE_INT) parts[i] << (i * HOST_BITS_PER_CHAR);\n-\t}\n+  if (itk > itk_unsigned_long\n+      && (flags & CPP_N_WIDTH) != CPP_N_LARGE\n+      && ! in_system_header && ! flag_isoc99)\n+    pedwarn (\"integer constant is too large for \\\"%s\\\" type\",\n+\t     (flags & CPP_N_UNSIGNED) ? \"unsigned long\" : \"long\");\n \n-      value = build_int_2 (low, high);\n-      TREE_TYPE (value) = long_long_unsigned_type_node;\n+  TREE_TYPE (value) = type;\n \n-      /* If warn_traditional, calculate both the ISO type and the\n-\t traditional type, then see if they disagree.  */\n-      if (warn_traditional)\n-\t{\n-\t  /* Traditionally, any constant is signed; but if unsigned is\n-\t     specified explicitly, obey that.  Use the smallest size\n-\t     with the right number of bits, except for one special\n-\t     case with decimal constants.  */\n-\t  if (! spec_long && base != 10\n-\t      && int_fits_type_p (value, unsigned_type_node))\n-\t    trad_type = spec_unsigned ? unsigned_type_node : integer_type_node;\n-\t  /* A decimal constant must be long if it does not fit in\n-\t     type int.  I think this is independent of whether the\n-\t     constant is signed.  */\n-\t  else if (! spec_long && base == 10\n-\t\t   && int_fits_type_p (value, integer_type_node))\n-\t    trad_type = spec_unsigned ? unsigned_type_node : integer_type_node;\n-\t  else if (! spec_long_long)\n-\t    trad_type = (spec_unsigned\n-\t\t\t ? long_unsigned_type_node\n-\t\t\t : long_integer_type_node);\n-\t  else if (int_fits_type_p (value,\n-\t\t\t\t    spec_unsigned \n-\t\t\t\t    ? long_long_unsigned_type_node\n-\t\t\t\t    : long_long_integer_type_node)) \n-\t    trad_type = (spec_unsigned\n-\t\t\t ? long_long_unsigned_type_node\n-\t\t\t : long_long_integer_type_node);\n-\t  else\n-\t    trad_type = (spec_unsigned\n-\t\t\t ? widest_unsigned_literal_type_node\n-\t\t\t : widest_integer_literal_type_node);\n-\t}\n-\t\n-\t/* Calculate the ISO type.  */\n-\tif (! spec_long && ! spec_unsigned\n-\t    && int_fits_type_p (value, integer_type_node))\n-\t  type = integer_type_node;\n-\telse if (! spec_long && (base != 10 || spec_unsigned)\n-\t\t && int_fits_type_p (value, unsigned_type_node))\n-\t  type = unsigned_type_node;\n-\telse if (! spec_unsigned && !spec_long_long\n-\t\t && int_fits_type_p (value, long_integer_type_node))\n-\t  type = long_integer_type_node;\n-\telse if (! spec_long_long\n-\t\t && int_fits_type_p (value, long_unsigned_type_node))\n-\t  type = long_unsigned_type_node;\n-\telse if (! spec_unsigned\n-\t\t && int_fits_type_p (value, long_long_integer_type_node))\n-\t  type = long_long_integer_type_node;\n-\telse if (int_fits_type_p (value, long_long_unsigned_type_node))\n-\t  type = long_long_unsigned_type_node;\n-\telse if (! spec_unsigned\n-\t\t && int_fits_type_p (value, widest_integer_literal_type_node))\n-\t  type = widest_integer_literal_type_node;\n-\telse\n-\t  type = widest_unsigned_literal_type_node;\n-\n-      /* We assume that constants specified in a non-decimal\n-\t base are bit patterns, and that the programmer really\n-\t meant what they wrote.  */\n-      if (warn_traditional && !in_system_header\n-\t  && base == 10 && trad_type != type)\n-\t{\n-\t  if (TYPE_PRECISION (trad_type) != TYPE_PRECISION (type))\n-\t    warning (\"width of integer constant is different in traditional C\");\n-\t  else if (TREE_UNSIGNED (trad_type) != TREE_UNSIGNED (type))\n-\t    warning (\"integer constant is unsigned in ISO C, signed in traditional C\");\n-\t  else\n-\t    warning (\"width of integer constant may change on other systems in traditional C\");\n-\t}\n+  /* Convert imaginary to a complex type.  */\n+  if (flags & CPP_N_IMAGINARY)\n+    value = build_complex (NULL_TREE, convert (type, integer_zero_node), value);\n \n-      if (pedantic && (flag_isoc99 || !spec_long_long)\n-\t  && !warn\n-\t  && ((flag_isoc99\n-\t       ? TYPE_PRECISION (long_long_integer_type_node)\n-\t       : TYPE_PRECISION (long_integer_type_node)) < TYPE_PRECISION (type)))\n-\t{\n-\t  warn = 1;\n-\t  pedwarn (\"integer constant larger than the maximum value of %s\",\n-\t\t   (flag_isoc99\n-\t\t    ? (TREE_UNSIGNED (type)\n-\t\t       ? _(\"an unsigned long long int\")\n-\t\t       : _(\"a long long int\"))\n-\t\t    : _(\"an unsigned long int\")));\n-\t}\n+  return value;\n+}\n \n-      if (base == 10 && ! spec_unsigned && TREE_UNSIGNED (type))\n-\twarning (\"decimal constant is so large that it is unsigned\");\n+/* Interpret TOKEN, a floating point number with FLAGS as classified\n+   by cpplib.  */\n+static tree\n+interpret_float (token, flags)\n+     const cpp_token *token;\n+     unsigned int flags;\n+{\n+  tree type;\n+  tree value;\n+  REAL_VALUE_TYPE real;\n+  char *copy;\n+  size_t copylen;\n+  const char *typename;\n \n-      if (spec_imag)\n-\t{\n-\t  if (TYPE_PRECISION (type)\n-\t      <= TYPE_PRECISION (integer_type_node))\n-\t    value = build_complex (NULL_TREE, integer_zero_node,\n-\t\t\t\t   convert (integer_type_node, value));\n-\t  else\n-\t    ERROR (\"complex integer constant is too wide for 'complex int'\");\n-\t}\n-      else\n-\tTREE_TYPE (value) = type;\n+  /* FIXME: make %T work in error/warning, then we don't need typename.  */\n+  if ((flags & CPP_N_WIDTH) == CPP_N_LARGE)\n+    {\n+      type = long_double_type_node;\n+      typename = \"long double\";\n+    }\n+  else if ((flags & CPP_N_WIDTH) == CPP_N_SMALL\n+\t   || flag_single_precision_constant)\n+    {\n+      type = float_type_node;\n+      typename = \"float\";\n+    }\n+  else\n+    {\n+      type = double_type_node;\n+      typename = \"double\";\n+    }\n \n-      /* If it's still an integer (not a complex), and it doesn't\n-\t fit in the type we choose for it, then pedwarn.  */\n+  /* Copy the constant to a nul-terminated buffer.  If the constant\n+     has any suffixes, cut them off; REAL_VALUE_ATOF/ REAL_VALUE_HTOF\n+     can't handle them.  */\n+  copylen = token->val.str.len;\n+  if ((flags & CPP_N_WIDTH) != CPP_N_MEDIUM)\n+    /* Must be an F or L suffix.  */\n+    copylen--;\n+  if (flags & CPP_N_IMAGINARY)\n+    /* I or J suffix.  */\n+    copylen--;\n+\n+  copy = alloca (copylen + 1);\n+  memcpy (copy, token->val.str.text, copylen);\n+  copy[copylen] = '\\0';\n+\n+  /* The second argument, machine_mode, of REAL_VALUE_ATOF tells the\n+     desired precision of the binary result of decimal-to-binary\n+     conversion.  */\n+  if (flags & CPP_N_HEX)\n+    real = REAL_VALUE_HTOF (copy, TYPE_MODE (type));\n+  else\n+    real = REAL_VALUE_ATOF (copy, TYPE_MODE (type));\n \n-      if (! warn\n-\t  && TREE_CODE (TREE_TYPE (value)) == INTEGER_TYPE\n-\t  && ! int_fits_type_p (value, TREE_TYPE (value)))\n-\tpedwarn (\"integer constant is larger than the maximum value for its type\");\n-    }\n+  /* A diagnostic is required for \"soft\" overflow by some ISO C\n+     testsuites.  This is not pedwarn, because some people don't want\n+     an error for this.\n+     ??? That's a dubious reason... is this a mandatory diagnostic or\n+     isn't it?   -- zw, 2001-08-21.  */\n+  if (REAL_VALUE_ISINF (real) && pedantic)\n+    warning (\"floating constant exceeds range of \\\"%s\\\"\", typename);\n \n-  if (p < str + len)\n-    error (\"missing white space after number '%.*s'\", (int) (p - str), str);\n+  /* Create a node with determined type and value.  */\n+  value = build_real (type, real);\n+  if (flags & CPP_N_IMAGINARY)\n+    value = build_complex (NULL_TREE, convert (type, integer_zero_node), value);\n \n   return value;\n-\n- syntax_error:\n-  return integer_zero_node;\n }\n \n static tree\n@@ -1321,7 +1065,7 @@ lex_charconst (token)\n   tree type, value;\n   unsigned int chars_seen;\n   int unsignedp;\n- \n+\n   result = cpp_interpret_charconst (parse_in, token,\n  \t\t\t\t    &chars_seen, &unsignedp);\n "}, {"sha": "6603a20710c4d4d3edef8f97185b3817f8d4e6df", "filename": "gcc/cpperror.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ceeedfc11a23c9223095ef4eace51f29fb036aa9/gcc%2Fcpperror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ceeedfc11a23c9223095ef4eace51f29fb036aa9/gcc%2Fcpperror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpperror.c?ref=ceeedfc11a23c9223095ef4eace51f29fb036aa9", "patch": "@@ -92,6 +92,7 @@ _cpp_begin_message (pfile, code, line, column)\n \t{\n \t  if (CPP_OPTION (pfile, inhibit_errors))\n \t    return 0;\n+\t  level = DL_ERROR;\n \t  pfile->errors++;\n \t}\n       else if (CPP_OPTION (pfile, inhibit_warnings))"}, {"sha": "e5f464eaa0008177f46a8c8b3a2b2bb39cbf04f6", "filename": "gcc/cppexp.c", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ceeedfc11a23c9223095ef4eace51f29fb036aa9/gcc%2Fcppexp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ceeedfc11a23c9223095ef4eace51f29fb036aa9/gcc%2Fcppexp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppexp.c?ref=ceeedfc11a23c9223095ef4eace51f29fb036aa9", "patch": "@@ -995,6 +995,33 @@ num_positive (num, precision)\n   return (num.low & (cpp_num_part) 1 << (precision - 1)) == 0;\n }\n \n+/* Sign extend a number, with PRECISION significant bits and all\n+   others assumed clear, to fill out a cpp_num structure.  */\n+cpp_num\n+cpp_num_sign_extend (num, precision)\n+     cpp_num num;\n+     size_t precision;\n+{\n+  if (!num.unsignedp)\n+    {\n+      if (precision > PART_PRECISION)\n+\t{\n+\t  precision -= PART_PRECISION;\n+\t  if (precision < PART_PRECISION\n+\t      && (num.high & (cpp_num_part) 1 << (precision - 1)))\n+\t    num.high |= ~(~(cpp_num_part) 0 >> (PART_PRECISION - precision));\n+\t}\n+      else if (num.low & (cpp_num_part) 1 << (precision - 1))\n+\t{\n+\t  if (precision < PART_PRECISION)\n+\t    num.low |= ~(~(cpp_num_part) 0 >> (PART_PRECISION - precision));\n+\t  num.high = ~(cpp_num_part) 0;\n+\t}\n+    }\n+\n+  return num;\n+}\n+\n /* Returns the negative of NUM.  */\n static cpp_num\n num_negate (num, precision)"}, {"sha": "580ef35a87de9d25982ac74e5e1b1d155280904d", "filename": "gcc/cppinit.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ceeedfc11a23c9223095ef4eace51f29fb036aa9/gcc%2Fcppinit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ceeedfc11a23c9223095ef4eace51f29fb036aa9/gcc%2Fcppinit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppinit.c?ref=ceeedfc11a23c9223095ef4eace51f29fb036aa9", "patch": "@@ -1770,6 +1770,8 @@ cpp_post_options (pfile)\n   if (CPP_OPTION (pfile, cplusplus))\n     CPP_OPTION (pfile, warn_traditional) = 0;\n \n+  /* The compiler front ends override this, but I think this is the\n+     appropriate setting for the library.  */\n   CPP_OPTION (pfile, warn_long_long) = (CPP_OPTION (pfile, pedantic)\n \t\t\t\t\t&& !CPP_OPTION (pfile, c99));\n "}, {"sha": "672f3e860d50e9c09558c0abba3e1551c454b88a", "filename": "gcc/cpplib.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ceeedfc11a23c9223095ef4eace51f29fb036aa9/gcc%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ceeedfc11a23c9223095ef4eace51f29fb036aa9/gcc%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.h?ref=ceeedfc11a23c9223095ef4eace51f29fb036aa9", "patch": "@@ -625,6 +625,10 @@ extern unsigned cpp_classify_number PARAMS ((cpp_reader *, const cpp_token *));\n extern cpp_num cpp_interpret_integer PARAMS ((cpp_reader *, const cpp_token *,\n \t\t\t\t\t      unsigned int type));\n \n+/* Sign extend a number, with PRECISION significant bits and all\n+   others assumed clear, to fill out a cpp_num structure.  */\n+cpp_num cpp_num_sign_extend PARAMS ((cpp_num, size_t));\n+\n /* Diagnostic levels.  To get a dianostic without associating a\n    position in the translation unit with it, use cpp_error_with_line\n    with a line number of zero.  */"}, {"sha": "8da0dbefded1a0bcc07521414b9cdc8c9dd7a8ca", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ceeedfc11a23c9223095ef4eace51f29fb036aa9/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ceeedfc11a23c9223095ef4eace51f29fb036aa9/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=ceeedfc11a23c9223095ef4eace51f29fb036aa9", "patch": "@@ -1,3 +1,10 @@\n+2002-06-02  Neil Booth  <neil@daikokuya.demon.co.uk>\n+\n+\t* gcc.dg/wtr-int-type-1.c, gcc.dg/wtr-suffix-1.c,\n+\tgcc.dg/cpp/paste4.c, gcc.dg/cpp/sysmac2.c:\n+\tUpdate for mofified diagnostics.\n+\t* gcc.dg/c99-intconst-1.c: No longer fail.\n+\n 2002-06-02  Richard Henderson  <rth@redhat.com>\n \n \t* gcc.dg/uninit-A.c: Remove xfail markers."}, {"sha": "629b0bcac2057e44e340f80cbb1820f6147382d5", "filename": "gcc/testsuite/gcc.dg/c99-intconst-1.c", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ceeedfc11a23c9223095ef4eace51f29fb036aa9/gcc%2Ftestsuite%2Fgcc.dg%2Fc99-intconst-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ceeedfc11a23c9223095ef4eace51f29fb036aa9/gcc%2Ftestsuite%2Fgcc.dg%2Fc99-intconst-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc99-intconst-1.c?ref=ceeedfc11a23c9223095ef4eace51f29fb036aa9", "patch": "@@ -4,11 +4,6 @@\n /* { dg-do compile } */\n /* { dg-options \"-std=iso9899:1999 -pedantic-errors\" } */\n \n-/* C99 type selection didn't make it into 3.1, so this test\n-   will fail on one or two entries; which ones depends on the\n-   platform.\n-   { dg-excess-errors \"c99 not yet\" } */\n-\n #include <limits.h>\n \n /* Assertion that constant C is of type T.  */"}, {"sha": "2215b34a7adbab730c2c0e5b547830dcab585e76", "filename": "gcc/testsuite/gcc.dg/cpp/paste4.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ceeedfc11a23c9223095ef4eace51f29fb036aa9/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fpaste4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ceeedfc11a23c9223095ef4eace51f29fb036aa9/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fpaste4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fpaste4.c?ref=ceeedfc11a23c9223095ef4eace51f29fb036aa9", "patch": "@@ -11,6 +11,6 @@\n \n int main ()\n {\n-  double d = glue (1.0e, +1); /* { dg-error \"floating const|parse error\" } */\n+  double d = glue (1.0e, +1); /* { dg-error \"exponent|parse error\" } */\n   return 0;\n }"}, {"sha": "0d1efabdc07368d2ce762bb20c9cceafdd1e34af", "filename": "gcc/testsuite/gcc.dg/cpp/sysmac2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ceeedfc11a23c9223095ef4eace51f29fb036aa9/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fsysmac2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ceeedfc11a23c9223095ef4eace51f29fb036aa9/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fsysmac2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fsysmac2.c?ref=ceeedfc11a23c9223095ef4eace51f29fb036aa9", "patch": "@@ -1,7 +1,7 @@\n /* Copyright (C) 2001 Free Software Foundation, Inc.  */\n \n /* { dg-do compile } */\n-/* { dg-options \"-std=gnu99 -pedantic -Wtraditional\" } */\n+/* { dg-options \"-std=gnu99 -pedantic -Wtraditional -fno-show-column\" } */\n \n /* Tests diagnostics are suppressed for some macros defined in system\n    headers.  */"}, {"sha": "bb3a7de3cab59db74631066b61c40d45cfae9b7f", "filename": "gcc/testsuite/gcc.dg/wtr-int-type-1.c", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ceeedfc11a23c9223095ef4eace51f29fb036aa9/gcc%2Ftestsuite%2Fgcc.dg%2Fwtr-int-type-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ceeedfc11a23c9223095ef4eace51f29fb036aa9/gcc%2Ftestsuite%2Fgcc.dg%2Fwtr-int-type-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fwtr-int-type-1.c?ref=ceeedfc11a23c9223095ef4eace51f29fb036aa9", "patch": "@@ -2,7 +2,7 @@\n    Note, gcc should omit these warnings in system header files.\n    By Kaveh R. Ghazi <ghazi@caip.rutgers.edu> 8/22/2000.  */\n /* { dg-do compile } */\n-/* { dg-options \"-Wtraditional\" } */\n+/* { dg-options \"-std=c99 -Wtraditional\" } */\n \n void\n testfunc (void)\n@@ -18,12 +18,14 @@ testfunc (void)\n   i = 0xFFFFFFFFFFFFFFFF;\n   i = 01777777777777777777777;\n \n-  /* We expect to get either a \"width of integer constant changes with\n-     -traditional\" warning or an \"integer constant is unsigned in ISO\n-     C, signed with -traditional\" warning depending on whether we are\n-     testing on a 32 or 64 bit platform.  Either warning means the\n-     test passes and both matched by checking for \"integer constant\".  */\n-  i = 18446744073709551615; /* { dg-warning \"integer constant\" \"integer constant\" } */\n+  /* Nor should values outside the range of (32-bit) unsigned long but\n+     inside the range of long long.  [since -traditional has no long long,\n+     we can pretend it worked the way it does in C99.]  */\n+  i = 9223372036854775807;\n+\n+  /* But this one should, since it doesn't fit in long (long), but\n+     does fit in unsigned long (long).  */\n+  i = 18446744073709551615; /* { dg-warning \"decimal constant|unsigned\" \"decimal constant\" } */\n   \n # 29 \"sys-header.h\" 3\n /* We are in system headers now, no -Wtraditional warnings should issue.  */\n@@ -39,6 +41,3 @@ testfunc (void)\n   i = 9223372036854775807;\n   i = 18446744073709551615;\n }\n-\n-/* Ignore \"decimal constant is so large that it is unsigned\" warnings.  */\n-/* { dg-warning \"decimal constant\" \"decimal constant\" { target *-*-* } 26 } */"}, {"sha": "f6b6300ac1f9558a07f4d50722ecffb0afac197a", "filename": "gcc/testsuite/gcc.dg/wtr-suffix-1.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ceeedfc11a23c9223095ef4eace51f29fb036aa9/gcc%2Ftestsuite%2Fgcc.dg%2Fwtr-suffix-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ceeedfc11a23c9223095ef4eace51f29fb036aa9/gcc%2Ftestsuite%2Fgcc.dg%2Fwtr-suffix-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fwtr-suffix-1.c?ref=ceeedfc11a23c9223095ef4eace51f29fb036aa9", "patch": "@@ -12,13 +12,13 @@ testfunc (void)\n \n   i = 1L;\n   i = 1l;\n-  i = 1U; /* { dg-warning \"traditional C rejects the 'u' suffix\" \"numeric constant suffix\" } */\n-  i = 1u; /* { dg-warning \"traditional C rejects the 'u' suffix\" \"numeric constant suffix\" } */\n+  i = 1U; /* { dg-warning \"traditional C rejects\" \"numeric constant suffix\" } */\n+  i = 1u; /* { dg-warning \"traditional C rejects\" \"numeric constant suffix\" } */\n   f = 1.0;\n-  f = 1.0F; /* { dg-warning \"traditional C rejects the 'f' suffix\" \"numeric constant suffix\" } */\n-  f = 1.0f; /* { dg-warning \"traditional C rejects the 'f' suffix\" \"numeric constant suffix\" } */\n-  f = 1.0L; /* { dg-warning \"traditional C rejects the 'l' suffix\" \"numeric constant suffix\" } */\n-  f = 1.0l; /* { dg-warning \"traditional C rejects the 'l' suffix\" \"numeric constant suffix\" } */\n+  f = 1.0F; /* { dg-warning \"traditional C rejects\" \"numeric constant suffix\" } */\n+  f = 1.0f; /* { dg-warning \"traditional C rejects\" \"numeric constant suffix\" } */\n+  f = 1.0L; /* { dg-warning \"traditional C rejects\" \"numeric constant suffix\" } */\n+  f = 1.0l; /* { dg-warning \"traditional C rejects\" \"numeric constant suffix\" } */\n  \n # 24 \"sys-header.h\" 3\n /* We are in system headers now, no -Wtraditional warnings should issue.  */"}, {"sha": "d215d392fec19b49325f22af203bac3c79b4cf27", "filename": "gcc/tree.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ceeedfc11a23c9223095ef4eace51f29fb036aa9/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ceeedfc11a23c9223095ef4eace51f29fb036aa9/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=ceeedfc11a23c9223095ef4eace51f29fb036aa9", "patch": "@@ -2027,7 +2027,9 @@ extern tree global_trees[TI_MAX];\n #define V16SF_type_node\t\t\tglobal_trees[TI_V16SF_TYPE]\n \n /* An enumeration of the standard C integer types.  These must be\n-   ordered so that shorter types appear before longer ones.  */\n+   ordered so that shorter types appear before longer ones, and so\n+   that signed types appear before unsigned ones, for the correct\n+   functioning of interpret_integer() in c-lex.c.  */\n enum integer_type_kind\n {\n   itk_char,"}]}