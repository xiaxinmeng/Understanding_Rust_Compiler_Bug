{"sha": "f13a69eccf8e409e1046f6bc1df333f0bf69cb6f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjEzYTY5ZWNjZjhlNDA5ZTEwNDZmNmJjMWRmMzMzZjBiZjY5Y2I2Zg==", "commit": {"author": {"name": "Benjamin Kosnik", "email": "bkoz@redhat.com", "date": "2002-07-31T02:47:36Z"}, "committer": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2002-07-31T02:47:36Z"}, "message": "char_traits.h: Remove generic definitions.\n\n\n2002-07-30  Benjamin Kosnik  <bkoz@redhat.com>\n            Gabriel Dos Reis  <gdr@nerim.net>\n\n\t* include/bits/char_traits.h: Remove generic definitions.\n\t* include/bits/streambuf_iterator.h (istreambuf_iterator): Use\n\teof, not -2.\n\t* include/bits/istream.tcc (istream::readsome): Don't check\n\tagainst eof, instead use constants.\n\t(istream::sync): Same.\n\t(istream::sentry::sentry): Use eq_int_type.\n\t(istream::get): Same.\n\t* include/bits/ostream.tcc: Change __pad to\n\t__pad<_CharT, _Traits>::_S_pad.\n\t* include/bits/locale_facets.h: Add __pad_traits generic and\n\tostreambuf_iterator specialization.\n\t* include/bits/locale_facets.tcc: Change __pad into struct __pad\n\twith a _CharT and _Traits template parameter and _S_pad static\n\tmember function.\n\t* src/locale-inst.cc: Update __pad instantiations.\n\n\t* include/std/std_fstream.h: Declare _M_underflow_common\n\tspecializations.\n\t* src/fstream.cc: New. Add _M_underflow_common specializations.\n\t* include/bits/fstream.tcc (filebuf::close): Use traits_type.\n\t(filebuf::_M_underflow_common(bool)): Remove generic version, as\n\tsys_ungetc and custom int_types don't get along.\n\t* include/std/std_streambuf.h: Add _M_pos.\n\t* src/Makefile.am (sources): Add fstream.cc.\n\t* src/Makefile.in: Regenerate.\n\n\t* testsuite/21_strings/capacity.cc: Add char_traits specializations.\n\t* testsuite/22_locale/codecvt_members_unicode_char.cc: Same.\n\t* testsuite/22_locale/codecvt_members_unicode_wchar_t.cc: Same.\n\t* testsuite/22_locale/ctor_copy_dtor.cc: Same.\n\t* testsuite/27_io/filebuf_virtuals.cc (test07): Move to...\n\t* testsuite/27_io/filebuf.cc: ...here.\n\t* testsuite/testsuite_hooks.h: Add gnu_char, gnu_int, char_traits\n\tspecialization for both.\n\t* testsuite/27_io/streambuf.cc: Add instantiation test,\n\ttestsuite_hooks include.\n\t* testsuite/27_io/istream.cc: Same.\n\t* testsuite/27_io/ostream.cc: Same.\n\t* testsuite/27_io/fstream.cc: Same.\n\t* testsuite/27_io/stringstream.cc: Same.\n\t* testsuite/27_io/filebuf.cc: Same.\n\t* testsuite/27_io/stringbuf.cc: Same.\n\nCo-Authored-By: Gabriel Dos Reis <gdr@nerim.net>\n\nFrom-SVN: r55893", "tree": {"sha": "08b6c08936b83169138f92c71df06d93579f7e79", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/08b6c08936b83169138f92c71df06d93579f7e79"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f13a69eccf8e409e1046f6bc1df333f0bf69cb6f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f13a69eccf8e409e1046f6bc1df333f0bf69cb6f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f13a69eccf8e409e1046f6bc1df333f0bf69cb6f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f13a69eccf8e409e1046f6bc1df333f0bf69cb6f/comments", "author": null, "committer": null, "parents": [{"sha": "506a61b144b1bd438ed18f767d9831bc95d739ac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/506a61b144b1bd438ed18f767d9831bc95d739ac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/506a61b144b1bd438ed18f767d9831bc95d739ac"}], "stats": {"total": 1220, "additions": 874, "deletions": 346}, "files": [{"sha": "7ce18b38b13bd0e983ea313c911912c3a629645c", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f13a69eccf8e409e1046f6bc1df333f0bf69cb6f/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f13a69eccf8e409e1046f6bc1df333f0bf69cb6f/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=f13a69eccf8e409e1046f6bc1df333f0bf69cb6f", "patch": "@@ -1,3 +1,50 @@\n+2002-07-30  Benjamin Kosnik  <bkoz@redhat.com>\n+            Gabriel Dos Reis  <gdr@nerim.net>\n+\n+\t* include/bits/char_traits.h: Remove generic definitions.\n+\t* include/bits/streambuf_iterator.h (istreambuf_iterator): Use\n+\teof, not -2.\n+\t* include/bits/istream.tcc (istream::readsome): Don't check\n+\tagainst eof, instead use constants.\n+\t(istream::sync): Same.\n+\t(istream::sentry::sentry): Use eq_int_type.\n+\t(istream::get): Same.\n+\t* include/bits/ostream.tcc: Change __pad to \n+\t__pad<_CharT, _Traits>::_S_pad. \n+\t* include/bits/locale_facets.h: Add __pad_traits generic and\n+\tostreambuf_iterator specialization.\n+\t* include/bits/locale_facets.tcc: Change __pad into struct __pad\n+\twith a _CharT and _Traits template parameter and _S_pad static\n+\tmember function.\n+\t* src/locale-inst.cc: Update __pad instantiations.\n+\t\n+\t* include/std/std_fstream.h: Declare _M_underflow_common\n+\tspecializations.\n+\t* src/fstream.cc: New. Add _M_underflow_common specializations.\n+\t* include/bits/fstream.tcc (filebuf::close): Use traits_type.\n+\t(filebuf::_M_underflow_common(bool)): Remove generic version, as\n+\tsys_ungetc and custom int_types don't get along.\n+\t* include/std/std_streambuf.h: Add _M_pos.\n+\t* src/Makefile.am (sources): Add fstream.cc.\n+\t* src/Makefile.in: Regenerate.\n+\n+\t* testsuite/21_strings/capacity.cc: Add char_traits specializations.\n+\t* testsuite/22_locale/codecvt_members_unicode_char.cc: Same.\n+\t* testsuite/22_locale/codecvt_members_unicode_wchar_t.cc: Same.\n+\t* testsuite/22_locale/ctor_copy_dtor.cc: Same.\n+\t* testsuite/27_io/filebuf_virtuals.cc (test07): Move to...\n+\t* testsuite/27_io/filebuf.cc: ...here.\n+\t* testsuite/testsuite_hooks.h: Add gnu_char, gnu_int, char_traits\n+\tspecialization for both.\n+\t* testsuite/27_io/streambuf.cc: Add instantiation test,\n+\ttestsuite_hooks include.\n+\t* testsuite/27_io/istream.cc: Same.\n+\t* testsuite/27_io/ostream.cc: Same.\t\n+\t* testsuite/27_io/fstream.cc: Same.\n+\t* testsuite/27_io/stringstream.cc: Same.\n+\t* testsuite/27_io/filebuf.cc: Same.\n+\t* testsuite/27_io/stringbuf.cc: Same.\n+\t\n 2002-07-29  Alan Modra  <amodra@bigpond.net.au>\n \n \t* config/cpu/powerpc/cpu_limits.h (__glibcpp_long_bits): Define."}, {"sha": "a5fdfbef29604918d777fa8d772a7cb22824769d", "filename": "libstdc++-v3/include/bits/char_traits.h", "status": "modified", "additions": 17, "deletions": 45, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f13a69eccf8e409e1046f6bc1df333f0bf69cb6f/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fchar_traits.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f13a69eccf8e409e1046f6bc1df333f0bf69cb6f/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fchar_traits.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fchar_traits.h?ref=f13a69eccf8e409e1046f6bc1df333f0bf69cb6f", "patch": "@@ -1,6 +1,7 @@\n // Character Traits for use by standard string and iostream -*- C++ -*-\n \n-// Copyright (C) 1997, 1998, 1999, 2000, 2001 Free Software Foundation, Inc.\n+// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002\n+// Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -57,82 +58,53 @@ namespace std\n     struct char_traits\n     {\n       typedef _CharT \t\tchar_type;\n-      // Unsigned as wint_t in unsigned.\n+      // Unsigned as wint_t is unsigned.\n       typedef unsigned long  \tint_type;\n       typedef streampos \tpos_type;\n       typedef streamoff \toff_type;\n       typedef mbstate_t \tstate_type;\n       \n       static void \n-      assign(char_type& __c1, const char_type& __c2)\n-      { __c1 = __c2; }\n+      assign(char_type& __c1, const char_type& __c2);\n \n       static bool \n-      eq(const char_type& __c1, const char_type& __c2)\n-      { return __c1 == __c2; }\n+      eq(const char_type& __c1, const char_type& __c2);\n \n       static bool \n-      lt(const char_type& __c1, const char_type& __c2)\n-      { return __c1 < __c2; }\n+      lt(const char_type& __c1, const char_type& __c2);\n \n       static int \n-      compare(const char_type* __s1, const char_type* __s2, size_t __n)\n-      { \n-\tfor (size_t __i = 0; __i < __n; ++__i)\n-\t  if (!eq(__s1[__i], __s2[__i]))\n-\t    return lt(__s1[__i], __s2[__i]) ? -1 : 1;\n-\treturn 0; \n-      }\n+      compare(const char_type* __s1, const char_type* __s2, size_t __n);\n \n       static size_t\n-      length(const char_type* __s)\n-      { \n-\tconst char_type* __p = __s; \n-\twhile (*__p) ++__p; \n-\treturn (__p - __s); \n-      }\n+      length(const char_type* __s);\n \n       static const char_type* \n-      find(const char_type* __s, size_t __n, const char_type& __a)\n-      { \n-\tfor (const char_type* __p = __s; size_t(__p - __s) < __n; ++__p)\n-\t  if (*__p == __a) return __p;\n-\treturn 0;\n-      }\n+      find(const char_type* __s, size_t __n, const char_type& __a);\n \n       static char_type* \n-      move(char_type* __s1, const char_type* __s2, size_t __n)\n-      { return (char_type*) memmove(__s1, __s2, __n * sizeof(char_type)); }\n+      move(char_type* __s1, const char_type* __s2, size_t __n);\n \n       static char_type* \n-      copy(char_type* __s1, const char_type* __s2, size_t __n)\n-      { return (char_type*) memcpy(__s1, __s2, __n * sizeof(char_type)); }\n+      copy(char_type* __s1, const char_type* __s2, size_t __n);\n \n       static char_type* \n-      assign(char_type* __s, size_t __n, char_type __a)\n-      { \n-\tfor (char_type* __p = __s; __p < __s + __n; ++__p) \n-\t  assign(*__p, __a);\n-        return __s; \n-      }\n+      assign(char_type* __s, size_t __n, char_type __a);\n \n       static char_type \n-      to_char_type(const int_type& __c)\n-      { return char_type(__c); }\n+      to_char_type(const int_type& __c);\n \n       static int_type \n-      to_int_type(const char_type& __c) { return int_type(__c); }\n+      to_int_type(const char_type& __c);\n \n       static bool \n-      eq_int_type(const int_type& __c1, const int_type& __c2)\n-      { return __c1 == __c2; }\n+      eq_int_type(const int_type& __c1, const int_type& __c2);\n \n       static int_type \n-      eof() { return static_cast<int_type>(-1); }\n+      eof(); \n \n       static int_type \n-      not_eof(const int_type& __c)\n-      { return eq_int_type(__c, eof()) ? int_type(0) : __c; }\n+      not_eof(const int_type& __c);\n     };\n \n "}, {"sha": "279e0ab16ba2e8b590351f032c55d9f04c73f518", "filename": "libstdc++-v3/include/bits/fpos.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f13a69eccf8e409e1046f6bc1df333f0bf69cb6f/libstdc%2B%2B-v3%2Finclude%2Fbits%2Ffpos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f13a69eccf8e409e1046f6bc1df333f0bf69cb6f/libstdc%2B%2B-v3%2Finclude%2Fbits%2Ffpos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Ffpos.h?ref=f13a69eccf8e409e1046f6bc1df333f0bf69cb6f", "patch": "@@ -105,7 +105,7 @@ namespace std\n       bool  \n       operator!=(const fpos& __pos) const\n       { return _M_off != __pos._M_off; }\n-      \n+\n       streamoff \n       _M_position() const { return _M_off; }\n "}, {"sha": "2caeb6e5e5815cfe34b759fe36b22e3d7c654504", "filename": "libstdc++-v3/include/bits/fstream.tcc", "status": "modified", "additions": 2, "deletions": 91, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f13a69eccf8e409e1046f6bc1df333f0bf69cb6f/libstdc%2B%2B-v3%2Finclude%2Fbits%2Ffstream.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f13a69eccf8e409e1046f6bc1df333f0bf69cb6f/libstdc%2B%2B-v3%2Finclude%2Fbits%2Ffstream.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Ffstream.tcc?ref=f13a69eccf8e409e1046f6bc1df333f0bf69cb6f", "patch": "@@ -112,7 +112,8 @@ namespace std\n \t{\n \t  const int_type __eof = traits_type::eof();\n \t  bool __testput = _M_out_cur && _M_out_beg < _M_out_end;\n-\t  if (__testput && _M_really_overflow(__eof) == __eof)\n+\t  if (__testput \n+\t      && traits_type::eq_int_type(_M_really_overflow(__eof), __eof))\n \t    return __ret;\n \n \t  // NB: Do this here so that re-opened filebufs will be cool...\n@@ -155,96 +156,6 @@ namespace std\n       _M_last_overflowed = false;\t\n       return __ret;\n     }\n-\n-  template<typename _CharT, typename _Traits>\n-    typename basic_filebuf<_CharT, _Traits>::int_type \n-    basic_filebuf<_CharT, _Traits>::\n-    _M_underflow_common(bool __bump)\n-    {\n-      int_type __ret = traits_type::eof();\n-      bool __testin = _M_mode & ios_base::in;\n-      bool __testout = _M_mode & ios_base::out;\n-\n-      if (__testin)\n-\t{\n-\t  // Check for pback madness, and if so swich back to the\n-\t  // normal buffers and jet outta here before expensive\n-\t  // fileops happen...\n-\t  if (_M_pback_init)\n-\t    {\n-\t      _M_pback_destroy();\n-\t      if (_M_in_cur < _M_in_end)\n-\t\treturn traits_type::to_int_type(*_M_in_cur);\n-\t    }\n-\n-\t  // Sync internal and external buffers.\n-\t  // NB: __testget -> __testput as _M_buf_unified here.\n-\t  bool __testget = _M_in_cur && _M_in_beg < _M_in_cur;\n-\t  bool __testinit = _M_is_indeterminate();\n-\t  if (__testget)\n-\t    {\n-\t      if (__testout)\n-\t\t_M_really_overflow();\n-\t      else if (_M_in_cur != _M_filepos)\n-\t\t_M_file.seekoff(_M_in_cur - _M_filepos,\n-\t\t\t\tios_base::cur, ios_base::in);\n-\t    }\n-\n-\t  if (__testinit || __testget)\n-\t    {\n-\t      const locale __loc = this->getloc();\n-\t      const __codecvt_type& __cvt = use_facet<__codecvt_type>(__loc); \n-\n-\t      streamsize __elen = 0;\n-\t      streamsize __ilen = 0;\n-\t      if (__cvt.always_noconv())\n-\t\t{\n-\t\t  __elen = _M_file.xsgetn(reinterpret_cast<char*>(_M_in_beg), \n-\t\t\t\t\t  _M_buf_size);\n-\t\t  __ilen = __elen;\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  char* __buf = static_cast<char*>(__builtin_alloca(_M_buf_size));\n-\t\t  __elen = _M_file.xsgetn(__buf, _M_buf_size);\n-\n-\t\t  const char* __eend;\n-\t\t  char_type* __iend;\n-\t\t  __res_type __r = __cvt.in(_M_state_cur, __buf, \n-\t\t\t\t\t    __buf + __elen, __eend, _M_in_beg, \n-\t\t\t\t\t    _M_in_beg + _M_buf_size, __iend);\n-\t\t  if (__r == codecvt_base::ok)\n-\t\t    __ilen = __iend - _M_in_beg;\n-\t\t  else \n-\t\t    {\n-\t\t      // Unwind.\n-\t\t      __ilen = 0;\n-\t\t      _M_file.seekoff(-__elen, ios_base::cur, ios_base::in);\n-\t\t    }\n-\t\t}\n-\n-\t      if (0 < __ilen)\n-\t\t{\n-\t\t  _M_set_determinate(__ilen);\n-\t\t  if (__testout)\n-\t\t    _M_out_cur = _M_in_cur;\n-\t\t  __ret = traits_type::to_int_type(*_M_in_cur);\n-\t\t  if (__bump)\n-\t\t    _M_in_cur_move(1);\n-\t\t  else if (_M_buf_size == 1)\n-\t\t    {\n-\t\t      // If we are synced with stdio, we have to unget the\n-\t\t      // character we just read so that the file pointer\n-\t\t      // doesn't move.\n-\t\t      _M_file.sys_ungetc(*_M_in_cur);\n-\t\t      _M_set_indeterminate();\n-\t\t    }\n-\t\t}\t   \n-\t    }\n-\t}\n-      _M_last_overflowed = false;\t\n-      return __ret;\n-    }\n   \n   template<typename _CharT, typename _Traits>\n     typename basic_filebuf<_CharT, _Traits>::int_type "}, {"sha": "798fd332b90620aa0f1c65c2857f04e20f212c5d", "filename": "libstdc++-v3/include/bits/istream.tcc", "status": "modified", "additions": 45, "deletions": 29, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f13a69eccf8e409e1046f6bc1df333f0bf69cb6f/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fistream.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f13a69eccf8e409e1046f6bc1df333f0bf69cb6f/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fistream.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fistream.tcc?ref=f13a69eccf8e409e1046f6bc1df333f0bf69cb6f", "patch": "@@ -54,13 +54,14 @@ namespace std\n \t      __int_type __c = __sb->sgetc();\n \n \t      if (__in._M_check_facet(__in._M_fctype))\n-\t\twhile (__c != __eof\n-\t\t       && __in._M_fctype->is(ctype_base::space, __c))\n+\t\twhile (!traits_type::eq_int_type(__c, __eof)\n+\t\t       && __in._M_fctype->is(ctype_base::space, \n+\t\t\t\t\t     traits_type::to_char_type(__c)))\n \t\t  __c = __sb->snextc();\n \n #ifdef _GLIBCPP_RESOLVE_LIB_DEFECTS\n //195.  Should basic_istream::sentry's constructor ever set eofbit? \n-\t      if (__c == __eof)\n+\t      if (traits_type::eq_int_type(__c, __eof))\n \t\t__in.setstate(ios_base::eofbit);\n #endif\n \t    }\n@@ -521,7 +522,7 @@ namespace std\n \t    {\n \t      __c = this->rdbuf()->sbumpc();\n \t      // 27.6.1.1 paragraph 3\n-\t      if (__c != __eof)\n+\t      if (!traits_type::eq_int_type(__c, __eof))\n \t\t_M_gcount = 1;\n \t      else\n \t\tthis->setstate(ios_base::eofbit | ios_base::failbit);\n@@ -552,7 +553,7 @@ namespace std\n \t      const int_type __eof = traits_type::eof();\n \t      int_type __bufval = this->rdbuf()->sbumpc();\n \t      // 27.6.1.1 paragraph 3\n-\t      if (__bufval != __eof)\n+\t      if (!traits_type::eq_int_type(__bufval, __eof))\n \t\t{\n \t\t  _M_gcount = 1;\n \t\t  __c = traits_type::to_char_type(__bufval);\n@@ -588,13 +589,15 @@ namespace std\n \t      __streambuf_type* __sb = this->rdbuf();\n \t      int_type __c = __sb->sgetc();\t\n \t      \n-\t      while (_M_gcount + 1 < __n && __c != __eof && __c != __idelim)\n+\t      while (_M_gcount + 1 < __n \n+\t\t     && !traits_type::eq_int_type(__c, __eof)\n+\t\t     && !traits_type::eq_int_type(__c, __idelim))\n \t\t{\n \t\t  *__s++ = traits_type::to_char_type(__c);\n \t\t  __c = __sb->snextc();\n \t\t  ++_M_gcount;\n \t\t}\n-\t      if (__c == __eof)\n+\t      if (traits_type::eq_int_type(__c, __eof))\n \t\tthis->setstate(ios_base::eofbit);\n \t    }\n \t  catch(exception& __fail)\n@@ -627,14 +630,17 @@ namespace std\n \t      const int_type __eof = traits_type::eof();\t      \n \t      __streambuf_type* __this_sb = this->rdbuf();\n \t      int_type __c = __this_sb->sgetc();\n+\t      char_type __c2 = traits_type::to_char_type(__c);\n \t      \n-\t      while (__c != __eof && __c != __idelim \n-\t\t     && (__sb.sputc(traits_type::to_char_type(__c)) != __eof))\n+\t      while (!traits_type::eq_int_type(__c, __eof) \n+\t\t     && !traits_type::eq_int_type(__c, __idelim) \n+\t\t     && !traits_type::eq_int_type(__sb.sputc(__c2), __eof))\n \t\t{\n \t\t  ++_M_gcount;\n \t\t  __c = __this_sb->snextc();\n+\t\t  __c2 = traits_type::to_char_type(__c);\n \t\t}\n-\t      if (__c == __eof)\n+\t      if (traits_type::eq_int_type(__c, __eof))\n \t\tthis->setstate(ios_base::eofbit);\n \t    }\n \t  catch(exception& __fail)\n@@ -667,17 +673,19 @@ namespace std\n \t      __streambuf_type* __sb = this->rdbuf();\n \t      int_type __c = __sb->sgetc();\n \t    \n-\t      while (_M_gcount + 1 < __n && __c != __eof && __c != __idelim)\n+\t      while (_M_gcount + 1 < __n \n+\t\t     && !traits_type::eq_int_type(__c, __eof)\n+\t\t     && !traits_type::eq_int_type(__c, __idelim))\n \t\t{\n \t\t  *__s++ = traits_type::to_char_type(__c);\n \t\t  __c = __sb->snextc();\n \t\t  ++_M_gcount;\n \t\t}\n-\t      if (__c == __eof)\n+\t      if (traits_type::eq_int_type(__c, __eof))\n \t\tthis->setstate(ios_base::eofbit);\n \t      else\n \t\t{\n-\t\t  if (__c == __idelim)\n+\t\t  if (traits_type::eq_int_type(__c, __idelim))\n \t\t    {\n \t\t      __sb->sbumpc();\n \t\t      ++_M_gcount;\n@@ -717,14 +725,16 @@ namespace std\n \t      int_type __c = __sb->sgetc();\t\n \t      \n \t      __n = min(__n, numeric_limits<streamsize>::max());\n-\t      while (_M_gcount < __n  && __c !=__eof && __c != __delim)\n+\t      while (_M_gcount < __n  \n+\t\t     && !traits_type::eq_int_type(__c, __eof) \n+\t\t     && !traits_type::eq_int_type(__c, __delim))\n \t\t{\n \t\t  __c = __sb->snextc();\n \t\t  ++_M_gcount;\n \t\t}\n-\t      if (__c == __eof)\n+\t      if (traits_type::eq_int_type(__c, __eof))\n \t\tthis->setstate(ios_base::eofbit);\n-\t      else if (__c == __delim)\n+\t      else if (traits_type::eq_int_type(__c, __delim))\n \t\t{\n \t\t  __sb->sbumpc();\n \t\t  ++_M_gcount;\n@@ -806,9 +816,8 @@ namespace std\n \t{\n \t  try \n \t    {\n-\t      const int_type __eof = traits_type::eof(); \n \t      streamsize __num = this->rdbuf()->in_avail();\n-\t      if (__num != static_cast<streamsize>(__eof))\n+\t      if (__num > 0)\n \t\t{\n \t\t  __num = min(__num, __n);\n \t\t  if (__num)\n@@ -843,7 +852,8 @@ namespace std\n \t    {\n \t      const int_type __eof = traits_type::eof();\n \t      __streambuf_type* __sb = this->rdbuf();\n-\t      if (!__sb || __sb->sputbackc(__c) == __eof) \n+\t      if (!__sb \n+\t\t  || traits_type::eq_int_type(__sb->sputbackc(__c), __eof))\n \t\tthis->setstate(ios_base::badbit);\t\t    \n \t    }\n \t  catch(exception& __fail)\n@@ -873,7 +883,8 @@ namespace std\n \t    {\n \t      const int_type __eof = traits_type::eof();\n \t      __streambuf_type* __sb = this->rdbuf();\n-\t      if (!__sb || __eof == __sb->sungetc())\n+\t      if (!__sb \n+\t\t  || traits_type::eq_int_type(__sb->sungetc(), __eof))\n \t\tthis->setstate(ios_base::badbit);\t\t    \n \t    }\n \t  catch(exception& __fail)\n@@ -895,18 +906,21 @@ namespace std\n     basic_istream<_CharT, _Traits>::\n     sync(void)\n     {\n-      int __ret = traits_type::eof();\n+      int __ret = -1;\n       _M_gcount = 0;\n       sentry __cerb(*this, true);\n       if (__cerb) \n \t{\n \t  try \n \t    {\n \t      __streambuf_type* __sb = this->rdbuf();\n-\t      if (!__sb || __ret == __sb->pubsync())\n-\t\tthis->setstate(ios_base::badbit);\t\t    \n-\t      else \n-\t\t__ret = 0;\n+\t      if (__sb)\n+\t\t{\n+\t\t  if (__sb->pubsync() == -1)\n+\t\t    this->setstate(ios_base::badbit);\t\t    \n+\t\t  else \n+\t\t    __ret = 0;\n+\t\t}\n \t    }\n \t  catch(exception& __fail)\n \t    {\n@@ -1186,16 +1200,18 @@ namespace std\n \t  __streambuf_type* __sb = __in.rdbuf();\n \t  __int_type __c = __sb->sbumpc();\n \t  const __int_type __eof = _Traits::eof();\n-\t  __testdelim = __c ==  __idelim;\n+\t  __testdelim = _Traits::eq_int_type(__c, __idelim);\n \n-\t  while (__extracted <= __n && __c != __eof && !__testdelim)\n+\t  while (__extracted <= __n \n+\t\t && !_Traits::eq_int_type(__c, __eof)\n+\t\t && !__testdelim)\n \t    {\n \t      __str += _Traits::to_char_type(__c);\n \t      ++__extracted;\n \t      __c = __sb->sbumpc();\n-\t      __testdelim = __c == __idelim;\n+\t      __testdelim = _Traits::eq_int_type(__c, __idelim);\n \t    }\n-\t  if (__c == __eof)\n+\t  if (_Traits::eq_int_type(__c, __eof))\n \t    __in.setstate(ios_base::eofbit);\n \t}\n       if (!__extracted && !__testdelim)"}, {"sha": "159cecccdcb1adf8302a0527b7e27082efe2634d", "filename": "libstdc++-v3/include/bits/locale_facets.h", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f13a69eccf8e409e1046f6bc1df333f0bf69cb6f/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_facets.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f13a69eccf8e409e1046f6bc1df333f0bf69cb6f/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_facets.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_facets.h?ref=f13a69eccf8e409e1046f6bc1df333f0bf69cb6f", "patch": "@@ -55,6 +55,9 @@ namespace std\n # define  _GLIBCPP_NUM_FACETS 14\n #endif\n \n+  template<typename _CharT, typename _Traits>\n+    struct __pad;\n+\n   // 22.2.1.1  Template class ctype\n   // Include host and configuration specific ctype enums for ctype_base.\n   #include <bits/ctype_base.h>\n@@ -652,6 +655,7 @@ namespace std\n       virtual iter_type \n       do_get(iter_type, iter_type, ios_base&, ios_base::iostate&, bool&) const;\n \n+\n       virtual iter_type \n       do_get(iter_type, iter_type, ios_base&, ios_base::iostate&, long&) const;\n \n@@ -697,6 +701,23 @@ namespace std\n   template<typename _CharT, typename _InIter>\n     locale::id num_get<_CharT, _InIter>::id;\n \n+#if 0\n+  // Partial specialization for istreambuf_iterator, so can use traits_type.\n+  template<typename _CharT>\n+    class num_get<_CharT, istreambuf_iterator<_CharT> >;\n+\n+      iter_type \n+      _M_extract_float(iter_type, iter_type, ios_base&, ios_base::iostate&, \n+\t\t       string& __xtrc) const;\n+\n+      iter_type \n+      _M_extract_int(iter_type, iter_type, ios_base&, ios_base::iostate&, \n+\t\t     string& __xtrc, int& __base) const;\n+\n+      virtual iter_type \n+      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&, bool&) const;\n+#endif\n+\n   template<typename _CharT, typename _OutIter>\n     class num_put : public locale::facet, public __num_base\n     {"}, {"sha": "63e52c0058511997f885920db598dd8f35e057e2", "filename": "libstdc++-v3/include/bits/locale_facets.tcc", "status": "modified", "additions": 87, "deletions": 73, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f13a69eccf8e409e1046f6bc1df333f0bf69cb6f/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_facets.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f13a69eccf8e409e1046f6bc1df333f0bf69cb6f/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_facets.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_facets.tcc?ref=f13a69eccf8e409e1046f6bc1df333f0bf69cb6f", "patch": "@@ -94,6 +94,7 @@ namespace std\n     _M_extract_float(_InIter __beg, _InIter __end, ios_base& __io,\n \t\t     ios_base::iostate& __err, string& __xtrc) const\n     {\n+      typedef char_traits<_CharT>\t\t__traits_type;\n       const locale __loc = __io.getloc();\n       const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);\n       const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__loc);\n@@ -103,7 +104,8 @@ namespace std\n       const char_type __minus = __ctype.widen('-');\n       int __pos = 0;\n       char_type  __c = *__beg;\n-      if ((__c == __plus || __c == __minus) && __beg != __end)\n+      if ((__traits_type::eq(__c, __plus) || __traits_type::eq(__c, __minus))\n+\t  && __beg != __end)\n \t{\n \t  __xtrc += __ctype.narrow(__c, char());\n \t  ++__pos;\n@@ -113,7 +115,7 @@ namespace std\n       // Next, strip leading zeros.\n       const char_type __zero = __ctype.widen(_S_atoms[_M_zero]);\n       bool __found_zero = false;\n-      while (__c == __zero && __beg != __end)\n+      while (__traits_type::eq(__c, __zero) && __beg != __end)\n \t{\n \t  __c = *(++__beg);\n \t  __found_zero = true;\n@@ -141,19 +143,19 @@ namespace std\n       while (__beg != __end)\n         {\n \t  // Only look in digits.\n-\t  typedef char_traits<_CharT> \t__traits_type;\n           const char_type* __p = __traits_type::find(__watoms, 10,  __c);\n \n           // NB: strchr returns true for __c == 0x0\n-          if (__p && __c)\n+          if (__p && !__traits_type::eq(__c, char_type()))\n \t    {\n \t      // Try first for acceptable digit; record it if found.\n \t      ++__pos;\n \t      __xtrc += _S_atoms[__p - __watoms];\n \t      ++__sep_pos;\n \t      __c = *(++__beg);\n \t    }\n-          else if (__c == __sep && __check_grouping && !__found_dec)\n+          else if (__traits_type::eq(__c, __sep) \n+\t\t   && __check_grouping && !__found_dec)\n \t    {\n               // NB: Thousands separator at the beginning of a string\n               // is a no-no, as is two consecutive thousands separators.\n@@ -169,7 +171,7 @@ namespace std\n \t\t  break;\n \t\t}\n             }\n-\t  else if (__c == __dec && !__found_dec)\n+\t  else if (__traits_type::eq(__c, __dec) && !__found_dec)\n \t    {\n \t      // According to the standard, if no grouping chars are seen,\n \t      // no grouping check is applied. Therefore __found_grouping\n@@ -181,7 +183,8 @@ namespace std\n \t      __c = *(++__beg);\n \t      __found_dec = true;\n \t    }\n-\t  else if ((__c == __watoms[_M_e] || __c == __watoms[_M_E]) \n+\t  else if ((__traits_type::eq(__c, __watoms[_M_e]) \n+\t\t    || __traits_type::eq(__c, __watoms[_M_E])) \n \t\t   && !__found_sci && __pos)\n \t    {\n \t      // Scientific notation.\n@@ -190,7 +193,8 @@ namespace std\n \t      __c = *(++__beg);\n \n \t      // Remove optional plus or minus sign, if they exist.\n-\t      if (__c == __plus || __c == __minus)\n+\t      if (__traits_type::eq(__c, __plus) \n+\t\t  || __traits_type::eq(__c, __minus))\n \t\t{\n \t\t  ++__pos;\n \t\t  __xtrc += __ctype.narrow(__c, char());\n@@ -228,6 +232,7 @@ namespace std\n     _M_extract_int(_InIter __beg, _InIter __end, ios_base& __io,\n \t\t   ios_base::iostate& __err, string& __xtrc, int& __base) const\n     {\n+      typedef char_traits<_CharT>\t\t__traits_type;\n       const locale __loc = __io.getloc();\n       const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);\n       const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__loc);\n@@ -241,10 +246,13 @@ namespace std\n       else\n \t__base = 10;\n \n-     // First check for sign.\n+      // First check for sign.\n       int __pos = 0;\n       char_type  __c = *__beg;\n-      if ((__c == __ctype.widen('+') || __c == __ctype.widen('-'))\n+      const char_type __plus = __ctype.widen('+');\n+      const char_type __minus = __ctype.widen('-');\n+\n+      if ((__traits_type::eq(__c, __plus) || __traits_type::eq(__c, __minus))\n \t  && __beg != __end)\n \t{\n \t  __xtrc += __ctype.narrow(__c, char());\n@@ -259,7 +267,7 @@ namespace std\n       if (__base == 10)\n \t{\n \t  bool __found_zero = false;\n-\t  while (__c == __zero && __beg != __end)\n+\t  while (__traits_type::eq(__c, __zero) && __beg != __end)\n \t    {\n \t      __c = *(++__beg);\n \t      __found_zero = true;\n@@ -270,7 +278,9 @@ namespace std\n \t      ++__pos;\n \t      if (__basefield == 0)\n \t\t{\t      \n-\t\t  if ((__c == __x || __c == __X) && __beg != __end)\n+\t\t  if ((__traits_type::eq(__c, __x) \n+\t\t       || __traits_type::eq(__c, __X))\n+\t\t      && __beg != __end)\n \t\t    {\n \t\t      __xtrc += __ctype.narrow(__c, char());\n \t\t      ++__pos;\n@@ -284,12 +294,13 @@ namespace std\n \t}\n       else if (__base == 16)\n \t{\n-\t  if (__c == __zero && __beg != __end)\n+\t  if (__traits_type::eq(__c, __zero) && __beg != __end)\n \t    {\n \t      __xtrc += _S_atoms[_M_zero];\n \t      ++__pos;\n \t      __c = *(++__beg); \n-\t      if  ((__c == __x || __c == __X) && __beg != __end)\n+\t      if ((__traits_type::eq(__c, __x) || __traits_type::eq(__c, __X))\n+\t\t  && __beg != __end)\n \t\t{\n \t\t  __xtrc += __ctype.narrow(__c, char());\n \t\t  ++__pos;\n@@ -316,19 +327,18 @@ namespace std\n       const char_type __sep = __np.thousands_sep();\n       while (__beg != __end)\n         {\n-\t  typedef char_traits<_CharT> \t__traits_type;\n           const char_type* __p = __traits_type::find(__watoms, __len,  __c);\n \n           // NB: strchr returns true for __c == 0x0\n-          if (__p && __c)\n+          if (__p && !__traits_type::eq(__c, char_type()))\n \t    {\n \t      // Try first for acceptable digit; record it if found.\n \t      __xtrc += _S_atoms[__p - __watoms];\n \t      ++__pos;\n \t      ++__sep_pos;\n \t      __c = *(++__beg);\n \t    }\n-          else if (__c == __sep && __check_grouping)\n+          else if (__traits_type::eq(__c, __sep) && __check_grouping)\n \t    {\n               // NB: Thousands separator at the beginning of a string\n               // is a no-no, as is two consecutive thousands separators.\n@@ -394,7 +404,9 @@ namespace std\n       // Parse bool values as alphanumeric\n       else\n         {\n-\t  typedef basic_string<_CharT> __string_type;\n+\t  typedef char_traits<_CharT>\t      \t__traits_type;\n+\t  typedef basic_string<_CharT>   \t__string_type;\n+\n           locale __loc = __io.getloc();\n \t  const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__loc); \n \t  const __string_type __true = __np.truename();\n@@ -407,8 +419,10 @@ namespace std\n           for (size_t __n = 0; __beg != __end; ++__n)\n             {\n               char_type __c = *__beg++;\n-              bool __testf = __n <= __falsen ? __c == __falses[__n] : false;\n-              bool __testt = __n <= __truen ? __c == __trues[__n] : false;\n+              bool __testf = __n <= __falsen \n+\t\t             ? __traits_type::eq(__c, __falses[__n]) : false;\n+              bool __testt = __n <= __truen \n+\t\t             ? __traits_type::eq(__c, __trues[__n]) : false;\n               if (!(__testf || __testt))\n                 {\n                   __err |= ios_base::failbit;\n@@ -708,6 +722,7 @@ namespace std\n     _M_widen_float(_OutIter __s, ios_base& __io, _CharT __fill, char* __cs, \n \t\t   int __len) const\n     {\n+      typedef char_traits<_CharT> \t\t__traits_type;\n       // [22.2.2.2.2] Stage 2, convert to char_type, using correct\n       // numpunct.decimal_point() values for '.' and adding grouping.\n       const locale __loc = __io.getloc();\n@@ -723,7 +738,7 @@ namespace std\n       // Replace decimal point.\n       const _CharT* __p;\n       const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__loc);\n-      if (__p = char_traits<_CharT>::find(__ws, __len, __ctype.widen('.')))\n+      if (__p = __traits_type::find(__ws, __len, __ctype.widen('.')))\n \t__ws[__p - __ws] = __np.decimal_point();\n \n #ifdef _GLIBCPP_RESOLVE_LIB_DEFECTS\n@@ -744,7 +759,7 @@ namespace std\n \t  // Tack on decimal part.\n \t  if (__p)\n \t    {\n-\t      char_traits<_CharT>::copy(__p2, __p, __len - __declen);\n+\t      __traits_type::copy(__p2, __p, __len - __declen);\n \t      __newlen += __len - __declen;\n \t    }    \n \n@@ -816,13 +831,15 @@ namespace std\n     _M_insert(_OutIter __s, ios_base& __io, _CharT __fill, const _CharT* __ws, \n \t      int __len) const\n     {\n+      typedef char_traits<_CharT> \t\t__traits_type;\n       // [22.2.2.2.2] Stage 3.\n       streamsize __w = __io.width();\n       _CharT* __ws2 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT) \n \t\t\t\t\t\t\t    * __w));\n       if (__w > static_cast<streamsize>(__len))\n \t{\n-\t  __pad(__io, __fill, __ws2, __ws, __w, __len, true);\n+\t  __pad<_CharT, __traits_type>::_S_pad(__io, __fill, __ws2, __ws, \n+\t\t\t\t\t       __w, __len, true);\n \t  __len = static_cast<int>(__w);\n \t  // Switch strings.\n \t  __ws = __ws2;\n@@ -845,7 +862,7 @@ namespace std\n       if ((__flags & ios_base::boolalpha) == 0)\n         {\n           unsigned long __uv = __v;\n-          __s = _M_convert_int(__s, __io, __fill, 'u', char_type(), __uv);\n+          __s = _M_convert_int(__s, __io, __fill, 'u', char(), __uv);\n         }\n       else\n         {\n@@ -866,14 +883,14 @@ namespace std\n     _OutIter\n     num_put<_CharT, _OutIter>::\n     do_put(iter_type __s, ios_base& __io, char_type __fill, long __v) const\n-    { return _M_convert_int(__s, __io, __fill, 'd', char_type(), __v); }\n+    { return _M_convert_int(__s, __io, __fill, 'd', char(), __v); }\n \n   template<typename _CharT, typename _OutIter>\n     _OutIter\n     num_put<_CharT, _OutIter>::\n     do_put(iter_type __s, ios_base& __io, char_type __fill,\n            unsigned long __v) const\n-    { return _M_convert_int(__s, __io, __fill, 'u', char_type(), __v); }\n+    { return _M_convert_int(__s, __io, __fill, 'u', char(), __v); }\n \n #ifdef _GLIBCPP_USE_LONG_LONG\n   template<typename _CharT, typename _OutIter>\n@@ -894,7 +911,7 @@ namespace std\n     _OutIter\n     num_put<_CharT, _OutIter>::\n     do_put(iter_type __s, ios_base& __io, char_type __fill, double __v) const\n-    { return _M_convert_float(__s, __io, __fill, char_type(), __v); }\n+    { return _M_convert_float(__s, __io, __fill, char(), __v); }\n \n   template<typename _CharT, typename _OutIter>\n     _OutIter\n@@ -915,7 +932,7 @@ namespace std\n       __io.flags(__flags & __fmt | (ios_base::hex | ios_base::showbase));\n       try \n \t{\n-\t  __s = _M_convert_int(__s, __io, __fill, 'u', char_type(),\n+\t  __s = _M_convert_int(__s, __io, __fill, 'u', char(),\n \t\t\t       reinterpret_cast<unsigned long>(__v));\n \t  __io.flags(__flags);\n \t}\n@@ -1591,7 +1608,7 @@ namespace std\n \t\t    const _CharT** __names, size_t __indexlen, \n \t\t    ios_base::iostate& __err) const\n     {\n-      typedef char_traits<char_type> __traits_type;\n+      typedef char_traits<_CharT> \t\t__traits_type;\n       int* __matches = static_cast<int*>(__builtin_alloca(sizeof(int) * __indexlen));\n       size_t __nmatches = 0;\n       size_t __pos = 0;\n@@ -1686,7 +1703,7 @@ namespace std\n     do_get_weekday(iter_type __beg, iter_type __end, ios_base& __io, \n \t\t   ios_base::iostate& __err, tm* __tm) const\n     {\n-      typedef char_traits<char_type> __traits_type;\n+      typedef char_traits<_CharT> \t\t__traits_type;\n       locale __loc = __io.getloc();\n       __timepunct<_CharT> const& __tp = use_facet<__timepunct<_CharT> >(__loc);\n       const char_type*  __days[7];\n@@ -1729,7 +1746,7 @@ namespace std\n     do_get_monthname(iter_type __beg, iter_type __end,\n                      ios_base& __io, ios_base::iostate& __err, tm* __tm) const\n     {\n-      typedef char_traits<char_type> __traits_type;\n+      typedef char_traits<_CharT> \t\t__traits_type;\n       locale __loc = __io.getloc();\n       __timepunct<_CharT> const& __tp = use_facet<__timepunct<_CharT> >(__loc);\n       const char_type*  __months[12];\n@@ -1996,30 +2013,39 @@ namespace std\n   // internal-adjusted objects are padded according to the rules below\n   // concerning 0[xX] and +-, otherwise, exactly as right-adjusted\n   // ones are.\n+\n+  // NB: Of the two parameters, _CharT can be deduced from the\n+  // function arguments. The other (_Traits) has to be explicitly specified.\n   template<typename _CharT, typename _Traits>\n-    void\n-    __pad(ios_base& __io, _CharT __fill, _CharT* __news, const _CharT* __olds,\n-\t  const streamsize __newlen, const streamsize __oldlen, \n-\t  const bool __num)\n+    struct __pad\n     {\n-      typedef _CharT\tchar_type;\n-      typedef _Traits\ttraits_type;\n-      typedef typename traits_type::int_type int_type;\n-      \n-      int_type __plen = static_cast<size_t>(__newlen - __oldlen); \n-      char_type* __pads = static_cast<char_type*>(__builtin_alloca(sizeof(char_type) * __plen));\n-      traits_type::assign(__pads, __plen, __fill); \n+      static void\n+      _S_pad(ios_base& __io, _CharT __fill, _CharT* __news, \n+\t     const _CharT* __olds, const streamsize __newlen, \n+\t     const streamsize __oldlen, const bool __num);\n+    };\n \n-      char_type* __beg;\n-      char_type* __end;\n+  template<typename _CharT, typename _Traits>\n+    void \n+    __pad<_CharT, _Traits>::_S_pad(ios_base& __io, _CharT __fill, \n+\t\t\t\t   _CharT* __news, const _CharT* __olds, \n+\t\t\t\t   const streamsize __newlen, \n+\t\t\t\t   const streamsize __oldlen, const bool __num)\n+    {\n+      size_t __plen = static_cast<size_t>(__newlen - __oldlen);\n+      _CharT* __pads = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT) * __plen));\n+      _Traits::assign(__pads, __plen, __fill); \n+\n+      _CharT* __beg;\n+      _CharT* __end;\n       size_t __mod = 0;\n       size_t __beglen; //either __plen or __oldlen\n       ios_base::fmtflags __adjust = __io.flags() & ios_base::adjustfield;\n \n       if (__adjust == ios_base::left)\n \t{\n \t  // Padding last.\n-\t  __beg = const_cast<char_type*>(__olds);\n+\t  __beg = const_cast<_CharT*>(__olds);\n \t  __beglen = __oldlen;\n \t  __end = __pads;\n \t}\n@@ -2030,12 +2056,14 @@ namespace std\n \t  // Who came up with these rules, anyway? Jeeze.\n           locale __loc = __io.getloc();\n \t  const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc); \n-\t  const char_type __minus = __ctype.widen('-');\n-\t  const char_type __plus = __ctype.widen('+');\n-\t  bool __testsign = __olds[0] == __minus || __olds[0] == __plus;\n-\t  bool __testhex = __ctype.widen('0') == __olds[0] \n-\t                   && (__ctype.widen('x') == __olds[1] \n-\t\t\t       || __ctype.widen('X') == __olds[1]);\n+\t  const _CharT __minus = __ctype.widen('-');\n+\t  const _CharT __plus = __ctype.widen('+');\n+\t  bool __testsign = _Traits::eq(__olds[0], __minus)\n+\t    \t\t    || _Traits::eq(__olds[0], __plus);\n+\n+\t  bool __testhex = _Traits::eq(__ctype.widen('0'), __olds[0]) \n+\t    \t\t   && (_Traits::eq(__ctype.widen('x'), __olds[1]) \n+\t\t\t       || _Traits::eq(__ctype.widen('X'), __olds[1]));\n \t  if (__testhex)\n \t    {\n \t      __news[0] = __olds[0]; \n@@ -2044,47 +2072,35 @@ namespace std\n \t      __news += 2;\n \t      __beg = __pads;\n \t      __beglen = __plen;\n-\t      __end = const_cast<char_type*>(__olds + __mod);\n+\t      __end = const_cast<_CharT*>(__olds + __mod);\n \t    }\n \t  else if (__testsign)\n \t    {\n-\t      __news[0] = __olds[0] == __plus ? __plus : __minus;\n+\t      _Traits::eq((__news[0] = __olds[0]), __plus) ? __plus : __minus;\n \t      ++__mod;\n \t      ++__news;\n \t      __beg = __pads;\n \t      __beglen = __plen;\n-\t      __end = const_cast<char_type*>(__olds + __mod);\n+\t      __end = const_cast<_CharT*>(__olds + __mod);\n \t    }\n \t  else\n \t    {\n \t      // Padding first.\n \t      __beg = __pads;\n \t      __beglen = __plen;\n-\t      __end = const_cast<char_type*>(__olds);\n+\t      __end = const_cast<_CharT*>(__olds);\n \t    }\n \t}\n       else\n \t{\n \t  // Padding first.\n \t  __beg = __pads;\n \t  __beglen = __plen;\n-\t  __end = const_cast<char_type*>(__olds);\n+\t  __end = const_cast<_CharT*>(__olds);\n \t}\n-      traits_type::copy(__news, __beg, __beglen);\n-      traits_type::copy(__news + __beglen, __end, __newlen - __beglen - __mod);\n-    }\n-\n-  // NB: Can't have default argument on non-member template, and\n-  // num_put doesn't have a _Traits template parameter, so this\n-  // forwarding template adds in the default template argument.\n-  template<typename _CharT>\n-    void\n-    __pad(ios_base& __io, _CharT __fill, _CharT* __news, const _CharT* __olds,\n-\t  const streamsize __newlen, const streamsize __oldlen, \n-\t  const bool __num)\n-    { \n-      return __pad<_CharT, char_traits<_CharT> >(__io, __fill, __news, __olds,\n-\t\t\t\t\t\t __newlen, __oldlen, __num); \n+      _Traits::copy(__news, __beg, __beglen);\n+      _Traits::copy(__news + __beglen, __end, \n+\t\t\t  __newlen - __beglen - __mod);\n     }\n \n   // Used by both numeric and monetary facets.\n@@ -2401,5 +2417,3 @@ namespace std\n } // namespace std\n \n #endif\n-\n-"}, {"sha": "e42eca29192f2ce01e51a567c937db439cc168b5", "filename": "libstdc++-v3/include/bits/ostream.tcc", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f13a69eccf8e409e1046f6bc1df333f0bf69cb6f/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fostream.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f13a69eccf8e409e1046f6bc1df333f0bf69cb6f/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fostream.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fostream.tcc?ref=f13a69eccf8e409e1046f6bc1df333f0bf69cb6f", "patch": "@@ -474,7 +474,8 @@ namespace std\n \t      streamsize __len = 1;\n \t      if (__w > __len)\n \t\t{\n-\t\t  __pad(__out, __out.fill(), __pads, &__c, __w, __len, false);\n+\t\t  __pad<_CharT, _Traits>::_S_pad(__out, __out.fill(), __pads, \n+\t\t\t\t\t\t &__c, __w, __len, false);\n \t\t  __len = __w;\n \t\t}\n \t      __out.write(__pads, __len);\n@@ -509,7 +510,8 @@ namespace std\n \t      streamsize __len = 1;\n \t      if (__w > __len)\n \t\t{\n-\t\t  __pad(__out, __out.fill(), __pads, &__c, __w, __len, false);\n+\t\t  __pad<char, _Traits>::_S_pad(__out, __out.fill(), __pads, \n+\t\t\t\t\t       &__c, __w, __len, false);\n \t\t  __len = __w;\n \t\t}\n \t      __out.write(__pads, __len);\n@@ -542,7 +544,8 @@ namespace std\n \t      streamsize __len = static_cast<streamsize>(_Traits::length(__s));\n \t      if (__w > __len)\n \t\t{\n-\t\t  __pad(__out, __out.fill(), __pads, __s, __w, __len, false);\n+\t\t  __pad<_CharT, _Traits>::_S_pad(__out, __out.fill(), __pads, \n+\t\t\t\t\t\t __s, __w, __len, false);\n \t\t  __s = __pads;\n \t\t  __len = __w;\n \t\t}\n@@ -590,7 +593,8 @@ namespace std\n \t      \n \t      if (__w > __len)\n \t\t{\n-\t\t  __pad(__out, __out.fill(), __pads, __ws, __w, __len, false);\n+\t\t  __pad<_CharT, _Traits>::_S_pad(__out, __out.fill(), __pads, \n+\t\t\t\t\t\t __ws, __w, __len, false);\n \t\t  __str = __pads;\n \t\t  __len = __w;\n \t\t}\n@@ -628,7 +632,8 @@ namespace std\n \n \t      if (__w > __len)\n \t\t{\n-\t\t  __pad(__out, __out.fill(), __pads, __s, __w, __len, false);\n+\t\t  __pad<char, _Traits>::_S_pad(__out, __out.fill(), __pads, \n+\t\t\t\t\t\t __s, __w, __len, false);\n \t\t  __s = __pads;\n \t\t  __len = __w;\n \t\t}\n@@ -668,7 +673,8 @@ namespace std\n #endif\n \t  if (__w > __len)\n \t    {\n-\t      __pad(__out, __out.fill(), __pads, __s, __w, __len, false);\n+\t      __pad<_CharT, _Traits>::_S_pad(__out, __out.fill(), __pads, __s, \n+\t\t\t\t\t     __w, __len, false);\n \t      __s = __pads;\n \t      __len = __w;\n \t    }"}, {"sha": "99eb6af125f576a3fc26ce93641ee9383cbb0a3f", "filename": "libstdc++-v3/include/bits/sstream.tcc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f13a69eccf8e409e1046f6bc1df333f0bf69cb6f/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fsstream.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f13a69eccf8e409e1046f6bc1df333f0bf69cb6f/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fsstream.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fsstream.tcc?ref=f13a69eccf8e409e1046f6bc1df333f0bf69cb6f", "patch": "@@ -184,7 +184,7 @@ namespace std\n       \n       if (_M_buf_size)\n \t{\n-\t  off_type __pos = __sp._M_position();\n+\t  off_type __pos = __sp; // Use streamoff operator to do conversion.\n \t  char_type* __beg = NULL;\n \t  char_type* __end = NULL;\n \t  bool __testin = (ios_base::in & _M_mode & __mode) != 0;"}, {"sha": "152df9c6e4b993ad91272e2cfdaea31d27df423c", "filename": "libstdc++-v3/include/bits/streambuf_iterator.h", "status": "modified", "additions": 17, "deletions": 12, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f13a69eccf8e409e1046f6bc1df333f0bf69cb6f/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstreambuf_iterator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f13a69eccf8e409e1046f6bc1df333f0bf69cb6f/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstreambuf_iterator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstreambuf_iterator.h?ref=f13a69eccf8e409e1046f6bc1df333f0bf69cb6f", "patch": "@@ -69,13 +69,13 @@ namespace std\n \n     public:\n       istreambuf_iterator() throw() \n-      : _M_sbuf(0), _M_c(-2) { }\n+      : _M_sbuf(0), _M_c(traits_type::eof()) { }\n       \n       istreambuf_iterator(istream_type& __s) throw()\n-      : _M_sbuf(__s.rdbuf()), _M_c(-2) { }\n+      : _M_sbuf(__s.rdbuf()), _M_c(traits_type::eof()) { }\n \n       istreambuf_iterator(streambuf_type* __s) throw()\n-      : _M_sbuf(__s), _M_c(-2) { }\n+      : _M_sbuf(__s), _M_c(traits_type::eof()) { }\n        \n       // NB: The result of operator*() on an end of stream is undefined.\n       char_type \n@@ -85,21 +85,25 @@ namespace std\n       istreambuf_iterator& \n       operator++()\n       { \n-\tif (_M_sbuf && _M_sbuf->sbumpc() == traits_type::eof())\n+\tconst int_type __eof = traits_type::eof();\n+\tif (_M_sbuf && traits_type::eq_int_type(_M_sbuf->sbumpc(), __eof))\n \t  _M_sbuf = 0;\n \telse\n-\t  _M_c = -2;\n+\t  _M_c = __eof;\n \treturn *this; \n       }\n \n       istreambuf_iterator\n       operator++(int)\n       {\n+\tconst int_type __eof = traits_type::eof();\n \tistreambuf_iterator __old = *this;\n-\tif (_M_sbuf && (__old._M_c = _M_sbuf->sbumpc()) == traits_type::eof())\n+\tif (_M_sbuf\n+\t    && traits_type::eq_int_type((__old._M_c = _M_sbuf->sbumpc()), \n+\t\t\t\t\t__eof))\n \t  _M_sbuf = 0;\n \telse\n-\t  _M_c = -2;\n+\t  _M_c = __eof;\n \treturn __old; \n       }\n \n@@ -110,8 +114,8 @@ namespace std\n       equal(const istreambuf_iterator& __b) const\n       {\n \tconst int_type __eof = traits_type::eof();\n-\tbool __thiseof = _M_get() == __eof;\n-\tbool __beof = __b._M_get() == __eof;\n+\tbool __thiseof = traits_type::eq_int_type(_M_get(), __eof);\n+\tbool __beof = traits_type::eq_int_type(__b._M_get(), __eof);\n \treturn (__thiseof && __beof || (!__thiseof && !__beof));\n       }\n #endif\n@@ -120,13 +124,14 @@ namespace std\n       int_type \n       _M_get() const\n       { \n-\tint_type __ret = traits_type::eof();\n+\tconst int_type __eof = traits_type::eof();\n+\tint_type __ret = __eof;\n \tif (_M_sbuf)\n \t  { \n-\t    if (_M_c != static_cast<int_type>(-2))\n+\t    if (!traits_type::eq_int_type(_M_c, __eof))\n \t      __ret = _M_c;\n \t    else \n-\t      if ((__ret = _M_sbuf->sgetc()) == traits_type::eof())\n+\t      if (traits_type::eq_int_type((__ret = _M_sbuf->sgetc()), __eof))\n \t\t_M_sbuf = 0;\n \t  }\n \treturn __ret;"}, {"sha": "c3861051d40b8bff745722521b78c35099559fda", "filename": "libstdc++-v3/include/std/std_fstream.h", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f13a69eccf8e409e1046f6bc1df333f0bf69cb6f/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_fstream.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f13a69eccf8e409e1046f6bc1df333f0bf69cb6f/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_fstream.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_fstream.h?ref=f13a69eccf8e409e1046f6bc1df333f0bf69cb6f", "patch": "@@ -286,7 +286,16 @@ namespace std\n       }\n     };\n \n-\n+  // Explicit specializations.\n+  template<> \n+    basic_filebuf<char>::int_type \n+    basic_filebuf<char>::_M_underflow_common(bool __bump);\n+\n+ #ifdef _GLIBCPP_USE_WCHAR_T\n+  template<> \n+    basic_filebuf<wchar_t>::int_type \n+    basic_filebuf<wchar_t>::_M_underflow_common(bool __bump);\n+ #endif\n \n   // 27.8.1.5  Template class basic_ifstream\n   /**"}, {"sha": "ecd546e85a80f0a7b94c62a90b8754c621ecdea7", "filename": "libstdc++-v3/include/std/std_streambuf.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f13a69eccf8e409e1046f6bc1df333f0bf69cb6f/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_streambuf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f13a69eccf8e409e1046f6bc1df333f0bf69cb6f/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_streambuf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_streambuf.h?ref=f13a69eccf8e409e1046f6bc1df333f0bf69cb6f", "patch": "@@ -71,6 +71,7 @@ namespace std\n       // Non-standard Types:\n       typedef ctype<char_type>           \t\t__ctype_type;\n       typedef basic_streambuf<char_type, traits_type>  \t__streambuf_type;\n+      typedef typename traits_type::state_type \t\t__state_type;\n       \n       friend class basic_ios<char_type, traits_type>;\n       friend class basic_istream<char_type, traits_type>;\n@@ -132,6 +133,9 @@ namespace std\n       char_type*\t\t_M_pback_end_save;\n       bool\t\t\t_M_pback_init; \n \n+      // Yet unused.\n+      fpos<__state_type>\t_M_pos;\n+\n       // Initializes pback buffers, and moves normal buffers to safety.\n       // Assumptions:\n       // _M_in_cur has already been moved back"}, {"sha": "120841b1239326568ae78f23642bc9c5a3d2e6d2", "filename": "libstdc++-v3/src/Makefile.am", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f13a69eccf8e409e1046f6bc1df333f0bf69cb6f/libstdc%2B%2B-v3%2Fsrc%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f13a69eccf8e409e1046f6bc1df333f0bf69cb6f/libstdc%2B%2B-v3%2Fsrc%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2FMakefile.am?ref=f13a69eccf8e409e1046f6bc1df333f0bf69cb6f", "patch": "@@ -70,6 +70,7 @@ sources = \\\n \tconcept-inst.cc \\\n \tctype.cc \\\n \text-inst.cc \\\n+\tfstream.cc \\\n \tfstream-inst.cc \\\n \tfunctexcept.cc \\\n \tglobals.cc \\"}, {"sha": "0ad606a8a00538c13a58e7879f6e39e3a79a550a", "filename": "libstdc++-v3/src/Makefile.in", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f13a69eccf8e409e1046f6bc1df333f0bf69cb6f/libstdc%2B%2B-v3%2Fsrc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f13a69eccf8e409e1046f6bc1df333f0bf69cb6f/libstdc%2B%2B-v3%2Fsrc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2FMakefile.in?ref=f13a69eccf8e409e1046f6bc1df333f0bf69cb6f", "patch": "@@ -175,6 +175,7 @@ sources = \\\n \tconcept-inst.cc \\\n \tctype.cc \\\n \text-inst.cc \\\n+\tfstream.cc \\\n \tfstream-inst.cc \\\n \tfunctexcept.cc \\\n \tglobals.cc \\\n@@ -279,7 +280,7 @@ LDFLAGS = @LDFLAGS@\n LIBS = @LIBS@\n libstdc___la_OBJECTS =  basic_file.lo bitset.lo c++locale.lo codecvt.lo \\\n collate.lo complex_io.lo concept-inst.lo ctype.lo ext-inst.lo \\\n-fstream-inst.lo functexcept.lo globals.lo io-inst.lo ios.lo \\\n+fstream.lo fstream-inst.lo functexcept.lo globals.lo io-inst.lo ios.lo \\\n istream-inst.lo limits.lo locale-inst.lo locale.lo localename.lo \\\n messages.lo misc-inst.lo monetary.lo numeric.lo ostream-inst.lo \\\n sstream-inst.lo stdexcept.lo stl-inst.lo streambuf-inst.lo \\"}, {"sha": "5e6c6751bc449bbd86fafd65197da72308552583", "filename": "libstdc++-v3/src/locale-inst.cc", "status": "modified", "additions": 11, "deletions": 24, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f13a69eccf8e409e1046f6bc1df333f0bf69cb6f/libstdc%2B%2B-v3%2Fsrc%2Flocale-inst.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f13a69eccf8e409e1046f6bc1df333f0bf69cb6f/libstdc%2B%2B-v3%2Fsrc%2Flocale-inst.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Flocale-inst.cc?ref=f13a69eccf8e409e1046f6bc1df333f0bf69cb6f", "patch": "@@ -420,15 +420,7 @@ namespace std\n     bool\n     __verify_grouping<char>(const basic_string<char>&, basic_string<char>&);\n \n-  template\n-    void \n-    __pad<char>(ios_base&, char, char*, const char *, streamsize, \n-\t\tstreamsize, const bool);\n-\n-  template\n-    void \n-    __pad<char, char_traits<char> >(ios_base&, char, char*, const char *, \n-\t\t\t\t    streamsize, streamsize, const bool);\n+  template class __pad<char, char_traits<char> >;\n \n #ifdef _GLIBCPP_USE_WCHAR_T\n   template\n@@ -440,29 +432,23 @@ namespace std\n     __verify_grouping<wchar_t>(const basic_string<wchar_t>&, \n \t\t\t       basic_string<wchar_t>&);\n \n-  template\n-    void \n-    __pad<wchar_t>(ios_base&, wchar_t, wchar_t*, const wchar_t*, \n-\t\t   streamsize, streamsize, const bool);\n-\n-  template\n-    void \n-    __pad<wchar_t, char_traits<wchar_t> >(ios_base&, wchar_t, wchar_t*, \n-\t\t\t\t\t  const wchar_t*, streamsize, \n-\t\t\t\t\t  streamsize, const bool);\n-#endif // _GLIBCPP_USE_WCHAR_T\n+  template class __pad<wchar_t, char_traits<wchar_t> >;\n+#endif \n \n   template\n     int\n-    __convert_from_v(char*, const int, const char*, double, const __c_locale&, int);\n+    __convert_from_v(char*, const int, const char*, double, \n+\t\t     const __c_locale&, int);\n \n   template\n     int\n-    __convert_from_v(char*, const int, const char*, long double, const __c_locale&, int);\n+    __convert_from_v(char*, const int, const char*, long double, \n+\t\t     const __c_locale&, int);\n \n   template\n     int\n-    __convert_from_v(char*, const int, const char*, long, const __c_locale&, int);\n+    __convert_from_v(char*, const int, const char*, long, \n+\t\t     const __c_locale&, int);\n \n   template\n     int\n@@ -471,7 +457,8 @@ namespace std\n \n   template\n     int\n-    __convert_from_v(char*, const int, const char*, long long, const __c_locale&, int);\n+    __convert_from_v(char*, const int, const char*, long long, \n+\t\t     const __c_locale&, int);\n \n   template\n     int"}, {"sha": "3c45b0050170d11b465e0f24e8d7df4169c221b0", "filename": "libstdc++-v3/testsuite/21_strings/capacity.cc", "status": "modified", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f13a69eccf8e409e1046f6bc1df333f0bf69cb6f/libstdc%2B%2B-v3%2Ftestsuite%2F21_strings%2Fcapacity.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f13a69eccf8e409e1046f6bc1df333f0bf69cb6f/libstdc%2B%2B-v3%2Ftestsuite%2F21_strings%2Fcapacity.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F21_strings%2Fcapacity.cc?ref=f13a69eccf8e409e1046f6bc1df333f0bf69cb6f", "patch": "@@ -36,6 +36,93 @@ template<typename T>\n \n struct B { };\n \n+// char_traits specialization\n+namespace std\n+{\n+  template<>\n+    struct char_traits<A<B> >\n+    {\n+      typedef A<B> \t\tchar_type;\n+      // Unsigned as wint_t in unsigned.\n+      typedef unsigned long  \tint_type;\n+      typedef streampos \tpos_type;\n+      typedef streamoff \toff_type;\n+      typedef mbstate_t \tstate_type;\n+      \n+      static void \n+      assign(char_type& __c1, const char_type& __c2)\n+      { __c1 = __c2; }\n+\n+      static bool \n+      eq(const char_type& __c1, const char_type& __c2)\n+      { return __c1 == __c2; }\n+\n+      static bool \n+      lt(const char_type& __c1, const char_type& __c2)\n+      { return __c1 < __c2; }\n+\n+      static int \n+      compare(const char_type* __s1, const char_type* __s2, size_t __n)\n+      { \n+\tfor (size_t __i = 0; __i < __n; ++__i)\n+\t  if (!eq(__s1[__i], __s2[__i]))\n+\t    return lt(__s1[__i], __s2[__i]) ? -1 : 1;\n+\treturn 0; \n+      }\n+\n+      static size_t\n+      length(const char_type* __s)\n+      { \n+\tconst char_type* __p = __s; \n+\twhile (__p) \n+\t  ++__p; \n+\treturn (__p - __s); \n+      }\n+\n+      static const char_type* \n+      find(const char_type* __s, size_t __n, const char_type& __a)\n+      { \n+\tfor (const char_type* __p = __s; size_t(__p - __s) < __n; ++__p)\n+\t  if (*__p == __a) return __p;\n+\treturn 0;\n+      }\n+\n+      static char_type* \n+      move(char_type* __s1, const char_type* __s2, size_t __n)\n+      { return (char_type*) memmove(__s1, __s2, __n * sizeof(char_type)); }\n+\n+      static char_type* \n+      copy(char_type* __s1, const char_type* __s2, size_t __n)\n+      { return (char_type*) memcpy(__s1, __s2, __n * sizeof(char_type)); }\n+\n+      static char_type* \n+      assign(char_type* __s, size_t __n, char_type __a)\n+      { \n+\tfor (char_type* __p = __s; __p < __s + __n; ++__p) \n+\t  assign(*__p, __a);\n+        return __s; \n+      }\n+\n+      static char_type \n+      to_char_type(const int_type& __c)\n+      { return char_type(); }\n+\n+      static int_type \n+      to_int_type(const char_type& __c) { return int_type(); }\n+\n+      static bool \n+      eq_int_type(const int_type& __c1, const int_type& __c2)\n+      { return __c1 == __c2; }\n+\n+      static int_type \n+      eof() { return static_cast<int_type>(-1); }\n+\n+      static int_type \n+      not_eof(const int_type& __c)\n+      { return eq_int_type(__c, eof()) ? int_type(0) : __c; }\n+    };\n+} // namespace std\n+\n void test01()\n {\n   // 1 POD types : resize, capacity, reserve"}, {"sha": "51bf9b9600ad4107c36c4ce497d4e9f1f3cea62b", "filename": "libstdc++-v3/testsuite/22_locale/codecvt_members_unicode_char.cc", "status": "modified", "additions": 65, "deletions": 3, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f13a69eccf8e409e1046f6bc1df333f0bf69cb6f/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt_members_unicode_char.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f13a69eccf8e409e1046f6bc1df333f0bf69cb6f/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt_members_unicode_char.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt_members_unicode_char.cc?ref=f13a69eccf8e409e1046f6bc1df333f0bf69cb6f", "patch": "@@ -23,10 +23,71 @@\n #include <locale>\n #include <testsuite_hooks.h>\n \n-using namespace std;\n+\n \n #ifdef _GLIBCPP_USE___ENC_TRAITS\n \n+// Need some char_traits specializations for this to work.\n+typedef unsigned short\t\t\tunicode_t;\n+\n+namespace std\n+{\n+  template<>\n+    struct char_traits<unicode_t>\n+    {\n+      typedef unicode_t \tchar_type;\n+      // Unsigned as wint_t is unsigned.\n+      typedef unsigned long  \tint_type;\n+      typedef streampos \tpos_type;\n+      typedef streamoff \toff_type;\n+      typedef mbstate_t \tstate_type;\n+      \n+      static void \n+      assign(char_type& __c1, const char_type& __c2);\n+\n+      static bool \n+      eq(const char_type& __c1, const char_type& __c2);\n+\n+      static bool \n+      lt(const char_type& __c1, const char_type& __c2);\n+\n+      static int \n+      compare(const char_type* __s1, const char_type* __s2, size_t __n)\n+      { return memcmp(__s1, __s2, __n); }\n+\n+      static size_t\n+      length(const char_type* __s);\n+\n+      static const char_type* \n+      find(const char_type* __s, size_t __n, const char_type& __a);\n+\n+      static char_type* \n+      move(char_type* __s1, const char_type* __s2, size_t __n);\n+\n+      static char_type* \n+      copy(char_type* __s1, const char_type* __s2, size_t __n)\n+      {  return static_cast<char_type*>(memcpy(__s1, __s2, __n)); }\n+\n+      static char_type* \n+      assign(char_type* __s, size_t __n, char_type __a);\n+\n+      static char_type \n+      to_char_type(const int_type& __c);\n+\n+      static int_type \n+      to_int_type(const char_type& __c);\n+\n+      static bool \n+      eq_int_type(const int_type& __c1, const int_type& __c2);\n+\n+      static int_type \n+      eof(); \n+\n+      static int_type \n+      not_eof(const int_type& __c);\n+    };\n+}\n+\n /*\n > how do I check that these conversions are correct? \n Very easy.  Since all the characters are from ASCII you simply\n@@ -51,16 +112,16 @@ it shows that the other byte-order is used (25856 == 0x6500).\n \n \n void\n-initialize_state(__enc_traits& state)\n+initialize_state(std::__enc_traits& state)\n { state._M_init(); }\n \n // Partial specialization using __enc_traits.\n // codecvt<unicode_t, char, __enc_traits>\n // UNICODE - UCS2 (big endian)\n void test01()\n {\n+  using namespace std;\n   typedef codecvt_base::result\t\t\tresult;\n-  typedef unsigned short\t\t\tunicode_t;\n   typedef unicode_t\t\t\t\tint_type;\n   typedef char\t\t\t\t\text_type;\n   typedef __enc_traits\t\t\t\tenc_type;\n@@ -146,6 +207,7 @@ void test01()\n // UNICODE - UCS2 (little endian)\n void test02()\n {\n+  using namespace std;\n   typedef codecvt_base::result\t\t\tresult;\n   typedef unsigned short\t\t\tunicode_t;\n   typedef unicode_t\t\t\t\tint_type;"}, {"sha": "c944865b08fd7e7c2c697a57d212f3fe5411fdae", "filename": "libstdc++-v3/testsuite/22_locale/codecvt_members_unicode_wchar_t.cc", "status": "modified", "additions": 64, "deletions": 5, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f13a69eccf8e409e1046f6bc1df333f0bf69cb6f/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt_members_unicode_wchar_t.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f13a69eccf8e409e1046f6bc1df333f0bf69cb6f/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt_members_unicode_wchar_t.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fcodecvt_members_unicode_wchar_t.cc?ref=f13a69eccf8e409e1046f6bc1df333f0bf69cb6f", "patch": "@@ -1,6 +1,6 @@\n // 2000-08-23 Benjamin Kosnik <bkoz@cygnus.com>\n \n-// Copyright (C) 2000, 2001 Free Software Foundation\n+// Copyright (C) 2000, 2001, 2002 Free Software Foundation\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -23,21 +23,80 @@\n #include <locale>\n #include <testsuite_hooks.h>\n \n-using namespace std;\n-\n #ifdef _GLIBCPP_USE___ENC_TRAITS\n #ifdef _GLIBCPP_USE_WCHAR_T\n \n+// Need some char_traits specializations for this to work.\n+typedef unsigned short\t\t\tunicode_t;\n+\n+namespace std\n+{\n+  template<>\n+    struct char_traits<unicode_t>\n+    {\n+      typedef unicode_t \tchar_type;\n+      // Unsigned as wint_t is unsigned.\n+      typedef unsigned long  \tint_type;\n+      typedef streampos \tpos_type;\n+      typedef streamoff \toff_type;\n+      typedef mbstate_t \tstate_type;\n+      \n+      static void \n+      assign(char_type& __c1, const char_type& __c2);\n+\n+      static bool \n+      eq(const char_type& __c1, const char_type& __c2);\n+\n+      static bool \n+      lt(const char_type& __c1, const char_type& __c2);\n+\n+      static int \n+      compare(const char_type* __s1, const char_type* __s2, size_t __n)\n+      { return memcmp(__s1, __s2, __n); }\n+\n+      static size_t\n+      length(const char_type* __s);\n+\n+      static const char_type* \n+      find(const char_type* __s, size_t __n, const char_type& __a);\n+\n+      static char_type* \n+      move(char_type* __s1, const char_type* __s2, size_t __n);\n+\n+      static char_type* \n+      copy(char_type* __s1, const char_type* __s2, size_t __n)\n+      {  return static_cast<char_type*>(memcpy(__s1, __s2, __n)); }\n+\n+      static char_type* \n+      assign(char_type* __s, size_t __n, char_type __a);\n+\n+      static char_type \n+      to_char_type(const int_type& __c);\n+\n+      static int_type \n+      to_int_type(const char_type& __c);\n+\n+      static bool \n+      eq_int_type(const int_type& __c1, const int_type& __c2);\n+\n+      static int_type \n+      eof(); \n+\n+      static int_type \n+      not_eof(const int_type& __c);\n+    };\n+}\n+\n void\n-initialize_state(__enc_traits& state)\n+initialize_state(std::__enc_traits& state)\n { state._M_init(); }\n \n // Partial specialization using __enc_traits.\n // codecvt<unicode_t, wchar_t, __enc_traits>\n void test01()\n {\n+  using namespace std;\n   typedef codecvt_base::result\t\t\tresult;\n-  typedef unsigned short\t\t\tunicode_t;\n   typedef unicode_t\t\t\t\tint_type;\n   typedef wchar_t\t\t\t\text_type;\n   typedef __enc_traits\t\t\t\tenc_type;"}, {"sha": "94db3bcc139675406e0e73376b6743f2f762e839", "filename": "libstdc++-v3/testsuite/22_locale/ctor_copy_dtor.cc", "status": "modified", "additions": 61, "deletions": 2, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f13a69eccf8e409e1046f6bc1df333f0bf69cb6f/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fctor_copy_dtor.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f13a69eccf8e409e1046f6bc1df333f0bf69cb6f/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fctor_copy_dtor.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fctor_copy_dtor.cc?ref=f13a69eccf8e409e1046f6bc1df333f0bf69cb6f", "patch": "@@ -48,11 +48,70 @@ class gnu_facet: public std::locale::facet\n \n std::locale::id gnu_facet::id;\n \n+// Need some char_traits specializations for this to work.\n+typedef unsigned short\t\t\tunicode_t;\n+\n+namespace std\n+{\n+  template<>\n+    struct char_traits<unicode_t>\n+    {\n+      typedef unicode_t \tchar_type;\n+      // Unsigned as wint_t is unsigned.\n+      typedef unsigned long  \tint_type;\n+      typedef streampos \tpos_type;\n+      typedef streamoff \toff_type;\n+      typedef mbstate_t \tstate_type;\n+      \n+      static void \n+      assign(char_type& __c1, const char_type& __c2);\n+\n+      static bool \n+      eq(const char_type& __c1, const char_type& __c2);\n+\n+      static bool \n+      lt(const char_type& __c1, const char_type& __c2);\n+\n+      static int \n+      compare(const char_type* __s1, const char_type* __s2, size_t __n)\n+      { return memcmp(__s1, __s2, __n); }\n+\n+      static size_t\n+      length(const char_type* __s);\n+\n+      static const char_type* \n+      find(const char_type* __s, size_t __n, const char_type& __a);\n+\n+      static char_type* \n+      move(char_type* __s1, const char_type* __s2, size_t __n);\n+\n+      static char_type* \n+      copy(char_type* __s1, const char_type* __s2, size_t __n)\n+      {  return static_cast<char_type*>(memcpy(__s1, __s2, __n)); }\n+\n+      static char_type* \n+      assign(char_type* __s, size_t __n, char_type __a);\n+\n+      static char_type \n+      to_char_type(const int_type& __c);\n+\n+      static int_type \n+      to_int_type(const char_type& __c);\n+\n+      static bool \n+      eq_int_type(const int_type& __c1, const int_type& __c2);\n+\n+      static int_type \n+      eof(); \n+\n+      static int_type \n+      not_eof(const int_type& __c);\n+    };\n+}\n+\n void test01()\n {\n   using namespace std;\n-\n-  typedef unsigned short\t\t\tunicode_t;\n   typedef unicode_t\t\t\t\tint_type;\n   typedef char\t\t\t\t\text_type;\n   typedef __enc_traits\t\t\t\tenc_type;"}, {"sha": "e72f2ca8f6f78493b15081b682469fc215b65cb0", "filename": "libstdc++-v3/testsuite/27_io/filebuf.cc", "status": "modified", "additions": 57, "deletions": 1, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f13a69eccf8e409e1046f6bc1df333f0bf69cb6f/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilebuf.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f13a69eccf8e409e1046f6bc1df333f0bf69cb6f/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilebuf.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilebuf.cc?ref=f13a69eccf8e409e1046f6bc1df333f0bf69cb6f", "patch": "@@ -42,11 +42,67 @@ void test01()\n // test05\n // libstdc++/1886\n // should be able to instantiate basic_filebuf for non-standard types.\n-template class std::basic_filebuf<short, std::char_traits<short> >;\n+namespace test \n+{\n+  using namespace std;\n+  typedef short type_t;\n+  template class basic_filebuf<type_t, char_traits<type_t> >;\n+  template class basic_filebuf<gnu_char, char_traits<gnu_char> >;\n+} // test\n+\n+\n+// test07\n+// libstdc++/2020\n+// should be able to use custom char_type\n+class gnu_char_type\n+{\n+  unsigned long character;\n+public:\n+  // operator ==\n+  bool\n+  operator==(const gnu_char_type& __lhs) \n+  { return character == __lhs.character; }\n+\n+  // operator <\n+  bool\n+  operator<(const gnu_char_type& __lhs) \n+  { return character < __lhs.character; }\n+\n+  // default ctor\n+  gnu_char_type() { }\n+\n+  // to_char_type\n+  gnu_char_type(const unsigned long& __l) : character(__l) { } \n+\n+  // to_int_type\n+  operator unsigned long() const { return character; }\n+};\n+\n+void test07()\n+{\n+  bool test = true;\n+  typedef std::basic_filebuf<gnu_char_type> gnu_filebuf;\n+  \n+  try\n+    { gnu_filebuf obj; }\n+  catch(std::exception& obj)\n+    { \n+      test = false; \n+      VERIFY( test );\n+    }\n+}\n+\n+#if !__GXX_WEAK__\n+// Explicitly instantiate for systems with no COMDAT or weak support.\n+template \n+  std::basic_streambuf<gnu_char_type>::int_type\n+  std::basic_streambuf<gnu_char_type>::_S_pback_size;\n+#endif\n \n int main() \n {\n   test01();\n+  test07();\n   return 0;\n }\n "}, {"sha": "0a92788296a5b0e50e0fe7dcef0015a3f683959b", "filename": "libstdc++-v3/testsuite/27_io/filebuf_virtuals.cc", "status": "modified", "additions": 0, "deletions": 49, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f13a69eccf8e409e1046f6bc1df333f0bf69cb6f/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilebuf_virtuals.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f13a69eccf8e409e1046f6bc1df333f0bf69cb6f/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilebuf_virtuals.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilebuf_virtuals.cc?ref=f13a69eccf8e409e1046f6bc1df333f0bf69cb6f", "patch": "@@ -514,54 +514,6 @@ void test06()\n   VERIFY( buffer[0] == 'a' );\n }\n \n-// test06\n-// libstdc++/2020\n-// should be able to use custom char_type\n-class gnu_char_type\n-{\n-  unsigned long character;\n-public:\n-  // operator ==\n-  bool\n-  operator==(const gnu_char_type& __lhs) \n-  { return character == __lhs.character; }\n-\n-  // operator <\n-  bool\n-  operator<(const gnu_char_type& __lhs) \n-  { return character < __lhs.character; }\n-\n-  // default ctor\n-  gnu_char_type() { }\n-\n-  // to_char_type\n-  gnu_char_type(const unsigned long& __l) : character(__l) { } \n-\n-  // to_int_type\n-  operator unsigned long() const { return character; }\n-};\n-\n-void test07()\n-{\n-  bool test = true;\n-  typedef std::basic_filebuf<gnu_char_type> gnu_filebuf;\n-  \n-  try\n-    { gnu_filebuf obj; }\n-  catch(std::exception& obj)\n-    { \n-      test = false; \n-      VERIFY( test );\n-    }\n-}\n-\n-#if !__GXX_WEAK__\n-// Explicitly instantiate for systems with no COMDAT or weak support.\n-template \n-  std::basic_streambuf<gnu_char_type>::int_type\n-  std::basic_streambuf<gnu_char_type>::_S_pback_size;\n-#endif\n-\n main() \n {\n   test01();\n@@ -571,7 +523,6 @@ main()\n   test04();\n   test05();\n   test06();\n-  test07();\n \n   return 0;\n }"}, {"sha": "276294d9c9d4c2c6b424cb370153657ae380e0b6", "filename": "libstdc++-v3/testsuite/27_io/fstream.cc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f13a69eccf8e409e1046f6bc1df333f0bf69cb6f/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffstream.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f13a69eccf8e409e1046f6bc1df333f0bf69cb6f/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffstream.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffstream.cc?ref=f13a69eccf8e409e1046f6bc1df333f0bf69cb6f", "patch": "@@ -31,6 +31,7 @@\n // NB: This file is for testing basic_fstream with NO OTHER INCLUDES.\n \n #include <fstream>\n+#include <testsuite_hooks.h>\n \n // { dg-do compile }\n \n@@ -51,6 +52,7 @@ namespace test\n   using namespace std;\n   typedef short type_t;\n   template class basic_fstream<type_t, char_traits<type_t> >;\n+  template class basic_fstream<gnu_char, char_traits<gnu_char> >;\n } // test\n \n int main() "}, {"sha": "33a52de9470e43f098f80bd75d920e5fb16997c1", "filename": "libstdc++-v3/testsuite/27_io/ios_init.cc", "status": "modified", "additions": 170, "deletions": 0, "changes": 170, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f13a69eccf8e409e1046f6bc1df333f0bf69cb6f/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fios_init.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f13a69eccf8e409e1046f6bc1df333f0bf69cb6f/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fios_init.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fios_init.cc?ref=f13a69eccf8e409e1046f6bc1df333f0bf69cb6f", "patch": "@@ -34,6 +34,176 @@\n #include <iostream>\n #include <testsuite_hooks.h>\n \n+// char_traits specialization\n+namespace std\n+{\n+  template<>\n+    struct char_traits<unsigned short>\n+    {\n+      typedef unsigned short \tchar_type;\n+      // Unsigned as wint_t in unsigned.\n+      typedef unsigned long  \tint_type;\n+      typedef streampos \tpos_type;\n+      typedef streamoff \toff_type;\n+      typedef mbstate_t \tstate_type;\n+      \n+      static void \n+      assign(char_type& __c1, const char_type& __c2)\n+      { __c1 = __c2; }\n+\n+      static bool \n+      eq(const char_type& __c1, const char_type& __c2)\n+      { return __c1 == __c2; }\n+\n+      static bool \n+      lt(const char_type& __c1, const char_type& __c2)\n+      { return __c1 < __c2; }\n+\n+      static int \n+      compare(const char_type* __s1, const char_type* __s2, size_t __n)\n+      { \n+\tfor (size_t __i = 0; __i < __n; ++__i)\n+\t  if (!eq(__s1[__i], __s2[__i]))\n+\t    return lt(__s1[__i], __s2[__i]) ? -1 : 1;\n+\treturn 0; \n+      }\n+\n+      static size_t\n+      length(const char_type* __s)\n+      { \n+\tconst char_type* __p = __s; \n+\twhile (__p) \n+\t  ++__p; \n+\treturn (__p - __s); \n+      }\n+\n+      static const char_type* \n+      find(const char_type* __s, size_t __n, const char_type& __a)\n+      { \n+\tfor (const char_type* __p = __s; size_t(__p - __s) < __n; ++__p)\n+\t  if (*__p == __a) return __p;\n+\treturn 0;\n+      }\n+\n+      static char_type* \n+      move(char_type* __s1, const char_type* __s2, size_t __n)\n+      { return (char_type*) memmove(__s1, __s2, __n * sizeof(char_type)); }\n+\n+      static char_type* \n+      copy(char_type* __s1, const char_type* __s2, size_t __n)\n+      { return (char_type*) memcpy(__s1, __s2, __n * sizeof(char_type)); }\n+\n+      static char_type* \n+      assign(char_type* __s, size_t __n, char_type __a)\n+      { \n+\tfor (char_type* __p = __s; __p < __s + __n; ++__p) \n+\t  assign(*__p, __a);\n+        return __s; \n+      }\n+\n+      static char_type \n+      to_char_type(const int_type& __c)\n+      { return char_type(); }\n+\n+      static int_type \n+      to_int_type(const char_type& __c) { return int_type(); }\n+\n+      static bool \n+      eq_int_type(const int_type& __c1, const int_type& __c2)\n+      { return __c1 == __c2; }\n+\n+      static int_type \n+      eof() { return static_cast<int_type>(-1); }\n+\n+      static int_type \n+      not_eof(const int_type& __c)\n+      { return eq_int_type(__c, eof()) ? int_type(0) : __c; }\n+    };\n+\n+  template<>\n+    struct char_traits<unsigned char>\n+    {\n+      typedef unsigned char \tchar_type;\n+      // Unsigned as wint_t in unsigned.\n+      typedef unsigned long  \tint_type;\n+      typedef streampos \tpos_type;\n+      typedef streamoff \toff_type;\n+      typedef mbstate_t \tstate_type;\n+      \n+      static void \n+      assign(char_type& __c1, const char_type& __c2)\n+      { __c1 = __c2; }\n+\n+      static bool \n+      eq(const char_type& __c1, const char_type& __c2)\n+      { return __c1 == __c2; }\n+\n+      static bool \n+      lt(const char_type& __c1, const char_type& __c2)\n+      { return __c1 < __c2; }\n+\n+      static int \n+      compare(const char_type* __s1, const char_type* __s2, size_t __n)\n+      { \n+\tfor (size_t __i = 0; __i < __n; ++__i)\n+\t  if (!eq(__s1[__i], __s2[__i]))\n+\t    return lt(__s1[__i], __s2[__i]) ? -1 : 1;\n+\treturn 0; \n+      }\n+\n+      static size_t\n+      length(const char_type* __s)\n+      { \n+\tconst char_type* __p = __s; \n+\twhile (__p && *__p) \n+\t  ++__p; \n+\treturn (__p - __s); \n+      }\n+\n+      static const char_type* \n+      find(const char_type* __s, size_t __n, const char_type& __a)\n+      { \n+\tfor (const char_type* __p = __s; size_t(__p - __s) < __n; ++__p)\n+\t  if (*__p == __a) return __p;\n+\treturn 0;\n+      }\n+\n+      static char_type* \n+      move(char_type* __s1, const char_type* __s2, size_t __n)\n+      { return (char_type*) memmove(__s1, __s2, __n * sizeof(char_type)); }\n+\n+      static char_type* \n+      copy(char_type* __s1, const char_type* __s2, size_t __n)\n+      { return (char_type*) memcpy(__s1, __s2, __n * sizeof(char_type)); }\n+\n+      static char_type* \n+      assign(char_type* __s, size_t __n, char_type __a)\n+      { \n+\tfor (char_type* __p = __s; __p < __s + __n; ++__p) \n+\t  assign(*__p, __a);\n+        return __s; \n+      }\n+\n+      static char_type \n+      to_char_type(const int_type& __c)\n+      { return char_type(); }\n+\n+      static int_type \n+      to_int_type(const char_type& __c) { return int_type(); }\n+\n+      static bool \n+      eq_int_type(const int_type& __c1, const int_type& __c2)\n+      { return __c1 == __c2; }\n+\n+      static int_type \n+      eof() { return static_cast<int_type>(-1); }\n+\n+      static int_type \n+      not_eof(const int_type& __c)\n+      { return eq_int_type(__c, eof()) ? int_type(0) : __c; }\n+    };\n+} // namespace std\n+\n class gnu_filebuf: public std::filebuf\n {\n   int i;"}, {"sha": "6cec904eb67a50009d4365fe2467166767b79c3b", "filename": "libstdc++-v3/testsuite/27_io/istream.cc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f13a69eccf8e409e1046f6bc1df333f0bf69cb6f/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fistream.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f13a69eccf8e409e1046f6bc1df333f0bf69cb6f/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fistream.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fistream.cc?ref=f13a69eccf8e409e1046f6bc1df333f0bf69cb6f", "patch": "@@ -31,6 +31,7 @@\n // NB: This file is for testing istream with NO OTHER INCLUDES.\n \n #include <istream>\n+#include <testsuite_hooks.h>\n \n // { dg-do compile }\n \n@@ -51,6 +52,7 @@ namespace test\n   using namespace std;\n   typedef short type_t;\n   template class basic_istream<type_t, char_traits<type_t> >;\n+  template class basic_istream<gnu_char, char_traits<gnu_char> >;\n } // test\n \n int main() "}, {"sha": "ee764f9d69769624c6224c02c7a00c889dd73d4b", "filename": "libstdc++-v3/testsuite/27_io/ostream.cc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f13a69eccf8e409e1046f6bc1df333f0bf69cb6f/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fostream.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f13a69eccf8e409e1046f6bc1df333f0bf69cb6f/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fostream.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fostream.cc?ref=f13a69eccf8e409e1046f6bc1df333f0bf69cb6f", "patch": "@@ -31,6 +31,7 @@\n // NB: This file is for testing ostream with NO OTHER INCLUDES.\n \n #include <ostream>\n+#include <testsuite_hooks.h>\n \n // { dg-do compile }\n \n@@ -51,6 +52,7 @@ namespace test\n   using namespace std;\n   typedef short type_t;\n   template class basic_ostream<type_t, char_traits<type_t> >;\n+  template class basic_ostream<gnu_char, char_traits<gnu_char> >;\n } // test\n \n int main() "}, {"sha": "102ff60c260acd54c92a55ffd754f008f1a30532", "filename": "libstdc++-v3/testsuite/27_io/streambuf.cc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f13a69eccf8e409e1046f6bc1df333f0bf69cb6f/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fstreambuf.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f13a69eccf8e409e1046f6bc1df333f0bf69cb6f/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fstreambuf.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fstreambuf.cc?ref=f13a69eccf8e409e1046f6bc1df333f0bf69cb6f", "patch": "@@ -31,6 +31,7 @@\n // NB: This file is for testing basic_streambuf with NO OTHER INCLUDES.\n \n #include <streambuf>\n+#include <testsuite_hooks.h>\n \n // { dg-do compile }\n \n@@ -51,6 +52,7 @@ namespace test\n   using namespace std;\n   typedef short type_t;\n   template class basic_streambuf<type_t, char_traits<type_t> >;\n+  template class basic_streambuf<gnu_char, char_traits<gnu_char> >;\n } // test\n \n int main() "}, {"sha": "3cfd5af605c2ccc892aa6d307f53489f66a7fcfb", "filename": "libstdc++-v3/testsuite/27_io/stringbuf.cc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f13a69eccf8e409e1046f6bc1df333f0bf69cb6f/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fstringbuf.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f13a69eccf8e409e1046f6bc1df333f0bf69cb6f/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fstringbuf.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fstringbuf.cc?ref=f13a69eccf8e409e1046f6bc1df333f0bf69cb6f", "patch": "@@ -31,6 +31,7 @@\n // NB: This file is for testing basic_stringbuf with NO OTHER INCLUDES.\n \n #include <sstream>\n+#include <testsuite_hooks.h>\n \n // { dg-do compile }\n \n@@ -51,6 +52,7 @@ namespace test\n   using namespace std;\n   typedef short type_t;\n   template class basic_stringbuf<type_t, char_traits<type_t> >;\n+  template class basic_stringbuf<gnu_char, char_traits<gnu_char> >;\n } // test\n \n int main() "}, {"sha": "cb9e39d9588df9c02d684f31e8571408691b7bd0", "filename": "libstdc++-v3/testsuite/27_io/stringstream.cc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f13a69eccf8e409e1046f6bc1df333f0bf69cb6f/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fstringstream.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f13a69eccf8e409e1046f6bc1df333f0bf69cb6f/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fstringstream.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fstringstream.cc?ref=f13a69eccf8e409e1046f6bc1df333f0bf69cb6f", "patch": "@@ -31,6 +31,7 @@\n // NB: This file is for testing basic_stringstream with NO OTHER INCLUDES.\n \n #include <sstream>\n+#include <testsuite_hooks.h>\n \n // { dg-do compile }\n \n@@ -51,6 +52,7 @@ namespace test\n   using namespace std;\n   typedef short type_t;\n   template class basic_stringstream<type_t, char_traits<type_t> >;\n+  template class basic_stringstream<gnu_char, char_traits<gnu_char> >;\n } // test\n \n int main() "}, {"sha": "5725debe7e860cf71d1f068d26ea498d498748bc", "filename": "libstdc++-v3/testsuite/testsuite_hooks.h", "status": "modified", "additions": 80, "deletions": 2, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f13a69eccf8e409e1046f6bc1df333f0bf69cb6f/libstdc%2B%2B-v3%2Ftestsuite%2Ftestsuite_hooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f13a69eccf8e409e1046f6bc1df333f0bf69cb6f/libstdc%2B%2B-v3%2Ftestsuite%2Ftestsuite_hooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftestsuite_hooks.h?ref=f13a69eccf8e409e1046f6bc1df333f0bf69cb6f", "patch": "@@ -50,19 +50,23 @@\n // 4)  gnu_copy_tracker, from Stephen M. Webb <stephen@bregmasoft.com>.\n //   A class with nontrivial ctor/dtor that provides the ability to track the\n //   number of copy ctors and dtors, and will throw on demand during copy.\n+//\n+// 5) gnu_char, gnu_char_traits, abstract character classes and\n+// char_traits specializations for testing instantiations.\n \n #ifndef _GLIBCPP_TESTSUITE_HOOKS_H\n #define _GLIBCPP_TESTSUITE_HOOKS_H\n \n+#include <bits/c++config.h>\n+#include <cstddef>\n+\n #ifdef DEBUG_ASSERT\n # include <cassert>\n # define VERIFY(fn) assert(fn)\n #else\n # define VERIFY(fn) test &= (fn)\n #endif\n \n-#include <bits/c++config.h>\n-\n // Defined in GLIBCPP_CONFIGURE_TESTSUITE.\n #ifndef _GLIBCPP_MEM_LIMITS\n // Don't do memory limits.\n@@ -146,6 +150,80 @@ class gnu_copy_tracker\n     static int itsDtorCount;\n };\n \n+struct gnu_char\n+{\n+  unsigned long c;\n+};\n+\n+struct gnu_int\n+{\n+  unsigned long i;\n+};\n+\n+struct gnu_state\n+{\n+  unsigned long l;\n+  unsigned long l2;\n+};\n+\n+// char_traits specialization\n+namespace std\n+{\n+  template<class _CharT>\n+    struct char_traits;\n+\n+  template<>\n+    struct char_traits<gnu_char>\n+    {\n+      typedef gnu_char \t\tchar_type;\n+      typedef gnu_int  \t\tint_type;\n+      typedef long \t\tpos_type;\n+      typedef unsigned long \toff_type;\n+      typedef gnu_state \tstate_type;\n+      \n+      static void \n+      assign(char_type& __c1, const char_type& __c2);\n+\n+      static bool \n+      eq(const char_type& __c1, const char_type& __c2);\n+\n+      static bool \n+      lt(const char_type& __c1, const char_type& __c2);\n+\n+      static int \n+      compare(const char_type* __s1, const char_type* __s2, size_t __n);\n+\n+      static size_t\n+      length(const char_type* __s);\n+\n+      static const char_type* \n+      find(const char_type* __s, size_t __n, const char_type& __a);\n+\n+      static char_type* \n+      move(char_type* __s1, const char_type* __s2, size_t __n);\n+\n+      static char_type* \n+      copy(char_type* __s1, const char_type* __s2, size_t __n);\n+\n+      static char_type* \n+      assign(char_type* __s, size_t __n, char_type __a);\n+\n+      static char_type \n+      to_char_type(const int_type& __c);\n+\n+      static int_type \n+      to_int_type(const char_type& __c);\n+\n+      static bool \n+      eq_int_type(const int_type& __c1, const int_type& __c2);\n+\n+      static int_type \n+      eof();\n+\n+      static int_type \n+      not_eof(const int_type& __c);\n+    };\n+} // namespace std\n \n #endif // _GLIBCPP_TESTSUITE_HOOKS_H\n "}]}