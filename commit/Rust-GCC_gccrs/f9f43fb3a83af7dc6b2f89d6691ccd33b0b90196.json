{"sha": "f9f43fb3a83af7dc6b2f89d6691ccd33b0b90196", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjlmNDNmYjNhODNhZjdkYzZiMmY4OWQ2NjkxY2NkMzNiMGI5MDE5Ng==", "commit": {"author": {"name": "Wilco Dijkstra", "email": "wdijkstr@arm.com", "date": "2017-10-24T17:21:19Z"}, "committer": {"name": "Wilco Dijkstra", "email": "wilco@gcc.gnu.org", "date": "2017-10-24T17:21:19Z"}, "message": "Cleanup autopref scheduling\n\nr253236 broke AArch64 bootstrap. Earlier revision r253071 changed scheduling\nbehaviour on AArch64 as autopref scheduling no longer checks the base.\n\nThis patch fixes the bootstrap failure and cleans up autopref scheduling.\nThe code is greatly simplified.  Sort accesses on the offset first, and\nonly if the offsets are the same fall back to other comparisons in\nrank_for_schedule.  This doesn't at all restore the original behaviour\nsince we no longer compare the base address, but it now defines a total\nsorting order.  More work will be required to improve the sorting so\nthat only loads/stores with the same base are affected.\n\n    gcc/\n\tPR rtl-optimization/82396\n\t* gcc/haifa-sched.c (ready_sort_real): Remove qsort workaround.\n\t(autopref_multipass_init): Simplify initialization.\n\t(autopref_rank_data): Simplify sort order.\n\t* gcc/sched-int.h (autopref_multipass_data_): Remove\n\tmulti_mem_insn_p, min_offset and max_offset.\n\nFrom-SVN: r254056", "tree": {"sha": "92d7b65abfd2bb2d39f8c3fd72241927eefe1ece", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/92d7b65abfd2bb2d39f8c3fd72241927eefe1ece"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f9f43fb3a83af7dc6b2f89d6691ccd33b0b90196", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f9f43fb3a83af7dc6b2f89d6691ccd33b0b90196", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f9f43fb3a83af7dc6b2f89d6691ccd33b0b90196", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f9f43fb3a83af7dc6b2f89d6691ccd33b0b90196/comments", "author": null, "committer": null, "parents": [{"sha": "acea40ac746971daf5b9e6091b908653407b86ea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/acea40ac746971daf5b9e6091b908653407b86ea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/acea40ac746971daf5b9e6091b908653407b86ea"}], "stats": {"total": 124, "additions": 25, "deletions": 99}, "files": [{"sha": "e0ef3edb9da2663cf7ab89fec5987d61288a1eb3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9f43fb3a83af7dc6b2f89d6691ccd33b0b90196/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9f43fb3a83af7dc6b2f89d6691ccd33b0b90196/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f9f43fb3a83af7dc6b2f89d6691ccd33b0b90196", "patch": "@@ -1,3 +1,12 @@\n+2017-10-24  Wilco Dijkstra  <wdijkstr@arm.com>\n+\n+\tPR rtl-optimization/82396\n+\t* gcc/haifa-sched.c (ready_sort_real): Remove qsort workaround.\n+\t(autopref_multipass_init): Simplify initialization.\n+\t(autopref_rank_data): Simplify sort order.\n+\t* gcc/sched-int.h (autopref_multipass_data_): Remove\n+\tmulti_mem_insn_p, min_offset and max_offset.\n+\n 2017-10-24  Wilco Dijkstra  <wdijkstr@arm.com>\n \n \tPR middle-end/60580"}, {"sha": "4b906a34b8bb6aac4ba76404828b8fab19638ce1", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 14, "deletions": 90, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9f43fb3a83af7dc6b2f89d6691ccd33b0b90196/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9f43fb3a83af7dc6b2f89d6691ccd33b0b90196/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=f9f43fb3a83af7dc6b2f89d6691ccd33b0b90196", "patch": "@@ -3084,8 +3084,7 @@ ready_sort_real (struct ready_list *ready)\n   if (n_ready_real == 2)\n     swap_sort (first, n_ready_real);\n   else if (n_ready_real > 2)\n-    /* HACK: Disable qsort checking for now (PR82396).  */\n-    (qsort) (first, n_ready_real, sizeof (rtx), rank_for_schedule);\n+    qsort (first, n_ready_real, sizeof (rtx), rank_for_schedule);\n \n   if (sched_verbose >= 4)\n     {\n@@ -5569,9 +5568,7 @@ autopref_multipass_init (const rtx_insn *insn, int write)\n \n   gcc_assert (data->status == AUTOPREF_MULTIPASS_DATA_UNINITIALIZED);\n   data->base = NULL_RTX;\n-  data->min_offset = 0;\n-  data->max_offset = 0;\n-  data->multi_mem_insn_p = false;\n+  data->offset = 0;\n   /* Set insn entry initialized, but not relevant for auto-prefetcher.  */\n   data->status = AUTOPREF_MULTIPASS_DATA_IRRELEVANT;\n \n@@ -5586,49 +5583,33 @@ autopref_multipass_init (const rtx_insn *insn, int write)\n     {\n       int n_elems = XVECLEN (pat, 0);\n \n-      int i = 0;\n-      rtx prev_base = NULL_RTX;\n-      int min_offset = 0;\n-      int max_offset = 0;\n+      int i, offset;\n+      rtx base, prev_base = NULL_RTX;\n+      int min_offset = INT_MAX;\n \n       for (i = 0; i < n_elems; i++)\n \t{\n \t  rtx set = XVECEXP (pat, 0, i);\n \t  if (GET_CODE (set) != SET)\n \t    return;\n \n-\t  rtx base = NULL_RTX;\n-\t  int offset = 0;\n \t  if (!analyze_set_insn_for_autopref (set, write, &base, &offset))\n \t    return;\n \n-\t  if (i == 0)\n-\t    {\n-\t      prev_base = base;\n-\t      min_offset = offset;\n-\t      max_offset = offset;\n-\t    }\n \t  /* Ensure that all memory operations in the PARALLEL use the same\n \t     base register.  */\n-\t  else if (REGNO (base) != REGNO (prev_base))\n+\t  if (i > 0 && REGNO (base) != REGNO (prev_base))\n \t    return;\n-\t  else\n-\t    {\n-\t      min_offset = MIN (min_offset, offset);\n-\t      max_offset = MAX (max_offset, offset);\n-\t    }\n+\t  prev_base = base;\n+\t  min_offset = MIN (min_offset, offset);\n \t}\n \n-      /* If we reached here then we have a valid PARALLEL of multiple memory\n-\t ops with prev_base as the base and min_offset and max_offset\n-\t containing the offsets range.  */\n+      /* If we reached here then we have a valid PARALLEL of multiple memory ops\n+\t with prev_base as the base and min_offset containing the offset.  */\n       gcc_assert (prev_base);\n       data->base = prev_base;\n-      data->min_offset = min_offset;\n-      data->max_offset = max_offset;\n-      data->multi_mem_insn_p = true;\n+      data->offset = min_offset;\n       data->status = AUTOPREF_MULTIPASS_DATA_NORMAL;\n-\n       return;\n     }\n \n@@ -5638,7 +5619,7 @@ autopref_multipass_init (const rtx_insn *insn, int write)\n     return;\n \n   if (!analyze_set_insn_for_autopref (set, write, &data->base,\n-\t\t\t\t       &data->min_offset))\n+\t\t\t\t       &data->offset))\n     return;\n \n   /* This insn is relevant for the auto-prefetcher.\n@@ -5647,63 +5628,6 @@ autopref_multipass_init (const rtx_insn *insn, int write)\n   data->status = AUTOPREF_MULTIPASS_DATA_NORMAL;\n }\n \n-\n-/* Helper for autopref_rank_for_schedule.  Given the data of two\n-   insns relevant to the auto-prefetcher modelling code DATA1 and DATA2\n-   return their comparison result.  Return 0 if there is no sensible\n-   ranking order for the two insns.  */\n-\n-static int\n-autopref_rank_data (autopref_multipass_data_t data1,\n-\t\t     autopref_multipass_data_t data2)\n-{\n-  /* Simple case when both insns are simple single memory ops.  */\n-  if (!data1->multi_mem_insn_p && !data2->multi_mem_insn_p)\n-    return data1->min_offset - data2->min_offset;\n-\n-  /* Two load/store multiple insns.  Return 0 if the offset ranges\n-     overlap and the difference between the minimum offsets otherwise.  */\n-  else if (data1->multi_mem_insn_p && data2->multi_mem_insn_p)\n-    {\n-      int min1 = data1->min_offset;\n-      int max1 = data1->max_offset;\n-      int min2 = data2->min_offset;\n-      int max2 = data2->max_offset;\n-\n-      if (max1 < min2 || min1 > max2)\n-\treturn min1 - min2;\n-      else\n-\treturn 0;\n-    }\n-\n-  /* The other two cases is a pair of a load/store multiple and\n-     a simple memory op.  Return 0 if the single op's offset is within the\n-     range of the multi-op insn and the difference between the single offset\n-     and the minimum offset of the multi-set insn otherwise.  */\n-  else if (data1->multi_mem_insn_p && !data2->multi_mem_insn_p)\n-    {\n-      int max1 = data1->max_offset;\n-      int min1 = data1->min_offset;\n-\n-      if (data2->min_offset >= min1\n-\t  && data2->min_offset <= max1)\n-\treturn 0;\n-      else\n-\treturn min1 - data2->min_offset;\n-    }\n-  else\n-    {\n-      int max2 = data2->max_offset;\n-      int min2 = data2->min_offset;\n-\n-      if (data1->min_offset >= min2\n-\t  && data1->min_offset <= max2)\n-\treturn 0;\n-      else\n-\treturn data1->min_offset - min2;\n-    }\n-}\n-\n /* Helper function for rank_for_schedule sorting.  */\n static int\n autopref_rank_for_schedule (const rtx_insn *insn1, const rtx_insn *insn2)\n@@ -5726,7 +5650,7 @@ autopref_rank_for_schedule (const rtx_insn *insn1, const rtx_insn *insn2)\n       int irrel2 = data2->status == AUTOPREF_MULTIPASS_DATA_IRRELEVANT;\n \n       if (!irrel1 && !irrel2)\n-\tr = autopref_rank_data (data1, data2);\n+\tr = data1->offset - data2->offset;\n       else\n \tr = irrel2 - irrel1;\n     }\n@@ -5754,7 +5678,7 @@ autopref_multipass_dfa_lookahead_guard_1 (const rtx_insn *insn1,\n     return 0;\n \n   if (rtx_equal_p (data1->base, data2->base)\n-      && autopref_rank_data (data1, data2) > 0)\n+      && data1->offset > data2->offset)\n     {\n       if (sched_verbose >= 2)\n \t{"}, {"sha": "6832589e3d0ad9ed5937ab3e81f3573c2560fe67", "filename": "gcc/sched-int.h", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9f43fb3a83af7dc6b2f89d6691ccd33b0b90196/gcc%2Fsched-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9f43fb3a83af7dc6b2f89d6691ccd33b0b90196/gcc%2Fsched-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-int.h?ref=f9f43fb3a83af7dc6b2f89d6691ccd33b0b90196", "patch": "@@ -819,15 +819,8 @@ struct autopref_multipass_data_\n   /* Base part of memory address.  */\n   rtx base;\n \n-  /* Memory offsets from the base.  For single simple sets\n-     only min_offset is valid.  For multi-set insns min_offset\n-     and max_offset record the minimum and maximum offsets from the same\n-     base among the sets inside the PARALLEL.  */\n-  int min_offset;\n-  int max_offset;\n-\n-  /* True if this is a load/store-multiple instruction.  */\n-  bool multi_mem_insn_p;\n+  /* Memory offsets from the base.  */\n+  int offset;\n \n   /* Entry status.  */\n   enum autopref_multipass_data_status status;"}]}