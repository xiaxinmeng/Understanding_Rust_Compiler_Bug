{"sha": "e81e4b43e9e07cb115a9cb14d1bc2fdf8fab4c15", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTgxZTRiNDNlOWUwN2NiMTE1YTljYjE0ZDFiYzJmZGY4ZmFiNGMxNQ==", "commit": {"author": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2013-01-14T21:50:28Z"}, "committer": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2013-01-14T21:50:28Z"}, "message": "re PR fortran/55806 (Missed optimization with ANY or ALL)\n\n2013-01-14  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\tPR fortran/55806\n\t* frontend-passes.c (optimize_reduction):  New function,\n\tincluding prototype.\n\t(callback_reduction):  Likewise.\n\t(gfc_run_passes):  Also run optimize_reduction.\n\t(copy_walk_reduction_arg):  New function.\n\t(dummy_code_callback):  New function.\n\n2013-01-14  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\tPR fortran/55806\n\t* gfortran.dg/array_constructor_40.f90:  New test.\n\nFrom-SVN: r195179", "tree": {"sha": "d4cf804a87b9c0180dd979b0d2dd1b8a050f0cf2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d4cf804a87b9c0180dd979b0d2dd1b8a050f0cf2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e81e4b43e9e07cb115a9cb14d1bc2fdf8fab4c15", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e81e4b43e9e07cb115a9cb14d1bc2fdf8fab4c15", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e81e4b43e9e07cb115a9cb14d1bc2fdf8fab4c15", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e81e4b43e9e07cb115a9cb14d1bc2fdf8fab4c15/comments", "author": null, "committer": null, "parents": [{"sha": "5a0727d99003e061b89e016c036947951d0743d2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a0727d99003e061b89e016c036947951d0743d2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5a0727d99003e061b89e016c036947951d0743d2"}], "stats": {"total": 233, "additions": 233, "deletions": 0}, "files": [{"sha": "b412d0a97b91281889a4346edbff3ef6965f10ae", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e81e4b43e9e07cb115a9cb14d1bc2fdf8fab4c15/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e81e4b43e9e07cb115a9cb14d1bc2fdf8fab4c15/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=e81e4b43e9e07cb115a9cb14d1bc2fdf8fab4c15", "patch": "@@ -1,3 +1,13 @@\n+2013-01-14  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\n+\tPR fortran/55806\n+\t* frontend-passes.c (optimize_reduction):  New function,\n+\tincluding prototype.\n+\t(callback_reduction):  Likewise.\n+\t(gfc_run_passes):  Also run optimize_reduction.\n+\t(copy_walk_reduction_arg):  New function.\n+\t(dummy_code_callback):  New function.\n+\n 2013-01-13  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR fortran/55935"}, {"sha": "5b092ca906f80b8ac64d792cb875cd3dafe284c9", "filename": "gcc/fortran/frontend-passes.c", "status": "modified", "additions": 166, "deletions": 0, "changes": 166, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e81e4b43e9e07cb115a9cb14d1bc2fdf8fab4c15/gcc%2Ffortran%2Ffrontend-passes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e81e4b43e9e07cb115a9cb14d1bc2fdf8fab4c15/gcc%2Ffortran%2Ffrontend-passes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ffrontend-passes.c?ref=e81e4b43e9e07cb115a9cb14d1bc2fdf8fab4c15", "patch": "@@ -40,6 +40,8 @@ static bool optimize_lexical_comparison (gfc_expr *);\n static void optimize_minmaxloc (gfc_expr **);\n static bool is_empty_string (gfc_expr *e);\n static void doloop_warn (gfc_namespace *);\n+static void optimize_reduction (gfc_namespace *);\n+static int callback_reduction (gfc_expr **, int *, void *);\n \n /* How deep we are inside an argument list.  */\n \n@@ -107,6 +109,7 @@ gfc_run_passes (gfc_namespace *ns)\n       expr_array = XNEWVEC(gfc_expr **, expr_size);\n \n       optimize_namespace (ns);\n+      optimize_reduction (ns);\n       if (gfc_option.dump_fortran_optimized)\n \tgfc_dump_parse_tree (ns, stdout);\n \n@@ -180,6 +183,145 @@ optimize_expr (gfc_expr **e, int *walk_subtrees ATTRIBUTE_UNUSED,\n   return 0;\n }\n \n+/* Auxiliary function to handle the arguments to reduction intrnisics.  If the\n+   function is a scalar, just copy it; otherwise returns the new element, the\n+   old one can be freed.  */\n+\n+static gfc_expr *\n+copy_walk_reduction_arg (gfc_expr *e, gfc_expr *fn)\n+{\n+  gfc_expr *fcn;\n+  gfc_isym_id id;\n+\n+  if (e->rank == 0 || e->expr_type == EXPR_FUNCTION)\n+    fcn = gfc_copy_expr (e);\n+  else\n+    {\n+      id = fn->value.function.isym->id;\n+\n+      if (id == GFC_ISYM_SUM || id == GFC_ISYM_PRODUCT)\n+\tfcn = gfc_build_intrinsic_call (current_ns,\n+\t\t\t\t\tfn->value.function.isym->id,\n+\t\t\t\t\tfn->value.function.isym->name,\n+\t\t\t\t\tfn->where, 3, gfc_copy_expr (e),\n+\t\t\t\t\tNULL, NULL);\n+      else if (id == GFC_ISYM_ANY || id == GFC_ISYM_ALL)\n+\tfcn = gfc_build_intrinsic_call (current_ns,\n+\t\t\t\t\tfn->value.function.isym->id,\n+\t\t\t\t\tfn->value.function.isym->name,\n+\t\t\t\t\tfn->where, 2, gfc_copy_expr (e),\n+\t\t\t\t\tNULL);\n+      else\n+\tgfc_internal_error (\"Illegal id in copy_walk_reduction_arg\");\n+\n+      fcn->symtree->n.sym->attr.access = ACCESS_PRIVATE;\n+    }\n+\n+  (void) gfc_expr_walker (&fcn, callback_reduction, NULL);\n+\n+  return fcn;\n+}\n+\n+/* Callback function for optimzation of reductions to scalars.  Transform ANY\n+   ([f1,f2,f3, ...]) to f1 .or. f2 .or. f3 .or. ..., with ANY, SUM and PRODUCT\n+   correspondingly.  Handly only the simple cases without MASK and DIM.  */\n+\n+static int\n+callback_reduction (gfc_expr **e, int *walk_subtrees ATTRIBUTE_UNUSED,\n+\t\t    void *data ATTRIBUTE_UNUSED)\n+{\n+  gfc_expr *fn, *arg;\n+  gfc_intrinsic_op op;\n+  gfc_isym_id id;\n+  gfc_actual_arglist *a;\n+  gfc_actual_arglist *dim;\n+  gfc_constructor *c;\n+  gfc_expr *res, *new_expr;\n+  gfc_actual_arglist *mask;\n+\n+  fn = *e;\n+\n+  if (fn->rank != 0 || fn->expr_type != EXPR_FUNCTION\n+      || fn->value.function.isym == NULL)\n+    return 0;\n+\n+  id = fn->value.function.isym->id;\n+\n+  if (id != GFC_ISYM_SUM && id != GFC_ISYM_PRODUCT\n+      && id != GFC_ISYM_ANY && id != GFC_ISYM_ALL)\n+    return 0;\n+\n+  a = fn->value.function.actual;\n+\n+  /* Don't handle MASK or DIM.  */\n+\n+  dim = a->next;\n+\n+  if (dim->expr != NULL)\n+    return 0;\n+\n+  if (id == GFC_ISYM_SUM || id == GFC_ISYM_PRODUCT)\n+    {\n+      mask = dim->next;\n+      if ( mask->expr != NULL)\n+\treturn 0;\n+    }\n+\n+  arg = a->expr;\n+\n+  if (arg->expr_type != EXPR_ARRAY)\n+    return 0;\n+\n+  switch (id)\n+    {\n+    case GFC_ISYM_SUM:\n+      op = INTRINSIC_PLUS;\n+      break;\n+\n+    case GFC_ISYM_PRODUCT:\n+      op = INTRINSIC_TIMES;\n+      break;\n+\n+    case GFC_ISYM_ANY:\n+      op = INTRINSIC_OR;\n+      break;\n+\n+    case GFC_ISYM_ALL:\n+      op = INTRINSIC_AND;\n+      break;\n+\n+    default:\n+      return 0;\n+    }\n+\n+  c = gfc_constructor_first (arg->value.constructor);\n+\n+  if (c == NULL)\n+    return 0;\n+\n+  res = copy_walk_reduction_arg (c->expr, fn);\n+\n+  c = gfc_constructor_next (c);\n+  while (c)\n+    {\n+      new_expr = gfc_get_expr ();\n+      new_expr->ts = fn->ts;\n+      new_expr->expr_type = EXPR_OP;\n+      new_expr->rank = fn->rank;\n+      new_expr->where = fn->where;\n+      new_expr->value.op.op = op;\n+      new_expr->value.op.op1 = res;\n+      new_expr->value.op.op2 = copy_walk_reduction_arg (c->expr, fn);\n+      res = new_expr;\n+      c = gfc_constructor_next (c);\n+    }\n+\n+  gfc_simplify_expr (res, 0);\n+  *e = res;\n+  gfc_free_expr (fn);\n+\n+  return 0;\n+}\n \n /* Callback function for common function elimination, called from cfe_expr_0.\n    Put all eligible function expressions into expr_array.  */\n@@ -484,6 +626,16 @@ dummy_expr_callback (gfc_expr **e ATTRIBUTE_UNUSED, int *walk_subtrees,\n   return 0;\n }\n \n+/* Dummy function for code callback, for use when we really\n+   don't want to do anything.  */\n+static int\n+dummy_code_callback (gfc_code **e ATTRIBUTE_UNUSED,\n+\t\t     int *walk_subtrees ATTRIBUTE_UNUSED,\n+\t\t     void *data ATTRIBUTE_UNUSED)\n+{\n+  return 0;\n+}\n+\n /* Code callback function for converting\n    do while(a)\n    end do\n@@ -639,6 +791,20 @@ optimize_namespace (gfc_namespace *ns)\n     }\n }\n \n+static void\n+optimize_reduction (gfc_namespace *ns)\n+{\n+  current_ns = ns;\n+  gfc_code_walker (&ns->code, dummy_code_callback, callback_reduction, NULL);\n+\n+/* BLOCKs are handled in the expression walker below.  */\n+  for (ns = ns->contained; ns; ns = ns->sibling)\n+    {\n+      if (ns->code == NULL || ns->code->op != EXEC_BLOCK)\n+\toptimize_reduction (ns);\n+    }\n+}\n+\n /* Replace code like\n    a = matmul(b,c) + d\n    with"}, {"sha": "e25cfc8bf0fcde52d2adf3ab4d0ec4a1d8179126", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e81e4b43e9e07cb115a9cb14d1bc2fdf8fab4c15/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e81e4b43e9e07cb115a9cb14d1bc2fdf8fab4c15/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=e81e4b43e9e07cb115a9cb14d1bc2fdf8fab4c15", "patch": "@@ -1,3 +1,8 @@\n+2013-01-14  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\n+\tPR fortran/55806\n+\t* gfortran.dg/array_constructor_40.f90:  New test.\n+\n 2013-01-14  Richard Sandiford  <rdsandiford@googlemail.com>\n \n \t* gcc.dg/tree-ssa/slsr-8.c: Allow widening multiplications."}, {"sha": "ca91d5eacda858daffe048f23723f9e86199119f", "filename": "gcc/testsuite/gfortran.dg/array_constructor_40.f90", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e81e4b43e9e07cb115a9cb14d1bc2fdf8fab4c15/gcc%2Ftestsuite%2Fgfortran.dg%2Farray_constructor_40.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e81e4b43e9e07cb115a9cb14d1bc2fdf8fab4c15/gcc%2Ftestsuite%2Fgfortran.dg%2Farray_constructor_40.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Farray_constructor_40.f90?ref=e81e4b43e9e07cb115a9cb14d1bc2fdf8fab4c15", "patch": "@@ -0,0 +1,52 @@\n+! { dg-do run }\n+! { dg-options \"-ffrontend-optimize -fdump-tree-original\" }\n+! PR 55806 - replace ANY intrinsic for array\n+! constructor with .or.\n+\n+module mymod\n+  implicit none\n+contains\n+  subroutine bar(a,b,c, lo)\n+    real, dimension(3,3), intent(in) :: a,b\n+    logical, dimension(3,3), intent(in) :: lo\n+    integer, intent(out) :: c\n+    real, parameter :: acc = 1e-4\n+    integer :: i,j\n+    \n+    c = 0\n+    do i=1,3\n+       if (any([abs(a(i,1) - b(i,1)) > acc,  &\n+            (j==i+1,j=3,8)])) cycle\n+       if (any([abs(a(i,2) - b(i,2)) > acc, &\n+            abs(a(i,3) - b(i,3)) > acc, lo(i,:)])) cycle\n+       c = c + i\n+    end do\n+  end subroutine bar\n+\n+  subroutine baz(a, b, c)\n+    real, dimension(3,3), intent(in) :: a,b\n+    real, intent(out) :: c\n+    c = sum([a(1,1),a(2,2),a(3,3),b(:,1)])\n+  end subroutine baz\n+end module mymod\n+\n+program main\n+  use mymod\n+  implicit none\n+  real, dimension(3,3) :: a,b\n+  real :: res\n+  integer :: c\n+  logical lo(3,3)\n+  data a/1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9/\n+\n+  b = a\n+  b(2,2) = a(2,2) + 0.2\n+  lo = .false.\n+  lo(3,3) = .true.\n+  call bar(a,b,c,lo)\n+  if (c /= 1) call abort\n+  call baz(a,b,res);\n+  if (abs(res - 8.1) > 1e-5) call abort\n+end program main\n+! { dg-final { scan-tree-dump-times \"while\" 3 \"original\" } }\n+! { dg-final { cleanup-tree-dump \"original\" } }"}]}