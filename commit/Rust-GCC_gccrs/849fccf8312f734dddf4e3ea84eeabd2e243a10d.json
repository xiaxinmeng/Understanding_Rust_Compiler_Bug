{"sha": "849fccf8312f734dddf4e3ea84eeabd2e243a10d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODQ5ZmNjZjgzMTJmNzM0ZGRkZjRlM2VhODRlZWFiZDJlMjQzYTEwZA==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2017-01-11T11:27:43Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2017-01-11T11:27:43Z"}, "message": "re PR rtl-optimization/79032 (unaligned memory access generated with LRA and optimization)\n\n\tPR rtl-optimization/79032\n\t* lra-constraints.c (simplify_operand_subreg): In the MEM case, test\n\tthe alignment of the adjusted memory reference against that of MODE,\n\tinstead of the alignment of the original memory reference.\n\nFrom-SVN: r244311", "tree": {"sha": "293439ba584fbb7053bd43b36c0c1d62e28925c7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/293439ba584fbb7053bd43b36c0c1d62e28925c7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/849fccf8312f734dddf4e3ea84eeabd2e243a10d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/849fccf8312f734dddf4e3ea84eeabd2e243a10d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/849fccf8312f734dddf4e3ea84eeabd2e243a10d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/849fccf8312f734dddf4e3ea84eeabd2e243a10d/comments", "author": null, "committer": null, "parents": [{"sha": "e325277522ec7a72286f1faa5bfb47f4b4be3d81", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e325277522ec7a72286f1faa5bfb47f4b4be3d81", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e325277522ec7a72286f1faa5bfb47f4b4be3d81"}], "stats": {"total": 52, "additions": 48, "deletions": 4}, "files": [{"sha": "00eabd0c1cd92ffb30c82ead1f5d9766856adb45", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/849fccf8312f734dddf4e3ea84eeabd2e243a10d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/849fccf8312f734dddf4e3ea84eeabd2e243a10d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=849fccf8312f734dddf4e3ea84eeabd2e243a10d", "patch": "@@ -1,3 +1,10 @@\n+2017-01-11  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\tPR rtl-optimization/79032\n+\t* lra-constraints.c (simplify_operand_subreg): In the MEM case, test\n+\tthe alignment of the adjusted memory reference against that of MODE,\n+\tinstead of the alignment of the original memory reference.\n+\n 2017-01-11  Martin Jambor  <mjambor@suse.cz>\n \n \t* hsa.c (hsa_callable_function_p): Revert addition of DECL_ARTIFICIAL"}, {"sha": "7b0d2f4b85fca66fdec1b9c2265b1d409a5d3c48", "filename": "gcc/lra-constraints.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/849fccf8312f734dddf4e3ea84eeabd2e243a10d/gcc%2Flra-constraints.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/849fccf8312f734dddf4e3ea84eeabd2e243a10d/gcc%2Flra-constraints.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-constraints.c?ref=849fccf8312f734dddf4e3ea84eeabd2e243a10d", "patch": "@@ -1505,15 +1505,15 @@ simplify_operand_subreg (int nop, machine_mode reg_mode)\n \t\t\t\t  MEM_ADDR_SPACE (subst))))\n \t{\n \t  /* If we change the address for a paradoxical subreg of memory, the\n-\t     address might violate the necessary alignment or the access might\n-\t     be slow.  So take this into consideration.  We need not worry\n+\t     new address might violate the necessary alignment or the access\n+\t     might be slow; take this into consideration.  We need not worry\n \t     about accesses beyond allocated memory for paradoxical memory\n \t     subregs as we don't substitute such equiv memory (see processing\n \t     equivalences in function lra_constraints) and because for spilled\n \t     pseudos we allocate stack memory enough for the biggest\n \t     corresponding paradoxical subreg.  */\n-\t  if (!(MEM_ALIGN (reg) < GET_MODE_ALIGNMENT (mode)\n-\t\t&& SLOW_UNALIGNED_ACCESS (mode, MEM_ALIGN (reg)))\n+\t  if (!(MEM_ALIGN (subst) < GET_MODE_ALIGNMENT (mode)\n+\t\t&& SLOW_UNALIGNED_ACCESS (mode, MEM_ALIGN (subst)))\n \t      || (MEM_ALIGN (reg) < GET_MODE_ALIGNMENT (innermode)\n \t\t  && SLOW_UNALIGNED_ACCESS (innermode, MEM_ALIGN (reg))))\n \t    return true;"}, {"sha": "c892d161ea0d742981220ba0d4e5822b44d287d5", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/849fccf8312f734dddf4e3ea84eeabd2e243a10d/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/849fccf8312f734dddf4e3ea84eeabd2e243a10d/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=849fccf8312f734dddf4e3ea84eeabd2e243a10d", "patch": "@@ -1,3 +1,7 @@\n+2017-01-11  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc.c-torture/execute/20170111-1.c: New test.\n+\n 2017-01-11  Richard Biener  <rguenther@suse.de>\n \n \t* gcc.dg/tree-ssa/pr61743-1.c: Adjust."}, {"sha": "0ff4bab23e697fa655dd05842ebb5015af6ecdaf", "filename": "gcc/testsuite/gcc.c-torture/execute/20170111-1.c", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/849fccf8312f734dddf4e3ea84eeabd2e243a10d/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20170111-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/849fccf8312f734dddf4e3ea84eeabd2e243a10d/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20170111-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20170111-1.c?ref=849fccf8312f734dddf4e3ea84eeabd2e243a10d", "patch": "@@ -0,0 +1,33 @@\n+/* PR rtl-optimization/79032 */\n+/* Reported by Daniel Cederman <cederman@gaisler.com> */\n+\n+extern void abort (void);\n+\n+struct S {\n+  short a;\n+  long long b;\n+  short c;\n+  char d;\n+  unsigned short e;\n+  long *f;\n+};\n+\n+static long foo (struct S *s) __attribute__((noclone, noinline));\n+\n+static long foo (struct S *s)\n+{\n+  long a = 1;\n+  a /= s->e;\n+  s->f[a]--;\n+  return a;\n+}\n+\n+int main (void)\n+{\n+  long val = 1;\n+  struct S s = { 0, 0, 0, 0, 2, &val };\n+  val = foo (&s);\n+  if (val != 0)\n+    abort ();\n+  return 0;\n+}"}]}