{"sha": "3d17d93d9fe5c1141c319158e756f6b9b6300f86", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2QxN2Q5M2Q5ZmU1YzExNDFjMzE5MTU4ZTc1NmY2YjliNjMwMGY4Ng==", "commit": {"author": {"name": "Alexandre Oliva", "email": "aoliva@redhat.com", "date": "2001-09-29T21:52:12Z"}, "committer": {"name": "Alexandre Oliva", "email": "aoliva@gcc.gnu.org", "date": "2001-09-29T21:52:12Z"}, "message": "reload.c (find_reloads): Mark new USE insns with QImode.\n\n* reload.c (find_reloads): Mark new USE insns with QImode.\n(find_reloads_toplev, find_reloads_address, subst_reg_equivs,\nfind_reloads_subreg_address): Likewise.\n* regrename.c (note_sets, clear_dead_regs): Abort if pseudos are\nencountered.\n* reload1.c (reload_combine_note_use): Likewise, inside USEs and\nCLOBBERs.\n(reload): Make sure there are no USEs with mode other than\nVOIDmode.  At the end, remove those marked with QImode.\n\nFrom-SVN: r45889", "tree": {"sha": "8b7cd2a3c1dc10fd6fe1a5ff6ec9025224f41a3e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8b7cd2a3c1dc10fd6fe1a5ff6ec9025224f41a3e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3d17d93d9fe5c1141c319158e756f6b9b6300f86", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3d17d93d9fe5c1141c319158e756f6b9b6300f86", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3d17d93d9fe5c1141c319158e756f6b9b6300f86", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3d17d93d9fe5c1141c319158e756f6b9b6300f86/comments", "author": null, "committer": null, "parents": [{"sha": "9f57ca195a961a5ed6d93d6a7f570fd0de7e5c6e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9f57ca195a961a5ed6d93d6a7f570fd0de7e5c6e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9f57ca195a961a5ed6d93d6a7f570fd0de7e5c6e"}], "stats": {"total": 77, "additions": 67, "deletions": 10}, "files": [{"sha": "8e5d1827c60d248b6d10580cd0eaebb006a059bf", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d17d93d9fe5c1141c319158e756f6b9b6300f86/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d17d93d9fe5c1141c319158e756f6b9b6300f86/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3d17d93d9fe5c1141c319158e756f6b9b6300f86", "patch": "@@ -1,3 +1,15 @@\n+2001-09-29  Alexandre Oliva  <aoliva@redhat.com>\n+\n+\t* reload.c (find_reloads): Mark new USE insns with QImode.\n+\t(find_reloads_toplev, find_reloads_address, subst_reg_equivs,\n+\tfind_reloads_subreg_address): Likewise.\n+\t* regrename.c (note_sets, clear_dead_regs): Abort if pseudos are\n+\tencountered.\n+\t* reload1.c (reload_combine_note_use): Likewise, inside USEs and\n+\tCLOBBERs.\n+\t(reload): Make sure there are no USEs with mode other than\n+\tVOIDmode.  At the end, remove those marked with QImode.\n+\n 2001-09-29  Per Bothner  <per@bothner.com>\n \n \t* cppdefault.c (cpp_include_defaults):  Also search PREFIX_INCLUDE_DIR."}, {"sha": "c0cf2326360d74de1803ff99b1112ad833a181d4", "filename": "gcc/regrename.c", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d17d93d9fe5c1141c319158e756f6b9b6300f86/gcc%2Fregrename.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d17d93d9fe5c1141c319158e756f6b9b6300f86/gcc%2Fregrename.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregrename.c?ref=3d17d93d9fe5c1141c319158e756f6b9b6300f86", "patch": "@@ -112,6 +112,11 @@ note_sets (x, set, data)\n     return;\n   regno = REGNO (x);\n   nregs = HARD_REGNO_NREGS (regno, GET_MODE (x));\n+\n+  /* There must not be pseudos at this point.  */\n+  if (regno + nregs > FIRST_PSEUDO_REGISTER)\n+    abort ();\n+\n   while (nregs-- > 0)\n     SET_HARD_REG_BIT (*pset, regno + nregs);\n }\n@@ -132,6 +137,11 @@ clear_dead_regs (pset, kind, notes)\n \trtx reg = XEXP (note, 0);\n \tunsigned int regno = REGNO (reg);\n \tint nregs = HARD_REGNO_NREGS (regno, GET_MODE (reg));\n+\n+\t/* There must not be pseudos at this point.  */\n+\tif (regno + nregs > FIRST_PSEUDO_REGISTER)\n+\t  abort ();\n+\n \twhile (nregs-- > 0)\n \t  CLEAR_HARD_REG_BIT (*pset, regno + nregs);\n       }"}, {"sha": "cde346091274a315b6a73cb42d2b2c7be48f90fd", "filename": "gcc/reload.c", "status": "modified", "additions": 27, "deletions": 5, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d17d93d9fe5c1141c319158e756f6b9b6300f86/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d17d93d9fe5c1141c319158e756f6b9b6300f86/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=3d17d93d9fe5c1141c319158e756f6b9b6300f86", "patch": "@@ -3816,7 +3816,11 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t    if (GET_CODE (operand) == REG)\n \t      {\n \t\tif (modified[i] != RELOAD_WRITE)\n-\t\t  emit_insn_before (gen_rtx_USE (VOIDmode, operand), insn);\n+\t\t  /* We mark the USE with QImode so that we recognize\n+\t\t     it as one that can be safely deleted at the end\n+\t\t     of reload.  */\n+\t\t  PUT_MODE (emit_insn_before (gen_rtx_USE (VOIDmode, operand),\n+\t\t\t\t\t      insn), QImode);\n \t\tif (modified[i] != RELOAD_READ)\n \t\t  emit_insn_after (gen_rtx_CLOBBER (VOIDmode, operand), insn);\n \t      }\n@@ -4302,7 +4306,11 @@ find_reloads_toplev (x, opnum, type, ind_levels, is_set_dest, insn,\n \t\t this substitution.  We have to emit a USE of the pseudo so\n \t\t that delete_output_reload can see it.  */\n \t      if (replace_reloads && recog_data.operand[opnum] != x)\n-\t\temit_insn_before (gen_rtx_USE (VOIDmode, x), insn);\n+\t\t/* We mark the USE with QImode so that we recognize it\n+\t\t   as one that can be safely deleted at the end of\n+\t\t   reload.  */\n+\t\tPUT_MODE (emit_insn_before (gen_rtx_USE (VOIDmode, x), insn),\n+\t\t\t  QImode);\n \t      x = mem;\n \t      i = find_reloads_address (GET_MODE (x), &x, XEXP (x, 0), &XEXP (x, 0),\n \t\t\t\t\topnum, type, ind_levels, insn);\n@@ -4561,7 +4569,12 @@ find_reloads_address (mode, memrefloc, ad, loc, opnum, type, ind_levels, insn)\n \t\t      && ! rtx_equal_p (tem, reg_equiv_mem[regno]))\n \t\t    {\n \t\t      *loc = tem;\n-\t\t      emit_insn_before (gen_rtx_USE (VOIDmode, ad), insn);\n+\t\t      /* We mark the USE with QImode so that we\n+\t\t\t recognize it as one that can be safely\n+\t\t\t deleted at the end of reload.  */\n+\t\t      PUT_MODE (emit_insn_before (gen_rtx_USE (VOIDmode, ad),\n+\t\t\t\t\t\t  insn), QImode);\n+\n \t\t      /* This doesn't really count as replacing the address\n \t\t\t as a whole, since it is still a memory access.  */\n \t\t    }\n@@ -4892,7 +4905,11 @@ subst_reg_equivs (ad, insn)\n \t    if (! rtx_equal_p (mem, reg_equiv_mem[regno]))\n \t      {\n \t\tsubst_reg_equivs_changed = 1;\n-\t\temit_insn_before (gen_rtx_USE (VOIDmode, ad), insn);\n+\t\t/* We mark the USE with QImode so that we recognize it\n+\t\t   as one that can be safely deleted at the end of\n+\t\t   reload.  */\n+\t\tPUT_MODE (emit_insn_before (gen_rtx_USE (VOIDmode, ad), insn),\n+\t\t\t  QImode);\n \t\treturn mem;\n \t      }\n \t  }\n@@ -5724,7 +5741,12 @@ find_reloads_subreg_address (x, force_replace, opnum, type,\n \t\t this substitution.  We have to emit a USE of the pseudo so\n \t\t that delete_output_reload can see it.  */\n \t      if (replace_reloads && recog_data.operand[opnum] != x)\n-\t\temit_insn_before (gen_rtx_USE (VOIDmode, SUBREG_REG (x)), insn);\n+\t\t/* We mark the USE with QImode so that we recognize it\n+\t\t   as one that can be safely deleted at the end of\n+\t\t   reload.  */\n+\t\tPUT_MODE (emit_insn_before (gen_rtx_USE (VOIDmode,\n+\t\t\t\t\t\t\t SUBREG_REG (x)),\n+\t\t\t\t\t    insn), QImode);\n \t      x = tem;\n \t    }\n \t}"}, {"sha": "bc3456f931cb17df19f6c7425fdee5d3948ba1da", "filename": "gcc/reload1.c", "status": "modified", "additions": 18, "deletions": 5, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3d17d93d9fe5c1141c319158e756f6b9b6300f86/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3d17d93d9fe5c1141c319158e756f6b9b6300f86/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=3d17d93d9fe5c1141c319158e756f6b9b6300f86", "patch": "@@ -758,6 +758,13 @@ reload (first, global)\n     {\n       rtx set = single_set (insn);\n \n+      /* We may introduce USEs that we want to remove at the end, so\n+\t we'll mark them with QImode.  Make sure there are no\n+\t previously-marked insns left by say regmove.  */\n+      if (INSN_P (insn) && GET_CODE (PATTERN (insn)) == USE\n+\t  && GET_MODE (insn) != VOIDmode)\n+\tPUT_MODE (insn, VOIDmode);\n+\n       if (GET_CODE (insn) == CALL_INSN\n \t  && find_reg_note (insn, REG_SETJMP, NULL))\n \tfor (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n@@ -1183,7 +1190,9 @@ reload (first, global)\n \t\t\t\t\t CALL_INSN_FUNCTION_USAGE (insn));\n \n \tif ((GET_CODE (PATTERN (insn)) == USE\n-\t     && find_reg_note (insn, REG_EQUAL, NULL_RTX))\n+\t     /* We mark with QImode USEs introduced by reload itself.  */\n+\t     && (GET_MODE (insn) == QImode\n+\t\t || find_reg_note (insn, REG_EQUAL, NULL_RTX)))\n \t    || (GET_CODE (PATTERN (insn)) == CLOBBER\n \t\t&& (GET_CODE (XEXP (PATTERN (insn), 0)) != REG\n \t\t    || ! REG_FUNCTION_VALUE_P (XEXP (PATTERN (insn), 0)))))\n@@ -8929,7 +8938,12 @@ reload_combine_note_use (xp, insn)\n \n     case CLOBBER:\n       if (GET_CODE (SET_DEST (x)) == REG)\n-\treturn;\n+\t{\n+\t  /* No spurious CLOBBERs of pseudo registers may remain.  */\n+\t  if (REGNO (SET_DEST (x)) >= FIRST_PSEUDO_REGISTER)\n+\t    abort ();\n+\t  return;\n+\t}\n       break;\n \n     case PLUS:\n@@ -8946,10 +8960,9 @@ reload_combine_note_use (xp, insn)\n \tint use_index;\n \tint nregs;\n \n-\t/* Some spurious USEs of pseudo registers might remain.\n-\t   Just ignore them.  */\n+\t/* No spurious USEs of pseudo registers may remain.  */\n \tif (regno >= FIRST_PSEUDO_REGISTER)\n-\t  return;\n+\t  abort ();\n \n \tnregs = HARD_REGNO_NREGS (regno, GET_MODE (x));\n "}]}