{"sha": "f0478a53cb286eeb251e891e93609a714da9724c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjA0NzhhNTNjYjI4NmVlYjI1MWU4OTFlOTM2MDlhNzE0ZGE5NzI0Yw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-09-08T09:22:59Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-09-08T09:22:59Z"}, "message": "[multiple changes]\n\n2017-09-08  Arnaud Charlet  <charlet@adacore.com>\n\n\t* sem_util.ads, sem_util.adb (Is_CCT_Instance): Only expect\n\tentities of named concurrent types as Ref_Id and not of anonymous\n\tconcurrent objects (because callers already know when a conversion\n\tis necessary and can easily do it); also, do not expect protected\n\ttypes or protected objects as Context_Id (because no flow-related\n\tSPARK pragmas are attached there); reflect these changes in a\n\tmore precise comment.\n\n2017-09-08  Olivier Hainque  <hainque@adacore.com>\n\n\t* g-altive.ads: Add documentation.\n\n2017-09-08  Bob Duff  <duff@adacore.com>\n\n\t* sem_util.ads, debug.adb: Minor comment fix.\n\t* erroutc.ads: Comment fix.\n\n2017-09-08  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch12.adb (Validate_Array_Type_Instance): Suppress check\n\tfor compatibility of component types of formal and actual in an\n\tinstantiation of a child unit,\twhen the component type of the\n\tformal is itself a formal of an enclosing generic.\n\nFrom-SVN: r251872", "tree": {"sha": "8311392e23e919d341d6291f43cbacbdcc5827c2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8311392e23e919d341d6291f43cbacbdcc5827c2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f0478a53cb286eeb251e891e93609a714da9724c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f0478a53cb286eeb251e891e93609a714da9724c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f0478a53cb286eeb251e891e93609a714da9724c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f0478a53cb286eeb251e891e93609a714da9724c/comments", "author": null, "committer": null, "parents": [{"sha": "780d73d73d39e83d6034d1d7b06c27091e9a9cdc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/780d73d73d39e83d6034d1d7b06c27091e9a9cdc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/780d73d73d39e83d6034d1d7b06c27091e9a9cdc"}], "stats": {"total": 475, "additions": 413, "deletions": 62}, "files": [{"sha": "471a5da8c1bc69992fe38b0325b730317729695b", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0478a53cb286eeb251e891e93609a714da9724c/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0478a53cb286eeb251e891e93609a714da9724c/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=f0478a53cb286eeb251e891e93609a714da9724c", "patch": "@@ -1,3 +1,29 @@\n+2017-09-08  Arnaud Charlet  <charlet@adacore.com>\n+\n+\t* sem_util.ads, sem_util.adb (Is_CCT_Instance): Only expect\n+\tentities of named concurrent types as Ref_Id and not of anonymous\n+\tconcurrent objects (because callers already know when a conversion\n+\tis necessary and can easily do it); also, do not expect protected\n+\ttypes or protected objects as Context_Id (because no flow-related\n+\tSPARK pragmas are attached there); reflect these changes in a\n+\tmore precise comment.\n+\n+2017-09-08  Olivier Hainque  <hainque@adacore.com>\n+\n+\t* g-altive.ads: Add documentation.\n+\n+2017-09-08  Bob Duff  <duff@adacore.com>\n+\n+\t* sem_util.ads, debug.adb: Minor comment fix.\n+\t* erroutc.ads: Comment fix.\n+\n+2017-09-08  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch12.adb (Validate_Array_Type_Instance): Suppress check\n+\tfor compatibility of component types of formal and actual in an\n+\tinstantiation of a child unit,\twhen the component type of the\n+\tformal is itself a formal of an enclosing generic.\n+\n 2017-09-08  Arnaud Charlet  <charlet@adacore.com>\n \n \t* sem_util.ads, sem_util.adb (Is_CCT_Instance): moved from"}, {"sha": "03820fd1528c9e1a354de535a1964d4ba9a8e700", "filename": "gcc/ada/debug.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0478a53cb286eeb251e891e93609a714da9724c/gcc%2Fada%2Fdebug.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0478a53cb286eeb251e891e93609a714da9724c/gcc%2Fada%2Fdebug.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdebug.adb?ref=f0478a53cb286eeb251e891e93609a714da9724c", "patch": "@@ -548,7 +548,7 @@ package body Debug is\n \n    --  d.l  Use Ada 95 semantics for limited function returns. This may be\n    --       used to work around the incompatibility introduced by AI-318-2.\n-   --       It is useful only in -gnat05 mode.\n+   --       It is useful only in Ada 2005 and later.\n \n    --  d.m  When -gnatl is used, the normal output includes full listings of\n    --       all files in the extended main source (body/spec/subunits). If this"}, {"sha": "9aa44e91e98c1fa0ebc7ba10719cc5d77906c80b", "filename": "gcc/ada/erroutc.ads", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0478a53cb286eeb251e891e93609a714da9724c/gcc%2Fada%2Ferroutc.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0478a53cb286eeb251e891e93609a714da9724c/gcc%2Fada%2Ferroutc.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ferroutc.ads?ref=f0478a53cb286eeb251e891e93609a714da9724c", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2015, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2017, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -192,13 +192,13 @@ package Erroutc is\n       --  have Sptr pointing to the instantiation point.\n \n       Optr : Source_Ptr;\n-      --  Flag location used in the call to post the error. This is normally\n-      --  the same as Sptr, except when an error is posted on a particular\n-      --  instantiation of a generic. In such a case, Sptr will point to\n-      --  the original source location of the instantiation itself, but\n-      --  Optr will point to the template location (more accurately to the\n-      --  template copy in the instantiation copy corresponding to the\n-      --  instantiation referenced by Sptr).\n+      --  Flag location used in the call to post the error. This is the same as\n+      --  Sptr, except when an error is posted on a particular instantiation of\n+      --  a generic. In such a case, Sptr will point to the original source\n+      --  location of the instantiation itself, but Optr will point to the\n+      --  template location (more accurately to the template copy in the\n+      --  instantiation copy corresponding to the instantiation referenced by\n+      --  Sptr).\n \n       Line : Physical_Line_Number;\n       --  Line number for error message"}, {"sha": "1e247b30f5c5257290ba39b119fb58240cce9a12", "filename": "gcc/ada/g-altive.ads", "status": "modified", "additions": 352, "deletions": 13, "changes": 365, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0478a53cb286eeb251e891e93609a714da9724c/gcc%2Fada%2Fg-altive.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0478a53cb286eeb251e891e93609a714da9724c/gcc%2Fada%2Fg-altive.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-altive.ads?ref=f0478a53cb286eeb251e891e93609a714da9724c", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2004-2011, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2004-2017, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -86,22 +86,22 @@\n --          |                |                |             |\n --    Vector_Types   Vector_Operations   Vector_Views   Conversions\n \n---  The user can manipulate vectors through two families of types: Vector\n+--  Users can manipulate vectors through two families of types: Vector\n --  types and View types.\n \n---  Vector types are defined in the GNAT.Altivec.Vector_Types package\n+--  Vector types are available through the Vector_Types and Vector_Operations\n+--  packages, which implement the core binding to the AltiVec API, as\n+--  described in [PIM-2.1 data types] and [PIM-4 AltiVec operations and\n+--  predicates].\n \n---  On these types, users can apply the Altivec operations defined in\n---  GNAT.Altivec.Vector_Operations. Their layout is opaque and may vary across\n---  configurations, for it is typically target-endianness dependant.\n+--  The layout of Vector objects is dependant on the target machine\n+--  endianness, and View types were devised to offer a higher level user\n+--  interface. With Views, a vector of 4 uints (1, 2, 3, 4) is always declared\n+--  with a VUI_View := (Values => (1, 2, 3, 4)), element 1 first, natural\n+--  notation to denote the element values, and indexed notation is available\n+--  to access individual elements.\n \n---  Vector_Types and Vector_Operations implement the core binding to the\n---  AltiVec API, as described in [PIM-2.1 data types] and [PIM-4 AltiVec\n---  operations and predicates].\n-\n---  View types are defined in the GNAT.Altivec.Vector_Views package\n-\n---  These types do not represent Altivec vectors per se, in the sense that the\n+--  View types do not represent Altivec vectors per se, in the sense that the\n --  Altivec_Operations are not available for them. They are intended to allow\n --  Vector initializations as well as access to the Vector component values.\n \n@@ -123,6 +123,9 @@\n --  The \"hard\" version would map to real AltiVec instructions via GCC builtins\n --  and inlining.\n \n+--  See the \"Design Notes\" section below for additional details on the\n+--  internals.\n+\n -------------------\n -- Example usage --\n -------------------\n@@ -425,3 +428,339 @@ private\n    CR6_LT_REV : constant := 3;\n \n end GNAT.Altivec;\n+\n+--------------------\n+--  Design Notes  --\n+--------------------\n+\n+------------------------\n+-- General principles --\n+------------------------\n+\n+--  The internal organization has been devised from a number of driving ideas:\n+\n+--  o From the clients standpoint, the two versions of the binding should be\n+--    as easily exchangable as possible,\n+\n+--  o From the maintenance standpoint, we want to avoid as much code\n+--    duplication as possible.\n+\n+--  o From both standpoints above, we want to maintain a clear interface\n+--    separation between the base bindings to the Motorola API and the\n+--    additional facilities.\n+\n+--  The identification of the low level interface is directly inspired by the\n+--  the base API organization, basically consisting of a rich set of functions\n+--  around a core of low level primitives mapping to AltiVec instructions.\n+\n+--  See for instance \"vec_add\" in [PIM-4.4 Generic and Specific AltiVec\n+--  operations]: no less than six result/arguments combinations of byte vector\n+--  types map to \"vaddubm\".\n+\n+--  The \"hard\" version of the low level primitives map to real AltiVec\n+--  instructions via the corresponding GCC builtins. The \"soft\" version is\n+--  a software emulation of those.\n+\n+---------------------------------------\n+-- The Low_Level_Vectors abstraction --\n+---------------------------------------\n+\n+--  The AltiVec C interface spirit is to map a large set of C functions down\n+--  to a much smaller set of AltiVec instructions, most of them operating on a\n+--  set of vector data types in a transparent manner. See for instance the\n+--  case of vec_add, which maps six combinations of result/argument types to\n+--  vaddubm for signed/unsigned/bool variants of 'char' components.\n+\n+--  The GCC implementation of this idiom for C/C++ is to setup builtins\n+--  corresponding to the instructions and to expose the C user function as\n+--  wrappers around those builtins with no-op type conversions as required.\n+--  Typically, for the vec_add case mentioned above, we have (altivec.h):\n+--\n+--    inline __vector signed char\n+--    vec_add (__vector signed char a1, __vector signed char a2)\n+--    {\n+--      return (__vector signed char)\n+--        __builtin_altivec_vaddubm ((__vector signed char) a1,\n+--                                   (__vector signed char) a2);\n+--    }\n+\n+--    inline __vector unsigned char\n+--    vec_add (__vector __bool char a1, __vector unsigned char a2)\n+--    {\n+--      return (__vector unsigned char)\n+--        __builtin_altivec_vaddubm ((__vector signed char) a1,\n+--                                   (__vector signed char) a2);\n+--    }\n+\n+--  The central idea for the Ada bindings is to leverage on the existing GCC\n+--  architecture, with the introduction of a Low_Level_Vectors abstraction.\n+--  This abstaction acts as a representative of the vector-types and builtins\n+--  compiler interface for either the Hard or the Soft case.\n+\n+--  For the Hard binding, Low_Level_Vectors exposes data types with a GCC\n+--  internal translation identical to the \"vector ...\" C types, and a set of\n+--  subprograms mapping straight to the internal GCC builtins.\n+\n+--  For the Soft binding, Low_Level_Vectors exposes the same set of types\n+--  and subprograms, with bodies simulating the instructions behavior.\n+\n+--  Vector_Types/Operations \"simply\" bind the user types and operations to\n+--  some Low_Level_Vectors implementation, selected in accordance with the\n+--  target\n+\n+--  To achieve a complete Hard/Soft independence in the Vector_Types and\n+--  Vector_Operations implementations, both versions of the low level support\n+--  are expected to expose a number of facilities:\n+\n+--  o Private data type declarations for base vector representations embedded\n+--    in the user visible vector types, that is:\n+\n+--      LL_VBC, LL_VUC and LL_VSC\n+--        for vector_bool_char, vector_unsigned_char and vector_signed_char\n+\n+--      LL_VBS, LL_VUS and LL_VSS\n+--        for vector_bool_short, vector_unsigned_short and vector_signed_short\n+\n+--      LL_VBI, LL_VUI and LL_VSI\n+--        for vector_bool_int, vector_unsigned_int and vector_signed_int\n+\n+--    as well as:\n+\n+--      LL_VP for vector_pixel and LL_VF for vector_float\n+\n+--  o Primitive operations corresponding to the AltiVec hardware instruction\n+--    names, like \"vaddubm\". The whole set is not described here. The actual\n+--    sets are inspired from the GCC builtins which are invoked from GCC's\n+--    \"altivec.h\".\n+\n+--  o An LL_Altivec convention identifier, specifying the calling convention\n+--    to be used to access the aforementioned primitive operations.\n+\n+--  Besides:\n+\n+--  o Unchecked_Conversion are expected to be allowed between any pair of\n+--    exposed data types, and are expected to have no effect on the value\n+--    bit patterns.\n+\n+-------------------------\n+-- Vector views layout --\n+-------------------------\n+\n+--  Vector Views combine intuitive user level ordering for both elements\n+--  within a vector and bytes within each element. They basically map to an\n+--  array representation where array(i) always represents element (i), in the\n+--  natural target representation. This way, a user vector (1, 2, 3, 4) is\n+--  represented as:\n+\n+--                                                       Increasing Addresses\n+--  ------------------------------------------------------------------------->\n+\n+--  | 0x0 0x0 0x0 0x1 | 0x0 0x0 0x0 0x2 | 0x0 0x0 0x0 0x3 | 0x0 0x0 0x0 0x4 |\n+--  | V (0), BE       | V (1), BE       | V (2), BE       | V (3), BE       |\n+\n+--  on a big endian target, and as:\n+\n+--  | 0x1 0x0 0x0 0x0 | 0x2 0x0 0x0 0x0 | 0x3 0x0 0x0 0x0 | 0x4 0x0 0x0 0x0 |\n+--  | V (0), LE       | V (1), LE       | V (2), LE       | V (3), LE       |\n+\n+--  on a little-endian target\n+\n+-------------------------\n+-- Vector types layout --\n+-------------------------\n+\n+--  In the case of the hard binding, the layout of the vector type in\n+--  memory is documented by the Altivec documentation. In the case of the\n+--  soft binding, the simplest solution is to represent a vector as an\n+--  array of components. This representation can depend on the endianness.\n+--  We can consider three possibilities:\n+\n+--  * First component at the lowest address, components in big endian format.\n+--  It is the natural way to represent an array in big endian, and it would\n+--  also be the natural way to represent a quad-word integer in big endian.\n+\n+--  Example:\n+\n+--  Let V be a vector of unsigned int which value is (1, 2, 3, 4). It is\n+--  represented as:\n+\n+--                                                           Addresses growing\n+--  ------------------------------------------------------------------------->\n+--  | 0x0 0x0 0x0 0x1 | 0x0 0x0 0x0 0x2 | 0x0 0x0 0x0 0x3 | 0x0 0x0 0x0 0x4 |\n+--  | V (0), BE       | V (1), BE       | V (2), BE       | V (3), BE       |\n+\n+--  * First component at the lowest address, components in little endian\n+--  format. It is the natural way to represent an array in little endian.\n+\n+--  Example:\n+\n+--  Let V be a vector of unsigned int which value is (1, 2, 3, 4). It is\n+--  represented as:\n+\n+--                                                           Addresses growing\n+--  ------------------------------------------------------------------------->\n+--  | 0x1 0x0 0x0 0x0 | 0x2 0x0 0x0 0x0 | 0x3 0x0 0x0 0x0 | 0x4 0x0 0x0 0x0 |\n+--  | V (0), LE       | V (1), LE       | V (2), LE       | V (3), LE       |\n+\n+--  * Last component at the lowest address, components in little endian format.\n+--  It is the natural way to represent a quad-word integer in little endian.\n+\n+--  Example:\n+\n+--  Let V be a vector of unsigned int which value is (1, 2, 3, 4). It is\n+--  represented as:\n+\n+--                                                           Addresses growing\n+--  ------------------------------------------------------------------------->\n+--  | 0x4 0x0 0x0 0x0 | 0x3 0x0 0x0 0x0 | 0x2 0x0 0x0 0x0 | 0x1 0x0 0x0 0x0 |\n+--  | V (3), LE       | V (2), LE       | V (1), LE       | V (0), LE       |\n+\n+--  There is actually a fourth case (components in big endian, first\n+--  component at the lowest address), but it does not have any interesting\n+--  properties: it is neither the natural way to represent a quad-word on any\n+--  machine, nor the natural way to represent an array on any machine.\n+\n+--  Example:\n+\n+--  Let V be a vector of unsigned int which value is (1, 2, 3, 4). It is\n+--  represented as:\n+\n+--                                                           Addresses growing\n+--  ------------------------------------------------------------------------->\n+--  | 0x0 0x0 0x0 0x4 | 0x0 0x0 0x0 0x3 | 0x0 0x0 0x0 0x2 | 0x0 0x0 0x0 0x1 |\n+--  | V (3), BE       | V (2), BE       | V (1), BE       | V (0), BE       |\n+\n+--  Most of the Altivec operations are specific to a component size, and\n+--  can be implemented with any of these three formats. But some operations\n+--  are defined by the same Altivec primitive operation for different type\n+--  sizes:\n+\n+--  * operations doing arithmetics on a complete vector, seen as a quad-word;\n+--  * operations dealing with memory.\n+\n+--  Operations on a complete vector:\n+--  --------------------------------\n+\n+--  Examples:\n+\n+--  vec_sll/vsl : shift left on the entire vector.\n+--  vec_slo/vslo: shift left on the entire vector, by octet.\n+\n+--  Those operations works on vectors seens as a quad-word.\n+--  Let us suppose that we have a conversion operation named To_Quad_Word\n+--  for converting vector types to a quad-word.\n+\n+--  Let A be a Altivec vector of 16 components:\n+--  A = (A(0), A(1), A(2), A(3), ... , A(14), A(15))\n+--  Let B be a Altivec vector of 8 components verifying:\n+--  B = (A(0) |8| A(1), A(2) |8| A(3), ... , A(14) |8| A(15))\n+--  Let C be a Altivec vector of 4 components verifying:\n+--  C = (A(0)  |8| A(1)  |8| A(2)  |8| A(3), ... ,\n+--       A(12) |8| A(13) |8| A(14) |8| A(15))\n+\n+--  (definition: |8| is the concatenation operation between two bytes;\n+--  i.e. 0x1 |8| 0x2 = 0x0102)\n+\n+--  According to [PIM - 4.2 byte ordering], we have the following property:\n+--  To_Quad_Word (A) = To_Quad_Word (B) = To_Quad_Word (C)\n+\n+--  Let To_Type_Of_A be a conversion operation from the type of B to the\n+--  type of A.  The quad-word operations are only implemented by one\n+--  Altivec primitive operation.  That means that, if QW_Operation is a\n+--  quad-word operation, we should have:\n+--  QW_Operation (To_Type_of_A (B)) = QW_Operation (A)\n+\n+--  That is true iff:\n+--  To_Quad_Word (To_Type_of_A (B)) = To_Quad_Word (A)\n+\n+--  As To_Quad_Word is a bijection. we have:\n+--  To_Type_of_A (B) = A\n+\n+--  resp. any combination of A, B, C:\n+--  To_Type_of_A (C) = A\n+--  To_Type_of_B (A) = B\n+--  To_Type_of_C (B) = C\n+--  ...\n+\n+--  Making sure that the properties described above are verified by the\n+--  conversion operations between vector types has different implications\n+--  depending on the layout of the vector types:\n+--  * with format 1 and 3: only a unchecked conversion is needed;\n+--  * with format 2 and 4: some reorganisation is needed for conversions\n+--  between vector types with different component sizes; that has a cost on the\n+--  efficiency, plus the complexity of having different memory pattern for\n+--  the same quad-word value, depending on the type.\n+\n+--  Operation dealing with memory:\n+--  ------------------------------\n+\n+--  These operations are either load operation (vec_ld and the\n+--  corresponding primitive operation: vlx) or store operation (vec_st\n+--  and the corresponding primitive operation: vstx).\n+\n+--  According to [PIM 4.4 - vec_ld], those operations take in input\n+--  either an access to a vector (e.g. a const_vector_unsigned_int_ptr)\n+--  or an access to a flow of components (e.g. a const_unsigned_int_ptr),\n+--  relying on the same Altivec primitive operations. That means that both\n+--  should have the same representation in memory.\n+\n+--  For the stream, it is easier to adopt the format of the target. That\n+--  means that, in memory, the components of the vector should also have the\n+--  format of the target. meaning that we will prefer:\n+--  * On a big endian target: format 1 or 4\n+--  * On a little endian target: format 2 or 3\n+\n+--  Conclusion:\n+--  -----------\n+\n+--  To take into consideration the constraint brought about by the routines\n+--  operating on quad-words and the routines operating on memory, the best\n+--  choice seems to be:\n+\n+--  * On a big endian target: format 1;\n+--  * On a little endian target: format 3.\n+\n+--  Those layout choices are enforced by GNAT.Altivec.Low_Level_Conversions,\n+--  which is the endianness-dependant unit providing conversions between\n+--  vector views and vector types.\n+\n+----------------------\n+--  Layouts summary --\n+----------------------\n+\n+--  For a user abstract vector of 4 uints (1, 2, 3, 4), increasing\n+--  addresses from left to right:\n+\n+--  =========================================================================\n+--                 BIG ENDIAN TARGET MEMORY LAYOUT for (1, 2, 3, 4)\n+--  =========================================================================\n+\n+--                                    View\n+--  -------------------------------------------------------------------------\n+--  | 0x0 0x0 0x0 0x1 | 0x0 0x0 0x0 0x2 | 0x0 0x0 0x0 0x3 | 0x0 0x0 0x0 0x4 |\n+--  | V (0), BE       | V (1), BE       | V (2), BE       | V (3), BE       |\n+--  -------------------------------------------------------------------------\n+\n+--                                   Vector\n+--  -------------------------------------------------------------------------\n+--  | 0x0 0x0 0x0 0x1 | 0x0 0x0 0x0 0x2 | 0x0 0x0 0x0 0x3 | 0x0 0x0 0x0 0x4 |\n+--  | V (0), BE       | V (1), BE       | V (2), BE       | V (3), BE       |\n+--  -------------------------------------------------------------------------\n+\n+--  =========================================================================\n+--              LITTLE ENDIAN TARGET MEMORY LAYOUT for (1, 2, 3, 4)\n+--  =========================================================================\n+\n+--                                    View\n+--  -------------------------------------------------------------------------\n+--  | 0x1 0x0 0x0 0x0 | 0x2 0x0 0x0 0x0 | 0x3 0x0 0x0 0x0 | 0x4 0x0 0x0 0x0 |\n+--  | V (0), LE       | V (1), LE       | V (2), LE       | V (3), LE       |\n+\n+--                                    Vector\n+--  -------------------------------------------------------------------------\n+--  | 0x4 0x0 0x0 0x0 | 0x3 0x0 0x0 0x0 | 0x2 0x0 0x0 0x0 | 0x1 0x0 0x0 0x0 |\n+--  | V (3), LE       | V (2), LE       | V (1), LE       | V (0), LE       |\n+--  -------------------------------------------------------------------------\n+\n+--  These layouts are common to both the soft and hard implementations on\n+--  Altivec capable targets."}, {"sha": "69f58183e26362ac715b120bc1316153fc1ebf3c", "filename": "gcc/ada/sem_ch12.adb", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0478a53cb286eeb251e891e93609a714da9724c/gcc%2Fada%2Fsem_ch12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0478a53cb286eeb251e891e93609a714da9724c/gcc%2Fada%2Fsem_ch12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch12.adb?ref=f0478a53cb286eeb251e891e93609a714da9724c", "patch": "@@ -12080,14 +12080,20 @@ package body Sem_Ch12 is\n          --  for static matching has failed. The case where both the component\n          --  type and the array type are separate formals, and the component\n          --  type is a private view may also require special checking in\n-         --  Subtypes_Match.\n+         --  Subtypes_Match. Finally, we assume that a child instance where\n+         --  the component type comes from a formal of a parent instance is\n+         --  correct because the generic was correct. A more precise check\n+         --  seems too complex to install???\n \n          if Subtypes_Match\n            (Component_Type (A_Gen_T), Component_Type (Act_T))\n              or else\n                Subtypes_Match\n                  (Find_Actual_Type (Component_Type (A_Gen_T), A_Gen_T),\n                   Component_Type (Act_T))\n+            or else\n+              (not Inside_A_Generic\n+                 and then Is_Child_Unit (Scope (Component_Type (A_Gen_T))))\n          then\n             null;\n          else"}, {"sha": "c9a02437e70fa9882bca3a4207ac9ef09515e25e", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0478a53cb286eeb251e891e93609a714da9724c/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0478a53cb286eeb251e891e93609a714da9724c/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=f0478a53cb286eeb251e891e93609a714da9724c", "patch": "@@ -971,7 +971,7 @@ package body Sem_Prag is\n                      --  (SPARK RM 6.1.4).\n \n                      elsif Is_Single_Task_Object (Item_Id)\n-                       and then Is_CCT_Instance (Item_Id, Spec_Id)\n+                       and then Is_CCT_Instance (Etype (Item_Id), Spec_Id)\n                      then\n                         Current_Task_Instance_Seen;\n                      end if;\n@@ -2218,7 +2218,7 @@ package body Sem_Prag is\n                --  is the same single type (SPARK RM 6.1.4).\n \n                elsif Is_Single_Concurrent_Object (Item_Id)\n-                 and then Is_CCT_Instance (Item_Id, Spec_Id)\n+                 and then Is_CCT_Instance (Etype (Item_Id), Spec_Id)\n                then\n                   --  Pragma [Refined_]Global associated with a protected\n                   --  subprogram cannot mention the current instance of a"}, {"sha": "465d1412e3f325228c5a8c3af89eba0dc40b4a05", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 9, "deletions": 30, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0478a53cb286eeb251e891e93609a714da9724c/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0478a53cb286eeb251e891e93609a714da9724c/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=f0478a53cb286eeb251e891e93609a714da9724c", "patch": "@@ -12391,38 +12391,17 @@ package body Sem_Util is\n       Context_Id : Entity_Id) return Boolean\n    is\n    begin\n-      pragma Assert\n-        (Is_Entry (Context_Id)\n-           or else\n-         Ekind_In (Context_Id, E_Function,\n-                               E_Procedure,\n-                               E_Protected_Type,\n-                               E_Task_Type)\n-           or else\n-         Is_Single_Concurrent_Object (Context_Id));\n-\n-      --  When the reference denotes a single protected type, the context is\n-      --  either a protected subprogram or its body.\n-\n-      if Is_Single_Protected_Object (Ref_Id) then\n-         return Scope_Within (Context_Id, Etype (Ref_Id));\n-\n-      --  When the reference denotes a single task type, the context is either\n-      --  the same type or if inside the body, the anonymous task object.\n-\n-      elsif Is_Single_Task_Object (Ref_Id) then\n-         if Is_Single_Task_Object (Context_Id) then\n-            return Context_Id = Ref_Id;\n-\n-         elsif Ekind (Context_Id) = E_Task_Type then\n-            return Context_Id = Etype (Ref_Id);\n-\n-         else\n-            return Scope_Within_Or_Same (Context_Id, Etype (Ref_Id));\n-         end if;\n+      pragma Assert (Ekind_In (Ref_Id, E_Protected_Type, E_Task_Type));\n \n+      if Is_Single_Task_Object (Context_Id) then\n+         return Scope_Within_Or_Same (Etype (Context_Id), Ref_Id);\n       else\n-         pragma Assert (Ekind_In (Ref_Id, E_Protected_Type, E_Task_Type));\n+         pragma Assert\n+           (Is_Entry (Context_Id)\n+              or else\n+            Ekind_In (Context_Id, E_Function,\n+                                  E_Procedure,\n+                                  E_Task_Type));\n \n          return Scope_Within_Or_Same (Context_Id, Ref_Id);\n       end if;"}, {"sha": "a17179f382a508804d81d140941b38d514678c11", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0478a53cb286eeb251e891e93609a714da9724c/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0478a53cb286eeb251e891e93609a714da9724c/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=f0478a53cb286eeb251e891e93609a714da9724c", "patch": "@@ -1297,11 +1297,11 @@ package Sem_Util is\n    --  Returns true if the last character of E is Suffix. Used in Assertions.\n \n    function Has_Tagged_Component (Typ : Entity_Id) return Boolean;\n-   --  Returns True if Typ is a composite type (array or record) which is\n-   --  either itself a tagged type, or has a component (recursively) which is\n-   --  a tagged type. Returns False for non-composite type, or if no tagged\n-   --  component is present. This function is used to check if \"=\" has to be\n-   --  expanded into a bunch component comparisons.\n+   --  Returns True if Typ is a composite type (array or record) that is either\n+   --  a tagged type or has a subcomponent that is tagged. Returns False for a\n+   --  noncomposite type, or if no tagged subcomponents are present. This\n+   --  function is used to check if \"=\" has to be expanded into a bunch\n+   --  component comparisons.\n \n    function Has_Undefined_Reference (Expr : Node_Id) return Boolean;\n    --  Given arbitrary expression Expr, determine whether it contains at\n@@ -1480,8 +1480,9 @@ package Sem_Util is\n      (Ref_Id     : Entity_Id;\n       Context_Id : Entity_Id) return Boolean;\n    --  Subsidiary to the analysis of pragmas [Refined_]Depends and [Refined_]\n-   --  Global. Determine whether entity Ref_Id denotes the current instance of\n-   --  a concurrent type. Context_Id denotes the associated context where the\n+   --  Global. Determine whether entity Ref_Id (which must represent either\n+   --  a protected type or a task type) denotes the current instance of a\n+   --  concurrent type. Context_Id denotes the associated context where the\n    --  pragma appears.\n \n    function Is_Child_Or_Sibling"}]}